# [清华集训 2012] 串珠子

## 题目描述

铭铭有 $n$ 个十分漂亮的珠子和若干根颜色不同的绳子。现在铭铭想用绳子把所有的珠子连成一个整体。

现在已知所有的珠子互不相同，用整数 $1$ 到 $n$ 编号。对于第 $i$ 个珠子和第 $j$ 个珠子，可以选择不用绳子连接，或者在 $c_{i,j}$ 根不同颜色的绳子中选择一根将它们连接。如果把珠子看作点，把绳子看作边，将所有珠子连成一个整体即为所有点构成一个连通图。特别地，珠子不能和自己连接。

铭铭希望知道总共有多少种不同的方案将所有珠子连成一个整体。由于答案可能很大，因此只需输出答案对 $1000000007$ 取模的结果。

## 说明/提示

#### 样例解释
按每对珠子是否连接有以下四类连接方法。

![Picture](https://s2.ax1x.com/2020/01/19/1C1K1I.png)

每类连接方法包含的方法数为包含的边对应的绳子的 $c_{i,j}$ 之积。

其中图(1)有 $2\times3\times4=24$ 种，图(2)有 $2\times4=8$ 种，图(3)有 $2\times3=6$ 种，图(4)有 $3\times4=12$ 种。共 $50$ 种。

#### 数据规模和约定
对于 $100\%$ 的数据，$n$ 为正整数，所有的 $c_{i,j}$ 为非负整数且不超过 $1000000007$。保证 $c_{i,j}=c_{j,i}$。每组数据的 $n$ 值如下表所示。

|编号|1|2|3|4|5|6|7|8|9|10|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|$n$|$8$|$9$|$9$|$10$|$11$|$12$|$13$|$14$|$15$|$16$|

## 样例 #1

### 输入

```
3
0 2 3
2 0 4
3 4 0
```

### 输出

```
50```

# 题解

## 作者：George1123 (赞：51)

**广告：[blog$\diamondsuit$](https://www.luogu.com.cn/blog/Wendigo/)**

[P5933 【\[清华集训2012\]串珠子】](https://www.luogu.com.cn/problem/P5933)

### 此题算法：状压 $dp$

看到 $n\le 16$ 即可想到状压做法：

用 $dp[k]$ 表示 $k$ 这个点集的答案（联通连边方案数）。

用 $f[k]$ 表示 $k$ 这个点集的连边方案数。

用 $\spadesuit(k)$ 表示 $k$ 这个点集不连通连边方案数。

这时求 $\spadesuit(k)$ 需要先找一个 $k$ 中的点 $p$（为了确保计算 $\spadesuit(k)$ 时拆成的 $C_ki$ 有点，且拆分方案不会重复计算），求出 $frm=C_k\{p\}$。

（其中 $C$ 为补集符号，下同。） 

可推算知 $\spadesuit(k)=\sum_{i\in frm} f[i]\times dp[C_ki]$。

（拆出 $C_ki$，剩下的点随便拆不拆。）

$\therefore f[k]=\Pi_{(i<j)\in k}(c[i][j]+1)$

$\therefore dp[k]=f[k]-\spadesuit(k)$


于是，整个状压 $dp$ 就写完了，答案为 $dp[2^n-1]$。


## 以下是代码 $+$ 注释

```cpp
#include <bits/stdc++.h>
using namespace std;
#define lng long long
#define fo(i,a,b) for(int i=a;i<=b;i++)
#define of(i,b,a) for(int i=b;i>=a;i--)
const int N=18;
const int M=1e9+7;
int d(){int x;scanf("%d",&x);return x;}
int n,c[N][N],cnt; lng f[1<<N],dp[1<<N];
int main(){
	n=d(),cnt=(1<<n)-1;
	fo(i,1,n)fo(j,1,n) c[i][j]=d();
	fo(k,0,cnt){ f[k]=1;
		fo(i,1,n)if(k&(1<<i-1))
			fo(j,i+1,n) if(k&(1<<j-1))
				f[k]=f[k]*(c[i][j]+1)%M; //get f[]
	}
	fo(k,1,cnt){ dp[k]=f[k];
		int frm=k^(k&-k);  //p=lowbit(k)=(k&-x)
		for(int i=frm;i;i=(i-1)&frm) //枚举frm的子集i
			dp[k]=(dp[k]-f[i]*dp[k^i]%M+M)%M; //get ♠()
	}
	printf("%lld\n",dp[cnt]);
	return 0;
}
```

代码很短思维难度大就是状压 $dp$ 题的特点。

**写题解不易，为我点个赞吧！**

谢谢大家! !


---

## 作者：nkxjlym (赞：17)

萌新第一次写题解，有什么不足之处欢迎大家指出！



大概翻了翻题解，发现大部分都是用的状压dp+枚举子集，时间复杂度 $O(3^n)$。

这里提供一个 $O(n^2 2^n)$ 的做法，实测可以在 2s 内通过 $n<=20$ 的数据，目前排全站第一。

**前置知识：快速莫比乌斯变换、子集卷积**

前面的推式子都差不多，但这里还是说一下。

### 第一步，推式子

我们定义：

$f_S$ 表示$S$集合构成连通图的方案数；

$g_S$ 表示$S$集合乱连的总方案（即不保证连通）。

我们通过递推的方式求 $g$ ：

$$g_S=g_{S'} \prod\limits_{q\in S'} (c_{p,q}+1)$$

其中 $S'$ 为 $S$ 中去掉任意某元素 $p$ 所得，“ $+1$ ”即可以不连。

直接求连通方案 $f$ 不好求，但我们考虑算不连通方案，再用总方案去减。

对于不连通方案，**只要图有两个以上的连通块，这个图就不连通了**。我们抓住这个特点，考虑枚举其中一个连通块，其他的点任其自生自灭，只要不连向我们枚举的连通块，随便连，这样的图肯定是不连通的。

但直接枚举可能算重，即我们现在枚举了一个连通块 $T$，之后枚举另一个连通块 $T'$ 时，$T$ 出现在了自生自灭的那些点中，这显然会重复计算。

只要我们先后枚举的连通块总是**有交**，就一定不会算重了。考虑从 $S$ 中抽出一个点 $p$，枚举的所有连通块中均包含 $p$，就不会出现上述情况。跟上个式子一样，$S'$ 为 $S$ 中去掉任意某元素 $p$ 所得：

$$f_S=g_S-\sum\limits_{T\subset S'}g_{S'-T}f_{T\cup \{p\}}$$

~~这里图方便用减号代替了补集符号，大家看的懂就行。~~

做到这一步，已经可以用 $O(3^n)$ 枚举子集做了。下面我将对式子做一些变换，来做到更优复杂度。

### 第二步，一点点变换

看着这个式子，是不是挺像子集卷积？那我们就把它变得更子集卷积。

注意到原式子中 $T$ 是不能取 $S'$ 的，于是我们移项并合并：

$$\sum\limits _{T\subseteq S'}g_{S'-T}f_{T\cup \{p\}} =g_S$$

其实式子已经变完了（真·一点点变换），但为了求出答案，我们改变一下 $p$ 的定义。

$p$ 可以是 $S$ 中的任意元素，于是我们钦定 $p$ 为 $S$ 中最高位元素，即 $p=highbit(S)$。

设总点数为 $n$，考虑 $S$ 取遍 $[2^{n-1},2^n-1]$，则 $p=2^{n-1}$，$S'\in [0,2^{n-1}-1]$ 。

回头看我们的式子，发现其实就是 $g$ 前半段与 $f$ 后半段子集卷积后变成了 $g$ 后半段。

这里设 $G_0$ 为 $g$ 前半段， $G_1$ 为后半段， $f$ 同理：

$$G_0*F_1=G_1$$

$$F_1=\frac{G1}{G0}$$

其中 $*$ 为子集卷积，除号即为其逆运算。

而 $g$ 是已知的，且答案为 $f_{2^n-1}$ 在 $f$ 后半段中，于是就在 $O(n^2 2^n)$ 完成了此题。

顺带一提，子集卷积求逆直接分别对 $G_0$ , $G_1$ FMT，对位做多项式除法，最后 IFMT 即可。由于项数很少只有 $n$，暴力除即可。

### Code:

```cpp
#include<bits/stdc++.h>
#define R register int
#define ll long long
#define I inline
using namespace std;
const int N=20,M=1<<N,P=1e9+7;
int n,l,c[N][N],g[M],pc[M];//pc即popcount，二进制中1的个数
I void pls(int &a,int b){a+=b;if(a>=P)a-=P;}
I void mns(int &a,int b){a-=b;if(a<0)a+=P;}
struct poly
{
	int a[N];
	void operator/=(const poly &p)
	{
		for(R i=1;i<=n;i++)
		{
			for(R j=0;j<i;j++)
				a[i]=(a[i]-1ll*a[j]*p.a[i-j])%P;
			if(a[i]<0)a[i]+=P;
		}
	}
	void operator+=(const poly &p){for(R i=0;i<=n;i++)pls(a[i],p.a[i]);}
	void operator-=(const poly &p){for(R i=0;i<=n;i++)mns(a[i],p.a[i]);}
};
poly g0[M>>1],g1[M>>1];
void FMT(poly *s)
{
	for(R i=1;i<l;i<<=1)
		for(R j=0;j<l;j+=i<<1)
			for(R k=j;k<j+i;k++)
				s[k+i]+=s[k];
}
void IFMT(poly *s)
{
	for(R i=1;i<l;i<<=1)
		for(R j=0;j<l;j+=i<<1)
			for(R k=j;k<j+i;k++)
				s[k+i]-=s[k];
}
int main()
{
	int rn,rl;
	scanf("%d",&rn);n=rn-1;//g, f拆成两半的长度处理
	l=1<<n;rl=1<<rn;
	for(R i=0;i<rn;i++)
		for(R j=0;j<rn;j++)
			scanf("%d",c[i]+j);
	g[0]=1;
	for(R i=1,j,k;i<rl;i++)
	{
		for(j=0;!(i>>j&1);j++);
		g[i]=g[i&i-1];
		for(k=j+1;i>>k;k++)
			if(i>>k&1)g[i]=g[i]*(c[j][k]+1ll)%P;
	}
	pc[0]=-1;//这里图方便把初值设为了-1，但其实后面会变成0
	for(R i=0;i<l;i++)
	{
		pc[i]=pc[i&i-1]+1;
		g0[i].a[pc[i]]=g[i];
		g1[i].a[pc[i]]=g[i|l];
		//注意这里占位多项式的处理，由于把g拆成了两段，后半段popcount应为原来的-1
	}
	FMT(g0);FMT(g1);
	for(R i=0;i<l;i++)g1[i]/=g0[i];
	IFMT(g1);
	printf("%d",g1[l-1].a[n]);
	return 0;
}

```



---

## 作者：vectorwyx (赞：12)

## upd：修改了一处小错误，感谢@[syksykCCC](https://www.luogu.com.cn/user/51971)神仙指正

如果只是求 $n$ 个点无向连通图的个数，做法是令 $f_{i}$ 表示 $i$ 个点的无向连通图的个数，$g_{i}$ 表示 $i$ 个点的无向不连通图的个数，$tot_{i}$ 表示 $i$ 个点的无向图个数。$tot_{i}$ 很好求。求 $g_{i}$ 我们只需要枚举点 $i$ 所在连通块的大小，即 $g_{i}=\sum_{j=1}^{i-1} C_{i-1}^{j-1}\times f_{j}\times tot_{j-i},f_{i}=tot_{i}-g_{i}$。

换到这一题上，因为点与点之间的连边的种数是不一样的，因此我们不能只枚举连通块的大小，还要枚举连通块包含哪些点。再看到 $n\le16$，自然想到使用状压 dp 求解。

令 $f_{i},g_{i},tot_{i}$ 表示 $i$ 所代表的点集的无向连通图/无向不连通图/无向图的个数，先求 $tot_{i}$，再求 $g_{i}$。

对于 $i$ 中的任两点 $p_{1},p_{2}$，有两种情况：连边（$c_{p_{1},p_{2}}$ 种选择）或不连边（$1$ 种选择），由乘法原理可得 $tot_{i}=\prod_{p_{1}\in i}\prod_{p_{2}\in i}(c_{p_{1},p_{2}+1)}$。

$g_{i}$ 的转移方程与上面那个类似，随便选一个点 $p\in i$，令 $S$=$i-\{p\}$，也就是说 $S$ 为 $i$ 去掉 $p$ 后得到的点集。然后枚举 $S$ 的非空子集 $S1$，把 $S1$ 关于 $S$ 的补集 $S2$ 并上 $\{p\}$ 的结果作为 $p$ 所在连通块的点集，即 $g_{i}=\sum_{S1\subset S,S1\not= \varnothing}tot_{i}\times f_{S2\cup\{p\}}$。最后的答案就是 $f_{2^{n}-1}$。总时间复杂度为 $O(3^{n}+2^{n}n^{2})$

代码如下（点个赞再走吧QAQ，谢谢您！）：
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
#define lowbit(x) x&(-x)
#define ll long long
#define fo(i,x,y) for(int i=x;i<=y;++i)
#define go(i,x,y) for(int i=x;i>=y;--i)
using namespace std;
inline int read(){ int x=0,fh=1; char ch=getchar(); while(!isdigit(ch)){ if(ch=='-') fh=-1; ch=getchar(); } while(isdigit(ch)){ x=(x<<1)+(x<<3)+ch-'0'; ch=getchar(); } return x*fh; }

const int N=1<<16,yrz=1e9+7;
int f[N],g[N],tot[N],n,c[20][20];//f[i]:连通 g[i]:不连通 

int main(){
	cin>>n;
	fo(i,1,n) fo(j,1,n) c[i][j]=read();
	int pw=(1<<n)-1;
	fo(i,1,pw){
		int p=-1,bit[20],top=0;
		go(j,n-1,0) if(i&(1<<j)){
			p=(1<<j);
			bit[++top]=j+1;
		}
		tot[i]=1;
		fo(j,1,top)
			fo(k,j+1,top) tot[i]=1ll*tot[i]*(c[bit[j]][bit[k]]+1)%yrz;
		int S=i-p;
		for(int S1=S;S1;S1=(S1-1)&S){
			int S2=(i^S1)|p;
			g[i]=(g[i]+1ll*f[S2]*tot[S1])%yrz;
		}
		f[i]=(tot[i]+yrz-g[i])%yrz;
		//printf("%d:%d %d %d\n",i,tot[i],f[i],g[i]);
	}
	cout<<f[pw];
	return 0;
}
/*
-------------------------------------------------
*/
```


---

## 作者：MikukuOvO (赞：10)

考虑$f[i]$表示状态为$i$的连边方案数，$g[i]$表示状态为$i$的能使得联通的连边方案数，$t[i]$表示状态为$i$使得不连通的方案数。

首先$f[i]$是比较好求的，就是$f[i]=\prod_{(u<v)\in k}(c[u][v]+1)$。

关于求$t[i]$，我们首先固定$i$中的一个点$p$，那么剩余的点要么与$p$联通，要么与$p$不连通。

假设和$p$联通的点集为$S$，不连通的点集为$T$，那么对于$t[i]$的贡献就是$g[S]\times f[T]$。

这样我们枚举子集转移即可，$g[i]=f[i]-t[i]$。

这里我解答一个问题，为什么$p$可以任意？

考虑实际上我们固定$p$点的意义，就是使得其余的所有点的状态只有两种，这样我们枚举子集转移就会做到不重不漏。

[$code$](https://captaindag.github.io/2020/04/05/%E6%B8%85%E5%8D%8E%E9%9B%86%E8%AE%AD2012-%E4%B8%B2%E7%8F%A0%E5%AD%90/)

---

## 作者：斜揽残箫 (赞：5)


upd ： 感谢 [fhq_treap](https://www.luogu.com.cn/user/138390) 的指正，修改了一些字母的意义。

## Solution

首先此题的数据范围很容易想到状压 DP。

首先，我们发现联通子图的方案数似乎不容易计算，考虑先求出不连通的子图数量，之后用全部的联通子图数量减去即可。

直接设 $f(S)$ 表示仅考虑二进制数 $S$ 表示的点，有多少连通子图。

先预处理一个 $g(S)$ 表示 $S$ 内的子图数量即可，$g(S) = \prod_{(i < j) \in S} a_{i,j} + 1$。

之后如何求出 $f_i$ 呢 ？

我们可以假设一个点 $P \in i$，与 $P$ 联通的点集是 $s$，不连通的点集是 $t$，所以对于 $f_i$ 的贡献是 $g_s \times f_t$，所以，我们枚举 $i$ 的子集直接转移即可，求出 $f_i = g_i - g_s \times f_t$。

于是就做完了，答案就是 $f_{2 ^ n - 1}$。

## Code

```
#include <cstdio>
#include <cmath>
#include <iostream>
#include <cstring>
#include <algorithm>
#define int long long
using namespace std;
const int Maxk = (1 << 16) + 20;
const int mod = 1000000007;
int a[20][20];
int n,N;
int g[Maxk],f[Maxk];
inline int read()
{
	int s = 0, f = 0;char ch = getchar();
	while (!isdigit(ch)) f |= ch == '-', ch = getchar();
	while (isdigit(ch)) s = s * 10 + (ch ^ 48), ch = getchar();
	return f ? -s : s;
}
signed main()
{
  n = read();
  N = (1 << n) - 1;
  for(int i = 1;i <= n;i ++) 
    for(int j = 1;j <= n;j ++)  
      a[i][j] = read();
  for(int S = 0;S <= N;S ++) {
    g[S] = 1;
    for(int i = 1;i <= n;i ++) {
      if(!(S & (1 << (i - 1)))) continue;
      for(int j = i + 1;j <= n;j ++) {
        if(!(S & (1 << (j - 1)))) continue;
        g[S] = (g[S] * (a[i][j] + 1) % mod + mod) % mod;
      }
    }
  }
  for(int i = 1;i <= N;i ++) {
    f[i] = g[i];
    int s = i ^ (i & -i);
    for(int j = s;j > 0;j = (j - 1) & s) {
      int t = i ^ j;
      f[i] = (f[i] - g[j] * f[t] % mod + mod) % mod;
    }
  }
  cout << f[N] << endl;
  return 0;
}
```

---

## 作者：nofind (赞：3)

## [题意](https://www.lydsy.com/JudgeOnline/problem.php?id=2560)

考虑经典问题:求n个点无向联通图的个数的解法:

$g[n]$表示n个点的无向图个数,$f[n]$表示n个点的无向联通图个数

$f[n]=g[n]-\sum\limits_{i=1}^{n-1}f[i]*g[n-i]*C_{n-1}^{i-1}$

即枚举1所在联通块大小,块内联通,其他随意,用总方案数减去

这题不能这么做,因为每个点之间边数不同,但是由于n很小,可以状压

$g[s]$表示当前点状态为$s$时,无向图个数

$g[s]=\prod\limits_{i,j\in s}c[i][j]+1$

$f[s]$表示当前点状态为$s$时,无向联通图个数

$f[s]=g[s]-f[t]*g[s\ xor\ t](lowbit(s)\in t,t!=s)$

code:
```
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define lowbit(x) (x&-x)
const int maxn=17;
const int mod=1e9+7;
int n;
int f[1<<maxn],g[1<<maxn];
int c[maxn][maxn];
signed main()
{
	scanf("%lld",&n);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			scanf("%lld",&c[i][j]);
	for(int s=0;s<(1<<n);s++)g[s]=1;
	for(int s=0;s<(1<<n);s++)
		for(int i=1;i<=n;i++)
			for(int j=i+1;j<=n;j++)
				if((s&(1<<(i-1)))&&(s&(1<<(j-1))))g[s]=g[s]*(c[i][j]+1)%mod;//+1->不选
	//for(int s=0;s<(1<<n);s++)printf("%d ",g[s]);
	for(int s=0;s<(1<<n);s++)
	{
		f[s]=g[s];
		for(int t=s;t;t=(t-1)&s)
			if((t&lowbit(s))&&t!=s)
				f[s]=(f[s]-f[t]*g[s^t]%mod+mod)%mod;
	}
	//for(int s=0;s<(1<<n);s++)printf("%d ",f[s]);
	printf("%lld",f[(1<<n)-1]);
	return 0;
}
```


---

## 作者：Dita (赞：1)

[题面](https://www.luogu.com.cn/problem/P5933)

**solution**

$dp$ 状态很显然，就是设 $f[s]$ 表示点集 $s$ 内所有点联通的方案数。

怎么求联通的方案数？

统计一个集合中所有点联通的方案数很难，但是可以用所有的连边情况 -  不连通的方案数的方案数就可以求出来了。

所有的连边情况：$g[s] = \prod (c_{i,j} + 1)(i, j\in s)$ （两点之间可以不选边，所以要+1）  

求不联通的的方案数？真的妙 = =

一个错误思路：枚举一个联通块 $t$，然后剩下的点可联通可不连通，这样就保证了这个联通块和其余点之间没有边，达到了总的图不连通。方案数为： $f[t]\times g[s - t]$ ，然后把枚举的答案相加就好。

这样可能会算重，因为枚举完一个联通块的时候计算一个方案，枚举另一个连通块的时候有可能会出现相同的情况，也会被记录答案。

**枚举一个点所在的连通块**，确定一个点 $p$ ，对于每种不同的方案，$p$ 点只可能在一个联通块内，枚举这个联通块 $T$ ，那么不连通的方案就是 $\sum f[T]\times g[s - T]$

转移式子就有了：$f[s] = g[s] - \sum f[T] \times g[s - T]$

下面代码实现的 $p$ 取的是最后一位的 $1$，在枚举子集时就可以做到这一点，就是转移式子有点不同。

**code**

```c++
/*
work by:Ariel_
*/
#include <iostream>
#include <cstring>
#include <cstdio>
#include <queue>
#include <algorithm>
#define int long long
#define rg register
using namespace std;
const int mod = 1e9 + 7;
int read(){
    int x = 0,f = 1; char c = getchar();
    while(c < '0'||c > '9') {if(c == '-') f = -1; c = getchar();}
    while(c >= '0' && c <= '9') {x = x*10 + c - '0'; c = getchar();}
    return x*f;
}
int n, g[1 << 18], f[1 << 18], c[17][17];
signed main(){
   n = read();
   for (int i = 1; i <= n; i++)
     for (int j = 1; j <= n; j++) c[i][j] = read();
   for (int S = 0; S <= (1 << n) - 1; S++) {
      g[S] = 1;
   	  for (int i = 1; i <= n; i++) {
   	    if(S & (1 << i - 1)){
   	      for (int j = i + 1; j <= n; j++) {
   	    	   if (S & (1 << j - 1)) 
			   g[S] = g[S] * (c[i][j] + 1) % mod;
		    }
	    }
	  }
   }
   for (int S = 1; S <= (1 << n) - 1; S++) {
      f[S] = g[S];
   	  int tmp = S ^ (S & -S);//因为是真子集，所以要先掉最后一位。  
	  for (int T = tmp; T; T = (T - 1) & tmp) {
   	       f[S] =  (f[S] - g[T] * f[S ^ T] % mod + mod) % mod;
	   }
   }
   printf("%lld", f[(1 << n) - 1]);
   puts("");
   return 0;
}
```



---

## 作者：BADFIVE (赞：1)

首先看到这道题，就想到了状压 dp，再看到 $n$ 的范围是 $8≤n≤16$，那就可以直接用状压了。   
**题意**：有 $n$ 个点的一张无向图，求所有连起来子图的乘积，注意是权值的乘积和。   
**思路**：我们用 $f[i]$ 来表示当它为 $i$ 时的数量(方案数),$dp[i]$ 来表示连起来的子图数量，再定义一个数来记录点集 $i$ 的所有子图的方案数，然后这个时间的复杂度为 $O(n^3)$。   
数组要注意开的范围，考虑实际上我们固定 $n$ 点的意义，就是使得其余的所有点的状态只有两种，这样我们枚举子集转移就会做到不多不少，考虑它所在的连通图的节点个数进行计数。   

参考代码：  
```cpp
#include <bits/stdc++.h>
using namespace std;
long long f[1<<18],dp[1<<18],c[18][18];
int main(){
	long long n,cnt=0;
	cin>>n;
	cnt=(1<<n)-1;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			cin>>c[i][j];
		}
	}
	for(int k=0;k<=cnt;k++){
		f[k]=1;
		for(int i=1;i<=n;i++){
			if(k&(1<<i-1)){
				for(int j=i+1;j<=n;j++){
					if(k&(1<<j-1)){
						f[k]=f[k]*(c[i][j]+1)%1000000007;记得%
					}
				
				}
			}
		}
	}
	for(int k=1;k<=cnt;k++){
		dp[k]=f[k];
		int arr=k^(k&-k);
		for(int i=arr;i;i=(i-1)&arr){
			dp[k]=(dp[k]-f[i]*dp[k^i]%1000000007+1000000007)%1000000007;//记得%
		}	
	}
	cout<<dp[cnt];
}
```


---

## 作者：zach0914 (赞：1)

# [12串珠子](https://www.luogu.com.cn/problem/P5933)

---

接下来我们把整道题的**主要思路**简要地梳理开来。

---

首先，我们先考虑最经典的问题（这经典吗？？？）：

~~旅行商问题~~

不，是与之类似的一类问题：给一堆点（有顺序要求），要求有多少种方案数使这 $n$ 个点构成一张连通图（无自环、重边）。

该问题可以通过一下方法解决：

考虑**补集转化**思想，将求所有的连通图的方案转化为所有图的方案$-$非连通图的方案。

我们可以定义一个 $dp(S)$ 代表最终答案（ $S$ 代表点集，下同），$f(S)$ 代表非连通图的方案，$g(S)$ 代表总方案数。

很显然，在该集合中所有的点构成的完全图的的子图个数是总方案数。

而对于非连通图而言，我们可以将点集中的点分为两部分——一部分为连通图、另一部分瞎搞，只要这两部分互相不连通就可以了。

只不过为了**不重不漏**，我们可以对于**任意一个点**，考虑它所在的连通图的节点个数进行计数。

最后我们有：
$$
f(S)=\sum dp(S0)*g(S\setminus S0)
$$

---

回到这道题，我们可以仿照刚才的想法，**补集转化**去做。只不过我们这里的总方案数并不是2的整数次幂，而是每条边种数加一后，所有数的乘积后的结果。

对于补集而言，仍然选**任意一个点**进行分情况计数即可。

最后不用卡常就过了。

---

总结：

1. 经典状压问题的变形；

2. 补集转化。



---

## 作者：Light_snow (赞：1)

本文同步自[[清华集训2012]串珠子](https://www.cnblogs.com/dixiao/p/15094439.html)。

是一个很经典集合问题。

在一个点集中，一定可以分割成若干个联通子集。

如果我们设 $f_i$ 为一个点集的联通方案，$g_i$ 为一个点集的所有方案。

我们先任取一个点，考虑枚举一个集合和这个点不联通。

那么我们知道这样不连通的方案 $\sum g[j] \times\ f[i\  \oplus \  j]$。

依据简单的容斥：
$f_i = g_i - \sum_{s\in(i\  \oplus\  j)}\  g[j] \times\ f[i\  \oplus\  j]$。
答案为 $f_{2^n - 1}$。

在实现有细节，即先把当前集合丢掉 lowbit，在枚举不连通的子集。

```cpp
#include<iostream>
#include<cstdio>
#define ll long long 
#define mod 1000000007
#define N 20
#define M (1 << 17)

ll n;

ll c[N][N];

ll f[M],g[M];

int main(){
	scanf("%lld",&n);
	for(int i = 1;i <= n;++i)
	for(int j = 1;j <= n;++j)
	scanf("%lld",&c[i - 1][j - 1]);
	ll K = (1 << n) - 1;
	for(int i = 0;i <= K;++i){
		g[i] = 1;
		for(int j = 0;j <= n - 1;++j){
			for(int k = j + 1;k <= n - 1;++k){
				if(((i >> j) & 1) && ((i >> k) & 1))
				g[i] = (g[i] * (c[j][k] + 1)) % mod;
			}
		}
	}
	for(int i = 0;i <= K;++i){
		f[i] = g[i];
		int t = i ^ (i & -i);
		for(int j = t;j > 0;j = (j - 1) & t){
			f[i] = (f[i] - g[j] * f[i ^ j] % mod + mod) % mod;
		}
	}
	std::cout<<f[K]<<std::endl;
}
```

---

## 作者：yyxmy (赞：0)

在每条边的贡献相等且都是$1$的情况下， 会有这样一个$dp$ :

令$dp_i$表示$i$个点形成连通块的方案数， 转移为：

$dp_i = 2^{(^n_2)}-\sum_{j=1}^{n-1} dp_j * 2^{(^{n-j}_2)}*C(i-1, j-1)$

这个式子是什么意思呢， $2^{(^n_i)}$表示的是$i$个点形成的无向图的方案数， 因为我们要求的是连通图， 所以现在 要把其中连通块的个数$>1$的去掉。 应该如何去重呢， 有这样一种很巧妙的方法， 即令1号点所在联通块的大小为$j$，强制这个联通块与其它点之间没有边，剩下点之间随意连边， 这就保证了图不连通，且对于每种不连通的方案只会被算到1次。

在本题当中， 每条边的贡献是不一样的， 但是范围只有16， 这就启发我们来枚举子集转移了， 具体思想是差不多的， $dp$变成了以下这样

令$dp_s$表示s这个集合连通的方案数， 转移起来比较简单；

$dp_s = f(s)-\sum_{t\sub s 且 min(s)\in t}dp_t*f(s-t)$

其中$f(s)$表示s这个集合形成无向图的方案数。

代码也比较简短
```cpp
#include<bits/stdc++.h>
#define reg register
#define mod 1000000007
#define maxn 200001
using namespace std;
inline int  read() {
    reg int s = 0, t = 0; reg char ch = getchar();
    while(ch > '9' || ch < '0') t |= ch == '-', ch = getchar();
    while(ch >= '0' && ch <= '9') s = (s << 1) + (s << 3) + (ch ^ 48), ch = getchar();
    return t ? -s : s;
}
int d[maxn], dp[maxn], p[101], c[101][101], n, m;
void dfs(int u, int now){
	if(u == n + 1){
		//cout << now << endl;
		d[now] = 1;
		for(int i = 1; i <= n; i++)
			for(int j = i + 1; j <= n; j++)
				if(p[i] && p[j]) d[now] = 1ll * d[now] * (c[i][j] + 1) % mod;
		return;
	}
	p[u] = 1; dfs(u + 1, now + (1 << (u - 1)));
	p[u] = 0; dfs(u + 1, now);
}
int main()
{
	n = read(); m = 1 << n;
	for(int i = 1; i <= n; i++)
		for(int j = 1; j <= n; j++)
			 c[i][j] = read(); dfs(1, 0);
	for(int i = 1; i < m; i++){
		dp[i] = d[i];
		for(int j = i; j; j = (j - 1) & i){
			if(j & 1 && j != i) dp[i] = (dp[i] + mod - 1ll * dp[j] * d[i - j] % mod) % mod;  
		}
	}
	cout << dp[m - 1] << endl;
	return 0;
}

```


---


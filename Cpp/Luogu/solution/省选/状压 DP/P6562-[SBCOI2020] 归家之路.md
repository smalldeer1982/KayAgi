# [SBCOI2020] 归家之路

## 题目背景

时光流逝，岁月无痕。  
小镇的夜空中，缀满了无数宝石一般的闪烁星辰。  
依旧是那片星空，依旧是那个小镇。  
......  
“好久不见啊。”  
“不知不觉，竟然已经过去了那么久了...”  
“但是，这座小镇还是曾经的那个小镇啊。”  
“只不过，我们都不再是过去的自己了呢。”  
“你还记得吗，我们曾经一起在这里看雪，一起玩游戏...”   
“可是游戏结局明明一开始就已经决定了...真是太坏了...”    
“嘿嘿，说起来你还从来没赢我过呢......”  
“我还记得，你以前说过，每当世界上有一份思念，便会化成一片雪花在这里飘落...”  
“嗯，我只要看着冬天的雪便能想起你了。我知道，这一定是你的思念吧...”    
“我也看到了，如同雪花般飘落的记忆......”  

天空中，点点滴滴的光芒融合在一起，清澈而宁静。眼前的风景是那么熟悉又陌生。  
![](https://cdn.luogu.com.cn/upload/image_hosting/ic5htl18.png)

“我们再待一会儿如何，就像以前一样......”  
“和你，和小镇，和星空......”

## 题目描述

天空中一共有 $2^n$ 颗星，依次编号为 $0,1,...,2^n-1$。每颗星都有一个亮度值。初始时第 $i$ 颗星的亮度值为 $a_i$。  

对于两个正整数 $a,b$ 我们定义一种布尔类型运算 $a\otimes b$ 。如果在 $a$ 的**二进制**表示中，满足每一个 $a$ 是 $1$ 的位，$b$ 的对应位也是 $1$，那么  $a\otimes b$ 为 `True` , 否则 $a\otimes b$ 为 `False`。  
若两数在二进制表示下的位数不同，则将两数 **右对齐** 后在左侧补0。例如两个数是 $1$ 和 $11$ （二进制），$1$ 会变成 $01$。

对于这些星的亮度值有两种操作：

第一种：$1$ $a$ $b$ $k$。对于所有的满足 $a\otimes c$ 值为 `True` 以及 $c\otimes b$ 值为 `True` 的 $c$，将第 $c$ 颗星的亮度值加上 $k$。

第二种：$2$ $a$ $b$。若第 $c$ 颗星的编号 $c$ 满足 $a\otimes c$ 值为 `True` 以及 $c\otimes b$ 值为 `True`。求出所有第 $c$ 颗星的亮度总和，答案对 $2^{32}$ 取模。  


## 说明/提示

**【样例解释】**

第一次是询问，$0$ 的二进制表示为 $000$， $7$ 的二进制表示为 $111$ 。此时，所有数都满足，即求的是所有数之和，为 $36$。

第二次是修改，$1$ 的二进制表示为 $001$，$5$ 的二进制表示为 $101$，发现 $c=1,5$ 满足，二进制表示分别为 $001$，$101$所以 $a_1,a_5$ 的值从 $2,6$ 变为 $3,7$。

第三次是询问，$1$ 的二进制表示为 $001$，$7$ 的二进制表示为 $111$，发现 $c=1,3,5,7$ 满足，二进制表示分别为 $001$，$011$，$101$，$111$。求的是 $a_1,a_3,a_5,a_7$ 的和 $3+4+7+8=22$。

**【数据范围】**

**本题捆绑测试，共有 $4$ 个子任务**。 

$Subtask 1(1\%)$：答案为样例。

$Subtask 2(9\%)$：$n \le 12,m \le 2\times 10^3$。

$Subtask 3(15\%)$：所有 $2$ 操作都在 $1$ 操作之后。

$Subtask 4(75\%)$：没有任何额外限制。

对于 $100\%$ 的数据，$1 \le n \le 16,1 \le m \le 2\times 10^5, 0 \le a,b \le 2^n-1,0 \le a_i,k \le 2^{32}-1$。

**【温馨提示】**

对 $2^{32}$ 取模，可以直接用无符号 `32` 位整形的数据类型进行运算。在 `c++` 中就是 `unsigned int`。

~~也就是【直接自然溢出啥事没有】。~~

## 样例 #1

### 输入

```
3 3
1 2 3 4 5 6 7 8
2 0 7
1 1 5 1
2 1 7```

### 输出

```
36
22```

# 题解

## 作者：JohnVictor (赞：11)

放上官方题解。

令序列长 $m=2^n$。

首先对于前 $5\%$ 的数据可以直接暴力。复杂度 $O(mq)$。

暴力枚举子集的方法是（这里是 `c++` 代码）
```cpp
int f=x^y;
for(int t=x^y;t>=0;t=(t-1)&f)
  ```
  
当然还有什么都不发生的情况，也就是不存在满足要求的 $c$。这个可以使用 `a and b=a` 进行特判。

继续开始思考后面的部分分。之后都假设所有的修改和询问都是有效的，也就是 `a and b=a`一直成立。

这个修改、询问的形式类似一个区间，那么需要知道一个前置知识 **高维前缀和**。如果不知道的话可以学一下，比较简单。

那么类比不带修直接求区间的和，我们考虑用几个高维前缀和相加减去表示一个询问的答案。

这里可以从简单的情况开始考虑。如果 $a=0$，那么就直接是一个高维前缀和的答案；那么继续考虑，令 $sum(i)$ 为 $i$ 的高维前缀和，如果 $a=1$，那么询问 $(a,b)$ 的答案是一些 $a_c$ 的和，其中 $c$ 是奇数并且 `c and b=b`。那么这个答案比 $sum(b)$ 小了 $c$ 是偶数，并且 `c and b=b` 的位数之和。后面的那个恰好可以用 $sum(b-1)$ 表示。

思路逐渐明朗起来，如果 $x$ 是 $b$ 与 $a$ 相同且二进制位 `1` 的一位的值，那么我们可以得到

$$query(a,b)=query(a-x,b)-query(a-x,b-x)$$

这个式子可以位运算进行优化，`x=a&-a`，`a-x` 可以用 `a^x` 表示。

这个看似还没啥用——如果 $a,b$ 相同那么这个复杂度还是 $m$ 级别的。但是仔细分析：

如果 $a,b$ 二进制不同的位有 $x$ 位，相同的有 $y$ 位，其中 $x+y=n$，那么直接暴力计算就可以用 $O(2^x)$ 次计算完成；如果用上面那种方法，它的复杂度是 $O(2^y)$。

进行特判并且选择可以做到 $O(2^{\min(x,y)})$，也就是 单次询问 $O(\sqrt m)$。这个算法可以通过第二档部分分。

这里有一个很小的优化，没什么用：

可以快速预处理出 $0$ 到$(2^n-1)$ 中每一个数有多少个二进制 `1`，这样查询二进制 `1` 的个数就从 $O(\log m)$ 变成了 $O(1)$。具体实现和 `FFT` 中的那个 `rev` 数组类似：

```cpp
for(int i=0;i<(1<<n);i++)count[i]=count[i>>1]+(i&1),rev[i]=(1<<n)-i-1;
```

其实这么进行修改也是 $O(\sqrt m)$ 的，但是唯一的问题就是无法及时更新。如果询问都在修改后面，可以考虑懒标记，用数组 `curr` 记录。如果 `curr[i]` 记录了值，那么就代表所有 `i` 的子集都要加上这个值。

这里用代码更清楚一点：
```cpp
void modify(int x,int y,uint z)
{
	if(count[x^y]<=n/2)
	{
		int f=x^y;
		for(int t=x^y;;t=(t-1)&f){
			a[t|x]+=z;
			if(t==0)
				break;
          //这一部分是对修改值不多的情况进行暴力
		}
		return;
	}
	if(x==0)
	{
		curr[y]+=z;//如果x=0那么就可以直接打上懒标记
		return;
	}
	int lbt=x&-x;
	modify(x^lbt,y,z);
	modify(x^lbt,y^lbt,-z);//与 query 部分类似的递归
}
```

等到所有修改结束后可以下放懒标记，暴力下放的复杂度是 $O(3^n)$，总时间复杂度 $O(\sqrt mq+3^n)$，可以通过第三档部分分。

然而这里并不是没有优化的空间了。下放懒标记的过程完全可以看成又一次高维前缀和。

本来的高维前缀和上的值是它的所有子集的和；而这时候需要加的值，是所有以它为自己的懒标记的和。

举个栗子，如果一个数的二进制表示是 `001`，那么高维前缀和中就是 `000,001` 的和，在这种情况下要加上 `001,011,101,111` 这四个懒标记的和。所以这样只用反着来一遍高维前缀和就行了。

为了加速，我预处理了 `rev` 数组代表一个数二进制取反后的结果，因为这里不能直接用 `~`。（这个 `rev` 不是 `FFT` 中的 `rev`）

话不多说上代码：

```cpp
void update()
{
	for(int i=0;i<n;i++)
		for(int j=0;j<(1<<n);j++)
		{
			if(j&(1<<i))
				curr[rev[j]]+=curr[rev[j^(1<<i)]];
		}
  //这里是反着的高维前缀和
	for(int i=0;i<(1<<n);i++)
		a[i]+=curr[i];
	for(int i=0;i<(1<<n);i++)
		pres[i]=a[i];
	for(int i=0;i<n;i++)
		for(int j=0;j<(1<<n);j++)
			if(j&(1<<i))
				pres[j]+=pres[j^(1<<i)];
}
```
其中 `pres` 是高维前缀和数组。这一次 `update` 的复杂度是高维前缀和的复杂度 $O(n2^n)$。

好了，各位大佬们看到这里，正解已经呼之欲出了：分块！

我们假设块长为 $s$，一共 $t$ 块。

修改还是正常修改，查询还是正常查询。这里复杂度是 $O(q \sqrt m)$。

查询的时候，唯一的问题就是计算块内贡献。这个可以位运算 $O(1)$ 计算每个贡献，复杂度是 $ms$；每一块的 `update` 的复杂度是 $O(tn2^n)$，那么我们可以得到总的复杂度可以达到 $O(m \sqrt {nq}+q \sqrt m)$，在块长为 $\sqrt{nq}$ 时最优。

块内的贡献还是有细节的。大概是这两种情况：

（1）一个修改的数和询问的数没有相同的。

（2）有一部分相同。

这个位运算有很多种实现方法，直接上代码：

```cpp
for(int i=1;i<=cnt;i++)
			{
				num=(s[i].a|a)&(s[i].b&b);
				if(num==int(s[i].a|a))
				{
					num=(s[i].a|a)^(s[i].b&b);
					ans+=(1<<count[num])*s[i].k;
				}
			}
			cout<<ans<<endl;
```

`std` 的长度 `2235byte`，作为数据结构还是比较良心的。

如果写挂了可以找我要代码，前两天发现有人疑似抄我放的代码，所以不准备直接放。

---

## 作者：command_block (赞：7)

**题意** : 

定义一种布尔类型运算 $a\otimes b$ : 如果在 $a$ 的**二进制**表示中，满足每一个 $a$ 是 $1$ 的位，$b$ 的对应位也是 $1$，那么  $a\otimes b$ 为 `True` , 否则为 `False`。

维护一个长度为 $2^n$ ，标号为 $0\dots2^n-1$ 的序列 $S$，支持如下操作。

- 给出 $a,b,k$ ，将所有满足 $a\otimes  c,\ c\otimes b$ 的 $S$ 加上 $k$。

- 给出 $a,b$ ，查询 $\sum\limits_{c}(a\otimes  c)(c\otimes b)S[c]$。

$n\leq 16,q\leq 2\times 10^5$ ，时限 $\texttt{1s}$。

------------

有趣的题目。

两种操作中，指定的 $c$ 集合的形式相同，且较为陌生，不妨先来考虑无修改的情况。

$a\otimes b\Leftrightarrow a\subseteq b$

$a\otimes  c,\ c\otimes b\Leftrightarrow a\subseteq c\subseteq b\Rightarrow (c-a)\subseteq (b-a)$

相当于，指定若干位 （$a$）为 $1$ ，若干位（$U-b$） 为 $0$ ，其余位（b-a）随意。

称 $\left<a,b\right>=\{c|\}$

这样，可能的 $c$ 的个数就是 $O(2^{|b-a|})$。当然，$|b-a|$ 仍然有可能较大。

当 $|b-a|$（不确定的位的个数） 较大时，确定的位相应地较少。

设 $f(s_0,s_1)$ 表示钦定位集合 $s_0$ 为 $0$ ，位集合 $s_1$ 为 $1$ 的位置的和。

当 $s_1=\varnothing$ 时，相当于子集求和，提前 $O(2^nn)$ 预处理即可。

否则，设 $p$ 为 $s_1$ 中任意一个元素，则有 ：

$$f(s_1,s_0)=f(s_1-p,s_0)-f(s_1-p,s_0+p)$$

意思是，用 $p=0/1$ 的方案减去 $p=0$ 的方案，即可得到 $p=1$ 的方案。

利用这个式子递推，不难得出复杂度为 $O(2^{|U-a|})$。

和上面的暴力做法结合，复杂度为 $O(2^{n/2})$。似乎也可以做到 $O(2^{n/3})$。

接下来考虑带修的情况。对时间分块，块大小设为 $B$ 。

- 零散的 $B$ 个修改对询问的贡献。

  相当于我们要计算两个形如 $R=\{c|a\subseteq c\subseteq b\}$ 的交集。
  
  假设 $R_1$ 中指定位集合 $a_1$ 为 $0$ ，位集合 $b_1$ 为 $1$。$R_2$ 中类似。
  
  $c$ 同时属于 $R_1,R_2$ 相当于指定 $a_1∪a_2$ 为 $0$ ，$b_1∪b_2$ 为 $1$。
  
每过 $B$ 个修改就重新计算一次 $S$ 以及 $S$ 的子集和。

可以用同样的递推方式将一次加法操作转化为对 $O(2^{n/2})$ 个子集的加法，或者是单点加法。

使用高维后缀和即可批量计算子集加法。

这样的复杂度是 $O\big(q(B+2^{n/2})+2^nnq/B\big)$ 取 $B=\sqrt{2^nn}$ 可得复杂度为 $O(q2^{n/2}\sqrt{n})$。

常数较小。

```cpp
#include<algorithm>
#include<cstring>
#include<cstdio>
#include<cmath>
#define cpy(f,g,n) memcpy(f,g,sizeof(f[0])*(n))
#define uint unsigned int
#define MaxS 66000
using namespace std;
int n,n0;
void sum0(uint *f)
{
  for (int len=1;len<n;len<<=1)
    for (int p=0;p<n;p+=len+len)
      for (int k=0;k<len;k++)
        f[p|len|k]+=f[p|k];
}
void sum1(uint *f)
{
  for (int len=1;len<n;len<<=1)
    for (int p=0;p<n;p+=len+len)
      for (int k=0;k<len;k++)
        f[p|k]+=f[p|len|k];
}
uint t0[MaxS],t1[MaxS],w0[MaxS],w1[MaxS];
void build()
{
  cpy(w0,t1,n);sum1(w0);
  for (int i=0;i<n;i++)w0[i]+=t0[i];
  cpy(w1,w0,n);sum0(w1);
}
#define lbit(x) ((x)&-(x))
uint calc(int s0,int s1)
{
  if (!s1)return w1[(n-1)^s0];
  int p=lbit(s1);
  return calc(s0,s1^p)-calc(s0|p,s1^p);
}
void upd(int s0,int s1,uint c)
{
  if (!s1){t1[(n-1)^s0]+=c;return ;}
  int p=lbit(s1);
  upd(s0,s1^p,c);upd(s0|p,s1^p,-c);
}
int cnt[MaxS];
void add(int a,int b,uint c)
{
  if (cnt[a]<=n0/2)upd(b,a,c);
  else {
    int sl=(n-1)^a^b;
    for (int s=sl;s;s=(s-1)&sl)
      t0[s|a]+=c;
    t0[a]+=c;
  }
}
struct Data
{int a,b;uint c;}r[MaxS];
int q,tot,BS;
int main()
{
  scanf("%d%d",&n0,&q);n=1<<n0;
  BS=sqrt(n0*n)+1;
  for (int i=1;i<n;i++)
    cnt[i]=cnt[i>>1]+(i&1);
  for (int i=0;i<n;i++)
    scanf("%u",&t0[i]);
  build();
  for (int i=1,op,a,b;i<=q;i++){
    scanf("%d%d%d",&op,&a,&b);
    b=(n-1)^b;
    if (a&b){
      if (op==1)scanf("%u",&r[0].c);
      else puts("0");
      continue;
    }
    if (op==1){
      r[++tot]=(Data){a,b};
      scanf("%u",&r[tot].c);
      add(a,b,r[tot].c);
      if (tot==BS)
        {build();tot=0;}
    }else {
      uint ret=0; 
      if (cnt[a]<=n0/2)ret=calc(b,a);
      else {
        int sl=(n-1)^a^b;
        for (int s=sl;s;s=(s-1)&sl)
          ret+=w0[s|a];
        ret+=w0[a];
      }
      for (int i=1;i<=tot;i++){
        int a2=a|r[i].a,b2=b|r[i].b;
        if (!(a2&b2))ret+=r[i].c<<(n0-cnt[a2|b2]);
      }printf("%u\n",ret);
    }
  }return 0;
}
```
  
  
  





---

## 作者：犇犇犇犇 (赞：7)

[题目链接](https://www.luogu.com.cn/problem/P6562)

为什么这道题到现在为止都没啥人做啊qaq  
还有人来私信我说不知道题解在写啥，怎么做（雾  
貌似官方题解没写清楚，所以自己写一篇qaq  
个人认为这道题出的还是不错的qwq

## Subtask 1

答案为样例。

emm 当时放着是想看参加人数的，不说了（雾

## Subtask 2

$n \le 12,m \le 2\times 10^3$

首先我们来看一下 $\otimes$ 这个操作符  
> 如果在 $a$ 的二进制表示中，满足每一个 $a$ 是 $1$ 的位，$b$ 的对应位也是 $1$，那么 $a\otimes b$ 为 True , 否则 $a\otimes b$ 为 False。

也就是说，只有$1 \otimes 1 $ 才是 True 。这不就是 & 吗？  
所以 $a \otimes b$ 相当于 a & b == a   
所以我们可以得到 10 分的暴力做法。暴力枚举i ，判断是否符合要求。而要求就是 ```(int(a&i)==a) && (int(i&b)==i)```

```
#include <bits/stdc++.h>
using namespace std;
const int MOD = 1<<31;
const int MAXN = (1<<16)+5;
inline int read()
{
	int x=0,f=1;char c=getchar();
	while(c<'0' || c>'9'){if(c=='-')f=-1;c=getchar();}
	while(c>='0' && c<='9'){x=x*10+c-'0';c=getchar();}
	return x*f;
}
int s[MAXN],n,q;
int main()
{
	n=read();q=read();
	for(int i=0;i<(1<<n);i++)
	{
		s[i]=read(); 
	}
	while(q--)
	{
		int k,a,b,v;
		k=read();a=read();b=read();
		if(k==1)
		{
			v=read();
			for(int i=0;i<(1<<n);i++)
			{
				if((int(a&i)==a) && (int(i&b)==i))
					s[i]+=v;
			}
		}
		else
		{
			long long ans=0; 
			for(int i=0;i<(1<<n);i++)
			{
				if((int(a&i)==a) && (int(i&b)==i))
					ans=(ans+s[i])%MOD;
			}
			printf("%lld\n",ans)%MOD;
		}
	} 
	return 0;
} 
```

当然我们还有一个更加优雅的暴力。  
我们观察一下，可以发现，对于 a & i == a  需要满足的条件是 对于每个a是1的位，i也是1。也就是说，a中所有是1的位已经被确定下来。对于 i & b == i 同样，若 b 是 0 的位，i也必须为0。  
也就是说，对于a中所有为1的位，b中所有0的位，在i中都已经确定。只有a为0，b为1的位才需要被枚举。也就是说只有 a^b 中所有为1的位我们需要枚举。
这里要注意的是，如果有一位a为1，且b为0，这两个条件自相矛盾，所以直接退出即可。  
即   
```
if(int(a&b)!=a)
	return; 
```

比如第一个样例 $a=(001)_2$, 则 i 第3位必须为1，$b=(101)_2$，i 第二位必须为0。只有第1为没有确定。只有所以 i 只可能为$(001)_2,(101)_2$ ， 而$a$^$b=(100)_2$ 恰好满足这种条件。

于是我们便有了一种更加高效的方法。
枚举子集我们采用  
这里子集定义为如果 a&b==a ，那么b是a的子集
```
int t=a^b;
for(int s=t;;s=(s-1)&t)
```
t为所有需要枚举的位置。我们需要枚举t的子集。s-1相当于把最右边的1变成0，再把1右边的所有元素变成1。而&t保证了所得到的结果是t的子集。对于每一位，会在第一次-1时变为0，而在下一次-1，会把它又重新变成1。

比如 $(11010)_2  \rightarrow (11000)_2 \rightarrow (10010)_2 \rightarrow (10000)_2 \rightarrow (01010)_2 \rightarrow (01000)_2 \rightarrow (00010)_2 $

这样我们满足了对于所有b是0的位，s是0，所以还需要s|a来满足所有a是1的位，s为1。 

```
#include<bits/stdc++.h>
using namespace std;

unsigned int m[(1<<16)+5];
int n,q,opt,a,b;
unsigned int k;

void modify()
{
	scanf("%d%d%u",&a,&b,&k);
	if(int(a&b)!=a)
		return; 
	int t=a^b;
	for(int s=t;;s=(s-1)&t)
	{
		m[s|a]+=k;
		if(s==0)break;
	}
}

void query()
{
	scanf("%d%d",&a,&b);
	if(int(a&b)!=a)
	{
		cout<<0<<endl;
		return; 
	}
	int t=a^b,ans=0;
	for(int s=t;;s=(s-1)&t){
		ans+=m[s|a];
		if(s==0)break;
	}
	printf("%u\n",ans);
}

int main()
{
	cin>>n>>q;
	for(int i=0;i<(1<<n);i++)
		scanf("%u",&m[i]);
	for(int i=0;i<q;i++)
	{
		scanf("%d",&opt);
		if(opt==1)
			modify();
		if(opt==2)
			query();
	}
	return 0;
}
```
这个暴力其实十分高效，设 count[x] 为 x 的二进制中1的位数，因为每次的操作次数实际只有 count[a^b] 次。因为 a^b 中不是1的位都已经被确定。

## Subtask 3

所有 $2$ 操作都在 $1$ 操作之后。

对于更高分数的做法，我们尝试将修改和询问表示成一个"前缀和"。  
这里的"前缀和"是指对于 (a,b) 的询问或修改，所有 a=0 的为一个"前缀"和，这个前缀和表示为 curr[b]，curr[b]=query(0,b) 这个可以预处理出来，具体操作在后面讲。   

我们以询问(query)来举例，修改(modify)同理  
对于操作 (a,b) 如果a=0 ，那么直接返回前缀和即可。  
对于任意的操作 (a,b) 我们尝试将其拆分，使得我们能将它用一些前缀和以及单点查询将其表示出来。  
比如现在有 query(a,b)  现在 a!=0，则a至少存在一个为1的位，同时b的对应位也为1。假设那一位为x（我们可以令$x=\operatorname{lowbit}(a)$显然满足要求)   
我们可以发现   
$query(a,b)=query(a-x,b)-query(a-x,b-x)$  

比如 $a=(00110)_2,b=(11110)_2,x=(00010)_2$  
$a-x=(00100)_2$ , $b-x=(11100)_2$   

此时 $a$ ^ $b=(11000)_2$ ， $(a-x)$ ^ $b=(11010)_2$， $(a-x)$ ^ $(b-x)=(11000)_2$

在做 query(a,b) 的时候，第4位被固定了，必须为1。当我们转化为  query(a-x,b) 的时候，带来了第4位为0或1的情况。而第四位为0的情况是我们不需要的啊。所以正好减掉 query(a-x,b-x) ，此时第四位被固定为0，其他要求不变。

这里我们每次找到 a 的一个为 1 的位，将她消去。这里 x 为 $\operatorname{lowbit}(a)$ 
即 `x=a&-a` 这里 x-a 等价于 x^a ，b-x 等价于 b^x  
这样我们就成功的消去了 a 的一个为 1 的位，我们可以逐渐消去 a 的所有为 1 的位，使 a 最终等于 0 ，从而将他表示成了一些"前缀和"的和与差的形式。

有了"前缀和"，我们就可以方便的进行 query 了。设 count[x] 为 x 的二进制中1的位数，那么我们可以当 count[a^b]小于8的时候直接暴力修改，修改方法可以参考上面那个"优雅的暴力"。为什么是8呢？因为此时带来的修改最多为 $2^8$ 次修改，这个恰好可以很快的处理出来。  
而如果 count[a$^$b]>8 时，我们就将其表示成一些"前缀和"的组合。因为只有a=0，b=1的位才有可能 使得 a^b 的那一位为1，（如果a=1，b=0此时答案为0，无需操作）。因为$1 \le n \le 16$，所以 a 中 1 的个数必定小于8，每次a中有一个1，会分成两个query，即最多将操作(a,b)表示为 $2^8$个前缀和的组合。这里用8作为界来举例，其实对于任意的 n ，n/2 这个界是比较好的，count[a^b] 小于 n/2 的时候暴力修改，而如果 count[a^b]>n/2 时，则将 query(a,b) 递归拆成两个操作。  

这里修改(modify)操作同理，只不过把求和操作换成了修改操作，直接对原数或者前缀和操作。  

```
void modify(int x,int y,uint z)
{
	if(count[x^y]<=n/2)
	{
		int f=x^y;
		for(int t=x^y;;t=(t-1)&f){
			a[t|x]+=z;
			if(t==0)
				break;
		}
		return;
	}
	if(x==0)
	{
		curr[y]+=z;
		return;
	}
	int lbt=x&-x;
	modify(x^lbt,y,z);
	modify(x^lbt,y^lbt,-z);
}
uint query(int x,int y)
{
	if(count[x^y]<=n/2)
	{
		int f=x^y;
		uint ans=0;
		for(int t=x^y;;t=(t-1)&f)
		{
			ans+=a[t|x];
			if(t==0)
				return ans;
		}
	}
	if(x==0)
		return curr[y];
	int lbt=x&(-x);
	return query(x^lbt,y)-query(x^lbt,y^lbt);
}
```
下面问题就变成了如何处理这种"前缀和"  
设 x 的前缀和为 curr[x] 我们可以发现 $curr[x]=query(0,x)$ 

如果 a&b==a ，那么b是a的子集，记为$b\subset a$，即 curr[x] 为所有x的子集的和。  
用公式写就是 ${curr[x]=\Large\Sigma_{i\subset x} a_i }$  
处理这种子集问题我们有一种办法叫做 **高维前缀和**，对于已知的 $a_1$,$a_2$,...,$a_{2^t}$可以在 $O(2^t*t)$的时间内处理出所有的curr。  
所以对于所有修改完再询问的情况，我们在操作时，给 curr 或者原数$a_i$直接修改，然后再用高维前缀和把所有的修改给还原回来，类似于线段树懒标记的思想，即把之前修改给前缀和打的tag全都还原回来，给所有 $a_i$真实的值，然后再做一遍高维前缀和，重新求得修改后的curr。然后对于询问就可以直接query了。    
这里两次高维前缀和复杂度为 $O(2^n*n)$，在所有修改操作都结束后执行一次。这里用update函数。  

这里需要稍微注意一下的就是第一次高维前缀和的时候我们用curr来表示修改标记，类似于线段树懒标记。而此时我们需要恢复其原来的值，也就是说这里要求的不是子集，而是"父集"。

比如现在 curr[1]=1 ，也就是说所有包含了 1 的元素都要改变。因为现在有一个 modify(0,1) curr表示为所有包含它的和，所以所有包含1的都要修改，比如 001,011,101,111 四个。这里类似于"父集"的修改。  
所以我们需要反着求高维前缀和，第二维从$(1<<n)-1$循环到0。不理解的可以通过最简单的一维前缀和来类比下。此时我们的 curr[n] 被修改了，curr[1],curr[2],...,curr[n] 都要被修改，因为 curr[n] 包含所有数。curr[i]的修改需要改变下标小于 i 的curr。此时有$curr[n]+=curr[n+1]$ ， i 从 n-1 循环到0。这里也是同样道理。

第二次高维前缀和就是通过a去求curr，和正常的高维前缀和没有区别。
  

```
void update()
{
	cnt=0;
	for(int i=0;i<n;i++)
		for(int j=(1<<n)-1;j>=0;j--)
		{
			if(j&(1<<i))
				curr[j^(1<<i)]+=curr[j];
		}
	for(int i=0;i<(1<<n);i++)
		a[i]+=curr[i];
	memset(curr,0,sizeof(curr));
	for(int i=0;i<(1<<n);i++)
		curr[i]=a[i];
	for(int i=0;i<n;i++)
		for(int j=0;j<(1<<n);j++)
			if(j&(1<<i))
				curr[j]+=curr[j^(1<<i)];
}
```

count[x]表示x的二进制中有多少个1，可以直接预处理

```
for(int i=1;i<=(1<<n);i++)
		count[i]=count[i>>1]+(i&1);
```
这个dp还算是比较巧妙地吧。

这样我们就完成了对subtask3的做法，放上完整代码：  

```
#include<bits/stdc++.h>
#define count cou
using namespace std;
typedef unsigned int uint;
const uint MAXN=(1<<16)+5;
inline uint read()
{
	uint x=0,f=1;char c=getchar();
	while(c<'0' || c>'9'){if(c=='-')f=-1;c=getchar();}
	while(c>='0' && c<='9'){x=x*10+c-'0';c=getchar();}
	return x*f;
}
uint a[MAXN],curr[MAXN],k,count[MAXN];
int q,n,opt,cnt;

void modify(int x,int y,uint z)
{
	if(count[x^y]<=n/2)
	{
		int f=x^y;
		for(int t=x^y;;t=(t-1)&f){
			a[t|x]+=z;
			if(t==0)
				break;
		}
		return;
	}
	if(x==0)
	{
		curr[y]+=z;
		return;
	}
	int lbt=x&-x;
	modify(x^lbt,y,z);
	modify(x^lbt,y^lbt,-z);
}
uint query(int x,int y)
{
	if(count[x^y]<=n/2)
	{
		int f=x^y;
		uint ans=0;
		for(int t=x^y;;t=(t-1)&f)
		{
			ans+=a[t|x];
			if(t==0)
				return ans;
		}
	}
	if(x==0)
		return curr[y];
	int lbt=x&(-x);
	return query(x^lbt,y)-query(x^lbt,y^lbt);
}

void update()
{
	cnt=0;
	for(int i=0;i<n;i++)
		for(int j=(1<<n)-1;j>=0;j--)
		{
			if(j&(1<<i))
				curr[j^(1<<i)]+=curr[j];
		}
	for(int i=0;i<(1<<n);i++)
		a[i]+=curr[i];
	memset(curr,0,sizeof(curr));
	for(int i=0;i<(1<<n);i++)
		curr[i]=a[i];
	for(int i=0;i<n;i++)
		for(int j=0;j<(1<<n);j++)
			if(j&(1<<i))
				curr[j]+=curr[j^(1<<i)];
}
int main()
{
	cin>>n>>q;
	int size=sqrt(n*(q+(1<<n))),Isquery=0;
	for(int i=0;i<(1<<n);i++)
		cin>>a[i];
	for(int i=1;i<=(1<<n);i++)
		count[i]=count[i>>1]+(i&1);
	while(q--)
	{
		cin>>opt;
		if(opt==1)
		{
			int a,b;
			uint k;
			cin>>a>>b>>k;
			if(int(a&b)==a)
				modify(a,b,k);
		}
		else
		{
			if(Isquery==0)
			{
				Isquery=1;
				update();
			}
			int a,b;
			cin>>a>>b;
			if(int(a&b)!=a)
			{
				cout<<0<<endl;
				continue;
			}
			cout<<query(a,b)<<endl;
		}
	}
	return 0;
}
```
因为 subtask1 和 subtask2 并不满足"先修改后询问"的条件，这份代码只能通过 subtask3 。如果要通过 subtask1 和 subtask2 的话可以自行加判断（比如n是否大于12）。

## Subtask 4

$1 \le n \le 16,1 \le m \le 2\times 10^5, 0 \le a,b \le 2^n-1,0 \le a_i,k \le 2^{32}-1$

上面我们解决的对于"先修改后询问"的问题，那如果这些问题混合在一起了怎么办？因为每次询问操作我们都需要真实的a与curr，但是一旦更新(update)了这些的真实值，时间的代价是巨大的。那么我们可不可以隔几个操作更新一次呢？所以这题的正解就是 **分块**。之前有人问我到底对啥分块。注意的是这里我们不是对于序列中的值来进行分块，而是**对于操作**分块，每次块结束后做一次update。    

那么对于块内没有update的怎么办？我们只有当前块更新之前的a和curr啊。那么当前块的修改怎么办？此时我们发现当前块内的修改操作最多只有$\sqrt{m}$个，所以我们可以考虑暴力枚举当前块内的修改对于我们的询问产生的影响。对于一个修改对一个询问产生的影响可以 $O(1)$ 求出。

假设现在的修改操作为 (ma,mb)，而我们需要求出的询问操作为 (qa,qb)。 

此时修改为这两个操作"重合"的部分。若s为满足要求的数，即s在修改(ma,mb)中被修改，同时在询问(qa,qb)中被覆盖到。我们来看看s二进制中哪些位置是确定的。    
上面我们得到了每个ma是1的位，s一定也是1。每个qa是1的位，s一定为1。所以 (ma|qa) 中为1的位，s为1。  
同理。每个ma与qb中为0的位，s一定为0。即 (mb&qb) 为0的位，s为0。  
所以本质覆盖的条件就是操作 (ma|qa,mb&qb) 的所有子集。所以修改的位为 (ma|qa)^(mb&qb) 中为1的所有位。若 num=(ma|qa)^(mb&qb) ,即有 count[num] 位不确定，可以为0或1，一共有 $2^{num}$ 种情况。如果这个修改的值为k，每种情况都会带来k的修改，那么总修改大小为 $2^{num}*k$  

代码中用s[i]表示修改(ma,mb)，a,b来表示询问qa,qb。

```
num=(s[i].a|a)&(s[i].b&b);
if(num==int(s[i].a|a))
{
	num=(s[i].a|a)^(s[i].b&b);
	ans+=(1<<count[num])*s[i].k;
}
```

所以我们用两个新的数组pres,与num数组来表示**当前块修改前**所有元素的前缀和以及真实值，用curr数组来表示**当前块内**的修改。每次块结束之后便做一次update。

丢个std qaq 和 subtask3 的代码不同的地方加了注释，其他的见之前的题解  

```
#include<bits/stdc++.h>
#define count cou
using namespace std;
typedef unsigned int uint;
const uint MAXN=(1<<16)+5;
inline uint read()
{
	uint x=0,f=1;char c=getchar();
	while(c<'0' || c>'9'){if(c=='-')f=-1;c=getchar();}
	while(c>='0' && c<='9'){x=x*10+c-'0';c=getchar();}
	return x*f;
}
struct question
{
	int a,b;
	uint k;
}s[MAXN]; //因为这里我们需要调用当前块的修改，所以用结构体存下来
uint num[MAXN],a[MAXN],curr[MAXN],pres[MAXN],k,count[MAXN];
//num表示a的备份,在当前块前的真实值,防止在modify操作中被修改
//a始终表示真实值
//curr表示当前块内的modify带来的整块修改，类似于线段树懒标记  
//pres表示当前块修改前的前缀和
//count[x]表示x的二进制表示中有多少个1
int q,n,opt,cnt;

void modify(int x,int y,uint z)
{
	if(count[x^y]<=n/2)
	{
		int f=x^y;
		for(int t=x^y;;t=(t-1)&f){
			a[t|x]+=z;
			if(t==0)
				break;
		}
		return;
	}
	if(x==0)
	{
		curr[y]+=z;
		return;
	}
	int lbt=x&-x;
	modify(x^lbt,y,z);
	modify(x^lbt,y^lbt,-z);
} 
//modify修改，与之前没区别，这里定义不同的是curr只记录当前块内的修改
uint query(int x,int y)
{
	if(count[x^y]<=n/2)
	{
		int f=x^y;
		uint ans=0;
		for(int t=x^y;;t=(t-1)&f)
		{
			ans+=num[t|x]; 
            //因为这里需要求出当前块之前的和，所以需要当前块修改前的真实值，用num
			if(t==0)
				return ans;
		}
	}
	if(x==0)
		return pres[y]; 
        //同上，因为这里需要求出当前块之前的和，所以用pres来表示当前块操作前的前缀和
	int lbt=x&(-x);
	return query(x^lbt,y)-query(x^lbt,y^lbt);
}

void update()
{
	cnt=0;
	for(int i=0;i<n;i++)
		for(int j=(1<<n)-1;j>=0;j--)
		{
			if(j&(1<<i))
				curr[j^(1<<i)]+=curr[j];
		} //这里还原curr，与subtask3相同
	for(int i=0;i<(1<<n);i++)
		a[i]+=curr[i]; //把a[i]还原为真实值
	for(int i=0;i<(1<<n);i++)
		num[i]=a[i]; //因为我们需要记录当前块之前的值，所以备份num，防止被modify修改
	memset(curr,0,sizeof(curr));//curr只记录当前块内的修改，每次块结束的时候清空
	for(int i=0;i<(1<<n);i++)
		pres[i]=a[i];
	for(int i=0;i<n;i++)
		for(int j=0;j<(1<<n);j++)
			if(j&(1<<i))
				pres[j]+=pres[j^(1<<i)]; 
	//重新求高维前缀和
}
int main()
{
	cin>>n>>q;
	int size=sqrt(n*(q+(1<<n))); //块大小
	for(int i=0;i<(1<<n);i++)
		cin>>a[i];
	for(int i=1;i<=(1<<n);i++)
		count[i]=count[i>>1]+(i&1);
	update(); //先求一次高维前缀和
	while(q--)
	{
		cin>>opt;
		if(opt==1)
		{
			cnt++; //记录当前块的修改个数，方便之后枚举
			cin>>s[cnt].a>>s[cnt].b>>s[cnt].k;
			if(int(s[cnt].a&s[cnt].b)==s[cnt].a)
				modify(s[cnt].a,s[cnt].b,s[cnt].k);
			else cnt--; //如果此修改无效，那么删除
		}
		else
		{
			int a,b;
			cin>>a>>b;
			if(int(a&b)!=a) //询问无意义，直接退出
			{
				cout<<0<<endl;
				continue;
			}
			int num;
			uint ans;
			ans=query(a,b);
			for(int i=1;i<=cnt;i++)//枚举块内的修改
			{
				num=(s[i].a|a)&(s[i].b&b);
				if(num==int(s[i].a|a))
				{
					num=(s[i].a|a)^(s[i].b&b);
					ans+=(1<<count[num])*s[i].k;
				} //每个修改对于答案的影响
			} 
			cout<<ans<<endl;
		}
		if(q%size==0)
			update(); //块结束，更新所有到真实值
	}
	return 0;
}
```

个人感觉这道题虽然是一道数据结构题，但是本质却没有用到其他的高级数据结构（数组不算），主要用到了高维前缀和和分块的思想。代码量相比其他数据结构题也不算大，还算一道比较好的题吧（  
本人第一次办比赛，还是想让题解尽量详细一点。之前写官方题解的由于他本人没写过代码，所以可能题解比较模糊，本来想着重写一篇，没想到咕了这么久qaq




---

## 作者：MuelsyseU (赞：2)

显然题目中 $a\otimes b=0$ 等价于 $S_a \in S_b$，其中 $S_x$ 表示取出 $x$ 为 $1$ 的位构成的集合。也就是在位运算上，`(a | b) == b`。

显然若操作的 $S_a\not\subset S_b$ 就没有任何符合条件的数；否则 $c$ 应该满足：

1. 若 $a_i=1,b_i=1$，则 $c_i=1$。
2. 若 $a_i=0,b_i=0$，则 $c_i=0$。
3. 若 $a_i=0,b_i=1$，则 $c_i\in\{0,1\}$。

实际上就是解决以下问题：

> 钦定一些位为 $0$，一些位为 $1$，一些位任意，快速访问符合条件的所有数 $\in[0,2^n-1]$。

我们定义 $S_x$ 包含的位钦定为 $0$，$S_y$ 包含的位钦定为 $1$，其余任意得到的数的集合为 $s(x,y)$。则我们操作对应的集合即为 `s((~b) & ((1 << n) - 1), a)`。

---

其实与其说是分块，个人认为严格来说属于根号分治加上根号重构。

这个根号分治尤其巧妙，它是基于以下三个事实：

1. 枚举填写其中 $k$ 个可任意填写的位，其它位固定，得到所有 $2^k$ 个数的复杂度是 $O(2^k)$ 的。

2. 通过高维前缀和，得到 $S_x$ 中的位钦定为 $0$，其它位置任意（实际上等价于枚举子集）的所有数是 $O(1)$ 的，这个集合等于 $s(x,0)$。

3. $\forall k\in S_y$，$p=2^k, s(x,y)=s(x,y-p)-s(x+p,y-p)$。也就是把 $k$ 这一位任意填写，再除去把 $k$ 填写为 $0$ 的方案数，就得到其填写为 $1$ 的方案数。

于是我们发现，结合 $2,3$，在 $|S_x|$ 次递归、复杂度 $O(2^{|S_y|})$ 可以使得询问的各个 $y=0$，从而解决问题；而通过 $1$，又可以在 $O(2^{n-|S_x|-|S_y|})$ 复杂度内完成。

综上所述，我们可以做到 $O(2^\frac{n}{2}) = O(\sqrt{2^n})$ 复杂度。多维护一个前缀和可以做到 $O(2^\frac{n}{3})$。

---

然后考虑修改，显然跑高维前缀和是可以 $O(n2^n)$ 并且这个东西很难支持直接修改，故考虑根号重构。

显然一个修改对一个询问的贡献与两者对应的集合的交集大小 $t$ 和修改的 $k$ 有关。这个可以 $O(1)$ 位运算简单得到。查询询问时，把上次计算高维前缀和之后，到目前的所有修改遍历一遍，并加上这部分贡献 $\sum tk$。

同时修改的时候我们也对应单点修改或者标记一个集合对应的所有子集被修改，积累 $B$ 次修改后，就重新计算。注意到我们直接对于标记跑高维后缀和，就可以算出一个点的实际值；最后再计算出当前的高维前缀和。

取 $B=\sqrt{2^nn}$ 可得时间复杂度 $O(q\sqrt{2^nn})$，空间线性。

```cpp
#include <bits/stdc++.h>
#define pct __builtin_popcount
using namespace std;

const int maxn = 1 << 17, bs = 2005;
int n, q, all;
unsigned s[maxn], v[maxn], a[maxn], b[maxn];
void reset() {
	for(int j = 0; j < n; j++) 
		for(int i = 0; i <= all; i++)
			if(!((i >> j) & 1)) b[i] += b[i ^ (1 << j)];
	// 此时 a 为真实的单点增加量，v 为实际值
	for(int i = 0; i <= all; i++)
		a[i] += b[i], v[i] += a[i], s[i] = v[i];
	for(int j = 0; j < n; j++) 
		for(int i = 0; i <= all; i++)
			if((i >> j) & 1) s[i] += s[i ^ (1 << j)];
	memset(a, 0, sizeof(a)), memset(b, 0, sizeof(b));
}
int st[maxn], top;
void add(int x, int y, unsigned z) {
	if (!y) return void(b[all & (~x)] += z);
	int p = y & (-y);
	add(x, y ^ p, z), add(x | p, y ^ p, -z);
}
unsigned ask(int x, int y) {
	if (!y) return s[all & (~x)];
	int p = y & (-y);
	return ask(x, y - p) - ask(x + p, y - p);
}
void add(int i, int s, int x, int y, unsigned z) {
	if (i == n) return void(a[s] += z);
	if (!(x & (1 << i))) add(i + 1, s | (1 << i), x, y, z); // 没有钦定为 0
	if (!(y & (1 << i))) add(i + 1, s, x, y, z); // 没有钦定为 1
}
unsigned ask(int i, int s, int x, int y) {
	if (i == n) return v[s];
	unsigned z = 0;
	//Wrong
	if (!(x & (1 << i))) z += ask(i + 1, s | (1 << i), x, y); // 没有钦定为 0
	if (!(y & (1 << i))) z += ask(i + 1, s, x, y); // 没有钦定为 1
	return z;
}
struct Oper {
	int x, y;
	unsigned z;
} op[bs + 5];
int cnt = 0;
void modify(int x, int y, unsigned z) {
	op[++cnt] = {x, y, z};
	(n - pct(x) - pct(y) >= n / 2) ? add(x, y, z) : add(0, 0, x, y, z);
}
unsigned query(int x, int y) {
	unsigned res = 0;
	for (int i = 1; i <= cnt; ++i) {
		if ((x | op[i].x) & (y | op[i].y)) continue;
		res += op[i].z * (1u << (n - pct(x | op[i].x) - pct(y | op[i].y)));
	}
	return res + ((n - pct(x) - pct(y) >= n / 2) ? ask(x, y) : ask(0, 0, x, y));
}
signed main() {
	int c, x, y;
	unsigned z;
	scanf("%d%d", &n, &q), all = ((1 << n) - 1);
	for (int i = 0; i <= all; ++i) scanf("%u", v + i);
	reset();
	while (q--) {
		scanf("%d%d%d", &c, &x, &y), z = 0;
		if (c == 1)
			scanf("%u", &z), ((x & y) ^ x) ? void() : modify((~y) & ((1 << n) - 1), x, z);
		else
			printf("%u\n", ((x & y) ^ x) ? 0 : query((~y) & ((1 << n) - 1), x));
		if (cnt >= bs) reset(), cnt = 0;
	}
	return 0;
}
```

---

## 作者：duyi (赞：2)

# WoW ↓

[超超超超超超超爽的阅读体验 WoW](https://www.cnblogs.com/dysyn1314/p/13326768.html)



## 题目大意

[题目链接](https://www.luogu.com.cn/problem/P6562)

给定$n$以及$a_0,a_1,\dots,a_{2^n-1}$的初始值。对于整数$x,y$，定义$x\subseteq y$为真当且仅当$x\operatorname{and}y=x$。$q$次操作，操作分两种：

- 修改操作：$1\ x\ y\ k$，对于所有$x\subseteq t\subseteq y$，把$a_t$加上$k$。
- 询问操作：$2\ x\ y$，对于所有$x\subseteq t\subseteq y$，求出$a_t$的和。对$2^{32}$取模。

数据范围：$1\leq n\leq 16$, $1\leq q\leq 2\times10^5$。

## 本题题解

对于所有修改和询问，我们首先判断它是否满足$x\subseteq y$。如果不满足，则可以直接忽略（如果是询问则答案等于$0$）。以下只考虑$x\subseteq y$的情况。

修改和询问，方法是类似的。这里我们以修改为例。暴力的做法是枚举所有$t\in[0,2^n)$，判断是否满足$x\subseteq t\subseteq y$。容易想到一种更优雅的暴力：设$z=y\setminus x$，我们枚举$t'\subseteq z$，则所有合法的$t$，都可以表示为$t'\cup x$。我们很容易实现不重不漏地枚举子集。那么，如果设$y$比$x$多的二进制位有$d$个，我们现在就可以$O(2^d)$实现一次修改或查询。

```cpp
//不重不漏地枚举子集
int z=x^y;
for(int i=z;;i=(i-1)&z){
	// do something ...
	if(i==0)break;
}
```

不过显而易见的是，$d$可能达到$O(n)$级别，所以仅有上述的暴力还是不够的。

对于这种子集询问，可以将其看做$n$个维度，于是想到做高维前缀和。设$a$的高维前缀和数列为$s$，即$s_{y}=\sum_{x\subseteq y}a_x$。记询问$(x,y)$对应的答案为$f(x,y)$。显然，当$x=0$时，$f(0,y)=s_y$。

考虑$x\neq 0$时，取出任意一个$x$里是$1$的二进制位，例如，取出$p=\operatorname{lowbit}(x)$。因为$x\subseteq y$，所以$y$的这一位也必为$1$。那么：
$$
f(x,y)=f(x-p,y)-f(x-p,y-p)
$$
这很好理解：$f(x-p,y)$的意思是，$p$这一位既可以选也可以不选。但是在符合$f(x,y)$要求的数里，$p$这一位必须为$1$，所以减去$p$这一位为$0$的情况$f(x-p,y-p)$即可。

我们可以按这个式子递归下去，每次$x$一定会减少一个二进制位，递归的边界就是$x=0$。设$x$里有$c$个$1$，则递归的复杂度是$O(2^c)$的。

这个复杂度看上去依然高达$O(2^n)$，不过我们可以和上一个暴力结合一下。回顾：$d$是$y$比$x$多的二进制位数，那么$c+d$就是$y$的二进制位数，显然$c+d\leq n$。因此：$\min(c,d)\leq\frac{n}{2}$。所以结合这两种做法，单次修改或查询的复杂度可以降至$O(2^{\frac{n}{2}})$。

不过别高兴得太早。这种做法，需要预先知道高维前缀和数组$s$。这在静态的问题（subtask3）中是好办的：修改时，维护一个标记数组$m$，$m_y$表示对$y$的**所有子集**都要加上这个数。所有修改完成后，做一遍**高维后缀和**（fwt and），就能还原出每个位置$a_i$的增量。然后对新的$a$，做一遍**高维前缀和**（fwt or），就得到$s$了。两次fwt的复杂度都是$O(2^nn)$。

---

但是在非静态的问题里，就不能这样处理$s$。

我们考虑对操作分块，每$B$个操作分为一块。

对于修改操作，还是和上面一样进行，仍然维护一个标记数组$m$，不过这个$m$只记录当前块的信息，跳到下一个块时要清空。

对于查询操作，分别考虑【本块内的修改】和【前面块的修改】对答案的贡献。

- 【本块内的修改】的贡献：枚举所有本块内的修改，设修改的范围是$(x_1,y_1)$，当前询问的范围是$(x_2,y_2)$。则这个修改对本次询问，产生贡献的范围就是$(x_1\operatorname{or} x_2,y_1\operatorname{and}y_2)$。这个范围里的数的数量，就是$2^{\text{bitcnt}((y_1\operatorname{and}y_2)\setminus(x_1\operatorname{or} x_2))}$。
- 【前面块的修改】的贡献：可以把前面块修改后的高维前缀和数组$s$预处理好。然后根据$c$, $d$的大小，枚举子集或递归查询即可（这和静态问题是一样的。所以说分块的好处就是，不同的块之间，相当于是静态问题）。

每处理完一个块，就更新高维前缀和数组$s$。

时间复杂度$O(2^nn\cdot \frac{q}{B}+(B+2^{\frac{n}{2}})q)$。$B$取$2000$左右可以AC。

参考代码：

```cpp
//problem:P6562
#include <bits/stdc++.h>
using namespace std;

#define pb push_back
#define mk make_pair
#define lob lower_bound
#define upb upper_bound
#define fi first
#define se second
#define SZ(x) ((int)(x).size())

typedef unsigned int uint;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<int,int> pii;

template<typename T>inline void ckmax(T& x,T y){x=(y>x?y:x);}
template<typename T>inline void ckmin(T& x,T y){x=(y<x?y:x);}

const int MAXN=16;
const int MAXM=1<<MAXN;
const int MAXQ=2e5;
const int B=2000;
//const int BCNT=MAXQ/B+10;

int n,q,m,half_n;
int bitcnt[MAXM+5];
uint v[MAXM+5],s[MAXM+5],mdf_v[MAXM+5],mdf_s[MAXM+5];

template<typename T>
void fwt_or(T* a,int n,T flag){
	for(int i=1;i<n;i<<=1){
		for(int j=0;j<n;j+=(i<<1)){
			for(int k=0;k<i;++k){
				a[j+k+i]+=a[j+k]*flag;
			}
		}
	}
}
template<typename T>
void fwt_and(T* a,int n,T flag){
	for(int i=1;i<n;i<<=1){
		for(int j=0;j<n;j+=(i<<1)){
			for(int k=0;k<i;++k){
				a[j+k]+=a[i+j+k]*flag;
			}
		}
	}
}

struct ModifyInfo{
	int a,b;uint k;
	ModifyInfo(){}
	ModifyInfo(int _a,int _b,uint _k){
		a=_a;b=_b;k=_k;
	}
}sta[B+5];
int top;

void modify_work(int a,int b,uint k){
	if(!a){
		mdf_s[b]+=k;
		return;
	}
	int lb=(a&(-a));
	modify_work(a-lb,b,k);
	modify_work(a-lb,b-lb,-k);
}
void modify(int a,int b,uint k){
	if((a&b)!=a)return;
	sta[++top]=ModifyInfo(a,b,k);
	if(bitcnt[a^b] <= half_n){
		int dif=a^b;
		for(int i=dif;;i=(i-1)&dif){
			mdf_v[a^i]+=k;
			if(i==0)break;
		}
		return;
	}
	modify_work(a,b,k);
}
uint query_work(int a,int b){
	if(!a){
		return s[b];
	}
	int lb=(a&(-a));
	return query_work(a-lb,b)-query_work(a-lb,b-lb);
}
uint query(int a,int b){
	if((a&b)!=a)return 0;
	uint res=0;
	// 本块内的修改对本次询问的贡献
	for(int i=1;i<=top;++i){
		int na=(a|sta[i].a);
		int nb=(b&sta[i].b);
		if((na&nb)!=na)continue;
		res+=(1u<<bitcnt[na^nb])*sta[i].k;
	}
	if(bitcnt[a^b] <= half_n){
		int dif=a^b;
		for(int i=dif;;i=(i-1)&dif){
			res+=v[a^i];
			if(i==0)break;
		}
		return res;
	}
	//之前的块的贡献
	res+=query_work(a,b);
	return res;
}
void rebuild(){
	fwt_and(mdf_s,m,1u);//懒标记下放
	for(int i=0;i<m;++i){
		v[i] += mdf_v[i] + mdf_s[i];
		s[i]=v[i];
		mdf_v[i]=mdf_s[i]=0;
	}
	fwt_or(s,m,1u);
	top=0;
}
int main() {
	cin>>n>>q;
	m=1<<n;
	half_n=n>>1;
	for(int i=0;i<m;++i){
		cin>>v[i];
		s[i]=v[i];
	}
	fwt_or(s,m,1u);//高维前缀和
	
	for(int i=1;i<m;++i)
		bitcnt[i]=bitcnt[i>>1]+(i&1);//预处理bitcnt
	
	for(int tq=1;tq<=q;++tq){
		int op;cin>>op;
		if(op==1){
			int a,b;uint k;
			cin>>a>>b>>k;
			modify(a,b,k);
		}
		else{
			int a,b;
			cin>>a>>b;
			cout<<query(a,b)<<endl;
		}
		
		if(tq%B==0)rebuild();
	}
	return 0;
}
```


---

## 作者：普通的名字 (赞：0)

容易发现 $a\otimes b=\text{True}\Longleftrightarrow a\land b=a$，下面记 $a\land b=a$ 为 $a\sube b$。（这是因为 $b$ 在二进制下 $1$ 的位置包含 $a$ 的。）

修改与询问都涉及到 $a\sube c$ 且 $c\sube b$，此时 $a\sube b$，下面都假设该条件满足，即存在这样的 $c$。不妨先考虑询问，记二元组 $(a,b)$ 为询问，$f(a,b)$ 为这个询问的答案，$x=\operatorname{popcount(a)},y=\operatorname{popcount(b)}-x$，有 $x+y\le n$。

由于 $a\sube c\sube b\Rightarrow (c-a)\sube (b-a)$，$c$ 相当于在 $a$ 的基础上，任选几个 $b$ 具有而 $a$ 没有的 $1$。如果直接枚举，时间复杂度为 $O(2^y)$。

在这里我们考虑高维前缀和，记 $S_i=\sum\limits_{j\in i}a_i$，那么询问 $(0,b)$ 的答案即为 $S_x$。我们希望能通过配凑几个 $S$，得到询问 $(a,b)$ 的答案。考虑 $p\sube a$ 且 $\operatorname{popcount}(p)=1$，有恒等式：
$$f(a,b)=f(a-p,b)-f(a-p,b-p)$$
直观理解就是 $(a-p,b)$ 中 $p$ 那一位可以任选，而 $(a-p,b-p)$ 那一位只能为 $0$，于是二者相减后那一位只能为 $1$，就变为 $(a,b)$ 的情况了。对这两个 $f$ 不断递归下去计算，时间复杂度为 $O(2^x)$。

上面我们列出两种求 $f(a,b)$ 的方法，由于 $a+b\le n$，那么 $\min(a,b)\le\frac n2$，$a,b$ 哪个小就用哪种方式求答案，总的时间复杂度为 $O(\sqrt{2^n})$。

---

对于修改，也能用类似于询问的方式做：如果 $a=\min(a,b)$，就递归下去，给 $O(2^x)$ 个 $S_i$ 打上“差分”标记，表示 $i$ 及 $i$ 的子集都要加上 $w$，标记的更新可以用高维后缀和实现；否则 $O(2^y)$ 枚举 $c$，暴力修改。但是对于每次修改，我们都重新求一边 $S$，复杂度 $O(2^nn)$，不可行。

我们又用复杂度分治的思想，将询问分成若干大小为 $B$ 的块，在每个块结束时求一次 $S$。对于一次询问，在它之前的块的修改对其贡献已经通过求 $S$ 更新到位了，现在的问题是块内的修改如何处理。枚举块内的修改，设其为 $(a',b',w)$，该询问为 $(a,b)$，则只有满足 $(a\lor a')\sube c\sube (b\land b')$ 的位置 $c$，它被修改，并且被查询。所以此修改对询问造成的贡献为 $w\cdot2^{\operatorname{popcount}((a\lor a')\oplus(b\land b'))}$。

求 $S$ 的时间复杂度为 $O(2^nn\cdot\frac qB)$，块内算贡献时间复杂度为为 $O(q(B+\sqrt{2^n}))$，取 $B=\sqrt{2^nn}$，得总的时间复杂度为 $O(q\sqrt{2^nn})$。

具体的实现参照代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define uint unsigned int
const int N=1<<16;
int n0,q,n,sz[N],B,cnt;
uint a[N],b[N],dt[N],sum[N];
struct node{uint x,y,z;}t[N];
void build()
{
    for(int i=0;i<n0;i++)
        for(int j=0;j<n;j++)
            if(!(j>>i&1)) b[j]+=b[j^1<<i];
    for(int i=0;i<n;i++) dt[i]+=b[i],a[i]+=dt[i],sum[i]=a[i];
    for(int i=0;i<n0;i++)
        for(int j=0;j<n;j++)
            if(j>>i&1) sum[j]+=sum[j^1<<i];
    memset(b,0,sizeof(b)),memset(dt,0,sizeof(dt));
}
void add1(uint x,uint y,uint z)
{
    if(!x){
        b[y]+=z;
        return;
    }
    uint lb=x&-x;
    add1(x^lb,y,z),add1(x^lb,y^lb,-z);
}
void add2(uint i,uint s,uint x,uint y,uint z)
{
    if(i==n0){
        dt[s]+=z;
        return;
    }
    if(!(y>>i&1)) add2(i+1,s,x,y,z);
    else{
        if(!(x>>i&1)) add2(i+1,s,x,y,z);
        add2(i+1,s^1<<i,x,y,z);
    }
}
uint ask1(uint x,uint y)
{
    if(!x) return sum[y];
    uint lb=x&-x;
    return ask1(x^lb,y)-ask1(x^lb,y^lb);
}
uint ask2(uint i,uint s,uint x,uint y)
{
    if(i==n0) return a[s];
    uint sum=0;
    if(!(y>>i&1)) sum=ask2(i+1,s,x,y);
    else{
        if(!(x>>i&1)) sum=ask2(i+1,s,x,y);
        sum+=ask2(i+1,s^1<<i,x,y);
    }
    return sum;
}
void update(uint x,uint y,uint z)
{
    t[++cnt]={x,y,z};
    if(sz[y]-sz[x]>=n0/2) add1(x,y,z);
    else add2(0,0,x,y,z);
}
uint query(uint x,uint y)
{
    uint ans=0;
    for(int i=1;i<=cnt;i++){
        if(((x|t[i].x)&(y&t[i].y))!=(x|t[i].x)) continue;
        ans+=t[i].z*(1<<sz[(x|t[i].x)^(y&t[i].y)]);
    }
    if(sz[y]-sz[x]>=n0/2) ans+=ask1(x,y);
    else ans+=ask2(0,0,x,y);
    return ans;
}
int main()
{
    cin.tie(0)->sync_with_stdio(0);
    cin>>n0>>q;
    n=1<<n0,B=sqrt(n*n0)+1;
    for(int i=1;i<n;i++) sz[i]=sz[i>>1]+(i&1);
    for(int i=0;i<n;i++) cin>>a[i];
    build();
    for(uint i=1,op,x,y,z;i<=q;i++){
        cin>>op>>x>>y;
        if(op==1){
            cin>>z;
            if((x&y)==x) update(x,y,z);
        }
        else{
            if((x&y)==x) cout<<query(x,y)<<"\n";
            else cout<<"0\n";
        }
        if(cnt>=B) build(),cnt=0;
    }
}
```

---


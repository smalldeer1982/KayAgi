# 「EZEC-2」甜梦

## 题目背景



> 昨是今非望无尽，生死相隔两茫茫。    
解愁肠，度思量，人间如梦，倚笑乘风凉。

## 题目描述

有 $n$ 个梦境场景，编号 $\in [1,n]$ 且互不相同。PF 有精神分裂症，他在同一时间会处于两个梦境。**这两个梦境所在的场景编号差别的绝对值不能大于 $l$**。场景之间有 $m$ 种**单向**关系，其中第 $i$ 个关系连接场景 $u_i$ 和 $v_i$。不存在不可能到达的场景。

每个场景都有一个快乐值，其中第 $j$ 个场景的快乐值为 $a_j$，在梦境**第一次**经过时增加。

一开始两个梦境均在场景 $1$，当两个梦境都移动到场景 $n$ 时，PF会醒来。

如果某次移动时，PF 目前梦境所在的两个场景 $A,B$ 都与某个场景 $C$ **直接相连**，那么 PF 可以**同时移动** 两个梦境到达场景 $C$ 。否则，PF **一次只能移动一个梦境**。

请你编一个程序，来计算醒来时可能得到的最大快乐值。

## 说明/提示

[大样例](https://www.luogu.com.cn/paste/ar8yuqg6)

**【样例解释 #1】**

![](https://cdn.luogu.com.cn/upload/image_hosting/a3bbsu8i.png?x-oss-process=image/resize,m_lfit,h_340,w_500)

下文用 $A,B$ 表示目前正在进行的梦境：

移动梦境 $A \space 1 \to 3$，移动梦境 $B \space 1 \to 4$，移动梦境 $A \space 3 \to 5$，之后同时移动梦境 $A \space B$ 到达场景 $7$，快乐值总和为 $5+10+10 = 25$。

**注意**：如果想移动某一梦境到场景 $6$，那么另一梦境的编号必须大于等于 $4$。然而到 $6$ 的线路只有 $1\to 6$，而同时拥有场景 $1$ 和场景 $4$ 不满足中间相隔场景 $\le l$，故唯一通过场景 $6$ 的方案为将两个梦境同时移动到场景 $6$，而这么做能得到的快乐值为 $20$。

---

**【数据范围与约定】**
| 测试点编号 | $ n \le$ | $ m \le$ | $ l \le$ | $ a_i \le$| 时间 | 特殊性质 |
| :----------: | :----------: | :----------: | :----------: |:----------: | :----------: |:----------: |
| $1,2$ | $10$ | $15$| $5$ | $50$ | $1\text s$ |无 |
| $3\sim 4$ | $16$ | $40$ | $8$ | $5 \times 10^3$ |$1\text s$ |无 |
| $5\sim 6$ | $16$ | $120$ | $8$ | $5 \times 10^3$ |$1\text s$ |无 |
| $7 \sim 10$ | $100$| $10^3$|$10$ | $10^4$|$1 \text s$ |无|
| $11$ | $100$| $10^3$|$10$ | $10^4$|$1\text s$ |场景是一棵树|
| $12 \sim 14$ | $10^3$| $10^4$|$10$ | $10^4$|$1\text s$ |无|
| $15,16$ | $5\times10^3$| $3\times10^4$|$10$ | $10^4$|$1\text s$ |无|
| $17,18$ | $5\times10^3$| $3\times10^4$|$11$ | $10^4$|$2\text s$ |无|
| $19,20$ | $5\times10^3$| $3\times10^4$|$12$ | $10^4$|$3\text s$ |无|

对于 $100\%$ 的数据，$1\le u<v \le n$, $1 \le n \le 5\times 10^3$, $1 \le m \le 3\times 10^4$, $1 \le a_i \le 10^4$, $1 \le l \le 12$。

**输入保证每个场景都能从起点到达，并且都能连到终点。**

**输入不保证没有重边。**

**输入不对 $u,v$ 的编号差做任何保证。**

------------

**【移动范例】**

假设 $l=2$ 且关系存在，下面的格式表示 $A \space B$ $\to$ $A' \space B'$ 一次移动：

* $1 \space 3 \to 5\space 3$ (√)
* $1 \space 3 \to 1\space 4$ (×)
* $1 \space 3 \to 8\space 8$ (√)
* $1 \space 3 \to 6\space 8$ (×)

## 样例 #1

### 输入

```
7 9 2
0 4 5 10 10 20 0
1 2
1 3
1 4
1 6
2 5
3 5
4 7
5 7
6 7```

### 输出

```
25```

# 题解

## 作者：奇米 (赞：12)

# 题解 - $\mathrm{P6603}\ $甜梦

### 题目意思

* [题目传送门](https://www.luogu.com.cn/problem/P6603)

### $\mathrm{Sol}$

* **一道很神仙的状压$DP$**

* 我们发现$l\leq 12$，我们自然而然地想到了状压。于是$f_{S,u}$表示在状态$S$下较小的点为$u$的最大快乐值。$S$这个东西其实是对$[u,u+l]$这段区间的二进制表示。

* 我们如何用较小$u$标号去推出较大标号$v$，我们首先说出结论$v=u+High(S)$。其中$High(S)$为$S$状态下最高位$1$的位置。具体是因为我们的$DAG$是走不了回头路的，所以$v$一定是当前状态下的最高位。这个还是可以理解的吧。

* 接下来我们来看转移，其实莫过于$3$种情况。

* $[1]$ $u,v$同时移动到$P$

  * 那么转移：$f_{1,P}=\max(f_{1,P},f_{S,u}+val_{P})$
  * 这个好理解就是两个点并到一个点，然后更新状态为$1(2^0)$

* $[2]$ $v$移动到$P$，$u$不动

  * 那么转移：$f_{S|(1<<P-u),u}=\max(f_{S|(1<<P-u),u},f_{S,u}+val_P$

   * 这个不需要考虑以前状态是否出现过，因为编号是递增的

* $[3]\ u$移动到$P$，$v$不动

  * 如果此时$P>v$那么$v$成为较小点，于是$f_{(S>>v-u)|(1<<P-v),v}=\max(f_{(S>>v-u)|(1<<P-v),v},f_{S,u}+val_{P})$

   * 此时这个$val_P$要看在上一个状态中是否出现过


   * 如果此时$P<v$那么$P$还是较小点，于是$f_{S>>P-u|1,u}=\max(f_{S>>P-u|1,u},f_{S,u}+val_{P})$


   * 此时这个$val_P$要看在上一个状态中是否出现过

   

* 于是答案就是$f_{1,n}$。就是两个点都在$n$点，其他就是写细节问题啦~~~


### $\mathrm{Code}$

```cpp
#include <bits/stdc++.h>
#define For(i,a,b) for ( int i=(a);i<=(b);i++ )
#define Dow(i,b,a) for ( int i=(b);i>=(a);i-- )
#define GO(i,x) for ( int i=head[x];i;i=e[i].nex )
#define mem(x,s) memset(x,s,sizeof(x))
#define cpy(x,s) memcpy(x,s,sizeof(x))
#define YES return puts("YES"),0
#define NO return puts("NO"),0
#define GG return puts("-1"),0
#define pb push_back
using namespace std;

inline int read()
{
	int sum=0,ff=1; char ch=getchar();
	while(!isdigit(ch))
	{
		if(ch=='-') ff=-1;
		ch=getchar();
	}
	while(isdigit(ch))
		sum=sum*10+(ch^48),ch=getchar();
	return sum*ff;
}

const int mod=1e9+7;
const int mo=998244353;
const int N=5005;
const int M=1<<13|1;

int n,m,l,val[N],a[N][N],f[N][M],High[M];
vector<int> G[N];

int main()
{
	n=read();m=read();l=read();
	For(i,1,n) val[i]=read();
	For(i,1,m)
	{
		int x,y;
		x=read(),y=read();
		if(!a[x][y]) a[x][y]=1,G[x].pb(y);
	}
	For(S,0,(1<<l+1)-1) for ( int j=l+1;~j;j-- ) if((S>>j)&1)
	{
		High[S]=j;
		break;
	}
	memset(f,-1,sizeof(f));
	For(i,1,n)
	{
		if(f[i][1]==-1) f[i][1]=0;
		For(S,0,(1<<l+1)-1)
		{
			if(!(S&1)) continue;
			int idv=i+High[S];
			if(f[i][S]==-1) continue;
			For(j,0,(int)G[idv].size()-1)
			{
				int v=G[idv][j];
				if(a[i][v]) f[v][1]=max(f[i][S]+val[v],f[v][1]);
				if(v-i>l) continue;
				int nxt=S|(1<<v-i);
				f[i][nxt]=max(f[i][nxt],f[i][S]+val[v]);
			}
			For(j,0,(int)G[i].size()-1)
			{
				int v=G[i][j];
				if(v-idv>l) continue;//1:
				if(v>idv)
				{
					int nxt=(S>>idv-i)|(1<<v-idv);
					if(S>>v-i&1) f[idv][nxt]=max(f[idv][nxt],f[i][S]);
					else f[idv][nxt]=max(f[idv][nxt],f[i][S]+val[v]);
				}
				else 
				{
					int nxt=S>>v-i|1;
					if(S>>v-i&1) f[v][nxt]=max(f[v][nxt],f[i][S]);
					else f[v][nxt]=max(f[v][nxt],f[i][S]+val[v]);
				}
			}
		}
	}
	printf("%d\n",f[n][1]);
	return 0;
}
				
		
		
```

   

---

## 作者：pocafup (赞：8)

**P0:题外话**：

update: 赛后的空间给足了256MB，现在只要写正解都能过。

~~废话有点多，不想看的直接往下翻~~

~~这题真是我梦里想出来的2333~~

有人写出我的题了，好开心啊!（雾

不过这次特殊奖励没人拿到有点可惜惹

某天醒来突然发现某大佬问我某个测试点为啥WA，一看他的暴力剪枝解法 $95$ 。。。这才发现数据的垃圾（事实证明那个剪枝不可行，当时还怀疑我的方法不是唯一解法233）

这道题正解完全不卡时间空间，std的时空在不开 $O_2$ 的情况下均有十倍以上的宽裕(而且std并没有卡常)。空间和时间的紧迫仅对于某些不是正解的满分做法适用（~~所以我没卡那些做法就不算毒瘤吧~~）

卡空间的原因有四个：

1.这题的空间能够优化 $400$ 倍以上

2.这题的正解是一个常用的方法以不那么常见的方式写

3.在卡空间的情况下时间复杂度不变

4.正解的方法不少，而且每种都有存在的意义

我既然敢卡就敢承担责任。要喷请尽情喷，如果有道理的我一定会接受。

------------
**P1:最基础的观察：**

虽然不观察这个解题也没影响¿

由于可以同时走并且保证连通，这题不可能出现无解状态。(~~没错就是为了考观察闲着无聊加上去的~~)

为啥要这么搞呢？因为上次无解给了五分，结果到结束没人写正解，倒是有超过 $50$ 人骗了五分。。。

不是说这种骗分不好，但是到时候来个捆绑这种骗分不就蒙了吗（

当然，这次仍然给了骗分的数据，后面会讲到。

------------

**P2:题解：**

对于 $ n <= 10$ 的点，暴力 $dfs$，复杂度 $O(n!)$。

裸的 $dfs$ 我放了一手，给了 $20$ 分，放过了两个不稠密的 $n\le 16$ 的点。但如果要毒瘤起来不注重常数优化连 $n<=10$ 都未必过得去。

核心枚举代码：
```
inline void dfs(int fir, int sec, int num){
  if (fir==sec && sec==n) {ans = max(ans,num);return;}
  for (int v : adj[fir]){
    if (mp[sec][v]) dfs(v,v,num+pos[v]);//如果他俩同时能去某个点
    if (abs(v-sec)>l) continue;//如果去的点跟sec差太远了
    if (!vis[v]){
      vis[v] = true;
      dfs(v,sec,num+pos[v]);//如果这个点没去过,就加上点权去一次
      vis[v] = false;
    }else{
      dfs(v,sec,num);//如果去过,可以不加点权去一次
    }
  }
  for (int v : adj[sec]){
    if (abs(v-fir)>l) continue;
    if (!vis[v]){
      vis[v] = true;
      dfs(fir,v,num+pos[v]);
      vis[v] = false;
    }else{
      dfs(fir,v,num);
    }//同上
  }
}
```

------------
对于 $ n <= 16$ 的点，考虑全局状压。用 $dp[i][j][k]$ 来记录在取点状态为 $i$，且两个点分别在 $j$ 和 $k$ 时能得到的最大快乐值。转移为:

$$ dp[i][j][k] = \left\{
\begin{aligned}
&dp[i+(1<<v_{j})][v_{j}][k]& \\
&dp[i+(1<<v_{k})][j][v_{k}]& \\
&dp[i+(1<<v_{j,k})][v_{j,k}][v_{j,k}]&
\end{aligned}
\right.
$$


复杂度 $O(2^n*n^2)$。

------------
对于 $ n <= 100$ 的点，$dp$ 记录全局状态显然不可取。

因为 PF 不会走回头路，所以当两个点的编号均大于一个数 $K$，那么状态内所有比 $K$ 小点都没有任何意义。因此，我们可以选择只记录两个节点之间的状态。而这个状态的数量为 $2^l$。于是，我们的 $dp$ 变为四维：$dp[i][j][k][l]$，其中 $i$ 表示已经没用的点数，$j$ 表示这十个点的状态，$k,l$ 分别表示左右两个梦境在这十个点的位置。

状态要考虑一下怎么移动，比如在这题中 $0100010$ 可以简化为 $0010001$。

转移方法没有变化，复杂度为 $O(n\times2^l \times l^2)$

另一种可行方法为 $dp[i][j][k]$，$i$ 表示十个点之间的状态，$j,k$ 暴力记录左右两点的位置进行转移，复杂度 $O(2^l \times n^2)$，都能通过这组数据。

------------
对于 $ n <= 10^3$ 的点，考虑降维。

~~通过观察~~，可以发现转移的时候如果存的编号较小的点不是 $l$ 个状态的第一个点，那么这个点前面的点仍然没有意义。

因此，我们可以让较小的点严格为状态的第一点，存储 $dp[i][j][k]$，其中 $i$ 表示较小点的编号，$j$ 表示目前的状态，$k$ 表示较大的点，而较大点的编号为 $i+k$，可证 $k$ 的最大值不会超过 $l$。

于是，我们的时间就减少到了 $O(n \times 2^l \times l)$，能够通过这组数据。

------------
对于 $ n <= 5 \times 10^3,l\le 11$ 的点，考虑只记录一个点。

我们能够发现，当较小点为状态中的第一个时，较大点一定会是状态中编号的最大的那个点（因为没法走回头路，而较小的点固定在第一个，如果目前点编号不够状态中最大点的编号大，那么那个最大点不可能被到达过）。于是，我们可以只存储 $dp[i][j]$，分别表示较小点的的编号以及现在的状态。

求某个状态下的最大点可以用数组预处理记录：把每种 $l$ 的最大点列举一遍，开一个数组记录就能做到 $O(2^l)$ 的预处理之后 $O(1)$ 求出某状态下的最大点。

转移方法: (下面用 $curr$ 表示较大点)

$$ dp[i][j] = \left\{
\begin{aligned}
&dp[i][j+(1<<v)] \space\{v-i \le l\}&\\
&dp[v][(j>>(i-v))|1] \space \{v<curr\} &\\
&dp[curr][(j>>(curr-i)) + (1<<(v-curr))] \space \{ 0\le v-curr \le l\}&\\
&dp[v][1] \{i \to v\space \&\&\space curr \to v\}&

\end{aligned}
\right.
$$

核心预处理和转移代码：
```cpp
  for (int i=1;i<(1<<(l+1));i++){
    for (int k=l+1;k>=0;k--){
      if ((i>>k) & 1) {top[i] = k; break;}
    }
  }//预处理
  memset (dp,0xff,sizeof(dp)); dp[1][1] = 0;
  for (int i=1;i<=n;i++){
    for (int j=1;j<(1<<(l+2));j++){
      int curr = i+top[j];//较大点的编号
      if (dp[i][j]==-1 || ((j|1)!=j)) continue;//如果这个状态不可到达或者较小点不在2^0那里.
      for (int v : adj[curr]){//较大点的转移
        if (mp[i][v]) dp[v][1] = max(dp[v][1],dp[i][j]+pos[v]);
        if (v-i>l) continue;//不能跟较小的差距太大
        int nxt = j+(1<<(v-i));//转移后的状态
        dp[i][nxt] = max(dp[i][nxt],dp[i][j]+pos[v]);
      }
      for (int v : adj[i]){
        if (v-curr>l) continue;//如果转移后比较大点大太多
        if (v>curr){//注意:如果转移的点比较大点大,那么较大点现在变成较小点,需要直接替换i并进行移位操作
          int nxt = (j>>(curr-i)) + (1<<(v-curr));
          dp[curr][nxt] = max(dp[curr][nxt],dp[i][j]+(((j>>(v-i))&1) ? 0 : pos[v]));
        }else{//否则用v代替和移位
          int nxt = (j>>(v-i))|1;
          dp[v][nxt] = max(dp[v][nxt],dp[i][j]+(((j>>(v-i))&1) ? 0 : pos[v]));
        }
      }
    }
  }
  cout << dp[n][1] << endl;
}
```

复杂度 $O(2^l + n\times2^l)$。

这档部分分好像也可以用 $bfs$ 状压或 $dfs$ 状压实现？不过出题人太懒了就没写。

------------
对于 $ n <= 5 \times 10^3,l\le 12$ 的点，上面的方法虽然时间复杂度正确，但空间会爆炸。

思考一下，当我们存任意一个点时，由于状态不可能不存。空间复杂度一定为 $n*2^l$。于是，我们只能想想怎么一个点都不存。

为了不刻意卡空间常数，我给了 $128MB$。这意味着刚才的解法只会爆两倍空间。因此，我们可以~~乱搞一波~~。

做法一(离散化)：

我们发现，在保证 $dp$ 第一维是最小点的时候，第二维的状态如果不含有$1$，那么这个状态无意义。

知识点一：我们可以对状态进行筛选，并离散化状态。此做法能够节省 $2$ 倍空间与时间，刚好能够通过这个数据。

部分离散代码：

```cpp
for (int i=1;i<(1<<(l+1));i++){
    if ((i|1)==i) num.push_back(i),head[i] = num.size()-1;
}

...

for (int i=1;i<=n;i++){
    for (int z=0;z<num.size();z++){
      int j = num[z];
      int curr = i+top[j];

...

	for (int v : adj[curr]){//较大点转移，原理与最小点一样，因此只放一个。
          if (mp[i][v]) dp[v][0] = max(dp[v][0],dp[i][z]+pos[v]);
          if (v-i>l) continue;
          int nxt = head[j+(1<<(v-i))];
          dp[i][nxt] = max(dp[i][nxt],dp[i][z]+pos[v]);
     	}
```

做法二 (map)：

我们发现，当某个点的转移全部完成，那么这个点的所有数据都没有任何意义了。因此，我们可以使用 unordered_map 来记录。而 $umap$ 的查询为大常数的 $O(1)$ ，我在这里暂且当他为 $O(1)$。

于是，我们的做法变为：当一个点的转移全部结束，我们就将它的所有状态删除。

知识点二：我们可以建一个局部变量，然后将它跟 $map$ 的某维进行置换，时间删除由 $O(n)$ 的 $map.clear()$ 变为 $O(1)$。

```cpp
unordered_map<int,int> tmp;
if (i!=n)swap(tmp,dp[i]);
 ```
 
这个常数会让这种做法跑不进一秒，所以时限我开大了。

此做法能够跟做法一结合，在这个基础上快两倍，对卡常的玩家更加友好。

【正解】做法三(滚动数组)：

~~显然~~这题的滚动数组并不能用 $dp[2][1<<l]$ 求。原因是每个编号不止会关联到他后面那一个。

但是，根据题目发现，每个编号最多只会关联到后面 $l$ 个。因此，我们可以使用 $dp[l+1][1<<l]$ 来存。这样能够保证在滚动的同时不遗漏。

对于同时移动的操作，由于滚动数组的原因，我们无法在 $dp$ 内记录。然而，我们可以另开一个数组，记录当两点同时到达某个点时的最大值，然后当使用的时候先取了最大值再开始转移。

```cpp
#include <iostream>
#include <unordered_map>
#include <algorithm>
#include <vector>
#include <fstream>
#include <cstring>
#include <vector>
using namespace std;
const int MAXN = 5e3+5;
const int MAXL = 13;
unordered_map<int,unordered_map<int,bool> > mp;
int n,m,l,pos[MAXN],dp[MAXL][(1<<MAXL)+5],top[(1<<MAXL)+5],big[MAXN],ans,now;
vector<int> adj[MAXN],num;
inline int max(int a, int b) {return a>b?a:b;}
int main(){
  cin >> n >> m >> l;
  for (int i=1;i<=n;i++) cin >> pos[i];
  for (int i=1;i<=m;i++){
    int a,b; cin >> a >> b; if (!mp[a][b]) mp[a][b] = true,adj[a].push_back(b);
  }
  memset(top,0xff,sizeof(top));
  for (int i=1;i<(1<<(l+1));i++){
    for (int k=l+1;k>=0;k--){
      if ((i>>k) & 1) {top[i] = k; break;}
    }
  }//预处理
  memset (dp,0xff,sizeof(dp));
  for (int i=1;i<=n;i++){
    now = (i-1)%MAXL;//现在编号在滚动数组的位置
    dp[now][1] = max(dp[now][1],big[i]);//先保证这东西最大
    for (int j=1;j<(1<<(l+1));j++){
      int pos1 = i;
      int pos2 = i+top[j];
      if (dp[now][j]==-1) continue;
      for (int v : adj[pos2]){
        if (mp[pos1][v]) big[v] = max(big[v],dp[now][j]+pos[v]);//额外的数组
        if (v-i>l)continue;
        int nxt = j+(1<<(v-pos1));
        dp[now][nxt] = max(dp[now][nxt],dp[now][j]+pos[v]);
      }
      for (int v : adj[pos1]){
        if (v-pos2>l) continue;
        if (v>pos2){
          int nxt = (j>>(pos2-pos1)) + (1<<(v-pos2));
          int to = (pos2-1)%MAXL;
          dp[to][nxt] = max(dp[to][nxt],dp[now][j]+(((j>>(v-pos1)) & 1) ? 0 : pos[v]));
        }else{
          int nxt = (j>>(v-pos1))|1;
          int to = (v-1)%MAXL;
          dp[to][nxt] = max(dp[to][nxt],dp[now][j]+(((j>>(v-pos1)) & 1) ? 0 : pos[v]));
        }
      }
      if (i!=n)dp[now][j] = -1;//操作完就将它设为-1,注意别把终点给更了。。。
    }
  }
  cout << dp[(n-1)%MAXL][1] << endl;
}
```

这里对转移点用了 $map$，如果改用数组存，时间会快一倍，空间大两倍(反正都是20M以下)。

赛时某位神仙用他自己的做法写过去了，这里不讲，如果他愿意可以发题解搞贡献分。

------------


**P3:骗分做法**

1.良心骗分 $5$ 分去哪了？其实在第 $11$ 个测试点那

观察题意发现，每个点都能从起点到达，并且都能连到终点。由于梦境是一棵树，故要将所有单向边连起来并连到终点的方法一定唯一：$1 \to 2 \space  $ $&&$ $ \space 2\to 3 ...$。所以不管梦境选择再怎么花里胡哨，两个点同时往后一格一格走就能保证拿满，而答案就是所有快乐值加起来。

2.某些贪心做法

在 $dfs$ 的时候只记录两个点进行转移，记录 $dp[i][j]$， 如果经过这个点的时候 $dp[i][j]$ 太小了，那么直接跳过。

这个做法就是数据垃圾时 $95$ 的做法。然而，我们可以观察到，哪怕你记录了 $dp[i][j]$，上次经过和这次经过时中间点的取舍可能不一样，故这个贪心不成立(但是搞笑的是，有 $80\%$ 以上的数据用词解法跟正解答案相同，所以数据造得我怀疑人生)。

不仅如此，这个贪心的复杂度仍然是 $O(n!)$，能过 $100$ 都很幸运了。

为了给骗分的机会，我给了这种解法额外的 $10$ 分，其他会$WA+TLE$。

对贪心进行分别判断，在 $n\le16$ 时不进行贪心，并进行各种玄学常数优化，能够再拿十分。

因此，无任何状压能拿到的分数是 $20(基础)+10(撞正解)+5(树链子)+10(常数优化) = 45$ ，应该在不写正解的情况下算良心的了。



---

## 作者：syksykCCC (赞：5)

不卡空间了，好评，可以去掉滚动数组了（雾

首先发现 $l$ 相当小，另外图是一个 DAG，所以可以考虑状压 dp。

于是可以用 $f_{u, S}$（$S$ 是一个压位的二进制数）来表示其中较小点在 $u$ 时的最大快乐值。$S$ 代表的是编号为 $[u, u+l]$ 的结点的访问状态（$1$ 表示访问过了，$0$ 表示没访问过）。这意味着，$S$ 可以理解为一个长度为 $l+1$ 的 bitset。

下面用 $S_i$ 表示 $S$ 的第 $i$ 位的值（最低位为 $0$，最高位为 $l$）。

显然，如果 $S_0 = 0$ 的话这个状态可以废掉了，因为 $S_0$ 代表的是 $u$ 这个点，既然 $f_{u, S}$ 表示较小点在 $u$，那 $u$ 不可能没被访问过。

我们只知道了一个点，那么，能不能知道另一个点 $v$ 在哪里呢？

很显然，因为随着移动，$u$ 和 $v$ 只会单调上升，因此，$S$ 的最高位（指的是为 $1$ 的最高位）所代表的值就是 $v$ 的编号。这是因为如果 $v$ 不是最高位的话，比 $v$ 大的位置是不可能访问过的。

于是可以预处理个 $\operatorname{highbit}(S)$ 表示 $S$ 的最高位的**编号**（返回值为 $[0, l]$），则有 $v = S + \operatorname{highbit}(S)$。

不妨采用「去更新」的方式转移，对于一个 $f_{u, S}$，可以用来转移哪些状态呢？

*下文 $f_x + z\to f_y$ 可以理解为 $f_y = \max\{f_y, f_x + z\}$，也就是所谓「去更新」的意思。

分类讨论一下:

1. 同时跑  

   枚举一个 $w$，$w$ 显然可以为任何**同时和 $u, v$ 连通的数**，那么，最终状态就是两个点都在 $w$，也就是 $f_{w, 1}$，所以用 $f_{u, S} + a_w \to f_{w, 1}$。

   代码中这个和第二种情况写在了一起，目的是方便（

2. 只跑大的

   显然，大的跑完后还要保证 $w - u \le l$，那么枚举完与 $v$ 连通的 $w$ 后，可以先确保这个约束成立，记 $S'$ 为新的状态，则：
  
   $$ S' = S \cup (w -u) $$

   也就是标记 $w$ 访问过了，然后，用 $f_{u, S} + a_w \to f_{u, S'}$。

3. 只跑小的

   这种应该是最麻烦的了。
  
   同样枚举一个和 $u$ 连通的 $w$，同时要确保 $w - v \le l$ 成立（这里不需要取 $|w - v|$ 的绝对值，想一想，为什么？）
  
   再分情况讨论：
  
   * 第一个是 $w > v$，那么这时较小的点变成了 $v$，也就是原来的 $S_0$ 对应的是 $u$，现在则对应 $v$，后面的也要随之变化，可以用 `S >> (v - u)` 来体现，后面为了数学公式规范用 $\operatorname{up}_{u \to v}(S)$ 来表示。
  
     $$ S' = \operatorname{up}_{u \to v}(S) \cup (w - v)$$
  
     如果 $S_{w - u} = 1$ 了，那么说明 $w$ 之前已经访问过，不再累加贡献，$f_{u, S} \to f_{v, S'}$，否则 $f_{u, S} + a_w \to f_{v, S'}$。
   
   * 第二个是 $w < v$，同理，有：
   
     $$ S' = \operatorname{up}_{u \to w}(S) \cup (w - w) $$
     
     如果 $S_{w - u} = 1$，则 $f_{u, S} \to f_{w, S'}$，否则，$f_{u, S} + a_w \to f_{w, S'}$。

那么，最终答案就是 $f_{n, 1}$（两个点都在 $n$）。

$-1$ 其实不用单独判断，只要先将 $f$ 的初始值都赋值为 $-1$，如果 $f_{n, 1}$ 没有合法来源更新过，自然就是 $-1$ 了。

时间复杂度 $O(n 2^l)$。

代码仅供参考。

```cpp
#include <bits/stdc++.h>
#define rg register
using namespace std;
inline int read()
{
	int v = 0; char c = getchar();
	while(c < '0' || c > '9') c = getchar();
	while(c >= '0' && c <= '9') v = (v << 3) + (v << 1) + (c ^ 48), c = getchar();
	return v;
}
const int N = 5e3 + 5, L = 13;
int n, m, l, val[N], highbit[1 << L];
int f[N][1 << L];
vector<int> G[N];
unordered_map<int, unordered_map<int, bool> > mp; 
int main()
{
	n = read(); m = read(); l = read();
	for(rg int i = 1; i <= n; i++) val[i] = read();
	for(rg int i = 1; i <= m; i++)
	{
		int u = read(), v = read();
		if(!mp[u][v])
		{
			mp[u][v] = true;
			G[u].push_back(v);
		}
	}
	for(rg int i = 1; i < (1 << l + 1); i++)
	{
		for(rg int k = l + 1; ~k; k--)
		{
			if(i >> k & 1)
			{
				highbit[i] = k;
				break;
			}
		}
	}
	memset(f, -1, sizeof f);
	for(rg int i = 1; i <= n; i++)
	{
		if(f[i][1] == -1) f[i][1] = 0; 
		for(rg int s = 1; s < (1 << l + 1); s++)
		{
            if(s & 1 == 0) continue; // 最小的点（自己）没到达过的状态可以歇了 
			int u = i, v = i + highbit[s];
			if(f[u][s] == -1) continue;
			for(int w : G[v])
			{
				// 同时跑 
				if(mp[u][w]) f[w][1] = max(f[w][1], f[u][s] + val[w]);
				
				// 只跑大的 
				if(w - u > l) continue;
				rg int nxt = s | (1 << w - u);
				f[u][nxt] = max(f[i][nxt], f[u][s] + val[w]);
			}
			for(int w : G[u]) // 转移小的点
			{
				if(w - v > l) continue;
				if(w > v) // 小的点变成 v
				{
					rg int nxt = (s >> v - u) | (1 << w - v);
					if(s >> w - u & 1) // 原本走过 w 了 
						f[v][nxt] = max(f[v][nxt], f[u][s]);
					else f[v][nxt] = max(f[v][nxt], f[u][s] + val[w]);
				}
				else // 小的点变成 w 
				{
					rg int nxt = s >> w - u | 1;
					if(s >> w - u & 1) // 原本走过 w 了 
						f[w][nxt] = max(f[w][nxt], f[u][s]);
					else f[w][nxt] = max(f[w][nxt], f[u][s] + val[w]);
				}
			}
		}
	}
	printf("%d\n", f[n][1]);
	return 0;
}
```

---

## 作者：Glacial_Shine (赞：2)

数据范围提示题。

看一眼数据范围，发现是个 DAG 并且只能从编号小的往编号大的走。

绝对值之差的范围也提示了状压。

考虑记 $f_{u, s}$ 表示两个点中编号较小的点为 $u$，且此时从 $u$ 往后 $l$ 个点的状态（是否经过）为 $s$。

此时发现另一个点 $v$ 就是编号最大被经过的点。

于是直接转移就可以了。

注意维护的 $s$ 是维护几位，包不包括 $u$ 当前这一位，避免枚举错误。

## Code

```cpp
#include <bits/stdc++.h>
using namespace std;
const int INF = 1e9;
int n, m, l, a[5005];
int f[5005][1 << 13], mp[5005][5005];
vector <int> E[5005];
int high(int s) {
    for (int i = l; i >= 0; i--)
        if ((s >> i) & 1)
            return i;
}
int main() {
    scanf("%d%d%d", &n, &m, &l);
    for (int i = 1; i <= n; i++)
        scanf("%d", &a[i]);
    for (int i = 1, u, v; i <= m; i++)
        scanf("%d%d", &u, &v), E[u].push_back(v), mp[u][v] = true;
    memset(f, -1, sizeof(f));
    f[1][1] = 0;
    for (int u = 1; u <= n; u++) {
        for (int s = 1; s < (1 << l + 1); s += 2) {
            if (f[u][s] == -1)
                continue;
            int v = u + high(s);
            // v 往后走
            for (auto to : E[v]) {
                if (mp[u][to])
                    f[to][1] = max(f[to][1], f[u][s] + a[to]);
                    // 两个同时往后走，此时因为不存在比 u，v 编号大的点被经过，所以新的状态 s 即为 1
                if (to - u > l)
                    continue;
                f[u][s | (1 << to - u)] = max(f[u][s | (1 << to - u)], f[u][s] + a[to]);
            }
            // u 往后走
            for (auto to : E[u]) {
                if (to - v > l)
                    continue;
                if (to > v) {
                    int nxt = (s >> (v - u)) | (1 << to - v);
                    f[v][nxt] = max(f[v][nxt], f[u][s] + (((s >> to - u) & 1) ? 0 : a[to]));
                }
                else {
                    int nxt = (s >> (to - u)) | 1;
                    f[to][nxt] = max(f[to][nxt], f[u][s] + (((s >> to - u) & 1) ? 0 : a[to]));
                }
            }
        }
    }
    printf("%d\n", f[n][1]);
    return 0;
}
```

---

## 作者：yizhiming (赞：0)

## 题目大意

给定一个 $n$ 个点，$m$ 条边的图。

有两个人，初始在节点 $1$，每次两个人可以同时移动到他们俩当前同时直接相连的一个节点，或者其中一个人单独移动到其直接相连的一个节点。

每个节点有点权 $a_i$，第一次经过时会累加点权作为贡献，要保证两个人任意时刻所在节点坐标差不能超过 $l$，求两人同时到达节点 $n$ 时的最大点权和。

$1\leq n\leq 5\times 10^3,1\leq m \leq 3\times 10^4,1\leq a_i\leq10^4,1\leq l\leq 12$。

## 题目分析

个人感觉是一道很妙的动态规划，我们观察数据范围，发现 $1\leq l\leq 12$，那这就说明了这道题的突破口在 $l$ 上，仔细读题，发现下标差不超过 $l$，说明当 $u$ 确定时，$v$ 能在的节点范围很小，我们考虑用状压，直接维护这个东西，假设 $u$ 是当前下标较小的节点，那么用 $dp_{u,st}$ 表示当前较小的节点为 $u$ 时，下标在 $[u,u+l]$ 的信息为 $st$。

但是这时候就有人要问了，如果我只记录这些信息，到时候我走回头路时怎么处理呢？

我们要仔细观察题目：

- 边满足 $u<v$。

- 输入保证每个场景都能从起点到达，并且都能连到终点。

这保证了什么？~~保证有解~~保证这个图是一张 $DAG$（有向无环图），这有什么优美性质呢？我们不会走回头路，那么上面的那个疑问就解决了。同时还表示，当前下标最大的节点，必定有一个人在，因为走不了回头路嘛，这样也顺手解决了怎么表示当前人所在节点的问题：

设 $hb_{st}$ 表示 $st$ 最高位的 $1$ 是哪一位，那么状态 $dp_{u,st}$ 的另一个人所在的节点 $v$ 的下标即为 $u+hb_{st}$。

## 具体做法

感觉铺垫的差不多了，我们每次转移考虑以下几种情况：

- 如果当前两个点都能到达点 $now$，那么可以直接转移过去，否则考虑转移单点
- 考虑转移单点的时候，我们考虑哪个点转移，如果转移 $v$，那么不做特殊处理，若转移 $u$，则需要判断枚举到的点 $now$ 与 $v$ 的下标哪个更大，如果 $now>v$ 要注意更改 $v$ 为当前较小的值，同时还要考虑当前枚举的节点 $now$ 之前的贡献是否加上了。

具体的写法和细节看看代码应该就好

最后答案就是 $dp_{n,1}$ 表示最后两个人都在 $n$ 节点。

## Code

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <queue>
#include <cmath>
using namespace std;
int read(){
	int x=0,f=1;char ch = getchar();
	while(ch<'0'||ch>'9'){if(ch=='-'){f=-1;}ch = getchar();}
	while(ch>='0'&&ch<='9'){x = x*10+ch-'0';ch = getchar();}
	return x*f;
}
const int N = 5e3+5;
const int S = (1<<13)+5;
bool e[N][N];
int a[N];
struct aa{
	int nxt,to;
}edge[N*6];
int head[N],hb[S];
int tot;
void add(int u,int v){
	edge[++tot].nxt = head[u];edge[tot].to = v;head[u] = tot;
}
int dp[N][S];
int main(){
	int n,m,l;
	n = read();m = read();l = read();
	for(int i=1;i<=n;i++){
		a[i] = read();
	}
	int u,v;
	while(m--){
		u = read();v = read();
		if(!e[u][v]){
			e[u][v]=1;
			add(u,v);
		}
	}
	int s = (1<<(l+1))-1;
	for(int i=1;i<=s;i++){
		for(int k=l+1;k>=0;k--){
			if((i>>k)&1){
				hb[i] = k;
				break;
			}
		}
	}
	memset(dp,-1,sizeof(dp));
	dp[1][1] = 0;
	for(int i=1;i<=n;i++){
		if(dp[i][1]==-1){
			dp[i][1] = 0;
		}
		for(int st=1;st<=s;st+=2){//有些小细节就在代码写了
			//比如这里 st+=2 是为了保证 st 第1位是 1，以保证当前状态内 u 出现过 
			int u = i,v = i+hb[st];
			if(dp[u][st]==-1){
				continue;
			}
			for(int j=head[v];j;j=edge[j].nxt){
				int now = edge[j].to;
				if(e[u][now]){
					dp[now][1] = max(dp[now][1],dp[u][st]+a[now]);
				}
				if(abs(now-u)>l){//这里和下面其实不用加 abs 我一开始读题没注意到 u<v 这一限制 
					continue;
				}
				dp[u][st|(1<<(now-u))] = max(dp[u][st|(1<<(now-u))],dp[u][st]+a[now]);//比v大的数当前贡献一定没记录，所以不用分讨 
			}
			for(int j=head[u];j;j=edge[j].nxt){
				int now = edge[j].to;
				if(abs(v-now)>l){
					continue;
				}
				if(now>v){
					int res = (st>>(v-u))|(1<<(now-v));//这里自己手玩一下就知道怎么由 u-v 变成 v-now 了 
					dp[v][res] = max(dp[v][res],dp[u][st]+a[now]);//这里没必要分讨，还是因为比 v 大的数贡献一定没记录 
				}else{
					int res = (st>>(now-u))|1;
					if((st>>(now-u))&1){//分讨 
						dp[now][res] = max(dp[now][res],dp[u][st]);
					}else{
						dp[now][res] = max(dp[now][res],dp[u][st]+a[now]);
					}
				}
			}
		}
	}
	cout<<dp[n][1]<<"\n";
	return 0;
}

```

最后完结撒花咯

---


# 『PG2』模拟最大流

## 题目描述


给定 $n$ 个点，$m$ 条有向边，给定每条边的容量，保证每条边 $(u,v,w)$ 满足 $v-u\in[0,k]$，求从点 $1$ 到点 $n$ 的最大流。

## 说明/提示

对于 $20\%$ 的数据满足 $n\leq 10^2$，$m\leq 10^4$，$k\leq 2$。

对于 $40\%$ 的数据满足 $n\leq 10^4$，$m\leq 10^6$，$k\leq 2$。

对于 $60\%$ 的数据满足 $n\leq  8\times 10^4$，$m\leq 10^6$，$k\leq 2$。

对于 $80\%$ 的数据满足 $n\leq  8\times 10^4$，$m\leq 10^6$，$k\leq 4$。

对于 $100\%$ 的数据满足 $2\leq n\leq 8\times 10^4$，$1\leq m\leq 10^6$，$2\leq k\leq 7$，$1\leq w\leq100$。

## 样例 #1

### 输入

```
9 21 3
1 2 1
2 3 1
3 4 1
4 5 1
5 6 1
6 7 1
7 8 1
8 9 1
1 3 1
2 4 1
3 5 1
4 6 1
5 7 1
6 8 1
7 9 1
1 4 1
2 5 1
3 6 1
4 7 1
5 8 1
6 9 1```

### 输出

```
3```

## 样例 #2

### 输入

```
5 10 2
3 5 73
3 4 33
3 5 84
4 5 10
3 4 15
1 2 83
1 3 8
1 3 24
5 5 15
1 2 62```

### 输出

```
32```

# 题解

## 作者：enucai (赞：9)

大家好像都在写 $O(n3^k)$，呃呃。

首先最大流转成最小割，考虑状压，令 $f_{i,S}$，表示考虑了 $[1,i]$ 这些点，源点仅能走到点集 $S$ 中的点，最小割掉的边权总和。

由于有 $u\to v$，$v-u\le k$，所以对于 $S$，我们只需要保留 $[i-k+1,i]$ 这个区间内的点即可，因为前面的点都不可能走到 $>i$ 的点。

转移时暴力枚举子集是 $O(n3^k)$ 的，但是发现如果最终能走到 $i$，那么所有 $x\to i$ 的边都不割是最优的，否则就得割掉所有 $S$ 集合中 $x\to i$ 的边，复杂度 $O(n2^k)$。

---

## 作者：sangshang (赞：5)

## 前言

本题的本意应该是使用状压 DP，在时间复杂度 $O(n\times 3^w)$ 内求解。w 指边权值域。

因为不难发现，本题数据量很大，但边权很小。

于是我们考虑使用最大流算法 AC。

**本题解意义并不是乱搞靠卡常 AC，而是优化最大流算法。**

# 正文

这是一道紫题，不可能让你用 Edmond\_Karp 或者是 Dinic 和 ISAP 这类算法通过的。我们也不在这里讨论。~~绝不是我不会优化。~~

翻开算法库，还有一种算法，时间复杂度更优。那就是**最高标号预流推进算法 HLPP，时间复杂度 $O(n^2\times \sqrt{m})$。**

如果你不知道，可以看这道题。[P4722 【模板】最大流 加强版 / 预流推进](https://www.luogu.com.cn/problem/P4722)

就算你用了，但你会发现，还是会 TLE。

请检查你在上面题目中总用时，如果是 5s，那肯定没戏，如果是 500ms，那也很难，要优化到 245ms，才到位。

# HLPP

回顾 HLPP 算法的本质，按照节点高度，进行超额推流。

源点超额流是 $+\infty$，因此我们在算法一开始，将所有以源点为出点的边都进行饱和推流，之后的算法过程中，源点高度始终为 n，等于退出算法。

除源点外，节点高度 $h_u$，表示以 u 为出点还有剩余容量的边 $e\in E$ 中，$\min\ h_{e_{to}}+1$。每次推流当且仅当，节点还有超额流，推流的边还有剩余容量，推流到达节点高度加一等于当前节点高度。

显然会有两种情况。一种，超额流被推完了，结束推流；一种，超额流没有被推完，此时就不能再奢求以当前高度推流，只能在还有剩余容量的边中重新计算高度，重新推流。

## 优化一 全局标签重贴

如果大量超额流被推送出去，当推到后面发现推不出去了，此时只能通过修改节点高度回流。

但节点高度不是一次修改到位，而是节点之间反复推流，不断增加高度。这可太浪费了。因此我们使用全局标签重贴，每过一会儿，就直接重新设置节点高度，一次修改到位。

一次全局标签重贴是时间复杂度是 $O(n+m)=O(m)$，整个算法复杂度是 $O(n^2\times \sqrt{m})$，考虑稠密图情况，我们能进行 n 次全局标签重贴。高度修改不会超过 $n^2$，也就是每修改 n 次能进行 1 次，算上常数，大概进行 $\lfloor n\div 4\rfloor$ 次最优。

## 优化二 当前弧优化

容易发现不饱和推流对算法影响较小，不用修改高度。明显，如果一次不饱和推流从自己的边 1 推到边 i，那么 $[1,i)$ 的边都没有可继续推流的边。下次直接从边 $i$ 开始推流。

事实上，如果不加当前弧优化，时间复杂度会退化，加了才正确。

注意，如果是饱和推流，修改高度后，要重设当前弧。

## 优化三 gap 优化

超额流的推进一定是一步一个台阶，有序向下的。但如果楼梯断了，显然断层上的楼梯都没有用处了，此时直接废弃它们，能够节省很多时间。

## 优化四 桶写

如果使用堆进行维护等待推流的节点，时间复杂度会多一个 $\log_2n$，很不理想，因此我们选择进行桶装维护，将维护复杂度降到 $O(1)$。不仅如此，桶写还优化了 gap，使其更方便。

同时，高度超过 n 的节点就不再维护，等于被踢出算法，这大概能减少一点常数。

## 优化五 存图

使用 `std::vector` 进行存图会更快，这大概是因为内存访问更连续，速度更快。


------------


可能是因为过度使用 STL，不开 O2 还是卡常，但只要开 O2，运行效率不亚于 DP 做法。

## Code

```cpp
#include <bits/stdc++.h>

//using namespace std;
struct HLPP {
	public:
		typedef int ANS_TYPE;
		struct edge {
			int to, rev;
			ANS_TYPE flow;
			edge(int to, ANS_TYPE flow, int rev): to(to), flow(flow), rev(rev) {}
			edge() {}
		};
		int n, m, s, t, maxh, maxgaph, workcnt;
		std::vector< std::vector<edge> >vec;
		std::vector<ANS_TYPE>ov;
		std::vector<int>h, cur, ovlist, ovnex, gap, gapprv, gapnex;
		HLPP(int n, int m, int s, int t): n(n), m(m), s(s), t(t), maxh(0), maxgaph(0), workcnt(0),
			vec(n + 1), ov(n + 1), h(n + 1), cur(n + 1),
			ovlist((n + 1), -1), ovnex((n + 1), -1),
			gap((n + 1), -1), gapprv((n + 1), -1), gapnex((n + 1), -1) {}
		HLPP() {}
		inline void addedge(int u, int v, ANS_TYPE f) {
			vec[u].push_back(edge(v, f, vec[v].size()));
			vec[v].push_back(edge(u, 0, vec[u].size() - 1));
		}

		inline ANS_TYPE get_max_flow() {
			relabel();
			for (auto &e : vec[s]) {
				if (e.flow) {
					push_flow(s, e, e.flow);
					maxh = std::max(maxh, h[e.to]);
				}
			}
			for (; maxh; --maxh) {
				while (~ovlist[maxh]) {
					int x = ovlist[maxh];
					ovlist[maxh] = ovnex[x];
					update_dis(x);
					if (workcnt >= (n << 2)) {
						relabel();
					}
				}
			}
			return ov[t];
		}

		inline void update_dis(int x) {
			int nh = n, sz = vec[x].size();
			for (int i = cur[x]; i < sz; ++i) {
				auto &e = vec[x][i];
				if (e.flow) {
					if (h[x] == h[e.to] + 1) {
						push_flow(x, e, std::min(ov[x], e.flow));
						if (!ov[x]) {
							cur[x] = i;
							return;
						}
					} else {
						nh = std::min(nh, h[e.to] + 1);
					}
				}
			}
			for (int i = 0; i < cur[x]; ++i) {
				auto &e = vec[x][i];
				if (e.flow) {
					nh = std::min(nh, h[e.to] + 1);
				}
			}
			cur[x] = 0;
			++workcnt;
			if (~gapnex[gap[h[x]]]) {
				set_height(x, nh);
			} else {
				int oldh = h[x];
				for (int i = oldh; i <= maxgaph; ++i) {
					for (int j = gap[i]; ~j; j = gapnex[j]) {
						h[j] = n;
					}
					gap[i] = -1;
				}
				maxgaph = oldh - 1;
			}
		}
		inline void set_height(int x, int newh) {
			if (~gapprv[x]) {
				if (gapprv[x] == x) {
					gapprv[gapnex[x]] = gapnex[x];
					gap[h[x]] = gapnex[x];
				} else {
					gapnex[gapprv[x]] = gapnex[x];
					if (~gapnex[x]) {
						gapprv[gapnex[x]] = gapprv[x];
					}
				}
			}
			if ((h[x] = newh) >= n) {
				return;
			}
			maxgaph = std::max(maxgaph, newh);
			if (ov[x]) {
				maxh = std::max(maxh, h[x]);
				ovnex[x] = ovlist[h[x]];
				ovlist[h[x]] = x;
			}
			if (~(gapnex[x] = gap[h[x]])) {
				gapprv[gapnex[x]] = x;
			}
			gap[h[x]] = gapprv[x] = x;
		}
		inline void push_flow(int u, edge &e, ANS_TYPE df) {
			if (!ov[e.to] && (e.to) != t) {
				ovnex[e.to] = ovlist[h[e.to]];
				ovlist[h[e.to]] = (e.to);
			}
			ov[u] -= df, ov[e.to] += df, e.flow -= df, vec[e.to][e.rev].flow += df;
		}
		inline void relabel() {
			workcnt = maxh = maxgaph = 0;
			std::fill(h.begin(), h.end(), n), h[t] = 0;
			std::fill(gap.begin(), gap.end(), -1);
			std::fill(gapprv.begin(), gapprv.end(), -1);
			std::fill(gapnex.begin(), gapnex.end(), -1);
			std::fill(ovlist.begin(), ovlist.end(), -1);
			std::fill(ovnex.begin(), ovnex.end(), -1);
			std::fill(cur.begin(), cur.end(), 0);
			std::queue<int>q;
			q.push(t);
			int x;
			while (!q.empty()) {
				x = q.front(), q.pop();
				for (auto &e : vec[x]) {
					if (h[e.to] == n && e.to != s && vec[e.to][e.rev].flow) {
						set_height(e.to, h[x] + 1);
						q.push(e.to);
					}
				}
			}
		}
};
HLPP ans;
#define getchar() getchar_unlocked()
//#define getchar() _getchar_nolock()
//可能是因为我本地评测环境奇特，只有 _getchar_nolock()
inline int read() {
	int x = 0;
	bool f = false;
	char c = getchar();
	while (c < '0' || c > '9') {
		if (c == '-') {
			f = true;
		}
		c = getchar();
	}
	while (c >= '0' && c <= '9') {
		x = x * 10 + c - '0';
		c = getchar();
	}
	return f ? -x : x;
}

int main() {
	int n, m, s, t;
	n = read(), m = read();
	read();
	s = 1, t = n;
	ans = HLPP(n, m, s, t);
	for (int i = 0; i < ans.m; ++i) {
		int u, v, f;
		u = read(), v = read(), f = read();
		ans.addedge(u, v, f);
	}
	printf("%d", ans.get_max_flow());
	return 0;
}
```
## 后记
别问我怎么学的优化，问就是跟[这题](https://www.luogu.com.cn/problem/P4722)的[榜一](https://www.luogu.com.cn/record/134276631)学的。

但还是比他慢上不少，我是真看不懂他那奇特的存图方式。

有知道怎么优化的可以私信我。

**感谢观看，希望大家能从这篇题解中学到不少东西。**

---

## 作者：TernaryTree (赞：4)

关于我不会 $\Theta(n3^k)$ 只会 $\Theta(n2^k)$ 这件事。

最大流转最小割。

考虑前 $i$ 个点的答案为 $f_i$。现在我们要扩展到 $f_{i+1}$，怎么处理？显然这会加入 $[i-k+1,i]$ 到 $i+1$ 的一些边。发现不太好转移，但是 $k$ 较小所以我们把 $[i-k+1,i]$ 这段区间状压起来，状态修改为 $f_{i,S}$。$S$ 的二进制下从低到高第 $j$ 位表示，源点能否到达 $i-j$ 这个位置。

转移时，枚举 $i+1$ 能否被源点到达。如果可以，我们不需要割掉任何一条边，直接由 $f_{i,S}$ 转移。如果不可以，那么对于 $f_{i,S}$ 中 $S$ 每一个 $1$，都要割掉到 $i+1$ 的边。这个可以 $\Theta(n2^k)$ 递推地预处理，记为 $g_{i,S}$：$S$ 为 $1$ 的位置到 $i+1$ 的边权和。此时原 dp 的转移来自 $f_{i,S}+g_{i,S}$。

做完了。

```cpp
#include <bits/stdc++.h>

using namespace std;

const int maxn = 8e4 + 10;
const int inf = 2e9;
const int maxk = 8;

int n, m, k, ans = inf;
int tot[maxn][maxk];
int f[maxn][1 << maxk];
int g[maxn][1 << maxk];

signed main() {
	cin >> n >> m >> k;
	const int U = (1 << k), msk = U - 1;
	for (int i = 1, u, v, w; i <= m; i++) {
		cin >> u >> v >> w;
		tot[u][v - u] += w;
	}
	for (int i = 1; i <= n; i++) {
		for (int s = 1; s < U; s++) {
			int j = __builtin_ctz(s);
			g[i][s] = g[i][s ^ (1 << j)] + (i - j >= 1 ? tot[i - j][j + 1] : 0);
		}
	}
	memset(f, 0x3f, sizeof(f));
	for (int s = 0; s < (1 << k); s++) {
		if (s & 1) f[1][s] = 0;
	}
	for (int i = 1; i < n; i++) {
		for (int s = 0; s < U; s++) {
			f[i + 1][(s << 1 | 1) & msk] = min(f[i + 1][(s << 1 | 1) & msk], f[i][s]);
			f[i + 1][(s << 1) & msk] = min(f[i + 1][(s << 1) & msk], f[i][s] + g[i][s]);
		}
	}
	for (int s = 0; s < (1 << k); s++) {
		if (!(s & 1)) ans = min(ans, f[n][s]);
	}
	cout << ans << endl;
	return 0;
}

```

---

## 作者：zifanwang (赞：0)

首先最大流等于最小割，然后就能很容易地想到一个状压 dp 做法：记 $f_{i,s}$ 表示使得前 $i$ 个点中，最后 $k$ 个点与点 $1$ 的联通情况为 $s$ 的最小代价。然后考虑下一个点是否联通直接转移即可，然后就做完了。时间复杂度 $\mathcal O(n2^k)$。

参考代码：
```cpp
#include<bits/stdc++.h>
#define mxn 80003
#define rep(i,a,b) for(int i=a;i<=b;++i)
#define rept(i,a,b) for(int i=a;i<b;++i)
using namespace std;
int n,m,k,s,d[mxn][10],f[mxn][128];
signed main(){
	scanf("%d%d%d",&n,&m,&k);
	for(int i=0,x,y,z;i<m;++i){
		scanf("%d%d%d",&x,&y,&z);
		d[y][y-x]+=z;
	}
	s=(1<<k)-1;
	memset(f,0x3f,sizeof(f));
	f[1][1]=0;
	rept(i,1,n){
		rept(j,0,1<<k)if(f[i][j]<1e9){
			int sm=0;
			rept(x,0,k)if((j>>x)&1)sm+=d[i+1][x+1]; 
			f[i+1][(j<<1)&s]=min(f[i+1][(j<<1)&s],f[i][j]+sm);
			f[i+1][(j<<1|1)&s]=min(f[i+1][(j<<1|1)&s],f[i][j]);
		}
	}
	int ans=1e9;
	rept(i,0,1<<k)if(!(i&1))ans=min(ans,f[n][i]);
	cout<<ans;
	return 0;
}
```

---


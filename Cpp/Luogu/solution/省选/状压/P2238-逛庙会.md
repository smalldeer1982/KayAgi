# 逛庙会

## 题目背景

本题时限 3s，请考虑常数优化或者读入优化。（std 没有特别进行优化）

## 题目描述

城市里正在举行庙会。庙会里有很多摊位。庙会的会场是一个南北向 $H$ 个摊位、东西向 $W$ 个摊位组成的大型方阵。从北开始第 $i$ 行、西开始第 $j$ 列的一个摊位，我们表示为 $(i,j)$。

正妹现在处于庙会的 $(1,1)$ 位置，然后要往东或者往南走，一直走到 $(H,W)$ 跟小 B 汇合。$(1,1)$ 点、$(H,W)$ 点和它们的东西南北邻近一个摊位都没有开张。别的地方也可能有一些摊位没有开张。

正妹是个吃货。只要到达一个摊位，总是经不起小吃的诱惑。如果这个摊位开张了，而且该摊位小吃还没有买过，就会买下这个摊位的小吃。无论这个摊位是否有开张，其东西南北直接相邻的摊位小吃的香味也很诱人，如果邻近的摊位的小吃没有买过，那么就在这些邻近（上下左右）的且没有买过的摊位（假设有 $r$ 个）中，买其中的 $r-1$ 个摊位的小吃。然后继续往东或者南走。同一家小摊，不会购买多次。

虽然正妹是个吃货，但是零用钱还是很有限。可是她又是管不住自己，就是要买买买。所以她希望知道自己最少能吃掉多少钱的东西。

## 说明/提示

```plain
5 5
oooo7
.2xoo
9346o
..45o
.8..o
```

样例解释：`o` 为正妹经过的路线，`x` 为她顺便买的小吃。当走到 $(2,4)$ 时，左下右都有开张且没有买过的摊位，于是买左和右，继续沿着路线走。由于之后路线没有经过没有买过摊位，而且上下左右开张且没买过的摊位不超过 $1$，所以一个都不买了。

对于 $20\%$ 的数据，开张的摊位不超过 $20$；

对于 $100\%$ 的数据，保证 $3\le H,W\le1000$。

特别注意：数据是在 Windows 生成，输入数据换行符可能是 `\r\n`（两个字符）或者 `\n`。而评测机是 Linux。请特别注意。不接受赛后以「本地能过，评测 WA」的理由申诉。

参考读入方式（节选自 std）：

```cpp
for (i = 0; i < H; ++i) {
	scanf("%s", in);
	for (j = 0; j < W; ++j) {
		shop[i][j] = blabla..
	}
}
```

## 样例 #1

### 输入

```
5 5
....7
.21.8
9346.
..45.
.8...```

### 输出

```
9```

# 题解

## 作者：kkksc03 (赞：17)

假设我们先考虑同一个小摊，可重复购买的话，会比较简单。也就是说，根据各个摊位，计算要买东西的价格为状态，从(1,1)到(H,W)移动的过程做二维dp。但是不能重复购买，在哪些小摊里买了东西这个也要作为一个状态。因此成了三维状态dp。第三维是状态压缩。

实际上对于一个点，可以向右或者向下扩展。这样可以很大的简化讨论（之前的题解写错了，抱歉）

其中第三维k是0-15一共16种状态，代表上下左右买或者不买，一共2^4=16种状态（如果你非要搞成6维dp我也不说什么）。k'代表合法的状态转移。比如现在的位置有摊位，从左边转移过来的状态中，就不可以购买左边的右边（也就是目前所处的位置）。初始条件就是F[0][0][k]=0。

下面是std

```cpp
 #include <stdio.h>

#define chmin(a,b) if ((a) > (b)) { a = (b); }

const int INF = 1000000;
int H, W;
int shop[1020][1020];
int dp[1020][1020][16];
int bc[] = { 0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4 };//二进制中1的个数

int main()
{
    int i, j, k, k2, cost;
    char in[1020];
    scanf("%d%d", &H, &W);

    for (i = 0; i < H + 3; ++i) {
        for (j = 0; j < W + 3; ++j) {
            shop[i][j] = 0;
            for (k = 0; k < 16; ++k) dp[i][j][k] = INF;
        }
    }

    for (i = 0; i < H; ++i) {
        scanf("%s", in);
        for (j = 0; j < W; ++j) {
            shop[i + 1][j + 1] = (in[j] == '.' ? 0 : (in[j] - '0'));
        }
    }

    dp[1][1][15] = 0;
    for (i = 1; i <= H; ++i) {
        for (j = 1; j <= W; ++j) {
            for (k = 0; k < 16; ++k) {
                // move to (i + 1, j)
                for (k2 = 0; k2 < 16; ++k2) {
                    if (
                        ((k & 4) == 0) != ((k2 & 8) == 0) 
                        ||!(k & 2)
                        ||(bc[k & 1] + bc[k2 & 6] <= 1)
                    ) continue;
                
                    cost = dp[i][j][k];
                    if (k2 & 1) cost += shop[i + 2][j - 1];
                    if (k2 & 2) cost += shop[i + 2][j];
                    if (k2 & 4) cost += shop[i + 1][j + 1];

                    chmin(dp[i + 1][j][k2], cost);
                }

                // move to (i, j + 1)
                for (k2 = 0; k2 < 16; ++k2) {
                    if (
                        ((k & 2) == 0) != ((k2 & 1) == 0)
                        ||!(k & 4)
                        ||(bc[k & 8] + bc[k2 & 6] <= 1)
                    ) continue;
                

                    cost = dp[i][j][k];
                    if (k2 & 8) cost += shop[i - 1][j + 2];
                    if (k2 & 4) cost += shop[i][j + 2];
                    if (k2 & 2) cost += shop[i + 1][j + 1];

                    chmin(dp[i][j + 1][k2], cost);
                }
            }
        }
    }

    printf("%d\n", dp[H][W][15]);
    return 0;
}
```

---

## 作者：kyel (赞：11)

楼下已有两篇大佬的题解，然而一篇**代码骨骼精奇**，但是说明过于简略，如果你本来没想到做法的话应该是看不懂的；另一篇讲得非常详细，不过**做法略显繁琐**。~~总之，记得给这篇题解点赞。~~

先来简化一下题意中的一个条件：当处在某一个店铺时，会在边上四个店铺中**选三个购买**。其中，**未开张的店铺和已购买过的店铺权值为0**。这样，就不用去数它边上有几个店铺的值r了，反正选两个就是（除去过来时的店铺）。

再来明确一下这道题难在哪里。
```cpp
5 5
..8.5
...2.
.91.9
.83..
526..
answer : 3
```
首先这不是一组优雅的数据，因为这是对拍跑出来的。不过我们把最优解剖出来:
```cpp
5 5
AA?.?
.AA2.
.?1A?
.??AA
???.A
```
在位置(2,3)处同时取走值1与2，于是接下来就可以一个不取地走到终点。

如果你能理解为什么错误的代码可能跑出4，你就理解了这道题的难点了：在(2,3)处与(3,4)处重复取了1。

为什么会出现这种破事？因为从(2,3)到(3,4)经历了两次转移，其中 **“取走(3,3)”这个信息很可能在转移中被遗弃了**。

那么这个操作的信息需要被携带着多远呢？

我们发现，**向右转移一格的时候需要知道自己上方的格子是否被取走**。

![](https://cdn.luogu.com.cn/upload/pic/55523.png)

如上图，我们发现从蓝色格子向红色格子转移的时候，需要知道棕色格子是否被取走（是否存在）。

所以，对于从某个格子向右侧转移，**它的右上方的格子是否存在是关键的**。

同样的，对于从某个格子向下转移，**它的左下方的格子是否存在是关键的**。

所谓“关键的”，不过是**需要纳入状态**罢了。

令dp[i][j][k][x]表示(i,j)个格子的状态。其中k以状态压缩的方式表示这个格子**右、下方的格子是否存在**，x以状态压缩的方式表示这个格子**右上、左下的格子是否存在**。

于是仔细考虑转移就好。

转移分为向右、向下转移。向右转移时，**考虑(i,j)的K值以判断(i,j+1)是否已经被加入了dp值，而(i,j)的X值中的leftup位将变为(i,j+1)的K值中的up位**。向下转移同理。

代码仅供参考。虽然将魔数用常量的方式表示了，但是还是非常的。。。丑陋而不易理解。
```cpp

#include <cstdio>
#include <cstdlib>
namespace my {
	inline void getmin(int& a, int b) {
		if (b < a) a = b;
	}
}
const int maxn(1123), inf(11234567), right(1), down(2), left(4), up(4);
const int rightup(1), leftdown(2);
int map[maxn][maxn], dp[maxn][maxn][4][4], cx, cy;
int cntbit[16], two[16], end;
char buffer[maxn];
int main() {
	using namespace my;
	for (int i(0); i != 8; ++i) {
		cntbit[i] = (i & 1) + cntbit[i >> 1];
		if (cntbit[i] == 2) two[end++] = i;
	}
	scanf("%d%d", &cx, &cy);
	for (int i(0); i <= cx; ++i) for (int j(0); j <= cy; ++j)
		for (int k(0); k != 4; ++k) for (int l(0); l != 4; ++l)
			dp[i][j][k][l] = inf;
	for (int i(1); i <= cx; ++i) {
		scanf("%s", buffer);
		for (int j(1); j <= cy; ++j) {
			if (buffer[j - 1] != '.') map[i][j] = buffer[j - 1] - '0';
		}
	}
	dp[1][1][0][0] = 0;
	for (int i(1); i <= cx; ++i) {
		for (int j(1); j <= cy; ++j) {
			for (int k(0); k != 4; ++k) {
				for (int x(0); x != 4; ++x) {
					if (i == 2 && j == 4) {
						i = 2;
					}
					for (int t(0); t != end; ++t) {
						int newx(rightup | ((k & down) ? leftdown : 0));
						int buy(two[t]), cost(dp[i][j][k][x]);
						if (k & right) cost += map[i][j + 1];
						if ((buy & up) && (x & rightup)) cost += map[i - 1][j + 1];
						if (buy & down) cost += map[i + 1][j + 1];
						if (buy & right) cost += map[i][j + 2];
						getmin(dp[i][j + 1][3 ^ (buy & 3)][newx], cost);//利用上几行的计算，由(i,j)转移向(i,j+1)
						newx = leftdown | (k & right ? rightup : 0);
						cost = dp[i][j][k][x];
						if (k & down) cost += map[i + 1][j];
						if ((buy & left) && (x & leftdown)) cost += map[i + 1][j - 1];
						if (buy & down) cost += map[i + 2][j];
						if (buy & right) cost += map[i + 1][j + 1];
						getmin(dp[i + 1][j][3 ^ (buy & 3)][newx], cost);//由(i,j)转移向(i,j+1)
					}
				}
			}
		}
	}
	int ans(inf);
	for (int k(0); k != 4; ++k) for (int x(0); x != 4; ++x)
		my::getmin(ans, dp[cx][cy][k][x]);
	printf("%d\n", ans);
	return 0;
}

```
当然了，既然写了对拍，文末附赠一个对拍代码。
```cpp
#include <cstdio>
#include <cstdlib>
#include <ctime>

int map[1123][1123];
int main() {
	srand(time(0));
	while (1) {
		int n(5), m(5);//地图大小
		for (int i(0); i != n; ++i) {
			for (int j(0); j != m; ++j) {
				map[i][j] = rand() % 20;
				if (map[i][j] > 9) map[i][j] = 0;
			}
		}
		map[0][0] = map[0][1] = map[1][0] = 0;
		map[n - 1][m - 1] = map[n - 2][m - 1] = map[n - 1][m - 2] = 0;
		FILE *out;
		out = fopen("data.in", "w+");
		fprintf(out, "%d %d\n", n, m);
		for (int i(0); i != n; ++i) {
			for (int j(0); j != m; ++j) {
				fprintf(out, "%c", map[i][j] ? map[i][j] + '0' : '.');
			}
			fprintf(out, "\n");
		}
		fclose(out);
		system("P2238.exe < data.in > mine.out"), system("std.exe < data.in > std.out");//P2238.exe为要对拍的代码,std.exe为std
		if (system("fc mine.out std.out")) {
			printf("orz\n"); while(1);//答案对不上了
		}
	}
	return 0;
}
```


---

## 作者：Zayin2653457495 (赞：4)

#分析


##性质一

首先注意到这句话——“如果邻近的摊位的小吃没有买过，那么就在这些邻近（上下左右）的且没有买过的摊位（假设有r个）中，买其中的r-1个摊位的小吃”，在没有买过r个的摊位中，买其中的r-1个，那么如果算上已经买过的摊位，实际上就是在邻近的开张了的店铺（假设有Cnt个）中，至少要买Cnt-1个。又因为对于某个在路径上的店铺（假设为（i，j））相邻会有两个店铺（首尾除外），所以实际上（i，j）这个店铺邻近最多有2个，换句话说，（i，j）这个店铺额外买的最多不超过一个店铺（为方便说明，下文称这店铺为额外店铺）。


##性质二

由性质一可知，对于路径的每个店铺（i，j）最多只有一个额外店铺，那么如果我们首先确定了正妹怎么走（也就是路径），那么路径上每个店铺的额外店铺也就确定了是哪个（贪心选最小的）。换句话说，路径上的店铺和额外店铺的购买过程可以完全独立开来。


##性质三

对于路径上的店铺（i，j）来说，他的额外店铺只有两种情况——


1.与其他店铺公用一个额外店铺：

-----   -----

       | 路径 | 额外 |
-----   -----

       | 路径 | 路径 |
-----   -----


或

-----   -----

       | 路径 | 路径 |
-----   -----

       | 额外 | 路径 |
-----   -----



2.自己独用一个额外店铺：

-----
                          | 额外 |
-----   -----  -----

       | 路径 | 路径 | 路径 |
-----   -----  -----


或

-----
                 | 路径 |
-----   -----

       | 额外 | 路径 |
-----   -----

                 | 路径 | 
-----

对于1.这种情况，很明显只存在转角的地方；

对于2.这种情况，很明显只存在直走的地方。


那么可以观察到——

对于1.的情况，前面的额外店铺可以由后面的额外店铺决定，所以前面的额外店铺可以暂时不买，等到后面才买；

对于2.的情况，因为额外店铺是自己独享的，那独享的肯定不比共用的优嘛，所以肯定能不独享就不独享，换句话说，除非迫不得已，肯定不独享（共产大法好）。

综上所述：如果额外店铺可以以后再买，那么就尽量以后再买，拖到不能不买为止才去买。


再进一步可以发现——

对于1.的情况，也就是存在共享额外店铺的情况，那么共享额外店铺的这两个店铺坐标之差只能为2（设这两个共享额外店铺的店铺的坐标为（i-1，j-1）（i，j））。这个额外店铺只能在（i-1，j-1）的下方或右方，在（i，j）的上方或左方（或者说这个额外店铺的坐标只能为（i-1，j）或（i，j-1））；

对于2.的情况，也就是存在独用额外店铺的情况，因为独用额外店铺只存在于直走的路径，所以这个额外店铺垂直于路径方向。


##总结

1.除开路径上的店铺，路径上的每个店铺（i，j）额外买的最多不超过一个店铺（额外店铺）；

2.路径上的店铺和额外店铺的购买过程可以完全独立开来；

3.如果额外店铺可以以后再买，那么就尽量以后再买，拖到不能不买为止才去买。

4.额外店铺与路径本身的关系。


#算法

由总结二可知，我们可以像方格取数那样dp路径，顺便维护额外店铺的信息；

由总结三可知，dp时我们要知道（i，j）这个店铺的信息，还要知道它父亲的信息，更要知道它父亲的父亲的信息；

由总结四可知，dp时我们必须要知道（i，j）这个店铺是怎么过来的（这样才能买额外店铺）。


又因为共享时额外店铺只在右方或下方，那么如果买了上方和左方的店铺是没有后效性的，右方或下方的店铺可以由不得已的时候（下面的dp）再买，所以我们在dp时可以只买上方和左方的店铺，右方和下方的店铺会成为下层dp的上方和左方，所以可以暂时不买~


由此推出转移方程—— dp[dir][i][j][c1][c2]     dir=[0,1]  c1=[0,2]  c2=[0,1]；


dir表示（i，j）这个店铺是从父亲那里怎么走过来的，0表示向下，1表示向右；

c1表示（i，j）这个店铺还差多少个店铺（包括路径上的店铺）才能符合题目要求；

c2表示（i，j）这个店铺的父亲还差多少个店铺（包括路径上的店铺）才能符合题目要求；


dp[dir][i][j][c1][c2]表示按dir方向走到（i，j）时，~c1~,~c2~，的最小花费。


下面以dir==0（向下走）为例，dir==1类似，并设（i，j）这个店铺要买Cnt的店铺（包括路径上的店铺）才满足题目要求。



很显然，如果（i，j）这个店铺开张了，那么就可以更新它父亲（i-1，j）的信息（需要买的店铺-1），否则就不能更新；

如果它父亲（i-1，j）这个店铺开张了，那么就可以更新它本身的信息（需要买的店铺-1），否则就不能更新。


dp[0][i][j][ Cnt-(bool)shop[i-1][j] ][c2] = dp[1][i-1][j][ c2+(bool)shop[i][j] ][0]+shop[i][j]；      c2=[0,1]


其他情况如下：


1.（i，j）的父亲是从左边走过来的。


-----   -----

         | 路径 | 路径 |
-----   -----

         |   ？  | 路径 |
-----   -----



对于？所在的店铺（i，j-1），如果它开张了，那么它本身就可以更新（i-1，j-1）和（i，j）的信息。



        if (shop[i][j])

            dp[0][i][j][ Cnt-1-(bool)shop[i-1][j] ][c2] =min（dp[0][i][j][ Cnt-(bool)shop[i-1][j] ][0]  ，  dp[1][i-1][j][ c2+(bool)shop[i][j] ][1] ）+ shop[i][j] + shop[i][j-1];

2.（i，j）的父亲是从上面走过来的。


----- -----

                 | 路径 |   1   |
----- -----

                 | 路径 |
-----   -----

        |   2   | 路径 | 
-----   -----


一，这时1所在的店铺（i-2，j+1）可能会被（i-2，j）独享，要更新一下：


dp[0][i][j][ Cnt-(bool)shop[i-1][j] ][c2] = dp[1][i-1][j][ c2+(bool)shop[i][j] ][1] + shop[i][j] +shop[i-2][j+1];


二，这时2所在的店铺（i，j-1）只能更新（i，j）的信息（独享），更新：


dp[0][i][j][ Cnt-1-(bool)shop[i-1][j] ][c2] = dp[1][i-1][j][ c2+(bool)shop[i][j] ][0]+shop[i][j] + shop[i][j-1]；


3.作为特殊情况c2==0时,不论(i,j)是否都可以更新(i-1,j)的信息,这个和上面的方程差不多就不写出来了~




#总结

自此我们的dp就写完了。。。

由于本人代码风格不佳，写得有点长。。。所以就不粘出来了。。。


        
    




---

## 作者：liangbowen (赞：2)

[problem](https://www.luogu.com.cn/problem/P2238) & [blog](https://www.cnblogs.com/liangbowen/p/17663441.html)。

kkk 的题解有一些地方是错的 /cf，所以写篇题解造福后人。

---

一眼 DP，如果你平凡地设 $dp_{i,j}$，会发现买过的是不能再买的，然后就转移不动了。所以要记录每个点附近的点是否被吃过。

于是状压，每个二进制位表示 $(i,j)$ 周围的一些点是否被吃过。不妨钦定 $X$ 表示当前位置，$Y$ 表示下一步的位置。

若往右走，$Y$ 的左面必定吃过，下边必定没吃过。然而，$Y$ 的右面与上面**不知道是否吃过**（即如果吃过的话，这一位状态就是固定的）；往下走时，$Y$ 的上面必定吃过，右面必定没吃过，$Y$ 的左面不知道是否吃过。

所以枚举 $X$ 时，我们还得提前知道 $Y$ 的其中两面是否被吃过。于是状压需要记录：**右**，**下**，**右上**（即往右走时 $Y$ 的上面），**左下**（即往下走时 $Y$ 的左面）是否吃过。

考虑转移，以往右走为例，往下走是同理的。首先 $Y$ 一定没有被吃过，其次 $Y$ 的上、下、右至少要有 $2$ 个位置没有被吃过。转移的话看右、下、右上三位，还有就吃掉，非常简单。

于是做完了，代码很好写。一些小细节：

+ 有些东西没有表示出来，如往右走时 $Y$ 的上面，其实就是 $X$ 的右上；往右走时 $Y$ 自己的状态，就是 $X$ 的右面。
+ 有一些东西必须相等，如往右走时 $X$ 的下面和 $Y$ 的左下是同一个东西。

[code](https://www.luogu.com.cn/paste/cyf4ts46)，时间复杂度 $O(nmT^2)$，$T=2^4$。


---


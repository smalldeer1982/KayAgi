# 美好的每一天

## 题目背景

**时间限制3s,空间限制162MB**


素晴らしき日々

我们的情人，不过是随便借个名字，用幻想吹出来的肥皂泡，把信拿去吧，你可以使假戏成真。我本来是无病呻吟，漫无目的的吐露爱情---现在这些漂泊不定的鸟儿有地方栖息了，你可以从信里看出来。拿去吧---由于不是出自真心，话就说得格外动听，拿去吧，就这么办吧...


由于世界会在7月20日完结，作为救世主，间宫卓司要在19日让所有人回归天空

现在已经是19日傍晚，大家集合在C栋的天台上，一共n个人

在他们面前，便是终之空，那终结的天空

![](https://cdn.luogu.com.cn/upload/pic/4139.png)


## 题目描述

回归天空是一件庄重的事情，所以卓司决定让大家分批次进行，给每个人给了一个小写字母'a'->'z'作为编号

一个区间的人如果满足他们的**编号重排之后可以成为一个回文串**，则他们可以一起回归天空，即这个区间可以回归天空

由于卓司是一个喜欢妄想的人，他妄想了m个区间，每次他想知道每个区间中有多少个子区间可以回归天空

因为世界末日要来了，所以卓司的信徒很多

![](https://cdn.luogu.com.cn/upload/pic/4138.png)


## 说明/提示

对于10%的数据，n,m<=100

对于30%的数据，n,m<=2000

对于100%的数据，n,m<=60000

**字符集大小有梯度**


在大家回归天空之后，彩名露出了阴冷的笑容

![](https://cdn.luogu.com.cn/upload/pic/4137.png)


## 样例 #1

### 输入

```
6 6
zzqzzq
1 6
2 4
3 4
2 3
4 5
1 1```

### 输出

```
16
4
2
2
3
1```

## 样例 #2

### 输入

```
6 6
aaabbb
1 2
2 3
3 4
4 5
5 6
1 6```

### 输出

```
3
3
2
3
3
17```

## 样例 #3

### 输入

```
4 1
yuno
1 4```

### 输出

```
4```

# 题解

## 作者：juju527 (赞：27)

### 莫队

注意到回文串只可能是所有字母都是偶数个或者**仅有**一个字母是奇数个

由于区间内我们只关心字母的奇偶，想到**异或**

对于一个区间我们用一个26位的二进制数表示每一个字母出现次数为奇或偶(0偶1奇)

而我们只要把所有的前缀区间的状态计算出来，对于任意一个区间我们都可以异或得到答案

定义$a_i$表示区间[1,i]的各个字母出现状态的值

[x,y]的状态即$a_y\bigoplus a_{x-1}$

那么其实原问题就被我们转换成对于一个区间[x,y]

**选择i属于[x-1,y]的两个不同位置的a值进行异或是否能得到0或者2的某次方**

得到0即字母都是奇数个，2的某次方即仅有一个字母是奇数个

我们考虑莫队区间拓展的过程

进来一个值时相当于多了一个a值x可用

根据异或的传递性，我们查询原本这个区间里a值等于x的有多少和a值等于x异或2的某次方的有多少

删除同理

复杂度$O(26*n\sqrt n)$

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=60005,maxm=60005;
int n,m;
int base;
struct query{
	int id;
	int x,y;
	bool operator <(query i)const{
		return x/base==i.x/base?y<i.y:x<i.x;
	}
}q[maxm];
int ans=0;
int a[maxn];
int cnt[(1<<26)+5];
int ANS[maxm];
inline int read(){
	register int x=0,y=1;
	register char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')y=-1;ch=getchar();}
	while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+(ch^48),ch=getchar();
	return x*y;
}
inline void ins(register int x){
	ans+=cnt[a[x]];
	cnt[a[x]]++;
	for(register int i=0;i<26;i++)
		ans+=cnt[a[x]^(1<<i)];
	return ;
}
inline void del(register int x){
	cnt[a[x]]--;
	ans-=cnt[a[x]];
	for(register int i=0;i<26;i++)
		ans-=cnt[a[x]^(1<<i)];
	return ;
}
int main(){
	n=read();m=read();
	base=3*sqrt(n);
	for(register int i=1;i<=n;i++){
		register char c;
		cin>>c;
		a[i]=1<<(c-'a');
		a[i]^=a[i-1];
	}
	for(register int i=1;i<=m;i++){
		q[i].id=i;
		q[i].x=read();
		q[i].y=read();
	}
	sort(q+1,q+m+1);
	int l=1,r=0;
	for(register int i=1;i<=m;i++){
		register int x=q[i].x-1,y=q[i].y,id=q[i].id;
		while(l<x)del(l++);
		while(l>x)ins(--l);
		while(r>y)del(r--);
		while(r<y)ins(++r);
		ANS[id]=ans;
	}
	for(register int i=1;i<=m;i++)printf("%d\n",ANS[i]);
	return 0;
}

```



---

## 作者：kczno1 (赞：9)

在这题之后就都只会骗分了。。

这题容易想到莫队，如何考虑加入一个点之后的影响？

用26位二进制表示每一个字符的奇偶状态，1表示奇数，能够形成回文的区间一定是没有1或者只有一个1。

预处理出1->每个点 的状态(前缀和)，xor一下就能得到一个区间的状态。

所以，加入一个的点的时候枚举27个要产生的状态即可。

可以离散化,之后预处理出了一个状态xor27个状态达到的状态。

这样就可以做到O(nlogn\*26)预处理+O(n根号n\*26)。

```cpp
#include<bits/stdc++.h>
#pragma GCC optimize("O2")

#define ll long long 
#define N 60010
#define len 300
int sum[N];
ll ans[N],now;
int link[N][28],num[N];
int cnt[N];
struct segment
{
 void push(int x)
 {
     x=sum[x];
     for (int i=1;i<=num[x];++i) now+=cnt[link[x][i]];
     ++cnt[x];
 }
 void del(int x)
 {
     x=sum[x];
     --cnt[x];
     for (int i=1;i<=num[x];++i) now-=cnt[link[x][i]];
 }
}seg;
int n,m,i;

bool xiao(int *x,int *y)
{
    return *x<*y;
}
void init_sum()
{
    static char s[N];
    scanf("%s",s+1);
    for (i=1;i<=n;++i)
     sum[i]=sum[i-1]^(1<<s[i]-'a');
     
    //离散 
    static int *q[N],dy[N];
    for (i=0;i<=n;++i) q[i]=sum+i;
    std::sort(q,q+n+1,xiao);
    int top=1;dy[1]=*q[0];*q[0]=1;
    for (i=1;i<=n;++i)
    {
        if (*q[i]!=dy[top]) dy[++top]=*q[i];
        else 
         if (!num[top]) link[top][num[top]=1]=top;
        *q[i]=top;
    }
    for (i=1;i<=top;++i)
    {
        for (int j=0;j<26;++j)
        {
            int to=dy[i]^(1<<j);
            int *w=std::lower_bound(dy+1,dy+top+1,to);
            if (w!=dy+top+1&&*w==to) link[i][++num[i]]=w-dy;
        }
    }
}

int j,nl,nr;
struct query
{
    int l,r;
    void solve()
    {
        if (l>nr)
        {
            if (nr)
                for (;;++nl)
                {
                    seg.del(nl-1);
                    if (nl>nr) break;
                }
            seg.push(l-1);
            nl=l;nr=l-1;
        }
        while (nr<r) seg.push(++nr);
        while (nr>r) seg.del(nr--);
        while (nl<l) {seg.del(nl-1);++nl;}
        while (nl>l) {seg.push(nl-2);--nl;}
        ans[j]=now;
    }
}q[N];
int head[300],nex[N];
void init_query()
{
    static int t[N],next[N];
    int r;
    for (i=1;i<=m;++i) 
    {scanf("%d%d",&q[i].l,&r);q[i].r=r;
     next[i]=t[r];t[r]=i;
    }
    for (i=n;i;--i)
    for (r=t[i];r;r=next[r])
    {
        nex[r]=head[(q[r].l-1)/len];
        head[(q[r].l-1)/len]=r;
    }
}

int main()
{
    //freopen("1.in","r",stdin);freopen("1.out","w",stdout);
    scanf("%d%d",&n,&m);
    init_sum();
    init_query();
    for (i=0;i<=(n-1)/len;++i)
    for (j=head[i];j;j=nex[j])
     q[j].solve();
    for (i=1;i<=m;++i) printf("%lld\n",ans[i]);
}
```

---

## 作者：devout (赞：7)

一个区间可以重排成回文串，相当于这区间最多有一个字母出现了奇数次。

发现字符集只有$26$，并且我们只关心出现次数的奇偶性，所以我们可以考虑状压。

发现询问区间个数不太好解决，所以我们对于状压数组求一下前缀异或和，此时$[l,r]$上的情况就相当于$a_{l-1}\otimes r_i$，那么问题转化成了区间中有多少对数$(x,y)$，使得$x\otimes y$最多只有一位上是$1$。

那么我们就可以考虑莫队，因为异或可以移项，所以每插入/删除一个数的时候对答案的贡献就是$\sum_{i=0}^{25}cnt[x\otimes 2^i]$

这样我们就在$O(\sigma n\sqrt n)$的时间里解决了

```cpp
#include <bits/stdc++.h>
using namespace std;

# define Rep(i,a,b) for(int i=a;i<=b;i++)
# define _Rep(i,a,b) for(int i=a;i>=b;i--)
# define RepG(i,u) for(int i=head[u];~i;i=e[i].next)

typedef long long ll;

const int N=60005;
const int M=26;

template<typename T> void read(T &x){
   x=0;int f=1;
   char c=getchar();
   for(;!isdigit(c);c=getchar())if(c=='-')f=-1;
   for(;isdigit(c);c=getchar())x=(x<<1)+(x<<3)+c-'0';
    x*=f;
}

int n,m,sq;
char s[N];
int a[N];
int l[N],r[N],pos[N];
int cnt[1<<M];
int out[N],ans;

struct misaka{
	int l,r,id;	
}q[N];

bool cmp(misaka x,misaka y){
	if(pos[x.l]!=pos[y.l])return pos[x.l]<pos[y.l];
	else if(pos[x.l]&1)return x.r<y.r;
	else return x.r>y.r;
}

void init(){
	sq=sqrt(n+1);
	Rep(i,1,n+1)pos[i]=(i-1)/sq+1;
	sort(q+1,q+m+1,cmp);	
}

void add(int x){
	ans+=cnt[a[x]];
	cnt[a[x]]++;
	Rep(i,0,25)
		ans+=cnt[a[x]^(1<<i)];	
}

void del(int x){
	cnt[a[x]]--;
	ans-=cnt[a[x]];
	Rep(i,0,25)
		ans-=cnt[a[x]^(1<<i)];	
}

int main()
{
//	freopen("p3604.in","r",stdin);
//	freopen("p3604.out","w",stdout);
	read(n),read(m);
	scanf("%s",s+1);
	Rep(i,1,n)a[i+1]=a[i]^(1<<s[i]-'a');
	Rep(i,1,m)read(q[i].l),read(q[i].r),q[i].id=i,q[i].r++;
	init();
	for(int i=1,l=1,r=0;i<=m;i++){
		while(l>q[i].l)add(--l);
		while(r<q[i].r)add(++r);
		while(l<q[i].l)del(l++);
		while(r>q[i].r)del(r--);
		out[q[i].id]=ans;
	}
	Rep(i,1,m)printf("%d\n",out[i]);
	return 0;
}
```


---

## 作者：qwaszx (赞：7)

~~黑的素晴日做不来就做做紫的~~

二次离线莫队.

首先考虑莫队去转移，将颜色状压一下，那么每次只需要求出类似有多少个右端点为 $r$ 左端点在 $[l,r-1]$ 之间的区间满足异或和中 $1$ 的个数不超过 $1$ .使用前缀异或和并开桶维护即可.这个直接莫队是 $O(26n\sqrt{m})$ 的，卡常之后可以通过.

发现转移的时候是一些类似 $[l,i-1]$ 对 $i$ 的贡献的东西的区间和，可以拆成 $[1,i-1]$ 对 $i$ 的贡献减去 $[1,l-1]$ 对 $i$ 的贡献，那么可以二次离线莫队，变成 $O(n)$ 次修改 $O(n\sqrt{m})$ 次查询，将修改的复杂度变为 $O(26n)$ 即可平衡为 $O(n\sqrt{m})$.

对于卡空间，由于只有 $O(n)$ 种查询，所以并不需要开桶，只保留这 $O(n)$ 个前缀异或和即可.空间复杂度 $O(26n)$.

由于常数比较大或者我写得非常垃圾的原因打不过rk1的直接莫队.

需要注意 $l$ 和 $r$ 两边贡献的形式并不相同.

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<vector>
#include<cmath>
#include<algorithm>
#include<bitset>
#define IT vector<Q>::iterator
using namespace std;
const int N=150000;
struct Q{int l,r,id;}q[N];
unsigned short cnt[N];
int qans[N],ans[N],bl[N],col[N],tmp[N],n,m,sl[N],sr[N],s[N],len[N],S[N][26];
vector<Q>ql[N],qr[N];
pair<int,int>mvl[N],mvr[N];
char st[N];
int cmp(const Q &a,const Q &b){return bl[a.l]==bl[b.l]?((bl[a.l]&1)?a.r<b.r:a.r>b.r):a.l<b.l;}
int main()
{
    scanf("%d%d",&n,&m);
    scanf("%s",st+1);for(int i=1;i<=n;i++)col[i]=st[i]-97;
    for(int i=1;i<=n;i++)s[i]=s[i-1]^(1<<col[i]),tmp[i]=s[i];
    sort(tmp,tmp+n+1);
    for(int i=0;i<=n;i++)
    {
        for(int j=0;j<26;j++)
        {
            int w=s[i]^(1<<j),pos=lower_bound(tmp,tmp+n+1,w)-tmp;
            if(pos<=n&&tmp[pos]==w)S[i][len[i]++]=pos;
        }
    }
    for(int i=0;i<=n;i++)s[i]=lower_bound(tmp,tmp+n+1,s[i])-tmp;
    for(int i=1;i<=m;i++)scanf("%d%d",&q[i].l,&q[i].r),q[i].id=i;
    int blo=314;if(!blo)blo=1;
    for(int i=1;i<=n;i++)bl[i]=(i-1)/blo+1;
    sort(q+1,q+m+1,cmp);int l=1,r=0;
    for(int i=1;i<=m;i++)
    {
        if(r<q[i].r)qr[l-1].push_back((Q){r,q[i].r,i}),mvr[i]=make_pair(r,q[i].r),r=q[i].r;
        if(l>q[i].l)ql[r].push_back((Q){l,q[i].l,i}),mvl[i]=make_pair(l,q[i].l),l=q[i].l;
        if(r>q[i].r)qr[l-1].push_back((Q){r,q[i].r,i}),mvr[i]=make_pair(r,q[i].r),r=q[i].r;
        if(l<q[i].l)ql[r].push_back((Q){l,q[i].l,i}),mvl[i]=make_pair(l,q[i].l),l=q[i].l;
    }
    for(int i=1;i<=n;i++)
    {
        cnt[s[i-1]]++;for(int j=0;j<len[i-1];j++)cnt[S[i-1][j]]++;
        sr[i]=sr[i-1]+cnt[s[i]];
        for(IT j=qr[i].begin();j!=qr[i].end();j++)
        {
            int l=j->l,r=j->r,id=j->id,f=-1,t=0;
            if(l>r)swap(l,r),f=1;
            for(int k=l+1;k<=r;k++)t+=cnt[s[k]];
            qans[id]+=f*t;
        }
    }
    cnt[s[0]]--;for(int j=0;j<len[0];j++)cnt[S[0][j]]--;
    cnt[s[n]]++;for(int j=0;j<len[n];j++)cnt[S[n][j]]++;
    for(int i=n;i>=1;i--)
    {    
        for(IT j=ql[i].begin();j!=ql[i].end();j++)
        {
            int l=j->l,r=j->r,id=j->id,f=-1,t=0;
            if(l>r)swap(l,r),f=1;
            for(int k=l;k<r;k++)t+=cnt[s[k-1]];
            qans[id]+=f*t;
        }   
        cnt[s[i]]--;for(int j=0;j<len[i];j++)cnt[S[i][j]]--;   
        sl[i]=cnt[s[i-1]];
    }
    for(int i=1;i<=n;i++)sl[i]+=sl[i-1];
    for(int i=1;i<=m;i++)
    {
        qans[i]+=qans[i-1];
        qans[i]+=sr[mvr[i].second]-sr[mvr[i].first];
        if(mvl[i].second)qans[i]+=sl[mvl[i].second-1]-sl[mvl[i].first-1];
        ans[q[i].id]=qans[i];
    }
    for(int i=1;i<=m;i++)printf("%d\n",ans[i]);
}
```

---

## 作者：tzc_wk (赞：7)

> ## 洛谷 P3604

> 题意：给出一个长度为 $n$ 的字符串 $s$。有 $m$ 次询问，每次询问给出一个区间 $[l,r]$，问：这个区间有多少个子串，满足通过重排这个区间中的字符，可以得到一个回文串。

> $1 \leq n \leq 6 \times 10^4$

这题常数卡的……诶

我们考虑将一个子串压缩成一个 $26$ 位的二进制串。从右往左数第一位表示字符 $a$ 的情况，第二位表示字符 $b$ 的情况，以此类推。

每一位上为 $0$ 对应字符出现了偶数次，否则出现了奇数次。

很显然，一个字符串满足条件当且仅当它对应的二进制数为 $0$ 或 $2^x$。我们记录前缀异或数组 $sum$，那么 $[l,r]$ 的子串就是 $sum_r \operatorname{xor} sum_{l-1}$

不难想到莫队。每次将区间从 $[l,r]$ 扩大至 $[l,r+1]$ 的时候会增加右端点为 $r+1$ 的区间的贡献。记 $cnt_i$ 为 $sum_l,sum_{l+1},sum_{l+2},\dots,sum_r$ 中异或上 $i$ 出现的次数，那么答案增加的量就是 $cnt_{sum_r \operatorname{xor} 0}+cnt_{sum_r \operatorname{xor} 2^0}+cnt_{sum_r \operatorname{xor} 2^1}+cnt_{sum_r \operatorname{xor} 2^2}+\dots+cnt_{sum_r \operatorname{xor} 2^{25}}$

扩大左端点以及删除也同理。

时间复杂度 $\mathcal O(26n \sqrt n)$，需要娴熟的卡常技巧。

最后是丑陋无比的代码（开了O2，还有指令集）：

```cpp
//Coded by tzc_wk
/*
数据不清空，爆零两行泪。
多测不读完，爆零两行泪。
边界不特判，爆零两行泪。
贪心不证明，爆零两行泪。
D P 顺序错，爆零两行泪。
大小少等号，爆零两行泪。
变量不统一，爆零两行泪。
越界不判断，爆零两行泪。
调试不注释，爆零两行泪。
溢出不 l l，爆零两行泪。
*/
#include <bits/stdc++.h>
using namespace std;
#define fi			first
#define se			second
#define fz(i,a,b)	for(int i=a;i<=b;i++)
#define fd(i,a,b)	for(int i=a;i>=b;i--)
#define foreach(it,v) for(__typeof(v.begin()) it=v.begin();it!=v.end();it++)
#define all(a)		a.begin(),a.end()
#define giveup(...) return printf(__VA_ARGS__),0;
#define fill0(a)	memset(a,0,sizeof(a))
#define fill1(a)	memset(a,-1,sizeof(a))
#define fillbig(a)	memset(a,0x3f,sizeof(a))
#define fillsmall(a) memset(a,0xcf,sizeof(a))
#define mask(a)		(1ll<<(a))
#define maskx(a,x)	((a)<<(x))
#define _bit(a,x)	(((a)>>(x))&1)
#define _sz(a)		((int)(a).size())
#define filei(a)	freopen(a,"r",stdin);
#define fileo(a)	freopen(a,"w",stdout);
#define fileio(a) 	freopen(a".in","r",stdin);freopen(a".out","w",stdout)
#define eprintf(...) fprintf(stderr,__VA_ARGS__)
#define put(x)		putchar(x)
#define eoln        put('\n')
#define space		put(' ')
#define y1			y_chenxiaoyan_1
#define y0			y_chenxiaoyan_0
#pragma GCC optimize(2)
#pragma GCC optimize(3)
#pragma GCC target("avx")
#pragma GCC optimize("Ofast")
#pragma GCC optimize("inline")
#pragma GCC optimize("-fgcse")
#pragma GCC optimize("-fgcse-lm")
#pragma GCC optimize("-fipa-sra")
#pragma GCC optimize("-ftree-pre")
#pragma GCC optimize("-ftree-vrp")
#pragma GCC optimize("-fpeephole2")
#pragma GCC optimize("-ffast-math")
#pragma GCC optimize("-fsched-spec")
#pragma GCC optimize("unroll-loops")
#pragma GCC optimize("-falign-jumps")
#pragma GCC optimize("-falign-loops")
#pragma GCC optimize("-falign-labels")
#pragma GCC optimize("-fdevirtualize")
#pragma GCC optimize("-fcaller-saves")
#pragma GCC optimize("-fcrossjumping")
#pragma GCC optimize("-fthread-jumps")
#pragma GCC optimize("-funroll-loops")
#pragma GCC optimize("-fwhole-program")
#pragma GCC optimize("-freorder-blocks")
#pragma GCC optimize("-fschedule-insns")
#pragma GCC optimize("inline-functions")
#pragma GCC optimize("-ftree-tail-merge")
#pragma GCC optimize("-fschedule-insns2")
#pragma GCC optimize("-fstrict-aliasing")
#pragma GCC optimize("-fstrict-overflow")
#pragma GCC optimize("-falign-functions")
#pragma GCC optimize("-fcse-skip-blocks")
#pragma GCC optimize("-fcse-follow-jumps")
#pragma GCC optimize("-fsched-interblock")
#pragma GCC optimize("-fpartial-inlining")
#pragma GCC optimize("no-stack-protector")
#pragma GCC optimize("-freorder-functions")
#pragma GCC optimize("-findirect-inlining")
#pragma GCC optimize("-frerun-cse-after-loop")
#pragma GCC optimize("inline-small-functions")
#pragma GCC optimize("-finline-small-functions")
#pragma GCC optimize("-ftree-switch-conversion")
#pragma GCC optimize("-foptimize-sibling-calls")
#pragma GCC optimize("-fexpensive-optimizations")
#pragma GCC optimize("-funsafe-loop-optimizations")
#pragma GCC optimize("-fdelete-null-pointer-checks")
typedef pair<int,int> pii;
inline int read(){
	int x=0,neg=1;char c=getchar();
	while(!isdigit(c)){
		if(c=='-')	neg=-1;
		c=getchar();
	}
	while(isdigit(c))	x=x*10+c-'0',c=getchar();
	return x*neg;
}
inline void print(int x){
	if(x<0){
		putchar('-');
		print(abs(x));
		return;
	}
	if(x<=9)	putchar(x+'0');
	else{
		print(x/10);
		putchar(x%10+'0');
	}
}
inline int qpow(int x,int e,int _MOD){
	int ans=1;
	while(e){
		if(e&1)	ans=ans*x%_MOD;
		x=x*x%_MOD;
		e>>=1;
	}
	return ans;
}
int n=read(),m=read();
const int BLOCK_SZ=500;
int bel[60005],L[60005],R[60005],blk;
struct query{
	int l,r,id;
	friend bool operator <(query a,query b){
		if(bel[a.l]!=bel[b.l])	return bel[a.l]<bel[b.l];
		else if(bel[a.l]^1)		return a.r>b.r;
		else					return a.r<b.r;
	}
} q[60005];
char s[60005];
unsigned short cnt[1<<26];
int ans=0;
int sum[60005],anss[60005];
inline void insertl(int x){
	x--;
	ans+=cnt[sum[x]];
	int t=sum[x];
	for(register int i=0;i<26;i++)	ans+=cnt[t^(1<<i)];
	cnt[sum[x]]++;
}
inline void insertr(int x){
	ans+=cnt[sum[x]];
	int t=sum[x];
	for(register int i=0;i<26;i++)	ans+=cnt[t^(1<<i)];
	cnt[sum[x]]++;
}
inline void dell(int x){
	x--;
	cnt[sum[x]]--;
	ans-=cnt[sum[x]];
	int t=sum[x];
	for(register int i=0;i<26;i++)	ans-=cnt[t^(1<<i)];
}
inline void delr(int x){
	cnt[sum[x]]--;
	ans-=cnt[sum[x]];
	int t=sum[x];
	for(register int i=0;i<26;i++)	ans-=cnt[t^(1<<i)];
}
signed main(){
	cin>>s+1;
	blk=(n-1)/BLOCK_SZ+1;
	fz(i,1,blk){
		L[i]=(i-1)*BLOCK_SZ+1;
		R[i]=min(i*BLOCK_SZ,n);
		fz(j,L[i],R[i])	bel[j]=i;
	}
	fz(i,1,n)	sum[i]=sum[i-1]^(1<<(s[i]-'a'));
	cnt[0]=1;
	fz(i,1,m){
		q[i].l=read(),q[i].r=read();q[i].id=i;
	}
	sort(q+1,q+m+1);
	int l=1,r=0;
	fz(i,1,m){
//		cout<<i<<endl;
		while(r<q[i].r)	insertr(++r);
		while(l>q[i].l)	insertl(--l);
		while(l<q[i].l)	dell(l++);
		while(r>q[i].r)	delr(r--);
		anss[q[i].id]=ans;
	}
	fz(i,1,m)	printf("%d\n",anss[i]);
	return 0;
}
```

---

## 作者：w (赞：6)

官方题解： https://www.luogu.org/discuss/show?postid=7867


---

## 作者：louhao088 (赞：4)


一道莫队好题。

------------

题意：求区间可重排为回文串的个数。

------------


看到可重排为回文串，我们想到它的性质，即至多有一个字母个数为奇数，又因为字母数只有 26 ，那么我们很容易联想到把串压为一个数，其中每位表示一个字母出现的奇偶次数，这样最多有 27 种，我们就可以暴力判断一个串是否为合法了。而且往串中加入一个字母也可以 $O(1)$ 完成，算每一段的值可以用异或操作 $O(1)$ ，然而这样复杂度仍然很大，为 $O(n^2q)$，很显然无法通过。

考虑优化，由于合法情况很少，我们可以用枚举合法方案代替判断每个序列是否合法。具体的，我们可以用一个桶统计串的出现情况，这样我们可以用 $O(27)$ 统计之前与他可以异或得到的合法情况，这样复杂度就降为 $O(27nq)$ 。

继续优化，由于可以离线，很容易想到用莫队优化，往一个序列加值，删值算贡献可以 $O(27)$ 完成，时间复杂度为 $O(27q \sqrt n)$。


------------


这样理论上可以通过，然而发现 MLE 。本题对空间要求较高，由于本题桶的相同方案数量较少，我们可以用 unsinged short int （short int 有可能会被特殊数据构造到溢出） 。这样只要常数不太大就能通过了。




------------
代码如下

```cpp
#include<bits/stdc++.h>
using namespace std;
//static char buf[1000000],*p1=buf,*p2=buf;
//#define getchar() p1==p2&&(p2=(p1=buf)+fread(buf,1,1000000,stdin),p1==p2)?EOF:*p1++
#define re register
#define mp make_pair
#define fi first
#define se second
#define pb push_back
const int maxn=6e4+5,M=34005;
inline int read()
{
	char ch=getchar();bool f=0;int x=0;
	for(;!isdigit(ch);ch=getchar())if(ch=='-')f=1;
	for(;isdigit(ch);ch=getchar())x=(x<<1)+(x<<3)+(ch^48);
	if(f==1)x=-x;return x;
}
inline void print(int x)
{
    static int a[55];int top=0;
    if(x<0) putchar('-'),x=-x;
    do{a[top++]=x%10,x/=10;}while(x);
    while(top) putchar(a[--top]+48);
}
int n,m,a[maxn],res,ans[maxn],id[maxn],t;
unsigned short int s[1<<26];
struct node {int l,r,id;}q[maxn];
char b[maxn];
bool cmp(node a,node b){if(id[a.l]!=id[b.l])return a.l<b.l;if(id[a.l]&1)return a.r<b.r;return a.r>b.r;}
void add(int x){for(int i=0;i<=25;i++)res+=s[x^(1<<i)];res+=s[x];s[x]++;}
void cut(int x){s[x]--;for(int i=0;i<=25;i++)res-=s[x^(1<<i)];res-=s[x];}
signed main()
{
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	n=read(),m=read();
	scanf("%s",b+1);t=sqrt(n+m);
	for(int i=1;i<=n;i++)
		a[i]=a[i-1]^(1<<(b[i]-'a')),id[i]=(i-1)/t+1;
	for(int i=1;i<=m;i++)
		q[i].l=read()-1,q[i].r=read(),q[i].id=i;
	sort(q+1,q+m+1,cmp);int l=0,r=-1;
	for(int i=1;i<=m;i++)
	{
		
		while(l>q[i].l)add(a[--l]);
		while(r<q[i].r)add(a[++r]);
		while(l<q[i].l)cut(a[l++]);
		while(r>q[i].r)cut(a[r--]);
		ans[q[i].id]=res;
	}
	for(int i=1;i<=m;i++)
		printf("%d\n",ans[i]);
 	return 0;
}
```






---

## 作者：MSqwq (赞：3)

~~过的第一道 lxl 的题，真 nm 毒瘤~~  
蛮好的一道题目。  
考虑状压。对原数列做前缀和，每一位代表是奇数个还是偶数个。那么前缀和异或就可以得到一个区间。  
对于一个区间，只有异或和是 $0$ 或 $2^k$  时才能构成回文串。那么莫队增加和修改时枚举 $k$ 即可。   
时间复杂度：$O(26n \sqrt n)$  
注意常数不要太大。  
代码实现：  
```
#include<bits/stdc++.h>
#define ll long long
using namespace std;
int n,m;
int g,q[60010]; 
char c[60010];
struct qwq{
    int x,y;
    int id;
}a[60010];
bool cmp(qwq x,qwq y)
{
    if(x.x/g==y.x/g)
    {
        if((x.x/g)&1)return x.y<y.y;
        else return x.y>y.y;
    }
    else return x.x<y.x;
}
int l=1,r,sum,ql,qr;
int f[1<<26];
int ans[60010];
void q1(int x)
{
    sum+=f[q[x]];
    for(int i=0;i<=25;i++)sum+=f[q[x]^(1<<i)];
    f[q[x]]++;
}
void q2(ll x)
{
    f[q[x]]--;
    for(int i=0;i<=25;i++)sum-=f[q[x]^(1<<i)];
    sum-=f[q[x]];
}
int main()
{
    scanf("%d%d",&n,&m);
    g=sqrt(n);
    cin>>c;
    for(int i=0;i<strlen(c);i++)q[i+1]=q[i]^(1<<(c[i]-'a'));
    for(int i=1;i<=m;i++)
    {
        scanf("%d%d",&a[i].x,&a[i].y);
        a[i].id=i;
    }
    sort(a+1,a+1+m,cmp);
    f[0]=1;
    for(int i=1;i<=m;i++)
    {
        ql=a[i].x;
        qr=a[i].y;
        while(r<qr)q1(++r);
        while(l>ql)q1(--l-1);
        while(l<ql)q2(l++-1);
        while(r>qr)q2(r--);
        ans[a[i].id]=sum;
    } 
    for(int i=1;i<=m;i++)printf("%d\n",ans[i]);
}
```


---

## 作者：404Not_Found (赞：2)

一个区间是否能重排成回文串，等价于最多有一个字母出现次数为奇数。所以我们只需关心每个字母出现次数的奇偶性。

考虑状压，用一个 $26$ 进制的数来表示一段区间每个字母出现次数的奇偶性。仿照[这道题](https://www.luogu.com.cn/problem/P4462)的思路，记录异或前缀和，记为 $a_i$，那么 $[l,r]$ 的异或和即为 $a_{l-1}  \oplus a_r$。则问题变为，区间 $[l-1,r]$ 内有多少对 $(x,y)$ 使得 $x \oplus y$ 最多只有一位为 $1$，莫队统计即可。

时间复杂度：$\mathcal{O}(n \sqrt n)$。忽略常数，视 $n,m$ 同阶。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN = 6e4+5;
inline int read()
{
	int x=0; char c=getchar();
	for(;!isdigit(c);c=getchar());
	for(;isdigit(c);c=getchar()) x=(x<<1)+(x<<3)+c-48;
	return x;
}
int blk,bel[MAXN];
struct Query{
	int l,r,id;
	bool operator<(Query& rhs)
	{
		if(bel[l]==bel[rhs.l]) return bel[l]&1?r<rhs.r:r>rhs.r;
		return bel[l]<bel[rhs.l]; 
	}
} q[MAXN];
int a[MAXN],ans[MAXN],now,n,m;
short cnt[(1<<26)+5];
void add(int x)
{
	now+=cnt[a[x]]; cnt[a[x]]++;
	for(int i=0;i<26;i++) now+=cnt[a[x]^(1<<i)];
}
void del(int x)
{
	cnt[a[x]]--; now-=cnt[a[x]];
	for(int i=0;i<26;i++) now-=cnt[a[x]^(1<<i)];
}
int main()
{
	n=read(); m=read(); blk=pow(n,0.5);
	for(int i=1;i<=n;i++)
	{
		char c; cin>>c;
		a[i]=a[i-1]^(1<<(c-'a'));
		bel[i]=(i-1)/blk+1;
	}
	for(int i=1;i<=m;i++)
	{
		q[i].l=read(),q[i].r=read(); q[i].l--;
		q[i].id=i;
	}
	sort(q+1,q+m+1);
	int l=1,r=0;
	for(int i=1;i<=m;i++)
	{
		while(l<q[i].l) del(l++);
		while(l>q[i].l) add(--l);
		while(r<q[i].r) add(++r);
		while(r>q[i].r) del(r--);
		ans[q[i].id]=now;
	}
	for(int i=1;i<=m;i++) printf("%d\n",ans[i]);
	return 0;
}
```

---

## 作者：xudaxia (赞：2)

这个题还是可以的。  
但是卡常卡得我心力憔悴。还是太菜了  
我们把一个区间当做一个26位二进制数，每一位代表一个英文，二进制数的每一个位0代表这一位对应的字母出现了偶数次，否则出现了奇数次。    
那么一个区间可以升天，当且仅当这个区间对应的二进制数为0或$x^i$。  
我们用莫队。用$a[i]$代表异或前缀和。考虑$[l,r]->[l,r+1]$贡献的变化，贡献会加上，$\sum{(a[r+1]==a[x])}+\sum{a[r+1]\oplus{(1<<i)}}(l-1\leq x\leq r,0\leq i\leq 25)$   
我们维护一个$a[i]$在当前区间出现次数的桶$c[i]$就成  了$c[a[r+1]]+\sum{c[a[r+1]\oplus{(1<<i)}]}(0\leq i\leq 25)$就可以做了。  
卡常居然用到了 unsigned short。。。
```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<map>
using namespace std;
const int N=60100;
map<int,bool> book;
int n,m,ans[N],tmp,a[N],block[N],pw[30];
unsigned short c[(1<<26)+100];
int cnt,head[N];
struct edge{
    int to,nxt;
}e[N*26];
void add(int u,int v){
    cnt++;
    e[cnt].nxt=head[u];
    e[cnt].to=v;
    head[u]=cnt;
}
char s[N];
struct ques{
    int l,r,id;
}qu[N];
bool cmp(ques a,ques b){
    if(block[a.l]==block[b.l])return a.r<b.r;
    else return block[a.l]<block[b.l];
}
int read(){
    int sum=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){sum=sum*10+ch-'0';ch=getchar();}
    return sum*f;
}
int main(){
    n=read(),m=read();
    int Block=sqrt(n);
    scanf("%s",s+1);
    book[0]=1;
    for(int i=1;i<=n;++i){
        a[i]=a[i-1]^(1<<(s[i]-'a'));
        block[i]=(i-1)/Block+1;
        book[a[i]]=1;
    }
    for(int i=0;i<=n;i++)
        for(int j=0;j<=25;j++)
            if(book[a[i]^(1<<j)])add(i,a[i]^(1<<j));
    for(int i=1;i<=m;++i)qu[i].l=read(),qu[i].r=read(),qu[i].id=i;
    sort(qu+1,qu+1+m,cmp);
    int l=1,r=0;
    c[0]=1;
    for(int j=1;j<=m;++j){
        while(r<qu[j].r){
            r++;
            tmp+=c[a[r]];
            for(int i=head[r];i;i=e[i].nxt)tmp+=c[e[i].to];
            c[a[r]]++;
        }
        while(l>qu[j].l){
            l--;
            tmp+=c[a[l-1]];
            for(int i=head[l-1];i;i=e[i].nxt)tmp+=c[e[i].to];
            c[a[l-1]]++;
        }
        while(r>qu[j].r){
            c[a[r]]--;
            tmp-=c[a[r]];
            for(int i=head[r];i;i=e[i].nxt)tmp-=c[e[i].to];
            r--;
        }
        while(l<qu[j].l){
            c[a[l-1]]--;
            tmp-=c[a[l-1]];
            for(int i=head[l-1];i;i=e[i].nxt)tmp-=c[e[i].to];
            l++;
        }
        ans[qu[j].id]=tmp;
    }
    for(int i=1;i<=m;i++)printf("%d\n",ans[i]);
    return 0;
}
```

---

## 作者：hongzy (赞：2)

### 莫队题

先把字母用二进制表示

考虑移动区间对答案的贡献：

一个区间$[l,r]$对答案有贡献当且仅当$a[r] \;\text{xor}\; a[l - 1]=2^x$或$0$，其中$a[i]$为异或前缀和

那么开一个桶记录，用$c[x]$表示$a$值为$x$的点个数，统计答案直接利用异或的性质

有个细节：当前维护$[l,r]$的信息时，桶应该维护$[l-1,r]$的信息

然后就是如何解决出题人的各种卡：

桶开$\text{unsigned short}$可以解决空间问题

然后可以$70$分，最多卡到$80$

我们发现每次移动端点时，这$26$个状态很多是肯定为$0$的，对答案不产生影响。可以发现只有$a$中出现过的值才是有用的，把这些状态存下来。换句话说，$c[x]$有用当且仅当存在$a[i]=x$.

（离散化可能不必要qwq

```cpp
#include <algorithm>
#include <cstdio>
#include <cmath>
using namespace std;

typedef unsigned short ushort;

const int N = 6e4 + 5;

struct Query {
	int id, l, r, fir;
	bool operator < (const Query & q2) const {
		return fir < q2.fir || (fir == q2.fir && r < q2.r);
	}
} q[N];

int n, m, b, a[N], ans[N], now;
int st[N][26], len[N]; //有用状态 
char s[N];
ushort c[1 << 26]; //桶 
bool tag[1 << 26]; //a的访问标记 

void ins(int x) { //insert
	now += c[a[x]] ++;
	for(ushort i = 0; i < len[x]; i ++)
		now += c[st[x][i]];
}

void del(int x) { //delete
	now -= -- c[a[x]];
	for(ushort i = 0; i < len[x]; i ++)
		now -= c[st[x][i]];
}

int main() {
	scanf("%d%d%s", &n, &m, s + 1);
	b = (int) (n / sqrt(m)); //block size
	for(ushort i = 0; i <= n; i ++) {
		a[i] = i ? a[i - 1] ^ (1 << (s[i] - 'a')) : 0;
		tag[a[i]] = 1;
	}
	for(ushort i = 0; i <= n; i ++) {
		for(ushort j = 0; j < 26; j ++) {
			if(tag[a[i] ^ (1 << j)]) {
				st[i][len[i] ++] = a[i] ^ (1 << j);
			}
		}
	}
	for(ushort i = 1; i <= m; i ++) {
		scanf("%d%d", &q[i].l, &q[i].r);
		q[i].fir = q[i].l / b;
		q[i].id = i;
	}
	sort(q + 1, q + m + 1);
	int l = q[1].l, r = q[1].l - 1;
	c[a[l - 1]] ++;
	for(ushort i = 1; i <= m; i ++) {
		while(l > q[i].l) ins(-- l - 1);
		while(r < q[i].r) ins(++ r);
		while(l < q[i].l) del(l ++ - 1);
		while(r > q[i].r) del(r --);
		ans[q[i].id] = now;
	}
	for(int i = 1; i <= m; i ++)
		printf("%d\n", ans[i]);
	return 0;
}
```

---

## 作者：寒鸽儿 (赞：1)

题意：

给定一个长度为 $n$ 的字符串， $m$ 次询问区间能重排成回文串的子区间计数。  

$1 \leq n, m \leq 6 \times 10^4, \left| \sum ^ * \right| = 26$ 。

题解：  

区间重排成回文串等价于区间出现出现次数为奇数的字符的个数不超过 $1$ 。   

将 $\sum^*$ 映射到 $\mathbb Z_2^{\left| \sum^* \right|}$ 的一组向量基。则区间出现次数均为偶数等价于区间 $+_2$ 之和 $=0$ 。有一个数出现次数为奇数等价于 $+_2$ 和等于选取的基的一个向量（数）。

不妨取 $x_i = $ `1 << i` ， $0 \leq i \leq 25$ 。 

由于基比较小（26），可以直接暴力扫。

问题转化到可以简单地由普通莫队维护的信息。区间 $+_2$ 可以很简单地差分，用两个后缀 $+_2$ 的 $+_2$ 来表示。

---

## 作者：SDNetFriend (赞：1)

## P3604 美好的每一天 题解

（头次独立做出 lxl 的题，虽然不是 Ynoi（大雾））

### 题意这里不再赘述

[P3604 美好的每一天](https://www.luogu.com.cn/problem/P3604)

### 朴素分析

这个数据范围一看，可以猜到大概是字符集大小乘个 $\sqrt n$ 或者 $\log_n^2$，这里是前者，可以用莫队处理。

那考虑什么样的区间重排后可以成为回文串，即出现次数为奇数的字母至多只有一个的区间。

### 深入分析

考虑如何在移动端点时维护这个限制。我们发现，假设我们采用状压维护区间每个字母出现次数的奇偶性，那么这个信息可以方便地变成前缀和。

简单来讲就是，我们设 $a_x$ 表示区间 $[1,x]$ 中各字母出现次数的奇偶性，对应位如果是 $0$ 就是偶数，是 $1$ 即为奇数，那么区间 $[l,r]$ 重排后可以成为回文串的充要条件即 $a_{l-1}\bigoplus a_r$ 是 $0$ 或 $2^k (k\in Z)$。

然后这个东西就可以莫队维护了。可以用 $b$ 来存储所有可以和当前位的 $a$ 匹配的状态，转移时挨个处理即可。

### 优化

我们发现状态比较多，达到了 $2^{26}$，但这在本题的空间限制下是过大的，那么离散化即可。

### 贴代码

```cpp
#include <bits/stdc++.h>
#define lint long long
#define rint register int
using namespace std;
inline lint read(){
	char c;lint f=1,res=0;
	while(c=getchar(),!isdigit(c))if(c=='-')f*=-1;
	while(isdigit(c))res=res*10+c-'0',c=getchar();
	return res*f;
}
/*写完这个题去写莫队总结啊！*/
const int N=1e5+5,C=30,S=N*C;
int n,m,a[N],b[N][C],bk;;
lint ans[N];
char s[N];
struct query{int l,r,id;}q[N];
inline bool cmp(query q0,query q1){
	if(q0.l/bk==q1.l/bk)
		return q0.r<q1.r;
	return q0.l<q1.l;
}
int _a[S],cnt;
map<int,int> id;
//离散化 
inline void init(){
	for(rint i=0;i<=n;++i){
		_a[++cnt]=a[i];
		for(rint j=1;j<=26;++j)
			_a[++cnt]=a[i]^(1<<(j-1));
	}
	sort(_a+1,_a+cnt+1);
	cnt=unique(_a+1,_a+1+cnt)-(_a+1);
	for(rint i=1;i<=cnt;++i)
		id[_a[i]]=i;
	for(rint i=0;i<=n;++i){
		b[i][0]=id[a[i]];
		for(rint j=1;j<=26;++j)
			b[i][j]=id[a[i]^(1<<(j-1))];
	}
}
lint sum[S]={0},res=0;
int lp=0,rp=-1;//端点从0开始
//加入x位置的贡献 
inline void add(int x){
	for(rint i=0;i<=26;++i)
		res+=sum[b[x][i]];
	++sum[b[x][0]];
} 
//删除x位置的贡献
inline void del(int x){
	--sum[b[x][0]];
	for(rint i=0;i<=26;++i)
		res-=sum[b[x][i]];
} 
inline void calc(int l,int r){
	while(lp>l)add(--lp);
	while(rp<r)add(++rp);
	while(lp<l)del(lp++);
	while(rp>r)del(rp--);
}
int main(){
	n=read();m=read();
	scanf("%s",s+1);
	for(rint i=1;i<=n;++i)
		a[i]=a[i-1]^(1<<(s[i]-'a'));
	init();
	for(rint i=1;i<=m;++i){
		int l=read(),r=read();
		q[i]=query{l,r,i};
	}
	bk=4*sqrt(n)+1;
	sort(q+1,q+1+m,cmp);
	for(rint i=1;i<=m;++i){
		calc(q[i].l-1,q[i].r);
		ans[q[i].id]=res;
	}
	for(rint i=1;i<=m;++i)
		printf("%lld\n",ans[i]);
	return 0;
}
```


---

## 作者：FutaRimeWoawaSete (赞：1)

卡空间恶心心。               

我们考虑什么样的区间才可以排列成一个回文串：        

1. 所有数的出现次数为偶数；
2. 有 $1$ 个数出现奇数次其他数出现次数都为偶数；        

那么我们只要能快速维护一个区间的数字出现次数奇偶性即可，果断考虑到我们的按位异或运算。           

我们发现字符集大小很小，所以直接用一个数来压字母，然后滚一个前缀和就可以 $O(1)$ 知道一个区间的奇偶情况。              

第一眼感觉可以区间 DP ，然而多组静态查询就在往数据结构的方向上引领了。                   

我们考虑一下如何判断一个区间合法：            

1. 对应的答案就是区间按位异或值为 $0$ ；         
2. 对应的答案就是区间按位异或值为一个 $2$ 的整数次幂；       

于是考虑莫队，我们在转移的时候用 $O(26)$ 枚举一下 $2$ 的情况就好了，时间复杂度 $O(26n \sqrt n)$ 。         

比较恶心的是卡了空间，因为我们任意一种前缀和种类最多的出现次数不会超过 n 的一半也就是 $30000$ ，刚好可以用 short 类型卡一下空间……               

贱，太贱了。             

```cpp
#include "bits/stdc++.h"
using namespace std;
const int Len = 6e4 + 5;
int n,m;
char s[Len];
short cnt[1 << 26];
int nums[32],sum[Len],block[Len],t,Print[Len],Ans;
struct node
{
	int l,r,id;
}Sec[Len];
bool cmp(node x,node y)
{
	if(block[x.l] == block[y.l]) return x.r < y.r;
	return block[x.l] < block[y.l];
}
inline void Add(int x)
{
	Ans += cnt[sum[x]];
	cnt[sum[x]] ++;
	for(int i = 0 ; i < 26 ; i ++) Ans += cnt[sum[x] ^ nums[i]];
	//printf("1 %d %d\n",x,Ans); 
}
inline void Sub(int x)
{
	cnt[sum[x]] --;
	Ans -= cnt[sum[x]];
	for(int i = 0 ; i < 26 ; i ++) Ans -= cnt[sum[x] ^ nums[i]];
	//printf("2 %d %d\n",x,Ans); 
}
int main()
{
	for(int i = 0 ; i < 26 ; i ++) nums[i] = (1 << i);
	scanf("%d %d",&n,&m);
	t = sqrt(n);
	for(int i = 1 ; i <= n ; i ++) block[i] = (i - 1) / t + 1;
	scanf("%s",s + 1);
	for(int i = 1 ; i <= n ; i ++) sum[i] = sum[i - 1] ^ nums[s[i] - 'a'];
	//for(int i = 1 ; i <= n ; i ++) printf("%d ",sum[i]); 
	for(int i = 1 ; i <= m ; i ++)
	{
		scanf("%d %d",&Sec[i].l,&Sec[i].r);
		Sec[i].id = i;
	}
	sort(Sec + 1 , Sec + 1 + m , cmp);
	int l = 1 , r = 0;
	//for(int i = 1 ; i <= m ; i ++) printf("###%d %d\n",Sec[i].l,Sec[i].r);
	for(int i = 1 ; i <= m ; i ++)
	{
		while(l > Sec[i].l - 1) Add(-- l);
		while(r < Sec[i].r) Add(++ r);
		while(l < Sec[i].l - 1) Sub(l ++);
		while(r > Sec[i].r) Sub(r --);
		Print[Sec[i].id] = Ans;
	}
	for(int i = 1 ; i <= m ; i ++) printf("%d\n",Print[i]);
	return 0;
}
```

---

## 作者：1saunoya (赞：1)

[$my blog$](https://www.cnblogs.com/Isaunoya/p/11642428.html)

~~lxl 的题还真是毒瘤…~~

题意大概是 l ~ r 区间有多少个回文子串…
然后考虑怎么做…数字的出现次数怎么看都是和莫队没有关系的。
不难想到，想要一段区间回文，必须小于等于一个`有奇数次出现的`字母。

那么考虑 -> [这题](https://www.luogu.org/problem/P1469)

你就有想法了，就是把一个区间异或起来。剩下的值就是奇数次出现的。

那么又可以想到 一共有 26 个字母 你可以把每个字母压成 $2^0$ ~ $2^25$ 

这样就可以当做数值来做了。

问题1：怎么求区间异或和( O(1) 的 复杂度 )

问题2:  怎么莫队（区间的当然和平常的莫队不太一样）

请读者 仔细思考以上问题再继续下翻。

异或和是可以通过像前缀和的方式求的
前缀和的预处理 $sum_i$ = $sum_{i-1}$ + $a_i$
查询 $sum_{i=l}^{r}$ $sum_r$ - $sum_{l-1}$

异或前缀和也是可以做的 类似正常的前缀和
$sum_i$ = $sum_{i-1}$ ^ $a_i$
$\oplus_{i=l}^{r}$ = $sum_r$ ^ $sum_{l-1}$

然后考虑怎么莫队
当你把 $sum_i$ 设成了 1 到 i 的 异或和
你需要做的就是求这个区间的两个数的异或和是否由二进制位组成。
然后这个问题就转化成 $\mathfrak{0(26n)}$ 的预处理了
你只需要算出来对它有贡献的且序列里有的然后放到 $vector$ 里
每次移动左右指针的时候修改的复杂度就会降低
我个人建议把 所有的 l 都 减 1 这样操作起来会方便点 而且 r 到 r 这个区间也算贡献的。

给出两道弱化版的题 建议做好了再做这题。

~~~
https://www.luogu.org/problem/P4462
https://www.luogu.org/problem/CF617E
~~~

我在这道题上栽了个坑… 其他题我也没注意到这个问题 Ins 和 Del 操作建议放在一起
不放在一起就会相互影响 这样答案可能不对
这题的整体复杂度是 $\mathfrak{0(26 n\sqrt{n})}$

code

```cpp
#pragma GCC optimize("Ofast")
#pragma GCC optimize(3)
#include<bits/stdc++.h>
using namespace std ;
const int N = 6e4 + 5 ;
struct node {
	int l , r , id , bl ;
	bool operator < (const node & c) const {
		return bl < c.bl || (bl == c.bl && r < c.r) ;
	}
} q[N] ;
int n , m , a[N] , Ans[N] , ans = 0 ;
char s[N] ;
vector < int > v[N] ;
unsigned short cnt[1 << 26] ;
bool vis[1 << 26] ;
inline void Ins(int x) { ans += cnt[a[x]] ++ ; for( int & pt : v[x] ) ans += cnt[pt] ; }
inline void Del(int x) { ans -= -- cnt[a[x]] ; for( int & pt : v[x] ) ans -= cnt[pt] ; }
signed main() {
	scanf("%d %d %s" , & n , & m , s + 1) ;
	int unt = n / sqrt(m * 0.9) ;
	for(register int i = 0 ; i <= n ; i ++) a[i] = i ? a[i - 1] ^ (1 << (s[i] - 'a')) : 0 , vis[a[i]] = 1 ;
	for(register int i = 0 ; i <= n ; i ++)
		for(register int j = 0 ; j <= 25 ; j ++) if(vis[a[i] ^ (1 << j)]) v[i].emplace_back(a[i] ^ (1 << j)) ;
	for(register int i = 1 ; i <= m ; i ++) scanf("%d %d" , & q[i].l , & q[i].r) , q[i].bl = q[i].l / unt , q[i].id = i ;
	sort(q + 1 , q + m + 1) ;
	int l = q[1].l , r = q[1].l - 1; cnt[a[l - 1]] ++ ;
	for(register int i = 1; i <= m; i ++) {
			while(l > q[i].l) Ins(-- l - 1) ;
			while(r < q[i].r) Ins(++ r) ;
			while(l < q[i].l) Del(l ++ - 1) ;
			while(r > q[i].r) Del(r --) ;
			Ans[q[i].id] = ans ;
	}
	for(register int i = 1 ; i <= m ; i ++) printf("%d\n" , Ans[i]) ;
	return 0 ;
}
```

---

## 作者：JWRuixi (赞：0)

~~我讨厌细节题……，但看到这道题好多人复杂度呢么假，于是过来写篇题解~~

- 题意

给定一个长度为 $n$ 的字符串 $s$，和 $m$ 组询问：

```l r```，询问有多少组 $i, j$ 满足 $l\le i \le j \le r$，且 $s[l,r]$ 为回文串。

- 分析

首先考虑到回文串的特征是至多有一个字母数量为奇数，只看奇偶而且字符集很小，考虑状压。

设状态 $s$ 表示每个字符数量奇偶的状态，考虑对其做个前缀异或和就能知道一个区间的状态了！当且仅当 ```__builtin_popcount(s[r] ^ s[l - 1]) <= 1``` 时这个区间合法，这样我们就有了 $\mathcal O(26n\sqrt n)$ 的普通莫队做法！

但是有计算机算一下，极限情况下这个复杂度高达 $380640000$，平均下来每秒要跑 $126880000$，似乎难以通过（除非你常数小……），许哦一这个时候就要介绍优化方法，莫队二次离线！

莫队二次离线适用于当转移复杂度较高，查询复杂度低，且询问贡献可以差分时使用，显然这道题满足这些限制！

考虑一个区间的转移，当 $[l,r]\rightarrow [l,r+1]$，时，我们新加入的数 $s_r$ 的贡献可以拆成 $s_r\rightarrow [1,r]$，再去掉 $s_r \rightarrow [1,l-1]$。

我么发现有大量的贡献形如 $p\rightarrow [1,p-1]$，显然这种贡献可以提前处理出来，复杂度 $\mathcal O(26n)$，至于 $p\rightarrow [1,l-1]$ 的贡献，我们可以将其挂在 $l-1$ 这个点上，让后在遍历时处理，显然我们可以预处理能和状态 $s$ 匹配的所有情况，那就可以做到 $\mathcal O(26n + n\sqrt n)$ 了！

综上复杂度 $\mathcal O(26n + n\sqrt n)$，可以通过本题，代码细节多，建议仔细读完并理解后在写。

- code

```cpp
#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/hash_policy.hpp>
#pragma GCC target("sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2")
#define LL long long
using namespace std;

namespace IO{
	char ibuf[(1 << 20) + 1], *iS, *iT;
	#if ONLINE_JUDGE
	#define gh() (iS == iT ? iT = (iS = ibuf) + fread(ibuf, 1, (1 << 20) + 1, stdin), (iS == iT ? EOF : *iS++) : *iS++)
	#else
	#define gh() getchar()
	#endif
	#define reg register
	inline long long read () {
		reg char ch = gh();
		reg long long x = 0;
		reg char t = 0;
		while (ch < '0' || ch > '9') t |= ch == '-', ch = gh();
		while (ch >= '0' && ch <= '9') x = (x << 1) + (x << 3) + (ch ^ 48), ch = gh();
		return t ? -x : x;
	}
	inline void write(long long x) {
		if (x < 0) {
			x = ~(x - 1);
			putchar('-');
		}
		if (x > 9)
			write(x / 10);
		putchar(x % 10 + '0');
	}
	inline char cread () {
		reg char ch = gh();
		while (ch == ' ' || ch == '\n') ch = gh();
		return ch;
	}
}

using IO::read;
using IO::write;
using IO::cread;

const int maxn(60005);
int n, m, sqn, a[maxn], s_pre[maxn], s_suf[maxn];
__gnu_pbds::gp_hash_table <int, int> mp;
//map <int, int> mp;
LL pre[maxn], suf[maxn], ans[maxn];

struct qNode {
	int l, r, id;
	LL ans;
	inline bool operator < (const qNode &rhs) const {
		if (l / sqn == rhs.l / sqn) return (l / sqn) & 1 ? r < rhs.r : r > rhs.r;
		return l < rhs.l;
	}
} q[maxn];

struct mNode {
	int l, r, id, k;
};
vector <mNode> pre_qry[maxn], suf_qry[maxn];

inline void mpinit () {
	__gnu_pbds::gp_hash_table <int, int> tmp;
	swap(mp, tmp);
	++mp[0];
	for (int k = 0; k < 26; k++) ++mp[(1 << k)];
}

int main () {
	n = read(), m = read(), sqn = sqrt(n);
	for (int i = 1; i <= n; i++) a[i] = cread() - 'a';
	for (int i = 1; i <= n; i++) s_pre[i] = s_pre[i - 1] ^ (1ll << a[i]);
	for (int i = n; i; i--) s_suf[i] = s_suf[i + 1] ^ (1ll << a[i]);
	mpinit();
	for (int i = 1; i <= n; i++) {
		pre[i] = pre[i - 1] + mp[s_pre[i]];
		++mp[s_pre[i]];
		for (int k = 0; k < 26; k++) ++mp[s_pre[i] ^ (1 << k)];
	}
	mpinit();
	for (int i = n; i; i--) {
		suf[i] = suf[i + 1] + mp[s_suf[i]];
		++mp[s_suf[i]];
		for (int k = 0; k < 26; k++) ++mp[s_suf[i] ^ (1 << k)];
	}
	for (int i = 1; i <= m; i++) q[i] = {read(), read(), i};
	sort(q + 1, q + m + 1);
	for (int i = 1, l = 1, r = 0; i <= m; i++) {
		if (l > q[i].l) {
			q[i].ans += suf[q[i].l] - suf[l];
			suf_qry[r + 1].push_back({q[i].l, l - 1, i, -1});
			l = q[i].l;
		}
		if (r < q[i].r) {
			q[i].ans += pre[q[i].r] - pre[r];
			pre_qry[l - 1].push_back({r + 1, q[i].r, i, -1});
			r = q[i].r;
		}
		if (l < q[i].l) {
			q[i].ans -= suf[l] - suf[q[i].l];
			suf_qry[r + 1].push_back({l, q[i].l - 1, i, 1});
			l = q[i].l;
		}
		if (r > q[i].r) {
			q[i].ans -= pre[r] - pre[q[i].r];
			pre_qry[l - 1].push_back({q[i].r + 1, r, i, 1});
			r = q[i].r;
		}
	}
	mpinit();
	for (int i = 1; i <= n; i++) {
		for (mNode u : pre_qry[i])
			for (int pos = u.l; pos <= u.r; ++pos)
				q[u.id].ans += u.k * mp[s_pre[pos]];
		++mp[s_pre[i]];
		for (int k = 0; k < 26; k++) ++mp[s_pre[i] ^ (1 << k)];
	}
	mpinit();
	for (int i = n; i; i--) {
		for (mNode u : suf_qry[i])
			for (int pos = u.l; pos <= u.r; ++pos)
				q[u.id].ans += u.k * mp[s_suf[pos]];
		++mp[s_suf[i]];
		for (int k = 0; k < 26; k++) ++mp[s_suf[i] ^ (1 << k)];
	}
	for (int i = 2; i <= m; i++) q[i].ans += q[i - 1].ans;
	for (int i = 1; i <= m; i++) ans[q[i].id] = q[i].ans;
	for (int i = 1; i <= m; i++) write(ans[i]), puts("");
}
```

---

## 作者：Valhalla_Is_Calling (赞：0)

应该都能看出来是**莫队**吧(?)

想一下怎么把**回文串**这个问题转化为一个我们会写的模型。

最开始的思路是看一下一个区间是否有且只有一个 $i$ 满足 $i\in[1,26]\ \&\ cnt_i=1$，但感觉不太可做（感谢大佬指明方向）。

我们重新审视一下，如果我们把每一个字母都当成一个数字来看，那么上面那个 $cnt_i=1$ 的东西跟什么很像呢？是的，是异或。有关莫队和异或的爱情历史大家可以先去做一下[LOJ2534. 「CQOI2018」异或序列](https://loj.ac/p/2534) 。

异或一个非常好用的东西就是他的逆运算还是异或，即，一段区间 $[l,r]$ 的异或和等于 $pre_r\  \operatorname{xor}\ pre_{l-1}$，其中 pre 数组是前缀异或和。

我们又可以发现，既然只有一个字母被获准出现奇数次，那么显然，其他的字母代表的数字都可以互相异或抵消以至于消失，最后就剩下最中间那个最闪亮的星。所以我们从 $'a'$ 字母开始，每一个都设一个 $2^k$，这样最后如果一个区间满足条件，其异或和必定只有一个 1 出现。

这样我们就可以用莫队算法来维护一个前缀异或和，然后在 add 和 del 函数里边，枚举是哪一位是 1， 然后计算贡献即可。

#### 关于卡常

注意，这一部分是本题的重点(手动狗头~)

会发现这个前缀异或和最大不会超过 $2^{26}-1$，这个数字非常大，如果开数组会导致 MLE，如果开 map 或 gp_hash_table 会导致 TLE。

然后我们来学习一下上古时期流传的卡常大法。

先看一看是想解决 TLE 还是 MLE。TLE只有20分，没有前途，所以我们来看看怎么不 MLE。

事实上，会发现如果开一个 $2^{26}-1$ 的数组其所占空间刚好是 $256$ MB，但是其实不用 int 那么大的数据范围，因为一共只有 60000 个数，玄学一波开个 short就可以通过本题啦（

#### AC代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=6e4+5;
short cnt[67108865];
// gp_hash_table<long long,int> cnt;
int n,m,a[N],block,pre[N];
char str[N];
int pow2[28],ans;
struct Queries
{
    int id,l,r,ans;
}q[N];
int read()
{
    int x=0,f=1;
    char c=getchar();
    while(c<'0' || c>'9')
    {
        if(c=='-') f=-1;
        c=getchar();
    }
    while(c>='0' && c<='9')
    {
        x=(x<<1)+(x<<3)+(c^48);
        c=getchar();
    }
    return x*f;
}
bool cmp(Queries x,Queries y) {return ((x.l/block)^(y.l/block))?(x.l/block)<(y.l/block):(((x.l/block)&1)?x.r<y.r:x.r>y.r);}
int getlen(int x)
{
    int res=0;
    while (x)
    {
        res++;
        x/=2;
    }
    return res;
}
void del(int x) 
{
	cnt[x]--;
	ans-=cnt[x];
    for(int j=0;j<=25;j++) ans-=cnt[(1<<j)^x];
}
void add(int x) 
{
	ans+=cnt[x];
	cnt[x]++;
    for(int j=0;j<=25;j++) ans+=cnt[(1<<j)^x];
}
bool cmp1(Queries x,Queries y) {return x.id<y.id;}
int main()
{
    n=read(),m=read();
    block=sqrt(n);
    scanf("%s",str+1);
    pow2[0]=1;
    for(int i=1;i<=26;i++) pow2[i]=pow2[i-1]*2;
    for(int i=1;i<=n;i++) a[i]=pow2[str[i]-'a'],pre[i]=pre[i-1]^a[i];
    for(int i=1;i<=m;i++) q[i].id=i,q[i].l=read()-1,q[i].r=read();
    sort(q+1,q+m+1,cmp);
    int posl=1,posr=0;
    for(int i=1;i<=m;i++)
    {
        while(posr>q[i].r) del(pre[posr]),posr--;
        while(posr<q[i].r) posr++,add(pre[posr]);
        while(posl<q[i].l) del(pre[posl]),posl++;
        while(posl>q[i].l) posl--,add(pre[posl]);
        q[i].ans=ans;
        // Ans[q[i].id]=ans;
    }
    sort(q+1,q+m+1,cmp1);
    for(int i=1;i<=m;i++) cout<<q[i].ans<<endl;
    // for(int i=1;i<=m;i++) cout<<Ans[i]<<endl;
    return 0;
}
```


---

## 作者：chenzida (赞：0)

这题是一个挺有思维含量的莫队好题

（首先吐槽一下，第一篇题解好像没有离散化，我也 bzd 它是怎么过的）

思路分析：

这个东西是一个区间操作，同时，并不强制在线，~~正好我在学莫队~~所以就能比较容易看出这是一道莫队题。

那我们这个莫队维护什么呢？

思考能够重排之后成为回文串的条件，应该是只有一种字母有奇数个或者所有字母都是偶数个。又看到字符集大小这么小，可以想到状态压缩一下。又发现我们其实只关心奇偶性，所以我们可以考虑二进制下第 $i$ 位是 $0/1$ 表示这一位是奇数个还是偶数个。而我们一个区间的状态就可以直接进行 $xor$ 算出。

我们记 $Sum_i$ 表示 $1-i$ 的前缀 $xor$ 状态，这样根据异或性质我们可以得到一个区间 $[l,r]$ 的奇偶性状态为 $Sum_{l-1}\ xor\ Sum_r$，而一个区间是否合法就是看这个区间的奇偶性状态中二进制下 $1$ 的个数是否 $\le 1$。

最后还有一个细节，就是在往 $r$ 后加入新的点的时候，我们只用看 $Sum_r$，但是如果是往 $l$ 前加入新的点，我们还要看 $Sum_l$ 和 $Sum_{l-1}$。这个细节必须要处理好。

对于这种区间不对称的情况，我们强制将区间对称，把我们的查询区间的 $l$ 直接强制 $-1$ 即可。

代码如下：
```
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int NR=6e4+10;
void Min(int& x,int y){x=min(x,y);}
void Max(int& x,int y){x=max(x,y);}
int n,m;
int a[NR];
char ch[NR];
int kc;
int getid(int x){return (x-1)/kc+1;}
struct Query
{
	int id,l,r;
	bool operator<(const Query& A)const
	{
		if(getid(A.l)!=getid(l))return l<A.l;
		return r<A.r;
	}
}q[NR];
int tot,p[NR],num[NR];
int getnum(int x)
{
	int l=1,r=tot,ans=0;
	while(l<=r)
	{
		int mid=(l+r>>1);
		if(num[mid]<=x)ans=mid,l=mid+1;
		else r=mid-1;
	}
	if(num[ans]!=x)return 0;
	return ans;
}
int f[NR][30];
int all;
int cnt[NR];
int Ans[NR];
void ins(int x)
{
	all+=cnt[a[x]];cnt[a[x]]++;
	for(int i=0;i<26;i++)all+=cnt[f[x][i]];
}
void del(int x)
{
	cnt[a[x]]--;all-=cnt[a[x]];
	for(int i=0;i<26;i++)all-=cnt[f[x][i]];
}
void move(int x)
{
	int l1=q[x-1].l,l2=q[x].l,r1=q[x-1].r,r2=q[x].r;
	while(l1>l2)ins(l2++);while(r1<r2)ins(r2--);
	while(l1<l2)del(l1++);while(r1>r2)del(r1--);
}
int read()
{
	int x=0,f=1;char ch=getchar();
	while(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}
	while(ch<='9'&&ch>='0'){x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}
	return x*f;
}
signed main()
{
//	freopen("1.in","r",stdin);
//	freopen("1.out","w",stdout);
	n=read(),m=read();scanf("%s",ch+1);kc=sqrt(n);
	for(int i=1;i<=n;i++)a[i+1]=(1<<(ch[i]-'a')),a[i+1]^=a[i],p[i+1]=a[i+1];p[0]=-1,p[1]=a[1]=0;n++;
	sort(p+1,p+n+1);for(int i=1;i<=n;i++)if(p[i]!=p[i-1])num[++tot]=p[i];
	for(int i=1;i<=n;i++)for(int j=0;j<26;j++)
		f[i][j]=(getnum(a[i]^(1<<j)))?(getnum(a[i]^(1<<j))):tot+1;
	for(int i=1;i<=n;i++)a[i]=getnum(a[i]);
	for(int i=1;i<=m;i++)q[i].id=i,q[i].l=read(),q[i].r=read()+1;
	sort(q+1,q+m+1);q[0].l=1,q[0].r=0;
	for(int i=1;i<=m;i++)move(i),Ans[q[i].id]=all;
	for(int i=1;i<=m;i++)printf("%lld\n",Ans[i]);
	return 0;
}

---


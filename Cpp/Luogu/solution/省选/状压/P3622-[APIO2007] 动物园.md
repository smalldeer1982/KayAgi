# [APIO2007] 动物园

## 题目描述

新建的圆形动物园是亚太地区的骄傲。圆形动物园坐落于太平洋的一个小岛上，包含一大圈围栏，每个围栏里有一
种动物。如下图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/8pr43p86.png)

你是动物园的公共主管。你要做的是，让每个来动物园的人都尽可能高兴。今天有一群小朋友来动物园参观，你希望能让他们在动物园度过一段美好的时光。但这并不是一件容易的事——有的动物有一些小朋友喜欢，有的动物有一些小朋友害怕。如，Alex 喜欢可爱的猴子和考拉，而害怕拥牙齿锋利的狮子。而 Polly 会因狮子有美丽的鬃毛而喜欢它，但害怕有臭味的考拉。你可以选择将一些动物从围栏中移走以使得小朋友不会害怕。但你不能移走太多动物，否则小朋友们就没有动物可看了。每个小朋友站在大围栏圈的外面，可以看到连续的 $5$ 个围栏。你得到了所有小朋友喜欢和害怕的动物信息。当下面两处情况之一发生时，小朋友就会高兴：
- 至少有一个他害怕的动物被移走
- 至少有一个他喜欢的动物没被移走

例如，考虑下图中的小朋友和动物：

![](https://cdn.luogu.com.cn/upload/image_hosting/n69iqfv6.png)

- 假如你将围栏 $4$ 和 $12$ 的动物移走。Alex 和 Ka-Shu 将很高兴，因为至少有一个他们害怕的动物被移走了。这也会使 Chaitanya 高兴，因为他喜欢的围栏  $6$ 和 $8$ 中的动物都保留了。但是，Polly 和 Hwan 将不高兴，因为他们看不到任何他们喜欢的动物，而他们害怕的动物都还在。这种安排方式使得三个小朋友高兴。
- 现在，换一种方法，如果你将围栏 $4$ 和 $6$ 中的动物移走，Alex 和 Polly 将很高兴，因为他们害怕的动物被移走了。Chaitanya 也会高兴，虽然他喜欢的动物 $6$ 被移走了，他仍可以看到围栏 $8$ 里面他喜欢的动物。同样的 Hwan 也会因可以看到自己喜欢的动物 $12$ 而高兴。唯一不高兴的只有 Ka-Shu。
- 如果你只移走围栏 $13$ 中的动物，Ka-Shu 将高兴，因为有一个他害怕的动物被移走了，Alex, Polly, Chaitanya 和 Hwan 也会高兴，因为他们都可以看到至少一个他们喜欢的动物。所以有 $5$ 个小朋友会高兴。这种方法使得了最多的小朋友高兴。

## 说明/提示

**数据范围**
对于 $100\%$ 的数据，$10 \le N \le 10^4$，$1 \le C \le 5\times 10^4$，$1 \le E \le N$。

**样例说明**
- 第一个样例是题目描述中的例子，所有的 $C=5$ 个小朋友都能高兴。
- 第二个样例是一个不能使得所有 $C=7$ 个小朋友都高兴的例子。

## 样例 #1

### 输入

```
14 5 
2 1 2 4 2 6 
3 1 1 6 4 
6 1 2 9 6 8
8 1 1 9 12 
12 3 0 12 13 2 ```

### 输出

```
5```

## 样例 #2

### 输入

```
12 7 
1 1 1 1 5 
5 1 1 5 7 
5 0 3 5 7 9 
7 1 1 7 9 
9 1 1 9 11 
9 3 0 9 11 1
11 1 1 11 1```

### 输出

```
6```

# 题解

## 作者：Rayment (赞：47)

# Solution
这是一道状压DP的好题……

首先可以注意到每个小朋友只能看见5个围栏，数据范围很小，其次由于小朋友喜欢和讨厌的动物都是他能看到的，那么这个小朋友是否满意就只与这五格围栏有关，那么可以考虑状态压缩。

考虑到可能小朋友看见的围栏范围可能相同，那么我们可以预处理num[pos][s]，表示从第pos个围栏开始的五个围栏状态为s时，会有多少个小朋友满意。
定义状态f[i][s]表示枚举到第i个围栏且[i,i+5]的围栏移走状态为s时的最多满意人数。则f[i][s]可以由第i-1个围栏移走和不移走两种状态转移得来：

$ f[i][s]=\max{(f[i-1][(s\&15)<<1],f[i-1][(s\&15)<<1|1])}+num[i][s] $

其次要注意的是在dp之前先枚举前五个的状态state，因为围栏是一个环，最后枚举第n+1个围栏时，其实就相当于又回到了第一个围栏，那么此时必须满足s=state才是有效状态，更新答案。

时间复杂度$O(2^{10}\times n)$
# Code
```cpp
#include <iostream>
#include <cstring>
#include <cstdio>
#define check(st) ((st&l)||(~st&d))
using namespace std;
template <typename Tp> inline void read(Tp &x)
{
	x=0;
	char ch=getchar();
	while(ch<'0'||ch>'9') ch=getchar();
	while(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();
}
const int maxn=50010;
int n,m,ans,f[maxn][40],num[maxn][40];
inline int max(int x,int y){return x>y?x:y;}
void input()
{
	int a,b,c,l,d,t;
	read(n);read(m);
	for(int i=1;i<=m;i++)
	{
		read(a);read(b);read(c);
		l=d=0;
		for(int j=1;j<=b;j++)
		  {read(t);t=(t-a+n)%n;l|=1<<t;}
		for(int j=1;j<=c;j++)
		  {read(t);t=(t-a+n)%n;d|=1<<t;}
		for(int j=0;j<32;j++)
		  if(check(j))
		    num[a][j]++;
	}
}
int main()
{
	#ifndef ONLINE_JUDGE
	freopen("in.txt","r",stdin);
	#endif
	input();
	for(int i=0;i<32;i++)
	{
		memset(f[0],128,sizeof(f[0]));//设一个极小值即可
		f[0][i]=0;
		for(int j=1;j<=n;j++)
		  for(int s=0;s<32;s++)
		    f[j][s]=max(f[j-1][(s&15)<<1],f[j-1][(s&15)<<1|1])+num[j][s];
		if(ans<f[n][i])
		  ans=f[n][i];
	}
	printf("%d\n",ans);
	return 0;
}
```


---

## 作者：babingbaboom (赞：30)

Denote i as the number of animals, j as marking the animals i~i + 4 placing away or not, we have: dp[i][j] = max(dp[i - 1][(j >> 1) & 31], dp[i - 1][(j >> 1) + 16]) + num[i][j]. Here num[i][j] stands for the number of children who are happy among the children placing i as their last animal to see while the animals i~i + 4 have a state of j. 

Code:

```cpp
#include<bits/stdc++.h>

using namespace std;

const int MaxN=100010;

int Hate,Love,N,C,ans=0,E;
int F[MaxN][32]={0},num[MaxN][32];

void DFS(int x,int dep,int status)
{
     if (dep>4)
     {
     	if((Love&status)||(Hate&status)!=Hate)num[E][status]++;
        return;
     }
     DFS(x,dep+1,status);
     DFS(x,dep+1,status|(1<<dep));
}

void Init()
{
	 int i,H,L,x;
     scanf("%d%d",&N,&C);
     for (i=1;i<=C;i++)
     {
         scanf(“%d%d%d”,&E,&H,&L);
         Hate=Love=0;
         while (H--){scanf(“%d”,&x);Hate=Hate|(1<<(x-E+N)%N);}
         while (L--){scanf(“%d”,&x);Love=Love|(1<<(x-E+N)%N);}
         DFS(i,0,0);
     }
}

int Max(int a,int b) {return a>b?a:b;}

void DP(int st)
{
     int i,j,k,r,p,q,w1,w2;
     for (j=0;j<32;j++)F[0][j]=0;
     for (i=1;i<=N;i++)
     {
     	if (i<5)
        	for (j=0;j<32;j++)
       		{
            	q=st>>(i-1);
       			r=(1<<(5-i))-1;
       			if ((j&r)==q)
       			{
           			w1=(j<<1)&31;w2=w1+1;
           			F[i][j]=Max(F[i-1][w1],F[i-1][w2])+num[i][j];
       			}
       			else F[i][j]=0;
       		}
        else if(i+3<N)
        	for (j=0;j<32;j++)
        	{
        		w1=(j<<1)&31;w2=w1+1;
            	F[i][j]=Max(F[i-1][w1],F[i-1][w2])+num[i][j];
        	}
        else
        {
            q=st&((1<<(i+4-N))-1);
            for (j=0;j<32;j++)
            {
            	if ((j>>(N-i+1))==q)
            	{
            		w1=(j<<1)&31;w2=w1+1;
                	F[i][j]=Max(F[i-1][w1],F[i-1][w2])+num[i][j];
            	}
            	else F[i][j]=0;
            }
        }
     }
     for (j=0;j<32;j++)
     	if (ans<F[N][j]) ans=F[N][j];
}

void Solve()
{
     for (int st=0;st<16;st++)DP(st);
     printf("%d\n",ans);
}

int main()
{
     Init();
     Solve();
     return 0;
}
```

---

## 作者：青珹 (赞：29)

比较费脑子的一道题

先说题目核心思想 ： 状压dp

环的处理我们先不管。

我们设 **dp[j][s]** 表示 到达动物 j 且 [ j , j+5) 这五个动物状态为s时 最多能使多少小朋友开心。

其中，s为 0~31 的整数，二进制下的s表示[ j , j+5) 这五个动物状态，0表示不选，1表示选，特别注意，[ j , j+5) 分别对应s从**右往左数**的每个数字，例如s = 18 ，二进制下表示为10010 ，即 j 到 j+4 的状态为 0 , 1 , 0 , 0 , 1。

可得状态转移方程：**dp[j][s] = min( dp[j-1][(s&15)<<1] , dp[j-1][(s&15)<<1|1] ) + num[j][s]**;

解释：15 的二进制为01111，(s&15) 即取 [ j , j+5) 的前 4 个数的状态。然后 <<1 代表作为 [j-1 , j+4)的后四个状态，对j-1的状态枚举一下是0还是1，取个min，再加上num[j][s]就行了

num[j][s]为已经预处理出来的数组,它的意思为:

状态为s时，某几个视野为[j , j+5)的小朋友中高兴地人数

还是有点懵？没事，将上面的解释结合下图来看：

```cpp
当前 j=3 , s=18 (10010) , s&5=2 (0010)
动物:             1    2    3    4    5    6    7    8    9    10
下标:                 j-1   j   j+1  j+2  j+3  j+4
s状态:                      0    1    0    0    1
(s&5)为:                    0    1    0    0
(s&5)>>1状态:          0    0    1    0    0
(s&5)>>1|1状态:        1    0    1    0    0
```


这样就比较好理解了。

**num的预处理**

可随读入一起处理：

```cpp
for(int i=1;i<=m;i++){
        int E=read(),F=read(),L=read(),fear=0,like=0;
        for(int j=1;j<=F;j++){
            int x=read() ;
            x=(x-E+n)%n;
            fear|=(1<<x);//fear表示这五个围栏中这个小朋友害怕的动物的状态 
        }
        for(int j=1;j<=L;j++){
            int x=read();
            x=(x-E+n)%n;
            like|=(1<<x);//like表示这五个围栏中这个小朋友喜欢的动物的状态 
        }
        for(int j=0;j<32;j++)//0-> 拿走 1->留下 
            if((fear&~j)||(like&j))
                num[E][j]++;
    }
```


较难理解的几点：
1.x = (x-E+n)%n，fear |= (1<<x)

	这个为环的处理，手推几个式子就能得出

2.(fear&~j)||(like&j)

看题目条件：

      - 至少有一个他害怕的动物被移走
      - 至少有一个他喜欢的动物没被移走

 

这里留给读者自行思考，不再解释( '~'符号为取反，即0变1,1变0)

然后就是最后dp环的处理：

可以枚举开始的状态 ，设开始0的状态为 i,1从0推过来 则最后的状态**只有** dp[n][i] 对答案有效，强制和开始的状态一样

OK结束，代码：

```cpp
#include <algorithm>
#include <iostream>
#include <cstring>
#include <cstdio>
#include <cmath>
using namespace std;
int n,m,ans;
int num[50005][35];
int dp[10005][35];
inline int read(){
    int x=0;
    char ch=getchar();
    while(ch<'0'||ch>'9')
        ch=getchar();
    while(ch>='0'&&ch<='9'){
        x=(x<<1)+(x<<3)+(ch^48);
        ch=getchar();
    }
    return x;
}
int main(){
    n=read(),m=read();
    for(int i=1;i<=m;i++){
        int E=read(),F=read(),L=read(),fear=0,like=0;
        for(int j=1;j<=F;j++){
            int x=read() ;
            x=(x-E+n)%n;
            fear|=(1<<x);
        }
        for(int j=1;j<=L;j++){
            int x=read();
            x=(x-E+n)%n;
            like|=(1<<x);
        }
        for(int j=0;j<32;j++)//0-> 拿走 1->留下 
            if((fear&~j)||(like&j))
                num[E][j]++;
    }
    for(int i=1;i<=n;i++){
        for(int j=0;j<32;j++){
            cout<<num[i][j]<<" ";
        }
        cout<<endl;
    }
    for(int i=0;i<32;i++){
        memset(dp[0],128,sizeof(dp[0]));
        dp[0][i]=0;
        for(int j=1;j<=n;j++)
          for(int s=0;s<32;s++)
            dp[j][s]=max(dp[j-1][(s&15)<<1],dp[j-1][(s&15)<<1|1])+num[j][s];
        if(ans<dp[n][i])//开始状态为 i 结尾状态也得是i才能更新ans 
          ans=dp[n][i];
    }
    cout<<ans;
    return 0;
}
```


---

## 作者：asuldb (赞：8)

我好$sb$啊，把$>>$打成$<<$结果就写了两节课

那个一个人只能看到五个动物显然很鬼畜

那我们就可以压这一维了

$dp[i][s]$表示从第$i$个位置往后数五个位置的状态是$s$时最多能有几个小朋友开心($0$表示移走，$1$表示保留)

之后我们处理处每一个人的喜欢和害怕的状态，往下转移就好了

还有这是一个环，感觉非常不好处理的样子

我们可以枚举第一个位置之后的状态是什么，最后的位置必须和第一个位置吻合就好了

复杂度$O(4^5n)$

代码

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#define re register
#define max(a,b) ((a)>(b)?(a):(b))
#define maxn 50005
int dp[10005][33];
int S[maxn],F[maxn],L[maxn];
int ans=0;
inline int read()
{
    char c=getchar();
    int x=0;
    while(c<'0'||c>'9') c=getchar();
    while(c>='0'&&c<='9')
        x=(x<<3)+(x<<1)+c-48,c=getchar();
    return x;
}
int n,m,now;
int main()
{
    n=read(),m=read();
    int t1,t2;
    for(re int i=1;i<=m;i++)
    {
        S[i]=read();
        t1=read(),t2=read();
        int x;
        F[i]=31;
        for(re int j=1;j<=t1;j++)
        {
            x=read()-S[i];
            if(x<0) x+=n;
            F[i]^=(1<<x);
        }
        for(re int j=1;j<=t2;j++)
        {
            x=read()-S[i];
            if(x<0) x+=n;
            L[i]|=(1<<x);
        }
    }
    for(re int s=0;s<=31;s++)
    {
        memset(dp,-20,sizeof(dp));
        now=1;
        for(re int i=0;i<=31;i++) dp[1][i]=-21232;
        dp[1][s]=0;
        while(S[now]==1) 
        {
            if((L[now]&s)||((F[now]|s)!=31)) dp[1][s]++;
            now++;
        }
        for(re int i=1;i<n;i++)
        {
            for(re int j=0;j<=31;j++)
            {
                dp[i+1][(j>>1)|(1<<4)]=max(dp[i][j],dp[i+1][(j>>1)|(1<<4)]);
                dp[i+1][j>>1]=max(dp[i][j],dp[i+1][j>>1]);
            }
            while(S[now]==i+1)
            {
                for(re int j=0;j<=31;j++)
                    if((L[now]&j)||((F[now]|j)!=31)) dp[i+1][j]++;
                now++;
            }
        }
        int t=s;
        t^=(1<<4);
        if(t>s) t-=(1<<4);
        for(re int i=0;i<=31;i++)
            if((i>>1)==t) ans=max(ans,dp[n][i]);
    }
    std::cout<<ans;
    return 0;
}
```

---

## 作者：chenzida (赞：6)

**题目大意**：一个环上包含 $n$ 个点，有 $c$ 个人要去看，每个人都有一个站的位置。假设 $ta$ 站在位置 $x$,则 $ta$ 只能看到区间 $[x,x+4]$，这 $5$ 个位置的点。每个人都有喜欢的和讨厌的点，一个人开心当且仅当一个 $ta$ 喜欢的点没有被移走或者一个 $ta$ 讨厌的点被移走了，求怎么设计移走点能使开心的人数最多，输出这个人数。

~~我也是看了题目标签才会做的。~~

**思路解析**：这道题因为只有每个人只能看到 $5$ 个点，而这些极小的常数往往就是突破的关键。所以我们考虑来状压这个值，其中数码 $0$ 表示不移走， $1$ 表示移走，然后我们考虑一下怎么 $dp$。还是 $dp$ 四步走。

$dp$ 状态：$dp[i][st]$ 表示从第 $i$ 个位置开始，之后 $5$ 个的状态压缩完是 $st$ 时，在前 $i$ 个位置上的小朋友最多有几个开心的。

$dp$ 初值：$dp[i][st]=-inf(1\leq i\leq n,0\leq st\leq 31)$

但是当到转移时就会遇到一点困难，那就是如果要取一个 $5$ 为 $2$ 进制数的前四位会有些麻烦，所以我们就将这个状态反着存，这样取前 $4$ 位就变成了取后四位，直接 $st \And 15$ 即可。

所以 $dp$ 转移就是这样：

$dp[i][st]=max(dp[i-1][(st \And 15)<<1],dp[i-1][(st\And 15)<<1|1])+cal(i,st)$。

其中 $cal(i,st)$ 表示第 $[i,i+4]$ 位的状压值为 $st$。但是这个要怎么求呢？可以在 $dp$ 之前就初始化好，即输入每个人的数据的时候就将它算出来。设这个人的位置为 $a$,喜欢的点状压完是 $st1$，讨厌的点状压完是 $st2$,并且当前枚举到的状态为 $st$，则公式为：

$f[a][st]+=((st1\And (st\ xor\ 15)) || (st2\And st));$

其中 $st\ xor\ 15$ 的效果和对 $st$ 按位取反效果一样，只是按位取反符号不好打。

公式解释：其中 $(st1\And (st\ xor\ 15))$ 表示是否有这个人喜欢的点没有被移走，而 $(st2\And st))$ 则表示是否有这个人不喜欢的被移走了，而这两个如果满足其 $1$，这个人就会很开心。所以就将 $f[a][st]$ 加上这个值就行了。

最后时间复杂度 $O(2^{10}\times n)$，是能过掉这道题的。

代码如下：

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
using namespace std;
const int NR=1e5+10;
const int MR=(1<<6)+1;
int n,m;
int dp[NR][MR];
int f[NR][MR];
int ans;
int read()
{
	int x=0,f=1;char ch=getchar();
	while(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}
	while(ch<='9'&&ch>='0'){x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}
	return x*f;
}
int main()
{
    n=read(),m=read();
    for(int i=1;i<=m;i++)
    {
        int a=read(),b=read(),c=read();
        int st1=0,st2=0;
        for(int j=1;j<=b;j++)
        {
            int x=read();
            x=(x-a+n)%n;
            st1|=(1<<x);
        }
        for(int j=1;j<=c;j++)
        {
            int x=read();
            x=(x-a+n)%n;
            st2|=(1<<x);
        }
        for(int st=0;st<=31;st++)
        {
        	f[a][st]+=((st1&(st^31))||(st2&st));
		}
    }
    for(int st1=0;st1<=31;st1++)
    {
        memset(dp,-999999,sizeof(dp));
        dp[0][st1]=0;
        for(int i=1;i<=n;i++)
        {
        	for(int st=0;st<=31;st++)
        	{
        		dp[i][st]=max(dp[i-1][(st&15)<<1],dp[i-1][(st&15)<<1|1])+f[i][st];
			}
		}
        ans=max(ans,dp[n][st1]);
    }
    printf("%d",ans);
    return 0;
}
```

---

## 作者：SSHhh (赞：4)

首先，仔细观察题面就会发现，数据范围略微偏小。

然后再仔细的观察一下就会发现一个关键性的问题，不难发现 "每个小朋友只能看到五个动物"。这就应该是本题的切入点。

我们先考虑一下如果拆环成链该怎么做。

那么很显然，我们用 $dp[i][S]$来表示当前考虑到了第 $i$ 个位置，$[i-4,i]$ 这段区间的移除情况是 $S$ 的最大答案，$ dp[i][S]=max(dp[i-1][S>>1],dp[i-1][S>>1|(1<<4)])+sum[i][S]$ *（其实就是枚举之前的第一个位置移还是不移）* 这个预处理的 $sum[i][S]$ 表示当第 $i$ 个位置前的移除情况是 $S$ 时能使多少个小朋友高兴。

那么我们把这个环拼好后又该怎么做呢？

注意 ${(2^5)}^2\times 1e4$ 的复杂度也是可以过的，所以我们可以枚举前五个（0~4）的状态，然后暴力往后转移，最后统计答案最大值就行了。不过注意一点，因为你枚举了前五位的状态，所以当你的转移顺着环回来时，最后五位（$n$ ~ $n+4$）的答案应该是和前四位相同的。因为前四位的所有 $S$ 中，只有你枚举的那个是有意义的，所以在统计答案时只需统计 $dp[n+4][S]$ 即可。

下面附上代码：

```cpp
#include<iostream>
#include<string.h>
using namespace std;
int n,m,ans,sum[10005][32],dp[10005][32];
const int INF=214783647,lim=(1<<5);
int main()
{
	cin>>n>>m;
	for(int i=1;i<=m;i++)
	{
		int x,a,b,p,q,tmp;
		cin>>x>>a>>b,p=q=0;
		for(int i=1;i<=a;i++)
			cin>>tmp,p|=(1<<((4-tmp+x+n)%n));
		for(int i=1;i<=b;i++)
			cin>>tmp,q|=(1<<((4-tmp+x+n)%n));
		for(int S=0;S<lim;S++)
			if((S&p)||(~S&q)) sum[(x+3)%n+1][S]++;
	}
	memset(dp,-12,sizeof(dp));
	for(int i=n+1;i<=n+4;i++)
		for(int S=0;S<lim;S++)
			sum[i][S]=sum[i-n][S];
	for(int lS=0;lS<lim;lS++)
	{
		for(int i=0;i<lim;i++)
			dp[4][i]=-INF;
		dp[4][lS]=0;
		for(int i=5;i<=n+4;i++)
			for(int S=0;S<lim;S++)
				dp[i][S]=max(dp[i-1][S>>1],dp[i-1][(S>>1)|16])+sum[i][S];
		ans=max(ans,dp[n+4][lS]);
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：Newuser (赞：4)

## 思路

考虑f[i][s]表示i位置状态为s时的最多小朋友开心数（s用状压表示，0被移走，1没被移走）。
## 解法

这里对于每个小朋友只能看到相邻的五个动物，对于每个位置我们可以改变移不移走开不开心的状态量很小，我们考虑状压DP。

先直接搞出一个数组g[i][s]，表示在i这个位置设置看到的5个动物是否移走的状态下（s用状压表示，0被移走，1没被移走）可以使得该位置多少个小朋友开心，

考虑f[i][s]表示i位置状态为s时的最多小朋友开心数，我们首先枚举对于1的前四个（对于n的后四个），然后之后根据f[i-1]一直搞dp，决策往上第5个（不会对目前状态影响）移不移 方程f[i][s] = max( f[i-1][(s&15)<<1] , f[i-1][(s&15)<<1|1] +g[i][s]，这里的s&15是找的对于现在状态的后四个对于上一个状态的前四个。

我们设定初始设定得那四个为S，最后ans在f[n][S<<1|1]和f[n][S<<1]里面找。

就这样搞定啦！
//欢迎来蒟蒻博客看看[Newuser小站动物园](http://www.newuser.top/2018/06/01/%e3%80%90apio-ctsc2007%e5%8a%a8%e7%89%a9%e5%9b%ad%e3%80%91%e7%8a%b6%e5%8e%8bdp/)

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,c;
const int S = 31;
const int maxn  = 10005;
int hh[maxn][S+3]; 
int f[maxn][S+3];
int main()
{
    scanf("%d%d",&n,&c);
    for(int i=1;i<=c;i++)
    {
        int e,f,l;
        scanf("%d%d%d",&e,&f,&l);
        int hp=0,xh=0;
        for(int j=1;j<=f;j++)
        {
            int x;
            scanf("%d",&x);
            x=(x-e+n)%n;
            hp|=(1<<x);
        }
        for(int j=1;j<=l;j++)
        {
            int x;
            scanf("%d",&x);
            x=(x-e+n)%n;
            xh|=(1<<x);
        }
        for(int j=0;j<=S;j++)
        {
            if( (xh&j)||( (S^j)&hp ) )
            {
                hh[e][j]++;
            }
        }
    }
    int ans=0;
    for(int s=0;s<16;s++)
    {
        for(int i=0;i<=S;i++) f[0][i]=-0x3f3f3f3f;
        f[0][s<<1]=f[0][s<<1|1]=0;
        for(int i=1;i<=n;i++)
        {
            for(int j=0;j<=S;j++) 
            {
                f[i][j] = max( f[i-1][(j&15)<<1],f[i-1][(j&15)<<1|1] ) + hh[i][j];
            }
        }
        ans = max( ans,max(f[n][s<<1],f[n][s<<1|1]) );
    }
    printf("%d",ans);
}
```

---

## 作者：Fearliciz (赞：2)

本篇题解与其他题解的主要区别在于：详细解释了为什么数组赋初值的时候要赋特别小，如果发现自己WA了几个点可以来看一下本篇题解。（思路了解的同学可以直接跳到关于赋初值的部分）

了解题意后，可以发现最多有 $10^4$ 个动物，那么想压动物是否被移走是显然会炸的，当然压小朋友更不可能，可是发现每位小朋友只能看到连续的五个动物，而这样只需要 32 的空间，是行得通的。

对此我们令 $f_{j,s}$ 表示对于前 $j$ 个动物，目前算到第 $j$ 个（起始位置），的移走状态为 $s$ 的最大高兴的小朋友数量。

可是单独只用这一个转移数组做起来会很费劲，那我们便再建一个数组 $w$ 存储在区间 $\left [ i,i+4 \right ] $ 的动物移走状态为 $s$ 高兴的小朋友的数量（因为此区间而高兴）

预处理代码：

```cpp
cin >> n >> c;
for(int i = 1; i <= c; i++)
{
	fear = 0, love = 0;
	cin >> e >> F >> l;
	for(int j = 1; j <= F; j++)
	{
		cin >> x; 
		x = (x - e + n) % n;
		fear |= (1 << x);
	}
	for(int j = 1; j <= l; j++)
	{
		cin >> x;
		x = (x - e + n) % n;
		love |= (1 << x);
	}
	for(int j = 0; j < 32; j++) //00000 - 11111 表示动物是否被移走
		if((j & fear) || (~j & love))
			w[e][j]++;
}
```

有了这个数组，转移就很明显了，直接套用状压转移套路即可：

$$
f_{j,s}=\max(f_{j-1,(s\&15)<<1},f_{j-1,(s\&15)<<1|1})+w_{j,s}
$$

```cpp
int ans = 0;
for(int i = 0; i < 32; i++)
{
	memset(f[0], -0x3f, sizeof f[0]); 
	f[0][i] = 0;
	for(int j = 1; j <= n; j++)
		for(int s = 0; s < 32; s++)
			f[j][s] = max(f[j - 1][(s & 15) << 1], f[j - 1][(s & 15) << 1 | 1]) + w[j][s];
	ans = max(ans, f[n][i]);
}
cout << ans;
```

以上就是本题思路，接下来讲解：

	memset(f[0], -0x3f, sizeof f[0]); 

虽然本题的转移中没有进行任何的相减操作，不过还是要把数组赋得特别小，有可能有人认为是溢出，不过如果担心溢出，为什么不去开更大的数组而是去干一件不一定起作用的事？

不是溢出的问题，还能想到的是错解的问题，请大家思考这样的一种可能：

我们假设赋出的值是 -1。

（注：为了更好体现状态，将 $s$ 转为二进制形式）

显然 $f[0][00000]$ 无法转移到 $f[1][00111]$。

所以 $f[1][00111]$ 就会保持在 -1。

可是由于 $f[2][01111]$ 可以从 $f[1][00111]$ 转移到，且 $w[2][01111]$ 等于 4，那么 $f[2][01111]$ 的值就变成了 3，也就是一个 “可行的解”。

这就是一个典型的例子，后面转移用的是前面的错解，导致了一系列的错误。

总结：考虑转移初始值的时候一定要考虑到错误的转移怎么避免，如果想得不是很明白，可以全部开最小值或最大值减少错误的可能性。

---

## 作者：2018LZY (赞：2)

[题目](https://www.luogu.com.cn/problem/P3622)
 
[**更好的阅读体验**](https://blog.csdn.net/qq_42886072/article/details/106692142)

显然环是比较难处理的,我们不妨把环断成链,然后先忽略掉所有从n跑到1的情况.

那么很容易定义出这样的状态$f[i][j]$表示前$i$个位置最后4个位置的删除状态为$j$(状态压缩)的最大方案数,然后每扫过一个人观测范围的终点就统计一下:

$\begin{cases} f[i][(j\& 7)*2]=\max(f[i-1][j]+calc(i,j*2)\\ f[i][(j\& 7)*2+1]=\max(f[i-1][j]+calc(i,j*2+1))\end{cases}$

解释一下:上面状态压缩是赋予远端更大的2的次幂权重,$calc(x,y)$表示终点为$x$状态为$y$的可满足人数.



把环接上的话,我们就需要记录一下初始前4个位的状态,代码中定义$f[i][j][k]$表示前$i$个位置 $[1,4]$的状态为$j$,最后4为为$k$的方案.

特别的,最后我们应该加上跨过$(n,1)$的人数.



```cpp
完整代码看上述连接
const int N=1e4+10,M=5e4+10;

int n,m,f[N][16][16];
struct edge{int x,y,next;}a[M]; //x表示不喜欢的集合,y表示喜欢的集合 
int len,last[N];

void ins(int x,int u,int v) {
	a[++len]=(edge){u,v,last[x]};
	last[x]=len;
}

int calc(int x,ui y) {
	int s=0;
	for(int k=last[x];k;k=a[k].next) {
		ui u=a[k].x,v=a[k].y;
		if((y&u)||((~y)&v)) s++;
	}
	return s;
}

void upd(int &x,int y) {if(x<y) x=y;}

int g(int t) {
	int s=0;
	for(int i=1;i<=4;i++) {
		int y=t>>(4-i)&31;
		s+=calc(i,y);
	}
	return s;
}

int main() {
	qr(n); qr(m);
	memset(f[4],-63,sizeof f[4]);
	for(int i=0;i<16;i++) 
		f[4][i][i]=0;
	while(m--) {
		int x=0,y=0,i,j,u,v;
		qr(i); qr(u); qr(v);
		while(u--) qr(j),x|=1<<(4-(j>=i?j-i:j-i+n));
		while(v--) qr(j),y|=1<<(4-(j>=i?j-i:j-i+n));
		if(i+4>n) ins(i+4-n,x,y);
		else ins(i+4,x,y);
	}
	for(int i=5;i<=n;i++) 
		for(int k=0;k<16;k++) {//i前4个位置的状态 
			int a=calc(i,k*2),b=calc(i,k*2+1);//O(32m)
			for(int j=0;j<16;j++) {//[1,4]的状态 
				upd(f[i][j][(k&7)*2],f[i-1][j][k]+a);
				upd(f[i][j][(k&7)*2+1],f[i-1][j][k]+b);//O(256n)
			}
		}
	int ans=0;
	for(int j=0;j<16;j++)
		for(int k=0;k<16;k++) 
			upd(ans,f[n][j][k]+g(k*16|j));
	pr2(ans);
	return 0;
}


```



---

## 作者：Polaris_Dane (赞：2)

状态压缩是一个非常实用的工具

通过将一种状态（只包括$0$和$1$）压缩为一个二进制数

易于处理查询（当然如果你愿意，你也可以用三进制表示更复杂的状态）

首先我们看看这道题的题目

非常明显，是DP题（因为贪心肯定是错的）

那么我们考虑转移时需要用到的状态

第一我们需要知道现在到了哪一个围栏

第二我们需要知道前一个围栏向后数5位的每一个围栏中的动物是否被搬走了

那么很明显，这并不好表示

而五这个数字很明显很小

可以用来状压

我们用一个二进制数来表示连续五个围栏中动物的状态

那么每次转移时，我们会考虑下一个围栏，我们只需要上一个状态的后四位状态

所以我们有这样的一个方程

```cpp
dp[i][j]=max(dp[i-1][(j&15)<<1],dp[i-1][(j&15)<<1|1])+num[i][j];
```

&15是为了取状态的后$4$位进行转移

我们还要预处理出每一个围栏不同状态会使多少小朋友开心

~~这个非常简单~~

还有一个点就是（即我挂在哪了）

由于动物园是环形的

所以你初始状态与最后一个围栏的状态必须相同，即是$s[0]$必须与$s[n]$相同

所以DP的流程如下

```cpp
	for (int s=0;s<1<<5;s++){
		memset(dp[0],128,sizeof(dp[0]));dp[0][s]=0;
		for (int i=1;i<=n;i++)
			for (int j=0;j<1<<5;j++)
				dp[i][j]=max(dp[i-1][(j&15)<<1],dp[i-1][(j&15)<<1|1])+num[i][j];
		ans=max(ans,dp[n][s]);
	}
```
$Talk$ $is$ $cheap$,$show$ $you$ $the$ $code$

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<cstring>
#include<cstdlib>
#include<cctype>
#include<set>
#include<queue>
#define M 51000
#define inf 0x3f3f3f3f
#define LL long long
const int mod=988244353;
using namespace std;
inline int read(){
	int f=1,x=0;char s=getchar();
	while (!isdigit(s)){if(s=='-')f=-1;s=getchar();}
	while (isdigit(s)){x=(x<<1)+(x<<3)+(s^48),s=getchar();}
	return x*f;
}
int n,c,num[M][(1<<5)+1],dp[M][(1<<5)+1],ans;
signed main(void){
	n=read(),c=read();
	for (int i=1;i<=c;i++){
		int fear=0,like=0;
		int e=read(),f=read(),l=read();
		for (int j=1;j<=f;j++){
			int x=read();
			x=(x-e+n)%n;
			fear|=1<<x;
		}
		for (int j=1;j<=l;j++){
			int x=read();
			x=(x-e+n)%n;;
			like|=1<<x;
		}
		for (int j=0;j<1<<5;j++){
			if ((j&fear)||(~j&like)) num[e][j]++;
		}
	}
	for (int s=0;s<1<<5;s++){
		memset(dp[0],128,sizeof(dp[0]));dp[0][s]=0;
		for (int i=1;i<=n;i++)
			for (int j=0;j<1<<5;j++)
				dp[i][j]=max(dp[i-1][(j&15)<<1],dp[i-1][(j&15)<<1|1])+num[i][j];
		ans=max(ans,dp[n][s]);
	}
	printf("%d",ans);
	return 0;
}
 
```


---

## 作者：xh39 (赞：2)

我们发现n的数据范围很大,无法进行状态压缩(还没等你MLE,你先TLE了)。于是我们要寻找突破口。

仔细观看题目,发现了这样一句话

> 每个小朋友站在大围栏圈的外面，可以看到连续的 5 个围栏。

这个连续的5个围栏,就可以作为突破口。

对这5个围栏进行状态压缩。具体解释在代码里。
```cpp
#include<iostream>
using namespace std;
int w[100005][155],zyl[100005][155]; //w表示权值,即移走或不移走这5个动物获得的贡献。用状态压缩表示5个动物的状态。
int main(){
	int n,c,i,j,k,e,f,l,x,y,like,hate,Max=0; //like表示喜欢的状态压缩,hate表示害怕的状态压缩。
	cin>>n>>c;
	for(i=0;i<c;++i){
		cin>>e>>f>>l;
		like=hate=0;
		for(j=0;j<f;++j){
			cin>>x;
			if(x<e){
				x+=n;
			}
			like=(like|(1<<x-e))&31; //或运算可以写成加法,但或运算更快。&31时过滤掉超出5个围栏的动物。
		}
		for(j=0;j<l;++j){
			cin>>y;
			if(y<e){
				y+=n;
			}
			hate=(hate|(1<<y-e))&31; //注释同计算like。
		}
		for(j=0;j<32;++j){
			w[e][j]+=(bool)((j&hate)||((~j)&like)); //移走了他害怕的或没移走他喜欢的。
		}
	}
	for(k=0;k<32;++k){
		for(i=0;i<32;++i){
			zyl[0][i]=-2147483647; //一开始初始化为极小值。-2147483647=-(2³¹-1) 即int的下限。
		}
		zyl[0][k]=0;
		for(i=1;i<=n;++i){
			for(j=0;j<32;++j){
				zyl[i][j]=max(zyl[i-1][(j&15)<<1],zyl[i-1][((j&15)<<1)|1])+w[i][j]; //这是dp的状态转移方程。左移时避免影响结果,先舍去第一位。左移后枚举选不选当前这个。
			}
		}
		Max=max(Max,zyl[n][k]); //取最大值。
	}
	cout<<Max;
	return 0;
}
```

---

## 作者：_sry (赞：2)

发现每个小朋友最多只能看到$5$个动物所以考虑状压$dp$。我们定义$f(i,j)$为第$i$个位置从此往后$5$个人的最喜欢数量。所以只要预处理出对于每个点从后$5$个会让多少小朋友高兴即可
```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
inline int read(){
    int f=1,ans=0;char c=getchar();
    while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
    while(c>='0'&&c<='9'){ans=ans*10+c-'0';c=getchar();}
    return f*ans;
}
const int N=50001;
const int M=50001;
int n,m,cal[M][33],f[N][33];
int maxn;
int main(){
    n=read(),m=read();
    for(int i=1;i<=m;i++){
        int s=read(),seccnt=read(),hapcnt=read();
        int hap=0,sec=0;
        for(int j=1;j<=seccnt;j++){
            int x=read();x=((x-s)%n+n)%n;
            sec|=(1<<(x));
        }
        for(int j=1;j<=hapcnt;j++){
            int x=read();x=((x-s)%n+n)%n;
            hap|=(1<<(x));
        }
        for(int j=0;j<32;j++)
            if((j&hap)||((sec&j)!=sec)) {
                cal[s][j]++;
            }
    }
    for(int i=0;i<32;i++){
        memset(f,-127/3,sizeof(f));
        f[0][i]=0;
        for(int j=1;j<=n;j++){
            for(int z=0;z<32;z++) f[j][z]=max(f[j-1][(z&15)<<1],f[j-1][((z&15)<<1)|1])+cal[j][z];
        }
        maxn=max(maxn,f[n][i]);
    }
    cout<<maxn;
}
```

---

## 作者：lgswdn_SA (赞：1)

观察数据范围发现一个人看到的东西其实是一个数量很少的区间 （$5$） 个，而且还涉及到取还是不取，所以我们状压这 $5$ 位。

状态稍微尝试下可得 $f(i,s)$ 表示截止到第 $i$ 个动物且区间 $[i,i+4]$ 的去留状态是 $s$ 的最大满意数。决策为枚举 $i-1$ 取不取。

我们怎么从这 $5$ 位的状态 $s$ 求出前面 $5$ 位呢？

我们假设这 $5$ 位是 ```abcde``` 【注意：状压中的状态是**倒序存储**的！】

首先我们需要取出后 $4$ 位 ```abcd``` （位运算操作是 ```s&15```）。

然后左移一下 ```abcd0``` 就是我们要求的啦。



$$
f(i,s)=\max \big(f(i-1,(s\&15)<<1),f(i-1,((s\& 15)<<1)|1\big)+w(i,s)
$$

其中 $w(i,s)$ 代表这个状态本身可以获得的收益（即开心的小朋友数）。注意为了避免重复计算，$w(i,s)$ 有小朋友开心当且仅当 $i=$ 小朋友的 $E$ 且这个小朋友在这个状态下是开心的。

对于 $w$ 怎么计算，我们可以分 $3$ 个步骤：将小朋友害怕的状压，将小朋友喜欢的状压，最后求每个 $s$ 可不可以让小朋友开心。我们看下代码。


```cpp
rep(i,1,c) {
	int e,f,l; scanf("%d%d%d",&e,&f,&l);
	int fears=0,likes=0;
	rep(j,1,f) { //Step1
		int x; scanf("%d",&x);
		x-=e; x++; if(x<0) x+=n;
		fears|=msk(x);
	}
	rep(j,1,l) { //Step2
		int x; scanf("%d",&x);
		x-=e; x++; if(x<0) x+=n;
		likes|=msk(x);
	}
	rep(s,0,full(5)) //Step3
		w[e][s]+=((~s)&fears||s&likes);
}
```
Step1，2 非常易懂。Step 3 中对 $s$ 取反的操作相当于找出我们移掉哪些动物。


最后其实这题还有个坑点，就是它是环状动物园，所以最后一个状态必须等于第 $0$ 个状态（比 $i=1$ 前面的状态）。怎么处理呢？**暴力处理**。暴力枚举第 $0$ 个状态。

```cpp
#include<bits/stdc++.h>
#define full(i) ((1<<i)-1)
#define msk(i) (1<<i-1)
#define rep(i,a,b) for(register int i=(a);i<=(b);i++)
using namespace std;
const int N=5e4+9,S=66;

int n,c,w[N][S],f[N][S],ans;

void pr(int s) {
	rep(i,1,5) cout<<(bool)(s&msk(i));
}

int main() {
	scanf("%d%d",&n,&c);
	rep(i,1,c) {
		int e,f,l; scanf("%d%d%d",&e,&f,&l);
		int fears=0,likes=0;
		rep(j,1,f) {
			int x; scanf("%d",&x);
			x-=e; x++; if(x<0) x+=n;
			fears|=msk(x);
		}
		rep(j,1,l) {
			int x; scanf("%d",&x);
			x-=e; x++; if(x<0) x+=n;
			likes|=msk(x);
		}
		rep(s,0,full(5))
			w[e][s]+=((~s)&fears||s&likes);
	}
	rep(t,0,full(5)) {
		memset(f,128,sizeof(f)); f[0][t]=0;
		rep(i,1,n) rep(s,0,full(5))
			f[i][s]=max(f[i-1][(s&15)<<1],f[i-1][((s&15)<<1)|1])+w[i][s];
		ans=max(ans,f[n][t]);
	}
	printf("%d",ans);
	return 0;
}
```

一般来说，遇到这种有比较奇特的数据范围的东西，要么暴力（详见 [NOI2017]游戏 ）要么状压（详见此题）要么直接手动写进状态或者分类讨论。状压还是非常吼的啊~

---


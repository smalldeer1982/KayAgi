# [HAOI2016] 字符合并

## 题目描述

有一个长度为 $n$ 的 $01$ 串，你可以每次将相邻的 $k$ 个字符合并，得到一个新的字符并获得一定分数。

得到的新字符和分数由这 $k$ 个字符确定。你需要求出你能获得的最大分数。


## 说明/提示

#### 数据规模与约定

对于 $100\%$ 的数据，保证：

- $1\leq n\leq 300$，$1 \lt k \leq 8$。
- $c_i\in\{0,1\}$，$1 \leq w_i \leq 10^9$。

## 样例 #1

### 输入

```
3 2
1 0 1
1 10
1 10
0 20
1 30
```

### 输出

```
40```

# 题解

## 作者：zxTLE (赞：38)

这道题我觉得真实难度应该在省选/NOI-以下。

主要思路为区间dp+状压dp

由题目的k<=8考虑使用状态压缩。

为了得到最大的分数我们应该尽量合并数字到不能合并为止，于是最终得到的01串中的每一个数字 展开（还原后）是一系列不相交的区间，我们考虑用区间dp的思维来转移状态。

我们用f[ i ][ j ][ t ]表示原串中第i到j个数字最终合并成t的状态的最大分数。

我们枚举中间的断点mid，（i<=mid<=j）,上文已证区间不相交，于是不妨使mid右边的子串合并成t的最后一位数字，mid左边的合并成其他位的数字。
因为能合并成1位数字的原串长度可以为1，k，2k-1......，所以我们每次将mid的值改变k-1即可。

另有一种特殊情况，即i到j恰好有k位数字，我们直接把它合并一次。用一个辅助数组存储最大值（直接修改f数组可能会导致修改后的数能够再修改其他数组元素，具体看代码理解一下）。

最后的答案就是f[ 1 ][ n ][所有状态]中的最大值啦。
由于wi的值可能很大，所以记得使用long long。

附代码：

```cpp
#include<bits/stdc++.h>
#define N 310
#define K 8
#define inf (ll)1<<60
#define ll long long
using namespace std;

ll n,k,a[N],c[1<<K],w[1<<K],f[N][N][1<<K];
 
int main()
{
	scanf("%lld%lld",&n,&k);
	for (ll i=1;i<=n;i++) scanf("%1lld",&a[i]);
	for (ll i=0;i<(1<<k);i++) scanf("%lld%lld",&c[i],&w[i]);
	for (ll i=1;i<=n;i++)
	 for (ll j=1;j<=n;j++)
	  for (ll z=0;z<(1<<k);z++)
	  f[i][j][z]=-inf;
    //读入及初始化 
    for (ll i=n;i>=1;i--)
      for (ll j=i;j<=n;j++)    
      //注意循环的正逆顺序，因为mid比j小，j正序枚举；mid比i大，i倒序枚举
	  //(使状态转移时f[i][mid-1][..],f[mid][j][..]的值已被处理好) 
      { 
        if (i==j) { f[i][j][a[i]]=0;continue;}
        ll len=j-i;
        len%=k-1; if (!len) len=k-1;
        for (ll mid=j;mid>i;mid-=k-1)
        for (ll op=0;op<(1<<(len));op++)
        { f[i][j][op<<1]=max(f[i][j][op<<1],f[i][mid-1][op]+f[mid][j][0]);
          f[i][j][op<<1|1]=max(f[i][j][op<<1|1],f[i][mid-1][op]+f[mid][j][1]);
            
		}
		if (len==k-1) 
		{
			ll g[2];
			g[0]=g[1]=-inf;
			for (ll op=0;op<(1<<k);op++)
			g[c[op]]=max(g[c[op]],f[i][j][op]+w[op]);
			f[i][j][0]=g[0];f[i][j][1]=g[1];
		}
	  }
	  ll ans=-inf;
	  for (ll i=0;i<(1<<k);i++) ans=max(ans,f[1][n][i]);
	  printf("%lld",ans);
}
```

---

## 作者：tommymio (赞：19)

这题提供了一种状压DP的 **idea**，状态压缩可以和其他DP方式共同使用来记录一种状态.

我们发现这题的 $k$ 极其的小，$2 \leq k \leq 8$，这么小的数据范围肯定考虑状压DP.

我们同时发现，为了使答案最大，合并的区间之间必然不相交，那我们就可以掏出区间DP.

这题我们大概就有了一个想法，设 $f_{l,r,S}$ 为 $[l,r]$区间，合并后的状态为 $S$ 的最小代价.

怎么转移呢，如果暴力转移是 $O(n^3*2^{k-1})$，绝对会**TLE**.

接下来就考虑找规律，我们发现：**不论合并的过程如何，只要给出一个串的长度，它合并后的长度一定不变**.

那接下来就来找出这个长度吧：

- 串的长度为 $1$ 时，无法合并，长度仍为 $1$.
- 串的长度为 $k$ 时，长度为 $k$ 的串能够合并，最终生成长度为 $1$ 的新串.
- 串的长度为 $2k-1$ 时，长度为 $k$ 的串先合并，生成长度为 $1$ 的串后与剩下的长度为 $k-1$ 的串一起合并，生成长度为 $1$ 的串.
- ...

很明显可以发现，当串的长度为 $a(k-1)+1$时，该串最后生成的串的长度一定为 $1$.

并且进一步可以得到，当串的长度为 $len$ 时，最后该串的长度为 $(len-1) \bmod (k-1)+1$.

这样我们就缩小了DP转移过程中枚举的范围.

DP过程如下：

- $f_{l,r,S}=\max \{f_{l,mid,S}+f_{mid+1,r,S}\}((r-l) \bmod (k-1)\not=0)$
- 当$(r-l) \bmod (k-1)=0$ 时，还需计算上整个串合并的代价，这一点不太好表达，直接看代码.

时间复杂度为 $O(n^2 \lfloor \frac{n}{k} \rfloor*2^{k-1})$，这个复杂度虽然看上去和暴力差不多，但实际运行远低于该上界.

**PS:这题如果不将非法值置为 $-\infty$ 会出现玄学错误.**

**Show the Code**

```cpp
#include<cstdio>
#include<cstring>
#define max(a,b) ((a)>(b)? (a):(b))
typedef long long ll;
ll inf;
int a[305],c[1<<8|1];
ll f[305][305][1<<8|1],g[2],w[1<<8|1];
inline int read() {
	register int x=0,f=1;register char s=getchar();
	while(s>'9'||s<'0') {if(s=='-') f=-1;s=getchar();}
	while(s>='0'&&s<='9') {x=x*10+s-'0';s=getchar();}
	return x*f;
}
int main() {
	int n=read(),k=read();
	for(register int i=1;i<=n;++i) a[i]=read();
	for(register int i=0;i<(1<<k);++i) {c[i]=read();w[i]=read();}
	memset(f,-0x3f,sizeof(f));
	memset(&inf,-0x3f,sizeof(inf));
	for(register int i=1;i<=n;++i) f[i][i][a[i]]=0;
	for(register int len=2;len<=n;++len) {
		for(register int l=1;l<=n-len+1;++l) {
			//(len-1)%(k-1)
			//0*k+1 1*k 2*k-1 3*k-2 4*k-3... 
			//1 2k-1 3k-1 4k-1
			int r=l+len-1,x=(len-1)%(k-1);
			if(x==0) x=k-1;
			for(register int mid=r-1;mid>=l;mid-=k-1) {//l~mid mid+1~r
				for(register int S=0;S<(1<<x);++S) {
					f[l][r][S<<1]=max(f[l][r][S<<1],f[l][mid][S]+f[mid+1][r][0]);
					f[l][r][S<<1|1]=max(f[l][r][S<<1|1],f[l][mid][S]+f[mid+1][r][1]);
				}
			}
			if(x==k-1) {
				g[0]=g[1]=inf;
				for(register int S=0;S<(1<<k);++S) g[c[S]]=max(g[c[S]],f[l][r][S]+w[S]);
				f[l][r][0]=g[0];f[l][r][1]=g[1];
			}
		}
	}
	ll res=inf;
	for(register int i=0;i<(1<<k);++i) res=max(res,f[1][n][i]);
	printf("%lld\n",res);
	return 0;
}
```

---

## 作者：pomelo_nene (赞：8)

$\ \ \ \ \ \ \ $[luogu](https://www.luogu.com.cn/problem/P3736)，同步于[动态规划100题](https://www.luogu.com.cn/blog/blog10086001/dong-tai-gui-hua-100-ti)第16题。

$\ \ \ \ \ \ \ $根据经验，$k$ 很小，并且只有 01 串，很容易想到状压 dp。

$\ \ \ \ \ \ \ $因为分数非负，考虑把能合的全部都合起来。我们考虑合并完成后展开，各个区间一定是不相交的。考虑用上区间 dp。

$\ \ \ \ \ \ \ $区间 dp 套路，枚举中间端点。合并成一位 0 或 1 一定会弄掉 $k$ 个字符变成 1 个（因为其中区间不相交），所以直接 `ptt+=k-1` 就好。

$\ \ \ \ \ \ \ $然后特殊情况是区间长度刚好是 $k$。那么直接合并，用两个临时变量储存。（因为修改之后能够修改其他的值，不好操作）。

$\ \ \ \ \ \ \ $最后说一下状态定义：定义 $dp_{i,j,S}$ 为合并 $[i,j]$ 区间，状态为 $S$。有 dp 方程：

$$\begin{cases}
dp_{i,j,now \times 2}=\max \{ dp_{i,ptt-1,now} + dp_{ptt,j,0}\}(dp_{ptt,j,0}!=-inf) \\\\ dp_{i,j,now \times 2+1}=\max \{ dp_{i,ptt-1,now} + dp_{ptt,j,1}\}(dp_{ptt,j,1}!=-inf)
\end{cases}$$

$\ \ \ \ \ \ \ $最后注意下枚举顺序，考虑用到 $dp_{i,ptt-1}$ 和 $dp_{ptt,j}$，枚举区间一定要倒序枚举。

$\ \ \ \ \ \ \ $答案为 $\max \{ dp_{1,n}\}$

```cpp
#include<cstdio>
#include<queue>
#include<algorithm>
#include<cstring>
#include<iostream>
#include<set>
#include<map>
#define lc(x) x<<1ll
#define rc(x) x<<1ll|1ll
using namespace std;
char t[3005];
int n,m;
long long NegaInf,a[3005],cnt[2600],val[2600],dp[305][305][305];
int main(){
	scanf("%d %d",&n,&m);
	for(int i=1;i<=n;++i)	scanf("%lld",&a[i]);
	for(int i=0;i<=(1<<m)-1;++i)	scanf("%lld %lld",&cnt[i],&val[i]);
	memset(dp,128,sizeof dp);
	for(int i=1;i<=n;++i)	dp[i][i][a[i]]=0;
	NegaInf=dp[0][0][0]; 
	for(int dis=2;dis<=n;++dis)
	{
		for(int i=1,j=dis;j<=n;++i,++j)
		{
			long long lena=(j-i)%(m-1);
			lena=!lena?m-1:lena;
			for(int ptt=j;ptt>=i+1;ptt-=m-1)
			{
				for(int k=0;k<=(1<<lena)-1;++k)
				{
					if(dp[i][ptt-1][k]==NegaInf)	continue;
					if(dp[ptt][j][0]!=NegaInf)	dp[i][j][lc(k)]=max(dp[i][j][lc(k)],dp[i][ptt-1][k]+dp[ptt][j][0]);
					if(dp[ptt][j][1]!=NegaInf)	dp[i][j][rc(k)]=max(dp[i][j][rc(k)],dp[i][ptt-1][k]+dp[ptt][j][1]);
				}
			}
			if(lena==m-1)
			{
				long long rear0=NegaInf,rear1=NegaInf;
				for(int k=0;k<=(1<<m)-1;++k)
				{
					if(dp[i][j][k]!=NegaInf)
					{
						if(cnt[k])	rear1=max(rear1,dp[i][j][k]+val[k]);
						else	rear0=max(rear0,dp[i][j][k]+val[k]);
					}
				}
				dp[i][j][0]=rear0,dp[i][j][1]=rear1;
			}
		}
	}
	long long ans=NegaInf;
	for(int i=0;i<=(1<<m)-1;++i)	ans=max(ans,dp[1][n][i]);
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：pengyule (赞：5)

> 一个长为 $1\le n\le 300$ 的 01 串 $a$，可以选长为 $2\le k\le 8$ 的连续段 $[l,r]$ 替换为 $c_x\in \{0,1\}$，得到 $1\le w_x\le 10^9$ 价值，其中 $x$ 表示 $a:[l,r]$ 构成的二进制数。例如 `10011` 将中间三个字符替换为 `1`，会得到新字符串 `111`，而后续的操作均在新字符串上进行。

#### 受到启发

- 看到 $k\le 8$ 想到状态压缩。
- 看到 $n\le 300$ 想到区间 dp。

#### 观察性质

- 将一个区间从始态到终态的过程本质是将区间划分成 $<k$ 段，每一段中的数合并成一个数。
- 由于 $w_x\le 1$，对于一固定长度区间，它最后的长度是确定的，因一次操作将区间长削减 $k-1$。为 `y=len%(k-1)==0?(k-1):len%(k-1)`。

#### 题解


$f[l,r,s]$ 表示区间 $[l,r]$ 的终态为 $s$ 的最大价值。$s$ 是一个 `y` 位二进制数，`y` 的含义见上。
枚举 $s$ 的最后一位所代表的区间后缀的起始点 $i>l$，$f[l,r,s]=f[l,i-1,s>>1]+f[i,r,s\&1]$。
$O(n^32^y)\le O(n^32^k)$。

观察到有效地 $i$ 只可能是 $r,r-(k-1),r-2(k-1),...$，这样枚举可将常数 $\div k$。
$O(n^32^k/k)$。区间 dp 常数小，可通过。

一些注意事项：
1. LL
2. 枚举 $s$ 时，如果 `y==1`，发现没法转移。考虑倒数第二次转移的末态作为 $s$ 来。即 `y+=(k-1)`。但**储存** `f[l,r,s]` 时的 $s$ 还是得按最后一次的 $s$ 来表示。

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N=305;
int n,k,ans,a[N],c[260],v[260],f[N][N][260];
signed main(){
	cin>>n>>k;
	for(int i=1;i<=n;i++)cin>>a[i];
	for(int i=0;i<(1<<k);i++)cin>>c[i]>>v[i];
	memset(f,-0x3f,sizeof(f));
	for(int i=1;i<=n;i++)f[i][i][a[i]]=0;
	for(int l=1;l+k-1<=n;l++){
		int x=0;
		for(int i=l;i<=l+k-1;i++)x=(x<<1)+a[i];
		f[l][l+k-1][c[x]]=v[x];
	}
	for(int len=2;len<=n;len++){
		for(int l=1,r=len;r<=n;l++,r++){
			int x=len%(k-1);if(!x)x+=k-1;if(x<=1)x+=k-1;
			for(int s=0;s<(1<<x);s++){
				int _s=x==k?c[s]:s;
				int tmp=f[0][0][0];
				for(int i=r;i>l;i-=k-1)
					if(f[l][i-1][s>>1]!=f[0][0][0]&&f[i][r][s&1]!=f[0][0][0])
						tmp=max(tmp,f[l][i-1][s>>1]+f[i][r][s&1]);
				if(x==k&&tmp!=f[0][0][0])tmp+=v[s];
				f[l][r][_s]=max(f[l][r][_s],tmp);
				if(len==n)ans=max(ans,f[l][r][_s]);
			}
		}
	}
	cout<<ans;
}
```

---

## 作者：Zxsoul (赞：5)

## P3736 [HAOI2016]字符合并

**考点** 
> 区间DP和状压DP组合好题！

首先是理解题目意思，我可是在理解题意上就花了近半个小时，貌似题面有个地方打错了。

选择 $k$ 个字符合并比较简单，但是 $k$ 个字符合并后会产生一个字符，这让我立马想到了 [蚯蚓](https://www.luogu.com.cn/problem/P2827)[贪吃蛇](https://www.luogu.com.cn/problem/P7078)，可是题目并不是维护大小问题，所以并不需要数据结构维护，考虑DP。题目中以状态的形式给出每 $k$ 个字符串的贡献，这是让我们去想状压，如何既满足区间的DP式子，又能完成状压操作呢？

不难发现对于一个区间，我们可以决定他的最终形态，我们在区间DP中再开一维记录最终形态，不就可以DP了嘛。设 $f_{i,j,S}$ 表示区间 $[i,j]$ 最终形态为 $S$ 的最大得分。我们从区间DP的性质去分析如何转移，对于我们枚举的中间值 $mid$，倘若 $[mid,j]$ 内恰好有 $k$ 那么就可以合并成一个了，转换成式子是：
$$
f_{i,j,S}=\max\{f_{i,mid-1,S/2} + f_{mid,j,0/1}\}
$$
其中第一个 `\` 是除号，这里是左移的意思，等价于将右边的一位扔掉。第二个 `\` 表示或者的意思。

这种寻找中间与边界的关系的思路来源于 [P4170 [CQOI2007]涂色](https://www.luogu.com.cn/problem/P4170) ，这是区间DP关系的常规找法。

接下来细说中间值 $mid$ 的枚举，我们直接保证 $[mid,j]$ 总是以 $nk-(n-1)$ 的形式出现，因为这个式子最终合并后是一个字符。当区间恰好是 $k$ 时可以直接合并，那么我们的 $f_{i,j,0/1}$ 就价值了，因为合并后只有两种数字，则用 $g_{0/1}$ 表示长度为 $k$ 的最大价值。转移有：
$$
g_{c[S]}=\max\{f_{i,j,S}+w_S\}
$$
其中 $S$ 是枚举的子集状态。最后将 $g$ 向 $f_{i,j,0/1}$ 转移就好了，这道题目就愉快的做完了。

注：以上思路来自题解区，因为这题是我的**百紫题**，因此特意纪念一下。

**值得注意的是**

1. `memset-0x80` 的赋值我写挂了，建议循环赋值，我挂了好久。
2. 理解 `Len=(j-i)%(k-1)` 的含义，它并不表示区间长度(我大写了)，表示的是有多少个 $k-1$，其中 `(j-i)` 会留下一个，在加上这 $n(k-1)$，就构成上面提到的式子：$nk-(n-1)$ ，他最后合并就只有一项，所以不会做出贡献。
3. 枚举子集状态时不可有前面的转移过来，因为右移会爆，应该是想后面转移。

**代码**
```c
/*
    17:58 刚读懂题目
     
*/
#include <set>
#include <cmath>
#include <queue>
#include <cstdio>
#include <vector>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <string.h> 
#define int long long
using namespace std;

const int A = 1e5+10;
const int B = 2e4+10;
const int mod = 1e9 + 7;
const int inf = 0x3f3f3f3f;

inline int read() {
  char c = getchar();
  int x = 0, f = 1;
  for ( ; !isdigit(c); c = getchar()) if (c == '-') f = -1;
  for ( ; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48);
  return x * f;
}
int n,k;
int g[4];
int a[B];
int c[B],w[B];
int f[309][309][1<<(8)];
main()
{
    n=read(); k=read();
    for (int i=1;i<=n;i++) a[i]=read();
    for (int i=0;i<(1<<k);i++) c[i]=read(),w[i]=read();
    for (int i=1;i<=n;i++)
	 for (int j=1;j<=n;j++)
	  for (int z=0;z<(1<<k);z++)
	  f[i][j][z]=-inf; //不能用memset!!! 
    for (int len=1;len<=n;len++)
    {
        for (int i=1;i+len-1<=n;i++)
        {
            int j=i+len-1;
            if (i==j) {f[i][j][a[i]]=0; continue;}
            int Len=(len-1)%(k-1);//得到最简的状态 
            if (!Len && len!=1) Len=k-1;
            for (int l=j;l>i;l-=k-1)
            {
                for (int S=0;S<(1<<(Len+1));S++)//为什么不能老状态转线状态，而是线状态转去转别的装填 
                { 
                    f[i][j][S<<1]=max(f[i][j][S<<1],f[i][l-1][S]+f[l][j][0]);
                    f[i][j][S<<1|1]=max(f[i][j][S<<1|1],f[i][l-1][S]+f[l][j][1]);
                }
            } 
            if (Len==k-1)//刚好可以合成一个数
            {
                g[1]=g[0]=-inf;
                for (int S=0;S<(1<<k);S++)
                {
                    g[c[S]]=max(g[c[S]],f[i][j][S]+w[S]);
                }
                f[i][j][0]=g[0], f[i][j][1]=g[1];
            } 
        }
    } 
    int ans=-inf;
    for (int i=0;i<(1<<k);i++) ans=max(ans,f[1][n][i]);
    printf("%lld",ans);
} 
```
若有不符合规矩的地方请管理员大大务必详细点出，谢谢了。 qwq

---

## 作者：_ReClouds_ (赞：3)

发现 $2 \leq k \leq 8$，于是可以考虑状压 DP。

我们可以设 $f_{l,r,S}$ 表示区间 $[l, r]$ 经过若干次操作变成 01 串 $S$ 的最大分数。

基于贪心的思想，我们一定要**使得整个 01 串最终不可操作**，所以 01 串 $S$ 的长度不超过 $k - 1$，否则 $S$ 可以继续进行合并，直到其长度小于等于 $k - 1$。

那么我们有一个很暴力的做法：

对于 $l, r$，枚举中点 $mid$，再枚举区间 $[l, mid]$ 和 $[mid + 1, r]$ 的所有状态，同时枚举合并的区间 $[p, p + k - 1]$，直接转移即可。

这样做的时间复杂度是 $O(kn^32^{2k - 2})$ 的，会 T 飞。

这个时候，一般的想法是**找到一些有利于统计的性质**。

------

我们会发现，一个 $p$ 可能会被多个区间枚举到，**但是它们转移的效果是一样的**。

举个例子：

假设我们有两个区间 $[l_1, r_1], [l_2, r_2]$。

前者枚举出的状态分别为：$00010, 10100$；

后者枚举出的状态分别为：$00101, 01000$；

如果前者取区间 $[4, 8]$ 合并，后者取区间 $[3, 7]$ 合并，那么上面的两个区间合并出来是等价的。

所以我们遵从最简化原则，对于每个区间，我们钦定后面一部分区间（即 $[mid + 1, r]$ 这一部分）的状态只能为 0 或 1（即长度为 1 的 01 串）。实际上，这样的操作相当于不断往一个串中添 0 或 1。

接着，我们可以发现，长度为 $len$ 的串，最终一定会被操作成长度为 $(len - 1)\bmod (k - 1) + 1$ 的串。也就是说，只要最初的 01 串的长度是确定的，那么最终的 01 串长度同样是确定的。

所以，如果一段区间的长度 $len$ 满足 $(len - 1)\bmod (k - 1) = 0$，那么经过若干次操作后，这个区间一定可以变成长度为 1 的 01 串。

因此，枚举 $mid$ 时，我们不需要一个个位置地枚举，只需要满足 $(r - mid - 1) \bmod (k - 1) = 0$ 即可。

（所以，DP 状态中的 $S$ 实际上可能带有若干个前导 0，取决于最终变成的 01 串的长度）

------

综合上述性质，我们就有了时间复杂度是 $O(n^2\lfloor\frac{n}{k}\rfloor 2^{k - 1})$ 的做法，不过这只是一个上界，并且区间 DP 本身就是跑不满的，所以这个复杂度是可以通过的。

但是，上述做法就不能在转移的过程中计算答案了。

不过，结合前面的这句 “实际上，这样的操作相当于不断往一个串中添 0 或 1”，我们可以发现，当 $(len - 1) \bmod (k-1) = 0$ 时，01 串中正好添加了 $k$ 个字符。此时，我们就可以把它们再合并一次，同时计算答案了。

代码：

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cassert>
#include<cstring>

#define MAXN 305
#define MAXM 8

using LL = long long;
using namespace std;

int n, k, a[MAXN], c[1 << MAXM];
LL ans, w[1 << MAXM], f[MAXN][MAXN][1 << MAXM];
const LL INF = 0x3F3F3F3F3F3F3F3F;

int main()
{
    #ifdef FILE
        freopen("Input.in", "r", stdin);
        freopen("Output.out", "w", stdout);
    #endif
    scanf("%d%d", &n, &k);
    for(register int i = 1; i <= n; i++) scanf("%d", a + i);
    for(register int i = 0; i < (1 << k); i++) scanf("%d%lld", c + i, w + i);
    for(register int i = 1; i <= n; i++) for(register int j = 1; j <= n; j++) for(register int S = 0; S < (1 << k); S++) f[i][j][S] = -INF;
    for(register int i = 1; i <= n; i++) f[i][i][a[i]] = 0;
    for(register int len = 2; len <= n; len++)
    {
        for(register int l = 1, r = l + len - 1; r <= n; ++l, ++r)
        {
            int t = (len - 1) % (k - 1);
            if(t == 0) t = k - 1;
            for(register int mid = r - 1; mid >= l; mid -= k - 1)
            {
                for(register int S = 0; S < (1 << t); S++)
                {
                    f[l][r][S << 1] = max(f[l][r][S << 1], f[l][mid][S] + f[mid + 1][r][0]);	//添加一个 0
                    f[l][r][S << 1 | 1] = max(f[l][r][S << 1 | 1], f[l][mid][S] + f[mid + 1][r][1]);	//添加一个 1
                }
            }
            if(t == k - 1)	//再次合并
            {
                LL g[2] = {-1LL, -1LL};
                for(register int S = 0; S < (1 << k); S++) g[c[S]] = max(g[c[S]], f[l][r][S] + w[S]);
                f[l][r][0] = g[0], f[l][r][1] = g[1];
            }
        }
    }
    ans = -INF;
    for(register int i = 0; i < (1 << (k - 1)); i++) ans = max(ans, f[1][n][i]);
    printf("%lld\n", ans);
    return 0;
}
```

---

## 作者：程门立雪 (赞：3)

~~不知道有没有人和我一样没读懂题目。~~

**题意：**

有一个长度为 $n$  的 $01$ 串，你可以每次将相邻的 $k$ 个字符合并，得到一个新的字符并获得一定分数。读入的 $c_i$ 和 $w_i$ 表示，如果长度为 $k$ 的 $01$ 串连成二进制后得到的数为 $i$, 那么，这个字符串将会变为 $c_i$, 获得的分数为 $w_i$​。

例如，样例就表示：

>1 10       00——>1    得分：10
>
>1 10       01——>1    得分：10
>
>0 20       10——>0    得分： 20
>
>1 30       11——>1     得分：30

**题解：**

$w_i$​ 都是正数只有把一个区间合并到不能再合并，得到的答案才是最优的。

看到 $k$​​​ 的取值可以想到状压dp，根据题目中序列合并的操作，合并的区间之间是不相交的，可以想到区间dp。

设 $f(i,j,s)$​​ 表示将字符从 $i$​​ 到 $j$​​ 合并成 $s$​​​​ 所得的最高分数。

最后答案为 $f(1,n, $​所以状态$)$​​​ 中的最大值。

转移时，暴力的转移肯定会超时，我们考虑枚举中间断点，使断点右边的子串合成 $s$​ 的最后一位，断点右边合成其他的数字。

想让子串合成一位，那么原串的长度为 $x \times (k - 1) + 1$​, (不明白的， 可以想几个例子)，所以我们每次将中间断点的值改变​ $k - 1$​​ 就可以。这样就缩小了转移中枚举的范围。

当 $(j - i) \bmod (k - 1) \not= 0$​​​​  时，

$f(i,j,s) = \max(f(i,j,s), f(i,mid,s) + f(mid + 1,j,s))$​​

当 $(j - i) \bmod (k - 1) = 0$​ 时，需要直接把它们合并一次。

~~代码和 zxTLE很像，因为看了他的题解。~~

```c
/*
Date:2021.8.2
Source:luogu 3736   
konwledge:区间dp + 状压dp 
*/
#include <iostream>
#include <cstdio>
#include <cstring>
#define orz cout << "AK IOI"
#define int long long

using namespace std;

inline int read()
{
	int f = 0, x = 0; char ch = getchar();
	while(!isdigit(ch)) f |= (ch == '-'), ch = getchar();
	while(isdigit(ch)) x = x * 10 + (ch ^ 48), ch = getchar();
	return f ? -x : x;
}
inline void print(int X)
{
	if(X < 0) {X = ~(X - 1); putchar('-');}
	if(X > 9) print(X / 10);
	putchar(X % 10 + '0');
}
int n, k, s[310], c[310], w[310], f[310][310][310]; 
signed main()
{
	n = read(), k = read();
	for(int i = 1; i <= n; i++) s[i] = read();
	for(int i = 0; i < (1 << k); i++) c[i] = read(), w[i] = read();
	memset(f, -63, sizeof f);
	for(int i = n; i >= 1; i--)
	{
		for(int j = i; j <= n; j++)
		{
			if(i == j) { f[i][j][s[i]] = 0; continue;}
			int len = j - i;
			len %= (k - 1);
			if(len == 0) len = k - 1;
			for(int mid = j; mid > i; mid -= k - 1)
				for(int s = 0; s < (1 << len); s++)
				{
					f[i][j][s << 1] = max(f[i][j][s << 1], f[i][mid - 1][s] + f[mid][j][0]);
					f[i][j][s << 1 | 1] = max(f[i][j][s << 1 | 1], f[i][mid - 1][s] + f[mid][j][1]);
				}
			if(len == k - 1)
			{
				int g[2];
				g[0] = g[1] = -0x3f3f3f3f;
				for(int s = 0; s < (1 << k); s++)
				g[c[s]] = max(g[c[s]], f[i][j][s] + w[s]);
				f[i][j][0] = g[0], f[i][j][1] = g[1];
			}
		}
	}	
	int ans = -0x3f3f3f3f;
	for(int i = 0; i < (1 << k); i++) ans = max(ans, f[1][n][i]);
	print(ans);
	return 0;	
}
```

感谢 https://www.luogu.com.cn/blog/kingjack/solution1-p3736


---

## 作者：Authentic_k (赞：3)

## 前置芝士

 区间DP，状压DP

## 数组含义　
$dp[s][i][j]$：$s$ 表示状态， $i$ 表示左端点， $j$ 表示右端点　。

## 基本思想

 1. 大区间可以被小区间更新，考虑**区间DP**。

  2. 应记录每一次状态，即合并完之后的数字，来更新下一个状态，考虑**状压**。

  * **tips** ： 由于按照二进制从大到小顺序，则必然按原数从小到大排序，则与原数按顺序一一对应。

## 代码实现

  1. 枚举区间长度（区间 DP 基本思想），枚举左右端点。
 
  2. 因为区间确定则合并后数字数量确定，则可以枚举状态，分为前部分和后部分，进而合并区间。

  3. 分情况考虑，如果长度为 $k$ , $2k-1$ ...... 则合并为 0 , 1，价值为**左区间+右区间+合并价值**；如果不为上一个情况则为左区间+右区间且区间状态合并。

* ### DP转移

```cpp
if(Len!=m)
{
    dp[p][l][r]=max(dp[p][l][r],dp[p>>j][l][k-1]+dp[p&((1<<j)-1)][k][r]);
    ans=max(ans,dp[p][l][r]);
}
else
{
    dp[to[p]][l][r]=max(dp[to[p]][l][r],dp[p>>j][l][k-1]+dp[p&((1<<j))-1][k][r]+val[p]);
    ans=max(ans,dp[to[p]][l][r]);
}
```
**一边更新一边记录 ans**，最后输出。

## AC代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int dp[258][301][301],len[2000],val[258],to[258],ans;
template <typename T>
inline void read (T &a) {
	T x = 0, f = 1;
	char ch = getchar ();
	while (! isdigit (ch)) {
		if (ch == '-') f = 0;
		ch = getchar ();
	}
	while (isdigit (ch)) {
		x = (x << 1) + (x << 3) + (ch ^ '0');
		ch = getchar ();
	}
	a = f ? x : -x;
}
inline int max (int a , int b) {
    if(a > b) return a;
    return b;
}
signed main()
{
	int n,m;
    read(n),read(m);
    memset(dp,0xcf,sizeof(dp));
	for(int i = 1 ; i <= n ; i ++) {
        char s;
        while(true) {
            s = getchar();
            if(s == '0' or s == '1') break;
        }
        dp[s - '0'][i][i] = 0;
    }
    for(int i = 0 ; i < (1 << m) ; i ++) 
	read(to[i]),read(val[i]);
    for(int i=1;i<=m;i++)
    {
    	len[i]=i;
    }
    for(int i=m;i<=n;i++)
    {
    	len[i]=len[i-m+1];
    }
    for(int L=1;L<n;L++)
    {
    	for(int l=1;l+L<=n;l++)
    	{
    		int r=l+L,Len=len[L+1];
    		if(Len==1) Len=m;
    		for(int p=0;p<(1<<Len);p++)
    		{
    			for(int j=1;j<Len;j++){
    			int k=l;
    			for(;k<=n;k++) if(len[r-k+1]==j) break;
    			for(;k<=r;k+=m-1)
    			{
    				if(Len!=m)
    				{
    					dp[p][l][r]=max(dp[p][l][r],dp[p>>j][l][k-1]+dp[p&((1<<j)-1)][k][r]);
    					ans=max(ans,dp[p][l][r]);
    				}
    				else
    				{
    					dp[to[p]][l][r]=max(dp[to[p]][l][r],dp[p>>j][l][k-1]+dp[p&((1<<j))-1][k][r]+val[p]);
    					ans=max(ans,dp[to[p]][l][r]);
    				}
    			}
			  }
    		}
    	}
    }
    printf("%lld",ans);
}
```

---

## 作者：Purslane (赞：1)

# Solution

一眼区间 DP。然后很快想到了一个 $O(n^3 \times 2^k)$ 的做法：设 $dp_{l,r,st}$ 为区间 $[l,r]$ 中的数全部合并为 $st$ 状态的最大权值。转移的时候找到后缀的区间，把它压成一个数。

但是很显然通过不了。我们寻求优化。

第一点，我们发现，一个区间再怎么合并，它的长度和原长必定模 $k-1$ 同余。因此后缀区间只需枚举原来的 $\frac{1}{k}$。

再发现，我们整个区间，长度基本上是模 $k-1$ 均匀分布的。（我是说基本上，差异在 $O(k)$ 量级内）因此我们发现，$\frac{1}{k} \sum_{i=1}^{k} 2^i = \frac{2^{k+1}}{k}$，基本上又把一个东西的枚举量除了 $k$。

因此我们就用这个非常简单的优化就可以做到 $O(\frac{n^3 \times 2^k}{k^2})$，应该也许能过吧。

```cpp
#include<bits/stdc++.h>
#define int long long
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=300+10,MAXK=(1<<8)+10;
int n,k,a[MAXN],dp[MAXN][MAXN][MAXK],nxt[MAXK],w[MAXK];
signed main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>n>>k; ffor(i,1,n) cin>>a[i]; ffor(i,0,(1<<k)-1) cin>>nxt[i]>>w[i];
	memset(dp,-0x3f,sizeof(dp)); ffor(i,1,n) dp[i][i][a[i]]=0;
	ffor(len,2,n) {
		for(int l=1,r=len;r<=n;l++,r++) {
			ffor(j,l,r-1) if((r-j)%(k-1)==1%(k-1)) {
				if(dp[j+1][r][0]>=0) {
					ffor(st,0,(1<<((j-l)%(k-1)+1))-1) {
						int ST=(st<<1);
						if((j-l)%(k-1)+2==k) dp[l][r][nxt[ST]]=max(dp[l][r][nxt[ST]],dp[l][j][st]+dp[j+1][r][0]+w[ST]);
						else dp[l][r][ST]=max(dp[l][r][ST],dp[l][j][st]+dp[j+1][r][0]);
					}
				}
				if(dp[j+1][r][1]>=0) {
					ffor(st,0,(1<<((j-l)%(k-1)+1))-1) {
						int ST=(st<<1)+1;
						if((j-l)%(k-1)+2==k) dp[l][r][nxt[ST]]=max(dp[l][r][nxt[ST]],dp[l][j][st]+dp[j+1][r][1]+w[ST]);
						else dp[l][r][ST]=max(dp[l][r][ST],dp[l][j][st]+dp[j+1][r][1]);
					}
				}
			}
		}
	}
	int ans=0;
	ffor(i,0,(1<<k)-1) ans=max(ans,dp[1][n][i]);
	cout<<ans;
	return 0;
}
```

你别说，还挺快的。

---

## 作者：iloveziwei (赞：1)

# 传送门

[传送门](https://www.luogu.com.cn/problem/P3736)

# 思路

题目要求一段数**合并**后的最大分数，看到合并，且 $n$ 的范围才 $300$，自然的想到复杂度 $O(n^3)$ 的区间 dp。

注意到 $k$ 的范围很小，我们就可以想到复杂度为 $O(2^k)$ 状压，状压字符当前的状态。

结合起来，$dp_{i,j,s}$ 表示区间 `[i,j]` 合并后状态为 $s$，有 $O(n^3 2^k)$ 的暴力，显然易见会超时，这时我们就要找合并的性质。

不妨假设一段长度为 $t$ 的 `01` 序列，显然易见，当 $t = k$ 时，合并次数为 $1$。

假设合并完一次后，得到的长度为 $1$，如果再想合并一次，就要让合并完后的长度 $1$ 加上另一端区间的长度 $t_1$ 的和为 $k$，那显然 $t_1 = k-1$。合并后的长度为 $1$。

然后，再合并一次，那么 $t_2 = k-1$。合并后的长度仍为 $1$。

显然，如果继续合并，那么会有无数个 $k-1$ 被合并，那么就有 $t_n = k-1$，那么能够合并为长度为 $1$ 的区间的原长度就为 $\sum \limits_{i = 1}^{n}{t_i}+1 \to n(k-1) + 1$。

扩展一下，如果一个字符串长度为 $l_1$，合并后的长度为 $l_2$，那么根据上述方程，就有合并后的长度 $l_2 = (l_1 - 1) \bmod (k-1) + 1$，于是枚举 $l$ 的时候就不用每个都枚举，每次从右往左依次减去 $k-1$。

所以显然易见 dp 方程就为：

$$
\begin{cases}
  dp_{i,j,2s} = \max \limits_{i \le l < j,(j - 1 - l)\bmod( k - 1) = 0} \{ dp_{i,l,s} + dp_{l+1,j,0} \} \\
  dp_{i,j,(2s) \vee 1} = \max \limits_{i \le l < j,(j - 1 - l)\bmod( k - 1) = 0} \{ dp_{i,l,s} + dp_{l+1,j,1} \}
\end{cases}
$$

特别的，当一段区间合并后的长度为 $1$ 时，可以将所有的状态合并为一个字符，也就是：

$$
\begin{cases}
  dp_{i,j,0} = \max \limits_{0 \le s \le 2^k-1,r_s = 0}\{dp_{i,j,s}+w_s \} \\
  dp_{i,j,1} = \max \limits_{0 \le s \le 2^k-1,r_s = 1}\{dp_{i,j,s}+w_s \} 
\end{cases}
$$

这里的 $r_s$ 表示状态为 $s$ 的字符串合并后的答案，$w_s$ 表示合并得到的分数，注意要开辅助数组储存。

# AC code

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const ll N=310;
const ll K=7;
bool sum[N];
ll getsum(ll i,ll j) {
	if(i>j)swap(i,j);
	ll ans=0;
	for(ll k=j,q=0; k>=i; k--,q++) {
		ans+=(sum[k])*(1<<q);
	}
	return ans;
}
ll wes(unsigned ll x) {
	return 32-__builtin_clz(x);
}
//调试 
ll n,kk;
ll dp[N][N][1<<(K+1)|1];
ll str[1<<(K+1)|1];
bool tr[(1<<(K+1))|1];
int main() {
	cin>>n>>kk;
	for(ll i=1; i<=n; i++) {
		for(ll j=1; j<=n; j++) {
			for(ll s=(1<<kk)-1; s>=0; s--) {
				dp[i][j][s]=-1145141919810ll;//初始化 
			}
		}
	}
	for(ll i=1; i<=n; i++) {
		cin>>sum[i];
		dp[i][i][sum[i]]=0;
	}
	for(ll i=1; i<=(1<<kk); i++) {
		cin>>tr[i-1]>>str[i-1];
	}
	for(ll k=2; k<=n; k++) {
		for(ll i=1; i<=n-k+1; i++) {
			ll j=i+k-1;
			ll sizee=(k-1)%(kk-1);
			if(sizee==0) {
				sizee=kk-1;
			}
			for(ll l=j-1; l>=i; l-=(kk-1)) {
				for(ll s=(1<<(sizee))-1; s>=0; s--) {
					dp[i][j][s<<1]=max(dp[i][j][s<<1],dp[i][l][s]+dp[l+1][j][0]);
					dp[i][j][s<<1|1]=max(dp[i][j][s<<1|1],dp[i][l][s]+dp[l+1][j][1]);
				}
			}
			if(sizee==kk-1) {//合并后的长度为1
				ll r[2];
				r[0]=r[1]=-1145141919810ll;
				for(ll s=(1<<kk)-1; s>=0; s--) {
					r[tr[s]]=max(r[tr[s]],dp[i][j][s]+str[s]);
				}
				dp[i][j][0]=max(dp[i][j][0],r[0]);
				dp[i][j][1]=max(dp[i][j][1],r[1]);
			}
		}
	}
	ll ans=-1145141919810ll;
	for(ll s=(1<<kk)-1; s>=0; s--) {
		ans=max(ans,dp[1][n][s]);//答案
	}
	cout<<ans<<endl;
}
```

---

## 作者：CmsMartin (赞：1)

## 题目描述

[题目传送门](https://www.luogu.com.cn/problem/P3736)

[更好的阅读体验](http://cmsblog.top/archives/haoi2016-zi-fu-he-bing)

## 思路

假设 $dp_{l,r,S}$ 表示区间 $[l,r]$ 合并成二进制数 $S$ 的最大分数。

然后考虑转移。

首先有一个结论，尽可能多的合并直到不能合并位置。这样我们可以考虑合并后长度为 $1$ 的区间。显然，这个区间的大小为集合 $S =\{x|n \in \mathbb{N}\ x=nk-n+1\}$，然后就有 $dp_{l,r,2w}=dp_{l,mid,w}+dp_{mid+1,r,0}$，其中 $r - mid \in S$；以及 $dp_{l,r,2w+1}=dp_{l,mid,w} + dp_{mid+1,r,1}$，其中 $r-mid\in S$。

然后就是初始化，$i$ 到 $j$ 恰好有 $k$ 位数字，我们直接把它合并一次，具体实现看代码。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long

const int MAXK = 8, MAXN = 310;

int N, K;
int A[MAXN], W[MAXN], C[MAXN];
int Dp[MAXN][MAXN][1 << MAXK];

signed main() {
	memset(Dp, 0xcf, sizeof Dp);
	cin >> N >> K;
	for (int i = 1; i <= N; i++) cin >> A[i];
	for (int i = 0; i < (1 << K); i++)
		cin >> C[i] >> W[i];
	for (int i = 1; i <= N; i++) 
		Dp[i][i][A[i]] = 0;
	for (int len = 2; len <= N; len++) {
		for (int l = 1; l + len - 1 <= N; l++) {
			int r = l + len - 1;
			int tmp = (len - 1) % (K - 1);
			if (!tmp) tmp = K - 1;
			for (int k = r - 1; k >= l; k -= (K - 1)) {
				for (int w = 0; w < (1 << tmp); w++) {
					Dp[l][r][w << 1] = max(Dp[l][r][w << 1], Dp[l][k][w] + Dp[k + 1][r][0]);
					Dp[l][r][w << 1 | 1] = max(Dp[l][r][w << 1 | 1], Dp[l][k][w] + Dp[k + 1][r][1]);
				}
			}
			if (tmp == K - 1) {
				int CYB1 = INT_MIN, CYB2 = INT_MIN;

                for (int k = 0; k < (1 << K); ++ k) {
                    if (C[k] == 0)
                        CYB1 = max(CYB1, Dp[l][r][k] + W[k]);
                    else
                        CYB2 = max(CYB2, Dp[l][r][k] + W[k]);
                }

                Dp[l][r][0] = CYB1;
				Dp[l][r][1] = CYB2;
			}
		}
	}
	
	int Ans = INT_MIN;
	for (int i = 0; i < (1 << K); i++)
		Ans = max(Ans, Dp[1][N][i]);	
	cout << Ans << endl;
	return 0;
}
```

---

## 作者：rq_kyz (赞：0)

# 【题解】 P3736 [HAOI2016] 字符合并

### 传送门

[P3736 [HAOI2016] 字符合并](https://www.luogu.com.cn/problem/P3736)

---

### 题意

给定一个长度为 $n$ 的 `01` 字符串，进行若干次操作，每次将连续 $k$ 个字符合并，已知每种合并之后的字符和价值，问最大价值为多少。

---

### 分析

首先我们需要知道一段长度为 $len$ 的 `01` 字符串合并后的长度 $len1$ 为多少。每一次我们合并时，会把长度为 $k$ 的字符串变为长度为 $1$ 的字符串，也就是将长度减去 $k-1$。所以我们可以得到公式：

$len1=(len-1)\bmod(k-1)+1$。

然后，我们就可以推导状态转移方程。本题数据范围很小，所以我们可以使用区间 DP 和状态压缩 DP，$dp_{l,r,s}$ 表示 $l$ 到 $r$ 这段区间合并为 $s$ 的最大价值。转移时，我们可以考虑最后一位，将最后一位从 $s$ 中单独分出来，分成两端分别进行递推。这样是可以保证正确性的，因为前面的 $len1-1$ 位又会被同样的分割，所以方案不会遗漏。

所以状态转移方程为：

$dp_{l,r,s}=\max(dp_{l,r,s},dp_{l,i,s\div2}+dp_{i+1,r,s\bmod2})$

（$i$ 为循环的中间节点。）

但是这样会 TLE，因为时间复杂度为 $O(n^32^k)$。我们可以想到，中间节点 $i$ 不需要从 $l$ 到 $r-1$ 全部循环，只需要循环那些合并之后长度为 $len1-1$ 的 $i$ 就可以了。另外，我们的 $s$ 可以循环去掉末位之后的 $s$，在更新时分别更新最后一位为 $0$ 或 $1$ 两种情况。

最终的状态转移方程为：

$dp_{l,r,s\times2}=\max(dp_{l,r,s\times2},dp_{l,i,s}+dp_{i+1,r,0})$

$dp_{l,r,s\times2+1}=\max(dp_{l,r,s\times2+1},dp_{l,i,s}+dp_{i+1,r,1})$

（$s$ 是去掉末位之后的 $s$。）

---

### 代码

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
ll a[301];
ll v[1<<8],w[1<<8];
ll dp[301][301][1<<8];
int main(){
	ll n,k;
	scanf("%lld%lld",&n,&k);
	for(ll i=1;i<=n;i++)
		scanf("%lld",&a[i]);
	for(ll s=0;s<(1<<k);s++)
		scanf("%lld%lld",&v[s],&w[s]);
	for(ll l=1;l<=n;l++)
		for(ll r=1;r<=n;r++)
			for(ll s=0;s<(1<<k);s++)
				dp[l][r][s]=-1e18;
	for(ll l=1;l<=n;l++)
		dp[l][l][a[l]]=0;//初始化
	for(ll len=2;len<=n;len++)
		for(ll l=1,r=len;r<=n;l++,r++){
			ll len1=(len-1)%(k-1)+1;
			for(ll i=r-1;i>=l;i-=k-1)//循环中间节点，保证l~i区间合并后长度为len1-1
				for(ll s=0;s<(1<<(len1-3+k)%(k-1)+1);s++){//循环前len1-1位的情况
					//这里的“(len1-3+k)%(k-1)+1”等价与“len1-1==0?k-1:len1-1”，请读者自行思考公式推导方法
					dp[l][r][s<<1]=max(dp[l][r][s<<1],dp[l][i][s]+dp[i+1][r][0]);
					dp[l][r][s<<1|1]=max(dp[l][r][s<<1|1],dp[l][i][s]+dp[i+1][r][1]);
				}
			if(len1==1){//当合并后长度为1时，需要单独处理，注意要用临时数组存储
				ll ls[2];
				ls[0]=ls[1]=-1e9;
				for(ll s=0;s<(1<<k);s++)
					ls[v[s]]=max(ls[v[s]],dp[l][r][s]+w[s]);
				dp[l][r][0]=max(dp[l][r][0],ls[0]);
				dp[l][r][1]=max(dp[l][r][1],ls[1]);
			}
		}
	ll ans=-1e18;
	for(ll s=0;s<(1<<(n-1)%(k-1)+1);s++)
		ans=max(ans,dp[1][n][s]);//统计答案
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：Coros_Trusds (赞：0)

[更好的阅读体验](https://www.cnblogs.com/Coros-Trusds/p/16413282.html)

# 题目大意

有一个长度为 $n$ 的 $01$ 串，你可以每次将相邻的 $k$ 个字符合并，得到一个新的字符并获得一定分数。

得到的新字符和分数由这 $k$ 个字符确定。你需要求出你能获得的最大分数。

# 题目分析

因为所有的分数都不存在负数，所以我们肯定要选到不能选，也就是直到整个 $01$ 串的长度小于 $k$ 为止。经过数学归纳法，我们也能够发现：当原串的长度为 $l$ 时，最后剩下的长度为 $(l-1)\bmod(k-1)+1$。

可以通过计算得到当前串剩下的长度而进行枚举。

--------------
令 $dp[l][r][i]$ 表示区间 $[l,r]$ 变成状态 $i$ 的最大分数。

状态转移方程类似于石子合并，$dp[l,r,s]=\max\{dp[l][k][s>>1]+dp[k+1][r][0/1]\}$。

但要注意枚举断点时每次减去 $k-1$。因为我们状态转移中右边区间合并成一位，而只有长度为 $a(k-1)+1$ 的区间才能合并成 $1$ 位，故如此。并且枚举需要倒序枚举。

# 代码

```cpp
// Problem: P3736 [HAOI2016]×Ö·ûºÏ²¢
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P3736
// Memory Limit: 250 MB
// Time Limit: 1000 ms
// Date:2022-06-25 22:30
// 
// Powered by CP Editor (https://cpeditor.org)

#include <iostream>
#include <cstdio>
#include <climits>//need "INT_MAX","INT_MIN"
#include <cstring>//need "memset"
#include <numeric>
#include <algorithm>
#include <cmath>
#define int long long
#define enter putchar(10)
#define debug(c,que) std::cerr << #c << " = " << c << que
#define cek(c) puts(c)
#define blow(arr,st,ed,w) for(register int i = (st);i <= (ed); ++ i) std::cout << arr[i] << w;
#define speed_up() std::ios::sync_with_stdio(false),std::cin.tie(0),std::cout.tie(0)
#define mst(a,k) memset(a,k,sizeof(a))
#define stop return(0)
const int mod = 1e9 + 7;
inline int MOD(int x) {
	if(x < 0) x += mod;
	return x % mod;
}
namespace Newstd {
	char buf[1 << 21],*p1 = buf,*p2 = buf;
	inline int getc() {
		return p1 == p2 && (p2 = (p1 = buf) + fread(buf,1,1 << 21,stdin),p1 == p2) ? EOF : *p1 ++;
	}
	inline int read() {
		int ret = 0,f = 0;char ch = getc();
		while (!isdigit(ch)) {
			if(ch == '-') f = 1;
			ch = getc();
		}
		while (isdigit(ch)) {
			ret = (ret << 3) + (ret << 1) + ch - 48;
			ch = getc();
		}
		return f ? -ret : ret;
	}
	inline double double_read() {
		long long ret = 0,w = 1,aft = 0,dot = 0,num = 0;
		char ch = getc();
		while (!isdigit(ch)) {
			if (ch == '-') w = -1;
			ch = getc();
		}
		while (isdigit(ch) || ch == '.') {
			if (ch == '.') {
				dot = 1;
			} else if (dot == 0) {
				ret = (ret << 3) + (ret << 1) + ch - 48;
			} else {
				aft = (aft << 3) + (aft << 1) + ch - '0';
				num ++;
			}
			ch = getc();
		}
		return (pow(0.1,num) * aft + ret) * w;
	}
	inline void write(int x) {
		if(x < 0) {
			putchar('-');
			x = -x;
		}
		if(x > 9) write(x / 10);
		putchar(x % 10 + '0');
	}
}
using namespace Newstd;

const int INF = 0x3f3f3f3f3f3f3f3f;
const int N = 305,M = 8;
int a[N],c[(1 << M) + 1],w[(1 << M) + 1],dp[N][N][(1 << M) + 1];
//dp[l][r][k]:[l,r] ±ä³É×´Ì¬ i µÄ×î´ó·ÖÊý
int n,m;
int32_t main(void) {
    scanf("%lld%lld",&n,&m);
	for (register int i = 1;i <= n; ++ i) scanf("%1lld",a + i);
	for (register int i = 0;i < (1 << m); ++ i) scanf("%lld%lld",c + i,w + i);
	mst(dp,-0x3f);
	for (register int i = 1;i <= n; ++ i) dp[i][i][a[i]] = 0;
	for (register int len = 2;len <= n; ++ len) {
		for (register int l = 1;l + len - 1 <= n; ++ l) {
			int r = l + len - 1;
			int tmp = (len - 1) % (m - 1);
			if (!tmp) tmp = m - 1;
			for (register int k = r - 1;k >= l;k -= m - 1) {
				for (register int v = 0;v < (1 << tmp); ++ v) {
					dp[l][r][v << 1] = std::max(dp[l][r][v << 1],dp[l][k][v] + dp[k + 1][r][0]);
					dp[l][r][v << 1 | 1] = std::max(dp[l][r][v << 1 | 1],dp[l][k][v] + dp[k + 1][r][1]);
				}
			}
			if (tmp == m - 1) {
				int t1 = -INF,t2 = -INF;
				for (register int k = 0;k < (1 << m); ++ k) {
					if (c[k] == 0) t1 = std::max(t1,dp[l][r][k] + w[k]);
					else t2 = std::max(t2,dp[l][r][k] + w[k]);
				}
				dp[l][r][0] = t1,dp[l][r][1] = t2;
			}
		}
	}
	int res = -INF;
	for (register int i = 0;i < (1 << m); ++ i) {
		res = std::max(res,dp[1][n][i]);
	}
	printf("%lld\n",res);
	
	return 0;
}
```

---


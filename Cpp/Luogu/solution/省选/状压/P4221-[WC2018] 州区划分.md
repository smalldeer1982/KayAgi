# [WC2018] 州区划分

## 题目背景

**滥用本题评测将被封号！**

## 题目描述

小 S 现在拥有 $n$ 座城市，第 $i$ 座城市的人口为 $w_i$，城市与城市之间可能有双向道路相连。

现在小 S 要将这 $n$ 座城市划分成若干个州，每个州由至少一个城市组成，每个城市在恰好一个州内。

假设小 S 将这些城市划分成了 $k$ 个州，设 $V_i$ 是第 $i$ 个州包含的所有城市组成的集合。定义一条道路是一个州的内部道路，当且仅当这条道路的两个端点城市都在这个州内。如果一个州内部存在一条起点终点相同，不经过任何不属于这个州的城市，且经过这个州的所有内部道路都恰好一次并且经过这个州的所有城市至少一次的路径（路径长度可以为 $0$），则称这个州是不合法的。

定义第 $i$ 个州的满意度为：第 $i$ 个州的人口在前 $i$ 个州的人口中所占比例的 $p$ 次幂，即：

$$\left(\dfrac{\sum _ {x \in V _ i} w _ x}{\sum _ {j = 1} ^ i \sum _ {x \in V _ j} w _ x}\right) ^ p$$


定义一个划分的满意度为所有州的满意度的乘积。

求所有合法的划分方案的满意度之和。

答案对 $998244353$ 取模。
两个划分 $\{V_1, V _ 2, \cdots, V_k\}$ 和 $\{C_1, C _ 2, \cdots, C_s\}$ 是不同的，当且仅当 $k \neq s$，或存在某个 $1 \leq i \leq k$，使得 $V_i \neq C_i$。

## 说明/提示



【提示】

$x^{p-1} \equiv 1 \pmod p$，其中 $p$ 为质数， $x \in [1,p)$。

保证对于所有数据有：$0 \leq n \leq 21$， $0 \leq m \leq \dfrac{n\times (n-1)}{2}$ ， $0 \leq p \leq 2$， $1 \leq w_i \leq 100$。


## 样例 #1

### 输入

```
3 2 1
1 2
2 3
1 1 1```

### 输出

```
1```

# 题解

## 作者：lahlah (赞：30)

[luogu P4221 [WC2018]州区划分](https://www.luogu.org/problem/P4221)

# 题意
题意比较复杂，大致就是说

给出$n$个点，$m$条边

把$n$个点分成若干组，使每组里面不存在欧拉回路

每种方案的满意度为所有州的满意度的乘积

求所有方案的满意度的和

大概就是这样

# 题解
首先要知道怎么判断欧拉回路

当一组的所有点的度数都为**偶数**时存在欧拉回路（因为要起点和终点相同）

如果图不联通也是合法的

然后就可以用子集DP解决 15’ 的问题

code:
```cpp
#include<bits/stdc++.h>
#define mod 998244353
#define ll long long
using namespace std;
struct edge{
	int v, nxt;
}e[10005];
int p[25], eid;
void init(){
	memset(p, -1, sizeof p);
	eid = 0;
}
void insert(int u, int v){
	e[eid].v = v;
	e[eid].nxt = p[u];
	p[u] = eid ++;
}
ll qpow(ll x, int y){
	ll ret = 1;
	for(;y; y >>= 1, x = x * x % mod) if(y & 1) ret = ret * x % mod;
	return ret;
}
int fa[25];
int get(int x){
	return fa[x] == x? x:(fa[x] = get(fa[x]));
}
void merge(int x , int y){
	x = get(x), y = get(y);
	fa[x] = y;
}
int n, m, q, a[25][25], w[25], he[1 << 23], ok[1 << 23], du[25], U[1000005], V[1000005];
ll f[(1 << 23)];
int main(){
	init();
	scanf("%d%d%d", &n, &m, &q);
	for(int i = 1; i <= m; i ++) scanf("%d%d", &U[i], &V[i]);
	for(int i = 1; i <= n; i ++) scanf("%d", &w[i]);
	for(int S = 0; S < (1 << n); S ++){
		
		int bb = 0;
		for(int i = 1; i <= n; i ++){
			if((1 << (i - 1)) & S) he[S] += w[i], bb ++;
			du[i] = 0, fa[i] = i;
		}
			
		
		for(int i = 1; i <= m; i ++){//枚举边，看这条边是否在S这一组里
			if(((1 << (U[i] - 1)) & S) && ((1 << (V[i] - 1)) & S)){
				if(get(U[i]) != get(V[i])) merge(U[i], V[i]), bb --;
				du[U[i]] ++;
				du[V[i]] ++;//统计度数
			}
		}
		
		if(bb != 1) ok[S] = 1;
		int cnt = 0;
		for(int i = 1; i <= n; i ++) 
			cnt += (du[i] & 1);
		if(cnt) ok[S] = 1;//处理出当前点是否合法
	
	}
	f[0] = 1;
	for(int S = 0; S < (1 << n); S ++){//子集DP
		for(int S0 = S; S0; S0 = (S0 - 1) & S) if(ok[S0]){
			f[S] += f[S ^ S0] * qpow(he[S0] % mod * qpow(he[S], mod - 2) % mod, q) % mod;//子集DP
			f[S] %= mod;
		}
	}
	printf("%lld", f[(1 << n) - 1]);
	return 0;
}
```
恭喜你获得了15’的好成绩！！！！



看看子集DP的式子

可以转换为

$ans[S] = \sum f[S0] * g[S1]$ 满足$S0∩S1= \emptyset$ 且$ S0∪S1=S$

如果不考虑交集为空的情况那很明显可以FWT 

考虑多加一位表示集合中 **1** 的个数

$ans[i][S] = \sum f[j][S0] * g[i - j][S1]$ 且满足 $S0∪S1 = S$
然后惊喜的发现就相当于是把$f[j]$和$g[i-j]$卷在一起
然后就可以FWT 了
~~非常容易理解~~


code:
```cpp

#include<bits/stdc++.h>
#define mod 998244353
#define ll long long
using namespace std;
void fwt(ll *a, int len, int opt){//板子
	for(int i = 2; i <= len; i <<= 1)
		for(int p = i >> 1, j = 0; j + i <= len; j += i)
			for(int k = j; k < j + p; k ++)
				a[p + k] =(a[p + k] + opt * a[k] + mod) % mod;
}
ll qpow(ll x, int y){
	ll ret = 1;
	for(;y; y >>= 1, x = x * x % mod) if(y & 1) ret = ret * x % mod;
	return ret;
}
int fa[25];
int get(int x){
	return fa[x] == x? x:(fa[x] = get(fa[x]));
}
void merge(int x , int y){
	x = get(x), y = get(y);
	fa[x] = y;
}
int n, m, q, a[25][25], w[25], he[1 << 23], ok[1 << 23], du[25], U[1000005], V[1000005], bitcount[1 << 23];
ll f[23][1 << 22], g[23][1 << 22], inv[1 << 22];
int main(){
	scanf("%d%d%d", &n, &m, &q);
	int len = 1 << n;
	for(int i = 1; i <= m; i ++) scanf("%d%d", &U[i], &V[i]);
	for(int i = 1; i <= n; i ++) scanf("%d", &w[i]);
	for(int S = 0; S < len; S ++){
		
		int bb = 0;
		for(int i = 1; i <= n; i ++){
			if((1 << (i - 1)) & S) he[S] += w[i], bb ++;
			du[i] = 0, fa[i] = i;
		}
		bitcount[S] = bb;//bitcount(S)表示S中1的个数
		
		for(int i = 1; i <= m; i ++){
			if(((1 << (U[i] - 1)) & S) && ((1 << (V[i] - 1)) & S)){
				if(get(U[i]) != get(V[i])) merge(U[i], V[i]), bb --;
				du[U[i]] ++;
				du[V[i]] ++;
			}
		}
		
		if(bb != 1) ok[S] = 1;
		int cnt = 0;
		for(int i = 1; i <= n; i ++) 
			cnt += (du[i] & 1);
		if(cnt) ok[S] = 1;
		
		if(ok[S]) g[bitcount[S]][S] = qpow(he[S], q);//g是用来转移的，表示S划分成一组的满意度（分子）
		inv[S] = qpow(qpow(he[S], mod - 2), q);//分母 —— 逆元
	}
	for(int i = 0; i <= n; i ++) fwt(g[i], 1 << n, 1);
	f[0][0] = 1; fwt(f[0], 1 << n, 1);//FWT
	for(int i = 1; i <= n; i ++){
		for(int j = 0; j <= i - 1; j ++)
			for(int k = 0; k < len; k ++)
				f[i][k] += f[j][k] * g[i - j][k] % mod, f[i][k] %= mod;//卷起来
		fwt(f[i], 1 << n, -1);//IFWT
		
		for(int j = 0; j < len; j ++) f[i][j] = bitcount[j] == i? f[i][j] * inv[j] % mod:0;//求满意度
		if(i != n) fwt(f[i], 1 << n, 1);
	}
	printf("%lld", f[n][len - 1]);
	return 0;
}


```

~~这题在WC算是简单题了吧~~

好像有点小卡常QWQ

---

## 作者：ComeIntoPower (赞：14)

有一个显而易见的DP:$dp[S]$表示选择了城市集合S时的答案，$f[S]$表示城市集合S的w之和，那么

$dp[S]=\frac{1}{f[S]} \sum_{S'\in S}dp[S']*f[S-S']$

这是$O(3^n)$的。

上面的DP实际上是一个卷积。可以考虑子集卷积，可以参照vfk在2015年的论文。$dp[i][S]$中$i$表示$S$的bitcount,那么可以直接把这个FWT然后OR卷积，时间复杂度$O(n^2 2^n)$

```cpp
```C++
#include<bits/stdc++.h>
#define mod 998244353
#define G(x) (__builtin_popcount(x))
using namespace std;
typedef long long ll;
const ll I=((ll)7e18)/mod*mod;
ll dp[22][1<<21];
int n,m,inv[3000],f[1<<21],p,h[1<<21],dp2[1<<21];
int g[22][1<<21],ans,fa[25],dg[25],w[25],a[25][25],A[1<<21];
int M(int x){
	return x>=mod?x-mod:x;
}
int find(int x){
	return x==fa[x]?x:fa[x]=find(fa[x]);
}
void fwt(int h[],int len){
	for(int i=1;i<len;i<<=1)
		for(int j=0;j<len;j+=i<<1)
			for(int k=0;k<i;++k){
				int x=h[j+k],y=h[j+k+i];
				h[j+k+i]=M(y+x);
			}
} 
void ifwt(ll h[],int len){
	for(int i=0;i<len;++i)h[i]%=mod;
	for(int i=1;i<len;i<<=1)
		for(int j=0;j<len;j+=i<<1)
			for(int k=0;k<i;++k){
				ll x=h[j+k],y=h[j+k+i];
				h[j+k+i]=M(y-x+mod);
			}
} 
int chk(int S){
	for(int i=1;i<=n;++i)if(S>>i-1&1)fa[i]=i,dg[i]=0;
	for(int i=1;i<=n;++i)if(S>>i-1&1) 
		for(int j=i+1;j<=n;++j)if(S>>j-1&1)
			if(a[i][j])dg[i]++,dg[j]++,fa[find(i)]=find(j); 
	int lst=0;
	for(int i=1;i<=n;++i)
		if((S>>i-1&1)&&lst&&lst!=find(i))return 1;
		else if((S>>i-1&1))lst=find(i);
	for(int i=1;i<=n;++i)if((S>>i-1&1)&&dg[i]%2)return 1;
	return 0;
}
int cal(int x,int p){
	if(p==0)return 1;
	else if(p==1)return x;
	else return 1ll*x*x%mod;
}
int _cal(int x,int p){
	if(p==0)return 1;
	else if(p==1)return x;
	else return x*x;
}
int cmp(int x,int y){
	return G(x)<G(y);
}
int main(){
	scanf("%d%d%d",&n,&m,&p);
	for(int i=1;i<=2500;++i)inv[i]=(i==1?1:1ll*inv[mod%i]*(mod-mod/i)%mod);
	for(int i=1,u,v;i<=m;++i)scanf("%d%d",&u,&v),a[u][v]=a[v][u]=1;
	for(int i=1;i<=n;++i)scanf("%d",&w[i]);
	for(int i=1;i<(1<<n);++i)f[i]=w[__builtin_ctz(i&-i)+1]+f[i^(i&-i)],g[A[i]=A[i^(i&-i)]+1][i]=chk(i)*_cal(f[i],p);
	for(int i=1;i<=n;++i)fwt(g[i],1<<n);
	dp2[0]=dp[0][0]=inv[0]=1;
	for(int i=0;i<=n;++i){
		if(i)ifwt(dp[i],1<<n);
		if(i==n){
			ans=(dp[n][(1<<n)-1]%mod*cal(inv[f[(1<<n)-1]],p)%mod+mod)%mod;
			break;
		}
		for(int j=0;j<(1<<n);++j)
			if(A[j]==i)dp2[j]=dp[i][j]%mod*cal(inv[f[j]],p)%mod;
			else dp2[j]=0;
		fwt(dp2,1<<n);
		for(int j=1;i+j<=n;++j)
			for(int k=0;k<(1<<n);++k){
				dp[i+j][k]+=1ll*dp2[k]*g[j][k];
				if(dp[i+j][k]>I)dp[i+j][k]-=I;
			}
	}
	printf("%d",ans);
} 
```
```

---

## 作者：bztMinamoto (赞：9)

[传送门(洛谷)](https://www.luogu.org/problemnew/show/P4221)

~~全世界都会子集卷积就咱不会……全世界都在写$FMT$就咱只会$FWT$……~~

# 前置芝士

## 或运算$FWT$或者$FMT$

左转洛谷模板区，包教包会

## 子集卷积

定义：对于两个集合幂级数$F,G$，它们的子集卷积$H$定义为$$H_S=\sum_{T\subseteq S}F_TG_{S-T}$$
简单来说就是两个下标要满足的条件为$L\cap R=\varnothing$且$L\cup R=S$

$L\cup R=S$就是个异或卷积的事儿，关键是$L\cap R=\varnothing$太麻烦了

转化一下，$L\cap R=\varnothing$等价于$|L|+|R|=|S|$

那么我们可以新加一维，设$f_{i,S}$表示集合大小为$i$，集合为$S$，那么只有在$i=|S|$的时候这才是个对的东西。一开始的时候，我们可以把所有的$f_{|S|,S}$赋值为原来的$f(S)$（$g$同理），然后不断枚举$i$，做完$FWT$之后令$h_{i,S}=\sum_{j=0}^if_{j,S}g_{i-j,S}$。每个$i$做完后，把那些$|S|\neq i$的$h_{i,S}$清零就好了

如果不是很明白为什么的话，可以这样理解。首先对于所有的$j<i$，$f_j,g_j$里面存的都是正确的值。根据$FWT$的性质，未清零之前$h_{i,S}$中每一个$S$都是由那些$L\cup R=S$的$f_L$和$g_R$得来的，只要除去那些$|L|+|R|\neq |S|$的，剩下的肯定正确

# 本题题解

设$f_S$为选点集合为$S$时的贡献之和，$g_S$当$S$是一个合法集合时为${sum_S}^p$，当$S$不合法时为$0$

那么递推式就是$$f_S=\frac{1}{{sum_S}^p}\sum_{T\subset S}f_Tg_{S-T}$$

似乎有点眼熟……话说这个不就是个子集卷积么……

等会儿？这玩意儿是自己卷自己啊？

但我们发现这里每一个数只会被自己的子集卷到，于是我们依然可以枚举$i$，那么所有$|T|<|S|$的$f_{|T|,T}$已经算好了，直接带进去卷就好了

另外，$S$是个合法集合就是说$S$不存在欧拉回路，那么$S$存在欧拉回路的充要条件就是$S$连通且每个点度数都是偶数，判一下就好了

~~所以咱真的不知道为啥大家都写$FMT$，咱写$FMT$比$FWT$慢好多啊……~~
```cpp
//minamoto
#include<bits/stdc++.h>
#define R register
#define fp(i,a,b) for(R int i=a,I=b+1;i<I;++i)
#define fd(i,a,b) for(R int i=a,I=b-1;i>I;--i)
#define go(u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)
using namespace std;
char buf[1<<21],*p1=buf,*p2=buf;
inline char getc(){return p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++;}
int read(){
    R int res,f=1;R char ch;
    while((ch=getc())>'9'||ch<'0')(ch=='-')&&(f=-1);
    for(res=ch-'0';(ch=getc())>='0'&&ch<='9';res=res*10+ch-'0');
    return res*f;
}
char sr[1<<21],z[20];int C=-1,Z=0;
inline void Ot(){fwrite(sr,1,C+1,stdout),C=-1;}
void print(R int x){
    if(C>1<<20)Ot();if(x<0)sr[++C]='-',x=-x;
    while(z[++Z]=x%10+48,x/=10);
    while(sr[++C]=z[Z],--Z);sr[++C]='\n';
}
const int N=(1<<21)+5,P=998244353;
inline int add(R int x,R int y){return x+y>=P?x+y-P:x+y;}
inline int dec(R int x,R int y){return x-y<0?x-y+P:x-y;}
inline int mul(R int x,R int y){return 1ll*x*y-1ll*x*y/P*P;}
int ksm(R int x,R int y){
	R int res=1;
	for(;y;y>>=1,x=mul(x,x))if(y&1)res=mul(res,x);
	return res;
}
int sz[N],sum[N],inv[N],f[25][N],g[25][N],w[25],p[25],fa[25],deg[25],bin[25];
int lim,n,m,q,u,v;
int find(int x){return fa[x]==x?x:fa[x]=find(fa[x]);}
void dft(int *A){
	for(R int mid=1;mid<lim;mid<<=1)
		for(R int j=0;j<lim;j+=(mid<<1))
			for(R int k=0;k<mid;++k)
				A[j+k+mid]=add(A[j+k+mid],A[j+k]);
}
void idft(int *A){
	for(R int mid=1;mid<lim;mid<<=1)
		for(R int j=0;j<lim;j+=(mid<<1))
			for(R int k=0;k<mid;++k)
				A[j+k+mid]=dec(A[j+k+mid],A[j+k]);
}
int calc(R int S){
	if(!q)return 1;
	R int res=0;
	fp(i,1,n)if(S>>(i-1)&1)res=add(res,w[i]);
	return q&1?res:mul(res,res);
}
bool ck(R int S){
	if(sz[S]==1)return 0;
	int k=sz[S];
	fp(i,1,n)deg[i]=0,fa[i]=i;
	fp(i,1,n)if(S&(1<<i-1)){
		sum[S]+=w[i];
		fp(j,i+1,n)if((S&(1<<j-1))&&(p[i]&(1<<j-1))){
			++deg[i],++deg[j];
			if(find(i)!=find(j))fa[fa[i]]=fa[j],--k;
		}
	}
	sum[S]=q==0?1:q==1?sum[S]:sum[S]*sum[S];
	if(k>1)return true;
	fp(i,1,n)if((S&(1<<i-1))&&(deg[i]&1))return true;
	return false;
}
int main(){
//	freopen("testdata.in","r",stdin);
	n=read(),m=read(),q=read(),lim=(1<<n);
	fp(i,1,m)u=read(),v=read(),p[u]|=(1<<v-1),p[v]|=(1<<u-1);
	fp(i,1,n)w[i]=read();
	fp(i,1,lim-1)sz[i]=sz[i>>1]+(i&1);
	fp(i,1,lim-1){
		g[sz[i]][i]=ck(i)?sum[i]:0;
		inv[i]=ksm(sum[i],P-2);
	}
	fp(i,0,n)dft(g[i]);
	f[0][0]=1,dft(f[0]);
	fp(i,1,n){
		fp(j,0,i-1)fp(k,0,lim-1)f[i][k]=add(f[i][k],mul(f[j][k],g[i-j][k]));
		idft(f[i]);
		fp(k,0,lim-1)f[i][k]=sz[k]==i?mul(f[i][k],inv[k]):0;
		if(i!=n)dft(f[i]);
	}
	printf("%d\n",f[n][lim-1]);
	return 0;
}
```

---

## 作者：Kelin (赞：9)

题目要求的:$\sum[$合法$](\prod_{i=1}^k\frac{\sum_{x\in V_i}w_x}{\sum_{j=1}^i\sum_{x\in V_j}w_x})^p\mod 998244353$

合法条件:$\sum|V_i|=n,|\bigcup V_i|=n,V_i$没有欧拉回路

考虑一个$DP,f_s=\sum_{t\in s}f_{s-t}g_t(\frac{val_t}{val_s})^p$

$f_s$是当前划分集合是$s$的答案,$g_s$表示集合$s$是否合法,$val_s$就是$s$的权值和

可以看出这个$DP$是$3^n$(枚举子集)的

发现这个玩意$\sum_{t\in s}f_{s-t}g_t$是一个子集卷积(不会的转$2015vfk$集训队论文)

$f_s=\sum_{a\bigcup b=s,a\bigcap b=\emptyset}f_ag_b(\frac{val_b}{val_s})^p$

并集可以直接$FMT$然后点乘得到,交集就不好玩了

考虑$a\bigcap b=\emptyset\Rightarrow |a|+|b|=|s|$

这样就可以把交集为空的限制去掉了

$f_{i,s}$表示$s$中$1$的个数是$i$的答案,$g_{i,s}=[s$合法$]*val_s$

$\Rightarrow f_{i,s}g_{i,s}=\sum_{j=0}^{i-1}\sum_{t\in s}f_{j,s-t}g_{i-j,t}$

直接把$f_j,g_{i-j}FMT$一下再点乘一下再$IFMT$一下得到$f_{i,s}g_{i,s}$

再乘以$g_{i,s}$的逆元就可以得到$f_{i,s}$了

最后的答案就是$f_{n,2^n-1}$

其他的看代码把(参考了一下$immortalCO$大佬的代码)

代码里那个怎么判断是不是欧拉回路主要是两点

①:一个点到当前集合的点的数量的奇数个

②:从一点出发,用状压模拟$dfs$,看看能不能走完这个点集

感觉好妙啊,$\%\%\%immortalCO$
```
#include<bits/stdc++.h>
#define fp(i,a,b) for(register int i=a,I=b+1;i<I;++i)
#define fd(i,a,b) for(register int i=a,I=b-1;i>I;--i)
#define go(i,u) for(register int i=fi[u],v=e[i].to;i;v=e[i=e[i].nx].to)
#define file(s) freopen(s".in","r",stdin),freopen(s".out","w",stdout)
template<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}
template<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}
using namespace std;
char ss[1<<17],*A=ss,*B=ss;
inline char gc(){return A==B&&(B=(A=ss)+fread(ss,1,1<<17,stdin),A==B)?-1:*A++;}
template<class T>inline void sd(T&x){
    char c;T y=1;while(c=gc(),(c<48||57<c)&&c!=-1)if(c==45)y=-1;x=c-48;
    while(c=gc(),47<c&&c<58)x=x*10+c-48;x*=y;
}
char sr[1<<21],z[20];int C=-1,Z;
inline void Ot(){fwrite(sr,1,C+1,stdout),C=-1;}
template<class T>inline void we(T x){
    if(C>1<<20)Ot();if(x<0)sr[++C]=45,x=-x;
    while(z[++Z]=x%10+48,x/=10);
    while(sr[++C]=z[Z],--Z);sr[++C]='\n';
}
const int N=22,M=1<<21,P=998244353;
typedef int arr1[N];
typedef int arr2[M];
int n,m,k,S;arr1 e,Mi;arr2 w,g[N],f[N],nx,cnt,pos,iw;long long tp[M];
inline int inv(int x){return x^1?P-1ll*(P/x)*inv(P%x)%P:1;}
inline int fpm(int a){int x=1;for(int b=k;b;b>>=1,a=1ll*a*a%P)if(b&1)x=1ll*x*a%P;return x;}
inline int add(int a,int b){return a+=b,a>=P?a-P:a;}
inline int sub(int a,int b){return a-=b,a<0?a+P:a;}
inline void fmt(int*a,int op(int,int)){
    fp(i,1,n)fp(s,1,S)if(s&Mi[i])
        a[s]=op(a[s],a[s^Mi[i]]);
}
int main(){
    #ifndef ONLINE_JUDGE
        file("walk");
    #endif
    sd(n),sd(m),sd(k);int u,v;
    pos[Mi[1]=1]=1;fp(i,2,n)pos[Mi[i]=Mi[i-1]<<1]=i;
    while(m--)
        sd(u),sd(v),
        e[u]|=Mi[v],e[v]|=Mi[u];
    fp(i,1,n)sd(w[Mi[i]]);S=(1<<n)-1;
    fp(i,1,S)nx[i]=i&-i,cnt[i]=cnt[i^nx[i]]+1;
    fp(s,1,S){
        w[s]=w[nx[s]]+w[s^nx[s]],iw[s]=inv(fpm(w[s]));
        int t=nx[s];
        for(int i=s;i;i-=nx[i])
            if(cnt[e[pos[nx[i]]]&s]&1)goto NotEuler;
        for(int i=nx[s],p;i;)
            p=pos[nx[i]],i-=nx[i],
            i|=e[p]&s&~t,t|=e[p]&s;
        if(s==t)continue;
        NotEuler:g[cnt[s]][s]=fpm(w[s]);
    }f[0][0]=1;fmt(f[0],add);int*a,*b;
    fp(i,1,n){
        fmt(g[i],add);memset(tp,0,8*S+8);
        fp(j,0,i-1){
            a=f[j],b=g[i-j];
            fp(s,0,S)tp[s]+=1ll*a[s]*b[s];
        }a=f[i];
        fp(s,0,S)a[s]=tp[s]%P;
        fmt(a,sub);
        fp(s,0,S)a[s]=1ll*a[s]*iw[s]%P;
        if(i<n)fmt(a,add);
    }
    printf("%d",f[n][S]);
return Ot(),0;
}
```

---

## 作者：约瑟夫用脑玩 (赞：8)

个人感受来说，现有题解都是写给那些会这道题的人看的，所以就像扯点不会的人看的东西（？

大概没有啥前置，~~只要~~理解[不交并卷积](https://www.luogu.com.cn/problem/P6097)的实质就行。

首先观察一个州的满意度，设 $W(S)=\sum_{x\in S}w_x$，则州 $V$ 的满意度即为 $Val(V_i,V)=(\dfrac{W(V)}{W(V)+\sum_{V_i} W(V_i)})^p$，其中 $V_i$ 是划分方案在它前面的州。

注意分母~~比较奇怪~~，有一个 $W(V)$ 是因为定义是：与前面已划分的州合并完后包含了自身的 $W$ 和。

以上或以下的已划分好的方案均默认有州两两不交，即 $\forall V_1,V_2,V_1\cap V_2=\varnothing$，~~写着比较长就不写了~~。

然后注意到一个划分的满意度是州之间的乘积，这就给了 DP 出路，考虑多个划分方案均并上同一个州 $V$，那么满意度可以写作：

$$Val(V_i,V)\times\prod Val(V_i)+Val(V'_ i,V)\times\prod Val(V'_ i)+\cdots$$

不难发现，由于满意度的分母只与目前划分的城市有关，另一种方式的满意度为 $Val(S,V)=(\dfrac{W(V)}{\sum_{x\in S} w_x})^p$，其中 $S$ 即为已划分包括 $V$ 的所有城市集合。

那么用的城市 $S$ 相同的划分方案显然可以一起考虑，上式即写作：

$$=Val(S,V)\times(\prod Val(V_i)+\prod Val(V'_ i)+\cdots),\bigcup V_i=S,\bigcup V'_ i=S,\cdots$$

于是设当前用了 $S$ 的城市的划分方案的满意度之和为 $F(S)=\sum_{\bigcup V=S}\prod Val(V)$，注意 $S$ 定义。

那么这些划分方案都并上州 $V$ 后的满意度之和就是 $Val(S\cup V,V)\times F(S)$，显然转移到 $\to F(S\cup V)$，须满足 $S\cap V=\varnothing$。

之前伏笔了一手，有 $Val(S\cup V)$ 而不是 $Val(S)$，可以再看一眼满意度的定义。

当然州 $V$ 本身得合法，设判断 $V$ 合法的式子为 $G(V)=[V\text{合法}]$，不合法是裸欧拉图判断应该没人不会吧。

于是我们得到了 $O(3^n)$ 的转移式：

$$F(S\cup V)\leftarrow Val(S\cup V,V)\times F(S),G(V)=1,S\cap V=\varnothing$$

复杂度还不太行，考虑直接对转移式下手，但发现一个州的满意度 $Val$ 是个二元的不舒服，直接拆开：

$$F(S\cup V)\leftarrow (\dfrac{W(V)}{\sum_{x\in S\cup V} w_x})^p\times F(S)=\dfrac{W^p(V)\times F(S)}{(\sum_{x\in S\cup V} w_x)^p}$$

于是设 $H(S)=F(S)\times (\sum_{x\in S}w_x)^p$，上式即：

$$H(S\cup V)=W^p(V)\times F(S),G(V)=1,S\cap V=\varnothing$$

这很 FMT，如果没有 $S\cap V=\varnothing$ 就是或卷积，有了是一个[不交并卷积](https://www.luogu.com.cn/problem/P6097)的玩意。

不过你会发现还有一点不对劲，$F$ 的取值与 $H$ 有关，$H$ 又是 $F$ 卷起来的。

回顾一下不交并卷积：二进制位数卷起来，然后正常的 FMT 或起来，利用二进制位数得到或起来该有值的位置。

这个东西每一层二进制位数一样，DP 值互不影响，于是我们可以一层一层的 FMT 或出 $H$，把它转回这一层的 $F$，然后用来或出下一层的 $H$。

最后答案是 $F(U)$ 在最后一层，$U$ 是全集，复杂度是不交并卷积的顶，$O(n^22^n)$。

唯一的坑点竟是不合法的判断，不是欧拉图而是连通的欧拉图，也就是说不连通的欧拉图也是合法的，所以要处理好孤立点，得在这个集合里的才算。

[代码](https://www.luogu.com.cn/paste/lwmlz90k)，感觉完全不卡常啊。（还是得把氧气吸上

---

## 作者：Yansuan_HCl (赞：3)

FWT 题。

记城市集 $S$ 的人口为 $g(S)$，可以列出状压 DP 方程：

$$f(S)=\sum_Tf(S\backslash T)\left(g(T)g(S)^{-1}\right)^p$$

，其中 $T$ 没有欧拉回路或不连通。移出 $g(S)^{-p}$ 可得：

$$f(S)=g(S)^{-p}\sum_Tf(S\backslash T)g(T)^p$$

。直接转移复杂度为 $O(3^n)$ 不可接受。好在这是一个[子集卷积](https://www.luogu.com.cn/problem/P6097)的形式，我们可以枚举 $|S|$ 和 $|T|$ 进行 FMT. 然而，这里有一个转移系数 $g(S)^{-p}$，无法边卷边做。

**考虑钦点转移顺序**——按 $|S|$ 从小到大转移。这样，每次算出 $f(|S|=i)$ 之后，我们可以直接逆变换回原数组，再对于每个 $S$ 乘上转移系数 $g(S)^{-p}$。

```cpp
const ll P = 998244353;
ll qpow(ll x, ll t) { ll v = 1;
	for (; t; (x *= x) %= P, t >>= 1) if (t & 1) (v *= x) %= P;
	return v;
}
void FWTor(ll *f, int lim, ll t) {
	for (int i = 2; i <= lim; i <<= 1)
		for (int j = 0; j < lim; j += i)
			for (int k = 0; k < (i >> 1); ++k)
				(f[j + k + (i >> 1)] += t * f[j + k]) %= P;
}

const int N = (1 << 21) + 1;
int n, m, pw, S;
int mat[25][25];
ll g[25][N], f[25][N], invG[N]; // g has been FWT
int flag[N];
ll w[N];

int fa[25]; int getFa(int p) { return fa[p] == p ? p : fa[p] = getFa(fa[p]); }
void gen() {
	U (s, 1, S) {
		int cnt = __builtin_popcount(s); U (i, 0, n - 1) fa[i] = i;
		int deg[25] {};
		U (i, 0, n - 2) if ((s >> i) & 1)
			U (j, i + 1, n - 1) if (((s >> j) & 1) && mat[i][j]) {
				int fi = getFa(i), fj = getFa(j);
				++deg[i]; ++deg[j];
				if (fi != fj) {
					--cnt;
					fa[fj] = fi;
				}
			}
		if (cnt != 1) { flag[s] = 1; }
		if (!flag[s]) U (i, 0, n - 1) flag[s] |= (deg[i] & 1);
		cnt = __builtin_popcount(s);
		
		U (i, 0, n - 1) if ((s >> i) & 1)
			g[cnt][s] += w[i];		
		g[cnt][s] = qpow(g[cnt][s], pw);
		invG[s] = qpow(g[cnt][s], P - 2);
		if (!flag[s]) g[cnt][s] = 0;
	}
	U (i, 1, n) FWTor(g[i], 1 << n, 1);
}

// f[S]: partitioned cities set S
// f[0] = 1
// g[S]: \sum w \in S

void dp() {
	f[0][0] = 1;
	U (i, 1, n) {
		FWTor(f[i - 1], 1 << n, 1);
		U (p, 1, i) 
			U (s, 0, S)
				(f[i][s] += f[i - p][s] * g[p][s]) %= P;
				
		FWTor(f[i], 1 << n, P - 1);
		U (s, 0, S)
			(f[i][s] *= invG[s]) %= P;
	}
}
	
int main() {	
	rd(n, m, pw); S = (1 << n) - 1;
	U (i, 1, m) {
		int u, v; rd(u, v); --u, --v;
		mat[u][v] = mat[v][u] = 1;
	}
	U (i, 0, n - 1) rd(w[i]);
	
	gen();	
	dp();
	printf("%lld", f[n][S]);
}
```

---

## 作者：Great_Influence (赞：3)

来一发FMT的题解。

这道题目其实并不难，但是考的考点非常偏。。。(松松松:这次没有卡常了)

可以发现，这道题显然可以用dp来解决。设$dp[S]$表示已经分了$S$这个子集的答案，$sum[S]$为$S$中元素的权值之和，$g[S]$为$sum[S]$乘以该子集是否没有欧拉回路，则存在以下转移式:

$\displaystyle dp[S]=\frac{1}{sum[S]^p}\sum_{T\in S}g[T]*dp[S-T]$

发现满足子集卷积形式。直接枚举子集转移为$3^nn^2$的，无法通过此题。但是利用$FWT$或者$FST$或者$FMT$都可以优化成$2^nn^2$，便可以通过了。

$FMT$为快速莫比乌斯变换，正操作可以将一个子集的权值转为某种点值形式(和$DFT$差不多)，逆操作则是将正操作得到的点值转回子集权值(和$IDFT$差不多)。转成的点值可以加减乘除，对应子集的加减乘除。对于本题，只要打一个子集乘就可以了。

记得至少需要转移$n-1$次，因为最多可以划出$n-1$个州。

代码:

```cpp
#include<bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp>
#define Rep(i,a,b) for(register int i=(a),i##end=(b);i<=i##end;++i)
#define Repe(i,a,b) for(register int i=(a),i##end=(b);i>=i##end;--i)
#define For(i,a,b) for(i=(a),i<=(b);++i)
#define Forward(i,a,b) for(i=(a),i>=(b);--i)
template<typename T>inline void read(T &x)
{
    T f=1;x=0;char c;
    for(c=getchar();!isdigit(c);c=getchar())if(c=='-')f=-1;
    for(;isdigit(c);c=getchar())x=x*10+(c^48);
    x*=f;
}
using namespace std;

static int n,m,P,w[31];

static int p[31];

inline void init()
{
    read(n);read(m);read(P);
    static int u,v;
    Rep(i,1,m)read(u),read(v),p[u]|=1<<v-1,p[v]|=1<<u-1;
    Rep(i,1,n)read(w[i]);
}

const int mod=998244353;

typedef long long ll;

inline int power(int a,int b)
{
    static int sm;
    for(sm=1;b;b>>=1,a=(ll)a*a%mod)if(b&1)
        sm=(ll)sm*a%mod;
    return sm;
}


static int Len;

inline int ad(int u,int v){return (u+=v)>=mod?u-mod:u;}

inline void FMT(int *a)
{
    for(register int z=1;z<Len;z<<=1)
        Rep(j,0,Len-1)if(z&j)a[j]=ad(a[j],a[j^z]);
}

inline void IFMT(int *a)
{
    for(register int z=1;z<Len;z<<=1)
        Rep(j,0,Len-1)if(z&j)a[j]=ad(a[j],mod-a[j^z]);
}
static int bit[1<<21],S[1<<21],fa[23],inv[1<<21];

int find(int x){return x==fa[x]?x:fa[x]=find(fa[x]);}


static int dp[22][1<<21],g[22][1<<21];

static int sta[23],tp;

inline int check(int x)
{
    if(bit[x]==1)return 0;tp=0;
    static int now,u,v;
    Rep(i,1,n)if(x&(1<<i-1))
    {
        sta[++tp]=i;
        now=x&p[i];
        if(!now||bit[now]&1)return 1;
    }
    Rep(i,1,tp)fa[sta[i]]=sta[i];
    Rep(i,1,tp)Rep(j,1,tp)if(p[sta[i]]&(1<<sta[j]-1))
        if((u=find(sta[i]))^(v=find(sta[j])))fa[u]=v;
    Rep(i,1,tp)if(find(sta[i])^fa[sta[1]])return 1;
    return 0;
}

inline int calc(int x)
{
    if(!P)return 1;
    static int sm;sm=0;
    Rep(i,1,n)if(x&(1<<i-1))sm=ad(sm,w[i]);
    if(P==1)return sm;
    return sm*sm;
}

inline void solve()
{
    static int sm,flag,u,v;
    Len=1<<n;
    Rep(i,1,Len-1)bit[i]=bit[i>>1]+(i&1);
    Rep(i,1,Len-1)
    {
        S[i]=calc(i);
        g[bit[i]][i]=check(i)?S[i]:0;
        inv[i]=power(S[i],mod-2);
    }
    dp[0][0]=1;FMT(dp[0]);
    Rep(i,1,n)FMT(g[i]);
    Rep(i,1,n)
    {
    	int *f=dp[i];
        Rep(j,0,i-1)
        {
            int *a=dp[j],*b=g[i-j];
            Rep(k,0,Len-1)f[k]=ad((ll)a[k]*b[k]%mod,f[k]);
        }
        IFMT(f);
        Rep(k,0,Len-1)f[k]=i==bit[k]?(ll)f[k]*inv[k]%mod:0;
        if(i^n)FMT(f);
    }
    printf("%d\n",dp[n][Len-1]);
}

int main()
{
    init();
    solve();
    return 0;
}
```

---

## 作者：lhm_ (赞：2)

一个州不合法为其内部有欧拉回路，即图连通且每个点度数都为偶数。

$n$ 很小，考虑用状压 $DP$ 解决本题，设 $f_S$ 为集合 $S$ 的答案，$ g_S $ 为集合 $S$ 的 $w$ 和的 $p$ 次方。

得转移方程为：

$$
	f_S= \frac{1}{g_S} \sum_{ T \subset S } f_T g_{S-T}
$$

其中 $S,T,S-T$ 都为合法的集合。直接枚举子集转移是 $O(n^3)$，复杂度无法接受，观察式子后，发现用子集卷积优化即可，

$code:$

```cpp
#include<bits/stdc++.h>
#define maxn 25
#define maxm 510
#define maxs 2400010
#define p 998244353
#define lowbit(x) (x&(-x))
using namespace std;
typedef long long ll;
template<typename T> inline void read(T &x)
{
    x=0;char c=getchar();bool flag=false;
    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}
    while(isdigit(c)){x=(x<<1)+(x<<3)+(c^48);c=getchar();}
    if(flag)x=-x;
}
ll n,m,k,all;
ll v[maxn],fa[maxn],d[maxn];
ll f[maxn][maxs],g[maxn][maxs],sum[maxs],inv[maxs],cnt[maxs];
struct edge
{
    int x,y;
}e[maxm];
int find(int x)
{
    return fa[x]==x?x:fa[x]=find(fa[x]);
}
void FWT(ll *a,int type)
{
    for(int len=1;len<all;len<<=1)
        for(int i=0;i<all;i+=len<<1)
            for(int j=i;j<i+len;++j)
                a[j+len]=(a[j+len]+a[j]*type+p)%p;
}
ll qp(ll x,ll y)
{
    ll v=1;
    while(y)
    {
        if(y&1) v=v*x%p;
        x=x*x%p,y>>=1;
    }
    return v;
}
bool check(int s)
{
    if(cnt[s]<=1) return false;
    memset(d,0,sizeof(d));
    for(int i=1;i<=n;++i) fa[i]=i;
    int num=0;
    for(int i=1;i<=m;++i)
    {
        int x=e[i].x,y=e[i].y;
        if(!(s&(1<<(x-1)))||!(s&(1<<(y-1)))) continue;
        if(find(x)!=find(y)) fa[find(x)]=find(y),num++;
        d[x]++,d[y]++;
    }
    if(num!=cnt[s]-1) return true;
    for(int i=1;i<=n;++i)
        if(d[i]&1)
            return true;
    return false;
}
int main()
{
    read(n),read(m),read(k),all=1<<n;
    for(int i=1;i<all;++i) cnt[i]=cnt[i-lowbit(i)]+1;
    for(int i=1;i<=m;++i) read(e[i].x),read(e[i].y);
    for(int i=1;i<=n;++i) read(v[i]);
    for(int s=0;s<all;++s)
    {
        for(int i=1;i<=n;++i)
            if(s&(1<<(i-1)))
                sum[s]+=v[i];
        sum[s]=qp(sum[s],k),inv[s]=qp(sum[s],p-2);
        if(check(s)) g[cnt[s]][s]=sum[s];
    }
    f[0][0]=1,FWT(f[0],1);
    for(int i=0;i<=n;++i) FWT(g[i],1);
    for(int i=1;i<=n;++i)
    {
        for(int j=0;j<i;++j)
            for(int s=0;s<all;++s)
                f[i][s]=(f[i][s]+f[j][s]*g[i-j][s]%p)%p;
        FWT(f[i],-1);
        for(int s=0;s<all;++s) f[i][s]=f[i][s]*inv[s]%p;
        FWT(f[i],1);
    }
    FWT(f[n],-1),printf("%lld",f[n][all-1]);
    return 0;
}
```

---

## 作者：Mihari (赞：2)

# 题目

[传送门](https://www.luogu.com.cn/problem/P4221)

# 题解

首先，作为一位 $\text{OIer}$ 你首先需要的是能够判断

>如果一个州内部存在一条起点终点相同，不经过任何不属于这个州的城市，且经过这个州的所有内部道路都恰好一次并且经过这个州的所有城市至少一次的路径（路径长度可以为 $0$），则称这个州是不合法的。

这句话是指我们划分出来的某个州内部不存在欧拉回路。

如何判断？只需要判断两个条件：

1. 没有奇数度的点；
2. 州是连通的；

满足这两个条件，这个州就是不合法的。

注意到 $n\le 21$，那么我们可以暴力 $\mathcal O(m\times 2^n)$ 处理出所有划分方案的合法性，以及每个划分方案的贡献。

接下来，我们想如何解决这道题。

定义 $dp[s]$ 表示所有州划分过的城市构成 $i$ 的二进制串，那么我们就有
$$
dp[s]=\sum_{i\mid j=s,i\&j=0} dp[i]\times \text{calc}(s,s-i)
$$
这里的 $\text{calc}(s,s-i)$ 就是我们的某一个州划分为 $s-i$ 时的满意度，不难得到
$$
\begin{aligned}
\text{calc}(s,s-i)&=\left (\frac{sum[s-i]}{sum[s]} \right )^p \\
&=\frac{(sum[s-i])^p}{(sum[s])^p} \\
\end{aligned}
$$
把它代回原来的状转，可得
$$
\begin{aligned}
dp[s]=\sum_{i\mid j=s,i\&j=0} dp[i]\times\frac{(sum[s-i])^p}{(sum[s])^p}
\end{aligned}
$$
由于 $\frac{1}{(sum[s])^p}$ 与 $i$ 无关，考虑弄到左边去，可得
$$
sum[s]\times dp[s]=\sum_{i\mid j=s,i\&j=0} dp[i]\times (sum[s-i])^p
$$
这就是标准的子集卷积了，用相同的方法进行处理之后，乘上 $\text{inv}(sum[s])$ 就可以得到 $dp[s]$ 了。

# 代码

```cpp
#include<cstdio>
#include<iostream>
using namespace std;

const int MAXN=21;
const int MAXM=(MAXN*(MAXN-1))>>1;
const int MOD=998244353;
const int MAXSIZE=1<<MAXN;

inline void DWT_or(int a[],const int N,const int opt){
    for(int t=2;t<=N;t<<=1)
        for(int i=0,p=t>>1;i<N;i+=t)for(int j=i;j<i+p;++j){
            a[j+p]+=a[j]*opt;
            if(a[j+p]>=MOD)a[j+p]-=MOD;
            else if(a[j+p]<0)a[j+p]+=MOD;
        }
}

struct edge{int u,v;}e[MAXM+5];
int w[MAXN+5],sum[MAXSIZE+5],sz[MAXN+5][MAXSIZE+5];
int tsum[MAXSIZE+5];

int n,m,p;

inline void Init(){
    scanf("%d %d %d",&n,&m,&p);
    int u,v;
    for(int i=1;i<=m;++i){
        scanf("%d %d",&u,&v);
        e[i]=edge{u-1,v-1};
    }
    for(int i=0;i<n;++i)scanf("%d",&w[i]);
}
/*
void print(const int s){
    for(int i=n-1;i>=0;--i){
        if((s>>i)&1)printf("1");
        else printf("0");
    }putchar('\n');
}
*/
bool vis[MAXN+5];
int d[MAXN+5];

int pre[MAXN+5],siz[MAXN+5];
int findSet(const int u){
    return pre[u]==u?u:pre[u]=findSet(pre[u]);
}
inline void unionSet(const int u,const int v){
    int x=findSet(u),y=findSet(v);
    if(x^y){
        pre[x]=y;
        siz[y]+=siz[x];
    }
}

inline void calc(const int s){
    //printf("get a kind of situation : ");print(s);
    /*
    for(int i=0;i<n;i++)
        cout<<vis[i]<<' ';
    cout<<'\n';
    */
    for(int i=0;i<n;++i){
        if(vis[i])d[i]=0,pre[i]=i,siz[i]=1;
        else d[i]=-1;
    }
    for(int i=1;i<=m;++i)if(vis[e[i].u] && vis[e[i].v])
        ++d[e[i].u],++d[e[i].v],unionSet(e[i].u,e[i].v);
    bool flg=true;
    int all=-1,cnt=0;
    for(int i=0;i<n;++i)if(vis[i]){
        ++cnt;
        all=siz[findSet(i)];
        if(d[i]&1)flg=false;
        sum[s]+=w[i];
        if(sum[s]>=MOD)sum[s]-=MOD;
    }tsum[s]=sum[s];
    if(flg && all==cnt)sum[s]=0;
}
void dfs(const int now,const int s){
    if(now==n)return calc(s);
    dfs(now+1,s<<1);
    vis[now]=true;
    dfs(now+1,s<<1|1);
    vis[now]=false;
}

int dp[MAXN+5][MAXSIZE+5];
int bitcnt[MAXSIZE+5];

inline int inv(int n,int m=MOD-2){
    int ret=1;
    for(;m>0;m>>=1){
        if(m&1)ret=1ll*ret*n%MOD;
        n=1ll*n*n%MOD;
    }return ret;
}

signed main(){
    Init();
    dfs(0,0);
    for(int i=1;i<=MAXSIZE;++i)bitcnt[i]=bitcnt[i>>1]+(i&1);
    dp[0][0]=1;
    DWT_or(dp[0],1<<n,1);
    for(int i=0;i<(1<<n);++i){
        if(p==0)sz[bitcnt[i]][i]=sum[i]=(sum[i]==0?0:1),tsum[i]=1;
        else if(p==1)sz[bitcnt[i]][i]=sum[i];
        else if(p==2)sz[bitcnt[i]][i]=1ll*sum[i]*sum[i]%MOD,sum[i]=sz[bitcnt[i]][i],tsum[i]=1ll*tsum[i]*tsum[i]%MOD/*,cout<<sz[bitcnt[i]][i]<<'\n'*/;
        tsum[i]=inv(tsum[i]);
    }

    for(int i=0;i<=n;i++)
        DWT_or(sz[i],1<<n,1);
    
    for(int i=1;i<=n;++i){
        for(int j=0;j<i;++j)
        for(int k=0;k<(1<<n);++k){
            dp[i][k]=dp[i][k]+1ll*dp[j][k]*sz[i-j][k]%MOD;
            if(dp[i][k]>=MOD)dp[i][k]-=MOD;
        }
        DWT_or(dp[i],1<<n,-1);
        for(int k=0;k<(1<<n);++k){
            dp[i][k]=1ll*dp[i][k]*tsum[k]%MOD;
            if(bitcnt[k]^i)dp[i][k]=0;
        }
        DWT_or(dp[i],1<<n,1);
    }
    DWT_or(dp[n],1<<n,-1);
    printf("%d\n",dp[n][(1<<n)-1]);
    return 0;
}
```



---

## 作者：eastcloud (赞：0)

[更好的阅读体验](https://www.cnblogs.com/eastcloud/p/17249376.html)

## 题目描述

给出 $n$ 个城市，$m$ 条边，一个划分合法当且仅当所有划分中的点集和集合中点之间存在的边集所构成的图不构成欧拉回路且联通。

定义一个点集的值为 
![](https://cdn.luogu.com.cn/upload/image_hosting/ft44pcog.png)

划分的总值为其中所有点集的值之积，求所有合法划分的值之和。

## 题目分析

看到数据范围以及题目描述，不难想到使用状压 dp 解决此问题，首先对于每种状态判断是否合法，再枚举当前总状态和最后一个加进来的状态。

设当前状态为 $i$，枚举出的子集状态为 $j$，保证其合法，状态集合大小记为 $siz_i$，可以得到以下状态转移方程：

$f_i=\sum_{i\bigcap j=j}f_j(\frac{siz_j}{siz_i})^p$

时间复杂度为 $O(3^n)$，还无法通过本题。

继续观察柿子，如果把后面的乘数拆开分别处理，一个放到等式左边，一个另起一个函数，就会发现这其实就是一个子集卷积，卷完左边后对于右边部分乘上逆元恢复就行。

还有一个问题，这个柿子中 $f$ 会自己卷自己，不过发现卷积中只会用到比自己 1 的个数少的状态，只需要一边卷一边处理即可。

## 代码

```
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<cstring>
#include<queue>
#define N 35
#define ll long long
using namespace std;
ll e,head[50000],nex[50000],to[50000];
ll val[N],g[22][(1<<22)];
ll vis[N],f[22][(1<<22)];
ll inv[(1<<22)];
ll n;
const ll mod=998244353;
queue<ll> q;
ll qp(ll x,ll y){
	ll ans=1;
	while(y){
		if(y&1) ans=(ans*x)%mod;
		x=(x*x)%mod;
		y>>=1;
	}
	return ans;
}
void add(ll u,ll v){
	to[++e]=v;nex[e]=head[u];head[u]=e;
	to[++e]=u;nex[e]=head[v];head[v]=e;
}
bool jud(ll x){
	if(x==0) return false;
	while(q.size()) q.pop();
	for(ll i=1;i<=n;i++) vis[i]=0;
	for(ll i=1;i<=n;i++)if((1<<(i-1))&x){q.push(i);break;}
	while(q.size()){
		ll u=q.front();q.pop();if(vis[u])continue;vis[u]++;
		for(int i=head[u];i;i=nex[i]){
			int v=to[i];
			if((1<<(v-1))&x && !vis[v]) q.push(v);
		}
	}
	for(ll i=0;i<n;i++) if((1<<i)&x && !vis[i+1]) return true;
	for(ll i=0;i<=n;i++){
		if(x&(1<<i)){
			int cnt=0;
			for(ll j=head[i+1];j;j=nex[j]){
				ll v=to[j];
				if((1<<(v-1))&x) cnt++;
			}
			if(cnt%2) return true;
		}
	}
	return false;
}
ll sum(ll x){
	ll ans=0;
	for(ll i=0;i<n;i++) if(x&(1<<i)) ans+=val[i+1];
	return ans;
}
void fwt(ll *f,ll opt){
	for(ll mid=1,R=2;R<=(1<<n);R<<=1,mid<<=1){
		for(ll j=0;j<(1<<n);j+=R){
			for(ll k=0;k<mid;k++){
				if(opt==1) f[j+k+mid]=(f[j+k+mid]+f[j+k])%mod;
				else f[j+k+mid]=(f[j+k+mid]-f[j+k]+mod)%mod;
			}
		}
	}
}
inline int read(){
    int x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
        if(ch=='-')
            f=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        x=(x<<1)+(x<<3)+(ch^48);
        ch=getchar();
    }
    return x*f;
}
int main(){
	ll m,p,u,v;
	n=read();m=read();p=read();
	for(ll i=1;i<=m;i++){
		u=read();v=read();
		add(u,v);
	}
	for(ll i=0;i<n;i++) val[i+1]=read();
	for(ll i=0;i<(1<<n);i++){
		if(jud(i)) g[__builtin_popcount(i)][i]=qp(sum(i),p);
		inv[i]=qp(qp(sum(i),mod-2),p);
	}
	f[0][0]=1;fwt(f[0],1);
	for(ll i=0;i<=n;i++) fwt(g[i],1);
	for(ll i=1;i<=n;i++){
		for(ll j=0;j<i;j++){
			for(ll k=0;k<(1<<n);k++){
				f[i][k]+=(f[j][k]*g[i-j][k])%mod;
				f[i][k]%=mod;
			}
		}
		fwt(f[i],-1);
		for(ll j=0;j<(1<<n);j++){
			if(__builtin_popcount(j)==i)f[i][j]=(f[i][j]*inv[j])%mod;
			else f[i][j]=0;
		}
		if(i!=n)fwt(f[i],1);
	}
	cout<<f[n][(1<<n)-1];
}
```


---


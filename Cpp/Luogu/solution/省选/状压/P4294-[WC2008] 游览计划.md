# [WC2008] 游览计划

## 题目背景

UPD：

- @panda_2134 提供 Special Judge；

- @yzy1 提供了[两组 hack 数据](https://www.luogu.com.cn/discuss/527294)，即不算分的 subtask1；

- @kradcigam [完善](https://www.luogu.com.cn/discuss/873182)了 Special Judge。

## 题目描述

从未来过绍兴的小D有幸参加了Winter Camp 2008，他被这座历史名城的秀丽风景所吸引，强烈要求游览绍兴及其周边的所有景点。

主办者将绍兴划分为N行M列(N×M)个分块，如下图(8×8)：

![](https://cdn.luogu.com.cn/upload/pic/15472.png)

景点含于方块内，且一个方块至多有一个景点。无景点的方块视为路。

为了保证安全与便利，主办方依据路况和治安状况，在非景点的一些方块内安排不同数量的志愿者；在景点内聘请导游（导游不是志愿者）。在选择旅游方案时，保证任意两个景点之间，存在一条路径，在这条路径所经过的每一个方块都有志愿者或者该方块为景点。既能满足选手们游览的需要，又能够让志愿者的总数最少。

例如，在上面的例子中，在每个没有景点的方块中填入一个数字，表示控制该方块最少需要的志愿者数目：

![](https://cdn.luogu.com.cn/upload/pic/15473.png)

图中用深色标出的方块区域就是一种可行的志愿者安排方案，一共需要20名志愿者。由图可见，两个相邻的景点是直接（有景点内的路）连通的（如沈园和八字桥）。

现在，希望你能够帮助主办方找到一种最好的安排方案。

## 说明/提示

所有的 10 组数据中 N, M ，以及景点数 K 的范围规定如下：

![](https://cdn.luogu.com.cn/upload/pic/15474.png)

输入文件中的所有整数均不小于 0 且不超过 2^16。



## 样例 #1

### 输入

```
4 4
0 1 1 0
2 5 5 1
1 5 5 1
0 1 1 0```

### 输出

```
6
xoox
___o
___o
xoox```

# 题解

## 作者：RabbitHu (赞：35)

## 题解

这道题是【斯坦纳树】的经典例题。斯坦纳树是这样一类问题：带边权无向图上有几个（一般约10个）点是【关键点】，要求选择一些边使这些点在同一个联通块内，同时要求所选的边的边权和最小。

怎么解决斯坦纳树问题？……其实，就是一种状压DP。

$dp[i][j]$表示以i号节点为根，当前状态为j（j的二进制中已经与i连通的点对应位置为1）。

这个“以i为根”是哪来的呢？其实i可以是联通块中任意一个点，没有额外限制，只是引入这个i就可以DP了。

当根i不改变时（即合并两个都包含i的联通块）状态转移方程是：

$$dp[i][j] = \min_{s \in j}\{dp[i][s] + dp[i][\complement_js] - val[i]\}$$ 

（$val[i]$表示本题中i号点的权值，减去一个是因为$dp[i][s]$和$dp[i][\complement_js]$中都含有i号点的权值，要防止“加重了”）

当根改变时（即在原有联通块中加入一个新节点i并设置为根，要求i、k相邻）：

$$dp[i][j] = \min\{dp[k][j] + val[i]\}$$

第一个状态转移方程有顺序，可以直接DP；而第二个状态转移方程没有明显顺序，但可以按照最短路的SPFA算法“DP”（神奇！）。

## 代码

```cpp
#include <cstdio>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <iostream>
#include <queue>
#define space putchar(' ')
#define enter putchar('\n')
using namespace std;
typedef long long ll;
template <class T>
void read(T &x){
    char c;
    bool op = 0;
    while(c = getchar(), c < '0' || c > '9')
    if(c == '-') op = 1;
    x = c - '0';
    while(c = getchar(), c >= '0' && c <= '9')
    x = x * 10 + c - '0';
    if(op) x = -x;
}
template <class T>
void write(T x){
    if(x < 0) putchar('-'), x = -x;
    if(x >= 10) write(x / 10);
    putchar('0' + x % 10);
}

const int INF = 0x3f3f3f3f;
int n, m, K, root, f[101][1111], a[101], ans[11][11];
bool inq[101];
typedef pair<int, int> par;
typedef pair<par, int> rec;
#define fi first
#define se second
#define mp make_pair
#define num(u) (u.fi * m + u.se)
rec pre[101][1111];
const int dx[] = {0, 0, -1, 1};
const int dy[] = {1, -1, 0, 0};
queue<par> que;

bool legal(par u){
    return u.fi >= 0 && u.se >= 0 && u.fi < n && u.se < m;
}
void spfa(int now){
    while(!que.empty()){
	par u = que.front();
	que.pop();
	inq[num(u)] = 0;
	for(int d = 0; d < 4; d++){
	    par v = mp(u.fi + dx[d], u.se + dy[d]);
	    int nu = num(u), nv = num(v);
	    if(legal(v) && f[nv][now] > f[nu][now] + a[nv]){
		f[nv][now] = f[nu][now] + a[nv];
		if(!inq[nv]) inq[nv] = 1, que.push(v);
		pre[nv][now] = mp(u, now);
	    }
	}
    }
}
void dfs(par u, int now){
    if(!pre[num(u)][now].se) return;
    ans[u.fi][u.se] = 1;
    int nu = num(u);
    if(pre[nu][now].fi == u) dfs(u, now ^ pre[nu][now].se);
    dfs(pre[nu][now].fi, pre[nu][now].se);
}

int main(){

    read(n), read(m);
    memset(f, 0x3f, sizeof(f));
    for(int i = 0, tot = 0; i < n; i++)
	for(int j = 0; j < m; j++){
	    read(a[tot]);
	    if(!a[tot]) f[tot][1 << (K++)] = 0, root = tot;
	    tot++;
	}
    for(int now = 1; now < (1 << K); now++){
	for(int i = 0; i < n * m; i++){
	    for(int s = now & (now - 1); s; s = now & (s - 1))
		if(f[i][now] > f[i][s] + f[i][now ^ s] - a[i]){
		    f[i][now] = f[i][s] + f[i][now ^ s] - a[i];
		    pre[i][now] = mp(mp(i / m, i % m), s);
		}
	    if(f[i][now] < INF)
		que.push(mp(i / m, i % m)), inq[i] = 1;
	}
	spfa(now);
    }
    write(f[root][(1 << K) - 1]), enter;
    dfs(mp(root / m, root % m), (1 << K) - 1);
    for(int i = 0, tot = 0; i < n; i++){
	for(int j = 0; j < m; j++)
	    if(!a[tot++]) putchar('x');
	    else putchar(ans[i][j] ? 'o' : '_');
	enter;
    }

    return 0;
}
```

---

## 作者：tommymio (赞：12)

这题实质上就是求点权之和最小的斯坦纳树。

把二维坐标映射成一维坐标，再建好边，就和斯坦纳树的做法差不多了。

和模板的套路一样，设 $f_{i,S}$ 为以 $i$ 为根的树，包含了给出点集中的子集 $S$，能够得到的最小点权和。

- $f_{i,S}=\min \{f_{i,S},f_{j,S}+a_i\}$ (1).
- $f_{i,S}=\min\{f_{i,S},f_{j,S-S'}+f_{i,S'}\}(S' \subset S)$ (2). 

同样，第一个式子我们仍然使用 $\text{dijistra}$ 进行松弛，但第二个式子要做出一定的变化，不再是求边权和最小时的 $f_{i,S} = min\{f_{i,S'}+f_{i,S-S'}\}$。由于这题的要求变为求点权之和最小，所以在合并的时候，如果照搬上式，同一个点权 $a_i$ 可能会被重复累加两遍，我们需要在合并的时候减去多累加的那一次，即 $f_{i,S}= \min \{f_{i,S},f_{i,S'}+f_{i,S-S'}-a_i\}$(3)。

这题的难点并不在于如何求出答案，而在于打印方案。

观察一下两个DP式子，发现(1)式是一个是三角形不等式，(3)式是一个递推式。

于是就可以考虑用不同的方法来处理这两个式子，对于第一个式子，我们记录下上一个转移过来的节点，这样就可以形成一条链，链上的点可能又由(3)式转移而来。对于第二个式子，我们直接递归求解。所以两种方法结合起来，就是这题打印方案的方法。

打印方案的具体思路可以看代码，我认为是写的很清楚的了，如果还不懂可以直接私信本人。

**Show the Code**

```cpp
#include<cstdio>
#include<queue>
#include<cstring>
#include<functional>
#define id(x,y) ((x)*m+(y))
#define min(a,b) ((a)<(b)? (a):(b))
const int inf=0x3f3f3f3f;
int cnt=0;
int a[105],vis[105],mp[105],b[105][1<<10],f[105][1<<10],pre[105][1<<10];
int h[105],to[2005],ver[2005];
std::priority_queue<std::pair<int,int> > Q;
inline int read() {
	register int x=0,f=1;register char s=getchar();
	while(s>'9'||s<'0') {if(s=='-') f=-1;s=getchar();}
	while(s>='0'&&s<='9') {x=x*10+s-'0';s=getchar();}
	return x*f;
}
inline void add(int x,int y) {
	to[++cnt]=y;
	ver[cnt]=h[x];
	h[x]=cnt;
}
inline void print(int x) {int a[25];a[0]=0;while(x) {a[++a[0]]=x&1;x>>=1;}while(a[0]) {printf("%d",a[a[0]--]);}printf(" ");}
inline void dijistra(int S) {
	while(Q.size()) {
		int x=Q.top().second;Q.pop();
		if(vis[x]) continue;
		vis[x]=1;
		for(register int i=h[x];i;i=ver[i]) {
			int y=to[i];
			if(f[y][S]>f[x][S]+a[y]) Q.push(std::make_pair(-(f[y][S]=f[x][S]+a[y]),y)),pre[y][S]=x;
		}
	}
}
void dfs(int x,int S) {
	if(b[x][S]) return;
	b[x][S]=1;
	mp[x]=1;
	if(pre[x][S]!=-1&&f[pre[x][S]][S]+a[x]==f[x][S]) {
		int tmp=pre[x][S];
		while(tmp!=-1) {dfs(tmp,S);tmp=pre[tmp][S];}
	}
	for(register int S0=S;S0>=0;--S0) {
		if((S0|S)!=S) continue;
		if(f[x][S]==f[x][S0]+f[x][S-S0]-a[x]) {dfs(x,S0);dfs(x,S^S0);break;}
	}
}
int main() {
	int n=read(),m=read(),k=0,pos=-1;
	memset(f,0x3f,sizeof(f));
	memset(pre,-1,sizeof(pre));
	for(register int i=0;i<n;++i) {
		for(register int j=0;j<m;++j) {
			if(!(a[id(i,j)]=read())) f[id(i,j)][1<<((++k)-1)]=0,pos=id(i,j);
			if(i-1>=0) {
				add(id(i-1,j),id(i,j));
				add(id(i,j),id(i-1,j));
			}
			if(j-1>=0) {
				add(id(i,j-1),id(i,j));
				add(id(i,j),id(i,j-1));
			}
		}
	}
	for(register int S=1;S<(1<<k);++S) {
		for(register int i=0;i<n*m;++i) {
			for(register int S0=S;S0>=0;--S0) {
				if((S0|S)!=S) continue;
				f[i][S]=min(f[i][S],f[i][S0]+f[i][S-S0]-a[i]);//+a[i]*2 -> must -a[i]
			}
			vis[i]=0;
			if(f[i][S]!=inf) Q.push(std::make_pair(-f[i][S],i));
		}
		dijistra(S);
	}
	if(pos!=-1) printf("%d\n",f[pos][(1<<k)-1]);
	else printf("0\n");
	dfs(pos,(1<<k)-1);
	for(register int i=0;i<n;++i) {
		for(register int j=0;j<m;++j) {
			int x=id(i,j);
			if(a[x]&&mp[x]) printf("o");
			if(a[x]&&(!mp[x])) printf("_");
			if(!a[x]) printf("x");
		}
		if(i!=n-1) printf("\n");
	} 
	return 0;
}
```

---

## 作者：w36557658 (赞：7)

发现spj好了之后，经过多次的修改简化与注释，我终于边复习了一遍插头dp边用插头dp的最小表示法正式AC本题。

欢迎访问我的博客：http://www.cnblogs.com/luyouqi233/p/8258525.html

对插头dp的简要讲解：http://www.cnblogs.com/luyouqi233/p/8256778.html

本题解参考自：http://www.sigongzi.org/index.php/archives/jiyuliantongxingdezhuangtaiyasuodongtaiguihua.html

（请注意参考博客代码有一些小问题，后面有hack数据。）

看到又是格子又是路径联通等等之类的条件，加上我们又学过插头dp而不会斯坦纳树这个算法（比如我），我们应该能想到使用插头dp。

而且如果没有学过括号表示法插头dp的独立插头（比如我），那么也没有关系，牺牲常数选用最小表示法也是可以的。

但是我们最开始学的插头dp只能解决哈密顿回路啊根本没有这道题这么复杂这可怎么办？

别慌，我们慢慢理：

1.景点是必须要取的（插头不能为“0”）。

2.路径必须是互相联通的线段。

对于1，我们强制不让这个格子不放插头即可。

对于2，我们考虑如果我们当前格子的上插头在轮廓线再没有与之相连通的插头，此时我们不选当前格子的话我们就将分开成两条路径了，所以必须要取；但是如果是左插头的话如果不取的话是可能符合2的。

（如果不是很好理解的话动手画图吧。）

另外还要注意的是当我们已经把所有的景点都扫完时，之后的状态就都有可能构成一种方案，所以要时刻更新（这也是参考博客代码的错误。）

然后正常插头dp即可，部分细节写在了代码注释里。

emmmm你要问我复杂度的话我也不知道呀！

```
// luogu-judger-enable-o2
#include<cstdio>
#include<cstring>
using namespace std;
const int INF=2147483647;
const int mod=999983;
const int N=11;
const int M=1000005;
struct node{//哈希表 
    int nxt;
    int state,ans,pos,pre;//状态，答案，编号，前一个状态 
    bool choose;//是否选择该方块 
}edge[M];
int head[mod+1],cnt;
int lcnt,rcnt;
void insert(int now,int num,int ppos,int last,bool flag){
    int u=now%mod;
    for(int i=head[u];i;i=edge[i].nxt){
        if(edge[i].state==now){
            if(num<edge[i].ans){
                edge[i].ans=num;
                edge[i].pos=ppos;
                edge[i].pre=last;
                edge[i].choose=flag;
            }
            return;
        }
    }
    edge[++cnt].nxt=head[u];
    head[u]=cnt;
    edge[cnt].state=now;
    edge[cnt].ans=num;
    edge[cnt].pos=ppos;
    edge[cnt].pre=last;
    edge[cnt].choose=flag;
    return;
}
bool g[N][N];
int w[N],cntt;
int n,m,lastedge,e1,e2;
int mp[N][N];
int mapp[N];
inline void decode(int now){
    for(int i=m;i>=1;i--){
    	w[i]=now&7;
    	now>>=3;
    }
    return;
}
inline int encode(){
    int x=0,tot=0;
    memset(mapp,-1,sizeof(mapp));
    mapp[0]=0;
    for(int i=1;i<=m;i++){
        if(mapp[w[i]]==-1)mapp[w[i]]=++tot;
        w[i]=mapp[w[i]];
        x=x<<3|w[i]; 
    }
    return x;
}
inline void init(){
    memset(head,0,sizeof(head));
    lcnt=rcnt+1;rcnt=cnt;
    return;
}
inline void getans(){
    for(int k=lcnt;k<=rcnt;k++){
        int now=edge[k].state;
        int num=edge[k].ans;
        decode(now);
        bool flag=1;
        for(int l=1;l<=m&&flag;l++){
            if(w[l]>1)flag=0;
        }
        if(num<cntt&&flag){
            cntt=num;
            lastedge=k;
        }
    }
    return;
}
void plugdp(){
    insert(0,0,101,0,0);
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            init();
           	if(i>e1||(i==e1&&j>e2))getans();//当前状态可能构成一种方案
            for(int k=lcnt;k<=rcnt;k++){
                int now=edge[k].state;
                int num=edge[k].ans;
                decode(now);
                int is_right=w[j-1];//这个格子左面格子的右插头 
                int is_down=w[j];//这个格子上面格子的下插头 
                bool flag=0;//判断是否可以放插头，1可以不放 
                if(!mp[i][j])flag=0;//景点必须放 
                else if(!is_down)flag=1;//下插头不需要再匹配，故可以不放。 
                else{
                    flag=0;
                    for(int l=1;l<=m&&!flag;l++){
                    	if(l!=j&&w[l]==is_down)flag=1;
                        //上插头已经与轮廓线的一端匹配，可以在那一端延伸。 
                	}
                	//没有匹配的插头，必须要接上 
            	}
                if(flag){//不放插头 
                    w[j]=0;//下插头没有用了 
                    insert(encode(),num,(i-1)*m+j,k,0);
                    w[j]=is_down;
                }
                //放插头 
                if(!is_right&&!is_down)w[j]=7;//一个新插头 
                else if(!is_down&&is_right)w[j]=is_right;//右插头延续过来 
                else if(is_right!=is_down&&is_right&&is_down){
                    for(int l=1;l<=j;l++){//不太好说，但画个图应该就理解了 
                    	if(w[l]==is_right)w[l]=is_down;
                    }
                }
                //如果下插头和右插头匹配那么就把它们连起来 
            	insert(encode(),num+mp[i][j],(i-1)*m+j,k,1);
            } 
        }
    }
    init();
    getans();
    return;
}
void getans(int k){
    if(!k)return;
    int r=edge[k].pos;
    int l=(r-1)/m+1;r=(r-1)%m+1;
    g[l][r]=edge[k].choose;
    getans(edge[k].pre);
    return;
}
int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            scanf("%d",&mp[i][j]);
            if(!mp[i][j])e1=i,e2=j;
        }
    }
    cntt=INF;
    plugdp();
    printf("%d\n",cntt);
    getans(lastedge);
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            if(!mp[i][j])putchar('x');
            else if(g[i][j])putchar('o');
            else putchar('_');
        }
        putchar('\n');
    }
    return 0;
}
```

hack参考博客程序的数据。
```
4 3
0 1 1
10 10 1
10 10 0
10 10 1

ans：
3
xoo
__o
__x
___
```

---

## 作者：jun头吉吉 (赞：5)

## 题意
一张 $n\times m$ 的网格，网格有权值，某些格子必须取，问能覆盖所有必须取的点的连通块的最小权值。
## 题解
最近在做轮廓线dp于是就用轮廓线水了一发。

其实如果稍微理解一下的话就是[[JLOI2009]神秘的生物](https://www.luogu.com.cn/problem/P3886)的改编了。
~~(看这年份可能是JLOI改编这道题)~~

首先是对于必须选的点，我们赋极小值，使其必须选中，再把这部分权值加回来。以后的讨论就不用管必选与否了。

由于不是闭合回路，我们无法用括号序列来表示，因此我们用**最小表示法**，比如当前的轮廓线上，$1,3,4$ 在一个连通块内， $6,7$ 在一个连通块内，我们可以用 $(1011022)$ 来表示当前的轮廓线。不难证明一个数列与一个轮廓线的连通性是一一对应的。

由于 $m\le 10$ ，一条轮廓线上的不同的连通块个数最多有 $6$ 个，所以我们使用 $8$ 进制来表示这个数列。

来考虑怎么转移，发现有以下几种

### 此方格不选
若是保证 $\rm dp$ 状态合法，左边的方块的连通性不变，上面的必须不是唯一的这个标号，不然上面的方块就变成一个独立的连通块了。若合法把上面的连通块标号改为 $0$ 即可。
### 此方格选且左上至少有一个选
设标号分别为 $A$、$B$，那么需要 $A$、$B$ 会连通成一个连通块（如果存在的话）。那么只需要把 $\min(A,B)$ 以及 当前格点的标号改为 $\max(A,B)$ 即可。不过如果 $\min(A,B)=0$ 就没必要改了。
### 此方格选且左上都未选
最简单，只需要新建一个 $7$ 号连通块即可。

经过上面的操作我们得到的并不是最小表示，只是单纯地连通性。我们需要简单地写一个函数使其变为最小表示。

为了方便起见，在转为最小表示的过程中，当且仅当只有一个连通块时状态才可以计入答案。

那么现在我们已经能计算最小值了。考虑构造方案。。

在原来的基础上，在 $\rm dp$ 数组中记录每种状态的最大值的前一个状态，答案的结束状态、结束位置。这里用了个 `pair` 来实现。从结束位置向前遍历，并每次跳到前一个状态。

于是就可以愉快地A了这道题了。

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=11,INF=1000000;
int n,m,k,val[N][N];//为了强制选景点，赋极小值-INF
int mp[N][N];//在最优方案中这个值选不选
pair<int,pair<int,pair<int,int>>>ans;
#define Ans ans.first
#define endst ans.second.first
#define endx ans.second.second.first
#define endy ans.second.second.second
int bits[N],s[N];int x,y,nowans,nowst;
unordered_map<int,pair<int,int>>dp[N][N];
//规定：first为最小值， second为上一次状态
void init_bits(){for(int i=1;i<N;i++)bits[i]=i*3;}
void getstate(){for(int i=1;i<=m;i++)s[i]=(nowst>>bits[i])&7;s[0]=0;}
int relable(){
	static int t[20];memset(t,0,sizeof t);int cnt=0,st=0;
	for(int i=1;i<=m;i++)if(s[i]){
		if(t[s[i]])s[i]=t[s[i]];
		else s[i]=t[s[i]]=++cnt;
	}
	for(int i=1;i<=m;i++)st+=s[i]<<bits[i];
	if(cnt==1)ans=min(ans,{nowans,{st,{x,y}}});
	return st;
}
void insert(int st){
	if(dp[x][y].find(st)==dp[x][y].end())dp[x][y][st]={nowans,nowst};
	else dp[x][y][st]=min(dp[x][y][st],{nowans,nowst});
}
void DP(){
	dp[0][m][0]={0,0};
	for(x=1;x<=n;x++)
		for(y=1;y<=m;y++){
			int prex=x,prey=y-1;
			if(prey==0)prey=m,prex=x-1;
			for(auto k:dp[prex][prey]){
				nowst=k.first,nowans=k.second.first;
				//假装这里没有插头
				getstate();
				int d_plug=s[y],r_plug=s[y-1];
				int cnt=0;s[y]=0;
				for(int l=1;l<=m;l++)
					if(d_plug==s[l])cnt++;
				if(!d_plug||cnt)insert(relable());
				//如果有插头
				getstate();
				nowans+=val[x][y];
				if(!r_plug&&!d_plug)s[y]=7;//新建连通块
				else{
					s[y]=max(r_plug,d_plug);
					for(int l=1;l<=n;l++)
						if(s[l]&&s[l]==min(r_plug,d_plug))
							s[l]=max(r_plug,d_plug);
				}
				insert(relable());
			}
		}
}
signed main(){
	scanf("%d%d",&n,&m);
	for(x=1;x<=n;x++)
		for(y=1;y<=m;y++)
			scanf("%d",&val[x][y]),val[x][y]==0&&(val[x][y]=-INF,k++);
	init_bits();DP();
	printf("%d\n",Ans+k*INF);
	nowst=endst;
	for(x=endx;x;x--){
		for(y=x==endx?endy:m;y;y--){
			if(nowst>>bits[y]&7)mp[x][y]=1;
			nowst=dp[x][y][nowst].second;
		}
	}
	for(x=1;x<=n;x++){
		for(y=1;y<=m;y++){
			if(val[x][y]==-INF)putchar('x');
			else if(mp[x][y])putchar('o');
			else putchar('_');
		}putchar('\n');
	}
}
```

---

## 作者：Sai0511 (赞：5)

~~教练上次课讲了插头dp,然后列出的插头dp题目里有这道题。本来想练练插头dp的结果用更快更简单的斯坦纳树解决了这道题。~~     
斯坦纳树经典题目。       
斯坦纳树其实并不是很难，一般用来解决在一张无向图上选
$\text{m}$个点使这$\text{m}$个点连通并且始所选边边权最小。   

那么回到本题。    
设$f_{i,j,s}$表示当前在第$\text{i}$行$\text{j}$列的点，状态为$\text{s}$的时候最小权值和。设$\text{s1}$代表$\text{s}$的子集。       
那么转移方程显而易见。        
$$f_{i,j,s} = min(f_{i,j,s},f_{i,s1xors} - a_{i,j})$$       
这个转移应该不难看懂吧。             
但是这里会出现一个问题：那就是会出现新的节点。    
我们可以用最短路的方式求出下面一个方程：    
设$\text{x,y}$为当前的节点，$\text{xa,ya}$是新拓展出的与$\text{x,y}$相连接的节点。        
则：          
$$f_{xa,ya,s} = min(f_{xa,ya,s},f_{x,y,s} +a_{xa,ya})$$         
然后我们就顺利的解决了这道题。      
### My Code：      
```cpp
#include <bits/stdc++.h>

const int maxn = 20;
const int maxm = 20;
const int inf = 0x3f3f3f3f;
typedef long long ll;

struct Pair {
  int x, y;
  Pair() { x = 0;  y = 0; }
  Pair(int _x,int _y) { x = _x;  y = _y;  }
};

inline Pair Make_Pair(int x,int y) {
  return Pair(x,y);
}

template<class T> inline void read(T& res) {
  res = 0;  bool sign = 0;  char ch;
  do ch = getchar(), sign |= ch == '-'; while(!isdigit(ch));
  while(isdigit(ch)) res = (res << 1) + (res << 3) + (ch & 15), ch = getchar();
  (sign) && (res = -res);
}

const int dir[4][2] = {{0,-1},{0,1},{-1,0},{1,0}};
int n, m, i, j, k, tx, ty;
int a[maxn][maxn], f[maxn][maxn][1 << 11];
bool inq[maxn][maxn], ans[maxn][maxn];
struct state {
  int x, y, S;
  state() { x = y = S = 0; }
  state(int _x,int _y,int _S) { x = _x;  y = _y;  S = _S; }
} las[maxn][maxn][1 << 11];
std::queue<Pair> q;

inline void spfa(int s) {
  while(!q.empty()) {
    Pair qwq = q.front();  q.pop();
    int x = qwq.x, y = qwq.y;  inq[x][y] = 0;
    for(int i = 0, xa, ya;i < 4;i++) {
      xa = x + dir[i][0];
      ya = y + dir[i][1];
      if(xa < 1 || xa > n || ya < 1 || ya > m) continue;
      if(f[x][y][s] + a[xa][ya] < f[xa][ya][s]) {
        f[xa][ya][s] = f[x][y][s] + a[xa][ya];
        if(!inq[xa][ya]) q.push(Make_Pair(xa,ya)), inq[xa][ya] = 1;
        las[xa][ya][s] = state(x,y,s);
      }
    }
  }
}

void dfs(int i,int j,int s) {
  if(!las[i][j][s].S) return;  ans[i][j] = 1;
  state qwq = las[i][j][s];
  int x = qwq.x, y = qwq.y, S = qwq.S;
  dfs(x,y,S);
  if(i == x && j == y) dfs(i,j,s ^ S);
}

int main() {
  read(n);  read(m);
  int cnt = 0;
  memset(f,0x3f,sizeof(f));
  for(int i = 1;i <= n;i++) {
    for(int j = 1;j <= m;j++) {
      read(a[i][j]);
      if(!a[i][j]) tx = i, ty = j, f[i][j][1 << cnt] = 0, cnt++;
    }
  }
  for(int l = 1, liml = (1 << cnt) - 1;l <= liml;l++) {
    while(!q.empty()) q.pop();
    for(int i = 1;i <= n;i++) {
      for(int j = 1;j <= m;j++) {
        for(int k = l;k;k = l & (k - 1)) {
          if(f[i][j][l] > f[i][j][k] + f[i][j][k ^ l] - a[i][j]) {
            f[i][j][l] = f[i][j][k] + f[i][j][k ^ l] - a[i][j];
            las[i][j][l] = state(i,j,k);
          }
        }
        if(f[i][j][l] != inf) q.push(Make_Pair(i,j)), inq[i][j] = 1;
      }
    }
    spfa(l);
  }
  printf("%d\n",f[tx][ty][(1 << cnt) - 1]);
  dfs(tx,ty,(1 << cnt) - 1);
  for(int i = 1;i <= n;i++) {
    for(int j = 1;j <= m;j++) {
      if(!a[i][j]) { printf("x");  continue; }
      ans[i][j] ? printf("o") : printf("_");
    }
    puts("");
  }
  return 0;
}
```

---

## 作者：EternalEpic (赞：3)

做这道题前，您得保证会最小斯坦纳树。

我们不难发现，题目意思是要找到一些点放志愿者，使给定点连通。

可以证明，最后一定会形成一棵树，因为多余的边会让答案不优（边权不为负）

那么，就可以用最小斯坦纳树来解决问题了。

在模板题中，我们使 $dp_{i,S}$ 表示以 $ i $ 为根，连通性为 $ S $ 的最优代价。可是这题是一个二维矩阵，我们为了方便，可以进行转置。

n行m列的矩阵中，$g(x, y)$ 可以用 $a((x - 1) $ * $ m + y)$ 表示。

注意：不是 $a((x - 1) $ * $ n + y)$ ，笔者因为这个一直WA50。

然后看上去就是板子题了？

额，还有些细节，这题实际上是点权化边权，所以要把这个

```cpp
for (int subset = s & (s - 1); subset; subset = (subset - 1) & s)
	if (dp[i][s] > dp[i][subset] + dp[i][s ^ subset]) {
		dp[i][s] = dp[i][subset] + dp[i][s ^ subset];
		pre[i][s] = Mp(Mp(x, y), subset);
	}
```

改为

```cpp
for (int subset = s & (s - 1); subset; subset = (subset - 1) & s)
	if (dp[i][s] > dp[i][subset] + dp[i][s ^ subset] - a[i]) {
		dp[i][s] = dp[i][subset] + dp[i][s ^ subset] - a[i];
		pre[i][s] = Mp(Mp(x, y), subset);
	}
```

最后还要把每次转移决策点找出来，方便输出方案。

完结撒花：

```cpp
const int dx[] = {0, 0, -1, 1};
const int dy[] = {-1, 1, 0, 0};
const int Maxn = 15, Maxm = 1 << 11;
int n, m, k, a[Maxn * Maxn], ans[Maxn][Maxn], dp[Maxn * Maxn][Maxm], cnt;
typedef pair < pair <int, int>, int > pii; pii pre[Maxn * Maxn][Maxm];

struct state {
	int x, y, d;
	state(void) { x = y = d = 0; }
	state(int _x, int _y, int _d) : x(_x), y(_y), d(_d) {}
	inline bool operator < (const state&rhs) const { return d > rhs.d; }
}; priority_queue <state> q; bool vis[Maxn][Maxn];

inline bool vaild(int x, int y) { return x >= 1 && y >= 1 && x <= n && y <= m; }
inline void Dijkstra(int s) {
	Ms(vis, false);
	while (!q.empty()) {
		int x = q.top().x, y = q.top().y; q.pop();
		if (vis[x][y]) continue; vis[x][y] = true;
		for (int i = 0; i < 4; i++) {
			int nx = x + dx[i], ny = y + dy[i];
			if (vaild(nx, ny) && dp[(nx - 1) * m + ny][s] > dp[(x - 1) * m + y][s] + a[(nx - 1) * m + ny]) {
				dp[(nx - 1) * m + ny][s] = dp[(x - 1) * m + y][s] + a[(nx - 1) * m + ny];
				q.push(state(nx, ny, dp[(nx - 1) * m + ny][s])); pre[(nx - 1) * m + ny][s] = Mp(Mp(x, y), s);
			}
		}
	}
}

#define coor(u) ((u.first - 1) * m + u.second)
inline void findpaths(pair <int, int> u, int s) {
	if (!pre[coor(u)][s].second) return;
	ans[u.first][u.second] = 1;
	if (pre[coor(u)][s].first == u) findpaths(u, s ^ pre[coor(u)][s].second);
	findpaths(pre[coor(u)][s].first, pre[coor(u)][s].second);
}

int fx, fy, pos;
signed main(void) {
//	file("");
	read(n), read(m); Ms(dp, 0x3f);
	for (int i = 1; i <= n; i++)
	for (int j = 1; j <= m; j++) {
		read(a[++cnt]);
		if (a[cnt] == 0) { ++k;
			dp[cnt][1 << k - 1] = 0;
			pos = cnt; fx = i; fy = j;
		}
	}
	
	for (int s = 1; s < 1 << k; s++) {
		for (int x = 1; x <= n; x++)
		for (int y = 1; y <= m; y++) { int i = (x - 1) * m + y;
			for (int subset = s & (s - 1); subset; subset = (subset - 1) & s)
				if (dp[i][s] > dp[i][subset] + dp[i][s ^ subset] - a[i]) {
					dp[i][s] = dp[i][subset] + dp[i][s ^ subset] - a[i];
					pre[i][s] = Mp(Mp(x, y), subset);
				}
			if (dp[i][s] != 0x3f3f3f3f) q.push(state(x, y, dp[i][s]));
		} Dijkstra(s);
	} writeln(dp[pos][(1 << k) - 1]); findpaths(Mp(fx, fy), (1 << k) - 1);
	
	for (int i = 1; i <= n; i++)
	for (int j = 1; j <= m; j++) {
		if (!a[(i - 1) * m + j]) putchar('x');
		else putchar(ans[i][j] ? 'o' : '_');
		if (j == m) putchar('\n');
	}
//	fwrite(pf, 1, o1 - pf, stdout);
	return 0;
}
```



---

## 作者：Y1shuiLi (赞：3)

2019 8.9
斯坦纳树，因为要求最小值，环的存在没有意义。

类似宝藏的，最优解是一颗树

模型：给定某些关键点，找到一些边的集合使得关键点互相连通，要求开销最小

用到一点点树形dp的想法，用 dp i，s表示以i为根，s是关键点集合状态下的最小值。

1，树与树

树是由子树合并来的

常规第一层转移： dp i，s=min（dp i，S+dp i，s-S）；

2，树与点

考虑树由另外一个点转移过来,dp i,s=min(dp j,s+dis i,j)

这是三角不等式的形式，我们可以用spfa来加速算法；

树形结合一下就是spfa是有dx、dy参与的上下左右四格的拓展，这样保证i与j相连

第一层转移是对i本身有可能连起来的情况的合并；

一些细节注意：

1 读入时预处理景点， dp k，1<<(k-1)=0；

2队列中已经扩展完的点不可以再扩展，假设i j相连，i点get最优后轮到j扩，j也取得最优后再返回去把i也扩一遍，是非法的。不标记会凉凉。 其实这点在spfa模板中都说的很清楚了，笔者是写来提醒自己。

3 取min所以memset max；

4扔到队列中时也要要求这个点在之前是扩展过的，否则太大会爆掉（0x7f）;

5拓扑顺序问题：为什么第一重和第二重不能颠倒：第二重的dp是在所有节点对于s已经求得最小值的情况下再拓展，比方说假设“考虑树由另外一个点转移过来,dp i,s=min(dp j,s+dis i,j)”，且这种方案是最优，如果这时的dp
j，s没有更新过就凉凉，完美避开。所以spfa的顺序是在i和s的两重循环完后再跑的。

6.关于为什么需要第二重的一些思考。因为我们枚举第一重时只保证了两个子集互不重合，也就是说关键点的连通状态是不一样的，但是不保证在真实地图上道路是有重叠的，这会导致浪费。假设i点得到的最优解中两个子集的道路有重叠，我们在后续枚举某个点时，一定会枚举到刚刚好不重叠且取最优的点j（因为枚举了所有的点，如果有的话，一定包括在其中），这样再跑一次第二重转移，就能把不重叠的方案考虑进去，从j转移到i。

TALK IS CHEAP,SHOE ME THE CODE.

```cpp
#include <bits/stdc++.h>
using namespace std;
int dx[5]={0,-1,1,0,0},dy[5]={0,0,0,-1,1},book[300],num[105][105],
f[201][1<<11],n,m,k,MOVEx[300],MOVEy[300],a[300],tot=0,cnt=0,i,s,ts,
get[300],pre[300][1<<11][3];
struct node{
	int x,y,id;
};
queue <node>q;
void print( )
{ int i;
for(i=1;i<=n*m;i++)
 {if(a[i]==0) get[i]=2;}
 
for(i=1;i<=n;i++)
 {for(int j=1;j<=m;j++)
  {if(get[num[i][j]]==2)
    {cout<<"x";}
    else if(get[num[i][j]]==1)
     {cout<<"o";}
      else cout<<"_";
		}
	cout<<endl;	
	  }
}
void dfs(int i,int s)
{ if(pre[i][s][0]==1)
   {if(pre[i][s][1]==i) {
	 get[i]=2;	
     return;
	 }
	 else {
		get[pre[i][s][1]]=1;//放置	
	    dfs(pre[i][s][1],s);
	 }
		}
 	else {
		get[i]=1;
		dfs(i,pre[i][s][1]);
		dfs(i,pre[i][s][2]);
 	}
}
void spfa(int s)
{ while(!q.empty( ))
	{ node p=q.front( );
	  q.pop( );
	 int xx=p.x,yy=p.y,r=p.id,newr;//数据，编号 
	  book[r]=0;//不在队列中 
	  for(int i=1;i<=4;i++)
	   { int x=xx+dx[i],y=yy+dy[i];
	
		  if(x<=n&&x>=1&&y<=m&&y>=1)//ok
		   {newr=num[x][y];
				if(f[newr][s]>f[r][s]+a[newr])
				 {f[newr][s]=f[r][s]+a[newr];
				  pre[newr][s][0]=1;
				  pre[newr][s][1]=r;
				   if(book[newr]==0)
					{book[newr]=1;//合法&&可扩 压入队列 
					 node newp;
					 newp.id=newr;newp.x=x;newp.y=y;
					 q.push(newp);
						}
					}
				}
			} 
		}
	}
void solve( )
{ int U=(1<<k)-1;
 	for(s=0;s<=U;s++)
 	 {
	   for(i=1;i<=n*m;i++)
 	    { for(ts=(s&(s-1));ts;ts=((ts-1)&s))//类似宝藏 枚举子集 
			{
				if(f[i][s]>f[i][ts]+f[i][s^ts]-a[i])
				{f[i][s]=f[i][ts]+f[i][s^ts]-a[i];
				 pre[i][s][0]=2;
				 pre[i][s][1]=ts;
				 pre[i][s][2]=(s^ts);
					}
				}
			 if(f[i][s]<20192019) 
			 {node h;
			  h.x=MOVEx[i];h.y=MOVEy[i];h.id=i;
			   if(book[h.id]==0)
			     {q.push(h);book[i]=1;}
			   }	
			}
			spfa(s);
		 }
		 int point,ans=20192019;
		 for(i=1;i<=n*m;i++)
		 { if(ans>f[i][U]) 
		    {ans=f[i][U];point=i;
				 }
				}	
		dfs(point,U);
		print( );					
}
int main( )
{
	cin>>n>>m;
	for(int s=0;s<=(1<<11)-1;s++)
	 for(int i=1;i<=200;i++)
	  {f[i][s]=20192019;}
int ch;
k=0;
	for(int i=1;i<=n;i++)
	 for(int j=1;j<=m;j++)
	  {cin>>ch;
	   ++cnt;
	   tot+=ch;
	   num[i][j]=cnt;//同下 
	   a[cnt]=ch;//坐标统一转为编号 
	   MOVEx[cnt]=i;MOVEy[cnt]=j;//编号转格子 
	   if(ch==0) {
			++k;
			 f[cnt][1<<(k-1)]=0;
			 pre[cnt][1<<(k-1)][0]=1;
			 pre[cnt][1<<(k-1)][1]=cnt;
			 get[cnt]=2;
	   }
	}

	solve( );		
}	 
```



---

## 作者：foreverlasting (赞：2)

[题面](https://www.lydsy.com/JudgeOnline/problem.php?id=2595)

斯坦纳树。

首先我们要了解什么是斯坦纳树。看起来名字很高深，其实只不过是一棵树普通的树而已。说白了，就是给你$n$个点，其中有$k$个是关键点，我们将把这个$k$个关键点连接起来的树称作斯坦纳树。如果连接有边权，且当前连接方式的总边权最小，则称之为最小斯坦纳树。显然，最小生成树是一种特殊的最小斯坦纳树。

那么很明显了，这道题就是一道裸的最小斯坦纳树的题了。然后开始思考如何求解最小斯坦纳树。比较常规的方法就是状压了。状态的每一位用来表示这一位对应的点是否被连接上了。于是就是常规的状压了。$dp[i][S]$表示当前点的编号为$i$，状态为$S$的最小权值和。转移方程也很好写，就是枚举子集$SS$,$dp[i][S]=min(dp[i][SS]+dp[i][SS xor S]-va[i])$。然后这里可能会出现新的结点（即不是子集），所以方程变成$dp[i][S]=min(dp[j][S]+va[i])$（$j$和$k$相连）。而这条方程可以通过求最短路的方式求出。于是就做好了。

code:
```
//2018.9.10 by ljz
#include<bits/stdc++.h>
using namespace std;
#define res register int
#define LL long long
#define inf 0x3f3f3f3f
#define eps 1e-15
inline int read(){
    res s=0;
    bool w=0;
    char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')w=1;ch=getchar();}
    while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=getchar();
    return w?-s:s;
}
inline void _swap(res &x,res &y){
    x^=y^=x^=y;
}
inline int _abs(const res &x){
    return x>0?x:-x;
}
inline int _max(const res &x,const res &y){
    return x>y?x:y;
}
inline int _min(const res &x,const res &y){
    return x<y?x:y;
}
const int N=10+10;
const int dx[]={0,0,-1,1};
const int dy[]={-1,1,0,0};
namespace MAIN{
    int n,m;
    typedef pair<int,int> Pair;
#define mp make_pair
    Pair Q[N*N];
    int he,ta;
    int dp[N][N][1<<10];
    int va[N][N],tot,ex,ey,sx,sy;
    struct SIT{
        int x,y,S;
        SIT() {}
        SIT(res x,res y,res S):x(x),y(y),S(S) {}
    }pre[N][N][1<<10];
    bool vis[N][N];
    inline void spfa(res S){
        while(he<=ta){
            res x=Q[he].first,y=Q[he].second;
            he++;
            vis[x][y]=0;
            for(res d=0;d<4;d++){
                res nx=x+dx[d],ny=y+dy[d];
                if(nx<1||nx>n||ny<1||ny>m)continue;
                if(dp[nx][ny][S]>dp[x][y][S]+va[nx][ny]){
                    dp[nx][ny][S]=dp[x][y][S]+va[nx][ny];
                    if(!vis[nx][ny])Q[++ta]=mp(nx,ny),vis[nx][ny]=1;
                    pre[nx][ny][S]=SIT(x,y,S);
                }
            }
        }
    }
    bool ans[N][N];
    void dfs(res x,res y,res S){
        if(!pre[x][y][S].S)return;
        ans[x][y]=1;
        SIT p=pre[x][y][S];
        dfs(p.x,p.y,p.S);
        if(p.x==x&&p.y==y)dfs(x,y,S^p.S);
    }
    inline void MAIN(){
        n=read(),m=read();
        memset(dp,inf,sizeof(dp));
        for(res i=1;i<=n;i++)
            for(res j=1;j<=m;j++){
                va[i][j]=read();
                if(!va[i][j])dp[i][j][1<<tot]=0,ex=i,ey=j,tot++;
            }
        for(res S=1;S<(1<<tot);S++){
            he=1,ta=0;
            for(res i=1;i<=n;i++)
                for(res j=1;j<=m;j++){
                    for(res SS=S;SS;SS=S&(SS-1))
                        if(dp[i][j][S]>dp[i][j][SS]+dp[i][j][SS^S]-va[i][j])
                            dp[i][j][S]=dp[i][j][SS]+dp[i][j][SS^S]-va[i][j],pre[i][j][S]=SIT(i,j,SS);
                    if(dp[i][j][S]!=inf)Q[++ta]=mp(i,j),vis[i][j]=1;
                }
            spfa(S);
        }
        printf("%d\n",dp[ex][ey][(1<<tot)-1]);
        dfs(ex,ey,(1<<tot)-1);
        for(res i=1;i<=n;i++){
            for(res j=1;j<=m;j++){
                if(!va[i][j])printf("x");
                else if(ans[i][j])printf("o");
                else printf("_");
            }
            puts("");
        }
    }
}
int main(){
    MAIN::MAIN();
    return 0;
}
```


---

## 作者：huayucaiji (赞：1)

## 前言

我就喜欢这种重题的题，不知道是WC搬的CF还是CF搬的WC，不管了，反正一样就是了。

既可以水 $2$ 篇题解，也可以搞掉一黑一紫，何乐而不为？

## 解题思路

$k$ 很小，又是连通性问题，显然最小斯坦纳树，问题是如何建图？如何求出方案？

### 建图

我们可以按四联通来建图，不用管边权。由于在这张图里只有点权，我们的斯坦纳树 DP 转移方程会有所改变（不要重复计算点权），具体看代码，其实很好理解（只要你理解了斯坦纳树的板子）。

### 求出方案

这个有点难度。其实可以和大部分 DP 一样，需要记录一下转移决策点。SPFA 可以这样，三角形不等式的部分怎么办？

我们其实可以这样，如果可以已通过 SPFA 记录的决策点一直往前推，就往前，直到结束为止，我们就在把当前状态的递推在跑一遍即可。

```cpp
//Don't act like a loser.
//This code is written by huayucaiji
//You can only use the code for studying or finding mistakes
//Or,you'll be punished by Sakyamuni!!!
#include<bits/stdc++.h>
#define int long long
using namespace std;

int read() {
	char ch=getchar();
	int f=1,x=0;
	while(ch<'0'||ch>'9') {
		if(ch=='-')
			f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9') {
		x=x*10+ch-'0';
		ch=getchar();
	}
	return f*x;
}

const int MAXN=110,MAXK=11,INF=2e9;
const int dx[]={1,0,-1,0};
const int dy[]={0,1,0,-1};

int n,m,k,cnt;
int a[MAXN],h[MAXN],f[MAXN][1<<MAXK],g[MAXN][1<<MAXK];
char ans[MAXN];
bool inq[MAXN],vis[MAXN][1<<MAXK];
queue<int> q;

int idx(int i,int j) {
	return (i-1)*m+j;
} 
bool ok(int i,int j) {
	if(i>n||i<1||j>m||j<1) {
		return 0;
	}
	return 1;
}

struct edge {
	int to,nxt;
}e[10000];

void addedge(int u,int v) {
	e[++cnt].nxt=h[u];
	e[cnt].to=v;
	h[u]=cnt;
}

void SPFA(int s) {
	while(!q.empty()) {
		int u=q.front();
		q.pop();
		inq[u]=0;
		
		for(int i=h[u];i;i=e[i].nxt) {
			int v=e[i].to;
			if(f[v][s]>f[u][s]+a[v]) {
				f[v][s]=f[u][s]+a[v];
				g[v][s]=u;
				if(!inq[v]) {
					q.push(v);
					inq[v]=1;
				}
			}
		}
	}
}

void getans(int u,int s) {
	if(vis[u][s]) {
		return ;
	}
	vis[u][s]=1;
	
	ans[u]='o';
    //一直往前推
	while(g[u][s]!=-1&&f[g[u][s]][s]+a[u]==f[u][s]) {
		u=g[u][s];
		getans(u,s);
	}
	for(int t=s&(s-1);t;t=(t-1)&s) {
		if(f[u][t]+f[u][s^t]-a[u]==f[u][s]) {
			getans(u,t);
			getans(u,s^t);
			break;
            //重新递推
		}
	}
}

signed main() {
	cin>>n>>m;
	for(int i=1;i<=n*m;i++) {
		for(int j=0;j<=1023;j++) {
			f[i][j]=INF;
			g[i][j]=-1;
		}
	}
	for(int i=1;i<=n;i++) {
		for(int j=1;j<=m;j++) {
			ans[idx(i,j)]='_';
			cin>>a[idx(i,j)];
			if(!a[idx(i,j)]) {
				f[idx(i,j)][1<<k]=0;
				k++;
			}
			for(int p=0;p<4;p++) {
				if(ok(i+dx[p],j+dy[p])) {
					addedge(idx(i,j),idx(i+dx[p],j+dy[p]));
				}
			}
		}
	}
	
	int mx=(1<<k)-1;
	
	for(int s=0;s<=mx;s++) {
		for(int i=1;i<=n*m;i++) {
			for(int t=s&(s-1);t;t=(t-1)&s) {
				f[i][s]=min(f[i][s],f[i][t]+f[i][s^t]-a[i]);
                //同一点的点权不要重复算
			}
			if(f[i][s]<INF) {
				inq[i]=1;
				q.push(i);
			}
		}
		SPFA(s);
	}
	
	int minn=INF,mark=0;
	for(int i=1;i<=n*m;i++) {
		if(f[i][mx]<minn) {
			minn=f[i][mx];
			mark=i;
		}
	}
	
	cout<<minn<<endl;
	getans(mark,mx);
	for(int i=1;i<=n;i++) {
		for(int j=1;j<=m;j++) {
			if(!a[idx(i,j)]) {
				ans[idx(i,j)]='x';
			}
			printf("%c",ans[idx(i,j)]);
		}
		puts("");
	}
	return 0;
}

```

---


# [九省联考 2018] 一双木棋 chess

## 题目描述

菲菲和牛牛在一块 $n$ 行 $m$ 列的棋盘上下棋，菲菲执黑棋先手，牛牛执白棋后手。

棋局开始时，棋盘上没有任何棋子，两人轮流在格子上落子，直到填满棋盘时结束。  

落子的规则是：一个格子可以落子当且仅当这个格子内没有棋子且这个格子的左侧及上方的所有格子内都有棋子。

棋盘的每个格子上，都写有两个非负整数，从上到下第 $i$ 行中从左到右第 $j$ 列的格子上的两个整数记作 $a_{i,j}$ 和 $b_{i,j}$。

在游戏结束后，菲菲和牛牛会分别计算自己的得分：菲菲的得分是所有有黑棋的格子上的 $a_{i,j}$ 之和，牛牛的得分是所有有白棋的格子上的 $b_{i,j}$ 的和。

菲菲和牛牛都希望，自己的得分减去对方的得分得到的结果最大。现在他们想知道，在给定的棋盘上，如果双方都采用最优策略且知道对方会采用最优策略，那么，最终的结果如何？


## 说明/提示

### 样例 1 说明

![](https://cdn.luogu.com.cn/upload/pic/16877.png)

棋盘如图所示，双方都采用最优策略时，棋局如下：

- 菲菲下在第 $1$ 行第 $1$ 列（这是第一步时唯一可以落子的格子）。
- 牛牛下在第 $1$ 行第 $2$ 列。
- 菲菲下在第 $2$ 行第 $1$ 列。
- 牛牛下在第 $1$ 行第 $3$ 列。
- 菲菲下在第 $2$ 行第 $2$ 列。
- 牛牛下在第 $2$ 行第 $3$ 列（这是这一步时唯一可以落子的格子）。
- 填满棋盘，游戏结束。

盘面如下：

![](https://cdn.luogu.com.cn/upload/pic/16878.png)

菲菲的得分为 $2 + 9 + 1 = 12$，牛牛的得分为 $7 + 2 + 1 = 10$。

### 数据规模与约定

各测试点信息如下表。

![](https://cdn.luogu.com.cn/upload/pic/16879.png)

- 对于编号为奇数的测试点，保证 $b_{i, j} = 0$。
- 对于全部的测试点，保证 $1 \leq n, m \leq 10$，$0 \leq a_{i, j}, b_{i, j} \leq 10^5$。


## 样例 #1

### 输入

```
2 3
2 7 3
9 1 2
3 7 2
2 3 1
```

### 输出

```
2```

# 题解

## 作者：ouuan (赞：105)

作为一名非正式蒟蒻，凭着A掉这题在弱省HB拿了d1rank2，于是发篇题解祝贺自己人生首次尝试状压便AC

画图之后可以发现每行的棋子数是一个递增序列，即上一行的棋子数一定比下一行多，而且每一行的棋子都是从左往右那么多个，也就是说确定了每一行的棋子数就确定了整个局面，所以关键就是如何简洁地表示一个递增序列。

不要问我怎么想到的，我们可以先写m个0，然后看每一行，有几个棋子就在第几个0后面插入一个1

e.g.

xxxxo

xxooo

xoooo

xoooo

ooooo

就是1011010010

然后这玩意就是我们要的状态

那么转移方程呢？其实得出状态的表示方法之后方程就很好写了，实现起来略复杂，但想通了也不难

ab(u)表示状态u的局面有奇数颗棋子还是偶数颗棋子，即下一步该谁下，计算的方法是从最高位开始向下遍历，累计有奇数个0时遍历到1便把输出取反，实现如下：

```
bool ab(int u)
{
    int i;
    bool odd=false,out=false;
    for (i=1<<(n+m-1);i>0;i>>=1)
    {
        if (i&u)
        {
            if (odd)
            {
                out=!out;
            }
        }
        else
        {
            odd=!odd;
        }
    }
    return out;
}
```

存a和b时a[i][j]=A[i][m+1-j]会稍微方便一些

然后就是最终的方程：f(i)=若ab(i)则为min，否则为max{f(把每个后面一位非1&&不是最后一位的1分别向后移一位)+ab(i)?(-b[逆数第几个1后移][移之前这个1后面有几个0]):a[逆数第几个1后移][移之前这个1后面有几个0]}

这个方程的文字看起来非常复杂，所以建议自行理解并写出方程，如果看不懂的话可以结合下面的代码：

```
for (i=mini+1;i<=maxi;++i)
    {
        flag=false;
        one=zero=0;
        if (ab(i))
        {
            f[i]=0x7fffffff;
            for (j=1;j<(1<<(n+m));j<<=1)
            {
                if (j&i)
                {
                    ++one;
                    if (flag)
                    {
                        f[i]=min(f[i],f[i-(j>>1)]-b[one][zero]);
                    }
                    flag=false;
                }
                else
                {
                    ++zero;
                    flag=true;
                }
            }
        }
        else
        {
            f[i]=-0x7fffffff;
            for (j=1;j<(1<<(n+m));j<<=1)
            {
                if (j&i)
                {
                    ++one;
                    if (flag)
                    {
                        f[i]=max(f[i],f[i-(j>>1)]+a[one][zero]);
                    }
                    flag=false;
                }
                else
                {
                    ++zero;
                    flag=true;
                }
            }
        }
    }
```

完整代码就不给出了，还是建议看懂状态的表示之后剩余部分全部自行写出

---

## 作者：Anoxiacxy (赞：91)

作为一名正式选手表示自己这道题考场上被吊打了。。。。

考场上所有的技能就只剩下暴搜了，然后一发$\alpha-\beta$剪枝混了60分走人

%%%楼下的楼下的楼下。。。的楼下，翻了半天似乎都是哈希做法，那我来一发轮廓线的DP吧

### 进入正题

首先，由于一个位置能落子，当且仅当上面和左边都没有空位，根据这个依赖关系的传递性，不难发现一个位置能落子，当且仅当左上角的矩形内部也只有自己一个空位。

那么，可以证明，任何时候，棋盘上的棋子都是一个连续且单调的的左上三角形，所有我们可以用一个轮廓线来表示三角形的右下边界，这样就可以表达棋盘的状态了

不妨用 $1$ 表示竖着的轮廓边，$0$ 表示横着的轮廓边。    
从左下角开始，任何一个轮廓线都可以表达为长度为 $n+m$，且拥有$n$个$1$，$m$个$0$ 的$01$串

比如下图中，初始状态就是 $00011$

![](https://cdn.luogu.com.cn/upload/pic/16877.png)

显然第一步棋是唯一的，下完以后的轮廓线可以表示为 $00101$

如果这个时候走第一行第二列，那么状态可以表示为 $01001$

如果这个时候走第二行第一列，那么状态可以表示为 $00110$

然后，可以发现，状态的转移就是把其中一个 $1$ 向左挪一个位置即可

本质就是 $01->10$

所有找到这些位置就可以转移啦

然后发现转移的顺序不太明显。。。记忆化搜索。。。

令 $S$ 表示一条从左下到右上的轮廓线，令 $f[S]$ 表示这个轮廓线的状态距离游戏结束还能得多少分,可以得到边界条件 $f[11\cdots1100\cdots00] = 0$，最终的答案便是 $f[00\cdots0011\cdots11]$

转移的时候看看是谁在下棋，顺着轮廓线定位到当前落子的位置，然后取个 $min,max$ 就好了，代码较短，复杂度是 $\binom{n+m}{n}$ 的，所以跑的比较快。
```c++
#include <bits/stdc++.h>
using namespace std;

inline int read(int u = 0, char c = getchar(), bool f = false) {
	for (;!isdigit(c); c = getchar()) f |= c == '-';
	for (; isdigit(c); c = getchar()) u = (u << 1) + (u << 3) + c - '0';
	return f ? -u : u;
}

const int maxn = 10;
const int oo = 1e9 + 7;

int a[maxn][maxn], b[maxn][maxn];

int f[1 << (maxn << 1)];

int dfs(int sta, bool who, int n, int m) {
	if (~f[sta]) return f[sta];
	f[sta] = who ? -oo : oo;
	int x = n, y = 0;
	for (int i = 0; i < n + m - 1; i++) {
		if (sta >> i & 1) x--; else y++;
		if ((sta >> i & 3) != 1) continue;
		int nxt = sta ^ (3 << i);
		if (who) 
			f[sta] = max(f[sta], dfs(nxt, who ^ 1, n, m) + a[x][y]);
		else 	
			f[sta] = min(f[sta], dfs(nxt, who ^ 1, n, m) - b[x][y]);
	}	
	return f[sta];	
		
}

int main() {
	int n = read(), m = read(); 
	for (int i = 0; i < n; i++)
		for (int j = 0; j < m; j++)
			a[i][j] = read();
	for (int i = 0; i < n; i++)
		for (int j = 0; j < m; j++)
			b[i][j] = read();
	memset(f, 0xff, sizeof(f));
	f[((1 << n) - 1) << m] = 0;
	cout << dfs((1 << n) - 1, 1, n, m) << endl;
}
```
### UPD:
妈呀代码出锅了。。。拿 $-1$ 表示没有搜索过似乎是错的。。。不管啦。。。数据水。。。就过了。。。
心疼考场使用 $next$ 而 $CE$ 的同学们。。。




---

## 作者：cmd2001 (赞：52)

显然放下的棋子构成一个阶梯型。

我们爆搜一发状态量，发现只有35万多种，这不随便做？

然后在用map记录答案的情况下一发min-max对抗搜索就好了。

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<map>
#define debug cout
typedef long long int lli;
using namespace std;
const int maxn=15,base=12;
const int inf=0x3f3f3f3f;

map<lli,int> mp;
int a[maxn][maxn],b[maxn][maxn];
int hei[maxn]; // hei[0] = n .
int n,m;

inline lli hsh() {
	lli ret = 0;
	for(int i=1;i<=n;i++) ret = ret * base + hei[i];
	return ret;
}
inline void unzip(lli t) {
	for(int i=n;i;i--) hei[i] = t % base , t /= base;
}
inline int getnxt() {
	int ret = 0;
	for(int i=1;i<=n;i++) ret += hei[i];
	return ret & 1; // 0 means max , 1 means min .
}
inline int dfs(lli sta) {
	if( mp.find(sta) != mp.end() ) return mp[sta];
	unzip(sta);
	int tpe = getnxt() , ret = tpe ? inf : -inf;
	for(int i=1;i<=n;i++)
		if( hei[i-1] > hei[i] ) {
			++hei[i];
			lli h = hsh();
			if( !tpe ) ret = max( ret , dfs(h) + a[i][hei[i]] );
			else ret = min( ret , dfs(h) - b[i][hei[i]] );
			--hei[i];
		}
	return mp[sta] = ret;
}

int main() {
	scanf("%d%d",&n,&m) , hei[0] = m;
	for(int i=1;i<=n;i++) for(int j=1;j<=m;j++) scanf("%d",a[i]+j);
	for(int i=1;i<=n;i++) for(int j=1;j<=m;j++) scanf("%d",b[i]+j);
	for(int i=1;i<=n;i++) hei[i] = m;
	lli full = hsh(); mp[full] = 0;
	dfs(0);
	printf("%d\n",mp[0]);
	return 0;
}
```

---

## 作者：shadowice1984 (赞：23)

省选的时候想到了怎么压状态却不会后边的dp

~~最后边的方向全部连反导致只有20pts连暴力都不如~~

# 本题题解

首先先阅读一下题面

对于落子的限制条件是，上方和左方的格子要么是棋子要么是边界

那么我们会发现，一个棋子想要存在的条件是上方和左方的所有格子全部被棋子填满

**所以任意时刻，棋盘上的棋子构成一个锯齿形**

那么我们发现一件事情，尽管棋盘上的棋子个数高达100个

**但是锯齿形图形轮廓线的长度最长不过n+m-1**

因此一定是要在轮廓线上做一些手脚了，我们需要在$2^{n+m-1}$的信息量内描述这个轮廓线

然后一种可行的做法是直接记录每一行有多少个格子，用map存下来，这样的话最大值是$10^{10}$可以用longlong存下去，然后凭借比正解多个log的复杂度可以通过此题

但是这样压状态太暴力了……我们需要想一些优雅的办法

发现我们的轮廓线是联通的，**所以一个轮廓线可以看成一个路径**，这意味着我们可以使用类似于"路标"的方法描述一个路径，也就是说用类似于“下一步走到哪里+起始点”的方法来告诉我们一条路径

具体来讲，我们使用$dp_{i,j}$来描述一个轮廓线，i表示第一行所有棋子中最靠右的棋子的列号，j是一个在二进制下有意义的数，如果j的第p位是0，那么我们从i出发，第p步向左走，如果为1，第p步向下走，这样我们就可以从点i出发，走出这条轮廓线(或者说是路径)

那么我们现在终于可以描述一个棋盘了。

下面是博弈论dp的问题

大概的思路就是假装我们可以一步看到结局，然后选择对自己最有利的状态

但是我们其实没办法看到结局，所以我们倒着看，显然棋盘被布满的状态下没有人可以获得新的分数，那么如果我们用$dp_{i,j}$表示从i，j这个状态向后推演，双方都使用最优策略可以得到的分数差，就可以起到“看到结局的效果”

那么我们会发现，如果这个局面是先手下完以后形成的，那么如何这个局面如何转移的主动权显然是攥在后手的手里，所以此时这个dp值应该由所有后继状态的相对于先手最劣的状态转移过来，也就是所有的后继状态取个min

同理，如果是后手的话，dp值就应该是对于后手最劣的状态转移过来，也就是所有的后继状态取个max

~~(如果实在分不清楚的话可以minmax都试一遍，哪个过了样例就选哪个)~~

最后一个问题，怎么转移呢？

我们发现第一是可以记忆化搜索的，但是其实是存在迭代解法的

发现各个状态间的转移关系，如果把状态看作点，转移关系看作边，那么整张图是一张DAG我们的转移顺序其实是拓扑序，所以将所有状态tpsort一遍无脑转移即可

另一个小问题，如何生成后继状态?

我们按照这个状态把这个轮廓线走出来，然后如果存在一个L形，我们就可以去掉一这个L形的尖从而把这个L形变成一个倒L形，然后就是把相邻两个路标取反一下
具体实现一下就是异或上一个3<<几位就行了

实在不会的话可以自己画一下图，思路就是通过撤走一个棋子然后生成后继状态
然后自己画一个图倒一倒就行了

记得特判第一个点，因为第一个点并不存在L形的结构。

另外如果觉得调试麻烦的话可以写一个打印函数直接以字符画的形式打印出轮廓线方便调试

上代码~

```C
#include<cstdio>
#include<algorithm>
#include<queue>
using namespace std;const int N=20;const int M=524300;
int dp[N][M];int d[N][M];int up;int val[2][N][N];int n;int m;
struct data{int st;int nw;};queue <data> q;int t[N][M];char mp[N][N];
int main()
{
	scanf("%d%d",&n,&m);t[m][(1<<(n-1))-1]=(n*m+1)%2;//记得处理出来每个状态是先手还是后手 
	for(int i=1;i<=n;i++){for(int j=1;j<=m;j++){scanf("%d",&val[0][i][j]);}} 
	for(int i=1;i<=n;i++){for(int j=1;j<=m;j++){scanf("%d",&val[1][i][j]);}}
	for(q.push((data){m,(1<<(n-1))-1});!q.empty();q.pop())//先处理出每个点额度数 
	{
		int st=q.front().st;int nw=q.front().nw;int px=1;int py=st;int ns=nw>>1;
		if((nw&1)==0&&st!=1)//特判第1个点 
		{
			d[st-1][ns]++;t[st-1][ns]=t[st][nw]^1;
			if(d[st-1][ns]==1){q.push((data){st-1,ns});}
		}
		for(int p=nw,i=0;px<n&&py>=1;p>>=1,i++)//生成后继状态 
		{
			if((p&1)==1&&((p>>1)&1)==0)
			{
				ns=py==1?nw^(1<<i):ns=nw^(3<<i);
				d[st][ns]++;t[st][ns]=t[st][nw]^1;
				if(d[st][ns]==1){q.push((data){st,ns});}
			}if(p&1){px++;}else {py--;}
		}dp[st][nw]=t[st][nw]?-0x3f3f3f3f:0x3f3f3f3f;//然后赋个初值 
	}dp[m][(1<<(n-1))-1]=0;
	for(q.push((data){m,(1<<(n-1))-1});!q.empty();q.pop())//按照拓扑序dp 
	{
		int st=q.front().st;int nw=q.front().nw;int px=1;int py=st;int ns=nw>>1;
		if(t[st][nw])//如果这个局面由后手落子形成 
		{
			if((nw&1)==0&&st!=1)
			{
				d[st-1][ns]--;
				if(d[st-1][ns]==0){q.push((data){st-1,ns});}
				dp[st-1][ns]=min(dp[st-1][ns],dp[st][nw]-val[1][1][st]);
			}
			for(int p=nw,i=0;px<n&&py>=1;p>>=1,i++)//具体来讲我们看这个点下方的点是否可以删掉 
			{
				if(p&1==1&&((p>>1)&1)==0)
				{
					ns=py==1?nw^(1<<i):ns=nw^(3<<i);//额要特判下边界情况以免把最后一个位变成1导致越界 
					d[st][ns]--;if(d[st][ns]==0){q.push((data){st,ns});}
					dp[st][ns]=min(dp[st][ns],dp[st][nw]-val[1][px+1][py]);
				}if(p&1){px++;}else {py--;}//然后按照路标移动指针 
			}
		}
		else//然后同理的 
		{
			if((nw&1)==0&&st!=1)
			{
				d[st-1][ns]--;if(d[st-1][ns]==0){q.push((data){st-1,ns});}
				dp[st-1][ns]=max(dp[st-1][ns],dp[st][nw]+val[0][1][st]);
			}
			for(int p=nw,i=0;px<n&&py>=1;p>>=1,i++)
			{
				if(p&1==1&&((p>>1)&1)==0)
				{
					ns=py==1?nw^(1<<i):ns=nw^(3<<i);
					d[st][ns]--;if(d[st][ns]==0){q.push((data){st,ns});}
					dp[st][ns]=max(dp[st][ns],dp[st][nw]+val[0][px+1][py]);
				}if(p&1){px++;}else {py--;}
			}
		}
	}printf("%d",dp[1][0]+val[0][1][1]);return 0;//最后别忘了加上先手最早落的子 
}
```




---

## 作者：yzhang (赞：20)

### [更好的阅读](https://www.cnblogs.com/yzhang-rp-inf/p/10217249.html)

### [原题传送门](https://www.luogu.org/problemnew/show/P4363)

这道题珂以轮廓线dp解决

经过推导，我们珂以发现下一行的棋子比上一行的棋子少（或等于），而且每一行中的棋子都是从左向右依次排列（从头开始，中间没有空隙）

所以每下完一步棋，棋盘的一部分是有棋子的，另一部分是没棋子的

那么，我们就珂以用一条轮廓线来表示有棋子的部分和没棋子的部分的分界线

我们珂以用一个二进制数表示轮廓线，长$n+m$位，含有$n$个$1$和$m$个$0$，轮廓线从右上走到左下，二进制中一位$1$表示向下$1$格，$0$表示向左$1$格

再经过推导，珂以发现每多下一步棋，轮廓线中的一个$1$就会向前移一位

有了这些我们就珂以开始设计方程，进行记忆化搜索

我们设$L$为一条轮廓线，用$f[L]$表示这个轮廓线距离游戏结束菲菲还能比牛牛多多少分

所以边界条件就是$f[((1<<n)-1)<<m]$，最终答案便是$f[(1<<n)-1]$

转移答案时，顺着轮廓线寻找珂以落子的位置，然后根据是谁下的比$Min$或$Max$就行了

时间复杂度应该是$O(\frac{(n+m)!}{n!m!})$

### 完整代码(代码下方有一些对代码中位运算的解释)

```cpp
#include <bits/stdc++.h>
#define N 10
#define inf (1<<30)
#define getchar nc
using namespace std;
inline char nc(){
    static char buf[100000],*p1=buf,*p2=buf; 
    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++; 
}
inline int read()
{
    register int x=0,f=1;register char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+ch-'0',ch=getchar();
    return x*f;
}
inline void write(register int x)
{
    if(!x)putchar('0');if(x<0)x=-x,putchar('-');
    static int sta[20];register int tot=0;
    while(x)sta[tot++]=x%10,x/=10;
    while(tot)putchar(sta[--tot]+48);
}
inline int Max(register int x,register int y)
{
	return x>y?x:y;
}
inline int Min(register int x,register int y)
{
	return x<y?x:y;
}
int n,m;
int a[N][N],b[N][N];
int f[1<<(N<<1)];
bool vis[1<<(N<<1)];
inline int dfs(register int now,register int who)
{
	if(vis[now])
		return f[now];
	f[now]=who?-inf:inf;
	int x=n,y=0;
	for(register int i=0;i<n+m-1;++i)
	{
		if(now>>i&1)
			--x;
		else
			++y;
		if((now>>i&3)!=1)
			continue;
		int nxt=now^(3<<i);
		if(who)
			f[now]=Max(f[now],dfs(nxt,who^1)+a[x][y]);
		else
			f[now]=Min(f[now],dfs(nxt,who^1)-b[x][y]);
	}
	vis[now]=true;
	return f[now];
}
int main()
{
	n=read(),m=read();
	for(register int i=0;i<n;++i)
		for(register int j=0;j<m;++j)
			a[i][j]=read();
	for(register int i=0;i<n;++i)
		for(register int j=0;j<m;++j)
			b[i][j]=read();
	vis[((1<<n)-1)<<m]=true;
	write(dfs((1<<n)-1,1));
	return 0;
}
```

关于位运算的解释

1.

```cpp
    if(now>>i&1)
        --x;
    else
        ++y;
```

这实际就是扫描轮廓线的过程，先左移$i$位，使得倒数第$i+1$位在最后，再与$1$“&”一下就珂以判断倒数第$i+1$为是$0$还是$1$，从而判断该状态的子状态的位置

2.

```cpp
    if((now>>i&3)!=1)
         continue;
```

3的二进制是$11$，因为只有当状态连续的两位是$01$（前一位是$0$，后一位是$1$）才能转移，这句话就是判断了这个格子是否能下棋子

3.

```cpp
    int nxt=now^(3<<i);
```

这句能确定转移后轮廓线的形状，原来的两位是$01$，异或上$11$就成了$10$

```cpp
·-    ->     |
|           -·
```

---

## 作者：行吟啸九州 (赞：19)

对于这种博弈论的题，基本上理解就能想到了把状态压出来，然后做记忆化搜索。

这个题直接dp的话，你可以存一下每行都铺到了哪个位置，这个办法的复杂度O($n^m$)的,通过复杂的数据分治，你就可以得到80分的好成绩了。

然后我们思考一下正解，显而易见的是，这个题所有有用的情况都会呈一个锯齿状，这个感性地想一下就知道了。所以这个题有用的情况数很少,只有$C^{n}_{n + m}$ 种。

为什么呢，因为这个锯齿状的图形，相当于你往右走```n```步，再往下走```m```步, 相当于一共有```n + m```个位置，往里放```n```个东西，所以就是
$C^{n}_{n + m}$ 种了。

$C^{10}_{20}$ = ```184756```‬种，所以我们可以暴力11进制压位，用map直接存即可，复杂度是O(```(n + log184756) * 184756```)。

需要提一个细节，就是$11^{10}$是爆```int```的，需要开一下```long long```，否则就会玄学TLE。

良心省选题，代码几乎无细节，这个题其实放到```noip```提高也不为过了。

```
#include<bits/stdc++.h>
using namespace std;
#define inf 2003518617
#define int long long
#define For(i, j, n) for(register int i = j ; i <= n ; ++i)
int n, m, ed, a[12][12], b[12][12];
map<int, int>ans, vis;

inline int dfs(int x, int w){
	if(x == ed) return 0;
	if(vis[x] == 1) return ans[x];
	int po = 1, sum = w ? inf : -inf, tmp = x, c[12];
	vis[x] = 1, c[0] = inf;
	For(i, 1, n) c[i] = tmp % 11, tmp /= 11;
	if(w){
		For(i, 1, n){ 
			if(c[i] < min(c[i - 1], m)) sum = min(sum, dfs(x + po, w ^ 1) - b[i][c[i] + 1]);
			po *= 11;
		} 
	}
	else{
		For(i, 1, n){
			if(c[i] < min(c[i - 1], m)) sum = max(sum, dfs(x + po, w ^ 1) + a[i][c[i] + 1]);	
			po *= 11;
		}
	} 
	return ans[x] = sum;
}

signed main(){
	scanf("%lld %lld", &n, &m);
	For(i, 1, n) For(j, 1, m) scanf("%lld", &a[i][j]);
	For(i, 1, n) For(j, 1, m) scanf("%lld", &b[i][j]);
	For(i, 1, n) ed = ed * 11 + m;
	printf("%lld", dfs(0, 0)); 
	return 0;
}
```

---

## 作者：YoungNeal (赞：13)

题解在博客[食用](http://www.cnblogs.com/YoungNeal/p/8746362.html)效果更佳哦~  
## Solution
考场上没想出来写的 30 分暴力诶

没想到现在就已经会了

我们定义某一时刻棋盘上的落子情况为当前的**状态**

定义 $s$ 为初状态，即棋盘上还没有落子

定义 $t$ 为末状态，即棋盘上已经落完子

不难证明，合法的状态小于二十万种

那么先 $HASH$ 一下每个状态，令其唯一对应一个正整数

对于每一个状态，我们可以知道它是从哪些状态转移来的

定义 $num[i]$ 表示 $i$ 状态落了多少子，方便判断当前是该先手还是该后手。

我们 $dp$ 要倒着推，因为如果正着推，有可能出现当前虽然求出了最大价值，但是却不是他们的最优策略的情况。

所以定义 $f[i]$ 表示从状态 $i$ 到末状态 $t$ 先手减后手的最大价值

 $f[t]$ 初值为$0$，$f[1]$ 即为答案

但是怎么求中间状态 $f[i]$ 的值呢？

之前提到过，可以求出 $i$ 状态是由 哪些状态转移来的，假设有一个状态为 $j$ 可以转移到 $i$

我们用 $num$ 数组求出在状态 $j$ 时是先手下了还是后手下了最后一个棋子，然后分情况讨论

如果是先手：考虑后手的最优策略，显然是想让 $f[i]$ 最小，所以 $f[i]=min{f[j]-b[x][y]}$，$x$、$y$ 是 $j$ 转移到 $i$ 状态落子的横纵坐标

同理，如果为后手：那么 $f[i]$ 最大的转移方程是 $f[i]=max{f[j]+a[x][y]}$，$x$、$y$ 的意义跟上面一样

那我们现在就剩最后一个问题了：怎么进行转移呢？

我这里利用了拓扑序进行转移：如果一个状态被所有的后续状态遍历完并求出最优解后，就将其 $push$ 进队列里，让它去转移状态即可。

最坏情况时间复杂度 O(18万*180万）  
但是开氧气优化跑的贼快，最慢的点 $300ms$ ~~(反正省选也开 O2 不算作弊)~~

## Code
```
// By YoungNeal
#include<map>
#include<queue>
#include<cstdio>
#include<cctype>
#define N 400005
#define int long long
#define mod 1000000007
using namespace std;

int head[N];
int cnt,s,t;
int n,m,tot;
int qp[N][15];
int f[N],fz[15];
int deg[N],num[N];
int a[15][15],b[15][15];

map<int,int> mp;
queue<int> topo;

struct Edge{
    int to,nxt,disa,disb;
}edge[N*10];

void add(int x,int y,int z,int p){
    edge[++cnt].to=y;
    edge[cnt].nxt=head[x];
    edge[cnt].disa=z;
    edge[cnt].disb=p;
    head[x]=cnt;
}

void hsh(int x){
    int d=0;tot++;
    for(int i=1;i<=n;i++)
        d=d*15+fz[i],d%=mod,qp[tot][i]=fz[i];
    mp[d]=tot;
    num[tot]=x;
    if(num[tot]&1) f[tot]=2e18;
    else f[tot]=-2e18;
}

void dfs(int now,int lim,int num){
    if(now>n){
        hsh(num);
        return;
    }
    for(int i=0;i<=lim;i++)
        fz[now]=i,dfs(now+1,i,num+i);
}

void _find(){
    int x=0,y=0;
    for(int i=1;i<=n;i++) y=y*15+m,y%=mod;
    s=mp[x],t=mp[y];
}

void read(int &x){
    x=0;char ch=getchar();
    while(!isdigit(ch)) ch=getchar();
    while(isdigit(ch)) x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
}

signed main(){
    scanf("%lld%lld",&n,&m);
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++) read(a[i][j]);
    }
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++) read(b[i][j]);
    }
    dfs(1,m,0);
    _find();
    f[t]=0;
    for(int i=2;i<=tot;i++){
        for(int j=n;j;j--){
            if(qp[i][j]==qp[i][j+1]) continue;
            int x=0;int idx=j,idy=qp[i][j];
            for(int p=1;p<=n;p++){
                if(p==j) x=x*15+qp[i][j]-1,x%=mod;
                else x=x*15+qp[i][p],x%=mod;
            }
            if(num[i]&1) add(i,mp[x],a[idx][idy],0);
            else add(i,mp[x],0,b[idx][idy]);
            deg[mp[x]]++;
        }
    }
    topo.push(t);
    while(topo.size()){
        int u=topo.front();topo.pop();
        for(int i=head[u];i;i=edge[i].nxt){
            int to=edge[i].to;
            if(num[to]&1) f[to]=min(f[to],f[u]-edge[i].disb);
            else f[to]=max(f[to],f[u]+edge[i].disa);
            deg[to]--;
            if(!deg[to]) topo.push(to);
        }
    }
    printf("%lld\n",f[1]);
    return 0;
}
```

---

## 作者：panda_2134 (赞：7)

这是一份暴力题解。

## Prelude

这个题当时在考场上马上就想到了Minimax搜索，然后带上AlphaBeta剪枝就可以乱搞了，一个小时连码带对拍搞完，然后开始~~睡觉~~干后面题的暴力

考试结束前5分钟我把题意看错了，慌得要命，改了之后样例输出3，交卷之前一分钟，潜意识中感到不对，连着按了30几下Ctrl-Z，撤回到了正确的版本，编译了一下，连样例都没测，就交卷了。还好rp好，没有WA声一片，还混了75= =

出场后和 @Anoxiacxy 分析了一下，发现似乎可以压轮廓线？考试的时候果然智商下线啊……

后来听说我省（HB）一个初三的dalao（就楼下那位）当场码出正解，无限膜拜orzorzorz

## 解法

这种 $n, m \le 10$ 的题，一看就是要暴力。但是直接暴力 + AlphaBeta剪枝 + 节点排序只能拿到70.

考虑直接爆搜+优化。如果每个状态中记录整个棋盘，每次扩展就要遍历整个棋盘找合适的点。考虑优化这个过程。

我们知道，如果按照题目的要求摆放，棋子一定构成包含棋盘左上角的一个连通块。由于我特别弱，不会轮廓线状压DP，就考虑只在状态中记录每行每列的最后一个棋子的位置（显然，已经摆放的棋子是谁的，对于状态的转移没有影响）。

棋子只会越来越多，所以构成一个DAG。打大暴力后发现有很多的重复状态，所以记忆化应该有用。每个状态里面有 $n+m$ 个数字，直接记录显然药丸，于是我们hash一下（其中pair记录的是状态-当前玩家）：

```cpp
namespace std {
    template<>
    struct hash<State> {
        size_t operator()(const State& s) const {
            size_t h = 0, base = 131;
            for(register int i = 1; i <= n; i++, base *= 13) 
                h += s.row[i] * base; // BKDRHash
            return h;
        }
    };
    template<typename T1, typename T2>
    struct hash<pair<T1, T2> > {
    	size_t operator()(const pair<T1, T2>& s) const {
    		size_t h = 0;
    		h = std::hash<T1>()(s.first) ^ std::hash<T2>()(s.second);
    		return h;
    	}
    };
}
```

这样就可以上 `unordered_map` 了。用`unordered_map`记忆化之后最后一个点就可以跑过了，而且也不慢。

## 代码

```cpp
/*
	暴力+hash_map
*/
#include <bits/stdc++.h>
#define fst first
#define snd second
using namespace std;

typedef pair<int, int> pii;
typedef pair<int, pii> Step;

const int MAXN = 10, INF = 0x3f3f3f3f;
int n, m, A[MAXN+10][MAXN+10], B[MAXN+10][MAXN+10];

struct State {
	int row[MAXN+10], col[MAXN+10];
	State() {
		memset(row, 0, sizeof(row)); 
		memset(col, 0, sizeof(col));
	}
	bool full() {
		for(int i = 1; i <= n; i++)
			if(row[i] != m) return false;
		return true;
	}
	bool possible(int x, int y) {
		return row[x] == y-1 && col[y] == x-1;
	}
	bool operator==(const State &rhs) const {
	    for(int i = 1; i <= n; i++)
	        if(row[i] != rhs.row[i]) return false;
	    return true;
	}
	const State& operator=(const State &rhs) {
		memcpy(row, rhs.row, sizeof(row));
		memcpy(col, rhs.col, sizeof(col));
		return (const State&) *this;
	}
} S;

namespace std {
    template<>
    struct hash<State> {
        size_t operator()(const State& s) const {
            size_t h = 0, base = 131;
            for(register int i = 1; i <= n; i++, base *= 13) 
                h += s.row[i] * base;
            return h;
        }
    };
    template<typename T1, typename T2>
    struct hash<pair<T1, T2> > {
    	size_t operator()(const pair<T1, T2>& s) const {
    		size_t h = 0;
    		h = std::hash<T1>()(s.first) ^ std::hash<T2>()(s.second);
    		return h;
    	}
    };
}

unordered_map<pair<State, int>, int > cache;

void init() {
	scanf("%d%d", &n, &m);
	for(int i = 1; i <= n; i++)
		for(int j = 1; j <= m; j++)
			scanf("%d", &A[i][j]);
	for(int i = 1; i <= n; i++)
		for(int j = 1; j <= m; j++)
			scanf("%d", &B[i][j]);
}

int Minimax(State &u, int player) {

	if(u.full()) return 0;

	if(cache.count({u, player}))
		return cache[{u, player}];

	int sz = 0; Step step[(MAXN+1) * 2];
	if(player == 1) {	//Max 玩家
		int maxv = -INF;
		for(int i = 1; i <= n; i++) if(u.row[i] < m && u.possible(i, u.row[i]+1))
			step[++sz] = { A[i][u.row[i]+1], {i, u.row[i]+1} };
		for(int i = 1; i <= sz; i++) {
			u.row[step[i].snd.fst]++; u.col[step[i].snd.snd]++;
			maxv = max(maxv, step[i].fst + Minimax(u, 3 - player));
			u.row[step[i].snd.fst]--; u.col[step[i].snd.snd]--;
		}
		cache[{u, player}] = maxv;
		return maxv;
	} else {	// Min 玩家
		int minv = INF;
		for(int i = 1; i <= n; i++) if(u.row[i] < m && u.possible(i, u.row[i]+1))
			step[++sz] = { -B[i][u.row[i]+1], {i, u.row[i]+1} };
		for(int i = 1; i <= sz; i++) {
			u.row[step[i].snd.fst]++; u.col[step[i].snd.snd]++;
			minv = min(minv, step[i].fst + Minimax(u, 3 - player));
			u.row[step[i].snd.fst]--; u.col[step[i].snd.snd]--;
		}
		cache[{u, player}] = minv;
		return minv;
	}
}

void work() {
	printf("%d", Minimax(S, 1));
}

int main() {
	init(); work();
	return 0;
}
```



---

## 作者：teafrogsf (赞：6)

## 写了个比较通俗易懂的。
首先我们可以发现，存每个位置的状态显然是不行的。而作者又比较弱不会轮廓线上DP，所以只会写爆搜。  
我们可以存储每一行放了多少个棋子，因为显而易见地，这些棋子都要放到最左边，所以可以很方便地表示一整个棋盘。  
然后开始简易的对抗搜索，先手时取max，后手时取min，理解方法许多题解都有提到，不再赘述。  
只需要每次判断在这一行下子是否可行，然后进行搜索即可。  
因为直接暴力存储13进制数的原因，跑的比较慢，最大点0.1s。~~对于我这样的juruo来说可以了~~
```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<tr1/unordered_map>
#define neko 12
#define chkmin(a,b) ((a)<(b)?(a):(b)) 
#define chkmax(a,b) ((a)>(b)?(a):(b))
#define f(i,a,b) for(register int i=(a);i<=(b);i=-(~i))
#define rf(i,a,b) for(register int i=(a);i>=(b);i=~(-i))
typedef long long ll;
int n,m,a[neko][neko],b[neko][neko],num[neko];
ll rdx=13;
std::tr1::unordered_map<ll,int>ht;
ll zip()//加密
{ll x=0;f(i,1,n)x=x*rdx+1ll*num[i];return x;}
void unzip(ll x)//解密
{rf(i,n,1)num[i]=x%rdx,x/=rdx;}
int dfs(ll now,bool hand)//hand=1 先手 =0 后手
{
    if(ht.count(now))return ht[now];
    unzip(now);int ans=hand?(-0x3f3f3f3f):(0x3f3f3f3f);ll aft;//注意初始值
    f(i,1,n)
    {
        if(num[i]<num[i-1])
        {
            ++num[i],aft=zip();
            if(hand)ans=chkmax(ans,dfs(aft,0)+a[i][num[i]]);
            else ans=chkmin(ans,dfs(aft,1)-b[i][num[i]]);
            --num[i];
        }
    }ht[now]=ans;
    return ans;
}
int main()
{
    scanf("%d%d",&n,&m);
    f(i,1,n)
     f(j,1,m)
      scanf("%d",&a[i][j]); 
    f(i,1,n)
     f(j,1,m)
      scanf("%d",&b[i][j]);
    f(i,0,n)num[i]=m;
    ht[zip()]=0;
    dfs(0,1);return printf("%d\n",ht[0]),0;//输出0状态的答案
}
```

---

## 作者：双管荧光灯 (赞：3)

我们用一个数组a表示状态，a[i]表示第i行已经前a[i]个格子放了棋子（显然棋子只能连续放），并且我们发现a[i]是单调不降的，暴搜发现共有不超过300000种可能，于是可以状压DP

状态可以用一个set进行存储，按字典序排序，就可以DP了

另外，这是博弈版的DP，所以dfs中加入一个量l,表示谁现在走，先手想要结果尽可能大，所以取max，后手想结果小，所以取min

```cpp
#include<stdio.h>
#include<iostream>
#include<stdlib.h>
#include<string.h>
#include<set>
using namespace std;
const int N=200005;
int n,m,a[11][11],b[11][11],i,j;
struct str{
    int a[11],c;
    bool operator <(const str &p) const
    {
        int i;
        for(i=1;i<=n;i++)
        {
            if(p.a[i]>a[i])
                return false;
            if(p.a[i]<a[i])
                return true;
        }
    }
}tmp;
set<str> f;
int dfs(str p,int l)
{
    int j;
    for(j=1;j<=n;j++)
        if(p.a[j]!=m)
            break;
    if(j>n)
        return 0;
    set<str>::iterator t;
    t=f.find(p);
    if(t!=f.end())
        return (*t).c;
    int s;
    if(l==1)
        s=1<<30;
    else
        s=-(1<<30);
    for(j=1;j<=n;j++)
        if((p.a[j]!=p.a[j-1]||j==1)&&p.a[j]!=m)
        {
            p.a[j]++;
            if(l==1)
                s=min(s,dfs(p,l^1)-b[j][p.a[j]]);
            else
                s=max(s,dfs(p,l^1)+a[j][p.a[j]]);
            p.a[j]--;
        }
    p.c=s;
    f.insert(p);
    return s;
}
int main()
{
    scanf("%d %d",&n,&m);
    for(i=1;i<=n;i++)
        for(j=1;j<=m;j++)
            scanf("%d",&a[i][j]);
    for(i=1;i<=n;i++)
        for(j=1;j<=m;j++)
            scanf("%d",&b[i][j]);
    printf("%d",dfs(tmp,0));
}

```

---

## 作者：VCode (赞：3)

https://vcode28629.coding.me/JSOI2018D1T1/

当时现场A了这道题，成功以非正式的身份吓到了正式选手。后来听讲解发现好像和我的思路不太一样，所以发一下我的做法

### 思考方向

考试的时候我就想，这可能是个博弈论，也可能是个DP

博弈论的话由于不是标准的求先手必胜还是必败，所以应该不是了。

那么就是DP了。而且是10\*10的，应该是个状压DP。所以先确定了总体思路：状压DP

### 关于A和B的处理

居然一个格子有两个参数，这样一下就复杂了，要是能变成一个就好了。

所以我试了各种方法（太过复杂不予描述），成功找到了正解：

ans最开始不设为0，设为所有B的和的相反数，然后把格子里A和B加起来就可以正常玩了。

Player1和Player2轮流落子，P1想让结果尽量大，P2落子不计算得分，想让结果尽量小。

### 如何状压

题目明显是在和我们说每一行棋子一定是左边的一串，并且这一串长度不会超过上面一串。10的二进制位为1010，4位。那么10个10放在一起就是40位，没有超过long long，状压成功。

二进制1010 1001 1000 0111 0110 0101 0100 0011 0010 0001的意思就是第一行10子，二行9子，3行8子，4行7子……10行1子

### DP状态的设定

我们肯定不能开1 << 40这么大的DP数组，所以需要离散化。那就DFS一遍枚举所有状态并且用map水一下就好了，反正开O2

我们知道如果一个状态确定了，那轮到谁就也确定了。所以dp[i]就索性设定为状态i下按最优策略博弈**还能**拿到的分数好了。

但是我比较懒，即使想到了也不想这么写，还不如干脆dp[i][1]为“下一步轮到第1个人走，那么最优策略下**还能**得到的分数是多少”，dp[i][0]为“下一步轮到第2个人走，那么最优策略下**还能**得到的分数是多少”

### DP的转移方程

dp[now][0] = min(dp[下一个状态][1]);

dp[now][1] = max(dp[下一个状态][0] + 到达状态能得到的分数);

OK，那到达状态能得到的分数怎么办？

### 到达状态能得到的分数

肯定就是现在的比后来的多出来的那一格的得分了，这个大家看我代码就能明白了，不用多说。

```cpp
//b before
//a after
inline int getX(long long b, long long a) {
  a -= b;
  for(int i = 1; i <= xlen; ++i) {
    if((15ll << ((xlen - i) << 2)) & a) {
      return i;
    }
  }
}
inline int getY(long long b, long long a) {
  int x = getX(b, a);
  return (a >> ((xlen - x) << 2)) & 15;
}
//unmap是一个逆向离散化的数组
inline int getArr(int b, int a) {
  return arr[getX(unmap[b], unmap[a])][getY(unmap[b], unmap[a])];
}
```

### 具体实现

由于我这么设的状态，所以逆向连边是肯定的了。

正常来说肯定是要拓扑排序了，但是我弱，考场上并没想到

所以我写了个SPFA。。。。

```cpp
// luogu-judger-enable-o2 O2不开会80分
#include<cstdio>
#include<cstring>
#include<map>
#include<queue>

template<typename T>
inline void input(T &var) {
  char ch = ' ';
  T ope = 1;
  while((ch < '0' || '9' < ch) && ch != '-') {
    ch = getchar();
  }
  if(ch == '-') {
    ope = -1;
    ch = getchar();
  }
  var = 0;
  while('0' <= ch && ch <= '9') {
    var = var * 10 + ch - '0';
    ch = getchar();
  }
  var *= ope;
}
template<typename T>
inline void output(T var) {
  if(var < 0) {
    putchar('-');
    var = -var;
  } else if(var == 0) {
    putchar('0');
    return;
  }
  if(var >= 10) {
    output(var / 10);
  }
  putchar(var % 10 + '0');
  return;
} 

struct Edge {
  Edge(int to, Edge *next) : to(to), next(next) {  }
  Edge *next;
  int to;
} *first[300000];

std::map<long long, int> map;
long long unmap[300000];
long long memery[300000][2];
int cnt = 0;
int xlen;
int ylen;
long long ans = 0;
int arr[15][15];

void init();
void build();
long long solve();

int main() {
  init();
  build();
  output(solve() + ans);
  return 0;
}

void getMap(int x, int last_y, long long res) {
  --x;
  map[res << ((xlen - x) << 2)] = ++cnt;
  unmap[cnt] = res << ((xlen - x) << 2);
  ++x;
  if(x > xlen) return;
  for(int y = 1; y <= last_y; ++y) {
    getMap(x + 1, y, (res << 4) | y);
  }
  return;
}

inline int getYByX(long long res, int x) {
  res >>= ((xlen - x) << 2);
  res &= 15;
  return res;
}

void init() {
  input(xlen);
  input(ylen);
  getMap(1, ylen, 0);
  for(int i = 1; i <= xlen; ++i) {
    for(int j = 1; j <= ylen; ++j) {
      input(arr[i][j]);
    }
  }
  int key;
  for(int i = 1; i <= xlen; ++i) {
    for(int j = 1; j <= ylen; ++j) {
      input(key);
      arr[i][j] += key;
      ans -= key;
    }
  }
  return;
}

inline void addEdge(int from, int to) {
  first[from] = new Edge(to, first[from]);
  return;
}

void build() {
  std::queue<long long> que;
  que.push(1ll << ((xlen - 1) << 2));
  static bool vis[300000];
  memset(vis, 0, sizeof(vis));
  vis[map[1ll << ((xlen - 1) << 2)]] = true;
  while(!que.empty()) {
    long long now = que.front();
    que.pop();
    if(getYByX(now, 1) < ylen) {
      long long next = now + (1ll << ((xlen - 1) << 2));
      //addEdge(map[now], map[next]);
      addEdge(map[next], map[now]);
      if(!vis[map[next]]) {
        que.push(next);
        vis[map[next]] = true;
      }
    }
    for(int i = 2; i <= xlen; ++i) {
      if(getYByX(now, i - 1) <= getYByX(now, i)) continue;//no <
      long long next = now + (1ll << ((xlen - i) << 2));
      //addEdge(map[now], map[next]);
      addEdge(map[next], map[now]);
      if(!vis[map[next]]) {
        que.push(next);
        vis[map[next]] = true;
      }
    }
  }
  return;
}

inline int getX(long long b, long long a) {
  a -= b;
  for(int i = 1; i <= xlen; ++i) {
    if((15ll << ((xlen - i) << 2)) & a) {
      return i;
    }
  }
}
inline int getY(long long b, long long a) {
  int x = getX(b, a);
  return (a >> ((xlen - x) << 2)) & 15;
}

inline int getArr(int b, int a) {
  return arr[getX(unmap[b], unmap[a])][getY(unmap[b], unmap[a])];
}

long long solve() {
  memset(memery, -1, sizeof(memery));
  addEdge(2, 1);
  long long fin = 0;
  for(int i = 1; i <= xlen; ++i) {
    fin <<= 4;
    fin |= ylen;
  }
  fin = map[fin];
  for(int i = 1; i <= cnt; ++i) {
    memery[i][0] = 0x7fffffffffffffff;
    memery[i][1] = 0x8000000000000000;
  }
  memery[fin][0] = memery[fin][1] = 0;
  
  std::queue<int> que;
  que.push((int)fin);
  static bool in_que[300000];
  memset(in_que, 0, sizeof(in_que));
  while(!que.empty()) {
    int now = que.front();
    que.pop();
    in_que[now] = false;
    for(Edge *edg = first[now]; edg != NULL; edg = edg->next) {
      bool flag = false;
      if(memery[now][1] < memery[edg->to][0]) {
        memery[edg->to][0] = memery[now][1];
        flag = true;
      }
      if(memery[edg->to][1] < memery[now][0] + getArr(edg->to, now)) {
        memery[edg->to][1] = memery[now][0] + getArr(edg->to, now);
        flag = true;
      }
      if(flag) {
        if(in_que[edg->to]) continue;
        in_que[edg->to] = true;
        que.push(edg->to);
      }
    }
  }
  return memery[1][1];
}
```

---

## 作者：JasonZRY (赞：2)

考虑一下所谓的两个人都是走最优策略

也就是对于第一个人，

它一定从当前局面可以到达的所有局面中，选择一个最大的走。

第二个人一定会从当前局面所有可以到达的局面中，选择一个最小的走。即A想最大化suma-sumb而B想要最小化suma-sumb 

(这就是所谓的min−max搜索或者叫对抗搜索) 

考虑一下所有的状态，一定是一个从上往下的阶梯型

因为n,m<=10

所以我们可以用一个n位的m+1进制数把当前下完的轮廓给哈希一下。

那么，对于一个局面，我们可以做记忆化搜索，

我们只需要根据局面当前下子的是谁，决定这个状态是最大还是最小。这样用map压下当前所有状态，直接搜索即可。。

代码：

```
#include<bits/stdc++.h>                         
using namespace std;
map<long long,int>ma;
int ln[15],n,m,a[15][15],b[15][15];
long long x;
long long hash(){
    long long ret=0;
	for(int i=1;i<=n;++i)ret=ret*11+ln[i];
	return ret;
}
void unhash(long long st){
    for(int i=n;i;--i)ln[i]=st%11,st/=11;
}
int Next(){
    int ret=0;
	for(int i=1;i<=n;++i)ret+=ln[i];
	return ret&1;
}
int dfs(long long st){
    if(ma.count(st))return ma[st];
    unhash(st);
    int opt=Next(),ret=opt?1e9:-1e9;
    for(int i=1;i<=n;++i)
        if(ln[i-1]>ln[i]){
            ln[i]++;
            long long now=hash();
            if(opt)ret=min(ret,dfs(now)-b[i][ln[i]]);
			else ret=max(ret,dfs(now)+a[i][ln[i]]);
            ln[i]--;
        }
    return ma[st]=ret;
}
int main(){
    scanf("%d%d",&n,&m);
	ln[0]=m;
    for(int i=1;i<=n;++i)for(int j=1;j<=m;++j)scanf("%d",&a[i][j]);
    for(int i=1;i<=n;++i)for(int j=1;j<=m;++j)scanf("%d",&b[i][j]);
    for(int i=1;i<=n;++i)x=x*11+m;
    ma[x]=0;
    dfs(0);
    printf("%d",ma[0]);
    return 0;
}
```
这个代码用cin cout会TLE，后来改成scanf printf就A了。

### 代码配上解释应该就能懂了，理解万岁，请勿抄袭OwO!!!

---

## 作者：ShineEternal (赞：2)

# 写在前面：如想获得更佳阅读效果，请点击[这里](https://blog.csdn.net/kkkksc03/article/details/85011315)

非省选蒟蒻来水一发题目，求过。

# 题目链接：https://www.luogu.org/problemnew/show/P4363

# 分析：
首先博弈，然后考虑棋盘的规则，因为一个子在落下时它的上面和左面都已经没有空位了，所以棋子的右下的轮廓线一定是个凸包，更具体地，从棋盘的左下沿着棋盘边界或棋子轮廓线走到棋盘右上，所走的路径一定只有向上和向右两种。

# 代码：

```cpp
#include<cstdio>
using namespace std;
const int maxn=25,N=1<<20,INF=0x3f3f3f3f;
int f[N],n,m,nm,c[2][maxn][maxn];bool vis[N];
void Max(int &x,int y)
{
    if(x<y)
        x=y;
    
}
int Run(int now,bool rt)
{
    if(vis[now])
    return -f[now];
    vis[now]=true;
    int &ans=f[now],k=0,i,j,cur=now,cnt=0;
    ans=-INF;
    for(k=0;now&&(k<nm);k++,cnt+=i)
    {
        i=now&1,now>>=1,j=now&1;
        if(i&&!j)
            Max(ans,Run(cur^(3<<k),!rt)+c[rt][k+1-cnt][m-cnt]);
    }
    return -ans;
}
int main()
{
    int i,j;
    scanf("%d%d",&n,&m),nm=n+m-1;
    for(i=1;i<=n;i++)
        for(j=1;j<=m;j++)
            scanf("%d",&c[0][i][j]);
    for(i=1;i<=n;i++)
        for(j=1;j<=m;j++)
            scanf("%d",&c[1][i][j]);
    vis[((1<<m)-1)<<n]=true,printf("%d\n",-Run((1<<m)-1,0));
    return 0; 
}
```



---

## 作者：Ryan_ (赞：0)

先手希望先手得分减后手得分最大，后手希望先手得分减后手得分最小

棋盘的局面一定是阶梯状，且从上往下递减

可以将轮廓线作为状态，记忆化搜索

用n个数表示一个状态，第i个数表示第i行放了几个

记忆的状态表示当棋盘为这个状态时，接下来再下的最有解

记忆化搜索节省的是接下来再下的时间

```
#include<map>
 
#include<cstdio>
 
#include<cstring>
 
#include<iostream>
 
#include<algorithm>
 
   
 
#define N 11
 
    
 
using namespace std;
 
   
 
int n,m;
 
   
 
int a[N][N],b[N][N];
 
   
 
struct node
 
{
 
    int v[N];
 
    node()
 
    {
 
        memset(v,0,sizeof(v));
 
    }
 
    bool operator < (node p) const
 
    {
 
        for(int i=1;i<=n;++i)
 
            if(v[i]<p.v[i]) return true;
 
            else if(v[i]>p.v[i]) return false;
 
    }
 
};
 
map<node,int>mp;
 
   
 
int dfs(node now,bool who)
 
{
 
    if(mp.find(now)!=mp.end()) return mp[now];
 
    int i;
 
    for(i=1;i<=n;++i)
 
        if(now.v[i]<m) break;
 
    if(i>n) return 0;
 
    int s;
 
    if(!who) s=-2e9;
 
    else s=2e9;
 
    for( i=1;i<=n;++i)
 
         if(now.v[i]!=m && (now.v[i]<now.v[i-1] || i==1))
 
         {
 
             now.v[i]++;
 
             if(!who) s=max(s,dfs(now,who^1)+a[i][now.v[i]]);
 
             else s=min(s,dfs(now,who^1)-b[i][now.v[i]]);
 
             now.v[i]--;
 
        }
 
    return mp[now]=s;
 
}
 
   
 
int main()
 
{
 
 //  freopen("data.in","r",stdin);
 
    scanf("%d%d",&n,&m);
 
    for(int i=1;i<=n;++i)
 
         for(int j=1;j<=m;++j)
 
             scanf("%d",&a[i][j]);
 
    for(int i=1;i<=n;++i)
 
         for(int j=1;j<=m;++j)
 
             scanf("%d",&b[i][j]);
 
    node now;
 
    printf("%d",dfs(now,0));
 
}
```


---


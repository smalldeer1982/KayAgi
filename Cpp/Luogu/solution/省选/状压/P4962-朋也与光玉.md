# 朋也与光玉

## 题目背景

> 一つ一つの光は小さくでも、たくさん集まればきっととても不思議な大きな力になるはず。 

渚的离世、汐的离去...朋也的人生几乎陷入了一片黑暗。

但是，这会是结束吗？

![](https://i.loli.net/2018/10/04/5bb5f64297c70.jpg)

## 题目描述

光坂小镇是一个由 $n$ 个点（编号为 $1$ ~ $n$），$m$ 条有向边构成的图，每个节点上都有一个光玉，光玉共有 $k$ 种，编号为 $0$ ~ $k-1$。

为了使一切改变，朋也需要找齐全部的 $k$ 种光玉。他可以从任意一个节点出发，在图上任意行走，但不会经过同一个节点两次，每碰到一个光玉便会将其收集，收集到 $k$ 个光玉后，即经过了 $k$ 个节点后，便不会继续收集。请设计一种方案，使得朋也能够收集全部的 $k$ 种光玉，且走过的路径长度最短。

换句话说，每个点一个颜色，找到一条最短的点数为 $k$ 、恰好经过全部 $k$ 种颜色的路径。你需要求出这条路径的长度。

## 说明/提示

$2\le n\le 100$，$1\le m\le n(n-1)$，$2\le k\le 13$，$1\le w_i\le 10^7$

保证图中没有重边、自环。

## 样例解释

样例一，$3\rightarrow 6\rightarrow 7$ 为一组最优解。

样例二，无解。

样例三，最优解为 $4\rightarrow 5\rightarrow 2$。

## 样例 #1

### 输入

```
8 19 3
1 2 0 1 1 1 2 0
3 1 4
3 2 2
1 4 1
7 4 10
5 4 7
4 2 5
5 6 4
4 7 3
8 5 10
3 6 8
8 1 10
5 2 10
6 7 3
4 3 9
6 2 5
4 8 10
3 8 3
1 7 8
1 3 9```

### 输出

```
11```

## 样例 #2

### 输入

```
5 6 3
0 1 1 2 2
1 2 3
2 3 2
1 4 2
5 2 1
1 3 4
5 4 1```

### 输出

```
Ushio!```

## 样例 #3

### 输入

```
6 13 3
2 2 2 1 0 2
1 4 4
3 4 8
5 3 2
4 5 6
2 3 2
1 3 3
1 2 4
3 1 4
6 3 6
3 2 6
2 1 6
4 2 9
5 2 1```

### 输出

```
7```

# 题解

## 作者：_虹_ (赞：8)

蒟蒻的首道状压题...

太蒟蒻，下面有些概念很可能会说的不准确。。。

这个程序可能算记忆化搜索的解法？（我还是觉得叫它剪枝搜索更直观。）

跑的出乎意料的快，吸氧总时间在720ms到790ms波动，最慢点170ms~180ms，不吸氧1100ms左右，考场上卡了我很久的#8这样剪枝之后用10ms就过了...（可能是数据比较适合这样写）~~（乱搞碾标算）~~

比赛时的最优解，管理员神犇出现后的次优解(tql QAQ)。

时间复杂度：**O(玄学)**

（理论上界应该很惨，但是基本上不可能达到，所以貌似没法算？）~~（能算也不会算，我太蒻了）~~
```cpp
#include <iostream> 
using namespace std;
#define I_MAX 2147483647
const int kmaxn=100+5;
int point[kmaxn];//该点颜色
int map[kmaxn][kmaxn];//邻接矩阵
int cut[32767+5][kmaxn];//cut[状态][当前位置]表示记录每个情况的最优解
int ans=I_MAX,n,m,k;
int u,v,w;
void dfs(int status,int pos,int dest,int deepth=1)//status的每个二进制位表示是否拿了这种光玉
{
    if((status>>point[pos])&1||ans<=dest||(cut[status][pos]!=0&&cut[status][pos]<=dest))//拿过的光玉重复或不可能是最优解，那就不走
        return;
    if(deepth>=k)//都取完了，更新答案
    {
        ans=min(ans,dest);//其实min没啥用，上面的if剪枝保证了dest<ans（刚发现）
        return;
    }
    cut[status][pos]=dest;//这应该属于记忆化吧，反正我是用来剪枝了，毕竟这个dfs函数没有返回值
    status+=1<<point[pos];//更新当前状态
    for(register int i=1;i<=n;++i)//遍历出边
    {
        if(map[pos][i])dfs(status,i,dest+map[pos][i],deepth+1);//能走就试着走
    }
}
int main()
{
    ios::sync_with_stdio(false);
    cin>>n>>m>>k;
    for(register int i=1;i<=n;++i)
    {
        cin>>point[i];
    }
    for(register int i=0;i<m;++i)
    {
        cin>>u>>v>>w;
        map[u][v]=w;//m最大为n(n-1)，很适合邻接矩阵存边
    }
    for(register int i=1;i<=n;++i)
    {
        dfs(0,i,0);//从每个点开始搜
    }
    if(ans==I_MAX)
    {
        cout<<"Ushio!"<<endl;
    }
    else
    {
        cout<<ans<<endl;
    }
    return 0;
}
```
这篇题解只说记忆化（剪枝？），不写递推，因为我不会。。。。

最近爆了好几场0，明天还要期中考试，希望写个题解能rp++;~~也希望管理员给个通过。~~

---

## 作者：S_S_H (赞：6)

### 又一道状压......
推荐做过或没做过的同学们做一下

[P4802 [CCO 2015]路短最](https://www.luogu.org/problem/P4802)

[P4772 灰化肥，会挥发](https://www.luogu.org/problem/P4772)

这两道状压题，和这个题很像，推荐食用我的题解......

题目简化：说的很清楚了，每个点一个颜色，找到一条最短的点数为 k 、恰好经过

全部 k 种颜色的路径，求出这条路径的长度。

数据范围2 ≤ k ≤ 13可以状压

那我们是用递推还是搜索？貌似很麻烦......~~其实就是不会~~

因为和P4802和P4772相比，此题唯一的不同就是节点不再具有唯一性

~~（很简单）~~
就是我这个颜色可以由很多节点转移而来，转移时枚举转移点无法考虑边的长度

本蒟蒻只能考虑记忆化搜索

定义状态check[ S ][ t ]表示已取节点状态为S以t为节点的情况下的最长路

#### 因为走过的不可以再走，就相当于这个图中所有已有状态的节点都已经不可走

所以该状态与从那条路径来没有关系，满足无后效性。我们这里的check数组可以

作为记忆化数组来用，如果现状态的值比它大，就可以舍弃掉。

分析到这里，我们O( n ! / 玄学 )代码已经构思完了

很简洁的代码：

```cpp
#include<iostream>
#include<cstdio>
const int inf=2147483647;
const int maxm=(1<<14)-1;
using namespace std;
int n,m,k,ans=inf,color[110],map[110][110],check[110][(1<<14)];
void dfs(int now,int len,int s,int num){//表示：当前节点，已有光玉个数，现状态，路径和
	if((s&(1<<color[now]))||ans<=num||check[now][s]<=num) return;//记忆化
	if(len==k){
		ans=num;
		return;
	}
	check[now][s]=num;
	for(int i=1;i<=n;i++)
		if(map[now][i]!=inf)
			dfs(i,len+1,s|(1<<color[now]),num+map[now][i]);
}
int main(){
	scanf("%d%d%d",&n,&m,&k);
	for(int i=1;i<=n;i++)
		scanf("%d",&color[i]);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			map[i][j]=inf;
	for(int i=1;i<=m;i++){
		int u,v,c;
		scanf("%d%d%d",&u,&v,&c);
		map[u][v]=c;
	}
	for(int i=1;i<=n;i++)
		for(int j=0;j<=(1<<k)-1;j++)
			check[i][j]=inf;
	for(int i=1;i<=n;i++)
		check[i][1<<color[i]]=0;
	for(int i=1;i<=n;i++)
		dfs(i,1,0,0);
	ans==inf?printf("Ushio!"):printf("%d",ans);//异端的三目运算
	return 0;
}
```
## 最后祝大家2019CSP NOI XXXOI RP++! ! !

---

## 作者：CYJian (赞：4)

这里给出蒟蒻比赛的一种玄学dp。。

首先可以设置状态$f[i][j]$表示当前已经拥有$i$这个集合的光玉，且在$j$号点的最短路径。

然后我们可以显然的得到初始状态为$f[1<<a[i]][i]=0$

然后蒟蒻直接连边后把这个当做$SPFA$在跑了。。

具体见代码注释。

```
#include <bits/stdc++.h>

using namespace std;

#define reg register
#define ge getchar()
#define ll long long
#define MAXN 100

template<typename T>
inline bool chkmin(reg T&a, reg T b) { return (a > b) && ((a = a < b ? a : b) || 1); }
template<typename T>
inline T read(reg T&x) {
  reg char ch, f = 0; x = 0;
  while(!isdigit(ch = ge)) f |= ch == '-';
  while(isdigit(ch)) x = (x << 1) + (x << 3) + (ch ^ 48), ch = ge;
  return x = f ? -x : x;
}
//上面为选择最小值并返回是否更新和快读的简单函数。

int n, m, k, inf;
int a[MAXN + 1];//每一个节点的光玉是什么

int tot;
int fi[MAXN + 1];
int le[MAXN * MAXN + 1];
int to[MAXN * MAXN + 1];
int ne[MAXN * MAXN + 1];

inline void Link(reg int u, reg int v, reg int w) {
  tot++;
  to[tot] = v;
  le[tot] = w;
  ne[tot] = fi[u];
  fi[u] = tot;
}//邻接链表连边。


inline void BFS() { //这里就是dp的过程了。
  reg int f[MAXN + 1][1 << 13]; //这里可能和上面的有一些出入，但是就是上面的把i和j交换了一下而已。
  reg bool in[MAXN + 1][1 << 13];//是否在队列里面。
  queue<int>q, s; //懒得写pair，于是开了两个队列。
  memset(f, 127, sizeof(f)); //初始化为inf
  memset(in, false, sizeof(in)); //清空。
  for(reg int i = 1; i <= n; i++) q.push(i), s.push(1 << a[i]), f[i][1 << a[i]] = 0;//初始化。
  reg int ans = f[0][0], S = (1 << k) - 1;
  while(!q.empty()) {//以下内容非常接近SPFA。。
    reg int x = q.front(), t = s.front(), i, u, T;
    q.pop(), s.pop();
    in[x][t] = false;//已经出队。
    for(i = fi[x]; i; i = ne[i]) {
      u = to[i];
      if(t & (1 << a[u])) continue;//如果下一个点的光玉已经拿到过了就跳过。
      T = t | (1 << a[u]); //否则计算出得到的光玉集合。
      if(chkmin(f[u][T], f[x][t] + le[i]) && !in[u][T]) {//如果答案更新了并且没有在队列中，那么加入队列。同SPFA。
        q.push(u);
        s.push(T);
        in[u][T] = true;
      }
    }
  }
  for(reg int i = 1; i <= n; i++)
    chkmin(ans, f[i][S]);//找到最小的答案。
  if(ans == f[0][0]) puts("Ushio!");//无解。f[0][0]中存的是一开始的inf值。
  else printf("%d\n", ans);//否则输出答案。
}

int main() {
  read(n), read(m), read(k);
  for(reg int i = 1; i <= n; i++) read(a[i]);
  for(reg int i = 1, u, v, w; i <= m; i++)//连边。
    read(u), read(v), read(w), Link(u, v, w);
  BFS();
  return 0;
}
```

---

## 作者：pangyuchen75 (赞：3)

## 思路

首先，发现 $2 \le k \le 13$，则 $4 \le 2^k \le 8192$，不难发现可以用状压。

暴力的 DFS 肯定是会超时的。

所以我们可以使用状压的记忆化搜索来解决这道问题。

## 代码

代码主要分为两部分，输入（inp）和计算（work）。

然后我用了链式前向星来存图。

接下来解释一下 DFS 部分。

参数：$u$ 表示当前遍历到的点，$state$ 表示当前收集到的光玉的状态（二进制状压后）。

首先判断如果当前状态已经有答案了，就直接返回该答案。

如果光玉已经收集全了，就直接把当前的答案设为 $0$，并返回 $0$。

接下来遍历所有子节点，判断如果当前光玉状态没有包含该子节点的光玉，就遍历该子节点，最后求出所有的答案加上该条边的权值的最小值作为答案并返回即可。

C++ 代码如下：

```cpp
#include <cstdio>
#include <cstring>
using namespace std;

const int N = 105;
const int M = 1e4 + 5;
const int inf = 0x3f3f3f3f;

int n, m, k;
int val[N];
int tot, head[N];
int to[M], wei[M], nxt[M];
int f[N][1 << 13];
int ans;

void bemin(int &a, int b) {
	a = a < b ? a : b;
}

void add(int u, int v, int w) {
	to[tot] = v;
	wei[tot] = w;
	nxt[tot] = head[u];
	head[u] = tot ++ ;
}

int dfs(int u, int state) {
	if (f[u][state] != inf)
		return f[u][state];
	
	if (state == (1 << k) - 1)
		return f[u][state] = 0;
	
	int res = inf;
	
	for (int i = head[u]; i != -1; i = nxt[i]) {
		int v = to[i];
		int w = wei[i];
		
		if (state & (1 << val[v]))
			continue;
		
		bemin(res, w + dfs(v, state | (1 << val[v])));
	}
	
	return f[u][state] = res;
}

void inp() {
	scanf("%d%d%d", &n, &m, &k);
	memset(head, -1, sizeof head);
	
	for (int i = 1; i <= n; ++i)
		scanf("%d", &val[i]);
	
	while (m -- ) {
		int u, v, w;
		scanf("%d%d%d", &u, &v, &w);
		add(u, v, w);
	}
}

void work() {
	memset(f, 0x3f, sizeof f);
	ans = inf;
	
	for (int i = 1; i <= n; i ++ )
		bemin(ans, dfs(i, 1 << val[i]));
	
	if (ans == inf)
		puts("Ushio!");
	else
		printf("%d\n", ans);
}

int main() {
	inp();
	work();
	
	return 0;
} 
```

# 完结撒花！

---

## 作者：Wsl886 (赞：2)

## 分析
首先 $2\le k\le 13$ 很容易看出这是一道状压题。

但是正常的 DFS 肯定是会超时的，所以要用一个简单但又非常实用的优化技巧——记忆化搜索。

注意事项都放在代码里了。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=110,inf=0x3f3f3f3f,M=1<<13;
int n,m,k,mp[N][N],a[N],ans=inf;
int f[N][M];
int dfs(int id,int x)
{
	if(f[id][x]!=inf) return f[id][x];
	if(x==(1<<k)-1) return f[id][x]=0;//已经全拿了
	int ret=inf;
	for(int i=1;i<=n;i++){
		if(!mp[id][i]) continue;//0就是没有边
		if(x&(1<<a[i])) continue;//如果已经拿到了编号为a[i]的光玉就跳过
		ret=min(ret,mp[id][i]+dfs(i,x|(1<<a[i])));
	}
	return f[id][x]=ret;
}
int main()
{
	memset(f,0x3f,sizeof f);//一定要赋初值
	cin>>n>>m>>k;
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=1;i<=m;i++){
		int u,v,w;
		cin>>u>>v>>w;
		mp[u][v]=w;
	}
	for(int i=1;i<=n;i++){
		ans=min(ans,dfs(i,1<<a[i]));
	}
		
	if(ans==inf) cout<<"Ushio!\n";//inf即为没找到
	else cout<<ans<<"\n";
}
```

## 结尾
#### 所有的故事都应该有一个美好的结尾！
#### 如有不对请大佬指出。

---

## 作者：crashed (赞：2)

# 朋也与光玉
# 题目
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[点这里](https://www.luogu.com.cn/problem/P4962)看题目。  
# 分析
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;比较~~套路~~规矩的一道题。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;看到$k$很小，所以可以想到写状压。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不难想到 DP ：  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$f(u,S)$：到节点$u$上，已得到光玉集合为$S$的最短距离。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;转移如下：  
$$f(u,S)=\min_{(v,u)\in E}\{f(v,S-\{a_u\})+w(v,u)\}$$  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于这是在图上，所以会存在环。因此用 Dijkstra 来解决这个 DP。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;时间为$O(n2^k(k+\log_2n))$。  
# 代码
```cpp
#include <queue>
#include <cstdio>
using namespace std;

typedef long long LL;

const LL INF = 0x3f3f3f3f3f3f3f3f;
const int MAXN = 105, MAXM = MAXN * MAXN, MAXK = 13, MAXS = ( 1 << 13 ) + 5;

template<typename _T>
void read( _T &x )
{
	x = 0;char s = getchar();int f = 1;
	while( s > '9' || s < '0' ){if( s == '-' ) f = -1; s = getchar();}
	while( s >= '0' && s <= '9' ){x = ( x << 3 ) + ( x << 1 ) + ( s - '0' ), s = getchar();}
	x *= f;
}

template<typename _T>
void write( _T x )
{
	if( x < 0 ){ putchar( '-' ); x = ( ~ x ) + 1; }
	if( 9 < x ){ write( x / 10 ); }
	putchar( x % 10 + '0' );
}

template<typename _T>
_T MIN( const _T a, const _T b )
{
	return a < b ? a : b;
}

struct edge
{
	int to, nxt, w;
}Graph[MAXM];

struct node
{
	LL dist; int u, S;
	node() { dist = u = S = 0; }
	node( const int U, const int s, const LL D ) { u = U, S = s, dist = D; }
	bool operator < ( const node & b ) const { return ! ( dist < b.dist ); }
};

priority_queue<node> q;

LL dist[MAXN][MAXS];
int head[MAXN], a[MAXN];
int N, M, K, cnt;
bool visited[MAXN][MAXS];

void addEdge( const int from, const int to, const int W )
{
	Graph[++ cnt].w = W, Graph[cnt].to = to, Graph[cnt].nxt = head[from];
	head[from] = cnt;
}

void Dijkstra()
{
	while( ! q.empty() ) q.pop();
	for( int i = 1 ; i <= N ; i ++ )
		for( int S = 0 ; S < 1 << K ; S ++ )
			dist[i][S] = INF, visited[i][S] = false;
	for( int i = 1 ; i <= N ; i ++ ) q.push( node( i, 1 << a[i], dist[i][1 << a[i]] = 0 ) );
	node h;
	int u, S, v, vS, w;
	while( ! q.empty() )
	{
		h = q.top(), q.pop();
		if( visited[u = h.u][S = h.S] ) continue; visited[u][S] = true;
		for( int i = head[u] ; i ; i = Graph[i].nxt )
		{
			v = Graph[i].to;
			if( S & ( 1 << a[v] ) ) continue;
			vS = S | ( 1 << a[v] );
			if( ! visited[v][vS] && dist[v][vS] > dist[u][S] + ( w = Graph[i].w ) )
				q.push( node( v, vS, dist[v][vS] = dist[u][S] + w ) );
		}
	}
}

int main()
{
	read( N ), read( M ), read( K );
	for( int i = 1 ; i <= N ; i ++ ) read( a[i] );
	for( int i = 1, a, b, c ; i <= M ; i ++ ) read( a ), read( b ), read( c ), addEdge( a, b, c );
	Dijkstra();
	LL ans = INF;
	for( int i = 1 ; i <= N ; i ++ ) ans = MIN( ans, dist[i][( 1 << K ) - 1] );
	if( ans == INF ) puts( "Ushio!" );
	else write( ans ), putchar( '\n' );
	return 0;
}
```

---

## 作者：VenusM1nT (赞：2)

我：DFS+状压可以伐

Sooke：可以啊，你加油

望着一半的TLE，我陷入了沉思……

~~沉思个P看小IG虐场去~~

既然裸的DFS不行（其实我加了几个剪枝），那么就要大优化，也就是使用记忆化搜索

我们用$f[u][state]$来表示当前点编号为$u$，状态为$state$时的最小花费

这个记搜看着没毛病吧？但、是、，这个$***$的#$8$……无力吐槽

本来按照楼下大佬的写法写了一个时间戳……但是4e7就会炸，必须写1e7_(:△」∠)_

可能我就是天生自带大常数的男愣吧(；′⌒`)

其他的就是DFS+状压，在check的时候我们可以直接把当前的$state$和$1<<k-1$比较，就不用一位一位与了

见代码

```
#include<bits/stdc++.h>
using namespace std;
int cnt,fst[105],nxt[10005],to[10005],w[10005];
int n,m,k,a[105],f[105][10005],ans=2147400000,Index;
bool vis[105];
void AddEdge(int u,int v,int c)//链式前向星赛高！
{
    to[++cnt]=v;
    nxt[cnt]=fst[u];
    fst[u]=cnt;
    w[cnt]=c;
}
void Dfs(int u,int ss,int sum,int dian)
{
	Index++;//时间戳
    if(Index>10000000 || vis[u] || ans<sum || dian>k || f[u][ss]<sum) return;//一堆迷之剪枝
    int mubiao=(1<<k)-1;
    f[u][ss]=sum;//记搜
    if(ss==mubiao && dian==k)//check答案
    {
        ans=min(ans,sum);
        return;
    }
    vis[u]=1;
    for(int i=fst[u];i;i=nxt[i])//拓展点
    {
        int v=to[i],s=ss;
        if(s&(1<<a[v])) continue;//如果下一个点的已经收集过就不去了
		s|=1<<a[v];
        Dfs(v,s,sum+w[i],dian+1);
    }
    vis[u]=0;//没什么卵用的回溯
}
int main()
{
    scanf("%d %d %d",&n,&m,&k);
    for(int i=1;i<=n;i++) scanf("%d",&a[i]);
    for(int i=1;i<=m;i++)
    {
        int x,y,z;
        scanf("%d %d %d",&x,&y,&z);
        AddEdge(x,y,z);
    }
    for(int i=1;i<=n;i++)
    {
        memset(vis,0,sizeof(vis));
        memset(f,60,sizeof(f));//不要忘了设初值
        Dfs(i,1<<a[i],0,1);
    }
    if(ans==2147400000) printf("Ushio!");//判断无解
    else printf("%d",ans);
    return 0;
}
```

---

## 作者：Citlali_qwq (赞：2)

## 题意

给定一个 $n$ 个点 $m$ 条边的有向图，每一个点有一个颜色 $a_i$，现在让你找到一个最短的点数为 $k$ 且恰好经过全部 $k$ 种颜色的路径。求出这条路径的长度。

## 分析

首先考虑裸的 $\operatorname{dfs}$ 加上状压。

$dfs(u,s)$ 表示当前走到了 $u$ 号点，已经收集了 $s$ 种颜色的路径长度。这种做法显然会超时。

不妨考虑记忆化搜索，$dp[u][s]$ 表示走到了 $u$ 号点，状态（收集到的颜色）为 $s$ 的最小长度。

这种做法很行，但是交上去一看，只有 $93$，考虑玄学优化。使用一个时间戳，只用跑大约 $10^7$ 左右是可以跑出答案的，这样可以节约很多不必要的搜索。

剩下的细节可以看代码。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN = 2e4 + 10;
const int MR = 2e2 + 10;
const int INF = 0x3f3f3f3f;
int n, m, k;
int a[MAXN];
int head[MAXN], to[MAXN], ne[MAXN], w[MAXN], id;
int dp[MR][MAXN];
bool vis[MAXN];
void add(int x, int y, int z)
{
	to[++id] = y;
	w[id] =z;
	ne[id] = head[x];
	head[x] = id;
}
int ans = INF;
int tim = 0;
void dfs(int u, int state, int sum, int step)
{
	if(vis[u] || ans < sum || step > k || dp[u][state] < sum)return ;
	int aim = (1 << k) - 1;
	dp[u][state] = sum;
	if(state == aim && step == k)
	{
		ans = min(ans, sum);
		return ;
	}
	vis[u] = true;
	for(int i = head[u]; i; i = ne[i])
	{
		int v = to[i];	
		int ts = state;
		if(ts & (1 << a[v]))continue;
		ts |= (1 << a[v]);
		dfs(v, ts, sum + w[i], step + 1);
	}
	vis[u] = false;
}
int main()
{
	cin >> n >> m >> k;
	for(int i = 1; i <= n; i++)cin >> a[i];
	for(int i = 1, x, y, z; i <= m; i++)
	{
		cin >> x >> y >> z;
		add(x, y, z);
	}
	for(int i = 1; i <= n; i++)
	{
		memset(vis, false, sizeof vis);
		memset(dp, 0x3f, sizeof dp);
		dfs(i, (1 << a[i]), 0, 1);
	}
	if(ans == INF)puts("Ushio!");
	else cout << ans << endl;
}
```

#### 后记

看完 `Clanned` 以后再来看这道题感觉很震撼，尤其是无法收集完成时输出 `Ushio!` 是真的有点抽象（（（

---

## 作者：linghuchong_ (赞：1)

# 朋也与光玉(Sol)

### 简述：  
每个点一个颜色，找到一条最短的点数为 k 、恰好经过全部 k 种颜色的路径。你需要求出这条路径的长度。

### 思路：  
以$dp[i][S]$表示当前在第$i$号点，已经找到的光玉为$S"$所需要走的最短路程。

### 详解：  
考虑如何进行状压DP。对于每一个点，我们遍历它所有能通往的点，这个时候下一个点对应的状态就是 S|(1<<yu[v])

这样得到dp转移方程：

$dp[u][s]=min\{dp[v][s|(1<<yu[v])]\}$

dp的过程用dfs实现。代码如下。

AC CODE:
```cpp
#include <bits/stdc++.h>
#define inf 999999999
using namespace std;
const int maxn=110;
const int maxm=1e5+10;
const int maxk=14;
struct edge{int t,n,w;}e[maxm];
int ans=inf,eid,p[maxn],n,m,k,dp[maxn][1<<maxk],yu[maxn],u,v,w;
void ins(int u,int v,int w){e[++eid].t=v,e[eid].w=w,e[eid].n=p[u];p[u]=eid;}
int dfs(int u,int s)
{
    if(s==(1<<k)-1)return dp[u][s]=0;
    if(dp[u][s])return dp[u][s];
    int res=inf;
    for(int i=p[u];i;i=e[i].n)
    {
        int v=e[i].t,w=e[i].w;
        if((1<<yu[v])&s)continue;
        res=min(res,dfs(v,s|(1<<yu[v]))+w);
    }
    return dp[u][s]=res;
}
signed main()
{
    cin>>n>>m>>k;
    for(int i=1;i<=n;i++)cin>>yu[i];
    for(int i=1;i<=m;i++){cin>>u>>v>>w;ins(u,v,w);}
    for(int i=1;i<=n;i++)ans=min(ans,dfs(i,1<<yu[i]));
    if(ans>=inf)cout<<"Ushio!"<<endl;
    else cout<<ans<<endl;
    return 0;
}
```


---

## 作者：Kelvin2009 (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P4962)

这是一道状态压缩的记忆化搜索。

考虑设计状态，用 $st$ 来表示有哪些种类已取到：对于第 $i$ 位，取到为 $1$，否则为 $0$，表示第 $i$ 种光玉是否已收集。

对于记忆化，用 $rec_{i,st}$ 表示当前状态为 $st$，刚遍历完 $i$ 点所能经过的最短路径长度。显然若当前的路径的长度已超过 $rec_{i,st}$，就没有必要再搜下去了。

只有记忆化显然还是过不去，考虑当前的路径长度已不小于记录的最小路径长度，也没有必要再搜下去了。

对应题目要求，只有当前还没有的玉石才能收集，只要发现该类玉石已被收集，立马跳过。

------------
代码：

------------

```cpp
#include<bits/stdc++.h>
using namespace std;
const int range=105;
const int st_ran=1<<14;
const int lim=0x3f3f3f3f;
int n,m,k,u,v,ans,a[range],rec[range][st_ran],grap[range][range];
void dfs(int u,int num,int st,int sum,bool fir)
{
	if(sum>=ans || (rec[u][st]<=sum && !fir)) return;
	if(num==k) void(ans=sum);
	rec[u][st]=sum;
	for(int i=1;i<=n;i++) if(grap[u][i] && !(st&(1<<a[i]))) dfs(i,num+1,st|(1<<a[i]),sum+grap[u][i],0);
	return ;
}
int main()
{
	ans=lim;
	scanf("%d%d%d",&n,&m,&k);
	for(int i=1;i<=n;i++) scanf("%d",&a[i]);
	while(m--)
	{
		scanf("%d%d",&u,&v);
		scanf("%d",&grap[u][v]);
	}
	for(int i=1;i<=n;i++) for(int j=0;j<st_ran;j++) rec[i][j]=lim;
	for(int i=1;i<=n;i++) rec[i][1<<a[i]]=0;
	for(int i=1;i<=n;i++) dfs(i,1,1<<a[i],0,1);
	if(ans==lim) printf("Ushio!");
	else printf("%d",ans);
	return 0;
}
```

---

## 作者：Infinite_Eternity (赞：0)

# Description

[P4962 朋也与光玉](https://www.luogu.com.cn/problem/P4962)

有一张 $n$ 个点 $m$ 条边的有向图，每个点一个颜色，找到一条最短的点数为 $k$，且恰好经过全部 $k$ 种颜色的路径。求出这条路径的长度。

数据范围：$2\le n\le 100$，$1\le m\le n(n-1)$，$2\le k\le 13$，$1\le w_i\le 10^7$。

# Analysis

看一眼数据范围：$2\le k\le 13$，直接裸状压 DP。

我们设 $dp[i][j]$ 为当前走到下标为 $i$ 的节点，且经过颜色的状态为 $j$ 的**最短路径**：
$$dp[v][i \mid 2^o] = \min(dp[v][i \mid 2^o], dp[u][i] + G[u][v])$$

- 首先，枚举经过颜色的当前状态，取出其中一个的颜色，找到这个颜色的节点，并将其作为起点。

- 接下来，找当前没经过的颜色，找到所有为这个颜色的节点，对他们进行开辟。

- 最后，按照题意输出即可。

# Code

```cpp
#include <bits/stdc++.h>
using namespace std;
inline int min(int a,int b) {return (a) < (b) ? (a) : (b);}
const int maxn = 105;
const int INF = 0x3f3f3f3f;
int G[maxn][maxn];
int dp[maxn][8200];
int w[maxn];
int n, m, k;
vector<int> vec[14];
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
char buf[1 << 21], *p1 = buf, *p2 = buf;
inline int read()
{
    register char c = getchar();
    register int x = 0, f = 1;
    while (c < '0' || c > '9') {if (c == '-') f = -1;c = getchar();}
    while (c >= '0' && c <= '9') {x = (x << 3) + (x << 1) + c - 48;c = getchar();}
    return x * f;
}
int main()
{
    memset(G, 0x3f, sizeof G);
    memset(dp, 0x3f, sizeof dp);
    n=read(), m=read(), k=read();
    for(register int i = 1; i <= n; ++i)
    {
        w[i]=read(); 
        G[i][i] = 0;
        vec[w[i]].push_back(i);
    }
    while(m--)
    {
        int u, v, w; 
        u=read(), v=read(), w=read();
        G[u][v] = min(G[u][v], w);
    }
    for(register int i = 1; i <= n; ++i)
    {
        dp[i][1 << w[i]] = 0;
    }
    int S = (1 << k) - 1;
    for(register int i = 1; i <= S; ++i)
    {
        for(register int j = 0; j < k; ++j)
        {
            if((1 << j) & i)
            {
                int size1 = vec[j].size();
                for(register int l = 0; l < size1; ++l)
                {
                    int u = vec[j][l];
                    for(register int o = 0; o < k; ++o)
                    {
                        if((1 << o) & i) continue;
                        int size2 = vec[o].size();
                        for(register int p = 0; p < size2; ++p)
                        {
                            int v = vec[o][p];
                            if(G[u][v] != INF)
                            {
                                dp[v][i | (1 << o)] = min(dp[v][i | (1 << o)], dp[u][i] + G[u][v]);
                            }
                        }
                    }
                }
            }
        }
    }
    int ans = INF;
    for(register int i = 1; i <= n; ++i) 
    {
        ans = min(ans, dp[i][S]);
    }
    if(ans == INF) printf("Ushio!\n");
    else printf("%d\n", ans);
    return 0;
}
```

---

## 作者：Link_Cut_Y (赞：0)

### 题目大意

不想写了，[点这里吧](https://www.luogu.com.cn/problem/P4962)

### 题目分析

一看这数据范围，裸的状压啊！

设 $\mathrm{f_{i, j}}$ 为走到 $i$ 点，当前拿到光玉的状态为二进制数 $j$。

转移时枚举邻点 $t$， $\mathrm{f_{t, j | c_t} = \min\{f_{i, j} + w\}}$，$c_t$ 为 $t$ 点的光玉种类。

转移时可以加入剪枝，如：当前答案大于已知答案一定不优，可以剪掉。

我是手写栈转移的，可能和大家不大一样（当然和记搜也没啥区别）。

### 代码示例

```cpp
#include <algorithm>
#include <iostream>
#include <cstring>
#include <cstdio>
#include <stack>
#define rep(i, a, b) for (int i = (a); i <= (b); i ++ )
#define rop(i, a, b) for (int i = (a); i < (b); i ++ )
#define dep(i, a, b) for (int i = (a); i >= (b); i -- )
#define dop(i, a, b) for (int i = (a); i > (b); i -- )

using namespace std;

using LL = long long;
using PII = pair<int, int>;
using PLL = pair<LL, LL>;

const int N = 110, M = 100010;
int h[N], e[M], ne[M], w[M], idx;
int n, m, k, col[N], f[N][1 << 14];
PII stk[10000]; int top = 0;

void add(int a, int b, int c) {
	e[ ++ idx] = b, ne[idx] = h[a], h[a] = idx, w[idx] = c;
}

int main() {
	scanf("%d%d%d", &n, &m, &k);
	rep(i, 1, n) scanf("%d", &col[i]);
	while (m -- ) {
		int a, b, c;
		scanf("%d%d%d", &a ,&b, &c);
		add(a, b, c);
	}
	
	memset(f, 0x3f, sizeof f);
	for (int i = 1; i <= n; i ++ ) {
		f[i][1 << col[i]] = 0;
		stk[ ++ top] = {i, 1 << col[i]};
	}
	
	int res = 0x3f3f3f3f;
	while (top) {
		PII t = stk[top -- ];
		int u = t.first, s = t.second;
		if (f[u][s] >= res) continue;
		for (int i = h[u]; i; i = ne[i]) {
			int v = e[i];
			if ((s >> col[v]) & 1) continue;
			if (f[u][s] + w[i] >= f[v][s | (1 << col[v])]) continue;
			f[v][s | (1 << col[v])] = f[u][s] + w[i];
			if (f[v][s | (1 << col[v])] >= res) continue;
			if ((s | (1 << col[v])) == ((1 << k) - 1))
				res = min(res, f[v][s | (1 << col[v])]);
			else stk[ ++ top] = {v, s | (1 << col[v])};
		}
	}
	
	res == 0x3f3f3f3f ? puts("Ushio!") : printf("%d\n", res);
	
	return 0;
}
```

总之算是一道水紫吧。

---

## 作者：Eraine (赞：0)

## 状态压缩 DP

我的思路也是状态压缩 DP，不过与题解区大佬不同的是，部分大佬加上了最短路，其他则在 DFS 中跑 DP，而我的是存粹的递推 DP。

简化版题意：求一条长度为 $k-1$ 的路径，满足所有的权值全出现且仅出现一次在这条路径上。

首先，看到 $k\le 13$ ，想到状态压缩 DP。其次，看到 **所有的权值全出现且仅出现一次** ，可以设计状态压缩方程状态：

$f_{i_S}$ 为走到第 $i$ 个节点收集到的光玉集合为 $S$ 的最短路。

方程显而易见：

$f_{v_S}=\min (f_{u_{S-a_v}}+dis_{u,v})$ $(a_v\in S)$

初始化条件给一下：

$f_{i_{a_i}}=0$

$f_{i_{S}}=inf$

代码如下：

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
using namespace std;
const int N=100;
const int M=1e4;
const int K=1<<13;
const int inf=1e9;
int num[N+5],tot;
struct node{
	int end;
	int len;
	int nxt;
	void add(int u,int v,int w){
		end=v;
		len=w;
		nxt=num[u];
		num[u]=tot;
	}
}edge[M+5];//邻接表
int n,m,k,a[N+5];
int f[N+5][K+5];
int main(){
	scanf("%d%d%d",&n,&m,&k);
	for(int i=1;i<=n;i++)
		scanf("%d",&a[i]);
	for(int i=1;i<=m;i++){
		int u,v,w;
		scanf("%d%d%d",&u,&v,&w);
		edge[++tot].add(v,u,w);//输入一条边
		//想想为什么要建反向边（为什么会优化时间）
	}
	memset(f,0x3f,sizeof f);
	for(int i=1;i<=n;i++)
		f[i][1<<a[i]]=0;
	//方程初始化条件
	for(int S=1;S<1<<k;S++){//枚举子集状态
		for(int i=0;i<k;i++){//枚举点权
			if(!(S&1<<i))//S不包括a[i]的情况就跳过
				continue;
			for(int u=1;u<=n;u++){//枚举边的到达点
				if(a[u]!=i)
					continue;
				for(int j=num[u];j;j=edge[j].nxt){
					int v=edge[j].end,len=edge[j].len;
					f[u][S]=min(f[u][S],f[v][S^1<<i]+len);//方程
				}
			}
		}
	}
	int res=inf;
	for(int i=1;i<=n;i++)
		res=min(res,f[i][(1<<k)-1]);
	//输出答案
	if(res==inf)
		printf("Ushio!\n");
	else
		printf("%d\n",res);
	return 0;
}
```


---

## 作者：lmrttx (赞：0)

>一つ一つの光は小さくでも、たくさん集まればきっととても不思議な大きな力になるはず。

>虽然每一束光都很小，但如果聚集在一起，一定会成为不可思议的巨大力量。

本题成了我的信仰题。

来写篇状压+DFS的题解，我会尽量写好懂点的qwq。

题意：

有一张有向图，每个节点有一种颜色。要求的是走过 $k$ 个节点并收集 $k$ 种颜色的一条路径，使之最短。

分析：

发现 $k$ 很小，可以状压。

本题的一个点可以从很多的点转移得，所以求最短路时不考虑边的长度。这并不影响答案。

题目说**走过的点不可再走**，就是说走过的点无法修改，满足无后效性。

`dp[i][j]`表示节点 $i$ 的状态为 $j$ 时的路径长度。

然后就可以通过转移节点和状态进行搜索。

代码：

具体见代码吧，我觉得从代码入手更好理解。

代码加了防抄袭！

```cpp
#inludce<bits/stdc++.h>
usign namespace std;
#defnie inf 2147483647
#define maxm (1<<14)-1
int n,m,k;
int ans,color[110],a[110][110],dp[110][maxm];
 
void dfs(int now,int len,int s,int sum){
	//节点 now,已经取的颜色种数len,状态s,路径长度sum 
	if(s&(1<<color[now])||ans<=sum||dp[now][s]<=sum)
	//边界 
	return;
	if(len==k){ans=sum;return;}
	//搜索到就退出 
	dp[now][s]=sum;
	//dp[now][s]的路径长度（答案）为当前值 
	for(register int i=1;i<=n;i++){
		if(a[now][i]!=inf) 
		//节点没搜过就去搜 
		dfs(i,len+1,s|(1<<color[now]),sum+a[now][i]);
		//颜色种数+1，状态改变，路径长度增加 
	}
}


inline int read(){//快读 
	int ss=0,w=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-')w=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9'){
		ss=(ss<<3)+(ss<<1)+(ch^48);
		ch=getchar();
	}
	return ss*w;
}
void init(){
	ans=inf;
	n=read();m=read();k=read();
	for(register int i=1;i<=n;i++) color[i]=read();
	for(register int i=1;i<=n;i++)
	for(register int j=1;j<=n;j++) a[i][j]=inf;
	for(register int i=1,u,v,ww;i<=m;i++){
		u=read();v=read();ww=read();
		a[u][v]=ww; 
	}
	for(register int i=1;i<=n;i++)
	for(register int j=0;j<(1<<k)-1;j++) dp[i][j]=inf;
	for(register int i=1;i<=n;i++) dp[i][1<<color[i]]=0;
}//初始化 
void out(){
	if(ans==inf) puts("Ushio!");
	else printf("%d",ans);
}//输出
int main(){
	init();
	for(register int i=1;i<=n;i++) dfs(i,1,0,0);
	//从节点i，颜色数为1，状态0，长度0开始搜索 
	out();
	return 0;
} 
```

~~好像并不难呀！就是状态转移的二进制烦人了点...~~

希望本文能对读者有帮助，谢谢阅读qwq。




---

## 作者：nofind (赞：0)

题意:https://www.luogu.org/problem/P4962

不知道为什么其他题解写的那么麻烦

发现k这么小,显然是状压,很容易想到状态:$f[x][s]$表示当前在x,捡的物品的集合为s的最短路,注意我在实际实现时是倒推的

转移就枚举起点,dfs过程中当前点出边记搜即可

这时可能有人说怎么处理不经过相同的点呢?我们发现题中说经过k个点,捡完k个物品,我们转移时只要不走已经得到的物品就必定不会经过走过的点

复杂度:$O(n2^k$*玄学)

code:
```
#include<bits/stdc++.h>
using namespace std;
const int maxn=110;
const int maxm=10010;
const int maxk=15;
const int inf=1e9;
int n,m,K,cnt,ans=inf;
int head[maxn],a[maxn];
int f[maxn][1<<maxk];
bool vis[maxn][1<<maxk];
struct edge{int to,nxt,dis;}e[maxm];
inline void add(int u,int v,int w){e[++cnt].nxt=head[u];head[u]=cnt;e[cnt].to=v;e[cnt].dis=w;}
int dfs(int x,int s)
{
	if(s==(1<<K)-1)return 0;
	if(vis[x][s])return f[x][s];
	vis[x][s]=1;
	int res=inf;
	for(int i=head[x];i;i=e[i].nxt)
	{
		int y=e[i].to;
		if(s&(1<<a[y]))continue;
		res=min(res,dfs(y,s|(1<<a[y]))+e[i].dis);
	}
	return f[x][s]=res;
}
int main()
{
	scanf("%d%d%d",&n,&m,&K);
	for(int i=1;i<=n;i++)scanf("%d",&a[i]);
	for(int i=1;i<=m;i++)
	{
		int u,v,w;scanf("%d%d%d",&u,&v,&w);
		add(u,v,w);
	}
	for(int i=1;i<=n;i++)ans=min(ans,dfs(i,1<<a[i]));
	if(ans==inf)puts("Ushio!");
	else printf("%d",ans);
	return 0;
}
```


---

## 作者：牧濑蓝莉栖 (赞：0)

官方题解说的是递推的做法，在这里介绍一下记搜的做法。

按题意我们可以知道最多搜到第k个点就回溯，设dfs(i,j,k)表示当前搜到第i个点,状态为j(状压),路径权值为k。

转移相当简单,对该节点的每条边进行拓展,设to为尾部节点,有

      **!(j&(1<<color[to]))**
      
成立

注意一下一开始停留的地方颜色是有的,每个点搜一下就好了。
```cpp
#include"cstdio"
#include"iostream"
#include"cstring"

using namespace std;

const int N=1005;
const int M=1<<15;

int n,m,k;
int head[N],tot;
int f[N][N];
int p[N];

struct edge {
	int v;
	int nxt;
	int w;
} e[N*N];//邻接表
int ans=2147483647;
int l,r;
int tmp=2147483646;

bool check(int j) {//判断j是否为目标状态,但是其实可以通过预处理2的方幂做到O(1)判断
	for(int i=0; i<=k-1; i++) {
		if(!(j&(1<<i)))return false;
	}
	return true;
}

void add(int u,int v,int w) {
	++tot;
	e[tot].v=v;
	e[tot].w=w;
	e[tot].nxt=head[u];
	head[u]=tot;
}
	int t=0;

void dfs(int i,int j,int now,int num) {//num表示已搜点数,因为在拓展过程中判断,所以可省略
	t++;
	if(t>4e7)return;//要加时间戳,不然#8卡不过去,当然可能是我太菜
	if(f[i][j]<now)return;//一种记忆化写法,动态更新
	if(num>k)return ;
	if(now>tmp)return;
	f[i][j]=now;
	if(check(j)) {
		if(now<tmp)
		{
			tmp=now;
			l=i;
		}
		return;
	}
	for(int u=head[i]; u; u=e[u].nxt) {
		int to=e[u].v;
		if(j&(1<<p[to]))continue;
		dfs(to,j|(1<<(p[to])),now+e[u].w,num+1);
	}
}

int main() {
	freopen("a.in","r",stdin);
	freopen("a.out","w",stdout);
	
	int u,v,w;
	scanf("%d%d%d",&n,&m,&k);
	for(int i=1; i<=n; i++) {
		scanf("%d",&p[i]);
	}
	for(int i=1; i<=m; i++) {
		scanf("%d%d%d",&u,&v,&w);
		add(u,v,w);
	}
	for(int i=1; i<=n; i++) {
		memset(f,127,sizeof(f));//赋大值
		dfs(i,1<<(p[i]),0,1);
		tmp=min(ans,tmp);
	}
	if(tmp==2147483646) {//一个细节,考虑一下
		printf("Ushio!");
	} else cout<<tmp;
	return 0;
}

```


---


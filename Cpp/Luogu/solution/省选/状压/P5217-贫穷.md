# 贫穷

## 题目背景

LHF 最大的特点就是贫穷。  
LHF 最大的爱好就是看购物节目。

这天他又在看购物节目了。  
他在节目里看到一款新型文本编辑器，~~除了价钱以外~~非常适合他这样的穷人使用。

因为……它能够计算打印成本！  
（这里的打印成本是与出现过的字母的种类数相关的）

他十分心动，要求你实现这个功能。

## 题目描述

这个文本编辑器支持以下操作：
 - $\texttt{I x c}$，在第 $x$ 个字母后面插入一个 $c$。
 - $\texttt{D x}$，删除第 $x$ 个字母。
 - $\texttt{R x y}$，反转当前文本中的区间 $[x,y]$。
 - $\texttt{P x}$，输出初始文本中第 $x$ 个字母在当前文本中的位置。特别地，若不存在，输出 $0$。
 - $\texttt{T x}$，输出当前文本中第 $x$ 个字母。
 - $\texttt{Q x y}$，输出当前文本中区间 $[x,y]$ 内出现过的字母的种类数。

## 说明/提示

**数据范围：**

对于 $20\%$ 的数据，$n \le 100$。  
对于 $50\%$ 的数据，$n \le 10000$。  
对于 $100\%$ 的数据，$1 \le n,m \le 10^5$，文本涉及的字母仅包含小写字母。

**样例解释：**

 1. 文本不变，但初始文本中第 $2$ 个字母与第 $4$ 个字母的位置交换。
 2. 当前第 $2$ 个字母是初始文本的第 $4$ 个字母。
 3. 文本变为 $\texttt{imiwakawaii}$。
 4. 文本变为 $\texttt{wimiwakawaii}$。
 5. 这个字母为 $\texttt{m}$。 
 6. 这段文本为 $\texttt{miwakawa}$，包含的字符种类的集合为 $\{\texttt{a},\texttt{i},\texttt{k},\texttt{m},\texttt{w}\}$，元素个数为 $5$。

## 样例 #1

### 输入

```
12 6
kimiwakawaii
R 2 4
P 4
D 1
I 0 w
T 3
Q 3 10```

### 输出

```
2
m
5
```

# 题解

## 作者：George1123 (赞：10)

[$\Huge \texttt{My Cnblogs}$](https://www.cnblogs.com/Wendigo/p/12899654.html)

---

> [洛谷P5217 贫穷](https://www.luogu.com.cn/problem/P5217)

> 给定长度为 $n$ 的初始文本 $s$，有 $m$ 个如下操作：
> 1. $\texttt{I x c}$，在第 $x$ 个字母后面插入一个 $c$。
> 2. $\texttt{D x}$，删除第 $x$ 个字母。
> 3. $\texttt{R x y}$，反转当前文本中的区间 $[x,y]$。
> 4. $\texttt{P x}$，输出初始文本中第 $x$ 个字母在当前文本中的位置。特别地，若不存在，输出 $0$。
> 5. $\texttt{T x}$，输出当前文本中第 $x$ 个字母。
> 6. $\texttt{Q x y}$，输出当前文本中区间 $[x,y]$ 内出现过的字母的种类数。

> 数据范围：$1\le n,m\le 10^5$。

---
初学平衡树的蒟蒻太蒟蒻了，这题做了 $5$ 个小时。

蒟蒻是用 $\tt fhqTreap$ 做的，虽然对付这题 $\tt Splay$ 更自然，但是 $\tt fhqTreap$ 代码短。

---
- **维护节点信息：**

```cpp
const int N=1e5,T=2e5;
// N为初始文本长度，T为平衡树节点最大个数
int o[N+7];
// 记录每个初始文本字母对应的平衡树节点
int sz[T+7],fa[T+7],ls[T+7],rs[T+7],v[T+7],sm[T+7],p[T+7],mk[T+7];
// sz：节点的子树大小
// fa：节点的父亲节点，用于4操作中求rank
// ls/rs：左右儿子节点
// v：该节点对应的字母（-'a'）
// sm：子树的字母总集状压（0<=sm[x]<(1<<26)）
// p：fhqTreap精华随机数权值（用于维护堆）
// mk：翻转标记，用于解决3操作
```
---
- **$\tt fhqTreap$ 基本操作：**

```cpp
void up(int x){
	if(ls[x]) fa[ls[x]]=x;
	if(rs[x]) fa[rs[x]]=x;
	sz[x]=sz[ls[x]]+sz[rs[x]]+1;
	sm[x]=sm[ls[x]]|sm[rs[x]]|1<<v[x];
}
void down(int x){if(mk[x]) swap(ls[x],rs[x]),mk[ls[x]]^=1,mk[rs[x]]^=1,mk[x]=0;} 
int wen(int x,int y=rand()){return v[++cnt]=x,p[cnt]=y,up(cnt),cnt;}
int merge(int x,int y){
	if(!x||!y) return x^y;
	if(p[x]<p[y]) return down(x),rs[x]=merge(rs[x],y),up(x),x;
	return down(y),ls[y]=merge(x,ls[y]),up(y),y;
}
void split(int u,int k,int&x,int&y){
	if(!u) return void(x=y=0);
	down(u); //这东西一定要写在这里，要不然不知道ls[u]是不是真的ls[u]
	if(k<=sz[ls[u]]) y=u,split(ls[y],k,x,ls[y]),fa[x]=0;
	else x=u,split(rs[x],k-sz[ls[u]]-1,rs[x],y),fa[y]=0;
	up(u);
}
```

---

- **题目中的操作：**

**$\color{#44a897}{\texttt{[0]}}$ 插入文本：** 野蛮 $\tt merge$。

```cpp
for(int i=1;i<=n;i++) rt=merge(rt,o[i]=wen(s[i]-'a'));
```

**$\color{#44a897}{\texttt{[1]}}$ 插入字符：** 套路 $\tt split$，套路 $\tt merge$。

```cpp
scanf("%d %s",&a,&c[1]);
split(rt,a,L,R);
rt=merge(merge(L,wen(c[1]-'a')),R);
```

**$\color{#44a897}{\texttt{[2]}}$ 删除字符：** 先把节点分裂出来，然后把两边合并。为了操作 $4$ 可以看出一个点是否被删，在被删节点权值上做标记。

```cpp
scanf("%d",&a);
split(rt,a,L,R),split(L,a-1,L,M);
v[M]=-1,rt=merge(L,R);
```

**$\color{#44a897}{\texttt{[3]}}$ 翻转区间：** 先把区间分裂出来，然后打翻转标记，最后不忘把树合回去。

```cpp
scanf("%d%d",&a,&b);
split(rt,b,L,R),split(L,a-1,L,M);
mk[M]^=1,rt=merge(merge(L,M),R);
```

**$\color{#44a897}{\texttt{[4]}}$ 查询排名：** 如果节点权值有删除标记输出 $0$。否则先把节点到根的路径**从上到下**下放标记，然后**从下向上**求该节点前面的节点数。

```cpp
void updown(int x){if(fa[x]) updown(fa[x]);down(x);}
int frank(int x){
	updown(x);
	int res=sz[ls[x]]+1;
	for(int i=x;fa[i];i=fa[i])if(rs[fa[i]]==i) res+=sz[ls[fa[i]]]+1;
	return res;
}

scanf("%d",&a);
if(v[o[a]]==-1) puts("0");
else printf("%d\n",frank(o[a]));
```

**$\color{#44a897}{\texttt{[5]}}$ 输出位置字母：** 相当于求个 $\tt kth$，可以套路 $\tt split$ 求。

```cpp
scanf("%d",&a);
split(rt,a,L,R),split(L,a-1,L,M);
printf("%c\n",'a'+v[M]);
rt=merge(merge(L,M),R);
```

**$\color{#44a897}{\texttt{[6]}}$ 区间字母种类：** 先把区间分裂出来，答案即分裂出的根节点的子树字母集状压中的 $1$ 的个数。

```cpp
scanf("%d%d",&a,&b);
split(rt,b,L,R),split(L,a-1,L,M);
printf("%d\n",bit(sm[M])),rt=merge(merge(L,M),R);
```
---
- **调试与解释**

**$\color{#efca55}{\texttt{[1]}}$ 输出当前字符串：** 求平衡树的中序遍历，写个 $\tt Dfs$。

```cpp
void Print(int x){
	down(x);
	if(ls[x]) Print(ls[x]);
//	printf("[%d<-%d->%d] (sz%d,v[%c],p%d,fa%d)\n",ls[x],x,rs[x],sz[x],v[x]+'a',p[x],fa[x]);
	printf("%c",v[x]+'a');
	if(rs[x]) Print(rs[x]);
}
```

**$\color{#efca55}{\texttt{[2]}}$ 为什么有些时候写了 $\tt Print$ 就对了，注释掉就挂了：** $\tt Print$ 函数帮你把整棵树的翻转标记下放了，如果出现这种情况说明你的操作过程中标记下放不完全。如果要验证你的代码除了标记下放都是正确的，可以把 $\tt Print$ 中的输出去掉，每次操作完都 $\tt Print$，然后交一发，如果 $\tt ac$ 两个点，$\tt tle$ 八个点，说明你的代码除了标记下放都是正确的。

---
好了结束了，蒟蒻又写了一篇无意义题解，放代码吧：

```cpp
#include <bits/stdc++.h>
using namespace std;

//Start
typedef long long ll;
typedef double db;
#define mp(a,b) make_pair(a,b)
#define x(a) a.first
#define y(a) a.second
#define b(a) a.begin()
#define e(a) a.end()
#define sz(a) int((a).size())
#define pb(a) push_back(a)
const int inf=0x3f3f3f3f;
const ll INF=0x3f3f3f3f3f3f3f3f;

//Data
const int N=1e5,T=2e5;
int n,m,o[N+7];
char s[N+7],c[3];
int bit(int x){return x?bit(x-(x&-x))+1:0;}

//Fhqtreap
int rt,cnt,sz[T+7],fa[T+7],ls[T+7],rs[T+7],v[T+7],sm[T+7],p[T+7],mk[T+7];
void up(int x){
	if(ls[x]) fa[ls[x]]=x;
	if(rs[x]) fa[rs[x]]=x;
	sz[x]=sz[ls[x]]+sz[rs[x]]+1;
	sm[x]=sm[ls[x]]|sm[rs[x]]|1<<v[x];
}
void down(int x){if(mk[x]) swap(ls[x],rs[x]),mk[ls[x]]^=1,mk[rs[x]]^=1,mk[x]=0;}
int wen(int x,int y=rand()){return v[++cnt]=x,p[cnt]=y,up(cnt),cnt;}
int merge(int x,int y){
	if(!x||!y) return x^y;
	if(p[x]<p[y]) return down(x),rs[x]=merge(rs[x],y),up(x),x;
	return down(y),ls[y]=merge(x,ls[y]),up(y),y;
}
void split(int u,int k,int&x,int&y){
	if(!u) return void(x=y=0);
	down(u);
	if(k<=sz[ls[u]]) y=u,split(ls[y],k,x,ls[y]),fa[x]=0;
	else x=u,split(rs[x],k-sz[ls[u]]-1,rs[x],y),fa[y]=0;
	up(u);
}
void updown(int x){if(fa[x]) updown(fa[x]);down(x);}
int frank(int x){
	updown(x);
	int res=sz[ls[x]]+1;
	for(int i=x;fa[i];i=fa[i])if(rs[fa[i]]==i) res+=sz[ls[fa[i]]]+1;
	return res;
}
void Print(int x){
	down(x);
	if(ls[x]) Print(ls[x]);
//	printf("[%d<-%d->%d] (sz%d,v[%c],p%d,fa%d)\n",ls[x],x,rs[x],sz[x],v[x]+'a',p[x],fa[x]);
	printf("%c",v[x]+'a');
	if(rs[x]) Print(rs[x]);
}

//Main
int main(){
	scanf("%d%d\n%s",&n,&m,&s[1]);
	for(int i=1;i<=n;i++) rt=merge(rt,o[i]=wen(s[i]-'a'));
//	puts("now---");
//	Print(rt); puts("");
//	puts("++++++");
	for(int i=1,a,b,L,M,R;i<=m;i++){
		scanf("\n%s ",&c[1]);
		if(c[1]=='I'){
			scanf("%d %s",&a,&c[1]);
			split(rt,a,L,R);
			rt=merge(merge(L,wen(c[1]-'a')),R);
		} else if(c[1]=='D'){
			scanf("%d",&a);
			split(rt,a,L,R),split(L,a-1,L,M);
			v[M]=-1,rt=merge(L,R);
		} else if(c[1]=='R'){
			scanf("%d%d",&a,&b);
			split(rt,b,L,R),split(L,a-1,L,M);
			mk[M]^=1,rt=merge(merge(L,M),R);
		} else if(c[1]=='P'){
			scanf("%d",&a);
			if(v[o[a]]==-1) puts("0");
			else printf("%d\n",frank(o[a]));
		} else if(c[1]=='T'){
			scanf("%d",&a);
			split(rt,a,L,R),split(L,a-1,L,M);
			printf("%c\n",'a'+v[M]);
			rt=merge(merge(L,M),R);
		} else if(c[1]=='Q'){
			scanf("%d%d",&a,&b);
			split(rt,b,L,R),split(L,a-1,L,M);
			printf("%d\n",bit(sm[M])),rt=merge(merge(L,M),R);
		}
//		puts("now---");
//		Print(rt); 
//		puts("");
//		puts("++++++");
	}
	return 0;
}
```
---

**祝大家学习愉快！**


---

## 作者：xuyiyang (赞：5)

## Description

维护一个文本编辑器，这个文本编辑器支持以下操作：
 - $\texttt{I x c}$，在第 $x$ 个字母后面插入一个 $c$。
 - $\texttt{D x}$，删除第 $x$ 个字母。
 - $\texttt{R x y}$，反转当前文本中的区间 $[x,y]$。
 - $\texttt{P x}$，输出初始文本中第 $x$ 个字母在当前文本中的位置。特别地，若不存在，输出 $0$。
 - $\texttt{T x}$，输出当前文本中第 $x$ 个字母。
 - $\texttt{Q x y}$，输出当前文本中区间 $[x,y]$ 内出现过的字母的种类数。

对于 $100\%$ 的数据，$1 \le n,m \le 10^5$，文本涉及的字母仅包含小写字母。

## Solution

看就是一道平衡树，翻了下题解发现没几个写 Splay 的，来发个。
- 对于 $\texttt{I x c}$ 操作，就是 Splay 的基础插入。
- 对于 $\texttt{D x}$ 操作，就是 Splay 的删除
- 对于 $\texttt{R x y}$ 操作，就是文艺平衡树的操作，将 $x - 1$ 转到根，$y+1$ 挂到 $x$ 的右子树下面，$y+1$ 的左子树就是 $x \sim y$ 这段区间，打上标记即可。
- 对于 $\texttt{P x}$ 操作，将原序列中的数在 Splay 中的结点编号存起来，记为 $pos_x$, 询问的时候将根到 $pos_x$ 的结点的标记下传，然后把 $pos_x$ 转到根节点，它左子树的结点个数加上自己就是答案。
- 对于 $\texttt{T x}$ 操作，把 $x-1$ 转到根，$x+1$ 挂到 $x-1$ 的下面，$x+1$ 的左子树就是 $x$。
- 对于 $\texttt{Q x y}$ 操作，由于只有 $26$ 个字母，所以可以状态压缩维护，其余与 $\texttt{R x y}$ 步骤一样。

还有一些实现细节，由于直接 $1 \sim n$ 存会有一些边界问题，所以可以在前后加两个哨兵，注意这样前面的所有操作的 $x,y$ 都要加一。对于反转操作来说，使用在下传标记的时候反转可能会出错，具体实现可以看代码。

## Code
```cpp
const int N = 100010;

int n, m;
char str[N];

struct Node
{
	int s[2], v, p;
	int cnt, Size, rev; //cnt表示状态压缩
}tr[N * 2]; //注意还有 100000 次插入
int root, idx;
int pos[N];

void pushup(int u)
{
	tr[u].Size = tr[tr[u].s[0]].Size + tr[tr[u].s[1]].Size + 1;
	tr[u].cnt = tr[tr[u].s[0]].cnt | tr[tr[u].s[1]].cnt | (~tr[u].v ? (1 << tr[u].v) : 0);
}

void push_rev(int u)
{
	swap(tr[u].s[0], tr[u].s[1]);
	tr[u].rev ^= 1;
}

void pushdown(int u) //打标记
{
	if (tr[u].rev)
	{
		push_rev(tr[u].s[0]), push_rev(tr[u].s[1]);
		tr[u].rev = 0;
	}
}

void rotate(int x)
{
	int y = tr[x].p, z = tr[y].p;
	int k = tr[y].s[1] == x;
	tr[z].s[tr[z].s[1] == y] = x, tr[x].p = z;
	tr[y].s[k] = tr[x].s[k ^ 1], tr[tr[x].s[k ^ 1]].p = y;
	tr[x].s[k ^ 1] = y, tr[y].p = x;
	pushup(y), pushup(x);
}

void splay(int x, int k)
{
	while (tr[x].p != k)
	{
		int y = tr[x].p, z = tr[y].p;
		if (z != k)
			(tr[y].s[1] == x) ^ (tr[z].s[1] == y) ? rotate(x) : rotate(y);
		rotate(x);
	}
	if (!k) root = x;
}

int get_k(int k)
{
	int u = root;
	while (u)
	{
		pushdown(u);
		if (k <= tr[tr[u].s[0]].Size) u = tr[u].s[0];
		else if (k == tr[tr[u].s[0]].Size + 1) return u;
		else k -= tr[tr[u].s[0]].Size + 1, u = tr[u].s[1];
	}
	return -1;
}

int get(int x, int p)
{
	idx ++ ;
	tr[idx].v = x, tr[idx].p = p;
	tr[idx].cnt = 1 << x, tr[idx].Size = 1;
	return idx;
}

int build(int t, int l, int r) //建树
{
	if (l > r) return 0;
	int mid = l + r >> 1;
	int x = ++ idx;
	if (mid > 0 && mid < n + 1) pos[mid] = x;
	if (mid > 0 && mid < n + 1) tr[x].v = str[mid] - 'a', tr[x].cnt = (1 << tr[x].v);
	else tr[x].v = -1, tr[x].cnt = 0; //对于哨兵，没有贡献
	tr[x].p = t;
	tr[x].s[0] = build(x, l, mid - 1); tr[x].s[1] = build(x, mid + 1, r);
	pushup(x); return x;
}

void insert(int x, int v)
{
	int y = get_k(x + 2); x = get_k(x + 1); //注意由于哨兵的存在所有端点都得加 1，下同
	splay(x, 0), splay(y, x);
	tr[y].s[0] = get(v, y);
	pushup(y), pushup(x); //不要忘记修改信息
}

void remove(int x)
{
	int y = get_k(x + 2); x = get_k(x);
	splay(x, 0), splay(y, x);
	tr[tr[y].s[0]].v = -1; tr[y].s[0] = 0;
	pushup(y), pushup(x);
}

void reverse(int l, int r)
{
	int y = get_k(r + 2), x = get_k(l);
	splay(x, 0), splay(y, x);
	push_rev(tr[y].s[0]);
}

void update(int x) //将 x 到根的结点下传标记，注意要用栈来实现
{
	if (x != root) update(tr[x].p);
	pushdown(x);
}

int count(int x)
{
	int ret = 0;
	while (x) { ret ++ ; x &= x - 1; }
	return ret;
}

void write(int u) //输出序列，调试用
{
	pushdown(u);
	if (tr[u].s[0]) write(tr[u].s[0]);
	if (tr[u].v != -1) printf("%c ", tr[u].v + 'a');
	if (tr[u].s[1]) write(tr[u].s[1]);
}

int main()
{
	scanf("%d%d\n", &n, &m);
	scanf("%s", str + 1);
	root = build(0, 0, n + 1);
	while (m -- )
	{
		char op[2];
		scanf("%s", op);
		
		if (*op == 'I')
		{
			int x; char y;
			scanf("%d %c", &x, &y);
			insert(x, y - 'a');
		}
		else if (*op == 'D')
		{
			int x;
			scanf("%d", &x);
			remove(x);
		}
		else if (*op == 'R')
		{
			int l, r;
			scanf("%d%d", &l, &r);
			reverse(l, r);
		}
		else if (*op == 'T')
		{
			int x; scanf("%d", &x);
			int y = get_k(x + 2); x = get_k(x);
			splay(x, 0), splay(y, x);
			printf("%c\n", (char)(tr[tr[y].s[0]].v + 'a'));
		}
		else if (*op == 'Q')
		{
			int l, r;
			scanf("%d%d", &l, &r);
			int y = get_k(r + 2), x = get_k(l);
			splay(x, 0), splay(y, x);
			printf("%d\n", count(tr[tr[y].s[0]].cnt));
		}
		else if (*op == 'P')
		{
			int x;
			scanf("%d", &x);
			if (tr[pos[x]].v == -1) puts("0");
			else 
			{
				update(pos[x]);
				splay(pos[x], 0);
				printf("%d\n", tr[tr[root].s[0]].Size); //由于加了 0 号点这个哨兵，所以要减 1，与加上 x 刚好抵消。
			}
		}
	}
	return 0;
}
```

---

## 作者：Weng_Weijie (赞：5)

发现这些操作都可以用平衡树维护，我用的是 fhq treap

对于种类数可以状压

对于求排名，fhq treap 需要记录每个节点的父亲，自下往上求排名，而 splay 就比较方便了

翻转就是基础操作了

```cpp
#include <iostream>
#include <cstdlib>

const int N = 200005;
int n, m, idx, root;
std::string str;
int lc[N], rc[N], size[N], f[N], pri[N], sum[N], val[N];
bool rev[N], removed[N];
int newnode(char ch) {
	int now = ++idx;
	lc[now] = rc[now] = 0, size[now] = 1, pri[now] = std::rand(), f[now] = 0;
	val[now] = ch - 'a', sum[now] = 1 << val[now];
	return now;
}
void pushup(int x) {
	if (lc[x]) f[lc[x]] = x;
	if (rc[x]) f[rc[x]] = x;
	size[x] = 1 + size[lc[x]] + size[rc[x]];
	sum[x] = 1 << val[x] | sum[lc[x]] | sum[rc[x]];
}
void setrev(int x) {
	rev[x] ^= 1, std::swap(lc[x], rc[x]);
}
void pushdown(int x) {
	if (rev[x]) {
		if (lc[x]) setrev(lc[x]);
		if (rc[x]) setrev(rc[x]);
		rev[x] = 0;
	}
}
void split(int now, int k, int &x, int &y) {
	if (!now) x = y = 0;
	else {
		pushdown(now);
		if (size[lc[now]] >= k) y = now, split(lc[y], k, x, lc[y]), f[x] = 0;
		else x = now, split(rc[x], k - size[lc[now]] - 1, rc[x], y), f[y] = 0;
		pushup(now);
	}
}
int merge(int x, int y) {
	if (!x || !y) return x | y;
	if (pri[x] < pri[y]) {
		pushdown(x), rc[x] = merge(rc[x], y), pushup(x);
		return x;
	} else {
		pushdown(y); lc[y] = merge(x, lc[y]), pushup(y);
		return y;
	}
}
void clear(int x) {
	if (f[x]) clear(f[x]);
	pushdown(x);
}
int getrank(int x) {
	clear(x);
	int ans = size[lc[x]] + 1;
	while (f[x]) {
		if (rc[f[x]] == x)
			ans += size[lc[f[x]]] + 1;
		x = f[x];
	}
	return ans;
}
char kth(int k) {
	int a, b;
	split(root, k, root, b);
	split(root, k - 1, a, root);
	char ans = val[root] + 'a';
	root = merge(a, merge(root, b));
	return ans;
}
int query(int l, int r) {
	int a, b;
	split(root, r, root, b);
	split(root, l - 1, a, root);
	int ans = __builtin_popcount(sum[root]);
	root = merge(a, merge(root, b));
	return ans;
}
void reverse(int l, int r) {
	int a, b;
	split(root, r, root, b);
	split(root, l - 1, a, root);
	setrev(root);
	root = merge(a, merge(root, b));
}
void insert(int pos, char ch) {
	int a, b;
	split(root, pos, a, b);
	root = merge(a, merge(newnode(ch), b));
}
void remove(int pos) {
	int a, b;
	split(root, pos, root, b);
	split(root, pos - 1, a, root);
	removed[root] = 1;
	root = merge(a, b);
}
int main() {
	std::ios::sync_with_stdio(0), std::cin.tie(0);
	std::cin >> n >> m >> str;
	for (int i = 0; i < n; ++i)
		root = merge(root, newnode(str[i]));
	for (int i = 0; i < m; ++i) {
		int x, y; char ch, opt;
		std::cin >> opt;
		if (opt == 'I') std::cin >> x >> ch, insert(x, ch);
		else if (opt == 'D') std::cin >> x, remove(x);
		else if (opt == 'R') std::cin >> x >> y, reverse(x, y);
		else if (opt == 'P') {
			std::cin >> x;
			if (removed[x]) std::cout << 0 << '\n';
			else std::cout << getrank(x) << '\n';
		}
		else if (opt == 'T') std::cin >> x, std::cout << kth(x) << '\n';
		else if (opt == 'Q') std::cin >> x >> y, std::cout << query(x, y) << '\n';
	}
	return 0;
}

```

---

## 作者：MeowScore (赞：4)

本题解使用 fhq_treap。

平衡树序列操作板子题，加上一点状压技巧。

[传送门qwq](https://www.luogu.com.cn/problem/P5217)

首先应该了解平衡树序列操作的基本分裂方法，板子题应该是文艺平衡树。这里的分裂方法可以理解为“按大小分裂”。还有很好的一点就是如果按照 $k$ 分裂，其实分裂下来的是序列中序的前 $k$ 个元素。

注意到字母最多只有 $26$ 种，考虑转成数字后状压。注意合并子树信息的时候是“或”的关系。如果一个节点为根的子树内有元素 $i$，那么这个节点的状压信息的二进制下的第 $i$ 位就是 $1$。

废话不多说，直接看操作。

（以下内容我是把字母转成数字了的！请注意。）

先把基本的函数拿出来吧，方便理解。

### 平衡树里维护的信息：

```
int v[N];//权值
int c[N];//修正值
int ls[N];//左儿子
int rs[N];//右儿子
int fa[N];//父亲
int sz[N];//子树大小
int tag[N];//翻转标记
long long ans[N];//这个节点为根的子树内状压的结果
```

### split：

参数说明：$r$ 是当前处理到的根，$k$ 是要分裂这棵树的中序的前多少个数。$x$ 是分裂完左段的根节点，$y$ 是分裂完右段的根节点。$fx$ 是分裂后 $x$ 的父亲，$fy$ 是分裂完 $y$ 的父亲。

```
void split(int r,int k,int &x,int &y,int fx,int fy){
	if(!r){
		x=0;
		y=0;
		return;
	}
	if(tag[r])
		push_down(r);
	if(sz[ls[r]]>=k){
		y=r;
		split(ls[r],k,x,ls[r],fx,r);
	}
	else{
		x=r;
		split(rs[r],k-sz[ls[r]]-1,rs[r],y,r,fy);
	}
	upd(r);
	if(x)
		fa[x]=fx;
	if(y)
		fa[y]=fy;
}
```

### merge：

```
int merge(int r1,int r2){
	if(!r1||!r2)
		return r1+r2;
	if(c[r1]<=c[r2]){
		if(tag[r1])
			push_down(r1);
		rs[r1]=merge(rs[r1],r2);
		fa[rs[r1]]=r1;
		upd(r1);
		return r1;
	}
	else{
		if(tag[r2])
			push_down(r2);
		ls[r2]=merge(r1,ls[r2]);
		fa[ls[r2]]=r2;
		upd(r2);
		return r2;
	}
}
```

### 建立新点：

```
int newnode(int a){
	cnt++;
	v[cnt]=a;
	c[cnt]=rand();
	sz[cnt]=1;
	ans[cnt]=(1<<a);
	return cnt;
}
```

## 1.插入操作

在 $p$ 位置后面插入数字 $a$。

```
root=merge(root,newnode(a));
```

## 2.删除操作

删除序列中的第 $p$ 个数字。

其实就是把通过分裂把 $p$ 位置的元素单独放到一棵树上，合并的时候忽略这棵树即可。然后把扔掉的元素权值改为 $-1$，这么做以后会用。

```
split(root,p-1,x,z,0,0);
split(z,1,y,z,0,0);
v[y]=-1;
root=merge(x,z);
```

## 3.反转操作

文艺平衡树的基本操作。

```
split(root,l-1,x,z,0,0);
split(z,r-l+1,y,z,0,0);
tag[y]^=1;
swap(ls[y],rs[y]);
root=merge(x,merge(y,z));
```

## 4.查询位置

查询原序列第 $p$ 各元素现在在序列里的位置。

其实就是查询 $p$ 号点的中序。

对于无解，即 $p$ 号点的权值已经被改为 $-1$ 了，直接判掉。（这就是为什么操作二要这么操作）

对于有解，写一个查询中序的函数，注意查之前要把根节点到你查的位置这条链上的懒标记全都下传，而且是自上而下的。

```
void work(int r){//下传标记
	if(fa[r])
		work(fa[r]);
	if(tag[r])
		push_down(r);
}
int find(int r){//查询中序
	work(r);
	int res=sz[ls[r]]+1;
	while(fa[r]){
		if(rs[fa[r]]==r)
			res+=sz[ls[fa[r]]]+1;
		r=fa[r];
	}
	return res;
}
```

## 5.查询权值

查询 $p$ 位置的权值。

通过分裂使得 $p$ 位置的元素单独位于一棵树上，这样我们就得到了它的编号，输出权值即可。

```
split(root,p-1,x,z,0,0);
split(z,1,y,z,0,0);
cout<<char(v[y]+96);
printf("\n");
root=merge(x,merge(y,z));
```


## 6.查询元素种类

查询区间 $[x,y]$ 内的元素个数。

把这段区间分裂下来，查询这棵树的状压信息即可。

然后算一下这个数字的二进制里有多少个 $1$，基本常识了。

```
split(root,r,x,z,0,0);
split(x,l-1,x,y,0,0);
printf("%d\n",calc(ans[y]));
root=merge(x,merge(y,z));
```
### calc 以及 lowbit 函数：

```
long long lowbit(long long k){
	return k&(-k);
}
int calc(long long k){
	int res=0;
	while(k){
		res++;
		k-=lowbit(k);
	}
	return res;
}
```
思路很清晰了吧，给个代码：

```
#include<bits/stdc++.h>
using namespace std;
int read(){
	int ss=0,ww=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-')
			ww=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9'){
		ss=ss*10+ch-'0';
		ch=getchar();
	}
	return ss*ww;
}
int n,m;
const int N=200010;
int root,x,y,z;
int v[N];
int c[N];
int ls[N];
int rs[N];
int fa[N];
int sz[N];
int tag[N];
int cnt;
ll ans[N];
typedef long long ll;
int newnode(int a){
	cnt++;
	v[cnt]=a;
	c[cnt]=rand();
	sz[cnt]=1;
	ans[cnt]=(1<<a);
	return cnt;
}
void upd(int r){
	sz[r]=sz[ls[r]]+sz[rs[r]]+1;
	ans[r]=(ans[ls[r]]|ans[rs[r]]|(1<<v[r]));
}
void push_down(int r){
	tag[r]=0;
	if(ls[r]){
		tag[ls[r]]^=1;
		swap(ls[ls[r]],rs[ls[r]]);
	}
	if(rs[r]){
		tag[rs[r]]^=1;
		swap(ls[rs[r]],rs[rs[r]]);
	}
}
int merge(int r1,int r2){
	if(!r1||!r2)
		return r1+r2;
	if(c[r1]<=c[r2]){
		if(tag[r1])
			push_down(r1);
		rs[r1]=merge(rs[r1],r2);
		fa[rs[r1]]=r1;
		upd(r1);
		return r1;
	}
	else{
		if(tag[r2])
			push_down(r2);
		ls[r2]=merge(r1,ls[r2]);
		fa[ls[r2]]=r2;
		upd(r2);
		return r2;
	}
}
void split(int r,int k,int &x,int &y,int fx,int fy){
	if(!r){
		x=0;
		y=0;
		return;
	}
	if(tag[r])
		push_down(r);
	if(sz[ls[r]]>=k){
		y=r;
		split(ls[r],k,x,ls[r],fx,r);
	}
	else{
		x=r;
		split(rs[r],k-sz[ls[r]]-1,rs[r],y,r,fy);
	}
	upd(r);
	if(x)
		fa[x]=fx;
	if(y)
		fa[y]=fy;
}
void rev(int l,int r){
	split(root,l-1,x,z,0,0);
	split(z,r-l+1,y,z,0,0);
	tag[y]^=1;
	swap(ls[y],rs[y]);
	root=merge(x,merge(y,z));
}
void work(int r){
	if(fa[r])
		work(fa[r]);
	if(tag[r])
		push_down(r);
}
int find(int r){
	work(r);
	int res=sz[ls[r]]+1;
	while(fa[r]){
		if(rs[fa[r]]==r)
			res+=sz[ls[fa[r]]]+1;
		r=fa[r];
	}
	return res;
}
ll lowbit(ll k){
	return k&(-k);
}
int calc(ll k){
	int res=0;
	while(k){
		res++;
		k-=lowbit(k);
	}
	return res;
}
int main(){
	n=read();
	m=read();
	for(int i=1;i<=n;i++){
		char c;
		cin>>c;
		int a=c-96;
		root=merge(root,newnode(a));
	}
	for(int i=1;i<=m;i++){
		char opt;
		cin>>opt;
		if(opt=='I'){
			int p,a;
			char c;
			p=read();
			cin>>c;
			a=c-96;
			split(root,p,x,y,0,0);
			root=merge(merge(x,newnode(a)),y);
		}
		if(opt=='D'){
			int p;
			p=read();
			split(root,p-1,x,z,0,0);
			split(z,1,y,z,0,0);
			v[y]=-1;
			root=merge(x,z);
		}
		if(opt=='R'){
			int l,r;
			l=read();
			r=read();
			rev(l,r);
		//	print(root);
		}
		if(opt=='P'){
			int p;
			p=read();
			if(v[p]==-1)
				printf("0\n");
			else
				printf("%d\n",find(p));
		}
		if(opt=='T'){
			int p;
			p=read();
			split(root,p-1,x,z,0,0);
			split(z,1,y,z,0,0);
			cout<<char(v[y]+96);
			printf("\n");
			root=merge(x,merge(y,z));
		}
		if(opt=='Q'){
			int l,r;
			l=read();
			r=read();
			split(root,r,x,z,0,0);
			split(x,l-1,x,y,0,0);
			printf("%d\n",calc(ans[y]));
			root=merge(x,merge(y,z));
		}
	}
	return 0;
}

```


---

## 作者：Thinking (赞：4)

来一发$Splay$~~~

首先一个个操作分析：

1. I操作，$Splay$插入。
2. D操作，$Splay$删除。
3. R操作，可以参考[P3391](https://www.luogu.org/problemnew/show/P3391)，把$[x,y]$从树中分裂出来，打标记
4. P操作，在建树时把$1-n$号字符所在的结点编号记下来，判断该点是否被删除（在删除时加个记号），如果没有，先把结点上方的标记全部下推，然后将结点旋到根，输出排名
5. T操作，将排名第$x$的结点旋到根
6. Q操作，考虑字母只有26个，用$1,2,...2^{25}$状压维护一下，询问时同样把$[x,y]$从树中分裂出来，输出

于是接下来就是上模板了~~（似乎我写的最长）~~
```cpp
#include<cstdio>
#include<cctype>
#define il inline
const int N=200050;
char rB[1<<21],*S,*T,wB[1<<21];
int wp=-1;
il char gc(){return S==T&&(T=(S=rB)+fread(rB,1,1<<21,stdin),S==T)?EOF:*S++;}
il void flush(){fwrite(wB,1,wp+1,stdout);wp=-1;}
il void pc(char c){if(wp==(1<<21))flush();wB[++wp]=c;}
il char rdu(){
    char c=gc();
    while(!isupper(c))c=gc();
    return c;
}
il char rdc(){
    char c=gc();
    while(!islower(c))c=gc();
    return c;
}
il int rdi(){
    char c=gc();
    while(!isdigit(c))c=gc();
    int x=c&15;
    for(c=gc();isdigit(c);c=gc())x=(x<<3)+(x<<1)+(c&15);
    return x;
}
//快读
short buf[15];
il void wt(int x){
    short l=-1;
    while(x>9){
        buf[++l]=x%10;
        x/=10;
    }
    pc(x|48);
    while(l>=0)pc(buf[l--]|48);
    pc('\n');
}
//快写
char v[N],st[N>>1];
int pos[N>>1],s[N],fa[N],ch[N][2],f[N],sz=0;
bool lazy[N];
il void rds(){  //这个也是快读
    char c=gc();
    while(!islower(c))c=gc();
    st[1]=c;
    for(int i=2,c=gc();islower(c);i++,c=gc())st[i]=c;
}
il void Swap(int &a,int &b){int t=a;a=b;b=t;}
il short count(int x){  //数x二进制位中1的个数，即字符种类数
    short s=0;
    for(;x;x^=x&-x)s++;
    return s;
}
//模板来了
struct Splay{
    int rt;
    il int newnode(char c){
        v[++sz]=c;s[sz]=1;fa[sz]=ch[sz][0]=ch[sz][1]=0;f[sz]=1<<c-'a';lazy[sz]=0;
        return sz;
    }
    il void maintain(int o){  //维护结点信息
        s[o]=1+s[ch[o][0]]+s[ch[o][1]];  //该结点子树大小
        f[o]=(1<<v[o]-'a')|f[ch[o][0]]|f[ch[o][1]];  //该结点子树所含字符种类
    }
    il void pushdown(int o){  //下推懒标记
        if(lazy[o]){
            Swap(ch[o][0],ch[o][1]);
            lazy[ch[o][0]]^=1;lazy[ch[o][1]]^=1;
            lazy[o]=0;
        }
    }
    il short cmp(int o,char c){  //比较
        if(v[o]==c)return -1;
        else return c>v[o];
    }
    il bool dir(int o){return ch[fa[o]][1]==o;}  //o是它父亲的左/右儿子（0表示左，1表示右，以下均同）
    il void rotate(int o){  //旋转，将o旋到它父亲的位置
        int f=fa[o];
        short d=dir(o);
        fa[o]=fa[f];
        if(f==rt)rt=o;
        else ch[fa[f]][dir(f)]=o;
        if(ch[f][d]=ch[o][d^1])fa[ch[f][d]]=f;
        fa[ch[o][d^1]=f]=o;
        maintain(f);maintain(o);
    }
    il void splay(int o){  //Splay最核心的内容，将o旋转到根
        for(;fa[o];rotate(o))if(fa[fa[o]])rotate(dir(fa[o])==dir(o)?fa[o]:o);
    }
    void build(int &o,int L,int R){  //开始建一棵完美Splay
    	int M=L+R>>1;
    	o=newnode(st[M]);pos[M]=o;  //P操作用的编号
    	if(L<M){
    		build(ch[o][0],L,M-1);
    		fa[ch[o][0]]=o;
        }
        if(M<R){
            build(ch[o][1],M+1,R);
            fa[ch[o][1]]=o;
        }
        maintain(o);
    }
    il void find(int k){  //找到排名为k的结点并将其旋到根
        int o=rt,t;
        for(;;){
            pushdown(o);  //每访问一个结点都要记得下推标记
            t=s[ch[o][0]];
            if(t+1==k)break;
            else if(k<=t)o=ch[o][0];
            else{
                k-=t+1;
                o=ch[o][1];
            }
        }
        splay(o);
    }
    il int split(bool d){  //将树根的左/右儿子分裂出来
        pushdown(rt);
        int t=ch[rt][d];
        ch[rt][d]=0;fa[t]=0;
        maintain(rt);
        return t;
    }
    il void merge(int t,bool d){  //合并到树的最左/右侧
        if(!rt)rt=t;
        else{
            find(d?s[rt]:1);
            fa[ch[rt][d]=t]=rt;
            maintain(rt);
        }
    }
    il void ins(int k,char c){  //I操作，本来可以直接用find，因为写得早忘记了
    	if(!rt)rt=newnode(c);
    	else{
    		int o=rt,t;
    		for(;;){
    			pushdown(o);
    			t=s[ch[o][0]];
    			if(t+1==k)break;
    			else if(k<=t)if(ch[o][0])o=ch[o][0];
    			else{  //这里注意当k=0，即插在最前面时，是找不到第0结点的，特判一下
    				fa[ch[o][0]=newnode(c)]=o;
    				maintain(o);
    				splay(o);  //做完操作都splay一下可以保证树的随机性
    				return;
                }else{
                    k-=t+1;
                    o=ch[o][1];
                }
            }
            splay(o);
            t=split(1);
            fa[ch[o][1]=newnode(c)]=o;
            fa[ch[ch[o][1]][1]=t]=ch[o][1];
            maintain(ch[o][1]);
            maintain(o);
//先将o旋到根，再分裂右子树，将新结点变成o的右儿子，原来的右子树变成新结点的右儿子，就成功将新结点插入到o的右侧
        }
    }
    il void del(int k){  //D操作，同样可以用find简化
        int o=rt,t;
        for(;;){
            pushdown(o);
            t=s[ch[o][0]];
            if(t+1==k)break;
            else if(k<=t)o=ch[o][0];
            else{
                k-=t+1;
                o=ch[o][1];
            }
        }
        splay(o);
        t=split(1);
        v[o]='#';  //以'#'作为删除标记
        fa[rt=ch[o][0]]=0;
        merge(t,1);
//先将o旋转到根，再合并它的左右子树
    }
    void allpush(int o){  //对o的所有祖先做下推
        if(o!=rt)allpush(fa[o]);
        pushdown(o);
    }
}tree;
int main(){
    int n=rdi(),m=rdi(),x,y,t1,t2;
    char opt,c;
    rds();
    tree.build(tree.rt,1,n);
    while(m--){
        opt=rdu();x=rdi();
        if(opt=='I'){
            c=rdc();
            tree.ins(x,c);
        }else if(opt=='D')tree.del(x);
        else if(opt=='R'){
            if((y=rdi())<x)Swap(x,y);
            tree.find(y);t2=tree.split(1);
            tree.find(x);t1=tree.split(0);
//将区间[x,y]分裂出来，先找x的话y的排名会改变，不如先找y方便
            lazy[tree.rt]^=1;
            tree.merge(t1,0);
            tree.merge(t2,1);
        }else if(opt=='P')if(v[pos[x]]=='#'){pc('0');pc('\n');}
        else{
            tree.allpush(pos[x]);
            tree.splay(pos[x]);
            wt(s[ch[tree.rt][0]]+1);
        }else if(opt=='T'){
            tree.find(x);
            pc(v[tree.rt]);pc('\n');
        }else if(opt=='Q'){
            if((y=rdi())<x)Swap(x,y);
            tree.find(y);t2=tree.split(1);
            tree.find(x);t1=tree.split(0);
            wt(count(f[tree.rt]));
            tree.merge(t1,0);
            tree.merge(t2,1);
        }
    }
    flush();
    return 0;
}
```

---

## 作者：GUO120822 (赞：2)

平衡树。

发现前 3 个操作能通过模板的拼凑弄出来，注意删除的时候打个标记，不然就会在删除的树里找半天。

第 5 个操作也是板子的。

第 6 个操作状压一下，记录子树内的状态，0 表示没有，1 表示有。然后直接使用系统函数统计答案即可。

难点在于操作 4。先下传标记。注意得从上到下下传，不然有残留。注意在过程中维护父亲节点，然后计算中序遍历，若被标记，特判。

代码：


```cpp
/*采用 FHQ_treap*/
#include<bits/stdc++.h>
using namespace std;
mt19937 rd(time(NULL));
const int N=2e5+10;
int n,m,i,root,id[N],c,x,y,fa[N];
char a[N],op[2],ch;
struct FHQ{
	int l,r,size,rk,val,st,tag,fa;
}tr[N];
int add_node(int val)
{
	c++;
	tr[c].val=val;
	tr[c].rk=rd();
	tr[c].size=1;
	tr[c].st=(1<<val);
	return c;
}
void pushdown(int k)
{
	if (!tr[k].tag) return;
	tr[tr[k].l].tag^=1;
	tr[tr[k].r].tag^=1;
	swap(tr[k].l,tr[k].r);
	tr[k].tag=0;
}
void update(int k)
{
	tr[k].size=tr[tr[k].l].size+tr[tr[k].r].size+1;
	tr[k].st=(tr[tr[k].l].st|tr[tr[k].r].st|(1<<tr[k].val));
}
void split(int k,int &a,int &b,int x,int fx,int fy)
{
	if (k==0)
	{
		a=b=0;
		return;
	}
	pushdown(k);
	if (tr[tr[k].l].size+1<=x)
	{
		a=k;
		tr[k].fa=fx;
		split(tr[k].r,tr[k].r,b,x-tr[tr[k].l].size-1,k,fy);
	}
	else
	{
		b=k;
		tr[k].fa=fy;
		split(tr[k].l,a,tr[k].l,x,fx,k);
	}
	update(k);
}
void merge(int &k,int a,int b)
{
	if (a==0||b==0)
	{
		k=a+b;
		return;
	}
	if (tr[a].rk<=tr[b].rk)
	{
		k=a;
		pushdown(a);
		tr[b].fa=a;
		merge(tr[a].r,tr[a].r,b);
	}
	else
	{
		k=b;
		pushdown(b);
		tr[a].fa=b;
		merge(tr[b].l,a,tr[b].l);
	}
	update(k);
}
void insert(int &k,int x,int val)
{
	int a=0,b=0,cur=add_node(val);
	split(k,a,b,x,0,0);
	merge(a,a,cur);
	merge(k,a,b);
}
void del(int &k,int x)
{
	int a=0,b=0,z=0;
	split(k,a,b,x,0,0);
	split(a,a,z,x-1,0,0);
	tr[z].val=-1;
	merge(z,tr[z].l,tr[z].r);
	merge(a,a,z);
	merge(k,a,b);
}
void reverse(int &k,int l,int r)
{
	int a=0,b=0,z=0;
	split(k,a,b,r,0,0);
	split(a,a,z,l-1,0,0);
	tr[z].tag^=1;
	merge(a,a,z);
	merge(k,a,b);
}
int query(int &k,int l,int r)
{
	int a=0,b=0,z=0;
	split(k,a,b,r,0,0);
	split(a,a,z,l-1,0,0);
	int t=__builtin_popcount(tr[z].st);
	merge(a,a,z);
	merge(k,a,b);
	return t;
}
char print(int &k,int x)
{
	int a=0,b=0,z=0;
	split(k,a,b,x,0,0);
	split(a,a,z,x-1,0,0);
	char c=tr[z].val+'a';
	merge(a,a,z);
	merge(k,a,b);
	return c;
}
void dfs(int x)
{
	if (tr[x].fa) dfs(tr[x].fa);
	pushdown(x);
}
int fd(int x)
{
	if (tr[x].val==-1) return 0;
	dfs(x);
	int res=tr[tr[x].l].size+1;
	while (tr[x].fa)
	{
		if (tr[tr[x].fa].r==x) res+=tr[tr[tr[x].fa].l].size+1;
		x=tr[x].fa;
	}
	return res;
}
int main()
{
	scanf("%d%d%s",&n,&m,a+1);
	for (i=1;i<=n;i++)
	{
		id[i]=add_node(a[i]-'a');
		merge(root,root,id[i]);
	}
	while (m--)
	{
		scanf("%s%d",op,&x);
		if (op[0]=='I')
		{
			scanf("%s",&ch);
			insert(root,x,ch-'a');
		}
		else if (op[0]=='D') del(root,x);
		else if (op[0]=='R')
		{
			scanf("%d",&y);
			reverse(root,x,y);
		}
		else if (op[0]=='P') printf("%d\n",fd(x));
		else if (op[0]=='T') printf("%c\n",print(root,x));
		else if (op[0]=='Q') 
		{
			scanf("%d",&y);
			printf("%d\n",query(root,x,y));
		}
	}
	return 0;
}
```

---

## 作者：Lydia1010__ (赞：2)

## 本题思路：
这道题是文艺平衡树的模板题。我们发现对于字符串的操作其实只有插入，删除，翻转一个区间，查询当前的第 $x$ 的字符，查询原本存在的一个字符现在在哪里和区间元素种类个数。这些操作文艺平衡树都能实现。

文艺平衡树和普通平衡树不同的地方就在于分裂操作，普通平衡树是按照权值分裂，而文艺平衡树是按照子树大小，分裂出前面 $k$ 个字符所组成的平衡树。
```cpp
void split(int p,int &x,int &y,int k){
	if(!p){x=y=0;return;}
	if(tr[p].add){chuan(p);}
	if(tr[ls].siz>=k) y=p,split(ls,x,ls,k),wei(y);
	else x=p,split(rs,rs,y,k-tr[ls].siz-1),wei(x);
}
```

考虑实现：

1. 插入删除就直接分裂出来即可，没有什么难点。

2. 翻转操作的话我们可以打懒标记，如果当前的懒标记为一的话就交换左右儿子即可。

3. 输出原本存在的一个字符现在在哪里这一步我们可以考虑给每一个节点记录父亲节点是多少（删除的就是负一，遇见直接输出零即可）。我们就记录每个初始字符所对应的节点编号，直接跳父亲节点到根之后从根一路把懒标记传下直到回到需要查的节点（可以开一个队列，记录一路到根的结点编号，从队末开始下传懒标记）。然后考虑是多少，自己及自己的左子树肯定合法，其次就是如果每一次跳父亲时当前节点是其父亲的右子树，那么其父的左子树及其父也合法，直接求即可。

4. 输出第 $x$ 个字符直接分裂出来即可。

5. 区间元素种类个数因为只有二十六个字符，我们给每一个节点都记录一下自己子树中每个字符分别出现多少，出现的就给种类数加一即可。

## 本题代码：
```cpp
#include<bits/stdc++.h>
#define ls tr[p].ch[0]
#define rs tr[p].ch[1]
#define int long long
using namespace std;
struct f{char x;int rnd,siz,add,fa,ch[2],chh[26],ans;}tr[200005];
void wei(int p){
	tr[p].fa=0;
	tr[ls].fa=p,tr[rs].fa=p;tr[p].siz=1+tr[ls].siz+tr[rs].siz;
	tr[p].ans=0;
	for(int i=0;i<26;i++){
		tr[p].chh[i]=0;
		if(tr[p].x-'a'==i) tr[p].chh[i]=1;
		tr[p].chh[i]+=tr[ls].chh[i]+tr[rs].chh[i];
		tr[p].ans+=(tr[p].chh[i]>0?1:0);
	}
}
void chuan(int p){tr[ls].add=1-tr[ls].add;tr[rs].add=1-tr[rs].add;swap(tr[p].ch[0],tr[p].ch[1]);tr[p].add=0;}
void split(int p,int &x,int &y,int k){
	if(!p){x=y=0;return;}
	if(tr[p].add){chuan(p);}
	if(tr[ls].siz>=k) y=p,split(ls,x,ls,k),wei(y);
	else x=p,split(rs,rs,y,k-tr[ls].siz-1),wei(x);
}
void merge(int &p,int x,int y){
	if(!x||!y){p=x+y;return;}
	if(tr[x].add) chuan(x);if(tr[y].add) chuan(y);
	if(tr[x].rnd<=tr[y].rnd) p=x,merge(rs,rs,y);
	else p=y,merge(ls,x,ls);
	wei(p);
}
int cnt;
int add(char p){
	tr[++cnt].rnd=rand();tr[cnt].siz=1,tr[cnt].x=p;
	tr[cnt].chh[p-'a']++;tr[cnt].ans=1;return cnt;
}
int id[100005],root;
int st[100005],top;
int cha(int p){
	p=id[p];
	if(tr[p].fa==-1) return 0;
	top=0;
	while(p){st[++top]=p;p=tr[p].fa;}
	for(int i=top;i>=1;i--){if(tr[st[i]].add) chuan(st[i]);}
	int ans=tr[tr[st[1]].ch[0]].siz+1;
	for(int i=2;i<=top;i++){if(tr[st[i]].ch[1]==st[i-1]){ans+=tr[tr[st[i]].ch[0]].siz+1;}}
	return ans;
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0); 
	srand(time(0));
	int n,m;cin>>n>>m;
	for(int i=1;i<=n;i++){
		char x;cin>>x;
		merge(root,root,add(x));id[i]=cnt;
	}
	while(m--){
		char op;cin>>op;
		if(op=='I'){
			int l;char r;cin>>l>>r;
			int x,y;split(root,x,y,l);merge(x,x,add(r));merge(root,x,y);
		}
		if(op=='D'){
			int k,l,r,z; cin>>k;
			split(root,l,r,k);split(l,l,z,tr[l].siz-1);
			tr[z].fa=-1;merge(root,l,r);
		}
		if(op=='R'){
			int l,r;cin>>l>>r;
			int x,y,z;
			split(root,x,y,l-1);
			split(y,y,z,r-l+1);
			tr[y].add=1-tr[y].add;merge(y,y,z),merge(root,x,y);
		}
		if(op=='P'){
			int x;cin>>x;cout<<cha(x)<<'\n';
		}
		if(op=='T'){
			int x;cin>>x;
			int l,r,z;split(root,l,r,x-1);
			split(r,r,z,1);cout<<tr[r].x<<'\n';
			merge(r,r,z),merge(root,l,r);
		}
		if(op=='Q'){
			int l,r;cin>>l>>r;
			int x,y,z;
			split(root,x,y,l-1);
			split(y,y,z,r-l+1);
			cout<<tr[y].ans<<'\n';merge(y,y,z),merge(root,x,y);
		}
	}
	return 0;
}
```

---

## 作者：KiDDOwithTopTree (赞：2)

题目在这：[传送门](https://www.luogu.com.cn/problem/P5217)。

很好的一道文艺平衡树的练手题目。

### 做法：fhq treap。

主要的难点在于操作 P、T、Q。

操作 T 实际就是把操作的位置分离出来，直接输出即可。

操作 Q 则可以用压位进行处理。

何为压位？

我们可以把26个字母换成一共26位的数字。a 在个位标为1，b 在十位标为1…

但是26位的数字好大啊，怎么办呢？

我们可以把它**转换为二进制**。

那么便成了：a 在第1位标为1，b 在第2位标为1…

找到在哪个位置标1可以用**位移**来实现。

那么合并区间的答案呢？

我们可以用**或**来实现。

如何找到有多少种字母呢？

我们可以使用类似于**进制转换**的方法去寻找到。

### 重点与难点：操作 P。

~~这个操作不是一般的变态。~~

打过 Splay 的会知道，在文艺平衡树时，通常会需要一个 pushall 函数来实现把节点到根的标记全部下传。

很明显，这一题也是需要这个函数的。

但是我不想也不会打 Splay 啊！

那怕甚？fhq 同样可以！

~~只不过有点麻烦而已。~~

我们需要进行魔改 fhq，使它能够有连向 $fa$ 的边。

我们怎么去进行维护呢？

当然是从 pushup 开刀啦。

```cpp
inline void pushup(int pos){
	int lson=fhq[pos].lson,rson=fhq[pos].rson;
	if(lson)
		fhq[lson].fa=pos;//如果有左儿子，那就要把左儿子的父亲更新
	if(rson)
		fhq[rson].fa=pos;//右儿子同理
	fhq[pos].size=fhq[lson].size+fhq[rson].size+1;
	fhq[pos].tot=fhq[lson].tot|fhq[rson].tot|1<<fhq[pos].val;//更新压位
}
```

当然，在每次 merge 后，$root$ 的 $fa$ 都要更新为0。

如何 pushall 呢？

我们可以用一个**头递归**，一直顺着 $fa$ 找到根，在 pushdown 回去。

```cpp
void pushall(int pos){
	if(fhq[pos].fa)//还有父亲，就是还不是根
		pushall(fhq[pos].fa);
	pushdown(pos);//记得下传标记
}
```

因为还有可能节点被删除，所以被删除的节点的 $fa$ 可以标为-1标记成被删除。

那么 P 操作的代码如下：

```cpp
int rnk(int pos){
	if(fhq[pos].fa==-1)//被删除
		return 0;
	pushall(pos);//把节点上面的影响清空
	int ans=fhq[fhq[pos].lson].size+1;//左儿子有贡献
	for(int i=pos;fhq[i].fa;i=fhq[i].fa)//跳fa来算出所以的贡献
		if(fhq[fhq[i].fa].rson==i)//注意：只有当pos是fa的右儿子时才有左儿子的贡献
			ans+=fhq[fhq[fhq[i].fa].lson].size+1;//加上贡献
	return ans;
}
```

肯定会有人问：为什么直接就用 $pos$ 就可以了呢？

那是因为最开始我们都是按顺序一个一个插入的，第 $i$ 个字母的编号即为 $i$。

那么就可以快落地 A 这一题了~

```cpp
#include<iostream>
#include<cstdlib>
#include<cstring>
using namespace std;
const int N=1e6+10;
struct fhq_treap{
	int fa,lson,rson;
	int val,key;
	int size;
	int tot;
	int tag;
};
fhq_treap fhq[N];
string s;
int a[N];
int tot,root;
inline int newnode(int val){
	tot++;
	fhq[tot].key=rand();
	fhq[tot].tot=1<<val;//注意要位移
	fhq[tot].val=val;
	fhq[tot].size=1;
	fhq[tot].fa=0;
	return tot;
}
inline void pushup(int pos){
	int lson=fhq[pos].lson,rson=fhq[pos].rson;
	if(lson)
		fhq[lson].fa=pos;
	if(rson)
		fhq[rson].fa=pos;
	fhq[pos].size=fhq[lson].size+fhq[rson].size+1;
	fhq[pos].tot=fhq[lson].tot|fhq[rson].tot|1<<fhq[pos].val;
}
inline void pushdown(int pos){
	if(!fhq[pos].tag)
		return ;
	swap(fhq[pos].lson,fhq[pos].rson);
	fhq[fhq[pos].lson].tag^=1;
	fhq[fhq[pos].rson].tag^=1;
	fhq[pos].tag=0;
}
void split(int pos,int size,int &x,int &y){
	if(!pos){
		x=y=0;
		return ;
	}
	pushdown(pos);
	if(fhq[fhq[pos].lson].size+1<=size){
		x=pos;
		split(fhq[x].rson,size-fhq[fhq[pos].lson].size-1,fhq[x].rson,y);//注意size要减左儿子的size和自己
	}
	else{
		y=pos;
		split(fhq[y].lson,size,x,fhq[y].lson);
	}
	pushup(pos);
}
int merge(int x,int y){
	if(!x||!y)
		return x+y;
	if(fhq[x].key<fhq[y].key){
		pushdown(x);
		fhq[x].rson=merge(fhq[x].rson,y);
		pushup(x);
		return x;
	}
	else{
		pushdown(y);
		fhq[y].lson=merge(x,fhq[y].lson);
		pushup(y);
		return y;
	}
}
void pushall(int pos){
	if(fhq[pos].fa)
		pushall(fhq[pos].fa);
	pushdown(pos);
}
void ins(int pos,int val){
	int x,y;
	split(root,pos,x,y);
	root=merge(merge(x,newnode(val)),y);
	fhq[root].fa=0;//不忘标记
}
void del(int pos){
	int x,y,z;
	split(root,pos-1,x,y);
	split(y,1,y,z);
	fhq[y].fa=-1;//不忘标记
	root=merge(x,z);
	fhq[root].fa=0;//不忘标记
}
void rev(int l,int r){
	int x,y,z;
	split(root,l-1,x,y);
	split(y,r-l+1,y,z);//是r-l+1
	fhq[y].tag^=1;
	root=merge(merge(x,y),z);
	fhq[root].fa=0;//不忘标记
}
int rnk(int pos){
	if(fhq[pos].fa==-1)
		return 0;
	pushall(pos);
	int ans=fhq[fhq[pos].lson].size+1;
	for(int i=pos;fhq[i].fa;i=fhq[i].fa)
		if(fhq[fhq[i].fa].rson==i)
			ans+=fhq[fhq[fhq[i].fa].lson].size+1;
	return ans;
}
char num(int pos){
	int x,y,z;
	split(root,pos-1,x,y);
	split(y,1,y,z);
	char ch=fhq[y].val+'a';
	root=merge(merge(x,y),z);
	fhq[root].fa=0;//不忘标记
	return ch;
}
int cnt(int l,int r){
	int x,y,z;
	split(root,l-1,x,y);
	split(y,r-l+1,y,z);
	int tmp=fhq[y].tot;
	root=merge(merge(x,y),z);
	fhq[root].fa=0;//不忘标记
	int ans=0;
	while(tmp){
		ans+=tmp%2;
		tmp/=2;
	}//类似进制转换来求
	return ans;
}
int main(){
	int n,m;
	cin>>n>>m;
	cin>>s;
	for(int i=0;i<n;i++)
		a[i+1]=s[i]-'a';
	for(int i=1;i<=n;i++)
		root=merge(root,newnode(a[i]));
	char opt,ch;
	int x,y;
	for(int i=1;i<=m;i++){
		cin>>opt;
		switch(opt){
			case 'I':
				cin>>x>>ch;
				ins(x,ch-'a');
				break;
			case 'D':
				cin>>x;
				del(x);
				break;
			case 'R':
				cin>>x>>y;
				rev(x,y);
				break;
			case 'P':
				cin>>x;
				cout<<rnk(x)<<'\n';
				break;
			case 'T':
				cin>>x;
				cout<<num(x)<<'\n';
				break;
			case 'Q':
				cin>>x>>y;
				cout<<cnt(x,y)<<'\n';
				break;
		}
	}
}
```

---

## 作者：SSerxhs (赞：2)

非常裸、而且非常简单的一道平衡树。

前5个操作都是平衡树的基本操作，第6个操作可以考虑状压，2^26用一个int就能存下来，则区间合并直接取或即可。如果此题字符集再大一些可以考虑bitset

```cpp
#include <stdio.h>
#include <string.h>
#include <algorithm>
using namespace std;
const int N=2e5+2;
int s[N],siz[N],c[N][2],f[N],zf[N],lz[N],st[N],ys[N];
int n,m,i,j,x,y,z,cc,ds,tp,rt;
inline void read(int &x)
{
    cc=getchar();
    while ((cc<48)||(cc>57)) cc=getchar();
    x=cc^48;cc=getchar();
    while ((cc>=48)&&(cc<=57))
    {
        x=x*10+(cc^48);
        cc=getchar();
    }
}
inline void pushup(int x)
{
    s[x]=s[c[x][0]]|s[c[x][1]]|1<<zf[x];
    siz[x]=siz[c[x][0]]+siz[c[x][1]]+1;
}
inline void pushdown(int x)
{
    if (lz[x])
    {
        swap(c[c[x][0]][0],c[c[x][0]][1]);
        swap(c[c[x][1]][0],c[c[x][1]][1]);
        lz[c[x][0]]^=1;lz[c[x][1]]^=1;
        lz[x]=0;
    }
}
inline void zigzag(int x)
{
    int y=f[x],typ=(c[y][1]==x);
    if (f[x]=f[y]) c[f[y]][c[f[y]][1]==y]=x;
    if (c[x][typ^1]) f[c[x][typ^1]]=y;
    c[y][typ]=c[f[y]=x][typ^1];
    c[x][typ^1]=y;
    pushup(y);
}
inline void splay(int x,int tar)
{
    int y=st[tp=1]=x;
    while (f[y]) st[++tp]=y=f[y];
    while (tp) pushdown(st[tp--]);
    while ((y=f[x])!=tar)
    {
        if (f[y]!=tar)
        {
            if (c[f[y]][0]==y^c[y][0]==x) zigzag(x); else zigzag(y);
        }
        zigzag(x);
    }
    pushup(x);
    if (!tar) rt=x;
}
inline void find(int kth,int tar)
{
    int x=rt;
    pushdown(x);
    while (siz[c[x][0]]+1!=kth)
    {
        if (siz[c[x][0]]>=kth) pushdown(x=c[x][0]); else
        {
            kth-=siz[c[x][0]]+1;
            pushdown(x=c[x][1]);
        }
    }
    splay(x,tar);
}
int main()
{
    read(n);read(m);
    while ((cc<'a')||(cc>'z')) cc=getchar();
    siz[1]=ds=n+2;siz[n+2]=1;
    c[1][1]=2;f[n+2]=n+1;
    c[2][1]=3;f[2]=1;siz[2]=n+1;
    ys[1]=2;
    zf[2]=cc^96;
    for (i=2;i<=n;i++)
    {
        siz[i+1]=n+2-i;
        c[i+1][1]=i+2;
        f[i+1]=i;
        zf[i+1]=getchar()^96;
        ys[i]=i+1;
    }
    for (i=n+1;i;i--) pushup(i);
    s[n+2]=1;
    rt=1;
    while (m--)
    {
        cc=getchar();
        while ((cc<'A')||(cc>'Z')) cc=getchar();
        if (cc=='I')
        {
            read(x);
            find(x+1,0);find(x+2,rt);
            x=c[rt][1];
            f[c[x][0]=++ds]=x;
            while ((cc<'a')||(cc>'z')) cc=getchar();
            zf[ds]=cc^96;
            siz[ds]=1;
            s[ds]=1<<zf[ds];
            pushup(x);pushup(rt);
            continue;
        }
        if (cc=='D')
        {
            read(x);
            find(x,0);find(x+2,rt);
            x=c[rt][1];
            zf[c[x][0]]=0;
            c[x][0]=0;
            pushup(x);pushup(rt);
            continue;
        }
        if (cc=='R')
        {
            read(x);read(y);
            find(x,0);find(y+2,rt);
            x=c[c[rt][1]][0];
            lz[x]^=1;swap(c[x][0],c[x][1]);
            continue;
        }
        if (cc=='P')
        {
            read(x);
            x=ys[x];
            if (!zf[x])
            {
                puts("0");
                continue;
            }
            splay(x,0);
            printf("%d\n",siz[c[x][0]]);
            continue;
        }
        if (cc=='T')
        {
            read(x);
            find(x+1,0);
            printf("%c\n",zf[rt]|96);
        }
        else
        {
            read(x);read(y);
            find(x,0);find(y+2,rt);
            x=c[c[rt][1]][y=0];
            for (i=1;i<=26;i++) if (1<<i&s[x]) ++y;
            printf("%d\n",y); 
        }
    }
}
```

---

## 作者：talent_wei (赞：1)

## 一、题前话

[题目传送门](https://www.luogu.com.cn/problem/P5217)

借此写一写对 FHQ-Treap 的感悟

## 二、FHQ-Treap

### Treap

什么是 Treap？Treap 是一个二叉搜索树，基于随机化。其满足 BST 和 Heap 两个的性质。即对于每一个节点都有一个 $\text{key}$（数值，用来满足 BST）和 $\text{val}$（优先级，用来满足 Heap）。对于任意一个节点，都有 $\text{key}_{lson} < \text{key}_u < \text{key}_{rson}$, $\text{val}_u > \text{val}_{lson}$, $\text{val}_u > \text{val}_{rson}$。

首先根据 Treap 的定义则一个集合（假设所有元素的 $\text{key}$ 和 $\text{val}$ 已知）建成的 Treap 应该是唯一的。我们可以这样去想：我们先把 $\text{val}$ 最大的 $\text u$ 拿出来做根节点，然后把 $\text{key}$ < $\text{key}_u$ 的集合拿出来做左子树，剩余的做右子树。递归下去树的结构就是确定的。

那么如果这样我们就可以证明树高的期望是 $O(\log n)$ 的，很好的完成了保持树平衡的任务，使得 BST 平均时间复杂度降至 $O(\log n)$。

### FHQ-Treap

普通 Treap 是基于旋转的，那么为什么要有 FHQ-Treap 呢？因为他简单好写好理解，能解决很多区间问题且可以可持久化。

什么是 FHQ-Treap 呢？首先他只基于 $\text {merge}$ 和 $\text {split}$ 这两个操作，可以参考一下[这里](https://www.luogu.com.cn/article/ifj4ute5)。笔者主要写一下对区间操作的认识。

首先我们先放上 P3369 的代码

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define LL __int128

// problem : P3369
// coded by talent_wei
// time : 2025 / 3 / 18
// algorithm : FHQ - Treap

const int N = 1e5 + 5;
int n, val[N], key[N], size[N], num[N];
int ls[N], rs[N], root, cnt;

mt19937 g(time(0));
uniform_int_distribution < int > myrand(0, 1000000000);

int newnode(int v) {
	key[++ cnt] = v;
	val[cnt] = myrand(g);
	size[cnt] = num[cnt] = 1;
	return cnt;
}

void pushup(int o) {
	size[o] = size[ls[o]] + size[rs[o]] + num[o];
}

void split(int o, int &x, int &y, int v) {
	if(!o) {
		x = y = 0;
		return;
	}
	if(key[o] <= v) {
		x = o;
		split(rs[o], rs[o], y, v);
	} else {
		y = o;
		split(ls[o], x, ls[o], v);
	}
	pushup(x), pushup(y);
}

void merge(int &o, int x, int y) {
	if(!x || !y) {
		o = x + y;
		return;
	}
	if(val[x] >= val[y]) {
		o = x;
		merge(rs[o], rs[x], y);
	} else {
		o = y;
		merge(ls[o], x, ls[y]);
	}
	pushup(o);
}

void insert(int v) {
	int l = 0, mid = 0, r = 0;
	split(root, l, r, v);
	split(l, l, mid, v - 1);
	if(mid) num[mid] ++, size[mid] ++;
	else mid = newnode(v);
	merge(l, l, mid);
	merge(root, l, r);
}

void remove(int v) {
	int l = 0, mid = 0, r = 0;
	split(root, l, r, v);
	split(l, l, mid, v - 1);
	num[mid] --, size[mid] --;
	if(num[mid]) merge(l, l, mid);
	merge(root, l, r);
}

int getrank(int v) {
	int l = 0, r = 0, ans = 0;
	split(root, l, r, v - 1);
	ans = size[l] + 1;
	merge(root, l, r);
	return ans;
}

int getkth(int k) {
	int o = root;
	while(true) {
		if(k <= size[ls[o]]) {
			o = ls[o];
			continue;
		}
		k -= size[ls[o]] + num[o];
		if(k <= 0) return key[o];
		o = rs[o];
	}
}

int getprev(int v) {
	int l = 0, r = 0;
	split(root, l, r, v - 1);
	int o = l;
	while(rs[o]) o = rs[o];
	merge(root, l, r);
	return key[o];
}

int getnext(int v) {
	int l = 0, r = 0;
	split(root, l, r, v);
	int o = r;
	while(ls[o]) o = ls[o];
	merge(root, l, r);
	return key[o];
}

int main() {
	ios::sync_with_stdio(false);
	cin >> n;
	while(n --) {
		int op, x;
		cin >> op >> x;
		if(op == 1) insert(x);
		if(op == 2) remove(x);
		if(op == 3) cout << getrank(x) << "\n";
		if(op == 4) cout << getkth(x) << "\n";
		if(op == 5) cout << getprev(x) << "\n";
		if(op == 6) cout << getnext(x) << "\n";
	}
	return 0;
}
```

这是基于按值分裂的。我们可以瞅一下按排名分裂的（因为一般序列操作都是在每一位置进行操作）

```cpp
void split(int o, int &x, int &y, int k) {
	if(!o) {
		x = y = 0;
		return;
	}
	if(size[l(o)] + 1 <= k) {
		x = o;
		split(r(o), r(x), y, k - size[l(o)] - 1);
	} else {
		y = o;
		split(l(o), x, l(y), k);
	}
	pushup(x), pushup(y);
}
```

先放一道题：
[我做的第一道题](https://www.luogu.com.cn/problem/P2596)

题目要维护一个 stack，其实把他搞平了就是维护一个数组。

先看第一个要求：置顶。

置顶其实就是放到第一个位置。

那我们很明显可以先按排名分裂，找到这本书。然后把这本书的 $\text{key}$ 值调到最小，然后 $\text {merge}$。这时的 $\text{key}$ 可以理解成当前位置的相对大小。

但是我们发现一个很好玩的事情：我们在整个代码的其他部分（包括 $\text {merge}$）都不会用到这个 $\text{key}$，因为 $\text {merge}$ 是有序的。

那我们就很好了，直接把不要 $\text {key}$ 了，把他 $\text {split}$  出来后直接 $\text {merge}$ 就行了。

其他操作同理。

最后注意一下要把 $0$ 去除，因为如果我们 $\text{pushup(0)}$，$0$ 节点的内容就会有改变，但空节点也是 $0$，容易出现错误。

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define LL __int128

// problem : P2596 
// coded by talent_wei
// time : 2025 / 3 / 19
// algorithm : FHQ - Treap

const int N = 1e5 + 5;
int n, m, a[N], val[N], id[N], cnt;
int root, fa[N], size[N], ls[N], rs[N];

mt19937 g(time(0));
uniform_int_distribution < int > myrand(0, 1000000000);

int newnode(int v) {
	val[++ cnt] = myrand(g);
	size[cnt] = 1;
	return cnt;
}

void pushup(int o) {
	if(!o) return;
	size[o] = size[ls[o]] + size[rs[o]] + 1;
	if(ls[o]) fa[ls[o]] = o;
	if(rs[o]) fa[rs[o]] = o;
}

void split(int o, int &x, int &y, int k) {
	if(!o) {
		x = y = 0;
		return;
	}
	if(size[ls[o]] + 1 <= k) {
		x = o;
		split(rs[o], rs[x], y, k - size[ls[o]] - 1);
	} else {
		y = o;
		split(ls[o], x, ls[y], k);
	}
	pushup(x), pushup(y);
}

void merge(int &o, int x, int y) {
	if(!x || !y) {
		o = x + y;
		return;
	}
	if(val[x] >= val[y]) {
		o = x;
		merge(rs[o], rs[x], y);
	} else {
		o = y;
		merge(ls[o], x, ls[y]);
	}
	pushup(o);
}
 
int getrank(int o) {
	int ans = size[ls[o]] + 1;
	while(o != root) {
		if(rs[fa[o]] == o) ans += size[ls[fa[o]]] + 1;
		o = fa[o];
	}
	return ans;
}

void debug(int o) {
	printf("size[%d] = %d, fa[%d] = %d\n\n", a[o], size[o], a[o], a[fa[o]]);
	if(ls[o]) printf("%d --l--> %d\n\n", a[o], a[ls[o]]), debug(ls[o]);
	if(rs[o]) printf("%d --r--> %d\n\n", a[o], a[rs[o]]), debug(rs[o]);
}

int main() {
	cin >> n >> m;
	for(int i = 1; i <= n; i++) {
		cin >> a[i];
		id[a[i]] = newnode(a[i]);
		merge(root, root, id[a[i]]);
	}
	while(m --) {
		char op[10]; 
		int x, l = 0, r = 0, mid = 0;
		scanf("%s%d", op + 1, &x);
		if(op[1] == 'T') {
			int k = getrank(id[x]);
			split(root, l, r, k);
			split(l, l, mid, k - 1);
			merge(l, mid, l);
			merge(root, l, r);
		} else if(op[1] == 'B') {
			int k = getrank(id[x]);
			split(root, l, r, k);
			split(l, l, mid, k - 1);
			merge(r, r, mid);
			merge(root, l, r);
		} else if(op[1] == 'I') {
			int t; scanf("%d", &t); 
			if(!t) continue;
			x = getrank(id[x]);
			int bmid = 0;
			if(t > 0) {
				split(root, l, r, x + 1);
				split(l, l, mid, x);
				split(l, l, bmid, x - 1);
				merge(l, l, mid);
				merge(l, l, bmid);
				merge(root, l, r);
			} else {
				split(root, l, r, x);
				split(l, l, mid, x - 1);
				split(l, l, bmid, x - 2);
				merge(l, l, mid);
				merge(l, l, bmid);
				merge(root, l, r);
			}
		} else if(op[1] == 'Q') {
			split(root, l, r, x);
			split(l, l, mid, x - 1);
			printf("%d\n", a[mid]);
			merge(l, l, mid);
			merge(root, l, r);
		} else printf("%d\n", getrank(id[x]) - 1);
	}
	return 0;
}
```

看一下懒标记：

首先可以发现这个东西和线段树有点像，都是从下面合并，但不同的是这个还要加上此节点自己的影响。

但懒标记是一样的啊，可以就把他理解成线段树的懒标记，但是 $\text{pushdown}$ 是在 $\text{key}$ 和 $\text {split}$  里面做。

所以就非常的简单。

## 对于此题：

我们对于每一个节点都维护一个 $\text{rev}$，代表是不是要反转。然后维护一个 $\text{s[26]}$，代表在这个区间内某字母是否出现过。

code:

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define LL __int128

// problem : P5217 
// coded by talent_wei
// time : 2025 / 3 / 21
// algorithm : FHQ - Treap
// 1.split注意是 split(l, l, mid, x - 1) 而不是 split(root, l, mid, x - 1)
// 2.所有pushup / pushdown 把 0 都跳过 
// 3.调试时可以用极为简单的样例 

const int N = 2e5 + 5;
int n, m, root, cnt, val[N], size[N], ls[N], rs[N];
int rev[N], s[N][26], sum[N], del[N], fa[N];
char ch[N];

mt19937 g(time(0));
uniform_int_distribution < int > myrand(0, 1000000000);

int newnode(char v) {
	val[++ cnt] = myrand(g);
	size[cnt] = sum[cnt] = 1;
	s[cnt][v - 'a'] = 1;
	ch[cnt] = v;
	return cnt;
} 

void adds(int x, int y) {
	sum[x] = 0;
	for(int i = 0; i < 26; i++) {
		s[x][i] = s[x][i] || s[y][i];
		sum[x] += s[x][i];
	}
}

#define l(o) ls[o]
#define r(o) rs[o]

void pushup(int o) {
	if(!o) return;
	size[o] = 1; sum[o] = 1;
	memset(s[o], 0, sizeof s[o]);
	s[o][ch[o] - 'a'] = 1;
	if(l(o)) fa[l(o)] = o, size[o] += size[l(o)], adds(o, l(o));
	if(r(o)) fa[r(o)] = o, size[o] += size[r(o)], adds(o, r(o));
}

void pushdown(int o) {
	if(!rev[o]) return;
	swap(l(o), r(o));
	if(l(o)) rev[l(o)] ^= 1;
	if(r(o)) rev[r(o)] ^= 1;
	rev[o] = 0;
}

void split(int o, int &x, int &y, int k) {
	if(!o) {
		x = y = 0;
		return;
	}
	pushdown(o);
	if(size[l(o)] + 1 <= k) {
		x = o;
		split(r(o), r(x), y, k - size[l(o)] - 1);
	} else {
		y = o;
		split(l(o), x, l(y), k);
	}
	pushup(x), pushup(y);
}

void merge(int &o, int x, int y) {
	if(!x || !y) {
		o = x + y;
		return;
	}
	pushdown(x), pushdown(y);
	if(val[x] >= val[y]) {
		o = x;
		merge(r(o), r(x], y);
	} else {
		o = y;
		merge(l(o), x, l(y));
	}
	pushup(o);
}

void cleartag(int o) {
	if(o != root) cleartag(fa[o]);
	pushdown(o);
}

int getrank(int o) {
	cleartag(o);
	int res = size[l(o)] + 1;
	while(o != root) {
		if(r(fa[o]) == o) res += size[l(fa[o])] + 1;
		o = fa[o];
	}
	return res;
}

int main() {
	ios::sync_with_stdio(false);
	cin >> n >> m >> ch + 1;
	for(int i = 1; i <= n; i++) 
		merge(root, root, newnode(ch[i]));
	while(m --) {
		char op, c; 
		int x, y, l = 0, r = 0, mid = 0;
		cin >> op >> x;
		if(op == 'I') {
			cin >> c;
			split(root, l, r, x);
			merge(l, l, newnode(c));
			merge(root, l, r);
		} else if(op == 'D') {
			split(root, l, r, x);
			split(l, l, mid, x - 1);
			if(mid <= n) del[mid] = 1;
			merge(root, l, r);
		} else if(op == 'R') {
			cin >> y;
			split(root, l, r, y);
			split(l, l, mid, x - 1);
			rev[mid] ^= 1;
			merge(l, l, mid);
			merge(root, l, r);
		} else if(op == 'P') {
			if(del[x]) cout << 0 << "\n";
			else cout << getrank(x) << "\n";
		} else if(op == 'T') {
			split(root, l, r, x);
			split(l, l, mid, x - 1);
			cout << ch[mid] << "\n";
			merge(l, l, mid);
			merge(root, l, r);
		} else if(op == 'Q') {
			cin >> y;
			split(root, l, r, y);
			split(l, l, mid, x - 1);
			cout << sum[mid] << "\n";
			merge(l, l, mid);
			merge(root, l, r);
		}
	}
	return 0;
}
```

## END

---

## 作者：qinsishi (赞：1)

我们注意到需要区间翻转，那大概率只能使用平衡树树了，这里我使用无旋 Treap。

这道题有一个棘手操作是查询区间出现的字母种类数，考虑到最多只有 $26$ 种字母，我们可以把出现过的字母状压到一起。

还有一个小问题就是如何求得原字母现在的排名。注意到，可以用平衡树的初始节点 $i\in[1,n]$ 来代表原字符串 $S$ 的 $S_i$。这样我们只需要求节点 $i$ 的排名即可；若节点 $i$ 被删除，则打个标记即可。

求排名时只需要从节点 $i$ 往上跳，如果是右儿子就把根和左子树一贡献。注意到，由于需要下传翻转区间的标记，所以在求排名时需要先跑到根节点下传一下标记。

那么，接下来，至于要按排名分类和正常合并即可。其它添加删除都是平衡树的常规操作。

具体细节见代码：

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

const int N = 2e5+10; // 空间是 2e5
int siz[N], rnd[N];
int ls[N], rs[N], fa[N];
int tag[N], val[N], u[N];
int n, m;
int tot, root;

int newnode(int v) {
	++tot;
	siz[tot]=1; rnd[tot]=rand(); 
	val[tot]=(1<<v); u[tot]=(1<<v);
	return tot;
}

void dosth(int p, int z) { // 翻转 
	tag[p] ^= z; 
	if (z) swap(ls[p], rs[p]);
}

void down(int p) {
	if (tag[p]) {
		if (ls[p]) dosth(ls[p], tag[p]);
		if (rs[p]) dosth(rs[p], tag[p]);
		tag[p] = 0; 
	}
}

int push(int p) {
	fa[ls[p]] = p; fa[rs[p]] = p;
	siz[p] = siz[ls[p]]+siz[rs[p]]+1;
	val[p] = u[p]|val[ls[p]]|val[rs[p]];
	return p;
}

void spsiz(int p, int s, int &L, int &R) {
	if (!p) return L=R=0, void();
	down(p);
	if (siz[ls[p]] >= s) R=p, spsiz(ls[p], s, L, ls[p]); 
	else L=p, spsiz(rs[p], s-siz[ls[p]]-1, rs[p], R);
	push(p);
}

int merge(int L, int R) {
	if (!L||!R) return L|R;
	down(L); down(R);
	if (rnd[L]>rnd[R]) return rs[L]=merge(rs[L], R), push(L);
	else return ls[R]=merge(L, ls[R]), push(R);
}

void clear(int p) {
	if (p != root) clear(fa[p]);
	down(p); 
}

int ask(int p) {
	clear(p);
	int ret = siz[p]-siz[rs[p]];
	while (p != root) {
		if (rs[fa[p]] == p)
			ret += siz[fa[p]]-siz[p];
		p = fa[p]; 
	}
	return ret;
}

signed main() {
	ios::sync_with_stdio(0);
	cin.tie(0);
	srand(time(0));
	string s; cin >> n >> m >> s;
	s = " " + s;
	for (int i=1; i<=n; ++i) {
		int x = newnode(s[i]-'a');
		root = merge(root, x);
	} 
	while (m--) {
		string op, ch; int x, y, a, b, c; 
		cin >> op >> x;
		switch (op[0]) {
		case 'I': 
			cin >> ch; 
			spsiz(root, x, a, b);
			root = merge(merge(a, newnode(ch[0]-'a')), b);
			break;
		case 'D':
			spsiz(root, x-1, a, b); 
			spsiz(b, 1, b, c);
			u[b] = 0;
			root = merge(a, c);
			break;
		case 'R':
			cin >> y;
			spsiz(root, y, b, c);
			spsiz(b, x-1, a, b);
			dosth(b, 1);
			root = merge(merge(a, b), c);
			break;
		case 'P':
			if (u[x] == 0) cout << "0\n";
			else cout << ask(x) << '\n';
			break;
		case 'T':
			spsiz(root, x-1, a, b);
			spsiz(b, 1, b, c);
			for (int i=0; i<26; ++i) {
				if ((val[b]>>i)&1) {
					cout << char('a'+i) << '\n';
					break;
				}
			}
			root = merge(merge(a, b), c);
			break;
		case 'Q':
			cin >> y;
			int cnt = 0;
			spsiz(root, y, b, c);
			spsiz(b, x-1, a, b);
			for (int i=0; i<26; ++i) {
				if ((val[b]>>i)&1) {
					++cnt;
				}
			}
			cout << cnt << '\n';
			root = merge(merge(a, b), c);
		}
	}
	return 0;
}
```

---

## 作者：5k_sync_closer (赞：1)

提供一个代码短，跑得快的指针 FHQ 写法。

前置知识：FHQ Treap，[文艺平衡树](https://www.luogu.com.cn/problem/P3391)，[笛卡尔树](https://www.luogu.com.cn/problem/P5854)（用来优化常数）。
# 思路
用平衡树维护之，考虑经典平衡树五问：
### 节点信息
因为我们写的是 FHQ，所以要记录左右孩子、两个权值、子树大小。

考虑怎么处理 P 操作。我们记录初始文本中每个字符对应的节点，

询问节点 $x$ 的排名时，从根到 $x$ 依次 push down，再从 $x$ 到根统计 $x$ 前面的节点数。

因为要处理 $x$ 到根的路径，所以要记录父节点。

因为要特判 $x$ 不存在的情况，所以要记录该节点是否被删除。

考虑怎么处理 Q 操作。注意到字符集很小，我们记录一个状压值 $q$，$q$ 的第 $i$ 位为 $1$ 表示该子树内包含字符 `'a'+i`。
### 节点标记
因为要维护区间反转，所以要记录区间反转标记。
### 下传标记
和[文艺平衡树](https://www.luogu.com.cn/problem/P3391)一样，不解释。
### 区间修改
和[文艺平衡树](https://www.luogu.com.cn/problem/P3391)一样，直接打标记即可，不解释。
### 上传信息
正常更新子树大小，注意更新父节点。

考虑如何合并状压值 $q$，显然可以按位或解决。

于是我们可以写出：
```cpp
struct T
{
    T *l, *r, *f;int v, k, s, q;bool b, g;int z() {return l ? l->s : 0;}
    T(int _) : l(0), r(0), f(0), v(_), k(rand()), s(1), q(1 << v), b(0), g(0) {}void u() {
    s = 1;q = 1 << v;if(l) l->f = this, s += l->s, q |= l->q;if(r) r->f = this, s += r->s, q |= r->q;}
    void d() {if(b) {T *t = l;l = r;r = t;if(l) l->b ^= 1;if(r) r->b ^= 1;b = 0;}}
}*r, *a, *b, *c, *s[30], *d[100050];void D(T *x) {if(x) D(x->f), x->d();}
void S(T *x, int k, T *&a, T *&b)
{
    if(!x) {a = b = 0;return;}if(!k) {a = 0;b = x;return;}
    if(k >= x->s) {a = x;b = 0;return;}x->d();int z = x->z();
    if(z >= k) b = x, S(x->l, k, a, b->l), b->u();
    else a = x, S(x->r, k - z - 1, a->r, b), a->u();
}
T *M(T *a, T *b)
{
    if(!a) return b;if(!b) return a;
    if(a->k < b->k) {a->d();a->r = M(a->r, b);a->u();return a;}
    else {b->d();b->l = M(a, b->l);b->u();return b;}
}
```
考虑怎么把初始文本建出来。我们可以用笛卡尔树优化建树过程：
```cpp
for(int i = 1;i <= n;++i)
{
    do v = getchar();while(!islower(v));a = new T(v - 'a');
    k = a->k;p = l;while(l && k < s[l - 1]->k) s[--l]->u();
    if(l < p) a->l = s[l];if(l) s[l - 1]->r = a;s[l++] = d[i] = a;
}
while(l) s[--l]->u();r = s[0];
```
接下来分别考虑每种操作。
### I 操作/D 操作
套路分裂合并，不解释。
```cpp
scanf(" %c%d", &o, &x);switch(o) {
case 'I': scanf(" %c", &v);S(r, x, a, b);r = M(a, M(new T(v - 'a'), b));break;
case 'D': S(r, x - 1, a, b);S(b, 1, b, c);b->g = 1;r = M(a, c);break;
```
### R 操作
和[文艺平衡树](https://www.luogu.com.cn/problem/P3391)一样，把操作区间分裂出来，打标记，合并回去。
```cpp
case 'R': scanf("%d", &y);S(r, y, a, c);S(a, x - 1, a, b);b->b ^= 1;r = M(a, M(b, c));break;
```
### P 操作
见上文。

>询问节点 $x$ 的排名时，从根到 $x$ 依次 push down，再从 $x$ 到根统计 $x$ 前面的节点数。

```cpp
case 'P': q = 0;if(!d[x]->g) {D(a = d[x]);q = a->z() + 1;
for(;a->f;a = a->f) if(a == a->f->r) q += a->f->z() + 1;}printf("%d\n", q);break;
```
### T 操作
套路分裂合并，不解释。
```cpp
case 'T': S(r, x - 1, a, b);S(b, 1, b, c);printf("%c\n", b->v + 'a');r = M(a, M(b, c));break;
```
### Q 操作
把操作区间分裂出来，输出 $q$ 的二进制中 $1$ 的个数（可以用 `__builtin_popcount` 计算），合并回去。
```cpp
case 'Q':scanf("%d", &y);S(r, y, a, c);S(a, x - 1, a, b);
printf("%d\n", __builtin_popcount(b->q));r = M(a, M(b, c));break;
```
# Code
~~来点极简风代码~~
```cpp
#include <cstdio>
#include <cctype>
#include <cstdlib>
#define A r = M(a, M(b, c))
#define B S(r, x - 1, a, b);S(b, 1, b, c)
#define C S(r, R(), a, c);S(a, x - 1, a, b)
inline int R()
{
    int r = 0;char c = getchar();while(!isdigit(c)) c = getchar();
    while(isdigit(c)) r = r * 10 + c - '0', c = getchar();return r;
}
int n, m, l, k, p, o, x, y, q;char v;struct T
{
    T *l, *r, *f;int v, k, s, q;bool b, g;int z() {return l ? l->s : 0;}
    T(int _) : l(0), r(0), f(0), v(_), k(rand()), s(1), q(1 << v), b(0), g(0) {}void u() {
    s = 1;q = 1 << v;if(l) l->f = this, s += l->s, q |= l->q;if(r) r->f = this, s += r->s, q |= r->q;}
    void d() {if(b) {T *t = l;l = r;r = t;if(l) l->b ^= 1;if(r) r->b ^= 1;b = 0;}}
}*r, *a, *b, *c, *s[30], *d[100050];void D(T *x) {if(x) D(x->f), x->d();}
void S(T *x, int k, T *&a, T *&b)
{
    if(!x) {a = b = 0;return;}if(!k) {a = 0;b = x;return;}
    if(k >= x->s) {a = x;b = 0;return;}x->d();int z = x->z();
    if(z >= k) b = x, S(x->l, k, a, b->l), b->u();
    else a = x, S(x->r, k - z - 1, a->r, b), a->u();
}
T *M(T *a, T *b)
{
    if(!a) return b;if(!b) return a;
    if(a->k < b->k) {a->d();a->r = M(a->r, b);a->u();return a;}
    else {b->d();b->l = M(a, b->l);b->u();return b;}
}
int main()
{
    srand(388651);n = R();m = R();for(int i = 1;i <= n;++i)
    {
        do v = getchar();while(!islower(v));a = new T(v - 'a');
        k = a->k;p = l;while(l && k < s[l - 1]->k) s[--l]->u();
        if(l < p) a->l = s[l];if(l) s[l - 1]->r = a;s[l++] = d[i] = a;
    }
    while(l) s[--l]->u();r = s[0];while(m--)
    {
        scanf(" %c", &o);x = R();switch(o)
        {
            case 'I': scanf(" %c", &v);S(r, x, a, b);r = M(a, M(new T(v - 'a'), b));break;
            case 'D': B;b->g = 1;r = M(a, c);break;case 'R': C;b->b ^= 1;A;break;
            case 'P': q = 0;if(!d[x]->g) {D(a = d[x]);q = a->z() + 1;for(;a->f;a = a->f)
            if(a == a->f->r) q += a->f->z() + 1;}printf("%d\n", q);break;
            case 'T': B;printf("%c\n", b->v + 'a');A;break;
            case 'Q': C;printf("%d\n", __builtin_popcount(b->q));A;break;
        }
    }
    return 0;
}
```


---

## 作者：JimmyLee (赞：0)

# 题意

>维护一个字符串，支持以下操作：
>
>- $\texttt{I x c}$，在第 $x$ 个字母后面插入一个 $c$。
>- $\texttt{D x}$，删除第 $x$ 个字母。
>- $\texttt{R x y}$，反转当前文本中的区间 $[x,y]$。
>- $\texttt{P x}$，输出初始文本中第 $x$ 个字母在当前文本中的位置。特别地，若不存在，输出 $0$。
>- $\texttt{T x}$，输出当前文本中第 $x$ 个字母。
>- $\texttt{Q x y}$，输出当前文本中区间 $[x,y]$ 内出现过的字母的种类数。

# 分析

序列问题，有插入操作，直接无脑上平衡树。

本题解使用 FHQ Treap。

---

我们先看这一个操作：

>  - $\texttt{P x}$，输出初始文本中第 $x$ 个字母在当前文本中的位置。特别地，若不存在，输出 $0$。

发现一般的 FHQ Treap 无法维护相关信息。

考虑**记录每个节点的父亲节点**。

从该节点向根跳，如果该节点是父亲节点的右儿子，那么记录父亲节点及其左子树贡献。

新的问题来了：如何维护父亲节点？

我们可以考虑在 `push_up()` 操作时维护，将两个子节点的父节点设为当前节点。

对于个别节点（`split()` 或 `merge()` 操作后的根节点），在操作完后单独将父节点设为空即可。

该部分代码如下：

```cpp
void access(node *x) 
{
    if(!x) return; 
    access(x->fa); 
    x->push_down();
}

uint32_t find_pos(node *x)
{
    if(x->del||!x) return 0;
    access(x);
    uint32_t res=siz(x->lc)+1;
    while(x->fa)
    {
        if(x->fa->rc==x) 
            res+=siz(x->fa->lc)+1;
        x=x->fa;
    }
    return res;
}
```

---

然后来看查询操作：

>  - $\texttt{Q x y}$，输出当前文本中区间 $[x,y]$ 内出现过的字母的种类数。

可以维护一个 `bitset`，记录哪些字母是出现过的。

`push_up()` 代码如下：

```cpp
node* push_up()
{
    siz=1;
    chr.reset();
    chr[c-'a']=1;
    if(lc) siz+=lc->siz, chr|=lc->chr, lc->fa=this;
    if(rc) siz+=rc->siz, chr|=rc->chr, rc->fa=this;
    return this;
}
```

查询本身就很套路了：

```cpp
int query(int l, int r)
{
    node *a, *b, *c;
    split(str, l-1, a, b);
    split(b, r-l+1, b, c);
    int ret=b->chr.count();
    str=merge(merge(a, b), c);
    str->fa=0;
    return ret;
}
```

其他的都是 FHQ Treap 的基本操作，不多赘述。

# Code

```cpp
#include<bits/stdc++.h>
using namespace std;
#define maxn 200005

namespace Treap
{
    mt19937 rnd(time(0));

    struct node
    {
        uint64_t id;
        int64_t siz=1;
        node *lc=0, *rc=0, *fa=0;
        char c;
        bool del=0, rev=0;
        bitset<26> chr;
        node(char ch, uint64_t d): c(ch), id(d) {chr.reset(); chr[ch-'a']=1;}

        void reverse() {swap(lc, rc); rev^=1;}

        void push_down()
        {
            if(rev) 
            {
                if(lc) lc->reverse();
                if(rc) rc->reverse();
                rev^=1;
            }
        }

        node* push_up()
        {
            siz=1;
            chr.reset();
            chr[c-'a']=1;
            if(lc) siz+=lc->siz, chr|=lc->chr, lc->fa=this;
            if(rc) siz+=rc->siz, chr|=rc->chr, rc->fa=this;
            return this;
        }
    };

    node* new_node(char v) {return new node(v, rnd());}

    #define siz(x) (x?x->siz:0)

    void split(node *x, int s, node *&l, node *&r)
    {
        if(!x) return l=r=0, void();
        x->push_down();
        if(siz(x->lc)<s) l=x, split(x->rc, s-siz(x->lc)-1, x->rc, r);
        else             r=x, split(x->lc, s, l, x->lc);
        x->push_up();
    }

    node* merge(node *x, node *y)
    {
        if(!x||!y) return x?x:y;
        if(x->id<y->id)
        {
            x->push_down();
            x->rc=merge(x->rc, y);
            return x->push_up();
        }
        else
        {
            y->push_down();
            y->lc=merge(x, y->lc);
            return y->push_up();
        }
    }

    void access(node *x) 
    {
        if(!x) return; 
        access(x->fa); 
        x->push_down();
    }
    
    uint32_t find_pos(node *x)
    {
        if(x->del||!x) return 0;
        access(x);
        uint32_t res=siz(x->lc)+1;
        while(x->fa)
        {
            if(x->fa->rc==x) 
                res+=siz(x->fa->lc)+1;
            x=x->fa;
        }
        return res;
    }

    node *str;

    void insert(int p, char c)
    {
        node *a, *b;
        split(str, p, a, b);
        str=merge(merge(a, new_node(c)), b);
        str->fa=0;
    }

    void erase(int p)
    {
        node *a, *b, *c;
        split(str, p-1, a, b);
        split(b, 1, b, c);
        b->del=1;
        str=merge(a, c);
        if(str) str->fa=0;
    }

    void reverse(int l, int r)
    {
        node *a, *b, *c;
        split(str, l-1, a, b);
        split(b, r-l+1, b, c);
        b->reverse();
        str=merge(merge(a, b), c);
        str->fa=0;
    }

    char get(int p)
    {
        node *a, *b, *c;
        split(str, p-1, a, b);
        split(b, 1, b, c);
        char ret=b->c;
        str=merge(merge(a, b), c);
        str->fa=0;
        return ret;
    }

    int query(int l, int r)
    {
        node *a, *b, *c;
        split(str, l-1, a, b);
        split(b, r-l+1, b, c);
        int ret=b->chr.count();
        str=merge(merge(a, b), c);
        str->fa=0;
        return ret;
    }
}

Treap::node *rt[maxn];
string s;

int main()
{
    int n, m;
    cin>>n>>m>>s;
    for(int i=1;i<=n;i++) 
        rt[i]=Treap::new_node(s[i-1]), 
        Treap::str=merge(Treap::str, rt[i]);
    while(m--)
    {
        char op;
        int x, y;
        char ch;
        cin>>op>>x;
        if(op=='I') cin>>ch, Treap::insert(x, ch);
        if(op=='D') Treap::erase(x);
        if(op=='R') cin>>y, Treap::reverse(x, y);
        if(op=='P') cout<<Treap::find_pos(rt[x])<<'\n';
        if(op=='T') cout<<Treap::get(x)<<'\n';
        if(op=='Q') cin>>y, cout<<Treap::query(x, y)<<'\n';
    }
}
```

---

## 作者：FutaRimeWoawaSete (赞：0)

被降智了。               

考虑用 fhq-treap 维护。              

对于一操作我们直接按子树大小分裂插入即可。            

对于二操作我们直接按子树大小分裂删除即可。             

对于三操作，也就是文艺平衡树，我们直接分裂出需要反转的囊括了区间的树，打上反转标记后一直 push_down 就好了。           

对于四操作，我们考虑初始插入的平衡树节点 $x$，其在平衡树节点中的标号也是 $x$，用这个节点向上跳到根然后从根到底下 push_down 一遍后维护它在这棵平衡树里中序遍历的位置即可。            

对于五操作，直接按子树大小分裂输出即可。            

对于六操作，考虑在平衡树上开一个大小为 $26$ 的 bool 数组然后每次 update 从子树转移即可，为了省空间可以压成一个 int 整型。           

时间复杂度 $O(n \log n)$，空间复杂度 $O(n)$。

```cpp
#include "bits/stdc++.h"
using namespace std;
const int Len = 2e5 + 5;
int n,m,root,x,y,z,tot;
bool vis[Len];
struct node
{
	int l,r,siz,key,val,tag,f;
	int sum;
	node(){l = r = siz = key = val = tag = f = sum = 0;}
	node(int L,int R,int SIZ,int KEY,int VAL,int TAG,int F,long long SUM){l = L , r = R , siz = SIZ , key = KEY , val = VAL , tag = TAG , f = F , sum = SUM;}
}fhq[Len];
int newnode(int val)
{
	++ tot;
	fhq[tot] = node(0 , 0 , 1 , rand() , val , 0 , 0 , (1 << val));
	return tot;
}
#define ls fhq[p].l
#define rs fhq[p].r
void update(int p)
{
	fhq[p].siz = fhq[ls].siz + fhq[rs].siz + 1;
	fhq[p].sum = fhq[ls].sum | fhq[rs].sum | (1 << fhq[p].val);
	//fhq[ls].f = p , fhq[rs].f = p;
}
void push_down(int p)
{
	if(fhq[p].tag)
	{
		swap(fhq[p].l , fhq[p].r);
		fhq[ls].tag ^= 1 , fhq[rs].tag ^= 1;
		fhq[p].tag = 0;
	}
}
void split(int now,int k,int &x,int &y,int lstx,int lsty)
{
	if(!now){x = y = 0;return;}
	push_down(now);
	if(k <= fhq[fhq[now].l].siz)
	{
		y = now;
		fhq[now].f = lsty;
		split(fhq[now].l , k , x , fhq[now].l , lstx , y);
	}
	else
	{
		x = now;
		fhq[now].f = lstx;
		split(fhq[now].r , k - fhq[fhq[now].l].siz - 1 , fhq[now].r , y , x , lsty);
	}
	update(now);
}
int merge(int x,int y)
{
	if(!x || !y) return x + y;
	if(fhq[x].key < fhq[y].key) 
	{
		push_down(x);
		fhq[x].r = merge(fhq[x].r , y);
		fhq[fhq[x].r].f = x;
		update(x);
		return x;
	}
	else
	{
		push_down(y);
		fhq[y].l = merge(x , fhq[y].l);
		fhq[fhq[y].l].f = y;
		update(y);
		return y;
	}
}
void Ins(int siz,int val)
{
	x = y = 0;
	split(root , siz , x , y , 0 , 0);
	root = merge(merge(x , newnode(val)) , y);
}
void del(int siz)
{
	x = y = z = 0;
	split(root , siz - 1 , x , z , 0 , 0);
	split(z , 1 , y , z , 0 , 0);
	vis[y] = 1;
	root = merge(x , z);
}
void Rev(int l,int r)
{
	int Siz = r - l + 1;
	split(root , l - 1 , x , z , 0 , 0);
	split(z , Siz , y , z , 0 , 0);
	fhq[y].tag ^= 1;
	root = merge(x , merge(y , z));
}
vector<int> calc;
void Pa(int x)
{
	calc.push_back(x);
	if(x == root) return;
	Pa(fhq[x].f);
}
void Print(int x)
{
	push_down(x);
	if(fhq[x].l) Print(fhq[x].l);
	printf("%d\n",x);
	if(fhq[x].r) Print(fhq[x].r);
}
int Pos(int x)
{
	if(vis[x]) return 0;
	calc.clear();
	Pa(x);
	//for(int j = 0 ; j < calc.size() ; j ++) printf("calc:%d ",calc[j]);
	int u = root , nums = calc.size() - 1 , rank = 0;
	while(u != x && nums - 1 >= 0)
	{
		push_down(u);
		if(fhq[u].l == calc[nums - 1]) u = fhq[u].l;
		else rank += fhq[fhq[u].l].siz + 1 , u = fhq[u].r;
		-- nums;
	}
	push_down(u);
	//Print(root);
	return rank + fhq[fhq[u].l].siz + 1;
}
void FirX(int siz)
{
	x = y = z = 0;
	split(root , siz , x , z , 0 , 0);
	split(x , siz - 1 , x , y , 0 , 0);
	putchar(fhq[y].val + 'a') , puts("");
	root = merge(merge(x , y) , z);
}
void Count(int l,int r)
{
	int Siz = r - l + 1;
	split(root , l - 1 , x , z , 0 , 0);
	split(z , Siz , y , z , 0 , 0);int sim = 0;
	for(int i = 0 ; i < 26 ; i ++) sim += ((fhq[y].sum >> i) & 1); 
	printf("%d\n",sim);
	root = merge(x , merge(y , z));
}
char s[Len],ss[5],sss[5];
int main()
{
	srand(time(0));
	scanf("%d %d",&n,&m);
	scanf("%s",s + 1);
	for(int i = 1 ; i <= n ; i ++) Ins(i - 1 , s[i] - 'a');
	int X,Y;
	for(int i = 1 ; i <= m ; i ++)
	{
		scanf("%s",ss + 1);
		if(ss[1] == 'I') 
		{
			scanf("%d",&X);
			scanf("%s",sss + 1);
			Ins(X , sss[1] - 'a');
		}	
		else if(ss[1] == 'D') 
		{
			scanf("%d",&X);
			del(X);
		}
		else if(ss[1] == 'R')
		{
			scanf("%d %d",&X,&Y);
			Rev(X , Y);
		}
		else if(ss[1] == 'P') 
		{
			scanf("%d",&X);
			printf("%d\n",Pos(X));
		}
		else if(ss[1] == 'T') 
		{
			scanf("%d",&X);
			FirX(X);
		}
		else if(ss[1] == 'Q') 
		{
			scanf("%d %d",&X,&Y);
			Count(X , Y);
		}
	}
	return 0;
}
```

---

## 作者：试试事实上吗 (赞：0)

​		看完题目我们都知道是平衡树，而且是要资瓷区间操作的平衡树，并且要能区间翻转，所以我们~~被迫~~选择~~自带三倍大常数~~的$Splay$，剩下的都是一些平衡树的基操了。

操作$1$ ：插入，很简单。~~该怎么插就怎么插~~

操作$2$ ：删除，直接删除。

操作$3$ ：翻转，将要操作的子树旋转出来，然后直接打标记翻转。

操作$4$ ：开始时将整个序列$build$出来，然后用数组将原序列在平衡树中的位置记录下来。平衡树中的一个点被删除后就给那个点打上标记，查询时直接查对应的位置，如果被删除后就输出$0$，否则先$dfs$将路上的标记$pushdown$下来，然后再旋转到根输出排名即可。

操作$5$ ：第$k$小，直接输出即可。

操作$6$ ：状压压字母，将要操作的子树旋转出来，然后直接输出。

### 细节

$1.$

推荐使用一个这样的函数：

```cpp
inline int split(int l,int r)
{
    int x=rnk(l-1),y=rnk(r+1);
    splay(x,0);splay(y,x);
    return lc(y);
}
```

$rnk$就是找第$k$个位置。

然后你要插入就

```cpp
int u=split(pos,pos-1);
```

删除就

```cpp
int u=split(pos,pos);
```

找区间就

```cpp
int u=split(l,r);
```

$2.$

为了不使我们$split$时越界，我们就在首尾搞两个字母，然后要把读入后的位置$++$。

然后呢？然后就完了。

上代码：

```cpp
inline int ids(int u) {return u==rc(fc(u));}
inline void connect(int u,int f,int s) {fc(u)=f;tr[f].ch[s]=u;}
inline void pushup(int u)
{
    if(!u) return;
    tr[u].siz=tr[lc(u)].siz+tr[rc(u)].siz+1;
    tr[u].valt=tr[lc(u)].valt|tr[rc(u)].valt|(1<<tr[u].val);
}
inline void update(int u)
{
    tr[u].rev^=1;
    swap(lc(u),rc(u));
}

inline void pushdown(int u)
{
    if(!tr[u].rev) return;
    if(lc(u)) update(lc(u));
    if(rc(u)) update(rc(u));
    tr[u].rev=0;
}

inline void rotate(int u)
{
    int f=fc(u),ff=fc(f),s1=ids(u),s2=ids(f);
    connect(tr[u].ch[s1^1],f,s1);connect(f,u,s1^1);connect(u,ff,s2);
    pushup(f);pushup(u);
}

inline void splay(int u,int to)
{
    while(fc(u)!=to)
    {
        if(fc(fc(u))==to) rotate(u);
        else if(ids(u)==ids(fc(u))) rotate(fc(u)),rotate(u);
        else rotate(u),rotate(u);
    }
}

inline int rnk(int k)
{
    int u=root;
    while(u)
    {
        pushdown(u);
        if(tr[lc(u)].siz+1==k) return u;
        else if(tr[lc(u)].siz>=k) u=lc(u);
        else k=k-tr[lc(u)].siz-1,u=rc(u);
    }
}

inline int split(int l,int r)
{
    int x=rnk(l-1),y=rnk(r+1);
    splay(x,0);splay(y,x);
    return lc(y);
}

inline void insert(int pos,int val)
{
    split(pos,pos-1);
    int u=rc(root),v=++utot;lc(u)=v;
    tr[v].siz=1;tr[v].fa=u;tr[v].val=val;tr[v].valt=(1<<val);
    pushup(u);pushup(fc(u));pushup(fc(fc(u)));
}

inline void erase(int pos)
{
    int u=split(pos,pos);delt[u]=1;
    lc(fc(u))=0;fc(u)=0;
}

inline void reverse(int l,int r)
{
    int u=split(l,r);
    update(u);
}

void prepush(int u)
{
    if(!u) return;
    prepush(fc(u));pushdown(u);
}

inline int getpos(int pos)
{
    if(delt[used[pos]]) return 1;
    const int &u=used[pos];
    prepush(u);splay(u,0);
    return tr[lc(u)].siz+1;
}

inline int getcol(int l,int r)
{
    int u=split(l,r),res=0;u=tr[u].valt;
    while(u) res++,u=u-(u&(-u));
    return res;
}

int build(int l,int r,int f)
{
    if(l>r) return 0;
    int mid=(l+r)>>1,u=++utot;
    fc(u)=f;used[mid]=u;tr[u].siz=1;
    if(mid!=1&&mid!=n+2) tr[u].val=pre[mid]-'a',tr[u].valt=1<<tr[u].val;
    lc(u)=build(l,mid-1,u);
    rc(u)=build(mid+1,r,u);
    pushup(u);
    return u;
}

template<typename T>
inline void read(T &x)
{
    char c;int f=1;
    while(!isdigit(c=getchar())) (c=='-')&&(f=-1);
    x=c^48;
    while(isdigit(c=getchar())) x=x*10+(c^48);
    x*=f;
}

int main()
{
    int x,y,t;
    char in[10],opt[10];
    read(n);read(t);
    scanf("%s",pre+2);
    root=build(1,n+2,root);
    while(t--)
    {
        scanf("%s",opt);read(x);x++;
        if(opt[0]=='I') scanf("%s",in),insert(x+1,in[0]-'a');
        else if(opt[0]=='D') erase(x);
        else if(opt[0]=='R') read(y),y++,reverse(x,y);
        else if(opt[0]=='P') printf("%d\n",getpos(x)-1);
        else if(opt[0]=='T') printf("%c\n",(char)tr[rnk(x)].val+'a');
        else read(y),y++,printf("%d\n",getcol(x,y));
    }
    return 0;
}
```



---

## 作者：123456xwd (赞：0)

#### [P5217 贫穷](https://www.luogu.com.cn/problem/P5217)

用 FHQ-Treap 解决，按照排名来分裂 。

首先，明确一点，原序列中的第 $i$ 个元素在平衡树中的下标也为 $i$。

Treap 维护以下信息：

```c++
struct node{
	int l,r,val,rnd,siz,cnt,tag,fa;
	bool flag;
}a[N<<1];
```

依次表示左儿子下标，右儿子下标，这个节点代表的字母，Treap 的随机值，该节点为根的树的大小，该节点为根的树内节点包含的字母的状压值，区间翻转的懒惰标记，该节点的父亲（没有的话为空），这个点是否被删除。

**操作一：**

分裂成两颗，然后和新节点合并。

```c++
cin>>x>>c;
split(root,x,rt1,rt2);
root=merge(merge(rt1,New(c-'a')),rt2);
```

**操作二：**

分裂成三颗，把左右两颗合并，记得给被删除的节点打上标记，后面有用。

```c++
cin>>x;
split(root,x,rt1,rt2);
split(rt1,x-1,rt1,rt3);
a[rt3].flag=1;
root=merge(rt1,rt2);
```

**操作三：**

区间翻转，分裂成三颗，然后给对应的打上标记即可。

```c++
cin>>x>>y;
split(root,y,rt1,rt3);
split(rt1,x-1,rt1,rt2);
a[rt2].tag^=1;
root=merge(merge(rt1,rt2),rt3);
```

**操作四：**

首先，根据标记判断那个节点有没有被删除。

若没有被删除，就是找到下标为 $x$ 的节点的排名。

注意，由于有区间翻转操作，需要先从 $x$ 递归到 $root$，从上往下依次标记下传。

```c++
void down(int k){//依次下放 
	if(a[k].fa) down(a[k].fa);
	push_down(k);
}
int find(int x){//节点x的排名 
	down(x);//因为和结构有关，所以要先下传标记. 
	int ans=a[a[x].l].siz+1;
	while(a[x].fa){
		if(a[a[x].fa].r==x) ans+=a[a[x].fa].siz-a[x].siz;
		x=a[x].fa;
	}
	return ans;
}
//主函数内：
cin>>x;
if(a[x].flag) cout<<"0\n";
else cout<<find(x)<<"\n";
```

**操作五：**

查找第 $x$ 大，记得在查找前先下传标记。

```c++
int kth(int x,int k){
	while(1){
		push_down(x);//下传标记
		if(a[a[x].l].siz>=k) x=a[x].l;
		else if(a[a[x].l].siz+1==k) return x;
		else k-=1+a[a[x].l].siz,x=a[x].r;
	}
}
//主函数内：
cin>>x;
cout<<(char)(a[kth(root,x)].val+'a')<<"\n"; 
```

**操作六：**

先分裂出来对应的区间。

查找其根节点的状压变量二进制下一的个数即可。

```c++
cin>>x>>y;
split(root,y,rt1,rt3);
split(rt1,x-1,rt1,rt2);
cout<<__builtin_popcount(a[rt2].cnt)<<"\n";
root=merge(merge(rt1,rt2),rt3);
```



#### 代码：

```c++
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int N=1e5+5;
struct node{
	int l,r,val,rnd,siz,cnt,tag,fa;
	bool flag;
}a[N<<1];
int tot;
int New(int id){
	a[++tot].rnd=rand()*rand();
	a[tot].siz=1;
	a[tot].val=id;
	a[tot].cnt=(1<<id); 
	return tot;
}
void push_up(int k){
	if(a[k].l) a[a[k].l].fa=k;
	if(a[k].r) a[a[k].r].fa=k;
	a[k].siz=a[a[k].l].siz+a[a[k].r].siz+1;
	a[k].cnt=a[a[k].l].cnt|a[a[k].r].cnt|(1<<a[k].val);
}
void push_down(int k){
	if(!a[k].tag) return;
	if(a[k].l) a[a[k].l].tag^=1;
	if(a[k].r) a[a[k].r].tag^=1;
	swap(a[k].l,a[k].r);
	a[k].tag=0;
}
void down(int k){//依次下放 
	if(a[k].fa) down(a[k].fa);
	push_down(k);
}
void split(int now,int k,int &x,int &y){
	if(!now){
		x=y=0;
		return;
	}
	push_down(now);
	if(a[a[now].l].siz>=k){
		y=now;split(a[now].l,k,x,a[y].l);
	}
	else{
		x=now;split(a[now].r,k-1-a[a[now].l].siz,a[x].r,y);
	}
	push_up(now);
}
int merge(int x,int y){
	if(!x||!y) return x+y;
	if(a[x].rnd<a[y].rnd){
		push_down(x);a[x].r=merge(a[x].r,y);
		push_up(x);return x;
	}
	else{
		push_down(y);a[y].l=merge(x,a[y].l);
		push_up(y);return y;
	}
}
int find(int x){//节点x的排名 
	down(x);//因为和结构有关，所以要先下传标记. 
	int ans=a[a[x].l].siz+1;
	while(a[x].fa){
		if(a[a[x].fa].r==x) ans+=a[a[x].fa].siz-a[x].siz;
		x=a[x].fa;
	}
	return ans;
}
int kth(int x,int k){
	while(1){
		push_down(x);
		if(a[a[x].l].siz>=k) x=a[x].l;
		else if(a[a[x].l].siz+1==k) return x;
		else k-=1+a[a[x].l].siz,x=a[x].r;
	}
}
string s;
int n,m,root,rt1,rt2,rt3,rt4;
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	srand(time(0));
	cin>>n>>m>>s;s=' '+s;
	for(int i=1;i<=n;i++){
		root=merge(root,New(s[i]-'a'));
	}
	int x,y;
	char opt,c;
	while(m--){
		cin>>opt;
		if(opt=='I'){
			cin>>x>>c;
			split(root,x,rt1,rt2);
			root=merge(merge(rt1,New(c-'a')),rt2);
		}
		if(opt=='D'){
			cin>>x;
			split(root,x,rt1,rt2);
			split(rt1,x-1,rt1,rt3);
			a[rt3].flag=1;
			root=merge(rt1,rt2);
		}
		if(opt=='R'){
			cin>>x>>y;
			split(root,y,rt1,rt3);
			split(rt1,x-1,rt1,rt2);
			a[rt2].tag^=1;
			root=merge(merge(rt1,rt2),rt3);
		} 
		if(opt=='P'){
			cin>>x;
			if(a[x].flag) cout<<"0\n";
			else cout<<find(x)<<"\n";
		}
		if(opt=='T'){
			cin>>x;
			cout<<(char)(a[kth(root,x)].val+'a')<<"\n"; 
		}
		if(opt=='Q'){
			cin>>x>>y;
			split(root,y,rt1,rt3);
			split(rt1,x-1,rt1,rt2);
			cout<<__builtin_popcount(a[rt2].cnt)<<"\n";
			root=merge(merge(rt1,rt2),rt3);
		}
	}
	return 0;
}
```

---


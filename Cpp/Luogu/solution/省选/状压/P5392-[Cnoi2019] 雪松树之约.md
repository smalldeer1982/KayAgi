# [Cnoi2019] 雪松树之约

## 题目背景

由于 Cirno 突然犯懒, 所以背景故事咕咕咕了。

## 题目描述

Cirno 定义了一种图：圆柱网络 $G( L, x )$ 。

$G(L, x)$ 表示一个有 $L \times x$ 个节点的图。

其中每个节点用一个整数二元组 $( a, b )$ 表示 $( 1 \le a \le L, 1 \le b \le x )$。

对于 $ \forall i \in (1,L], \ j \in (0,x]$ , 节点 $(i, j)$ 与节点 $(i - 1, j)$ 之间有一条边。

对于 $ \forall i \in [1,L], \ j \in (0,x)$ , 节点 $(i, j)$ 与节点 $(i, j +1)$ 之间有一条边。

对于 $ \forall i \in [1,L]$ 节点 $(i, x)$ 与 节点 $(i, 1)$ 之间有一条边。

现在 Cirno 想知道 $G( L, x )$ 的 **独立集** 的个数。

由于你不会高精度，所以你需要将答案对 $998244353$ 取模。


## 说明/提示

对于 前 $10\%$ 的数据 $ L, x \le 8 $。

对于 前 $30\%$ 的数据 $ x \le 8 $。

对于 前 $50\%$ 的数据 $ x \le 11 $。

对于 $100\%$ 的数据 $0 < L \le 10^{18}, 0 <x \le 17 $。

本题采用捆绑测试。

下图 是 $G( 3, 4 )$ 的示例图。

![](https://cdn.luogu.com.cn/upload/pic/56163.png)

## 样例 #1

### 输入

```
3 4```

### 输出

```
181```

## 样例 #2

### 输入

```
1000 8```

### 输出

```
124141757```

# 题解

## 作者：lonlyn (赞：4)

[可能在博客里内容更丰富一些](http://lonlyn.gitee.io/blog/2019/08/06/luoguP5392/)

&emsp;&emsp;10%的数据：~~打表~~状压dp。

&emsp;&emsp;30%的数据：非常朴素的状压dp+矩阵加速。

&emsp;&emsp;50%的数据：虽然方案数 $2^{11}$ 比较多，但是**真正可行的方案只有199种**。我们只需针对可行的方案进行处理，便可以在时间空间上得以满足。（如果发现因为tle得了30分大概需要卡一卡常数~~反正我卡了~~）

&emsp;&emsp;50分代码自动省略（大佬们应该都会虽然博客里有）。

&emsp;&emsp;100%数据：

&emsp;&emsp;当x为17的时候我们发现可行的方案数也达到 3571 让人无法接受。所以我们要减少方案。

&emsp;&emsp;方法就是**将类似的方案合并**，也就是将**能循环互相得到的方案归到一组，成为一个总的状态，用它进行转移**。

&emsp;&emsp;为什么可以这么做？

&emsp;&emsp;对于**两组状态 $A,B$ **，我们现在要求**由 $A$ 状态转移到 $B$ 状态**，对于**任意的两个状态 $s1,s2\in{A}$ ，它转移到B状态的方案数是相同的**。

&emsp;&emsp;证明？~~显然~~因为这是个可以循环的结构。我们完全可以把s2旋转到s1的位置重合（属于一个方案组），同样s2时的B中状态也同时旋转到与s1时的B中状态相同。所以是等价的。

&emsp;&emsp;（这个道理不好说明可以意会一下。下面有图片解释）

&emsp;&emsp;通过分组思维我们就可以将方案数减少到 211 种，然后就可以解决此题。

&emsp;&emsp;同时记录一下几个坑：

&emsp;&emsp;1.注意全0方案的处理。全0方案自成一组，它到**任何方案组的方案数**为其**方案组里的状态总数**，任何方案组到全0方案组的的方案数为 1 。

&emsp;&emsp;2.**方案组可以转移到方案组自身**。且注意此时方案数不一定为方案组里状态总数-1。

&emsp;&emsp;3.方案组里的状态总数并不一定等于 x 。

&emsp;&emsp;最后再来个方案组等价举例：
![一个栗子](https://cdn.luogu.com.cn/upload/pic/69520.png)
&emsp;&emsp;如图，第一层（红色）左右两个状态等价。它们转移到第二层（蓝色）的可选点也就是蓝色标出的点，旋转后即相同。

&emsp;&emsp;完结撒花。蒟蒻代码如下:
```c++
// luogu-judger-enable-o2
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
#include<ctime>
#include<vector>
using namespace std;
#define ll long long
#define il inline
#define rg register
const ll mod=998244353;
struct matrix{
    ll a[233][233];
    void clr(){
        memset(a,0,sizeof(a));
    }
}u,v,ed;
ll n,x,ans;
int a_id[132000],tot;
int num[20]; int p;
int s[132000],vis[132000];
vector<int> G[132000];
il matrix unit(){
    matrix tmp; tmp.clr();
    for (rg int i=1;i<=230;++i)
      tmp.a[i][i]=1;
    return tmp;
}
il matrix operator * (matrix aa,matrix bb){
    matrix tmp; tmp.clr();
    for (rg int k=1;k<=tot;++k){
        for (rg int i=1;i<=tot;++i){
            for (rg int j=1;j<=tot;++j){
                tmp.a[i][j]=((tmp.a[i][j]+aa.a[i][k]*bb.a[k][j]))%mod;
            }
        }
    }
    return tmp;
}
il int work(int tmp){
    if (tmp&(1<<x)) return tmp-(1<<x)+1;
    else return tmp;
}
il void checkcircle(int tmp){
    G[tmp].push_back(tmp);
    a_id[++tot]=tmp;
    s[tmp]++; vis[tmp]=1;
    int nxt=work(tmp<<1);
    while (!vis[nxt]){
        G[tmp].push_back(nxt);
        vis[nxt]=true; s[tmp]++;
        nxt=work(nxt<<1);
    }
}
il void check(int tmp){
    if (vis[tmp]) return;
    int xx=tmp;
    p=0; memset(num,0,sizeof(num));
    while (tmp){
        ++p;
        if (tmp&1) num[p]=true;
        tmp>>=1;
    }
    for (rg int i=2;i<=x;++i)
      if (num[i]&&num[i-1]) return;
    if (num[x]&&num[1]) return;
    checkcircle(xx);
    u.a[tot][tot]=s[a_id[tot]];
}
il void link(){
    for (rg int i=1;i<=tot;++i){
        for (rg int j=1;j<=tot;++j){
            int uu=a_id[i],vv=a_id[j],sum=0,to;
            if (vv==0){
                v.a[i][j]=1;
                continue;
            }
            if (uu==0){
                v.a[i][j]=s[vv];
                continue;
            }
            for (rg int k=0;k<G[vv].size();++k){
                to=G[vv][k];
                if ((uu&to)==0) ++sum;
            }
            v.a[i][j]=sum;
        }
    }
}
int main(){
    cin>>n>>x;
    for (rg int i=0;i<=(1<<x)-1;++i) check(i);
    link();
    matrix tmp=unit(); n--;
    while (n){
        if (n&1) tmp=tmp*v;
        v=v*v; n>>=1;
    }
    ed=u*tmp;
    for (rg int i=1;i<=tot;++i)
      for (rg int j=1;j<=tot;++j){
        ans=(ans+ed.a[i][j]+mod)%mod;
    }
    cout<<ans;
    return 0;
}
```
~~对蒟蒻我来说这题感觉真的很鲁棒~~

---

## 作者：LeavingZzz (赞：2)

## $\mathsf{Solution}\space\mathsf{For}\space \mathsf{P5392}$  
~~先吐槽一句卡常~~  

### $\mathsf{Analysis}$
题目提示很明显（  

`圆柱网络`  

实际上是若干个多边形逐层连接成的柱体  
![](https://cdn.luogu.com.cn/upload/image_hosting/lci0bvnp.png)  
每一层在图形上是完全一样的，然后本题要求该图的独立集个数  

先不考虑这么多层，假如只给一个多边形，要求这个多边形图的独立集个数，发现多边形点数 $x\le 17$ 于是想到状压，用二进制位的 `0/1` 表示该点 选择/未选 的状态  
![](https://cdn.luogu.com.cn/upload/image_hosting/kzfqoa7v.png)  
可以暴力枚举全部的 $2^x$ 个状态然后检查是否出现相邻的 `1` 或者是否首尾同时是 `1`（如上图左边是一种可行的状态，而右边的就不是）  

然后考虑多层的时候的解法  

尝试dp，设 $f[i][j]$ 表示第 $i$ 层采取可行状态 $j$ 的时候的独立集个数  

有状态转移方程  
$$f[i][j]=\sum\limits_{sta_k \& sta_j=0}f[i-1][k]$$  
于是便可以先把所有单层的可行状态暴力算出来然后按照上述方程dp，时间复杂度 $O(L\times sta^2)$ ，$sta$ 是指单层可行状态数目，期望得分 $10$ 分  

考虑优化，这里的 $L$ 只给了 $2$ 档，发现当 $L\le10^{18}$ 的时候似乎只能用 $\log L$ 的时间递推，于是考虑用点科技加速递推  

于是想到矩阵加速  
设计一个大小为 $sta\times sta$ 的转移矩阵，考虑让如下两个矩阵乘法  

$$\begin{bmatrix}f[i-1][1]&f[i-1][2]&...&f[i-1][j]\\&\\&\end{bmatrix}\begin{bmatrix}able(1,1)&able(2,1)&...&able(j,1)\\able(1,2)&able(2,2)&...&able(j,2)\\.....\\able(1,j)&able(2,j)&...&able(j,j)\end{bmatrix}$$  
$able(i,j)$ 是一个标记，当 $sta_i\&sta_j=0$ 时 $able(i,j)=1$ 否则 $able(i,j)=0$  

然后根据矩阵乘法的结合律，将右边的转移矩阵作 $L-1$ 次幂  

但是这个做法的得分也只有 $50$ 分，原因是在 $x=17$ 的时候状态数已经多达 $3571$ 种，矩阵乘法的复杂度是 $O(N^3)$ 的，妥妥超时  

进一步考虑优化，尝试合并状态  

如  
![](https://cdn.luogu.com.cn/upload/image_hosting/hcvgl46o.png)  
可以旋转得到的状态实际上可以合并为一组，原因就在于可以将其中一种转移到终态的全部过程旋转一个角度和另外一种重合，也就是组内的形态都是是等价的  

这时候 $able(i,j)$ 也需要修改，变成了在第 $j$ 组中有多少个形态与第 $i$ 组的一个元素的 $\operatorname{and}$ 值为 $0$，至于为什么这里只能取一个，因为一个组内所有的形态是等价的，一个元素能够扩展到的状态个数等于其他元素能够扩展到的状态个数，可以结合 $f[i+1][k]=\sum f[i][j]\times able(j,k)$ 理解。  
### $\mathsf{Code}$
```
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<vector>
#include<iostream>
#include<cctype>
using namespace std;
typedef long long LL;
const int maxs=(1<<17)+7;
const int maxn=212;
const int mod=998244353;
int cnt;
LL N,K;
struct Matrix
{
    LL m[maxn][maxn];
    Matrix () {memset(m,0,sizeof(m));return ;}
}ini,trans;
Matrix operator * (const Matrix &x,const Matrix &y)
{
    Matrix t;
    for(int k=1;k<=cnt;k++)
        for(int i=1;i<=cnt;i++)
            for(int j=1;j<=cnt;j++)
                t.m[i][j]=(t.m[i][j]+x.m[i][k]*y.m[k][j])%mod;
    return t;
}
Matrix operator ^ (Matrix b,LL k)
{
    Matrix s;
    for(int i=1;i<=cnt;i++)
        s.m[i][i]=1;
    while(k)
    {
        if(k&1) s=s*b;
        b=b*b;
        k>>=1;
    }
    return s;
}
int nxt(int x)//将数x的二进制位循环左移一位
{
    if((x>>K-1)&1) return ((x<<1)^(1<<K))^1;
    return (x<<1);
}
bool vis[maxs];//某种状态是否出现
vector <int> m[maxn];
int sta[maxn],sz[maxn];

bool judge(int x)//判断是否出现相邻的1
{
    if(((x>>K-1)&1)&&(x&1)) return false;//首尾同时为1
    for(int i=0;i<K-1;i++)
    if((x&(1<<i))&&(x&(1<<i+1))) return false;//相邻的1
    return true;
}
void add(int x)
{
    if(vis[x]) return ;//出现过的状态
    vis[x]=true;
    sta[++cnt]=x;//第cnt组的一个元素x
    sz[cnt]=1;//第cnt组元素个数
    m[cnt].push_back(x);//cnt组中的全部元素
    x=nxt(x);//旋转状态
    while(!vis[x])//将可以通过旋转形态x得到的形态记入cnt组
    {
        vis[x]=true;
        ++sz[cnt];m[cnt].push_back(x);
        x=nxt(x);//旋转
    }
    ini.m[1][cnt]=sz[cnt];//如果初始为第cnt组中的形态那么有sz[cnt]种方案
    return ;
}
void pre()
{
    int u,v,re;
    for(int i=1;i<=cnt;i++)
        for(int j=1;j<=cnt;j++)
        {
            re=0;
            u=sta[i];//第i组元素取一个
            for(int k=0;k<m[j].size();k++)
            {
                v=m[j][k];
                if((u&v)==0) ++re;//不互相冲突则可以扩展
            }
            trans.m[i][j]=re;//第i组扩展到第j组有re种方式
        }
    return ;
}
int main()
{
    #ifndef ONLINE_JUDGE
    freopen("1.in","r",stdin);
    #endif
    scanf("%lld%lld",&N,&K);
    int all=(1<<K)-1;
    for(int i=0;i<=all;i++)
    if(judge(i)) add(i);//枚举所有状态，如果合法就尝试加入组中
    pre();//计算able的值
    trans=trans^(N-1);
    ini=ini*trans;
    int ans=0;
    for(int i=1;i<=cnt;i++)
        ans+=ini.m[1][i],ans%=mod;//终态可能是任意一组中的形态，全部统计
    printf("%d",ans);
    return 0;
}
```  
### $\texttt{关于卡常}$
提一句，这题理论计算量已经T了，开了 $2.0s$ 以及O2优化才勉强能过，如果最后一个 `subtask` 全T了要考虑减小矩乘中的常数，枚举顺序  
```
for(int k=1;k<=N;k++)
    for(int i=1;i<=N;i++)
        for(int j=1;j<=N;j++)
            t.m[i][j]=(t.m[i][j]+x.m[i][k]*y.m[k][j])%mod;
```  
是最优的，原理大概是内存访问比较连续所以会快一些  

$\large\mathsf{End}$

---

## 作者：Semorius (赞：1)

首先分析一下给出的图的形态，限制 $1$ 表示每相邻两层之间对应点之间两两连边，限制 $2$ 和限制 $3$ 表示每一层是一个环，所以整张图可以形象地看成是由 $L$ 个大小为 $x$ 的环上下顺次相连形成的柱状图。

观察数据范围，$L$ 很大但 $x$ 很小，所以可以考虑对每一层做状态压缩，然后利用矩阵快速幂进行层与层之间的转移。对每个环逆时针编号为 $1 \sim x$，设 $s_i$ 表示第 $i$ 层的状态，$s_i$ 二进制下低位开始第 $j$ 位为 $1$ 或 $0$ 表示环上编号为 $j$ 的点选或不选。

先预处理出每层满足独立集的状态，发现当 $x=17$ 时，一共有 $3571$ 种。如果用这些状态转移在矩阵乘法自带的 $O(n^3)$ 复杂度下根本无法通过。那么能否再压缩掉一些状态？

手动模拟发现有些情况其实是本质相同的。

![1](https://cdn.luogu.com.cn/upload/image_hosting/rjhyrh97.png)
![2](https://cdn.luogu.com.cn/upload/image_hosting/ggvnz887.png)

例如上面两个环，忽略编号时，右图中的环可由左图中的环逆时针旋转 $144\degree$ 得到，也就是说，这两个环实际上是本质相同的。

考虑合并这种旋转以后能重合的本质相同的环，再跑一遍发现可用状态只剩下 $211$ 种，算一下复杂度，似乎~~只要常数小~~刚好能过？

然后想压缩掉这些本质相同的状态后如何转移。对于一些本质相同的状态，我们从中选出其中一个作为这些状态的**代表环**，而这个**代表环**是有编号对应的。我们设 $dp_{i,s_j}$ 表示第 $i$ 层的状态为 $s_j$ 且**固定**第 $i$ 层**不动**的方案数。这里**不动**的含义是当前层选的状态与该状态对应的**代表环**严格相同，而第 $1$ 到 $i-1$ 层可整体旋转与之相匹配。当从 $dp_{i-1,s_k}$ 向 $dp_{i,s_j}$ 转移时，记状态 $s_k$ 通过旋转得到的 $x$ 个状态中，与 $s_j$ 构成独立集的状态数有 $cnt_{k,j}$ 种。那么有如下转移：

$$dp_{i,s_j}=\sum dp_{i-1,s_k}\times cnt_{k,j}$$

转化为矩阵，容易发现 $cnt$ 数组即为转移矩阵。

最后统计答案时，对于第 $L$ 层的每一种状态的答案，要乘上该状态里旋转可得的状态个数。（相当于将整张图旋转一定的角度）

注意常数，尽量减少取模，时间复杂度 $O(x \cdot 2^x + 211^3 \cdot \log L)$

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
const ll SIZE = 200005;
const ll mod = 998244353;
ll L, n;
bool mp[150005];
bool mp1[150005];
ll cntm[150005];
ll a[SIZE], id[150005], tot;

inline ll rd(){
	ll f = 1, x = 0;
	char ch = getchar();
	while(ch < '0' || ch > '9'){
		if(ch == '-') f = -1;
		ch = getchar();
	}
	while(ch >= '0' && ch <= '9'){
		x = (x << 1) + (x << 3) + (ch ^ 48);
		ch = getchar();
	}
	return f*x;
}

struct node{
	ll o[212][212];
}zy;

node jl;
node mul(node A, node B){
	for(int i = 0; i <= tot; i++)
		for(int j = 0; j <= tot; j++){
			jl.o[i][j] = 0;
			for(ll k = 0; k <= tot; k++){
				jl.o[i][j] += A.o[i][k] * B.o[k][j] % mod;
			}
			jl.o[i][j] %= mod;
		}
	return jl;	
}

node power(node x, ll y){
	node j2;
	for(int i = 0; i <= tot; i++)
		for(int j = 0; j <= tot; j++)
			j2.o[i][j] = (i==j);
	while(y){
		if(y & 1) j2 = mul(j2, x);
		x = mul(x, x);
		y >>= 1;
	}
	return j2;
}

int main(){
	L = rd(), n = rd();
	for(int i = 0; i < (1<<n); i++){
		ll now = i; bool ff = 0;
		for(ll j = 2; j <= n; j++){
			if((i&(1<<(j-1))) && (i&(1<<(j-2)))){
				ff = 1;
				break;
			}
		}
		if((i&1) && (i&(1<<(n-1)))) ff = 1;
		if(!ff){ //同一个环内满足两两不相邻
			for(ll j = 1; j < n; j++){
				now = ((now&1)<<(n-1))|(now>>1);
				if(mp[now]){
					cntm[id[now]]++;//更新循环意义下相同方案的个数
					ff = 1;
					break;
				}
			}
		}
		if(!ff){//出现一种新的本质不同的环
			cntm[tot+1] = 1; 
			mp[i] = 1;
			a[++tot] = i;
			id[a[tot]] = tot;
		}
	}	
	for(int i = 1; i <= tot; i++){//枚举可能的转移，构造转移矩阵
		for(int j = 1; j <= tot; j++){
			if((a[i]&a[j]) == 0) zy.o[i][j]++;	
			if(a[i] == 0) continue;
			ll now = a[i], st = a[i]; bool ff = 0;
			for(int h = 1; h < n; h++){
				now = ((now&1)<<(n-1))|(now>>1);
				if(ff && now == st) break;
				if((now&a[j]) == 0) zy.o[i][j]++;
				ff = 1;
			}
		}
	}
	node ans = power(zy, L-1);
	ll aans = 0;
	for(int i = 1; i <= tot; i++){
		ll jl = 0;
		for(int j = 1; j <= tot; j++){
			jl = jl + ans.o[j][i];
			if(jl >= mod) jl -= mod;
		}
		jl = jl * cntm[i] % mod; //统计最顶层为状态i的方案数 
		aans = aans + jl;
		if(aans >= mod) aans -= mod;
	}
	printf("%lld", aans);
	return 0;
}
```


---

## 作者：Phobia (赞：0)

首先观察到题目中的 $L$ 很大，而这个东西的计数看着就不是很存在通项公式的亚子，注意到每一层可能的状态仅和上下相邻两层有关，故考虑矩阵快速幂优化 DP。

考虑状压每一层的状态，然后发现 $2^x$ 很大，搞一下就会发现合法的状态很少，仅有 $3571$ 种，然后再搞一下又发现合法状态中的本质不同（即经过旋转后的图形）的数量仅有 $211$ 种~~啊，这是毕业的味道~~，而 $211^3=9393931\approx9\times10^6$ 完全在可接受范围内了。

考虑矩阵仅存储压缩后的状态，转移时枚举当前层合法状态与下一层合法状态，然后就错了，原因是每个转移会多 $\times\text{与改状态同构的状态数量次}$，其实很好理解，就是原本 $A$ 转移到 $B$，现在所有和 $A$ 相似的 $C$ 都转移到了 $B$，而模数又是个质数，于是直接除掉。

然后就暴力矩阵快速幂就行了，时间复杂度 $\Theta\left(211^3\log{L}\right)$。

~~~cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long i64;
typedef __int128 i128;

const int maxn = 3575; 
const int maxs = (1 << 17) + 5;
const int p = 998244353;

i64 l;

int n, tot, tag[maxs], hsh[maxs];

vector<int> sta, id;

struct matrix
{
	int m[215][215];
	matrix operator*(const matrix& rhs) const
	{
		matrix res;
		for (int i = 1; i <= tot; ++i)
		{
			for (int j = 1; j <= tot; ++j)
			{
				i128 now = 0;
				for (int k = 1; k <= tot; ++k)
					now += (i64)m[i][k] * rhs.m[k][j];
				res.m[i][j] = now % p;
			}
		}
		return res;
	}
} U, T;

int read()
{
	int res = 0, ch = getchar();
	for (; !isdigit(ch); ch = getchar())
		;
	for (; isdigit(ch); ch = getchar())
		res = (res << 3) + (res << 1) + (ch & 15);
	return res;
}

int qpow(int x, int y)
{
	int res = 1;
	while (y)
	{
		if (y & 1)
			res = (i64)res * x % p;
		x = (i64)x * x % p;
		y >>= 1; 
	}
	return res;
}

int main()
{
	scanf("%lld%d", &l, &n);
	for (int s = 0; s < 1 << n; ++s)
	{
		if ((s & 1) && (s & 1 << n - 1) || (s & s << 1))
			continue;
		sta.push_back(s);
		if (tag[s])
			id.push_back(tag[s]);
		else
		{
			id.push_back(++tot);
			for (int i = 0; i < n; ++i)
			{
				s = s >> 1 | (s & 1) * (1 << n - 1);
				tag[s] = tot; 
			}
		}
		++hsh[*id.rbegin()];
	}
	for (int i = 0; i < sta.size(); ++i)
	{
		int w = qpow(hsh[id[i]], p - 2);
		for (int j = 0; j < sta.size(); ++j)
		{
			if (sta[i] & sta[j])
				continue;
			T.m[id[i]][id[j]] = (T.m[id[i]][id[j]] + w) % p;
		}
	}
	U.m[1][1] = 1;
	while (l)
	{
		if (l & 1)
			U = U * T;
		T = T * T;
		l >>= 1;
	}
	int ans = 0;
	for (int i = 1; i <= tot; ++i)
		ans = (ans + U.m[1][i]) % p;
	printf("%d\n", ans);
	return 0;
}
~~~

---


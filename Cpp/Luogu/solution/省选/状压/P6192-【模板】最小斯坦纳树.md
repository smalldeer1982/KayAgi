# 【模板】最小斯坦纳树

## 题目描述

给定一个包含 $n$ 个结点和 $m$ 条带权边的无向连通图 $G=(V,E)$。

再给定包含 $k$ 个结点的点集 $S$，选出 $G$ 的子图 $G'=(V',E')$，使得：

1. $S\subseteq V'$；

2. $G'$ 为连通图；

3. $E'$ 中所有边的权值和最小。

你只需要求出 $E'$ 中所有边的权值和。

## 说明/提示

【样例解释】

样例中给出的图如下图所示，红色点为 $S$ 中的元素，红色边为 $E'$ 的元素，此时 $E'$ 中所有边的权值和为 $2+2+3+4=11$，达到最小值。

![](https://cdn.luogu.com.cn/upload/image_hosting/rdu06bwj.png)

---

【数据范围】

对于 $100\%$ 的数据，$1\leq n\leq 100,\ \ 1\leq m\leq 500,\ \ 1\leq k\leq 10,\ \ 1\leq u,v\leq n,\ \ 1\leq w\leq 10^6$。

保证给出的无向图连通，但 **可能** 存在重边和自环。

## 样例 #1

### 输入

```
7 7 4
1 2 3
2 3 2
4 3 9
2 6 2
4 5 3
6 5 2
7 6 4
2 4 7 5
```

### 输出

```
11
```

# 题解

## 作者：ix35 (赞：116)

最小斯坦纳树，就是要花费最小的代价，连通给定的 $k$ 个关键点，这是一个组合优化问题。

这个问题可以用状压 DP 来解决，首先容易发现一个结论：

**答案的子图一定是树。**

证明：如果答案存在环，则删去环上任意一条边，代价变小。

于是我们为这棵树钦定一个树根，设 $dp(i,S)$ 表示以 $i$ 为根的一棵树，包含集合 $S$ 中所有点的最小代价。

考虑如何不重不漏地转移。

一棵以 $i$ 为根的树有两种情况，第一种是 $i$ 的度数为 $1$，另一种是 $i$ 的度数大于 $1$。

对于 $i$ 的度数为 $1$ 的情况，可以考虑枚举树上与 $i$ 相邻的点 $j$，则：

$$dp(j,S)+w(j,i)\to dp(i,S)$$

对于 $i$ 的度数大于 $1$ 的情况，可以划分成几个子树考虑，即：

$$dp(i,T)+dp(i,S-T)\to dp(i,S)\ \ (T\subseteq S)$$

这里的转移顺序是有讲究的，这可以理解成一个类似背包的 DP，与 $i$ 相邻的点是一个个出现的，每次多合并上一个点，所以按 $S$ 升序枚举即可。

这两种转移具体如何实现呢？对于下面一种较为简单，枚举子集即可，时间复杂度为 $O(n\times 3^k)$，因为 $\sum\limits_{S\subseteq\{1,\ldots,n\}} |S|$ 是 $O(3^n)$ 的。

对于上面一种，其实可以想到最短路模型的三角形不等式，对于每个 $S$，将图做一次松弛操作即可。

由于我不喜欢 SPFA，所以这里采用了 dijkstra 实现，这部分时间复杂度为 $O(m\log m\times 2^k)$。

所以总时间复杂度为 $O(n\times 3^k+m\log m\times 2^k)$。


---

## 作者：xyf007 (赞：32)

主要是来提供一种常数较小的写法，讲解部分略去  
考虑最后的 DP 式子分为两部分：
$$ \begin{aligned}f_{i,S}&\gets\min_{T\subseteq S}(f_{i,T}+f_{i,S\setminus T})\\f_{i,S}&\gets f_{j,S}+w(i,j)\end{aligned} $$
大部分人就按照如上形式进行转移，但是这样常数很大，因为 **数组访问不连续**。在第一种转移的时候，内层枚举子集很不连续；在求最短路的时候，同样很不连续。

为了访问连续，一个想法就是交换数组两维。同时在第一种转移的时候，先枚举子集再枚举 $i$，这样数组访问就很连续了；在求最短路时，所有转移都在 $f_{S}$ 中，比之前全部第二维为 $S$ 快多了。  
另一个优化是当 $T<S\setminus T$ 的时候直接 `break`，因为这种情况及其子集已经在之前转移过了。这样可以让你的常数除以 $2$。  
另外如果图比较稀疏，使用 SPFA 可以加快你的平均运行效率，即使出题人将其卡满成 $O(nm)$ 依然不会成为复杂度瓶颈。

经过以上优化的代码可以通过 $n=200,k=14$ 的数据，尽管理论复杂度达到了惊人的 $9\times10^8$。代码如下：
```cpp
template <typename T>
void checkmax(T &x, T y) {
  if (x < y) x = y;
}
template <typename T>
void checkmin(T &x, T y) {
  if (x > y) x = y;
}
int n, m, k, dp[1024][101];
std::vector<std::pair<int, int>> g[101];
bool vis[101];
void Spfa(int S) {
  std::queue<int> q;
  for (int i = 0; i < n; i++)
    if (dp[S][i] != 0x3f3f3f3f) q.emplace(i), vis[i] = true;
  while (!q.empty()) {
    int u = q.front();
    q.pop(), vis[u] = false;
    for (auto &&[v, w] : g[u])
      if (dp[S][u] + w < dp[S][v]) {
        dp[S][v] = dp[S][u] + w;
        if (!vis[v]) q.emplace(v), vis[v] = true;
      }
  }
}
int main(int argc, char const *argv[]) {
  std::ios_base::sync_with_stdio(false);
  std::cin.tie(nullptr), std::cout.tie(nullptr);
  std::cin >> n >> m >> k;
  for (int i = 1; i <= m; i++) {
    int u, v, w;
    std::cin >> u >> v >> w, u--, v--;
    g[u].emplace_back(v, w), g[v].emplace_back(u, w);
  }
  std::memset(dp, 0x3f, sizeof(dp));
  for (int i = 0; i < k; i++) {
    int x;
    std::cin >> x, x--;
    dp[1 << i][x] = 0;
  }
  for (int S = 1; S < (1 << k); S++) {
    for (int T = S & (S - 1); T; T = (T - 1) & S) {
      if (T < (S ^ T)) break;
      for (int i = 0; i < n; i++) checkmin(dp[S][i], dp[T][i] + dp[T ^ S][i]);
    }
    Spfa(S);
  }
  std::cout << *std::min_element(dp[(1 << k) - 1], dp[(1 << k) - 1] + n);
  return 0;
}
```

---

## 作者：WeLikeStudying (赞：24)

- 最小斯坦纳树，同样是让无向图中的某个点连通，但却可以使用一些中间点来帮助连边。
- 这本来是很具有实用性的（从几何中都可以找得出大量直接连边并非最短的例子），可惜是个 $\text{NP-hard}$。
- 当然，非多项式级别的算法也是要讲求效率的，所以就有了这个[模板](https://www.luogu.com.cn/problem/P6192)。
- 不过据说如果给定的点集在欧几里得平面（就是给定欧几里得平面上几个点，要让它们连通，可以选择的中转点是整个欧几里得平面内的所有点，连接任意两点的边权是其欧几里得距离）的话，也是存在着比较优秀的做法的，[link](https://link.springer.com/article/10.1007/BF01758756)，有兴趣的可以买下这篇论文看一下，比较贵，而且访问好像还要科学上网~~科学上网是违法的~~。
- 该算法中，整个图的点数 $n\le 100$，边数 $m\le 500$，但要求的点集 $k\le 10$。

**分析**
- 最朴素的想法当然是枚举点集跑最小生成树了，复杂度是 $O(m\lg m+2^nm\alpha(n))$ ~~绝对不可能跑过好吧。~~
- 但枚举要求的点的子集还是可以做到的，考虑使用状态压缩动态规划来求解，但怎么状态压缩还是个不太好想的事。
- 实际上是利用~~斯坦纳树啊它显然是一棵树~~（因为边都是非负的）的形式。
- 指定一个点作为根节点，然后思考怎么转移……
- 即设 $dp(i,S)$ 为以 $i$ 为根的子树中连着关键节点的集合为 $S$ 的树权值和的最小值。
- 如果 $i$ 的度为 $1$，那可以删掉节点 $i$，找一个相邻的节点 $j$ 代替，也就是：
$$f(i,S)\leftarrow f(j,S)+w(i,j)$$
- 如果 $i$ 的度不为 $1$，那么分成两个集合考虑，$S$ 的一个划分 $A,B$，所以有：
$$f(i,S)\leftarrow f(i,A)+f(i,B)$$
- 对于第二个转移，可以使用枚举子集的方法，由这个式子：
$$\sum_{i=0}^nC(n,i)2^i=3^n$$
- 我们可以得出复杂度是 $O(n3^k)$。
- 对于第一个转移，简单来说我们就是整张图进行松弛操作，所以我们可以使用一个和单源最短路类似的操作，可以理解成将 $f(i,S)$ 赋值为点 $i$ 的 $dis$ 跑最短路，我们直接上堆优化。
- 所以总的复杂度是 $O(n3^k+m\lg m2^k)$，可以通过此题。
- 作者感觉这个做法是很妙的，因为尤其是第一个转移，以 $i$ 为根的子树，$i$ 如果度数为 $1$，那么如果不是关键节点，为啥要出现呢？其实这是对我们的目标：最小斯坦纳树的扩大，变为了它的组成要件。
- 这的确是一个有益的启示。

**具体实现**
- 主要是注意这题是无向图需要开双倍边。
- [代码实现](https://www.luogu.com.cn/paste/rws9nn6d)。

---

## 作者：cyffff (赞：21)

[$\text{Link}$](https://www.luogu.com.cn/problem/P6192)
## 题意
给出一张 $n$ 个点，$m$ 条有权边的无向连通图，其中有 $k$ 个点是关键点。求图的一个子图，满足包含了所有 $k$ 个关键点，使得所包含的边集的权值和最小，求这个最小值。

$n\le 100$，$m\le500$，$k\le10$。
## 思路
首先，我们要知道答案子图是一颗树，因为如果其上有个环，可以断开环上任意一条边，点集不会变化但答案会变小。

考虑状压 $\text {dp}$，设 $dp_{i,S}$ 表示以 $i$ 为根的答案中包含了关键点集合 $S$ 时的答案。

有两种情况：$i$ 的度为 $1$ 或大于 $1$。

- 若 $i$ 的度数为 $1$

考虑其与 $j$ 相连，则有转移
$$dp_{j,S}+w_{(i,j)}\to dp_{i,S}$$
再考虑用 $j$ 更新 $i$，可以考虑使用最短路算法，用 $dp_{j,S}$ 更新所有 $dp_{i,S}$，再用被更新的继续更新其它值。
$$dp_{j,S}+dis_{i,j}\to dp_{i,S}$$
这部分时间复杂度是 $O(2^k\times nm)$ 的。

- 若 $i$ 的度数大于 $1$

考虑 $i$ 可以划分成两个子集之并，枚举 $S$ 的子集，用它与其补集的答案之和更新 $dp_{i,S}$，即
$$dp_{i,S}\gets dp_{i,T},dp_{i,S\backslash T}$$
这里简单说明一下枚举子集的时间复杂度：

$$\begin{aligned}\sum_{S⊆\{1,2\dots n\}}2^{|S|}&=\sum_{k=0}^n2^k\sum_{S⊆\{1,2\dots n\}}[|S|=k]\\
&=\sum_{k=0}^n2^k\binom{n}{k}\\
&=\sum_{k=0}^{n}2^{k}1^{n-k}\binom{n}{k}\\
&=3^n\\
\end{aligned}$$

所以这部分时间复杂度是 $O(n\times 3^k)$ 的。

总时间复杂度就是 $O(n\times 3^k+nm\times 2^k)$ 的，这里用 $\text{SPFA}$ 比 $\text{Dijkstra}$ 快很多。

另外，满足题目要求的树为斯坦纳树，这个算法构建出来的树被称为最小斯坦纳树。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
namespace IO{//by cyffff
	
}
const int N=100+10,K=10;
int n,m,k,p[N],up;
int cnt,head[N];
int dp[N][1<<K];
struct Edge{
	int to,nxt,w;
}a[N*10];
inline void add(int u,int v,int w){
	cnt++;
	a[cnt].to=v;
	a[cnt].w=w;
	a[cnt].nxt=head[u];
	head[u]=cnt;
}
queue<int>q;
bool vis[N];
inline void SPFA(int s){
	while(!q.empty()){
		int rt=q.front();
		q.pop();
		vis[rt]=0;
		for(int i=head[rt];i;i=a[i].nxt){
			int t=a[i].to;
			if(dp[t][s]>dp[rt][s]+a[i].w){
				dp[t][s]=dp[rt][s]+a[i].w;
				if(!vis[t])
					q.push(t),vis[t]=1;
			}
		}
	}
}
int main(){
	memset(dp,127/3,sizeof(dp));
	n=read(),m=read(),k=read();
	for(int i=1;i<=m;i++){
		int u=read(),v=read(),w=read();
		add(u,v,w),add(v,u,w); 
	}
	for(int i=1;i<=k;i++){
		p[i]=read();
		dp[p[i]][1<<i-1]=0;
	}
	up=(1<<k)-1;
	for(int s1=0;s1<=up;s1++){
		for(int i=1;i<=n;i++){
			for(int s2=s1&s1-1;s2;s2=s2-1&s1)
				dp[i][s1]=min(dp[i][s1],dp[i][s2]+dp[i][s1^s2]);
			if(dp[i][s1]<1e9)
				q.push(i),vis[i]=1;
		}
		SPFA(s1);
	} 
	write(dp[p[1]][up]);
	flush();
}
```
再见 qwq~

---

## 作者：skydogli (赞：14)

~~模拟赛考了一手板子，瞬间暴毙~~

这个东西解决的问题：一个有权的无向图上有k个关键点，求联通k个关键点最小的代价。

因为直接钦定了k个关键点，所以只能上状压，k也通常不会很大。

思路：

先Floyd求出任意两点之间的最短路。

用$f_{st,i}$表示将集合st的关键点全部联通的最小花费，有2种转移。

- $st'\in st ,f_{st',j}+f_{st-st',j}\rightarrow f_{st,j}$


- $f_{st,i}=f_{st,j}+\operatorname{dis}_{i,j}$

~~正确性显然，且可以证明能找到最优解~~


枚举状态，然后每个状态跑最短路即可。为了方便可以用$O(n^2)$的Dijstra,总复杂度$O(3^k+2^kn^2+n^3)$

模板代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define MN 105
int n,m,k,vis[MN];
int f[1<<10][MN];
int G[MN][MN];
bool chk(int x){
	for(int i=0;i<k;i+=2)
		if(((x>>i)&1)!=((x>>i+1)&1))return 0;
	return 1;
}
void work(int x){
	for(int i=1;i<=n;++i)vis[i]=0;
	for(int i=1;i<=n;++i){
		int p=0;
		for(int i=1;i<=n;++i)
			if(!vis[i]&&(!p||f[x][i]<f[x][p]))p=i;
		if(f[x][p]>1e9) return;
		vis[p]=1;
		for(int i=1;i<=n;++i)
			f[x][i]=min(f[x][i],f[x][p]+G[i][p]);
	}
}
int id[MN];
int main(){
	scanf("%d%d%d",&n,&m,&k);
	memset(G,0x3f,sizeof(G));
	memset(f,0x3f,sizeof(f));
	for(int i=1;i<=n;++i)G[i][i]=0;
	for(int i=1;i<=m;++i){
		int u,v,w;
		scanf("%d%d%d",&u,&v,&w);
		if(G[u][v]>w)G[u][v]=G[v][u]=w;
	}
	for(int i=1;i<=k;++i){
		scanf("%d",&id[i]);
	}
	for(int k=1;k<=n;++k)
		for(int i=1;i<=n;++i)
			for(int j=1;j<=n;++j)
				G[i][j]=min(G[i][j],G[i][k]+G[k][j]);
	for(int i=1;i<(1<<k);++i){
		for(int j=i;j;j=(j-1)&i){
			for(int k=1;k<=n;++k){
				if(f[j][k]<1e9)f[i][k]=min(f[i][k],f[j][k]+f[i-j][k]);
			}
		}//枚举子集
		if(!(i&(i-1)))for(int j=0;j<k;++j)if(i&(1<<j)){f[i][id[j+1]]=0;break;}
		work(i);//求最短路
	}
	int mn=1e9;
	for(int i=1;i<=n;++i)mn=min(mn,f[(1<<k)-1][i]);
	printf("%d\n",mn);
	return 0;
}

```

---

## 作者：hzx360 (赞：7)

各位大佬已经讲的很明白了，但我觉得还有一些细节的地方让我们思考思考的。

状态设计：$dp_{i,S}$ 以 $i$ 为根，树中关键点集合为 $S$ 的最小值。

#### 转移

1) 树根度数不为 $1$ ，考虑拆分成两个子集 $S1 , S2$ ，满足 $S1 \cap S2 = S$ 且 $S1 \cup S2 = \varnothing$ :

$$ dp_{i,S} \gets dp_{i,S1}+dp_{i,S2} $$

**Tip：需要注意枚举子集的办法。**

------------

2) 树根 $i$ 度数为 $1$ :

$$ dp_{i,S} \gets dp_{j,s}+w_{i,j} $$

**Tip：这里是我觉得比较有意思的地方，首先看这个式子可以想到最短路的形式，这里可能有几个疑惑的点。**

- 如何最短路：转移 $(1)$ 中 $dp$ 值不为 $\inf$ 的点当作出发点，点权为 $dp_{i,S}$ 。

- 如果 $i$ 不是关键点：因为转移 $(1)$ 中的数据是上一个状态转移来的，有可能状态中不包括一些点，而我们的最小代价可能需要用到这些点，所以这里可以理解成树的扩展。

- 如果 $i$ 点本来就在这个状态的树里：虽然这样转移不合法，但很显然是不优的，所以就算在树里也没关系。

#### Code：
```
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=4e3;
const int inf=2e9;
int n,m,k,p[N],state;
int dp[N][N];
int head[N],to[N],ne[N],w[N],tot;
void add(int x,int y,int z){
	ne[++tot]=head[x];
	to[tot]=y,w[tot]=z;
	head[x]=tot;
}
queue<int>q;
bool vis[N];
void spfa(int s){
	while(!q.empty()){
		int u=q.front();q.pop();
		vis[u]=0;
		for(int i=head[u];i;i=ne[i]){
			int v=to[i];
			if(dp[v][s]>dp[u][s]+w[i]){
				dp[v][s]=dp[u][s]+w[i];
				if(!vis[v]) q.push(v),vis[v]=1;
			}
		}
	}
}
signed main(){
	cin>>n>>m>>k;
	for(int i=1;i<=m;i++){
		int x,y,z;cin>>x>>y>>z;
		add(x,y,z),add(y,x,z);
	}
	state=(1<<k)-1;
	for(int i=1;i<=n;i++) for(int s=0;s<=state;s++) dp[i][s]=inf;
	for(int i=1;i<=k;i++){
		cin>>p[i];
		dp[p[i]][1<<(i-1)]=0;
	}
	for(int s1=1;s1<=state;s1++){
		for(int i=1;i<=n;i++){
			for(int s2=s1&(s1-1);s2;s2=s1&(s2-1)) dp[i][s1]=min(dp[i][s1],dp[i][s2]+dp[i][s1^s2]);//枚举子集 
			if(dp[i][s1]<inf) q.push(i),vis[i]=1;//将这个点看成出发点 
		}
		spfa(s1);
	}
	cout<<dp[p[1]][state];//此时以哪个关键点为根都无所谓，答案是一样的 
}

---

## 作者：404Not_Found (赞：4)

## 题意

给出一张无向带权图 $G=(V,E)$ 和一个关键点集 $S\in V$，找出一张子图 $G'$ 使得 $G'$ 包含所有关键点，并使总权值最小。

## 解法

显然，答案一定是一棵树，并且所有的关键点都是这一棵树的叶子节点。证明是显然的：如果子图中含有环，则将其中一条边删去可以使得答案更优。而叶子节点如果不是关键点，那么将叶子节点删去也会使得答案更优。这棵树被称为斯坦纳树。

斯坦纳树并不能在多项式时间内求解。我们可以使用状态压缩动态规划解决这个问题。

设 $f(i,S)$ 表示当前以 $i$ 为根，使得点集 $S$ 连通所需代价的最小值。我们分情况进行转移：

+ $i$ 的度数为 $1$

那么斯坦纳树只有一个节点与 $i$ 相连，设这个点为 $j$，那么有转移

$$f(i,S) \leftarrow f(j,S)+w(i,j)$$

$w(i,j)$ 为从 $i$ 到 $j$ 的代价

+ $i$ 的度数不为 $1$

此时 $i$ 可以划分为两个子集，考虑枚举 $S$ 的子集 $S_1$，那么有

$$f(i,S) \leftarrow f(i,S_1)+f(i,S-S_1)$$

最后的问题是如何转移。

对于第二种转移即 $i$ 的度数不为一的情况，直接枚举 $S$ 的子集即可。记住枚举子集的复杂度是 $O(3^{|S|})$ 的。

第一种转移比较麻烦。这个式子可以让我们联想到最短路的三角形不等式，最短路转移即可。

一些细节：

边界不用多说，关键点在只包含它的集合是不需要代价的，即 $f(i,\{i\})=0  (i \in S)$。

最后的答案取 $f(i,S)(i \in S)$ 的任意一个都是可以的，因为关键点都是叶子节点。（其实为了保险一般都取 $\min_i f(i,S)$）。

最后，$\rm SPFA$ 比 $\rm Dijkstra$ 要快很多。

总时间复杂度 $O(n \times3^k+nm \times 2^k)$， 用 $\rm Dijsktra$ 转移的话时间复杂度为 $O(n \times 3^k+ m \log m \times 2^k)$。

容易发现 $\rm SPFA$ 并不是时间复杂度的瓶颈，因此斯坦纳树的题一般都可以放心地用 $\rm SPFA$ 去转移。



```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN = 105;
const int MAXM = 505;
const int K = 11;
struct edge{
	int to,nxt,dis;
} e[MAXM<<1];
int head[MAXN],cnt;
inline void add(int u,int v,int w)
{
	e[++cnt].to=v;
	e[cnt].nxt=head[u];
	e[cnt].dis=w;
	head[u]=cnt;
}
int f[MAXN][1<<K],p[K];
int vis[MAXN];
int n,m,k;
queue<int> q;
void SPFA(int S)
{
	while(!q.empty())
	{
		int u=q.front(); q.pop();
		vis[u]=0;
		for(int i=head[u];i;i=e[i].nxt)
		{
			int v=e[i].to;
			if(f[v][S]>f[u][S]+e[i].dis)
			{
				f[v][S]=f[u][S]+e[i].dis;
				if(!vis[v]) q.push(v),vis[v]=1;
			}
		}
	}
}
int main()
{
	scanf("%d%d%d",&n,&m,&k);
	memset(f,0x7f,sizeof(f));
	for(int i=1;i<=m;i++)
	{
		int u,v,w;
		scanf("%d%d%d",&u,&v,&w);
		add(u,v,w); add(v,u,w);
	}
	for(int i=1;i<=k;i++) scanf("%d",&p[i]),f[p[i]][1<<(i-1)]=0;
	for(int S=0;S<(1<<k);S++)
	{
		for(int i=1;i<=n;i++)
		{
			for(int S1=S&(S-1);S1;S1=(S1-1)&S)
				f[i][S]=min(f[i][S],f[i][S1]+f[i][S^S1]);
			if(f[i][S]<=1e9) q.push(i);  
		}
		SPFA(S);
	}
	int ans=1e9;
	for(int i=1;i<=k;i++) ans=min(ans,f[p[i]][(1<<k)-1]);
	printf("%d\n",ans);
	return 0;
}
```

---


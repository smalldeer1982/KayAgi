# 「C.E.L.U-01」门禁

## 题目背景

abruce 有一次去机房去得**比较**早，然后……他在外面等了35分钟……于是，他想到这样一个问题：  
机房的大门锁着，有 $n$ 名学生都需要进来，进来必须要门禁卡。但有些学生会一同前往。一同前往的人中只要有一个人带了门禁卡就会免于被锁在外面的窘境。现在老师终于要发门禁卡了，可是究竟要发多少张呢？

## 题目描述

我们将题目背景中的问题简化。给出 $n$ 个点，以及任意两个点 $i,j$ 之间存在一条无向边的概率 $p_{i,j}$，求图中联通块个数的期望。

## 说明/提示

样例解释1：以下八种情况出现概率都是 $\dfrac{1}{8}$。  
![](https://cdn.luogu.com.cn/upload/image_hosting/u1fkikj5.png)  
连通块的个数分别为 $3,2,2,2,1,1,1,1$。  
所以期望是 $\dfrac{1}{8}\times3+\dfrac{3}{8}\times2+\dfrac{4}{8}\times1=\dfrac{13}{8}=1.625$

|数据编号|$n$|特殊性质|
|:-:|:-:|:-:|
|$1\sim3$|$\le4$|无|
|$4$|$\le8$|$p_{i,j}=0$ 或 $p_{i,j}=1$|
|$5\sim6$|$\le8$|$i\not=j$ 时 $p_{i,j}=0.5$|
|$7\sim8$|$\le8$|无|
|$9\sim10$|$\le11$|无|
|$11\sim12$|$\le14$|无|

## 样例 #1

### 输入

```
3
0 0.5 0.5
0.5 0 0.5
0.5 0.5 0```

### 输出

```
1.625000```

## 样例 #2

### 输入

```
4
0 0.129 0.58 0.37
0.129 0 0.22 0.134
0.58 0.22 0 0.6
0.37 0.134 0.6 0```

### 输出

```
2.143266```

# 题解

## 作者：abruce (赞：19)

这道题有一个简洁的外表，但却有一颗毒瘤的心/xyx（好吧最后发现我想多了）  
我做这道题断断续续花了一个月的时间，改方法 2 次，改方程 3 次，终于做了出来。
还是先来看部分分吧。  
### 8pts  
直接搜索一遍就出来了，统计连通块个数，应该没有难度。  
### 16pts  
由于图中所有边出现的概率都是 $0.5$，所以每一种图出现的概率都是相同的。计算一下每一种图出现了几个连通块就行了。（我不清楚过不过得了，因为我自己没试，应该是可以打表的）  
### 24pts  
暴力枚举每条边出现和不出现时的情况，然后就很好算连通块个数，就可以算出期望了。  
### 64pts  
篇幅较长，如果想看正解可以略过。  

首先，这道题数据范围很小，又是求连通块个数的期望，我们可以考虑把每个点属于哪一个连通块给状压，用 $0$ 表示还没选。但如果你直接暴力枚举状态是什么，既不好转移也容易超时。我们可以选择进行一些优化。  
1. 像 $25$ 这种状态是没有意义的，因为这表示第一个点属于 $2$ 号连通块，第 $2$ 个点属于 $5$ 号连通块。  
2. 像 $221$ 这种状态是没有意义的，因为它与 $112$ 等价，显然后者转移时要方便一些。
3. 像 $101$ 这种状态是没有意义的，因为中间有一个没选的点导致转移出问题。

所以我们得出合法状态的要求，如果这点选了，那它要么和前面某个连通块连在一起，要么自己单独成为一个连通块，且是之前选了多少连通块的数量 $+1$。  
由此，就可以得出如何搜索合法状态的函数了。

接下来我们思考哪些状态之间可以转移。  
经过我的总结，有四种情况不能选：  
1. $100$ 是不能转移到 $111$ 的，因为你无法一次填补两个空缺。  
2. $110$ 是不能转移到 $100$ 的，因为你不能删除一个点。  
3. $110$ 是不能转移到 $121$ 的，因为原来 $1$ 和 $2$ 在同一个连通块里，现在又不在同一个连通块里了。  
4. $1230$ 是不能转移到 $1221$ 的，因为新加入的 $4$ 号点没有与 $2,3$ 连边，而且 $2,3$ 在原来不属于同一个连通块，但现在又属于同一个连通块了。

除此之外，其它的都是可以转移的。  

但你也许会问为什么 $122340$ 会转移到 $122111$，但我可以向你解释，这是可以的。来看下面两张图：  
![](https://cdn.luogu.com.cn/upload/image_hosting/zi4vxr2a.png)  
这就是原图的状态，圆圈内的数表示所属的连通块。  
加入新点后，朝这几个点连边，可以得到：  
![](https://cdn.luogu.com.cn/upload/image_hosting/gziks366.png)  
红色为新点，红边为新边。然后原来的 $1,3,4$ 连通块就被新点连接在了一起，所以是合法的。  
看了上面这两张图，我们就知道怎么转移了。  
我们需要找出需要连接哪几个连通块，每个连通块内至少连一条边（即剪去都不连的情况），不在同一个连通块的一个都不能连，于是转移的代码就出来了。  


总的代码因为影响观感就不放了，如果要看可以到[这里](https://www.luogu.com.cn/record/51789834)  
附：这本来是我打的 std，后来被艹了才写了后面的内容。  
### 80pts  
这个图最后每一种状态（64pts 已提到）都会有若干个互相隔离的连通块，我们可以先求出每一个连通块出现的概率（即减去任意两个点不连通的概率），然后再将这些连通块之间互相隔离的概率乘起来得到最终答案。  
举个例子，假设这是原图（同一个连通块用同种颜色标出）：
![](https://cdn.luogu.com.cn/upload/image_hosting/y8w5t99i.png)  
那么我们可以每一个连通块分一层：  
![](https://cdn.luogu.com.cn/upload/image_hosting/pdj2koym.png)  
通过一个状压DP就可以很快计算出每一种连通块出现的概率，然后在乘上不同连通块没有相连概率就是答案。  
代码因为影响观感就不放了，要看可以在[这里](https://www.luogu.com.cn/record/51789564)   
附：这本来是我打的第二个 std，后来被艹了才写了后面的内容。  
## 100pts  
发现上面那个算法的瓶颈不在 dp 上，而是在搜索上，我们考虑如何优化掉这个不知道什么复杂度的搜索。  
我们现在已经求出一个连通块出现的概率了，考虑如何计算它对于答案的贡献。  
如果它对答案有贡献，那么必然是这个连通块存在且相对于其它连通块独立。所以每一个连通块计算进的答案就是它出现的概率乘上它与其它点都没有相连的概率。  
代码很短： 
```cpp
#include<bits/stdc++.h>
const int maxn=16;
double p[maxn][maxn],f[1<<maxn],ans;
int n;
int main() {
	scanf("%d",&n);
	for(register int i=0; i<n; i++)
		for(register int j=0; j<n; j++)
			scanf("%lf",&p[i][j]);
	f[0]=1;
	for(register int ii=1; ii<(1<<n); ii++) {
		int lst=ii&(-ii);
		f[ii]=1;
		for(register int jj=(ii-1)&ii; jj; jj=(jj-1)&ii) {
			if(!(jj&lst))continue;//我们把最后一个点钦定为新加的点
			double ps=f[jj];
			for(register int i=0; i<n; i++) {
				if(!((1<<i)&(ii^jj)))continue;
				for(register int j=0; j<n; j++)
					if((1<<j)&jj)ps*=1-p[i][j];//如果i在ii中出现且没有在jj出现，然后j在jj中出现，则不能连边 
			}
			f[ii]-=ps;//正难则反计算概率
		}
	}
	for(register int ii=1; ii<(1<<n); ii++) {
		double now=1;
		for(register int i=0; i<n; i++)
			for(register int j=0; j<n; j++)
				if(!((1<<j)&ii)&&((1<<i)&ii))now*=1-p[i][j];//必须相对于其它连通块独立
		ans+=f[ii]*now;
	}
	printf("%.6lf",ans);
	return 0;
}
```

---

## 作者：Sol1 (赞：14)

提供一种~~干爆 std 的~~ $O(3^n)$ 做法。

设 $f_S$ 为 $S$ 中点集构成一个连通块的概率。

则有套路容斥：考虑这个点集不是连通块时，枚举其中一个点所在的连通块，要求这个连通块自己连通，并且和剩余的点之间没有边。

可以得到转移式：

$$f_S=\sum_{T\subset S}f_TF(S\backslash T,T)$$

其中 $F(S,T)$ 是 $S$ 与 $T$ 之间没有边的概率。

暴力计算将得到一个 $O(3^nn^2)$ 的做法。

考虑折半：预处理出 4 个数组 $s_{0/1,0/1}$，分别为：

- 所有 $[0,n/2)$ 中的点的子集 到 所有 $[0,n/2)$ 中的点的子集 之间没有边的概率
- 所有 $[0,n/2)$ 中的点的子集 到 所有 $[n/2,n)$ 中的点的子集 之间没有边的概率
- 所有 $[n/2,n)$ 中的点的子集 到 所有 $[0,n/2)$ 中的点的子集 之间没有边的概率
- 所有 $[n/2,n)$ 中的点的子集 到 所有 $[n/2,n)$ 中的点的子集 之间没有边的概率

这样暴力预处理这 4 个数组的时间是 $O(2^nn^2)$，同时可以通过拆分集合，把对应的 $s$ 相乘来 $O(1)$ 查询 $F(S,T)$。

如此继续暴力执行 DP 即可做到 $O(3^n)$，而且常数很小。这一做法可以推广到类似的状压连通块的题目，且均可以做到 $O(2^nn^2+3^n)$。

实战效果：在目前数据范围下最大的测试点可以比 std 快 20 倍左右。

```cpp
#include <bits/stdc++.h>
using namespace std;

int n, S;
long double s[2][2][1<<7][1<<7], dp[1<<14], p[14][14];

inline void Read() {
	cin >> n;
	for (int i = 0;i < n;i++) {
		for (int j = 0;j < n;j++) cin >> p[i][j];
	}
}

inline void Prefix() {
	S = (n + 1) / 2;
	for (int f1 = 0;f1 < 2;f1++) {
		for (int f2 = 0;f2 < 2;f2++) {
			for (int i = 0;i < (1 << S);i++) {
				for (int j = 0;j < (1 << S);j++) {
					s[f1][f2][i][j] = 1;
					for (int k = 0;k < S;k++) {
						for (int l = 0;l < S;l++) {
							if (((i >> k) & 1) && ((j >> l) & 1)) s[f1][f2][i][j] *= 1 - p[k + f1 * S][l + f2 * S];
						}
					}
				}
			}
		}
	}
}


inline long double Query(int s1, int s2) {
	return s[1][1][s1 >> S][s2 >> S] * s[1][0][s1 >> S][s2 & ((1 << S) - 1)] * s[0][1][s1 & ((1 << S) - 1)][s2 >> S] * s[0][0][s1 & ((1 << S) - 1)][s2 & ((1 << S) - 1)];
}

inline void Solve() {
	for (int i = 1;i < (1 << n);i++) {
		dp[i] = 1;
		int t = i ^ (i & -i);
		for (int j = t;j;j = (j - 1) & t) dp[i] -= dp[i ^ j] * Query(i ^ j, j);
	}
	long double ans = 0;
	for (int i = 1;i < (1 << n);i++) ans += dp[i] * Query(i, ((1 << n) - 1) ^ i);
	cout << fixed << setprecision(11) << ans << endl;
}

int main() {
	Read();
	Prefix();
	Solve();
	return 0;
}
```

---

## 作者：Harry27182 (赞：4)

数据范围很小，可以很自然地想到状压 dp。

我们考虑一个比较套路的状态设计（我第一次学），设 $f_s$ 表示 $s$ 中的点内部相互连通的概率。

下面考虑如何 dp。我们发现很难由已知状态转移到当前状态，所以正难则反吗，考虑容斥，我们处理 $s$ 集合内部不连通的概率，考虑钦定一个元素让 $s$ 的子集 $t$ 一定包含，那么可以有转移式：

$$f_s=1-\sum_{t} f_{t}\times P(s\oplus t,t)$$

其中  $P(s\oplus t,t)$ 表示这两个集合之间互不连通的概率。

稍微手模一下可以发现钦定一个元素可以让转移做到不重不漏，这里我们钦定了编号最小的元素，方便代码实现。

于是我们得到了一个 $O(3^n\times n^2)$ 的 dp，已经可以通过本题。

考虑进一步优化，我们发现 $3^n$ 的枚举子集是无法优化的，所以需要考虑优化转移过程，可以比较自然的想到预处理 $P(s\oplus t,t)$。

直接处理显然是 $4^n\times n^2$ 的，所以我们发挥人类智慧，考虑 ```meet in middle```。

分前 $\frac {n}{2}$ 和后 $\frac {n}{2}$ 来处理，如果两个集合 $s$ 与 $t$ ，它们的：

- $s$ 的前 $\frac {n}{2}$ 与 $t$ 的前 $\frac {n}{2}$ 不连通

- $s$ 的前 $\frac {n}{2}$ 与 $t$ 的后 $\frac {n}{2}$ 不连通

- $s$ 的后 $\frac {n}{2}$ 与 $t$ 的前 $\frac {n}{2}$ 不连通

- $s$ 的后 $\frac {n}{2}$ 与 $t$ 的后 $\frac {n}{2}$ 不连通

他们就是不连通的。

所以我们可以在 $2^n\times n^2$ 的时间内预处理，时间复杂度为 $O(2^n\times n^2+3^n)$。

实现细节可以参考代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;double p[20][20],g[2][2][1005][1005],f[1000005],ans;
double get(int i,int j){return g[0][0][i&((1<<m)-1)][j&((1<<m)-1)]*g[1][0][i>>m][j&((1<<m)-1)]*g[0][1][i&((1<<m)-1)][j>>m]*g[1][1][i>>m][j>>m];}
int main()
{
	scanf("%d",&n);
	for(int i=0;i<n;i++)
	{
		for(int j=0;j<n;j++)scanf("%lf",&p[i][j]);
	} 
	m=(n+1)>>1;
	for(int p1=0;p1<2;p1++)
	{
		for(int p2=0;p2<2;p2++)
		{
			for(int i=0;i<(1<<m);i++)
			{
				for(int j=0;j<(1<<m);j++)
				{
					g[p1][p2][i][j]=1;
					for(int k=0;k<m;k++)
					{
						for(int l=0;l<m;l++)
						{
							if((i&(1<<k))&&(j&(1<<l)))
							{
								g[p1][p2][i][j]*=1-p[k+p1*m][l+p2*m];
							}
						}
					}
				}
			}
		}
	}
	for(int s=1;s<(1<<n);s++)
	{
		int now=s^(s&(-s));
		f[s]=1;
		for(int t=now;t;t=now&(t-1))f[s]-=f[s^t]*get(t,s^t);
	}
	for(int i=1;i<(1<<n);i++)ans+=f[i]*get(i,((1<<n)-1)^i);
	printf("%.6lf",ans);
	return 0;
}
```

---

## 作者：IIIIIlIIIl (赞：2)

提供一种新的从 $O(3^nn^2)$ 优化到 $O(3^n)$ 的方法，思路来源于机房大佬。

朴素的dp还是一样的：

$$ans=\sum \limits_{S=1}^{2^n-1} f(S)g(S) $$

其中 $f(S)$ 表示状态 $S$ 的中的点集构成连通块的概率，$g(S)$ 表示 $S$ 中的点集构成的连通块与外部割裂的概率。

但是发现 $f(S)$ 不好直接算，我们钦定 $S$ 中编号最小的点为关键点，可以直接 $lowbit$ 计算，令 $x$ 为 $S$ 中关键点，考虑容斥:

$$f(S)=\sum \limits_{T\subset S \& x\subset T} f(T)\times E(S\setminus T,T)$$

其中 $E(X,Y)$ 表示 $X$ 中的点与 $Y$ 中的点割裂的概率,$O(n^2)$ 求这个 $E$ 是很容易的，此时dp的复杂度为 $O(3^nn^2)$，考虑预处理出 $P_{i,S}$ 表示点 $i$ 与集合 $S$ 中的点全部割裂的概率，时间复杂度 $O(2^nn)$。

下来就是神奇的部分了，考虑改变枚举方式：

$$f(S\cup T)=\sum \limits_{x\subset S\& S \cap T=\emptyset} f(S)\times E(S,T)$$

我们枚举 $S$，因为关键点在 $S$ 中，那么 $T$ 不能枚举编号比 $x$ 小的点，如果从小到大枚举 $T$，那么转移可以计算 $E$ 可以做到 $O(1)$ 的转移：

$$ E(S,T)=E(S,T')\times P_{y,S} $$

$$ T'=T-\operatorname{lowbit}(T) $$

其中 $y$ 表示 $T$ 中编号最小的点，此时计算 $E$ 的复杂度从 $O(n^2)$ 减少到了 $O(1)$，总复杂度为 $O(3^N)$。

最后附上代码~~有点丑陋~~：

```cpp
#include<bits/stdc++.h>

const int maxn=20;
const int maxm=(1<<18)+5;

int n,lg[maxm];
double a[maxn][maxn],f[maxm],g[maxm],ans;
double t1[maxn][maxm],p[maxm];

int lowbit(int x){return x&-x;}

double calc(int s){
	double res=1;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			if(i==j)continue;
			if((s&(1<<(i-1)))&&((s&(1<<(j-1)))==0)){
				res=res*(1.0-a[i][j]);
			}
		}
	}
	return res;
}

void work(){
	p[0]=1;
	for(int s=1;s<(1<<n);s++)f[s]=1;
	for(int s=1;s<(1<<n);s++){
		int x=lowbit(s);
		int t=(((1<<n)-1)^s),y=lg[x];
//		memset(p,0,sizeof(p));p[0]=1;
		t=(t>>(y+1));t=(t<<(y+1));
		for(int i=t&(t-1);i;i=(i-1)&t){
			int T=(t^i);
			p[T]=p[T-lowbit(T)]*t1[lg[lowbit(T)]+1][s];
			f[T|s]-=f[s]*p[T];
		}
		if(t!=0){
			p[t]=p[t-lowbit(t)]*t1[lg[lowbit(t)]+1][s];
			f[t|s]-=f[s]*p[t];	
		}
	}
}

void init(){
	for(int i=1;i<=n;i++){
		for(int s=1;s<(1<<n);s++){
			if(s&(1<<(i-1)))continue;
			double res=1;
			for(int k=1;k<=n;k++){
				if(s&(1<<(k-1)))res=res*(1-a[i][k]);
			}
			t1[i][s]=res;
		}
	}
}

int main(){
	scanf("%d",&n);
	for(int i=2;i<maxm;i++)lg[i]=lg[i>>1]+1;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			scanf("%lf",&a[i][j]);
		}
	}
	init();
	for(int s=1;s<(1<<n);s++)g[s]=calc(s);
	work();
	for(int s=1;s<(1<<n);s++)ans+=g[s]*f[s];
	printf("%lf",ans);
	return 0;
}

```

模拟赛出了这道题，场上只会指数级枚举边的暴力...

---

## 作者：daniEl_lElE (赞：1)

一个很经典的问题是一个子集连。见 P5933。

然后考虑期望的线性性，计算一个子集是极大连通块的概率。也就是子集内与子集外无边。这是容易计算的。

如果预处理出所有 $S,T$ 满足 $S\cap T=\emptyset$，$S,T$ 完全不连通的概率，复杂度是 $O(3^n)$ 的。本人这里写的是 $O(3^nn^2)$。

```cpp
#include <bits/stdc++.h>
#define int long long
#define double long double
using namespace std;
double f[65536];
double g[20][20];
signed main(){
	int n; cin>>n;
	double ans=0;
	for(int i=1;i<=n;i++) for(int j=1;j<=n;j++) cin>>g[i][j];
	for(int i=1;i<(1<<n);i++){
		int p=(i&(-i)),sta=i^p;
		f[i]=1;
		if(sta) for(int j=(sta-1)&sta;;j=(j-1)&sta){
			double mul=1;
			for(int k=1;k<=n;k++){
				if((i>>(k-1))&1){
					if(((j|p)>>(k-1))&1){
						for(int l=1;l<=n;l++){
							if((i>>(l-1))&1){
								if(!(((j|p)>>(l-1)&1))){
									mul*=(1-g[k][l]);
								}
							}
						}
					} 
				}
			}
			f[i]-=f[j|p]*mul;
			if(!j) break;
		}
		double mul=1;
		for(int k=1;k<=n;k++){
			if((i>>(k-1))&1){
				for(int l=1;l<=n;l++){
					if(!((i>>(l-1))&1)){
						mul*=(1-g[k][l]);
					}
				}
			}
		}
		ans+=f[i]*mul;
	}
	cout<<fixed<<setprecision(10)<<ans;
	return 0;
}

```

---

## 作者：MiniLong (赞：0)

##### P7105

[题目链接](https://www.luogu.com.cn/problem/P7105)

​	设 $f_i$ 为状态 $i$ 集合的点的答案，$g_i$ 是 $i$ 组成连通块的概率，$q_{i,j}$ 为 $i$ 向集合 $j$ 没有 1 条边概率。有 $f_i = \sum\limits_{j\subseteq i,lowbit(i)\in j}  (\prod\limits_{k\in j} q_{k,{C_i}^j}) g_j (f_{{C_i}^j} + 1),g_i = 1 - \sum\limits_{j\subset i,lowbit(i) \in j} (\prod\limits_{k\in j} q_{k,{C_i}^j})g_j$。就是枚举最后一个连通块，$g$ 是通过容斥得到。复杂度 $\Theta(3^n n + 2^n n^2)$。当然可以使用折半的技巧优化到 $\Theta(3^n+2^n n^2)$，但是没必要。

---


# [集训队互测 2012] calc

## 题目描述

一个序列 $a_1,a_2,\dots,a_n$ 是合法的，当且仅当：

- $a_1,a_2,\dots,a_n$ 都是 $[1,k]$ 中的整数。
- $a_1,a_2,\dots,a_n$ 互不相等。

一个序列的值定义为它里面所有数的乘积，即 $a_1\times a_2\times\dots\times a_n$。

求所有不同合法序列的值的和对 $p$ 取模后的结果。两个序列不同当且仅当他们任意一位不同。

## 说明/提示

【数据范围】

对于 $5\%$ 的数据，$k \le 10$，$n \le 10$。

对于 $20\%$ 的数据，$k \le 1000$，$n \le 20$。

对于 $50\%$ 的数据，$k \le 10^9$，$n \le 20$。

对于 $100\%$ 的数据，$k \le 10 ^ 9$，$n \le 500$，$p \le 10 ^ 9$，保证 $p$ 为素数，保证 $n + 1 < k < p$。

by WJMZBMR
****
$\mathsf i \color{red}\mathsf{ostream}$ 觉得这题数据太弱了，于是他造了个[加强版](https://www.luogu.com.cn/problem/P5850)

## 样例 #1

### 输入

```
9 7 10007```

### 输出

```
3611```

# 题解

## 作者：GKxx (赞：46)

本蒟蒻第一次做这种亦可赛艇的DP优化...

真是妙不可言啊

首先我们有一个暴力的DP：$f(i,j)$表示前$i$个数取值域范围$[1,j]$的所有不同合法序列的值之和。但是这样转移并不方便。我们可以只考虑递增的序列，考虑第$i$个数取不取$j$，于是有转移

$$f(i,j)=f(i-1,j-1)\times j+f(i,j-1)$$

最后对于每个递增序列都可以任意重排，所以答案是$f(n,A)\times n!$。

这样做的复杂度是$O(nA)$的，并不能通过，需要优化。

首先你要知道一个定理：平面上横坐标不同的任意$n+1$个点可以唯一确定一个次数不高于$n$的多项式$p(x)$，可以使用拉格朗日插值公式来确定：

$$p(x)=\sum\limits_{i=0}^ny_i\prod\limits_{j\neq i}\frac{x-x_j}{x_i-x_j}$$

假设$f(n,i)$是关于$i$的$g(n)$次多项式，我们来推导$g(n)$的表达式。

注意到：如果$p(x)$是$n$次多项式，那么差分$p(x)-p(x-1)$是$n-1$次多项式。证明比较显然。

然后我们发现$f(n,i)$的转移方程里有差分的形式：

$$f(n,i)-f(n,i-1)=f(n-1,i-1)\times i$$

观察这个式子。左边是关于$i$的$g(n)-1$次多项式，右边是关于$i$的$g(n-1)+1$次多项式，于是我们有

$$g(n)-1=g(n-1)+1$$

当$n=0$时显然有

$$g(0)=0$$

不难发现$g(n)$是等差数列，得到$g(n)=2n$

利用数学归纳法直接按照转移方程归纳也可以证明，但我这里是在未知结论的情况下正面推导的。

既然$f(n,i)$是关于$i$的$2n$次多项式，我们就不需要求出$f(n,A)$，只要求出$f(n,1)$到$f(n,2n+1)$，就有了$2n+1$个点，利用拉格朗日插值即可插出$f(n,A)$的值。

直接利用拉格朗日插值公式是$O(n^2)$的，当横坐标是连续的整数的时候可以预处理前缀积和后缀积来优化到$O(n)$，另外就算横坐标不是连续的整数我们也可以用一些玄妙的做法[快速插值](https://www.luogu.org/problemnew/show/P5158)。但是本题$n\leq500$，就随意啦

代码比较简单，就不贴了。

---

## 作者：NaCly_Fish (赞：35)

~~你们啊，搞什么拉格朗日插值，真是 too young，too simple！~~  
提供一种比较优秀的做法。
****  
updated：改为了全程用生成函数推导。

不妨先转换一下题意：  
将 **序列** 变为 **集合**，即将有序化为无序，最后答案乘 $n!$ 就好了。  

对于一个数 $i$，如果选它对乘积的贡献就是 $i$，不选就是 $1$。  
又由于不能有重复的数，所以其生成函数为 $(1+ix)$。  

把它们都乘起来即是 $k$ 固定时，答案的生成函数
$$F(x)=\prod_{i=1}^k(1+ix)$$
用一个取 $\ln$ 的套路，把它们先加起来，之后再 $\exp$：
$$\ln(1+kx)=\int\frac{k}{1+kx}\text dx$$
$$=\int \left( k\sum_{i=0}^\infty(-k)^ix^i\right) \text dx$$
$$=\sum_{i=1}^\infty(-1)^{i-1}\frac{k^i}{i}x^i$$
$$[x^n]\ln F(x)=\frac{(-1)^{n-1}}{n}\sum_{i=1}^ki^n$$
这是一个经典的自然数幂和的形式，考虑列出它的指数型生成函数：
$$G(x)=\sum_{n=0}^\infty\left( \sum_{i=1}^ki^n \right)\frac{x^n}{n!}$$
$$=\sum_{i=1}^k\sum_{n=0}^\infty \frac{i^nx^n}{n!}$$
$$=\sum_{i=1}^k\text e^{ix}$$
等比数列求和得到
$$G(x)=\frac{\text e^{kx}-1}{1-\text e^{-x}}$$
什么，你问常数项为零怎么求逆？分子常数项也是零，同除 $x$ 就好了。   
然后将 $G(x)$ 的系数代入上面的式子
$$[x^n]\ln F(x)=(-1)^{n-1}(n-1)![x^n]G(x)$$  

多项式 $\exp$ 即得 $F(x)$，总时间复杂度 $\Theta(n \log n)$。  
~~然而需要 MTT，非常毒瘤~~  

参考代码：  
```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<cmath>
#include<algorithm>
#define N 2053
#define ll long long
#define reg register
#define add(x,y) (x+y>=p?x+y-p:x+y)
#define dec(x,y) (x<y?x-y+p:x-y)
#define pi 3.141592653589793
using namespace std;

int p;

inline void read(int &x){
    x = 0;
    char c = getchar();
    while(c<'0'||c>'9') c = getchar();
    while(c>='0'&&c<='9'){
        x = (x<<3)+(x<<1)+(c^48);
        c = getchar();
    }
}

void print(int x){
    if(x>9) print(x/10);
    putchar(x%10+'0');  
}

inline int power(int a,int t){
    int res = 1;
    while(t){
        if(t&1) res = (ll)res*a%p;
        a = (ll)a*a%p;
        t >>= 1; 
    }
    return res;
}

struct complex{
    double r,i;
    inline complex(double r=0,double i=0):r(r),i(i){}

    inline complex operator * (const complex& x) const{
        return complex(r*x.r-i*x.i,i*x.r+r*x.i);
    }
    inline complex operator ~ () const{
        return complex(r,-i);
    }
    inline complex operator + (const complex& x) const{
        return complex(r+x.r,i+x.i);
    }
    inline complex operator - (const complex& x) const{
        return complex(r-x.r,i-x.i);
    }
    inline complex operator / (const int& x) const{
        return complex(r/x,i/x);
    }
};

int rev[N],inv[N],fac[N],ifac[N];
complex rt[N];
int siz;

void init(int n){
    int lim = 1;
    while(lim<=n) lim <<= 1,++siz;
    for(reg int i=1;i!=lim;++i) rev[i] = (rev[i>>1]>>1)|((i&1)<<(siz-1));
    inv[1] = 1;
    rt[lim>>1] = complex(1,0);
    for(reg int i=1;i!=(lim>>1);++i) rt[i+(lim>>1)] = complex(cos(pi*i/lim*2),sin(pi*i/lim*2));
    for(reg int i=(lim>>1)-1;i;--i) rt[i] = rt[i<<1];
    for(reg int i=2;i<=lim;++i) inv[i] = (ll)(p-p/i)*inv[p%i]%p;
}

inline int getlen(int n){
    return 1<<(32-__builtin_clz(n));    
}

inline void FFT(complex *f,int type,int lim){
    if(type==-1) reverse(f+1,f+lim);
    static complex a[N],x;
    int shift = siz-__builtin_ctz(lim);
    for(reg int i=0;i!=lim;++i) a[rev[i]>>shift] = f[i];
    for(reg int mid=1;mid!=lim;mid<<=1)
    for(reg int j=0;j!=lim;j+=(mid<<1))
    for(reg int k=0;k!=mid;++k){
        x = a[j|k|mid]*rt[mid|k];
        a[j|k|mid] = a[j|k]-x;
        a[j|k] = a[j|k]+x;
    }
    for(reg int i=0;i!=lim;++i) f[i] = a[i];
    if(type==1) return;
    for(reg int i=0;i!=lim;++i) f[i] = f[i]/lim;
}

void multiply(const int *A,const int *B,int n,int m,int *R,int len){
    static complex f[N],g[N],h[N],q[N];
    register complex t,f0,f1,g0,g1;
    register ll x,y,z;
    int lim = getlen(n+m);
     for(reg int i=0;i!=lim;++i){
        f[i] = complex(A[i]>>15,A[i]&32767);
        g[i] = complex(B[i]>>15,B[i]&32767);
    } 
    FFT(f,1,lim),FFT(g,1,lim);
    for(reg int i=0;i!=lim;++i){
        t = ~f[i?lim-i:0];
        f0 = (f[i]-t)*complex(0,-0.5),f1 = (f[i]+t)*0.5;
        t = ~g[i?lim-i:0];
        g0 = (g[i]-t)*complex(0,-0.5),g1 = (g[i]+t)*0.5;
        h[i] = f1*g1;
        q[i] = f1*g0 + f0*g1 + f0*g0*complex(0,1);
    }
    FFT(h,-1,lim),FFT(q,-1,lim);
    for(reg int i=0;i<=len;++i){
        x = (ll)(h[i].r+0.5)%p<<30;
        y = (ll)(q[i].r+0.5)<<15;
        z = q[i].i+0.5;
        R[i] = (x+y+z)%p;
    }
}

inline void inverse(const int *f,int n,int *R){
    static int g[N],h[N];
    memset(g,0,getlen(n<<1)<<2);
    int lim = 1,top = 0;
    int s[30];
    while(n){
        s[++top] = n;
        n >>= 1;
    }
    g[0] = power(f[0],p-2);
    while(top--){
        n = s[top+1];
        while(lim<=(n<<1)) lim <<= 1;
        memcpy(h,f,(n+1)<<2);
        memset(h+n+1,0,(lim-n)<<2);
        multiply(h,g,n,n,h,n);
        multiply(h,g,n,n,h,n);
        for(reg int i=0;i<=n;++i) g[i] = dec(add(g[i],g[i]),h[i]);
    }
    memcpy(R,g,(n+1)<<2);
}

inline void log(int *f,int n){
    static int g[N];
    inverse(f,n,g);
    for(reg int i=0;i!=n;++i) f[i] = (ll)f[i+1]*(i+1)%p;
    f[n] = 0;
    int lim = getlen(n<<1);
    memset(g+n+1,0,(lim-n)<<2);
    multiply(f,g,n,n,f,n);
    for(reg int i=n;i;--i) f[i] = (ll)f[i-1]*inv[i]%p;
    f[0] = 0;
}

void exp(const int *f,int n,int *R){
    static int g[N],h[N];   
    memset(g,0,getlen(n<<1)<<2);
    int lim = 1,top = 0;
    int s[30];
    while(n){
        s[++top] = n;
        n >>= 1;    
    }
    g[0] = 1;
    while(top--){
        n = s[top+1];
        while(lim<=(n<<1)) lim <<= 1;
        memcpy(h,g,lim<<2);
        log(g,n);
        for(reg int i=0;i<=n;++i) g[i] = dec(f[i],g[i]);
        g[0] = add(g[0],1);
        multiply(g,h,n,n,g,n);
    }
    memcpy(R,g,(n+1)<<2);
}

int n,k;
int F[N],G[N];

int main(){
    read(k),read(n),read(p);
    init(n<<1|1);
    int ans,lim = getlen(n<<1),pw = k;
    ifac[0] = ifac[1] = fac[0] = fac[1] = 1;
    for(reg int i=2;i<=n+1;++i) ifac[i] = fac[i] = (ll)fac[i-1]*i%p;
    ifac[n+1] = power(fac[n+1],p-2);
    for(reg int i=n;i;--i) ifac[i] = (ll)ifac[i+1]*(i+1)%p;
    for(reg int i=0;i<=n;++i){
        F[i] = (ll)pw*ifac[i+1]%p;
        G[i] = (i&1)?p-ifac[i+1]:ifac[i+1];
        pw = (ll)pw*k%p;
    }
    inverse(G,n,G);
    multiply(F,G,n,n,G,n);
    memset(F,0,sizeof(F));
    for(reg int i=1;i<=n;++i){
        F[i] = (ll)fac[i-1]*G[i]%p;
        if((i-1)&1) F[i] = p-F[i];
    }
    exp(F,n,F);
    ans = (ll)F[n]*fac[n]%p;
    printf("%d",ans);
    return 0;   
}
```  
ps：由于求出了 $F_k(x)$ 的生成函数，所以对 $\forall i \le n$ 的答案都可以直接 $\Theta(1)$ 求出

---

## 作者：tkysss (赞：14)

竟然没有人写容斥惹

考虑容斥：
令$s(m) = \sum i^m;$ 

令f[i]表示n==i时的答案：

放第i个，每次选择让一个相同，两个相同，，，j个相同

可以比较艰难地得出：

$f[i] = \sum_{j=1}^{i} (-1)^{j-1} * A_{i-1}^{j-1} * f[i-j]*s(j) ;$

为什么是排列容斥？？

因为每次做的时候不同的顺序是会被分别统计的；

或像candyORZ一样 推一推组合也会推会回来 ；

预处理S(m)自然数幂可以用伯努利数做到K^2;

伯努利数详见：
https://blog.csdn.net/acdreamers/article/details/38929067

https://blog.csdn.net/chhnz/article/details/79307351
```
#include<bits/stdc++.h>
#define ll long long
#define rg register
using namespace std;
const int N=510;
int n,m,mod,C[N][N],A[N][N],B[N],S[N],fac[N],iv[N],pwn[N],f[N]; 
int main(){
	freopen("bzoj2655.in","r",stdin);
	freopen("bzoj2655.out","w",stdout);
	scanf("%d%d%d",&n,&m,&mod);
	for(rg int i=pwn[0]=fac[0]=1;i<=m+1;i++){
		fac[i]=(ll)fac[i-1]*i%mod;
		pwn[i]=(ll)pwn[i-1]*(n+1)%mod;
	}
	iv[1]=1;
	for(rg int i=2;i<=m+1;i++)iv[i]=(ll)(mod-mod/i)*iv[mod%i]%mod;
	for(rg int i=0;i<=m+1;i++)A[i][0]=C[i][0]=1;
	for(rg int i=1;i<=m+1;i++)
	for(rg int j=1;j<=m+1;j++){
		C[i][j] = (C[i-1][j-1] + C[i-1][j])%mod;
		A[i][j] = ((ll)j*A[i-1][j-1]%mod + A[i-1][j])%mod;
	}
	for(rg int i=B[0]=1;i<=m+1;i++){
		for(rg int j=0;j<i;j++){
			B[i] = (B[i] + (ll)C[i+1][j]*B[j]%mod)%mod;
		} 
		B[i] = (mod - (ll)B[i]*iv[i+1]%mod)%mod;
	}
	S[0]=n;
	for(rg int i=1;i<=m;i++){
		for(rg int j=0;j<=i;j++){
			S[i] = (S[i] + (ll)C[i+1][j]*B[j]%mod*pwn[i+1-j]%mod)%mod;
		}
		S[i] = (ll)iv[i+1]*S[i]%mod;
	}
	f[0]=1;
	for(rg int i=1;i<=m;i++){
		for(rg int j=1;j<=i;j++){
			int fg = j&1 ? 1 : -1;
			f[i] = (f[i] + fg * (ll)A[i-1][j-1] * S[j] %mod * f[i-j] %mod)%mod;
		} 
		f[i] = (f[i]+mod)%mod;
	}
	cout<<f[m]<<endl;
	return 0;
}

```


---

## 作者：Log_x (赞：13)

## Solution
- 先统计序列元素递增的贡献和，答案就为 贡献和 $\times n!$。
- 设 $f[i][j]$ 表示前 $i$ 个数选的最大的数 $\le j$ 的贡献和，转移显然为 $f[i][j] = f[i - 1][j - 1] \times j + f[i][j - 1]$，时间复杂度 $O(nA)$。
- 现在我们尝试证明：$f[n][A]$ 可以用一个关于 $A$ 的 $2n + 1$ 次多项式表示。
- 这个转移方程似乎不太好弄，我们先转换一下思路。
- 设 $g[i][j]$ 表示前 $i$ 个数选的最大的数 $= j$ 的贡献和，转移显然为 $g[i][j] = (\sum \limits_{k = 0}^{j - 1} g[i - 1][k]) \times j$，则 $f[n][A] = \sum \limits_{j = 0}^{A} g[n][j]$。
- 若 $g[n][j]$ 可以用一个关于 $j$ 的多项式表示，我们对 $g[n][j]$ 求前缀和实际上使多项式次数 $+1$，因此现在只要证明 $g[n][j]$ 可以用一个 $2n$ 次多项式表示。
- 考虑数学归纳，$n = 0$ 时显然成立，每次转移相当于求前缀和并 $\times j(1 \le j \le A)$，多项式次数增加 $2$，得证。
- 又因为 $f[n][0] = 0$，常数项肯定为 $0$，用 $2n + 1$ 个点即可表示这个多项式。
- 直接暴力拉格朗日插值即可，时间复杂度 $O(n^2)$。

## Code

```cpp
#include <algorithm>
#include <iostream>
#include <cstring>
#include <cstdlib>
#include <cctype>
#include <cstdio>
#include <ctime>
#include <cmath>

template <class T>
inline void read(T &res)
{
	char ch; 
	while (ch = getchar(), !isdigit(ch));
	res = ch ^ 48;
	while (ch = getchar(), isdigit(ch))
		res = res * 10 + ch - 48;
}

const int N = 505;
const int M = 1005;
int A, n, mod, m, y[M], f[N][M];

inline void add(int &x, int y)
{
	x += y;
	x >= mod ? x -= mod : 0;
}

inline int quick_pow(int x, int k)
{
	int res = 1;
	while (k)
	{
		if (k & 1) res = 1ll * res * x % mod;
		x = 1ll * x * x % mod; k >>= 1;
	}
	return res;
}

inline int Lagrange(int x)
{
	if (x >= 1 && x <= m)
		return y[x];

	int res = 0;
	for (int i = 1; i <= m; ++i)
	{
		int p = y[i], q = 1;
		for (int j = 1; j <= m; ++j)
			if (i != j)
			{
				p = 1ll * p * (x - j) % mod;
				q = 1ll * q * (i - j) % mod;
			}
		p < 0 ? p += mod : 0;
		q < 0 ? q += mod : 0;
		res = (res + 1ll * p * quick_pow(q, mod - 2)) % mod;
	}
	return res;
}

int main()
{
	read(A); read(n); read(mod);
	
	int res = 1;
	for (int i = 1; i <= n; ++i)
		res = 1ll * res * i % mod;
	m = n + n + 1;
	for (int j = 0; j <= m; ++j)
		f[0][j] = 1;
	for (int i = 1; i <= n; ++i)
		for (int j = 1; j <= m; ++j)
			f[i][j] = (1ll * f[i - 1][j - 1] * j + f[i][j - 1]) % mod;
	for (int j = 1; j <= m; ++j)
		y[j] = f[n][j];
	std::cout << 1ll * res * Lagrange(A) % mod << std::endl;
}
```

---

## 作者：Rainybunny (赞：12)

### 题意简述

&emsp;&emsp;[link](https://www.luogu.com.cn/problem/P4463).

&emsp;&emsp;给定 $k,n,p$，求：
$$
\sum_{\{a_n\}}\left[(\forall i)\left(a_i\in[1,k]\right)\right]\left[(\forall i\not=j)\left(a_i\not=a_j\right)\right]\prod_{i=1}^n a_i\bmod p
$$

### 数据规模

&emsp;&emsp;$n\le500;~n+1<k<p\le10^9$。

### Solution

#### Step 1

&emsp;&emsp;有一个比较 naive 的 DP：令 $f(i,j)$ 表示前 $i$ 个元素取值在 $[1,j]$ 之间，构成的**单增序列**的值（即$\prod_{t=1}^ia_t$）之和。易有：
$$
f(i,j)=j\cdot f(i-1,j-1)+f(i,j-1)
$$
&emsp;&emsp;那么答案为：
$$
ans=n!f(n,k)
$$
&emsp;&emsp;复杂度 $O(nk)$，不可过。

#### Step 2

&emsp;&emsp;接下来，~~结合本文的主题，~~我们将会证明，**当 $n$ 为常数，$f(n,x)$ 是关于 $x$ 的 $2n+1$ 次的函数**。

##### 证明

&emsp;&emsp;差分 $f(i)$，令 $g(i,j)=f(i,j)-f(i,j-1)$。结合原题，有转移：
$$
g(i,j)=j\sum_{t=0}^{j-1}g(i-1,t)
$$
&emsp;&emsp;同时，有：
$$
f(i,j)=\sum_{t=0}^jg(i,j)
$$
&emsp;&emsp;由于对函数 $f(i)$ 差分相当于将其次数 $-1$（最高次展开后抵消）。故只需证 $g(n,x)$ 是关于 $x$ 的 $2n$ 次函数。

&emsp;&emsp;考虑归纳：

- $1).$ 当 $n=0$ 时，$g(n,x)=[x=0]$，成立。

- $2).$ 当 $n=m$ 时成立，考察 $n=m+1$ 的情况：
    $$
    g(m+1,x)=x\sum_{t=0}^{x-1}g(m,t)
    $$
    &emsp;&emsp;求前缀和，次数 $+1$，再带上系数 $x$，次数总共 $+2$。由于 $n=m$ 是次数为 $2m$，故 $n=m+1$ 时次数为 $2m+2=2(m+1)$。

    &emsp;&emsp;由 $1).~2).$ $g(n,x)$ 是关于 $x$ 的 $2n$ 次函数得证，故有 $f(n,x)$ 是关于 $x$ 的 $2n+1$ 次函数，证毕。



&emsp;&emsp;由此，对于 $k\le2n+1$ 的情况，我们直接 DP 得出答案；否则只需要 DP 出 $f(n,1..2n+1)$ 的值，然后利用 Lagrange 插值法求出已被形如 $\left(x,f(n,x)\right)$ 的 $2n+1$ 个点唯一确定的 $2n+1$ 次函数，最后代入 $x=k$ 求得答案即可。

&emsp;&emsp;复杂度 $O(n^2)$。

#### 代码

```cpp
#include <cstdio>

const int MAXN = 500;
int n, k, p, x[MAXN + 5], f[MAXN + 5][MAXN * 2 + 5];

inline int qkpow ( int a, int b ) {
	int ret = 1;
	for ( ; b; a = 1ll * a * a % p, b >>= 1 ) ret = 1ll * ret * ( b & 1 ? a : 1 ) % p;
	return ret;
}

inline int lagrange ( const int n, const int* x, const int* y, const int k ) {
	int ret = 0;
	for ( int i = 1; i <= n; ++ i ) {
		int num = y[i], den = 1;
		for ( int j = 1; j <= n; ++ j ) {
			if ( i ^ j ) {
				num = 1ll * num * ( k - x[j] + p ) % p;
				den = 1ll * den * ( x[i] - x[j] + p ) % p;
			}
		}
		ret = ( ret + 1ll * num * qkpow ( den, p - 2 ) ) % p;
	}
	return ret;
}

int main () {
	scanf ( "%d %d %d", &k, &n, &p );
	int fac = 1;
	for ( int i = 0; i <= k && i <= ( n << 1 | 1 ); ++ i ) f[0][i] = 1;
	for ( int i = 1; i <= n; fac = 1ll * fac * i ++ % p ) {
		for ( int j = 1; j <= k && j <= ( n << 1 | 1 ); ++ j ) {
			f[i][j] = ( 1ll * j * f[i - 1][j - 1] + f[i][j - 1] ) % p;
		}
	}
	if ( k <= ( n << 1 | 1 ) ) return printf ( "%d\n", int ( 1ll * fac * f[n][k] % p ) ), 0;
	for ( int i = 1; i <= ( n << 1 | 1 ); ++ i ) x[i] = i;
	return printf ( "%d\n", int ( 1ll * fac * lagrange ( n << 1 | 1, x, f[n], k ) % p ) ), 0;
}
```


---

## 作者：Prean (赞：9)

题意很明确。

考虑一个 $\rm DP$。由于限制了互不相同，那么我们考虑从值域开始想。

设 $dp_{n,k}$ 为在 $[1,n]$ 中选了 $k$ 个数的权值之和。

容易得到有：
$$dp_{n,k}=\sum_{i=1}^{n-1}dp_{i,k-1} \times n \times (N-k+1)$$
很明显考虑 $0$ 肯定也没有问题。

接下来开始生成函数：
$$F_k(x)=\sum_{i=0}^{\infty}dp_{i,k}x^i$$
首先这个 $N-k+1$ 肯定能放到最后去乘上一个阶乘，于是就变成了计算
$$dp_{n,k}=\sum_{i=0}^{n-1}dp_{i,k-1} \times n$$
用 GF 来写的话，因为 $n$ 的存在，考虑求导：
$$F_k(x)=x(\frac {xF_{k-1}(x)}{1-x})'$$

然后我们有边界条件 $F_0(x)=1$，答案是 $[x^n]\frac {F_k(x)}{1-x}$。

注意到 $F_k(x)$ 一定是类似 $\frac {G(x)}{(1-x)^y}$ 之类的，所以考虑递推 $F_k(x)$。

根据 $F_k(x)=x(\frac {xF_k(x)}{1-x})'$，我们直接保存 $F_k(x)=\frac {H(x)}{(1-x)^y}$，然后暴力计算多项式乘法，除法求导利用 $(\frac {F(x)}{G(x)})'=\frac {F'(x)G(x)-F(x)G'(x)}{G^2(x)}$ 即可。

具体来说，计算这个东西：
$$(\frac {F(x)}{(1-x)^y})'$$
我们知道 $(F^k(x))'=kF^{k-1}(x)F'(x)$：
$$\frac {F'(x)(1-x)^y+yF(x)(1-x)^{y-1}}{(1-x)^{2y}}$$
$$\frac {F'(x)(1-x)+yF(x)}{(1-x)^{y+1}}$$
答案是类似 $\frac {F(x)}{(1-x)^{k+1}}$ 的形式，我们又知道 $\frac 1 {(1-x)^{k+1}}=\sum_{i=0}^{\infty}\binom {i+k}ix^i$，直接卷就好了。

瓶颈在递推，复杂度 $O(k^2)$。

别忘记最后要乘上一个阶乘。
```cpp
#include<cstdio>
typedef unsigned ui;
const ui M=505;
ui n,k,mod,f[M<<1],C[M<<1];
inline ui pow(ui a,ui b){
	ui ans(1);for(a%=mod;b;b>>=1,a=1ull*a*a%mod)if(b&1)ans=1ull*ans*a%mod;return ans;
}
signed main(){
	ui i,j,inx,ans(0);scanf("%u%u%u",&k,&n,&mod);C[inx=2*n+1>k?k:2*n+1]=f[0]=1;
	for(i=1;i<=n;f[1]=f[0],f[0]=0,++i)for(j=i*2;j>=2;--j)f[j]=(1ull*f[j-1]*j+f[j-2]*(2ull*i-j))%mod;
	if(inx==2*n+1)for(i=1;i<=2*n;++i)C[inx]=1ull*C[inx]*(k-i)%mod*pow(i,mod-2)%mod;
	for(i=inx-1;i<=2*n;--i)C[i]=C[i+1]*(k+2ull*n-i)%mod*pow(k-i,mod-2)%mod;
	for(i=0;i<=n*2;++i)ans=(ans+1ull*C[i]*f[i])%mod;for(i=1;i<=n;++i)ans=1ull*ans*i%mod;
	printf("%u",ans);
}
```

---

## 作者：81179332_ (赞：5)

不妨先算出数列从小到大排序后的答案，再乘上 $n!$ 即为最终答案

设 $f_i(j)$ 表示前 $i$ 个数，选择的最大的数不超过 $j$ 的答案，则最终答案为 $n!\cdot f_n(k)$

容易写出转移方程：$f_i(j)=j\cdot f_{i-1}(j-1)+f_i(j)$

复杂度是 $O(nk)$ 的

设 $g_i(j)=f_i(j)-f_i(j-1)$，容易看出，$g_i$ 是 $f_i$ 的差分数组，$g_i(j)$ 表示考虑前 $i$ 个数，最大的数为 $j$ 的答案

则对于 $g$ 的转移方程为 $g_i(j)=j\cdot \sum\limits_{k=0}^{j-1}g_{i-1}(k)$

翻译过来即为：$g_i(j)$ 的每一项是 $g_{i-1}$ 的前缀和乘上 $j$，则容易发现，$g_i$ 的次数比 $g_{i-1}$ 多 $2$

由于 $g_0$ 的次数为 0，则 $g_n$ 的次数为 $2n$，由于 $g_n$ 是 $f_n$ 的差分数组，则 $f_n$ 的次数为 $2n+1$，拉格朗日插值即可，可以做到 $O(n)$

```cpp
const int N = 1010;
int k,n,m;
ll f[N][N],y[N];
ll pre[N],suf[N],fac[N],ifac[N];
ll Lang(ll k)
{
	if(k <= m) return f[n][k];
	suf[m + 1] = 1,pre[0] = k;
	ifac[m] = qpow(fac[m],mod - 2);for(int i = m;i;i--) ifac[i - 1] = ifac[i] * i % mod;
	for(int i = 1;i <= m;i++) pre[i] = pre[i - 1] * (k - i) % mod;
	for(int i = m;~i;i--) suf[i] = suf[i + 1] * (k - i) % mod;
	ll ans = 0;
	for(int i = 0;i <= m;i++)
		ans = (ans + y[i] * (i == 0 ? 1 : pre[i - 1]) % mod * suf[i + 1] % mod
			 * ifac[i] % mod * ((m - i & 1) ? mod - 1 : 1) % mod * ifac[m - i] % mod) % mod;
	return ans;
}
int main()
{
	k = read(),n = read(),mod = read();
	m = 2 * n + 1;
	for(int i = 0;i <= m;i++) f[0][i] = 1;
	for(int i = 1;i <= n;i++)
		for(int j = 1;j <= m;j++)
			f[i][j] = (f[i - 1][j - 1] * j + f[i][j - 1]) % mod;
	for(int i = 1;i <= m;i++)
		y[i] = f[n][i];
	fac[0] = 1;for(int i = 1;i <= m;i++) fac[i] = fac[i - 1] * i % mod;
	ll ans = Lang(k);
	fprint(ans * fac[n] % mod);
}
```

---

## 作者：绝顶我为峰 (赞：4)

提供一种全新的思路，灵感来自于 AK 了十年 IOI 的熊熊熊大帅哥。

熊熊熊大帅哥的 blog：[传送门](https://www.cnblogs.com/ustze/p/16578275.html)

考虑容斥，自然的想法是枚举一个集合钦定全部相等，但是这样我们并不知道每个状态的容斥系数是什么，我们需要知道这里的容斥系数到底是什么。

把问题抽象到一个 $n$ 个点的图上，如果 $a_i=a_j$ 我们就在 $i,j$ 之间连边。

换一种思路容斥，我们考虑枚举一个边集 $E$，钦定 $E$ 中的边都连，记 $f(S)$ 表示 $S$ 中元素全部相等的元素和，他具体是什么我们留到稍后考虑，记 $C(E)$ 为连上 $E$ 中边后形成的联通块集合，那么我们可以得到所有满足条件的序列的权值和为 $\sum\limits_{E}(-1)^{|E|}\prod\limits_{S\in C(E)}f(S)$。

这个时候再考虑每个 $C(E)$ 的贡献，可以得到 $\sum\limits_P(\prod\limits_{S\in P}f(S))(\sum\limits_E[C(E)=P](-1)^{|E|})$，注意到前面的部分已经和 $E$ 没有关系了，我们只要对每个 $P$ 快速求出后面括号的答案。

记 $g(S)$ 表示所有让 $S$ 联通的连边方案 $E$ 的 $(-1)^{|E|}$ 的和，那么我们可以继续化简得到 $\sum\limits_P\prod\limits_{S\in P}f(S)g(S)$，因为每条边的贡献都是 $-1$。

再求 $g(S)$，设 $h(S)$ 表示 $S$ 内部随意连边的容斥系数和，$F(k)$ 表示钦定把 $S$ 划分成 $k$ 个联通块，连通块之间不连边的方案的容斥系数和，$G(k)$ 是恰好把 $S$ 划分成 $k$ 个联通块，连通块之间不连边的方案的容斥系数和，显然有 $g(S)=G(1)$。

通过斯特林反演来去掉联通的限制，有 $F(k)=\sum\limits_P[|P|=k]\prod\limits_{S\in P}h(S)=\sum\limits_{i=k}^nS_2(i,k)G(i)$，其中 $S_2$ 是第二类斯特林数。

于是可以得到 $G(k)=\sum\limits_{i=k}^n(-1)^{i-k}S_1(i,k)F(i)$，$S_1$ 是第一类斯特林数。

注意到如果集合划分中存在一个联通块的大小 $\geq 2$，那么我们随意连边的时候任选一条边取反就可以将所有连边方案两两配对，且每一对奇偶性不同，此时 $h(S)=0$。

唯一 $h(S)\neq 0$ 的情况是所有联通块大小都是 $1$，也就是钦定划分成 $|S|$ 个联通块，此时显然只有一种连边方案就是什么也不连，因此这时 $h(S)=1$，代入可以得到 $g(S)=G(1)=(-1)^{|S|-1}S_1(|S|,1)=(-1)^{|S|-1}(|S|-1)!$。

再把 $g(S)$ 带回原式，可以得到要求答案就是 $\sum\limits_P\prod\limits_{S\in P}f(S)(-1)^{|S|-1}(|S|-1)!$。

再来考虑 $f(S)$，在本题中即为 $\sum\limits_{i=1}^mi^{|S|}$，这是经典的自然数幂前缀和，可以拉插在 $O(|S|\log |S|)$ 的时间复杂度内求出。

于是直接枚举子集转移可以做到 $O(3^n)$ 显然是过不去的，考虑优化。

事实上每个位置的元素并没有本质的区别，我们先对无标号序列计数即可。

考虑直接枚举集合划分，记 $dp_{i,j}$ 表示考虑了划分中所有大小 $\leq i$ 的集合，和为 $j$ 的权值和，转移的时候枚举有多少个集合大小恰好是 $i$ 然后直接按照上面的式子转移。但是这样会算重，因为同样大小的集合在划分中实际上是不区分的，因此如果有 $k$ 个大小是 $i$ 的集合，系数要多一个 $\frac1{k!}$，这样直接转移是 $O(\sum\limits_{i=1}^n\sum\limits_{j=1}^n\frac ij)=O(n^2\ln n)$ 的，前面插值需要做 $n$ 次复杂度也是 $O(n^2\log n)$，可以通过此题。

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
inline void init()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
}
inline int read()
{
    int x;
    cin>>x;
    return x;
}
const int m=read(),n=read(),mod=read();
int dp[501][501],fac[501],inv[501],sum[501],pre[505],suf[505];
inline int pw(int a,int b)
{
    int res=1;
    while(b)
    {
        if(b&1)
            res=1ll*res*a%mod;
        b>>=1;
        a=1ll*a*a%mod;
    }
    return res;
}
inline int c(int x,int y)
{
    if(x<y||x<0||y<0)
        return 0;
    return 1ll*fac[x]*inv[y]%mod*inv[x-y]%mod;
}
inline int Mod(int x)
{
    return x>=mod? x-mod:x;
}
inline int calc(int cnt,int lim)
{
    pre[0]=suf[lim+1]=1;
    for(int i=1;i<=lim;++i)
        pre[i]=1ll*pre[i-1]*Mod(m-i+mod)%mod;
    for(int i=lim;i>=1;--i)
        suf[i]=1ll*suf[i+1]*Mod(m-i+mod)%mod;
    int ans=0,tot=0;
    for(int i=1;i<=lim;++i)
    {
        tot=Mod(tot+pw(i,cnt));
        ans=Mod(ans+1ll*tot*pre[i-1]%mod*suf[i+1]%mod*inv[i-1]%mod*inv[lim-i]%mod*((lim-i)&1? mod-1:1)%mod);
    }
    return ans;
}
int main()
{
    init();
    sum[0]=fac[0]=inv[0]=1;
    for(int i=1;i<=n+2;++i)
        fac[i]=1ll*fac[i-1]*i%mod;
    inv[n+2]=pw(fac[n+2],mod-2);
    for(int i=n+1;i>=1;--i)
        inv[i]=1ll*inv[i+1]*(i+1)%mod;
    for(int i=1;i<=n;++i)
        sum[i]=calc(i,i+2);
    dp[0][0]=1;
    for(int i=1;i<=n;++i)
        for(int j=0;j<=n;++j)
        {
            int w=1,val=1ll*inv[i]%mod*sum[i]%mod*(i&1? 1:mod-1)%mod*fac[i-1]%mod;
            for(int k=0;i*k<=j;++k)
            {
                dp[i][j]=Mod(dp[i][j]+1ll*dp[i-1][j-i*k]*w%mod*inv[k]%mod);
                w=1ll*w*val%mod;
            }
        }
    cout<<1ll*fac[n]*dp[n][n]%mod<<'\n';
    cout.flush();
    return 0;
}
```

---

## 作者：jun头吉吉 (赞：4)

## 题意
一个序列$a_1,a_2,\ldots,a_n$合法，当且仅当：
- $\forall i\in[1,n],a_i\in[1,k]$
- $\forall i\not=j,a_i\not=a_j$

一个序列的值为它的乘积,即$\prod_{i=1}^na_i$

给定$n,k$,求所有不同的序列的值的和。
## 题解
不难发现答案可以写成生成函数的形式：
$$F(x)=\prod_{i=1}^k(1+ix)$$
但此时是无序的，因为$a_1,a_2,\ldots,a_n$互不相等，乘$n!$即可。最后答案为$n![x^n]F(x)$

两边同取$\ln$把积变和。
$$\ln F(x)=\sum_{i=1}^k\ln(1+ix)$$
左边这个东西是可以化为多项式的。具体的：
$$
\begin{aligned}
\ln(1+ix)=&\int(\ln(1+ix))^\prime dx
&\text{(求导再求原)}\\
=&\int \frac{i}{1+ix}dx
&\text{(复合函数求导)}\\
=&\int i\sum_{j=0}^\infty 
(-ix)^jdx
&\text{(还原等比数列求和)}\\
=&\int i\sum_{j=0}^\infty (-1)^ji^jx^jdx
&\text{(拆括号)}\\
=&\sum_{j=0}^\infty (-1)^ji^{j+1}\int x^jdx
&\text{(交换求和顺序)}\\
=&\sum_{j=0}^\infty (-1)^ji^{j+1}\frac{x^{j+1}}{j+1}
&\text{(求原函数)}\\
=&\sum_{j=1}^\infty(-1)^{j-1}i^j\frac{x^j}{j}
&\text{(用j-1替换j)}
\end{aligned}
$$
于是乎带进去。
$$\ln F(x)=\sum_{i=1}^k\sum_{j=1}^\infty(-1)^{j-1}i^j\frac{x^j}{j}$$
整理一下下
$$\sum_{j=1}^\infty\frac{(-1)^{j-1}}{j}(\sum_{i=1}^ki^j)x^j$$
记$f_y(x)=\sum_{i=1}^xi^y$
$$\sum_{j=1}^\infty\frac{(-1)^{j-1}}{j}f_j(k)x^j$$
根据经验我们知道$f_y(x)=\sum_{i=1}^xi^y$是一个关于$x$的$y+1$次多项式，可以用拉格朗日插值得到。
$$f(x)=\sum_{i=0}^{n}y_i\prod_{i\not=j}\frac{x-x_j}{x_i-x_j}$$
此时求$f_y(x)$的复杂度为$\mathcal{O}(y^2)$，但由于点是我们自己取的，取连续的点可以做到$\mathcal{O}(y)$。我们已知$i\in[0,n]$时的取值$y_i$，那么魔改公式：
$$f(k)=\sum_{i=0}^ny_i\prod_{i\not=j}\frac{k-j}{i-j}$$
记
$$pre_i=\prod_{j=0}^{i}k-j,suf_i=\prod_{j=i}^nk-j$$
有
$$f(k)=\sum_{i=0}^ny_i\frac{pre_{i-1}\times suf_{i+1}}{i!(n-i)!(-1)^{n-i}}$$
注意符号。

算出系数后在$\exp$一下就好了。

然后就有$\mathcal{O}(n^2+n\log n)$的算法了。

只不过需要`MTT`
## 代码
```cpp
#include<bits/stdc++.h>
namespace in{
	char buf[1<<21],*p1=buf,*p2=buf;
	inline int getc(){return p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++;}
	template <typename T>inline void read(T& t){
		t=0;int f=0;char ch=getc();while (!isdigit(ch)){if(ch=='-')f = 1;ch=getc();}
	    while(isdigit(ch)){t=t*10+ch-48;ch = getc();}if(f)t=-t;
	}
	template <typename T,typename... Args> inline void read(T& t, Args&... args){read(t);read(args...);}
}
namespace out{
	char buffer[1<<21];int p1=-1;const int p2 = (1<<21)-1;
	inline void flush(){fwrite(buffer,1,p1+1,stdout),p1=-1;}
	inline void putc(const char &x) {if(p1==p2)flush();buffer[++p1]=x;}
	template <typename T>void write(T x) {
		static char buf[15];static int len=-1;if(x>=0){do{buf[++len]=x%10+48,x/=10;}while (x);}else{putc('-');do {buf[++len]=-(x%10)+48,x/=10;}while(x);}
		while (len>=0)putc(buf[len]),--len;
	}
}
typedef std::complex<double>complex;
const int N=4e6+10;const double PI=acos(-1);const complex I=complex(0,1);
int rev[N];complex Wn[N];int M,mod;
struct modint{
    int x;
    modint(int o=0){x=o;}
    modint &operator = (int o){return x=o,*this;}
    modint &operator +=(modint o){return x=x+o.x>=mod?x+o.x-mod:x+o.x,*this;}
    modint &operator -=(modint o){return x=x-o.x<0?x-o.x+mod:x-o.x,*this;}
    modint &operator *=(modint o){return x=1ll*x*o.x%mod,*this;}
    modint &operator ^=(int b){
        modint a=*this,c=1;
        for(;b;b>>=1,a*=a)if(b&1)c*=a;
        return x=c.x,*this;
    }
    modint &operator /=(modint o){return *this *=o^=mod-2;}
    modint &operator +=(int o){return x=x+o>=mod?x+o-mod:x+o,*this;}
    modint &operator -=(int o){return x=x-o<0?x-o+mod:x-o,*this;}
    modint &operator *=(int o){return x=1ll*x*o%mod,*this;}
    modint &operator /=(int o){return *this *= ((modint(o))^=mod-2);}
	template<class I>friend modint operator +(modint a,I b){return a+=b;}
    template<class I>friend modint operator -(modint a,I b){return a-=b;}
    template<class I>friend modint operator *(modint a,I b){return a*=b;}
    template<class I>friend modint operator /(modint a,I b){return a/=b;}
    friend modint operator ^(modint a,int b){return a^=b;}
    friend bool operator ==(modint a,int b){return a.x==b;}
    friend bool operator !=(modint a,int b){return a.x!=b;}
    bool operator ! () {return !x;}
    modint operator - () {return x?mod-x:0;}
	modint &operator++(int){return *this+=1;}
};
inline long long num(complex x){double d=x.real();return d<0?(long long)(d-0.5)%mod:(long long)(d+0.5)%mod;}
struct poly{
	std::vector<complex>a0,a1;
	int size(){return a0.size();}
    void resize(int n){a0.resize(n);a1.resize(n);}
	void set(int x,modint y){
		a0[x]=y.x/M;
		a1[x]=y.x%M;
	}
	long long get(int x){return (M*M*num(a0[x].real())%mod +
				M*(num(a0[x].imag())+num(a1[x].real()))%mod+num(a1[x].imag()))%mod;}
	modint val(int x){return (long long)(M*a0[x].real()+a1[x].real()+mod)%mod;}
};
poly operator+(poly a,poly b){
    int n=std::max(a.size(),b.size());a.resize(n),b.resize(n);
    for(int i=0;i<n;i++)a.set(i,a.val(i)+b.val(i));return a;
}
poly operator-(poly a,poly b){
    int n=std::max(a.size(),b.size());a.resize(n),b.resize(n);
    for(int i=0;i<n;i++)a.set(i,a.val(i)-b.val(i));return a;
}
inline poly one(){poly a;a.resize(1);a.set(0,1);return a;}
inline int ext(int n){int k=0;while((1<<k)<n)k++;return k;}
inline void init(int k){
	int n=1<<k;
	for(int i=0;i<n;i++)
		rev[i]=(rev[i>>1]>>1)|((i&1)<<(k-1));
	for(int i=0;i<n;i++)
		Wn[i]={cos(PI/n*i),sin(PI/n*i)};
}
void FFT(std::vector<complex>&A,int n,int t){
	if(t<0)for(int i=1;i<n;i++)if(i<(n-i))std::swap(A[i],A[n-i]);
	for(int i=0;i<n;i++)
		if(i<rev[i])std::swap(A[i],A[rev[i]]);
	for(int m=1;m<n;m<<=1)
		for(int i=0;i<n;i+=m<<1)
			for(int k=i;k<i+m;k++){
				complex W=Wn[1ll*(k-i)*n/m];
				complex a0=A[k],a1=A[k+m]*W;
				A[k]=a0+a1;A[k+m]=a0-a1; 
			}
	if(t<0)for(int i=0;i<n;i++)A[i]/=n;
}
void MTT(poly &A,int n,int t){
	for(int i=0;i<n;i++)A.a0[i]=A.a0[i]+I*A.a1[i];
	FFT(A.a0,n,t);
	for(int i=0;i<n;i++)A.a1[i]=std::conj(A.a0[i?n-i:0]);
	for(int i=0;i<n;i++){
		complex p=A.a0[i],q=A.a1[i];
		A.a0[i]=(p+q)*0.5;A.a1[i]=(q-p)*0.5*I;
	}
}
inline poly operator*(poly a,poly b){
    int n=a.size()+b.size()-1,k=ext(n);
    a.resize(1<<k),b.resize(1<<k),init(k);
    MTT(a,1<<k,1);MTT(b,1<<k,1);
	for(int i=0;i<(1<<k);i++){
		complex p=a.a0[i]*b.a0[i]+I*a.a1[i]*b.a0[i];
		complex q=a.a0[i]*b.a1[i]+I*a.a1[i]*b.a1[i];
		a.a0[i]=p,a.a1[i]=q;
	}
    FFT(a.a0,1<<k,-1);FFT(a.a1,1<<k,-1);a.resize(n);
	long long tmp;for(int i=0;i<n;i++)
		tmp=a.get(i),a.set(i,tmp);
	return a;
}
inline poly deriv(poly a){//求导 
    int n=a.size()-1;
    for(int i=0;i<n;i++)a.set(i,a.val(i+1)*(i+1));
    a.resize(n);return a;
}
inline poly inter(poly a){//求原 
    int n=a.size()+1;a.resize(n);
    for(int i=n;i>=1;i--)a.set(i,a.val(i-1)/i);
    a.set(0,0);return a;
}
poly inv(poly F,int k){
    int n=1<<k;F.resize(n);
    if(n==1){F.set(0,modint(1)/F.val(0));return F;}
    poly G,H=inv(F,k-1);
    G.resize(n),H.resize(n<<1),F.resize(n<<1);
    for(int i=0;i<n/2;i++)G.set(i,H.val(i)*2);
    H=H*H;H.resize(n);H=H*F;H.resize(n);
    G=G-H;return G;
}
inline poly inv(poly a){
    int n=a.size();
    a=inv(a,ext(n)),a.resize(n);return a;;
}
inline poly ln(poly a){
    int n=a.size();
    a=inter(deriv(a)*inv(a));
    a.resize(n);return a;
}
poly exp(poly a,int k){
	int n=1<<k;a.resize(n);
	if(n==1)return one();
	poly f0=exp(a,k-1);f0.resize(n);
	return f0*(one()+a-ln(f0)); 
}
poly exp(poly a){
	int n=a.size();
	a=exp(a,ext(n));a.resize(n);return a;
}
modint y[1000];
modint *pre,*suf;modint aaa[2000];
modint fac[1000],ifac[1000];
modint get(int n,int k){
	//计算\sum_{i=1}^k i^n 显然为一个n+1次的多项式 需要n+2个点 
	modint sum=0;
	for(int i=0;i<=n+1;i++,sum+=(modint(i)^n))y[i]=sum;
	n=n+1;pre[-1]=suf[n+1]=1;
	for(int i=0;i<=n;i++)pre[i]=pre[i-1]*(k-i);
	for(int i=n;i>=0;i--)suf[i]=suf[i+1]*(k-i);
	sum=0;
	for(int i=0;i<=n;i++)
		if((n-i)&1)sum-=y[i]*pre[i-1]*suf[i+1]*ifac[i]*ifac[n-i];
		else sum+=y[i]*pre[i-1]*suf[i+1]*ifac[i]*ifac[n-i];
	return sum;
}
int n,k;
signed main(){
	in::read(k,n,mod);M=sqrt(mod);
	pre=&aaa[10];suf=&aaa[1010];ifac[0]=fac[0]=1;for(int i=1;i<1000;i++)fac[i]=fac[i-1]*i,ifac[i]=modint(1)/fac[i];
	poly F;F.resize(n+1);
	for(int i=1;i<=n;i++)
		if((i+1)&1)F.set(i,-get(i,k)/i);
		else F.set(i,get(i,k)/i);
	//for(int i=0;i<=n;i++)printf("%d ",F.val(i).x);puts("");
	F=exp(F);out::write((F.val(n)*fac[n]).x);
	out::flush();
	return 0;
}
```

---

## 作者：foreverlasting (赞：4)

[题面](https://www.luogu.org/problemnew/show/P4463)

拉格朗日插值。

首先推出一个$DP$。

$dp[i][j]$表示当前匹配到第$i$个数，乘积的值域在$[1,...,j]$。转移方程也很显然，$dp[i][j]$=$dp[i-1][j-1]*i*j+dp[i][j-1]$。然后发现$A$太大了，然后仔细观察式子。我们假设$dp[i][j]$为一个最高次为$2*i$关于$j$的多项式，那么$dp[i+1][j]$=$dp[i][j]*i*j+dp[i+1][j]$，$dp[i][j]*i*j$是最高次为$2*i+1$关于$j$的多项式，$dp[i+1][j]$是最高次为$2*(i+1)$关于$j$的多项式，可见$dp[i+1][j]$是最高次为$2*(i+1)$关于$j$的多项式。所以得出$dp[n][A]$是最高次为$n*2$关于$A$的多项式。所以直接拉格朗日插值就好了。

code：
```
//2018.10.11 by ljz
#include<bits/stdc++.h>
using namespace std;
#define res register int
#define LL long long
#define inf 0x3f3f3f3f
#define eps 1e-15
inline int read(){
    res s=0;
    bool w=0;
    char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')w=1;ch=getchar();}
    while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=getchar();
    return w?-s:s;
}
inline void _swap(res &x,res &y){
    x^=y^=x^=y;
}
inline int _abs(const res &x){
    return x>0?x:-x;
}
inline int _max(const res &x,const res &y){
    return x>y?x:y;
}
inline int _min(const res &x,const res &y){
    return x<y?x:y;
}
const int N=5e2+10;
namespace MAIN{
    int A,n,kcz;
    int dp[N][N<<1];
    int ans;
    inline int qpow(res x,res y){
        res ret=1;
        while(y){
            if(y&1)ret=1LL*ret*x%kcz;
            y>>=1,x=1LL*x*x%kcz;
        }
        return ret%kcz;
    }
    inline void add(res &x,const res &y){
        x+=y;
        x>=kcz?x-=kcz:1;
        x<0?x+=kcz:1;
    }
    inline int calc(const res &x){
        res tmp=1,ret=0,p=((n<<1)&1)?kcz-1:1;
        for(res i=1;i<=n<<1;i++)tmp=1LL*tmp*(x-i)%kcz*qpow(i,kcz-2)%kcz;
        for(res i=0;i<=n<<1;i++,p=kcz-p)
            add(ret,1LL*p*dp[n][i]%kcz*tmp%kcz),tmp=1LL*tmp*(x-i)%kcz*qpow(x-i-1,kcz-2)%kcz*((n<<1)-i)%kcz*qpow(i+1,kcz-2)%kcz;
        return ret;
    }
    inline void MAIN(){
        A=read(),n=read(),kcz=read();
        for(res i=0;i<=n<<1;i++)dp[0][i]=1;
        for(res i=1;i<=n;i++)
            for(res j=1;j<=n<<1;j++)
                dp[i][j]=(1LL*dp[i-1][j-1]*i*j%kcz+dp[i][j-1])%kcz;
        if(A<=n<<1)printf("%d\n",dp[n][A]);
        else printf("%d\n",calc(A));
    }
}
int main(){
    MAIN::MAIN();
    return 0;
}
```

---

## 作者：VenusM1nT (赞：3)

$\textbf{DP}$。  
讲道理我超喜欢这题的（  
首先我们看子序列数非常多，我们考虑算出 $f_{i,j}$ 表示前 $i$ 个数内最大值不超过 $j$ 的**递增序列**的权值和，然后我们再把递增的转化为任意的，也就是乘上 $n!$ 就可以了。那么 $f_{i,j}$ 怎么推呢？有一个显然的递推式为：
$$f_{i,j}=f_{i,j-1}+f_{i-1,j-1}\times j$$
含义应该不难理解吧，不多解释了（  
那么这个东西的转移是 $\text{O}(n\times A)$ 的，显然复杂度炸上天，那么怎么办好呢？我们对 $f_{n,i}$ 进行考虑，它是由 $f_{n,i-1}+f_{n-1,i-1}\times i$ 转移过来的，再推一项，会发现 $f_{n,i}$ 的最终展开的形式长得很像一个关于 $i$ 的多项式，如果我们可以确定若干个点的话，就可以利用 $\textbf{Lagrange}$ **插值法** 来求出 $f_{n,A}$ 的值。那么首先我们要确定的是这个多项式的次数。我们可以假设 $f_{n,i}$ 为关于 $i$ 的 $g_n$ 次多项式，一个结论是对于 $n$ 次的多项式 $h(x)$，$h(x)-h(x-1)$ 的次数是 $n-1$ 次，因为在计算最高次的时候，两个多项式都会出现形如 $a\times x^n$ 的形式，相减就抵消掉了。我们考虑这个结论，然后对一开始的递推式进行变形，如下：
$$f_{n,i}-f_{n,i-1}=f_{n-1,i-1}\times i$$
将 $g_n$ 代入，再用上面的结论就可以得到：
$$g_n-1=g_{n-1}+1$$
注意到这是一个等差数列的格式，则可以得到通项公式：
$$g_n=n\times 2$$
所以 $f_{n,i}$ 是一个关于 $i$ 的 $n\times2$ 次多项式，而一个 $n\times2$ 次多项式可以由 $n\times2+1$ 个点来确定，那么我们直接大力求出 $n\times 2+1$ 个点的值，再直接用 $\textbf{Lagrange}$ **插值法** 就可以得到 $f_{n,A}$ 的值。

```cpp
#include<bits/stdc++.h>
#define MAXN 505
#define reg register
#define inl inline
using namespace std;
int A,n,Mod,a[MAXN],lim,f[MAXN][MAXN<<1],y[MAXN];
inl int Add(reg int x,reg int y)
{
	return x+y>Mod?x+y-Mod:x+y;
}
inl int Del(reg int x,reg int y)
{
	return x-y<0?x-y+Mod:x-y;
}
inl int Mul(reg int x,reg int y)
{
	return 1ll*x*y-1ll*x*y/Mod*Mod;
}
inl int Pow(reg int x,reg int y)
{
	reg int res=1;
	for(;y;y>>=1,x=Mul(x,x)) if(y&1) res=Mul(res,x);
	return res;
}
inl int Lagrange(reg int x)
{
	if(1<=x && x<=lim) return y[x];
	reg int res=0;
	for(reg int i=1;i<=lim;i++)
	{
		reg int Up=1,Dn=1;
		for(reg int j=1;j<=lim;j++)
		{
			if(i==j) continue;
			Up=Mul(Up,Del(x,j));
			Dn=Mul(Dn,Del(i,j));
		}
		res=Add(res,Mul(y[i],Mul(Up,Pow(Dn,Mod-2))));
	}
	return res;
}
int main()
{
	scanf("%d %d %d",&A,&n,&Mod);
	lim=(n<<1)+1;
	for(reg int i=0;i<=lim;i++) f[0][i]=1;
	for(reg int i=1;i<=n;i++)
	{
		for(reg int j=1;j<=lim;j++) f[i][j]=Add(f[i][j-1],Mul(f[i-1][j-1],j));
	}
	for(reg int i=1;i<=lim;i++) y[i]=f[n][i];
	reg int ans=Lagrange(A);
	for(reg int i=1;i<=n;i++) ans=Mul(ans,i);
	printf("%d\n",ans);
	return 0;
}
```

当然，我们也可以用横坐标连续这一特点对其进行优化，$\textbf{Lagrange}$ **插值法** 的复杂度可以优化至 $n\times2+1$，运行速度快了一倍不止。
```cpp
#include<bits/stdc++.h>
#define MAXN 1005
#define reg register
#define inl inline
using namespace std;
int A,n,Mod,a[MAXN],lim,f[MAXN][MAXN],y[MAXN],suf[MAXN],pre[MAXN],inv[MAXN];
inl int Add(reg int x,reg int y)
{
	return x+y>Mod?x+y-Mod:x+y;
}
inl int Del(reg int x,reg int y)
{
	return x-y<0?x-y+Mod:x-y;
}
inl int Mul(reg int x,reg int y)
{
	return 1ll*x*y-1ll*x*y/Mod*Mod;
}
inl int Pow(reg int x,reg int y)
{
	reg int res=1;
	for(;y;y>>=1,x=Mul(x,x)) if(y&1) res=Mul(res,x);
	return res;
}
inl int Lagrange(reg int x)
{
	if(1<=x && x<=lim) return y[x];
	reg int res=0,prod=1;
	pre[0]=pre[lim+1]=suf[0]=suf[lim+1]=inv[0]=1;
	for(reg int i=1;i<=lim;i++) pre[i]=Mul(pre[i-1],Del(A,i));
	for(reg int i=lim;i>=1;i--) suf[i]=Mul(suf[i+1],Del(A,i));
	for(reg int i=1;i<=lim;i++) prod=Mul(prod,i);
	inv[lim]=Pow(prod,Mod-2);
	for(reg int i=lim-1;i>=1;i--) inv[i]=Mul(inv[i+1],i+1);
	for(reg int i=1;i<=lim;i++)
	{
		reg int x=Mul(y[i],Mul(pre[i-1],Mul(suf[i+1],Mul(inv[i-1],inv[lim-i]))));
		if((lim-i)&1) x=Del(Mod,x);
		res=Add(res,x);
	}
	return res;
}
int main()
{
	scanf("%d %d %d",&A,&n,&Mod);
	lim=(n<<1)+1;
	for(reg int i=0;i<=lim;i++) f[0][i]=1;
	for(reg int i=1;i<=n;i++)
	{
		for(reg int j=1;j<=lim;j++) f[i][j]=Add(f[i][j-1],Mul(f[i-1][j-1],j));
	}
	for(reg int i=1;i<=lim;i++) y[i]=f[n][i];
	reg int ans=Lagrange(A);
	for(reg int i=1;i<=n;i++) ans=Mul(ans,i);
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：NaVi_Awson (赞：1)

[博客也有详解，欢迎来踩](https://www.cnblogs.com/NaVi-Awson/p/9251080.html)

## Description

给出 $A,n,p$ ，让你在模 $p$ 意义下求所有序列 $a$ 满足“长度为 $n$ 且 $a_i\in[1,A]$ ，并且对于 $i\neq j,a_i\neq a_j$”的价值和。

一个序列的价值定义为 $\prod\limits_{i=1}^n a_i$ 。

$1\leq A\leq 10^9,1\leq n\leq 500,p\leq 10^9$ 并且 $p$ 为素数， $p>A>n+1$ 。

## Solution

考虑朴素的 $\text{DP}$ 。

记 $f_{i,j}$ 为长度为 $j$ 的序列只含 $[1,i]$ 内的数的价值。

转移是考虑是否加上 $i$ 这个元素并且如果加上放在哪一位，那么

$$f_{i,j}=f_{i-1,j-1}\times j\times i+f_{i-1,j}$$

这样转移是 $O(An)$ 的，过不了...

[据说](https://blog.csdn.net/ez_yww/article/details/77221338) $f_{i,j}$ 是一个关于 $i$ 有关的 $2j$ 次的多项式。

那么我们考虑 $\text{DP}$ 出 $f_{i,n},i\in[0,2n]$ 的值，用拉格朗日插值求出唯一解即可...

## Code

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1000+5;

int f[N][N], a, n, p, x[N], y[N], ifac[N], inv[N];

int quick_pow(int a, int b) {
	int ans = 1;
	while (b) {
		if (b&1) ans = 1ll*ans*a%p;
		b >>= 1, a = 1ll*a*a%p;
	}
	return ans;
}
int lagrange(int n, int *x, int *y, int xi) {
	int ans = 0, s1 = 1;
	for (int i = 0; i <= n; i++) {
		s1 = 1ll*s1*(xi-x[i])%p;
		inv[i] = quick_pow(xi-x[i], p-2);
	}
	ifac[1] = ifac[0] = 1;
	for (int i = 2; i <= n; i++) ifac[i] = -1ll*p/i*ifac[p%i]%p;
	for (int i = 2; i <= n; i++) ifac[i] = 1ll*ifac[i]*ifac[i-1]%p;
	for (int i = 0; i <= n; i++)
		(ans += 1ll*y[i]*s1%p*inv[i]%p*ifac[i]%p*(((n-i)&1) ? -1 : 1)*ifac[n-i]%p) %= p;
	return (ans+p)%p;
}
void work() {
	scanf("%d%d%d", &a, &n, &p);
	for (int i = 0; i <= n*2; i++) f[i][0] = 1;
	for (int i = 1; i <= n*2; i++)
		for (int j = 1; j <= n; j++)
			f[i][j] = (1ll*f[i-1][j-1]*i%p*j%p+f[i-1][j])%p;
	if (a <= 2*n) {printf("%d\n", f[a][n]); return; }
	for (int i = 0; i <= 2*n; i++) x[i] = i, y[i] = f[i][n];
	printf("%d\n", lagrange(2*n, x, y, a));
}
int main() {work(); return 0; }
```

---

## 作者：crashed (赞：0)

# 题目
&emsp;&emsp;[点这里](https://www.luogu.com.cn/problem/P4463)看题目。   
# 分析   
&emsp;&emsp;首先不难想到可以枚举递增的序列，最后在答案里面乘上$n!$，于是有$O(nk)$的暴力 DP 一枚：   
&emsp;&emsp;$f(i,j)$表示长度为$i$、最大值$\le j$的序列的贡献和。   
&emsp;&emsp;转移显然：   
$$f(i,j)=j\times f(i-1,j-1)+f(i,j-1)$$   
&emsp;&emsp;那么可以发现，当序列长度固定的时候，$f(n,x)$肯定是关于$x$的函数。环顾四周，DP 转移方程中并不存在除法、开方、作为指数乘方等运算，所以可以推测$f(n,x)$就是$x$的多项式函数。   
&emsp;&emsp;那么，它的次数是多少呢？这直接决定了我们如何进行插值。设$f(n,x)$的次数为$g(n)$，考虑到转移左右两边的次数应该是相等的，就有：   
$$f(i,j)-f(i,j-1)=j\times f(i-1,j-1)\Rightarrow g(n)-1=g(n-1)+1$$   
&emsp;&emsp;补充一下，多项式函数做差分，即$f(x)-f(x-1)$，得到的结果的次数会比原多项式的小一，可以直接用二项式定理展开证明。  
&emsp;&emsp;然后发现，$g(n)=g(n-1)+2$，由于$f(0,x)=1$，所以$g(0)=0$，得到通项公式$g(n)=2n$。  
&emsp;&emsp;然后我们就知道了$f(n,x)$是关于$x$的$2n$次的多项式函数，因此，我们需要算出$2n+1$个点值，用于插值。总时间$O(n^2)$。   
```cpp
#include <cstdio>

const int MAXN = 1005;

template<typename _T>
void read( _T &x )
{
	x = 0;char s = getchar();int f = 1;
	while( s > '9' || s < '0' ){if( s == '-' ) f = -1; s = getchar();}
	while( s >= '0' && s <= '9' ){x = ( x << 3 ) + ( x << 1 ) + ( s - '0' ), s = getchar();}
	x *= f;
}

template<typename _T>
void write( _T x )
{
	if( x < 0 ){ putchar( '-' ); x = ( ~ x ) + 1; }
	if( 9 < x ){ write( x / 10 ); }
	putchar( x % 10 + '0' );
}

int f[MAXN][MAXN], y[MAXN];
int N, K, M, mod;

int qkpow( int base, int indx )
{
	int ret = 1;
	while( indx )
	{
		if( indx & 1 ) ret = 1ll * ret * base % mod;
		base = 1ll * base * base % mod, indx >>= 1;
	}
	return ret;
}

int inver( const int a ) { return qkpow( a, mod - 2 ); }
void add( int &x, const int v ) { x = ( x + v >= mod ? x + v - mod : x + v ); }

int Lagrange()
{
	if( K <= M ) return y[K];
	int ans = 0, tmp;
	for( int i = 1 ; i <= M ; i ++ )
	{
		tmp = 1;
		for( int j = 1 ; j <= M ; j ++ )
			if( i != j )
				tmp = 1ll * tmp * ( K - j ) % mod * inver( i - j + mod ) % mod;
		add( ans, 1ll * tmp * y[i] % mod );
	}
	return ans;
}

int main()
{
	read( K ), read( N ), read( mod );
	M = 2 * N + 1;
	for( int j = 0 ; j <= M ; j ++ )
		f[0][j] = 1; 
	for( int i = 1 ; i <= N ; i ++ )
		for( int j = 1 ; j <= M ; j ++ )
			f[i][j] = ( 1ll * f[i - 1][j - 1] * j % mod + f[i][j - 1] ) % mod;
	for( int i = 0 ; i <= M ; i ++ ) y[i] = f[N][i];
	int fac = 1; 
	for( int i = 1 ; i <= N ; i ++ ) fac = 1ll * fac * i % mod;
	write( 1ll * fac * Lagrange() % mod ), putchar( '\n' );
	return 0;
}
```

---

## 作者：hl666 (赞：0)

WJMZBMR的题果然放在几年后看来仍然挺神，提出了一种独特的优化DP的方式

首先我们想一个暴力DP，先定下所有数的顺序（比如强制它递增），然后最后乘上$n!$种排列方式就是答案了

那么我们容易想出一个DP，令$f_{i,j}$表示前$i$个数中，最大的数小于等于$j$的方案数是多少

显然有转移：

$$f_{i,j}=f_{i-1,j-1}\times j+f_{i,j-1}$$

但这样DP是$O(nA)$的，需要用**拉格朗日插值**进行优化，不会拉格朗日插值的可以看一下[浅谈拉格朗日插值](https://www.cnblogs.com/cjjsb/p/11054853.html)

在里面就提到了插值的一个关键点就是求出给定多项式的次数。因此我们观察$f_{n,i}$，猜测它是关于$i$的$t_n$次多项式

那么我们把转移方程移项一下：

$$f_{i,j}-f_{i,j-1}=f_{i-1,j-1}\times j$$

有差分和乘积的一些相关性质可以得出它们之间次数的关系：

$$t_n-1=t_{n-1}+1$$

而当$n=0$时，有$t_0=0$，所以容易推出$t_n=2n$

因此我们知道了$f_{n,i}$是关于$i$的$2n$次多项式，那么直接暴力DP求出$f_{n,1}$到$f_{n,2n+1}$，然后插值出$f(n,A)$的值即可

CODE

```cpp
#include<cstdio>
#define RI register int
#define CI const int&
using namespace std;
const int N=505;
int A,n,m,f[N][N<<1],g[N<<1],fact[N<<1],mod;
inline int sum(CI a,CI b)
{
    int t=a+b; return t>=mod?t-mod:t;
}
inline int sub(CI a,CI b)
{
    int t=a-b; return t<0?t+mod:t;
}
inline int quick_pow(int x,int p=mod-2,int mul=1)
{
    for (;p;p>>=1,x=1LL*x*x%mod) if (p&1) mul=1LL*mul*x%mod; return mul;
}
inline void DP(CI n,CI m)
{
    RI i,j; for (RI i=0;i<=m;++i) f[0][i]=1;
    for (i=1;i<=n;++i) for (j=1;j<=m;++j)
    f[i][j]=sum(1LL*f[i-1][j-1]*j%mod,f[i][j-1]);
}
inline int Lagerange(CI n,int *f,CI k)
{
    if (k<=n) return f[k]; RI i; int ret=0,mt=1;
    for (i=1;i<=n;++i) mt=1LL*mt*(k-i)%mod; for (i=1;i<=n;++i)
    {
        int tp=1LL*mt*quick_pow(k-i)%mod*f[i]%mod;
        int dv=1LL*fact[i-1]*fact[n-i]%mod; tp=1LL*tp*quick_pow(dv)%mod;
        if ((n-i)&1) ret=sub(ret,tp); else ret=sum(ret,tp);
    }
    return ret;
}
int main()
{
    scanf("%d%d%d",&A,&n,&mod); DP(n,m=n<<1|1);
    RI i; for (i=1;i<=m;++i) g[i]=f[n][i];
    for (fact[0]=i=1;i<=m;++i) fact[i]=1LL*fact[i-1]*i%mod;
    return printf("%d",1LL*Lagerange(m,g,A)*fact[n]%mod),0;
}
```



---


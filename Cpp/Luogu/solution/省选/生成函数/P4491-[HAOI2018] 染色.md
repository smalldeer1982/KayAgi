# [HAOI2018] 染色

## 题目背景

HAOI2018 Round2 第二题

## 题目描述

为了报答小 C 的苹果，小 G 打算送给热爱美术的小 C 一块画布，这块画布可以抽象为一个长度为 $N$ 的序列，每个位置都可以被染成 $M$ 种颜色中的某一种。

然而小 C 只关心序列的 $N$ 个位置中出现次数恰好为 $S$ 的颜色种数，如果恰好出现了 $S$ 次的颜色有 $K$ 种，则小 C 会产生 $W_k$ 的愉悦度。

小 C 希望知道对于所有可能的染色方案，他能获得的愉悦度的和对 $1004535809$
取模的结果是多少。

## 说明/提示

特殊性质: $\forall 1 \le i \le m, W_i = 0$。

对于 $100\%$ 的数据，满足 $1 \le N \le 10 ^ 7$，$1 \le M \le 10 ^ 5$，$1 \le S \le 150$，$0 \le W_i < 1004535809$。

![Data](https://cdn.luogu.com.cn/upload/pic/18057.png)


## 样例 #1

### 输入

```
8 8 3
3999 8477 9694 8454 3308 8961 3018 2255 4910```

### 输出

```
524070430```

## 样例 #2

### 输入

```
见 sample.zip/data2.in```

### 输出

```
见 sample.zip/data2.ans```

# 题解

## 作者：command_block (赞：72)

广告 : [炫酷反演魔术](https://www.luogu.com.cn/blog/command-block/xuan-ku-fan-yan-mo-shu) & [多项式计数杂谈](https://www.luogu.com.cn/blog/command-block/sheng-cheng-han-shuo-za-tan)

二项式反演经典题。

设 $G[k]$ 表示有**恰好** $k$ 种颜色出现了 $S$ 次的方案数。

我们需要求出 $W[1...n]$ 即可解决问题,这个 $n=\min(M,N/S)$

一个`naive`的想法是 : 钦定$k$种颜色,每种强行染上$S$次。

剩下的颜色放任自流,随便怎么染。

得到 $\dbinom{m}{k}*\dfrac{n!}{(S!)^k(n-S*k)!}*(n-S*k)^{m-k}$

组合意义 : "选 $k$ 种颜色$\times$可重排列$\times$放任自流"

那么这个东西肯定不是 $G[k]$ ,也并不是所谓 "至少 $k$ 种颜色出现了 $S$ 次的方案数"

事实上,这是会重复计数的,但是仍然以优美的方式蕴含了 $G[k]$。

我们设其为 $F[k]$。

- 我们先从特殊情况来分析

  假设有三种颜色 $a,b,c$

  按照上式的组合思想:

  1) 钦定 $a,b$ ,然后随便染,不幸的是 $c$ 也出现了 $S$ 次

  2) 钦定 $a,c$ ,然后随便染,不幸的是 $b$ 也出现了 $S$ 次

  很明显会把 $a,b,c$ 都恰好出现 $S$ 次的方案算重复,所以严格来讲这个式子并不能称之为方案数……

  究竟算重多少次呢?

  考虑有 $4$ 种颜色 $a,b,c,d$

  那么 $G[4]$ 与 $F[3]$ 间的贡献关系是什么呢?

	$G[4]$ 在 $F[3]$ 钦定 $\{a,b,c\}$,$\{a,b,d\}$,$\{a,c,d\}$,$\{b,c,d\}$ 的时候各被算重一次,那么算重了 $\dbinom{4}{3}$ 次。

类比至一般情况,得到 $F[k]=\sum\limits_{i=k}^{n}\dbinom{i}{k}*G[i]$

已知 $F$ 要求 $G$ ,不就是二项式反演的经典操作嘛!

反演可得 $G[k]=\sum\limits_{i=k}^n(-1)^{i-k}\dbinom{i}{k}F[i]$

到现在复杂度还是 $O(n^2)$ 的,我们考虑把组合数拆开看看能否卷积:

$G[k]=\sum\limits_{i=k}^n(-1)^{i-k}\dfrac{i!}{k!(i-k)!}F[i]$

$G[k]*k!=\sum\limits_{i=k}^n\dfrac{(-1)^{i-k}}{(i-k)!}i!F[i]$

这可以明显地看到差卷积形式了。

设 $A[i]=i!*F[i],\ B[i]=\dfrac{(-1)^i}{i!}$

则有$G[k]=\frac{1}{k!}\sum\limits_{i=k}^nA[i]B[i-k]$

NTT计算差卷积即可,复杂度$O(N+n\log n)$。

**Code:**

```cpp
#include<algorithm>
#include<cstdio>
#define ll long long
using namespace std;
const int _G=3,mod=1004535809,Maxn=135000,MaxNum=10000500;
ll powM(ll a,int t=mod-2){
  ll ans=1;
  while(t){
    if(t&1)ans=ans*a%mod;
    a=a*a%mod;t>>=1;
  }return ans;
}
const int invG=powM(_G);
int tr[Maxn<<1];
void NTT(int *g,bool op,int n)
{
  #define ull unsigned long long
  static ull f[Maxn<<1],w[Maxn]={1};
  for (int i=0;i<n;i++)f[i]=g[tr[i]];
  for(int l=1;l<n;l<<=1){
    ull tG=powM(op?_G:invG,(mod-1)/(l+l));
    for (int i=1;i<l;i++)w[i]=w[i-1]*tG%mod;
    for(int k=0;k<n;k+=l+l)
      for(int p=0;p<l;p++){
        int tt=w[p]*f[k|l|p]%mod;
        f[k|l|p]=f[k|p]+mod-tt;
        f[k|p]+=tt;
      }      
    if (l==(1<<10))
      for (int i=0;i<n;i++)f[i]%=mod;
  }if (!op){
    ull invn=powM(n);
    for(int i=0;i<n;++i)
      g[i]=f[i]%mod*invn%mod;
  }else for(int i=0;i<n;++i)g[i]=f[i]%mod;
}
int n,m,S,lim,limNum;
ll w[Maxn],fac[MaxNum],ifac[MaxNum];
void Init()
{
  limNum=max(n,m);fac[0]=1;
  for (int i=1;i<=limNum;i++)
    fac[i]=fac[i-1]*i%mod;
  ifac[limNum]=powM(fac[limNum]);
  for (int i=limNum;i;i--)
    ifac[i-1]=ifac[i]*i%mod;
}
ll C(int n,int m)
{return fac[n]*ifac[m]%mod*ifac[n-m]%mod;}
inline ll clacF(int x){
  return 
    C(m,x)*fac[n]%mod*
    powM(ifac[S],x)%mod*ifac[n-S*x]%mod*
		powM(m-x,n-S*x)%mod;
}
int A[Maxn<<1],B[Maxn<<1];
int main()
{
  scanf("%d%d%d",&n,&m,&S);
  lim=min(m,n/S);Init();
  for (int i=0;i<=lim;i++){
    A[i]=clacF(i)*fac[i]%mod;
    B[i]=(i&1) ? mod-ifac[i] : ifac[i];
  }reverse(A,A+lim+1);
  for(n=1;n<lim+lim+2;n<<=1);
  for (int i=0;i<n;i++)
    tr[i]=(tr[i>>1]>>1)|((i&1)?n>>1:0);
  NTT(A,1,n);NTT(B,1,n);
  for (int i=0;i<n;i++)A[i]=1ll*A[i]*B[i]%mod;
  NTT(A,0,n);reverse(A,A+lim+1);
  ll ans=0;
  for (int i=0,w;i<=lim;i++){
    scanf("%d",&w);
    ans=(ans+A[i]*ifac[i]%mod*w)%mod;
  }printf("%lld",ans);
  return 0;
}
```

---

## 作者：λᴉʍ (赞：34)

显然颜色数量不会超过$lim=\min(m,n/S)$

考虑容斥，计算恰好出现了$S$次的颜色有**至少**$i$种的方案数$f[i]$，钦定$i$种颜色正好放$S$种

有$m$种颜色选$i$种，所以乘一个$C_m^i$

然后这n个位置分成$i+1$个部分：被钦定的$i$种颜色，每个有$S$个；剩下的$m-i$种颜色，一共$n-iS$个。先看作是可重的全排列数，那么方案就有$\frac{n!}{(S!)^i(n-iS)!}$种。前$i$各部分都是只有一种颜色，后面部分每个有$m-i$种取法，所以还有一个$(m-i)^{n-iS}$

综上，$f[i]=C_m^i\cdot \frac{n!}{(S!)^i(n-iS)!}\cdot(m-i)^{n-iS}$

接下来就是答案，恰好出现了$S$次的颜色有**正好**$i$种的方案数$ans[i]$

用容斥，$ans[i]=\sum_{j=i}^{lim}(-1)^{j-i}C_j^if[j]$

那个组合数很麻烦，拆开

$ans[i]=\sum_{j=i}^{lim}(-1)^{j-i}\frac{j!}{i!(j-i)!}f[j]$

$ans[i]\cdot i!=\sum_{j=i}^{lim}\frac{(-1)^{j-i}}{(j-i)!}f[j]\cdot j!$

这就可以直接用NTT做了，如果不知道怎么做的可以先写zjoi2014 力

```cpp
#include<bits/stdc++.h>
#define il inline
#define vd void
#define mod 1004535809
typedef long long ll;
il int gi(){
    int x=0,f=1;
    char ch=getchar();
    while(!isdigit(ch)){
        if(ch=='-')f=-1;
        ch=getchar();
    }
    while(isdigit(ch))x=x*10+ch-'0',ch=getchar();
    return x*f;
}
il int pow(int x,int y){
    int ret=1;
    while(y){
        if(y&1)ret=1ll*ret*x%mod;
        x=1ll*x*x%mod;y>>=1;
    }
    return ret;
}
#define inv(a) pow((a),mod-2)
const int G=3,iG=inv(G);
int fact[10000001],W[100010];
int A[262147],B[262147],rev[262147];
il int C(int n,int m){
    if(n<m)return 0;
    return 1ll*fact[n]*inv(1ll*fact[m]*fact[n-m]%mod)%mod;
}
il vd ntt(int*A,int n,int t){
    for(int i=0;i<n;++i)if(rev[i]>i)std::swap(A[rev[i]],A[i]);
    for(int o=1;o<n;o<<=1){
        int W=pow(t?G:iG,(mod-1)/(o<<1));
        for(int*p=A;p!=A+n;p+=o<<1)
            for(int i=0,w=1;i<o;++i,w=1ll*w*W%mod){
                int t=1ll*w*p[i+o]%mod;
                p[i+o]=(p[i]-t+mod)%mod,p[i]=(p[i]+t)%mod;
            }
    }
    if(!t){
        int invN=inv(n);
        for(int i=0;i<n;++i)A[i]=1ll*invN*A[i]%mod;
    }
}
int main(){
    int n=gi(),m=gi(),s=gi();
    for(int i=0;i<=m;++i)W[i]=gi();
    int LIM=std::max(m,n);
    fact[0]=1;for(int i=1;i<=LIM;++i)fact[i]=1ll*fact[i-1]*i%mod;
    int lim=std::min(m,n/s);
    int N=1,lg=0;while(N<(lim+1)<<1)N<<=1,++lg;
    for(int i=0;i<=lim;++i)A[i]=1ll*fact[i]*C(m,i)%mod*fact[n]%mod*pow(m-i,n-i*s)%mod*inv(1ll*pow(fact[s],i)*fact[n-i*s]%mod)%mod;
    for(int i=0;i<=lim;++i){
        B[i]=inv(fact[lim-i]);
        if((lim-i)&1)B[i]=mod-B[i];
    }
    for(int i=0;i<N;++i)rev[i]=(rev[i>>1]>>1)|((i&1)<<lg-1);
    ntt(A,N,1),ntt(B,N,1);
    for(int i=0;i<N;++i)A[i]=1ll*A[i]*B[i]%mod;
    ntt(A,N,0);
    int ans=0;
    for(int i=0;i<=lim;++i)ans=(ans+1ll*W[i]*A[lim+i]%mod*inv(fact[i])%mod)%mod;
    printf("%d\n",ans);
    return 0;
}
```


---

## 作者：Great_Influence (赞：22)

本做法为zhou888同学现场推出来的NTT做法，放出来可以%一%。

设$N=\min\{\lfloor\frac{n}{S}\rfloor,m\}$，则考虑一个暴力容斥:


$ans=\sum\limits_{i=0}^Nw[i]{m\choose i}{n\choose is}\frac{(is)!}{(s!)^i}\sum\limits_{j=0}^{N-i}(-1)^j{m-i\choose j}{n-is\choose js}\frac{(js)!}{(s!)^j}(m-i-j)^{n-is-js}$

然后拆开划式子:

$ans=\sum\limits_{i=0}^Nw[i]{m\choose i}{n\choose is}(is)!\sum\limits_{j=i}^{N}{m-i\choose j-i}(-1)^{j-i}{n-is\choose js-is}(js)!(\frac{1}{s!})^j(m-j)^{n-js}$

$=\sum\limits_{i=0}^Nw[i]\frac{m!n!}{i!(m-i)!(is)!(n-is)!}(is!)\sum\limits_{j=i}^{N}(-1)^{j-i}\frac{(m-i)!(n-is)!}{(m-j)!(j-i)!(n-js)!(js-is)!}(js-is)!(\frac{1}{s!})^j(m-j)^{n-js}$

$=\sum\limits_{j=0}^{N}\sum\limits_{i=0}^jw[i](-1)^{j-i}\frac{m!n!}{i!(is)!}\frac{(is)!(js-is)!(m-j)^{n-js}}{(m-j)!(j-i)!(n-js)!(js-is)!}(\frac{1}{s!})^j$

$=\sum\limits_{j=0}^{N}\frac{m!n!}{(m-j)!(n-js)!}(\frac{1}{s!})^j(m-j)^{n-js}\sum\limits_{i=0}^j(-1)^{j-i}\frac{w[i]}{i!}*\frac{1}{(j-i)!}$

$=\sum\limits_{j=0}^{N}\frac{m!n!}{(m-j)!(n-js)!}(\frac{1}{s!})^j(m-j)^{n-js}\sum\limits_{i=0}^j\frac{w[i]}{i!}*\frac{(-1)^{j-i}}{(j-i)!}$

发现后方为卷积形式，直接NTT即可。

时间复杂度$O(nlog_2n)$。

代码：

```cpp
#include<bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp>
#define Rep(i,a,b) for(register int i=(a),i##end=(b);i<=i##end;++i)
#define Repe(i,a,b) for(register int i=(a),i##end=(b);i>=i##end;--i)
#define For(i,a,b) for(i=(a),i<=(b);++i)
#define Forward(i,a,b) for(i=(a),i>=(b);--i)
template<typename T>inline void read(T &x)
{
	T f=1;x=0;char c;
	for(c=getchar();!isdigit(c);c=getchar())if(c=='-')f=-1;
	for(;isdigit(c);c=getchar())x=x*10+(c^48);
	x*=f;
}
using namespace std;
void file()
{
#ifndef ONLINE_JUDGE
	freopen("color.in","r",stdin);
	freopen("color.out","w",stdout);
#endif
}

const int MAXN=1e7+7,MAXM=1e6+7,mod=1004535809,g=3;

static int n,m,s,N,w[MAXM];

inline void init()
{
	read(n);read(m);read(s);
	N=min(m,n/s);
	Rep(i,0,m)read(w[i]);
}

static int func[MAXN],inv[MAXN];

#define ll long long

inline int power(int a,int b)
{
	static int sum;
	for(sum=1;b;b>>=1,a=(ll)a*a%mod)if(b&1)
		sum=(ll)sum*a%mod;
	return sum;
}

static int len,rev[MAXM<<2],a[MAXM<<2],b[MAXM<<2],invN,invS;
inline void NTT(int *X,int typ)
{
	Rep(i,1,len-1)if(i<rev[i])swap(X[i],X[rev[i]]);
	static int i,j,k,kk,w,wn,t;
	for(k=2,kk=1;k<=len;k<<=1,kk<<=1)
	{
		wn=power(g,(mod-1)/k);
		for(i=0;i<len;i+=k)
			for(w=1,j=0;j<kk;++j,w=(ll)w*wn%mod)
			{
				t=(ll)w*X[i+j+kk]%mod;
				X[i+j+kk]=(X[i+j]-t+mod)%mod;
				X[i+j]=(X[i+j]+t)%mod;
			}
	}
	if(typ<0)
	{
		reverse(X+1,X+len);
		static int invN=power(len,mod-2);
		Rep(i,0,len-1)X[i]=(ll)X[i]*invN%mod;
	}
}

inline void solve()
{
	func[0]=1;
	Rep(i,1,max(max(n,s),m))func[i]=(ll)func[i-1]*i%mod;
	inv[max(max(n,s),m)]=power(func[max(n,max(s,m))],mod-2);
	Repe(i,max(max(n,m),s),1)inv[i-1]=(ll)inv[i]*i%mod;
	invS=inv[s];
	for(len=2;len<=2*N;len<<=1);
	Rep(i,1,len-1)rev[i]=(rev[i>>1]>>1)|((i&1)*(len>>1));
	Rep(i,0,N)
	{
		a[i]=(ll)inv[i]*w[i]%mod;
		b[i]=(i&1?(ll)mod-1:1)*inv[i]%mod;
	}
	NTT(a,1);NTT(b,1);
	Rep(i,0,len)a[i]=(ll)a[i]*b[i]%mod;
	NTT(a,-1);
	static int ans=0;
	Rep(i,0,N)
		ans=(ans+(ll)inv[m-i]*inv[n-i*s]%mod*power(invS,i)%mod*power(m-i,n-i*s)%mod*a[i]%mod)%mod;
	printf("%d\n",(ll)ans*func[n]%mod*func[m]%mod);
}

int main()
{
	file();
	init();
	solve();
	return 0;
}

```

---

## 作者：Owen_codeisking (赞：15)

# [更好的阅读体验戳这里](https://www.cnblogs.com/owencodeisking/p/10279539.html)

补充一篇详细得不能再详细的题解，比如让我自己看懂。

可能与前面的题解有些相同，我想补充一下自己的想法。

显然，最多 $K$ 最大为 $N=min(\lfloor \frac nS\rfloor,m)$

首先，我们看到出现 $S$ 次的颜色**恰好** $K$ 种的话，我们就可以考虑容斥，将其化为出现 $S$ 次的颜色**至少** $K$ 种的方案数 $f[K]$

那么先选定在 $m$ 中颜色中选定 $i$ 种颜色，有 $C_m^i$ 种

选定在 $n$ 个位置中选定 $iS$ 个位置，有 $C_n^{iS}$ 种

但是 $iS$ 个位置中随机排列的话，**因为颜色相同交换算一种**，所以有 $\frac {iS!}{(S!)^i}$ 种

其他位置可以乱选，剩下 $m-i$ 中颜色，$n-iS$ 个位置，有 $(m-i)^{n-iS}$ 种

那么乘法原理，$f[i]=C_m^iC_n^{iS}\frac {iS!}{(S!)^i}(m-i)^{n-iS}$

现在定义 $ans[i]$ 为出现 $S$ 次颜色**恰好** $K$ 种的方案数，开始容斥。首先想到容斥系数 $(-1)^{j-i}$

然后在 $j$ 种颜色中 $i$ 种颜色的方案数被算了 $C_j^i$ 次

那么可以推出：

$ans[i]=\sum_{j=i}^{N}(-1)^{j-i}C_j^if[j]$

$ans[i]=\sum_{j=i}^{N}(-1)^{j-i}\frac {j!}{i!(j-i)!}f[j]$

$ans[i]\times i!=\sum_{j=i}^{N}(-1)^{j-i}\frac {1}{(j-i)!}f[j]\times j!$

定义 $F(x)=\frac {(-1)^i}{i!}\ x^i,G(x)=f[i]\times i!\ x^i$

但是这样还不能卷积。我们将 $G(x)$ 系数翻转一下，$ans[i]\times i!=F(x)*G(x)$ 中 $x^{N-i}$ 项的系数

那么最终 $Ans=\sum_{i=0}^{N}w[i]\times ans[i]$。用 $NTT$ 实现多项式乘法，时间复杂度 $O(n\log n)$

$Code\ Below:$

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int maxn=100000+10;
const int maxm=10000000+10;
const int mod=1004535809;
int n,m,s,N,lim,w[maxn],f[maxn],a[maxn<<2],b[maxn<<2],r[maxn<<2],fac[maxm],inv[maxm];

inline int read(){
	register int x=0,f=1;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}
	while(isdigit(ch)){x=(x<<3)+(x<<1)+ch-'0';ch=getchar();}
	return (f==1)?x:-x;
}

int C(int n,int m){
	if(n<m) return 0;
	return 1ll*fac[n]*inv[m]%mod*inv[n-m]%mod;
}

int fpow(int a,int b){
	int ret=1;
	for(;b;b>>=1,a=1ll*a*a%mod)
		if(b&1) ret=1ll*ret*a%mod;
	return ret;
}

void NTT(int *f,int n,int op){
	for(int i=0;i<n;i++)
		if(i<r[i]) swap(f[i],f[r[i]]);
	int buf,tmp,x,y;
	for(int len=1;len<n;len<<=1){
		tmp=fpow(3,(mod-1)/(len<<1));
		if(op==-1) tmp=fpow(tmp,mod-2);
		for(int i=0;i<n;i+=len<<1){
			buf=1;
			for(int j=0;j<len;j++){
				x=f[i+j];y=1ll*buf*f[i+j+len]%mod;
				f[i+j]=(x+y)%mod;f[i+j+len]=(x-y+mod)%mod;
				buf=1ll*buf*tmp%mod;
			}
		}
	}
	if(op==1) return ;
	int inv=fpow(n,mod-2);
	for(int i=0;i<n;i++) f[i]=1ll*f[i]*inv%mod;
}

int main()
{
	scanf("%d%d%d",&n,&m,&s);N=min(n/s,m);
	for(int i=0;i<=m;i++) scanf("%d",&w[i]);
	fac[0]=fac[1]=inv[0]=inv[1]=1;
	for(int i=2;i<=max(n,m);i++){
		fac[i]=1ll*fac[i-1]*i%mod;
		inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;
	}
	for(int i=2;i<=max(n,m);i++) inv[i]=1ll*inv[i]*inv[i-1]%mod;
	for(int i=0;i<=N;i++) f[i]=1ll*C(m,i)*C(n,i*s)%mod*fac[i*s]%mod*fpow(inv[s],i)%mod*fpow(m-i,n-i*s)%mod;
	for(int i=0;i<=N;i++){
		a[i]=(((i&1)?-1:1)*inv[i]+mod)%mod;
		b[i]=1ll*f[i]*fac[i]%mod;
	}
	reverse(b,b+N+1);
	for(lim=1;lim<=(N<<1);lim<<=1);
	for(int i=0;i<lim;i++) r[i]=(r[i>>1]>>1)|((i&1)?(lim>>1):0);
	NTT(a,lim,1);NTT(b,lim,1);
	for(int i=0;i<lim;i++) a[i]=1ll*a[i]*b[i]%mod;
	NTT(a,lim,-1);
	reverse(a,a+N+1);
	int ans=0;
	for(int i=0;i<=N;i++) ans=(ans+1ll*w[i]*a[i]%mod*inv[i]%mod)%mod;
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：Soulist (赞：13)

令$f(i)$表示至少有$i$个出现次数为$\rm S$的数量数

需要注意的是如果$iS>n$则答案为$0$

考虑如何计算$f(i)$，不妨令$d_i$表示颜色$i$的出现次数

对于一组给定的$d_1+d_2+...+d_m=n$显然有方案数为一个混合组合数即：

$$\dfrac{n!}{d_1!d_2!d_3!...d_m!}$$

于是可以考虑到两个指数型生成函数：

$$F(x)=\dfrac{x^S}{S!}$$

$$G(x)=\sum_{i=0}^{\infty} \dfrac{x^i}{i!}=e^x$$

由于$f_i$表示至少出现了$i$个出现次数为$S$的答案，于是有：

$$f(i)=\dbinom{m}{i}F^{i}G^{m-i}\times n![x^n]$$

初步化简得：

$$f(i)=\dbinom{m}{i} G^{m-i}\dfrac{n!}{(S!)^i}[x^{n-iS}]$$

$$f(i)=\dbinom{m}{i} G^{m-i}\dfrac{n!}{(S!)^i}[x^{n-iS}]\times \dfrac{(n-iS)!}{(n-iS)!}$$

需要注意的是$G^{m-i}=(e^x)^{m-i}=e^{(m-i)x}$

而且我们知道$e^kx=\sum_{i=0}^{\infty} \dfrac{k^ix^i}{i!}$

所以$G^{m-i}[x^{n-iS}]\times (n-iS)!=(m-i)^{n-iS}$

于是得：

$$f(i)=\dbinom{m}{i}\dfrac{(m-i)^{n-iS}n!}{(n-iS)!(S!)^i}$$

然后考虑令$g(i)$表示恰好为$i$个$S$

则可以得到：

由于：

$$f(i)=\sum_{k=i}^{m} \dbinom{k}{i}g_k$$

则改一下就是：

$$g(i)=f(i)-\sum_{k=i+1}^m \dbinom{k}{i} g_k$$

这样已经可以$O(m^2)$了...

但由二项式反演，所以有：

$$g(i)=\sum_{k=i}^n(-1)^{k-i}\dbinom{k}{i}f_k$$

$$g(i)=\sum_{k=i}^{n} \dfrac{(-1)^{k-i}k!f_k}{i!(k-i)!}$$

我们将$f$并将下标中的最底层当作$0$开始然后翻转后可以得到$($将所有$i,k$用$m-i,m-k)$替换得：

$$g(i)=\sum_{k=0}^i \dfrac{(-1)^{i-k}(m-k)!rev_{k}}{(m-i)!(i-k)!}$$

不妨令$r(k)=(m-k)!rev_k(-1)^{-k}$

容易发现$g(x)=\dfrac{(-1)^i}{(m-x)!}\sum_{i+j=x}r(i)\times (j!)^{-1}$

于是卷起来就可以了。。。

需要注意的是$g_i$也是反过来的

话说我应该没有把二项式反演弄错吧。。。

写了个暴力验证发现没错。。。

然后改了好久终于写出来了。。。mmp最后$NTT(a,-1)$的时候弄错了对象。。。

```cpp
#include<bits/stdc++.h>
using namespace std ;
#define drep( i, s, t ) for( register int i = t; i >= s; -- i )
#define rep( i, s, t ) for( register int i = s; i <= t; ++ i )
#define re register
#define int long long
int gi() {
	char cc = getchar() ; int cn = 0, flus = 1 ;
	while( cc < '0' || cc > '9' ) {  if( cc == '-' ) flus = - flus ; cc = getchar() ; }
	while( cc >= '0' && cc <= '9' )  cn = cn * 10 + cc - '0', cc = getchar() ;
	return cn * flus ;
}
const int P = 1004535809 ;
const int Gi = 334845270 ; 
const int G = 3 ;
const int N = 1e5 + 5 ; 
const int M = 1e7 + 5 ; 
int n, m, S, I1, L, Ans, Inv, limit = 1, w[N], f[N], g[N] ;
int fac[M], inv[M], R[N << 2], rev[N << 2], A[N << 2] ; 
int fpow( int x, int k ) {
	int ans = 1, base = x ; 
	while( k ) {
		if( k & 1 ) ans = ( ans * base ) % P ;
		base = ( base * base ) % P, k >>= 1 ; 
	} return ans ; 
}
int F( int x ) {
	if( x * S > n ) return 0 ; 
	int a = fpow( m - x, n - x * S ) * fac[n] % P ; 
	int b = fac[n - x * S] * fpow( fac[S], x ) % P ;
	return a * fpow( b, P - 2 ) % P ; 
}
void Init() {
	int t = max( n, m ) + 1 ; I1 = P - 1 ; 
	rep( i, 0, m ) w[i] = gi() ; 
	inv[0] = fac[0] = 1 ; 
	rep( i, 1, t ) fac[i] = fac[i - 1] * i % P ;
	inv[t] = fpow( fac[t], P - 2 ) ;
	drep( i, 1, t ) inv[i - 1] = ( inv[i] * i ) % P ; 
}
void init( int x ) {
	while( limit <= x ) limit <<= 1, ++ L ; 
	rep( i, 0, limit ) R[i] = ( R[i >> 1] >> 1 ) | ( ( i & 1 ) << ( L - 1 ) ) ;
	Inv = fpow( limit, P - 2 ) ;
}
void NTT( int *a, int type ) { 
	for( re int i = 0; i < limit; ++ i ) if( R[i] > i ) swap( a[i], a[R[i]] ) ;
	for( re int k = 1; k < limit; k <<= 1 ) {
		int d = fpow( ( type == 1 ) ? G : Gi, ( P - 1 ) / ( k << 1 ) ) ;
		for( re int i = 0; i < limit; i += ( k << 1 ) ) 
		for( re int j = i, g = 1; j < i + k; ++ j, g = ( g * d ) % P ) {
			int Nx = a[j], Ny = a[j + k] * g % P ;
			a[j] = ( Nx + Ny ) % P, a[j + k] = ( Nx - Ny + P ) % P ;  
		}
	}
	if( type != 1 ) rep( i, 0, limit ) a[i] = a[i] * Inv % P ; 
} 
signed main()
{
	n = gi(), m = gi(), S = gi(), Init() ;
	rep( i, 0, m ) f[i] = 1ll * fac[m] * inv[i] % P * inv[m - i] % P * F(i) % P ; 
	rep( i, 0, m ) rev[i] = f[m - i] * fac[m - i] % P * fpow( I1, P - i - 1 ) % P, A[i] = inv[i] ; 
	init( m + m ), NTT( rev, 1 ), NTT( A, 1 ) ;
	rep( i, 0, limit ) rev[i] = rev[i] * A[i] % P ; NTT( rev, -1 ) ;
	rep( i, 0, m ) g[i] = rev[i] * fpow( I1, i ) % P * inv[m - i] % P ;
	rep( i, 0, m ) Ans = ( Ans + g[m - i] * w[i] % P ) % P ; 
	printf("%lld\n", Ans ) ; 
	return 0 ;
}
```

这道题和$[$珍珠$]$挺像的...貌似珍珠按照这个容斥做法只需要补一个二项式定理然后用$NTT$算$f$后再容斥，这道题代码还挺短的。。。

---

## 作者：xiezheyuan (赞：6)

> **摘要**：这里介绍仅使用 EGF 而不使用二项式反演的一种解法。

前置知识：指数生成函数（EGF）、多项式乘法（卷积，NTT）。

## 简要题意

给定一个长度为 $n$ 的纸带，你需要用最多 $m$ 种颜色给纸带的每一个位置染色。

若有 $k$ 种颜色恰好出现了 $S$ 次，则会获得 $W_k$ 的收益。你需要输出所有染色方案的收益总和。

答案对 $1004535809$ 取模。

$1\leq n\leq 10^7,1\leq m\leq 10^5,1\leq S\leq 150$。

## 思路

首先考虑设 $f(z)$ 表示有 $z$ 种颜色恰好出现 $S$ 次的方案数，则答案就是：

$$
\sum_{i=0}^{m}W_if(i)
$$

求 $f(z)$ 不妨考虑生成函数。我们将颜色分为恰好出现 $S$ 次的（下面成为关键色）以及恰好出现非 $S$ 次的（下面称为一般色）。由于纸带染色问题属于有标号体系，所以我们需要使用 EGF。

先构造关键色的生成函数：

$$
\hat{\mathbf{F}}_1 = \frac{x^S}{S!}
$$

然后是一般色的生成函数：

$$
\hat{\mathbf{F}}_0=-\frac{x^S}{S!}+\sum_{k=0}^{+\infty} \frac{x^k}{k!}=e^x-\frac{x^S}{S!}
$$

则有：

$$
f(z)=\binom{m}{z}\cdot n!\cdot [x^n]\left(\left(\hat{\mathbf{F}}_1\right)^z\cdot \left(\hat{\mathbf{F}}_0\right)^{m-z}\right)
$$

然后就是大力化式子，先考虑化简后面的多项式：

$$
\begin{aligned}
&\left(\hat{\mathbf{F}}_1\right)^z\cdot \left(\hat{\mathbf{F}}_0\right)^{m-z}\\
&=\left(\frac{x^S}{S!}\right)^z\cdot \left(e^x-\frac{x^S}{S!}\right)^{m-z}\\
&=\frac{x^{Sz}}{(S!)^z}\cdot \sum_{k=0}^{m-z}\binom{m-z}{k}e^{xk}\frac{x^{Sm-Sz-Sk}}{(S!)^{m-z-k}}(-1)^{m-k-z}\\
&=\sum_{k=0}^{m-z}\binom{m-z}{k}e^{xk}\frac{x^{Sm-Sk}}{(S!)^{m-k}}(-1)^{m-k-z}\\
&=\sum_{k=0}^{m-z}\binom{m-z}{k}\frac{x^{Sm-Sk}}{(S!)^{m-k}}(-1)^{m-k-z}\sum_{t=0}^{+\infty}\frac{k^t}{t!}x^t
\end{aligned}
$$

考虑它的 $x^n$ 项系数到底是什么，不难发现需要满足 $S(m-k)+t=n$，也就是 $t=n-S(m-k)$，代入：

$$
\begin{aligned}
&[x^n]\sum_{k=0}^{m-z}\binom{m-z}{k}\frac{x^{Sm-Sk}}{(S!)^{m-k}}(-1)^{m-k-z}\sum_{t=0}^{+\infty}\frac{k^t}{t!}x^t\\
&=\sum_{k=0}^{m-z}\binom{m-z}{k}\frac{k^{n-S(m-k)}(-1)^{m-k-z}}{(n-S(m-k))!(S!)^{(m-k)}}\\
&=(m-z)!\sum_{k=0}^{m-z}\frac{k^{n-S(m-k)}(-1)^{m-k-z}}{(n-S(m-k))!(S!)^{(m-k)}(m-k-z)!k!}
\end{aligned}
$$

换元，令 $k\leftarrow m-k$，得：

$$
(m-z)!\sum_{k=z}^{m}\frac{(m-k)^{n-Sk}(-1)^{k-z}}{(n-Sk)!(S!)^{k}(k-z)!(m-k)!}
$$

令：

$$
g(k)= \frac{(m-k)^{n-Sk}}{(n-Sk)!(m-k)!(S!)^k}
$$

则得到：

$$
\begin{aligned}
&(m-z)!\sum_{k=z}^{m}\frac{(m-k)^{n-Sk}(-1)^{k-z}}{(n-Sk)!(S!)^{k}(k-z)!(m-k)!}\\
&=(m-z)!\sum_{k=z}^{m}\frac{(-1)^{k-z}}{(k-z)!}g(k)
\end{aligned}
$$

改为枚举 $k-z$ 得：

$$
\begin{aligned}
&(m-z)!\sum_{k=z}^{m}\frac{(-1)^{k-z}}{(k-z)!}g(k)\\
&=(m-z)!\sum_{k=0}^{m}\frac{(-1)^k}{k!}g(k+z)
\end{aligned}
$$

令 $g'(k)=g(m-k)$，得：

$$
\begin{aligned}
&(m-z)!\sum_{k=0}^{m}\frac{(-1)^k}{k!}g(k+z)\\
&=(m-z)!\sum_{k=0}^{m}\frac{(-1)^k}{k!}g'((m-z)-k)
\end{aligned}
$$

最终得到：

$$
f(z)=\binom{m}{z}n!(m-z)!\sum_{k=0}^{m}\frac{(-1)^k}{k!}g'((m-z)-k)
$$

注意到后面那个式子可以看成一个卷积形式，答案就是卷积的 $x^{m-z}$ 项系数。因此我们可以构造两个多项式，一遍多项式卷积就可以求出后面那个和式的值。

时间复杂度 $O(n+m\log m)$。

## 代码

多项式模板过长，已经省略，下面展示核心代码：

```cpp
int n, m, s, fact[N], inv[N], w[N];

int binom(int x, int y){ return Mul(fact[x], Mul(inv[y], inv[x - y])); }

signed main(){
    ios::sync_with_stdio(false);
    cin.tie(0);cout.tie(0);
    cin >> n >> m >> s;
    for(int i=0;i<=m;i++) cin >> w[i];
    fact[0] = fact[1] = inv[0] = inv[1] = 1;
    for(int i=2;i<=max(n, m);i++){
        fact[i] = Mul(fact[i-1], i);
        inv[i] = Mul(mod - mod / i, inv[mod % i]);
    }
    for(int i=2;i<=max(n, m);i++) inv[i] = Mul(inv[i], inv[i-1]);
    Poly poly(m + 1);
    for(int k=0;k<=m;k++){
        if(n - 1ll * s * k < 0) continue;
        int tmp = fastpow(m - k, n - 1ll * s * k);
        tmp = Mul(tmp, inv[n - 1ll * s * k]);
        tmp = Mul(tmp, inv[m - k]);
        tmp = Mul(tmp, fastpow(inv[s], k));
        poly[k] = tmp;
    }
    reverse(poly.a.begin(), poly.a.end());
    Poly poly2(m + 1);
    for(int k=0;k<=m;k++){
        int tmp = inv[k];
        if(k & 1) tmp = mod - tmp;
        poly2[k] = tmp;
    }
    poly = poly * poly2;
    int ans = 0;
    for(int i=0;i<=m;i++){
        int tmp = Mul(fact[m - i], fact[n]);
        tmp = Mul(tmp, poly[m - i]);
        tmp = Mul(tmp, binom(m, i));
        tmp = Mul(tmp, w[i]);
        ans = Add(ans, tmp);
    }
    cout << ans << '\n';
    return 0;
}

// Written by xiezheyuan
```

---

## 作者：Orion545 (赞：4)

# 广告

[蒟蒻のblog](https://www.cnblogs.com/dedicatus545/p/9159192.html)

# 思路

这道题的核心在于“**恰好**有$k$种颜色占了**恰好**$s$个格子”

这些“恰好”，引导我们去思考，怎么求出总的方案数呢？

### 分开考虑

考虑把恰好有$s$个格子的颜色，和不是$s$个颜色的格子分开来考虑

那么，显然答案可以用这样的一个式子表示：

令$lim=min(\lfloor\frac ns\rfloor,m)$，那么：

### $ans=\sum_{i=0}^{lim}w_iC_m^iC_n^{is}\frac{(is)!}{(s!)^i}g(m-i,n-is)$

其中$g(i,j)$表示把$i$种颜色放进$j$个格子里面，没有“恰好占了$s$个格子”的颜色的方案总数

这个$g$显然可以容斥原理来做

### 容斥原理

考虑对$g$用容斥原理推导，可得到如下公式：

### $g(i,j)=\sum_{k=0}^i(-1)^kC_i^kC_j^{ks}\frac{(ks)!}{(s!)^k}(i-k)^{j-ks}$

把这个公式代回原式，可得到：

### $ans=\sum_{i=0}^{lim}w_iC_m^iC_n^{is}\frac{(is)!}{(s!)^i}\sum_{j=0}^{lim-i}(-1)^jC_{m-i}^jC_{n-is}^{js}\frac{(js)!}{(s!)^j}(m-i-j)^{n-is-js}$

我们发现这个玩意儿好像比较复杂，没有什么特殊性质

难道这条路走不通？

### 构造卷积

我们发现后面的这个代表$g$的这一部分里面，有很多的$j$在，

那么我们想一想，$j$的枚举是所有比当前的$i$小的，那么只要把$j$用另一个东西：$j-i$替代了，然后把$j$变成所有比当前的大的，那么是不是和这个式子等价了呢？

说干就干！

### $ans=\sum_{i=0}^{lim}w_iC_m^iC_n^{is}\frac{(is)!}{(s!)^i}\sum_{j=lim-i}^{lim}(-1)^{j-i}C_{m-i}^{j-i}C_{n-is}^{js-is}\frac{(js-is)!}{(s!)^{j-i}}(m-j)^{n-js}$

诶，这样一变化......后面的式子里这么多$j-i$，前面又是$i$，这让我们想到了什么？

**处理卷积啊！**

### 变换枚举方式

我们先把这些个烦人的组合数拆成阶乘的形式

### $ans=\sum_{i=0}^{lim}w_i\frac{m!n!}{i!(is)!(m-i)!(n-is)!}\frac{(is)!}{(s!)^i}\sum_{j=lim-i}^{lim}(-1)^{j-i}\frac{(m-i)!(n-is)!}{(j-i)!(js-is)!(m-j)!(n-js)!}\frac{(js-is)!}{(s!)^{j-i}}(m-j)^{n-js}$

我们把左边的项挪进右边的最后一个sigma里面，然后把$ij$的枚举顺序反过来，得到：

### $ans=\sum_{j=0}^{lim}\sum_{i=0}^{j}w_i\frac{m!n!}{i!(is)!(m-i)!(n-is)!}\frac{(is)!}{(s!)^i}(-1)^{j-i}\frac{(m-i)!(n-is)!}{(j-i)!(js-is)!(m-j)!(n-js)!}\frac{(js-is)!}{(s!)^{j-i}}(m-j)^{n-js}$

发现有很多项可以消掉了

### $ans=\sum_{j=0}^{lim}\sum_{i=0}^{j}w_i\frac{m!n!}{i!(s!)^i}(-1)^{j-i}\frac{1}{(j-i)!(m-j)!(n-js)!}\frac{1}{(s!)^{j-i}}(m-j)^{n-js}$

再合并一下各个分数线

### $ans=\sum_{j=0}^{lim}\sum_{i=0}^{j}(-1)^{j-i}\frac{w_im!n!}{i!(s!)^j(j-i)!(m-j)!(n-js)!}(m-j)^{n-js}$

把所有只含$j$的提到前面一个sigma去

### $ans=\sum_{j=0}^{lim}\frac{m!n!(m-j)^{n-js}}{(s!)^j(m-j)!(n-js)!}\sum_{i=0}^{j}\frac{(-1)^{j-i}w_i}{i!(j-i)!}$

发现后面是一个卷积的形式！

设$a(i)=\frac{w_i}{i!},b(i)=\frac{(-1)^i}{i!}$

那么：

### $ans=\sum_{j=0}^{lim}\frac{m!n!(m-j)^{n-js}}{(s!)^j(m-j)!(n-js)!}(a\ast b)(j)$

所有的逆元、阶乘都可以$O(n)$预处理，卷积使用模数为998244353的$NTT$来实现，总时间复杂度为$O(n+limlog_2lim)$

# Code:

我的代码好像常数比较大......如果有知道怎么优化的dalao，麻烦在评论区帮忙指出一下！

不胜感激！

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define ll long long
using namespace std;
inline ll read(){
	ll re=0,flag=1;char ch=getchar();
	while(ch>'9'||ch<'0'){
		if(ch=='-') flag=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9') re=(re<<1)+(re<<3)+ch-'0',ch=getchar();
	return re*flag;
}
ll MOD=1004535809,g=3,f[10000010],finv[10000010],w[10000010],invlimit;
ll qpow(ll a,ll b){
	ll re=1;
	while(b){
		if(b&1) re=re*a%MOD;
		a=a*a%MOD;b>>=1;
	}
	return re;
}
ll A[400010],B[400010],r[400010],n,limit,cnt,m,S,N,invg;
void init(){
	limit=1;cnt=0;ll i;
	while(limit<=(N<<1)) limit<<=1,cnt++;
	for(i=0;i<limit;i++) r[i]=((r[i>>1]>>1)|((i&1)<<(cnt-1)));
	f[1]=finv[1]=f[0]=finv[0]=1;
	for(i=2;i<=max(max(n,m),S);i++){
		f[i]=f[i-1]*i%MOD;
	} 
	finv[max(max(n,m),S)]=qpow(f[max(max(n,m),S)],MOD-2);
	for(i=max(max(n,m),S);i>=1;i--) finv[i-1]=finv[i]*i%MOD;
	invlimit=qpow(limit,MOD-2);invg=qpow(g,MOD-2);
}
void ntt(ll *a,ll type){
	ll i,j,k,mid,len;ll y,w,wn;
	for(i=0;i<limit;i++) if(i<r[i]) swap(a[i],a[r[i]]);
	for(mid=1;mid<limit;mid<<=1){
		len=mid<<1;
		wn=qpow(((type==1)?g:invg),(MOD-1)/len);
		for(j=0;j<limit;j+=len){
			w=1;
			for(k=0;k<mid;k++,w=w*wn%MOD){
				y=a[j+k+mid]*w%MOD;
				a[j+k+mid]=(a[j+k]-y+MOD)%MOD;
				a[j+k]=(a[j+k]+y)%MOD;
			}
		}
	}
	if(type==-1) for(i=0;i<limit;i++) a[i]=(a[i]*invlimit%MOD);
}
int main(){
	n=read();m=read();S=read();N=min(n/S,m);ll i;
	for(i=0;i<=m;i++) w[i]=read();
	init();
	for(i=0;i<=N;i++){
		A[i]=finv[i]*w[i]%MOD;
		B[i]=((i&1)?MOD-1:1)*finv[i]%MOD;
	}
	ntt(A,1);ntt(B,1);
	for(i=0;i<limit;i++) A[i]=A[i]*B[i]%MOD;
	ntt(A,-1);
	ll ans=0;
	for(i=0;i<=N;i++){
		ans=(ans+(finv[m-i]*finv[n-i*S]%MOD*qpow(finv[S],i)%MOD*qpow(m-i,n-i*S)%MOD*A[i]))%MOD;
	}
	printf("%lld\n",ans*f[n]%MOD*f[m]%MOD);
}
```

---

## 作者：Taduro (赞：3)

一股套路题的味道。。。

首先真正的颜色数$x=min(m,n/s)$。

考虑容斥：$f_i$表示至少有i种颜色出现S次的方案数。

那么

$$f_i=C^i_mC^{i\times s}_n\times\frac{(i\times s)!}{(s!)^i}\times (m-i)^{n-i\times s}$$

有至少就有恰好:

$$g_k=\sum_{i=k}^n(-1)^{i-k}C^k_if_i$$

$$
=\sum_{i=k}^n(-1)^{i-k}\frac{i!}{(i-k)!k!}f_i
$$

$$
=\frac{1}{k!}\sum_{i=k}^n\frac{(-1)^{i-k}}{(i-k)!}\times f_i\times i!
$$

这是个套路啊。。。

设$A_i=\frac{(-1)^i}{i!}$，$B_i=f_i\times i!$。因为$i-k$和$i$的差是定值，把$B$反向，令$B'_i=B_{x-i}$。

就出现了$x-i+i-k=x-k$，那么令$A\times B'=C$

$C_k$就是恰好$x-k$种颜色的方案数，反过来，恰好$k$种颜色的方案数就是$C_{x-k}$。

NTT即可。

```c++
#include<cstdio>
#include<iostream>
using namespace std;
const int rt=3,mod=1004535809;
int w[100001],f[500001],g[500001],n,m,l,r[500001];
int lim,t,jc[10000001],ny[10000001],so[10000001];
int po[500001],pv[500001],ans,s;
inline int add(int x,int y){return x+y>=mod?x+y-mod:x+y;}
inline int dec(int x,int y){return x-y<0?x-y+mod:x-y;}
inline int mul(int x,int y){return 1ll*x*y-1ll*x*y/mod*mod;}
inline int C(int x,int y){return mul(jc[y],mul(ny[y-x],ny[x]));}
inline int ksm(int x,int y){
	int num=1;
	while (y){
		if (y&1) num=mul(num,x);
		x=mul(x,x); y>>=1;
	}
	return num;
}
inline void NTT(int *a,int inv){
	for (int i=1; i<lim; i++)
		if (i<r[i]) swap(a[i],a[r[i]]);
	for (int i=1; i<lim; i<<=1){
		int wn=po[i]; if (inv<0) wn=pv[i];
		for (int j=0; j<lim; j+=(i<<1)){
			int w=1;
			for (int k=0; k<i; k++,w=mul(w,wn)){
				int x=a[j+k],y=mul(a[i+j+k],w);
				a[j+k]=add(x,y); a[i+j+k]=dec(x,y);
			}
		}
	}
	if (inv>0) return; inv=ksm(lim,mod-2);
	for (int i=0; i<lim; i++) a[i]=mul(a[i],inv);
}
int main(){
	scanf("%d%d%d",&n,&m,&s);
	for (int i=0; i<=m; i++) scanf("%d",&w[i]);
	jc[0]=jc[1]=ny[0]=ny[1]=so[1]=1; t=max(n,m);
	for (int i=2; i<=t; i++){
		jc[i]=mul(jc[i-1],i);
		so[i]=mul(dec(mod,mod/i),so[mod%i]);
		ny[i]=mul(ny[i-1],so[i]);
	}
	t=min(m,n/s);
	for (int i=0,d=1; i<=t; i++,d=mod-d){
		f[t-i]=mul(C(i,m),C(i*s,n));
		f[t-i]=mul(f[t-i],mul(jc[i*s],ksm(ny[s],i)));
		f[t-i]=mul(f[t-i],ksm(m-i,n-i*s));
		f[t-i]=mul(f[t-i],jc[i]);
		g[i]=mul(d,ny[i]);
	}
	// for (int i=0; i<=t; i++) printf("%d ",g[i]); puts("");
	lim=1;
	while (lim<=t+t) lim<<=1,l++;
	for (int i=1; i<=lim; i++){
		r[i]=(r[i>>1]>>1)|((i&1)<<(l-1));
		po[i]=ksm(rt,(mod-1)/(i<<1));
		pv[i]=ksm(po[i],mod-2);
	}
	NTT(f,1); NTT(g,1);
	for (int i=0; i<lim; i++) f[i]=mul(f[i],g[i]);
	NTT(f,-1);
	for (int i=0; i<=t; i++) ans=add(ans,mul(mul(w[i],f[t-i]),ny[i]));
	printf("%d\n",ans);
	return 0;
}
```



---

## 作者：Hyscere (赞：3)

设$f(i)$表示恰好$i$种颜色有$s$个的方案数，$g(i)$表示至少的方案数。

那么可以得到：
$$g(i)=\sum_{j=i}^Mf(j)=\binom{m}{i}(m-i)^{n-si}\frac{(si)!}{(s!)^i}\binom{n}{si}$$
后面的也比较好理解，第一项枚举放哪些颜色，第二项剩下的颜色随便选，后面两项枚举顺序和硬点的颜色放的位置。

注意这里$M=\min(m,\lfloor n/s \rfloor)$。

那么对这玩意广义容斥一波可以得到：
$$f(i)=\sum_{j=i}^{M}(-1)^{j-i}\binom{j}{i}g(j)$$
$$=\sum_{j=i}^{M}(-1)^{j-i}\binom{j}{i}\binom{m}{j}(m-j)^{n-sj}\frac{(sj)!}{(s!)^j}\binom{n}{sj}$$
$$=\sum_{j=i}^{M}(-1)^{j-i}\binom{j}{i}\binom{m}{j}(m-j)^{n-sj}\frac{n!}{(s!)^j(n-sj)!}$$
把$f$化简一下：
$$f(i)=\sum_{j=i}^{M}(-1)^{j-i}\binom{j}{i}\binom{m}{j}(m-j)^{n-sj}\frac{(sj)!}{(s!)^j}\binom{n}{sj}$$
$$=\frac{1}{i!}\times\sum_{j=i}^{M}(-1)^{j-i}\frac{1}{(j-i)!}\times \frac{m!}{(m-j)!}(m-j)^{n-sj}\frac{n!}{(s!)^j(n-sj)!}$$

那么注意到这是一个卷积的形式，设：
$$s(i)=(-1)^i\frac{1}{i!},t(i)=\frac{m!}{(m-i)!}(m-i)^{n-si}\frac{n!}{(s!)^j(n-si)!}$$
那么：
$$f(i)=\frac{1}{i!}\sum_{j=i}^{M}s(j-i)t(j)$$
这玩意可以$reverse$ $t$之后和$s$卷起来，然后再$reverse$一次，就可以得到后面的卷积了。

具体的可以自己照着上面的步骤推一下。

然后算答案就直接：
$$
ans=\sum_{i=0}^{M}w_if(i)
$$
~~我才没有因为一开始的g(i)写错了调了一晚上呢~~

```c++
#include<bits/stdc++.h>
using namespace std;
 
void read(int &x) {
    x=0;int f=1;char ch=getchar();
    for(;!isdigit(ch);ch=getchar()) if(ch=='-') f=-f;
    for(;isdigit(ch);ch=getchar()) x=x*10+ch-'0';x*=f;
}
 
void print(int x) {
    if(x<0) putchar('-'),x=-x;
    if(!x) return ;print(x/10),putchar(x%10+48);
}
void write(int x) {if(!x) putchar('0');else print(x);putchar('\n');}

#define lf double
#define ll long long 

const int maxn = 6e5+10;
const int inf = 1e9;
const lf eps = 1e-8;
const int mod = 1004535809;

int n,m,S,w[maxn],s[maxn],t[maxn],fac[maxn*100],ifac[maxn*100],r[maxn],N,bit,pos[maxn];

int qpow(int a,int x) {
	int res=1;
	for(;x;x>>=1,a=1ll*a*a%mod) if(x&1) res=1ll*res*a%mod;
	return res;
}

void ntt(int *a,int f) {
	for(int i=0;i<N;i++) if(pos[i]>i) swap(a[i],a[pos[i]]);
	for(int i=1;i<N;i<<=1) {
		int wn=qpow(f==1?3:qpow(3,mod-2),(mod-1)/(i<<1));
		for(int j=0,ww=1;j<N;j+=(i<<1),ww=1)
			for(int k=0;k<i;k++,ww=1ll*ww*wn%mod) {
				int x=a[j+k]%mod,y=1ll*a[i+j+k]*ww%mod;
				a[j+k]=(x+y)%mod,a[i+j+k]=(x-y)%mod;
			}
	}
	if(f==-1) {
		int inv=qpow(N,mod-2);
		for(int i=0;i<N;i++) a[i]=1ll*a[i]*inv%mod;
	}
}

int main() {
	read(n),read(m),read(S);int M=min(m,n/S);
	int L=max(n,m);
	for(int i=0;i<=m;i++) read(w[i]);
	fac[0]=ifac[0]=1;
	for(int i=1;i<=L;i++) fac[i]=1ll*fac[i-1]*i%mod;
	ifac[L]=qpow(fac[L],mod-2);
	for(int i=L-1;i;i--) ifac[i]=1ll*ifac[i+1]*(i+1)%mod;
	for(int i=0,p=1;i<=M;i++,p=-p) s[i]=(p*ifac[i]+mod)%mod;
	for(int i=0;i<=M;i++) t[i]=1ll*fac[m]*ifac[m-i]%mod*qpow(m-i,n-S*i)%mod*fac[n]%mod*qpow(ifac[S],i)%mod*ifac[n-S*i]%mod;
	
	reverse(t,t+M+1);
    N=1;while(N<=M<<1) N<<=1,bit++;
	for(int i=0;i<N;i++) pos[i]=pos[i>>1]>>1|((i&1)<<(bit-1));
	ntt(s,1),ntt(t,1);
	for(int i=0;i<N;i++) r[i]=1ll*s[i]*t[i]%mod;
	ntt(r,-1);
	reverse(r,r+M+1);
	int ans=0;
	for(int i=0;i<=M;i++) ans=(ans+1ll*r[i]*ifac[i]%mod*w[i]%mod)%mod;
	write((ans+mod)%mod);
	return 0;
}
```

---

## 作者：AzusaCat (赞：2)

有一个长度为 $n$ 的序列，你需要给每个位置填上 $m$ 种颜色中的一种，对于一种染色方案，如果恰好被填了 $s$ 次的颜色种类数为 $k$ ，则这种染色方案的价值为 $W_k$ ，求所有染色方案的价值之和对 $1004535809$ 取模。$n\leqslant10^7,m\leqslant10^5,s\leqslant150$。

我们只需要计算出对每个 $k\in[0,\min(m,\lfloor\frac{n}{s}\rfloor)]$ 设那个上界为 $v$ 。恰好被填了 $s$ 次的颜色种类数恰好为 $k$ 的方案数 $f(k)$  然后 $\sum\limits_{i=0}^vw_if(i)$ 就是答案。然后发现 $f(k)$ 不好直接算就用二项式反演来解决。按照套路先设钦定 $k$ 种颜色恰好被填了 $S$ 次剩下随便填的方案数为 $g(k)$ ，那么就有 $f(k)=\sum\limits_{i=k}^{v}(-1)^{i-k}\dbinom{i}{k}g(i)$ 。考虑怎么算出 $g(k)$ ，首先我们要从 $M$ 种颜色里选出钦定的 $k$ 种，方案数为 $\dbinom{m}{k}$ ，然后计算怎么填的方案数。明显方案数与我们先填哪种颜色无关，所以第一种颜色有 $\dbinom{n}{s}$ 种方案，第二种有 $\dbinom{n-s}{s}$ 种方案，以此类推第 $k$ 种颜色有 $\dbinom{n-(k-1)s}{s}$ 种方案。然后填完了 $ks$ 个位置后还剩下 $n-ks$ 个，这些可以随便填钦定颜色之外的颜色，方案数为 $(m-k)^{n-ks}$ 。所以有 $g(k)=(m-k)^{n-ks}\dbinom{m}{k}\prod\limits_{j=0}^{k-1}\dbinom{n-js}{s}$ ，把组合数拆开后为 $g(k)=(m-k)^{n-ks}\dbinom{m}{k}\frac{n!}{(s!)^k(n-ks)!}$ 。然后由于 $m$ 较大，反演回来时需要用 NTT。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int const p=1004535809,g=3,gi=334845270;
int r[400005],A[400005],B[400005],G[400005],w[100005],fac[10000005],inv[10000005];
int pw(int x,int y)
{
	int res=1;
	while(y)
	{
		if(y&1)res=1ll*res*x%p;
		x=1ll*x*x%p;
		y>>=1;
	}
	return res;
}
void ntt(int *f,int n,int op)
{
	for(int i=1;i<n;i++)r[i]=(r[i>>1]>>1)+((i&1)?(n>>1):0);
	for(int i=0;i<n;i++)if(i<r[i])swap(f[i],f[r[i]]);
	for(int len=2;len<=n;len<<=1)
	{
		int q=len>>1,wn=pw(op==1?g:gi,(p-1)/len);
		for(int i=0;i<n;i+=len)
			for(int j=i,w=1;j<i+q;j++,w=1ll*w*wn%p)
			{
				int d=1ll*f[j+q]*w%p;
				f[j+q]=(f[j]-d+p)%p;
				f[j]+=d,f[j]%=p;
			}
	}
	if(op==-1)
	{
		int t=pw(n,p-2);
		for(int i=0;i<n;i++)f[i]=1ll*f[i]*t%p;
	}
}
int main()
{
	int n,m,s,v;
	scanf("%d%d%d",&n,&m,&s);
	v=min(m,n/s);
	fac[0]=inv[0]=1;
	for(int i=1;i<=max(n,m);i++)fac[i]=1ll*fac[i-1]*i%p;
	inv[max(n,m)]=pw(fac[max(n,m)],p-2);
	for(int i=max(n-1,m-1);i>=1;i--)inv[i]=1ll*inv[i+1]*(i+1)%p;
	for(int i=0;i<=m;i++)scanf("%d",&w[i]);
	for(int i=0;i<=v;i++)
		G[i]=1ll*pw(m-i,n-s*i)*fac[m]%p*inv[i]%p*
		inv[m-i]%p*fac[n]%p*pw(inv[s],i)%p*inv[n-i*s]%p;
	for(int i=0;i<=v;i++)A[i]=1ll*fac[v-i]*G[v-i]%p,B[i]=1ll*((i&1)?(p-1):1)*inv[i]%p;
	int vv=1;
	while(vv<=(v<<1))vv<<=1;
	ntt(A,vv,1),ntt(B,vv,1);
	for(int i=0;i<vv;i++)A[i]=1ll*A[i]*B[i]%p;
	ntt(A,vv,-1);
	int ans=0;
	for(int i=0;i<=v;i++)ans+=1ll*A[v-i]*w[i]%p*inv[i]%p,ans%=p;
	printf("%d",ans);
	return 0;
}
```

---

## 作者：奇米 (赞：2)

# 题解 - $\mathrm{P4491}$

## 题目意思

[题目传送门](https://www.luogu.com.cn/problem/P4491)

## $\mathrm{Sol}$

* **二项式反演题**

我们按套路设 

$f_{i}$ 表示钦定有 $i$ 个颜色数为 $S$ 的方案数。$g_i$ 表示恰好有 $i$ 个颜色数为 $S$。

那么$ans=\sum_{i=0}^{m} g_i\times w_i$

$g_i=\sum_{j=i}^{\min(m,\frac{n}{s})} f_j\times C_{j}^{i}\times (-1)^{j-i}$ 

关键怎么求这个$f_j$

$f_j=C_{m}^{j}\times C_n^{j\times s}\times \frac{(j\times s)!}{(s!)^j}\times (m-j)^{n-j\times s}$

中间那一项可以这样子理解：你先要在 $n$ 个位置中至少选出 $j\times s$ 个位置的方案数为 $C_n^{j\times s}$ ，对于具体地填入可以理解为先按照全排列的方式填再去掉相同颜色的那些多余情况，即$\frac{(j\times s)!}{(s!)^j}$。其他都很好理解。

时间复杂度：$O(m^2)$ 由于跑不满可以过 $m\leq 5\times 10^4$ 的点

然后我们考虑优化是这个式子：

原式：$g_i\times i!=\sum_{j=i}^{n}\frac{(-1)^{j-i}}{(i-j)!}j!f_j$

这就是道很经典的题目了,可以看看$ZJOI2014$ 力那道题目

我们设 $F_i=i!f_i$，$G_i=\frac{(-1)^i}{i!}$

那么原式可以写成：$g_i=\frac{1}{i!}\sum_{j=i}^{n} F_j\times G_{j-i}$

直接$NTT$ 一下就好了。

## $\mathrm{Code}$

```cpp
#include <bits/stdc++.h>
#define For(i,a,b) for ( int i=(a);i<=(b);i++ )
#define Dow(i,b,a) for ( int i=(b);i>=(a);i-- )
#define GO(i,x) for ( int i=head[x];i;i=e[i].nex )
#define mem(x,s) memset(x,s,sizeof(x))
#define cpy(x,s) memcpy(x,s,sizeof(x))
#define YES return puts("YES"),0
#define NO return puts("NO"),0
#define GG return puts("-1"),0
#define pb push_back
#define int long long
using namespace std;

inline int read()
{
	int sum=0,ff=1; char ch=getchar();
	while(!isdigit(ch))
	{
		if(ch=='-') ff=-1;
		ch=getchar();
	}
	while(isdigit(ch))
		sum=sum*10+(ch^48),ch=getchar();
	return sum*ff;
}

const int mod=1e9+7;
const int mo=1004535809;
const int N=1e7+5;
const int G=3ll;

int n,m,fac[N],inv[N],F[N],f[N],g[N];
int w[N],ans,l,r[N],mx,INV,lim,s;

inline int ksm(int a,int b)
{
	int ans=1;
	while(b)
	{
		if(b&1ll) ans=ans*a%mo;
		a=a*a%mo;
		b>>=1ll;
	}
	return ans%mo;
}

const int InvG=ksm(G,mo-2);
 
inline int C(int n,int m)
{
	return fac[n]*inv[m]%mo*inv[n-m]%mo;
}

inline void NTT(int *f,int op)
{
	For(i,0,lim-1) if(i<r[i]) swap(f[i],f[r[i]]);
	for ( int mid=1;mid<lim;mid<<=1ll)
	{
		int tmp=ksm(G,(mo-1)/(mid*2ll));
		if(op) tmp=ksm(tmp,mo-2);
		for ( int i=0;i<lim;i+=mid*2ll )
		{
			int w=1ll;
			for ( int j=0;j<mid;j++,w=w*tmp%mo )
			{
				int x=f[i+j];
				int y=w*f[i+j+mid]%mo;
				f[i+j]=(x+y)%mo;
				f[i+j+mid]=(x-y+mo)%mo;
			}
		}
	}
	if(op) For(i,0,lim-1) f[i]=f[i]*INV%mo;
}

signed main()
{
	n=read(),m=read(),s=read();
	For(i,0,m) w[i]=read();
	int M=max(n,m);
	fac[0]=1;
	For(i,1,M) fac[i]=fac[i-1]*i%mo;
	inv[M]=ksm(fac[M],mo-2)%mo;
	Dow(i,M-1,0) inv[i]=inv[i+1]*(i+1)%mo;
	mx=min(m,n/s);
	Dow(i,mx,0) F[i]=C(m,i)*fac[n]%mo*inv[n-i*s]%mo*ksm(ksm(fac[s],i),mo-2)%mo*ksm(m-i,n-i*s)%mo;
	For(i,0,mx) f[i]=F[i]*fac[i]%mo;
	For(i,0,mx) g[i]=((i&1ll)?mo-inv[i]:inv[i]);
	reverse(f,f+mx+1);
	lim=1ll;
	while(lim<=(mx+1)<<1ll) lim<<=1ll,l++;
	INV=ksm(lim,mo-2)%mo;
	For(i,0,lim-1) r[i]=r[i>>1ll]>>1ll|((i&1ll)<<(l-1));
	NTT(f,0),NTT(g,0);
	For(i,0,lim-1) f[i]=f[i]*g[i]%mo;
	NTT(f,1);
	int ans=0;
	For(i,0,mx) ans=(ans+1ll*f[mx-i]*w[i]%mo*inv[i]%mo)%mo;
	printf("%lld\n",ans);
	return 0;
}

```


---

## 作者：传奇666666 (赞：2)

这道题其实也不是很难，就是要用$NTT$而已……

首先考虑定义$f_i$表示钦定$i$种颜色出现了恰好$S$次，别的颜色随便选的方案数（钦定的不一样就算不一样）。$g_i$表示有恰好$i$种颜色出现了恰好$S$次，那么容斥一下有$g_i=\sum_{j=i}^{min(m,n/s)}{(-1)^{j-i}*C_j^i*f_j}$

考虑化简这个式子

$ \begin{aligned}
g_i & = \sum_{j=i}^{min(m,n/s)}{(-1)^{j-i}*C_j^i*f_j}\\
& = \sum_{j=i}^{min(m,n/s)}{(-1)^{j-i}*\frac{j!}{i!*(j-i)!}*f_j}\\
& = \sum_{j=i}^{min(m,n/s)}{\frac{1}{i!}*\frac{(-1)^{j-i}}{(j-i)!}*f_j*j!}\\
\end{aligned} $

所以有$g_i*i!=\sum_{j=i}^{min(m,n/s)}{\frac{(-1)^{j-i}}{(j-i)!}*f_j*j!}$，注意到后面这个东西是可以使用一些手法来卷积的，所以只需要把$f_i$表示成比较好求的形式求出来，套个$NTT$就做完了。

下面来考虑表示$f_i$。首先我们可先把钦定的颜色每种内部的$S$个看作相同，互相之间不同，未钦定的其他颜色全部看作相同，那么这就是一个可重集的全排列问题，那么钦定$i$个的方案为$\frac{n!}{(s!)^i*(n-i*s)!}$。之后考虑如何表示$f_i$。首先，钦定时有$C_m^i$种方法，之后那$n-i*s$个位置每个又有$m-i$种选法，所以$f_i=C_m^i*\frac{n!}{(s!)^i*(n-i*s)!}*(m-i)^{n-i*s}$。所以就做完了。

可能有人不知道一些手法是什么，我还是最后说一下。

令$a_j=f_j*j!$，$b_j=\frac{(-1)^j}{j!}$，$k=min(m,n/s)$。那么显然$g_i*i!=\sum_{j=i}^{k}{b_{j-i}*a_j}$。

考虑换个写法，$g_i*i!=\sum_{j=0}^{k-i}{b_j*a_{j+i}}$

令$c_i=a_{k-i}$，则$g_i*i!=\sum_{j=0}^{k-i}{b_j*c_{k-i-j}}$，这样就可以卷积了。

---

## 作者：撤云 (赞：2)

[点击食用效果更佳](https://www.cnblogs.com/hbxblog/p/11197899.html)

### $Solution$

观察题目发现恰好出现了$s$次的颜色有$k$种,不太好弄.

所以我们设$a[i]$表示为恰好出现了$s$次的颜色有至少$i$种的方案数,然后容斥一下

我们看一看$a[i]$怎么求？

这很明显可以一眼看出来

$$a[i]=C_m^i*C_n^{is}*(m-i)^{n-is}*\frac{(is)!}{{s!}^i}$$

在$m$个颜色中选则$i$个,在$n$个位置选择$i*s$个,将这$i*s$个数全排列(有重复元素)，剩下的位置随便选

算完这个以后可以开始容斥求答案,设答案数组为$F[i]$

$$F[i]=\sum_{j=i}^{limit}(-1)^{j-i}*C_j^i*a[j]$$

再将组合数拆开:

$$F[i]=\sum_{j=i}^{limit}(-1)^{j-i}*\frac{j!}{(j-i)!*i!}*a[j]$$
$$F[i]*i!=\sum_{j=i}^{limit}\frac{(-1)^{j-i}}{(j-i)!}*a[j]*j!$$

令$f[i]=\frac{(-1)^{i}}{(i)!},g[i]=a[j]*j!$  

所以原式为:

$$F[i]*i!=\sum_{j=i}^{limit}f[j-i]*g[i]$$

然后将$f$数组翻转,原式为:

$$F[i]*i!=\sum_{j=i}^{limit}f[n-j+i]*g[i]$$
然后发现$j$从$1$开始对答案没有影响,这又是个卷积,又因为有$\%$数,所以直接$ntt$求即可

### $Code$

``` cpp
#include<iostream>
#include<cstdlib>
#include<cstdio>
#define int long long
#define rg register
#define file(x) freopen(x".in","r",stdin);freopen(x".out","w",stdout);
using namespace std;
const int mod=1004535809;
const int N=10000001+10;
int read(){
    int x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9') f=(c=='-')?-1:1,c=getchar();
    while(c>='0'&&c<='9') x=x*10+c-48,c=getchar();
    return f*x;
}
int f[N],g[N],r[N],limit=1,w[N],inv[N],jc[N];
int ksm(int a,int b){
	int ans=1;
	while(b){
		if(b&1) ans=ans*a%mod;
		a=a*a%mod,b>>=1;
	}
	return ans;
}
void fft(int *a,int opt){
    for(int i=0;i<=limit;i++)
        if(i<r[i])
            swap(a[i],a[r[i]]);
    for(int i=1;i<limit;i<<=1){
        int w=ksm(3,(mod-1)/(i*2));
		if(opt==-1) w=ksm(w,mod-2);
        for(int j=0;j<limit;j+=i<<1){
            int l=1;
            for(int k=j;k<j+i;k++){
                int p=l*a[k+i]%mod;
                a[k+i]=(a[k]-p+mod)%mod;
                a[k]=(a[k]+p)%mod;
                l=l*w%mod;
            }
        }
    }
}
int C(int n,int m){
	return jc[n]*inv[m]%mod*inv[n-m]%mod;
}
main(){
    int n=read(),m=read(),s=read(),l=0,M=min(m,n/s),ans=0;
	for(int i=0;i<=m;i++)
		w[i]=read();
    while(limit<=M<<1)
        limit<<=1,l++;
	jc[0]=1;
	for(int i=1;i<=max(n,m);i++)
		jc[i]=jc[i-1]*i%mod;
	inv[max(n,m)]=ksm(jc[max(n,m)],mod-2);
	for(int i=max(n,m)-1;i>=0;i--)
		inv[i]=inv[i+1]*(i+1)%mod;
	for(int i=0;i<=M;i++)
		g[i]=C(m,i)*C(n,i*s)%mod*jc[s*i]%mod*ksm(inv[s],i)%mod*ksm(m-i,n-i*s)%mod;
	for(int i=0;i<=M;i++){
		g[i]=g[i]*jc[i]%mod;
		f[M-i]=(ksm(-1,i)*inv[i]+mod)%mod;
	}
    for(int i=0;i<limit;i++)
        r[i]=(r[i>>1]>>1)|((i&1)<<(l-1));
    fft(f,1),fft(g,1);
    for(int i=0;i<limit;i++)
        f[i]=f[i]*g[i]%mod;
    fft(f,-1);
    for(int i=0;i<=M;i++)
        ans=(ans+f[i+M]*ksm(limit,mod-2)%mod*inv[i]%mod*w[i]%mod)%mod;
	printf("%lld",ans);
}

```

---

## 作者：Mihari (赞：1)

# 题目

[传送门](https://www.luogu.com.cn/problem/P4491)

# 题解

## 50%思路

注意到数据范围中的重点 $S\le 150$ 。

有了这个关键的数据范围，再加上题目对于 $W[]$ 的定义”如果恰好出现了 $S$ 次的颜色有 $K$ 种, 则小 C 会产生 $W_k$ 的愉悦度.“，其实这道题思路就比较明显了——利用容斥，计算出现次数恰好为 $S$ 的颜色为 $k$ 的方案数。

首先，我们考虑，假设我们有 $k$ 个出现次数为 $S$ 的颜色，他们内部的填色方案 $T[k]$，那么显然有
$$
T[k]=\prod_{i=0}^{k-1} C_{kS-iS}^S
$$
具体理解就是 $k$ 种颜色中的前 $i$ 种先使用完 $iS$ 个格子之后，从剩下的 $kS-iS$ 个格子种选出 $S$ 个作为第 $i+1$ 种颜色放置的位置。

我们将上式变换一下，就有
$$
\begin{aligned}
T[k]&=\prod_{i=0}^{k-1}\frac{(kS-iS)!}{S!(kS-iS-S)!} \\
&=\prod_{i=0}^{k-1}\frac{(kS-iS)!}{S![kS-(i+1)S]!}
\end{aligned}
$$
发现分母中 $[kS-(i+1)S]!$ 能与下一项，也就是 $i'=i+1$ 时的分子消去，那么前一项分母与后一项分子两两相消之后，我们能够得到
$$
T[k]=\frac{(kS)!}{(S!)^k}
$$
继续分析，由于我们使用容斥，定义 $G[k]$ 为当有**不少于** $k$ 种颜色刚好 $S$ 出现情况时的方案数，定义 $F[k]$ 为当有**刚好** $k$ 种颜色出现 $S$ 的情况方案数。

显然有
$$
F[k]=\sum_{j=i}^m (-1)^{j-k}\times G[j]\times C_j^k
$$
但是这个 $G[k]$ 怎么算呢？我们都处理出 $T[k]$ 了，那么 $G[k]$ 也很明显
$$
G[k]=C_m^k\times T[k]\times (m-k)^{n-kS}
$$
那么这个时候，我们的时间复杂度是多少了呢？

考虑 $G[],T[]$ 都可以预处理，阶乘、逆元也可以预处理，那么最后的时间复杂度在于计算 $F[]$ 的时间，能够看出，其时间复杂度为 $\mathcal O(m^2)$ 的。

这是 $50\%$ 的得分了。

## 100%思路

有了前面的分析，我们的目的很明确了——降低计算 $F[]$ 的复杂度。

考虑将 $F[]$ 的计算式
$$
F[k]=\sum_{j=i}^m (-1)^{j-k}\times G[j]\times C_j^k
$$
同样地，我们将 $C$ 变换为阶乘的形式，那么有
$$
\begin{aligned}
F[k]&=\sum_{j=i}^m (-1)^{j-k}\times G[j]\times C_j^k \\
&=\sum_{j=i}^m (-1)^{j-k}\times G[j]\frac{j!}{k!(j-k)!}
\end{aligned}
$$
由于这个时候我们假设了当前为 $k$，即目前 $k$ 是一个固定值，考虑将最后一项分母中的 $k!$ 拿出来，就有
$$
F[k]=\frac{1}{k!}\sum_{j=i}^m (-1)^{j-k}\times G[j]\frac{j!}{(j-k)!}
$$
移项，有
$$
F[k]\times k!=\sum_{j=i}^m (-1)^{j-k}\times G[j]\frac{j!}{(j-k)!}
$$
我们令 $H_1[j-k]=(-1)^{j-k}\times \frac{1}{(j-k)!}$

再令 $H_2[j]=G[j]\times j!$

是否十分明朗了？假如我们将 $H_1[]$ 执行一次类似于 `reverse()` 的操作，那么
$$\begin{aligned}
H_1[k-j]&=(-1)^{j-k}\times \frac{1}{(j-k)!} \\
H_2[j]&=G[j]\times j!
\end{aligned}
$$
而我们最后要求的 $F[k]=\frac{H_1[k-j]\times H_2[j]}{k!}$

上面是不是**卷积**？！！是不是 `NTT` ？！！

于是，这道题 $100\%$ 的数据就这么解决了。

```cpp
代码呢？？？
嘿嘿嘿，嘿嘿嘿，我又把代码咕了
```

---

## 作者：2014吕泽龙 (赞：1)

一个神奇的容斥。

题目中的**恰好**提示我们要把它转化成**至少**

设$f[i]$表示出现**至少**$i$种出现次数为$S$的颜色的方案数。

首先钦定$C_m^i$个颜色。

其次钦定$C_n^{iS}$个位置。

把他们全排列（可重集的排列）$\frac{iS!}{(S!)^i}$
剩下$m-i$种颜色，$n-iS$个位置，可以瞎放$(m-i)^{n-iS}$

于是

$f[i]=C_m^iC_n^{iS}\frac{iS!}{(S!)^i}(m-i)^{n-iS}$

注意我们只需要处理出

$lim=min(\frac{n}{S},m)$的$f$

求出这个玩意儿可以通过线性处理阶乘和阶乘逆元做到$O(limlog)$搞出来

剩下根据容斥原理。

$Ans[k]=\sum_{i=k}(-1)^{i-k}C_i^kf[i]$

那个$C_i^k$是因为从每个$f_i$都被$f_k$重复计算了$C_i^k$次。

接下来就是套路了。

$Ans[k]=\sum_{i=k}(-1)^{i-k}\frac{i!}{k!(i-k)!}f[i]$
$Ans[k]\cdot k!=\sum_{i=k}\frac{(-1)^{i-k}}{(i-k)!}f[i]i!$

$NTT$即可。
```cpp
#include<bits/stdc++.h>
const int N = 262144, M = 1e7 + 10, P = 1004535809;
int ri() {
    char c = getchar(); int x = 0, f = 1; for(;c < '0' || c > '9'; c = getchar()) if(c == '-') f = -1;
    for(;c >= '0' && c <= '9'; c = getchar()) x = (x << 1) + (x << 3) - '0' + c; return x * f;
}
int w[N], R[N], A[N], B[N], sz[N], f[M], g[M], v[N], tp, L, InvL, n;
int fix(int x) {return (x >> 31 & P) + x;}
int add(int a, int b) {return a += b, a >= P ? a - P : a;}
int mul(int a, int b) {return 1LL * a * b % P;}
int Pow(int x, int k) {
    int r = 1;
    for(;k; x = mul(x, x), k >>= 1)
        if(k & 1)
            r = mul(r, x);
    return r;
}
int Inv(int x) {return Pow(x, P - 2);}
void Pre(int m) {
    L = 1; int x = 0;
    for(;(L <<= 1) < m; ++x) ;
    for(int i = 1;i < L; ++i)
        R[i] = R[i >> 1] >> 1 | (i & 1) << x;
    w[0] = 1; int wn = Pow(3, (P - 1) / L);
    for(int i = 1;i < L; ++i)
        w[i] = mul(w[i - 1], wn);
    InvL = Inv(L);
}
void DFT(int *F) {
    for(int i = 0;i < L; ++i)
        if(i < R[i])
            std::swap(F[i], F[R[i]]);
    for(int i = 1, d = L >> 1; i < L; i <<= 1, d >>= 1)
        for(int j = 0;j < L; j += i << 1) {
            int *l = F + j, *r = F + j + i, *p = w, tp;
            for(int k = i; k--; ++l, ++r, p += d)
                tp = mul(*r, *p), *r = fix(*l - tp), *l = add(*l, tp);
        }
}
int C(int m, int n) {return mul(mul(f[m], g[n]), g[m - n]);}
void Get(int n) {
    f[0] = 1; for(int i = 1;i <= n; ++i) f[i] = mul(f[i - 1], i);
    g[n] = Inv(f[n]); for(int i = n;i; --i) g[i - 1] = mul(g[i], i);
}
int main() {
    int n = ri(), m = ri(), s = ri(), lim = std::min(n / s, m);
    for(int i = 0;i <= m; ++i) v[i] = ri();
    Get(std::max(n, m));
    for(int i = 0;i <= lim; ++i) {
        int cnt = i * s;
        A[i] = mul(mul(C(m, i), C(n, cnt)), mul(f[cnt], Pow(g[s], i)));
        A[i] = mul(A[i], mul(Pow(m - i, n - cnt), f[i]));
    }
    for(int i = 0;i <= lim; ++i)
        B[lim - i] = i & 1 ? fix(-g[i]) : g[i];
    Pre((lim << 1) + 1);
    DFT(A); DFT(B);
    for(int i = 0;i < L; ++i)
        A[i] = mul(A[i], B[i]);
    DFT(A);
    int ans = 0;
    for(int i = 0;i <= lim; ++i) {
        ans = add(ans, mul(mul(v[i], g[i]), mul(A[L - i - lim & L - 1], InvL)));
    }
    printf("%d\n", ans);
    return 0;
}
```

---


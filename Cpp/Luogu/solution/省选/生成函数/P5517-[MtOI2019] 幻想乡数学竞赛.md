# [MtOI2019] 幻想乡数学竞赛

## 题目背景

一年一度的幻想乡数学竞赛 (thMO) 又要开始了。

幻想乡中学习数学的少 (lao) 女 (tai) 们 (po) 和冰之妖精 baka 一起准备着 thMO。

但是在那一刻，幻想乡日复一日的宁静被打破了。

广播里，播放起了死亡的歌曲！

在那一刻，人们又回想起了被算数支配的恐惧。  

就剩下 baka，baka，baka，baka 的声音在幻想乡里回荡。  
 

---  

河城 荷取 (Kawashiro Nitori) 正坐在 thMO2019 的考场上！  
因为荷取有着她的[超级计算机](https://www.luogu.org/problemnew/show/P4911)，在成功地用光学迷彩覆盖了计算机之后，荷取在 thMO2019 的考场上所向披靡。  

* 荷取用她的超级计算机 $0 \,\mathrm{ms}$ 跑出了这么一道题：  

  * $\exists \{ a_n\} (n=0,1,\cdots ,10^{18})$，已知 $a_0=2,a_1=5,a_{n+2}=3a_{n+1}-2a_n$，求 $a_n\bmod 10^{9}+7$

* 荷取：显然，这个题可以用矩阵乘法 + 快速幂，可以 $O(\log n)$ 水过去，差不多就这样：

$$
\begin{bmatrix} a_n & a_{n+1} \end{bmatrix}=\begin{bmatrix} a_0 & a_1 \end{bmatrix} \times \begin{bmatrix} 3 & 1 \\ -2 & 0 \end{bmatrix}^n
$$      
  
但是荷取遇到了一道她不会的题，她正在寻求你的帮助呢！ 

## 题目描述

存在一个数列 $\{ a_n\} (n\in \{ 0,1,2,\cdots ,2^{64}-1\} )$。  
已知 $a_0=-3,a_1=-6,a_2=-12,a_n=3a_{n-1}+a_{n-2}-3a_{n-3}+3^n$。  

* 现在给你一个非负整数 $n$ ，令 $p=10^{9}+7$，请你求出 $a_n \bmod p$。 

* **注：若 $a_n<0$ ，请输出 $(a_n \bmod p+p)\bmod p$。**    
  
  
为了更充分地考验你的水平，荷取设置了 $T$ 组询问。

* 为了在某种程度上减少你的输入和输出量，我们采用以下的代码来生成询问：  
  
```cpp
namespace Mker
{
//  Powered By Kawashiro_Nitori
//  Made In Gensokyo, Nihon
	#include<climits>
	#define ull unsigned long long
	#define uint unsigned int
	ull sd;int op;
	inline void init() {scanf("%llu %d", &sd, &op);}
	inline ull ull_rand()
	{
		sd ^= sd << 43;
		sd ^= sd >> 29;
		sd ^= sd << 34;
		return sd;
	}
	inline ull rand()
	{
		if (op == 0) return ull_rand() % USHRT_MAX + 1;
		if (op == 1) return ull_rand() % UINT_MAX + 1; 
		if (op == 2) return ull_rand();
	}
}
```  

在调用 `Mker::init()` 函数之后，你第 $i$ 次调用 `Mker::rand()` 函数时返回的便是第 $i$ 次询问的 $n_i$。

在这里给出 $op$ 的限制：

* 如果 $op=0$，满足 $n_i \leq 2^{16}$。

* 如果 $op=1$，满足 $n_i \leq 2^{32}$。

* 如果 $op=2$，满足 $n_i \leq 2^{64}-1$。

为了减少你的输出量，你只需要输出所有询问答案的**异或和**。





## 说明/提示

### 子任务  

![png](https://i.loli.net/2019/04/19/5cb9bb2c6c1d6.png)  

### 题目来源

[迷途之家 2019 联赛](https://www.luogu.org/contest/20135)(MtOI2019) T4

出题人：disangan233

验题人：suwakow


## 样例 #1

### 输入

```
142857 1145141919 0```

### 输出

```
562611141```

## 样例 #2

### 输入

```
142857 1145141919 1```

### 输出

```
894946216```

## 样例 #3

### 输入

```
142857 1145141919 2```

### 输出

```
771134436```

# 题解

## 作者：Fading (赞：50)

出题人是没怎么学过数列的相关套路知识吗...

感觉他的解法非常复杂啊，为什么连生成函数都用到了...

给一个简单的思路吧，不放代码。

$$a_{n}=3a_{n-1}+a_{n-2}-3a_{n-3}+3^n$$

$$a_{n}-a_{n-2}=3a_{n-1}-3a_{n-3}+3^n$$

设$b_n=a_n-a_{n-2}$，就有

$$b_1=-6,b_2=-9$$

$$b_n=3b_{n-1}+3^n$$

$$\frac {b_n}{3^n}=\frac {b_{n-1}}{3^{n-1}}+1$$

设$c_n=\frac {b_n}{3^n}$，就有

$$c_n=c_{n-1}+1$$

$$c_1=-2,c_2=-1,c_n=n-3$$

代回去，利用错项相交即可得到通项公式。

就是这样...

做一道数列小题还是蛮合适的。

---

## 作者：tonny2001 (赞：16)

# 教大家用高一数列知识解决这道题，~~初中生也能理解~~
首先原递推式可以化为$a_n-3a_{n-1}=a_{n-2}-3a_{n-3}+3^n$。

然后令$\{b_n\}=a_n-3a_{n-1}$，可得$b_n=b_{n-2}+3^n$。

然后把$n$分奇偶两类讨论。

当$n$为奇数时，可得：
$$\left\{\begin{matrix}b_n-b_{n-2}=3^n\\ b_{n-2}-b_{n-4}=3^{n-2}\\\vdots\\ b_3-b_1=3^3\end{matrix}\right.$$
很明显可以把每行的式子加起来，右边用**等比数列求和**，可得
$$b_n-b_1=\frac{3^3\left (1-9^{\frac{n-1}{2}}  \right )}{1-9}=\frac{3^{n+2}-3^{3}}{8}$$
又因为$b_1=a_1-3a_0=3$，所以可得$n$为奇数时：
$$b_n=a_n-3a_{n-1}=\frac{3^{n+2}}{8}-\frac{3}{8}$$
用同样的方法可以得到，当$n$为偶数时：
$$b_n=a_n-3a_{n-1}=\frac{3^{n+2}}{8}-\frac{33}{8}$$
继续观察这个式子，我们发现可以将等式两边同时除以$3^n$，令$\{c_n\}=\frac{a_n}{3^n}$，得到：
$$\frac{a_n}{3^n}-\frac{a_{n-1}}{3^{n-1}}=c_n-c_{n-1}=\frac{9}{8}-\frac{1}{8·3^{n-1}}\text{（$n$为奇数）}$$
$$\frac{a_n}{3^n}-\frac{a_{n-1}}{3^{n-1}}=c_n-c_{n-1}=\frac{9}{8}-\frac{11}{8·3^{n-1}}\text{（$n$为偶数）}$$
同样分奇偶讨论。将下面那个式子中的$n$减$1$后就可以得到$n$为奇数时的两个式子，即：
$$c_n-c_{n-1}=\frac{9}{8}-\frac{1}{8·3^{n-1}}$$
$$c_{n-1}-c_{n-2}=\frac{9}{8}-\frac{11}{8·3^{n-2}}$$
两式相加得：
$$c_n-c_{n-2}=\frac{9}{4}-\frac{17}{4·3^{n-1}}$$
所以有：
$$\left\{\begin{matrix}c_n-c_{n-2}=\frac{9}{4}-\frac{17}{4·3^{n-1}}\\c_{n-2}-c_{n-4}=\frac{9}{4}-\frac{17}{4·3^{n-3}}\\\vdots\\c_3-c_1=\frac{9}{4}-\frac{17}{4·3^2}\end{matrix}\right.$$
同样把每个式子加起来，右边用等比数列求和。可得：
$$c_n-c_1=\frac{n-1}{2}\times\frac{9}{4}-\frac{17}{4}\times\frac{\frac{1}{9}\left ( 1-\left ( \frac{1}{9} \right )^{\frac{n-1}{2}}\right )}{1-\frac{1}{9}}$$
$$=\frac{17}{32}\times3^{1-n}+\frac{9}{8}n-\frac{53}{32}$$
因为$c_1=\frac{a_1}{3}=-2$，所以当$n$为奇数时：
$$c_n=\frac{a_n}{3^n}=\frac{17}{32}\times3^{1-n}+\frac{9}{8}n-\frac{117}{32}$$
等式两边同时乘上$3^n$，得$n$为奇数时：
$$a_n=\frac{51}{32}+\frac{n}{8}\times3^{n+2}-\frac{117}{32}\times3^n$$
$$=\frac{1}{32}\times\left ( 51+3^n\left ( 36n-117 \right ) \right )$$
同样的做法可以得到$n$为偶数时：
$$a_n=\frac{1}{32}\times\left ( 21+3^n\left ( 36n-117 \right ) \right )$$
因为两式只有一个常数不同，所以将它们合并，于是就可得$a_n$通项公式为：
$$a_n=\frac{1}{32}\times\left ( 3^n\left ( 36n-117 \right ) +21+30\times\left [ n \text{ }mod\text{ }2==1\right ]\right )$$
求出通项后，我们发现每次询问都需要对$3^n$做一次**快速幂**，时间复杂度$O\left ( Tlogn \right )$，这样只能得到30分。考虑优化。

由**费马小定理**我们知道当$p$为质数时有$x^{p-1}\equiv1\left ( mod\text{ }p \right )$。所以显然有$x^{n}\equiv x^{n\text{ }mod\text{ }p-1}\left ( mod\text{ }p \right )$。所以计算快速幂时可以直接让$n$对$p-1$取模后再运算，时间复杂度$O\left ( Tlogp \right )$。依然无法通过此题。

观察到$p=10^9+7$，$\sqrt{p}\approx31623$。所以考虑**光速幂**。预处理数组$pow1\left [ i \right ]=3^{32000i}$，$pow2\left [ i \right ]=3^i$。所以有$3^n=pow1\left [ \left \lfloor n/32000 \right \rfloor \right ]\times pow2\left [ n\text{ }mod\text{ }32000 \right ]$。时间复杂度$O\left ( T \right )$。
```cpp
#include<iostream>
#include<cstdio>
#define ULL unsigned long long
namespace Mker
{
//  Powered By Kawashiro_Nitori
//  Made In Gensokyo, Nihon
	#include<climits>
	#define ull unsigned long long
	#define uint unsigned int
	ull sd;int op;
	inline void init() {scanf("%llu %d", &sd, &op);}
	inline ull ull_rand()
	{
		sd ^= sd << 43;
		sd ^= sd >> 29;
		sd ^= sd << 34;
		return sd;
	}
	inline ull rand()
	{
		if (op == 0) return ull_rand() % USHRT_MAX + 1;
		if (op == 1) return ull_rand() % UINT_MAX + 1; 
		if (op == 2) return ull_rand();
	}
}
using namespace std;
const int MOD = 1e9 + 7;
const int inv32 = 281250002;
const int POW = 369057345;
const int N = 32000;
int T;
ULL n, m, ans, now, pow1[N + 10], pow2[N + 10];
int main()
{
	scanf("%d", &T);
	Mker::init();
	pow1[0] = pow2[0] = 1;
	for(int i = 1; i <= N; i++)
		pow1[i] = pow1[i - 1] * POW % MOD, pow2[i] = pow2[i - 1] * 3 % MOD;
	while(T--)
	{
		n = Mker::rand();
		now = (n % MOD * 36 - 117 + MOD) % MOD;
		m = n % (MOD - 1);
		now = (now * pow1[m / N] % MOD * pow2[m % N] % MOD + 21 + 30 * (n & 1)) % MOD;
		(now *= inv32) %= MOD;
		ans ^= now;
	}
	printf("%llu", ans);
	return 0;
}
```



---

## 作者：disangan233 (赞：16)

## 题意

存在一个数列$\{ a_n\} (n\in \{ 0,1,2,\cdots ,10^{18}\cdots \} )$。  

已知$a_0=-3,a_1=-6,a_2=-12,a_n=3a_{n-1}+a_{n-2}-3a_{n-3}+3^n$。

* 现在给你给定的$n$，令$p=10^{9}+7$，请你求出$a_n \bmod p$。 

## Solutions

### Sol 1

输出0，期望得分：$5~pts$。  

### Sol 2 

直接暴力递推，时间复杂度$O(tn)$，期望得分：$20~pts$。    

### Sol 3

考虑将递推式转化为矩阵乘法：  

$$\begin{bmatrix} a_{i-1}\\a_{i-2}\\a_{i-3}\\3^i \end{bmatrix} \times \begin{bmatrix} 3&1&-3&1\\1&0&0&0\\0&1&0&0\\0&0&0&3\end{bmatrix} = \begin{bmatrix} a_{i}\\a_{i-1}\\a_{i-2}\\3^{i+1} \end{bmatrix}$$

因为矩阵满足结合律，快速幂即可，时间复杂度$O\left(4^3 \times t\log {n}\right)$  

* 加上对于数据点12的打表，期望得分：$20-60~pts$  

### Sol 4  

~~由题目名字得知这是一个数学题。~~   

构造关于$x$的OGF：$f(x)=a_0x^0+a_1x^1+a_2x^2+a_3x^3+\cdots +a_nx^n+\cdots $，

那么可以得到：

$$(3x^3-x^2-3x+1)f(x)=a_0x^0+(a_1-3a_0)x^1+(a_2-3a_1-a_0)x^2+3^3x^3+\cdots+3^nx^n+\cdots$$

将$a_0=-3,a_1=-6,a_2=-12$代入后得：    

$$(3x^3-x^2-3x+1)f(x)=-3+3^1x^1+3^2x^2+3^3x^3+\cdots+3^nx^n+\cdots$$

因式分解后得到： 
$$(3x-1)(x+1)(x-1)f(x)=-3+3^1x^1+3^2x^2+3^3x^3+\cdots+3^nx^n+\cdots$$

用等比数列求和公式化简：    
$$(3x-1)(x+1)(x-1)f(x)=-4+\dfrac{1}{1-3x}=\dfrac{12x-3}{1-3x} $$
$$f(x)=\dfrac{12x-3}{(1-3x)^2(1+x)(1-x)}$$

用待定系数法把这个式子拆开：

$$\dfrac{12x-3}{(1-3x)^2(1+x)(1-x)}=\dfrac{A}{(1-3x)^2}+\dfrac{B}{1+x}+\dfrac{C}{1-x}+\dfrac{D}{1-3x} $$
$$A=\dfrac{12x-3}{(1+x)(1-x)} \Bigg|_{x=\frac{1}{3}}=\dfrac{9}{8} $$
$$B=\dfrac{12x-3}{(1-3x)^2(1-x)} \Bigg|_{x=-1}=-\dfrac{15}{32} $$
$$C=\dfrac{12x-3}{(1-3x)^2(1+x)} \Bigg|_{x=1}=\dfrac{9}{8}$$

D单独求：  

$$\because \dfrac{(12x-3)x}{(1-3x)^2(1+x)(1-x)}=\dfrac{Ax}{(1-3x)^2}+\dfrac{Bx}{1+x}+\dfrac{Cx}{1-x}+\dfrac{Dx}{1-3x} $$
$$\therefore \lim_{x \to \infty} (xf(x))=0 $$
$$\therefore \lim_{x \to \infty} (B-C-\dfrac{1}{3}D)=0 $$
$$\therefore D=3\times(B-C)=-\dfrac{153}{32}$$

将求得的$A$，$B$，$C$，$D$代入$f(x)$中：  

$$\because A=\dfrac{9}{8},B=-\dfrac{15}{32},C=\dfrac{9}{8},D=-\dfrac{153}{32} $$
$$\therefore f(x)=\dfrac{9}{8(1-3x)^2}-\dfrac{15}{32(1+x)}+\dfrac{9}{8(1-x)}-\dfrac{153}{32(1-3x)} $$
$$\therefore f(x)=\dfrac{9}{8}\sum^{\infty}_{i=0}x^i-\dfrac{15}{32}\sum^{\infty}_{i=0}(-1)^ix^i-\dfrac{153}{32}\sum^{\infty}_{i=0}3^ix^i+\dfrac{9}{8}\sum^{\infty}_{i=0}3^ix^i(i+1) $$
$$\therefore f(x)=\dfrac{1}{32} \sum^{\infty}_{i=0} \left[ 3^{i+2}\times (4i-13)+36-15\times (-1)^i \right] x^i $$
$$\therefore a_n=\dfrac{3^{n+2}\times (4n-13)+36-15\times (-1)^n}{32}$$

快速幂即可，时间复杂度$O\left(t\log {n}\right)$，期望得分$30-60~pts$。  

### Sol 5 

分析算法后发现，**Sol 3**因为**常数巨大**而不够优秀，然而**Sol 4**已经**足够优秀**却仍然超时。  

发现**Sol 4**中最烧时间的就是求$3^{n+2} \bmod p$的部分。

* 对，你想到了什么？欧拉定理！  

**欧拉定理**  

因为$a^b\equiv a^{b \bmod \varphi(p)} \pmod{p}$，我们把时间复杂度成功地优化到了$O\left(t\log {p}\right)$。

* 但是我们依然$\mathrm{TLE}$。 

考虑继续优化求$3^p \bmod p$的部分。  

**"光速"幂**  

已知$p=10^9+7$，$\log_2{p}\leq 32$。所以我们预处理出$2^{16}$以内的所有快速幂情况，每一次快速幂就可以$O(1)$完成了！  

分析后我们的算法时间复杂度为$O\left(2 \times 2^{16}+ 2t\right)$，空间复杂度为$O(2^{16})$，期望得分：$80-100~pts$。

仍然不够优秀，考虑常数优化，如：

* 合理使用`long long`来减少取模的常数。
* 使用循环展开来降低常数。
* 使用`inline`，`register`等常见的优化常数的技巧。

以上是std使用的优化方法，下面是一些神奇的优化方法（出题人没试过）：

* 修改`Mker`中常数大的地方来减少常数。
* 更多的编译优化~~&指令集？~~
* 在代码里注入`czakioi`等玄学的信仰优化

期望得分：$100~pts$

## Code

```cpp
#include<bits/stdc++.h>
using namespace std;
namespace Mker
{
//  Powered By Kawashiro_Nitori
//  Made In Gensokyo, Nihon
    #include<climits>
    #define ull unsigned long long
    #define uint unsigned int
    ull sd;int op;
    inline void init() {scanf("%llu %d", &sd, &op);}
    inline ull ull_rand()
    {
        sd ^= sd << 43;
        sd ^= sd >> 29;
        sd ^= sd << 34;
        return sd;
    }
    inline ull rand()
    {
        if (op == 0) return ull_rand() % USHRT_MAX + 1;
        if (op == 1) return ull_rand() % UINT_MAX + 1; 
        if (op == 2) return ull_rand();
    }
}
#define re register int
#define ll long long
#define ull unsigned long long
#define in inline
const int base=16,lim=(1<<16)-1,inv32=281250002;
const ll p=1e9+7,pp=p*p;
int t,pre,ans,mul[2][lim+1];
ll m;
in ll multi(re a) {ll b=mul[0][a&lim];a>>=base;if(a)b=b*mul[1][a&lim]%p;return b;}
in void get_multi()
{
	mul[0][0]=mul[1][0]=1;mul[0][1]=3;
    for(re j=2;j<=lim;j++) mul[0][j]=1ll*mul[0][1]*mul[0][j-1]%p;
    mul[1][1]=1ll*mul[0][lim]*mul[0][1]%p;
    for(re j=2;j<=lim;j++) mul[1][j]=1ll*mul[1][1]*mul[1][j-1]%p;
}
int main()
{
    scanf("%d",&t);Mker::init();get_multi();
    while(t--)
    {
        ull n=Mker::rand();
		pre=(n&1)?51:21;m=((n%p)<<2)-13+p;
        ans^=(((multi((n+2)%(p-1))*m)%p+pre)*inv32+pp)%p;
    }
    printf("%d",ans);
    return 0;
}
```

---

## 作者：ljc1301 (赞：8)

真·数学&卡常题

官方题解中似乎是用生成函数，我这里就讲另一个神奇的科技——特征方程。

首先，我们注意到这个递推式中有个很讨厌的$3^n$，如果把这个给去掉就好了。注意到，每一项都带一个$3^n$，我们考虑把这个东西求出来，把递推式边个形，有
$$3^n=a_n-3a_{n-1}-a_{n-2}+3a_{n-3}$$
即
$$3^{n-1}=a_{n-1}-3a_{n-2}-a_{n-3}+3a_{n-4}$$
那么有
$$\begin{aligned}3^n&=3\cdot3^{n-1}\\&=3a_{n-1}-9a_{n-2}-3a_{n-3}+9a_{n-4}\end{aligned}$$
所以
$$\begin{aligned}a_n&=3a_{n-1}+a_{n-2}-3a_{n-3}+3^n\\&=3a_{n-1}+a_{n-2}-3a_{n-3}+3a_{n-1}-9a_{n-2}-3a_{n-3}+9a_{n-4}\\&=6a_{n-1}-8a_{n-2}-6a_{n-3}+9a_{n-4}\end{aligned}$$
这样就变成了一个齐次的递推式了。顺便一提，这是四阶的，所以要先知道前四项，用最初的递推式手算一下得到$a_3=-6$。

现在来求这个东西的通项公式。先引入一个东西——特征方程。顺便再介绍一下，这个东西很有用，出了在解递推数列中有用，在矩阵、微分方程、积分方程等中都是一个黑科技。下面就介绍一下齐次递推数列中的特征方程。

首先，我们把递推式写成这样的形式：
$$a_{n+4}=6a_{n+3}-8a_{n+2}-6a_{n+1}+9a_n$$
然后，把$a_{n+k}$替换成$x^k$，得到 
$$x^4=6x^3-8x^2-6x+9$$
这有什么好处呢？不妨设$x_1,x_2,x_3,x_4$为它的四个根，那么就有
$$\begin{cases}x_1^4=6x_1^3-8x_1^2-6x_1+9\\x_2^4=6x_2^3-8x_2^2-6x_2+9\\x_3^4=6x_3^3-8x_3^2-6x_3+9\\x_4^4=6x_4^3-8x_4^2-6x_4+9\end{cases}$$
两边同时乘以$x_k^n$，得
$$\begin{cases}x_1^{n+4}=6x_1^{n+3}-8x_1^{n+2}-6x_1^{n+1}+9x_1^n&(1)\\x_2^{n+4}=6x_2^{n+3}-8x_2^{n+2}-6x_2^{n+1}+9x_2^n&(2)\\x_3^{n+4}=6x_3^{n+3}-8x_3^{n+2}-6x_3^{n+1}+9x_3^n&(3)\\x_4^{n+4}=6x_4^{n+3}-8x_4^{n+2}-6x_4^{n+1}+9x_4^n&(4)\end{cases}$$
那么，把$(1)$式乘以$c_1$（一个系数），把$(2)$式乘以$c_2$，把$(3)$式乘以$c_3$，把$(4)$式乘以$c_4$，然后相加得到
$$\begin{aligned}&c_1x_1^{n+4}+c_2x_2^{n+4}+c_3x_3^{n+4}+c_4x_4^{n+4}\\=&6(c_1x_1^{n+3}+c_2x_2^{n+3}+c_3x_3^{n+3}+c_4x_4^{n+3})\\-&8(c_1x_1^{n+2}+c_2x_2^{n+2}+c_3x_3^{n+2}+c_4x_4^{n+2})\\-&6(c_1x_1^{n+1}+c_2x_2^{n+1}+c_3x_3^{n+1}+c_4x_4^{n+1})\\+&8(c_1x_1^n+c_2x_2^n+c_3x_3^n+c_4x_4^n)\end{aligned}$$
当$a_n=c_1x_1^n+c_2x_2^n+c_3x_3^n+c_4x_4^n$时就有
$$a_{n+4}=6a_{n+3}-8a_{n+2}-6a_{n+1}+9a_n$$
然后，我们知道$4$个$a_n$的值，就可以把$c_k$解出来了。当然，这个过程是可以推导到任意次数的，用的时候可以直接记结论，就是求根，根据前几项解$a_n=c_1x_1^n+c_2x_2^n+c_3x_3^n+c_4x_4^n$，然后写出通项公式。

再多说几句，当一个特征多项式只能看出来几个因式的时候，或出现了不爽的根的时候，比如$x^2+1$，则可以把递推式化简成$a_n+a_{n-2}=c_1(a_{n-1}+a_{n-3})+\cdots$，有时可以便于求解。

好，看起来要结束了，我们先把方程解出来，如果都是有理根就很舒服了。我们移项得
$$x^4-6x^3+8x^2+6x-9=0$$
因式分解（可以用试根法）得
$$(x-3)^2(x-1)(x+1)=0$$
那么根就是$x_1=x_2=3,x_3=1,x_4=-1$。等一下，好像有点问题，这里出现了重根，那么解$c_k$时$c_1$和$c_2$前面的系数时完全相同的（因为$x_1=x_2$）。那怎么办呢？

这里再稍微拓展一下，讲一下$x_1$是它的$k$重根时的做法（当然这里只有二重根，但为了形象地描述，还是用这个方程）。设$x^{n+4}=6x^{n+3}-8x^{n+2}-6x^{n+1}+9x^n$移项后为$f(x)=0$，则$(x-x_1)^k$是它的因式，不妨设$f(x)=(x-x_1)^kg(x)$，显然$f(x_1)=0$，而由洛必达法，对于$1\leqslant m<k$，对$m$从小到大归纳，有
$$\begin{aligned}0&=(x_1-x_1)^{k-m}g(x_1) \\&=\lim_{x\to x_1}(x-x_1)^{k-m}g(x)\\&=\lim_{x\to x_1}\frac{(x-x_1)^kg(x)}{(x-x_1)^m}\\&=\lim_{x\to x_1}\frac{f(x)}{(x-x_1)^m}\\&=\lim_{x\to x_1}\frac{f'(x)}{((x-x_1)^m)'}\\&=\lim_{x\to x_1}\frac{f'(x)}{m(x-x_1)^{m-1}}\\&=\begin{cases}f'(x_1)&&m=1\\\lim\limits_{x\to x_1}\frac{f^{(2)}(x)}{m(m-1)(x-x_1)^{m-2}}=\cdots=\lim\limits_{x\to x_1}\frac{f^{(m)}(x)}{m!}=\frac{f^{(m)}(x_1)}{m!}&(\texttt{由归纳},f^{(m')}(x_1)=0(m'<m))&m>1\end{cases}\end{aligned}$$
$\therefore f^{(m)}(x_1)=0$

而移项前得$x^{n+4}=6x^{n+3}-8x^{n+2}-6x^{n+1}+9x^n$，对它两边同时求$m\ (1\leqslant m<k)$次导应该也是成立的，所以有
$$(n+4)^\frac m{}x^{n+4-m}=6(n+3)^\frac m{} x^{n+3-m}-8(n+2)^\frac m{}x^{n+2-m}-6(n+1)^\frac m{}x^{n+1-m}+9n^\frac m{}x^{n-m}$$
稍微写好看一点，用$n+m$替代$n$：
$$(n+4+m)^\frac m{}x^{n+4}=6(n+3+m)^\frac m{} x^{n+3}-8(n+2+m)^\frac m{}x^{n+2}-6(n+1+m)^\frac m{}x^{n+1}+9(n+m)^\frac m{}x^n$$
发现每个$x^n$前得系数都是一个固定的$m$次的多项式，所以用$0\leqslant m<k$这里的$m$应该能表示所有的$k-1$次多项式，即
$$h(n+4)x^{n+4}=6h(n+3)x^{n+3}-8h(n+2)x^{n+2}-6h(n+1)x^{n+1}+9h(n)x^n$$
当$h$为小于$k$次的多项式时成立。

所以，和前面同理，这里待定的系数就是这个$k-1$次的多项式的系数。这又是一个可以直接记的结论：当有$k$重根$x_1$时，待定$(c_{1,0}+c_{1,1}n+\cdots+c_{1,k-1}n^{k-1})x_1^n$，其它项和原来的相同。

所以，在这道题中，不妨设$a_i=(c_1n+c_2)3^n+c_3+c_4(-1)^n$，根据$a_0=-3,a_1=-6,a_2=-12,a_3=-6$，解得$c_1=\frac98,c_2=-\frac{117}{32},c_3=\frac98,c_4=-\frac{15}{32}$

然而，这题需要卡常数。根据$a^p\equiv a\pmod p$，因为$3\neq 0\pmod p$，所以$3^{p-1}\equiv1\pmod p$，所以计算$3^n$时，可以计算$3^{n\mod (p-1)}$，这样，可以预处理$3^{0,1,\cdots,65535}$，和$3^{0,65536,2\cdot65536,\cdots,65536\cdot65536}$，然后 $\Theta(1)$算快速幂。当然还可以结合其他卡常技巧。

代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef unsigned long long ull;
typedef long long ll;
typedef unsigned int uint;
ull sd;int op;
#define sz 65537
#define kcz 1000000007
ll t0[sz],t1[sz];
int main()
{
    int T;
    register int i,ans=0;
    ull n;
    scanf("%d%llu%d",&T,&sd,&op);
    for(i=1,t0[0]=1;i<sz;i++) t0[i]=t0[i-1]*3%kcz;
    for(i=1,t1[0]=1;i<sz;i++) t1[i]=t1[i-1]*t0[65536]%kcz; // 预处理
    for(;T--;)
    {
        sd ^= sd << 43,sd ^= sd >> 29,sd ^= sd << 34;
        if(op==2) n=sd;
        else if (op == 0) n = sd%USHRT_MAX + 1;
        else n = sd%UINT_MAX + 1; // 把Mker的内容放到主函数里
        ans^=(((ll)(n%kcz)*125000002+93749997)%kcz*t0[(n%(kcz-1))&65535]%kcz*t1[((n%(kcz-1))>>16)&65535]+((n&1)?343750004:906250007))%kcz; // 提前算9/8等，而9/8-15/32*(-1)^n是51/32或21/32（根据n的奇偶），也可以提前算
    }
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：cccgift (赞：7)

### 感觉@[Fading](https://www.luogu.org/space/show?uid=20309)没有讲清楚……这里顺着他的思路再讲一下。

考场上我想到了这个思路，最后错项相交的部分事实上是最麻烦的。

首先，我们已经得到了$a_n-a_{n-2}=(n-3)*3^n$。

那么我们考虑把每一项$a_i-a_{i-2}$都弄出来相加，就像这样：

$(a_n-a_{n-2})+(a_{n-2}+a_{n-4})+......$

$=(n-3)*3^n+(n-5)*3^{n-2}+......$

但是，对于$n$为奇数和$n$为偶数，左边的最后一项是不同的，我们只考虑$n$为奇数的情况（$n$为偶数同理）。

若$n$为奇数，原式就变成了这样：

$(a_n-a_{n-2})+(a_{n-2}+a_{n-4})+......+(a_3-a_1)$

$=(n-3)*3^n+(n-5)*3^{n-2}+......+(n-n)*3^3$

$=a_n-a_1$

发现$a_1=-6$，所以我们只要求中间那部分就行了。

设$X=(n-3)*3^n+(n-5)*3^{n-2}+......+(n-(n-2))*3^5+(n-n)*3^3$

考虑等比数列公式的推法，

$9X=(n-3)*3^{n+2}+(n-5)*3^n+......+(n-n)*3^5$

尝试用$9X$去减$X$，相同指数的项对应相减。

于是，$9X-X+2*(3^n+3^{n-2}+3^{n-4}......+3^5)=(n-3)*3^{n+2}-(n-n)*3^3$

最后就是考虑怎么求$Y=2*(3^n+3^{n-2}+3^{n-4}......+3^5)$，不妨我们去求$3^n+3^{n-2}+......+3^1$，这就是等比数列，用一下公式，答案就是$\frac{9*3^n-3}{8}$，代回去，

$Y=\frac{3^{n+2}-3}{4}-2*(3^3+3^1)=\frac{3^{n+2}-243}{4}$。

所以，$8X=(n-3)*3^{n+2}-\frac{3^{n+2}-243}{4}$

那么，$a_n=\frac{(4n-13)*3^{n+2}+243}{32}-6$，由于$n+2$可能会爆$ull$，所以化成$a_n=\frac{(36n-117)*3^n+51}{32}$，这是$n$为奇数的情况，再推一遍$n$为偶数的情况发现就是把$51$换成$21$，最后光速幂处理$3^n$即可。

### 代码如下：

```cpp
#include<cstdio>
#include<cstring>
#include<cctype>
#include<utility>
#include<algorithm>
#include<cmath>
using namespace std;
#define res register int
#define ll long long
#define cccgift
//#define getchar()(p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
//char buf[1<<21],*p1=buf,*p2=buf;
namespace wode{
    template<typename T>
    inline void read(T &x)
    {
        static char ch;bool f=1;
        for(x=0,ch=getchar();!isdigit(ch);ch=getchar()) if(ch=='-') f=0;
        for(;isdigit(ch);x=(x<<1)+(x<<3)+(ch^48),ch=getchar());x=f?x:-x;
    }
    template<typename T>
    void print(T x)
    {
        if (x<0) putchar('-'),x=-x;
        if (x>=10) print(x/10);
        putchar(x%10+'0');
    }
    template<typename T>
    inline void print(T x,char ap) {print(x);if (ap) putchar(ap);}
    template<typename T>
    inline T max(T x,T y) {return x<y?y:x;}
    template<typename T>
    inline T min(T x,T y) {return x<y?x:y;}
    template<typename T>
    inline void chkmax(T &x,T y) {x=x<y?y:x;}
    template<typename T>
    inline void chkmin(T &x,T y) {x=x<y?x:y;}
}
using wode::read;using wode::chkmin;using wode::chkmax;using wode::print;
namespace Mker
{
//  Powered By Kawashiro_Nitori
//  Made In Gensokyo, Nihon
	#include<climits>
	#define ull unsigned long long
	#define uint unsigned int
	ull sd;int op;
	inline void init() {scanf("%llu %d", &sd, &op);}
	inline ull ull_rand()
	{
		sd ^= sd << 43;
		sd ^= sd >> 29;
		sd ^= sd << 34;
		return sd;
	}
	inline ull rand()
	{
		if (op == 0) return ull_rand() % USHRT_MAX + 1;
		if (op == 1) return ull_rand() % UINT_MAX + 1; 
		if (op == 2) return ull_rand();
	}
}
int t,fac1[32769],fac2[32769],tot,fac4;
ull n;
inline ll kuai(ll p,ll q,int mod) {ll tot=1;for(;q;p=p*p%mod,q>>=1) if(q&1) tot=tot*p%mod;return tot;}
#define mod 1000000007
#define sq 32768 //设成这个数，接下来取模就可以直接位运算了
#define inv32 281250002 //预先算出32的逆元
int main()
{
	read(t),Mker::init();
	fac1[0]=1;
	for(res i=1;i<=sq;++i) fac1[i]=(ll)fac1[i-1]*3%mod;
	fac2[0]=1;
	for(res i=1;i<=sq;++i) fac2[i]=(ll)fac2[i-1]*fac1[sq]%mod; //光速幂预处理
	while(t--) {
		n=Mker::rand();int now=n%(mod-1),sum=(ll)fac2[now>>15]*fac1[now&(sq-1)]%mod; //注意用欧拉定理把指数弄进模数的范围内！
		tot^=(ll)inv32*(((ll)(n%mod)*36-117+mod)%mod*sum%mod+((n&1)?51:21))%mod;
	}
	print(tot,'\n');
	return 0;
}
```

---

## 作者：囧仙 (赞：6)

## 题目大意

> 已知数列 $\{A_n\}$ ，  
> $$A_n=\begin{cases}
-3 & \text{if } n=0 \cr
-6 & \text{if } n=1 \cr
-12 & \text{if } n=2 \cr
3a_{n-1}+a_{n-2}-3a_{n-3} & \text{if } n> 3
\end{cases}$$
> $T$ 次询问，每次求出数列的第 $n$ 项，输出所有答案对 $10^9+7$ 取模后的异或和。   
> $T\le 5\times 10^7,n\in[0,2^{64})$ 。

## 题解

**注意**：这是一个比较乱搞的思路，可能并不普遍适用，请酌情阅读。

显然，由于 $T$ 达到了 $5\times 10^7$ 的级别，因此使用矩阵优化并不能通过题。求出 $A_n$ 的通项变得必不可少了。

考虑写一个简单粗暴的暴力程序，用于计算 $A_n$ 以便于观察柿子。

```cpp
int A[25];
A[0]=-3,A[1]=-6,A[2]=-12;
for(int i=3;i<=20;++i){
    A[i]=3*A[i-1]+A[i-2]-3*A[i-3]+(int)pow(3,i);
}
```

**注意**：函数 $\text{pow}$ 可能会出各种各样的问题，需要强制类型转换为 $\text{int}$ 。

我们可以通过打表计算出 $a_i$ 的若干项。

$$A_{n}=\{-3,-6,-12,-6,69,480,2256,9228,35061,127326,448404\cdots\}(n=0,1,2,\cdots)$$

显然，根据题面中给出来的递推式，我们能够发现 $A_n$ 应该是按照指数级增长的。因此，我们并不能用拉格朗日插值求出一个有限项的多项式通项公式。但这启发我们计算 $A_n/A_{n-1}$ ，因为**指数增长速度远远大于二次方、三次方**。

$$\frac{A_n}{A_{n-1}}\approx \{3.52,3.44,3.39,3.34,3.31,3.28,3.26,3.24,3.22,3.20,2.92\cdots\} (n=10,11,12\cdots)$$

可以发现，随着 $n$ 的增大， $\dfrac{A_n}{A_{n-1}}$ 应当是趋向于 $3$ 的。由于通项公式不会太复杂，因此可以大胆猜想公比约等于 $3$ 。

但是很有可能式子里会出现形如 $n\times 3^n$ 一类的东西（比如， $\sum_{i=0}^n i\times 2^i$ 的通项公式就含有 $n\times 2^n$ ）。这点需要特殊注意。不妨考虑计算 $A_n/3^n$ 。

$$\frac{A_n}{3^n}\approx\{7.59,8.72,9.84,10.97,12.09,13.22,14.34,15.47,16.59,17.72,17.23\cdots\}(n=10,11,12,\cdots)$$

这点印证了我们的猜想，因为 $A_n/3^n$ 的确近似于一个一次函数。

于是，我们可以大胆猜想， $A_n$ 的通项公式应该长这样：

$$A_n=p\times 3^n+q\times n\times 3^n+an^2+bn+c$$

其中， $p,q,a,b,c$ 是我们待定的系数。事实上，我们可以通过高斯消元进行处理。什么？高斯消元只能处理到浮点数，但是你看不出来这个数化为有理分数长什么样？这点很简单，只要我们进行一些修改（类似于 $\text{NOIP2020 T1}$ ），就能处理有理分数了。

但是我们发现，无论我们怎么怎么计算 $p,q,a,b,c$ ，结果都长得很奇怪。但是我们明明计算出公比趋近于 $3$ 。想想看还有什么东西可能缺少了？

事实上，通项公式里是可能存在 $(-1)^n,n\times (-1)^n$ 的。（不过， $(-3)^n,n\times (-3)^n$ 一类情况也是可能存在的。当然，本题中用不到，不同题目可能有调整）我们修正一下刚刚设的 $A_n$ 的通项公式：

$$A_n=p\times 3^n+q\times n\times 3^n+r\times (-1)^n+s\times n\times (-1)^n+an^2+bn+c$$

这时候，我们再次用高斯消元法进行求解。考虑到 $a_0,a_1,a_2$ 的特殊性，我们就取 $a_3,a_4,\cdots a_9$ 。列出的增广矩阵如下：

$$\begin{bmatrix}
27 & 81 & -1 & -3 & 9 & 3 & 1 &|& -6 \cr
81 & 324 & 1 & 4 & 16 & 4 & 1 &|& 69 \cr
243 & 1215 & -1 & -5 & 25 & 5 & 1 &|& 480 \cr
729 & 4374 & 1 & 6 & 36 & 6 & 1 &|& 2256 \cr
2187 & 15309 & -1 & -7 & 49 & 7 & 1 &|& 9228 \cr
6561 & 52488 & 1 & 8 & 64 & 8 & 1 &|& 35061 \cr
19683 & 177147 & -1 & -9 & 81 & 9 & 1 &|& 127326 \cr
\end{bmatrix}$$

可以得到：

$$\begin{cases}
p=x_1=-\frac{117}{32} \cr
q=x_2=\frac{9}{8} \cr
r=x_3=-\frac{15}{32} \cr
s=x_4=0 \cr
a=x_5=0 \cr
b=x_6=0 \cr
c=x_7=\frac{9}{8} \cr
\end{cases}$$

（解得的 $s,a,b$ 都为 $0$ ，说明通项公式里不存在这一项）。

整理回刚刚的形式，可以得到：

$$
A_n=-\frac{117}{32}\times 3^n+\frac{9}{8}\times n\times 3^n-\frac{15}{32}\times (-1)^n+\frac{9}{8}
$$

再整理为容易计算的形式：

$$A_n=\frac{(-117+36n)\times 3^n-15\times (-1)^n+36}{32}$$

于是，我们成功获得了 $A_n$ 的通项公式，下面就是计算它了。

---

由于 $n$ 的值过大，我们需要进行一系列优化：

- $1.$ 根据费马小定理（其实也可以用欧拉定理。费马小定理是他的特殊情况），可以得到：

$$3^{p-1}\equiv 1\pmod p$$

因此，

$$3^n\equiv 3^{n\bmod (p-1)} \pmod p$$

- $2.$ 考虑如何快速计算 $3^n,(n<2^{32})$ 。（光速幂）

有一个比较显然的结论：

$$3^{n}=3^{(n\bmod m)+(n\operatorname{div} m)\times m}=3^{m^{n\operatorname{div} m}}\times 3^{n\bmod m}$$

不妨令 $m=2^{16}$ ，那么只需要预处理出 $3^i,(3^m)^i,(i\in[0,2^{16}))$ ，就可以 $\mathcal O(1)$ 计算出 $3^n$ 次方了。

一些注意点：

- 写暴力程序时，一定要注意 $\text{pow}$ 函数由于精度方面的原因导致的问题。

- 用待定系数法计算时，想清楚了有哪些可能的项。

- 高斯消元要用特殊修改版的，不然光看小数真的很难看出比较复杂的有理分数。

- 记得要在恰当的地方使用 $\bmod p$ ，也要恰当地强制类型转换为 $\text{long long}$ ，不然可能会炸。

- 不要抄错出题人给的随机数生成器。

~~别问我为什么要注意这些，问就是我把这些雷全部踩了~~。

## 参考代码

- 特殊修改版高斯消元，输入格式同[P3389](https://www.luogu.com.cn/problem/P3389)：

```cpp
#include<bits/stdc++.h>
#define up(l,r,i) for(int i=l,END##i=r;i<=END##i;++i)
#define dn(r,l,i) for(int i=r,END##i=l;i>=END##i;--i)
using namespace std;
typedef long long i64;
const int INF =2147483647;
const int MAXN=100+3;
int n;
int qread(){
    int w=1,c,ret;
    while((c=getchar())> '9'||c< '0') w=(c=='-'?-1:1); ret=c-'0';
    while((c=getchar())>='0'&&c<='9') ret=ret*10+c-'0';
    return ret*w;
}
i64 gcd(i64 a,i64 b){
    a=labs(a),b=labs(b); if(a>b) swap(a,b); return a==0?b:gcd(b%a,a);
}
struct Node{
    i64 a,b; Node(i64 _a=0,i64 _b=1):a(_a),b(_b){
        i64 d=gcd(a,b);a/=d,b/=d; if(a<0&&b<0) a=-a,b=-b;
    }
    Node operator +(Node t){
        i64 d=b/gcd(b,t.b)*t.b; return Node(d/b*a+d/t.b*t.a,d);
    }
    Node operator *(Node t){return Node(a*t.a,b*t.b);}
    Node operator /(Node t){return Node(a*t.b,b*t.a);}
}X[MAXN][MAXN],Y[MAXN],R[MAXN];
Node inv(Node x){return Node(-x.a,x.b);}
int main(){
    n=qread(); up(1,n,i){
        up(1,n,j) X[i][j].a=qread(); Y[i].a=qread();
    }
    up(1,n,i){
        int f=0; up(i,n,j) if(X[j][i].a){f=j;break;}
        if(f==0) puts("No Solution"),exit(0); else 
        if(f!=i){ 
            up(1,n,j) swap(X[i][j],X[f][j]); swap(Y[i],Y[f]);
        }
        up(i+1,n,j){
            Node p=X[j][i]/X[i][i]; Y[j]=Y[j]+inv(Y[i]*p);
            up(i+1,n,k) X[j][k]=X[j][k]+inv(p*X[i][k]);
        }
    }
    dn(n,1,i){
        R[i]=Y[i]/X[i][i]; dn(i-1,1,j) Y[j]=Y[j]+inv(X[j][i]*R[i]);
    }
    up(1,n,i) printf("%lld/%lld\n",R[i].a,R[i].b);
    return 0;
}
```

- 简单粗暴小范围打表程序：

```cpp
#include<bits/stdc++.h>
#define up(l,r,i) for(int i=l,END##i=r;i<=END##i;++i)
#define dn(r,l,i) for(int i=r,END##i=l;i>=END##i;--i)
using namespace std;
typedef long long i64;
const int INF =2147483647;
i64 A[25];
int main(){
    A[0]=-3,A[1]=-6,A[2]=-12;
    up(3,20,i){
        A[i]=3*A[i-1]+A[i-2]-3*A[i-3]+(int)pow(3,i);
    }
    up(0,20,i){
        printf("A[i]=%lld\n",A[i]);
    }
    up(1,20,i){
        printf("%lld %lld ",(i64)pow(3,i),(i64)pow(3,i)*i);
        printf("%lld %lld ",(i64)pow(-1,i),(i64)pow(-1,i)*i);
        printf("%lld %lld %lld ",1ll*i*i,1ll*i,1ll);
        printf("%lld\n",A[i]);
    }
    return 0;
}
```

- 最重要的，本题 $\text{AC}$ 代码：

```cpp
#include<bits/stdc++.h>
#define up(l,r,i) for(int i=l,END##i=r;i<=END##i;++i)
#define dn(r,l,i) for(int i=r,END##i=l;i>=END##i;--i)
using namespace std;
typedef long long i64;
typedef unsigned int       u32;
typedef unsigned long long u64;
const int INF =2147483647;
namespace Mker{
	u64 sd;int op;
	inline void init(){scanf("%llu%d",&sd,&op);}
	inline u64 ull_rand(){
		sd^=sd<<43,sd^=sd>>29,sd^=sd<<34; return sd;
	}
	inline u64 rand(){
		if (op==0) return (ull_rand()%0xFFFF    )+1;
		if (op==1) return (ull_rand()%0xFFFFFFFF)+1; 
		return ull_rand();
	}
}
int qread(){
    int w=1,c,ret;
    while((c=getchar())> '9'||c< '0') w=(c=='-'?-1:1); ret=c-'0';
    while((c=getchar())>='0'&&c<='9') ret=ret*10+c-'0';
    return ret*w;
}
const int MAXN =65536+3,MOD=1e9+7;
int T,m=65535,W[MAXN],M[MAXN],t1,t2,t3,t,ans;
int pwr(u32 w){
    return 1ll*M[w>>16]%MOD*W[w&m]%MOD;
}
int qkp(int a,int b){
    int r=1;while(b){if(b&1)r=1ll*r*a%MOD;b>>=1,a=1ll*a*a%MOD;}return r;
}
int main(){
    T=qread(),Mker::init();
    W[0]=1; up(1,m,i) W[i]=3ll*W[i-1]%MOD; M[1]=3ll*W[m]%MOD;
    M[0]=1; up(2,m,i) M[i]=1ll*M[1]*M[i-1]%MOD;
    t=qkp(32,MOD-2);
    up(1,T,i){
        u64 n=Mker::rand(),res=1ll*((n%MOD*36ll+MOD-117)%MOD*pwr(n%(MOD-1))%MOD+((n&1)?15:MOD-15)+36)%MOD*t%MOD; 
        ans^=res;
    }
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：AsunderSquall (赞：4)

本人不会生成函数，只会大力乱搞。   
因为这个乱搞思维含量非常低，但是很烦，容易出错。  
如果给足够的时间的话这题应该是个大水题。  

由于我推通项的时候在本地的 Typora 编辑的，所以格式不太一样，因此我就直接把截图发上来了。
![](https://cdn.luogu.com.cn/upload/image_hosting/xcavc6up.png)  
![](https://cdn.luogu.com.cn/upload/image_hosting/imrc30v8.png)  
![](https://cdn.luogu.com.cn/upload/image_hosting/79qrswjh.png)  

因此  
$$a_n=\begin{cases}\dfrac{(4n-13)\times3^{n+2}+51}{32}, & (n \bmod 2=1),\\\dfrac{(4n-13)\times3^{n+2}+21}{32}, & (n \bmod 2=0)\end{cases}$$  

然后考虑到 $3^{n+2}$ 每次处理都要 $\log n$ 的时间，很不划算。  
我们先用一波费马小定理 $3^{n+2}=3^{(n+2)\bmod 1000000006}$  
然后剩下的数字可以直接光速幂计算  
还有就是 $n \bmod2$ 的值必须直接判断，不能取模之后再判断。  
代码：
```cpp
const ull inv32=ksm(32);
ull T,ans;

ull pw1[N+5],pw2[N+5];
void init()
{
    pw1[0]=1;for (int i=1;i<=N;i++) pw1[i]=pw1[i-1]*3%mod;
    pw2[0]=1;for (int i=1;i<=N;i++) pw2[i]=pw2[i-1]*pw1[N]%mod;
}
ull gsm(int n){return pw2[n/N]*pw1[n%N]%mod;}
signed main()
{
    rd(T);Mker::init();
    init();
    while (T--)
    {
        ull n=Mker::rand();
        bool tmp=n%2;
        ull m=n%(Mod);n%=mod;
        ans^=((4*n+mod-13)%mod*gsm((m+2)%Mod)%mod+(tmp?51:21))*inv32%mod;
    }
    cout<<ans<<endl;
}

```

---

## 作者：无名之雾 (赞：2)

不理解为什么没人用特征根法求通项公式。

首先需要将 $3^n$ 消去。以构造特征方程。

$$3a_n=9a_{n-1}+3a_{n-2}-9a_{n-3}+3^{n+1}$$
$$3a_{n+1}=3a_{n}+a_{n-1}-3a_{n-2}+3^{n+1}$$
$$a_{n+1}=6a_n+8a_{n-1}-6a_{n-2}+9a_{n-3}$$
$$a_{n+4}=6a_{n+3}+8a_{n+2}-6a_{n+1}+9a_n$$

构造特征方程：

$$x^4=6x^3+8x^2+6x+9$$
$$(x+1)(x-1)(x-3)^2$$

特征根为 $1,-1,3,3$

设 $a_n=1^nA+(-1)^nB+3^n(Cn+D)$。

有方程组：

$$ \begin{cases} A+B+D=-3 \\ A-B+3(C+D)=-6 \\A+B+9(2C+D)=-12 \\A-B+27(3C+D)=-6
\end{cases}$$

解得：

$$ \begin{cases} A = \dfrac{9}{8}\\ B = -\dfrac{15}{32}\\ C = \dfrac{9}{8}\\ D = -\dfrac{117}{32}
\end{cases}$$

$$a_n=\dfrac{9}{8}+\dfrac{15}{32}(-1)^{n+1}+3^n(\dfrac{9}{8}n-\dfrac{117}{32})$$
$$a_n=\dfrac{3^{n+2}(4n-13)+36-15(-1)^n}{32}$$

---

## 作者：m256i (赞：1)

可以作为混凝土数学第 7 章的练习题了（

$$a_n=3a_{n-1}+a_{n-2}-3a_{n-3}+3^n$$

带上 $a_0=-3,a_1=-6,a_2=-12$ 与 $\forall n<0,a_n=0$，我们得到这样一个递归式：

$$a_n=3a_{n-1}+a_{n-2}-3a_{n-3}+3^n[n \ge 0]-4[n=0]$$

转换成生成函数 $A(x)$：

$$
\begin{aligned}
A(x)&=\sum_{n \ge 0}a_nx^n\\
&=\sum_{n \ge 0}(3a_{n-1}+a_{n-2}-3a_{n-3}+3^n[n \ge 0]-4[n=0])x^n\\
&=3\left(\sum_na_{n-1}x^n\right)+\left(\sum_na_{n-2}x^n\right)-3\left(\sum_na_{n-3}x^n\right)+\left(\sum_{n \ge 0}3^nx^n\right)-4\\
&=3xA(x)+x^2A(x)-3x^3A(x)+\dfrac{1}{1-3x}-4
\end{aligned}
$$

解一下这个方程：

$$
\begin{aligned}
A(x)&=3xA(x)+x^2A(x)-3x^3A(x)+\dfrac{1}{1-3x}-4\\
(1-3x-x^2+3x^3)A(x)&=\dfrac{1}{1-3x}-4\\
(1-3x-x^2+3x^3)A(x)&=\dfrac{-3+12x}{1-3x}\\
A(x)&=\dfrac{-3+12x}{(1-3x-x^2+3x^3)(1-3x)}
\end{aligned}
$$

把下面因式分解：

$$A(x)=\dfrac{-3+12x}{(1+x)(1-x)(1-3x)^2}$$

这个式子肯定是没法做的。怎么拆开？

具体数学里讲述了一种叫做有理展开的技巧。

如果没有重根，存在简单的通项公式。但是本题有重根，做起来会比较麻烦。

---

假如多项式 $R(x)=\dfrac{P(x)}{Q(x)}$ 满足以下条件：

* $Q(x)=c(1-\rho_1x)^{d_1}(1-\rho_2x)^{d_2}\cdots(1-\rho_kx)^{d_k}$，其中 $\rho_1 \neq \rho_2 \neq \cdots \neq \rho_k$。
* $P(x)$ 的次数小于 $d_1+d_2+\cdots+d_k$。

那么必定存在若干个次数分别为 $d_i-1$ 的多项式 $f_i(x)$ 使得 $[x^n]R(x)=f_1(n)\rho_1^n+f_2(n)\rho_2^n+\cdots+f_k(n)\rho_k^n$，且 $f_i$ 的最高次项系数为：

$$
\dfrac{P\left(\frac{1}{\rho_i}\right)}{c(d_i-1)!\prod\limits_{j \ne i}\left(1-\frac{\rho_j}{\rho_i}\right)^{d_j}}
$$

证明过于复杂，此处略。

---

用这种方法，我们可以计算出 $a_n=[x^n]A(x)=-\dfrac{15}{32}(-1)^n+\dfrac{9}{8}+\left(\dfrac{9}{8}n+\alpha\right)3^n$。

把 $n=0$ 代入，可以算出 $\alpha=-\dfrac{117}{32}$。

因此通项公式为：

$$a_n=\dfrac{9}{8}-\dfrac{15}{32}(-1)^n+\left(\dfrac{9}{8}n-\dfrac{117}{32}\right)3^n$$

还可以提取一个公共分母：

$$a_n=\dfrac{36-15(-1)^n+(36n-117)3^n}{32}$$

光速幂即可。

如何检验这个结果的正确性？先验证一下小数据的正确性，然后数学归纳法即可。

接下来，我们来介绍一种传统方法。

在传统方法中，我们需要把 $A(x)$ 写成一下形式：

$$\dfrac{P}{1+x}+\dfrac{Q}{1-x}+\dfrac{R}{1-3x}+\dfrac{S}{(1-3x)^2}$$

通分一下，有：

$$
\dfrac{P(1-x)(1-3x)^2+Q(1+x)(1-3x)^2+R(1+x)(1-x)(1-3x)+S(1+x)(1-x)}{(1+x)(1-x)(1-3x)^2}
$$

然后花大力气展开：

$$
\dfrac{P(1-7x+15x^2-9x^3)+Q(1-5x+3x^2+9x^3)+R(1-3x-x^2+3x^3)+S(1-x^2)}{(1+x)(1-x)(1-3x)^2}
$$

按照 $x$ 的次数合并：

$$
\dfrac{(P+Q+R+S)+(-7P-5Q-3R)x+(15P+3Q-R-S)x^2+(-9P+9Q+3R)x^3}{(1+x)(1-x)(1-3x)^2}
$$

然后解这个四元一次方程组：

$$
\left\{
\begin{array}{rrrrl}
P&+Q&+R&+S&=-3\\
-7P&-5Q&-3R&&=12\\
15P&+3Q&-R&-S&=0\\
-9P&+9Q&+3R&&=0
\end{array}
\right.
$$

最终解得：

$$
\begin{cases}
P=-\dfrac{15}{32}\\
Q=\dfrac{9}{8}\\
R=-\dfrac{153}{32}\\
S=\dfrac{9}{8}
\end{cases}
$$

再把这些数代入 $A(x)$：

$$
\begin{aligned}
A(x)&=-\dfrac{15}{32}\dfrac{1}{1+x}+\dfrac{9}{8}\dfrac{1}{1-x}-\dfrac{153}{32}\dfrac{1}{1-3x}+\dfrac{9}{8}\dfrac{1}{(1-3x)^2}\\
&=\sum_{n \ge 0}-\dfrac{15}{32}(-x)^n+\dfrac{9}{8}x^n-\dfrac{153}{32}(3x)^n+\dfrac{9}{8}\dbinom{n+1}{n}(3x^n)\\
&=\sum_{n \ge 0}\left(-\dfrac{15}{32}(-1)^n+\dfrac{9}{8}+\left(-\dfrac{153}{32}+\dfrac{9}{8}(n+1)\right)3^n\right)x^n\\
&=\sum_{n \ge 0}\left(-\dfrac{15}{32}(-1)^n+\dfrac{9}{8}+\left(\dfrac{9}{8}n-\dfrac{117}{32}\right)3^n\right)x^n
\end{aligned}
$$

得到的结果相同，但是哪个更简单是显然的。

---

## 作者：peterwuyihong (赞：1)

来点 MO 题。

题意：$a_0=-3,a_1=-6,a_2=-12,a_n=3a_{n-1}+a_{n-2}-3a_{n-3}+3^n$

求满足 $a_n\equiv x\pmod{10^9+7}$ 的最小正整数 $x$。

$$a_n-a_{n-2}=3a_{n-1}-3a_{n-3}+3^n$$

设 $b_n=a_n-a_{n-2}$

$$b_n=3b_{n-1}+3^n$$

$$\frac{b_n}{3^n}=\frac{b_{n-1}}{3^{n-1}}+1$$

$$\frac{b_2}{3^2}=-1$$

$$\frac{b_n}{3^n}=n-3$$

$$a_n=a_{n-2}+(n-3)3^n$$

对奇偶讨论一下

$$a_n=\frac{21+3^{n+2}(4n-13)}{32}(n\bmod 2=0)$$

$$a_n=\frac{51+3^{n+2}(4n-13)}{32}(n\bmod 2=1)$$

肥妈小定理把幂次消下来，然后光速计算就行了。

复杂度 $O(\sqrt p+T)$

```cpp
#include<bits/stdc++.h>
using namespace std;
#define rep(i,j,k) for(int i=j;i<=(k);i++)
#define per(i,j,k) for(int i=j;i>=(k);i--)
#define all(x) x.begin(),x.end()
const int p=1e9+7;
template<class _Tp,class _tp>void add(_Tp&x,const _tp& y){((x+=y)>=p)&&(x-=p);}template<class _Tp,class _tp>_Tp Add(_Tp x,const _tp y){add(x,y);return x;}
template<class _Tp,class _tp>void sub(_Tp&x,const _tp&y){((x-=y)<0)&&(x+=p);}template<class _Tp,class _tp>_Tp Sub(_Tp x,const _tp y){sub(x,y);return x;}
template<class _Tp,class _tp>void mul(_Tp&x,const _tp&y){x=1ll*x*y%p;}template<class _Tp,class _tp>_Tp Mul(const _Tp x,const _tp y){return 1ll*x*y%p;}
template<class _Tp,class _tp>_Tp ksm(_Tp a,_tp b){_Tp ans(1);for(;b;b>>=1,mul(a,a))if(b&1)mul(ans,a);return ans;} 
template<class _Tp>_Tp div2(_Tp a){if(a&1)a+=p;return a>>1;}
struct gsm{
  #define _Tp int
  int _[32768][2],mx;
  gsm(int o,_Tp lim){
    mx=sqrt(lim)+1;
    _[0][0]=_[0][1]=1;
    for(int i=1;i<=mx;i++)_[i][0]=Mul(_[i-1][0],o);
    for(int i=1;i<=mx;i++)_[i][1]=Mul(_[i-1][1],_[mx][0]);
  }
  int operator()(_Tp x){return Mul(_[x%mx][0],_[x/mx][1]);}
}q(3,p);
const int inv=ksm(32,p-2);
#define ull unsigned long long
namespace Mker
{
//  Powered By Kawashiro_Nitori
//  Made In Gensokyo, Nihon
  #include<climits>
  #define uint unsigned int
  ull sd;int op;
  inline void init() {scanf("%llu %d", &sd, &op);}
  inline ull ull_rand()
  {
    sd ^= sd << 43;
    sd ^= sd >> 29;
    sd ^= sd << 34;
    return sd;
  }
  inline ull rand()
  {
    if (op == 0) return ull_rand() % USHRT_MAX + 1;
    if (op == 1) return ull_rand() % UINT_MAX + 1; 
    if (op == 2) return ull_rand();
  }
}
// 但是你大括号怎么换行啊
int u;
void solve(ull n){
  int t=n%p;
  int _t=(n+2)%(p-1);
  if(n%2==0)u^=Mul(Add(21,Mul(q(_t),Sub(Mul(4,t),13))),inv);
  else u^=Mul(Add(51,Mul(q(_t),Sub(Mul(4,t),13))),inv);
}
signed main(){
  int T;
  cin>>T>>Mker::sd>>Mker::op;
  while(T--)solve(Mker::rand());
  cout<<u;
}
```

---

## 作者：ricky0916 (赞：1)

~~求数列通项基础题~~

好，现在让我们开始求通项。

$ a_n=3a_{n-1}+a_{n-2}-3a_{n-3}+3^n $

$ a_n-a_{n-2}=3(a_{n-1}-a_{n-3})+3^n $

令$ b_n=a_n-a_{n-2} $

则$ b_n=3b_{n-1}+3^n $

所以$ \dfrac{b_n}{3^n}=\dfrac{b_{n-1}}{3^{n-1}}+1 $

令$ c_n=\dfrac{b_n}{3^n} $

则$ c_n=c_{n-1}+1 $

所以$ c_n=c_2+n-2 $

而$ b_2=a_2-a_0=-9 $

所以$ c_2=-1 $，得$ c_n=n-3 $

于是$ b_n=(n-3)\times 3^n $

现在来做个分类。

1. 当$ 2|n $时

$$
a_n=a_0+\sum_{i=1}^{\frac{n}{2}} (2i-3)\times 3^{2i}
$$
令
$$
X=\sum_{i=1}^{a} (2i-3)\times 3^{2i}
$$
则
$$
\begin{aligned}
9X&=\sum_{i=1}^a (2i-3)\times 3^{2i+2}\\
8X&=(2a-3)\times 3^{2a+2}-\sum_{i=2}^a 2\times 9^i+9\\
8X&=(2a-3)\times 3^{2a+2}-\dfrac{9^{a+1}-9^2}{4}+9\\
X&=\dfrac{(8a-13)\times 3^{2a+2}+117}{32}
\end{aligned}
$$

代入$ a=\dfrac{n}{2} $，得到$ a_n=\dfrac{(4n-13)\times 3^{n+2}+21}{32} $

2. 当$ 2\nmid n $时，~~同理~~，$ a_n=\dfrac{(4n-13)\times 3^{n+2}+51}{32}  $

所以得到了通项：$ a_n=\dfrac{(36n-117)\times 3^n+36-15\times(-1)^n}{32} $

（此处乘进去为了防暴`ull`）

于是我们就可以光速幂预处理，$ O(1) $回答了！

（32在$ \bmod $ $ 10^9+7$意义下逆元为$ 281250002 $）

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int gsm1[40010],gsm2[40010],n,hhh,ans;
const int mod=1000000007,_32=281250002;
void phy26(){
	gsm1[0]=gsm2[0]=1;
	for(int i=1;i<=31623;i++){
		gsm1[i]=1ll*gsm1[i-1]*3%mod;
	}
	for(int i=1;i<=31623;i++){
		gsm2[i]=1ll*gsm2[i-1]*gsm1[31623]%mod;
	}
}
inline int gsm(int x){
	return 1ll*gsm2[x/31623]*gsm1[x%31623]%mod;
}
namespace Mker
{
//  Powered By Kawashiro_Nitori
//  Made In Gensokyo, Nihon
	#include<climits>
	#define ull unsigned long long
	#define uint unsigned int
	ull sd;int op;
	inline void init() {scanf("%llu %d", &sd, &op);}
	inline ull ull_rand()
	{
		sd ^= sd << 43;
		sd ^= sd >> 29;
		sd ^= sd << 34;
		return sd;
	}
	inline ull rand()
	{
		if (op == 0) return ull_rand() % USHRT_MAX + 1;
		if (op == 1) return ull_rand() % UINT_MAX + 1; 
		if (op == 2) return ull_rand();
	}
}
int solve(unsigned long long x){
	if(x%2==0) return 1ll*(1ll*(36*(x%mod)-117+mod)%mod*gsm(x%(mod-1))+21)%mod*_32%mod;
	return 1ll*(1ll*(36*(x%mod)-117+mod)%mod*gsm(x%(mod-1))+51)%mod*_32%mod;
}
int main(){
	phy26();
	scanf("%d",&n);
	Mker::init();
	for(int i=0;i<n;i++){
		ans^=solve(Mker::rand());
	}
	printf("%d",ans);
	return 0;
}
```


---


# 排列计数

## 题目描述

我们记一个排列 $P$ 的升高为 $k$ 当且仅当存在 $k$ 个位置 $i$ 使得 $P_i<P_{i+1}$。

现在给定排列长度 $n$，对于所有整数 $k\in [0,n]$ 求有多少个排列的升高为 $k$。

## 说明/提示

对于 $100\%$ 的数据，$1\leq n\leq 2\times 10^5$。

## 样例 #1

### 输入

```
4```

### 输出

```
1 11 11 1 0```

# 题解

## 作者：Elegia (赞：52)

普及一个奇妙的组合意义证明。

我们首先将答案除以 $n!$ 这样就是概率，考虑 $n$ 个实数的均匀分布 $(a_1, a_2, \cdots, a_n) \in (0, 1)^n$，显然有两个实数相等的概率是 $0$，那么根据对称性 $a_i$ 的大小关系服从排列 $p_i$ 是等概率的。也就是说我们转而考虑 $a_i < a_{i + 1}$ 的位置有 $k$ 个的概率。

令 $a_0 = 0$，考虑差分 $b_i = (a_i - a_{i - 1}) \bmod 1$，因此 $b_i \in (0, 1)$ 且我们可以认为建立了 $(b_1, b_2, \cdots, b_n)$ 到 $(a_1, a_2, \cdots, a_n)$ 的一个“均匀”映射。

考虑 $\sum_{i = 1}^n b_i$ 的意义，如果 $a_i < a_{i + 1}$ 那么说明 $b_{i + 1}$ 没有在取模时加一，否则发生了加一。因此 $\sum b_i = a_n + n - 1 - k$，也就是说我们仅仅是在计算对于实数 $x_1, x_2, \cdots, x_n \in (0, 1)$，$\sum x_i \in (n - 1 - k, n - k)$ 的概率我们只需算出 $\sum x_i < n - k$ 的概率然后差分即可。

考虑形式上我们虽然是求概率，但是考虑扩展为“测度”，也就是对于可行的每一部分的 $n$ 维微元进行求和，我们可以先假设没有 $x_i < 1$ 的限制，那么总共的测度是 $\frac{(n-k)^n}{n!}$。进行容斥，假设有 $j (j \le n - k)$ 个数强制 $\ge 1$，那么这一部分的测度是 $\frac{(n - k - j)^n}{n!}$。

因此概率可以通过一部中间运算得到：

$$
\sum_{j=0}^{n-k} (-1)^j \binom n j  \frac{(n - k - j)^n}{n!} = \sum_{j = 0}^{n - k} \frac{(-1)^j}{j!(n - j)!} (n - k - j)^n
$$

一次卷积。

---

## 作者：Karry5307 (赞：24)

### 题意

我的题面写的挺直白的，不再多过解释。

$\texttt{Data Range:}n\leq 2\times 10^5$

### 题解

对于长度为 $n$ 且有 $k$ 个上升的排列定义为**欧拉数** $\left\langle\begin{matrix}n\\k\end{matrix}\right\rangle$。

其实这个东西的英文名叫 $\texttt{Eulerian Number}$，所以说别把它和另一个欧拉数搞混淆了。

首先我们有一个非常 $\texttt{naive}$ 的想法是 $\texttt{dp}$。

考虑从长度为 $n-1$ 的排列中插入一个 $n$ 来构造长度为 $n$ 的排列。

然后有四种情况。

- 在排列的左端插入一个 $n$，这样不产生任何升高，所以这种情况从 $\left\langle\begin{matrix}n-1\\k\end{matrix}\right\rangle$ 转移来。

- 在排列的右端插入一个 $n$，这样会产生一个升高，所以这种情况由 $\left\langle\begin{matrix}n-1\\k-1\end{matrix}\right\rangle$ 转移来。

- 在某一个位置 $i$ 和 $i+1$ 中间插入 $n$，其中 $P_i<P_{i+1}$，那么这里会产生一个升高，同时会破坏原来的一个升高，所以总的升高是不变的。所以之前的排列要有 $k$ 个升高，所以，这种情况由 $k\left\langle\begin{matrix}n-1\\k\end{matrix}\right\rangle$转移来。

- 在某一个位置 $i$ 和 $i+1$ 中间插入 $n$，其中 $P_i>P_{i+1}$，那么这里会产生一个升高，但是不会破坏任何原有的升高，所以总而言之产生了一个升高。所以之前的排列要有 $k-1$ 个升高，所以，这种情况由 $(n-k-1)\left\langle\begin{matrix}n-1\\k-1\end{matrix}\right\rangle$转移来。

所以，我们有一个简单的递推式：

$$\left\langle\begin{matrix}n\\k\end{matrix}\right\rangle=(k+1)\left\langle\begin{matrix}n-1\\k\end{matrix}\right\rangle+(n-k)\left\langle\begin{matrix}n-1\\k-1\end{matrix}\right\rangle$$

然后，我们来证明一个非常重要的恒等式叫做 $\texttt{Worpitzky}$ 恒等式，为

$$x^n=\sum\limits_{k}\left\langle\begin{matrix}n\\k\end{matrix}\right\rangle\binom{x+k}{n}$$

在证明这个之前，我们先来证明一个小小的东西做热身：

$$x\binom{x+k}{n}=(k+1)\binom{x+k}{n+1}+(n-k)\binom{x+k+1}{n+1}$$

两边强行展开一下就好了，然后我们用数学归纳法证。

首先，要证明的柿子在 $n=0$ 时成立。

然后，若 $x^n=\sum\limits_{k=0}^{n}\left\langle\begin{matrix}n\\k\end{matrix}\right\rangle\binom{x+k}{n}$ 成立，则只需证 $x^{n+1}=\sum\limits_{k=0}^{n+1}\left\langle\begin{matrix}n+1\\k\end{matrix}\right\rangle\binom{x+k}{n+1}$ 也成立。

于是，我们来推推柿子，首先从一个很弱智的东西开始：

$$x^{n+1}=x\cdot x^n=\sum\limits_{k=0}^{n}\left\langle\begin{matrix}n\\k\end{matrix}\right\rangle x\binom{x+k}{n}$$

然后我们热身的东西就派上用场啦：

$$x^{n+1}=\sum\limits_{k=0}^{n}\left\langle\begin{matrix}n\\k\end{matrix}\right\rangle\left ((k+1)\binom{x+k}{n+1}+(n-k)\binom{x+k+1}{n+1}\right )$$

一步拆括号，有

$$x^{n+1}=\sum\limits_{k=0}^{n}\left\langle\begin{matrix}n\\k\end{matrix}\right\rangle (k+1)\binom{x+k}{n+1}+\sum\limits_{k=0}^{n}\left\langle\begin{matrix}n\\k\end{matrix}\right\rangle(n-k)\binom{x+k+1}{n+1}$$

然后，康康右边，我们用之前的递推式，有

$$\sum\limits_{k=0}^{n+1}\left\langle\begin{matrix}n+1\\k\end{matrix}\right\rangle\binom{x+k}{n+1}=\sum\limits_{k=0}^{n+1}\left ((k+1)\left\langle\begin{matrix}n\\k\end{matrix}\right\rangle+(n+1-k)\left\langle\begin{matrix}n\\k-1\end{matrix}\right\rangle\right )\binom{x+k}{n+1}$$

意识到在 $k=n+1$ 处被求和式值为 $0$，所以适当调整一下上界，并一步拆括号

$$\sum\limits_{k=0}^{n+1}\left\langle\begin{matrix}n+1\\k\end{matrix}\right\rangle\binom{x+k}{n+1}=\sum\limits_{k=0}^{n}(k+1)\left\langle\begin{matrix}n\\k\end{matrix}\right\rangle\binom{x+k}{n+1}+\sum\limits_{k=0}^{n}(n+1-k)\left\langle\begin{matrix}n\\k-1\end{matrix}\right\rangle\binom{x+k}{n+1}$$

右边的和式用 $k-1$ 代替 $k$，得到

$$\sum\limits_{k=0}^{n+1}\left\langle\begin{matrix}n+1\\k\end{matrix}\right\rangle\binom{x+k}{n+1}=\sum\limits_{k=0}^{n}(k+1)\left\langle\begin{matrix}n\\k\end{matrix}\right\rangle\binom{x+k}{n+1}+\sum\limits_{k=-1}^{n-1}(n-k)\left\langle\begin{matrix}n\\k\end{matrix}\right\rangle\binom{x+k+1}{n+1}$$

然后发现这个 $k=-1$ 和 $k=n$ 时右边和式中被求和式值为 $0$，调整一下上下界即可证明该恒等式。

然后就是有限微积分啊哈哈哈。首先我们注意到

$$\Delta\left (\binom{x+k}{n}\right)=\binom{x+k}{n-1}$$

然后做多次差分即可得到这样一个东西：

$$\Delta^m\left (\binom{x+k}{n}\right)=\binom{x+k}{n-m}$$

很好，于是我们可以前进一步了

$$\sum\limits_{k}\left\langle\begin{matrix}n\\k\end{matrix}\right\rangle\binom{x+k}{n-m}=\Delta^m(x^n)=\sum\limits_{j}\binom{m}{j}(-1)^{m-j}(x+j)^n$$

我们将 $x=0$ 代入，并使用一个非常常见的公式

$$m!\left\{\begin{matrix}n\\m\end{matrix}\right\}=\sum\limits_{k}\binom{m}{k}k^n(-1)^{m-k}$$

于是，有

$$\sum\limits_{k}\left\langle\begin{matrix}n\\k\end{matrix}\right\rangle\binom{k}{n-m}=m!\left\{\begin{matrix}n\\m\end{matrix}\right\}$$

很好，我们又迈出了一步。接下来是关键的一步。

我们两边对 $m$ 求和，有

$$\sum\limits_{m}\sum\limits_{k}\left\langle\begin{matrix}n\\k\end{matrix}\right\rangle\binom{k}{n-m}=\sum\limits_{m}m!\left\{\begin{matrix}n\\m\end{matrix}\right\}$$

乘上 $z^{n-m}$（换一个变量）

$$\sum\limits_{k}\left\langle\begin{matrix}n\\k\end{matrix}\right\rangle\sum\limits_{m}z^{n-m}\binom{k}{n-m}=\sum\limits_{m}z^{n-m}m!\left\{\begin{matrix}n\\m\end{matrix}\right\}$$

然后你会发现是个二项式定理的事情，然后简单的代换一下最终我们得到

$$\left\langle\begin{matrix}n\\k\end{matrix}\right\rangle=\sum\limits_{k}\left\{\begin{matrix}n\\k\end{matrix}\right\}\binom{n-k}{m}(-1)^{n-k-m}k!$$

很好。强行拆组合数

$$\left\langle\begin{matrix}n\\m\end{matrix}\right\rangle=\sum\limits_{k}\left\{\begin{matrix}n\\k\end{matrix}\right\}\frac{(n-k)!}{m!(n-k-m)!}(-1)^{n-k-m}k!$$

然后，写得更加清楚一点，我们有

$$m!\left\langle\begin{matrix}n\\m\end{matrix}\right\rangle=\sum\limits_{k}\left(\left\{\begin{matrix}n\\k\end{matrix}\right\}k!(n-k)!\right)\frac{(-1)^{n-(m+k)}}{(n-(m+k))!}$$

现在，我们设 $f_i=i!\left\langle\begin{matrix}n\\i\end{matrix}\right\rangle$， $g_k=\left\{\begin{matrix}n\\k\end{matrix}\right\}k!(n-k)!$， $h_k=\frac{(-1)^{n-k}}{(n-k)!}$，然后有

$$f_i=\sum\limits_{k}g_{k}h_{i+k}$$

把 $h$ 翻转一下做个卷积再把 $f$ 翻转回来即可。时间复杂度 $O(n\log n)$。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef int ll;
typedef long long int li;
const ll MAXN=524351,MOD=998244353,G=3,INVG=332748118;
ll fd,cnt,limit;
ll f[MAXN],g[MAXN],rev[MAXN],fact[MAXN],finv[MAXN];
inline ll read()
{
    register ll num=0,neg=1;
    register char ch=getchar();
    while(!isdigit(ch)&&ch!='-')
    {
        ch=getchar();
    }
    if(ch=='-')
    {
        neg=-1;
        ch=getchar();
    }
    while(isdigit(ch))
    {
        num=(num<<3)+(num<<1)+(ch-'0');
        ch=getchar();
    }
    return num*neg;
}
inline ll qpow(ll base,ll exponent)
{
    li res=1;
    while(exponent)
    {
        if(exponent&1)
        {
            res=1ll*res*base%MOD;
        }
        base=1ll*base*base%MOD,exponent>>=1;
    }
    return res;
}
inline void NTT(ll *cp,ll cnt,ll inv)
{
    ll cur=0,res=0,omg=0;
    for(register int i=0;i<cnt;i++)
    {
        if(i<rev[i])
        {
            swap(cp[i],cp[rev[i]]);
        }
    }
    for(register int i=2;i<=cnt;i<<=1)
    {
        cur=i>>1,res=qpow(inv==1?G:INVG,(MOD-1)/i);
        for(register ll *p=cp;p!=cp+cnt;p+=i)
        {
            omg=1;
            for(register int j=0;j<cur;j++)
            {
                ll t=1ll*omg*p[j+cur]%MOD,t2=p[j];
                p[j+cur]=(t2-t+MOD)%MOD,p[j]=(t2+t)%MOD;
                omg=1ll*omg*res%MOD;
            }
        }
    }
    if(inv==-1)
    {
        ll invl=qpow(cnt,MOD-2);
        for(register int i=0;i<=cnt;i++)
        {
            cp[i]=1ll*cp[i]*invl%MOD;
        }
    }
}
inline void setup(ll cnt)
{
    fact[0]=finv[0]=1;
    for(register int i=1;i<cnt;i++)
    {
        fact[i]=(li)fact[i-1]*i%MOD;
    }
    finv[cnt-1]=qpow(fact[cnt-1],MOD-2);
    for(register int i=cnt-2;i;i--)
    {
        finv[i]=(li)finv[i+1]*(i+1)%MOD;
    }
}
int main()
{
    setup((fd=read()+1)+10);
    for(register int i=0;i<fd;i++)
    {
        f[i]=(li)(i&1?MOD-1:1)*finv[i]%MOD;
        g[i]=(li)qpow(i,fd-1)*finv[i]%MOD;
    }
    cnt=1,limit=-1;
    while(cnt<(fd<<1))
    {
        cnt<<=1,limit++;
    }
    for(register int i=0;i<cnt;i++)
    {
        rev[i]=(rev[i>>1]>>1)|((i&1)<<limit);
    }
    NTT(f,cnt,1),NTT(g,cnt,1);
    for(register int i=0;i<cnt;i++)
    {
        f[i]=(li)f[i]*g[i]%MOD,g[i]=0;
    }
    NTT(f,cnt,-1);
    for(register int i=0;i<fd;i++)
    {
        f[i]=(li)f[i]*fact[i]%MOD*fact[fd-1-i]%MOD;
        g[i]=(fd-1-i)&1?MOD-finv[fd-1-i]:finv[fd-1-i];
    }
    for(register int i=fd;i<cnt;i++)
    {
    	f[i]=g[i]=0;
	}
    reverse(g,g+fd),NTT(f,cnt,1),NTT(g,cnt,1);
    for(register int i=0;i<cnt;i++)
    {
    	f[i]=(li)f[i]*g[i]%MOD;
	}
	NTT(f,cnt,-1),reverse(f,f+fd);
	for(register int i=0;i<fd;i++)
	{
		printf("%d ",(li)f[i]*finv[i]%MOD); 
	}
}
```

---

## 作者：⑨_Cirno_ (赞：17)

两位大佬写的都太神仙辣~，~~对像我这样对欧拉数一无所知的蒟蒻真的太不友好了~~，这里提供一种(可能)比较简便的做法

我们发现正好等于这个条件貌似不是很好办，所以我们尝试转化成计算这样一个东西：先钦定k个位置必须填小于号，其余位置没有要求，合法的数列总数，并对每个k求出这样的答案

考虑我们钦定过小于号后，我们把这个数列分段，如果两个位置有小于号相邻就吧它们分成一组，容易发现分完组后方案数就是个可重集合排列计数，也就是

$$\frac{n!}{\prod_{S}|S|!}$$

要计算对于所有可能集合这个式子的和，考虑使用指数生成函数，继续发现这个数列有n-1-k段，所以答案就是把序列划分成n-1-k段后每一段长度阶乘倒数的乘积之和，令m=n-1-k，用生成函数表示就是

$$[x^n](e^x-1)^m$$

把式子拆开

$$[x^n]\sum_{i=0}^m\binom{m}{i}(-1)^{m-i}e^i$$

$$=\sum_{i=0}^m\binom{m}{i}(-1)^{m-i}\frac{i^n}{n!}$$

$$=\frac{m!}{n!}\sum_{i=0}^m\frac{i^n}{i!}\frac{(-1)^{m-i}}{(m-i)!}$$

显然是个卷积，就可以nlogn计算每个k对应的值了

计算出这个值后，考虑怎么计算答案，设fi表示我们算出来的i对应的值，gi为有i个小于号的答案

我们可以列出式子

$$f_i=\sum_{j=i}^{n-1}\binom{j}{i}g_j$$

二项式反演一下

$$g_i=\sum_{j=i}^{n-1}(-1)^{j-i}\binom{j}{i}f_j$$

这个东西把式子拆开，翻转一下还是个卷积，所以我们可以用两次NTT在O(nlogn)的时间内算出答案啦

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef long long LL;
typedef long double lb;
#define ri register int
const int N=600005,M=998244353;
int i,n,j,r[N];
long long f[N],fac[N],inv[N],g[N];
long long qpow(long long a,long long b)
{
	long long s=a,ans=1;
	while(b)
	{
		if(b&1)
			ans=ans*s%M;
		s=s*s%M;
		b>>=1;
	}
	return ans;
}
void NTT(long long *f,int op,int lim)
{
	for(ri i=0;i<lim;++i)
		r[i]=(r[i>>1]>>1)|(i&1?lim>>1:0);
	for(i=0;i<lim;++i)
		if(i<r[i])
			swap(f[i],f[r[i]]);
	for(ri i=1;i<lim;i<<=1)
	{
		long long wn=qpow(3,op==1?(M-1)/(i<<1):M-1-(M-1)/(i<<1));
		for(ri j=0;j<lim;j+=i<<1)
		{
			long long s=1;
			for(ri k=j;k<j+i;++k)
			{
				long long a=f[k],b=f[k+i]*s;
				f[k]=(a+b)%M;
				f[k+i]=(a-b)%M;
				s=s*wn%M;
			}
		}
	}
	if(op==-1)
	{
		long long inv=qpow(lim,M-2);
		for(ri i=0;i<lim;++i)
			f[i]=f[i]*inv%M;
	}
}
int main()
{
	scanf("%d",&n);
	fac[0]=1;
	for(ri i=1;i<=n;++i)
		fac[i]=fac[i-1]*i%M;
	inv[n]=qpow(fac[n],M-2);
	for(ri i=n-1;i>=0;--i)
		inv[i]=inv[i+1]*(i+1)%M;
	for(ri i=0;i<=n;++i)
		f[i]=inv[i]*qpow(i,n)%M;
	for(ri i=0;i<=n;++i)
		g[i]=inv[i]*(i&1?-1:1);
	int lim=1;
	while(lim<=2*n)
		lim<<=1;
	NTT(f,1,lim);
	NTT(g,1,lim);
	for(i=0;i<lim;++i)
		f[i]=f[i]*g[i]%M;
	NTT(f,-1,lim);
	for(i=1;i<=n;++i)
		f[i]=f[i]*fac[i]%M;
	for(i=0;i<n;++i)
		f[i]=f[i+1];
	for(i=n;i<lim;++i)
		f[i]=0;
	memset(g,0,sizeof(g));
	for(i=0;i<n;++i)
		f[i]=fac[n-1-i]*f[i]*(i&1?-1:1)%M;
	for(i=0;i<n;++i)
		g[i]=inv[i];
	NTT(f,1,lim);
	NTT(g,1,lim);
	for(i=0;i<lim;++i)
		f[i]=f[i]*g[i]%M;
	NTT(f,-1,lim);
	for(i=0;i<n;++i)
		f[i]=f[i]*inv[n-1-i]%M;
	reverse(f,f+n);
	for(i=0;i<n;++i)
		printf("%lld ",(f[i]*((i^n)&1?1:-1)%M+M)%M);
	putchar('0');
}
```


---

## 作者：木xx木大 (赞：13)

EI的组合意义大法和其他巨佬的数学归纳法太神仙啦！

这里参考 command_block 的博客，写了一种暴力生成函数推导的做法

按一般套路把“恰好”反演掉。设 $f(k)$ 表示钦定有 $k$ 次升高的方案数。钦定一些位置填小于号后对数列“分段”，每个小于号将它左右合并为一段。

单独考虑每个段的贡献，其 EGF 即为 $\sum\limits_{i=1}=\frac{x^i}{i!}=e^x-1$。
如果钦定有 $k$ 个升高，则有 $m=n-k$ 个段，得到
$$
			\begin{aligned}
				[x^n](e^x-1)^m=&[x^n]\sum_{i=0}^{m}{m\choose i}e^{ix}(-1)^{m-i}\\
				=&\sum_{i=0}^{m}{m\choose i}\frac{i^n}{n!}(-1)^{m-i}\\
				=&\frac{m!}{n!}\sum_{i=0}^m\frac{i^n}{i!}\frac{(-1)^{m-i}}{(m-i)!}
			\end{aligned}	
$$

按这个式子卷积一次再二项式反演一次即可得到答案，但我们还可以继续化简
$$
		\begin{aligned}
			\left\langle\begin{matrix}n \\ k\end{matrix}\right\rangle&=n!\sum\limits_{i=k}^n\dbinom{i}{k}(-1)^{i-k}[x^n](e^x-1)^{n-i}\\ &=n!\sum\limits_{i=k}^n\dbinom{i}{k}(-1)^{i-k}\sum\limits_{j=0}^{n-i}\dbinom{n-i}{j}(-1)^{n-i-j}[x^n]e^{xj}\\ &=n!\sum\limits_{i=k}^n\dbinom{i}{k}(-1)^{i-k}\sum\limits_{j=0}^{n-k}\dbinom{n-i}{j}(-1)^{n-i-j}\dfrac{j^n}{n!}\\ &=\sum\limits_{j=0}^{n-k}(-1)^{n-k-j}j^n\sum\limits_{i=k}^n\dbinom{i}{k}\dbinom{n-i}{j}\\ &=\sum\limits_{j=0}^{n-k}(-1)^{n-k-j}j^n\dbinom{n+1}{k+j+1}\\ 
		\end{aligned}	
$$
其中倒数第二步中 ${i\choose k}=[x^{i-k}]\frac{1}{(1-x)^{k+1}},{n-i\choose j}=[x^{n-i-j}]\frac{1}{(1-x)^{j+1}}$，则它们卷起来得到 $[x^{n-k-j}]\frac{1}{(1-x)^{k+j+2}}={n+1\choose k+j+1}$

于是我们只需要做一遍差卷积即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
namespace FGF
{
	const int N=1e6+5,mo=998244353,g=3,gi=(mo+1)/3;
	int n,m,a[N],fac[N],inv[N],b[N],lim,r[N];
	int qpow(int x,int y)
	{
		int s=1;
		while(y)
		{
			if(y&1)s=1ll*s*x%mo;
			x=1ll*x*x%mo;
			y>>=1;
		}
		return s;
	}
	void NTT(int *y,int op)
	{
		for(int i=0;i<lim;i++)
			if(r[i]<i)swap(y[r[i]],y[i]);
		for(int l=1;l<lim;l<<=1)
			for(int i=0,wn=qpow(op==1?g:gi,(mo-1)/(l<<1));i<lim;i+=(l<<1))
				for(int j=0,w=1;j<l;j++,w=1ll*w*wn%mo)
				{
					int tmp=(y[i+j]-1ll*y[i+j+l]*w%mo+mo)%mo;
					y[i+j]=(y[i+j]+1ll*y[i+j+l]*w%mo)%mo,y[i+j+l]=tmp;
				}
		if(op==-1)
			for(int i=0,inv=qpow(lim,mo-2);i<lim;i++)
				y[i]=1ll*y[i]*inv%mo;
	}
	void work()
	{
		scanf("%d",&n);
		fac[0]=inv[1]=inv[0]=1;
		for(int i=2;i<=n+1;i++)
			inv[i]=1ll*inv[mo%i]*(mo-mo/i)%mo;
		for(int i=1;i<=n+1;i++)
			fac[i]=1ll*i*fac[i-1]%mo,inv[i]=1ll*inv[i-1]*inv[i]%mo;
		for(int i=0;i<=n;i++)
			a[i]=((((n-i)&1)?-1ll:1ll)*inv[i+1]*inv[n-i]%mo+mo)%mo;
		for(int i=0;i<=n;i++)
			b[i]=qpow(i,n);
		reverse(a,a+n+1);
		for(lim=1;lim<(n+n+2);lim<<=1);
		for(int i=0;i<lim;i++)r[i]=r[i>>1]>>1|(i&1)*(lim>>1);
		NTT(a,1),NTT(b,1);
		for(int i=0;i<lim;i++)a[i]=1ll*a[i]*b[i]%mo;
		NTT(a,-1);
		reverse(a,a+n+1);
		for(int i=0;i<=n;i++)
			printf("%lld ",1ll*a[i]*fac[n+1]%mo);
			
	}
}
int main()
{
	FGF::work();
	return 0;
}
```
		
还有一个不知道有没有用的结论
$$
x^n=\sum\limits_{k=0}^n\left\langle\begin{matrix}n\\k\end{matrix}\right\rangle\dbinom{x+k}{n}
$$
		

---

## 作者：Aleph1022 (赞：12)

几乎是对于 EI 的题解的人话翻译。

首先转为计算概率。这只需要最后乘上 $n!$。  
我们考虑一个在 $(0,1)^n$ 上均匀随机的实数序列 $a_1,a_2,\dots,a_n$，将其排出排名。我们知道两个实数相等的概率是 $0$，所以这是良定义的。  
然后根据强烈的对称性，我们知道所有 $n$ 阶排列也满足同样的分布。这就是说，我们考虑 $a_1,a_2,\dots,a_n$ 序列的一种排名的出现概率就等价于同种排列的出现概率。

考虑令 $a_0 = 0$，我们做其差分 $b_i = (a_i - a_{i-1}) \bmod 1$。由于 $a_i \in (0,1)$，我们知道可以通过 $b_i$ 序列唯一确定 $a_i$ 序列。  
同时，我们注意到 $b_i = a_i - a_{i-1} + [a_i < a_{i-1}]$。则可知 $\sum b_i = a_n + n-1-k$。由于我们知道 $n-1-k$ 必然是 $\sum b_i$ 的整数部分，所以实际上我们仅考虑 $b_i$ 序列的分布和其 $\sum b_i$ 即可对 $n-1-k$ 进行限制。

于是现在问题转化为计算 $b_1,b_2,\dots,b_n \in (0,1)^n$ 且 $\sum b_i \in (n-1-k,n-k)$ 的概率。  
我们可以差分为 $\sum b_i < n-k$ 和 $\sum b_i < n-1-k$。

然后接下来的一步或许会让大部分读者有些匪夷所思。我将尽我所能让您理解。  
形象地，假设我们给定 $n$ 个 $(0,1)$ 内的区间 $(l_i,r_i)$，问 $\forall i,b_i \in [l_i,r_i]$ 的概率。那自然是 $\prod \frac{r_i-l_i}{1-0} = \prod (r_i - l_i)$。  
我们发现，如果我们有办法用一个图像刻画出这个序列落在每一种可能性中是合法或非法，那么事实上最终的答案就是这个图形的「面积」（这也是我们选择 $(0,1)$ 的原因）。

接下来我们考虑用容斥来刻画这个图形的「面积」，这是为了去除 $b_i < 1$ 的限制。  
首先我们考虑 $b_i$ 完全没有上界，$\sum b_i < n-k$ 的「面积」。  
我们转为考虑 $s_i = \sum_{j \le i} b_j$ 的「面积」，如果不考虑大小关系，它其实就是 $(n-k)^n$。但是我们又要求 $b_i > 0$，因此 $s_i$ 必须是上升的，因此我们再除以 $n!$。  
对于某些 $b_i$ 被钦定 $\ge 1$，我们可以从总和中减去这些 $1$，然后就转为了前文的问题。  
总结一下就是
$$
\sum\limits_{i=0}^{n-k} (-1)^i \binom ni \frac{(n-k-i)^n}{n!}
$$

可以卷积解决。

---

## 作者：皎月半洒花 (赞：10)

### 题意

我们记一个排列$P$的升高为$k$当且仅当存在$k$个位置$i$使得$P_i<P_{i+1}$

现在给定排列长度$n$，对于所有整数$k\in [0,n]$求有多少个排列的升高为$k$。

$n\leq 200,000$

### $\rm Sol$

首先写一个递推式，令$f(n,k)$表示答案，则有

$$
f(n,k)=(n-k) \cdot f(n-1,k-1) + (k + 1) \cdot f(n-1,k)
$$

其意义是，考虑将这个序列的升高与圆排列的升高之间建立映射。定义顺时针为正方向（其实顺时针逆时针是对称的）。

* 一个长为$n$、升高为$k$的**圆排列**，有$n-k$种断开的方式，使之变成一个长为$n$，升高为$k$的**序列**；

* 一个长为$n$，升高为$k+1$的**圆排列**，有$k+1$种断开方式，使之变成一个长为$n$，升高为$k$的**序列**。

* 一个长为$n$，升高为$k$的**圆排列**，删除掉值为$n$的那一项，则一定会删除掉恰好$1$个升高，所以对应一个长为$n-1$，升高为$k-1$的**序列**。

* 一个长为$n$，升高为$k+1$的**圆排列**，删除掉值为$n$的那一项，则一定会删除掉恰好$1$个升高，所以对应一个长为$n-1$，升高为$k$的**序列**。


显然后面两条的逆操作同样成立，所以是双射。

然而其实后面两条是等价的，只是平移了一下$k$…233

~~然后就可以获得一个$n^2$算法，得到$0pts$的好成绩了~~

_____

之后就需要用到黑宝书—— ~~《混凝土数学》~~ 《具体数学》了。

具体数学的$6.2$提到了这个数列（表），有一个公式是长这样的：

$$
f(n,m)=\sum _{k=0}^{m}\binom{n+1}{k}(m+1-k)^n(-1)^k
$$

然而~~混凝土~~编者当时都没有给出这东西是怎么来的，~~并且咱也不怎么会推~~ ，于是或许就可以当个结论记住？

不过如果要是证明它是对的倒挺简单……即考虑把上式记作这个数列**关于$\bold n$的$\bold m$展开**，那么大家手算一下发现这东西跟关于$n-1$的$m-1$展开和关于$n-1$的$m$展开，存在递推形式，且递推形式和一开始给出的递推式相同；加之初值一样，所以成立。

……然后就是计算生成函数，考虑如何计算第$n$行的$\bold {OGF}$

通过观察法，可以发现作为第$m$项系数的这个和式，其中$\sum _{k=0}^{m}\binom{n+1}{k}(-1)^k$是一个二项式的展开，再将$(m+1-k)^n$这东西对称处理一下，~~通过简单的结合律~~ 就可以得到它的$\bold{OGF}$:

$$
(1-x)^{n+1}\sum_{k=0}^{n} (k+1)^nx^{k}
$$

~~上述过程完全可以去OEIS上找，可以简化一系列猜结论+验证结论的过程~~

然后就是一个多项式快速幂了……

然而朴素的多项式快速幂是$\log^2$，~~再加上NTT本身>O(log n)的常数~~发现并不可以过……但实际上$(1-x)^n$状物就是个杨辉三角，于是组合数算一下就完了.jpg

（截止到我写下这一行字为止，我的code还是最快的）

```cpp

int main(){
    cin >> PL ; 
    K = PL += 1 ; int i, j ;
    for (i = 0 ; i < 19  ;++ i){
        rr int *rua = gg[i] ; rua[0] = 1 ;
        rr int gi = rua[1] = expow(3, 998244352/(1 << (i + 1))) ;
        for (j = 2 ; j < (1 << i) ; ++ j) 
            rua[j] = 1ll * rua[j - 1] * gi % P ;
    }
    M = 1 ;
    while (M <= (PL << 1)) M <<= 1, ++ l ;
    for (i = 0 ; i < M ; ++ i) 
        R[i] = (R[i >> 1] >> 1) | ((i & 1) << (l - 1)) ;
    F[0] = 1, F[1] = -1, 
    A[0] = 1, Fac[0] = Inv[0] = 1 ;
    for (i = 1 ; i <= PL ; ++ i) 
        Fac[i] = 1ll * Fac[i - 1] * i % P ;
    Inv[PL] = expow(qwq = Fac[PL], P - 2) ; 
    for (i = PL - 1 ; i ; -- i) 
        Inv[i] = 1ll * Inv[i + 1] * (i + 1) % P ;
    for (i = 0 ; i <= PL ; ++ i) 
        A[i] = (i & 1) ? P - Comb(i) : Comb(i) ;
    for (i = 0 ; i <= PL ; ++ i) 
        S[i] = expow(i + 1, PL - 1) ;
    NTT(A, M, 1), NTT(S, M, 1) ;
    for (i = 0 ; i <= M ; ++ i) 
        S[i] = 1ll * S[i] * A[i] % P ;
    NTT(S, M, -1) ;
    for (i = 0 ; i < PL ; ++ i) printf("%d ", S[i]) ;
    return 0 ;
}
```


讲道理，最后是不是应该%一下出题人啊，%%%$\sf{\color{black}{K}\color{red}{arry5307}}$














---

## 作者：Little09 (赞：7)

不会生成函数，不会组合意义，更不会具体数学。

------------

考虑先对升高容斥，钦定 $k$ 个位置是升高，其他位置任意。这时将序列分为了 $n-k$ 段，每段需要满足单调递增。问题变成了把 $1\sim n$ 放入 $n-k$ 个有标号的集合，使得每个集合不为空的方案数。

再对空集合容斥。钦定这 $n-k$ 个集合中的 $p$ 个集合为空，其他集合任意。那么问题就变成把 $1\sim n$ 放入 $n-k-p$ 个有标号的集合的方案数，这个问题是小学数学题，答案就是 $(n-k-p)^n$，可以快速幂处理。

具体地，我们记 $f(k)$ 表示把 $1\sim n$ 放入 $k$ 个有标号的集合，使得每个集合不为空的方案数。根据第二个容斥，可以得到：

$$f(k)=\sum_{i=0}^k\dbinom ki(-1)^i(k-i)^n$$

这是经典卷积形式，做一次卷积即可得到 $f$。

从 $f$ 得到答案只需要再做一次二项式反演即可。这部分平凡。

时间复杂度 $O(n\log n)$。

```cpp
int main()
{
	ios_base::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	cin >> n;
	init();
	ll tmp=1;
	for (int i=0;i<=n;i++)
	{
		a[i]=tmp*inv[i]%mod;
		tmp=mod-tmp;
		b[i]=p[i]*inv[i]%mod;
	}
	mul(n,n,a,b,c);
	for (int i=0;i<=n;i++) c[i]=c[i]*jc[i]%mod;
	for (int i=0;i<=n;i++) c[i]=c[i]*jc[n-i]%mod;
	tmp=1;
	for (int i=0;i<=n;i++) c[i]=c[i]*tmp%mod,tmp=mod-tmp;
	for (int i=0;i<=n;i++) b[i]=inv[i];
	mul(n,n,b,c,a);
	tmp=1;
	for (int i=0;i<=n;i++) a[i]=a[i]*tmp%mod*inv[n-i]%mod,tmp=mod-tmp;
	for (int i=n;i>=0;i--) cout << a[i] << " ";
	return 0;
}
```


---

## 作者：zzw4257 (赞：6)

给 EI 的题解的翻译再做一次翻译

首先考虑一个简单的转化，我们可以把整数上的偏序关系丢到实数上，具体的

$\frac{\left\langle\begin{matrix}n\\k\end{matrix}\right\rangle}{n!}$ 表示 $(0,1)$ 中均匀随机 $n$ 个实数 $\{a_i\}$ ，有 $k$ 个升高即 $\displaystyle \sum_{i=1}^{n-1} [a_{i+1}>a_i]=k$ 的概率

依然不好求，考虑差分,注意到这样会出负数然后接下来是精妙的一步，令 $b_i=a_i-a_{i-1}\mod 1=a_i-a_{i-1}+[a_i<a_{i-1}]$ ，则有 $\forall i,b_i\in(0,1)$ (注意到这样表示的好处很大，首先是值域统一了，然后也能够唯一还原回真正的差分数组从而还原回原数组了，根据前缀和可以快速判出到底有没有$+1$) 

对 $b_i$ 我们考察其性质，易有 $\displaystyle \sum_{i=1}^n b_i=\displaystyle \sum_{i=1}^n a_i-a_{i-1}+\sum_{i=1}^{n}[a_i<a_{i-1}]=a_n+n-1-k$

因此有 $\displaystyle \sum_{i=1}^n b_i\in(n-k-1,n-k)$

现在问题被完全转化为以下形式

> $(0,1)$ 中均匀随机 $n$ 个实数 $\{b_i\}$，$\sum b_i<x$ 的概率

不妨设问题的答案为 $F(x)$ 

接下来是更精妙的一步，注意到 $b_i$ 之间连接不紧密，限制只对其整体作用，因此考虑对 $\displaystyle c_i=\sum_{j=1}^i b_j$ 进一步研究

问题好像可以转为

> $(0,x)$ 中均匀随机 $n$ 个实数 $\{c_i\}$，$\forall i\in[1,n),c_{i+1}-c_i\in(0,1)$的概率。吗?

但是这是错的，正确的说法是

> $(0,x)$ 中均匀随机 $n$ 个实数 $\{c_i\}$，$\forall i\in[1,n),c_{i+1}-c_i\in(0,1)$的测度

关于这个玄妙的事实我们可以有一个感性的理解

那就是我们原来求的是 $(0,1)^n$ 这个 $n$ 维空间中间的合法的点集所占整个空间测度的比例，而现在概率空间的测度扩大，合法的点集的测度没有膨胀(意思就是求概率用的分子没变分母变,具体的原因是有一些点维度间不单调无法表示对原概率空间中的一个点施加前缀和变换的结果，这些点本来不存在于原问题概率空间中)，因此我们不能数比例(概率)而应该直接数测度相当于把分母从 $x^n$ 改回 $1^n$

具体来说，在 $(0,x)$ 均匀随机 $n$ 个实数满足某种特定的序关系的测度为 $\frac{x^n}{n!}$

下面是 $n=2$ 的一个解释

![](https://pic.imgdb.cn/item/618728af2ab3f51d91fcfed9.png)

关于上界钦定有几个相邻元素的差 $>1$ ，做个容斥,们有 $F(x)=\displaystyle \sum_{i=0}^{x}\binom{n}{i}(-1)^i \frac{(x-i)^n}{n!}$

答案为 $F(n-k)-F(n-k-1)$

---

## 作者：VinstaG173 (赞：6)

~~MD再也不直接赋点值了~~

~~好水的模板啊，不如改成【模板】多项式乘法——By Fading~~

~~看见花姐姐放出公式没有证明试了试结果证出来了（大雾~~

~~其实具体数学我是看过了的~~

首先我们要知道这样一个东西叫做欧拉数~~虽然你上搜索引擎搜到的欧拉数基本不是这个东西~~

用$\left\langle\begin{matrix}n\\k\end{matrix}\right\rangle$表示长度为$n$且升高为$k$个排列的个数。

首先有个递推式：

$$\left\langle\begin{matrix}n\\k\end{matrix}\right\rangle=(k+1)\left\langle\begin{matrix}n-1\\k\end{matrix}\right\rangle+(n-k)\left\langle\begin{matrix}n-1\\k-1\end{matrix}\right\rangle$$

这个可以利用其组合意义很容易证明，$\color{black}\mathsf{K}\color{red}\mathsf{arry}$和花姐姐也证过了，在此就不赘述了。

然后我们根据这个递推式，可以得出一个式子（《具体数学》P225）：

$$\left\langle\begin{matrix}n\\m\end{matrix}\right\rangle=\sum_{k=0}^{m}\binom{n+1}{k}(-1)^k(m+1-k)^n$$

尝试用数学归纳法证。

$$\left\langle\begin{matrix}n\\m\end{matrix}\right\rangle=(m+1)\left\langle\begin{matrix}n-1\\m\end{matrix}\right\rangle+(n-m)\left\langle\begin{matrix}n-1\\m-1\end{matrix}\right\rangle$$

$$=(m+1)\sum_{k=0}^{m}\binom{n}{k}(-1)^k(m+1-k)^{n-1}+(n-m)\sum_{k=0}^{m-1}\binom{n}{k}(-1)^k(m-k)^{n-1}$$

$$=\sum_{k=0}^{m}\binom{n}{k}(-1)^k\left[(m+1)(m+1-k)^{n-1}+(n-m)(m-k)^{n-1}\right]$$

$$=\sum_{k=0}^{m}\binom{n}{k}(-1)^k\left[(m+1-k)^n+k(m+1-k)^{n-1}+(n-m)(m-k)^{n-1}\right]$$

$$=\left(\sum_{k=0}^{m}\binom{n}{k}(-1)^k(m+1-k)^n\right)+\left(\sum_{k=0}^{m}\binom{n}{k}(-1)^k\dfrac{k}{m+1-k}(m+1-k)^n\right)+\left(\sum_{k=0}^{m}\binom{n}{k}(-1)^k(n-m)(m-k)^{n-1}\right)$$

$$=\left(\sum_{k=0}^{m}\left(\binom{n}{k}+\binom{n}{k-1}\right)(-1)^k(m+1-k)^n\right)+\left(\sum_{k=0}^{m}\binom{n}{k}(-1)^k(n-m)(m-k)^{n-1}\right)-\left(\sum_{k=0}^{m}k\left(\dfrac{1}{n+1-k}-\dfrac{1}{m+1-k}\right)\binom{n}{k}(-1)^k(m+1-k)^n\right)$$

其中

$$\left(\sum_{k=0}^{m}\binom{n}{k}(-1)^k(n-m)(m-k)^{n-1}\right)-\left(\sum_{k=0}^{m}k\left(\dfrac{1}{n+1-k}-\dfrac{1}{m+1-k}\right)\binom{n}{k}(-1)^k(m+1-k)^n\right)$$

将被减的求和式中$k$用$k+1$代替（容易发现$k=m$的项为$0$，且减号后的求和式中$k=0$的项为$0$）得到：

$$\left(\sum_{k=1}^{m}\binom{n}{k-1}(-1)^{k-1}(n-m)(m+1-k)^{n-1}\right)-\left(\sum_{k=1}^{m}k\left(\dfrac{m-n}{(n+1-k)(m+1-k)}\right)\binom{n}{k}(-1)^k(m+1-k)^n\right)$$

$$=\sum_{k=1}^{m}\binom{n}{k-1}(-1)^{k-1}(n-m)(m+1-k)^{n-1}-\left(\dfrac{k}{n+1-k}\binom{n}{k}\right)(-1)^k(m-n)(m+1-k)^{n-1}$$

容易看出上式为$0$。

所以

$$\left\langle\begin{matrix}n\\m\end{matrix}\right\rangle=\sum_{k=0}^{m}\left(\binom{n}{k}+\binom{n}{k-1}\right)(-1)^k(m+1-k)^n$$

$$=\sum_{k=0}^{m}\binom{n+1}{k}(-1)^k(m+1-k)^n$$

边界为$m=0$时$\left\langle\begin{matrix}n\\m\end{matrix}\right\rangle=1$，$n=0$且$m\neq 0$时$\left\langle\begin{matrix}n\\m\end{matrix}\right\rangle=0$，显然满足公式。

于是我们可以快乐地构造两个函数：

$$f(x)=\sum_k \binom{n+1}{k}(-1)^kx^k$$

与

$$g(x)=\sum_k (k+1)^n$$

然后求个卷积就完了。

Code:
```cpp
#include<cmath>
#include<cstdio>
#include<cstring>
using namespace std;
#define rg register
#define ll long long
const int o=998244353;
int N,M,Q,L=1,l=0;
int rev[600007];
ll f[600007],g[600007],h[600007],frc[600007],fic[600007];
void exgcd(ll a,ll b,ll &d,ll &x,ll &y)
{
	(b)?(exgcd(b,a%b,d,y,x),y-=x*(a/b)):(x=1,y=0,d=a);
}
inline ll _inv(ll a)
{
	ll d,x,y;
	exgcd(a,o,d,x,y);
	return (d==1)?(x+o)%o:-1;
}
inline ll qpw(rg ll x,rg ll k)
{
	rg ll r=1;
	while(k)
	{
		(k&1)&&(r=r*x%o),x=x*x%o,k>>=1;
	}
	return r;
}
inline void NTT(ll *a,int opt)
{
	for(rg int i=0;i<L;++i)
	{
		if(i<rev[i])
		{
			a[i]^=a[rev[i]]^=a[i]^=a[rev[i]];
		}
	}
	for(rg int m=1;m<L;m<<=1)
	{
		rg ll tmp=qpw(3,(o-1)/(m<<1)*opt+o-1);
		for(rg int s=0;s<L;s+=m<<1)
		{
			rg ll u=1;
			for(rg int t=0;t<m;++t,u=u*tmp%o)
			{
				ll a1=a[s+t],a2=a[s+t+m]*u%o;
				a[s+t]=(a1+a2)%o,a[s+t+m]=(a1-a2+o)%o;
			}
		}
	}
	if(~opt)return;
	Q=_inv(L);
	for(rg int i=0;i<L;++i)a[i]=a[i]*Q%o;
}
int main()
{
	scanf(" %d",&N);
	frc[0]=1;for(int i=1;i<=N+1;++i)frc[i]=frc[i-1]*i%o;
	fic[N+1]=_inv(frc[N+1]);for(int i=N;~i;--i)fic[i]=fic[i+1]*(i+1)%o;
	for(int i=0;i<=N;++i)g[i]=qpw(i+1,N),f[i]=frc[N+1]*fic[i]%o*fic[N+1-i]%o*((i&1)?o-1:1)%o;
	while(L<=(N<<1))L<<=1,++l;
	for(int i=0;i<L;++i)
	{
		rev[i]=(rev[i>>1]>>1)|((i&1)<<(l-1));
	}
	NTT(f,1);
	NTT(g,1);
	for(int i=0;i<L;++i)
	{
		h[i]=f[i]*g[i]%o;
	}
	NTT(h,-1);
	for(int i=0;i<=N;++i)
	{
		printf("%lld ",h[i]);
	}
	return 0;
}
```

---

## 作者：analysis (赞：1)

### P5825 排列计数

欧拉数：一忘皆空。

一点欧拉数的结论都不记得了（甚至还是 AC 后看题解区才发现是欧拉数），所以只能乱推了。

---

对于一个长度为 $n$ 的上升段来说，贡献了 $n-1$ 个上升位置。

故假设序列分为了 $i$ 个极长上升段，就有 $n-i$ 个升高。

于是拿二项式反演缝一下非极长上升段就好了。具体来说，假设 $f_i$ 为恰好有 $i$ 个升高的排列数，$g_i$ 为钦定 $i$ 个上升段的方案数，则：
$$
f_i=\sum_{j=i}^{n-1}\binom{j}{i}(-1)^{j-i}g_{n-j}
$$
考虑 $g_i=n![x^n](e^{x}-1)^i$，则：
$$
f_i=\sum_{j=i}^{n-1}\binom{j}{i}(-1)^{j-i}g_{n-j}\\
=\frac{1}{i!}\sum_{j=i}^{n-1}(\frac{(-1)^{j-i}}{(j-i)!})(j!g_{n-j})\\
$$
令 $a_i=\frac{(-1)^{i}}{i!}$、$b_i=i!g_{n-i}$。翻转 $a$，即 $a^{R}_i=a_{n-1-i}$，则：
$$
f_i=\frac{1}{i!}\sum_{j=0}^{n-1+i}a^{R}_{n-1+i-j}b_j\\
$$
卷积即可。

再讨论如何求 $g$，考虑到：
$$
g_i=n![x^n]\sum_{j=0}^{i}\binom{i}{j}e^{jx}(-1)^{i-j}\\
g_i=i!\sum_{j=0}^{i}\frac{j^n}{j!}\frac{(-1)^{i-j}}{(i-j)!}
$$
卷积即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
namespace Poly{
const int mod=998244353,g=3,N=524288;
#define poly vector<int>
    int fpow(int a,int b=mod-2){
        int r=1;
        while(b){
            if(b&1)r=1ll*r*a%mod;
            a=1ll*a*a%mod;
            b>>=1;
        }
        return r;
    }
int sz,w[N+5];
    void ntt(poly &a){
        for(int len=sz,mid=sz>>1;len>=2;len>>=1,mid>>=1){
            int wn=fpow(g,(mod-1)/len);
            for(int i=w[0]=1;i<mid;i++)w[i]=1ll*w[i-1]*wn%mod;
            for(int i=0;i<sz;i+=len){
                for(int j=0;j<mid;j++){
                    int x=a[i+j],y=a[i+j+mid];
                    a[i+j]=(x+y)%mod;
                    a[i+j+mid]=1ll*(x-y+mod)*w[j]%mod;
                }
            }
        }
    }
    void intt(poly &a){
        for(int len=2,mid=1;len<=sz;len<<=1,mid<<=1){
            int wn=fpow(fpow(g,(mod-1)/len));
            for(int i=w[0]=1;i<mid;i++)w[i]=1ll*w[i-1]*wn%mod;
            for(int i=0;i<sz;i+=len){
                for(int j=0;j<mid;j++){
                    int x=a[i+j],y=1ll*w[j]*a[i+j+mid]%mod;
                    a[i+j]=(x+y)%mod;
                    a[i+j+mid]=(x-y+mod)%mod;
                }
            }
        }
        int t=fpow(sz);
        for(int i=0;i<sz;i++)a[i]=1ll*a[i]*t%mod;
    }
    poly mul(poly a,poly b){
        int n=(int)a.size()+(int)b.size()-1;
        sz=1;while(sz<n)sz<<=1;a.resize(sz),b.resize(sz);
        ntt(a),ntt(b);for(int i=0;i<sz;i++)a[i]=1ll*a[i]*b[i]%mod;intt(a);
        a.resize(n);
        return a;
    }
}
using namespace Poly;
int n,fac[N+5],ifac[N+5];
poly a,b,c;
signed main(){
    for(int i=fac[0]=1;i<=N;i++)fac[i]=1ll*fac[i-1]*i%mod;
    ifac[N]=fpow(fac[N]);
    for(int i=N-1;i>=0;i--)ifac[i]=1ll*ifac[i+1]*(i+1)%mod;
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    cin>>n;a.resize(n),b.resize(n+1),c.resize(n+1);
    for(int i=0;i<=n;i++){
        b[i]=1ll*ifac[i]*fpow(i,n)%mod;
        c[i]=ifac[i];
        if(i&1)c[i]=(mod-c[i])%mod;
    }
    b=mul(b,c);b.resize(n+1);
    for(int i=0;i<=n;i++)b[i]=1ll*fac[i]*b[i]%mod;
    reverse(b.begin(),b.end());b.pop_back();
    for(int i=0;i<n;i++){
        a[i]=ifac[i];if(i&1)a[i]=(mod-a[i])%mod;
        b[i]=1ll*fac[i]*b[i]%mod;
    }
    reverse(a.begin(),a.end());
    a=mul(a,b);
    for(int i=0;i<n;i++)a[i]=1ll*ifac[i]*a[i+n-1]%mod;
    a.resize(n);a.push_back(0);
    for(auto ed:a)cout<<ed<<' ';
}
```

---

## 作者：可爱的小棉羊 (赞：1)

代码很简单，但是推式子真的长，而且 Karry 的推的过程~~难懂~~太强了，上面其他的都是用生成函数大法搞的。

决定写一篇关于卡巨佬的题解的人话翻译。

## $\texttt{Worpitzky}$ 恒等式

我们称长度为 $n$ 且有 $k$ 个上升的排列的个数为欧拉数（$\texttt{Eulerian Number}$）$\left\langle\begin{matrix}n\\k\end{matrix}\right\rangle$。

~~也就说本题我们可以取个新名字：欧拉数·行。~~

我们考虑如何做这玩意。

考虑 DP，我们假设前 $n-1$ 个已经排好了，我们要是插一个 $n$ 进去会发生什么呢，假设插入后有 $k$ 个升高。

1. 插在最后面不产生升高，这种情况有 $\left\langle\begin{matrix}n-1\\k\end{matrix}\right\rangle$ 种。

1. 插在最前面产生了一个升高，即为 $\left\langle\begin{matrix}n-1\\k-1\end{matrix}\right\rangle$。

1. 插在中间第 $i$ 位后面且 $P_i<P_{i+1}$ 那么他阻断了一个升高，有多出了一个，这种位置共有 $k$ 个，贡献为 $k\left\langle\begin{matrix}n-1\\k\end{matrix}\right\rangle$。

1. 插在中间第 $i$ 位后面且 $P_i>P_{i+1}$ 那么多出了一个，这种位置共有 $n-k-1$ 个，贡献为 $(n-k-1)\left\langle\begin{matrix}n-1\\k-1\end{matrix}\right\rangle$。

我们就得到了一个递推式：

$$\left\langle\begin{matrix}n\\k\end{matrix}\right\rangle=(k+1)\left\langle\begin{matrix}n-1\\k\end{matrix}\right\rangle+(n-k)\left\langle\begin{matrix}n-1\\k-1\end{matrix}\right\rangle$$

~~洛谷的 $\KaTeX$ 什么时候可以修修了，一个欧拉数要拿矩阵格式表示！~~

这样我们就有了一个 $n^2$ 的做法，~~获得了整整 $0$ 分！~~

我们现在来证一个恒等式，叫 $\texttt{Worpitzky}$ 恒等式。

$$x^n=\sum_{i}\left\langle\begin{matrix}n\\i\end{matrix}\right\rangle\binom{x+i}n$$

先做点小体操来证这个小等式：

$$x\binom {x+k}n=(k+1)\binom{x+k}{n+1}+(n-k)\binom{x+k+1}{n+1}$$

非常显然，展开就是答案。

那我们就开始证明吧！数学归纳法，启动！

显然 $n=0$ 时显然成立。

$$\begin{aligned}
 x^{n+1}&=\sum_i \left\langle\begin{matrix}n\\i\end{matrix}\right\rangle x\binom{x+i}n\\
&=\sum_i \left\langle\begin{matrix}n\\i\end{matrix}\right\rangle ((i+1)\binom{x+i}{n+1}+(n-i)\binom{x+k+1}{n+1})\\
\end{aligned}$$

我们还是写上上下界比较好，同时拆开：

$$x^{n+1}=\sum_{i=0}^{n}\left\langle\begin{matrix}n\\i\end{matrix}\right\rangle (i+1)\binom{x+i}{n+1}+\sum_{i=0}^n\left\langle\begin{matrix}n\\i\end{matrix}\right\rangle(n-i)\binom{x+i+1}{n+1}$$

好像不行了，我们要有双向搜索的思想看看我们的目标：

$$\begin{aligned}\sum^{n+1}_{i=0}\left\langle\begin{matrix}n+1\\i\end{matrix}\right\rangle\binom{x+i}{n+1}&=\sum^{n+1}_{i=0}((i+1)\left\langle\begin{matrix}n\\i\end{matrix}\right\rangle+(n-i-1)\left\langle\begin{matrix}n\\i-1\end{matrix}\right\rangle)\binom{x+i}{n+1}\\
&=\sum^{n+1}_{i=0}(i+1)\left\langle\begin{matrix}n\\i\end{matrix}\right\rangle\binom{x+i}{n+1}+\sum^{n+1}_{i=0}(n-i-1)\left\langle\begin{matrix}n\\i-1\end{matrix}\right\rangle\binom{x+i}{n+1}\\
&=\sum^{n+1}_{i=0}(i+1)\left\langle\begin{matrix}n\\i\end{matrix}\right\rangle\binom{x+i}{n+1}+\sum^{n}_{i=-1}(n-i)\left\langle\begin{matrix}n\\i\end{matrix}\right\rangle\binom{x+i+1}{n+1}\\
&=\sum^{n}_{i=0}(i+1)\left\langle\begin{matrix}n\\i\end{matrix}\right\rangle\binom{x+i}{n+1}+\sum^{n}_{i=0}(n-i)\left\langle\begin{matrix}n\\i\end{matrix}\right\rangle\binom{x+i+1}{n+1}
\end{aligned}$$

就证完了。

## 继续推式子

学过有限微积分的都知道，有：

$$\Delta(\binom{x+k}n)=\binom{x+k}{n-1}$$

多做几次差分得到：

$$\Delta^m(\binom{x+k}n)=\binom{x+k}{n-m}$$

我们得到了：

$$\sum_i\left\langle\begin{matrix}n\\i\end{matrix}\right\rangle\binom{x+i}{n-m}=\Delta^m(x^n)=\sum_{i=0}^n\binom{m}i(x+i)^n(-1)^{m-i}$$

我们又知道：

$$m!\begin{Bmatrix}n\\m\end{Bmatrix}=\sum_i\binom mii^n(-1)^{n-i}$$

设 $x=0$ 有：

$$\sum_i\left\langle\begin{matrix}n\\i\end{matrix}\right\rangle\binom{i}{n-m}=m!\begin{Bmatrix}n\\m\end{Bmatrix}$$

接下来非常关键，也是我百思不得其解，思考了很久的一步：

对 $m$ 求和得到：

$$\sum_m\sum_i\left\langle\begin{matrix}n\\i\end{matrix}\right\rangle\binom{i}{n-m}=\sum_mm!\begin{Bmatrix}n\\m\end{Bmatrix}$$

乘上 $y^{n-m}$ 得到：

$$\sum_i\left\langle\begin{matrix}n\\i\end{matrix}\right\rangle\sum_my^{n-m}\binom{i}{n-m}=\sum_my^{n-m}m!\begin{Bmatrix}n\\m\end{Bmatrix}$$

套二项式定理：

$$\sum_i\left\langle\begin{matrix}n\\i\end{matrix}\right\rangle(1+y)^i=\sum_my^{n-m}m!\begin{Bmatrix}n\\m\end{Bmatrix}$$

代换 $x=y+1$：

$$\sum_i\left\langle\begin{matrix}n\\i\end{matrix}\right\rangle x^i=\sum_mm!\begin{Bmatrix}n\\m\end{Bmatrix}(x-1)^{n-m}$$

考虑将他看成关于 $x$ 的多项式，对于右边我们对于每个 $m$ 算出 $x^i$ 的系数加一起即可，显然套二项式定理得到：

$$\sum_i\left\langle\begin{matrix}n\\i\end{matrix}\right\rangle x^i=\sum_i\sum_mm!\begin{Bmatrix}n\\m\end{Bmatrix}\binom{n-m}{i}(-1)^{n-m-i}x^i$$

提取出系数得到：

$$\left\langle\begin{matrix}n\\k\end{matrix}\right\rangle=\sum_ii!\begin{Bmatrix}n\\i\end{Bmatrix}\binom{n-i}{k}(-1)^{n-i-k} $$

哇！！！好简洁的形式啊！！

拆开变成一个卷积形式：

$$\left\langle\begin{matrix}n\\k\end{matrix}\right\rangle=\sum_ii!\begin{Bmatrix}n\\i\end{Bmatrix}\frac{(n-i)!}{k!(n-i-k)!}(-1)^{n-i-k} $$

写好看点：

$$k!\left\langle\begin{matrix}n\\k\end{matrix}\right\rangle=\sum_i(i!\begin{Bmatrix}n\\i\end{Bmatrix}(n-i)!)\frac{(-1)^{n-(i+k)}}{(n-(i+k))!} $$

令 $f_i=i!\left\langle\begin{matrix}n\\i\end{matrix}\right\rangle,g_i=i!(n-i)!\begin{Bmatrix}n\\i\end{Bmatrix},h_i=\frac{(-1)^i}{(n-i)!}$

那么有：

$$f_k=\sum_ig_kh_{i+k}$$

令 $h'_i=h_{n-i}$，即翻转一遍：

$$\sum_ig_kh'_{k-i}=\sum_ig_kh_{{n-k+i}}=f_{n-k}$$

思路很明显了，求出 $g_i,h_i$，将 $h$ 翻转后与 $g$ 做卷积，然后再翻转一遍就是答案，对于那个第二类斯特林数，我们套[第二类斯特林数·行](https://www.luogu.com.cn/problem/P5395)就行了。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const ll mod=998244353,g=3,ing=(mod+1)/3;
ll fpow(ll a,ll b){
	ll ans=1;
	while(b){
		if(b&1)ans=ans*a%mod;
		a=a*a%mod;
		b>>=1;
	}
	return ans;
}
int n;
int lim=1,k=0;
ll a[800005],b[800005],fac[800005],rev[800005];
ll g1[800005],h[800005];
void ntt(ll *a,int n,int f){
	for(int i=0;i<n;i++)if(i<rev[i])swap(a[i],a[rev[i]]);
	for(int h=1;h<n;h<<=1){
		long long wn=fpow((f==1)? g:ing,(mod-1)/(h<<1));
		for(int i=0;i<n;i+=(h<<1)){
			long long w=1;
			for(int j=0;j<h;j++,w=(wn*w)%mod){
				long long x=a[i+j],y=w*a[i+j+h]%mod;
				a[i+j]=(x+y)%mod;
				a[i+j+h]=(x-y+mod)%mod;
			}
		}
	}
	if(f==-1){
		long long inv=fpow(n,mod-2);
		for(int i=0;i<n;i++)a[i]=a[i]*inv%mod;
	}
}
int main(){
	cin>>n;
	while(lim<=(n<<1)){
		lim<<=1;
		k++;
	}
	fac[0]=1;
	for(int i=1;i<=n;i++)fac[i]=fac[i-1]*i%mod;
	for(int i=0;i<=n;i++){
		a[i]=fpow(i,n)*fpow(fac[i],mod-2)%mod;
		b[i]=fpow(fac[i],mod-2);
		if(i&1)b[i]=mod-b[i];
	}
	for(int i=1;i<lim;i++)rev[i]=(rev[i>>1]>>1)|((i&1)<<(k-1));
	ntt(a,lim,1);
	ntt(b,lim,1);
	for(int i=0;i<lim;i++)a[i]=a[i]*b[i]%mod;
	ntt(a,lim,-1);
	for(int i=0;i<=n;i++)g1[i]=a[i]*fac[i]%mod*fac[n-i]%mod;
	for(int i=0;i<=n;i++){
		h[i]=fpow(fac[n-i],mod-2);
		if((n-i)&1)h[i]=mod-h[i];
	}
	for(int i=0;i<=(n>>1);i++)swap(h[i],h[n-i]);
	ntt(g1,lim,1);
	ntt(h,lim,1);
	for(int i=0;i<lim;i++)g1[i]=g1[i]*h[i]%mod;
	ntt(g1,lim,-1);
	for(int i=0;i<=(n>>1);i++)swap(g1[i],g1[n-i]);
	for(int i=0;i<=n;i++){
		cout<<fpow(fac[i],mod-2)*g1[i]%mod<<" ";
	}
}
```

---

## 作者：Anoshag_Ruwan (赞：1)

欧拉数模板题。~~尽管看这题时不知道什么是欧拉数~~

设答案为 $f(n,k)$。一个有 $x$ 个升高的排列可以拆成 $x+1$ 个单调递减连续段，于是想到将 $1$~$n$ 的自然数划分为 $k$ 个非空集合，每个集合内部降序排序再以任意顺序拼接，方案数为 $\begin{Bmatrix}n\\k\end{Bmatrix}k!$，当然，这样产生的排列升高一定是拼接处，但并不是每个拼接处都会产生升高，枚举升高个数和非升高拼接处位置，则有 $\begin{Bmatrix}n\\k\end{Bmatrix}k!=\sum\limits_{i<k}f(n,i)\tbinom{n-1-i}{k-1-i}$。

由于答案显然是对称的，将 $i$ 替换为 $n-1-i$ 则有$\begin{Bmatrix}n\\k\end{Bmatrix}k!=\sum\limits_{i \geq 0}f(n,i)\tbinom{i}{n-k}$。

这个形式就可以考虑二项式反演了，令 $g(k)=\begin{Bmatrix}n\\n-k\end{Bmatrix}(n-k)!$，则 $g(k)=\sum\limits_{i \geq k}f(n,i)\tbinom{i}{k}$，反演得 $f(n,k)=\sum\limits_{i \geq k}(-1)^{i-k}g(i)\tbinom{i}{k}$，先卷积处理第二类斯特林数，然后使用减法卷积（将其中一个数列翻转再卷积）即可。

想证明欧拉数经典表达式 $n^m=\sum\limits_{i \geq 0}f(m,i)\tbinom{n+i}{m}$ 也不难，将开始的式子直接代入$\sum\limits_{i \geq 0}\binom{n}{i}\begin{Bmatrix}n\\i\end{Bmatrix}i!$ 则有 $n^m=\sum\limits_{i \geq 0}\binom{n}{i}\sum\limits_{j<i}f(m,j)\tbinom{m-1-j}{i-1-j}$。

$n^m=\sum\limits_{i \geq 0}f(m,i)\sum\limits_{j>i}\tbinom{n}{j}\tbinom{m-1-i}{m-j}$，后面是范德蒙德卷积的形式。

关键是切入的组合意义，推式子难度挺简单的。

```cpp
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<cstring>
using namespace std;
long long frc[200011],k1,inv[200011],p=998244353,q[600011],r[600011],a[600011],b[600011];
inline long long add(long long x,long long y){return x+y>=p?x+y-p:x+y;}
inline long long ksm(long long x,long long y){
	long long k=1,l=x;
	while(y){if(y&1)k=k*l%p;l=l*l%p,y>>=1;}
	return k;
}
inline void bter(){
	for(int i=0;i<k1;i++)r[i]=(r[i>>1]>>1)|(i&1?k1>>1:0);}
inline void bz(long long *f){
	for(int i=0,k=ksm(k1,p-2);i<k1;i++)
		f[i]=f[i]*k%p;
}
inline void ntt(long long *f,bool m){
	long long i,j,k,l,h;
	for(i=0;i<k1;i++)
		if(i<r[i])swap(f[i],f[r[i]]);
	for(i=1;i<k1;i<<=1){
		l=ksm(m?3:332748118,(p-1)/(i<<1));
		for(j=q[0]=1;j<i;j++)q[j]=q[j-1]*l%p;
		for(j=0;j<k1;j+=i<<1)
			for(h=j;h<j+i;h++)
				k=q[h-j]*f[h+i]%p,f[h+i]=add(f[h],p-k),f[h]=add(f[h],k);}
}
int main()
{
	long long i,j,k,m,n;scanf("%lld",&n);
	for(i=frc[0]=1;i<=n;i++)
		frc[i]=frc[i-1]*i%p;
	for(i=n,inv[i]=ksm(frc[i],p-2);i;i--)
		inv[i-1]=inv[i]*i%p;
	for(k1=1;k1<=n<<1;k1<<=1);
	for(i=0;i<=n;i++)
		a[i]=i&1?p-inv[i]:inv[i],b[i]=ksm(i,n)*inv[i]%p;
	bter();ntt(a,1);ntt(b,1);
	for(i=0;i<k1;i++)
		a[i]=a[i]*b[i]%p;
	ntt(a,0);bz(a);//第二类斯特林数 
	for(i=0;i<k1;i++)
		b[i]=i<=n?a[n-i]*frc[i]%p*frc[n-i]%p:0;
	memset(a,0,sizeof(a));
	for(i=0;i<=n;i++)
		a[n-i]=i&1?p-inv[i]:inv[i];
	ntt(a,1);ntt(b,1);
	for(i=0;i<k1;i++)
		a[i]=a[i]*b[i]%p;
	ntt(a,0);bz(a);
	for(i=n;i<=n<<1;i++)
		printf("%lld ",a[i]*inv[i-n]%p);
	printf("\n");
	return 0;
}
```


---


# [Code+#2] 白金元首与独舞

## 题目背景

```cpp
到河北省 见斯大林 / 在月光下 你的背影 / 让我们一起跳舞吧
```
うそだよ~ 河北省怎么可能有 Stalin。


可是…… 可是如果 Stalin 把自己当作炸弹扔到地堡花园里来了呢？


怀揣着这份小小的希望，元首 Adolf 独自走进了花园。终有一天会重逢的吧，Stalin。或许是在此处，或许是在遥远的彼方。


无论如何，在此之前，好好装点一番花园，编排一段优美的舞步吧！


## 题目描述

元首把花园分为 $n$ 行 $m$ 列的网格。每个格子中都可以放置一个标识，指向上、下、左、右四个方向中的任意一个。元首位于一个格子时，会按照其中标识所指的方向进入周围的格子，或者走出花园（即目的格子不在网格之内）。举个例子 —— 对于下面的放置方式，元首从第 $3$ 行第 $2$ 列的格子开始，会沿着以红色标出的路径走出花园；从第 $2$ 行第 22 列的格子开始，则会在以蓝色标出的环路内不断地行走。

 ![](https://cdn.luogu.com.cn/upload/pic/12659.png) 

元首已经设计好了大部分格子的标识。元首用字符 L、R、U、D 分别表示指向左、右、上、下四个方向的标识，用字符 . 表示未决定的格子。现在，元首希望将每个 . 替换为 L、R、U、D 中任意一种，使得从花园中的任意一个格子出发，按照上述规则行走，都可以最终走出花园。


你需要编写程序帮助元首计算替换的不同方案数。两个方案不同当且仅当存在一个格子，使得两个方案中该格子内的标识不同。当然，由于答案可能很大，只需给出方案数除以 $10^9 + 7$所得的余数即可。


## 说明/提示

**样例解释**

第 $1$ 组数据中，将惟一的 . 替换成 R、U 或 D 均满足要求。


第 $2$ 组数据中，将左上方和右下方的两个 . 分别替换成 LR、LU、LD、UR、UU、UD、DR 或 DD 均满足要求。


第 $3$ 组数据中，没有待决定的格子，原本的安排会使得元首陷入无尽的环路，故答案为 $0$。该组数据与**题目描述**中的例子相同。


第 $4$ 组数据中，也没有待决定的格子，但原本的安排已经满足要求，故答案为 $1$。


令 $k$ 表示标记未确定（即包含 “.”）的格子总数。


对于所有数据，有 $1 \leq T \leq 10$，$1 \leq n, m \leq 200$，$0 \leq k \leq \min(nm, 300)$。

 ![](https://cdn.luogu.com.cn/upload/pic/12660.png) 

“... wie Stalin!”


题面与史实无关。


来自 CodePlus 2017 12 月赛，清华大学计算机科学与技术系学生算法与竞赛协会 荣誉出品。

Credit：idea/吕时清 命题/吕时清 验题/王聿中，杨景钦

Git Repo：https://git.thusaac.org/publish/CodePlus201712

感谢腾讯公司对此次比赛的支持。


## 样例 #1

### 输入

```
5
3 9
LLRRUDUUU
LLR.UDUUU
LLRRUDUUU
4 4
LLRR
L.LL
RR.R
LLRR
4 3
LRD
LUL
DLU
RDL
1 2
LR
2 2
..
..```

### 输出

```
3
8
0
1
192```

# 题解

## 作者：shadowice1984 (赞：10)

一道神奇的Matrix-Tree定理题……
________________

## 前置芝士:矩阵树定理

蛤？做cp题不会矩阵树定理?如果不会的话请自行度娘

### 本题题解

先来简述一下题意，给你一张网格图，每个格子上有一个箭头，还有一些格子是不定向的，现在希望给这些格子定向，使得这张网格图当中不存在环，求合法的定向方案数

我们考虑将这张网格图转化成一个真正的图……

那么建图方法依然很简单，原来网格图上的点还是原来的点，然后如果这个点上写着L的话就把这个点和它左边的点连有向边，写着R的话就把这个点和它右边的点连有向边,写着U的话就把这个点和它上边的点连有向边，写着D的话就把这个点和它下边的点连有向边

然后新建一个虚点表示"外面的区域",也就是如果在刚才的建图方式当中上/下/左右边的点不存在的话我们就将这个点和这个表示外面的点连有向边

那么我们发现如此这般转化后的新图满足两个性质

1.如果这张图合法的话图中是没有环的

2.如果这张图合法的话，图中的每一个点都存在一条到达表示外部的虚点的有向路径

~~(其实上边两句都是废话)~~

然后我们发现这个图有一个更加重要的性质是这个图只有$nm$条边却有$nm+1$个点，另外所有的点(除了虚点例外)的出度都为1

这些性质指向了一个共同的结论，就是一张合法的图转化之后必然是一张有向的树形图，并且以我们新建的虚点为根

那么此时的问题开始渐渐变得明朗起来了，我们现在的目标就是对树形图计数，这个问题是有明确的$O(n^3)$算法的，也就是通过矩阵树定理来求解

但是似乎对于这道题，如果我们将每一个方向未知的点向四周连4条有向边，然后其余点正常连边，最后跑一趟矩阵树定理进行树形图计数的话，我们会得到一个优秀的$O(n^3m^3)$的暴力

这样的复杂度实在是不优秀，所以我们需要想一些更加机智的算法

突然发现方向未定的点最多只有300个那么我们可以考虑是不是可以把这张图缩一缩点，只保留关于未知点的信息呢？

我们发现一个性质就是，我们一旦走到了某一个点i，j之后接下来的走法完全是完全一样的，而和我怎么走到这个i，j无关

因此这张图上的一条路径是否存在仅仅和这条路径上的不定向点的决策是否正确有关

此时我们可以暴力模拟/dfs找出一个不定向点在定向为/上/下/左/右之后第一个到达的未定向点(或者是那个表示外界的虚点)，然后将这个点和这个点一个到达的点连一条边(这样的话总计一个点会连4条边)

那么我们对这样建出的图跑矩阵树定理得出的生成树方案树和原图中的生成树方案树将会是相等的，因为我们这么做相当于把原图中已经是树的部分去掉了而直接在不确定的点之间连边

此时我们的复杂度是$O(T((n+m)nm+k^3))$已经可以通过本题了

不过如果你常数大一点的话可能就T飞了……

想要优化复杂度的话可以把刚才的爆搜改成记忆化爆搜，此时的复杂度就变成了$O(T(nm+k^3))$就可以轻松的通过本题辣~

tips:给有向图做树形图统计的话，对于这道题的话我们的基尔霍夫矩阵应该是入度矩阵-临接矩阵，而求行列式时删掉的一行一列也不再是随便删而是删去树形图的根(本题中就是我们建的那个虚点)

tips:记得在这张图中有环的时候输出0

上代码~

```C
#include<cstdio>
#include<algorithm>
using namespace std;const int N=310;typedef long long ll;const ll mod=1e9+7;
inline ll po(ll a,ll p){ll r=1;for(;p;p>>=1,a=a*a%mod)if(p&1)r=r*a%mod;return r;}
int n;int m;int tr[N][N];int ctt;ll kr[N][N];char mde[N][N];int id[N][N];int T;
int dx[4]={0,0,-1,1};int dy[4]={-1,1,0,0};
inline ll det()//高斯削元求行列式 
{
	ll res=1;int t=0;for(int i=1;i<ctt;i++)for(int j=1;j<ctt;j++)(kr[i][j]+=mod)%=mod;
	for(int i=1;i<ctt;i++)
	{
		if(kr[i][i]==0)for(int j=i+1;j<ctt;j++)
			if(kr[j][i]!=0){for(int k=i;k<ctt;k++)swap(kr[j][k],kr[i][k]);t^=1;break;}
		if(kr[i][i]==0)return 0;(res*=kr[i][i])%=mod;ll inv=po(kr[i][i],mod-2);
		for(int j=i;j<ctt;j++)(kr[i][j]*=inv)%=mod;
		for(int j=1;j<ctt;j++)
			if(i!=j)for(int k=ctt-1;k>=i;k--)(kr[j][k]+=mod-kr[i][k]*kr[j][i]%mod)%=mod;
	}return t?(mod-res)%mod:res;
}
inline void add(int u,int V){kr[u][u]++;kr[u][V]--;}
inline int dfs(int px,int py)//记忆化搜索出从每个点出发后到达的第一个未定向点/虚点 
{
	if(px<1||px>n||py<1||py>m)return ctt;if(tr[px][py]!=0)return tr[px][py];
	switch(mde[px][py])
	{
		case 'L':{tr[px][py]=dfs(px+dx[0],py+dy[0]);break;}
		case 'R':{tr[px][py]=dfs(px+dx[1],py+dy[1]);break;}
		case 'U':{tr[px][py]=dfs(px+dx[2],py+dy[2]);break;}
		case 'D':{tr[px][py]=dfs(px+dx[3],py+dy[3]);break;}
	}return tr[px][py];
}
inline bool dfs(int px,int py,int col)//dfs判环 
{
	if(px<1||px>n||py<1||py>m)return true;
	if(id[px][py]==col)return false;if(id[px][py]!=0)return true;id[px][py]=col;
	switch(mde[px][py])
	{
		case 'L':{return dfs(px+dx[0],py+dy[0],col);break;}
		case 'R':{return dfs(px+dx[1],py+dy[1],col);break;}
		case 'U':{return dfs(px+dx[2],py+dy[2],col);break;}
		case 'D':{return dfs(px+dx[3],py+dy[3],col);break;}
	}return true;
}
inline void solve()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)scanf("%s",mde[i]+1);
	for(int i=1;i<=n;i++)for(int j=1;j<=m;j++)if(mde[i][j]=='.')tr[i][j]=++ctt;++ctt;
	for(int i=1,c=0;i<=n;i++)
		for(int j=1;j<=m;j++)if(id[i][j]==0&&dfs(i,j,++c)==false){printf("0\n");return;}
	for(int i=1;i<=n;i++)//建图 
		for(int j=1;j<=m;j++)if(mde[i][j]=='.')for(int k=0;k<4;k++)add(tr[i][j],dfs(i+dx[k],j+dy[k]));
	printf("%lld\n",det());//跑矩阵树定理 
}
inline void clear()
{
	for(int i=1;i<=ctt;i++)for(int j=1;j<=ctt;j++)kr[i][j]=0;ctt=0;
	for(int i=1;i<=n;i++)for(int j=1;j<=m;j++)id[i][j]=0;
	for(int i=1;i<=n;i++)for(int j=1;j<=m;j++)tr[i][j]=0;
}
int main(){scanf("%d",&T);for(int z=1;z<=T;z++)solve(),clear();return 0;}//拜拜程序~ 


```





---

## 作者：Rainybunny (赞：3)

&emsp;&emsp;[推销博客 owo](https://www.cnblogs.com/rainybunny/p/13224064.html)。
# $\mathcal{Description}$
&emsp;&emsp;[link](https://www.luogu.com.cn/problem/P4033).  
&emsp;&emsp;给定一个 $n\times m$ 的网格图，一些格子指定了走出该格的方向（上下左右），而有 $k$ 格可以任意指定走出方向。求指定的方案数，使得从任意格子都可以走出网格图。  
&emsp;&emsp;$n,m\le200;k\le300$。
# $\mathcal{Solution}$
&emsp;&emsp;令“走出边界”为走到一个特殊点，建图，其中未指定方向的点向四周连边，相当于求以特殊点为根的**内向树**个数，跑矩阵树定理即可。复杂度 $\mathcal O(n^3m^3)$。  
&emsp;&emsp;考虑优化，生成树个数实质上只与不定向的点有关，所以直接预处理出每个不定向点向上/下/左/右走到的第一个不定向点，向其连边，再跑矩阵树。复杂度 $\mathcal O(k^3)$。
## $\mathcal{Code}$
```cpp
#include <cstdio>
#include <cstring>
#include <iostream>

const int MOD = 1e9 + 7, MAXN = 200, MAXP = 300;
int T, N, M, K[MAXP + 5][MAXP + 5], col[MAXN + 5][MAXN + 5], unk[MAXN + 5][MAXN + 5], cnt;
char gar[MAXN + 5][MAXN + 5];

inline int qkpow ( int a, int b, const int p = MOD ) {
	int ret = 1;
	for ( ; b; a = 1ll * a * a % p, b >>= 1 ) ret = 1ll * ret * ( b & 1 ? a : 1 ) % p;
	return ret;
}

inline int det ( const int n ) {
	int ret = 1, swp = 1;
	for ( int i = 2; i <= n; ++ i ) {
		for ( int j = i; j <= n; ++ j ) {
			if ( K[j][i] ) {
				if ( i ^ j ) std::swap ( K[i], K[j] ), swp *= -1;
				break;
			}
		}
		if ( ! ( ret = 1ll * ret * K[i][i] % MOD ) ) return 0;
		for ( int j = i + 1, inv = qkpow ( K[i][i], MOD - 2 ); j <= n; ++ j ) {
			int d = 1ll * K[j][i] * inv % MOD;
			for ( int k = i; k <= n; ++ k ) K[j][k] = ( K[j][k] - 1ll * K[i][k] * d % MOD + MOD ) % MOD;
		}
	}
	return ( ret * swp + MOD ) % MOD;
}

inline bool findLoop ( const int x, const int y, const int cur ) {
	if ( x < 1 || x > N || y < 1 || y > M || gar[x][y] == '.' ) return false;
	if ( col[x][y] == cur ) return true;
	if ( col[x][y] ) return false;
	col[x][y] = cur;
	if ( gar[x][y] == 'L' ) return findLoop ( x, y - 1, cur );
	if ( gar[x][y] == 'R' ) return findLoop ( x, y + 1, cur );
	if ( gar[x][y] == 'U' ) return findLoop ( x - 1, y, cur );
	if ( gar[x][y] == 'D' ) return findLoop ( x + 1, y, cur );
	return false;
}

inline int findUnknown ( const int x, const int y ) {
	if ( x < 1 || x > N || y < 1 || y > M ) return 1;
	if ( unk[x][y] ) return unk[x][y];
	int& ret = unk[x][y];
	if ( gar[x][y] == 'L' ) ret = findUnknown ( x, y - 1 );
	if ( gar[x][y] == 'R' ) ret = findUnknown ( x, y + 1 );
	if ( gar[x][y] == 'U' ) ret = findUnknown ( x - 1, y );
	if ( gar[x][y] == 'D' ) ret = findUnknown ( x + 1, y );
	return ret;
}

inline void add ( const int s, int t ) {
	if ( ! t ) t = 1;
	++ K[s][s], -- K[s][t];
	if ( K[s][t] < 0 ) K[s][t] += MOD;
}

int main () {
	for ( scanf ( "%d", &T ); T --; ) {
		memset ( K, 0, sizeof K );
		memset ( col, 0, sizeof col );
		memset ( unk, 0, sizeof unk );
		scanf ( "%d %d", &N, &M ), cnt = 1;
		for ( int i = 1; i <= N; ++ i ) {
			scanf ( "%s", gar[i] + 1 );
			for ( int j = 1; j <= M; ++ j ) {
				if ( gar[i][j] == '.' ) {
					unk[i][j] = ++ cnt;
				}
			}
		}
		bool loop = false;
		for ( int i = 1, cur = 1; i <= N && ! loop; ++ i ) {
			for ( int j = 1; j <= M && ! loop; ++ j ) {
				loop |= findLoop ( i, j, cur ++ );
			}
		}
		if ( loop ) { puts ( "0" ); continue; }
		for ( int i = 1; i <= N; ++ i ) {
			for ( int j = 1; j <= M; ++ j ) {
				findUnknown ( i, j );
			}
		}
		for ( int i = 1; i <= N; ++ i ) {
			for ( int j = 1; j <= M; ++ j ) {
				if ( gar[i][j] == '.' ) {
					add ( unk[i][j], unk[i][j - 1] );
					add ( unk[i][j], unk[i][j + 1] );
					add ( unk[i][j], unk[i - 1][j] );
					add ( unk[i][j], unk[i + 1][j] );
				}
			}
		}
		printf ( "%d\n", det ( cnt ) );
	}
	return 0;
}
```

---


# [BJWC2010] 严格次小生成树

## 题目描述

小 C 最近学了很多最小生成树的算法，Prim 算法、Kruskal 算法、消圈算法等等。正当小 C 洋洋得意之时，小 P 又来泼小 C 冷水了。小 P 说，让小 C 求出一个无向图的次小生成树，而且这个次小生成树还得是严格次小的，也就是说：如果最小生成树选择的边集是 $E_M$，严格次小生成树选择的边集是 $E_S$，那么需要满足：($value(e)$ 表示边 $e$ 的权值) $\sum_{e \in E_M}value(e)<\sum_{e \in E_S}value(e)$。

这下小 C 蒙了，他找到了你，希望你帮他解决这个问题。


## 说明/提示

数据中无向图**不保证无自环**。

对于 $50\%$ 的数据， $N\le 2000$，$M\le 3000$。

对于 $80\%$ 的数据， $N\le 5\times 10^4$，$M\le 10^5$。

对于 $100\%$ 的数据， $N\le 10^5$，$M\le 3\times10^5$，边权  $\in [0,10^9]$，数据保证必定存在严格次小生成树。

## 样例 #1

### 输入

```
5 6
1 2 1 
1 3 2 
2 4 3 
3 5 4 
3 4 3 
4 5 6 ```

### 输出

```
11```

# 题解

## 作者：Nemlit (赞：79)

管理员备注：本文中第二份代码在 hack 数据中会 WA，请读者注意

[原文地址](https://www.cnblogs.com/bcoier/p/10293072.html)
### 生成树的概念：
在一个无向图中，设顶点数为$n$，取其中$n-1$条边并使所有点相连，所得到的一棵树即为生成树。
### 最小生成树：
如果还没有接触过生成树的同学，欢迎戳->[最小生成树详解](https://tbr-blog.blog.luogu.org/solution-p3366)

# 次小生成树：
次小生成树顾名思义，就是边权之和次小的一棵生成树。有严格次小生成树与非严格次小生成树之分。

~~尽管这个算法的名字叫做次小生成树，不过其实可以理解成一道数据结构~~

次小生成树可以和次短路径一起理解，有兴趣的同学可以做做模板题

非严格次小生成树的边权之和不一定要比最小生成树的小，即	$Σw$次≥$Σw$最

严格次小生成树的边权之和一定要比最小生成树的小，即$Σw$次>$Σw$最

想要求出次小生成树？

显然我们可以dfs求出所有的生成树，在排序选出严格次小的就可以了。

但是上述方法显然不能快速求出次小生成树

为了快速的求出来次小生成树，我们需要知道一个结论：次小生成树和最小生成树之间只有一条边的差异。

这一条结论为什么是正确的呢？

我们先来看看$Kruskal$是怎么求最小生成树的

$Kruskal$是按照边权排序，按照贪心的思路一条一条的加进树边，所以如果要求出次小生成树，那么我们可以放弃一条小的边不选，加入另一条边使图联通。

如果我们"放弃"了两条边，那么只"放弃"一条边的生成树的边权和显然小于"放弃"两条边的生成树的边权和。

所以求出（非）严格次小生成树的朴素算法为：先建立一棵最小生成树。再枚举删去最小生成树上的每一条路径，再在新构成的生成树中选出一棵边权之和最小生成树的即可。

时间复杂度为$O(nmlogm)$。当然这种算法还不够优秀，我们可以继续优化

非严格次小生成树我们可以这样优化：

枚举边的时候，枚举没有被并入到最小生成树的边（我们将把这条边加入到生成树中，显然现在的图形不再是一棵树，所以我们要原图中删去一条最大边，使新图仍然联通）

加入边权值为$W1$。查询树上每一条的路径，在路径选取一个边权最大值$W2$。则当前枚举的答案为$W−W2+W1$（W为最小生成树的边权之和）

枚举所有的边之后，取最小值即可。

我们可以用倍增/树剖/LCT来实现查询树上最大值的操作，故复杂度为：$O(mlogn)$

再来看看严格次小生成树

不难发现：求非严格最小生成树时，枚举一条边$W1$，之后再寻找一条生成树上的最大边$W2$

显然$W1≥W2$，因此可能由此得到的次小生成树并非严格。所以我们可以在每次查询时，需要找到严格次小的$W1$，即$W1>W2$，这样我们就可以得到严格次小生成树了。

维护仍可以用倍增或者树剖思想。

这里介绍树剖的思路：

先用线段树维护区间最小值与严格次小值，如果是叶子节点最大值就设为他本身，次大值设为0

合并的时候把两个区间的这四个值（两个最大值与两个次大值）排序，再寻找最大值与严格次小值即可。

### [严格次小生成树模板题](https://www.luogu.org/problemnew/show/P4180)
### 代码如下：
```
#include<bits/stdc++.h>
using namespace std;
#define re register
#define il inline
#define int long long //把所有int转成longlong
#define debug printf("Now is line %d\n",__LINE__);
il int read()
{
    re int x=0,f=1;char c=getchar();
    while(c<'0'||c>'9'){if(c=='-') f=-1;c=getchar();}
    while(c>='0'&&c<='9') x=(x<<3)+(x<<1)+(c^48),c=getchar();
    return x*f;
}//快读 
#define maxm 300005
#define inf 12345678900000000
#define maxn 100005
struct Edge{int u,v,w,next;}e[maxm<<1];
struct qj{int ma,ma2;}q[maxn<<2];
struct Edge1
{
    int u,v,w;
    bool operator <(const Edge1 &x) const{return w<x.w;}//按照边权排序 
}edge[maxm];
int n,m,vis[maxm],ans=inf,head[maxn],cnt,fa[maxn],mtree;
il void add(int u,int v,int w)
{
    e[++cnt].v=v;
    e[cnt].w=w;
    e[cnt].next=head[u];
    head[u]=cnt;
}//前向星加边
namespace smallesttree
{
    il int find(int x)
    {
        while(x!=fa[x]) x=fa[x]=fa[fa[x]];
        return x;
    }//并查集找祖先 
    il void init()
    {	
        for(re int i=1;i<=n;i++) fa[i]=i; //预处理并查集 
        for(re int i=0;i<m;i++) edge[i].u=read(),edge[i].v=read(),edge[i].w=read();
    }
    il void kruskal()
    {
        init();
        sort(edge,edge+m);
        re int T=0;
        for(re int i=0;i<m;++i)
        {
            re int eu=find(edge[i].u),ev=find(edge[i].v);//寻找祖先
            if(eu!=ev)
            {
            	add(edge[i].u,edge[i].v,edge[i].w),add(edge[i].v,edge[i].u,edge[i].w);
                mtree+=edge[i].w;//记录子树大小 
                fa[ev]=eu;//合并 
                vis[i]=1;//标记该边为树边 
                if(++T==n-1) break;//边数等于节点数+1即为一颗树 
            }
        }
    } 
}
//求出最小生成树
namespace treecut
{
    int dep[maxn],father[maxn],top[maxn],W[maxn],a[maxn],size[maxn],son[maxn],seg[maxn],col;
    //dep:深度 father:父亲节点 top:重链的顶端 W:到根节点的距离 a:点的权值 size:子树大小 son:重儿子 seg:在线段树中的序号（dfs序） 
    il void dfs1(int u,int fr)
    {
        dep[u]=dep[fr]+1;
        size[u]=1;
        father[u]=fr;
        for(re int i=head[u];i;i=e[i].next)
        {
            re int v=e[i].v;
            if(v!=fr)
            {
                W[v]=W[u]+e[i].w;//W为每一个点到根节点的距离 
                dfs1(v,u);
                size[u]+=size[v];
                if(size[v]>size[son[u]]) son[u]=v;
            }
        }
    }//预处理出dep、size、father以及son 
    il void dfs2(int now,int fi)
    {
        top[now]=fi;
        seg[now]=++col;
        a[col]=W[now]-W[father[now]];//a为点的权值（它与之父亲节点边的权值）（相当于前缀和） 
        if(!son[now]) return;
        dfs2(son[now],fi);
        for(re int i=head[now];i;i=e[i].next)
        {
            re int v=e[i].v;
            if(v!=son[now]&&v!=father[now]) dfs2(v,v);
        }
    }//预处理出每个节点的top、seg以及权值 
    //树剖模板就不解释了 
    #define ls k<<1
    #define rs k<<1|1
    il bool CMP(int a,int b){return a>b;}
    il int getse(int x,int g,int z,int c)
    {
        re int a[5]={x,g,z,c};
        sort(a,a+4,CMP);
        for(re int i=1;i<3;++i)
        {
            if(a[i]!=a[0]) return a[i];
        }
    }//找到两个区间的最大值和严格次大值（四个数）的最大值与严格次大值 
    // 就是合并两个区间的最大值和严格次大值
    il void build(int k,int l,int r)
    {
        if(l==r)
        {
            q[k].ma=a[l];
            return;
        }
        re int mid=(l+r)>>1;
        build(ls,l,mid),build(rs,mid+1,r);
        q[k].ma=max(q[ls].ma,q[rs].ma);
        q[k].ma2=getse(q[ls].ma,q[rs].ma,q[ls].ma2,q[rs].ma2);
    }//预处理出区间最大值与次大值 
    il qj query(int k,int l,int r,int ll,int rr)
    {
        if(ll>r||rr<l) return (qj){-inf,-inf};
        if(ll<=l&&rr>=r) return (qj){q[k].ma,q[k].ma2};
        re int mid=(l+r)>>1;
        re qj t1=query(ls,l,mid,ll,rr),t2=query(rs,mid+1,r,ll,rr);
        return (qj){max(t1.ma,t2.ma),getse(t1.ma,t2.ma,t1.ma2,t2.ma2)};
    }//查询区间的区间的最大值与次小值 
    il int LCA(int u,int v,int d)
    {
        re int need=-inf;
        while(top[u]!=top[v])
        {
            if(dep[top[u]]<dep[top[v]]) swap(u,v);
            qj temp=query(1,1,n,seg[top[u]],seg[u]);
            u=father[top[u]];
            need=max(need,(temp.ma==d)?temp.ma2:temp.ma);//严格次小边（如果temp.ma==k就是非严格次小） 
        }
        if(dep[u]<dep[v]) swap(u,v);//找到LCA 
        qj temp=query(1,1,n,seg[v]+1,seg[u]);
        return max(need,(temp.ma==d)?temp.ma2:temp.ma);//同上 
    }
    il void init()
    {
        dfs1(1,0),dfs2(1,1),build(1,1,n);
    }
}
//树链剖分 
signed main()
{
    n=read(),m=read();
    smallesttree::kruskal();//求出最小生成树
    treecut::init();//预处理
    for(re int i=0;i<m;++i)
    {
    	if(vis[i]) continue;//枚举所有非树边（没有在最小生成树的边）
    	re int temp=mtree/*最小生成树边权和*/+edge[i].w/*本来的树边的边权*/-treecut::LCA(edge[i].u,edge[i].v,edge[i].w)/*找到严格次小边的边权*/;
        if(ans>temp&&temp!=mtree+e[i].w/*其实就是严格此小边不为0（没有找到严格次小边）*/&&temp>mtree) ans=temp;
    }
    printf("%lld",ans);
    return 0;
}
```

## $updata$ $in$ $2019$-$04$-$02$

学习了LCT后，发现这道题貌似可以LCT做，而且代码短了很多？

先跑一边$Kruskal$，并在LCT上跑出最小生成树的样子

然后对于每一条非树边，加入后会产生一个环，我们删去环内最大值（若最大值和改变相同则插入次大值）即可

```
#include<bits/stdc++.h>
using namespace std;
#define il inline
#define re register
#define debug printf("Now is Line : %d\n",__LINE__)
#define file(a) freopen(#a".in","r",stdin);//freopen(#a".out","w",stdout)
#define inf 1234567890000000000
#define ll long long
il int read() {
    re int x = 0, f = 1; re char c = getchar();
    while(c < '0' || c > '9') { if(c == '-') f = -1; c = getchar();}
    while(c >= '0' && c <= '9') x = x * 10 + c - 48, c = getchar();
    return x * f;
}
#define rep(i, s, t) for(re int i = s; i <= t; ++ i)
#define get_fa(x) ch[1][fa[x]] == x
#define isroot(x) ch[1][fa[x]] == x || ch[0][fa[x]] == x
#define updown(x) tag[x] ^= 1, swap(ch[0][x], ch[1][x])
#define maxn 600005
struct edge {
    int u, v, w;
}e[maxn];
int n, m, is[maxn],ch[2][maxn], fa[maxn], tag[maxn], st[maxn], Fa[maxn];
int mx1[maxn], mx2[maxn], val[maxn];
ll ans, Ans = inf;
il int find(int x) {
    while(Fa[x] != x) x = Fa[x] = Fa[Fa[x]];
    return x;
}
il bool cmp(edge a, edge b) {return a.w < b.w;}
il void pushdown(int x) {
    if(!tag[x]) return;
    if(ch[0][x]) updown(ch[0][x]);
    if(ch[1][x]) updown(ch[1][x]);
    tag[x] = 0;
}
il void pushup(int x) {
    mx1[x] = val[x];
    if(mx1[x] < mx1[ch[0][x]]) mx2[x] = mx1[x], mx1[x] = mx1[ch[0][x]];
    else if(mx1[x] > mx1[ch[0][x]]) mx2[x] = max(mx2[x], mx1[ch[0][x]]);
    if(mx1[x] < mx1[ch[1][x]]) mx2[x] = mx1[x], mx1[x] = mx1[ch[1][x]];
    else if(mx1[x] > mx1[ch[1][x]]) mx2[x] = max(mx2[x], mx1[ch[1][x]]);
    mx2[x] = max(max(mx2[x], mx2[ch[1][x]]), mx2[ch[0][x]]);
}
il void rotate(int x) {
    int y = fa[x], z = fa[y], w = get_fa(x), k = get_fa(y);
    if(isroot(y)) ch[k][z] = x; fa[x] = z;
    ch[w][y] = ch[w ^ 1][x], fa[ch[w ^ 1][x]] = y;
    ch[w ^ 1][x] = y, fa[y] = x;
    pushup(y), pushup(x);
}
il void Splay(int x) {
    int top = 0, y = x;
    st[++ top] = y;
    while(isroot(y)) st[++ top] = y = fa[y];
    while(top) pushdown(st[top --]);
    while(isroot(x)) {
        if(isroot(fa[x])) rotate(get_fa(x) == get_fa(fa[x]) ? fa[x] : x);
        rotate(x);
    }
}
il void access(int x) {for(re int y = 0; x; x = fa[y = x]) Splay(x), ch[1][x] = y, pushup(x);}
il void makeroot(int x) {access(x), Splay(x), updown(x);}
il int findroot(int x) {
    access(x), Splay(x);
    while(ch[0][x]) x = ch[0][x];
    return Splay(x), x;
}
il void spilt(int x, int y) {makeroot(x), access(y), Splay(y);}
il void link(int x, int y) {
    makeroot(x);
    if(findroot(y) != x) fa[x] = y;
}
int main() {
    n = read(), m = read();
    rep(i, 1, m) e[i].u = read(), e[i].v = read(), e[i].w = read();
    rep(i, 1, n) Fa[i] = i;
    sort(e + 1, e + 1 + m, cmp);
    rep(i, 1, m) {
        val[i + n] = e[i].w;
        int u = e[i].u, v = e[i].v, a = find(u), b = find(v);
        if(a != b) ans += e[i].w, link(u, i + n), link(i + n, v), is[i] = 1, Fa[a] = b;
    }
    rep(i, 1, m) {
        if(is[i]) continue;
        int u = e[i].u, v = e[i].v;
        spilt(u, v);
        if(e[i].w > mx1[v]) Ans = min(Ans, (ll)e[i].w - mx1[v]);
        else Ans = min(Ans, (ll)e[i].w - mx2[v]);
    }
    printf("%lld", Ans + ans);
    return 0;
}
```

---

## 作者：lx_zjk (赞：77)

这道题目 是$kruskal$和$LCA$ 算法的合集 题目 不难

但是重在细节

首先 如果是次小生成树 有个性质就是他与最小生成树只有一条边不同 那么就枚举加入哪条边 然后 删去原路径上的一条边 然后删去权值最大（实际上应该是最大的次大的）

一开始 看到这道题 感觉和货车运输比较类似 然后就开始做 每次倍增维护路径上最大值 但是发现样例过不了 交上去有$60pts$

然后开始手搞样例 发现样例他删去的边是路径上的次大边 因为假设加上这条最大边 最小生成树权值和还是原来的和 那么我们考虑维护树上次大和最大值

讲一下维护次大值的思路 就是$max (min(g[u][i - 1], g[f[u][i - 1]][i - 1]), h[u][i - 1], h[f[u][i - 1]][i - 1]))$

然后就是模板了 不过这个模板并没有什么用

```cpp
#include <cstdio>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <iostream>
#include <set>
#include <map>
#include <queue>

using namespace std;

typedef long long ll;

const ll INF = (1ll << 62);

#define DEBUG(x) std::cerr << #x << " = " << x << std::endl

#define int ll

inline ll read() {
    ll f = 1, x = 0;char ch;
    do {ch = getchar();if (ch == '-')f = -1;} while (ch > '9' || ch < '0');
    do {x = x * 10 + ch - '0';ch = getchar();} while (ch >= '0' && ch <= '9');
    return f * x;
}

const int MAX_N = 100000 + 50;
const int MAX_M = 300000 + 50;
const int MAX_F = 30 + 5;

struct EDGE {
	int to, next, w;
} edge[MAX_M << 1];

int head[MAX_N], cnt;

void addedge (int u, int v, int w) {
	edge[++cnt].to = v;
	edge[cnt].w = w;
	edge[cnt].next = head[u];
	head[u] = cnt;
}

int f[MAX_N][MAX_F], g[MAX_N][MAX_F], h[MAX_N][MAX_F], dep[MAX_N];

inline void ckmax (int &x, int y) {
	x = (x > y ? x : y);
}

inline void dfs (int u, int fa, int w) {
	dep[u] = dep[fa] + 1;
	f[u][0] = fa;
	g[u][0] = w;
	h[u][0] = -INF;
	for (int i = 1; i <= 20; i ++ ) {
		f[u][i] = f[f[u][i - 1]][i - 1];
		g[u][i] = max (g[u][i - 1], g[f[u][i - 1]][i - 1]);
		h[u][i] = max (h[u][i - 1], h[f[u][i - 1]][i - 1]);
		if (g[u][i - 1] > g[f[u][i - 1]][i - 1]) h[u][i] = max (h[u][i], g[f[u][i - 1]][i - 1]);
		else if (g[u][i - 1] < g[f[u][i - 1]][i - 1]) h[u][i] = max (h[u][i], g[u][i - 1]);
	}
	for (int i = head[u]; i; i = edge[i].next ) {
		int v = edge[i].to, w = edge[i].w;
		if (v == fa) continue;
		dfs (v, u, w);
	}
}

inline int LCA (int x, int y) {
	if (dep[x] < dep[y]) swap (x, y);
	for (int i = 20; i >= 0; i -- ) {
		if (dep[f[x][i]] >= dep[y]) x = f[x][i];
	}
	if (x == y) return x;
	for (int i = 20; i >= 0; i -- ) {
		if (f[x][i] != f[y][i]) {
			x = f[x][i];
			y = f[y][i];
		}
	}
	return f[x][0];
}

int n, m, fa[MAX_N], res, sum;

struct Node {
	int u, v, w;
	bool operator < (const Node & rhs ) const  {
		return w < rhs.w;
	}
} a[MAX_M << 1];

inline int find (int x) {
	return x == fa[x] ? x : fa[x] = find (fa[x]);
}

inline void merge (int x, int y) {
	x = find (x); y = find (y);
	if (x == y) return;
	fa[x] = y;
}

bool vis[MAX_M];

inline void kruskal () {
	n = read (); m = read ();
	for (int i = 1; i <= m; i ++ ) {
		a[i].u = read (); a[i].v = read (); a[i].w = read ();
	}
	sort (a + 1, a + m + 1);
	for (int i = 1; i <= n; i ++ ) fa[i] = i;
	res = 0;
	for (int i = 1; i <= m; i ++ ) {
		if (find (a[i].u) != find (a[i].v)) {
			vis[i] = 1;
			res ++ ;
			merge (a[i].u, a[i].v);
			sum += a[i].w;
			addedge (a[i].u, a[i].v, a[i].w);
			addedge (a[i].v, a[i].u, a[i].w);
		}
		if (res == n - 1) break;
	}
	res = 0;
	dfs (1, 0, 0);
}

inline int qmax (int u, int v, int maxx) {
	int ans = -INF;
	for (int i = 18; i >= 0; i -- ) {
		if (dep[f[u][i]] >= dep[v]) {
			if (maxx != g[u][i]) ans = max (ans, g[u][i]);
			else ans = max (ans, h[u][i]);
			u = f[u][i];
		}
	}
	return ans;
}

inline void ckmin (int &x, int y) {
	x = (x < y ? x : y);
}

inline void calc () {
	int ans = INF;
	for (int i = 1; i <= m; i ++ ) {
		if (vis[i]) continue;
		int lca = LCA (a[i].u, a[i].v);
		int max_u = qmax (a[i].u, lca, a[i].w);
		int max_v = qmax (a[i].v, lca, a[i].w);
		ckmin (ans, sum - max (max_u, max_v) + a[i].w);
	}
	printf ("%lld\n", ans);
}

signed main() {
	kruskal ();
	calc ();
	return 0;
}
```

---

## 作者：Fuko_Ibuki (赞：28)

事实证明,本题的数据仍然不够强.bzoj上面原本的数据也是这样的.  
一边不断咒骂自己实在太不要脸,一边还是写了题解.

首先我们还是来想想那个非严格次小生成树.  
枚举每一条非树边,把路径上的最大值减掉再加上该边的权值.求出一个最小值就是答案.   
我知道标算要维护次大边,这样确实不好写.  
然后我不禁想:严格次小生成树的总权值大于最小生成树,所以我在枚举刚才的答案时对**严格大于最小生成树的结果**取最小值,这样进行贪心.  
我不知道大家是否看懂了上面这句话.  
那么显然上面这个奇怪的算法肯定是错的,但是稍微想一下我发现非常不好hack.   
要想hack掉这个,你需要产生一组次大边产生次小生成树的数据.  
由于随机数据出现这样的情况的概率非常低(目前的情况是$1$个小时没有拍出一组hack成功的数据.),所以最后我还是抱着试试看的心情交了一遍.WA90.  
我看那个唯一的错误点运行的时间,$2ms$.  
那时候我开始窃喜.然后我开始特判边数非常小的数据,用暴力跑出所有生成树.  
然后非常普通的A了.  
额.不过我旁边的大佬用两个小时搞出了一组能够hack我的数据.  
代码就放在下面了,大家笑一下就好.

```cpp
#include<bits/stdc++.h>
namespace chtholly{
typedef long long ll;
#define re0 register int
#define rec register char
#define rel register ll
#define gc getchar
#define pc putchar
#define p32 pc(' ')
#define pl puts("")
/*By Citrus*/
inline int read(){
  int x=0,f=1;char c=gc();
  for (;!isdigit(c);c=gc()) f^=c=='-';
  for (;isdigit(c);c=gc()) x=(x<<3)+(x<<1)+(c^'0');
  return f?x:-x;
  }
template <typename mitsuha>
inline bool read(mitsuha &x){
  x=0;int f=1;char c=gc();
  for (;!isdigit(c)&&~c;c=gc()) f^=c=='-';
  if (!~c) return 0;
  for (;isdigit(c);c=gc()) x=(x<<3)+(x<<1)+(c^'0');
  return x=f?x:-x,1;
  }
template <typename mitsuha>
inline int write(mitsuha x){
  if (!x) return 0&pc(48);
  if (x<0) x=-x,pc('-');
  int bit[20],i,p=0;
  for (;x;x/=10) bit[++p]=x%10;
  for (i=p;i;--i) pc(bit[i]+48);
  return 0;
  }
inline char fuhao(){
  char c=gc();
  for (;isspace(c);c=gc());
  return c;
  }
}using namespace chtholly;
using namespace std;
const int yuzu=4e5;
const ll inf=1e16;
typedef int fuko[yuzu|10];
int n=read(),m=read(),cnt,ecnt;
fuko vis,head;
struct node{
int u,v,cost;
void rd(){u=read(),v=read(),cost=read();}
bool operator <(const node &b) const{
  return cost<b.cost;
  }
}b[yuzu|10];

struct dsu{
fuko fa;
void init(int n){for (int i=1;i<=n;++i) fa[i]=i;}
int find(int x){return fa[x]^x?fa[x]=find(fa[x]):x;}
int mg(int u,int v){
  int fu=find(u),fv=find(v);
  return fu^fv?fa[fu]=fv,1:0;
  }
}my_;

struct edge{int fr,to,cost,next;}e[yuzu<<1|13];
void add(int u,int v,int c){e[++ecnt]=edge{u,v,c,head[u]},head[u]=ecnt;}

ll mst;
ll getmst(){
for (int i=1;i<=m;++i){
  int u=b[i].u,v=b[i].v,c=b[i].cost;
  if (my_.mg(u,v)){
    vis[i]=1,mst+=c;
    add(u,v,c),add(v,u,c);
    }
  }return mst;
}
 
/*求非严格最小生成树用的是树链剖分,可以求出树上两点间的最大值.
  树剖之类的全是模板,相信不用我多做解释.*/
namespace tree_chain_splitting{
fuko fa,son,sz,dep,ord,dfn,top,a;
 
void dfs1(int u,int f){
  sz[u]=1,dep[u]=dep[fa[u]=f]+1;
  for (int i=head[u];i;i=e[i].next){
    int v=e[i].to;
    if (v^f){
      dfs1(v,u),sz[u]+=sz[v];
      if (sz[v]>sz[son[u]]) son[u]=v;
      }
    }
  }
void dfs2(int u,int _top){
  top[u]=_top,dfn[ord[++cnt]=u]=cnt;
  if (son[u]) dfs2(son[u],_top);
  for (int i=head[u];i;i=e[i].next){
    int v=e[i].to;
    if (v^fa[u]&&(v^son[u])) dfs2(v,v);
    }
  }
 
typedef ll karen[yuzu<<2|13];
struct segtree{
#define le rt<<1
#define ri le|1
#define ls le,l,mid
#define rs ri,mid+1,r
karen da;
void build(int rt=1,int l=1,int r=n){
  if (l==r) da[rt]=a[l];
  else{
    int mid=l+r>>1;
    build(ls),build(rs);
    da[rt]=max(da[le],da[ri]);
    }
  } 
ll query(int ql,int qr,int rt=1,int l=1,int r=n){
  if (ql>r||qr<l) return -inf;
  if (ql<=l&&qr>=r) return da[rt];
  int mid=l+r>>1;
  return max(query(ql,qr,ls),query(ql,qr,rs));
  }
}llx;
 
void preedge(){
  for (int i=1;i<=m;++i) if (vis[i]){
    int u=b[i].u,v=b[i].v;
    if (dep[u]>dep[v]) swap(u,v);
    a[dfn[v]]=b[i].cost;
    }
  }
 
ll query(int u,int v){
  ll ans=-inf;
  for (;top[u]^top[v];u=fa[top[u]]){
    if (dep[top[u]]<dep[top[v]]) swap(u,v);
    ans=max(ans,llx.query(dfn[top[u]],dfn[u]));
    }
  if (dep[u]>dep[v]) swap(u,v);
  return max(ans,llx.query(dfn[u]+1,dfn[v]));
  }
 
int main(){
  int i;
  dfs1(1,0),dfs2(1,1);
  preedge(),llx.build();
  ll zxy=inf;
  for (i=1;i<=m;++i) if (!vis[i]){
    int u=b[i].u,v=b[i].v;
    ll tmp=mst-query(u,v)+b[i].cost;
    if (tmp>mst) zxy=min(zxy,tmp); 
    }write(zxy);
  }
}
 
namespace m_less_than_11{//暴力枚举组合数不用我解释吧.
ll llx=inf;
fuko a;
/*m:k k:n-1 n:m*/
void dfs(int k,int p){
if (k>=n){
  ll tmp=0;
  for (int i=1;i<n;++i) tmp+=b[a[i]].cost;
  if (tmp>mst) llx=min(llx,tmp);
  return;
  }
for (int i=p+1;i<=m+k-n+1;++i){
  a[k]=i,dfs(k+1,i);
  }
}

int main(){
  dfs(1,0);
  write(llx);
  }
}
 
int main(){
int i,j;
my_.init(n);
for (i=1;i<=m;++i) b[i].rd();
sort(b+1,b+m+1),getmst();
if (m<=15) return m_less_than_11::main(),0;
tree_chain_splitting::main();
}
```

---

## 作者：lzcjoe (赞：19)

### 题面

1493：次小生成树

时间限制: 1000 ms 内存限制: 65536 KB
 
【题目描述】

原题来自：BeiJing 2010 组队赛

给定一张 N 个点 M 条边的无向图，求无向图的严格次小生成树。

设最小生成树的边权之和为 sum，严格次小生成树就是指边权之和大于 sum 的生成树中最小的一个。

【输入】

第一行包含两个整数 N 和 M，表示无向图的点数与边数；
接下来 M 行，每行三个数 x,y,z，表示点 x 和点 y 之间有一条边，边的权值为 z。

【输出】

包含一行，仅一个数，表示严格次小生成树的边权和。
数据保证必定存在严格次小生成树。

【输入样例】

5 6 
1 2 1 
1 3 2 
2 4 3 
3 5 4 
3 4 3 
4 5 6

【输出样例】

11

【提示】

数据范围：

对于全部数据，1≤N≤10^5,1≤M≤3×10^5，数据中无向图无自环，边权值非负且不超过 10^9。

### 算法

次小生成树算法

1. **非严格次小生成树算法**

先使用最小生成树算法（Kruscal）计算最小生成树边权和，再逐一枚举新加的一条边（次小生成树一点是在最小生成树中删去一条边、增加一条边），此时会出现一个环，将环上除了添加的边以外的最大的边删去（贪心），即可得到一种生成树的方法，更新新的生成树的边权和的最小值即可。

但题目要求严格次小生成树（边权和严格大于最小生成树的边权和）时这种贪心的方法是不正确的，反例如下：

![](https://cdn.luogu.com.cn/upload/pic/71230.png)

此图的次小生成树边权和为11（1-2，2-4，3-4，3-5）。

可以在最小生成树中加上3-4边删去1-3边，但此算法在加入3-4边时处理1-2-4-3-1的环时最大值在2-4边，为3，此时次小生成树的边权与最小生成树一样，因为要求严格次小生成树，不会考虑，而会选择用加上4-5边，结果为12，不符。

2. **严格次小生成树生成树算法（Kruskal+树上倍增lca）**

**Kruskal**

求解最小生成树，再根据最小生成树的边权和更换边计算严格最小生成树。

**树上倍增lca**

求解最小生成树后，通过替换最小生成树上的边可以求解次小生成树。

在非严格次小生成树中，新添加的边的边权一定不小于最大值（否则就不是最小生成树），不能求出严格次小生成树（最大边可能等于添加的边的权值）。因此，对于严格次小生成树来说，不仅要求环上的最大值，还要求环上的次大值，这样在出现最大值等于边权时可以用次大值更新答案，保证答案正确性。

设$g[x][i] , maxl[x][i] , secl[x][i]$
分别表示在树上从x点向上走2^i层的结点编号、x点向上走2^i层遇到的边权的最大值、x点向上走2^i层遇到的边权的次大值，设i点与j点的最近公共祖先为k，则可以通过二进制分解和迭代得到i-k的最大值、次大值和j-k的最大值、次大值，枚举每一条不在最小生成树上的边更新答案即可。

### 代码

80 TLE：

```cpp
#include<cstdio>
#include<algorithm>
#define maxi(a,b) ((a)>(b)?(a):(b))

unsigned int n,m;

struct pic
{
	unsigned int u,v,w;
	char book;
	bool operator < (const pic &a) const
	{
		return w<a.w;
	}
}edge[300005];//存图

unsigned int father[100005];
unsigned int get_father(unsigned int a)
{
	if(father[a]==a)
	{
		return father[a];
	}
	father[a]=get_father(father[a]);
	return father[a];
}//并查集

unsigned int points;
unsigned long long int sum;
struct tree
{
	unsigned int to,next,w;
}tree[200005];
unsigned int cnt,head[100005];
void add(unsigned int u,unsigned int v,unsigned int w)
{
	cnt++;
	tree[cnt].to=v;
	tree[cnt].next=head[u];
	head[u]=cnt;
	tree[cnt].w=w;
}//链式前向心存树、建边

unsigned int deep[100005],maxl[100005][20],secl[100005][20],g[100005][20];
//倍增数组，deep为在树上的深度，其余的含义在前文已经描述

void dfs(unsigned int now)
{
	for(unsigned int i=head[now];i!=0;i=tree[i].next)
	{
		if(tree[i].to!=g[now][0])
		{
			deep[tree[i].to]=deep[now]+1;
			maxl[tree[i].to][0]=tree[i].w;
			g[tree[i].to][0]=now;
			dfs(tree[i].to);
		}
	}
}//DFS求点的深度和最大值、祖先初始化

unsigned long long int ans=999999999999999ull;
unsigned int get_lca(unsigned int u,unsigned int v)
{
	//假设u比j深
	if(deep[u]<deep[v])
	{
    	//不成立，进行交换
		unsigned int t;
		t=u;
		u=v;
		v=t;
	}
	unsigned int i;
	for(i=0;i<=18;i++)
	{
		if((1<<i)>deep[u])
		{
			break;
		}
	}
	i--;
    //求u的深度对应最大二进制次数
	for(int j=i;j>=0;j--)
	{
    	//从i开始枚举u、v之间的高度差
		if(deep[u]>=deep[v]+(1<<j))
		{
			u=g[u][j];
            //不断迭代u的值使其接近于v
		}
	}
	if(u==v)
	{
    	//u、v在一个点，返回这个点的值
		return u;
	}
    //此时u、v在同一层
	for(int j=18;j>=0;j--)
	{
    	//枚举祖先可能的层数，从大到小枚举，使分解唯一
		if(g[u][j]!=g[v][j])//祖先不同
		{
			u=g[u][j];
			v=g[v][j];
            //迭代更新u、v
		}
	}
    //此时找出的是距离公共祖先最近的两个点，距离为1层
	return g[u][0];
    //返回祖先值，即为最近公共祖先
}//树上倍增求lca

unsigned int get_ans(unsigned int u,unsigned int v,unsigned int w)
{
	//获取新增u->v构成的环中的最大值（次大值）
	unsigned int lca=get_lca(u,v),i,maxleft=0,maxright=0;
	for(i=0;i<=18;i++)
	{
		if((1<<i)>deep[u])
		{
			break;
		}
	}
	i--;
    //获取深度二进制
	for(int j=i;j>=0;j--)
	{
    	//枚举u与公共祖先的链上的最大值（次大值）
		if(deep[u]>=deep[lca]+(1<<j))
		{
			if(maxl[u][j]!=w)
			{
            	//最大值与边权相等
				maxleft=maxi(maxleft,maxl[u][j]);
                //取次大值
			}
			else
			{
            	//取最大值
				maxleft=maxi(maxleft,secl[u][j]);
			}
			u=g[u][j];//迭代接近lca
		}
	}
	for(i=0;i<=18;i++)
	{
		if((1<<i)>deep[v])
		{
			break;
		}
	}
	i--;
	for(int j=i;j>=0;j--)
	{
		if(deep[v]>=deep[lca]+(1<<j))
		{
			if(maxl[v][j]!=w)
			{
				maxright=maxi(maxright,maxl[v][j]);
			}
			else
			{
				maxright=maxi(maxright,secl[v][j]);
			}
			v=g[v][j];
		}
	}
    //同理求v与公共祖先的链上的最大值（次大值）
	return maxi(maxleft,maxright);
}
int main()
{
	scanf("%u%u",&n,&m);
	for(unsigned int i=1;i<=n;i++)
	{
		father[i]=i;
	}
	for(unsigned int i=1;i<=m;i++)
	{
		scanf("%u%u%u",&edge[i].u,&edge[i].v,&edge[i].w);
		edge[i].book=0;
	}
    //初始化、读入
	std::sort(edge+1,edge+m+1);
	for(unsigned short int i=1;i<=m;i++)
	{
		unsigned int fu=get_father(edge[i].u),fv=get_father(edge[i].v);
		if(fu!=fv)
		{
			points++;
			sum+=edge[i].w;
			edge[i].book=1;
			father[fv]=fu;
			add(edge[i].u,edge[i].v,edge[i].w);
			add(edge[i].v,edge[i].u,edge[i].w);
			if(points==n-1)
			{
				break;
			}
		}
	}
    //Kruskal算法，并添加树上边
	dfs(1);
    //初始化深度、单层的最大值
	for(unsigned short int i=1;i<=18;i++)
	{
		for(unsigned short int j=1;j<=n;j++)
        //short int -> TLE
		{
			g[j][i]=g[g[j][i-1]][i-1];
            //向上2^i层的祖先就是向上2^i-1层的祖先向上2^i-1层的祖先
			maxl[j][i]=maxi(maxl[j][i-1],maxl[g[j][i-1]][i-1]);
			secl[j][i]=maxi(secl[j][i-1],secl[g[j][i-1]][i-1]);
            //最大值、次大值分别更新
			if(maxl[j][i-1]<maxl[g[j][i-1]][i-1] && secl[j][i]<maxl[j][i-1])
			{
				secl[j][i]=maxl[j][i-1];
			}
			else if(maxl[j][i-1]>maxl[g[j][i-1]][i-1] && secl[j][i]<maxl[g[j][i-1]][i-1])
			{
				secl[j][i]=maxl[g[j][i-1]][i-1];
			}
            //针对不同情况更新可能的次大值
		}
	}
	for(unsigned int i=1;i<=m;i++)
	{
		if(edge[i].book==0)
		{
			unsigned int j=get_ans(edge[i].u,edge[i].v,edge[i].w);
			if(j!=edge[i].w && ans>sum-j+edge[i].w)
			{
				ans=sum-j+edge[i].w;
			}
            //获取链上的最大值（次大值）并更新答案
		}
	}
	printf("%llu",ans);//输出答案
	return 0;
}
```

---

读入优化 + 各种卡常手段（++、--和,） + 改short

100 AC：

```cpp
#include<cstdio>
#include<algorithm>
#define maxi(a,b) ((a)>(b)?(a):(b))
inline unsigned int fread()
{
	unsigned int x=0;
	char ch=getchar();
	while(ch<'0' || ch>'9')
	{
		ch=getchar();
	}
	while(ch>='0' && ch<='9')
	{
		x=x*10+ch-'0';
		ch=getchar();
	}
	return x;
}//读入优化
unsigned int n,m;
struct pic
{
	unsigned int u,v,w;
	char book;
	inline bool operator < (const pic &a) const
	{
		return w<a.w;
	}
}edge[300005];
unsigned int father[100005];
unsigned int get_father(unsigned int a)
{
	if(father[a]==a)
	{
		return father[a];
	}
	return father[a]=get_father(father[a]);
}
unsigned int points;
unsigned long long int sum;
struct tree
{
	unsigned int to,next,w;
}tree[200005];
unsigned int cnt,head[100005];
inline void add(unsigned int u,unsigned int v,unsigned int w)
{
	++cnt,tree[cnt].to=v,tree[cnt].next=head[u],head[u]=cnt,tree[cnt].w=w;
}
unsigned int deep[100005],maxl[100005][20],secl[100005][20],g[100005][20];
void dfs(unsigned int now,unsigned int fa)
{
	unsigned int v;
	for(unsigned int i=head[now];i!=0;i=tree[i].next)
	{
		v=tree[i].to;
		if(v!=fa)
		{
			deep[v]=deep[now]+1,maxl[v][0]=tree[i].w,g[v][0]=now;
			dfs(v,now);
		}
	}
}
unsigned long long int ans=999999999999999ull;
unsigned int get_lca(unsigned int u,unsigned int v)
{
	if(deep[u]<deep[v])
	{
		unsigned int t;
		t=u,u=v,v=t;
	}
	for(register short int j=18;j>=0;--j)
	{
		if(deep[g[u][j]]>=deep[v])
		{
			u=g[u][j];
		}
	}
	if(u==v)
	{
		return u;
	}
	for(register short int j=18;j>=0;--j)
	{
		if(g[u][j]!=g[v][j])
		{
			u=g[u][j],v=g[v][j];
		}
	}
	return g[u][0];
}
unsigned int get_ans(unsigned int u,unsigned int v,unsigned int w)
{
	unsigned int lca=get_lca(u,v),maxleft=0,maxright=0;
	for(register short int j=18;j>=0;--j)
	{
		if(deep[g[u][j]]>=deep[lca])
		{
			if(maxl[u][j]!=w)
			{
				maxleft=maxi(maxleft,maxl[u][j]);
			}
			else
			{
				maxleft=maxi(maxleft,secl[u][j]);
			}
			u=g[u][j];
		}
	}
	for(register short int j=18;j>=0;--j)
	{
		if(deep[g[v][j]]>=deep[lca])
		{
			if(maxl[v][j]!=w)
			{
				maxright=maxi(maxright,maxl[v][j]);
			}
			else
			{
				maxright=maxi(maxright,secl[v][j]);
			}
			v=g[v][j];
		}
	}
	return maxi(maxleft,maxright);
}
int main()
{
	n=fread(),m=fread();
	for(register unsigned int i=1;i<=n;++i)
	{
		father[i]=i;
	}
	for(register unsigned int i=1;i<=m;++i)
	{
		edge[i].u=fread(),edge[i].v=fread(),edge[i].w=fread();
	}
	std::sort(edge+1,edge+m+1);
	for(register unsigned int i=1;i<=m;++i)
	{
		register unsigned int fu=get_father(edge[i].u),fv=get_father(edge[i].v);
		if(fu!=fv)
		{
			++points,sum+=edge[i].w,edge[i].book=1,father[fv]=fu;
			add(edge[i].u,edge[i].v,edge[i].w);
			add(edge[i].v,edge[i].u,edge[i].w);
			if(points==n-1)
			{
				break;
			}
		}
	}
	dfs(1,0);
	for(register unsigned short int i=1;i<=18;++i)
	{
		for(register unsigned int j=1;j<=n;++j)
		{
			g[j][i]=g[g[j][i-1]][i-1],maxl[j][i]=maxi(maxl[j][i-1],maxl[g[j][i-1]][i-1]),secl[j][i]=maxi(secl[j][i-1],secl[g[j][i-1]][i-1]);
			if(maxl[j][i-1]<maxl[g[j][i-1]][i-1] && secl[j][i]<maxl[j][i-1])
			{
				secl[j][i]=maxl[j][i-1];
			}
			else if(maxl[j][i-1]>maxl[g[j][i-1]][i-1] && secl[j][i]<maxl[g[j][i-1]][i-1])
			{
				secl[j][i]=maxl[g[j][i-1]][i-1];
			}
		}
	}
	for(register unsigned int i=1;i<=m;++i)
	{
		if(edge[i].book==0)
		{
			unsigned int j=get_ans(edge[i].u,edge[i].v,edge[i].w);
			if(j!=edge[i].w && ans>sum-j+edge[i].w)
			{
				ans=sum-j+edge[i].w;
			}
		}
	}
	printf("%llu",ans);
	return 0;
}
```

总算是AC了！

#### 运行结果

一本通OJ：

1493

通过 100分

测试点1: 答案正确 312KB 1MS 

测试点2: 答案正确 688KB 1MS 

测试点3: 答案正确 680KB 1MS 

测试点4: 答案正确 712KB 2MS 

测试点5: 答案正确 1068KB 2MS 

测试点6: 答案正确 21704KB 104MS 

测试点7: 答案正确 19980KB 109MS 

测试点8: 答案正确 19452KB 88MS 

测试点9: 答案正确 41372KB 382MS 

测试点10: 答案正确 40116KB 272MS 

洛谷：

用时 1.44s 内存 32.70MB

测试点信息

6ms/8.62MB 
AC #1

4ms/1.04MB 
AC #2

6ms/10.63MB 
AC #3

6ms/10.88MB 
AC #4

5ms/1.26MB 
AC #5

201ms/27.55MB 
AC #6

150ms/15.88MB 
AC #7

102ms/15.25MB 
AC #8

658ms/32.70MB 
AC #9

302ms/31.57MB 
AC #10

---

//第2道AC的紫题

---

## 作者：qwaszx (赞：18)

可以证明次小生成树一定是最小生成树换一条边形成的，因为换更多的边一定不优

所以先跑出来一个最小生成树，然后枚举所有非树边，加入非树边之后会形成一个环，然后去掉环上的最大的一条树边

但是有一个问题是如果非树边等于环上的最大树边那么是不符合要求的，所以还要维护一个严格次大的树边

现在问题变成多次询问两点之间的最大和次大值.倍增是一种方法但是常数不优越

树剖一下，因为没有修改，所以还可以维护出每个点到链头的最大次大值，这样只需要最后查询一下即可.

最后这个查询可以线段树，这里用了玄学优化的$ST$表，期望$O(n)$的.可以去看$lxl$的$blog$.

最优解不知道写了个什么鬼算法能过，反正随便$hack$

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
#define INF 1000000007
using namespace std;
const int N=4e5;
struct Node{int mx,smx;}val[N];
int max(const int &a,const int &b){return a>b?a:b;}
int tp[N],f[N],dep[N],size[N],son[N],nxt[N],fst[N],mm,dfs_cnt,id[N],w[N],tw[N],n,m;
struct Edge{int u,v,w;}e1[N],e[N],tmp[N];
void ade(int u,int v,int w){e[++mm]=(Edge){u,v,w};nxt[mm]=fst[u],fst[u]=mm;}
void link(int u,int v,int w){ade(u,v,w),ade(v,u,w);}
Node pushup(const Node &a,const Node &b)
{
	if(a.mx>b.mx)return (Node){a.mx,max(a.smx,b.mx)};
	if(a.mx==b.mx)return (Node){a.mx,max(a.smx,b.smx)};
	return (Node){b.mx,max(a.mx,b.smx)};
}
Node pushup(const Node &a,const int &b)
{
	if(b>=a.mx)return (Node){b,a.smx};
	return (Node){a.mx,max(b,a.smx)};
}
struct DSU
{
	int f[N],size[N];
	void clear(){for(int i=1;i<=n;i++)size[i]=1;}
	int find(int x){return !f[x]?x:f[x]=find(f[x]);}
	void merge(int x,int y)
	{
		if(size[x]<size[y])f[x]=y,size[y]+=size[x];
		else f[y]=x,size[x]+=size[y];
	}
}dsu;
struct STable
{
	Node f[20][10000],pre[N],suf[N];
	int lg[N],blo,bl[N];
	void make()
	{
		blo=ceil(sqrt(n*4/3));
		for(register int i=1;i<=n;i++)bl[i]=(i-1)/blo+1;int bln=bl[n];
		for(register int i=1;i<=bln;i++)
		{
			int l=(i-1)*blo+1,r=min(i*blo,n);
			pre[l]=(Node){w[l],-INF},suf[r]=(Node){w[r],-INF};
			for(register int j=l+1;j<=r;j++)pre[j]=pushup(pre[j-1],w[j]);
			for(register int j=r-1;j>=l;j--)suf[j]=pushup(suf[j+1],w[j]);
			f[0][i]=pre[r];
		}
		lg[1]=0;for(register int i=2;i<=bln;i++)lg[i]=lg[i>>1]+1;
		for(register int i=1;(1<<i)<=bln;i++)
			for(register int j=1;j+(1<<i)-1<=bln;j++)
				f[i][j]=pushup(f[i-1][j],f[i-1][j+(1<<(i-1))]);
	}
	Node query(int l,int r)
	{
		int bll=bl[l],blr=bl[r];Node ans;
		if(bll==blr){ans=(Node){w[l],-INF};for(register int i=l+1;i<=r;i++)ans=pushup(ans,w[i]);return ans;}
		ans=pushup(suf[l],pre[r]);
		if(++bll<=--blr)
		{
			int len=lg[blr-bll+1];
			ans=pushup(ans,pushup(f[len][bll],f[len][blr-(1<<len)+1]));
		}
		return ans;
	}
}a;
void dfs1(int u,int fa)
{
	f[u]=fa,dep[u]=dep[fa]+1,size[u]=1;
	int mx=0;
	for(register int i=fst[u];i;i=nxt[i])
	{
		int v=e[i].v;
		if(v==fa)continue;
		dfs1(v,u);
		size[u]+=size[v];
		if(size[v]>mx)mx=size[v],son[u]=v;
	}
}
void dfs2(register int u,int top)
{
	tp[u]=top,id[u]=++dfs_cnt;w[dfs_cnt]=tw[u];
	if(u==top)val[u]=(Node){tw[u],-INF};
	else val[u]=pushup(val[f[u]],tw[u]);
	if(son[u])dfs2(son[u],top);
	for(register int i=fst[u];i;i=nxt[i])
	{
		int v=e[i].v;
		if(v!=son[u]&&v!=f[u])
			dfs2(v,v);
	}
}
Node query(register int x,register int y)
{
	register Node ans={-INF,-INF};
	while(tp[x]!=tp[y])
	{
		if(dep[tp[x]]<dep[tp[y]])swap(x,y);
		ans=pushup(ans,val[x]);
		x=f[tp[x]];
	}
	if(dep[x]<dep[y])swap(x,y);
	if(x!=y)ans=pushup(ans,a.query(id[y]+1,id[x]));
	return ans;
}
int getin()
{
	int x=0;char ch=getchar();
	while(ch<'0'||ch>'9')ch=getchar();
	while(ch>='0'&&ch<='9')x=x*10+ch-48,ch=getchar();
	return x;
}
int cmp(const Edge &a,const Edge &b){return a.w<b.w;}
int main()
{
	n=getin(),m=getin();
	for(register int i=1;i<=m;i++)
	{
		e1[i].u=getin(),e1[i].v=getin(),e1[i].w=getin();
	}
	sort(e1+1,e1+m+1,cmp);long long s=0,ans=1e18;int cnt=0;
	dsu.clear();//puts("");
	for(register int i=1;i<=m;i++)
	{
		int u=dsu.find(e1[i].u),v=dsu.find(e1[i].v);
		if(u!=v)
		{
			link(e1[i].u,e1[i].v,e1[i].w);
			dsu.merge(u,v);s+=e1[i].w;//cout<<e1[i].u<<" "<<e1[i].v<<" "<<e1[i].w<<endl;
		}
		else tmp[++cnt]=(Edge){e1[i].u,e1[i].v,e1[i].w};
	}
	dfs1(1,0);tw[1]=-INF;
	for(register int i=1;i<=mm;i+=2)
		tw[dep[e[i].u]>dep[e[i].v]?e[i].u:e[i].v]=e[i].w;
	dfs2(1,1);a.make();
	for(register int i=1;i<=cnt;i++)
	{
		int u=tmp[i].u,v=tmp[i].v,w=tmp[i].w;//cout<<u<<" "<<v<<endl;
		Node t=query(u,v);//printf("%d %d\n",t.mx,t.smx);
		if(w==t.mx)ans=min(ans,s-t.smx+w);
		else ans=min(ans,s-t.mx+w);
	}
	cout<<ans<<endl;
}
```

---

## 作者：Masky (赞：10)

## 次小生成树

一开始只是兴起学一学，思路挺好理解的但是打代码不知道是想复杂了还是怎么的，反正很繁琐，调了一整天


一、定义
非严格次小生成树，即边权和小于等于最小生成树边权和的生成树；严格次小生成树，即边权和大于最小生成树边权和的生成树


****
****
****

\
二、解法

首先，我们可以证明，次小生成树与最小生成树一定只有一条不同的边。
\
这是很显然的，因为我们如果选出两条边来替换最小生成树的边，一定是没有只替换一条边优。

那么，对于每一条非树边$(u,v)$，如果我们把它加入生成树，就会形成一个环，我们要从环里删除一条边使仍然构成一棵树，那么要使生成的树边权和尽量小，我们就需要找到这个环里除了边$~(u,v)~$外最大的一条边（$Q$:为什么除了边$~(u,v)~$？$A$:因为这是我们要加进去的边），即原生成树上$u$到$v$的路径上边权最大的一条边。这我们可以通过倍增或者树剖实现。
\
具体而言，用每个点的点权存储其到其父亲的边的边权。但是这样有一个问题，就是说如果$~u,v~$不在同一条链上，那么我们要求的其路径上的最大值就是路径$~(u,v)~$上不包括$~lca(u,v)~$的所有点的点权最大值。那么怎样实现不包括$~lca~$呢？
\
对于倍增，我们只需要使最终求的比$~lca~$深度大$~1~$即可。代码如下：
```
int ans=-inf;
for(int i=20;i>=0;i--){
    if((dep[x]-(1<<i))>dep[y]){
        ans=max(ans,Max[x][i]);
        x=f[x][i];
    }
}
if(f[x][0]==y)return ans;
for(int i=20;i>=0;i--){
    if(f[f[x][i]][0]!=f[f[y][0]]){
        ans=max(ans,max(Max[x][i],Max[y][i]));
        x=f[x][i],y=f[y][i];
    }
}
return ans;
//应该是这样的，反正也没写过，我写的时树剖版本的。
```
对于树剖，先求出$~lca~$，在$~x~$不断向$~lca~$所在重链链上跳时，如果最终与$~lca~$重合，那么所求即为前一步的重链的顶，否则是$~lca~$所在重链的下一个点即在线段树上标号$+1$的数。代码如下：
```
il int find(int x,int fu){
    int now=0;
    while(top[x]!=top[fu])now=top[x],x=fa[top[x]];
    if(x==fu)return now;return reflect[id[fu]+1];
}
node now=pushup(query_way(x,find(x,fu)),query_way(y,find(y,fu)));
```
在求严格次小生成树时，我们需要考虑，如果所考虑的非树边边权和环内最大边边权一样，那么我们还要去找环内的次大边，所以在树剖的线段树上还要维护次大值。

树剖版核心代码如下：
```
namespace tre_cut{
    int dep[maxn],siz[maxn],son[maxn],fa[maxn],w_data[maxn];
    int top[maxn],cnt,id[maxn],a[maxn],reflect[maxn];
    struct node{int Max,MMax;}tre[maxn<<1];
    struct NODE{int ls,rs;}tree[maxn<<1];
    il void dfs1(int x,int fu,int deep){
        dep[x]=deep;fa[x]=fu;siz[x]=1;
        for(rint i=hed[x];i;i=nxt[i]){
            if(!vis[i]||to[i]==fu)continue;
            dfs1(to[i],x,deep+1);w_data[to[i]]=w[i];
            siz[x]+=siz[to[i]];
            if(siz[to[i]]>siz[son[x]])son[x]=to[i];
        }return;
    }
    il void dfs2(int x,int topx){
        top[x]=topx;id[x]=++cnt;a[cnt]=w_data[x];reflect[cnt]=x;
        if(!son[x])return;dfs2(son[x],topx);
        for(rint i=hed[x];i;i=nxt[i]){
            if(to[i]==fa[x]||to[i]==son[x]||!vis[i])continue;
            dfs2(to[i],to[i]);
        }return;
    }
    int comp[5];
    il node pushup(node ls,node rs){
        comp[1]=ls.Max,comp[2]=ls.MMax,comp[3]=rs.Max,comp[4]=rs.MMax;
        int Max=-inf,MMax=-inf-inf;
        for(rint i=1;i<=4;++i){
            if(comp[i]>Max)MMax=Max,Max=comp[i];
            else if(comp[i]<Max&&comp[i]>MMax)MMax=comp[i];
        }
        return (node){Max,MMax};
    }
    int CNT;
    il void build(int &rt,int l,int r){
        if(!rt)rt=++CNT;
        if(l==r)return (void)(tre[rt]=(node){a[l],-inf});
        build(lson),build(rson);
        tre[rt]=pushup(tre[tree[rt].ls],tre[tree[rt].rs]);
    }
    il node query(int rt,int l,int r,int L,int R){
        if(!rt)return (node){-inf,-inf-inf};
        if(L<=l&&r<=R)return tre[rt];
        node end=(node){-inf,-inf-inf};
        if(L<=Mid)end=pushup(end,query(lson,L,R));
        if(R>Mid)end=pushup(end,query(rson,L,R));
        return end;
    }
    il int lca(int x,int y){
        while(top[x]!=top[y]){
            if(dep[top[x]]<dep[top[y]])swap(x,y);
            x=fa[top[x]];
        }
        if(dep[x]>dep[y])swap(x,y);
        return x;
    }
    il void process(){//预处理
        dfs1(1,0,1);dfs2(1,1);
        int rt=0;build(rt,1,n);
        return;
    }
    il int find(int x,int fu){
        int now=0;
        while(top[x]!=top[fu])now=top[x],x=fa[top[x]];
        if(x==fu)return now;return reflect[id[fu]+1];
    }
    il node query_way(int x,int y){
        node end=(node){-inf,-inf-inf};
        while(top[x]!=top[y]){
            if(dep[top[x]]<dep[top[y]])swap(x,y);
            end=pushup(end,query(1,1,n,id[top[x]],id[x]));
            x=fa[top[x]];
        }
        if(dep[x]>dep[y])swap(x,y);
        end=pushup(end,query(1,1,n,id[x],id[y]));
        return end;
    }
    il void doit(int x,int y,int z){
        int fu=lca(x,y);
        node now=pushup(query_way(x,find(x,fu)),query_way(y,find(y,fu)));
        int S1=S+z-now.Max,S2=S+z-now.MMax;
        if(S1>S)ANS=min(ANS,S1);
        else if(S2>S) ANS=min(ANS,S2);
        return;
    }
}
signed main(){
    for(int i=2;i<=e;i+=2){
        if(vis[i])continue;//vis表示该边是否在最小生成树上
        tre_cut::doit(fr[i],to[i],w[i]);//查询每条非树边的端点u,v在树上的路径中最大的边权
    }
    printf("%lld\n",ANS);
    return 0;
}
```
思路极其清晰

---

## 作者：回青绝影 (赞：9)

### ——我好难,QAQ

这道题卡了我一下午！

##### ~~就是这样的，然而很有意思的是中间发生了十分多的事，比如：当我发现了我的一个错误的时候，我很开心的以为我可以A了，结果——换了一个点WA（太棒了！），然后我果断弃了此题。直到第二天，我又重新打了一遍，然后，我就想到了一个问题，成功切了这道毒瘤题……~~

总而言之，我太菜了！

---

 想必这道题的思路是很明确的——**LCA+最小生成树**，~~因为我不会LCT~~。

我的问题在于，原先我的思路是，次小生成树，这并不严格……所以：

### 80分：
```cpp
int lca(int x,int y,int z){
    if (find(x)!=find(y)) return -1;
	if (dep[x]<dep[y]) swap(x,y);
	int d=dep[x]-dep[y],ans=0;
	for (int i=0;(1<<i)<=d;i++)
		if ((1<<i)) ans=max(ans,(an[x][i]==z?0:an[x][i])),x=f[x][i];
	if (x==y) return ans;
	for (int i=log2(dep[x]);i>=0;i--)
		if (f[x][i]!=f[y][i]) ans=max(max(an[x][i],an[y][i])==z?0:max(an[x][i],an[y][i]),ans),x=f[x][i],y=f[y][i];
	return max(max(an[x][0],an[y][0])==z?0:max(an[x][0],an[y][0]),ans);
}
```

然而如果是严格次小生成树，那么，就不能把删去的边与新添加进去的边的值相等。这是问题一。

### 90分：
```cpp
int lca(int x,int y,int z){
    if (find(x)!=find(y)) return -1;
	if (dep[x]<dep[y]) swap(x,y);
	int d=dep[x]-dep[y],ans=0;
	for (int i=0;(1<<i)<=d;i++)
		if ((1<<i)&d) ans=max(ans,(an[x][i]==z?0:an[x][i])),x=f[x][i];
	if (x==y) return ans;
	for (int i=log2(dep[x]);i>=0;i--)
		if (f[x][i]!=f[y][i]) ans=max(max(an[x][i],an[y][i])==z?0:max(an[x][i],an[y][i]),ans),x=f[x][i],y=f[y][i];
	return max(max(an[x][0],an[y][0])==z?0:max(an[x][0],an[y][0]),ans);
}
```

第二个问题是，你会发现，在第二段代码里面，我对于与加入边相等的值相等的边，我是不会取的，而是取了0，然而这很明显有问题，所以要存一下次小的值……，于是就改好了！

### 100分：

```cpp
int lca(int x,int y,int z){
//    if (find(x)!=find(y)) return -1;
	if (dep[x]<dep[y]) swap(x,y);
	int d=dep[x]-dep[y],ans=0;
	for (int i=0;(1<<i)<=d;i++)
		if ((1<<i)&d) ans=max(ans,(an[x][i]==z?an1[x][i]:an[x][i])),x=f[x][i];
	if (x==y) return ans;
	for (int i=log2(dep[x]);i>=0;i--)
		if (f[x][i]!=f[y][i]) ans=max(max(an[x][i],an[y][i])==z?an1[x][i]:max(an[x][i],an[y][i]),ans),x=f[x][i],y=f[y][i];
	return (max(max(an[x][0],an[y][0])==z?max(max(an1[x][0],an1[y][0]),ans):max(an[x][0],an[y][0]),ans));
}
```

## 总代吗：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1000001,M=600001,INF=1e9+7;
struct st{
    int x,y,z;
}kr[M];
int n,m,k,rt,cnt,q,ans=INF,anz;
int nxt[M<<1],last[N],a[M<<1],w[M<<1];
int fa[N],f[N][21],dep[N],sz[N],an[N][21],an1[N][21];
bool l[N];
void add(int x,int y,int z){
    nxt[++k]=last[x];
    last[x]=k;
    a[k]=y;
    w[k]=z;
}
bool cmp(st a,st b){
    return a.z<b.z;
}
int find(int x){
    if (x==fa[x]) return x;
    else return fa[x]=find(fa[x]);
}
void kruskal(){
    sort(kr+1,kr+1+m,cmp);
    for (int i=1;i<=m;i++){
        if (kr[i].x==kr[i-1].x&&kr[i].y==kr[i-1].y){l[i]=1;continue;}
        int b=find(kr[i].x),c=find(kr[i].y);
        if (b!=c){
            fa[b]=c;
            cnt++;l[i]=1;anz+=kr[i].z;//printf("%d %d %d\n",kr[i].x,kr[i].y,kr[i].z);
            add(kr[i].x,kr[i].y,kr[i].z);
            add(kr[i].y,kr[i].x,kr[i].z);
        }
        if (cnt==n-1) return ;
    }
}
void dfs_lca(int x,int fa,int y){
	dep[x]=dep[fa]+1;
	f[x][0]=fa;an[x][0]=y;an1[x][0]=0;
	for (int i=1;(1<<i)<=dep[x];i++)
		f[x][i]=f[f[x][i-1]][i-1],
		an[x][i]=max(an[f[x][i-1]][i-1],an[x][i-1]),
		an1[x][i]=max(max(an1[f[x][i-1]][i-1],an1[x][i-1]),an[x][i-1]==an[f[x][i-1]][i-1]?0:min(an[x][i-1],an[f[x][i-1]][i-1]));
	for (int i=last[x];i;i=nxt[i])
		if (a[i]!=fa) dfs_lca(a[i],x,w[i]);
}
int lca(int x,int y,int z){
//    if (find(x)!=find(y)) return -1;
	if (dep[x]<dep[y]) swap(x,y);
	int d=dep[x]-dep[y],ans=0;
	for (int i=0;(1<<i)<=d;i++)
		if ((1<<i)&d) ans=max(ans,(an[x][i]==z?an1[x][i]:an[x][i])),x=f[x][i];
	if (x==y) return ans;
	for (int i=log2(dep[x]);i>=0;i--)
		if (f[x][i]!=f[y][i]) ans=max(max(an[x][i],an[y][i])==z?an1[x][i]:max(an[x][i],an[y][i]),ans),x=f[x][i],y=f[y][i];
	return (max(max(an[x][0],an[y][0])==z?max(max(an1[x][0],an1[y][0]),ans):max(an[x][0],an[y][0]),ans));
}
signed main(){
    // freopen("a.in","r",stdin);
    scanf("%lld%lld",&n,&m);
    for (int i=1;i<=n;i++) fa[i]=i;
    // memset(an,0,sizeof(an));memset(l,0,sizeof(l));
    for (int i=1;i<=m;i++) scanf("%lld%lld%lld",&kr[i].x,&kr[i].y,&kr[i].z);
    kruskal();
	for (int i=1;i<=n;i++)
		if (!dep[i]) dfs_lca(i,0,0);
    for (int x,i=1;i<=m;i++)
        if (!l[i]){
            x=lca(kr[i].x,kr[i].y,kr[i].z);//printf("%d %d %d\n",kr[i].x,kr[i].y,x);
            if (kr[i].z-x) ans=min(ans,kr[i].z-x);
        }
    printf("%lld",ans+anz);
    return 0;
}
```


---

## 作者：hepan (赞：7)

### 题目大意

找到一棵**严格**次小生成树，边权和**大于**最小生成树。

$n\le10^5,m\le 3\cdot 10^5,w_i\le10^9$

### 思路

比较厉害的一道题，几乎完全覆盖了提高组的知识点，没有一点超出提高组的范围。

因为是次小生成树，一定是与最小生成树有很大关联的，所以先用 kruskal 求出最小生成树。

考虑每条边，假设该边在次小生成树上，那么必须删去两点之间的一条边，但不能与这条边权值相同，因为这个过程一定是增加权值，所以只能进行一次。

具体的，维护数组数组 $fa_{u,i},fimx_{u,i},semx_{u,i}$ 表示 $u$ 往上 $2^i$ 的的祖先，$u$ 到 $2^i$ 祖先这段的最大值、次大值。在求 LCA 的预处理同时处理，求 LCA 是同时维护答案。

时间复杂度：$\Theta(m\log n+n\log n)$

### code

```
#include <bits/stdc++.h>
using namespace std;
#define rep(i,a,n) for (int i=a;i<=n;i++)
#define per(i,a,n) for (int i=a;i>=n;i--)
#define pb push_back
#define mp make_pair
#define all(x) (x).begin(),(x).end()
#define fi first
#define se second
#define SZ(x) ((int)(x).size())
typedef vector<int> VI;
typedef long long ll;
typedef pair<int,int> PII;
const int mod=998244353;
const ll mod2=1ll*mod*mod;
const int maxn=3e5+10;
int quick(int a,int b){int res=1;a%=mod;assert(b>=0); for(;b;b>>=1){if(b&1)res=1ll*res*a%mod;a=1ll*a*a%mod;}return res;}
int gcd(int a,int b){return b?gcd(b,a%b):a;}
int n,m,pa[maxn][23],dep[maxn],fimx[maxn][23],semx[maxn][23],FA[maxn];
ll ans=1e18,mst;
vector<PII> eg[maxn];
struct edge{
	int u,v,w,qu;
	bool operator<(const edge x)const{
		return w<x.w;
	}
}e[maxn];
int find(int u){
	return (FA[u]==u)?u:FA[u]=find(FA[u]);
}
void kruskal(){
	rep(i,1,n) FA[i]=i;
	sort(e+1,e+m+1);
	rep(i,1,m){
		int u=find(e[i].u),v=find(e[i].v);
		if(u==v) continue;
		mst+=e[i].w;
		FA[u]=v;
		e[i].qu=1;
		eg[e[i].u].pb(mp(e[i].v,e[i].w));
		eg[e[i].v].pb(mp(e[i].u,e[i].w));
	} 
}
void dfs(int u,int fa){
	dep[u]=dep[fa]+1;
	pa[u][0]=fa;
	for(int i=0;i<SZ(eg[u]);i++){
		int v=eg[u][i].fi;
		if(v==fa) continue;
		fimx[v][0]=eg[u][i].se;
		dfs(v,u);
	}
}
void init(){
	rep(j,1,18)
		rep(i,1,n){
			pa[i][j]=pa[pa[i][j-1]][j-1];
			fimx[i][j]=max(fimx[i][j-1],fimx[pa[i][j-1]][j-1]);
			semx[i][j]=max(semx[i][j-1],semx[pa[i][j-1]][j-1]);
			if(fimx[i][j-1]!=fimx[pa[i][j-1]][j-1])
				semx[i][j]=max(semx[i][j],min(fimx[i][j-1],fimx[pa[i][j-1]][j-1]));
		}
}
void query(int u,int v,int w){
	int maxn1=0,maxn2=0;
	if(dep[u]>dep[v]) swap(u,v);
	per(i,18,0) 
		if(dep[v]>=dep[u]+(1<<i)){
			if(maxn1^fimx[v][i]) maxn2=max(maxn2,min(maxn1,fimx[v][i]));
			maxn1=max(maxn1,fimx[v][i]);
			maxn2=max(maxn2,semx[v][i]);
			v=pa[v][i];
		}
	if(u==v){
		ll tmp=w-((w==maxn1)?maxn2:maxn1);
		ans=min(ans,mst+tmp);
		return ;
	}
	per(i,18,0){
		if(pa[u][i]!=pa[v][i]){
			if(maxn1^fimx[u][i]) maxn2=max(maxn2,min(maxn1,fimx[u][i]));
			maxn1=max(maxn1,fimx[u][i]);
			maxn2=max(maxn2,semx[u][i]);
			if(maxn1^fimx[v][i]) maxn2=max(maxn2,min(maxn1,fimx[v][i]));
			maxn1=max(maxn1,fimx[v][i]);
			maxn2=max(maxn2,semx[v][i]);
			v=pa[v][i],u=pa[u][i];
		}
	}
	if(maxn1^fimx[u][0]) maxn2=max(maxn2,min(maxn1,fimx[u][0]));
	maxn1=max(maxn1,fimx[u][0]);
	maxn2=max(maxn2,semx[u][0]);
	if(maxn1^fimx[v][0]) maxn2=max(maxn2,min(maxn1,fimx[v][0]));
	maxn1=max(maxn1,fimx[v][0]);
	maxn2=max(maxn2,semx[v][0]);
	ll tmp=w-((w==maxn1)?maxn2:maxn1);
	ans=min(ans,mst+tmp);
	return ;
}
int main(){
	cin>>n>>m;
	rep(i,1,m) scanf("%d%d%d",&e[i].u,&e[i].v,&e[i].w);
	kruskal();
	dfs(1,0);
	init();
	rep(i,1,m) 
		if(!e[i].qu){
			query(e[i].u,e[i].v,e[i].w);
		}
	cout<<ans;
	return 0;
}
```

---

## 作者：wjyyy (赞：7)

**给大常数lct选手一个救赎的机会。**

**博客地址：[传送门](https://www.wjyyy.top/3020.html)**

## 题解：

第一眼看上去是一个lct维护生成树的问题。然而没有动态加删边，可能是大材小用。

不过用lct直接维护生成树也有一定的问题。如果我们枚举不在生成树上的边，找环并删除环上边权小于当前边的权值最大的边，也许并不能保证**最小生成树与(严格)次小生成树只相差一对边**。

实际上是可以的。我们用反证法稍微考虑一下最小生成树(MST)与(严格)次小生成树(SST)相差两对边的情况。



_如果MST和SST相差两对边，假设分别为$\{a_1,b_1\},\{a_2,b_2\}$，也就是说$\{a_1,a_2\}$在MST上，$\{b_1,b_2\}$在SST上。那么一定有_
$$a_1+a_2<b_1+b_2\qquad(1)$$
_但是这个不等式可以有多种情况，我们现在已经把$\{a_1,a_2\}$删掉了，还要加回两条边（不为原来的边）使得图重新构成一棵生成树，可以有$\{a_1,b_1\},\{a_1,b_2\},\{a_2,b_2\},\{a_2,b_1\},\{b_1,b_2\}$这五种情况。但是无论如何，$\{b_1,b_2\}$都不会是这五组中最小的。_

_假设$a_1\le a_2,b_1\le b_2$，若$a_1<b_1$，则$\{a_1,b_2\}$一定在次小生成树上了了，若$a_1\ge b_1$，由不等式$(1)$，一定有$a_2<b_2$，那么此时$\{a_2,b_1\}$就最优了。_

_证毕。_



那么此时就考虑查询一条链上小于$x$的最大边权来更新答案。因为lct是用splay做的，所以可以维护链上的最大值和次大值，大致是这样的：

```cpp
void maintain(int k)
{
    sum[k]=Max(Max(sum[ls],key[k]),sum[rs]);//维护最大值
    ssum[k]=0;//次大值
    ssum[k]=(sum[ls]<sum[k]&&sum[ls]>ssum[k])?sum[ls]:ssum[k];//次大值只可能在这四种中出现
    ssum[k]=(key[k]<sum[k]&&key[k]>ssum[k])?key[k]:ssum[k];
    ssum[k]=(ssum[ls]<sum[k]&&ssum[ls]>ssum[k])?ssum[ls]:ssum[k];
    ssum[k]=(ssum[rs]<sum[k]&&ssum[rs]>ssum[k])?ssum[rs]:ssum[k];
}
```

常数是原来的$3$倍多。轻而易举TLE。~~因此如果不是要练LCT还是建议大家写倍增/树剖。~~

不过我们可以提取出来这条链然后dfs这棵子splay，带入参数$x$，找到小于$x$的最大边权。既然我们已经维护了子树最大值，就可以**剪枝**，对，就是剪枝。如果子树最大值小于$x$了，直接用最大值更新答案并返回，否则继续dfs。

这种操作的最坏复杂度是$O(nm)$的，一条构造过的链应该可以卡得掉。不过数据强度不是很大，剪枝效果比较好，O2最慢的点也只跑了709ms。

## Code：

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#define ls ch[0][k]
#define rs ch[1][k]
#define which(k) (ch[1][fa[k]]==k)
#define isroot(k) (ch[0][fa[k]]!=k&&ch[1][fa[k]]!=k)
int read()
{
    char ch=getchar();
    int x=0;
    while(ch<'0'||ch>'9')
        ch=getchar();
    while(ch>='0'&&ch<='9')
    {
        x=x*10+ch-'0';
        ch=getchar();
    }
    return x;
}
int Max(int x,int y)
{
    return x>y?x:y;
}
int ch[2][401000],fa[401000];
int key[401000],sum[401000],lazy[401000];
void pushdown(int k)
{
    if(lazy[k])
    {
        lazy[k]=0;
        int tmp=ls;
        ls=rs;
        rs=tmp;
        lazy[ls]^=1;
        lazy[rs]^=1;
    }
}
void maintain(int k)
{
    sum[k]=Max(Max(sum[ls],key[k]),sum[rs]);
}
void Rotate(int k)
{
    int y=fa[k];
    if(!isroot(y))
        ch[which(y)][fa[y]]=k;
    bool d=which(k);
    fa[k]=fa[y];
    fa[y]=k;
    ch[d][y]=ch[!d][k];
    fa[ch[d][y]]=y;
    ch[!d][k]=y;
    maintain(y);
    maintain(k);
}
int stk[401000],tp=0;
void splay(int k)
{
    while(!isroot(k))
    {
        stk[++tp]=k;
        k=fa[k];
    }
    stk[++tp]=k;
    int qaq=fa[k];
    while(tp)
        pushdown(stk[tp--]);
    k=stk[1];
    while(fa[k]!=qaq)
    {
        int y=fa[k];
        if(!isroot(y))
            Rotate(which(k)^which(y)?k:y);
        Rotate(k);
    }
}
void access(int k)
{
    for(register int x=k,y=0;x;y=x,x=fa[x])
    {
        splay(x);
        ch[1][x]=y;
        maintain(x);
    }
}
void makeroot(int k)
{
    access(k);
    splay(k);
    lazy[k]^=1;
}
int getroot(int k)
{
    access(k);
    splay(k);
    while(ls)
        k=ls;
    return k;
}
void split(int x,int y)
{
    makeroot(x);
    access(y);
    splay(y);
}
void link(int x,int y)
{
    makeroot(x);
    fa[x]=y;
}
int Find(int k,int x)//在splay中找小于x的最大值
{
    int tmp=0;
    if(key[k]<x)//先比较当前节点
        tmp=key[k];
    if(sum[ls]<x)//决策进不进入左儿子
        tmp=tmp>sum[ls]?tmp:sum[ls];
    else
    {
        int y=Find(ls,x);
        tmp=tmp>y?tmp:y;
    }
    if(sum[rs]<x)//右儿子
        tmp=tmp>sum[rs]?tmp:sum[rs];
    else
    {
        int y=Find(rs,x);
        tmp=tmp>y?tmp:y;
    }
    return tmp;
}
struct edge
{
    int x,y,w;
    friend bool operator <(edge a,edge b)
    {
        return a.w<b.w;
    }
}e[300100];
bool used[300100];
int main()
{
    int n,m;
    long long Sum=0,ans=1e18;
    n=read();
    m=read();
    for(int i=1;i<=m;++i)
    {
        e[i].x=read();
        e[i].y=read();
        e[i].w=read();
    }
    std::sort(e+1,e+1+m);
    for(int i=1;i<=m;++i)
    {
        key[n+i]=sum[n+i]=e[i].w;
        makeroot(e[i].x);
        if(getroot(e[i].y)!=e[i].x)
        {
            used[i]=1;
            link(e[i].x,n+i);
            link(e[i].y,n+i);
            Sum+=e[i].w;
        }
    }
    for(int i=1;i<=m;++i)
        if(!used[i])
        {
            split(e[i].x,e[i].y);
            int t=Find(e[i].y,e[i].w);//不超过e[i].w
            ans=ans<Sum+key[n+i]-t?ans:Sum+key[n+i]-t;
        }
    printf("%lld\n",ans);
    return 0;
}
```


---

## 作者：hicc0305 (赞：4)

求次小生成树，首先我们要求出最小生成树

然后，我们显然要拿没被选中的边来替换最小生成树中的边。

当我们把一条边加进去的时候，必然会形成一个环，那么很简单，我们只用找出环上除新加边的且不与新加相等边最大边，差值就是加这条边的最小增加量。然后所有最小增加量再加上最小生成树的边权值，就是答案了。

同理，我们也可以这样求第三小生成树，而再小的话就不行了，因为有可能替换两条边要比替换一条边要小。而求第三小的话是不会出现这种情况的，原因如下：假设替换a增加量最小，b次小，c最大，显然a<b<a+b,而a+b是否小于c是不能确定的。

然后怎么找出环上除新加边的且不与新加相等边最大边呢？对于边(u,v)我们找出u,v的LCA：l，然后用倍增处理u->l,v->l两条路径，即可。但由于可能出现最大值和新加边的权值相等，所以我们还要预处理次大边，如下：

预处理：f不多说，v1为j倍增处理出的最大值，v2就是次大值。

```cpp
for(int i=1;i<=21;i++)
		for(int j=1;j<=n;j++)
		{
			f[i][j]=f[i-1][f[i-1][j]];
			v1[i][j]=max(v1[i-1][j],v1[i-1][f[i-1][j]]);
			v2[i][j]=max(v2[i-1][j],v2[i-1][f[i-1][j]]);
			if(v1[i-1][j]>v1[i-1][f[i-1][j]]) v2[i][j]=max(v2[i][j],v1[i-1][f[i-1][j]]);
            else if(v1[i-1][j]<v1[i-1][f[i-1][j]]) v2[i][j]=max(v2[i][j],v1[i-1][j]);
		}
```

对于一条环的处理：
```
int get(int u,int v,int k)
{
	int res=-INF; 
	for(int i=20;i>=0;i--)
		if(dep[f[i][u]]>=dep[v])
		{
			if(k!=v1[i][u]) res=max(res,v1[i][u]);//不一样就和最大的取max
            else res=max(res,v2[i][u]);//否则和次大的取max
            u=f[i][u];
		}
	return res;
}


for(int i=1;i<=m;i++)
		if(!e[i].in)
		{
			int l=Lca(e[i].x,e[i].y);
			int res=max(get(e[i].x,l,e[i].z),get(e[i].y,l,e[i].z));
			ans=min(ans,e[i].z-res);
		}
```

OK，全部的代码：
```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#define int long long
using namespace std;
const long long INF=214748364700000;
int n,m,sum=0,cnt=0;
int fa[100100],f[30][100100],dep[100100],v1[30][100100],v2[30][100100];
int head[200100],nxt[200100],to[200100],val[200100];
struct Edge
{
	int x,y,z,in;
}e[300100];
bool cmp(Edge a,Edge b) {return a.z<b.z;}
int find(int x)
{
	if(fa[x]==x) return x;
	return fa[x]=find(fa[x]);
}
void addedge(int x,int y,int z)
{
	cnt++;
	nxt[cnt]=head[x];
	head[x]=cnt;
	to[cnt]=y;
	val[cnt]=z;
}
void dfs(int u,int pre)
{
	for(int i=head[u];i!=-1;i=nxt[i])
	{
		int v=to[i];
		if(v==pre) continue;
		dep[v]=dep[u]+1,f[0][v]=u;
		v1[0][v]=val[i],v2[0][v]=-INF;
		dfs(v,u);
	}
}
int Lca(int x,int y)
{
	if(dep[x]<dep[y]) swap(x,y);
	for(int i=20;i>=0;i--)
		if(dep[f[i][x]]>=dep[y]) x=f[i][x];
	if(x==y) return x;
	for(int i=20;i>=0;i--)
		if(f[i][x]!=f[i][y]) x=f[i][x],y=f[i][y];
	return f[0][x];
}
int get(int u,int v,int k)
{
	int res=-INF; 
	for(int i=20;i>=0;i--)
		if(dep[f[i][u]]>=dep[v])
		{
			if(k!=v1[i][u]) res=max(res,v1[i][u]);
            else res=max(res,v2[i][u]);
            u=f[i][u];
		}
	return res;
}
signed main()
{
	memset(head,-1,sizeof(head));
	scanf("%lld%lld",&n,&m);
	for(int i=1;i<=m;i++)
		scanf("%lld%lld%lld",&e[i].x,&e[i].y,&e[i].z);
	sort(e+1,e+m+1,cmp);
	for(int i=1;i<=n;i++)
		fa[i]=i;
	for(int i=1;i<=m;i++)
	{
		if(cnt==2*n-2) break;
		int fx=find(e[i].x),fy=find(e[i].y);
		if(fx!=fy)
		{
			fa[fx]=fy;
			sum+=e[i].z;
			e[i].in=1;
			addedge(e[i].x,e[i].y,e[i].z);
			addedge(e[i].y,e[i].x,e[i].z);
		}
	}
	dep[1]=1;dfs(1,0);
	for(int i=1;i<=21;i++)
		for(int j=1;j<=n;j++)
		{
			f[i][j]=f[i-1][f[i-1][j]];
			v1[i][j]=max(v1[i-1][j],v1[i-1][f[i-1][j]]);
			v2[i][j]=max(v2[i-1][j],v2[i-1][f[i-1][j]]);
			if(v1[i-1][j]>v1[i-1][f[i-1][j]]) v2[i][j]=max(v2[i][j],v1[i-1][f[i-1][j]]);
            else if(v1[i-1][j]<v1[i-1][f[i-1][j]]) v2[i][j]=max(v2[i][j],v1[i-1][j]);
		}
	int ans=INF;
	for(int i=1;i<=m;i++)
		if(!e[i].in)
		{
			int l=Lca(e[i].x,e[i].y);
			int res=max(get(e[i].x,l,e[i].z),get(e[i].y,l,e[i].z));
			ans=min(ans,e[i].z-res);
		}
	printf("%lld",ans+sum);
	return 0;
}
```

---

## 作者：ysner (赞：4)

题意：求边权第二小的生成树。

首先做一遍最小生成树。

考虑次小生成树对于最小生成树来说只改变一条边.

所以我们可以枚举每一条不在最短路上的边。

用**树上倍增**查出这条边的两个端点在最小生成树上的路径上的边的最大值和次大值（其相当于把这条边连起来,这时形成了一个环，看把最大边还是次大边删掉，能使其形成次小生成树），

然后和当前边计算一下差值，取其小者加上即可.

（当然**树链剖分+ST表**也可）

~~注意开long long和开够空间~~
```
#include<iostream>
#include<cmath>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<algorithm>
#define ll long long
#define re register
#define il inline
#define fp(i,a,b) for(re int i=a;i<=b;i++)
#define fq(i,a,b) for(re int i=a;i>=b;i--)
using namespace std;
const int N=2000005;
ll n,m,cnt,f[N],h[N],vis[N],d[N];
ll ans=1e18,s,ant1[N/10][25],ant2[N/10][25];//ant1存祖先，ant2存最大值
struct xzy
{
  int u,v;ll w;
  bool operator < (const xzy &p)
  {
    return w<p.w;
  }
}a[N];
struct Edge
{
  int to,next;ll w;
}e[N];
il void add(re int u,re int v,re ll w)
{
  e[++cnt]=(Edge){v,h[u],w};h[u]=cnt;
  e[++cnt]=(Edge){u,h[v],w};h[v]=cnt;
}
il ll gi()
{
  re ll x=0,t=1;
  re char ch=getchar();
  while((ch<'0'||ch>'9')&&ch!='-') ch=getchar();
  if(ch=='-') t=-1,ch=getchar();
  while(ch>='0'&&ch<='9') x=x*10+ch-48,ch=getchar();
  return x*t;
}
il int find(re int x){return f[x]==x?x:f[x]=find(f[x]);}
il void kruskal()
{
  ll ans=0;
  fp(i,1,n) f[i]=i;
  sort(a+1,a+1+m);
  fp(i,1,m)
    {
      re int u=find(a[i].u),v=find(a[i].v);
      if(u!=v) f[u]=v,s+=a[i].w,add(a[i].u,a[i].v,a[i].w),vis[i]=1;
    }
}
il void dfs(re int u,re int fa,re int deep)//预处理深度
{
  ant1[u][0]=fa;d[u]=deep;
  for(re int i=h[u];i;i=e[i].next)
    {
      re int v=e[i].to;
      if(v==fa) continue;
      ant2[v][0]=e[i].w;
      dfs(v,u,deep+1);
    }
}
il int getLCA(re int x,re int y)
{
  if(d[x]<d[y]) swap(x,y);
  while(d[x]^d[y]) x=f[x];
  while(x^y) x=f[x],y=f[y];
  return x;
}
il void work()//预处理倍增数组
{
  fp(j,1,20)
    fp(i,1,n)
    {
      ant1[i][j]=ant1[ant1[i][j-1]][j-1];
      ant2[i][j]=max(ant2[ant1[i][j-1]][j-1],ant2[i][j-1]);
    }
}
il ll getmax(re int x,re int y,re ll z)
{
  if(y==-1) return 0;
  if(ant2[x][y]==z) return max(getmax(x,y-1,z),getmax(ant1[x][y-1],y-1,z));
  return ant2[x][y];
}
il ll Query(re int x,re int y,re ll z)//树上倍增找出最大次大值
{
  ll mx=0;
  if(d[x]<d[y]) swap(x,y);
  if(d[x]^d[y])
    fq(i,20,0)
      if(d[ant1[x][i]]>=d[y]) mx=max(mx,getmax(x,i,z)),x=ant1[x][i];
  if(x==y) return z-mx;
  fq(i,20,0)
    if(ant1[x][i]^ant1[y][i])
      {
	mx=max(mx,max(getmax(x,i,z),getmax(y,i,z)));
	x=ant1[x][i],y=ant1[y][i];
      }
  return z-max(mx,max(getmax(x,0,z),getmax(y,0,z)));
}
int main()
{
  n=gi();m=gi();
  fp(i,1,m) a[i].u=gi(),a[i].v=gi(),a[i].w=gi();
  kruskal();//最小生成树
  dfs(1,1,1);
  work();
  fp(i,1,m)
    if(!vis[i])//在最小生成树外的边
      {
	re ll q=Query(a[i].u,a[i].v,a[i].w);
	if(q) ans=min(ans,s+q);
      }
  printf("%lld\n",ans);
  return 0;
}
```



---

## 作者：asuldb (赞：3)

树上的路径怎么能没有树剖

显然，**次小生成树和最小生成树只在一条边上有差距**，于是我们就可以枚举这一条边，将所有边加入最小生成树，之后再来从这些并不是那么小的生成树中找到那个最小的

我们往最小生成树里加入一条边一定会在这条边的两个端点之间形成一个环，**为了让维持树的结构，我们要断开环上的一条边，而为了让得到的新生成树尽量小，于是我们就选择最大的一条边断开，但是为了保证严格次小，在这条边和最大边长度相同时，断开一条严格次大的边**

而从树上找两点之间的最大边和严格次大边，我们显然可以直接上树剖

我们可以维护出每一个到其所在重链顶端的最大边和严格次大边，之后直接倍增往上跳就可以了

直到跳到两个点在同一条重链上的时候，没有办法在像之前那样做了，于是直接用线段树来查询

单次做的复杂度还是$O(logn)$

但是树剖是出了名的小常数，常数大的线段树也只做了一次查询，于是效率非常喜人，在我人傻常数大的情况下依旧跑到了最优解第二

代码
```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>
#include<bitset>
#define mp std::make_pair
#define re register
#define LL long long
#define maxn 100005
#define max(a,b) ((a)>(b)?(a):(b))
#define min(a,b) ((a)<(b)?(a):(b))
#define k1 first
#define k2 second
typedef std::pair<int,int> pii;
struct node
{
	int v,nxt,w;
}e[maxn<<1],a[maxn*3];
std::bitset<maxn*3> ff;
int l[maxn<<2],r[maxn<<2],t1[maxn<<2],t2[maxn<<2];
int head[maxn],deep[maxn],fa[maxn],tot[maxn],to[maxn],b[maxn];
int top[maxn],f[maxn],son[maxn],sum[maxn],d1[maxn],d2[maxn],pre[maxn];
int n,m,num,_;
LL cnt;
void dfs1(int r)
{
	sum[r]=1;
	int maxx=-1;
	for(re int i=head[r];i;i=e[i].nxt)
	if(!deep[e[i].v])
	{
		deep[e[i].v]=deep[r]+1;
		pre[e[i].v]=pre[r]+e[i].w;
		f[e[i].v]=r;
		dfs1(e[i].v);
		sum[r]+=sum[e[i].v];
		if(sum[e[i].v]>maxx) maxx=sum[e[i].v],son[r]=e[i].v;
	}
}
void dfs2(int r,int topf)
{
	top[r]=topf;
	to[r]=++_;
	b[_]=pre[r]-pre[f[r]];
	if(r!=topf)
	{
		if(pre[r]-pre[f[r]]>d1[f[r]]) d2[r]=d1[f[r]];
			else if(pre[r]-pre[f[r]]<d1[f[r]]) d2[r]=max(d2[r],pre[r]-pre[f[r]]);
				else d2[r]=d2[f[r]];
		d1[r]=max(d1[f[r]],pre[r]-pre[f[r]]);
	}
	if(!son[r]) return;
	dfs2(son[r],topf);
	for(re int i=head[r];i;i=e[i].nxt)
	if(deep[e[i].v]>deep[r]&&son[r]!=e[i].v) d1[e[i].v]=-99,d2[e[i].v]=-100,dfs2(e[i].v,e[i].v);
}
inline int find(int x)
{
	if(fa[x]==x) return x;
	return fa[x]=find(fa[x]);
}
inline int read()
{
	char c=getchar();
	int x=0;
	while(c<'0'||c>'9') c=getchar();
	while(c>='0'&&c<='9')
		x=(x<<3)+(x<<1)+c-48,c=getchar();
	return x;
}
inline void add_edge(int x,int y,int z)
{
	e[++num].v=y;
	e[num].w=z;
	e[num].nxt=head[x];
	head[x]=num;
}
inline int cmp(node K,node M)
{
	return K.w<M.w;
}
inline void swap(int &a,int &b) {a^=b,b^=a,a^=b;}
void build(int x,int y,int i)
{
	l[i]=x;r[i]=y;
	if(x==y)
	{
		t1[i]=b[x];
		return;
	}
	int mid=x+y>>1;
	build(x,mid,i<<1),build(mid+1,y,i<<1|1);
	t1[i]=max(t1[i<<1|1],t1[i<<1]);
	if(t1[i<<1|1]>t1[i<<1]) t2[i]=max(t2[i<<1|1],t1[i<<1]);
		else if(t1[i<<1]>t1[i<<1|1]) t2[i]=max(t2[i<<1],t1[i<<1|1]);
			else t2[i]=max(t2[i<<1|1],t2[i<<1]);
}
pii query(int x,int y,int i)
{
	if(x<=l[i]&&y>=r[i]) return mp(t1[i],t2[i]);
	int mid=l[i]+r[i]>>1;
	if(y<=mid) return query(x,y,i<<1);
	if(x>mid) return query(x,y,i<<1|1);
	pii lson=query(x,y,i<<1),rson=query(x,y,i<<1|1);
	pii now;
	now.k1=max(lson.k1,rson.k1);
	if(lson.k1>rson.k1) now.k2=max(lson.k2,rson.k1);
		else if(lson.k1<rson.k1) now.k2=max(lson.k1,rson.k2);
			else now.k2=max(rson.k2,lson.k2);
	return now;
}
int main()
{
	n=read(),m=read();
	for(re int i=1;i<=m;++i)
		a[i].v=read(),a[i].nxt=read(),a[i].w=read();
	std::sort(a+1,a+m+1,cmp);
	for(re int i=1;i<=n;++i) fa[i]=i,tot[i]=1;
	int K=0;
	for(re int i=1;i<=m;++i)
	{
		int xx=find(a[i].v);
		int yy=find(a[i].nxt);
		if(xx!=yy)
		{
			K++;
			ff[i]=1;
			add_edge(a[i].v,a[i].nxt,a[i].w);
			add_edge(a[i].nxt,a[i].v,a[i].w);
			if(tot[xx]>tot[yy]) fa[yy]=xx,tot[xx]+=tot[yy];
			else fa[xx]=yy,tot[yy]+=tot[xx];
			cnt+=a[i].w;
		}
		if(K==n-1) break;
	}
	deep[1]=1;
	dfs1(1);
	d1[1]=-99,d2[1]=-100;
	dfs2(1,1);
	build(1,n,1);
	LL ans=9999999999999999;
	for(re int i=m;i;--i)
	if(!ff[i])
	{
		int m1=0,m2=-1;
		int x=a[i].v;
		int y=a[i].nxt;
		while(top[x]!=top[y])
		{
			if(deep[top[x]]<deep[top[y]]) swap(x,y);
			if(d1[x]<m1) m2=max(m2,d1[x]);
				else if(d1[x]>m1) m2=m1;
					else m2=max(m2,d2[x]);
			m1=max(m1,d1[x]);
			if(pre[x]-pre[f[x]]<m1) m2=max(m2,pre[x]-pre[f[x]]);
				else if(pre[x]-pre[f[x]]>m1) m2=m1;
			m1=max(m1,pre[x]-pre[f[x]]);
			x=f[top[x]];
		}
		if(x!=y)
		{
			if(deep[x]>deep[y]) swap(x,y);
			pii now=query(to[x]+1,to[y],1);
			if(now.k1>m1) m2=m1;
				else if(now.k1<m1) m2=max(m2,now.k1);
					else m2=max(m2,now.k2);
			m1=max(m1,now.k1);
		}
		if(a[i].w<m1) continue;
		if(a[i].w>m1) ans=min(ans,cnt+a[i].w-m1);
		if(a[i].w==m1&&m2) ans=min(ans,cnt+a[i].w-m2);
	}
	std::cout<<ans;
	return 0;
}
```

---

## 作者：stdlifg (赞：2)

**严格次小生成树**


首先看看如果不严格我们怎么办。

[非严格次小生成树怎么做](https://zhuanlan.zhihu.com/p/24950356)


由此，我们发现一个结论，求非严格次小生成树，只需要先用kruskal算法求得最小生成树，然后暴力枚举非树边，替换路径最大边即可。


那要是严格呢？


我们发现如果是严格的次小生成树，那么将一条边替换另一条时，这两条边的权值一定**不相同**


但是，我们知道，**替换边**肯定大于等于**被替换边**（因为如果**替换边**小于**被替换边**，就存在一颗包含**替换边**而不包含**被替换边**的一棵权值更小的生成树，原树就不是最小生成树了）


所以替换边要么等于路径上最大的边，要么比最大的边还大。


利用这个性质，我们只需要维护路径中的最大值和次大值，当**替换边**等于路径上的最大值，我们直接换用严格次大值即可。


**一些细节**


1.我维护两点之间路径最大值用的是LCT，但是正解是LCA。LCT必须要开O2才能跑过去。


2.数组要开足够大，最后统计答案时要开long long,不然会爆int



**我的代码**
```cpp
#include <algorithm>
#include <iostream>
#include <cstring>
#include <cstdio>
#include <vector>
#include <queue>
#define rg register int
#define ll long long
#define RG register
#define il inline
using namespace std;

il ll gi() {
    RG ll x=0;rg o=0;RG char ch=getchar();
    while(ch!='-'&&(ch<'0'||'9'<ch)) ch=getchar();
    if(ch=='-') o=1,ch=getchar();
    while('0'<=ch&&ch<='9') x=(x<<1)+(x<<3)+ch-'0',ch=getchar();
    return o?-x:x;
}
int n,m;
#define SZ 7000010

struct Edge {int a,b;ll w;}e[SZ];
bool cmp(Edge a,Edge b) {return a.w<b.w;}

#define lson tr[x].ch[0]
#define rson tr[x].ch[1]
struct Splaytree{int fa,ch[2],rev,mxp,mxp2;}tr[SZ];
il void pushup(rg x)
{
    tr[x].mxp=x; tr[x].mxp2=0;
    if(e[tr[lson].mxp].w>e[tr[x].mxp].w) tr[x].mxp=tr[lson].mxp;
    if(e[tr[rson].mxp].w>e[tr[x].mxp].w) tr[x].mxp=tr[rson].mxp;
    // 维护 最大
    if(e[tr[lson].mxp].w!=e[tr[x].mxp].w && (e[tr[lson].mxp].w>e[tr[x].mxp].w||!tr[x].mxp2) ) tr[x].mxp2=tr[lson].mxp;
    if(e[tr[lson].mxp2].w!=e[tr[x].mxp].w && (e[tr[lson].mxp2].w>e[tr[x].mxp].w||!tr[x].mxp2) ) tr[x].mxp2=tr[lson].mxp2;    
    if(e[tr[rson].mxp].w!=e[tr[x].mxp].w && (e[tr[rson].mxp].w>e[tr[x].mxp].w||!tr[x].mxp2) ) tr[x].mxp2=tr[rson].mxp;
    if(e[tr[rson].mxp2].w!=e[tr[x].mxp].w && (e[tr[rson].mxp2].w>e[tr[x].mxp].w||!tr[x].mxp2) ) tr[x].mxp2=tr[rson].mxp2;        
    // 维护严格次大
}
il void pushdown(rg x)
{
    if(tr[x].rev)
    {
        tr[lson].rev^=1,tr[rson].rev^=1;
        swap(lson,rson),tr[x].rev=0;
    }
}
il bool isroot(rg x)
{
    return tr[tr[x].fa].ch[0]!=x && tr[tr[x].fa].ch[1]!=x;
}
il void rotate(rg x)
{
    rg y=tr[x].fa,z=tr[y].fa;
    rg k=tr[y].ch[1]==x;
    if(!isroot(y)) tr[z].ch[y==tr[z].ch[1]]=x;tr[x].fa=z;
    tr[y].ch[k]=tr[x].ch[k^1],tr[tr[x].ch[k^1]].fa=y;
    tr[x].ch[k^1]=y,tr[y].fa=x;
    pushup(y),pushup(x);
}
int stk[SZ],top; 
il void splay(rg x)
{
    stk[top=1]=x;
    for(rg i=x;!isroot(i);i=tr[i].fa) stk[++top]=tr[i].fa;
    for(;top;--top) pushdown(stk[top]);
    while(!isroot(x))
    {
        rg y=tr[x].fa,z=tr[y].fa;
        if(!isroot(y))
         (tr[y].ch[0]==x)^(tr[z].ch[0]==y)?rotate(x):rotate(y);
        rotate(x);
    }
}
il void access(rg x) {for(rg y=0;x;y=x,x=tr[x].fa)splay(x),rson=y,pushup(x);}
il void makeroot(rg x) {access(x);splay(x);tr[x].rev^=1;}
il int findroot(rg x) {access(x);splay(x);while(lson) x=lson;return x;}
il void split(rg x,rg y) {makeroot(x);access(y);splay(y);}
il int query(rg x,rg y) {split(x,y);return tr[y].mxp;} //求x 到 y最大值 
il int query2(rg x,rg y) {split(x,y);return tr[y].mxp2;} // 求x 到 y严格次大值
il void link(rg x,rg y) {makeroot(x);tr[x].fa=y;}
il void cut(rg x,rg y) {split(x,y);if(tr[y].ch[0]==x)tr[y].ch[0]=tr[x].fa=0;}
int fa[SZ];int find_fa(rg x) {if(x!=fa[x]) fa[x]=find_fa(fa[x]);return fa[x];} //一行并查集
bool check[SZ];

int main()
{

    n=gi(),m=gi();
    for(rg i=1;i<=m;++i) e[i]=(Edge){gi(),gi(),gi()};
    // 先求一遍最小生成树 ans 记录最小生成树边的大小
    RG ll ans=0;
    sort(e+1,e+1+m,cmp);    
    for(rg i=1;i<=n;++i) fa[i]=i; // 初始化并查集
    for(rg f1,f2,i=1;i<=m;++i)
    {
        f1=find_fa(e[i].a);
        f2=find_fa(e[i].b);
        if(f1!=f2)
        {
            check[i]=1; // check=1 表示最小生成树中有这一条边 反之
            fa[f1]=f2;
            ans+=e[i].w;
            link(e[i].a+m,i);
            link(e[i].b+m,i);
        }
    }

#define INF 2147483647
#define Getmin(a,b) (a)=(a)>(b)?(b):(a) 

    RG ll Ans=INF;
    for(rg f1,f2,i=1;i<=m;++i)
    {
        if(check[i]) continue; //我们选择不再最小生成树上的边
        rg mxp=query(e[i].a+m,e[i].b+m);
        if(e[mxp].w==e[i].w)
        {
            rg mxp2=query2(e[i].a+m,e[i].b+m);
            if(!mxp2 || e[mxp2].w==e[mxp].w) continue;
            Getmin(Ans,e[i].w-e[mxp2].w);
        }
        else Getmin(Ans,e[i].w-e[mxp].w);
    }

    cout<<ans+Ans;
    return 0;
}

```

---

## 作者：C20203030 (赞：1)

~~其实这并不是一个模板题~~ 

## 一、题目

[点此看题](https://www.luogu.org/problem/P4180)

## 二、解法

发现次小生成树和最小生成树只有一条边的差异，为什么呢？考虑每一条不在最小生成树上的边如果加上去的增量，发现它是非负的，要生成次小生成树，肯定要最小化增量，所以只替换一条边是最优的。

考虑每一条边去替换树上的边，先加入这条边，会与树形成一个环，发现环上的最大边就是我们替换的树边，但由于题目要求严格次小，就不能取和加入边权值相等的树边，暴力跑即可。

考虑对暴力优化，发现找最大边的过程本质就是一个$Lca$，我们用倍增维护最大值和次大值，然后跑$Lca$就行了，时间复杂度$O(n\log n)$。


```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#define int long long
using namespace std;
const int MAXN = 100005;
const int inf = (1ll<<62);
int read()
{
    int x=0,flag=1;char c;
    while((c=getchar())<'0' || c>'9') if(c=='-') flag=-1;
    while(c>='0' && c<='9') x=(x<<3)+(x<<1)+(c^48),c=getchar();
    return x*flag;
}
int n,m,tot,ans=inf,f[MAXN],p[MAXN],dep[MAXN];
int fa[MAXN][20],Max[MAXN][20],sub[MAXN][20];
long long mst;
struct edge
{
    int v,c,next;
}e[2*MAXN];
struct node
{
    int u,v,c;
    bool operator < (const node &x) const
    {
        return c<x.c;
    }
}a[3*MAXN];
int op(int a,int b,int lim)
{
    if(a>=lim) return b>=lim?0:b;
    if(b>=lim) return a>=lim?0:a;
    return max(a,b);
}
int findSet(int x)
{
    if(x^p[x]) p[x]=findSet(p[x]);
    return p[x];
}
void MST()
{
    sort(a+1,a+1+m);
    for(int i=1;i<=n;i++)
        p[i]=i;
    for(int i=1;i<=m;i++)
    {
        int u=a[i].u,v=a[i].v,c=a[i].c,x=findSet(u),y=findSet(v);
        if(x==y) continue;
        e[++tot]=edge{v,c,f[u]},f[u]=tot;
        e[++tot]=edge{u,c,f[v]},f[v]=tot;
        mst+=c;
        p[x]=y;
    }
}
void dfs(int u,int par)
{
    fa[u][0]=par;
    dep[u]=dep[par]+1;
    for(int i=1;i<20;i++)
    {
        int pos=fa[u][i-1];
        Max[u][i]=max(Max[u][i-1],Max[pos][i-1]);
        sub[u][i]=max(sub[u][i-1],sub[pos][i-1]);
        fa[u][i]=fa[pos][i-1];
        if(Max[u][i-1]^Max[pos][i-1])
            sub[u][i]=max(sub[u][i],min(Max[u][i-1],Max[pos][i-1]));
    }
    for(int i=f[u];i;i=e[i].next)
        if(e[i].v^par)
        {
            Max[e[i].v][0]=e[i].c;
            sub[e[i].v][0]=-inf;
            dfs(e[i].v,u);
        }
}
void updata(int &x,int u,int i,int lim)
{
    x=op(x,Max[u][i],lim);
    x=op(x,sub[u][i],lim);
}
int lca(int u,int v,int lim)
{
    int res=-inf;
    for(int i=19;i>=0;i--)
    {
        if(dep[fa[u][i]]>=dep[v]) updata(res,u,i,lim),u=fa[u][i];
        if(dep[fa[v][i]]>=dep[u]) updata(res,v,i,lim),v=fa[v][i];
    }
    if(u==v) return res;
    for(int i=19;i>=0;i--)
        if(fa[u][i]^fa[v][i])
        {
            updata(res,u,i,lim);updata(res,v,i,lim);
            u=fa[u][i],v=fa[v][i];
        }
    updata(res,u,0,lim);updata(res,v,0,lim);
    return res;
}
signed main()
{
    n=read();m=read();
    for(int i=1;i<=m;i++)
    {
        int u=read(),v=read(),c=read();
        a[i]=node{u,v,c};
    }
    MST();
    dfs(1,0);
    for(int i=1;i<=m;i++)
    {
        int val=lca(a[i].u,a[i].v,a[i].c);
        if(val!=-inf) ans=min(ans,a[i].c-val);
    }
    printf("%lld\n",ans+mst);
}

```

**tips**

1、$lca$做二进制分解是要从大到小。

2、注意要开$long long$。

3、极大值用$(1<<62)$。


---

## 作者：crashed (赞：1)

# 题目
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[点这里](https://www.luogu.org/problem/P4180)看题目。  
# 分析
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;很容易想到，次小生成树和最小生成树之间在没有边权相同的边情况下有且仅有一条边不同。如果存在多条边不同的话就肯定不是次小的了。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以我们只需要考虑改的边到底是哪一条就可以了。先求出最小生成树，然后考虑加入一条新边$(u,v,w)$，则原树上$(u,lca(u,v),v)$的路径会变成一个环。显然，我们必须要在这个环上删除一条边重新变成一棵树。如果这个环上的最长边删去之后生成树的权值和没变，我们就要删除次长边；否则就删去最长边。假如我们可以快速地求出生成树中一条路径$(u,lca(u,v),v)$的最长边和次长边，我们扫一遍就可以知道答案了。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;考虑快速求出最长边和次长边。我们模拟倍增，求出从某个点$u$上跳$2^j$步经过的边权的最大值和次大值，预处理时间同样是$O(n\log_2n)$；而查询的时候类似于$LCA$的上跳，中间更新出最大值和次大值就可以了，单次时间$O(\log_2n)$。  
# 代码
```cpp
#include <cmath>
#include <cstdio>
#include <utility>
#include <algorithm>
using namespace std; 

typedef long long LL;

const int INF = 0x3f3f3f3f;
const int MAXN = 1e5 + 5, MAXM = 3e5 + 5, MAXLOG = 20;

template<typename _T>
void read( _T &x )
{
	x = 0;char s = getchar();int f = 1;
	while( s > '9' || s < '0' ){if( s == '-' ) f = -1; s = getchar();}
	while( s >= '0' && s <= '9' ){x = ( x << 3 ) + ( x << 1 ) + ( s - '0' ), s = getchar();}
	x *= f;
}

template<typename _T>
void write( _T x )
{
	if( x < 0 ){ putchar( '-' ); x = ( ~ x ) + 1; }
	if( 9 < x ){ write( x / 10 ); }
	putchar( x % 10 + '0' );
}

template<typename _T>
_T MAX( const _T a, const _T b )
{
	return a > b ? a : b;
}

template<typename _T>
_T MIN( const _T a, const _T b )
{
	return a < b ? a : b;
}

typedef pair<int, int> RT;

struct edge
{
	int to, nxt, w;
}Graph[MAXN * 2];

struct Edge
{
	int from, to, w;
	bool operator < ( const Edge & other ) const { return w < other.w; }
}E[MAXM];

RT maxW[MAXN][MAXLOG];
int f[MAXN][MAXLOG];
int fa[MAXN], dep[MAXN];
int head[MAXN];
int N, M, cnt, lg2;
bool used[MAXM];

void addEdge( const int from, const int to, const int W )
{
	cnt ++;
	Graph[cnt].w = W;
	Graph[cnt].to = to;
	Graph[cnt].nxt = head[from];
	head[from] = cnt;
}

void makeSet( const int siz ) { for( int i = 1 ; i <= siz ; i ++ ) fa[i] = i; }
int findSet( const int u ) { return fa[u] ^ u ? ( fa[u] = findSet( fa[u] ) ) : fa[u] ; }
bool unionSet( const int u, const int v )
{
	int r1 = findSet( u ), r2 = findSet( v );
	if( r1 == r2 ) return false;
	fa[r1] = r2;
	return true;
}

void DFS( const int u, const int fat )
{
	f[u][0] = fat;
	dep[u] = dep[fat] + 1;
	int v;
	for( int i = head[u] ; i ; i = Graph[i].nxt )
	{
		v = Graph[i].to;
		if( v ^ fat )
			maxW[v][0] = RT( Graph[i].w, -INF ), 
			DFS( v, u );
	}
}

void maintain( RT &a, const int val )
{
	if( a.first < val ) a.second = a.first, a.first = val;
	else if( a.second < val ) a.second = val;
}

void init()
{
	for( int j = 1 ; j <= lg2 ; j ++ )
		for( int i = 1 ; i <= N ; i ++ )
		{
			f[i][j] = f[f[i][j - 1]][j - 1];
			maxW[i][j] = RT( -INF, -INF );
			maintain( maxW[i][j], maxW[i][j - 1].first ), maintain( maxW[i][j], maxW[i][j - 1].second ),
			maintain( maxW[i][j], maxW[f[i][j - 1]][j - 1].first ), maintain( maxW[i][j], maxW[f[i][j - 1]][j - 1].second );
		}
}

void balance( int &u, RT &a, const int steps )
{
	for( int i = 0 ; ( 1 << i ) <= steps ; i ++ )
		if( steps & ( 1 << i ) )
			maintain( a, maxW[u][i].first ), 
			maintain( a, maxW[u][i].second ), 
			u = f[u][i];
}

RT query( int u, int v )
{
	RT r = RT( -INF, -INF );
	if( dep[u] > dep[v] ) balance( u, r, dep[u] - dep[v] );
	if( dep[v] > dep[u] ) balance( v, r, dep[v] - dep[u] );
	if( u == v ) return r;
	for( int i = lg2 ; ~ i ; i -- )
		if( f[u][i] ^ f[v][i] )
			maintain( r, maxW[u][i].first ), maintain( r, maxW[u][i].second ), 
			maintain( r, maxW[v][i].first ), maintain( r, maxW[v][i].second ),
			u = f[u][i], v = f[v][i];
	maintain( r, maxW[u][0].first ), maintain( r, maxW[u][0].second );
	maintain( r, maxW[v][0].first ), maintain( r, maxW[v][0].second );
	return r;
}

int main()
{
	read( N ), read( M );
	lg2 = log2( N );
	for( int i = 1 ; i <= M ; i ++ )
		read( E[i].from ), read( E[i].to ), read( E[i].w );
	std :: sort( E + 1, E + 1 + M );
	makeSet( N );
	LL MST = 0;
	int tot = 0;
	for( int i = 1 ; i <= M ; i ++ )
	{
		if( unionSet( E[i].from, E[i].to ) )
			MST += E[i].w, tot ++, used[i] = true,
			addEdge( E[i].from, E[i].to, E[i].w ), addEdge( E[i].to, E[i].from, E[i].w );
		if( tot == N - 1 ) break;
	}
	DFS( 1, 0 );
	init();
	RT tmp;
	LL res = 0x3f3f3f3f3f3f3f3f;
	for( int i = 1 ; i <= M ; i ++ )
		if( ! used[i] )
		{
			tmp = query( E[i].from, E[i].to );
			if( MST - tmp.first + E[i].w > MST ) res = MIN( res, MST - tmp.first + E[i].w );
			if( MST - tmp.second + E[i].w > MST ) res = MIN( res, MST - tmp.second + E[i].w );
		}
	write( res ), putchar( '\n' );
	return 0;
}
```

---

## 作者：lengxinjy (赞：1)

看到写LCT的人比较少啊……就来一波LCT吧

LCT十分擅长解决树的动态加边、删边问题以及与生成树有关的问题，比如此题。

现在假设我们已经求出了一张图的最小生成树，那么我们应该如何调整才能求出严格次小生成树呢？

我们注意到，一定存在一棵严格次小生成树，使得这棵次小生成树与最小生成树只有一条边的差别。~~（至于咋注意到的本蒟蒻也不会）~~

所以，求出最小生成树后，我们可以枚举每一条不在生成树上的边，来尝试将这条边加入生成树。由于此时生成树的形态已经完整，再加入一条边后，树上必定会形成环，所以我们应该尝试用这条新边$e_{now}$替换这两点间路径上边权最大的一条边$e_{max}$（因为原树已经是最小生成树，所以一定有$v[e_{now}]\geq v[e_{max}]$）。这里需要注意一点，由于可能存在$v[e_{now}]= v[e_{max}]$的情况，而本题要求的是严格次小生成树，因此当这种情况出现时，我们应该替换的不是$e_{max}$而是路径上边权严格次小的边$e_{max2}$。每次尝试后求出权值，最后取所有替换方案权值的最小值即为答案。

到这里，实现方法已经很清楚了。用一棵LCT维护子树的最大值和严格次大值的节点编号$mx$及$mx2$，先对所有边按权值排序，求出MST及其权值$ans$后，枚举每一条非MST边，每次执行$split(e[i].u,e[i].v)$，那么当前替换后的答案就是$ans-v[mx[e[i].v]]+e[i].w$或$ans-v[mx2[e[i].v]]+e[i].w$。更新答案时取$\min$即可。

这里还有一个小问题，如何维护严格次大值？我们发现，对于一个节点$x$，设其左右子节点$ls$和$rs$，那么能成为$mx2[x]$的点就只有五种可能:$x,mx[ls],mx[rs],mx2[ls],mx2[rs]$。逐个判断即可。

$update$代码：
```cpp
void update(int x)
{
	mx[x]=x;
	if(son[0][x]&&v[mx[son[0][x]]]>v[mx[x]])mx2[x]=mx[x],mx[x]=mx[son[0][x]];
	else if(son[0][x]&&v[mx[son[0][x]]]>v[mx2[x]]&&v[mx[son[0][x]]]<v[mx[x]])mx2[x]=mx[son[0][x]];
	if(son[0][x]&&v[mx2[son[0][x]]]>v[mx2[x]]&&v[mx2[son[0][x]]]<v[mx[x]])mx2[x]=mx2[son[0][x]];
	if(son[1][x]&&v[mx[son[1][x]]]>v[mx[x]])mx2[x]=mx[x],mx[x]=mx[son[1][x]];
	else if(son[1][x]&&v[mx[son[1][x]]]>v[mx2[x]]&&v[mx[son[1][x]]]<v[mx[x]])mx2[x]=mx[son[1][x]];
	if(son[1][x]&&v[mx2[son[1][x]]]>v[mx2[x]]&&v[mx2[son[1][x]]]<v[mx[x]])mx2[x]=mx2[son[1][x]];
}
```
（这里感觉有些繁琐，如果有大佬有更好的方法欢迎提出）

另外还有一个常数优化。我们没有必要先求出最小生成树后再枚举替换的边，而可以直接扫一遍所有的边，用并查集维护点的连通性。若两点不连通，就直接$link$并且将最小生成树的权值$ans++$；若两点已连通，则用上面的方法尝试替换并更新严格次小生成树与最小生成树的权值之差$delta$。最后输出$ans+delta$即可。

如果还是被卡常怎么办？吸氧大法好……

贴代码
```cpp
#include<bits/stdc++.h>
#define int long long
#define ull unsigned long long
#define ff first
#define ss second
#define rep(i,a,b) for(int i=(a);i<=(b);i++)
#define per(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int INF=2147483647;
inline int read()
{
	int x=0,k=1;char c=getchar();
	while(c<'0'||c>'9'){if(c=='-')k=-1;c=getchar();}
	while(c>='0'&&c<='9'){x=(x<<3)+(x<<1)+(c^48);c=getchar();}
	return x*k;
}
int fa[400086],son[2][400086],mx[400086],mx2[400086],v[400086],f[100086],n,m,x,y,k,num,cnt,now,ans;
bool r[400086];
struct edge{
	int u,v,w;
	bool operator<(edge x)const
	{
		return w<x.w;
	}
}e[300086];
bool isroot(int x)
{
	return (son[0][fa[x]]!=x)&&(son[1][fa[x]]!=x);
}
void rvers(int x)
{
	r[x]^=1;
	swap(son[0][x],son[1][x]);
}
void pushdown(int x)
{
	if(!r[x])return ;
	if(son[0][x])rvers(son[0][x]);
	if(son[1][x])rvers(son[1][x]);
	r[x]=0;
}
void update(int x)
{
	mx[x]=x;
	if(son[0][x]&&v[mx[son[0][x]]]>v[mx[x]])mx2[x]=mx[x],mx[x]=mx[son[0][x]];
	else if(son[0][x]&&v[mx[son[0][x]]]>v[mx2[x]]&&v[mx[son[0][x]]]<v[mx[x]])mx2[x]=mx[son[0][x]];
	if(son[0][x]&&v[mx2[son[0][x]]]>v[mx2[x]]&&v[mx2[son[0][x]]]<v[mx[x]])mx2[x]=mx2[son[0][x]];
	if(son[1][x]&&v[mx[son[1][x]]]>v[mx[x]])mx2[x]=mx[x],mx[x]=mx[son[1][x]];
	else if(son[1][x]&&v[mx[son[1][x]]]>v[mx2[x]]&&v[mx[son[1][x]]]<v[mx[x]])mx2[x]=mx[son[1][x]];
	if(son[1][x]&&v[mx2[son[1][x]]]>v[mx2[x]]&&v[mx2[son[1][x]]]<v[mx[x]])mx2[x]=mx2[son[1][x]];
}
void rotate(int x)
{
	int y=fa[x],z=fa[y];
	bool t=(son[1][y]==x);
	if(!isroot(y))son[son[1][z]==y][z]=x;
	fa[x]=z;
	fa[y]=x;
	son[t][y]=son[!t][x];
	son[!t][x]=y;
	if(son[t][y])fa[son[t][y]]=y;
	update(y);
	update(x);
}
void pathdown(int x)
{
	if(!isroot(x))pathdown(fa[x]);
	pushdown(x);
}
void splay(int x)
{
	pathdown(x);
	for( ;!isroot(x);rotate(x))
	if(!isroot(fa[x]))(son[0][fa[x]]==x)^(son[0][fa[fa[x]]]==fa[x])?rotate(x):rotate(fa[x]);
}
void access(int x)
{
	int y=0;
	while(x)
	{
		splay(x);
		son[1][x]=y;
		update(x);
		y=x;
		x=fa[x];
	}
}
void makeroot(int x)
{
	access(x);
	splay(x);
	rvers(x);
}
void split(int x,int y)
{
	makeroot(x);
	access(y);
	splay(y);
}
void link(int x,int y)
{
	split(x,y);
	fa[x]=y;
}
void cut(int x,int y)
{
	split(x,y);
	fa[x]=son[0][y]=0;
	update(y);
}
int query(int x,int y)
{
	split(x,y);
	return mx[y];
}
int query2(int x,int y)
{
	split(x,y);
	return mx2[y];
}
int find(int x)
{
	if(x!=f[x])return f[x]=find(f[x]);
	return f[x];
}
void merge(int x,int y)
{
	int fx=find(x),fy=find(y);
	if(fx==fy)return ;
	f[fx]=fy;
}
signed main()
{
	n=read(),m=read();
	rep(i,1,n)f[i]=i;
	rep(i,1,m)
	{
		x=read(),y=read(),k=read();
		if(x>y)swap(x,y);
		e[i].u=x,e[i].v=y,e[i].w=k;
	}
	sort(e+1,e+1+m);
	int delta=0x7f7f7f7f7f7f7f7f;
	rep(i,1,m)
	{
		x=e[i].u,y=e[i].v,k=e[i].w;
		int fx=find(x),fy=find(y);
		if(fx==fy)
		{
			int w=query(x,y),w2=query2(x,y);
			if(v[w]<k)delta=min(delta,k-v[w]);
			else delta=min(delta,k-v[w2]);
		}
		else
		{
			merge(x,y);
			v[i+n]=k;
			link(x,i+n),link(i+n,y);
			ans+=k;
		}
	}
	printf("%lld",ans+delta);
	return 0;
}
```


---

## 作者：MLEAutoMaton (赞：1)

## 前言

首先需要了解什么是最小生成树,还要知道什么是倍增(求Lca).

上面的东西如果了解了,就可以开始进入学习的路途了!!



## 1 算法框架

### 1.1 整体思路

用不是最小生成树上的边去更新答案.



### 1.2 具体维护

对于每一个倍增跳上去的,要维护两个东西:

- 路径的边权最大值.
- 路径的边权次大值



## 2 具体实现

我们考虑一下对于每一条边(不在最小生成树上),如果要把它加入答案,如何更新?

MST-路径最大值+边权.

~~然后这个东西就可以很愉快地解决了...~~

其实不是的,如果题目求的是次小生成树,这题就没了,但是题目要求的是严格次小生成树,怎么办呢?

考虑一下,如果要这样子,我们更新答案就不能和MST相等,然后依旧可以很愉快地解决了!!!

```cpp
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<math.h>
#include<algorithm>
using namespace std;
#define int long long
const int N=100010,M=300010,Inf=2e18+10;
struct node{
    int u,v,w;
}e[M];
int fa[N],front[N],to[N<<1],nxt[N<<1],w[N<<1],MST,cnt,n,m,k,flag[M];
int f[N][20],Min[N][20],Max[N][20],dep[N];
int find(int x){
    if(fa[x]!=x)fa[x]=find(fa[x]);
    return fa[x];
}
void Add(int u,int v,int W){
    to[++cnt]=v;nxt[cnt]=front[u];w[cnt]=W;
    front[u]=cnt;
}
bool cmp(node a,node b){
    return a.w<b.w;
}
void dfs(int u,int Fa){
    f[u][0]=Fa;
    for(int i=front[u];i;i=nxt[i]){
        int v=to[i];
        if(v!=Fa){
            dep[v]=dep[u]+1ll;
            Max[v][0]=w[i];
            Min[v][0]=-Inf;
            dfs(v,u);
        }
    }
}
int LCA(int u,int v){
    if(dep[u]<dep[v])swap(u,v);
    for(int i=18;~i;i--)
        if(dep[f[u][i]]>=dep[v])
            u=f[u][i];
    if(u==v)return u;
    for(int i=18;~i;i--)
        if(f[u][i]!=f[v][i])
            u=f[u][i],v=f[v][i];
    return f[u][0];
}
int qmax(int u,int v,int W){
    int ans=-Inf;
    for(int i=18;~i;i--)
        if(dep[f[u][i]]>=dep[v]){
            if(W!=Max[u][i])ans=max(ans,Max[u][i]);
            else ans=max(ans,Min[u][i]);
            u=f[u][i];
        }
    return ans;
}
signed main(){
    scanf("%lld%lld",&n,&m);
    for(int i=1;i<=n;i++)fa[i]=i;
    for(int i=1;i<=m;i++){
        int u,v,W;scanf("%lld%lld%lld",&u,&v,&W);
        e[i]=(node){u,v,W};
    }
    sort(e+1,e+m+1,cmp);
    for(int i=1;i<=m;i++){
        int u=find(e[i].u),v=find(e[i].v);
        if(u!=v){
            flag[i]=1;
            Add(e[i].u,e[i].v,e[i].w);
            Add(e[i].v,e[i].u,e[i].w);
            fa[v]=u;MST+=e[i].w;
            k++;if(k==n-1)break;
        }
    }
    Min[1][0]=-Inf;
    dep[1]=1;
    dfs(1,-1);
    for(int j=1;j<=18;j++)
        for(int i=1;i<=n;i++){
            f[i][j]=f[f[i][j-1]][j-1];
            Max[i][j]=max(Max[i][j-1],Max[f[i][j-1]][j-1]);
            Min[i][j]=max(Min[i][j-1],Min[f[i][j-1]][j-1]);
            if(Max[i][j-1]>Max[f[i][j-1]][j-1])
                Min[i][j]=max(Min[i][j],Max[f[i][j-1]][j-1]);
            else if(Max[i][j-1]<Max[f[i][j-1]][j-1])
                Min[i][j]=max(Min[i][j],Max[i][j-1]);
        }
    int ans=Inf;
    for(int i=1;i<=m;i++)
        if(!flag[i]){
            int u=e[i].u,v=e[i].v;
            int lca=LCA(u,v);
            int Maxu=qmax(u,lca,e[i].w),Maxv=qmax(v,lca,e[i].w);
            ans=min(ans,MST-max(Maxu,Maxv)+e[i].w);
        }
    printf("%lld\n",ans);
    return 0;
}
```

---

## 作者：Sangber (赞：1)

### 题目描述

小$C$最近学了很多最小生成树的算法，$Prim$算法、$Kruskal$算法、消圈算法等等。正当小$C$洋洋得意之时，小$P$又来泼小$C$冷水了。小$P$说，让小$C$求出一个无向图的次小生成树，而且这个次小生成树还得是严格次小的，也就是说：如果最小生成树选择的边集是$E_M$，严格次小生成树选择的边集是$E_S$，那么需要满足：(value(e)表示边e的权值) 

这下小 C 蒙了，他找到了你，希望你帮他解决这个问题。  
输入输出格式  
输入格式：  

第一行包含两个整数$N$和$M$，表示无向图的点数与边数。接下来$M$行，每行 3个数$x\ y\ z$ 表示，点$x$和点$y$之间有一条边，边的权值为$z$。  

输出格式：  

包含一行，仅一个数，表示严格次小生成树的边权和。  
(数据保证必定存在严格次小生成树)  

说明:  
数据中无向图无自环;  
$50\%$ 的数据$N≤2000\ M≤3000$;  
$80\%$的数据$N≤50000\ M≤100000$;  
$100\%$ 的数据$N≤100000\ M≤300000$;  
边权值非负且不超过$10^9$ 。

------------
### 基本思路：  
先求出最小生成树，在建树时，将所有的边划分为两个集合（树边$E_T$和非树边$E_K$）  
之后考虑将$\forall\ e(u,v)\in E_K$分别加入到最小生成树上去，将树上$u,v$之间的最大边权$Maxvalue(u,v)$与$value(e)$作比较：  
+  若$Maxvalue(u,v)\ne value(e)$ 则得到$MST^\prime$的一个候选值$MST-Maxvalue(u,v)+value(e)$
+  若$Maxvalue(u,v)= value(e)$ 则得到$MST^\prime$的一个候选值$MST-Maxvalue^\prime(u,v)+value(e)$  
（其中$MST^\prime$为次小生成树，$Maxvalue^\prime(u,v)$为树上$u,v$间的次大边权）  

思路确定下来之后，最严峻的问题就是：**如何快速求出$Maxvalue(u,v)$和$Maxvalue^\prime(u,v)$?**  

---
### 树上倍增$+LCA$
对所建立的最小生成树进行树上倍增，各元素意义如下：

+  $f[\ i\ ][\ j\ ]$表示树上编号为$i$的点向上跳$2^j$步所到达的祖先编号
+  $maxg[\ i\ ][\ j\ ]$表示树上编号为$i$的点以上长度为$2^j$的树上路径的**最大**边权值
+  $ming[\ i\ ][\ j\ ]$表示树上编号为$i$的点以上长度为$2^j$的树上路径的**次大**边权值  

在求处理树上路径$(u,v)$时先求出$LCA(u,v)$，再分为$(u,LCA(u,v))$和$(v,LCA(u,v))$两段处理，取两次答案的较大值作为当前的目标替换值（具体实现见代码中的$qmax$函数）  

---

### 细节注意事项
个人来看，以下几点是**非常重要**滴：
1. $Kruskal$的构树（最基本的一步，千万不能出岔子）
1. 维护树上路径的边权最大值与次大值（**重中之重！！！**）  
千万要注意$maxg$和$ming$的转移,不然就有可能像我一样一直WA第一个点$...$
1. $LCA$辅助查询树上路径$(u,v)$之间的最大边权  
1. 开$long\ long$ 啊（不开$long\ long$见祖宗$...$）  

---

### 参考代码  
下面是蒟蒻的代码（~~欢迎大佬来踩~~）  
``` cpp
//由于本地调试的时候忘了开long long，所以所有的int都是long long...qwq
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<algorithm>
typedef long long LL;
const LL INF=2147483647000000;//INF 开大
// 空间都开大点
const LL MAXN=400010;
const LL MAXM=900010;
using namespace std;
inline LL read(){//读优
	LL s=0;bool f=false;char c=getchar();
	while(c<'0'||c>'9')f|=(c=='-'),c=getchar();
	while(c>='0'&&c<='9')s=(s<<3)+(s<<1)+(c^48),c=getchar();
	return (f)?(-s):(s);
}
struct edge{
	LL u,v,w;bool bt;//bt为false则说明为非树边，为真则为树边
	void scan(){u=read(),v=read(),w=read();}
	bool operator<(const edge&obj)const{return w<obj.w;}
}e[MAXM];
LL tot,head[MAXN],nxt[MAXM<<1],v[MAXM<<1],w[MAXM<<1];
inline void Add_edge(LL from,LL to,LL dis){
	nxt[++tot]=head[from],head[from]=tot,v[tot]=to,w[tot]=dis;
}
LL fa[MAXN];
inline LL findd(LL k){
	return fa[k]==k?k:fa[k]=findd(fa[k]);
}
LL n,m,MST=0;
inline void kruskal(){
	for(LL i=1;i<=n;i++) fa[i]=i;
	sort(e+1,e+1+m);
	for(LL i=1;i<=m;i++){
		LL u=e[i].u;
		LL v=e[i].v;
		LL w=e[i].w;
		if(findd(u)!=findd(v)){
			MST+=w;
			e[i].bt=true;
			Add_edge(u,v,w);
			Add_edge(v,u,w);
			fa[findd(u)]=findd(v);
		}
	}
}
LL dep[MAXN],f[MAXN][19];
LL maxg[MAXN][19],ming[MAXN][19];
inline void dfs(LL u,LL p){
	for(LL i=1;i<=18;i++){
		f[u][i]=f[f[u][i-1]][i-1];
		maxg[u][i]=max(maxg[u][i-1],maxg[f[u][i-1]][i-1]);
        //maxg肯定为两段路径分别的maxg的较大值
		ming[u][i]=max(ming[u][i-1],ming[f[u][i-1]][i-1]);
        //先令ming为两段路径分别的ming的较大值
       	//这个 if 非常重要！不然的话，要是边权最大的边有很多，就会使次大边权也为最大值
		if(maxg[u][i-1]!=maxg[f[u][i-1]][i-1])
			ming[u][i]=max(ming[u][i],min(maxg[u][i-1],maxg[f[u][i-1]][i-1]));
        //若两段的maxg相同，则不必要继续更新ming
        //否则要将ming与两段路径的maxg的较小值作比较，再次更新
	}
	for(LL i=head[u];i;i=nxt[i])
		if(!dep[v[i]]){
			f[v[i]][0]=u;
			maxg[v[i]][0]=w[i];
			ming[v[i]][0]=-INF;
			dep[v[i]]=dep[u]+1;
			dfs(v[i],u);
		}
}
inline LL LCA(LL x,LL y){
	if(dep[x]<dep[y]) swap(x,y);
	for(LL i=18;i>=0;i--)
		if(dep[f[x][i]]>=dep[y]) x=f[x][i];
	if(x==y) return x;
	for(LL i=18;i>=0;i--)
		if(f[x][i]^f[y][i]) x=f[x][i],y=f[y][i];
	return f[x][0];
}
inline LL qmax(LL x,LL y,LL z){
	LL ans=-INF;
    //ans记录树上(x,y)同一条链上的最大边权
    //由于主函数中求了LCA，所以在当前的函数中，y一定是x的祖先
	for(LL i=18;i>=0;i--)
		if(dep[f[x][i]]>=dep[y]){
        //这个 if 的原理同上
        //若当前这条非树边的权与当前路径段的最大边权不等
			if(z!=maxg[x][i])
            	//则用maxg更新一次
				ans=max(ans,maxg[x][i]);
			else
            	//否则则用ming尝试更新
				ans=max(ans,ming[x][i]);
			x=f[x][i];
		}
	return ans;
}
int main(){
	n=read(),m=read();
	for(LL i=1;i<=m;i++) e[i].scan();
	kruskal();
	dep[1]=1;
	maxg[1][0]=0;
	ming[1][0]=-INF;
	dfs(1,0);
	LL _MST_=INF;
	for(LL i=1;i<=m;i++){
		LL u=e[i].u;
		LL v=e[i].v;
		LL w=e[i].w;
		if(!e[i].bt){
			LL lca=LCA(u,v);
			LL maxx=qmax(u,lca,w);
			LL maxy=qmax(v,lca,w);
			_MST_=min(_MST_,MST-max(maxx,maxy)+w);
		}
	}
	return printf("%lld",_MST_),0;
}
```  
###  调了一天才调出来的正解，希望有帮助吧$qwq$

---

## 作者：_Fugitive_ (赞：1)

Kurskal找最小生成树

然后枚举一条非树边

找边所在的环上的最大值和次大值

这题有一个十分大材小用的写法

就是把在找一条链上的最大值和次大值

用可持久化线段树来维护（主席树）

好像有哪个大佬提到过这种写法……

```cpp
#include<bits/stdc++.h>
#define N 100005
#define mid ((l+r)>>1)
using namespace std;
int n,m;
vector<int>P[N],C[N];
struct edge{
	int a,b,c;
	bool operator<(const edge &_)const{return c<_.c;}
}E[N*3];
int vis[N*3];
int fat[N];
int getfa(int x){return x==fat[x]?x:fat[x]=getfa(fat[x]);}
long long Kurskal(){
	for(int i=1;i<=n;i++)fat[i]=i;
	sort(E+1,E+m+1);
	long long ans=0;
	for(int i=1;i<=m;i++){
		int x=getfa(E[i].a),y=getfa(E[i].b);
		if(x==y)continue;
		vis[i]=1;
		ans+=E[i].c;
		fat[x]=y;
		P[E[i].a].push_back(E[i].b);
		C[E[i].a].push_back(E[i].c);
		P[E[i].b].push_back(E[i].a);
		C[E[i].b].push_back(E[i].c);
	}
	return ans;
}
int fa[N][20],de[N];
int res[N*40];
int R[N*40];
int L[N*40];
int B[N*3],rt[N];
int tt,tot;
int update(int l,int r,int x,int p) {
	int rot=++tt;
	L[rot]=L[p];
	R[rot]=R[p];
	res[rot]=res[p]+1;
	if(l>=r)return rot;
	if(l<r) {
		if(x<=mid)L[rot]=update(l,mid,x,L[p]);
		else R[rot]=update(mid+1,r,x,R[p]);
	}
	return rot;
}
int query(int l,int r,int u,int v,int w,int k) {
	if(l>=r)return l;
	int x=res[L[v]]+res[L[u]]-2*res[L[w]];
	if(x>=k)return query(l,mid,L[u],L[v],L[w],k);
	else return query(mid+1,r,R[u],R[v],R[w],k-x);
}
int query2(int l,int r,int u,int v,int w,int k){
	if(l>=r)return res[u]+res[v]-2*res[w];
	if(k<=mid)return query2(l,mid,L[u],L[v],L[w],k);
	else return query2(mid+1,r,R[u],R[v],R[w],k);
}
void dfs(int p,int lastt,int dep,int cost){
	int t=lower_bound(B+1, B+1+tot, cost)-B; 
	rt[p]=update(1,tot,t,rt[lastt]);
	fa[p][0]=lastt;
	de[p]=dep;
	for(int i=0;i<(int)P[p].size();i++){
		int y=P[p][i];
		if(y==lastt)continue;
		dfs(y,p,dep+1,C[p][i]);
	}
}
int Lca(int a, int b) {
	if(de[a]>de[b])swap(a,b);
	for(int j=19;j>=0;j--)
		if(de[fa[b][j]]>=de[a])b=fa[b][j];
//	printf("a=%d b=%d\n",a,b);
	if(a==b)return a;
	for(int j=19;j>=0;j--){
		if(fa[b][j]!=fa[a][j]){
			b=fa[b][j];
			a=fa[a][j];
		}
	}
	return fa[a][0];
}
void solve(){
	tt=0;
	scanf("%d %d",&n,&m);
	for(int a,b,c,i=1;i<=m;i++){
		scanf("%d %d %d",&a,&b,&c);
		E[i]=(edge){a,b,c};
		B[i]=c;
	}
	long long ans=Kurskal();
//	printf("%lld\n",ans);
	sort(B+1,B+m+1);
    tot = unique(B+1, B+1+m)-B-1;
	dfs(1,0,1,E[1].c);
	for(int i=1;i<=19;i++)
		for(int j=1;j<=n;j++)
			fa[j][i]=fa[fa[j][i-1]][i-1];
	int mi=0x3f3f3f3f;
	for(int i=1;i<=m;i++){
		if(vis[i])continue;
		int lca=Lca(E[i].a,E[i].b);
		int t=lower_bound(B+1, B+1+tot, E[i].c)-B;
		int sum=res[rt[E[i].a]]+res[rt[E[i].b]]-2*res[rt[lca]];
		int kk=query(1,tot,rt[E[i].a],rt[E[i].b],rt[lca],sum);
		if(t>kk){
			mi=min(mi,B[t]-B[kk]);
			continue;
		}
		sum-=query2(1,tot,rt[E[i].a],rt[E[i].b],rt[lca],kk);
		if(sum==0)continue;
		kk=query(1,tot,rt[E[i].a],rt[E[i].b],rt[lca],sum);
//		printf("%d %d\n",B[t],B[kk]);
		mi=min(mi,B[t]-B[kk]);
	}
	printf("%lld\n",ans+mi);
}
int main(){
	solve();
	return 0;
}
```


---

## 作者：于丰林 (赞：1)

题目大意：

给定一个无向图，求出该图的次小生成树。

点数n≤100 000 边数m≤300 000

做法其实是比较简单的，首先我们求出给定图中的最小生成树，然后我们枚举每一条非树边，将其加入生成树中，可以证明这样一定会出现一个环，我们只需要在这个环中找到除去这条边以外最大的边,(又因为是严格次小生成树，所以还有找次小的，以防最大值与非树边边权相等），将它删去，然后得到另一个生成树，记录一下ans，对于所有非树边枚举得到的ans只要取一个最小值就可以了（因为是次小生成树）

但是这种做法的复杂度有点大，我们来分析一下：求最小生成树是O(n)，（由于并查集时间复杂度可以看作是一个常数），枚举非选择的边是O(m)，每一次求最大值（和次大值）也是O(m)，所以渐近时间复杂度是O(m^2)，如果要通过这道题还是差了很多。

那么我们进行优化：

很显然最小生成树不能优化，每一条非树边都必须被枚举，所以我们只能在求最大值上下手了。

考虑到我们在加入该非树边之前应该是一颗没有环的树，那么求一段路径上的最大值我们是会做的，树链剖分？代码量过于大了，那么我们考虑另一种做法：树上倍增LCA

其实LCA可以干很多事情的。。。

关于LCA求树上两点路径中边权最大值，这个其实是比较简单的，我们在原来的基础上开一个w[u][i]，表示从u向上跳2^i个点，这一段路径的最大值

动态转移方程也是比较显然的：我们假定f[u][i]表示从u向上跳2^i个点到达点的坐标，那么就有w[u][i+1]=max(w[u][i],w[f[u][i]][i])

所以我们只需要就从这两个点分别跳到他们的LCA处，每一次取最大值就可以了，这样我们就将m^2的算法转化成了mlogn,这样通过这道题就轻松加愉快了

但是我们忽略了一点：

题目中要求严格次小，但是这种做法很有可能就是和最小生成树相等，那么我们还需要解决这个难题。

其实也不算是难题，只是在原来的基础上多记录一个次大值，我们假设w2[u][i]表示从u向上跳2^i个单位，这段路径上的次大值。

动态转移方程就是：当w[u][i]>w[f[u][i]][i]　　w2[u][i+1]=max(w[f[u][i]][i],w2[f[u][i]][i])

　　　　　　　　　当w[u][i]<w[f[u][i]][i]　　w2[u][i+1]=max(w[u][i],w2[f[u][i]][i])

　　　　　　　　　当相等时，就继承上一个段的就可以了

那么我们就圆满的解决了这道题，总复杂度：mlogn+n*k　　k为一个比较小的常数

还有一些注意事项：

1.inf要足够大　　因为这个边权之和很大很大

2.建树时要建反向边，谁知道给定的两个点相对顺序呢？

最后，附上本题代码：
```cpp
#include<cstdio>
#include<algorithm>
#include<iostream>
using namespace std;
//Debug Yufenglin
#define dej printf("Running\n");
#define dep1(x) cout<<#x<<"="<<x<<endl;
#define dep2(x,y) cout<<#x<<"="<<x<<' '<<#y<<"="<<y<<endl;
#define dep3(x,y,z) cout<<#x<<"="<<x<<' '<<#y<<"="<<y<<' '<<#z<<"="<<z<<endl;

//Standfor Yufenglin
#define LL long long
#define LB long double
#define reg register
#define il inline
#define inf 1e8
#define maxn 100000
#define maxm 300000

struct EDGE
{
    LL u,v,w;
};
struct TREE
{
    LL to,val,nxt;
};
TREE tree[maxm+5];
EDGE edge[maxm+5];
LL n,m;
LL fa[maxn+5],f[maxn+5][30],w1[maxn+5][30],maxw1,maxw2,cnt,num;
LL head[maxn+5],dep[maxn+5],w2[maxn+5][30],ans,minans=1e16,sum;
bool vis[maxm+5];

bool cmp(EDGE x,EDGE y)
{
    return x.w<y.w;
}
void add(LL x,LL y,LL z)
{
    edge[++cnt].u=x;
    edge[cnt].v=y;
    edge[cnt].w=z;
}
void addedge(LL x,LL y,LL z)
{
    tree[++num].to=y;
    tree[num].val=z;
    tree[num].nxt=head[x];
    head[x]=num;
}
LL find(LL x)
{
    if(fa[x]==x) return x;
    return fa[x]=find(fa[x]);
}
void dfs(LL u,LL fa)
{
    dep[u]=dep[fa]+1;
    f[u][0]=fa;
    for(int i=0; i<=25; i++)
    {
        f[u][i+1]=f[f[u][i]][i];
        w1[u][i+1]=max(w1[u][i],w1[f[u][i]][i]);
        w2[u][i+1]=max(w2[u][i],w2[f[u][i]][i]);
        if(w1[u][i]>w1[f[u][i]][i]) w2[u][i+1]=max(w2[u][i+1],w1[f[u][i]][i]);
        if(w1[u][i]<w1[f[u][i]][i]) w2[u][i+1]=max(w2[u][i+1],w1[u][i]);
    }
    for(int i=head[u]; i; i=tree[i].nxt)
    {
        if(tree[i].to==fa) continue;
        w1[tree[i].to][0]=tree[i].val;
        dfs(tree[i].to,u);
    }
}
LL LCA(LL x,LL y)
{
    if(dep[x]<dep[y]) swap(x,y);
    for(int i=25; i>=0; i--)
    {
        if(dep[f[x][i]]>=dep[y])
        {
            x=f[x][i];
        }
        if(x==y) return x;
    }
    for(int i=25; i>=0; i--)
    {
        if(f[x][i]!=f[y][i])
        {
            x=f[x][i];
            y=f[y][i];
        }
    }
    return f[x][0];
}
LL query(LL x,LL y,LL d)
{
    LL anst=-1;
    for(int i=25;i>=0;i--)
    {
        if(dep[f[x][i]]>=dep[y])
        {
            if(d!=w1[x][i]) anst=max(anst,w1[x][i]);
            else anst=max(anst,w2[x][i]);
            x=f[x][i];
        }
    }
    return anst;
}
int main()
{
    scanf("%lld%lld",&n,&m);
    for(int i=1; i<=m; i++)
    {
        LL x,y,z;
        scanf("%lld%lld%lld",&x,&y,&z);
        add(x,y,z);
    }
    sort(edge+1,edge+cnt+1,cmp);
    for(int i=1; i<=n; i++) fa[i]=i;
    for(int i=1; i<=m; i++)
    {
        if(find(edge[i].u)!=find(edge[i].v))
        {
            addedge(edge[i].u,edge[i].v,edge[i].w);
            addedge(edge[i].v,edge[i].u,edge[i].w);
            fa[find(edge[i].u)]=find(edge[i].v);
            ans+=edge[i].w;
            vis[i]=1;
            sum++;
        }
        if(sum==n-1) break;
    }
    for(int i=1;i<=n;i++) w2[i][0]=-1;
    dfs(1,0);
    for(int i=1; i<=m; i++)
    {
        if(vis[i]==0)
        {
            LL lca=LCA(edge[i].u,edge[i].v);
            LL maxu=query(edge[i].u,lca,edge[i].w);
            LL maxv=query(edge[i].v,lca,edge[i].w);
            minans=min(minans,ans-max(maxu,maxv)+edge[i].w);
        }
    }
    printf("%lld\n",minans);
    return 0;
}
```


---

## 作者：SCKer (赞：1)

　　思路大体一致:先用$kruskal$求出$MST$,再用通过加边和删边的操作求解.对此就不多说了.本篇题解主要讨论**删边操作**.

1. 若去掉**严格**这一要求,那么要删除的边即为$MST$上两点间的最大权值.对此,可以考虑用**kruskal重构树**,树上两点间的$LCA$即为所求.
2. 要求**严格**的话,直接判断即可,若$LCA$的点权与当前枚举边的点权相同, 暴力地遍历一下两点间的非叶子节点即可

　　PS:当然,$LCA$的过程还是可以优化的,转成求$RMQ$,可以做到$O(1)$的查询,$\pm RMQ$的话,可以做到$O(n)$的预处理 (~~然而并不会~~)

  
```
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>

#define IL inline

using namespace std;
typedef long long ll;

IL int read()
{
    int sum = 0;
    bool k = 1;
    char c = getchar();
    for(;'0' > c || c > '9'; c = getchar())
    if(c == '-') k = 0;
    for(;'0' <= c && c <= '9'; c = getchar())
        sum = sum * 10 + (c - '0');
    return k ? sum : -sum;
}

int n, m;

struct Side
{
    int u, v, w;
    bool f;
    bool operator < (const Side &b) const
    {	
        return w < b.w;
    }
}side[300005];

int fa[200005][18];
int dep[200005];
int weight[200005];
int lg[200005]; // 打标,卡卡常

int pa[200005];//并查集
IL int find(int x) { return pa[x] = (pa[x] == x ? x : find(pa[x])); }
IL bool join(int x, int y, int z, int &T)
{
    int x1 = find(x), y1 = find(y);
    if(x1 == y1) return 0;
    ++T;
    fa[x1][0] = fa[y1][0] = T + n;
    weight[T + n] = z;
    
    pa[x1] = pa[y1] = T + n;
    
    return 1;
}

IL ll kru()
{
    sort(side + 1, side + m + 1);
    
    for(int i = 1; i <= n; ++i)
    {
        pa[i] = i; pa[i + n] = i + n;
    }
    
    ll sum = 0;
    int T = 0;
    for(int i = 1; i <= m && T < n; ++i)
    if(join(side[i].u, side[i].v, side[i].w, T))
    {
        side[i].f = 1;
        //printf("%d\n",side[i].w);
        sum += side[i].w;
        //printf("%d\n", sum);
    }
    return sum;
}

IL int get_dep(int u)
{
    if(dep[u] != -1) return dep[u];
    if(!fa[u][0]) return dep[u] = 0;
    return dep[u] = get_dep(fa[u][0]) + 1;
}

IL void lca()
{
    int n2 = (n << 1) - 1;
    memset(dep, -1, sizeof(dep));
    for(int i = 1; i <= n2; ++i)
    if(dep[i] == -1)
        get_dep(i);
    //太懒不想建树,直接记忆化求dep
    for(int i = 2; i <= n2; ++i)
        lg[i] = lg[i >> 1] + 1;
    for(int j = 1; j <= lg[n2]; ++j)
    for(int i = 1; i <= n2; ++i)
    if(fa[i][j - 1])
        fa[i][j] = fa[fa[i][j - 1]][j - 1];
}

IL void swap_(int &x, int &y) { int tmp = x; x = y; y = tmp; }

IL int query(int x, int y)
{
    if(dep[x] < dep[y]) swap_(x, y);
    for(int t = dep[x] - dep[y]; t; t -= t & (-t))
        x = fa[x][lg[t & (-t)]];
    //蜜汁跳高度, lg表 + lowbit优化
    if(x == y) return x;
    for(int i = lg[dep[x]]; i >= 0; --i)
    if(fa[x][i] != fa[y][i])
    {
        x = fa[x][i];
        y = fa[y][i];
    }
    return fa[x][0];
}

IL void solve(ll sum)
{
    ll det = -1, w;
    for(int i = 1, p, x, y; i <= m; ++i)
    if(!side[i].f)
    {
        x = side[i].u; y = side[i].v;
        p = query(x, y);
        w = side[i].w - weight[p];
        if(w)
        {
            if(det == -1 || w < det) det = w;
        }else
        if(!w)
        {
            for(x = fa[x][0]; x != p; x = fa[x][0])
            if(weight[x] != side[i].w && weight[x] > w)
                w = weight[x];
            for(y = fa[y][0]; y != p; y = fa[y][0])
            if(weight[y] != side[i].w && weight[y] > w)
                w = weight[y];
            det = weight[p] - w;
        }
    }
    printf("%lld\n", det + sum);
}

int main()
{
    n = read(); m = read();
    for(int i = 1; i <= m; ++i)
    {
        side[i].u = read(); side[i].v = read(); side[i].w = read();
    }
    ll sum = kru();
    lca();
    solve(sum);
    return 0;
}
```

---


# [蓝桥杯 2015 省 A] 灾后重建

## 题目描述

Pear 市一共有 $N$（$ \le 50000$）个居民点，居民点之间有 $M$（$ \le 2\times 10^5$）条双向道路相连。这些居民点两两之间都可以通过双向道路到达。这种情况一直持续到最近，一次严重的地震毁坏了全部 $M$ 条道路。

震后，Pear 打算修复其中一些道路，修理第 $i$ 条道路需要 $P_i$ 的时间。不过，Pear 并不打算让全部的点连通，而是选择一些标号特殊的点让他们连通。

Pear 有 $Q$（$ \le 50000$）次询问，每次询问，他会选择所有编号在 $[l,r]$ 之间，并且编号 $\bmod{K}=C$ 的点，修理一些路使得它们连通。由于所有道路的修理可以同时开工，所以完成修理的时间取决于花费时间最长的一条路，即涉及到的道路中 $P_i$ 的最大值。

你能帮助 Pear 计算出每次询问时需要花费的最少时间么？这里询问是独立的，也就是上一个询问里的修理计划并没有付诸行动。

## 说明/提示

对于 $20\%$ 的数据，$N,M,Q \le 30$。

对于 $40\%$ 的数据，$N,M,Q \le 2000$。

对于 $100\%$ 的数据，$N \le 50000,M \le 2 \times 10^5,Q \le 50000.P_i \le 10^6.L_i,R_i,K_i$ 均在 $[1,N]$ 范围内，$C_i$ 在 $[0,K_i)$ 范围内。

时限 5 秒, 256M。

蓝桥杯 2015 年省赛 A 组 J 题。

## 样例 #1

### 输入

```
7 10 4
1 3 10
2 6 9
4 1 5
3 7 4
3 6 9
1 5 8
2 7 4
3 2 10
1 7 6
7 6 9
1 7 1 0
1 7 3 1
2 5 1 0
3 7 2 1```

### 输出

```
9
6
8
8```

# 题解

## 作者：XLao (赞：4)

可以做到 $O(N\sqrt{N})$。

现有的一篇根号分治大概复杂度是假的，因为没放缺省源，没测他，不敢下定论。

---

可以直接在最小生成树上做。

>证明：
在最小生成树的基础上，任意连一条非树边 $(u,v)$，再断开最小生成树 $u$ 到 $v$ 路径上的任意一条边，都不会让某两点间产生更优路径，否则与“当前是最小生成树”相悖。

下面的“路径”都指 生成树 上的路径。

题目形式非常根号分治。

若 $K>\sqrt{N}$，则涉及到的点不超过 $\sqrt{N}$ 个，我们直接建虚树看看最大的边就好。由于 $\max$ 是可重复贡献的，其实都不用按 dfs 序，按下标顺序也可以。

> 按下标顺序：可以理解为每次加入点 $u$ 到当前关键点集合，在当前关键点集合里随便选一个点 $v$，让 $u$ 和 $v$ 联通，连的这些边一定在最终边集，所以不会多连；成功联通了 $u$，所以不会少连。

若 $K\le \sqrt{N}$，则本质不同的 $K$ 只有 $\sqrt{N}$ 个。在做每个 $K$ 的时候，算出所有的 $(i,i-K)$ 的链上 $\max$。由于按下标顺序就可以，那么把对 $K$ 取余数相同的下标**按顺序**排在一起，就可以用区间 $\max$ 解决了。

>　举例来说：比如 $N=5$，处理 $K=2$ 时，就把下标重排成 $2,4,1,3,5$，其中前两个模 $K$ 等于 $0$，后三个等于 $1$，这样询问的点一定是一个连续的区间。

---

到这里还是 $O(N\sqrt{N}\log N)$ 的。

但是可以 $O(1)$ 求 lca，以及链上 $\max$。

求 lca 就是欧拉序+ST表。

求链上 $\max$ 就把所有询问拆成 $u\to lca$ 和 $v\to lca$，挂在端点上，离线下来在树上做根号修改，$O(1)$ 求后缀 $\max$ 的分块就好了。（但是后面这部分要 $O(N\sqrt{N})$ 的空间，要调整块大小才能过去，以及确实不一定比得过树剖的小常数，仅供参考）

```cpp
#include<bits/stdc++.h>
using namespace std;

int read()
{
	char c=getchar(); int res=0, f=1;
	while(!isdigit(c)) {if(c=='-') f=-1; c=getchar();}
	while(isdigit(c)) {res=(res<<3)+(res<<1)+(c^48); c=getchar();}
	return res*f;
}

const int N=5e4+1, M=2e5+1;

int n,m,q,thre;

struct Edge {int x,y,z;} E[M];
bool cmpz(Edge a, Edge b) {return a.z < b.z;}

int Fa[N];
int find(int x) {return Fa[x]==x ? x:Fa[x]=find(Fa[x]);}
int merge(int x,int y)
{
	int fx=find(x), fy=find(y);
	if(fx!=fy) {Fa[fx]=fy; return 1;}
	return 0;
}

struct edge {int nex,to,v;} a[N<<1];
int h[N],tot;
void adde(int x,int y,int z)
{
	a[++tot]=(edge){h[x],y,z}, h[x]=tot;
	a[++tot]=(edge){h[y],x,z}, h[y]=tot;
}

int dep[N],val[N],sq[N<<1],Ti,in[N];
void dfs_init(int u,int f)
{
	dep[u]=dep[f]+1, sq[in[u]=++Ti]=u;
	for(int i=h[u];i;i=a[i].nex)
	{
		int v=a[i].to;
		if(v!=f) val[v]=a[i].v, dfs_init(v,u), sq[++Ti]=u;
	}
}
#define _min(x,y) (in[x]<in[y] ? x:y)
int lg2[N<<1],minn[N<<1][18];
void build_ST()
{
	lg2[0]=-1;
	for(int i=1;i<=Ti;++i) lg2[i]=lg2[i>>1]+1, minn[i][0]=sq[i];
	for(int i=1;(1<<i)<=Ti;++i)
	for(int l=1;l+(1<<i)-1<=Ti;++l)
		minn[l][i] = _min(minn[l][i-1], minn[l+(1<<(i-1))][i-1]);
}
int LCA(int x,int y)
{
	x=in[x], y=in[y];
	if(x>y) swap(x,y);
	int k=lg2[y-x+1];
	return _min(minn[x][k], minn[y-(1<<k)+1][k]);
}
#undef _min

struct Que {int l,r,K,C,id;} lx[N]; int Q,answer[N];
bool cmpq(Que a,Que b) {return a.K < b.K;}

struct data {int v,id;};
vector<data> G[N]; int ans[N*100],block,blo[N];
pair<int,int> sta[N]; int top;

void addq(int u,int v,int id)
{
	int lca=LCA(u,v);
	G[u].emplace_back((data){lca,id});
	G[v].emplace_back((data){lca,id});
}

int maxx[N<<2],A[N];
void add(int u,int v)
{
	int p=blo[u];
	for(int i=1;i<blo[u];++i) sta[++top] = make_pair(i,maxx[i]), maxx[i] = max(maxx[i],v);
	for(int i=(p-1)*block+1; i<=u; ++i) sta[++top] = make_pair(-i,A[i]), A[i] = max(A[i],v);
}
int ask(int u) {return max(maxx[blo[u]], A[u]);}
void roll_back(int tar)
{
	while(top>tar)
	{
		int i=sta[top].first, v=sta[top].second; --top;
		if(i>0) maxx[i]=v; else A[-i]=v;
	}
}
void dfs_calc(int u,int f)
{
	int prev=top;
	add(dep[u],val[u]);
	for(auto now : G[u])
	{
		int v=now.v, id=now.id;
		if(id>0) answer[id] = max(answer[id], ask(dep[v]+1));
		else ans[-id] = max(ans[-id], ask(dep[v]+1));
	}
	for(int i=h[u];i;i=a[i].nex)
	{
		int v=a[i].to;
		if(v!=f) dfs_calc(v,u);
	}
	roll_back(prev);
}

#define ls (pos<<1)
#define rs (pos<<1|1)
#define mid ((l+r)>>1)
void build(int pos,int l,int r)
{
	if(l==r) {maxx[pos]=A[l]; return;}
	build(ls,l,mid); build(rs,mid+1,r);
	maxx[pos] = max(maxx[ls],maxx[rs]);
}
int ask(int pos,int ql,int qr,int l,int r)
{
	if(ql>qr) return 0;
	if(ql<=l && r<=qr) return maxx[pos];
	int res=0;
	if(ql<=mid) res = max(res, ask(ls,ql,qr,l,mid));
	if(qr>mid) res = max(res, ask(rs,ql,qr,mid+1,r));
	return res;
}
#undef ls
#undef rs
#undef mid

int id[N];
int main()
{
	n=read(), m=read(), q=read();
	for(int i=1;i<=m;++i)
		E[i]=(Edge){read(),read(),read()};
	sort(E+1,E+m+1,cmpz);
	for(int i=1;i<=n;++i) Fa[i]=i;
	for(int i=1;i<=m;++i)
	{
		if(merge(E[i].x, E[i].y))
			adde(E[i].x, E[i].y, E[i].z);
	}
	dfs_init(1,0); build_ST();
	thre=100;
	for(int i=1,l,r,K,C;i<=q;++i)
	{
		l=read(), r=read(), K=read(), C=read();
		if(K>thre)
		{
			for(int u=(l-1)/K*K+C,v=0; u<=r; u+=K)
			{
				if(u<l) continue;
				if(v) addq(u,v,i); v=u;
			}
		}
		else lx[++Q]=(Que){l,r,K,C,i};
	}
	sort(lx+1,lx+Q+1,cmpq);
	
	for(int i=1,tt=0,K=0;i<=Q;++i)
	{
		if(lx[i].K!=K)
		{
			K=lx[i].K;
			for(int C=0;C<K;++C)
			for(int u=C?C:K,v=0; u<=n; v=u,u+=K)
			{
				++tt;
				if(v) addq(u,v,-tt);
			}
		}
	}
	block=sqrt(n);
	for(int i=1;i<=n;++i) blo[i]=(i-1)/block+1;
	dfs_calc(1,0);
	
	for(int i=1,tt=0,K=0;i<=Q;++i)
	{
		if(lx[i].K!=K)
		{
			K=lx[i].K;
			int prev=tt;
			for(int C=0;C<K;++C)
			for(int u=C?C:K;u<=n;u+=K)
			{
				++tt;
				A[tt-prev]=ans[tt], id[u]=tt-prev;
			}
			build(1,1,n);
		}
		int l = (lx[i].l-1)/K*K+lx[i].C;
		if(l<lx[i].l) l+=K;
		int r = lx[i].r/K*K+lx[i].C;
		if(r>lx[i].r) r-=K;
		if(l<=r) answer[lx[i].id] = ask(1,id[l]+1,id[r],1,n);
	}
	for(int i=1;i<=q;++i) printf("%d\n",answer[i]);
}
```

---

后记：

这题被一车暴力卡过去了，但是 5w，5s 真的 n 方都快过了qwq。

---

## 作者：_lbw_ (赞：1)

建出 kruskal 重构树，问题转化为了求一个区间内模 $\equiv c\pmod k$ 的点的 lca。

用 dfn 序查 lca，预处理复杂度可以忽略。

根号分治，对于 $k\geq B$ 的情况暴力，时间复杂度 $\mathcal{O}(q\dfrac{n}B)$。

对于 $k\leq B$ 的情况，我们有 $k$ 个长为 $\dfrac{n}k$ 的数组，询问区间 lca。

我们知道查询只有 $q$ 次而序列总长为 $nB$，故采取任意预处理复杂度线性查询复杂度不高于 $\sqrt{n}$ 的数据结构均可，代码中使用 zkw 线段树。

时间复杂度在 $B=\sqrt{q}$ 时取到最小值为 $\mathcal{O}(n\sqrt{q})$。

跑的还是比较快的，预处理部分要注意空间。

```cpp
#define ll long long
using namespace std;
#define I ll
#define her1 20081214
#define IV void
#define ull unsigned long long
#define cp(x,y)memcpy(x,y,sizeof y)
#define mem(x,val)memset(x,val,sizeof x)
#define D(i,j,n)for(register int i=j;i>=n;i--)
#define E(i,now)for(register int i=first[now];i;i=G[i].nxt)
#define F(i,j,n)for(register int i=j;i<=n;i++)
#define DL(i,j,n)for(register i64 i=j;i>=n;i--)
#define EL(i,now)for(register i64 i=first[now];i;i=G[i].nxt)
#define FL(i,j,n)for(register i64 i=j;i<=n;i++)
ll read(){
	ll ans=0,f=1;
	char c=getchar();
	while(c<'0'||c>'9'){
		if(c=='-')f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9')ans=ans*10+c-'0',c=getchar();
	return ans*f;
}
#undef ll
using i64 = int;
#include "assert.h"
mt19937_64 rnd(her1);
#include "functional"
const i64 B = 100;
const int maxn = 5e4+5;
const int maxm = 2e5+5;
struct edge{i64 u,v,w;}e[maxm];
i64 n,m,q,fa[maxn*2],tot,val[maxn*2];
i64 find(i64 x){return fa[x]==x?x:fa[x]=find(fa[x]);}
struct Tree{
	i64 dfn[maxn*2],dft;vector<i64>G[maxn*2];
	IV add(i64 u,i64 v){G[u].push_back(v);}
	i64 Min(i64 x,i64 y){return dfn[x]<dfn[y]?x:y;}
	IV dfs(i64 u,i64 F){
		st[dfn[u]=++dft][0]=F;
		for(i64 v:G[u])dfs(v,u);
	}
	i64 st[maxn*2][22];
	IV Build(i64 rt){
		dfs(rt,0);
		F(j,1,20)F(i,1,dft-(1<<j)+1)
			st[i][j]=Min(st[i][j-1],st[i+(1<<j-1)][j-1]);
	}
	i64 LCA(i64 x,i64 y){
		if(x==y)return x;if((x=dfn[x])>(y=dfn[y]))swap(x,y);
		i64 k=__lg(y-x++);return Min(st[x][k],st[y-(1<<k)+1][k]);
	}
}tr;
struct SGT{
	i64 n;vector<i64>p;
	IV chg(i64 P,i64 v){p[P+n-1]=v;}
	IV resize(i64 N){p.resize(2*(n=N)+5);}
	IV Build(){D(i,n-1,1)p[i]=tr.LCA(p[i<<1],p[i<<1|1]);}
	i64 Q(i64 l,i64 r){
		i64 ans=0;
		auto upd=[&](i64 P){ans=!ans?P:tr.LCA(P,ans);};
		for(l+=n-1,r+=n-1;l<=r;l>>=1,r>>=1){
			if( (l&1))upd(p[l++]);
			if(!(r&1))upd(p[r--]);
		}
		return ans;
	}
}zkw[B+2][B+2];
int main(){
	// freopen("1.in","r",stdin);
	// freopen("1.out","w",stdout);
	n=read();m=read();q=read();F(i,1,2*n-1)fa[i]=i;
	F(i,1,m)e[i].u=read(),e[i].v=read(),e[i].w=read();
	sort(e+1,e+1+m,[](edge A,edge B){return A.w<B.w;});tot=n;
	F(i,1,m){
		i64 fu=find(e[i].u),fv=find(e[i].v);if(fu==fv)continue;
		val[fa[fu]=fa[fv]=++tot]=e[i].w;tr.add(tot,fu);tr.add(tot,fv);
		// cout<<e[i].w<<' '<<e[i].u<<' '<<e[i].v<<endl;
	}
	tr.Build(tot);
	F(K,1,B){
		F(i,0,K-1)zkw[K][i].resize(n/K+5);
		F(i,1,n)zkw[K][i%K].chg((i-1)/K+1,i);//,cout<<i%K<<' '<<(i-1)/K+1<<' '<<i<<endl;
		F(i,0,K-1)zkw[K][i].Build();
		// cout<<zkw[K][1].Q(1,2)<<endl;
	}
	while(q--){
		i64 l=read(),r=read(),k=read(),c=read(),tmp=0;
		if(k>B){
			F(i,l,r)if(i%k==c){
				if(!tmp)tmp=i;
				else tmp=tr.LCA(tmp,i);
			}
		}
		else{
			while(l%k!=c)l++;while((r%k+k)%k!=c)r--;
			if(l<=r)tmp=zkw[k][c].Q((l-1)/k+1,(r-1)/k+1);
		}
		printf("%d\n",val[tmp]);
	}
	return 0;
}
```

---

## 作者：zhouyuhang (赞：1)

很久之前不会这题。最近看到小朋友在做，于是写了一个做法。**这个做法不需要你会建虚树，只需要知道虚树是什么就可以了**。

套路地取原图的最小生成树将图上问题转化为树上问题。那么我们只需求出以所选择的点为关键点的虚树边权最大值。而题目中对模 $K$ 余 $C$ 的点求解是一个常见的根号分治形式。于是我们只需给出 $K\le B$ 与 $K>B$ 时的两个做法即可。

首先考虑 $K$ 较大时的做法。此时，选择出的点的数量不会太多，因此一个简单的想法是对这些点直接建虚树做。可我们不会建虚树，怎么办呢？注意到我们只需知道虚数的边集，而一个简单的结论是：**以点集 $S$ 为关键点建出的虚数边集等于点集 $S$ 的 LCA 到 $S$ 内每一点的路径的并**。注意到取 max 是允许重复贡献的，因此直接使用树链剖分就得到了一个单次查询 $O(\frac{N}{B}\log N)$ 的做法。

沿用 $K$ 较大时的思路，$K$ 较小时，我们依旧只需要求出 LCA 到每个点路径的最大值。不同之处在于，这时选择的点比较多，不能暴力求出每一条路径。我们考虑使用区间数据结构（如线段树）对上述过程进行优化。由于没有修改操作，我们只需要解决信息的合并即可。

具体来说，我们需要记录区间的 LCA $t$ 和区间路径并的最大值 $m$。当我们将 $(t_1,m_1)$ 和 $(t_2,m_2)$ 合并时，显然有 $t=\text{LCA}(t_1,t_2)$。怎么对 $m$ 进行合并呢？可以发现，当我们将两个区间合起来时，除了这两个区间的 LCA 之间的路径，其余的边都一定在此前两个区间的路径并中出现过。因此有 $m=\max(m_1,m_2,\text{pathmax}(t_1,t_2))$，其中 $\text{pathmax}(x,y)$ 表示 $x$ 到 $y$ 路径上的最大值。

分析一下复杂度：上述做法线段树建树的过程是 $O(NB\log N)$，这是因为我们要对每一个 $0\le C<K\le B$ 建树；而对于固定的 $K$，所有 $0\le C<K$ 的线段树大小之和为 $N$。单次查询的复杂度是 $O(\log^2 N)$，表示瓶颈。

将两个做法综合起来，取 $B=\sqrt n$，就可以得到最优复杂度 $O(N\sqrt N\log N)$（默认 $N,Q$ 同阶）。实际上，由于 $\log N$ 来自于树剖，因此最慢的点也不过 500ms。

一些实现细节：

- 用树剖维护边的信息是老生常谈的内容了。将边的信息挂在父亲上，查询时略微注意细节即可。
- 多个点的 LCA 等于 dfn 序最小和最大两个点的 LCA。虽然对复杂度没有影响，但可以减小一定常数。
- 如果真的对每一个 $0\le C<K\le B$ 建一颗线段树，不仅要写动态开点，空间复杂度更是来到了恐怖的 $O(n\sqrt n)$，无法接受。由于题目不要求强制在线，因此可以将询问离线，每次分别建树，常数会显著减小。

[记录](https://www.luogu.com.cn/record/111462042)。代码比较长，就不挂上去了，可以私信找我要。

一点碎碎念：感觉这类题本质上就是套路的复合。也就是说，题目缺乏高妙的观察或者对算法灵活的使用，只是呆板地将一些套路组合在一起。应该避免总出这样的题。

---

## 作者：wangsiqi2010916 (赞：0)

一个结论，如果要让路径上的最大值最小，路径必然在原图的最小生成树上。

因为如果不在，那么经过的非树边的权值必然会小于会与它组成环的树边的最大值，此时就可以替换。

看到题目中的 $k$，可以根号分治。

当 $k>\sqrt n$ 的时候，需要计算的点的数量就 $<\sqrt n$，不超过 250 个，就可以暴力枚举每个点。

因为是求 $\max$，可以重复计算，根据 LCA 的性质，每一次只需要在上一个点求解完后的最近公共祖先的基础上叠加计算。

时间复杂度 $O(q\sqrt n \log n)$

对于剩下的部分，因为 $k$ 很小，情况很少，所以可以预处理出每一个 $i$ 到 $i+k$ 的贡献。

此时，对于每个余数，建线段树，然后 $O(\log n)$ 求解即可。

但是这样的空间复杂度很大，考虑优化。

注意到题目中没有限制强制在线，可以离线处理，将所有询问按 $k$ 为第一关键字，$c$ 为第二关键字排序。

此时，可以在 $k$ 改变时更新 $n$ 个数的贡献，$c$ 或 $k$ 改变时，重新建线段树。

此时，更新和查询的时间复杂度均为 $O(n\sqrt n \log n)$。

因为 $n$ 很小，所以能够通过。

代码：

```cpp
#include<cstdio>
#include<algorithm>
#include<cmath>
#define lid id<<1
#define rid id<<1|1
using namespace std;
int n,m,q,head[50005],edgenum;
struct node{
	int u,v,w;
}a[200005];
struct edge{
	int to,nxt,val;
}e[100005];
struct ques{
	int l,r,k,c,id;
}qs[50005];
void add_edge(int u,int v,int w)
{
	e[++edgenum].nxt=head[u];
	e[edgenum].to=v;
	e[edgenum].val=w;
	head[u]=edgenum;
}
bool cmp(node x,node y)
{
	return x.w<y.w;
}
int f[50005];
int find(int x)
{
	if(f[x]!=x) f[x]=find(f[x]);
	return f[x];
}
int f1[50005][18],dep[50005],d[50005][18];
int dfn[50005],tot,ans[50005];
void dfs(int u,int fa)
{
	dep[u]=dep[fa]+1,f1[u][0]=fa;
	dfn[u]=++tot;
	for(int i=1;i<=16;i++)
	{
		f1[u][i]=f1[f1[u][i-1]][i-1];
		d[u][i]=max(d[u][i-1],d[f1[u][i-1]][i-1]);
	}
	for(int i=head[u];i;i=e[i].nxt)
	{
		int v=e[i].to;
		if(v==fa) continue;
		d[v][0]=e[i].val;
		dfs(v,u);
	}
}
bool cmp1(ques x,ques y)
{
	if(x.k==y.k) return x.c<y.c;
	return x.k<y.k;
}
int lca,mx;
void getlca(int x,int y)
{
	if(dep[x]<dep[y]) swap(x,y);
	mx=0;
	for(int i=16;i>=0;i--)
	{
		if(dep[f1[x][i]]>=dep[y])
		{
			mx=max(mx,d[x][i]);
			x=f1[x][i];
		}
		if(x==y)
		{
			lca=x;
			return;
		}
	}
	for(int i=16;i>=0;i--)
	{
		if(f1[x][i]!=f1[y][i])
		{
			mx=max(mx,max(d[x][i],d[y][i]));
			x=f1[x][i],y=f1[y][i];
		}
	}
	lca=f1[x][0],mx=max(mx,max(d[x][0],d[y][0]));
}
int get(int l,int r,int k,int c)
{
	int st=l/k;
	st=st*k+c;
	if(st<l) st+=k;
	int lc=st,res=0;
	for(int i=st+k;i<=r;i+=k)
	{
		getlca(lc,i);
		res=max(res,mx);
		lc=lca;
	}
	return res;
}
int p[50005],b[50005],cnt;
void getarr(int x)
{
	for(int i=1;i<=n;i++) p[i]=0;
	for(int i=1;i<=n-x;i++)
	{
		getlca(i,i+x);
		p[i]=mx;
	}
}
struct seg_tr{
	int l,r,val;
}tr[200005];
void build(int id,int l,int r)
{
	tr[id].l=l,tr[id].r=r;
	if(l==r)
	{
		tr[id].val=b[l];
		return;
	}
	int mid=(l+r)>>1;
	build(lid,l,mid);
	build(rid,mid+1,r);
	tr[id].val=max(tr[lid].val,tr[rid].val);
}
int query(int id,int l,int r)
{
	if(tr[id].l==l&&tr[id].r==r)
	{
		return tr[id].val;
	}
	int mid=(tr[id].l+tr[id].r)>>1;
	if(r<=mid) return query(lid,l,r);
	else if(l>mid) return query(rid,l,r);
	else return max(query(lid,l,mid),query(rid,mid+1,r));
}
void new_tr(int x,int y)
{
	if(y==0) y=x;
	cnt=0;
	for(int i=y;i<=n-x;i+=x)
	{
		b[++cnt]=p[i];
	}
	build(1,1,cnt);
}
int getans(int l,int r,int k,int c)
{
	int st=l/k,ed=r/k;
	if(c==0)
	{
		st=(l+k-1)/k;
		return query(1,st,ed-1);
	}
	if(st*k+c<l) st++;
	if(ed*k+c>r) ed--;
//	printf("%d %d %d\n",st,ed,cnt);
	return query(1,st+1,ed);
}
int main()
{
	scanf("%d%d%d",&n,&m,&q);
	for(int i=1;i<=m;i++)
	{
		int u,v,w;
		scanf("%d%d%d",&u,&v,&w);
		a[i]=(node){u,v,w};
	}
	for(int i=1;i<=q;i++)
	{
		int l,r,k,c;
		scanf("%d%d%d%d",&l,&r,&k,&c);
		qs[i]=(ques){l,r,k,c,i};
	}
	sort(a+1,a+m+1,cmp);
	for(int i=1;i<=n;i++) f[i]=i;
	for(int i=1;i<=m;i++)
	{
		int u=a[i].u,v=a[i].v;
		if(find(u)==find(v)) continue;
		f[find(u)]=find(v);
		add_edge(u,v,a[i].w);
		add_edge(v,u,a[i].w);
	}
	dfs(1,0);
	sort(qs+1,qs+q+1,cmp1);
	int len=sqrt(n);
//	printf("1");
	for(int i=1;i<=q;i++)
	{
		if(qs[i].k>len)
		{
//		printf("%d",i);
			ans[qs[i].id]=get(qs[i].l,qs[i].r,qs[i].k,qs[i].c);
			continue;
		}
		if(qs[i].k!=qs[i-1].k)
		{
			getarr(qs[i].k);
//			for(int j=1;j<=n;j++)
//			{
//				printf("%d ",p[j]);
//			}
//			printf("\n");
			new_tr(qs[i].k,qs[i].c);
		}
		else if(qs[i].c!=qs[i-1].c)
		{
			new_tr(qs[i].k,qs[i].c);
		}
//		printf("%d ",qs[i].id);
		ans[qs[i].id]=getans(qs[i].l,qs[i].r,qs[i].k,qs[i].c);
	}
//	printf("1");
	for(int i=1;i<=q;i++)
	{
		printf("%d\n",ans[i]);
	}
	return 0;
}
```

---


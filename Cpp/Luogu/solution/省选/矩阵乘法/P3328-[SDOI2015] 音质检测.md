# [SDOI2015] 音质检测

## 题目描述

万老板希望在新的智能音乐播放设备 $\operatorname{IPOOD}$ 中，实现对波文件音质性能的评定。离散的波文件被考虑为长度为 $N$ 的整数序列：$A_1,A_2,\cdots,A_N$。所谓的音质性能检测，可以评定任何的一个区间范围 $[L,R]$ ，音质性能取决于下述评分：

$$\sum_{L<i<R}F[A_{i-1}+1]F[A_{i+1}-1] \operatorname{mod}\;(10^9+7)$$

其中 $F$ 是可归纳定义的数列，满足 $F_1=1$，$F_2=2$ 且 $F_{k+2}=F_{k+1}+aF_{k}+b$ 对于任何 $k>0$ 成立。

其中 $a$ 和 $b$ 为正整系数。为了可以为用户提供更好的服务体验，并希望对给定的波文件进行修正优化。这一款设备中，还应该支持对波文件的修改。对于给定的区间范围 $[L,R]$ ，允许用户将 $A_L$ 至 $A_R$ 同时增加一，或同时减少一。

## 说明/提示

$N\leq 3\times10^5,Q\leq10^4,0\leq a,b\leq10^9$

## 样例 #1

### 输入

```
7 7
1 0
3 4 5 6 7 8 9
query 2 4
query 3 7
plus 3 5
query 2 4
plus 4 7
query 3 7
query 1 7```

### 输出

```
64 
1766 
104 
7479 
7687```

# 题解

## 作者：SDNetFriend (赞：15)

从某位不愿透露姓名的神仙处获得了一个做法。

一种线段树配合矩阵乘法的做法。

首先看到这个线性递推式子，显然可以直接矩阵快速幂没有什么问题，就把向量设为形如 $F_i,F_{i-1},1$ 就可以了，我们叫这个向量是 $V(i)$，然后我们设使得 $i$ 加一的转移矩阵为 $pl$，减一的为 $mi$。

然后看，最终我们计算贡献的式子是：$F_{A_{i-1}+1}F_{A_{i+1}-1}$。

我们可以发现，如果按照我们写代码时，把向量放进矩阵里面，假设 $V$ 是列向量，那么转置就是个行向量。用这两个对应的矩阵，列向量左乘行向量得到的结果就恰好是两个向量第一位之积。

那么这个乘积就可以描述成 $(V(A_{i-1}+1)\times V(A_{i+1}-1)^T)[0][0]$ 的，这个东西有什么用呢？我们设 $W(i)=V(A_{i-1}+1)\times V(A_{i+1}-1)^T$

我们考虑对一个点 $i$，我们都维护一下 $W(i)$。这样有什么用呢？假设我想要让 $A_{i-1}$ 和 $A_{i+1}$ 都加上 $1$，那么新的贡献一定可以通过 $((pl\times V(A_{i-1}+1))\times (pl\times V(A_{i+1}-1))^T)[0][0]=(pl\times W(i)\times pl^T)[0][0]$ 表示出来。

那此时使用线段树的思路就明了了，因为矩阵乘法对加法具有分配律，所以我们线段树维护区间 $W$ 之和，然后修改的时候直接整体在前面或者后面乘上转移矩阵，就可以得出答案了！形式化地写，即：（以左右均乘加一矩阵为例）
$$
pl\times (\sum_{i=l}^r W(i))\times pl^T=\sum_{i=l}^r pl\times W(i)\times pl^T
$$
于是本题解决了，时间复杂度 $O((n+Q)\log n)$。

另外不知道为什么这个题直接写普通线段树会 TLE，但如果写动态开点就能过，很迷惑。

### 代码

```cpp
#include <bits/stdc++.h>
#define lint long long
using namespace std;
inline int read(){
	char c;int f=1,res=0;
	while(c=getchar(),!isdigit(c))if(c=='-')f*=-1;
	while(isdigit(c))res=res*10+c-'0',c=getchar();
	return res*f;
}
const int N=3e5+5;
const lint md=1e9+7;
#define add(x,y) x=(x+y)%md
struct mat{
	lint v[3][3];
	mat(lint x=0){
		memset(v,0,sizeof v);
		for(int i=0;i<3;++i)v[i][i]=x;
	}inline lint* operator[](int x)
		{return v[x];}
	inline mat operator*(mat x){
		mat r;
		for(int i=0;i<3;++i)
			for(int k=0;k<3;++k)
				for(int j=0;j<3;++j)
					add(r[i][j],v[i][k]*x[k][j]);
		return r;
	}inline mat operator+(mat x){
		for(int i=0;i<3;++i)
			for(int j=0;j<3;++j)
				add(x[i][j],v[i][j]);
		return x;
	}inline mat T(){
		mat r;
		for(int i=0;i<3;++i)
			for(int j=0;j<3;++j)
				r[i][j]=v[j][i];
		return r;
	}inline mat qpow(lint x){
		mat r(1),t=*this;
		while(x){
			if(x&1)r=r*t;
			t=t*t;x>>=1;
		}return r;
	}
}pl,mi,tpl,tmi,f,tf;
int n,nq;lint a,b,v[N];
inline lint qpow(lint x,lint y=md-2){
	lint res=1;
	while(y){
		if(y&1)res=res*x%md;
		x=x*x%md;y>>=1;
	}return res;
}
inline void init(){
	pl[0][0]=pl[1][0]=pl[2][2]=1;
	pl[0][1]=a;pl[0][2]=b;
	f[0][0]=2;f[1][0]=f[2][0]=1;
	tpl=pl.T();tf=f.T();
	if(a){
		mi[0][1]=mi[2][2]=1;
		mi[1][0]=qpow(a);
		mi[1][1]=md-qpow(a);
		mi[1][2]=md-b*qpow(a)%md;
	}else{
		mi[0][1]=mi[1][1]=mi[2][2]=1;
		mi[1][2]=md-b;
	}tmi=mi.T();
}
mat s[N<<1],tl[N<<1],tr[N<<1];
int ch[N<<1][2],tot,rt;
inline void nupd(int x,mat lu,mat ru){
	tl[x]=lu*tl[x];tr[x]=tr[x]*ru;
	s[x]=lu*s[x]*ru;
}inline void pushdown(int x){
	nupd(ch[x][0],tl[x],tr[x]);
	nupd(ch[x][1],tl[x],tr[x]);
	tl[x]=tr[x]=mat(1);
}void build(int &x=rt,int l=2,int r=n-1){
	x=++tot;tl[x]=tr[x]=mat(1);
	if(l==r){
		s[x]=pl.qpow(v[l-1]-1)*f;
		s[x]=s[x]*tf*tpl.qpow(v[l+1]-3);
		return;
	}int mid=l+r>>1;
	build(ch[x][0],l,mid);
	build(ch[x][1],mid+1,r);
	s[x]=s[ch[x][0]]+s[ch[x][1]];
}
void upd(int lp,int rp,mat lu,mat ru,int x=rt,int l=2,int r=n-1){
	if(l>rp||r<lp)return;
	if(lp<=l&&r<=rp)return nupd(x,lu,ru);
	int mid=l+r>>1;pushdown(x);
	upd(lp,rp,lu,ru,ch[x][0],l,mid);
	upd(lp,rp,lu,ru,ch[x][1],mid+1,r);
	s[x]=s[ch[x][0]]+s[ch[x][1]];
}
mat query(int lp,int rp,int x=rt,int l=2,int r=n-1){
	if(l>rp||r<lp)return mat();
	if(lp<=l&&r<=rp)return s[x];
	int mid=l+r>>1;pushdown(x);
	mat res=query(lp,rp,ch[x][0],l,mid);
	res=res+query(lp,rp,ch[x][1],mid+1,r);
	return res;
}
int main(){
	n=read();nq=read();
	a=read();b=read();
	for(int i=1;i<=n;++i)v[i]=read();
	init();build();
	while(nq--){
		string op;cin>>op;
		int l=read(),r=read();
		if(op=="plus"){
			upd(l+1,r+1,pl,mat(1));
			upd(l-1,r-1,mat(1),tpl);
		}else if(op=="minus"){
			upd(l+1,r+1,mi,mat(1));
			upd(l-1,r-1,mat(1),tmi);
		}else if(op=="query")
			printf("%lld\n",query(l+1,r-1)[0][0]);
	}return 0;
}

```



---

## 作者：斯德哥尔摩 (赞：8)

[P3328 [SDOI2015]音质检测](https://www.luogu.org/problemnew/show/P3328)

趁没有题解赶紧抢一发一血。。。

## 先说一点题外话



首先洛谷上只能评测，题面暂时不全。。。

所以我们可以去$Vijos$搞搞事。

当然如果你有某$ZOJ$的~~氪金~~权限号，你也可以去某$ZOJ$。。。

然而Vijos上数据范围不对，应该是洛谷上的数据范围。。。

所以没钱氪金就凑合着看吧。。。

这里附上$Vijos$的题面。

[1958 音质检测](https://vijos.org/p/1958)

## 步入正题

这个题简直就是道神题。。。

首先，线段树+奇奇怪怪的矩阵快速幂应该都能想到。

关键是怎么做对吧。。。

首先考虑一个性质：

我们如果有数列的相邻两项$f[i],f[i+1]$。

那么用这两项向后推$k$项其线性表示系数一定。

即表示为$f[i+k]=A\times f[i]+B\times f[i+1]+C$的形式。

那么这样我们预处理这些系数就好了嘛。

注意到维护的是一个乘积的形式，那么我们要维护这个必须得维护$8$个量。

**对！你没有看错！$8$个！**

将其写成$3\times 3$矩阵的形式转移会比较科学。

注意$a==0$时的特判。 

以上是正解。

然后某位巨佬用了$BSGS$预处理$f$函数，简直无敌了：[链接](https://blog.csdn.net/qq_20669971/article/details/70208601)。

然而我表示并不能码出来，于是自己$YY$了一个方案。

思路大致差不多，但是维护的东西多了点。

我们可以用线段树维护$f[a_{i-1}],f[a_{i-1}+1],f[a_{i-1}-1],f[a_{i+1}],f[a_{i+1}+1],f[a_{i+1}-1]$的值，以及两两乘积和。

加一的时候可以直接用递推式用保存的$f$值求出新的值。

减一的时候也可以解方程求值。

同样注意$a==0$时的特判。 

然后开始码码码。。。

好长啊。。。

然后这题还有一大堆乱七八糟的细节，这里总结了个人的几点：

1. 记得尽量降低时间、空间复杂度，能$return$的地方尽量$return$，以免不必要的搜索导致$TLE/MLE$。

2. 还有一件事，注意开$long\ long$！

3. 还有一件事，做减法的时候如果减了两次，一定要先取模，再加上模数，再取模！不然会求出来负数，就光荣地$WA$了。。。

4. 还有一件事，注意线段树的边界问题，为这个我还浪费了一次提交，药丸。。。

[记得有空到本蒟蒻的博客里喝喝茶哦！](https://www.cnblogs.com/Yangrui-Blog/p/9623294.html)

附上炒鸡长的代码（码风较丑不要打我。。。）：
```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#define LSON rt<<1
#define RSON rt<<1|1
#define DATA(x,i,j) a[x].data[i-1][j-1]
#define SUM(x,i,j) a[x].sum[i-1][j-1]//为了省空间，只能这样干了。。。
#define ADD(x) a[x].c
#define DEL(x) a[x].d
#define LSIDE(x) a[x].l
#define RSIDE(x) a[x].r
#define WIDTH(x) (RSIDE(x)-LSIDE(x)+1)
#define MAXN 300010
#define MOD 1000000007LL
using namespace std;
int n,m;
long long A,B,inv,f[MAXN][4];
struct node{//矩阵
	long long val[4][4];
	inline void clean(){
		for(int i=1;i<=3;i++)
		for(int j=1;j<=3;j++)
		val[i][j]=(i==j);
	}
	friend node operator *(const node x,const node y){
		node ret;
		for(int i=1;i<=3;i++)
		for(int j=1;j<=3;j++){
			ret.val[i][j]=0;
			for(int k=1;k<=3;k++)ret.val[i][j]=(ret.val[i][j]+x.val[i][k]*y.val[k][j]%MOD)%MOD;
		}
		ret.val[3][3]=1;
		return ret;
	}
}one,two,power[35];
struct Segment_Tree{//线段树，记得不要在结构体里再开结构体。。。
	long long sum[3][3],data[3][3];
	int c,d,l,r;
}a[MAXN<<2];
inline long long read(){
	long long date=0,w=1;char c=0;
	while(c<'0'||c>'9'){if(c=='-')w=-1;c=getchar();}
	while(c>='0'&&c<='9'){date=date*10+c-'0';c=getchar();}
	return date*w;
}
long long mexp(long long a,long long b,long long c){//普通快速幂
	long long s=1;
	while(b){
		if(b&1)s=s*a%c;
		a=a*a%c;
		b>>=1;
	}
	return s;
}
node pow(long long k){//矩阵快速幂
	node s;
	s.clean();
	int i=1;
	while(k){
		if(k&1)s=s*power[i];//预处理矩阵的2的幂次方
		k>>=1;
		i++;
	}
	return s;
}
void function(int i){
	node s=one*pow(f[i][0]-2);
	f[i][1]=s.val[1][2];f[i][2]=s.val[1][1];
}
void build(){
	one.val[1][1]=2;one.val[1][2]=one.val[1][3]=1;
	two.val[1][1]=two.val[1][2]=two.val[3][3]=1;
	two.val[2][1]=A;two.val[3][1]=B;
	for(int i=1;i<=32;i++){//预处理矩阵的2的幂次方
		power[i]=two;
		two=two*two;
	}
}

//-------------------以下是线段树-------------------

inline void pushup(int rt){//上传
	for(int i=1;i<=3;i++)
	for(int j=1;j<=3;j++){
		DATA(rt,i,j)=(DATA(LSON,i,j)+DATA(RSON,i,j))%MOD;
		SUM(rt,i,j)=(SUM(LSON,i,j)+SUM(RSON,i,j))%MOD;
	}
}
inline void add(int rt,int l){//下传加法标记，可以不用特判A==0
	for(int i=1;i<=2;i++)SUM(rt,l,i)=SUM(rt,l,i+1);
	SUM(rt,l,3)=(SUM(rt,l,2)+A*SUM(rt,l,1)%MOD+B*WIDTH(rt)%MOD)%MOD;
	if(l==1){
		for(int i=1;i<=2;i++)
		for(int j=1;j<=3;j++)
		DATA(rt,i,j)=DATA(rt,i+1,j);
		for(int i=1;i<=3;i++)DATA(rt,3,i)=(DATA(rt,2,i)+A*DATA(rt,1,i)%MOD+B*SUM(rt,2,i)%MOD)%MOD;
	}
	else{
		for(int i=1;i<=3;i++)
		for(int j=1;j<=2;j++)
		DATA(rt,i,j)=DATA(rt,i,j+1);
		for(int i=1;i<=3;i++)DATA(rt,i,3)=(DATA(rt,i,2)+A*DATA(rt,i,1)%MOD+B*SUM(rt,1,i)%MOD)%MOD;
	}
}
inline void del(int rt,int l){//下传减法标记
	if(A==0){//记得特判！
		for(int i=2;i>=1;i--)SUM(rt,l,i+1)=SUM(rt,l,i);
		SUM(rt,l,1)=(SUM(rt,l,2)-B*WIDTH(rt)%MOD+MOD)%MOD;
		if(l==1){
			for(int i=2;i>=1;i--)
			for(int j=1;j<=3;j++)
			DATA(rt,i+1,j)=DATA(rt,i,j);
			for(int i=1;i<=3;i++)DATA(rt,1,i)=(DATA(rt,2,i)-B*SUM(rt,2,i)%MOD+MOD)%MOD;
		}
		else{
			for(int i=1;i<=3;i++)
			for(int j=2;j>=1;j--)
			DATA(rt,i,j+1)=DATA(rt,i,j);
			for(int i=1;i<=3;i++)DATA(rt,i,1)=(DATA(rt,i,2)-B*SUM(rt,1,i)%MOD+MOD)%MOD;
		}
		return;
	}
	for(int i=2;i>=1;i--)SUM(rt,l,i+1)=SUM(rt,l,i);
	SUM(rt,l,1)=((SUM(rt,l,3)-SUM(rt,l,2)-B*WIDTH(rt)%MOD)*inv%MOD+MOD)%MOD;
	if(l==1){
		for(int i=2;i>=1;i--)
		for(int j=1;j<=3;j++)
		DATA(rt,i+1,j)=DATA(rt,i,j);
		for(int i=1;i<=3;i++)DATA(rt,1,i)=((DATA(rt,3,i)-DATA(rt,2,i)-B*SUM(rt,2,i)%MOD)*inv%MOD+MOD)%MOD;
	}
	else{
		for(int i=1;i<=3;i++)
		for(int j=2;j>=1;j--)
		DATA(rt,i,j+1)=DATA(rt,i,j);
		for(int i=1;i<=3;i++)DATA(rt,i,1)=((DATA(rt,i,3)-DATA(rt,i,2)-B*SUM(rt,1,i)%MOD)*inv%MOD+MOD)%MOD;
	}
}
inline void pushdown_sign(int rt,int l,int c){//下传标记，为了方便就写成了函数
	if(!c)return;
	if(c>0)for(int i=1;i<=c;i++)add(rt,l);
	else for(int i=-1;i>=c;i--)del(rt,l);
}
inline void pushdown(int rt){//真正的线段树下传标记
	if(LSIDE(rt)==RSIDE(rt))return;
    
	ADD(LSON)+=ADD(rt);
    DEL(LSON)+=DEL(rt);
	pushdown_sign(LSON,1,ADD(rt));
    pushdown_sign(LSON,2,DEL(rt));
    //----------------------------------
	ADD(RSON)+=ADD(rt);
    DEL(RSON)+=DEL(rt);
	pushdown_sign(RSON,1,ADD(rt));
    pushdown_sign(RSON,2,DEL(rt));
    
	ADD(rt)=DEL(rt)=0;
}
void buildtree(int l,int r,int rt){//建树
	LSIDE(rt)=l;RSIDE(rt)=r;ADD(rt)=DEL(rt)=0;
	if(l==r){
		for(int i=1;i<=3;i++){
			SUM(rt,1,i)=f[l-1][i];
			SUM(rt,2,i)=f[l+1][i];
		}
		for(int i=1;i<=3;i++)
		for(int j=1;j<=3;j++)
		DATA(rt,i,j)=SUM(rt,1,i)*SUM(rt,2,j)%MOD;
		return;
	}
	int mid=LSIDE(rt)+RSIDE(rt)>>1;
	buildtree(l,mid,LSON);
	buildtree(mid+1,r,RSON);
	pushup(rt);
}
void update_add(int l,int r,int c,int rt){//区间加
	if(l<=LSIDE(rt)&&RSIDE(rt)<=r){
		ADD(rt)+=c;
		pushdown_sign(rt,1,c);
		return;
	}
	pushdown(rt);
	int mid=LSIDE(rt)+RSIDE(rt)>>1;
	if(l<=mid)update_add(l,r,c,LSON);
	if(mid<r)update_add(l,r,c,RSON);
	pushup(rt);
}
void update_del(int l,int r,int c,int rt){//区间减
	if(l<=LSIDE(rt)&&RSIDE(rt)<=r){
		DEL(rt)+=c;
		pushdown_sign(rt,2,c);
		return;
	}
	pushdown(rt);
	int mid=LSIDE(rt)+RSIDE(rt)>>1;
	if(l<=mid)update_del(l,r,c,LSON);
	if(mid<r)update_del(l,r,c,RSON);
	pushup(rt);
}
long long query(int l,int r,int rt){//区间求和
	if(l>r)return 0;//特判一下
	long long ans=0;
	if(l<=LSIDE(rt)&&RSIDE(rt)<=r)return DATA(rt,3,1);
	pushdown(rt);
	int mid=LSIDE(rt)+RSIDE(rt)>>1;
	if(l<=mid)ans=(ans+query(l,r,LSON))%MOD;
	if(mid<r)ans=(ans+query(l,r,RSON))%MOD;
	return ans;
}

//-------------------以上是线段树-------------------

void work(){
	char ch[7];
	int x,y,l,r;
	while(m--){
		scanf("%s",ch);x=read();y=read();
		if(ch[0]=='p'){//注意边界问题以及不必要的搜索
        
			l=x+1;r=y+1;
			if(r>n)r=n;
			if(l<=r)update_add(l,r,1,1);
            
			l=x-1;r=y-1;
			if(l<1)l=1;
			if(l<=r)update_del(l,r,1,1);
		}
		else if(ch[0]=='m'){
        
			l=x+1;r=y+1;
			if(r>n)r=n;
			if(l<=r)update_add(l,r,-1,1);
            
			l=x-1;r=y-1;
			if(l<1)l=1;
			if(l<=r)update_del(l,r,-1,1);
		}
		else printf("%lld\n",query(x+1,y-1,1));
	}
}
void init(){
	n=read();m=read();A=read();B=read();
	inv=mexp(A,MOD-2,MOD);//预处理逆元
	build();
	for(int i=1;i<=n;i++){//预处理f函数
		f[i][0]=read();
		function(i);
		f[i][3]=(f[i][2]+f[i][1]*A%MOD+B)%MOD;
	}
	buildtree(1,n,1);
}
int main(){//主函数So easy!
	init();
	work();
    return 0;
}

```

---

## 作者：YxYe (赞：5)

# P3328 [SDOI2015] 音质检测

## 写在前面

[题目传送门](https://www.luogu.com.cn/problem/P3328)

[博客食用效果更佳](https://www.luogu.com.cn/blog/YxYe/)

[第一次最优解且比别人快将近一半：2023/9/18](https://www.luogu.com.cn/record/125141291)

## 题意

题意比较清晰易懂，这里就不说了。

1. 看到要求这么大的范围的数列 $F$，立刻想到用矩阵快速幂处理。

2. 看到有多次询问，很容易想到用线段树维护操作。

**所以本题算法为矩阵快速幂 + 线段树！**

显然我们可以用矩阵快速幂求出初始状态：原数组 $a$ 中所有的答案 $F[a[i]\pm 1]$。

而矩阵快速幂可以通过系数转移，那么我们可以维护系数 $sum$，然后通过对 $sum$ 的操作求出答案。

对于每一次操作，相当于一次偏移 $\pm 1$，故对于每个位置的数据 $data$，我们可以将 $F[i],F[i+1],F[i+2]$ 的答案统统记录，这样就可以往前/后推出答案了：

- 偏移 $+1$：$Data[i+2]=Data[i+1]+a\times Data[i]+b\times sum[i+1]$。

- 偏移 $-1$：$Data[i-1]=(Data[i+1]-Data[i]-b\times sum[i-1])\div a$。

因为答案求的是 $F[x\pm 1]$ 的乘积，所以 $a[i]\pm 1$ 两个位置的数据都要记录！

## 细节

1. 十年OI一场空，不开 long long 见祖宗。

2. 注意边界！注意边界！注意边界！

3. 洛谷卡的时空限制比较紧，注意常数和冗余空间。

4. 快速幂每次的乘数要预处理，不然会 T 飞！

5. $a=0$ 要特判，因为除数不能为 $0$！

6. 代码要简洁，不然会像我一样调了半天。

## 代码

有亿点长

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<vector>
#include<stack>
#include<queue>
#define ll long long
#define db double
#define fo(i,tr,b) for(int i=(tr);i<=(b);i++)
#define fp(i,tr,b) for(int i=(tr);i<(b);i++)
#define de(i,tr,b) for(int i=(tr);i>=(b);i--)
#define fs(i,u) for(int i=head[u];i;i=nxt[i])
#define pii pair<int, int>
#define pdd pair<db,db>
#define pb push_back
#define fir first
#define sec second
#define ls (now<<1)
#define rs (now<<1|1)
#define mid ((l+r)>>1)
#define lowbit(x) (x&(-x))
using namespace std;
inline ll read(){
    ll x=0,f=1;char ch=getchar();
    while(!isdigit(ch)){
        if(ch=='-')f=-1;
        ch=getchar();
    }
    while(isdigit(ch)){
        x=(x<<1)+(x<<3)+(ch^48);
        ch=getchar();
    }
    return x*f;
}
const int maxn=3e5+10;
const int mod=1e9+7;
int n,m;
ll a0,b0,inv,f[maxn][4];
struct matrix{
	ll a[5][5];
	matrix(){
		memset(a,0,sizeof(a));
	}
	ll *operator[](int x){
		return a[x];
	}
}I,F0,dF,F,X[32];
matrix operator *(const matrix &A,const matrix &B){//矩阵乘法
	matrix C;
    fo(i,1,3){
        fo(j,1,3){
            fo(k,1,3){
                (C[i][j]+=A.a[i][k]*B.a[k][j])%=mod;
            }
        }
    }
    return C;
}
matrix mpow(ll y){//矩阵快速幂
	matrix ret=I;
	for(int i=1;y;y>>=1,i++)if(y&1)ret=ret*X[i];
	return ret;
}
ll fpow(ll x,ll y){//快速幂
	ll ret=1;
	for(;y;y>>=1,x=(x*x)%mod)if(y&1)ret=(ret*x)%mod;
	return ret;
}
void init(){//矩阵快速幂预处理
	inv=fpow(a0,mod-2);
	fo(i,1,3)I[i][i]=1;
	F0[1][1]=2;
	F0[1][2]=F0[1][3]=1;
	dF[1][1]=dF[1][2]=dF[3][3]=1;
	dF[2][1]=a0;
	dF[3][1]=b0;
	fp(i,1,32){
		X[i]=dF;
		dF=dF*dF;
	}
	fo(i,1,n){
		f[i][0]=read();
		F=F0*mpow(f[i][0]-2);
		f[i][1]=F[1][2];
		f[i][2]=F[1][1];
		f[i][3]=(f[i][2]+f[i][1]*a0%mod+b0)%mod;
	}
}
struct Seg{
	ll sum[3][4],data[4][4];
	int lz[3];
}tr[maxn<<2];
void pushup(int now){//上传数据
	fo(i,1,3){
		fo(j,1,3){
			tr[now].data[i][j]=(tr[ls].data[i][j]+tr[rs].data[i][j])%mod;
		}
	}
	fo(i,1,2){
		fo(j,1,3){
			tr[now].sum[i][j]=(tr[ls].sum[i][j]+tr[rs].sum[i][j])%mod;
		}
	}
}
void add(int now,int l,int r,int x){//偏移+1的懒标记
	fo(i,1,2)tr[now].sum[x][i]=tr[now].sum[x][i+1];
	tr[now].sum[x][3]=(tr[now].sum[x][2]+a0*tr[now].sum[x][1]%mod+b0*(r-l+1)%mod)%mod;
	if(x==1){
		fo(i,1,2){
			fo(j,1,3){
				tr[now].data[i][j]=tr[now].data[i+1][j];
			}
		}
		fo(i,1,3){
			tr[now].data[3][i]=(tr[now].data[2][i]+a0*tr[now].data[1][i]%mod+b0*tr[now].sum[2][i]%mod)%mod;
		}
	}else{
		fo(i,1,3){
			fo(j,1,2){
				tr[now].data[i][j]=tr[now].data[i][j+1];
			}
		}
		fo(i,1,3){
			tr[now].data[i][3]=(tr[now].data[i][2]+a0*tr[now].data[i][1]%mod+b0*tr[now].sum[1][i]%mod)%mod;
		}
	}
}
void cut(int now,int l,int r,int x){//偏移-1的懒标记
	if(a0==0){
		de(i,2,1){
			tr[now].sum[x][i+1]=tr[now].sum[x][i];
		}
		tr[now].sum[x][1]=(tr[now].sum[x][2]-b0*(r-l+1)%mod+mod)%mod;
		if(x==1){
			de(i,2,1){
				fo(j,1,3){
					tr[now].data[i+1][j]=tr[now].data[i][j];
				}
			}
			fo(i,1,3){
				tr[now].data[1][i]=(tr[now].data[2][i]-b0*tr[now].sum[2][i]%mod+mod)%mod;
			}
		}else{
			fo(i,1,3){
				de(j,2,1){
					tr[now].data[i][j+1]=tr[now].data[i][j];
				}
			}
			fo(i,1,3){
				tr[now].data[i][1]=(tr[now].data[i][2]-b0*tr[now].sum[1][i]%mod+mod)%mod;
			}
		}
	}else{
		de(i,2,1){
			tr[now].sum[x][i+1]=tr[now].sum[x][i];
		}
		tr[now].sum[x][1]=((tr[now].sum[x][3]-tr[now].sum[x][2]-b0*(r-l+1)%mod)*inv%mod+mod)%mod;
		if(x==1){
			de(i,2,1){
				fo(j,1,3){
					tr[now].data[i+1][j]=tr[now].data[i][j];
				}
			}
			fo(i,1,3){
				tr[now].data[1][i]=((tr[now].data[3][i]-tr[now].data[2][i]-b0*tr[now].sum[2][i]%mod)*inv%mod+mod)%mod;
			}
		}else{
			fo(i,1,3){
				de(j,2,1){
					tr[now].data[i][j+1]=tr[now].data[i][j];
				}
			}
			fo(i,1,3){
				tr[now].data[i][1]=((tr[now].data[i][3]-tr[now].data[i][2]-b0*tr[now].sum[1][i]%mod)*inv%mod+mod)%mod;
			}
		}
	}
}
void pushdown_(int now,int l,int r,int x,int y){//独立下传懒标记
	if(x>0)fo(i,1,x)add(now,l,r,y);
	if(x<0)de(i,-1,x)cut(now,l,r,y);
}
void pushdown(int now,int l,int r){//整体下传懒标记
	if(l==r)return;
    fo(i,1,2){
    	tr[ls].lz[i]+=tr[now].lz[i];
    	tr[rs].lz[i]+=tr[now].lz[i];
		pushdown_(ls,l,mid,tr[now].lz[i],i);
	    pushdown_(rs,mid+1,r,tr[now].lz[i],i);
	    tr[now].lz[i]=0;
	}
}
void build(int now,int l,int r){//建树
	if(l==r){
		fo(i,1,3){
			tr[now].sum[1][i]=f[l-1][i];
			tr[now].sum[2][i]=f[l+1][i];
		}
		fo(i,1,3){
			fo(j,1,3){
				tr[now].data[i][j]=tr[now].sum[1][i]*tr[now].sum[2][j]%mod;
			}
		}
		return;
	}
	build(ls,l,mid);
	build(rs,mid+1,r);
	pushup(now);
}
void pls(int now,int l,int r,int L,int R,int x){//偏移+1
	if(L<=l&&r<=R){
		tr[now].lz[1]+=x;
		pushdown_(now,l,r,x,1);
		return;
	}
	pushdown(now,l,r);
	if(L<=mid)pls(ls,l,mid,L,R,x);
	if(mid+1<=R)pls(rs,mid+1,r,L,R,x);
	pushup(now);
}
void mns(int now,int l,int r,int L,int R,int x){//偏移-1
	if(L<=l&&r<=R){
		tr[now].lz[2]+=x;
		pushdown_(now,l,r,x,2);
		return;
	}
	pushdown(now,l,r);
	if(L<=mid)mns(ls,l,mid,L,R,x);
	if(mid+1<=R)mns(rs,mid+1,r,L,R,x);
	pushup(now);
}
ll query(int now,int l,int r,int L,int R){//求答案
	if(L<=l&&r<=R){
		return tr[now].data[3][1];
	}
	ll ret=0;
	pushdown(now,l,r);
	if(L<=mid)(ret+=query(ls,l,mid,L,R))%=mod;
	if(mid+1<=R)(ret+=query(rs,mid+1,r,L,R))%=mod;
	return ret;
}
int main(){
	n=read();m=read();a0=read();b0=read();
	init();
	build(1,1,n);
	while(m--){
		string s;cin>>s;
		int x=read(),y=read();
		if(s[0]=='p'){
			int l=x+1,r=y+1;
			if(r>n)r=n;//注意边界！！！
			pls(1,1,n,l,r,1);
			l=x-1,r=y-1;
			if(l<1)l=1;//注意边界！！！
			mns(1,1,n,l,r,1);
		}
		if(s[0]=='m'){
			int l=x+1,r=y+1;
			if(r>n)r=n;//注意边界！！！
			pls(1,1,n,l,r,-1);
			l=x-1,r=y-1;
			if(l<1)l=1;//注意边界！！！
			mns(1,1,n,l,r,-1);
		}
		if(s[0]=='q'){
			if(x+1>y-1)puts("0");//注意边界！！！
			else printf("%lld\n",query(1,1,n,x+1,y-1));
		}
	}
    return 0;
}
```

---

## 作者：dspt (赞：3)

这是一道矩阵乘法题，题解区里面居然没有一篇题解写出了矩阵到底长什么样！

为了让变量名不重复，用 $c_i$ 表示题面中的 $A_i$。题面关于 $c_i$ 的大小说的非常不清楚，其实可以认为操作过程中 $c_i-1\geqslant 2$，也就是说可以完全忽略 $c_1,c_0$。

---

### $a=0$

容易想到用矩阵来维护 $f$。
$$
\begin{bmatrix}
1&b\\
0&1
\end{bmatrix}
\begin{bmatrix}
f_i\\
1
\end{bmatrix}=
\begin{bmatrix}
f_{i+1}\\
1
\end{bmatrix}
$$
考虑题目如果求 $\sum_{l<i<r}f_{c_i}$ 怎么做，注意到矩阵乘法其实有分配律，所以可以用线段树维护一个区间的矩阵和，那么答案就是 $(l,r)$ 的矩阵和。

区间加法就是给对应区间左乘一个转移矩阵，区间减法就是给对应区间右乘一个转移矩阵的逆矩阵，转移矩阵：
$$
\begin{bmatrix}
1&-b\\
0&1
\end{bmatrix}
$$
我们再把做法推广到 $\sum_{l<i<r}f_{c_{i-1}}f_{c_{i+1}}$。有了乘法就需要维护这个乘法了。对于两个列向量 $u,v$，我们想要获得 $u_1v_1$ 的值，直接乘起来显然不对。我们可以**转置** $v$，然后 $uv$ 相乘得到的矩阵的第一行第一列就是我们想要的 $u_1v_1$（实际上我们可以通过这个方法获得任意 $u_iv_j$ 的值）。

于是我们转置积的右侧部分。转置还有一个好处，原本直接乘起来就会出现转移矩阵需要乘在中间的情况，而转置后维护 $f_{c_{i+1}}$ 就变成了右乘转移矩阵，具体的：
$$
\left(\begin{bmatrix}
1&b\\
0&1
\end{bmatrix}\right)^i
\begin{bmatrix}
f_i\\
1
\end{bmatrix}
\begin{bmatrix}
f_i\\
1
\end{bmatrix}^T
\left(\begin{bmatrix}
1&b\\
0&1
\end{bmatrix}^T\right)^j
$$
线段树的 tag 维护左乘了多少了转移矩阵，右乘了多少转移矩阵即可。询问就是区间求和。

$\sum_{l<i<r}f_{c_{i-1}-1}f_{c_{i+1}+1}$ 其实是类似的，只要修改一下初始值即可。

&nbsp;

### $a>0$

类似的容易写出转移：
$$
\begin{bmatrix}
0&1&0\\
a&1&b\\
0&0&1
\end{bmatrix}
\begin{bmatrix}
f_{i-1}\\
f_i\\
1
\end{bmatrix}=
\begin{bmatrix}
f_i\\
f_{i+1}\\
1
\end{bmatrix}
$$
逆矩阵：
$$
\begin{bmatrix}
-\frac1a&\frac1a&-\frac ba\\
1&0&0\\
0&0&1
\end{bmatrix}
$$
线段树维护：
$$
\left(\begin{bmatrix}
0&1&0\\
a&1&b\\
0&0&1
\end{bmatrix}\right)^i
\begin{bmatrix}
f_{i-1}\\
f_i\\
1
\end{bmatrix}
\begin{bmatrix}
f_{i-1}\\
f_i\\
1
\end{bmatrix}^T
\left(\begin{bmatrix}
0&1&0\\
a&1&b\\
0&0&1
\end{bmatrix}^T\right)^j
$$
其实与 $a=0$ 是类似的。

---

需要预处理转移矩阵的 $i$ 次方的值，不然可能会超时。

建议手推一下转移矩阵 & 逆矩阵，不要直接抄。

---

## 作者：ZhongYuLin (赞：2)

容易列出转移矩阵 $A$ 和初态向量 $\textbf{x}$。将题目所求形式化地写出

$$\sum_{L<i<R}(A^{a_{i-1}+1}\textbf{x})(A^{a_{i+1}-1}\textbf{x})^{\mathsf{T}}$$

考虑到 $(AB)^\mathsf{T}=B^\mathsf{T}A^\mathsf{T}$，于是有：

$$\sum_{L<i<R}A^{a_{i-1}+1}(\textbf{x}\textbf{x}^{\mathsf{T}}){A^\mathsf{T}}^{a_{i+1}-1}$$

容易用线段树维护。


```cpp
#include<bits/stdc++.h>
#define ls mid<<1
#define rs mid<<1|1
using namespace std;
using ll=long long;
const int N=3e5+3,P=1e9+7;
static inline int up(int x,int y){return x+y>=P?x+y-P:x+y;}
ll fp(ll a,ll b=P-2){ll ans=1;for(;b;b>>=1,a=a*a%P)if(b&1)ans=ans*a%P;return ans;}
struct Mat{
    int a[3][3];
    Mat(){memset(a,0,sizeof(a));}
    int*operator[](int i){return a[i];}
    const int *operator[](int i)const{return a[i];}
    friend Mat operator*(const Mat &x,const Mat &y){
        Mat z;
        for(int i=0;i<3;++i)
            for(int j=0;j<3;++j)
                for(int k=0;k<3;++k)
                    z[i][j]=(z[i][j]+1ll*x[i][k]*y[k][j])%P;
        return z;
    }
    friend Mat operator+(const Mat &x,const Mat &y){
        Mat z;
        for(int i=0;i<3;++i)
            for(int j=0;j<3;++j)
                z[i][j]=up(x[i][j],y[i][j]);
        return z;
    }
    friend Mat trans(Mat x){
        for(int i=0;i<3;++i)
            for(int j=i+1;j<3;++j)
                swap(x[i][j],x[j][i]);
        return x;
    }
    void out(){
        for(int i=0;i<3;++i,puts(""))
            for(int j=0;j<3;++j)printf("%d ",a[i][j]);
    }
};
Mat tag_L[N<<1],tag_R[N<<1],t[N<<1];
Mat del,A,B,INV_A,I;
bitset<N<<1>has_L,has_R;
int n,q;
int a[N];
Mat operator^(Mat a,ll b){Mat ans=I;for(;b;b>>=1,a=a*a)if(b&1)ans=ans*a;return ans;}
void fix1(int p,const Mat &k){
    t[p]=k*t[p];
    if(!has_L[p])has_L[p]=1,tag_L[p]=k;
    else tag_L[p]=k*tag_L[p];
}
void fix2(int p,const Mat &k){
    t[p]=t[p]*k;
    if(!has_R[p])has_R[p]=1,tag_R[p]=k;
    else tag_R[p]=tag_R[p]*k;
}
void push_down(int p,int mid){
    if(has_L[p]){
        fix1(ls,tag_L[p]);
        fix1(rs,tag_L[p]);
        has_L[p]=0;
    }
    if(has_R[p]){
        fix2(ls,tag_R[p]);
        fix2(rs,tag_R[p]);
        has_R[p]=0;
    }
}
void upd1(int x,int y,int l=2,int r=n-1,int p=1){
    if(x<=l&&r<=y)return fix1(p,del);
    int mid=l+r>>1;push_down(p,mid);
    if(x<=mid)upd1(x,y,l,mid,ls);
    if(y>mid)upd1(x,y,mid+1,r,rs);
    t[p]=t[ls]+t[rs];
}
void upd2(int x,int y,int l=2,int r=n-1,int p=1){
    if(x<=l&&r<=y)return fix2(p,del);
    int mid=l+r>>1;push_down(p,mid);
    if(x<=mid)upd2(x,y,l,mid,ls);
    if(y>mid)upd2(x,y,mid+1,r,rs);
    t[p]=t[ls]+t[rs];
}
int query(int x,int y,int l=2,int r=n-1,int p=1){
    if(x<=l&&r<=y)return t[p][0][0];
    int mid=l+r>>1;push_down(p,mid);
    if(y<=mid)return query(x,y,l,mid,ls);
    if(x>mid)return query(x,y,mid+1,r,rs);
    return up(query(x,y,l,mid,ls),query(x,y,mid+1,r,rs));
}
int op;
void build(int l=2,int r=n-1,int p=1){
    if(l==r){
        if(l!=n&&l!=1)
            if(op)t[p]=(A^(a[l-1]+1-1))*B*(trans(A)^(a[l+1]-1-1));
            else t[p]=(A^(a[l-1]+1-2))*B*(trans(A)^(a[l+1]-1-2));
        return;
    }
    int mid=l+r>>1;
    build(l,mid,ls);
    build(mid+1,r,rs);
    t[p]=t[ls]+t[rs];
}
int main(){
    int u,v,w,x,y,z;
    ios::sync_with_stdio(0);
    cin.tie(0);cout.tie(0);
    cin>>n>>q>>x>>y;op=x;
    for(int i=1;i<=n;++i)cin>>a[i];
    if(x){
        A[0][0]=0;A[0][1]=1;A[0][2]=0;
        A[1][0]=x;A[1][1]=1;A[1][2]=y;
        A[2][0]=0;A[2][1]=0;A[2][2]=1;
        
        u=fp(x);v=P-u;w=1ll*(P-y)*u%P;
        INV_A[0][0]=v;INV_A[0][1]=u;INV_A[0][2]=w;
        INV_A[1][0]=1;INV_A[1][1]=0;INV_A[1][2]=0;
        INV_A[2][0]=0;INV_A[2][1]=0;INV_A[2][2]=1;
    
        B[0][0]=1;B[0][1]=2;B[0][2]=1;
        B[1][0]=2;B[1][1]=4;B[1][2]=2;
        B[2][0]=1;B[2][1]=2;B[2][2]=1;
        
        I[0][0]=I[1][1]=I[2][2]=1;
    }else{
        A[0][0]=1;A[0][1]=y;
        A[1][0]=0;A[1][1]=1;

        INV_A[0][0]=1;INV_A[0][1]=P-y;
        INV_A[1][0]=0;INV_A[1][1]=1;

        B[0][0]=4;B[0][1]=2;
        B[1][0]=2;B[1][1]=1;

        I[0][0]=I[1][1]=1;
    }
    build();string op;
    for(;q--;){
        cin>>op>>x>>y;
        if(op[0]=='p'){
            if(x+1<n)del=A,upd1(max(2,x+1),min(n-1,y+1));
            if(y-1>1)del=trans(A);upd2(max(2,x-1),min(n-1,y-1));
        }
        else if(op[0]=='m'){
            if(x+1<n)del=INV_A;upd1(max(2,x+1),min(n-1,y+1));
            if(y-1>1)del=trans(INV_A);upd2(max(2,x-1),min(n-1,y-1));
        }
        else if(y-x<2)puts("0");
        else printf("%d\n",query(x+1,y-1));
    }
    return 0;
}
```

---

## 作者：_luanyi_ (赞：2)

发现大家几乎都是用 $3\times 3$ 矩阵然后转置一项乘上另一项维护的，很聪明，我来讲讲我想到的另一个做法。

我的做法是来拓展题目的，如果只想学怎么用矩阵维护的可以看看其他人的题解。

发现要求的式子很难看，先化成我们喜欢的样子：$\sum\limits_{i\in[L,R]}f_{a_i}g_{b_i}$，然后修改操作就是区间对 $a,b\pm1$。

发现 $f$ 和 $g$ 在做法中没有规定必须相同，那为了拓展可以按不同做，即 $f_i=a_ff_{i-1}+bf_{i-2}+c_f,g_i=a_gg_{i-1}+b_gg_{i-2}+c_g$。

为了方便，钦定 $a,b\neq 0$。如果有 $a=0$ 或 $b=0$ 也是类似的，因为矩阵不满秩需要特殊处理，可以参考其他题解，当然如果没有 $-1$ 操作的话可以不处理，因为不用求逆。

其实递推式里只写了两项，但其实项数更多也是能做的。

考虑如果只有 $f$ 怎么做，我们从手里掏出一个很典的矩阵：
$$
\begin{bmatrix}
f_{i}&f_{i-1}&1
\end{bmatrix}=
\begin{bmatrix}
f_{i-1}&f_{i-2}&1
\end{bmatrix}
\begin{bmatrix}
a_f&b_f&c_f\\
1&0&0\\
0&0&1
\end{bmatrix}
$$
这个操作是将下标加一。

那下标减一呢？发现这个矩阵是满秩的，那么乘上逆矩阵就好了。

区间操作呢？线段树维护区间乘矩阵，区间求矩阵和就好了。

现在回到同时有 $f,g$ 的做法。我们考虑，直接把所有的东西塞进一个矩阵，就像上面那样。

上面的矩阵之所以有 $f_{i-1},f_{i-2},1$ 是因为在算 $f_i$ 时需要用到这些的值。

那么我们现在要求的是 $f_a\times g_b$，修改操作有 $a\pm 1,b\pm 1$ 四种，我们下只以 $a+1$ 操作为例，其他类似。

发现 $f_ag_b=a_ff_{a-1}g_b+b_ff_{a-2}g_b+c_fg_b$，因此可以想到，我们需要维护的量有：$g_{b},f_{a-1}g_b,f_{a-2}g_b$。

类似的，在 $b+1$ 中，我们也需要用到量 $f_ag_{b-1},f_ag_{b-2},f_a$。

同时，为了计算 $f_a,g_b$，可以观察到需要用量 $f_{a-1},f_{a-2},g_{b-1},g_{b-2},1$。

因此，矩阵就呼之欲出了。

以 $f$ 的指数 $+1$ 为例。

（为了好看就写成竖着的了，其实竖着的列向量都是行向量。）

我们从裤裆里掏出转移矩阵：
$$
\begin{bmatrix}
f_ag_b\\
f_{a-1}g_b\\
f_{a}g_{b-1}\\
f_{a-1}g_{b-1}\\
f_{a}\\
f_{a-1}\\
g_{b}\\
g_{b-1}\\
1
\end{bmatrix}=
\begin{bmatrix}
f_{a-1}g_b\\
f_{a-2}g_b\\
f_{a-1}g_{b-1}\\
f_{a-2}g_{b-1}\\
f_{a-1}\\
f_{a-2}\\
g_{b}\\
g_{b-1}\\
1
\end{bmatrix}
\begin{bmatrix}
a_f&b_f&0&0&0&0&c_f&0&0\\
1&0&0&0&0&0&0&0&0\\
0&0&a_f&b_f&0&0&0&c_f&0\\
0&0&1&0&0&0&0&0&0\\
0&0&0&0&a_f&b_f&0&0&c_f\\
0&0&0&0&1&0&0&0&0\\
0&0&0&0&0&0&1&0&0\\
0&0&0&0&0&0&0&1&0\\
0&0&0&0&0&0&0&0&1\\
\end{bmatrix}
$$
设这个转移矩阵为 $F$。

在 $a,b\neq 0$ 时，矩阵是满秩的，所以如果要 $-1$ 的话就乘上 $F^{-1}$ 即可。

那么设初始向量为 $v$，每操作一次就乘上一个转移矩阵即可。剩下的和之前一样线段树维护即可。

做完了吗？可能会发现有一个小问题：$ABA^{-1}=B$ 一般不成立，也即如果我们想要撤销 $A$ 这一次操作，我们需要的运算应该为 $A^{-1}AB$。这当然可以分成左右两边分别维护，但这样拓展性有限。

我们发现这样一个事情：你先 $F$ 操作，再 $G$ 操作，效果是 $f_{a+1}g_{b+1}$。这和先 $G$ 再 $F$ 的效果是一样的。

因此，我们可以直接交换。换句话说，此处的矩阵乘法具有交换律。严谨的证明貌似要扯到张量，但我不会。

那么就可以直接维护了，复杂度为 $O(n\log nk^3)$，$k=9$。~~（然后你发现太慢了过不了。）~~

那这种做法的好处是什么呢？

发现这种做法不局限于两项，你不仅仅可以是 $\sum fg$，还可以是 $\sum fgh$，$\sum f_1f_2f_3f_4$，等等，同样可以大力写出矩阵直接转移。

设我们要求的是 $\sum\limits_*\prod\limits_{i=1}^mf_{i,*}$，矩阵的大小就是 $3^m\times 3^m$，复杂度就是 $O(n\log n3^{3m})$。

听说可以优化到 $O(n\log n3^{m+1})$，但我不会。

没有代码，因为跑得太慢了，如果有人用这种做法过了请踹我。

---


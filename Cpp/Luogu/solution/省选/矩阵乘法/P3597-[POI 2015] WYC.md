# [POI 2015] WYC

## 题目描述

给定一张 $n$ 个点 $m$ 条边的带权有向图，每条边的边权只可能是 $1$，$2$，$3$ 中的一种。

将所有可能的路径按路径长度排序，请输出第 $k$ 小的路径的长度，注意路径不一定是简单路径，即可以重复走同一个点。

## 说明/提示

**【样例解释】**

长度为 $1$ 的路径有 $1\to 2$，$5\to 3$，$4\to 5$。长度为 $2$ 的路径有 $2\to3$，$3\to4$，$4\to5\to3$。长度为 $3$ 的路径有 $4\to6$，$1\to2\to3$，$3\to4\to5$，$5\to3\to4$。长度为 $4$ 的路径有 $5\to3\to4\to5$。

----

原题名称：Wycieczki。

## 样例 #1

### 输入

```
6 6 11
1 2 1
2 3 2
3 4 2
4 5 1
5 3 1
4 6 3```

### 输出

```
4```

# 题解

## 作者：木xx木大 (赞：15)

[P3597 [POI2015]WYC](https://www.luogu.com.cn/problem/P3597)

首先，发现点数和边权都很小，于是我们按照套路拆点+矩乘：把一个点拆成 $u_1,u_2,u_3$ ，连边 $u_3\rightarrow u_2,u_2\rightarrow u_1$，对于一条给定的边 $(u,v,w)$ ，连边 $(u_1,v_w)$。

如果直接求这个转移矩阵的 $d$ 次方，那么求出的矩阵中的值 $(u_1,v_1)$ 表示 $u\rightarrow v$  走过的路径长恰好为 $d$ 的方案数。 为了方便判断，我们需要求出路径长 $\le d$ 的方案数之和。那么我们**建一个超级汇点0**，连边 $(u_1,0)$，超级汇点处的方案数就是全局的方案数。**为了保留上一次得到的答案，我们再连边 $(0,0)$。**这样， $(0,0)$ 处的值就是路径长 $\le d$ 的方案数之和。

$k$ 太大，如果一个一个乘，复杂度不对；于是我们倍增优化即可。倍增这块其他题解写得很清楚，这里就不再赘述了。

```cpp
#include<bits/stdc++.h>
#define ld long double
#define ll long long
using namespace std;
namespace FGF
{
	int n,m;
	ll K,ans;
	struct matrx{
		ld a[130][130];
	}g[110],A;
	matrx operator *(matrx x,matrx y)
	{
		matrx s;memset(s.a,0,sizeof(s.a));
		for(int i=0;i<=3*n;i++)
			for(int j=0;j<=3*n;j++)
				for(int k=0;k<=3*n;k++)
					s.a[i][j]+=x.a[i][k]*y.a[k][j];
		return s;
	}
	void work()
	{
		scanf("%d%d%lld",&n,&m,&K);
		for(int i=1;i<=n;i++)
			A.a[0][(i-1)*3+1]=g[0].a[(i-1)*3+1][0]=g[0].a[(i-1)*3+2][(i-1)*3+1]=g[0].a[(i-1)*3+3][(i-1)*3+2]=1;
		g[0].a[0][0]=1;
		for(int i=1;i<=m;i++)
		{
			int u,v,w;
			scanf("%d%d%d",&u,&v,&w);
			g[0].a[(u-1)*3+1][(v-1)*3+w]++;
		}
		int d;
		for(d=1;;d++)
		{
			g[d]=g[d-1]*g[d-1];
			matrx tmp=A*g[d];
			if(tmp.a[0][0]-n>=K)break;
			if(d>=64)
			{
				puts("-1");
				return;
			}
		}
		for(;d>=0;d--)
		{
			matrx tmp=A*g[d];
			if(tmp.a[0][0]-n<K)A=tmp,ans+=(1LL<<d);
		}
		printf("%lld",ans);
	}
}
int main()
{
	FGF::work();
	return 0;
}
```

---

## 作者：Alex_Wei (赞：10)

> [P3597 [POI2015]WYC](https://www.luogu.com.cn/problem/P3597)
>
> [POI 合集](https://www.cnblogs.com/alex-wei/p/POI.html)。

非常显然的矩阵快速幂，由于边权只有 $3$ 所以拆点，存储 $f_{i,j},f_{i,j+1}$ 和 $f_{i,j+2}$ 表示以 $i$ 结尾的长度为 $j,j+1,j+2$ 的路径数量。最后再计一个 $sum$ 表示路径总数，得到转移矩阵 $B$。

预处理出 $B^1,B^2,\cdots,B^{61}$，然后倍增求解即可。时间复杂度 $\mathcal{O}(n^3\log k)$，有 $27$ 倍常数。注意矩阵每个数在任何时候都要对 $k$ 取 $\min$。

```cpp
const int N = 120 + 5;
const ll inf = 2e18;

ll n, m, k, sz;
void add(ll &x, ll y) {x += y; if(x > inf) x = inf;}
ll mul(ll x, ll y) {return !y ? 0 : x > inf / y ? inf : x * y;}
struct Mat {
	ll a[N][N];
	Mat operator * (Mat x) {
		Mat y; mem(y.a, 0, sz + 1);
		for(int i = 1; i <= sz; i++)
			for(int j = 1; j <= sz; j++)
				for(int k = 1; k <= sz; k++)
					add(y.a[i][j], mul(a[i][k], x.a[k][j]));
		return y;
	}
	Mat operator / (Mat x) {
		Mat y; mem(y.a, 0, sz + 1);
		for(int i = 1; i <= sz; i++)
			for(int j = 1; j <= sz; j++)
				add(y.a[1][i], mul(a[1][j], x.a[j][i]));
		return y;
	}
} base, pw[N], I;

bool Med;
int main(){
	cin >> n >> m >> k, sz = n * 3 + 1;
	for(int i = 1; i <= n; i++) I.a[1][i] = 1;
	for(int i = 1; i <= m; i++) {
		int u, v, w; cin >> u >> v >> w;
		base.a[u][v + (w - 1) * n]++;
	} base.a[sz][sz] = 1;
	for(int i = 1; i < sz; i++) {
		if(i > n) base.a[i][i - n]++;
		for(int j = 1; j <= n; j++)
			base.a[i][sz] += base.a[i][j];
	} pw[0] = base;
	ll ans = 0, d = 0;
	while((I / pw[d]).a[1][sz] < k) {
		d++, pw[d] = pw[d - 1] * pw[d - 1];
		if(d > 61) puts("-1"), exit(0);
	}
	while(~(--d)) {
		Mat nw = I / pw[d];
		if(nw.a[1][sz] < k) ans += 1ll << d, I = nw;
	} cout << ans + 1 << endl;
	return 0;
}
```

---

## 作者：Planetary_system (赞：8)

## 题面解释：
一个有向图，边权为 $1$，$2$，$3$ 中的一个，求第 $k$ 短路径的长度。

## 思路分析：
对于可以重复走的第 $k$ 短路径，我们优先考虑矩阵，把边加到矩阵里做乘法即可。而边权的范围不难想到拆点，即把点 $i$ 拆成 $i_1$，$i_2$，$i_3$ 三个点，这样就保证了短的路径先走到。

而此处 $k$ 很大，所以需要倍增，把答案二进制拆分，先从前往后找到边界，再从后往前计算答案。

注意矩阵里要用 `long double`，不然会悲剧 $79\text{ pts}$，别问我怎么知道，调了三天。
## Code
```cpp
#include<bits/stdc++.h>
#define int long long 
using namespace std;
int n,m,k,ans;
struct mt{
	long double d[130][130];
	mt(){memset(d,0,sizeof(d));}
}mp[100],o,w;
const mt operator *(const mt &a,const mt &b){
	mt c;
	for(int i=0;i<=3*n;i++)
		for(int j=0;j<=3*n;j++)
			for(int l=0;l<=3*n;l++)
				c.d[i][j]+=a.d[i][l]*b.d[l][j];
	return c;
}
signed main(){
	scanf("%lld%lld%lld",&n,&m,&k);
	for(int i=1;i<=n;i++)
		mp[0].d[i][0]=mp[0].d[i][i+n]=mp[0].d[i+n][i+2*n]=1;
	mp[0].d[0][0]=1;
	for(int i=0;i<=n;i++)
		o.d[0][i]=1;
	for(int i=1,u,v,w;i<=m;i++)
		scanf("%lld%lld%lld",&u,&v,&w),
		mp[0].d[u+n*(w-1)][v]++;
	int log=1;
	for(;;log++){
		mp[log]=mp[log-1]*mp[log-1];
		w=o*mp[log];
		if(w.d[0][0]-n-1>=k)break;
		if(log>64){
			printf("-1");
			return 0;
		}
	}
	for(log--;log>=0;log--){
		w=o*mp[log];
		if(w.d[0][0]-n-1<k)o=w,ans|=(1ll<<log);
	}
	printf("%lld",ans);
	return 0;
}
```

谢谢！

---

## 作者：yijan (赞：8)

~~下面那个题解竟然能过。。。。~~


本人trl，不会a*启发式搜索。。

看到权值1，2，3显然拆点。不会？移步[4159](https://www.luogu.org/problemnew/show/P4159)

然后既然要问你第k短路径，可以考虑枚举长度为1路径有多少，长度为2有多少，找到第一个长度使得路径个数达到k

> 凡一步一步跳的都考虑倍增

然后就显然想到了倍增。

倍增处理后再一个一个减下来，复杂度降到log

最终复杂度~~大概~~是~~O(跑得过)~~$O(n^3logk)$

当然，有个坑是你不能把拆点拆出的新点用来做路径终点QAQ
因为这个点根本不存在

然后如果倍增到了65还没发现大于k($2^{65}$已经炸了）肯定无解。

细节很多 处理一下~~因为一个中间变量没开longlongwa了几十遍~~

```cpp
/*Heroes Never Die!*/
#include "iostream"
#include "algorithm"
#include "cstring"
#include "cstdio"
using namespace std;
#define MAXN 125
#define P 1000000000
typedef long long ll;
ll n , t , k;

struct matrx { ll a[MAXN][MAXN]; } G[70] , tmp , cur , inf ;

bool work( matrx& a ){
    ll p = 0;
    for( ll i = 1 ; i <= n ; ++ i )
        if( (k <= (p += a.a[i][0] - 1)) ) return true;
    return false;
}

void mul( matrx& x , matrx& y ) {
    for( ll i = 0 ; i <= 3*n ; ++ i )
        for( ll j = 0 ; j <= 3*n ; ++ j ) {
            tmp.a[i][j] = 0;
            for( ll p = 0 ; p <= 3*n ; ++ p ) 
                tmp.a[i][j] += x.a[i][p] * y.a[p][j];
        }
}


int main() {
    //freopen("input","r",stdin);
    ll m;
    cin >> n >> m >> k;
    G[0].a[0][0] = 1;
    for( ll i = 1 ; i <= n ; ++ i ) cur.a[i][i] = G[0].a[i][0] = G[0].a[i][i+n] = G[0].a[i+n][i+2*n] = 1;
    for( ll i = 0,u,v,w ; i < m ; ++ i ) {
        scanf("%lld%lld%lld",&u,&v,&w);
        ++ G[0].a[u+(w-1)*n][v];
    }
    ll i;
    for( i = 1 ;  ; ++ i ) {
        if( i > 65 ) return puts("-1"),0;
        mul( G[i-1] , G[i-1] ) , G[i] = tmp;
        if(work( G[i] )) break;
    }
    long long ans = 0;
    for( i-- ; ~i ; --i ) {
        mul( cur , G[i] );
        if( !work(tmp) ) cur = tmp , ans += (1ll<<i);
    }
    cout << ans ;
}
//qwq



```

---

## 作者：Jayun (赞：7)

# 链接：

[题目](https://www.luogu.com.cn/problem/P3597)

[博客园](https://www.cnblogs.com/GJY-JURUO/p/13551825.html)

# 题目大意：

给定一个 $n$ 个点 $m$ 条边的带权**有向图**，每条边的边权为 $w\quad(w\in\{1,2,3\})$，将所有可能路径按边权排序，输出第 $k$ 小路径权值。

# 正文：

此题为 [NOI2020D1T1](https://www.cnblogs.com/GJY-JURUO/p/13541730.html) 的阉割版本，设一个矩阵数组 $F_k$，其中每一个 $(u,v)$ 表示从 $u$ 到 $v$ 路径长度为 $2^k$ 的路径有多少条，特别
地，$(i,0)$ 表示以 $i$ 为终点的长度为 $2^k$ 的路径有多少条。用倍增的方法，转移 $2^k$ 次后的矩阵，再从大到小加回来。但显然直接做是不可能的，因为有边权。但是题目给出边权 $w\in\{1,2,3\}$，考虑拆点。

还有一件事，如果倍增到 $2^65$ 还没发现大于 $k$ 的直接输 $-1$。

# 代码：

代码没卡常，开 O2 过了，这个题需要稍微卡卡常。

```cpp
struct matrix
{
	ll mat[N * 3][N * 3];
	inline ll* operator [] (int b) { return mat[b];}
	matrix(){ memset(mat, 0, sizeof mat);}
}F[logT + 5], tmp, now;
int n, m;
ll k, ans;

inline matrix operator * (matrix &a, matrix &b)
{
	matrix c; 
	for (int k = 0; k <= 3 * n; k++)
		for (int i = 0; i <= 3 * n; i++)
			for (int j = 0; j <= 3 * n; j++)
				c[i][j] += a[i][k] * b[k][j];
	return c;
}


bool check (matrix a)
{
	ll sum = 0;
	for (int i = 1; i <= n; i++)
		if(k <= (sum += a[i][0] - 1)) return 1;
	return 0;
}

signed main()
{
	scanf ("%d%d%lld", &n, &m, &k);
	for (int i = 1; i <= n; i++)
	{
		F[0][i][0] = F[0][i][i + n] = F[0][i + n][i + 2 * n] = 1;
	}
	for (int i = 1; i <= m; i++)
	{
		int u, v, w;
		scanf ("%d%d%d", &u, &v, &w);
		++F[0][u + n * (w - 1)][v];
	}
	F[0][0][0] = 1; 
	int logt = 1;
	for (; logt < logT + 5; logt++)
	{
		if(logt > 65)
		{
			puts("-1");
			return 0;
		}
		F[logt] = F[logt - 1] * F[logt - 1];
		if(check(F[logt])) break;
	}
	for (int i = 0; i <= 3 * n; i++)
		now[i][i] = 1;
	for (; --logt >= 0; )
	{
		tmp = now * F[logt];
		if(!check(tmp)) now = tmp, ans += (1ll << logt);
	}
	printf("%lld", ans);
	return 0;
}

```

---

## 作者：JohnJoeZhu (赞：4)

[题面传送门](https://www.luogu.com.cn/problem/P3597)

前排推销：[矩阵知识点总结（包括这道题及其前置知识）](https://www.luogu.com.cn/blog/JohnJoeZHU/ju-zhen-tai-fa)

### 1.解题思路
拆分问题，逐一突破
#### 1）如果边权为1，求长度为k的路径条数
由$n$的范围可以想到邻接矩阵+矩阵乘法

矩阵的使用范围与原因前排有 ~~（又强推~~

那么每一步就是走一次，也就是要走$k$次

根据矩阵乘法的结合律，我们就可以利用快速幂求出该子问题的解，$k=1e18$我也不怕
#### 2）如果边权为1，2，3，求长度为k的路径条数
因为每一步我们就走1个边权，如果边权为3我们就要走3步，那就可以拆点实现了 （例题[P4159 [SCOI2009]迷路](https://www.luogu.com.cn/problem/P4159)）

点与点之间的连边含义还是为1步能走到的点

1）的方法照搬即可
#### 3）如果边权为1，2，3，求第s小的路径的长度

如果长度为1~k的路径条数小于s，那么就求长度为1~k+1的路径条数，每次加上长度为k+1的路径条数即可

可是数据范围使得时间难以承受

那我们能不能考虑$log$的算法呢？

在结合律，逐步递增的启发下，我们可以考虑倍增啊

倍增的可行性基于s的可拆分为2进制的性质

所以可以考虑把$2^n($该步数的路径条数小于s$)$的路径条数预处理，再组合即可

### 2.思路实现

#### 1）矩阵预备

```cpp
struct MA{
	ll a[200][200];
	void print()//调试用
	{
		for(int i=0;i<=3*n;i++)
		{
			for(int j=0;j<=3*n;j++) printf("%lld ",a[i][j]);
			printf("\n");
		}
		printf("\n");
	}
};
MA operator * (const MA x,const MA y)//重载运算符好评
{
	MA z;
	for(int i=0;i<=3*n;i++)//3*n是基于拆点来写的
		for(int j=0;j<=3*n;j++)
		{
			z.a[i][j]=0;
			for(int k=0;k<=3*n;k++)
				z.a[i][j]=z.a[i][j]+x.a[i][k]*y.a[k][j];
		}
	return z;
}
```

#### 2）拆点

```cpp
MA x[100];//x为倍增数组
for(int i=1,u,v,w;i<=m;i++)
{
	scanf("%d%d%d",&u,&v,&w);
	x[0].a[u+(w-1)*n][v]++;//拆点常规操作，让你要走这条边先跳w次
}
x[0].a[0][0]=1;//0为虚拟汇点（因为我们要统计的是全图的条数而不是固定起点和终点
for(int i=1;i<=n;i++) x[0].a[i][0]=x[0].a[i][i+n]=x[0].a[i+n][i+n*2]=1;//前一个为向汇点连边，后两个为拆点的虚点间互相连边
```
#### 3）倍增

```cpp
bool pd(MA z)//判断与目标的大小
{
	ll sum=0;
	for(int i=1;i<=n;i++) if(k<=(sum+=z.a[i][0]-1)) return 1;//只有实点可以作为终点。0为虚拟源点，-1是目标点原来就可以连一条边给汇点
	return 0;
}

for(i=1;;i++)
{
	if(i==65) {printf("-1");return 0;}//超过范围
	x[i]=x[i-1]*x[i-1];//倍增数组
	if(pd(x[i])) break;//求到倍增终点
}
//这里是单位矩阵预处理
for(i--;i>=0;i--)
{
	MA sum=anss*x[i];
	if(!pd(sum)) anss=sum,ans+=(1ll<<i);//sum来组合倍增的结果，如果可以就覆盖（覆盖方式唯一） 
}
```

### 3.最终代码时间（带调试注释，无解释的注释，码风丑勿喷）

```cpp
#include<cstdio>
#include<cstring>
#define ll long long
int n,m;
struct MA{
	ll a[200][200];
	void print()
	{
		for(int i=0;i<=3*n;i++)
		{
			for(int j=0;j<=3*n;j++) printf("%lld ",a[i][j]);
			printf("\n");
		}
		printf("\n");
	}
}x[100],anss;
ll k,ans=0;
MA operator * (const MA x,const MA y)
{
	MA z;
	for(int i=0;i<=3*n;i++)
		for(int j=0;j<=3*n;j++)
		{
			z.a[i][j]=0;
			for(int k=0;k<=3*n;k++)
				z.a[i][j]=z.a[i][j]+x.a[i][k]*y.a[k][j];
		}
	return z;
}
bool pd(MA z)
{
	ll sum=0,flag=0;
//	z.print();
	for(int i=1;i<=n;i++) if(k<=(sum+=z.a[i][0]-1)) flag=1;
//	printf("%lld\n",sum);
	return flag;
}
int main()
{
	scanf("%d%d%lld",&n,&m,&k);
	for(int i=1,u,v,w;i<=m;i++)
	{
		scanf("%d%d%d",&u,&v,&w);
		x[0].a[u+(w-1)*n][v]++;
	}
	x[0].a[0][0]=1;
	for(int i=1;i<=n;i++) x[0].a[i][0]=x[0].a[i][i+n]=x[0].a[i+n][i+n*2]=1;
//	x[0].print();
	int i;
	for(i=1;;i++)
	{
		if(i==65) {printf("-1");return 0;}
		x[i]=x[i-1]*x[i-1];
//		x[i].print();
		if(pd(x[i])) break;
	}
	for(int i=0;i<=3*n;i++) anss.a[i][i]=1;
//	printf("%d\n",i);
	for(i--;i>=0;i--)
	{
		MA sum=anss*x[i];
		if(!pd(sum)) anss=sum,ans+=(1ll<<i); 
	}
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：Tachibana27 (赞：3)

根据 [P4159](https://www.luogu.com.cn/problem/P4159)，我们套路地对本题转化：

先考虑当边权取值 $0$ 或 $1$ 时，我们设 $dp_{i,j,k}$ 表示从 $i$ 走到 $j$ 花费 $k$ 的代价。容易发现转移是简单的。那么有转移 $dp_{i,j,k}=\sum \limits _{k=1} ^n dp_{i,k,t-1}\times dp_{k+1,j,1}$。进一步地展开，有 $dp_t=dp_1 ^t$。拿个矩阵快速幂可以优化到 $O(\log t)$。

若取值更大，我们考虑拆点。有以下拆点方式：

- 对于满足 $1\le x \le n$，我们让 $(x,w)$ 与 $(x,w-1)$ 连边。

- 对于给定的边 $(x,y,w)$，我们让 $(x,0)$ 与 $(y,w-1)$ 连边。

- 当我们查询 $(x,y)$ 的距离时，我们只能查询 $(x,0)$ 到 $(y,0)$ 的距离。

此时我们将取值更多转换成了取值 $0,1$ 的做法。可自行画图理解。

$k$ 非常大，若按照上面的思路我们是必须要枚举 $k$ 的，复杂度无法接受。但由于我们只需要第 $k$ 长的路径，我们可以考虑倍增跳矩阵乘法。

不妨假设我们的矩阵乘法的矩阵为 $I$，我们可以预处理出 $\forall 1\le i\le \log k,I^i$，然后一个一个的减。用倍增优化后可以把 $O(k)$ 降到 $O(\log k)$。

然后，就是数据类型的选择了。

code:

```cpp

int n,m,k;
#define n_ ((n<<1LL)+n)//n*3
class mat{
	public:
		int a[186][186];
		inline void ini(){
			memset(a,0,sizeof a);
			return;
		}
		inline int *operator[](int x){
			return a[x];
		}
		inline friend mat operator*(mat a,mat b){
			mat c;
			c.ini();
			for(int i=0;i<=n_;i++)
				for(int j=0;j<=n_;j++)
					for(int k=0;k<=n_;k++)
						c[i][j]=(c[i][j]+a[i][k]*b[k][j]);//出题人不给mod一点也不良心/kk
			return c;
		}
		inline void print(){
			for(int i=0;i<=n_;i++,puts(""))
				for(int j=0;j<=n_;j++)
					std::cout<<a[i][j]<<" ";
			return;
		}
}bz[186],qwq;
inline int id(int x,int y){
	return ((x-1)<<1)+y+x-1;
}
int ans;
signed main(){
	std::cin>>n>>m>>k;
	for(int i=1;i<=n;i++)
		qwq[0][id(i,1)]=bz[0][id(i,1)][0]=bz[0][id(i,2)][id(i,1)]=bz[0][id(i,3)][id(i,2)]=1;//取值转换的那一部分
	bz[0][0][0]=1;//其中 bz 为倍增。
	for(int i=1;i<=m;i++){
		int u,v,w;
		std::cin>>u>>v>>w;
		bz[0][id(u,1)][id(v,w)]++;//重边所以要用自增
	}
	int point=0;//倍增
	while(++point){
		bz[point]=bz[point-1]*bz[point-1];
		if((qwq*bz[point])[0][0]-n>=k)//如果当前处理的已经超过 k 则不必要处理下去，解一定可以处理出来
			break;
		if(point>64){//特别的，如果超过 64 就断定它无解
			puts("-1");
			exit(0);
		}
	}
	while(point+1){//从大往小考虑 I^point
		if((qwq*bz[point])[0][0]-n<k){//如果小于则一定是答案的一部分
			qwq=qwq*bz[point];
			ans+=(1LL<<point);
		}
		point--;
	}
	std::cout<<ans;
	return 0;//撒花
}

```

---

## 作者：bianshiyang (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P3597)

一道矩阵结合图论的经典题，本篇题解主要讲讲建立超级汇点的原理和倍增上的一些细节，其余部分其他题解已经讲得很好了。

# 分析
为了方便叙述，题面中出现的 $n,m,k$ 在后文均使用大写字母 $N,M,K$ 来表示。且记 $E$ 为原图链接矩阵，用 $E_t(r,c)$表示矩阵 $E^t$ 的第 $r$ 行第 $c$ 列的数字，与之对应的，$E^t$ 就表示 $E_t$。

这题想到矩阵乘法优化并不难，非常的套路，建议看本篇题解之前先通过这道[板子题](https://www.luogu.com.cn/problem/P4159)。然后就发现这题和上面那题的区别就是：本题求的是排名为 $K$ 的路径长度，而那题求的是长度为 $t$ 的个数。这两者可以通过二分互相转化，即二分出来一个长度，判断小于等于这个长度的路径是否小于等于 $K$（这里的 tric 感觉和数位 DP 的差不多感觉）。但是直接二分复杂度可能会退化成 $O(K\log K)$，~~还不如直接枚举~~，所以要舍弃二分而使用倍增来保证复杂度。具体地，我们记 $S_i$ 表示长度小于等于 $2^i$ 的路径总数，提前预处理 $S_i$，然后用这些 $2$ 的幂来凑出最后的答案。

首先可以发现 $E_k$ 保存的是长度恰好为 $k$ 的路径数，那么我们怎么才能求出长度小于等于 $k$ 的路径数呢，这时候就要引入一个超级汇点，比如点 $0$。具体地，我们把每个点都向这个 $0$ 点连边，这样子 $E_k(i,0)$ 保存的就是从 $i$ 出发长度为 $k-1$ 的路径数（长度为 $k-1$ 是因为每个点走向 $0$ 还需要一条边），可是这样子有什么好处呢？明明保存的还是确定长度的方案数啊，但是进一步我们发现如果在 $0$ 上连一个自环，那么很惊奇的是 $E_k(i,0)$ 居然求出了长度小于等于 $k-1$ 的所有方案数。

原理也很好理解，我们可以只考虑扩展一步的情况（因为矩阵乘法满足结合律，所以后面的可以直接归纳法）。直接从图论上理解就是之前长度为 $k-2$ 的路径在进行一次矩阵乘法后可以选择走 $0$ 这条自环，那么长度就变为 $k-1$，于是就把长度为 $k-2$ 的所有路径都加了过来，那么长度为 $k-3$，$k-4$ 的都可以归纳证，而长度本来就为 $k-1$ 的又会新产生也会加进来，所以就可以得到长度小于等于 $k-1$ 的所有路径。如果这部分不好理解的话也可以简单想成长度不足 $k-1$ 的走到 $0$ 之后可以一直跑自环直到长度到达 $k-1$。

如果要从矩阵的角度理解也不难，考虑数学归纳法，需要证的是 $E_k(i,0)$ 为长度小于等于 $k-1$ 的所有路径数，$E_1$ 显然正确，因为每个点就是长度为 $0$ 的方案数，所以所有 $E_1(i,0)$ 都是 $1$，接下来开始归纳。考虑扩展一步，假设是从 $E_{k-1}$ 扩展到 $E_k$，对于任意的 $i$ 都有 $E_k(i,0)=\sum_{j=0}^n E_{k-1}(i,j)E_1(j,0)$，而每个 $E_1(j,0)$ 都是 $1$，所以 $E_k(i,0)$ 就是 $\sum_{j=0}^n E_{k-1}(i,j)$，且正是因为有了 $E_1(0,0)=1$ 才可以把 $E_{k-1}(i,0)$ 加过来，而 $E_{k-1}(i,0)$ 的含义是 $i$ 出发长度小于等于 $k-2$ 的所有路径数，然后再加上后面所有长度等于 $k-1$ 的路径数就可以得到 $E_k(i,0)$ 表示的是所有长度小于等于 $k-1$ 的路径数。

我们如果要求出这个图上所有长度小于等于 $k-1$ 的路径数则需要求出 $E_k(i,0)$ 之和，这个可以直接用一个长为 $N$ 的行向量 $A$ 来乘这个矩阵求出，只需要对 $\forall i>0$ 均有 $A_1(i,0)=1$ 即可。但是我们会发现 $E_k$ 只能求出长度小于 $k$ 的路径数，与我们之前思考的小于等于 $k$ 的不符，所以要稍微改一下倍增，每次倍增之后如果总方案数小于 $K$ 才把这个 $2$ 的幂加上去（而不是小于等于），注意这里算方案数的时候要把长度为 $0$ 的 $N$ 条路去掉。可能有人会有这样子的疑问，既然求出来的是长度小于 $k$ 的，那么每次凑一个 $2$ 的幂长度都会少 $1$，那么不是凑着凑着越来越少不就不对了吗。这样想其实会有点问题，我们要知道 $E_k$ 保存的是扩展 $k$ 次之后的矩阵，此时保留的是长度为 $k$ 的所有点对之间的路径数，只不过用 $A$ 去乘它得到的是小于 $k$ 的路径方案数（因为走到 $0$ 还要耗费一步），而每次倍增乘的矩阵是某个 $E_{2^i}$，这样最后的矩阵就是对的。也就是说假设最后答案为 $t$，那么我们得到的矩阵应该是 $E_t$，这个矩阵是正确的，只是求出来的路径数应该是长度小于 $t$ 的，这样正确性就可以保证了。

讲到这里如果还是不太好理解的可以看下代码，有比较详细的注释。

# 代码实现
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=42;
typedef long long ll;
typedef long double ldb;
int n,m,u,v,w;
ll k,ans;

struct Matrix{
	ldb a[N*3][N*3]={0};//这里要开long double不然会炸，由于最后要减去n求方案数，所以直接对k取min处理起来有点麻烦
	int r,c;
	void init(int x,int y) {r=x,c=y;}
	friend Matrix operator*(Matrix x,Matrix y)
	{
		Matrix z;
		z.r=x.r,z.c=y.c;
		for(int i=0;i<=z.r;i++)
			for(int j=0;j<=z.c;j++)
				for(int k=0;k<=x.c;k++) z.a[i][j]+=x.a[i][k]*y.a[k][j];
		return z;
	}
}dis[65],a0;//dis[i]表示E^(2^i)的矩阵，a0就是上文说的A

int main()
{
	scanf("%d%d%lld",&n,&m,&k);
	for(int i=1;i<=n;i++)
		for(int j=2;j<=3;j++) dis[0].a[3*(i-1)+j][3*(i-1)+j-1]++;//拆点
	while(m--)
	{
		scanf("%d%d%d",&u,&v,&w);
		dis[0].a[3*(u-1)+1][3*(v-1)+w]++;//这部分连边可以直接借鉴迷路那题
	}
	for(int i=1;i<=n;i++) dis[0].a[3*(i-1)+1][0]++,a0.a[0][3*(i-1)+1]++;//每个点向0连边
	dis[0].a[0][0]++;//连0的自环
	dis[0].init(3*n,3*n);a0.init(0,3*n);
	int i;
	for(i=1;;i++)//这部分预处理所有E^(2^i)的矩阵
	{
		dis[i]=dis[i-1]*dis[i-1];
		Matrix a=a0*dis[i];
		if(a.a[0][0]-n>=k) break;//算方案一定要减去n（长度为0）
		if(i>=62)//只要有一条路径存在就可以在这条路径一直走，也就是总路径一定大于等于走的步数，这里2^62已经比k的上界大了就说明无解了
		{
			printf("-1\n");
			return 0;
		}
	}
	for(;i>=0;i--)
	{
		Matrix a=a0*dis[i];
		if(a.a[0][0]-n<k) a0=a,ans+=(1ll<<i);//这里要减去n，而且是小于号，a0存的就是E^ans的矩阵
	}
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：xiaoshumiao (赞：2)

有一个性质，就是把邻接矩阵乘 $p$ 次就相当于在图上走了 $p-1$ 条边。可以通过矩阵乘法的公式来推算。

对于这道题，因为边权只有 $3$，可以把每个点拆成三个点去建边，这样边权都是 $1$ 了。可以直接用上面的公式去算。

但 $k$ 到了 $10^{18}$ 数量级，因此考虑倍增。每次倍增一下就检查当前所有路径是否有 $k$ 条来计算答案。

具体实现见代码。
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=150;
struct Matrix {
    int n,m; unsigned long long a[N][N];
    Matrix() { memset(a,0,sizeof(a)); }
}a[70];
Matrix operator *(Matrix a,Matrix b) {
    Matrix c; c.n=a.n,c.m=b.m;
    for(int i=0;i<=a.n;i++) for(int j=0;j<=b.m;j++) for(int k=0;k<=a.m;k++) c.a[i][j]+=a.a[i][k]*b.a[k][j];
    return c;
}
int main() {
    ios::sync_with_stdio(false),cin.tie(nullptr);
    int n,m; long long k; cin>>n>>m>>k,a[0].n=a[0].m=3*n,a[0].a[0][0]=1;
    for(int i=1;i<=n;i++) a[0].a[i][0]=a[0].a[i][i+n]=a[0].a[i+n][i+(n<<1)]=1;//拆点
    int u,v,w;
    while(m--) cin>>u>>v>>w,a[0].a[u+n*(w-1)][v]++;
    int p=0;
    //倍增
    for(int i=1;i<=64;i++) {
        a[i]=a[i-1]*a[i-1]; unsigned long long sum=0;
        for(int j=1;j<=n;j++) sum+=a[i].a[j][0]-1;
        if(sum>=k) { p=i; break; }
    }
    if(!p) return cout<<"-1",0;
    long long ans=0; Matrix q; q.n=q.m=3*n;
    for(int i=0;i<=q.n;i++) q.a[i][i]=1;
    for(int i=p-1;i>=0;i--) {
        Matrix t=q*a[i]; unsigned long long sum=0;
        for(int j=1;j<=n;j++) sum+=t.a[j][0]-1;
        if(sum<k) q=t,ans|=(1ll<<i);
    }
    cout<<ans;
    return 0;
}
```

---

## 作者：Code_星云 (赞：2)

很容易看出来是矩阵乘法，然后考虑到边权很小，把每个点拆成三个点，然后建立超级源点，用于统计全局答案。然后就可以用矩阵快速幂求出 $2$ 的次幂时的答案。具体的，我们用 $f_i$ 表示走了小于等于 $2^i$ 条边时的方案数。为了维护小于等于，我们对超级源点连自环。

然后是很套路的倍增跳找答案。需要注意的是，这道题在矩阵求方案数时要用 unsigned long long 来维护，不然会 WA 3 个点。

```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
#define int long long

const int N = 205;
int n, m, k, ans;
struct Matrix{
	unsigned long long a[N][N];
	void init(){memset(a, 0, sizeof a);}
};
Matrix operator * (Matrix x, Matrix y){
	Matrix z; z.init();
	for(int i = 0; i <= 3 * n; i ++) 
	  for(int j = 0; j <= 3 * n; j ++)
		for(int k = 0; k <= 3 * n; k ++)
		  z.a[i][j] += x.a[i][k] * y.a[k][j];
	return z;
}
Matrix f[70], Base;

signed main(){
	scanf("%lld %lld %lld", &n, &m, &k); f[0].init(); Base.init();
	for(int i = 1; i <= m; i ++){
		int u, v, w; scanf("%lld %lld %lld", &u, &v, &w);
		f[0].a[u + (w - 1) * n][v] ++;
	}
	for(int i = 1; i <= n; i ++) Base.a[0][i] = f[0].a[i][0] = f[0].a[i][i + n] = f[0].a[i + n][i + 2 * n] = 1;
	f[0].a[0][0] = 1; int i;
	for(i = 1; ; i ++){
		if(i == 65){puts("-1"); return 0;}
		f[i] = f[i - 1] * f[i - 1];
		Matrix tmp = Base * f[i];
		if(tmp.a[0][0] - n >= k) break;
	}
	for(; i >= 0; i --){
		Matrix tmp = Base * f[i];
		if(tmp.a[0][0] - n < k) Base = tmp, ans += (1ll << i);
	}
	printf("%lld\n", ans); return 0;
}
```


---

## 作者：QcpyWcpyQ (赞：1)

本题结合了矩阵快速幂的两个常见优化技巧，拆点 + 倍增预处理转移矩阵的 $2$ 的幂次。

具体地，因为边权最大为 $3$，把每个点 $u$ 拆成三个点 $u,u+n,u+2n$ 并连边 $u\to u+n,u+n\to u+2n$，那么边 $u\to v$ 转化为边 $u+2n\to v$。令得到的转移矩阵为 $G$，求出 $G^d$ 后，矩阵中的值 $(u,v)$ 表示 $u\leadsto v$ 长度恰为 $d$ 的方案数。要求的是全局第 $k$ 短，所以可以建立一个超级汇点 $0$ 来继承所有节点的和，并将所有点向超级汇点连边。为了保留每次得到的答案，将超级汇点连自环。这样 $G^d_{0,0}$ 的值就是长度 $\leq d$ 的方案数。统计答案时，预处理转移矩阵的 $2$ 的幂次并倍增求解。时间复杂度为 $\mathcal O(n^3\log k)$。

---

## 作者：lfxxx (赞：1)

调了一个半小时，原来是快读寄了。

考虑拆点，每个点拆成 $(u_1,u_2,u_3)$ 然后连边 $(u_2,u_1),(u_3,u_2)$ 就可以处理 $1,2,3$ 的边权，然后写出图对应的矩阵，做 $k$ 次乘法得到走 $k$ 步的方案数，然后建出超级汇点 $0$，对于每个不是拆出来的点 $u$ 连边 $(u,0)$，然后连边 $(0,0)$ 就可以在 $0$ 处计算走不大于 $p$ 步的方案数，然后预处理矩阵从大往小倍增求出最大的 $d$ 使得做不大于 $d$ 步的方案数小于 $k$ 即可。

时间复杂度 $O((n \max(c))^3 \log P)$。

这里 $P$ 是最长路，最长路不存在的话至多为 $k$。也就是其实是 $O(nw)^3 \log \max(m,k))$。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const __int128 inf = 1e18+114;
const int maxn = 200;
//µã i -> 3*i 3*i-1 3*i-2
int n,m,k;
struct Matrix{
    int n,m;
    __int128 a[maxn][maxn];
    Matrix(int N=0,int M=0,int C=0){
        n=N,m=M;
        for(int i=0;i<=n;i++)
            for(int j=0;j<=m;j++) a[i][j]=C;
    }
    Matrix operator*(const Matrix &x)const{
        Matrix res=Matrix(n,x.m,0);
        for(int i=0;i<=n;i++)
            for(int k=0;k<=m;k++)
                for(int j=0;j<=x.m;j++){
                    res.a[i][j]=min(res.a[i][j]+a[i][k]*x.a[k][j],inf);
                }
        return res;
    }
}e;
Matrix _pow[maxn];
int P[maxn];
signed main(){
    cin>>n>>m>>k;
    Matrix c=Matrix(3*n,3*n,0);
    e=Matrix(3*n,3*n,0);
    for(int i=0;i<=3*n;i++) e.a[i][i]=1;
    c.a[0][0]=1;
    for(int i=1;i<=n;i++) c.a[3*i][0]=1,c.a[3*i-2][3*i-1]=1,c.a[3*i-1][3*i]=1;
    for(int i=1;i<=m;i++){
        int u,v,w;
        cin>>u>>v>>w;
        if(w==1) c.a[3*u][3*v]++;
        else if(w==2) c.a[3*u][3*v-1]++;
        else if(w==3) c.a[3*u][3*v-2]++;
    }
    _pow[0]=c;
    P[0]=1;
    for(int i=1;i<=65;i++) _pow[i]=_pow[i-1]*_pow[i-1],P[i]=P[i-1]*2;
    Matrix x=Matrix(0,3*n,0);
    for(int i=1;i<=n;i++) x.a[0][3*i]=1;
    Matrix lwx=x*_pow[65];
    if(lwx.a[0][0]-n<k){
        cout<<-1<<"\n";
        return 0;
    }
    int ans=0;
    for(int i=65;i>=0;i--){
        Matrix New=x*_pow[i];
        if(New.a[0][0]-n<k){
            x=x*_pow[i],ans=ans+P[i];
        }
    }
    cout<<ans<<"\n";
    return 0;
}

```


---

## 作者：_xguagua_Firefly_ (赞：0)

### 分析

首先，我们可以观察到这个边权很小，$k$ 又很大，所以考虑拆点跑矩阵快速幂。将一个点 $u$ 拆成 $( u _ {1},u _ {2},u _ {3} )$，并且 $\forall i \in [1,2],u _ {i + 1}$ 向 $u _ {i}$ 连边。题目中给我们的 $(u,v,w)$ 的边，可以转化为 $(u _ {1},v _ {w},1)$ 的边。

但是，我们需要统计的是经过小于等于 $t$ 条边的方案数，矩阵快速幂算出来的是恰好 $t$ 条边的方案数，所以，我们可以建立一个超级汇点，$i$ 向 $0$ 连边，并且 $0$ 也向 $0$ 连一个自环，这样我们就可以统计小于等于 $t$ 的方案数了。但是，这样会统计到留在汇点的，所以我们再建立一个矩阵 $B$，令 $B _ {0,i} = 1$，在计算方案数的时候原矩阵左乘 $B$ 并减去 $n$，以此保证起点和终点都是原来的点且方案数不会变多。

因为 $k$ 很大，所以我们考虑倍增优化。因为 $2 ^ {65} \gt 10 ^ {18}$，所以在第 $65$ 次倍增还没有答案那就无解。

有些细节，具体见代码。

### Code

```cpp
#include <bits/stdc++.h>
#define int long long
#define getID(u,d) (u + ((d - 1) * n))
using namespace std;

constexpr int MAXN = 200;
int n,m,k,u,v,w,N;
struct Matrix
{
    unsigned int val[MAXN][MAXN]; // 答案可能爆 long long
    Matrix()
    {
        memset(val,0,sizeof(val));
    };
    Matrix operator*(const Matrix &a) const
    {
        Matrix res;
        for(int i = 0;i <= N;i++)
        {
            for(int j = 0;j <= N;j++)
            {
                for(int k = 0;k <= N;k++)
                    res.val[i][j] = (res.val[i][j] + val[i][k] * a.val[k][j]);
            }
        }
        return res;
    }
}g[70],base;
signed main()
{
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    cin >> n >> m >> k;
    N = n * 3;
    for(int i = 1;i <= m;i++)
    {
        cin >> u >> v >> w;
        ++g[0].val[u][getID(v,w)];
    }
    for(int i = 1;i <= n;i++)
        g[0].val[getID(i,2)][i] = g[0].val[getID(i,3)][getID(i,2)] = g[0].val[i][0] = base.val[0][i] = 1;
    g[0].val[0][0] = 1;
    int p = 1;
    for(;;++p)
    {
        if(p >= 65)
        {
            cout << "-1";
            exit(0);
        }
        g[p] = g[p - 1] * g[p - 1];
        Matrix tmp = base * g[p];
        if((tmp.val[0][0] - n) >= k)
            break;
    }
    int ans = 0;
    for(;p >= 0;--p)
    {
        Matrix tmp = base * g[p];
        if(tmp.val[0][0] - n < k)
            base = tmp,ans += (1ll << p); // 如果只用 1 << p 会爆
    }
    cout << ans;
}
```

---

## 作者：roger_yrj (赞：0)

## P3597 [POI2015] WYC

### 题意

给定一个有向图，求第 $k$ 小的路径长度。

### 题解

注意到 $k$ 非常的大，很容易想到矩阵快速幂优化。

如果边权都为 $1$，这题就很容易了，直接写个矩阵优化 Floyd 计数。

注意到边权最大只有 $3$，我们考虑拆点。

我们考虑下面这张图：

![](https://cdn.luogu.com.cn/upload/image_hosting/00l7nwg9.png)

我们将每个点拆成 $3$ 个点，转化成下面这张图：

![](https://cdn.luogu.com.cn/upload/image_hosting/acm32geh.png)

你会发现，原图中 $u$ 到 $v$ 的边的长度等于新图中 $u-0$ 到 $v-0$ 的距离。

为了方便统计答案，我们建超级源点和超级汇点，然后直接矩阵优化 Floyd 即可。

### 代码

```cpp
#include<bits/stdc++.h>
#define ld long double
#define P(x,y) (x+(y)*n)
#define ll long long
using namespace std;
const int N=210;
int n,m;ld k;
struct mat{
	ld t[N][N];
}A,B,mt[100];
mat operator*(mat x,mat y){
	mat ret;
	for(int i=0;i<=3*n+1;i++){
		for(int j=0;j<=3*n+1;j++){
			ret.t[i][j]=0;
			for(int k=0;k<=3*n+1;k++){
				ret.t[i][j]=ret.t[i][j]+x.t[i][k]*y.t[k][j];
			}
		}
	}
	return ret;
}
int main(){
	cin>>n>>m>>k;
	for(int i=1;i<=n;i++)B.t[P(i,2)][P(i,1)]=B.t[P(i,1)][P(i,0)]=B.t[P(i,0)][0]=1;
	for(int i=1,u,v,w;i<=m;i++){
		cin>>u>>v>>w;
		B.t[u][P(v,w-1)]++;
	}B.t[0][0]=1;
	for(int i=1;i<=n;i++)A.t[3*n+1][i]=1;
	ll ans=0;
	mt[0]=B;
	int i=1;
	for(;;i++){
		if(i>60){
			cout<<"-1";
			return 0; 
		}
		mt[i]=mt[i-1]*mt[i-1];
		mat tmp=A*mt[i];
		if(tmp.t[3*n+1][0]-n>=k)break;
	}
	for(;i>=0;i--){
		mat tmp=A*mt[i];
		if(tmp.t[3*n+1][0]-n<k)A=tmp,ans|=(1ll<<i);
	}
	cout<<ans;
}
```

---


# [六省联考 2017] 组合数问题

## 题目描述

组合数 $C_n^m$ 表示的是从 $n$ 个互不相同的物品中选出 $m$ 个物品的方案数。举个例子， 从 $(1, 2, 3)$ 三个物品中选择两个物品可以有 $(1, 2)$，$(1, 3)$，$(2, 3)$ 这三种选择方法。根据组合数的定义，我们可以给出计算组合数  $C_n^m$  的一般公式：

$$ C_n^m = \frac {n!} {m! \ (n - m)!}  $$

其中 $n! = 1 \times 2 \times \cdots \times n$。（特别地，当 $n = 0$ 时，$n! = 1$；当 $m > n$ 时，$C_n^m = 0$。）

小葱在 NOIP 的时候学习了 $C_i^j$ 和 $k$ 的倍数关系，现在他想更进一步，研究更多关于组合数的性质。小葱发现，$C_i^j$ 是否是 $k$ 的倍数，取决于 $C_i^j \bmod k$ 是否等于 $0$，这个神奇的性质引发了小葱对 $\mathrm{mod}$ 运算（取余数运算）的兴趣。现在小葱选择了是四个整数 $n, p, k, r$，他希望知道

$$\left( \sum_{i = 0}^\infty C_{nk}^{ik + r} \right) \bmod p,$$

即

$$\left( C_{nk}^{r} + C_{nk}^{k + r} + C_{nk}^{2k + r} + \cdots + C_{nk}^{(n - 1)k + r}  + C_{nk}^{nk + r} + \cdots \right) \bmod p$$

的值。

## 说明/提示

对于 $30\%$ 的测试点，$1 \leq n, k \leq 30$，$p$ 是质数；   
对于另外 $5\%$ 的测试点，$p = 2$；  
对于另外 $5\%$ 的测试点，$k = 1$；  
对于另外 $10\%$ 的测试点，$k = 2$；  
对于另外 $15\%$ 的测试点，$1 \leq n \leq 10^3, 1 \leq k \leq 50$，$p$ 是质数；  
对于另外 $15\%$ 的测试点，$1 \leq n \times k \leq 10^6$，$p$ 是质数；  
对于另外 $10\%$ 的测试点，$1 \leq n \leq 10^9, 1 \leq k \leq 50$，$p$ 是质数；  
对于 $100\%$ 的测试点，$1 \leq n \leq 10^9, 0 \leq r < k \leq 50, 2 \leq p \leq 2^{30} - 1$。


## 样例 #1

### 输入

```
2 10007 2 0```

### 输出

```
8```

## 样例 #2

### 输入

```
20 10007 20 0```

### 输出

```
176```

# 题解

## 作者：jiangly (赞：102)

#### 题意

给定 $n$, $p$, $r$, $k$ ($1\le n\le 10^9$, $0\le r<k\le 50$, $2\le p\le 2^{30}-1$)，求
$$
\sum_{i\bmod k=r}{nk\choose i}\bmod p
$$

#### 题解

$$
\begin{aligned}&\sum_{i\bmod k=r}{nk\choose i}\\=&\sum_{i\bmod k=r}[x^i](1+x)^{nk}\\=& [x^r]\left((1+x)^{nk}\bmod(x^k-1)\right)\end{aligned}
$$

直接循环卷积快速幂，时间复杂度 $O(k^2(\log n+\log k))$。

#### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int p, k;
vector<int> operator*(const vector<int> &lhs, const vector<int> &rhs) {
    vector<int> result(k);
    for (int i = 0; i < k; ++i)
        for (int j = 0; j < k; ++j)
            result[(i + j) % k] = (result[(i + j) % k] + 1LL * lhs[i] * rhs[j]) % p;
    return result;
}
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n, r;
    cin >> n >> p >> k >> r;
    vector<int> a(k), ans(k);
    if (k == 1) {
        a[0] = 2 % p;
    } else {
        a[0] = a[1] = 1;
    }
    ans[0] = 1;
    auto e = 1LL * n * k;
    while (e > 0) {
        if (e & 1)
            ans = ans * a;
        a = a * a;
        e >>= 1;
    }
    cout << ans[r] << endl;
    return 0;
}
```



---

## 作者：Marser (赞：42)

首先，题目要我们求的是这玩意儿：
$$\sum_{i=1}^\infty C_{nk}^{ik+r}$$
这一坨不是那么好弄，我们观察数据范围，发现$k,r$的范围出奇的小，自然会想到求通项或者矩阵优化。

我们考虑上面这个式子的组合意义，它相当于在$nk$个不同物品中选出$t$个，且满足$t\bmod k = r$的方案数。考虑设计状态$f_{i,j}$表示当前考虑到前$i$个物品，所选数量$\bmod~k$的余数为$j$的方案数，对于第$i$个物品有选与不选两种转移，就可以得出比较显然的转移方程：
$$f_{i,j} = f_{i-1,j} + f_{i-1,j-1}$$
我们发现在每一轮转移过程中，每次转移都只与$f_{i-1}$有关，所以考虑用矩阵来加速转移。很容易推出这样一个转移矩阵：
$$ \begin{bmatrix} f_{nk,0}\\  	f_{nk,1}\\  	f_{nk,2}\\  	\vdots  \\  	f_{nk,k}\\  	\end{bmatrix} = \begin{bmatrix} 1 & 0 & \cdots & 0 & 1 \\ 1 & 1 & 0 & \cdots & 0 \\ 0 & 1 & 1 & \cdots & 0 \\ \vdots & \ddots & \ddots & \ddots & \vdots \\ 0 & 0 & \cdots & 1 & 1 \\ \end{bmatrix}^{nk} \begin{bmatrix} 1\\  	0\\  	0\\  	\vdots  \\  	0\\  	\end{bmatrix} $$
然后就做完了。个人觉得没有什么难点，有点虚高。

但是本题还有一个坑点：当$k=1$时，矩阵退化成单个变量，而此时如果采用赋值的初始化方法就会挂。可以将赋值改为自加，也可以特判过掉。

```cpp
//丑陋的代码
#include<bits/stdc++.h>
#define reg register
#define F(i,a) for(reg int i=0;i<a;i++)
typedef long long ll;
using namespace std;
int n,p,k,r;
int A[55][55],R[55][55],T[55][55];
int main(){
	scanf("%d%d%d%d",&n,&p,&k,&r);const int mod=p;
	F(i,k)A[i][i]++,A[i][(i-1+k)%k]++,R[i][i]=1;reg ll b=1ll*n*k;
	while(b){
		if(b&1){
			F(i,k)F(j,k)T[i][j]=R[i][j],R[i][j]=0;
			F(i,k)F(j,k)F(l,k)R[i][j]=(R[i][j]+1ll*A[i][l]*T[l][j]%mod)%mod;
		}
		F(i,k)F(j,k)T[i][j]=A[i][j],A[i][j]=0;b>>=1;
		F(i,k)F(j,k)F(l,k)A[i][j]=(A[i][j]+1ll*T[i][l]*T[l][j]%mod)%mod;
	}
	printf("%d\n",R[0][r]);
	return 0;
}
```

---

## 作者：nofind (赞：7)

题意：https://www.luogu.org/problem/P3746

考虑该式子的组合意义:在n*k个物品中选出t个使得t%K==r

可以设计DP:f[i][j]->从i个物品中取%K==j个物品的方案数

j!=0 f[i][j]=f[i-1][j-1]+f[i-1][j]

j=0 f[i][j]=f[i-1][K-1]+f[i-1][j]

发现都是从i-1转移的齐次递推,自然可以矩乘优化

如图（以k==4为例）: ![](https://cdn.luogu.com.cn/upload/pic/72501.png )

细节注意:K=1时写法的问题:

错误:
```
for(int i=0;i<K;i++)B[i][i]=B[(i-1+K)%K][i]=1;
```
正确:

```
for(int i=0;i<K;i++)B[i][i]++,B[(i-1+K)%K][i]++;
```
原因:你输出矩阵看看就知道了,给你个数据点:

input
```
6 572660339 1 0
```
output
```
64
```
wrong ans
```
1
```

code：

```
#include<bits/stdc++.h>
using namespace std;
#define int long long 
const int maxk=60;
int n,p,K,r;
struct Mat
{
	int a[maxk][maxk];
	int* operator[](int i){return a[i];}
	Mat (int x=0)
	{
		for(int i=0;i<K;i++)
			for(int j=0;j<K;j++)
				a[i][j]=x;
	}
	inline void idx(){for(int i=0;i<K;i++)a[i][i]=1;}	
};
Mat operator *(Mat a,Mat b)
{
	Mat res;
	for(int i=0;i<K;i++)
		for(int j=0;j<K;j++)
			for(int k=0;k<K;k++)
				res[i][j]=(res[i][j]+a[i][k]*b[k][j]%p)%p;
	return res;	
}
Mat operator ^(Mat a,int k)
{
	Mat res;res.idx();
	while(k)
	{
		if(k&1)res=res*a;
		a=a*a;k>>=1;
	}
	return res;
}
signed main()
{
	Mat A,B;
	scanf("%lld%lld%lld%lld",&n,&p,&K,&r);
	A[0][0]=1;
	for(int i=0;i<K;i++)B[i][i]++,B[(i-1+K)%K][i]++;
	A=A*(B^(n*K));
	printf("%lld",A[0][r]);
	return 0;
}
```


---

## 作者：UltiMadow (赞：6)

过的第350道题，写个题解庆祝一下

### 前言
翻了翻题解发现全部都是矩阵乘法，复杂度都是 $O(k^3logn)$，于是我来补一篇复杂度 $O(k^2logn)$ 的做法

不过在看这篇题解前，请尽量先理解矩阵乘法的做法，因为我就不再细说矩阵乘法的做法了

### 解法
我们先来康康矩阵乘法的递推式：
$$
f[i][j]=\sum(f[i-1][l]\times f[i-1][(j-l+k)\%k])
$$
其中 $0\le l<k$

我们发现，既然我们可以从第 $i-1$ 个状态转移，那么我们是不是可以考虑把两个状态合并呢？

于是，我们推出了下面的式子：
$$
f[i_1+i_2][j]=\sum(f[i_1][l]\times f[i_2][(j-l+k)\%k])
$$
其中对于任意的 $i_1+i_2=i$ 都可以通过上面的表达式由 $i_1$ 和 $i_2$ 推出 $i$

那么，如何选择 $i_1$ 和 $i_2$ 就成了本题的一个关键的问题

我们发现，当 $i$ 为偶数时，我们可以选 $i_1=i_2=\frac{i}{2}$ 时我们只需要通过一组 $f[i_1]$ 的数据就可以得到 $f[i]$ 了，这样就可以大大减少本题的计算量

接下来我们就可以采用快速幂的方法来进行转移了（具体在代码里说明）

### 代码
```cpp
#include<bits/stdc++.h>
#define int long long//其实本题可以不用long long
using namespace std;
int n,k,r,p;
int c[110][110];
struct Node
{
	int a[110];
}f;
Node operator * (Node x,Node y)
{
	Node ret;
	for(int i=0;i<100;i++)ret.a[i]=0;
	for(int i=0;i<k;i++)
		for(int j=0;j<k;j++)
			ret.a[i]=(ret.a[i]+x.a[j]*y.a[(i-j+k)%k])%p;
	return ret;
}
Node qpow(Node x,int y)//快速幂
{
	Node ret=x;//初始我们传入的x是f[1]的情况
	while(y)//这里，我们把每一次乘法看成一次转移，y就是转移次数
	{
		if(y%2==1)ret=ret*x;
		x=x*x;y>>=1;
	}
	return ret;
}
signed main()
{
	scanf("%lld%lld%lld%lld",&n,&p,&k,&r);
	c[1][1]=1;
	for(int i=2;i<=k+1;i++)
		for(int j=1;j<=i;j++)
			c[i][j]=(c[i-1][j-1]+c[i-1][j])%p;
	for(int i=0;i<k;i++)
		f.a[i]=c[k+1][i+1];//f[1][i]就是C(k,i)的组合数
	f.a[0]++;
	printf("%lld",qpow(f,n-1).a[r]%p);
	return 0;
}
```

---

## 作者：Karry5307 (赞：6)

### 题意

给定 $n,p,k,r$，求：

$$\left(\sum\limits_{i=0}^{\infty}\binom{nk}{ik+r}\right)\bmod p$$

$\texttt{Data Range}:1\leq n\leq 10^9,1\leq r<k\leq 50,p\leq 2^{30}-1$

### 题解

题解区里只有一篇循环卷积的题解，那我就来写一篇吧。

考察这么个东西：

$$F(x)=(1+x)^{nk}=\sum\limits_{i=0}^{nk}\binom{nk}{i}x^i$$

注意到我们要求的其实就是这个东西：

$$\sum\limits_{i=0}^{\infty}[x^{ik+r}]F(x)$$

然后这个东西可以循环卷积求，循环卷积快速幂的话复杂度为 $O(k^2(\log k+\log n))$，但是存在一个比这个较为优秀的做法。

注意到 $k\leq 50$，而且 $\dbinom{50}{25}=126410606437752$ 不会爆 `long long`，所以可以先杨辉三角将 $(1+x)^k$ 的系数求出来再循环卷积快速幂，时间复杂度 $O(k^2+k^2\log n)$。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef int ll;
typedef long long int li;
const ll MAXN=51;
ll n,MOD,kk,r;
ll f[MAXN],res[MAXN];
li binom[MAXN][MAXN];
inline ll read()
{
    register ll num=0,neg=1;
    register char ch=getchar();
    while(!isdigit(ch)&&ch!='-')
    {
        ch=getchar();
    }
    if(ch=='-')
    {
        neg=-1;
        ch=getchar();
    }
    while(isdigit(ch))
    {
        num=(num<<3)+(num<<1)+(ch-'0');
        ch=getchar();
    }
    return num*neg;
}
inline void conv(ll *f,ll *g,ll *res)
{
	static ll tmp[2*MAXN];
	for(register int i=0;i<kk;i++)
	{
		for(register int j=0;j<kk;j++)
		{
			tmp[i+j]=(tmp[i+j]+(li)f[i]*g[j])%MOD;
		}
	}
	for(register int i=2*kk-1;i>=0;i--)
	{
		i>=kk?tmp[i-kk]=(tmp[i-kk]+tmp[i])%MOD,tmp[i]=0:res[i]=tmp[i];
	}
	memset(tmp,0,sizeof(tmp));
}
int main()
{
    n=read(),MOD=read(),kk=read(),r=read(),binom[0][0]=res[0]=1,f[0]=2;
    for(register int i=1;i<=kk;i++)
    {
    	binom[i][0]=1;
    	for(register int j=1;j<=kk;j++)
    	{
    		binom[i][j]=binom[i-1][j-1]+binom[i-1][j];
		}
	}
	for(register int i=1;i<kk;i++)
	{
		f[i]=binom[kk][i]%MOD;
	}
	while(n)
	{
		if(n&1)
		{
			conv(res,f,res);
		}
		conv(f,f,f),n>>=1;
	}
	printf("%d\n",res[r]);
}
```

---

## 作者：Nemlit (赞：3)

题目是要我们求出如下柿子：
$$\sum_{i=0}^{n}C_{nk}^{ik+r}$$

考虑k和r非常小，我们能不能从这里切入呢？

如果你注意到，所有组合数上方的数$\%k==r$，那么是不是可以从$DP$开始呢？

跟据上述性质，我们可以得到暴力$DP$：

考虑组合数的实际意义是在n个数中选出m个，那么我们可以设$dp[i][j]$表示在i个元素中，选了$m\%k==j$的方案数

转移就可以用$dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1]$了，根据你的欧气，你可以获得$45-70$分的分数

由于空间原因，暴力代码用了滚动数组；由于文章长度原因，暴力代码省去了一些没必要的东西
## $Brute:$
```
#define rep(i, s, t) for(re int i = s; i <= t; ++ i)
#define drep(i, s, t) for(re int i = t; i >= s; -- i)
int n, m, p, r, dp[55];
int main() {
	n = read(), p = read(), m = read(), r = read(), dp[0] = 1;
	rep(i, 1, n * m) {
		int pax = dp[m - 1];
		drep(j, 1, m - 1) dp[j] = (dp[j - 1] + dp[j]) % p;
		dp[0] = (dp[0] + pax) % p;
	}
	printf("%d", dp[r]);
	return 0;
}

```
那么我们还可以怎么优化呢？

考虑到$N*K$达到了$5*10^{10}$，我们考虑矩阵优化：

我们怎么从$dp[i - 1][0……m-1]$推出$dp[i][0……m-1]$呢？

只需要构造一个$50*50$的矩阵，第一行中第一列和最后一列为$1$，其余第$i$行第$i$列和第$i-1$列为1，其他都是$0$，问题便可以解决

注意，矩阵初始化的时候不能直接$=1$，要考虑$k=1$的情况
## $Code:$
```
#include<bits/stdc++.h>
using namespace std;
#define int long long
int read() {
    int x = 0, f = 1; char c = getchar();
    while(c < '0' || c > '9') { if(c == '-') f = -1; c = getchar();}
    while(c >= '0' && c <= '9') x = x * 10 + c - 48, c = getchar();
    return x * f;
}
#define rep(i, s, t) for(int i = s; i <= t; ++ i)
int n, m, p, r;
struct Martix {
	int a[55][55];
	void Init() { rep(i, 1, m) a[i][i] = 1; }
	void Mem() { memset(a, 0, sizeof(a)); }
}Ans, Base;
Martix Mul(Martix a, Martix b) {
	Martix c; c.Mem();
	rep(i, 1, m) rep(j, 1, m) rep(k, 1, m) c.a[i][j] = (c.a[i][j] + a.a[i][k] * b.a[k][j] % p) % p;
	return c;
}
Martix Pow(Martix a, int b) {
	Martix R; R.Mem(), R.Init();
	while(b) {
		if(b & 1) R = Mul(R, a);
		a = Mul(a, a), b >>= 1;
	}
	return R;
}
signed main() {
	n = read(), p = read(), m = read(), r = read();
	++ Base.a[1][1], ++ Base.a[1][m], ++ Ans.a[1][1];
	rep(i, 2, m) ++ Base.a[i][i], ++ Base.a[i][i - 1];
	Ans = Mul(Ans, Pow(Base, n * m));
	printf("%lld", Ans.a[1][1 + r]);
	return 0;
}

```

---

## 作者：Blizzard (赞：2)

这道题用到了组合数，我们可以考虑用矩阵快速幂来优化一下这个递推

省选时候迷了一波，打了30,仔细一想其实还是挺水的，代码奉上

···
```cpp
#include<bits/stdc++.h>
#define LL long long
using namespace std;
int n, K, r, p;
struct Mat{
    int x, y;
    LL num[55][55];
    void Clear(){
      memset(num, 0, sizeof(num));
    }
}A, B, Ans;
Mat operator * (Mat A, Mat B){
    Mat C;
    C.Clear();
    C.x = A.x;
    C.y = B.y;
    for(int i = 0; i < C.x; i++)
     for(int j = 0; j < C.y; j++)
      for(int k = 0; k < A.y; k++)
        C.num[i][j] = (C.num[i][j] + (A.num[i][k] % p * B.num[k][j] % p)) % p;
    return C;
}
Mat Pow(Mat X, LL n){
    while(n){
      if(n & 1)  A = X * A;
      X = X * X;
      n >>= 1;
    }
    return A;
}
int main(){
    scanf("%d%d%d%d", &n, &p, &K, &r);
    A.Clear();
    B.Clear();
    Ans.Clear();
    A.x = K;
    A.y = 1;
    A.num[0][0] = 1;
    B.x = B.y = K;
    for(int i = 0; i < K; i++){
      B.num[i][i] = 1;
      B.num[i][(i+1)%K] ++;
    }
    Ans = Pow(B, (LL)(n) * (LL)K);
    printf("%lld\n", Ans.num[r][0]);
    return 0;
}
···
```

---

## 作者：crashed (赞：1)

# 题目
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[点这里](https://www.luogu.com.cn/problem/P3746)看题目。  
# 分析
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于$m>n$的时候$C_n^m=0$ 。因此我们只需要求出： 
$$\sum_{i=0}^n C_{nk}^{ik+r}\mod p$$
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于$ik+r$的数，我们可以表示为$i\equiv r\pmod k$。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此我们只需要对下标对$k$取模之后余$r$的位置求和即可。根据组合数的定义，也就是在$nk$中选出对$k$取模后余$r$个东西的方案和。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，不难想到一个 DP：  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$f(i,x)$：$i$个物品中选出模$k$余$x$个物品的方案和。    
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;转移可以直接抄组合数（转移中$x$请自觉对$k$取模）：   
$$f(i,x)=f(i-1,x-1)+f(i-1,x)$$  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;朴素做的话是$O(nk)$，但是由于$k$较小，所以可以用矩阵快速幂优化一发，将时间降到$O(k^3\log_2)$。  
# 代码
```cpp
#include <cstdio>
#include <cstring>

typedef long long LL;

const int MAXK = 55;

template<typename _T>
void read( _T &x )
{
	x = 0;char s = getchar();int f = 1;
	while( s > '9' || s < '0' ){if( s == '-' ) f = -1; s = getchar();}
	while( s >= '0' && s <= '9' ){x = ( x << 3 ) + ( x << 1 ) + ( s - '0' ), s = getchar();}
	x *= f;
}

template<typename _T>
void write( _T x )
{
	if( x < 0 ){ putchar( '-' ); x = ( ~ x ) + 1; }
	if( 9 < x ){ write( x / 10 ); }
	putchar( x % 10 + '0' );
}

template<typename _T>
void swapp( _T &x, _T &y )
{
	_T t = x; x = y, y = t;
}

int N, mod, K, R;

struct matrix
{
	int mat[MAXK][MAXK], n, m;
	matrix() { n = m = 0, memset( mat, 0, sizeof mat ); }
	matrix( const int n_, const int m_ ) { n = n_, m = m_, memset( mat, 0, sizeof mat ); }
	int* operator [] ( const int indx ) { return mat[indx]; }
	matrix operator * ( matrix b )
	{
		matrix ret = matrix( n, b.m );
		for( int i = 1 ; i <= n ; i ++ )
			for( int j = 1 ; j <= b.m ; j ++ )
				for( int k = 1 ; k <= m ; k ++ )
					ret[i][k] = ( ret[i][k] + 1ll * mat[i][j] * b[j][k] % mod ) % mod; 
		return ret;
	}
	void operator *= ( matrix b ) { *this = *this * b; }
};

matrix A, B;

matrix I( const int n ) { matrix ret = matrix( n, n ); for( int i = 1 ; i <= n ; i ++ ) ret[i][i] = 1; return ret; }

matrix qkpow( matrix base, LL indx )
{
	matrix ret = I( base.n );
	while( indx )
	{
		if( indx & 1 ) ret *= base;
		base *= base, indx >>= 1;
	}
	return ret;
}

int qkpow( int base, LL indx )
{
	int ret = 1;
	while( indx )
	{
		if( indx & 1 ) ret = 1ll * ret * base % mod;
		base = 1ll * base * base % mod, indx >>= 1;
	}
	return ret;
}

void init()
{
	A = matrix( 1, K ), B = matrix( K, K );
	for( int i = 1 ; i <= K ; i ++ ) B[i][i] = 1, B[i][i == 1 ? K : i - 1] = 1;
	A[1][1] = 1;
}

int main()
{
	read( N ), read( mod ), read( K ), read( R );
	if( K == 1 ) { write( qkpow( 2, 1ll * N * K ) ), putchar( '\n' ); return 0; }
	init();
	matrix tmp = qkpow( B, 1ll * N * K );
	write( ( A * tmp )[1][R + 1] ), putchar( '\n' );
	return 0;
}
```

---

## 作者：MikukuOvO (赞：1)

首先我们观察这个式子：

$(\sum_{i=0}^{\infty}C_{nk}^{ik+r})mod$ $p$

由于无穷的存在，直接求解是不行的，那么我们考虑它的意义。

发现其实就是从$nk$个数中取出%$k=r$个数的方案数。

我们定义$f[i][j]$表示前$i$个数中取出%$k=j$个数的方案数。

不难写出递推式$f[i][j]=f[i-1][j]+f[i-1][(j-1+k)$%$k]$

这样我们直接进行求解的复杂度是$O(nk^2)$的。

但是我们发现这个是可以矩乘的，这样我们构造这样的矩阵。

$\begin{bmatrix}
f[i-1][0]\\
...\\
f[i-1][k-1]
\end{bmatrix} \times \begin{bmatrix}
1&1&0&...\\
0&1&1&...\\
...&...&...&...\\
1&...&...&1
\end{bmatrix}=\begin{bmatrix}
f[i][0]\\
...\\
f[i][k-1]
\end{bmatrix}
$

具体细节可以看代码，并且注意$k=1$时构造的矩阵那一位应该是$2$，也就是构造时要$++$而不是赋值为$1$。

代码实现：

```cpp
const int K=55;

ll n,p,k,r;

struct mat
{
    ll c[K][K];
    mat(){ms(c);}
    mat operator*(const mat &x)const
    {
        mat res;
        for(int m=1;m<=k;++m)
            for(int i=1;i<=k;++i)
                for(int j=1;j<=k;++j)
                    res.c[i][j]=(res.c[i][j]+c[i][m]*x.c[m][j]%p)%p;
        return res;
    }
};

mat mul(mat res,ll y)
{
    mat x;
    ++x.c[1][1],++x.c[1][k];
    for(int i=2;i<=k;++i) x.c[i][i]=x.c[i][i-1]=1;
    while(y)
    {
        if(y&1) res=res*x;
        x=x*x;
        y>>=1;
    }
    return res;
}
int main()
{
    fio();
    gi(n),gi(p),gi(k),gi(r);
    mat a,ans;
    a.c[1][1]=1;
    ans=mul(a,n*k);
    print(ans.c[1][r+1>k?r+1-k:r+1]);
    end();
}
```

---


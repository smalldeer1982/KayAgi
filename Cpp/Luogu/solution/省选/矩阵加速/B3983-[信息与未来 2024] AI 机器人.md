# [信息与未来 2024] AI 机器人

## 题目描述

![](https://cdn.luogu.com.cn/upload/image_hosting/27icb51c.png)

在 $n$ 行 $m$ 列的矩形空间中有一个机器人。矩形空间的每一个格子要么是平地（用半角点号 `.` 表示），要么是障碍物 （用井号表示 `#`）。以下是一个 $n = 3, m = 7$ 的例子：

```
...#...
...#...
.......
```

初始时,机器人位于矩形的左上角 （第一行、第一列）。每一时刻，机器人可以遵照程序执行 `U`（Up，向上）、`L` （Left，向左）、 `D` （Down，向下）、`R` （Right，向右） 四种指令中的一个，尝试向某个方向移动一格；如果移动的目标格子超出了边界或是障碍物，则保持原地不动，例如执行程序：

`LLLRRRRRRRRRDDDDRRRRRRRRR`

后，机器人会从空间的左上角移动到右下角。Dr. X 扩展了机器人程序的表达能力,引入了循环。给定程序 `P`，`(P)n` 相当于把程序 `P`“复制粘贴”$n$ 次。循环可以嵌套。例如，在足够大且无阻挡的空间中执行程序：

`(R(DRUL)7)5`

会重复 $5$ 次执行“向右移动一格、转圈 $7$ 次”，而如果机器人在 $n = 1, m = 2$ 的空间中执行上述程序，就会表现为“左右横跳”。

Dr. X 还给机器人装备了人工智能，对于某些指定的循环，机器人可以由深度神经网络自主决定循环的次数（$0$ 次或任意多次），用星号 `*` 表示，例如

`(DR(R)*)3`

外层循环会执行 $3$ 次，由于循环“复制粘贴”的特性，每次向下向右移动一格后，机器人可以根据自己的想法向右移动 $0$ 格或任意多格。人工智能循环也可以嵌套，根据循环“先外层后里层”的执行顺序，总是先确定外层人工智能循环的执行次数，再按照“复制粘贴”的规则执行内层循环代码。

人工智能模块使机器人的行为变得难以预测。给定一个机器人程序，Dr. X 想知道，哪些格子是机器人在执行程序过程中绝无可能经过的（即无论机器人如何选择循环执行的次数，都不会经过）？这样他可以在这些格子上安装监控，并在观察到机器人行为失控的时候及时制止。

## 说明/提示

对于 $30\%$ 的数据，输入程序不含星号 `*` 且在 $10^5$ 步内终止。

对于另外 $30\%$ 的数据，输入程序中不含星号 `*`。

对于 $100\%$ 的数据，$1 \leq n, m \leq 10$，且输入程序的长度不超过 $1000$。

>本题原始满分为 $20\text{pts}$。

## 样例 #1

### 输入

```
3 7
...#...
...#...
.......
LLLRRRRRRRRRDDDDRRRRRRRRR```

### 输出

```
+++#...
..+#...
..+++++```

## 样例 #2

### 输入

```
3 7
...#...
##.....
.......
(R(DRUL)7)5```

### 输出

```
+++#...
##+++++
..+++++```

## 样例 #3

### 输入

```
3 7
.......
.#####.
.......
(R)*(D)*```

### 输出

```
+++++++
+#####+
+.....+```

# 题解

## 作者：wosile (赞：19)

UPD：修正笔误。

信息与未来真神吧？拿这种东西给小学生做？

我的做法可能偏复杂了。

观察到 $n,m \le 10$，对于每对括号，我们可以先对于其内部的字符串，计算出对于每一种初始位置，经过这个字符串后可能会到达哪里，以及可能会经过哪些位置。这两个信息可以用两个大小为 $nm \times nm$ 的 $\texttt{01}$ 矩阵 $M_t,M_p$ 表示。也就是说，一段字符串 $S$ 就可以转化成一个矩阵二元组 $(M_t,M_p)$。

对于单个字符 `LRUD`，我们可以提前把它们对应的这两个矩阵算出来。

方便起见，我们把全部 $nm$ 个位置从 $1$ 到 $nm$ 编号，比如说，$S(M_t,M_p)$ 中，$M_p(x,y)$ 就代表从编号为 $x$ 的位置开始，经过字符串 $S$ 所代表的操作序列，有没有可能经过编号为 $y$ 的位置。

当两段操作序列 $S(M_t,M_p),T(N_t,N_p)$ 按顺序拼接在一起得到 $ST(F_t,F_p)$ 时，假如我们从 $x$ 号位置开始，我们会先经过 $M_p(x,t)=1$ 的位置 $t$，然后到达 $M_t(x,r)=1$ 的位置 $r$，然后再经过 $N_p(r,z)=1$ 的位置 $z$，到达 $N_t(r,y)=1$ 的位置 $y$。

由此~~并不~~显然有，$F_t(x,y)=\bigcup\limits_{r=1}^{nm}(M_t(x,r)\cap N_t(r,y))$ 和 $F_p(x,y)=(\bigcup \limits_{r=1}^{nm}M_t(x,r)\cup N_p(r,y))\cup M_p(x,y)$。

我们发现这个东西很像矩阵乘法。具体来讲，若乘法为 $\text{and-or}$ 矩阵乘法，那么 $F_t=M_t\times N_t$，$F_p=M_p \cup (M_t \times N_p)$。显然是有结合律的，那不妨定义矩阵二元组的乘法如上，即 $(M_t,M_p)(N_t,N_p)=(M_tN_t,M_tN_p\cap M_p)$。

做这个乘法的复杂度是 $O(n^3m^3)$ 的，但是我们可以通过 `std::bitset` 或者 `unsigned long long` 或者 `__int128` 之类的东西压位，可以做到 $O(\frac{n^3m^3}{w})$。

对于 $\texttt{(S)k}$ 的情况，显然整个字符串对应的矩阵二元组就是 $k$ 个 $S(M_t,M_p)$ 相乘，即 $(F_t,F_p)=(M_t,M_p)^k$。这里可以用快速幂，当然不用也无所谓。

对于 $\texttt{(S)*}$ 的情况，若把 $M_t$ 看作一个邻接矩阵，则 $F_t$ 相当于一个可达性矩阵，而 $F_p(x,y)$ 则相当于“在这个图上从 $x$ 号位置开始走能到达的所有点 $t$ 中，是否有点满足 $M_p(t,y)=1$”。$F_t$ 可以通过 Floyd-Warshall 传递闭包（这里也可以压位除掉一个 $w$）求出，$F_p$ 可以一并求出。

然后全拼起来就做完了，总复杂度 $O(\frac{n^3m^3|S|k}w)$，其中 $k$ 是括号后附带的数字，$k \le 9$。如果你有心情做矩阵快速幂可以做到 $O(\frac{n^3m^3|S|\log k}w)$，常数非常小。

这题既不入门，也不面试，但是它在入门与面试题库里面。综合算法难度，思维难度和代码难度，我觉得这应该是 B 题库最难的一题。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int dx[4]={0,0,-1,1};
const int dy[4]={-1,1,0,0};
char s[15][15],S[1005];
int n,m,N;
inline int id(int x,int y){
    return (x-1)*m+y;
}
inline int getx(int x){
    return (x-1)/m+1;
}
inline int gety(int x){
    return (x-1)%m+1;
}
struct command{
    command(){
        for(int i=1;i<=N;i++){
            to[i].reset();
            path[i].reset();
        }
    }
    bitset<105>to[105],path[105];
    void operator |=(command o){
        for(int i=1;i<=N;i++){
            to[i]|=o.to[i];
            path[i]|=o.path[i];
        }
    }
}com[505];
int cnt=0,readpos=0;
bitset<105>tr[105];
command concatenate(const command &x,const command &y){
    command z;
    for(int i=1;i<=N;i++)z.path[i]=x.path[i];
    for(int i=1;i<=N;i++)for(int j=1;j<=N;j++)if(x.to[i][j]){
        z.to[i]|=y.to[j],z.path[i]|=y.path[j];
    }
    return z;
}
command repeat(command &x,int k){
    for(int i=1;i<=N;i++)tr[i].reset();
    command ans;
    for(int i=1;i<=N;i++)ans.to[i][i]=1,ans.path[i][i]=1;
    if(k<1 || k>9){
        ans|=x;
        for(int i=1;i<=N;i++)for(int j=1;j<=N;j++){
            // Floyd 求最短路的时候我们有 dis[j][k] <--- dis[j][i]+dis[i][k]，这里也是一样的道理。
            if(ans.to[j][i]){
                ans.to[j]|=ans.to[i];
                ans.path[j]|=ans.path[i];
            }
        }
    }
    else{
        command tmp=x;
        while(k){
            // 快速幂
            if(k&1)ans=concatenate(ans,tmp);
            tmp=concatenate(tmp,tmp);
            k>>=1;
        }
    }
    return ans;
}
int Len;
void walk(command &x,int dir){
    for(int i=1;i<=N;i++)tr[i].reset();
    for(int i=1;i<=N;i++)for(int j=1;j<=N;j++)if(x.to[i][j]){
        int nx=getx(j)+dx[dir],ny=gety(j)+dy[dir];
        if(nx>=1 && nx<=n && ny>=1 && ny<=m && s[nx][ny]=='.')tr[i][j+dx[dir]*m+dy[dir]]=1;
        else tr[i][j]=1;
    }
    for(int i=1;i<=N;i++)x.to[i]=tr[i],x.path[i]|=tr[i];
}
void readCommand(command &x){
    for(int i=1;i<=N;i++){
        x.to[i][i]=x.path[i][i]=1;
    }
    while(readpos<Len && S[readpos]!=')'){
        char c=S[readpos];
        // LRUD 可以做到 N^2 而不是 N^3/w
        if(c=='L')walk(x,0);
        if(c=='R')walk(x,1);
        if(c=='U')walk(x,2);
        if(c=='D')walk(x,3);
        if(c=='('){
            ++readpos;
            command &f=com[++cnt];
            readCommand(f);
            ++readpos;
            char op=S[readpos];
            x=concatenate(x,repeat(f,op-48));
        }
        ++readpos;
    }
}
int main(){
    scanf("%d%d",&n,&m);
    N=n*m;
    for(int i=1;i<=n;i++)scanf("%s",s[i]+1);
    scanf("%s",S);
    Len=strlen(S);
    readCommand(com[++cnt]);
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            if(s[i][j]=='#')putchar('#');
            else if(com[1].path[id(1,1)][id(i,j)])putchar('+');
            else putchar('.');
        }
        putchar('\n');
    }
    return 0;
}
```

---

## 作者：silverleo (赞：10)

> 更新下代码，原来代码有点问题没有实现最优复杂度。

- 先看最简单的情况，一个不含 `*` 的操作序列路线是固定的并且最后停留的位置唯一，直接按步移动就可以。

- 然后考虑 `(S)*` 的情况，可以把每次循环可能停留的位置叠加起来，循环叠加直至位置不再变化为止。用一个 `bitset` 表示矩阵，例如  `(R)*` 的停留位置如下：
```
1111111  
0000000  
0000000   
```
后续移动就在之前矩阵基础上移动得到，比如 `(R)*D ` 得到的矩阵为：
```
1111111  
1111111    
0000000   
```
- 障碍物用另一个矩阵表示， $1$ 表示空格，$0$ 表示障碍物。为处理方便在每行最后增加一列障碍物，然后每次移动之后的位置有两个来源：  
1. 原位置移位之后与空格的交集
2. 原位置与障碍物反向移位后的交集（即被障碍物挡住停留在原地的情况）

用位运算来处理很方便，将两种情况合并就是移动后的结果了。

以样例 $3$ 数据为例，空格矩阵为：
```
11111110  
10000010    
11111110
```
起点 `(1,1)` 经过 `(R)*` 移动之后得到的位置：
```
11111110  
00000000    
00000000  
```
再经过 `(D)*` 移动之后得到的位置：
```
11111110  
10000010    
10000010  
```
把所有移动过程中经过的点记录下来就是最终答案。

直接提交会超时，要加上记忆化搜索，只需要记录关键指令位 `(` 的结果。直接记忆化只能过部分数据，因为整个矩阵的状态数是 $2^{n \times m}$ 级别，显然过大。再观察发现其中每个点可以独立计算互不干扰，因此可以将矩阵拆成点之后再对每个点分别记忆化，最后将所有点的结果合并就是完整的结果了，这样每一步最多只需要保存 ${n \times m}$ 个结果。

### 复杂度
`(S)*` 复杂度由指令长度、每个关键节点需要计算的点数、`*` 的最大循环次数决定，其中 `*` 循环次数不超过 ${n \times m}$，每一步需计算的点数也是 ${n \times m}$，每个点的结果 `bitset` 合并需要 ${n \times m \over w}$ 开销，复杂度 ${O({\lvert S \rvert  n^3 m^3 \over w})}$。

而 `(S)k` 虽然只需要循环 ${k}$ 次，但是每次必须把所有点都计算一遍（`(S)*` 循环每次只需要计算新增的点），复杂度 ${O({\lvert S \rvert  n^3 m^3 k \over w})}$ 反而更高。

最终复杂度 ${O({\lvert S \rvert  n^3 m^3 k \over w})}$，可以优化到 ${O({\lvert S \rvert  n^3 m^3 \log k \over w})}$。

完结撒花，小学毕业，哦耶！

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef bitset<128> GRID;
int n,m,to[1000];
string path;
GRID blank,vis(1),flag(1); 
unordered_map<int,GRID> mp[1000];

GRID move(GRID& g,char ch){
	GRID res;
	if(ch=='U')res=(g>>(m+1)&blank)|(g&~(blank<<(m+1)));//空格位取反即障碍物，行尾加了一列障碍物所以上下移动需要移m+1位 
	else if(ch=='D')res=(g<<(m+1)&blank)|(g&~(blank>>(m+1)));
	else if(ch=='L')res=(g>>1&blank)|(g&~(blank<<1));
	else if(ch=='R')res=(g<<1&blank)|(g&~(blank>>1));
	vis|=res;//移动时记录结果
	return res;
}

GRID solve(int& ind,int p);

GRID solve2(int& ind,GRID g){//将矩阵拆解为每个点来搜索 
	GRID res;
	int start=ind;
	for(int i=0;i<n*(m+1);i++)
		if(g[i]){
			ind=start;
			res|=solve(ind,i);
		}	
	return res;
}
 
GRID solve(int& ind,int p){//点p从指令位ind执行到')'或结尾得到的结果 
	int t=ind;
	if(mp[t].find(p)!=mp[t].end()){//记忆化搜索
		ind=to[t];
		return mp[t][p];
	}		
	GRID res=flag<<p;		
	while(ind<path.size()){
		char ch=path[ind++];
		if(ch=='('){//遇到左括号进入递归
			int start=ind;
			GRID last=res;
			res=solve2(ind,last);					
			if(path[ind]=='*'){
				res|=last;//原位置与移动后的位置叠加作为结果，直到结果和原位置重合为止
				GRID diff=res^last;//每次循环只需要搜索新增的点就可以，避免重复搜索 
				while(diff.any()){
					last=res;
					ind=start;
					res=solve2(ind,diff)|last;
					diff=res^last;
				}
			}else{
				for(int i=0;i<path[ind]-'1';i++){
					last=res;
					ind=start;
					res=solve2(ind,last);
				}
			}
			ind++;
		}else if(ch==')')break;//遇到右括号退出递归
		else res=move(res,ch);
	}	
	to[t]=ind;
	return mp[t][p]=res;
}

int main(){
	cin>>n>>m;
	string s;
	for(int i=0,p=0;i<n;i++,p++){ 
		cin>>s;
		for(int j=0;j<m;j++,p++){
			if(s[j]=='.')blank[p]=1;
		}				
	}
	cin>>path;
	int t=0;
	solve2(t,vis);
	for(int i=0,p=0;i<n;i++,p++){
		for(int j=0;j<m;j++,p++){
			if(!blank[p])cout<<'#';
			else if(vis[p])cout<<'+';
			else cout<<'.';
		}
		cout<<endl;
	}
}
```

---

## 作者：Moeebius (赞：9)

> 好题要点赞。
>
> 以下有好多碎碎念。

考虑没有 `*` 的情况怎么做。暴力展开是错的，因为展开完指令的长度可以轻松达到指数级。

分析一下操作的性质。因为撞墙维持不动的特性，如果仅维护坐标变化量，这个东西既没有交换律也没有结合律，看起来我们只会暴力。

> 我们甚至不知道机器人的终点在哪里！

仔细思考，发现问题就在撞墙上面。也就是说，我们对于任意的初始坐标，是不知道机器人移动完去哪里的。

于是有一个简单粗暴的想法：维护初始坐标就完事了！

我们不再维护坐标变化量，而是维护一个 $\text{初始坐标}\rightarrow \text{结束坐标}$ 的映射。可以写成一个长宽均为 $nm$ 的布尔矩阵的形式。

容易发现在这个背景下 $\mathtt{L,R,U,D}$ 都可以写成一个矩阵的形式，操作有了结合律。

好了我们知道机器人去哪里了，对于中途经过的坐标也是好维护的。具体来说，我们同时维护一个长宽均为 $nm$ 的布尔矩阵，第 $i$ 行第 $j$ 列为 $1$ 当且仅当存在一种方案使得机器人从 $i$ 对应的坐标出发，中途经过 $j$。

容易发现这个拓展不影响操作的结合律。

然后用个矩阵快速幂（慢速幂？）就做完了没有 `*` 的情况。

---

如果你注意力良好，是可以观察到 `*` 在做什么的：从起点出发，按照一定的规则一直走，求能到达的终点集合——等价于求原图传递闭包！这时一个起点的终点变成一个点集了，但是我们并不依赖这个性质所以没关系。发现此时中途经过的点集也是好维护的，因此我们做完了这道题。

当然，如果你注意力糟糕，也可以求原矩阵的 $nm$ 次「或幂」；具体来说，暴力维护终点的做法就是让当前终点每次右乘原矩阵，然后令答案或上这个矩阵；这个东西可以倍增地做，然后中途点集的维护同理。

---

代码实现：布尔矩阵乘法可以压位做，复杂度 $O(\frac{n^3m^3|S|k}{w})$ 或者 $O(\frac{n^3m^3|S|(\log n + \log m + \log k)}{w})$，其中 $k=9$。

**Code（传递闭包）**
```cpp

using lll = __int128_t;

struct Mat {
  int n;
  lll v[128], u[128];
  Mat(int _n = 0) : n(_n) { memset(v, 0, sizeof(v)); }
  Mat operator*(const Mat &rhs) const {
    // ans[i][j] |= l[i][k] & r[k][j]
    Mat ans(n);
    copy(u, u + n, ans.u);
    For(i, 0, n - 1) For(k, 0, n - 1) if ((v[i] >> k) & 1) ans.v[i] |= rhs.v[k],
        ans.u[i] |= rhs.u[k];
    return ans;
  }
};

int n, m, dx[] = {0, 0, -1, 1}, dy[] = {-1, 1, 0, 0};
string G[11];
Mat L, R, U, D;
bool ok(int u, int v) {
  return (u >= 0 && u < n && v >= 0 && v < m && G[u][v] != '#');
}
int go(int u, int v, int dir) {
  int p = u + dx[dir], q = v + dy[dir];
  return ok(p, q) ? (p * m + q) : (u * m + v);
}
void init(Mat &x) {
  For(i, 0, n - 1) For(j, 0, m - 1) if (ok(i, j)) x.v[i * m + j] =
      x.u[i * m + j] = lll(1) << (i * m + j);
}
// since y < 9, we can do it brutely.
il Mat qpow(Mat x, int y) {
  assert(y);
  Mat ans = x;
  For(i, 2, y) ans = ans * x;
  return ans;
}
il Mat floyd(Mat x) {
  // rep(k) rep(i) rep(j) f[i][j] |= f[i][k] & f[k][j]
  For(i, 0, n - 1) For(j, 0, m - 1) if (ok(i, j)) {
    x.v[i * m + j] |= lll(1) << (i * m + j);
    x.u[i * m + j] |= lll(1) << (i * m + j);
  }
  For(k, 0, x.n - 1) For(i, 0, x.n - 1) if (x.v[i] >> k & 1) {
    x.v[i] |= x.v[k];
    x.u[i] |= x.u[k];
  }
  return x;
}
Mat fetch(char c) {
  switch (c) {
  case 'L':
    return L;
  case 'R':
    return R;
  case 'U':
    return U;
  case 'D':
    return D;
  default:
    assert(0);
  }
}
bool get_cur_pos(const Mat &x) {
  For(i, 0, n - 1) For(j, 0, m - 1) if (x.v[0] >> (i * m + j) & 1) return cerr
      << i << ' ' << j << '\n',
      1;
  return 0;
}

il void Main() {
  cin >> n >> m;
  For(i, 0, n - 1) cin >> G[i];
  L.n = n * m;
  For(i, 0, n - 1) For(j, 0, m - 1) if (ok(i, j)) {
    L.v[i * m + j] |= lll(1) << go(i, j, 0);
    L.u[i * m + j] = L.v[i * m + j] | lll(1) << (i * m + j);
  }
  R.n = n * m;
  For(i, 0, n - 1) For(j, 0, m - 1) if (ok(i, j)) {
    R.v[i * m + j] |= lll(1) << go(i, j, 1);
    R.u[i * m + j] = R.v[i * m + j] | lll(1) << (i * m + j);
  }
  U.n = n * m;
  For(i, 0, n - 1) For(j, 0, m - 1) if (ok(i, j)) {
    U.v[i * m + j] |= lll(1) << go(i, j, 2);
    U.u[i * m + j] = U.v[i * m + j] | lll(1) << (i * m + j);
  }
  D.n = n * m;
  For(i, 0, n - 1) For(j, 0, m - 1) if (ok(i, j)) {
    D.v[i * m + j] |= lll(1) << go(i, j, 3);
    D.u[i * m + j] = D.v[i * m + j] | lll(1) << (i * m + j);
  }

  stack<Mat> st;
  string oper;
  cin >> oper;
  st.emplace(n * m), init(st.top());

  int __id = 0;

  for (char ch : oper) {
    __id++;
    if (ch == '(') {
      st.emplace(n * m);
      init(st.top());
    } else if (ch == ')') {
      continue;
    } else if (isdigit(ch)) {
      auto u = st.top();
      st.pop(), st.top() = st.top() * qpow(u, ch - '0');
    } else if (ch == '*') {
      auto u = st.top();
      st.pop(), st.top() = st.top() * floyd(u);
    } else {
      st.top() = st.top() * fetch(ch);
    }
  }

  assert(st.size() == 1);
  For(i, 0, n - 1) For(j, 0, m - 1) {
    if (!ok(i, j))
      cout << '#';
    else if (st.top().u[0] >> (i * m + j) & 1)
      cout << '+';
    else
      cout << '.';
    if (j == m - 1)
      cout << '\n';
  }
}
```

**Code(不用传递闭包)**
```cpp
struct Mat {
  int n;
  lll v[100], u[100];
  Mat(int _n = 0) : n(_n) { memset(v, 0, sizeof(v)); }
  Mat operator*(const Mat &rhs) const {
    // ans[i][j] |= l[i][k] & r[k][j]
    Mat ans(n);
    copy(u, u + n, ans.u);
    For(i, 0, n - 1) For(k, 0, n - 1) if ((v[i] >> k) & 1) ans.v[i] |= rhs.v[k],
        ans.u[i] |= rhs.u[k];
    return ans;
  }
  Mat &operator*=(const Mat &rhs) { return *this = *this * rhs; }
  Mat operator|(const Mat &rhs) const {
    Mat res = *this;
    For(i, 0, n - 1) res.v[i] = v[i] | rhs.v[i], res.u[i] = u[i] | rhs.u[i];
    return res;
  }
};

int n, m, dx[] = {0, 0, -1, 1}, dy[] = {-1, 1, 0, 0};
string G[11];
Mat L, R, U, D;
bool ok(int u, int v) {
  return (u >= 0 && u < n && v >= 0 && v < m && G[u][v] != '#');
}
int go(int u, int v, int dir) {
  int p = u + dx[dir], q = v + dy[dir];
  return ok(p, q) ? (p * m + q) : (u * m + v);
}
void init(Mat &x) {
  For(i, 0, n - 1) For(j, 0, m - 1) if (ok(i, j)) x.v[i * m + j] =
      x.u[i * m + j] = lll(1) << (i * m + j);
}
// Since y < 9, we can do it brutely.
// However, here is the QUICK pow implementation.
il Mat qpow(Mat x, int y) {
  Mat ans(n * m);
  init(ans);
  while (y) {
    if (y & 1)
      ans *= x;
    x *= x, y >>= 1;
  }
  return ans;
}
// Furthermore, we CAN implement floyd by QPOW!
il Mat floyd(Mat x) {
  Mat ans(n * m);
  init(ans);
  int y = INT_MAX;
  while (y) {
    if (y & 1)
      ans = ans | ans * x;
    x = x | x * x, y >>= 1;
  }
  return ans;
}
Mat fetch(char c) {
  switch (c) {
  case 'L':
    return L;
  case 'R':
    return R;
  case 'U':
    return U;
  case 'D':
    return D;
  default:
    assert(0);
  }
}

il void Main() {
  cin >> n >> m;
  For(i, 0, n - 1) cin >> G[i];
  L.n = n * m;
  For(i, 0, n - 1) For(j, 0, m - 1) if (ok(i, j)) {
    L.v[i * m + j] = lll(1) << go(i, j, 0);
    L.u[i * m + j] = L.v[i * m + j] | lll(1) << (i * m + j);
  }
  R.n = n * m;
  For(i, 0, n - 1) For(j, 0, m - 1) if (ok(i, j)) {
    R.v[i * m + j] = lll(1) << go(i, j, 1);
    R.u[i * m + j] = R.v[i * m + j] | lll(1) << (i * m + j);
  }
  U.n = n * m;
  For(i, 0, n - 1) For(j, 0, m - 1) if (ok(i, j)) {
    U.v[i * m + j] = lll(1) << go(i, j, 2);
    U.u[i * m + j] = U.v[i * m + j] | lll(1) << (i * m + j);
  }
  D.n = n * m;
  For(i, 0, n - 1) For(j, 0, m - 1) if (ok(i, j)) {
    D.v[i * m + j] = lll(1) << go(i, j, 3);
    D.u[i * m + j] = D.v[i * m + j] | lll(1) << (i * m + j);
  }

  stack<Mat> st;
  string oper;
  cin >> oper;
  st.emplace(n * m), init(st.top());

  int __id = 0;

  for (char ch : oper) {
    __id++;
    if (ch == '(') {
      st.emplace(n * m);
      init(st.top());
    } else if (ch == ')') {
      continue;
    } else if (isdigit(ch)) {
      auto u = st.top();
      st.pop(), st.top() *= qpow(u, ch - '0');
    } else if (ch == '*') {
      auto u = st.top();
      st.pop(), st.top() *= floyd(u);
    } else {
      st.top() *= fetch(ch);
    }
  }

  assert(st.size() == 1);
  For(i, 0, n - 1) For(j, 0, m - 1) {
    if (!ok(i, j))
      cout << '#';
    else if (st.top().u[0] >> (i * m + j) & 1)
      cout << '+';
    else
      cout << '.';
    if (j == m - 1)
      cout << '\n';
  }
}
```

---

## 作者：沉石鱼惊旋 (赞：9)

真神啊。不低于省选难度吧？

我们每一步移动的本质，其实是相当于有若干个一样的机器人在很多位置移动，按操作方法移动到了一个位置。最后答案就是这些机器人移动位置的交集。

然而我们发现，对于一个位置 $(x_1,y_1)$，这上面的机器人所能移动到的位置 $(x_2,y_2)$ 是固定的。因此可以用一个大小为 $(n\times m)\times (n\times m)$ 的 01 矩阵，$a_{i,j}$ 表示编号 $i$ 的点能否到达编号 $j$ 的点。我们这里需要把矩形空间压缩成线性空间，把一个点对映射成一个编号。

我们不妨对于 $\tt{U,L,D,R}$ 每种操作先处理出每种操作，所有位置经过操作时候能到达的位置。这是可以读入了这个矩形空间就能解决的。

接下来我们可以递归（或者用栈处理）这个表达式。

我们简单定义一下以后说到的操作：

1. 矩阵乘法：此处为广义的。我们的矩阵由于维护的是是否可达，所以就是乘法改成做一个 bit_or 运算。也就是 `c[i][j] = a[i][k] | b[k][j];`。
2. 矩阵加法：还是，广义……？其实表达成矩阵 bit_or 更合适，但是和上文有些重复，还是表述成矩阵加法吧。这里加法也改成 bit_or。也就是 `c[i][j] = a[i][j] | b[i][j];`。

众所周知，矩阵乘法可以算图上行走 $k$ 步的方案数。类比过来，这里的矩阵乘法可以让我们知道走 $k$ 步能到哪里。而这里的矩阵加法是用来合并路径的。

单次操作是简单的，我们把目前的操作得到的结果和目前这个单次操作做一个矩阵乘法即可。

带有括号不好处理。我们先来讲固定次数怎么做。

在我们已知括号内的操作时，直接循环这么多次，每次用已有操作序列做矩阵乘法，然后路径做一个矩阵加法。

星号同理，但是循环次数不唯一。我们可以发现，其实下面这组测试数据星号需要的循环次数会比较多。

```cpp
10 10
..........
#########.
#########.
#########.
#########.
#########.
#########.
#########.
#########.
..........
(RD)*
```

这样的话最坏情况就是 $(1,1)\to (1,n)\to(n,m)$ 得到 $18$ 的长度（第一个点默认走过）。

所以星号跑 $18$ 次，把结果全凑一起就行。

然而还可以构造出要跑更多次的数据，所以这个方法这个方法太菜了。我们可以做到更好的复杂度。

先对目前括号内的操作序列做一个传递闭包，相当于得到了每个点能前往的所有点。然后相当于对这个做一次行走即可。

那么接下来我们求出括号内操作序列即可。对于每个 `(` 找到与之匹配的 `)`，递归搜出这两个中间的操作序列即可。

最后，这题矩阵运算有一个技巧。因为是 01 矩阵，可以用 bitset 优化，这样矩阵乘法复杂度就是 $\mathcal O(\frac{n^3}{w})$ 的。但是，又发现这题矩阵大小至多 $100\times 100$，可以用状压的思想把一行压成一个数。这样理论上针对这题的矩阵乘法复杂度就是 $\mathcal O(n^2)$。可以用 C++ 中的 `__int128` 储存。

这个方法甚至星号不是瓶颈，有界限的循环才是瓶颈。

时间复杂度 $\mathcal O(|s|(nm)^2k)$，其中 $k=9$。可以通过。并且不可能卡满，因此实际效率非常快。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef array<__int128, 100> Matrix;
typedef pair<Matrix, Matrix> pMM;
int n, m;
char mp[10][10];
int id[10][10];
__int128 pw[100];
int N;
const int dx[] = {0, 0, 1, -1};
const int dy[] = {1, -1, 0, 0};
inline bool in(int x, int y) { return 0 <= x && x < n && 0 <= y && y < m; }
char to[100];
Matrix base[4];
Matrix ans;
inline void clear(Matrix &x)
{
    for (int i = 0; i < N; i++)
        x[i] = 0;
}
inline void build(Matrix &x)
{
    for (int i = 0; i < N; i++)
        x[i] |= pw[i];
}
Matrix operator|(const Matrix &x, const Matrix &y)
{
    Matrix z;
    clear(z);
    for (int i = 0; i < N; i++)
        z[i] = x[i] | y[i];
    return z;
}
Matrix operator*(const Matrix &x, const Matrix &y)
{
    Matrix z;
    clear(z);
    for (int k = 0; k < N; k++)
        for (int i = 0; i < N; i++)
            if (x[i] >> k & 1)
                z[i] |= y[k];
    return z;
}
Matrix &operator|=(Matrix &x, const Matrix &y) { return x = x | y; }
Matrix &operator*=(Matrix &x, const Matrix &y) { return x = x * y; }
string s;
pMM dfs(int l, int r) // [l, r)
{
    Matrix opt;
    clear(opt);
    build(opt);
    Matrix path;
    clear(path);
    build(path);
    for (int i = l; i < r; i++)
    {
        if (isalpha(s[i]))
        {
            opt *= base[to[s[i]]];
            path |= opt;
            continue;
        }
        int cnt = 0;
        int j = i;
        while (j < r)
        {
            if (s[j] == '(')
                cnt++;
            if (s[j] == ')')
                cnt--;
            j++;
            if (!cnt)
                break;
        }
        auto [op, mp] = dfs(i + 1, j - 1);
        if (s[j] == '*')
        {
            build(op);
            for (int x = 0; x < N; x++)
                for (int y = 0; y < N; y++)
                    if (op[x] >> y & 1)
                        op[x] |= op[y];
            path |= opt * op * mp;
            opt *= op;
        }
        else
        {
            for (int k = 0; k < (s[j] ^ '0'); k++)
            {
                path |= opt * mp;
                opt *= op;
            }
        }
        i = j;
    }
    return {opt, path};
}
int main()
{
    to['R'] = 0, to['L'] = 1, to['D'] = 2, to['U'] = 3;
    pw[0] = 1;
    for (int i = 1; i < 100; i++)
        pw[i] = pw[i - 1] << 1;
    cin >> n >> m;
    N = n * m;
    for (int i = 0; i < n; i++)
        for (int j = 0; j < m; j++)
            cin >> mp[i][j];
    for (int i = 0; i < n; i++)
        for (int j = 0; j < m; j++)
            id[i][j] = i * m + j;
    for (int i = 0; i < 4; i++)
    {
        for (int x = 0; x < n; x++)
        {
            for (int y = 0; y < m; y++)
            {
                int tx = x + dx[i];
                int ty = y + dy[i];
                base[i][id[x][y]] |= pw[in(tx, ty) && mp[tx][ty] == '.' ? id[tx][ty] : id[x][y]];
            }
        }
    }
    cin >> s;
    ans = dfs(0, s.size()).second;
    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < m; j++)
        {
            if (mp[i][j] == '#')
                putchar('#');
            else if (ans[0] >> id[i][j] & 1)
                putchar('+');
            else
                putchar('.');
        }
        putchar('\n');
    }
    return 0;
}
```

---


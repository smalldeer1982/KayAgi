# 「FAOI-R5」波特检测

## 题目背景

正在验证您是否是真人。这可能需要几秒钟时间。

## 题目描述

小 H 是一个 bot，他内置一个序列 $\{A_n\}$ 和一个长度为 $n$ 的 01 串 $H$。询问他一个区间 $[l,r]$，他可以给出一个**集合** $g(l,r)$:
- 设置序列 $\{B_n\}$，对于 $i=1,2,\ldots,n$，执行以下操作：
  - 如果 $H_i=\tt{0}$，$B_i=A_i$（即小 H 不能修改 $A_i$ 的值）；
  - 如果 $H_i=\tt{1}$，可以任意选择一个非负整数 $v$，令 $B_i=v$（即小 H 可以任意修改 $A_i$ 的值，**修改后的值可以不在 $\boldsymbol{[0,2^k-1]}$ 范围内**）。
- $g(l,r)=\{B_l\operatorname{xor}B_{l+1},B_{l+1}\operatorname{xor}B_{l+2},\cdots,B_{r-1}\operatorname{xor}B_{r}\}$。

喵仔牛奶需要对小 H 进行若干次检测，每次选取 $[l,r],[L,R]$ 两个区间，满足 $r\le L$，并向小 H 询问得出 $g(l,r),g(L,R)$。若 $g(l,r)\cap g(L,R)\neq\varnothing$，则检测失败，小 H 的 bot 身份会被发现。

若小 H 存在一种策略可以回答所有可能的询问并不存在检测失败（也就是对于任意满足 $r\le L$ 区间 $[l,r],[L,R]$ 都不会检测失败），我们就称这个 01 串 $H$ 是「可用的」。

给定 $n,k$，序列 $\{A_n\}$ 的每一项都在 $[0,2^k-1]$ 中均匀随机选取。你需要求出「可用的」01 串 $H$ 的个数的期望值。答案对 $998244353$ 取模。

## 说明/提示

### 样例 1 解释

唯一一种可能的情况是 $A=[0]$，此时 $H=\tt 0$ 和 $H=\tt 1$ 都是「可用的」，故答案为 $2$。

### 样例 2 解释

有以下 $4$ 种可能的情况：

- $A=[0,0]$。
- $A=[0,1]$。
- $A=[1,0]$。
- $A=[1,1]$。

在不修改的情况下，它们都能通过检测（对应的答案均为 $2^2=4$），故答案为 $2^2=4$。

### 样例 3 解释

有以下 $8$ 种可能的情况：
- $A=[0,0,0]$，$H$ 的个数为 $7$。
- $A=[0,0,1]$，$H$ 的个数为 $8$。
- $A=[0,1,0]$，$H$ 的个数为 $7$。
- $A=[0,1,1]$，$H$ 的个数为 $8$。
- $A=[1,0,0]$，$H$ 的个数为 $8$。
- $A=[1,0,1]$，$H$ 的个数为 $7$。
- $A=[1,1,0]$，$H$ 的个数为 $8$。
- $A=[1,1,1]$，$H$ 的个数为 $7$。

当 $A=[0,1,0]$ 时，$H=\tt{000}$ 不是「可用的」。当询问 $[1,2],[2,3]$ 时：
- 小 H 每次只能原封不动地保留 $A$。
- 当询问 $[1,2]$ 时，$g(1,2)=\{1\}$。
- 当询问 $[2,3]$ 时，$g(2,3)=\{1\}$。
- $g(1,2)\cap g(2,3)=\{1\}$，检测失败。

当 $A=[1,1,1]$ 时，$H=\tt{010}$ 是「可用的」。当询问 $[1,2],[2,3]$ 时：
- 小 H 可以任意修改 $A$ 的值，**并且每次询问时修改的值可以不一样**。
- 当询问 $[1,2]$ 时，小 H 令 $B=[1,2,1]$，$g(1,2)=\{3\}$。
- 当询问 $[2,3]$ 时，小 H 令 $B=[1,1,1]$，$g(2,3)=\{0\}$。
- $g(1,2)\cap g(2,3)=\varnothing$，检测成功。

故答案为 $(7\times 4+8\times 4)\times\dfrac{1}{8}=\dfrac{15}{2}$。

注意到 $2\times 499122184\equiv 15\pmod{998244353}$，答案即为 $499122184$。

### 样例 4 解释

答案为 $\dfrac{907}{32}\equiv655097885\pmod{998244353}$。

### 数据规模与约定

**本题采用捆绑测试。**

- Subtask 1（10 pts）：$n\leq2$。
- Subtask 2（10 pts）：$n\leq 6$，$k\leq 2$。
- Subtask 3（10 pts）：$n\leq 50$，$k\leq6$。
- Subtask 4（10 pts）：$n\leq 500$，$k\leq 20$。
- Subtask 5（20 pts）：$n\leq 2\times10^3$。
- Subtask 6（20 pts）：$n\leq 5\times10^4$。
- Subtask 7（20 pts）：无特殊限制。

对于所有数据，$1\leq n\leq 10^6$，$0\leq k\leq 10^9$。

## 样例 #1

### 输入

```
1 0```

### 输出

```
2```

## 样例 #2

### 输入

```
2 1```

### 输出

```
4```

## 样例 #3

### 输入

```
3 1```

### 输出

```
499122184```

## 样例 #4

### 输入

```
5 2```

### 输出

```
655097885```

## 样例 #5

### 输入

```
10 3```

### 输出

```
972670600```

## 样例 #6

### 输入

```
114 514```

### 输出

```
802524221```

# 题解

## 作者：luanyanjia (赞：5)

注意：本文中 $0$ 和 $1$ 全是反的，我读题也是这么读的，但不影响答案就不改了。

首先期望乘上总方案数，变成对任意 $h$ 序列，统计 $a$ 序列的方案数。

$h_i = 0$  时，$a_i$ 可以变成任意大的数，所以一定不会影响答案。 

先把 $a$ 序列变成它的异或差分，差分后的序列和原序列仍然一一对应。现在限制变成了不存在 $i,j$ 使得 $a_i = a_j$ 且 $h_i = h_{i-1} = h_{j} = h_{j-1} = 1$，然后 $a_1$ 随便填。

设 $f_{n,i}$ 为长为 $n$ 的 01 序列中有多少含有恰好 $i$ 对连续的 $1$。知道了 $f_i$ 那么答案就是 $\sum\limits_{i = 0}^{n-1}{f_i \binom{2^k}{i} (2^{k})^{n-i}}$。

要求 $f_{n,i}$，考虑朴素 DP：设 $g_{i,j,0/1}$ 为长为 $i$ 的序列中有 $j$ 对连续的 $1$，且最后一位是 $0$ 或 $1$ 的方案数。有：

$$ g_{i,j,0} = g_{i-1,j,0} + g_{i-1,j,1} $$
$$ g_{i,j,1} = g_{i-1,j,0} + g_{i-1,j-1,1} $$

直接暴力转移，复杂度 $O(n^2)$，能得 $60$ 到 $80$ 分。

其实我们只需要 $g_{n,i,0/1}$，考虑 $F_{i,0/1} = \sum\limits_{j = 0}^{\infty}{g_{i,j,0/1} x^{j}}$。上述转移用 $F$ 刻画就是：

$$ F_{i,0} = F_{i-1,0} + F_{i-1,1} $$
$$ F_{i,1} = F_{i-1,0} + xF_{i-1,1} $$

是不是很矩阵？可以用矩阵再刻画：

$$
\begin{bmatrix}
F_{n,0} & F_{n,1}\\0 & 0
\end{bmatrix}
= 
\begin{bmatrix}
1 & 1\\0 & 0
\end{bmatrix}

{\begin{bmatrix}
1 & 1\\1 & x
\end{bmatrix}}^{n-1}
$$

后面就很明了啦。直接算显然爆炸，考虑插值。把 NTT 要用的单位根全都带进去算一遍，再逆回来就能得到 $f$ 数组，进而得到答案。时间复杂度 $O(n \log n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
void rd(){}
template<typename T,typename... U> void rd(T &x,U&... arg){
	x=0;int f=1;char c=getchar();
	while(c<'0'||c>'9'){if(c=='-') f=-1;c=getchar();}
	while(c>='0'&&c<='9') x=x*10+c-48,c=getchar();
	x*=f;rd(arg...);
}
const int N=1<<21;
const int mod=998244353;
int n,k,maxn;
inline int KSM(int x,int n){
	int ans=1;
	while(n){
		if(n&1)ans=1ll*ans*x%mod;
		x=1ll*x*x%mod;
		n>>=1;
	}
	return ans;
}
int rt[N+5],f[N+5],id[N+5];
inline void Init(int n){
	int k=__builtin_ctz(n);
	for(int i=1;i<n;i++){
		if(i&1)id[i]=id[i>>1]>>1|(1<<(k-1));
		else id[i]=id[i>>1]>>1;
	}
	rt[n/2]=1;
	int bas=KSM(3,(mod-1)/n);
	for(int i=n/2+1;i<n;i++)rt[i]=1ll*rt[i-1]*bas%mod;
	for(int i=n/2-1;i>=1;i--)rt[i]=rt[i*2];
}
inline void IDFT(int* a,int n){
	for(int i=0;i<n;i++)
		if(i<id[i])swap(a[i],a[id[i]]);
	for(int i=1;i<n;i<<=1){
		for(int j=0;j<n;j+=i*2){
			for(int k=0;k<i;k++){
				int x=a[j+k],y=a[i+j+k];
				a[j+k]=(x+1ll*y*rt[i+k]%mod)%mod;
				a[i+j+k]=(x+1ll*(mod-y)*rt[i+k]%mod)%mod;
			}
		}
	}
	reverse(a+1,a+n);
	int invn=KSM(n,mod-2);
	for(int i=0;i<n;i++)a[i]=1ll*a[i]*invn%mod;
}
struct Matrix{
	int m[2][2];
	Matrix(){memset(m,0,sizeof m);}
	Matrix(int _a,int _b,int _c,int _d){m[0][0]=_a,m[0][1]=_b,m[1][0]=_c,m[1][1]=_d;}
	int* operator[](int x){return m[x];}
	Matrix operator*(Matrix b){
		Matrix c;
		c[0][0]=(1ll*m[0][0]*b[0][0]+1ll*m[0][1]*b[1][0])%mod;
		c[0][1]=(1ll*m[0][0]*b[1][0]+1ll*m[0][1]*b[1][1])%mod;
		c[1][0]=(1ll*m[0][1]*b[0][0]+1ll*m[1][1]*b[1][0])%mod;
		c[1][1]=(1ll*m[0][1]*b[1][0]+1ll*m[1][1]*b[1][1])%mod;
		return c;
	}
};
inline Matrix KSM(Matrix x,int n){
	Matrix ans=Matrix(1,0,0,1);
	while(n){
		if(n&1)ans=ans*x;
		x=x*x;
		n>>=1;
	}return ans;
}
signed main(){
	rd(n,k);
	maxn=1;
	while(maxn<=n)maxn*=2;
	Init(maxn);
	int BAS=KSM(3,(mod-1)/maxn),now=1;
	for(int i=0;i<maxn;i++){
		Matrix bas=Matrix(1,1,0,0),m=Matrix(1,1,1,now);
		bas=bas*KSM(m,n-1);
		f[i]=(bas[0][0]+bas[0][1])%mod;
		now=1ll*now*BAS%mod;
	}
	IDFT(f,maxn);
	int ans=0;now=KSM(2,k),BAS=1;
	for(int i=0;i<n;i++){
		(ans+=1ll*f[i]*BAS%mod*KSM(KSM(2,k),n-i)%mod)%=mod;
		BAS=1ll*BAS*(now--)%mod;
	}
	printf("%lld\n",1ll*ans%mod*KSM(KSM(KSM(2,k),n),mod-2)%mod);
	return 0;
}

```

---

## 作者：Phobia (赞：4)

前面的 $\mathcal{O}\left(n^2\right)$ 部分简单提一下。

首先简化一下这个给定的~~司马~~条件，瞪眼不难看出，如果存在 $i\neq j$ 使得 $B_i\operatorname{xor}B_{i+1}=B_j\operatorname{xor}B_{j+1}$，那么这个 $A$，$H$ 一定是不合法的，特别注意样例 2 提醒我们对于 $H_i=1$ 的 $i$ 不会影响答案。所以不妨考虑如何用 $H$ 去生成 $A$，设 $dp\left(i,j,0/1\right)$ 表示前 $i$ 个中存在 $j$ 个有效的 $A_i\operatorname{xor}A_{i+1}$，$H_i=0/1$ 的方案数，容易写出转移方程：

$$dp\left(i+1,j+1,0\right)\gets dp\left(i,j,0\right)*\left(2^k-j\right)$$
$$dp\left(i+1,j,1\right)\gets dp\left(i,j,0\right)*2^k$$
$$dp\left(i+1,j,0\right)\gets dp\left(i,j,1\right)*2^k$$
$$dp\left(i+1,j,1\right)\gets dp\left(i,j,1\right)*2^k$$

然后观察到只有 $00$ 相连时转移比较特殊，不难看出，假设 $H$ 中有 $x$ 个 $00$ 相连，那么这个 $H$ 对总方案数的贡献就是 $\frac{2^{k\left(n-x-1\right)}\left(2^k!\right)}{\left(2^k-x\right)!}$，所以问题就转到对所有 $H$ 中的 $x$ 计数。

~~然后你会发现这东西司马难做~~，于是你想起了 [[ABC260Ex] Colorfulness](https://www.luogu.com.cn/problem/AT_abc260_h) 这道题，你发现如果把 $1$ 看成不同的数字，这两个东西几乎仅有 $0$ 的个数是不确定的一点区别，于是你尝试写了一下答案的至少有 $m$ 个位置为 $00$ 的方案数的生成函数生成函数，简单讲就是枚举一下 $0$ 的个数，就是这个东西：

$$F\left(x\right)=1+\sum\limits_{i=1}^n\sum_{j=0}^{i-1}\binom{n-j}{i-j}\binom{i-1}{j}x^j$$

你尝试变换一下求和顺序。

$$=1+\sum\limits_{j=0}^{n-1}\frac{\left(n-j\right)!x^j}{j!}\sum\limits_{i=j+1}^n\frac{\left(i-1\right)!}{\left(n-i\right)!}\frac{1}{\left(i-1-j\right)!\left(i-j\right)!}$$

然后你发现这个东西怎么看怎么可以卷积。

$$=1+\sum\limits_{j=0}^{n-1}\frac{\left(n-j\right)!x^j}{j!}\sum\limits_{x-y=j}\frac{x!}{\left(n-x-1\right)!y!(y+1)!}$$

然后经典套路。

$$=1+\sum\limits_{j=0}^{n-1}\frac{\left(n-j\right)!x^j}{j!}\sum\limits_{x+(n-y)=n+j }\frac{x!}{\left(n-x-1\right)!y!(y+1)!}$$

然后根据二项式定理得到恰好的生成函数 $G\left(x\right)$，然后就做完了，一共两次 $NTT$，还挺简单了，~~然而比赛中我推这个式子推了快 2 个小时，然后 T4 没时间调了，喜提 400pts~~。

~~~cpp
#include <bits/stdc++.h>

using namespace std;

inline int read()
{
    int res = 0, ch = getchar();
    for (; !isdigit(ch); ch = getchar())
        ;
    for (; isdigit(ch); ch = getchar())
        res = (res << 3) + (res << 1) + (ch & 15);
    return res;
}

typedef long long i64;

const int P = 998244353, inv2 = P + 1 >> 1;

inline int add(int x, int y)
{
    return x + y >= P ? x + y - P : x + y;
}

inline int sub(int x, int y)
{
    return x >= y ? x - y : x - y + P;
}

inline int mul(int x, int y)
{
    return (i64)x * y % P;
}

template<class ...Args>
inline int mul(int x, Args... args)
{
    return mul(x, mul(args...));
}

inline int qpow(int x, int y)
{
    int res = 1;
    while (y)
    {
        if (y & 1)
            res = mul(res, x);
        x = mul(x, x);
        y >>= 1;
    }
    return res;
}

namespace polynomial
{
    const int N = (1 << 21) + 5;
    typedef int poly_t[N];

    void NTT(int n, int on, int* F)
    {
        static int rev[N];
        for (int i = 1; i < n; ++i)
        {
            rev[i] = rev[i >> 1] >> 1 | (i & 1) * (n >> 1);
            if (i < rev[i])
                swap(F[i], F[rev[i]]);
        }
        for (int m = 2; m <= n; m <<= 1)
        {
            int wn = qpow(3, (P - 1) / m);
            for (int i = 0; i < n; i += m)
            {
                int w = 1;
                for (int j = i; j < i + m / 2; ++j)
                {
                    int x = F[j], y = mul(F[j + m / 2], w);
                    F[j] = add(x, y);
                    F[j + m / 2] = sub(x, y);
                    w = mul(w, wn);
                }
            }
        }
        if (on == -1)
        {
            int inv = qpow(n, P - 2);
            reverse(F + 1, F + n);
            for (int i = 0; i < n; ++i)
                F[i] = mul(F[i], inv);
        }
    }
};

typedef vector<int> poly;

inline int upper(int n)
{
    int m = 1;
    while (m < n)
        m <<= 1;
    return m;
}

poly operator*(const poly& F, const poly& G)
{
    static polynomial::poly_t A, B;
    int n = F.size() + G.size() - 1, m = upper(n);
    fill(A, A + m, 0);
    fill(B, B + m, 0);
    copy(F.begin(), F.end(), A);
    copy(G.begin(), G.end(), B);
    polynomial::NTT(m, 1, A);
    polynomial::NTT(m, 1, B);
    for (int i = 0; i < m; ++i)
        B[i] = mul(A[i], B[i]);
    polynomial::NTT(m, -1, B);
    return poly(B, B + n);
}

const int N = 1e6 + 5;

int n, k, fac[N], ifac[N];

int main()
{
    n = read(), k = qpow(2, read());
    fac[0] = 1;
    for (int i = 1; i <= n; ++i)
        fac[i] = mul(fac[i - 1], i);
    ifac[n] = qpow(fac[n], P - 2);
    for (int i = n; i >= 1; --i)
        ifac[i - 1] = mul(ifac[i], i);
    poly A(n), B(n + 1), C(n), D(n + 1);
    for (int i = 0; i < n; ++i)
        A[i] = mul(fac[i], ifac[n - i - 1]);
    for (int i = 0; i < n; ++i)
        B[n - i] = mul(ifac[i], ifac[i + 1]);
    A = A * B;
    for (int i = 0; i < n; ++i)
        C[i] = mul(A[i + n], fac[n - i], ifac[i]);
    C[0] = add(C[0], 1);
    for (int i = 0; i < n; ++i)
        C[i] = mul(C[i], fac[i]);
    for (int i = 0; i <= n; ++i)
        D[n - i] = mul((i & 1) ? P - 1 : 1, ifac[i]);
    C = C * D;
    int ans = 0;
    for (int i = 0, w = 1; i < n; ++i)
    {
        ans = add(ans, mul(C[i + n], qpow(k, n - i), ifac[i], w));
        w = mul(w, k - i);
    }
    printf("%d\n", mul(ans, qpow(qpow(k, P - 2), n)));
    return 0;
}
~~~

---

## 作者：Lyrella (赞：1)

# 简要题意

有一个序列 $A,A_i\in[0,2^k)$，其中 $A_i$ 在值域内随机取值。你需要给出一个 01 序列 $H$，满足不存在 $i\neq j,A_i\oplus A_{i-1}=A_j\oplus A_{j-1},H_{i}=H_{i-1}=H_j=H_{j-1}=0$，求任意给出一个 $H$ 合法的概率。

# 题解

首先可以发现如果对序列做一次差分没有任何影响，于是将条件改成 $A_i=A_j$，所以如果 $H$ 中有连续的 0 就需要满足 $A$ 不同，否则就随便填，我们可以设 $f_i$ 表示序列中有 i 个连续两个 0 的方案数，于是答案就为：

$$
\sum_{i=0}^{n-1}f_i\left(2^k\right)^{\underline{i}}\left(2^k\right)^{n-i}
$$

考虑 dp 求 $f_i$。设 $g_{i,j,0/1}$ 表示填了前 $i$ 个位置，有 $j$ 个连续的 0 且第 $i$ 个位置填 0/1 的方案数。简单 dp 有：

$$
\begin{aligned}
g_{i,j,0}&=g_{i-1,j-1,0}+g_{i-1,j,1}\\
g_{i,j,1}&=g_{i-1,j,0}+g_{i-1,j,1}
\end{aligned}
$$

但是这样是 $O(n^2)$ 的，然后这里有一个 trick：看到数对相乘就往向量和矩阵上面想。于是考虑生成函数，设 $G_{i,0/1}=\sum\limits_jg_{i,j,0/1}x^j$，然后把转移写成矩阵形式：

$$
\begin{bmatrix}
G_{i,0}\\G_{i,1}
\end{bmatrix}
=
\begin{bmatrix}
x&1\\1&1
\end{bmatrix}
^{n-1}
\begin{bmatrix}
1\\1
\end{bmatrix}
$$

这个时候直接 NTT 套矩阵快速幂是 $O(n\log^2n)$，显然爆炸，于是考虑优化。因为是生成函数，所以我们不关心 $x$ 的取值。若我们通过 $O(n)$ 次矩阵快速幂求出若干点值然后再 $O(n\log n)$ 快速插值就可以保证复杂度。$x$ 的选取和 NTT 原理相同，我们直接取单位根即可。

# 代码

```cpp
signed main(){
    n = rd(), k = rd();
    lim_init(n << 1); init(lim); rev_init();
    rt = qmi(3, (p - 1) / lim);
    for(int i = 0, cur = 1; i < lim; ++i, cur = Mul(cur, rt)){
        mat A(2, 2), B(2, 1); A[0][0] = cur, A[0][1] = A[1][0] = A[1][1] = 1;
        B[0][0] = B[1][0] = 1;
        A = qmi(A, n - 1) * B; f[i] = Add(A[0][0], A[1][0]);
    }
    // cout << lim << endl;
    // for(int i = 0; i < lim; ++i)printf("F[%d] = %d\n", i, f[i]);
    NTT(f, 0); for(int i = 0; i < lim; ++i)f[i] = Mul(f[i], inum[lim]);
    // cout << lim << endl;
    // for(int i = 0; i < lim; ++i)printf("F[%d] = %d\n", i, f[i]);
    for(int i = 0, s = 1, cur = qmi(2, k); i < n; ++i, s = Mul(s, cur--))
        ans = Add(ans, Mul(f[i], Mul(s, qmi(qmi(2, k), n - i))));
    cout << Mul(ans, Inv(qmi(qmi(2, k), n)));
    return 0;
}
```

---

## 作者：喵仔牛奶 (赞：1)

定义序列 $A_1,A_2,\cdots,A_n$ 的异或差分 $B_i=A_i\operatorname{xor}A_{i+1}$。可以发现如果检测失败，一定存在 $[x,x+1],[y,y+1]$ 使其检测失败。如果所有 $x,y\in[1,n)\land x\neq y$ 都检测成功，就合法。

考虑 $H_x,H_y$，如果 $H_x=H_y=\tt 0$，那么如果 $B_x=B_y$ 就检测失败，否则成功；如果 $H_x=\tt 1$ 或 $H_y=\tt 1$，那么其中一个数修改为 $2^k$ 就可以使得 $B_x\neq B_y$。

将 $H_i=\tt 1$ 看做在异或差分里覆盖相邻的两个数 $i-1,i$，合法条件就是没有被覆盖的数不能相同。特别地，$H_i=\tt 1$ 只会覆盖 $1$，而 $H_n=\tt 1$ 只会覆盖 $n-1$。

由于 $V=2^k$，所以每个异或差分出现的概率相等，可以不用管原序列具体是啥。假设剩下 $x$ 个没覆盖的位置，就有 $\dfrac{V!}{(V-x)!}\times V^{n-1-x}$ 种填数的方案，我们考虑数覆盖方案。

接下来做法很多，介绍一种做法。

在一个位置修改会影响它和后面的数。设 $f_{i,j}$ 是前 $i$ 个位置被覆盖、$i+1$ 未被覆盖，$[1,i]$ 中有 $j$ 个位置未被覆盖，且 $i-1$ 被修改的方案数。$g_{i,j}$ 是前 $i$ 个位置被覆盖、$i+1$ 未被覆盖，$[1,i]$ 中有 $j$ 个位置未被覆盖，且 $i-1$ 没有被修改的方案数。

由于 $i+1$ 未被覆盖，$i$ 处肯定没有修改。我们考虑加入对 $i-1$ 的修改来转移 $f_{i,j}$：
- $i-1$ 已被覆盖：需要满足 $i-1$ 没有修改过，方案数是 $f_{i-1,j}$。
- $i-1$ 未被覆盖：前面 $i-2$ 个随便填，$f_{i-2,j}+g_{i-2,j}$。

我们考虑空出 $i$ 来转移 $g$：
- 前面 $i-1$ 个随便填，$f_{i-1,j-1}+g_{i-1,j-1}$。

综上：
$$
\begin{cases}
f_{i,j}=f_{i-1,j}+f_{i-2,j}+g_{i-2,j}\\
g_{i,j}=f_{i-1,j-1}+g_{i-1,j-1}
\end{cases}
$$

答案就是 $\displaystyle\frac{1}{V^{n-1}}\sum_{i=0}^{n-1}(f_{n,i}\times 2+g_{n,i})\times\frac{V!}{(V-i)!}\times V^{n-1-i}$
。

直接做是 $\mathcal{O}(n^2)$ 的，期望得分 $60$，我们考虑优化。

令 $F_i(x)=\sum_{j=0}^{\infty}f_{i,j}x^i$，$G_i(x)=\sum_{j=0}^{\infty}g_{i,j}x^i$

转移可以写成：
$$
\begin{cases}
F_i(x)=F_{i-1}(x)+F_{i-2}(x)+G_{i-2}(x)\\
G_i(x)=xF_{i-1}(x)+xG_{i-1}(x)
\end{cases}
$$

可以写成 $2\times 2$ 矩阵：
$$
\begin{bmatrix}
1,1\\
1,x\\
\end{bmatrix}
\begin{bmatrix}F_{i-1}(x)\\F_{i-2}(x)+G_{i-2}(x)\end{bmatrix}

=
\begin{bmatrix}F_{i}(x)\\F_{i-1}(x)+G_{i-1}(x)\end{bmatrix}
$$

观察到答案次数只有 $n-1$，我们直接把每个单位根带进去，矩阵快速幂 $\mathcal{O}(2^3\times\log n)$ 算出答案，然后一遍 DNTT 插出来原多项式就可以了。

时间复杂度 $\mathcal{O}(n\log n)$，期望得分 $100$。由于只有 $1$ 次 NTT，常数较小，std 极限数据不到 0.25s。

---


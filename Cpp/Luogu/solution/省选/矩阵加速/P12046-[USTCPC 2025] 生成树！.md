# [USTCPC 2025] 生成树！

## 题目背景

克露丝卡尔酱喜欢生成树！

克露丝卡尔酱认为对称结构十分完美！

克露丝卡尔酱可爱！

## 题目描述

克露丝卡尔酱想要计数 **$n+1$ 个点的 $k$ 阶轮**的生成树个数。

**$n+1$ 个点的 $k$ 阶轮**的定义为：

- $0$ 为中心，$1\sim n$ 构成一个环（对于 $1 \le i <n$，$i$ 和 $i+1$ 之间有连边，$1$ 和 $n$ 之间有连边）。
- 对于 $1 \le i \le \dfrac{n}{k}$，$0$ 和 $ik$ 之间有额外连边。

**保证 $n \bmod k = 0$，答案对 $10^9+7$ 取模。**

## 说明/提示

两个样例中的轮分别为：

![](https://cdn.luogu.com.cn/upload/image_hosting/4fgbshrn.png)

## 样例 #1

### 输入

```
4 1```

### 输出

```
45```

## 样例 #2

### 输入

```
6 2```

### 输出

```
50```

# 题解

## 作者：Purslane (赞：5)

# Solution

高考数学做法。

考虑枚举所有和 $0$ 连的点的编号的间隔，设为 $p_1k$,$p_2k$，$p_3k$,$\cdots$。

显然需要满足：$\sum p_i = \frac{n}{k}$。

给定一组 $\{p\}$ 之后，你有 $\prod p_ik$ 种方法断掉环上的边。而显然还有 $p_1$ 种方法确定第一个点的位置。所以答案就是：

$$
\sum_{\sum p_i = \frac{n}{k}} p_1 \prod p_ik
$$

显然我们能写出 $O(n^2)$ 的 DP：设 

$$dp_n = \sum_{\sum p_i = n} p_1 \prod p_ik$$

则有

$$
dp_n = n^2 k + \sum_{j=1}^{n-1} f_j (i-j)k
$$

暴力实现 $O(n^2)$ 的 DP 发现是对的！

考虑优化。如果你高考数学学明白了，就知道这种递推式带求和的数列求值可以多写几项然后抵消。

发现 $i-j$ 这个东西是等差数列，那么灵光一闪——我们计算 $dp_{n+2} + dp_{n+1} - 2dp_{n}$。（等差数列 $\{x\}$ 满足性质 $a_x + a_{x+2} = 2a_{x+1}$，所以我们这么做可以抵消掉很多东西！）

具体咋化简的不展示了，可以得到：

$$
dp_{n+2} = 2k + (2+k) dp_{n+1} - dp_n
$$

特别的，$dp_1=k$，$dp_2 = 4k + k^2$。

使用矩阵快速幂维护即可，复杂度 $O(\log n)$。

```cpp
#include<bits/stdc++.h>
#define int long long
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=100,MOD=1e9+7;
int n,k;
struct Mat {int v[3][3];}ori,mul;
Mat operator *(Mat A,Mat B) {
	Mat C;
	memset(C.v,0,sizeof(C.v));
	ffor(i,0,2) ffor(j,0,2) ffor(k,0,2) C.v[i][k]=(C.v[i][k]+A.v[i][j]*B.v[j][k])%MOD;
	return C;
}
Mat operator ^(Mat A,int p) {
	Mat C;
	memset(C.v,0,sizeof(C.v));
	C.v[0][0]=C.v[1][1]=C.v[2][2]=1;
	while(p) {
		if(p&1) C=C*A;
		A=A*A,p>>=1;
	}
	return C;
}
signed main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>n>>k;
	int nk=k%MOD;
	ori.v[0][0]=(4*nk+nk*nk)%MOD,ori.v[0][1]=nk,ori.v[0][2]=1;
	mul.v[0][0]=nk+2,mul.v[0][1]=1,mul.v[0][2]=0;
	mul.v[1][0]=-1,mul.v[1][1]=0,mul.v[1][2]=0;
	mul.v[2][0]=2*nk%MOD,mul.v[2][1]=0,mul.v[2][2]=1;
	if(n/k==1) cout<<nk;
	else ori=ori*(mul^(n/k-2)),cout<<(ori.v[0][0]%MOD+MOD)%MOD;
	return 0;
}
```

---

## 作者：VinstaG173 (赞：2)

神秘做法。

发现我们确定生成树中点 $0$ 连出的边的形态后，外圈的环被分成若干部分，每部分是 $ck$ 条边，为了形成生成树从其中任意断一条边均可。

记 $m=n/k$，答案为 $f_{k,m}$，枚举生成树中点 $1$ 顺逆时针转遇到下一个与 $0$ 相邻的点，则有 $c$ 种可能这两个点之间包含点 $1$ 的部分有 $ck$ 条边，剩余 $(m-c)k$ 条边继续拆分成若干部分，记答案为 $g_{k,m-c}$，则列出算式：

$$f_{k,m}=\sum_{c=1}^mc\cdot ckg_{k,m-c}.$$

则对 $g$ 的求解可以直接枚举第一部分有 $ck$ 条边，得到递推式：

$$g_{k,m}=\sum_{c=1}^mckg_{k,m-c}.$$

设 $f_k$ 的 OGF 为 $F_k$，$g_k$ 的 OGF 为 $G_k$，则有

$$F_k=\dfrac{kx(1+x)}{(1-x)^3}G_k, G_k=\dfrac{kx}{(1-x)^2}G_k+1,$$

整理化简，解得

$$\begin{aligned}
F_k(x)&=\dfrac{kx(1+x)}{(1-x)(1-(2+k)x+x^2)}\\
&=-\dfrac2{1-x}+\dfrac{k\alpha^2}{(1-\alpha)^2(\alpha-x)}+\dfrac{k\beta^2}{(1-\beta)^2(\beta-x)},
\end{aligned}$$

其中 $\alpha,\beta=\frac{(2+k)\pm\sqrt{k^2+4k}}2$ 为 $1-(2+k)x+x^2=0$ 的两根，由 Vieta 定理满足 $\alpha\beta=1,\alpha+\beta=2+k$。用留数法计算 $\lim_{x\to c}(c-x)F_k(x)$ 可得到上述展开式中 $\frac1{c-x}$ 项的系数。只举 $\alpha$ 的例子计算：

$$\begin{aligned}
\lim_{x\to\alpha}(\alpha-x)F_k(x)&=\dfrac{k\alpha(1+\alpha)}{(1-\alpha)(\beta-\alpha)}\\
&=\dfrac{k\alpha^2(1+\alpha)}{(1-\alpha)(\alpha\beta-\alpha^2)}\\
&=\dfrac{k\alpha^2}{(1-\alpha)^2}.
\end{aligned}$$

故

$$\begin{aligned}
f_{k,m}&=[x^m]F_k\\
&=-2+\dfrac{k\alpha^{1-m}}{(1-\alpha)^2}+\dfrac{k\beta^{1-m}}{(1-\beta)^2}\\
&=\alpha^m+\beta^m-2,
\end{aligned}$$

其中

$$\dfrac{k\alpha^{1-m}}{(1-\alpha)^2}=\dfrac{k\beta^m}{\beta-2+\alpha}=\beta^m.$$

由于 $\alpha,\beta$ 为上述方程两根，直接矩阵快速幂求解即可。时间复杂度 $O(\log n)$，空间复杂度 $O(1)$。

Code:
```cpp
const int ntf=1e9+7;

ll n,k;
ll r[2][2],a[2][2],t[2][2];
inline void mlt(){
	t[0][0]=(r[0][0]*a[0][0]+r[0][1]*a[1][0])%ntf;
	t[0][1]=(r[0][0]*a[0][1]+r[0][1]*a[1][1])%ntf;
	t[1][0]=(r[1][0]*a[0][0]+r[1][1]*a[1][0])%ntf;
	t[1][1]=(r[1][0]*a[0][1]+r[1][1]*a[1][1])%ntf;
	r[0][0]=t[0][0],r[0][1]=t[0][1];
	r[1][0]=t[1][0],r[1][1]=t[1][1];
}inline void car(){
	t[0][0]=(a[0][0]*a[0][0]+a[0][1]*a[1][0])%ntf;
	t[0][1]=(a[0][0]*a[0][1]+a[0][1]*a[1][1])%ntf;
	t[1][0]=(a[1][0]*a[0][0]+a[1][1]*a[1][0])%ntf;
	t[1][1]=(a[1][0]*a[0][1]+a[1][1]*a[1][1])%ntf;
	a[0][0]=t[0][0],a[0][1]=t[0][1];
	a[1][0]=t[1][0],a[1][1]=t[1][1];
}inline void _qpw(ll v){
	while(v){
		if(v&1)mlt();
		car();v>>=1;
	}
}

ll ans;
inline void solve(){
	cin>>n>>k;n/=k;k%=ntf;
	r[0][0]=r[1][1]=a[1][0]=1;
	r[0][1]=r[1][0]=a[1][1]=0;
	a[0][1]=ntf-1;a[0][0]=(k+2);_qpw(n-1);
	ans=((k+2)*r[0][0]+r[0][1]*2+ntf-2)%ntf;
	cout<<ans<<"\n";
}
```

---

## 作者：Jorisy (赞：2)

下文中，我们定义：
- 「辐边」：和节点 $0$ 相连的边。
- 「辐点」：和节点 $0$ 相连的点。
- 「轮边」：不和节点 $0$ 相连的边。
- 「轮点」：编号大于 $0$ 的节点。
- 「轮径」：相邻两个辐点之间只经过轮边的路径。

考虑如何刻画一棵生成树。

首先考虑钦定所有辐边是否被删。假设有相邻的两条辐边 $(0,u),(0,v)$，那么存在环 $0\to u\to\cdots\to v\to 0$，此时我们必须在 $u\to v$ 的路径上删去**一条**边（因为如果删去两条的话，就会多出来一个连通块，不是一棵生成树）。

设 $f_i$ 为 $i$ 条辐边、$ki$ 个轮点对应的答案。其中辐边 $(0,ki)$ **必选**。

对于一个 $ki$ 个轮点的轮 $G_i$，我们考虑如何从 $kj(j<i)$ 个轮点的轮 $G_j$ 变化过来。我们可以对于 $G_j$ 的一个轮点，断开以它为端点的一条轮径，并插入那些边。如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/sa360cmb.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/81n1g52o.png)

我们钦定了 $G_i$ 从 $G_j$ 变化而来，那么意味着，我们新添加的辐边**都不会被选**。

那么节点 $ki$ 和节点 $kj$ 之间，我们必须要删去一条边。由于一共有 $(i-j)k$ 条边，所以我们有 $(i-j)k$ 种方案，那么我们从 $G_j$ 过来的方案数就是 $f_j\cdot (i-j)k$。

当然，我们也可能不会从某个 $G_j$ 变化得来，就是说其他辐边都没选，那么我们考虑总的轮边有 $ki$ 条，辐边有 $i$ 条，所以方案数就是乘起来，即 $i^2k$。

综上所述，就有 $f_i=i^2k+\sum\limits_{j=1}^{i-1}f_j\cdot(i-j)k=i^2k+k\sum\limits_{j=1}^{i-1}(i-j)f_j$。

直接算是平方的。

考虑这东西怎么进一步简化。

尝试偏移一下下标：

$$
\begin{aligned}
f_{i-1}&=(i-1)^2k+\boxed{k\sum\limits_{j=1}^{i-2}(i-j-1)f_j}\\
f_i&=i^2k+k\sum\limits_{j=1}^{i-1}(i-j)f_j=i^2k+kf_{i-1}+\boxed{k\sum\limits_{j=1}^{i-2}(i-j)f_j}\\
f_{i+1}&=(i+1)^2k+k\sum\limits_{j=1}^i(i-j+1)f_j=(i+1)^2k+kf_i+2kf_{i-1}+\boxed{k\sum\limits_{j=1}^{i-2}(i-j+1)f_j}\\
\end{aligned}
$$

方框框出来的部分，考虑利用类似等差中项的东西消掉。

$$
\begin{aligned}
&2f_i-f_{i-1}-f_{i+1}\\
=&2i^2k+2kf_{i-1}-(i-1)^2k-(i+1)^2k-kf_i-2kf_{i-1}\\
=&-2k-kf_i
\end{aligned}
$$

于是就有最终的式子：

$$
f_i=(k+2)f_{i-1}-f_{i-2}+2k
$$

然后我们就可以上矩阵快速幂了。

容易得到 $\begin{bmatrix}(k+2)&-1&1\\1&0&0\\0&0&1\end{bmatrix}\times\begin{bmatrix}f_i\\f_{i-1}\\2k\end{bmatrix}=\begin{bmatrix}f_{i+1}\\f_i\\2k\end{bmatrix}$，就做完了。

```cpp
#include<bits/stdc++.h>
#define N 
#define ll long long
#define mod 1000000007
using namespace std;

struct mat{
    ll a[5][5];
    int n=3,m=3;
    ll* operator[](int i){return a[i];}
    void init(int x=3,int y=3)
    {
        n=x;
        m=y;
        for(int i=0;i<n;i++)
        {
            for(int j=0;j<m;j++)
            {
                a[i][j]=0;
            }
        }
    }
    void one(int x=3,int y=3)
    {
        init(x,y);
        for(int i=0;i<min(n,m);i++) a[i][i]=1;
    }
}ans;
mat operator*(mat x,mat y)
{
    mat res;
    res.init();
    int n=x.n,m=x.m,p=y.m;
    for(int k=0;k<m;k++)
    {
        for(int i=0;i<n;i++)
        {
            for(int j=0;j<p;j++)
            {
                (res[i][j]+=x[i][k]*y[k][j])%=mod;
            }
        }
    }
    return res;
}

mat qpow(mat x,ll y)
{
    mat res;
    res.one();
    while(y)
    {
        if(y&1) res=res*x;
        x=x*x;
        y>>=1;
        cerr<<y<<' ';
    }
    return res;
}

int main()
{
    //freopen(".in","r",stdin);
    //freopen(".out","w",stdout);
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    ll n,k;
    cin>>n>>k;
    ll m=k%mod;
    mat ans;
    ans.init(1,3);
    ans[0][0]=(m*m+m*4)%mod;
    ans[1][0]=m;
    ans[2][0]=m*2%mod;
    mat a;
    a.init(3,3);
    a[0][0]=(m+2)%mod;
    a[0][1]=mod-1;
    a[0][2]=1;
    a[1][0]=1;
    a[1][1]=0;
    a[1][2]=0;
    a[2][0]=0;
    a[2][1]=0;
    a[2][2]=1;
    if(n==k)
    {
        cout<<m;
        return 0;
    }
    cout<<(qpow(a,n/k-2)*ans)[0][0];
    return 0;
}
```

---

## 作者：min_inf (赞：1)

这都啥啊？

首先选出一些与 $0$ 相连的边，把环分成若干段，每段选一条边。

直接设 $f_{i,0/1,0/1,0/1}$ 表示前 $i$ 条环边，有没有选与 $0$ 相连的边，第一段选没选最后一段选没选，显然可以矩阵快速幂。

```cpp
T qpow(T x,ll y){
    T ret{};repn(i,8)ret[i][i]=1;
    while(y){
        if(y&1)ret=ret*x;
        x=x*x,y>>=1;
    }
    return ret;
}

signed main(){
    // freopen(".in","r",stdin);
    // freopen(".out","w",stdout);
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    cin>>n>>k;
    T A{};
    repn(i,8){
        A[i][i]=1;
        if((i&4)&&!(i&1))A[i][i|1]=1;
        if(!(i&4)&&!(i&2))A[i][i|2]=1;
    }
    A=qpow(A,k);
    T B{};
    repn(i,8){
        B[i][i]=1;
        if((i&4)&&(i&1))B[i][i^1]=1;
        if(!(i&4))B[i][i|4]=1;
    }
    T r=qpow(A*B,n/k);
    cout<<(r[0][5]+r[0][6]).val()<<'\n';
}
```

---

## 作者：Rosaya (赞：0)

这里找规律等等可以通过此题的方法不在介绍，仅介绍 std 做法。

### 前置芝士

Matrix-Tree 定理。

列出 $n+1$ 个点 $k$ 阶轮的 Laplace 矩阵，再删掉中心点所在行列，最终答案即为该矩阵的行列式。

### 常规做法

答案只需计算如下矩阵的行列式，其中主对角线上的值 $a_{i,i}$ 在 $i$ 是 $k$ 的倍数时为 $3$，否则为 $2$。

$$
\begin{vmatrix}
    2 & -1 & \cdots & -1 \\
    -1 & 2 & \cdots & 0 \\
    \vdots & \vdots & \ddots & \vdots \\
    -1 & 0 & \cdots & 3
\end{vmatrix}
$$

该行列式可以拆成四部分：

$$
\begin{vmatrix}
    2 & -1 & \cdots & 0 \\
    -1 & 2 & \cdots & 0 \\
    \vdots & \vdots & \ddots & \vdots \\
    -1 & 0 & \cdots & 3
\end{vmatrix}
+
\begin{vmatrix}
    2 & -1 & \cdots & -1 \\
    -1 & 2 & \cdots & 0 \\
    \vdots & \vdots & \ddots & \vdots \\
    0 & 0 & \cdots & 3
\end{vmatrix}
\\
+
\begin{vmatrix}
    2 & -1 & \cdots & 0 \\
    -1 & 2 & \cdots & 0 \\
    \vdots & \vdots & \ddots & \vdots \\
    0 & 0 & \cdots & 3
\end{vmatrix}
+
\begin{vmatrix}
    0 & 0 & \cdots & -1 \\
    0 & 2 & \cdots & 0 \\
    \vdots & \vdots & \ddots & \vdots \\
    -1 & 0 & \cdots & 0
\end{vmatrix}
$$

其中前两项的答案均为 $-1$，后两项行列式满足如下形式：

$$
\begin{vmatrix}
    a_{1,1} & -1 & \cdots & 0 \\
    -1 & a_{2,2} & \cdots & 0 \\
    \vdots & \vdots & \ddots & \vdots \\
    0 & 0 & \cdots & a_{n,n}
\end{vmatrix}
$$

记 $\Delta_n$ 表示 $n \times n$ 的矩阵的行列式，有性质 $\Delta_n=a_{n,n}\Delta_{n-1} - \Delta_{n-2}$，可以用矩阵快速幂优化，复杂度 $O(\log n)$。

---


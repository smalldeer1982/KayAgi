# [NOI2007] 生成树计数

## 题目描述

最近，小栋在无向连通图的生成树个数计算方面有了惊人的进展，他发现：

- $n$ 个结点的环的生成树个数为 $n$。
- $n$ 个结点的完全图的生成树个数为 $n^{n-2}$ 。

这两个发现让小栋欣喜若狂，由此更加坚定了他继续计算生成树个数的想法，他要计算出各种各样图的生成树数目。

一天，小栋和同学聚会，大家围坐在一张大圆桌周围。小栋看了看，马上想到了生成树问题。如果把每个同学看成一个结点，邻座（结点间距离为 $1$）的同学间连一条边，就变成了一个环。可是，小栋对环的计数已经十分娴熟且不再感兴趣。于是，小栋又把图变了一下：不仅把邻座的同学之间连一条边，还把相隔一个座位（结点间距离为 $2$）的同学之间也连一条边，将结点间有边直接相连的这两种情况统称为 有边相连，如图 $1$ 所示。

![](https://cdn.luogu.com.cn/upload/image_hosting/5lvvgbor.png) 

小栋以前没有计算过这类图的生成树个数，但是，他想起了老师讲过的计算任意图的生成树个数的一种通用方法：构造一个 $n\times n$ 的矩阵 $A=\{ a_{i,j}\}$，其中：

$$a_{i,j}=\begin{cases}
d_i & i=j \\
-1 & \text{$i, j$ 之间有边直接相连} \\
0 & \text{其他情况}
\end{cases}$$

与图 1 相应的 $A$ 矩阵如下所示。为了计算图 1 所对应的生成数的个数，只要去掉矩阵 $A$ 的最后一行和最后一列，得到一个 $(n-1)\times(n-1)$ 的矩阵 $B$，计算出矩阵 $B$ 的行列式的值便可得到图 1 的生成树的个数。

$$
A=\begin{bmatrix}
4 & -1 & -1 & 0 & 0 & 0 & -1 & -1 \\
-1 & 4 & -1 & -1 & 0 & 0 & 0 & -1 \\
-1 & -1 & 4 & -1 & -1 & 0 & 0 & 0 \\
0 & -1 & -1 & 4 & -1 & -1 & 0 & 0 \\
0 & 0 & -1 & -1 & 4 & -1 & -1 & 0 \\
0 & 0 & 0 & -1 & -1 & 4 & -1 & -1 \\
-1 & 0 & 0 & 0 & -1 & -1 & 4 & -1 \\
-1 & -1 & 0 & 0 & 0 & -1 & -1 & 4 \\
\end{bmatrix},\\
B=\begin{bmatrix}
4 & -1 & -1 & 0 & 0 & 0 & -1  \\
-1 & 4 & -1 & -1 & 0 & 0 & 0  \\
-1 & -1 & 4 & -1 & -1 & 0 & 0 \\
0 & -1 & -1 & 4 & -1 & -1 & 0 \\
0 & 0 & -1 & -1 & 4 & -1 & -1 \\
0 & 0 & 0 & -1 & -1 & 4 & -1 \\
-1 & 0 & 0 & 0 & -1 & -1 & 4 \\
\end{bmatrix},
$$

所以生成树的个数为 $\det B =3528$。小栋发现利用通用方法，因计算过于复杂而很难算出来，而且用其他方法也难以找到更简便的公式进行计算。于是，他将图做了简化，从一个地方将圆桌断开，这样所有的同学形成了一条链，连接距离为 1 和距离为 2 的点。例如八个点的情形如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/cfo7z7yu.png) 

这样生成树的总数就减少了很多。小栋不停的思考，一直到聚会结束，终于找到了一种快捷的方法计算出这个图的生成树个数。可是，如果把距离为 $3$ 的点也连起来，小栋就不知道如何快捷计算了。现在，请你帮助小栋计算这类图的生成树的数目。


## 说明/提示

样例对应的图如下：

$$
A = \begin{bmatrix}
3 & -1 & -1 & -1 & 0 \\
-1 & 4 & -1 & -1 & -1 \\
-1 & -1 & 4 & -1 & -1 \\
-1 & -1 & -1 & 4 & -1 \\
0 & -1 & -1 & -1 & 3 \\
\end{bmatrix},
B = \begin{bmatrix}
3 & -1 & -1 & -1 \\
-1 & 4 & -1 & -1  \\
-1 & -1 & 4 & -1  \\
-1 & -1 & -1 & 4  \\
\end{bmatrix}, \det B = 75
$$

### 数据规模和约定

| 测试点编号 |   $k$   |      $n$      |
| :--------: | :-----: | :-----------: |
|     1      |  $=2$   |   $\le 10$    |
|     2      |  $=3$   |     $=5$      |
|     3      |  $=4$   |   $\le 10$    |
|     4      |  $=5$   |     $=10$     |
|     5      | $\le 3$ |   $\le 100$   |
|     6      | $\le 5$ |   $\le 100$   |
|     7      | $\le 3$ |  $\le 2000$   |
|     8      | $\le 5$ |  $\le 10000$  |
|     9      | $\le 3$ | $\le 10^{15}$ |
|     10     | $\le 5$ | $\le 10^{15}$ |

此外，对于所有数据，$2\le k\le n$。

### 提示

以下为行列式的一种计算方法。记 $\sigma(\bm P)$ 表示排列 $\bm P$ 中逆序对的数量，那么可以求得矩阵 $B$ 的行列式如下：

$$\det B=\sum_{\bm P=[p_1,p_2,\cdots,p_n]} (-1)^{\sigma(\bm P)} \prod_{i=1}^n b_{i,p_i}$$

例如，对于 $B=\begin{bmatrix}1 & 2 & 3 \\ 4 & 5 & 6 \\ 7 & 8 & 0\end{bmatrix}$，其行列式计算如下：

$$
\def\arraystretch{1.5}
\begin{array}{|c|c|c|c|c|c|}\hline
\bm P & \sigma(\bm P) & b_{1,p_1} & b_{2,p_2} & b_{3,p_3} & (-1)^{\sigma(\bm P)}\prod_{i=1}^n b_{i,p_i} \\ \hline
[1, 2, 3] & 0 & 1 & 5 & 0 & 0 \\ \hline
[1, 3, 2] & 1 & 1 & 6 & 8 & -48 \\\hline
[2, 1, 3] & 1 & 2 & 4 & 0 & 0 \\\hline
[2, 3, 1] & 2 & 2 & 6 & 7 & 84 \\\hline
[3, 1, 2] & 2 & 3 & 4 & 8 & 96 \\\hline
[3, 2, 1] & 3 & 3 & 5 & 7 & -105 \\\hline
\end{array}
$$

所以 $B$ 的行列式值为 $0-48+0+84+96-105=27$。


## 样例 #1

### 输入

```
3 5```

### 输出

```
75```

# 题解

## 作者：Kinandra (赞：25)

标签: 矩阵树定理, 高斯消元, 矩阵快速幂.

(就我一个老实人真的按照题目讲的矩阵树定理做的吗?

#### Part 1 观察矩阵

为了方便讨论, 令 $k=3$ , 其余情况可以很容易的推广.

我们考虑 $n=9$ 时的基尔霍夫矩阵(为了方便观察~~懒得打~~,值为 $0$ 的位置用空表示):
$$
\left[
\begin {matrix}
3&-1&-1&-1&&&&&\\
-1&4&-1&-1&-1&&&&\\
-1&-1&5&-1&-1&-1&&&\\
-1&-1&-1&6&-1&-1&-1&&\\
&-1&-1&-1&6&-1&-1&-1&\\
&&-1&-1&-1&6&-1&-1&-1\\
&&&-1&-1&-1&5&-1&-1\\
&&&&-1&-1&-1&4&-1\\
&&&&&-1&-1&-1&3
\end {matrix}
\right]
$$

惊讶(并不)地发现矩阵的 $k+1\sim n-k$ 行都是由 $k$ 个 $-1$ , 一个 $2k$ 和  $k$ 个 $-1$ 拼接而成的.

求行列式通常需要将矩阵消成上三角的形式, 并将对角线上的元素相乘, 我们通过若干次交换两行将矩阵变成如下形式:
$$
\left[
\begin {matrix}
-1&-1&-1&6&-1&-1&-1&&\\
&-1&-1&-1&6&-1&-1&-1&\\
3&-1&-1&-1&&&&&\\
-1&4&-1&-1&-1&&&&\\
-1&-1&5&-1&-1&-1&&&\\
&&-1&-1&-1&6&-1&-1&-1\\
&&&-1&-1&-1&5&-1&-1\\
&&&&-1&-1&-1&4&-1\\
&&&&&-1&-1&-1&3
\end {matrix}
\right]
$$
这里矩阵有点小, 可能看不出这么交换的目的, 考虑一个 $n$ 较大的情况( $n=17$ ):
$$
\left[
\begin {matrix}
-1&-1&-1&6&-1&-1&-1&&\\
&-1&-1&-1&6&-1&-1&-1&\\
&&-1&-1&-1&6&-1&-1&-1&\\
&&&-1&-1&-1&6&-1&-1&-1&\\
&&&&-1&-1&-1&6&-1&-1&-1&\\
&&&&&-1&-1&-1&6&-1&-1&-1&\\
&&&&&&-1&-1&-1&6&-1&-1&-1&\\
&&&&&&&-1&-1&-1&6&-1&-1&-1&\\
&&&&&&&&-1&-1&-1&6&-1&-1&-1&\\
&&&&&&&&&-1&-1&-1&6&-1&-1&-1&\\
3&-1&-1&-1&&&&&\\
-1&4&-1&-1&-1&&&&\\
-1&-1&5&-1&-1&-1&&&\\
&&&&&&&&&&-1&-1&-1&6&-1&-1&-1\\
&&&&&&&&&&&-1&-1&-1&5&-1&-1\\
&&&&&&&&&&&&-1&-1&-1&4&-1\\
&&&&&&&&&&&&&-1&-1&-1&3
\end {matrix}
\right]
$$
我们发现矩阵的前 $n-2k-1$ 行已经形成了一个 '天然' 的上三角, 并且这 $n-2k-1$ 行的形式都十分相似: $k$ 个 $-1$ , $1$ 个 $2k$ 和 $k$ 个$-1$ 一次拼接而成. 

#### Part 2 高斯消元

我们考虑将矩阵的用前 $n-2k-1$ 行去消元第 $n-2k\sim n-k-1$ 行过程. 由于前 $n-2k-1$ 行非 $0$ 位置个数都为 $2k+1$ 且非 $0$ 的位置具有特殊性, 所以消元的过程中被消的行向量非 $0$ 位置数量始终不大于 $2k$ (但是每消一次整体向右移动一个位置), 考虑**一次消元**这 $2k$ 个的值是如何变化的: 我们有这样一个行向量


$$
\left[
\begin {matrix}
a_0&a_1&a_2&a_3&a_4&a_5&0
\end {matrix}
\right]
$$

为了消去 $a0$ , 加上如下行向量:
$$
a_0\left[
\begin {matrix}
-1&-1&-1&6&-1&-1&-1
\end {matrix}
\right]
$$
从而得到:
$$
\left[
\begin {matrix}
0&a_1-a_0&a_2-a_0&a_3+6a_0&a_4-a_0&a_5-a_0&-a_0
\end {matrix}
\right]
$$
记为:

$$
\left[
\begin {matrix}
0&a'_0&a'_1&a'_2&a'_3&a'_4&a'_5
\end {matrix}
\right]
$$

显然这个消元可以通过矩阵来转移: 

$$
\left[
\begin {matrix}
a'_0&a'_1&a'_2&a'_3&a'_4&a'_5
\end {matrix}
\right]=
\left[
\begin {matrix}
a_0&a_1&a_2&a_3&a_4&a_5
\end {matrix}
\right]
\left[
\begin {matrix}
-1&1&0&0&0&0\\
-1&0&1&0&0&0\\
6&0&0&1&0&0\\
-1&0&0&0&1&0\\
-1&0&0&0&0&1\\
-1&0&0&0&0&0
\end {matrix}
\right]
$$

于是我们就可以通过快速幂来加速高斯消元. 我们需要消 $k$ 行, 所以这个部分的时间复杂度为 $\mathcal O(k^4\log n)$ .

将第 $n-2k\sim n-k-1$ 行用前 $n-2k-1$ 行消元过后, 非 $0$ 位置都分布在 $n-k\sim n$ 行, 我们暴力对剩余部分($n-2k\sim n-1$ 行)消元即可, 这个部分时间复杂度为 $\mathcal O(k^3)$.

总时间复杂度 $\mathcal O(k^4\log n)$.

#### Part 3 细节

`Part 1` 中我们进行了若干次交换两行的操作, 这会使行列式乘上若干个 $-1$ , 不要忘记计算.

最后算行列式时不要忘记将 '天然' 的上三角中的 $-1$ 的贡献算上.

注意要计算的是主余子式, 不要忘记去掉一行一列.

$n\leqslant 2k$ 时不存在'天然'的上三角, 但是此时直接暴力消元是 $\mathcal O(k^3)$ , 特殊处理即可.

#### Part 4 Code

```cpp
#include <bits/stdc++.h>
#define mod 65521
using namespace std;
long long read();
int M(int x) { return x >= mod ? x - mod : x; }
void Add(int& x, int y) { (x += y) >= mod ? x -= mod : x; }
int fsp(unsigned bs, int p) {
    int rt = 1;
    while (p) {
        if (p & 1) rt = bs * rt % mod;
        bs = bs * bs % mod, p >>= 1;
    }
    return rt;
}

long long n;
int k, lim;

int b[102][102];
void work1() {
    for (int i = 1; i <= n; ++i)
        for (int j = i + 1; j <= min(i + k, (int)n); ++j)
            ++b[i][i], ++b[j][j], b[i][j] = b[j][i] = mod - 1;
    lim = n - 1;
}

int K;
struct Mat {
    int a[21][21];
    int* operator[](int p) { return a[p]; }
    Mat operator*(Mat& b) {
        static Mat rt;
        for (int i = 1; i <= K; ++i)
            for (int j = 1; j <= K; ++j) {
                rt[i][j] = 0;
                for (int k = 1; k <= K; ++k)
                    Add(rt[i][j], 1ll * a[i][k] * b[k][j] % mod);
            }
        return rt;
    }
} bs, res;

int c[21];

void work2() {
    K = k << 1;
    for (int i = 1; i <= K; ++i)
        bs[i][1] = mod - 1, bs[i][i + 1] = res[i][i] = 1;
    bs[k][1] = K;
    for (long long p = n - K - 1; p; p >>= 1)
        (p & 1) ? res = res * bs : res, bs = bs * bs;

    for (int i = 1; i <= k; ++i) {
        memset(c, 0, sizeof c);
        for (int j = 1; j <= i + k; ++j) c[j] = mod - 1;
        c[i] = k + i - 1;
        for (int j = 1; j <= K; ++j)
            for (int k = 1; k <= K; ++k)
                Add(b[i][j], 1ll * res[j][k] * c[k] % mod);
    }

    for (int i = k + 1; i <= K; ++i) {
        for (int j = i - k; j <= K; ++j) b[i][j] = mod - 1;
        b[i][i] = 3 * k - i + 1;
    }

    lim = K;
    if (1ll * (n - K - 1) * (k + 1) & 1)
        for (int i = 1; i <= K; ++i) b[1][i] = mod - b[1][i];
}

void solve() {
    int res = 1, ny;
    for (int i = 1; i <= lim; ++i) {
        if (!b[i][i])
            for (int j = i; j <= lim; ++j)
                if (b[j][i]) {
                    swap(b[i], b[j]), res = mod - res;
                    break;
                }
        res = 1ll * res * b[i][i] % mod, ny = fsp(b[i][i], mod - 2);
        for (int j = i; j <= lim; ++j) b[i][j] = 1ll * b[i][j] * ny % mod;
        for (int j = i + 1; j <= lim; ++j)
            for (int k = lim; k >= i; --k)
                Add(b[j][k], mod - 1ll * b[j][i] * b[i][k] % mod);
    }
    printf("%d\n", M(res));
}
int main() {
    k = read(), (n = read()) <= 20 ? work1() : work2(), solve();
    return 0;
}

long long read() {
    long long x = 0;
    char c = getchar();
    while (c < '0' || c > '9') c = getchar();
    while (c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();
    return x;
}
```



---

## 作者：Kelin (赞：12)

## [题意](https://blog.csdn.net/BeNoble_/article/details/79749248)

一个$n$个点的树,点$i$只能向$[i-k,i-1]$内的点连边,求有标号生成树的个数

$n\le10^{15},k\le5$

---

## 题解

题面误导向系列,显然不能像他说的那样做吧

因为发现$k$特别小,所以可以考虑用状压表示$i$和前$k-1$个点的联通情况

考虑$DP,f[i][j]$表示前$i$个点,$[i-k,i]$这些点的连通性是$j$的方案数

考虑到有些状态本质上是一样的($e.g.\ 1\to2\to3=1\to3\to2$)

所以考虑用最小表示法来存状态

>如$k=3$时有$5$种状态$:111,112,121,122,123$

>数字表示第$i$属于第几个集合

>如$121$表示$\{1,3\},\{2\}$即$1,3$联通

通过爆搜搜出所有满足[最小表示法](https://wenku.baidu.com/view/df40d5287375a417866f8f7e.html)的状态$(k=5$时有$52$种$)$

>这里稍微解释一下,就是假设当前点所在的最大的集合编号是$i$

>那么下一个点最多只能在第$i+1$个集合,否则就是非法的,不然就更新最大值

>这个爆搜完全可以直接每个点开一个数组去判断,代码里用压位二进制写的

然后一个最小表示法实际上对应很多种树$(n$个点的有标号无根树个数的$n^{n-2})$

>$e.g.\ 11122$表示$\{1,2,3\},\{4,5\}$对应的树的种数是$3^{3-2}\times2^{2-2}=3$

暴力枚举新加入一个点之后两个状态之间的转移

也就是$2^k$枚举新的点和前面的那些点$([i-k,i-1])$是否连边

>$1.$下一状态不能有环

>$2.$下一状态必须与当前状态所有的点都连通

>$3.$可以用并查集来判断并求出所有满足条件的转移数

>$4.$转移的时候把点$i-k-1$当做$0$号点,$i$点当做$k$号点,会比较好转移一些

设$g[j][k]$表示从$j$状态转移到$k$状态的方案数

设$Cnt$为状态数,那么有

$$f[i][j]=\sum_{k=0}^{Cnt}f[i-1][k]\times g[k][j]$$

然后可以发现这就是矩阵乘法的一步,所以把$g$表示成矩阵然后直接矩阵快速幂就好了

最后把矩阵快幂得到的矩阵乘上$f[k]$这个矩阵的和就是答案了

因为最后的状态必须是$1\ldots1$(所有点都要联通),所以只要算上第一个状态的答案就好了

~~这个代码可能要认真看几遍才能看得懂~~

~~感觉还是比较短的~~

```
#include<bits/stdc++.h>
#define fp(i,a,b) for(register int i=a,I=b+1;i<I;++i)
#define fd(i,a,b) for(register int i=a,I=b-1;i>I;--i)
#define go(u) for(register int i=fi[u],v=e[i].to;i;v=e[i=e[i].nx].to)
#define file(s) freopen(s".in","r",stdin),freopen(s".out","w",stdout)
template<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}
template<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}
using namespace std;
const int K=6,S=55,P=65521,T[]={1,1,1,3,16,125};
typedef long long ll;
int k,Cnt,ans,sum[K],fa[K],f[S],sta[S],pos[1<<16];ll n;
inline int pls(int a,int b){return a+=b,a<P?a:a-P;}
struct matrix{
    int a[S][S];
    matrix(int x=0){memset(a,0,sizeof a);if(x)fp(i,1,Cnt)a[i][i]=1;}
    inline int*operator[](int x){return a[x];}
    inline matrix operator*(matrix b){
        matrix c;
        fp(i,1,Cnt)fp(k,1,Cnt)if(a[i][k])fp(j,1,Cnt)
            c[i][j]=pls(c[i][j],(ll)a[i][k]*b[k][j]%P);
        return c;
    }
    inline matrix operator^(ll b){
        matrix x(1),a=*this;
        for(;b;b>>=1,a=a*a)if(b&1)x=x*a;
        return x;
    }
}g;
inline bool chk(int s){
    int tp=1;
    for(int i=0;i<3*k;tp|=1<<(((s>>i)&7)),i+=3)
        fp(j,0,((s>>i)&7)-1)if(!(tp&(1<<j)))return 0;
    return 1;
}
void dfs(int d,int s){
    if(d==k){if(chk(s))sta[++Cnt]=s,pos[s]=Cnt;return;}
    fp(i,1,k)dfs(d+1,s|(i<<(3*d)));
}
int gf(int x){return fa[x]==x?x:fa[x]=gf(fa[x]);}
inline void Getnx(int i,int s,int nw){
    fp(j,0,k)fa[j]=j;
    fp(j,0,k)fp(l,j+1,k)
        if(((nw>>(3*j))&7)==((nw>>(3*l))&7))fa[gf(j)]=gf(l);
    fp(j,0,k)if(s&(1<<j)){
        if(gf(j)^gf(k))fa[fa[j]]=k;
        else return;
    }
    int tp=0,nx=0,fg=0;
    fp(j,1,k)if(gf(0)==gf(j)){fg=1;break;};
    if(!fg)return;
    fp(j,0,k-1)if(!(nx&(7<<(j*3)))){
        nx|=++tp<<(j*3);
        fp(l,j+1,k-1)if(gf(j+1)==gf(l+1))
            nx|=tp<<(l*3);
    }
    ++g[i][pos[nx]];
}
int main(){
    #ifndef ONLINE_JUDGE
        file("s");
    #endif
    scanf("%d%lld",&k,&n);dfs(0,1);
    fp(i,1,Cnt){
        f[i]=1;int nw=sta[i];
        memset(sum,0,sizeof sum);
        fp(j,0,k-1)++sum[(nw>>(j*3))&7];
        fp(j,1,k)f[i]*=T[sum[j]];
        fp(s,0,(1<<k)-1)Getnx(i,s,nw);
    }g=g^(n-k);
    fp(i,1,Cnt)ans=pls(ans,f[i]*g[i][1]%P);
    printf("%d",ans);
return 0;
}
```

---

## 作者：Cyhlnj (赞：10)

~~感觉是一道很简单的题目。。。~~

$k$ 只有 $5$，那么考虑 $k$ 个 $k$ 个递推

那么可以设 $f[i][j]$ 表示以 $i$ 结尾的 $k$ 个的状态为 $j$(连通性)

每次向后移动去掉前面一个点，加入后面一个点，然后去掉的点必须和后面的一个点连通

而 $j$ 爆搜出来用最小表示法表示只有 $52$ 个有用的状态

那么只要预处理出 $g[i][j]$ 表示状态 $i$ 转移到状态 $j$ 的方案数就可以矩乘了

#### 状态数才 52!!!

~~怎么暴力怎么写~~

直接暴力就好了，枚举一个状态，$2^k$ 枚举加入点的连边，每次暴力并查集判断一下，然后暴力扫一遍求出最小表示法就好了

最后指数级暴力枚举最开始的 $k$ 个点之间的连边求出初始的状态

然后大力矩乘

~~感觉还是很简单。。。~~

```cpp
# include <bits/stdc++.h>
using namespace std;
typedef long long ll;

namespace IO {
    const int maxn(1 << 21 | 1);

    char ibuf[maxn], *iS, *iT, c;
    int f;

    inline char Getc() {
        return iS == iT ? (iT = (iS = ibuf) + fread(ibuf, 1, maxn, stdin), (iS == iT ? EOF : *iS++)) : *iS++;
    }

    template <class Int> inline void In(Int &x) {
        for (f = 1, c = Getc(); c < '0' || c > '9'; c = Getc()) f = c == '-' ? -1 : 1;
        for (x = 0; c >= '0' && c <= '9'; c = Getc()) x = (x << 1) + (x << 3) + (c ^ 48);
        x *= f;
    }
}

using IO :: In;

const int mod(65521);

int id[555555], st[53], p[20], v[20], fa[20], tot, k;
ll n;

struct Matrix {
	ll a[53][53];

	inline Matrix() {
		memset(a, 0, sizeof(a));
	}

	inline ll* operator [](int x) {
		return a[x];
	}

	inline Matrix operator *(Matrix b) const {
		Matrix c;
		for (int i = 1; i <= tot; ++i)
			for (int j = 1; j <= tot; ++j)
				for (int k = 1; k <= tot; ++k) c[i][k] += a[i][j] * b[j][k];
		for (int i = 1; i <= tot; ++i)
			for (int j = 1; j <= tot; ++j) c[i][j] %= mod;
		return c;
	}
} f, trs;

void Dfs(int x) {
	if (x > k) {
		int cnt = 0, sta = 0;
		for (int i = 1; i <= k; ++i) v[i] = 0;
		for (int i = 1; i <= k; ++i) if (!v[p[i]]) v[p[i]] = ++cnt;
		for (int i = 1; i <= k; ++i) sta = sta * 10 + v[p[i]];
		if (!id[sta]) id[sta] = ++tot, st[tot] = sta;
		return;
	}
	for (int i = 1; i <= k; ++i) p[x] = i, Dfs(x + 1);
}

inline int Find(int x) {
	return fa[x] == x ? x : fa[x] = Find(fa[x]);
}

inline void Pre_Work(int s) {
	for (int i = 1; i <= k; ++i) fa[i] = i;
	for (int i = 1, c = 0; i <= k; ++i)
		for (int j = 1; j < i; ++j, ++c)
			if (s & (1 << c)) {
				if (Find(i) == Find(j)) return;
				fa[Find(i)] = Find(j);
			}
	int cnt = 0, sta = 0;
	for (int i = 1; i <= k; ++i) v[i] = 0, p[i] = Find(i);
	for (int i = 1; i <= k; ++i) if (!v[p[i]]) v[p[i]] = ++cnt;
	for (int i = 1; i <= k; ++i) sta = sta * 10 + v[p[i]];
	++f[1][id[sta]];
}

inline void Add(int fr, int s) {
	for (int i = 1; i <= k; ++i) fa[i] = i;
	fa[k + 1] = k + 1, v[k + 1] = 0;
	for (int st = fr, i = k; i; --i) p[i] = st % 10 + k, st /= 10;
	for (int i = 1; i <= k; ++i)
		for (int j = i + 1; j <= k; ++j)
			if (p[i] == p[j] && Find(i) != Find(j)) fa[Find(j)] = Find(i);
	for (int i = 1; i <= k; ++i)
		if (s & (1 << (i - 1))) {
			if (Find(i) == Find(k + 1)) return;
			fa[Find(k + 1)] = Find(i);
		}
	int flg = 0;
	for (int i = 1; i <= k; ++i) if (Find(1) == Find(i + 1)) flg = 1;
	if (!flg) return;
	int cnt = 0, sta = 0;
	for (int i = 1; i <= k; ++i) v[i] = 0, p[i] = Find(i + 1);
	for (int i = 1; i <= k; ++i) if (!v[p[i]]) v[p[i]] = ++cnt;
	for (int i = 1; i <= k; ++i) sta = sta * 10 + v[p[i]];
	++trs[id[fr]][id[sta]];
}

int main() {
	In(k), In(n), n -= k, Dfs(1);
	int s = 1 << (k * (k - 1) >> 1);
	for (int i = 0; i < s; ++i) Pre_Work(i);
	s = 1 << k;
	for (int i = 1; i <= tot; ++i)
		for (int j = 0; j < s; ++j) Add(st[i], j);
	for (; n; n >>= 1, trs = trs * trs)
		if (n & 1) f = f * trs;
	printf("%lld\n", f[1][1]);
    return 0;
}
```

---

## 作者：totorato (赞：10)

# 生成树计数 Berlekamp-Massey算法

## 状态压缩Dp
此题存在一种状态压缩Dp的解法，该做法的存在得益于矩阵快速幂的优化。由于用到了矩阵，我们不难发现，这道题是可以看成是一种齐次线性常系数递推的。

## 齐次线性常系数递推
这种递推可以表示成一种类似卷积的过程：

已知数列$F$的前$N$项，和长度为$M$的线性递推方程$G$，有：

$$\forall i>M,\ \ F_i = \sum_{j=1}^{M}F_{i-j}G_j$$

## Berlekamp-Massey算法
这种算法就是通过一段给定的$F$，求出最短的$G$，使得：
$$\forall deg(F)\geq i>deg(G),\ F_i = \sum_{j=1}^{deg(G)}G_jF_{i-j}$$

这个算法的教程可以参考https://www.k-xzy.xyz/ 中的几篇(推荐)，或者网上其他教程。

## 问题的解决
知道了这些理论基础，我们就可以先利用最简单的$Matrix-Tree$定理求出数列的前几项，然后用$Berlekamp-Massey$算法求出递推方程，最后用矩阵快速幂优化该递推方程的求解。这样，我们就可以避开最复杂的状态压缩Dp的过程。

这种算法在**状态压缩Dp的转移方程非常复杂**，或**递推方式不明显**时非常有用。
## 代码实现
我该题的代码分为三个模块：1.矩阵树定理打表、2.Berlekamp-Massey算法求递推方程、3.矩阵快速幂优化递推方程的求解。

```cpp
#include <bits/stdc++.h>
#define MX 5005
#define MOD 65521LL

using namespace std;

typedef long long ll;

ll N, K;

ll qpow(ll x, ll t)
{
	ll ans = 1;
	while(t)
	{
		if(t & 1) ans = ans*x%MOD;
		x = x*x%MOD;
		t >>= 1;
	}
	return ans;
}

ll inv(ll x)
{
	return qpow(x, MOD-2);
}

namespace Table
{
	struct mat
	{
		int n;
		ll x[MX][MX];
		
		void init() {memset(x, 0, sizeof(x));}
		
		void gauss()
		{
			for(int i=1; i<=n; i++)
			{
				int pos = i;
				if(!x[i][i])
				{
					for(int j=i+1; j<=n; j++) 
					{
						if(x[j][i])
						{
							pos = j;
							break;
						}
					}
					swap(x[i], x[pos]);
				}
				for(int j=i+1; j<=n; j++)
				{
					if(x[j][i])
					{
						ll mul = x[j][i]*inv(x[i][i])%MOD;
						for(int k=i; k<=n; k++) x[j][k] = (x[j][k]-x[i][k]*mul+MOD*MOD)%MOD;
					}
				}
			}
		}
		
		ll det()
		{
			gauss();
			ll ans = 1;
			for(int i=1; i<=n; i++) ans = ans*x[i][i]%MOD;
			return ans<0 ? -ans : ans;
		}
	} T;
	
	void calc()
	{
		T.init();
		for(int i=1; i<=N; i++)
			for(int j=1; j<=K; j++)
				if(i+j<=N)
					T.x[i+j][i] = T.x[i][i+j] = -1, T.x[i][i] ++, T.x[i+j][i+j] ++;
		T.n = N-1;
		printf("%lld\n", T.det());
	}
};

namespace Belekamp_Massey
{
	ll A[MX], F[MX], G[MX];
	int lenA, lenF, lenG;
	
	ll calc(int p, int len, ll* x)
	{
		ll ret = 0;
		for(int i=1; i<=len; i++)
			ret += A[p-i]*x[i];
		return ret%MOD;
	}
	
	void work()
	{
		G[1] = inv(A[1]), lenG = 1;
		F[1] = 0, lenF = 1;
		for(int i=2; i<=lenA; i++)
		{
			ll delta = (A[i]-calc(i, lenF, F)+MOD)%MOD;
			if(!delta)
			{
				memmove(G+2, G+1, sizeof(ll)*lenG);
				G[1] = 0;
				lenG ++;
			}
			else
			{
				swap(lenG, lenF);
				swap(G, F);
				for(int j=1; j<=lenF; j++) F[j] = (F[j]*delta+G[j])%MOD;
				memmove(G+2, G+1, sizeof(ll)*lenG);
				G[1] = MOD-1;
				lenG ++;
				ll now = inv(calc(i+1, lenG, G));
				for(int j=1; j<=lenG; j++) G[j] = G[j]*now%MOD;
			}
		}
		for(int i=1; i<=lenF; i++) printf("%lld ", F[i]);
		putchar('\n');
	}
	
	void input()
	{
		scanf("%d", &lenA);
		for(int i=1; i<=lenA; i++) scanf("%lld", &A[i]);
	}
};

namespace Matrix
{
	int n;
	
	struct mat
	{
		ll x[50][50];
		
		void init() {memset(x, 0, sizeof(x));}
		
		void E() {init(); for(int i=1; i<=n; i++) x[i][i] = 1;}
		
		void output()
		{
			for(int i=1; i<=n; i++)
			{
				for(int j=1; j<=n; j++) printf("%lld ", x[i][j]);
				putchar('\n');
			}
			putchar('\n');
		}
	};
	
	mat operator * (const mat& a, const mat& b)
	{
		mat c; c.init();
		for(int k=1; k<=n; k++)
			for(int i=1; i<=n; i++)
			{
				int t = a.x[i][k];
				for(int j=1; j<=n; j++)
					c.x[i][j] += t*b.x[k][j];
			}
		for(int i=1; i<=n; i++)
			for(int j=1; j<=n; j++)
				c.x[i][j] %= MOD;
		return c;
	}
	
	mat qpow(const mat& a, ll t)
	{
		mat x = a; mat ans; ans.E();
		while(t)
		{
			if(t & 1) ans = ans*x;
			x = x*x;
			t >>= 1;
		}
		return ans;
	}
	
	ll calc(ll mi, ll si, ll* s, ll* f)
	{
		mat a; a.init();
		n = si;
		if(mi <= si) return s[mi];
		for(int i=1; i<=n; i++) a.x[1][i] = f[i];
		for(int i=2; i<=n; i++) a.x[i][i-1] = 1;
		a = qpow(a, mi-si);
		ll ans = 0;
		for(int i=1; i<=n; i++) ans += a.x[1][i]*s[n+1-i];
		return ans%MOD;
	}
};

ll S1[10] = {1,1};
ll S2[10] = {3,1,1,3};
ll S3[10] = {7,1,1,3,16,75,336,1488};
ll S4[20] = {17,1,1,3,16,125,864,5635,35840,29517,48795,64376,52310,4486,28336,8758,64387,31184};
ll S5[50] = {45,1,1,3,16,125,1296,12005,38927,26915,65410,9167,63054,58705,18773,9079,38064,46824,48121,50048,47533,30210,24390,51276,45393,357,44927, 15398,15923,31582,56586,25233,41258,21255,21563,16387,39423,26418,10008,6962,42377,50881,54893,50452,23715,53140};

ll F1[10] = {1,1};
ll F2[10] = {3,3,65520,0};
ll F3[10] = {7,5,65518,3,65516,1,0,0};
ll F4[20] = {17,7,65520,65496,31,65469,65437,300,65437,65469,31,65496,65520,7,65520,0,0,0};
ll F5[50] = {45,8,5,65489,40,364,63172,62845,2793,7304,50170,14272,13974,32712,27590,63226,30516,31431,62449,44809,2992,62529,20712,3072, 34090,35005,2295,37931,32809,51547,51249,15351,58217,62728,2676,2349,65157,65481,32,65516,65513,1,0,0,0,0};

int main()
{
	scanf("%lld%lld", &K, &N);
	if(K == 1) printf("%lld\n", Matrix::calc(N, F1[0], S1, F1));
	if(K == 2) printf("%lld\n", Matrix::calc(N, F2[0], S2, F2));
	if(K == 3) printf("%lld\n", Matrix::calc(N, F3[0], S3, F3));
	if(K == 4) printf("%lld\n", Matrix::calc(N, F4[0], S4, F4));
	if(K == 5) printf("%lld\n", Matrix::calc(N, F5[0], S5, F5));
	/*int lim = 80;
	
	freopen("3.in", "w", stdout);
	printf("%d\n", lim);
	for(int i=1; i<=lim; i++)
	{
		N = i;
		K = 3;
		Table::calc();
		if(i%100 == 0) fprintf(stderr, "%d\n", i/100);
	}
	freopen("ans3", "w", stdout);
	freopen("3.in", "r", stdin);
	Belekamp_Massey::input();
	Belekamp_Massey::work();*/
	return 0;
}
```

---

## 作者：pldzy (赞：6)

状压 dp + 矩阵快速幂优化。

~~感觉题解区几篇题解说得云里雾里的……也没有一定的证明……~~

[Link.](https://www.luogu.com.cn/problem/P2109)

## Update

- 2023年6月10日：贴上代码，修改错别字。
- 2024年7月26日：修改笔误。造成误解，十分抱歉。

## Solution

### Part1 dp 状态设计

发现 $k$ 的范围很小，具有很强的指向性——状压 dp。

结合题面，发现一个点 $i$ 只可能和 $j\in (i-k,i)$ 的点连边，即 $i-k+1$ 之前的点我们根本不用考虑它和 $i$ 的连接情况，我们只需要**保证 $[1,i-k]$ 这些点连通**即可。

故可以设计状态 $f(i,sta)$ 表示当前考虑到点 $i$，且 $(i-k,i]$ 这 $k$ 个点的连通状态为 $sta$ 时，生成树的方案数。

因为最后要求的是生成树，而生成树的必要条件是 $[1,n]$ 都是连通的。所以我们每次从 $f(i-1,sta')$ 转移到 $f(i, sta)$ 时，都要**保证 $i-k$ 和 $j\in (i-k,i]$ 中至少一个点是连通的**。

为什么这样就可以保证 $f(n,sta_{final})$ 的方案数（其中 $sta_{final}$ 代表 $(n-k,n]$ 都连通的状态）都是合法的（即 $[1,n]$ 都是连通的）？

此处~~口胡~~一个反证法。易知，若 $[1,n]$ 不连通，即有若干个连通块，那我们一定可以找到某个连通块中，编号最大的节点 $i$，满足它和 $(i,i+k]$ 一定都不连通。故我们如果保证了转移时每一个 $i-k$ 和 $j\in (i-k,i]$ 中至少一个点是连通的，那这个图最终一定就是一个连通图。

### Part2 状态压缩

然后考虑状态中 $sta$ 的表述。

其余众多题解都提及了，我们可以使用最小表示法，将每种 $k$ 点连接状态都表示出来。具体地，给同一个连通块中的点都赋上同一数值即可，不同连通块数值不同即可。

对于每种连接状态，预处理 `dfs()` 出来即可，状态总数不超 $60$。

### Part3 dp 状态转移

考虑状态转移。

记 $g(sta',sta)$ 表示从状态 $sta'$ 转移到 $sta$ 的方案数。即，对于一个待转移的点 $i+1$，它可以通过 $g(sta',sta)$ 种方案，和 $j\in [i - k+2,i]$ 的点连边，使得原先 $[i-k+1,i]$ 这些点构成的状态 $sta'$，能转变为现在 $(i-k+1,i+1]$ 这些点构成的状态 $sta'$。

如何保证最终答案的合法性？易知生成树一定是一个无环的连通图。连通性的保证在 Part1 中已经讲解了，现在保证图中一定不出现环。所以我们在两两状态转移的时候一定要注意不能出现环，否则当前状态不合法。

那么存在一个十分显然的转移：

$$f(i,sta)=\sum_{sta'} f(i-1,sta')\times g(sta',sta)$$

然后仔细观察，会发现这个形式实际上是矩阵乘法的形式。故我们在求出了 $g[][]$ 之后，可以使用矩阵快速幂求出最终方案数。

进一步地，不难得出可以省去 $f$ 的第一维。因矩阵快速幂的使用，$f$ 可简化为 $f(1,sta)$。

### Part4 $f$ 数组初始化

注意，$f$ 不能直接采用 `dfs()` 中暴力推出来的状态种类进行初始化。

原因是不同的连边方式可能导致同样的连通状态。

故，我们这样初始化 $f$：对于前 $k$ 个点，一共有 $\dbinom{k}{2}$ 条边，而对于每条边，我们可以选择连或不连，故一共有 $2^{\frac{k\times (k-1)}{2}}$ 种连边方式。对于每种连边方式，我们直接暴力连边，使用并查集维护连通性，即可得到最终连通状态。

总复杂度可过。

## Code

````cpp
#include<bits/stdc++.h>
using namespace std;

typedef long long ll;
#define rep(i, a, b) for(int i = a; i <= b; ++i)
#define Rep(i, a, b) for(int i = a; i < b; ++i)
const int mod = 65521;
ll n;
int id[600005], st[53], p[25], v[25];
int fa[25], tot, k;
struct mtr{
	ll a[53][53];
	inline mtr(){
		memset(a, 0, sizeof a);
	}
	inline ll* operator [](int x){ return a[x];}
	inline mtr operator *(mtr b) const{
		mtr c;
		rep(i, 1, tot) rep(j, 1, tot) rep(k, 1, tot)
			c[i][k] += a[i][j] * b[j][k];
		rep(i, 1, tot) rep(j, 1, tot) c[i][j] %= mod;
		return c;
	}
}f, tr;

inline void dfs(int x){
	if(x > k){
		int cnt, sta; cnt = sta = 0;
		rep(i, 1, k) v[i] = 0;
		rep(i, 1, k) if(!v[p[i]]) v[p[i]] = ++cnt;
		rep(i, 1, k) sta = sta * 10 + v[p[i]];
		if(!id[sta]) id[sta] = ++tot, st[tot] = sta;
		return;
	} rep(i, 1, k) p[x] = i, dfs(x + 1);
}
inline int fnd(int x){
	return fa[x] == x ? x : fa[x] = fnd(fa[x]);
}
inline void init(int s){
	rep(i, 1, k) fa[i] = i;
	for (int i = 1, c = 0; i <= k; ++i)
		for (int j = 1; j < i; ++j, ++c)
			if(s & (1 << c)){
				if(fnd(i) == fnd(j)) return;
				fa[fnd(i)] = fnd(j);
			} 
	int cnt = 0, sta = 0;
	rep(i, 1, k) v[i] = 0, p[i] = fnd(i);
	rep(i, 1, k) if(!v[p[i]]) v[p[i]] = ++cnt;
	rep(i, 1, k) sta = sta * 10 + v[p[i]];
	++f[1][id[sta]];
}

inline void add(int fr, int s){
	rep(i, 1, k) fa[i] = i;
	fa[k + 1] = k + 1, v[k + 1] = 0;
	for(int st = fr, i = k; i; --i) p[i] = st % 10 + k, st /= 10;
	rep(i, 1, k) rep(j, i + 1, k)
		if(p[i] == p[j] and fnd(i) != fnd(j))
			fa[fnd(j)] = fnd(i);
	rep(i, 1, k) if(s & (1 << (i - 1))){
		if(fnd(i) == fnd(k + 1)) return;
		fa[fnd(k + 1)] = fnd(i);
	} int flg = 0;
	rep(i, 1, k) if(fnd(1) == fnd(i + 1)) flg = 1;
	if(!flg) return;
	int cnt = 0, sta = 0;
	rep(i, 1, k) v[i] = 0, p[i] = fnd(i + 1);
	rep(i, 1, k) if(!v[p[i]]) v[p[i]] = ++cnt;
	rep(i, 1, k) sta = sta * 10 + v[p[i]];
	++tr[id[fr]][id[sta]];
}

int main(){
	scanf("%d%lld", &k, &n), n -= k, dfs(1);
	int s = 1 << (k * (k - 1) >> 1);
	Rep(i, 0, s) init(i);
	s = 1 << k;
	rep(i, 1, tot) Rep(j, 0, s) add(st[i], j);
	for(; n; n /= 2, tr = tr * tr) if(n & 1)
		f = f * tr;
	printf("%lld\n", f[1][1]);
	return 0;
}
````

------------

Thanks for reading.

---

## 作者：lalaouye (赞：6)

这是一道递推题。~~写了三个小时~~

如果你推式子能力不强，思路不够清晰，就不要看题解了，因为这道题可以锻炼你的这些能力。

首先注意到 $k \le 5$，那么自然就能想到递推，然后就会发现状态跟前面树的形态有关，但是我们只需要提取出真正有效的状态，那就是前面树的联通情况，所以我们可以把状态先预处理，给每个状态一个 $id$，然后就可以快乐地递推了。**大体**的式子长这样:

$f_{i,j}=\sum v_{j,k}\times f_{i-1,k}$。

其中 $v$ 是在一个状态到另一个状态有多少种转移方式（连边方式）。


然后你就会发现前面 $n$ 非常的大，并且的某些联通状态是无法转移的，所以我们需要矩阵优化，并且~~手推~~暴搜完的 $52$ 种状态，看着就非常恶心，那么该如何处理？我的做法是，把每种状态压成 $10$ 进制储存，一开始我是想用 $5$ 进制的，但是能用 $10$ 进制为啥要用 $5$ 进制？然后我们考虑一种状态能被那类状态转移，这时我们发现：

1.如果当前状态某两项不等（不在同一棵树），且前一个状态的这两项相等（在同一棵树），那就绝对不行。因为你不可能还把别人的边拆了嘛。

2.因为现在在考虑 $i$ 往前连边（容易证明这样转移是可以得到完整答案的），所以说如果当前状态有任意**在同一**棵树的两项**不在** $i$ 所在的树，并且**前一**状态这两项**不在同一**棵树，那就绝对不行，为什么？因为 $i$ 如果往这两项连边，那么那么两个就都会在 $i$ 所在的树，但是现在的状态要求这两项跟 $i$ 不在同一棵树，所以肯定不行。

接下来，就考虑给 $v$ 赋值了，虽然看起来很麻烦很难，实际上想明白了就不难了，我们既然已经知道了状态，那 $i$ 要向哪棵子树连边也就知道了，所以实际上就是把要连边的每一棵子树的大小乘起来就行，当然要特判大小为 $0$ 的树。

最后就只剩下初始化了，题目女子心地告诉我们一张完全图的生成树个数为 $n^{n-2}$，那就也跟刚刚的做法差不多了。

上代码：

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N = 6, P = 65521;
int n, k, tot, s, t;
int color[N], bel[6], fid[55];
short id[1000000];
bool o[6];
void dfs (int x)
{
	if (x > k)
	{
		int tem = 0, pw = 1;
		int cnt = 0;
		memset (bel, 0, sizeof bel);
		for (int i = 1; i <= k; ++ i)
			if (! bel[color[i]])
				bel[color[i]] = ++ cnt;
		for (int i = 1; i <= k; ++ i)
			color[i] = bel[color[i]];
		for (int i = k; i >= 1; -- i)
			tem += color[i] * pw, pw *= 10;
		if (! id[tem])
		{
			id[tem] = ++ tot, fid[tot] = tem;
			if (cnt == 5) s = tot;
			if (cnt == 1) t = tot;
		} return;
	}
	for (int i = 0; i < k; ++ i) color[x] = i, dfs (x + 1);
}
struct Mac
{
	int c[55][55];
};
Mac operator *(const Mac &a, const Mac &b)
{
	Mac ret;
	for (int i = 1; i <= tot; ++ i)
	{
		for (int j = 1; j <= tot; ++ j)
		{
			ret.c[i][j] = 0;
			for (int k = 1; k <= tot; ++ k)
				(ret.c[i][j] += a.c[i][k] * b.c[k][j]) %= P;
		}
	}
	return ret;
}
int pw10[7] = {1, 10, 100, 1000, 10000, 100000, 1000000};
int get (int x, int y)
{ return (y / (pw10[x - 1])) % 10; }
Mac I, A, B;

Mac qpow (Mac x, int y)
{ Mac ret = I; for (; y; y >>= 1) { if (y & 1) ret = ret * x; x = x * x; } return ret; }

int match[6];

//同一子树的显然可以用一种颜色表示 


signed main ()
{
	scanf ("%d %lld", &k, &n);
	if (k >= n)
		return printf ("%d\n", (int)pow (n, n - 2)), 0; //特判 
	dfs (1);//暴搜状态 
	for (int i = 1; i <= tot; ++ i) I.c[i][i] = 1;
	A = I;
	for (int i = 1; i <= tot; ++ i)
	{
		int x = fid[i];
		for (int j = 1; j <= tot; ++ j)
		{
			memset (bel, 0, sizeof bel);
			memset (o, 0, sizeof o);
			int y = fid[j], F = 0;
			for (int a = 2; a <= k; ++ a)
			{
				if (F) break;
				for (int b = 2; b <= k; ++ b)
				{
					if (get (a, x) == get (b, x))//如果两项相等 
					{
						if (get (a - 1, y) ^ get (b - 1, y))//如果前状态两项不等 
						{
							if (get (a, x) ^ get (1, x))//如果当前状态中这两项跟当前不在同一子树 
							{ F = 1; break; }
							else o[get (a - 1, y)] = o[get (b - 1, y)] = 1;
						}
						else
						if (get (a, x) == get (1, x)) 
							o[get (a - 1, y)] = 1;
					}
					else if (get (a - 1, y) == get (b - 1, y))
					{ F = 1; break; }
				}
			}
			if (! F)
			{
				int dat = 1;//赋值 
				for (int a = 1; a <= k; ++ a)
					++ bel[get (a, y)];
				for (int a = 1; a <= k; ++ a)
					if (o[a]) dat *= bel[a];
				B.c[j][i] = dat;
			}
		}
		int dat = 1;
		memset (bel, 0, sizeof bel);//初始化 
		for (int j = 1; j <= k; ++ j)
			++ bel[get (j, x)];
		for (int j = 1; j <= k; ++ j)
			if (bel[j] > 2) dat = dat * pow (bel[j], bel[j] - 2);
		dat %= P;
		A.c[1][i] = dat;
	} 
	Mac ret = A * qpow (B, n - k);
	printf ("%d\n", ret.c[1][t]);
	return 0;
}
```


---

## 作者：Vocalise (赞：5)

## 题意

一个 $n$ 个点的无向图，其中仅编号差不超过 $k$ 的点间有唯一一条无向边，求该图的生成树个数。

$k\le 5,n\le 10^{15},k\le n$

## 题解

$n$ 很大，$k$ 很小。考虑对于连续的 $k$ 个点进行关于连通性的状压 DP，在一次 DP 过程中构造出转移矩阵，然后通过矩阵快速幂求出答案。

为什么是 $k$ 个点：我们需要保证新加入的点与该状态中的所有点都有边。

设 $f_{i,s}$ 表示考虑到第 $i$ 个点，其中 $(i-k,i]$ 中的 $k$ 个点在前 $i$ 个点已经连成的图中的连通性形如 $s$，的方案数。且保证 $\le i-k$ 的点全部连通。

$s$ 并不是一个集合的表示。为了表达连通性，我们设 $s$ 为一个 $k$ 位 $k$ 进制数。两个数位上的数字相同，当且仅当两个位置上的点在一个连通块里。

例如 $(012)_3$，表示三个点都不连通。$(112)_3$，表示 $1$ 和 $2$ 连通，$3$ 独立成一个连通块。

发现在 $k^k$ 个状态中有大量重复的。如 $(112)_3$ 和 $(220)_3$ 表示同一种情况。考虑去重。

令数位上的数字按 $0,1\cdots$ 依次出现，且 $i$ 的首次出现一定早于 $j(j>i)$ 的首次出现即可。

处理完之后发现当 $k=5$ 时有效状态仅有 $52$ 个。

接下来考虑 DP。从 $f_{i,s}$ 向后推：

枚举 $2^k$ 的状态表示 $i+1$ 向前面 $k$ 个点的连边情况。

如果一对 $s$ 中同色的点同时连了边，就不合法。

另外，考虑一种特殊情况：第 $i-k+1$ 个点在 $s$ 中独立成连通块。因为之后它不再有边可连，所以此时必须连边。

整理好状态之后，若有转移 $f_{i,s}\rightarrow f_{i+1,t}$，我们令转移矩阵的 $(t,s)$ 项加一。考虑矩阵乘法的一项即可。这里我们设 $f_i$ 的向量为列向量，$(f_{i,1}\cdots f_{i,x})^T$（状态从 $1$ 标到 $x$），矩阵是左乘向量。

考虑到对于前 $k-1$ 个点，不好处理它们的转移。因此直接构造 $f_k$：

若 $s$ 的非单点连通块大小分别为 $a_1\cdots a_m(a_i>1)$，因为前 $k$ 个点两两有边，所以根据凯莱定理（题中给出），其方案数为：
$$
f_{k,s}=\prod_{i=1}^ma_i^{a_i-2}
$$
最后矩阵快速幂即可。

复杂度 $\Theta((2k)^kk+v^3\log n)$，$v$ 为状态数 $52$。实现上差别影响不大。

```cpp
#include <cstdio>
#include <iostream>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <queue>
#include <vector>

const int S = 3125;
const int T = 55;
const int p = 65521;

typedef long long ll;
char buf[1 << 25] ,*p1 = buf ,*p2 = buf;
#define getchar() (p1 == p2 && (p2 = (p1 = buf) + fread(buf ,1 ,1 << 21 ,stdin) ,p1 == p2) ? EOF : *p1++)
inline ll read() {
    ll x = 0, f = 1; char ch = getchar();
    while(ch > '9' || ch < '0') { if(ch == '-') f = -1; ch = getchar(); }
    while(ch >= '0' && ch <= '9') x = x * 10 + ch - 48, ch = getchar();
    return x * f;
}

inline int Pow(int a,int b) {
    int r = 1;
    while(b--) r *= a;
    return r;
}

int k,U,val[S],sta[S],m,f[S],g[S]/*,f[100][S]*/; ll n;
int tmp[5],b[5],vis[5];

int c[5],q[5],map[5];
int Reduce(int x) {
    for(int i = 0;i < k;i++) c[i] = x % k, x /= k;
    int t = 0;
    for(int i = 0;i < k;i++) q[i] = 0;
    for(int i = 0;i < k;i++) {
        if(!q[c[i]]) map[c[i]] = t++, q[c[i]] = 1;
        c[i] = map[c[i]];
    }
    for(int i = k - 1;i >= 0;i--) x = x * k + c[i];
    return x;
}

void Init() {
    for(int i = 0;i <= U;i++) if(Reduce(i) == i) sta[++m] = i, val[i] = m;
    for(int i = 1;i <= m;i++) {
        int x = sta[i]; 
        for(int j = 0;j < k;j++) x /= k;
    }
    return;
}

int res[T][T],mat[T][T];

int r[T][T];
void Mul(int a[T][T],int b[T][T]) {
    for(int i = 1;i <= m;i++)
        for(int j = 1;j <= m;j++) {
            r[i][j] = 0;
            for(int k = 1;k <= m;k++) r[i][j] = (r[i][j] + 1ll * a[i][k] * b[k][j]) % p;
        }
    for(int i = 1;i <= m;i++)
        for(int j = 1;j <= m;j++) a[i][j] = r[i][j];
    return;
}

int main() {
    k = read(), n = read(), U = Pow(k,k) - 1;
    Init();
    // std::printf("%d\n",m); m = 52 status
    for(int id = 1;id <= m;id++) {
        int s = sta[id], x = s;
        for(int i = 0;i < k;i++) tmp[i] = 0;
        for(int i = 0;i < k;i++) tmp[x % k]++, x /= k;
        f[id] = 1;
        for(int i = 0;i < k;i++) if(tmp[i] > 1)
            f[id] *= Pow(tmp[i],tmp[i] - 2);
    }
    for(int id = 1;id <= m;id++) {
        for(int t = 0;t < (1 << k);t++) {
            int s = sta[id], x = s;
            for(int i = 0;i < k;i++) tmp[i] = 0;
            for(int i = 0;i < k;i++) tmp[b[i] = x % k]++, x /= k;
            if(tmp[b[0]] == 1 && !(t & 1)) continue;
            int c = -1, flag = true;
            for(int i = 0;i < k;i++) vis[i] = 0;
            for(int i = 0;i < k;i++) if(((t >> i) & 1)) {
                c = b[i];
                if(vis[b[i]]) flag = false;
                vis[b[i]] = true;
            }
            if(!flag) continue;
            if(c == -1) {
                for(int i = 0;i < k;i++) if(!tmp[i]) c = i;
            } else for(int i = 0;i < k;i++) if(vis[b[i]]) b[i] = c;
            int _t = c;
            for(int i = k - 1;i >= 1;i--) _t = _t * k + b[i];
            _t = Reduce(_t);
            mat[val[_t]][id] = (mat[val[_t]][id] + 1) % p;
        }
    }
    ll b = n - k;
    for(int i = 1;i <= m;i++) res[i][i] = 1;
    while(b) {
        if(b & 1) Mul(res,mat);
        Mul(mat,mat);
        b >>= 1;
    }
    for(int i = 1;i <= m;i++)
        for(int j = 1;j <= m;j++) g[i] = (g[i] + 1ll * res[i][j] * f[j]) % p;
    std::printf("%d\n",g[1]);
    return 0;
}

```



---

## 作者：cancan123456 (赞：3)

首先，我们把题目中说的矩阵构造出来：

由于你要是直接写的话会很困难，那么我们观察 $n=10,k=3$ 的情况。

这里我们把 0 省略。

$A=\left[\begin{matrix}3&-1&-1&-1\\-1&4&-1&-1&-1\\-1&-1&5&-1&-1&-1\\-1&-1&-1&6&-1&-1&-1\\&-1&-1&-1&6&-1&-1&-1\\&&-1&-1&-1&6&-1&-1&-1\\&&&-1&-1&-1&6&-1&-1&-1\\&&&&-1&-1&-1&5&-1&-1\\&&&&&-1&-1&-1&4&-1\\&&&&&&-1&-1&-1&3\end{matrix}\right]$


我们先把最后一行和最后一列忽略掉

$B=\left[\begin{matrix}3&-1&-1&-1\\-1&4&-1&-1&-1\\-1&-1&5&-1&-1&-1\\-1&-1&-1&6&-1&-1&-1\\&-1&-1&-1&6&-1&-1&-1\\&&-1&-1&-1&6&-1&-1&-1\\&&&-1&-1&-1&6&-1&-1\\&&&&-1&-1&-1&5&-1\\&&&&&-1&-1&-1&4\end{matrix}\right]$

然后要求行列式。

众所周知，求行列式的时候我们要把矩阵消元成三角矩阵，那么对这个矩阵直接消元肯定过不了，考虑优化高斯消元的过程。

我们最上面的 $k$ 行交换下来，可以通过每次 $n-2$ 次交换把第一行换下来然后重复 $k$ 次：

$\left[\begin{matrix}-1&-1&-1&6&-1&-1&-1\\&-1&-1&-1&6&-1&-1&-1\\&&-1&-1&-1&6&-1&-1&-1\\&&&-1&-1&-1&6&-1&-1\\&&&&-1&-1&-1&5&-1\\&&&&&-1&-1&-1&4\\3&-1&-1&-1\\-1&4&-1&-1&-1\\-1&-1&5&-1&-1&-1\end{matrix}\right]$

我们把矩阵分成三部分：

$\left[\begin{matrix}{\color{blue}-1}&{\color{blue}-1}&-{\color{blue}1}&{\color{blue}6}&{\color{blue}-1}&{\color{blue}-1}&{\color{blue}-1}\\&{\color{blue}-1}&{\color{blue}-1}&{\color{blue}-1}&{\color{blue}6}&{\color{blue}-1}&{\color{blue}-1}&{\color{blue}-1}\\&&{\color{blue}-1}&{\color{blue}-1}&{\color{blue}-1}&{\color{blue}6}&{\color{blue}-1}&{\color{blue}-1}&{\color{blue}-1}\\&&&{\color{red}-1}&{\color{red}-1}&{\color{red}-1}&{\color{red}6}&{\color{red}-1}&{\color{red}-1}\\&&&&{\color{red}-1}&{\color{red}-1}&{\color{red}-1}&{\color{red}5}&{\color{red}-1}\\&&&&&{\color{red}-1}&{\color{red}-1}&{\color{red}-1}&{\color{red}4}\\3&-1&-1&-1\\-1&4&-1&-1&-1\\-1&-1&5&-1&-1&-1\end{matrix}\right]$

蓝色的部分（$n-2k-1$ 行）都是先 $k$ 个 $-1$，$1$ 个 $2k$ 和 $k$ 个 $-1$。

红色的部分（$k$ 行）中的第 $i$ 行是先 $k$ 个 $-1$，然后一个 $2k-i+1$，最后 $k-i$ 个 $-1$。

黑色的部分（$k$ 行）中的第 $i$ 行是先 $i-1$ 个 $-1$，一个 $k+i-1$，最后 $k$ 个 $-1$。

然后我们发现，消元的过程就是先用蓝色的部分消元，再用红色的部分消元。

我们发现蓝色的部分形式都一样而且数量非常多，所以我们考虑一起执行然后再暴力消元后面的部分（一共就 $2k$ 行）。

我们把黑色部分的某一行写成下面的格式：

$$\left[\begin{matrix}a_0&a_1&\cdots&a_{2k-1}&0\end{matrix}\right]$$

那么蓝色部分的所有行都是这样：

$$\left[\begin{matrix}-1&-1&\cdots&2k&\cdots&-1&-1\end{matrix}\right]$$

我们发现，要消掉 $a_0$，我们只需要把蓝色部分的那一行乘以 $a_0$ 然后加到黑色部分，我们对齐写一下：

$$\begin{matrix}[&a_0&a_1&\cdots&a_k&\cdots&a_{2k-1}&0&]\\ [&-a_0&-a_0&\cdots&2ka_0&\cdots&-a_0&-a_0&]\\ [&0&a_1-a_0&\cdots&a_k+2ka_0&\cdots&a_{2k-1}-a_0&-a_0&]\end{matrix}$$

然后我们把消元一次后的结果记为

$$\left[\begin{matrix}0&b_0&b_1&\cdots&b_{2k-1}\end{matrix}\right]$$

那么我们就可以推出转移公式了：

$b_i=\begin{cases}a_{i+1}-a_0&i\not=k-1\\a_k+2ka_0&i=k-1\end{cases}$

这里我们认为 $a_{2k}=0$。

我们把它写成矩阵的形式，就是构造一个矩阵 $M$ 使得

$$\left[\begin{matrix}b_0&b_1&\cdots&b_{2k-1}\end{matrix}\right]=\left[\begin{matrix}a_0&a_1&\cdots&a_{2k-1}\end{matrix}\right]M$$

根据上面的转移，我们可以很容易得写出 $M$：

$$M=\left[\begin{matrix}-1&-1&\cdots&2k&\cdots&-1&-1\\1\\&1\\&&\ddots\\&&&1\\&&&&\ddots\\&&&&&1\end{matrix}\right]$$

比如我们把 $k=3$ 的矩阵写出来：

$$M=\left[\begin{matrix}-1&-1&6&-1&-1&-1\\1\\&1\\&&1\\&&&1\\&&&&1\end{matrix}\right]$$

然后要消元 $n-2k-1$ 次，我们就计算出 $M^{n-2k-1}$ 然后与 黑色部分的每一行分别乘一下即可。

最后，暴力计算红色的部分即可。

最后要注意把蓝色部分的 $n-2k-1$ 个 $-1$ 处理一下（就是行列式乘 $(-1)^{n-2k-1}$），还有我们最开始进行了 $k(n-2)$ 次行交换。

```cpp
#include <cstdio>
using namespace std;
typedef long long ll;
const ll p = 65521;
// 题目中输入的 n, k 
// 因为某些原因, 就开到了全局 
ll n;
int k;
struct Matrix { // 一个矩阵 
	int n, m;
	ll mat[10][10];
	Matrix() { // 自动清零 
		for (int i = 0; i < 10; i++) {
			for (int j = 0; j < 10; j++) {
				mat[i][j] = 0;
			}
		}
	}
	ll * operator[](const int & a) { // 这里是为了方便 a[i][j] 的访问方式 
		return mat[a];
	}
};
Matrix operator * (const Matrix & a, const Matrix & b) { // 矩阵乘法 
	Matrix c;
	c.n = a.n;
	c.m = b.m;
	for (int i = 0; i < c.n; i++) {
		for (int j = 0; j < c.m; j++) {
			for (int k = 0; k < a.m; k++) {
				c.mat[i][j] += a.mat[i][k] * b.mat[k][j];
			}
			c.mat[i][j] %= p;
		}
	}
	return c;
}
Matrix pow(Matrix a, ll b) { // 矩阵快速幂 
	Matrix ans;
	ans.n = ans.m = a.n;
	for (int i = 0; i < a.n; i++) {
		ans.mat[i][i] = 1;
	}
	while (b != 0) {
		if ((b & 1) == 1) {
			ans = ans * a;
		}
		a = a * a;
		b /= 2;
	}
	return ans;
}
namespace DetSolver {
Matrix a;
void swap(ll & a, ll & b) {
	a ^= b ^= a ^= b;
}
// 对 a 这个矩阵求行列式 
// 下面是我从行列式板子复制粘贴过来的 
ll det(int n) {
	ll ans = 1;
	for (int i = 0; i < n; i++) {
		for (int j = i + 1; j < n; j++) {
			while (a[i][i] != 0) {
				ll div = a[j][i] / a[i][i];
				for (int k = i; k < n; k++) {
					a[j][k] = (a[j][k] - div * a[i][k] % p + p) % p;
				}
				for (int k = 0; k < n; k++) {
					swap(a[i][k], a[j][k]);
				}
				ans = p - ans;
			}
			for (int k = 0; k < n; k++) {
				swap(a[i][k], a[j][k]);
			}
			ans = p - ans;
		}
	}
	for (int i = 0; i < n; i++) {
		ans = ans * a[i][i] % p;
	}
	return ans;
} // DetSolver
}
namespace solve1 { // 第一种情况, n <= 2 * k 
int abs(int x) {
	return x < 0 ? -x : x;
}
void main() {
	// 构造矩阵, 这里直接暴力构造 
	for (int i = 0; i < n; i++) {
		for (int j = 0; j < n; j++) {
			if (i != j && abs(i - j) <= k) {
				DetSolver::a[i][j] = p - 1;
				DetSolver::a[i][i]++;
			}
		}
	}
	// 行列式就是答案 
	// 注意这里传进去的是 n - 1, 就是自动忽略了最后一行和最后一列 
	printf("%lld", DetSolver::det(n - 1));
}
} // solve1
namespace solve2 { // 第二种情况 
void main() {
	// 这里的 fix 是最后要乘在行列式上的值 
	ll fix = 1;
	// 前面的两个处理 
	if (k * (n - 2) % 2 == 1) {
		fix = p - fix;
	}
	if ((n - 2 * k - 1) % 2 == 1) {
		fix = p - fix;
	}
	// 构造矩阵 M 
	Matrix M;
	M.n = M.m = 2 * k;
	for (int i = 0; i < M.n; i++) {
		M[0][i] = p - 1;
	}
	M[0][k - 1] = 2 * k;
	for (int i = 1; i < M.n; i++) {
		M[i][i - 1] = 1;
	}
	M = pow(M, n - 2 * k - 1);
	// 构造黑色部分 
	Matrix black[k];
	for (int i = 0; i < k; i++) {
		Matrix & row = black[i];
		row.n = 1;
		row.m = 2 * k;
		for (int j = 0; j < i; j++) {
			row[0][j] = p - 1;
		}
		row[0][i] = k + i;
		for (int j = i + 1; j <= i + k; j++) {
			row[0][j] = p - 1;
		}
	}
	for (int i = 0; i < k; i++) {
		black[i] = black[i] * M;
	}
	// 构造红色部分, 并且把黑色部分和它拼在一起 
	// 由于最后是要求行列式的, 所以是一个引用 
	Matrix & red = DetSolver::a;
	red.n = red.m = 2 * k;
	for (int i = 0; i < k; i++) { // 构造上半部分 (红色部分) 
		for (int j = 0; j < i; j++) {
			red[i][j] = 0;
		}
		for (int j = 0; j < k; j++) {
			red[i][j + i] = p - 1;
		}
		red[i][k + i] = 2 * k - i;
		for (int j = k + i + 1; j < 2 * k; j++) {
			red[i][j] = p - 1;
		}
	}
	// 把黑色部分拼在一起 
	for (int i = 0; i < k; i++) {
		for (int j = 0; j < 2 * k; j++) {
			red[i + k][j] = black[i][0][j];
		}
	}
	// 求行列式并且输出 
	ll ans = DetSolver::det(2 * k) * fix % p;
	printf("%lld", ans);
}
} // solve2
int main() {
	scanf("%d %lld", &k, &n);
	// 调用对应的函数 
	if (n <= 2 * k) {
		solve1::main();
	} else {
		solve2::main();
	}
	return 0;
}
```

---

## 作者：Jiang_zi_chuan (赞：2)

# 双倍经验吼啊！！

## [原题](http://www.lydsy.com/JudgeOnline/problem.php?id=1494)

# [此题题解CSDN博客链接](https://blog.csdn.net/jzc20080511/article/details/86317689)

#### 思路：

```从这道题的数据范围，不难看出要使用状态压缩。

首先，我们来确定前k个点的状态。

原本想用一个k位二进制数记录每个点跟它前面的k个点的连接情况，

但是这样处理不了一个问题，就是如何排除环的存在。

所以借鉴了一些解题报告，发现可以在由1~n依次处理节点时，

用一个k位k进制数来记录最近k个点所在的联通块的情况，

这样的状态其实并不多，n=5的时候有52个。

为了避免状态的冗余，就要保证一个状态只有一种表示形式，

为此我学习了非常巧妙的“最小表示法”(SOJ 3296)。

但其实本题与最小表示法并无关系，

最小表示法求的是一个串的字典序最小的循环表示。

而本题中显然不能对状态进行循环表示，

而只能在已知哪几个节点处于同一个联通块的情况下，改变联通块的标号，使得得到的状态最小。

当我们枚举出了初始的状态后，例如节点1,2,3属于联通块0，节点4,5属于联通块1。

那么，同一个联通块中，生成树的形态仍然有很多。

在后面的状态转移的过程中，我们可以通过枚举边来自然的进行转移。

但是初始状态却没办法这样，对于一个初始状态，我们无法得知有多少种连边方式可以得到它。

本题给出了一个利用矩阵计算生成树个数(HDOJ 4305)的方法，具体可以参考周冬的《生成树的计数及其应用》：

对于有n个点的图，构造一个矩阵，使得：

若i==j，a[i][j]=dex[i]。（dex[i]为节点i的度数）。

否则，若点i和点j间有边相连，a[i][j]=-1。

若无边相连，a[i][j]=0。

然后求这个矩阵的行列式，得到的即是这个图的生成树个数。

当然，如果计算的行列式的值非常大，自然就要对某个数取模（本题中K<=5，没有这个必要）。

对于行列式模任意值的解法，bjin的论文《欧几里得算法的应用》中有介绍。

另外，个人觉得bjin的两道题： SPOJ DETER3（行列式模） 和 SPOJ MSTS（最小生成树计数，HDOJ 4408与此题类似），

非常适合作为本题的后续练习。

显然，对于这道题。

假设相邻K个点中，有x个点同属于1号联通块

那么这x个点中两两间都必然是可以连边的。

我们要求的是x个点的完全图的生成树种数，

得到的即是联通块1在当前的K个点这个部分，所能得到的生成树种数。

当然，其实不必真的去计算行列式，题目的开头已经告诉我们了，n个节点的完全图的生成树个数是n^(n-2)。

这个结论可以用cayley定理来证明。

处理了初始状态之后，再来看一下状态的转移。

从序号由小到大处理各节点。

每处理一个节点x时，用一个k位二进制数枚举这个点跟它前面的k个点的连接情况，

然后就可以由[x-k-1,x-1]的原状态转化到[x-k,x]的新状态。

当然，这过程中可能出现环，这个可以用并查集来判断，如果出现环，这个转移就是无效的。

显然，按节点顺序从小到大处理，每次在标记一个新的联通块的时候，使用当前未使用的最小标号即可。

我们不难看出，状态转移时的倍数关系，只与原状态和新状态有关，跟点的序号无关。

因此我们可以构造一个初始向量和一个转移矩阵。

我构造的初始向量g[]是一个行向量。每个位置代表一种初始状态。

每个位置的值，就是前k个点有多少种连接方式能够达成这种状态。

然后对于状态转移矩阵f[][]，第i行第j列表示由状态i转移到状态j有多少种合法的连接方式（不成环且第x-k个点至少与x-k+1~x中的一个点同一个联通块）。

求出g*pow(f,n-k)之后，对于得到的行向量中每个位置的数值，就代表了有多少种达到这个状态的方法。

然而，这些状态并不都是有用的。

只有所有点处于同一个联通快的那个状态是有用的，也就是状态0。

所以输出g[0][0]即可。

PS：

做这道题的过程中主要参考了俞华程的论文《矩阵乘法在信息学中的应用》和陈丹琦的论文《基于连通性状态压缩的动态规划问题》（恰好以上两位也是OI界有名的赛场伉俪，有木有有木有！），以及ACMonster和whjpji的解题报告。

非常感谢！

还要谢谢适牛借给我他超级长长长长长长长长长长的矩阵类模板哟~~~~~~~~
```

代码：

```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstring>
#define ll long long
using namespace std;
const int Mx=200;
const int p=65521;
using namespace std;
ll n;
int K,tot/*状态总数*/,Tr_siz[]={1,1,1,3,16,125}/*完全图的生成树个数*/;
int fa[Mx],siz[Mx]/*第i个联通块的大小*/,status[600],hash[1<<16]/*hash[S]=状态S的编号*/;

struct Matrix
{
    int n,m; ll num[Mx][Mx];
    Matrix() { n=m=0; memset(num,0,sizeof(num)); }
}A,trans;
Matrix operator*(Matrix a,Matrix b)
{
    Matrix c;
    c.n=a.n,c.m=b.m;
    for(int k=1;k<=a.m;k++)
        for(int i=1;i<=c.n;i++)
            for(int j=1;j<=c.m;j++)
                c.num[i][j]=(c.num[i][j]+a.num[i][k]*b.num[k][j]%p)%p;
    return c;
}
void Pow(ll c)
{
    while(c)
    {
        if(c&1) A=A*trans;
        trans=trans*trans;
        c>>=1;
    }
}

void dfs(int x,int sta) //当前要加入第x个点的联通状态，当前的状态为sta
{
    if(x==K+1)
    {
        memset(siz,0,sizeof(siz));
        A.num[1][++tot]=1;
        for(int i=1;i<=K;i++)
            siz[sta>>((i-1)*3)&7]++;
        for(int i=0;i<K;i++)
            A.num[1][tot]*=Tr_siz[siz[i]];
        status[tot]=sta;
        hash[sta]=tot;
        return;
    }
    int tmp=-1; //联通块的最大编号,联通块编号的区间是[0,K-1]
    for(int i=1;i<x;i++) //!!!当前的sta里只保存了1~pos-1这些点的连通性
        tmp=max(tmp,sta>>((i-1)*3)&7);
    for(int i=0;i<=tmp+1&&i<K;i++)
        dfs(x+1,sta<<3|i);
}

int find(int x) 
{
    if(fa[x]==x) return x;
    return fa[x]=find(fa[x]);
}

int Get_Status() //用当前的并查集来求出新的点2到点k+1的最小表示
{
    int sta=0,tot=0;
    bool vis[Mx]; memset(vis,false,sizeof(vis));
    for(int i=K+1;i>=2;i--)
        if(!vis[i])
        {
            vis[i]=true,sta|=tot<<((i-2)*3);
            for(int j=i-1;j>=2;j--)
                if(find(i)==find(j))
                    vis[j]=true,sta|=tot<<((j-2)*3);
            tot++;
        }
    return hash[sta];
}

void cal(int sta,int addsta) //用加边状态addsta去更新最小表示法sta,addsta里的第i位为1表示第k+1个点要和点i+1连新边
{
    for(int i=0;i<=K+1;i++) fa[i]=i;
    for(int i=1;i<=K;i++) //枚举点对(i,j)是否在最小表示法里的同一联通块内，将最小表示法中的连通性用并查集表示
        for(int j=i+1;j<=K;j++)
            if((status[sta]>>((i-1)*3)&7)==(status[sta]>>((j-1)*3)&7))
            {
                int rooti=find(i),rootj=find(j);
                if(rooti!=rootj) fa[rooti]=rootj;
            }
    for(int i=1;i<=K;i++)
        if(addsta&(1<<(i-1)))
        {
            int rooti=find(i),rootj=find(K+1);
            if(rooti==rootj) return; //判环，加的新边的两端点原来就是联通的，加入新边后会出现环
            fa[rooti]=rootj;
        }
    bool flag=false; //flag=true表示有点和点1联通
    for(int i=2;i<=K+1;i++)
        if(find(i)==find(1))
        {
            flag=true; break;
        }
    if(!flag) return; //点1不链接后面的点，那么这个生成树不联通
    trans.num[sta][Get_Status()]++;
}

int main()
{
    scanf("%d%lld",&K,&n);
    dfs(1,0); A.n=1; A.m=trans.n=trans.m=tot;
    for(int i=1;i<=tot;i++)
        for(int j=0;j<(1<<K);j++) cal(i,j);
    Pow(n-K); printf("%lld\n",A.num[1][1]);
    return 0;
}
```

---

## 作者：yizhiming (赞：1)

我为什么写的这么丑。

[Link](https://www.luogu.com.cn/problem/P2109)

## 题目大意

给你一个大小为 $n$ 的无向连通图，给定一个数 $k$，表示下标之差不超过 $k$ 的点对之间有连边，求生成树个数。

$1\leq n \leq 10^{15},2\leq k \leq \min(5,n)$。

## 题目分析

发现 $k$ 很小，所以先从 $k$ 入手，不难发现对于一个点，只有前 $k$ 个点会对这个点有影响，所以考虑状压出前 $k$ 个点的连通状态，具体的，令 $b_i$ 表示所属集合，若 $b_i$ 相同则说明连通，但是状态数有点多了。

有许多状态是冗余的，我们可以用最小表示法去减少状态数，这部分可以暴搜预处理出来，当 $k=5$ 时，状态数仅有 $52$ 种，考虑转移。

设 $g_{i,j}$ 表示由 $i$ 状态在后面添加一个点，转移成 $j$ 状态的方案数，不难发现最后一个点对于前面的每个点都可能有连边，所以枚举 $2^k$ 个连边方案，利用并查集来维护最后的所属集合，以及是否连出环即可，注意一个细节，若 $i$ 状态中第一个点自己单独属于一个集合，那么这次加入的新点一定要向这个点连边，否则的话会导致不连通而不是生成树，其他题解貌似没说，我在这里卡了很久。

所以特殊判断一下满足上面那个条件的集合，所能够转移的状态方案数全部减半即可。

那此时我们就可以利用 $g_{i,j}$，暴力枚举当前选择了前 $x$ 个点时的方案，设 $f_{x,y}$ 表示考虑了前 $x$ 个点，状态为 $y$ 的情况，容易推出如下转移式子。

$f_{x,y}=\sum\limits_{S}(f_{x-1,S}\times g_{S,y})$，然后把所有的状态视作下标，则上述转移的形式就是一个矩阵乘法的形式。

注意到了形式是矩阵乘法，那么 $n$ 很大的问题也解决了，因为转移时一样的，所以做一遍矩阵快速幂即可，注意初始 $x\leq k$ 的情况不一样，需要预处理出来初始状态，可以直接枚举 $\frac{k(k-1)}{2}$ 条边的连边方案，预处理出来所有的情况即可，最后乘上转移矩阵的 $n-k$ 次方即可。

注意最后要求的合法方案只有当所有数属于同一个集合的情况。

## Code

```cpp
#include <iostream>
#include <algorithm>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <queue>
#define int long long
using namespace std;
int read(){
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
const int N = 65;
int Mod = 65521;
int bel[N],n,k;
int zt[N][10],top;
int vis[10];
void dfs(int cs,int up){
	if(cs==k+1){
		top++;
		for(int i=1;i<=k;i++){
			zt[top][i] = bel[i];
		}
		return;
	}
	for(int i=1;i<=k;i++){
		if(i>up+1){
			continue;
		}
		bel[cs] = i;
		dfs(cs+1,max(up,i));
	}
}
int fa[N],b[N],lsh[N];
int find(int x){
	if(fa[x]!=x){
		fa[x] = find(fa[x]);
	}
	return fa[x];
}
bool check(int x,int y,int S){
	for(int i=0;i<=k;i++){
		fa[i] = i;
	}
	for(int i=1;i<=k;i++){
		for(int j=i+1;j<=k;j++){
			if(zt[x][i]==zt[x][j]){
				int u = find(i-1),v = find(j-1);
				if(u!=v){
					fa[v] = u;
				}
			}
		}
	}
	for(int i=0;i<k;i++){
		if((S>>i)&1){
			int u = find(i),v = find(k);
			if(u!=v){
				fa[v] = u;
			}else{
				return false;
			}
		}
	}
	memset(vis,0,sizeof(vis));
	int ct = 0;
	for(int i=1;i<=k;i++){
		b[i] = find(i);
		if(!vis[b[i]]){
			vis[b[i]] = ++ct;
		}
		b[i] = vis[b[i]];
	}
	for(int i=1;i<=k;i++){
		if(zt[y][i]!=b[i]){
			return false;
		}
	}
	return true;
}
struct Mat{
	int val[N][N];
	void clear(){
		for(int i=1;i<=top;i++){
			for(int j=1;j<=top;j++){
				val[i][j] = 0;
			} 
		}
	}
	Mat operator*(const Mat&x)const{
		Mat res;
		res.clear();
		for(int i=1;i<=top;i++){
			for(int j=1;j<=top;j++){
				for(int k=1;k<=top;k++){
					res.val[i][j] = (res.val[i][j]+val[i][k]*x.val[k][j]%Mod)%Mod;
				}
			}
		}
		return res;
	}
}I,g,f;
Mat ksm(Mat x,int y){
	Mat res = I;
	while(y){
		if(y&1){
			res = res*x;
		}
		y>>=1;
		x = x*x;
	}
	return res;
}
void add(int x){
	int tt=0;
	for(int i=1;i<=k;i++){
		fa[i] = i;
	}
	for(int i=1;i<=k;i++){
		for(int j=i+1;j<=k;j++){
			if((x>>tt)&1){
				int u = find(i),v = find(j);
				if(u!=v){
					fa[v] = u;
				}else{
					return;
				}
			}
			tt++;
		}
	}
	memset(vis,0,sizeof(vis));
	int ct = 0;
	for(int i=1;i<=k;i++){
		b[i] = find(i);
		if(!vis[b[i]]){
			vis[b[i]] = ++ct;
		}
		b[i] = vis[b[i]];
	}
	for(int i=1;i<=top;i++){
		for(int j=1;j<=k+1;j++){
			if(j==k+1){
				f.val[1][i]++;
				return ;
			}
			if(b[j]!=zt[i][j]){
				break;
			}
		}
	}
}
signed main(){
	k = read();n = read();
	dfs(1,0);
	for(int i=1;i<=top;i++){//由i变j的方案数 
		int cnt = 0;
		for(int j=1;j<=k;j++){
			cnt+=(zt[i][j]==1);
		}
		for(int j=1;j<=top;j++){
			for(int S=0;S<(1<<k);S++){
				g.val[i][j]=(g.val[i][j]+check(i,j,S))%Mod;
			}
			if(cnt==1){
				g.val[i][j]/=2;
			}
		}
	}
	I.clear();f.clear();
	for(int i=1;i<=top;i++){
		I.val[i][i] = 1;
	}
	int up = k*(k-1)/2;
	for(int i=0;i<(1<<up);i++){
		add(i);
	} 
	g = ksm(g,n-k);
	int ans = 0;
	for(int i=1;i<=top;i++){
		ans = (ans+f.val[1][i]*g.val[i][1]%Mod)%Mod;
	}
	cout<<ans<<"\n";
	return 0;
}

```


---

## 作者：龚祖豪曾用号 (赞：0)

### Description

最近，小栋在无向连通图的生成树个数计算方面有了惊人的进展，他发现：

>$n$个结点的环的生成树个数为$n$。

>$n$个结点的完全图的生成树个数为$n^{n-2}$。


这两个发现让小栋欣喜若狂，由此更加坚定了他继续计算生成树个数的想法，他要计算出各种各样图的生成树数目。一天，小栋和同学聚会，大家围坐在一张大圆桌周围。小栋看了看，马上想到了生成树问题。如果把每个同学看成一个结点，邻座（结点间距离为1）的同学间连一条边，就变成了一个环。可是，小栋对环的计数已经十分娴熟且不再感兴趣。

于是，小栋又把图变了一下：不仅把邻座的同学之间连
一条边，还把相隔一个座位（结点间距离为2）的同学之间也连一条边，将结点间有边直接相连的这两种情况统称
为有边相连，如图1所示。

![](https://cdn.luogu.com.cn/upload/pic/12787.png)

小栋以前没有计算过这类图的生成树个数，但是，他想起了老师讲过的计算任意图的生成树个数的一种通用方法：
构造一个$n×n$的矩阵$A$={$a_{ij}$},其中

![](https://cdn.luogu.com.cn/upload/pic/12788.png)


其中$di$表示结点i的度数。与图1相应的$A$矩阵如下所示。为了计算图1所对应的生成数的个数，只要去掉矩阵A的最
后一行和最后一列，得到一个$(n-1)×(n-1)$的矩阵$B$，计算出矩阵$B$的行列式的值便可得到图1的生成树的个数

![](https://cdn.luogu.com.cn/upload/pic/12789.png)

所以
生成树的个数为$|B|=3528$。小栋发现利用通用方法，因计算过于复杂而很难算出来，而且用其他方法也难以找到更
简便的公式进行计算。于是，他将图做了简化，从一个地方将圆桌断开，这样所有的同学形成了一条链，连接距离
为1和距离为2的点。例如八个点的情形如下：


![](https://cdn.luogu.com.cn/upload/pic/12790.png)

这样生成树的总数就减少了很多。小栋不停的思考，一直到聚会结束，终于找到了一种快捷的方法计算出这个图的
生成树个数。可是，如果把距离为3的点也连起来，小栋就不知道如何快捷计算了。现在，请你帮助小栋计算这类
图的生成树的数目。



### HINT


因为$k$很小，所以考虑**状态压缩**

每一个状态表示$i$的前$k$个点各自属于哪个**连通块**

用一个$k$位的$k$进制数表示状态

然而状态很多，用**最小表示法**

即$122$与$233$是**等价**的

这样状态不超过52

然后就可以$dp$

$f[i]$ $[S]$ $=$ $∑_{Slast}$ $f$ $[i−1]$  $[Slast]$

显然可以用**矩阵快速幂**

实现枚举$S$，找到通过变换能形成的所有状态

具体通过一个二进制数，表示第$k+1$个点向哪些点连边

用**并查集**判断，并将新的状态改为最小表示

## $Code$
```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
using namespace std;
typedef long long lol;
lol cnt,n,Mod=65521,k,id[100001],vis[201],set[201];
lol h[201],v[201];
struct Matrix
{
  lol a[201][201];
  Matrix operator * (const Matrix &x) const
  {
    Matrix res;
    memset(res.a,0,sizeof(res.a));
    for(int i=1;i<=cnt;++i)
      for(int j=1;j<=cnt;++j)
        for(int k=1;k<=cnt;++k)
        res.a[i][j]=(res.a[i][j]+(a[i][k]*x.a[k][j])%Mod)%Mod;
    return res;
  }
}ans,Mat;
int find(int x)
{
  if (set[x]!=x) set[x]=find(set[x]);
  return set[x];
}
lol pow(lol x,lol y)
{
  lol res=1;
  while (y)
    {
      if (y&1) res=res*x%Mod;
      x=x*x%Mod;
      y>>=1;
    }
  return res;
}
Matrix qpow(lol y)
{int i;
  Matrix res;
  memset(res.a,0,sizeof(res.a));
  for (i=1;i<=cnt;i++)
    res.a[i][i]=1;
  while (y)
    {
      if (y&1) res=res*Mat;
      Mat=Mat*Mat;
      y>>=1;
    }
  return res;
}
void dfs(int x,int ed,int S)
{int i;
  if (x==k+1)
    {
      id[S]=++cnt;
      h[cnt]=S;
      return;
    }
  for (i=1;i<=ed;i++)
    dfs(x+1,ed+(i==ed),(i<<(3*(x-1)))+S);
}
int get_id()
{
  memset(vis,-1,sizeof(vis));
  int cc=0,i;
  for (i=2;i<=k+1;i++)
    if (vis[find(i)]==-1) vis[find(i)]=++cc;
  int x=0;
  for (i=2;i<=k+1;i++)
    {
      x+=(vis[find(i)]<<(3*(i-2)));
    }
  return id[x];
}
void build_Mat(int now,int add)
{int i,j,flag;
  for (i=0;i<=k+1;i++)
    set[i]=i;
  for (i=1;i<=k;i++)
    {
      for (j=i+1;j<=k;j++)
    if ((now>>((i-1)*3)&7)==(now>>((j-1)*3)&7))
    {
      int p=find(i),q=find(j);
      if (p!=q) set[p]=q;
    }
    }
  for (i=1;i<=k;i++)
    if (add&(1<<i-1))
      {
    int p=find(i),q=find(k+1);
    if (p==q) return;
    set[p]=q;
      }
  flag=0;
  for (i=2;i<=k+1;i++)
    {
      if (find(1)==find(i)) {flag=1;break;}
    }
  if (!flag) return;
  Mat.a[id[now]][get_id()]++;
}
int main()
{int i,j;
  cin>>k>>n;
  dfs(1,1,0);
  for (i=1;i<=cnt;i++)
    {
      for (j=0;j<(1<<k);j++)
    {
      build_Mat(h[i],j);
    }
    }
  for (i=1;i<=cnt;i++)
    {
      memset(v,0,sizeof(v));
      int x=h[i];
      int as=1;
      for (j=1;j<=k;j++)
    {
      v[x>>(3*(j-1))&7]++;
    }
      for (j=1;j<=k;j++)
    if (v[j]>=2)
    {
      as*=pow(v[j],v[j]-2);
    }
      ans.a[1][i]=as;
    }
  ans=ans*qpow(n-k);
  cout<<ans.a[1][1]<<endl;
}
```

---


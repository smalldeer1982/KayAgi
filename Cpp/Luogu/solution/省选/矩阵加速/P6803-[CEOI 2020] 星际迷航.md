# [CEOI 2020] 星际迷航

## 题目背景

原时空限制：0.2s，32m

## 题目描述

星际联邦由 $N$ 颗行星组成，分别编号为 $1 \sim N$。一些行星间由星际通道相连。通过这些星际通道，飞船可以在短时间内往返于各星球之间。整个星际联邦中恰好有 $N-1$ 条星际通道，并且通过这些星际通道，任意两颗行星之间均能相互抵达。

除了我们所处的宇宙之外，还有 $D$ 个平行宇宙，这些平行宇宙是我们的宇宙的完全复刻，它们的行星，星际通道都和我们的完全相同。我们将这些平行宇宙编号为 $1 \sim D$（我们的宇宙编号为 $0$），记第 $i$ 个宇宙的第 $x$ 颗行星为 $P_{x}^i$。通过星门，我们可以在这些平行宇宙间穿梭。$\forall i \in [0,D)$，我们将选择一个 $A_i$ 和一个 $B_i$（要求 $1 \leq A_i,B_i \leq N$），在 $P_{A_i}^i$ 和 $P_{B_i}^{i+1}$ 之间搭建一个**单向**（只能从 $P_{A_i}^i$ 前往 $P_{B_i}^{i+1}$）星门。

当所有的星门都准备就绪后，联邦星舰 Batthyány 号将会开始它的处女航，它目前正环绕着 $P_1^0$ 行星。Ágnes 舰长准备和 Gábor 中尉玩这样一个游戏：两个人交替选择星舰接下来前往的目的地，要求该目的地可以通过星际通道或星门直接抵达。他们希望每次前往的星球都是之前未抵达过的。即，如果星舰抵达了 $P_{x}^i$，他们将不再经过这个星球（但是可以抵达 $x$ 在其他平行宇宙中的相应星球）。由 Ágnes 舰长作为先手开始游戏，Gábor 中尉作为后手，当一位玩家在他的回合中，不能选择一个合法的目的地时，他就输掉了游戏。

舰长和中尉都是绝对聪明的，他们知道所有星际通道和星门的排布方案，并且他们每次都按照最优方案行动。你需要求出，有多少种布置星门的方案，使得作为先手的 Ágnes 舰长必胜？两种布置星门的方案是不同的，当且仅当存在一个整数 $i$，使得 $A_i$ 或 $B_i$ 不同。

## 说明/提示

### 样例解释

共有 $3 \times 3=9$ 种本质不同的布置星门的方案，下面列出四种舰长必胜的情况。

![](https://cdn.luogu.com.cn/upload/image_hosting/vblsc4g6.png)

### 子任务

所有数据均满足：$1 \leq N \leq 10^5$，$1 \leq D \leq 10^{18}$，$1 \leq u,v \leq N$。

各子任务的约束条件如下：

| 子任务编号 | 分值 | 约束                         |
| ---------- | ---- | ---------------------------- |
| $1$        | $0$  | 样例                         |
| $2$        | $7$  | $N=2$                        |
| $3$        | $8$  | $N \leq 100$，$D=1$          |
| $4$        | $15$ | $N \leq 1000$，$D=1$         |
| $5$        | $15$ | $D=1$                        |
| $6$        | $20$ | $N \leq 1000$，$D \leq 10^5$ |
| $7$        | $20$ | $D \leq 10^5$                |
| $8$        | $15$ | 无特殊约束                   |

## 样例 #1

### 输入

```
3 1
1 2
2 3```

### 输出

```
4```

# 题解

## 作者：滑蒻稽 (赞：29)

## Des

[P6803 [CEOI2020]星际迷航](https://www.luogu.com.cn/problem/P6803)

## Sol

首先设败点为先手必败的点，胜点为先手必胜的点。记胜点 $dp_u=1$，败点 $dp_u=0$。

在不同树之间连边相当于给被连上的树换一个根。

如果一个点接上一个败点，那么自己有可能变成胜点，从而导致根的胜负情况发生逆转（变成胜点或败点都有可能）。如果一个点接上一个胜点那么没有影响。

于是换根 DP 求出有多少个点连接败点后会使根的胜负情况发生逆转，记为 $R_u$。

记整棵树败点数目为 $c$，考虑 $D=1$ 的情况。如果 $1$ 号点是胜点，那么答案为 $(n-R_1)\times c+(n-c)\times n$；如果 $1$ 号点是败点，那么答案为 $R_1\times c$。

然后考虑 $D=2$ 的情况。设以第二棵树败点的答案总和为 $f0$，胜点答案总和为 $f1$。那么对于第 0 颗树的根，如果根是胜点，那么答案为 $(n-R_1)f0+nf1$。如果根是败点，那么答案为 $R_1f0$。

考虑 $f0,f1$ 怎么求。$f0$ 可能由胜点转败点或败点不变组成，$f1$ 同理。于是有

$$
f0=\sum_u[dp_u=0](n-R_u)c+\sum_u[dp_u=1]R_uc+\sum_u[dp_u=0]n(n-c)
$$

$$
f1=\sum_u[dp_u=1](n-R_u)c+\sum_u[dp_u=0]R_uc+\sum_u[dp_u=1]n(n-c)
$$

对于 $D=3$ 的情况，第一棵树的 $f0',f1'$ 可以用第二棵树的 $f0,f1$ 迭代得到，只需把上面公式中的 $c$ 替换为 $f0$，$n-c$ 替换为 $f1$。$D$ 更大的情况可以用矩阵快速幂优化。

我们设转移矩阵为 $T$，算出 $T^{D-1}\times \begin{matrix}[c&n-c]\end{matrix}$ 得到 $\begin{matrix}[f0&f1]\end{matrix}$。再根据一号点是胜点还是败点输出答案为 $(n-R_1)\times f0+n\times f1$ 或 $R_1\times f0$ 即可。

然后讲一下换根 DP。$R_u$ 的值在两种 情况下不为 $0$。一是节点全都是败点，这样 $R_u$ 就等于所有儿子 $R_v$ 之和。二是节点恰有一个为败点，这样 $R_u$ 就等于该点 $R_v$。于是只需要维护儿子败点的数量即可换根 DP。

最后复杂度 $O(n+\log D)$。

这道题比较麻烦地方在于 $R_u$ 的设置。如果分根从胜点变败点和从败点变胜点处理，那你大概就要写两个 换根 DP，比较麻烦。但用 $R_u$ 表示 $u$ 的胜负逆转后就变得简单了。

## My Code

```cpp
#include <bits/stdc++.h>

using namespace std;
typedef long long ll;
const int N = 1e5 + 5, D = 1e9 + 7;
inline void Add(int &a, ll b) { a = (a + b) % D; }
int n, c;
ll K;
struct mat {
	int a[2][2];
	mat(bool e = false) {
		memset(a, 0, sizeof a);
		if(e) a[0][0] = a[1][1] = 1;
	}
	mat operator*(const mat &x) {
		mat y;
		for(int i = 0; i < 2; i++)
			for(int j = 0; j < 2; j++)
				y.a[i][j] = ((ll)a[i][0] * x.a[0][j] + (ll)a[i][1] * x.a[1][j]) % D;
		return y;
	}
};
mat fpm(mat a, ll b) {
	mat res(true);
	while(b) {
		if(b & 1) res = res * a;
		b >>= 1, a = a * a;
	}
	return res;
}
vector<int> g[N];
int dp[N], s0[N], R[N], SR[N][2];
// SR[i][0] 表示 i 号点所有 dp 值为 0 的儿子的 R 的和，SR[i][1] 同理 
void dfs1(int u, int f) {
	for(int v : g[u]) {
		if(v == f) continue;
		dfs1(v, u);
		s0[u] += !dp[v];
		SR[u][dp[v]] += R[v];
	}
	dp[u] = (s0[u] > 0);
	if(s0[u] == 1) R[u] = SR[u][0];
	else if(s0[u] == 0) R[u] = SR[u][1] + 1;
}
int dp2[N], R2[N];
// 换根 DP 
void dfs2(int u, int f) {
	if(!dp[u]) ++c;
	R2[u] = R[u], dp2[u] = dp[u];
	for(int v : g[u]) {
		if(v == f) continue;
		int s0u = s0[u], dpu = dp[u], Ru = R[u], SRu0 = SR[u][0], SRu1 = SR[u][1];
		int s0v = s0[v], dpv = dp[v], Rv = R[v], SRv0 = SR[v][0], SRv1 = SR[v][1];

		s0[u] -= !dp[v];
		dp[u] = (s0[u] > 0);
		SR[u][dp[v]] -= R[v];
		if(s0[u] == 1) R[u] = SR[u][0];
		else if(s0[u] == 0) R[u] = SR[u][1] + 1;
		else R[u] = 0;
		dp[v] |= !dp[u];
		s0[v] += !dp[u];
		SR[v][dp[u]] += R[u];
		if(s0[v] == 1) R[v] = SR[v][0];
		else if(s0[v] == 0) R[v] = SR[v][1] + 1;
		else R[v] = 0;
		dfs2(v, u);

		s0[u] = s0u, dp[u] = dpu, R[u] = Ru, SR[u][0] = SRu0, SR[u][1] = SRu1;
		s0[v] = s0v, dp[v] = dpv, R[v] = Rv, SR[v][0] = SRv0, SR[v][1] = SRv1;
	}
}

int main() {
	ios::sync_with_stdio(false); cin.tie(nullptr);
	cin >> n >> K;
	for(int i = 1, u, v; i < n; i++) {
		cin >> u >> v;
		g[u].emplace_back(v), g[v].emplace_back(u);
	}
	dfs1(1, 0);
	dfs2(1, 0);
	
	mat p, T;
	// 处理转移矩阵 
	for(int i = 1; i <= n; i++) {
		if(dp2[i] == 0) {
			Add(T.a[0][0], n - R2[i]);
			Add(T.a[1][0], n);
			Add(T.a[0][1], R2[i]);
		} else if (dp2[i] == 1) {
			Add(T.a[0][0], R2[i]);
			Add(T.a[0][1], n - R2[i]);
			Add(T.a[1][1], n);
		}
	}
	p.a[0][0] = c, p.a[0][1] = n - c;
	p = p * fpm(T, K - 1);

	int f0 = p.a[0][0], f1 = p.a[0][1];
	if(dp[1]) cout << ((ll)(n - R2[1]) * f0 + (ll)n * f1) % D << '\n';
	else cout << (ll)R2[1] * f0 % D << '\n';

	return 0;
}
```

---

## 作者：s_r_f (赞：5)

[我的CEOI作战记录&题解-洛谷博客](https://www.luogu.com.cn/blog/s-r-f/ceoi2020-zuo-zhan-ji-lu-ti-xie-shi-gong-zhong-post)

[我的CEOI作战记录&题解-cnblogs](https://www.cnblogs.com/s-r-f/p/13581895.html)

首先思考 $D=1$ 怎么做.

不难发现,如果一个时空隧道指向了一个必胜点,那么这个时空隧道相当于不存在;否则相当于**强制把这一层的某个点 $x$ 变为了必胜点.**

换根 DP 求出 $cnt_x$ 表示能使 $x$ 胜负状态改变的**强制把这一层的某个点 $y$ 变为了必胜点的操作种数.**

记**原树**上的必胜点数目为 $cntw$ ,必败点数目为 $cntl$ ,记 $win_x$ 表示**原树上** $x$ 是否必胜,是则为 $1$ ,否则为 $0$ .

那么对于 $D=1$ ,答案就是 $cnt_1 \times cntl + win_1 \times n \times cntw$ . 

记 $fw_i$ 为 把 $i$ 强制变为必胜点之后的必胜点数目,特别的,令 $fw_0=cntw$ .  记 $sumcntw$ 为 $\sum\limits_{i=1}^n fw_i$   

记 $fl_i$ 为 把$i$强制变为必胜点之后的必败点数目$,$特别的$,$令 $fl_0=cntl$ . 记 $sumcntl$ 为 $\sum\limits_{i=1}^n fl_i$  


对于 $D>1$ 的情况$,$首先我们考虑 $dp_{i,x(1\leq x\leq n)}$ 表示第$i$层的时空隧道连接了下一层的必败点$,$并使得$x$强制变为必胜点的方案数.

再记一个 $dp_{i,0}$ 表示示第 $i$ 层的时空隧道连接了下一层的必胜点的方案数.

如果我们能计算出这些东西$,$那么答案就是 $\sum\limits_{i=0}^n dp_{1,i} \times (cnt_1 \times fl_i+win_1\times n \times fw_i)$

那么怎么 DP 呢?

$dp_{i,x(x>0)} = \sum\limits_{y=0}^n dp_{i+1,y} \times fl_y$

$dp_{i,0}=\sum\limits_{y=0}^n dp_{i+1,y} \times fw_y$

不难发现所有的 $dp_{i,1},dp_{i,2},...,dp_{i,n}$ 都相等,所以对于每个 $i$ 我们只需要记两个 DP 值.

并且转移可以写成矩阵形式,而且**无论是转移还是计算答案我们都不需要求出 $fl_i$ 和 $fw_i$ ,只需要求出它们的和** $sumcntw$ , $sumcntl$ . 这两个数可以通过上述的换根 DP 结果求出.

复杂度 $O(n+\log D)$ 或 $O(n\log n+\log D)$ 细节非常多.

$O(n + \log D)$ 代码 ：[见云剪贴板](https://www.luogu.com.cn/paste/g4l76gys)

**注意实现时的空间！！！注意实现时的空间！！！注意实现时的空间！！！**

**不建议使用vector存图/map存DP结果.**

---

## 作者：Sorato_ (赞：4)

# P6803 星际迷航 题解

## 题目大意

给定一颗 $N$ 个节点的树。这样的树有 $D+1$ 层，编号从 $0$ 到 $D$。对于 $i=0,1,\dots,D-1$，需要选择第 $i$ 层的任意一个节点向第 $i+1$ 层的任意一个节点连一条**有向边**。最初人在第 $0$ 层图的 $1$ 号节点。两个玩家交替选择下一步向哪走，要求走到的点 $v$ 之前没有到过，且与当前节点 $u$ 相邻或有一条有向边从 $u$ 指向 $v$。如果到一个玩家选择时，不能走到任何没有到过的节点，这个玩家就输了。问有多少种连有向边的方案能使得先手必胜。

## Solve

首先，如果从一棵树的节点 $u$ 开始走，那么将这棵树的根定为 $u$ 之后，走出的合法路径一定是一条从浅往深走的链。所以如果第 $i$ 层和第 $i+1$ 层间的有向边指向节点 $u$，那么相当于把第 $i+1$ 层的树的根定为 $u$。

连接这条有向边之后，会根据节点 $u$ 是必胜还是必败，对这条边起点的状态做出一定修改。所以，我们并不关心这条有向边指向的是哪个节点，只关心从指向的那个节点开始，先手是必胜还是必败。

由此，我们设计如下状态：设 $f(i,1/0)$ 表示考虑了 $i$ 层树，从第 1 棵树的任意节点开始走，使得先手必胜 / 必败，这样的连边的总方案数。

考虑我把在这 $i$ 层树前面再添一层树（记为第 0 棵树），即把原来的第 1 棵树连在第 0 棵的某个节点下。 $f(i,0/1)$ 如何转移到 $f(i+1,0/1)$？

记新连的这条有向边为 $(u,v)$。第 $0$ 棵树的根为 $s$。

对于 $f(i+1,1)$，我要求最后先手必胜。

- 如果 $s$ 原本是必胜的，我要求 $(u,v)$ 不能改变 $s$ 的状态；
- 否则，我要求必须改变 $s$ 的状态。

对于 $f(i+1,0)$，类似。

接下来考虑什么样的 $(u,v)$ 能使 $s$ 的状态发生改变。显然当这 $i$ 层树在从 $v$ 开始时是必胜态时，$(u,v)$ 一定不会改变 $s$ 的状态，即：$u$ 只有连向一个必败点，$(u,v)$ 才会改变 $s$ 的状态。

所以我们设 $g(s)$ 表示在以 $s$ 为根时，有多少个节点 $u$ 满足从 $u$ 向一个必败点连边后，$s$ 的状态会发生改变。

如果求出来 $g(u)$，我们根据 $s$ 原本的状态和要转移到的状态的异同，就能知道是否要求 $(u,v)$ 必须改变 $s$ 的状态，就有了如下状态转移式：
$$
f(i+1,1)\longleftarrow\sum\limits_{s=1}^n
\begin{cases}
g(s)f(i,0),&h(s)=0\\
n(f(i,0)+f(i,1))-g(s)f(i,0).&h(s)=1
\end{cases}\\
f(i+1,0)\longleftarrow\sum\limits_{s=1}^n
\begin{cases}
g(s)f(i,0),&h(s)=1\\
n(f(i,0)+f(i,1))-g(s)f(i,0).&h(s)=0\\
\end{cases}
$$
其中，$h(s)$ 表示在原树中，以 $s$ 为根是先手必胜还是必败。$n(f(i,0)+f(i,1))$ 为这 $i+1$ 层间的总连边方案。

系数为定值，并且 $i$ 的范围很大，但第二维状态很少，所以考虑矩阵快速幂加速。

求出 $f(D,0/1)$ 之后，根据 $h(1)$ 来计算最终答案即可。

$h$ 的换根比较简单。问题是 $g$ 怎么求。

先考虑若以 1 为根，如何求 $g(1)$，即朴素树形 dp。

设 $g'_s(u)$ 表示以 $s$ 为根时，$u$ 的子树内有多少节点满足向必败点连边后能改变 $u$ 的状态。分情况讨论。

- 若 $u$ 子树内必败，那么 $g'_s(u)$ 即为所有儿子 $g'$ 的和，再加上 1，即自己直接连向必败点的方案。
- 否则若 $u$ 的儿子里只有一个必败，那个儿子记为 $u'$，那么 $g'_s(u)=g'_s(u')$。

至于换根，记 $w(u,0/1)$ 表示以 $u$ 为根时，$u$ 儿子里必败 / 必胜点的 $g$ 值的和，$w'_{s}(u,0/1)$ 表示以 $s$ 为根时，$u$ 儿子里必败 / 必胜点的$g$ 值的和。那么 $g'$ 的转移可以形式化地表示为：
$$
g'_s(u)=
\begin{cases}
w'_s(u,0)+1,&h'_s(u)=0\\
w'_s(u,1),&h'_s(u)=1\\
0.&\text{Otherwise}
\end{cases}
$$
其中，$h'(u)$ 表示以 1 为根时，$u$ 的儿子内必败点个数。之所以弃掉原本必胜 / 必败的意义，是为了方便转移。

接下来考虑如何换根求 $g(u)$。

当根从 $u$ 换到 $v$ 时，首先要把 $v$ 的贡献从 $w(u),h(u)$ 里刨掉得到 $w'_v(u),h'_v(u)$，之后根据上面的式子，计算 $g'_v(u)$，用 $h'_v(u),g'_v(u)$ 更新 $h(v),w(v)$。

感觉重点在这个 $w$ 的定义，很巧妙，省去了很多讨论。

## Code

```c++
void F(int u,int fa)
{
	for(int v:e[u])
		if(v!=fa)
			F(v,u),h[u]+=!h[v],w[u][h[v]>0]+=g[v];
	if(h[u]==1)	g[u]=w[u][0];
	if(!h[u])	g[u]=w[u][1]+1;
}
void G(int u,int fa)//换根
{
	if(!h[u])	cnt=-~cnt;
	int _h,_g,_w[2];
	for(int v:e[u])
		if(v!=fa)
		{
			_w[0]=w[u][0],_w[1]=w[u][1];
			_h=h[u]-!h[v];_w[h[v]>0]-=g[v];
			if(_h>1)	_g=0;
			else if(_h)	_g=_w[0];
			else	_g=_w[1]+1;
			h[v]+=!_h;w[v][_h>0]+=_g;
			if(h[v]>1)	g[v]=0;
			else if(h[v])	g[v]=w[v][0];
			else	g[v]=w[v][1]+1;
			G(v,u);
		}
}
struct mat{矩乘板子}a;
signed main()
{
	n=read();m=read();
	for(int i=1,u,v;i<n;i=-~i)
		u=read(),v=read(),
		e[u].push_back(v),e[v].push_back(u);
	F(1,0);G(1,0);
	for(int i=1;i<=n;i=-~i)//根据换根求得的 g 计算转移矩阵
		if(h[i])
			add(a.a[0][0],g[i]),
			add(a.a[0][1],n-g[i]),add(a.a[1][1],n);
		else
			add(a.a[0][1],g[i]),
			add(a.a[0][0],n-g[i]),add(a.a[1][0],n);
	a=a^(m-1);
	int x=(1ll*cnt*a.a[0][0]+1ll*(n-cnt)*a.a[1][0])%MOD;
	int y=(1ll*cnt*a.a[0][1]+1ll*(n-cnt)*a.a[1][1])%MOD;
	if(h[1])	ans=(1ll*n*(x+y)-1ll*g[1]*x)%MOD;//若以 1 为根必胜，我要求不能改变根的状态
	else	ans=1ll*g[1]*x%MOD;//否则要求必须改变
	return printf("%d",ans),0;
}
```

---

## 作者：luanmenglei (赞：3)


记从这个点开始先手必胜的点为白点，反之则为黑点。

考虑从后往前考虑树的形态，因为在一开始只有最后的一棵树才是我们所了解的。

注意到从第 $i+1$ 层到第 $i$ 层的考察中，我们并不关心 $i$ 中的一个节点到底连接了 $i+1$ 中的哪一个节点，我们只关心其连接的为黑点还是白点。

所以不难想到我们只需要维护两个值：

$A$ 表示在所有 $i+1\sim D$ 的连边方案中，第 $i$ 层的白点个数之和；

B 表示在所有 $i+1\sim D$ 的连边方案中，第 $i$ 层的黑点个数之和。

只要我们能对每一个节点求出 $f_{x,0/1}$ 表示 $x$ 这个点为黑点/白点时的整棵树的黑点白点数量，那么就能快速转移了，因为从 $A \rightarrow A'$ 只关心 $f$ 的和，并且每层的树的形态在连边之前都是一样的，所以可以矩阵快速幂转移。

但这样做有点太麻烦了，于是我们另辟蹊径，计算每一个点的贡献，那么我们就只需要求出 $f_x$ 表示能够通过连边使得 $x$ 的状态翻转的点数就可以转移了。

记 $S_1$ 表示原树中白点集合，$S_0$ 表示黑点集合。

那么有转移：

$$
A'=\sum_{x \in S_1}{(n-f_x)B+nA}+\sum_{x \in S_0}{f_xB}
$$
$$
=n\lvert S_1 \rvert(A+B)+B\left(\sum_{x\in S_0}{f_x}-\sum_{x\in S_1}f_x \right) 
$$

$$
B'=\sum_{x \in S_1}{B f_x}+\sum_{x \in S_0}{(n-f_x)B+nA}
$$
$$
=n \lvert S_0 \rvert (A+B)+B\left(\sum_{x \in S_1}f_x-\sum_{x \in S_0}{f_x} \right)
$$

可以发现同样都只与和有关且系数不变，那么转移矩阵也是好写的，这里不再赘述。

于是现在所有的工作都只需要关心在原树上怎么求出一个点的状态和能改变他状态的点数了。

这些都是可以用换根 DP 求出的，方法都是先计算钦定一个点只关心其子树内的点的答案，然后再通过其父亲已经算好的作为根的答案转移，这也是换根 DP 的通用方法，这里同样不再赘述。

一些分讨的过程会写在注释里。

时间复杂度 $\mathcal{O}(n + \log D)$。

[提交记录 #1879735 - LibreOJ (loj.ac)](https://loj.ac/s/1879735)

---

## 作者：TruchyR (赞：2)

观前提示：建议进文章页面获得更好的阅读体验。  

模拟赛 T4 赛后没看题解自己调出来的，写篇题解纪念一下。    

这篇题解的换根 dp 自己觉得说是如换，且可能比较麻烦。  
## 第一步
目标：**求每个点为根时的胜负**。

这里指的是只看一棵树时，从每个点开始先手是否必胜。    

下文必胜或必败指的是先手。  

首先要发现，如果一个点接下来能走的地方有至少一个必败，那么这个点就必胜，否则这个点必败。  

具体的，前者可以前往必败的那个点，这样对面就成了必败的先手。  
### 第一小步
目标：**求以点 $1$ 为根，每个点只能往深处走时的胜负**。    

最容易的一种情况，直接深搜，然后看儿子中是否有必败。    
$f_i$ 表示这种情况的胜负，$f_i=1$ 表示必胜，$f_i=0$ 表示必败。  
```cpp
void dfs1(int t){
	for(auto i:v[t]){
		if(fa[t]==i) continue;
		fa[i]=t;ss[t]++;//这里顺便记录了每个节点儿子数量
		dfs(i);
		if(!f[i]) f[t]=1;//如果儿子必败，这个点必胜
	}
}
```
### 第二小步
目标：**求以当前点为根时的胜负**。  

进一步地，我们可以引入 $fc_i$ 表示点 $i$ 接下来的选择中有多少点是必胜点。这里的选择指包括指向父亲的所有出边。  

如果这个值与选择的数量相同，说明接下来走不到必败点，这个点自然必败。否则这个点就必胜。  

引入 $fu_i$ 表示点 $i$ 的父亲的必胜情况，注意这里不能往回走到点 $i$。用上面的方法判断即可。  

然后自然可以算出当前点为根时的胜负了，具体看代码。  

```cpp
void dfs2(int t){
	if(t>1){
        fu[t]=((fc[fa[t]]-f[t])<(v[fa[t]].size()-1));
        //(fc[fa[t]]-f[t]) 即这个点的父亲的选择中的必胜点数量
        //(v[fa[t]].size()-1) 即这个点的父亲的选择的数量
        //注意要扣掉 t 这个点的信息
    }
	fc[t]=fu[t];
	for(auto i:v[t]){
		if(fa[t]==i) continue;
		fc[t]+=f[i];
	}//统计 fc[t]，就是把父亲和儿子的合起来
	for(auto i:v[t]){
		if(fa[t]==i) continue;
		dfs2(i);
	}//继续往下搜
}
```
## 第二步
目标：**求每个点为根时，这棵树有几个点向下一个平行宇宙连边可能改变这个点的胜负**。  

首先看什么类型的点向外连什么类型的点可以改变这个点的胜负。  

- 如果从必胜点连向必胜点，由于这个点的选择已经有过必败点，所以胜负不会改变。  

- 如果从必胜点连向必败点，由于这个点的选择已经有过必败点，所以胜负不会改变。  

- 如果从必败点连向必胜点，这个点的选择中还是没有必败点，所以还是必败，胜负不会改变。  

- 如果从必败点连向必败点，这个点的选择中出现了必败点，这个点会变为必胜点，胜负改变。  

所以得出结论，必败点连向必败点才会改变这个点的胜负。  

那么一直到根节点呢？还是要一个一个算，具体看下面。  
### 第一小步
目标：**求以点 $1$ 为根，每个点只能往深处走时，子树有几个点向外连可以改变最上面点的胜负**。

设 $F_i$ 为标题这个值，注意这里区分大小写。  

那么首先如果点 $t$ 必败，那么可以造成贡献。  

考虑点 $t$ 的每个儿子 $i$ 如果胜负改变，是否会对点 $t$ 造成影响。   

容易得到，没改变前，儿子中的必胜点数量是 $ct=fc_t-fu_t$，而选择数 $S$ 为儿子总数量。    

- 如果点 $i$ 原先是必败点，那么必胜点数量成为 $ct+1$，如果 $ct+1=S$，改变后点 $t$ 的选择变得没有必败点，胜负改变。  

- 如果点 $i$ 原本是必胜点，那么必胜点数量变为 $ct-1$，如果 $ct=S$，改变后点 $t$ 的选择变得有必败点，胜负改变。  

据此，我们可以写下第三个深搜。  

```cpp
void dfs3(int t){
	if(!f[t]) F[t]++;
    //这个点必败的贡献
	int ct=fc[t]-fu[t];
    //选择中必胜点数量
	int S=ss[t];
    //选择数，前面求过
	for(auto i:v[t]){
		if(i==fa[t]) continue;
		dfs3(i);//注意这里要先递归
		if(f[i]){
			if(ct==S) F[t]+=F[i];
            //i 原先是必胜，改变后 t 的选择中有了必败
		}else{
			if(ct+1==S) F[t]+=F[i];
            //i 原先是必败，改变后 t 的选择中没有了必败
		}
	}
}
```
### 第二小步
目标：求**以当前点为根，整棵树有几个点向外连可以改变根节点的胜负**。

在这之前先求出 $fal_i$ 表示以点 $i$ 为根是否必胜，前面讲过。  

最难的也是最后一个深搜。  

设 $Fl_i$ 为上面标题的值。  

设 $Fu_i$ 为这个点表示点 $i$ 的父亲可以走到的点中有几个向外连可以改变父亲的胜负，注意这里不能往回走到点 $i$。  

先考虑求出 $Fl_t$，这里要用到 $Fu_t$ 但是后文再说。 

容易得到，没改变前，出边中的必胜点数量是 $ct=fc_t$，而选择数 $S$ 为出边数量。  

那么可以仿照上一个搜索的方法，就是往父亲走的时候要修改一下，贡献是 $Fu_t$。  

接下来考虑用 $t$ 的信息求出它儿子 $i$ 的 $Fu_i$。  

- 如果点 $i$ 是必胜点，上文提到的 $ct$ 与 $S$ 同时减一，相当于没影响，直接把 $Fl_t$ 加进去。  

- 如果点 $i$ 是必败点，上文提到的 $S$ 减一，有影响了，要按照类似的方式重新算一遍。  

但还有要注意的点：  

1. 如果 $Fl_t$ 中把儿子 $i$ 的贡献算进去了，儿子 $i$ 那边要扣掉。  

2. 这种情况下，点 $t$ 的胜负要按照全文的计算方式重新算一遍。  

```cpp
void dfs4(int t){
	int ct=fc[t];
    //选择中必胜点数量
	int S=v[t].size();
    //选择数即出边数量
	int uut=0;
    //对于儿子是必败点的要再算
    //下面循环的部分和上一个搜索相似
	for(auto i:v[t]){
		if(i==fa[t]){
			if(fu[t]){
				if(ct==S) Fl[t]+=Fu[t];
				if(ct==S-1) uut+=Fu[t];
			}else{
				if(ct+1==S) Fl[t]+=Fu[t];
				if(ct+1==S-1) uut+=Fu[t];
			}
		}else{
			if(f[i]){
				if(ct==S) Fl[t]+=F[i],Fu[i]-=F[i];
                //儿子在贡献里，由于在 Fu[i] 的定义中 t 没法去 i，所以儿子那要扣掉
				if(ct==S-1) uut+=F[i];
			}else{
				if(ct+1==S) Fl[t]+=F[i];
				if(ct+1==S-1) uut+=F[i],Fu[i]-=F[i];
                //与上面同理
			}
		}
	}
	for(auto i:v[t]){
		if(i==fa[t]) continue;
		if(f[i]){Fu[i]+=Fl[t];}
		else{Fu[i]+=uut;}
        //按题解说的加进去
		if((fc[t]-f[i])>=(v[t].size()-1)) Fu[i]++;
        //这个条件就是 t 在没法去 i 时是否必败
		dfs4(i);
	}
	if(!fal[t]) Fl[t]++;
    //这个点必败的贡献，放在最后更新方便一些
}
```
## 第三步
目标：**计算 $d=1$ 的情况**。

这里说的点 $1$ 是 $P_1^0$。  

首先看不改变点 $1$ 胜负的连边： 

1. 前面求的那 $Fl_1$ 个点，但是连向了必胜点。  
2. 前面求的那 $Fl_1$ 以外的点连向任一点。  

改变点 $1$ 胜负的连边自然只有：

1. 前面求的那 $Fl_1$ 个点，连向了必败点。

设 $oans_{0/1}$ 为初始树上以某个点为根必败或必胜的点数量，那么就可以求出不改变和改变胜负的连边方案数。  

前者是 $Fl_1\times oans_1+(n-Fl_1)\times (oans_0+oans_1)$，后者是 $Fl_1\times oans_0$。  

根据点 $1$ 原本的状态输出其中一个，我们终于拿到了 $38$ 分！

代码放在最后。  
## 第四步
目标：完成本题。

接下来，设 $G_{i,0/1}$ 为考虑了 $i\sim d$ 个平行宇宙的所有连边方案后，产生的所有 $n^{2(d-i)}$ 中方案中在平行宇宙 $i$ 中的 $n^{2(d-i)+1}$ 个点中，有几个必败/必胜点。  

这个转移可以仿照上面的，有：  

- $G_{d,0}=oans_0$，$G_{d,1}=oans_1$。
- $G_{i,0}=p_{0,0}\times G_{i+1,0}+p_{1,0}\times G_{i+1,1}$。 
- $G_{i,1}=p_{0,1}\times G_{i+1,0}+p_{1,1}\times G_{i+1,1}$。 

对于树上的每个点 $j$，可以在递推前对系数 $p$ 做出如下更新：  
- 将 $p_{0,fal_j}$ 增加 $n-Fl_j$。
- 将 $p_{1,fal_j}$ 增加 $Fl_j+n-Fl_j=n$。
- 将 $p_{0,(1-fal_j)}$ 增加 $Fl_j$。

和前面的类似，只是把式子拆开了。  

然后我们就可以先做出一个 $O(n+d)$ 的算法。  

注意到这个柿子可以变为 $[G_{d,0},G_{d,1}]\times\begin{bmatrix}
 p_{0,0} & p_{0,1}\\
 p_{1,0} & p_{1,1}
\end{bmatrix}^{(d-1)}=[G_{1,0},G_{1,1}]$。 

然后我们可以矩阵快速幂过掉这题！  
### 代码
```cpp
#include<bits/stdc++.h>
#define CKE if(CHECK)
#define FRE if(FIL)
#define int long long
#define MX 200005
using namespace std;
const int mod=1000000007;int read();
int n,d,a,b,fa[MX],f[MX],fu[MX],fc[MX],fal[MX],F[MX],Fu[MX],Fl[MX];
vector<int> v[MX],oo[MX];int ss[MX];
void dfs1(int t){
	for(auto i:v[t]){
		if(fa[t]==i) continue;
		fa[i]=t;ss[t]++;
        //这里顺便记录了每个节点儿子数量和父亲
		dfs1(i);
		if(!f[i]) f[t]=1;
        //如果儿子必败，这个点必胜
	}
}
void dfs2(int t){
	if(t>1){
        fu[t]=((fc[fa[t]]-f[t])<(v[fa[t]].size()-1));
        //(fc[fa[t]]-f[t]) 即这个点的父亲的选择中的必胜点数量
        //(v[fa[t]].size()-1) 即这个点的父亲的选择的数量
        //注意要扣掉 f[t]
    }
	fc[t]=fu[t];
	for(auto i:v[t]){
		if(fa[t]==i) continue;
		fc[t]+=f[i];
	}//统计 fc[t]，就是把父亲和儿子的合起来
	for(auto i:v[t]){
		if(fa[t]==i) continue;
		dfs2(i);
	}//继续往下搜
}
void dfs3(int t){
	if(!f[t]) F[t]++;
    //这个点必败的贡献
	int ct=fc[t]-fu[t];
    //选择中必胜点数量
	int S=ss[t];
    //选择数，前面求过
	for(auto i:v[t]){
		if(i==fa[t]) continue;
		dfs3(i);//注意这里要先递归
		if(f[i]){
			if(ct==S) F[t]+=F[i];
            //i 原先是必胜，改变后 t 的选择中有了必败
		}else{
			if(ct+1==S) F[t]+=F[i];
            //i 原先是必败，改变后 t 的选择中没有了必败
		}
	}
}
void dfs4(int t){
	int ct=fc[t];
    //选择中必胜点数量
	int S=v[t].size();
    //选择数即出边数量
	int uut=0;
    //对于儿子是必败点的要再算
    //下面循环的部分和上一个搜索相似
	for(auto i:v[t]){
		if(i==fa[t]){
			if(fu[t]){
				if(ct==S) Fl[t]+=Fu[t];
				if(ct==S-1) uut+=Fu[t];
			}else{
				if(ct+1==S) Fl[t]+=Fu[t];
				if(ct+1==S-1) uut+=Fu[t];
			}
		}else{
			if(f[i]){
				if(ct==S) Fl[t]+=F[i],Fu[i]-=F[i];
                //儿子在贡献里，由于在 Fu[i] 的定义中 t 没法去 i，所以儿子那要扣掉
				if(ct==S-1) uut+=F[i];
			}else{
				if(ct+1==S) Fl[t]+=F[i];
				if(ct+1==S-1) uut+=F[i],Fu[i]-=F[i];
                //与上面同理
			}
		}
	}
	for(auto i:v[t]){
		if(i==fa[t]) continue;
		if(f[i]){Fu[i]+=Fl[t];}
		else{Fu[i]+=uut;}
        //按题解说的加进去
		if((fc[t]-f[i])>=(v[t].size()-1)) Fu[i]++;
        //这个条件就是 t 在没法去 i 时是否必败
		dfs4(i);
	}
	if(!fal[t]) Fl[t]++;
    //这个点必败的贡献，放在最后更新方便一些
}
int oans[10],pjz[10];
int lans[5],pxs[2][2],pys[2][2],pzs[2][2];
void Matrix(int cs){
    //矩阵快速幂，这里写的比较难看
	memcpy(pys,pxs,sizeof(pxs));cs--;
	while(cs){
		if(cs&1){
			pzs[0][0]=(pxs[0][0]*pys[0][0]+pxs[0][1]*pys[1][0])%mod;
			pzs[0][1]=(pxs[0][0]*pys[0][1]+pxs[0][1]*pys[1][1])%mod;
			pzs[1][0]=(pxs[1][0]*pys[0][0]+pxs[1][1]*pys[1][0])%mod;
			pzs[1][1]=(pxs[1][0]*pys[0][1]+pxs[1][1]*pys[1][1])%mod;
			memcpy(pxs,pzs,sizeof(pzs));
		}
		cs>>=1;
		pzs[0][0]=(pys[0][0]*pys[0][0]+pys[0][1]*pys[1][0])%mod;
		pzs[0][1]=(pys[0][0]*pys[0][1]+pys[0][1]*pys[1][1])%mod;
		pzs[1][0]=(pys[1][0]*pys[0][0]+pys[1][1]*pys[1][0])%mod;
		pzs[1][1]=(pys[1][0]*pys[0][1]+pys[1][1]*pys[1][1])%mod;
		memcpy(pys,pzs,sizeof(pzs));
	}
}
signed main(){
	n=read();d=read();
	for(int i=1;i<n;i++){
		a=read();b=read();
		v[a].push_back(b);
		v[b].push_back(a);
	}
    //四个深搜
	dfs1(1);
	dfs2(1);
	dfs3(1);
	for(int i=1;i<=n;i++) fal[i]=(fc[i]<v[i].size());
	dfs4(1);
    //计算系数和oans
	for(int i=1;i<=n;i++){
		oans[fal[i]]++;
		pxs[0][fal[i]]+=(n-Fl[i]);
		pxs[1][fal[i]]+=n;
		pxs[0][fal[i]^1]+=Fl[i];
		for(int ii=0;ii<2;ii++)
		for(int jj=0;jj<2;jj++)
			pxs[ii][jj]%=mod;
	}
	pjz[0]=oans[0],pjz[1]=oans[1];
	if(d>1){
        //矩阵快速幂
	    Matrix(d-1);
    	pjz[2]=pxs[0][0]*pjz[0]+pxs[1][0]*pjz[1];
    	pjz[3]=pxs[0][1]*pjz[0]+pxs[1][1]*pjz[1];
    	pjz[0]=pjz[2]%mod,pjz[1]=pjz[3]%mod;
	}
    //算最后一个
	lans[fal[1]]=(Fl[1]*pjz[1]+(n-Fl[1])*(pjz[0]+pjz[1]))%mod;
	lans[fal[1]^1]=(Fl[1]*pjz[0])%mod;
	cout<<lans[1];
	return 0;
}
int read(){
	int Ca=0;char Cr=' ';int Cf=1;
	while(Cr<'0' || Cr>'9'){Cr=getchar();if(Cr=='-'){Cf=-1;}}
	while(Cr>='0' && Cr<='9'){Ca=Ca*10+Cr-48;Cr=getchar();}
	return Ca*Cf;
}
```

---

## 作者：Green_White (赞：1)

## [P6803	\[CEOI2020\] 星际迷航](https://www.luogu.com.cn/problem/P6803)

来自 [动态规划题单](https://www.cnblogs.com/FloatingLife/p/18396056)。

当 $D=0$ 时，我们思考怎么求出舰长是否必胜：\
因为我们只能从 $1$ 出发，所以如果我们以 $1$ 为根，我们肯定只能一直往下走。\
所以可以树形 DP，设 $p_i$ 表示 $i$ 点是否为先手必胜点 (下面简称为必胜点，必败点同理)。\
根据 SG 函数的相关知识 $p_i=mex_{j \in son(i)}$。\
最后就是看 $p_1$ 是否为 `true`。

当 $D=1$ 时：\
我们需要把第二棵树的一个点 $y$ 接到第一棵树的一个点 $x$ 下，所以如果我们选择走 $(x,y)$ 这条星门，那么走到第二棵树后就是以 $y$ 为根了，所以我们还需要求出以每一个点为根时，$p$ 数组的情况，我们先假设我们做 $n$ 次树形 DP $O(n^2)$ 地来求。\
下面将以 $p_{rt,i}$ 表示以 $rt$ 为根时，$i$ 是否为必胜点 (只有一棵树，即 $D=0$)。\
还是考虑树形 DP，设 $g_i$ 表示在 $D=1$ 时，以 $1$ 为根，将第二棵树的一个点 $y$ 拉过来当做 $i$ 子树内一个点的儿子，使 $i$ 成为必胜点（$i$ 可以原来就是必胜点）的方案数。\
首先如果 $y$ 是一个必胜点，即 $p_{y,y}=true$，那么把它接过来没有任何影响，所以我们在 $dp$ 状态中认为 $y$ 是一个必败点。(这里 $y$ 假设给定，即计算方案数时不需要考虑 $y$ 到底是第二棵树的哪个点)。\
下面除了 $y$ 节点，节点均指在原树中的 (即第一棵树)。

1. 如果 $i$ 原来有 $\ge 2$ 个子节点 $j$ 是必败点：\
   那么把 $y$ 接过来不会有任何影响，因为 $y$ 至多改变一个儿子的状态，$g_i=size_i$。
2. 如果 $i$ 原来有 $1$ 个儿子 $j$ 是必败点：\
   (1) 那么我要么不把 $y$ 接在 $j$ 的子树里，让他还是必败点，方案数 $=size_i-size_j$。\
   (2) 要么把 $y$ 接在 $j$ 的子树里，但是要使 $j$ 还是必败点，方案数 $=size_j-g_j$。\
   综上 $g_i=size_i-g_j$。
3. 如果 $i$ 原来一个儿子都不是必败点：\
   那么我要使得让他的一个儿子变成必败点，$g_i=1 + \sum (size_j - g_j) = size_i - \sum g_j$（最开始 $+1$ 是因为可以直接接在 $i$ 下面）。

如果设 $s_1$ 表示 $p_{y,y}=true$ 的 $y$ 的数量，$s_0$ 表示 $p_{y,y}=false$ 的 $y$ 的数量，那么有：\
$ans = n\times s_1 \times p_{1,1} + g_1\times s_0$。\
意思是，如果以 $1$ 为根时，$1$ 点是必胜点（即 $p_{1,1}=true$），那么第二棵树里 $s_1$ 中的点可以随便连，否则不能连。而 $s_0$ 中的点只能连在可以使 $1$ 点成为必胜点的那 $g_1$ 个点中。

**再次提醒**：$p_{rt,i},s_0,s_1$ 这些量都只是针对原树而言，并没有其他树连进来；$g$ 只考虑的是 $D=1$ 的情况。\
时间复杂度 $O(n^2)$。

在下面的讨论中由于我们只用到了每一个 $p_{rt,rt}$，所以将以 $p_{rt}$ 代替 $p_{rt,rt}$。

当 $D>1$ 时：\
直觉告诉我们肯定是从后往前 DP，设 $f_{i,0}$ 表示遍历到第 $i$ 棵树，从第 $i$ 棵树中选出一个必败点连向第 $i-1$ 棵树（**具体连第 $i-1$ 棵树的哪个点未定**）的方案数。\
$f_{i,1}$ 则是选出一个必胜点连向第 $i-1$ 棵树。\
由于我们每一次仅仅只需要挑出一个必胜点或必败点，这意味着我们需要求出以每一个 $x$ 为根时，$g_x$ 的值，因此下面的讨论将以 $g_x$ 表示以 $x$ 为根时，$g_x$ 的值，而不是以 $1$ 为根。\
我们还是先暴力地做 $n$ 次树形 DP 来得到这个东西。

1. 如果第 $i+1$ 棵树向第 $i$ 棵树连进来的是必胜点，那么相当于没有连，所以从第 $i$ 棵树选出一个必败点的方案为 $s_0$，选出一个必胜点的方案为 $s_1$，所以：\
   $f_{i+1,1}\times n\times s_0 \to f_{i,0}$\
   $f_{i+1,1}\times n\times s_1 \to f_{i,1}$\
   因为我们的 dp 状态里规定了：**具体连第 $i-1$ 棵树的哪个点未定**，所以第 $i+1$ 棵树先随便连一个点，再从那 $s_0/s_1$ 个点中选出一个点连向 $i-1$。
2. 如果第 $i+1$ 棵树向第 $i$ 棵树连进来的是必败点，那让一个点 $x$ 成为必胜点的方案有 $g_x$ 种，成为必败点的方案有 $n-g_x$ 种，所以：\
   $f_{i+1,0}\times \sum g_x \to f_{i,1}$\
   $f_{i+1,0}\times \sum (n-g_{x}) \to f_{i,0}$

综上，得到转移方程：\
$f_{i,0}=f_{i+1,1}\times n\times s_0 + f_{i+1,0}\times \sum(n-g_x)$\
$f_{i,1}=f_{i+1,1}\times n\times s_1 + f_{i+1,0}\times \sum g_x$\
容易预处理出，$sum_1=\sum g_x,sum_0=\sum (n-g_x) = n^2 - sum_1$，所以转移是 $O(1)$ 的。\
边界：$f_{D,0}=s_0,f_{D,1}=s_1$。\
答案：$ans = n \times f_{1,1}\times p_1 + f_{1,0}\times g_1$。\
时间复杂度 $O(n^2+D)$。

设计完状态就是一些关于优化的套路了，我们来看要优化什么：

1. 求 $p_x$。
2. 求 $g_x$。
3. 求 $f_{i,0/1}$。

$1,2$ 直接换根 DP：\
设 $up_i$ 表示以 $fa_i$ 为根时，去掉 $i$ 这棵子树，$p_{fa_i}$ 的值。\
$h_i$ 表示以 $fa_i$ 为根时，去掉 $i$ 这棵子树，$g_{fa_i}$ 的值。\
那么就可以用 $i$ 号节点儿子的 $p$ 和 $up_i$ 更新 $p_i$，儿子的 $g_i$ 和 $h_i$ 更新 $g_i$，更新方法类似。\
那怎么求 $up$ 和 $h$ 呢？\
会发现 $up_i$ 只需要用 $up_{fa_i}$ 和 $p_u$ ( $u$ 是除了 $i$ 以外 $fa_i$ 的儿子) 类似更新。\
$h_i$ 只需要用 $h_{fa_i}$ 和 $g_u$ ( $u$ 是除了 $i$ 以外 $fa_i$ 的儿子) 类似更新即可。

再来看 $3$ 的转移：\
$f_{i,0}=f_{i+1,1}\times n\times s_0 + f_{i+1,0}\times sum_0$。\
$f_{i,1}=f_{i+1,1}\times n\times s_1 + f_{i+1,0}\times sum_1$。\
这就非常的矩阵快速幂，因为只跟上一层的状态和 $n,s_0,sum_0,s_1,sum_1$ 有关。\
转移矩阵就不写了，手推即可。

DP 好题！点赞。

时间复杂度：$O(n + \log D)$。

## code

```
#include<bits/stdc++.h>
#define int long long 
using namespace std;
const int N=1e5+5,mod=1e9+7;
inline int read(){
    int w = 1, s = 0;
    char c = getchar();
    for (; c < '0' || c > '9'; w *= (c == '-') ? -1 : 1, c = getchar());
    for (; c >= '0' && c <= '9'; s = 10 * s + (c - '0'), c = getchar());
    return s * w;
}
int n,D;
int tot,head[N],to[N<<1],Next[N<<1]; 
void add(int u,int v){
	to[++tot]=v,Next[tot]=head[u],head[u]=tot;
}

int Size[N],fa[N],p[N],g[N]; 
vector<int> son[N];
vector<int> V[N];   //V[u] 保存满足 v 是 u 的儿子，且 p[v]=0 的 v
int Sumg[N];  //保存儿子的 g 的和 
void dfs1(int u,int Fa){
	fa[u]=Fa;
	Size[u]=1;
	p[u]=0;
	int cnt=0,failson=0,sumg=0;
	for(int i=head[u];i;i=Next[i]){
		int v=to[i];
		if(v==fa[u]) continue;
		son[u].push_back(v);
		dfs1(v,u);
		Size[u]+=Size[v];
		if(p[v]==0) p[u]=1,cnt++,failson=v,V[u].push_back(v);
		(sumg+=g[v])%=mod;
	}
	Sumg[u]=sumg;
	if(cnt>=2) g[u]=Size[u];
	else if(cnt==1) g[u]=(Size[u]-g[failson]+mod)%mod;
	else g[u]=(Size[u]-sumg+mod)%mod;
}

int up[N],h[N];
void dfs2(int u){//在计算 up 和 h 时不能每一次都遍历兄弟，不然碰到菊花就假了 
	if(fa[u]){
		up[u]=0;
		int cnt=0,failson_g=0,sumg=0;
		cnt=V[fa[u]].size();
		for(int v:V[fa[u]])   //这里遍历兄弟至多只遍历2个 
			if(v!=u){
				failson_g=g[v];
				break;
			} 
		sumg=(Sumg[fa[u]]-g[u]+mod)%mod;
		if(p[u]==0) cnt--;
		
		if(fa[fa[u]]){
			if(up[fa[u]]==0) cnt++,failson_g=h[fa[u]];
			(sumg+=h[fa[u]])%=mod;
		}
		
		if(cnt) up[u]=1;
		if(cnt>=2) h[u]=n-Size[u];  //注意此时整棵树的大小要减去 Size[u] 
		else if(cnt==1) h[u]=(n-Size[u]-failson_g+mod+mod)%mod;
		else h[u]=(n-Size[u]-sumg+mod+mod)%mod;		
	}
	
	for(int i=head[u];i;i=Next[i]){
		int v=to[i];
		if(v==fa[u]) continue;
		dfs2(v);
	}
} 

int s0,s1,sum0,sum1;
void dfs3(int u){   //更新 p 和 g 
	p[u]=0;
	int cnt=0,failson_g=0,sumg=0;
	for(int v:son[u]){
		if(p[v]==0) p[u]=1,cnt++,failson_g=g[v];
		(sumg+=g[v])%=mod;
	}
	if(fa[u]){
		if(up[u]==0) p[u]=1,cnt++,failson_g=h[u];
		(sumg+=h[u])%=mod;
	}
	if(cnt>=2) g[u]=n;
	else if(cnt==1) g[u]=(n-failson_g+mod)%mod;
	else g[u]=(n-sumg+mod)%mod;
	
	if(p[u]==0) s0++;
	else s1++;
	(sum1+=g[u])%=mod,(sum0+=(n-g[u]+mod)%mod)%=mod;

	for(int i=head[u];i;i=Next[i]){
		int v=to[i];
		if(v==fa[u]) continue;
		dfs3(v);
	}
}

struct Matrix{
	int a[2][2];
	int n,m;
	void Init(){
		memset(a,0,sizeof a);
	}
}F,A;
Matrix operator * (const Matrix &A,const Matrix &B){
	Matrix C;
	C.Init();
	C.n=A.n,C.m=B.m;
	for(int k=0;k<=A.m;k++){
		for(int i=0;i<=C.n;i++){
			for(int j=0;j<=C.m;j++){
				(C.a[i][j]+=A.a[i][k]*B.a[k][j]%mod)%=mod;
			}
		}
	}
	return C;
}
Matrix Quick_power(Matrix A,int b){
	Matrix Ans;
	Ans.n=1,Ans.m=1;
	for(int i=0;i<=Ans.n;i++){    //单位矩阵 
		for(int j=0;j<=Ans.m;j++){
			if(i==j) Ans.a[i][j]=1;
			else Ans.a[i][j]=0;
		}
	}
	while(b){
		if(b&1) Ans=Ans*A;
		b>>=1,A=A*A;
	} 
	return Ans;
}
signed main(){
//	freopen("ball.in","r",stdin);
//	freopen("ball.out","w",stdout);
	n=read(),D=read();
	for(int i=1;i<n;i++){
		int u=read(),v=read();
		add(u,v),add(v,u);
	}
    
    dfs1(1,0);
    dfs2(1);
    dfs3(1);
    
    F.n=0,F.m=1;
    F.a[0][0]=s0,F.a[0][1]=s1;
    A.n=1,A.m=1;
    A.a[0][0]=sum0;
    A.a[0][1]=sum1;
    A.a[1][0]=s0*n%mod;
    A.a[1][1]=s1*n%mod;
    F=F*Quick_power(A,D-1);
    
	printf("%lld\n", (F.a[0][1]*n%mod*p[1]+F.a[0][0]*g[1]%mod)%mod );
	return 0;
}
```

---

## 作者：封禁用户 (赞：1)

## 正题
题目链接:https://www.luogu.com.cn/problem/P6803

[link](https://www.luogu.com.cn/problem/P6803)
## 题目大意
给出一棵 $n$ 个点的树，把它复制出 $D+1$ 层，编号为 $[0,D]$，然后每一层随机一个点向下一层随机一个点连边。

然后从第 $0$ 层的 $1$ 号点出发，两个人轮流操作走向一个之前没有走过的点，求有多少种连边方案使得先手必胜。

$1\leq n\leq 10^5,1\leq D\leq 10^{18}$

## 解题思路
我们先只考虑连到下一层的那个点是必胜还是必败的。

显然，连接的下一层的点如果是必胜的，那么局面不会有任何改变。而如果连接的是必败的点，那么原本必败的情况就会变成必胜的情况。

考虑对于每个点算出  $G_{x,0/1}$  表示从 $x$ 出发的情况，如果连接的下层点必败，这一层有多少种连边情况会先手必胜/先手必败。

这个东西虽然比较麻烦，但是可以通过换根 dp 求出。

然后把所有点的求个和得到 $S_{0,0/1}$ 表示下一层连接先手必败的点，这一层得到胜/负的方案。

同样的通过每一个点为根时树的胜负情况得 $S_{1,0/1}$ 表示下一层连接先手必胜的点（局面不会改变），这一层得到胜/负的方案。

这样做 $D$ 层我们就可以直接矩阵乘法了。

时间复杂度： $O(n+\log D)$

## 代码
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<vector>
#define ll long long
using namespace std;
const ll N=1e5+10,S=2,P=1e9+7;
struct Matrix{
	ll a[S][S];
}s,ans,c;
Matrix operator*(const Matrix &a,const Matrix &b){
	memset(c.a,0,sizeof(c.a));
	for(ll i=0;i<S;i++)
		for(ll j=0;j<S;j++)
			for(ll k=0;k<S;k++)
				(c.a[i][j]+=a.a[i][k]*b.a[k][j]%P)%=P;
	return c;
}
struct node{
	ll to,next;
}a[N<<1];
ll n,d,tot,ls[N],g[N][2];
bool f[N];vector<ll> q[N];
void addl(ll x,ll y){
	a[++tot].to=y;
	a[tot].next=ls[x];
	ls[x]=tot;return;
}
void dfs(ll x,ll fa){
	ll p=0;
	for(ll i=ls[x];i;i=a[i].next){
		ll y=a[i].to;
		if(y==fa)continue;
		dfs(y,x);f[x]|=!f[y];
		if(!f[y])p=(p?-1:y);
		g[x][1]+=g[y][0];
		g[x][0]+=g[y][1];
	}
	if(p==-1)g[x][1]+=g[x][0];
	else if(p>0)g[x][1]+=g[x][0]-g[p][1];
	if(p==-1)g[x][0]=0;
	else if(p>0)g[x][0]=g[p][1];
	g[x][1]++;
	return;
}
void solve(ll x,ll fa,ll p,ll s0,ll s1){
	if(!p)q[x].push_back(fa);
	for(ll i=ls[x];i;i=a[i].next){
		ll y=a[i].to;
		if(y==fa)continue;
		if(!f[y]&&q[x].size()<3)q[x].push_back(y);
		s0+=g[y][1];s1+=g[y][0];
	}
	if(!q[x].size())p=0;
	else if(q[x].size()==1)p=q[x][0];
	else p=-1;
	int pg0=g[x][0],pg1=g[x][1];
	g[x][0]=s0,g[x][1]=s1;
	if(p==-1)g[x][1]+=g[x][0],g[x][0]=0;
	else if(p>0)g[x][1]+=g[x][0]-g[p][1],g[x][0]=g[p][1];
	g[x][1]++;ll _f=(p?1:0);ans.a[0][_f]++;
	s.a[0][0]+=g[x][0];s.a[0][1]+=g[x][1];
	s.a[1][0]+=(!_f)*n;s.a[1][1]+=_f*n;
	for(ll i=ls[x];i;i=a[i].next){
		ll y=a[i].to;
		if(y==fa)continue;
		if(!q[x].size())p=0;
		else if(q[x].size()==1){
			if(q[x][0]==y)p=0;
			else p=q[x][0];
		}
		else if(q[x].size()==2){
			if(q[x][0]==y)p=q[x][1];
			else if(q[x][1]==y)p=q[x][0];
			else p=-1;
		}
		else p=-1;
		g[x][0]=s0-g[y][1];g[x][1]=s1-g[y][0];
		if(p==-1)g[x][1]+=g[x][0],g[x][0]=0;
		else if(p>0)g[x][1]+=g[x][0]-g[p][1],g[x][0]=g[p][1];
		g[x][1]++;solve(y,x,p?1:0,g[x][1],g[x][0]);
	}
	g[x][0]=pg0;g[x][1]=pg1;return;
}
signed main()
{
	scanf("%lld%lld",&n,&d);
	for(ll i=1,x,y;i<n;i++){
		scanf("%lld%lld",&x,&y);
//		x=i+1;y=(i+1)/2;
		addl(x,y);addl(y,x);
	}
	dfs(1,0);
	ll A=g[1][1];
	solve(1,0,1,0,0);
	s.a[0][0]%=P;s.a[0][1]%=P;
	s.a[1][0]%=P;s.a[1][1]%=P;
	d--;
	while(d){
		if(d&1)ans=ans*s;
		s=s*s;d>>=1;
	}
	ll answer=A*ans.a[0][0]%P;
	(answer+=f[1]*n*ans.a[0][1]%P)%=P;
	printf("%lld\n",answer);
	return 0;
}
```
代码长度 2.38 KB


用时 264 ms


内存 21.84 MB


---

## 作者：huhangqi (赞：1)

由于两个人都是绝对聪明的，所以每个人都只会做出最好的选择。

由于这个游戏在加完星门以后的情况已经确定了，所以开始时的树的形态以及开的星门就会直接导致游戏的胜负。

那么我们可以先处理出在根的胜负。

我们记录状态 $dp_i$ 在 $i$ 为 $0$ 或者 $1$，分别表示在这个点先手一定赢还是一定输。

怎么样可以知道是赢还是输呢？

如果我这一步走到一个先手必定输的点，那么我经过这一次聪明的选择就可以直接拿下对手，反之如果我走了先手必赢的点，那么对手就一定可以把我拿下。

那么情况就显然了，如果这个点的儿子中有必输点，那么这个点就必赢，反之必输。

那么我们可以直接在 $O(n)$ 内求出根是必赢还是必输。

但是还有一个星门操作对于答案可能产生影响。

我们先考虑 $D$ 的值为 $1$ 的情况。

此时我们连接一条边，需要知道这个点为根是必赢还是必输。

虽然树的形态相同，但是我们并不知道这个点到底是必赢点还是必输点因为我们只处理了这个点的子树内的情况。

这时很容易想到处理的方式就是换根 DP。

这时我们就得到了连接的点是必赢还是必输。

我们还可以发现只有在两个连接点都必输才能对前一棵树的连接点产生变化。

然而这样并不一定能够修改答案，因为我们的这一次变化必须对这个点的祖先产生影响。

明显我们希望得出以这个点为根的树内有多少个点修改可以对于这棵树的结果产生影响，这样才能够得到通过星门改变结果的方案数。

我们记录一个数组 $s_i$ 表示儿子中的必输点数量。

如果此时的 $s_i$ 为 $0$ 的话，那么这个点必输，我们直接修改它的一个儿子，变成必输，或者直接更改此节点，那么这个点就变为必胜了。

如果此时的 $s_i$ 为 $1$ 的话，此时这个点必赢，我们直接将那个必输点修改掉即可。

如果此时的 $s_i$ 大于 $1$ 的话，那么此时这个点一定是必赢，无法更改。

那么就处理完成了，再来一个换根就完事了。

那么我们就可以得到一个有效修改的节点数。

设在 $i$ 为根时更改有效的节点数为 $f_i$。

得到这个以后，我们再处理出最开始以这个节点为根的必赢和必输数量，就可以得到最终必赢和必输的情况。

式子可以自己推一下，考虑这个点是变还是不变即可。

此时再考虑有更大的 $D$ 的情况就很简单了，我们已经得到了新的根必胜和必败方案了，然后我们下一次操作本质相同，只需要将必赢和必输点的数量更新即可。

十分入机的加法乘法，简单的递推式，再加上巨大的操作次数，很容易就能想到矩阵优化。

那么直接上矩阵就拿下了。

代码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int mod=1e9+7;
int n,d,dp[100005],sum[100005][2],f[100005],s[100005],cnt;
vector<int> e[100005];
struct MT{
	int c[5][5],n,m;
	MT(){
		n=m=0;
		memset(c,0,sizeof(c));
	}
	MT friend operator*(MT a,MT b){
		MT c;
		c.n=a.n,c.m=b.m;
		for(int i=1;i<=a.n;i++){
			for(int j=1;j<=b.m;j++){
				for(int k=1;k<=a.m;k++){
					c.c[i][j]+=(a.c[i][k]*b.c[k][j])%mod;
					c.c[i][j]%=mod;
				}
			}
		}
		return c;
	}
}base,be;
void ksm(MT a,int b){
	while(b){
		if(b&1)be=be*a;
		a=a*a;
		b>>=1;
	}
}
void dfs(int p,int fa){
	for(int i:e[p]){
		if(i==fa)continue;
		dfs(i,p);
		if(!dp[i])s[p]++;
		sum[p][dp[i]]+=f[i];
	}
	if(s[p])dp[p]=1;
	else dp[p]=0;
	if(!s[p])f[p]=sum[p][1]+1;
	else if(s[p]==1)f[p]=sum[p][0];
	else f[p]=0;
}
void dfs2(int p,int fa){
	if(!dp[p])cnt++;
	int dpp=dp[p],sump0=sum[p][0],sump1=sum[p][1],fp=f[p],sp=s[p];
	for(int i:e[p]){
		if(i==fa)continue;
		if(!dp[i])s[p]--;
		sum[p][dp[i]]-=f[i];
		if(s[p])dp[p]=1;
		else dp[p]=0;
		if(!s[p])f[p]=sum[p][1]+1;
		else if(s[p]==1)f[p]=sum[p][0];
		else f[p]=0;
		swap(i,p);
		if(!dp[i])s[p]++;
		sum[p][dp[i]]+=f[i];
		if(s[p])dp[p]=1;
		else dp[p]=0;
		if(!s[p])f[p]=sum[p][1]+1;
		else if(s[p]==1)f[p]=sum[p][0];
		else f[p]=0;
		swap(i,p);
		dfs2(i,p);
		dp[p]=dpp,sum[p][0]=sump0,sum[p][1]=sump1,f[p]=fp,s[p]=sp;
	}
}
signed main(){
	cin>>n>>d;
	for(int i=1,u,v;i<n;i++){
		cin>>u>>v;
		e[u].push_back(v);
		e[v].push_back(u);
	}
	dfs(1,0);
	dfs2(1,0);
	base.n=base.m=2;
	for(int i=1;i<=n;i++){
		if(dp[i]){
			base.c[1][1]=(base.c[1][1]+f[i])%mod;
			base.c[1][2]=(base.c[1][2]+n-f[i])%mod;
			base.c[2][2]=(base.c[2][2]+n)%mod;
		}
		else {
			base.c[1][1]=(base.c[1][1]+n-f[i])%mod;
			base.c[2][1]=(base.c[2][1]+n)%mod;
			base.c[1][2]=(base.c[1][2]+f[i])%mod;
		}
	}
	be.n=1,be.m=2;
	be.c[1][1]=cnt,be.c[1][2]=n-cnt;
	ksm(base,d-1);
	if(dp[1])cout<<(((n-f[1])*be.c[1][1])%mod+(n*be.c[1][2])%mod)%mod;
	else cout<<(f[1]*be.c[1][1])%mod;
	return 0;
}

``````

---

## 作者：duyi (赞：0)

# CF1402C Star Trek

洛谷的Markdown缩进有一些问题，请务必进入下面的链接阅读：

[超超超超超超超超超超超超超超超超超超超超超超超超超超超超超超超超超超超超超超超超超超超超超爽的阅读体验](https://www.cnblogs.com/dysyn1314/p/13581665.html)

[题目链接](https://codeforces.com/contest/1402/problem/C)

约定：假设从第$i$棵树的节点$a$，连向了第$i+1$棵树的节点$b$，则我们认为第$i+1$棵树是以$b$为根的。

考虑一个DP。设$dp[i]$表示依次连接了$i$棵树，【从第一棵树的根节点出发，先手必胜】的方案数。注意，第一棵树的根节点可以是**任意一个节点**（只有在求答案时，才强制要求第一棵树的根节点是$1$，我们在定义状态时不考虑这个）。也就是说，$dp[i]$，是把第一棵树根节点为$1\dots n$的方案数加起来。

转移时考虑在**前面**添加一棵树。

朴素的转移，我们枚举添加的这棵树的根$\text{root}$。此时需要做一些分类讨论：

- 单独考虑一棵树，以$\text{root}$为根时，是否是先手必胜的。如果是**先手必胜**的，此时我们要求连出去的边**不能改变**根节点$\text{root}$的胜负状态。具体来说，枚举树里每一个节点$u$，考虑从$u$连出去：
  - 如果改变$u$的胜负性后，**不会影响**到根节点$\text{root}$的胜负性。那么后面$i-1$棵树的连边方案可以任意。方案数是$n\times n^{2(i-1)}$。其中$n$表示给后面的第一棵树定一个根节点，$n^{2(i-1)}$表示其他树之间任意连边。
  - 如果改变$u$的胜负性后，**会影响**到根节点$\text{root}$的胜负性：
    - 如果$u$的子树是先手**必胜**的。那么随便连一条边，当走到$u$时，先手无论如何不会走向这条边。所以也可以任意连边，方案数是$n\times n^{2(i-1)}$。
    - 如果$u$的子树是先手**必败**的。则我们连出去的边必须必胜。因为如果连向了一个必败状态，则走到$u$时，先手就一定就会走我们新连的这条边，于是就改变了$u$的胜负性，进而改变了根的胜负性。因此，连边只能连向必胜，方案数是$dp[i-1]$。
- 单独考虑一棵树，以$\text{root}$为根时，如果不是先手必胜（也就是**后手必胜**），此时我们要求连出去的边**必须改变**根节点的胜负状态。具体来说，枚举树里每一个节点$u$，考虑从$u$连出去：
  - 如果改变$u$的胜负性后，**不会影响**到根节点$\text{root}$的胜负性。那一定不符合我们的要求。所以从$u$节点连出去的方案数是$0$。
  - 如果改变$u$的胜负性后，**会影响**到根节点$\text{root}$的胜负性：
    - 如果$u$的子树是先手**必胜**的。那么我们无论怎么连边，走到$u$时先手都不会走我们连出去的边。所以不可能改变$u$的胜负性，进而不可能改变根的胜负性。所以方案数还是$0$。
    - 如果$u$的子树是先手**必败**的。那么我们连向一个必败点，就能改变$u$的胜负性。所以连边方案数是$n\times n^{2(i-1)}-dp[i-1]$。

通过上述的分类讨论，我们发现，确定根后，只需要知道每个节点$u$的两个信息：

- 点$u$的子树，是否是先手必胜的。
- 点$u$胜负性改变，是否会影响根的胜负性。

具体来说，只需要知道，对每个根来说，两种信息$2\times2$共$4$类点的数量分别是多少，就能计算出DP的转移系数。然后用矩阵快速幂优化DP。

首先，可以枚举根，各做一次树形DP，求出这两个信息。时间复杂度$O(n^2)$。具体来说：

- 点$u$的子树是否先手必胜。这个只需要看儿子里，有没有先手必败的点即可。只要存在先手必败的儿子，则点$u$就是先手必胜的，否则是先手必败的。
- 点$u$的胜负性改变，能否影响到根。这个要满足两个条件：
  - 首先，点$u$的父亲，必须能影响根。
  - 其次，点$u$的所有兄弟里（它父亲除了$u$以外的儿子），必须没有必败点。也就是说，要么点$u$父亲的儿子里压根没有必败点；要么恰好有一个必败点且这个点就是$u$。

这两个DP都比较简单。假设求出的两个信息，分别为$f_{\text{root}}(u),g_{\text{root}}(u)$（$f_{\text{root}}(u),g_{\text{root}}(u)\in\{0,1\}$）。那相当于对每个$\text{root}$，求出一个：
$$
\text{cnt}[\text{root}][x\in\{0,1\}][y\in\{0,1\}]=\sum_{i=1}^{n}[f_{\text{root}}(i)=x]\times[g_{\text{root}}(i)=y]
$$
假设有了这个$\text{cnt}$数组，我们就很容易求出系数，然后进行上述的DP并用矩阵快速幂优化了。

先对$1$，求出$\text{cnt}[1][x][y]$，然后换根。换根的时候非常复杂，需要进行大量的讨论。具体来说，要预处理出一个$s(u)$表示只考虑（以$1$为根时）点$u$的子树，子树里有多少$g_{1}(i)=1$的点。换句话说，就是不考虑$u$的父亲了，强制点$g(u)=1$。这个$s$在换根时，有很大的用处。

其他细节，留给读者自行讨论。实在讨论不出来可以看看参考代码。~~不过看到这么长的代码，你估计宁愿自己讨论......~~。

时间复杂度$O(n+\log d)$。


[去看代码~](https://www.cnblogs.com/dysyn1314/p/13581665.html)


---


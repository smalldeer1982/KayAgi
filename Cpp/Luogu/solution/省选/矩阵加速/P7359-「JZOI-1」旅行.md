# 「JZOI-1」旅行

## 题目背景

新年快到了，小僖要做一个长远的旅行，至于从哪里开始，到哪里，他还没有想好。

## 题目描述

这次旅行是在一个由 $N$ 个城市和 $(N-1)$ 条双向道路组成的一个国家中，其中保证任意两个城市可以互达。

为了美化环境，所有道路都是沿河修建的，这意味着小僖可以自己制造一艘船，然后划船通过这条路，所以小僖每走一条边都可以从陆上走过去，也可以划船通过。

当然，因为顺流和逆流的原因，所以有一个参数 $z_i$，换句话讲，如果从陆上走过这条边所花费的时间为 $a_i$，那么顺流而下划船所花费的时间为 $a_i-z_i$ (保证结果大于 $0$)，逆流而上花费的时间为 $a_i+z_i$。不过，造船需要 $L$ 的时间，且人一旦上了岸，就必须放弃这条船只。

现在小僖想你帮忙算一下从 $u$ 走到 $v$ 的最短时间。

注意：一条船可以连续走多段水路（只要你不下船）

## 说明/提示

### 样例1解释
图长这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/2sp03gic.png)

对于第一组询问，也就是从 $2$ 到 $3$，我们可以在 $2$ 号节点造船，花费 $2$ 的时间，然后从节点 $2$ 顺流而下到 $1$，花费 $2-1=1$，在顺流而下到 $3$，花费 $3-2=1$，所以总花费为 $2+1+1=4$。
## 数据范围
对于 $10\%$ 的数据，$N,T\leq10^3$。

对于另外 $10\%$ 的数据，树的形态随机。

对于另外 $20\%$ 的数据，所有的 $u$ 或所有的 $v$ 都相等。

最后一个测试点给出了一条链。

对于 $100\%$ 的数据，$N,T\leq2\times10^5$，且 $0
<a_i,L\leq10^5$。

## 样例 #1

### 输入

```
3 2 2
1 2 2 1 0
1 3 3 2 1
2 3
1 2```

### 输出

```
4
2```

## 样例 #2

### 输入

```
4 1 1
1 2 100 99 1
2 3 100 99 0
3 4 100 99 1
1 4```

### 输出

```
104```

# 题解

## 作者：_LHF_ (赞：9)

前置知识：矩阵乘法，动态规划，树上倍增

首先，我们先考虑链的情况的单个询问怎么处理。

设$f_{i,0/1}$表示当前处于第i个点，当前在走陆路、水路，那么$f_{i,0}=min(f_{i-1,0}+s1,f_{i-1,1}+min(s1,s2))$，$f_{i,1}=min(f_{i-1,1}+s2,f_{i-1,0}+min(s1,s2)+L)$其中，$s1,s2$分别表示走陆路和走水路的时间。

然后考虑优化。

我们发现这是一个矩阵乘法，可以得到转移矩阵
$$\begin{bmatrix}f_{i,0}\\f_{i,1}\end{bmatrix}=\begin{bmatrix}f_{i-1,0}\\f_{i-1,1}\end{bmatrix}* \begin{bmatrix} s1 & \min(s1,s2) \\ s2 & \min(s1,s2)+L \end{bmatrix}$$
其中，这里用的是广义矩阵乘法，这里的广义矩阵乘法的定义为，若：
$$C=A* B$$
其中A是一个$n\times m$的矩阵，B是一个$m\times k$的矩阵，则
$$C_{i,j}=\min_{p=1}^m(A_{i,p}+B_{p,j})$$
可以证明，这东西满足结合律。

所以用在本题上面，我们设$f_{i,j}$表示节点$i$向上走$2^j$的转移矩阵。

不过，由于从$u$到$v$并不等价于从$v$到$u$，所以我们要同时记录上行和下行的状态，最后倍增即可。

不过需要注意：矩阵乘法并不满足交换律，所以不要弄错乘法的顺序。

然后就没了，时间复杂度$O(n\log n)$，常数约为8.

---

## 作者：H6_6Q (赞：7)

$\large\text{Solution}$

简单说下我的做法吧。

对于树上的每一条链，我们可以通过维护一些信息来使得两条链之间可以合并。

那么一个显然的思路是维护：

1. 该链的两端都不开船的最小花费 $a$

1. 该链的下端开船，上端不开船的最小花费 $b$

1. 该链的上端开船，下端不开船的最小花费 $c$

1. 该链的两端都开船的最小花费 $d$

那么显然最简单的情况也就是只有一条边的情况，我们以此为边界。

然后就是考虑如何合并两条链  $x,y$ 的信息，使得合并后 $x$ 在下 $y$ 在上。

设合并完的链为 $z$，那么显然有以下式子：

$$a_z=\min(a_x+a_y,a_x+b_y,c_x+a_y,c_x+b_y-L)$$

$$b_z=\min(b_x+a_y,b_x+b_y,d_x+b_y-L,d_x+a_y)$$

$$c_z=\min(c_x+c_y,c_x+d_y-L,a_x+c_y,a_x+d_y)$$

$$d_z=\min(d_x+d_y-L,d_x+c_y,b_x+c_y,b_x+d_y)$$

既然已经支持合并，那么可以直接倍增瞎搞了。

当然还有很多细节要处理，不过都是一些小问题了。

代码就不放了，写得太丑了（

---

## 作者：翼德天尊 (赞：3)

在每个节点时的状态只有两个：有船或是没船。

显然两个点之间的路径可以由起点到 lca 的路径和 lca 到终点的路径拼接起来，所以我们可以考虑设置两个数组 $dp1_{i,0/1}$ 和 $dp2_{i,0/1}$ 分别表示从 $i$ 到 $i$ 的父亲，当前走路到 $i$ 或坐船到 $i$ 的最短时间，以及从 $i$ 的父亲到 $i$，当前走路到 $i$ 或坐船到 $i$ 的最短时间。有转移方程：

$$dp1_{fa,0}=\min(dp1_{i,0}+a_p,dp1_{i,1}+a_p)$$
$$dp1_{fa,1}=\min(dp1_{i,0}+L+a_p+z_p,dp1_{i,1}+a_p+z_p)$$
$$dp2_{i,0}=\min(dp2_{fa,0}+a_p,dp2_{fa,1}+a_p)$$
$$dp2_{i,1}=\min(dp2_{fa,0}+L+a_p+z'_p,dp2_{fa,1}+a_p+z'_p)$$

其中 $z_p$ 与 $z'p$ 为根据路径水流流向而增加或减少的额外时间。

为了能迅速求解，不妨将转移方程写成转移矩阵，通过倍增优化求解即可。

转移显然，询问时将两条路径的矩阵拼接起来即可。

这题又一次证明了转移矩阵**由于满足结合律而与数据结构拥有的高度适配性**。

其他题解都没放代码， 这里放个个人的 AC 代码给大家参考一下吧qwq：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
#define int long long
const int N=2e5+5;
const int INF=1e15;
const int K=22;
int n,l,q,dep[N],fa[N][K],ztot;
struct node{
	int head[N],tot,to[N<<1],next[N<<1],a[N<<1],z[N<<1];
	void adde(int u,int v,int x,int y){
		to[++tot]=v,a[tot]=x,z[tot]=y,next[tot]=head[u],head[u]=tot;
	}
}B;
struct Matrix{
	int a[2][2];
	Matrix(){//初始化矩阵
		a[0][0]=a[1][0]=a[0][1]=a[1][1]=INF;
	}
	void init(){//初始化向量
		a[0][0]=0;
		a[0][1]=a[1][0]=a[1][1]=INF;
	}
}S[N][K],T[N][K],Z[N];
Matrix operator *(const Matrix&x,const Matrix&y){
	Matrix z;
	for (int k=0;k<2;k++)
		for (int i=0;i<2;i++)
			for (int j=0;j<2;j++)
				z.a[i][j]=min(z.a[i][j],x.a[i][k]+y.a[k][j]);
	return z;
}
int read(){
	int w=0,f=1;
	char ch=getchar();
	while (ch>'9'||ch<'0') {
		if (ch=='-') f=-1;
		ch=getchar();
	}
	while (ch>='0'&&ch<='9') {
		w=(w<<3)+(w<<1)+(ch^48);
		ch=getchar();
	}
	return w*f;
}
void dfs(int u){//倍增预处理
	for (int i=B.head[u];i;i=B.next[i]){
		int v=B.to[i];
		if (v!=fa[u][0]){
			fa[v][0]=u;
			dep[v]=dep[u]+1;
			for (int j=1;(1<<j)<=dep[v];j++)
				fa[v][j]=fa[fa[v][j-1]][j-1];
			S[v][0].a[0][0]=B.a[i],S[v][0].a[0][1]=l+B.a[i]+B.z[i];
			S[v][0].a[1][0]=B.a[i],S[v][0].a[1][1]=B.a[i]+B.z[i];
			for (int j=1;(1<<j)<=dep[v];j++)
				S[v][j]=S[fa[v][j-1]][j-1]*S[v][j-1];
			T[v][0].a[0][0]=B.a[i],T[v][0].a[0][1]=l+B.a[i]-B.z[i];
			T[v][0].a[1][0]=B.a[i],T[v][0].a[1][1]=B.a[i]-B.z[i];		
			for (int j=1;(1<<j)<=dep[v];j++)
				T[v][j]=T[v][j-1]*T[fa[v][j-1]][j-1];//注意S和T不同的运算顺序（矩阵乘法不满足交换律）
			dfs(v);
		}
	}
}
Matrix query(int u,int v){//查询
	Matrix ans;
	ans.init();	
	if (dep[u]>dep[v]){
		for (int i=20;i>=0;i--)
			if (dep[u]-(1<<i)>=dep[v])
				ans=ans*T[u][i],u=fa[u][i];
	}else if (dep[v]>dep[u]){
		for (int i=20;i>=0;i--)
			if (dep[v]-(1<<i)>=dep[u])
				Z[++ztot]=S[v][i],v=fa[v][i];//用栈存储，倒序算贡献
	}
	if (u==v){
		while (ztot) ans=ans*Z[ztot],--ztot;
		return ans;
	}
	for (int i=20;i>=0;i--)
		if (fa[u][i]!=fa[v][i]){
			ans=ans*T[u][i],Z[++ztot]=S[v][i];
			u=fa[u][i],v=fa[v][i];
		}
	ans=ans*T[u][0],Z[++ztot]=S[v][0];
//	cout<<min(ans.a[0][0],ans.a[0][1])<<"\n";
	while (ztot) ans=ans*Z[ztot],--ztot;
	return ans;
}
signed main(){
	n=read(),l=read(),q=read();
	for (int i=1;i<n;i++){
		int u=read(),v=read(),x=read(),y=read(),z=read();
		if (z==1) B.adde(u,v,x,-y),B.adde(v,u,x,y);
		else B.adde(u,v,x,y),B.adde(v,u,x,-y);//加边
	}
	dfs(1);
	while (q--){
		int u=read(),v=read();
		Matrix ans=query(u,v);
		cout<<min(ans.a[0][0],ans.a[0][1])<<'\n';
	}
	return 0;  
}
```

---

## 作者：loveJY (赞：3)

这里提供一个理论复杂度和实际复杂度都更优的做法吧...

## Part0 prework

前置部分是设计本题的二维O1转移的dp,其他的题解都写的很好这里就不再赘述了

## Part1 可行的solution

可以根据dp转移我们不难设计出转移矩阵,并且使用$+\min$卷积实现矩阵乘法

接下来就相当于需要实现一个快速get$u->v$有向的路径转移矩阵积的东西,基本想法是树剖或者全局平衡二叉树维护区间矩阵乘法,然后通过合并区间来实现$O(poly\log*k^3)$的复杂度回答询问,k是矩阵的长

或者直接使用倍增,每个点维护向上跳$2^i$步的转移矩阵,然后对于询问可以$O(\log n)$次矩阵乘法进行回答,复杂度还是$O(nploy\log*k^3)$

因为回答询问可以使用一列向量去乘其余转移矩阵,每次的复杂度都是$O(k^2\log n),q\log nk^2$不是复杂度瓶颈,我们考虑怎么优化预处理的复杂度

## Part2 优化预处理

那么可以类似树状数组,我们维护每个点向上跳$2^0,2^1,....,2^{lowbit(dep(x))}$的转移矩阵,然后再回答询问的时候,只需要先不断的跳$lowbit(x)$步,直到x和LCA的深度差小于$lowbit(x)$,我们再从高位到低位和倍增一样的跳剩下的步数

但是这么做仍然可以卡到$O(k^3logn)$,构造一颗有很多$2^x$深度的点即可

但是**深度**这种东西我们是可以钦定的,也就是说所有树上节点深度其实只是关于根节点的相对深度

那么我们考虑把所有节点的$lowbit(x)$拿出来,然后我们从低到高考虑每一位,对于$lowbit$第i位为0节点数多于第i位为1的节点数的位,**我们就在根节点的这一位加上$2^i$**,从而相当于翻转整颗树这一位的0/1,使得这一位为1的更多

这样实现最劣情况下是$O(\frac{n}{2}*1+\frac{n}{4}*2+\frac{n}{8}*4....\leq 2n)=O(n)$的,因此我们只需要n次矩阵乘法

至此我们有了一个$O(nk^3+q\log k^2)$的做法

代码确实实现了也跑的快了一点,放出部分查询的关键代码吧

```cpp

int p = x;
while(dep[p] - dep[anc] >= lowbit(dep[p])) {
	ans = ans * st2[p][trs[lowbit(dep[p])]];
	p = fa[p][trs[lowbit(dep[p])]];
}//先跳lowbit
for(int i = logn; i >= 0; --i) {
	if((dep[p] - dep[anc]) >> i & 1) {
		ans = ans * st2[p][i];
		p = fa[p][i];
	}
}//再去倍增跳

```


要不要给给过审啊....这个做法还是挺妙的吧

---

## 作者：takanashi_mifuru (赞：1)

> 我爱树剖素质高高，凹凹凹凹！

这种拉一条路径出来然后问你什么最优化啊方案数啊这种看着就一股 dp 味的东西一般都是先序列上解决然后树剖一下或者倍增一下拉到树上去做。

那你考虑序列上面怎么做。

首先考虑无论是怎么走你的式子里面一定会有一个 $a_i$ 的贡献所以你直接提前把这个贡献加上，然后就只需要算一下 $z_i$ 的贡献了。

然后你考虑设计一个状态就是 $dp_{i,0/1}$，表示你走到这里，有没有坐船，然后这个东西转移很简单，如果你走路，那么一点贡献也没有，直接在上一个点的两个状态中取 $\min$，如果你坐船，那么要么是本来就坐船，直接更新贡献，要么是本来不坐船，现在坐船了，你要手搓一艘船然后更新，你发现这个东西的递推可以写成矩阵形式。

然后序列上解决这个问题就不能说是很困难了，你可以直接线段树维护区间矩阵乘积，然后直接乘过去，也可以倍增维护。

搬到树上就很套路了，找到 LCA 之后可以直接倍增或者树剖把矩阵的乘积找出来，时间复杂度是 $O(n\log n)$（倍增）或 $O(\log^2 n)$（树剖）的。

---

## 作者：Graphcity (赞：1)

我们先把询问所在的路径提取出来，设 $f_{i,0/1}$ 表示走到路径上的第 $i$ 个点，当前是走陆路 / 水路的代价。

顺流而下时，考虑如下决策：

- 走陆路：$f_{i,0}\gets f_{i-1,0}+a$

- 临时造一艘船，走完后扔掉：$f_{i,0}\gets f_{i-1,0}+L+a-z$

- 走完这条边后下船：$f_{i,0}\gets f_{i-1,1}+a-z$

- 造一艘船，开始走水路：$f_{i,1}\gets f_{i-1,0}+L+a-z$

- 走水路：$f_{i,1}\gets f_{i-1,1}+a-z$

逆流而上时大体相同。

我们发现这个转移可以写成矩阵乘法的形式：（$C_{i,j}=\min_k(A_{i,k}+B_{k,j})$）

$$
\begin{bmatrix}
\min(a,L+a-z) & a-z\\
L+a-z & a-z
\end{bmatrix}
\times
\begin{bmatrix}
f_{i-1,0} \\
f_{i-1,1}
\end{bmatrix}
=
\begin{bmatrix}
f_{i,0}\\
f_{i,1}
\end{bmatrix}
$$

逆流而上时，转移矩阵长这样：

$$
\begin{bmatrix}
a & a\\
L+a & \min(a+L,a+z)
\end{bmatrix}
\times
\begin{bmatrix}
f_{i-1,0} \\
f_{i-1,1}
\end{bmatrix}
=
\begin{bmatrix}
f_{i,0}\\
f_{i,1}
\end{bmatrix}
$$

用线段树维护矩阵的逆序乘积即可。

我们把这个过程搬到树上，用树链剖分就可以实现它。注意树剖向上跳的时候需要乘上顺序乘积，向下走的时候需要乘上逆序乘积。

时间复杂度 $O(n\log^2n)$。

```cpp
#include<bits/stdc++.h>
#define ll long long
#define For(i,a,b) for(int i=(a);i<=(b);++i)
#define Rof(i,a,b) for(int i=(a);i>=(b);--i)
using namespace std;
const int Maxn=2e5;
const ll inf=1e18;

inline int read()
{
    int x=0,f=1;
    char ch=getchar();
    while(ch<'0' || ch>'9')
    {
        if(ch=='-') f=-1;
        ch=getchar();
    }
    while(ch>='0' && ch<='9')
    {
        x=x*10+ch-'0';
        ch=getchar();
    }
    return x*f;
}

struct Node{int frm,to,nxt,w1,w2;} Edge[Maxn*2+5];
int tot,Head[Maxn+5];
inline void Addedge(int x,int y,int w1,int w2)
{
    Edge[++tot]=(Node){x,y,Head[x],w1,w2},Head[x]=tot;
    Edge[++tot]=(Node){y,x,Head[y],w1,w2},Head[y]=tot;
}
int n,m,s,fa[Maxn+5],dep[Maxn+5],siz[Maxn+5],son[Maxn+5];
int dfn[Maxn+5],top[Maxn+5],pre[Maxn+5],cur;
struct Matrix
{
    ll f[2][2];
    inline ll&operator()(int x,int y) {return f[x][y];}
    inline void Print() {printf("%lld %lld\n%lld %lld\n",f[0][0],f[0][1],f[1][0],f[1][1]);}
} mat[Maxn+5][2],t[Maxn*4+5][2],idt;
#define ls(x) (x<<1)
#define rs(x) (x<<1|1)
inline Matrix operator*(Matrix a,Matrix b)
{
    Matrix c;
    c(0,0)=min(a(0,0)+b(0,0),a(0,1)+b(1,0));
    c(0,1)=min(a(0,0)+b(0,1),a(0,1)+b(1,1));
    c(1,0)=min(a(1,0)+b(0,0),a(1,1)+b(1,0));
    c(1,1)=min(a(1,0)+b(0,1),a(1,1)+b(1,1));
    return c;
}
inline void dfs1(int x,int f)
{
    fa[x]=f,dep[x]=dep[f]+1,siz[x]=1;
    for(int i=Head[x];i;i=Edge[i].nxt)
    {
        int y=Edge[i].to,a=Edge[i].w1; if(y==f) continue;
        int tp=(i&1),z=Edge[i].w2;
        mat[y][tp](0,0)=min(a,s+a-z),mat[y][tp](0,1)=a-z;
        mat[y][tp](1,0)=s+a-z,mat[y][tp](1,1)=a-z,tp^=1;
        mat[y][tp](0,0)=a,mat[y][tp](0,1)=a;
        mat[y][tp](1,0)=s+a,mat[y][tp](1,1)=min(a+z,a+s);
        dfs1(y,x),siz[x]+=siz[y],son[x]=(siz[y]>siz[son[x]]?y:son[x]);
    }
}
inline void dfs2(int x,int t)
{
    dfn[x]=++cur,pre[cur]=x,top[x]=t;
    if(son[x]) dfs2(son[x],t);
    for(int i=Head[x];i;i=Edge[i].nxt)
    {
        int y=Edge[i].to;
        if(y!=fa[x] && y!=son[x]) dfs2(y,y);
    }
}
inline void Build(int l,int r,int p)
{
    if(l==r) {For(i,0,1) t[p][i]=mat[pre[l]][i]; return;}
    int mid=(l+r)>>1;
    Build(l,mid,ls(p)),Build(mid+1,r,rs(p));
    t[p][0]=t[ls(p)][0]*t[rs(p)][0];
    t[p][1]=t[rs(p)][1]*t[ls(p)][1];
}
inline Matrix Count(int nl,int nr,int l,int r,int p,int k)
{
    if(l<=nl && nr<=r) return t[p][k];
    int mid=(nl+nr)>>1; Matrix res=idt;
    if(k==0)
    {
        if(l<=mid) res=res*Count(nl,mid,l,r,ls(p),k);
        if(r>mid) res=res*Count(mid+1,nr,l,r,rs(p),k);
    }
    else
    {
        if(l<=mid) res=Count(nl,mid,l,r,ls(p),k)*res;
        if(r>mid) res=Count(mid+1,nr,l,r,rs(p),k)*res;
    }
    return res;
}
inline ll Count(int a,int b)
{
    Matrix s1=idt,s2=idt;
    while(top[a]!=top[b])
    {
        if(dep[top[a]]>dep[top[b]])
            s1=Count(1,n,dfn[top[a]],dfn[a],1,0)*s1,a=fa[top[a]];
        else s2=s2*Count(1,n,dfn[top[b]],dfn[b],1,1),b=fa[top[b]];
    }
    if(dep[a]>dep[b]) s1=Count(1,n,dfn[b]+1,dfn[a],1,0)*s1;
    if(dep[b]>dep[a]) s2=s2*Count(1,n,dfn[a]+1,dfn[b],1,1);
    s1=s2*s1; return min(s1(0,0),s1(1,0));
}

int main()
{
    n=read(),s=read(),m=read();
    idt(0,0)=idt(1,1)=0,idt(0,1)=idt(1,0)=inf;
    For(i,1,n-1)
    {
        int a=read(),b=read(),w1=read(),w2=read(),typ=read();
        if(typ==0) swap(a,b);
        Addedge(a,b,w1,w2);
    }
    dfs1(1,0),dfs2(1,1),Build(1,n,1);
    while(m--)
    {
        int a=read(),b=read();
        printf("%lld\n",Count(a,b));
    }
    return 0;
}
```

---

## 作者：zhangxy__hp (赞：0)

考虑一次询问，显然 DP，设 $f_{u,0/1}$ 表示走路/坐船到 $u$ 点的最小花费即可。

多次询问，考虑维护矩阵，广义矩阵乘，倍增处理询问。比如对于一条顺流的边 $i$，可以构造矩阵：

$$
\begin{bmatrix}
a_i&L+a_i-z_i\\
a_i&a_i-z_i
\end{bmatrix}
$$

对每个点 $u$ 维护 $up_{u,i}$ 和 $dw_{u,i}$ 表示从 $u$ 向上走到 $2^i$ 级祖先的矩阵和从 $2^i$ 级祖先向下走到 $u$ 的矩阵。时间复杂度 $O((N+T)\log N)$。

```cpp
#include<bits/stdc++.h>
#define ll long long
#define il inline

using namespace std;
namespace asbt{
namespace cplx{bool begin;}
const int maxn=2e5+5;
const ll inf=0x3f3f3f3f3f3f3f3f;
int n,m,q,enm,hd[maxn];
int anc[maxn][22],dep[maxn];
struct edge{
	int v,nxt;
	ll w,d;
	bool typ;
}e[maxn<<1];
il void addedge(int u,int v,ll w,ll d,bool typ){
	e[++enm]=(edge){v,hd[u],w,d,typ};
	hd[u]=enm;
}
struct juz{
	ll mat[2][2];
	juz(){
		mat[0][0]=mat[0][1]=mat[1][0]=mat[1][1]=0;
	}
	il ll*operator[](int x){
		return mat[x];
	}
	il juz operator*(juz x)const{
		juz res;
		res[0][0]=res[0][1]=res[1][0]=res[1][1]=inf;
		for(int i=0;i<=1;i++){
			for(int j=0;j<=1;j++){
				for(int k=0;k<=1;k++){
					res[i][j]=min(res[i][j],mat[i][k]+x[k][j]);
				}
			}
		}
		return res;
	}
}up[maxn][22],dw[maxn][22];
il void dfs(int u,int fa){
	anc[u][0]=fa,dep[u]=dep[fa]+1;
	for(int i=1;i<=20;i++){
		anc[u][i]=anc[anc[u][i-1]][i-1];
		up[u][i]=up[u][i-1]*up[anc[u][i-1]][i-1];
		dw[u][i]=dw[anc[u][i-1]][i-1]*dw[u][i-1];
	}
	for(int i=hd[u],v,w,d,typ;i;i=e[i].nxt){
		v=e[i].v,w=e[i].w,d=e[i].d,typ=e[i].typ;
		if(v==fa){
			continue;
		}
		up[v][0][0][0]=up[v][0][1][0]=w;
		dw[v][0][0][0]=dw[v][0][1][0]=w;
		if(typ){
			up[v][0][0][1]=m+w+d;
			up[v][0][1][1]=w+d;
			dw[v][0][0][1]=m+w-d;
			dw[v][0][1][1]=w-d;
		}
		else{
			up[v][0][0][1]=m+w-d;
			up[v][0][1][1]=w-d;
			dw[v][0][0][1]=m+w+d;
			dw[v][0][1][1]=w+d;
		}
		dfs(v,u);
	}
}
namespace cplx{
	bool end;
	il double usdmem(){return (&begin-&end)/1048576.0;}
}
int main(){
	ios::sync_with_stdio(0),cin.tie(0);
	cin>>n>>m>>q;
	for(int i=1,u,v,w,d,typ;i<n;i++){
		cin>>u>>v>>w>>d>>typ;
		addedge(u,v,w,d,typ);
		addedge(v,u,w,d,typ^1);
	}
	dfs(1,0);
//	for(int i=1;i<=n;i++){
//		for(int j=0;j<=1;j++){
//			cout<<up[i][j][0][0]<<" "<<up[i][j][0][1]<<" ";
//		}
//		puts("");
//		for(int j=0;j<=1;j++){
//			cout<<up[i][j][1][0]<<" "<<up[i][j][1][1]<<" ";
//		}
//		puts("");
//	}
//	for(int i=1;i<=n;i++){
//		for(int j=0;j<=1;j++){
//			cout<<dw[i][j][0][0]<<" "<<dw[i][j][0][1]<<" ";
//		}
//		puts("");
//		for(int j=0;j<=1;j++){
//			cout<<dw[i][j][1][0]<<" "<<dw[i][j][1][1]<<" ";
//		}
//		puts("");
//	}
	while(q--){
		int u,v;
		cin>>u>>v;
		if(u==v){
			cout<<"0\n";
			continue;
		}
		juz resu,resv;
		bool flu=0,flv=0;
		if(dep[u]>dep[v]){
			int ddep=dep[u]-dep[v],tmp=0;
			while(ddep){
				if(ddep&1){
					if(!flu){
						resu=up[u][tmp];
						flu=1;
					}
					else{
						resu=resu*up[u][tmp];
					}
					u=anc[u][tmp];
				}
				ddep>>=1,tmp++;
			}
			if(u==v){
				cout<<min(resu[0][0],resu[0][1])<<"\n";
				continue;
			}
		}
		else{
			int ddep=dep[v]-dep[u],tmp=0;
			while(ddep){
				if(ddep&1){
					if(!flv){
						resv=dw[v][tmp];
						flv=1;
					}
					else{
						resv=dw[v][tmp]*resv;
					}
					v=anc[v][tmp];
				}
				ddep>>=1,tmp++;
			}
			if(u==v){
				cout<<min(resv[0][0],resv[0][1])<<"\n";
				continue;
			}
		}
//		for(int i=0;i<=1;i++){
//			for(int j=0;j<=1;j++){
//				cout<<resu[i][j]<<" ";
//			}
//			puts("");
//		}
//		for(int i=0;i<=1;i++){
//			for(int j=0;j<=1;j++){
//				cout<<resv[i][j]<<" ";
//			}
//			puts("");
//		}
		for(int i=20;~i;i--){
			if(anc[u][i]!=anc[v][i]){
				if(!flu){
					resu=up[u][i];
					flu=1;
				}
				else{
					resu=resu*up[u][i];
				}
				if(!flv){
					resv=dw[v][i];
					flv=1;
				}
				else{
					resv=dw[v][i]*resv;
				}
				u=anc[u][i],v=anc[v][i];
			}
		}
		if(!flu){
			resu=up[u][0];
		}
		else{
			resu=resu*up[u][0];
		}
		if(!flv){
			resv=dw[v][0];
		}
		else{
			resv=dw[v][0]*resv;
		}
		juz res=resu*resv;
		cout<<min(res[0][0],res[0][1])<<"\n";
	}
	return 0;
}
}
int main(){return asbt::main();}
```

---

## 作者：Jerrywang09 (赞：0)

不是很难想的题。

考虑把路径拉出来，在序列上 DP。设 $f(u,0/1)$ 表示当前到达了结点 $u$，不在（在）船上的最小时间。

设当前点是 $u$，下一个点是 $v$，这个 DP 的转移是简单的（其中 $w'$ 是水流速度）：
$$
f(v,0)=\max(f(u, 0)+w, f(u, 1)+w)\\
f(v,1)=\max(f(u, 0)+L+w', f(u, 1)+w')
$$
写成矩阵形式（矩阵乘法是广义的）：
$$
\begin{pmatrix}
f(u, 0) & f(u, 1)
\end{pmatrix}
\begin{pmatrix}
w & L+w' \\
w & w' \\
\end{pmatrix}
=
\begin{pmatrix}
f(v, 0) & f(v, 1)
\end{pmatrix}
$$
搬到树上，可以使用树上倍增维护向上、向下两个方向的矩阵乘积。

```cpp
// P7359 「JZOI-1」旅行
#include <cstdio>
#include <iostream>
#define ll long long
#define rep(i, s, t) for(int i=s; i<=t; ++i)
#define debug(x) cerr<<#x<<":"<<x<<endl;
const int N=200010, lg=18; ll inf=0x3f3f3f3f3f3f3f3f;
using namespace std;
char buf[1<<23], *p1=buf, *p2=buf;
#define gc() (p1==p2 && (p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
inline int read()
{
    int x=0, f=1; char c=gc();
    while(c<'0' || c>'9') c=='-' && (f=-1), c=gc();
    while('0'<=c && c<='9') x=(x<<3)+(x<<1)+c-'0', c=gc();
    return x*f;
}

int n, L, T;
struct edge {int v, w, x, n;} e[N+N]; int hd[N], tot;
void add(int u, int v, int w, int x)
{
    e[++tot]={v, w, x, hd[u]}, hd[u]=tot;
}
struct mat
{
    ll a[2][2];
    mat() {a[0][0]=a[0][1]=a[1][0]=a[1][1]=inf;}
    void E() {a[0][0]=a[1][1]=0;}
    ll *operator[] (int i) {return a[i];}
} up[N][20], dn[N][20];
mat operator *(mat a, mat b)
{
    mat c;
    rep(i, 0, 1) rep(j, 0, 1) rep(k, 0, 1)
        c[i][j]=min(c[i][j], a[i][k]+b[k][j]);
    return c;
}
int d[N], f[N][20];
void dfs(int u, int fa)
{
    d[u]=d[fa]+1; f[u][0]=fa;
    rep(i, 1, lg)
    {
        f[u][i]=f[f[u][i-1]][i-1];
        dn[u][i]=dn[f[u][i-1]][i-1]*dn[u][i-1];
        up[u][i]=up[u][i-1]*up[f[u][i-1]][i-1];
    }
    for(int i=hd[u]; i; i=e[i].n) if(e[i].v!=fa)
    {
        int v=e[i].v, w=e[i].w, x=e[i].x;
        dn[v][0][0][0]=w, dn[v][0][0][1]=L+w+x;
        dn[v][0][1][0]=w, dn[v][0][1][1]=w+x;
        up[v][0][0][0]=w, up[v][0][0][1]=L+w-x;
        up[v][0][1][0]=w, up[v][0][1][1]=w-x;
        dfs(v, u);
    }
}
mat lca(int u, int v)
{
    mat Up, Dn; Up.E(), Dn.E();
    for(int i=lg; i>=0; i--) if(d[f[u][i]]>=d[v])
    {
        Up=Up*up[u][i];
        u=f[u][i];
    }
    for(int i=lg; i>=0; i--) if(d[f[v][i]]>=d[u])
    {
        Dn=dn[v][i]*Dn;
        v=f[v][i];
    }
    if(u==v) return Up*Dn;
    for(int i=lg; i>=0; i--) if(f[u][i]!=f[v][i])
    {
        Up=Up*up[u][i];
        Dn=dn[v][i]*Dn;
        u=f[u][i], v=f[v][i];
    }
    Up=Up*up[u][0];
    Dn=dn[v][0]*Dn;
    return Up*Dn;
}

int main()
{
#ifdef Jerrywang
    freopen("in.txt", "r", stdin);
#endif
    n=read(), L=read(), T=read();
    rep(i, 1, n-1)
    {
        int u=read(), v=read(), w=read(), x=read(), op=read();
        add(u, v, w, op?-x:x);
        add(v, u, w, op?x:-x);
    }
    dfs(1, 0);
    while(T--)
    {
        int u=read(), v=read();
        mat ret=lca(u, v);
        mat ori; ori[0][0]=0, ori[0][1]=L;
        ori=ori*ret;
        printf("%lld\n", min(ori[0][0], ori[0][1]));
    }

    return 0;
}
```

---


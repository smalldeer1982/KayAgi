# 「PMOI-3」期望乘积

## 题目描述

ducati 热爱定义一些奇奇妙妙的东西。

- 定义两个序列不同，当且仅当它们的长度不同，或者它们长度相同但存在至少一组对应位上的值不同。

- 定义序列 $A$ 的权值为 $A$ 中所有数的**乘积**。

- 定义序列间的**可达**如下：

  - 做**恰好** $t$ 次操作，每次操作选择 $A$ 的一个子区间（**注意，选定的子区间可以为空**）并将子区间中的数加 $1$ ；若存在一种操作方案，使得操作结束后 $A$ 与 $B$ 完全相同 ，则称 $A$ 可达 $B$。
  
- 定义序列 $A$ 的优美值为 $A$ 可达的**所有不同**序列的**权值**和。

现在，ducati 拥有了一个长度为 $n$ 的序列 $a$。他会多次查询一段区间的优美值。

你能帮帮好奇的他吗？你只需要输出每个答案对 $10007$ 取模的值就行啦。

## 说明/提示

【样例解释1】

$a$ 为 $\{1,2\}$。共 $1$ 次询问。

所有 $a$ 可达的 $b$ 如下：

$$\{1,3 \} \{2,2 \} \{2,3 \}\{1,2 \}$$

它们的权值之和为 $3+4+6+2=15$ 。

【样例解释2】

关于第二个样例，我有一个绝妙的解释，可惜这里空白太小，我写不下。

【数据范围】

**本题采用捆绑测试**。
- Subtask1（10pts）：$n,q\le8$；
- Subtask2（20pts）：$q=1$；
- Subtask3（30pts）：$n,q\le5\times10^4$，$t\le2$；
- Subtask4（40pts）：无特殊限制。

对于 $100\%$ 的数据满足，$1\le n,q\le10^5$，$1\le a_i\le10^4$，$1\le t\le3$，对于所有询问，$1\le l\le r\le n$。

## 样例 #1

### 输入

```
2 1 1
1 2
1 2```

### 输出

```
15```

## 样例 #2

### 输入

```
10 3 3
1 5 3 2 2 4 6 3 2 3
1 7
4 9
3 10```

### 输出

```
3850
1166
3893```

# 题解

## 作者：ducati (赞：4)

# Description

ducati 热爱定义一些奇奇妙妙的东西。

- 定义两个序列不同，当且仅当它们的长度不同，或者它们长度相同但存在至少一组对应位上的值不同。

- 定义序列 $A$ 的权值为 $A$ 中所有数的**乘积**。

- 定义序列间的**可达**如下：

  - 做**恰好** $t$ 次操作，每次操作选择 $A$ 的一个子区间（**注意，选定的子区间可以为空**）并将子区间中的数加 $1$ ；若存在一种操作方案，使得操作结束后 $A$ 与 $B$ 完全相同 ，则称 $A$ 可达 $B$。
  
- 定义序列 $A$ 的优美值为所有 $A$ 可达的**不同**序列的**权值**和。

现在，ducati 拥有了一个长度为 $n$ 的序列 $a$。他会多次查询一段区间的优美值。

你能帮帮好奇的他吗？你只需要输出每个答案对 $10007$ 取模的值就行啦。

$1 \le n,q \le 10^5$

# Solution

## Subtask 1

爆搜即可。

期望得分 $10$ 分。

## Subtask 2

不难发现，我们实际上就是要求出，所有满足对 $a[l \sim r]$ 进行不超过 $t$ 次操作可以达到的 $b$ 的权值和。注意，确定下了 $b$ 之后，从 $a$ 变为 $b$ 的最少操作次数就是 P1969。

考虑 $dp$ 。

令 $f_{i,j,k}$ 表示，目前考虑到第 $i$ 个数，$a_i$ 被加了 $j$ 次 $1$ ，且**要想达到**当前的 $b$ **至少需要操作** $k$ 次。

根据 P1969 的套路，不难得到状态转移式：

$$f_{i,j,k}=\sum_{p=0}^j f_{i-1,p,k-(j-p)}(a_i+j) + \sum_{p=j+1}^k f_{i-1,p,k} (a_i+j)$$

第一个 $\sum$ 表示 $j \ge p$ 的情况，此时总操作次数要添加 $j-p$ 次；第二个 $\sum$ 表示 $j<p$ 的情况，总操作次数不需增加。

边界: $f_{l-1,0,0}=1$

答案：$\sum_{x=0}^t \sum_{y=0}^t dp_{r,x,y}$

时间复杂度 $O(nt^3)$，期望得分 $30$ 分。

## Subtask 3
为了方便叙述，我们将这个三维 $dp$ 通过**映射**变为一个等价的二维 $dp$ 。具体地说，$f_{i,j,k}$ 被映射到了 $g_{i,(j-1)t+k}$。

考虑使用矩阵乘法来完成这个转移。

我们先处理出序列中每个位置的**转移矩阵**并建立出一棵线段树，维护区间内的**矩阵乘积**。

每次询问的时候，我们在线段树上找到那 $\log n$ 个被划分出来的区间，并将这些矩阵给乘起来即可。

时间复杂度 $O(nt^6+q \log n \ t^6)$ 。

期望得分 $60$ 分。

## Subtask 4
考虑优化。

在每次询问的时候，我们先定义一个向量，其 $1$ 至 $t$ 位均为 $0$，且第 $0$ 位为 $1$ 。 我们在线段树上找到那 $\log n$ 个被划分出来的区间，然后直接**向量乘矩阵**即可。

考虑到当 $t=3$ 时每个矩阵的边长都是 $10$ ，于是总时间复杂度为
$$O(10^3 n+10^2 \ q \log n)$$

期望得分 $100$ 分。

# Summary
本题主要考察了选手的 $dp$ 设计能力与优化能力，同时也考察了小数据结构与一些经典的优化套路(如向量乘矩阵，单次矩阵乘法对取模次数的优化)。

值得一提的是，本题似乎还可以通过**矩阵前缀和**以及**矩阵求逆**来解出。它虽然时间复杂度更为优秀（少一个 $\log n）$，但是它常数较大，有可能会被卡掉。

# Code

```cpp
#include <bits/stdc++.h>
#define PA pair<int,int>
#define fi first
#define se second
#define MP make_pair
using namespace std;
const int maxl=100005,mod=10007;

int read(){
	int s=0,w=1;char ch=getchar();
	while (ch<'0'||ch>'9'){if (ch=='-')  w=-w;ch=getchar();}
	while (ch>='0'&&ch<='9'){s=s*10+(ch^'0');ch=getchar();}
	return s*w;
}
int n,q,t,blo,now,ans,le,ri,tot;
int a[maxl],pos[11][11],lis[11];

struct Matrix{int a[11][11];}tmp[maxl];

struct Segment_tree{
	int lson,rson,prod;
	Matrix p;
}tree[maxl<<1];

Matrix operator * (const Matrix &x,const Matrix &y){
	Matrix z;
	for (int i=0;i<=blo;i++){
		for (int j=0;j<=blo;j++){
			z.a[i][j]=0;
			for (int k=0;k<=blo;k++)  z.a[i][j]+=x.a[i][k]*y.a[k][j];
			z.a[i][j]%=mod;
		}
	}
	return z;
}

void pushup(int rt){
	int l=tree[rt].lson,r=tree[rt].rson;
	tree[rt].p = tree[l].p * tree[r].p;
	tree[rt].prod = (tree[l].prod * tree[r].prod) % mod;
}

int build_tree(int l,int r,int rt){
	rt=++tot;
	if (l==r){
		tree[rt].prod=a[l];
		tree[rt].p=tmp[l];
		return rt;
	}
	int mid=(l+r)>>1;
	tree[rt].lson=build_tree(l,mid,0);
	tree[rt].rson=build_tree(mid+1,r,0);
	
	pushup(rt);
	
	return rt;
}

int query_prod(int nl,int nr,int l,int r,int rt){
	if (nl<=l&&r<=nr){
		return tree[rt].prod;
	}
	int mid=(l+r)>>1,res=1;
	if (nl<=mid)  res = query_prod(nl,nr,l,mid,tree[rt].lson);
	if (nr>mid)  res *= query_prod(nl,nr,mid+1,r,tree[rt].rson);
	
	return res%mod;
}

void query_seg(int nl,int nr,int l,int r,int rt){
	if (nl<=l && r<=nr){
		int tmp[10];
		for (int i=0;i<=blo;i++)  tmp[i]=0;
		for (int i=0;i<=blo;i++){
			for (int j=0;j<=blo;j++){
				tmp[j] += lis[i] * tree[rt].p.a[i][j];
			}
		}
		for (int i=0;i<=blo;i++)  lis[i] = tmp[i]%mod;
		return;
	}
	int mid=(l+r)>>1;
	if (nl<=mid)  query_seg(nl,nr,l,mid,tree[rt].lson);
	if (nr>mid)  query_seg(nl,nr,mid+1,r,tree[rt].rson);
}

signed main(){
	n=read(),q=read(),t=read();
	for (int i=1;i<=n;i++)  a[i]=read();
	
	if (t){
		blo=((t+1)*(t+2))/2;
		for (int i=0;i<=t;i++){
			for (int j=i;j<=t;j++){
				pos[i][j]=now;
				now++;
			}
		}
		for (int i=1;i<=n;i++){
			for (int j=0;j<=t;j++){
				int val=a[i]+j;
				for (int k=j;k<=t;k++){
					for (int p=0;p<=k;p++){
						if (p<j){
							if (k-j+p>=0)  tmp[i].a[pos[p][k-j+p]][pos[j][k]]=val;
						}
						else tmp[i].a[pos[p][k]][pos[j][k]]=val;
					}
				}
			}
		}
	}
	build_tree(1,n,1);
	while (q--){
		le=read(),ri=read();
		if (t==0){
			ans = query_prod(le,ri,1,n,1);
		} 
		else{
			memset(lis,0,sizeof(lis));
			lis[0]=1,ans=0;
			
			query_seg(le,ri,1,n,1);
			for (int i=0;i<=t;i++)  ans=(ans+lis[pos[i][t]])%mod;
		}
		printf("%d\n",ans);
	}
	return 0;
}
```


---

## 作者：冷却心 (赞：1)

shiroha 可爱捏。

给一个巨大暴力线段树做法，但是数据没卡？

先考察一个序列 $a$ 变换到另一个序列 $b$ 的最小操作次数。我们记增量 $d_i=b_i-a_i$，且 $d_0=0$，显然 $d_i$ 必非负，那么操作次数显然最少为 $\sum \max(d_i-d_{i-1},0)$。证明是 naive 的，考虑统计什么时候会新开一段加一即可。

本题需要多次询问，所以直接想线段树。考虑如何合并左右区间信息。我们对树上每个区间维护 $f_{a,b,p}$ 表示这个区间的左端点的增量为 $a$，右端点的增量为 $b$，区间内的最小操作次数是 $p$，的序列价值总和。记左区间维护的信息是 $f$，右区间是 $g$，当前合并的父区间为 $h$，那么：

$$f_{a,b,p} \times g_{c,d,q} \rightarrow h_{a,d,p+q-c+\max(0,c-b)}.$$

然后做完了。$n,q$ 同阶，时间复杂度 $O(nt^6\log n)$，可能会被卡常，可以通过调整上述六维的枚举顺序轻松通过。

```cpp
#include <bits/stdc++.h>
#define ull unsigned long long
#define LL long long
#define uint unsigned int
using namespace std;
const int N = 1e5 + 10;
const int MOD = 10007;
int n, Q, T, A[N];

struct Node { uint F[4][4][4]; } tr[N << 2];
const Node operator+(const Node& l, const Node& r) {
	if (l.F[0][0][0] == 114514) return r;
	if (r.F[0][0][0] == 114514) return l;
	Node res; memset(res.F, 0, sizeof res.F);
	for (int p = 0; p <= T; p ++) for (int q = 0; q <= T; q ++)
		for (int c = 0; c <= q; c ++) for (int b = 0; b <= p; b ++)
			if (p + q - c + max(0, c - b) <= T) 
				for (int a = 0; a <= p; a ++) for (int d = 0; d <= q; d ++)
					(res.F[a][d][p + q - c + max(0, c - b)] += (l.F[a][b][p] * r.F[c][d][q])) %= MOD;
	return res;
}
#define ls(x) (x << 1)
#define rs(x) (x << 1 | 1)
void build(int p, int l, int r) {
	if (l == r) {
		for (int i = 0; i <= T; i ++) tr[p].F[i][i][i] = (A[l] + i) % MOD;
		return ;
	}
	int mid = (l + r) >> 1; build(ls(p), l, mid); build(rs(p), mid + 1, r);
	tr[p] = tr[ls(p)] + tr[rs(p)]; return ;
}
Node query(int p, int l, int r, int x, int y) {
	if (x > r || y < l) { Node res; res.F[0][0][0] = 114514; return res; }
	if (x <= l && y >= r) return tr[p];
	int mid = (l + r) >> 1;
	return query(ls(p), l, mid, x, y) + query(rs(p), mid + 1, r, x, y);
}

int main() {
	freopen(".in", "r", stdin); freopen(".out", "w", stdout);
	ios :: sync_with_stdio(0); cin.tie(0); cout.tie(0);
	cin >> n >> Q >> T;
	for (int i = 1; i <= n; i ++) cin >> A[i];
	build(1, 1, n); int x, y;
	while (Q --) {
		cin >> x >> y;
		Node res = query(1, 1, n, x, y); uint Ans = 0;
		for (int i = 0; i <= T; i ++) for (int j = 0; j <= T; j ++) for (int k = 0; k <= T; k ++)
			Ans += res.F[i][j][k];
		cout << Ans % MOD << "\n";
	}
	return 0;
}
```

---

## 作者：Purslane (赞：1)

# Solution

简单题。

设每个位置**被增加的次数为 $c_i$**（特别的，$c_0=c_{n+1}=0$），则最少要加 $\sum_{i=1}^n \max\{0,c_i-c_{i-1}\}$ 次。

因此每个位置实际有用信息只有二元组 $(i,j)$，表示当前位的增加量，和之前的总爬坡量。注：显然 $i \le j$，因此实际上有用的对数为 $\dfrac{(t+1)(t+2)}{2}$，极限数据下是 $10$。

容易写出 $(i,j)$ 之间的转移，发现这是一个矩阵的形式，那么就可以 DDP 了。这时候可能想用线段树优化了。

但是发现我们不能允许 $O(n \log n)$ 次矩阵乘法。

假设我们要计算矩阵 $M_1M_2M_3 \cdots M_k$，但是我们发现实际上我们要用一个行向量 $A$，求出 $AM_1M_2\cdots M_k$。那么行向量和矩阵相乘就只需要进行 $100$ 次操作，能够用线段树维护了。

所以复杂度为：$O(nt^6 + qt^4 \log n)$，实际上有较小的常数，足以通过本题。

```cpp
#include<bits/stdc++.h>
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=1e5+10,MOD=1e4+7;
int n,q,t,a[MAXN],id[4][4];
struct MAT {int v[10][10];}ts[MAXN<<2];
struct VEC {int v[10];};
MAT operator *(MAT A,MAT B) {
	MAT res;memset(res.v,0,sizeof(res.v));
	ffor(i,0,9) ffor(j,0,9) ffor(k,0,9) res.v[i][k]=(res.v[i][k]+A.v[i][j]*B.v[j][k])%MOD;
	return res;
}
VEC operator *(VEC A,MAT B) {
	VEC res;memset(res.v,0,sizeof(res.v));
	ffor(i,0,9) ffor(k,0,9) res.v[k]=(res.v[k]+A.v[i]*B.v[i][k])%MOD;
	return res;
}
MAT gain(int a) {
	MAT res;
	memset(res.v,0,sizeof(res.v));
	ffor(i,0,t) ffor(j,i,t) ffor(dt,0,t) {
		int nj=j+max(0,dt-i);
		if(nj<=t) res.v[id[i][j]][id[dt][nj]]=a+dt;
	}
	return res;
}
#define lson (k<<1)
#define rson (k<<1|1)
#define mid (l+r>>1)
void build(int k,int l,int r) {
	if(l==r) return ts[k]=gain(a[l]),void();
	build(lson,l,mid),build(rson,mid+1,r);
	return ts[k]=ts[lson]*ts[rson],void();	
}
void query(int k,int l,int r,int x,int y,VEC &v) {
	if(x<=l&&r<=y) return v=v*ts[k],void();
	if(x<=mid) query(lson,l,mid,x,y,v);
	if(y>mid) query(rson,mid+1,r,x,y,v);
	return ;	
}
int main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>n>>q>>t;
	int tot=0;
	ffor(i,0,3) ffor(j,i,3) id[i][j]=tot++;
	ffor(i,1,n) cin>>a[i];
	build(1,1,n);
	ffor(i,1,q) {
		int l,r,res=0; cin>>l>>r;
		VEC ans; memset(ans.v,0,sizeof(ans.v));
		ans.v[id[0][0]]=1;
		query(1,1,n,l,r,ans);
		ffor(i,0,t) ffor(j,i,t) res=(res+ans.v[id[i][j]])%MOD;
		cout<<res<<'\n';
	}
	return 0;
}
```

---

## 作者：small_john (赞：1)

## 思路

妙妙题。

首先考虑暴力 dp，设 $f_{i,j,k}$ 为前 $i$ 个数，第 $i$ 个数加 $j$，操作次数为 $k$ 的序列权值之和。

转移是简单的：$f_{i,j,k}=\sum\limits_{x=0}^{j}f_{i-1,x,k-(j-x)}+\sum\limits_{x=j+1}^{t}f_{i-1,x,k}$。

原因为当上一个数的加的次数比这个数小时，这个数要多操作几次，反之，这个数不需要单独操作。

由于 $t$ 很小，所以考虑矩阵优化这个转移。

注意到，一个状态是有效的，当且仅当 $j\le k$，所以对于每一个 $i$，有效的状态至多有 $10$ 个，将这些状态映射到 $1\sim 10$ 即可使用矩阵。用线段树维护每个区间乘起来是多少，时间复杂度 $O(n\log n\times t^6)$。

但是这个时间复杂度还是难以通过，所以考虑向量乘矩阵，按顺序访问线段树上 $\log n$ 个节点，维护一个当前的向量即可。

时间复杂度 $O(n\times t^6+n\log n\times t^4)$，可以通过。

## 代码

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N = 1e5+5,mod = 1e4+7;
int n,q,lim,a[N],id[4][4],cnt;
struct node{
	int a[11][11];
	inline void init()
	{
		for(int i = 1;i<=cnt;i++)
			for(int j = 1;j<=cnt;j++)
				a[i][j] = 0;
	}
	inline friend node operator * (node x,node y)
	{
		node res;res.init();
		for(int i = 1;i<=cnt;i++)
			for(int j = 1;j<=cnt;j++)
				for(int k = 1;k<=cnt;k++)
					(res.a[i][j]+=x.a[i][k]*y.a[k][j])%=mod;
		return res;
	}
}t[N<<2];
#define ls (k<<1)
#define rs (k<<1|1)
void build(int k,int l,int r)
{
	if(l==r)
	{
		for(int i = 0;i<=lim;i++)//加的次数 
			for(int j = i;j<=lim;j++)//操作次数
			{
				for(int x = 0;x<=i;x++)
					(t[k].a[id[i][j]][id[x][j]]+=a[l]+x)%=mod;
				for(int x = i+1;x<=lim;x++)
					if(j+x-i<=lim) (t[k].a[id[i][j]][id[x][j+x-i]]+=a[l]+x)%=mod;
			}
		return;
	}
	int mid = (l+r)/2;
	build(ls,l,mid),build(rs,mid+1,r);
	t[k] = t[ls]*t[rs];
}
int f[2][11],now;
void ask(int k,int l,int r,int x,int y)
{
	if(l>y||r<x) return;
	if(l>=x&&r<=y)
	{
		now^=1;
		for(int j = 1;j<=cnt;j++)
		{
			f[now][j] = 0;
			for(int K = 1;K<=cnt;K++)
				(f[now][j]+=f[now^1][K]*t[k].a[K][j])%=mod;
		}
		return;
	}
	int mid = (l+r)/2;
	ask(ls,l,mid,x,y),ask(rs,mid+1,r,x,y);
}
signed main()
{
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>n>>q>>lim;
	for(int i = 0;i<=lim;i++)
		for(int j = i;j<=lim;j++)
			id[i][j] = ++cnt;
	for(int i = 1;i<=n;i++)
		cin>>a[i];
	build(1,1,n);
	while(q--)
	{
		int l,r;
		cin>>l>>r;
		for(int i = 1;i<=cnt;i++)
			f[0][i] = f[1][i] = 0;
		f[0][1] = 1,now = 0;
		ask(1,1,n,l,r);
		int ans = 0;
		for(int i = 1;i<=cnt;i++) (ans+=f[now][i])%=mod;
		cout<<ans<<'\n';
	}
	return 0;
}
```

---

## 作者：Sol1 (赞：1)

标算好强啊，给一个巨大麻烦的做法。

## 1 静态做法

由于 $t\leq 3$，所以考虑序列每一个位置加了多少，设该值为 $b_{[1,n]}$。

发现如果将 $b_{[1,n]}$ 的相同的连续段缩到一起，那么需要分开讨论的只有如下几种：

1. $(0),(1),2,1,2,(1),(0)$
1. $(0),(1),(2),3,(2),(1),(0)$
1. $(0),1,0,(1),2,(1),(0)$
1. $(0),(1),2,(1),0,1,(0)$
1. $(0),1,0,1,0,1,(0)$
1. $(0),1,0,1,(0)$
1. $(0),(1),2,(1),(0)$
1. $(0),1,(0)$
1. $0$

其中如果一个数加了括号就代表对应的段可以为空，否则就不能为空。

然后第 $9$ 种直接算，前 $8$ 种用分阶段的 DP 计算。

### 1.1 第 1 种

- $f_{i,0}$ 可以向 $f_{i+1,0/1/2}$ 转移；
- $f_{i,1}$ 可以向 $f_{i+1,1/2}$ 转移；
- $f_{i,2}$ 可以向 $f_{i+1,2/3}$ 转移；
- $f_{i,3}$ 可以向 $f_{i+1,3/4}$ 转移；
- $f_{i,4}$ 可以向 $f_{i+1,4/5/6}$ 转移；
- $f_{i,5}$ 可以向 $f_{i+1,5/6}$ 转移；
- $f_{i,6}$ 可以向 $f_{i+1,6}$ 转移。

转移到 $f_{i+1,0/1/2/3/4/5/6}$ 时分别乘上 $a_{i+1},a_{i+1}+1,a_{i+1}+2,a_{i+1}+1,a_{i+1}+2,a_{i+1}+1,a_{i+1}$。

边界 $f_{0,0}=1$，目标 $f_{n+1,6}$。（假定 $a_{n+1}=1$）

### 1.2 第 2 种

- $f_{i,0}$ 可以向 $f_{i+1,0/1/2/3}$ 转移；
- $f_{i,1}$ 可以向 $f_{i+1,1/2/3}$ 转移；
- $f_{i,2}$ 可以向 $f_{i+1,2/3}$ 转移；
- $f_{i,3}$ 可以向 $f_{i+1,3/4/5/6}$ 转移；
- $f_{i,4}$ 可以向 $f_{i+1,4/5/6}$ 转移；
- $f_{i,5}$ 可以向 $f_{i+1,5/6}$ 转移；
- $f_{i,6}$ 可以向 $f_{i+1,6}$ 转移。

转移到 $f_{i+1,0/1/2/3/4/5/6}$ 时分别乘上 $a_{i+1},a_{i+1}+1,a_{i+1}+2,a_{i+1}+3,a_{i+1}+2,a_{i+1}+1,a_{i+1}$。

边界 $f_{0,0}=1$，目标 $f_{n+1,6}$。

### 1.3 第 3 种

- $f_{i,0}$ 可以向 $f_{i+1,0/1}$ 转移；
- $f_{i,1}$ 可以向 $f_{i+1,1/2}$ 转移；
- $f_{i,2}$ 可以向 $f_{i+1,2/3/4}$ 转移；
- $f_{i,3}$ 可以向 $f_{i+1,3/4}$ 转移；
- $f_{i,4}$ 可以向 $f_{i+1,4/5/6}$ 转移；
- $f_{i,5}$ 可以向 $f_{i+1,5/6}$ 转移；
- $f_{i,6}$ 可以向 $f_{i+1,6}$ 转移。

转移到 $f_{i+1,0/1/2/3/4/5/6}$ 时分别乘上 $a_{i+1},a_{i+1}+1,a_{i+1},a_{i+1}+1,a_{i+1}+2,a_{i+1}+1,a_{i+1}$。

边界 $f_{0,0}=1$，目标 $f_{n+1,6}$。

### 1.4 第 4 种

- $f_{i,0}$ 可以向 $f_{i+1,0/1/2}$ 转移；
- $f_{i,1}$ 可以向 $f_{i+1,1/2}$ 转移；
- $f_{i,2}$ 可以向 $f_{i+1,2/3/4}$ 转移；
- $f_{i,3}$ 可以向 $f_{i+1,3/4}$ 转移；
- $f_{i,4}$ 可以向 $f_{i+1,4/5}$ 转移；
- $f_{i,5}$ 可以向 $f_{i+1,5/6}$ 转移；
- $f_{i,6}$ 可以向 $f_{i+1,6}$ 转移。

转移到 $f_{i+1,0/1/2/3/4/5/6}$ 时分别乘上 $a_{i+1},a_{i+1}+1,a_{i+1}+2,a_{i+1}+1,a_{i+1},a_{i+1}+1,a_{i+1}$。

边界 $f_{0,0}=1$，目标 $f_{n+1,6}$。

### 1.5 第 5 种

- $f_{i,0}$ 可以向 $f_{i+1,0/1}$ 转移；
- $f_{i,1}$ 可以向 $f_{i+1,1/2}$ 转移；
- $f_{i,2}$ 可以向 $f_{i+1,2/3}$ 转移；
- $f_{i,3}$ 可以向 $f_{i+1,3/4}$ 转移；
- $f_{i,4}$ 可以向 $f_{i+1,4/5}$ 转移；
- $f_{i,5}$ 可以向 $f_{i+1,5/6}$ 转移；
- $f_{i,6}$ 可以向 $f_{i+1,6}$ 转移。

转移到 $f_{i+1,0/1/2/3/4/5/6}$ 时分别乘上 $a_{i+1},a_{i+1}+1,a_{i+1},a_{i+1}+1,a_{i+1},a_{i+1}+1,a_{i+1}$。

边界 $f_{0,0}=1$，目标 $f_{n+1,6}$。

### 1.6 第 6 种

- $f_{i,0}$ 可以向 $f_{i+1,0/1}$ 转移；
- $f_{i,1}$ 可以向 $f_{i+1,1/2}$ 转移；
- $f_{i,2}$ 可以向 $f_{i+1,2/3}$ 转移；
- $f_{i,3}$ 可以向 $f_{i+1,3/4}$ 转移；
- $f_{i,4}$ 可以向 $f_{i+1,4}$ 转移。

转移到 $f_{i+1,0/1/2/3/4}$ 时分别乘上 $a_{i+1},a_{i+1}+1,a_{i+1},a_{i+1}+1,a_{i+1}$。

边界 $f_{0,0}=1$，目标 $f_{n+1,4}$。

### 1.7 第 7 种

- $f_{i,0}$ 可以向 $f_{i+1,0/1/2}$ 转移；
- $f_{i,1}$ 可以向 $f_{i+1,1/2}$ 转移；
- $f_{i,2}$ 可以向 $f_{i+1,2/3/4}$ 转移；
- $f_{i,3}$ 可以向 $f_{i+1,3/4}$ 转移；
- $f_{i,4}$ 可以向 $f_{i+1,4}$ 转移。

转移到 $f_{i+1,0/1/2/3/4}$ 时分别乘上 $a_{i+1},a_{i+1}+1,a_{i+1}+2,a_{i+1}+1,a_{i+1}$。

边界 $f_{0,0}=1$，目标 $f_{n+1,4}$。

### 1.8 第 8 种

- $f_{i,0}$ 可以向 $f_{i+1,0/1}$ 转移；
- $f_{i,1}$ 可以向 $f_{i+1,1/2}$ 转移；
- $f_{i,2}$ 可以向 $f_{i+1,2}$ 转移。

转移到 $f_{i+1,0/1/2}$ 时分别乘上 $a_{i+1},a_{i+1}+1,a_{i+1}$。

边界 $f_{0,0}=1$，目标 $f_{n+1,2}$。

---

目标是：

- 如果 $t=1$，就是第 $[8,9]$ 种的答案求和。
- 如果 $t=2$，就是第 $[6,9]$ 种的答案求和。
- 如果 $t=3$，就是第 $[1,9]$ 种的答案求和。

如此 DP，复杂度为 $O(n)$，可以过掉 $30$ 分。

## 2 动态做法

就是直接把这个阶段 DP 动态化，转移写成矩阵的形式放到线段树上面维护即可。

注意要用到官方题解中提到的向量乘矩阵优化常数。

这个垃圾做法的复杂度虽然也是 $O(n+q\log n)$，但是常数比标算大概大了 3 倍。。。

把矩乘的过程循环展开了一层就可以跑得跟标算差不多快。

~~以下是壮观的 9kb 代码，不会真有人想看吧~~

```cpp
#include <iostream>
#include <cmath>
#include <cstring>
#include <cstdio>
using namespace std;

#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
char buf[1 << 21], *p1 = buf, *p2 = buf;

inline int qread() {
	register char c = getchar();
	register int x = 0, f = 1;
	while (c < '0' || c > '9') {
		if (c == '-') f = -1;
		c = getchar();
	}
	while (c >= '0' && c <= '9') {
		x = (x << 3) + (x << 1) + c - 48;
		c = getchar();
	}
	return x * f;
}

inline int Abs(const int& x) {return (x > 0 ? x : -x);}
inline int Max(const int& x, const int& y) {return (x > y ? x : y);}
inline int Min(const int& x, const int& y) {return (x < y ? x : y);}

const int mod = 10007;

struct Matrix8 {
	int f1[7][7], f2[7][7], f3[7][7], f4[7][7], f5[7][7], f6[5][5], f7[5][5], f8[3][3];
	inline Matrix8 operator * (const Matrix8& b) const {
		Matrix8 res;
		for (int i = 0;i < 7;i++) {
			for (int j = 0;j < 7;j++) {
				res.f1[i][j] = (f1[i][0] * b.f1[0][j] + f1[i][1] * b.f1[1][j] + f1[i][2] * b.f1[2][j] + f1[i][3] * b.f1[3][j] + f1[i][4] * b.f1[4][j] + f1[i][5] * b.f1[5][j] + f1[i][6] * b.f1[6][j]) % mod;
				res.f2[i][j] = (f2[i][0] * b.f2[0][j] + f2[i][1] * b.f2[1][j] + f2[i][2] * b.f2[2][j] + f2[i][3] * b.f2[3][j] + f2[i][4] * b.f2[4][j] + f2[i][5] * b.f2[5][j] + f2[i][6] * b.f2[6][j]) % mod;
				res.f3[i][j] = (f3[i][0] * b.f3[0][j] + f3[i][1] * b.f3[1][j] + f3[i][2] * b.f3[2][j] + f3[i][3] * b.f3[3][j] + f3[i][4] * b.f3[4][j] + f3[i][5] * b.f3[5][j] + f3[i][6] * b.f3[6][j]) % mod;
				res.f4[i][j] = (f4[i][0] * b.f4[0][j] + f4[i][1] * b.f4[1][j] + f4[i][2] * b.f4[2][j] + f4[i][3] * b.f4[3][j] + f4[i][4] * b.f4[4][j] + f4[i][5] * b.f4[5][j] + f4[i][6] * b.f4[6][j]) % mod;
				res.f5[i][j] = (f5[i][0] * b.f5[0][j] + f5[i][1] * b.f5[1][j] + f5[i][2] * b.f5[2][j] + f5[i][3] * b.f5[3][j] + f5[i][4] * b.f5[4][j] + f5[i][5] * b.f5[5][j] + f5[i][6] * b.f5[6][j]) % mod;
			}
		}
		for (int i = 0;i < 5;i++) {
			for (int j = 0;j < 5;j++) {
				res.f6[i][j] = (f6[i][0] * b.f6[0][j] + f6[i][1] * b.f6[1][j] + f6[i][2] * b.f6[2][j] + f6[i][3] * b.f6[3][j] + f6[i][4] * b.f6[4][j]) % mod;
				res.f7[i][j] = (f7[i][0] * b.f7[0][j] + f7[i][1] * b.f7[1][j] + f7[i][2] * b.f7[2][j] + f7[i][3] * b.f7[3][j] + f7[i][4] * b.f7[4][j]) % mod;
			}
		}
		for (int i = 0;i < 3;i++) {
			for (int j = 0;j < 3;j++) {
				res.f8[i][j] = (f8[i][0] * b.f8[0][j] + f8[i][1] * b.f8[1][j] + f8[i][2] * b.f8[2][j]) % mod;
			}
		}
		return res;
	}
};
struct Result8 {
	int f1[7], f2[7], f3[7], f4[7], f5[7], f6[5], f7[5], f8[3];
	Result8() {
		memset(f1, 0, sizeof(f1));
		memset(f2, 0, sizeof(f2));
		memset(f3, 0, sizeof(f3));
		memset(f4, 0, sizeof(f4));
		memset(f5, 0, sizeof(f5));
		memset(f6, 0, sizeof(f6));
		memset(f7, 0, sizeof(f7));
		memset(f8, 0, sizeof(f8));
	}
	inline Result8 operator * (const Matrix8& b) const {
		Result8 res;
		for (int j = 0;j < 7;j++) {
			res.f1[j] = (f1[0] * b.f1[0][j] + f1[1] * b.f1[1][j] + f1[2] * b.f1[2][j] + f1[3] * b.f1[3][j] + f1[4] * b.f1[4][j] + f1[5] * b.f1[5][j] + f1[6] * b.f1[6][j]) % mod;
			res.f2[j] = (f2[0] * b.f2[0][j] + f2[1] * b.f2[1][j] + f2[2] * b.f2[2][j] + f2[3] * b.f2[3][j] + f2[4] * b.f2[4][j] + f2[5] * b.f2[5][j] + f2[6] * b.f2[6][j]) % mod;
			res.f3[j] = (f3[0] * b.f3[0][j] + f3[1] * b.f3[1][j] + f3[2] * b.f3[2][j] + f3[3] * b.f3[3][j] + f3[4] * b.f3[4][j] + f3[5] * b.f3[5][j] + f3[6] * b.f3[6][j]) % mod;
			res.f4[j] = (f4[0] * b.f4[0][j] + f4[1] * b.f4[1][j] + f4[2] * b.f4[2][j] + f4[3] * b.f4[3][j] + f4[4] * b.f4[4][j] + f4[5] * b.f4[5][j] + f4[6] * b.f4[6][j]) % mod;
			res.f5[j] = (f5[0] * b.f5[0][j] + f5[1] * b.f5[1][j] + f5[2] * b.f5[2][j] + f5[3] * b.f5[3][j] + f5[4] * b.f5[4][j] + f5[5] * b.f5[5][j] + f5[6] * b.f5[6][j]) % mod;
		}
		for (int j = 0;j < 5;j++) {
			res.f6[j] = (f6[0] * b.f6[0][j] + f6[1] * b.f6[1][j] + f6[2] * b.f6[2][j] + f6[3] * b.f6[3][j] + f6[4] * b.f6[4][j]) % mod;
			res.f7[j] = (f7[0] * b.f7[0][j] + f7[1] * b.f7[1][j] + f7[2] * b.f7[2][j] + f7[3] * b.f7[3][j] + f7[4] * b.f7[4][j]) % mod;
		}
		for (int j = 0;j < 3;j++) {
			res.f8[j] = (f8[0] * b.f8[0][j] + f8[1] * b.f8[1][j] + f8[2] * b.f8[2][j]) % mod;
		}
		return res;
	}
};
int idx;
struct Segtree {
	Matrix8 nd[400055];
	inline void Build(int p, int pl, int pr, int *a, int n) {
		if (pl == pr) {
			if (pr == n) idx = p;
			nd[p].f1[0][0] = a[pl];
			nd[p].f1[0][1] = a[pl] + 1;
			nd[p].f1[0][2] = a[pl] + 2;
			nd[p].f1[1][1] = a[pl] + 1;
			nd[p].f1[1][2] = a[pl] + 2;
			nd[p].f1[2][2] = a[pl] + 2;
			nd[p].f1[2][3] = a[pl] + 1;
			nd[p].f1[3][3] = a[pl] + 1;
			nd[p].f1[3][4] = a[pl] + 2;
			nd[p].f1[4][4] = a[pl] + 2;
			nd[p].f1[4][5] = a[pl] + 1;
			nd[p].f1[4][6] = a[pl];
			nd[p].f1[5][5] = a[pl] + 1;
			nd[p].f1[5][6] = a[pl];
			nd[p].f1[6][6] = a[pl];

			nd[p].f2[0][0] = a[pl];
			nd[p].f2[0][1] = (a[pl] + 1);
			nd[p].f2[0][2] = (a[pl] + 2);
			nd[p].f2[0][3] = (a[pl] + 3);
			nd[p].f2[1][1] = (a[pl] + 1);
			nd[p].f2[1][2] = (a[pl] + 2);
			nd[p].f2[1][3] = (a[pl] + 3);
			nd[p].f2[2][2] = (a[pl] + 2);
			nd[p].f2[2][3] = (a[pl] + 3);
			nd[p].f2[3][3] = (a[pl] + 3);
			nd[p].f2[3][4] = (a[pl] + 2);
			nd[p].f2[3][5] = (a[pl] + 1);
			nd[p].f2[3][6] = a[pl];
			nd[p].f2[4][4] = (a[pl] + 2);
			nd[p].f2[4][5] = (a[pl] + 1);
			nd[p].f2[4][6] = a[pl];
			nd[p].f2[5][5] = (a[pl] + 1);
			nd[p].f2[5][6] = a[pl];
			nd[p].f2[6][6] = a[pl];

			nd[p].f3[0][0] = a[pl];
			nd[p].f3[0][1] = (a[pl] + 1);
			nd[p].f3[1][1] = (a[pl] + 1);
			nd[p].f3[1][2] = a[pl];
			nd[p].f3[2][2] = a[pl];
			nd[p].f3[2][3] = (a[pl] + 1);
			nd[p].f3[2][4] = (a[pl] + 2);
			nd[p].f3[3][3] = (a[pl] + 1);
			nd[p].f3[3][4] = (a[pl] + 2);
			nd[p].f3[4][4] = (a[pl] + 2);
			nd[p].f3[4][5] = (a[pl] + 1);
			nd[p].f3[4][6] = a[pl];
			nd[p].f3[5][5] = (a[pl] + 1);
			nd[p].f3[5][6] = a[pl];
			nd[p].f3[6][6] = a[pl];

			nd[p].f4[0][0] = a[pl];
			nd[p].f4[0][1] = (a[pl] + 1);
			nd[p].f4[0][2] = (a[pl] + 2);
			nd[p].f4[1][1] = (a[pl] + 1);
			nd[p].f4[1][2] = (a[pl] + 2);
			nd[p].f4[2][2] = (a[pl] + 2);
			nd[p].f4[2][3] = (a[pl] + 1);
			nd[p].f4[2][4] = a[pl];
			nd[p].f4[3][3] = (a[pl] + 1);
			nd[p].f4[3][4] = a[pl];
			nd[p].f4[4][4] = a[pl];
			nd[p].f4[4][5] = (a[pl] + 1);
			nd[p].f4[5][5] = (a[pl] + 1);
			nd[p].f4[5][6] = a[pl];
			nd[p].f4[6][6] = a[pl];

			nd[p].f5[0][0] = a[pl];
			nd[p].f5[0][1] = (a[pl] + 1);
			nd[p].f5[1][1] = (a[pl] + 1);
			nd[p].f5[1][2] = a[pl];
			nd[p].f5[2][2] = a[pl];
			nd[p].f5[2][3] = (a[pl] + 1);
			nd[p].f5[3][3] = (a[pl] + 1);
			nd[p].f5[3][4] = a[pl];
			nd[p].f5[4][4] = a[pl];
			nd[p].f5[4][5] = (a[pl] + 1);
			nd[p].f5[5][5] = (a[pl] + 1);
			nd[p].f5[5][6] = a[pl];
			nd[p].f5[6][6] = a[pl];

			nd[p].f6[0][0] = a[pl];
			nd[p].f6[0][1] = (a[pl] + 1);
			nd[p].f6[1][1] = (a[pl] + 1);
			nd[p].f6[1][2] = a[pl];
			nd[p].f6[2][2] = a[pl];
			nd[p].f6[2][3] = (a[pl] + 1);
			nd[p].f6[3][3] = (a[pl] + 1);
			nd[p].f6[3][4] = a[pl];
			nd[p].f6[4][4] = a[pl];

			nd[p].f7[0][0] = a[pl];
			nd[p].f7[0][1] = (a[pl] + 1);
			nd[p].f7[0][2] = (a[pl] + 2);
			nd[p].f7[1][1] = (a[pl] + 1);
			nd[p].f7[1][2] = (a[pl] + 2);
			nd[p].f7[2][2] = (a[pl] + 2);
			nd[p].f7[2][3] = (a[pl] + 1);
			nd[p].f7[2][4] = a[pl];
			nd[p].f7[3][3] = (a[pl] + 1);
			nd[p].f7[3][4] = a[pl];
			nd[p].f7[4][4] = a[pl];

			nd[p].f8[0][0] = a[pl];
			nd[p].f8[0][1] = (a[pl] + 1);
			nd[p].f8[1][1] = (a[pl] + 1);
			nd[p].f8[1][2] = a[pl];
			nd[p].f8[2][2] = a[pl];
			return;
		}
		int mid = pl + pr >> 1;
		Build(p << 1, pl, mid, a, n);
		Build(p << 1 | 1, mid + 1, pr, a, n);
		nd[p] = nd[p << 1] * nd[p << 1 | 1];
	}
	inline void Query(int p, int pl, int pr, int l, int r, Result8& ans) {
		if (pl == l && pr == r) {
			ans = ans * nd[p];
			return;
		}
		int mid = pl + pr >> 1;
		if (mid >= r) Query(p << 1, pl, mid, l, r, ans);
		else if (mid + 1 <= l) Query(p << 1 | 1, mid + 1, pr, l, r, ans);
		else {
			Query(p << 1, pl, mid, l, mid, ans);
			Query(p << 1 | 1, mid + 1, pr, mid + 1, r, ans);
		}
	}
};
Segtree sgt;
int n, q, t, a[100005], prod[100005], iprod[100005];

inline void Read() {
	n = qread(); q = qread(); t = qread();
	iprod[0] = prod[0] = 1;
	for (int i = 1;i <= n;i++) prod[i] = prod[i - 1] * (a[i] = qread()) % mod;
	a[++n] = 1;
	prod[n] = prod[n - 1];
}

inline int Power(int x, int y) {
	int ans = 1;
	while (y) {
		if (y & 1) ans = ans * x % mod;
		x = x * x % mod;
		y >>= 1;
	}
	return ans;
}

inline void Prefix() {
	sgt.Build(1, 1, n, a, n);
	iprod[n] = Power(prod[n], mod - 2);
	for (int i = n - 1;i >= 1;i--) iprod[i] = iprod[i + 1] * a[i + 1] % mod;
}

inline void Solve() {
	while (q--) {
		int l = qread(), r = qread();
		Result8 res;
		if (t >= 1) res.f8[0] = 1;
		if (t >= 2) res.f7[0] = res.f6[0] = 1;
		if (t >= 3) res.f5[0] = res.f4[0] = res.f3[0] = res.f2[0] = res.f1[0] = 1;
		sgt.Query(1, 1, n, l, r, res);
		res = res * sgt.nd[idx];
		printf("%d\n", (res.f1[6] + res.f2[6] + res.f3[6] + res.f4[6] + res.f5[6] + res.f6[4] + res.f7[4] + res.f8[2] + prod[r] * iprod[l - 1]) % mod);
	}
}

int main() {
	Read();
	Prefix();
	Solve();
	#ifdef CFA_44
	while (1);
	#endif
	return 0;
}
```









---

## 作者：ask_silently (赞：0)

### [题目传送门](https://www.luogu.comproblem/P7576)

## 题目大意

给定一个序列 $a$，每次询问一段区间 $l$ 至 $r$，可以进行 $0$ 至 $t$ 次操作，每次选定一个区间将其所有数 $+1$。给出最终序列所有数乘积之和，对 $10007$ 取模。

## 思路分析

可以先考虑暴力 $O(nq)$ 如何做。假设我们现在已经知道操作序列 $c$，即每个数加了多少次，那么可以求出总操作次数。即 $\sum_{i=1}^{n-1} \max(0,c_{i+1}-c_i)$，这里详见 [P1969 [NOIP 2013 提高组] 积木大赛](https://www.luogu.com.cn/problem/P1969)。

由此，可以设计出一个状态 $dp_{i,j,k}$ 为前 $i$ 个数，总操作次数为 $j$，$c_i$ 为 $k$。转移是显然的：

$$dp_{i,j,k}=(a_i+k)\times(\sum_{l=0}^{k-1} dp_{i-1,j-k+l,l} + \sum_{l=k}^n dp_{i-1,j,l})$$

初始值：$dp_{0,0,0}=1$。

时间复杂度 $O(nq \times (t+1)^2)$。

可以尝试初步优化，发现 $k \le j$，则有用的信息总数为 $\frac{(t+1) \times (t+2)}{2}$，可以估算成 $t^2$。

接下来考虑如何优化掉 $n$。发现如果知道了 $dp_{i-1}$ 的所有信息，那么 $dp_i$ 是可以通过固定的几个 $dp_{i-1}$ 值相加得到的。所以考虑矩阵乘法，答案即为 $l$ 至 $r$ 的所有矩阵乘在一起，然后乘上初始矩阵，区间乘可以用线段树维护。为了方便维护，将 $dp_{i,j,k}$ 映射到 $dp_{i,j \times (t+1)+k}$。

显然可以预处理出来不同的 $t$ 值所对应的矩阵，然后乘上 $a_i+k$ 即可，加上建树的时间复杂度为 $O(n \times t^6)$。

然而查询的时间复杂度是 $q \log n \times t^6$，很明显会超时。但其实不需要线段树两个矩阵相乘，只需要一个初始行矩阵就可以，这样乘法的复杂度就降到了 $t^4$。

所以总时间复杂度大概是 $O(n \times t^6 + q \log n \times t^4)$，这个时间复杂度可以通过该题。

## ACcode


```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define INT_MAX (int)(1e18)
#define mid (l+r>>1)

const int N=1e5+10;
const int mod=10007;

int n,q,k;
int a[N],dp[N][16];

int len[4]={0,2,5,9};

int Ju[3][10][10]=
{
	{
		{1,0,1},
		{0,1,0},
		{0,1,1}
	},
	{
		{1,0,1,0,0,1},
		{0,1,0,0,1,0},
		{0,1,1,0,0,1},
		{0,0,0,1,0,0},
		{0,0,0,1,1,0},
		{0,0,0,1,1,1}
	},
	{
		{1,0,1,0,0,1,0,0,0,1},
		{0,1,0,0,1,0,0,0,1,0},
		{0,1,1,0,0,1,0,0,0,1},
		{0,0,0,1,0,0,0,1,0,0},
		{0,0,0,1,1,0,0,0,1,0},
		{0,0,0,1,1,1,0,0,0,1},
		{0,0,0,0,0,0,1,0,0,0},
		{0,0,0,0,0,0,1,1,0,0},
		{0,0,0,0,0,0,1,1,1,0},
		{0,0,0,0,0,0,1,1,1,1}
	}
};

struct node{
	int ju[10][10];
	
	void New_Node(int val){
		int las=0,nxt=1,add=2;
		for(int j=0;j<=len[k];j++){
			for(int i=0;i<=len[k];i++){
				if(j==nxt) las=nxt,nxt+=add,add++;
				ju[i][j]=Ju[k-1][i][j]*(val+j-las);
			}
		}
	}
}tr[N<<2],chu,sum;

inline int read(){
	int t=0,f=1;
	register char c=getchar();
	while(c<'0'||c>'9') f=(c=='-')?(-1):(f),c=getchar();
	while(c>='0'&&c<='9') t=(t<<3)+(t<<1)+(c^48),c=getchar();
	return t*f;
}

//将三维 dp i,j,k 映射到 i,j*(t+1)+k 上 

/*
30pts
int solve1(int L,int R){
	for(int i=0;i<=3;i++)
		for(int j=0;j<=3;j++)
			dp[L-1][i*(k+1)+j]=0;
	dp[L-1][0]=1;
	for(int i=L;i<=R;i++)
		for(int j=0;j<=k;j++)
			for(int l=0;l<=j;l++){
				dp[i][j*(k+1)+l]=0;
				cout<<"hou:"<<j*(k+1)+l<<"\n";
				for(int ls=0;ls<=j;ls++)
					if(ls<l) dp[i][j*(k+1)+l]+=dp[i-1][(j-l+ls)*(k+1)+ls],cout<<(j-l+ls)*(k+1)+ls<<" ";
					else dp[i][j*(k+1)+l]+=dp[i-1][j*(k+1)+ls],cout<<j*(k+1)+ls<<" ";
				dp[i][j*(k+1)+l]=dp[i][j*(k+1)+l]%mod*(a[i]+l)%mod;
				cout<<"\n";
			}
	int res=0;
	for(int i=0;i<=k;i++)
		for(int j=0;j<=i;j++) res=(res+dp[R][i*(k+1)+j])%mod;
	return res;
}
*/

node operator *(const node &x,const node &y){
	node z;
	for(int i=0;i<=len[k];i++)
		for(int j=0;j<=len[k];j++){
			z.ju[i][j]=0;
			for(int l=0;l<=len[k];l++) z.ju[i][j]+=x.ju[i][l]*y.ju[l][j];
			z.ju[i][j]%=mod;
		}
	return z;
}

void pushup(int bian){
	tr[bian]=tr[bian<<1]*tr[bian<<1|1];
}

void build(int bian,int l,int r){
	if(l==r){tr[bian].New_Node(a[l]);return;}
	build(bian<<1,l,mid);
	build(bian<<1|1,mid+1,r);
	pushup(bian);
}

void query(int bian,int l,int r,int L,int R){
	if(L<=l&&R>=r){
		for(int j=0;j<=len[k];j++){
			sum.ju[0][j]=0;
			for(int l=0;l<=len[k];l++)
				sum.ju[0][j]+=chu.ju[0][l]*tr[bian].ju[l][j];
			sum.ju[0][j]%=mod;
		}
		for(int i=0;i<=len[k];i++) chu.ju[0][i]=sum.ju[0][i];
		return;
	}
	if(L<=mid) query(bian<<1,l,mid,L,R);
	if(R>mid) query(bian<<1|1,mid+1,r,L,R);
}

int solve(int L,int R){
	chu.ju[0][0]=1;
	for(int i=1;i<=len[k];i++) chu.ju[0][i]=0;
	query(1,1,n,L,R);
	int res=0;
	for(int i=0;i<=len[k];i++) res=res+chu.ju[0][i];
	return res%mod;
}

void debug(int bian){
	for(int i=0;i<=len[k];i++){
		for(int j=0;j<=len[k];j++)
			cout<<tr[bian].ju[i][j]<<" ";
		cout<<"\n";
	}
	cout<<"\n";
}

signed main(){
	n=read(),q=read(),k=read();
	for(int i=1;i<=n;i++) a[i]=read();
	build(1,1,n);
	for(int i=1;i<=q;i++){
		int l=read(),r=read();
		cout<<solve(l,r)<<"\n";
	} 
	return 0;
}


```

---


# 数列

## 题目描述

给定一个长度是 $n$ 的数列 $A$ ，我们称一个数列是完美的，当且仅当对于其任意子段的和都是正的。

现在你有一个操作可以改变数列，选择一个区间 $[l,r]$ 满足 $\sum\limits_{i = l}^r A_i < 0$ ,其中 $1 < l \le r < n$。

令 $S = \sum\limits_{i = l}^r A_i$ ，对于 $A_{l - 1}$ 和 $A_{r + 1}$ 分别加上 $S$，$A_l$ 和 $A_r$ 分别减去 $S$（如果 $l = r$ 就减两次）。问最少几次这样的操作使得最终数列是完美的。

## 说明/提示

### 样例解释

首先选择区间 $[2,4]$，之后数列变成 $1,9-4,7,50$，然后选择 $[3,3]$，数列变成 $1,5,4,3,50$

### 限制与约定

对于 $20\%$ 的数据，满足 $1 \le N \le 5$ ;

对于 $100\%$ 的数据，满足 $1 \le N \le 10^5$ ;  $1 \le |A_i| < 2^{31}$

## 样例 #1

### 输入

```
5
13
-3 
-4
-5
62```

### 输出

```
2```

# 题解

## 作者：人殇物已非 (赞：20)

### 2021.11.7 update:
补充了被hack的问题。(格式可能略有些不符合新版规定，看在本来是一楼题解的份上放我一马吧呜呜）

对于一个区间 $[x,y]$ ,设这个区间的总和 $\sum\limits_{i=x}^ya[i]$ 设为 $S$ ;

那么我们在前缀和（设为 $sum[i]$ ）的意义上考虑到原操作其实就是$sum[x-1]+=S$ , $sum[x]+S-S$ , $sum[y]-=S$ , $sum[y+1]+S-S$ 。

而且我们注意到，本来就有 $sum[x-1]+S==sum[y]$ ，所以观察到其实原操作只是单纯的交换了一下 $sum[x-1]$ 和 $sum[y]$ 而已，而且这个 $[x,y]$ 区间任意选择，故原题已经可以改为：

#### 给一个前缀和序列，可以在其中任意交换2个数，最后让这个序列变为单调递增的。

#### 注意：在前缀和序列里不能有负数和相等的，若有就输出-1（自己证吧，我懒癌犯了。。）

对于这个新问题，我们先离散化，然后找“循环节”，就可以了。

#### 不知道循环节的小伙伴看这里（其他人可以走了）：
对于一个数列，我们想把它变成单调递增的该最少交换几次呢？

我们知道，若是交换必须是相邻的就是一道逆序对水题了（P1774）,而现在任意交换，那么我们这么考虑：

采用贪心的思想：每个数都有一个自己的位置，那么我们就每当遇到一个位置上面的数不正确，就把应该在这个位置的数和当前这个位置的数互换。这样可以想到，最多换 $n$ 次（好吧是 $n-1$ ）我们就可以得到正确的数列了,而其实呢，你每次换的时候很可能不止满足了当前位置的数正确了，另一个位置的数可能刚刚好“碰对了”，所以最好的结果次数就会减少，最坏情况下$n-1$次的最后一次一定会换一次满足两个位置，这也就是一个循环节。

而事实上，我们在换的时候若是每次都可以满足两个位置（太好了！），那么就是 $n/2$ 次了，这时候其实是两个数一个循环节。若是3个数用2次交换满足了，（一次普通，一次满足2个位置），那么这3个数就是一个循环节，**每个循环节的交换次数为循环节的长度-1。**

所以我们要尽可能的找更多的循环节，那怎么办呢？（其实上面那个第一次的贪心的思想就是正解。。）

我们发现，**若是有3个数成循环节，那么我就算把其中的数的位置换了，也不会破坏这个循环节**（交换是在数列里任意两个数）,所以，其实我不用刻意去找循环节（它会自己来找你。。。），**我只要每次都保证我的每一步交换都至少有一个位置上的数正确了，最后剩下的数的循环节一定还能使用，从而减小交换次数。**

所以，说了这么半天原来
### 这么水？？！！

#### 希望大家听懂了。
tip:其实那个贪心的交换不好实现，（逃

code：
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[100010],p[100010],s[100010],stmp[100010];
inline bool cmp(int x,int y){
    return s[x]<s[y];
}
inline void halt(){
    puts("-1"); exit(0);
}
int main(){
    int n,mx=0;
    cin>>n;
    for(int i=1;i<=n;i++){
        scanf("%d",&a[i]);
        p[i]=i;s[i]=s[i-1]+a[i],stmp[i]=s[i];
        mx=stmp[n];
    }
    sort(stmp+1,stmp+1+n);
    if(stmp[1]<=0 || stmp[n]!=mx) halt();
    for(int i=1;i<n;i++) if(stmp[i]==stmp[i+1]) halt();
    sort(p+1,p+1+n,cmp);//该排在第i的数的位置为p[i] 
    for(int i=1;i<=n;i++) s[p[i]]=i;//成功离散化 
    int ans=n;//不能是n-1哦
    for(int i=1;i<=n;i++){
        if(s[i]==i) ans--;
        else{
            swap(p[s[i]],p[i]),swap(s[p[s[i]]],s[i]);
        }//这里的两个swap自己找一组数去模拟着理解,其实实现的就是上面那个贪心
    }
    cout<<ans<<endl;
    return 0;
}
```

---

## 作者：wheneveright (赞：11)

[link](https://www.luogu.com.cn/problem/P1667)

## 分析

以下用 $a$ 表示原数组，用 $s$ 表示原数组的前缀和数组，用 $x'$ 表示操作前的 $x$ 数组。

因为要对区间操作所以考虑对原数组取前缀和。

考虑当前操作 $l, r$：

$sum = s'_r - s_{l - 1}$

则 $a$ 的变化为：

$a_l \to a'_l - sum$

$a_r \to a'_r - sum$

$a_{l - 1} \to a'_{l - 1} + sum$

$a_{r + 1} \to a'_{r + 1} + sum$

则 $s$ 的变化为：

$s_{l - 1} \to s'_{l - 1} + sum$

$s_l \to s'_l - sum + sum = s'_l$

$s_r \to s'_r - sum$

$s_{r + 1} \to s'_{r + 1} + sum - sum = s'_{r + 1}$

可以发现 $s_l, s_{r + 1}$ 没有发生变化。

将 $sum = s'_r - s'_{l - 1}$ 带入得：

$s_{l - 1} \to s'_{l - 1} + s'_r - s'_{l - 1} = s'_r$

$s_r \to s'_r - s'_r + s'_{l - 1} = s'_{l - 1}$

所以操作一次 $l, r$ 相当于将 $a_{l - 1}, a_r$ 交换。

那么做法就出来了，先将 $a$ 取前缀和，通过最少交换使得 $s$ 单调升即可。

如何确定交换步骤？

离散化后 $s_i$ 就是 $i$ 结束的位置，所以只要将 $s_i$ 与 $s_{s_i}$ 交换即可。

## 无解情况

### $s$ 中出现相同的数

根据这题的普遍做法，将原数组取前缀和后使其单调升才能使交换后的原序列全是正。

那么如果 $s$ 中出现相同的数，那么无论怎么交换都是不能做到使其单调升的。

### $s$ 中出现负数

因为在结束时 $s$ 数组是单调升的，根据前缀和的定义：$s_1 = a_1$ 可以得出结束时 $a_1$ 的值。

那么如果 $s$ 中有负数的话，排序后的 $s_1$ 一定为负数，相对应的 $a_1$ 就是负数，不符合题意。

### $s_n \neq \max (s)$

因为每次操作的 $l, r$ 的条件为 $1 < l \le r < n$。而前缀和交换时是交换 $s_{l-1}$ 和 $s_r$。

不难发现第 $n$ 个位置是无法被交换到的，那么如果最后一位不是最大，那么无法将其交换到相对应的位置。

## 代码

```cpp
# include <bits/stdc++.h>
using namespace std;

const int maxn = 100005;

int n, m, res;
long long s[maxn], a[maxn]; bool check;
unordered_map < long long, bool > mp;

int main () {
	cin >> n;
	for (int i = 1; i <= n; i++) cin >> s[i], s[i] += s[i - 1];
	for (int i = 1; i <= n; i++) (check = check || (s[i] < 0) || mp[s[i]] || s[i] > s[n]), mp[a[i] = s[i]] = true;
	if (check) { puts ("-1"); return 0; } sort (a + 1, a + 1 + n); m = unique (a + 1, a + 1 + n) - a - 1;
	for (int i = 1; i <= n; i++) s[i] = lower_bound (a + 1, a + 1 + m, s[i]) - a;
	for (int i = 1; i <= n; i++) while (s[i] != i) res++, swap (s[i], s[s[i]]);
	cout << res << endl;
	return 0;
}
```

---

## 作者：zxtikes (赞：8)

### 前言

实际上这题已经做完很久了，突然想起来这道题。

这实际上是一道很有意义的题目，考察了一种将抽象问题转化为具体操作的能力。

那我们废话不多说了，开始这道题目的分析：


------------
### 题意分析

相信大家都已经先看过题面了，接下来我对题目做简化分析，也就是把数学符号转化为文字。

每次操作会选择一个区间 $[l,r]$，且 $l, r \in (1, n)$。对它做如下操作：

如果区间和（令其为 $S$）小于零，左端点左边的数加上 $S$，右端点右边的数加上 $S$。并且左端点和右端点都减去 $S$。

其实我们分析到这一步，仍然对我们解题帮助很少，面对这种题，我们仍需要对于题目中所给的样例做出分析。



------------

### 题解思路

首先题目中提到，完美的序列连续子段和都为正，所以我们需要处理前缀和 $sum$。

就能得到：

$$
(\sum_{i = l}^{r}{A_i})=sum[r]-sum[l-1]
$$

这是很基础的处理前缀和的操作，大家应该都会的。

对于样例：

```
13 -3 -4 -5 62
```

处理它的前缀和，前缀和序列为：

```
13 10 6 1 63
```

根据我们上面求连续子段和的思路，要使得任意子段和为正，就必须保证它的前缀和序列是严格上升。

既然下来按照样例，他会对区间 $[2,4]$ 进行一次操作,变成了如下：

```
1 9 -4 7 50
```

处理他的前缀和序列：

```
1 10 6 13 63
```

**仔细观察** 这样的一次操作对于他的前缀和序列的改变是什么？

显然，我们发现序列中的 第 $1$，$4$ 发生了调换。再观察，操作是对 $[2,4]$ 进行的，显然，每次操作，可以转化为对前缀和序列中第 $l-1$ 和 $r$ 进行调换。

我们的目标就是讲前缀和序列变成一个 **严格上升子序列**。

最后我们注意一些细节：
    
1. 原前缀和序列中不能出现负数，因为出现负数，则永远构造不出目标序列。

2. 原前缀和序列中不能出现相同的数，因为若出现，则只能构造出非严格上升子序列，而我们目标是严格上升子序列。

3. 注意到操作区间区间左端点不能取到 $n$ ，所以我们无法对前缀和序列的最后一个数进行操作，所以必须保证 $sum[n]$ 最大。

4. 我们用离散化的方式，来构造我们的目标序列。



------------
### 代码展示


接下来展示一下丑陋的代码：


```cpp
#include<bits/stdc++.h>
#define ll long long
#define inf 1e9
#define rep(i,l,r) for(register int i=l;i<=r;++i)
#define per(i,r,l) for(register int i=r;i>=l;--i)
using namespace std;
const int N=1e5+5;

int n;
int a[N];
int s1[N],pos[N],tmp[N];
int maxn,max_num;
int ans;
inline bool exist(){//处理是否有解 
	sort(tmp+1,tmp+n+1);
	if(max_num!=n||tmp[1]<0)return true;
	rep(i,2,n)
	    if(tmp[i]==tmp[i-1])
	        return true;
	return false;
}
inline bool cmp(int a,int b){return s1[a]<s1[b];}//离散化的函数 
int main(){
	scanf("%d",&n);
	rep(i,1,n){
		scanf("%d",&a[i]);
		pos[i]=i;
		tmp[i]=s1[i]=s1[i-1]+a[i];//处理前缀和序列和目标序列 
		if(maxn<=tmp[i])maxn=tmp[i],max_num=i;
	}
	//判断是否有解，以及离散化 
	if(exist()){printf("-1\n");return 0;}
	sort(pos+1,pos+n+1,cmp);
	rep(i,1,n)s1[pos[i]]=i;
	//用贪心的思路，只要和目标序列不同，就调换 
	rep(i,1,n){
		if(s1[i]!=i){
			//这两步调换，实际上是同时改变序列中数的位置和值
			//比较难以理解，大家可以多加思考 
			swap(pos[s1[i]],pos[i]);
			swap(s1[pos[s1[i]]],s1[i]);
			ans++;
		}
	}
	printf("%d\n",ans);
	return 0;
}
```


------------

### 结尾

最后提一句，这道题是一道很有思维含量的题，如果大家还想练习类似的题。我可以推荐大家一道题

[NOIP2021 方差](https://www.luogu.com.cn/problem/P7962)

这道题比较难，量力而行吧。


------------
### UPDATE
已经重新修改 $\LaTeX$ 公式 + 标点


---

## 作者：RyanCh (赞：3)

题意题目说的很明显，我们直接开始推导。

我们凭题意考虑对于该数列中每个位置 $i$ 的前缀和 $sum_i$ ，其中我们设 $x = \sum\limits_{i = l}^r A_i$ ，那么我们可以得出推导如下：

- $x = sum_r - sum_{l - 1}$
- $sum_{l - 1} = sum_{l- 1} + x = sum_r$
- $sum_l = sum_l - x + x = sum_l$
- $sum_r = sum_r - x = sum_{l - 1}$
- $sum_{r + 1} = sum_{r - 1} + x - x = sum_{r + 1}$

我们观察到，其实就是将 $sum_r$ 与 $sum_{l - 1}$ 交换，所以，我们可以得到一个新题目：

即对于一段序列的前缀和，如何交换才能使它变得严格单调递增。

同时，我们观察数据，可以很轻易的联想到用离散化，并且贪心的去记录修改次数。

在说明贪心之前，我们先考虑几个明显的特殊性质：

- 前缀和的最小值不应小于或等于 0 ，否则无法更改成功；
- 前缀和的最大值必须为所有数的和，否则则说明有连续的一段小于 0 且左右不能在其修改时将其保持为整数；
- 前缀和互相之间不能相等，否则不能满足严格这一条件。

我们来证明贪心：

先说贪心结论，即将 $i$ 与在 $i$ 的位置的数交换，必然是最划算的。

我们来证明：我们发现，对于哪一个数，我们最后都必须交换到其位置，因此，我们直接将其复原到原位置，必然是没有更有解的。如果说可以连带的话，我们发现，连带是可以凭借直接交换而构成的，必然不比直接交换优，因此，我们用 $O(N)$ 的时间复杂度计算即可。

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5 + 10;
int n, m, id, ans, xb[N];
long long sum[N], x[N], minn = 1, maxn;
map<long long, int> mp;
int main() {
	scanf("%d", &n);
	for(int i = 1, l; i <= n; i++)
		scanf("%d", &l), sum[i] = sum[i - 1] + l, x[i] = sum[i], \
		minn = min(minn, sum[i]), maxn = max(maxn, sum[i]);
	if(minn <= 0 || maxn != sum[n]) { printf("-1"); return 0; }
	sort(x + 1, x + n + 1);
	for(int i = 1; i <= n; i++)	
		if(x[i] == x[i + 1]) { printf("-1"); return 0; }
		else mp[x[i]] = i;
	for(int i = 1; i <= n; i++)
		sum[i] = mp[sum[i]], xb[sum[i]] = i;
	for(int i = 1; i <= n; i++) {
		if(sum[i] == i) continue;
		int t = xb[i];
		swap(sum[i], sum[t]);
		swap(xb[i], xb[sum[t]]);
		ans++;
	}
	printf("%d", ans);
	return 0;
}
```


---

## 作者：chenxia25 (赞：3)

这种奇怪的在数列上操作，看看在前缀和 / 差分数组上发生了什么事往往能发现新大陆。

注意到这里选区间和，以及差分操作实际上是在前缀和数组上做单点操作，考虑 $a$​​​ 的前缀和 $S$​​​。那不难发现，这个操作其实就是让 $S_{l-1}$​​ 加上 $S_r-S_{l-1}$​，让 $S_r$​ 减去 $S_r-S_{l-1}$。那不就是交换 $S_{l-1},S_r$ 呗！到这儿就比较好做了。

任意子序列和为正……那就是所有元素都为正呗。这当且仅当前缀和数组 $S_1>0$ 且严格递增。如果 $S$ 里面有 $\leq 0$ 的值显然就废了，如果有两个相等的值无论如何不可能严格递增，那也废了。注意到这个交换操作是在 $[1,n-1]$ 里交换，$n$ 不能动。所以如果 $S_n$ 不是最大那也废了，否则只需将 $S_{1\sim n-1}$ 排序。

最小次数的话，其实就是任意排列变成恒等排列最小交换次数。建出有向图，数环的个数 $c$，答案就是 $n-1-c$。并查集或者 dfs 随便求。

---

## 作者：johnsmith0x3f (赞：2)

## 0x01

考察前缀和数组 $pre_i = A_1 + A_2 + \ldots + A_i$。

注意到题目要求的“任意连续子序列的和都是正的”等价于 $pre$ 数组严格单调递增，且 $\displaystyle\min_{1 \le i \le n} \{ pre_i \} > 0$。

又注意到一次操作等价于交换 $pre_{l-1}$ 和 $pre_r$ 的值。

则我们只需求出通过交换 $pre$ 数组中元素使其单调递增的最小操作次数。

## 0x02

考虑将 $pre$ 数组升序排序，即可得到 $pre_i$ 变换后的位置。

我们只需求出置换群的个数 $num$，则有 $\text{ans} = n - num$。

## 0x03

然而，此题存在无解的情况。

由 **0x01**，若存在 $pre_i \le 0$，则无解。

不难发现，若存在 $1 \le i < j \le n$ 使得 $a_i = a_j$，则无论如何排列 $pre$ 数组，都会存在一段连续子序列的和为 $0$。

且注意到题中 $1 < l \le r < n$，即 $pre_n$ 的值无法被交换，则必须满足 $pre_n$ 在所有 $pre$ 中最大，否则无解。

## 0x04 Code

```cpp
#include <bits/stdc++.h>
#define int long long
#define MAXN 100005
using namespace std;

inline int read(){
    int x = 0, f = 1; char c = getchar();
    while(isdigit(c)^1) f &= (c!=45), c = getchar();
    while(isdigit(c)) x = (x<<1) + (x<<3) + (c^48), c = getchar();
    return f ? x : -x;
}

int n, num, a[MAXN], id[MAXN], vst[MAXN];

signed main(){
    n = read();
    for(int i=1; i<=n; ++i) a[i] = a[i-1] + read(), id[i] = i;
    sort(id+1, id+n+1, [](const int& x, const int& y){
        return a[x] < a[y];
    });
    if(id[n]!=n || a[id[1]]<0) puts("-1"), exit(0);
    for(int i=2; i<=n; ++i)
        if(a[id[i]]==a[id[i-1]]) puts("-1"), exit(0);
    for(int i=1; i<=n; ++i){
        if(!vst[i]){
            ++num;
            for(int j=id[i]; j!=i; j=id[j]) vst[j] = 1;
        }
    }
    printf("%lld\n", n-num);
    return 0;
}
```


---

## 作者：DrownedFish (赞：2)

### 先贴个结论

给定一个有 $n$ 个互不相同的数的序列，每次操作可以任意交换两个数。设该序列中 **置换环** 个数为 $m$ ，则：

排序这个序列需要的最少操作次数 $=n-m$


------------

### 置换环

~~感性理解一下，~~ 比如现在有序列：

$$18\ \ 5\ \ 3\ \ 17\ \ 666\ \ 233$$

离散化之后：

$$4\ \ 2\ \ 1\ \ 3\ \ 6\ \ 5$$

之后是本人发明的一种**玄学**方法：写一个 $1$ ~ $n$ 的有序数列，把 **离散化后的原序列** 和 **有序数列** 对齐，每个元素分别和 **正下方的数** 以及 **与自己相等的数** 连边，**产生环的个数就是置换环个数**。比如这个例子中置换环的个数为 $3$ 。

![](https://s3.ax1x.com/2021/01/21/sha7FS.png)

~~我都不知道自己是怎么想出来的~~

至于为什么 $n\ -$ 置换环个数 $=$ 最少操作次数~~我口胡一下~~。

假设某个置换环包含 $x$ 个元素，那么对这 $x$ 个元素排序最少只需要操作 $x-1$ 次，因为当 $x>=2$ ，必定有一次操作同时使两个元素归位，其余操作使一个元素归位，当 $x=1$ ，根本无需排序~~自己试试看~~。

所以使所有元素归位，如果说本来要操作 $n$ 次，那么多一个置换环就可以少操作一次~~本蒟蒻不会严谨的证明，大家理解一下就好~~。


------------

### 回到题目

对题目给定的序列和按题意操作后的序列，把每个位置的元素都换成这个位置的前缀和，我们得到神奇的等价题意：

> 给定一个长度为 $n$ 的序列，每次操作可以交换下标 $1$ ~ $n-1$ (含边界) 的任意两个元素。 问至少操作几次可以使整个序列**严格单调递增**且元素均为正数。若无法实现，输出 $-1$ 。

剩下的就比较简单了，详见代码↓


------------


### **Code**

```
#include<bits/stdc++.h>
#define END {cout<<-1;return 0;}
#define N 100010
using namespace std;

int n,ans,a;
int tmp[N],sum[N],sav[N];
bool vis[N];

bool cmp(int x,int y) 
{return sum[x]< sum[y];}

void dfs(int x)
{
    if(vis[x]) return ; // 回到起点代表结束 
    vis[x]=true; // 标记为环上的元素 
    dfs(tmp[x]); // 继续搜 
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0); cout.tie(0); cin>>n;
    
    for(int i=1;i<=n;i++)
    {
        cin>>a; if(!a) END
        // 若 a1=0，那么 sum[1]=0
        // 不满足所有元素均为正，舍去 
        // 若 ai=0 (i>1)，那么会出现两个相等的前缀和 
        // 就无法实现严格单调递增，舍去 
        sum[i]=sum[i-1]+a; // 前缀和
        sav[i]=sum[i];
        tmp[i]=i;
    }
    sort(sav+1,sav+n+1);
    // 如果有元素不为正，或者最大值不在最后一位，则无法实现 
    if(sav[1]<=0 || sav[n]!=sum[n]) END
    
    // 离散化 
    sort(tmp+1,tmp+n+1,cmp);
    for(int i=1;i<=n;i++) 
    sum[tmp[i]]=i;
    
    ans=n; 
    // 答案初始化为元素个数 
    for(int i=1;i<=n;i++)
    // 每找到一个置换环，ans-1  
    if(!vis[i]) ans--,dfs(i);
    
    cout<<ans<<endl;
    return 0;
}

```

---

## 作者：破忆 (赞：2)

## 【题意】

$S_k=\sum_{i=1}^k a_i$。

每次选取区间 $[l,r]$。

$a_l-=S_r-S_{l-1}$。

$a_r-=S_r-S_{l-1}$。

$a_{l-1}+=S_r-S_{l-1}$。

$a_{r+1}+=S_r-S_{l-1}$。

要使得最终数列全为正，最少需要几步。

## 【分析】

通过 $S$ 分析每次操作。

$S_{l-1}'=S_{l-1}+S_r-S_{l-1}=S_r$。

$S_l'=S_{l-1}'-S_r+S_{l-1}+a_l=S_l$。

$S_r'=S_l'-S_r+S_{l-1}+a_r=S_{l-1}$。

$S_{r+1}'=S_r'-S_r+S_{l-1}+a_{r+1}=S_{r+1}$。

可以发现，操作的实质就是交换 $S_{l-1}$ 和 $S_r$。

最终数列全为正，即 $S$ 递增。

离散化之后，找循环节，使 $S$ 递增即可。

------------


感谢 @wheneveright 的指正，需要判无解。

无解的情况有 $3$ 种。

* 前缀和数组中出现相同的数

显然不能使 $S$ 递增。

* 前缀和数组中出现负数

把负的前缀和放在第一个，则 $a_1<0$。

* 前缀和数组中最后一位并非最大

若要将 $S_n$ 前调，则超出操作的范围。

## 【代码】
```cpp
#include<bits/stdc++.h>
#define maxn 100005
#define LL long long
using namespace std;
int n,ans,fa[maxn];
LL maxs;
bool vis[maxn];
struct data{
    LL x;
    int id;
    bool operator <(data b)const{return x<b.x;}
}a[maxn];
int read(){
    int ret=0,f=1;char ch=getchar();
    while(ch>'9'||ch<'0'){if(ch=='-')f=-f;ch=getchar();}
    while(ch<='9'&&ch>='0') ret=ret*10+ch-'0',ch=getchar();
    return ret*f;
}
map<LL,bool> hsh;
int main(){
	#ifndef ONLINE_JUDGE
    freopen("P1667.in","r",stdin);
    freopen("P1667.out","w",stdout);
    #endif
    ans=n=read();
    for(int i=1;i<=n;i++){
    	a[i]=(data){a[i-1].x+read(),i};
    	if(hsh[a[i].x]||a[i].x<0){
    		printf("-1\n");
    		return 0;
		}
		hsh[a[i].x]=1;
		maxs=max(maxs,a[i].x);
	}
	if(maxs^a[n].x){
		printf("-1\n");
		return 0;
	}
    sort(a+1,a+1+n);
    for(int i=1;i<=n;i++) fa[a[i].id]=i;
    for(int i=1;i<=n;i++) if(!vis[i]){
        int x=i;
        vis[i]=1;
        ans--;
        while(fa[x]!=i) x=fa[x],vis[x]=1;
    }
    printf("%d\n",ans);
    return 0;
}
```


---

## 作者：XL4453 (赞：1)

### 解题思路：

发现这个操作是基于了一个区间和，想到看看前缀和上有没有什么巧妙的变化。然后就愉快地发现这样的一个操作就是就是在前缀和意义下交换了 $x-1$ 和 $y$。

此时回去看最终要求的结果，容易发现其实就是要求每一个数都大于 $0$，也就是要求前缀和严格递增。特殊地，要求 $a_1=sum_1>0$，且 $sum_n$ 是最大的，因为它无法被交换。

---
至此，问题就已经被转化为了一个数组中的数字交换问题。

直接排个序依次往下做交换就行了，经典结论。

---
### 代码：

```cpp
#include<map>
#include<cstdio>
#include<algorithm>
using namespace std;
#define int long long
const int MAXN=200005;
int n,a[MAXN],sum[MAXN],sum_[MAXN],ans;
map <int,int> m;
signed main(){
	scanf("%lld",&n);
	for(int i=1;i<=n;i++){
		scanf("%lld",&a[i]);
		sum[i]=sum[i-1]+a[i];
		sum_[i]=sum[i];m[sum[i]]=i;
	}
	sort(sum_+1,sum_+n+1);
	if(sum_[1]<=0||sum[n]!=sum_[n]){
		printf("-1\n");
		return 0;
	}
	for(int i=1;i<=n;i++){
		if(sum_[i]==sum_[i-1]){
			printf("-1\n");
			return 0;
		}
	}
	for(int i=1;i<=n;i++){
		if(sum[i]!=sum_[i]){
			ans++;
			int SUM=sum[i];
			swap(sum[i],sum[m[sum_[i]]]);
			swap(m[SUM],m[sum_[i]]);
			if(sum[i]!=sum_[i])printf("!");
		}
	}
	printf("%lld\n",ans);
	return 0;
}
```


---

## 作者：MrcFrst (赞：0)

[原题传送门](https://www.luogu.com.cn/problem/P1667)

[可能更好的阅读体验](https://www.cnblogs.com/MrcFrst-LRY/p/17753088.html)

区间操作的维护看起来很麻烦，考虑转为点操作的维护。题目中的 $\sum_{i=l}^r a_i$ 启发我们用前缀和。那么我们考虑每次操作会对前缀和数组 $s$ 造成怎样的变化。设操作区间为 $[l,r]$，按照题意，会把 $a_{l-1}$ 和 $a_{r+1}$ 加上 $S$，$a_l$ 和 $a_r$ 减去 $S$，那么对于 $s$ 数组的影响即是把 $s_{l-1}$ 加上 $S$，$a_r$ 减去 $S$。

接下来我们考虑 $S$ 的取值，$S=\sum_{i=l}^r a_i=s_r-s_{l-1}$，然后我们把这个带过去可得：$s_{l-1}=s_{l-1}+s_r-s_{l-1}=s_r,s_r=s_r-(s_r-s_{l-1})=s_{l-1}$。

然后就发现这其实就是交换操作。

接下来考虑，我们的目标是使得序列 $a$ 中所有子段和 $\gt 0$，容易发现这就是让序列 $a$ 中所有数都 $\gt 0$，也就是使前缀和序列 $s$ 单调递增。

所以，我们的问题转化为了：每次操作可选择一对 $l,r(1\le l\lt r\lt n)$，然后 $swap(s_l,s_r)$。求使得序列 $s$ 单调递增的最小操作次数。

那这就是个经典问题了，可以用找置换环的方式解决，具体来说，我们记 $s$ 升序排序之后得到的数组为 $s'$，记 $pos_i$ 表示数 $i$ 在 $s'$ 中出现的位置。那么我们每次从一个没有访问过的位置开始搜，不断令 $i=pos_{s_i}$，直到找到一个置换环，即 $i$ 已经被访问过了，就退出，并令置换环个数 `cnt++`。

最终答案就是 $n-1-cnt$。不懂这里的置换环操作以及答案由来的选手可以自行搜索“置换环”进行了解。至于为什么是 $n-1$ 而不是 $n$，是因为我们每次选择的 $r$ 必须 $\lt n$，所以 $s_n$ 一定是永远都不能参与操作的，直接排除它就好了。

最后的最后，我们来考虑判断无解情况，首先如果 $s$ 中有相等的数的话就一定不能满足“递增”，于是无解，以及如果出现了 $s_i\le 0$ 的话也一定无解，因为如果有 $s_i\le 0$，那么我们把 $s$ 排完序之后一定有 $s_1\le 0$，即 $a_1\le 0$，不满足条件，故无解。

以上这些判断可以合并成：

```cpp
sort(s+1,s+n);
    for(re int i=1;i<=n;i++)
        if(s[i]<=s[i-1]){
            puts("-1");
            return 0;
        }
```

然后这题就做完了。

$\text{Code:}$

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define il inline
#define re register
const int N=100100;
int n,a[N],s[N],b[N],mx=-1e18;
unordered_map<int,int>mp;
bitset<N>vis;
il int read(){
    re int x=0,f=1;char c=getchar();
    while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
    while(c>='0'&&c<='9')x=(x<<3)+(x<<1)+(c^48),c=getchar();
    return x*f;
}
signed main(){
    n=read();
    for(re int i=1;i<=n;i++)
        a[i]=read(),b[i]=s[i]=s[i-1]+a[i];
    sort(s+1,s+n);
    for(re int i=1;i<=n;i++)
        if(s[i]<=s[i-1]){
            puts("-1");
            return 0;
        }
    for(re int i=1;i<n;i++)mp[s[i]]=i;
    int cnt=0;
    for(re int i=1;i<n;i++){
        if(vis[i])continue;
        int j=i;
        while(!vis[j]){
            vis[j]=1;
            j=mp[b[j]];
        }
        cnt++;
    }
    cout<<n-1-cnt;
    return 0;
}
```

---

## 作者：Purslane (赞：0)

# Solution

这种操作很让人想到方差那道题。

很容易发现，这样交换了 $pre_{l-1}$ 和 $pre_{r}$ 的值。

最终要求所有的 $pre$ 递增。

然而我们发现，我们只能在 $pre_{1 \dots n-1}$ 进行修改。

也就是说这些数必须夹在 $pre_0$ 与 $pre_n$ 之间且不能有相等的数。因此可以特判掉那些不合法的情况。

剩下的就是经典问题。求出置换环的个数，拿 $n-1$ 减掉即可。

代码：

```cpp
#include<bits/stdc++.h>
#define int long long
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=1e5+10;
int n,a[MAXN],vis[MAXN],to[MAXN],pre[MAXN],Pre[MAXN];
signed main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>n; ffor(i,1,n) cin>>a[i],pre[i]=pre[i-1]+a[i];
	map<int,int> mp;
	int mn=0,mx=pre[n]; if(mn>=mx) return cout<<-1,0;
	ffor(i,1,n-1) {
		if(mp[pre[i]]) return cout<<-1,0;
		if(pre[i]<=mn||pre[i]>=mx) return cout<<-1,0;
		mp[pre[i]]=1;
	}
	ffor(i,1,n-1) Pre[i]=pre[i];
	sort(Pre+1,Pre+n);
	ffor(i,1,n-1) {
		int pos=lower_bound(Pre+1,Pre+n,pre[i])-Pre;
		to[i]=pos;	
	}
	int ans=0;
	ffor(i,1,n-1) if(!vis[i]) {
		int len=0,u=i;
		while(!vis[u]) len++,vis[u]=1,u=to[u];
		ans+=len-1;	
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：Link_Cut_Y (赞：0)

## 题意

给定一个长度是 $n$ 的数列 $A$，我们称一个数列是完美的，当且仅当对于其任意连续子序列的和都是正的。

现在你有一个操作可以改变数列，选择一个区间 $[l,r]$ 满足 $\sum\limits_{i = l}^r A_i < 0$，其中 $1 < l \le r < n$。

令 $S = \sum\limits_{i = l}^r A_i$，对于 $A_{l - 1}$ 和 $A_{r + 1}$ 分别加上 $S$，$A_l$ 和 $A_r$ 分别减去 $S$（如果 $l = r$ 就减两次）。问最少几次这样的操作使得最终数列是完美的。

## 分析

从前缀和的角度进行考虑。

假设原序列的前缀和为 $\{s\}$，对 $[l, r]$ 进行操作。记 $S = \sum\limits_{i = l}^{r}a_i$。

则前缀和数列 $\{s\}$ 的变化为：

$$s_1 \cdots s_{l - 1}, s_l \cdots s_r, s_{r + 1} \cdots s_{n - 1}, s_n$$

$$\Rightarrow s_1 \cdots s_{l - 1} + S, s_{l} + S - S \cdots s_{r} - S, s_{r + 1} -S + S \cdots s_n$$

$$\Rightarrow s_1 \cdots s_{l - 1} + S, s_{l} \cdots s_{r} - S, s_{r + 1} \cdots s_n$$

又由于 $S = s_r - s_{l - 1}$，将 $S$ 代入，序列可变形为：

$$\Rightarrow s_1 \cdots s_r, s_{l} \cdots s_{l - 1}, s_{r + 1} \cdots s_n$$

其中对于 $i \in [1, l - 1) \cup [l, r) \cup [r + 1, n]$，$s_i$ 保持不变。这一点可以根据差分或前缀和的性质很好的推出。

因此，一次操作 $[l, r]$ 相当于将 $s_r$ 与 $s_{l - 1}$ 对调。

所以原题转化为一下问题：

> 给定数列 $s$ 和操作 $(l, r)$，表示将 $s_{l - 1}$ 与 $s_r$ 对调。问最小对调多少次能够将原序列变成单调递增序列，且对于 $\forall i \in [1, n],s_i > 0$（由于原题要求任意 $a_i$ 大于零）。

原题中 $s_n$ 不能够参与调换（因为题面要求 $r < n$）。为方便讨论，暂且让 $r$ 能够取到 $n$。

----------------------

由于调换仅与元素间大小关系有关，与值的大小无关，因此考虑将 $s$ 序列离散化，得到排列 $s'$。

例如当 $s = \{1, 7, 2, 6, 3\}$ 时，$s' = \{1, 5, 2, 4, 3\}$。（$s'_i$ 就是 $s_i$ 在 $s$ 中的排名）。

再给定目标序列 $t$，$t$ 为 $n$ 级排列的自然顺序，即为 $\{1, 2 \cdots n\}$。原问题转化为通过最小交换次数，将 $s$ 转化为目标排列 $t$。

--------------------

解决这个问题已经变得非常容易，有结论如下：

> 令 $\{a\}$，排序后的序列为 $\{a'\}$。令 $a_i$ 在 $\{a'\}$ 中的位置为 $i'$，则连边 $i \rightarrow i'$。

> 则答案为 $n - r$，其中 $r$ 为构造出的图的连通块个数。

具体证明可以看这里[排列排序最小交换次数](https://www.cnblogs.com/CDOI-24374/p/16410082.html)。我不会证。

最后别忘了判断无解情况：

 - 由于 $r$ 取不到 $n$，因此如果 $s_n \neq \max\{s\}$ 则无解。

 - 由于需要每个数大于零，所以要求 $\min\{s\}$ 大于零。
 
 - 同样的，由于要求每个数大于零，所以要求 $s$ 中不能有相同元素。
 
最后贴一个大家喜闻乐见的代码，需要自取：

## 示例代码

```cpp
#include <cstdio>
#include <vector>
#include <algorithm>

using namespace std;

const int N = 100010;

vector<int> nums;
int p[N], s[N], n;
bool st[N];

int find(int x) {
	return lower_bound(nums.begin(), nums.end(), x) - nums.begin() + 1;
}
void dfs(int u) {
	if (st[u]) return;
	st[u] = true; dfs(p[u]);
}

int main() {
	scanf("%d", &n); int res = 0;
	for (int i = 1; i <= n; i ++ ) {
		scanf("%d", &s[i]); s[i] += s[i - 1];
		if (s[i] < 0) return puts("-1"), 0;
		nums.emplace_back(s[i]);
	}
	sort(nums.begin(), nums.end());
	if (s[n] != nums.back()) return puts("-1"), 0;
	int m = unique(nums.begin(), nums.end()) - nums.begin();
	if (m < nums.size()) return puts("-1"), 0;
	for (int i = 1; i <= n; i ++ )
		p[i] = find(s[i]);
	for (int i = 1; i <= n; i ++ )
		res += (!st[i] ? (dfs(i), 1) : 0);
	printf("%d\n", n - res);
	return 0;
}
```

---

## 作者：Lgx_Q (赞：0)

[orz](https://www.luogu.com.cn/problem/P1667)

根据 CF，这种题如果没有简化的手段，只能暴力找规律。

相邻传数，不妨尝试以前缀和作为突破口。

设 $s_i=\sum_{i=1}^na_i$

对于一次操作 $[l,r]$，题目中的 $S$ 为 $s_r-s_{l-1}$，则：

1. $s_{l-1}\space\space\space\space\space←\space\space\space\space\space s_{l-1}+S=s_{l-1}+s_r-s_{l-1}=s_r$

2. $s_l\space\space\space\space\space←\space\space\space\space\space s_l+S-S=s_l$

3. $s_r\space\space\space\space\space←\space\space\space\space\space s_r+S-S-S=s_r-s_r+s_{l-1}=s_{l-1}$

4. $s_{r+1}\space\space\space\space\space←\space\space\space\space\space s_{r+1}+S-S-S+S=s_{r+1}$

我们发现，一次对于 $[l,r]$ 的操作，只是交换了 $s_{l-1},s_r$ 的值。令 $l←l-1$（所以 $s_1$ 也能被交换），则一次操作交换了 $s_l,s_r$ 的值。但不能操作 $s_n$，因为 $r$ 不能为 $n$。

又知最终目标是使得对于任意的 $i$，$a_i>0$。放到 $s$ 就是对于任意的 $i>1$，$s_i>s_{i-1}$。

因此我们要求的就是对于 $s_1,s_2,...,s_{n-1}$ 中的数任意交换，使得最终序列单调上升。

为了避免歧义，设 $t_1,t_2,...,t_n$ 为 $s_1,s_2,...,s_n$ 经过操作后的序列。 

先考虑什么情况下无解。

1. $t_1\le0$。因为有个隐藏条件 $t_0=s_0=0$。

2. 存在一个数 $i$，使得 $t_i=t_{i+1}$。要使得最终序列单调上升，那么就不能存在相同的数。

3. $t_n\le t_{n-1}$。因为 $t_n(s_n)$ 不能被交换。

然后。

设 $p_i$ 为原来 $s_i$ 在 $t$ 中的位置，即 $t_{p_i}=s_i$。

按套路，每个 $i$ 向 $p_i$ 连边，构成一张图，而且每个点的出度为 $1$。

因为每个数对应的 $p_i$ 都不一样，所以不可能有同一个 $p_i$ 被两个点连接，即每个点的入度也是 $1$。

这张图不一定连通，可以判断出这张图是由若干个环组成。

考虑在操作的同时动态调整 $p$ 数列，使得最终有 $p_1=1,p_2=2,...,p_n=n$，即最终的图应由 $n$ 个自环组成。每次操作交换 $s_l,s_r$ 时，也交换了 $p_l,p_r$。发现如果 $l,r$ 不在同一个环时一定不优。

所以交换的 $l,r$ 一定在同一个环中。画几个草稿发现一次交换会把一个大环拆成两个小环，没有限制。

设 $f_i$ 为一个 $i$ 个点的环，拆成 $i$ 个自环的操作次数。

得 $f_1=0$，

$$f_i=\min_{j=1}^{i-1}\{f_j+f_{i-j}+1\}$$

但是我们有一个结论：$f_i=i-1$

根据数学归纳法，假设 $f_j=j-1,f_{i-j}=i-j-1$ 成立，那么 $f_i=j-1+i-j-1+1=i-1$。

又知 $f_1=0=1-1$，所以 $f_i=i-1$。

所以 $\operatorname{DFS}$ 遍历一下每个环，利用 $f_i=i-1$ 计算总和即可。

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const ll maxn=2e5+10;
ll n,a[maxn],id[maxn],p[maxn],cnt;
bool flag,vis[maxn];
bool cmp(int x,int y)
{
	return a[x]<a[y];
}
void dfs(int u)
{
	if(vis[u]) return;
	vis[u]=true;
	dfs(p[u]);
}
int main()
{
	scanf("%lld",&n);
	for(ll i=1;i<=n;i++)
	{
		scanf("%lld",&a[i]);
		a[i]+=a[i-1];
		id[i]=i;
		if(a[i]<=0) flag=true;
	}
	sort(id+1,id+1+n,cmp);
	for(ll i=2;i<=n;i++)
		if(a[id[i]]==a[id[i-1]]) flag=true;
	if(id[n]!=n) flag=true;
	if(flag)
	{
		printf("-1");
		return 0;
	}
	for(ll i=1;i<=n;i++) p[id[i]]=i;
	for(ll i=1;i<=n;i++)
		if(!vis[i])
		{
			dfs(i);
			++cnt;
		}
	printf("%lld",n-cnt);
	return 0;
}
```

---


# [AHOI2005] 穿越磁场

## 题目描述

探险机器人在Samuel星球上寻找一块奇特的矿石，然而此时它陷入了一片神秘的磁场区域，动弹不得。

探险空间站立刻扫描了这片区域，绘制出该区域的磁场分布平面图。这片区域中分布了N个磁场，每个磁场呈正方形，且边与坐标轴平行。

例如下图中，存在3个磁场，白点表示机器人的位置，黑点表示矿石的位置：

 ![](https://cdn.luogu.com.cn/upload/pic/1642.png) 

科学家们分析平面图，进一步发现：这些磁场为大小不一的正方形，可能相交，甚至覆盖，但是它们的边缘不会重合，顶点也不会重合。

例如下面的两种情形是不会出现的：

 ![](https://cdn.luogu.com.cn/upload/pic/1643.png) 

科学家们给探险机器人启动了磁力罩，这样它就可以在磁场中自由穿越了。

初始时，探险机器人和所有矿石都不在任何磁场的边缘。由于技术限制，在穿越过程中机器人只能够水平或垂直移动，且不能够沿着磁场的边缘行动。

由于磁力罩的能量有限，科学家们希望探险机器人穿越尽量少的磁场边缘采集到这块矿石。例如上图中，探险机器人最少需要穿越两次磁场边缘。

现在小联请你编写程序，帮助科学家们设计探险机器人的路线，统计探险机器人最少需要穿越多少次磁场边缘。


## 样例 #1

### 输入

```
2
1 3 3 
2 1 4
0 0 3 4```

### 输出

```
2```

# 题解

## 作者：D_14134 (赞：5)


有一个简单的想法。直接判断两个点所属的不同的矩形的数量。

最开始一直不知道问题出在哪儿，后来借鉴了题解的图。

![](https://cdn.luogu.com.cn/upload/image_hosting/63cz8nyg.png)


可以看出，题目的坑点在于无法沿边线走。

正解：我们可以通过数据发现，n非常小，只有100。那么我们先离散化。然后在离散化后的图中在两点之间连边。没有跨过磁场的边权为0，跨过磁场的边权为1。然后跑spfa就可以了。

不过离散化的时候需要注意一些小问题。不能直接把第一个出现和最后一个出现的横坐标和纵坐标看成是边界，因为磁场是没有边界的，它有可能从外面绕一大圈过去，并不穿过磁场。
还有就是要注意离散化的时候不要把一些能通过的地方变成不能通过的了，比如说本来两条边中间有路可走结果处理成了两条边相邻，也不能把原来不能走的地方处理成能走的了。

## code
```
#include<queue>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#define maxn 510
using namespace std;

struct node{
	int a,b,c,d;
}s[maxn];

int n,x,y,l,A,B,C,D;
int xx,yy,cntx,cnty,X[maxn*2],Y[maxn*2],xp[maxn*2],yp[maxn*2],lshx[maxn*2],lshy[maxn*2];
int tot,point[maxn*maxn],nxt[maxn*maxn*10],v[maxn*maxn*10],c[maxn*maxn*10],dis[maxn*maxn];
bool flag[maxn][maxn][2],vis[maxn*maxn];
queue<int> q;

int cmpx(int x,int y){
	return X[x]<X[y];
}

int cmpy(int x,int y){
	return Y[x]<Y[y];
}

void add(int x,int y,int z){
	nxt[++tot]=point[x];point[x]=tot;v[tot]=y;c[tot]=z;
	nxt[++tot]=point[y];point[y]=tot;v[tot]=x;c[tot]=z;
}

void spfa(){
	int s=(A-1)*cnty+B;
	memset(dis,127,sizeof(dis)),dis[s]=0;
	memset(vis,0,sizeof(vis)),vis[s]=true;
	while(!q.empty()) q.pop();
	q.push(s);
	while(!q.empty()){
		int now=q.front();
		q.pop();
		vis[now]=false;
		for(int i=point[now];i;i=nxt[i])
			if(dis[v[i]]>dis[now]+c[i]){
				dis[v[i]]=dis[now]+c[i];
				if(!vis[v[i]]){
					vis[v[i]]=true;
					q.push(v[i]);
				}
			}
	}
}

void init(){
	scanf("%d",&n);
	for(int i=1;i<=n;++i){
		scanf("%d%d%d",&x,&y,&l);
		X[++xx]=x,xp[xx]=xx,X[++xx]=x+l,xp[xx]=xx;
		Y[++yy]=y,yp[yy]=yy,Y[++yy]=y+l,yp[yy]=yy;
	}
	scanf("%d%d%d%d",&A,&B,&C,&D);
	X[++xx]=A,xp[xx]=xx,X[++xx]=C,xp[xx]=xx;
	Y[++yy]=B,yp[yy]=yy,Y[++yy]=D,yp[yy]=yy;

	X[++xx]=-1,xp[xx]=xx,Y[++yy]=-1,yp[yy]=yy;
	X[++xx]=10000,xp[xx]=xx,Y[++yy]=10000,yp[yy]=yy;
}

void lsh(){
	sort(xp+1,xp+xx+1,cmpx);sort(yp+1,yp+yy+1,cmpy);
	for(int i=1;i<=xx;++i){
		if(X[xp[i]]!=X[xp[i-1]]) ++cntx,lshx[xp[i]]=++cntx;
		else lshx[xp[i]]=cntx;
	}
	for(int i=1;i<=yy;++i){
		if(Y[yp[i]]!=Y[yp[i-1]]) ++cnty,lshy[yp[i]]=++cnty;
		else lshy[yp[i]]=cnty;
	}
	xx=yy=0;
	for(int i=1;i<=n;++i){
		s[i].a=lshx[++xx],s[i].b=lshx[++xx];
		s[i].c=lshy[++yy],s[i].d=lshy[++yy];
	}
	A=lshx[++xx],C=lshx[++xx],B=lshy[++yy],D=lshy[++yy];
}

int main(){
	init();
	lsh();
	for(int i=1;i<=n;++i){
		int a=s[i].a,b=s[i].b,c=s[i].c,d=s[i].d;
		for(int j=a;j<b;++j) flag[j][d][0]=flag[j][c][0]=1;
		for(int j=c;j<d;++j) flag[a][j][1]=flag[b][j][1]=1;
	}
	for(int i=1;i<=cntx;++i)
		for(int j=1;j<=cnty;++j){
			int r=(i-1)*cnty+j,t;
			if(!flag[i][j][0]){
				t=i*cnty+j;
				if(flag[i][j][1]) add(r,t,1);
				else add(r,t,0);
			}
			if(!flag[i][j][1]){
				t=(i-1)*cnty+j+1;
				if(flag[i][j][0]) add(r,t,1);
				else add(r,t,0);
			}
		}
	spfa();
	int t=(C-1)*cnty+D;
	printf("%d\n",dis[t]);
}
```


---

## 作者：litble (赞：3)

将所有的正方形磁场的边界坐标离散化，将原图变成网格图。

处理一下往上/下/左/右走会跨越正方形边界的格子，他们往这个方向走支付1的代价，其他格子任意走支付0的代价。

然后可以用dijkstra或者01bfs跑一个最短路即可解决。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define RI register int
const int N=105,inf=0x3f3f3f3f;
int n,js1,js2,sx,sy,tx,ty;
int bx[N<<1],by[N<<1],X[N],Y[N],C[N],v[N][N][4],dis[N][N];
int mvx[5]={-1,1,0,0},mvy[5]={0,0,-1,1};

int getx(int x) {return lower_bound(bx+1,bx+1+js1,x)-bx;}
int gety(int y) {return lower_bound(by+1,by+1+js2,y)-by;}
void prework() {
	bx[n+n+1]=by[n+n+1]=inf,bx[n+n+2]=by[n+n+2]=-inf;
    //添加无限边界，也就是不在任何磁场中的格子
	sort(bx+1,bx+n+n+3),sort(by+1,by+n+n+3);
	js1=1;for(RI i=2;i<=n+n+2;++i) if(bx[i]!=bx[js1]) bx[++js1]=bx[i];
	js2=1;for(RI i=2;i<=n+n+2;++i) if(by[i]!=by[js2]) by[++js2]=by[i];
    //去重
	for(RI i=1;i<=n;++i) {
		int X1=getx(X[i]),X2=getx(X[i]+C[i]);
		int Y1=gety(Y[i]),Y2=gety(Y[i]+C[i]);
		for(RI j=X1;j<X2;++j)//处理跨越正方形的代价
			v[j][Y1][2]=v[j][Y2-1][3]=v[j][Y1-1][3]=v[j][Y2][2]=1;
		for(RI j=Y1;j<Y2;++j)
			v[X1][j][0]=v[X2-1][j][1]=v[X1-1][j][1]=v[X2][j][0]=1;
	}
    //找到起点和终点所在的格子
	sx=getx(sx)-1,sy=gety(sy)-1,tx=getx(tx)-1,ty=gety(ty)-1;
}
typedef pair<int,int> PR;
deque<PR> q;
void bfs() {//01bfs
	for(RI i=1;i<js1;++i)
		for(RI j=1;j<js2;++j) dis[i][j]=inf;
	dis[sx][sy]=0,q.push_back((PR){sx,sy});
	while(!q.empty()) {
		PR kl=q.front();q.pop_front();
		int x=kl.first,y=kl.second;
		for(RI i=0;i<4;++i) {
			int kx=x+mvx[i],ky=y+mvy[i];
			if(kx<1||ky<1||kx>=js1||ky>=js2) continue;
			if(dis[x][y]+v[x][y][i]<dis[kx][ky]) {
				if(dis[kx][ky]==inf) {
					if(v[x][y][i]) q.push_back((PR){kx,ky});
					else q.push_front((PR){kx,ky});
				}
				dis[kx][ky]=dis[x][y]+v[x][y][i];
			}
		}
	}
}
int main()
{
	scanf("%d",&n);
	for(RI i=1;i<=n;++i) {
		scanf("%d%d%d",&X[i],&Y[i],&C[i]);
		bx[i]=X[i],bx[n+i]=X[i]+C[i];
		by[i]=Y[i],by[n+i]=Y[i]+C[i];
	}
	scanf("%d%d%d%d",&sx,&sy,&tx,&ty);
	prework(),bfs();
	printf("%d\n",dis[tx][ty]);
	return 0;
}
```

---

## 作者：Zwaire (赞：2)

# P2537 [AHOI2005]穿越磁场

##   [LINK](https://www.luogu.com.cn/problem/P2537)

## 主要思想：离散化 + 最短路

题目中要求我们求从起点到终点经过的磁场边缘的数目，那我们是不是可以转化一下，把每一个区域看成一个联通块，这样的话，起点所在的联通块到终点所在的联通块，其中所经过的联通块的块数，就是我们所要求的的答案。**这样我们的问题就转化成了求联通块，再把相邻的联通块的边权设为 1 就行了**，问题是怎么求出联通块。

**BFS??**

显然效率过于低下，我们可以观察到一个性质：两条分割线之间会有很多没有用的点，即矩形内部的空白区域，因为在这个范围内走的话是没有任何贡献的，所以显得很多余，还会使我们的矩形扩大，那我们真正有意义的说是什么？？？

就是边界，当我们经过边界的时候才会增加答案，但是在边界内部，根本不会造成什么太大的影响，再考虑到我们的边长很大，那我们就可以想到离散化了。

但是离散化的过程要注意一下几点：

$\bullet$ 对于两个边之间有空白的边，需要我们再加上一条边来表示中间的空白部分（为了不改变原来图像的性质）。

$\bullet$ 我们还是看成网格图来计算，只是需要我们把 $x,y$ 两维分开计算即可。

```c++
int n, tx, ty, sx, sy, ex, ey;
int dx[5] = {0, 1, -1, 0, 0}, dy[5] = {0, 0, 0, 1, -1};
int Sx[N], Sy[N], visx[1001][1001], visy[1001][1001];
struct node
{
    int x1, x2, y1, y2;
}a[N];
int head[N], ver[N], nxt[N], edge[N], tot;
il void add(int x, int y, int z) {ver[++tot] = y; nxt[tot] = head[x]; head[x] = tot; edge[tot] = z;}
il int id(int x, int y) {return (x - 1) * ty + y;}
int d[N], v[N];
queue<int> q;
il void spfa()
{
    memset(d, 0x3f, sizeof(d));
    d[id(sx, sy)] = 0;
    v[id(sx, sy)] = 1;
    q.push(id(sx, sy));
    while(q.size())
    {
        int x = q.front(); q.pop();
        v[x] = 0;
        for_edge(i, x)
        {
            int y = ver[i], z = edge[i];
            if(d[y] > d[x] + z)
            {
                d[y] = d[x] + z;
                if(!v[y]) v[y] = 1, q.push(y);
            }
        }
    }
}

signed main()
{
    n = re();
    for_1(i, n)
    {
        int x = re(), y = re(), c = re();
        a[i] = node{x, x + c, y, y + c};
    }
    sx = re(), sy = re(), ex = re(), ey = re();
    Sx[++tx] = sx, Sx[++tx] = ex, Sy[++ty] = sy, Sy[++ty] = ey;
    for_1(i, n)
    {
        Sx[++tx] = a[i].x1, Sx[++tx] = a[i].x2;
        Sy[++ty] = a[i].y1, Sy[++ty] = a[i].y2;
    }
    sort(Sx + 1, Sx + 1 + tx); sort(Sy + 1, Sy + 1 + ty);
    tx = unique(Sx + 1, Sx + 1 + tx) - Sx - 1, ty = unique(Sy + 1, Sy + 1 + ty) - Sy - 1;
    for_xy(i, 2, tx) if(Sx[i] - Sx[i - 1] > 1) Sx[++tx] = Sx[i] - 1;
    for_xy(i, 2, ty) if(Sy[i] - Sy[i - 1] > 1) Sy[++ty] = Sy[i] - 1;//这一行和上一行就是保证之间有一个空白
    Sx[++tx] = -10, Sy[++ty] = -10; Sx[++tx] = INF, Sy[++ty] = INF;//加上边界
    sort(Sx + 1, Sx + 1 + tx); sort(Sy + 1, Sy + 1 + ty);
    tx = unique(Sx + 1, Sx + 1 + tx) - Sx - 1, ty = unique(Sy + 1, Sy + 1 + ty) - Sy - 1;
    for(int i = 1; i <= n; ++i)
    {
        a[i].x1 = lower_bound(Sx + 1, Sx + 1 + tx, a[i].x1) - Sx;
        a[i].x2 = lower_bound(Sx + 1, Sx + 1 + tx, a[i].x2) - Sx;
        a[i].y1 = lower_bound(Sy + 1, Sy + 1 + ty, a[i].y1) - Sy;
        a[i].y2 = lower_bound(Sy + 1, Sy + 1 + ty, a[i].y2) - Sy;
        for_xy(j, a[i].x1, a[i].x2) visx[j][a[i].y1] = visx[j][a[i].y2] = 1;//分成x,y两维，方便计算
        for_xy(j, a[i].y1, a[i].y2) visy[a[i].x1][j] = visy[a[i].x2][j] = 1;
    }
    sx = lower_bound(Sx + 1, Sx + 1 + tx, sx) - Sx, sy = lower_bound(Sy + 1, Sy + 1 + ty, sy) - Sy;
    ex = lower_bound(Sx + 1, Sx + 1 + tx, ex) - Sx, ey = lower_bound(Sy + 1, Sy + 1 + ty, ey) - Sy;
    for_1(i, tx)
    {
        for_1(j, ty)
        {
            for(int k = 1; k <= 4; ++k)
            {
                int xx = i + dx[k], yy = j + dy[k];
                if(xx < 1 || xx > tx || yy < 1 || yy > ty) continue;
                if(k == 1) add(id(i, j), id(xx, yy), visy[xx][yy]);//建边，与上面相对应，不再赘述
                if(k == 2) add(id(i, j), id(xx, yy), visy[xx][yy]);
                if(k == 3) add(id(i, j), id(xx, yy), visx[xx][yy]);
                if(k == 4) add(id(i, j), id(xx, yy), visx[xx][yy]);
            }
        }
    }
    spfa();//愉快的跑最短路
    cout<<d[id(ex, ey)]<<endl;
}

```

完结撒花✿✿ヽ(°▽°)ノ✿

---

## 作者：Betrayer_of_love (赞：1)

一个非常明显的思路是这样的，我们把正方形的边长把整个平面割成了若干个块，显然每个联通块都可以看做一个点，那么接下来只需要把所有的相邻边的联通块全部连上一条长度为 $1$ 的边，表示如果要从这个联通块到达另外一个联通块，需要穿过这一条边，那么最终的答案就变成了起点和终点所在联通块的最短路。因为找联通块不好搞，其实**离散**之后再当成网格图做就好了。

### CODE:


```cpp
#include<bits/stdc++.h>
#define ll long long
#define MAX 250
#define int long long
using namespace std;
inline int read() {
	int x = 0;
	bool t = false;
	char ch = getchar();
	while ((ch < '0' || ch > '9') && ch != '-')ch = getchar();
	if (ch == '-')t = true, ch = getchar();
	while (ch <= '9' && ch >= '0')x = x * 10 + ch - 48, ch = getchar();
	return t ? -x : x;
}
struct Matrix {
	int x1, x2, y1, y2;
} p[MAX << 1];
int n, Sx[MAX << 3], Sy[MAX << 3], tx, ty;
int Bx, By, Ex, Ey;
bool visx[MAX << 1][MAX << 1], visy[MAX << 1][MAX << 1];
struct Line {
	int v, next, w;
} e[MAX * MAX * 10];
int h[MAX * MAX << 2], cnt = 1;
inline void Add(int u, int v, int w) {
	e[cnt] = (Line) {
		v, h[u], w
	};
	h[u] = cnt++;
}
int d[4][2] = {1, 0, -1, 0, 0, 1, 0, -1};
int id(int x, int y) {
	return x * ty + y - ty;
}
int dis[MAX * MAX << 1];
bool vis[MAX * MAX << 1];
void SPFA() {
	queue<int> Q;
	Q.push(id(Bx, By));
	memset(dis, 63, sizeof(dis));
	dis[id(Bx, By)] = 0;
	while (!Q.empty()) {
		int u = Q.front();
		Q.pop();
		for (int i = h[u]; i; i = e[i].next) {
			int v = e[i].v;
			if (dis[v] > dis[u] + e[i].w) {
				dis[v] = dis[u] + e[i].w;
				if (!vis[v])vis[v] = true, Q.push(v);
			}
		}
		vis[u] = false;
	}
}
signed main() {
	n = read();
	for (int i = 1; i <= n; ++i) {
		int x = read(), y = read(), c = read();
		p[i] = (Matrix) {
			x, x + c, y + c, y
		};
	}
	Bx = read();
	By = read();
	Ex = read();
	Ey = read();
	Sx[++tx] = Bx;
	Sx[++tx] = Ex;
	Sy[++ty] = By;
	Sy[++ty] = Ey;
	for (int i = 1; i <= n; ++i)Sx[++tx] = p[i].x1, Sx[++tx] = p[i].x2;
	for (int i = 1; i <= n; ++i)Sy[++ty] = p[i].y1, Sy[++ty] = p[i].y2;
	sort(&Sx[1], &Sx[tx + 1]);
	sort(&Sy[1], &Sy[ty + 1]);
	tx = unique(&Sx[1], &Sx[tx + 1]) - Sx - 1;
	ty = unique(&Sy[1], &Sy[ty + 1]) - Sy - 1;
	for (int i = 2; i <= tx; ++i)if (Sx[i] - Sx[i - 1] > 1)Sx[++tx] = Sx[i] - 1;
	for (int i = 2; i <= ty; ++i)if (Sy[i] - Sy[i - 1] > 1)Sy[++ty] = Sy[i] - 1;
	Sx[++tx] = -10;
	Sy[++ty] = -10;
	Sx[++tx] = 1e9;
	Sy[++ty] = 1e9;
	sort(&Sx[1], &Sx[tx + 1]);
	sort(&Sy[1], &Sy[ty + 1]);
	tx = unique(&Sx[1], &Sx[tx + 1]) - Sx - 1;
	ty = unique(&Sy[1], &Sy[ty + 1]) - Sy - 1;
	for (int i = 1; i <= n; ++i) {
		p[i].x1 = lower_bound(&Sx[1], &Sx[tx + 1], p[i].x1) - Sx;
		p[i].x2 = lower_bound(&Sx[1], &Sx[tx + 1], p[i].x2) - Sx;
		p[i].y1 = lower_bound(&Sy[1], &Sy[ty + 1], p[i].y1) - Sy;
		p[i].y2 = lower_bound(&Sy[1], &Sy[ty + 1], p[i].y2) - Sy;
		for (int j = p[i].x1; j <= p[i].x2; ++j)visx[j][p[i].y1 - 1] = visx[j][p[i].y2 - 1] = true;
		for (int j = p[i].y2; j <= p[i].y1; ++j)visy[p[i].x1][j] = visy[p[i].x2][j] = true;
	}
	Bx = lower_bound(&Sx[1], &Sx[tx + 1], Bx) - Sx;
	By = lower_bound(&Sy[1], &Sy[ty + 1], By) - Sy;
	Ex = lower_bound(&Sx[1], &Sx[tx + 1], Ex) - Sx;
	Ey = lower_bound(&Sy[1], &Sy[ty + 1], Ey) - Sy;
	for (int i = 1; i <= tx; ++i)
		for (int j = 1; j <= ty; ++j)
			for (int k = 0; k < 4; ++k) {
				int x = i + d[k][0], y = j + d[k][1];
				if (x < 1 || y < 1 || x > tx || y > ty)continue;
				if (k == 0)Add(id(i, j), id(x, y), visy[x][y]);
				if (k == 1)Add(id(i, j), id(x, y), visy[i][j]);
				if (k == 2)Add(id(i, j), id(x, y), visx[i][j]);
				if (k == 3)Add(id(i, j), id(x, y), visx[x][y]);
			}
	SPFA();
	printf("%d\n", dis[id(Ex, Ey)]);
	return 0;
}
```

---


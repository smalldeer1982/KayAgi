# [Code+#3] 白金元首与克劳德斯

## 题目背景

> 千里白金雪满天　烽火江山起狼烟　分手竟兵刃相见

1941.7.

苏联军队出乎意料的反抗力量、前线德军的补给困难 —— 元首 Adolf 望着天空的云层陷入沉思……

## 题目描述

在 $xy$-直角坐标平面的天空中，有 $n$ 片四边平行于坐标轴的矩形云朵。每一片云由一个五元组 $(x_i, y_i, w_i, h_i, d_i)$ 表示，其中 $(x_i, y_i)$ 为云左下角顶点的坐标，$w_i$ 表示云在 $x$ 轴方向的宽度，$h_i$ 表示云在 $y$ 轴方向的长度，$d_i \in \{0, 1\}$ 为云的移动方向（$0$ 为横向，$1$ 为纵向）。具体来说，满足 $d_i = 0$ 的云沿 $x$ 轴正方向以每秒 $1$ 长度单位的速率不断移动，而满足 $d_i = 1$ 的云沿 $y$ 轴正方向以每秒 $1$ 长度单位的速率不断移动。

元首发现，**所有的云在此时没有重叠的面积**。他将这个时刻记作时刻 $0$。他想知道，对于 $(-\infty, +\infty)$ 中的**任意时刻**和平面上的**任意一个点**，最多可以同时被多少片云覆盖。一个点在某时刻被一朵云覆盖当且仅当这个点位于该时刻云朵所处矩形的**内部（不含边界）**。

你需要编写程序帮助元首满足他的好奇心。


## 说明/提示

第 $1$ 组数据中，任意时刻的任意一个点至多被惟一的一片云覆盖。

第 $2$ 组数据中，下图从左至右分别示意时刻 $0$、时刻 $4$、时刻 $11$ 的情形。

![](https://cdn.luogu.com.cn/upload/pic/15106.png)

第 $3$ 组数据中，时刻 $0$ 对应第 $2$ 组数据时刻 $20$ 的情形。在该组数据中，$(-20, 0)$ 内的时刻均有 $2$ 片云覆盖同一个点。请注意考察范围 $(-\infty, +\infty)$ 包含时刻 $0$ 之前的时间段。

对于所有数据，有 $1 \leq T \leq 15$，$-5\times 10^8 \leq x_i, y_i \leq 5\times 10^8$，$1 \leq w_i, h_i \leq 5\times 10^8$，$d_i \in {0, 1}$。

![](https://cdn.luogu.com.cn/upload/pic/15108.png)

Credit：https://www.luogu.org/discuss/show?postid=35727

## 样例 #1

### 输入

```
3
1
0 0 1 1 0
3
0 -10 10 10 1
10 0 10 10 1
-10 0 10 10 0
3
0 10 10 10 1
10 20 10 10 1
10 0 10 10 0
```

### 输出

```
1
2
2
```

# 题解

## 作者：shadowice1984 (赞：9)

考验大家初中物理的时候到了~

__________________________

## 本题题解

首先我们发现所有的云只有两种运动方向，水平向右和竖直向上

那么我们可以变化一下参考系，我们以一个竖直向上1单位速度每秒运动的点作为参考系

那么我们会发现此时所有水平运动的云都是不动的了

现在所有水平向右运动的云全部是沿着斜下方45度的方向运动了

又因为在0时刻所有云互不相交，因此所有水平运动的云互不相交，并且所有竖直的云也是互不相交的，所以同一个点最多被两朵云覆盖，而且一个是水平运动的另一个是竖直运动的云，所以答案要么是1要么是2对应着是否出现过云相交的情况

那么问题就非常简单了，我们的问题现在变成了一堆不动云和一堆45度运动的云会不会相交的问题，这个问题还是相当好解决的，我们先将整个坐标系旋转45度,现在的问题变成了一堆水平运动的斜矩形和一堆不动的斜矩形会不会相交的问题了

______________________

然后我们发现由于运动的时间是无限长，因此其实问题就判断一堆线段会不会相交的问题……具体点就是你发现每一个斜着的矩形可以抽象成一个上端点是顶点中y坐标最大值，下端点是顶点y坐标中的最小值的线段

然后我比较傻……，我是把所有的坐标全部离散化之后，将所有竖直云对应的线段全部区间+1然后对于每一个水平的云对应的线段,查一下区间和判一下是不是全是0来进行判断的…………

上代码~

```C
// luogu-judger-enable-o2
#include<cstdio>
#include<algorithm>
#include<map> 
using namespace std;const int N=1e5+10;typedef long long ll; 
int n;int x[N];int y[N];int w[N];int h[N];int t[N];int sum[4*N];
map <int,int> mp;int T;
inline void solve()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)scanf("%d%d%d%d%d",&x[i],&y[i],&w[i],&h[i],&t[i]);
    for(int i=1;i<=n;i++){mp[x[i]+y[i]+1]=1,mp[x[i]+y[i]+w[i]+h[i]]=1;}
    map <int,int> :: iterator it,it1;//大力离散化
    for(it=mp.begin(),it1=it,++it1;it1!=mp.end();++it,++it1)it1->second+=it->second;
    for(int i=1;i<=n;i++)
    {
        if(t[i]==0)//然后区间加
        {
            int l=mp[x[i]+y[i]+1];int r=mp[x[i]+y[i]+w[i]+h[i]];
            for(int j=l;j<=r;j++)sum[j]=1;
        }
    }for(int i=1;i<=(int)mp.size();i++)sum[i]+=sum[i-1];
    for(int i=1;i<=n;i++)//区间求和
    {
        if(t[i]==1)
        {
            int l=mp[x[i]+y[i]+1];int r=mp[x[i]+y[i]+w[i]+h[i]];
            if(sum[l]!=sum[r]){printf("2\n");return;}
        }
    }printf("1\n");
}
inline void clear()
{for(int i=1;i<=(int)mp.size();i++)sum[i]=0;mp.clear();}
int main()//拜拜程序~
{scanf("%d",&T);for(int z=1;z<=T;z++)solve(),clear();return 0;}

```

---

## 作者：zhou_yk (赞：4)

首先，此题答案只可能是1或者2

所以问题转化为判断会不会有两朵云在某个时刻相交

我们假设有两朵云。

第一朵信息为$(x1,y1,w1,h1,0)$
第二朵为$(x2,y2,w2,h2,1)$

在x方向两者相遇的时间段为$(x2-x1-w1,x2+w2-x1)$;

同理在y方向两者相遇的时间段为$(y1-y2-h2,y1+h1-y2)$。

那么就可以n^2的枚举两朵方向不同的云判断了，但显然要超时。


上面两段相交的充要条件是$x2+w2-x1>y1-y2-h2$ 且 $y1+h1-y2>x2-x1-w1$

化简

$x1+y1<x2+y2+w2+h2$ 且 $x2+y2<x1+y1+w1+h1$

我们发现，这个式子又是另外两条线段相交的充要条件

那么就是判断这n条线段是否存在相交并且所对应云移动方向不同的。

奉上代码

------------

```cpp
#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;
int n,Q,f[1000];
bool flag;
struct node {
	int l,r,p;
	bool operator < (const node &a) const {
		return l==a.l ? r<a.r : l<a.l;
	}
}a[100005];
int main()
{
	scanf("%d",&Q);
	while (Q--){
		scanf("%d",&n);
		for (int i=1;i<=n;++i) {
			int A,b,c,d,p;
			scanf("%d%d%d%d%d",&A,&b,&c,&d,&p);
			a[i]=(node){A+b,A+b+c+d,p};
		}
		sort(a+1,a+n+1);flag=true;
		memset(f,-0x3f3f3f,sizeof(f));
		for (int i=1;i<=n;++i) {
			if (a[i].l<f[a[i].p]^1) {
				flag=false;
				puts("2");
				break;
			}
			f[a[i].p]=max(f[a[i].p],a[i].r);
		}
		if (flag) puts("1");
	}
	return 0;
}
```

---

## 作者：AtomAlpaca (赞：2)

## 题目
[link](https://www.luogu.com.cn/problem/P4261)

## 正文
首先证明, 任意时刻不可能有一个点被三个及以上个云朵覆盖. 

考虑反证法, 假设有一点会被三个覆盖, 则必有至少两个云朵有重合部分且运动方向相同. 因为所有云朵都运动速度都相等, 这两个云朵在任意时刻都重合, 而这和题目中的 $0$ 时刻没有重合的云朵矛盾.

因此答案只可能是 $1$ 或 $2$. 我们只需要考虑是否有某一时刻存在两朵重合都云朵即可.

考虑到运动方向相同的云朵不可能重合, 我们只需要选取某一方向的云朵和另一方向的云朵逐个比较即可, 最坏复杂度是 $ O(N^2) $.

考虑如何判断. 由于只需要判断是否重合, 这两个云朵的具体坐标并不重要, 我们要考虑的是云朵的相对位置. 两个云朵都运动的情况难以处理, 因此我们给每一个云朵都加上一个方向为 x 轴负方向的速度, 这样对两者的相对位置不会产生影响, 但我们横向的云朵转化为了静止的状态, 而竖直方向都运动变为了向左上方斜 $ 45 $ 度的运动.

因为时间是任意的, 任意运动云朵 $ i $ 覆盖过的位置就是其左下角和右上角的轨迹围成的平行四边形. 这两点的坐标分别为 $ (x_i, y_i) $ 和 $ (x_i + w_i, y_i + h_i) $, 因此这两个轨迹的方程分别为 $ y_1 = -x + (y_i + x_i)$ 和 $ y_2 = -x + (y_i + h_i + x_i + w_i) $.

如果 $y_1$ 在静止云朵 $j$ 的右上角上方穿过, 或者 $y_2$ 在其左下角的下方穿过, 那么这两个云朵不能够重合. 也即

$$ 
	-x_j - w_j + y_i + x_i \ge  y_j + h_j
$$
或
$$ 
	-x_j + x_i + w_i + y_i + h_i \le  y_j
$$
时不能重合.

整理可得, $i$ 和 $j$ 能够重合都充要条件为:

$$
\begin{aligned}
	 x_i + y_i &<  x_j + w_j + y_j + h_j \\
     x_j + y_j &<  x_i + w_i + y_i + h_i
\end{aligned}
$$

逐个判断即可. 但这样交上去会 TLE 一个点, 考虑优化.

将所有静止节点按照 $ x_j +y_j $ 从小到大排序, 假如一个移动节点枚举到某一静止节点时满足 $ x_j + y_j \ge x_i + w_i + y_i + h_i $, 则不需要继续向下枚举, 放弃这个移动节点即可.

## 代码
``` c++
#include <bits/stdc++.h>

using std::cin;
using std::cout;
using std::vector;

int T, n, x, y, w, h, d;

struct Node
{
	int a, b;
};

vector <Node> a, b;

bool cmp(Node n1, Node n2)
{
	return n1.a < n2.a;
}

void clear()
{
	a.clear(); b.clear();
}

void solve()
{
	clear();
	cin >> n;
	for (int i = 1; i <= n; ++i)
	{
		cin >> x >> y >> w >> h >> d;
		if (d) { a.push_back(Node{x + y, x + y + w + h}); }
		else   { b.push_back(Node{x + y, x + y + w + h}); }
	}

	std::sort(b.begin(), b.end(), cmp);

	for (Node i : a)
	{
		for (Node j : b)
		{
			if (i.a < j.b and j.a < i.b) { cout << "2\n"; return; }
			if (i.b <= j.a)      		 { break; }
		}
	}
	cout << 1 << '\n';
}

int main()
{
	cin.tie(NULL);
	cout.tie(NULL);
	std::ios::sync_with_stdio(false);
	cin >> T;
	while (T--) { solve(); }
}
```

---


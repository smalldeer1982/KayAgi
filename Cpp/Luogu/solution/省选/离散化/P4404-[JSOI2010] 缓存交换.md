# [JSOI2010] 缓存交换

## 题目背景

感谢@ACdreamer 贡献数据

## 题目描述

在计算机中，CPU只能和高速缓存Cache直接交换数据。当所需的内存单元不在Cache中时，则需要从主存里把数据调入Cache。此时，如果Cache容量已满，则必须先从中删除一个。 

例如，当前Cache容量为3，且已经有编号为10和20的主存单元。 
此时，CPU访问编号为10的主存单元，Cache命中。 

接着，CPU访问编号为21的主存单元，那么只需将该主存单元移入Cache中，造成一次缺失（Cache Miss）。 

接着，CPU访问编号为31的主存单元，则必须从Cache中换出一块，才能将编号为31的主存单元移入Cache，假设我们移出了编号为10的主存单元。 

接着，CPU再次访问编号为10的主存单元，则又引起了一次缺失。我们看到，如果在上一次删除时，删除其他的单元，则可以避免本次访问的缺失。 

在现代计算机中，往往采用LRU(最近最少使用)的算法来进行Cache调度——可是，从上一个例子就能看出，这并不是最优的算法。 
对于一个固定容量的空Cache和连续的若干主存访问请求，聪聪想知道如何在每次Cache缺失时换出正确的主存单元，以达到最少的Cache缺失次数。

## 说明/提示

在第4次缺失时将3号单元换出Cache。 

## 样例 #1

### 输入

```
6 2
1 2 3 1 2 3```

### 输出

```
4```

# 题解

## 作者：CW666 (赞：11)



函数解释：
		  
          unique（）[unique函数的解释](https://www.cnblogs.com/wangkundentisy/p/9033782.html)
   		  
          make_pair（a,b)(过于无法理解我自行解释）将a与b压进堆里。a可以用于大根堆的排序
			
          lower_bound（）[lower_bound函数的解释](https://baike.baidu.com/item/lower_bound/8620039?fr=aladdin)
          
unique与lower_bound处理完减去数组可以得到处理后的址
（在下面代码有体现）

-----------
****//方法：如果该容器已满，后来出现的不在容器中的，一定要由容器中的元素中距离下一次出现最远的那个元素来替换掉。****
   ~~代码挺明确了就直接看吧~~
----------



```cpp
#include <bits/stdc++.h>//万能头文件 
using namespace std;//使用命名空间吧ei 
const int INF=0x3fffffff;//定义 
int a[100005],b[100005],last[100005],next[100005],cnt,sum;//定义 
bool vis[100005];//定义 
//用next[i]数组保存第I个内存地址的下一次出现的位置
//last[i]表示 下一次对i的 操作
// vis数组标记当前值是否在堆中
priority_queue <pair<int,int> > h; //建大根堆 
int n,m;//定义 
int main() { //main函数 
	memset(next,1,sizeof(next));//初始化 
	scanf("%d%d",&n,&m);//输入 
	for(int i=1; i<=n; i++) {//循环
		scanf("%d",a+i);//输入 
		b[i]=a[i];//赋值 
	}//结束循环 
	sort(b+1,b+1+n);//排序 
	int num=unique(b+1,b+1+n)-b-1;//去重,离散化，从后往前建出每块主存的操作顺序，返回最右址 
	for(int i=1; i<=n; i++)  {//循环
		a[i]=lower_bound(b+1,b+1+num,a[i])-b;//寻找第一个>=a[i]的数，返回址 
		next[last[a[i]]]=i;//构建 next数组 
		last[a[i]]=i;//构建last数组 
	}//结束循环 
	for(int i=1; i<=n; i++) { //循环 
		while(!h.empty()&&!vis[h.top().second]) h.pop();//如果大根堆不是空的并且堆顶元素的a[i]不在Cache缓存里就删除堆顶元素 
		if(vis[a[i]]) h.push(make_pair(next[i],a[i]));//如果a[i]在Cache缓存里就push进当前点的next[i]值 
		else{//如果a[i]不在Cache里 
			cnt++;//答案++ 
			vis[a[i]]=1;//a[i]标记 
			if(!h.empty()&&sum>=m) {//如果大根堆不是空的并且缓存没有剩余;
				vis[h.top().second]=0;//将堆顶元素的a[i]标记 
				h.pop();//删除堆顶元素 
			}//结束判断 
			if(sum<m) //如果Cache容量有剩余 
				sum++;//缓存++ 
			h.push(make_pair(next[i],a[i]));//把当前点push进去 
		}//结束否则 
	}//结束 循环 
	printf("%d",cnt); //输出答案 
	return 0; //功德圆满 
}//结束main函数 
```
~~言简意赅~~


---

## 作者：Acfboy (赞：5)

可以将问题进行转化。  
将在一段时间内加入 Cache 转化为线段覆盖了时间的区间，这样问题就变成了要求每个时刻不能有超过 $m$ 段覆盖，且每一个点必须被该颜色的线段覆盖，求最少要几段。

显然要不把两个颜色相同的端点相连，要不线段长度超过 $1$ 没有任何意义。所以只需考虑相邻两个颜色相同的点连成的线段中要取哪几条。  
不冲突的时候显然是要都取上，冲突的时候因为当前选哪条价值都一样，只是要尽可能减少对后面的影响，那么就选右端点最后面的线段踢出就一定是最优的了。

至于实现。离散化？优先队列？二分？**不用！**，作为 STL 人，我们当然选择 `std::map` 和 `std::set` 来维护！  
具体地，先求出每个点的下一个颜色相同的端点（没有设为无限大），然后在 `std::set` 里面存当前想取的线段的右端点就可以了，删除就意味着删掉最近的该颜色的点和最近右边该颜色点构成的条线段。  
记得每到一个点更新右端点的值。

代码非常短！

```cpp
void Update(int i) {
	std::set<std::pair<int, int> >::iterator it = 
		kick.lower_bound(std::make_pair(i, a[i]));
	std::pair<int, int> now = *it;
	kick.erase(it);
	now.first = next[i], kick.insert(now);
}
void Push(int i) {
	in[a[i]] = 1, size++, ans ++;
	kick.insert(std::make_pair(next[i], a[i]));
}
void Pop() {
	in[(--kick.end())->second] = 0, size --;
	kick.erase(--kick.end());
}
int main() {
	scanf("%d%d", &n, &m);
	memset(next, 0x3f, sizeof next);
	for (int i = 1; i <= n; i++) {
		scanf("%d", &a[i]);
		next[lst[a[i]]] = i, lst[a[i]] = i;
	}
	for (int i = 1; i <= n; i++) {
		if (in[a[i]]) { Update(i); continue; }
		if (size+1 > m) Pop(); 
		Push(i);		
	}
	printf("%d", ans);
	return 0;
}
```

---

## 作者：swhsz (赞：5)

当遇到需要将主存单元加进cache的时候,就看cache里是否满了,满了的话,就删除离最靠后的那一个，这样一定最优。
但是各位大佬的代码太长了。。。其实只需要判断一下当前的优先队列的top是否仍在cache中即可。
```cpp
#include <iostream>
#include <algorithm>
#include <cstdio>
#include <cmath>
#include <queue>
using namespace std;
priority_queue<int>q;
const int N=100005;
int n,m,a[N],b[N],last[N],nxt[N],cnt,ans;
bool vis[N];
int main() {
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++) scanf("%d",&a[i]),b[i]=a[i];
	sort(b+1,b+1+n);int u=unique(b+1,b+1+n)-b-1;
	for(int i=1;i<=n;i++)
    a[i]=lower_bound(b+1,b+1+u,a[i])-b,
    nxt[last[a[i]]]=i,last[a[i]]=i;
	for(int i=1;i<=u;i++) nxt[last[i]]=n+i,a[n+i]=i;
	for(int i=1;i<=n;i++) {
		while(q.size()&&vis[a[q.top()]]==false) 
        q.pop();
		if(vis[a[i]]) {q.push(nxt[i]);continue;}
		if(cnt<m) {
        	vis[a[i]]=1,
            cnt++,ans++,
            q.push(nxt[i]);
            continue;
        }
		vis[a[q.top()]]=0,
        ans++,q.pop();
        q.push(nxt[i]);
        vis[a[i]]=1;
	}
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：JasonL (赞：4)

这道题需要运用贪心+离散化的思想。

首先，当内存未满时，需要持续调入单元，必然会产生访问缺失。因而关键是在内存满时的操作。考虑当内存满时，撤出满足何种条件的单元才能使访问缺失最小。

显然，如果在一段区间内该单元的调用次数最少，就应该移除该单元。因为如果移去调用次数多的单元，在区间内会更容易造成更多的访问缺失。

如何规定区间长度，又如何判断单元在区间内的调用频率呢？我们可以保存在Cache中单元下一次调用的时刻，寻找在Cache中距离下一次调用的时刻最久的单元。因为从当前时刻到该单元调用的下一时刻中，该单元只调用了一次，其他单元必然至少调用一次，在这一区间中出现频率有可能更高。

我们注意到数据范围，主存访问次数<=100,000,而主存块编号<=1,000,000,000。因而我们需要使用离散化，对主存块重新进行编号，然后从后往前建立链状结构，保存不同单元下一次调用的时间。每次加入新单元时寻找满足条件的内存块。

然而这样只能拿到90分(1 TLE)。

考虑是否有更快找到需要移出的单元的做法。我们用一个优先队列，存入各单元下一次的调用时间。每次需要移除时就在队列中查找，如果查到某个单元现在仍在Cache中，就把它移出。

```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<queue>
using namespace std;
int n,m;
int num[101000],rank[101000];
int head[101000],nxt[101000],tnt=0,pos[101000];
bool in[101000];
int cnt=0,maxim=0;
priority_queue <pair<int,int> > q;
void add(int u){
	nxt[++tnt]=head[u];
	head[u]=tnt;
}
int check()
{
	if(cnt<m)
		return -1;	//Cache未满
	int mpos=0;
	while(!in[q.top().second]&&q.size())	
		q.pop();		//确认单元是否在Cache中
	if(q.size()){
		mpos=q.top().second;
		q.pop();
	}
	return mpos;
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=0;i<n;i++){
		scanf("%d",&num[i]);
		rank[i]=num[i];
	}
	sort(rank,rank+n);
	int qr=unique(rank,rank+n)-rank;	//离散化
	tnt=0;
	for(int i=n-1;i>=0;i--){
		num[i]=lower_bound(rank,rank+qr,num[i])-rank;
		add(num[i]);	//建立链表
		maxim=max(maxim,num[i]);
	}
	int ans=0;
	for(int i=0;i<n;i++){
		if(!in[num[i]]){
			int p=check();
			if(p==-1)			//Cache未满
				cnt++;
			else
				in[p]=false;	//将单元移出
			in[num[i]]=true;	//移入单元
			++ans;
		}
		if(!pos[num[i]])	//首次添加从表头开始
			pos[num[i]]=head[num[i]];
		else
			pos[num[i]]=nxt[pos[num[i]]];
		q.push(make_pair(-nxt[pos[num[i]]],num[i]));	//将下一次出现时间放入优先队列里
	}
	printf("%d",ans);
	return 0;
}
```


---

## 作者：SuperJvRuo (赞：4)

~~可以证明，~~每一次从cache中删除的主存一定是下次访问最晚的，可以用优先队列维护。

首先当然是要离散化。先倒着扫一遍建出链式结构，再正着扫一遍模拟访问过程，具体实现看代码。

```
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>
#include<queue>

using std::pair;
using std::priority_queue;
typedef pair<int, int> opt;
//first表示下一次访问该主存的时间，second表示这块主存离散化后的序号 
int Read()
{
	int x = 0;
	char c = getchar();
	while (!isdigit(c))
	{
		c = getchar();
	}
	while (isdigit(c))
	{
		x = (x << 3) + (x << 1) + (c ^ 48);
		c = getchar();
	}
	return x;
}

int next_query[100005], first_query[100005];
//next_query[opt]表示下一个 与opt使用相同主存的 操作
//first_query[mem]表示 下一次对mem的 操作 
void Add_opt(int memory, int order)//构建上边两个数组 
{
	next_query[order] = first_query[memory];
	first_query[memory] = order;
}
void Do_opt(int memory)//维护上边first_query数组 
{
	first_query[memory] = next_query[first_query[memory]];
}

int memory[100005], number[100005];
bool inCache[100005];//这块主存是否在cache中 

int main()
{
	memset(first_query, 0x3f, sizeof(first_query));
	int n = Read(), m = Read();
	for (int i = 1; i <= n; ++i)
	{
		memory[i] = Read();
		number[i] = memory[i];
	}
	std::sort(number + 1, number + n + 1);
	int size = std::unique(number + 1, number + n + 1) - number - 1;
	//离散化，从后往前建出每块主存的操作顺序 
	for (int i = n; i >= 1; --i)
	{
		Add_opt(memory[i] = std::lower_bound(number + 1, number + size + 1,
		                                     memory[i]) - number, i);
	}
	
	int ans = 0;
	//从前往后贪心操作 
	priority_queue<opt> cache;//这个单词的读音同cash，不读catch 
	for (int i = 1; i <= n; ++i)
	{
		if (!inCache[memory[i]])
		{
			++ans;//miss了一次 
			if (cache.size() == m)//cache满了 
			{
				inCache[cache.top().second] = 0;
				cache.pop();//移除下次操作最远的主存 
			}
			Do_opt(memory[i]);//进行操作 
			inCache[memory[i]] = 1;
			cache.push(opt(first_query[memory[i]], memory[i]));
		}
		else
		{
			Do_opt(memory[i]);
			++m;
			//std::priority_queue不能modify，那就再push一次，同时让大小限制+1
			//之前对这块主存的操作的first 一定小于 新push进去的操作的first
			//所以对贪心没有影响 
			cache.push(opt(first_query[memory[i]], memory[i]));
		}
	}
	printf("%d", ans);
	return 0;
}
```

---

## 作者：曹老师 (赞：3)

## Pro ##

[Luogu4404][1]

## Sol ##

[blog食用](http://www.caolaoshi.men/index.php/archives/jsoi2010-hcjh.html)

贪心，优先队列。

拿到题第一眼竟然是DP！不对不对，是贪心。找一组数据很容易的推导出一个贪心方法：如果该容器已满，后来出现的不在容器中的，一定要由容器中的元素中距离下一次出现最远的那个元素来替换掉。可能有点抽象，慢慢读会明白的。那么我们就先处理出到下一次出现的距离，因为前面出现过的下一次出现的时间由下一次决定，因此我们要倒着循环算出一个类似AC自动机或者KMP中的失配数组。我们用优先队列维护距离下一次的最大值，还要记录下该点的编号，方便检查是否在容器中。输入的编号非常大，因此要离散化处理，一定要用相同元素有相同序号的离散化方式。坑点：1.最开始的m个点不能直接放入，还要判断是否已经在容器中；2.不管怎样都要放入，即使已经在容器中，放入的时候优先队列会帮你选择好最大的那个，对贪心的结果没有什么影响。

**时间复杂度：O(nlogn)**

## Code ##

```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<queue>
#include<vector>
using namespace std;

const int L = 1e5 + 5;
struct node {
	int fail , num;
};
struct cmp {
	bool operator()(const node x , const node y) {
		return x.fail < y.fail;
	}
};
int n , m , fail[L] , now[L] , ans = 0 , flag = 1;
long long num[L] , t[L];
priority_queue<node , vector<node> , cmp>q;

int main() {
	memset(now , 0x3f , sizeof(now));
	scanf("%d%d",&n,&m);
	for(int i=1; i<=n; i++) {
		scanf("%lld",&num[i]);
		t[i] = num[i];
	}
	sort(t+1 , t+n+1);
	for(int i=1; i<=n; i++)
		num[i] = lower_bound(t+1 , t+n+1 , num[i]) - t;
	for(int i=n; i>=1; i--) {
		fail[i] = now[num[i]];
		now[num[i]] = i;
	}
	memset(now , 0 ,sizeof(now));
	for(int i=1; i<=n; i++) {
		if(ans == m)
			flag = 2;
		if(flag == 1 && !now[num[i]]) {
			ans++;
			now[num[i]] = 1;
		}
		if(flag == 2 && !now[num[i]]) {
			ans++;
			now[num[i]] = 1;
			now[q.top().num] = 0;
			q.pop();
		}
		node u ;
		u.num = num[i] ; u.fail = fail[i];
		q.push(u);
	}
	printf("%d",ans);
	return 0;
}
```


  [1]: https://www.luogu.org/problemnew/show/P4404

---

## 作者：Eltaos_xingyu (赞：2)

[快](https://www.luogu.com.cn/problem/P4404)[来](https://www.luogu.com.cn/problem/P2088)[有](https://www.luogu.com.cn/problem/SP688)[六](https://www.luogu.com.cn/problem/P3419)[倍](https://www.luogu.com.cn/problem/CF802A)[经](https://www.luogu.com.cn/problem/CF802B)验！！！！

## 题目描述

一个背包能装 $k$ 个物品，现在有 $n$ 件物品，$m$ 次需求。对于每次需求，如果需求的物品不在背包里（称为 `缺失` ），若背包已满，则需用背包里的一件东西来换，否则直接装进背包。求 `缺失` 的最小次数。

## 思路

首先，如果遇到需要交换的时候，一定是下一次需求距离现在最晚的在背包里的物品优先交换出去。

证明是简单的。考虑如果该物品在下一次需求时最晚，也就代表着下一次需求时该物品在背包里的概率最小，代表着移出该物品是当前最优的。

考虑使用优先队列来维护下一次需求最晚的的物品。

接下来就是一些细节了：

- 离散化：主存块编号最大 $10^9$，一看就不能维护这种种类是否在队列里面，如果不会用 `unordered_map` 的话，就要离散化一下。

- 链式建需求链表。

- 需要用 `pair` 结构，因为在交换的时候，要知道交换的是哪个，来维护这个物品是否在队列里。优先队列默认对 `pair` 的第一个元素排序。

如果有什么其他需要特别注意的细节，请提出！

AC 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[100001],b[100001],_next[100001],last[100001],vis[100001];
priority_queue<pair<int,int> > q;
//first->next[i]，即下一个a[i]出现在哪里
//second->a[i]，cache种类 
int nowcnt,ans,n,m; 
int main()
{
	ios::sync_with_stdio(false);
	cin>>n>>m;
	for(int i=1;i<=n;i++)cin>>b[i],a[i]=b[i];
	sort(b+1,b+n+1);//离散化开始
	int tot=unique(b+1,b+n+1)-b-1;
	for(int i=1;i<=n;i++){
		a[i]=lower_bound(b+1,b+tot+1,a[i])-b;
		_next[last[a[i]]]=i;
		last[a[i]]=i;
		_next[i]=1e9;
	}
	for(int i=1;i<=n;i++){
		while(!q.empty()&&!vis[q.top().second])q.pop();
		if(!vis[a[i]]){
			ans++;
			vis[a[i]]=1;
			if(!q.empty()&&nowcnt>=m){
				vis[q.top().second]=0;
//				cout<<q.top().second<<endl;
				q.pop();
			}
			if(nowcnt<m){
				nowcnt++;
			}
		}
//		cout<<ans<<" "<<i<<"\n";
		q.push(make_pair(_next[i],a[i]));
	}
	cout<<ans;
	return 0;
}
```


---

## 作者：Tuibro (赞：2)

## 前言

苯题是在%拟赛中做出，并觉得自己实现的方式可供以后学习，写此题解以记录。

## 思路

题目有点绕，大致意思为：给出一个限定大小空集，依次向集合中放数。如果当前集合中有此数，跳过；如果无此数，记为 $miss$ ，并且若集合未满，加入此数，反之用此数替代集合中一个数。求解 $miss$ 次数的最小值。

如果理解了，便很容易想到我们可以用**贪心**的思想来进行解决。

那么，该如何贪心呢？

再次读题与模拟样例可知，我们的最优策略是：**若集合已满，主动替换当前集合中，下次出现位置靠后的数**。同时也容易证明：若我们不去按照以上策略进行，即设 $next_a < next_b$，我们取 $a$ 进行替换，那么在后面循环到 $next_b$ 时，便需要再次替换集合中除 $a$ 以外的元素，那么是比取 $b$ 替换的情况更劣的。

考虑如上贪心。

## 做法

现在，有了以上贪心思路，我们需要维护的操作便十分明显：

* 实时更新当前元素下一次位置 $next_i$。

* 实时查询当前集合中，有最大 $next_i$ 的元素，并返回下标。

这里就需要我们最常用的**线段树**出场了。容易想到，我们的线段树可以记如下几个值：

```cpp
struct Tree
{
	int l,r,val,id;
	/*
	l,r 即为左右端点
	val 为next的值 
	id  为元素的下标 
	*/
}t[M<<2];
```

那么在维护区间的 $next$ 最大时，我们便可以顺带更新最大元素的下标，如下：

```cpp
void pushup(int x)
{
	t[x].val=max(t[ls(x)].val,t[rs(x)].val);
	t[x].id=t[ls(x)].val>t[rs(x)].val?t[ls(x)].id:t[rs(x)].id;
}
```

同时也要注意，为了后续操作便利，我们要先将该集合塞满后，再依次操作。而删除一个集合中的元素时，可以直接将此元素的 $next$ 赋值为极小值，这样便不会参与线段树的更新。

全部code如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ls(x) x<<1
#define rs(x) x<<1|1
const int M=2e5+5;
bool f1;

char IO;
int read()
{
    int num=0;bool f=0;
    while(IO=getchar(),IO<48||IO>57)if(IO=='-')f=1;
    do num=(num<<1)+(num<<3)+(IO^48);
    while(IO=getchar(),IO>=48&&IO<=57);
    return f?-num:num;
}

int n,m,ans;
int id[M],tmp[M],_next[M],last[M];
bool vis[M];

struct Tree
{
	int l,r,val,id;
	/*
	l,r 即为左右端点
	val 为next的值 
	id  为元素的下标 
	*/
}t[M<<2];
void pushup(int x)
{
	t[x].val=max(t[ls(x)].val,t[rs(x)].val);
	t[x].id=t[ls(x)].val>t[rs(x)].val?t[ls(x)].id:t[rs(x)].id;
}
void build(int x,int l,int r)
{
	t[x].l=l,t[x].r=r;
	if(l==r)
	{
		t[x].id=l;
		return ;
	}
	int mid=l+r>>1;
	build(ls(x),l,mid);
	build(rs(x),mid+1,r);
}
void update(int x,int pos,int v)
{
	if(t[x].l==t[x].r)
	{
		t[x].val=v;
		return ;
	}
	int mid=t[x].l+t[x].r>>1;
	if(pos<=mid)update(ls(x),pos,v);
	else update(rs(x),pos,v);
	pushup(x);
}

bool f2;
int main()
{
//  cout<<1.0*(&f2-&f1)/1024.0/1024.0<<endl;
	n=read(),m=read();
	for(int i=1;i<=n;i++)id[i]=read(),tmp[i]=id[i];
	sort(tmp+1,tmp+n+1);
	int tot=unique(tmp+1,tmp+n+1)-tmp-1;
	for(int i=1;i<=n;i++)
		id[i]=lower_bound(tmp+1,tmp+tot+1,id[i])-tmp;//离散化
	
    for(int i=1;i<=n;i++)
	{
		if(last[id[i]])_next[last[id[i]]]=i;
		last[id[i]]=i;
	}
	for(int i=1;i<=n;i++)
		if(!_next[i])_next[i]=n+1;
	
	int pos=1;
	build(1,1,tot);
	for(int i=1;i<=n;i++)
	{
		if(ans==m)break;pos=i;
		if(vis[id[i]])update(1,id[i],_next[i]);
		else vis[id[i]]=true,update(1,id[i],_next[i]),ans++;
	}//先将当前集合塞满
	for(int i=pos+1;i<=n;i++)
	{
		if(vis[id[i]])
		{
			update(1,id[i],_next[i]);//有数直接更新
		}
		else 
		{
			int num=t[1].id;
			vis[num]=false,update(1,num,0);//赋值为极小值
			vis[id[i]]=true,update(1,id[i],_next[i]);
			
			ans++;
		}
	}

	printf("%d",ans);
}
```

## 总结

此题用线段树动态维护一个集合内**最大元素下标**的方式，可以学习！



---

## 作者：hovny (赞：1)

## [题面](https://www.luogu.com.cn/problem/P4404)

## 解题思路

**优先队列&贪心**

### 分析

一开始给的数据范围过大，先离散化 $\to$ ~~直接上板子~~  
接着有显然的结论，删去 $Cache$ 中再出现的位置最后的元素是最优的，只要用 $priority\_queue$ 维护即可

**如何证明贪心的正确性** 

~~真·显然~~，如果删去再出现位置较前的，当做到这个位置 $i$ 时需要重新加入一次，而删去较后的元素，在 $i$ 位置时，就不需要重新加入

**关于优先队列**

优先队列维护最大值可以说是静态的，当比较的关键字在外部改变时，优先队列内部是不会做出调整的  
比如，优先队列中比较关键字为 `f[x]`，如果 `f[x]` 在该元素插入之后改变，该元素在优先队列内部的顺序不会改变  
不仅如此，随之带来的一系列迷之操作根本停不下来

### warning

就算一个值已经出现在了 $Cache$ 中，相应的信息也要更新

## Code

```cpp
#include<bits/stdc++.h>
#define rgt register
#define rint rgt int
#define LL long long
#define rll rgt LL
#define inf 0x7f7f7f7f
#define N 1000007
using namespace std;
template<class K>inline bool cmax(K&a,const K&b){return (a<b)?a=b,1:0;}
template<class K>inline bool cmin(K&a,const K&b){return (a>b)?a=b,1:0;}
inline int read() {
	rint s=0;
	rgt char c=getchar();
	while(!isdigit(c)) c=getchar();
	while(isdigit(c)) s=(s<<1)+(s<<3)+c-'0',c=getchar();
	return s;
}
int n,m,t,p[N],b[N],f[N],ls[N],ans;
bool vis[N];
struct cmp{
	inline bool operator() (const int a,const int b) {
		return f[a]<f[b];
	}
};
priority_queue<int,vector<int>,cmp>P;//重载运算符，根据一个元素下一次出现的位置
int main()
{
	rint i;n=read(),m=read();
	for(i=1;i<=n;i++) p[i]=b[i]=read();
	sort(p+1,p+n+1),t=unique(p+1,p+n+1)-p-1;
	for(i=1;i<=n;++i) b[i]=lower_bound(p+1,p+t+1,b[i])-p;//离散化
	memset(ls,inf,(t+1)<<2);
	for(i=n;i;--i) f[i]=ls[b[i]],ls[b[i]]=i;//下一次出现的位置
	for(i=1,t=0;i<=n;i++) {
		if(vis[b[i]]) {P.push(i);continue;}//存在于Cache中也要更新
		if(t<m) ++t;
		else vis[b[P.top()]]=0,P.pop();
		++ans,vis[b[i]]=1,P.push(i);
	}printf("%d",ans);
	return 0;
}
```



---

## 作者：free_fall (赞：0)

题目要求对于每一次访问，Cache 里都有对应的值，若没有，加入到 Cache 中，答案加一，若 Cache 已满，移除一个值并加入它，答案加一。

因为我们访问主存单元的编号顺序已知，唯一对答案可以产生影响的就是移出 Cache 的值的选择这一过程。

我们继续思考它的性质，假设我当前从 Cache 中取出了一个值 $x$，但是取出 $y$ 的结果比它更优，说明之后我们需要访问 $x$，而且 $x$ 的值在下一个 $y$ 的前面，导致移出 $x$ 之后又多了加入 $x$ 这一操作。

简单来说就是这么一个贪心性质，在 Cache 中，下一个对应的值越靠后，移出这个值就越优，因为它被访问到的可能更小。于是我们做这样一个贪心：每次取出 Cache 中下一个对应的值的下标最大的元素。

我们用 $las_i$ 记录下标为 $i$ 的值的下一个对应的值的下标为 $las_i$，如果没有这样一个值 $las_i=n+1$。用线段树维护 Cache 中 $las_i$ 最大的值的下标，操作时单点修改即可。

时间复杂度为 $O(n \log n)$，详细实现见代码。
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+5;
int n,m,a[N],b[N],uni,ans,cnt,las[N],mark[N];
struct seg_tree{
	#define ls p<<1
	#define rs p<<1|1
	int t[N<<2];
	void push_up(int p){
		t[p]=t[ls];
		if(mark[t[rs]]>mark[t[p]])t[p]=t[rs];
		return;
	}
	void build(int p,int l,int r){
		if(l==r){
			t[p]=l;
			return;
		}
		int mid=l+r>>1;
		build(ls,l,mid);
		build(rs,mid+1,r);
		push_up(p);
		return;
	}
	void change(int p,int l,int r,int x,int c){
		if(l==r){
			mark[l]=c;
			return;
		}
		int mid=l+r>>1;
		if(x<=mid)change(ls,l,mid,x,c);
		if(mid<x)change(rs,mid+1,r,x,c);
		push_up(p);
		return;
	}
	#undef ls
	#undef rs
}seg;
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
		b[i]=a[i];
	}
	sort(b+1,b+n+1);
	uni=unique(b+1,b+n+1)-b-1;
	for(int i=1;i<=n;i++){
		a[i]=lower_bound(b+1,b+uni+1,a[i])-b;
	}
	for(int i=n;i>=1;i--){
		if(mark[a[i]])las[i]=mark[a[i]];
		else las[i]=n+1;
		mark[a[i]]=i;
	}
	memset(mark,0,sizeof mark);
	seg.build(1,1,uni);
	for(int i=1;i<=n;i++){
		if(mark[a[i]]){
			seg.change(1,1,uni,a[i],las[i]);
			continue;
		}
		if(cnt<m){
			seg.change(1,1,uni,a[i],las[i]);
			cnt++,ans++;
			continue;
		}
		int id=seg.t[1];
		seg.change(1,1,uni,id,0);
		seg.change(1,1,uni,a[i],las[i]);
		ans++;
	}
	printf("%d",ans);
	return 0;
}
```

---

## 作者：Yansuan_HCl (赞：0)

贪心策略：每次需要换出去一个单元的时候，移出下次访问最远的。如果选一个更近的换出去，那有可能需要再把它更多次地换进来。

可以用一个平衡树找出下次访问最远的点，这里使用 `std::set`。

```cpp
const int N = 100005;

int n, m, k;
int a[N], lsh[N];
int ord(int x) { return lower_bound(lsh + 1, lsh + k, x) - lsh; }

BS<int> pos[N]; // i号主存的被访问时间
int front[N];
set<pair<int, int>, greater<pair<int, int>>> cache;
// {next_access, id}
bool inCache[N];

int main() {
    rd(n, m);
    for (int i = 1; i <= n; ++i) {
        rd(a[i]); lsh[i] = a[i];
    }
    sort(lsh + 1, lsh + n + 1);
    k = unique(lsh + 1, lsh + n + 1) - lsh;

    for (int i = 1; i <= n; ++i) {
        pos[ord(a[i])] += i;
    }
    for (int i = 1; i < k; ++i) pos[i] += 114514;

    int ans = 0;
    for (int i = 1; i <= n; ++i) {
        int id = ord(a[i]);
        if (inCache[id]) {
            auto it = cache.find({i, id});
            cache.erase(it);
            ++front[id];
            cache.insert({pos[id][front[id]], id});
            continue;
        }
        ++front[id];
        ++ans;
        if (cache.size() == 1u * m) {
            int x = cache.begin()->second;
            inCache[x] = 0;
            cache.erase(cache.begin());
        }
        inCache[id] = 1;
        cache.insert({pos[id][front[id]], id});
    }
    printf("%d", ans);
}
```

---


# 【XR-1】柯南家族

## 题目背景

xht37 最近沉迷于名侦探柯南。

在某集中，小兰又在怀疑柯南的真实身份了。为了让小兰不再怀疑，柯南编造出自己的家族背景来应对小兰的询问。

## 题目描述

这个家族一开始只有一个人，后来不断有人有了孩子，直到现在，这个家族有 $n$ 个人，第 $n$ 个人正是柯南。易知这个家族构成了一个 $n$ 个点的树形结构。

柯南为了使自己编造的家庭背景更加真实，他给家族中的每个人赋予了一个**智商值**。但是，一个人的**聪明程度**不仅仅只与他的**智商值**有关，还可能与他**祖先的聪明程度**及他**出生的时代**有关。

具体来说，在这个家族中，A 比 B 聪明**当且仅当** A 和 B 满足下面三种情况中的某一种：

1. A 的智商值比 B 的智商值高；
2. A 的智商值与 B 的智商值一样且 A 和 B 有不同的父亲，A 的父亲比 B 的父亲聪明；
3. A 的智商值与 B 的智商值一样且 A 和 B 的父亲是同一个人或某一个人没有父亲，A 比 B 后出生。

有一个很显然的结论是，这个家族中不会有两个人一样聪明。

柯南需要回答小兰的 $q$ 个询问。为了方便说明，假设第 $i$ 个出生的人编号为 $i$。

每个询问是下面三种情况中的某一种：

1. `1 x`：询问编号为 $x$ 的人在整个家族中聪明程度排第几。
2. `2 x k`：询问编号为 $x$ 的人及其祖先中第 $k$ 聪明的人的编号。
3. `3 x k`：询问编号为 $x$ 的人及其后代中第 $k$ 聪明的人的编号。

柯南还有许多案子要办，他不想在回答小兰的问题上浪费时间，他希望你能编程帮他回答小兰的所有询问。

## 说明/提示

【样例说明】

形成的树如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/eie1mrxb.png)

首先比较编号为 $2,3$ 的两个人，由于** $3$ 号的智商值与 $2$ 号的智商值一样且他们的父亲是同一个人，$3$ 号比 $2$ 号后出生**满足第 $3$ 种情况，因此 $3$ 号比 $2$ 号聪明。

再比较编号为 $4,5$ 的两个人，由于** $4$ 号的智商值与 $5$ 号的智商值一样且他们有不同的父亲，$4$ 号的父亲 $3$ 号比 $5$ 号的父亲 $2$ 号聪明**满足第 $2$ 种情况，因此 $4$ 号比 $5$ 号聪明。

再比较编号为 $1,5$ 的两个人，由于** $5$ 号的智商值与 $1$ 号的智商值一样且 $1$ 号没有父亲，$5$ 号比 $1$ 号后出生**满足第 $3$ 种情况，因此 $5$ 号比 $1$ 号聪明。

再根据第 $1$ 种情况比较编号为 $2,4$ 的两个人，可对 $5$ 人的聪明程度排序：$3 > 2 > 4 > 5 > 1$。

【数据规模与约定】

一共 $10$ 个测试点。

对于前 $20\%$ 的数据，$1 \le n, q \le 10 ^ 3$，每个测试点 $7$ 分，时限 1s。

对于另 $20\%$ 的数据，保证一个人最多只有一个儿子，每个测试点 $9$ 分，时限 4s。

对于另 $20\%$ 的数据，$1 \le n, q \le 10 ^ 5$，每个测试点 $9$ 分，时限 1.5s。

对于另 $20\%$ 的数据，保证只有第一种询问，每个测试点 $12$ 分，时限 1.5s。

对于 $100\%$ 的数据，$1 \le n, q \le 5 \times 10 ^ 5$，$1 \le a_i \le 10 ^ 9$，每个测试点 $13$ 分，时限 2.5s。

## 样例 #1

### 输入

```
5 11
1 1 3 2
1 2 2 1 1
1 1
1 2
1 3
1 4
1 5
2 4 1
2 5 3
3 1 1
3 1 2
3 1 3
3 1 4```

### 输出

```
5
2
1
3
4
3
1
3
2
4
5```

# 题解

## 作者：xht (赞：32)

题目地址：[P5346 【XR-1】柯南家族](https://www.luogu.org/problemnew/show/P5346)

Q：官方题解会咕么？

A：不会！~~（大雾~~

## 题解环节

首先，我们假设已经求出了 $n$ 个人聪明程度的排名。

$op = 1$ 是可以 $O(1)$ 回答的。

对于 $op = 2$ 和 $op = 3$，由于求第 $k$ 大很容易想到主席树。

$op = 2$ 只需要在节点的父亲版本上更新即可。

$op = 3$ 只需要按照 $dfs$ 序更新即可。

那么 $op = 2$ 和 $op = 3$ 可以做到单次 $O(\log n)$ 回答。

以上都挺套路的，现在的问题在于，如何 $sort$。

### 算法一：暴力

直接模拟比较方式即可，这里给出比较函数。

```cpp
inline bool cmp(int x, int y) {
	int fx = x, fy = y;
	while (fx != fy && a[fx] == a[fy]) {
		x = fx, y = fy;
		fx = f[fx], fy = f[fy];
	}
	return a[fx] < a[fy] || (a[fx] == a[fy] && x < y);
}
```

然后直接调用 $sort$ 函数即可，时间复杂度 $O(n^2)$，期望得分 $14$ 分。

### 算法二：树上倍增 + 哈希

这是应该算是对暴力的优化。

```cpp
//g[x]:log(x)
//d[x]:x的深度
//h[x]:从根节点到x的哈希值
//f[i][x]:树上倍增中x的第i祖先
//H(x,y):x到y的哈希值
inline bool cmp(int x, int y) {
	int w = g[min(d[x],d[y])];
	if (h[x] != h[y]) {
		for (int i = w; ~i; i--)
			if (H(f[i][x], x) == H(f[i][y], y)) {
				x = f[0][f[i][x]];
				y = f[0][f[i][y]];
			}
		if (a[x] == a[y]) {
			x = f[0][x];
			y = f[0][y];
		}
		return a[x] < a[y];
	} else {
		for (int i = w; ~i; i--)
			if (f[i][x] != f[i][y]) {
				x = f[i][x];
				y = f[i][y];
			}
		return x < y;
	}
}
```

需要预处理一大堆东西，然后仍然直接调用 $sort$ 函数即可，时间复杂度 $O(n \log ^ 2 n)$，期望得分 $32$ 分。

~~没错，两只 $\log$ 很成功的被我卡掉了。~~

### 算法三：后缀排序 SA

考虑部分分：

> 对于另 $20\%$ 的数据，保证一个人最多只有一个儿子，每个测试点 $9$ 分，时限 4s。

即整个家族形成一条链。

那么其实这就是一个以 $n$ 节点为头，根节点为尾的字符串，而题目所要求的其实就是后缀排序。

由于智商值的规模高达 $10^9$ ，离散化一下，然后使用 SA 进行排序即可，时间复杂度 $O(n \log n)$ ，期望得分 $18$ 分，结合方法二可以得到 $50$ 分。

### 算法四：

看一眼数据范围 $1 \le n \le 5 \times 10 ^ 5$，这显然要求我们用一种 $O(n \log n)$ 的算法进行排序。

受到方法三的启发，我们能不能把 SA 搬到树上呢？

于是，我们需要引入**树上 SA**。

### 模板：[【模板】树上后缀排序](https://www.luogu.org/problemnew/show/P5353)

~~为了写篇题解我还造了道模板题。~~

我们尝试把普通 SA 改成树上 SA，所以先把普通 SA 贴上来。

```cpp
namespace SA {
    int sa[N], rk[N], tp[N], tx[N];
    
    inline void tsort() {
        for (int i = 1; i <= m; i++) tx[i] = 0;
        for (int i = 1; i <= n; i++) ++tx[rk[i]];
        for (int i = 1; i <= m; i++) tx[i] += tx[i-1];
        for (int i = n; i; i--) sa[tx[rk[tp[i]]]--] = tp[i];
    }

    inline bool pd(int i, int w) {
        return tp[sa[i-1]] == tp[sa[i]] && tp[sa[i-1]+w] == tp[sa[i]+w];
    }

    inline void main() {
        for (int i = 1; i <= n; i++) rk[i] = s[i] - 'a' + 1, tp[i] = i;
        tsort();
        for (int w = 1, p = 0; p < n; w <<= 1, m = p) {
            p = 0;
            for (int i = 1; i <= w; i++) tp[++p] = n - w + i;
            for (int i = 1; i <= n; i++) if (sa[i] > w) tp[++p] = sa[i] - w;
            tsort(), swap(rk, tp), rk[sa[1]] = p = 1;
            for (int i = 2; i <= n; i++) rk[sa[i]] = pd(i, w) ? p : ++p;
        }
    }
}
```

想要把普通 SA 改成树上 SA，仔细观察上面的代码可以发现：

1. $tsort$ 函数肯定是不用改的；
2. $pd$ 函数可以用树上倍增实现；
3. $main$ 函数似乎也很好改？

于是开始改改改，突然发现有个问题：**由于序列上每个后缀长度都不一样，所以不可能出现完全相同的字符串，可是在树上是可能出现这种情况的。**

然后就没办法了么？

办法肯定是有的~~要不然这道题是咋出出来的~~。

我们来思考一下，在倍增的每一轮，**基数排序**究竟要达到什么目的？

对于普通 SA，在倍增的每一轮，假设已经对所有长度为 $x$ 的串排好序了。“第一关键字”和“第二关键字”代表了两个首尾相接的长度为 $x$ 的串，称为“主串”和“次串”。基数排序通过 $O(n)$ 的时间，将每一对“主串”和“次串”**合并**成一个长度为 $2x$ 的新串并保持合并后**有序**。

这样可以保证 $O(\log n)$ 次后，所有后缀呈有序状态。

对于树上 SA，也是同样的。只不过，除了“主串”作为第一关键字，“次串”作为第二关键字以外，为了保证合并后的有序性，我们还要额外将上一轮的有序状态作为第三关键字。同时第二关键字也不能简单地用原先的 $rk$ 数组构造（因为 $rk$ 数组会出现相同的排名），而要额外使用没有重复的数组（下面代码中的 $rkk$ 数组）构造。

总而言之，我们需要使用两次基数排序来达到目的，具体实现请参考代码~~因为这说得实在是太抽象了~~：

```cpp
namespace SA {
    int sa[N], rk[N], rkk[N], tp[N], rk2[N], tx[N];

    inline void tsort(int *sa, int *rk, int *tp, int m) {
        for (int i = 0; i <= m; i++) tx[i] = 0;
        for (int i = 1; i <= n; i++) ++tx[rk[i]];
        for (int i = 1; i <= m; i++) tx[i] += tx[i-1];
        for (int i = n; i; i--) sa[tx[rk[tp[i]]]--] = tp[i];
    }

    inline bool pd(int i, int t) {
        return tp[sa[i-1]] == tp[sa[i]] && tp[f[t][sa[i-1]]] == tp[f[t][sa[i]]];
    }

    inline void main() {
        int p = 0;
        for (int i = 1; i <= n; i++) a[i] = s[i] - 'a' + 1, tp[i] = i;
        tsort(sa, a, tp, n);
        rk[sa[1]] = rkk[sa[1]] = p = 1;
        for (int i = 2; i <= n; i++) {
            rk[sa[i]] = a[sa[i-1]] == a[sa[i]] ? p : ++p;
            rkk[sa[i]] = i;
        }
        for (int w = 1, t = 0; w < n; w <<= 1, ++t) {
            for (int i = 1; i <= n; i++) rk2[i] = rkk[f[t][i]];
            tsort(tp, rk2, sa, n);
            tsort(sa, rk, tp, p);
            swap(rk, tp);
            rk[sa[1]] = rkk[sa[1]] = p = 1;
            for (int i = 2; i <= n; i++) {
                rk[sa[i]] = pd(i, t) ? p : ++p;
                rkk[sa[i]] = i;
            }
        }
    }
}
```

~~当然也许还有其他写法。~~

有了树上 SA，原题就很简单了~~就是个板子~~，下面贴上 std：

```cpp
#include <bits/stdc++.h>
using namespace std;

namespace IO {
	const int SIZE = (1 << 21) + 1;
	char ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55];
	int f, qr;
#define gc() (iS == iT ? (iT = (iS = ibuf) + fread(ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS++)) : *iS++)

	inline void flush() {
		fwrite(obuf, 1, oS - obuf, stdout);
		oS = obuf;
	}

	inline void putc(char x) {
		*oS++ = x;
		if (oS == oT) flush();
	}

	template <class I>
	inline void rd(I &x) {
		for (f = 1, c = gc(); c < '0' || c > '9'; c = gc())
			if (c == '-') f = -1;
		for (x = 0; c <= '9' && c >= '0'; c = gc())
			x = x * 10 + (c & 15);
		x *= f;
	}

	template <class I>
	inline void print(I x) {
		if (!x) putc('0');
		if (x < 0) putc('-'), x = -x;
		while (x) qu[++qr] = x % 10 + '0', x /= 10;
		while (qr) putc(qu[qr--]);
		putc('\n');
	}

	struct Flusher_ {
		~Flusher_() {
			flush();
		}
	} io_flusher_;
}
using IO::rd;
using IO::print;

const int N = 5e5 + 6;
int n, q, f[21][N], a[N], b[N];
vector<int> e[N];

namespace SA {
	int sa[N], rk[N], rkk[N], tp[N], rk2[N], tx[N];

	inline void tsort(int *sa, int *rk, int *tp, int m) {
		for (int i = 0; i <= m; i++) tx[i] = 0;
		for (int i = 1; i <= n; i++) ++tx[rk[i]];
		for (int i = 1; i <= m; i++) tx[i] += tx[i-1];
		for (int i = n; i; i--) sa[tx[rk[tp[i]]]--] = tp[i];
	}

	inline bool pd(int i, int t) {
		return tp[sa[i-1]] == tp[sa[i]] && tp[f[t][sa[i-1]]] == tp[f[t][sa[i]]];
	}

	inline void main() {
		int p = 0;
		for (int i = 1; i <= n; i++) tp[i] = i;
		tsort(sa, a, tp, n);
		rk[sa[1]] = rkk[sa[1]] = p = 1;
		for (int i = 2; i <= n; i++) {
			rk[sa[i]] = a[sa[i-1]] == a[sa[i]] ? p : ++p;
			rkk[sa[i]] = i;
		}
		for (int w = 1, t = 0; w < n; w <<= 1, ++t) {
			for (int i = 1; i <= n; i++) rk2[i] = rkk[f[t][i]];
			tsort(tp, rk2, sa, n);
			tsort(sa, rk, tp, p);
			swap(rk, tp);
			rk[sa[1]] = rkk[sa[1]] = p = 1;
			for (int i = 2; i <= n; i++) {
				rk[sa[i]] = pd(i, t) ? p : ++p;
				rkk[sa[i]] = i;
			}
		}
		for (int i = 1; i <= n; i++) a[i] = rkk[i];
	}
}

namespace Seg {
	struct T {
		int l, r, c;
	} t[2][N*20];
	int tot[2], rt[2][N], dfn[N], s[N], num;

	inline int ins(int o, int p, int l, int r, int x) {
		int q = ++tot[o];
		t[o][q] = t[o][p];
		++t[o][q].c;
		if (l ^ r) {
			int mid = (l + r) >> 1;
			if (x <= mid) t[o][q].l = ins(o, t[o][p].l, l, mid, x);
			else t[o][q].r = ins(o, t[o][p].r, mid + 1, r, x);
		}
		return q;
	}

	inline int ask(int o, int p, int q, int l, int r, int k) {
		if (l == r) return l;
		int mid = (l + r) >> 1, rc = t[o][t[o][q].r].c - t[o][t[o][p].r].c;
		if (k <= rc) return ask(o, t[o][p].r, t[o][q].r, mid + 1, r, k);
		return ask(o, t[o][p].l, t[o][q].l, l, mid, k - rc);
	}

	inline void dfs(int x) {
		dfn[x] = ++num;
		rt[1][num] = ins(1, rt[1][num-1], 1, n, a[x]);
		s[x] = 1;
		for (unsigned int i = 0; i < e[x].size(); i++) {
			int y = e[x][i];
			rt[0][y] = ins(0, rt[0][x], 1, n, a[y]);
			dfs(y);
			s[x] += s[y];
		}
	}

	inline void main() {
		rt[0][1] = ins(0, 0, 1, n, a[1]);
		dfs(1);
		while (q--) {
			int o, x;
			rd(o), rd(x);
			if (o == 1) print(n + 1 - a[x]);
			else {
				int k;
				rd(k);
				if (o == 2) print(SA::sa[ask(0, 0, rt[0][x], 1, n, k)]);
				else print(SA::sa[ask(1, rt[1][dfn[x]-1], rt[1][dfn[x]+s[x]-1], 1, n, k)]);
			}
		}
	}
}

int main() {
	rd(n), rd(q);
	for (int i = 2; i <= n; i++) {
		rd(f[0][i]);
		e[f[0][i]].push_back(i);
	}
	int t = 0;
	bool flag = 1;
	while (flag && ++t) {
		flag = 0;
		for (int i = 1; i <= n; i++)
			if ((f[t][i] = f[t-1][f[t-1][i]])) flag = 1;
	}
	for (int i = 1; i <= n; i++) {
		rd(a[i]);
		b[i] = a[i];
	}
	sort(b + 1, b + n + 1);
	int p = unique(b + 1, b + n + 1) - (b + 1);
	for (int i = 1; i <= n; i++)
		a[i] = lower_bound(b + 1, b + p + 1, a[i]) - b;
	SA::main();
	Seg::main();
	return 0;
}
```

~~代码不长，也就 $4k$。~~

### 算法五：

比赛时有两个人 AC 了此题：[租酥雨](https://www.luogu.org/space/show?uid=47654)，[究极龙骑士](https://www.luogu.org/space/show?uid=47803)。

先 Orz ~~这叫官方膜拜。~~

他们用的都是替罪羊树维护~~不知道是不是叫后缀平衡树~~。

~~然而我甚至不会替罪羊树。~~

这个方法现在已知有两个人写了题解：[Owen_codeisking](https://www.luogu.org/blog/Owencodeisking/solution-p5346)，[dsidsi](https://blog.csdn.net/DSL_HN_2002/article/details/89854445)。

那我就不写了~~反正本来就不会。~~

总结一下这两篇题解的共性：都参考[租酥雨](https://www.luogu.org/space/show?uid=47654)的代码~~还都 diss 了窝（委屈~~。

## 故事环节

### idea 来源

~~凭空想到的。~~

一开始的想法是，树上**倍增**和 SA 的**倍增**可以结合一下嘛。

然后后来就搞出了树上 SA 这么个东西。

后来 World Final 有道题似乎要用树上 SA ~~不过听说被出题人对着卡？~~

当时还因为奶中了 WF 的算法兴奋了好一阵子。

~~然后省选就凉了。~~

### 彩蛋

不知道大家有没有发现本场比赛的彩蛋呢？

本场比赛的日期是 05-04，这个日期是不是有什么特殊的意义呢？

> 江户川柯南：真实身份是高中生侦探工藤新一。$17$ 岁，因服下毒药身体变小后约 $7$ 岁。生日是 $5$ 月 $4$ 日，来源于 $1891$ 年 $5$ 月 $4$ 日福尔摩斯和莫里亚蒂教授坠入莱辛巴赫瀑布的日期。
> 
> 工藤新一： $17$ 岁的高中生侦探。生日为 $5$ 月 $4$ 日，来源于《福尔摩斯探案集之最后一案》中， $1891$ 年 $5$ 月 $4$ 日福尔摩斯和莫里亚蒂教授在莱辛巴赫瀑布展开对决，莫里亚蒂掉到瀑布里死亡，福尔摩斯生还。

**祝柯南和新一生日快乐！**

没了么？

~~还有么？~~

这是 xht37 在洛谷的个人信息：

> - **用户 ID** 100544
> - **用户类型** 普通用户
> - **注册时间** 2018-05-04 08:29

**xht37 来洛谷已经整整一年啦 QwQ**

---

## 作者：NeosKnight (赞：6)

首先一看题,裸题啊,还不带修! 这个不是求出每一个点的排名后,祖先链上建主席树,子树里就线段树合并就做完了吗。

稍微详细一点就是: 用可持久化线段树维护当前存在的排名,每个节点上记录一下当前子树内的已有排名个数,询问的时候在线段树上走就行了。

~~(然后你发现你不会排序...这个真自闭了,明明马上就要切了但是被这个东西摆一道。)~~

首先的想法是按照深度顺序依次排序,这样对于需要比较父亲的排名时就能够直接O(1)得到了，但是这个样子不能直接暴力合并排名,复杂度会不对。

于是我们祭出后缀平衡树对于此类问题的做法,当我们要快速取得平衡树中两个点的先后关系时采用给每一个点赋一个权值的方式。

比如说权值范围在 (0,1) 中取,那么根节点的权值就是 0.5 它的左右儿子的权值范围分别变成 (0,0.5) , (0.5,1)

这样我们就可以 O(1) 的比较出两个点的大小关系了。实现上写一个替罪羊树就很方便了。

整理一下流程就是先用 替罪羊树+赋予节点权值的方式实现对节点的排序,然后再使用可持久化线段树得到答案。(大暴力解法)

复杂度$O(nlogn)$

代码:
```code
#include<bits/stdc++.h>
using namespace std;
#define Set(a,b) memset(a,b,sizeof(a))
template<class T>inline void init(T&x){
	x=0;char ch=getchar();bool t=0;
	for(;ch>'9'||ch<'0';ch=getchar()) if(ch=='-') t=1;
	for(;ch>='0'&&ch<='9';ch=getchar()) x=(x<<1)+(x<<3)+(ch-48);
	if(t) x=-x;return;
}typedef long long ll;
const int N=5e5+10;
const int MAXN=2e7+10;
int rk[N];int ls[MAXN],rs[MAXN],size[MAXN],cnt=0;
int id[N],rt1[N],rt2[N],fa[N],IQ[N];
int n,q;
struct edge{int to,next;}a[N];
int head[N];
inline void add(int x,int y){a[++cnt]=(edge){y,head[x]};head[x]=cnt;}
int ans[N];
typedef pair<int,int> PA;
vector<PA> Q1[N];
vector<PA> Q2[N];
int HEAD=0;
#define MID (l+r)>>1
inline void Insert(int&u,int l,int r,int p){
	++cnt;ls[cnt]=ls[u],rs[cnt]=rs[u],size[cnt]=size[u];
	u=cnt;++size[u];
	if(l==r) return;
	int mid=MID;
	if(mid>=p) Insert(ls[u],l,mid,p);
	else       Insert(rs[u],mid+1,r,p);
	return;
}
int Query(int u,int l,int r,int K){
	if(!u) return 0;if(l==r) return l;
	int mid=MID;
	if(size[ls[u]]>=K) return Query(ls[u],l,mid,K);
	return Query(rs[u],mid+1,r,K-size[ls[u]]);
}
int Merge(int u,int v,int l,int r){
	if(!u||!v)return u|v;size[u]+=size[v];
	if(l==r) return u;int mid=MID;
	ls[u]=Merge(ls[u],ls[v],l,mid);
	rs[u]=Merge(rs[u],rs[v],mid+1,r);
	return u;
}
void Dfs(int u){
	Insert(rt2[u],1,n,rk[u]);
	for(PA P:Q1[u]) {int ID=P.second;int K=P.first;ans[ID]=id[Query(rt1[u],1,n,K)];}
	for(int v,i=head[u];i;i=a[i].next) {
		v=a[i].to;
		rt1[v]=rt1[u];Insert(rt1[v],1,n,rk[v]);
		Dfs(v);
		rt2[u]=Merge(rt2[u],rt2[v],1,n);
	}
	for(PA P:Q2[u]) {
		int ID=P.second;int K=P.first;
		ans[ID]=id[Query(rt2[u],1,n,K)];
	}return;
}

namespace SORT{
	typedef double db;
	int dep[N];const double alpha=0.75;
	int ls[N],rs[N],size[N];int rt=0;double val[N];
	queue<int> Q;bool mark[N];
	inline bool cmp(int i,int j){
		if(IQ[i]!=IQ[j]) return IQ[i]>IQ[j];
		if(fa[i]&&fa[j]&&fa[i]!=fa[j]) return (IQ[fa[i]]>IQ[fa[j]]||val[fa[i]]<val[fa[j]]);
		return i>j;
	}
	inline bool Jud(int u){
		const int LIM=size[u]*alpha;
		if(!LIM) return 0;
		if(LIM<=size[ls[u]]||LIM<=size[rs[u]]) return 1;
		return 0;
	}
	int stk[N];int top=0;
	void dfs1(int u){if(!u) return;dfs1(ls[u]);stk[++top]=u;dfs1(rs[u]);return;}
	void dfs2(int&u,int l,int r,db L,db R){
		if(l>r) {u=0;return;}
		int mid=MID;u=stk[mid];
		db Mid=(L+R)/2.0;val[u]=Mid;
		dfs2(ls[u],l,mid-1,L,Mid);
		dfs2(rs[u],mid+1,r,Mid,R);
		size[u]=1+size[ls[u]]+size[rs[u]];
		return;
	}
	inline void Rebuild(int&u,db l,db r){top=0;dfs1(u);dfs2(u,1,top,l,r);return;}
	void Insert(int&u,db L,db R,int v,bool reb){
		if(!u) {u=v;val[v]=(L+R)/2;size[u]=1;return;}
		++size[u];bool Reb=0;
		if(reb&&Jud(u)) Reb=1;
		if(cmp(v,u)) Insert(ls[u],L,(L+R)/2.0,v,Reb^1);
		else         Insert(rs[u],(L+R)/2.0,R,v,Reb^1);
		if(Reb) Rebuild(u,L,R);return;
	}
	void Dfs(int u){
		if(!u) return;
		Dfs(ls[u]);
		id[++HEAD]=u,rk[u]=HEAD;
		Dfs(rs[u]);
		return;
	}
	void Work(){
		Q.push(1);
		while(!Q.empty()) {
			int u=Q.front();Q.pop();Insert(rt,0,1.0,u,1);
			for(int v,i=head[u];i;i=a[i].next) {v=a[i].to;Q.push(v);}
		}HEAD=0;Dfs(rt);
	}
}
int main()
{
	init(n),init(q);
	for(int i=2;i<=n;++i) init(fa[i]),add(fa[i],i);
	for(int i=1;i<=n;++i) init(IQ[i]),id[i]=i;
	SORT::Work();
	cnt=0;
	for(int i=1;i<=q;++i) {
		int op;init(op);
		int x,k;init(x);
		if(op==1) ans[i]=rk[x];
		else {
			init(k);
			if(op==2) Q1[x].push_back(PA(k,i));
			else      Q2[x].push_back(PA(k,i));
		}
	}Insert(rt1[1],1,n,rk[1]);
	Dfs(1);
	for(int i=1;i<=q;++i) printf("%d\n",ans[i]);
	return 0;
}

```

---

## 作者：y2823774827y (赞：4)

**更好的阅读体验$\Longrightarrow $[Blog](https://i.cnblogs.com/PostDone.aspx?postid=10820513&actiontip=%E4%BF%9D%E5%AD%98%E4%BF%AE%E6%94%B9%E6%88%90%E5%8A%9F)**
## 题目
[P5346 【XR-1】柯南家族](https://www.luogu.org/problemnew/show/P5346)
## 做法
聪明性是具有传递性的，且排列是固定的
那么先预处理出每个点的名次，用主席树维护$k$大值

一眼平衡树，遍历的同时插入$O(log^2n)$，总时间复杂度$O(nlog^2n)$

显然还需要优化，考虑两个点的比较：按深度递减比较值，如果在等长前提下值相等，则比较深度最浅且的不一样的祖先的大小

这和后缀比较大小相似，我们后缀数组来实现排列的这个过程
## Code
```cpp
#include<bits/stdc++.h>
typedef int LL;
const LL maxn=1e6+9;
inline LL Read(){
	LL x(0),f(1); char c=getchar();
	while(c<'0' || c>'9'){
		if(c=='-') f=-1; c=getchar();
	}
	while(c>='0' && c<='9'){
		x=(x<<3)+(x<<1)+c-'0'; c=getchar();
	}return x*f;
}
struct node{
	LL to,nxt;
}dis[maxn];
LL n,num,q,m,tim;
LL head[maxn],fa[maxn],a[maxn],sa[maxn],x[maxn],y[maxn],z[maxn],c[maxn],rk[maxn],inc[maxn][25],b[maxn],dfn[maxn],low[maxn];
inline void Add(LL u,LL v){
	dis[++num]=(node){v,head[u]}; head[u]=num;
}
inline void Sort(){
	for(LL i=1;i<=n;++i) ++c[x[i]=a[i]];
    for(LL i=2;i<=m;++i) c[i]+=c[i-1];
    for(LL i=n;i>=1;--i) sa[c[x[i]]--]=i;
    for(LL i=1;i<=n;++i) rk[sa[i]]=i;
	for(LL len=1,t=0;len<n;len<<=1,++t){
		LL num(0);
		for(LL i=1;i<=n;++i) z[i]=rk[inc[i][t]];
		for(LL i=0;i<=n;++i) c[i]=0;
		for(LL i=1;i<=n;++i) ++c[z[i]]; for(LL i=1;i<=n;++i) c[i]+=c[i-1];
        for(LL i=n;i>=1;--i) y[c[z[sa[i]]]--]=sa[i];
		
		for(LL i=0;i<=m;++i) c[i]=0;
		for(LL i=1;i<=n;++i) ++c[x[i]]; for(LL i=1;i<=m;++i) c[i]+=c[i-1];
		for(LL i=n;i>=1;--i) sa[c[x[y[i]]]--]=y[i];
		for(LL i=1;i<=n;++i) rk[sa[i]]=i;
		std::swap(x,y);
		x[sa[1]]=num=1;
		for(LL i=2;i<=n;++i)
		    x[sa[i]]=(y[sa[i]]==y[sa[i-1]] && y[inc[sa[i]][t]]==y[inc[sa[i-1]][t]])?num:++num;
		if(num==n) break;
		m=num;
	}
}
struct Tree{
	LL root[maxn],nod,size[maxn*10],son[maxn*10][2];
	void Update(LL &now,LL pre,LL l,LL r,LL x){
		now=++nod; size[now]=size[pre]+1;
		if(l==r) return; LL mid(l+r>>1);
		if(x<=mid){ Update(son[now][0],son[pre][0],l,mid,x); son[now][1]=son[pre][1]; }
		else{ Update(son[now][1],son[pre][1],mid+1,r,x); son[now][0]=son[pre][0]; }
	}
	LL Query1(LL now,LL l,LL r,LL k){
		if(l==r) return sa[l]; LL mid(l+r>>1);
		LL ret(size[son[now][0]]);
		return k<=ret?Query1(son[now][0],l,mid,k):Query1(son[now][1],mid+1,r,k-ret);
	}
	LL Query2(LL pre,LL now,LL l,LL r,LL k){
		if(l==r) return sa[l]; LL mid(l+r>>1);
		LL ret(size[son[now][0]]-size[son[pre][0]]);
		return k<=ret?Query2(son[pre][0],son[now][0],l,mid,k):Query2(son[pre][1],son[now][1],mid+1,r,k-ret);
	}
}T1,T2;
void Fir(LL u){
	inc[u][0]=fa[u];
	for(LL i=1;i<=20;++i){
		inc[u][i]=inc[inc[u][i-1]][i-1]; if(!inc[u][i]) break;
	}
	for(LL i=head[u];i;i=dis[i].nxt) Fir(dis[i].to);
}
void Dfs(LL u){
	dfn[u]=++tim;
	T1.Update(T1.root[u],T1.root[fa[u]],1,n,rk[u]);
	T2.Update(T2.root[tim],T2.root[tim-1],1,n,rk[u]);
	for(LL i=head[u];i;i=dis[i].nxt) Dfs(dis[i].to);
	low[u]=tim;
}
inline void Init(){
	n=Read(); q=Read();
	for(LL i=2;i<=n;++i) Add(fa[i]=Read(),i);
	for(LL i=1;i<=n;++i) b[i]=a[i]=Read();
	std::sort(b+1,b+1+n); m=std::unique(b+1,b+1+n)-b-1;
	for(LL i=1;i<=n;++i) a[i]=std::lower_bound(b+1,b+1+m,a[i])-b;
}
int main(){
	Init();
	Fir(1);
	Sort();
	std::reverse(sa+1,sa+1+n);
	for(LL i=1;i<=n;++i) rk[sa[i]]=i;
	Dfs(1);
	while(q--){
		LL op(Read()),x(Read());
		if(op==1) printf("%d\n",rk[x]);
		else{
			LL k(Read());
			if(op==2) printf("%d\n",T1.Query1(T1.root[x],1,n,k));
		    else printf("%d\n",T2.Query2(T2.root[dfn[x]-1],T2.root[low[x]],1,n,k));
		}
	}
	return 0;
}
```

---

## 作者：dsidsi (赞：4)

因为这篇题解是首发，所以厚颜无耻地贴一下自己的[博客](https://blog.csdn.net/DSL_HN_2002/article/details/89854445)

# Solution

这里写的是 @租酥雨 在考场的写法。

显然，聪明程度的比较具有传递性。所以如果我们可以快速把每个人的聪明程度排序，然后就可以轻易的回答询问了。

考虑按找某种顺序往已经排好的序列添加一个数，满足它的父亲已经被比较了（比如直接按输入顺序）。

比较显然的一种方法是用平衡树维护这个序列，每次往平衡树中添加一个点。但是把一个点插入平衡树需要$O(logn)$次操作，每次比较是$O(logn)$的，总复杂度$O(nlog^2n)$，加上平衡树的大常数显然无法通过。

考虑优化比较的复杂度。我们为每一个人赋上一个$[0,1]$的实数权值，用这个来表示一个人的聪明程度，新加的人的权值为他前驱后继的平均值。但是直接这样会炸精度，所以我们考虑用替罪羊树，在重构的同时重构把权值平均分配。这样由于平衡树的树高是$O(logn)$的，所以我们$/2$的次数也是$O(logn)$的，就不会炸精度了。

至于询问是主席树基本操作就不讲了。

顺便说一句，小兰没有发现柯南家族的人都是一个人就可以繁殖后代吗？

```cpp
#include <bits/stdc++.h>
using namespace std;

inline int gi()
{
    char c = getchar();
    while (c < '0' || c > '9') c = getchar();
    int sum = 0;
    while ('0' <= c && c <= '9') sum = sum * 10 + c - 48, c = getchar();
    return sum;
}

const int maxn = 500005;
const double alpha = 0.7;

int n, q, fa[maxn], c[maxn];

int rt, lch[maxn], rch[maxn], siz[maxn], cnt, tmp[maxn];
double w[maxn];

void dfs(int u)
{
    if (lch[u]) dfs(lch[u]);
    tmp[++cnt] = u;
    if (rch[u]) dfs(rch[u]);
}

void build(int &u, int l, int r, double wl, double wr)
{
    int mid = (l + r) >> 1;
    u = tmp[mid]; w[u] = (wl + wr) / 2;
    if (l < mid) build(lch[u], l, mid - 1, wl, w[u]); else lch[u] = 0;
    if (mid < r) build(rch[u], mid + 1, r, w[u], wr); else rch[u] = 0;
    siz[u] = 1 + siz[lch[u]] + siz[rch[u]];
}

void rebuild(int &u, double l, double r) {cnt = 0; dfs(u); build(u, 1, cnt, l, r);}

inline bool cmp(int a, int b)
{
    if (c[a] != c[b]) return c[a] > c[b];
    else if (fa[a] && fa[b] && fa[a] != fa[b]) return w[fa[a]] < w[fa[b]];
    else return a > b;
}

void insert(int &u, int x, double l, double r, bool f)
{
    if (!u) return u = x, siz[u] = 1, w[x] = (l + r) / 2, void();
    ++siz[u];
    bool flg = 0;
    if (cmp(x, u)) {
        flg |= alpha * (siz[lch[u]] + 1) > siz[rch[u]];
        insert(lch[u], x, l, w[u], flg);
    } else {
        flg |= alpha * (siz[rch[u]] + 1) > siz[lch[u]];
        insert(rch[u], x, w[u], r, flg);
    }
    if (flg && !f) rebuild(u, l, r);
}

struct edge
{
    int to, next;
} e[maxn];
int h[maxn], rk[maxn], dfn[maxn], low[maxn], T, ecnt;

inline void add(int u, int v) {e[++ecnt] = (edge) {v, h[u]}; h[u] = ecnt;}

struct node
{
    int lch, rch, siz;
} s[maxn * 60];
int tot, rt1[maxn], rt2[maxn];

void modify(int &x, int l, int r, int p)
{
    ++tot; s[tot] = s[x]; ++s[x = tot].siz;
    if (l == r) return ;
    int mid = (l + r) >> 1;
    if (p <= mid) modify(s[x].lch, l, mid, p);
    else modify(s[x].rch, mid + 1, r, p);
}

int query(int x, int y, int l, int r, int k)
{
    if (l == r) return tmp[l];
    int mid = (l + r) >> 1;
    if (k > s[s[y].lch].siz - s[s[x].lch].siz) return query(s[x].rch, s[y].rch, mid + 1, r, k - (s[s[y].lch].siz - s[s[x].lch].siz));
    else return query(s[x].lch, s[y].lch, l, mid, k);
}

void t_dfs(int u)
{
    dfn[u] = ++T;
    rt1[u] = rt1[fa[u]]; modify(rt1[u], 1, n, rk[u]);
    rt2[T] = rt2[T - 1]; modify(rt2[T], 1, n, rk[u]);
    for (int i = h[u], v; v = e[i].to, i; i = e[i].next)
        if (v != fa[u]) t_dfs(v);
    low[u] = T;
}

int main()
{
    n = gi(); q = gi();
    for (int i = 2; i <= n; ++i) add(fa[i] = gi(), i);
    for (int i = 1; i <= n; ++i) {
        c[i] = gi();
        insert(rt, i, 0, 1, 0);
    }

    rebuild(rt, 0, 1);
    for (int i = 1; i <= n; ++i) rk[tmp[i]] = i;
    
    t_dfs(1);

    int tp, x;
    while (q--) {
        tp = gi(); x = gi();
        if (tp == 1) printf("%d\n", rk[x]);
        else if (tp == 2) printf("%d\n", query(0, rt1[x], 1, n, gi()));
        else printf("%d\n", query(rt2[dfn[x] - 1], rt2[low[x]], 1, n, gi()));
    }

    return 0;
}
```

---

## 作者：Owen_codeisking (赞：4)

讲一下后缀平衡树的做法。

昨天花了一个下午写了一个 $O(n\log^2 n)$ 的做法，怎么卡都卡不过去。 ~~脑子想一想两只log怎么过五十万~~

第 $k$ 大可以不用管它，因为其实你把大小关系排好后，加一个 $dfs$ 序主席树和树上路径前缀主席树就行了。

那么我们考虑如何比较两个人的聪明程度。

首先，这可以倍增。我们哈希一下，暴力跳到两个点权值不一样的祖先，然后按照题意模拟即可。

但是显然，这种方法不能 $O(1)$ 比较，瓶颈在比较两个父亲谁更聪明上。

这样的话，其实能想到后缀平衡树。话说刚学的东西都能忘掉，我也是厉害。

~~Owen友情提示：不要没看懂题面就说题目简单，分分钟打脸~~

我们直接暴力插进平衡树就行了。出题人用的是树上 $SA$，你可以去问他具体怎么做的。

~~zsy2K是怎么写完的~~

$Code\ Below:$

```cpp
// luogu-judger-enable-o2
#include <bits/stdc++.h>
using namespace std;
const int maxn=500000+10;
const double alpha=0.75;
int n,q,fa[maxn],a[maxn],rnk[maxn],ch[maxn][2],siz[maxn],s[maxn],top,rt;double val[maxn];
int st[maxn],ed[maxn],mp[maxn],tim,head[maxn],to[maxn],nxt[maxn],tot;

inline void addedge(int x,int y)
{
    to[++tot]=y;
    nxt[tot]=head[x];
    head[x]=tot;
}
void dfs(int x)
{
    st[x]=++tim;mp[tim]=x;
    for(int i=head[x];i;i=nxt[i]) dfs(to[i]);
    ed[x]=tim;
}
inline bool cmp(int x,int y)
{
    if(a[x]!=a[y]) return a[x]>a[y];
    if(fa[x]&&fa[y]&&fa[x]!=fa[y]) return val[fa[x]]<val[fa[y]];
    return x>y;
}
void build(int &x,int l,int r,double _l,double _r)
{
	if(l>r) {x=0;return;}
	int mid=(l+r)>>1;val[x=s[mid]]=(_l+_r)/2;siz[x]=r-l+1;
	build(ch[x][0],l,mid-1,_l,val[x]);
	build(ch[x][1],mid+1,r,val[x],_r);
}
void recycle(int &x)
{
	if(!x) return ;
	recycle(ch[x][0]);s[++top]=x;recycle(ch[x][1]);x=0;
}
void rebuild(int &x,double l,double r)
{
	top=0;recycle(x);build(x,1,top,l,r);
}
void insert(int &x,int y,double l,double r,bool f)
{
	if(!x) {x=y;siz[y]=1;val[y]=(l+r)/2;return;}
	bool fg=f;siz[x]++;
	if(cmp(y,x))
	{
		fg|=(alpha*siz[x]<=siz[ch[x][0]]+1);
		insert(ch[x][0],y,l,val[x],fg);
	}
	else
	{
		fg|=(alpha*siz[x]<=siz[ch[x][1]]+1);
		insert(ch[x][1],y,val[x],r,fg);
	}
	if(fg&&!f) rebuild(x,l,r);
}

struct CT
{
int rt[maxn],sz,ls[maxn*20],rs[maxn*20],siz[maxn*20];
void update(int &x,int y,int l,int r,int k)
{
    x=++sz;ls[x]=ls[y];rs[x]=rs[y];siz[x]=siz[y]+1;
    if(l == r) return ;
    int mid=(l+r)>>1;
    if(k <= mid) update(ls[x],ls[y],l,mid,k);
    else update(rs[x],rs[y],mid+1,r,k);
}
int query(int u,int v,int l,int r,int k)
{
    if(l == r) return l;
    int mid=(l+r)>>1,now=siz[ls[v]]-siz[ls[u]];
    if(k <= now) return query(ls[u],ls[v],l,mid,k);
    else return query(rs[u],rs[v],mid+1,r,k-now);
}
void dfs(int x,int f)
{
    rt[x]=rt[f];update(rt[x],rt[x],1,n,rnk[x]);
    for(int i=head[x];i;i=nxt[i]) dfs(to[i],x);
}
inline void init1() {dfs(1,0);}
inline void init2()
{
    for(int i=1;i<=n;i++) rt[i]=rt[i-1],update(rt[i],rt[i],1,n,rnk[mp[i]]);
}
inline int ask1(int x,int k) {return s[query(0,rt[x],1,n,k)];}
inline int ask2(int x,int k) {return s[query(rt[st[x]-1],rt[ed[x]],1,n,k)];}
}S,T;

int main()
{
    scanf("%d%d",&n,&q);
    for(int i=2;i<=n;i++) scanf("%d",&fa[i]),addedge(fa[i],i);
    for(int i=1;i<=n;i++) scanf("%d",&a[i]),insert(rt,i,0,1,0);
    top=0;recycle(rt);
    for(int i=1;i<=n;i++) rnk[s[i]]=i;
    dfs(1);S.init1();T.init2();
    int op,x,k;
    while(q--)
    {
        scanf("%d%d",&op,&x);
        if(op==1) printf("%d\n",rnk[x]);
        if(op==2) scanf("%d",&k),printf("%d\n",S.ask1(x,k));
        if(op==3) scanf("%d",&k),printf("%d\n",T.ask2(x,k));
    }
    return 0;
}
```

---

## 作者：L_zaa_L (赞：0)

后缀平衡树板子，如果想看后缀平衡树的可以看看[我的文章](https://zhuanlan.zhihu.com/p/716855624)。

我们发现题目中的比较方式，是先比较自己再比较它的父亲，这种比较方式非常适合我们后缀平衡树的插入时比较大小，然后我们就可以得到整个树每个位置的排名等。

然后 $1$ 操作直接输出就可以了，$2$ 操作我们只需要将每个位置的主席树接上祖先的主席树，$3$ 操作直接将 dfs 序求出来，然后利用主席树求子树第 $k$ 大。

## Code
```cpp
#include<bits/stdc++.h>
#define ll long long
#define ls(x) (tr[x].l)
#define rs(x) (tr[x].r)
#define Debug(...) fprintf(stderr, __VA_ARGS__)
#define For(i,a,b) for(int i=a,i##end=b;i<=i##end;i++)
#define Rof(i,a,b) for(int i=a,i##end=b;i>=i##end;i--)
#define rep(i,  b) for(int i=1,i##end=b;i<=i##end;i++)
using namespace std;
const int N=1e6+5,base=999983,Mod=998244353;
const ll inf=1e16;
//char buf[(1<<21)+5],*p1,*p2;
//#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
inline void chmx(int &x,int y){(x<y)&&(x=y);}
inline void chmn(int &x,int y){(x>y)&&(x=y);}
inline void Add(int &x,int y){(x=x+y+Mod)%=Mod;}
inline int read(){
	int f=0,x=0;
	char ch=getchar();
	while(!isdigit(ch)){f|=(ch=='-');ch=getchar();}
	while(isdigit(ch)){x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}
	return f?-x:x;
}
void print(int n){
    if(n<0){
        putchar('-');
        n*=-1;
    }
    if(n>9) print(n/10);
    putchar(n%10+'0');
}
int n,m;
int s[N];
struct _Tree{
	ll v;
	int l,r,s,key;
};int fa[N];
int sa[N],rak[N];
struct SAT{
	_Tree tr[N];int rt,cnt;
	inline int chk(int x,int y){
		if(x==y) return 0;
		if(s[x]!=s[y])return (s[x]<s[y]?1:-1);
		if(fa[x]&&fa[y]&&fa[x]!=fa[y]) return (tr[fa[x]].v>tr[fa[y]].v?1:-1);
		return (x<y?1:-1);
	}
	inline void pushup(int x){
		tr[x].s=tr[ls(x)].s+tr[rs(x)].s+1;
	}
	void dfs(int x,ll l,ll r){
		tr[x].v=l+r>>1;
		if(ls(x))dfs(ls(x),l,tr[x].v-1);
		if(rs(x))dfs(rs(x),tr[x].v+1,r);
	}
	inline void zig(int &x,ll l,ll r){
		int q=ls(x);
		ls(x)=rs(q);
		rs(q)=x;
		pushup(x),pushup(q);
		dfs(q,l,r);x=q;
	}
	inline void zag(int &x,ll l,ll r){
		int q=rs(x);
		rs(x)=ls(q);
		ls(q)=x;
		pushup(x),pushup(q);
		dfs(q,l,r);x=q;
	}
	int merge(int x,int y){
		if(!x||!y)return x|y;
		if(tr[x].key<tr[y].key){
			rs(x)=merge(rs(x),y);
			pushup(x);
			return x;
		}
		else{
			ls(y)=merge(x,ls(y));
			pushup(y);
			return y;
		}
	}
	void ins(int &x,int p,ll l,ll r){
		if(!x){
			tr[p].l=tr[p].r=0;
			tr[p].key=rand();
			tr[p].v=(l+r)/2;
			tr[p].s=1;
			x=p;
			return ;
		}
		if(chk(x,p)>0){
			ins(ls(x),p,l,tr[x].v-1);
			pushup(x);
			if(tr[x].key>tr[ls(x)].key)
				zig(x,l,r);
		}
		else{
			ins(rs(x),p,tr[x].v+1,r);
			pushup(x);
			if(tr[x].key>tr[rs(x)].key)
				zag(x,l,r);
		}
	}
	void del(int &x,int p,ll l,ll r){
		if(!x)return;
		if(chk(x,p)==0){
			x=merge(ls(x),rs(x));
			if(x) dfs(x,l,r);
			return;
		}
		if(chk(x,p)>0)
			del(ls(x),p,l,tr[x].v-1);
		else del(rs(x),p,tr[x].v+1,r);
		pushup(x);
	}
	void getsa(int x) {
		if (!x) return;
		getsa(ls(x));
		sa[++cnt]=x;
		getsa(rs(x));
	}
}sat;
struct Tree{int l,r,s;};
struct Presistent_Tree{
	Tree tr[N*10];
	int cnt,rt[N];
	int updata(int x,int l,int r,int o){
		int p=++cnt;
		tr[p]=tr[x];tr[p].s++;
		if(l==r) return p;
		int mid=(l+r)>>1;
		if(o<=mid) ls(p)=updata(ls(x),l,mid,o);
		else rs(p)=updata(rs(x),mid+1,r,o);
		return p; 
	}
	int qry(int x,int y,int l,int r,int k){
		if(!k) return 0;
		if(l==r) return sa[l];
		int mid=(l+r)>>1,res=0;
		if(tr[ls(y)].s-tr[ls(x)].s>=k) return qry(ls(x),ls(y),l,mid,k);
		return qry(rs(x),rs(y),mid+1,r,k-(tr[ls(y)].s-tr[ls(x)].s));
	}
}t1,t2;
vector<int>q[N];
int cnt=0,bg[N],ed[N],dfn[N];
void dfs(int i){
	bg[i]=++cnt;dfn[cnt]=i;
	t2.rt[i]=t2.updata(t2.rt[fa[i]],1,n,rak[i]);
	for(auto v:q[i]){
		dfs(v);
	}ed[i]=cnt;
}
signed main(){
//	freopen("P6164_1.in","r",stdin);
//	freopen(".out","w",stdout);
	// ios::sync_with_stdio(false);
	// cin.tie(0); cout.tie(0);
	n=read();int Q=read();
	For(i,2,n) fa[i]=read(),q[fa[i]].push_back(i);
	For(i,1,n) s[i]=read();
	For(i,1,n) sat.ins(sat.rt,i,1,inf);
	sat.getsa(sat.rt);
	For(i,1,n) rak[sa[i]]=i;
	dfs(1);
	For(i,1,n)t1.rt[i]=t1.updata(t1.rt[i-1],1,n,rak[dfn[i]]);
	while(Q--){
		int op=read(),x=read();
		if(op==1) printf("%lld\n",rak[x]);
		else{
			int k=read();
			if(op==2) printf("%lld\n",t2.qry(t2.rt[0],t2.rt[x],1,n,k));
			else printf("%lld\n",t1.qry(t1.rt[bg[x]-1],t1.rt[ed[x]],1,n,k));
		}
	}
#ifdef LOCAL
    Debug("\nMy Time: %.3lfms\n", (double)clock() / CLOCKS_PER_SEC);
#endif
	return 0;
}
```

---


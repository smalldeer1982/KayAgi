# 时空轮回

## 题目描述

在时空中有 $n$ 个**时空节点**，有 $n-1$ 条时空通道将所有时空节点连接成一个连通块，每条时空通道连接着两个时空节点。

你初始在 $1$ 号时空节点，你每次可以选择一条时空通道来穿梭到另一个时空节点，由于时空穿梭的特殊性，每条时空通道至多通过一次。

每个时空节点有一个**风景**，第 $i$ 个时空节点的风景为 $a_i$。一段**风景序列**由若干个风景构成，一个长度为 $k$ 的风景序列为 $a_{i_1}a_{i_2}\dots a_{i_k}$。你可以通过若干次时空穿梭经过若干时空节点，这些时空节点按照经过顺序构成了一个风景序列，记这个风景序列为**重现的风景**。

定义一个风景序列 A 在风景序列 B 中的出现次数为：最多将风景序列 B 分为多少个连续且不相交的部分，使得风景序列 A 是每个部分的**子串**。

你有 $q$ 段**留恋的风景**，每段留恋的风景是一个风景序列，记第 $i$ 段留恋的风景为 $s_i$，其长度为 $m_i$，记 $s_i$ 中的第 $j$ 个风景为 $s_{i,j}$。对于每段留恋的风景，你都需要从 $1$ 号时空节点出发进行时空穿梭，得到重现的风景，你需要求出该留恋的风景在重现的风景中的出现次数的最大值。

注：

- 每段留恋的风景所对应的重现的风景相互独立。
- 原序列中任意个连续的数字组成的序列称为该序列的子串。

## 说明/提示

$1\le T\le10^5$，$1\le n,q,m_i\le10^5$，$1\le a_i,s_{i,j},u,v\le n$，$\sum n,\sum q,\sum m_i\le10^5$。

**注意本题不寻常的时空限制**。

## 样例 #1

### 输入

```
2
8 8
1 2 8 1 1 2 2 1
1 2
1 3
2 4
2 5
2 6
4 7
4 8
1 1
2 1 1
2 1 2
2 2 1
2 2 2
3 1 2 2
4 1 2 2 1
2 1 8
5 2
1 2 1 2 1
1 2
2 3
3 4
4 5
3 1 2 1
2 1 1```

### 输出

```
3
1
2
1
1
1
0
1
1
0
```

# 题解

## 作者：Falashiro (赞：2)

若要求风景序列 A 在风景序列 B 中的出现次数，则可以每次找到 B 中出现的第一个 A 并在它之后分割，正确性显然。
	
对于一个序列长度 $l$，考虑以 $\Theta(n)$ 的时间复杂度求出所有 $m_i=l$ 的询问的答案。
	
将询问离线，对于所有 $m_i=l$ 的询问，对询问的序列做哈希，并将其哈希值存入哈希表中。我们 dfs 原树，在 dfs 过程中设 $f_i$ 表示第 $i$ 次的询问的序列在 $1$ 号点到当前节点的路径上的出现次数，$g_i$ 表示上一次 $f_i$ 变化的节点。对于一个节点，可以求出以它为末尾的长度为 $l$ 的序列的哈希值，若与第 $i$ 次询问的序列的哈希值相同，则可以根据 $g_i$ 与当前节点的深度差判断是否可以更新 $f_i$，若 $f_i$ 更新，则同时更新 $g_i$ 与询问答案。dfs 回溯时，需同时回溯 $f$ 与 $g$。于是我们得到了一个时间复杂度为 $\Theta(n)$ 的处理相同长度的询问的算法。
	
令 $M=\sum m$，注意到不同的询问长度至多为 $\sqrt M$ 级别，于是对于每个出现的长度执行以上算法即可。时间复杂度为 $\Theta(n\sqrt M)$，空间复杂度为 $\Theta(n)$。

---

## 作者：Lucyna_Kushinada (赞：1)

一开始用的是递归来遍历树，卡常卡了好几面，结果改成欧拉序遍历跑的飞快，冲到了第三优解，遂作此篇。

题意很抽象，其实就是给定一棵字符集为 $[1,10^5]$ 中的整数的字符树，每次询问一个模式串，问其与所有从 $1$ 号节点出发的路径所组成的字符串中最大的不交匹配次数是多少。

首先考虑如何计算一个字符串最大的不交匹配次数，设其长度为 $k$，先计算出它的哈希值 $x$，然后只需要在遍历树的过程中记录当前节点到其 $k-1$ 级祖先组成的字符串哈希值 $y$ 是否与 $x$ 相等，如果相等，就从上一个匹配点看是否能转移即可，最后记得回溯一下就好了。

初看感觉不太可做，但是当你观察到 $\sum m_i\le 10^5$ 时，你会发现 $m_i$ 的种类数其实是 $\sqrt{\sum m_i}$ 级别的，如果对每一种 $m_i$，只用一次遍历就能把相同 $m_i$ 的询问都处理出来，那么复杂度将会是 $O(q \sqrt{\sum m_i})$，理论完全可以过。

我们考虑把询问存到哈希表上，在遍历的过程中，如果当前节点到其 $k-1$ 级祖先组成的字符串哈希值 $y$ 在哈希表中出现，那么进行转移就行了，一次节点至多进行一次转移，复杂度是正确的。

不过如果跑 $\sqrt{\sum m_i}$ 次递归遍历，非常有可能会超时，尤其是对于我这种不会卡常的人来讲，简直就是地狱，所以我们可以预先跑一遍递归遍历，来把树的欧拉序存下来，这样后面 $\sqrt{\sum m_i}$ 次都可以直接用欧拉序来遍历了。

历经了整个卡常过程的代码，非常丑。

```cpp
#include<bits/stdc++.h>
using namespace std;

#define rep(i,l,r) for(int i=(l);i<=(r);++i)
#define per(i,l,r) for(int i=(r);i>=(l);--i)
#define pr pair<int,int>
#define fi first
#define se second
#define pb push_back

#define N 100003
#define ll unsigned int
// #define int long long

const ll m1=100003;
int T,n,q,a[N],d[N],idx[N],fa[N],cnt,pre[N],dp[N],ans[N],ha[N],len,opt[N*2],now[N],lst[N],num;
bitset<N>ex;
unordered_map<ll,int>id;
ll pw1[N],b[N];
vector<int>e[N];

inline void clr(){
    id.clear();

    num=cnt=0;

    rep(i,1,n){
        ex[i]=0;
        pre[i]=dp[i]=ans[i]=0;
        e[i].clear();
    }
}

inline void dfs0(int k,int f){
    d[k]=d[f]+1;
    fa[k]=f;

    opt[++num]=k;

    for(int x:e[k]){
        if(x==f){
            continue;
        }

        dfs0(x,k);
    }

    opt[++num]=k+n;
}

#define getchar_unlocked getchar

inline int rd(){
	int x=0,f=1;
	
	char c=getchar_unlocked();
	
	while(!isdigit(c)){
		if(c=='-')f=-1;
		c=getchar_unlocked();
	}
	while(isdigit(c)){
		x=10*x+c-'0';
		c=getchar_unlocked();
	}
	
	return x*f;
}

// #undef getchar_unlocked

inline void dfs(int k){
    idx[d[k]]=a[k];
    ha[k]=ha[fa[k]]*m1+a[k];
    
    if(d[k]>len){
        ha[k]-=pw1[len]*idx[d[k]-len];
    }

    if(id.count(ha[k])&&d[k]>=len){
        ll u=id[ha[k]];
        int p=pre[u];

        if(d[p]<=d[k]-len){
            now[k]=u;
            lst[k]=p;

            dp[u]++;
            pre[u]=k;

            ans[u]=max(ans[u],dp[u]);
        }
    }
}

inline void ref(int k){
    if(now[k]){
        pre[now[k]]=lst[k];
        dp[now[k]]--;
    }
}

inline void sol(){
    n=rd();q=rd();

    clr();

    rep(i,1,n){
        a[i]=rd();
    }

    int u,v;
    rep(i,1,n-1){
        u=rd();v=rd();

        e[u].pb(v);
        e[v].pb(u);
    }

    dfs0(1,0);

    rep(i,1,q){
        int m;
        ll x,ha=0;

        m=rd();

        rep(j,1,m){
            x=rd();
            ha=ha*m1+x;
        }

        ex[m]=1;

        if(!id.count(ha)){
            id[ha]=++cnt;
        }

        int p=id[ha];
        b[i]=p;
    }

    rep(tmp,1,n){
        if(!ex[tmp]){
            continue;
        }
        // cout<<"len "<<len;

        rep(i,1,n){
            now[i]=lst[i]=0;
        }

        len=tmp;

        rep(i,1,num){
            // cout<<opt[i]<<' ';

            if(opt[i]<=n){
                dfs(opt[i]);
            }
            else{
                ref(opt[i]-n);
            }
        }
    }

    rep(i,1,q){
        cout<<ans[b[i]]<<"\n";
    }
}

signed main(){
    // freopen(".in","r",stdin);
    // freopen(".out","w",stdout);
    // ios::sync_with_stdio(0);
    // cin.tie(0);cout.tie(0);

    pw1[0]=1;
    rep(i,1,1e5){
        pw1[i]=pw1[i-1]*m1;
    }

    cin>>T;
    while(T--){
        sol();
    }

    return 0;
}
```

---

## 作者：eastcloud (赞：0)

先考虑对单个串怎么算贡献，最朴素的暴力是在 dfs 的过程中记一个 $f$ 表示目前匹配到第 $i$ 位的最多已匹配个数，然后每次转移对应数字所在的位置。

上述做法每次只匹配了一个字符，很不优，由于本题要求原串是树上链的子串，不妨每次匹配一整个字符串，把原串哈希，每次检查每个节点到根的对应长度路径是否能匹配上，能的话就转移，复杂度是平方的。

优化后的做法需要每次询问都对树上路径哈希一遍，很不优。一个经典结论是和为 $n$ 的正整数集合大小是 $O(\sqrt n)$ 的，于是我们可以判掉重复字符串，然后对每种长度跑上述算法，因为每个节点最多只能匹配一个对应长度的字符串，时间复杂度 $O(n\sqrt n)$。

哈希写个好点的，不然有概率被卡。


```cpp
void dfs(int x,int fa,int w,int len){
    dep[x]=dep[fa]+1;buc[dep[x]]=a[x];
    if(dep[x]>len)Dec(w,buc[dep[x]-len]),w=mul(w,ipw[1]),Add(w,mul(pw[len-1],a[x]));
    else Add(w,mul(pw[dep[x]-1],a[x]));
    int flag=0,flag2=0;
    if(t.count(w)){
        int id=t[w];
        if(dep[g[id]]<=dep[x]-len)flag2=g[id],g[id]=x,f[id]++,ans[id]=max(ans[id],f[id]),flag=id;
    }
    for(auto v:e[x])if(v!=fa)dfs(v,x,w,len);
    if(flag)g[flag]=flag2,f[flag]--;
}

void solve(){
    int n=read(),q=read();
    For(i,1,n)a[i]=read(),e[i].clear();
    For(i,1,n-1){
        int u=read(),v=read();
        e[u]+=v;e[v]+=u; 
    }
    For(i,1,q){
        L[i]=read();s[i].resize(L[i]+1);f[i]=g[i]=ans[i]=fl[i]=0;
        For(j,1,L[i])s[i][j]=read();Q[i]=mp(L[i],i);
    }
    sort(Q+1,Q+q+1);
    for(int i=1,j=1;i<=q;i=j+1,j=i){
        while(j+1<=q && Q[j+1].fi==Q[i].fi)j++;t.clear();
        For(k,i,j){
            int Hash=0,id=Q[k].se;
            For(l,1,L[id])Hash=pls(Hash,mul(s[id][l],pw[l-1]));
            if(t.count(Hash))fl[id]=t[Hash];
            else t[Hash]=Q[k].se;
        }
        dfs(1,0,0,Q[i].fi);
    }
    For(i,1,q)write((fl[i]?ans[fl[i]]:ans[i])),putchar('\n');
}
```

---

## 作者：Reunite (赞：0)

简单绿题。

题意即给一棵字符树，多次次询问一个模式串在树上任意到根链上的最长不交匹配次数。

因为不交，显然贪心匹配是最优的，匹配一次就删掉即可。考虑加速，如果压缩掉完全相同的模式串，那一个点 $u$ 为末尾，向上长度为 $d$ 的串最多只会匹配到一个询问的模式串。因此考虑对长度做，设当前在考虑所有长度为 $d$ 的答案，只需 dfs 的时候检查 $u$ 向上长度为 $d$ 的串能否匹配到一个模式串，然后检查该串上一次被匹配的位置到 $u$ 是否能再次匹配即可。最后递归撤销。

因为 $\sum len_i\le 10^5$，因此本质不同的 $len$ 只有 $\sqrt {\sum len_i}$ 种，容易发现只需上述检查串使用哈希表优化即可做到 $O(n\sqrt n)$。如果被卡常可以改为非递归遍历，不知道有没有更优复杂度做法。

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <vector>
#include <set>
#define B 23333
#define mod 16341163
#define ll unsigned long long
using namespace std;

int T,n,q;
int h[mod];
int a[100005];
int F[100005];
int G[100005];
int H[100005];
ll hs[100005];
ll hsq[100005];
ll bin[100005];
int dep[100005];
int stk[100005];
int ans[100005];
vector <int> g[100005];
vector <int> qq[100005];
struct Hash{ll x;int nxt;}e[100005];

inline void in(int &n){
	n=0;
	char c=getchar();
	while(c<'0' || c>'9') c=getchar();
	while(c>='0'&&c<='9') n=n*10+c-'0',c=getchar();
	return ;
}

inline void init(int u,int fa){
	hs[u]=hs[fa]*B+a[u];
	for(int v:g[u]) if(v^fa) init(v,u);
	return ;
}

inline ll get(int u,int d){return hs[u]-hs[stk[dep[u]-d]]*bin[d];}

inline int Find(ll x){
	for(int i=h[x%mod];i;i=e[i].nxt)
		if(e[i].x==x) return i;
	return 0;
}

inline void addhash(ll x,int v){
	e[v]={x,h[x%mod]};
	h[x%mod]=v;
	return ;
}

inline void work(int u,int fa,int d){
	dep[u]=dep[fa]+1;
	stk[dep[u]]=u;
	int id=0,ff=0,gg=0;
	if(dep[u]>=d){
		ll hs=get(u,d);
		id=Find(hs);
		if(id&&G[id]<=dep[u]-d){
			ff=F[id],gg=G[id];
			G[id]=dep[u];
			F[id]++;
			H[id]=max(H[id],F[id]);
		}
		else id=0;
	}
	for(int v:g[u]) if(v^fa) work(v,u,d);
	if(id) G[id]=gg,F[id]=ff;
	return ;
}

int main(){
	in(T);
	while(T--){
		in(n),in(q);
		bin[0]=1;
		for(int i=1;i<=n;i++){
			in(a[i]);
			g[i].clear();
			bin[i]=bin[i-1]*B;
		}
		for(int i=1;i<n;i++){
			int u,v;
			in(u),in(v);
			g[u].emplace_back(v);
			g[v].emplace_back(u);
		}
		init(1,0);
		int m=0;
		set <int> leng;
		for(int i=1;i<=q;i++) qq[i].clear(),ans[i]=0;
		for(int i=1;i<=q;i++){
			F[i]=G[i]=H[i]=0;
			int len,x;
			ll hs=0;
			in(len);
			leng.insert(len);
			for(int j=1;j<=len;j++) in(x),hs=hs*B+x;
			x=Find(hs);
			if(!x){
				x=++m;
				addhash(hs,m);
			}
			hsq[i]=hs;
			qq[x].emplace_back(i);
		}
		for(int len:leng) work(1,0,len);
		for(int i=1;i<=q;i++) h[hsq[i]%mod]=0;
		for(int i=1;i<=m;i++)
			for(int id:qq[i]) ans[id]=H[i];
		for(int i=1;i<=q;i++) printf("%d\n",ans[i]);
	}

	return 0;
}
```

---


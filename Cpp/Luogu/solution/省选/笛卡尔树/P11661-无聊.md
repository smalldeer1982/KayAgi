# 无聊

## 题目背景

![](https://cdn.luogu.com.cn/upload/image_hosting/f9kqwg7m.png)

## 题目描述

白很无聊呢，于是她给空出了道题。

给出 $n$ 个数的序列 $a,b$。

求 $b_l\equiv b_r\pmod {\displaystyle\max_{l\le i\le r}a_i}$ 的 $(l,r)$ 个数。

## 说明/提示

对于所有测试数据，保证：$1\le n,a_i,b_i\le 5\times10^5$。

| Subtask | $n\le$ | 限制 | 分值 |
| :----------: | :----------: | :----------: | :----------: |
| $0$ | $10^4$ | - | $5$ |
| $1$ | $10^5$ | $a_i\ge a_{i+1}$ | $15$ |
| $2$ | $10^5$ | - | $30$ |
| $3$ | $5\times10^5$ | - | $50$ |

## 样例 #1

### 输入

```
10
5 5 7 8 6 7 2 1 7 2 
4 11 7 19 13 8 10 11 10 7 ```

### 输出

```
15```

# 题解

## 作者：_Yonder_ (赞：8)

考虑最值分治，当然也可以用笛卡尔树，这两个东西本质一样。

以下内容视 $n,V$ 同阶。

先考虑 $50$ 分的做法：

假设当前分治的区间为 $x\sim y$，令 $x\sim y$ 最大的 $a_i$ 为 $a_k$。枚举小的一边（这里只讨论枚举左边，右边的同理），这时固定了 $b_l,a_k$，变为求 $m$ 次：$k\sim r$ 中 $b_l\equiv b_i\pmod{a_k}$ 的 $i$ 的个数。存成 $m$ 个询问，形如 $l,r,x,y$，求 $l\sim r$ 中模 $x$ 为 $y$ 的 $b_i$ 的个数。

根号分治跑询问即可，时间复杂度 $O(n\sqrt n\log n)$。

对于 $100$ 分的做法：

思考为什么最值分治枚举小的一边时间复杂度是 $O(n\log n)$。因为其对左区间长度与右区间长度取了最小值，这题也可以考虑这么优化。

假设当前分治区间短的一边的长度为 $q$，对短边跑根号分治的时间复杂度为 $O(q\sqrt V)$。若 $q\sqrt V>n$，显然不如暴力枚举另一边，那么就有：$T(n)=\displaystyle\max_{2k\le n}\{T(k-1)+T(n-k)+\min\{k\sqrt V,n\}\}$，可得 $T(n)=O(n\sqrt V)$。

时隔多日后补个证明，~~别打我~~。

令 $u=\frac{n}{\sqrt V}$（这是函数内的 $n$）。

把 $T(n)$ 拆成（以下所有内容，默认 $2k\le n$）：

$$T(n)=\max\{\displaystyle\max_{k\le u}\{T(n-k)+k\sqrt V+\frac{k(k-1)}{2}\},\displaystyle\max_{k\ge u}\{T(k-1)+T(n-k)+n\}\}$$

考虑从其中弄出两个函数：

$$A(n)=\displaystyle\max_{k\le u}\{A(n-k)+\frac{k(k-1)}{2}+k\sqrt V\}$$

$$B(n)=\displaystyle\max_{k\ge u}\{B(n-k)+B(k-1)+n\}$$

对于 $A(n)$ 绝对是 $k$ 越大越好，于是 $k=u$，易证 $A(n)=O(n\sqrt V)$。

易证 $A(n)=B(n)$。

考虑从 $1\to n$ 计算 $T(n)$，对于 $n\le\sqrt V$ 有：$T(n)=A(n)=B(n)$。

考虑代入法：

$$T(n)=\max\{\displaystyle\max_{k\le u}\{A(n-k)+k\sqrt V+\frac{k(k-1)}{2}\},\displaystyle\max_{k\ge u}\{B(k-1)+B(n-k)+n\}\}=\max\{A(n),B(n)\}=O(n\sqrt V)$$

终于结束啦。

---

## 作者：Alex_Wei (赞：6)

### [P11661 无聊](https://www.luogu.com.cn/problem/P11661)

对 $a$ 建出大根笛卡尔树。设当前区间为 $[l, r]$，最大值位置为 $p$，左右区间长度分别为 $X$ 和 $Y$。不妨设 $X < Y$，那么根据经典结论，$\sum X = \mathcal{O}(n\log n)$。设当前模数为 $m$，我们对每个左区间的 $a_i(l\leq i \leq p)$，求出有多少个右区间的 $a_j(p\leq j\leq r)$ 使得 $a_i\equiv a_j\pmod m$。

当 $m$ 较小的时候，把所有询问离线下来，把右区间拆成两个前缀相减，扫描线时对每个 $k$ 维护当前前缀有多少个数模 $m$ 余 $k$，即可 $\mathcal{O}(1)$ 回答左区间的每个位置的询问，总复杂度 $\mathcal{O}(mn + n\log n)$。

当 $m$ 较大的时候，在值域内使得 $a_i\equiv v\pmod m$ 的 $v$ 较少。如果我们已经有 $a_{p\sim r}$ 的桶（可类似树上启发式合并维护，也可以离线），那么可以暴力 $\mathcal{O}(\frac V m)$ 查询。取 $m = \mathcal{O}(\sqrt {V})$，那么当前区间的复杂度是 $\mathcal{O}(X\sqrt V)$，无法接受。

但是我们显然有 $\mathcal{O}(X + Y)$ 的做法。这样就有复杂度的递归式
$$
T(m) = T(X) + T(Y) + \min(m, X \sqrt V)
$$
其中 $X + Y = m$ 且忽略了 $\min$ 前面的常数。

可以证明 $T(n)\leq 2n\sqrt V\frac {\log n} {\log \sqrt V}$。考虑不断分裂区间直到长度不超过 $\frac n {\sqrt V}$。定义好分裂是 $X > \frac m {\sqrt V}$，坏分裂是 $X \leq \frac m {\sqrt V}$。好分裂的代价是 $m$，且最多只会好分裂 $\sqrt V$ 次（此时区间长度不超过 $\frac n {\sqrt V}$），即层数不超过 $\sqrt V$，于是代价不超过 $n\sqrt V$。而坏分裂出来的 $X$ 不会继续分裂（$m\leq n$），所以坏分裂的总代价不超过 $(\sum X)\sqrt V\leq n\sqrt V$。设分裂出的区间长度分别是 $L_{1\sim k}$ 其中 $L_i\leq \frac n {\sqrt V}$，则
$$
\begin{aligned}
T(n) & \leq \sum_{i = 1} ^ k T(L_i) + 2n\sqrt V \\
& \leq 2L_i\sqrt V \frac {\log \frac n {\sqrt V}} {\log \sqrt V} + 2n\sqrt V \\
& \leq 2n\sqrt V \left(\frac {\log n - \log \sqrt V}{\log \sqrt V} + 1\right) \\
& = 2n\sqrt V \frac {\log n} {\log \sqrt V}
\end{aligned}
$$

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
mt19937 rnd(1064);
int rd(int l, int r) {
  return rnd() % (r - l + 1) + l;
}
bool Mbe;

constexpr int N = 5e5 + 5;
int n, a[N], b[N], ls[N], rs[N];
int top, stc[N], buc[N], buc2[N];
ll ans;

void add(int l, int r, int v) {
  for(int i = l; i <= r; i++) buc[b[i]] += v;
}
void dfs(int l, int r, int x) {
  if(l == r) return buc[b[x]]++, ans++, void();
  if(l > r) return;
  int X = x - l, Y = r - x, flag = 0;
  if(X < Y) {
    dfs(l, x - 1, ls[x]);
    add(l, x - 1, -1);
    dfs(x + 1, r, rs[x]);
    if(X * 5e5 / a[x] < X + Y) {
      int c = b[x] % a[x];
      for(int p = l; p <= x; p++) {
        int R = b[p] % a[x];
        ans += c == R;
        for(int q = R; q < N; q += a[x]) ans += buc[q];
      }
      flag = 1;
    }
    add(l, x, 1);
  }
  else {
    dfs(x + 1, r, rs[x]);
    add(x + 1, r, -1);
    dfs(l, x - 1, ls[x]);
    if(Y * 5e5 / a[x] < X + Y) {
      int c = b[x] % a[x];
      for(int p = x; p <= r; p++) {
        int R = b[p] % a[x];
        ans += c == R;
        for(int q = R; q < N; q += a[x]) ans += buc[q];
      }
      flag = 1;
    }
    add(x, r, 1);
  }
  if(!flag) {
    memset(buc2, 0, a[x] + 2 << 2);
    int c = b[x] % a[x];
    for(int p = x, R; p <= r; p++) buc2[R = b[p] % a[x]]++, ans += c == R;
    for(int p = l; p < x; p++) ans += buc2[b[p] % a[x]];
  }
}

bool Med;
int main() {
  fprintf(stderr, "%.3lf\n", (&Mbe - &Med) / 1048576.0);
  ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
  cin >> n;
  for(int i = 1; i <= n; i++) cin >> a[i];
  for(int i = 1; i <= n; i++) cin >> b[i];
  for(int i = 1; i <= n; i++) {
    while(top && a[stc[top]] <= a[i]) ls[i] = stc[top--];
    rs[stc[top]] = i, stc[++top] = i;
  }
  dfs(1, n, stc[1]), cout << ans << "\n";
  fprintf(stderr, "%.3lf\n", 1.0 * clock() / CLOCKS_PER_SEC);
  return 0;
}
```

---

## 作者：xieziheng (赞：5)

卡常+卡空间+板+弱智，垃圾题的一切特征，这道题几乎都集齐了。

不过注意到我不会根号分治，所以这是个不靠谱的做法。

显然对着最大值分治，枚举较小区间元素，维护较大区间的信息，然后发现不好维护。

不过模这个东西可以让我们想到根号分治，发现相当于询问区间模 $x$ 有多少个等于 $y$。但是我差点不会做这个唐题！考虑设阈值 $B$，对于每个 $x\leq B$，跑一遍整个序列，把每个余数存一下，然后对每种余数的询问，可以排个序然后双指针。

对于 $x\geq B$ 的情况，直接枚举 $b$ 序列对应的值 $v$，这样的 $v$ 只有 $\mathcal{O}(\frac m x)$ 个，其中 $m$ 为值域。然后理论上还可以双指针线性，问题是被卡空间了，所以直接二分算了。

然后注意这两种做法都常数较大，而开始的暴力非常快，所以再平衡一下。在分治区间较短（$\leq K$）或者两个区间长度差异不大的时候直接暴力。

当然这么做肯定是过不去的。

几个卡常小寄巧：

- 先 barrett 约减取模。

- 二分不是对每个值开 ```vector``` 而是开个数组模拟。

- 可以手动算一下计算时间代价比一下。

- 我设的参数是 $K=1500,B=1200$ 的时候比较快。

根据某著名人物理论，如果你觉得一道题垃圾还不会做，说明你自己是垃圾。这说明我是垃圾，不过这是公理，是不证自明的。

---

## 作者：Purslane (赞：3)

# Solution

个人感觉这道题还是挺厉害的啊，至少有一点启发性。

显然要建出笛卡尔树，两点 $\rm LCA$ 就是最大值。

考虑从 $[l,x]$ 中选出 $i$，$[x,r]$ 中选出 $j$，使得 $v \mid b_i - b_j$。

这有点像合并两个集合，考虑启发式合并。设 $x- l \le r- x$，这样枚举 $i$，相当于查询了 $O(n \log n)$ 次“有多少 $j \in [l,r]$ 满足 $b_j \equiv v \bmod m$”。使用根号分治 + 莫队（其实不用莫队，离线前缀和即可）容易把这个问题做到 $O(n \sqrt V \log n)$。

考虑这样一个优化：显然我们有 $O(n)$ 的暴力做法。

所以暴力选择更优的即可。

复杂度实际上不是很好算（有点复杂），但是打表发现能过。

代码：

```cpp
#include<bits/stdc++.h>
#define LL long long
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=5e5+10;
int n,a[MAXN],b[MAXN],pre[MAXN],cnt[MAXN],l[MAXN],r[MAXN];
vector<int> rev[MAXN];
vector<pair<int,int>> qr[MAXN];
LL ans;
namespace SGT {
	pair<int,int> mx[MAXN<<2];
	#define lson (k<<1)
	#define rson (k<<1|1)
	#define mid (l+r>>1)	
	void build(const int k,const int l,const int r) {
		if(l==r) return mx[k]={a[l],l},void();
		build(lson,l,mid),build(rson,mid+1,r);
		return mx[k]=max(mx[lson],mx[rson]),void();	
	}
	pair<int,int> query(int k,int l,int r,int x,int y) {
		if(x<=l&&r<=y) return mx[k];
		if(y<=mid) return query(lson,l,mid,x,y);
		if(x>mid) return query(rson,mid+1,r,x,y);
		return max(query(lson,l,mid,x,y),query(rson,mid+1,r,x,y));	
	}
};
void build(int ll,int rr) {
	if(ll>rr) return ;
	auto pr=SGT::query(1,1,n,ll,rr);
	int rt=pr.second;
	l[rt]=ll,r[rt]=rr;
	build(ll,rt-1),build(rt+1,rr);
	return ;
}
class IO_helper{
private:
	static const int L = 1 << 16;
	char in_buf[L], *in_st, *out_st;

	char _getc(){
		if (in_st == out_st)
		{
			out_st = (in_st = in_buf) + fread(in_buf, 1, L, stdin);
			if (in_st == out_st) return EOF;
		}
		return *in_st++;
	}
public:
	template <typename IntType>
	IO_helper &operator>>(IntType &x){
		bool ok=0;
		char c; while ((c = _getc()) < '0' || c > '9')ok|=c=='-';
		for (x = 0; c >= '0' && c <= '9'; c = _getc())
			x = x * 10 + c - '0';
		x=(ok?-x:x);
		return *this;
	}
} IO;
int main() {
	IO>>n;
	ffor(i,1,n) IO>>a[i],rev[a[i]].push_back(i);
	ffor(i,1,n) IO>>b[i];
	SGT::build(1,1,n);
	build(1,n);
	ffor(i,1,700) if(!rev[i].empty()) {
		int flg=0,fs=n+1,ls=0;
		for(auto id:rev[i]) {
			int l1=id-l[id]+1,l2=r[id]-id+1;
			if(min(l1,l2)*600>r[id]-l[id]+1) {
				ffor(j,l[id],id) cnt[b[j]%i]++;
				ffor(j,id,r[id]) ans+=cnt[b[j]%i];
				ffor(j,l[id],id) cnt[b[j]%i]--;	
			}
			else {
				flg=1;
				fs=min(fs,l[id]),ls=max(ls,r[id]);
				if(l1<=l2) ffor(j,l[id],id) qr[r[id]].push_back({b[j]%i,1}),qr[id-1].push_back({b[j]%i,-1});
				else ffor(j,id,r[id]) qr[id].push_back({b[j]%i,1}),qr[l[id]-1].push_back({b[j]%i,-1});
			}
		}
		if(flg) {
			if(fs>=2) fs--;
			ffor(j,0,i-1) pre[j]=0;
			ffor(j,fs,ls) {
				pre[b[j]%i]++;
				for(auto pr:qr[j]) ans+=pr.second*pre[pr.first];
				qr[j].clear();
			}
		}
	}
	ffor(i,701,500000) if(!rev[i].empty()) {
		for(auto id:rev[i]) {
			int l1=id-l[id]+1,l2=r[id]-id+1;
			if(min(l1,l2)*600>r[id]-l[id]+1) {
				ffor(j,l[id],id) cnt[b[j]%i]++;
				ffor(j,id,r[id]) ans+=cnt[b[j]%i];
				ffor(j,l[id],id) cnt[b[j]%i]--;	
			}
			else {
				if(l1<=l2) ffor(j,l[id],id) qr[r[id]].push_back({b[j]%i,i}),qr[id-1].push_back({b[j]%i,-i});
				else ffor(j,id,r[id]) qr[id].push_back({b[j]%i,i}),qr[l[id]-1].push_back({b[j]%i,-i});
			}
		}
	}
	ffor(j,0,500000) pre[j]=0;
	ffor(i,1,n) {
		pre[b[i]]++;
		for(auto pr:qr[i]) {
			int s=pr.first,d=abs(pr.second),op=pr.second/d;
			while(s<=500000) ans+=op*pre[s],s+=d;
		}
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：Reunite (赞：2)

不好评价的题。

看到区间 $\max$ 做为 $\bmod$ 的除数信息不好维护，考虑确定最值，即最值分治，对于区间 $[l,r]$ 的 $a_i$ 最大的一个位置 $mid$，其值为 $mx$，考虑处理所有跨过 $mid$ 的区间答案。

不妨令 $mid-l<r-mid$，那么只需要遍历 $[l,mid)$ 的元素，每次查询 $(mid,r]$ 内 $b_i \equiv b_j\pmod {mx}$ 的个数即可，记一次查询复杂度为 $X$，则可以做到 $O(Xn\log n)$。

但是查询区间 $\equiv k\pmod x$ 的个数不好做，考虑在值域上根号分治，设阈值为 $B$，则 $x\le B$ 的可以直接对每个 $x$ 依次做，前缀和查表即可，可以以 $O(Bn)$ 的复杂度处理所所有这样的询问；$x>B$ 的时候，满足上式的数个数只有 $\frac{V}{B}$ 个，每次爆跳即可做到 $O(\frac{qV}{B})$，平衡可以做到 $O(\sqrt{nqV})$，即 $O(n\sqrt{V\log n})$，均摊一次查询的计算量约为 $X=700$。

但是显然过不去，考虑加入一个优化，即记被 $mid$ 分开的两边区间长度为 $l1\le l2$，若 $l1X>l1+l2$，那显然不如对一边插桶一边查表。再加入一些剪枝和优化就可以过了。出题人声称这个优化可以让复杂度变成 $O(n\sqrt V)$。

>下面提一个不保证对的想法，写一个 dp：设 $f_i$ 为当前分治区间长度为 $i$ 时的最坏计算量，则有：
>
>$$f_i=\max_{j=1}^{\frac{1}{2}i} \{f_j+f_{i-j}+\min(jX,i)\}$$
>
>算一下可以知道，在 $n=10^5$ 的时候，计算量约为 $6.8\times 10^7$，在 $n=10^6$ 的时候，计算量约为 $7.2\times 10^8$。可以声称在本题的数据范围下其复杂度可以看作 $O(n\sqrt V)$。
>

当然，上文提到的 $X$ 的取值，以及计算量这个东西并不严谨，只是我做题咕且胡出来的东西，如果有更好的复杂度证明和分析欢迎和我交流。

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <vector>
#define mk make_pair
#define ll long long
#define B 700
#define BB 600
using namespace std;

bool _;
int n,c1,c2,V;
ll ans;
int a[500005];
int b[500005];
int h[500005];
int t[500005];
int h1[500005];
int h2[500005];
struct node{int op,x,k,nxt;};
node c[2000005];
node g1[2000005];
node g2[2000005];

inline void add1(int a,int b,int c,int u){
	g1[++c1]={a,b,c,h1[u]};
	h1[u]=c1;
	return ;
}

inline void add2(int a,int b,int c,int u){
	g2[++c2]={a,b,c,h2[u]};
	h2[u]=c2;
	return ;
}

int mx[2000005];
int ps[2000005];

bool __;

inline void build(int u,int l,int r){
	if(l==r){mx[u]=a[l],ps[u]=l;return ;}
	int mid=(l+r)>>1;
	build(u<<1,l,mid);
	build(u<<1|1,mid+1,r);
	mx[u]=max(mx[u<<1],mx[u<<1|1]);
	ps[u]=mx[u]==mx[u<<1]?ps[u<<1]:ps[u<<1|1];
	return ;
}

inline pair <int,int> ask(int u,int l,int r,int L,int R){
	if(L<=l&&r<=R) return mk(mx[u],ps[u]);
	int mid=(l+r)>>1;
	if(L>mid) return ask(u<<1|1,mid+1,r,L,R);
	if(R<=mid) return ask(u<<1,l,mid,L,R);
	pair <int,int> t1=ask(u<<1,l,mid,L,R),t2=ask(u<<1|1,mid+1,r,L,R);
	return t1.first<t2.first?t2:t1;
}

inline pair <int,int> ask(int l,int r){return ask(1,1,n,l,r);}

inline void in(int &n){
	n=0;
	char c=getchar();
	while(c<'0' || c>'9') c=getchar();
	while(c>='0'&&c<='9') n=n*10+c-'0',c=getchar();
	return ;
}

inline void solve(int l,int r){
	if(l>=r) return ;
	pair <int,int> tmp=ask(l,r);
	int mid=tmp.second,mx=tmp.first;
	solve(l,mid-1),solve(mid+1,r);
	int l1,l2,r1,r2,M=b[mid]%mx;
	if(mid-l<r-mid) l1=l,r1=mid-1,l2=mid+1,r2=r;
	else l1=mid+1,r1=r,l2=l,r2=mid-1;
	if(r-l+1<=50){
		for(int i=l;i<=r;i++)
			if(i!=mid) ans+=b[i]%mx==M;
	}
	else{
		if(mx<=B){
			add2(-1,l2-1,M,mx);
			add2(1,r2,M,mx);
			add2(-1,l1-1,M,mx);
			add2(1,r1,M,mx);
		}
		else{
			add1(-1,mx,M,l2-1);
			add1(1,mx,M,r2);
			add1(-1,mx,M,l1-1);
			add1(1,mx,M,r1);
		}
	}
	if(l1>r1||l2>r2) return ;
	if((r1-l1+1)*BB>(r2-l2+1)){
		for(int i=l1;i<=r1;i++) h[b[i]%mx]++;
		for(int i=l2;i<=r2;i++) ans+=h[b[i]%mx];
		for(int i=l1;i<=r1;i++) h[b[i]%mx]--;
		return ;
	}
	if(mx<=B){
		for(int i=l1;i<=r1;i++){
			add2(-1,l2-1,b[i]%mx,mx);
			add2(1,r2,b[i]%mx,mx);
		}
	}
	else{
		for(int i=l1;i<=r1;i++){
			add1(-1,mx,b[i]%mx,l2-1);
			add1(1,mx,b[i]%mx,r2);
		}
	}

	return ;
}

int main(){
	// freopen("qwq.in","r",stdin);
	// printf("%d\n",(&_-&__)/1024/1024);
	in(n);
	for(int i=1;i<=n;i++) in(a[i]);
	for(int i=1;i<=n;i++) in(b[i]),V=max(V,b[i]);
	build(1,1,n);
	solve(1,n);
	ans+=n;
	for(int i=1;i<=n;i++){
		h[b[i]]++;
		for(int j=h1[i];j;j=g1[j].nxt){
			int x=g1[j].k;
			ll s=0;
			while(x<=V) s+=h[x],x+=g1[j].x;
			ans+=g1[j].op*s;
		}
	}
	for(int j=1;j<=B;j++){
		int m=0,pos=1,mn=1e9,mx=0;
		for(int x=h2[j];x;x=g2[x].nxt) t[g2[x].x]++,m++,mn=min(mn,g2[x].x),mx=max(mx,g2[x].x);
        if(!m) continue;
		for(int i=mn;i<=mx;i++) t[i]+=t[i-1];
		for(int i=0;i<=V;i++) h[i]=0;
		for(int x=h2[j];x;x=g2[x].nxt) c[t[g2[x].x]--]=g2[x];
		while(pos<=m&&c[pos].x==0) pos++;
		for(int i=mn;i<=mx;i++){
            t[i]=0;
			h[b[i]%j]++;
			while(pos<=m&&c[pos].x==i){
				ans+=c[pos].op*h[c[pos].k];
				pos++;
			}
		}
	}
	printf("%lld\n",ans);

	return 0;
}
```

---

## 作者：_Lamiris_ (赞：1)

## 题目链接

- [洛谷 P11661 无聊](https://www.luogu.com.cn/problem/P11661)

## 解题思路

### 笛卡尔树

看到模数是最大值，首先考虑关于最大值讨论。所以我们可以建一颗笛卡尔树，在笛卡尔树上维护。

这时候问题就会变成 $n$ 个类似“对于两段区间，从两段区间中分别任意选出一个数 $x$ 和 $y$，求满足 $x$ 和 $y$ 在模 $p$ 意义下同余的方案数”的子问题。

### 根号分治

看到取余，我们先可以尝试考虑根号分治。定义一个阈值 $B$。不妨设第一个区间的数的个数小于第二个区间的数的个数。
- 当 $p\leq B$ 时，统计出第二个区间**每种余数**的个数，记作 $mark$ 数组。枚举第一个区间的每个数 $b_i$，将答案加上 $mark[b_i \bmod p]$。
- 当 $p > B$ 时，统计出第二个区间**每种数**的个数，记作另一个 $mark$ 数组。枚举第一个区间的每个数 $b_i$，同时枚举 $p$ 的倍数，也就是枚举正整数 $k$，将答案加上 $mark[b_i + k\times p]$。

由于要统计第二个区间的种类数，直接枚举会超时，于是可以离线下来用莫队处理。对于 $p > B$ 的情况，我们只需要跑一次莫队就可以了。总时间复杂度为 $O(n\sqrt m+s\frac{V}{B})$，其中 $m$ 是此情况的子问题数量，$s$ 是枚举的数的个数，$V$ 是值域，与 $n$ 同阶。由于我们统计答案时枚举的是较小的区间，所以最劣也只会枚举不超过 $n\log n$ 个数。所以 $m,s\leq n$，那么当 $B$ 取 $\sqrt n$ 时，总时间复杂度不会超过 $O(n\sqrt n\log n)$，不能通过。

但是对于 $p\leq B$ 的情况，我们只能对于每种余数分别跑一次莫队，定义 $m[i]$ 是模数为 $i$ 的情况的子问题，总时间复杂度为 $O(n\sum_{i=1}^B{\sqrt{m[i]}}+s)$，s的定义同上。那么最劣时复杂度为 $O(Bn\sqrt{\frac{n}{B}}+s)$，无法通过。

### 根号分治 2

这个时候我们注意到一种暴力做法，先枚举第一段区间，统计每种模 $p$ 的余数的个数，仍记这个数组为 $mark$。然后枚举第二段区间，对于第二段区间中每个数 $t$，将答案加上 $mark[t\bmod p]$。单次时间复杂度为 $O(len_1 + len_2)$。

我们不妨再进一步分治：

- 当 $\min(len_1,len_2) \times B \leq len_1 + len_2$ 时，采用关于模数的根分做法。
- 当 $\min(len_1,len_2) \times B > len_1 + len_2$ 时，采用暴力做法。

### 时间复杂度

这时时间复杂度为：
$$
T(x)=\max_{i=1}^{x-1} T(i)+T(x-i)+\min(\min(i,x-i)*B,x)
$$

首先注意到 $T(x)$ 是一个增函数，打表可以发现当 $x=5\times 10^5$ 时 $T(x)=442,365,309$，可以通过本题。

对于 $p\leq B$ 的情况，由于是在笛卡尔树上维护区间，莫队的常数进一步减小，刚好可以通过。（感谢 @[masterhuang
](luogu://user/365021) 提醒）

所以总时间复杂度约为 $O(n\sqrt n)$，空间复杂度 $O(n)$。

AC 的[提交记录](https://www.luogu.com.cn/record/201606139)，数据加强后最慢一个点跑了 $974ms$。

## 参考代码

**ps：IO 库未给出，代码中的定义和文中略有不同。**


```cpp
#include<cmath>
#include<cstdio>
#include<vector>
#include<cstring>
#include<algorithm>
#define rg register
#define ll long long
#define isdigit(x) (47<(x)&&(x)<58)
#define min(x,y) ((x)<(y)?(x):(y))
using namespace std;
namespace YunLuo
{
    namespace IO
    {
        //略 awa
        struct in{}cin;struct out{~out(){flush();}}cout;
        template<typename T> in& operator>>(in &io,T &x){return read(x),io;}
        template<typename T> out& operator<<(out &io,const T x){return print(x),io;}
    }using namespace IO;

    const int N=5e5+5;
    const int maxn=5e5;
    const int V=707;
    int n,b[N];

    int stk[N],top;
    int ls[N],rs[N],val[N];
    inline void build()
    {
        for(rg int i=1,k;i<=n;++i)
        {
            k=top;
            while(k&&val[stk[k]]<val[i]) --k;
            if(k) rs[stk[k]]=i;
            if(k<top) ls[i]=stk[k+1];
            stk[top=++k]=i;
        }
    }

    int blk;
    struct QUES
    {
        int l,r,ql,qr,mod;
        inline bool operator <(const QUES& x){return ((ql/blk)^(x.ql/blk))?ql<x.ql:(((ql/blk)&1)?qr>x.qr:qr<x.qr);}
    };
    vector<QUES>s[V+1];

    ll ans;
    int mark[N],num[V];

    int lx[N],rx[N];
    void dfs(const int u)
    {
        if(ls[u]&&rs[u]) dfs(ls[u]),dfs(rs[u]),lx[u]=lx[ls[u]],rx[u]=rx[rs[u]];
        else if(ls[u]) dfs(ls[u]),lx[u]=lx[ls[u]],rx[u]=u;
        else if(rs[u]) dfs(rs[u]),lx[u]=u,rx[u]=rx[rs[u]];
        else lx[u]=rx[u]=u;
        if(min(u-lx[u]+1,rx[u]-u+1)*V<rx[u]-lx[u])
        {
            if(val[u]<=V)
            {
                if(u-lx[u]+1<rx[u]-u+1) s[val[u]].push_back({lx[u],u,u,rx[u],val[u]});
                else s[val[u]].push_back({u,rx[u],lx[u],u,val[u]});
            }else
            {
                if(u-lx[u]+1<rx[u]-u+1) s[0].push_back({lx[u],u,u,rx[u],val[u]});
                else s[0].push_back({u,rx[u],lx[u],u,val[u]});
            }
        }else
        {
            for(rg int j=lx[u];j<=u;++j) ++mark[b[j]%val[u]];
            for(rg int j=u;j<=rx[u];++j) ans+=mark[b[j]%val[u]];
            for(rg int j=lx[u];j<=u;++j) --mark[b[j]%val[u]];
        }
    }

    inline void solve()
    {
        cin>>n;
        for(rg int i=1;i<=n;++i) cin>>val[i];
        for(rg int i=1;i<=n;++i) cin>>b[i];
        build();dfs(stk[1]);

        blk=n/sqrt(s[0].size());sort(s[0].begin(),s[0].end());
        rg int L=1,R=0;
        rg QUES x;
        for(int t=0;t<s[0].size();++t)
        {
            x=s[0][t];
            while(R<x.qr) ++mark[b[++R]];
            while(L>x.ql) ++mark[b[--L]];
            while(L<x.ql) --mark[b[L++]];
            while(R>x.qr) --mark[b[R--]];
            
            for(rg int i=x.l;i<=x.r;++i)
                for(rg int j=b[i]%x.mod;j<=maxn;j+=x.mod)
                    ans+=mark[j];
        }

        for(rg short i=1;i<=V;++i)
        {
            blk=n/sqrt(s[i].size());sort(s[i].begin(),s[i].end());
            L=1,R=0;
            for(int t=0;t<s[i].size();++t)
            {
                x=s[i][t];
                while(R<x.qr) ++num[b[++R]%i];
                while(L>x.ql) ++num[b[--L]%i];  
                while(L<x.ql) --num[b[L++]%i];
                while(R>x.qr) --num[b[R--]%i];
                
                for(rg int j=x.l;j<=x.r;++j)
                    ans+=num[b[j]%i];
            }
            if(R-L+1<i) while(L<=R) --num[b[L++]%i];
            else memset(num,0,i<<2);
        }

        cout<<ans<<'\n';
    }
}

int main()
{
    #ifndef ONLINE_JUDGE
    freopen("awa.in","r",stdin);
    freopen("awa.out","w",stdout);
    #endif

    YunLuo::solve();
    return 0;
}
```

---


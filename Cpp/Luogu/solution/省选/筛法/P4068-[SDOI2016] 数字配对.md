# [SDOI2016] 数字配对

## 题目描述

有 $n$ 种数字，第 $i$ 种数字是 $a_i$、有 $b_i$ 个，权值是 $c_i$。

若两个数字 $a_i$、$a_j$ 满足，$a_i$ 是 $a_j$ 的倍数，且 $a_i/a_j$ 是一个质数，

那么这两个数字可以配对，并获得 $c_i \times c_j$ 的价值。

一个数字只能参与一次配对，可以不参与配对。

在获得的价值总和不小于 $0$ 的前提下，求最多进行多少次配对。

## 说明/提示

测试点 $1 \sim 3$： $n \leq 10 $， $a_i \leq 10 ^ 9 $ ， $b_i = 1 $，$ | c_i | \leq 10 ^ 5$；   

测试点 $4 \sim 5$： $n \leq 200 $， $a_i \leq 10 ^ 9 $ ， $b_i \leq 10 ^ 5  $，$c_i = 0$；

测试点 $6 \sim 10$： $n \leq 200 $， $a_i \leq 10 ^ 9 $ ， $b_i \leq 10 ^ 5$ ，$ | c_i | \leq 10 ^ 5$。

## 样例 #1

### 输入

```
3
2 4 8
2 200 7
-1 -2 1
```

### 输出

```
4```

# 题解

## 作者：xyz32768 (赞：16)

分析题目，发现重点在于条件「一个数字只能参与一次配对」。

考虑求出$cnt_i$，表示$a_i$分解质因数之后，每个质因数的指数之和。

那么$a_i$和$a_j$能配对的条件转化为：

$a_i$是$a_j$的倍数，且$cnt_i=cnt_j+1$。

考虑一个二分图的模型。先按照$cnt$的奇偶性，把数字分为两个集合。

1、源点向所有$cnt$为奇数的点连一条容量为$b_i$，费用为$0$的边。

2、所有$cnt$为偶数的点向汇点连一条容量为$b_i$，费用为$0$的边。

3、对于一对$i,j$，如果$a_i$和$a_j$能配对并且$cnt_i$为奇数，则由$i$向$j$连一条边，容量为$\infty$，费用为$ci\times cj$。

然后跑最大费用最大流。但是写法有一些变化：

由于跑最大费用最大流的过程中，每一次增广求出的最长路一定不会大于上一次增广求出的最长路，所以考虑贪心

每一次跑最长路后，沿着最长路，在价值总和不小于$0$的前提下尽可能增加流量。如果找不到增广路或者继续增广一定会使价值总和小于$0$，则已经传输的总流量就是答案。 
代码：
```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
inline int read() {
    int res = 0; bool bo = 0; char c;
    while (((c = getchar()) < '0' || c > '9') && c != '-');
    if (c == '-') bo = 1; else res = c - 48;
    while ((c = getchar()) >= '0' && c <= '9')
        res = (res << 3) + (res << 1) + (c - 48);
    return bo ? ~res + 1 : res;
}
typedef long long ll;
const int N = 210, M = 5e5 + 5; const ll INF = 1ll << 61;
int n, a[N], b[N], c[N], cnt[N], ecnt = 1, nxt[M], adj[N], st[M], go[M],
frm[M], S, T, len, que[M];
ll cap[M], cost[M], dis[N], sum, ans; bool vis[N];
void add_edge(int u, int v, ll w, ll x) {
    nxt[++ecnt] = adj[u]; adj[u] = ecnt; st[ecnt] = u;
    go[ecnt] = v; cap[ecnt] = w; cost[ecnt] = x;
    nxt[++ecnt] = adj[v]; adj[v] = ecnt; st[ecnt] = v;
    go[ecnt] = u; cap[ecnt] = 0; cost[ecnt] = -x;
}
int sigma(int n) {
    int i, S = sqrt(n), tot = 0; for (i = 2; i <= S; i++)
        while (n % i == 0) n /= i, tot++; if (n > 1) tot++; return tot;
}
bool spfa() {
    int i; for (i = S; i <= T; i++) vis[i] = 0, dis[i] = -INF;
    dis[que[len = 1] = S] = 0; for (i = 1; i <= len; i++) {
        int u = que[i]; vis[u] = 0;
        for (int e = adj[u], v; e; e = nxt[e])
            if (cap[e] && dis[u] + cost[e] > dis[v = go[e]]) {
                dis[v] = dis[u] + cost[frm[v] = e];
                if (!vis[v]) vis[que[++len] = v] = 1;
            }
    }
    return dis[T] > -INF;
}
bool add() {
    ll fl = INF, delta; for (int e = frm[T]; e; e = frm[st[e]])
        fl = min(fl, cap[e]); delta = dis[T] * fl;
    if (sum + delta >= 0) {
        sum += delta; ans += fl;
        for (int e = frm[T]; e; e = frm[st[e]])
            cap[e] -= fl, cap[e ^ 1] += fl; return 1;
    }
    else return ans += sum / (-dis[T]), 0;
}
ll solve() {
    while (spfa() && add()); return ans;
}
int main() {
    int i, j; n = read(); for (i = 1; i <= n; i++) a[i] = read();
    for (i = 1; i <= n; i++) b[i] = read();
    for (i = 1; i <= n; i++) c[i] = read(); S = 1; T = n + 2;
    for (i = 1; i <= n; i++) cnt[i] = sigma(a[i]);
    for (i = 1; i <= n; i++) if (cnt[i] & 1) add_edge(S, i + 1, b[i], 0);
        else add_edge(i + 1, T, b[i], 0);
    for (i = 1; i <= n; i++) if (cnt[i] & 1) for (j = 1; j <= n; j++)
        if ((cnt[i] + 1 == cnt[j] && a[j] % a[i] == 0) ||
            (cnt[j] + 1 == cnt[i] && a[i] % a[j] == 0))
                add_edge(i + 1, j + 1, INF, 1ll * c[i] * c[j]);
    cout << solve() << endl; return 0;
}
```

---

## 作者：louhao088 (赞：12)

## 一道非常好的网络流题

## 思路 二分+费用流

我的思路与其他题解不一样，可能是我太菜了，所以要多一只 $ \log$，不过跑的也飞快，最大一个点也只要 100ms，而且主要这个好想。


------------


1. 首先我们考虑建图

这其实与其他题解差不多，统计每个数其质因数指数之和，记录为 $tot_i$ ，若一个数能整除另一个数且 $tot$ 之差为一则连边，

建立超级源点 s，与汇点 t，对于每个奇数的 $tot_i$ 与 s 连边，偶数与t连边

```cpp
	for(int i=1;i<=n;i++)
		if(tot[i]%2==1)add(s,i,b[i],0);else add(i,t,b[i],0);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
		{ 
			if(a[i]%a[j]==0&&tot[i]==tot[j]+1)
			{
				if(tot[i]%2==1)add(i,j,inf,c[i]*c[j]);
				else add(j,i,inf,c[i]*c[j]);
			}
		}
```


------------


2. 然后我们来想如何求在获得的价值总和不小于0的前提下,进行最多配对次数

因为易证取的费用小于 0 次数之前的都大于等于0之后的都小于0

所以可以二分流量

在建一个超超级源点 ss，和汇点 tt，ss 与 s连一条g的边，t 与 tt 连一条 g 的边( g 为流量)

```cpp
bool check(int g)
{
	memset(last,0,sizeof last),memset(pre,0,sizeof pre),memset(head,0,sizeof head);
	cnt=1;int s=y+1,t=y+2;
	add(x,s,g,0),add(t,y,g,0);
	for(int i=1;i<=n;i++)
		if(tot[i]%2==1)add(s,i,b[i],0);else add(i,t,b[i],0);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
		{
			if(a[i]%a[j]==0&&tot[i]==tot[j]+1)
			{
				if(tot[i]%2==1)add(i,j,inf,c[i]*c[j]);
				else add(j,i,inf,c[i]*c[j]);
			}
		}
	feiyong1();
	return maxcost>=0;
}
```

注要开 long long

------------
完整代码


```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int maxn=80005,inf=0x3f3f3f3f;
inline int read()
{
	char ch=getchar();int x=0;bool f=0;
	for(;!isdigit(ch);ch=getchar())if(ch=='-')f=1;
	for(;isdigit(ch);ch=getchar())x=(x<<1)+(x<<3)+(ch^48);
	if(f==1)x=-x;return x;
}
queue<int>q;
struct edge
{
	int v,wf,nex,wd;
}e[maxn];
int head[205],cnt=1,pre[205],x,y,n,m,maxflow,flow[205],last[205],tot[205];
int dis[205],maxcost,a[205],b[205],c[205],d,l,r,ans;
void add(int u,int v,int wf,int wd){e[++cnt].v=v,e[cnt].wf=wf,e[cnt].wd=wd,e[cnt].nex=head[u],head[u]=cnt;
e[++cnt].v=u,e[cnt].wf=0,e[cnt].wd=-wd,e[cnt].nex=head[v],head[v]=cnt;}
bool vis[maxn];
inline bool spfa2() 
{
	memset(dis,0x80,sizeof dis);
	memset(vis,0,sizeof vis);
	memset(flow,0x3f,sizeof flow);
	queue<int>q;
	q.push(x),dis[x]=0,vis[x]=1,pre[y]=-1;
	while(!q.empty()) 
	{
		int u=q.front();
		vis[u]=0,q.pop();
		for(int i=head[u];i;i=e[i].nex) 
		{
			int v=e[i].v;
			if(e[i].wf&&dis[v]<dis[u]+e[i].wd) 
			{
				dis[v]=dis[u]+e[i].wd;
				flow[v]=min(flow[u],e[i].wf);pre[v]=u,last[v]=i;
				if(!vis[v])vis[v]=1,q.push(v);
			}
		}
	}
	return pre[y]!=-1;
}
void feiyong1()
{	
	maxcost=0;maxflow=0;
	while(spfa2())
	{
		int now=y;//cout<<dis[y]<<" "<<flow[y]<<endl;
		maxflow+=flow[y];maxcost+=flow[y]*dis[y];
		while(now!=x)
		{
			e[last[now]].wf-=flow[y];
			e[last[now]^1].wf+=flow[y];
			now=pre[now];
		}
	}
}
bool check(int g)
{
	memset(last,0,sizeof last),memset(pre,0,sizeof pre),memset(head,0,sizeof head);
	cnt=1;int s=y+1,t=y+2;
	add(x,s,g,0),add(t,y,g,0);
	for(int i=1;i<=n;i++)
		if(tot[i]%2==1)add(s,i,b[i],0);else add(i,t,b[i],0);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
		{
			if(a[i]%a[j]==0&&tot[i]==tot[j]+1)
			{
				if(tot[i]%2==1)add(i,j,inf,c[i]*c[j]);
				else add(j,i,inf,c[i]*c[j]);
			}
		}
	feiyong1();
	return maxcost>=0;
}
int getr()
{
	memset(last,0,sizeof last),memset(pre,0,sizeof pre),memset(head,0,sizeof head);
	cnt=1;int s=y+1,t=y+2;
	add(x,s,inf,0),add(t,y,inf,0);
	for(int i=1;i<=n;i++)
		if(tot[i]%2==1)add(s,i,b[i],0);else add(i,t,b[i],0);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
		{
			if(a[i]%a[j]==0&&tot[i]==tot[j]+1)
			{
				if(tot[i]%2==1)add(i,j,inf,c[i]*c[j]);
				else add(j,i,inf,c[i]*c[j]);
			}
		}
	feiyong1();return maxflow;
}
signed main()
{
	n=read();x=n+1,y=n+2;int M=0;
	for(int i=1;i<=n;i++)a[i]=read();
	for(int i=1;i<=n;i++)b[i]=read();
	for(int i=1;i<=n;i++)c[i]=read();
	for(int i=1;i<=n;i++)
	{
		int l=a[i];
		for(int j=2;j<=l;j++)
			if(l%j==0)l=l/j,j--,tot[i]++;
	}
	
	ans=0,l=0,r=getr();
	while(r>=l)
	{
		int mid=(l+r)>>1;
		if(check(mid))ans=mid,l=mid+1;
		else r=mid-1;
	}
	printf("%lld",ans);
	return 0;
}
```







---

## 作者：Orion545 (赞：9)

# 广告

[蒟蒻的blog](http://www.cnblogs.com/dedicatus545/p/8729451.html)

# 正文

### 一个数字能且只能匹配一次

这引导我们思考：一次代表什么？代表用到一定上限（b数组）就不能再用，同时每用一次会产生价值（c数组）

上限？价值？网络流！

把一次匹配设为一点流量，那产生的价值不就是费用了吗？

我们考虑把一种数字抽象成一个点，可以匹配的数字之间连边，费用为c\[i\]\*c\[j\]，流量上限为.....

等等，流量上限怎么设？

而且还有一个问题：这里的匹配是双向的，虽然可以$O\left(n^2\right)$求出所有匹配对，但是网络流要求是单向边啊！

别急，我们先来分析一下两个满足匹配条件的数，有什么性质

设$i=p\ast j$，其中p是一个质数

那我们考虑$i$和$j$的质因数分解，会发现：它们俩分解出的质因数个数之间正好差一！

这说明了什么？

这说明匹配只有可能在质因数个数奇偶性不同的数对之间存在，而如果根据质因数个数的奇偶性把数分成两组，那么所有边都在两组之间！

这是什么？二分图啊！

那么我们就可轻易把每条边定向成从奇数侧到偶数侧了！

接下来的事就简单了：我们建立超级源S和超级汇T，从S连边到所有质因数个数为奇数的点i，费用为0，容量为b\[i\]，质因数个数为偶数的点连到T，类似

这样，我们也一同限制了每个点最多流出去不超过b\[i\]的流量，也就是不发生超过b\[i\]次和这个数字有关的匹配

因此对于原图中的可行匹配，只要连边，费用为c\[i\]\*c\[j\]，流量上限inf

跑最大费用最大流......等等好像不行？这道题是要求费用非负时的最大流量啊......

别急，我们来贪心一波

我们每次在图中做一个spfa，找到费用最大（最长）的增广路，设它的总长度（费用）为maxn，同时设当前总费用为ans

如果maxn<-ans，那么即使加上1的流量，总费用也负数了，这个时候结束循环，输出总流量flow即可

否则，如果maxn>0，那么非常高兴，我们随便加，流量越多越好

如果maxn<0，那么也没有问题，我们只要令流的流量为$min(limit,ans/(-maxn))$，其中limit为当前增广路的流量上限

这样一直循环，直到因为上面的原因跳出，或者图不连通了为止，输出总流量flow，就是最大匹配数了

贪心的证明很显然，我们每次都是取最优走，而且后面的决策肯定没有我优，就证完了

# Code:

写的时候注意细节啊......这题细节贼多，一不小心就除0或者mod0了，而且实现分解质因数的时候注意，如果一个数x到了sqrt(x)都还没有一个质因数，那么它肯定是个质数

因此我们只要筛1e5的素数就够了

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cassert>
#define inf 1e15
#define ll long long
using namespace std;
inline ll read(){
    ll re=0,flag=1;char ch=getchar();
    while(ch>'9'||ch<'0'){
        if(ch=='-') flag=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9') re=(re<<1)+(re<<3)+ch-'0',ch=getchar();
    return re*flag;
}
ll cnt=-1,ans,flow,first[210],dis[210],vis[210],limit[210],pre[210];
struct edge{
    ll to,next,w,cap;
}a[100010];
inline void add(ll u,ll v,ll w,ll cap){
    a[++cnt]=(edge){v,first[u],w,cap};first[u]=cnt;
    a[++cnt]=(edge){u,first[v],-w,0};first[v]=cnt;
}
bool spfa(ll s,ll t){
    ll q[5010]={0},head=0,tail=1,u,v,w,i;
    for(i=s;i<=t;i++) dis[i]=-inf;
    memset(vis,0,sizeof(vis));
    memset(pre,-1,sizeof(pre));memset(limit,0,sizeof(limit));
    q[0]=s;vis[s]=1;dis[s]=0;limit[s]=inf;
    while(head<tail){
        u=q[head++];vis[u]=0;
        for(i=first[u];~i;i=a[i].next){
            v=a[i].to;w=a[i].w;
            if(a[i].cap&&(dis[v]<dis[u]+w)){//注意是最长路
                dis[v]=dis[u]+w;
                limit[v]=min(limit[u],a[i].cap);
                pre[v]=i;
                if(!vis[v]) q[tail++]=v,vis[v]=1;
            }
        }
    }
    return dis[t]!=-inf;
}
ll n,A[210],B[210],C[210],col[210];
ll tot=0,pri[100010],v[100010]={0};
void init(){//线筛
    ll i,j,k;v[1]=1;
    for(i=2;i<=100000;i++){
        if(!v[i]) pri[++tot]=i;
        for(j=1;j<=tot;j++){
            k=i*pri[j];if(k>100000) break;
            v[k]=1;
            if((i%pri[j])==0) break;
        }
    }
}
ll cntprime(ll x){
    ll re=0,c=1;
    while(x>1&&c<=tot){
        while((x%pri[c])==0) x/=pri[c],re++;
        c++;
    }
    if((c==tot+1)&&(x>1)) return 1;//处理特殊情况
    return re;
}
int main(){
    memset(first,-1,sizeof(first));
    ll i,j;init();
    n=read();
    for(i=1;i<=n;i++) A[i]=read(),col[i]=cntprime(A[i]);
    for(i=1;i<=n;i++){
        B[i]=read();
        if(col[i]%2) add(0,i,0,B[i]);
        else add(i,n+1,0,B[i]);
    }
    for(i=1;i<=n;i++) C[i]=read();
    for(i=1;i<=n;i++){
        for(j=i+1;j<=n;j++){
            if((((A[i]%A[j])==0)&&(col[i]==col[j]+1))||(((A[j]%A[i])==0)&&(col[j]==col[i]+1))){
                if(col[i]%2) add(i,j,C[i]*C[j],inf);
                else add(j,i,C[i]*C[j],inf);
            }
        }
    }
    ll tmp,u;
    while(1){
        if(!spfa(0,n+1)) break;
        if(dis[n+1]+ans<0) break;
        if(dis[n+1]>=0) tmp=limit[n+1];//注意这里>=不要写成>......我被这个坑了1h啊啊啊啊
        else tmp=min(limit[n+1],ans/(-dis[n+1]));
        ans+=dis[n+1]*tmp;flow+=tmp;
        for(u=n+1;~pre[u];u=a[pre[u]^1].to){
            a[pre[u]].cap-=tmp;a[pre[u]^1].cap+=tmp;
        }
    }
    printf("%lld\n",flow);
}
```

---

## 作者：SoyTony (赞：3)

看到题目想到费用流模型，要求保证费用为正时流量最大。

先不管具体怎么建模，但在保证当前可行流最大费用的情况下，最大费用具有单调性，也就是可以二分。

每次给定一个流量的上界，判断此时是否为正。

限制流量需要对源点拆点，连边容量为限制的 $x$。同样要把所有非源汇的点拆开，源点的出点与这些点的入点连容量为 $b$ 的边，可以匹配的两个点对应连出点与入点，容量无限大，剩下就是与汇点连无限大。

求最大费用，可以把费用设为负跑最小费用，这里拆点就可以避免负环出现，同时注意到同一种匹配 $(i,j)$ 会出现两次，因此答案要除以 $2$。

```cpp
int n,m;
int a[205],b[205],c[205];
int S1,S2,T;
struct Graph{
    struct edge{
        int to,nxt;
        ll lim,tmp,c;
    }e[maxm<<1];
    int head[maxn],cnt=1;
    inline void add_edge(int u,int v,ll w,ll c){
        e[++cnt].to=v,e[cnt].nxt=head[u],e[cnt].lim=w,e[cnt].tmp=w,e[cnt].c=c,head[u]=cnt;
        e[++cnt].to=u,e[cnt].nxt=head[v],e[cnt].lim=0,e[cnt].tmp=0,e[cnt].c=-c,head[v]=cnt;
    }
    int pre[maxn];
    ll dis[maxn];
    bool vis[maxn];
    inline void SPFA(){
        queue<int> q;
        memset(dis,0x3f,sizeof(dis));
        memset(vis,0,sizeof(vis));
        dis[S1]=0,vis[S1]=1;
        q.push(S1);
        while(!q.empty()){
            int u=q.front();
            q.pop();
            vis[u]=0;
            for(int i=head[u];i;i=e[i].nxt){
                int v=e[i].to;
                ll c=e[i].c;
                if(dis[u]+c<dis[v]&&e[i].lim){
                    dis[v]=dis[u]+c;
                    pre[v]=i;
                    if(vis[v]) continue;
                    vis[v]=1;
                    q.push(v);
                }
            }
        }
    }
    inline pair<ll,ll> max_flow(int_fast64_t x){
        e[2].lim=x,e[3].lim=0;
        for(int i=4;i<=cnt;++i) e[i].lim=e[i].tmp;
        ll flow=0,min_cost=0;
        while(1){
            SPFA();
            if(dis[T]==maxxn) return make_pair(flow,min_cost);
            ll mn=maxxn;
            for(int u=T;u!=S1;u=e[pre[u]^1].to) mn=min(mn,e[pre[u]].lim);
            flow+=mn;
            for(int u=T;u!=S1;u=e[pre[u]^1].to){
                min_cost+=e[pre[u]].c*mn;
                e[pre[u]].lim-=mn,e[pre[u]^1].lim+=mn;
            }
        }
    }
}G;

inline bool check_pr(int x){
    for(int i=2;i*i<=x;++i){
        if(x%i==0) return false;
    }
    return true;
}

int ans;

int main(){
    n=read();
    S1=2*n+1,S2=2*n+2,T=2*n+3;
    for(int i=1;i<=n;++i) a[i]=read();
    for(int i=1;i<=n;++i) b[i]=read();
    for(int i=1;i<=n;++i) c[i]=read();
    G.add_edge(S1,S2,1e9,0);
    for(int i=1;i<=n;++i){
        G.add_edge(S2,i,b[i],0);
        G.add_edge(i+n,T,b[i],0);
    }
    for(int i=1;i<=n;++i){
        for(int j=i+1;j<=n;++j){
            int x=a[i],y=a[j];
            if(x==y) continue;
            if(x<y) swap(x,y);
            if(x%y) continue;
            if(check_pr(x/y)){
                G.add_edge(i,j+n,1e9,-1ll*c[i]*c[j]);
                G.add_edge(j,i+n,1e9,-1ll*c[i]*c[j]);
            } 
        }
    }
    int l=0,r=G.max_flow(1e9).first/2;
    while(l<=r){
        int mid=(l+r)>>1;
        if(G.max_flow(mid*2).second<=0) ans=mid,l=mid+1;
        else r=mid-1;
    }
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：UperFicial (赞：2)

[传送门](https://www.luogu.com.cn/problem/P4068)

萌新刚学费用瘤，所以本篇题解会尽量讲得详细一些![](//图.tk/q)

前置芝士：

- 最小费用最大流。
- ~~质因数分解。~~

设 $cnt_i$ 为 $a_i$ 质因数分解后各项指数之和。

那么 $a_i$ 和 $a_j$ 能匹配的条件为，$a_i\bmod a_j=0$ 且 $cnt_i=cnt_j+1$。

稍微解释一下，若 $a_i$ 是 $a_j$ 的倍数，那么 $a_i$ 肯定包含 $a_j$ 的所有质因数，而又有条件 $cnt_i=cnt_j+1$，说明 $a_i$ 在 $a_j$ 的基础上只多了一个质因数，所以 $\frac{a_i}{a_j}$ 是一个质数。

现在考虑建图，我们根据 $cnt$ 的奇偶性将 $a_i$ 分成两堆儿：$cnt_i$ 为奇数的放在左边，$cnt_i$ 为偶数的放在右边。

考虑到【一个数只能匹配一次】这一条件，我们把流量设成 $b_i$。


新建一个虚拟汇点 $s$，将 $s$ 与左边的每一个点连一条容量为 $b_i$，费用为 $0$ 的边。

新建一个虚拟汇点 $t$，将右边的每一个点与 $t$ 连一条容量为 $b_i$，费用为 $0$ 的边。

**通过这样建图，就可以保证每一个 $a_i$ 最多使用 $b_i$ 次。**

两边的点就暴力建图，对于两个可以匹配的点 $i,j$，连一条 从 $i$ 到 $j$，容量为 $\infty$，费用为 $c_i\times c_j$ 的边。

中间部分的建图就已经不用考虑 $b_i$ 的限制了，因为两边的连边都已经考虑在内了。所以容量设为无限大。


那么现在就只剩下【价值之和不小于 $0$】 这一条件了。

这就需要对费用流改动一下。

考虑贪心。我们每次用 SPFA 跑最长路，那么每次 SPFA 跑到终点的最长路肯定是下降的。

我们对于当前的这一条增光路，在价值和不小于 $0$ 的情况下尽可能多的添加流量，直到价值和小于 $0$。

坑点：开 long long，边数组别开小。

贴一下巨丑的代码：

```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<ctime>
#include<cmath>
#include<cstdlib>
#include<climits>
#include<queue>
#include<vector>
using namespace std;
typedef long long ll;
const int MAXN(210);
const ll INF(1e18);
int n,a[MAXN],b[MAXN];
ll c[MAXN];
int cnt[MAXN];
int s,t;
inline ll Min(ll x,ll y){return x<y?x:y;}
inline int fenjie(int x)
{
	int res(0),N=sqrt(x+0.5);
	for(register int i=2;i<=N;i++)
		while(x%i==0) ++res,x/=i;
	if(x>1) ++res;
	return res;
}
struct E{int to,nxt;ll cost,flow;};
E edge[MAXN*MAXN];
int head[MAXN],tot=1;
inline void add_edge(int u,int v,ll f,ll w)
{
	edge[++tot].nxt=head[u];
	head[u]=tot;
	edge[tot].to=v;
	edge[tot].flow=f;
	edge[tot].cost=w;
	return;
}
ll dis[MAXN],flow[MAXN],Cost,Flow;
int pre[MAXN],pos[MAXN];
bool inq[MAXN];
queue<int>q;
inline bool SPFA()
{
	for(register int i=s;i<=t;i++)
		dis[i]=-INF,flow[i]=INF,inq[i]=false;
	q.push(s);
	dis[s]=0;
	while(!q.empty())
	{
		int u=q.front();
		q.pop();
		inq[u]=false;
		for(register int i=head[u];i;i=edge[i].nxt)
		{
			E e=edge[i];
			if(dis[e.to]<dis[u]+e.cost&&e.flow)
			{
				dis[e.to]=dis[u]+e.cost;
				flow[e.to]=Min(flow[u],e.flow);
				pre[e.to]=u,pos[e.to]=i;
				if(!inq[e.to]) q.push(e.to),inq[e.to]=true;
			}
		}
	} 
	return dis[t]>-INF;
}
inline bool MCMF()
{
	if(!SPFA()) return false;
	ll now=dis[t]*flow[t];
	if(Cost+now>=0)
	{
		Cost+=now;
		Flow+=flow[t];
		for(register int u=t;u!=s;u=pre[u])
		{
			int p=pos[u];
			edge[p].flow-=flow[t];
			edge[p^1].flow+=flow[t];
		}
		return true;
	}
	else return Flow+=Cost/(-dis[t]),false;	
}
int main()
{
	scanf("%d",&n);
	s=0,t=n+1;
	for(register int i=1;i<=n;i++) scanf("%d",&a[i]);
	for(register int i=1;i<=n;i++) scanf("%d",&b[i]);
	for(register int i=1;i<=n;i++) scanf("%lld",&c[i]);
	for(register int i=1;i<=n;i++) cnt[i]=fenjie(a[i]);
	for(register int i=1;i<=n;i++)
		if(cnt[i]&1) add_edge(s,i,b[i],0),add_edge(i,s,0,0);
		else add_edge(i,t,b[i],0),add_edge(t,i,0,0);
	for(register int i=1;i<=n;i++) if(cnt[i]&1)
		for(register int j=1;j<=n;j++)
			if((a[i]%a[j]==0&&cnt[i]==cnt[j]+1)||(a[j]%a[i]==0&&cnt[j]==cnt[i]+1))
				add_edge(i,j,INF,c[i]*c[j]),add_edge(j,i,0,-c[i]*c[j]);
	while(MCMF());
	printf("%lld\n",Flow);
	return 0;
}
```

$$\texttt{The End.by UF}$$

---

## 作者：nofind (赞：2)

## [题意](https://www.luogu.com.cn/problem/P4068)

看见配对数最多，想到这是最大流。看到代价，想到这是最大费用流。
于是这题是最大费用最大流。  
~~做完了，撒花！~~

我们发现这题没有明显的组别之分，也就是说我们并不知道建图时谁连源点谁连汇点。

再次观察题中给出的配对的条件：$a_i$是$a_j$的倍数且满足$\frac{a_i}{a_j}\in prime$，即$a_i=k*a_j,k\in prime$。

设$cnt_x$表示$x$质因数分解后指数之和，如$cnt_{12}=3$，因为$12=3^1*2^2,1+2=3$。

我们发现题中条件变为：$a_i$是$a_j$的倍数且满足$cnt_{a_i}=cnt_{a_j}+1!!!$

于是我们可以按照$cnt_{a_i}$的奇偶性对$i$分类，奇数连源点，偶数连汇点，容量都为$b_i$，费用为$0$。

之后就枚举每对$(i,j)$，满足条件就从$cnt$为奇数的向另一个连容量为$b_i*b_j$，费用为$c_i*c_j$的边即可。

如果没有这个限制题就已经做完了：“在获得的价值总和不小于$0$的前提下”

为了处理这个限制，我们考虑$Dinic$的过程，我们每次$spfa$的求出的最长路必定是递减的，因为这是$Dinic$复杂度的保证。（可以去看$Dinic$的复杂度证明，就是用最长/短路总是变得更差证的）

于是我们每次求出费用后就判断下加上是否会小于$0$，不小于$0$就直接加上，不然就只加加上刚好不小于$0$的那一部分，之后$break$掉。

code:
```
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn=210;
const ll inf=1e18;
int n,cnt_edge=1,S,T;
int a[maxn],b[maxn],c[maxn],head[maxn],cnt[maxn];
ll dis[maxn];
bool vis_prime[100010],vis[maxn];
vector<int>prime;
struct edge{int to,nxt;ll flow,cost;}e[(maxn*maxn)<<2];
inline ll read()
{
	char c=getchar();ll res=0,f=1;
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
	while(c>='0'&&c<='9')res=res*10+c-'0',c=getchar();
	return res*f;
}
inline void add(int u,int v,ll w,ll c)
{
	e[++cnt_edge].nxt=head[u];
	head[u]=cnt_edge;
	e[cnt_edge].to=v;
	e[cnt_edge].flow=w;
	e[cnt_edge].cost=c;
}
inline void addflow(int u,int v,ll w,ll c){add(u,v,w,c);add(v,u,0,-c);}
inline void pre_work()
{
	vis[1]=1;
	for(int i=2;i<=100000;i++)
	{
		if(!vis_prime[i])prime.push_back(i);
		for(unsigned int j=0;j<prime.size()&&i*prime[j]<=100000;j++)
		{
			vis_prime[i*prime[j]]=1;
			if(i%prime[j]==0)break;
		}
	}
}
inline bool spfa()
{
	memset(vis,0,sizeof(vis));
	for(int i=S;i<=T;i++)dis[i]=-inf;
	queue<int>q;
	q.push(S);dis[S]=0;vis[S]=1;
	while(!q.empty())
	{
		int x=q.front();q.pop();vis[x]=0;
		for(int i=head[x];i;i=e[i].nxt)
		{
			int y=e[i].to;
			if(dis[y]<dis[x]+e[i].cost&&e[i].flow>0)
			{
				dis[y]=dis[x]+e[i].cost;
				if(!vis[y])q.push(y),vis[y]=1;
			}
		}
	}
	return dis[T]!=-inf;
}
ll dfs(int x,ll lim)
{
	vis[x]=1;
	if(x==T||lim<=0)return lim;
	ll res=lim;
	for(int i=head[x];i;i=e[i].nxt)
	{
		int y=e[i].to;
		if(dis[y]!=dis[x]+e[i].cost||e[i].flow<=0||vis[y])continue;
		ll tmp=dfs(y,min(res,e[i].flow));
		res-=tmp;
		e[i].flow-=tmp;e[i^1].flow+=tmp;
		if(res<=0)break;
	}
	return lim-res;
}
inline ll Dinic()
{
	ll res=0,cost=0;
	while(spfa())
	{
		ll flow=dfs(S,inf);
		if(cost+flow*dis[T]>=0)res+=flow,cost+=flow*dis[T];
		else 
		{
			res+=min(flow,cost/(-dis[T]));
			break;
		}
	}
	return res;
}
int main()
{
	//freopen("test.in","r",stdin);
	//freopen("test.out","w",stdout);
	pre_work();
	n=read();
	for(int i=1;i<=n;i++)a[i]=read();
	for(int i=1;i<=n;i++)b[i]=read();
	for(int i=1;i<=n;i++)c[i]=read();
	for(int i=1;i<=n;i++)
	{	
		int tmp=a[i];
		for(unsigned int j=0;j<prime.size()&&1ll*prime[j]*prime[j]<=tmp;j++)
			while(tmp%prime[j]==0)cnt[i]++,tmp/=prime[j];
		if(tmp>1)cnt[i]++;
	}
	S=0,T=n+1;
	for(int i=1;i<=n;i++)
		if(cnt[i]&1)addflow(S,i,b[i],0);
		else addflow(i,T,b[i],0);
	for(int i=1;i<=n;i++)
		for(int j=i+1;j<=n;j++)
		{
			int x=a[i],y=a[j];
			if(((x%y!=0)&&(y%x!=0))||abs(cnt[i]-cnt[j])!=1)continue;
			x=i,y=j;
			if(cnt[y]&1)swap(x,y);
			addflow(x,y,1ll*b[x]*b[y],1ll*c[x]*c[y]);
		}
	printf("%lld",Dinic());
	return 0;
}
```


---

## 作者：蒟蒻初音ミク (赞：2)

# 广告

[蒟蒻的blog](http://www.luogu.com.cn/blog/111990/#)

# 正文

首先看完题，本蒟蒻也是一点思路也没有，直到看到下面的特殊数据：

![](https://cdn.luogu.com.cn/upload/image_hosting/gnkmxy0o.png)

~~然而并没有什么卵用~~

注意到那个特殊数据没有：$c_i>0$，这个数据意味着什么？意味着想选多少选多少！

那么怎么才能够知道最多能选多少呢？？？我们应该可以很自然地想到用网路流：

### 上图

![](https://cdn.luogu.com.cn/upload/image_hosting/hkweddvj.png)

首先把每一个点拆成两个点，然后左部点与源点连边（**绿色边**），容量为$b[i]$，费用为$0$；右部点与汇点连边（**蓝色边**），容量为$b[i]$，费用为$0$。最后枚举$i$,$j$。若满足$a[i]$是$a[j]$的倍数且$a[i]/a[j]$为质数，就把左部点的第i个与右部点的第$j$个连边（**红色边**），容量为$inf$，费用为$c[i] \times c[j]$。

最后跑一边**最大费用最大流**，答案是$maxflow>>1$（至于为什么要$>>1$,后面会讲）。

然后对于$100\%$的数据，就只剩下两个问题了：

## 一：判断$a[i]/a[j]$是否为质数

这里我们用$millar \_ rabbin$判素数法（当然也可以用暴力枚举到$\sqrt{n}$的办法，只是$millar \_ rabbin$较快）

```cpp
inline ll qmi(ll x,ll y,ll p)//快速幂
{
	if(!y)return 1;
	ll t=qmi(x,y>>1,p);
	if(y&1)return t*t%p*(x%p)%p;
	return t*t%p;
}

inline bool millar_rabbin(int n)//millar_rabbin的函数，若n为质数则返回1，否则返回0
{
	if(n==0||n==1)return 0;
	if(n==2)return 1;
	if(!(n&1))return 0;
	int u=n-1,cnt=0;
	while(!(u&1))++cnt,u>>=1;
	ll x,y;
	for(re int i=1;i<=100;++i)//验证100次
	{
		int a=rand()%(n-1)+1;
		x=qmi(a,u,n);
		for(re int j=1;j<=cnt;++j)
		{
			y=x*x%n;
			if(y==1&&x!=1&&x!=n-1)return 0;
			x=y;
		}
		if(x!=1)return 0;
	}
	return 1;
}
```

## 二：解决在费用$>0$的情况下的最大流

这个时候就需要我们来观察一下求最大费用最大流的$dfs$函数：

```cpp
//注意打斜杠的几行代码
inline int dfs(int now,int limit)
{
	if(now==t||!limit)//
	{
		feiyong+=dis[now]*limit;//
		return limit;//
	}
	int flow=0,v,f;
	vis[now]=1;
	for(re int &i=cur[now];i;i=edge[i].next)
	{
		v=edge[i].to;
		if(edge[i].f&&dis[v]==dis[now]+edge[i].w&&!vis[v])
		{
			f=dfs(v,min(limit,edge[i].f));
			edge[i].f-=f;
			edge[i^1].f+=f;
			limit-=f;
			flow+=f;
			if(!limit)break;
		}
	}
	if(!flow)dis[now]=0;
	return flow;
}

inline void dinic()
{
	while(spfa())maxflow+=dfs(s,inf);
}
```

我们可以发现，当我们的$feiyong<0$时，说明的我们的流量太大了，即原来的$feiyong$不够我们来增广流量，而通过$dfs$函数我们可以发现：

## 每增加$1$的流量，费用就会减少$(-dis[t])$

所以在我们发现$feiyong<0$的时候，保存一下前一次的费用，再用前一次的流量来换取流量，即改一下$dinic$函数：

```cpp
inline void dinic()
{
	while(spfa())
	{
		ll temp=feiyong;
		int flow=dfs(s,inf);
		if(feiyong<0)//费用小于0了，说明流量太大了 
		{
			maxflow+=temp/(-dis[t]);//把原来正的费用用来换流量，能换多少是多少 
			return;
		}
		maxflow+=flow;
	}
}
```

那么这道题最难的地方也就被我们解决了（~~自豪感满满~~）

## 最后有一些细节：

1.是$maxflow+=last \_ feiyong/(-dis[t])$，因为$dis[t]$本来是负数（不然$feiyong$怎么会减少呢），换流量的时候就要将其变为正数。

2.最后的答案是$maxflow>>1$，因为$a[i]$和$a[j]$连接了边，$a[j]$和$a[i]$也连接了边，相当于多连接了一条边，将流量和费用都$\times 2$，所以最后的答案是$maxflow>>1$。

最后上完整代码：

## code:

```cpp
#include <queue>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;

#define re register
#define ll long long
#define N 200
#define inf 0x7f7f7f7f
#define infll 0x7f7f7f7f7f7f7f7fll

struct ed{
	int to,next,f;
	ll w;
}edge[N*N*2+10];int tot=1;
int head[N*2+10],cur[N*2+10];

inline void adde_double(int u,int v,int f,ll w)
{
//	printf("u==%d v==%d f==%d w==%lld\n",u,v,f,w);
	edge[++tot].to=v;
	edge[tot].next=head[u];
	edge[tot].f=f;
	edge[tot].w=w;
	head[u]=tot;

	edge[++tot].to=u;
	edge[tot].next=head[v];
	edge[tot].f=0;
	edge[tot].w=-w;
	head[v]=tot;
}

int n,m,s,t;
ll dis[N*2+10];
bool vis[N*2+10];
queue<int>q;

inline bool spfa()
{
	memset(vis,0,sizeof(vis));
	while(!q.empty())q.pop();
	for(re int i=s;i<=t;++i)dis[i]=-infll;
	for(re int i=s;i<=t;++i)cur[i]=head[i];
	dis[s]=0;q.push(s);vis[s]=1;
	while(!q.empty())
	{
		int now=q.front();q.pop();vis[now]=0;
		for(re int i=head[now];i;i=edge[i].next)
		{
			int v=edge[i].to;
			if(edge[i].f&&dis[v]<dis[now]+edge[i].w)
			{
				dis[v]=dis[now]+edge[i].w;
				if(!vis[v])q.push(v),vis[v]=1;
			}
		}
	}
	return dis[t]!=-infll;
}

ll feiyong;

inline int dfs(int now,int limit)
{
	if(now==t||!limit)
	{
		feiyong+=dis[now]*limit;
		return limit;
	}
	int flow=0,v,f;
	vis[now]=1;
	for(re int &i=cur[now];i;i=edge[i].next)
	{
		v=edge[i].to;
		if(edge[i].f&&dis[v]==dis[now]+edge[i].w&&!vis[v])
		{
			f=dfs(v,min(limit,edge[i].f));
			edge[i].f-=f;
			edge[i^1].f+=f;
			limit-=f;
			flow+=f;
			if(!limit)break;
		}
	}
	if(!flow)dis[now]=0;
	return flow;
}

int a[N+10],b[N+10],c[N+10],maxflow;

inline void dinic()
{
	while(spfa())
	{
		ll temp=feiyong;
		int flow=dfs(s,inf);
		if(feiyong<0)//费用小于0了，说明流量太大了 
		{
			maxflow+=temp/(-dis[t]);//把原来正的费用用来换流量，能换多少是多少 
			return;
		}
		maxflow+=flow;
	}
}

inline ll qmi(ll x,ll y,ll p)
{
	if(!y)return 1;
	ll t=qmi(x,y>>1,p);
	if(y&1)return t*t%p*(x%p)%p;
	return t*t%p;
}

inline bool millar_rabbin(int n)
{
	if(n==0||n==1)return 0;
	if(n==2)return 1;
	if(!(n&1))return 0;
	int u=n-1,cnt=0;
	while(!(u&1))++cnt,u>>=1;
	ll x,y;
	for(re int i=1;i<=100;++i)
	{
		int a=rand()%(n-1)+1;
		x=qmi(a,u,n);
		for(re int j=1;j<=cnt;++j)
		{
			y=x*x%n;
			if(y==1&&x!=1&&x!=n-1)return 0;
			x=y;
		}
		if(x!=1)return 0;
	}
	return 1;
}

int main()
{
	scanf("%d",&n);
	s=0,t=n*2+1;
	for(re int i=1;i<=n;++i)scanf("%d",&a[i]);
	for(re int i=1;i<=n;++i)scanf("%d",&b[i]),adde_double(s,i,b[i],0),adde_double(i+n,t,b[i],0);
	for(re int i=1;i<=n;++i)scanf("%d",&c[i]);
	for(re int i=1;i<=n;++i)
	{
		for(re int j=1;j<=n;++j)
		{
			int x=a[i],y=a[j];
			if(x>y)swap(x,y);
			if(y%x==0&&millar_rabbin(y/x))adde_double(i,j+n,inf,(ll)c[i]*(ll)c[j]);
		}
	}
	dinic();
	printf("%d\n",maxflow/2);
	return 0;
}
```

---

## 作者：杨铠远 (赞：2)

## 怎么能不用$dinic$跑费用流呢
此题思路其他大佬讲的已经很清楚了
我来重点讲一讲$dinic$费用流的实现

spfa部分
```cpp
inline int spfa(){
	queue<int>q;
	memset(vis,0,sizeof(vis));
	for(int i=0;i<=n+1;i++)d[i]=-inf;
	d[s]=0;
	q.push(s);
	while(!q.empty()){
		int u=q.front();q.pop();vis[u]=0;
		for(int i=head[u];i;i=edge[i].nxt){
			int v=edge[i].v;
			if(edge[i].w&&d[v]<d[u]+edge[i].c){
				d[v]=d[u]+edge[i].c;
				if(!vis[v]){
					q.push(v);
					vis[v]=1;
				}
			}
		}
	}
	return d[t]>-inf;
}
```
这里只需要注意清空$vis$数组，因为跑$dinic$的时候还要用到$vis$标记


$dinic$部分
```cpp
inline int dinic(int u,int flow){
	if(u==t)return flow;
	int rest=flow,k;
	vis[u]=1;
	for(int i=head[u];i&&rest;i=edge[i].nxt){
		int v=edge[i].v;
		if(vis[v])continue;
		if(d[v]==d[u]+edge[i].c&&edge[i].w){
			k=dinic(v,min(rest,edge[i].w));
			if(!k)d[v]=0;
			edge[i].w-=k;
			edge[i^1].w+=k;
			rest-=k;
		}
	}
	return flow-rest;
}
```
到达一个点时，打上标记，
遍历出边时如果已经标记过$continue$掉

每次跑完$dinic$都要清空标记数组



完整代码
```cpp
//Code by : Y-k-y
#include <iostream>
#include <algorithm>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <queue>
#include <vector>
#include <set>
#include <map>
#define int long long
const int N=100010;
const int inf=1ll<<60;
using namespace std;
inline int rnd(){
	int res=0,f=1;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}
	while(isdigit(ch)){res=res*10+ch-'0';ch=getchar();}
	return res*f;
}
inline void wr(int x){
	if(x<0){putchar('-');x=-x;}if(x>9) wr(x/10);putchar(x%10+'0');
}
int a[N],b[N],c[N],d[N],pr[N],cnt,num[N],aa[N],ans,s,t,sum;
bool chk[N],vis[N];
struct pp{
	int v,nxt,w,c;
}edge[N];
int head[N],n,tot=1;
inline void add(int u,int v,int w,int cc){
	edge[++tot].nxt=head[u],head[u]=tot;
	edge[tot].v=v,edge[tot].w=w,edge[tot].c=cc;
	edge[++tot].nxt=head[v],head[v]=tot;
	edge[tot].v=u,edge[tot].w=0,edge[tot].c=-cc;
}
inline void uim(){
	for(int i=2;i<N;i++){
		if(!chk[i])pr[++cnt]=i;
		for(int j=1;j<=cnt;j++){
			if(i*pr[j]>N)break;
			chk[i*pr[j]]=1;
			if(!(i%pr[j]))break;
		}
	}
}
inline int spfa(){
	queue<int>q;
	memset(vis,0,sizeof(vis));//清空 
	for(int i=0;i<=n+1;i++)d[i]=-inf;
	d[s]=0;
	q.push(s);
	while(!q.empty()){
		int u=q.front();q.pop();vis[u]=0;
		for(int i=head[u];i;i=edge[i].nxt){
			int v=edge[i].v;
			if(edge[i].w&&d[v]<d[u]+edge[i].c){
				d[v]=d[u]+edge[i].c;
				if(!vis[v]){
					q.push(v);
					vis[v]=1;
				}
			}
		}
	}
	return d[t]>-inf;
}
inline int dinic(int u,int flow){
	if(u==t)return flow;
	int rest=flow,k;
	vis[u]=1;//打标记 
	for(int i=head[u];i&&rest;i=edge[i].nxt){
		int v=edge[i].v;
		if(vis[v])continue;//
		if(d[v]==d[u]+edge[i].c&&edge[i].w){
			k=dinic(v,min(rest,edge[i].w));
			if(!k)d[v]=0;
			edge[i].w-=k;
			edge[i^1].w+=k;
			rest-=k;
		}
	}
	return flow-rest;
}
signed main(){
	cin>>n;t=n+1;
	for(int i=1;i<=n;i++)aa[i]=a[i]=rnd();
	for(int i=1;i<=n;i++)b[i]=rnd();
	for(int i=1;i<=n;i++)c[i]=rnd();
	uim();
	for(int i=1;i<=n;i++){
		for(int j=1;j<=cnt;j++){
			if(a[i]<pr[j])break;
			if(!(a[i]%pr[j])){
				while(!(a[i]%pr[j])){
					num[i]++;a[i]/=pr[j];
				}
			}
		}
		if(a[i]!=1)num[i]++;
	}
	for(int i=1;i<=n;i++){
		if(num[i]&1)add(s,i,b[i],0);
		else add(i,t,b[i],0);
		if(num[i]&1)
		for(int j=1;j<=n;j++){
			if((!(aa[i]%aa[j])&&num[i]==num[j]+1)||((!(aa[j]%aa[i]))&&num[j]==num[i]+1)){
				add(i,j,inf,c[i]*c[j]);
			}
		}
	}
	int flow=0;
	bool flag=0;
	while(spfa()){
		while(flow=dinic(s,inf),flow!=0){
			for(int i=0;i<=n+1;i++)vis[i]=0;//清空 
			if(sum+d[t]*flow>=0){
				ans+=flow;sum+=d[t]*flow;
			}
			else{
				ans+=sum/(-d[t]);
				flag=1;break;
			}
		}
		if(flag)break;
	}
	wr(ans);
	return 0;
}

```




---

## 作者：Christopher_Yan (赞：1)

#### 题目描述
若两个数字 $a_i,a_j$ 满足，$a_i$是 $a_j$的倍数，且 $\frac{a_i}{a_j}$是一个质数，那么这两个数字可以配对，并获得 $c_i \times c_j$的价值。
一个数字只能参与一次配对，可以不参与配对。
在获得的价值总和不小于$0$的前提下，求最多进行多少次配对。


#### 解题思路
这个题模考时想到了网络流：一开始觉得建个图跑费用流就可以了，但是发现有个问题就是每个点既可以去匹配别人，也可以被别人匹配，这样就会导致很难去限制流量。
解决方法是：合理假设，感性证明。
我们仿佛可以隐隐的感觉到，如果$a$点匹配$b$点，$c$点也匹配了$b$点，$a,c$的值互不相等，则$a,c$不能相互匹配。至于证明我们可以设几个未知数算一下（我的证明可能不是很严谨，就不来误导新人了，但是感觉自己的证明没什么问题）。这样一波操作下来，图就变成了二分图，我们可以上左边的点作为匹配点，右边的点当作被匹配点，问题愉快解决。
注意跑费用流时，我们在EK中每增广一次就看一下总费用有没有小于$0$，有的话就跳出来，尝试一流量一流量的增广即可。

但是只拿了50分，原因两点：
1. 没开`long long`，我这是要**自毙**的节奏。
2. 最后单步增广的条件写残了，导致没有最后的单步增广（这还能得50分，233）。

改正以上问题就可以AC了。

#### AC代码
```cpp
#include<algorithm>
#include<iostream>
#include<climits>
#include<cstring>
#include<cstdio>
#include<cctype>
#include<queue>
#define int long long
using namespace std;

const int N=301010;
const int inf=LONG_LONG_MAX>>1;
int n,S,T;
int dis[N],pre[N],a[N],b[N],c[N],vis[N],id[N];
int ec=-1,f[N],nxt[N],to[N],bg[N],w[N],fe[N];

inline void read(int &x){
	int k=1;x=0;char c=getchar();
	while(!isdigit(c)) {if(c=='-')k*=-1;c=getchar();}
	while(isdigit(c)) x=(x<<1)+(x<<3)+(c^48),c=getchar();x*=k;
}
inline void Addedge_fir(int a,int b){
	++ec,to[ec]=b,bg[ec]=a,nxt[ec]=f[a],f[a]=ec;
	++ec,to[ec]=a,bg[ec]=b,nxt[ec]=f[b],f[b]=ec;
}
inline void Addedge_sec(int i,int a,int b){
	fe[i]=c[a]*c[b],w[i]=inf,i^=1;
	fe[i]=c[a]*c[b]*-1,w[i]=0;
}
inline void Addedge_thd(int a,int d){
	if(S==a)
	++ec,to[ec]=d,bg[ec]=a,fe[ec]=0,w[ec]=b[d],nxt[ec]=f[a],f[a]=ec,
	++ec,to[ec]=a,bg[ec]=d,fe[ec]=0,w[ec]=0,nxt[ec]=f[d],f[d]=ec;
	if(T==d)
	++ec,to[ec]=d,bg[ec]=a,fe[ec]=0,w[ec]=b[a],nxt[ec]=f[a],f[a]=ec,
	++ec,to[ec]=a,bg[ec]=d,fe[ec]=0,w[ec]=0,nxt[ec]=f[d],f[d]=ec;
}
inline bool Isp(int x){
	for(int i=2;i*i<=x;++i)
		if(x%i==0) return false;
	return true;
}
void DFS(int u,int cid){
	vis[u]=1,id[u]=cid;
	for(int i=f[u];i!=-1;i=nxt[i])
		if(!vis[to[i]])
			DFS(to[i],cid^1);
}
inline bool SPFA(){
	fill(pre+1,pre+N,0);
	fill(vis+1,vis+N,0);
	fill(dis+1,dis+N,-inf);
	queue<int> Q; Q.push(S);
	vis[S]=1,dis[S]=0;
	while(!Q.empty()){
		int u=Q.front();Q.pop();vis[u]=0;
		for(int i=f[u];i!=-1;i=nxt[i])
			if(w[i]&&dis[to[i]]<dis[u]+fe[i]){
				dis[to[i]]=dis[u]+fe[i],pre[to[i]]=i;
				if(!vis[to[i]]) vis[to[i]]=1,Q.push(to[i]);
			}
	}
	return dis[T]!=-inf;
}
inline void MCMF(){
	int ans=0,out=0,minn;
	while(SPFA()){
		minn=inf;
		for(int i=T;i!=S;i=bg[pre[i]])
			minn=min(minn,w[pre[i]]);
		for(int i=T;i!=S;i=bg[pre[i]])
			w[pre[i]]-=minn,w[pre[i]^1]+=minn;
		if(ans+minn*dis[T]<0) break;
		ans+=minn*dis[T],out+=minn;
	}
	if(dis[T]!=inf) while(ans+dis[T]>=0) 
		++out,ans+=dis[T];
	printf("%lld",out);
}
signed main(){
	read(n),S=n+1;T=S+1;
	memset(f,-1,sizeof(f));
	memset(id,-1,sizeof(id));
	for(int i=1;i<=n;++i) read(a[i]);
	for(int i=1;i<=n;++i) read(b[i]);
	for(int i=1;i<=n;++i) read(c[i]);
	for(int i=1;i<=n;++i)
		for(int j=i+1;j<=n;++j)
			if((a[i]%a[j]==0&&Isp(a[i]/a[j]))||(a[j]%a[i]==0&&Isp(a[j]/a[i])))
				Addedge_fir(i,j);
	for(int i=1;i<=n;++i) if(!vis[i]) DFS(i,1); 
	int eec=ec;memset(vis,0,sizeof(vis));
	for(int i=0;i<=eec;++i)
		if(id[bg[i]]==1){
			Addedge_sec(i,bg[i],to[i]);
			if(!vis[bg[i]]) vis[bg[i]]=1,Addedge_thd(S,bg[i]);
			if(!vis[to[i]]) vis[to[i]]=1,Addedge_thd(to[i],T);
		}
	return MCMF(),0;
}
```

---

## 作者：asuldb (赞：1)

[题目](https://www.luogu.org/problemnew/show/P4068)

发现要求配对的条件是这样

$$a_j|a_i,\frac{a_i}{a_j}=p_1$$

我们考虑一下再来一个$a_k$，满足

$$a_k|a_j,\frac{a_j}{a_k}=p_2$$

显然$a_i=a_jp_1,a_j=a_kp_2$，于是$a_i=p_1p_2\times a_k$

显然$p_1p_2$不会是一个质数，于是我们大胆得出一个结论，如**果$a_i$能和$a_j$配对，那么$a_i$就不能和其他能和$a_j$配对的数配对**

于是经过这样一番简单分析，发现这是一二分图

那么做法就很显然了，我们将这张图来一个黑白染色，之后按照题目要求连边就好了

至于这道题要求在费用为正的情况下流量最大，最大费用最大流只能保证最大流的时候费用最大，不能保证费用为正

但是我们知道$spfa$去增广出的最长路肯定越来越小，于是我们一旦发现当前费用乘上流量小于$0$了，以后就不可能再使得费用为正了，于是在这个之后判断一下剩余流量退出就好了

当然，由于只会写板子，还是边权取反的最小费用最大流好写

代码

```cpp
#include<queue>
#include<vector>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#define re register
#define LL long long
#define max(a,b) ((a)>(b)?(a):(b))
#define min(a,b) ((a)<(b)?(a):(b))
#define int long long
const int maxn=205;
const int inf=99999999999;
inline int read() {
	char c=getchar();int r=1,x=0;
	while(c<'0'||c>'9') {if(c=='-') r=-1;c=getchar();}
	while(c>='0'&&c<='9') x=(x<<3)+(x<<1)+c-48,c=getchar();return r*x;
}
std::vector<int> v[maxn];
std::queue<int> q;
struct E{int v,nxt,f;LL w;}e[205*205*10];
int head[maxn],d[maxn],vis[maxn];
int a[maxn],b[maxn],c[maxn],col[maxn];
int S,T,n,num=1;
inline void C(int x,int y,LL w,int f) {
	e[++num].v=y;e[num].nxt=head[x];head[x]=num;
	e[num].f=f,e[num].w=w;
}
inline void add(int x,int y,LL w,int f) {C(x,y,-1*w,f),C(y,x,w,0);}
inline int SPFA() {
	for(re int i=S;i<=T;i++) vis[i]=0,d[i]=inf;
	q.push(T),d[T]=0;
	while(!q.empty()) {
		int k=q.front();q.pop();vis[k]=0;
		for(re int i=head[k];i;i=e[i].nxt) 
		if(e[i^1].f&&d[e[i].v]>d[k]+e[i^1].w) {
			d[e[i].v]=d[k]+e[i^1].w;
			if(!vis[e[i].v]) q.push(e[i].v),vis[e[i].v]=1;
		}
	}
	return d[S]<inf;
}
int dfs(int x,int now) {
	if(x==T||!now) return now;
	int flow=0,ff;vis[x]=1;
	for(re int i=head[x];i;i=e[i].nxt)
	if(!vis[e[i].v]&&e[i].f&&d[e[i].v]==d[x]+e[i^1].w) {
		ff=dfs(e[i].v,min(now,e[i].f));
		if(ff<=0) continue;
		now-=ff,flow+=ff;e[i].f-=ff,e[i^1].f+=ff;
		if(!now) break;
	}
	return flow;
}
inline int check(int x) {
	if(x==1) return 0;
	for(re int i=2;i*i<=x;i++)
		if(x%i==0) return 0;
	return 1;
}
void paint(int x,int now) {
	col[x]=now;
	for(re int i=0;i<v[x].size();i++)
	if(col[v[x][i]]==2) paint(v[x][i],now^1); 
}
signed main() {
	n=read();T=n+1;
	for(re int i=1;i<=n;i++) a[i]=read();
	for(re int i=1;i<=n;i++) b[i]=read();
	for(re int i=1;i<=n;i++) c[i]=read();
	for(re int i=1;i<=n;i++)
		for(re int j=1;j<=n;j++)
			if(a[i]%a[j]==0&&check(a[i]/a[j])) 
				v[i].push_back(j),v[j].push_back(i);
	for(re int i=1;i<=n;i++) col[i]=2;
	for(re int i=1;i<=n;i++) 
		if(col[i]==2) paint(i,1);
	for(re int i=1;i<=n;i++)
	if(col[i]) add(S,i,0,b[i]);
		else add(i,T,0,b[i]);
	for(re int i=1;i<=n;i++) {
		if(!col[i]) continue;
		for(re int j=0;j<v[i].size();j++) 
			add(i,v[i][j],(LL)c[i]*(LL)c[v[i][j]],inf);
	}
	int t=0,ans=0,flag=1,F=0;
	while(SPFA()) {
		vis[T]=1;
		while(vis[T]) {
			for(re int i=S;i<=T;i++) vis[i]=0;
			t=dfs(S,inf);
			if(ans+t*d[S]>0) {
				F+=(0-ans)/d[S];
				flag=0;break;
			}
			ans+=t*d[S],F+=t;
		}
		if(!flag) break;
	}
	printf("%lld\n",F);
	return 0;
}
```


---

## 作者：MiniLong (赞：0)

一道网络流好题。

~~网络流，网络建模最毒瘤~~

看题目就很像一个二分图匹配问题，但会有几个问题。

- 每个数字只能参与 $1$ 次配对，所以不能把这 $n$ 个点都放在两边跑匹配。

- 这题要求的是在 **费用大于 $0$ 的情况下，最大的流**，而不是传统的 **保证流最大的情况下，最大的费用**。

先将这几个问题一一解决。

首先是如何将这 $n$ 个点分到两边。

可以发现一个性质。因为当 $a_i$ 和 $a_j$ 能匹配时，当且仅当 $a_i = a_j \times p$ （$p = \dfrac{a_i}{a_j} $，且 $p$ 为质数），**所以 $a_i$ 的质因数个数一定是 $a_j$ 质因数个数加一**。

有了这个性质，我们可以将这 $n$ 个点通过质因数个数的奇偶性分成两边，再连边匹配。

再解决如何保证费用大于 $0$。

可以使用贪心的思想。

对于每次最长路跑出来的权值和 $dis$ 和最大能通过的流量 $flow$，如果当前的答案 $ans + dis \times flow \ge 0$ 的话，那么显然这 $flow$ 个流量是肯定能流的。（因为每次增广权值和都是当前可流的最大的了）。

那如果 $ans + dis \times flow < 0$，就最多只能流 $\left\lfloor\dfrac{-now}{dis}\right\rfloor$ 了。（跟上面同理，如果最大的权值加上去都小于 $0$ 了，那么更小的肯定流不过去了）然后就可以退出增广了。

然后就是常规的建模啦~

$s$ 向每个左边的 $i$，连流量为 $b_i$，费用为 $0$。

每个可匹配的左边的 $i$ 和右边的 $j$，连流量为 $inf$，费用为 $-c_i \times c_j$（因为是最大费用，所以取相反数跑最小费用）

每个右边的 $j$ 向 $t$，连流量为 $b_j$，费用为 $0$。

然后按上面说的跑就好了。

```cpp
#include <bits/stdc++.h>
#define int long long
#define _rep(i, x, y) for(int i = x; i <= y; ++i)
#define _req(i, x, y) for(int i = x; i >= y; --i)
#define _rev(i, u) for(int i = head[u]; i; i = e[i].nxt)
#define pb(x) push_back(x)
#define mst(f, i) memset(f, i, sizeof f)
using namespace std;
#ifdef ONLINE_JUDGE
#define debug(...) 0
#else
#define debug(...) fprintf(stderr, __VA_ARGS__), fflush(stderr)
#endif
namespace fastio{
    template<typename T> inline void read(T &t){
        T x = 0, f = 1;
        char c = getchar();
        while(!isdigit(c)){
            if(c == '-') f = -f;
            c = getchar();
        }
        while(isdigit(c)) x = x * 10 + c - '0', c = getchar();
        t = x * f;
    }
    template<typename T, typename ... Args> inline void read(T &t, Args&... args){
        read(t);
        read(args...);
    }
    template<typename T> void write(T t){
        if(t < 0) putchar('-'), t = -t;
        if(t >= 10) write(t / 10);
        putchar(t % 10 + '0');
    }
    template<typename T, typename ... Args> void write(T t, Args... args){
        write(t), putchar(' '), write(args...);
    }
    template<typename T> void writeln(T t){
        write(t);
        puts("");
    }
    template<typename T> void writes(T t){
        write(t), putchar(' ');
    }
};
using namespace fastio;
typedef long long ll;
typedef pair<int, int> PII;
const int N = 1e6 + 5, inf = 0x3f3f3f3f3f3f3f3f, M = 1005;
int n, m, s, t;
int ecnt = 1, head[N];
struct edge{
	int v, w, c, nxt;
}e[N << 1];
void add(int u, int v, int w, int c){
	e[++ecnt] = edge{v, w, c, head[u]}, head[u] = ecnt;
	e[++ecnt] = edge{u, 0, -c, head[v]}, head[v] = ecnt;
	debug("link : %d -> %d, w = %d, c = %d\n", u, v, w, c);
}
int dis[N], cur[N];
bool vis[N];
bool spfa(int s, int t){
	mst(dis, inf);
	queue<int> q;
	q.push(s), dis[s] = 0, cur[s] = head[s], vis[s] = 1;
	while(q.size()){
		int u = q.front(); q.pop();
		vis[u] = 0;
		_rev(i, u){
			int v = e[i].v;
			if(e[i].w && dis[v] > dis[u] + e[i].c){
				dis[v] = dis[u] + e[i].c;
				cur[v] = head[v];
				if(!vis[v]){
					vis[v] = 1;
					q.push(v);
				}
			}
		}
	}
	return dis[t] != inf;
}
int Flow, Cost;
int dfs(int u, int in){
	int out = 0;
	if(u == t){
		return in;
	}
	vis[u] = 1;
	for(int i = cur[u]; i && in; i = e[i].nxt){
		int v = e[i].v;
		cur[u] = i;
		if(e[i].w && !vis[v] && dis[v] == dis[u] + e[i].c){
			int d = dfs(v, min(in, e[i].w));
			e[i].w -= d, e[i ^ 1].w += d;
			in -= d, out += d;
		}
	}
	vis[u] = 0;
	return out;
}
void Dinic(){
	Cost = Flow = 0;
	while(spfa(s, t)){
		int d = dfs(s, inf);
		int now = dis[t];
		if(Cost + now * d <= 0){
			Flow += d;
			Cost += now * d;
			continue;
		}
		int delta = -Cost / now;
		Flow += delta;
		Cost += now * delta;
		break;
	}
}
int a[205], b[205], c[205];
namespace Miller_Rabin{
    mt19937 rnd(time(0));
    int test = 8;
    ll ksm(ll p, ll h, ll P){
        ll base = p, res = 1;
        while(h){
            if(h & 1ll) res = res * base % P;
            h >>= 1ll, base = base * base % P;
        }
        return res;
    }
    bool isprime(ll n){
        if(n < 3 || n % 2 == 0) return n == 2;
        ll a = n - 1, b = 0;
        while(!(a & 1ll)) b++, a >>= 1ll;
        _rep(i, 1, test){
            ll x = rnd() % (n - 2) + 2, v = ksm(x, a, n), j = 1, nxt;
            for(j = 1; j <= b; ++j){
                nxt = v * v % n;
                if(v != 1 && v != n - 1 && nxt == 1) return 0;
                v = nxt; 
            }
            if(v != 1) return 0;
        }
        return 1;
    }
};
int cnt[205];
signed main(){
	read(n), s = 0, t = 2 * n + 1;
	_rep(i, 1, n){
		read(a[i]);	
		int x = a[i];
		for(int j = 2; j * j <= x; ++j){
			if(x % j) continue;
			while(x % j == 0) cnt[i]++, x /= j;
		}
		if(x > 1) cnt[i]++;
	}
	_rep(i, 1, n) read(b[i]);
	_rep(i, 1, n) read(c[i]);
	_rep(i, 1, n){
		if(cnt[i] % 2) add(s, i, b[i], 0);
		else add(i, t, b[i], 0);
	}
	_rep(i, 1, n){
		_rep(j, 1, n){
			if(cnt[i] % 2 == cnt[j] % 2) continue;
			if(a[i] % a[j] || !Miller_Rabin::isprime(a[i] / a[j])){
				continue;
			}
			if(cnt[i] % 2) add(i, j, inf, -c[i] * c[j]);
			else add(j, i, inf, -c[i] * c[j]);
		}
	}	
	Dinic();
	writeln(Flow);
    return 0;
}
```

---

## 作者：Leasier (赞：0)

前置芝士：[二分图](https://oi-wiki.org/graph/bi-graph/)、[费用流](https://oi-wiki.org/graph/flow/min-cost/)

考虑将两个数字 $a_i, a_j$ 可以匹配的条件转化为 $a_i \bmod a_j = 0$ 且 $\Omega(a_i) = \Omega(a_j) + 1$。

如果你的图论跟我一样菜，你会把可以连边的 $i \to j$ 连起来，并发现连出来的图是一个 DAG，而且可以根据 $\Omega$ 值的奇偶性对其分层。

这个时候明眼人（即指除我这样的瞎子之外）应该都能看出这个 DAG 可以根据 $\Omega$ 值的奇偶性构造二分图了，于是原问题转化成了一个**二分图最大权匹配**的问题，可以用**最大费用最大流求解**。

最后再来考虑“在获得的价值总和不小于 $0$ 的前提下”这句话，发现我们只需要将边权设为匹配的价值，并在跑费用流时特判一下：如果当前总费用加上流满当前增广路的总费用 $< 0$ 了，在当前增广路上搞尽可能多的流量并退出即可。

代码：
```cpp
#include <iostream>
#include <queue>

using namespace std;

typedef long long ll;

typedef struct {
	int nxt;
	int end;
	int dis;
	ll cost;
} Edge;

int cnt = 1;
int a[207], omega[207], b[207], c[207], head[207], pre_dot[207], pre_edge[207];
ll dis[207];
bool vis[207];
Edge edge[80407];
queue<int> q;

inline void init(int n){
	for (register int i = 0; i <= n; i++){
		dis[i] = 0x8000000000000000ll;
		vis[i] = false;
	}
}

inline int get_omega(int n){
	int ans = 0;
	for (register int i = 2; i * i <= n; i++){
		while (n % i == 0){
			n /= i;
			ans++;
		}
	}
	if (n > 1) ans++;
	return ans;
}

inline void add_edge(int start, int end, int dis, ll cost){
	cnt++;
	edge[cnt].nxt = head[start];
	head[start] = cnt;
	edge[cnt].end = end;
	edge[cnt].dis = dis;
	edge[cnt].cost = cost;
}

inline void spfa(int start){
	dis[start] = 0;
	vis[start] = true;
	q.push(start);
	while (!q.empty()){
		int cur = q.front();
		q.pop();
		vis[cur] = false;
		for (register int i = head[cur]; i != 0; i = edge[i].nxt){
			if (edge[i].dis != 0){
				int x = edge[i].end;
				ll y = dis[cur] + edge[i].cost;
				if (dis[x] < y){
					dis[x] = y;
					pre_dot[x] = cur;
					pre_edge[x] = i;
					if (!vis[x]){
						vis[x] = true;
						q.push(x);
					}
				}
			}
		}
	}
}

inline pair<int, ll> maxcost_maxflow(int n, int start, int end){
	pair<int, ll> ans(0, 0);
	while (true){
		init(n);
		spfa(start);
		if (dis[end] == 0x8000000000000000ll) break;
		int flow = 0x7fffffff;
		bool flag;
		for (register int i = end; i != start; i = pre_dot[i]){
			flow = min(flow, edge[pre_edge[i]].dis);
		}
		if (ans.second + flow * dis[end] < 0){
			flow = ans.second / -dis[end];
			flag = true;
		} else {
			flag = false;
		}
		for (register int i = end; i != start; i = pre_dot[i]){
			edge[pre_edge[i]].dis -= flow;
			edge[pre_edge[i] ^ 1].dis += flow;
		}
		ans.first += flow;
		ans.second += flow * dis[end];
		if (flag) break;
	}
	return ans;
}

int main(){
	int n, end;
	cin >> n;
	end = n + 1;
	for (register int i = 1; i <= n; i++){
		cin >> a[i];
		omega[i] = get_omega(a[i]);
	}
	for (register int i = 1; i <= n; i++){
		cin >> b[i];
	}
	for (register int i = 1; i <= n; i++){
		cin >> c[i];
	}
	for (register int i = 1; i <= n; i++){
		if (omega[i] % 2 == 0){
			add_edge(0, i, b[i], 0);
			add_edge(i, 0, 0, 0);
		} else {
			add_edge(i, end, b[i], 0);
			add_edge(end, i, 0, 0);
		}
		for (register int j = 1; j <= n; j++){
			if (a[i] % a[j] == 0 && omega[i] == omega[j] + 1){
				ll cost = (ll)c[i] * c[j];
				if (omega[i] % 2 == 0){
					add_edge(i, j, 0x7fffffff, cost);
					add_edge(j, i, 0, -cost);
				} else {
					add_edge(j, i, 0x7fffffff, cost);
					add_edge(i, j, 0, -cost);
				}
			}
		}
	}
	cout << maxcost_maxflow(end, 0, end).first;
	return 0;
}
```

---

## 作者：hzoi_liuchang (赞：0)

## 分析
设 $cnt[i]$ 为 $a[i]$ 分解质因数后质因数所有幂次的和。

如果 $a[i]$ 和 $a[j]$ 会产生冲突，那么 $cnt[i]$ 和 $cnt[j]$ 的奇偶性一定是相反的。

所以我们只要把 $cnt$ 为奇数的染成白色，把所有 $cnt$ 为偶数的染成黑色。

这样问题就转化为了二分图的模型。

然后由源点向所有白点连流量为 $b[i]$，费用为 $0$ 的边。

由白点向所有会与它产生冲突的黑点连流量为无穷大，费用为对应价值的边。

黑点同理。

因为题目中还有价值总和不小于 $0$ 的限制。

所以不能直接跑最大费用最大流。

要在费用变为 $0$ 的时候停止增广。

因为在增广的过程中费用一定是逐渐变小的。
## 代码
``` cpp
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<vector>
#include<queue>
#include<cstring>
#define rg register
inline int read(){
	rg int x=0,fh=1;
	rg char ch=getchar();
	while(ch<'0' || ch>'9'){
		if(ch=='-') fh=-1;
		ch=getchar();
	}
	while(ch>='0' && ch<='9'){
		x=(x<<1)+(x<<3)+(ch^48);
		ch=getchar();
	}
	return x*fh;
}
const int maxn=5e4+5;
int h[maxn],tot=2,n,m,s,t,ans;
struct asd{
	int to,nxt,val;
	long long cost;
}b[maxn<<1];
void ad(rg int aa,rg int bb,rg int cc,rg long long dd){
	b[tot].to=bb;
	b[tot].val=cc;
	b[tot].cost=dd;
	b[tot].nxt=h[aa];
	h[aa]=tot++;
}
long long dis[maxn],ans2;
int pre[maxn],incf[maxn],ans1;
bool inq[maxn];
std::queue<int> q;
bool spfa(){
	memset(dis,0xcf,sizeof(dis));
	memset(pre,0,sizeof(pre));
	memset(incf,0,sizeof(incf));
	inq[s]=1,dis[s]=0,incf[s]=0x3f3f3f3f;
	q.push(s);
	while(!q.empty()){
		rg int now=q.front();
		q.pop();
		inq[now]=0;
		for(rg int i=h[now];i!=-1;i=b[i].nxt){
			rg int u=b[i].to;
			if(b[i].val && dis[u]<dis[now]+b[i].cost){
				dis[u]=dis[now]+b[i].cost;
				incf[u]=std::min(incf[now],b[i].val);
				pre[u]=i;
				if(!inq[u]){
					inq[u]=1;
					q.push(u);
				}
			}
		}
	}
	return dis[t]!=dis[0];
}
void updat(){
	rg int now=t,i;
	ans2+=dis[now]*incf[now];
	if(ans2<0){
		ans1-=(ans2-dis[now]*incf[now])/dis[now];
		printf("%d\n",ans1);
		std::exit(0);
	}
	ans1+=incf[now];
	while(now!=s){
		i=pre[now];
		b[i].val-=incf[t];
		b[i^1].val+=incf[t];
		now=b[i^1].to;
	}
}
int jla[maxn],jlb[maxn],jlc[maxn],cnt[maxn];
int div(rg int now){
	rg int ncnt=0;
	for(rg int i=2;i*i<=now;i++){
		if(now%i==0){
			while(now%i==0){
				now/=i;
				ncnt++;
			}
		}
	}
	if(now>1) ncnt++;
	return ncnt;
}
int main(){
	memset(h,-1,sizeof(h));
	n=read();
	s=n+1,t=n+2;
	for(rg int i=1;i<=n;i++) jla[i]=read();
	for(rg int i=1;i<=n;i++) jlb[i]=read();
	for(rg int i=1;i<=n;i++) jlc[i]=read();
	for(rg int i=1;i<=n;i++) cnt[i]=div(jla[i]);
	for(rg int i=1;i<=n;i++){
		if(cnt[i]&1){
			ad(s,i,jlb[i],0);
			ad(i,s,0,0);
		} else {
			ad(i,t,jlb[i],0);
			ad(t,i,0,0);
		}
	}
	for(rg int i=1;i<=n;i++){
		if(cnt[i]&1){
			for(rg int j=1;j<=n;j++){
				if(cnt[j]&1) continue;
				if((cnt[i]==cnt[j]+1 && jla[i]%jla[j]==0) || (cnt[j]==cnt[i]+1 && jla[j]%jla[i]==0)){
					ad(i,j,0x3f3f3f3f,1LL*jlc[i]*jlc[j]);
					ad(j,i,0,-1LL*jlc[i]*jlc[j]);
				}
			}
		}
	}
	while(spfa()) updat();
	printf("%d\n",ans1);
	return 0;
}
```

---

## 作者：不存在之人 (赞：0)

如果a是b的倍数，且a/b是质数：

1. a能分解为奇数个质数相乘，那么a到b+n连一条容量为inf，费用为c[a]*c[b]的边

2. a能分解为偶数个质数相乘，那么b到a+n连一条容量为inf，费用为c[a]*c[b]的边

如果a能分解为奇数个质数相乘，那么源点到a连一条容量为sum[a]，费用为0的边

如果a能分解为偶数个质数相乘，那么a到汇点连一条容量为sum[a]，费用为0的边

### 这个网络去掉源点汇点及其边后就是一张二分图

之后求出在费用不低于0的情况下的最大流就是答案

改下SPFA
```cpp
#include<cstdio>
#include<cstring>
#include<queue>
#define LL long long
using namespace std;
typedef struct
{
	int x;
	int y,z;
	int tp;
}Res;
Res s[205];
typedef struct
{
	int flow;
	LL cost;
}Edge;
Edge road[505][505];
int dis,T,link[505],vis[505];
LL best[505];
int Spfa();
int Jud(int x)
{
	int i;
	if(x<=1)
		return 0;
	for(i=2;i*i<=x;i++)
	{
		if(x%i==0)
			return 0;
	}
	return 1;
}
int Sech(int x)
{
	int i,sum=0;
	for(i=2;i*i<=x;i++)
	{
		while(x%i==0)
		{
			sum++;
			x/=i;
		}
	}
	if(x!=1)
		sum++;
	return 2-(sum%2);
}
int main(void)
{
	LL ans,sum;
	int n,x,i,j,pre,flow;
	while(scanf("%d",&n)!=EOF)
	{
		for(i=1;i<=n;i++)
		{
			scanf("%d",&s[i].x);
			s[i].tp=Sech(s[i].x);
		}
		for(i=1;i<=n;i++)
			scanf("%d",&s[i].y);
		for(i=1;i<=n;i++)
			scanf("%d",&s[i].z);
		T=2*n+1;
		for(i=1;i<=n;i++)
		{
			if(s[i].tp==1)
				road[0][i].flow=s[i].y;
			else
				road[n+i][T].flow=s[i].y;
		}
		for(i=1;i<=n;i++)
		{
			for(j=1;j<=n;j++)
			{
				if(s[i].x%s[j].x==0&&Jud(s[i].x/s[j].x))
				{
					if(s[i].tp==1)
					{
						road[i][n+j].flow=2147483647;
						road[i][n+j].cost=(LL)s[i].z*s[j].z;
						road[n+j][i].cost=-(LL)s[i].z*s[j].z;
					}
					else
					{
						road[j][n+i].flow=2147483647;
						road[j][n+i].cost=(LL)s[i].z*s[j].z;
						road[n+i][j].cost=-(LL)s[i].z*s[j].z;
					}
				}
			}
		}
		ans=flow=0;
		while(Spfa())
		{
			x=T;
			dis=100000000;
			while(x!=0)
			{
				pre=link[x];
				dis=min(dis,road[pre][x].flow);
				x=pre;
			}
			x=T;
			sum=0;
			while(x!=0)
			{
				pre=link[x];
				road[pre][x].flow-=dis;
				road[x][pre].flow+=dis;
				sum+=road[pre][x].cost;
				x=pre;
			}
			if(ans+sum*dis<0)
			{
				flow+=-ans/sum;
				break;
			}
			ans+=sum*dis;
			flow+=dis;
		}
		printf("%d\n",flow);
	}
	return 0;
}
int Spfa()
{
	int i,now;
	memset(link,-1,sizeof(link));
	memset(vis,0,sizeof(vis));
	memset(best,-62,sizeof(best));
	best[0]=0;
	queue<int>q;
	q.push(0);
	while(q.empty()==0)
	{
		now=q.front();
		q.pop();
		for(i=1;i<=T;i++)
		{
			if(road[now][i].flow>0&&best[i]<best[now]+road[now][i].cost)
			{
				best[i]=best[now]+road[now][i].cost;
				link[i]=now;
				if(vis[i]==0)
				{
					vis[i]=1;
					q.push(i);
				}
			}
		}
		vis[now]=0;
	}
	if(best[T]>=-1e17)
		return 1;
	return 0;
}
```


---

## 作者：Ebola (赞：0)

### 广告： [我的博客](http://ebola.blogwo.com/)

可以说是非常水的一道题了

看到这种匹配，就得想一下二分图、网络流这一块东西

我们首先对所有的a[i]进行质因数分解，用cnt[i]记录a[i]的质因数个数

这样，两个数能匹配当且仅当a[i] mod a[j]=0 并且 cnt[i]-cnt[j]=1 (a[i]>a[j])

这样我们可以构造二分图，左边是cnt值为奇数的，右边是cnt值为偶数的，于是匹配就只会发生在两个集合之间，而不会发生在某个集合内

二分图匹配是行不通的，因为匹配有权，因此我们考虑费用流
建立源、汇点，源点向二分图的左边连边，二分图的右边向汇点连边，容量均为b[i]，费用均为0

对于匹配关系，我们将能匹配的两个点连边，从左边的点连向右边，容量INF，费用为匹配的权

我们要跑的是一个**最大费用最大流**

我们知道，费用流的增广过程是单调的，也就是说权值大的增广路会优先找出来，因此当某次增广时发现当前费用加上增广路的权<0了，根据题意，就需要结束增广过程

时间复杂度**O(能过)**

细节参考代码

```cpp
#include<bits/stdc++.h>
#define INF 0x7fffffff
#define LINF (1ll<<62)
using namespace std;

typedef long long LL;
struct Edge{int from,to,capa,flow,next;LL cost;} e[2000000];
int h[1000],sum=-1,s,t;
int a[210],b[210];
LL c[210],n;
int cnt[210];
bool vis[1000];
LL dist[1000];
int able[1000],p[1000];

void AddEdge(int u,int v,int w,LL c)
{
	sum++;
	e[sum].from=u;
	e[sum].to=v;
	e[sum].capa=w;
	e[sum].cost=c;
	e[sum].flow=0;
	e[sum].next=h[u];
	h[u]=sum;
}

void add_edge(int u,int v,int w,LL c)
{
	AddEdge(u,v,w,c);
	AddEdge(v,u,0,-c);
}

bool BellmanFord(int &flow,LL &cost)
{
	memset(vis,0,sizeof(vis));
	vis[s]=1;
	queue<int> q;
	q.push(s);
	for(int i=s;i<=t;i++) dist[i]=-LINF;
	dist[s]=0;
	able[s]=INF;
	while(!q.empty())
	{
		int o=q.front();
		for(int tmp=h[o];tmp!=-1;tmp=e[tmp].next)
			if(e[tmp].capa>e[tmp].flow&&dist[o]+e[tmp].cost>dist[e[tmp].to])
			{
				dist[e[tmp].to]=dist[o]+e[tmp].cost;
				able[e[tmp].to]=min(able[o],e[tmp].capa-e[tmp].flow);
				p[e[tmp].to]=tmp;
				if(!vis[e[tmp].to]) q.push(e[tmp].to),vis[e[tmp].to]=1;
			}
		q.pop();
		vis[o]=0;
	}
	if(dist[t]==-LINF) return 0;
	LL delta=(LL)able[t]*dist[t];
	if(cost+delta<0){flow+=cost/(-dist[t]);return 0;}
	cost+=delta;
	flow+=able[t];
	for(int u=t;u!=s;u=e[p[u]].from)
	{
		e[p[u]].flow+=able[t];
		e[p[u]^1].flow-=able[t];
	}
	return 1;
}

int MCMF()
{
	int flow=0;
	LL cost=0;
	while(BellmanFord(flow,cost));
	return flow;
}

int decompose(int n)
{
	int s=sqrt(n),tot=0;
	for(int i=2;i<=s;i++)
		while(n%i==0) n/=i,tot++;
	if(n>1) tot++;
	return tot;
}

int main()
{
	cin>>n;
	for(int i=1;i<=n;i++) scanf("%d",a+i);
	for(int i=1;i<=n;i++) scanf("%d",b+i);
	for(int i=1;i<=n;i++) scanf("%lld",c+i);
	for(int i=1;i<=n;i++) cnt[i]=decompose(a[i]);
	s=0;t=n+1;
	for(int i=s;i<=t;i++) h[i]=-1;
	for(int i=1;i<=n;i++)
		if(cnt[i]&1) add_edge(s,i,b[i],0);
		else add_edge(i,t,b[i],0);
	for(int i=1;i<=n;i++)
		if(cnt[i]&1)
			for(int j=1;j<=n;j++)
				if((a[i]%a[j]==0&&cnt[i]==cnt[j]+1)||(a[j]%a[i]==0&&cnt[j]==cnt[i]+1))
					add_edge(i,j,INF,c[i]*c[j]);
	cout<<MCMF()<<endl;
	return 0;
}

```

---


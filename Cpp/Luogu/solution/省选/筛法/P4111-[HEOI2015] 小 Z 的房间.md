# [HEOI2015] 小 Z 的房间

## 题目描述

你突然有了一个大房子，房子里面有一些房间。事实上，你的房子可以看做是一个包含 $n\times m$ 个格子的格状矩形，每个格子是一个房间或者是一个柱子。在一开始的时候，相邻的格子之间都有墙隔着。

你想要打通一些相邻房间的墙，使得所有房间能够互相到达。在此过程中，你不能把房子给打穿，或者打通柱子（以及柱子旁边的墙）。同时，你不希望在房子中有小偷的时候会很难抓，所以你希望任意两个房间之间都只有一条通路。现在，你希望统计一共有多少种可行的方案，答案对 $10^9$ 取模。


## 说明/提示

#### 数据规模与约定

- 对于 $20\%$ 的数据，$n,m \le 3$。
- 对于 $50\%$ 的数据，$n,m \le 5$。
- 有 $40\%$ 的数据，$\min(n,m) \le 3$。
- 有 $30\%$ 的数据，不存在柱子。
- 对于 $100\%$ 的数据，$1 \le n,m \le 9$。


## 样例 #1

### 输入

```
2 2
..
..
```

### 输出

```
4
```

## 样例 #2

### 输入

```
2 2
*.
.*
```

### 输出

```
0
```

# 题解

## 作者：zhy137036 (赞：24)

作为 OI-Wiki 上[矩阵树定理](https://oi-wiki.org/graph/matrix-tree)的例题，这道题似乎没有详细讲矩阵树定理的题解，~~而且 OI-Wiki 讲得十分晦涩。~~

首先这道题容易转化为：已知无向图，求它的生成树数量。这正是矩阵树定理的作用。

## 矩阵树定理

### 拉普拉斯矩阵

设无向图有 $n$ 个节点。拉普拉斯矩阵 $L$ 是一个 $n\times n$ 的矩阵。定义如下：

- $L_{i,i}$ 的值为节点 $i$ 的度数，即有多少条边和节点 $i$ 相连。
- $L_{i,j}\ (i\neq j)$ 的值为节点 $i$ 和节点 $j$ 之间相连的边数的相反数。

例如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/wnx2s596.png)

我们发现有两条边和节点 $1$ 相连，有三条边和节点 $2$ 相连，有三条边和节点 $3$ 相连，有两条边和节点 $4$ 相连，所以这个图各个节点的度数 $\deg=\{2,3,3,2\}$。

暂时写成如下矩阵：

$$\begin{bmatrix}2&0&0&0\\0&3&0&0\\0&0&3&0\\0&0&0&2\end{bmatrix}$$

然后对于每条边 $(i,j)$，我们令 $L_{i,j}=L_{j,i}=-1$，得到最终的拉普拉斯矩阵：

$$L=\begin{bmatrix}2&-1&-1&0\\-1&3&-1&-1\\-1&-1&3&-1\\0&-1&-1&2\end{bmatrix}$$

### 定理叙述

将拉普拉斯矩阵去掉任意的一行和一列，得到的矩阵求行列式，即是原图的生成树数量。

例如将刚才的矩阵去掉最后一行和最后一列，得到：

$$\begin{bmatrix}2&-1&-1\\-1&3&-1\\-1&-1&3\end{bmatrix}$$

计算这个矩阵的行列式。如果不会算，可以用[在线计算器](https://matrix.reshish.com/zh/determinant.php)。

该矩阵的行列式为 $8$，意思是说原图有 $8$ 个生成树。验证一下，发现原图确实有 $8$ 个生成树，如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/8ytgvgor.png)

~~证明就算了，不会证。~~

## 行列式

如何求一个矩阵的行列式呢？我们需要知道行列式的一些性质：

- 将矩阵的两行交换，其行列式变成相反数。
- 将矩阵的一行加上(另一行乘一个数)，其行列式不变。
- 三角矩阵的行列式为对角线的乘积。

后两条不是很理解没关系，我们来求一下刚才那个矩阵的行列式。

将第一行乘 $\dfrac12$，加到第二行和第三行上去：

$$\begin{vmatrix}2&-1&-1\\-1+2\times\dfrac12&3+(-1)\times\dfrac12&-1+(-1)\times\dfrac12\\-1+2\times\dfrac12&-1+(-1)\times\dfrac12&3+(-1)\times\dfrac12\end{vmatrix}=\begin{vmatrix}2&-1&-1\\0&\dfrac52&-\dfrac32\\0&-\dfrac32&\dfrac52\end{vmatrix}$$

再将第二行乘 $\dfrac35$，加到第三行上去：

$$=\begin{vmatrix}2&-1&-1\\0&\dfrac52&-\dfrac32\\0+0\times\dfrac35&-\dfrac32+\dfrac{5}2\times\dfrac35&\dfrac52+(-\dfrac32)\times\dfrac35\end{vmatrix}=\begin{vmatrix}2&-1&-1\\0&\dfrac52&-\dfrac32\\0&0&\dfrac85\end{vmatrix}$$

我们看最后得到的矩阵，它只有右上的一个三角形内有数，所以我们称它为“三角矩阵”。将它的对角线乘起来：$2\times\dfrac52\times\dfrac85=8$，就是原矩阵的行列式。

我们发现，这其实就是高斯消元法（不知道高斯消元法也没关系）。但是其中用到了分数，如果模数是质数可以用乘法逆元，否则因为分数在计算机上会有浮点误差，所以我们需要结合没有浮点误差的辗转相除法使用。

我们以较简单的二阶行列式为例：

$$\begin{vmatrix}7&2\\3&5\end{vmatrix}$$

用第二行去消第一行，也就是将第一行不断地减第二行，直到不能继续减，得到：

$$=\begin{vmatrix}1&-8\\3&5\end{vmatrix}$$

然后交换两行，继续消：

$$=-\begin{vmatrix}3&5\\1&-8\end{vmatrix}$$

$$=-\begin{vmatrix}0&29\\1&-8\end{vmatrix}$$

$$=\begin{vmatrix}1&-8\\0&29\end{vmatrix}$$

（注意前面的符号）

于是我们就将这个矩阵变成了三角矩阵。

如果是更多阶行列式，就需要用高斯消元法来逐个消去左下的数，使之成为三角矩阵。

## 推广

如果原图是有边权的，那又会怎样呢？

这时定义一个节点的度数为 和它相连的边 的边权和，$L_{i,j}\ (i\neq j)$ 的值为边 $(i,j)$ 的边权的相反数。

这时求出的值为所有生成树的(包含的所有边的乘积)的和，即：

$$\sum_{T\text{ 为原图的生成树}}\quad\prod_{e\text{ 为 }T\text{ 中的边}}w_e$$

## 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
char ch[20][20];//读入的地图
const int mod=1000000000;
int n,m,cnt,ans=1,id[20][20],A[100][100];
//A 是拉普拉斯矩阵，id 是地图中的格子的编号
void add(int x,int y) { A[x][y]--; A[y][x]--; A[x][x]++; A[y][y]++; }
//对于一个边，修改拉普拉斯矩阵
signed main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++) for(int j=1;j<=m;j++) cin>>ch[i][j];
	for(int i=1;i<=n;i++) for(int j=1;j<=m;j++) if(ch[i][j]=='.') id[i][j]=++cnt;
    //将地图中的格子进行编号
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++){
			if(ch[i][j]=='.'&&ch[i+1][j]=='.') add(id[i][j],id[i+1][j]);
			if(ch[i][j]=='.'&&ch[i][j+1]=='.') add(id[i][j],id[i][j+1]);
            //只加向下的边和向右的边，防止重复
		}
	cnt--;//去掉拉普拉斯矩阵的最后一行一列
	for(int i=1;i<cnt;i++){
		for(int j=i+1;j<=cnt;j++){
			while(A[j][i]){
				int l=A[i][i]/A[j][i];
                //这里不能直接取模，要先计算商
				for(int k=1;k<=cnt;k++)
					A[i][k]=(A[i][k]-A[j][k]*l%mod+mod)%mod;
				for(int k=1;k<=cnt;k++) swap(A[i][k],A[j][k]);
				ans*=-1;
                //每次交换两行，将答案取相反数
			}
		}
	}
	for(int i=1;i<=cnt;i++) ans=(ans*A[i][i]%mod+mod)%mod;
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：LawrenceSivan (赞：15)

# 矩阵-树定理

**（_Kirchhoff's_ _matrix_ _tree_ _theorem_）**

## 前言：

首先这个玩意集训的时候就已经讲过了。

但是当时并没有认真听。

现在回头看这玩意……

## 前置知识：


$1$：[拉普拉斯](https://baike.baidu.com/item/%E6%8B%89%E6%99%AE%E6%8B%89%E6%96%AF%E7%9F%A9%E9%98%B5/5583042?fr=aladdin)[矩阵](https://blog.csdn.net/qq_30159015/article/details/83271065) **极其重要**

$2$：[行列式](https://blog.csdn.net/zhoufenqin/article/details/7779707) **极其重要**

$3$：[高斯消元](https://lawrencesivan.github.io/2021/02/18/p2455%20%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84%EF%BC%88%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83%EF%BC%89/) **极其重要**

$4$：[矩阵树定理](https://baike.baidu.com/item/%E7%9F%A9%E9%98%B5-%E6%A0%91%E5%AE%9A%E7%90%86/18894498?fr=aladdin)  ~~这个了解一下这个名字就行了，要不然你直接看会了还看我的博客干屁~~ ~~**不重要**~~

$5$：[柯西–比内公式](https://baike.baidu.com/item/%E6%9F%AF%E8%A5%BF-%E6%AF%94%E5%86%85%E5%85%AC%E5%BC%8F/18882044?fr=aladdin)  ~~这个其实不用掌握~~

$6$：一些奇怪的人名：

[基尔霍夫](https://baike.baidu.com/item/%E5%8F%A4%E6%96%AF%E5%A1%94%E5%A4%AB%C2%B7%E7%BD%97%E4%BC%AF%E7%89%B9%C2%B7%E5%9F%BA%E5%B0%94%E9%9C%8D%E5%A4%AB/2371618?fromtitle=%E5%9F%BA%E5%B0%94%E9%9C%8D%E5%A4%AB&fromid=639565&fr=aladdin)

[拉普拉斯](https://baike.baidu.com/item/%E6%8B%89%E6%99%AE%E6%8B%89%E6%96%AF/5189?fromtitle=Laplace&fromid=5028043&fr=aladdin)

## 矩阵-树定理内容：

**官方定义**：矩阵-树定理是一个计数定理.若连通图 $G$ 的邻接矩阵为 $A$ ，将 $A$ 的对角线 $(i,i)$ 元素依次换为节点 $i$ 的度 $d(i)$，其余元素 $(i,j) (j!=i)$ 取 $A(i,j)$ 的相反数，所得矩阵记为 $M$ ，则 $M$ 的每个代数余子式相等，且等于 $G$ 的生成树的数目.这就是矩阵一树定理.我们常常称矩阵 $M$ 为基尔霍夫矩阵。

其实这玩意还有一些其他的说法：

比如比较阳间的**说法一**：将拉普拉斯矩阵去掉任意的一行和一列，得到的矩阵求行列式，即是原图的生成树数量。（拉普拉斯矩阵下面会说到）

还有更通俗易懂的**说法二**：（度数矩阵（对角线矩阵）-邻接矩阵）的行列式等于该图生成树个数（行列式下面也会说到）。

还有一些奇奇怪怪的**说法三**：对于一个无向图 $G$ ，它的生成树个数等于其基尔霍夫 _Kirchhoff_ 矩阵任何一个 $N−1$ 阶主子式的行列式的绝对值。

~~其实他们说的是一回事，完全一样。~~

随便记一个就行了。

## 拉普拉斯矩阵 （_Laplacian_ _Matrix_）

其实，它还有一个别的名字：基尔霍夫矩阵（基尔霍夫就是矩阵-树定理的提出者）。

设**无向图** $G$（允许重边，可以扩展到加权，但是不能有自环） 有 $n$ 个节点。拉普拉斯矩阵 $L:=(l_{i,j})_{n\times n}$ 定义如下：

- 若 $i==j$ 则 $l_{i,j}=\deg(v_i)$ , $\deg(v_i)$ 为定点 $v_i$ 的度。（如果是有向图，那么我们只考虑出度或者入度中的一个）.

- 若 $i\neq j $ ，但是顶点 $v_i$ 和 $v_j$ 之间有边相连，那么 $l_{i,j}=-1$.

- 其他情况 $l_{i,j}=0$.

根据说法一，我们去掉拉普拉斯矩阵的最后一列和最后一行，然后求行列式就得到了问题的解。

说白了，我们首先求出度数矩阵 $D$（也就是对角线矩阵，具体意义是这个点有多少个另外的点与他相连，那么对应位置就是几）。

然后求出邻接矩阵 $A$（就是表明点与点的连接关系的那个，具体可以参考一些矩阵快速幂的题或者联想一下 _floyd_）。

之后求出拉普拉斯矩阵（基尔霍夫矩阵） $W=D-A$.

然后将 $W$ 去掉任意一行和一列得到 $K'$ （一般为了方便我们直接去除最后一行和最后一列）。

那么生成树的个数就等于 $\det(K')$ （就是 $K'$ 的行列式）。

下面还会提到有向图的拉普拉斯矩阵以及如何推广到到带权。

## 行列式

一个矩阵对应一个行列式（就是一个数字）。

计算行列式就是需要矩阵化成上三角或下三角，然后观察对角线的元素，如果其中有个一元素为 $0$ 则整体为 $0$，否则**行列式的值就是对角线上各个元素的乘积**。

首先需要知道一些性质：

- 一个行列式和它的转置行列式相等.

- **互换行列式的两行或者两列，行列式的值变号**.

- 如果行列式中有两行或者两列完全相同，那么行列式为零.

- 行列式中某一行或者一列中所有元素同乘同一个数 $k$ ，等于用 $k$ 乘以行列式.

- 行列式中如果有两行或者或者两列元素对应成比例，那么行列式为零.

- **把行列式的某一行或者某一列的各个元素乘以同一个数以后加到另外一行或者一列的对应元素上去，行列式的值不变**.

以上加黑部分提示我们应该使用高斯消元来转化成三角，然后求得行列式。

**需要注意的是一定是三角而不是对角线矩阵**。

~~于是特别喜欢 高斯-约旦 消元的同学还是要学一学经典高斯的。~~

在把矩阵化成三角时需要注意，在题目中模数可能为任意，这样在剩余系就不一定存在逆元，所以需要使用辗转相除法。

或者如果这道题的模数是质数的话也可以使用乘法逆元。

消元结束以后直接算出行列式的值就好了。

```cpp
int ans=1;
for(re int i=1;i<=tmp;i++){
    for(re int j=i+1;j<=tmp;j++){
        while(a[j][i]){
            int t=a[i][i]/a[j][i];
            for(re int k=i;k<=tmp;k++)a[i][k]=(a[i][k]-a[j][k]*t%mod+mod)%mod;
            swap(a[i],a[j]);
            ans*=-1;
        }
    }
    ans=(ans*a[i][i]%mod+mod)%mod;
}
return (ans%mod+mod)%mod;

```

这里同时给出对于模数是质数时，求解行列式的方法：

```cpp
inline int det(){
    int ans=1;
	for(re int i=1;i<=tmp;i++){
	    for(re int j=i;j<=tmp;j++){
	        if(a[j][i]){
	            swap(a[i],a[j]);
	            if(i!=j)ans=mod-ans;
	            break;
	        }
		}
	            
	    int t=qpow(a[i][i],mod-2);
	        
	    for(re int j=i+1;j<=tmp;j++){
	        if(a[j][i]){
	        	for(re int k=tmp;k>=i;k--){
	        		a[j][k]=(a[j][k]-a[i][k]*t%mod*a[j][i]%mod+mod)%mod;
				}
			}
	    }
	}
	     
	for(re int i=1;i<=tmp;i++)ans=ans*a[i][i]%mod;	
		
	return ans;
}

```

需要处理一下负数情况，否则会出问题：

```cpp
inline void check(){
 	for(re int i=1;i<=n;i++){
   		for(re int j=1;j<=n;j++){
   			if(a[i][j]<0) a[i][j]+=mod;
		}
	}
}

```

对于本题，并不是所有的点都可以用来求行列式，只有不是墙的点才能放进矩阵。

否则根据上面的性质：**如果其中有个一元素为 $0$ 则整体为 $0$** 。

就会直接 _WA_ 了。

对于加边，只加向下或者向右的边，可以保证不重复。

```cpp
for(re int i=1;i<=n;i++){
		for(re int j=1;j<=m;j++){
			cin>>a[i][j];
			if(a[i][j]=='.')id[i][j]=++cnt;//用cnt来重新编号
		}
	}

```

## 本题相关：

$1$：这个题需要注意，一定要开 _long_ _long_.

我们可以观察一下这个题的样例一：

构建出来拉普拉斯矩阵之后并且去掉最后一行和最后一列，矩阵是这样的：

$\begin{bmatrix} -1&0&2\\0&1&1\\0&0&999999996\end{bmatrix}$

然后 ，不开 _long_ _long_ 就没有然后了。

$2$：构建完拉普拉斯矩阵以后千万不要忘记减掉最后一行和最后一列（不要上头。

$3$：上三角，上三角，上三角！（针对某些高斯-约旦党。

$4$：取 $mod$ 的时候注意处理负数。

## 复杂度分析：

由于我们使用了辗转相除法来进行高斯消元，所以原来 $O(n^3)$ 的高斯消元被加了一个 $log$ ，时间复杂度 $O(n^3m^3log(nm))$

## CODE：

```cpp
//#define LawrenceSivan

#include<bits/stdc++.h>
using namespace std;

typedef long long ll;
#define re register
const int N=150;
const int mod=1e9;
#define INF 0x3f3f3f3f

#define int long long//记得long long

struct matrix {//这里是矩阵的板子
    int n,m;
    int tmp;
    int a[N][N];

    matrix(){}
    matrix(const int &_n,const int &_m):n(_n+1),m(_m+1){
        memset(a,0,sizeof(a));
    }

    inline void clear(){
        memset(a,0,sizeof(a));
        for(int i=0;i<=n;i++){
            a[i][i]=1;
        }
    }

    inline void id(){
        for(int i=0;i<=n;i++){
            a[i][i]=1;
        } 
    } 

    inline matrix operator + (const matrix &b)const{
        matrix res(n,b.m);
        for(int i=0;i<=n;i++){
            for(int j=0;j<=m;j++){
                res.a[i][j]=(a[i][j]+b.a[i][j])%mod;
            }
        }
        return res;
    } 

    inline matrix operator - (const matrix &b)const{
        matrix res(n,b.m);
        for(int i=0;i<=n;i++){
            for(int j=0;j<=m;j++){
                res.a[i][j]=(a[i][j]-b.a[i][j])%mod;
            }
        }
        return res;
    } 

    inline matrix operator * (int c)const{
        matrix res(n,m);
        for(int i=0;i<=n;i++){
            for(int j=0;j<=m;j++){
                res.a[i][j]=(c*a[i][j])%mod;
            }
        }
        return res;
    }

    inline matrix operator * (const matrix &b)const{
        matrix res(n,b.m);
        for(int i=0;i<=n;i++){
            for(int j=0;j<=b.m;j++){
                for(int k=0;k<=m;k++){
                    res.a[i][j]=(res.a[i][j]+a[i][k]*b.a[k][j])%mod;        
                }
            }
        } 
        return res;
    }

    inline matrix operator ^ (int p)const{
        matrix res(n,m),x = *this; 
        res.clear();
        for(;p;p>>=1,x=x*x){
            if(p&1)res=res*x;
        }
        return res;
    }

    inline matrix trans(){
        matrix res(m,n);
        for(int i=0;i<=n;i++){
            for(int j=0;j<=m;j++){
                res.a[i][j]=a[j][i];
            }
        }
        return res;
    }
    
    inline int det(){//高斯消元与求行列式
        int ans=1;
        for(re int i=1;i<=tmp;i++){
            for(re int j=i+1;j<=tmp;j++){
                while(a[j][i]){//辗转相除
                    int t=a[i][i]/a[j][i];
                    for(re int k=i;k<=tmp;k++){
                        a[i][k]=(a[i][k]-a[j][k]*t%mod+mod)%mod;
                        
                    }
					swap(a[i],a[j]);
                    ans*=-1;//交换以后需要变号
                }
            }
            ans=(ans*a[i][i]%mod+mod)%mod;//勤处理负数
        }
        return (ans%mod+mod)%mod;
    }
}W,D,A;
//W 基尔霍夫矩阵（拉普拉斯矩阵）
//D 度数矩阵（对角线矩阵）
//A 邻接矩阵

int n,m;

char a[15][15];

int id[15][15],cnt;//id 用于重新编号

inline void add(int u,int v){
	A.a[u][v]=1;
	A.a[v][u]=1;
}

inline int read(){
    int x=0,f=1;char ch=getchar();
    while(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}
    while(isdigit(ch)){x=x*10+(ch^48);ch=getchar();}
    return x*f;
}

signed main(){
#ifdef LawrenceSivan
    freopen("aa.in","r",stdin);
    freopen("aa.out","w",stdout);
#endif
	n=read();m=read();
	for(re int i=1;i<=n;i++){
		for(re int j=1;j<=m;j++){
			cin>>a[i][j];
			if(a[i][j]=='.')id[i][j]=++cnt;
		}
	}
	
	W=matrix(cnt,cnt);//初始化矩阵
	D=matrix(cnt,cnt);
	A=matrix(cnt,cnt);
	
	for(re int i=1;i<=n;i++){//构造邻接矩阵
		for(re int j=1;j<=m;j++){
			if(id[i][j]&&id[i][j-1])add(id[i][j],id[i][j-1]); 
			if(id[i][j]&&id[i-1][j])add(id[i][j],id[i-1][j]);	
		}
	}
	
	for(re int i=1;i<=cnt;i++){//构造度数矩阵
		for(re int j=1;j<=cnt;j++){
			if(A.a[i][j]) D.a[i][i]++;
		}
	}
	
	W=D-A;//两者作差得到基尔霍夫矩阵（拉普拉斯矩阵）
	
	W.tmp=--cnt;//除掉最后一行与最后一列
	
	/*for(re int i=1;i<=cnt;i++){
		for(re int j=1;j<=cnt;j++){
			cout<<W.a[i][j]<<" ";
		}
		cout<<endl;
	}*/
	
	printf("%lld\n",W.det());//求行列式
	
	

	return 0;
}

```

## 关于拉普拉斯矩阵的有向图情况：

像我们上面所说的，只考虑入度或者出度就可以了。

但是考虑这两种是不一样的。

设**有向图** $G$（允许重边，可以扩展到加权，但是不能有自环） 有 $n$ 个节点。出度矩阵 $D=(l_{i,j})_{n\times n}$ 定义如下：

- 若 $i==j$ 则 $l_{i,j}=\deg^{out}(v_i)$ , $\deg^{out}(v_i)$ 为定点 $v_i$ 的出度。

- 若 $i\neq j $ ，则 $l_{i,j}=0$

类似地可以定义入度矩阵。

定义 $edge(i,j)$ 为点 $i$ 指向点 $j$ 的有向边数。

定义邻接矩阵 $A=(l_{i,j})_{n\times n}$ 

- 若 $i\neq j$ , $l_{i,j}=edge(i,j)$

于是 就可以定义 $Laplace$ 矩阵 $L^{out}$ 和 $L^{in}$ 。

- 当为 $L^{in}$ 时，统计的是外向树。（所有边指向叶节点）

- 当为 $L^{out}$ 时，统计的是内向树。（所有边指向根节点）

**内向是出度，外向是入度**（一定要记牢，不要混淆）

如果指定了根节点为$root$ 那么要在计算行列式的时候要去掉的就不是任意一行和一列了，**而是第 $root$ 行和第 $root$ 列**。

```cpp
inline void add(int t,int u,int v,int w){
    if(t==0){//内向树，出度矩阵
    	(D.a[u][u]+=w)%=mod;
		(A.a[u][v]+=w)%=mod;
	}
	
	else{//外向树，入度矩阵
		(D.a[v][v]+=w)%=mod;
		(A.a[u][v]+=w)%=mod;
	}
}

```

因此如果要统计一张图所有的内向树形图，只要枚举所有的根 $root$ 并对所有的行列式求和即可。

如果要统计一张图所有的外向树形图，只要枚举所有的根 $root$ 并对所有的行列式求和即可。

## 关于拉普拉斯矩阵扩展到带权

- 求生成树边权积之和

将上述中的 $D$ , $A$ 改为记录相应边边权和，则行列式从生成树个数变为对应的生成树所有边权之积的和。

于是可以发现，只要把边权全都看成 $1$ ，就是上面这道题我们解决的情况：求生成树个数。

---

## 作者：Siyuan (赞：15)

[$$\Large\texttt{My Blog}$$](https://hydingsy.github.io/articles/problem-HEOI-2015-Little-Z-Room/)

---

## Description

> 题目链接：[Luogu 4111](https://www.luogu.org/problemnew/show/P4111)

你突然有了一个大房子，房子里面有一些房间。事实上，你的房子可以看做是一个包含 $n\times m$ 个格子的格状矩形，每个格子是一个房间或者是一个柱子。在一开始的时候，相邻的格子之间都有墙隔着。

你想要打通一些相邻房间的墙，使得所有房间能够互相到达。在此过程中，你不能把房子给打穿，或者打通柱子（以及柱子旁边的墙）。同时，你不希望在房子中有小偷的时候会很难抓，所以你希望任意两个房间之间都只有一条通路。现在，你希望统计一共有多少种可行的方案。答案对 $10^9$ 取模。

数据范围：$1\le n,m\le 9$

------

## Solution

矩阵树定理裸题，注意不能把柱子的点放入矩阵中。加边时，我们只枚举 $(i,j)$ 上方和左方的点，这样可以保证每条边只被枚举到一次。

**时间复杂度**：$O(n^3m^3)$

------

## Code

```cpp
#include <cstdio>
#include <algorithm>

const int N=15,M=105;
const int mod=1e9;
char s[N][N];
int n,m,a[M][M],id[N][N];

void add(int u,int v) {
	--a[u][v],--a[v][u],++a[u][u],++a[v][v];
}
int Gauss(int n) {
	int ans=1;
	for(int i=1;i<=n;++i) {
		for(int k=i+1;k<=n;++k) {
			while(a[k][i]) {
				int d=a[i][i]/a[k][i];
				for(int j=i;j<=n;++j) a[i][j]=(a[i][j]-1LL*d*a[k][j]%mod+mod)%mod;
				std::swap(a[i],a[k]),ans=-ans;
			}
		}
		ans=1LL*ans*a[i][i]%mod,ans=(ans+mod)%mod;
	}
	return ans;
}
int main() {
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;++i) scanf("%s",s[i]+1);
	int idx=0;
	for(int i=1;i<=n;++i) for(int j=1;j<=m;++j) if(s[i][j]=='.') id[i][j]=++idx;
	for(int i=1;i<=n;++i) for(int j=1;j<=m;++j) if(s[i][j]=='.') {
		if(id[i-1][j]) add(id[i][j],id[i-1][j]);
		if(id[i][j-1]) add(id[i][j],id[i][j-1]);
	}
	printf("%d\n",Gauss(idx-1));
	return 0;
}
```



---

## 作者：i207M (赞：9)

# 行列式

何为行列式？ 一个矩阵对应一个行列式（数字）；

行列式有什么用？  目前看来，只有矩阵树定理用上了它；

## 行列式怎么求？ 

[好博客](https://blog.csdn.net/zhoufenqin/article/details/7779707)

简单来说，转置矩阵，行列式不变；

**交换两行/列位置，行列式取相反数；**

对一行/列乘以某数，行列式也乘以某数；

**用一行的倍数减去另一行，行列式的值不变；**

**一个上三角行列式的值等于对角线的乘积**

所以我们可以联想一下高斯消元的做法，把它削成上三角矩阵（注意，不是对角线矩阵），因为在剩余系下没有除法，所以我们要辗转相除；

```cpp
il int det() {
    int ans = 1;
    for (ri i = 1; i <= sz; ++i) {  // 当前在消第i个（i，i)
        for (ri j = i + 1, t; j <= sz; ++j) {  // 把它下面对应的位置消成0
            while (m[j][i]) { // 直到为0
                t = m[i][i] / m[j][i];  // 计算第j行相应的数是第i行的几倍
                for (ri k = i; k <= sz; ++k) {  // 一个一个消去并交换数字（消去后之前的位置变小）
                    mod(m[i][k] -= m[j][k] * t);
                    swap(m[i][k], m[j][k]); // 交换
                }
                ans *= -1; // 记得交换是，行列式取反
            }
        }
        if (m[i][i] == 0) return 0; // 如果有零，就不用继续做了
        else mod(ans *= m[i][i]); // 更新ans
    }
    return (ans % md + md) % md;
}
```

# 牢牢记住

## 矩阵树定理

（度数矩阵（对角线矩阵）-邻接矩阵）的行列式等于该图生成树个数；

------------


## 题目总结

矩阵树定理裸题

## 数据范围

能过

## 解题思路

如之前所说，直接做；

## 易错误区

1.！！！要建好图，有的地方不是节点

2.求行列式不要写错，是缩成上三角；

## 代码展示

```cpp
//%:pragma GCC optimize(2)
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cmath>
#include<cstring>
#include<string>
#include<algorithm>
#include<vector>
#include<map>
#include<set>
#include<list>
#include<queue>
#include<stack>
#include<bitset>
#include<deque>
using namespace std;
#define ll long long
#define inf 0x3f3f3f3f
#define ri register int
#define il inline
#define fi first
#define se second
#define mp make_pair
#define pi pair<int,int>
#define pb push_back
#define mem0(x) memset((x),0,sizeof (x))
#define mem1(x) memset((x),0x3f,sizeof (x))
il char gc() {
    static const int BS = 1 << 22;
    static unsigned char buf[BS], *st, *ed;
    if (st == ed) ed = buf + fread(st = buf, 1, BS, stdin);
    return st == ed ? EOF : *st++;
}
#define gc getchar
template<class T>void in(T &x)
{
    x = 0; bool f = 0; char c = gc();
    while (c < '0' || c > '9') {if (c == '-') f = 1; c = gc();}
    while ('0' <= c && c <= '9') {x = (x << 3) + (x << 1) + (c ^ 48); c = gc();}
    if (f) x = -x;
}
#undef gc
void out(int x) {
    if (x < 0) putchar('-'), x = -x;
    if (x > 9) out(x / 10);
    putchar(x % 10 + '0');
}
#define int ll
int n, m;
char tc[2];
bool h[12][12];
#define Maxsz 150
#define md 1000000000
il void mod(int &x) {
    x = (x % md + md) % md;
}
struct Mat {
    int sz;
    int m[Maxsz][Maxsz];
    il void clear() {mem0(m);}
    il Mat () {sz = 0; clear();}
    il int* operator[](int x) {
        return this->m[x];
    }
    il Mat operator*(const Mat &x)const {
        Mat res; res.sz = sz;
        for (ri i = 1; i <= sz; i++) {
            for (ri k = 1; k <= sz; k++) {
                for (ri j = 1; j <= sz; j++)
                    mod(res.m[i][j] += m[i][k] * x.m[k][j] % md);
            }
        }
        return res;
    }
    il void operator*=(const Mat &x) {
        *this = (*this) * x;
    }
    il void operator+=(const Mat &x) {
        for (ri i = 1; i <= sz; ++i) {
            for (ri j = 1; j <= sz; ++j) {
                mod(m[i][j] += x.m[i][j]);
            }
        }
    }
    il Mat operator+(const Mat &x)const {
        Mat res = *this;
        res += x;
        return res;
    }
    il void operator-=(const Mat &x) {
        for (ri i = 1; i <= sz; ++i) {
            for (ri j = 1; j <= sz; ++j) {
                m[i][j] -= x.m[i][j];//mod(m[i][j] -= x.m[i][j]);
            }
        }
    }
    il Mat operator-(const Mat &x)const {
        Mat res = *this;
        res -= x;
        return res;
    }
    il void print() {
        for (ri i = 1; i <= sz; i++) {
            for (ri j = 1; j <= sz; j++)
                printf("%lld ", m[i][j]);
            puts("");
        }
    }
    il void e() {
        clear();
        for (ri i = 1; i <= sz; i++)
            m[i][i] = 1;
    }
    il Mat qpow(int x) {
        Mat res, mul = *this;
        if (x == 0) {
            res.e();
            return res;
        }
        res = *this; --x;
        for (; x; x >>= 1, mul *= mul) if (x & 1) res *= mul;
        return res;
    }
    il int det() {
        int ans = 1;
        for (ri i = 1; i <= sz; ++i) {
            for (ri j = i + 1, t; j <= sz; ++j) {
                while (m[j][i]) {
                    t = m[i][i] / m[j][i];
                    for (ri k = i; k <= sz; ++k) {
                        mod(m[i][k] -= m[j][k] * t);
                        swap(m[i][k], m[j][k]);
                    }
                    ans *= -1;
                }
            }
            if (m[i][i] == 0) return 0;
            else mod(ans *= m[i][i]);
        }
        return (ans % md + md) % md;
    }
} d, g, s;
int cnt;
int xx[4] = {0, 1, 0, -1}, yy[4] = { -1, 0, 1, 0};
il bool check(int x, int y) {
    return (x >= 1) && (y >= 1) && (x <= n) && (y <= m) && (h[x][y] == 1);
}
signed main() {
    in(n), in(m);
    for (ri i = 1; i <= n; ++i) {
        for (ri j = 1; j <= m; ++j) {
            scanf("%1s", tc);
            h[i][j] = (tc[0] == '.');
        }
    }
    for (ri i = 1; i <= n; ++i) {
        for (ri j = 1; j <= m; ++j) {
            if (h[i][j]) {
                s[i][j] = ++cnt;
                if (check(i, j - 1)) {
                    g[s[i][j]][s[i][j - 1]] = 1;
                    g[s[i][j - 1]][s[i][j]] = 1;
                }
                if (check(i - 1, j)) {
                    g[s[i][j]][s[i - 1][j]] = 1;
                    g[s[i - 1][j]][s[i][j]] = 1;
                }
            }
        }
    }
    for (ri i = 1; i <= cnt; ++i) {
        for (ri j = 1; j <= cnt; ++j) {
            if (g[i][j])
                d[i][i]++;
        }
    }
    d.sz = g.sz = cnt;
    d -= g; --d.sz;
    printf("%lld", d.det());
    return 0;
}

```

---

## 作者：ez_lcw (赞：6)

题目明显是个矩阵树定理。我主要讲一下如何处理一些细节。

有两个麻烦的地方：

1. 题目中有一些地方不能走，那么在矩阵中就不能给它留位置，否则对角线上有地方会是 $0$。

	也就是说矩阵的边长不能是 $n\times m$，而是 $n\times m -\text{柱子数}$。
    
1. 模数不是质数，高斯消元中不能用逆元。

	这就要用到一种神奇的方法——辗转相除法。
    
   设现在我们枚举了矩阵中的两行 $i$、$j$：
   
   $$\begin{bmatrix}
   a_{i,i}&a_{i,i+1}&\cdots&a_{i,n}\\
   \\
   a_{j,i}&a_{j,i+1}&\cdots&a_{j,n}
   \end{bmatrix}$$
   
   根据高斯消元，我们现在要做的是把每一个 $a_{i,k}$（$i\leq k\leq n$）乘上 $\dfrac{a_{j,i}}{a_{i,i}}$，然后再把每一个 $a_{j,k}$（$i\leq k\leq n$）减去 $a_{i,k}$，然后就能消去 $a_{j,i}$。
   
   形式化地说，就是对于任意的 $i\leq k\leq n$，$a_{j,k}\gets \left(a_{j,k}-a_{i,k}\dfrac{a_{j,i}}{a_{i,i}}\right)$。
   
   平常的高斯消元可以用 double 直接算，但是要取模。而正常的模质数也可以用逆元处理 $\dfrac{1}{a_{i,i}}$。但是这一题模数不是质数，就不能用逆元，只能用辗转相除法：
   
   考虑到我们的目的就是消掉 $a_{j,i}$。整理一下条件：我们可以对矩阵进行两行交换，一行减去另一行的若干倍。
   
  	发现这也满足辗转相除的性质：
    
   我们可以把 $a_{i,k}$ 减去 $a_{j,k}\lfloor\dfrac{a_{i,i}}{a_{j,i}}\rfloor$（$i\leq k\leq n$），然后再交换第 $i$ 行和第 $j$ 行。对于 $a_{i,i}$ 和 $a_{j,i}$，发现这就和辗转相除中的操作 $(a_{i,i},a_{j,i})\rightarrow(a_{j,i},a_{i,i}\bmod a_{j,i})$ 一样。
   
   那么辗转相除到最后，肯定有 $a_{j,i}=0$，也满足了我们的目的。
   
   代码：
   
   ```cpp
  	for(int i=1;i<tot;i++)
	{
		for(int j=i+1;j<tot;j++)
		{
			//枚举出矩阵中的两行i、j
			while(a[j][i])//直到a[j][i]=0时，也就是达成目的时才停止
			{
				ll d=a[i][i]/a[j][i];
				for(int k=i;k<tot;k++)
					a[i][k]=(a[i][k]-d*a[j][k]%mod+mod)%mod;
				swap(a[i],a[j]);//交换两行
				ans=-ans;//交换矩阵的两行行列式要变号
			}
		}
	}
   ```
   
   至于为什么可以边模边辗转相除，也就是为什么 $(a_{i,i},a_{j,i})\rightarrow(a_{j,i},a_{i,i}\bmod a_{j,i})$ 等同于 $(a_{i,i},a_{j,i})\rightarrow\left(a_{j,i}\bmod p,\left(a_{i,i}-a_{j,i}\lfloor\dfrac{a_{i,i}}{a_{j,i}}\rfloor\right)\bmod p\right)$。
   
   首先有一开始 $a_{i,i}$ 和 $a_{j,i}$ 的绝对值均小于 $p$，而 $a_{i,i}\bmod a_{j,i}<a_{j,i}$。所以可以保证，在整个辗转相除的过程中，$a_{i,i}$ 和 $a_{j,i}$ 的绝对值均小于 $p$。
   
   此时 $a_{i,i}$ 和 $a_{j,i}$ 模完 $p$ 后还是它本身，可以看做整个辗转相除过程中，$a_{i,i}$ 和 $a_{j,i}$ 根本没有模过 $p$。那么边模边辗转相除是完全没有问题的。

然后所有的麻烦都被我们处理完了。

代码如下：

```cpp
#include<bits/stdc++.h>

#define N 110
#define ll long long
#define mod 1000000000

using namespace std;

int n,m,tot,id[N][N];
int fx[]={0,1},fy[]={1,0};
ll ans=1,a[N][N];

void work()//细节2，注释详见上面的代码
{
	for(int i=1;i<tot;i++)
	{
		for(int j=i+1;j<tot;j++)
		{
			while(a[j][i])
			{
				ll d=a[i][i]/a[j][i];
				for(int k=i;k<tot;k++)
					a[i][k]=(a[i][k]-d*a[j][k]%mod+mod)%mod;
				swap(a[i],a[j]);
				ans=-ans;
			}
		}
	}
}

int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
	{
		char s[15];
		scanf("%s",s+1);
		for(int j=1;j<=m;j++)
			if(s[j]=='.')
				id[i][j]=++tot;//细节1，只有这个点不是柱子才算进矩阵的编号
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			if(!id[i][j]) continue;
			int u=id[i][j];
			for(int k=0;k<2;k++)
			{
				int xx=i+fx[k],yy=j+fy[k];
				if(!id[xx][yy]) continue;
				int v=id[xx][yy];
				a[u][u]++,a[v][v]++;
				a[u][v]--,a[v][u]--;
			}
		}
	}
	work();
	for(int i=1;i<tot;i++)
		ans=ans*a[i][i]%mod;
	printf("%lld\n",(ans+mod)%mod);
	return 0;
}
```

---

## 作者：da32s1da (赞：6)

容易看出，本题就是一个**矩阵树定理**。

~~还是**裸**的~~

首先，建矩阵。

然后，删去最后一行最后一列，来一个高斯消元求行列式的值。

具体细节请看代码。

代码比较简洁，希望对大家有所帮助。
```
#include<cstdio>
#include<iostream>
#include<cmath>
using namespace std;
typedef long long LL;
const int N=100;
const LL mod=1e9;
int n,m,ed;
LL ans=1;
int h[N][N],vis[N];
LL f[N][N];
char s[N];
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++){
		scanf("%s",s);
		for(int j=0;j<m;j++)
		if(s[j]=='.')h[i][j+1]=1;  //记录下房间的位置 
		else vis[(i-1)*m+j+1]=1;   //重要！！为墙的行一定全为0！！ 
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++)
		if(h[i][j]){    //若为房间 
			ed=0;   //纪录度数矩阵 
			if(h[i][j-1])f[(i-1)*m+j][(i-1)*m+j-1]=-1,ed++;  //左 
			if(h[i][j+1])f[(i-1)*m+j][(i-1)*m+j+1]=-1,ed++;  //右 
			if(h[i-1][j])f[(i-1)*m+j][(i-2)*m+j]=-1,ed++;    //上 
			if(h[i+1][j])f[(i-1)*m+j][i*m+j]=-1,ed++;        //下 
			f[(i-1)*m+j][(i-1)*m+j]=ed;   //加上度数矩阵
		}
	}
	n=n*m-1;  //删去最后一行最后一列，并计算行列式的大小 
	for(int i=1;i<=n;i++)
	if(!vis[i]){    //注意！ 非墙的才继续 
		for(int j=i+1;j<=n;j++)
		if(!vis[j])  //同上 
		while(f[j][i]){   //辗转相除 
			LL r=f[i][i]/f[j][i];
			for(int k=1;k<=n;k++)
			f[i][k]=(f[i][k]-f[j][k]*r%mod+mod)%mod,swap(f[i][k],f[j][k]);
			ans=(mod-ans)%mod;   //交换两行，答案取负 
		}
		if(f[i][i]==0){puts("0");return 0;}  //若主对角线有0，则答案为0 
		ans=(ans*f[i][i]+mod)%mod;   //计算答案 
	}
	printf("%lld\n",ans);
}
```

---

## 作者：scallop (赞：2)

对于相邻的房间连一条无向边。

我们考虑选择一条边就表示打破一面墙。

那么题目要求两个房间**只有**一条道路，等价于我们最后选择的图是一颗树。

那么题目就是生成树计数。

用 _Matirx-Tree_ 定理即可。

注意模数不是质数，所以高斯消元时要注意。

时间复杂度 $O(n^3m^3log(nm))$ 空间复杂度 $O(n^2m^2)$

代码就不放了。

---

## 作者：封禁用户 (赞：1)

这题要求解生成树的个数，应该使用 [Matrix-Tree](https://blog.csdn.net/a_crazy_czy/article/details/72971868?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-1.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-1.pc_relevant_default&utm_relevant_index=1) 定理。

如果使用高斯消元解行列，那么会出现除法。所以我们应该使用欧几里得算法。

具体来分析高斯消元，高斯消元时进行初等变换，把某行乘一个数字 $x$ 在加到另一行，最终使目标行某个位置为 $0$。

我们可以设对应位置数值为 $a$， $b$ 使得 $b = 0$。则使 $b$ 所在行 $+a$ 所在行 $\times b \div a$ 使得 $a$， $b \bmod a$ 交换，直到 $a$， $b$ 中出现 $0$ 为止。

# AC代码

```cpp
#include<iostream>
#include<cmath>
#include<algorithm>
#include<cstdio>
using namespace std;
typedef long long LL;
const int MAXN = 1e6 + 10;
const int INF = 0x3f;
int n, m, S, mod = 1000000000;
int s[11][11], a[82][82];
char z[11][11];
int gs(){
	S--; 
	for(int i = 1;i <= S; i++){
		for(int j = 1;j <= S; j++){
			a[i][j] = (a[i][j] + mod) % mod;
		}
	} 
	long long ans = 1;
	for(int j = 1;j <= S; j++){
		for(int i = j + 1;i <= S; i++)
		while(a[i][j]){
			LL t = a[j][j] / a[i][j];
			for(int k = j;k <= S; k++)
				a[j][k] = (a[j][k] - t * a[i][k] % mod + mod) % mod,
				swap(a[i][k] ,a[j][k]);
			ans *= -1;
		}
		ans = ans * a[j][j] % mod;
	}
	return (ans + mod) % mod;
} 
int main()
{
	cin >> n >> m;
	for(int i = 1;i <= n; i++){
		scanf("%s", &z[i][1]);
	}
	for(int i = 0;i <= n + 1; i++){
		for(int j = 0;j <= m + 1; j++){
			if(i == 0 || j == 0 || i == n + 1 || j ==m + 1)
				z[i][j] = '*';
		}
	}
	for(int i = 1;i <= n; i++){
		for(int j = 1;j <= m; j++){
			if(z[i][j] == '.'){
				s[i][j] = ++S;
				if(z[i - 1][j] == '.')a[s[i-1][j]][s[i][j]] = 1;
				if(z[i - 1][j] == '.')a[s[i][j]][s[i-1][j]] = 1;
				if(z[i][j - 1] == '.')a[s[i][j-1]][s[i][j]] = 1;
				if(z[i][j - 1] == '.')a[s[i][j]][s[i][j-1]] = 1;
			}
		}
	}
	for(int i = 1;i <= S;i++){
		for(int j = 1;j <= S; j++){
			if(a[i][j] && i!= j)a[i][i] ++;
		}
	}
	cout << gs();
    return 0;
}

```


---

## 作者：y2823774827y (赞：1)

 ### 安利博客$\Longrightarrow\Longrightarrow\Longrightarrow$[更好的阅读体验](https://www.cnblogs.com/y2823774827y/p/10265456.html)
 
 #### 题目
[P4111 [HEOI2015]小Z的房间](https://www.luogu.org/problemnew/show/P4111)

#### 做法
思路很容易想，但是坑点多啊！！

首先有墙，并不能所有点都堆到矩阵然后去末行求$det$，非墙点才能丢进矩阵

动态开一下点

有模数，不是素数，也用不了逆元，我们就要用求$det$的黑科技，辗转相除法

## [code](https://www.cnblogs.com/y2823774827y/p/10265456.html)

---

## 作者：5k_sync_closer (赞：0)

这个大房子可以看成一张 $n\times m$ 的网格图，

柱子不能打通的限制可以看成删去每个柱子对应的点，

此时答案即为剩下的图的生成树个数。

用矩阵树定理求解即可。

```cpp
#include <cstdio>
#include <algorithm>
#define M 1000000000
#define int long long
using namespace std;
char z;
int u, v, n, _ = 1, q = 1, o[350][350], a[350][350];
void A(int u, int v)
{
    a[u][u] = (a[u][u] + 1) % M, a[v][v] = (a[v][v] + 1) % M;
    a[u][v] = (a[u][v] + M - 1) % M, a[v][u] = (a[v][u] + M - 1) % M;
}
signed main()
{
    scanf("%lld%lld", &u, &v);
    for (int i = 1; i <= u; ++i)
        for (int j = 1; j <= v; ++j)
        {
            scanf(" %c", &z);
            if (z == '.')
                o[i][j] = ++n;
        }
    for (int i = 1; i <= u; ++i)
        for (int j = 1; j <= v; ++j)
        {
            if (i != u && o[i][j] && o[i + 1][j])
                A(o[i][j], o[i + 1][j]);
            if (j != v && o[i][j] && o[i][j + 1])
                A(o[i][j], o[i][j + 1]);
        }
    for (int i = 2; i <= n; ++i)
        for (int j = i + 1; j <= n; ++j)
        {
            while (a[i][i])
            {
                int z = a[j][i] / a[i][i];
                for (int k = i; k <= n; ++k)
                    a[j][k] = (a[j][k] + M - a[i][k] * z % M) % M;
                swap(a[i], a[j]);
                _ = -_;
            }
            swap(a[i], a[j]);
            _ = -_;
        }
    for (int i = 2; i <= n; ++i)
        q = (q * a[i][i]) % M;
    if (_ == -1)
        q = (M - q) % M;
    printf("%lld", q);
    return 0;
}
```


---

## 作者：楠枫 (赞：0)

## 题解
**题目大意**：给定一个无向图，求它的生成树个数。

一道裸的矩阵树定理，外加一些建图的技巧。

### 矩阵树定理

对于一个 $Laplace$ 矩阵，其去掉任意一行后的行列式即为答案。

[行列式不会的看这里](https://blog.csdn.net/zhoufenqin/article/details/7779707)

$Laplace$ 矩阵是一个无向图的邻接矩阵转化而来的，其中 $L_{i,i}$ 代表 $i$ 的度数，$L_{i,j}$ 代表 $i->j$ 有多少条路径（准确的说是这些路径的权值和，求生成树时设为 $1$ ）。

至于怎么算，[看这里](https://oi-wiki.org/graph/matrix-tree/)。

那么有了这些知识，我们就可以 $A$ 了这题。

注意，这题中模数不是质数，不能求逆元，所以我们消元时要用辗转相除法，所以真正的时间复杂度为 $\mathcal O((nmlog_{nm})^3)$。

$AC \kern 0.5emCODE:$
```cpp
#include<bits/stdc++.h>
#define ri register signed
#define p(i) ++i
using namespace std;
namespace IO{
    char buf[1<<21],*p1=buf,*p2=buf;
    #define gc() p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++
    inline int read() {
        ri x=0,f=1;char ch=getchar();
        while(ch<'0'||ch>'9') {if (ch=='-') f=-1;ch=getchar();}
        while(ch>='0'&&ch<='9') {x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}
        return x*f; 
    }
}
using IO::read;
namespace nanfeng{
    #define int long long
    #define cmax(x,y) ((x)>(y)?(x):(y))
    #define cmin(x,y) ((x)>(y)?(y):(x))
    #define FI FILE *IN
    #define FO FILE *OUT
    static const int MOD=1e9,N=15;
    int id[N][N],G[N*N][N*N],deg[N*N],n,m,cnt,ans=1;
    char h[N][N];
    inline void add(int u,int v) {G[u][v]=G[v][u]=1;}
    inline int main() {
        // FI=freopen("nanfeng.in","r",stdin);
        // FO=freopen("nanfeng.out","w",stdout);
        n=read(),m=read();
        for (ri i(1);i<=n;p(i)) {
            scanf("%s",h[i]+1);
            for (ri j(1);j<=m;p(j)) if (h[i][j]=='.') id[i][j]=p(cnt); 
        }
        for (ri i(1);i<=n;p(i)) {
            for (ri j(1);j<=m;p(j)) {
                if (id[i][j]&&id[i][j-1]) add(id[i][j],id[i][j-1]);
                if (id[i][j]&&id[i-1][j]) add(id[i][j],id[i-1][j]);
            }
        }
        for (ri i(1);i<=cnt;p(i)) {
            for (ri j(1);j<=cnt;p(j)) if (G[i][j]) p(deg[i]);
        }
        for (ri i(1);i<=cnt;p(i)) {
            for (ri j(1);j<=cnt;p(j)) {
                if (i==j) G[i][j]=deg[i];
                else G[i][j]=-G[i][j];
            }   
        }
        cnt-=1;
        for (ri i(1);i<=cnt;p(i)) {//这是高斯消元，要化成三角矩阵，而不要以高斯约旦法消成对角线矩阵。
            for (ri j(i+1);j<=cnt;p(j)) {
                while(G[j][i]) {
                    int k=G[i][i]/G[j][i];
                    for (ri l(i);l<=cnt;p(l)) G[i][l]=(G[i][l]-G[j][l]*k%MOD+MOD)%MOD;
                    swap(G[i],G[j]);
                    ans*=-1;
                }
            }
            ans=(ans*G[i][i]%MOD+MOD)%MOD;
        } //求行列式
        printf("%lld\n",(ans+MOD)%MOD);
        return 0;
    }
    #undef int
}
int main() {return nanfeng::main();}
```


---

## 作者：crescentic (赞：0)

[小Z的房间](https://www.luogu.com.cn/problem/P4111)

### 思路分析

很明显的矩阵树。

矩阵树定理如下：
 > 对于一个无向图 $G$ ，它的生成树个数等于其基尔霍夫 $Kirchhoff$ 矩阵任何一个 $N-1$ 阶主子式的行列式的绝对值。

可以将问题转化为，求一个无向图的生成树个数，柱子啥的基本没啥作用。。。

所以将房子看作点即可，用 $cnt$ 重新编号。如果两个房子相邻，就连边。注意可以只判断下方和右方的情况，避免重复情况。其实只判断上方和左方也可以，主要看心情~

然后就是高斯消元模板，这里就不赘述了。具体实现看代码吧~

有一点就是，取模时要注意负数的情况。

### $CODE$

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
#define int long long
const int mod = 1e9;
int n,m,cnt,ans = 1,sum[105][105],num[15][15];
char s[15][15];
void add(int x,int y) {
	sum[x][x] ++, sum[y][y] ++;
	sum[x][y] --, sum[y][x] --;
}
signed main() {
	scanf("%lld %lld",&n,&m);
	for(int i = 1; i <= n; i ++) {
		scanf("%s",s[i] + 1); 
		for(int j = 1; j <= m; j ++) {
			if(s[i][j] == '.') num[i][j] = ++cnt;//点 
		}
	}
	for(int i = 1; i <= n; i ++) {//处理连边 
		for(int j = 1; j <= m; j ++) {
			if(!num[i][j]) continue;
			if(num[i + 1][j]) add(num[i][j],num[i + 1][j]);
			if(num[i][j + 1]) add(num[i][j],num[i][j + 1]);
		}
	}
	for(int i = 1; i < cnt; i ++) {//消元 
		for(int j = i + 1; j < cnt; j ++) {
			while(sum[j][i]) {
				int d = sum[i][i] / sum[j][i];
				for(int k = 1; k < cnt; k ++) sum[i][k] = (sum[i][k] - d * sum[j][k] % mod + mod) % mod,swap(sum[i][k],sum[j][k]);
				ans *= -1;
			}
		}
		ans = (ans * sum[i][i] % mod + mod) % mod;//+mod:处理负数 
	}
	printf("%lld",ans);
	return 0;
} 
```





---


# 于神之怒加强版

## 题目描述

给定 $n,m,k$，计算

$$\sum_{i=1}^n \sum_{j=1}^m \gcd(i,j)^k$$

对 $10^9 + 7$ 取模的结果。

## 说明/提示

#### 数据规模与约定

对于全部的测试点，保证 $1 \leq T \leq 2 \times 10^3$，$1 \leq n, m, k \leq 5 \times 10^6$。

## 样例 #1

### 输入

```
1 2
3 3```

### 输出

```
20```

# 题解

## 作者：滑大稽 (赞：31)

Update on 2021.2.4：修复了一些小错误

Update on 2021.9.1：再学线筛积性函数，补充解释，看的更清楚 ~~（可能吧）~~。

Update on 2021.9.2：新增关于 $G$ 函数的另一种筛法。

题外话：我研究了一下午题解终于搞懂了这道题，为了避免他人像我一样重(zhou)蹈(ma)覆(ti)辙(jie)，准备把我所理解的所有有关这道题的全部写出来。

首先，这个题目要求我们求这样一个式子：
$$
\sum_{i=1}^n\sum_{j=1}^m\gcd(i,j)^k
$$
一看到 $\gcd$，就可以很明显地感觉到，这是道莫反的题。

于是，我们开始按照莫反的思维推式子。

设
$$
f(k)=\sum_{i=1}^n\sum_{j=1}^m[\gcd(i,j)=k]
$$
$$
F(k)=\sum_{i=1}^n\sum_{j=1}^m[k|\gcd(i,j)]
$$
其中
$$
F(k)=\sum_{i=1}^{\lfloor \frac n k \rfloor}\sum_{j=1}^{\lfloor \frac m k \rfloor}1=\lfloor \frac n k \rfloor * \lfloor \frac m k \rfloor
$$
然后就可以得到
$$
F(k)=\sum_{k|d}f(d)
$$
根据反演，就可以知道
$$
f(k)=\sum_{k|d}\mu(\frac d k)* F(d)=\sum_{k|d}\mu(\frac d k)* \lfloor \frac n d \rfloor * \lfloor \frac m d \rfloor
$$
那么答案：
$$
ans=\sum_{i=1}^{min(n,m)}i^k* f(i)=\sum_{i=1}^{min(n,m)}i^k* \sum_{i|d}\mu(\frac d i)* \lfloor \frac n d \rfloor * \lfloor \frac m d \rfloor
$$
其中 $i^k$ 可以提到和号里面，$\lfloor \frac n d \rfloor * \lfloor \frac m d \rfloor$ 可以提到和号外面，就成了：
$$
ans=\sum_{i=1}^{min(n,m)}\lfloor \frac n d \rfloor * \lfloor \frac m d \rfloor* \sum_{i|d}\mu(\frac d i)* i^k 
$$
然后可以改一下和号的顺序:
$$
ans=\sum_{d=1}^{min(n,m)} \lfloor \frac n d \rfloor * \lfloor \frac m d \rfloor*\sum_{i|d} \mu(\frac d i)* i^{k}
$$

这一切看起来都是那么的和谐，前面可以用整除分块搞掉。

这题，要切掉了吧？

“好水啊”你心里暗自感叹着。

可是，当你注意后面那一坨以后，你可能会直接懵掉。

你尝试把他变成 $\varphi$，但你发现答案成了这样：
$$
ans=\sum_{d=1}^{min(n,m)} \lfloor \frac n d \rfloor * \lfloor \frac m d \rfloor* \varphi(d)\sum_{i|d} i^{k-1}
$$

后面这一坨还是搞不出来，不然 $O(n*\sqrt n)$ 的预处理拿点分？

可是你又不甘心。

我们发现后面的那一坨是一个卷积的形式，并且两个函数均为积性函数，所以卷起来也是积性函数。考虑线性筛。

设：


$$
g(x)=x^k
$$

$$
G(n)=\sum_{i|n}g(i)* \mu(\frac n i)
$$
那么答案就成了：
$$
ans=\sum_{d=1}^{min(n,m)}G(d)* \lfloor \frac n d \rfloor * \lfloor \frac m d \rfloor
$$

可是，$G$ 又怎么求？

(update的另一种求法在第一份代码后面)

就是这个问题，困扰我许久，翻遍了所有题解，才总结出这个自认为易懂一点的解释：

先扔结论：

$$
 G(a* b)=G(a)* G(b)(\gcd(a,b)=1)
$$
$$
G(a* b)=G(a)* b^k(\gcd(a,b) \ne 1\land b\in\mathbb P)
$$

首先第一个式子应该很好证明吧：

根据定义易得，$g,\mu$ 函数都为积性函数。而 $G=g*\mu$，所以根据狄利克雷卷积易知，$G$ 也为积性函数，所以第一个式子得证。

关键就是第二个式子怎么证，证了就可以在线性筛的时候处理了，但它的证明也困扰了我一个多小时。

首先设:
$$
a=p_1^{c_1}* p_2^{c_2} * p_3^{c_3}...* p_k^{c_k}(b\in \{p_i\})
$$


注意到 $b\in \{p_i\}$ 的条件是一定满足的，因为 $b$ 是一个质数，并且 $\gcd(a,b) \ne 1$ 。而这个条件在后面证明时会用到。

根据 $G$ 是积性函数可知：
$$
G(a)=\prod_{i=1}^kG(p_i^{c_i})
$$

然后设 $p_t=b$（前后呼应），就可以得到如下式子：
$$

\frac{G(a* b)}{G(a)}=\frac{\prod_{i=1}^kG(p_i^{c_i+[i=t]})}{\prod_{i=1}^kG(p_i^{c_i})}=\frac{G(p_t^{c_t+1})}{G(p_t^{c_t})}
$$

这里解释一下，因为只有当 $i=t$ 时分子分母的值才不同，其他的都可以约分约掉，所以可以约分成后面那个样子。

再看一下该怎么化简。尝试把 $G$ 展开。
$$
G(p_i^{c_i})=\sum_{j=0}^{c_i}g(p_i^{j})* \mu(p_i^{c_i-j})
$$
这里是对于任意一个质数的 $n$ 次幂的 $G$ 函数值而言的。

然后我们发现，只有当 $c_i-j \le 1$ 时 $\mu(p_i^{c_i-j})\ne0$（根据莫比乌斯函数的定义）

$$
\therefore G(p_i^{c_i})=g(p_i^{c_i})-g(p_i^{c_i-1})
$$

然后就可以带回原式了：
$$
\frac{G(a* b)}{G(a)}=\frac{g(p_t^{c_t+1})-g(p_t^{c_t})}{g(p_t^{c_t})-g(p_t^{c_t-1})}=\frac{p_t^{(c_t+1)* k}-p_t^{c_t* k}}{p_t^{c_t* k}-p_t^{(c_t-1)* k}}=p_t^k=b^k
$$

第二个式子也就证明出来了。

这里总结一下做法，先用线性筛把 $G$ 函数的值证明出来，预处理一下前缀和，这里复杂度可以认为是 $O(n)$ 的。（只在质数处跑了qpow，质数数量不多，所以这个 $\log$ 对于复杂度没影响。）（质数和质数幂的数量乘上 $\log 10^9+7$ 大概是 $2\times n$ 的样子）

然后对于每一组询问，跑一次整除分块，单次复杂度 $O(\sqrt n)$，$t$ 组复杂度就是 $O(t*\sqrt n)$。

总复杂度 $O(n+t*\sqrt n)$，可以通过此题。

请别介意我巨丑的代码：

```cpp
#include<iostream>
#include<cstdio>
#define int long long
using namespace std;
const int N=5e6+5,mod=1e9+7;
int g[N],pri[N],sum[N];
bool v[N];
inline int read()
{
	char h=getchar();
	int y=0,q=1;
	while(h<'0'||h>'9'){if(h=='-')q=-1;h=getchar();}
	while(h>='0'&&h<='9'){y=y*10+h-'0';h=getchar();}
	return y*q;
}
inline int qpow(int a,int b)
{
	int j=1;
	while(b)
	{
		if(b&1)(j*=a)%=mod;
		(a*=a)%=mod;
		b>>=1;
	}
	return j;
}
inline void init(int k)
{
	g[1]=1;
	int tot=0;
	for(int i=2;i<N;i++)
	{
		if(!v[i]){pri[++tot]=i;g[i]=(qpow(i,k)-1+mod)%mod;}
		for(int j=1;j<=tot&&pri[j]*i<N;j++)
		{
			v[pri[j]*i]=1;
			if(i%pri[j]==0)
			{
				g[pri[j]*i]=(g[i]*((g[pri[j]]+1)%mod))%mod;//g[pri[j]]+1=pri[j]^k
				break;
			}
			g[pri[j]*i]=(g[i]*g[pri[j]])%mod;
		}
	}
	for(int i=1;i<N;i++)sum[i]=(sum[i-1]+g[i])%mod;
}
inline int f(int a,int b)
{
	int n=min(a,b),ans=0;
	for(int l=1,r;l<=n;l=r+1)
	{
		r=min(a/(a/l),b/(b/l));
		ans=(ans+(sum[r]-sum[l-1])*(a/l)%mod*(b/l)%mod+mod)%mod;
	}
	return ans;
}
signed main()
{
	int t=read(),k=read();
	init(k);
	while(t--)
	{
		int n=read(),m=read();
		printf("%lld\n",f(n,m));
	}
}
```


update:

我们发现，上面的求解证明有点复杂。作为一名专业的懒癌oier，肯定要用某个特定的规律来做这种题。

$$
G(n)=\sum_{i|n}g(i)* \mu(\frac n i)
$$

首先，对于质数，我们一般很好求它的值，就直接算了。

然后对于筛那部分，假如 $pri[j]\nmid i$，则他们是互质的，$G[i* pri[j]]=G[i]* G[pri[j]]$。

然后我们就考虑不互质的情况了。我们尝试把 $i$ 中的 $pri[j]$ 全部提出来。所以记录 $ti[i]$ 为 $i$ 中最小素因子的出现次数，$t[i]$ 为最小素因子的 $ti[i]$ 次方。则有 $G[i* pri[j]]=G[\frac i {t[i]}]* G[pri[j]* t[i]]$。

但是我们发现，对于 $i* pri[j]$ 是一个质数的若干次幂的情况，它可能会自摸。比如 $i=2,pri[j]=2$，我们可以得到关于 $G[4]$ 的所谓表达式：$G[4]=G[1]* G[4]$。这就有问题了。所以我们对于质数若干次幂特殊考虑下。设 $i* pri[j]=p^b$。因为右边是 $\mu$，所以只会有 $g(p^b)* \mu(1)+g(p^{b-1})* \mu(p)$ 有贡献，展开即为 $p^{bk}-p^{(b-1)k}$。也就考虑完了。

复杂度仍然为 $O(n+t*\sqrt n)$。但是因为筛的位置在质数处和质数幂处跑了qpow，所以常数略大。但因为质数和质数幂数量较小，不会影响筛总体 $O(n)$ 的复杂度。（质数和质数幂的数量乘上 $\log 10^9+7$ 也大概是 $2\times n$ 的样子）

上一下筛的代码就行了：

```cpp
inline void init(int k)
{
	g[1]=1;
	int tot=0;
	for(int i=2;i<N;i++)
	{
		if(!v[i]){pri[++tot]=i;g[i]=(qpow(i,k)-1+mod)%mod;t[i]=i;ti[i]=1;}
		for(int j=1;j<=tot&&pri[j]*i<N;j++)
		{
			v[pri[j]*i]=1;
			if(i%pri[j]==0)
			{
				t[i*pri[j]]=t[i]*pri[j];
				ti[i*pri[j]]=ti[i]+1;
				if(t[i]==i)
				{
					g[pri[j]*i]=qpow(pri[j],(ti[i]+1)*k)-qpow(pri[j],ti[i]*k);
					if(g[pri[j]*i]<0)g[pri[j]*i]+=mod;
				}
				else
				{
					g[i*pri[j]]=1ll*g[i/t[i]]*g[t[i]*pri[j]]%mod;
				}
				break;
			}
			g[pri[j]*i]=(g[i]*g[pri[j]])%mod;
			t[i*pri[j]]=pri[j];ti[i*pri[j]]=1;
		}
	}
	for(int i=1;i<N;i++)sum[i]=(sum[i-1]+g[i])%mod;
}
```

---

## 作者：Wolfycz (赞：30)

先放上[博客原址](https://www.cnblogs.com/Wolfycz/p/9485396.html)，~~我才不是想刷访问量的~~

好，我们讲讲这题怎么写

我们令n<m，然后推柿子
$$\sum\limits_{i=1}^n\sum\limits_{j=1}^m gcd(i,j)^k$$
$$\sum\limits_{i=1}^n\sum\limits_{j=1}^m\sum\limits_{d=1}^n d^k [gcd(i,j)==1]$$
$$\sum\limits_{d=1}^n d^k\sum\limits_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum\limits_{j=1}^{\lfloor\frac{m}{d}\rfloor}\sum\limits_{x|i,x|j}\mu(x)$$
$$\sum\limits_{d=1}^n d^k\sum\limits_{x=1}^{\lfloor\frac{n}{d}\rfloor}\mu(x)\lfloor\dfrac{n}{dx}\rfloor\lfloor\dfrac{n}{dx}\rfloor$$
然后我们令$T=dx$，柿子变为
$$\sum\limits_{T=1}^n\lfloor\dfrac{n}{T}\rfloor\lfloor\dfrac{m}{T}\rfloor\sum\limits_{d|T}d^k\mu(\dfrac{T}{d})$$
令$g(T)=\sum\limits_{d|T}d^k\mu(\dfrac{T}{d})$，因此我们只要预处理出$g(T)$及其前缀和，我们便又可以开心地分块了

由于莫比乌斯反演的性质，所以$g(T)$是积性函数，所以有
$$g(T)=\prod\limits_{i=1}^t g(P_i^{x_i})$$
$$=\prod\limits_{i=1}^t(P_i^{k\times (x_i-1)}\times \mu(P_i)+P_i^{k\times x_i}\times \mu(1))$$
$$=\prod\limits_{i=1}^t P_i^{k\times (x_i-1)}\times(P_i^k-1)$$
然后就可以线筛了$\sim\sim\sim$
``` cpp
/*program from Wolfycz*/
#include<cmath>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#define inf 0x7f7f7f7f
using namespace std;
typedef long long ll;
typedef unsigned int ui;
typedef unsigned long long ull;
inline int read(){
	int x=0,f=1;char ch=getchar();
	for (;ch<'0'||ch>'9';ch=getchar())	if (ch=='-')    f=-1;
	for (;ch>='0'&&ch<='9';ch=getchar())	x=(x<<1)+(x<<3)+ch-'0';
	return x*f;
}
inline void print(int x){
	if (x>=10)	print(x/10);
	putchar(x%10+'0');
}
const int N=5e6,p=1e9+7;
int prime[N+10],miu[N+10],g[N+10],f[N+10];
bool inprime[N+10];
int Data,k,tot;
int mlt(int a,int b){
	int res=1;
	for (;b;b>>=1,a=1ll*a*a%p)	if (b&1)	res=1ll*res*a%p;
	return res;
}
void prepare(){
	f[1]=1;
	for (int i=2;i<=N;i++){
		if (!inprime[i]){
			prime[++tot]=i;
			g[tot]=mlt(i,k);
			f[i]=(g[tot]-1+p)%p;
		}
		for (int j=1;j<=tot&&i*prime[j]<=N;j++){
			inprime[i*prime[j]]=1;
			if (i%prime[j]==0){
				f[i*prime[j]]=1ll*f[i]*g[j]%p;
				break;
			}
			f[i*prime[j]]=1ll*f[i]*f[prime[j]]%p;
		}
	}
	for (int i=1;i<=N;i++)	f[i]=(f[i]+f[i-1])%p;
}
int main(){
	Data=read(),k=read();
	prepare();
	while (Data--){
		int n=read(),m=read(),T=min(n,m),pos,Ans=0;
		for (int i=1;i<=T;i=pos+1){
			pos=min(n/(n/i),m/(m/i));
			Ans=(Ans+1ll*(f[pos]-f[i-1]+p)*(n/i)%p*(m/i)%p)%p;
		}
		printf("%d\n",Ans);
	}
	return 0;
}
```

---

## 作者：ecnerwaIa (赞：26)

[题目](https://www.luogu.org/problemnew/show/P4449)（数论题说大意没什么必要吧）

开始有趣的推导过程！！（下面的$p$都表示质数,$x$都表示质因数中$p$的幂）

$$\sum_{i=1}^{n} \sum_{j=1}^{m}gcd(i,j)^{k}$$

一看还是那个套路枚举$gcd(i,j)$,为了方便起见，我们令$n<=m$

$$\sum_{i=1}^{n}d^k*{\sum_{j=1}^{\lfloor\frac{n}{i}\rfloor}{\mu(j)*\lfloor\frac{n}{i*j}\rfloor*\lfloor\frac{m}{i*j}\rfloor}}$$

这个形式不怎么能优化呢，好在我们做题多，发现可以枚举$T=i*j$

$$\sum_{T=1}^{n}\lfloor\frac{n}{T}\rfloor*\lfloor\frac{m}{T}\rfloor*\sum_{d|T}{d^k*\mu(\frac{T}{d})}$$

然后发现其实后面那个式子就是个卷积啦，如果k=1，卷积就是$\phi$,但这里出题人~~太坏了~~，不过因为是个积性函数，那么我们也可以像$\phi$一样线性求出来

令$f=id_k*\mu$，那么有

$$f(n)=\prod_{p_{i}|n}{f(p_{i}^{x_{i}})}$$

然后我们求$f(p_{i}^{x_{i}})$

$$f(p_{i}^{x_{i}})=\sum_{d|p_{i}^{x_{i}}}d^k*\mu(\frac{p_{i}^{x_{i}}}{d})$$

然后发现除了$d=p_{i}^{x_{i}-1},\frac{p_{i}^{x_{i}}}{d}=p_{i},\mu(p_{i})=-1$和$d=p_{i}^{x_{i}},\frac{p_{i}^{x_{i}}}{p_{i}^{x_{i}}}=1,\mu(1)=1$其余的$\mu$值都为0

这个应该都很清楚吧,莫比乌斯函数的一个性质$:$有>1个相同质因数时$\mu$为0

这样的话就简单了！

$$f(p_{i}^{x_{i}})=p_{i}^{k*x_{i}}-p_{i}^{k*(x_{i}-1)}=(p_{i}^k-1)*p_{i}^{k*(x_{i}-1)}$$

考虑$f(p_{i}^{x_{i}-1})(x_{i}>1)$

$$f({p_{i}^{x_{i}-1}})=(p_{i}^k-1)*p_{i}^{k*(x_{i}-2)}$$

则会发现$f(p_{i}^{x_{i}})=f(p_{i}^{x_{i}-1})*p_{i}^k$(当$x_{i}>1$时成立)

而当$x_{i}=1$时也简单,就是$p_{i}^k-1$

则现在求出了$f(i)$，要求$f(i*p_j)$

$$f(i*p_j)=\begin{cases}f(i)*p_{j}^k,&i\%j==0\\f(i)*(p_j^k-1),&i\%j!=0\end{cases}$$

那么就可以愉快的线性筛了（注：$f(p_j)=p_j^k-1$）

```cpp
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <queue>
using namespace std;
const int mod=1e9+7,N=5000000,M=350000;
int prime[M],p[M],t,k,n,m,f[N+10];
bool not_prime[N+10];
inline int qpow(int a,int b){int s=1;while(b){if(b&1)s=s*1ll*a%mod;a=a*1ll*a%mod;b>>=1;}return s;}
inline int mo(int x){if(x>mod)x-=mod;return x;}
#define min_(a,b) (a<b?a:b)
inline void get_pre(){
	f[1]=1;
	for(int i=2;i<=N;++i){
		if(!not_prime[i]){prime[++prime[0]]=i;p[prime[0]]=qpow(i,k);f[i]=mo(p[prime[0]]-1+mod);}
		for(int j=1;j<=prime[0]&&i*prime[j]<=N;++j){
			not_prime[i*prime[j]]=1;
			if(i%prime[j]==0){
				f[i*prime[j]]=f[i]*1ll*p[j]%mod; 
				break;
			}f[i*prime[j]]=f[i]*1ll*f[prime[j]]%mod;
		}
	}for(int i=2;i<=N;++i)f[i]=(f[i]+f[i-1])%mod;
}
inline int ab(int x){if(x<0)x+=mod;return x;}
int main(){
	scanf("%d%d",&t,&k);
	get_pre();
	int maxn,ans,j;
	while(t--){
		scanf("%d%d",&n,&m);
		maxn=min_(n,m);ans=0;
		for(int i=1;i<=maxn;i=j+1){
			j=min_(n/(n/i),m/(m/i));
			ans+=(ab(f[j]-f[i-1]))*1ll*(n/i)%mod*(m/i)%mod;
			ans=mo(ans);
		}printf("%d\n",ans);
	}
	return 0;
}

```



---

## 作者：楠枫 (赞：12)

这道题算是我完完整整推的第一道题，写篇题解纪念一下。

[题目](https://www.luogu.com.cn/problem/P4449)

废话不多说，直接开始推式子（给新手准备，过程较详细，大佬可自行跳步），以下过程中均假设 $(n\le m)$，$[d=1]$ 类似于代码中的 ```(d==1)``` 。
$$
\sum_{i=1}^{n}\sum_{j=1}^mgcd(i,j)^k
$$
直接按套路提取
$$
\sum_{d=1}^{n}d^k\sum_{i=1}^{n}\sum_{j=1}^m[gcd(i,j)=d]
$$
等价于
$$
\sum_{d=1}^{n}d^k\sum_{i=1}^{n}\sum_{j=1}^m[gcd(\frac{i}{d},\frac{j}{d})=1]
$$
我们改变一下枚举项，枚举 $\frac{i}{d},\frac{j}{d}$ 
$$
\sum_{d=1}^{n}d^k\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{d}\rfloor}[gcd(i,j)=1]
$$
接下来就要用到莫比乌斯函数的性质
$$
\sum_{d=1}^{n}d^k\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{d}\rfloor}\sum_{x|i}\sum_{x|j}\mu(x)
$$
我们改成枚举 $\frac{i}{x},\frac{j}{x}$
$$
\sum_{d=1}^{n}d^k\sum_{x=1}^{\lfloor\frac{n}{d}\rfloor}\lfloor\frac{n}{dx}\rfloor\lfloor\frac{m}{dx}\rfloor\mu(x)
$$
这个 $dx$ 让人很不爽，我们把它换个元，另 $T=dx$
$$
\sum_{T=1}^n\sum_{d|T}d^k\lfloor\frac{n}{T}\rfloor\lfloor\frac{m}{T}\rfloor\mu(\frac{T}{d})
$$
把无关项往前提一提
$$
\sum_{T=1}^n\lfloor\frac{n}{T}\rfloor\lfloor\frac{m}{T}\rfloor\sum_{d|T}d^k\mu(\frac{T}{d})
$$
整理好后我们会发现这个式子太友善了，后面一部分
$$
\sum_{d|T}d^k\mu(\frac{T}{d})
$$
完全就是 $id_k*\mu$ ( $*$ 为 $Dirichlet$ 卷积)，所以我们可以知道 $f(T)=id_k*\mu$ 是一个积性函数。

所以我们只需要研究 $T|p^x\kern 0.4emx\in N_+ \kern 0.4emp\in prime$

而由于 $\mu$ 的性质，(当 $x=1$ 时)
$$
d^k\mu(\frac{T}{d})=\left\{
\begin{aligned}
-1\kern 1.0em(d=1)\\
T^k\kern 1.0em(d=T)\\
\end{aligned}
\right.
$$
所以 $f(T)=T^k-1$ 

当 $x>1$ 时，有
$$
d^k\mu(\frac{T^x}{d})=\left\{
\begin{array}{lcl}
-(T^{x-1})^k\kern 1.0em(d=T^{x-1})\\
(T^x)^k\kern 2.7em(d=T^x)\\
\end{array}
\right.
$$
所以我们线性筛时
$$
f_{i×prime_j}=\left\{
\begin{array}{lcl}
f_i×f_{prime_j}\kern 1.0em gcd(prime_j,i)=1\\
f_i×prime_j^k\kern 1.0em (prime_j|i)
\end{array}
\right.
$$
这样我们就可以愉快的线性筛了，而由于那个快被我们遗忘的前半部分用数论分块，所以总体复杂度为 $O(n+(\text{素数个数})×logk+T×\sqrt{n})$

$AC\kern 0.4em CODE:$
```cpp
#include<bits/stdc++.h>
#define ri register int
#define p(i) ++i
using namespace std;
const int MOD=1e9+7,N=5e6+7; 
inline int read() {
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}
	return x*f;
}
int prime[N],vis[N],f[N],cm[N],k;
inline int fpow(int x,int y) {
	int res=1;
	while(y) {
		if (y&1) res=1ll*res*x%MOD;
		x=1ll*x*x%MOD;y>>=1;
	}
	return res;
} 
void getmju(int n) {
	int tot=0;f[1]=1;
	for (ri i(2);i<=n;p(i)) {
		if (!vis[i]) prime[p(tot)]=i,cm[tot]=fpow(i,k),f[i]=1ll*(cm[tot]-1+MOD)%MOD;
		for (ri j(1);j<=tot&&prime[j]*i<=n;p(j)) {
			vis[prime[j]*i]=1;
			if (!(i%prime[j])) {
				f[i*prime[j]]=1ll*cm[j]*f[i]%MOD;
				break;
			}
			f[i*prime[j]]=1ll*f[i]*f[prime[j]]%MOD;
		}
	}
	for (ri i(2);i<=n;p(i)) f[i]=(f[i]+f[i-1])%MOD; 
}
int n[2020],m[2020],mxn;
int main() {
	//freopen("rr.out","w",stdout);
	int T=read();k=read();
	for (ri i(1);i<=T;p(i)) n[i]=read(),m[i]=read(),mxn=max(mxn,min(n[i],m[i]));\\小小的优化一下
	getmju(mxn);
	for (ri i(1);i<=T;p(i)) {
		int nn=n[i],mm=m[i];
		if (nn>mm) swap(nn,mm);
		int ans=0;
		for (ri l(1),r;l<=nn;l=r+1) {
			r=min(nn/(nn/l),mm/(mm/l));
			ans=(ans+1ll*((f[r]-f[l-1]+MOD)%MOD)*(nn/l)%MOD*(mm/l)%MOD)%MOD;
		}
		printf("%d\n",ans);
	}
	return 0;
}
```

---

## 作者：Soulist (赞：10)

原题要求即：

$$\sum_{i=1}^n\sum_{j=1}^mgcd(i,j)^k$$

也就是：

$$\sum_{d=1}^nd^k\sum_{x=1}^{n/d}\mu(x)[\dfrac{n}{xd}][\dfrac{m}{xd}]$$

套路设 $T = xd$

得到式子：

$$\sum_{T=1}^n[\dfrac{n}{T}][\dfrac{m}{T}]\sum_{d|T}d^k*\mu(\frac{T}{d})$$

设$f(x) = \sum_{d|x}d^k*\mu(\frac{x}{d})$

本题重点应该是如何线性求出这个函数。$(-///-)$ ~~（也可能是我菜了）~~

满足下列性质的积性函数均可以线性求出：

$f(p)$可以快速求 且 $f(p^k)$可以快速求 $/$ 由$f(p^{k-1})$推出

具体做法是记一个$low[x]$维护$x$的最小质因子的次方。

然后较好的做法是用$low[x]$维护$x$的最小质因子的 $p_k$ 次方是多少

看代码的话应该可以理解 $QwQ$， 想一想 **欧拉筛** 和 **积性函数** 的性质。

话说这道题取模有点坑啊，最好开$longlong$

```cpp
#include<bits/stdc++.h>
using namespace std;
int read() {
	char cc = getchar(); int cn = 0, flus = 1;
	while(cc < '0' || cc > '9') {  if( cc == '-' ) flus = -flus;  cc = getchar();  }
	while(cc >= '0' && cc <= '9')  cn = cn * 10 + cc - '0', cc = getchar();
	return cn * flus;
}
#define LL long long
#define int long long
#define rep( i, s, t ) for( register int i = s; i <= t; ++ i )
const int N = 5000000 + 5 ;
const int mod = 1000000007 ;
int n, m, maxn, p[N], top , low[N];
LL f[N], sum[N];
bool isp[N];
int pow2( int x, int k ) {
	LL ans = 1, base = x;
	while( k ) {
		if( k & 1 ) ans *= base, ans %= mod;
		base *= base, base %= mod;
		k >>= 1;
	}
	return ans; 
}
void init() {
	maxn = N - 5, f[1] = sum[1] = 1;
	rep( i, 2, maxn ) {
		if( !isp[i] ) p[++ top] = i, f[i] = pow2( i, m ) - 1, low[i] = i;
		rep( j, 1, top ) {
			if( 1ll * p[j] * i > maxn ) break;
			isp[i * p[j]] = 1;
			if( i % p[j] == 0 ) {
				low[i * p[j]] = low[i] * p[j];
				if( low[i] == i ) f[i * p[j]] = ( pow2( i * p[j], m ) - pow2( i, m ) + mod ) % mod;
				else f[i * p[j]] = f[i / low[i]] * f[low[i] * p[j]] % mod;
				break;
			}
			f[i * p[j]] = f[i] * f[p[j]] % mod, low[i * p[j]] = p[j];
		}
		sum[i] = ( sum[i - 1] + f[i] ) % mod;
	}
}
signed main()
{
	int T = read(), x, y, l, r; m = read();
	init(); LL ans;
	while( T-- ) {
		x = read(), y = read(); if( x > y ) swap( x, y );
		ans = 0;
		for( l = 1; l <= x; l = r + 1 ) {
			r = min( ( x / ( x / l ) ), ( y / ( y / l ) ) );
			ans = ( ans + 1ll * ( ( x / l ) * ( y / l ) % mod ) * ( ( sum[r] - sum[l - 1] + mod ) % mod ) % mod ) % mod;
		}
		printf("%lld\n", ans % mod);
	}
	return 0;
}


```

---

## 作者：whiteqwq (赞：6)

备注：$\mathbb{P}$为质数集，$\mathbb{N^+}$为自然数集。

[P4449 于神之怒加强版](https://www.luogu.com.cn/problem/P4449)解题报告：

[更好的阅读体验](https://zybuluo.com/xiaoziyao/note/1707601)

题意：给定$T$与$k$，后有$T$组数据给定$n$和$m$，求
$$\sum_{i=1}^n\sum_{j=1}^m\gcd(i,j)^k$$
数据范围：$1\leqslant T\leqslant 2\times 10^3,1\leqslant n,m,k\leqslant 5\times 10^6$

我们可以先给原式变换一下形式（以下默认$n\leqslant m$）：
$$\sum_{i=1}^n\sum_{j=1}^m\gcd(i,j)^k$$

首先套路性地枚举$\gcd$：
$$\sum_{d=1}^n\sum_{i=1}^n\sum_{j=1}^m d^k[\gcd(i,j)==d]$$
（中括号内的是一个有点像$bool$的东西）

可以发现造成贡献的都是$\gcd(i,j)==d$的$(i,j)$，那么$i$和$j$肯定是$d$的倍数，我们就将$i$和$j$缩小$d$倍：
$$\sum_{d=1}^nd^k\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{d}\rfloor}[\gcd(i,j)==1]$$

然后莫比乌斯反演（$\sum_{d\mid n}\mu(d)=[n==1]$）：
$$\sum_{d=1}^nd^k\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{d}\rfloor}\sum_{r\mid\gcd(i,j)}\mu(r)$$

由于$r$是$\gcd(i,j)$的因数，因此$r$一定是$i$和$j$的公因数，仿照上面，我们将$i$和$j$缩小$r$倍（顺便改变一下运算顺序）：
$$\sum_{d=1}^nd^k\sum_{k=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{i=1}^{\lfloor\frac{n}{d\cdot r}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{d\cdot r}\rfloor}\mu(r)$$

稍微做一下变形：
$$\sum_{d=1}^n d^k\sum_{k=1}^{\lfloor\frac{n}{d}\rfloor}\mu(k)\cdot\lfloor\frac{n}{d\cdot r}\rfloor\cdot\lfloor\frac{m}{d\cdot r}\rfloor$$

然后我们可以设$t=d\cdot r$（这样我们可以把$d$的枚举变为枚举$t$的因数），然后可以得到：$\sum_{t=1}^n\sum_{d\mid t} d^k\cdot\mu(\frac{t}{d})\cdot\lfloor\frac{n}{t}\rfloor\cdot\lfloor\frac{m}{t}\rfloor$
设$f(x)=\sum_{d\mid x}d^k\cdot\mu(\frac{x}{d})$，则原式化为：
$$\sum_{t=1}^nf(t)\cdot\lfloor\frac{n}{t}\rfloor\cdot\lfloor\frac{m}{t}\rfloor$$

然后我们用整除分块可以做到$O(\sqrt{n})$的时间，于是我们的目标转移到如何线性筛预处理$f$函数：

由两个积性函数（$id_k(x)=x^k$与$\mu(x)$）
的狄利克雷卷积也是一个积性函数，我们可以构造$x$的标准分解$x=\prod_{i=1}^s p_i^{k_i}$得到$f(x)=\prod_{i=1}^s f(p_i^{k_i})$

于是我们转而计算一个质数的幂次方。
由莫比乌斯函数的性质（如果一个数$x$是一个完全平方数的倍数，那么$\mu(x)=0$，这是莫比乌斯函数的定义）可得，当$p\in\mathbb{P},c\in\mathbb{N^+}$则有：
$$f(p^c)=\sum_{d\mid p^c} d^k\cdot\mu(\frac{p^c}{d})=\sum_{d\mid p^c,\frac{p^c}{d}\nmid z^2(z\in\mathbb{N})}d^k\cdot\mu(\frac{p^c}{d})
=(p^{c-1})^k\cdot\mu(p)+(p^c)^k\cdot\mu(1)=p^{c\cdot k}-p^{(c-1)\cdot k}=p^{(c-1)\cdot k}\cdot(p^k-1)$$

因此很显然有：
$$f(p^{c+1})=p^{c\cdot k}\cdot(p^k-1)=p^k\cdot p^{(c-1)\cdot k}\cdot(p^k-1)=f(p^c)\cdot p^k$$

然后我们考虑求$f(p)$，发现
$$f(p)=\sum_{d\mid x}d^k\cdot\mu(\frac{x}{d})=1^k\cdot\mu(p)+p^k\cdot\mu
(1)=p^k-1$$

最后，我们讨论一下如何线性筛（求$f(x\cdot y)$，$x\in\mathbb{N^+}$，$y\in\mathbb{P}$）：

当$y\mid x$时，取$x$中$y$的幂次$c$，则由$f$的积性有
$$f(x\cdot y)=f(\frac{x\cdot y}{y^{c+1}})\cdot f(y^{c+1})$$
由上文求出的$f(p^{c+1})=f(p^c)\cdot p^k$得再用$f$的积性合并得：
$$f(x\cdot y)=f(\frac{x}{y^c})\cdot f(y^c)\cdot y^k=f(\frac{x}{y^c}\cdot y^c)\cdot y^k=f(x)\cdot y^k$$

当$y\nmid x$时，直接由$f$的积性可得
$$f(x\cdot y)=f(x)\cdot f(y)=f(x)\cdot f(y)$$

故线性筛+数论分块即可。

顺便提一下，$k$等于$1$是$f$函数等价于欧拉函数$\varphi$。

代码：
```
#include<stdio.h>
const long long maxn=5000005,mod=1000000007;
long long i,j,k,m,n,T,cnt,l,r,ans;
long long a[maxn],p[maxn],f[maxn],pf[maxn];
inline long long min(long long a,long long b){
	return a<b? a:b;
}
long long ksm(long long a,long long b){
	long long res=1;
	while(b){
		if(b&1)
			res=(res*a)%mod;
		a=(a*a)%mod,b>>=1;
	}
	return res;
}
int main(){
	scanf("%lld%lld",&T,&k);
	p[1]=f[1]=1;
	for(i=2;i<maxn;i++){
		if(p[i]==0)
			a[++cnt]=i,f[i]=(ksm(i,k)-1+mod)%mod;
		for(j=1;j<=cnt;j++){
			if(i*a[j]>=maxn)
				break;
			p[i*a[j]]=1;
			if(i%a[j]==0){
				f[i*a[j]]=f[i]*ksm(a[j],k)%mod;
				break;
			}
			f[i*a[j]]=f[i]*f[a[j]]%mod;
		}
	}
	for(i=1;i<maxn;i++)
		pf[i]=pf[i-1]+f[i];
	while(T--){
		scanf("%lld%lld",&n,&m);
		l=1,ans=0;
		while(l<=min(n,m)){
			r=min(n/(n/l),m/(m/l));
			ans=((ans+(pf[r]-pf[l-1]+mod)%mod*(n/l)%mod*(m/l)%mod)%mod+mod)%mod;
			l=r+1;
		}
		printf("%lld\n",ans);
	}
	return 0;
}
```






---

## 作者：关怀他人 (赞：6)

### 如果$LaTeX$挂了，请在[我的博客](https://www.luogu.com.cn/blog/LCA/solution-p4449)查看

![](https://cdn.luogu.com.cn/upload/image_hosting/zksjujf3.png)
![](https://cdn.luogu.com.cn/upload/image_hosting/8dcudn13.png)
![](https://cdn.luogu.com.cn/upload/image_hosting/l6diwvly.png)
![](https://cdn.luogu.com.cn/upload/image_hosting/pnlm7ukv.png)
```cpp
#include<bits/stdc++.h>
#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>
#include<cstdlib>
using namespace std;
typedef long long ll;

const int INF = 0x3f3f3f3f;
const int MAXN = 5e6 + 5;
const int MOD = 1e9 + 7;

int T,n,m,k,tot;
int p[MAXN],prime[MAXN],f[MAXN],g[MAXN];

namespace ModOperation{
	int add(int x,int y){
		x += y;
		if(x >= MOD)
			x -= MOD;
		return x;
	}
	
	int sub(int x,int y){
		x -= y;
		if(x < 0)
			x += MOD;
		return x;
	}
	
	int mul(int x,int y){
		return 1ll * x * y % MOD;
	}
}

using namespace ModOperation;

int power(int x,int y){
	int res = 1;
	while(y){
		if(y & 1)
			res = mul(res,x);
		x = mul(x,x);
		y >>= 1;
	}
	return res;
}

void Init(int n){
	f[1] = 1;
	for(int i = 2;i <= n;i++){
		if(!prime[i]){
			p[++tot] = i;
			g[i] = power(i,k);
			f[i] = sub(g[i],1);
		}
		for(int j = 1;j <= tot;j++){
			if(i * p[j] > n)
				break;
			prime[i * p[j]] = 1;
			if(i % p[j] == 0){
				f[i * p[j]] = mul(f[i],g[p[j]]);
				break;
			}
			f[i * p[j]] = mul(f[i],f[p[j]]);
		}
	}
	for(int i = 1;i <= n;i++)
		f[i] = add(f[i],f[i - 1]);
}

int main(){
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	scanf("%d%d",&T,&k);
	Init(5000000);
	while(T--){
		scanf("%d%d",&n,&m);
		if(n > m)
			swap(n,m);
		int ans = 0;
		for(int l = 1,r;l <= n;l = r + 1){
			r = min(n / (n / l),m / (m / l));
			ans = add(ans,mul(sub(f[r],f[l - 1]),mul(n / l,m / l)));
		}
		printf("%d\n",ans);
	}
	return 0;
}


```


---

## 作者：GKxx (赞：6)

这个式子这样推更快

设$q(n)=n^k,p=\mu*q,q=p*1$，则

$\sum_{i=1}^n{\sum_{j=1}^m{gcd(i,j)^k}}$

$=\sum_{i=1}^n{\sum_{j=1}^m{q(gcd(i,j))}}$

$=\sum_{i=1}^n{\sum_{j=1}^m{\sum_{d|gcd(i,j)}p(d)}}$

$=\sum_{d=1}^{min(n,m)}{\lfloor\frac{n}d\rfloor}{\lfloor\frac{m}d\rfloor}p(d)$

把卷积展开，就直接得到最终的式子

$=\sum_{d=1}^{min(n,m)}{\lfloor\frac{n}d\rfloor}{\lfloor\frac{m}d\rfloor}\sum_{t|d}{t^k\mu(\frac{d}t)}$

并不需要先化成$[gcd(i,j)=1]$，再套$\mu$，再交换$\sum$，再枚举乘积。。。。。

然后设$g(n)=\sum_{d|n}{d^k\mu(\frac{n}d)}$，线性筛求$g$的前缀和，就可以整除分块了

线性筛的部分另外几篇题解已经说得比较清楚了，就不说了

```cpp
#include <cctype>
#include <cstdio>
#include <climits>
#include <algorithm>

template <typename T> inline void read(T& t) {
    int f = 0, c = getchar(); t = 0;
    while (!isdigit(c)) f |= c == '-', c = getchar();
    while (isdigit(c)) t = t * 10 + c - 48, c = getchar();
    if (f) t = -t;
}
template <typename T> inline bool chkMin(T& x, const T& y) { return y < x ? (x = y, true) : false; }
template <typename T> inline bool chkMax(T& x, const T& y) { return x < y ? (x = y, true) : false; }
#ifdef WIN32
#define LLIO "%I64d"
#else
#define LLIO "%lld"
#endif	// WIN32 long long
#define rep(I, A, B) for (int I = (A); I <= (B); ++I)
#define rrep(I, A, B) for (int I = (A); I >= (B); --I)
#define erep(I, X) for (int I = head[X]; I; I = next[I])

const long long mod = 1000000007;
const int maxn = 5e6 + 207;
int p[maxn], v[maxn];
long long g[maxn], s[maxn];
int tot, K, T;

inline long long quickPow(long long x, long long k) {
    long long s = 1;
    for (; k; x = x * x % mod, k >>= 1)
        if (k & 1) s = s * x % mod;
    return s;
}
inline void EulerSieve(int n) {
    g[1] = 1;
    rep(i, 2, n) {
        if (!v[i]) {
            v[i] = i; p[++tot] = i; g[i] = quickPow(i, K) - 1;
            if (g[i] < 0) g[i] += mod;
        }
        for (int j = 1; j <= tot && p[j] <= v[i] && p[j] * i <= n; ++j) {
            v[p[j] * i] = p[j];
            if (!(i % p[j])) g[p[j] * i] = g[i] * quickPow(p[j], K) % mod;
            else g[p[j] * i] = g[p[j]] * g[i] % mod;
        }
    }
    rep(i, 1, n) s[i] = (s[i - 1] + g[i]) % mod;
}
int main() {
    read(T); read(K);
    EulerSieve(5e6);
    while (T--) {
        int n, m; read(n); read(m);
        long long ans = 0;
        for (int l = 1, r; l <= std::min(n, m); l = r + 1) {
            r = std::min(n / (n / l), m / (m / l));
            ans = (ans + 1ll * (n / l) * (m / l) % mod * ((s[r] - s[l - 1]) % mod + mod) % mod) % mod;
        }
        printf(LLIO "\n", ans);
    }
    return 0;
}
```

---

## 作者：loceaner (赞：5)

## 题意

求

$$\sum_{i=1}^{n}\sum_{j=1}^{m}\gcd(i,j)^k(\bmod 1e9+7)$$

## 思路

还是直接淦式子（你谷似乎不支持那么长的式子……，还是去我[博客](https://www.cnblogs.com/loceaner/p/12795852.html)看吧）

或者自己在这里看图片吧~

![图片](https://cdn.luogu.com.cn/upload/image_hosting/zbvdmbwa.png)

令$P=dx$，则原式等于

$$\sum_{P=1}^{\min(n,m)}\lfloor\frac n{P}\rfloor\lfloor\frac m{P}\rfloor\sum_{d|P}d^k\mu(\frac Pd)$$

显然前面的$\lfloor\frac n{P}\rfloor\lfloor\frac m{P}\rfloor$部分可以分块求解。

现在考虑后面的一部分，令

$$g(n)=\sum_{d|n}d^k\mu(\frac nd)$$

容易得出这个函数是积性函数，所以我们就可以线性筛然后求出其前缀和

然后就做完了

## 代码

```cpp
/*
Author:loceaner
莫比乌斯反演
*/
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#define int long long
using namespace std;

const int A = 5e6 + 11;
const int B = 1e6 + 11;
const int mod = 1e9 + 7;
const int inf = 0x3f3f3f3f;

inline int read() {
	char c = getchar();
	int x = 0, f = 1;
	for( ; !isdigit(c); c = getchar()) if(c == '-') f = -1;
	for( ; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48);
	return x * f;
}

bool vis[A];
int T, n, m, k, f[A], g[A], p[A], cnt, sum[A];

inline int power(int a, int b) {
	int res = 1;
	while (b) {
		if (b & 1) res = res * a % mod;
		a = a * a % mod, b >>= 1;
	}
	return res;
}

inline int mo(int x) {
	if(x > mod) x -= mod;
	return x;
}

inline void work() {
	g[1] = 1;
	int maxn = 5e6 + 1;
	for (int i = 2; i <= maxn; i++) {
		if (!vis[i]) { p[++cnt] = i, f[cnt] = power(i, k), g[i] = mo(f[cnt] - 1 + mod); }
		for (int j = 1; j <= cnt && i * p[j] <= maxn; j++) {
			vis[i * p[j]] = 1;
			if (i % p[j] == 0) { g[i * p[j]] = g[i] * 1ll * f[j] % mod; break; }
			g[i * p[j]] = g[i] * 1ll * g[p[j]] % mod;
		}
	}
	for (int i = 2; i <= maxn; i++) g[i] = (g[i - 1] + g[i]) % mod;
}

inline int abss(int x) {
	while (x < 0) x += mod;
	return x;
}

signed main() {
	T = read(), k = read();
	work();
	while (T--) {
		n = read(), m = read();
		int maxn = min(n, m), ans = 0;
		for (int l = 1, r; l <= maxn; l = r + 1) {
			r = min(n / (n / l), m / (m / l));
			(ans += abss(g[r] - g[l - 1]) * 1ll * (n / l) % mod * (m / l) % mod) %= mod;
		}
		ans = (ans % mod + mod) % mod;
		cout << ans << '\n';
	}
	return 0;
}
```





---

## 作者：pomelo_nene (赞：4)

## P4449 于神之怒加强版

求：

$$\sum_{i=1}^n \sum_{j=1}^m \gcd (i,j)^k$$

假设 $n<m$。

$$\sum_{d=1}^n \sum_{i=1}^n \sum_{j=1}^m d^k \times [\gcd(i,j)=d]$$

$$\sum_{d=1}^n \sum_{i=1}^{\lfloor \frac{n}{d}\rfloor} \sum_{j=1}^{\lfloor \frac{m}{d} \rfloor} d^k\times [\gcd(i,j)=1]$$

$$\sum_{d=1}^n d^k\sum_{i=1}^{\lfloor\frac{n}{d} \rfloor} \sum_{j=1}^{\lfloor\frac{m}{d}\rfloor} \sum_{D|i,D|j}\mu(D) $$

$$\sum_{d=1}^n d^k\sum_{D=1}^{\lfloor \frac{n}{d}\rfloor} \mu(D)\sum_{i=1}^{\lfloor\frac{n}{dD}\rfloor} \sum_{j=1}^{\lfloor\frac{m}{dD}\rfloor}1$$

$$\sum_{d=1}^n d^k\sum_{D=1}^{\lfloor \frac{n}{d} \rfloor} \mu(D)\lfloor \frac{n}{dD}\rfloor \lfloor \frac{m}{dD} \rfloor$$

令 $dD=T$。

$$\sum_{d=1}^n d^k \sum_{D=1}^{\frac{n}{d}}\mu(D)\lfloor \frac{n}{T}\rfloor \lfloor \frac{m}{T} \rfloor$$

$$\sum_{d=1}^n \lfloor \frac{n}{T}\rfloor \lfloor \frac{m}{T} \rfloor \sum_{d|T}d^k\mu(\frac{T}{d})$$

设 $f(T)=\sum_{d|T}d^k\mu(\frac{T}{d})$，易证 $f(T)$ 为积性函数，线性筛处理其前缀和即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
const LL MOD=1000000007;
LL f[5000005],gk[5000005],prime[5000005],cnt,T,k;
bool vis[5000005];
LL QuickPow(LL a,LL x)
{
	LL ans=1,base=a;
	while(x)
	{
		if(x&1)	ans*=base,ans%=MOD;
		base*=base;
		base%=MOD;
		x>>=1;
	}
	return ans;
}
void shai(LL upper)
{
	f[1]=1;
	for(LL i=2;i<=upper;++i)
	{
		if(!vis[i])	prime[++cnt]=i,gk[i]=QuickPow(i,k),f[i]=(gk[i]-1+MOD)%MOD;
		for(LL j=1;j<=cnt && prime[j]*i<=upper;++j)
		{
			vis[prime[j]*i]=true;
			if(i%prime[j])	f[i*prime[j]]=f[i]*f[prime[j]]%MOD;
			else
			{
				f[i*prime[j]]=f[i]*gk[prime[j]]%MOD;
				break;
			}
		}
	}
	for(LL i=2;i<=upper;++i)	f[i]+=f[i-1],f[i]%=MOD;
}
int main(){
	scanf("%lld %lld",&T,&k);
	shai(5000000);
	while(T-->0)
	{
		LL n,m;
		scanf("%lld %lld",&n,&m);
		if(n>m)	n^=m^=n^=m;
		LL ans=0;
		for(LL l=1,r;l<=n;l=r+1)
		{
			r=min(n/(n/l),m/(m/l));
			ans+=((f[r]-f[l-1])%MOD+MOD)%MOD*(n/l)%MOD*(m/l)%MOD;
			ans%=MOD;
		}
		printf("%lld\n",ans);
	}
	return 0;
}
```

$\ \ $

---

## 作者：青灯夜游 (赞：3)

# P4449 于神之怒加强版[莫比乌斯反演]

题意:	给定i,j,k

求
$$\sum_{i=1}^n\sum_{j=1}^m gcd^k(i,j)$$

## $ solution:$

一步一步推式子,

我们利用莫比乌斯反演,设

$$f(n) = n^k$$

$$f(n) = \sum_{d|n} g(d)$$

$$g(n) = \sum_{d|n} f(d)  \mu(\frac{n}{d})$$

化简原式

$$\sum_{i=1}^n\sum_{j=1}^m gcd^k(i,j) $$

$$=\sum_{i=1}^n\sum_{j=1}^m f(gcd(i,j))$$

$$=\sum_{i=1}^n\sum_{j=1}^m\sum_{d|gcd(i,j)} g(d)$$

由于

$$d|gcd(i,j) \Leftrightarrow d|i,d|j$$

所以$d$必须是$i,j$的约数

于是我们想到换个思路,枚举$i,j$的约数,然后考虑约数的贡献

所以我们改变枚举顺序,将$d$提到前面来(细节:由于 $d$ 为 $i,j$ 的公共约数,故d最大为$min(n,m)$

$$\sum_{d=1}^{min(n,m)}\sum_{d|i}^n\sum_{d|j}^m g(d)$$

$$=\sum_{d=1}^{min(n,m)} \lfloor{\frac{n}{d}}\rfloor \lfloor{\frac{m}{d}}\rfloor  g(d)$$

于是我们只需枚举d便可以统计出所有答案,复杂度为$O(n)$

考虑 $ \lfloor\frac{n}{d}\rfloor \lfloor \frac{m}{d}\rfloor $  可以用数论分块处理,再预处理一下$g$函数的前缀和,复杂度降为$O(\sqrt{n})$

那么麻烦来了,我们如何快速计算出g函数

本题数据范围为$5e6$,$O(nloglogn)$是过不了的     (事实上,$O(nloglogn)$最大能承受的数据案范围大致为$1e6$)

所以我们的解决办法就是线性筛

由于 $g = f * \mu$ , $f$ 和 $\mu$都为积性函数,故$g$也为积性函数

考虑线性筛的过程

当 $pri[j]$ 不为 $i$ 的因子时, $ pri[j] $ 与 $ i $ 互质,可得 $ g[pri[j] * i] = g[pri[j]] * g[i] $

当 $ pri[j] | i $ 时 , 根据线性筛的原理我们可以得出 , $ pri[j] $ 一定是 $ i $ 的最小质因子 . 我们分

两种情况讨论 , 分类讨论的原因下面会讲 $($ 此处设 $ low[i]  = p_1^{a_1}$ , $ p_1 $ 为i的最小质因子 $)$

$ 1.  low[i] != i $

我们把 $i$ 的最小质因子全部移到 $pri[j]$ 上去 , 这样 $ i $ 中剩下的就没有 $ pri[j] $ 的因子了,

所以两者互质 , 即  
$$g[pri[j] * i] = g[\frac{i}{low[i]}] * g[low[i] * pri[j]]$$

$ 2. low[i] == i $

换句话说 , 此时的 $ i $ 为 $ pri[j] $ 的幂 . 对于这种情况 , 我们为什么不能像上面那样求呢?

如果按照上面的步骤 , 我们会发现一个很尴尬的式子 $ g[p^k] = g[p^k] * g[1] $

$ g[1] $ 显然是为 $ 1 $ 的 , 右边的 $ g[p^k] $ 是我们需要的条件 , 而他刚好又是我们要求的值.

所以我们不能按照上面的方法求

 对于质数幂的积性函数 , 手推一下可以发现下面这个式子(只有质数的幂才可以这样推!)

$$g[p^k] = g[p^{k-1}] * f[p] + f[1] * \mu[p^k] (g = \mu * f)$$

回到题目中来,式子即变成

$$g[pri[j] * i] = g[i] * f[pri[j]] + f[1] * \mu[pri[j] * i]$$

然后我们的问题就圆满解决了

细节 :

注意每次 $ i $ 筛到一个质数时 , $ g[i] $ 都要更新为$ f[1] * \mu[i] + f[i] * mu[1] $ , 同时 $ low[i] = i $

$ i $ 与 $ pri[j] $ 互质的时候 , 更新 $ low $ , $ low[i * pri[j]] = pri[j] $

$ g $ 也要更新 , $ g[i * pri[j]] = g[i] * g[pri[j]] $

下面上代码


```cpp
// luogu-judger-enable-o2
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#define ll long long
#pragma GCC optimize(2)

using namespace std;

inline int read() {
    int res = 0 , flag = 1; char ch = getchar();
    while(!isdigit(ch)) { if(ch == '-') flag = -1; ch = getchar(); }
    while(isdigit(ch)) { res = (res << 3) + (res << 1) + ch - '0'; ch = getchar(); }
    return res * flag;
}

const int N=5e6;
const int mod=1000000007;

int mu[N+5],prime[N+5],ncnt;
ll k;
ll f[N+5],low[N+5];
ll g[N+5];
ll sum[N+5];
bool vis[N+5];

inline ll pow(ll a,ll b) {
    ll ret = 1;
    while(b) {
        if(b & 1) (ret *= a) %= mod;
        (a *= a) %= mod;
        b >>= 1;
    }
    return ret;
}

inline void Mobius() {
    mu[1] = 1;
    g[1] = 1;//积性函数g[1] == 1!!!!!!!!!!!!!
    
    for(register ll i = 1 ; i <= N ; ++ i) f[i] = pow(i,k);// , printf("%lld\n",f[i]);
    
    for(register int i = 2 ; i <= N ; ++ i) {
        if(!vis[i]) {
            prime[++ncnt] = i;
            low[i] = i;
            mu[i] = -1;
            g[i] = (f[i] - 1) % mod;
        }
        for(register int j = 1 ; j <= ncnt and i * prime[j] <= N ; ++ j) {
            vis[i * prime[j]] = 1;//筛掉//每次由最小的累积
            if(i % prime[j] == 0) {
//				mu[i * prime[j]] = 0;
                low[i * prime[j]] = low[i] * prime[j];
                
                if(low[i] == i) {//i为素数的幂形式
                    g[i * prime[j]] = (g[i] * f[prime[j]]) % mod;// + f[1] * mu[i * prime[j]]
                }
                else {
                    g[i * prime[j]] = (g[i / low[i]] * g[low[i] * prime[j]]) % mod;
                }
                break;
            }
            else {
                g[i * prime[j]] = (g[i] * g[prime[j]]) % mod;
                low[i * prime[j]] = prime[j];
                mu[i * prime[j]] = -mu[i];
            }
        }
    }
    
    for(register int i = 1 ; i <= N ; ++ i) sum[i] = (sum[i-1] + g[i]) % mod;
//	for(register int i = 1 ; i <= N ; ++ i) printf("%lld\n",sum[i]);
}

inline int min(int a , int b) {
    return a < b ? a : b;
}

inline ll work(int n,int m) {
    ll ans = 0;
    for(register int d = 1 , t; d <= min(n,m) ; d = t + 1) {
        t = min(n / (n/d) , m / (m/d));
        ans = (ans + 1ll * (n / d) * (m / d) % mod * ((sum[t] - sum[d - 1]) % mod + mod) % mod) % mod;
    }
    return ans;
}

int main() {
//	freopen("god.in","r",stdin);
//	freopen("god.out","w",stdout);

    int test = read(); k = read();
    Mobius();

    while(test --) {
        int n = read() , m = read();
        printf("%lld\n",work(n,m));
    }
    return 0;
}
```

end

------

## 莫比乌斯反演套路总结

用莫比乌斯反演优化算法的题目一般都涉及到 $ gcd $

优化的原理和关键是 $ d | gcd(i , j) \Leftrightarrow  d | i , d | j$ , 然后枚举约数 $ d $ 算贡献于是我们将 $ O(n^2) $ 枚举降为了

$ O(n) $ 枚举, 简化后式子中的 $ \lfloor \frac{n}{d} \rfloor * \lfloor \frac{m}{d} \rfloor $ 也可以用数论分块优化 , 复杂度再降为 $ O(\sqrt{n}) $

而运用莫比乌斯反演的关键是将题目中的式子化成如下形式

$$\sum_{i=1}^n\sum_{j=1}^m f(gcd(i,j))$$

然后就可以运用上述套路了

线性筛常见数论函数及自定义积性函数也是莫比乌斯反演可以考的一个板块

~~然而我还不会筛数论函数~~

以后有时间再写一篇这方面的博客

---

## 作者：kradcigam (赞：2)

# 前置知识
- [莫比乌斯反演](https://blog.csdn.net/qq_46230164/article/details/105877706)
- [数论分块](https://blog.csdn.net/qq_46230164/article/details/105934495)

式子还是正常的推

首先，$ID_k(x)=x^k$

$$\sum_{i=1}^{n} \sum_{j=1}^{m} ID_k(gcd(i,j))$$

$$\sum_{d=1} ID_k(d)\sum_{i=1}^{n} \sum_{j=1}^{m} [\gcd(i,j) =d]$$

$$\sum_{d=1} ID_k(d)\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{d}\rfloor} [\gcd(i,j) =1]$$

$$\sum_{d=1} ID_k(d)\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{d}\rfloor} \sum_{D\mid \gcd(i,j)} \mu(D)$$

$$\sum_{d=1}  ID_k(d)\sum_{D=1}^{\min(n,m)}\mu(D)\sum_{i=1}^{\lfloor\frac{n}{dD}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{dD}\rfloor} 1$$

$$\sum_{d=1}  ID_k(d)\sum_{D=1}^{\lfloor \frac{n}{d}\rfloor}\mu(D)\lfloor \frac{n}{dD} \rfloor \lfloor \frac{m}{dD} \rfloor$$

设 $T=dD$
$$\sum_{T=1}\lfloor \frac{n}{T} \rfloor \lfloor \frac{m}{T} \rfloor \sum_{d|T} ID_k(d) \mu(\frac{T}{d})$$
我们发现后面这个东西就是狄利克雷卷积

我们管它叫 $f$ 函数

也就是说

$$f=ID_k*\mu$$

由于积性函数卷积性函数还是积性函数

对于 $x\in prime$ $f(x)=x^k-1$ 

这样子就直接在线性筛的时候算一下就好了

代码：

```cpp
void sieve(){
    f[1]=1;
    for(int i=2;i<MAXN;i++){
        if(!vis[i]){
            prime[++prime[0]]=i;
            f[i]=(pw(i,k)-1+Mod)%Mod;
        }
        for(int j=1;j<=prime[0]&&i*prime[j]<MAXN;j++){
            vis[i*prime[j]]=true;
            if(i%prime[j]==0){f[i*prime[j]]=f[i]*(f[prime[j]]+1)%Mod;break;}
            f[i*prime[j]]=f[i]*f[prime[j]]%Mod;
        }
    }
    for(int i=1;i<MAXN;i++)s[i]=(s[i-1]+f[i])%Mod;
}
```










---

## 作者：teafrogsf (赞：2)

~~被YMY先看到了这道题不开心。~~  

### 蒟蒻怒交BZOJRE代码，然后发现自己以前写数论题都打的啥~~还交了7遍~~......  
关于推式子这方面的东西仍然被楼下抢了~~而且大家套路怎么都一模一样~~，我这里只是说一下那个$N_k$应该是没有必要算的，因为你只会利用到它下标为质数的部分。~~以及一份在数学题里面基本上没有什么卵用的参考代码~~  
~~然后因为没卡常数并且全程$\rm long\ long$的原因速度比楼下低到不知道哪里去了。~~  
$\rm int+1ll\vert(long\ long)$这种操作还是蛮好用的，尤其是在比赛的评测环境下可以跑得很快。大家可以学习一个~~虽然我没写~~。
```cpp
#include<cstdio>
#define neko 5500010
#define chkmin(a,b) ((a)<(b)?(a):(b))
#define f(i,a,b) for(register int i=(a);i<=(b);i=-(~(i)))
typedef long long ll;
static ll n,m,k,ans,mod=1e9+7;
static int cas;
typedef long long arr[neko];
static arr isnprime,prime,F,sumF,Pow;
template<typename T>
void swap(T &a,T &b){T t=a;a=b,b=t;}
static ll slowpow(ll m,ll n)
{
    ll b=1;
    for(;n;n>>=1,m=m*m%mod)if(n&1)b=b*m%mod;
    return b;   
}
inline void sieve()
{
    F[1]=1,Pow[1]=1;
    f(i,2,5000010)
    {
        if(!isnprime[i])prime[++prime[0]]=i,F[i]=slowpow(i,k)-1,Pow[i]=F[i]+1;
        for(register int j=1;j<=prime[0]&&prime[j]*i<=5000010;j++)
        {
            isnprime[i*prime[j]]=1;
           // Pow[i*prime[j]]=Pow[i]*Pow[prime[j]]%mod;
            if(i%prime[j]==0){F[i*prime[j]]=F[i]*Pow[prime[j]]%mod;break;}
            F[i*prime[j]]=F[i]*F[prime[j]]%mod;
        }
    }f(i,1,5000010)sumF[i]=sumF[i-1]+F[i],sumF[i]%=mod;
}
int main()
{
    int j;
    scanf("%d%lld",&cas,&k);
    sieve();
    while(cas--)
    {
        scanf("%lld%lld",&n,&m);
        ans=0;
        if(n>m)swap(n,m);
        for(register int i=1;i<=n;i=j+1)
        {
            j=chkmin(n/(n/i),m/(m/i));
            ans=(ans+(n/i)*(m/i)%mod*(sumF[j]-sumF[i-1])%mod)%mod;
        }printf("%lld\n",(ans+mod)%mod);
    }return 0;
}
```

---

## 作者：木xx木大 (赞：1)

[P4449 于神之怒加强版](https://www.luogu.com.cn/problem/P4449)

$$
\begin{aligned}&\sum\limits_{i=1}^n\sum\limits_{j=1}^m\gcd(i,j)^k\\=&\sum\limits_{i=1}^n\sum\limits_{j=1}^m\sum\limits_{d=1}^{\min(n,m)}[\gcd(i,j)=d]d^k\\=&\sum\limits_{d=1}^{\min(n,m)}\sum\limits_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum\limits_{j=1}^{\lfloor\frac{m}{d}\rfloor}[\gcd(i,j)=1]d^k\\=&\sum\limits_{d=1}^{\min(n,m)}d^k\sum\limits_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum\limits_{j=1}^{\lfloor\frac{m}{d}\rfloor}\sum\limits_{x|i,x|j}\mu(x)\\=&\sum\limits_{d=1}^{\min(n,m)}d^k\sum\limits_{x=1}^{(\min\lfloor\frac{n}{d}\rfloor,\lfloor\frac{m}{d}\rfloor)}\sum\limits_{i=1}^{\lfloor\frac{n}{xd}\rfloor}\sum\limits_{j=1}^{\lfloor\frac{m}{xd}\rfloor}\mu(x)\\=&\sum\limits_{d=1}^{\min(n,m)}d^k\sum\limits_{x=1}^{(\min\lfloor\frac{n}{d}\rfloor,\lfloor\frac{m}{d}\rfloor)}\mu(x){\lfloor\frac{n}{xd}\rfloor}\lfloor\frac{m}{xd}\rfloor\\=&\sum\limits_{T=1}^{\min(n,m)}{\lfloor\frac{n}{T}\rfloor}\lfloor\frac{m}{T}\rfloor\sum\limits_{d|T}d^k\mu(\frac{T}{d})\end{aligned}
$$

设 $g(n)=\sum\limits_{d|n}d^k\mu(\frac{n}{d})$，即 $g=Id_k*\mu$，$g$ 是积性函数，可以线性筛。设 $p$ 为一个质数，则有
$$
g(n)=n^k-(\frac{n}{p})^k=p^{ik}-p^{ik-k} \quad(n=p^i)\\g(p^{i+1})=p^{ik+k}-p^{ik}=p^kg(p^i)
$$
前半部分直接数论分块。那么总复杂度为 $O(n+T\sqrt{n})$。

~~菜鸡感觉这题难点不在莫反而在线性筛EE~~

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
namespace FGF
{
	int n,m,K;
	const int N=5e6+5,mo=1e9+7;
	int g[N],p[N],vis[N],cnt,pw[N];
	int qpow(int x,int y)
	{
		int s=1;
		while(y)
		{
			if(y&1)s=1ll*s*x%mo;
			x=1ll*x*x%mo;
			y>>=1;
		}
		return s;
	}
	void init()
	{
		g[1]=1;
		for(int i=2;i<=5e6;i++)
		{
			if(!vis[i])pw[i]=qpow(i,K),g[i]=(pw[i]-1+mo)%mo,p[++cnt]=i;
			for(int j=1;j<=cnt&&p[j]*i<=5e6;j++)
			{
				vis[p[j]*i]=1;
				if(i%p[j]==0){g[i*p[j]]=1ll*g[i]*pw[p[j]]%mo;break;}
				g[i*p[j]]=1ll*g[i]*g[p[j]]%mo;
			}
		}
		for(int i=2;i<=5e6;i++)
			g[i]=(g[i-1]+g[i])%mo;
	}
	void work()
	{
		int t;
		scanf("%d%d",&t,&K);
		init(); 
		while(t--)
		{
			scanf("%d%d",&n,&m);
			ll ans=0;
			for(int l=1,r;l<=min(n,m);l=r+1)
				r=min(n/(n/l),m/(m/l)),ans=(ans+1ll*(g[r]-g[l-1]+mo)%mo*(n/l)%mo*(m/l)%mo)%mo;
			printf("%lld\n",ans);
		}
	}
}
int main()
{
	FGF::work();
	return 0;
}
```

---

## 作者：Warriors_Cat (赞：1)

若公式渲染有问题请跳转到[这里](https://www.luogu.com.cn/blog/WarriorsCatxcy/solution-p4449)食用。

个人感觉是一道比较基础的莫比乌斯反演题？

### $Solution:$

莫比乌斯反演还是要推式子，以下默认 $n \le m$。

$$\begin{aligned}\text{原式}&=\sum_{i=1}^n\sum_{j=1}^m\sum_{d=1}^n d^k[\gcd(i, j)=d]\\&=\sum_{d=1}^nd^k\sum_{i=1}^{\left\lfloor \frac{n}{d} \right\rfloor}\sum_{j=1}^{\left\lfloor \frac{m}{d} \right\rfloor}[\gcd(i, j)=1]\\&=\sum_{d=1}^nd^k\sum_{i=1}^{\left\lfloor \frac{n}{d} \right\rfloor}\sum_{j=1}^{\left\lfloor \frac{m}{d} \right\rfloor}\sum_{p\mid\gcd(i, j)}\mu(p)\\&=\sum_{d=1}^nd^k\sum_{p=1}^{\left\lfloor \frac{n}{d} \right\rfloor}\mu(p)\left\lfloor \frac{n}{pd} \right\rfloor\left\lfloor \frac{m}{pd} \right\rfloor\end{aligned}$$

套路地令 $T=pd$，交换求和顺序可得：

$$\begin{aligned}\text{原式}&=\sum_{T=1}^n\sum_{d\mid T}\mu(d)\left(\dfrac{T}{d}\right)^k\left\lfloor \frac{n}{T} \right\rfloor\left\lfloor \frac{m}{T} \right\rfloor\end{aligned}$$

接下来的瓶颈就是如何线性筛 $f(n)=\sum_{d\mid n}\mu(d)\left(\dfrac{n}{d}\right)^k$。

其实这很简单，还是像普通的线性筛，考虑 $n \in \mathbb{P}$，$p^2\mid n$，$p^2\nmid n$ 三种情况，这里 $p \in \mathbb{P}$。

$i. n \in \mathbb{P}$，那么 $f(n) = \mu(1)\cdot n^k+\mu(n)\cdot 1^k=n^k-1$。

$ii.p^2 \mid n$，那么 $n$ 就含有两个及以上个 $p$，此时若 $p^2\mid d$，那么 $\mu(d)\left(\dfrac{n}{d}\right)^k=0$。于是只需要考虑 $p^2\nmid d$ 的贡献即可。很显然这些贡献跟 $f(\frac{n}{p})$ 差不多。不过要注意 $f(n)$ 比 $f(\frac{n}{p})$ 在 $\left(\dfrac{n}{d}\right)^k$ 上还多了个 $p^k$。于是 $f(n) = f(\frac{n}{p})\cdot p^k$。

$iii. p^2 \nmid n$，这个好办，由于 $f(n)$ 显然是一个积性函数，所以 $f(n) = f(\frac{n}{p})\cdot f(p)$。

综上，$f(n)$ 的筛法如下：

$$f(n)=\begin{cases}n^k-1&n \in \mathbb{P}\\ f(\frac{n}{p})\cdot p^k&p^2 \mid n, p \in \mathbb{P} \\ f(\frac{n}{p})\cdot f(p)&p^2 \nmid n, p \in \mathbb{P}\end{cases}$$

最后预处理 $f(n)$ 前缀和，套一个数论分块就好了。时间复杂度为 $O(N\log k + T\sqrt{N})$。

### $Code:$

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;
#define int long long
inline int read(){
	int x = 0, f = 1; char ch = getchar();
	while(ch < '0' || ch > '9'){ if(ch == '-') f = -1; ch = getchar(); }
	while(ch >= '0' && ch <= '9'){ x = x * 10 + (ch ^ 48); ch = getchar(); }
	return x * f;
}
const int N = 5000000, mod = 1000000007;
int t, k, n, m, pri[N + 10], f[N + 10], len; bool vis[N + 10];
inline int fpow(int n, int p){ int ans = 1; for(; p; p >>= 1, n = n * n % mod) if(p & 1) ans = ans * n % mod; return ans; }
inline void sieve(){
	f[1] = 1;
	for(int i = 2; i <= N; ++i){
		if(!vis[i]) pri[++len] = i, f[i] = (fpow(i, k) - 1 + mod) % mod;
		for(int j = 1; j <= len && i * pri[j] <= N; ++j){
			int p = i * pri[j]; vis[p] = 1;
			if(i % pri[j] == 0){ f[p] = f[i] * fpow(pri[j], k) % mod; break; }
			f[p] = f[i] * f[pri[j]] % mod;
		}
	}
	for(int i = 1; i <= N; ++i) f[i] = (f[i - 1] + f[i]) % mod;
}//线性筛
inline int solve(int n, int m){
	if(n > m) n ^= m ^= n ^= m; int ans = 0;
	for(int i = 1, j; i <= n; i = j + 1){
		j = min(n / (n / i), m / (m / i));
		ans = (ans + (f[j] - f[i - 1] + mod) % mod * (n / i) % mod * (m / i) % mod) % mod;
	}
	return ans;
}//数论分块模板
inline void work(){
	n = read(); m = read();
	printf("%lld\n", solve(n, m));
}
signed main(){
	t = read(); k = read(); sieve();
	while(t--) work();
	return 0;
}
```

---

## 作者：Genius_Star (赞：0)

**一个唯一一篇用杜教筛的题解。**

### 题意：

求：

$$\sum_{i=1}^n \sum_{j=1}^m  \gcd(i,j)^k$$

### 思路：

直接推式子：


$$\begin{aligned}\sum_{i=1}^n \sum_{j=1}^m  \gcd(i,j)^k&=\sum_{t=1}^n \sum_{i=1}^n \sum_{j=1}^m [\gcd(i,j)=t] t^k\\&=\sum_{t=1}^n \sum_{i=1}^{\lfloor \frac{n}{t} \rfloor} \sum_{j=1}^{\lfloor \frac{m}{t} \rfloor} [\gcd(i,j)=1] t^k \\&=\sum_{t=1}^n \sum_{i=1}^{\lfloor \frac{n}{t} \rfloor} \sum_{j=1}^{\lfloor \frac{m}{t} \rfloor} \sum_{d|\gcd(i,j)} \mu(d) \times t^k \\ &= \sum_{t=1}^n \sum_{i=1}^{\lfloor \frac{n}{t} \rfloor} \sum_{j=1}^{\lfloor \frac{m}{t} \rfloor} \sum_{d=1}^{\lfloor \frac{n}{t} \rfloor} [d|i][d|j]\mu(d) \times t^k \\&=\sum_{t=1}^n t^k \sum_{d=1}^{\lfloor \frac{n}{t} \rfloor} \mu(d) \sum_{i=1}^{\lfloor \frac{n}{t} \rfloor}[d|i] \sum_{j=1}^{\lfloor \frac{m}{t} \rfloor} [d|j] \\ &=\sum_{t=1}^n t^k \sum_{d=1}^{\lfloor \frac{n}{t} \rfloor} \mu(d) \times \lfloor \frac{n}{t \times d} \rfloor \times \lfloor \frac{m}{t \times d} \rfloor \end{aligned}$$

老套路，令 $T = t \times d$，原式化为：

$$\sum_{T=1}^n \lfloor \frac{n}{T} \rfloor \times \lfloor \frac{m}{T} \rfloor \sum_{t|T} t^k \times \mu(\frac{T}{k})$$

定义 $k(x)=x^k$，则：

$$\sum_{t|T} t^k \times \mu(\frac{T}{k})=(k \times \mu)(T)=\sum_{t|T} k(t) \times \mu(\frac{T}{k})$$

我们需要计算 $(k \times \mu)$ 的前缀和，考虑杜教筛。

因为 $\mu \times 1 = \varepsilon$，则 $k \times \mu \times 1=k \times \varepsilon$，所以套入杜教筛板子：

$$s(n) = \sum_{i=1}^n(k \times \varepsilon)(i)  - \sum_{i=2}^n s(\lfloor \frac{n}{i} \rfloor)$$

因为：

$$(k \times \varepsilon)(i)=\sum_{d|i}\varepsilon(d) \times k(\frac{i}{d})=k(i)$$

所以：

$$s(n)=\sum_{i=1}^n k(i)  - \sum_{i=2}^n s(\lfloor \frac{n}{i} \rfloor)$$

预处理一下 $k$ 的前缀和后即可计算。

杜教筛时只需要预处理 $10^5$ 以内 $(k \times \mu)$ 的前缀和即可，复杂度玄学，懒得证明了。

### 完整代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N=5e6+10,K=1e5+10,mod=1e9+7;
inline ll read(){
    ll x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')
          f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=(x<<1)+(x<<3)+(c^48);
        c=getchar();
    }
    return x*f;
}
inline void write(ll x){
	if(x<0){
		putchar('-');
		x=-x;
	}
	if(x>9)
	  write(x/10);
	putchar(x%10+'0');
}
ll T,n,m,k,cnt=0; 
ll S[N],A[N],P[N],M[N];
bool f[N];
ll qpow(ll a,ll b){
	ll ans=1;
	while(b){
		if(b&1ll)
		  ans=(ans*a)%mod;
		a=(a*a)%mod;
		b>>=1ll;
	}
	return ans;
}
void init(){
	M[1]=1;
    for(int i=2;i<N;i++){
        if(!f[i]){
			M[i]=-1;
			P[++cnt]=i;
		}
        for(ll j=1;j<=cnt&&i*P[j]<N;j++){
            f[i*P[j]]=1;
            if(i%P[j]==0)
			  break;
            else 
			  M[i*P[j]]=-M[i];
        }
    }
	for(int i=1;i<N;i++)
	  S[i]=qpow(i,k);
	for(ll i=1;i<K;i++){
		if(!M[i])
		  continue;
		for(ll j=i;j<K;j+=i)
		  A[j]=(A[j]+M[i]*S[j/i]+mod)%mod;
	}
	for(int i=2;i<N;i++)
	  S[i]=(S[i]+S[i-1])%mod;
	for(int i=2;i<K;i++)
	  A[i]=(A[i]+A[i-1])%mod;
}
ll H(ll n){
	if(A[n])
	  return A[n];
	ll ans=S[n],l,r;
	for(l=2;l<=n;l=r+1){
		r=n/(n/l);
		ans=(ans-((r-l+1)*H(n/l))%mod+mod)%mod;
	}
	A[n]=ans;
	return ans;
}
ll solve(ll n,ll m){
	ll ans=0,l,r;
	if(n>m)
	  swap(n,m);
	for(l=1;l<=n;l=r+1){
		r=min(n/(n/l),m/(m/l));
		ans=(ans+((((n/l)*(m/l))%mod)*((H(r)-H(l-1)+mod)%mod))%mod)%mod;
	}
	return ans;
}
int main(){
	T=read(),k=read();
	init();
	while(T--){
		n=read(),m=read();
		write(solve(n,m));
		putchar('\n');
	}
	return 0;
}
```


---

## 作者：Great_Influence (赞：0)

推半天式子才发现开了8s...

不管他，直接上过程。

$\sum\limits_{i=1}^n\sum\limits_{j=1}^m(i,j)^k$

$=\sum\limits_{d=1}^n d^k\sum\limits_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum\limits_{j=1}^{\lfloor\frac{m}{d}\rfloor}[(i,j)==1]$

$=\sum\limits_{d=1}^n d^k\sum\limits_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum\limits_{j=1}^{\lfloor\frac{m}{d}\rfloor}\sum\limits_{D|i,j}\mu(D)$

$=\sum\limits_{d=1}^n d^k\sum\limits_{D=1}^{\lfloor\frac{n}{d}\rfloor}\mu(D)\lfloor\frac{n}{dD}\rfloor\lfloor\frac{m}{dD}\rfloor$

$=\sum\limits_{t=1}^n\lfloor\frac{n}{t}\rfloor\lfloor\frac{m}{t}\rfloor\sum\limits_{d|t} d^k\mu(\frac{t}{d})$

设$f(n)=\sum\limits_{d|n} d^k\mu(\frac{n}{d})$ ，$N_k(n)=n^k$，则

$ans=\sum\limits_{t=1}^nf(t)\lfloor\frac{n}{t}\rfloor\lfloor\frac{m}{t}\rfloor$

发现$f$为积性函数。

筛法：

$f(p)=p^k-1$

$f(p^q)=f(p^{q-1})N_k(p)$

发现$N_k$是完全积性函数。

一并计算即可。

时间复杂度$O(nlog_2n+q\sqrt n)$。

---

## 作者：水库中的水库 (赞：0)

给定 $n,m,k$ 求解 $\sum_{i=1}^n\sum_{j=1}^mgcd(i,j)^k$

推一波式子

$$\begin{aligned}&\sum_{i=1}^n\sum_{j=1}^mgcd(i,j)^k\\=&\sum_{d=1}^{\min(n,m)}d^k\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{n}{d}\rfloor}[gcd(i,j)=1]\\=&\sum_{d=1}^{\min(n,m)}d^k\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{p|gcd(i,j)}\mu(p)\\=&\sum_{d=1}^{\min(n,m)}d^k\sum_{p=1}^{\min(\lfloor\frac{n}{d}\rfloor,\lfloor\frac{m}{d}\rfloor)}\mu(p)\sum_{i|p}\sum_{j|p}1\\=&\sum_{d=1}^{\min(n,m)}d^k\sum_{p=1}^{\min(\lfloor\frac{n}{d}\rfloor,\lfloor\frac{m}{d}\rfloor)}\mu(p)\lfloor\frac{n}{dp}\rfloor\lfloor\frac{m}{dp}\rfloor\\=&\sum_{t=1}^{\min(n,m)}\lfloor\frac{n}{t}\rfloor\lfloor\frac{m}{t}\rfloor\sum_{d|t}d^k\mu(\frac{t}{d})\end{aligned}$$

我们可以对 $\lfloor\frac{n}{t}\rfloor$ 和 $\lfloor\frac{m}{t}\rfloor$ 进行分块求解

定义 $f(n)=\sum_{d|n}d^k\mu(\frac{n}{d})$ ，于是我们只需要线性筛求出 $f(n)$ 的前缀和即可

```c++
/***************************************************************
	File name: P4449.cpp
	Author: ljfcnyali
	Create time: 2019年09月06日 星期五 21时28分26秒
***************************************************************/
#include<bits/stdc++.h>

using namespace std;

#define REP(i, a, b) for ( int i = (a), _end_ = (b); i <= _end_; ++ i ) 
#define mem(a) memset ( (a), 0, sizeof ( a ) ) 
#define str(a) strlen ( a ) 
#define int long long
typedef long long LL;

const int Mod = 1000000007;
const int maxn = 10000010;

int Max = 5000000, n, m, T, k;
int g[maxn], f[maxn], prime[maxn], tot;
bool vis[maxn];

inline int power(int a, int b)
{
    int r = 1;
    while ( b ) { if ( b & 1 ) r = (r * a) % Mod; a = (a * a) % Mod; b >>= 1; }
    return r;
}

signed main()
{
#ifndef ONLINE_JUDGE
    freopen("input.txt", "r", stdin);
    freopen("output.txt", "w", stdout);
#endif
    scanf("%lld%lld", &T, &k);
    f[1] = 1;
    REP(i, 2, Max)
    {
        if ( !vis[i] ) { prime[++ tot] = i; g[i] = power(i, k); f[i] = (g[i] - 1 + Mod) % Mod; }
        for ( int j = 1; j <= tot && i * prime[j] <= Max; ++ j )
        {
            vis[i * prime[j]] = true;
            if ( i % prime[j] == 0 ) { f[i * prime[j]] = f[i] * g[prime[j]] % Mod; break ; }
            f[i * prime[j]] = f[i] * (g[prime[j]] - 1 + Mod) % Mod;
        }
    }
    REP(i, 1, Max) f[i] = (f[i - 1] + f[i]) % Mod;
    while ( T -- ) 
    {
        scanf("%lld%lld", &n, &m);
        int i = 1, ans = 0;
        while ( i <= min(n, m) )
        {
            int j = min(n / (n / i), m / (m / i));
            int sum = ((f[j] - f[i - 1]) % Mod + Mod) % Mod;
            int s = ((n / i) * (m / i)) % Mod;
            ans = (ans + ((sum * s) % Mod)) % Mod;
            i = j + 1;
        }
        printf("%lld\n", ans);
    }
    return 0;
}
```



---


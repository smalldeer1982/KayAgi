# 多少个 1？

## 题目描述

给定整数 $K$ 和质数 $m$，求最小的正整数 $N$，使得 $ 11\cdots1$（$N$ 个 $1$）$\equiv K \pmod m$。

说人话：就是 $111\cdots 1111 \bmod m = K$。

## 说明/提示

$30\%$ 的数据保证 $m\leq 10^6$。

$60\%$ 的数据保证 $m\leq 5\times 10^7$。

$100\%$ 的数据保证 $6\leq m\leq 10^{11}$，$0< K< m$，保证 $m$ 是质数。

## 样例 #1

### 输入

```
9 17```

### 输出

```
3```

# 题解

## 作者：sxyugao (赞：25)

[更好的阅读体验](https://sxyugao.top/p/cbf2e03c.html)

---

怎么没人发快速乘的版本啊，那我就来水一发吧，其余思想如BSGS不再赘述。

为什么要快速乘？模数$>\sqrt{2^{63}-1}$，直接乘会爆$long\;long$。

正常的快速乘：
```cpp
LL mul(LL a, LL b, LL P){
	LL ans = 0;
	for(; b; b >>= 1, (a <<= 1) %= P)
		if(b & 1) (ans += a) %= P;
	return ans;
}
```
这是基于快速幂思想的，所以复杂度为 $log$，常数爆炸，会愉快地TLE，所以有一篇题解称之为“龟速乘”。

接下来是一份神奇的快速乘:
```
LL mul(LL a, LL b, LL P){
    LL L = a * (b >> 25LL) % P * (1LL << 25) % P;
    LL R = a * (b & ((1LL << 25) - 1)) % P;
    return (L + R) % P;
}
```
是不是看起来超级牛逼，一堆位运算。。。

其实看着这么高级其实就是利用了小学生都会的乘法分配律。

我们要计算 $a \cdot b\;mod\;p$，设 $b=L+R$。

那么原式就变为为$a\cdot(L+R)\;mod\;p=((a\cdot L)\;mod\;p+(a\cdot R)\;mod\;p)\;mod\;p$。

我们把 $L$ 钦定为 $b$ 的二进制前 $x$ 位，$R$ 为 $b$ 的后 $(64-x)$ 位。

就得到了以上的代码（以上这份代码 $x=25$），复杂度近似为O(1)。

用上这样的快速乘就可以AC了。

参考链接：https://zhuanlan.zhihu.com/p/31872064

[完整代码及BSGS推导](https://sxyugao.top/p/cbf2e03c.html)

欢迎大佬来访 (✧◡✧)

---

## 作者：01190220csl (赞：9)

完全不知道为什么此题必须用```__int128```~~Windows下不能用~~。快速乘+map完全可通过本题。

然而快速幂是多余的

知道$a^i$可以推出$a^{i+1}$，知道$(a^p)^i$可以推出$(a^p)^{i+1}$，这是常识。这样就愉快地变成$O(\sqrt{p}log\sqrt{p})$了，复杂度极其正确（然而快速幂再多一个log）。
```
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll times(ll a, ll b, ll m) {
	ll ans = 0;
	while (b) {
		if (b & 1) ans = (ans + a) % m;
		a = (a + a) % m;
		b >>= 1;
	}
	return ans;
}
ll bsgs(ll a, ll b, ll m) {
	map<ll, int> mp;
	int p = ceil(sqrt(m));
	ll num = 1;
	mp[1] = 0;
	for (int i = 1; i <= p; i++) num = times(num, a, m), mp[times(num, b, m)] = i;
	ll n = 1;
	for (int i = 1; i <= p; i++) {
		n = times(n, num, m);
		if (mp.find(n) != mp.end()) return 1ll * p * i - mp[n];
	}
	return -1;
}
int main() {
	ll k, m;
	cin >> k >> m;
	cout << bsgs(10, 9 * k + 1, m) << endl;
	return 0;
}

```

---

## 作者：jiangXxin (赞：3)

先看一下题目：

11111...111(N个)$\equiv k (mod_m)$

我们可以把N个1看成$\frac{10^{N}-1}{9}$，那么等式就变成了：

$\frac{10^{N}-1}{9}\equiv k(mod_m)$

由于同余的特性，我们就可以把方程变成：

$10^{N}\equiv 9k+1 (mod_m)$

这就变成了一个普通的**高次同余方程**了.

由于我们的**m是质数**，所以我们就可以用普通的**Baby Step,Giant Step**算法了，我这里就不再叙述它的证明过程了.

先交了几发**c++**:

（结果最后两个点要么是龟速乘TLE,要么是快乘乘爆，WA）.

不会用**int128**,我选择**Python**

**Code:**

```python
from math import *
s=input().split()
k=int(s[0])
p=int(s[1])
k=k*9+1
map={}
def quickpow(a,b,p):
    ret=1
    while(b):
        if(b&1):
            ret=ret*a%p
        a=a*a%p
        b=b>>1
    return ret


def BSGS(a,b,p):
    t=int(sqrt(p))+1
    aa=a
    for i in range(0,t):
        val=b*aa%p
        if(i==0):
            val=b
        if(val not in map):
            map[val]=i
        if(i>=1):
            aa=(aa*10)%p

    a=quickpow(a,t,p)
    aa=a
    if(a==0):
        if(b==0):
            return 1
        else:
            return -1
    for i in range(0,t+1):
        #val=quickpow(a,i,p)%p
        val=a
        if(i==0):
            val=1
        if(val in map):
            j=map[val]
            if(i*t-j>=0):
                return i*t-j
        if(i>=1):
            a=(a*aa)%p
    return -1
print(BSGS(10,k,p))
```


---

## 作者：Lates (赞：3)

## 最近在学数论，于是来写这道bsgs模板题。

- 正文

题意比较明确，要求

最小的n使得$111...111$一共n个$1$，能膜$m$为$k$。

即为求

$$111...111 \equiv k \ (mod \ m) $$

中$111...111$的位数$n$的最小值。

乍看之下没有思路，但是可以发现把这个数乘$9$再加$1$，就是$10^{n}$。

由于同余式两边乘或加某数，依然成立。所以把左右乘$9$加$1$，

就变成了求

$$10^{n} \equiv 9k+1 \ (mod \ m)$$

$n$的最小值。

这个式子就可以用bsgs算法来求

不会bsgs可以去[OI-wiki](https://oi-wiki.org/math/bsgs/)看看。

- 注意 

在bsgs计算过程中会爆long long，只开long long会WA后面两个点。要用快（龟）速

乘 或 `__int128`存数。

$Code$:

```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
#include <map>
using namespace std;
#define int __int128
inline int read(){
	register int x=0,f=0,ch=getchar();
	while('0'>ch||ch>'9')f^=ch=='-',ch=getchar();
	while('0'<=ch&&ch<='9')x=(x<<1)+(x<<3)+(ch^'0'),ch=getchar();
	return f?-x:x;
}
inline void print(int x){
	if(x<10){
		putchar(x+'0');
		return ;
	}else print(x/10);
	putchar(x%10+'0');
}
map<int,int>vis;
inline int qpow(int x,int p,int P){
	register int res=1;
	for(;p;p>>=1,x=x*x%P)if(p&1)res=res*x%P;
	return res%P;
}
int p,n,m,res,ans=1,Ans; 
signed main(){
	n=read()*9+1,p=read();n%=p;
	m=ceil(sqrt((long long)p));
	res=qpow(10,m,p)%p;
	vis[n%p]=0;
	for(register int i=1;i<=m;++i)
		vis[qpow(10,i,p)*n%p]=i;
	for(register int i=1;i<=m;++i){
		ans=ans*res%p;
		if(vis[ans]){
			Ans=i*m%p-vis[ans];
			print((Ans%p+p)%p);
			return 0;
		}
	}
	return 0;
}


```


---

## 作者：Fatalis_Lights (赞：2)

[博客内食用更佳](https://www.luogu.com.cn/blog/Dream-Battle/solution-p4884)

题目传送门： [Link](https://www.luogu.com.cn/problem/P4884)

前置知识： [BSGS/exBSGS](https://www.luogu.com.cn/problem/P4195)

## Solution

看到 $n$ 个 $1$ ，学习过数论的应该很容易联想到它的另一个形式：

$$\frac{10^n-1}{9}$$

所以原式是这个样子的：

$$\frac{10^n-1}{9}\equiv \operatorname{K} \left(\bmod \space m\right)$$

把分母移至右边并化简得：

$${10^n}\equiv \operatorname{9K+1} \left(\bmod \space m\right)$$

那么就可以套 BSGS/exBSGS 的板子了，但是数据范围比较大，所以笔者偷懒用了 `__int128` 。同时，还需注意 hash 数组的大小，过大会 MLE ，小了则会 RE ，实测用 $2^{20}$ 可以过。

附上代码：

```cpp
#include<bits/stdc++.h>
#define ll __int128
#define int __int128
using namespace std;

class Hash{
	static const ll HASHMOD=1000003;
	ll top,hash[HASHMOD+100],value[HASHMOD+100],stack[1<<20];
	ll locate(const int x) const{
		int h=x%HASHMOD;
		while(hash[h]!=-1 && hash[h]!=x) h++;
		return h;
	}
public:
	Hash(): top(0) { memset(hash,0xFF,sizeof(hash)); }
	void insert(const ll x, const ll v){
		const ll h=locate(x);
		if(hash[h]==-1)
			hash[h]=x ,value[h]=v, stack[++top]=h;
	}
	ll get(const ll x) const{
		const ll h=locate(x);
		return hash[h]==x ? value[h] : -1;
	}
	void clear(){ while(top) hash[stack[top--]]=-1;}
} hash;
struct Triple{
	ll x,y,z;
	Triple(){}
	Triple(const ll a, const ll b,const ll c): x(a), y(b), z(c){};
};

Triple Extendedgcd(const ll &a, const ll &b){
	if(b==0) return Triple(1,0,a);
	const Triple last=Extendedgcd(b,a%b);
	return Triple(last.y,last.x-a/b*last.y,last.z);
}

ll ebsgs(ll A, ll B, ll C){
	ll tmp=1, cnt=0, D=1;
	for(ll i=0;i<32;++i){
		if(tmp==B) return i;
		tmp=tmp*A%C;
	}
	for(Triple res; (res=Extendedgcd(A,C)).z!=1; ++cnt){
		if(B%res.z) return -1;
		B/=res.z,C/=res.z;
		D=D*A/res.z%C;
	}
	const ll sqrtn=static_cast<ll>(ceil(sqrt((double)C)));
	hash.clear();
	ll base=1;
	for(ll i=0;i<sqrtn;++i){
		hash.insert(base,i);
		base=base*A%C;
	}
	ll j=-1,i;
	for(i=0;i<sqrtn;++i){
		Triple res=Extendedgcd(D,C);
		const ll c=C/res.z;
		res.x=(res.x*B/res.z%c+c)%c;
		j=hash.get(res.x);
		if(j!=-1) return i*sqrtn+j+cnt;
		D=D*base%c;
	}
	return -1;
} 

void read(ll &x){
    int f=1;x=0;char s=getchar();
    while(s<'0'||s>'9'){if(s=='-')f=-1;s=getchar();}
    while(s>='0'&&s<='9'){x=x*10+s-'0';s=getchar();}
    x*=f;
}
void print(ll x){
    if(x<0)putchar('-'),x=-x;
    if(x>9)print(x/10);
    putchar(x%10+'0');
}

signed main(){
	ll b,c; read(c), read(b); 
	c=c*9+1;
	c%=b;
	const ll ans=ebsgs(10,c,b);
	print(ans);
	return 0;
}
```

---

## 作者：Ajwallet (赞：2)

[蒟蒻blog]()，欢迎来踩QwQ！！！

这么多人都用了$map$+__ int128

我就发一波$longdouble$乘防爆$long\ long$+手写$hash$的题解吧QwQ

思路都是式子转换成$10^n\equiv 9k+1(mod\ m)$，形如$a^x\equiv b(mod\ p)$，所以这是一道$BSGS$的模板题，其中$a=10,b=9k+1,p=m$，跑大步小步就$OK$啦

关于$hash$表的大小，其实只需要选一个大于$\sqrt{10^{11}}=10^{6.5}\approx 3.16\times 10^5$的质数就可以了，但不要太大，容易炸空间

以下是$BSGS$算法的流程
>设$x=it-j$，其中$t=\lceil \sqrt p\rceil$，$0\leq j<t$，则方程可以变成$a^{it-j}\equiv b(mod\ p)$，两边同时乘$a^j$，得到$a^{it}\equiv ba^j(mod\ p)$，即$(a^i)^t\equiv ba^j(mod\ p)$。

>此时对于所有的$j\in [0,t-1]$，把$ba^j\ mod\ p$插入一个$hash$表。

>然后对于所有的$i\in[0,t]$，计算$(a^i)^t\ mod\ p$，同时查询是否存在对应的$j$即可，时间复杂度为$O(\sqrt p)$

其实准确来说应该是$O(\sqrt p\ log\ \sqrt p)$了啦，快速幂也要时间的嘛不是？
***
#### $Code$
```cpp
#include<cmath>
#include<cstdio>
#include<algorithm>
#define LL long long
using namespace std;LL m,k;
struct hash
{
	#define p 1000003
	LL a[p],b[p];//a是原hash表，b用来存储这个位置上要存的数
	inline LL h(LL x){return x%p;}//求出每个数对应的hash函数值
	inline int find(LL x)//在hash表中查找x
	{
		int y=x%p;
		while(a[y]&&a[y]!=x) y=h(++y);//直到找到一个空位或找到这个数为止
		return y;
	}
	inline void push(LL x,LL num)//在x的位置放入num
	{
		int y=find(x);//给予
		a[y]=x;
		b[y]=num;
		return;
	}
	inline int init(LL x)//判断是否存在x，存在返回对应数值，不存在返回-1
	{
		int y=find(x);
		return a[y]==x?b[y]:-1;
	}
	#undef p
}h;
inline LL ksc(LL a,LL b,LL p)//long double版本的快速乘，防止相城爆long long
{
    a%=p;b%=p;
    long long c=(long double)a*b/p;
    long long ans=a*b-c*p;
    if(ans<0) ans+=p;
    else if(ans>=p) ans-=p;
    return ans;
}
inline LL ksm(LL x,LL y,LL p)//快速幂
{
	LL ans=1;
	for(;y;y>>=1,x=ksc(x,x,p)) if(y&1) ans=ksc(ans,x,p);
	return ans;
}
inline LL BSGS(LL a,LL b,LL p)
{
	a%=p;b%=p;
	if(!a) return !b?1:-1;
	if(b==1) return 0;
	LL t=ceil(sqrt(p)),val;
	for(register int j=0;j<t;j++) val=ksc(b,ksm(a,j,p),p),h.push(val,j);//放入hash表中
	a=ksm(a,t,p);val=1;//初始化val=a^0
	for(register int i=1;i<=t;i++)
	{
		val=ksc(val,a,p);//每次乘a，就变成了val=a^i
		LL j=h.init(val);//查询
		if(j>=0&&i*t-j>=0) return i*t-j;//判断
	}
	return -1;
}
signed main()
{
	scanf("%lld%lld",&k,&m);
	printf("%lld",BSGS(10,9*k+1,m));
}
```

---

## 作者：未见堇开 (赞：1)

2022.9.23 ver. 

校正了之前的错误，并且根据新数据范围调整题解内容。

这篇题解的上一个版本撰写于 2019.07.15。

数据范围**在 2020 年才**修改为现在的数据范围。

请务必注意。

------------
#### 1. 思路

$$\begin{aligned}\dfrac {10^{x}-1} {9}&\equiv K\pmod {m}\\\dfrac {10^{x}-1} {9}+my&=K\\10^{x}-1+9my&=9K\\10^{x}-1&\equiv 9K\sout {\pmod {9m}}\pmod {m}\end{aligned}$$

~~又$\sout {\because 10\perp 9m}$不一定成立，本题应使用$\sout {\mathrm {exBSGS}}$算法。~~

数据范围调整之后，$m$ 是**不小于** $6$ 的质数。

于是 $m=2$ 和 $m=5$ 的情况**被排除**，$10\perp m$ 一定成立。

那么 $\rm BSGS$ 就够用了。另外，题目一定有解也不难确认了。

~~除此之外，本题明确要求$\sout {x>0}$，因此$\sout {x=0}$的情况应当被排除，但计算所有解导致了$\sout \color{DarkBlue} \mathrm {TLE}$或许是因为我太菜了~~。

~~用$\sout {unordered\_ map}$、开$\sout {O_{2}}$才勉强通过该题。~~

之前的数据范围暂且不谈。我们**只考虑现有**数据范围下，$x>0$ 是否一定成立。

我们先假定 $x=0$，不难推知此时 $m|K$。

但是 $K<m$，显然这两条是矛盾的。

于是必有 $x\neq 0$。

显然 $x\geq 0$ ，那么 $x>0$ 便是板上钉钉的了。

数据范围很大，别忘了用快速乘！

（当然，`__int128` 也行）
#### 2. 代码
```cpp
#include <cstdio>
#include <cmath>
#include <map>
#define rgst register
using namespace std;

typedef long long ll;

ll x, y, K, M;
map<ll, int> q;

inline ll qmul(ll a, ll b, ll p)
{
	ll d = (ll)(a *(long double)b / p + 0.5);
	ll res = a * b - d * p;
	return((res % p + p)% p);
}

inline ll qpwr(ll a, ll n, ll p)
{
	ll res= 1;
	a %= p;
	for(; n; n >>= 1, a = qmul(a, a, p)% p)
		if(n & 1)
			res = qmul(a, res, p);
	return(res % p);
}

inline ll bsgs(ll a, ll b, ll p)
{
	q.clear();
	b %= p;
	q[b] = 0;
	int m = ceil(sqrt(p));
	for(rgst int i = 1; i <= m; i++)
	{
		b = qmul(b,a,p);
		q[b] = i;
	}
	b = 1;
	ll po = qpwr(a,m,p);
	for(rgst int i = 1; i <= m; i++)
	{
		b = qmul(b, po, p);
		if(q.count(b))
			return( ((1ll * m * i - q[b])% p + p)% p);
	}
	return(-1);
}

inline ll calc(ll a,ll b,ll p)
{
	a %= p, b %= p;
	ll res = bsgs(a, b, p);
	if(res == -1)
		return(-1);
	return(res);
}

int main()
{
	scanf("%lld %lld", &K, &M);
	printf("%lld", calc(10, 9 * K + 1, M));
	return(0);
}
```

---

## 作者：ZhuMingYang (赞：0)

快速乘from这位巨佬 [sxyugao] Orz Orz
------------
看题解中没快速乘的代码，我这蒟蒻给一份代码供参考

这道题设答案为x 即可以得到式子:1/9*(10^x-1)≡K (mod m)

化简后得:10^x≡9K+1 (mod m)

显然就是一道bsgs模板题



------------


以下简要介绍bsgs算法思路:

我们求的x可设为x=i*t - j  （0 <=j< t）

其中t=ceil(sqrt(m)) （数学符号不想找了。。。）

P.S. 设t=ceil(sqrt(m))是因为此时复杂度期望值最小

那么原式可继续化为 (10^t)^i≡(9K+1)*10^j （mod m） （0 <=j< t ）

那么右侧可以枚举 0 <=j< t 的 j 算出(9K+1)*10^j % m 并存入一个hash表中（可用map）

像这样：hash[(9K+1)*10^j%m]=j

左侧枚举 0 <=i<= t 的 i 算出(10^t)^i % m查表看看有没有对应值 有的话 答案就是i*t-hash[(10^t)^i%m]
```
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<vector>
#include<cmath>
#include<map>
using namespace std;
typedef long long ll;
ll a,b,p,x;
map<ll,int> hash;
map<ll,int>::iterator it;
ll mul(ll a,ll b,ll p)
{
    if(a>1e9||b>1e9){
        ll x = 1LL<<25;
        ll L = a * (b >> 25LL) % p * x % p;
        ll R = a * (b & (x - 1)) % p;
        return (L + R) % p;
    }
    else
        return a*b%p;
}
ll qpow(ll a,ll b,ll p)
{
    ll ans=1;
    for(;b;b>>=1)
    {
        if(b&1){
            ans=mul(ans,a,p);
        }
        a=mul(a,a,p);
    }
    return ans;
}
ll bsgs(ll a,ll b,ll p)
{
    a%=p,b%=p;
    if(a==0) return b==0?1:-1;
    if(b==1) return 0;
    ll t=ceil(sqrt(p)),val;
    for(int j=0;j<t;j++)
    {
        val=mul(b,qpow(a,j,p),p);
        hash[val]=j;
    }
    a=qpow(a,t,p);
    val=1;
    for(int i=1;i<=t;i++)
    {
        val=mul(val,a,p);
        it=hash.find(val);
        if(it!=hash.end())
        {
            if(i*t-(it->second)>=0) return i*t-(it->second);
        }
    }
    return -1;
}
int main()
{
    scanf("%lld%lld",&b,&p);
    x=bsgs(10,9*b+1,p);
    printf("%lld\n",x);
    return 0;
}
```
刚刚又优化了一下 现在一秒内能过


再附上一枚bsgs拓展（即不要求a与p互质）
```
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<vector>
#include<cmath>
#include<map>
using namespace std;
typedef long long ll;
ll a,b,p,x;
map<ll,int> hash;
map<ll,int>::iterator it;
ll mul(ll a,ll b,ll p)
{
    if(a>1e9||b>1e9){
        ll x = 1LL<<25;
        ll L = a * (b >> 25LL) % p * x % p;
        ll R = a * (b & (x - 1)) % p;
        return (L + R) % p;
    }
    else
        return a*b%p;
}
ll qpow(ll a,ll b,ll p)
{
    ll ans=1;
    for(;b;b>>=1)
    {
        if(b&1){
            ans=mul(ans,a,p);
        }
        a=mul(a,a,p);
    }
    return ans;
}
ll gcd(ll a,ll b)
{
    if(b==0) return  a;
    return gcd(b,a%b);
}
ll ex_bsgs(ll a,ll b,ll p)
{
    a%=p,b%=p;
    if(a==0) return b==0?1:-1;
    if(b==1) return 0;
    ll d=a,tmp=1,k=0;
    while(true)
    {
        d=gcd(d,p);
        if(d==1) break;
        if(b%d!=0) return -1;
        b/=d,p/=d;
        tmp=mul(tmp,a/d,p);
        k++;
        if(tmp==b) return k;
    }
    a%=p,b%=p,tmp%=p;
    ll t=ceil(sqrt(p)),val;
    for(int j=0;j<t;j++)
    {
        val=mul(b,qpow(a,j,p),p);
        hash[val]=j;
    }
    a=qpow(a,t,p);
    val=tmp;
    for(int i=1;i<=t;i++)
    {
        val=mul(val,a,p);
        it=hash.find(val);
        if(it!=hash.end())
        {
            if(i*t-(it->second)+k) return i*t-(it->second)+k;
        }
    }
    return -1;
}
int main()
{
    scanf("%lld%lld",&b,&p);
    x=ex_bsgs(10,9*b+1,p);
    printf("%lld\n",x);
    return 0;
}
```

---


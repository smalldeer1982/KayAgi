# 评分系统

## 题目背景

答疑请到：https://www.luogu.org/discuss/show?postid=79498

由于时限等问题，请大家重交一遍这道题

本题时限开至2s

样例：https://files.cnblogs.com/files/ztz11/yl.rar

---

众所周知，luogu 有题目难度的评分系统，用户在通过题目后可以选择题目难度以及算法标签，来完善 luogu 的题库。

![](https://cdn.luogu.com.cn/upload/pic/40327.png)

（原注：以下内容非真实评分数据，纯属作者编造，仅供娱乐使用。）

## 题目描述

Menteur-Hxy 同学很不老实，为了实现 NOIp 前 AC $100$ 道黑题的目标，他决定雇佣一些水军，最少雇佣 $1$ 个水军。

每个水军都有一个能力值 $x_i$，表示该水军可以解决难度最高为 $x_i$ 的题目。这些水军十分尽职尽责，在通过这道题目后都会给题目评最高难度。当然，luogu 的正常用户也会做题，他们会正常地评分。现在，我们给你所有水军的能力值以及每道题正常用户的评分记录，请你求出有多少种选择水军的方案，可以使这道题的评分变为黑题。因为答案可能过大，最终请输出答案数 $\bmod p$ 的值。

评分计算公式：去掉一个最高分，去掉一个最低分后求平均分。

**【表一：投票信息】**

| 投票编号 | 对应难度 | 分数贡献 |
| :------: | :------: | :------: |
| $1$ | 入门 | $1$ |
| $2$ | 普及- | $10$ |
| $3$ | 普及/提高- | $15$ |
| $4$ | 普及+/提高 | $25$ |
| $5$ | 提高+/省选- | $40$ |
| $6$ | 省选/NOI- | $55$ |
| $7$ | NOI | $75$ |
| $8$ | NOI+/CTSC | $100$ |

**【表二：难度规则】**

| 难度等级 | 对应颜色 | 对应分数 |
| :------: | :------: | :------: |
| 入门 | 红 | $1\sim 5$ |
| 普及- | 橙 | $6\sim 12$ |
| 普及/提高- | 黄 | $13\sim 20$ |
| 普及+/提高 | 绿 | $21\sim 35$ |
| 提高+/省选- | 蓝 | $36\sim 45$ |
| 省选/NOI- | 紫 | $46\sim 70$ |
| NOI+/CTSC | 黑 | $71\sim 100$ |

## 说明/提示

**【样例解释 $1$】**

luogu 用户评分和为 $25+40+55+75+100=295$，弃掉一个最低分后为 $270$，这时 Menteur-Hxy 雇佣两个及以上水军就可以达到目的。

因为可以通过本题的水军共有 $4$ 个，所以选择方案共有：

$$\{1,2\}\{1,2,3\}\{1,2,3,4\}\{1,2,4\}\{1,3\}\{1,3,4\}\{1,4\}\{2,3\}\{2,3,4\}\{2,4\}\{3,4\}$$

共 $11$ 种，对 $9$ 取余后结果为 $2$。

**【数据规模与约定】**

对于 $30\%$ 的数据，$n, m \leq 50$。

对于另外 $20\%$ 的数据，$p$ 为质数。

对于 $100\%$ 的数据，$1 \leq n, m, k,s_i \leq 10^5, 1 \leq t \leq 5, 2 \leq p \leq 3 \times 10^3, 1 \leq t_i \leq 8$。

保证合格水军的数量与需要的最少水军数量之差不超过 $5000$。

（原注：本题可能轻微卡常。感谢 @Ghostcai ，@Swhsz 帮忙验题。）

## 样例 #1

### 输入

```
1
5 5 9
1 2 3 4 5
4 5 6 7 8
2```

### 输出

```
2```

## 样例 #2

### 输入

```
5
20 10 1329
540 499 490 419 308 261 323 476 476 374 23 13 14 16 19 34 43 19 27 32 
8 8 8 8 8 7 7 7 7 7 
50
20 10 1800
74 434 97 134 283 118 234 498 328 388 29 48 48 43 23 42 31 16 20 26 
8 8 7 6 8 8 8 7 7 7 
50
20 10 2704
142 378 330 281 377 64 340 309 466 289 34 37 19 17 20 48 21 28 38 15 
6 8 6 6 8 7 7 7 7 6 
50
20 10 72
365 356 456 479 459 222 548 377 212 223 38 20 49 18 49 38 31 48 41 17 
6 8 7 6 8 7 8 8 8 6 
50
20 10 1416
367 191 403 298 445 464 79 467 431 362 10 45 48 37 46 43 11 35 30 39 
8 6 8 7 7 7 8 8 7 8 
50```

### 输出

```
1023
1023
1023
15
1023```

# 题解

## 作者：ztz11 (赞：2)

比较良心的部分分（50pts）   
前30分可以暴力  
另20分可以递推  
对于这道题，化简下来，就是$C_{minx+1}^n+C_{minx+2}^n+...+C_n^n$  
(n为合格的水军数量，minx为最少需要的水军数量（因为要去掉最高分，所以我们要+1）)  
然后对于p=质数的情况，lucas定理即可  
p!=质数的话用exlucas就行    
当然，据说有人暴力能水不少分？tql！（可能是我数据出水了）  
```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define rii register int i
#define rij register int j 
#define int long long
using namespace std;
int n1,m1,p,nl[100005],t;
int pf[10]={0,1,10,15,25,40,55,75,100};
int pow(int a,int b,int p)
{
    int res=1;
    while(b)
    {
        if(b&1)
        {
            res=res*a%p;
        }
        a=a*a%p;
        b>>=1;
    }
    return res;
}
int exgcd(int a,int b,int& x,int& y)
{
    if(!b)
    {
        x=1;
        y=0;
        return a;
    }
    int res=exgcd(b,a%b,y,x);
    y-=(a/b)*x;
    return res;
}
int reverse(int a,int p)
{
    int x,y;
    exgcd(a,p,x,y);
    return (x%p+p)%p;
}
int C(int n,int m,int p)
{
    if(m>n)
    {
        return 0;
    }
    int res=1,i,a,b;
    for(i=1;i<=m;i++)
    {
        a=(n+1-i)%p;
        b=reverse(i%p,p);
        res=res*a%p*b%p;
    }
    return res;
}
int Lucas(int n,int m,int p)
{
    if(m==0)
    {
        return 1;
    }
    return Lucas(n/p,m/p,p)*C(n%p,m%p,p)%p;
}
int cal(int n,int a,int b,int p)
{
    if(!n)
    {
        return 1;
    } 
    int i,y=n/p,tmp=1;
    for(i=1;i<=p;i++)
    {
        if(i%a)
        {
            tmp=tmp*i%p;
        }
    }
    int ans=pow(tmp,y,p);
    for(i=y*p+1;i<=n;i++)
    {
        if(i%a)
        {
            ans=ans*i%p;
        } 
        
    } 
    return ans*cal(n/a,a,b,p)%p;
}
int multiLucas(int n,int m,int a,int b,int p)
{
    int i,t1,t2,t3,s=0,tmp;
    for(i=n;i;i/=a)
    {
        s+=i/a;
    }
    for(i=m;i;i/=a)
    {
        s-=i/a;
    }
    for(i=n-m;i;i/=a)
    {
        s-=i/a;
    }
    tmp=pow(a,s,p);
    t1=cal(n,a,b,p);
    t2=cal(m,a,b,p);
    t3=cal(n-m,a,b,p);
    return tmp*t1%p*reverse(t2,p)%p*reverse(t3,p)%p;
}
int exLucas(int n,int m,int p)
{
    int i,d,c,t,x,y,q[100],a[100],e=0;
    for(i=2;i*i<=p;i++)
    {
        if(p%i==0)
        {
            q[++e]=1;
            t=0;
            while(p%i==0)
            {
                p/=i;
                q[e]*=i;
                t++;
            }
            if(q[e]==i)
            {
                a[e]=Lucas(n,m,q[e]);
            }
            else
            {
                a[e]=multiLucas(n,m,i,t,q[e]);
            }
        }
    }
    if(p>1)
    {
    	e++;
        q[e]=p;
        a[e]=Lucas(n,m,p);
    }
    for(i=2;i<=e;i++)
    {
        d=exgcd(q[1],q[i],x,y);
        c=a[i]-a[1];
        if(c%d)
        {
            exit(-1);
        }
        t=q[i]/d;
        x=(c/d*x%t+t)%t;
        a[1]=q[1]*x+a[1];
        q[1]=q[1]*q[i]/d;
    }
    return a[1];
}
inline int rd(){
    int x=0,f=1;char ch=getchar();
    while(!isdigit(ch)) {f=ch=='-'?0:1;ch=getchar();}
    while(isdigit(ch))  {x=(x<<1)+(x<<3)+ch-'0';ch=getchar();}
    return f?x:-x;
}
bool cmp(int lk,int kl)
{
	return lk<kl;
}
void solve()
{
	n1=rd();
	m1=rd();
	p=rd();
//	scanf("%lld%lld%lld",&n,&m,&p);
	for(rii=1;i<=n1;i++)
	{
		nl[i]=rd();
//		scanf("%lld",&nl[i]);
	}
	sort(nl+1,nl+n1+1,cmp);
	int minx=10,jsq=0;
	for(rii=1;i<=m1;i++)
	{
		int val;
		val=rd();
//		scanf("%lld",&val);
		minx=min(minx,val);
		jsq+=pf[val];
	}
	jsq-=pf[minx];
	int cha=(m1-1)*71-jsq;
	int mins=cha/29;
	if(mins*29<cha)
	{
		mins++;
	}
	if(cha<=0)
	{
		mins=0;
	}
	int ans=0;
	int zx;
	zx=rd();
//	scanf("%lld",&zx);
	int cnt=n1;
	for(rii=1;i<=n1;i++)
	{
		if(nl[i]<zx)
		{
			cnt--;
		}
		else
		{
			break;
		}
	}
	n1=cnt;
	for(rii=mins+1;i<=n1;i++)
	{
		ans+=exLucas(n1,i,p);
		ans%=p;
	}
    printf("%lld\n",ans);
}
signed main()
{
// 	freopen("pf10.in","r",stdin);
// 	freopen("pf10.out","w",stdout);
    scanf("%lld",&t);
    for(rii=1;i<=t;i++)
    {
    	solve();
	}
}
```

---

## 作者：WhitD (赞：0)

## 思路
首先肯定要求出为了达到黑题的要求（评分 $\ge71$），我们最少需要请多少水军。

设水军人数为 $x$，谷民人数为 $m$，谷民打的总分为 $sum$，最低分为 $min$，自然可列出下式：
$$\frac{sum-min+100(x-1)}{m-1+x-1}\ge71$$

关于为什么是 $(x-1)$：由于我们除了去掉一个最低分以外，还会去掉一个最高分，水军打的一定是最高分（$100$），所以算的时候直接减去就可以了。

化简后得：

$$x\ge\frac{71m-sum+min-42}{29}$$

我们所求的是最小值，即：

$$x=\max(1,\lceil\frac{71m-sum+min-42}{29}\rceil)$$

关于为什么要对 $1$ 取 $\max$，是因为等式右边可能是负数，我们总不能对负数做组合数计算吧。

考虑选取的方案数，设可以做题的水军人数为 $cnt$，最少选取 $x$ 人，方案数为 $cnt\choose x$，当然我们也可以多选，最多可以把 $cnt$ 个人都选上，因此总方案数为：

$$\sum_{i=x}^{cnt}{cnt\choose i}$$

模数范围比较小，模数是质数的情况需要用普通卢卡斯定理解决（用扩展卢卡斯定理会 TLE on #4，比较神秘），笔者就是在这里卡了好长时间（两页提交记录）。

不是质数的情况用扩展卢卡斯定理解决就可以了。

(如果你还不了解卢卡斯定理，[点这里](https://oi-wiki.org/math/number-theory/lucas/))。

## AC 代码
```cpp
#include<iostream>
using namespace std;
inline int _min(int a,int b){return (a<b)?a:b;}
inline int _max(int a,int b){return (a>b)?a:b;}
inline int _ceil(double x){return (int(x)==x)?int(x):(int)(x+1);}
inline void exgcd(int a,int b,int &x,int &y)
{
	if(!b)
	{
		x=1,y=0;
		return ;
	}
	exgcd(b,a%b,y,x),y-=x*(a/b);
}
inline int inv(int v,int p)
{
	register int x,y;
	exgcd(v,p,x,y);
	return (x%p+p)%p;
}
inline int qkpow(int a,int b,int p)
{
	register int res=1;
	while(b)
		res=(b&1)?res*a:res,a=a*a%p,b>>=1;
	return res%p;
}
inline int fac(int n,int pi,int pk)
{
	if(!n) 
		return 1;
	register int ans=1,i=2;
	for(i=2;i<pk;i++) 
		ans=(i%pi)?ans*i%pk:ans;
	ans=qkpow(ans,n/pk,pk);
	for(i=2;i<=n%pk;i++) 
		ans=(i%pi)?ans*i%pk:ans;
	return ans*fac(n/pi,pi,pk)%pk;
}
inline int l(int n,int m,int pi,int pk)
{
	register int ind=0,i=0;
	for(i=n;i;i/=pi) 
		ind+=i/pi;
	for(i=m;i;i/=pi) 
		ind-=i/pi;
	for(i=n-m;i;i/=pi) 
		ind-=i/pi;
	return fac(n,pi,pk)*inv(fac(m,pi,pk),pk)%pk*inv(fac(n-m,pi,pk),pk)%pk*qkpow(pi,ind,pk)%pk;
}
inline int exlucas(int n,int m,int p)
{
	register int tmp=p,ans=0,pk=1;
	for(register int i=2;i*i<=tmp;++i)
	{
		if(!(tmp%i))
		{
			pk=1;
			while(!(tmp%i)) 
				tmp/=i,pk*=i;
			ans=(ans+l(n,m,i,pk)*inv(p/pk,pk)%p*p/pk%p)%p;
		}
	}
	return (tmp>1)?(ans+l(n,m,tmp,tmp)*inv(p/tmp,tmp)%p*p/tmp%p)%p:ans%p;
}
inline int C(int n,int m,int p)
{
    if(m>n)
        return 0;
    register int res=1,i,a,b;
    for(i=1;i<=m;++i)
        a=(n+1-i)%p,b=inv(i%p,p),res=res*a%p*b%p;
    return res;
}
inline int lucas(int n,int m,int p)
{
    return (!m)?1:(lucas(n/p,m/p,p)*C(n%p,m%p,p))%p;
}
inline int is_p(int x)
{
	for(int i=2;i*i<=x;i++)
		if(x%i==0)
			return 0;
	return 1;
}
int T,n,m,p,s[100005],mn,sum,x,k,cnt,ans,i,t,score[10]={0,1,10,15,25,40,55,75,100};
int main()
{
	std::ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>T;
	while(T--)
	{
		ans=sum=cnt=0,mn=100005;
		cin>>n>>m>>p;
		for(i=1;i<=n;++i)
			cin>>s[i];
		for(i=1;i<=m;++i)
			cin>>t,mn=_min(mn,score[t]),sum+=score[t];
		sum-=mn;
		x=_max(1,_ceil((71.0*m-sum-42.0)/29.0));
		cin>>k;
		for(i=1;i<=n;++i)
			cnt+=(s[i]>=k);
		if(is_p(p))
			for(x;x<=cnt;++x)
				ans=(ans+lucas(cnt,x,p));
		else
			for(x;x<=cnt;++x)
				ans=(ans+exlucas(cnt,x,p));
		cout<<(ans%p)<<'\n';
	}
	return 0;
}
```


---


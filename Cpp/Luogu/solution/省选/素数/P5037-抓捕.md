# 抓捕

## 题目背景

@葛军  原创

古桥文乃作为一名OIer，每天勤奋地在洛谷上刷题，然而她的父母却认为他有网瘾，就将她送到了杨叫兽的网戒中心。

![](https://cdn.luogu.com.cn/upload/pic/41018.png )

一年之后，凭借不懈地努力古桥文乃终于逃了出来，并且立刻向警察蜀黍举报杨叫兽的所作所为，了解情况后警察请她带路去网戒中心抓捕杨叫兽。

## 题目描述

啊~~~~！

他们刚到达网戒中心就听到惨叫声从里面传来。古桥文乃在网戒中心呆了一年，对里面的情况很熟悉，立马就知道杨叔又在13号治疗室“点现钱”。同时，她知道网戒中心有$n$个房间，任意房间都有走廊相连，每个走廊和房间之间都有门，门是向外锁上的，且在开启后会自动锁上（即每次从房间$i$进入任意一个与其相连的走廊需要花费$c_i$的体力开锁，而从走廊进入房间不用耗费体力）。

杨叔为了防止“盟友”逃跑，在每个房间安装了摄像头，安排了$n$个手下在监控中心看着监控。

**特别的，1号房间为监控中心，1号手下负责防止任何人（除了杨叔）进入监控中心（否则立刻报告给杨叔）**，

其余的2号到$n$号手下每人负责监控编号是自己整数倍的房间（例如$n=10$时2号手下监控2号，4号，6号，8号，10号房间），13号治疗室也按照此规则被监控，如果他们其中一个人看到同一个人两次，就会向杨叔报告（但是每一个手下不会互相交流信息），好在这些手下都四肢发达头脑简单，只能记得上一秒的事情。

为了保证抓捕的顺利，古桥文乃和警察不能被发现，现在他们在$x$号房间，13号治疗室在$y$号房间，已知他们通过每一条走廊要1秒，开锁和通过房间不用花费时间（但会被监控室的手下看到），古桥文乃和警察想知道他们在不被发现的情况下最少要花费多少体力才能进入13号治疗室。

## 说明/提示

2->3->4

对于30%的数据，$n$<=$1500$，$T$<=$15$；

对于50%的数据，$n$<=$2500$，$T$<=$30$；

对于70%的数据，$n$<=$4500$，$T$<=$50$；

对于100%的数据，$n$<=$4500$，$T$<=$200$，$2$<=$x$,$y$<=$n$，$c_i$<=$9900$

## 样例 #1

### 输入

```
1
5
2 4
1 2 3 4 5```

### 输出

```
5```

# 题解

## 作者：STA_Morlin (赞：16)

[P5037 抓捕 の 题目传送门。](https://www.luogu.com.cn/problem/P5037)

## 题目
> 有一点数为 $n$ 的图，每次只能去与本点互质的点，每次从点出发需要 $c_i$ 点体力，求从点 $s$ 到点 $e$ 所耗费的最小体力。

## 思路简析

首先要手动连边，点 $1$ 不可连，因为连了就会失败 ~~不知道为什么要弄个点 $1$~~。

剩下的边也不是每个都能连。

每条走廊要跑一秒，每个手下能记住一秒的事，所以不能在两秒内让同一个手下看到，则每次必须去互质的点。

Eg：$2$ -> $3$，$2$ 不能去 $4$，因为 $2$ 号手下同时看着点 $2$ 和点 $4$。

说句闲话：作者本来好像是向卡暴力让构造过的，结果他的构造比暴力还慢。

然后跑 heap+dij。

---
## 代码实现

这里的 dij 不是普通的 dij。

每次出房间需要体力，所以在入队的时候要加上出房间的体力值。

# _CODE_
```cpp
#include <bits/stdc++.h>
using namespace std;
#define pii pair <int, int>
#define mp(x, y) make_pair(x, y)
const int man = 4.5e3+10;
class Graph {
public:
    int hed[man], dis[man], len;
    int nxt[man*man], to[man*man];
    void Ins (int u, int v) {
        to[++len] = v;
        nxt[len] = hed[u];
        hed[u] = len;
        return ;
    }
} G;

int T, n, s, e;
int dis[man], vis[man];
void dijkstra (int s) {
    priority_queue <pii, vector <pii >, greater <pii > > q;
    memset(dis, 0x3f, sizeof(dis));
    memset(vis, 0, sizeof(vis));
    dis[s] = 0;
    q.push(mp(G.dis[s], s));
    while (q.size()) {
        int x = q.top().first, y = q.top().second;
        q.pop(), vis[y] = 1;
        for (int i = G.hed[y]; i; i = G.nxt[i]) {
            int v = G.to[i];
            if (vis[v]) continue;
            if (dis[v] > x) {
                dis[v] = x;
                if (v == e) {
                    printf("%d\n", dis[v]);
                    return ;
                } q.push(mp(dis[v]+G.dis[v], v));
            }
        }
    } puts("-1");
    return ;
}
int main () {
	#ifndef ONLINE_JUDGE
		freopen("test.in", "r", stdin);
		freopen("test.out", "w", stdout);
	#endif
    scanf("%d%d", &T, &n);
    for (int i = 2; i < n; ++ i) 
        for (int j = i+1; j <= n; ++ j) 
            if (__gcd(i, j) == 1) G.Ins(i, j), G.Ins(j, i);
    while (T --) {
        scanf("%d%d", &s, &e);
        for (int i = 1; i <= n; ++ i) scanf("%d", G.dis+i);
        dijkstra(s);
    }
    return 0;
}
```
# E.N.D.

---

## 作者：_虹_ (赞：12)

刚刚看到有大佬举报这题抄袭题解这事才想起这道题。

分享一个  ~~赛后十分钟写出来的~~ **诡异**的做法

init函数预处理出所有不互质的点对。

**任意房间都有走廊相连**，所以不需要连边，只要两点互质就存在一条边，边权=出发点点权。在这张图上跑dij+heap。

~~印象中t了。~~

记录ans=min(ans,result[y])，在relax的时候放弃所有result[v]>=ans的点u的relax，相当于是在最短路树上剪枝。

然后AC了。

效率不如出题人题解提到的relax点y时终止dij的方法，但是这道题上慢的不多，实测后5个点慢10ms多一点。

~~程序不吸氧总用时600ms上下。并不知道为什么会这么快。。。。不知道有没有大佬讲解一下。。。。~~

~~rank1 31ms /  2.78MB ，不知道大佬用了什么神仙算法。orz~~

```cpp
//#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;
const unsigned int INT_MAX=2147483647;

const int kmaxn=4500+5;
const int kmaxm=kmaxn<<4;
//////////////////////////////////////////////////////////////////////////////////
struct unit
{
    int first;
    int second;
    unit():first(0),second(0){};
    inline unit(const int& f,const int& s):first(f),second(s){};
    const int inline operator<(const unit& u)const
    {
        return first>u.first;
    }
};
class p_queue
{
    unit heap[kmaxm];
    int otail;
        public:
        p_queue():otail(0){};
        unit inline top(){
            pop_heap(&heap[0],&heap[otail]);
            return heap[otail-1];
        }
        void inline pop(){--otail;
        }
        void inline push(const unit& v){
            heap[otail++]=v;
            push_heap(&heap[0],&heap[otail]);
        }
        const bool inline empty()const{return !otail;}
}q;
//priority_queue<pair<int,int>,vector<pair<int,int> >,greater<pair<int,int> > > q;
/////////////////////////////////////////////////////////////////////////////////
bool unable[kmaxn][kmaxn];
int result[kmaxn];//走到i点消耗的最小体力 
int value[kmaxn];//从i点出发消耗掉的体力 
bool hsh[kmaxn];
int otail=0;
int n;
int ans;
int x,y;
void inline relax(const int& p)
{
    register int v=result[p]+value[p];
    if(ans<=v)
        return;
    for(register int i=2;i<=n;++i)
    {
        if(!hsh[i]&&!unable[p][i]&&(result[i]<0||result[i]>v))
        {
        	result[i]=v;
        	if(i==y)
        		ans=v;
            else if(v<ans)
            //	q.push(make_pair(v,i));
        		q.push(unit(v,i));
        	//cout<<i<<"	"<<p<<endl;
        }
    }
}
void inline shortest_path(const int& start)
{
    ans=INT_MAX;
    //q.push(make_pair(0,start));
    q.push(unit(0,start));
    result[start]=0;
    int t=0;
    while(!q.empty())
    {
            t=q.top().second;
            q.pop();
            if(!hsh[t])
            {
                relax(t);
                hsh[t]=true;
            }
    }
}
/*void inline add_edge(const int& s,const int &d,const int &w)
{
    if(s!=d)
    	map[s][d]=w;
}*/
inline int read(){
   register int s=0,w=1;
   register char ch=getchar();
   while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
   while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
   return s*w;
}

int t;
void inline init()
{
    for(register int i=2;i<=n;++i)
    {
        for(register int f=1;f*i<=n;++f)
        {
            value[otail++]=i*f;
            for(register int k=0;k<otail;++k)
            {
                unable[value[otail-1]][value[k]]=unable[value[k]][value[otail-1]]=true;
            }
        }
        otail=0;
    }
}
int main()
{
    //ios::sync_with_stdio(false);
    //cin>>t>>n;
    t=read();
    n=read();
    init();
    while(t--)
    {
        //cin>>x>>y;
        x=read();
        y=read();
        for(register int i=1;i<=n;++i)
        {
            //cin>>value[i];
            value[i]=read();
            result[i]=-1;
            hsh[i]=false;
        }
        shortest_path(x);
        //cout<<result[y]<<endl;
        printf("%d\n",result[x]);
    }
    return 0;
}
```

~~题面强调开o2，比赛时候卡了一个多小时常数都没卡过去才发觉不对。（虽然我自带大常数）~~

---

## 作者：GalwayGirl (赞：10)

## 题意简述
初看题目，觉得很容易，就是让你将除了 $1$ 之外的两两互质的点建边，边权取决于出发点，问从 $s$ 到 $t$ 的最短路。

## Solution
$n$ 的范围为 $4500$，互质的点建无向边的范围为将近 $3 \times 10 ^ 7$，暴力建边不成问题，那么跑边呢？~~恭喜你，喜提 50pts~~。

考虑本题与其他题目不同的地方，它的边权就是出发点。
再考虑一下 Dijkstra 的核心思想，就是贪心的将最短距离放入堆中，再提出来对终点进行松弛操作。对两种不同的边权画图分析。

1. 两点之间边权给出。

![](https://cdn.luogu.com.cn/upload/image_hosting/qdi9164t.png)

可以看到节点 1 和 节点 2 对 3 进行松弛，然后 1 又对 4 进行松弛，因为一个点与不同点的边权的差异性，导致每次都要将点提出来更新其他点。

2. 边权取决与点

![](https://cdn.luogu.com.cn/upload/image_hosting/1qfemftj.png)

因为每个点到其他点的边权是相同的，所以上图与下图是等价的。

![](https://cdn.luogu.com.cn/upload/image_hosting/ibij8ott.png)

可以发现当点到其他点边权相同时，点权加上边权为定值，所以在放入堆中时可以将点权加边权作为排序关键字，进行松弛操作时提出来的点一定是最优的，直接赋值即可，具体操作见此处代码。
```cpp
    S=read();T=read();
    for(int i=1;i<=n;i++)w[i]=read(),dis[i]=1e18,vis[i]=false;
    priority_queue<hh>q;
    q.push({S,w[S]});
    dis[S]=0;
    while(!q.empty()){
        int now=q.top().id;
        long long val=q.top().val;
        q.pop();
        if(vis[now])continue;
        vis[now]=true;
        for(int i=head[now];i;i=edge[i].next){
            int v=edge[i].to;
            dis[v]=val;
            if(v==T){
                printf("%lld\n",dis[T]);
                return;
            }
            q.push({v,dis[v]+w[v]});
        }
    }
```
所以在写类似优化的题时，一定要了解算法核心才能想办法优化。

最后贴上代码。
```cpp
#include<bits/stdc++.h>
using namespace std;
const int M=3e7,N=4600;
int t,n,c,head[N],S,T,w[N];
long long dis[N];
bool vis[N];
inline int read(){
    int x=0,w=1;char ch=0;
    while(ch<'0'||ch>'9'){
        if(ch=='-')w=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        x=(x<<1)+(x<<3)+ch-'0';
        ch=getchar();
    }
    return x*w;
}
struct xzh{
    int next,to;
}edge[M*2];
struct hh{
    int id;
    long long val;
    bool operator <(const hh&x)const{
        return x.val<val;
    }
};
void add(int u,int v){
    c++;
    edge[c].next=head[u];
    edge[c].to=v;
    head[u]=c;
}
int gcd(int a,int b){
    if(b==0)return a;
    return gcd(b,a%b);
}
void pre(){
    for(int i=2;i<=n;i++){
        for(int j=i;j<=n;j++){
            if(gcd(i,j)==1)add(i,j),add(j,i);
        }
    }
}
void solve(){
    S=read();T=read();
    for(int i=1;i<=n;i++)w[i]=read(),dis[i]=1e18,vis[i]=false;
    priority_queue<hh>q;
    q.push({S,w[S]});
    dis[S]=0;
    while(!q.empty()){
        int now=q.top().id;
        long long val=q.top().val;
        q.pop();
        if(vis[now])continue;
        vis[now]=true;
        for(int i=head[now];i;i=edge[i].next){
            int v=edge[i].to;
            dis[v]=val;
            if(v==T){
                printf("%lld\n",dis[T]);
                return;
            }
            q.push({v,dis[v]+w[v]});
        }
    }
}
int main(){
    t=read();n=read();
    pre();
    while(t--)solve();
}
```


---

## 作者：GOD_hj (赞：9)

## 题意

有 $n$ 个点的图，任意一点 $x$ 到可去另外一点 $y$ 必须互质，即 $\gcd(x,y)=1$。

图无边权，但是拥有点权。求到终点 $en$ 的最短距离。

---

## 思路

此题需使用 Dijkstra 算法求最短路。最后要求 $x$ 到 $y$ 的最短路径，如果直接暴力算最短路，肯定 TLE，怎么办呢？

考虑每次压入优先队列时，带上当前体力值，这样，就可以记录上次的最短距离。

---

**性质**

- Dijkstra 算法的运算特征：由当前最小值向连着的点拓展。
- 此图的特性：没有边权，只有从一点到走廊（边）上才会耗费体力值。

由此即可得：**当第一次对终点 $y$ 进行松弛操作时的值就是答案**。

---

## code

```cpp
#include<bits/stdc++.h>
#define k pair <int, int>//宏定义 
using namespace std;
const int N = 4.5e3+10;
static inline int read () {//快读 
	int x = 0；bool f = 1; char s = getchar();
	while(s<'0'||s>'9'){if(s=='-')f=0;s=getchar();}
	while(s>='0'&&s<='9'){x=(x<<1)+(x<<3)+(s^48);s=getchar();}
	return f?x:-x;
}
//inline:内联函数 

int T, n, a[N], h[N*N], cnt;//注意：一定是N*N!!! 
struct edge {int to, next;} e[N*N];

static inline void add(int x,int y){//链式前向星存图
	e[++cnt].to = y;
	e[cnt].next = h[x];
	h[x] = cnt;
}

bool vis[N];int dis[N];
priority_queue<k,vector<k>,greater<k> >q;//优先队列 pair型 

static inline void dijkstra(int s, int en){//求最短路 
	memset(dis, 0x3f, sizeof dis);
	memset(vis, 0, sizeof vis);
	priority_queue<k,vector<k>,greater<k> >().swap(q);//清零 且清空内存 
	dis[s] = 0;
	q.push(make_pair(dis[s]+a[s], s));//first:最小值 second:编号 
	while(q.size()){
		pair<int,int> u = q.top(); q.pop();
		int x = u.first, y = u.second;
		vis[y] = 1;
		for(int i = h[y]; i; i = e[i].next) {
			int v = e[i].to;
			if (vis[v]) continue;//松弛处理 
			if (dis[v] > dis[y]+a[y]){//从点到边耗费体力 
				dis[v] = x;//上次的值 
				if (v == en){
					printf("%d\n",dis[v]);
					return ;
				} q.push(make_pair(dis[v]+a[v], v));
			}
		}
	} puts("-1\n");//到不了 输出 -1 
	return ;
}

signed main(void){
	T=read();n=read();
	for(int i = 2; i < n; ++ i)
		for(int j = i+1; j <= n; ++ j)
			if(__gcd(i, j) == 1){//判断互质 ，最大公因数为 1 
				add(i, j);
				add(j, i);//无向图 
			}
	while (T --) {
		int x = read(), y = read();
		for(int i = 1; i <= n; ++ i) a[i] = read();
		dijkstra(x, y);//记得用快读，开 O2 
	}
	return 0;
}
```


---

## 作者：Morpheuse (赞：6)

###### ~~审核大大辛苦了~~

###### 其他大佬的方法不太适合我这个蒟蒻 所以就只好自己写一篇了



------------


## 题意简述：

给 $n$ 个点


其中 点 $i$ 能去到的点 $j$ 满足 $gcd(i , j) = 1$.

离开每个点都有代价,但是边没有代价.

求到达 $y$ 的最小代价


------------

这是一道好题 主要考察了我们对 $dij$ 求最短路这个算法的**理解** 如果只是~~像我一样~~背代码的同学可能无法很快想到这个题目的正解.

## 解题思路：


理解了题意(或者看完题意简述)之后就能知道:

题目是要我们求从 $x$ 到达 $y$ 的最小代价 毫无疑问直接上 $dij$. 

但是这个时间复杂度是 $O(Tmlogm)$, $m$ 表示边数,在 $n = 4500$ 的时候 $m$ 达到了 $6151496$ ，很明显 $1.5s$ 也跑不过去. 

那怎么办呢？

因为边是没有代价的 有代价的是开锁(门是向外锁上的)

所以如果我们每一次往优先队列里面加入的**排序关键字**带上了当前点的点权,设从优先队列中取出的点为 $k$ 且到 $k$ 的代价为 $f_k$, 就会满足一个性质：

- $f_k$ 是从起点到点 $k$ 的最优解.(其实这是废话)

让我们思考 $dij$ 的**过程:**

无非就是每次用 $f$ 最小且没有用过的点来更新其他没用过的点的 $f$ , 这个时候 如果 $f_i$ 用过了 那么 $f_i$ 一定就是从起点到点 $i$ 的最短距离.

如果你想问为什么这样是对的 那你可以深入思考一下 $dij$ 这个算法的核心 : **利用已知最小值对剩下的点进行扩展**.

那么 这个性质的正确性是不是显而易见了呢？

### 但是
如果只利用这个性质的话 不是 $MLE$ 就是 $TLE$ , 所以我们还是得想其他的优化方法

照上面所说 题目给我们的图有一个性质 : 边是没有权值的 有权值的是从一个点出去.

我们深入思考一下 就能发现这样一个更重要的性质

### 在第一次为终点 $y$ 松弛时 松弛的结果就是答案.

我们先考虑一下这个性质为什么在**其他题目**中不成立

因为对于边有权值的图 在我们用点 $i$ 对终点 $y$ 松弛之后 另外的一个点 $j$ 对 $y$ 进行松弛的结果可能更小. 

例如：

$f_i = 1 , f_j = 2 , i\to y:4 , j\to y:2$.

我们应该是先用 $f_i$ 对 $y$ 进行松弛 $f_y = 5$.

但是正确答案应该是用 $f_j$ 进行松弛 $f_y = f_j + 2 = 4$.

究其本质 是因为边 $i\to y $和 $j\to y$ 的权值无法确定.

而在我们这道题目中 , 因为出点有权值 , 所以如果我们把出点的权值看作边权 在每次进入优先队列的时候带上点权 , 那每一条边的权值就是确定的  根据优先队列的性质 在我们这道题目中 $f_j + (j\to y)$ 会比 $f_i + (i\to y)$ 优先考虑 也就满足了我上面所说的性质(具体可以看代码).


## code:


```cpp
#include<bits/stdc++.h>
#define maxn 4501
#define inf 0x3f3f3f3f
using namespace std;

struct edge
{
	int to , next;
}e[maxn * maxn];
int head[maxn],sum;
inline void add(int x , int y)
{
	e[++ sum].next = head[x];
	e[sum].to = y;
	head[x] = sum;
}

typedef pair<int , int> p;
int f[maxn],vis[maxn],a[maxn];
int t,n,x,y;

priority_queue<p , vector<p> , greater<p> > q;

void init()
{
	for(int i = 1 ; i <= n ; ++ i) f[i] = inf , vis[i] = 0;
	while(!q.empty()) q.pop();
}
int gcd(int x , int y)
{
	return y == 0 ? x : gcd(y , x % y);
}

void work(int st , int en)
{
	init();
	f[st] = 0;
	q.push(make_pair(a[st] , st));//权 点 
	while(!q.empty())
	{
		int top = q.top().first , po = q.top().second;//top 为代价 po 为点的序号 
		q.pop();
		if(vis[po]) continue;
		vis[po] = 1;
		for(int i = head[po] ; i ; i = e[i].next)
		{
			int to = e[i].to;
            if(vis[to]) continue;
			if(f[to] > f[po] + a[po])
			{
				f[to] = top;
				if(to == en)
				{
					printf("%d\n", f[to]);
					return;
				}
				q.push(make_pair(f[to] + a[to] , to));
			}
		}
	}
	printf("-1\n");
}

inline int read()
{
	int x = 0 ; char c = getchar();
	while(c < '0' || c > '9') c = getchar();
	while(c >= '0' && c <= '9') x = x * 10 + c - '0' , c = getchar();
	return x;
}
int main()
{
	t = read() , n = read();
	for(int i = 2 ; i <= n ; ++ i)
		for(int j = i ; j <= n ; j ++)
			if(gcd(i , j) == 1)//i j 互质 
				add(i , j) , add(j , i);
	while(t --)
	{
		x = read() , y = read();
		for(int i = 1 ; i <= n ; ++ i) a[i] = read();
		work(x , y);
	}
	return 0;
}
```

---

## 作者：π酱 (赞：5)

照例先扯淡

不知道大家有没有做过[P4473 [国家集训队]飞飞侠](https://www.luogu.org/problemnew/show/P4473)呢？如果没做过可以去看一下，那题的这道题就是用了飞飞侠的优化思想。有一次考试，我们考到了飞飞侠这道题，然后标程是分层图，由于我太菜了，没听懂就上网搜讲解，结果发现了一个神仙算法：Dijkstra+并查集优化（后来zcysky大佬也在洛谷上发了相关的题解，我也很不要脸的发了一篇，此处就不讲了），在看懂之后我就把那题的优化思路运用到了这里QAQ。

扯完了，下面开始讲题目。

先把题意简化一下：给你编号为$1$到$n$的$n$个点，两个编号互质的点可以连边，从相同的点出发的边权值相同，求给定两点之间最短路（其实除了$1$号点，其余每个点都是相互连通的，~~按照惯例输出$-1$的数据是不存在的~~）。

题目大致分成$2$部分：1.枚举$n$以内的互质点对；2.求最短路

对于第一部分，我本来是想卡一下暴力枚举，只让构造法过的，但是由于$n$太小，所以构造甚至跑的比暴力枚举还慢QAQ（难道是我写的太垃圾了？？？），所以......最后并没有卡。

但是还是讲一下构造法的思路吧（大家看看就好）：

1.首先预处理$1$~$n$中所有的质数

2.枚举$i=1$~$n$

3.对于每一个$i$，分解质因数，求出它使用了那些质数

4.从$i$没有使用过的质数中选取一些进行组合并使其小于$i$

代码如下（最短路部分没有优化）：
```
#include<bits/stdc++.h>
#define ll long long
#define INF 0x7f7f7f7f
using namespace std;
const int maxn = 105;
ll x[50010],Ans1,Su[10010],Fa[10010],Cnt,Ans,n,X,Dist[10010],w[10010];
bool Pd[10010],Used[10010],From[10010][10010];
int T,u,v,Head[10010],To[61000010],Next[61000010];
queue<ll> Q;
struct Node {
    int p,Dis;
} Now,N;
bool operator <(Node x,Node y) {
    return x.Dis>y.Dis;
}
priority_queue<Node> PQ;
template <typename T>
inline int Read(T &x) {
    x=0;
    int f=1;
    char c=getchar();
    while(c!='-'&&c>'9'&&c<'0')
        c=getchar();
    for(; !isdigit(c); c=getchar())
        if(c=='-')
            f=-f;
    for(; isdigit(c); c=getchar())
        x=x*10+c-'0';
    x*=f;
    if(c=='\n')
        return 1;
    else
        return 0;
}
inline void Write(long long x) {
    if(x<0) {
        putchar('-');
        x=-x;
    }
    if(x>9) {
        Write((x-x%10)/10);
    }
    putchar(x%10+'0');
}
inline ll Multi(ll a, ll b, ll p) {
    ll Ans1 = 0;
    while(b) {
        if(b & 1LL)	Ans1 = (Ans1+a)%p;
        a = (a+a)%p;
        b >>= 1;
    }
    return Ans1;
}
inline ll QPow(ll a, ll b, ll p) {
    ll Ans1 = 1;
    while(b) {
        if(b & 1LL)	Ans1 = Multi(Ans1, a, p);
        a = Multi(a, a, p);
        b >>= 1;
    }
    return Ans1;
}
inline bool MR(ll n) {
    if(n == 2)	return true;
    int s = 20, i, t = 0;
    ll u = n-1;
    while(!(u&1)) {
        t++;
        u >>= 1;
    }
    while(s--) {
        ll a = rand()%(n-2)+2;
        x[0] = QPow(a, u, n);
        for(i = 1; i <= t; i++) {
            x[i] = Multi(x[i-1], x[i-1], n);
            if(x[i] == 1 && x[i-1] != 1 && x[i-1] != n-1)	return false;
        }
        if(x[t] != 1)	return false;
    }
    return true;
}
inline ll Gcd(ll a, ll b) {
    if(b == 0)
        return a;
    else
        return Gcd(b, a%b);
}
inline ll Pollard_Rho(ll n, int c) {
    ll i = 1, k = 2, x = rand()%(n-1)+1, y = x;
    while(1) {
        i++;
        x = (Multi(x, x, n)+c)%n;
        ll p = Gcd((y-x+n)%n, n);
        if(p != 1 && p != n)	return p;
        if(y == x)	return n;
        if(i == k) {
            y = x;
            k <<= 1;
        }
    }
}
inline void Find(ll x, int c) {
    if(x == 1)	return;
    if(MR(x)) {
        Pd[x]=1;
        return;
    }
    ll p = x, k = c;
    while(p >= x) {
        p = Pollard_Rho(p, c--);
    }
    Find(p, k);
    Find(x/p, k);
}
inline void Add(int a,int b) {
    To[++Cnt]=a;
    Next[Cnt]=Head[b];
    Head[b]=Cnt;
    To[++Cnt]=b;
    Next[Cnt]=Head[a];
    Head[a]=Cnt;
}
void Dijkstra(int x) {
    Dist[x]=0;
    Now.Dis=0;
    Now.p=x;
    PQ.push(Now);
    while(!PQ.empty()) {
        Now=PQ.top();
        From[Now.p][0]=0;
        PQ.pop();
        if(!Pd[Now.p]) {
            Pd[Now.p]=1;
            for(int i=Head[Now.p]; i; i=Next[i]) {
                if(!Pd[To[i]]&&(!From[Now.p][Fa[To[i]]])&&(Dist[To[i]]>Dist[Now.p]+w[Now.p])) {
                    Fa[To[i]]=Now.p;
                    Dist[To[i]]=Dist[Now.p]+w[Now.p];
                    From[To[i]][Now.p]=1;
                    N.p=To[i];
                    N.Dis=Dist[Now.p]+w[Now.p];
                    PQ.push(N);
                }
            }
        }
    }
}
int main() {
    Read(T);
    Read(n);
    Cnt=0;
    for(int i=2; i<=5000; i++) {
        if(MR(i)) {
            Su[++Cnt]=i;
        }
    }
    Cnt=0;
    for(int i=1; i<=n; i++) {
        memset(Pd,0,sizeof(Pd));
        memset(Used,0,sizeof(Used));
        Find(i,57);
        for(int j=1; Su[j]<i; j++) {
            if(!Pd[Su[j]]) {
                Q.push(Su[j]);
                Ans++;
            }
        }
        while(!Q.empty()) {
            X=Q.front();
            Add(X,i);
            Q.pop();
            for(int j=1; Su[j]<=i; j++) {
                if(X*Su[j]<i&&(!Pd[Su[j]])&&(!Used[X*Su[j]])) {
                    Q.push(X*Su[j]);
                    Used[X*Su[j]]=1;
                    Ans++;
                }
            }
        }
    }
    while(T--) {
        fill(Dist,Dist+n+5,INF);
        memset(Fa,0,sizeof(Fa));
        memset(From,0,sizeof(From));
        memset(Pd,0,sizeof(Pd));
        Read(u);
        Read(v);
        for(int i=1; i<=n; i++) {
            Read(w[i]);
        }
        Dijkstra(u);
        Write(Dist[v]);
        putchar('\n');
    }
    return 0;
}
```

对于第二部分，相信大家一定都会写Dijkstra+堆优化，那么你就可以轻易得到50分了。

那剩下的50分呢？

其实仔细观察题目我们就会发现，从同一个点出发的边权值都相同，那么我们在把点压进优先队列时可以直接加上当前点的点权（即从当前点出发的边的权值），由于优先队列的性质，每次从优先队列中取出的点，其状态一定是最优解，而且其拓展出的状态也是最优解。证明如下：

假设点$x$已经得到了最短路，证明用该点更新的$y$也得到了最短路

反证，假设存在路径$x$′→$y$

使$Dist[y]$ 更小，且在$x$更新$y$之后，那么有$Dist[x$′$]+w[x]<Dist[x]+w[x]$，因为$x$′在$x$之后，有$Dist[x$′$]+w[x$′$]≥Dist[x]+w[x]$，两式矛盾，运用数学归纳法，可知上述结论成立，以及起点$s$到每一点的最短路径就是$Dist[i]$

其实和飞飞侠的证明是一样的（所以我就直接搬运了2333）。

这样的话，每个点第一次被访问到就一定是最优解，所以只要找到需要的点就可以直接退出了。

代码如下：
```
#include<bits/stdc++.h>
#define ll long long
#define INF 0x7f7f7f7f
using namespace std;
const int maxn = 105;
ll x[50010],Ans1,Su[5010],Cnt,Ans,n,X,Dist[5010],w[5010],Da;
bool Pd[5010],Used[5010];
int T,u,v,Head[5010],To[15000010],Next[15000010];
queue<ll> Q;
struct Node {
    int p,Dis;
} Now,N;
bool operator <(Node x,Node y) {
    return x.Dis>y.Dis;
}
priority_queue<Node> PQ;
template <typename T>
inline int Read(T &x) {
    x=0;
    int f=1;
    char c=getchar();
    while(c!='-'&&c>'9'&&c<'0')
        c=getchar();
    for(; !isdigit(c); c=getchar())
        if(c=='-')
            f=-f;
    for(; isdigit(c); c=getchar())
        x=x*10+c-'0';
    x*=f;
    if(c=='\n')
        return 1;
    else
        return 0;
}
inline void Write(long long x) {
    if(x<0) {
        putchar('-');
        x=-x;
    }
    if(x>9) {
        Write((x-x%10)/10);
    }
    putchar(x%10+'0');
}
//这回是正常的快速输入输出
inline ll Gcd(ll a, ll b) {
    if(b == 0)
        return a;
    else
        return Gcd(b, a%b);
}
inline void Add(int a,int b) {
    To[++Cnt]=a;
    Next[Cnt]=Head[b];
    Head[b]=Cnt;
    To[++Cnt]=b;
    Next[Cnt]=Head[a];
    Head[a]=Cnt;
}
void Dijkstra(int x) {
    Dist[x]=w[x];
    Now.Dis=w[x];
    Now.p=x;
    PQ.push(Now);
    while(!PQ.empty()) {
        Now=PQ.top();
        PQ.pop();
        if(!Pd[Now.p]) {
            Pd[Now.p]=1;
            for(int i=Head[Now.p]; i; i=Next[i]) {
                if(!Pd[To[i]]&&(Dist[To[i]]>Now.Dis)) {
                    if(To[i]==v){
                    	Da=Now.Dis;
                        return;
                    }
                    Dist[To[i]]=Now.Dis;
                    N.p=To[i];
                    N.Dis=Dist[To[i]]+w[To[i]];
                    PQ.push(N);
                }
            }
        }
    }
}
int main() {
    Read(T);
    Read(n);
    Cnt=0;
    for(int i=2;i<=n;i++){
    	for(int j=i+1;j<=n;j++){
    		if(Gcd(i,j)==1){
    			Add(i,j);
            }
        }
    }
    while(T--) {
        fill(Dist,Dist+n+5,INF);
        memset(Pd,0,sizeof(Pd));
        Read(u);
        Read(v);
        for(int i=1; i<=n; i++) {
            Read(w[i]);
        }
        Dijkstra(u);
        Write(Da);
        putchar('\n');
        while(!PQ.empty()){
        	PQ.pop();
        }
    }

    return 0;
}
```

---

## 作者：陌路的花 (赞：1)

对于这个题结论的简洁证明：

关于为什么将当前点的时间也放进优先队列后，松弛的时候第一次搜到终点 $t$ 时，那个值就是最小值.

这个问题等价于

> 证明每个点第一次被更新的时候就是到达它的最小时间花费.

考虑当前从队列里拿出来的值为 $x$ ，则根据性质可知其余 $x'\ge x$ .

由 $x$ 得到下一个点的时间写成 $x+d_v$ ，注意到它对于 $x'$ 同样适用，即

$x+d_v\le x'+d_v$ .

于是可知第一次搜到的时候就是最小值.

---

## 作者：出言不逊王子 (赞：0)

因为你不能同时出现在两个相同数的倍数的房间，所以你每次移动到的房间编号必须和你当前所在的房间编号互质。

所以我们如果建图，那么每个点只能往与其编号互质的点连边。

建完边跑一趟最短路就好。

但是注意到边权是点权，所以我们考虑把点权加到每个点的状态里面，每次选择当前时间最短的点进行松弛即可。

```cpp
#include<bits/stdc++.h>
#define fs(i,x,y,z) for(int i=x;i<=y;i+=z)
#define ft(i,x,y,z) for(int i=x;i>=y;i+=z)
#define ll long long
#define ull unsigned long long
#define db double
#define ms(a,b) memset(a,b,sizeof(a))
#define sz(a) sizeof(a)
#define pii pair<int,int>
using namespace std;
const int rw[]={-1,0,1,0,-1,1,-1,1},cl[]={0,1,0,-1,-1,1,1,-1};
const int N=4505,inf=0x3f3f3f3f;
inline int read(){
	int date=0,w=1;char c=0;
	while(c<'0'||c>'9'){if(c=='-')w=-1;c=getchar();}
	while(c>='0'&&c<='9'){date=date*10+c-'0';c=getchar();}
	return date*w;
}
vector<int> e[N]; 
int t,n,a[N],dis[N],s,p;
priority_queue<pii,vector<pii>,greater<pii>> q;
void mian(){
	s=read(),p=read();
	fs(i,1,n,1) a[i]=read();
	ms(dis,0x3f);dis[s]=0;
	q.push({a[s],s});while(!q.empty()){
		pii now=q.top();q.pop();
		int u=now.second,dist=now.first;
		if(dist-a[u]!=dis[u]) continue;
		for(auto v:e[u]){
			if(dis[v]>dist){
				dis[v]=dist;
				if(v==p) return void(printf("%d\n",dis[v]));
				q.push({dis[v]+a[v],v}); 
			}
		} 
	}
}
signed main(){
	t=read(),n=read();
	fs(i,2,n-1,1) fs(j,i+1,n,1) if(__gcd(i,j)==1) e[i].push_back(j),e[j].push_back(i);
	while(t--) mian();
	return 0;
}
//每个点的点权+1是边权 
```

---


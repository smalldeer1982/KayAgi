# 质数前缀统计

## 题目背景

这是洲阁筛和 Min_25 筛的重要前置知识。

## 题目描述

设 $S(n)$ 为 $n$ 以内质数的 $k$ 次方和。

给出 $N$，求下列式子的值。

$$\sum_{i=1}^{\lfloor\sqrt{N}\rfloor} i^2 S \!\left( \left\lfloor \frac{N}{i} \right\rfloor \right)$$

所有结果对给定的质数 $p$ 取模。



## 说明/提示

**样例解释** : 

$S \!\left( \left\lfloor \frac{N}{1} \right\rfloor \right)\! = S(10) = 2^3 + 3^3 + 5^3 + 7^3 = 503$。

$S \!\left( \left\lfloor \frac{N}{2} \right\rfloor \right)\! = S(5) = 2^3 + 3^3 + 5^3 = 160$。

$S \!\left( \left\lfloor \frac{N}{3} \right\rfloor \right)\! = S(3) = 2^3 + 3^3 = 35$。

$1^2 S \!\left( \left\lfloor \frac{N}{1} \right\rfloor \right)\! + 2^2 S \!\left( \left\lfloor \frac{N}{2} \right\rfloor \right)\! + 3^2 S \!\left( \left\lfloor \frac{N}{3} \right\rfloor \right)\! = 503 + 640 + 315 = 1458$。

| 测试点编号 | $N \le$ | $k \le$ | 时限 |
| :--: | :--: | :--: | :--: |
| $1\sim 3$ | $10^6$ | $10$ | $1\texttt s$ |
| $4\sim 7$ | $4\times {10}^{10}$ | $0$ | $3\texttt s$ |
| $8\sim 12$ | $4\times {10}^{10}$ | $10$ | $3\texttt s$ |

对于 $100\%$ 的数据，$0 \le k \le 10$，$1 \le N \le 4\times {10}^{10}$，${10}^9 < p < 1.01 \times {10}^9$。

## 样例 #1

### 输入

```
10 3 1000000007```

### 输出

```
1458```

## 样例 #2

### 输入

```
100000 0 1000000007```

### 输出

```
941229402```

## 样例 #3

### 输入

```
100000 10 1000000007```

### 输出

```
446053671```

# 题解

## 作者：command_block (赞：8)

我们考虑借鉴埃式筛法的思想,逐渐使用质数将不合法的数筛去。

- 引理 : 合数$m$必有一个$\sqrt{m}$以内的因子。

因此,实现埃式筛的时候,只需要利用$\sqrt{N}$以内的质数来筛除,就能正确地得到$N$以内所有的质数。

令$h(n,k)$表示埃式筛法枚举了前$k$个质数后,不超过$n$的,还剩下的数的$c$次方和,即

$$\sum\limits_{i=1}^n\large i^c\ \small[\text{i不含}\leq p_k\text{的素因子}]$$

我们以$k$**从小到大**的方式,筛去“**最小素因子**为$p_k$的数”,注意只筛到$\sqrt{N}$即可。

考虑每次减去被筛掉的数的贡献,可以得到递推式 :

$$h(n,k)=h(n,k-1)-p_k^c\begin{cases}{\big(h(\lfloor n/p_k\rfloor,k-1)-h(p_k-1,k-1)\big)}&(p^k\leq\sqrt{n})\\0&(p^k>\sqrt{n})\end{cases}$$

边界 : $h(n,0)=\sum\limits_{i=2}^ni^k$,此时只有$1$被筛去。

至于如何求解自然数幂和,不在本文的范围,可见 `P4593` & `CF622F` , 使用拉格朗日插值这部分复杂度为$O(k\sqrt{n})$

- **解释** :

我们必须不重不漏地选出最小素因子为$p_k$的数。

考虑埃式筛是怎么筛的 : 每次从已知的数范围内枚举$x$,如果其没有被筛掉,那么就能得到$x$没有小于$p_k$的素因子。

那么就能得到$x*p_k$最小素因子为$p_k$(**不重**),我们筛去$x*p_k$,这里能得到$x\leq\lfloor n/p_k\rfloor$。

不漏的性质显然。

这样子,我们去除$h(\lfloor n/p_k\rfloor,k-1)$的贡献。

注意到$h(p_k-1,k-1)$中的贡献都是质数,明显拥有小于$p_k$的素因子,这部分不应减去。

当$p_k>\sqrt{n}$时,有$h(n,k)=h(n,k-1)$,即没有数被筛除,结合引理容易理解。

形式上就是 : $\lfloor n/p_k\rfloor<p_k$。

------------

注意到我们在递推中需要利用$\lfloor n/p_k\rfloor$处的取值,有引理:
$\lfloor\frac{N}{ab}\rfloor=\left\lfloor\frac{\lfloor\frac{N}{a}\rfloor}{b}\right\rfloor$,比较经典,证明从略。

结合整除分块的结论,我们从$N$出发,除上一系列整数,只会得到$O(\sqrt{N})$种结果。

我们只用维护任意的$\lfloor N/d\rfloor$处的答案即可,这一共$O(\sqrt{N})$个。

接下来我们讨论实现方法。

- ① 

如果采用暴力实现,在每个质数处使用上述递推式,复杂度为:

质数个数$O(\frac{\sqrt{N}}{logN})$,维护的值$O(\sqrt{N})$,总复杂度为$O(\frac{N}{logN})$,无法通过。

- ②

注意到某些值在递推中是不会改变的,在递推式中不断`+0`。

有$O(\frac{\sqrt{m}}{logm})$个质数在转移时会影响到$h(m,?)$地值,取最大的$\sqrt{n}$个$\lfloor N/d\rfloor$积分,

总复杂度 : $O(\sum\limits_{d=1}^{\sqrt{N}}\frac{\sqrt{N/d}}{log(N/d)})=O(\frac{N^{3/4}}{logN})$,这也就是洲阁筛第一部分的经典复杂度。

大多数题目里,做到这样已经够了,由于代码简单,常数小,**实战中最为常用**。

- ③

当然,可以考虑利用朴素筛法预处理一部分,假设我们预处理$[1,K]$。

每次新加质数的时候都把$K$以内暴力筛除一遍,需要**树状数组**维护动态前缀和,复杂度$O(KlogK)$

递推的运算次数$O(\sum\limits_{d=1}^{N/K}\frac{\sqrt{N/d}}{logN})=O(\frac{N}{logN\sqrt{K}})$,不过注意到树状数组需要一个$O(logK)$,这部分复杂度为$O(\frac{N}{\sqrt{K}})$

总的复杂度就是$O(\frac{N}{\sqrt{K}}+KlogK)$,取$K=O((\frac{N}{logN})^{2/3})$可得复杂度为$O(N^{2/3}log^{1/3}N)\rightarrow O(N^{2/3+e})$。

这还不够优秀,并且由于常数问题,跑过暴力需要精细实现。

- ④

考虑省掉递推运算中的部分树状数组操作。

注意到$h(n,k)$中如果$p_k>\sqrt{n}$的话函数值不再改变,此时我们直接存下对应的函数值即可,没必要再使用树状数组。

观察$h(n,k)$递推式中使用的函数值:

$h(\lfloor n/p_k\rfloor,k-1)$

此时,这个函数值仍在变化的条件是$\sqrt{n/p_k}>p_k\rightarrow n>p_k^3$

也就是说,在$h(m,?)$的求值中有$O(\frac{\sqrt[3]{m}}{logm})$个树状数组操作,复杂度即为$O(\sqrt[3]{m})$。

这部分总复杂度是$O(\sum\limits_{d=1}^{N/K}\sqrt[3]{N/d})=O(\frac{N}{K^{2/3}})<O(\frac{N}{logN\sqrt{K}})$,可不计。

$h(p_k-1,k-1)$

这时该函数值早已确定,前缀和即可。

这样子的总复杂度是$O(\frac{N}{logN\sqrt{K}}+KlogK)$取$K=O(\frac{N^{2/3}}{log^{4/3}N})$可得复杂度为$O(\frac{N^{2/3}}{log^{1/3}N})\rightarrow O(N^{2/3-e})$。

- ⑤

想要更快的话请见 : zzt巨神 :《一些特殊的数论函数求和问题》(2018国家候选队队论文)

里面提出了一种$O((\frac{N}{logN})^{2/3})$的做法,但是实现较为复杂。

- ⑥ 听说有$O(\frac{n^{2/3}}{logn})$的做法。

------------

这里只给出$O(\frac{n^{3/4}}{logn}+k\sqrt{n})$的代码实现。

使用了一个除法优化。

```cpp
#include<algorithm>
#include<cstdio>
#include<cmath>
#define Limit 320000
typedef long long ll;
using namespace std;
int mod;
ll powM(ll a,int t)
{
  ll ans=1;
  while(t){
    if (t&1)ans=ans*a%mod;
    a=a*a%mod;
    t>>=1;
  }return ans;
}
int k,m;
ll lf[15],rf[15],ifac[15],y[15];
void Init()
{
  m=k+2;
  for (int i=1;i<=m;i++)
    y[i]=(y[i-1]+powM(i,k))%mod;
  ifac[0]=ifac[1]=1;
  for (int i=2;i<=m;i++)
    ifac[i]=ifac[mod%i]*(mod-mod/i)%mod;
  for (int i=2;i<=m;i++)
    ifac[i]=ifac[i]*ifac[i-1]%mod;
  lf[0]=1;
}
ll gPows(ll N)
{
  N%=mod;
  for (int i=1;i<=m;i++)
    lf[i]=lf[i-1]*(N-i)%mod;
  rf[m+1]=1;
  for (int i=m;i;i--)
    rf[i]=rf[i+1]*(N-i)%mod;
  ll ans=0;
  for (int i=1;i<=m;i++)
    ans=(ans+y[i]*lf[i-1]%mod*
         rf[i+1]%mod*ifac[i-1]%mod*
         ((m-i)&1 ? mod-ifac[m-i] : ifac[m-i]))%mod;
  return ans;
}
ll N,h0[Limit],h1[Limit];
int lim;
int main()
{
  scanf("%lld%d%d",&N,&k,&mod);
  Init();
  lim=sqrtl(N);
  for(int i=1;i<=lim;++i){ 
    h1[i]=gPows(N/i)-1; 
    h0[i]=gPows(i)-1;
  }
  for(int i=2;i<=lim;++i){
    h0[i]=(h0[i]+mod)%mod;
    if(h0[i]==h0[i-1])continue;
    ll x0=h0[i-1],r=(ll)i*i,p0=powM(i,k);
    int u=min((ll)lim,N/((ll)i*i)),uu=min(u,lim/i);
    for(int j=1;j<=uu;++j)
      h1[j]=(h1[j]-p0*(h1[j*i]-x0))%mod;
    ll t=N/i;
    if (t<(1ll<<31))
      for(int tt=t,j=uu+1;j<=u;++j)
        h1[j]=(h1[j]-p0*(h0[tt/j]-x0))%mod;
    else 
      for(int j=uu+1;j<=u;++j)
        h1[j]=(h1[j]-p0*(h0[t/j]-x0))%mod;
    for(int j=lim;j>=r;--j)
      h0[j]=(h0[j]-p0*(h0[j/i]-x0))%mod;
  }
  ll ans=0;
  for (int i=1;i<=lim;i++)
    ans=(ans+h1[i]*i%mod*i)%mod;
  printf("%lld\n",(ans+mod)%mod);
}
```

---

## 作者：myee (赞：3)

### 引言

来学洲阁筛，顺带补篇题解。

### 思路

设 $T=\lfloor\sqrt n\rfloor$。

设 $T$ 以内的质数由小到大依次为 $p_1,p_2,\dots,p_m$。

即求

$$
\sum_{i=1}^Ti^2S(\lfloor\frac ni\rfloor)
$$

对于 $S(y)$，我们把贡献拆成 $\le T$ 的质数与 $>T$ 的质数两部分。

$\le T$ 的部分显然可以预处理，考虑后半部分。

设

$$g(j,y)=\sum_{v=1}^yv^k[\forall1\le i\le j,p_i\nmid v]$$

显然后半部分贡献可以直接表示为 $g(m,y)-1$。

于是考虑如何快速计算 $g$。

对于 $g(0,y)$，

$$g(0,y)=\sum_{v=1}^yv^k$$

这个显然可以 Lagrange 插值，在 $O(k)$ 时间内计算单项。当 $k$ 是常数时，其可视作 $O(1)$。（以下均认为 $k$ 为常数，毕竟 $O(k\sqrt n)$ 实际上也几乎不影响总复杂度）

考虑对 $g(j,y)$ 做递推。

考虑 $j$ 增量 $1$ 时，哪部分贡献会被除去。

显然是是 $p_j$ 倍数的部分。

这部分的贡献可以与 $g(j-1,\lfloor\frac y{p_j}\rfloor)$ 的贡献构成双射，即

$$g(j,y)=g(j-1,y)-p_j^kg_k(j-1,\lfloor\frac y{p_j}\rfloor)$$

直接递推做的复杂度是 $O(\frac n{\log n})$ 的，需要优化。

考虑如下事实：

$p_{j+1}>y$ 时，$g(j,y)=1$。

因此当 $p_j\le y<p_j^2$ 时，

$$g(j,y)=g(j-1,y)-p_j^kg_k(j-1,\lfloor\frac y{p_j}\rfloor)=g(j-1,y)-p_j^k$$

也即，只用计算到最后一个使得 $p_j^2\ge y$ 的部分为止，剩下的 $p_j^k$ 的贡献可以后缀和预处理。

至此，总计算复杂度被优化至 $O(\frac{n^{\frac34}}{\log n})$。

### Code

注意本题要通过滚动数组优化空间到 $O(\sqrt n)$。

即，对同一个 $j$ 计算出其对多个 $y$ 的解。

方便起见，这里求自然幂和采用了伯努利数。

```cpp
typedef AnyMod::ModInt modint;
ullt SQRT(ullt v){
    ullt ans=sqrt(v);
    while(ans*ans<=v)ans++;
    while(ans*ans>v)ans--;
    return ans;
}
modint B[25],P[25],Q[25];
uint k;
modint S(modint n){
    if(k)n++;
    modint ans,v(1);
    for(uint i=k;~i;i--)ans+=P[k]*Q[i]*Q[k+1-i]*B[i]*(v*=n);
    return ans;
}
ullt T,Prime[200005];uint tp;
modint SufSum[200005],Val[200005];
uint Pre[200005];
std::vector<ullt>V;
modint M[400005];uint End[400005],Top[400005];
uint turn(ullt v){return std::lower_bound(V.begin(),V.end(),v,std::greater<ullt>())-V.begin();}
modint find(uint j,ullt v){
    uint a=turn(v);
    return M[a]-(SufSum[Top[a]]-SufSum[j]);
}
int main()
{
#ifdef MYEE
    freopen("QAQ.in","r",stdin);
    // freopen("QAQ.out","w",stdout);
#endif
    ullt n;uint p;scanf("%llu%u%u",&n,&k,&p);AnyMod::ChgMod(p),T=SQRT(n);
    P[0]=1;for(uint i=1;i<=k+1;i++)P[i]=P[i-1]*i;
    Q[k+1]=P[k+1].inv();for(uint i=k+1;i;i--)Q[i-1]=Q[i]*i;
    B[0]=1;for(uint i=1;i<=k+1;i++)for(uint j=0;j<i;j++)B[i]-=P[i]*Q[j]*Q[i-j+1]*B[j];
    for(ullt i=2;i<=T;i++){
        static bol B[200005];if(B[i])continue;
        Prime[++tp]=i;for(ullt j=i;j<=T;j+=i)B[j]=1;
    }
    for(uint v=0;v<=T;v++){
        uint l=0,r=tp;
        while(l<r){uint mid=(l+r+1)>>1;if(v<Prime[mid])r=mid-1;else l=mid;}
        Pre[v]=l;
    }
    for(uint i=tp;i;i--)SufSum[i-1]=SufSum[i]+(Val[i]=modint(Prime[i])^k);
    for(ullt l=1,r;l<=n;l=r+1)V.push_back(n/l),r=n/(n/l);
    for(uint i=0;i<V.size();i++)
        End[i]=Pre[std::min(T,SQRT(V[i]))],M[i]=S(V[i]);
    for(uint j=1;j<=tp;j++)for(uint i=0;i<V.size()&&End[i]>=j;i++)
        M[i]-=Val[j]*find(j-1,V[i]/Prime[j]),Top[i]++;
    modint ans;for(ullt i=1;i<=T;i++)ans+=(find(tp,n/i)+SufSum[0]-1)*i*i;
    ans.println();
    return 0;
}
```







---

## 作者：Prean (赞：3)

~~卡完常后来造福一下人类~~
## 如何从4.80s卡到920ms.jpg
![](https://cdn.luogu.com.cn/upload/image_hosting/xzj0rynq.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/uqba51ra.png)

本题解的复杂度为 $ O(\frac {n^{3/4}} {\log n}) $，然而标算是 $ O(\frac {n^{2/3}} {\log^{1/3} n}) $ 的。。。

有时间尝试卡一下标算，但是看样子好像已经卡过一些了，不知道能不能比我这个代码快（

首先亮出经典 DP：
$$ f(n,id)=f(n,id-1)-p_{id}^k \times (f(\frac n {p_{id}},id-1)-f(p_{id},id-1)) $$
然后你写完之后稍微卡一下，再吸个氧就能得到4.80s的代码了。

稍微卡一下指把DP的部分中的int和ll分开，并且线性筛进行了一些神奇的优化（

然后我们开始卡。

首先加了一个FastMod，速度变成了2.57s

然后众所周知的是，实数除法比整数除法要快，变成了1.31s。

然后我们知道线性筛的原理是 **用自身最小的质因子筛掉自己**，那么我们没有必要用除法，将其记录下来即可，1.13s。

然后我们将减法优化改成暴力取模，发现变成了1.06s。

然后由于我的DP过程中边界是这样判的：
```cpp
for(;j<=tot&&pri[i]<=(m1=w[j]*invp[i]);++j)
```
我们发现只需要将pri[top+1]改为INF就能够避免掉前面的那个`j<=tot`，这次卡进了1s，970ms。

然后由于我们DP时每次都计算了一遍`sum[i-1]+p`，我们就新开了一个变量s将其存下来，920ms。

### upd:把f中的n故技重施能卡到915ms。

不知道还能不能卡/youl

### upd:把前面的一些“优化”删掉之后跑了885ms。
```cpp
#include<cstdio>
#include<cmath>
typedef long long ll;
typedef __uint128_t L;
typedef unsigned long long ull;
const ll M=2e5+5;
int k,p,a[15],ifac[15],sl[15],sr[15];
int S,id1[M],id2[M];ll tot,g[M<<1];ll n,w[M<<1];
int top,F[17985],pri[17985],sum[17985],pos[M];bool zhi[M];
double invp[17985];
struct FastMod{
    ull b,m;
    FastMod(ull b):b(b),m(ull((L(1)<<64)/b)){}
    friend inline ull operator%(const ull&a,const FastMod&mod){
        ull q=(L(mod.m)*a)>>64;
        ull r=a-q*mod.b;
        return r>=mod.b?r-mod.b:r;
    }
}mod(2);
inline int pow(int a,int b){
	register int ans=1;
	for(;b;b>>=1,a=1ll*a*a%mod)if(b&1)ans=1ll*ans*a%mod;
	return ans;
}
inline void init(){
	register int i;k+=2;a[1]=sl[0]=sr[k+1]=ifac[0]=ifac[1]=1;
	for(i=2;i<=k;++i)a[i]=(a[i-1]+pow(i,k-2))%mod,ifac[i]=1ll*(p-p/i)*ifac[p%i]%mod;
	for(i=2;i<=k;++i)ifac[i]=1ll*ifac[i-1]*ifac[i]%mod;
	for(i=1;i<=k;++i)a[i]=1ll*ifac[i-1]*(k-i&1?p-ifac[k-i]:ifac[k-i])%mod*a[i]%mod;
}
inline int f(const int&n){
	register int i,N=n+p;register ull ans=0;
	for(i=1;i<=k;++i)sl[i]=1ll*sl[i-1]*(N-i)%mod;
	for(i=k;i>=1;--i)sr[i]=1ll*sr[i+1]*(N-i)%mod;
	for(i=1;i<=k;++i)ans+=1ll*sr[i+1]*sl[i-1]%mod*a[i];
	return ans%mod;
}
inline void sieve(const int&n){
	register int i=6,j,x,m;top=2;
	F[1]=pow(pri[1]=2,k);F[2]=pow(pri[2]=3,k);
	sum[1]=F[1];sum[2]=F[1]+F[2];
	invp[1]=1./2*(1+1e-15);invp[2]=1./3*(1+1e-15);
	do{
		if(!zhi[m=i-1]&&i-1<=n){
			pri[++top]=m;sum[top]=(sum[top-1]+(F[top]=pow(m,k)))%mod;
			invp[top]=1./m*(1+1e-15);
		}
		for(j=3;j<=top&&(x=m*pri[j])<=n;++j){
			zhi[x]=true;if((pos[x]=j)==pos[m])break;
		}
		if(!zhi[m=i+1]&&i+1<=n){
			pri[++top]=m;sum[top]=(sum[top-1]+(F[top]=pow(m,k)))%mod;
			invp[top]=1./m*(1+1e-15);
		}
		for(j=3;j<=top&&(x=m*pri[j])<=n;++j){
			zhi[x]=true;if((pos[x]=j)==pos[m])break;
		}
	}while((i+=6)-1<=n);pri[++top]=p;invp[top]=0;
}
void Solve(const ll&n){
	const ll&n9=n/1e9;
	register int i,j,k,s;register ll m,L=1,R;
	for(;L<=n;L=R+1,--g[tot]){
		R=n/(m=w[++tot]=1.*n/L);g[(m<=S?id1[m]:id2[R])=tot]=f(m%mod);
	}
	for(i=1;i<=top;++i){
		s=sum[i-1]+p;
		for(j=1;pri[i]<=(m=w[j]*invp[i]);++j){
			g[j]+=1ll*F[i]*(s-g[m<=S?id1[m]:id2[int(1.*n/m)]])%mod;
			if(g[j]>=p)g[j]-=p;
		}
	}
}
signed main(){
	register int i=1;register ull ans=0;
	scanf("%lld%d%d",&n,&k,&p);mod=FastMod(p);
	sieve(S=sqrt(n));init();Solve(n);
	for(register ll m;i<=S;++i){
		m=1.*n/i;
		ans+=1ll*i*i%mod*g[m<=S?id1[m]:id2[ll(1.*n/m)]]%mod;
		if(ans>=p)ans-=p;
	}
	printf("%d",ans);
}
```

---

## 作者：邮差将军 (赞：3)

- 题目大意：
设 $S(n)$ 为 $n$ 以内质数的 $k$ 次方和。求：
$$
\sum_{i=1}^{\lfloor\sqrt n\rfloor}i^2S\left(\left\lfloor\frac{n}{i}\right\rfloor\right)
$$


- 前置芝士：[拉格朗日插值](https://www.luogu.com.cn/problem/P4781)

可以在 $O(k)$ 的时间帮助我们快速计算 $\sum_{i=1}^{n}i^k$ 。

很明显这道题求的是 min_25 筛的第一部分。
关于 min_25 筛，[模版题](https://www.luogu.com.cn/problem/P5325) 讲的很详细了，简单再提两句：

设 $min(p)$ 为$i$的最小质因子，$p_j$为从小到大的第$j$个质数，设：

$$
g(n,j)=\sum_{i=1}^{n}[i\in prime\  ||\  min(p)>p_j]\cdot f(i)
$$
设 $f(j)$ 为质数处点值等于 $g(j)$ 的完全积性函数。则有转移方程：

$$
g(n,j)=
\begin{cases}
g(n,j-1)& {p_j^2>n}\\
g(n,j-1)-f(j)\left(g(\frac{n}{p_j},j-1)-g(p_{j-1},j-1)\right) & {p_j^2\leq n}
\end{cases}
$$
因此$g(n,0)$即为转移最开始，筛掉1之后所有数点值之和。采用滚动数组省略第二维。

注意到我们要求的 $i$ 值总是小于 $\sqrt{n}$，所以$S\left(\left\lfloor\frac{n}{i}\right\rfloor\right)$ 在转移中即对应 $g(i,tot)$，tot为n以内质数个数（即转移的轮次）。

另外注意一个细节：预处理出所有质数的 $k$ 次方，可以省掉快速幂的一个$log$，否则会超时。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int MAXN = 2e5 + 50;
int k, mod, inv6;
ll n, lim;

int prime[MAXN], num[MAXN], tot, sp[MAXN];
int powp[MAXN];
int x[15], y[15];
int s1[15], s2[15], ifac[15];

int ksm(int a, int b, int p)
{
    int ans = 1;
    for(; b; b >>= 1, a = 1LL * a * a % p) if(b & 1) ans = 1LL * ans * a % p;
    return ans;
}

void init()
{
    for(int i = 2; i < MAXN; i++)
    {
        if(!num[i])
        {
            prime[++tot] = i;
            sp[tot] = (sp[tot-1] + ksm(i, k, mod)) % mod;
        }
        for(int j = 1; j <= tot && i * prime[j] < MAXN; j++)
        {
            num[i*prime[j]] = 1;
            if(i % prime[j] == 0) break;
        }
    }
    for(int i = 1; i <= tot; i++) powp[i] = ksm(prime[i], k, mod);
    ifac[0] = ifac[1] = 1;
    for (int i = 2; i < 15; i++) ifac[i] = -1LL * mod / i * ifac[mod%i] % mod;
    for (int i = 2; i < 15; i++) ifac[i] = 1LL * ifac[i] * ifac[i-1] % mod;
    for(int i = 1; i <= k+1; i++)
    {
        x[i] = i;
        y[i] = (y[i-1] + ksm(i, k, mod)) % mod;
    }
    inv6 = ksm(6, mod-2, mod);
}

inline int Lagrange(int n, int *x, int *y, ll xi)
{
    ll ans = 0; xi %= mod;
    s1[0] = (xi - x[0] + mod) % mod; s2[n+1] = 1;
    for (int i = 1; i <= n; i++) s1[i] = 1LL * s1[i-1] * (xi-x[i]) % mod;
    for (int i = n; i >= 0; i--) s2[i] = 1LL * s2[i+1] * (xi-x[i]) % mod;
    
    for (int i = 0; i <= n; i++)
        (ans += 1LL * y[i] * (i == 0 ? 1 : s1[i-1]) % mod * s2[i+1] % mod
         * ifac[i] % mod * (((n-i)&1) ? -1 : 1) * ifac[n-i] % mod);
    return (ans % mod + mod) % mod;
}

inline int qm(int k, ll n)
{
    return Lagrange(k+1, x, y, n);
}

ll g[MAXN << 1], id1[MAXN << 1], id2[MAXN << 1], val[MAXN << 1];
void pre(ll n)
{
    lim = sqrt(n); int m = 0;
    for(ll l = 1, r; l <= n; l = r + 1)
    {
        r = n / (n / l);
        val[++m] = n / l;
        if(val[m] <= lim) id1[val[m]] = m;
        else id2[n/val[m]] = m;
        g[m] = (qm(k, val[m]) - 1 + mod) % mod;
    }
    for(int j = 1; j <= tot; j++)
    {
        for(int i = 1; 1LL * prime[j] * prime[j] <= val[i]; i++)
        {
            ll tmp = val[i] / prime[j];
            if(tmp <= lim) tmp = id1[tmp];
            else tmp = id2[n/tmp];
            g[i] -= 1LL * powp[j] * (g[tmp] - sp[j-1] + mod) % mod;
            if(g[i] < 0) g[i] += mod;
        }
    }
}

int sum(ll x)
{
    x %= mod;
    return x * (x+1) % mod * (2*x+1) % mod * inv6 % mod;
}

int solve()
{
    ll ret = 0;
    for(ll l = 1, r; l <= lim; l = r + 1)
    {
        r = n / (n / l);
        ll sz = sum(min(lim, r)) - sum(l-1) + mod; // sum是i^2前缀和
        ret += 1LL * sz * g[l] % mod; // g[l]就是n/l以内质数点值的前缀和
    }
    return ret % mod;
}

int main()
{
    scanf("%lld%d%d", &n, &k, &mod);
    init(); pre(n);
    printf("%d\n", solve());
    return 0;
}

```



---

## 作者：Zi_Gao (赞：1)

## 前言

借此篇题解记录一下 Min\_25 筛中的预处理所有 $S\left(\left\lfloor \frac{n}{i}\right\rfloor\right)$ 方法。

## 记号与约定

在本文中若无特殊说明，记号均采用以下定义：

- $\frac{a}{b}=\left\lfloor\frac{a}{b}\right\rfloor$。

- $p$ 表示一个质数。

- $p_i$ 表示第 $i$ 个质数，令 $p_0=1$。

- $\text{lpf}\left(n\right)$ 表示 $n$ 的最小质因子。

- $\text{isPri}\left(n\right)$ 表示 $n$ 是否是质数。

- 题面中的 $k$ 在本文中记作 $e$。同时 $k$ 失去原有定义。

## 正文

考虑直接求得 $S\left( \frac{n}{i}\right)$ 并不好求，于是我们考虑设计一种递推的方法，从全体小于 $n$ 的自然数开始，依次去掉最小质因子为 $p_i$ 的合数，这样做的好处非常明显，因为对于一个合数 $a$ 有 $\text{lpf}^2\left(a\right)\leq a$，所以我们令 $x$ 为最大的 $p_x^2\leq n$，那么 $g\left(n,x\right)=S\left(n\right)$，意思是只需要递推到 $x$ 即可，并且 $x$ 并不大可以粗略看作 $\mathcal{O}\left(\sqrt{n}\right)$ 的。定义 $g\left(n,k\right)$：

$$
g\left(n,k\right)=\sum_{i=1}^n \left[\text{isPri}\left(i\right)\lor\text{lpf}\left(i\right)\gt p_k\right] i^e
$$

自然有边界 $g\left(n,0\right)=\sum_{i=1}^n i^e$ 为了预处理这个边界可以参考 CF622F 一题，可以在 $\mathcal{O}\left(e\right)$ 内处理出单点值。

现在考虑从 $g\left(n,k-1\right)$ 递推到 $g\left(n,k\right)$，考虑这个过程中哪些数被踢了出去，自然是最小质因子为 $p_k$ 的合数，把 $p_k$ 提出来可以得到：$p_k^eg\left(\frac{n}{p_k},k-1\right)$ 但是这样把小于 $g\left(\frac{n}{p_k},k-1\right)$ 中小于 $p_k$ 质数会成为更小的质因子，所以是 $g\left(\frac{n}{p_k},k-1\right)-g\left(p_{k-1},k-1\right)$，最终递推式子：

$$
g\left(n,k\right)=g\left(n,k-1\right)-p_k^e\left(g\left(\frac{n}{p_k},k-1\right)-g\left(p_{k-1},k-1\right)\right)
$$

虽然 $k$ 只有 $\mathcal{O}\left(\sqrt{n}\right)$，但是第一维似乎还是很大？别急理性分析一波，第一维的形式一定类似于 $n$ 一直连除一些数向下取整的形式，由于有：

$$
\left\lfloor\frac{\left\lfloor\frac{n}{b}\right\rfloor}{b}\right\rfloor=\left\lfloor\frac{n}{ab}\right\rfloor
$$

所以，第一维只可能是 $\left\lfloor\frac{n}{i}\right\rfloor$ 中的取值，很经典地，我们知道这个东西取值只有 $\mathcal{O}\left(\sqrt{n}\right)$ 个，但是这两个上界都很不紧，继续通过一些列分析可以得到最终递推复杂度是 $\mathcal{O}\left(\frac{n^{0.75}}{\log n}\right)$ 的，具体过程可以参考 [OI Wiki 上的证明](https://oi-wiki.org/math/number-theory/min-25/#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90)。

## 代码

```cpp
#include<bits/stdc++.h>
// #define ONLINE_JUDGE
#define INPUT_DATA_TYPE long long
#define OUTPUT_DATA_TYPE int
INPUT_DATA_TYPE read(){register INPUT_DATA_TYPE x=0;register char f=0,c=getchar();while(c<'0'||'9'<c)f=(c=='-'),c=getchar();while('0'<=c&&c<='9')x=(x<<3)+(x<<1)+(c&15),c=getchar();return f?-x:x;}void print(OUTPUT_DATA_TYPE x){if(x<0)x=-x,putchar('-');if(x>9)print(x/10);putchar(x%10^48);return;}

long long mod;
int K;

long long qpow(register long long base,register long long e){
    register long long res=1;
    base%=mod;
    while(e){
        if(e&1) res=(res*base)%(mod);
        base=(base*base)%(mod);
        e>>=1;
    }
    return res;
}

#define INV_DATA_TYPE long long
INV_DATA_TYPE exgcd(INV_DATA_TYPE a,INV_DATA_TYPE b,INV_DATA_TYPE &x,INV_DATA_TYPE &y){
    if(!b){
        x=1;
        y=0;
        return a;
    }
    INV_DATA_TYPE d=exgcd(b,a%b,y,x);
    y-=a/b*x;
    return d;
}

INV_DATA_TYPE inv(INV_DATA_TYPE n,INV_DATA_TYPE p){
    n%=p;
    INV_DATA_TYPE x,y;
    exgcd(n,p,x,y);
    x%=p;
    return x>=0?x:x+p;
}

long long pl[20],pr[20],fac[20],y[20],b[20];

long long S_all(long long n){
    register int i;
    register long long ans=0,a;
    pl[0]=pr[K+3]=1;
    for(i=1;i<=K+2;i++) pl[i]=pl[i-1]*(n%mod-i)%mod;
    for(i=K+2;i>=1;i--) pr[i]=pr[i+1]*(n%mod-i)%mod;
    
    for(i=1;i<=K+2;i++){
        a=pl[i-1]*pr[i+1]%mod;
        (ans+=y[i]*a%mod*b[i]%mod)%=mod;
    }
    return (ans+mod)%mod;
}

long long sp[1000010],n;
long long g[1000010],val[1000010];

int sqrtN,cntId,idx_s[1000010],idx_b[1000010];

std::bitset<1000010> isPrime;
long long prime[1000010];
int cntPri;

void Euler(int n){
    register long long i,j;
    for(i=2;i<=n;++i){
        if(!isPrime[i]){
            prime[++cntPri]=i;
            sp[cntPri]=(sp[cntPri-1]+qpow(i,K))%mod;
        }
        for(j=1;j<=cntPri&&prime[j]*i<=n;++j){
            isPrime[prime[j]*i]=1;
            if(!(i%prime[j])) break;
        }
    }
}

int getIdx(long long a){
    if(a<=sqrtN) return idx_s[a];
    else return idx_b[n/a];
}

void initG(){
    register long long i,nxt,tmp;
    register int id;
    for(i=1;i<=n;i=nxt+1){
        nxt=n/(n/i);
        val[++cntId]=n/i;

        g[cntId]=(S_all(val[cntId])+mod-1)%mod;

        if(n/i<=sqrtN) idx_s[n/i]=cntId;
        else idx_b[n/(n/i)]=cntId;
    }

    for(register int i=1,j;i<=cntPri;++i){
        tmp=qpow(prime[i],K);
        for(j=1;j<=cntId&&prime[i]*prime[i]<=val[j];++j){
            id=getIdx(val[j]/prime[i]);
            (g[j]+=mod-tmp*(g[id]+mod-sp[i-1])%mod)%=mod;
        }
    }
    return;
}

long long inv6;

long long s2(long long n){
    n%=mod;
    return n*(n+1)%mod*(n*2+1)%mod*inv6%mod;
}

int main(){
	#ifndef ONLINE_JUDGE
	freopen("name.in", "r", stdin);
	freopen("name.out", "w", stdout);
	#endif

    register long long res=0,i,nxt;
    sqrtN=std::sqrt(n=read());
    K=read();
    mod=read();

    for(i=fac[0]=1;i<=K+2;i++) fac[i]=fac[i-1]*i%mod,y[i]=(y[i-1]+qpow(i,K))%mod;
    for(i=1;i<=K+2;i++) b[i]=inv(fac[i-1]*((K-i)&1?mod-1:1)%mod*fac[K+2-i],mod)%mod;
    
    inv6=inv(6,mod);

    Euler(sqrtN);
    initG();

    for(i=1;i<=sqrtN;i=nxt+1){
        nxt=std::min(n/(n/i),(long long)sqrtN);
        (res+=(s2(nxt)+mod-s2(i-1))*g[getIdx(n/i)])%=mod;
    }

    print(res);

	#ifndef ONLINE_JUDGE
	fclose(stdin);
	fclose(stdout);
	#endif
    return 0;
}
```

---


# [CQOI2016] 伪光滑数 加强版

## 题目背景

原题链接：[P4359 [CQOI2016] 伪光滑数](https://www.luogu.com.cn/problem/P4359)

## 题目描述

若一个大于 $1$ 的整数 $m$ 的**不去重**质因数分解有 $k$ 项，其最大的质因子为 $a_k$，并且满足 $a_{k}^{k} \leq n$，$a_k \leq 397$，我们就称整数 $m$ 为 $n$ - 伪光滑数。

给定整数 $n$，求出第 $k$ 大的 $n$ - 伪光滑数。

## 说明/提示

对于 $100\%$ 的数据，$1 < n \leq 10^{11}$，$k \geq 1$，保证至少有 $k$ 个满足要求的数。

## 样例 #1

### 输入

```
12345 20```

### 输出

```
9167```

# 题解

## 作者：konyakest (赞：4)

怎么题解全是左偏树，来发一个既简单常数又小的做法。

先考虑固定最大质数（假设是 $397$）时怎么做。

我们考虑这样一个质数表：

![](https://cdn.luogu.com.cn/upload/image_hosting/7p9ba8xg.png)

我们用红线表示选了这个数，上面显示的是所有质因子都选 $397$ 的情况。

我们假设有一个指针在这里：

![](https://cdn.luogu.com.cn/upload/image_hosting/w4ammj1b.png)

考虑移动这个指针来得到所有的答案。

每次有两种选择：

- 当前指针右移

![](https://cdn.luogu.com.cn/upload/image_hosting/80h6yca5.png)

- 移动指针到下一行，并右移

![](https://cdn.luogu.com.cn/upload/image_hosting/thdjank9.png)

同时，为了避免重复，我们要保证当前指针所在列不能大于上一行选的位置（也就是说，选出的数的位置单调不增）。

为了保证最大质数固定，最后一行选的位置不能移动。

容易用堆维护这个过程。每次取出值最小的状态，进行以上两种扩展即可。

证明：

- 每种状态**有且仅有只有一种方式**能被扩展到

- 每种状态扩展后的状态一定比这个状态的值要小

然后发现本题最大质因子不固定，把每一种最大质因子都加入初始状态即可。

时间复杂度 $O(k\log k)$，目前是本题和弱化版的[最优解](https://www.luogu.com.cn/record/161391733)

代码：

```cpp
constexpr int prs[]={397, 389, 383, 379, 373, 367, 359, 353, 349, 347, 337, 331, 317, 313, 311, 307, 293, 283, 281, 277, 271, 269, 263, 257, 251, 241, 239, 233, 229, 227, 223, 211, 199, 197, 193, 191, 181, 179, 173, 167, 163, 157, 151, 149, 139, 137, 131, 127, 113, 109, 107, 103, 101, 97, 89, 83, 79, 73, 71, 67, 61, 59, 53, 47, 43, 41, 37, 31, 29, 23, 19, 17, 13, 11, 7, 5, 3, 2};

struct DATA{
	int p,   //最大质因子在质数表中的位置
        k,   //最大的数 k 满足 pow(prs[p],k) <= n
	    las, //上一行的位置
        n,m; //指针坐标
	ll val;  //值
	friend bool operator<(const DATA& x,const DATA& y){return x.val<y.val;}
};

priority_queue<DATA> q;

signed main(){
	ll n;
	int k;
	cin>>n>>k;
	int tp=0;
	for(auto i:prs){
		ll j=1;
		int tot=0;
		while(__int128(j)*i<=n){
			j*=i,tot++;
			q.push({tp,tot,sizeof(prs)/sizeof(int)-1,1,tp,j});
		}
		tp++;
	}
	F(i,1,k-1){
		DATA d=q.top();
		q.pop();
		if(d.m<d.las&&d.n<d.k) q.push({d.p,d.k,d.las,d.n,d.m+1,d.val/prs[d.m]*prs[d.m+1]});
		if(d.m!=d.p&&d.n+1<d.k) q.push({d.p,d.k,d.m,d.n+1,d.p+1,d.val/prs[d.p]*prs[d.p+1]});
	}
	cout<<q.top().val<<endl;
	return 0;
}
```

---

## 作者：IkunTeddy (赞：4)

# 题目分析

首先，这是一个第 $k$ 大问题，又因为这个 $k$ 较小，所以我们优先考虑 k 路归并。

现在就该考虑，该记录什么进行归并。所以我们就该考虑答案的后效性，这样才能记录出所有答案进行 k 路归并。

通过阅读题目，我们可以很容易的得出答案有且只有两个后效性：

1. 最大素因子
2. 素因子个数

因为素因子是 $O(\log{N})$ 级别，而最大素因子最大为 $397$，所以我们可以考虑将所有后效性记录下来。

所以，我们设 $prime_i$ 为满足题目条件的第 $i$ 小的素数，$f_{i,j}$ 表示最大素因子为 $prime_i$ 且素因子个数为 $j$ 的满足条件的**元素集合**，$P$ 为所有满足题目素数的个数，这里 $P=78$。

这个集合明显可以递推，朴素方程也很简单。

$f_{i,j}= \bigcup\limits_{p=1}^{i-1} \bigcup\limits_{q=1}^{j-1} \{x \times {prime_{i}}^{j-q}\mid x \in f_{p,q} \}$。

我们就需要找一个数据结构支持：

1. 找最大，次大（k 路归并时要用到）。

2. 全局乘（递推时要用）。

3. 快速合并（递推时要用）。

第一个条件明显需要用到堆来维护，而第二个条件直接打懒标记，第三个条件考虑可并堆，而我们又要查询任意集合的值，所以需要保留任意版本，所以我们只能选择**可持久化左偏树**。

现在就是分析时间与空间了。总时间复杂度是 $O({\log{N}}^3 \times P^2)$，这是能就接受的。总空间复杂度也是 $O({\log{N}}^3 \times P^2)$。很明显不能接受，原因是因为合并次数太多了，所以我们考虑优化转移方程的枚举次数。

我们可以发现，其实没有必要枚举枚举 $q$ 这一维，所以考虑优化掉，然后我们可以得到：

$f_{i,j}=\bigcup\limits_{p=1}^{i}\{x \times prime_{i}\mid x \in f_{p,j-1} \}$。

这样，时间复杂度是 $O({\log{N}}^2 \times P^2)$，空间复杂度也是 $O({\log{N}}^2 \times P^2)$。这也开不下，继续优化。

这个方程显然是个前缀集合并，所以我们设 $g_{i,j}=\bigcup\limits_{p=1}^{i}f_{p,j}$。那么就可以得到：

$f_{i,j}=\{x \times prime_{i}\mid x \in g_{i,j-1} \}$。

这样，时间复杂度是 $O({\log{N}}^2 \times P)$，空间复杂度是 $O({\log{N}}^2 \times P)$。

哇，终于优化完了！

接下来就是基础的 k 路归并了。

总时间复杂度 $O({\log{N}}^2 \times P+k\log{N})$。

# Code

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int maxn=2e5+10;
const int Log=40+10;
const int P=80+10;
ll n;
int k;
int cnt=78,prime[P]={0,2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397};
int vis[P][Log];
int f[P][Log]; //最大质因子为prime[i]的集合，质因子数为j(在这里只用记录这棵左偏树的根)
int g[P][Log]; //前缀f[1~i][j];
// 
struct node{
	int ls,rs;
	ll val;
	int dist;
	ll tag;
}tree[6000000+10];
int nodecnt;
int newnode(ll val){
	int v=++nodecnt;
	tree[v].ls=tree[v].rs=0;
	tree[v].val=val;
	tree[v].dist=1;
	tree[v].tag=1;
	return v;
}
int copynode(int p){
	int v=++nodecnt;
	tree[v]=tree[p];
	return v;
}
int mul(int v,ll k){
	if(!v)return 0;
	v=copynode(v);
	tree[v].tag*=k;
	tree[v].val*=k;
	return v;
}
void pushdown(int v){
	if(tree[v].tag==1)return ;
	tree[v].ls=mul(tree[v].ls,tree[v].tag);
	tree[v].rs=mul(tree[v].rs,tree[v].tag);
	tree[v].tag=1;
}
int merge(int x,int y){
	if(!x||!y)return x|y;
	if(tree[y].val>tree[x].val)swap(x,y);
	x=copynode(x);
	pushdown(x);
	tree[x].rs=merge(tree[x].rs,y);
	if(tree[tree[x].ls].dist<tree[tree[x].rs].dist)swap(tree[x].ls,tree[x].rs);
	tree[x].dist=tree[tree[x].rs].dist+1;
	return x;
}
//
struct Queue{
	ll val;
	int p;
	bool operator < (const Queue &it)const{
		return val<it.val;
	}
};
priority_queue<Queue>que;
signed main(){
	cin>>n>>k;
	for(int i=1;i<=cnt;i++){
		ll s=1;
		for(int j=1;;j++){
			if(n/s<prime[i]){break ;}
			vis[i][j]=1;
			s=s*prime[i];
		}
	}
	for(int i=1;i<=cnt;i++){
		int rt=newnode(prime[i]);
		f[i][1]=rt;
		g[i][1]=merge(g[i-1][1],f[i][1]);
	}
	for(int j=1;j<=37;j++){
		for(int i=1;vis[i][j];i++){
			int rt=mul(g[i][j-1],prime[i]);
			f[i][j]=merge(f[i][j],rt);
			g[i][j]=merge(g[i-1][j],f[i][j]);
			que.push({tree[f[i][j]].val,f[i][j]});
		}
	}
	while(k--){
		Queue x=que.top();
		que.pop();
		if(!k){
			cout<<x.val<<'\n';
			break ;
		}
		pushdown(x.p);
		if(tree[x.p].ls) que.push({tree[tree[x.p].ls].val,tree[x.p].ls});
		if(tree[x.p].rs)que.push({tree[tree[x.p].rs].val,tree[x.p].rs});
	}
	
	return 0;
}
```

---

## 作者：Moeebius (赞：0)

考虑记 $f_{i,j}$ 表示 有 $i$ 个质因数，并且最大质因数为第 $j$ 的素数的合法数集。

容易发现，合法的充要条件是 $\text{Prime}_j^i \le n$。

考虑递推预处理 $f$。容易发现 $f_{i,j} = \bigcup _{k=1}^{j}(f_{i-1,j} \cdot \text{Prime}_{j})$

> 此处 $\text{Prime}_i$ 表示第 $i$ 个质数，$S\cdot x$ 表示把集合内的每个数都乘上 $x$。

发现这样转移的话，$f_{i,j}$ 两两不同，所以无需考虑去重的问题，只要把集合并起来就行了。

根据扩展贪心的套路，把每个 $f_{i,j}$ 看成一个数集，每次：
1. 从所有数集里面取出最大值。
2. 定位到最大值所属的数集。
3. 把这个最大值删了，并加入其在这个数集内的后继。

直到取满规定个数为止。

很明显，这样做时符合扩展贪心的性质的，即：**每个答案都可以由一个优于它的答案转移到，并且每个答案仅会被转移到一次**。

第 1、2 步很明显可以通过正常的堆来维护，但是如何快速完成预处理和第 3 步呢？

考虑到需要支持 **合并集合**，**取集合内最大值**，**全局乘上一个数**，**删除集合内最大值** 这些操作，想到可持久化可并堆。

但是可持久化可并堆是不支持 `pop` 操作的，否则复杂度升天。

考虑像 k 短路一样，退而求其次，每次加入堆内某个节点的两个子节点，以类似一种拓扑序的形式遍历整个堆。

然后就做完了，可持久化可并堆的部分比较难写，注意一定要按时下放标记。

[可持久化可并堆](https://www.luogu.com.cn/paste/6pjya6y5)

[主函数部分](https://www.luogu.com.cn/paste/twcqon0k)

---


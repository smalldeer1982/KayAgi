# 【模板】一般图最大匹配

## 题目背景

模板题，无背景。

## 题目描述

给出一张 $n$ 个点 $m$ 条边的无向图，求该图的最大匹配。

## 说明/提示

对于 $50\%$ 的数据，$n\le500$。

对于 $100\%$ 的数据，$2\le n\le10^3$，$1\le m\le5\times10^4$。

本题有 5 组 extra test。

####  提示
为了方便你调试你的程序，出题人在[这里](https://www.luogu.com.cn/paste/vf7dlo6r)为你提供了一个~~写的很丑的~~数据生成器。

## 样例 #1

### 输入

```
10 10
4 3
3 1
4 7
2 10
2 9
3 10
5 9
4 6
1 10
1 7
```

### 输出

```
4
7 9 10 6 0 4 1 0 2 3 ```

# 题解

## 作者：皎月半洒花 (赞：61)

upd: 改了一些小错误.
_____


本来想着随便写一发，$90$ 就 $90$ ~~咱也不带怂的~~ 。

然后就…过掉了…

顺便也过掉了 uoj 的 $52$ 组数据和 $43+$ 组的 `Extra Task` 。

考虑随机匹配。发现匹配本质上就是在找增广路，因为如果一个匹配 $\mathbf{M}$ 是图 $\mathbf{G}$ 的最大匹配的充要条件就是 $\mathbf{G}$ 中不存在增广路。

考虑直接枚举每个点找增广路会有什么问题。对于一张二分图，一条增广路要么是一条奇链、要么是一条奇链套一个偶环，偶环上总可以完备匹配，所以绕偶数步走到原点并不改变下一条边的匹配状态。但是奇环则未必，如果经过一个奇环，就必然会存在冲突的情况。

所以随机匹配的思想就是，不找环，只找长度为奇数的简单路。这样做相当于强制断环为链，正确性难以保证。但是考虑如果多做几次，错误率就会大大下降。于是考虑多做几次这样的匹配。注意到这样做很容易被卡掉，只需要多几个奇环顺便构造一下加边顺序就可以了。所以就可以每次走的时候将边表随一下即可。

然后…用 `rand()` 很容易被卡掉，因为值域很小，而边数比 $32768$ 大得多。所以用 `mt19937` 就可以了。

值得一提的是，以下代码为了保证正确，卡了时，大概是卡了 $0.85s$ 左右。但是十分有趣的是…洛谷的数据在 $0.0005s=0.5ms$ 的卡时范围之内都能过掉…这…咱也不知道该说什么好。

upd: 随机匹配似乎是无敌了。在 `uoj` 试了一发卡时 $0.005s=5ms$ 的情况，依旧无压力过掉了所有 $hack$ 数据。这个故事告诉我们：题是众生一般题，水是天下一样水。

```cpp

int ans ;
int n, m ;
int vis[N] ;
int match[N] ;

clock_t st ;

mt19937 g_f ;

il db now_time(){
    return (double)(clock() - st) / CLOCKS_PER_SEC ;
}
int do_match(int x, mt19937 g_f){
    cout << x << ' ' ;
    shuffle(E[x].begin(), E[x].end(), g_f) ; vis[x] = 1 ;
    for (auto y : E[x])
        if (!match[y])
            return vis[y] = 1, match[y] = x, match[x] = y, 1 ;
    for (auto y : E[x]){
        int z = match[y] ;
        if (vis[z]) continue ;
        match[x] = y, match[y] = x, match[z] = 0 ;
        if (do_match(z, g_f)) return 1 ;
        match[y] = z, match[z] = y, match[x] = 0 ;
    }
    return 0 ;
}
int main(){
    random_device seed ;
    mt19937 g_f(seed()) ;
    cin >> n >> m ; int x, y, z ;
    for (int i = 1 ; i <= m ; ++ i)
        x = qr(), y = qr(), add_e(x, y) ; st = clock() ;
    while (now_time() < 0.85){
        for (int i = 1 ; i <= n ; ++ i)
            if (!match[i])
                fill(vis + 1, vis + n + 1, 0), ans += do_match(i, g_f), puts("") ;
    }
    cout << ans << '\n' ;
    return debug(match, 1, n), 0 ;
}

```


---

## 作者：Singercoder (赞：43)

# 算法介绍

+ 算法简介：带花树算法，是一种在一般图中寻找最大匹配的算法。它是以匈牙利算法为基础，并特别加入了对奇数环的讨论后形成的。

+ 前置知识：**bfs**匈牙利算法+并查集

# 模板分析

直接以[uoj79](http://uoj.ac/problem/79)为模板讲解。luogu数据过水，无法卡掉所有错误做法。

1. 创造性的算法往往是在已有基础上改进形成的，带花树算法亦是如此。
  
   我们考虑在一个一般图中，不存在奇数环，即为一颗存在偶数环的树，可以想到直接对其进行二分图染色+匈牙利算法（二者可以同时进行）解决，这是带花树算法的基础框架。（code省略了部分细节）
   
```cpp
bool bfs(int s)
{
	while(!q.empty())
	{
		u=q.front();q.pop();
		for(int v=1;v<=n;++v)if(e[u][v])//枚举可达节点 
		{
			if(!col[v])//未遍历过，即遍历路径仍为树结构 
			{
				pre[v]=u;//记录前驱 
				if(!match[v]){aug(v);return 1;}//找到増广路终点，进行増广
				else{col[v]=2;col[match[v]]=1;q.push(match[v]);}//v点已有匹配，令u=match[v] 
			}
			else//环，处理见下 
		}
	}
	return 0;//増广失败 
}
```
  
2. 思考对奇数环的讨论。我们称奇数环为花，如下图所示：![](https://cdn.luogu.com.cn/upload/image_hosting/d964m39s.png)
  
   图中加粗边为已有匹配。定义每对已有匹配的出点为u（col=1，颜色为绿），入点为v（col=2，颜色为白）。（这仅是一种不严格的颜色命名）
   
   如果染色増广过程中发现了奇数环，则花的根节点必然为u型点。（想一想如果花根是v型节点，是否还会出现染色冲突？）
     
   以A点为起点进行染色増广。可见在染色过程中，I与J产生冲突。带花树算法的处理方法是：将花缩成一点，该点作为u型点向花外遍历，在修改増广路的时候再将花展开。（这只是一种理解方式，实现时并不真正进行缩展，而是用并查集模拟缩花的过程，用反向pre保证花内部増广路的正确）
   
   首先，我们考虑用一个并查集维护花根之间的关系（因为可能出现花套花的情况），即将花内所有分花根合并到新出现的总花根上。
   
   然后处理花内部的増广路关系，这是带花树算法的精髓：
     
   1. 在产生冲突前，奇数环上所有出点（即绿色点）都已进行了从环内向环外的遍历。
       
   2. 产生冲突后，我们分别以I和J为新増广路的u，向对方方向继续染色増广。可以发现，对方方向上原本的入点（即白色点），可以作为出点向花外遍历（如图中H->N），而这条増广路是从花内距花根较远的一条路延伸来的（如图中J->I->H->N)。
   
   3. 考虑如何记录这条较远的非常规路径。我们知道，在匈牙利算法中，对于每一对匹配中的入点v，我们都会有一个pre指向其前驱匹配的出点u（即图中的红色边），也就是说仅有v型点具有pre。
   
      然而在花中，所有点可以作为u型点向外遍历，也就没有了严格的u、v区分。因此无论u、v染色情况如何，我们为花中所有匹配对之间建立相互的pre，具体实现见下（注意由于原本已有部分pre，即红色边，我们要根据特殊性质去建立剩余的pre，即蓝色边）。
      
      特别注意，如果到了u为根节点，就不要再反向建立pre了，因为它所在匹配对并不完全属于花！
      
   这样，无论以哪个点作为u向环外遍历，我们在花内部都能得到正确的増广路。（想一想，以图中表示出的白色点和绿色点分别为起点，向花外遍历，其在花内体现出的増广路分别是什么样的？）
   
```cpp
else//环 
{
	if(get_fa(u)==get_fa(v))continue;//该环已被缩成一点，不必处理 
	if(col[v]==1)//奇数环，需要将花缩成花根一点 
	{
		//此时的u、v均为出点，不适用命名原则 
		int r=lca(u,v);//寻找lca，即总花根 
		shrink(u,v,r);//分别从两个方向，建立反向pre，保证花内部増广路正确性 
		shrink(v,u,r);
	}
	//偶数环不必处理 
}
```

3. 你可能会注意到上面的程序框架中出现了lca和shrink这两个函数。

   关于lca，我们只要朴素寻找总花根即可，因为遍历的起点总是在变的，无法用倍增lca来加速。
   
   关于shrink，思想就是上述对于花内増广路的维护，也就是建立反向pre。
   
   连带修改増广路的aug函数一起，code如下：
   
```cpp
void aug(int v)//从v点开始修改増广路 
{
	int t;
	while(v)
	{
		t=match[pre[v]];//临时记录下一次的v
		match[v]=pre[v];
		match[pre[v]]=v;
		v=t; 
	}
}
int cnt,vis[MAXN];
int lca(int u,int v)//寻找两个节点的总花根 
{
	++cnt;//每次lca选用不同的cnt作为判断条件 
	u=get_fa(u);//保证操作对象时刻为分花根 
	v=get_fa(v);
	while(vis[u]!=cnt)//某一点同时两次被染色，即为总花根 
	{
		vis[u]=cnt;
		u=get_fa(pre[match[u]]);//保证操作对象时刻为分花根 
		if(v)swap(u,v);//切换操作对象 
	}
	return u;
}
void shrink(int u,int v,int r)//以r为总花根，将花缩成花根一点，并建立内部的反向pre
{
	while(get_fa(u)!=r)//当已达到总花根，说明缩花任务完成 
	{
		//每次循环起初的v为上个匹配的v 
		pre[u]=v;//建立反向pre，保证増广路
		v=match[u];
		if(col[v]==2){col[v]=1;q.push(v);}//花内所有v，都应以u身份向外増广 
		if(get_fa(u)==u)fa[u]=r;//如果某一点为分花根，将其合并到总花根上 
		if(get_fa(v)==v)fa[v]=r;
		u=pre[v];//切换操作对象 
	}
}
```

于是基础的匈牙利算法和对奇数环的讨论全部完成，带花树算法成功得到实现。

# 时间复杂度

+ 同匈牙利算法，O（$n^3$）。

  不过常数肯定略大，且编程难度也大幅上升。

---

## 作者：Fuyuki (赞：37)

upd：修改了几处语病。

【模板】带花树算法

能使用匈牙利算法做出[这道题](https://www.luogu.com.cn/problem/P3386)会对理解本文有帮助。

定义图的一组匹配为图的一个边集，保证边集中的边两两没有公共定点。

定义一条边是匹配边当且仅当这条边属于一个匹配，一个点被匹配当且仅当这个点是一条匹配边的端点。

寻找图上的最大匹配常常使用增广路算法。在这里，一条增广路定义为一条起点和终点不相同且均未被匹配的路径，保证路径上的边是非匹配边和匹配边交替。

可以发现，增广路一定包含奇数条边，且将这些边依次翻转（即匹配边变成非匹配边，非匹配边变成匹配边）后得到的还是一组匹配。

这样，每找到一条增广路，就可以使得图中的匹配数量 +1。因此，一个匹配是最大匹配当且仅当图中不存在增广路。

对于二分图，可以使用匈牙利算法可以在 $O(nm)$ 的时间内求出最大匹配。

匈牙利算法寻找的增广路实际上是一条有向的增广路，其中的匹配边的方向是唯一的。这在二分图中是正确的，但是在一般图中，匹配边在增广路中的方向不是唯一的，这使得匈牙利算法中一个点不能被访问两次的限制错误。因此一般图的最大匹配不能用匈牙利算法求解。

一般图和二分图的区别只有奇环的有无，对于一个大小为 $2k+1$ 的奇环，最多只有 $k$ 对匹配，因此一定有至少一个节点能够向外匹配。同时，通过环内增广，每个节点都可以成为这个向外匹配的点。

因此，在求匹配的时候，一个奇环和一个节点是等价的，所以可以将奇环缩成点后当成二分图进行匹配。

将奇环缩成的节点叫做花，对原图用 bfs 找一条增广路，这棵节点可能是花的 bfs 树就称作带花树。

在带花树上 bfs，并尝试对访问到的节点进行黑白染色。假设起点是黑点，那么黑->白的边是非匹配边，白->黑的边是匹配边。遍历黑点的出边，如果访问到的点未被染色且未被匹配，那么就找到了一条增广路。如果被匹配了，则将该点染白色，将该点的匹配点染黑色并加入队列中。

如果访问到的点是白点，那么找到了一个偶环，没有影响无需处理。如果访问到的点是黑点，那么找到了一个奇环，在 bfs 树上找到这两个点的 lca 即可定位这个奇环，可以用并查集将其缩起来。因为缩起来的环是一个黑点，所以环上的白点都需改成黑点并加入到队列中。

为了方便地遍历这条增广路，对每个点存一个前驱 pre 表示这个点出发走一条非匹配边后应该到达哪个节点。被缩掉的环上的非匹配边的 pre 应该都是双向的，在缩环时处理一下。

可以发现，通过缩环减少一个点的复杂度为均摊 $O(logn)$，因为使用了并查集。找到一条增广路最坏情况下需要遍历整张图，复杂度为 $O(n+m)$。

因此，用带花树算法求出一般图最大匹配的复杂度为 $O(n(nlogn+m))$，通常可以当做 $O(nm)$（和匈牙利一样跑不满就是了）。

题外话，额外存一下每个花在树上的节点是哪一个就可以按秩合并了。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define I inline int
#define V inline void
#define FOR(i,a,b) for(int i=a;i<=b;i++)
#define REP(u) for(int i=h[u],v;v=e[i].t,i;i=e[i].n)
const int N=1e3+1,M=1e5+1;
queue<int>q;
int n,m,tot,qwq,ans;
int h[N],lk[N],tag[N],fa[N],pre[N],dfn[N];
struct edge{int t,n;}e[M];
V link(int x,int y){lk[x]=y,lk[y]=x;}
V add_edge(int x,int y){
	if(!lk[x]&&!lk[y])link(x,y),ans++;
	e[++tot]=(edge){y,h[x]},h[x]=tot;
	e[++tot]=(edge){x,h[y]},h[y]=tot;
}
V rev(int x){if(x)rev(x[pre][lk]),link(x,pre[x]);}
I find(int x){return fa[x]==x?x:fa[x]=find(fa[x]);}
I lca(int x,int y){
	for(qwq++;;x=x[lk][pre],swap(x,y))
		if(dfn[x=find(x)]==qwq)return x;
		else if(x)dfn[x]=qwq;
}
V shrink(int x,int y,int p){
	for(;find(x)!=p;x=pre[y]){
		pre[x]=y,y=lk[x],fa[x]=fa[y]=p;
		if(tag[y]==2)tag[y]=1,q.push(y);
	}
}
I blossom(int u){
	FOR(i,1,n)tag[i]=pre[i]=0,fa[i]=i;
	tag[u]=1,q=queue<int>(),q.push(u);
	for(int p;!q.empty();q.pop())REP(u=q.front())
		if(tag[v]==1)
			p=lca(u,v),shrink(u,v,p),shrink(v,u,p);
		else if(!tag[v]){
			pre[v]=u,tag[v]=2;
			if(!lk[v])return rev(v),1;
			else tag[lk[v]]=1,q.push(lk[v]);
		}
	return 0;
}
int main(){
	scanf("%d%d",&n,&m);
	for(int x,y;m--;add_edge(x,y))scanf("%d%d",&x,&y);
	FOR(i,1,n)ans+=!lk[i]&&blossom(i);
	cout<<ans<<'\n';
	FOR(i,1,n)cout<<lk[i]<<' ';
	return 0;
}
```

---

## 作者：Spasmodic (赞：21)

## 1.前言
[模板题](https://www.luogu.com.cn/problem/P6113)

[双倍经验，只是建图不同](https://www.luogu.com.cn/problem/P4258)

前置芝士:匈牙利算法。

下面进入正题。

## 2.带花树算法

由于我画图不好看，所以这里的图都是来源于[这个网站](https://www-m9.ma.tum.de/graph-algorithms/matchings-blossom-algorithm/index_en.html)，在此鸣谢。

首先，我们随便画了一张一般图，然后试着去用BFS版的匈牙利算法去执行。
![](https://cdn.luogu.com.cn/upload/image_hosting/8u0uw5qw.png)
然而，我们会发现在匈牙利算法执行到这里的时候，会出现死循环：
![](https://cdn.luogu.com.cn/upload/image_hosting/wopna6eq.png)
其中，蓝边是已匹配的边，灰色部分是BFS树，带红色圈的是正在找增光路的点，红点是目前找增广路的点，橙点是这个点的邻居。

其实这就是匈牙利算法最大的瓶颈：**奇环**。

在图中，$3-4-5-6-7$就是一个奇环，匈牙利算法遇到它就会产生死循环。

我们对这个奇环也做不了什么，于是我们只好把它缩成一个点，试图继续做。

缩完的这个点由于已经不是一个普通的点，于是我们给它起一个新的名字：**花**。于是这个操作就被称为**开花**。

缩完花之后图就变成了这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/gc2qzqgc.png)

缩完花了之后，我们很快就会发现找到了增广路，那就是$8-0-1-2-10-9$。

然后我们就可以再把$10$这个点还原成环，并且同时用环上的链连接原来被缩成花的2个点，得到的结果如图所示。
![](https://cdn.luogu.com.cn/upload/image_hosting/0gj1xhq2.png)
然后我们将匹配边重组，就可以得到最终的答案：
![](https://cdn.luogu.com.cn/upload/image_hosting/5urd4240.png)
上面的算法流程就被称为**带花树算法**。
## 3.实现
由于这题实现较为复杂，重点是开花，我借鉴了[yyb神仙的博客](https://www.cnblogs.com/cjyyb/p/8719368.html)。

首先，将队列中存在过的点染为黑色，黑点的匹配点染为白色，其余无色，则开花$\Leftrightarrow$两个点均为黑点

为了时空复杂度不太高，我们不能通过直接重构图来开花，于是我们额外维护一个并查集，将同朵花中的节点在并查集中合并。

具体的实现方法是，设我们找到的两个点为$u,v$，我们找到这两个点在BFS树上的LCA，称之为$w$，然后对$u-w$，$v-w$分别缩一下就好了。

我们先来看如何求LCA。
### 3.1 LCA
我们维护每个点的前驱$pre$和匹配点$match$，然后每次用$pre$和$match$轮流往上跳，边跳边打标记，如果发现碰上了那么就是LCA。

其实这相当于暴力跳，但是由于跳完以后还会缩点，每次总点数都会缩小相同的复杂度，因此均摊复杂度是$O(1)$的。

代码：
```cpp
inline int lca(register int u,register int v){
	for(++cnt,u=find(u),v=find(v);dfn[u]!=cnt;){
		dfn[u]=cnt;
		u=find(pre[match[u]]);
		if(v)swap(u,v);
	}
	return u;
}
```
### 3.2 开花
和前面同样的思路，我们考虑先将$u,v$用$pre$链接起来，然后两边同时跳，把所有白点全部变成黑点并扔进队列中即可。

同理均摊复杂度也是$O(1)$的。

代码：
```cpp
inline void blossom(register int x,register int y,register int w){
	while(find(x)!=w){
		pre[x]=y,y=match[x];
		if(vst[y]==2)vst[y]=1,q.push(y);
		if(find(x)==x)p[x]=w;
		if(find(y)==y)p[y]=w;
		x=pre[y];
	} 
}
```
最终代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1005;
int T,n,m,e,cnt,tot,ans,hd[N],p[N],match[N],pre[N],vst[N],dfn[N];
queue<int>q;
struct edge{int t,nxt;}es[N*N];
char ss[1<<17],*A=ss,*B=ss;
inline char gc(){return A==B&&(B=(A=ss)+fread(ss,1,1<<17,stdin),A==B)?-1:*A++;}
inline void read(register int&x){
    x=0;int s=gc();
    while(!isdigit(s))s=gc();
    while(isdigit(s))x=(x<<3)+(x<<1)+s-'0',s=gc();
}
void print(register int x){
    if(x>9)print(x/10);
    putchar(x%10+'0');
}
inline void Add(register int u,register int v){es[++tot]=(edge){v,hd[u]};hd[u]=tot;}
inline void add(register int u,register int v){Add(u,v),Add(v,u);}
int find(register int x){return x==p[x]?x:p[x]=find(p[x]);}
inline int lca(register int u,register int v){
	for(++cnt,u=find(u),v=find(v);dfn[u]!=cnt;){
		dfn[u]=cnt;
		u=find(pre[match[u]]);
		if(v)swap(u,v);
	}
	return u;
}
inline void blossom(register int x,register int y,register int w){
	while(find(x)!=w){
		pre[x]=y,y=match[x];
		if(vst[y]==2)vst[y]=1,q.push(y);
		if(find(x)==x)p[x]=w;
		if(find(y)==y)p[y]=w;
		x=pre[y];
	} 
} 
inline int aug(register int s){
	if((ans+1)*2>n)return 0;
	for(register int i=1;i<=n;++i)p[i]=i,vst[i]=pre[i]=0;
	while(!q.empty())q.pop();
	for(q.push(s),vst[s]=1;!q.empty();q.pop()) 
		for(register int u(q.front()),i(hd[u]),v,w;i;i=es[i].nxt){
			if(find(u)==find(v=es[i].t)||vst[v]==2)continue;
			if(!vst[v]){
				vst[v]=2;pre[v]=u;
				if(!match[v]){
					for(register int x=v,lst;x;x=lst)lst=match[pre[x]],match[x]=pre[x],match[pre[x]]=x;
					return 1;
				}
				vst[match[v]]=1,q.push(match[v]);
			}else blossom(u,v,w=lca(u,v)),blossom(v,u,w);
		}
	return 0;
}
int main(){
	read(n),read(m);
	for(register int i=1,u,v;i<=m;i++)read(u),read(v),add(u,v),add(v,u);
	for(register int i=n;i;--i)if(!match[i])ans+=aug(i);
	print(ans),putchar('\n');
	for(register int i=1;i<=n;i++)print(match[i]),putchar(' ');
	return 0;
}
```

---

## 作者：RemiliaScar1et (赞：12)

~~又开始乱学东西了~~

## 一般图的最大匹配—带花树算法

### 简介

在此之前，请先确保理解 >[二分图匹配](https://www.luogu.com.cn/problem/P3386)<

对于二分图的最大匹配，我们常用的便是找增广路+给点染白/黑色的匈牙利算法。

而二分图与一般图的区别就是，**二分图没有奇环，一般图有**。问题也就出在这个奇环上。

于是带花树算法(Jack Edmonds于1961年发表)就是来解决这个问题的

### 解析

看下图

![](https://img.imgdb.cn/item/6014b8e13ffa7d37b3b14a21.png)

当这个具有 $3$ 个点的奇环内存在 $1$ 对以上的匹配时，就会发生同色点匹配的情况，匈牙利直接 $O(+\infty)$ 了。

所以这时我们要在匈牙利的基础上，对前面的匹配进行修改。因此带花树的基本框架是BFS的匈牙利。

现在想想怎么修改比较好。

对于一个有 $2k+1$ 个点的奇环，其内部最多能有 $k$ 组匹配，同时有一个点匹配到环外的点。
我们可以**将奇环缩到一个点**，这个点向外匹配。剩下 $2k$ 个点两两匹配。这个缩完的点就叫**花**。

怎么缩环为点呢？我们需要明白，出现同色点匹配的情况，是由于我们从某个点开始搜出来的两条路径碰头了。现在我们要找到这个点。记这个点 $lca$ 为**最近公共花祖先**，也称**花根**。可以让两个同色节点交替往上跳，第一个重复点就是花根。由于求完花根我们就会缩环 ~~(开花)~~ ，所以暴力上跳的时间复杂度均摊下来并不高。

缩环时，我们利用一个记录前驱的 $pre$ 数组将环连接起来。将**所有的白点染黑然后让这些白点进队**以进行后面的增广操作。此时**整个花中全部变成了黑点，相当于整个花缩成了一个黑点**。为了方便修改以及寻找节点在花中的真正祖先(可能会出现套娃的现象)，我们可以使用并查集。

总时间复杂度约为 $O(nmlog\ n)$。

结合代码食用更佳

code:

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
#define rg register
const int N=1e4+10,M=5e5+10;

inline int read()
{
	rg int x=0,w=1;
	rg char ch=getchar();
	while((ch<'0'||ch>'9')&&ch!='-') ch=getchar();
	if(ch=='-') w=-1,ch=getchar();
	while(ch<='9'&&ch>='0') x=(x<<3)+(x<<1)+(ch-'0'),ch=getchar();
	return x*w;
}

int head[N],ver[M],nxt[M],tot=0;
void add(int x,int y)
{
	ver[++tot]=y;
	nxt[tot]=head[x];
	head[x]=tot;
}
int fa[N];
int find(int x)//并查集
{
	int x_root=x;
	while(fa[x_root]!=x_root) x_root=fa[x_root];
	while(x!=x_root)
	{
		int tmp=fa[x];
		fa[x]=x_root; x=tmp;
	}
	return x_root;
}
int match[N],pre[N];//记录匹配与前驱
int vis[N],dfn[N],tim=0;
int n,m,res=0;

int lca(int x,int y)//求花根
{
  /*dfn是一个标记数组，一边打标即一边上跳，第一个重复点就是花根
	花根一定是一个黑点，所以可以隔点上跳*/
	++tim;
	x=find(x);y=find(y);
	while(dfn[x]!=tim)
	{
		dfn[x]=tim;
		x=find(pre[match[x]]);
		if(y) swap(x,y);
	}
	return x;
}

queue<int> q;
void blossom(int x,int y,int w)//缩奇环(开花)
{
	while(find(x)!=w)
	{
		pre[x]=y;y=match[x];//
		if(vis[y]==2) vis[y]=1,q.push(y);//暴力染黑然后进队
		if(find(x)==x) fa[x]=w;
		if(find(y)==y) fa[y]=w;
		x=pre[y];
	}
}

bool solve(int S)//带花树
{
	for(int i=1;i<=n;i++) fa[i]=i,vis[i]=pre[i]=0;
	while(q.size()) q.pop();

	q.push(S);
	vis[S]=1;
	while(q.size())
	{
		int x=q.front();
		q.pop();
		for(int i=head[x];i;i=nxt[i])
		{
			int y=ver[i];

			if(find(x)==find(y)||vis[y]==2) continue;//y是白点或是同一花中的点
			if(!vis[y])//y还没有染色
			{
				vis[y]=2; pre[y]=x;
				if(!match[y])//没被匹配
				{
					for(int k=y,p;k;k=p)
						p=match[pre[k]],match[k]=pre[k],match[pre[k]]=k;//修改匹配
					return 1;
				}
				vis[match[y]]=1,q.push(match[y]);//被匹配过了
			}
			else //y是黑色点
			{
				int w=lca(x,y);
				blossom(x,y,w);
				blossom(y,x,w);//缩环两个方向各一次拼起来
			}
		}
	}
	return 0;
}

int main()
{
	n=read(),m=read();
	for(int i=1;i<=m;i++)
	{
		int x=read(),y=read();
		add(x,y); add(y,x);
	}

	for(int i=1;i<=n;i++)
		if(!match[i]) res+=solve(i);
	printf("%d\n",res);
	for(int i=1;i<=n;i++)
		printf("%d ",match[i]);
	return 0;
}

```


---

## 作者：lanos212 (赞：9)

### 前言

下文中的 $N$ 表示全图点数，$M$ 表示边数。

众所周知，二分图最大匹配可以在 $O(NM)$ 的时间复杂度内使用**增广路算法**解决。

虽然使用网络流建模解决二分图匹配可以获得更加优秀的复杂度，但是它很难被沿用到一般图上的匹配问题。

对于一般图最大匹配的**开花算法/带花树算法**，我们可以看作是一种**增广路算法**上拓展得到的算法。

如果已经熟练掌握二分图与一般图的关系，了解开花算法以处理奇环为主，可以直接跳至**开花算法/带花树算法**部分。

### 二分图匹配时遇到已访问点

先给出增广路的定义。

> **增广路**是一条路径，起始点未被匹配，终点未被匹配，中间经过的边以**非匹配边**与**匹配边**交替出现。

也就是长下面这样子的：（图中黑点表示被匹配点，白点表示未匹配点，特别加粗的边为匹配边）

![增广路](https://cdn.luogu.com.cn/upload/image_hosting/ge6wit41.png)

我们回顾一下增广路算法的可行性是怎么保证的。

首先，我们运用了**增广路定理**：当图上不存在增广路时，得到最大匹配。

而在二分图上，找增广路时遇到已经访问过的点比较好处理，如下图。

![](https://cdn.luogu.com.cn/upload/image_hosting/1dmqq8to.png)

如果遇到已经访问过的点，存在上图中的两种情况：

1. 当前增广路**出现环**，发现此时把环去掉仍然是一条增广路，所以遇到已访问的点就不用访问了。
2. 走到之前已经**增广失败**的点，发现此时继续走下去也一定无法增广，这种已访问点也无需访问。

综上所述，做二分图最大匹配时，搜索到已访问的点可以直接忽略，继续往别的点找增广路。

### 一般图匹配遇到已访问点

那么一般图匹配是不是也是都可以直接忽略呢？

显然不是，不然就可以用增广路算法做一般图匹配了。

我们不妨在一般图上考虑上面的情况。

注意，一般图和二分图的区别在于一般图**存在奇环**，我们会着重考虑**奇环**带来的影响。

我们还是考虑像二分图那样的两种情况：

![](https://cdn.luogu.com.cn/upload/image_hosting/5troqs1e.png)

1. 当前增广路**出现环**，发现环一定是偶环，这与二分图中相同。
2. 走到之前已经**增广失败**的点，如形成偶环走下去不能匹配，形成奇环走下去可能还能匹配。

这样我们只需要考虑经过奇环该怎么处理。

### 开花算法/带花树算法

先引入一个在搜索增广路时需对每个点记录一个值 $vis$。

我们将搜索增广路时经过边抠出来形成一颗生成树。（例图在下面）

- 当我们还没有访问到一个点 $x$ 时，$vis_x=0$。
- 当一个点 $x$ 在生成树上距离起始点长度为**奇数**时，$vis_x=2$。
- 当一个点 $x$ 在生成树上距离起始点长度为**偶数**时，$vis_x=1$。

为了方便一个点向起始点回跳，我们还需要对每个点记录一个值 $pre$。

$pre$ 的定义源于非匹配边，它记录如果要跳向父亲节点时，应该跳向哪个点。

当然，我们还要记录每个点和谁匹配。对于一个已匹配点 $x$，它匹配了 $match_x$ 这个点。

![](https://cdn.luogu.com.cn/upload/image_hosting/w612endx.png)

这个算法中，我们采用**宽度优先搜索**（BFS）来搜索增广路，以便于后面的操作。

注意，我们在 BFS 的过程中，进入队列的**只有 $vis=1$ 的点**。

我们可以先类似增广路算法去直接搜索增广路，那么我们需要处理这几种情况：

#### 到达的点 vis=2

这种情况形成了二分图最大匹配时出现的偶环问题，我们按照增广路算法的思路，不去管这个点。

#### 到达的点 vis=0，未匹配

找到增广路了，整条增广路翻转后结束搜索即可。

![](https://cdn.luogu.com.cn/upload/image_hosting/7bgueoc5.png)

对于具体实现，我们找到到达的点为 $x$，然后不断做下面的操作直到跳到起始点：

- 找到上一个点 $y$，上上个点 $z$，然后将 $match_x$ 改为 $y$，将 $match_y$ 改为 $x$，再让 $x$ 跳到 $z$ 的位置继续操作。

由于只有 $match$ 是对不同搜索过程共用，而别的记录的值都只用于当前起始点的搜索，所以我们只需要修改 $match$ 的值。

#### 到达的点 vis=0，已匹配

这个时候可以直接将到达点 $x$ 所匹配的点 $match_x$ 扔入队列，将 $vis_x$ 改成 $2$，将 $vis_{match_x}$ 改成 $1$。

#### 到达的点 vis=1

我们发现此时出现了奇环，而这个奇环上的边一定长成这个样子：

![](https://cdn.luogu.com.cn/upload/image_hosting/3vq6t1fg.png)

进入奇环的那条边一定是匹配边，之后两边以非匹配与匹配边交替。

而对于这种奇环，我们将整个奇环缩成一个点，不影响我们继续寻找增广路（这个点我们称为花，缩点的过程称为开花）。

因为对于任何一条进入奇环的出去的增广路，都可以对应一条经过花的增广路，同时一条经过花的增广路，也可以对应一条进入奇环出去的增广路，具体可见下图中的两个不同方向的例子：

![](https://cdn.luogu.com.cn/upload/image_hosting/hrb7owxg.png)

为了方便，我们缩点后的花实际放在奇环距离起始点最近的那个点上，我们称之为根。

下面是关于开花的具体实现方式。

对于缩点后图上边的问题，需要分两种考虑。

1. 环外到环的边，这些边我们在缩点后会将所有连出去的点都入队，可处理掉出环时的问题；缩点后用并查集维护当前点所在根，这样从外面走进环可以直接通过并查集找到根。

2. 环内的边只需要修改所有非匹配边，使得与根相连的点 $pre$ 连向根，其余的 $pre$ 在两个非匹配边间互相连对方，这样每个环上的点都能通过先跳向 $match$，再跳向 $pre$ 的方式到达根，可以结合下图中的两个不同方向的例子理解。

![](https://cdn.luogu.com.cn/upload/image_hosting/r32xdbmk.png)

注意到上面两种处理对环外走回环然后从根回去提供了截然不同的两种路线，一种是慢慢绕环，一种是直接并查集跳到根。

这两种是有区别的，慢慢绕环我们会在找到增广路后翻转时用到，直接并查集跳到根我们会在下面找花的根用到。

现在我们还剩下如何求花的根。

如果我们现在在点 $x$，要走到 $vis=1$ 的点 $y$，那么根就是 $x$ 和 $y$ 在生成树上的 LCA。我们可以让 $x,y$ 轮流向上跳，跳的方式是先跳 $match$，再跳 $pre$。当 $x,y$ 都经过同一个点时，就可以确定这个点是 LCA 了。

注意，每跳一步前，都要让当前点移到并查集指向的根，不然会多次经过已经被缩点缩掉的边，导致复杂度不正确。

在一般情况下，时间复杂度趋近 $O(NM +N^2\log N)$，而且和增广路算法一样跑不满。（具体一些细节导致我不会分析复杂度但反正跑的还是很快的 qwq）

一些具体实现比较麻烦，可以通过代码理解。

code
```cpp
#include<bits/stdc++.h>
using namespace std;
int tot,tag[1001],vis[1001],ma[1001],pre[1001],f[1001],n,m,ans;
vector<int> v[1001]; queue<int> q;
inline int find(int x){while (x!=f[x]) x=f[x]=f[f[x]]; return x;}
inline int lca(int x,int y){
	++tot;
	while (1){
		if (x){
			x=find(x); if (tag[x]==tot) return x;
			tag[x]=tot; x=pre[ma[x]];
		}
		swap(x,y);
	}
}
inline void flower(int x,int y,int p){ 
	while (find(x)!=p){
		pre[x]=y; y=ma[x]; vis[y]=1; q.push(y);
		if (find(x)==x) f[x]=p;
		if (find(y)==y) f[y]=p;
		x=pre[y];
	}
}
inline void bfs(int st){
	for (int i=1;i<=n;++i) pre[i]=vis[i]=0,f[i]=i;
	while (!q.empty()) q.pop();
	vis[st]=1; q.push(st);
	while (!q.empty()){
		int x=q.front(); q.pop();
		for (int y:v[x]) if (find(y)!=find(x) && vis[y]!=2){
			if (vis[y]==1){
				int l=lca(x,y); flower(x,y,l); flower(y,x,l); continue;
			}
			vis[y]=2; pre[y]=x;
			if (!ma[y]){
				int px=y;
				while (px){
					int py=pre[px],pz=ma[py];
					ma[px]=py; ma[py]=px; px=pz;
				}
				++ans; return;
			}
			vis[ma[y]]=1; q.push(ma[y]);
		}
	}
}
int main(){
	ios::sync_with_stdio(false); cin.tie(0);
	cin>>n>>m;
	for (int i=1;i<=m;++i){
		int x,y; cin>>x>>y;
		v[x].push_back(y),v[y].push_back(x);
	}
	for (int i=1;i<=n;++i) if (!ma[i]) bfs(i);
	cout<<ans<<'\n'; for (int i=1;i<=n;++i) cout<<ma[i]<<' ';
	return 0;
}
```

---

## 作者：Mars_Dingdang (赞：4)

这道题是一般图最大匹配的模板题，采用 BFS 增广+带花树算法求解。本题解参考陈胤伯《浅谈图的匹配算法及其应用》。

## 题目大意
给定一张 $n$ 个节点，$m$ 条边的无向图，求最大匹配以及构造一组解。

## 大体思路
类似二分图的最大匹配，我们尝试一般地对一个未盖点 $s$ 进行增广。

![](https://cdn.luogu.com.cn/upload/image_hosting/bg4ifnvu.png)

然而，如上图所示，$s\to t$ 虽然可达，但是将路径取反后某些点在两条匹配边上，不满足“匹配”的要求。注意到问题在于图中存在奇环，即长度为奇数的环。因此，一般图最大匹配的关键点在于如何处理奇环。

可以先将原图当作二分图，枚举每一个 $match=0$ 的未盖点 $s$，从 $s$ 开始交替地通过 BFS 寻找增广路。同时，我们对这棵交替树进行奇偶标号，将未访问点的 $vis$ 设为 $0$，队列中的点设为 $1$，被队列中的点扩展出的点 $vis\leftarrow 2$。每次只枚举 $vis=1$ 的点的出边。显然对于一个 $vis=1$ 的点 $u$，若 $\operatorname{edge}(u,v)\in E$ 且 $v$ 未访问，则 $vis(v)=2, vis(match_v)=1$。

由此可以构建出算法框架：设当前点为 $u$，扩展结点为 $v$。
- 若 $v$ 未访问，若 $v$ 是未匹配点则找到增广路，否则从 $v$ 的匹配点入队；

- 若 $v$ 已经访问过：表示找到了一个环。若环为偶环，即 $vis=2$ 则直接跳过（因为此时等价于二分图），否则是奇环，将环上的边缩成一个点（即所谓的开花），然后在新图中再寻找增广路。

设原图为 $G$，缩点后的图为 $G'$，可以证明 $G'$ 有增广路是 $G$ 有增广路的充分必要条件。更进一步地，缩点以后增广路的起点不变。因此上述算法成立。

具体地，我们用并查集求出花根（即交错树上环上所有点的 lca），并记录每个点的前驱。求解时不便于路径压缩，因此采用最基本的向上跳跃法。开花（blossom）时将所有遇到的 $vis=2$ 的点改成 $vis=1$ 并入队，然后通过修改并查集数组并入 lca 缩点。

这样，每一次 lca 求解和 blossom 复杂度为 $O(n)$，每一次 BFS 复杂度为 $O(n^2)$，所以总的复杂度为 $O(n^3)$。

## 完整代码
```cpp
#include <iostream>
#include <cstdio>
#include <queue>
using namespace std;
#define rep(ii,aa,bb) for(re int ii = aa; ii <= bb; ii++)
#define Rep(ii,aa,bb) for(re int ii = aa; ii >= bb; ii--)
typedef long long ll;
typedef unsigned long long ull;
typedef pair<int, int> PII;
typedef double db;
const int maxn = 100005;
namespace IO_ReadWrite {
	#define re register
	#define gg (p1 == p2 && (p2 = (p1 = _buf) + fread(_buf, 1, 1<<21, stdin), p1 == p2) ? EOF :*p1++)
	char _buf[1<<21], *p1 = _buf, *p2 = _buf;
	template <typename T>
	inline void read(T &x){
		x = 0; re T f=1; re char c = gg;
		while(c > 57 || c < 48){if(c == '-') f = -1;c = gg;}
		while(c >= 48 &&c <= 57){x = (x<<1) + (x<<3) + (c^48);c = gg;}
		x *= f;return;
	}
	inline void ReadChar(char &c){
		c = gg;
		while(!isalpha(c)) c = gg;
	}
	template <typename T>
	inline void write(T x){
		if(x < 0) putchar('-'), x = -x;
		if(x > 9) write(x/10);
		putchar('0' + x % 10);
	}
	template <typename T>
	inline void writeln(T x){write(x); putchar('\n');}
}
using namespace IO_ReadWrite;
int n, m, head[maxn], tot, ver[maxn], nxt[maxn];
queue <int> q;
bool del[maxn];
inline void add(int u, int v) {
	ver[++tot] = v; nxt[tot] = head[u]; head[u] = tot;
	ver[++tot] = u; nxt[tot] = head[v]; head[v] = tot;
}
int fa[maxn], vis[maxn], pre[maxn], match[maxn], dfn[maxn], timer;
inline int find(int k) {
	if(k == fa[k]) return k;
	return fa[k] = find(fa[k]);
}// 并查集
inline int lca(int u, int v) {
	timer ++;
	u = find(u), v = find(v);
	while(dfn[u] != timer) {// 若相等则表示找到 lca
		dfn[u] = timer;
		u = find(pre[match[u]]); // 向上跳跃
		if(v) u ^= v ^= u ^= v; // 轮流跳跃
	}
	return u;
}
inline void blossom(int x, int y, int z) {
	while(find(x) != z) {// 当没有全部缩完
		pre[x] = y; y = match[x];
		if(vis[y] == 2) {//遇到偶点
			vis[y] = 1;
			q.push(y);
		}
		if(x == find(x)) fa[x] = z;
		if(y == find(y)) fa[y] = z;//若本身是根直接并入 lca
		x = pre[y];
	}
}
inline bool bfs(int s) {
	rep(i, 1, n) {
		fa[i] = i;
		vis[i] = pre[i] = 0;
	}
	while(!q.empty()) q.pop();
	q.push(s); vis[s] = 1;//初始化
	while(!q.empty()) {
		int u = q.front(); q.pop();
		for(int i = head[u]; i; i = nxt[i]) {
			int v = ver[i];
			if(vis[v] == 2 || find(u) == find(v)) continue;
			// 偶环或已经开花则忽略 
			if(vis[v] == 0) {// 若没有访问过 
				vis[v] = 2; pre[v] = u;
				if(!match[v]) {//未盖点：找到增广路 
					for(int x = v, lst; x; x = lst) {
						lst = match[pre[x]];
						match[x] = pre[x];
						match[pre[x]] = x;
					}// 路径取反
					return 1;
				}
				vis[match[v]] = 1;
				q.push(match[v]);// 否则从 match[v] 开始扩展 
			} // 找到奇环：求lca，开花 
			else {
				int w = lca(u, v);
				blossom(u, v, w); blossom(v, u, w);
			}
		}
	}
	return 0;
}
int main () {
	read(n); read(m);
	rep(i, 1, m) {
		int u, v;
		read(u); read(v);
		add(u, v);
	}
	int p = 0;
	rep(i, 1, n) //枚举未盖点进行增广
		if(match[i] == 0) p += bfs(i);
	writeln(p);
	rep(i, 1, n) write(match[i]), putchar(' ');
	return 0;
}
```
当然，你也可以用一般图最大权匹配的带权带花树解这道题，只要将边权都设为 1 即可。

---

## 作者：花淇淋 (赞：3)

[blog链接](https://www.cnblogs.com/cyf32768/p/13380851.html)

## Description
给定一张 $n$ 个点 $m$ 条边的无向图，求最大匹配。

要求输出每个点对应的匹配点。

$n\le 500,m\le 124750$。

时空限制 $\text{1s/256MB}$。
## Solution
以下内容参考：陈胤伯《浅谈图的匹配算法及其应用》 

### 一些相关定义

 - 交替路：匹配边和非匹配边交替出现的路径。
 - 交替树：根到任意一点的路径，都是交替路。
 - 未盖点：未匹配的点。
 - 增广路：路径为交替路，且开头和结尾都是未盖点。
 - 交替环：匹配边和非匹配边交替出现的环。
 - 增广：把路径上每条边的状态取反，即匹配边变为非匹配边，非匹配边变为匹配边。

### 初步思路

我们先按二分图匹配来做。

枚举一个未盖点 $s$，从 $s$ 开始 DFS，尝试找出一条以 $s$ 开头的增广路。

这样会 DFS 出一棵以 $s$ 为根的交替树。

记一个数组 $vis_u$，$vis_u=1$ 表示 $u$ 在交替树上到 $s$ 的距离为偶数，$vis_u=2$ 则为奇数。若 $vis_u=0$，表示还没访问到 $u$。 

令 $match_u$ 表示 $u$ 的匹配点，没有则为 $0$。

设当前 DFS 到 $u$，$u$ 是红点，枚举和 $u$ 相连的点 $v$：

 - $vis_v=2$，说明找到一个交替环，什么也不用做。
 - $vis_v=0,match_v=0$，这时候起点 $s$ 和终点 $v$ 都是未盖点，且 $s→v$ 为交替路，因此 $s→v$ 是一条增广路。那么将 $s→v$ 增广，然后结束 DFS。
 - $vis_v=0,match_v\ne 0$，继续 DFS $match_v$。
 
以上三种都是二分图匹配中出现的情况。

**一般图由于可能存在奇环，还会有 $vis_v=1$ 的情况。**

具体地，令 $p$ 为 $u,v$ 在交替树上的 $lca$，则树上路径 $p→v,u→p$，以及非树边 $(u,v)$ 组成了一个奇环。

这里先给出做法：把这个奇环上的所有边删掉，并把整个环缩成一个点 $p$。即对于环上任意一点 $x$，如果存在边 $(x,y)$ 满足 $y$ 不在环上，那么删除 $(x,y)$，连接 $(p,y)$。

然后，在缩点之后的新图中，重新寻找增广路。

接下来证明缩点的正确性，也就是要证明：设原图为 $F$，缩点之后的图为 $G$，那么：

 1. 如果 $F$ 有增广路，那么 $G$ 也有增广路。
 2. 如果 $G$ 有增广路，那么 $F$ 也有增广路。
 
如果上述两点均成立，那么 $F$ 和 $G$ 就是等价的，也就是缩点是合法的。

### 证明第一点

我们将 $F$ 中 $s→p$ 这一条路径上的边状态全部取反，得到 $F_1$。将 $G$ 也通过同样的变换得到 $G_1$。

我们发现 $s→p$ 路径长度必为偶数，即必有 $vis_p=1$。因为在交替树中，$p$ 有至少两个儿子，所以 $match_p$ 肯定是 $p$ 的父节点，$p$ 和儿子的边肯定是非匹配边。

而交替树中，$s$ 和儿子的边肯定也是非匹配边，因为 $s$ 是未盖点。所以 $vis_p=vis_s=1$。

这说明了，$F$ 和 $F_1$ 中的匹配数相同。

如果 $F$ 有增广路，那么说明 $F$ 的匹配不是最大匹配，那么 $F_1$ 中的匹配也不是最大匹配。根据定理：$F$ 的匹配是最大匹配，充要条件是 $F$ 中不存在增广路。可知 $F_1$ 也有增广路。

同理如果 $G_1$ 有增广路，那么 $G$ 也有增广路。

**现在只要证明，如果 $F_1$ 有增广路，那么 $G_1$ 有增广路。**

 1. 如果增广路没经过这个奇环，那么我们可以在 $G_1$ 中找到一条一样的增广路。
 2. 如果经过奇环：设 $F_1$ 存在一条增广路为 $s→t$，且第一个在环上的点为 $x$。那么我们把增广路改为 $s→x→p$，且 $x→p$ 为环上路径。因为 $s→x,x→p$ 都是交替路，而 $s,p$ 在 $F_1,G_1$ 中都是未盖点，所以 $s→x→p$ 是一条合法的增广路。将其对应到 $G_1$ 中，相当于走到缩成的新点 $w$，就停下来。而 $w$ 也是未盖点（$w$ 相当于 $F_1$ 的 $p$），那么 $G_1$ 的 $s→w$ 也是增广路。
 
证毕。
 
### 证明第二点

和证明第一点一样，我们只要证明：

**如果 $G_1$ 有增广路，那么 $F_1$ 有增广路。**

同样只需考虑增广路经过缩成的新点（奇环）的情况。

已知 $w$ 是未盖点，那么经过 $w$ 的增广路，可以改成以 $w$ 结尾。

考虑 $G_1$ 中增广路以 $w$ 为结尾的边 $(x,w)$。在 $F_1$ 中，找到环上的一个点 $y$ 使得存在边 $(x,y)$，那么 $F_1$ 中的增广路可以是：$s→x→y→p$。

证毕。

### 具体实现

还是枚举未盖点 $s$，寻找以 $s$ 为开头的增广路。

但是不用 DFS，改用 BFS。

BFS 的过程中，还需要对每个点 $u$ 维护以下信息：

 - $u$ 所在的花中，深度（指到 $s$ 的树上距离）最小的点是哪个，可以使用并查集。
 - $pre_u$：若 $vis_u=1$，则 $match_u$ 是父节点，否则 $pre_u$ 是父节点。$pre_u$ 的记录可以便于增广。

先把 $s$ 加入队列，并标记 $vis_s=1$。

每次取出队头 $u$，枚举与其相连的点 $v$。

 - $vis_v=2$，或 $v,u$ 已经被缩成同一个点（同一朵花）了，什么也不用做。
 - $vis_v=0,match_v=0$，令 $pre_v=u$，增广 $s→v$。
 - $vis_v=0,match_v\ne 0$，令 $pre_v=u$，并把 $match_v$ 加入队列。
 - $vis_v=1$，令 $p=lca(u,v)$，将奇环上的点缩掉。
 
**找 $lca(u,v)$：**

注意到 $vis_u=vis_v=1$，即 $u,v$ 的深度均为偶数。那么可以轮流让 $u,v$ 向上跳两步，即依次执行 $u=pre_{match_u},v=pre_{match_v},u=pre_{match_u},v=pre_{match_v}$。

当然如果某一步无法再向上跳了，就跳过这一步。我们把经过的点全部标记，如果走到了已经有标记的点，就是 $lca$ 了。

注意 $u$ 每跳一步都要执行 $u=find(u)$，即找并查集的根，$v$ 也是，不然会凉。这个原因下面会讲。

**将路径 $(u,p),(v,p)$ 缩成一朵花：**

要做三件事：

 1. 因为环上所有点都跟 $p$ 合并了，所以要把环上所有 $vis=2$ 的点全部标记 $vis=1$，并加入队列。
 2. 把环上每个点所在的并查集都跟 $p$ 所在的并查集合并。
 3. 修改 $pre$ 数组，使得对于环上任意一条非匹配边 $(x,y)$，都有 $pre_x=y,pre_y=x$。 此时环上的 $pre_x$ 就是 $x$ 走环上非匹配边到达的点，$match_x$ 就是 $x$ 走环上匹配边到达的点，当然这个 $x$ 不能是 $p$，因为只能从环上其它点走到 $p$，不能从 $p$ 走到环上其它点。那么 $pre,match$ 数组维护了环上所有的边。
 
此时 $vis=2$ 的 $pre$，不一定都是交替树上的父边了。当然 $match_p$ 肯定还是 $p$ 的父边。因此在跳交替树的每一步都要 $u=find(u)$。否则，$u$ 不是所在花的根，执行 $u=pre_{match_u}$ 时，可能会跳到别的花里去。注意这个时候 $u,v,p$ 还没缩花，但 $u$ 可能在别的花里面。

时间复杂度 $O(nm\alpha(n))$。

## Code

```cpp
#include <bits/stdc++.h>

using namespace std;

template <class t>
inline void read(t & res)
{
	char ch;
	while (ch = getchar(), !isdigit(ch));
	res = ch ^ 48;
	while (ch = getchar(), isdigit(ch))
		res = res * 10 + (ch ^ 48);
}

template <class t>
inline void print(t x)
{
	if (x > 9) print(x / 10);
	putchar(x % 10 + 48);
}

const int e = 1005, o = 3e5 + 5;

int adj[e], nxt[o], go[o], num, n, m, pre[e], match[e], ans, fa[e], tim, vis[e], tag[e];
queue<int>q;

inline void link(int x, int y)
{
	nxt[++num] = adj[x]; adj[x] = num; go[num] = y;
	nxt[++num] = adj[y]; adj[y] = num; go[num] = x;
}

inline int find(int x)
{
	return fa[x] == x ? x : fa[x] = find(fa[x]);
}

inline int lca(int x, int y)
{
	tim++;
	for (;;)
	{
		if (x)
		{
			x = find(x);
			if (tag[x] == tim) return x;
			tag[x] = tim; x = pre[match[x]];
		}
		swap(x, y);
	}
}

inline void flower(int x, int y, int p)
{
	while (find(x) != p)
	{
		pre[x] = y; y = match[x];
		vis[y] = 1; q.push(y);
		if (find(x) == x) fa[x] = p;
		if (find(y) == y) fa[y] = p;
		x = pre[y];
	}
}

inline bool bfs(int s)
{
	int i;
	for (i = 1; i <= n; i++) vis[i] = pre[i] = 0, fa[i] = i;
	while (!q.empty()) q.pop();
	q.push(s); vis[s] = 1;
	while (!q.empty())
	{
		int u = q.front();
		q.pop();
		for (i = adj[u]; i; i = nxt[i])
		{
			int v = go[i];
			if (vis[v] == 2 || find(u) == find(v)) continue;
			if (!vis[v])
			{
				vis[v] = 2; pre[v] = u;
				if (!match[v])
				{
					int x = v;
					while (x)
					{
						int y = pre[x], z = match[y];
						match[x] = y; match[y] = x;
						x = z;
					}
					return 1;
				}
				vis[match[v]] = 1;
				q.push(match[v]);
			}
			else
			{
				int p = lca(u, v);
				flower(u, v, p); flower(v, u, p);
			}
		}
	}
	return 0;
}

int main()
{
	read(n); read(m);
	int i, x, y;
	while (m--)
	{
		read(x); read(y);
		link(x, y);
	}
	for (i = 1; i <= n; i++)
		if (!match[i] && bfs(i)) ans++;
	cout << ans << endl;
	for (i = 1; i <= n; i++)
	{
		print(match[i]);
		putchar(i == n ? '\n' : ' ');
	}
	return 0;
}
```

---

## 作者：王大神——A001 (赞：3)

前置知识：

[二分图匹配](https://wdsa001.github.io/2021/12/25/er-fen-tu-pi-pei-dai-quan-wan-mei-pi-pei/#toc-heading-5)

[并查集](https://wdsa001.github.io/2021/12/23/ke-chi-jiu-hua-bing-cha-ji/#toc-heading-1)

[`BFS` 匈牙利算法](https://wdsa001.github.io/2021/12/25/er-fen-tu-pi-pei-dai-quan-wan-mei-pi-pei/#toc-heading-9)

## 一般图最大匹配

[传送门](https://www.luogu.com.cn/problem/P6113)

题目的要求从二分图匹配比那成了一般图匹配，其实和 `BFS` 版的匈牙利算法想法有些相似：找增广路。但是题目的图变成了一般图，所以就会有环的出现。那么问题的聚焦点就是对环的处理。

环分为奇环和偶环，其中偶环可以“自产自消”但是奇环不行，所以我们重点处理的也是奇环。

偶环：

![偶环](https://s4.ax1x.com/2021/12/26/TwbmVA.png)

（其中，一条线代表路径，两个点可以互通，两条线代表两个点匹配，一个蓝点匹配一个粉点。）

带花树定义：可以处理图中有奇环的情况，将奇环缩成一个点（算法中叫做一朵花），然后再类似于匈牙利算法通过找增广路来找这个图的最大匹配。

我们不直接讲怎么处理奇环，先讲代码思路，碰见问题再说。

- 数组初始化，读入基本信息（加边），如果都没有匹配，就先匹配上。

- 尝试没有匹配的点，能不能让其它点改配，从而让这个点匹配成功。

- 初始化信息（每个第一次没有匹配的点都会尝试，所以一定要初始化）。

这里我们用的信息有这些：标记该节点是否尝试过匹配，或是否已经加入尝试改配的序列了。

注意：这个数组要记录三中状态：$1$ 尝试换配，$2$ 尝试过的点，$0$ 没有尝试过的点。

想想一下，现在有 $4$ 个点，$a$ 和 $b$ 可以匹配，$b$ 和 $c,d$ 可以匹配，$d$ 和 $c$ 也可以匹配。但是现在，$b$ 和 $c$ 匹配上了（这显然不优）。

我们尝试让 $a$ 匹配，$a$ 可以匹配 $b$ 但是 $b$ 已经匹配了，这是将 $b$ 打上标记 $2$ 代表尝试过的点，而 $c$ 打上标记 $1$ 代表尝试换配的点。因为，如果 $c$ 可以匹配其他的，那么就将 $b$“让”出来了，那么 $a$ 也就匹配成功了，所以 $c$ 入队尝试匹配。

记得开新数组，因为这时的 $b$ 还要存储 $a$，是 $a$ 尝试匹配，这样如果匹配成功了，方便回溯。

发现 $c$ 和 $d$ 还可以匹配，那么就让 $c$ 和 $d$ 匹配，$b$ 被让出来了，利用刚刚开的新数组回溯让 $a$ 和 $b$ 匹配。

- 尝试节点入队，尝试匹配，不断进行标记，如果出现了已经打过标记 $1$ 的节点，那么说明成环了，而且是奇环。

匹配遇见了标记 $1$ 的节点，我们现在遍历的点（尝试换配的点）全是标记为 $1$ 的点，而两个标号为 $1$ 的点相遇了，说明是奇环。如下图所示：

奇环：

![奇环](https://s4.ax1x.com/2021/12/26/TwbnUI.png)

（和上面的偶环的规则一样。这里蓝色节点代表了标记是 $1$。）

上图只是一个奇环，所以可能看不出什么名堂，请看下面这个图：

![奇环换配](https://s4.ax1x.com/2021/12/26/Twbu5t.png)

在第一个小图中可以看到，匹配的并不是最优的，那么我们就要尝试让他更优，我们从红点开始处理，尝试匹配。

（上面的紫虚边代表如果试配成功，那么换配后，紫虚边就换变成黑实边，也就是匹配边，而黑虚边就会消失；而如果匹配失败，黑虚边就会变回黑实边，紫虚边消失。）

最后匹配成功也就让整个环“合理”了（代码中标记的是“逆环”操作（名字乱起的，明白最重要））。

我们上边只是一个奇环，简单的一张图，如果是环套多个环（环中有环），那么怎么处理呢？

首先，要将整个环选出一个祖先（不管大环还是小环，缩完点后，就可以看成点，环套环就可以把里面的环先缩成点，再将外面的环缩成点。），大体流程如下（为了减少篇幅画一块了，先看左边的一列）：

![找祖先](https://s4.ax1x.com/2021/12/26/TwbMPP.png)

注意：找祖先的时候，要将两个“碰头”的点同时往回找。如果只让一个点往回找的话，就直接回到绿点（开始的地方）了。

- 如果匹配成功要记得换配（更新匹配关系）。

- 统计结果，输出即可。

细节详见代码。

### 代码思路整理

- 数组初始化，读入基本信息。

- 尝试没有匹配的点。

- 每个点匹配都要初始化信息。

- 尝试更多匹配，匹配成功换配。

- 统计结果，输出。

### 代码

```cpp
#include<iostream>
#include<cstdlib>
#include<cstring>
#include<cstdlib>
#include<cmath>
#include<algorithm>
#include<queue>
#include<vector>
#include<stack>
using namespace std;
long long r_r(){//快读 
	long long k=0,f=1;
	char c=getchar();
	while(!isdigit(c)){
		if(c=='-')f=-1;
		c=getchar();
	}
	while(isdigit(c)){
		k=(k<<1)+(k<<3)+(c^48);
		c=getchar(); 
	}
	return k*f;
}
const int o_o=2e5+10;
queue<int>q_q;
int n,m;
int a_s;//统计结果 
int l_k[o_o];//记录和哪个点匹配 
int b_b[o_o];//标记 1 尝试换配，2 尝试过的点，0 没有尝试过的点 
int f_a[o_o];//记录父节点 
int p_r[o_o];//记录从那个点来的 
int x_x;//环缩点后的标号 
int g_h[o_o];//共环的编号 

//链式前向星 
struct po{
	int v;
	int n_t;
}p_p[o_o];
int h_d[o_o],x_p;
void a_d(int u,int v){//加边 
	p_p[++x_p].v=v;
	p_p[x_p].n_t=h_d[u];
	h_d[u]=x_p;
}
void n_w(int x){//换配 
	if(!x)return ;
	n_w(l_k[p_r[x]]);//一直走到头 
	
	//换配 
	l_k[x]=p_r[x];
	l_k[p_r[x]]=x;
}
int f(int k){//找父节点 
	if(k==f_a[k])return k;
	return f_a[k]=f(f_a[k]);//路径压缩 
}
int l_c(int x,int y){
	x_x++;//开新点（环缩点） 
	while(1){
		x=f(x);//上爬，爬到父节点（如果不是自己的话，相当于直接出环） 
		if(g_h[x]==x_x)return x;
		//跑到已经标记过的点了，定义当前点为这个环的祖先 
		else if(x)g_h[x]=x_x;//更新节点标记 
		x=p_r[l_k[x]];//更新为当前节点匹配的节点的来的点
		//下一个可能换配的点，即标记 b_b 为 1 的点 
		swap(x,y);//交换标号，两头一起跑，可以成环相遇
		//如果只有一个点跑就跑回起点了 
	}
}
void s_k(int x,int y,int f_f){
	while(f(x)!=f_f){//不是子节点 
		p_r[x]=y;//更新记录来的点 
		y=l_k[x];//记录匹配的点 
		f_a[x]=f_a[y]=f_f;//匹配的一对点更新父节点 
		if(b_b[y]==2){//遍历过 
			b_b[y]=1;//标记 
			q_q.push(y);//入队尝试 
		}
		x=p_r[y];//更新到 y 的点 
	}
}
int b_s(int x){
	for(int i=1;i<=n;i++){//初始化信息 
		b_b[i]=0;
		p_r[i]=0;
		f_a[i]=i;//初始化父节点 
	}
	b_b[x]=1;//标记 
	q_q=queue<int>();//清空队列 
	q_q.push(x);//将当前节点入队 
	int f_f;
	while(!q_q.empty()){
		int k=q_q.front();//提取队头 
		q_q.pop();
		for(int i=h_d[k];i;i=p_p[i].n_t){
			int v=p_p[i].v; 
			if(b_b[v]==1){//标记过，尝试匹配路径成环了 
				f_f=l_c(k,v);//记录环的公共祖先 
				
				//逆环尝试 
				s_k(k,v,f_f);
				s_k(v,k,f_f);
			}else if(!b_b[v]){//没有标记过 
				p_r[v]=k;//记录来的点 
				b_b[v]=2;//标记到过节点，但是不是尝试换配的节点 
				if(!l_k[v]){//当前节点没有匹配过 
					n_w(v);//换配 
					return 1;//匹配成功 
				}else {//当前节点已经匹配 
					b_b[l_k[v]]=1;//和目标匹配的节点标记，尝试换配 
					q_q.push(l_k[v]);//入队，尝试匹配其他节点
					//如果它能匹配成功别的点，就能把这个点“让”出来 
				}
			}
		}
	}
	return 0;
}
int main(){
	n=r_r(),m=r_r();
	for(int i=1;i<=m;i++){
		int a=r_r(),b=r_r();
		//加边 
		a_d(a,b);
		a_d(b,a);
		if(!l_k[a]&&!l_k[b]){//两个点都没有匹配，先匹配上 
			l_k[a]=b;//记录匹配的点 
			l_k[b]=a;
			a_s++;//统计匹配对数 
		}
	}
	for(int i=1;i<=n;i++) 
		if(!l_k[i]&&b_s(i))a_s++;
	//节点未匹配，尝试匹配，如果匹配成功，统计结果 
	printf("%d\n",a_s);//输出匹配成功的对数 
	for(int i=1;i<=n;i++)printf("%d ",l_k[i]);//输出匹配编号 
	return 0;
}
```


---

## 作者：Immortal_Bird (赞：3)

基建第三篇

这题让我见识到了
$queue$被卡。卡了8个点。
$T$了半天。吸氧也不过去艹（祖安玩家上线）

---

带花树解决的是一般图的最大匹配。

匈牙利和网络流解决的是二分图的最大匹配。

带花树复杂度$O(n(nlogn+m))$，不过和匈牙利一样跑不满。

---
由于匈牙利无法解决带**奇环**的图匹配，而只能解决**偶环**的图匹配，那么考虑将奇环缩成一个点（花），这样那个环就变成了<$1+$
偶数点>的花。

然后整张图就变成了二分图。由于缩点后的那部分偶数点一定可以最大匹配，那么我们就可以在新建的二分图上匹配了。

**主要流程**

把图中点分为黑白两类，黑白匹配。

每次从未匹配的点开始增广，它的$v$有一下几种情况

- $u$和$v$已经在一朵花里了

跳过。
- $v$是白点

已经被匹配了，放弃$v$原先的匹配点或$u$与$v$匹配不影响，跳过
- $v$还没有被染色

把$u$染成白色，$v$染成黑色。
1. $v$没有被匹配过，就把$v$和$u$匹配，**$v$不染色**。增广成功，一路取反，退出函数,$ans++$。

2. $v$被匹配过了，那么把$v$的匹配点染成黑色，压入队列，继续寻找增广路。
（和匈牙利差不多）

- $v$是黑点

$u,v$在一朵没标记的花里（可以手动模拟一下）。找到$u,v$的最近公共花祖先去定位这朵花。先把这朵没有标记的花标记一下($shrink$)，再把这朵花上的白点染黑，塞入队列中去匹配。

至于此图的$lca$，我们需要$pre$数组记录当前点返回到哪里。

至于为啥要两次shrink，我的理解是一个环中，两个相邻点要**遍历**整个环，就必须一边向左，一边向右，像接带子成环一样的遍历。

代码部分参考，有经过自己码风调整[https://www.cnblogs.com/owenyu/p/6858508.html](https://www.cnblogs.com/owenyu/p/6858508.html)

[P6113 一般图最大匹配](https://www.luogu.com.cn/problem/P6113)

$$ Code$$

```cpp
#include<bits/stdc++.h>
using namespace std;

int read(){
	int x=0;bool f=0;char ch=getchar();
	while(!isdigit(ch))f|=ch=='-',ch=getchar();
	while(isdigit(ch))x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
	return f?-x:x;
}

void write(int x){
	if(x<0)putchar('-'),x=-x;
	if(x>9)write(x/10);
	putchar(48+x%10);
}

void writeln(int x){write(x);putchar('\n');}
void writebl(int x){write(x);putchar(' ');}


const int maxn = 1009;
const int maxm = maxn*maxn*2;

struct TWF{//Tree with flower
	#define I inline
	#define R register
	struct node{
		int v,next;
	}e[maxm];
	int head[maxn],tot;
	inline void add(int u,int v){e[++tot]=(node){v,head[u]};head[u]=tot;}
	inline void addedge(int u,int v){add(u,v);add(v,u);}
		
	int q[maxm],ql,qr;
	int n,m,ans,tim,pre[maxn];
	int dfn[maxn],match[maxn],cl[maxn],fa[maxn];
	
	int find(int x){return fa[x]==x?x:fa[x]=find(fa[x]);}	
	I int lca(int x,int y){
		for(++tim;;swap(x,y))if(x){
			x=find(x);
			if(dfn[x]==tim)return x;
			else dfn[x]=tim,x=pre[match[x]];
		}
	}
	I void shrink(int x,int y,int p){
		while(find(x)!=p){
			pre[x]=y,y=match[x];
			if(cl[y]==2)cl[y]=1,q[++qr]=y;
			if(find(x)==x)fa[x]=p;
			if(find(y)==y)fa[y]=p;
			x=pre[y];
		}
	}
	I bool aug(int s){
		for(R int i=1;i<=n;++i)fa[i]=i;
		memset(cl,0,sizeof(cl));memset(pre,0,sizeof(pre));
		cl[q[ql=qr=1]=s]=1;
		while(ql<=qr){
			int u=q[ql++];
			for(R int i=head[u],v=e[i].v;i;i=e[i].next,v=e[i].v){
				if(cl[v]==2||find(v)==find(u))continue;
				if(!cl[v]){
					cl[v]=2;pre[v]=u;
					if(!match[v]){
						for(R int x=v,las,y;x;x=las)
							las=match[y=pre[x]],match[x]=y,match[y]=x;
						return 1;
					}
					cl[match[v]]=1,q[++qr]=match[v];
				}
				else if(cl[v]==1){
					int l=lca(u,v);
					shrink(u,v,l);
					shrink(v,u,l);
				}
			}
		}
		return 0;
	}
	#undef R
	#undef I
}T;

int main(){
	int ans=0;
	T.n=read(),T.m=read();
	for(int u,v;T.m;--T.m)u=read(),v=read(),T.addedge(u,v);
	for(int i=1;i<=T.n;++i)ans+=(!T.match[i]&&T.aug(i));
	writeln(ans);
	for(int i=1;i<=T.n;++i)writebl(T.match[i]);
}
```



---

## 作者：yangdezuo (赞：1)

## 代码1（需要C++14 （GCC 9）编译）
带花树算法（Blossom Algorithm）
开花算法（Blossom Algorithm，也被称做带花树）可以解决一般图最大匹配问题（maximum cardinality matchings）。此算法由 Jack Edmonds 在 1961 年提出。经过一些修改后也可以解决一般图最大权匹配问题。此算法是第一个给出证明说最大匹配有多项式复杂度。

一般图匹配和二分图匹配（bipartite matching）不同的是，图可能存在奇环。
### 复杂度分析 Complexity Analysis
每次找增广路，遍历所有边，遇到花会维护花上的点，$O(|E|^2)$。

枚举所有未匹配点做增广路，总共 $O(|V||E|^2)$。

下面是代码
```cpp
#include <bits/stdc++.h>
using namespace std;

// graph
template <typename T>
class graph {
 public:
  struct edge {
    int from;
    int to;
    T cost;
  };

  vector<edge> edges;
  vector<vector<int> > g;
  int n;

  graph(int _n) : n(_n) { g.resize(n); }

  virtual int add(int from, int to, T cost) = 0;
};

// undirectedgraph
template <typename T>
class undirectedgraph : public graph<T> {
 public:
  using graph<T>::edges;
  using graph<T>::g;
  using graph<T>::n;

  undirectedgraph(int _n) : graph<T>(_n) {}

  int add(int from, int to, T cost = 1) {
    assert(0 <= from && from < n && 0 <= to && to < n);
    int id = (int)edges.size();
    g[from].push_back(id);
    g[to].push_back(id);
    edges.push_back({from, to, cost});
    return id;
  }
};

// blossom / find_max_unweighted_matching
template <typename T>
vector<int> find_max_unweighted_matching(const undirectedgraph<T> &g) {
  std::mt19937 rng(114514);  // 这里随机种子是无关紧要的
  // 也可以用 chrono::steady_clock::now().time_since_epoch().count()
  // 获取当前时间
  vector<int> match(g.n, -1);   // 匹配
  vector<int> aux(g.n, -1);     // 时间戳记
  vector<int> label(g.n);       // "o" or "i"
  vector<int> orig(g.n);        // 花根
  vector<int> parent(g.n, -1);  // 父节点
  queue<int> q;
  int aux_time = -1;

  auto lca = [&](int v, int u) {
    aux_time++;
    while (true) {
      if (v != -1) {
        if (aux[v] == aux_time) {  // 找到拜访过的点 也就是LCA
          return v;
        }
        aux[v] = aux_time;
        if (match[v] == -1) {
          v = -1;
        } else {
          v = orig[parent[match[v]]];  // 以匹配点的父节点继续寻找
        }
      }
      swap(v, u);
    }
  };  // lca

  auto blossom = [&](int v, int u, int a) {
    while (orig[v] != a) {
      parent[v] = u;
      u = match[v];
      if (label[u] == 1) {  // 初始点设为"o" 找增广路
        label[u] = 0;
        q.push(u);
      }
      orig[v] = orig[u] = a;  // 缩花
      v = parent[u];
    }
  };  // blossom

  auto augment = [&](int v) {
    while (v != -1) {
      int pv = parent[v];
      int next_v = match[pv];
      match[v] = pv;
      match[pv] = v;
      v = next_v;
    }
  };  // augment

  auto bfs = [&](int root) {
    fill(label.begin(), label.end(), -1);
    iota(orig.begin(), orig.end(), 0);
    while (!q.empty()) {
      q.pop();
    }
    q.push(root);
    // 初始点设为 "o", 这里以"0"代替"o", "1"代替"i"
    label[root] = 0;
    while (!q.empty()) {
      int v = q.front();
      q.pop();
      for (int id : g.g[v]) {
        auto &e = g.edges[id];
        int u = e.from ^ e.to ^ v;
        if (label[u] == -1) {  // 找到未拜访点
          label[u] = 1;        // 标记 "i"
          parent[u] = v;
          if (match[u] == -1) {  // 找到未匹配点
            augment(u);          // 寻找增广路径
            return true;
          }
          // 找到已匹配点 将与她匹配的点丢入queue 延伸交错树
          label[match[u]] = 0;
          q.push(match[u]);
          continue;
        } else if (label[u] == 0 && orig[v] != orig[u]) {
          // 找到已拜访点 且标记同为"o" 代表找到"花"
          int a = lca(orig[v], orig[u]);
          // 找LCA 然后缩花
          blossom(u, v, a);
          blossom(v, u, a);
        }
      }
    }
    return false;
  };  // bfs

  auto greedy = [&]() {
    vector<int> order(g.n);
    // 随机打乱 order
    iota(order.begin(), order.end(), 0);
    shuffle(order.begin(), order.end(), rng);

    // 将可以匹配的点匹配
    for (int i : order) {
      if (match[i] == -1) {
        for (auto id : g.g[i]) {
          auto &e = g.edges[id];
          int to = e.from ^ e.to ^ i;
          if (match[to] == -1) {
            match[i] = to;
            match[to] = i;
            break;
          }
        }
      }
    }
  };  // greedy

  // 一开始先随机匹配
  greedy();
  // 对未匹配点找增广路
  for (int i = 0; i < g.n; i++) {
    if (match[i] == -1) {
      bfs(i);
    }
  }
  return match;
}

int main() {
  ios::sync_with_stdio(false);

  int n, m;
  cin >> n >> m;

  undirectedgraph<int> g(n);

  while (m--) {
    int u, v;
    cin >> u >> v;
    g.add(u - 1, v - 1);  // 0-based
  }

  auto match = find_max_unweighted_matching(g);

  cout << count_if(match.begin(), match.end(), [](int x) { return x != -1; }) /
              2
       << endl;
  for (int i = 0; i < n; i++) cout << match[i] + 1 << " \n"[i == n - 1];

  return 0;
}

```

## 接着本题还有第二种解法——构造最大匹配
$G$ 的最大匹配大小等于 $\operatorname{rank}\tilde{A}$ 的一半。如果我们能找到 $\tilde{A}$ 的一个极大满秩子矩阵，那么对子矩阵对应的导出子图求出一组完美匹配，即可找到 $G$ 的一组完美匹配。
换一个角度考虑，如果 $G$ 有完美匹配，那么 $\tilde{A}$ 满秩，换言之，$\tilde{A}$ 是线性无关的。那么如果 $\tilde{A}$ 不是满秩的，我们可以求出 $\tilde{A}$ 的一组线性基，然后只保留线性基对应的行列，就可以得到 $\tilde{A}$ 的一个极大满秩子矩阵。

求出极大满秩子矩阵之后，再用上面的算法找出导出子图的一组完美匹配，即可得到原图的一组最大匹配。注意由于高斯消元中可能会有行的交换，因此实现时要注意维护好点的编号。
```cpp
#include <bits/stdc++.h>
using namespace std;

const int maxn = 505, p = (int)1e9 + 7;

int qpow(int a, int b) {
  int ans = 1;
  while (b) {
    if (b & 1) ans = (long long)ans * a % p;
    a = (long long)a * a % p;
    b >>= 1;
  }
  return ans;
}

int A[maxn][maxn], B[maxn][maxn], t[maxn][maxn], id[maxn];

// 高斯消元 O(n^3)
// 在传入 B 时表示计算逆矩阵, 传入 nullptr 则只需计算矩阵的秩
void Gauss(int A[][maxn], int B[][maxn], int n) {
  if (B) {
    memset(B, 0, sizeof(t));
    for (int i = 1; i <= n; i++) B[i][i] = 1;
  }

  for (int i = 1; i <= n; i++) {
    if (!A[i][i]) {
      for (int j = i + 1; j <= n; j++)
        if (A[j][i]) {
          swap(id[i], id[j]);
          for (int k = i; k <= n; k++) swap(A[i][k], A[j][k]);

          if (B)
            for (int k = 1; k <= n; k++) swap(B[i][k], B[j][k]);
          break;
        }

      if (!A[i][i]) continue;
    }

    int inv = qpow(A[i][i], p - 2);

    for (int j = 1; j <= n; j++)
      if (i != j && A[j][i]) {
        int t = (long long)A[j][i] * inv % p;

        for (int k = i; k <= n; k++)
          if (A[i][k]) A[j][k] = (A[j][k] - (long long)t * A[i][k]) % p;

        if (B) {
          for (int k = 1; k <= n; k++)
            if (B[i][k]) B[j][k] = (B[j][k] - (long long)t * B[i][k]) % p;
        }
      }
  }

  if (B)
    for (int i = 1; i <= n; i++) {
      int inv = qpow(A[i][i], p - 2);

      for (int j = 1; j <= n; j++)
        if (B[i][j]) B[i][j] = (long long)B[i][j] * inv % p;
    }
}

bool row_marked[maxn] = {false}, col_marked[maxn] = {false};

int sub_n;  // 极大满秩子矩阵的大小

// 消去一行一列 O(n^2)
void eliminate(int r, int c) {
  row_marked[r] = col_marked[c] = true;  // 已经被消掉

  int inv = qpow(B[r][c], p - 2);

  for (int i = 1; i <= sub_n; i++)
    if (!row_marked[i] && B[i][c]) {
      int t = (long long)B[i][c] * inv % p;

      for (int j = 1; j <= sub_n; j++)
        if (!col_marked[j] && B[r][j])
          B[i][j] = (B[i][j] - (long long)t * B[r][j]) % p;
    }
}

int vertices[maxn], girl[maxn];  // girl 是匹配点, 用来输出方案

int main() {
  auto rng = mt19937(chrono::steady_clock::now().time_since_epoch().count());

  int n, m;
  scanf("%d%d", &n, &m);  // 点数和边数

  while (m--) {
    int x, y;
    scanf("%d%d", &x, &y);
    A[x][y] = rng() % p;
    A[y][x] = -A[x][y];  // Tutte 矩阵
  }

  for (int i = 1; i <= n; i++)
    id[i] = i;  // 输出方案用的，因为高斯消元的时候会交换列
  memcpy(t, A, sizeof(t));

  Gauss(A, nullptr, n);

  for (int i = 1; i <= n; i++)
    if (A[id[i]][id[i]]) vertices[++sub_n] = i;  // 找出一个极大满秩子矩阵

  for (int i = 1; i <= sub_n; i++)
    for (int j = 1; j <= sub_n; j++) A[i][j] = t[vertices[i]][vertices[j]];

  Gauss(A, B, sub_n);

  for (int i = 1; i <= sub_n; i++)
    if (!girl[vertices[i]])
      for (int j = i + 1; j <= sub_n; j++)
        if (!girl[vertices[j]] && t[vertices[i]][vertices[j]] && B[j][i]) {
          // 注意上面那句 if 的写法, 现在 t 是邻接矩阵的备份，
          // 逆矩阵 j 行 i 列不为 0 当且仅当这条边可行
          girl[vertices[i]] = vertices[j];
          girl[vertices[j]] = vertices[i];

          eliminate(i, j);
          eliminate(j, i);
          break;
        }

  printf("%d\n", sub_n / 2);
  for (int i = 1; i <= n; i++) printf("%d ", girl[i]);

  return 0;
}

```

---


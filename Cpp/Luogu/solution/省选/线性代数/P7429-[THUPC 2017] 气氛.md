# [THUPC 2017] 气氛

## 题目描述

北大街，在中国是一个非常常见的地名，比较著名的有上海北大街，西安北大街，成都北大街，太原北大街，中关村北大街等。

我们都知道，北的意思是自由民主，大的意思是兼收并蓄，所以住在北大街的人也性情迥异，我们假设在北大街住了 $n$ 个人。

有人向住在北大街的这 $n$ 个人提了 $n-1$ 个问题，比如：

「用不用筷子？」

「吃不吃红烧肉？」

「写代码用 tab 还是 space」

「大括号换不换行？」

「……」

根据每个人的回答，他会被分配一个 $n-1$ 维的零一坐标，也就是一个点。这样 $n$ 个点可以恰好构成一个 $n-1$ 维空间中的凸包。

北大街的居民认为，在这个多面体内，便是华夏；多面体之外，便是蛮夷。我们可以很容易的计算出华夏部分的广义凸包体积。

有一天，清华路的 B 君来北大街玩，听说了这个故事觉得很有趣，于是也试着给出了这 $n-1$ 个问题的答案，

清华路的 B 君，当然认为自己属于华夏，但是北大街表示在 $n-1$ 维空间中如果有 $n+1$ 个点的话，华夏部分的体积难以计算。

这下子气氛突然僵化。所以这个问题就留给你了，输入 $n-1$ 维度空间中的 $n+1$ 个点，求广义凸包的体积。

由于这个体积可能不是整数，你只需要输出体积乘以 $n-1$ 的阶乘，然后对 $10^9+7$ 取模的结果。

## 说明/提示

$1\le t\le 100,3\le n\le35$

点的坐标一定是 $0$ 或者 $1$。
#### 版权信息
来自 THUPC（THU Programming Contest，清华大学程序设计竞赛）2017。

## 样例 #1

### 输入

```
1
3
0 0
0 1
1 0
1 1```

### 输出

```
2```

# 题解

## 作者：清烛 (赞：3)

在[博客](https://blog.imyangty.com/sol-luogu-p7429/)里面访问（连接较不稳定）

或者 [CSDN](https://blog.csdn.net/qq_44950190/article/details/119336197)

## Before we start
前置知识：

- 行列式的几何意义
- 高斯消元求行列式

没了。

## Description

$t$ 组数据（$1\le t\le 100$），问 $n - 1$ 维空间中的 $n + 1$ 个点构成的凸包的广义体积。点的坐标一定是 $0$ 或 $1$。

## Solution

首先，这 $n + 1$ 个点肯定是参与构成了整个凸包的，因为点的坐标一定为 $0$ 或 $1$。

而我们想想 $n -1$ 维空间中 $n$ 个点构成的凸包的体积，无非就是用这 $n$ 个点张成 $n - 1$ 个向量，然后求出行列式的值除以 $n$ 的阶乘取绝对值，证明可以随便搜一下或者直接当结论记住。也可以手推一下 $2$ 维和 $3$ 维空间的情况发现其是对的。

可是我们这题的点有 $n + 1$ 个，没办法直接用行列式做，怎么办呢？

不妨从二维的情况考虑起。

![](https://imyangty.com/wp-content/uploads/2021/08/p7429_1.png)

考虑求四边形 $ABCD$ 的体积，不难发现我们可以依次求 $\triangle ABC$，$\triangle BCD$，$\triangle ABD$ 和 $\triangle ACD$ 的面积，在图上已经显示出来。然后会发现这样刚好将每个区域覆盖了两次。

考虑三维的情况。

![](https://imyangty.com/wp-content/uploads/2021/08/p7429_2.png)

然后考虑 $\binom 5 4 = 5$ 个四面体，发现他们的体积加起来也就是整个凸包的体积的两倍。

所以我们可以大胆猜想，**$n - 1$ 维空间中 $n + 1$ 个点构成的凸包的体积等于所有选 $n$ 个点构成的凸包体积之和的一半。**

事实上这也是正确的，~~我太屑了不会证明~~。

于是这道题就做完了。具体地，每次选择一个不出现的点，然后随便取一个点为起点算出 $n - 1$ 个向量，然后高斯消元计算出这 $n - 1$ 个向量组成的 $n - 1$ 维行列式（消成对角阵之后直接将对角线元素相乘），把这些行列式的值加起来。得到的结果除以二输出即可。

## Implement

实现的时候需要注意：

- 题目要求我们乘上 $(n - 1)!$ 后输出，所以我们不用除以 $(n - 1)!$ 了。
- 由于我们需要**行列式的值的绝对值**，所以不能进行模意义下的高斯消元，需要使用 double 进行高斯消元。
- 消元完后得到的行列式的值需要四舍五入成 `long long`（可能爆 `int`）然后计入答案。
- 最后乘上 $2$ 的逆元 $5\times10^8 + 4$。

```cpp
#include <cstdio>
#include <cctype>
#include <cmath>
#include <algorithm>
#define il inline
#define FOR(i, a, b) for (int i = (a); i <= (b); ++i)
#define DEC(i, a, b) for (int i = (a); i >= (b); --i)

namespace fastIO {}

using namespace fastIO;

const int maxn = 40, mod = 1e9 + 7, inv2 = 5e8 + 4;

struct Point {//存储点/向量
    int dim;
    int x[maxn];
} p[maxn];

Point operator-(const Point &a, const Point &b) {
    Point ret;
    ret.dim = a.dim;
    FOR(i, 1, ret.dim) ret.x[i] = a.x[i] - b.x[i];
    return ret;
}

typedef double db;
db mat[maxn][maxn];
int n;

double det(int n, db a[40][40]) {//Gauss-Jornan 消元计算行列式
    FOR(i, 1, n) {
        int r = i;
        FOR(j, i + 1, n)
            if (fabs(a[j][i]) > fabs(a[r][i])) r = j;
        std::swap(a[r], a[i]);
        FOR(k, 1, n) {
            if (k == i) continue;
            db div = a[k][i] / a[i][i];
            FOR(j, i + 1, n) a[k][j] -= div * a[i][j];
        }
    }
    db ret = 1;
    FOR(i, 1, n) ret *= a[i][i];
    return ret;
}

int main() {
    int t;
    read(t);
    while (t--) {
        read(n);
        FOR(i, 1, n + 1) {
            p[i].dim = n - 1;
            FOR(j, 1, n - 1) read(p[i].x[j]);
        }
        int ans = 0;
        FOR(ban, 1, n + 1) {//枚举不使用的点
            int st = (ban == 1) ? 2 : 1;//随便定起点
            for (int j = 1, col = 1; j <= n + 1 && col <= n - 1; ++j, ++col) {
                while (j == st || j == ban) ++j;
                Point tmp = p[j] - p[st];
                FOR(r, 1, n - 1) mat[r][col] = tmp.x[r];//算出向量然后加进矩阵里面
            }
            ans = (ans + (long long)fabs(round(det(n - 1, mat)))) % mod;//这里要开 long long
        }
        print(1ll * ans * inv2 % mod), putchar('\n');
    }
    return output(), 0;
}
```



---

## 作者：W123789 (赞：2)

#### 前置知识

1. 行列式的计算

首先，有如下定理：

>  $n$ 阶行列式的绝对值就是 $n$ 个列向量构成的 $n$ 维平行多面体的广义体积。

不妨从简单情况入手：

在 $n = 1$ 时，行列式的绝对值对应向量的模长。

在 $n = 2$ 时，行列式的绝对值对应平行四边形的面积。

在 $n=3$ 时，行列式的绝对值对应平行六面体的体积。

$$\cdots$$

我们知道，行列式有如下性质($n$ 个向量设为 $x_1,x_2,x_3,\cdots,x_n$)：

>1. 行列式是 $x_1,x_2,x_3,\cdots,x_n$ 的一个函数, 也就是 $\operatorname{det} A = f(x_1,x_2,x_3,\cdots,x_n)$
>2. 行列式的某一列乘上一个常数 $k$,  则行列式的值乘上一个常数 $k$, 即$f(x1,x2,x3,\cdots,kx_i,\cdots,x_n) = kf(x_1,x_2,x_3,\cdots,x_n)$
>3. 将行列式的某一列写成两列之和，那么行列式也相应地成为两个行列式之和，即  $f(x_1,x_2,\cdots,x_i,\cdots,x_n) = f(x_1,x_2,\cdots,y_i,\cdots,x_n)+f(x1,x2,\cdots,z_i,\cdots,x_n)$,其中 $x_i=y_i+z_i$
>4. 只要有两列相同，那么行列式值为 $0$
>5. 交换任意两列，行列式的值取反(但绝对值不变)
>6. $\operatorname{det} I=1$

来对比体积的性质：

> 1. 体积是 $x_1,x_2,x_3,\cdots,x_n$ 的一个函数，也就是 $V=f(x_1,x_2,\cdots,x_n)$
>
> 2. 将某个向量的长度乘上 $k$，则体积的值也要乘上 $k$
>
> 3. 将某个向量写成两个向量之和，那么体积 $f(x_1,x_2,\cdots,x_i,\cdots,x_n) = f(x_1,x_2,\cdots,y_i,\cdots,x_n)+f(x1,x2,\cdots,z_i,\cdots,x_n)$,其中 $x_i=y_i+z_i$，相当于就是把原来的体积一分为二，但总体积不变。
>
> 4. 只要有两个向量重合，那么体积为 $0$，这相当于降低了一个维度。
> 5. 交换两个向量的位置，体积不变。
>
> 6. 边长为 $1$ 的 $n$ 维单位立方体的体积是 $1$

对比体积和行列式的性质，我们惊讶的发现，行列式的绝对值就是体积。

而对于凸包的体积，也就是广义多面体除以 $n!$，而本题要乘 $n!$,所以就不需要除以 $n!$。

若此题只有 $n-1$ 个 $n-1$ 维向量，那么就可以直接用行列式计算，最后取绝对值。

但此题有 $n$ 个向量，多出来了一个。

从简单情况入手:

在一维下, $AB=\frac{AC+CB+AB}{2}$

![](https://cdn.luogu.com.cn/upload/image_hosting/ksf54h6o.png)

在二维下, $S_{ABCD}=\frac{S_{\Delta ABC}+S_{\Delta BCD}+S_{\Delta CDA}+S_{\Delta DAB}}{2}$

![](https://cdn.luogu.com.cn/upload/image_hosting/r5ih844u.png)

三维也是如此，在草稿纸上画一画就出来了。

于是我们发现：$n(n \leq 3)$ 维空间中的 $n+1$ 个向量构成的广义凸包体积，等于在 $n+1$ 个向量中任选 $n$ 个向量构成的凸包的体积之和除以 $2$ 。

实际上，这个结论拓展到任意维都是成立的。

于是，我么在 $n$ 个向量中任选 $n-1$ 个，算出它们的行列式，累加起来，最后乘上 $2$ 的逆元。

需要注意的是，通过尝试，算行列式需要 double 类型，每次累加答案用 round 函数四舍五入后取绝对值再取模。

代码如下：

```cpp
#include <cstdio>
#include <cstring>
#include <cmath>
#include <iostream>
using namespace std;
const double eps = 1e-6;
const int MAX = 45;
namespace IO{
	template <typename T>
	inline void read(T &x) {
		x = 0;
		bool f = 1;
		static char ch = getchar();
		while (ch < '0' || ch > '9') {
			if (ch == '-') 
				f = 0;
			ch = getchar();
		}
		while (ch >= '0' && ch <= '9') {
			x = (x << 3) + (x << 1) + (ch ^ 48);
			ch = getchar();
		}
		if (!f) x = -x;
	}
	template <typename T>
	inline void write(T x){
		if (x < 0) {
			x = -x;
			putchar('-');
		}
		if (x > 9) 
			write(x / 10);
		putchar(x % 10 + '0');
	}
}
using namespace IO;
int n;
double a[MAX][MAX];
const int mod = 1e9 + 7, inv2 = 5e8 + 4;
inline double det(int n) {
	int r;
	double f;
	for (int i = 0; i < n; i++) {
		r = i;
		for (int j = i + 1; j < n; j++)
			if (fabs(a[j][i]) > fabs(a[r][i])) r = j;
		if (fabs(a[r][i]) < eps) return 0;
		swap(a[r], a[i]);
		for (int k = 0; k < n; k++) {
			if (k == i) continue;
			double f = a[k][i] / a[i][i];
			for (int j = i + 1; j < n; j++)
				a[k][j] -= f * a[i][j];
		}
	}
	double ans = 1;
	for (int i = 0; i < n; i++)
		ans *= a[i][i];
	return ans;
	
}
double p[MAX][MAX];
int main() {
	int T;
	read(T);
	while (T--) {
		int x;
		read(n);
		for (int i = 0; i <= n; i++)
			for (int j = 0; j < n - 1; j++)
				read(x), p[i][j] = x;
		long long ans = 0;
		for (int k = 0; k <= n; k++) {
			int s = (k == 0);
			for (int j = 0, i = 0; j <= n && i < n - 1; j++, i++) {
				while (j == s || j == k) j++;
				for (int l = 0; l < n - 1; l++)
					a[l][i] = p[j][l] - p[s][l];
			}
			ans = (ans + (long long)fabs(round(det(n - 1)))) % mod;
		}
		printf("%lld\n", 1ll * ans * inv2 % mod);
	}
	
	return 0;
}
```

~~完结撒花~~

##### 后记

参考资料: https://spaces.ac.cn/archives/2208



---

## 作者：滑稽的小宫 (赞：2)

线性代数题。

## 题目简述

输入 $n-1$ 维度空间中的 $n+1$ 个点，求广义凸包的体积

## 解法：行列式
首先有一个结论：**$n$ 个线性无关向量张成的 $n$ 维广义平行六面体的体积为 $n$ 个向量构成矩阵的行列式的绝对值**

证明请看[这里](https://www.zhihu.com/question/377129026)

然后对于 $n$ 维凸包，它的体积就是广义平行六面体体积除以 $n$ 的阶乘。

而我们知道，**高斯消元的过程不会改变行列式的值**，这样我们就可以先通过高斯消元，将 $n$ 个向量构成的矩阵消成阶梯矩阵，然后根据n阶行列式的定义，对角线上所有数的乘积就是行列式。

但是有一个问题，这道题给出的 $n-1$ 维向量数量为 $n$ 个，如何处理多出来的那一个？

考虑一下二维的情况：

![](https://cdn.luogu.com.cn/upload/image_hosting/pnqykxdp.png)

考虑我们每次选三个点构成两个向量，张成的三角形为 $\triangle ABC,\triangle BCD,\triangle CDA,\triangle DAB$，这几个三角形面积加起来正好为四边形面积的二倍。

不妨大胆假设** $n$ 维空间中由 $n+1$ 个向量构成的凸包体积就等于所有选 $n$ 个向量构成的凸包体积之和的一半**

事实上这也是正确的（~~但蒟蒻太蒻不会证明~~）

因此这道题就很简单了，从 $n+1$ 个点里面选出 $n$ 个点，然后构成 $n-1$ 个向量（起点可以随便选），用高斯消元算出行列式，四舍五入取绝对值加入答案，最后除以二（用 $2$ 关于 $1e9+7$ 的逆元 $5e8+4$）

注意高斯消元过程要用 `double` 型，算出的行列式要四舍五入成整型取模。（题目里已经乘上了 $n-1$ 的阶乘，不用再除了）

## 代码：
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#define N 50
#define db double
#define ll long long
#define mod 1000000007ll
#define inv 500000004ll
#define eps 1e-6
int t,n;
bool equal(db x,db y){
    return x-y<eps&&y-x<eps;
}
class line{
    public:
    ll n;
    db l[N];
    line(int tot=0){
        n=tot;
        std::memset(&l,0,sizeof(l));
        return;
    }void clear(){
        for(int i=1;i<=n;i++)l[i]=0;
        return;
    }void print(){
        for(int i=1;i<=10;i++)printf("%.2lf ",l[i]);
    }
}vec[N];
line operator *(db b,line a){
    line ans(a.n);
    for(int i=1;i<=a.n;i++)ans.l[i]=a.l[i]*b;
    return ans;
}line operator +(line a,line b){
    line ans(a.n);
    for(int i=1;i<=b.n;i++)ans.l[i]=a.l[i]+b.l[i];
    return ans;
}void swap(line &a,line &b){
    line tmp=a;
    a=b,b=tmp;
    return;
}class matrix{
    public:
    ll n;
    line a[N];
    matrix(){
        std::memset(&a,0,sizeof(a));
        return;
    }
    void insert(line v){//用线性基的方法高斯消元
        for(int i=1;i<=n;i++){
            if(!equal(v.l[i],0)){
                if(equal(a[i].l[i],0)){a[i]=v;return;}
                else v=(-v.l[i]/a[i].l[i])*a[i]+v;
            }
        }return;
    }db det(){//阶梯矩阵的行列式就是对角线上数的乘积
        db ans=1;
        for(int i=1;i<=n;i++)ans=ans*a[i].l[i];
        return ans;
    }void clear(){
        for(int i=1;i<=n;i++)a[i].clear();
    }void print(){
        for(int i=1;i<=10;i++)a[i].print(),puts("");
    }
}A;
ll ab(ll a){
    return a<0?-a:a;
}
int main(){
    scanf("%d",&t);
    st:
    if(t--==0)return 0;
    scanf("%d",&n);
    A.n=n-1;
    for(int i=1;i<=n+1;i++){
        for(int j=1;j<n;j++){
            scanf("%lf",&vec[i].l[j]);
        }vec[i].n=n-1;
    }ll ans=0;
    for(int fb=1;fb<=n+1;fb++){
        int st=fb%(n+1)+1;
        line v=(-1)*vec[st];
        for(int j=1;j<=n+1;j++){
            if(j==fb||j==st)continue;
            A.insert(vec[j]+v);
        }ans=(ans+ab(round(A.det())))%mod;//round函数四舍五入
        //A.print();
        //while(1);
        A.clear();
    }printf("%lld\n",ans*inv%mod);
    goto st;
    return 0;
}
```

---

## 作者：Acoipp (赞：1)

## 分析

前置知识：行列式，这里默认读者会计算行列式，不会的可以左转 [Acoipp 的线性代数总结](https://www.luogu.com.cn/blog/674469/shuo-xue-xue-xi-bi-ji-1note-10-post)。

接下来步入正题。

设 $k$ 维空间中存在 $k$ 个点，则这 $k$ 个点和原点构成的凸包面积 $\times k!$ 就是：

$$
A=\begin{vmatrix}
x_{1,1} & x_{2,1} & \cdots & x_{k,1} \\
x_{1,2} & x_{2,2} & \cdots & x_{k,2} \\
\vdots & \vdots & \ddots & \vdots \\
x_{1,k} & x_{2,k} & \cdots & x_{k,k}
\end{vmatrix}
$$

行列式的值为 $\det(A)$，答案就是 $|\det(A)|$ 这是一个结论，二维的情况显然可以证明，三维及以上就需要想象力了。

如果是给定的 $k+1$ 个点构成的凸包，我们就需要任意指定一个点为原点建系即可。

为了方便起见，以下介绍的凸包体积均乘上了 $k!$。


与上面的描述不同的是，此题给的是 $k+2$ 个点，相当于有一个点是多余的，这个时候我们充分发扬人类智慧，任选 $k+1$ 个点计算凸包体积，这样的话我们可以得到 $k+2$ 个答案，那么最后这 $k+2$ 个点的凸包体积就是这 $k+2$ 个答案的和除以 $2$。

以样例为例，这 $k+2$ 个答案都是一个三角形的面积，都为 $\dfrac12$，加起来就是 $2$，除以 $2$ 之后是 $1$，但是还要乘上 $2!$，答案就是 $2$ 了。

## 细节

因为我们要知道行列式的绝对值，所以只能用 `double` 或者 `long double` 进行运算。

笔者使用的是 `long double`，每次算行列式进行高斯消元的时候，因为高斯消元有一个性质，就是把绝对值最大的项交换过来误差会更小，所以我们用 `fabs` 函数比较绝对值大小就可以了。

最后我们还需要进行随机扰动，即加上一个比较小的值，或者你也可以四舍五入用 `round` 函数才能避免精度问题。

有的时候 `long double` 比 `double` 慢得多，所以建议尽可能使用 `double` 而不是 `long double`。

时间复杂度是 $O(Tn^4)$，小常，可过。

## 代码

`long double` 代码如下：

```cpp
#include<bits/stdc++.h>
#define ll long long
#define double long double
#define mod 1000000007
#define N 55
using namespace std;
ll T,n,p[N][N],i,j,k,tot,has,ans;
double a[N][N];
inline double solve(ll n){
	ll i,j,k;
	double res,ans=1;
	for(i=1;i<=n;i++){
		ll pos = i;
		for(j=i+1;j<=n;j++) if(fabs(a[j][i])>fabs(a[pos][i])) pos=j;
		for(j=1;j<=n;j++) swap(a[i][j],a[pos][j]);
		if(fabs(a[i][i])<1e-7) return 0;
		for(j=i+1;j<=n;j++){
			res = a[j][i]/a[i][i];
			for(k=1;k<=n;k++) a[j][k]-=a[i][k]*res;
		}
	}
	for(i=1;i<=n;i++) ans=ans*a[i][i];
	return fabs(ans);
}
int main(){
	ios::sync_with_stdio(false);
	cin>>T;
	while(T--){
		ans=0;
		cin>>n;
		for(i=1;i<=n+1;i++) for(j=1;j<=n-1;j++) cin>>p[i][j];
		for(i=1;i<=n+1;i++){
			has = -1,tot = 0;
			if(i==1) has=2;
			else has=1;
			for(j=1;j<=n+1;j++){
				if(j==i||j==has) continue;
				tot++;
				for(k=1;k<=n-1;k++) a[k][tot]=p[j][k]-p[has][k];
			}
			ans = (ans+solve(n-1)+1e-7);
		}
		cout<<ans%mod*(1+mod)/2%mod<<endl;
	}
	return 0;
}
```

`double` 代码如下：

```cpp
#include<bits/stdc++.h>
#define mod 1000000007
#define inv 500000004
#define N 40
using namespace std;
int T,n,p[N][N],i,j,k,tot,has;
long long ans;
double a[N][N];
inline char nc(){
	static char buf[1000000],*p=buf,*q=buf;
	return p==q&&(q=(p=buf)+fread(buf,1,1000000,stdin),p==q)?EOF:*p++;
}
inline int read(){
	int res = 0;
	char c = nc();
	while(c<'0'||c>'9')c=getchar();
	while(c<='9'&&c>='0')res=res*10+c-'0',c=nc();
	return res;
}
inline double solve(int n){
	int i,j,k,pos;
	double res,ans=1;
	for(i=1;i<=n;i++){
		pos = i;
		for(j=i+1;j<=n;j++) if(fabs(a[j][i])>fabs(a[pos][i])) pos=j;
		swap(a[i],a[pos]);
		for(j=i+1;j<=n;j++){
			res = a[j][i]/a[i][i];
			for(k=i+1;k<=n;k++) a[j][k]-=a[i][k]*res;
		}
	}
	for(i=1;i<=n;i++) ans=ans*a[i][i];
	return ans;
}
int main(){
	T=read();
	while(T--){
		ans=0;
		n=read();
		for(i=1;i<=n+1;i++) for(j=1;j<=n-1;j++) p[i][j]=read();
		for(i=1;i<=n+1;i++){
			has = -1,tot = 0;
			if(i==1) has=2;
			else has=1;
			for(j=1;j<=n+1;j++){
				if(j==i||j==has) continue;
				tot++;
				for(k=1;k<=n-1;k++) a[k][tot]=p[j][k]-p[has][k];
			}
			ans += fabs(floor(solve(n-1)+1e-3));
		}
		cout<<ans%mod*inv%mod<<endl;
	}
	return 0;
}
```

---

## 作者：Selnev (赞：1)

### Step 1.

（注：下文公式省略绝对值符号，因为正负并不会影响推导的正确性，只需写代码时注意一下即可）

首先我们需要解决的第一个问题肯定是这 $ n + 1 $ 个点构成的广义凸包究竟是什么样的。这个问题其实很简单，不难发现由于坐标只会是 $ 0 $ 或 $ 1 $，没有点会处于凸包内部，也就是说每一个点都在凸包上。

然后考虑如何计算答案。首先回想一个大家可能比较熟悉的公式：$ S_{\triangle ABC} = \frac12\left|\begin{matrix}x_A & x_B\\y_A & y_B\end{matrix}\right| $：

![](https://cdn.luogu.com.cn/upload/image_hosting/ylrqzaod.png)

由此容易得到二维平行四边形的面积公式：$ S = \left|\begin{matrix}x_1 & x_2\\y_1 & y_2\end{matrix}\right| $。

观察式子，有一个大胆的假设：对于 $ N $ 维广义平行六面体，它的体积公式为：
$$
S_N = \left|\begin{matrix}x_{1, 1} & x_{2, 1} & \cdots & x_{N, 1}\\x_{1, 2} & x_{2, 2} & \cdots & x_{N, 2}\\\vdots & \vdots & \ddots & \vdots\\x_{1, N} & x_{2, N} & \cdots & x_{N, N}\end{matrix}\right|
$$
事实上这个结论是正确的，至于怎么证明，~~总之就是可以证明~~（由于证明相关的内容不是很重要，本文均放到最后；此条证明见文末 1.1）。

### Step 2.

但这个结论求的是广义平行六面体的体积，和题目要求的凸包体积又有什么关系？先不要急，考虑以下结论：$ N $ 维下的 $ N + 1 $ 个点构成的凸包，要么体积是 $ 0 $，要么是一个单纯形（网上查到的这个名字，可以理解为任意两点都相邻，比如一维线段、二维三角形和三维四面体；此条证明见文末 2.1）。

通过观察有（证明见文末 2.2）：

1. 一维下的单纯形为线段，”广义平行六面体“也为线段，它们的长度比为 $ 1 $；

2. 二维下的单纯形为三角形，”广义平行六面体“为平行四边形，它们的长度比为 $ \frac12 $；

3. 三维下的单纯形为四面体，”广义平行六面体“为平行六面体，它们的长度比为 $ \frac16 $；

4. 推测 $ N $ 维下的单纯形的体积等于对应的超平行六面体体积的 $ \frac1{(n - 1)!} $。


因此我们就能求得 $ n $ 个点构成的凸包的体积了，但是题目总共给出了 $ n + 1 $ 个点，我们仍然需要更多的结论。

### Step 3.

这一步实在挺不住了，于是打开了题解。题解给出了一条规律：这 $ n + 1 $ 个点构成的凸包的体积，等于从中任选 $ n $ 个点构成的凸包的体积的和的二分之一（证明见文末 3.1）。

然后这道题就很突然地做完了，总的来说：

1. 先枚举哪一个点不选，并用高斯消元求行列式（模板题：[P7112](https://www.luogu.com.cn/problem/P7112)，并计算得到剩余点构成的凸包的体积；
2. 将体积求和，输出总和的二分之一；

需要注意的是，由于高斯消元用的是 `double`，统计答案时一定要 `round` 一下，否则会挂掉。

``` cpp
#include <bits/stdc++.h>

#define MOD 1000000007
#define INV2 500000004

using namespace std;

int T, n;
int pos[37][37];
double mat[37][37];

double Gauss() {
	for (int i = 1; i < n; ++ i) {
		int r = i;
		for (int j = i + 1; j < n; ++ j) if (fabs(mat[j][i]) > fabs(mat[r][i])) r = j;
		if (r != i) for (int j = i; j < n; ++ j) swap(mat[i][j], mat[r][j]);
		for (int j = i + 1; j < n; ++ j) {
			if (mat[j][i]) {
				const double temp = mat[j][i] / mat[i][i];
				for (int k = i; k < n; ++ k) mat[j][k] -= mat[i][k] * temp;
			}
		}
	}
	double res = 1;
	for (int i = 1; i < n; ++ i) res *= mat[i][i];
	return res;
}


int main() {
	scanf("%d", &T);
	while (T --) {
		long long ans = 0;
		scanf("%d", &n);
		for (int i = 1; i <= n + 1; ++ i)
			for (int j = 1; j < n; ++ j)
				scanf("%d", &pos[i][j]);
		for (int i = 1; i <= n + 1; ++ i) {
			const int p0 = i == 1 ? 2 : 1;
			for (int j = 1, col = 1; j <= n + 1; ++ j) {
				if (i == j || p0 == j) continue;
				for (int k = 1; k < n; ++ k) mat[k][col] = pos[j][k] - pos[p0][k];
				++ col;
			}
			ans += (long long)(round(fabs(Gauss()))) % MOD;
			ans -= ans >= MOD ? MOD : 0;
		}
		printf("%lld\n", ans * INV2 % MOD);
	}
	return 0;
}
```

### 证明

#### 1.1. $ n $ 个点表示的广义平行六面体的体积等于各点列向量组成的行列式的绝对值

不会线性代数，挂个链接：[link1](https://www.zhihu.com/question/377129026)&[link2](https://www.zhihu.com/question/440490236)。

#### 2.1. $ n $ 维下的 $ n + 1 $ 个仿射无关的点构成的凸包是单纯形

似乎比上一条更可证一些，但想到结论之后确实还不会证明，先挂个链接：[link](https://www.cnblogs.com/wintergrass/archive/2011/10/25/2223460.html)。

#### 2.2. $ n $ 维下单纯形的体积等于对应超平行六面体体积的 $ \frac1{n!} $

（其实在 2.1 给出的链接中有这一条的证明）

首先需要一个引理：$ n $ 维超棱锥的体积等于 $ n $ 维超棱柱体积的 $ \frac1n $。

有了这个引理后就很好证明了，将 $ n $ 维单纯性称作 $ A_n $，$ n $ 维超平行六面体称作 $ B_n $ 有：
$$
V_{A_n} = h \cdot S_{A_n} \cdot \frac1{n} = h \cdot (S_{B_n} \cdot \frac{V_{A_{n-1}}}{V_{B_{n-1}}}) \cdot \frac1{n} = (h \cdot S_{B_n}) \cdot (\frac{V_{A_{n-1}}}{V_{B_{n-1}}} \cdot \frac1n) = V_{B_n} \cdot \frac1{n!}
$$

#### 3.1. $ n - 1 $ 维下 $ n + 1 $ 个点构成的凸包的体积等于从中任选 $ n $ 个点构成的凸包的体积的和的二分之一

此处给出一个自己想到的证明（说不定有问题），有点抽象，可以对照着最后给出的三维情况看。

1. 从 $ n + 1 $ 个点构成的凸包中选出 $ n - 1 $ 个点构成凸包（需要保证剩余两点不相邻，反证法不难证明肯定存在满足条件的点对），将其称为“底”。

2. 剩余两个点都一定和底上的每一个点相邻，将两者分别称为”顶点“ $ A $ 和 $ B $；

3. $ n $ 个点构成的凸包有两种可能：

   1. 没选其中一个顶点：发现没选 $ A $ 时的体积加没选 $ B $ 时的体积，恰好为总的凸包体积；

   2. 没选底上的某个点：发现所有情况的和也恰为总的凸包体积；

      证明就是考虑连接顶点与底相交于一点 $ O $，将 $ O $ 与底上各点相连，恰能分为 $ n - 1 $ 个部分，且每个部分恰属一种情况；

   两种情况相加即为总体积的两倍，得证。

（注：三维情况）

![](https://cdn.luogu.com.cn/upload/image_hosting/qln9wfwk.png)

1. 称灰色三角形为“底”。

2. 将最两侧的两个点称为“顶点” $ A $ 和 $ B $。

3. 连接 $ A $ 和 $ B $（图中未画出），与底交与图中绿色点处。连接绿色点和底上的各个点，将底分为了三个部分。

   1. 没选其中一个顶点时：灰色三角形左侧锥体以及右侧锥体，相加为整个凸包体积；
   2. 没选底上的一个点：相邻的所有部分均不属于此凸包，于是每个部分只属于一个凸包，相加也为整个凸包体积；

得证。

~~怀疑是不是写得有些冗长了。~~


---


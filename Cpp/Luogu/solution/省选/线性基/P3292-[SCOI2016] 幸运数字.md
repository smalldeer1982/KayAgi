# [SCOI2016] 幸运数字

## 题目描述


A 国共有 $n$ 座城市，这些城市由 $n - 1$ 条道路相连，使得任意两座城市可以互达，且路径唯一。每座城市都有一个幸运数字，以纪念碑的形式矗立在这座城市的正中心，作为城市的象征。

一些旅行者希望游览 A 国。旅行者计划乘飞机降落在 $x$ 号城市，沿着 $x$ 号城市到 $y$ 号城市之间那条唯一的路径游览，最终从 $y$ 城市起飞离开 A 国。在经过每一座城市时，游览者就会有机会与这座城市的幸运数字拍照，从而将这份幸运保存到自己身上。然而，幸运是不能简单叠加的，这一点游览者也十分清楚。他们迷信着幸运数字是以异或的方式保留在自己身上的。

例如，游览者拍了 $3$ 张照片，幸运值分别是 $5, 7, 11$，那么最终保留在自己身上的幸运值就是 $5 \operatorname{xor} 7 \operatorname{xor} 11 = 9$。

有些聪明的游览者发现，只要选择性地进行拍照，便能获得更大的幸运值。例如在上述三个幸运值中，只选择 $5$ 和 $11$ ，可以保留的幸运值为 $14$ 。现在，一些游览者找到了聪明的你，希望你帮他们计算出在他们的行程安排中可以保留的最大幸运值是多少。

## 说明/提示

对于 $100 \%$ 的数据，保证 $n \leq 2 \times 10^4, q \leq 2 \times 10^5, G_i \leq 2^{60}$。

## 样例 #1

### 输入

```
4 2
11 5 7 9
1 2
1 3
1 4
2 3
1 4```

### 输出

```
14 
11```

# 题解

## 作者：夜猫子驱蚊器 (赞：64)

[我的博客，欢迎来踩( • ̀ω•́ )✧](https://www.cnblogs.com/ymzqwq/p/bzoj4568.html)

提供一个两个log的在线做法，有点类似[kcz说的序列做法](https://www.luogu.org/problemnew/solution/P3292)  
kcz说的那个，可以去做[这题](https://www.luogu.org/problem/CF1100F)，裸的

对每一个点，我们可以预处理出从根到它的线性基，并且贪心的让高位的向量对应的点深度尽量大，并预处理出 $pos[x][i]$ 表示 $x$ 号结点第 $i$ 位的向量对应最深的点，可以用以下代码求出。

```cpp
LL bas[N][61];
int pos[N][61];
void ins(int p,LL bas[],int pos[]){
	LL x=a[p];
	if (x==0) return;
	rf(i,60,0)
	 if ((x>>i)&1){
	 	if (!bas[i]){
	 		bas[i]=x;pos[i]=p;
	 		break;
		}
		if (dep[p]>dep[pos[i]]) swap(pos[i],p),swap(x,bas[i]); //确保第i位深度尽量大
		x^=bas[i];
	 }
}
```
这样写正确性是显然的，当第 $i$ 位碰到了一个更深的点的时候，就相当于交换了一下插入的顺序。

然后对于一个查询 $x,y$ ，假设其LCA深度为 $d$ ，我们只取 $pos[x][i] \geq d$ 和 $pos[y][i] \geq d$ 的那些向量，暴力合并就行了ヾ(◍°∇°◍)ﾉﾞ

这个算法跑得很快，我也没特意卡常，就洛谷第二页（开O2就rank2）了，BZOJ是rank5。  
~~作为kcz的小迷妹，在此悄悄%%%kcz~~

最后贴一下丑陋的代码，感觉比点分什么的好写啊~

```cpp
#include<bits/stdc++.h>
#define LL long long
#define re register
#define fr(i,x,y) for(int i=(x);i<=(y);i++)
#define rf(i,x,y) for(int i=(x);i>=(y);i--)
#define frl(i,x,y) for(int i=(x);i<(y);i++)
#define frz(i,x,y) for(int i=x,z=y;i<=z;i++)
using namespace std;
const int N=20002;
const int M=N<<1;
const int Lg=15;
int n,q;
LL a[N];
int cnt,head[N],Next[M],v[M];

inline void read(int &x){
	char ch=getchar();x=0;int w=0;
	for(;ch<'0'||ch>'9';ch=getchar()) if (ch=='-') w=1;
	for(;ch>='0'&&ch<='9';ch=getchar()) x=(x<<3)+(x<<1)+ch-'0';
	if (w) x=-x;
}
inline void read(LL &x){
	char ch=getchar();x=0;int w=0;
	for(;ch<'0'||ch>'9';ch=getchar()) if (ch=='-') w=1;
	for(;ch>='0'&&ch<='9';ch=getchar()) x=(x<<3)+(x<<1)+ch-'0';
	if (w) x=-x;
}

void add(int x,int y){ Next[++cnt]=head[x];head[x]=cnt;v[cnt]=y; }

int dep[N],f[N][Lg];
LL bas[N][61];
int pos[N][61];
void ins(int p,LL bas[],int pos[]){
	LL x=a[p];
	if (x==0) return;
	rf(i,60,0)
	 if ((x>>i)&1){
	 	if (!bas[i]){
	 		bas[i]=x;pos[i]=p;
	 		break;
		}
		if (dep[p]>dep[pos[i]]) swap(pos[i],p),swap(x,bas[i]);
		x^=bas[i];
	 }
}

void dfs(int x,int fa){
	dep[x]=dep[fa]+1;
	f[x][0]=fa;
	frl(i,1,Lg) f[x][i]=f[f[x][i-1]][i-1];
	
	fr(i,0,60) pos[x][i]=pos[fa][i],bas[x][i]=bas[fa][i];
	ins(x,bas[x],pos[x]);
	
	for(int i=head[x];i;i=Next[i])
	 if (v[i]!=fa) dfs(v[i],x);
}

int getLCA(int x,int y){
	if (dep[x]<dep[y]) swap(x,y);
	rf(i,Lg-1,0) if (dep[f[x][i]]>=dep[y]) x=f[x][i];
	if (x==y) return x;
	rf(i,Lg-1,0) if (f[x][i]!=f[y][i]) x=f[x][i],y=f[y][i];
	return f[x][0];
}

LL base[61];
int main(){
	read(n);read(q);
	fr(i,1,n) read(a[i]);
	int x,y;
	fr(i,2,n){
		read(x);read(y);
		add(x,y);add(y,x);
	}
	dfs(1,0);
	while(q--){
		read(x);read(y);
		int lca=getLCA(x,y);
		rf(i,60,0) if (dep[pos[x][i]]>=dep[lca]) base[i]=bas[x][i];else base[i]=0;
		rf(i,60,0)
		 if (dep[pos[y][i]]>=dep[lca]){
		 	LL x=bas[y][i];
		 	if (x==0) continue;
		 	rf(j,i,0)
		 	 if ((x>>j)&1){
		 	 	if (!base[j]){ base[j]=x;break; }
				x^=base[j];
			 }
		 }
		LL ans=0;
		rf(i,60,0) if ((ans^base[i])>ans) ans^=base[i];
		printf("%lld\n",ans);
	}
	return 0;
}
```

---

## 作者：kczno1 (赞：40)

亦或最大值<=>求出线性基。

线性基支持O(log)插入。

由于向量只有log个，合并时O(log)复制，之后暴力插入，合并时间O(log^2)。

如果用倍增，必然就要合并多个线性基，时间就会是log^3。

考虑用点分治，

O(nlogn)得到根到每个点的线性基，

处理lca在当前根的询问，就只用合并两个线性基。

时间O((n+q)\*log^2)

(如果是序列上的还可以做到只有一个log，

从左到右枚举右端点，贪心的让高位的向量对应的左端点尽量靠右边。

查询时只使用左端点在询问左端点右边的向量。)

我还有一个想法是用tarjan。(这种我还没写过)

当一个询问两个点都被访问后在lca处打个标记，

当lca处理完子树后，处理所有标记。

O((n+m)a\*log^2)

可以先处理lca，再来一遍tarjan处理询问。

```cpp
#include<bits/stdc++.h>

#define us unsigned short
#define ll long long
const int N=20010,M=200010;

int n,m,i,x,y;
ll a[N];
int t[N];
struct edge
{
    int to,next;
}l[N+M<<1];int e;
int qt[N];
ll ans[M];bool have[M];

bool vis[N];
us q[N],head,tail;
namespace kcz
{
us sz[N],f[N];
us get_g(int x)
{
    q[tail=1]=x;f[x]=0;
    for(head=1;head<=tail;++head)
    {
        x=q[head];sz[x]=1;
        for(i=t[x];y=l[i].to;i=l[i].next) 
        if(!vis[y]&&y!=f[x])
        {
            f[y]=x;
            q[++tail]=y;
        }
    }
    for(head=tail;head;--head)
    {
        x=q[head];
      if(sz[x]>=(tail>>1)) return x;
        sz[f[x]]+=sz[x];
    }
}
};
us belong[N];
ll g[61],f[N][61];

void ins(ll *f,ll x)
{
    short i; 
    for(i=60;x;--i) 
    if((x>>i)&1) 
     if(!f[i]){f[i]=x;return ;}
     else x^=f[i];
}
ll qiu(ll *f)
{
    ll ans=0;
    for(short i=60;i>=0;--i)
    if((ans^f[i])>ans) ans^=f[i];
    return ans;
}
us now;
void dfs(us x,us fr)
{
    belong[x]=now;
    int i;us y;
    for(i=0;i<=60;++i) f[x][i]=f[fr][i];
    ins(f[x],a[x]);
    for(i=t[x];y=l[i].to;i=l[i].next)
    if(y!=fr&&!vis[y]) dfs(y,x);
}
void merge(ll *g,ll *f1,ll *f2)
{
    int i;
    for(i=0;i<=60;++i) g[i]=f1[i];
    for(i=0;i<=60;++i) ins(g,f2[i]);
}
void solve(int x)
{
    vis[x]=1;
    belong[x]=0;
    for(i=0;i<=60;++i) f[x][i]=0;
    ins(f[x],a[x]);
    for(i=t[x];now=l[i].to;i=l[i].next) dfs(now,x);
    for(head=1;head<=tail;++head) 
    {
        x=q[head];
        for(i=qt[x];y=l[i].to;i=l[i].next)
        if(!have[i>>1]&&belong[x]!=belong[y])
        {
            have[i>>1]=1;
            merge(g,f[x],f[y]);
            ans[i>>1]=qiu(g);
        }
    } 
}

#define ch_top 10000000
char ch[ch_top],*now_r=ch,*now_w=ch-1;
void read(int &x)
{
    while(*now_r<'0') ++now_r;
    for(x=*now_r-'0';*++now_r>='0';) x=(x<<1)+(x<<3)+*now_r-'0';
}
void read(ll &x)
{
    while(*now_r<'0') ++now_r;
    for(x=*now_r-'0';*++now_r>='0';) x=(x<<1)+(x<<3)+*now_r-'0';
}
void write(ll &x)
{
    static us st[30],top;
    if(!x) *++now_w='0';
    else
    {
        for(;x;x/=10) st[++top]=x%10;
        for(;top;--top) *++now_w='0'+st[top];
    }
    *++now_w='\n';
}

int main()
{ freopen("1.in","r",stdin);freopen("1.out","w",stdout);
    fread(ch,1,ch_top,stdin);
    read(n);read(m);
    int i;
    for(i=1;i<=n;++i) read(a[i]);
    e=M<<1; 
    for(i=1;i<n;++i)
    {
        read(x);read(y);
        l[++e]=(edge){y,t[x]};t[x]=e;
        l[++e]=(edge){x,t[y]};t[y]=e;
    }
    e=1;
    for(i=1;i<=m;++i) 
    {
        read(x);read(y);
        l[++e]=(edge){y,qt[x]};qt[x]=e;
        l[++e]=(edge){x,qt[y]};qt[y]=e;
        if(x==y) {have[i]=1;ans[i]=a[x];}
    }
    for(i=1;i<=n;++i) 
    while(!vis[i]) solve(kcz::get_g(i));
    for(i=1;i<=m;++i) write(ans[i]);
    fwrite(ch,1,now_w-ch+1,stdout);
}
O(n*a+m*a*log^2)

```

---

## 作者：TopCarry (赞：35)

## 事实上我们完全可以用倍增做到两个$log$。

&emsp;&emsp;因为线形基是**可以支持**$RMQ$的，因为中间重复的部分在第二次插入的时候就不会被插进去，所以我们只要使用倍增，每次询问不用倍增合并$log$次线形基，而用$RMQ$的思想合并即可抹去一个$log$。

&emsp;&emsp;总复杂度$O(mlog^2n+nlog^3n)$。因为$n$比$m$小很多所以是可以接受的。
```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<iostream>
using namespace std;
#define ll long long
#define gc getchar()
inline ll read(){
	register ll x(0),f(1);register char c(gc);
	while(c>'9'||c<'0')f=c=='-'?-1:1,c=gc;
	while(c>='0'&&c<='9')x=x*10+c-48,c=gc;
	return f*x;
}
const int N=21000;
void ins(ll x,ll *A){
	register int i;
	if(x) 
	for(i=60;i>=0;i--)
		if((1ll<<i)&x)
			if(!A[i]){A[i]=x;break;}
			else{x^=A[i];}
		else if(!x){
			break;
		}
}
void merge(ll *A,ll *C){
	register int i;
	for(i=60;i>=0;i--)if(A[i])ins(A[i],C);
}
struct edge{
	int next,to;
}e[N<<1];
int head[N],tot;
void add(int x,int y){
	e[++tot].next=head[x];e[tot].to=y;head[x]=tot;
}
int fa[N][24],lg[N],deep[N],n,m;
ll d[N][24][64],val[N];
void dfs(int u,int fath){
	deep[u]=deep[fath]+1;
	fa[u][0]=fath;
	ins(val[u],d[u][0]);
	for(int i=1;i<=lg[deep[u]];i++){
		fa[u][i]=fa[fa[u][i-1]][i-1];
		merge(d[u][i-1],d[u][i]);
		merge(d[fa[u][i-1]][i-1],d[u][i]);
	}
	for(int i=head[u];i;i=e[i].next)
		if(e[i].to!=fath)
			dfs(e[i].to,u);
}
int get(int x,int y){
	if(deep[x]<deep[y])swap(x,y);
	while(deep[x]>deep[y]){
		x=fa[x][lg[deep[x]-deep[y]]];
	}
	if(x==y)return x;
	for(int i=20;i>=0;i--)
		if(fa[x][i]!=fa[y][i])x=fa[x][i],y=fa[y][i];
	return fa[x][0];
}
ll ans[100];
int kth(int x,int K){
	for(int i=20;i>=0;i--){
		if(K&(1<<i))x=fa[x][i];
	}
	return x;
}
ll query(ll x,ll y){
	register int i;
	memset(ans,0,sizeof(ans));
	int lca=get(x,y); 
	int len=lg[deep[x]-deep[lca]];
	merge(d[lca][0],ans);
	merge(d[x][len],ans);
	merge(d[kth(x,deep[x]-deep[lca]-(1<<len))][len],ans);
	len=lg[deep[y]-deep[lca]];
	merge(d[y][len],ans);
	merge(d[kth(y,deep[y]-deep[lca]-(1<<len))][len],ans);
	ll now=0;
	for(i=60;i>=0;i--)if((now^ans[i])>now)now^=ans[i];
	return now;
} 
int main(){
	n=read();m=read();
	register int i;
	for(i=1;i<=n;i++)val[i]=read();
	for(i=2;i<=n;i++)lg[i]=lg[i/2]+1;
	for(i=1;i<n;i++){
		int x=read(),y=read();
		add(x,y);add(y,x);
	}
	dfs(1,0);
	for(i=1;i<=m;i++){
		int x=read(),y=read();
		cout<<query(x,y)<<'\n';
	}
	return 0;
}
```


---

## 作者：Calculatelove (赞：20)

[可能更好的阅读体验。](https://www.cnblogs.com/cjtcalc/p/13393163.html)

## Description

给出一棵包含 $n$ 个点的树，点带权。

有 $Q$ 次询问，每次询问给出两个点 $x$ 和 $y$，求 $x$ 到 $y$ 的简单路径上，任意选择若干个点，使得其点权异或和最大。

数据范围：$1 \leq n \leq 2 \times 10^4$，$1 \leq Q \leq 2 \times 10^5$，$0 \leq g_i \leq 2^{60}$。  
时空限制：$4000 \ \mathrm{ms} / 256 \ \mathrm{MiB}$。

## Solution

首先我们知道线性基是可以暴力合并的，即把线性基 $b$ 的元素一个个地插入线性基 $a$ 中。定义 $\text{merge}$ 运算合并两个线性基，显然 $\text{merge}$ 运算的复杂度是 $\mathcal{O}(\log^2 n)$ 的。

考虑树上倍增。设 $f(i, j)$ 表示节点 $i$ 向上跳 $2^j$ 步所到达的节点编号，设 $g(i, j)$ 表示节点 $i$ 向上跳 $2^j$ 步所经过的所有节点（不包括节点 $i$）的点权所组成的线性基。则有：
$$
f(i, j) = f(f(i, j - 1), j - 1)
$$

$$
g(i, j) = g(i, j - 1) \ \text{merge} \ g(f(i, j - 1), j - 1)
$$

通过简单的 BFS 即可预处理出 $f$ 与 $g$。询问也按照倍增求 $\text{LCA}$ 的框架，令 $x, y$ 向上跳，$x, y$ 每向上移动一段路径，就合并该路径对应的线性基。

至此我们有一个 $\mathcal{O}(n \log^3 n) - O(\log^3 n)$ 的做法。

这个做法还不够优秀，考虑挖掘线性基合并的一些性质。

---

树上倍增的一个 trick：若一个运算满足 $a \oplus a = a$，则我们称这个运算（例如 $\max$、$\min$、$\gcd$ 等）满足 **" 可重复贡献 "** 性。考虑 $x$ 到 $y$ 之间的路径，记 $z = \text{LCA}(x, y)$。

![G.png](https://i.loli.net/2020/07/28/D8Z7Wq3VsfPzhXd.png)

我们将 $x$ 到 $y$ 的路径分成了 红路径、 橙路径、黄路径、 绿路径 四部分，每一部分的长度都是不超过 " 所在大路径的长度 " 的 $2$ 的**最大整数次**幂（红路径 和 橙路径 归在 $x$ 到 $z$ 的大路径里，黄路径 和 绿路径 归在 $y$ 到 $z$ 的大路径里），每一部分的贡献都可以通过倍增数组求出，故答案为 红路径贡献 $\oplus$ 橙路径贡献 $\oplus$ 黄路径贡献 $\oplus$ 绿路径贡献。

设 $\oplus$ 运算的复杂度为 $\mathcal{O(w)}$，若配合 " 长链剖分求树上 $k$ 级祖先 " 以及 " tarjan 求 $\text{lca}$ "，即可 $\mathcal{O(w)}$ 回答询问。

---

回到此题，注意到线性基合并也是满足 **" 可重复贡献 "** 性的。具体的说：若线性基 $a$ 与线性基 $b$ 所代表的路径之间有交集，则线性基 $a$ 与线性基 $b$ 经过 $\text{merge}$ 运算后所得到的线性基代表的路径为线性基 $a$ 与线性基 $b$ 所代表的路径的并集。因为交集部分的元素在重复插入线性基的时候显然不会多做贡献。

![P.png](https://i.loli.net/2020/07/28/nzWkjg7UE6XdT8q.png)

于是套用上述 trick 即可将复杂度优化至 $\mathcal{O}(n \log^3 n) - O(\log^2 n)$。

注意到 $\text{merge}$ 操作的复杂度为 $\mathcal{O}(\log^2 n)$，所以我们还是可以用树上倍增来求  " 树上 $k$ 级祖先 " 以及 " $\text{lca}$ "。

```c++
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <queue>

using namespace std;

const int N = 20100, M = 40100;

int logx[N];

int n, m;

long long val[N];

int tot, head[N], ver[M], Next[M];

void add(int u, int v) {
	ver[++ tot] = v;    Next[tot] = head[u];    head[u] = tot;
}

struct bas {
	long long p[64];
	bas() { 
		for (int i = 0; i <= 63; i ++)
			p[i] = 0;
	} 
};

long long calc(bas a) {
	long long ans = 0;
	for (int i = 63; i >= 0; i --)
		if ((ans ^ a.p[i]) > ans) ans ^= a.p[i];
	return ans;
}

bas operator + (bas a, long long x) { 
	for (int i = 63; i >= 0; i --) {
		if (!(x >> i)) continue;
		if (!a.p[i]) { a.p[i] = x; break; }
		else x ^= a.p[i];
	}
	return a;
}

bas operator + (bas a, bas b) {
	for (int i = 63; i >= 0; i --)
		if (b.p[i]) a = a + b.p[i];
	return a;
}

int d[N];
int f[N][20];
bas g[N][20];

void bfs() {
	queue<int> q;
	q.push(1), d[1] = 1;
	while (q.size()) {
		int u = q.front(); q.pop();
		for (int i = head[u]; i; i = Next[i]) {
			int v = ver[i];
			if (d[v]) continue;
			d[v] = d[u] + 1;
			f[v][0] = u;
			g[v][0] = g[v][0] + val[u];
			for (int j = 1; j <= 19; j ++) {
				f[v][j] = f[f[v][j - 1]][j - 1];
				if (f[v][j]) g[v][j] = g[v][j - 1] + g[f[v][j - 1]][j - 1];
			}
			q.push(v);
		}
	}
} 

int lca(int x, int y) {
	if (d[x] > d[y]) swap(x, y);
	for (int i = 19; i >= 0; i --)
		if (d[x] <= d[f[y][i]]) y = f[y][i];
	if (x == y) return x;
	for (int i = 19; i >= 0; i --)
		if (f[x][i] != f[y][i]) x = f[x][i], y = f[y][i];
	return f[x][0];
} 

int jump(int x, int lv) {
	for (int i = 19; i >= 0; i --)
		if (lv >> i & 1) x = f[x][i];
	return x;
}

long long ask(int x, int y) {
	bas ans;
	ans = ans + val[x];
	ans = ans + val[y];
	int L = lca(x, y);
	if (d[x] - d[L] >= 1) {
		int lv = logx[d[x] - d[L]];
		ans = ans + g[x][lv];
		ans = ans + g[jump(x, d[x] - d[L] - (1 << lv))][lv];
	} if (d[y] - d[L] >= 1) {
		int lv = logx[d[y] - d[L]];
		ans = ans + g[y][lv];
		ans = ans + g[jump(y, d[y] - d[L] - (1 << lv))][lv];
	}
	return calc(ans);
}

int main() {
	logx[0] = -1;
	for (int i = 1; i <= 20000; i ++)
		logx[i] = logx[i / 2] + 1;

	scanf("%d%d", &n, &m);

	for (int i = 1; i <= n; i ++)
		scanf("%lld", &val[i]);

	for (int i = 1, u, v; i < n; i ++) {
		scanf("%d%d", &u, &v);
		add(u, v), add(v, u);
	}

	bfs();

	while (m --) {
		int x, y; scanf("%d%d", &x, &y);
		printf("%lld\n", ask(x, y));
	} 

	return 0;
}
```

---

## 作者：帅到报警 (赞：15)

[不知道倍增LCA是什么的出门左转！](https://www.luogu.org/problemnew/show/P3379)

[不知道线性基是什么的出门右转！](https://www.luogu.org/problemnew/show/P3812)

### 【题意分析】
好吧我刚看到这道题的时候真的没有想出怎么做。。。（~~我只是一只线性基蒟蒻~~）然后我只能打一把暴力，按照 LCA 模板推出倍增线性基的写法。（’へ’）

然后。。就 A 了、、

（原来这就是一道树上暴力倍增合并线性基的题目，不过我整整打了3天）

我们知道线性基找最大异或和的做法后，就可以知道如何将两条路的线性基合并起来了。我们**只要将某一条路上线性基的所有元素再用原来线性基的做法加入另一条路的线性基中即可**。然后在处理 LCA 的时候顺便处理好倍增线性基，每次查询就维护一个 ans 数组，在两个点不断往上跳的时候将线性基照上述处理方法塞入 ans 数组中去。最后按照模板找出最大异或和。

### 【核心代码】
1、合并两条路：遍历 b 数组的所有元素，如果这一位不为 0，（即需要合并）就塞入 a 中去
```cpp
void Merge(ll *a, ll *b)
{
	for(int i = 61; i >= 0; i--)
	{
		if(b[i])
			Get_p(a, b[i]);
	}
}
```
2、每次询问做一遍 LCA
```cpp
void Solve()
{
	for(int i = 1; i <= q; i++)
	{
		memset(ans, 0, sizeof(ans));
		int u = read(), v = read();
		Lca(u, v);
		sum = 0;
		for(int j = 61; j >= 0; j--)
			sum = Max(sum, sum ^ (ll)ans[j]);
		printf("%lld\n", sum);
	}
}
```

### 【正解】
```cpp
#include <bits/stdc++.h>
#define N 20010
#define ll long long
using namespace std;

ll sum;
int n, q, tot;
ll G[N], Head[N << 1], dep[N], ans[N];
ll fa[N][21], p[N][21][62];

struct Edge{
	int to, nxt; 
}edge[N << 1];

inline ll read()//不用快读会T..
{
    char ch = getchar();
	ll x = 0, f = 1;
    while(ch > '9' || ch < '0')
	{
		if(ch == '-')
			f = -1;
		ch = getchar();
	}
    while(ch >= '0' && ch <= '9')
	{
		x = x * 10 + ch - '0';
		ch = getchar();
	}
    return x * f;
}

inline ll Max(ll a, ll b)//手打max省时
{
	return a > b ? a : b;
}

inline void Add_edge(int u, int v)
{
	edge[++tot].nxt = Head[u], edge[tot].to = v, Head[u] = tot;
	edge[++tot].nxt = Head[v], edge[tot].to = u, Head[v] = tot;
}

inline void Get_p(ll *a, ll val)//构造线性基
{
	for(int i = 61; i >= 0; i--)
	{
		if((val >> i) & 1)
		{
			if(!a[i])
			{
				a[i] = val;
				break;
			}
			val ^= a[i];
		}
	} 
}

void Dfs(int u, int v)//信仰大法师预处理ᕦ(ò_óˇ)ᕤ
{
	fa[v][0] = u;
	dep[v] = dep[u] + 1;
	for(int i = Head[v]; i; i = edge[i].nxt)
	{
		int w = edge[i].to;
		if(w == u)
			continue;
		Dfs(v, w);
	}
}

void Merge(ll *a, ll *b)//合并
{
	for(int i = 61; i >= 0; i--)
	{
		if(b[i])
			Get_p(a, b[i]);
	}
}

void Get_lca()//lca预处理
{
	for(int j = 1; j < 20; j++)
	{
		for(int i = 1; i <= n; i++)
		{
			fa[i][j] = fa[fa[i][j - 1]][j - 1];
			memcpy(p[i][j], p[i][j - 1], sizeof(p[i][j - 1]));
			Merge(p[i][j], p[fa[i][j - 1]][j - 1]);
		}
	}
}

inline void Lca(int u, int v)//查询lca并塞 ans
{
	if(dep[u] < dep[v])
		swap(u, v);
	for(int i = 20; i >= 0; i--)
		if(dep[fa[u][i]] >= dep[v])
			Merge(ans, p[u][i]), u = fa[u][i];
	if(u == v)
	{
		Merge(ans, p[u][0]);
		return;
	}
	for(int i = 20; i >= 0; i--)
		if(fa[u][i] != fa[v][i])
		{
			Merge(ans, p[u][i]), Merge(ans, p[v][i]);
			u = fa[u][i], v = fa[v][i];
		}
	Merge(ans, p[u][0]), Merge(ans, p[v][0]), Merge(ans, p[fa[u][0]][0]);
}

void Solve()
{
	for(int i = 1; i <= q; i++)
	{
		memset(ans, 0, sizeof(ans));
		int u = read(), v = read();
		Lca(u, v);
		sum = 0;
		for(int j = 61; j >= 0; j--)
			sum = Max(sum, sum ^ (ll)ans[j]);
		printf("%lld\n", sum);
	}
}

int main()
{
	freopen("2335.in", "r", stdin);
	freopen("2335.out", "w", stdout);
	n = read(), q = read();
	for(int i = 1; i <= n; i++)
		Get_p(p[i][0], G[i] = read());
	for(int i = 1; i <= n - 1; i++)
	{
		int u = read(), v = read();
		Add_edge(u, v);
	}
	Dfs(0, 1);
	Get_lca();
	Solve();
	
	return 0;
}
```

---

## 作者：Dispwnl (赞：12)

### [博客](https://a-failure.github.io/2018/06/17/SCOI2016-%E5%B9%B8%E8%BF%90%E6%95%B0%E5%AD%97/)

提供一种树链剖分的思路

求最大XOR，可以用线性基搞

但是这是在树上操作，所以得变化一下

考虑树链剖分，线段树每个节点都储存两个子节点的线性基合并后的线性基

然后查询时每次提出一条链的线性基，跟答案线性基合并

最后在答案线性基上求最大值就行了

时间复杂度为$O(nlogn^4)$（应该），似乎点分治能搞到$O(nlogn^2)$。。。？

代码：
```
# include<iostream>
# include<cstring>
# include<cstdio>
# include<cstdlib>
# include<algorithm>
# define LL long long
# define tl (k<<1)
# define tr (k<<1|1)
# define mid (l+r>>1)
using namespace std;
const int MAX=2e4+1;
struct o{
    int x,y;
}c[MAX<<1];
int n,q,cnt,num;
int h[MAX],top[MAX],id[MAX],d[MAX],son[MAX],siz[MAX],fa[MAX];
LL a[MAX],w[MAX],ans[61],tran[61];
LL s[MAX<<2][61];
LL read()
{
    LL x=0;
    char ch=getchar();
    for(;!isdigit(ch);ch=getchar());
    for(;isdigit(ch);x=x*10+ch-48,ch=getchar());
    return x;
}
void add(int x,int y)
{
    c[++num]=(o){h[x],y},h[x]=num;
    c[++num]=(o){h[y],x},h[y]=num;
}
void dfs(int x,int f)
{
    fa[x]=f,d[x]=d[f]+1,siz[x]=1;
    for(int i=h[x];i;i=c[i].x)
      {
      	int y=c[i].y;
      	if(y==f) continue;
        dfs(y,x);
        siz[x]+=siz[y];
        if(siz[y]>siz[son[x]]) son[x]=y;
      }
}
void dfs1(int x,int tp)
{
    top[x]=tp,id[x]=++cnt,w[cnt]=a[x];
    if(son[x]) dfs1(son[x],tp);
    for(int i=h[x];i;i=c[i].x)
      {
      	int y=c[i].y;
      	if(y==fa[x]||y==son[x]) continue;
      	dfs1(y,y);
      }
}
void ins(LL *a,LL x)
{
    for(int i=60;~i;--i)
      if(x&(1ll<<i))
      if(!a[i])
      {
      	a[i]=x;
      	break;
      }
      else x^=a[i];
}
void merge(LL *a,LL *b)
{
    for(int i=60;~i;--i)
      if(b[i]) ins(a,b[i]);
}
void pus(int k)
{
    merge(s[k],s[tl]),merge(s[k],s[tr]);
}
void build(int l,int r,int k)
{
    if(l==r)
    {
        ins(s[k],w[l]);
        return;
    }
    build(l,mid,tl),build(mid+1,r,tr);
    pus(k);
}
LL GET_MAX()
{
    LL tot=0;
    for(int i=60;~i;--i)
      if((tot^ans[i])>tot) tot^=ans[i];
    return tot;
}
void ask(int l,int r,int k,int L,int R)
{
    if(l==L&&r==R)
    {
        merge(tran,s[k]);
        return;
    }
    if(R<=mid) ask(l,mid,tl,L,R);
    else if(L>mid) ask(mid+1,r,tr,L,R);
    else ask(l,mid,tl,L,mid),ask(mid+1,r,tr,mid+1,R);
}
LL ASK(int x,int y)
{
    for(int i=0;i<=60;++i)
      ans[i]=0;
    while(top[x]!=top[y])
    {
        if(d[top[x]]<d[top[y]]) swap(x,y);
        for(int i=0;i<=60;++i)
          tran[i]=0;
        ask(1,n,1,id[top[x]],id[x]);
        merge(ans,tran);
        x=fa[top[x]];
    }
    if(d[x]>d[y]) swap(x,y);
    for(int i=0;i<=60;++i)
      tran[i]=0;
    ask(1,n,1,id[x],id[y]);
    merge(ans,tran);
    return GET_MAX();
}
int main()
{
    n=read(),q=read();
    for(int i=1;i<=n;++i)
      a[i]=read();
    for(int i=1;i<n;++i)
      add(read(),read());
    dfs(1,0),dfs1(1,1),build(1,n,1);
    for(int i=1;i<=q;++i)
      {
      	int x=read(),y=read();
      	printf("%lld\n",ASK(x,y));
      }
    return 0;
}
```

---

## 作者：jun头吉吉 (赞：9)

### 题意
给出一棵树，求树上两点间简单路径上的点的异或最大值
### 题解
**一道线性基+倍增LCA的二合一板子题**

考虑到求异或的最大值肯定需要**线性基**，而线性基作为一种神奇的结构，它具有以下性质
- 设线性基的异或集合中不存在0，即异或集合中每个元素的异或方案唯一

- 线性基二进制最高位互不相同。

- 线性基中元素互相异或，异或集合不变。

利用这些性质，我们可以用$O(log^2n)$的时间复杂度合并，合并就是把一个基中的所有值插进另一个基~~众所周知，$\texttt{Oier}$是不需要证明的~~

再来考虑倍增求LCA的操作，我们预处理出每个节点的$i$倍父亲，转移方程是长这样的：
```cpp
f[now][i]=f[f[now][i-1]][i-1]
```
那我们也可以用这样的方法，求出$x$到它的$i$倍父亲（不包括）的线性基，在往上跳的时候把线性基合并一下就ok了

```cpp
#include<bits/stdc++.h>
using namespace std;
template<typename T>
inline void read(T &x){
	x=0;char c=getchar();bool f=false;
	for(;!isdigit(c);c=getchar())f!=c=='-';
	for(;isdigit(c);c=getchar())x=x*10+c-'0';
	if(f)x=-x;
}
template<typename T ,typename ...Arg>
inline void read(T &x,Arg &...args){
	read(x);read(args...);
}
template<typename T>
inline void write(T x){
	if(x<0)putchar('-'),x=-x;
	if(x>=10)write(x/10);
	putchar(x%10+'0');
}
typedef long long ll;
const ll maxn=20000+100;
const ll maxm=20000+100;
bool flag[maxn];
ll dis[maxn];
const ll maxn_wei=61;
struct XXJ{
	//线性基板子
	ll b[maxn_wei];
	void init(){memset(b,0,sizeof b);}
	void insert(ll x){
		for(ll i=maxn_wei-1;i>=0;i--){
			if(!(x&(1ll<<i)))continue;
			if(!b[i]){
				b[i]=x;
				return ;
			}
			x^=b[i];
		}
	}
	XXJ operator+(const XXJ b)const{
		XXJ New=*this;
		for(int i=0;i<maxn_wei;i++)
			if(b.b[i])
				New.insert(b.b[i]);
		return New;
	}
};
struct Graph{
	struct Edge{ll v,nxt;}e[maxm*2];
	ll cnt,head[maxn];
	void init(){memset(head,0,sizeof head);cnt=0;}
	void add(ll u,ll v){e[++cnt]=(Edge){v,head[u]};head[u]=cnt;}
	#define For(G,i) for(ll eee=(G).head[(i)];eee;eee=(G).e[eee].nxt)
	#define v(G) (G).e[eee].v
}G;
ll n,m,u,v,w;
int f[maxn][15];
XXJ b[maxn][15];
int lg[maxn];
int depth[maxn];
ll g[maxn];
void dfs(int now,int fath){
	f[now][0]=fath;depth[now]=depth[fath]+1;
	b[now][0].init();b[now][0].insert(g[now]);
	for(int i=1;i<=lg[depth[now]];++i)
    	f[now][i]=f[f[now][i-1]][i-1],
		b[now][i]=b[now][i-1]+b[f[now][i-1]][i-1];
	For(G,now)if(v(G)!=fath)dfs(v(G),now);
}
XXJ lca(int x,int y){
	XXJ tmp;tmp.init();
	if(depth[x]<depth[y])//令x更深
		swap(x,y);
	while(depth[x]>depth[y])
		tmp=tmp+b[x][lg[depth[x]-depth[y]]-1],
		x=f[x][lg[depth[x]-depth[y]]-1];
	if(x==y){//如果x是y的祖先，那他们的LCA肯定就是x了
		tmp.insert(g[x]);
		return tmp;
	}
	for(int k=lg[depth[x]]-1;k>=0;k--)//向上跳
		if(f[x][k]!=f[y][k]) //因为我们要跳到LCA的下面一层，所以它们肯定不相等
	    	tmp=tmp+b[x][k]+b[y][k],x=f[x][k],y=f[y][k];
	tmp.insert(g[f[x][0]]);
	tmp.insert(g[x]);
	tmp.insert(g[y]);
	
	return tmp;
}
signed main(){
	read(n,m);
	for(int i=1;i<=n;i++)
		read(g[i]);
	for(ll i=1;i<n;i++){
		read(u,v);
		G.add(u,v);
		G.add(v,u);
	}
	for(int i=1;i<=n;++i)
		lg[i]=lg[i-1]+(1<<lg[i-1]==i);
	dfs(1,-1);
	while(m--){
		int x,y;read(x,y);
		XXJ get=lca(x,y);
		ll ans=0;
		for(int i=maxn_wei-1;i>=0;i--)
			ans=max(ans,ans^get.b[i]);
		write(ans);putchar('\n');
	}
}
```

---

## 作者：KaguyaH (赞：8)

### 前置知识

- [线性基](https://www.luogu.com.cn/problem/P3812)。
- [LCA](https://www.luogu.com.cn/problem/P3379)。

### 题意简述
- 给定一棵 $n$ 个节点的**树**，求两点间路径上所有点权的**异或最大值**。

- $n \le 2 \times 10^4$，$q \le 2 \times 10^5$。

### 题目分析
异或最大值，想到**线性基**。

因为线性基满足：
对于集合 $A, B$，把 $B$ 的线性基依次插入到 $A$ 的线性基中即可得到 $A \cup B$ 的线性基；
    
故我们可以使用倍增 LCA 的思想，在倍增的同时维护答案的线性基。

预处理出每个节点的 $2^k$ 级祖先的同时处理出每个节点到 $2^k$ 级祖先的线性基即可。

时间复杂度 $O(n \log n \log^2 G_i + q \log n \log^2 G_i) = O(n \log^3 G_i + q \log^3 G_i)$，约为 $11.1 \times 10^9$ 级别。

### [代码](https://www.luogu.com.cn/paste/odjuffsk)

这份代码加上火车头再加上一些毒瘤优化可以用 C++17 过掉这道题（详见本人评测记录）。

### 优化

但是，自带大常数的选手发现只得了 30 分。

下面是为大常数但却希望用 C++ 语言不开 O2 AC 的选手准备的优化。

我们考虑，如果把这两个节点到 LCA 的路径用类似 ST 表的方式维护，即想办法只在答案线性基中只插入常数次节点，那么我们就可以把每次询问的时间复杂度从 $O(\log n \log^2 G_i)$ 降为 $O(\log n + \log^2 G_i)$。

STL 库的常数也比较大，故把所有 STL 中的函数与类手写一遍，再加上读写优化。

做完这些，你就能用 C++ 拿到 70 分的好成绩。

但是还不够。

我们发现，在插入线性基时，插入的数常常会很早变为 $0$，此时直接退出即可。

在倍增 LCA 时，也会有类似的情况出现（提前倍增到指定位置），同样直接进行下一步。

### [代码](https://www.luogu.com.cn/paste/52injktf)

---

## 作者：EastPorridge (赞：6)

写了一个 [猫树](https://www.luogu.com.cn/blog/EastPorridge/cat-tree) 的博客，里面有几道题。

### 题目分析：

我们有个最暴力的做法，树剖线段树套线性基，树剖，线段树各一个 $\log$，线性基合并俩 $\log$，一共四个 $\log$。

$\log$ 叠在一起，很难受，我们可以直接离线掉它。

具体来说就是我们树剖每次会从树上拆分出一条路径，我们没必要立刻知道它的答案，而是再把它看成一个询问，这样的复杂度怎么样呢？

树剖一次最多会跳 $\log n$ 个链头，$q$ 次询问，所以我们把原问题拆成了**序列**上的 $q \log n$ 个子问题，每个问题是求 $l \sim r$ 这个区间任选值，使它的异或和最大。

怎么做呢？再用线段树是没区别的，我们考虑再次离线，这个问题可以使用猫树分治解决，具体的，我们每次维护以 $\text{mid}$ 为中心的，$l \sim \text{mid}$ 的后缀线性基和 $\text{mid+1} \sim r$ 的前缀线性基，如果此时询问区间 $[L,R]$ 横跨 $\text{mid}$，则可以通过合并左右两个线性基得出答案，否则，它一定在 $\text{mid}$ 的一边，分治下去就可以了。

这样做的复杂度瓶颈在线性基合并，是两个 $\log$ 的。

再进一步的，我们求出了 $q \log n$ 个子问题又能怎么样呢？能线性基合并。

我们求子问题的解是没用的，有用的是子问题的线性基，我们把猫树分治求出来的线性基再次合并。

理论部分结束，交一发，[寄了](https://www.luogu.com.cn/record/100349808)。

它跑的确实很快，考虑一下 MLE 的原因，原因是存的 $q \log n$ 个线性基，是一个很大的 $10^7$，虽然树剖一般不可能这么 $\log$，会小一点。

我们拿 `vector` 把它存下来，resize 来动态开空间，把树剖几件套换成 `short`，用完边直接用 `shrink_to_fit()` 把它释放掉，还有就是询问区间为 $l=r$ 的是不需要线性基的，我们通过标号的方式把它剔除，或者直接倍增或者根号分治处理掉一点询问等等技巧，凹一下就可以了，难点不在这里。

整个代码写了 $3.5 \text{KB}$，应该没人想看吧，只给树剖出子问题和猫树分治部分的代码了。

### Code.

```cpp
void pre(int u,int v)
{
	while(top[u] != top[v])
	{
		if(dep[top[u]] < dep[top[v]]) swap(u,v);
		pl.emplace_back(node{id[top[u]],id[u]}); ++tot;
		u=fa[top[u]];
	}
	if(dep[u] < dep[v]) swap(u,v); pl.emplace_back(node{id[v],id[u]}); ++tot;
}
void sol(int l,int r,int L,int R)
{
	if(L > R) return ; int mid = (l + r) >> 1;
	f[mid].init(); for(int i=mid+1;i<=r;i++) f[i]=f[i-1],f[i].insert(a[i]);
	f[mid].insert(a[mid]); for(int i=mid-1;i>=l;i--) f[i]=f[i+1],f[i].insert(a[i]);
	int tmid=L-1; tn=0;
	for(int i=L;i<=R;i++)
	{
		int tmp=p[i];
		if(pl[tmp].r <= mid) p[++tmid]=tmp;
		else if(mid < pl[tmp].l) s[++tn]=tmp;
		else ans[tmp]=merge(f[pl[tmp].l],f[pl[tmp].r]);
	}
	for(int i=1;i<=tn;i++) p[tmid+i]=s[i]; R=tmid+tn;
	sol(l,mid,L,tmid); sol(mid+1,r,tmid+1,R);
}
```


---

## 作者：Bosun (赞：3)

做完线性基♂的模板题，就来看这道题，我怕不是疯了。

实际上此题还是相当水的，只不过我们查询的是树上路径的线性基♂，而且线性基不能通过删除等操作实现挖取部分元素做线性基的操作，所以只能暴力合并了。。。。。

那当然不能一个一个元素地合并了，因为异或具有结合律，所以我可以按照倍增的思想，gay[i][j]表示i往上跳2^j步的线性基，然后dp的时候暴力合并两个gay[i][j-1]与gay[fa[i][j-1]][j-1],复杂度N(logN)*64。

在查询的时候类似倍增LCA,在往上跳的过程中暴力合并，复杂度也是N(logN)*64的

实现时我们可以将线性基的板子封装成结构体，代码会很短(仅97行)
最后提醒大家一句：开long long 开long long 开long long,重要的事情说三遍！！！

code:
```cpp
#include<bits/stdc++.h>
using namespace std;
const int M=20001;
int n;
typedef long long ll;
ll a[100001];
struct xxj{
	ll b[64];
	xxj(){
		memset(b,0,sizeof(b));	
	}
	void insert(ll x){
		int i;
		for(i=63;~i;i--){
			if(!((x>>i)&1))continue;
			if(!b[i]){b[i]=x;return ;}
			else x^=b[i];
		}
	}
	ll q_max(){
		int i;
		ll ans=0;
		for(i=63;~i;i--){
			ans=max(ans,ans^b[i]);
		}
		return ans;
	}
};
xxj merge(xxj u,xxj v){
	int i;
	for(i=63;~i;i--){
		if(v.b[i])u.insert(v.b[i]);
	}
	return u;
}
int cnt,nxt[2*M],h[2*M],v[2*M];
void add(int x,int y){
	cnt++;
	nxt[cnt]=h[x];
	h[x]=cnt;
	v[cnt]=y;
}
int fa[M][21],dep[M];
xxj gay[M][21];
void dfs(int u,int f){
	int i;
	fa[u][0]=f;
	gay[u][0].insert(a[f]);
	dep[u]=dep[f]+1;
	for(i=h[u];i;i=nxt[i]){
		int to=v[i];
		if(to!=f)dfs(to,u);
	}
}
ll query(int x,int y){
	int i;
	if(dep[x]>dep[y])swap(x,y);
	xxj jyk;
	jyk.insert(a[x]),jyk.insert(a[y]);
	for(i=20;i>=0;i--){
		if(dep[fa[y][i]]>=dep[x])jyk=merge(jyk,gay[y][i]),y=fa[y][i];
	}
	if(x==y)return jyk.q_max();
	for(i=20;i>=0;i--){
		if(fa[x][i]!=fa[y][i]){
			jyk=merge(jyk,gay[x][i]);
			jyk=merge(jyk,gay[y][i]);
			x=fa[x][i],y=fa[y][i];
		}
	}
	jyk=merge(jyk,gay[x][0]);
	return jyk.q_max();
}
int main(){
	int i,j;
	int q;
	cin>>n>>q;
	for(i=1;i<=n;i++)scanf("%lld",&a[i]);
	for(i=1;i<n;i++){
		int x,y;
		scanf("%d%d",&x,&y);
		add(x,y),add(y,x);
	}
	dfs(1,0);
	for(j=1;j<=20;j++){
		for(i=1;i<=n;i++){
			fa[i][j]=fa[fa[i][j-1]][j-1];
			gay[i][j]=merge(gay[fa[i][j-1]][j-1],gay[i][j-1]);
		}
	}
	while(q--){
		int x,y;
		scanf("%d%d",&x,&y);
		printf("%lld\n",query(x,y));
	}
	return 0;
}
```


---

## 作者：ccviolett (赞：3)

> 一句话题意：多次询问树上两点之间最大点权异或和

首先求异或最大值可以想到线性基，然后要处理一条路径上的线性基呢，我们考虑用倍增的思想，对于每一个点维护其祖先和到祖先一路上的线性基，每次询问的话在求 lca 的过程中顺带合并一路上的线性基就可以了。

第一次写线性基合并，枚举的一个中的每个元素暴力往另一个中插，发现会 T 飞，因为这样子的话 $n * log^2n * 64*64$ 就会跑满，再多一点什么常数就爆了。

发现线性基不会太密集，在合并的时候稍微优化一点点就可以比较优雅地过掉这道题目了。

关于点分治的做法，以后再写吧。

```cpp
typedef long long readtype;

/* Header {{{ */
#include <bits/stdc++.h>
using namespace std;

typedef long long var;

readtype read() {
  readtype a = 0, c = getchar(), s = 0;
  while (!isdigit(c)) s |= c == '-', c = getchar();
  while (isdigit(c)) a = a * 10 + c - 48, c = getchar();
  return s ? -a : a;
}
/* }}} */

const int N = 21004;

struct Basis {
  var val[64];
  Basis() {
    memset(val, 0, sizeof(val));
  }
  void insert(var t);
  var getmax();
};

int n, q;
var g[N];
int top, fi[N], ne[N << 1], to[N << 1];
int fa[N][21], deep[N];
Basis basis[N][21];

Basis merge(Basis a, Basis b);
void add(int u, int v);
void getInfo(int t);
var getRes(int x, int y);

int main() {
  #ifndef ONLINE_JUDGE
  freopen("4568.in", "r", stdin);
  freopen("4568.out", "w", stdout);
  #endif
  n = read(), q = read();
  for (int i = 1; i <= n; ++i) g[i] = read();
  for (int i = 2; i <= n; ++i) add(read(), read());
  getInfo(1);
  for (int i = 1; i <= q; ++i) 
    printf("%lld\n", getRes(read(), read()));
  return 0;
}

void Basis::insert(var t) {
  for (int i = 63; i >= 0; --i) {
    if (!((t >> i) & 1)) continue;
    if (!val[i]) {
      val[i] = t;
      break;
    }
    t ^= val[i];
  }
}

var Basis::getmax() {
  var res = 0;
  for (int i = 63; i >= 0; --i) {
    if ((res ^ val[i]) > res) res ^= val[i];
  }
  return res;
}

Basis merge(Basis a, Basis b) {
  for (int i = 63; i >= 0; --i) {
    var t = b.val[i];
    if (!t) continue;
    for (int j = i; j >= 0; --j) {
      if (!((t >> j) & 1)) continue;
      if (!a.val[j]) {
        a.val[j] = t;
        break;
      }
      t ^= a.val[j];
    }
  }
  return a;
}

void add(int u, int v) {
  ne[++top] = fi[u], fi[u] = top, to[top] = v;
  ne[++top] = fi[v], fi[v] = top, to[top] = u;
}

void getInfo(int t) {
  deep[t] = deep[fa[t][0]] + 1;
  basis[t][0].insert(g[t]);
  for (int i = 1; i <= 20; ++i) {
    fa[t][i] = fa[fa[t][i - 1]][i -1];
    basis[t][i] = merge(basis[t][i - 1], basis[fa[t][i - 1]][i - 1]);
  }
  for (int i = fi[t]; i; i = ne[i]) {
    if (to[i] == fa[t][0]) continue;
    fa[to[i]][0] = t;
    basis[to[i]][0].insert(g[t]);
    getInfo(to[i]);
  }
}

var getRes(int x, int y) {
  if (deep[x] < deep[y]) swap(x, y);
  Basis tot;
  tot.insert(g[x]);
  int t = deep[x] - deep[y];
  for (int i = 20; i >= 0; --i) {
    if (t >= (1 << i)) {
      t -= (1 << i);
      tot = merge(tot, basis[x][i]);
      x = fa[x][i];
    }
  }
  if (x == y) return tot.getmax();
  for (int i = 20; i >= 0; --i) {
    if (fa[x][i] == fa[y][i]) continue;
    tot = merge(tot, merge(basis[x][i], basis[y][i]));
    x = fa[x][i], y = fa[y][i];
  }
  tot = merge(tot, merge(basis[x][0], basis[y][0]));
  return tot.getmax();
}
```

---

## 作者：GKxx (赞：3)

分享一个本题除了暴力之外最慢的做法：LCT

想法很简单，用LCT维护链上的线性基，`update`的时候就合并就行了。其它基本上就是LCT基本操作。

复杂度应该是$O(Q\log n\log G_i)$的，但是常数奇大无比，非常非常非常非常慢，反正我T到只有20分。

```cpp
#include <cctype>
#include <cstdio>
#include <climits>
#include <algorithm>

template <typename T> inline void read(T& x) {
    int f = 0, c = getchar(); x = 0;
    while (!isdigit(c)) f |= c == '-', c = getchar();
    while (isdigit(c)) x = x * 10 + c - 48, c = getchar();
    if (f) x = -x;
}
template <typename T, typename... Args>
inline void read(T& x, Args&... args) {
    read(x); read(args...); 
}
template <typename T> void write(T x) {
    if (x < 0) x = -x, putchar('-');
    if (x > 9) write(x / 10);
    putchar(x % 10 + 48);
}
template <typename T> void writeln(T x) { write(x); puts(""); }
template <typename T> inline bool chkmin(T& x, const T& y) { return y < x ? (x = y, true) : false; }
template <typename T> inline bool chkmax(T& x, const T& y) { return x < y ? (x = y, true) : false; }

typedef long long LL;
const int maxn = 2e4 + 207;
LL a[maxn];
int n, m;

inline void insert(LL *base, LL val) {
    if (val)
        for (int i = 60; ~i; --i)
            if (val >> i) {
                if (base[i]) val ^= base[i];
                else {
                    base[i] = val;
                    return;
                }
            }
}
inline void merge(LL *a, LL *b) {
    for (int i = 60; ~i; --i)
        if (b[i]) insert(a, b[i]);
}
inline LL query(LL *base) {
    LL ans = 0;
    for (int i = 60; ~i; --i)
        if ((ans ^ base[i]) > ans) ans ^= base[i];
    return ans;
}

struct Link_Cut_Tree {
    int fa[maxn], ch[maxn][2];
    LL base[maxn][77];
    bool rev[maxn];
    inline int iden(int x) { return ch[fa[x]][0] == x ? 0 : (ch[fa[x]][1] == x ? 1 : -1); }
    inline void update(int x) {
        for (int i = 0; i <= 60; ++i) base[x][i] = 0;
        insert(base[x], a[x]);
        if (ch[x][0]) merge(base[x], base[ch[x][0]]);
        if (ch[x][1]) merge(base[x], base[ch[x][1]]);
    }
    inline void pushdown(int x) {
        if (rev[x]) {
            rev[ch[x][0]] ^= 1; rev[ch[x][1]] ^= 1;
            rev[x] = 0; std::swap(ch[x][0], ch[x][1]);
        }
    }
    inline void rotate(int x) {
        int d = iden(x), y = fa[x];
        if (~iden(y)) ch[fa[y]][iden(y)] = x;
        fa[x] = fa[y];
        if ((ch[y][d] = ch[x][d ^ 1])) fa[ch[x][d ^ 1]] = y;
        fa[ch[x][d ^ 1] = y] = x;
        update(y); update(x);
    }
    int stk[maxn];
    inline void splay(int x) {
        int tp = 1; stk[1] = x;
        for (int i = x; ~iden(i); i = fa[i]) stk[++tp] = fa[i];
        while (tp) pushdown(stk[tp--]);
        while (~iden(x)) {
            int y = fa[x];
            if (~iden(y)) rotate(iden(y) ^ iden(x) ? x : y);
            rotate(x);
        }
    }
    inline void access(int x) {
        for (int y = 0; x; x = fa[y = x])
            splay(x), ch[x][1] = y, update(x);
    }
    inline void makeroot(int x) {
        access(x); splay(x); rev[x] ^= 1;
    }
    inline void link(int x, int y) {
        makeroot(x); fa[x] = y;
    }
    inline LL query(int x, int y) {
        makeroot(x); access(y); splay(y);
        return ::query(base[y]);
    }
};
Link_Cut_Tree lct;

int main() {
    read(n, m);
    for (int i = 1; i <= n; ++i) read(a[i]), insert(lct.base[i], a[i]);
    for (int i = 1, x, y; i <= n - 1; ++i) read(x, y), lct.link(x, y);
    for (int i = 1; i <= m; ++i) {
        int x, y; read(x, y);
        writeln(lct.query(x, y));
    }
    return 0;
}
```

为了防止这篇题解不通过，讲一下不会TLE的做法。其实只要倍增就可以了。设$base[x][i][62]$是从$x$开始往上走$2^i$这一段的线性基，可以用类似于倍增LCA的$fa[x][i]=fa[fa[x][i - 1]][i - 1]$这样的方法预处理出来。查询的时候，从两个点开始倍增地往上跳，一边跳一边合并线性基，最后可以合并出一个表示$x$到$y$这条路径上的点权的线性基，然后查询即可。

复杂度是和LCT一样的，都是$O(Q\log n\log G_i)$，但是它就是能过...

```cpp
#include <cctype>
#include <cstdio>
#include <climits>
#include <algorithm>

template <typename T> inline void read(T& x) {
    int f = 0, c = getchar(); x = 0;
    while (!isdigit(c)) f |= c == '-', c = getchar();
    while (isdigit(c)) x = x * 10 + c - 48, c = getchar();
    if (f) x = -x;
}
template <typename T, typename... Args>
inline void read(T& x, Args&... args) {
    read(x); read(args...); 
}
template <typename T> void write(T x) {
    if (x < 0) x = -x, putchar('-');
    if (x > 9) write(x / 10);
    putchar(x % 10 + 48);
}
template <typename T> void writeln(T x) { write(x); puts(""); }
template <typename T> inline bool chkmin(T& x, const T& y) { return y < x ? (x = y, true) : false; }
template <typename T> inline bool chkmax(T& x, const T& y) { return x < y ? (x = y, true) : false; }

typedef long long LL;
const int maxn = 2e4 + 207;
int v[maxn << 1], head[maxn], next[maxn << 1], tot;
LL a[maxn];
int dep[maxn], fa[maxn][20];
LL base[maxn][20][67];
LL curr[67];
int n, m;

inline void ae(int x, int y) {
    v[++tot] = y; next[tot] = head[x]; head[x] = tot;
    v[++tot] = x; next[tot] = head[y]; head[y] = tot;
}
inline void insert(LL *base, LL x) {
    if (x) {
        for (int i = 60; ~i; --i)
            if (x >> i) {
                if (base[i]) x ^= base[i];
                else {
                    base[i] = x;
                    return;
                }
            }
    }
}
inline void merge(LL *a, LL *b) {
    for (int i = 60; ~i; --i)
        if (b[i]) insert(a, b[i]);
}
inline LL query(LL *base) {
    LL ans = 0;
    for (int i = 60; ~i; --i)
        if ((ans ^ base[i]) > ans) ans ^= base[i];
    return ans;
}
void dfs(int x) {
    dep[x] = dep[fa[x][0]] + 1;
    for (int i = 1; i <= 16; ++i)
        fa[x][i] = fa[fa[x][i - 1]][i - 1];
    insert(base[x][0], a[x]);
    for (int i = 1; i <= 16; ++i) {
        for (int j = 0; j <= 60; ++j)
            base[x][i][j] = base[x][i - 1][j];
        merge(base[x][i], base[fa[x][i - 1]][i - 1]);
    }
    for (int i = head[x]; i; i = next[i])
        if (v[i] != fa[x][0]) {
            fa[v[i]][0] = x;
            dfs(v[i]);
        }
}
inline LL query(int x, int y) {
    for (int i = 0; i <= 60; ++i) curr[i] = 0;
    if (x == y) return a[x];
    if (dep[x] < dep[y]) std::swap(x, y);
    for (int i = 16; ~i; --i) if (dep[fa[x][i]] >= dep[y]) {
        merge(curr, base[x][i]);
        x = fa[x][i];
    }
    if (x == y) {
        merge(curr, base[x][0]);
        return query(curr);
    }
    for (int i = 16; ~i; --i) if (fa[x][i] != fa[y][i]) {
        merge(curr, base[x][i]);
        merge(curr, base[y][i]);
        x = fa[x][i];
        y = fa[y][i];
    }
    merge(curr, base[x][1]);
    merge(curr, base[y][0]);
    return query(curr);
}
int main() {
    read(n, m);
    for (int i = 1; i <= n; ++i) read(a[i]);
    for (int i = 1, x, y; i < n; ++i) read(x, y), ae(x, y);
    dfs(1);
    for (int i = 1, x, y; i <= m; ++i) read(x, y), writeln(query(x, y));
    return 0;
}
```

数组不要开太大，会MLE。

---

## 作者：Sasiyar (赞：2)

[题目](https://www.luogu.com.cn/problem/P3292)

使用我的做法需要知道的算法：

$LCA$ 和可持久化异或线性基。

使用线性基维护出每个点到根的这一条路径上面的元素形成的线性基。

查询的时候先找出 $lca$ ，就有了两条路径，两条路径的线性基可以提出来后暴力合并。

提出来的方法就是找深度大于 $lca$ 的。

于是按着线性基的套路求一波答案这题就完了。

加了 $O2$ 后最后的一个点跑 $521ms$ 。

时间复杂度大概 $O(nlog_2n+360q)$ 吧。

~~不要在意变量名~~

```cpp
#include <bits/stdc++.h>
#define rep(i,a,b) for(int i=(a);i<=(b);++i)
#define per(i,a,b) for(int i=(a);i>=(b);--i)
#define ll long long
#define mp make_pair
#define pb push_back
#define debug(...) fprintf(stderr, __VA_ARGS__)
using namespace std;
template<typename T> inline void ckmax(T&a, T b) { if (b > a) a = b; }
template<typename T> inline void ckmin(T&a, T b) { if (b < a) a = b; }
struct _in {
	const _in operator,(int&a) const {
		a = 0; char k = getchar(); int f = 1;
		for (; !isdigit(k); k = getchar()) if (k == '-') f = -1;
		for (; isdigit(k); k = getchar()) a = a * 10 + k - '0';
		a *= f; return*this;
	}
}in;
struct _inl {
	const _inl operator,(ll&a) const {
		a = 0; char k = getchar(); int f = 1;
		for (; !isdigit(k); k = getchar()) if (k == '-') f = -1;
		for (; isdigit(k); k = getchar()) a = a * 10 + k - '0';
		a *= f; return*this;
	}
}inl;
const int N = 20000 + 5, M = 200000 + 5;

int fr[N << 1], to[N << 1], h[N], tot;
long long val[N];
inline void rider (int u, int v) {
	tot++; fr[tot] = h[u];
	to[tot] = v; h[u] = tot;
}
int n, q, st[N][16], dep[N];
inline int LCA (int u, int v) {
	if(dep[u] < dep[v]) swap (u, v);
	for (int i = 15; i >= 0 && dep[u] > dep[v]; --i)
		if (dep[st[u][i]] >= dep[v]) u = st[u][i];
	for (int i = 15; i >= 0 && u != v; --i)
		if (st[u][i] != st[v][i]) u = st[u][i], v = st[v][i];
	return u == v ? u : st[u][0];
}
int num[N][64];
long long bs[N][64];
inline void archer (int u, int f) {
	dep[u] = dep[f] + 1;
	st[u][0] = f; rep (i, 1, 15) st[u][i] = st[ st[u][i - 1] ][i - 1];
	memcpy (bs[u], bs[f], sizeof bs[f]); memcpy (num[u], num[f], sizeof num[f]);
	long long tmp = val[u]; int nowid = u;
	per (i, 59, 0) {
		if (!(tmp & (1LL << i))) continue;
		if (!bs[u][i]) { bs[u][i] = tmp, num[u][i] = nowid;break; }
		else {
			if (dep[nowid] > dep[num[u][i]]) swap (bs[u][i], tmp), swap (num[u][i], nowid);
			tmp ^= bs[u][i];
		}
	}
	for (int i = h[u]; i; i = fr[i]) if (to[i] != f) {
		archer (to[i], u);
	}
}
long long assassin[64];
inline void berserker (long long v) {
	per (i, 59, 0) {
		if (!(v & (1LL << i))) continue;
		if (!assassin[i]) { assassin[i] = v; break; }
		else v ^= assassin[i];
	}
}
int f[20], top;
inline void lancer (int x, int y) {
	int lca = LCA (x, y);
	memset (assassin, 0, sizeof assassin);
	rep (i, 0, 59) if (dep[ num[x][i] ] >= dep[lca]) berserker (bs[x][i]);
	rep (i, 0, 59) if (dep[ num[y][i] ] >= dep[lca]) berserker (bs[y][i]);
	long long ans = 0;
	per (i, 59, 0) ans = max (ans, ans ^ assassin[i]);
	top = 0;
	while (ans) { f[top++] = ans % 10; ans /= 10; }
	per (i, top - 1, 0) putchar(f[i] + '1' - 1);
	putchar('\n');
}
int main ()
{
	in, n, q;
	rep (i, 1, n) inl, val[i];
	rep (i, 1, n - 1) {
		int x, y; in, x, y;
		rider (x, y), rider (y, x);
	}
	archer (1, 0);
	while (q--) {
		int x, y; in, x, y;
		lancer (x, y);
	}
	return 0;
}
```



---

## 作者：matsuk (赞：2)

**线性基+倍增$LCA$。**

这题是直接球树上路径的最大权值，于是就选择使用大家都喜爱的倍增球$LCA$啦（因为好打_(:з」∠)__)

可是仔细一看发现事情并没有那么简单 贡献是用异或和算的??

其实加个线性基就可以啦!

吧平时倍增用的$dis$数组膜改一下下，变成记录线性基的$p$数组：在最后要加一维，表示二进制的第几位。

一开始以为数组会开不下，然后发现$n$只有$20000$ 计算一波发现可以! 然后再开一个~~变量名丑陋的~~$pp$数组，表示当前询问中的线性基(我一开始没用这个数组，直接更新答案，WA到哭泣)。每次询问跳倍增，并吧当前位置的$p$插到$pp$里面去~

然后接下来就可以暴力搞了~

**一些需要注意(我调了很久)的地方:**

**·** 这里的贡献算的是点权，不是边权。于是我的$p$数组就有点奇怪: 他记录的是节点**包括自己**往上跳$2^i$步的线性基($up$数组的含义仍然不变)，换句话说，算的是$up$[$u$][$i$]以下的权值。所以当跳到$LCA$时，当前点的权值还没有统计过，就要手动吧$g$[$u$]添加到线性基里面去。

**·** $2^{60}$要开$longlong$! 不过写个$max$函数比较$longlong$返回$int$的人除了我不会再有第二个了八..

**·** $g$[$v$]可别写成$v$了(细节废哭泣)

代码: 

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
typedef long long ll;
using namespace std;
#define il inline
#define rg register
ll read(){
	ll x=0; int p=1; char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-') p=0; ch=getchar();}
	while(ch>='0'&&ch<='9') x=(x<<1)+(x<<3)+(ch^48), ch=getchar();
	return p?x: -x;
}
il ll max(ll a, ll b){return a>b?a: b;}
#define _ 20010
int n, q, hd[_], cnt;
struct Edge{int nxt, to;}e[_<<1];
il void add(int u, int v){
	e[++cnt]=(Edge){hd[u], v}, hd[u]=cnt;
}
const int mx=60;
ll g[_], p[_][16][mx+1], pp[mx+1];
int up[_][16], dep[_];
void insert(ll x){//吧x插入答案线性基~
	for(int i=mx; ~i; --i)
		if(x>>i){
			if(!pp[i]){pp[i]=x; break;}
			x^=pp[i];
		}
}
void insert_p(int u, int d, ll x){//吧x插入倍增线性基~
	for(int i=mx; ~i; --i)
		if(x>>i){
			if(!p[u][d][i]){p[u][d][i]=x; break;}
			x^=p[u][d][i];
		}
}
void dfs(int u, int fr){
	dep[u]=dep[fr]+1, up[u][0]=fr;
	insert_p(u, 0, g[u]);
	
	for(int i=1; i<=15; ++i){
		up[u][i]=up[up[u][i-1]][i-1];
		if(!up[u][i]) break;

		for(int j=mx; ~j; --j){
			if(p[u][i-1][j]) insert_p(u, i, p[u][i-1][j]);
			if(p[up[u][i-1]][i-1][j]) insert_p(u, i, p[up[u][i-1]][i-1][j]);
		}
	}

	for(rg int i=hd[u]; i; i=e[i].nxt)
		if(e[i].to!=fr) dfs(e[i].to, u);
}
ll query(int u, int v){
	memset(pp, 0, sizeof(pp));//pp就是每次询问时的线性基~

	if(dep[u]<dep[v]) swap(u, v);
	for(int i=15; ~i; --i)
		if(dep[up[u][i]]>=dep[v]){
			for(int j=mx; ~j; --j)
				if(p[u][i][j]) insert(p[u][i][j]);
			u=up[u][i];
		}

	if(u^v){
		for(int i=15; ~i; --i)
			if(up[u][i]!=up[v][i]){
				for(int j=mx; ~j; --j){
					if(p[u][i][j]) insert(p[u][i][j]);
					if(p[v][i][j]) insert(p[v][i][j]);
				}
				u=up[u][i], v=up[v][i];
			}
		insert(g[u]), insert(g[v]), insert(g[up[u][0]]);//加入现在的点权~
	}
	else insert(g[u]);
	
	ll now=0;
	for(int i=mx; ~i; --i)
		now=max(now, now^pp[i]);
	return now;
}
int main(){
	freopen("4568.in", "r", stdin);
	freopen("4568.out", "w", stdout);
	n=read(), q=read();
	for(rg int i=1; i<=n; ++i) g[i]=read();
	int x, y;
	for(rg int i=1; i^n; ++i)
		x=read(), y=read(), add(x, y), add(y, x);

	dfs(1, 0);//预处理~

	while(q--){
		x=read(), y=read();
		printf("%lld\n", query(x, y));
	}
}

```

---

## 作者：crashed (赞：1)

# 题目
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[点这里](https://www.luogu.org/problem/P3292)看题目。
# 分析
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;看到题目很容易想到异或线性基。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;于是我们只需要思考如何组合出路径上面对应的线性基来。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;考虑合并两个线性基，直接暴力合并（似乎只有这种方法）的时间是$O(log_2^2n)$。如果我们参考倍增的方法，处理出树上倍增出来的线性基的情况的话，预处理时间就是$O(nlog_2^3n)$，总时间就是$O((n+q)log_2^3n)$。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于$n$小并且时限大，所以这样的暴力做法可以过。~~搞半天这就是一道暴力题呀~~
# 代码
```cpp
#include <cmath>
#include <cstdio>
#include <cstring>

typedef long long LL;

const int MAXN = 20005, MAXSIZ = 65, MAXLOG = 20;

template<typename _T>
void read( _T &x )
{
	x = 0;char s = getchar();int f = 1;
	while( s > '9' || s < '0' ){if( s == '-' ) f = -1; s = getchar();}
	while( s >= '0' && s <= '9' ){x = ( x << 3 ) + ( x << 1 ) + ( s - '0' ), s = getchar();}
	x *= f;
}

template<typename _T>
void write( _T x )
{
	if( x < 0 ){ putchar( '-' ); x = ( ~ x ) + 1; }
	if( 9 < x ){ write( x / 10 ); }
	putchar( x % 10 + '0' );
}

template<typename _T>
_T MAX( const _T a, const _T b )
{
	return a > b ? a : b;
}

struct LB
{
	LL P[MAXSIZ];
	LB()
	{ 
		memset( P, 0, sizeof( P ) );
	}
	void insert( LL val )
	{
		for( int i = 60 ; ~ i ; i -- )
		{
			if( val & ( 1ll << i ) )
			{
				if( ! P[i] )
				{
					P[i] = val;
					break;
				}
				val ^= P[i];
			}
		}
	}
	LL query() const
	{
		LL res = 0;
		for( int i = 60 ; ~ i ; i -- )
		{
			res = MAX( res, res ^ P[i] ); 
		}
		return res;
	}
	LL& operator [] ( const int indx )
	{
		return P[indx];
	}
	LB operator + ( const LB & other ) const
	{
		LB res = other;
		for( int i = 60 ; ~ i ; i -- )
		{
			if( P[i] )
			{
				res.insert( P[i] );
			}
		}
		return res;
	}
}base[MAXN][MAXLOG];

struct edge
{
	int to, nxt;
}Graph[MAXN * 2];

LL G[MAXN];
int f[MAXN][MAXLOG];
int dep[MAXN];
int head[MAXN];
int N, Q, lg2, cnt, tot, ID = 0;

void addEdge( const int from, const int to )
{
	cnt ++;
	Graph[cnt].to = to;
	Graph[cnt].nxt = head[from];
	head[from] = cnt;
}

void DFS1( const int u, const int fa )
{
	base[u][0].insert( G[u] );
	dep[u] = dep[fa] + 1;
	f[u][0] = fa;
	int v;
	for( int i = head[u] ; i ; i = Graph[i].nxt )
	{
		v = Graph[i].to;
		if( v ^ fa )
		{
			DFS1( v, u );
		}
	}
}

void init()
{
	for( int j = 1 ; j <= lg2 ; j ++ )
	{
		for( int i = 1 ; i <= N ; i ++ )
		{
			f[i][j] = f[f[i][j - 1]][j - 1];
			base[i][j] = base[i][j - 1] + base[f[i][j - 1]][j - 1];
		}
	}
}

void balance( int &u, const int steps, LB &b )
{
	for( int i = 0 ; ( 1 << i ) <= steps ; i ++ )
	{
		if( steps & ( 1 << i ) )
		{
			b = b + base[u][i];
			u = f[u][i];
		}
	}
}

LL ask( int u, int v )
{
	LB res = LB();
	if( dep[u] > dep[v] )
	{
		balance( u, dep[u] - dep[v], res );
	}
	if( dep[v] > dep[u] )
	{
		balance( v, dep[v] - dep[u], res );
	}
	if( u == v )
	{
		res = res + base[u][0];
		return res.query();
	}
	for( int i = lg2 ; ~ i ; i -- )
	{
		if( f[u][i] ^ f[v][i] )
		{
			res = res + base[u][i] + base[v][i];
			u = f[u][i], v = f[v][i];
		}
	}
	res = res + base[u][0] + base[v][0] + base[f[u][0]][0];
	return res.query();
}

int main()
{
	int fr, to;
	read( N ), read( Q );
	lg2 = log2( N );
	for( int i = 1 ; i <= N ; i ++ )
	{
		read( G[i] );
	}
	for( int i = 1 ; i < N ; i ++ )
	{
		read( fr ), read( to );
		addEdge( fr, to );
		addEdge( to, fr );  
	}
	DFS1( 1, 0 );
	init();
	while( Q -- )
	{
		read( fr ), read( to );
		write( ask( fr, to ) ), putchar( '\n' );
	}
	return 0;
}
```

---

## 作者：hjmmm (赞：1)

本文同时发布于这里
[传送门](https://www.cnblogs.com/hjmmm/p/10433156.html)

## 题意
求树上路径最大点权异或和

自然想到（维护树上路径）+ （维护最大异或和）

那么有三种方法可以选择

1.树剖+线性基

2.倍增+线性基

3.点分治+线性基

至于线性基的合并

一共就60位

暴力合并就好啦

这是一份在loj T掉在洛谷AC的可怜代码

```cpp
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <cstring>
#include <cmath>
#include <vector> 
using namespace std;
const int N = 2e4 + 2;
const int LIM = 60;

inline int read()
{
    int x=0;bool t=false;char ch=getchar();
    while((ch<'0'||ch>'9')&&ch!='-')ch=getchar();
    if(ch=='-')t=true,ch=getchar();
    while(ch<='9'&&ch>='0')x=x*10+ch-48,ch=getchar();
    return t?-x:x;
}

struct Edge{
    int v, next;
}edge[N << 1];
int esize, head[N];
inline void addedge(int x, int y){
    edge[++esize] = (Edge){y, head[x]};
    head[x] = esize;
}

struct XXJ{
    long long w[LIM + 2];
    XXJ(){
        memset(w, 0, sizeof(w));
    }
    void ins(long long x){
        for(int i = LIM; ~i; --i){
            if(!(x >> i)) continue;
            else if(!w[i]){w[i] = x; break;}
            x ^= w[i];
        }
    }
    void print(){
        long long res = 0;
        for(int i = LIM; ~i; --i) 
            if((res ^ w[i]) > res) res ^= w[i];
 		printf("%lld\n", res);
    }
}px[N][18];
long long w[N];
int p[N][18], dep[N];
int n, m;

XXJ merge(XXJ x, XXJ y){
    for(int i = LIM; i >= 0; --i){
        if(y.w[i]) x.ins(y.w[i]);
    }
    return x;
}

XXJ LCA(int x, int y){
    XXJ res;
    res.ins(w[x]); res.ins(w[y]);
    if(dep[x] < dep[y]) swap(x, y); 
    for(int i = 15; i >= 0; --i)
        if(dep[x] - (1 << i) >= dep[y]){
        	res = merge(res, px[x][i]);
        	x = p[x][i];
        }
    if(x == y) return res;
    for(int i = 15; i >= 0; --i){
    	if(p[x][i] != p[y][i]){
    		res = merge(res, px[x][i]);
    		res = merge(res, px[y][i]);
    		x = p[x][i], y = p[y][i];
    	}
    }
    res = merge(res, px[x][0]);
    return res;
}

void dfs(int x, int ff){
    dep[x] = dep[ff] + 1;
    p[x][0] = ff;
    px[x][0].ins(w[ff]); 
    for(int i = head[x], vv; ~i; i = edge[i].next){
        vv = edge[i].v; if(vv == ff) continue;
        dfs(vv, x);
    }
}

void calc(){
    for(int i = 1; i <= 15; ++i){
        for(int j = 1; j <= n; ++j){
            p[j][i] = p[p[j][i - 1]][i - 1];
            px[j][i] = merge(px[j][i - 1], px[p[j][i - 1]][i - 1]);
        }
    }
}
 
int main() {
    memset(head, -1, sizeof(head));
    
    scanf("%d%d", &n, &m);
    for(int i = 1; i <= n; ++i){
        scanf("%lld", &w[i]);
    } 
    for(int i = 1, x, y; i < n; ++i){
        scanf("%d%d", &x, &y);
        addedge(x, y); addedge(y, x);
    }
    dfs(1, 0); 
    calc();
    for(int i = 1, x, y; i <= m; ++i){
        x = read(), y = read();
        XXJ res = LCA(x, y);
        res.print();
    }
    return 0;
}  
```

---

## 作者：miaokehao (赞：1)

基本思路与其他题解相同

打个暴力点的，每次都暴力合并添加60的常数

程序大部分与倍增LCA没有区别，只需要在倍增中加入线性基即可
```
#pragma GCC optimize(2)
#pragma GCC optimize(3)
#pragma GCC optimize(4)
#pragma GCC optimize("Ofast,no-stack-protector")
#include <bits/stdc++.h>
#define res register ll
#define ll long long
#define N 20005
using namespace std;
struct papa
{
  ll to,next;
} e[N<<1];
ll dep[N],fa[N][22],lg[N],d[N],a[N];
ll tot;
inline ll read()
{
  ll X=0,w=0;
  char ch=0;
  while(!isdigit(ch))
  {
    w|=ch=='-';
    ch=getchar();
  }
  while(isdigit(ch)) X=(X<<3)+(X<<1)+(ch^48),ch=getchar();
  return w?-X:X;
}
struct linear_base
{
  static const ll maxlog=62;
  ll d[maxlog+1];
  linear_base()
  {
    memset(d,0,sizeof(d));
  }
  inline void insert(res now)
  {
    for(res i=maxlog; ~i; i--)
      if((now>>i)&1)
        if(d[i]) now^=d[i];
        else
        {
          d[i]=now;
          return;
        }
  }
  inline ll qmax()
  {
    res ans=0;
    for(res i=maxlog; ~i; i--)
      if((ans^d[i])>ans)
        ans^=d[i];
    return ans;
  }
  inline ll qmin()
  {
    for(res i=0; i<=maxlog; i++)
      if(d[i])
        return d[i];
    return 0;
  }
  inline bool check(res now)
  {
    for(res i=maxlog; ~i; i--)
      if((now>>i)&1)
        if(d[i]) now^=d[i];
    return now==0;
  }
  inline ll query(res k)
  {
    ll tmp[maxlog+1],tot,ans=0;
    for(res i=0; i<=maxlog; i++)
    {
      for(res j=0; j<i; j++) d[i]^=d[j];
      tmp[++tot]=d[i];
    }
    for(res i=0; i<tot; i++)
      if((k>>i)&1)
        ans^=tmp[i];
    return ans;
  }
  inline void merge(linear_base a1)
  {
    for(res i=60; ~i; i--)
      if(a1.d[i]) insert(a1.d[i]);
  }
} L[N][20];
inline void add(ll x,ll y)
{
  e[++tot].to=y;
  e[tot].next=d[x];
  d[x]=tot;
}
void dfs(res now,res fath)
{
  dep[now]=dep[fath]+1;
  fa[now][0]=fath;
  L[now][0].insert(a[fath]);
  for(res i=1; (1<<i)<=dep[now]; i++)
  {
    fa[now][i]=fa[fa[now][i-1]][i-1];
    L[now][i].merge(L[now][i-1]),L[now][i].merge(L[fa[now][i-1]][i-1]);
  }
  for(res i=d[now]; i; i=e[i].next)
    if(e[i].to!=fath)
      dfs(e[i].to,now);
}
inline ll lca(res x,res y)
{
  linear_base ans;
  if(x==y) return a[x];
  if(dep[x]<dep[y])
    swap(x,y);
  ll cha=dep[x]-dep[y];
  for(res i=0; i<15; i++)
    if(cha&(1<<i))
      ans.merge(L[x][i]),x=fa[x][i];
  if(x==y)
    return ans.qmax();
  for(res i=14; i>=0; i--)
    if(fa[x][i]!=fa[y][i])
    {
      ans.merge(L[x][i]),ans.merge(L[y][i]);
      x=fa[x][i],y=fa[y][i];
    }
  ans.merge(L[x][0]);
  ans.merge(L[y][0]);
  return ans.qmax();
}
ll n,m,s;
int main()
{
  n=read(),m=read();
  for(res i=1; i<=n; i++)
  {
    a[i]=read();
    L[i][0].insert(a[i]);
  }
  for(res i=1; i<=n-1; i++)
  {
    res x=read(),y=read();
    add(x,y),add(y,x);
  }
  dfs(1,0);
  for(res i=1; i<=m; i++)
  {
    res x=read(),y=read();
    printf("%lld\n",lca(x,y));
  }
  return 0;
}
```

---

## 作者：nekko (赞：1)

题意大概是求链上选出一些数，使得异或和最大，没有修改

子集最大异或和？线性基！

不妨考虑一个暴力一些的做法

考虑树上倍增，$f_{i,j}$表示从点$i$往上爬$2^j-1$次，所经过的点构成的线性基

发现这个可以维护，时间复杂度是$O(n \log^3 n)$

查询的话就是树上倍增了，总时间复杂度大约是$O(n \log^3 n)$

~~加上快读后可以大力卡进去~~

``` cpp
%:pragma GCC optimize(2)
%:pragma GCC optimize(3)
 
#include <bits/stdc++.h>
 
using namespace std;
 
typedef long long ll;
 
const int N = 20000 + 10;
 
ll val[N];
 
struct BAS { ll val[62]; } bas[N][20], la;
 
int n, q, fa[N][20], deep[N], head[N], rest[N * 2], to[N * 2];
 
template<typename T> inline void read(T &x) {
    x = 0;
    char c = getchar();
    while(!isdigit(c)) c = getchar();
    while(isdigit(c)) x = x * 10 + c - '0', c = getchar();
}
 
inline void add(int u, int v) { static int tot = 0; to[++ tot] = v, rest[tot] = head[u], head[u] = tot; }
 
inline int getlca(int u, int v) {
    if(deep[u] < deep[v]) swap(u, v);
    for(int i = 15 ; ~ i ; -- i) if(deep[fa[u][i]] >= deep[v]) u = fa[u][i];
    if(u == v) return u;
    for(int i = 15 ; ~ i ; -- i) if(fa[u][i] != fa[v][i]) u = fa[u][i], v = fa[v][i];
    return fa[u][0];
}
 
inline void ins(BAS &bas, ll val) {
    for(int i = 60 ; ~ i ; -- i) {
        if((val >> i) & 1) {
            if(!bas.val[i]) {
                bas.val[i] = val;
                break;
            }
            val ^= bas.val[i];
        }
    }
}
 
inline void merge(BAS &bas, BAS &src) { for(int i = 60 ; ~ i ; -- i) if(src.val[i]) ins(bas, src.val[i]); }
 
inline ll query(BAS &bas) {
    ll res = 0;
    for(int i = 60 ; ~ i ; -- i)
        if((res ^ bas.val[i]) > res) res ^= bas.val[i];
    return res;
}
 
void dfs(int u) {
    deep[u] = deep[fa[u][0]] + 1;
    ins(bas[u][0], val[u]);
    for(int i = 1 ; i <= 15 ; ++ i) {
        fa[u][i] = fa[fa[u][i - 1]][i - 1];
        merge(bas[u][i], bas[u][i - 1]), merge(bas[u][i], bas[fa[u][i - 1]][i - 1]);
    }
    for(int i = head[u] ; i ; i = rest[i]) {
        int v = to[i];
        if(v != fa[u][0]) fa[v][0] = u, dfs(v);
    }
}
 
inline ll sol(int u, int v) {
    memset(la.val, 0, sizeof la.val);
    int d = getlca(u, v);
    if(u == v) {
        ins(la, val[u]);
    } else if(d == u || d == v) {
        if(deep[u] > deep[v]) swap(u, v);
        for(int i = 15 ; ~ i ; -- i)
            if(deep[fa[v][i]] >= deep[u]) merge(la, bas[v][i]), v = fa[v][i];
        ins(la, val[u]);
    } else {
        for(int i = 15 ; ~ i ; -- i) {
            if(deep[fa[u][i]] >= deep[d]) merge(la, bas[u][i]), u = fa[u][i];
            if(deep[fa[v][i]] >= deep[d]) merge(la, bas[v][i]), v = fa[v][i];
        }
        ins(la, val[d]);
    }
    return query(la);
}
 
int main() {
    read(n), read(q);
    for(int i = 1 ; i <= n ; ++ i) read(val[i]);
    for(int i = 1, u, v ; i < n ; ++ i) {
        read(u), read(v);
        add(u, v), add(v, u);
    }
    dfs(1);
    for(int i = 1, u, v ; i <= q ; ++ i) {
        read(u), read(v);
        printf("%lld\n", sol(u, v));
    }
}
```

---

## 作者：弦巻こころ (赞：0)

~~在这里给一种理论复杂度非常优秀的算法~~

看到题解里面没有树剖,我当时想的时候就非常迷惑, 树剖不是才 $mlogn^2$吗,怎么可能没有人用这个过呢. (而且树剖还可以支持修改)

然后我就老老实实写了树剖,交了1发发现t飞了,然后仔细一看发现,在线段树中用到的merge,它是自带360的常数的. ~~于是这就是一个有360常数的优秀mlogn方做法~~

然后我并没有放弃,我发现当x=0时其实是不用add的于是我就加了if(b.p[i])这样一句话,然后开O2它就A了 ????? 理论复杂度 $1e11$的优秀算法也能过,太草了.

其实复杂度是假的,但是如果题目带修改的话,树剖就比较好用了,因为这道题用树剖还可以支持各种修改. ~~所以还是来一起写树剖吧.~~

这道题的树剖思路还是比较套路的,就直接树剖,然后线段树每个节点维护线性基,最后再写个合并式的query就行了.

~~2k 80行超简短代码~~

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int N=20205;
int ls(int i){return i<<1;}
int rs(int i){return i<<1|1;}
vector<int> v[N];
struct tree{
    ll p[65];
}tr[4*N];
int fa[N],sz[N],son[N],id[N],dfn[N],top[N];
ll tot,an[N],a[N];
int n,m,s,t;
void add(tree &f,ll x){//线性基模板
    for(int i=60;i>=0;i--){
        if(!(x&(1ll<<i)))continue;
        if(!f.p[i]){f.p[i]=x;break;}
        x^=f.p[i];
    }return;
}
tree merge(tree a,tree b){//暴力合并线性基
    for(int i=0;i<=60;i++) if(b.p[i]) add(a,b.p[i]);
    return a;//这里要加特判传进去的数不为0,减小常数
}
void build(int i,int l,int r){
    if(l==r){
        add(tr[i],a[l]);return ;
    }int mid=(l+r)>>1;
    build(ls(i),l,mid);build(rs(i),mid+1,r);
    tr[i]=merge(tr[ls(i)],tr[rs(i)]);
}
tree query(int i,int l,int r){//合并式的query
    if(l>=s&&r<=t) return tr[i];
    int mid=(l+r)>>1;
    if(mid>=t) return query(ls(i),l,mid);
    if((mid+1)<=s) return query(rs(i),mid+1,r);
    return merge(query(ls(i),l,mid),query(rs(i),mid+1,r));
}
void dfs1(int x,int f){
    dfn[x]=dfn[f]+1;fa[x]=f;sz[x]=1;
    for(int i=0;i<v[x].size();i++){
        int nxt=v[x][i];if(nxt==f) continue;
        dfs1(nxt,x);sz[x]+=sz[nxt];
        if(sz[nxt]>sz[son[x]]) son[x]=nxt;
    }
}
void dfs2(int x,int f){
    id[x]=++tot;a[tot]=an[x];top[x]=f;
    if(!son[x])return;
    dfs2(son[x],f);
     for(int i=0;i<v[x].size();i++) {
        int nxt=v[x][i];
        if(nxt!=fa[x]&&nxt!=son[x]) dfs2(nxt,nxt); 
    }
}
void que(int x,int y){
    tree num=tr[0];ll ans=0;
    while(top[x]!=top[y]){
        if(dfn[top[x]]<dfn[top[y]]) swap(x,y);
        s=id[top[x]],t=id[x];
        num=merge(num,query(1,1,n));
        x=fa[top[x]];
    }
    if(id[x]>id[y])swap(x,y);
    s=id[x],t=id[y];
    num=merge(num,query(1,1,n));
    for(int i=60;i>=0;i--){//求解线性基
        if(!(ans&(1ll<<i)))ans^=num.p[i];
    }printf("%lld\n",ans);
}
int main(){ 
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)scanf("%lld",&an[i]);
    for(int i=1,x,y;i<n;i++){
        scanf("%d%d",&x,&y);
        v[x].push_back(y),v[y].push_back(x);
    }
    dfs1(1,0);dfs2(1,1);build(1,1,n);
    for(int i=1;i<=m;i++){
        scanf("%d%d",&s,&t);que(s,t);
    }
}//没了
```

~~其实复杂度肯定是不对的,但考虑到如果题目要求修改就不能倍增,看下树剖解法也没太大问题对吧~~

---

## 作者：mulberror (赞：0)

[【bzoj数据下载地址】](https://lydsy.download/archive/4568.zip)不要谢我  
窝[博客](https://www.cnblogs.com/chhokmah/p/10748907.html)

------
先讲一下窝是怎么错的。。。  
$MLE$是因为数组开小了。。  

-----
看到异或和最大，那么就会想到用线性基。  
如果不会线性基的可以参考一下我的学习笔记：[「线性基」学习笔记and乱口胡总结](https://www.cnblogs.com/chhokmah/p/10748282.html)

------
但是这一道题目需要合并线性基。  
如何合并线性基？  
不需要什么花里胡哨的操作，直接暴力插入就可以了。  
```cpp
void merge(xxj &x, xxj y) {
	for (int i = BIT; ~i; i --) 
		if (y.p[i]) x.ins(y.p[i]);
}
```
代码中的$x$和$y$是两个线性基。  
原理就是把$y$中的每一个元素插入到$x$中。  
然后再套一个倍增求$LCA$就可以了。  

# 代码
```cpp
#include <bits/stdc++.h>
#define gc getchar
using namespace std;
typedef long long ll;
const int BIT = 62;
const int LOG = 21; 
const int N = 40005;
template <typename T> void read(T &x) {
	x = 0; T fl = 1; char c = 0;
	for (; c < '0' || c > '9'; c = gc()) 
		if (c == '-') fl = -1;
	for (; c >= '0' && c <= '9'; c = gc()) 
		x = (x << 1) + (x << 3) + (c ^ 48); 
	x *= fl; 
}
struct xxj {
	ll p[BIT + 2];
	void clear() { memset(p, 0, sizeof(p)); }
	void ins(ll x) {
		for (int i = BIT; ~i; i --) {
			if ((x >> i) == 0) continue;
			if (!p[i]) { p[i] = x; break; }
			x ^= p[i];
		}
	}
} g[N][LOG + 2], ans;
struct edge {
	int to, nt;
} E[N];
int fa[N][LOG + 2];
int n, ecnt, Q;
int dep[N], H[N];
void add_edge(int u, int v) {
	E[++ ecnt] = (edge){v, H[u]};
	H[u] = ecnt;
}
void merge(xxj &x, xxj y) {
	for (int i = BIT; ~i; i --) 
		if (y.p[i]) x.ins(y.p[i]);
}
void dfs(int u, int ft) {
	fa[u][0] = ft; dep[u] = dep[ft] + 1;
	for (int i = 1; i <= LOG; i ++) {
		fa[u][i] = fa[fa[u][i - 1]][i - 1];
		g[u][i] = g[u][i - 1];
		merge(g[u][i], g[fa[u][i - 1]][i - 1]);
	}
	for (int e = H[u]; e; e = E[e].nt) {
		int v = E[e].to;
		if (v == fa[u][0]) continue; 
		dfs(v, u);
	}
}
void Lca(int u, int v) {
	if (dep[u] < dep[v]) swap(u, v);
	for (int i = LOG; ~i; i --) 
		if (dep[fa[u][i]] >= dep[v]) 
			merge(ans, g[u][i]), u = fa[u][i];
	if (u == v) {
		merge(ans, g[u][0]);
		return;
	}
	for (int i = LOG; ~i; i --) {
		if (fa[u][i] != fa[v][i]) {
			merge(ans, g[u][i]); 
			merge(ans, g[v][i]); 
			u = fa[u][i]; v = fa[v][i]; 
		}
	}
	merge(ans, g[u][0]);
	merge(ans, g[v][0]); 
	merge(ans, g[fa[u][0]][0]);
}
int main() {
	read(n); read(Q);
	for (int i = 1; i <= n; i ++) {
		ll x; read(x);
		g[i][0].ins(x);
	}
	for (int i = 1, u, v; i < n; i ++) {
		read(u); read(v); 
		add_edge(u, v);
		add_edge(v, u);
	}
	dfs(1, 0);
	while (Q --) {
		int u, v; read(u); read(v); 
		ans.clear();
		Lca(u, v); 
		ll res = 0ll;
		for (int i = BIT; ~i; i --) 
			if ((res ^ ans.p[i]) > res) res ^= ans.p[i];
		cout << res << endl;
	}
	return 0;
}
```

---


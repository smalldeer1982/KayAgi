# 火枪打怪

## 题目描述

LXL 进入到了一片丛林,结果他发现有 $n$ 只怪物排成一排站在他面前。LXL 有一杆火枪能对付这些怪物。他知道从左至右数第 $i$ 只怪物的血量是 $m_i$。现在 LXL 可以将一些子弹射向某个怪物。LXL 可以控制他所发射的子弹数量及子弹的威力值。当某个子弹射到第 $i$ 个怪物，如果这个子弹的威力值为 $p$，除了这个怪物会掉 $p$ 点血以外，它左边的第 $j$ 个怪物 $(j<i)$，也会遭到 $\max(0, p - (i - j)^2)$ 的溅射伤害（好神奇的子弹）。当某只怪物的血量小于 $0$ 时，它就死了，但它的尸体还在，即怪物的位置永远不会改变。LXL 希望只用 $k$ 发子弹，请你求出一个最小的正整数 $p$，使 LXL 用 $k$ 发子弹且每发子弹的威力值为 $p$ 就可以消灭所有怪物。


## 说明/提示

对于 $30\%$ 的数据，$n\leq 300$。

对于 $100\%$ 的数据，$n\leq 5\times 10^5$，$k\leq 5\times 10^5$，$1\leq m_i\leq 10^{10}$。


## 样例 #1

### 输入

```
3 1
1 4 5
```

### 输出

```
6```

# 题解

## 作者：Merak (赞：42)

Ps.唔这个题真的巨难（肯定是我弱QAQ）花了很久才搞懂……还是别人给讲的……感觉现在可能还有没有完全理解的细节部分，所以题解可能有的地方写得不够准确，如果发现哪里不对的话请务必告诉我！！不能误人子弟（雾）(っ\*´Д`)っ

——————————————————————————————————————————————————————

**题目要求**

LXL面前有n只怪物，他将一些子弹射向某个怪物。LXL可以控制他所发射的子弹数量及子弹的威力值。当某个子弹射到第i个怪物，如果这个子弹的威力值为p，除了这个怪物会掉p点血以外，它左边的第j个怪物(j<i)，也会遭到Max(0, p - (i - j) \* (i - j))的溅射伤害。当某只怪物的血量小于0（敲黑板！！等于0还没有死喔）时，它就死了，但是位置永远不会改变。求出用k发子弹消灭所有怪物的最小威力值p，且p为正整数。

**思路分析**

思路和楼下基本是相同的，另外扩充一些细节。

首先提醒一个细节：会爆int，所以定义要用longlong。

其次对做法进行分析。因为p是跟怪物的Hp值相关的，所以我们先观察一下Hp的范围：1<=Hp[i]<=10^10。因为范围比较大，所以我们采用二分的方法来寻找最优解。需要注意的是，威力值p有可能是大于Hp值的，所以我们在对p进行二分查找的时候要将范围在[1,10^10]的基础上再进行扩大。

那么如何判断p是否满足题目条件呢？这里我们写一个判断函数对其进行条件满足与否的判定。如何判定是整个题的关键，那么我们一步一步来分析：

<判断函数>

子弹的溅射范围是在被击中怪物的左侧，所以为了尽可能的多溅射到怪物，我们从最右边开始枚举。我们用一个num数组来记录每个位置上射出子弹的个数（受到伤害为p而不是p-(i-j)\*(i-j)的子弹个数，也就是说被溅射到的不算，溅射的子弹会用别的方法储存）。接下来怎么做呢？

首先我们对式子p-(i-j)\*(i-j)进行处理。将该式拆开得到：伤害值=p-i^2+2ij-j^2。由于我们在枚举时p的值在该次枚举内是固定不变的，所以我们将p当做一个定值去处理。同理j（当前枚举到的位置）也可以认为是一个定值，所以推到这一步我们就可以明白式子拆开的优点：我们可以单独计算和存储这两个定值。那么，假设该怪物在其位置上的有效子弹（包括其他位置溅射过来的）为plus，我们就可以得到这样一个式子：

- 总伤害（allhurt）=Σ(p-(i-j)^2)

我们将它展开来看，就有：

- 原式=Σp-Σi^2+Σ2ij-Σj^2

注：p是一个定值，j同理（因为在当前枚举回合内两个值是不变的，所以可以这样认为）。所以我们可以将Σp和Σj提出，且容易证得Σp=plus\*p。

而因为i是一个变值，所以i前的Σ就需要通过循环操作来实现。

那么如何来实现呢？

我们可以通过当前枚举到的位置j的后一位（即j+1）得到当前位置的状态。我们通过累加j+1放置的子弹个数来求得plus。但是值得注意的是，如果子弹无法溅射到当前位置，也就是说累加到的子弹数里包含了无效子弹，那么如果不除去无效子弹的个数，就会对我们的计算结果造成影响。那么如何除去呢？

我们再来观察一下溅射伤害计算的公式：溅射伤害=p-(i-j)^2。容易得出，我们的溅射最大范围其实就是sqrt(p)+1。可以手动计算验证一下。我们将这个溅射范围定义为over，即：

- 溅射范围（over）=sqrt(p)+1

也就是说，如果某个位置放置的子弹已经无法对当前位置的怪物造成伤害，那么我们就可以把该位置上的子弹数从plus中减去。这样我们就实现了计算有效子弹个数的想法。

完成了公式内所有未知数的求值工作，接下来我们就该维护num的值了。当我们求出总伤害(allhurt)之后，就可以计算在当前位置放置的子弹个数了。这里我们进行分类讨论：

如果当前造成的总伤害已经足够让这个位置上的怪物死亡，那么我们不需要更新num值。

如果当前造成的总伤害不能让这个位置上的怪物死亡或者恰好让该怪物的Hp值为0（为0是不代表死亡的，还活着~），那么我们需要在该位置上放置子弹。并且显然，需要放置的子弹个数为：

- Num[i]=(Hp[i]-allhurt)/p+1

为什么加1呢？因为当Hp恰好等于0的时候怪物还没有死呀qwq~

同时我们定义一个计算总子弹放置数的变量cnt，每次更新完num值后将每个num值累加起来。

因为我们要求的是用k发子弹消灭所有怪物的最小威力值p，所以如果在当前回合的枚举中我们求得的cnt大于要求子弹个数k，我们便对p的范围向左二分，反之向右。

这样我们的判断函数就写好了。

主函数没有什么特别需要强调的，需要的只是输入和简单的二分操作，这里就不再详述。

最后一定要注意的是，每次判断时要对存储计算结果的变量进行清零。

代码如下：

```cpp
#include<algorithm>
#include<iostream>
#include<iomanip>
#include<cstring>
#include<cstdio>
#include<cmath>
using namespace std;
typedef long long ll;
ll l=1,r=1e14;
ll n,k,mid,ans;
ll Hp[500003],num[500003];
bool check(ll p)
{
    ll over=(ll)sqrt(p)+1;//溅射范围 
    ll cnt=0;//子弹放置总个数 
    memset(num,0,sizeof(num));
    ll plus=0,i=0,i2=0;
    //plus表示有效子弹的个数，i表示放置子弹的位置，i2表示i^2 
    for(ll j=n;j>=1;j--)
    {
        if(num[j+1])//累加子弹的个数 
        {
            plus+=num[j+1];
            i+=num[j+1]*(j+1);
            i2+=num[j+1]*(j+1)*(j+1); 
        }
        if((j+over<=n)&&(num[j+over]))//删除无效子弹的个数 
        {
            plus-=num[j+over];
            i-=num[j+over]*(j+over);
            i2-=num[j+over]*(j+over)*(j+over);
        }
        ll allhurt=1ll*plus*p-1ll*j*j*plus+2ll*i*j-i2;//计算总伤害 
        if(Hp[j]>=allhurt)//如果不能直接杀死 
        {
            num[j]=(Hp[j]-allhurt)/p+1;
            cnt+=num[j];//累加总放置子弹的个数 
        }
        if(cnt>k) return false;//如果放置子弹多余要求子弹个数    
    }
    return true;//如果小于要求子弹个数 
}
int main()
{
    cin>>n>>k;
    for(ll i=1;i<=n;i++)
    {
        cin>>Hp[i];
    }
    while(l<=r)//对p的范围进行二分操作 
    {
        mid=(l+r)>>1;
        if(check(mid))
        {
            r=mid-1;
            ans=mid;
        }
        else l=mid+1;    
    }
    printf("%lld",ans);
    return 0;
} 
```

---

## 作者：yybyyb (赞：15)

看到楼下的方法，

我来说一种神奇的方法，论如何$O(n)$差分check

看到式子$P-dis^{2}$其中dis是$(i-j)$

第一个的P是定值，开一个数字差分P的倍数

后面的$dis^{2}$

我们来写一下：

$0,1,4,9,16.....$

相减一下

$1,3,5,7...$

再减一下

$2,2,2,2.....$

所以，这三个数列，互相相关

所以，直接再开三个数组分别差分这三个数列就行了

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<set>
#include<map>
#include<vector>
#include<queue>
using namespace std;
#define MAX 501000
#define ll long long
int n,K;
ll hp[MAX],HP[MAX];
ll c1[MAX],c2[MAX],c3[MAX],c4[MAX];
inline ll read()
{
    ll x=0,t=1;char ch=getchar();
    while((ch<'0'||ch>'9')&&ch!='-')ch=getchar();
    if(ch=='-')t=-1,ch=getchar();
    while(ch<='9'&&ch>='0')x=x*10+ch-48,ch=getchar();
    return x*t;
}
bool check(ll P)
{
    int sss=sqrt(P);
    int tot=0;
    ll t1=0,t2=0,t3=0,t0=0;
    memset(c1,0,sizeof(c1));
    memset(c2,0,sizeof(c2));
    memset(c3,0,sizeof(c3));
    memset(c4,0,sizeof(c4));
    for(int i=1;i<=n;++i)hp[n-i+1]=HP[i];
    for(int i=1;i<=n;++i)
    {
        t3+=c3[i];//P标记
        t2+=c2[i];//差的差的标记
        t1+=c1[i]+t2;//差
        t0+=t1+c4[i];
        hp[i]-=1ll*P*t3-t0;//扣的血
        if(hp[i]<=0)continue;//死掉了
        int gg=((hp[i]+P-1)/P);//还要打的次数
        tot+=gg;
        if(tot>K)return false;
        c3[i+1]+=gg;c3[min(n+1,i+sss+1)]-=gg;//打P标记
        c2[i+1]+=1ll*2*gg;c2[min(n+1,i+sss+1)]-=2*gg;
        c1[i+1]-=gg;c1[min(n+1,i+sss+1)]-=1ll*(1ll*2*sss-1)*gg;
        c4[min(n+1,i+sss+1)]-=1ll*sss*sss*gg;
    }
    return tot<=K;
}
int main()
{
    n=read();K=read();
    for(int i=1;i<=n;++i)HP[i]=read()+1;
    ll l=1,r=1e15,ans=1e15;
    while(l<r)
    {
        ll mid=(l+r)>>1;
        if(check(mid))ans=mid,r=mid;
        else l=mid+1;
    }
    printf("%lld\n",ans);
    return 0;
}

```

---

## 作者：litc (赞：12)

容易注意到随着p的增大，所需要的子弹数单调递减。于是我们便会想到二分答案，但这并不是难点，本题的难点在于：对于一个二分出的p，如何快速计算出它所需要的子弹数？

由于本题中子弹的溅射伤害只是向左，故很容易想到子弹应从右打起，打到怪物被消灭为止。但如果朴素计算溅射伤害，复杂度可能高达O(n^2)，无法通过本题。所以我们需要一个更优的计算方法。

我们设对于二分出的p，射到从左到右第s个怪物身上的子弹数为kk[s]。对于p-(i-j)\*(i-j)我们将它拆开，变成-j^2+2ij-i^2+p。对于第j个怪，它受到的溅射伤害应为-(kk[j+1]+...+kk[n])\*j^2+2\*(kk[j+1]\*(j+1)+...+kk[n]\*n)\*j-(kk[j+1]\*(j+1)^2+...+kk[n]\*n^2)+(kk[j+1]+...+kk[n])\*p。

这其实是把溅射伤害的值表示为一个二次函数。而二次函数每一项的系数都是可累加的，溅射伤害可以随着循环算出。而当p-(i-j)\*(i-j)<0时，我们便需要把对应的i从系数中减去。每一位至多只会被减去一次，故总复杂度仍不变，对于一个二分出的p，计算出它所需要的子弹数的时间复杂度仍为O(n)。


---

## 作者：灵乌路空 (赞：11)

先无良宣传一下博客 $wwwwww$    
[文章列表 - 地靈殿 - 洛谷博客](https://www.luogu.org/blog/koishikoishi/)

---

## 知识点: 二分答案 , 贪心 , 前缀和.

### [原题面](https://www.luogu.org/problem/P1485) 

---

### 题目要求:
给定一数列 $a$ , 一整数 $k$.   
给定操作:  第 $i$ 个数减 $p$, 其 左侧的 数列中 左数第$j$个数减 $\max(0,p-(i-j)^2)$ .    
操作最多 进行 $k$ 次  , 求将数列全部变为负数时 ,  最小的 $p$ 值.   

---

### 分析题意:
很明显, 可以对 $p$ 进行二分答案 , 并检查操作次数是否满足要求.
 
- 在检查正确性时 , 贪心选择操作对象 :   
  对于给定操作, 只对 某个数 及 其左侧的数 有影响,      
  则应优先  对 较右侧的数 进行操作.      
   
- 在进行操作后 ,  如何 维护原数列的值?      
    考虑对计算式进行分析:     

	- 若 $\large p-(i-j)^2< 0$ :     
	  说明 数列中 $i$ 与 $j$两位置 的 距离 $\large (i-j)>\sqrt{p}$     
	  则: 对 $i$ 位置进行操作 , 不会对 $j$ 位置造成影响.      
	  
	  由于 $p$ 已知 , 则可求得满足 $\large p-(i-j)^2\ge 0$的, 最大的$\large (i-j)$ , 记为$\large \max{(i-j)}$   
	  则: 对于第 $j$ 个位置 , 区间$\large [j+1,j+\max{(i-j)}]$ 内位置被操作 , $j$ 位置才会被影响   
	   
	-  要 求得第 $j$ 个位置 的 数值 ,   
	   设 在 区间$\large [j+1,j+\max{(i-j)}]$ 进行了$k_1$ 次操作 , 每次被操作的位置记录在数组 $i$ 中   
	   则: $j$ 位置当前的数值 $\large m[j]'=m[j]- \sum\limits_{x=1}^{k_1}{p-(i_x-j)^2}\ \  (  \text{第}x \text{次操作位置为}i_x , )$   
	   
	   对计算式进行转化:   
	   $\ \ \ \  \large m[j]- \sum\limits_{x=1}^{k_1}{[p-(i_x-j)^2]}$     
	   $\large = m[j]-\sum\limits_{x=1}^{k_1}{(p-{i_x}^{2} + 2i_xj-j^2)}$     
	   $\large = m[j]-\sum\limits_{x=1}^{k_1}{p}+\sum\limits_{x=1}^{k_1}{{i_x}^2}-      \sum\limits_{x=1}^{k_1}{2i_xj}+\sum\limits_{x=1}^{k_1}{j^2}$     
	   $\large = m[j]- k_1(p-j^2)+\sum\limits_{x=1}^{k_1}{{i_x}^2} - 2j \sum\limits_{x=1}^{k_1}{i_x}$   
	   
	   对于式子中的值 :      
	   $\large k_1=$ 区间 $\large [j+1,j+\max{(i-j)}]$  内的操作数      
	   $\large \sum\limits_{x=1}^{k_1}{{i_x}^2}=$ 区间 $\large [j+1,j+\max{(i-j)}]$ 被操作位置编号 的 平方和      
	   $\large \sum\limits_{x=1}^{k_1}{i_x}=$ 区间 $\large [j+1,j+\max{(i-j)}]$ 被操作位置编号 的 和     
	   
	   以上三个值 , 可以通过维护三个 后缀和 来得到,    
	   就可以实现 $O(1)$的 单点查询    
	   
- 通过上述手段 , 就可以实现在$O(n)$ 复杂度内 , 对一个枚举的 $p$ 进行 $check$   
 
---

### 算法实现:   

首先对 $p$ 进行二分答案.   
在 $check()$函数中,检查枚举 $p$ 的合法性:   
倒序枚举 $n\rightarrow 1$ 中的元素,   
通过计算式 $\large m[j]= m[j]- k_1(p-j^2)+\sum\limits_{x=1}^{k_1}{{i_x}^2} - 2j    \sum\limits_{x=1}^{k_1}{i_x}$, 求得 $m[j]$ 的值.   
- 如果 $m[j]<0$ ,则此位置已经满足条件 , 不需要被操作 .    
- 否则 就对 $j$ 位置进行直接操作 , 并更新后缀和.    

总复杂度 $O(nlogn)$ , 稳过.   

---

### 其他优化:  
真的有必要记录全部的 $[i,n]$ 内的后缀和吗 $???$   
很明显不需要.   
可以在枚举的过程中 直接进行差分 ,  即可维护所需的三个值.   
可以大幅优化空间复杂度   
~~反正又不卡空间 所以就没有写~~   

---

附代码:   

```cpp
#include<cstdio>
#include<cmath>
#include<ctype.h>
#define int long long
const int MARX = 2e6+10;
//=============================================================
int n,k,ans , m[MARX];
int sum1[MARX],sum2[MARX],sum3[MARX];
//sum1~3,分存区间[i,n]内 操作编号的和 , 操作编号平方的和 , 操作数的和. 
//=============================================================
inline int read()
{
    int s=1, w=0; char ch=getchar();
    for(; !isdigit(ch);ch=getchar()) if(ch=='-') s =-1;
    for(; isdigit(ch);ch=getchar()) w = w*10+ch-'0';
    return s*w;
}
bool check(int p)
{
	int imax=sqrt(p);//获得max(i-j)
	for(int i=n; i>=1; i--)//倒序枚举数列 
	{
	  sum1[i]=sum1[i+1] , sum2[i]=sum2[i+1] , sum3[i]=sum3[i+1];//维护前缀和 
	  
	  int nowm = m[i] - (sum3[i]-sum3[i+imax+1])*(p-i*i);//计算 更新后的m[i] 
	  nowm += (sum2[i]-sum2[i+imax+1]);
	  nowm -= (2*i*(sum1[i]-sum1[i+imax+1])); 
	  
	  if(nowm<0) continue;//m[i]已经<0,满足条件 
	  for(; nowm>=0; )
	  {
		nowm-=p, sum1[i]+=i, sum2[i]+=i*i,sum3[i]++;//对i位置进行操作,并更新前缀和 
	    if(sum3[i] > k) return 0;//操作次数达到限制 
	  }
	}
	return 1;
}
//=============================================================
signed main()
{
	n=read(),k=read();
	for(int i=1; i<=n; i++) m[i]=read();
	for(int l=1,r=1e12+10; l<=r;)//二分答案枚举p 
	{
	  int mid = (l+r)>>1;
	  if(check(mid)) ans=mid,r=mid-1;
	  else l=mid+1;
	}
	printf("%lld",ans);
}
```

---

## 作者：forever_nope (赞：4)

新手第一次写题解 qwq

~~因为这道题我整整调了一整天~~，所以我尽可能讲的详细又简洁。

## 题目描述

共有 $n$ 个怪物，血量为 $m_i$，现在要打死这些怪物（血量 $< 0$）。每次攻击第 $i$ 个怪物，它会掉 $p$ 滴血，同时左侧第 $j$ 个怪物会掉 $\max(0, p - (i - j) ^ 2)$ 滴血。

共使用 $k$ 次攻击，求最小的 $p$。

## 简要分析

### 0x01

求一个可行的最小值，对于每一个值都是明显的**是否可行**。

同时因为 $p$ 越大，$k$ 一定会越来越小（或者维持不变），所以答案是具有单调性的。

因此可以看出，题目可以使用二分答案来做。

瞄一眼数据范围 $10^{10}$ 好吧我直接开 `long long` 了。

然后就是考虑怎么设计 Check 函数了。

### 0x02

题目说明，当攻击怪物时，只有左侧的怪物会“收到牵连”，所以可以很快的想到，从右侧开始遍历更加方便（没有后效性）。

对于每一个怪物我们都要把它打死（因为再继续往左遍历，右面的怪物不会受到任何影响了）。

所以我们只需要考虑这个怪物会收到多大的牵连就可以了，所以我们接着从题目给的公式入手。

### 0x03

（$f_i$ 为第 $i$ 个怪物收到的溅射伤害值）

（$cnt_i$ 为打死第 $i$ 个怪物的最小攻击次数）

因为是倒着遍历，所以我们考虑将式子转换为一个（或多个，实际上是多个）后缀和进行运算的形式：

$$
\begin{aligned}
	f_i	&= \sum_{j = i + 1}^{\min(n, i + \lfloor \sqrt p \rfloor)} cnt_j \times (p - (j - i) ^ 2) \\
		&= \textstyle \sum cnt_j \times (p - i ^ 2 - j ^ 2 + 2i \times j) \\
		&= \textstyle \sum cnt_j \times p - \sum cnt_j \times j ^ 2 - \sum cnt_j \times i ^ 2 + \sum cnt_j \times 2i \times j \\
		&= \textstyle p \times \sum cnt_j - \sum cnt_j \times j ^ 2 - i ^ 2 \times \sum cnt_j + 2i \times \sum cnt_j \times j \\
		&= \textstyle (p - i ^ 2) \times \sum cnt_j + 2i \times \sum cnt_j \times j - \sum cnt_j \times j ^ 2
\end{aligned}
$$

然后设三个后缀和数组：

$$
\begin{aligned}
	c_i &= \textstyle \sum_{j = i + 1}^n cnt_j \\
	cj_i &= \textstyle \sum_{j = i + 1}^n cnt_j \times j \\
	cjj_i &= \textstyle \sum_{j = i + 1}^n cnt_j \times j ^ 2 
\end{aligned}
$$

然后我们就可以把原式转换为：

$$
\begin{aligned}
	\\
	f_i	&= (p - i ^ 2) \times \sum_{j = i + 1}^{i + \lfloor \sqrt p \rfloor} cnt_j + 2i \times \sum_{j = i + 1}^{i + \lfloor \sqrt p \rfloor} cnt_j \times j - \sum_{j = i + 1}^{i + \lfloor \sqrt p \rfloor} cnt_j \times j ^ 2\\
		&= (p - i ^ 2) \times (c_i - c_{i + \lfloor \sqrt p \rfloor}) + 2i \times (cj_i - cj_{i + \lfloor \sqrt p \rfloor}) - (cjj_i - cjj_{i + \lfloor \sqrt p \rfloor}) \\
	\\
	cnt_i &= \lceil \frac{m_i - f_i + 1}{p} \rceil \\
		&= \lfloor \frac{m_i - f_i + p}{p} \rfloor
\end{aligned}
$$

这样分析就结束了（~~但是我做了一整天［哭］~~）

## 我的代码

有注释

```cpp
#include <bits/stdc++.h>

// 开 long long 不然会爆掉
#define int long long

using namespace std;

const int N = 1e6 + 10;

int read()
{
    int num = 0, flag = 1;
    char ch = getchar();
    for (; !isdigit(ch); ch = getchar())
        if (ch == '-')
            flag = -1;
    for (; isdigit(ch); ch = getchar())
        num = (num << 3) + (num << 1) + ch - '0';
    return num * flag;
}

int n, k;
int m[N];

int c[N];   // cnt 的后缀数组
int cj[N];  // cnt * j 的后缀数组
int cjj[N]; // cnt * j * j 的后缀数组

// 获取某一个怪物背的锅的数量
int getd(int i, int j, int p)
{
    return (p - i * i) * (c[i] - c[j]) + 2 * i * (cj[i] - cj[j]) - (cjj[i] - cjj[j]);
}

bool check(int p)
{
    int x = sqrt(p), res = k;
    for (int i = n; i >= 1; --i)
    {
        int D = getd(i, i + x, p);              // 背的锅
        int cnt = (max(m[i] - D, -p) + p) / p;  // 攻击次数

        if ((res -= cnt) < 0)
            return false;

        // 处理后缀数组
        c[i - 1] = c[i] + cnt;
        cj[i - 1] = cj[i] + cnt * i;
        cjj[i - 1] = cjj[i] + cnt * i * i;
    }
    return true;
}

signed main()
{
    n = read(), k = read();
    for (int i = 1; i <= n; ++i)
        m[i] = read();

    // 二分
    int l = 1, r = 1e11;
    while (l < r)
    {
        int mid = l + r >> 1;
        if (check(mid))
            r = mid;
        else
            l = mid + 1;
    }

    printf("%lld\n", l);
    return 0;
}
```


---

## 作者：PosVII (赞：4)

**前言**

------------

此题会用到二分、前缀和、贪心等操作。

**分析**

------------

当 $p$ 越高，就越能只用 $k$ 发子弹击杀所有怪物。不难想到使用二分。只可惜 $check$ 函数需要我们的思考。

这里用到贪心思路，爆搜找射击位置的时间复杂度太高了，我们想一想如何优化。

我们可以知道，溅射伤害和直接伤害都在被射击的怪物的左边，不会影响到右边的怪物，那么我们只需要确保每次射击先射向从右往左数第一个未死的怪物，只需要开个数组存对每个怪物的伤害即可。我们不难得知能造成伤害的最大长度为 $\sqrt p +1$

OJ自测 $40$ 分。

要优化，我们要对于造成的伤害进行优化。我们首先得到伤害的计算不能循环枚举，那么我们尝试对溅射伤害进行拆分。

可以拆分出射向第 $i$ 个怪物的子弹对第 $j$ 个怪物造成的伤害（溅射伤害）为

$p - i^2 - j^2 + 2 \times i \times j$

这时我们有了一个思路：对于每个怪物，我们都存下前面的子弹对它造成的溅射伤害，$j$ 已经确定了，那么我们只需要把能对它造成伤害的子弹的 $p$ 之和、$i^2$ 之和与 $i$ 之和记录下来就可以计算溅射伤害了，但如果有超出了溅射范围的子弹，我们要把它们删掉，否则会造成负数伤害。

**code**

------------

```
#include<bits/stdc++.h>
using namespace std; 
long long n,k,m[5000006],h[5000006],ll=1,rr=1e16;
bool check(long long p) {
	memset(h,0,sizeof(h));
	long long x=n,u=0,f=sqrt(p)+1,lasu=0,i=0,j=0,kk=0;
	bool flag=0;
	while(x>0) {
		if(x+f<=n&&h[x+f]>=1) {
			lasu-=h[x+f];
			i-=h[x+f]*(x+f)*(x+f);
			j-=h[x+f]*(x+f);
		}
		kk=lasu*p-i-x*x*lasu+j*x*2;
//		cout<<x<<" "<<i<<" "<<j<<" "<<kk<<" "<<(m[x]-kk)/p+1<<endl;
		if(kk<=m[x]) {
			h[x]+=(m[x]-kk)/p+1;
			lasu+=h[x];
			i+=h[x]*x*x;
			j+=h[x]*x;
			u+=h[x];
			if(u>k) {
				flag=1;
				break;
			}
		}
		x--;
	} 
	return flag;
}
void c(long long l,long long r) {
	if(l==r) {
		cout<<l;
		return;
	}
	if(l+1==r) {
		if(check(l)==0) cout<<l;
		else cout<<r;
		return;
	}
	long long mid=(l+r)/2;
	if(check(mid)) {
		c(mid+1,r);
	}
	else {
		c(l,mid);
	}
	return;
}
int main() {
    cin>>n>>k;
    for(int i=1;i<=n;i++) cin>>m[i];
	c(ll,rr);
    return 0;
}  
/*
f=3
1 4 5
0 0 1
    6
    
lasu*p-las^2-x^2+2*las*x;
*/
```

---

## 作者：kiwabo (赞：3)

题目传送门  [P1485 火枪打怪](www.luogu.com.cn/problem/P1485)

生活不易，蒟蒻叹气。

------~~华丽~~朴素的分割线------

## 坑点：
Hp 恰好等于 0 的时候怪物还没有死。

## 方法：二分答案
难点：如何快速计算出溅射出的伤害。

可以将每个怪物收到过的子弹伤害和溅射伤害表示为一个函数，每一项系数都可以快速累加。

AC code：（内含~~不~~包含反抄袭）
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=1e6+10;
int read()
{
    int num=0,flag=1;
    char ch=getchar();
    for (;!isdigit(ch);ch=getchar())
        if (ch=='-')
            flag=-1;
    for (;isdigit(ch);ch=getchar())
        num=(num<<3)+(num<<1)+ch-'0';
    return num*flag;
}
int n, k;
int m[N];
int c[N];
int cj[N];
int cjj[N];
int getd(int i,int j,int p)
{
    return (p-i*i)*(c[i]-c[j])+2*i*(cj[i]-cj[j])-(cjj[i]-cjj[j]);
}
bool check(int p)
{
    int x=sqrt(p),res=k;
    for (int i=n;i>=1;i--)
    {
        int D = getd(i,i+x,p);
        int cnt=(max(m[i]-D,-p)+p)/p;

        if ((res-=cnt)<0)
            return 0;
        c[i-1]=c[i]+cnt;
        cj[i-1]=cj[i]+cnt*i;
        cjj[i-1]=cjj[i]+cnt*i*i;
    }
    return true;
}
signed main()
{
    n=read(),k=read();
    for (int i=1;i<=n;i++)
        m[i]=read();
    int l=1,r=(int)1e11;
    while (l<r)
    {
        int mid=(l+r)/2;
        if (check(mid))
            r=mid;
        else
            l=mid+1;
    }
	cout<<l;
    return 0;
}
```


---

## 作者：koukou (赞：2)

这题，还要感谢 YNH_QAQ 帮我调的。

要用算法：二分 $+$ 前缀和
## 思路
随着 $p$ 的增大，所需要的子弹数单调递减，于是我们便会想到二分答案。
其实看出二分并不难，难的是如何计算出溅射的伤害。
思路：可以将每个怪物受到的子弹伤害和溅射伤害写为一个函数，每一项系数都可以快速累加。
具体看代码：
```cpp
#include<iostream>
#include<cmath>
#define int long long
using namespace std;
int n, k, c, d, ans;
int a[5000001], l = 1, r1, b[5000001];
bool check(int p)//二分函数
{
	for(int i = 1; i <= n; i++)
	{
		b[i] = 0;
	}
	int r = sqrt(p) + 1, s = 0, v1 = 0, v2 = 0, sum = 0;
	for(int i = n; i >= 1; i--)
	{
		if(i + r <= n && b[i + r])
		{
			s -= b[i + r];
			v1 -= (i + r) * (i + r) * b[i + r];
			v2 -= (i + r) * b[i + r];
		}
		int hp = s * p - v1 - i * i * s + v2 * i * 2;
		if(a[i] >= hp)
		{
			b[i] += (a[i] - hp) / p + 1;
			s += b[i];
			v1 += i * i * b[i];
			v2 += i * b[i];
			sum += b[i];
		}
		if(sum > k)
		{
			break;
		}
	}
	return sum <= k;
}
signed main()
{
	cin >> n >> k;
	for(int i = 1; i <= n; i++)
	{
		cin >> a[i];
		r1 += a[i];
	}
	while(l <= r1)//处理
	{
		int mid = (l + r1) / 2;
		if(check(mid))
		{
			r1 = mid - 1, ans = mid;
		}
		else
		{
			l = mid + 1;
		}
	}
	cout << ans;
	return 0;
}
```

---

## 作者：YNH_QAQ (赞：2)

## 思路
标签有二分，而且伤害越大，子弹要少，求最大的最小，二分答案 $p$。

溅射伤害只往左，每次打最右边活着的怪物，每次检查子弹数量。考虑叠加的溅射伤害为 $\max(0,p-(i-j)^2)$，改一下得 $p-(i-j)^2=p-i^2-j^2+2ij$，维护前缀和数组存储 $j$ 与 $j^2$ 即可。

---

## 作者：Leap_Frog (赞：1)

# P1485火枪打怪（题解）

**此题第一眼就可以看出是二分答案** ~~我看了标签QwQ~~  
最难的是二分的$\texttt{check}$函数如何写。  

首先因为子弹的威力是定值，所以每一个子弹的溅射范围是一样的，事先算出溅射范围。  
$p-(i-j)*(i-j)=p-i^2+2*i*j+j^2$  
这个式子中，$i^2$、$2*i*j$、$j^2$ 都是可以维护的。  
于是我们维护$i^2$之和，$2*i$之和，$\texttt{1}$之和。  
在加入时可以临时乘上$\texttt{j}$的次方次幂。  

所以就有了下面的代码，不懂的详见代码注释。。。

```cpp
#include<bits/stdc++.h>
#define ll long long
#define int long long
using namespace std;
int n,k,b[500005];
ll a[500005];
inline char check(ll p)
{
    ll _2=0,_1=0,_0=0,s=sqrt(p)+1;
    //s表示溅射范围，_2，_1，_0分别表示 i*i ， 2*i ， 1 。
    int tot=0;
    //tot表示子弹数。
    memset(b,0,sizeof(b));
    //b表示在这里有无发过子弹。
    for(int i=n;i>=1;i--)
    {
        if(i+s<=n&&b[i+s]) _2-=(i+s)*(i+s)*b[i+s],_1-=(i+s)*b[i+s],_0-=b[i+s];
        //溅射结束，去掉影响。
        ll gone=_0*p-_0*i*i+2*_1*i-_2;
        //gong表示这个怪物由于之前的溅射扣的血量。
        if(a[i]>=gone) b[i]=(a[i]-gone)/p+1,tot+=b[i],_0+=b[i],_1+=b[i]*i,_2+=b[i]*i*i;
        //如果这个怪物没被打死，还需要在开枪。
        if(tot>k) return 1;
        //k枪已经打不死全部怪物了。
    }
    return 0;
}
signed main()
{
    scanf("%lld%lld",&n,&k);
    for(int i=1;i<=n;i++) scanf("%lld",a+i);
    ll l=1,r=1e13,ans=0;
    while(l<=r)
    {
        int mid=(l+r)>>1;
        if(check(mid)) l=mid+1;else r=mid-1,ans=mid;
    }
    //二分板子。
    printf("%lld\n",ans);
    return 0;
}
```

---

## 作者：殇雪 (赞：1)

我们显然可以发现这道题的二分性质。再细心观摩一波数据，50W，只能用O（nlogn）及以下的算法。二分需要一个log，这便要求我们O(n)处理check函数。


比较显然，我们可以差分。我们发现只有右边对左边有贡献，不妨从右到左做，我们发现这是一个二次多项式，那么可以二阶差分，对于单一的子弹来说，他的


伤害的差分是一个等差数列，K=2n-1，那对差分数组进行差分，我们统计对当前怪物有贡献的子弹，那么这个伤害的二阶差分就是两倍的子弹数。那么我们还


有一个问题，那就是子弹的伤害不可能是负数。我们有这样一个方法，我们在一颗子弹的伤害区域的最左侧打标记  -1，标示该位置之后出子弹范围，那么我们同


时在一阶差分数组中把多余的伤害减掉，那么这颗子弹之后就没有贡献了。



```cpp
#include<bits/stdc++.h>
#define sight(c) ('0'<=c&&c<='9')
#define LL long long
inline void read(int &x) {
    static char c;
    for (;!sight(c);c=getchar());
    for (x=0;sight(c);c=getchar())x=x*10+c-48;
}
inline void read(long long &x) {
    static char c;static int b;
    for (b=1;!sight(c);c=getchar())if (c=='-') b=-1;
    for (x=0;sight(c);c=getchar())x=x*10+c-48;
    x*=b;
}
#define N 501007
#define min(a,b) (a)<(b)?(a):(b)
#define HP a
LL len,ans2,ans,Ans,cm,n,dle,a[N],k,r,c1[N],c2[N],c3[N],c4[N],hp[N];
bool check(LL P)
{
    int sss=sqrt(P); int tot=0;
    LL t1=0,t2=0,t3=0,t0=0;
    memset(c1,0,sizeof(c1)); memset(c2,0,sizeof(c2));
    memset(c3,0,sizeof(c3)); memset(c4,0,sizeof(c4));
    for(int i=1;i<=n;++i)hp[n-i+1]=HP[i]+1;//记得+1，因为怪物0血还没有死
    for(int i=1;i<=n;++i)
    {
        t3+=c3[i]; t2+=c2[i];
        t1+=c1[i]+t2; t0+=t1+c4[i];
        hp[i]-=1ll*P*t3-t0;
        if(hp[i]<=0)continue; int gg=((hp[i]+P-1)/P);
        tot+=gg; if(tot>k)return false;
        c3[i+1]+=gg;c3[min(n+1,i+sss+1)]-=gg;
        c2[i+1]+=1ll*2*gg;c2[min(n+1,i+sss+1)]-=2*gg;
        c1[i+1]-=gg;c1[min(n+1,i+sss+1)]-=1ll*(1ll*2*sss-1)*gg;
        c4[min(n+1,i+sss+1)]-=1ll*sss*sss*gg;
    }
    return tot<=k;
}
int main () {
    read(n); read(k);
    for (int i=1;i<=n;i++) read(a[i]);
    r=1ll<<53;
    while (r) {
        if (!check(ans+r)) ans+=r;
        r>>=1;
    } 
    printf("%lld\n",ans+1); return 0;
}
```

---

## 作者：lizicheng3042 (赞：0)

嗯，感觉好像挺简单一道题啊，~~建议评绿~~。  
## P1485：火枪打怪
### 题目简析  
根据题目首先考虑用二分答案解决，那么根据题意设 $l=1$，$r$ 的话，我们发现，最极端的情况下，我们只有一发子弹，那么场上 $5\times10^5$ 只怪，我们从最右边打一枪，设最左边的怪血量最大，也就是 $10^{10}$ 时，需要的威力就是 
$$10^{10}+499999\times499999+1=259999000002$$
那么显然 $r$ 直接取这个值就行了。（为什么要加一呢？因为题目里说血量少于 $0$ 才可以，等于零不行……）

接下来我们观察这个子弹的效果，我们发现，假设子弹的威力为 $c$，那么在位置 $i$ 发射的子弹就会影响到最远 $i-\sqrt c$ 位置的怪，等效于在区间 $[i-\sqrt c,i]$ 内所有数减去 $c$，并在位置 $j(i-\sqrt c\le j\le i)$ 加上 $(i-j)^2$。
### 实现思路
~~首先看到区间加我们一眼线段树~~，当然，这是错的。  
我们发现用线段树会让复杂度达到 $O(n\log^2n)$，而显然这是一个十分危险的数字。因此，我们考虑在二分过程中用 $O(1)$ 的复杂度来维护转移。  
为了保证较低的复杂度，我们显然不能把每颗子弹对某个位置的影响分开讨论，于是我们需要将所有子弹造成的影响整体修改。我们发现，对于第 $i$ 位置子弹（先假设这个威力 $c$ 不是很小），他对第 $i$ 位置之前的位置的影响为 $c-1,c-4,c-9$……
### 具体实现
我们发现第 $j$ 个位置与 $j$ 右边一个位置的影响的变化量等于 $(i-j)\times2-1$，即一个初项为 $1$，公差为 $2$ 的等差数列（等差数列即一个数组 $a$，设初项为 $b$，公差为 $c$，则 $a_1= b$，$a_i+c=a_{i+1}$）。 
![](https://cdn.luogu.com.cn/upload/image_hosting/sddrihy0.png)  
由此，我们可以考虑维护影响量的变化量，那么转移只需要知道影响当前位置的子弹的数量的量即可。（为什么这么说呢？因为我们发现，不管子弹距离这里多远，只要对这里有影响，那么这个影响一定是可以由子弹对上一个位置的影响推出的）  

------------

现在我们考虑怎么维护其他信息。如当前位置的怪的剩余血量，我们可以考虑维护前面的子弹对这个怪的影响，为了维护这个量，我们可以维护当前位置需要减去多少影响，然后，因为我们知道变化量的变化量是一个有规律的，所以，只要知道了变化量的变化量，维护上述的其他量就成为了可能，时间复杂度变为 $O(n\log n)$，详细请看下面代码注释。

```cpp
#include<cstdio>
#include<algorithm>
#include<cmath>
using namespace std;
typedef long long ll;
int n,k,new_or[500005]/*记录第i个位置sho的版本*/,tim;
ll sho[500005];//记录有多少子弹的影响到该位置结束
ll num[500005];
bool check(ll a)
{
	ll less=0/*变化量的变化量*/,get=0/*前面影响的剩余量*/,h=k,kw=0/*变化量*/;
	ll qian=ceil(sqrt(a));//表示向左影响的最大范围，不开ll WA on #7，为此多调了好久……
	ll s=a-qian*qian;//表示不能被完整的减去的影响的变化量，需要自行补上
	for(int i=n;i>=1&&h>=0;i--)
	{
		if(new_or[i]!=tim)//版本更新
		{
			sho[i]=0;
			new_or[i]=tim;
		}			
		less-=sho[i]*2;//去掉往后不影响的子弹的变化量的变化量
		kw-=(qian*2-1)*sho[i];//将去已经往后不影响的子弹的变化量去掉
		get-=(ll)(sho[i]*s);//去掉不能被完整表示的那一部分剩余量
		ll c=num[i]-get;//除去前面子弹的影响后当前位置怪的剩余血量。
		int y=max(0ll,i-qian);//表示在该位置发射的子弹影响结束的位置
		while(c>=0ll&&h>=0ll)
		{
			c-=a;
			h--;
			if(new_or[y]!=tim)
			{
				sho[y]=0;
				new_or[y]=tim;
			}	
			sho[y]++;
			less+=2;
			kw--;
			get+=a;
				
		}
		kw+=less;//将	
		get-=kw;	
	}
	return h>=0;//如果剩下的子弹为负数，那肯定是不可行的
}
int main()
{
	scanf("%d%d",&n,&k);
	for(int a=1;a<=n;a++)
	{
		scanf("%lld",&num[a]);
	}
	ll l=1,r=259999000002;
	while(l<r)
	{
		ll mid=(l+r)/2;
		if(check(mid))//返回true表示当前威力可行，将上界定为mid
			r=mid;
		else//返回false表示当前威力不可行，将下界定为mid+1
			l=mid+1;
		tim++;
	}
	printf("%lld",l);
	return 0;
}
```



---

## 作者：zhou_ziyi (赞：0)

### 思路
求最小值，很有可能是二分，我们再看数据范围，就应该往这方面想。
其实这道题最坑的还是 `check`， 是真的不好想。
我们不难写出一个 $\Theta(n^2)$ 的 `check`。
```cpp
bool check(int x) {
    int sum = 0;
    for (int i = 1; i <= n; i++) b[i] = a[i];
    for (int i = n; i >= 1; i--) {
        if (b[i] < 0)
            continue;
        int h = ceil((b[i] + 1) * 1.0 / x);
        b[i] -= h * x;
        for (int j = 1; j < i; j++) b[j] -= max(0ll, x - (i - j) * (i - j)) * h;
        sum += h;
    }
    return sum <= m;
}
```
但是这必定超时，所以我们要想办法优化我们的 `check`。
我们可以化简式子得到：
$p - (i-j)^2=p-i^2+2*i*j-j^2$
我们假设射击范围为 `r`,
所以溅射伤害为：
$hp_i=\sum_{i + 1}^{i+r-1}p-(i^2 * r+\sum_{j=i+1}^{i+r-1}j^2)+2*i*\sum_{j=i + 1}^{i+r-1} j$。  
所以我们只需维护 $i^2$, $j^2$的区间和即可。
就有代码：
```cpp
bool check(int p) {
    for (int i = 1; i <= n; i++)
		b[i] = 0;
	int r = sqrt(p) + 1, s = 0, v1 = 0, v2 = 0, sum = 0;
    for (int i = n; i >= 1; i--) {
        if (i + r <= n && b[i + r]) {
        	s -= b[i + r];
        	v1 -= (i + r) * (i + r) * b[i + r];
        	v2 -= (i + r) * b[i + r];
		}
        int hp = s * p - v1 - i * i * s + v2 * i * 2;
        if (a[i] >= hp) {
        	b[i] += (a[i] - hp) / p + 1;
        	s += b[i];
        	v1 += i * i * b[i];
        	v2 += i * b[i];
        	sum += b[i];
		}
		if (sum > m)
        	break;
	}
    return sum <= m;
}
```
其时间复杂度为 $\Theta(n)$。
### Code
```cpp
#include <cstdio>
#include <cmath>
#include <iostream>
#define int long long
using namespace std;
const int MAXN = 5e5 + 5;
int n, m;
int a[MAXN];
int b[MAXN];
bool check(int p) {
    for (int i = 1; i <= n; i++)
		b[i] = 0;
	int r = sqrt(p) + 1, s = 0, v1 = 0, v2 = 0, sum = 0;
    for (int i = n; i >= 1; i--) {
        if (i + r <= n && b[i + r]) {
        	s -= b[i + r];
        	v1 -= (i + r) * (i + r) * b[i + r];
        	v2 -= (i + r) * b[i + r];
		}
        int hp = s * p - v1 - i * i * s + v2 * i * 2;
        if (a[i] >= hp) {
        	b[i] += (a[i] - hp) / p + 1;
        	s += b[i];
        	v1 += i * i * b[i];
        	v2 += i * b[i];
        	sum += b[i];
		}
		if (sum > m)
        	break;
	}
    return sum <= m;
}
signed main() {
    scanf("%lld %lld", &n, &m);
    for (int i = 1; i <= n; i++)
		scanf("%lld", &a[i]);
    int l = 1, r = 1e15;
    while (l < r) {
        int mid = (l + r) >> 1;
        if (check(mid))
            r = mid;
        else
            l = mid + 1;
    }
    printf("%lld", l);
    return 0;
}
```

---

## 作者：BigJoker (赞：0)

# Preface

很久之前的一道题了，今天终于补好了。。。

# Solution

伤害值越大，需要的子弹就越少，所以可以二分 $p$。

考虑一下判断函数。贪心的考虑一下，由于溅射伤害只会伤害到左边，那么我们肯定优先打右边的。

那么思路就很明显了，每次打最右边还没有死的怪物，然后看一下子弹数量会不会超。

但是算法的瓶颈也很明显，那就是如何叠加溅射伤害。

我们把溅射伤害的式子拆开。

$p-(i-j)^2=p-i^2-j^2+2\times i\times j$

那么就可以使用前缀和数组来存储 $j^2$ 和 $j$，然后就很简单了。

# Code

```cpp
#include<bits/stdc++.h>
#define int long long
#define re register
#define il inline
using namespace std;
const int N=6e5+5;
int qr(){
	int s=0,f=1;
	char ch=getchar();
	while(ch<'0' || ch>'9') (ch=='-'?f=-1:1),ch=getchar();
	while(ch>='0' && ch<='9') s=s*10+ch-'0',ch=getchar();
	return s*f;
}
void qw(int x){
	if(x<0) putchar('-'),x=-x;
	if(x>9) qw(x/10);
	putchar(x%10+'0');
}
int n,k;
int m[N],m1[N],sum1[N],sum2[N],sum3[N];
bool check(int p){
	int ans=0,u=sqrt(p),t1=0,t2=0,t3=0,u1,u2,u3,res;
	for(int i=1;i<=n;i++) m[i]=m1[i];
	for(int i=n;i;i--){
		sum1[i]=sum1[i+1],sum2[i]=sum2[i+1],sum3[i]=ans;
		if(i+u+1<=n) u1=sum1[i]-sum1[i+u+1],u2=sum2[i]-sum2[i+u+1],u3=sum3[i]-sum3[i+u+1];
		else u1=sum1[i],u2=sum2[i],u3=sum3[i];
		m[i]-=p*u3+2*u2*i-u1-u3*i*i;
		if(m[i]<0) continue;
		res=(m[i]*1.0/(p*1.0))+1;
		ans+=res;
		if(ans>k) return 0;
		sum1[i]+=res*i*i;
		sum2[i]+=res*i;
		sum3[i]=ans;
	}
	return 1;
}
int f(int l,int r){
	if(l==r) return l;
	if(l+1==r){
		if(check(l)) return l;
		return r;
	}
	int mid=l+r>>1;
	if(check(mid)) return f(l,mid);
	return f(mid+1,r); 
}
signed main(){
	n=qr(),k=qr();
	for(re int i=1;i<=n;i++) m1[i]=qr();
	qw(f(0,1e12));
	return 0;
}
```

---


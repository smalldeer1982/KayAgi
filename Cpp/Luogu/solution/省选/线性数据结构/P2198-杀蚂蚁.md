# 杀蚂蚁

## 题目背景

说“善有善报，恶有恶报，不是不报……”。小 FF 一心只顾自己企业的壮大而没顾及自己的采矿业对 Greed Island 上生态环境的破坏，Greed Island 的环境日益恶劣。终于，岛上的蚂蚁们变异了，它们决定对小 FF 的矿区进行攻击，欲将岛上的人类驱逐出去……面对蚂蚁们的进攻，人类节节败退。无奈之下，小 FF 请来了全宇宙最强的防御系统制造商派来的工程机器人——SCV，希望能够阻挡蚂蚁的攻势。



## 题目描述

经过小 FF 的研究，他发现蚂蚁们每次都走同一条长度为 $n$ 个单位的路线进攻，且蚂蚁们的经过一个单位长度所需的时间为 $T$ 秒。也就是说，只要小 FF 在条路线上布防且给蚂蚁造成沉痛伤害就能阻止蚂蚁的进军。

SCV 擅长制造的防御塔有三种，分别是激光塔，放射塔和干扰塔，他们可以在一个单位长度内修建一座防御塔。三种防御塔的作用如下：

激光塔：使用高能激光，当蚂蚁从塔前经过时每秒对蚂蚁造成 $r$ 点伤害。

放射塔：释放放射性元素，当蚂蚁经过这座塔后，每一秒受到 $g$ 点伤害。

干扰塔：干扰塔负责干扰蚂蚁们的信息素，使得蚂蚁在经过这座塔后，经过之后每一个单位长度的时间变成 $T+b$。

当然，放射塔和干扰塔的效果是可以叠加的，也就是说如果敌人经过 $x$ 座放射塔，那么敌人每秒钟会受到 $x \times g$ 点伤害；同理，如果敌人经过 $y$ 座干扰塔，那么敌人经过一个单位长度的时间将变为 $T + y \times b$。

现在距离蚂蚁的下一轮进攻还有足够长的时间，你这个“NewBe\_One”计划的首席工程师现在被任命为战略总参谋长，因此你必须设计一个给蚂蚁们造成最大伤害的布塔方案。

## 说明/提示

#### 样例解释

第 $1$ 号位置为放射塔，第 $2,3$ 号位置建造干扰塔，第 $4,5$ 号位置建造激光塔。

#### 数据范围

对于 $30\%$ 的数据：$1 \leq n \leq 20$；

对于 $60\%$ 的数据：$1 \leq n \leq 1024,0 \leq r,g,b \leq 65536,0 \leq T \leq 3$；

对于另外 $40\%$ 的数据：$1 \leq n \leq 400,0 \leq r,g,b \leq 2^{31}-1,0 \leq t \leq 1000$。

## 样例 #1

### 输入

```
5 4 3 2 1```

### 输出

```
82```

# 题解

## 作者：miemieQWQ (赞：21)

蒟蒻的心路历程:{

1.这不是贪心吗?

倒着来, 一格一格查最最优, 样例都没过直接交, 得分20...

2.这不是枚举吗?

假装思考一遍: 激光塔和 放射塔 或 干扰塔 交换位置, 伤害量只会大,

不会小. 干扰塔和放射塔交换位置, 伤害范围增多了一格, 伤害量增大.

所以最后得知防御塔顺序为一堆放射塔、一堆干扰塔、再来一堆激光塔.

嗯, 那么枚举i(放射塔开始位置)和j(激光塔开始位置)问题解决, 20分?

3.这原来是dp啊!

经过分析可以知道第一个塔必定为放射塔, 最后几个塔也必定是激光塔,

但中间放射塔和干扰塔却是镶嵌分布的. 所以只能动态来求解咯!

得分50 →70 →0(MLE) →80 →100

4.关于高精

需要高精加法和乘法, 考虑数据最后也不会太大, \_\_int128还可以搞定!

高精记得要分类讨论, 前60%的数据不要用高精(否则MLE, 没有压位).

} 
大致解题思路:{

1.原理:

用dp[i][j]表示在"前面"放i个干扰塔、j个放射塔所产生的最大伤害值,

每一步都可以通过dp[i-1][j]或dp[i][j-1]转移而来, 并且与顺序无关,

剩下n-i-j个格子全放激光塔. //i, j, n-i-j ∈[0, n]

最终答案ans = max{dp[i][j] + jg \* (T+gr\*i) \* (n-i-j)};

2.边界:

dp[0][j] = dp[0][j-1] + fs \* (n-j) \* T; //fs 放射塔每格伤害

3.状态转移方程:

dp[i][j] = max(dp[i-1][j] + ①, dp[i][j-1] + ②);

①添置干扰塔的伤害: fs \* j \* gr \* (n-i-j) //gr 干扰塔每格减速

②添置放射塔的伤害: fs \* (T+gr\*i) \* (n-i-j) //jg 激光塔每格伤害

} 
测试数据:{

10%的数据满足只有干扰塔、激光塔

30%的数据满足只有两种防御塔

60%的数据不需要高精度

另外40%的数据需要40位以内的高精

//不要问我为什么知道的那么清楚, 下面数据仅供参考

(输入1: 400 2147483647 2147483647 2147483647 1000)

(输出1: 24504193721991962785921500) //别数了26个

(输入2: 1024 65536 65536 65536 3)

(输出2: 383746102307848192) //别数了18个


} 
贴一份\_\_int128的代码, 高精读起来太费力!


```cpp 
#include<bits/stdc++.h>
#define LONG __int128
using namespace std;

const int N = 1050, M = 30;
LONG dp[N][N] = {0}, ans = 0;
int n, r, g, b, T;

inline void PRINT(LONG x, const string &s)
{
    const long long Base = 1000000000000000000;
    long long l = x / Base, r = x % Base;
    if (l) printf("%lld%18lld", l, r);
    else printf("%lld", r); putchar(s[0]);
}

int main()
{
    cin >>n >>r >>g >>b >>T;
    const LONG jg = r, fs = g, gr = b;
    const LONG fsgr = fs * gr, fsT = fs * T;
    const LONG jggr = jg * gr, jgT = jg * T;

    //i(干扰塔个数), j(放射塔个数) , k(激光塔个数) ↓
    for (int j = 1; j <= n; j++) //边界 
        dp[0][j] = dp[0][j-1] + fsT * (n-j);
    for (int i = 1; i < n; i++)
        for (int j = 1, k; k = n - i - j; j++)
            dp[i][j] = max(dp[i-1][j] + fsgr * j * k,
                           dp[i][j-1] + (fsgr * i + fsT) * k);
    
    for (int i = 0; i < n; i++) //加上激光塔求最大值 
        for (int j = 0, k; k = n - i - j; j++)
            ans = max(ans, dp[i][j] + (jggr * i + jgT) * k);
    PRINT(ans, "\n");
    return 0;
}
```

---

## 作者：寄风 (赞：11)

## 废话
今天模拟考考了这一题，考场上生草一个 $O(n^3)$ 做法，结果为了减小常数，没开 `__int128`，100->60，写篇题解纪念。

## 正题
一眼 dp。考虑四维状态 $dp_{i,j,k,l}$ 表示当前布防到了第 $i$ 个，有 $j$ 个激光塔，$k$ 个放射塔，$l$ 个干扰塔。

时空复杂度显然直接爆炸，考虑优化。可以发现，知道总数和两种塔的数量，可以直接算出第三种塔的数量（因为不放塔是不优的，在这个不放塔的位置丢上任何一个塔显然不会更劣）。

于是现在时空复杂度均降为 $O(n^3)$。

分析一下复杂度。数据范围是 $1 \le n \le 1024$，这 $O(n^3)$ 只要常数小不是随便过？优化一下空间就行了。

然后套路滚动数组，使得空间降至二维。

而 dp 的转移是简单的，枚举第 $i$ 个位置放哪种塔，根据题意计算出对应的伤害就行了。

于是就做完了。

注意要开 `__int128`。
## 后话
实际上有一个结论，就是激光塔放在后面一定不会更劣。然后有了这个结论，复杂度可以做到 $O(n^2)$。笔者再去钻研钻研。

## 代码
时间复杂度 $O(n^3)$，空间复杂度 $O(n^2)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int __int128
int read(){
	int s = 0 , f = 1;
	char c = getchar();
	while(c < '0' || c > '9'){
		f = c == '-' ? -1 : 1;
		c = getchar();
	}
	while(c >= '0' && c <= '9'){
		s = (s << 1) + (s << 3) + c - '0';
		c = getchar();
	}
	return f * s;
}
void print(int x){
	x < 0 ? x *= -1 : x *= 1;
	x > 9 ? print(x / 10) , putchar(x % 10 + '0') : putchar(x % 10 + '0');
}
int dp[1055][1055];//dp[i][j][k]表示当前放到i，有j个干扰，k个放射，激光可以算，滚动掉i 
int n , r , g , b , t;
inline int _get(int j , int k){//k个放射塔，j个干扰塔，蚂蚁走一个单位带来的伤害 
	return k * g * (t + j * b);
}
signed main(){
	n = read() , r = read() , g = read() , b = read() , t = read();
	//方程：dp[j][k]=max(dp[j-1][k]+k*g*(t+(j-1)*b),dp[j][k-1]+(k-1)*g*(t+j*b),dp[j][k]+r*(t+j*b))
	memset(dp , 0xcf , sizeof(dp));
	dp[0][0] = 0;
	int ans = 0;
	for(int i = 1;i <= n;i++){
		for(int j = i;j >= 0;j--){
			for(int k = i - j;k >= 0;k--){
				int tmp = dp[j][k];
				int cnt = i - j - k;
				int ans1 , ans2 , ans3;
				int w1 = -1e18 , w2 = -1e18 , w3 = -1e18;
				if(j > 0) w1 = dp[j - 1][k] + _get(j - 1 , k);
				if(k > 0) w2 = dp[j][k - 1] + _get(j , k - 1);
				dp[j][k] = max(w1 , w2);
				w3 = tmp + _get(j , k) + r * (t + j * b);
				dp[j][k] = max(dp[j][k] , w3);
				ans = max(ans , dp[j][k]);
				// if(dp[j][k] < 0) puts("Boom!");
			}
		}
	}
//	for(int i = 0;i <= n;i++){
//		for(int j = 0;j + i <= n;j++){
//			ans = max(ans , dp[i][j]);
//		}
//	}
	print(ans);
	return 0;
}
```



---

## 作者：End1essSummer (赞：10)


原题链接：[传送门](https://www.luogu.com.cn/problem/P2198)

我der分数历程 0->70->90->100

由于这道题让我掉了为数不多的头发，特地来写一篇题解来纪念我的头发QAQ

----

  - 目录QAQ
  
     - 题面简化
     
     - 思路确定（dp）
     
     - 细节问题（int128,转移以及解）
     
     - 具体实现（代码以及注释）
     

----

### 题面简化

题面中给了你这些有用的信息：

激光塔：每秒对蚂蚁造成 **r** 点伤害（经过这个塔的单位长度时）

放射塔：蚂蚁经过这座塔 **后** ，每一秒受到 **g** 点伤害。

干扰塔：蚂蚁经过这座塔 **后** ，经过之后 **每一个单位长度** 的时间变成 **T+b** 。

并且塔的效果可以叠加。

----

### 思路确定

分析这些信息可以得知：若有任意一个激光塔不在后面，即它的后面还有任意一个放射塔或者是干扰塔，那么我们可以交换他们的顺序来使得答案更优。

具体证明应该无需多说，这里只给出简要思路：如果它后面有个放射塔，那么和它交换位置后每秒能造成更多的伤害。如果它后面有个干扰塔，把它放前面后能使蚂蚁经过单位长度的时间更多，也能让后面的塔造成更多伤害。

那么最后得到的结果应该是一大摊激光塔的前面是一大摊干扰塔和一大摊放射塔，由于干扰塔和放射塔的顺序可能不是固定的，我们考虑用dp求解。

更具体一点，我们定义 $dp[i][j]$ 代表前面建了i座放射塔，j座干扰塔，剩下的全建激光塔所能造成的最大伤害。

----

### 细节问题

接下来列举需要注意的一些细节问题：

   1. 首先，这道题的极限数据你用int或是long long都是必炸的。所以我们需要高精度。不过其实这道题其实是只需要四十位高精的，所以我们可以用int128。至于int128,它不支持cin,cout,scanf,printf等正常方式对变量的输入输出，需自己另写输入输出函数(或瞎搞输出，接下来可以在我的代码里看到)。
   
   2. 关于这道题的边界问题，需要注意的是找答案时实际上任何一个方案都有可能成为最后的解（包括边界 $dp[0][0]$ , $dp[i][0]$ , $dp[0][j]$ ，即分别是全建激光塔，和分别只有两种塔的情况。），这也是为什么我先70分然后90分却AC不了（当然现在AC了）的原因。
   
   3. 关于转移。由于这道题我们需要dp转移,我们来考虑转移公式。对于 $dp[i][j]$ 来讲，它能够从 $dp[i][j-1]$ 和 $dp[i-1][j]$ 转移过来。由于我们相当于拆了一座激光塔去建了一座新塔，所以我们考虑先减去被拆掉的激光塔（激光塔：QAQ）对答案的贡献，然后再去考虑新建的塔的贡献。这里分类讨论：当新建的塔是放射塔的时候，它所能造成的贡献便是 剩下的单位长度 $\times$ 走完一单位长度所需的时间  $\times$  放射伤害。当新建的塔是干扰塔的时候，它所能造成的伤害便是 累计放射伤害 $\times$ 单位长度 $\times$ 干扰塔延长时间 + 激光塔伤害 $\times$ 单位长度 $\times$ 干扰塔延长时间 。具体实现请看代码。 （为什么这样做，请结合动规数组定义来理解。另外，定义不止我这一种，解法也不止一种，如果你发现你的定义和我的不一样，请先不要着急重构，您可以选择先检查自己的方法为什么错了或者转战其他的题解qwq）
   
----

### 具体实现

```cpp

#include<algorithm>
#include<iostream>
#define ll __int128_t //宏定义
#define ull unsigned long long
using namespace std;
long long n,r,g,b,t;
ll dp[1030][1030]={0},jg=0,fs=0,gr=0,maxn=0,T=0;//i为放射，j为干扰,另外其他的变量应该是可以看名字猜出用来干什么的qwp（例如maxn就是统计答案的，jg就是激光）
int main(){
    cin>>n>>r>>g>>b>>t;
    jg=r,fs=g,gr=b,T=t;
    dp[0][0]=n*T*jg;//初始化
    maxn=dp[0][0];
    for(ll j=1;j<=n;j++){
        dp[0][j]=dp[0][j-1]-(T+gr*(j-1))*jg+jg*(n-j)*gr;
        maxn=max(maxn,dp[0][j]);
    }for(ll i=1;i<=n;i++){
        dp[i][0]=dp[i-1][0]-T*jg+fs*(n-i)*T;
        maxn=max(maxn,dp[i][0]);//一直到这里都是初始化qwp
    }for(ll i=1;i<=n;i++){
        for(ll j=1;j<=n-i;j++){
            dp[i][j]=max(dp[i-1][j]-jg*(T+j*gr)/*减去被拆掉的激光塔*/+fs*(T+j*gr)*(n-i-j)/*考虑放射塔的贡献*/ ,dp[i][j-1]-jg*(T+(j-1)*gr)/*减去被拆掉的激光塔，这里是j-1的原因是因为它是从dp[i][j-1]转移过来的*/+i*fs*(n-i-j)*gr+jg*(n-i-j)*gr)/*考虑干扰塔的贡献*/;
            maxn=max(maxn,dp[i][j]);
        }
    }ull base=1e18;
    ull x=maxn/base,y=maxn%base;
    if(x!=0){
        cout<<x;
    }cout<<y;//这里就是奇奇怪怪的输出方法qwp
    return 0;
}

```

到这里就结束辽，如果还有什么不懂可以私信问我QWQ

完结撒花 \(^ - ^)/

----


---

## 作者：真的超爱信息 (赞：3)

### START


------------

刚开始看到这道题，一眼数据范围，感觉就是三维dp。

但是！！！

第一：longlong很明显是存不下der。但是打高精是不可能的，这辈子都不可能的。于是旁边的dalao告诉我可以用int128诶！！！~~虽然当时并不知道是什么hhhhh~~

第二：数组会开不下。细细思考后发现可以开个滚动数组记录前一个枚举的塔的个数的最优解啊，然后总塔数减去两种塔的个数就是最后一种塔的个数呀！！然后就可以愉快的省下了一维啦！！我可真是个小机灵鬼！！~~不要脸地猛夸自己xixixi~~

初看这题会感觉比较麻烦，因为三种塔并不是很好处理，但只要细心想就能发现：激光塔对于位置没有什么要求，而干扰塔和放射塔很明显是越靠前所造成的总伤害越高，而单纯的干扰塔并不能对蚂蚁造成伤害，所以最终的方案一定是以一堆放射塔，一堆干扰塔，一堆激光塔的形式存在。（也就是说激光塔的位置应该尽量靠后。）

那么题目变简化成了在n个格子的前i个位置放置干扰塔和放射塔，后n-i个位置放置激光塔所造成的最大伤害。

Code：
```cpp
#include<bits/stdc++.h>
#define MAXN 5001
using namespace std;
__int128 n,r,g,t,b,Ans;//懒于打高精hhhh 
__int128 ans[MAXN][MAXN];//二维ans[i][j]来表示前i个塔有j个干扰塔，则有i-j个放射塔，n-i个激光塔 
int read();
void print(__int128 x){
	if(x>9)  print(x/10);
    putchar(x%10+'0');//int128是直接输出不了der，所以要这个亚子输出 
}
int main(){
	//freopen("antbuster.in","r",stdin);
	//freopen("antbuster.out","w",stdout);
	n=read(),r=read(),g=read(),b=read(),t=read();//快读 
	for(int i=1;i<=n;i++)
		ans[i][0]=(i-1)*g*t+ans[i-1][0];//初始化，若n个点上全部都放上放射塔 
	for(int i=1;i<=n;i++)
		for(int j=1;j<i;j++)
			ans[i][j]=max(ans[i-1][j-1]+(i-j)*g*(t+(j-1)*b),ans[i-1][j]+(i-j-1)*g*(t+j*b));
		//共i个点，放j个干扰塔的情况 
	for(int i=0;i<=n;i++)
		for(int j=0;j<=i;j++)
			Ans=max(ans[i][j]+r*(n-i)*(t+j*b)+(i-j)*g*(n-i)*(t+j*b),Ans);
		//n个点上，i个塔已经放置，剩下n-i个塔全部放置激光塔 
	print(Ans);//输出 
	return 0;
}
int read()//快读 
{
	int x=0,k=1;char ch=' ';
	while(!isdigit(ch)){
		ch=getchar();
		if(ch=='-')  k=-1;
	}
	while(isdigit(ch)){
		x=x*10+ch-'0';
		ch=getchar();
	}
	return k*x;
}
```


------------

### END


---

## 作者：Luckies (赞：3)

## 题目大意

有一条长度为 $n$ 个单位长度的路，蚂蚁们要从起点走到终点。蚂蚁们每走 $1$ 个单位距离需要 $T$ 秒钟。现在，出题人可以在路上修筑 $3$ 种防御塔来阻挡蚂蚁的进攻，每个单位距离只能修筑 $1$ 座塔，塔的作用分别如下：

1. 激光塔：蚂蚁在塔前时每秒会受到 $r$ 点伤害。

2. 放射塔：蚂蚁经过塔后，每秒钟受到 $g$ 点伤害。

3. 干扰塔：蚂蚁经过塔后，每行走一个单位距离的时间延长为 $T + b$。

其中，放射塔和干扰塔的效果可以叠加。比如蚂蚁经过了 $y$ 座放射塔后，每秒钟受到的伤害为 $yr$，干扰塔同理。

现在需求能给蚂蚁们造成的最大伤害。

## 解法

分析题目，题目需要求一个最大值，且不在意中间过程，因此我们可以考虑 dp。

设 $dp_{i, j, k}$ 表示修 $i$ 座干扰塔，$j$ 座放射塔，$k$ 座激光塔的最大伤害。显然，每个位置都修塔是最优的，因此，我们可以省掉一维 $k$，需要用时直接计算即可。

关于如何转移，枚举干扰塔和放射塔的个数 $i, j$，$dp_{i, j}$ 可以由 $dp_{i - 1, j}, dp_{i, j - 1}$ 转移过来，也就是对于上一个状态来说，少一座激光塔，多一座干扰塔或少一座激光塔，多一座放射塔。那么 $dp_{i, j} = \max(dp_{i - 1, j} - r\times(t + b(i - 1)) + b\times(n - i - j)(r + g\times j), dp_{i, j - 1} - t\times r - i\times b\times r + g\times(n - i - j)(t + b\times i)$。多一座干扰塔，就要将一座激光塔所造成的伤害减去，加上时间延长放射塔所造成的伤害。多一座放射塔，也要讲一座激光塔的伤害减去，然后加上一座放射塔所造成的伤害。

边界的处理和转移差不多，就是此时只有两种塔，比转移少简单一些。需要注意的是全是激光塔的情况也需要处理，也就是 $dp_{0, 0} = t\times r\times n$。

由于此题答案可能过大，整数变量需要定义为 ```__int128```，且 ```__int128``` 无法使用 ```cin```、```cout```、```scanf```、```printf``` 等进行输入输出，所以请手写快读快写。

## AC Code
```cpp
#include<bits/stdc++.h>
#define int __int128
using namespace std;
const int N = 2e3 + 5;
int n, r, g, b, t, dp[N][N], ans;
int read()
{
	int k = 1, t = 0;
	char c = getchar();
	while(c < '0' || c > '9')
	{
		if(c == '-')
			k *= -1;
		c = getchar();
	}
	while(c >= '0' && c <= '9')
	{
		t = t * 10 + c - '0';
		c = getchar();
	}
	return k * t;
}
void write(int x)
{
	int b[50], cnt = 0;
	while(x != 0)
	{
		int y = x % 10;
		x /= 10;
		b[++cnt] = y;
	}
	for(int i = cnt; i >= 1; i--)
		putchar(b[i] + '0');
	return;
}
signed main()
{
	n = read(), r = read(), g = read(), b = read(), t = read();
	memset(dp, 0xcf, sizeof(dp));
	dp[0][0] = n * t * r;
	ans = dp[0][0];//处理边界
	for(int i = 1; i <= n; i++)
	{
		dp[i][0] = dp[i - 1][0] - (t + (i - 1) * b) * r + (n - i) * b * r;
		dp[0][i] = dp[0][i - 1] - t * r + (n - i) * t * g;
		ans = max(ans, max(dp[0][i], dp[i][0]));
	}
	for(int i = 1; i <= n; i++)//转移
		for(int j = 1; j + i <= n; j++)
			dp[i][j] = max(dp[i - 1][j] - (t + (i - 1) * b) * r + (n - i - j) * b * (r + g * j), dp[i][j - 1] - t * r - i * (b * r) + (n - i - j) * (t + b * i) * g);
	for(int i = 1; i <= n; i++)//答案为最大值
		for(int j = 1; j + i <= n; j++)
			ans = max(ans, dp[i][j]);
	write(ans);
	return 0;
}
```

---

## 作者：dlxingzi (赞：2)

#### 闲话
这题花了我三天时间，写篇题解来庆祝一下。

( scv?话说，现在还有打 sc2 的 OIer 吗？)

### 题意简要：
你可以布防 n 座防御塔，来阻挡蚂蚁们的进攻。你需要输出对蚂蚁能造成的最大伤害量。可以选择的塔的种类如下：
* 激光塔：当蚂蚁从塔前经过时，每秒对蚂蚁造成 r 点伤害。
* 放射塔：当蚂蚁经过这座塔后，每一秒受到 g 点伤害。
* 干扰塔：当蚂蚁经过这座塔后，经过之后每一个单位长度的时间变成 t+b。

其中，r 表示激光塔的效果，g 表示放射塔的效果，b 表示干扰塔的效果，t 表示蚂蚁们经过一个单位长度所用的时间。

## 正文
这题，很明显是dp。

想到以 dp[i][j][k] 表示放 i 座激光塔， j 座放射塔， k 座干扰塔。

但是，这样转移式很繁琐，时间也过不去，所以考虑优化。

经过一段时间的思考，我惊奇的发现，激光塔和(在它前面的)放射塔(或干扰塔)交换位置,伤害量只会大，绝对不会小(激光和放射交换位置，放射伤害多了一格，激光和干扰交换位置，减速多了一格）。

也就是说，将激光塔全部放在最后是最优的，而前面则是放射塔和干扰塔镶嵌分布。

那么状态就出来了，设 dp[i][j] 表示前面放 i 个放射塔，j 个干扰塔所造成的最大伤害量。

转移式即为
```
dp[i][j]=max(dp[i-1][j]+(n-i-j)*g*(t+b*j)-t*r-j*b*r,
dp[i][j-1]-(t+b*(j-1))*r+r*b*(n-i-j)+i*g*(n-i-j)*b);
```
dp[i][j] 可以由 dp[i-1][j] 和 dp[i][j-1] 转移过来，即在多放一座放射塔造成的伤害量-少放一座激光塔的伤害量和多放一座干扰塔造成的伤害量-少放一座激光塔的伤害量中取最值。



这里要注意，放射塔和干扰塔的顺序我们是不用管的，这里生成的就是最优序列产生的最大伤害量。

要记住，边界情况也要记入
(如全是激光塔，全是放射塔或只有两种塔的情况)

这题会爆 long long ，而 ~~我懒得写~~ 高精度太繁琐，所以用 __int128_t。

代码如下

```cpp
#include <bits/stdc++.h>
using namespace std;
long long N,R,G,B,T;
__int128_t dp[1025][1025],ans=0,n,r,g,b,t;
signed main(){
    cin>>N>>R>>G>>B>>T;
    n=N,r=R,g=G,b=B,t=T;
    //要这么搞才能对，只用long long会有问题
    //我在这卡了好久qwq
    dp[0][0]=n*r*t;
    //全部激光塔
    ans=max(ans,dp[0][0]);
    for(int i=1;i<=n;i++){
        dp[i][0]=dp[i-1][0]+(n-i)*g*t-r*t;
        //i座放射塔，n-i座激光塔
        ans=max(ans,dp[i][0]);
        dp[0][i]=dp[0][i-1]+b*r*(n-i)-(t+(i-1)*b)*r;
        ans=max(ans,dp[0][i]);
        //i座干扰塔，n-i座激光塔
    }
    //以上都是初始化
    for(int i=1;i<=n;i++){
        for(int j=1;j<=n-i;j++){
            dp[i][j]=max(dp[i-1][j]+(n-i-j)*g*(t+b*j)-t*r-j*b*r,\
            dp[i][j-1]-(t+b*(j-1))*r+r*b*(n-i-j)+i*g*(n-i-j)*b);
            //在多放一座放射塔造成的伤害量和多放一座干扰塔造成的伤害量中取最值
            //记住，当多放一座干扰塔时，把放射塔多造成的伤害也算进去
            ans=max(ans,dp[i][j]);
            //任意一种方案都可能成为答案
        }
    }
    unsigned long long base=1e18;
    unsigned long long x=ans/base,y=ans%base;
    if(x!=0)cout<<x;
    cout<<y;
    return 0;
}
```



---

## 作者：九思 (赞：2)

激光塔:蚂蚁经过**时**,每秒造成r点伤害;  
放射塔:蚂蚁经过**后**,每秒受到g点伤害，效果可叠加;  
干扰塔:蚂蚁经过**后**,经过**之后每一个单位长度**的时间增加b，效果可叠加。

DP。分析可知，激光塔一定放最后面造成的杀伤最大，因为放射和干扰效果均可延续至最后一格，一定要放在前面。~~（证明就不用了吧好像前面那位兄台说了qwq）~~  
那么dp[i][j]设前i格放了j个**放射塔**(那么就有i-j个干扰塔啦)在此格可造成的最大伤害值，则  
```dp[i][j]= max(dp[i-1][j-1]+g*(j-1)*(b*(i-j)+T), dp[i][j],dp[i-1][j]+g*j*(b*(i-j-1)+T)); ```  
（注意只有i>j时才可以进行后一步转移~~调了1.5h qwq~~）  

处理完后再加上激光塔和放射塔的共同伤害并取最大值再统计  
```ans=max(ans,dp[i][j]+(n-i)*(T+b*(i-j))*(g*j+r));```  
注意i和j都要从0开始枚举哦  

要用~~高精(这辈子都不可能的)~~__int128

```
#include<cstdio>
#include<cstring>
#include<iostream>
#define f(i,a,b) for(register int i=a;i<=b;++i)
using namespace std;
const int N = 1234;
template <class T> inline void read(T &n) {
    n=0;register char ch;while(!isdigit(ch=getchar()));
    for(n=ch^48;isdigit(ch=getchar());n=(n<<3)+(n<<1)+(ch^48));
}
template <class T>inline void write(T x) {
    if(x<0)putchar('-'),x=-x;
    if(x>9)write(x/10);putchar(x%10+48);
}
__int128 ans,dp[N][N],n,r,g,b,T;
int main() {
	read(n),read(r),read(g),read(b),read(T);
	f(i,1,n) f(j,1,i) {dp[i][j]=dp[i-1][j-1]+g*(j-1)*(b*(i-j)+T);
    //这个是第i格放放射塔
	if(i>j)dp[i][j]=max(dp[i][j],dp[i-1][j]+g*j*(b*(i-j-1)+T));
    //这个是第i格放干扰塔
    }
	f(i,0,n) f(j,0,i)
	ans=max(ans,dp[i][j]+(n-i)*(T+b*(i-j))*(g*j+r));
    //加上激光塔~~
	write(ans);
    return 0;
}
```

---

## 作者：creation_hy (赞：1)

题目很傻，但是细节多。。。。

这三种塔我的第一感觉是分段，分别放放射、干扰、激光，然后把式子化一下就能做到平方，但是不对。

原因是放射和干扰可能会交叉，因为前面放干扰的话后面放射在前期会变强。

那 dp 不就行了，$f[i][j]$ 表示前 $i$ 个全放放射或者干扰，然后放了 $j$ 个放射。转移很简单。统计答案直接加上后面的激光就行了。

然后注意几个坑，首先要用 int128，其次要考虑只放一种塔和只放两种塔的情况。

最后千万不要统计到 $f[x][x+1]$ 这种状态，会出 bug。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 1050;
__int128 n, r, g, b, T, f[N][N], ans;
inline void print(__int128 x)
{
    if (x > 9)
        print(x / 10);
    cout << char(x % 10 + 48);
}
inline __int128 read()
{
    ll x;
    cin >> x;
    return x;
}
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    n = read(), r = read(), g = read(), b = read(), T = read();
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= i; j++)
            f[i][j] = max(j < i ? f[i - 1][j] + ((i - 1 - j) * b + T) * (g * j) : 0, f[i - 1][j - 1] + ((i - j) * b + T) * (g * (j - 1)));
    for (int i = 0; i <= n; i++)
        for (int j = 0; j <= i; j++)
            ans = max(ans, f[i][j] + (n - i) * ((i - j) * b + T) * (r + g * j));
    print(ans);
    return 0;
}
```

---

## 作者：Φρανκ (赞：1)

题意：布置三种防御塔共 $n$ 座，使经过这些塔的蚂蚁受伤害最高。

核心思想：DP

解：

三种塔分别为：

1. 干扰塔：使蚂蚁**此后**经过每一格所需时间增加 $b$ 秒。
2. 放射塔：使蚂蚁**此后**经过每一秒受到伤害增加 $g$ 点。
3. 激光塔：使蚂蚁经过该塔**本身**每一秒受到伤害 $r$ 点。

容易发现，激光塔的伤害与蚂蚁经过它本身所花时间成正比，放射塔伤害与蚂蚁经过它之后所有塔时间成正比。所以激光塔应建在所有干扰塔与放射塔之后之后，但放射塔与干扰塔的位置关系是不定的，需要DP。

考虑状态 $f(i,j)$ 指修筑 $i$ 座干扰塔，$j$ 座放射塔，其余皆修筑激光塔后最大可造成的伤害。该状态可以从 $f(i-1,j)$ 或 $f(i,j-1)$ 转移得到，方法是去除一座激光塔并在前面两种塔序列的末尾添加一座对应类型的塔（在开头添加应该也可行，但过于复杂未推出）并除去一座激光塔。

设当前已有 $x$ 座干扰塔，$y$ 座射线塔，则拆除一座激光塔会减少 $r(t+bx)$ 点伤害。此后再修筑一座干扰塔会增加 $b(n-x-y-1)(r+gy)$ 点伤害（对于后面 $n-x-y-1$ 座激光塔的每一座蚂蚁需要多消耗 $b$ 秒经过，这期间其每秒受 $r+gy$ 点伤害），修筑放射塔则会增加 $g(n-x-y-1)(t+bx)$ 点伤害（对于后面 $n-x-y-1$ 座激光塔的每一座蚂蚁需要消耗 $t+bx$ 秒经过，这期间其每秒多受 $g$ 点伤害），对于每一个状态比较两种转移方式即可。

DP正确性论证：一个区间内塔修筑顺序只会对蚂蚁在该区域内所受伤害值造成影响，而不会对蚂蚁在其之后每秒受伤害值与移速造成影响。所以DP一定可以得到最优解。

需要使用```__int128```，否则数据会溢出。

代码：
```
#include <bits/stdc++.h>
using namespace std;
long long n1, r1, g1, b1, t1, res1[101], flag;
__int128 n, r, g, b, t, a[1025][1025], res;
int main()
{
	cin>>n1>>r1>>g1>>b1>>t1;
	n=n1;
	r=r1;
	g=g1;
	b=b1;
	t=t1;
	a[0][0]=t*r*n;//初始化
	for(int i=1; i<=n; i++)
	{
		a[i][0]=a[i-1][0]-(t+(i-1)*b)*r+b*r*(n-i);
		a[0][i]=a[0][i-1]-t*r+g*t*(n-i);
	}//边界条件
	for(int i=1; i<=n; i++)
		for(int j=1; j<=n; j++)
			a[i][j]=max(a[i-1][j]-(t+(i-1)*b)*r+b*(j*g+r)*(n-i-j), a[i][j-1]-(t+i*b)*r+g*(t+i*b)*(n-i-j));//DP
	for(int i=0; i<=n; i++)
//	{
		for(int j=0; j<=n; j++)
//		{
//			cout<<a[i][j]<<" ";
			res=max(res, a[i][j]);//查找最大值
//		}
//		cout<<endl;
//	}
	while(res>0)
	{
		res1[flag++]=res%10;
		res/=10;
	}//转化__int128
	for(int i=flag-1; i>=0; i--)
		cout<<res1[i];//输出
	return 0;
}

```

---

## 作者：minVan (赞：0)

**解题思路**

激光塔一定在最后。$f_{i,j}$ 表示前 $i$ 个位置放 $j$（$j\le i$）个放射塔，那么 $i-j$ 个干扰塔的伤害。

若第 $i$ 个位置放放射塔：$f_{i,j}=f_{i-1,j-1}+(j-1)\times g\times[t+b\times(i-j)]$
若第 $i$ 个位置放干扰塔，也就是 $j<i$：$f_{i,j}=\max\{f_{i-1,j-1}+(j-1)\times g\times[t+b\times(i-j)],f_{i-1,j}+j\times g\times[t+b\times(i-j-1)]\}$。

最终答案为 $\max\limits_{0\le j\le i\le n}\{f_{i,j}+(n-i)\times(r+j\times g)\times[t+b\times(i-j)]\}$。

由于答案过大，所以建议开 `__int128_t` 或者高精度。

**AC 代码，请勿抄袭**

```cpp
#include<bits/stdc++.h>
using namespace std;
__int128_t n, r, g, b, t, ans, f[1030][1030];
inline __int128_t read() {
  __int128_t x = 0;
  bool flag = 0;
  char ch = getchar();
  while(ch < '0' || ch > '9') {
    if(ch == '-') {
      flag = 1;
    }
    ch = getchar();
  }
  while(ch >= '0' && ch <= '9') {
    x = x * 10 + (ch - '0');
    ch = getchar();
  }
  if(!flag) {
    return x;
  } else {
    return -x;
  }
}
inline void write(__int128_t x) {
  if(x < 0) {
    x = -x;
    putchar('-');
  }
  if(x > 9) {
    write(x / 10);
  }
  putchar(x % 10 + '0');
}
int main() {
	n = read(), r = read(),  g = read(), b = read(), t = read();
	for(int i = 1; i <= n; i++) {
		for(int j = 1; j <= i; j++) {
			f[i][j] = f[i - 1][j - 1] + (j - 1) * g * (t + b * (i - j));
			if(i != j) {
				f[i][j] = max(f[i][j], f[i - 1][j] + j * g * (t + b * (i - j - 1)));
			}
		}
	}
	for(int i = 0; i <= n; i++) {
		for(int j = 0; j <= i; j++) {
			ans = max(ans, f[i][j] + (n - i) * (r + j * g) * (t + b * (i - j)));
		}
	}
	write(ans);
	return 0;
}
```

---


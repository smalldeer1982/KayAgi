# [TJOI2015] 组合数学

## 题目描述

为了提高智商，ZJY 开始学习组合数学。某一天她解决了这样一个问题：给一个网格图，其中某些格子有财宝。每次从左上角出发，只能往右或下走。问至少要走几次才可能把财宝全捡完。

但是她还不知足，想到了这个问题的一个变形：假设每个格子中有好多块财宝，而每一次经过一个格子至多只能捡走一块财宝，其他条件不变，至少要走几次才可能把财宝全捡完？

这次她不会做了，你能帮帮她吗？

## 说明/提示

### 数据范围

对于 $30\%$ 的数据，$n \le 5$，$m \le 5$，每个格子中的财宝数不超过 $5$ 块。

对于 $50\%$ 的数据，$n \le 100$，$m \le 100$，每个格子中的财宝数不超过 $1000$ 块。

对于 $100\%$ 的数据，$1\le t\le 2$，$1\le n \le 1000$，$1\le m \le 1000$，每个格子中的财宝不超过 $10^6$ 块。

## 样例 #1

### 输入

```
1
3 3
0 1 5
5 0 0
1 0 0```

### 输出

```
10```

# 题解

## 作者：ButterflyDew (赞：46)

这不是个贪心吗？

怎么都最小链覆盖=最大点独立集去了

注意到一个点出度最多只有2，可以贪心一下出度的去向

按读入顺序处理就可以，维护一个$res_i$数组，表示上一行第$i$列可以流给下面那个格子的次数，然后如果当前这个格子不够用，从右往左把所有的还有次数的$res$拿过来给当前格子用就可以了。

考虑这样的正确性，每个格子已经用了上面的，当然继续从左边的用啦

------

**Code:**

```cpp
#include <cstdio>
#include <cctype>
#include <cstring>
template <class T>
void read(T &x)
{
	x=0;char c=getchar();
	while(!isdigit(c)) c=getchar();
	while(isdigit(c)) x=x*10+c-'0',c=getchar();
}
const int N=1010;
const int inf=0x3f3f3f3f;
int res[N],s[N],tot;
void work()
{
	memset(res,0,sizeof res);
	int n,m,ans=0;
	read(n),read(m);
	for(int a,i=1;i<=n;i++)
	{
	    res[s[tot=1]=0]=inf;
	    for(int j=1;j<=m;j++)
		{
			read(a);
			if(a>res[j])
			{
			    int d=a-res[j];
				while(res[s[tot]]<d) d-=res[s[tot]],res[s[tot--]]=0;
				res[s[tot]]-=d;
				res[j]=a;
			}
			s[++tot]=j;
		}
		ans+=inf-res[0];
	}
	printf("%d\n",ans);
}
int main()
{
	int T;read(T);
	while(T--) work();
	return 0;
}
```

---

## 作者：yihhhhhhh (赞：18)

dag有向无环图

最长反链=dag最小覆盖

dp
注意用longlong

然后还有就是不用初始化因为刚开始都是边界【】【0】或【0】【】推导出来取0没有影响

不懂可以戳http://www.cnblogs.com/maijing/p/4844893.html

> Dilworth定理：DAG的最小链覆盖=最大点独立集 
最小链覆盖指选出最少的链(可以重复)使得每个点都在至少一条链中

最大点独立集指最大的集合使集合中任意两点不可达

> 此题中最大点独立集显然是一个集合满足集合中任意两点都是左下-右上的关系
对于点(i,j)来说，点(i-1,j+1)不和它联通，对于任一个f[i][j]，它存储的都是以(i,j)为左下端点一直到往上的方格图中需要走的次数

f[i][j]可以是f[i-1][j+1]+a[i][j]

(不和(i-1,j+1)联通，所以f[i][j]一定大于等于(i-1,j+1)的方案数+自己的权值数)

f[i-1][j]与f[i][j+1]在这里可以看作是矩阵间的合并求最大


```cpp
    #include<bits/stdc++.h>
    #include<algorithm>
    #define ll long long
    using namespace std;
    int read(){
        int x=0,f=1;char ch=getchar();
        for(;!isdigit(ch);ch=getchar())if(ch=='-')f=-1;
        for(;isdigit(ch);ch=getchar())x=(x<<3)+(x<<1)+ch-48;
        return x*f;
    }
    int a[1005][1005],T,n,m;
    ll f[1005][1005];
    int main(){
        T=read();
        while(T--){
            n=read();m=read();
            for(int i=1;i<=n;i++)
            for(int j=1;j<=m;j++)
                a[i][j]=read();
            for(int i=1;i<=n;i++)
            for(int j=m;j>=1;j--)//左右翻转矩阵
                f[i][j]=max(f[i-1][j+1]+a[i][j],max(f[i-1][j],f[i][j+1]));//右上到左下（考虑必须独立走的格子——>右上到左下）或者隔壁
            printf("%lld\n",f[n][1]);
        }
        return 0;
}
```

---

## 作者：Piwry (赞：12)

看大部分题解都对这个 $Dilworth$ 定理讲的不够清楚...这个定理其实是可以推广到更广泛的情况的（~~貌似有一位大佬有提到广义的定义...只是有点简短（~~。

于是我就来给出一个具体的定义QWQ

## $Dilworth$ 定理

首先讲**偏序集**的定义：

对集合 $A$ 给定一个关系 $R$（表达元素间的这个关系可以记做 $aRb$），若 $R$ 满足（默认元素均 $\in A$）：

1. $aRa$（自反性）
2. 若 $aRb, bRa$，则有 $a=b$（反对称性）
3. 若 $aRb, bRc$，则有 $aRc$（传递性）

则 $R$ 是 $A$ 上的偏序关系，$R$ 和 $A$ 一起被称为一个偏序集。

（全序集其实就是对于任意两个属于 $A$ 的元素均有关系 $R$）

再回到 $Dilworth$ 定理。首先定义：

1. 链，指一个集合 $S\subseteq A$，它的任意两个元素都可比。
2. 反链，指一个集合 $S'\subseteq A$，它的任意两个元素都不可比。

而 $Dilworth$ 定理其实就是指：

1. 对于一个偏序集，其最少反链划分数等于其最大链的大小。
2. 对于一个偏序集，其最少链划分数等于其最大反链的大小。

现在讲讲证明：

首先第二条显然可以通过 "反向" 定义偏序集从而得到。我们只尝试证明第一条。

定义最少反链划分数 $p$，最大链大小 $r$，偏序集 $X$。

$\text{Lemma 1. }p\geqslant r$

$\text{Proof. }$由于链中元素都两两可比，所以它们之间都不会被划分到同一个反链中，显然得证。

 _--定义极小元：在偏序集 $X$ 中，对于某元素 $a$，如果对于任意元素 $b$，都有 $aRb$，则称 $a$ 为 $X$ 中的极小元。_ 

$\text{Lemma 2. }r\geqslant q$

$\text{Proof. }$设 $X_1=X$，令 $A_1$ 是 $X_1$ 中极小元的集合，从 $X_1$ 中删除 $A_1$ 得到 $X_2$；令 $A_2$ 是 $X_2$ 中极小元的集合，从 $X_2$ 中删除 $A_2$ 得到 $X_3$...并如此循环定义，最终一定会有一个 $X_k$ 非空而 $X_{k+1}$ 为空。

显然 $A_1,A_2,...,A_k$ 就是 $X$ 反链的**一种**划分（根据定义，每个极小元集合中的元素除非相等，否则**不可比**），因此至少有$k\geqslant q$；且注意到对于 $X_i(i>1)$ 中任意元素 $a_i$，必存在 $X_{i-1}$ 中的元素 $a_{i-1}$，使得 $a_{i-1}Ra_i$。因此易得存在链 $S=\{a_1, a_2, ..., a_k, R\}$（根据传递性）。由于 $r$ 是最长链大小，因此至少有 $r\geqslant k$。引理于是得证。

## 本题解析

我们将每个格子拆为其财宝个数个元素，并定义关系 $aRb$ 为在网格图中 $a$ 可以到达 $b$，注意同一个格子的元素是**相互不可到达的**（一次只能拿一个财宝）。

显然这样的关系是满足偏序关系要求的。那么题目要求我们求的实际上就是这个偏序集的最少链划分数，也就是最大反链大小。

但由于这个偏序关系和网格图密切相关，我们可以不在转化后的偏序集上做，而是直接在网格图上做 "dp"。

考虑一个格子位置 $(i,j)$（$(\text{行, 列})$，编号从左到右或从上到下递增）。所属格子位置在该格子右上角且 "**相邻**" 的，且上面元素和该格子上面元素没有偏序关系的，一定是格子 $(i-1, j+1)$；有偏序关系的，一定是格子 $(i, j+1)$ 和 $(i-1, j)$。

这样的关系也可以递推，从而知道对于一个格子位置，和它有偏序关系的一定是行列**均大于它**或**均小于它**的格子；无偏序关系的一定是行列一**个大于它一个小于它**或相反的格子。

然后显然可以设状态 `[i][j]`，表示从网格图右上角至格子 $(i, j)$ 最大的反链大小，dp 一下就可以了。

（这段 dp 分析写的有点烂...~~感性理解下~~）

## CODE

~~（话说代码和直接考虑 dp 一模一样（~~

```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
using std::max;

int map[1010][1010];
long long dp[1010][1010];

inline int read(){
	int x =0; char c =getchar();
	while(c < '0' || c > '9') c =getchar();
	while(c >= '0' && c <= '9') x = (x<<3) + (x<<1) + (48^c), c =getchar();
	return x;
}

int main(){
	for(int t =0, T =read(); t < T; ++t){
		memset(map, 0, sizeof(map)), memset(dp, 0, sizeof(dp));
		int n =read(), m =read();
		for(int i =1; i <= n; ++i) for(int j =1; j <= m; ++j) map[i][j] =read();
		for(int i =1; i <= n; ++i) for(int j =m; j > 0; --j)
			dp[i][j] =max(dp[i-1][j+1]+map[i][j], max(dp[i][j+1], dp[i-1][j]));
		printf("%lld\n", dp[n][1]);
	}
}
```


---

## 作者：Kaizyn (赞：8)

这题蒟蒻看了好几遍题解还没懂，于是去网上搜集各大神题解在此作补充

参考~~抄自~~：U54194 yihhhhhhh 的题解
[](https://blog.csdn.net/popoqqq/article/details/45171469)https://blog.csdn.net/popoqqq/article/details/45171469
[](https://blog.csdn.net/lych_cys/article/details/50268211)https://blog.csdn.net/lych_cys/article/details/50268211
[](https://blog.csdn.net/ziqian2000/article/details/55684200)https://blog.csdn.net/ziqian2000/article/details/55684200
[](https://www.cnblogs.com/gjc1124646822/p/8481081.html)https://www.cnblogs.com/gjc1124646822/p/8481081.html

------------

结论性题解：

**Dilworth定理** DAG的最小链覆盖=最大点独立集 

**最小链覆盖** 指选出最少的链(可以重复)使得每个点都在至少一条链中 

**最大点独立集** 指最大的集合使集合中任意两点不可达 

此题中最大点独立集显然是一个集合满足集合中任意两点都是左下-右上的关系 


------------

伟大的证明：

①

求一条从左下到右上的最长路径，大概可以证明这就是最少的次数。

简单的证明如下：

- **必要性** 显然成立，这几个点之间不能互相到达，至少需要走这几个点才能全部取完。

- **充分性** 反证法，假设有几个点没有被取完。那么对于每一个点，以这个点为右下角的一个矩形中所有最长路径上的点，他们走的路径都已经满了（语文不好只能这样表达了），否则肯定可以走下来。那么吧这个点加入最长路径，加上这个点左上角走下来碰到的一下点，是更长的路径。只能大概这么表达一下了，讲不清楚啊。

- 或者直接用网络流解释，这道题目就是给出流量下界求最小流，那么对应的就是最大割了。

②

答案就是在图中选出一些点，使得两两不可达且权值和最大。

然而并没有找到证明，于是只好自己脑补。大概是会证(口)明(胡)了吧……现给出我的证明如下：

先分析出行进的策略：走到第一行最右的一个非零格子，向下走一行进入第二行，走到右边最右的一个非零格子(若无则不走)，向下走一行进入第三行，走到右边最右的一个非零格子(若无则不走) ……走到右下角。

**证明**：易知选出的点集中最右上的(称作x)那个一定在第一遍的行进路上。只需证明当x的权值减完之后，点集S中除x以外的最右上的点(称作y)在接下来的行进路上，即可说明存在这样一种方案。

首先，显然x，y围成的矩形内(不含边界)中不可能有点，否则加入点集更优。假设y无法进入当前行进路，即y的右上角还有点，设为u。易知这个点不会在x的右上方，否则就不会轮到x。这个点只能在[y的右上]与[x的左上或右下] 的交集之中。此时用u替换x，点集S权值更优。但可能导致u和x的前一个点集中的右上的点无法衔接，即变得可达。设x的前一个点集中的右上点为z。如果z一直都在消u，则把z也丢掉即可。如果z消u之前在消v(即v,u不可达,v不属于点集S)，则用v,u共同替换x,z答案更优，此时继续递归寻找z的右上点，变成子问题。点集S中最右上的点没有右上点，因此子问题可以结束，即可以找到最优解。

可能你看不懂我在说什么，建议把图画出来比一比，那样应该就知道了QAQ

------------

还有这种似乎比较易懂：

设f[i][j]，代表从(1,m)到(i,j)不能同一次取的有多少，

我们知道(i,j)和右上(i-1,j)是不能同时取的，

所以f[i][j]=f[i-1][j+1]+a[i][j]，

我们同时考虑到(i,j)可以从(i-1,j)和(i,j+1)转移过来

------------

最后得出DP状态转移方程
```cpp
f[i][j] = max( f[i-1][j], f[i][j+1]), f[i-1][j+1]+a[i][j] );
```
                               

------------


```cpp
#include <iostream>
#include <cstring>
#include <cstdio>

using namespace std;

const int Maxn = 1e3+7;

int T, n, m;
int a[Maxn][Maxn];
long long f[Maxn][Maxn];

int main()
{
    scanf("%d", &T);
    while(T--)
    {
        memset(f, 0, sizeof f);
        scanf("%d%d", &n, &m);
        for(int i = 1; i <= n; ++i)
            for(int j = 1; j <= m; ++j)
                scanf("%d", &a[i][j]);
        for(int i = 1; i <= n; ++i)
            for(int j = m; j >= 1; --j)
                f[i][j] = max( max(f[i-1][j], f[i][j+1]), 
                               f[i-1][j+1]+a[i][j] );
        printf("%lld\n", f[n][1]);
    }
    return 0;
}
```


------------
最后……蒟蒻我好像还是不很清楚……

---

## 作者：木xx木大 (赞：7)

[P3974 [TJOI2015]组合数学](https://www.luogu.com.cn/problem/P3974)

**Dilworth定理：最长反链=最小链覆盖=最大独立集**

**最小链覆盖**：指选出最少的链(可以重复)使得每个点都在至少一条链中

**最大独立集**：指最大的集合使集合中任意两点不可达

此题中独立集显然是一个满足集合中任意两点都是左下-右上的关系的集合。最大独立集即在图中选出一些点，使得它们两两不可达且权值和最大。

设 $f_{i,j}$ 表示从 $(1,m)$ 到 $(i,j)$ 不能同一次取的有多少。我们知道 $(i,j)$ 和右上 $(i-1,j+1)$ 是不能同时取的，同时 $(i,j)$ 可以从 $(i-1,j)$ 和 $(i,j+1)$ 转移过来。得出DP方程 $f_{i,j} = max(f_{i-1,j}, f_{i,j+1}, f_{i-1,j+1}+a_{i,j})$ 。

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll dp[1005][1005],g[1005][1005];
int n,m,t;
int main()
{
	scanf("%d",&t);
	while(t--)
	{
		scanf("%d%d",&n,&m);
		for(int i=1;i<=n;i++)
			for(int j=1;j<=m;j++)
				scanf("%lld",&g[i][j]);
		for(int i=1;i<=n;i++)
			for(int j=m;j>=1;j--)
				dp[i][j]=max(dp[i-1][j+1]+g[i][j],max(dp[i-1][j],dp[i][j+1]));
		printf("%lld\n",dp[n][1]);
	}
	return 0;
 } 
 ```

---

## 作者：xiayuanxia (赞：5)

P3974 [TJOI2015] 组合数学

Dilworth 定理告诉我们：最小链覆盖数 = 最大反链的大小。

在本题中：
链：一条路径（从左上到右下的合法移动序列）。
反链：一组格子，其中任意两个格子 $(i,j)$ 和 $(x,y)$ 满足 **$i \leq x$ 且 $j \geq y$**（即一个在另一个的“左下方向”，无法被同一条路径覆盖）。

建模为偏序集：
 
 把每个有财宝的格子 $(i,j)$ 看作一个元素。
 
 定义偏序关系：$(i,j) \leq (x,y)$ 当且仅当 $i \leq x$ 且 $j \leq y$（即可以从 $(i,j)$ 向右或向下走到 $(x,y)$）。 
 
 反链：一组格子，其中任意两个格子不可比，即一个在另一个的“左下方向”。

最大反链：
   - 我们需要找到最大的反链，即最多有多少个格子满足**互相无法被同一条路径覆盖**。
   - 这些格子必须满足：对于任意两个 $(i,j)$ 和 $(x,y)$，要么 $i < x$ 且 $j > y$，要么 $i > x$ 且 $j < y$（即不能同时满足 $i \leq x$ 和 $j \leq y$）。

转化为网格上的“对角线”问题：
 观察发现，反链的格子必须分布在不同的“反对角线”上（即 $i + j$ 为常数的线）。 最大反链的大小 = 所有反对角线上财宝总数的最大值。

 每次路径可以覆盖一个“链”（即一系列可比较的格子）。
 
 最少路径数 = 最小链覆盖数 = 最大反链的大小。
 
 最大反链的大小 = 网格中无法被同一条路径覆盖的格子财宝总数的最大值。

```cpp
#include <iostream>
#include <algorithm>
using namespace std;

const int N = 1005;
int t, n, m;
int a[N][N], dp[N][N];

int main() {
    cin >> t;
    while (t--) {
        cin >> n >> m;
        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= m; j++)
                cin >> a[i][j];
        
        // 动态规划计算最大反链和
        for (int i = 1; i <= n; i++)
            for (int j = m; j >= 1; j--)
                dp[i][j] = max(dp[i-1][j+1] + a[i][j], max(dp[i-1][j], dp[i][j+1]));
        
        cout << dp[n][1] << endl;
    }
    return 0;
}

---

## 作者：lidxy (赞：5)

## **因为我非常喜欢暴力，所以我用暴力 A 了此题。**
~~考场没打完，后来抵了三小时才过~~
## 题目大意:
一个网格图，每个格子上有很多块财宝，每次从左上角出发，只能向右或者下移动，走到右下角，每次只能捡格子上的一块财宝，一共走几次可以把所有财宝全部捡完。
## 思路：
大体思路，从左下角枚举到右上角（或者从右上角枚举到右下角，我写的是第一个），从每一列不断向上枚举，如果枚举到第一行，就从第二列开始向上枚举，以此类推，到第一行第 $m$ 列结束。
## 实现：
为什么是正确的？

通过观察可以发现左下角的格子只能通过第一列移动过来，并且只能向最后一行移动，所以可以直接模拟题意，把左下角的格子清零，并且把第一列和最后一行的格子减去左下角格子的值。

我们用 `a[i][j].w` 存每个格子的值。

如果这个格子减完之后小于 $0$ 就直接赋值为 $0$（可能不需要，但是抵 bug 的时候好抵）。

然后继续枚举 `a[n-1][1].w`，但是我们发现
如果 `a[n][2].w` `a[n-1][3].w` 都大于零，那么就不知道向哪移动，因此我们用 `a[n-1][2].cun` 来存这个节点可以有多少值继续向后移动（只存在这里，先不进行移动），同时把这个点的值减去 `a[n-1][1].w` ，
当我们枚举到 `a[n][2].w` 的时候先用存的值减，并且把 `a[n][2].w-=a[n-1][2].cun`（这个点存的值不够的话，就把它本身的值减去差的值），如果存的值不够，就继续枚举它上面存的值，加起来大于 `a[n][2].w` 就不需要记录答案，如果小于的话就把答案加上他们的差值，以此类推直到结束。
## 时间复杂度：

我的代码中可能有不必要的枚举，有的地方可以 break ，卡卡常应该能到最优解。
## 代码：
```
#include<bits/stdc++.h>
using namespace std;
#define ll long long
int t,n,m;
ll ans;
struct node
{
    int w,cun;
}a[1003][1003];
inline void dfs(int w,int x,int y)
{
    if(w==0)//如果这个点值为0.
    {
        if(x==1&&y==m)
        {
            cout<<ans<<endl;
            return;
        }
        else
        {
            if(x-1==0)
            {
                if(a[x-1][y].cun)
                {
                    a[x-1][y+1].cun+=a[x-1][y].cun;
                    a[x-1][y+1].w-=a[x-1][y].cun;
                    if(a[x-1][y+1].w<0)a[x-1][y+1].w=0;
                    a[x-1][y].cun=0;
                }
                else
                {
                    a[x-1][y].cun=0;
                }
                dfs(a[n][y+1].w,n,y+1);
                return ;
            }
            else
            {
                if(a[x-1][y].cun)
                {
                    a[x-1][y+1].cun+=a[x-1][y].cun;
                    a[x-1][y+1].w-=a[x-1][y].cun;
                    if(a[x-1][y+1].w<0)
                    {
                        a[x-1][y+1].w=0;
                    }
                    a[x-1][y].cun=0;
                }
                else
                {
                    a[x-1][y].cun=0;
                }
                dfs(a[x-1][y].w,x-1,y);
                return ;
            }
        }
    }
    else
    {
        int w1=w;
        a[x][y].w=0;
        if(x==1)
        {
            ans+=w;
        }
        else
        {
            for(register int i=x-1;i>=1;--i)
            {
                if(a[i][y].cun)
                {
                    a[i][y].cun-=w;//存的剩余
                    w=0-a[i][y].cun;//看看是不是够了
                    if(w<=0)//如果够了
                    {
                        w=0;
                        a[x-1][y+1].cun+=a[x-1][y].cun;
                        a[x-1][y+1].w-=a[x-1][y].cun;
                        if(a[x-1][y+1].w<0)a[x-1][y+1].w=0;
                        a[x-1][y].cun=0;
                        break;
                    }
                    if(a[i][y].cun<0)
                    {
                        a[i][y].cun=0;
                        a[i][y].w-=w;
                        if(a[i][y].w<0)
                        {
                            a[i][y].w=0;
                        }
                    }
                }
                else if(a[i][y].w)
                {
                    a[i][y].w-=w;
                    if(a[i][y].w<0)
                    {
                        a[i][y].w=0;
                    }
                }
                if(i==1)ans+=w;
            }
        }

        for(register int i=y+1;i<=m;++i)
        {
            a[x][i].w-=w1;
            if(a[x][i].w<0)a[x][i].w=0;
            if(a[x+1][i].w||a[x+1][i].cun)
            {
                a[x][i].cun+=w1;
                break;
            }
        }
        if(x==1&&y==m)
        {
            cout<<ans<<endl;
            return;
        }
        else
        {
            if(x-1==0)
            {
                if(a[x-1][y].cun)
                {
                    a[x-1][y+1].cun+=a[x-1][y].cun;
                    a[x-1][y+1].w-=a[x-1][y].cun;
                    a[x-1][y].cun=0;
                }
                else
                {
                    a[x-1][y].cun=0;
                }
                dfs(a[n][y+1].w,n,y+1);
                return ;
            }
            else
            {
                if(a[x-1][y].cun)
                {
                    a[x-1][y+1].cun+=a[x-1][y].cun;
                    a[x-1][y+1].w-=a[x-1][y].cun;
                    if(a[x-1][y+1].w<0)a[x-1][y+1].w=0;
                    a[x-1][y].cun=0;
                }
                else
                {
                    a[x-1][y].cun=0;
                }
                dfs(a[x-1][y].w,x-1,y);
                return ;
            }
        }
    }
}
ll read(){ll x=0,f=1;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9')x=x*10+ch-'0',ch=getchar();return x*f;}
int main()
{
//	freopen("coin.in","r",stdin);
//	freopen("coin.out","w",stdout);
    cin.tie(0);
    cout.tie(0);
    cin>>t;
    while(t--)
    {
        memset(a,0,sizeof(a));
        n=read(),m=read();
        ans=0;
        for(register int i=1;i<=n;++i)
        {
            for(register int j=1;j<=m;++j)
            {
                a[i][j].w=read();
            }
        }
        dfs(a[n][1].w,n,1);
    }
	fclose(stdin);
	fclose(stdout);
    return 0;
}
```

---

## 作者：pikiuk (赞：4)

几乎所有题解都直接将这个问题等价于最小链覆盖，并没有题解给出解释，这边给出一种简单的解释：

考虑拆点，我们讲 $(i,j)$ 拆做 $a_{i,j}$ 个，这 $a_{i,j}$ 个点互不连边，而 $a_{i,j}$ 和 $(i-1,j)$ 产生的 $a_{i-1,j}$ 以及 $(i,j-1)$ 产生的 $a_{i,j-1}$ 个点连 $a_{i,j}\times a_{i-1,j}+a_{i,j}\times a_{i,j-1}$ 条边。

此时问题就等价于求新图的最小链覆盖。这个就是题意。由 Dilworth 定理这个东西容易转化成最大独立集。

然后注意到 $(i,j)$ 所产生的 $a_{i,j}$ 个点是完全等价的，也就是如果有其中一个点被加入了最大独立集，其他点也一定在最大独立集里面。所以事实上实现的时候我们并不需要真的拆点，给每个点附上一个权值然后求最大权独立集即可，然后发现这是个网格图，是 DAG，直接 DAG 上 dp 计算即可，过程同其他题解类似，不再赘述。


---

## 作者：xzjds (赞：4)

斯特林是一位神奇的人物（不认识自行百度），我在昨天做题时就遇到一题是斯特林数模板题。它可以用来求解将p个物体划分成k个非空的不可辨别的（可以理解为盒子没有编号）集合的方法。
数斯特林数有着这样的递推式：S(p,k) = k*S(p-1,k) + S(p-1,k-1) [1<= k <=p-1]而这个递推式的边界条件便是：s[i][i]=1;(i>=1)s[i][0]=0;(i>=0)
这种组合数学也许并不常用，但掌握之后不但会给许多数论题目带来思路，同时也能在某些时刻给你意想不到的惊喜。

---

## 作者：湖南省队御用绫厨TM_Sharweek (赞：3)

~~我太菜了，看了好久才会。~~

## 题目大意

给出一个 $n \times m$ 的网格图，网格图上第 $i$ 行第 $j$ 列的权值为 $a_{i,j}$。每次行动从左上角开始走，只能向右或下走。求最小的行动次数使得点 $(i,j)$ 至少被经过 $a_{i,j}$ 次。

## 题目分析

**为避免歧义，本文使用 $(x,y)$ 表示网格图中在第 $x$ 行第 $y$ 列的点，使用 $\langle u,v \rangle$ 表示有向图中一条从 $u$ 连向 $v$ 的有向边。**

这种网格图上的问题我们通常会将其转化为图上问题考虑（虽然有时不会将图建出来）。我们可以把 $(i,j)$ 看作一个图上的点，并从它到它可以到达的点连一条有向边。但这样似乎很难处理每个点至少被经过 $a_{i,j}$ 次这个条件，于是我们可以考虑建分层图，将 $(i,j)$ 拆为 $a_{i,j}$ 个点。可是这样拆点，我们会发现权值为 $0$ 的点就没有了！其实没什么关系，直接将有边连向权值为 $0$ 的点的点再加上一条连向权值为 $0$ 的点有边连向的点的边即可。也是就是说，如果 $\exists\langle u,v\rangle,\langle v,w\rangle \in E$，且 $v$ 的权值为 $0$，那么我们就可以看成原图上有一条 $\langle u,w\rangle$ 的边。然后，对于原图中的边 $\langle u,v\rangle$，如果 $u,v$ 在分层图中对应的点的集合分别为 $U,V$，那么在分层图中我们对于任意的 $u' \in U,v' \in V$，都连一条 $\langle u',v'\rangle$ 的边。建好图后，我们可以发现问题的答案正是新图中最小链覆盖（即选出最少的链使图中每个点都在至少一条链里）数。

那么，怎么求这个数呢？我们需要用到 Dilworth 定理。

Dilworth 定理断言：**偏序集上的最小链覆盖数正好等于该偏序集上的最大反链大小**。与此同时，我们还有一个和它很相似的定理，即**偏序集上的最小反链覆盖数正好等于该偏序集上的最大链大小**。

需要注意的是，这里的链和图论中的链**不完全相同**。在这里，我们定义偏序集上的链表示偏序集的一个子集，这个子集内的任意两个元素 $a$ 和 $b$ 之间都是可以比的，即要么元素 $a$ 偏序于 $b$ 要么 $b$ 偏序于 $a$。而反链恰好相反，反链表示偏序集的一个子集，这个子集内任意两个元素 $a$ 和 $b$ 之间都是不可比的，即 $a$ **不**偏序于 $b$，$b$ 也**不**偏序于 $a$。

关于 Dilworth 定理的证明，[我之前已经很多人证明过了](https://oi-wiki.org/math/order-theory/#dilworth-%E5%AE%9A%E7%90%86%E4%B8%8E-mirsky-%E5%AE%9A%E7%90%86)，所以在此不给出。

如果我们把图上 $u$ 可以直接或间接到达 $v$ 看作偏序关系（事实上这确实是偏序关系）的话，我们就会发现 Dilworth 定理陈述了这样一个事实：图中最小链覆盖数正是最大的满足集合中任意两个点之间不能直接或间接到达的点集的大小。那么怎么求这个点集的大小呢？我们发现这个分层图中最多可能有 $10^{12}$ 个点，直接把图建出来显然是行不通的。所以必须考虑其他方法。

看一眼数据范围，$1 \le n,m \le 10^3$，也就是说矩阵中最大有 $10^6$ 个元素。时间复杂度大概率是 $O(n^2)$ 或者 $O(n^2\log n)$ 的（因为 $n$ 和 $m$ 数据范围一样，此处将 $m$ 认为是与 $n$ 等价的）。这启发我们直接从矩阵上考虑如何求这个点集的大小。容易发现（真的很容易！），$(i,j)$ 这个点与 $(i-1,j+1)$ 和 $(i+1,j-1)$ 一定互相不可到达，这是因为到达这三个点走的步数必然一样。也就是说，如果点集内选择了 $(i,j)$ 那么 $(i-1,j+1),(i+1,j-1)$ 一定也可以选。而分层图中 $(i,j)$ 会拆成 $a_{i,j}$ 个点，这些点之间一定也是互相不可到达的（可以由拆点的方式看出）。更进一步的，我们发现 $(1 \sim i-1,j+1 \sim m)$ 中所有点与 $(i,j)$ 都互不可达，$(i+1 \sim n,1 \sim j-1)$ 中所有点与 $(i,j)$ 都互不可达（因为这两种情况想要可达都要么要往上走要么要往左走）。我们还能发现 $(i,j),(i-1,j),(i+1,j),(i,j-1),(i,j+1)$ 这五个点之间最多只能选一个（想想原图中我们是怎么连边的）。考虑进行 DP。我们希望 DP 的转移过程不会有环，并且 $(i,j)$ 处的答案最好不会被转移到它的部分影响。于是我们可以这样设计状态：令 $f_{i,j}$ 表示只考虑子矩形 $(1 \sim i,j \sim m)$ 时的最大的点集的大小。因为 $(1 \sim i-1,j+1 \sim m)$ 与 $(i,j)$ 都互不可达，所以在 $f_{i-1,j+1}$ 的基础上再选择 $(i,j)$ 是肯定可行并且比在此基础上不选择 $(i,j)$ 肯定更优（$0\le a_{i,j}$）。再考虑不选择 $(i,j)$ 时的答案。因为 $f_{i,j}$ 表示的是只考虑子矩形时的最优解，所以 $f_{i-1,j}$ 肯定大于等于 $f_{i-1,j+1}$。如果要大于 $f_{i-1,j+1}$，那么肯定要选择 $(1 \sim i-1,j)$ 中的至少一处的点，而这些点都与 $(i,j)$ 都可以间接或直接到达，此时就不能选择 $(i,j)$ 处的点了。而如果相等，那么我们是否考虑从 $f_{i-1,j}$ 转移也无关紧要了。$f_{i,j+1}$ 同理。所以我们就可以得出状态转移方程：$f_{i,j}=\max(f_{i-1,j},f_{i,j+1},f_{i-1,j+1}+a_{i,j})$。边界条件就是 $f_{i,0}=f_{0,j}=0$，答案则是 $f_{n,1}$（别忘了状态是怎么定义的）。

## 参考代码

```cpp
/*********************************************************************
    程序名:P3974
    版权:
    作者: TM_Sharweek
    日期: 2024-11-01 12:38
    说明:I'm the cai_est OIer
*********************************************************************/
#include <bits/stdc++.h>

#define p_b push_back
#define m_p make_pair

using namespace std;
using ll = long long;
using ull = unsigned long long;
using i128 = __int128;

const int N = 1e3 + 50;

ll a[N][N], f[N][N];

int main() {
    freopen(".in","r",stdin);
	freopen(".out","w",stdout);
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	int T;
	cin >> T;
	while (T--) {
		int n, m;
		cin >> n >> m;
		for (int i = 1; i <= n; i++) {
			for (int j = 1; j <= m; j++) {
				cin >> a[i][j];
			}
		}
		//memset(f, 0, sizeof(f));//不要忘了多测清空哦
		for (int i = 1; i <= n; i++) {
			for (int j = m; j >= 1; j--) {
				f[i][j] = max({f[i - 1][j], f[i][j + 1], f[i - 1][j + 1] + a[i][j]});
			}
		}
		cout << f[n][1];
		//cout << endl;//输出每组数据要换行
	}

	return 1;
}
``````

---

## 作者：TJmyf (赞：3)

## 这类题的正解一般是优化 DP ，但是这道题的满分做法之一是贪心

先说一下很快想到的费用流：把每个格子当作一个 $2$ 个点，分为进入点和出点，这两个点连上 $2$ 条有向边，一条流量为财宝数量，单价为 $1$ ；另一条流量为 $∞$ ，单价为 $0$ 。再把每个点的出点和右边和下边的格子的入点连分别连一条流量为 $∞$ ，单价为 $0$ 的边即可。把最左上的格子的入店当作源点，最右下的格子的入店当作汇点即可（或者再定义一个源点和汇点），注意每次求最长路是最长路的权值要 $>0$ 才继续，否则终止。~~然后就有了 30pts 的 **code**~~：

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const ll maxn=1010,inf=1e15;
ll T,n,m,a[maxn][maxn],b[maxn][maxn];
ll s,t,cnt,fir[maxn*maxn*2],Flow,Cost;
struct edge
{
	int u,v,c,next,op;
	ll w;
}e[maxn*maxn*4];
void add_edge(int u,int v,ll w,int c)
{
	cnt++,e[cnt].u=u,e[cnt].v=v,e[cnt].w=w,e[cnt].c=c,e[cnt].next=fir[u],fir[u]=cnt;
	cnt++,e[cnt].u=v,e[cnt].v=u,e[cnt].w=0,e[cnt].c=-c,e[cnt].next=fir[v],fir[v]=cnt;
	e[fir[u]].op=fir[v],e[fir[v]].op=fir[u];
}
int dis[maxn*maxn*2],pre[maxn*maxn*2];
queue<int> q;
bool inq[maxn*maxn*2];
bool spfa()
{
	memset(dis,0xbf,sizeof(dis));
	dis[s]=0,q.push(s),inq[s]=1;
	while(!q.empty())
	{
		int x=q.front();
		q.pop(),inq[x]=0;
		for(int i=fir[x];i;i=e[i].next)
		{
			if(e[i].w>0&&dis[e[i].v]<dis[x]+e[i].c)
			{
				dis[e[i].v]=dis[x]+e[i].c,pre[e[i].v]=i;
				if(!inq[e[i].v]) inq[e[i].v]=1,q.push(e[i].v);
			}
		}
	}
	return dis[t]>0;
}
void dfs()
{
	ll np=t,sc=0,mf=inf;
	while(np!=s)
	{
		mf=min(mf,(ll)(e[pre[np]].w));
		sc+=e[pre[np]].c;
		np=e[pre[np]].u;
	}
	Flow+=mf;
	Cost+=1ll*mf*sc;
	np=t;
	while(np!=s)
	{
		e[pre[np]].w-=mf;
		e[e[pre[np]].op].w+=mf;
		np=e[pre[np]].u;
	}
}
void dinic()
{
	while(spfa()) dfs();
}
int main()
{
	scanf("%lld",&T);
	while(T--)
	{
		scanf("%lld%lld",&n,&m);
		memset(fir,0,sizeof(fir));
		cnt=0,s=n*m*2+1,t=s+1,Flow=0,Cost=0;
		int pf=1;
		for(int i=1;i<=n;i++)
			for(int j=1;j<=m;j++)
				scanf("%lld",&a[i][j]),b[i][j]=pf,pf+=2;
		add_edge(s,b[1][1],inf,0);
		add_edge(b[n][m]+1,t,inf,0);
		for(int i=1;i<=n;i++)
		{
			for(int j=1;j<=m;j++)
			{
				add_edge(b[i][j],b[i][j]+1,a[i][j],1);
				add_edge(b[i][j],b[i][j]+1,inf,0);
				if(j!=m) add_edge(b[i][j]+1,b[i][j+1],inf,0);
				if(i!=n) add_edge(b[i][j]+1,b[i+1][j],inf,0);
			}
		}
		dinic();
		printf("%lld\n",Flow);
	}
	return 0;
}
```

然后考虑贪心。对于二维的问题，我们很容易想到枚举一个维度，然后用数组维护另一个维度的信息。先枚举行数，再维护 $f_j$ 代表第 $j$ 列最多能剩余多少流量给下一行，如果 $f_j≥a_{ij}$ ，就不用再做处理了。 如果 $f_j<a_{ij}$ ，就贪心地找 $f_{j-1}$ ，把它的流量流到 $f_j$ ，如果还是不够 $a_{ij}$ ，就继续向前面找。这里找完的 $f$ 的值因为流给右边的列了，就不能流给下一行了，所以要减去流到右边的值，可以用栈维护，没更新完一个点把这个点的编号放到栈顶，每次如果榨干栈顶的流量，就把它踢掉。如果栈已经空了，但仍然有 $f_j<a_{ij}$ ，就增加答案的值，把 $f_j$ 补到 $a_{ij}$ ， **code**：

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int maxn=1010;
ll T,n,m,ans,a[maxn][maxn],f[maxn],len,st[maxn];
int main()
{
	scanf("%lld",&T);
	while(T--)
	{
		scanf("%lld%lld",&n,&m);
		for(int i=1;i<=n;i++) for(int j=1;j<=m;j++) scanf("%lld",&a[i][j]);
		memset(f,0,sizeof(f));
		ans=0;
		for(int i=1;i<=n;i++)
		{
			len=0;
			for(int j=1;j<=m;j++)
			{
				if(f[j]<a[i][j])
				{
					while(len)
					{
						if(f[st[len]]+f[j]>=a[i][j])
						{
							f[st[len]]-=(a[i][j]-f[j]),f[j]=a[i][j];
							break;
						}
						else f[j]+=f[st[len]],f[st[len]]=0,len--;
					}
				}
				if(f[j]<a[i][j]) ans+=(a[i][j]-f[j]),f[j]=a[i][j];
				len++;
				st[len]=j;
			}
		}
		printf("%lld\n",ans);
	}
	return 0;
}
```


---

## 作者：FlyInTheSky (赞：2)

[$$ \Large \texttt{My Blog} $$](http://blog.flyinthesky.win/bzoj3997/)

------------

一开始觉得是上下界网络流。。范围太大了

这题是一个最小链覆盖问题，可以转化为**最长反链覆盖**。

考虑这里的反链，**我们让$x$能到$y$看作偏序关系**，然后对于$x,y$在同一反链当且仅当这两个点是右上、左下关系

那么设$dp(i,j)$为以$(i,j)$为左下角的矩形中的最长反链长。那么考虑转移

$$dp(i,j)=\max \{ dp(i-1,j), dp(i,j+1), dp(i-1, j-1)+a_{i,j} \} $$

前两个是继承关系，后一个是包含$(i,j)$的最长反链长，显然$(i,j)$和$(i-1, j-1)$在一个反链。

```c++
#include<cstdio> 
#include<cstring>
#include<algorithm>
#include<iostream>
#include<cmath>
#include<queue>
#define ms(i, j) memset(i, j, sizeof i)
#define LL long long
#define db long double
#define fir first
#define sec second
#define mp make_pair
using namespace std;

int T;

namespace flyinthesky {

    const LL MAXN = 1000 + 5;
    
    LL n, m, a[MAXN][MAXN], dp[MAXN][MAXN];

    void clean() {
    	ms(dp, 0);
    }
    int solve() {
    	
    	clean();
    	cin >> n >> m;
    	for (LL i = 1; i <= n; ++i)
    	for (LL j = 1; j <= m; ++j) scanf("%lld", &a[i][j]);
    	
    	for (LL i = 1; i <= n; ++i) {
    		for (LL j = m; j >= 1; --j) {
    			dp[i][j] = max(dp[i - 1][j], max(dp[i][j + 1], dp[i - 1][j + 1] + a[i][j]));
            }
        }
        cout << dp[n][1] << endl;

        return 0;
    }
}
int main() { 
    cin >> T;
    while (T--) flyinthesky::solve();
    return 0;
}
```

---

## 作者：KAMIYA_KINA (赞：2)

## Tag

$\text{Dilworth}$ 定理。

## Description

给一个 $n\times m$ 的网格图，每一个格子有若干物品，每次可以向下或者向右走一步，一次可以拿走格子里的一个物品，求多少次才能拿完所有物品。

$\texttt{data range:} n,m\leq 10^3$

## Solution

这题就是要我们求最小链覆盖，然后根据 $\text{Dilworth}$ 定理转化为最长反链，从与其一定没有偏序关系的点 $(i-1,j+1)$ 转移过来，然后一直向右下转移。

但是这样不正确，我们只考虑了转移反链的从右上转移到当前的转移，但是没有考虑右右上或者其他与当前没有偏序关系的点到当前的转移，所以我们需要将 $(i-1,j)$ 和 $(i,j+1)$ 的答案先整理到当前点然后处理，这样就是对的了。

时间复杂度 $O(nm)$.

## Code

```cpp
const int N = 1e3 + 2;

int g[N][N], f[N][N], n, m;

inline void input() {
    n = rd, m = rd;
    FOR(i, 1, n) FOR(j, 1, m) g[i][j] = rd;
    return ;
}

inline void work() {
    FOR(i, 1, n) ROF(j, m, 1) {
        f[i][j] = f[i - 1][j + 1] + g[i][j];
        cmax(f[i][j], f[i - 1][j]);
        cmax(f[i][j], f[i][j + 1]);
    }
    cout << f[n][1] << '\n';
    return ;
}

inline void solve() {
    int t = rd;
    while(t--) {
        input();
        work();
    }
    return ;
}
```



---

## 作者：wurzang (赞：2)

菜鸡不会 Dilworth 定理，所以来交个线性规划题解。

将问题描述成线性规划

$$
\begin{array}{cc}
\min & \sum_{S} x_S\\
\operatorname{s.t.}
& \left(\sum_{S\ni i} x_S\right) \ge a_i\\
& x_S\geq 0
\end{array}
$$

对偶一下就是

$$
\begin{array}{cc}
\max & \sum_{i} a_iy_i \\
\operatorname{s.t.}
& \left(\sum_{i\in S} y_i\right) \le 1\\
& y_i\geq 0
\end{array}
$$

上面那个问题可以看做给若干个点赋予一个 $0/1$ 的权值，要求每条路径包含的权值不能大于 $1$，且权值与 $a_i$ 的乘积之和最大。

发现这个问题很像最大独立集的样子....所以直接求最大独立集即可。

---

## 作者：封禁用户 (赞：1)

既然题目叫《组合数学》，当然要用**组合数学**啦！

这题可以应用组合数学中的 Dilworth 定理，结合动态规划思想，求解最大独立集问题。题目给定一个权值矩阵，我们需要从中选取一些点，使得这些点两两不可达且权值和最大。

Dilworth 定理指出，在一个偏序集合中：
- 最大反链的大小等于最小链覆盖的大小。
- 同时，最大反链的大小也等于最大独立集的大小。

在本题中，我们的目标是构造一个最大独立集，即选择一组点，使得这些点之间没有直接的达到关系（以左下减右上的关系为标准）。为了解决该问题，我们可以使用动态规划。

我们定义 $dp[i][j]$ 表示从 $(1, m)$ 到 $(i, j)$ 的最大权值和，且 $(i, j)$ 不能和 $(i−1, j+1)$ 同时被选取。

所以，状态转移方程大体如下：
- 如果不选 $(i, j)$，我们考虑 $(i-1, j)$ 和 $(i, j+1)$ 的值。
- 如果选取 $(i, j)$，则将其对应的权值 $g[i][j]$ 加入。

因此，状态转移方程为：
$$
dp[i][j] = \max(dp[i-1][j+1] + g[i][j], dp[i-1][j], dp[i][j+1])
$$

## Code

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <cstring>

using namespace std;

long long dp[1005][1005];
long long g[1005][1005];

int main() 
{
	int t;
	cin >> t;
	while (t--) {
		int n, m;
		cin >> n >> m;

		for (int i = 1; i <= n; i++) {
			for (int j = 1; j <= m; j++) {
				cin >> g[i][j];
			}
		}

		memset(dp, 0, sizeof(dp));

		for (int i = 1; i <= n; i++) {
			for (int j = m; j >= 1; j--) {
				dp[i][j] = max(dp[i - 1][j + 1] + g[i][j], max(dp[i - 1][j], dp[i][j + 1]));
			}
		}

		cout << dp[n][1] << '\n';
	}

	return 0;
}
```

---

## 作者：liruixiong0101 (赞：1)

[P3974 [TJOI2015] 组合数学](https://www.luogu.com.cn/problem/P3974)

> 现有一个 $n\times m$ 的网格图，$(i,j)$ 网格上有 $a_{i,j}\in[0,10^6]$ 个财宝，你可以从 $(1,1)$ 走到 $(n,m)$，每一次走可以将路径上的每一个点的财报数量减一（若是负数则不变），求你最少需要走多少次，才能将网格图上的所有财宝捡完。

这是一道最小链覆盖问题，考虑使用狄尔沃斯定理，我们需要定义一种偏序关系使得这种偏序关系中的链是 $(1,1)$ 到 $(n,m)$ 的一条路径，且偏序关系是合法的。

由于一条从 $(1,1)$ 到 $(n,m)$ 的一条路径，那么路径中的每一个点的横坐标与纵坐标都单调不降，所以考虑偏序关系 $(x_1,y_1)\preceq (x_2,y_2)\Longleftrightarrow x_1\le x_2\;\wedge y_1\le y_2$ 定义在可重集合 $S$，$S$ 中包含 $a_{i,j}$ 个 $(i,j)$，容易证明这样的偏序关系是合法的。由于这种偏序关系的自反性，所以链并不是每次取一个财宝，而是可以取多个，这样与题意不符，需要另找偏序关系使其满足每一个元素都不重复。

定义这样一个偏序关系 $(x_1,y_1)\preceq (x_2,y_2)\Longleftrightarrow x_1\le x_2\;\wedge y_1\le y_2\;\wedge (x_1,y_1)\neq(x_2,y_2)$，其定义在集合 $S$ 中，$S$ 包含 $a_{i,j}$ 个 $(i,j,k)(k\in[1,a_{i,j}])$，但是这样不满足自反性，所以将其改成 $(x_1,y_1,z_1)\preceq (x_2,y_2,z_2)\Longleftrightarrow (x_1,y_1,z_1)=(x_2,y_2,z_2)\vee(x_1\le x_2\;\wedge y_1\le y_2\;\wedge (x_1,y_1)\neq(x_2,y_2))$（越来越抽象），这样的偏序关系既合法，又符合本题中的链。

由于最小链覆盖等于最长反链长度，所以考虑反链是什么。如果两个元素 $(x_1,y_1,z_1)$ 与 $(x_2,y_2,z_2)$（不妨设 $x_1\le x_2$）不可比，那么 $(x_1,y_1,z_1)$ 一定不等于 $(x_2,y_2,z_2)$，其次要满足 $y_1>y_2$，而且可以重复选择 $(x,y,a)$ 和 $(x,y,b)$，反链用文字表述为：从左下角往右上角走，保证路径中的任意点不相邻，且路径上的点的行数单调递减，列数单调递增，反链的长度即为路径上所有点的财宝数和。

接下来的事情就简单了，我们可以用 dp 解决。设 $f_{i,j}$ 表示选到 $(i,j)$ 的最大链长，那么就有转移式：

$$
f_{i,j}=\max\{\max_{k<i,l<j}f_{k,l}+a_{i,j},\max_{k\le i,l\le j,(k,l)\neq(i,j)}f_{k,l}\}
$$

可以从不可比的元素中转移并加上该权值，也可以不加该权值从任何地方转移。

显然 $\displaystyle\max_{k<i,l<j}f_{k,l}=f_{i-1,j-1},\max_{k\le i,l\le j,(k,l)\neq(i,j)}f_{k,l}=\max\{f_{i-1,j},f_{i,j-1}\}$，所以最终的转移式为：

$$
f_{i,j}=\max\{f_{i-1,j},f_{i,j-1},f_{i-1,j-1}+a_{i,j}\}
$$

（其实可以直接从这里看，也很好理解）

这题就做完了。

---

作者是蒟蒻，题解写的可能很麻烦，请谅解。

---

## 作者：大菜鸡fks (赞：1)

这题是最小链覆盖。

最小链覆盖=最大独立集。

这题只能向右下走。那么最大独立集就很显然了————可以用dp求出

```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
inline int read(){int x=0,f=1,ch=getchar(); while(ch<'0'||ch>'9'){if(ch=='-') f=-1; ch=getchar();} while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();} return x*f;}
inline void write(int x){if (x<0) putchar('-'),x=-x; if (x>=10) write(x/10); putchar(x%10+'0');}
inline void writeln(int x){write(x); puts("");}
const int N=1005;
int n,m,a[N][N];
inline void init(){
	n=read(); m=read();
	for (int i=1;i<=n;i++){
		for (int j=1;j<=m;j++){
			a[i][j]=read();
		}
	}
}
int dp[N][N];
inline void solve(){
	memset(dp,0,sizeof(dp));
	for (int i=1;i<=n;i++){
		for (int j=m;j;j--) {
			dp[i][j]=max(dp[i][j+1],dp[i-1][j+1]+a[i][j]);
			dp[i][j]=max(dp[i][j],dp[i-1][j]);
		}
	}
	writeln(dp[n][1]);
}
int main(){
	int T=read();
	while (T--){
		init();
		solve(); 
	}
	return 0;
} 
```

---

## 作者：船酱魔王 (赞：0)

## 题意回顾

方格上每个位置有一些棋子，每次左上到右下，每个格子每次最多拿一个，请问走多少次实现全收集？

网格长宽不超过 $ 1 \times 10^3 $，单测试点内最多二组测试数据。

## 分析

考虑走多少次想到序集覆盖问题。

考虑定义序集，序集为两个棋子可以在到达一个后到达下一个，即两个棋子不在同一个格子，且棋子一的两维坐标都小于等于棋子二，则称棋子一在序集上偏序于棋子二。

而链，就是一些棋子，第一个偏序第二个，第二个偏序第三个......，可以发现链的定义与一次行走等价，而覆盖所有棋子自然对应最小链覆盖。

序集满足性质：

* 无自环，即自己不偏序自己。
* 偏序关系有传递性
* 偏序关系倒过来不成立。

这一集合适用于 Dilworth 定理（偏序集视为 DAG 后，最小链覆盖等于反链），考虑用反链长度作为答案。

考虑反链的性质，当两个棋子视为反链上的两个点，意味着它们无偏序关系（一个到不了另一个），即满足两个棋子不能互相到达，而两个棋子同在某条反链上，当且仅当：

* 两个棋子横坐标小的纵坐标大。
* 两个棋子重合。

考虑重合的棋子同时取，而所有反链上互不重合的棋子若按照纵坐标排序则横坐标严格递减，则此时转移有了方向（左下），则一个格子要么全进入反链，要么全不进入反链，一个格子进入了反链下一个格子只能是左下，之前的只能是右上，而从右上往左下转移即可。

考虑怎么优化距离较远的格子的转移，用类似于前缀和优化的手段即可。

## AC 代码

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;
const int N = 1005;
int T;
int n, m;
int a[N][N];
int dp[N][N];
int main() {
	scanf("%d", &T);
	for(int ti = 1; ti <= T; ti++) {
		scanf("%d%d", &n, &m);
		for(int i = 1; i <= n; i++) {
			for(int j = 1; j <= m; j++) {
				scanf("%d", &a[i][j]);
			}
		}
		memset(dp, 0, sizeof(dp));
		for(int i = 1; i <= n; i++) {
			for(int j = m; j >= 1; j--) {
				dp[i][j] = max(dp[i - 1][j + 1] + a[i][j], max(dp[i - 1][j], dp[i][j + 1]));
			}
		}
		cout << dp[n][1] << endl;
	}
	return 0;
}
```

---

## 作者：YangJZHello (赞：0)

# 题意
有一个 $n$ 行 $m$ 列的网格图，图上的任意位置 $(i,j)$ 有一个权值 $a_{ij}$，从左上角出发，只能往右或下走。当经过某个位置时，若该位置的权值大于零，则权值减一。问至少要走几次才可以使所有权值归零。

# 数据范围
$1\leq n,m\leq1000,0\leq a_{ij}\leq10^6$。

# 思路
由于只能往右或下走，容易想到权值不为零的位置（可重复）可以组成严格偏序集，那么总共走的次数即为该偏序集的最小链覆盖数，由 Dilworth 定理可知，所求即为偏序集的宽度（最长反链长度，如果没听说过的话可以移步[这里](https://oi-wiki.org/math/order-theory/#dilworth-%E5%AE%9A%E7%90%86%E4%B8%8E-mirsky-%E5%AE%9A%E7%90%86)）。

考虑 DP，设 $f_{i,j}$ 表示从 $(i,j)$ 到 $(1,m)$ 这个子网格上的最长反链长度。对于某个位置 $(i,j)$，由于与 $(i-1,j),(i,j+1)$ 连通，而与 $(i-1,j+1)$ 不连通，可以列出状态转移方程：
$$
f_{i,j}=\max(f_{i-1,j},f_{i,j+1},f_{i-1,j+1}+a_{ij})
$$
边界：
$$
f_{1,m}=a_{1,m}\\
f_{0,y}=f_{x,m+1}=0
$$
则答案为 $f_{n,1}$。时间复杂度为 $\mathcal O(mn)$。

# 参考代码
```cpp
#include <iostream>
#include <cstring>
#include <cmath>

#define il inline
#define st static
#define re register
#define rep(i, s, t) for(re int i=s; i<=t; ++i)
#define arep(i, s, t) for(re int i=s; i>=t; --i)

const int MAXN=1e3+3;

int n, m;
long long a[MAXN][MAXN], f_m[MAXN][MAXN];

long long f(re int x, re int y) {
    return (x<=0||y>m)?
        0:
        (f_m[x][y]?
            f_m[x][y]:
            f_m[x][y]=std::max(std::max(f(x-1, y), f(x, y+1)), f(x-1, y+1)+a[x][y])
        );
    }

il void sol() {
    std::memset(f_m, 0, sizeof(f_m));
    std::cin >> n >> m;
    rep(i, 1, n) rep(j, 1, m) std::cin >> a[i][j];
    f_m[1][m] = a[1][m];
    return std::cout << f(n, 1) << '\n', void();
}

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);

    re int t; std::cin >> t;
    while(t--) sol();

    return 0;
}
```

---


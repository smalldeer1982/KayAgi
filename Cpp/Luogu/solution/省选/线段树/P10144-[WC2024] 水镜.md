# [WC2024] 水镜

## 题目描述

**提示**：我们在题目描述的最后提供了一份简要的、形式化描述的题面。

A 城是一座多雨的城市，山溪泉水众多。出于对水的喜爱，市民们在城市中央修建了一座大喷泉。

喷泉的水池中有一排 $n$ 个石柱，从左到右编号为 $1, 2, \cdots , n$，第 $i$ 个石柱的高度为 $h_i$。水池中有储水，水位 $L$ 为一个**正实数**。第 $i$ 个石柱会产生一个高度为 $h'_i = 2L - h_i$ 的像。若石柱在水面上方，像在水面下方；若石柱在水面下方，像在水面上方；若石柱顶端与水面重合，则像也与水面重合。

传说水中栖息着泉水精灵，每到满月之夜，它们就会在石柱上起舞，行动规则如下：

- 泉水精灵只能栖息在石柱顶端，或者石柱的像的顶端。即如果泉水精灵在石柱 $u$ 上，它的高度 $r_u$ 便只有 $h_u, h'_u$ 两种可能取值。
- 泉水精灵每次只能前往右侧相邻的石柱（或石柱的像）。
- 在移动过程中，泉水精灵的高度必须**严格单调递增**。

泉水精灵会选择一个石柱（或石柱的像）为起点，进行若干次移动后停止。这样的过程称为一次**舞蹈**。

A 城的雨季漫长，由于不规律的降雨，喷泉的水位可能会多次变化，舞蹈路径的可能性也随之改变。作为远道而来的旅人，你很想知道有多少种舞蹈是可能实现的。具体地，你需要计算有多少对 $(u, v)$（$1 ≤ u < v ≤ n$），满足存在一种水位 $L$，使得泉水精灵在一次舞蹈中，能从第 $u$ 个石柱（或它的像）出发，到达第 $v$ 个石柱（或它的像）。

**形式化的**：给定一个长度为 $n$ 的正整数序列 $h_1, h_2,\cdots , h_n$，求满足以下所有条件的
二元组 $(u, v)$ 的数量：
- $1 \le u < v \le n$，且 $u, v$ 为整数；
- 存在一个**正实数** $L$ 以及一个长度为 $(v - u + 1)$ 的序列 $r_u, r_{u+1},\cdots , r_v$ 满足以下
所有条件：
- $\forall u \le i \le v$，记 $h'_i = 2L - h_i$，则 $r_i \in \{h_i,h'_i\}$，特别地，当 $h_i = h'_i$ 时，$r_i = h_i$；
- $\forall u \le i < v, r_i < r_{i+1}$。


## 说明/提示

**样例 1 解释**

所有 $\binom{4}{2}=6$ 种 $(u, v)$ 都是可行的。
对于 $u = 1, v = 4$，可以选择 $L = 2.5$，则序列 $h'$
 为 $\{4, 2, 3, 1\}$，取序列 $r$ 为 $\{1, 2, 3, 4\}$
可以满足所有条件。

### 数据范围

对于所有测试数据：

- $2\le n\le 5\times 10^5$，
- $\forall 1\le i\le n,1\le h_i\le 10^{12}$。

| 测试点编号 | $n\le$ |
| :----------: | :----------: |
| $1\sim 2$ | $10$ |
| $3\sim 4$ | $100$ |
| $5\sim 6$ | $400$ |
| $7\sim 11$| $4000$ |
| $12\sim 13$ | $5\times 10^4$ |
| $14\sim 16$ | $10^5$ |
| $17\sim 19$ | $2\times 10^5$ |
| $20\sim 25$ | $5\times 10^5$ |


## 样例 #1

### 输入

```
4
1 3 2 4```

### 输出

```
6```

# 题解

## 作者：EuphoricStar (赞：30)

WC2024 被打爆了，呜呜。我赛时会这题 $8$ 分指数级暴力，哈哈。真不知道自己在干嘛。

下文令 $T = 2L$。

考虑如何判定一个序列 $a$ 是否合法。考虑先枚举一个 $T$。因为要求 $r_i < r_{i + 1}$，考虑讨论相邻两项的取值：

- 若 $a_i < a_{i + 1}$ 则 $r_i = a_i, r_{i + 1} = a_{i + 1}$ 可行，也就是若 $a_i \ge a_{i + 1}$ 则 $r_i = a_i, r_{i + 1} = a_{i + 1}$ **不**可行；
- 若 $a_i > a_{i + 1}$ 则 $r_i = T - a_i, r_{i + 1} = T - a_{i + 1}$ 可行，也就是若 $a_i \le a_{i + 1}$ 则 $r_i = T - a_i, r_{i + 1} = T - a_{i + 1}$ **不**可行；
- 若 $a_i + a_{i + 1} < T$ 则 $r_i = a_i, r_{i + 1} = T - a_{i + 1}$ 可行，也就是若 $a_i + a_{i + 1} \ge T$ 则 $r_i = a_i, r_{i + 1} = T - a_{i + 1}$ **不**可行；
- 若 $a_i + a_{i + 1} > T$ 则 $r_i = T - a_i, r_{i + 1} = a_{i + 1}$ 可行，也就是若 $a_i + a_{i + 1} \le T$ 则 $r_i = T - a_i, r_{i + 1} = a_{i + 1}$ **不**可行。

也就是说：

- 若 $a_i \le a_{i + 1}$ 且 $a_i + a_{i + 1} \le T$ 则 $r_i$ 必须取 $a_i$；
- 若 $a_i \le a_{i + 1}$ 且 $a_i + a_{i + 1} \ge T$ 则 $r_{i + 1}$ 必须取 $a_{i + 1}$；
- 若 $a_i \ge a_{i + 1}$ 且 $a_i + a_{i + 1} \le T$ 则 $r_{i + 1}$ 必须取 $T - a_{i + 1}$；
- 若 $a_i \ge a_{i + 1}$ 且 $a_i + a_{i + 1} \ge T$ 则 $r_i$ 必须取 $T - a_i$。

若这个序列不存在一组 $r$ 则一定能从上述四个条件得出矛盾。有三种矛盾：

1. $a_i = a_{i + 1}, a_i + a_{i + 1} = T$；
2. $a_{i - 1} \le a_i, a_{i - 1} + a_i \ge T, a_i \ge a_{i + 1}, a_i + a_{i + 1} \ge T$；
3. $a_{i - 1} \ge a_i, a_{i - 1} + a_i \le T, a_i \le a_{i + 1}, a_i + a_{i + 1} \le T$。

考虑不枚举 $T$ 怎么判合法性。考虑第二种矛盾，相当于若存在 $i$ 使得 $a_{i - 1} \le a_i, a_i \ge a_{i + 1}$，那么 $T > \min(a_{i - 1} + a_i, a_i + a_{i + 1})$，否则就会产生矛盾；类似地考虑第三种矛盾，若存在 $i$ 使得 $a_{i - 1} \ge a_i, a_i \le a_{i + 1}$，那么 $T < \max(a_{i - 1} + a_i, a_i + a_{i + 1})$。

也就是说对于一些位置有 $T \in (l_i, r_i)$ 的限制，若最后这些区间交出来不是空集（即 $\max l_i < \min r_i$）那么就合法。这时候发现第一种矛盾不需要考虑，因为若区间交出来不是空集则 $T$ 有无限个取值。

回到原题，考虑计算合法的子区间个数。发现对于一个左端点，合法的右端点一定是一段区间。直接二分右端点再判定即可。判定就是判区间 $\max l_i$ 是否 $< \min r_i$。

总时间复杂度 $O(n \log n)$。

```cpp
// Problem: P10144 [WC/CTS2024] 水镜
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P10144
// Memory Limit: 512 MB
// Time Limit: 1000 ms
// 
// Powered by CP Editor (https://cpeditor.org)

#include <bits/stdc++.h>
#define pb emplace_back
#define fst first
#define scd second
#define mkp make_pair
#define mems(a, x) memset((a), (x), sizeof(a))

using namespace std;
typedef long long ll;
typedef double db;
typedef unsigned long long ull;
typedef long double ldb;
typedef pair<ll, ll> pii;

const int maxn = 500100;
const int logn = 22;

ll n, a[maxn], f[logn][maxn], g[logn][maxn];

inline ll qmax(int l, int r) {
	int k = __lg(r - l + 1);
	return max(f[k][l], f[k][r - (1 << k) + 1]);
}

inline ll qmin(int l, int r) {
	int k = __lg(r - l + 1);
	return min(g[k][l], g[k][r - (1 << k) + 1]);
}

void solve() {
	scanf("%lld", &n);
	for (int i = 1; i <= n; ++i) {
		scanf("%lld", &a[i]);
	}
	for (int i = 2; i < n; ++i) {
		f[0][i] = -1e18;
		g[0][i] = 1e18;
		if (a[i - 1] <= a[i] && a[i] >= a[i + 1]) {
			f[0][i] = min(a[i - 1] + a[i], a[i] + a[i + 1]);
		}
		if (a[i - 1] >= a[i] && a[i] <= a[i + 1]) {
			g[0][i] = max(a[i - 1] + a[i], a[i] + a[i + 1]);
		}
	}
	for (int j = 1; (1 << j) <= n; ++j) {
		for (int i = 1; i + (1 << j) - 1 <= n; ++i) {
			f[j][i] = max(f[j - 1][i], f[j - 1][i + (1 << (j - 1))]);
			g[j][i] = min(g[j - 1][i], g[j - 1][i + (1 << (j - 1))]);
		}
	}
	ll ans = 0;
	for (int i = 1; i < n; ++i) {
		int l = i + 1, r = n, p = -1;
		while (l <= r) {
			int mid = (l + r) >> 1;
			if (mid - i <= 1 || qmax(i + 1, mid - 1) < qmin(i + 1, mid - 1)) {
				p = mid;
				l = mid + 1;
			} else {
				r = mid - 1;
			}
		}
		ans += p - i;
	}
	printf("%lld\n", ans);
}

int main() {
	int T = 1;
	// scanf("%d", &T);
	while (T--) {
		solve();
	}
	return 0;
}

```


---

## 作者：command_block (赞：22)

## 算法一：$\tilde O\big(2^n\big)$

枚举 $\binom{n}{2}$ 组 $u,v$，再枚举 $r_u\sim r_v$ 的 $2^{v-u+1}$ 种选择，判断是否存在一种选择满足 $r_u<r_{u+1}<\cdots<r_v$。

复杂度 $\tilde O\big(2^n\big)$，可以通过测试点 $1\sim 2$，期望得分 $8$。

## 算法二：$O\big(n^3\big)$

建立图论模型：对所有 $1\leq i\leq n$，在平面直角坐标系上标记点 $(i,h_i)$ 和 $(i,2L-h_i)$，共 $2n$ 个点。对于两个被标记的点 $p_1=(x_1,y_1)$，$p_2=(x_2,y_2)$，若满足 $x_2=x_1+1$ 且 $y_1<y_2$，则连接有向边 $p_1\to p_2$ 。本质上，我们想探究这张有向图的可达性。

点 $(i,h_i)$ 是固定不动的，点 $(i,2L-h_i)$ 会随着 $L$ 的变化而运动，相邻层之间的连边有 $O(1)$ 种可能的情况，每种情况生效的 $L$ 都是一个区间。

于是，我们可以将 $L$ 的可能取值划分为 $O(n)$ 个区间，每个区间内，有向图的结构都不变。

对于确定的图，简单 $O\big(n^2\big)$ 搜索（或递推）即可求出所有好对子，总复杂度 $O\big(n^3\big)$。

复杂度 $O\big(n^3\big)$，可以通过测试点 $1\sim 6$，期望得分 $24$。

## 算法三：$O\big(n^2\big)$

沿用算法二的思路，对 $L$ 分段讨论。

对于确定的图，按 $x$ 坐标从左往右 DP，记 $l_u$ 为在点 $u$ 结束的路径出发点 $x$ 坐标的最小值，转移显然。所有的 $l$ 可以 $O(n)$ 求出。

记 $u_i=(i,h_i)$，$u_i'=(i,2L-h_i)$，$s_i=\min(l_{u_i},l_{u'_i})$，则 $(s_i,i),(s_i+1,i),\dots,(i-1,i)$ 都是好对子。

对每个 $i$ 记录 $s_i$ 的最小值，则好对子总数为 $\sum_{i=1}^ni-s_i$。

复杂度 $O\big(n^2\big)$，可以通过测试点 $1\sim 11$，期望得分 $44$。

## 算法四：$O(n\log n)$

记 $p_i=\max(h_i,2L-h_i)$，存在符合题意的 $r_{u\sim v}$ 当且仅当：存在 $t\in\{u\sim v-1\}$，使得 $p_{u\sim t}$ 严格递减，$p_{t+1\sim v}$ 严格递增。$p_t,p_{t+1}$ 之间是等号、不等号都可以。

形式化地，我们想要的是 $p_u>p_{u+1}>\dots>p_t\ ?\ p_{t+1}<\dots< p_v$。

让 $L$ 从小到大增加，$p$ 之间的不等号会逐个改变，可以用 `std::set` 维护合法的极长“$\textsf{> > > ? < < <}$”区间。区间每次变化时（注意，可能有多个不等号同时变化），记下新的区间 $(l_i,r_i)$，使用单调栈求出所有区间的下包络，容易求出子区间总数。

复杂度 $O(n\log n)$，期望得分 $100$。

## 算法五：$O(n\log n)$

延续算法四的思路，$p_u>p_{u+1}>\dots>p_t\ ?\ p_{t+1}<\dots< p_v$ 可以转化为 $p_u\sim p_v$ 中不存在 $p_{i-1}\leq p_i\geq p_{i+1}$。

考虑水位变化给 $p$ 带来的影响。我们只关心相邻的 $p_i,p_{i+1}$ 的相对大小，不妨设 $h_i>h_{i+1}$，分类讨论可知

- 当 $L<\frac{h_i+h_{i+1}}{2}$ 时，$p_i>p_{i+1}$
- 当 $L>\frac{h_i+h_{i+1}}{2}$ 时, $p_i< p_{i+1}$
- 当 $L=\frac{h_i+h_{i+1}}{2}$ 时，$p_i=p_{i+1}$

另一种情况类似。

对于每个 $i$，“不存在 $p_{i-1}\leq p_i\geq p_{i+1}$”都对 $L$ 提出一个约束，形如“$L$ 不属于某区间”。

现在问题就转化成，给出 $N=n-1$ 个区间 $I_1,I_2,\dots,I_N$，求有多少对 $l,r$ 满足 $I_l\sim I_r$ 的并不是全集。

考虑用扫描线解决，枚举 $r$，我们要找到所有符合题意的 $l$。

先离散化，每次 $r$ 右移，新加入一个区间 $I_r$，将数组 $o$ 的区间 $I_r$ 赋值为 $r$。这样，数组 $o$ 中的最小值 $x_0$ 就是最薄弱的位置，$l\leq x_0$ 时能覆盖全集，$l>x_0$ 时不能。

（或者用双指针解决）复杂度 $O(n\log n)$，期望得分 $100$。

## 算法六：$O(n)$

延续算法五的思路，仍然求有多少对 $l,r$ 满足 $I_l\sim I_r$ 的并不是全集。

这些区间具有特殊性，通过复杂的讨论可以发现，$I_l\sim I_r$ 的并中至多有三个独立的区间，于是信息可以 $O(1)$ 储存与合并。

使用不可删双指针即可做到 $O(n)$。

参考实现：

- $O(n\log n)$

```cpp
#include <bits/stdc++.h>
#define ll long long
#define MaxN 500500
using namespace std;
int a[1<<22|50],wfl,wfr,wfc;
void cov(int l,int r,int u)
{
	if (wfl<=l&&r<=wfr){a[u]=wfc;return ;}
	int mid=(l+r)>>1;
	if (wfl<=mid)cov(l,mid,u<<1);
	if (mid<wfr)cov(mid+1,r,u<<1|1);
	a[u]=max(a[u],min(a[u<<1],a[u<<1|1]));
}
int n,tn;
ll h[MaxN],x[MaxN<<1];
int main()
{
  scanf("%d",&n);
  if (n<=2){puts("1");return 0;}
	for (int i=1;i<=n;i++){scanf("%lld",&h[i]);assert(h[i]>0);h[i]*=4;}
	for (int i=1;i<n;i++)x[i]=(h[i]+h[i+1])/2;
	sort(x+1,x+n);
	tn=unique(x+1,x+n)-x-1;
  int sav=tn; 
	for (int i=1;i<sav;i++)
	  if (x[i]+1!=x[i+1])x[++tn]=x[i]+1;
	x[++tn]=x[1]-1;x[++tn]=x[sav]+1;
	sort(x+1,x+tn+1);
	tn=unique(x+1,x+tn+1)-x-1;
	ll ans=1ll*n*(n-1)/2;
	for (int i=2;i<n;i++){
		ll l1,r1,l2,r2;
		if (h[i-1]==h[i]){l1=x[1];r1=x[tn];}
		else if (h[i-1]<h[i]){l1=x[1];r1=(h[i-1]+h[i])/2;}
		else {l1=(h[i-1]+h[i])/2;r1=x[tn];}
		if (h[i]==h[i+1]){l2=x[1];r2=x[tn];}
		else if (h[i]<h[i+1]){l2=(h[i]+h[i+1])/2;r2=x[tn];}
		else {l2=x[1];r2=(h[i]+h[i+1])/2;}
		wfl=lower_bound(x+1,x+tn+1,max(l1,l2))-x;
		wfr=lower_bound(x+1,x+tn+1,min(r1,r2))-x;
		if(wfl<=wfr){wfc=i-1;cov(1,tn,1);}
		ans-=a[1];
	}
	printf("%lld\n",ans);
  return 0;
}
```

- $O(n)$

```cpp
#include <bits/stdc++.h>
#define ll long long
#define MaxN 500500
using namespace std;
const ll INF=10000000000000ll;
struct Data{
  ll l0,l,r,r0;
  bool chk(){return l0+1<r0;}
};
const Data _E=(Data){0,0,0,INF};
Data operator + (const Data &A,const Data &B)
{
	Data C=_E;
	C.l0=max(A.l0,B.l0);
	C.r0=min(A.r0,B.r0);
	bool flA=0,flB=0; 
	if (C.l0>=A.l){C.l0=max(C.l0,A.r);flA=1;}
	if (C.l0>=B.l){C.l0=max(C.l0,B.r);flA=1;}
	if (C.r0<=A.r){C.r0=min(C.r0,A.l);flB=1;}
	if (C.r0<=B.r){C.r0=min(C.r0,B.l);flB=1;}
	if (!(A.r<B.l||B.r<A.l)){
		C.l=min(A.l,B.l);
		C.r=max(A.r,B.r);
	}else {
		assert(flA||flB);
		if (!flA){C.l=A.l;C.r=A.r;}
		else {C.l=B.l;C.r=B.r;}
	}
	return C;
}
int n;
ll h[MaxN];
Data a[MaxN],sl[MaxN],sr[MaxN];
int main()
{
	scanf("%d",&n);
  if (n<=2){puts("1");return 0;}
	for (int i=1;i<=n;i++){scanf("%lld",&h[i]);h[i]*=4;}
	for (int i=2;i<n;i++){
		ll l1,r1,l2,r2,L,R;
		if (h[i-1]==h[i]){l1=0;r1=INF;}
		else if (h[i-1]<h[i]){l1=0;r1=(h[i-1]+h[i])/2;}
		else {l1=(h[i-1]+h[i])/2;r1=INF;}
		if (h[i]==h[i+1]){l2=0;r2=INF;}
		else if (h[i]<h[i+1]){l2=(h[i]+h[i+1])/2;r2=INF;}
		else {l2=0;r2=(h[i]+h[i+1])/2;}
		L=max(l1,l2);R=min(r1,r2);
		if (L==0)a[i]=(Data){R,0,0,INF};
		else if (R==INF)a[i]=(Data){0,0,0,L};
		else if (L<=R)a[i]=(Data){0,L,R,INF};
		else a[i]=_E;
	}
	ll ans=0;int mid=2,r=1;
	sl[2]=_E;sr[1]=_E;
	for (int l=2;l<n;l++){
		if (r<l)r=l-1;
		if (l>mid){
			mid=r;
			sr[r]=sl[r+1]=_E;
			for (int i=r;i>=l;i--)
			  sl[i]=sl[i+1]+a[i];
		}
		while(r<n&&(sl[l]+sr[r]+a[r+1]).chk()){
			sr[r+1]=sr[r]+a[r+1];
			r++;
		}
		ans+=r-l+1;
	}
	printf("%lld",ans+n-1);
  return 0;
}
```

---

## 作者：yuanruiqi (赞：11)

感谢本题赠予的 $100pts$ 让我混了个 Ag。

### 算法一

注意到每一次跳跃只需要关心 $h_i,2L-h_i,h_{i-1},2L-h_{i-1}$ 的相对大小关系，若两个 $L$ 的值对任意 $i$ 的上式关系不会有影响，则称它们是本质相同的。

枚举所有本质不同 $L$ 暴力计算，复杂度 $O(n^3)$，难以优化。

### 算法二

考虑一个二元组 $(u,v)$ 满足条件时，合法的 $L$ 的取值，注意到它是一段区间。

显然可以区间 DP。设 $f_{l,r,0/1}$ 为二元组 $(l,r)$ 满足条件，且 $r$ 点位于 $h_i$ 或 $2L-h_i$，$L$ 可以取值的范围。不妨用 $\&$ 和 $|$ 表示区间交和并。转移有

$$f_{l,r,0} = f_{l,r-1,1} \ \& \  (-\infty,\frac{h_{i-1}+h_{i}}{2})$$

$$f_{l,r,1} = f_{l,r-1,0} \ \& \ (\frac{h_{i-1}+h_i}{2},+\infty)$$

另外当 $h_{i-1}\lt h_i$ 时可以给 $f_{l,r,0}$ 并上 $f_{l,r-1,0}$；$h_{i-1}\gt h_i$ 时可以给 $f_{l,r,1}$ 并上 $f_{l,r-1,1}$。不难发现若 $h$ 连续出现 $3$ 次相同数字，$f_{l,r,0/1}$ 会成为空集，不影响正确性。

实现是可以将 DP 最高维消去，空间复杂度 $O(n)$，时间复杂度 $O(n^2)$ 但是可以当 DP 到空集时主动退出，可以通过纯随机数据，听说能多拿 $4$ 分。

### 算法三

首先对于任意区间 $a,b$，注意到 $a \ \& \ (b\ | \ c) = a \ \& \ b \ | \ a \ \& \ c$，也就是区间交并满足分配率，可以使用矩阵乘法刻画递推，线段树维护矩乘进行 DDP，以 $O(\log n)$ 复杂度获取对某一个二元组 $(l,r)$ 查询 DP 的值。

不难想到对于每个左端点，二分线段树或线段树上二分，找到结果不为空集的最大右端点。复杂度 $O(n\log^2 n)$ 或 $O(n\log n)$。

### 算法四

基于算法二的剪枝，我们注意到当 $l$ 递增时，DP 不为空集的最大右端点 $r$ 单调不降。保留算法二的主要过程的同时，使用双指针的思想，结合算法三。将左端点 $l$ 推到 $l + 1$ 时，以 $O(\log n)$ 的复杂度获取上一次最大右端点 $r$ 处 DP 的新值即线段树上 $(l+1,r)$。时间复杂度 $O(n\log n)$。

### 赛时代码

```cpp
#include <bits/stdc++.h>
using namespace std;
using i64 = long long;
constexpr int maxn = 500000 + 100;
constexpr i64 inf = 0x3f3f3f3f3f3f3f3f;
struct node
{
    i64 l, r;
    inline bool check() const
    {
        return l <= r;
    }
    node(i64 _l=0, i64 _r=0) : l(_l), r(_r) {}
} f[maxn][2];
node operator&(const node a, const node b)
{
    return node(max(a.l, b.l), min(a.r, b.r));
}
node operator|(const node a, const node b)
{
    if (!a.check()) return b;
    if (!b.check()) return a;
    return node(min(a.l, b.l), max(a.r, b.r));
}
void operator|=(node& a, const node b)
{
    if (!a.check()) return a = b, void();
    if (!b.check()) return;
    a.l = min(a.l, b.l);
    a.r = max(a.r, b.r);
}
i64 a[maxn];
struct matrix
{
    node a, b, c, d;
} t[maxn << 2];
inline matrix operator*(const matrix& a, const matrix& b)
{
    matrix c;
    c.a = (a.a & b.a) | (a.b & b.c);
    c.b = (a.a & b.b) | (a.b & b.d);
    c.c = (a.c & b.a) | (a.d & b.c);
    c.d = (a.c & b.b) | (a.d & b.d);
    return c;
}
void build(int rt, int l, int r)
{
    if (l == r)
    {
        t[rt].a = (a[r - 1] < a[r] ? node(-inf, inf) : node(1, 0));
        t[rt].b = node(-inf, (a[r - 1] + a[r]) / 2 - 1);
        t[rt].c = node((a[r - 1] + a[r]) / 2 + 1, inf);
        t[rt].d = (a[r - 1] > a[r]) ? node(-inf, inf) : node(1, 0);
        return;
    }
    int mid = (l + r) >> 1;
    build(rt << 1, l, mid);
    build(rt << 1 | 1, mid + 1, r);
    t[rt] = t[rt << 1 | 1] * t[rt << 1];
}
matrix query(int rt, int l, int r, int L, int R)
{
    if (L <= l && r <= R) return t[rt];
    int mid = (l + r) >> 1;
    if (L <= mid && mid < R) return query(rt << 1 | 1, mid + 1, r, L, R) * query(rt << 1, l, mid, L, R);
    if (L <= mid) return query(rt << 1, l, mid, L, R);
    return query(rt << 1 | 1, mid + 1, r, L, R);
}
int main()
{
    freopen("mirror.in", "r", stdin);
    freopen("mirror.out", "w", stdout);
    ios::sync_with_stdio(0);
    cin.tie(0);
    int n;
    cin >> n;
    for (int i=1;i<=n;++i) cin >> a[i], a[i] <<= 3;
    i64 ans = 0;
    build(1, 1, n);
    matrix b;
    b.b = b.d = node(1, 0);
    b.a = b.c = node(-inf, inf);
    int lstj = -1;
    for (int i=1;i<n;++i)
    {
        if (lstj <= i) f[i][0] = f[i][1] = node(-inf, inf), lstj = i;
        else
        {
            matrix x = query(1, 1, n, i + 1, lstj) * b;
            f[lstj][0] = x.a, f[lstj][1] = x.c;
        }
        int ok = 1;
        for (int j=lstj+1;j<=n;++j)
        {
            f[j][0] = f[j][1] = node(1, 0);
            if (a[j - 1] < a[j]) f[j][0] = f[j - 1][0];
            f[j][0] |= (node(-inf, (a[j - 1] + a[j]) / 2 - 1) & f[j - 1][1]);
            if (a[j] < a[j - 1]) f[j][1] = f[j - 1][1];
            f[j][1] |= (node((a[j - 1] + a[j]) / 2 + 1, inf) & f[j - 1][0]);
            if (f[j][0].check() || f[j][1].check());
            else
            {
                ok = 0;
                lstj = j - 1;
                break;
            }
        }
        if (ok) lstj = n;
        ans += lstj - i;
    }
    cout << ans << '\n';
    return 0;
}

```

---

## 作者：UnyieldingTrilobite (赞：7)

考场做法，感觉还是蛮自然的。会尽量就考场思路进行复刻。首先我们很显然需要对这个条件有一些比较合理的刻画。第一反应是考虑如下的信息形如 $2L\in S$，然后对 $S$ 进行维护。不妨全集为 $(0,+\infty)$。

考虑我们现在有一个子区间，它的结尾是 $h_i$，现在我们要往后追加一个新元素 $h_{i+1}$。不难发现这个时候 $h_i$ 变或不变很重要。我们不妨维护 $S_0$ 表示 $h_i$ 不变时的 $S$，$S_1$ 表示 $h_i$ 变为 $2L-h_i$ 时的 $S$。我们对 $h_i$ 和 $h_{i+1}$ 的大小分类讨论，记 $d=h_i+h_{i+1}$：

1. $h_i\lt h_{i+1}$

$$\begin{cases}
S'_0=S_0\cup(S_1\cap(0,d))\\
S'_1=S_0\cap(d,+\infty)
\end{cases}$$

2. $h_i=h_{i+1}$

$$\begin{cases}
S'_0=S_1\cap(0,d)\\
S'_1=S_0\cap(d,+\infty)
\end{cases}$$

3. $h_i\gt h_{i+1}$

$$\begin{cases}
S'_0=S_1\cap(0,d)\\
S'_1=S_1\cup(S_0\cap(d,+\infty))
\end{cases}$$

于是容易想到归纳证明 $S_{0/1}$ 一定是一个区间，且满足 $S_0$ 的下界等于 $S_1$ 的下界（此时 $S_1$ 的上界不小于 $S_0$ 的上界），或 $S_0$ 的上界等于 $S_1$ 的上界（此时 $S_1$ 的下界不小于 $S_0$ 的下界），或 $S_0$ 的上界等于 $S_1$ 的下界；特殊地，认为空区间的上界或下界与任意值相等。三类情况实际上基本是一样的，但严谨起见我们来依次考虑：

1. $h_i\lt h_{i+1}$

+ $S_0=(l,x)$，$S_1=(l,y)$ 且 $y\ge x$

若 $d\ge x$ 则 $S_1'=\varnothing$，成立。

若 $d\lt x$ 则 $S_1'=(\max\{d,l\},x)$。此时 $S_0'=(l,x)\cup((l,y)\cap(0,d))=(l,x)$，成立。

+ $S_0=(x,r)$，$S_1=(y,r)$ 且 $y\ge x$

若 $d\ge r$ 则 $S_1'=\varnothing$，成立。

若 $d\lt r$ 则 $S_1'=(\max\{d,x\},r)$。此时 $S_0'=(x,r)\cup((y,r)\cap(0,d))=(x,r)$，成立。

+ $S_0=(x,p)$，$S_1=(p,y)$

若 $d\ge p$ 则 $S_1'=\varnothing$，成立。

若 $d\lt p$ 则 $S_1'=(\max\{d,x\},p)$。此时 $S_0'=(x,p)\cup((p,y)\cap(0,d))=(x,p)$，成立。

2. $h_i=h_{i+1}$

+ $S_0=(l,x)$，$S_1=(l,y)$ 且 $y\ge x$

若 $d\ge x$ 则 $S_1'=\varnothing$，成立。

若 $l\lt d\lt x$ 则 $S_1'=(d,x)$，$S_0'=(l,d)$，成立。

若 $d\le l$ 则 $S_0'=\varnothing$，成立。

+ $S_0=(x,r)$，$S_1=(y,r)$ 且 $y\ge x$

若 $d\ge r$ 则 $S_1'=\varnothing$，成立。

若 $x\lt d\lt r$ 则 $S_1'=(d,r)$。此时 $S_0'=(y,r)\cap(0,d)=(y,d)$，成立。

若 $d\le x$ 则 $S_0'=\varnothing$，成立。

+ $S_0=(x,p)$，$S_1=(p,y)$

若 $d\ge p$ 则 $S_1'=\varnothing$，成立。

若 $d\lt p$ 则 $S_0'=\varnothing$，成立。

3. $h_i\gt h_{i+1}$

+ $S_0=(l,x)$，$S_1=(l,y)$ 且 $y\ge x$

若 $d\le l$ 则 $S_0'=\varnothing$，成立。

若 $d\gt l$ 则 $S_0'=(l,\min\{d,y\})$。此时 $S_1'=(l,y)\cup((l,x)\cap(d,+\infty))=(l,y)$，成立。

+ $S_0=(x,r)$，$S_1=(y,r)$ 且 $y\ge x$

若 $d\le y$ 则 $S_0'=\varnothing$，成立。

若 $d\gt y$ 则 $S_0'=(y,\min\{d,r\})$。此时 $S_1'=(y,r)\cup((x,r)\cap(d,+\infty))=(y,r)$，成立。

+ $S_0=(x,p)$，$S_1=(p,y)$

若 $d\le p$ 则 $S_0'=\varnothing$，成立。

若 $d\gt p$ 则 $S_0'=(p,\min\{d,y\})$。此时 $S_1'=(p,y)\cup((x,p)\cap(d,+\infty))=(p,y)$，成立。

于是我们的结论就证完了。

这个事情实际上单用没啥用，但通过归纳可以简单证明，对于任意区间，在固定两端变与不变的前提下，满足条件的 $2L$ 构成一个区间。不难发现这个东西是可以用类似上面的转移对两个区间进行简单合并的。于是我们使用带删尺取（省流：双栈模拟队列，对栈上的每个位置记录到栈底的答案）就可以做 $O(n)$ 了。之所以要证区间是因为这样可以简单实现集合并。

代码在 CQYC 机子上没弄出来，总之非常好写（毕竟题解那一大串东西基本全是结论证明）。

以上。

---

## 作者：云浅知处 (赞：7)

注意到我们只关心 $h_i,2L-h_i$ 和 $h_{i+1},2L-h_{i+1}$ 之间两两的大小关系。当两个数的选择分别为 $(h_i,h_{i+1})$ 或者 $(2L-h_i,2L-h_{i+1})$ 时，这两个数的大小关系都和 $L$ 无关；否则这只和 $2L$ 与 $h_i+h_{i+1}$ 的大小关系有关。

由于一共只有不超过 $n-1$ 种不同的 $h_i+h_{i+1}$，因此本质不同的 $L$ 至多只有 $n$ 种。枚举 $L$ 的取值，考虑一个区间在确定了 $L$ 的取值之后该如何判定是否合法。

仍然是考虑 $h_i,2L-h_i,h_{i+1},2L-h_{i+1}$ 这四个数之间的大小关系。不妨先来考虑 $h_i\neq h_{i+1}$ 的情形，记这四个数分别为 $a_1,a_2,b_1,b_2$，由于我们一定可以调整 $L$ 使得 $2L\neq h_i+h_{i+1}$，这样，这四个数的大小关系就要么是 $\min(b_1,b_2)<\min(a_1,a_2)<\max(a_1,a_2)<\max(b_1,b_2)$，也就是 $b$ 的取值把 $a$ 夹在中间；要么是 $a$ 的取值把 $b$ 夹在中间。

我们把这两种分别记为 $\{2,3\}\to \{1,4\}$ 和 $\{1,4\}\to \{2,3\}$。如果是前者，不管前面取 $2$ 还是 $3$ 后面都只能取 $4$；如果是后者，前一个必须取 $1$ 否则直接无解，然后后一个一定会取 $2$。发现这要求区间必须形如先一段 $\{1,4\}\to \{2,3\}$，然后是 $\{2,3\}\to \{1,4\}$。需要特殊考虑一下 $h_i=h_{i+1}$ 的情况，这时一定前一个取较小值，后一个取较大值，那么要求 $h_{i-1},h_i$ 形如 $14/23$，$h_{i+1},h_{i+2}$ 形如 $23/14$。

- 其实这就是官方题解得到的结论：$p_i=\max(h_i,2L-h_i)$ 单谷。

考虑从小到大枚举 $L$ 的取值，每个 $(i,i+1)$ 至多从 $23/14$ 变成 $14/23$ 一次，或者是反过来变一次。维护合法的极长连续段即可算出每个 $i$ 向右最多延伸多少。一个更好写的写法是：套路地换个维度，倒着扫序列维，数据结构维护 $L$ 那一维就只需要做区间覆盖和全局求 max 了。

```cpp
#include<bits/stdc++.h>

#define ll long long
#define fi first
#define se second
#define mk make_pair

using namespace std;

ll read(){
	ll x=0,f=1;char c=getchar();
	for(;!isdigit(c);c=getchar())if(c=='-')f=-1;
	for(;isdigit(c);c=getchar())x=x*10+c-'0';
	return f==1?x:-x;
}

template<typename T>
void cmax(T &x,T v){x=max(x,v);}
template<typename T>
void cmin(T &x,T v){x=min(x,v);}

const int N=5e5+5;
int n;
ll h[N];
const ll INF=1e15;
int t[N],R[N];

struct sgt{
	int lz[N<<2],d[N<<2];
	#define ls(p) (p<<1)
	#define rs(p) (p<<1|1)
	void app(int f,int p){d[p]=f,lz[p]=f;}
	void pushup(int p){d[p]=max(d[ls(p)],d[rs(p)]);}
	void pushdown(int p){
		if(lz[p]==-1)return ;
		app(lz[p],ls(p)),app(lz[p],rs(p)),lz[p]=-1;
	}
	void build(int l,int r,int p){
		lz[p]=-1,d[p]=n;
		if(l==r)return ;
		int mid=(l+r)>>1;build(l,mid,ls(p)),build(mid+1,r,rs(p));
	}
	void cov(int l,int r,int v,int ql,int qr,int p){
		if(l<=ql&&qr<=r)return app(v,p),void();
		int mid=(ql+qr)>>1;pushdown(p);
		if(l<=mid)cov(l,r,v,ql,mid,ls(p));
		if(r>mid)cov(l,r,v,mid+1,qr,rs(p));
		pushup(p);
	}
	int qmax(){return d[1];}
}T;

signed main(){
	
	// freopen("mirror.in","r",stdin);
	// freopen("mirror.out","w",stdout);

	n=read();
	for(int i=1;i<=n;i++)h[i]=read();
	
	vector<ll>lsh;
	for(int i=1;i<n;i++)lsh.emplace_back(h[i]+h[i+1]);
	sort(lsh.begin(),lsh.end());
	lsh.resize(unique(lsh.begin(),lsh.end())-lsh.begin());

	int V=lsh.size()+1;
	vector<vector<int> >pos(V);
	for(int i=1;i<n;i++){
		int p=lower_bound(lsh.begin(),lsh.end(),h[i]+h[i+1])-lsh.begin()+1;
		if(h[i]!=h[i+1])pos[p].emplace_back(i);
	}

	for(int i=1;i<n;i++){
		if(h[i]<h[i+1])t[i]=3;
		else if(h[i]==h[i+1])t[i]=2;
		else if(h[i]>h[i+1])t[i]=1;
	}

	for(int i=1;i<=n;i++)R[i]=i+1;
	T.build(1,V,1);
	vector<vector<pair<int,int> > >vals(n+1);

	auto calc=[&](int p,int tim){
		if(t[p-1]>t[p]||(t[p-1]==2&&t[p]==2))vals[p].emplace_back(mk(1,tim));
		else vals[p].emplace_back(0,tim);
	};
	vals[1].emplace_back(mk(0,1)),vals[n].emplace_back(mk(1,1));
	for(int i=2;i<=n-1;i++)calc(i,1);

	for(int w=1;w<=V;w++){
		int p=1;
		if(w<=lsh.size()){
			vector<int>ps;
			for(int p:pos[w]){
				if(h[p]<h[p+1])t[p]=1;
				else if(h[p]>h[p+1])t[p]=3;
				if(p>=2&&p<=n-1)ps.emplace_back(p);
				if(p+1>=2&&p+1<=n-1)ps.emplace_back(p+1);
			}
			sort(ps.begin(),ps.end()),ps.erase(unique(ps.begin(),ps.end()),ps.end());
			for(int p:ps)calc(p,w+1);
		}
	}
	for(int i=1;i<=n;i++)vals[i].emplace_back(mk(-1,V+1));

	for(int i=n;i>=1;i--){
		R[i]=T.qmax();
		for(int j=0;j+1<vals[i].size();j++){
			int v=vals[i][j].fi,st=vals[i][j].se,ed=vals[i][j+1].se;
			if(v==1)T.cov(st,ed-1,i,1,V,1);
		}
	}

	ll ans=0;
	for(int i=1;i<=n;i++)ans+=R[i]-i;
	cout<<ans<<endl;

	return 0;
}
```

---

## 作者：strcmp (赞：5)

**题目大意：**

给定长度为 $n$ 的正整数序列，区间 $[l,\,r]$ 合法当且仅当满足以下条件：

- 存在实数 $L$，使得区间 $[l,\,r]$ 中任意一个元素 $a_i$，可以使得其变为 $2L - a_i$（也可以不变），存在一种方案使得 $[l,\,r]$ 递增。

求序列中合法的区间个数。

------------

大力分讨题。

首先有一个入门结论是区间 $[l,\,r]$ 若存在区间 $[l',\,r']$ 满足 $l' \le l \le r \le r'$，则若区间 $[l',\,r']$ 合法则区间 $[l,\,r]$ 合法。否则若 $[l,\,r]$ 不合法，则 $[l',\,r']$ 必然不合法。

那么就有一个显然的双指针把枚举区间的复杂度优化成 $\Theta(n)$，每次我们相当于加入/删除端点，求当前区间是否合法

不妨考虑三个 $a_{i - 1},\,a_i,\,a_{i + 1}$。

钦定 $a_{i - 1} < a_{i + 1}$，反过来的情况只是全部取 $2L - a_i$ 后的镜像。

考虑 $a_i < a_{i - 1} < a_{i + 1}$ 的情况。

- 显然两边不变的情况下，只能考虑选择 $2L - a_i$，此时要满足 $a_{i - 1} < 2L - a_i < a_{i + 1}$，即 $a_{i - 1} + a_i < 2L < a_{i + 1} + a_i$；或者令 $2L - a_{i - 1} < a_i < a_{i + 1}$，即 $2L < a_{i - 1} + a_i$；或者令 $2L - a_{i - 1} < 2L - a_{i} < a_{i + 1}$，此时 $2L < a_{i} + a_{i + 1}$。

注意到因为 $a_{i + 1} > a_{i - 1}$，所以最后一种取法 $L$ 的可能取值包含了前两种取法。

即 $a_i < a_{i - 1} < a_{i + 1}$ 的时候，令 $a_{i - 1},\,a_i$ 都变为自身的镜像最优。

当 $a_{i - 1} < a_i < a_{i + 1}$ 的时候，显然都取原来的值最优。

考虑 $a_{i - 1} < a_{i + 1} < a_{i}$。我们发现取 $a_i$ 变为 $2L - a_i$，$a_{i + 1}$ 变为 $2L - a_{i + 1}$ 最优。此时 $2L > a_i + a_{i - 1}$。

发现什么了吗？连续上升和连续下降都可以直接全部不变或者全部变为镜像，而在上面的讨论中我们已经把峰和谷的情况给讨论完了。

那么接下来考虑 $[l,\,r - 1]$ 是合法的，加入 $r$ 的情况。

- $a_r > a_{r - 1} > a_{r - 2}$，直接作为原值即可。

- $a_r < a_{r - 1} < a_{r - 2}$，全部取镜像即可。

- $a_{r - 1} \ge \max(a_r,\,a_{r - 2})$，形成了一个以 $a_{r - 1}$ 为顶的峰顶，根据上述讨论，$L$ 的下界 $L_{\text{min}}$ 变为 $\max(L_{\text{min}},\,a_{r - 1} + \min(a_{r - 2},\,a_{r}))$。

- $a_{r - 1} \le \min(a_r,\,a_{r - 2})$，形成了一个以 $a_{r - 1}$ 为底的谷底，根据上述讨论，$L$ 的上界 $L_{\text{max}}$ 变为 $\min(L_{\text{max}},\,a_{r - 1} + \max(a_{r - 2},\,a_{r}))$。

注意到这个东西本质上是一个开区间 $\max$ 和一个开区间 $\min$，直接做即可。

最后只需要判断 $L$ 的下界是否小于 $L$ 的上界即可，时间复杂度 $\Theta(n \log n)$，代码中求 RMQ 使用了 zkw 树。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long int ll;
using pll = pair<ll, ll>;
const int maxn = 2e6 + 10;
const ll mod = 1e9 + 7;
const ll inf = 114514191981052013LL;
ll a[maxn], b[maxn], c[maxn], ans = 0; int n, M = 1;
inline int qry(int l, int r) {
    if (l > r) return 1;
    ll pb = -inf, pc = inf;
    for (l = l + M - 1, r = r + M + 1; l ^ r ^ 1; l >>= 1, r >>= 1) {
        if (~l & 1) pb = max(pb, b[l ^ 1]), pc = min(pc, c[l ^ 1]);
        if (r & 1) pb = max(pb, b[r ^ 1]), pc = min(pc, c[r ^ 1]);
    }
    return pb < pc;
}
int main() {
    memset(b, 0xcf, sizeof(b));
    memset(c, 0x3f, sizeof(c));
    scanf("%d", &n); while (M <= n) M <<= 1;
    for (int i = 1; i <= n; i++) scanf("%lld", &a[i]);
        for (int i = 2; i < n; i++) {
        if (a[i] >= max(a[i - 1], a[i + 1])) b[i + M] = a[i] + min(a[i - 1], a[i + 1]);
        if (a[i] <= min(a[i - 1], a[i + 1])) c[i + M] = a[i] + max(a[i - 1], a[i + 1]);
    }
    for (int i = M; i >= 1; i--) b[i] = max(b[i << 1], b[i << 1 | 1]), c[i] = min(c[i << 1], c[i << 1 | 1]);
    for (int i = 1, r = 1; i <= n; i++) {
        while (r < n && qry(i + 1, r)) ++r;
        ans += r - i;
    }
    printf("%lld\n", ans);
    return 0;
}
```



---

## 作者：幸存者 (赞：4)

upd on 2.7：修正了一处错误。

upd on 1.17：又修正了一处错误，添加了代码。

一个不需要什么脑子的赛时做法，但不太好写而且常数不小。

我们考虑什么样的 $L$ 对答案有影响，容易发现的是相邻两个的相对状态最多只会改变一次，因为水面上的柱子和水面下的柱子高度和是相等的，所以相邻两个的水面上的柱子高的水面下的柱子就会低。

考虑一种特殊情况，那就是当两者水面上与水面下高度都完全相同时，$L=\dfrac{h_i+h_{i+1}}{2}$ 的，但稍加思考后我们就会发现这种情况是不优的，于是我们只需要考虑 $L=\dfrac{h_i+h_{i+1}}{2}+0.5$ 以及 $L=0$。

思考一下暴力怎么做，枚举这 $n$ 种有用的 $L$，计算每个点结尾的水面下的柱子最长单调上升段的长度 $lst_i$，每个点开头的水面上的柱子最长单调上升段的长度 $nxt_i$。那么我们维护 $mx_i$ 表示 $i$ 开头的最长合法段能到哪，考虑差分思想，则有 $mx_{i-lst_i+1}=\max\{mx_{i-lst_i+1},i+nxt_{i+1}\}$，最终只需对 $mx$ 取前缀最大值，然后答案就是 $\sum\limits_{i=1}^n(mx_i-i)$。

接着正解就不难想了，考虑我们初始这么维护 $L$ 的目的，所以每次相对上一次只会改变很少的相邻关系。我们考虑维护每个 $L$ 会改变哪些 $i,i+1$，放到一个 map 套 vector 里，然后每次水面下与水面上的相邻关系都会变化，只需要用线段树修改即可。

但由于我们需要 1log，所以必须开四颗线段树（也可以两颗线段树+线段树上二分），分别代表每个点开头/结尾，水面上/水面下最远能走到哪，完成区间覆盖单点查询即可。

注意一个细节，那就是我们必须得完成这个 $L$ 对应的全部修改后再去修改 $mx_i$ 的值，赛时我因为这个调了好久。

~~由于我赛时代码没了，而且我也懒得再写一遍了，所以就不放代码了。~~

在 WC 2025 又写了一份，见[云剪贴板](https://www.luogu.com.cn/paste/lp6drg3g)。

---

## 作者：_Diu_ (赞：4)

神秘 76pts，赛后发现可以优化成 100pts。

这就是脑电波对接失败给我带来的自信。

由于只看简化题面，我们的 $L$ 表示原题目中的 $2L$。

容易发现一个点取值有两种，$a_i$ 和 $L-a_i$，我们用一个状态 $01$ 表示是否翻转。

对于一个 $L$，我们可以用一个 $2\times 2$ 的布尔矩阵维护相邻两个数的状态，$A_{i,j}$ 表示左侧 $i$ 右侧 $j$ 是否合法。设这两个相邻的数分别为 $x,y$，则 $A=\begin{bmatrix}x<y&x+y<L\\x+y>L&x>y\end{bmatrix}$，一个区间合法等价于对应区间乘起来后非零。

容易发现对于一个 $A$，$A_{0,0}$ 和 $A_{1,1}$ 是固定的，并且我们从小到大扫 $L$，每个矩阵只会更新 $1$ 次（$L=x+y$ 的情况可以直接忽略），那么本质不同的 $L$ 只会有 $O(n)$ 个，那么我们已经有了一个 $O(n^3)$ 做法：枚举每个区间，再枚举每个 $L$。然后这个区间是单调的，可以双指针做到 $O(n^2)$。

接下来我们希望能够枚举不同的 $L$，然后分别统计合法区间个数。但是一个区间可能对应多个不同的 $L$，那么就会计重。为了解决这个问题，提出一个猜想：对于每个合法的区间，其对应的 $L$ 是连续的一段。

然而这个结论显然是错的，两个相同的数就能卡掉这玩意：对于 $x,x$，当 $L=2x$ 时不合法，否则合法。虽然这能看作挖掉端点后的段，可是这意味着矩阵的形态可能会发生很大的改变。

赛时我猜测除了端点外的合法的 $L$ 是一个区间，写了个暴力跑了 1min 左右的大样例都过了就认为这是对的了。本校 Au 爷洛谷著名网红 lovely_ckj 也用了这个结论，但其他人可能都没用，并不知道其正确性。

**Upd：在[神仙 ut 的题解](https://www.luogu.com.cn/blog/250637/solution-p10144)中看到了这个结论的证明。**考虑归纳，分别维护末尾是否翻转对应 $L$ 的区间 $S_0,S_1$，讨论两个 $h$ 的大小关系即可得证。

我们假设这个是对的，可以利用点边容斥/代表元解决上述问题。我采用的是代表元，假设所有 $a_i+a_{i+1}$ 离散化后是 $t_1,t_2,\dots,t_k$，我们数对于相邻两个 $L$ 的值域段 $(t_{i-1},t_i),(t_i,t_{i+1})$，第一个合法的/第二个不合法的区间数量和 $(t_k,+\infty)$ 的合法区间数量。

接下来考虑如何计数，我们考虑 dp 套 dp，把矩阵的形态状压起来。外层我们使用线段树维护，方便我们扫描 $L$ 时进行单点修改。线段树上我们需要维护靠左的区间的矩阵信息，靠右的还有区间内有多少个符合条件的区间。

注意到矩阵维护的是布尔值，本质不同的矩阵有 $2^4$ 个状态，我们直接对每种状态记录数量。但注意到我们记录的信息实际上是靠边的，有一侧是无效的，所以我们其实只需要记录 $2^2$ 个状态。但是因为我们需要记录两个可能有不同的段对应的矩阵的信息，因此还是需要记录 $2^4$ 个状态，合并需要 $2^4\times 2^4$ 处理跨重点的段。因此我们的到了一个 $O(n\log n)$ 做法，拥有低贱的 $256$ 的常数，和暴力同分。

我们容易发现，在合并过程中，有效的合并其实只有不超过 $64$ 种，可以把常数降到 $64$，实测跑 $10^5$ 的样例是 0.7s，$5\times10^5$ 的是 8s，感觉只有 64pts，但是由于机子过于强，跑过了 $2\times10^5$ 的点，喜提最大部分分 76pts。

赛时并没想到进一步优化的方法，但赛后我们发现实际上所求东西的性质是非常优秀的，我们并没有很好的利用它的性质。前面提到过矩阵实际上可以看作 $A_{0,0},A_{1,1}$ 不同时为 $1$；$A_{0,1},A_{1,0}$ 不同时为 $1$。因此对于一段的靠边的矩阵，实际上只有两种状态：要么是不合法，要么是只能传入 $0/1$ 或者两者皆可。因此我们可以把一个 $L$ 的段的对应状态压缩到 $2$ 个，维护两个段那么状态就是 $4$ 个，那么常数就降到了 $16$，大概是可以通过的了。

但实际上这个做法的矩阵性质还是不够强，我们任意矩阵只要满足 $A_{0,0},A_{1,1}$ 不同时为 $1$，$A_{0,1},A_{1,0}$ 不同时为 $1$ 都可以这样做，而原题还有更强的限制，因此原题可以做到 $O(n)$，但这个做法脱不开 $O(n\log n)$ 的范畴，没啥前途，可能这就是脑电波对接失败给我带来的自信！

赛时代码搞不到，暂时咕掉。



---

## 作者：FireBladeMaster (赞：4)

无脑做法。考虑相邻三个点 $x,y,z$，为了合法，分类讨论其大小关系将 $2L$ 限制在哪个区间。

![](https://cdn.luogu.com.cn/upload/image_hosting/uzen4tag.png)

限制全都形如 $(-\infty,x)$ 或者 $(x,+\infty)$。

现在你可以随便维护了。

我场上写的是考虑分治，每次统计跨过 $[mid-1,mid+1]$ 的区间的贡献。可以对一侧的限制处理后双指针。

时间复杂度 $O(n\log n)$。且不需要写数据结构，常数非常小。

当然你可以用 rmq+双指针，这样可以做到线性。

```cpp
#include <stdio.h>
#include <string.h>
#include <algorithm>
#include <vector>
#define int long long
inline int read()
{
    int num=0,f=1;char c=getchar();
    while(c<48||c>57){if(c=='-')f=-1;c=getchar();}
    while(c>47&&c<58)num=num*10+(c^48),c=getchar();
    return num*f;
}
int a[1234567],res=0;
const int inf=0x3f3f3f3f3f3f3f3f;
using pi=std::pair<int,int>;
pi get(int x,int y,int z)
{
	if(x==y&&y==z)return {inf,-inf};
	if(x<y&&y<z)return {-inf,inf};
	if(x>y&&y>z)return {-inf,inf};
	if(x<z&&z<y)return {x+y+1,inf};
	if(x>z&&z>y)return {-inf,x+y-1};
	if(y<x&&x<z)return {-inf,y+z-1};
	if(y>x&&x>z)return {y+z+1,inf};
	if(x==y&&x<z)return {-inf,y+z-1};
	if(x==y&&x>z)return {y+z+1,inf};
	if(y==z&&x<y)return {y+x+1,inf};
	if(y==z&&x>y)return {-inf,x+y-1};
	if(x==z&&y<x)return {-inf,x+y-1};
	if(x==z&&y>x)return {z+y+1,inf};
}
pi ins(pi x,pi y)
{
	return {std::max(x.first,y.first),std::min(x.second,y.second)};
}
int len(pi x){return x.second>=x.first;}
void fz(int l,int r)
{
	if(r-l+1==2)res++;
	else if(r-l+1==3)res+=(a[l]==a[l+1]&&a[l+1]==a[r]?2:3);
	else
	{
		int m=l+r>>1;
		fz(l,m);fz(m,r);
		std::vector<pi> x,y;
		x.reserve(r-m);y.reserve(m-l);
		for(int i=m+1;i<=r;i++)x.push_back(get(a[i-2],a[i-1],a[i]));
		for(int i=m-1;i>=l;i--)y.push_back(get(a[i],a[i+1],a[i+2]));
		for(int i=1;i<x.size();i++)x[i]=ins(x[i],x[i-1]);
		for(int i=1;i<y.size();i++)y[i]=ins(y[i],y[i-1]);
		int nw=y.size()-1;
		for(int i=0;i<x.size();i++)
		{
			while(nw>=0&&!len(ins(x[i],y[nw])))nw--;
			res+=nw+1;
		}
	}
}
signed main()
{
	int n=read();
	for(int i=1;i<=n;i++)a[i]=read()*14;
	fz(1,n);
	printf("%lld\n",res);
	return 0;
}
```

---

## 作者：Maverik (赞：3)

令 $T=2L$。

可以直观感受到 $T$ 分成 $O(n)$ 个有效段，因为我们只关心相邻两个数关于 $T$ 的相对距离，所以界点会是 $2a_i$ 或者 $a_i+a_{i+1}$。

有 $O(n^2)$ 暴力，设 $f(t,i,0/1)$ 表示 $T=t$ 时，不反转/反转 $i$ 为右端点时拓展的最大距离。

1. $a_i<a_{i+1},f(t,i,0)\to f(t,i+1,0)$
2. $a_i>a_{i+1},f(t,i,1)\to f(t,i+1,1)$
3. $a_i+a_{i+1}<T,f(t,i,0)\to f(t,i+1,1)$
4. $a_i+a_{i+1}>T,f(t,i,0)\to f(t,i+1,1)$

前面两种转移是固定的，后面两种转移关于 $T$ 只最多分成三段。

转移可以用 max-add 矩乘表示，考虑按照下标做扫描线，线段树维护每一项 $T$ 的 $f$ 矩阵。转移时区间乘矩阵就好了。

复杂度 $O(w^3 n\log n)$ 。


$w=3$ 比较好写没什么细节，有点卡常。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
inline void cmax(ll &x,const ll &y){ if(y>x) x=y; }
const int maxn=1e6+10;
const ll inf=0x3f3f3f3f3f3f3f3f;

inline namespace source {
    typedef long long int llong;
    typedef unsigned long long int ullong;
    template <typename T, enable_if_t<is_unsigned<T>::value, void**> = nullptr>
      constexpr T __lg(T const x)
      { return CHAR_BIT * sizeof(T) - 1 - __builtin_clz(x); }
    template <typename T, enable_if_t<is_unsigned<T>::value, void**> = nullptr>
      constexpr T lowbit(T const x) { return x & -x; }
    template <typename T>
      constexpr T& cmin(T &a, T const &b) { return a = min(a, b); }
    template <typename T>
      constexpr T& cmax(T &a, T const &b) { return a = max(a, b); }
    template <typename T>
      constexpr pair<T&, T&> cminmax(T &a, T &b)
      { return pair<T&, T&>(a, b) = minmax(T(a), T(b)); }
    inline namespace io {
      class Scanner {
        FILE* const stream; char buffer[BUFSIZ];
        char *head = buffer, *tail = buffer;
        void flush() {
          assert(head == tail), head = tail = buffer;
          tail += fread(buffer, sizeof(char), BUFSIZ, stream);
        }
      public:
        Scanner(FILE* const stream = stdin) : stream(stream) {}
        Scanner(const char* const filename) : stream(fopen(filename, "r")) {}
        ~Scanner() { fclose(stream); }
        char getc() {
          if (head == tail) flush();
          return head == tail ? EOF : *head++;
        }
        template <typename T, enable_if_t<is_unsigned<T>::value, void**> = nullptr>
          T get() {
            char ch;
            while (!isgraph(ch = getc()) && ch != EOF);
            assert(isdigit(ch)); T res(0);
            while (isdigit(ch)) res = res * 10 + (ch - '0'), ch = getc();
            return res;
          }
        template <typename T, enable_if_t<is_signed<T>::value, void**> = nullptr>
          T get() {
            char ch;
            while (!isgraph(ch = getc()) && ch != EOF);
            int const sign(ch == '-' ? ch = getc(), -1 : +1);
            assert(isdigit(ch)); T res(0);
            while (isdigit(ch)) res = res * 10 + sign * (ch - '0'), ch = getc();
            return res;
          }
        template <typename T>
          void read(T &value) { value = get<T>(); }
        template <typename T, typename ...U>
          void read(T &value, U &...args)
          { read(value), read(args...); }
        template <typename T>
          void read_each(T* const begin, T* const end)
          { for (T* i(begin); i != end; ++i) read(*i); }
      };
      class Printer {
        FILE* const stream; char buffer[BUFSIZ], *ptr = buffer;
        void flush() {
          uint const tmp(fwrite(buffer, sizeof(char), ptr - buffer, stream));
          assert(ptr - buffer == tmp), ptr = buffer;
        }
      public:
        Printer(FILE* const stream = stdout) : stream(stream) {}
        Printer(const char* const filename) : stream(fopen(filename, "w")) {}
        ~Printer() { flush(), fclose(stream); }
        void putc(char const ch) {
          if (ptr - buffer == BUFSIZ) flush();
          *ptr++ = ch;
        }
        void puts(const char *s) { while (*s) putc(*s++); putc('\n'); }
        template <typename T, enable_if_t<is_unsigned<T>::value, void**> = nullptr>
          void write(T value) {
            static char stk[CHAR_BIT * sizeof(T)], *top(stk);
            while (*top++ = value % 10 + '0', value /= 10);
            while (putc(*--top), top != stk);
          }
        template <typename T, enable_if_t<is_signed<T>::value, void**> = nullptr>
          void write(T value) {
            if (value < 0) putc('-');
            static char stk[CHAR_BIT * sizeof(T)], *top(stk);
            while (*top++ = abs(value % 10) + '0', value /= 10);
            while (putc(*--top), top != stk);
          }
        template <typename T>
          void writeln(T const value) { write(value), putc('\n'); }
        template <typename T, typename ...U>
          void write(T const value, U const ...args)
          { write(value), putc(' '), write(args...); }
        template <typename ...T>
          void writeln(T const ...args)
          { write(args...); putc('\n'); }
        template <typename T>
          void write_each(T* const begin, T* const end) {
            for (T* i(begin); i != end; ++i) write(*i), putc(' ');
            putc('\n');
          }
      };
    }
  }


int n;
ll a[maxn];

struct Vector{ ll c[3]; int N=1,M=3; };
struct Matrix{ ll c[3][3]; int N=3,M=3; };
inline Vector operator * (const Vector&A,const Matrix&B)
{
    Vector res; memset(res.c,0xcf,sizeof(res.c));
    cmax(res.c[0],A.c[0]+B.c[0][0]);
    cmax(res.c[0],A.c[1]+B.c[1][0]);
    cmax(res.c[0],A.c[2]+B.c[2][0]);

    cmax(res.c[1],A.c[0]+B.c[0][1]);
    cmax(res.c[1],A.c[1]+B.c[1][1]);
    cmax(res.c[1],A.c[2]+B.c[2][1]);

    cmax(res.c[2],A.c[0]+B.c[0][2]);
    cmax(res.c[2],A.c[1]+B.c[1][2]);
    cmax(res.c[2],A.c[2]+B.c[2][2]);
    return res;
}
inline Matrix operator * (const Matrix&A,const Matrix&B)
{
    Matrix res; memset(res.c,0xcf,sizeof(res.c));

    cmax(res.c[0][0],max({A.c[0][0]+B.c[0][0],A.c[0][2]+B.c[2][0],A.c[0][1]+B.c[1][0]}));
    cmax(res.c[0][1],max({A.c[0][0]+B.c[0][1],A.c[0][1]+B.c[1][1],A.c[0][2]+B.c[2][1]}));

    cmax(res.c[1][0],max({A.c[1][0]+B.c[0][0],A.c[1][1]+B.c[1][0],A.c[1][2]+B.c[2][0]}));
    cmax(res.c[1][1],max({A.c[1][0]+B.c[0][1],A.c[1][1]+B.c[1][1],A.c[1][2]+B.c[2][1]}));

    cmax(res.c[2][0],max({A.c[2][0]+B.c[0][0],A.c[2][1]+B.c[1][0],A.c[2][2]+B.c[2][0]}));
    cmax(res.c[2][1],max({A.c[2][0]+B.c[0][1],A.c[2][1]+B.c[1][1],A.c[2][2]+B.c[2][1]}));
    cmax(res.c[2][2],max({A.c[2][0]+B.c[0][2],A.c[2][1]+B.c[1][2],A.c[2][2]+B.c[2][2]}));
    return res;
}


#define ls (p<<1)
#define rs (p<<1|1)
#define mid ((t[p].l+t[p].r)>>1)
struct node{ int l,r; }t[maxn<<2];
Matrix tag[maxn<<2];
Vector mat[maxn<<2];
bool gtag[maxn<<2];
inline void pushup(int p)
{
    mat[p].c[0]=max(mat[ls].c[0],mat[rs].c[0]);
    mat[p].c[1]=max(mat[ls].c[1],mat[rs].c[1]);
    mat[p].c[2]=0;
}
inline void build(int p,int l,int r)
{
    t[p]={l,r},mat[p].c[0]=mat[p].c[1]=mat[p].c[2]=0;
    if(l==r) return;
    build(ls,l,mid),build(rs,mid+1,r);
}
inline void updata(int p,const Matrix&Mat)
{
    mat[p]=mat[p]*Mat;
    if(!gtag[p]) tag[p]=Mat; else tag[p]=tag[p]*Mat;
    gtag[p]=true;
}
inline void pushdown(int p)
{ if(gtag[p]) updata(ls,tag[p]),updata(rs,tag[p]),gtag[p]=false; }
inline void modify(int p,int l,int r,const Matrix&Mat)
{
    if(l>r) return;
    if(l<=t[p].l && t[p].r<=r) return updata(p,Mat);
    pushdown(p);
    if(l<=mid) modify(ls,l,r,Mat);
    if(r>mid) modify(rs,l,r,Mat);
    pushup(p);
}
inline ll Q(){ return max(mat[1].c[0],mat[1].c[1]); }
#undef mid

inline ll G(bool opt){ return opt?1ll:-inf; }
inline void solve()
{
    Scanner scanner; Printer printer;
    scanner.read(n);
    for(int i=1;i<=n;i++) scanner.read(a[i]),a[i]*=2;
    vector<ll>lsh;
    for(int i=1;i<=n;i++) lsh.push_back(2*a[i]-1);
    for(int i=1;i<n;i++) lsh.push_back(a[i]+a[i+1]-1);
    sort(lsh.begin(),lsh.end());
    lsh.erase(unique(lsh.begin(),lsh.end()),lsh.end());
    int Siz=lsh.size();
    ll ans=0;
    build(1,0,Siz-1);
    Matrix base;
    for(int i=1;i<n;i++)
    {
        base.c[0][0]=G(a[i]<a[i+1]),base.c[0][1]=-inf,          base.c[0][2]=-inf;
        base.c[1][0]=-inf,          base.c[1][1]=G(a[i]>a[i+1]),base.c[1][2]=-inf;
        base.c[2][0]=0,             base.c[2][1]=0,             base.c[2][2]=0;

        ll div=a[i]+a[i+1];
        int pos=lower_bound(lsh.begin(),lsh.end(),div)-lsh.begin(),v1,v2;
        if(lsh[pos]==div) modify(1,pos,pos,base),v1=pos-1,v2=pos+1;
        else v1=pos-1,v2=pos;
        base.c[0][1]=-inf,base.c[1][0]=1,modify(1,0,v1,base);
        base.c[0][1]=1,base.c[1][0]=-inf,modify(1,v2,Siz-1,base);
        ans+=Q();
    }
    printer.writeln(ans);
}
signed main()
{
    solve();
}
```



---

## 作者：Ustinian505 (赞：2)

~~线上选手~~

简要题意就不写了，直接开始分析！

## 如何检查 $h_{1\sim n}$ 是否合法

一点显然的分析，$L\leftarrow 2L$，此时 $L$ 的小数部分为 $0/0.5$（这样就可满足所有 $a,L-b$ 之间的大小比较）。那么我们将 $h_i\leftarrow 2h_i$，此时 $L$ 为非负整数。

设 $g_i=[r_i=L-h_i]$。假如 $L$ 确定，设 $f_{i,0/1}$ 表示考虑 $1\sim i$ 且 $g_i=0/1$ 是否可行，转移判断是否满足 $r_{i-1}<r_i$ 即可。

是否存在合法的 $L$ 是问题的关键。分析上文的转移，存在三种情况：

设 $s=h_{i-1}+h_i$。

1. $h_{i-1}<h_i$：
	
    - $g_{i-1}=0$：
    	
        - $g_i=0$，对 $L$ 没有限制。
        - $g_i=1$，$L>s$。
    - $g_{i-1}=1$：
   			
        - $g_i=0$，$L<s$。
        - $g_i=1$，不存在合法 $L$。
        
2. $h_{i-1}>h_i$：

	  - $g_{i-1}=0$：
    	
        - $g_i=0$，不存在合法 $L$。
        - $g_i=1$，$L>s$。
    - $g_{i-1}=1$：
   			
        - $g_i=0$，$L<s$。
        - $g_i=1$，对 $L$ 没有限制。

3. $h_{i-1}=h_i$：
	
    - $g_{i-1}=0$：
    	
        - $g_i=0$，不存在合法 $L$。
        - $g_i=1$，$L>s$。
    - $g_{i-1}=1$：
   			
        - $g_i=0$，$L<s$。
        - $g_i=1$，不存在合法 $L$。

三种情况类似，且对 $L$ 的限制为值域的前后缀，这启示我们维护合法 $L$ 的取值区间。

设 $f_{i,0/1}$ 表示满足 $1\sim i$ 的限制且 $g_i=0/1$ 时 $L$ 的取值范围，则转移为：

1. $h_{i-1}<h_i$：$f_{i,0}=f_{i-1,0}\cup(f_{i-1,1}\cap (-\infty,s)),f_{i,1}=f_{i-1,0}\cap (s,+\infty)$。
2. $h_{i-1}>h_i$：$f_{i,0}=f_{i-1,1}\cap (-\infty,s),f_{i,1}=f_{i-1,1}\cup (f_{i-1,0}\cap (s,+\infty))$。
3. $h_{i-1}=h_i$：$f_{i,0}=f_{i-1,1}\cap (-\infty,s),f_{i,1}=f_{i-1,0}\cap (s,+\infty)$。

什么时间复杂度？

$f_{i,0/1}$ 维护的是合法区间集合，单次交并复杂度 $O(|f_i|)$，总时间复杂度 $O(n^2)$？ 

手摸可以发现转移的特殊性导致 **$f_{i,0/1}$ 都有 $\leq 1$ 个区间，且 $f_{i,0/1}$ 有包含关系**。这是关键结论，但其实比较显然，可以归纳证明。

于是对于 $f_{i,0/1}$ 只用维护 $[l,r]$ 表示合法的 $L$ 即可，转移 $O(1)$，总时间线性，最终答案为 $[f_{n,0}\cup f_{n,1}\neq \emptyset]$。

枚举 $u$，然后计算所有 $f_{v>u,0/1}$ 来统计答案，总时间 $O(n^2)$，期望得分 $44$ 分。

## 分治优化

统计序列上的区间信息，常常使用分治算法。递归到 $[l,r]$ 时处理所有 $u\in [l,mid],v\in (mid,r]$ 的区间。只要处理长度为 $n$ 的区间能做到优于 $O(n^2)$，就能实现全局优于 $O(n^2)$。

回到这道题，考虑怎么处理跨过中点的区间呢。平方的解法相当于维护出满足 $[u,v]$ 的 $L$ 的区间是否为空集，在这里只需要知道满足 $[u,mid],[mid,v]$ 的 $L$ 的区间是否有交集即可。

设 $A_{i\leq mid,0/1},B_{i>mid,0/1}$ 分别表示左半边和右半边到中间的合法 $L$ 区间，$A$ 的转移类似 $B$，只是把 $h_{i-1},h_i$ 反过来罢了。可以线性求出。

设 $a_{i\leq mid}=A_{i,0}\cup A_{i,1},b_{i>mid}=B_{i,0}\cup B_{i,1}$，则 $[l,r]$ 对答案的贡献为 $\sum_{u=l}^{mid}{\sum_{v=mid+1}^r{[a_u\cap b_v\neq \emptyset]}}$。

这里有一个问题，需要满足 $a_u,b_v$ 是 $mid,0/1$ 中同一个转移得到的，不然会多算。处理 $mid,0/1$ 的初值然后算两遍即可。

暴力计算是平方的，但是 $a_{i+1}\subset a_i,b_{i-1}\subset b_i$（点越多限制越大嘛），所以对于 $u$ 来说合法的 $v$ 是一段前缀，$u$ 减小时合法前缀不增，双指针维护即可。算两遍后取更大的那一个前缀。时间复杂度线性。 

总时间复杂度 $O(n\log n)$，非常好写。

代码~

```cpp
#define L(i,s,t) for(int i=(s);i<=(t);++i)
#define R(i,s,t) for(int i=(s);i>=(t);--i)
#define T(i,s,t) for(int i=(s);i< (t);++i)
#define iV inline void
#define iI inline int
#define ll long long
#define iB inline bool
#define il inline ll
using namespace std;
const int N=5e5+3;
const ll inf=1e13;
il min(ll x,ll y) {return x<y?x:y;}
il max(ll x,ll y) {return x>y?x:y;}
int n,a[N];
ll h[N],ans;
struct it{ll l,r;iB emp() {return l>r;}}f[N][2],g[N];
it operator+(it A,it B) {return {min(A.l,B.l),max(A.r,B.r)};}
it operator*(it A,it B) {return {max(A.l,B.l),min(A.r,B.r)};}
iV solve(int l=1,int r=n) {
    if(l==r) return;
    int mid=(l+r)>>1;
    solve(l,mid),solve(mid+1,r);
    L(i,l,mid) a[i]=mid;
    auto sol=[&](int _){
        f[mid][_]={0,inf},f[mid][_^1]={inf,0};
        R(i,mid-1,l) {
            ll s=h[i]+h[i+1];it a={s+1,inf},b={0,s-1};
            if(h[i]<h[i+1]) f[i][0]=f[i+1][0]+f[i+1][1]*a,f[i][1]=f[i+1][0]*b;
            if(h[i]>h[i+1]) f[i][1]=f[i+1][1]+f[i+1][0]*b,f[i][0]=f[i+1][1]*a;
            if(h[i+1]==h[i])f[i][0]=f[i+1][1]*a,f[i][1]=f[i+1][0]*b;
        }
        L(i,mid+1,r) {
            ll s=h[i]+h[i-1];it a={s+1,inf},b={0,s-1};
            if(h[i-1]<h[i]) f[i][0]=f[i-1][0]+f[i-1][1]*b,f[i][1]=f[i-1][0]*a;
            if(h[i-1]>h[i]) f[i][1]=f[i-1][1]+f[i-1][0]*a,f[i][0]=f[i-1][1]*b;
            if(h[i-1]==h[i])f[i][0]=f[i-1][1]*b,f[i][1]=f[i-1][0]*a;
        }
        L(i,l,r) g[i]=f[i][0]+f[i][1];
        for(int i=mid,j=r;i>=l;--i) {
            while(j>mid&&(g[i]*g[j]).emp()) --j;
            a[i]=max(a[i],j);
        }
    };
    sol(0),sol(1);
    L(i,l,mid) ans+=a[i]-mid;
}
int main() {
    ios::sync_with_stdio(0),cin.tie(0);
    cin>>n;
    L(i,1,n) cin>>h[i],h[i]<<=1;
    solve();
    cout<<ans;
    return 0;
}
```

---

## 作者：IvanZhang2009 (赞：2)

鲜花：场外选手运气好 1h 过掉的题，听说被主持人锐评“赛时有人用矩乘，线段树过了”。

---
先考虑判定区间合法性。单调递增的条件引导我们思考相邻两位的关系，其实只有四种（这两位分别取 $h_i$ 还是 $2L-h_i$，称之为“不对称”和“对称”）。考虑这四种情况对 $2L$ 的限制：

- $r_i=h_i,r_{i+1}=h_{i+1}$，只需要 $h_i<h_{i+1}$ 才能转移。两者都对称同理，需要 $h_i>h_{i+1}$。这两部分对 $2L$ 没有限制。

- $r_i=h_i,r_{i+1}=2L-h_{i+1}$，则 $h_i<2L-h_{i+1},2L>h_i+h_{i+1}$。

- $r_i=2L-h_i,r_{i+1}=h_{i+1}$，则 $2L-h_i<h_{i+1}$，$2L<h_i+h_{i+1}$。

我们发现这些转移分别对 $2L$ 给出了上限和下限，所以发现合法的 $2L$ 是一段开区间。设计 dp：$l_{i,0/1},r_{i,0/1}$ 表示从区间开头到 $i$ 为止是否对称已经确定，$0/1$ 表示第 $i$ 位是否对称，状态表示当前 $2L$ 的**最宽的**上限和下限。合法当且仅当 $l_{n,0}<r_{n,0}$ **或** $l_{n,1}<r_{n,1}$。转移只要根据相邻 $h_i$ 和 $h_{i+1}$ 的大小关系，复杂度线性。注意 $h_{i}=h_{i+1}$ 的情况。

对每个左端点暴力做，复杂度 $\mathcal O(n^2)$。注意到题目中只出现 $2L$，没必要去除以 $2$ 来增加细节。

```cpp
int n;
int a[500005];
void Main() {
	cin>>n;
	REP(i,0,n)cin>>a[i];
	int ans=0;
	REP(i,0,n){
		#define inf 1'000'000'000'000'000'000ll
		int l1=0,r1=inf,l2=0,r2=inf;
		REP(j,i+1,n){
			int x=l1,y=r1,X=l2,Y=r2;
			if(a[j-1]<a[j]){
				l1=min(x,X);r1=max(y,min(Y,a[j-1]+a[j]));
				l2=max(x,a[j-1]+a[j]);r2=y;
			}else if(a[j]<a[j-1]){
				l1=X;r1=min(Y,a[j-1]+a[j]);
				l2=min(X,max(x,a[j-1]+a[j]));r2=max(y,Y);
			}else{
				l1=X;r1=min(Y,a[j-1]+a[j]);
				l2=max(x,a[j-1]+a[j]);r2=y;
			}
			if(l1<r1||l2<r2)++ans;
			else break;
		}
	}
	cout<<ans<<endl;
}
```
---
> 点了提交，顺利获得了 $44$ 分。**但是，我们发现这种设计可能会出现问题：** 我们在所有可能的转移中对上限和下限**独立地**取了“最宽的限制”。可不可能这种最值不能同时取到呢？或者说，有没有可能同一种状态的 $l,r$ 是分别从不同的状态得到的？

接下来简单证明一下正确性：首先忽略代码中 $l_1\ge r_1$ 或 $l_2\ge r_2$ 的情况，因为从这里转移毫无意义。

在剩余的情况中，我们发现在 $h_i\neq h_{i-1}$ 时只有这几种情况会发生：$l_1\le l_2\le r_2\le r_1$，$l_2\le l_1\le r_1\le r_2$。当 $h_i=h_{i-1}$ 时我们发现 $l_1\le r_1=l_2\le r_2$，而下一步必然出现某种情况不合法，所以这样没问题。对于 $h_i\neq h_{i+1}$ 的时候可以打表找规律，感性理解，或者~~经过巨量分类讨论~~归纳证明。更令人惊喜的是，~~经过打表~~，发现总有 $l_1=l_2$ 或 $r_1=r_2$。如果巨量分讨大抵也能证明？

以 $h_{i-1}<h_i$ 为例，$l_2$ 和 $r_2$ 已经确定都从 $(x,y)$ 转移，只需要考虑是否会出现 $l_1$ 和 $r_1$ 分别从代码中 $(x,y)$，$(X,Y)$ 转移的情况呢？反证。

- $l_1$ 不能从 $X$ 转移，$r_1$ 不能从 $y$ 转移，则有 $x<X,Y<y$，所以 $x< X\le Y< y$。这就矛盾了。

- 另一种是同理的。

所以这个做法大抵是没问题的，即不会出现 $l_1,r_1$ 只能从不同的状态分别得到“最宽的”限制。

---

观察代码中的转移（对于下限和上限的转移可以单独考虑）：上限可以由先前的上限和当前的 $h_i+h_{i+1}$ 通过 $\min$ 和 $\max$ 转移，且最后一步总会是取 $\max$。本来不怎么相信 $\min\max$ 能有啥性质，但是想到之前做过的 [这题](https://www.luogu.com.cn/problem/P3821) 是一个比较离谱的 $\max-\min$ 矩阵，发现似乎真有结合律！具体地，

$$\min(\max(a,b),\max(a,c))=\min(a,\max(b,c))$$

这个分讨一下 $a,b,c$ 的大小关系就证了。

以 $h_{i}<h_{i+1}$ 时，$r_{i,0/1}$ 到 $r_{i+1,0/1}$ 的转移为例（定义矩阵乘法为先取 $\min$ 再取 $\max$）：

$$
\left[\begin{matrix}
r_{i,0} & r_{i,1}
\end{matrix}\right]
\oplus
\left[\begin{matrix}
\inf & \inf\\
h_i+h_{i+1} & 0
\end{matrix}\right]
=
\left[\begin{matrix}
r_{i+1,0} & r_{i+1,1}
\end{matrix}\right]
$$
由于先取 $\min$，如果转移矩阵中一位是 $\inf$ 则表示对此处无限制，$0$ 表示此处不可转移（$2L>0$），否则表示一个限制。

其余类似。所以用线段树维护 $n-1$ 个转移矩阵，即可 $\mathcal O(\log n)$ 求出一个区间对 $2L$ 的上限。下限是类似的。考虑到明显的单调性，双指针求解答案，时间复杂度 $\mathcal O(n\log n)$。

```cpp
struct matrix1{
	int a,b,c,d;
	matrix1 operator *(matrix1 e){
		return matrix1{max(min(a,e.a),min(b,e.c)),max(min(a,e.b),min(b,e.d)),
		max(min(c,e.a),min(d,e.c)),max(min(c,e.b),min(d,e.d))};
	}
}s1[2000005];
struct matrix2{
	int a,b,c,d;
	matrix2 operator *(matrix2 e){
		return matrix2{min(max(a,e.a),max(b,e.c)),min(max(a,e.b),max(b,e.d)),
		min(max(c,e.a),max(d,e.c)),min(max(c,e.b),max(d,e.d))};
	}
}s2[2000005];
int n;
int a[500005];
#define inf 1'000'000'000'000'000'000ll
void build(int l,int r,int p){
	if(l==r){
		int x=a[l]+a[l-1];
		if(a[l]>a[l-1])s1[p]={inf,inf,x,0},s2[p]={0,x,0,inf};
		else if(a[l]<a[l-1])s1[p]={0,inf,x,inf},s2[p]={inf,x,0,0};
		else s1[p]={0,inf,x,0},s2[p]={inf,x,0,inf};
		return;
	}
	int m=(l+r)>>1;
	build(l,m,p*2+1);build(m+1,r,p*2+2);
	s1[p]=s1[p*2+1]*s1[p*2+2];s2[p]=s2[p*2+1]*s2[p*2+2];
}
matrix1 query1(int l,int r,int s,int t,int p){
	if(l<=s&&t<=r)return s1[p];
	int m=(s+t)>>1;
	if(m>=r)return query1(l,r,s,m,p*2+1);
	if(m<l)return query1(l,r,m+1,t,p*2+2);
	return query1(l,r,s,m,p*2+1)*query1(l,r,m+1,t,p*2+2);
}
matrix2 query2(int l,int r,int s,int t,int p){
	if(l<=s&&t<=r)return s2[p];
	int m=(s+t)>>1;
	if(m>=r)return query2(l,r,s,m,p*2+1);
	if(m<l)return query2(l,r,m+1,t,p*2+2);
	return query2(l,r,s,m,p*2+1)*query2(l,r,m+1,t,p*2+2);
}
bool ok(int l,int r){
	matrix1 x=query1(l,r,1,n-1,0);matrix2 y=query2(l,r,1,n-1,0);
	return min(y.a,y.c)<max(x.a,x.c)||min(y.b,y.d)<max(x.b,x.d);
}
void Main() {
	cin>>n;
	REP(i,0,n)cin>>a[i];
	build(1,n-1,0);
	int ans=0,r=1;
	REP(i,0,n){
		r=max(r,i+1);
		while(r<n&&ok(i+1,r))++r;
		ans+=r-i-1;
	}
	cout<<ans<<endl;
}
```
~~主函数超短的好不好。~~

---

## 作者：masonpop (赞：2)

独立做出来了，很兴奋，记录一下。

省略了冗长且无脑的分类讨论过程。

首先假装 $L$ 已经确定了来尝试判合法性。大致讨论一下相邻两项分别取 $a_i$ 和 $2L-a_i$ 时能否满足大小关系，最后发现只需要按照 $a_i$ 和 $a_{i+1}$ 的大小关系以及 $a_i+a_{i+1}$ 和 $2L$ 的大小关系分四类，每一类都可以排除 $a_i$ 或 $a_{i+1}$ 的一种取值。然后无解情况显然就是 $a_i$ 两种取值同时被排除。于是考虑相邻三项 $a_{i-1},a_i,a_{i+1}$ 能推出什么。经过一些分类讨论，无解情形是以下三种之一：

① 相邻两项相同且和是 $2L$。

② $a_i$ 为这三项的波峰且 $a_{i-1}+a_i,a_i+a_{i+1}$ 均 $\ge2L$。

③ $a_i$ 为这三项的波谷且 $a_{i-1}+a_i,a_i+a_{i+1}$ 均 $\le 2L$。

后两种情形就相当于把 $2L$ 的取值区间与一个开区间求交。因此只需判断最后交出来的开区间是否为空即可。这时发现第一种也不用判了，因为开区间不为空那么从中去掉有限个点后也一定非空。

注意到显然左端点固定时右端点有单调性，于是用 ST 表维护区间交然后直接双指针就做完了。复杂度 $O(n\log n)$。

---

## 作者：Harry27182 (赞：2)

一个智商不够，数据结构来凑的做法。

发现值域很大，并且 $L$ 的取值是实数域，枚举 $L$ 显然是不现实的。我们套路地考虑求出 $L$ 的取值范围，只要不为空集就是合法。根据这种题的经典套路，可以大胆猜测 $L$ 的合法取值点是一个区间。通过打表等方式知道，这个结论在 $h_i$ 互不相同的时候是正确的。如果 $h_i$ 有相邻两个相同，那么 $L$ 是不能取这个值的。不过由于 $L$ 的取值范围是实数域，所以扣去一个单点对结果没有影响，可以简单地忽略这种情况。

考虑朴素 dp。设 $dp_{i,0/1}$ 表示考虑到第 $i$ 位，这一位是否变为 $2L-h_i$ 时 $L$ 的范围，一个状态表示的是一个区间。转移比较简单，分类讨论一下即可，在此不再赘述。朴素做法的时间复杂度是 $O(n^2)$，期望得分 $44$ 分。

转移的形式比较简单，考虑矩阵乘法优化。我们需要做的是一个 $\min/\max$ 卷积和一个 $\max/\min$ 卷积。由于 $\max(\min(a,b),\min(a,c))=\min(a,\max(b,c))$，所以上述卷积形式满足结合律，可以使用广义矩阵乘法优化 dp。线段树每一个节点维护这一段区间的转移矩阵的乘积，每次查询一个区间的 dp 值直接在线段树上查询即可。又因为合法区间显然满足单调性，所以可以双指针，时间复杂度 $O(n\log n)$，虽然常数比较大，但是可以轻松通过本题。

```
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,w[500005],ans;
struct matrix{pair<int,int> a[2][2];}a[500005],tr[2000005];
matrix operator *(matrix x,matrix y)
{
	matrix res;
	res.a[0][0]=res.a[0][1]=res.a[1][0]=res.a[1][1]={1e18,-1e18};
	for(int i=0;i<2;i++)
	{
		for(int j=0;j<2;j++)
		{
			for(int k=0;k<2;k++)
			{
				res.a[i][j].first=min(res.a[i][j].first,max(x.a[i][k].first,y.a[k][j].first));
				res.a[i][j].second=max(res.a[i][j].second,min(x.a[i][k].second,y.a[k][j].second));
			}
		}
	}
	return res;
}
void build(int k,int l,int r)
{
	if(l==r){tr[k]=a[l];return;}
	int mid=(l+r)>>1;
	build(k<<1,l,mid);build(k<<1|1,mid+1,r);
	tr[k]=tr[k<<1]*tr[k<<1|1];
}
matrix query(int k,int l,int r,int x,int y)
{
	if(x<=l&&r<=y)return tr[k];
	int mid=(l+r)>>1;
	if(y<=mid)return query(k<<1,l,mid,x,y);
	if(x>mid)return query(k<<1|1,mid+1,r,x,y);
	return query(k<<1,l,mid,x,y)*query(k<<1|1,mid+1,r,x,y);
}
bool check(int l,int r)
{
	matrix now=query(1,1,n-1,l,r-1);
	if(min(now.a[0][0].first,now.a[1][0].first)<max(now.a[0][0].second,now.a[1][0].second))return 1;
	if(min(now.a[0][1].first,now.a[1][1].first)<max(now.a[0][1].second,now.a[1][1].second))return 1;
	return 0;
}
signed main()
{
	cin.tie(0)->sync_with_stdio(0);
	cin>>n;
	for(int i=1;i<=n;i++)cin>>w[i];
	for(int i=1;i<n;i++)
	{
		a[i].a[0][0]=a[i].a[0][1]=a[i].a[1][0]=a[i].a[1][1]={1e18,-1e18};
		if(w[i]<w[i+1])a[i].a[0][0]={-1e18,1e18};
		if(w[i]>w[i+1])a[i].a[1][1]={-1e18,1e18};
		a[i].a[1][0]={-1e18,w[i]+w[i+1]};
		a[i].a[0][1]={w[i]+w[i+1],1e18};
	}
	build(1,1,n-1);
	for(int i=1,r=2;i<n;i++)
	{
		r=max(r,i+1);
		while(r<n&&check(i,r+1))r++;
		ans+=r-i;
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：苏联小渣 (赞：2)

题意：

给定序列 $a$，询问有多少子区间 $[l,r]$ 满足：

- 存在**正实数** $L$ 和序列 $c_l,...,c_r$，满足 $c_i \in \{a_i,2L-a_i\}$ 且 $c_l,...,c_r$ 严格单调递增。

$1 \le n \le 5 \times 10^5,1 \le a_i \le 10^{12}$。

题解：

场上差点切了，很遗憾。

考虑给定 $2L$ 怎么判断：设 $f_{i,0}$ 表示 $c_i=a_i$ 能否可行，$f_{i,1}$ 表示 $c_i=2L-a_i$ 能否可行。直接转移可以对一个区间 $O(n)$ 判断。

考虑到有用的 $L$ 不会太多，那么看一下什么时候 $L$ 是有用的。我们分类讨论：

- $f_{i,0} \to f_{i+1,0}$，需要 $a_i<a_{i+1}$。

- $f_{i,1} \to f_{i+1,1}$，需要 $a_i>a_{i+1}$。

- $f_{i,0} \to f_{i+1,1}$，需要 $a_i<2L-a_{i+1}$，即 $2L>a_{i}+a_{i+1}$。

- $f_{i,1} \to f_{i+1,0}$，需要 $2L-a_{i} < a_{i+1}$，即 $2L<a_i+a_{i+1}$。

即我们可以得到 $O(n)$ 个关于 $2L$ 的不等式，由于是开区间所以加上或者减去 $0.5$ 即可，当然 $\times 2$ 也可以。

对这 $O(n)$ 个 $2L$ 每次 $O(n^2)$ check，时间复杂度 $O(n^3)$，期望得分 $24$ 分。

考虑从 dp 转移的角度优化：发现事实上这是一个可达性问题，而显然对于一个 $l$，能够到达的 $r$ 一定是一个连续的区间，且 $l_1 \le l_2,r_1 \le r_2$。考虑从图论的角度转化，假设 $f_{i,x}$ 能到达 $f_{i+1,y}$，那么给 $(i,x),(i+1,y)$ 连一条边，最后询问每个 $i$，$(i,0),(i,1)$ 所在的连通块能到达的最右的点是什么。显然可以倒着扫一遍做到 $O(n^2)$，期望得分 $44$ 分。

我们发现问题已经转化成了，断边、加边，查询一个点所在的连通块点编号的最大值。考虑一条边会在什么时候出现：

- $f_{i,0} \to f_{i+1,0}$，满足 $a_i<a_{i+1}$ 即可。

- $f_{i,1} \to f_{i+1,1}$，满足 $a_i>a_{i+1}$ 即可。

- $f_{i,0} \to f_{i+1,1}$，满足 $2L>a_{i}+a_{i+1}$ 即可。

- $f_{i,1} \to f_{i+1,0}$，满足 $2L<a_i+a_{i+1}$ 即可。

第一、二类一开始就可以连上；对于第三、四类，假如我们把 $2L$ 按照从小到大排序，它们的影响区间只会是一个前缀和一个后缀，不难联想到线段树分治，按照排序后的 $2L$ 的下标建立线段树，把这条边挂到线段树的前/后缀的 $O(\log n)$ 个结点上，对于加边，容易发现它只会对两个连通块能到达的最右端的点产生影响，而每个连通块在序列上都是一个区间，所以就变成了区间取 $\max$，最后单点查询一次。对于撤销，用可撤销并查集记录历史信息即可。用线段树和并查集直接实现，时间复杂度 $O(n \log^2 n)$，由于常数有点大所以实际得分 $76$ 分。

由于并查集常数小无所谓，所以考虑从线段树的角度优化。容易发现我们做的事情是区间取 $\max$，最后才单点查询，根据经典套路在 ST 表上取 $\max$，最后从大区间推小区间，即可做到只有并查集的小常数 $O(n \log^2 n)$（其实也可以当成 $O(n \log n)$），实际得分 $100$ 分，最慢点跑了 700ms。

代码拍了照，找时间抄一遍。

---

## 作者：hy233 (赞：1)

来点没人和我一样的逆天做法。

设相邻两个位置的数为 $u=h_i,v=h_{i+1}$，对应的像为 $u',v'$。则：

| 转移 | 限制 |
| :----------: | :----------: |
| $u \to v$ | $u<v$ |
| $u' \to v'$ | $u>v$ |
| $u \to v'$ | $L>\frac{u+v}{2}$ |
| $u' \to v$ | $L<\frac{u+v}2$ |
发现对 $L$ 的限制只有 $O(n)$ 种，可以将值域分为 $O(n)$ 段并枚举。

考虑一种分治做法计算答案：对于跨过分治中心的区间，枚举  $mid$ 和 $mid+1$ 的石柱状态和 $L$ 的值域，合法答案是左区间的一段后缀和右区间的一段前缀（可以预处理）。不同的答案使用单调栈简单合并一下。复杂度为 $O(n^2\log n)$。

我们发现，枚举值域段这件事情可以放到分治内部去做，对于一个分治区间，由于区间内的限制只有区间长度个，值域段也只有区间长度个。大概怎么双指针维护合并一下就好。

于是做完了，复杂度 $O(n\log n)$。

可能需要小卡一下时间和空间常数，`vector` 害人不浅。

最后赛时大样例0.9s，险胜！

---

## 作者：JWRuixi (赞：1)

# [WC/CTS2024] 水镜

## 题目描述

给定一个长度为 $n$ 的正整数序列 $h_1, h_2,\cdots , h_n$，求满足以下所有条件的二元组 $(u, v)$ 的数量：

- $1 \le u < v \le n$，且 $u, v$ 为整数；
- 存在一个**正实数** $L$ 以及一个长度为 $(v - u + 1)$ 的序列 $r_u, r_{u+1},\cdots , r_v$ 满足以下所有条件：
  - $\forall u \le i \le v$，记 $h'_i = 2L - h_i$，则 $r_i \in \{h_i,h'_i\}$，特别地，当 $h_i = h'_i$ 时，$r_i = h_i$；
  - $\forall u \le i < v, r_i < r_{i+1}$。

数据范围：$2\le n\le 5\times 10^5, h_i \le 10^{12}$。

## 分析

假设已经选定了 $L$，我们试图刻画一种简洁的判定区间合法性的方法。

记 $p_i = \max(h_i, 2L - h_i)$，我们断言：一个区间合法当且仅当其对应的 $p$ 序列是**单谷**的（即存在 $t \in [l, r]$，满足 $p_l > p_{l + 1} > \dots > p_t \ ? \ p_{t + 1} < \dots < p_{r - 1} < p_r$）。

证明：显然由于 $p$ 表示的是关于 $L$ 对称的两点中的较大值，所以 $L < \min\limits_{l \le i \le r}p_i$，那么如果存在峰，枚举一下决策就能发现一定无法使其变成单调的，那么序列只能是单谷的。

然而这个限制牵扯到的变量太多，正难则反，考虑不合法序列的特征，满足 $\exist i \in (l, r), p_{i - 1} \le p_i \ge p_{i + 1}$，不难发现这是充要的。

我们不妨考虑 $p_{i - 1}$ 和 $p_i$ 之间的关系与 $L$ 取值的影响，不妨 $h_i < h_{i + 1}$：

- $L \le \dfrac{h_i + h_{i + 1}}{2}$，则 $p_i \ge p_{i + 1}$；
- $L > \dfrac{h_i + h_{i + 1}}{2}$，则 $p_i < p_{i + 1}$。

**注意 $h_i > h_{i + 1}$ 时符号取反，$h_i = h_{i + 1}$ 时是全集**。

不难发现一个点不合法的条件是 $L$ 属于某一个区间，记为 $S_i$。

考虑扫描线，从小到大枚举 $r$ 端点，找到所有的 $l$ 满足区间 $[l, r]$ 不合法。注意到对于固定的 $r$，$l$ 的取值一定是一段前缀，所以只需要找到**最大**的 $l$ 满足 $[l, r]$ 不合法即可。

如果一个区间不合法，说明 $\bigcup\limits_{l < i < r}S_i = U$。考虑维护每一个 $L$ 的取值**最后一次**是被哪个区间覆盖的，那么**全局最小值**就是答案。

观察到实际上 $L$ 在的取值可以分为 $\mathcal O(n)$ 个等价类（分为 $n - 1$ 个端点和中间区域两类），所以离散化后考虑用线段树维护，支持区间覆盖、全局查最小值。

时间复杂度 $\mathcal O(n\log n)$。

## Code

提交记录：<https://pastebin.com/fLvKiZWr>。

---

## 作者：pikiuk (赞：1)

直观上显然对于一个区间 $[l,r]$，若有合法的 $L$，则其取值范围一定是一个区间，而又有区间越长，显然关于 $L$ 的限制越严格，因此我们只要有办法快速求出一个区间的 $L$ 对应的取值范围，就能用二分或双指针的办法求出答案。

考察连续的三个数 $x,y,z$，则有：

- 若 $x\leq y\leq z$ 或 $x\geq y\geq z$，则显然不论 $L$ 取何值，都存在一种构造使得这三个数满足题目要求。

- 若 $x\leq y\geq z$，则若 $L<y$，那么也一定存在一个构造，考虑 $L\geq y$ 的情况，分类讨论：

  - $x$ 或 $y$ 沿 $L$ 翻转：则有 $2L-x<y$ 或 $2L-y>x$，得到限制 $2L\neq x+y$。注意到由于取值是实数区间，因此扣掉若干个单点并不影响是否有值，不需要考虑这条限制。
  - 若 $y$ 沿 $L$ 翻转，则应满足 $2L-y < z$，那么有 $2L<y+z$。
  - 若 $x$ 翻转且 $y$ 不翻转，则有 $2L-x<y$，即 $2L<x+y$。

  那么综上有 $2L<\max (x+y,y+z)$。

- 对于 $x\geq y\leq z$ 的讨论是对称的，不做赘述。

我们用数据结构维护区间最值，注意到由于必须同时包含 $x,y,z$ 三个数才会带来对应的约束，一种解决办法是把限制挂在 $y$ 的下标上，查询时查询 $[l+1,r-1]$。

注意到实际上可能出现 $x=y=z$ 的情况，不过如果区间内某个值重复出现了超过三次，那么一定不合法，因此提前用双指针判掉某个值出现超过三次的区间即可。

综合时间复杂度 $\mathcal{O}(n\log n)$，可以运用 baka's trick 做到线性。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 5e5 + 7, W = 21;
using i64 = long long;
const i64 inf = 0x3f3f3f3f3f3f3f3f;

int n, R[N], R2[N];
i64 a[N], mn[W][N], mx[W][N];
map<i64, int> mp;

void init () {
	for (int o = 1; o < W; o ++) {
		for (int i = 1; i + (1 << o) - 1 <= n; i ++) {
			mn[o][i] = min (mn[o - 1][i], mn[o - 1][i + (1 << (o - 1))]),
			mx[o][i] = max (mx[o - 1][i], mx[o - 1][i + (1 << (o - 1))]);
		}
	}
}

bool check (int x) {
	return ((a[x - 1] >= a[x] and a[x] <= a[x + 1]) or (a[x - 1] <= a[x] and a[x] >= a[x + 1]));
}

bool check (int l, int r) {
	l ++;
	r --;
	int k = __lg (r - l + 1);
	if (l > r) return 1;
	i64 vL = max (mx[k][l], mx[k][r - (1 << k) + 1]);
	i64 vR = min (mn[k][l], mn[k][r - (1 << k) + 1]);
	return vL < vR;
}

int main () {
	cin >> n;
	for (int i = 1; i <= n; i ++)
		cin >> a[i];
	
	for (int i = 1, r = 0, cnt = 0; i <= n; i ++) {
		for (; r < n and ! cnt; ) {
			r ++;
			mp[a[r]] ++;
			if (mp[a[r]] == 3) cnt ++;
		}
				
		if (cnt) {
			mp[a[r]] --;
			assert (mp[a[r]] == 2);
			cnt --;
			r --;
		}

		
		assert (! cnt);
		R2[i] = r;
		mp[a[i]] --;
		assert (R2[i] <= n);
	}
	
	for (int i = 1; i + 2 <= n; i ++) {
		if (check (i + 1)) {
			if (a[i] >= a[i + 1] and a[i + 1] <= a[i + 2]) mn[0][i + 1] = max (a[i] + a[i + 1], a[i + 1] + a[i + 2]);
			else mx[0][i + 1] = min (a[i] + a[i + 1], a[i + 1] + a[i + 2]);
		}
	}
	
	for (int i = 1; i <= n; i ++) {
		if (! mn[0][i]) mn[0][i] = inf;
		if (! mx[0][i]) mx[0][i] = -inf;
	}
	
	init ();
	
	for (int i = 1; i <= n; i ++) {
		i64 vL = -inf, vR = inf;
		R[i] = min (i + 1, n);
		int l = min (i + 2, R2[i]), r = R2[i], pos = i + 1;
		while (l <= r) {
			int mid = (l + r) >> 1;
			if (check (i, mid)) pos = mid, l = mid + 1;
			else r = mid - 1;
		}
		
		R[i] = pos;
	}
	
	i64 ans = 0;
	for (int i = 1; i <= n; i ++) ans = ans + (R[i] - i);
	cout << ans << "\n";
}
```



---

## 作者：wrkwrkwrk (赞：1)

注意到如果 $2L$ 确定，那么可以按照如下方式 $\mathcal{O}(n)$ 时间内确定答案。

定义 $dp_{i,0/1}$ 表示右端点为 $i$，使用 $h_i/2L-h_i$ 为结尾的序列的最小左端点。

- 初值均为 $i$。
- 若 $h_{i-1}<h_i$，则 $dp_{i,0}$ 可取 $dp_{i-1,0}$。
- 若 $2L-h_{i-1}<h_i$，则 $dp_{i,0}$ 可取 $dp_{i-1,1}$。
- 若 $2L-h_{i-1}<2L-h_i$（即 $h_{i-1}>h_i$），则 $dp_{i,0}$ 可取 $dp_{i-1,1}$。
- 若 $h_{i-1}<2L-h_i$，则 $dp_{i,0}$ 可取 $dp_{i-1,1}$。
- 综合每次考虑的 $2L$，记 $c_i$ 为右端点为 $i$，可能的 $dp_{i,0/1}$ 的最小值，答案为 $\sum_{i=1}^{n}(i-c_i)$。

将这个转移关系画成一张图，如图所示

![](https://cdn.luogu.com.cn/upload/image_hosting/3xt5a8il.png)

观察可得性质：
- 二元组 $(u,v)$ （$1\leq u < v \leq n$，下同）合法，当且仅当 $dp_{u,0/1}$ 和 $dp_{v,0/1}$ 有至少一条路径。
- 若二元组 $(u,v)$ 合法，则 $\forall (l,r),u\leq l< r\leq v$，二元组 $(l,r)$ 合法。

由第二条联想到可以用双指针处理问题。

由于 $dp_{i,0}$ 是否可取 $dp_{i-1,0}$，$dp_{i,1}$ 是否可取 $dp_{i-1,1}$ 与 $L$ 的取值无关，则 $h_{i-2}<h_{i-1}<h_i$ 或者 $h_{i-2}>h_{i-1}>h_i$ 时 $i-2$ 和 $i$ 必然连接。

考虑如下情况：

- $h_{i-2}\leq h_{i-1}\geq h_i$，此时不考虑 $2L$ 取值，转移关系至多如图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/828h51mg.png)

此时若 $i-2$ 和 $i$（即图示中的 $1$ 和 $3$）相连，则 $dp_{i-2,0}$ 和 $dp_{i-1,1}$ 有边或者 $dp_{i-1,0}$ 和 $dp_{i,1}$ 有边，第一个条件要求 $h_{i-2}<2L-h_{i-1}$，第二个条件要求 $h_{i-1}<2L-h_{i}$，则为了满足要求，至少应 $2L>\min(h_{i-2}+h_{i-1},h_{i-1}+h_i)$。

- $h_{i-2}\geq h_{i-1}\leq h_i$，此时不考虑 $2L$ 取值，转移关系至多如图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/vb9ntb54.png)

此时若 $i-2$ 和 $i$ 相连，则 $dp_{i-2,1}$ 和 $dp_{i-1,0}$ 有边或者 $dp_{i-1,1}$ 和 $dp_{i,0}$ 有边，第一个条件要求 $2L-h_{i-2}<h_{i-1}$，第二个条件要求 $2L-h_{i-1}<h_{i}$，则为了满足要求，至少应 $2L<\max(h_{i-2}+h_{i-1},h_{i-1}+h_i)$。

将以上条件综合，可发现 $2L$ 的取值一定是一个区间，使用两个 set 即可维护。

最后，可能存在部分取值使得 $i-1$ 和 $i$ 不连通的情况（比如若 $h_{i-1}=h_i$，则 $2L$ 不能取 $2h_i$），但是由于可取的区间一定是无穷集或空集，所以不对答案造成影响。

code：
```cpp
#include<bits/stdc++.h>
using namespace std;
 
const long long inf=1e18;
int n;
long long h[500005];	
multiset<long long>a={-inf},b={inf};
void ad(int po){
	if(po>=3&&po<=n){
		if(h[po-2]<=h[po-1]&&h[po-1]>=h[po]){
			a.insert(min(h[po-2]+h[po-1],h[po-1]+h[po]));
		}	
		if(h[po-2]>=h[po-1]&&h[po-1]<=h[po]){
			b.insert(max(h[po-2]+h[po-1],h[po-1]+h[po]));
		}
	}
}
void re(int po){
	if(po>=3&&po<=n){
		if(h[po-2]<=h[po-1]&&h[po-1]>=h[po]){
			a.erase(a.find(min(h[po-2]+h[po-1],h[po-1]+h[po])));
		}
		if(h[po-2]>=h[po-1]&&h[po-1]<=h[po]){
			b.erase(b.find(max(h[po-2]+h[po-1],h[po-1]+h[po])));
			
		}
	}
}
int main(){
	cin>>n; 
	for(int i=1;i<=n;i++)cin>>h[i];
	long long ans=0;
	int r=2;
	for(int l=1;l<n;l++){
		if(l==r){
			r++;
			ad(r); 
		}
		re(l+1);//即清除 l+1 和 l-1 的连接对答案造成的影响
		while(r<=n&&*a.rbegin()<*b.begin()){
			r++;
			ad(r);
		}
		re(r);
		r--;
		ans+=r-l;
	}
	cout<<ans;
	return 0;
}

```




---

## 作者：王熙文 (赞：1)

提供一个我赛时想出来的神秘做法，但是好像挺自然的。

## 思路

下文用 $L$ 代替 $2L$。

首先将相邻的两个 $i,i+1$ 选择集合中的哪个分类讨论，设 $0$ 表示选择了 $a_i$，$1$ 表示 $L-a_i$。

* $00:a_i<a_{i+1}$
* $01:a_i<L-a_{i+1} \iff L>a_i+a_{i+1}$
* $10:L-a_i<a_{i+1} \iff L<a_i+a_{i+1}$
* $11:L-a_i<L-a_{i+1} \iff a_i>a_{i+1}$

考虑建立一个图，一共有 $2n$ 个点，每个位置有两个点分别表示选了 $0$ 或 $1$。对于相邻两个能够满足条件的选择方式连边。那么如果只考虑 $00,11$ 会形成上下两条断断续续的线，由若干条线段组成，且上下的边不重合。

此时如果贪心地将 $01,10$ 连边并使用二分、ST 表等方法做会导致细节太多，所以考虑使用一些手段，比如 dp 来防止细节。

考虑最终的连边形态一定是，从一条上面的线段连向下面的线段，再连向上面的线段，一直连下去。这样一定会连到所有的线段。连边过程中 $01$ 中的 $\max\{a_i+a_{i+1}\}$ 是 $L$ 的最小值，$10$ 中的 $\min\{a_i+a_{i+1}\}$ 是 $L$ 的最大值。根据上面观察的形态，可以发现最小值和最大值是独立的，即存在一条路径既使 $\max$ 最小，又使 $\min$ 最大。

其实有一种特殊情况这两者不是独立的：

![](https://cdn.luogu.com.cn/upload/image_hosting/nlm63m3c.png?x-oss-process=image/resize,m_lfit,h_1700,w_2250)

灰色的线是 $10$ 和 $01$ 取到最大、最小值时的路径。但是此时一定不合法，因为前者的 $\min$ 中至少有 $a_i+a_{i+1}$，后者的 $\max$ 中也至少有这个数，所以前者一定小于等于后者，不合法。所以剩下的情况也一定不合法。

所以可以分别对 $10$、$01$ 求出取到最大、最小值的路径。考虑 dp。设 $f_{i,0/1}$ 表示 $10$ 取到最大值的路径，$g_{i,0/1}$ 表示 $01$ 取到最小值的路径，则：

$$f_{i,0}=\left\{\begin{array}{l}\max(f_{i-1,0},\min(f_{i-1,1},a_{i-1}+a_i)) & a_{i-1}<a_i\\ \min(f_{i-1,1},a_{i-1}+a_i) & a_{i-1} \ge a_i\end{array}\right.$$

$$f_{i,1}=\left\{\begin{array}{l}\max(f_{i-1,0},f_{i-1,1}) & a_{i-1}>a_i\\ f_{i-1,0} & a_{i-1} \le a_i\end{array}\right.$$

$$g_{i,0}=\left\{\begin{array}{l}\min(g_{i-1,0},g_{i-1,1}) & a_{i-1}<a_i\\ g_{i-1,1} & a_{i-1} \ge a_i\end{array}\right.$$

$$g_{i,1}=\left\{\begin{array}{l}\min(\max(g_{i-1,0},a_{i-1}+a_i),g_{i-1,1}) & a_{i-1}>a_i\\ \max(g_{i-1,0},a_{i-1}+a_i) & a_{i-1} \le a_i\end{array}\right.$$

发现如果将状态变成矩阵，转移过程是一个 $\max-\min$ 矩阵乘法。考场上差点以为这玩意不可做，然而写一个程序发现它具有结合律。下面是这个矩阵乘法有结合律的证明：考虑三个矩阵相乘，最终一个位置 $(i,l)$ 一定来自某三个 $(i,j),(j,k),(k,l)$ 取 $\min$ 贡献过来的（对于这些贡献的值取 $\max$），因为 $\min$ 有结合律所以矩阵乘法也有。

这样就可以将转移过程看成矩阵乘法，使用线段树维护区间矩阵之积，并在线段树上二分最后一个 $\max(f_{i,0},f_{i,1})>\min(g_{i,0},g_{i,1})$ 的位置即可。

为了好写可以先填充若干个每个位置都是正无穷或负无穷的矩阵，并倒序加入转移矩阵，直接在整颗树上二分。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,a[500010];
struct Matrix
{
	int n=2;
	int a[2][2];
	Matrix operator * (Matrix x) const
	{
		Matrix ans; memset(ans.a,-0x3f,sizeof(ans.a));
		for(int k=0; k<n; ++k)
		{
			for(int i=0; i<n; ++i)
			{
				for(int j=0; j<n; ++j) ans.a[i][j]=max(ans.a[i][j],min(a[i][k],x.a[k][j]));
			}
		}
		return ans;
	}
	Matrix operator / (Matrix x) const
	{
		Matrix ans; memset(ans.a,0x3f,sizeof(ans.a));
		for(int k=0; k<n; ++k)
		{
			for(int i=0; i<n; ++i)
			{
				for(int j=0; j<n; ++j) ans.a[i][j]=min(ans.a[i][j],max(a[i][k],x.a[k][j]));
			}
		}
		return ans;
	}
} tree[2000010][2],tmp[2];
void build(int now,int l,int r)
{
	tree[now][0]=tmp[0],tree[now][1]=tmp[1];
	if(l!=r)
	{
		int mid=l+r>>1;
		build(now<<1,l,mid),build(now<<1|1,mid+1,r);
	}
}
void upd(int now,int l,int r,int qx,Matrix qz[2])
{
	if(l==r) return tree[now][0]=qz[0],tree[now][1]=qz[1],void();
	int mid=l+r>>1;
	if(qx<=mid) upd(now<<1,l,mid,qx,qz);
	else upd(now<<1|1,mid+1,r,qx,qz);
	tree[now][0]=tree[now<<1][0]*tree[now<<1|1][0],tree[now][1]=tree[now<<1][1]/tree[now<<1|1][1];
}
int query(int now,int l,int r,Matrix qz[2])
{
	if(l==r)
	{
		Matrix gt[2]={qz[0]*tree[now][0],qz[1]/tree[now][1]};
		return l-(max(gt[0].a[0][0],gt[0].a[0][1])<=min(gt[1].a[0][0],gt[1].a[0][1]));
	}
	Matrix gt[2]={qz[0]*tree[now<<1][0],qz[1]/tree[now<<1][1]};
	int mid=l+r>>1;
	if(max(gt[0].a[0][0],gt[0].a[0][1])>min(gt[1].a[0][0],gt[1].a[0][1])) return query(now<<1|1,mid+1,r,gt);
	else return query(now<<1,l,mid,qz);
}
signed main()
{
	memset(tmp[0].a,0x3f,sizeof(tmp[0].a));
	memset(tmp[1].a,-0x3f,sizeof(tmp[1].a));
	ios::sync_with_stdio(false),cin.tie(0);
	cin>>n;
	for(int i=1; i<=n; ++i) cin>>a[i];
	build(1,1,n);
	int ans=0;
	for(int i=n; i>=1; --i)
	{
		ans+=query(1,1,n,tmp)-i;
		Matrix gt[2];
		if(a[i-1]<a[i]) gt[0].a[0][0]=1e18,gt[0].a[1][0]=a[i-1]+a[i];
		else gt[0].a[0][0]=-1e18,gt[0].a[1][0]=a[i-1]+a[i];
		if(a[i-1]>a[i]) gt[0].a[0][1]=1e18,gt[0].a[1][1]=1e18;
		else gt[0].a[0][1]=1e18,gt[0].a[1][1]=-1e18;
		if(a[i-1]<a[i]) gt[1].a[0][0]=-1e18,gt[1].a[1][0]=-1e18;
		else gt[1].a[0][0]=1e18,gt[1].a[1][0]=-1e18;
		if(a[i-1]>a[i]) gt[1].a[0][1]=a[i-1]+a[i],gt[1].a[1][1]=-1e18;
		else gt[1].a[0][1]=a[i-1]+a[i],gt[1].a[1][1]=1e18;
		upd(1,1,n,i,gt);
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：w9095 (赞：0)

[P10144 [WC/CTS2024] 水镜](https://www.luogu.com.cn/problem/P10144)

对于任何一段连续上升的区间，我们不需要管它。对于任何一段连续下降的区间，我们只需要用 $2L$ 减去每个数就可以化为一段连续上升的区间。因此，对于这两种区间，我们可以看作一个点。

于是，我们发现其实 $2L$ 只会被波峰 $a_{i}\ge a_{i-1},a_{i}\ge a_{i+1}$ 和波谷 $a_{i}\le a_{i-1},a_{i}\le a_{i+1}$ 限制住。我们考虑对于每个波峰和波谷，是否存在一种方式可以走过去。

对于一个波峰 $a_{i}\ge a_{i-1},a_{i}\ge a_{i+1}$，我们有两种方法：

第一种，$a_{i+1}\to2L-a_{i+1}$，这样就得满足 $2L-a_{i+1}\gt a_{i}$，即 $2L\gt a_{i}+a_{i+1}$。

第二种，$a_{i}\to2L-a_{i}$ 且 $a_{i+1}\to2L-a_{i+1}$，这种情况下显然 $a_{i+1}\gt a_i$。但是这样就得满足 $2L-a_{i}\gt a_{i-1}$，即 $2L\gt a_{i}+a_{i-1}$。

如果 $2L\gt a_{i}+\min(a_{i-1},a_{i+1})$，则一定存在上述两种方法中的一种可以走过这个波峰。

对于一个波谷 $a_{i}\le a_{i-1},a_{i}\le a_{i+1}$，我们有两种方法：

第一种，$a_{i-1}\to2L-a_{i-1}$ 且 $a_{i}\to2L-a_{i}$，这种情况下显然 $a_{i}\gt a_{i-1}$。这样就得满足 $2L-a_{i}\lt a_{i+1}$，即 $2L\lt a_{i}+a_{i+1}$。

第二种，$a_{i}\to2L-a_{i}$，这样就得满足 $2L-a_{i}\lt a_{i-1}$，即 $2L\lt a_{i}+a_{i-1}$。这里不需要管对 $a_{i+1}$ 的影响，因为在下一个波峰中会统计。

如果 $2L\lt a_{i}+\max(a_{i-1},a_{i+1})$，则一定存在上述两种方法中的一种可以走过这个波谷。

对于波峰套波峰或波峰套波谷一类的情况，这样也是对的。原因是这样的限制给了每个波峰和波谷两种选择方式，套起来的两个波峰或波谷一定有一种方式可以匹配。

最后，我们发现合法的区间可以使用双指针维护。上面的这些限制可以使用 `multiset` 来维护，支持插入，删除，查询最值。

时间复杂度 $O(n\log n)$，非常优秀。

```cpp
#include <bits/stdc++.h>
using namespace std;
long long n,a[600000],ans=0,j=3; 
multiset<long long>b,s;
void add(long long x)
{
	if(x==n)return;
	if(a[x]>=a[x-1]&&a[x]>=a[x+1])s.insert(-a[x]-min(a[x-1],a[x+1]));
	if(a[x]<=a[x-1]&&a[x]<=a[x+1])b.insert(a[x]+max(a[x-1],a[x+1]));
}

void del(long long x)
{
	if(x==n)return;
	if(a[x]>=a[x-1]&&a[x]>=a[x+1])s.erase(s.find(-a[x]-min(a[x-1],a[x+1])));
	if(a[x]<=a[x-1]&&a[x]<=a[x+1])b.erase(b.find(a[x]+max(a[x-1],a[x+1])));
}

int main()
{
	scanf("%lld",&n);
	for(int i=1;i<=n;i++)scanf("%lld",&a[i]);
	add(2);
	for(int i=1;i<=n;i++)
	    {
	    	if(i!=1)del(i);
	    	while((b.empty()||s.empty()||*b.begin()>-(*s.begin()))&&j<=n)add(j),j++;
			ans+=(j-i);
		}
	printf("%lld\n",ans-n);
	return 0;
}
```

---

## 作者：gdf_yhm (赞：0)

[P10144](https://www.luogu.com.cn/problem/P10144)

考场上瞪了两个小时什么没想到，最后半小时想到一个不太一样的做法，写出来了但挂了。寄。

### 思路

记 $l=2\times L$。令 $i$ 取 $a_i$ 记为 $0$，取 $l-a_i$ 记为 $1$，写为 01 序列。

考虑取 $0/1$ 对 $l$ 的上下界的影响。分类讨论转移，以 $a_i<a_{i+1}$ 为例。

- $i$ 取 $0$，$i+1$ 取 $0$：没影响；

- $i$ 取 $0$，$i+1$ 取 $1$：$l>a_i+a_{i+1}$；

- $i$ 取 $1$，$i+1$ 取 $0$：$l<a_i+a_{i+1}$；

- $i$ 取 $1$，$i+1$ 取 $1$：不合法；

这样可能存在一个状态有两个转移，不知道哪边更优。

瞪了两个小时观察发现在一段连续上升或下降的区间，肯定会连着取 $a_i$ 或 $l-a_i$，即连续的 $00$ 或 $11$。而转角处向前向后其中一个间隔才可能存在 01 或 10。

然后发现并不存在一个状态得到两个交集非空且互不包含的转移，直接取两个的并即可。然后就可以用线段树维护区间左右两边的状态分别是什么。

考试的时候发现来不急了，写了二分右端点再线段树查询判断 $O(n\log^2 n)$，但 $a_i=a_{i+1}$ 注意到了但特判错了，寄。

考虑到右端点有单调性，从上一个答案向后判断即可，复杂度 $O(n\log n)$。

### code

```cpp
#define pii pair<int,int>

int n,a[maxn],ans;
struct nd{
	pii f[2][2];
}tree[maxn<<2];
void init(pii &u){
	if(u.first>=u.second)u=make_pair(inf,0);
}
void clr(nd &u){
	for(int i=0;i<2;i++){
		for(int j=0;j<2;j++)init(u.f[i][j]);
	}
}
pii mymin(pii u,pii v){
	init(u),init(v);
	return {max(u.first,v.first),min(u.second,v.second)};
}
pii mymax(pii u,pii v){
	init(u),init(v);
	return {min(u.first,v.first),max(u.second,v.second)};
}
nd merge(nd u,nd v){
	nd res;
	for(int i=0;i<2;i++){
		for(int j=0;j<2;j++){
			res.f[i][j]=mymax(mymin(u.f[i][0],v.f[0][j]),mymin(u.f[i][1],v.f[1][j]));
			init(res.f[i][j]);
		}
	}
	return res;
}
#define mid (l+r>>1)
#define ls o<<1
#define rs o<<1|1
void build(int o,int l,int r){
	if(l==r){
		tree[o].f[0][0]=tree[o].f[1][1]={inf,0};
		tree[o].f[0][1]={a[l]+a[l+1],inf};
		tree[o].f[1][0]={0,a[l]+a[l+1]};
		if(a[l]<a[l+1])tree[o].f[0][0]={0,inf};
		if(a[l]>a[l+1])tree[o].f[1][1]={0,inf};
		return ;
	}
	build(ls,l,mid),build(rs,mid+1,r);
	tree[o]=merge(tree[ls],tree[rs]);
	clr(tree[o]);
}
nd query(int o,int l,int r,int ql,int qr){
	if(l>=ql&&r<=qr)return tree[o];
	if(qr<=mid)return query(ls,l,mid,ql,qr);
	if(ql>mid)return query(rs,mid+1,r,ql,qr);
	nd res=merge(query(ls,l,mid,ql,qr),query(rs,mid+1,r,ql,qr));
	clr(res);
	return res;
}
bool check(int l,int r){
	nd res=query(1,1,n-1,l,r-1);
	for(int i=0;i<2;i++){
		for(int j=0;j<2;j++){
			if(res.f[i][j].first<res.f[i][j].second)return true;
		}
	}
	return false;
}
#undef mid

signed main(){
	n=read();
	for(int i=1;i<=n;i++)a[i]=read();
	build(1,1,n-1);
	for(int i=1,r=0;i<=n;i++){
		if(r<i)r=i;
		while(r<n&&check(i,r+1))r++;
		ans+=r-i;
		// cout<<i<<" "<<r<<"\n";
	}
	printf("%lld\n",ans);
}
```

---

## 作者：ExplodingKonjac (赞：0)

**[【原题链接】](https://www.luogu.com.cn/problem/P10144)**

一个抽象做法。

## 题目分析

简单分析之后可以得到，一段区间合法当且仅当 $|a_i-L|$ 是一个严格递减段拼上一个严格递增段，其中段均可以为空。

然后我们进行大胆猜想：

> Observation: 
> 
> 对于每一个区间，使其合法的 $L$ 对应一段区间。

那么我们就可以利用经典的点减边小技巧。将有用的 $L$ 离散化，然后枚举每个 $x$，计算 $L=x$ 时合法的区间数并求和，记作 $s_1$；计算当 $L\in[x,x+1]$ 时均合法的区间数并求和，记作 $s_2$。那么答案就是 $s_1-s_2$。

### Part 1: 计算 $s_1$

对于相邻两个位置 $i,i+1$，比较 $|a_i-L|,|a_{i+1}-L|$ 的大小，记作三种：$\texttt{>},\texttt{<},\texttt{=}$，且三种情况的出现均对应 $L$ 的某个区间。

于是我们可以边枚举 $x$ 边进行单点修改。

那么区间合法当且仅当其形如 $\texttt{>}\dots\texttt{><}\dots\texttt{<}$ 或者 $\texttt{>}\dots\texttt{>=<}\dots\texttt{<}$。

于是我们需要求这样子的区间数量。

这个问题可以在线段树上解决。复杂度 $O(n\log n)$。

### Part 2: 计算 $s_2$

问题实际上是类似的。如果对于相邻两个位置，如果 $L$ 取 $x,x+1$ 时大小关系均相同，和 Part 1 中的形式一样。否则，我们记作 $\texttt{?}$。

那么 $\texttt{?}$ 有先 $\texttt{>}$ 再 $\texttt{<}$，以及先 $\texttt{<}$ 再 $\texttt{>}$ 两种类型。可以发现合法的区间还可以是 $\texttt{>}\dots\texttt{>?}\dots\texttt{?<}\dots\texttt{<}$，且中间的 $\texttt{?}$ **类型必须相同**。

复杂一些，但仍然是线段树可以维护的。

### Part 3: 关于怎么维护

直接写信息合并会写出一坨屎山，很不推荐。

考虑模拟从左往右扫描一遍计算贡献，实时维护区间“走”到每一种状态的方案数，那么可以写成矩阵进行转移。设状态数是 $K$，那么复杂度 $O(nK^3\log n)$，无法通过。

进一步地，其实这个转移是一个自动机。我们实际上是要计数有多少个区间能够在自动机上走到接受态。于是我们在线段树的信息上维护：每种状态走到的状态、以每种状态进入后会给答案累加多少、以每种状态结束的方案数、当前答案。复杂度可以做到 $O(nK\log n)$。

### Part 4: Observation 的证明

~~It was verified by stress testing.~~

我认真的，看其它题解就知道了。

我在考场上压根没有完整地证明，拍不出错就当对了。

## 代码实现

需要代码的可以考虑穿越回 2024/2/1 然后去 A058 机子上拿。账号的密码是 `rqaxvc`。

---

## 作者：Purslane (赞：0)

# Solution

为啥我写个单 log 解法都得卡常？？我考场上写了这份代码，没过样例，然后我把删了。今天重写一遍，过了样例？但被卡常了。

UPD：并查集带 log。这下小丑了。那么我的代码是两只 log 的。

考虑我们建立出 $2n$ 个点的图，左边 $n$ 个点，右边 $n$ 个点，依次对齐。我们称左边点的编号为 $1$ 到 $n$，右边点的编号为 $n+1$ 到 $2n$。左边的点表示我们选择 $h_i$ 在最终的序列中。右边的点表示我们选择 $v-h_i$ 在最终的序列中。

这个图中边表示“一个数能放在另一个数后面”。那么相邻行之间的 $4$ 种连边分别对应如下情况：

- $i \to i+1$，如果 $h_i < h_{i+1}$。
- $i+n \to i+n+1$，如果 $h_i > h_{i+1}$。
- $i \to i+n+1$，如果 $h_i < v - h_{i+1}$，即 $v > h_i + h_{i+1}$。
- $i+1 \to i+n$，如果 $v<h_i+h_{i+1}$。

考虑 $v$ 事实上真正有区别的取值只有 $\dfrac{k}{2}$ 的形式，其中 $k$ 是正整数。所以考虑把所有的 $h$ 都乘上 $2$，于是下面的两条限制分别是 $v \ge h_i + h_{i+1} + 1$ 和 $v \le h_i + h_{i+1}-1$。

如果建立出这张图，我们就可以求出每个点沿着有向边走可以走到的最长路（或者记录最远到达哪一行对应的两个节点之一），然后对所有不同的 $v$ 取 $\max$ 就可以知道对于每个 $l$，最大的满足要求的 $r$ 是多少。

于是有一个很简单的 $O(n^2)$ 做法：把所有的 $v$ 拉出来离散化一下。

还有一个更简单的 $O(n \sqrt n)$ 做法。利用分块维护这个图的动态连通性。我考场上写了这个，没过。$150$ 行的代码正放在 cqyc 的电脑里面，恐怕已经给清掉了。

考场上曾经想过使用线段树分治。那么如何维护？

事实上，你把有向边当做无向边，然后维护连通块最浅行和最深行，记为 $l$ 和 $r$。每次你新合并出一个连通块的时候，给 $[l,r]$ 上所有点的最远到达和 $r$ 取 $\max$（观察到一个点最远到达至少是自己，相当于直接给 $[l,n]$ 这个区间取 $\max$。使用后缀和即可）。这样是 $O(n \log n)$ 的，稍加常数优化即可通过。

但是我在写这个做法的时候，不小心有一个细节写挂了，导致我以为这种做法是假的。而我构造了一个“反例”，而这个“反例”恰好是基于“有向边不能随便换成无向边”这一思路的。

其实我们只需要关系：合并两个连通块时，最浅的行一定可以到达最深的行吗？我画了一个这样的图：

![](https://s11.ax1x.com/2024/02/06/pF1K5UH.png)

很明显，如果我们新加入橙色的一条边，并不能保证最右边的那条线的顶端可以到达最左边那条线的底端。

不过稍微动动脑筋发现，这种唯一不合法的情况是不可能存在的。因为**我们的图只可能有两列点**，且**每条边只会连接相邻两行**，所以最右边这条线根本画不出来！

那么线段树分治就是合理的啦。

代码：

```cpp
#include<bits/stdc++.h>
#define ll long long
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
#define lson (k<<1)
#define rson (k<<1|1)
#define mid (l+r>>1)
using namespace std;
const int MAXN=5e5+10;
struct INFO {int id1,id2,fa,sze,mx,mn;};
int n,tot,tag[MAXN],fa[MAXN<<1],sze[MAXN<<1],mx[MAXN<<1],mn[MAXN<<1];
ll h[MAXN],lsh[MAXN<<1];
inline int find(const int k) {return (fa[k]==k)?k:(find(fa[k]));}
inline void merge(int u,int v,vector<INFO> &st) {
	int U=find(u),V=find(v);
	if(U==V) return ;
	if(sze[U]<sze[V]) swap(u,v),swap(U,V);
	st.push_back({U,V,fa[V],sze[U],mx[U],mn[U]});
	fa[V]=U,sze[U]+=sze[V],mn[U]=min(mn[U],mn[V]),mx[U]=max(mx[U],mx[V]);
	tag[mn[U]]=max(tag[mn[U]],mx[U]);
	return ;
}
inline void roll_back(vector<INFO>& st) {
	roff(i,(int)st.size()-1,0) {
		auto info=st[i]; int u=info.id1,v=info.id2;
		fa[v]=info.fa,sze[u]=info.sze,mx[u]=info.mx,mn[u]=info.mn;
	}
	return ;
}
struct Edge {
	pair<int,int> ed;
	int nxt;	
}edge[MAXN*40];
int itot,hd[MAXN<<3];
void add_edge(int u,pair<int,int> ed) {
	return edge[++itot]={ed,hd[u]},hd[u]=itot,void();
}
inline void insert(const int k,const int l,const int r,const int x,const int y,const pair<int,int> edge) {
	if(x<=l&&r<=y) return add_edge(k,edge),void();
	if(x<=mid) insert(lson,l,mid,x,y,edge);
	if(y>mid) insert(rson,mid+1,r,x,y,edge);
	return ;	
}
inline void solve(const int k,const int l,const int r) {
	vector<INFO> st;
	for(int i=hd[k];i;i=edge[i].nxt) merge(edge[i].ed.first,edge[i].ed.second,st);
	if(l!=r) solve(lson,l,mid),solve(rson,mid+1,r);
	roll_back(st);
	return ;
}
class IO_helper{
private:
	static const int L = 1 << 16;
	char in_buf[L], *in_st, *out_st;

	char _getc(){
		if (in_st == out_st)
		{
			out_st = (in_st = in_buf) + fread(in_buf, 1, L, stdin);
			if (in_st == out_st) return EOF;
		}
		return *in_st++;
	}
public:
	template <typename IntType>
	IO_helper &operator>>(IntType &x){
		bool ok=0;
		char c; while ((c = _getc()) < '0' || c > '9')ok|=c=='-';
		for (x = 0; c >= '0' && c <= '9'; c = _getc())
			x = x * 10 + c - '0';
		x=(ok?-x:x);
		return *this;
	}
} IO;
signed main() {
	IO>>n;
	ffor(i,1,n) IO>>h[i],h[i]<<=2;
	ffor(i,1,n-1) lsh[2*i-1]=h[i]+h[i+1],lsh[2*i]=h[i]+h[i+1]+1;
	lsh[2*n-1]=1,tot=2*n-1;
	sort(lsh+1,lsh+tot+1),tot=unique(lsh+1,lsh+tot+1)-lsh-1;
	ffor(i,1,n) fa[i]=i,fa[i+n]=i+n,sze[i]=sze[i+n]=1,mn[i]=mn[i+n]=mx[i]=mx[i+n]=i;
	vector<INFO> st;
	ffor(i,1,n-1) {
		if(h[i]<h[i+1]) merge(i,i+1,st);
		if(h[i]>h[i+1]) merge(i+n,i+n+1,st);
		int pos=lower_bound(lsh+1,lsh+tot+1,h[i]+h[i+1])-lsh-1;
		insert(1,1,tot,1,pos,{i+n,i+1});
		pos+=2;
		insert(1,1,tot,pos,tot,{i,i+n+1});
	}
	solve(1,1,tot);
	ffor(i,2,n) tag[i]=max(tag[i],tag[i-1]); 
	ll ans=0;
	ffor(i,1,n) ans+=max(0,tag[i]-i);
	cout<<ans;
	return 0;
}
```

你看我为了卡常还是付出了不少努力的。

---

## 作者：0xyz (赞：0)

场上做法。

不难发现如果 $(u,v)$ 是好的，那么 $(u,v-1)$ 也是好的。所以我们只要对于每个 $u$ 求出一个最大的 $v$ 即可，可以对 $u,v$ 双指针。

打表可以发现合法的 L 的取值范围是一段开区间，对于所有相邻的值 $a$ 和 $b$，只有 $(-\infty,a),(a,\frac{a+b}{2}),(\frac{a+b}{2},b),(b,\infty)$ 有本质区别。为了方便维护，直接将它们乘 2，以整数的方式维护。

我们在双指针的同时要快速查询每个区间合不合法，我这里用的是线段树。对于线段树上的每个点 $x$，维护一个 $2\times 2$ 的矩阵。$x_{i,j}$ 代表了区间左端点 $l$ 折还是不折，$j$ 代表右端点 $r$ 折还是不折。

主要的问题是区间合并，拿出相邻的两个元素 $a,b$。

无论 $a,b$ 关系如何，一定可以只折其中一个：

$$\begin{cases}2L-a<b\to 2L\in ls_{i,1}\land(-inf,a+b)\land rs_{0,j}&\text{a 折 b 不折}\\a<2L-b\to2L\in ls_{i,0}\land(a+b,inf)\land rs_{1,j}&\text{a 不折 b 折}\end{cases}$$

然后对于都折或者都不折的情况：

$$\begin{cases}\text{a<b 恒成立}\to 2L \in ls_{i,0}\land rs_{0,j} &a<b\\2L\in \emptyset&a=b\\\text{2L-a<2L-b 恒成立}\to 2L\in ls_{i,1}\land rs_{1,j}&a>b\end{cases}$$

所以 $x_{i,j}$ 就是上面所有情况的并。那么我们建树之后直接查询区间的 $x_{i,j}$ 的四个区间里是不是有一个不为空就可以了。虽然没有修改，但是由于空间原因不用 ST 表。

时间复杂度 $O(n\log n)$，空间复杂度 $O(n)$。

提示：不开 O2 只有 64 分，但是 WC 自动开 O2。

```cpp
#include<bits/stdc++.h>
#define F first
#define S second
using namespace std;
typedef long long ll;
typedef pair<ll,ll> P;
const ll z=1e18,inf=1e13,_=2e6+5;
ll n,a[_],ans;
struct N{P w[2][2];}s[_];
P O(P x,P y){
	if(x.F==z)return y;
	if(y.F==z)return x;
	return {min(x.F,y.F),max(x.S,y.S)};
}
P A(P x,P y){
	if(x.F==z||y.F==z||max(x.F,y.F)>=min(x.S,y.S))return {z,z};
	return {max(x.F,y.F),min(x.S,y.S)};
}
N mer(N x,N y,ll u,ll v){
	N p;
	for(ll i=0;i<2;i++)
		for(ll j=0;j<2;j++){
			p.w[i][j]=O(A(A(x.w[i][1],{-inf,u+v}),y.w[0][j]),A(A(x.w[i][0],{u+v,inf}),y.w[1][j]));
			if(u<v)p.w[i][j]=O(p.w[i][j],A(x.w[i][0],y.w[0][j]));
			if(u>v)p.w[i][j]=O(p.w[i][j],A(x.w[i][1],y.w[1][j]));
		}
	return p;
}
void build(ll x,ll l,ll r){
	if(l==r){
		s[x].w[0][0]=s[x].w[1][1]={-inf,inf};
		s[x].w[0][1]=s[x].w[1][0]={z,z};
		return;
	}
	ll d=(l+r)>>1;
	build(x<<1,l,d);build(x<<1|1,d+1,r);
	s[x]=mer(s[x<<1],s[x<<1|1],a[d],a[d+1]);
}
N query(ll x,ll l,ll r,ll ql,ll qr){
	if(ql<=l&&r<=qr)return s[x];
	ll d=(l+r)>>1;
	if(ql<=d&&d<qr)return mer(query(x<<1,l,d,ql,qr),query(x<<1|1,d+1,r,ql,qr),a[d],a[d+1]);
	if(ql<=d)return query(x<<1,l,d,ql,qr);
	else return query(x<<1|1,d+1,r,ql,qr);
}
bool ask(ll l,ll r){
	N p=query(1,1,n,l,r);
	return p.w[0][0].F<p.w[0][0].S||p.w[0][1].F<p.w[0][1].S||p.w[1][0].F<p.w[1][0].S||p.w[1][1].F<p.w[1][1].S;
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>n;
	for(ll i=1;i<=n;i++)cin>>a[i];
	build(1,1,n);
	for(ll i=1,j=1;i<=n;i++){
		while(j<n&&ask(i,j+1))j++;
		ans+=j-i;
	}
	cout<<ans<<'\n';
	return 0;
}
```

---

## 作者：ppip (赞：0)

[题目传送门](/problem/P10144)

先将 $h'$ 改为 $L-h$。

考虑查询整个序列是否符合要求怎么做。

首先有结论：如果存在一个 $L$，使得对于序列中任意相邻三个位置，都能找到一种选择单调的 $r$ 的方式，那么整个序列一定也可以。归纳证明即可，大概分讨一下三个位置六个数的大小关系。

现在我们只需要满足序列中任意相邻三个的限制。

同样的，对六个数之间的大小关系进行分讨，可以发现相邻三个数要能选出 $r$，其符合要求的 $L$ 一定是一个区间。于是问题转化为求若干区间的并是否为空，这是平凡的。

对于原问题，考虑尺取，每次需要支持加入一个区间，删除一个区间，查询当前所有区间的并是否为空。单调队列维护左端点最大值和右端点最小值即可。复杂度线性。

```cpp
#include <bits/stdc++.h>
using namespace std;
constexpr int N(5e5);
long long h[N+5],H[N+5];
int L[N+5],R[N+5],le[N+5];
template <typename Cp>
struct Q {
	int *a,q[N+5],L,R,e;
	void push(int x) {
		while (R-L&&Cp()(a[x],a[q[R-1]])) --R;
		q[R++]=x;
	}
	void pop(int x) { if (q[L]<=x) ++L;	}
	int operator()() { return R-L?a[q[L]]:e; }
	Q(int *x,int i):a{x},L{0},R{0},e{i} {}
};
Q<less<int>> tp(R,1e9);
Q<greater<int>> bt(L,0);
int main() {
	cin.tie(nullptr)->sync_with_stdio(false);
	int n;cin>>n;
	vector<long long> w;
	for (int i{1};i<=n;++i) cin>>h[i];
	for (int i{2};i<=n;++i) le[i]=(h[i]>h[i-1]?-1:h[i]<h[i-1]),H[i]=h[i]+h[i-1],w.push_back(H[i]);
	sort(w.begin(),w.end());
	w.erase(unique(w.begin(),w.end()),w.end());
	for (int i{2};i<=n;++i) H[i]=lower_bound(w.begin(),w.end(),H[i])-w.begin();
	int m(w.size());
	for (int i{3};i<=n;++i) {
		L[i]=0;R[i]=m;
		if (!le[i]&&!le[i-1]) swap(L[i],R[i]);
		if (le[i-1]>le[i]) R[i]=max(H[i-1],H[i]);
		if (le[i-1]<le[i]) L[i]=min(H[i-1],H[i])+1;
	}
	int r{1};
	long long ans{0};
	for (int l{1};l<=n;++l) {
		while (r<n) {
			if (r-l<1) ++r;
			else {
				int xl{max(bt(),L[r+1])},xr{min(tp(),R[r+1])};
				if (xl<=xr) ++r,bt.push(r),tp.push(r);
				else break;
			}
		}
		ans+=r-l;
		if (r>=l+2) bt.pop(l+2),tp.pop(l+2);
	}
	cout<<ans<<endl;
	return 0;
}
```

---


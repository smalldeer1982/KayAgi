# [Opoi 2024] 二十六点

## 题目背景

二十六点：

> 。 。 。 。 。 。 。 。 。 。 。 。 。
>
> 。 。 。 。 。 。 。 。 。 。 。 。 。

凑二十六点真好玩，而为了凑四道题，就有了这道权值只有 $26$ 种的凑数题。

## 题目描述


给你一棵有 $n$ 个结点的以 $1$ 为根的树 $T$，第 $i$ 个结点有一个颜色 $c_i$，${\tt a} \le c_i \le {\tt z}$，和一个值 $P_i$。

对于每一个点 $x$，**从它到它子树中每一个点**（注意顺序是从它本身到子树中的点）都有一条路径，一共有子树的大小条路径。

现在忽略掉这些路径中的第 $2$ 到第 $P_x$ 个的点，特别地，若 $P_x = 1$ 则不忽略任何点。将忽略后的路径当作一个序列，序列中每个点的权值为路径上点的 $c_i$，求**每一个点的所有序列最长不下降子序列长度的最大值**。

注: 若有路径 $j$ 上的节点数 $len_j < P_x$，则相当于忽略这条路径上除第一个点外的所有点。


## 说明/提示



### 样例一解释：

样例中树的形态：

![](https://cdn.luogu.com.cn/upload/image_hosting/6vbio7vo.png?x-oss-process=image/resize,h_450,m_lfit)

对于 $1$ 号节点：
$P_1=2$。

|  序列| 权值 | 最长不下降子序列长度 | 最长不下降子序列 |
| :----------: | :----------: | :----------: | :----------: |
| 1 | z | 1 | z |
| 1 3 | za | 1 |  z |
| 1 3 4 |  zab | 2  | ab |
| 1 3 5  |  zac | 2 |  ac   |
| 1 3 5 6 |  zaca | 2  | ac |
| 1 3 5 7 | zacd| 3 | acd  |

长度最长的最长不降子序列：acd。

$2$ 号节点和 $1$ 号节点同理。

对于 $3$ 号节点：
$P_3=1$。

|  序列| 权值 | 最长不下降子序列长度 | 最长不下降子序列 |
| :----------: | :----------: | :----------: | :----------: |
| 3 | a | 1 | a |
| 3 4 | ab | 1 |  ab |
| 3 5  |  ac | 2  | ac |
| 3 5 6  |  aca | 2 |  ac   |
|3 5 7   |  acd | 3  |acd |

长度最长的最长不降子序列：acd。

对于 $4,5,6,7$，它的所有序列中都只有它自己一个点，所以输出 $1$。
### 数据范围

本题采用 Subtask 计分。

| Subtask | Limit | Pts |
| :-----------: | :-----------: | :-----------: |
| 0 | $n \le 100$ | 5 |
| 1 | $n \le 2000$ | 15 |
| 2 | $\forall 1 \le i \le n \quad P_i=1$ | 30 |
| 3 | Empty | 50 |

对于 $100\%$ 的数据：

$1 \le n \le 10^5$。

$\forall 1 \le i \le n$， $c_i$ 为小写字母，$1 \le P_i \le n$。

给出的树连通且合法。

## 样例 #1

### 输入

```
7
2 1 1 9 8 5 1
zzabcad
1 2
2 3
3 4
3 5
5 6
5 7```

### 输出

```
3
3
3
1
1
1
1
```

## 样例 #2

### 输入

```
12
1 2 2 4 1 3 4 3 1 4 3 1 
baabbbbbbbaa
4 6
5 7
1 2
12 10
8 2
10 11
5 9
10 3
2 3
4 3
4 5
```

### 输出

```
5
4
3
1
2
1
1
1
1
1
1
1```

# 题解

## 作者：耳朵龙_ (赞：17)

与字符集大小无关的 $O(n\log n)$ 做法，狠狠爆标！~~场上写的是时空 $O(n|\Sigma|)$ 的长剖做法。~~

若字符集较大可以先离散化，下面认为字符集大小为 $O(n)$。记 $f_{i,j}$ 表示从 $i$ 开始，走到 $i$ 子树内任意一个叶子，能选出的开头为 $j$ 的最长不降子序列长度（忽略 $p_i$ 的限制）。枚举是否选择点 $i$，再枚举走向的子结点 $u$，有转移

$$f_{i,j}=\begin{cases}1+\max\limits_{v= c_i}^{|\Sigma|}\max\limits_uf_{u,v}&j=c_i\\\max\limits_uf_{u,j}&j\ne c_i\end{cases}$$

用线段树合并维护第二维，可以 $O(n\log n)$ 求出所有 $f$ 值。设 $g_i=\max_{j=1}^{|\Sigma|}f_{i,j}$。设 $h_i=f_{i,c_i}$，即必须选择 $i$ 时的最长不降子序列长度。设点 $i$ 的答案为 $ans_i$，深度为 $d_i$，其子树内结点的集合为 $S_i$。

求答案时，设 $a_i$ 表示选择点 $i$ 的符合题意的最长不降子序列长， $b_i$ 表示不选择点 $i$ 的符合题意的最长不降子序列长，则 $ans_i=\max(a_i,b_i)$。将这两部分分开考虑。

枚举子序列的第一个点，有
$$b_i=\max_{u\in S_i,d_u\ge d_i+p_i}h_u=\max_{u\in S_i,d_u\ge d_i+p_i}g_u$$
对于互为父子的点 $x,y$，有 $g_x\ge g_y$，因此，
$$b_i=\max_{u\in S_i,d_u=d_i+p_i}g_u$$
设 $s_{i,k}$ 表示 $i$ 子树内所有深度为 $k$ 的结点 $u$ 其 $g_u$ 的最大值，$b_i$ 即为 $s_{i,d_i+p_i}$。$s$ 的维护是长链剖分的基本操作，不再赘述，计算出 $g$ 后，这一部分的总时间复杂度为 $O(n)$。

注意到 $a_i\le b_i+1$，因此，$ans_i=a_i>b_i$ 当且仅当 $a_i=b_i+1$。也就是说，我们通过求出 $b$，绕过了困难（~~我不会~~）的求 $a$，转而解决简单的判定 $a_i$ 是否等于 $b_i+1$ 的问题。枚举子序列的第二个点，有
$$a_i=1+\max_{u\in S_i,d_u\ge d_i+p_i,c_u\ge c_i}h_u$$
因此只需判断是否有
$$b_i=\max_{u\in S_i,d_u\ge d_i+p_i,c_u\ge c_i}h_u$$
即可求出 $ans_i$。变形一下，上式即为判断是否有
$$d_i+p_i\le\max_{u\in S_i,h_u=b_i,c_u\ge c_i}d_u$$
开 $\max_ih_i=O(n)$ 棵动态开点线段树，将所有点按照 $c$ 从大到小排序，插入点 $i$ 时令第 $h_i$ 棵线段树 $dfn_i$ 处的值对 $d_i$ 取 $\max$，查询 $i$ 时判断其子树 $dfn$ 区间内最大值是否不小于 $d_i+p_i$ 即可。这一部分的总时间复杂度为 $O(n\log n)$。

总时空复杂度均为 $O(n\log n)$。这题字符集很小，代码里没有实现离散化：
```cpp
#include<bits/stdc++.h>
namespace IO{
const int L=(1<<20)+30;
char buf[L],*s,*t,pbuf[L],*p=pbuf;
#define gf() (s==t&&(s=buf)==(t=buf+fread(buf,1,L,stdin))?-1:*s++)
void rd(int&x){
	x=0;char c=gf();
	while(c<48) c=gf();
	while(c>=48) x=x*10+(c^48),c=gf();
}
void rd(char*x){
	do *x=gf();while(*x<48);
	while(*x>=48) *x-='a'-1,*++x=gf();
	*x=0;
}
void fl(){fwrite(pbuf,1,p-pbuf,stdout),p=pbuf;}
void pf(char c){if(p-pbuf==L) fl();*p++=c;}
void wt(int x){
	static int st[30],tp;
	do st[++tp]=x%10,x/=10;while(x);
	while(tp) pf(st[tp--]|48);
	pf(10);
}
}
using IO::rd;
using IO::wt;
using namespace std;
const int N=100005;
int n,m=26,maxr,p[N],dep[N],ans[N],dfn[N],sz[N],tim,len[N],son[N],s[N],h[N],rt[N],idx;
struct tn{int Ls,Rs,v;}tr[N*18];
#define ls tr[u].Ls
#define rs tr[u].Rs
vector<int>E[N],F[N];
char c[N];
int query(int u,int L,int R,int l=1,int r=maxr){
	if(!u||(L<=l&&r<=R)) return tr[u].v;
	int mid=(l+r)/2,z=0;
	if(L<=mid) z=query(ls,L,R,l,mid);
	if(R>mid) z=max(z,query(rs,L,R,mid+1,r));
	return z;
}
void insert(int&u,int x,int v,int l=1,int r=maxr){
	if(!u) tr[u=++idx]={0,0,0};
	if(tr[u].v=max(tr[u].v,v),l<r){
		int mid=(l+r)/2;
		x>mid?insert(rs,x,v,mid+1,r):insert(ls,x,v,l,mid);
	}
}
int merge(int u,int v){
	if(!u||!v) return u^v;
	ls=merge(ls,tr[v].Ls),rs=merge(rs,tr[v].Rs);
	return tr[u].v=max(tr[u].v,tr[v].v),u;
}
void getdep(int x,int pr){
	sz[x]=1;
	for(int y:E[x])
		if(y^pr){
			dep[y]=dep[x]+1,getdep(y,x),sz[x]+=sz[y];
			if(len[y]>len[son[x]]) son[x]=y;
		}
	len[x]=son[x]?len[son[x]]:dep[x];
}
void dfs(int x,int pr){
	dfn[x]=++tim;
	if(son[x]) dfs(son[x],x),rt[x]=rt[son[x]];
	for(int y:E[x])
		if(y^pr&&y^son[x]){
			dfs(y,x),rt[x]=merge(rt[x],rt[y]);
			for(int i=dep[y];i<=len[y];++i)
				s[dfn[x]+i-dep[y]+1]=max(s[dfn[x]+i-dep[y]+1],s[dfn[y]+i-dep[y]]);
		}
	h[x]=1+query(rt[x],c[x],m);
	insert(rt[x],c[x],h[x]),s[dfn[x]]=tr[rt[x]].v;
	ans[x]=len[x]<dep[x]+p[x]?1:s[dfn[x]+p[x]];
	F[int(c[x])].emplace_back(x);
}
#define eb emplace_back
int main(){
	rd(n);
	for(int i=1;i<=n;++i) rd(p[i]);
	rd(c+1);
	for(int i=1,u,v;i<n;++i)
		rd(u),rd(v),E[u].eb(v),E[v].eb(u);
	getdep(1,1),maxr=m,dfs(1,1),idx=0,maxr=n;
	for(int i=1;i<=n;++i) rt[i]=0;
	for(int i=m;i;--i){
		for(int x:F[i]) insert(rt[h[x]],dfn[x],dep[x]);
		for(int x:F[i])
			if(sz[x]>1)
				ans[x]+=query(rt[ans[x]],dfn[x]+1,dfn[x]+sz[x]-1)>=dep[x]+p[x];
	}
	for(int i=1;i<=n;++i) wt(ans[i]);
	return IO::fl(),0;
}
```

---

## 作者：int_R (赞：7)

设 $f_{x,i}$ 为以 $x$ 为根的子树中，以 $i$ 字符为开头的最长不下降子序列的长度。朴素 DP：

$$f_{x,i}=\max\limits_{y\in son(x),i\in\Sigma} f_{y,i}$$

对于 $i=c_x$，额外有 $f_{x,c_x}=1+\max\limits_{y\in son(x),i\geq c_x} f_{y,i}$。

问题相当查询在 $x$ 子树中，所有深度为 $dep_x+p_x$ 的点 $y$ 的 $f_{y,i}(i\in\Sigma)$ 的最大值，同时对于 $i\geq c_x$ 的值可以加一。

所以需要对于每个深度每个 $i$ 维护一个数据结构，考虑对于每个点在 `dfs` 遍历完其子树后，回溯到 $x$ 时进行查询。这样问题转化成查某一深度 `dfs` 序不小于 $dfn_x$ 的点中最大值，数据结构只需支持后缀插入，后缀查最大值，单调栈加二分即可。

时间复杂度是 $O(n\log n\vert\Sigma\vert)$。

```cpp
#include<stdio.h>
#include<iostream>
#include<algorithm>
#include<vector>
using namespace std;
const int MAXN=1e5+10;
int n,dfn[MAXN],tot,dep[MAXN],p[MAXN],f[MAXN][26];
int ANS[MAXN];char c[MAXN];typedef pair<int,int> P;
vector <int> v[MAXN];
struct ds//单调栈加二分
{
    vector <int> v,num;
    inline void I(int x,int y)
    {
        while(!num.empty()&&num.back()<=y)
            v.pop_back(),num.pop_back();
        v.push_back(x),num.push_back(y);
    }
    inline int Q(int x)
    {
        if(v.empty()||x>v.back()) return 0;
        int k=(lower_bound(v.begin(),v.end(),x))-v.begin();
        return num[k];
    }
}t[MAXN<<1][26];
void dfs(int x,int fa=0)
{
    dfn[x]=++tot,dep[x]=dep[fa]+1;int now=0,D=dep[x]+p[x];
    for(int y:v[x])
    {
        if(y==fa) continue;dfs(y,x);
        for(int i=0;i<26;++i)
            f[x][i]=max(f[x][i],f[y][i]);
    }
    for(int i=c[x]-'a';i<26;++i) now=max(now,f[x][i]);f[x][c[x]-'a']=now+1;
    for(int i=0;i<26;++i) t[dep[x]][i].I(dfn[x],f[x][i]);
    for(int i=0;i<26;++i)
        ANS[x]=max(ANS[x],t[D][i].Q(dfn[x])+(i>=c[x]-'a'));
}
int main()
{
#ifndef ONLINE_JUDGE
    freopen("in.in","r",stdin);
    freopen("out.out","w",stdout);
#endif
    cin.tie(0),cout.tie(0);
    ios::sync_with_stdio(0);
    cin>>n;for(int i=1;i<=n;++i) cin>>p[i];
    for(int i=1;i<=n;++i) cin>>c[i];
    for(int i=1,x,y;i<n;++i)
        cin>>x>>y,v[x].push_back(y),v[y].push_back(x);
    dfs(1);for(int i=1;i<=n;++i) cout<<ANS[i]<<'\n';return 0;
}
```

---

## 作者：流水行船CCD (赞：4)

出题人题解。提供一种在线且空间消耗较小的做法。虽然此题可以被线段树合并暴切。

## Subtask 0

很简单，按照题意模拟，树状数组优化后 $O(n \log n)$ 求最长不下降子序列。

$O(n^3 \log n)$

## Subtask 1

发现最优序列一定是到叶子的。则总共只会有 $O(n^2)$ 条序列，稍微优化一下转移顺序（从叶子到当前点），维护增量，可以做到 $O(n^2)$。

## Subtask 2

题目说 $P_i = 0$，其实就是问你每一个点从它到子树中任意一点的路径转换为序列后最长不下降子序列长度的最大值。

考虑 DP ~~这不是废话~~。

设 $f_{x,j}$  表示 $x$ 为子树的根时以 $j$ 字符结尾的最长不下降子序列长度的最大值，$x$ 结点的字符为 $c_x$。

$$ f_{x,j} = \left\{\begin{matrix} 
  \max\{v \in son_x | f_{v,j}\} \quad (j \ne c_x)\\  
  \max\{v \in son_x | \max\{c_x \le j | f_{v,j}\}\} + 1\quad (j = c_x)
\end{matrix}\right.$$

由于值域只有 $26$ 个字母，直接枚举，用后缀和快速更新第二种情况，可以做到 $O(n |\Sigma|)$。

## Subtask 3

仍然在 DP 的思路上优化，因为该 DP 方程的转移是接近 $O(1)$ 的，十分快速。

因为题目实际上就是忽略了一部分点，剩下了 $x$ 和其所有 $P_x$ 级儿子构成的序列。瓶颈在于要快速统计所有 $P_x$ 级儿子的贡献，所有的 $P_x$ 级儿子深度相同，考虑转为 BFS 序上一个连续区间的贡献。

先随便找到该点的任意一个 $P_x$ 级儿子，这里可以使用倍增往子树深度最大的儿子跳。用这个儿子把 BFS 序上 $P_x$ 级儿子的区间划分为两个，每一个都有单调性：长度越小越有可能是 $P_x$ 级儿子构成的区间，这里使用二分求解，判断时只需要看 $mid$ 的 $P_x$ 级祖先是不是 $x$ 即可，可以使用长链剖分 $O(1)$ 求 $k$ 级祖先。当然，可以直接使用三分求出区间。

求出 BFS 序区间 $[L,R]$ 后，发现当前结点的用权值 $j$ 更新答案仅可能是区间中的 $\max\{L \le i \le R | f_{i,j} \}$ 产生的贡献，因此用一个以 BFS 序为下标线段树维护 DP 数组，求区间最值即可。

## 空间线性做法

如果你将标程中 $k$ 级祖先部分改为重剖跳祖先，求出任意一个 $k$ 级儿子时往当前点所在长链上直接跳。（这个可以通过长儿子优先的 DFN 序 $O(1)$ 跳）那么本题所有倍增数组和梯子表均被消除，可以做到空间 $O(n)$。

### 扩展

根据 耳朵龙 大佬的爆标做法，在字符集为 $100000$ 时，将数组替换为动态开点值域线段树，即可做到 $O(n \log n \log V)$ 的在线回答询问，虽然常数和码长都会非常大。

## AC Code

```cpp
#include <bits/stdc++.h>

#define FAST_IO_OPEN

#define REP(i, l, r) for (int i=l;i<=r;++i)
#define rep(i, l, r) for (int i=l;i<r;++i)
#define PER(i, l, r) for (int i=l;i>=r;--i)
#define per(i, l, r) for (int i=l;i>r;--i)

typedef long long ll;
typedef unsigned long long ull;
using namespace std;

#ifdef FAST_IO_OPEN
namespace fast_IO {
#define FAST_IO
#define IOSIZE (1<<20)
	char ibuf[IOSIZE], obuf[IOSIZE];
	char *p1 = ibuf, *p2 = ibuf, *p3 = obuf;
#ifdef ONLINE_JUDGE
#define getchar()((p1==p2)and(p2=(p1=ibuf)+fread(ibuf,1,IOSIZE,stdin),p1==p2)?(EOF):(*p1++))
#define putchar(x)((p3==obuf+IOSIZE)&&(fwrite(obuf,p3-obuf,1,stdout),p3=obuf),*p3++=x)
#endif
#define isdigit(ch)(ch>47&&ch<58)
#define isspace(ch)(ch<33)
	
	template<typename T>
	inline T read() {
		T s = 0;
		int w = 1;
		char ch;
		while (ch = getchar(), !isdigit(ch) and (ch != EOF))if (ch == '-')w = -1;
		if (ch == EOF)return false;
		while (isdigit(ch))s = s * 10 + ch - 48, ch = getchar();
		return s * w;
	}
	
	template<typename T>
	inline bool read(T &s) {
		s = 0;
		int w = 1;
		char ch;
		while (ch = getchar(), !isdigit(ch) and (ch != EOF))if (ch == '-')w = -1;
		if (ch == EOF)return false;
		while (isdigit(ch))s = s * 10 + ch - 48, ch = getchar();
		return s *= w, true;
	}
	
	inline bool read(char &s) {
		while (s = getchar(), isspace(s));
		return true;
	}
	
	inline bool read(char *s) {
		char ch;
		while (ch = getchar(), isspace(ch));
		if (ch == EOF)return false;
		while (!isspace(ch))*s++ = ch, ch = getchar();
		*s = '\000';
		return true;
	}
	
	template<typename T>
	inline void print(T x) {
		if (x < 0)putchar('-'), x = -x;
		if (x > 9)print(x / 10);
		putchar(x % 10 + 48);
	}
	
	inline void print(char x) {
		putchar(x);
	}
	
	inline void print(char *x) {
		while (*x)putchar(*x++);
	}
	
	inline void print(const char *x) {
		for (int i = 0; x[i]; i++)putchar(x[i]);
	}
	
	inline bool read(std::string &s) {
		s = "";
		char ch;
		while (ch = getchar(), isspace(ch));
		if (ch == EOF)return false;
		while (!isspace(ch))s += ch, ch = getchar();
		return true;
	}
	
	inline void print(std::string x) {
		for (int i = 0, n = x.size(); i < n; i++)putchar(x[i]);
	}
	
	template<typename T, typename...T1>
	inline int read(T &a, T1 &...other) {
		return read(a) + read(other...);
	}
	
	template<typename T, typename...T1>
	inline void print(T a, T1...other) {
		print(a);
		print(other...);
	}
	
	struct Fast_IO {
		~Fast_IO() {
			fwrite(obuf, p3 - obuf, 1, stdout);
		}
	} io;
	
	template<typename T>
	Fast_IO &operator>>(Fast_IO &io, T &b) {
		return read(b), io;
	}
	
	template<typename T>
	Fast_IO &operator<<(Fast_IO &io, T b) {
		return print(b), io;
	}
}
using namespace fast_IO;

#endif

const int N = 2e5 + 7;
const int inf = 1e9 + 7;

namespace clion {
	int n;
	int P[N], val[N], Ans[N];
	vector<int> NTT[N], lis[N];//树 & 梯子表
	int dep[N], madep[N], son[N][20], fa[N][20], lg2[N];
	int bfn[N], ide[N], bfn_cnt = 0, dfn[N], id[N], len[N], belong[N], dfn_cnt = 0;
	string Str;
	
	void dfs1(int x, int d, int f) {//长链剖分 dfs1
		fa[x][0] = f;
		dep[x] = madep[x] = d;
		for (auto v : NTT[x]) {
			if (v == f)continue;
			dfs1(v, d + 1, x);
			if (madep[x] < madep[v]) {
				madep[x] = madep[v];
				son[x][0] = v;
			}
		}
	}
	
	void dfs2(int x, int top) {//长链剖分 dfs2 求出 dfn 序
		dfn[x] = ++dfn_cnt;
		id[dfn_cnt] = x;
		belong[x] = top;
		++len[top];
		if (son[x][0])dfs2(son[x][0], top);
		for (auto v : NTT[x]) {
			if (v == fa[x][0] || v == son[x][0])continue;
			dfs2(v, v);
		}
	}
	
	queue<int> q;
	
	void BFS() {//求出 BFN 序
		q.push(1);
		while (!q.empty()) {
			int x = q.front();
			q.pop();
			bfn[x] = ++bfn_cnt;
			ide[bfn_cnt] = x;
			for (auto v : NTT[x]) {
				if (v == fa[x][0])continue;
				q.push(v);
			}
		}
	}
	
	inline int getfa(int x, int kth) {//求出 k 级祖先。
		if (!kth) return x;
		if (kth >= dep[x]) return 0;
		x = fa[x][lg2[kth]];
		kth -= (1 << lg2[kth]);
		if (!kth) return x;//如果已经到了
		int f = belong[x], kin = dep[x] - dep[f];
		if (kth <= kin) {//祖先在长链上
			x = id[dfn[x] - kth];//直接用 dfn 来跳
		} else {//查梯子表
			kth -= kin;
			x = lis[f][kth];
		}
		return x;
	}
	
	inline int getson(int x, int k) {//求出任意一个 k 级儿子。
		for (int len = k, i = 0; len; ++i, len >>= 1)
			if (len & 1)x = son[x][i];
		return x;
	}
	
	struct Node {
		int tmp[27];//以该字符结尾的最长不下降子序列长度。
#define ls(x) (x << 1)
#define rs(x) (x << 1 | 1)
		
		Node() {
			memset(tmp, 0, sizeof(tmp));
		}
	} tr[N << 1];
	
	inline Node merge(Node l, Node r) {
		Node res;
		REP(i, 1, 26)res.tmp[i] = max(l.tmp[i], r.tmp[i]);
		return res;
	}
	
	inline void PushUp(int x) {
		while (x >> 1) {
			x >>= 1;
			tr[x] = merge(tr[ls(x)], tr[rs(x)]);
		}
	}
	
	inline int AskNode(int x, int l, int r, int now) {
		if (l == r) return x;
		int mid = (l + r) >> 1;
		if (now <= mid)return AskNode(ls(x), l, mid, now);
		else return AskNode(rs(x), mid + 1, r, now);
	}
	
	inline Node Query(int x, int l, int r, int L, int R) {
		if (L <= l && r <= R) {
			return tr[x];
		}
		int mid = (l + r) >> 1;
		if (L <= mid && R <= mid)return Query(ls(x), l, mid, L, R);
		if (mid < R && mid < L)return Query(rs(x), mid + 1, r, L, R);
		return merge(Query(ls(x), l, mid, L, R), Query(rs(x), mid + 1, r, L, R));
	}
	
	int DP(int x) {//求出所有桶数组
		int Node = AskNode(1, 1, n, bfn[x]);
		for (auto v : NTT[x]) {
			if (v == fa[x][0])continue;
			int tNode = DP(v), Max = 0;
			PER(i, 26, 1) {
				Max = max(Max, tr[tNode].tmp[i]);
				if (i == val[x]) {
					tr[Node].tmp[i] = max(tr[Node].tmp[i], Max);
				} else {
					tr[Node].tmp[i] = max(tr[Node].tmp[i], tr[tNode].tmp[i]);
				}
			}
		}
		++tr[Node].tmp[val[x]];
		PushUp(Node);
		return Node;
	}
	
	signed main() {
		io >> n;
		lg2[0] = -1;
		REP(i, 1, n)lg2[i] = lg2[i >> 1] + 1;//log2(i)
		REP(i, 1, n)io >> P[i];
		io >> Str;
		REP(i, 0, n - 1)val[i + 1] = (int) (Str[i] - 'a' + 1);
		int x, y;
		REP(i, 2, n) {
			io >> x >> y;
			NTT[x].emplace_back(y);
			NTT[y].emplace_back(x);
		}
		
		dfs1(1, 1, 1);
		dfs2(1, 1);
		BFS();
		REP(j, 1, lg2[n])REP(i, 1, n)son[i][j] = son[son[i][j - 1]][j - 1];
		REP(j, 1, lg2[n])REP(i, 1, n)fa[i][j] = fa[fa[i][j - 1]][j - 1];
		REP(i, 1, n) {
			if (belong[i] == i) {//链头
				lis[i].reserve(len[i] + 7);
				lis[i][0] = i;
				REP(j, 1, len[i])lis[i][j] = fa[lis[i][j - 1]][0];//预处理梯子表
			}
		}
		DP(1);
//		Node _ = Query(1, 1, n, bfn[2], bfn[2]);
//		REP(i, 1, 26)io << _.tmp[i] << ' ';
//		io << '\n';
		REP(i, 1, n) {
			x = ide[i];
			if (P[x] > madep[x] - dep[x]) {//没有该点
				Ans[x] = 0;
				continue;
			}
			y = getson(x, P[x]);
//            io<<x<<"USE"<<P[x]<<" "<<y<<'\n';
			int L = 1, R = bfn[y], resL = bfn[y], resR = bfn[y];
			if (P[x]) {
//            	io<<L<<' '<<R<<'\n';
				while (L <= R) {
					int mid = (L + R) >> 1;
					if (getfa(ide[mid], P[x]) == x) {
						R = mid - 1;
						resL = mid;
					} else {
						L = mid + 1;
					}
				}
				L = bfn[y], R = n;
//				io<<L<<' '<<R<<'\n';
				while (L <= R) {
					int mid = (L + R) >> 1;
					if (getfa(ide[mid], P[x]) == x) {
						L = mid + 1;
						resR = mid;
					} else {
						R = mid - 1;
					}
				}
			}
//			io << x << ":" << resL << ' ' << resR << '\n';
//			Node _ = Query(1, 1, n, 4, 5);
//			REP(j, 1, 26)io << _.tmp[j] << ' ';
//			io << '\n';
//			_ = Query(1, 1, n, 4, 4);
//			REP(j, 1, 26)io << _.tmp[j] << ' ';
//			io << '\n';
//			_ = Query(1, 1, n, 5, 5);
//			REP(j, 1, 26)io << _.tmp[j] << ' ';
//			io << '\n';
			Node res = Query(1, 1, n, resL, resR);
//			REP(j, 1, 26)io << res.tmp[j] << ' ';
//			io << '\n';
			if (P[x]) {
				int Max = 0;
				PER(j, 26, val[x])Max = max(Max, res.tmp[j]);
				res.tmp[val[x]] = Max + 1;
//                io <<x<<":"<< val[x]<<" "<<Max + 1 << '\n';
			}
			int Max = 0;
			REP(j, 1, 26)Max = max(Max, res.tmp[j]);
			Ans[x] = Max;
		}
		REP(i, 1, n)io << Ans[i] << '\n';
		return 0;
	}
}

signed main() {
#ifndef FAST_IO
	ios::sync_with_stdio(false);
	cin.tie(0), cout.tie(0);
#endif
//	freopen("std.in", "r", stdin);
//	freopen("user.out", "w", stdout);
	clion::main();
	return 0;
}
```

---

## 作者：Undead2008 (赞：3)

给个简单做法。

设计 dp 状态 $f_{i,k}$ 为 $i$ 的子树中开头结点的权值为 $k$，最长不降子序列的最大长度，有以下转移方程：

$$f_{i,k}=\begin{cases}\max_{j\in s_i}\limits f_{j,k}& k\neq c_i\\\max(\max_{j\in s_i,k'>k}\limits f_{j,k'}+1,\max_{j\in s_i}\limits f_{j,k})& \text{otherwise.}\end{cases}$$

其中 $s_i$ 表示 $i$ 子树中的点（不包括 $i$）构成的集合。

最后节点 $i$ 的答案等于

$$\max(\max_{j\in s_i,d_j\ge d_i+p_i,k>c_i}\limits f_{j,k'}+1,\max_{j\in s_i,d_j\ge d_i+p_i,k}\limits f_{j,k})$$

其中 $d_i$ 表示节点 $i$ 的深度，$s_i$ 的意义同上。

我们开 $26$ 棵线段树，第 $i$ 棵维护所有的 $f_{j,i}$ 的值，并把所有点的 $d_i$ 和 $d_i+p_i$ 离线下来从大到小排序来抹除对深度的限制。缺少了该限制后，使用 dfs 序维护子树信息即可做到 $O(n|\Sigma|\log n)$ 的复杂度。

值得一提的是转移是一个偏序的形式，将操作再次离线并使用三维偏序即可做到 $O(n\log n\log |\Sigma|)$。

---

## 作者：vanyou (赞：2)

一篇和标签完全不一样的做法。

先考虑一个简单的问题，如果 $p_i$ 都是 $1$ 即没有忽略的点，那么就是一个树形 DP。设 $dp_{i,j}$ 表示在以 $i$ 为根的子树上以第 $j$ 个小写字母为开头组成的不下降子序列的最大长度。那么 $dp_{i,j}$ 就可以从树上 $i$ 的子节点取最大值转移过来，只是要特判 $i$ 这个点是不是也可以放进那个子序列，可以的话就要额外加 $1$。

求出了这个，再把 $p$ 的限制加进来，发现求的就是以 $i$ 为根的子树里，所有 $dep(i) + p_i \le dep(j)$ 的点 $j$ 的 $dp_{j,k}$ 的最大值，同时特判 $i$ 可以放进去的情况，加个 $1$，其中 $dep(x)$ 表示 $x$ 在原树上的深度。用树上启发式合并就可以在 $O(n \log^2 n\  \Sigma)$ 的时间里解决，其中 $\Sigma$ 表示不同字符的数量。

这个 $\Sigma$ 实际上是比较小的，一般达不到 $26$，因为在树上启发式合并上修改时很难跑满。

不了解树上启发式合并的可以先做做[这个](https://www.luogu.com.cn/problem/CF600E)。

```c++
#include<bits/stdc++.h>
#define x first
#define y second
using namespace std;
const int N=1e5+10;
int n,p[N],cnt,dfn[N],si[N],dep[N],son[N],rev[N],ans[N];
string s;
vector<int> g[N];
vector<pair<int,int> > mx[N];

void pre(int u,int fa){
	dep[u]=dep[fa]+1,si[u]=1;
	dfn[u]=++cnt,rev[cnt]=u;
	for(auto i:g[u]){
		if(i==fa) continue;
		pre(i,u);
		si[u]+=si[i];
		if(si[i]>si[son[u]]) son[u]=i;
	}
}//树上启发式合并用的dfs序和重儿子

int dp[N][30];

void dfs(int u,int fa){
	dp[u][s[u]-'a'+1]=1;
	mx[u].push_back({1,s[u]-'a'+1});
	for(auto i:g[u]){
		if(i==fa) continue;
		dfs(i,u);
		for(int j=1;j<27;j++){
			dp[u][j]=max(dp[u][j],dp[i][j]);
			if(dp[i][j]&&s[u]-'a'+1<=j) dp[u][s[u]-'a'+1]=max(dp[u][s[u]-'a'+1],dp[i][j]+1);
		}
	}
	for(int i=1;i<27;i++){
		if(mx[u][0].x<dp[u][i]) mx[u].clear(),mx[u].push_back({dp[u][i],i});
		else if(mx[u][0].x==dp[u][i]) mx[u].push_back({dp[u][i],i});
	}
}//树形DP，mx是该点dp最大值的序列开头字符（可能有多个）

int c[N][30];

int lowbit(int x){return x&-x;}

void update(int x,int v,int z){for(int i=x;i;i-=lowbit(i)) c[i][z]=max(c[i][z],v);}

void clear(int x,int z){for(int i=x;i;i-=lowbit(i)) c[i][z]=0;}

int sum(int x,int z){
	int ans=0;
	for(int i=x;i<=n;i+=lowbit(i)) ans=max(ans,c[i][z]);
	return ans;
}

void add(int x){
	for(auto i:mx[x])
		update(dep[x],i.x,i.y);
}

void del(int x){
	for(auto i:mx[x])
		clear(dep[x],i.y);
}

void get(int u,int fa,bool cl){
	for(auto i:g[u]){
		if(i==fa||i==son[u]) continue;
		get(i,u,1);
	}
	if(son[u]) get(son[u],u,0);
	add(u);
	for(auto i:g[u]){
		if(i==fa||i==son[u]) continue;
		for(int j=dfn[i];j<=dfn[i]+si[i]-1;j++) add(rev[j]);
	}
	ans[u]=1;
	for(int i=1;i<27;i++){
		int x=sum(dep[u]+p[u],i);
		ans[u]=max(ans[u],x+(x&&s[u]-'a'+1<=i));
	}
	if(cl)
		for(int i=dfn[u];i<=dfn[u]+si[u]-1;i++) del(rev[i]);
}//树上启发式合并

signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++) cin>>p[i];
	cin>>s;s=" "+s;
	for(int i=1,u,v;i<n;i++){
		cin>>u>>v;
		g[u].push_back(v);
		g[v].push_back(u);
	}
	pre(1,0);
	dfs(1,0);
	get(1,0,0);
	for(int i=1;i<=n;i++) cout<<ans[i]<<"\n";
	return 0;
}
```

---

## 作者：Miss_SGT (赞：1)

提供一个第一篇题解中提到的时空 $O(n | \Sigma| )$ 长剖做法。

记 $f_{u,i}$ 为在 $u$ 的子树内以字符 $i$  结尾的最长不降子序列的长度（不考虑题目中的忽略操作）。树形 dp 转移是简单的。

那么节点 $i$ 的答案可以从其子树内距离它 $P_i$ 的点的 dp 值得到，记 $g_i$ 为这些 dp 值第 $i$ 位取最大值的结果，则有

$$ans_i =  \max(g_i+[i \ge c_i])$$

（因为一个节点的 dp 值包含其儿子的 dp 值，所以不用考虑距离大于 $P_i$ 的点）。

求这类子树内距离的问题正是长剖要干的事情，这里不再赘述，不会可以看看 [CF1009F](https://www.luogu.com.cn/problem/CF1009F)。

贴出核心代码，代码中对 $f[u]$ 做了后缀 max。


```cpp
struct node{
	int f[26];
	inline void Cmax(node &y){for(int i=0;i<26;++i) f[i]=max(f[i],y.f[i]);}
}*t[N],buf[N],*now=buf,f[N];
int len[N],son[N],ans[N];
void dfs1(int p,int fa){
	len[p]=1;
	for(int o=head[p],v;o;o=nxt[o]){
		if((v=to[o])==fa) continue;
		dfs1(v,p);
		if(len[v]>=len[p]) len[p]=len[v]+1,son[p]=v;
		f[p].Cmax(f[v]);
	}
	++f[p].f[c[p]];
	for(int i=c[p]-1;~i;--i) f[p].f[i]=max(f[p].f[i],f[p].f[c[p]]);
}
inline void calc(int p){
	if(len[p]>a[p]) ans[p]=max(t[p][a[p]].f[0],t[p][a[p]].f[c[p]]+1);
	else ans[p]=1;
}
void dfs2(int p,int fa){
	t[p][0]=f[p];
	if(!son[p]) return calc(p),void();
	t[son[p]]=t[p]+1;
	dfs2(son[p],p); 
	for(int o=head[p],v;o;o=nxt[o])
		if((v=to[o])!=fa&&v!=son[p]){
			t[v]=now,now+=len[v];
			dfs2(v,p);
			for(int i=0;i<len[v];++i) t[p][i+1].Cmax(t[v][i]);
		}
	calc(p);
}
```

---

## 作者：ruanshaochuan______ (赞：0)

关于此题长链剖分优化 dp 的详细讲解。

题解区中已有一篇长链剖分优化 dp 的文章，但并没有给出详细的说明。

# 前置知识
1. 长链剖分。
# 算法详解
## 状态设计
记 $f_{x,l,c}$ 为在节点 x 的子树中，离 x 的距离至少为 l，开头为 c 的最长不降子序列。
## 状态转移
转移方程显然，考虑使用长链剖分优化转移，每次从长儿子复制状态，再与其他儿子暴力合并，由于每个点至多被暴力合并一次，所以复杂度 $\operatorname{O}(n\Sigma)$。
## 答案输出
最后答案为 $\max^z_{i-a}f_{x,p_x,c}+[c \le co_x]$。
# 代码
代码还挺好写的。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=2e5+5;
struct Node{
	int a[26];
	void build(int x)
	{
		for(int i=0;i<=25;i++)
			if(i!=x)
				a[i]=0;
			else
				a[i]=1;
	}
};
vector<Node>f[maxn];
int pc[maxn],n,p[maxn],len[maxn],c[maxn],ans[maxn];
vector<int>vt[maxn];
void dfs(int x,int fa)
{
	len[x]=1;
	for(int v:vt[x])
		if(v!=fa)
		{
			dfs(v,x);
			if(len[v]+1>len[x])
			{
				pc[x]=v;
				len[x]=len[v]+1;
			}
		}
}
void query(int x,int fa)
{
	if(pc[x])
	{
		query(pc[x],x);
		swap(f[pc[x]],f[x]);
		Node t;
		t.build(-1);
		f[x].push_back(t);
	}
	if(!pc[x])
	{
		Node t;
		t.build(c[x]);
		f[x].push_back(t); 
	}
	for(int v:vt[x])
	{
		if(v!=fa&&v!=pc[x])
		{
			query(v,x);
			for(int i=0;i<f[v].size();i++)
				for(int j=0;j<=25;j++)
					f[x][f[x].size()-((f[v].size()-i)+1)].a[j]=max(f[x][f[x].size()-((f[v].size()-i)+1)].a[j],f[v][i].a[j]);
		}
	}
	if(pc[x])
	{
		for(int i=0;i<=25;i++)
		{
			f[x][f[x].size()-1].a[i]=f[x][f[x].size()-2].a[i];	
			if(i>=c[x])
				f[x][f[x].size()-1].a[c[x]]=max(f[x][f[x].size()-1].a[c[x]],f[x][f[x].size()-2].a[i]+1);
		}
	}
	if((int)f[x].size()-p[x]-1>=0)
	{
		int t=0;
		for(int i=0;i<=25;i++)
			t=max(t,f[x][f[x].size()-p[x]-1].a[i]+bool(i>=c[x]));
		ans[x]=t;
	}else
		ans[x]=1;
}
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
		cin>>p[i];
	for(int i=1;i<=n;i++)
	{
		char t;
		cin>>t;
		c[i]=t-'a';
	}
	for(int i=1;i<n;i++)
	{
		int u,v;
		cin>>u>>v;
		vt[u].push_back(v);
		vt[v].push_back(u);
	}
	dfs(1,0);
	query(1,0);
	for(int i=1;i<=n;i++)
		cout<<ans[i]<<"\n";
}
```

---

## 作者：zhoumurui (赞：0)

### 题面展示

题面十分抽象，上原文吧。

> 给你一棵有 $n$ 个结点的以 $1$ 为根的树 $T$，第 $i$ 个结点有一个颜色 $c_i$，${\tt a} \le c_i \le {\tt z}$，和一个值 $P_i$。
> 
> 对于每一个点 $x$，**从它到它子树中每一个点**（注意顺序是从它本身到子树中的点）都有一条路径，一共有子树的大小条路径。
> 
> 现在忽略掉这些路径中的第 $2$ 到第 $P_x$ 个的点，特别地，若 $P_x = 1$ 则不忽略任何点。将忽略后的路径当作一个序列，序列中每个点的权值为路径上点的 $c_i$，求**每一个点的所有序列最长不下降子序列长度的最大值**。
> 
> 注： 若有路径 $j$ 上的节点数 $len_j < P_x$，则相当于忽略这条路径上除第一个点外的所有点。

### 解题思路

给楼上的题解们一个更详细的解释。

设 $f_{u,i}$ 为满足下面条件的序列数量：

- 是 $u$ 的一条路径的子序列。（路径即题目描述中的定义）
- 单调不降。
- 首项为 $i$。

状态转移方程容易得出，这个 DP 的时间复杂度是 $O(nV)$，$V$ 为值域即 26。

对于每个 $u$，在它的路径里忽略第 $2$ 到第 $P_u$ 个点，就是只保留它的 **$P_u$ 级子孙**的路径，**并在它们前面都插上一个 $u$。**

那么答案就是下面两个数中取较大值：
- 对于 $i < c_u$，所有 $u$ 的 $P_u$ 级子孙 $v$ 的 $f_{v,i}$ 的最大值；
- 对于 $i \ge c_u$，所有 $u$ 的 $P_u$ 级子孙 $v$ 的 $f_{v,i}$ 的最大值加一。

**结论** 一个点 $u$ 的子树中所有点在 dfs 序中连续出现。

考虑对于每个颜色 $i$ 分别开一个数据结构。数据结构需要维护的信息有：

- 添加一个键值对。
- 告诉 $k$，在满足键不小于 $k$ 的键值对中求最大的值。

我们先考虑它怎么用，再来想它怎么实现的问题。在一个点 $u$ 的子树遍历完了之后，它的 $f_{u,i}$ 自然也求完了，我们将 $(dfn_u,f_{u,i})$ 插入第 $i$ 个数据结构中。这时，**已经遍历完毕的点中 $dfn_v \ge dfn_u$ 的恰好是 $u$ 子树中的所有点**。用 $dfn_u$ 给每个数据结构都查询一遍就得出 $u$ 的答案。

接下来考虑数据结构如何实现。~~主席树当然没有问题~~，可是常数和代码量都过大。我在题解区看到一个精妙的发明：

**单调栈+二分**。开两个 `vector` 把键值对存下来。加入一个键值对的时候，如果栈顶的值不大于新加入的值，那么就将栈顶弹出。

**结论** 存储的键始终递增。

**证明** 由单调栈的性质，存储的植始终递减。由于按后序遍历的顺序加入键值对，假如有相邻两位满足底下的键大于上面的键，那么上面一定是底下的祖先，上面的值就一定不小于底下的值，矛盾。

既然存储的键始终递增，值始终递减，那么查询自然是一个二分就可以了。

### 代码展示

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,p[100005];
char c[100005];
int h[100005],e[200005],ne[200005],idx;
void add(int u,int v){
    e[++idx]=v;
    ne[idx]=h[u];
    h[u]=idx;
}
int ans[100005];
int dfn[100005],dep[100005],tim;
int f[100005][26];
struct ds{
vector<int> v,num;
void Insert(int x,int y){
    while (!num.empty()&&num.back()<=y){
        v.pop_back();
        num.pop_back();
    }
    v.push_back(x),num.push_back(y);
}
int Query(int x){
    if (v.empty()||x>v.back())return 0;
    int k=lower_bound(v.begin(),v.end(),x)-v.begin();
    return num[k];
}
}t[200005][26];
void dfs(int u,int fa){
    dfn[u]=++tim;
    dep[u]=dep[fa]+1;
    int now=0,D=dep[u]+p[u];
    for (int i=h[u];i;i=ne[i]){
        int v=e[i];
        if (v==fa)continue;
        dfs(v,u);
        for (int i=0;i<26;i++){
            f[u][i]=max(f[u][i],f[v][i]);
        }
    }
    for (int i=c[u]-'a';i<26;i++)now=max(now,f[u][i]);
    f[u][c[u]-'a']=now+1;
    for (int i=0;i<26;i++){
        t[dep[u]][i].Insert(dfn[u],f[u][i]);
    }
    for (int i=0;i<26;i++){
        ans[u]=max(ans[u],t[D][i].Query(dfn[u])+(i>=c[u]-'a'));
    }
}
signed main(){
    cin>>n;
    for (int i=1;i<=n;i++)cin>>p[i];
    for (int i=1;i<=n;i++)cin>>c[i];
    for (int i=1;i<n;i++){
        int x,y;
        cin>>x>>y;
        add(x,y);
        add(y,x);
    }
    dfs(1,0);
    for (int i=1;i<=n;i++){
        cout<<ans[i]<<"\n";
    }
    return 0;
}
```

---

## 作者：Union_Find (赞：0)

本题解提供一种扫描线做法，时间复杂度 $O(n\log n \left | \Sigma\right |)$。

首先这道题的暴力 dp 很简单。设 $f_{i,j}$ 表示 $i$ 号点，第一个字符是 $j$ 的最长不上升子序列长度。注意，这个 $f$ 数组是没有 $p_i$ 限制的，下文的 $g$ 才有限制。



这样子我们就可以直接 $O(n^2\left | \Sigma\right |^2)$ 暴力做。稍微后缀最大值优化可以到 $O(n^2\left | \Sigma\right |)$，但没必要。~~反正也过不了。~~

然后设 $g_{i,j}$ 表示加上 $p_i$ 限制的答案，大致含义同 $f$。

$$g_{i,j} \gets \left\{\begin{matrix} j = c_i,f_{v,k}+1(v \in sub_i,k \ge j)
 \\j \not = c_i,f_{v,k}(v \in sub_i,k \ge j,dep_v\ge dep_i+p_i)

\end{matrix}\right.$$

然后答案就是 $\max g_{i,j}$。

如何优化呢？大部分题解都忽略了 $v \in sub_i$ 的限制，使用线段树合并或树上启发式合并。但实际上，我在考虑的时候是把 $v \in sub_i$ 当做一个限制一起做。

我们希望可以使 $v \in sub_i$ 变成一个不等式。这个简单，就是 $dfn_i \le dfn_v \le dfn_i + sz_i - 1$。这个限制同时有上下界的限制，另一个 $dep_v \ge dep_i+p_i$ 只有下界限制。我们考虑按照 $dep_i$ 从大到小排序，然后扫描线求 dp 值。

因为要扫描线从大到小扫，要求区间最大值，考虑线段树。再加上有一个 $k \ge j$ 的限制，我们直接开 $\left | \Sigma \right |$ 个线段树。

这样子，每个点被加一次，就是 $O(n\log n\left| \Sigma \right|)$ 的了。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define il inline
#define N 100005
il ll rd(){
	ll s = 0, w = 1;
	char ch = getchar();
	for (;ch < '0' || ch > '9'; ch = getchar()) if (ch == '-') w = -1;
	for (;ch >= '0' && ch <= '9'; ch = getchar()) s = ((s << 1) + (s << 3) + ch - '0');
	return s * w;
}
ll n = rd(), p[N], a[N], u, v, f[N][35], g[N][35], sz[N], dep[N], dfn[N], ex;
char s[N];
vector <ll> e[N], qurey[N], upd[N];
void dfs(ll u, ll fa){
	sz[u] = 1, dfn[u] = ++ex, dep[u] = dep[fa] + 1;
	for (int v : e[u]) if (v != fa) dfs(v, u), sz[u] += sz[v];
}struct ST{
	ll tr[N << 2];
	void add(ll p, ll l, ll r, ll x, ll k){
		if (l == r) return tr[p] = max(tr[p], k), void(0);
		ll mid = (l + r) >> 1;
		if (x <= mid) add(p << 1, l, mid, x, k);
		else add(p << 1 | 1, mid + 1, r, x, k);
		tr[p] = max(tr[p << 1], tr[p << 1 | 1]);
	}ll ask(ll p, ll l, ll r, ll nl, ll nr){
		if (nl <= l && r <= nr) return tr[p];
		ll mid = (l + r) >> 1, ans = 0;
		if (nl <= mid) ans = max(ans, ask(p << 1, l, mid, nl, nr));
		if (nr > mid) ans = max(ans, ask(p << 1 | 1, mid + 1, r, nl, nr));
		return ans;
	}
}tr[35];
int main(){
	for (int i = 1; i <= n; i++) p[i] = rd();
	scanf ("%s", s + 1);
	for (int i = 1; i <= n; i++) a[i] = s[i] - 'a' + 1;
	for (int i = 1; i <= n; i++) g[i][a[i]] = f[i][a[i]] = 1;
	for (int i = 1; i < n; i++){
		u = rd(), v = rd();
		e[u].push_back(v), e[v].push_back(u);
	}dfs(1, 0);
	for (int i = 1; i <= n; i++)
		qurey[min(dep[i] + p[i], n + 1)].push_back(i), upd[dep[i]].push_back(i);
	for (int i = n; i >= 1; i--){
		for (int v : upd[i]){
			for (int j = 26; j >= 1; j--)
				f[v][j] = max(f[v][j + 1], tr[j].ask(1, 1, n, dfn[v] + 1, dfn[v] + sz[v] - 1));
			f[v][a[v]]++;
			for (int j = 1; j <= 26; j++)
				tr[j].add(1, 1, n, dfn[v], f[v][j]);
		}for (int v : qurey[i]){
			for (int j = 26; j >= 1; j--)
				g[v][j] = max(g[v][j + 1], tr[j].ask(1, 1, n, dfn[v] + 1, dfn[v] + sz[v] - 1));
			g[v][a[v]]++;
		}
	}for (int i = 1; i <= n; i++){
		ll ans = 0;
		for (int j = 1; j <= 26; j++) ans = max(ans, g[i][j]);
		printf ("%lld\n", ans);
	}
	return 0;
}

```

---


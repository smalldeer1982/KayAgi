# BZOJ4262 Sum

## 题目描述

给定一个长度为 $10^5$ 的整数序列 $a_i$，现进行 $t$ 次询问，每次询问给出 $l_1,l_2,r_1,r_2$ 四个值，要求出：

$$\sum_{l \in [l_1,r_1]} \sum_{r \in [l_2,r_2]} (\max_{i \in [l,r]} a_i-\min_{i\in [l,r]} a_i)$$

的值。不要求强制在线。

本题中的序列 $a_i$ 由如下代码给定生成：

```cpp
const int mod = 1e9;
long long fst = 1023, sec = 1025;
for (int i = 1; i <= 100000; i++) {
	a[i] = fst ^ sec;
	fst = fst * 1023 % mod;
	sec = sec * 1025 % mod;
}
```

## 说明/提示

数据保证，$1\leq t\leq 40000$，$1\leq l_1<r_1\leq 10^5$，$1\leq l_2 \leq r_2\leq 10^5$。

## 样例 #1

### 输入

```
4
1 3 5 7
2 4 6 8
1 1 9 9
9 9 1 1```

### 输出

```
9322587654
9025304064
1065645568
0```

# 题解

## 作者：AbsMatt (赞：10)

### [题目传送器](https://www.luogu.com.cn/problem/P10637)

### [更爽的阅读体验](https://yaohaoyou.github.io/post/p10637-solution)

## 前言

我什么也不会，不知道为什么 \_maojun\_ 要感谢我。但是我要感谢 [\_maojun\_](https://www.luogu.com.cn/user/350297) 提供思路。

## 题意

给出**随机的**数列 $a$，求 $\sum_{l \in [l_1,r_1]} \sum_{r \in [l_2,r_2]} (\max_{i \in [l,r]} a_i-\min_{i\in [l,r]} a_i)$。

## 做法

做法肯定和[这篇题解](https://www.luogu.com.cn/article/3wka43ys)一样，但我尝试说的更详细一点。

### conclusion 1

我会盯式子！

因为 $\max -a_i = -\min a_i$，所以只要会求 $\sum_{l \in [l_1,r_1]} \sum_{r \in [l_2,r_2]} \max_{i \in [l,r]} a_i$，然后将 $a_i=-a_i$，再做一遍，两遍答案加起来就是要输出的结果。

### conclusion 2

我会前缀和差分！

 $\sum_{l \in [l_1,r_1]} \sum_{r \in [l_2,r_2]} \max_{i \in [l,r]} a_i=\sum_{l \in [l_1,r_1]} \sum_{r \in [1,r_2]} \max_{i \in [l,r]} a_i-\sum_{l \in [l_1,r_1]} \sum_{r \in [1,l_2-1]} \max_{i \in [l,r]} a_i$。

也就是说设 $s(l,r,x)=\sum_{i \in [l,r]}\sum_{j \in [1,x]} \max_{k\in [i,j]} a_k$，答案可以变成 $s(l1,r1,r2)-s(l1,r1,l2-1)$。

现在只需会求 $s(l,r,x)$ 即可。

### conclusion 3

我会扫描线！

这个做法在线做好像非常复杂了，所以可以尝试用离线下来做。

将所有的 $s(l,r,x)$ 的询问挂在 $x$ 上，设 $f(i,x)=\sum_{j\in [i,x]} \max_{k \in [i,j]} a_k$，则 $s(l,r,x)=\sum_{i\in [l,r]} f(i,x)$。

当 $x++$ 时，$f(i,x)+=\max_{j\in [i,x]}a_j$，也就是当前的后缀 $[i,x]$ 最大值。所以 $f(i,x)=\max[i,i]+\max[i,i+1]+...+\max[i,x]=\sum_{j=i}^xmax[i,j]$，也就是**以 $i$ 为左端点**的后缀最大值的历史版本和。 所以 $s(l,r,x)$  为区间 $[l,r]$ 的历史版本和之和。

### conclusion 4

我会 beats + 历史版本和（线段树 3）！

直接做就行了，使用 beats 进行区间取 max，维护后缀最大值，线段树维护历史版本和，求 $s(l,r,x)$ 时在线段树上区间修改，时间复杂度为 $O(n\times \log_2^2n)$，瓶颈在使用 beats 进行区间取 max。

### conclusion 5

我会单调栈！

后缀 $[i,x]$ 具有单调性，可以使用单调栈维护后缀最大值，来替换 beats。由于每个位置只会入栈一次，所以复杂度为**大常数**的 $O(n \times \log_2n)$，瓶颈在维护历史版本和与区间查询，维护历史版本和的常数较大。

这里放一份 [\_maojun\_ 的代码](https://www.luogu.com.cn/record/162817348)。

### conclusion 6

我会观察性质！

注意 a 数列是随机生成的。~~众所周知~~可以证明，在数据随机数列中，使用单调栈维护前缀/后缀 min/max 值，单调栈的大小期望为 $O(\log_2n)$。

那就可以不使用常数较大的常规方式维护历史版本和了。对于当前一段后缀 max 相同的区间，区间内每个数对答案的贡献在目前都是相同的，对于每段区间维护一个时间戳，记录它是什么时候进入单调栈的。当这个区间被弹出时，在线段树上将这个区间的历史版本和更新。

与传统的历史版本和不同的是，现在只有在当前点被弹出时才在线段树上维护历史版本和。依然在单调栈中的点可以 $O(1)$ 计算贡献，而这种点又只有 $O(\log_2n)$ 种。

所以就获得了一种只需要区间修改和区间查询的线段树的做法，**相比之下常数更小**，复杂度为 $O(n \times \log_2n)$。可以将线段树改成 zkw 或超级树状数组。膜拜 \_maojun\_ 使用了超级树状数组获得了[最优解](https://www.luogu.com.cn/record/163151201)。

## AC Code

```cpp
#include<bits/stdc++.h>
#define ll long long
#define eb emplace_back
#define mem(arr,x) memset(arr,x,sizeof(arr))
using namespace std;
constexpr int maxn=1e5+10;
int n,q;
ll a[maxn];
struct node{int l,r,k,id;};
namespace SegmentTree{
    #define ls p<<1
    #define rs p<<1|1
    #define lson ls,l,mid
    #define rson rs,mid+1,r
    #define all 1,1,n
    #define setpos int p,int l,int r
    #define setmid int mid=(l+r)>>1
    ll tr[maxn<<2],tag[maxn<<2];
    inline void pushup(int p){tr[p]=tr[ls]+tr[rs];}
    inline void pushtag(setpos,ll s){tr[p]+=(r-l+1)*s;tag[p]+=s;}
    inline void pushdown(setpos){if(!tag[p])return;setmid;pushtag(lson,tag[p]);pushtag(rson,tag[p]);tag[p]=0;}
    void update(setpos,int pl,int pr,ll s){
        if(l>=pl&&r<=pr)    return pushtag(p,l,r,s);
        pushdown(p,l,r);
        setmid;
        if(pl<=mid) update(lson,pl,pr,s);
        if(pr>mid)  update(rson,pl,pr,s);
        pushup(p);
    }
    ll query(setpos,int pl,int pr){
        if(l>=pl&&r<=pr)    return tr[p];
        pushdown(p,l,r);
        setmid;ll res=0;
        if(pl<=mid) res=query(lson,pl,pr);
        if(pr>mid)  res+=query(rson,pl,pr);
        return res;
    }
}
using namespace SegmentTree;
namespace DataMaker{
    const int mod = 1e9;
    long long fst = 1023, sec = 1025;
    void solve(){
        for (int i = 1; i <= 100000; i++) {
            a[i] = fst ^ sec;
            fst = fst * 1023 % mod;
            sec = sec * 1025 % mod;
        }
    }
}
vector<node> v[maxn];
ll ans[maxn];
int stk[maxn],tp;
void solve(){
    mem(tr,0);mem(tag,0);tp=0;
    for(int i=1;i<=n;i++){
        while(tp&&a[stk[tp]]<=a[i]){
            update(all,stk[tp-1]+1,stk[tp],1ll*(i-stk[tp])*a[stk[tp]]);
            tp--;
        }
        stk[++tp]=i;
        for(auto [l,r,k,id]:v[i]){
            ll res=query(all,l,r);
            for(int j=1;j<=tp;j++){
                int len=min(stk[j],r)-max(stk[j-1],l-1);
                if(len<=0)   continue;
                res+=1ll*len*(i-stk[j]+1)*a[stk[j]];
            }
            ans[id]+=(res*k);
        }
    }
}
signed main(){
    scanf("%d",&q);
    n=1e5;
    DataMaker::solve();
    for(int i=1,l1,r1,l2,r2;i<=q;i++){
        scanf("%d%d%d%d",&l1,&r1,&l2,&r2);
        v[r2].eb(l1,r1,1,i);
        v[l2-1].eb(l1,r1,-1,i);
    }
    solve();
    for(int i=1;i<=n;i++)   a[i]*=-1;
    solve();
    for(int i=1;i<=q;i++)   printf("%lld\n",ans[i]);
}
```

## 总结

基于数组随机可以获得小常数的 $O(n\times \log_2n)$，不基于数组随机可以获得历史版本和做法的 $O(n \times \log_2n)$。

感谢 \_maojun\_ 的帮助，同时大力推荐[他的题解](https://www.luogu.com.cn/article/3wka43ys)。

*文中部分引用了他人的代码和提交记录，如有侵权行为，请及时私信博主，我会依法进行更改或删除。

---

## 作者：_maojun_ (赞：10)

一个不用 beats 的 DS 做法。

其实也本质一样的。具体就是注意到 P3246 还有一种不用 beats 的单调栈 + 线段树做法。

---

$\min$ 和 $\max$ 的过程是等价的。把 $a_i\gets-a_i$ 再做一遍 $\max$ 即可得到 $-\min$ 的结果。

考虑只有 $\max$，记 $w(l,r)=\max\limits_{i=l}^ra_i$。

记

$$S(l,r,x)=\sum\limits_{i=l}^r\sum\limits_{j=1}^xw(i,j)$$

差分得到：

$$
\begin{aligned}
\sum\limits_{i=l_1}^{r_1}\sum\limits_{j=l_2}^{r_2}w(i,j)
&=\sum\limits_{i=l_1}^{r_1}\sum\limits_{j=1}^{r_2}w(i,j)-\sum\limits_{i=l_1}^{r_1}\sum\limits_{j=1}^{l_2-1}w(i,j)\\
&=S(l_1,r_1,r_2)-S(l_1,r_1,l_2-1)
\end{aligned}
$$

把询问挂在 $x$ 上，按 $x$ 从小到大扫描线。

则扫到 $x$ 的时候 $S(l,r,x)$ 就是 $w(i,x)$ 历史和的 $[l,r]$ 区间和。

考虑维护 $w(i,x)$，直接做就是 beats 了。进一步可以发现 $w(i,x)$ 就是后缀 $\max$ 数组，有单调性。

所以掏出一个单调栈，把前缀取 $\max$ 的操作变成一个后缀推平，掏出一个区间推平区间历史和线段树维护即可。

【为了让读者看得到下面的内容，原来的代码被删了】

---

upd $2024.6.26$

傻了，不需要区间推平。注意到单调栈的存在也维护了颜色段，所以直接每段区间加即可。

其次，这里有一个非常简单且跑得非常快的做法，感谢 @[AbsMatt](https://www.luogu.com.cn/user/739274) 的提醒。

注意到数据随机，根据经典结论单调栈的大小期望是 $O(\log n)$ 的，所以直接遍历每个栈元素计算答案复杂度是对的。

具体就是，考虑每个栈元素，对历史和贡献分为“加入前”，“加入后删除前”，“删除后”。

“加入前”没有贡献，“删除后”的贡献就是一个固定的区间加，而“加入后删除前”的贡献形如 $a_i\Delta t$，其中 $t$ 是时间戳。

所以删除一个栈元素的时候，就把它的贡献区间加到一个数据结构上，计算区间答案的时候“删除后”的贡献直接在数据结构上查询区间和即可。

对于计算时“加入后删除前”的元素，可以直接遍历每一个，贡献就是 $a_i\Delta t\times len$，$len$ 是该栈元素对应的区间和询问区间的交的长度。

这个数据结构可以是线段树，也可以是树状数组。可以做到比较小常数的 $O(n\log n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;

typedef long long ll;
const int N=1e5+5;
int n=1e5,m,a[N];

ll c1[N],c2[N];
inline void upd(int l,int r,ll k){		// 区间加区间和的树状数组
	ll k2=k*(l-1);
	for(;l<=n;l+=l&-l){c1[l]+=k;c2[l]+=k2;}
	k2=k*r++;
	for(;r<=n;r+=r&-r){c1[r]-=k;c2[r]-=k2;}
}
inline ll qry(int p){
	ll s1=0,s2=0;
	for(int i=p;i;i^=i&-i){s1+=c1[i];s2+=c2[i];}
	return s1*p-s2;
}
vector<tuple<int,int,int,bool>>q[N];ll ans[N];
#define eb emplace_back
int top,stk[N],tim[N];
inline void solve(){
#define mem(a) memset(a,0,sizeof a)
	mem(c1);mem(c2);top=0;
	for(int x=1;x<=n;x++){
		for(;top&&a[x]>=a[stk[top]];top--)
			upd(stk[top-1]+1,stk[top],(ll)(x-tim[top])*a[stk[top]]);
		stk[++top]=x;tim[top]=x;
		for(auto[l,r,i,o]:q[x]){
			ll res=qry(r)-qry(l-1);
			for(int t=1;t<=top;t++){
				int len=min(stk[t],r)-max(stk[t-1],l-1);
				if(len>0)res+=(x-tim[t]+1ll)*a[stk[t]]*len;
			}
			ans[i]+=o?-res:res;
		}
	}
}
int main(){
	const int mod=1e9;
	int fst=1023,sec=1025;
	for(int i=1;i<=n;i++){
		a[i]=fst^sec;
		fst=fst*1023ll%mod;
		sec=sec*1025ll%mod;
	}
	scanf("%d",&m);
	for(int i=1,l1,r1,l2,r2;i<=m;i++){
		scanf("%d%d%d%d",&l1,&r1,&l2,&r2);
		q[r2].eb(l1,r1,i,0);
		q[l2-1].eb(l1,r1,i,1);
	}
	solve();
	for(int i=1;i<=n;i++)a[i]=-a[i];
	solve();
	for(int i=1;i<=m;i++)printf("%lld\n",ans[i]);
	return 0;
}
```

---

## 作者：沉石鱼惊旋 (赞：6)

# 题目思路

**本文提供一种依赖 $a_i$ 随机生成的解决方式。**

首先 $\min$ 和 $\max$ 可以拆开，原式就是：

$$(\sum_{l \in [l_1,r_1]} \sum_{r \in [l_2,r_2]} \max_{i \in [l,r]} a_i)-(\sum_{l \in [l_1,r_1]} \sum_{r \in [l_2,r_2]} \min_{i \in [l,r]} a_i)$$

然而把 $a$ 序列取相反数之后的 $\max$ 就是原序列的 $\min$，做两次 $\max$ 就行，这个 $\min$ 也可以先忽略不计。

那么我们其实求的就是：

$$\sum_{l \in [l_1,r_1]} \sum_{r \in [l_2,r_2]} \max_{i \in [l,r]} a_i$$

这个第二个 $\sum$ 可以前缀和优化。

设 $f_{lx,rx,x}$ 表示：

$$\sum_{l \in [lx,rx]} \sum_{r \in [1,x]} \max_{i \in [l,r]} a_i$$

就是左端点在 $[lx,rx]$ 且右端点不超过 $x$ 的和。那么 $f_{l_1,r_1,r_2}-f_{l_1,r_1,l_2-1}$ 就是我们这个询问的答案。

先把询问 $(l_1,r_1,l_2,r_2)$ 拆成 $(l_1,r_1,l_2-1,-1)$ 和 $(l_1,r_1,r_2,1)$ 这 $2$ 条询问。后面的 $-1$ 和 $1$ 表示应该减还是加。

那么这个问题我们可以对 $x$ 做扫描线处理。

具体的，我们从 $1$ 到 $n$ 扫一遍，观察到每一次修改，会在上一个比自己大的位置停下来。那么我们维护这样的单调下降的单调栈，栈内储存的是单调下降的元素的下标，设 $stk_j$ 为栈内元素。那么我们每一次会对 $(stk_{j-1},stk_j]$ 的元素造成 $a_{stk_j}$ 的贡献。

对拆出来的 $2Q$ 条询问以 $(l,r,x,sign)$ 的 $x$ 为关键字排序，维护一个指针，表示目前处理到了哪一条询问。对于 $x=i$ 的询问，我们只需要对于对应的原询问的 $ans$ 加上或减去 $[l,r]$ 部分的总和。

那么我们需要一个支持『区间加法，区间求和』的数据结构。两棵 BIT 或者一棵 SGT 即可。

这个做法的复杂度是 $\mathcal O(n\log^2 n)$。

复杂度是两只 $\log$ 而不是 $\mathcal O(n^2\log n)$ 的原因，是因为这个 $a_i$ 生成是随机的。随机数据情况下，单调栈的大小期望是 $\mathcal O(\log n)$ 级别的。

特殊处理一下如果询问 $l_2=1$ 那么会有 $l_2-1=0$ 的情况，这时候相当于没有任何需要减掉的东西，把这一部分的询问丢掉。

上面讲的是 $\max$ 的实现，把 $a_i$ 取相反数再做一次一模一样的就是 $\min$。

# 完整代码

[洛谷 record 174940433](https://www.luogu.com.cn/record/174940433)

```cpp
#include <bits/stdc++.h>
using namespace std;
#define getchar() p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1000000, stdin), p1 == p2) ? EOF : *p1++
char buf[1000000], *p1 = buf, *p2 = buf;
template <typename T>
void read(T &x)
{
    x = 0;
    int f = 1;
    char c = getchar();
    for (; c < '0' || c > '9'; c = getchar())
        if (c == '-')
            f = -f;
    for (; c >= '0' && c <= '9'; c = getchar())
        x = x * 10 + c - '0';
    x *= f;
}
template <typename T, typename... Args>
void read(T &x, Args &...y)
{
    read(x);
    read(y...);
}
template <class T>
void write(T x)
{
    static int stk[30];
    if (x < 0)
        putchar('-'), x = -x;
    int top = 0;
    do
    {
        stk[top++] = x % 10, x /= 10;
    } while (x);
    while (top)
        putchar(stk[--top] + '0');
}
template <class T>
void write(T x, char lastChar) { write(x), putchar(lastChar); }
typedef long long ll;
const int p = 1000000000;
ll pw1023 = 1, pw1025 = 1;
const int n = 100000;
int a[100020];
ll ans[40020];
struct SegTree
{
    struct node
    {
        ll sum, lzy;
    } t[100020 << 2];
#define ls id << 1
#define rs id << 1 | 1
#define Llen (mid - l + 1)
#define Rlen (r - mid)
    void clear()
    {
        for (int i = 1; i <= 100000 << 2; i++)
            t[i].sum = t[i].lzy = 0;
    }
    void push_up(int id) { t[id].sum = t[ls].sum + t[rs].sum; }
    void push_down(int id, int l, int r)
    {
        int mid = l + r >> 1;
        t[ls].sum += t[id].lzy * Llen;
        t[rs].sum += t[id].lzy * Rlen;
        t[ls].lzy += t[id].lzy;
        t[rs].lzy += t[id].lzy;
        t[id].lzy = 0;
    }
    void build(int id = 1, int l = 1, int r = n)
    {
        if (l == r)
            return t[id].sum = 0, void();
        int mid = l + r >> 1;
        build(ls, l, mid);
        build(rs, mid + 1, r);
        push_up(id);
    }
    void add(int ql, int qr, ll k, int id = 1, int l = 1, int r = n)
    {
        if (r < ql || l > qr)
            return;
        if (ql <= l && r <= qr)
            return t[id].lzy += k, t[id].sum += k * (r - l + 1), void();
        push_down(id, l, r);
        int mid = l + r >> 1;
        add(ql, qr, k, ls, l, mid);
        add(ql, qr, k, rs, mid + 1, r);
        push_up(id);
    }
    ll query(int ql, int qr, int id = 1, int l = 1, int r = n)
    {
        if (r < ql || l > qr)
            return 0;
        if (ql <= l && r <= qr)
            return t[id].sum;
        push_down(id, l, r);
        ll ans = 0;
        int mid = l + r >> 1;
        ans += query(ql, qr, ls, l, mid);
        ans += query(ql, qr, rs, mid + 1, r);
        return ans;
    }
} T;
int Q;
struct query
{
    int l, r, x, sign, id;
} q[80020];
int stk[100020], top;
void solve()
{
    top = 0;
    int j = 1;
    while (j <= 2 * Q && q[j].x == 0)
        j++;
    for (int i = 1; i <= n; i++)
    {
        while (top >= 1 && a[stk[top]] <= a[i])
            top--;
        stk[++top] = i;
        for (int j = 1; j <= top; j++)
            T.add(stk[j - 1] + 1, stk[j], a[stk[j]]);
        while (j <= 2 * Q && q[j].x == i)
            ans[q[j].id] += q[j].sign * T.query(q[j].l, q[j].r), j++;
    }
}
int main()
{
    for (int i = 1; i <= n; i++)
    {
        (pw1023 *= 1023) %= p;
        (pw1025 *= 1025) %= p;
        a[i] = pw1023 ^ pw1025;
        // cout << a[i] << " \n"[i == n];
    }
    read(Q);
    for (int i = 1; i <= Q; i++)
    {
        int l1, r1, l2, r2;
        read(l1, r1, l2, r2);
        q[i * 2 - 1] = {l1, r1, l2 - 1, -1, i};
        q[i * 2] = {l1, r1, r2, 1, i};
    }
    sort(q + 1, q + 2 * Q + 1, [&](auto x, auto y)
         { return x.x < y.x; });
    solve();
    for (int i = 1; i <= n; i++)
        a[i] = -a[i];
    T.clear();
    solve();
    for (int i = 1; i <= Q; i++)
        write(ans[i], '\n');
    return 0;
}
```

---

## 作者：THUPOST_REMAKE (赞：6)

本题解介绍的是**不依赖序列随机特性**的“**序列扫描线+维护线段树历史和**”的做法。时间复杂度为 $O((n+q)\log n)$。相较于 seg-beats，个人更推荐使用线段树历史和的做法进行练习。同时本题也可以作为 [[NOIP2022] 比赛](https://www.luogu.com.cn/problem/P8868) 的**绝佳前置练习**。

本文将具体介绍本题的具体思路，从矩阵乘法视角理解线段树历史和，线段树半群结构优化，以及其他类似习题的简单介绍。面向初学者会写的相对详尽一些。

## 本题题意

给定一个长度为 $n$ 的非负整数序列 $a$ 以及 $q$ 组询问。每组询问为四个整数 $l_1,r_1,l_2,r_2$，求 $\sum\limits _{l\in [l_1,r_1]}\sum\limits_{r\in [l_2,r_2]}(\max\limits_{i\in[l,r]}a_i-\min\limits_{i\in[l,r]}a_i)$ 。数据保证 $1\le l_1\le r_1\le n,~1\le l_2\le r_2\le n$。

## 题目思路

首先题目中的 $\max$ 和 $\min$ 这两项可以分开处理。另有 $\min\limits_{i\in[l,r]} a_i=\max\limits_{i\in[l,r]}-a_i$，所以我们可以统一按照 $\max$ 处理，以原始的序列 $a$ 以及全部取相反数之后的序列分别跑一遍得到的答案进行加和即为所求。此时问题变成了如何求解 $\sum\limits _{l\in [l_1,r_1]}\sum\limits_{r\in [l_2,r_2]}\max\limits_{i\in[l,r]}a_i$。

这个东西在线好像还是不太好求，我们可以考虑采用**离线扫描线**的思路来完成。将扫描线的过程分为两个维度，以**按照 $a_1,a_2,...,a_n$ 为顺序进行加点作为时间维**，以**通常的 $[1,n]$ 区间作为序列维**。我们称已经加入了 $a_1,...,a_r$ 的时间称为时间版本 $r$ 。此时维护序列上的第 $i$ 个元素 $x_i=\max\limits_{j\in[i,r]}(a_j)$ ，那么序列上 $[l_1,r_1]$ 的区间和就有 $\sum\limits_{i=l_1}^{r_1} x_i= \sum\limits_{l\in[l_1,r_1]}\max\limits_{i\in[l,r]} a_i$。

显然，原始要求的 $\sum\limits _{l\in [l_1,r_1]}\sum\limits_{r\in [l_2,r_2]}\max\limits_{i\in[l,r]}a_i$ 就变成了序列上 $[l_1,r_1]$ 在时间版本 $l_2,l_2+1,...,r_2$ 的区间和之和。又由于我们维护的答案具有可差分性，所以可以变成在 $r_2$ 版本的历史和（即截止至 $r_2$ 的所有时间版本 $1,2,...,r_2$ 的区间和总和）减 $l_1$ 版本的历史和。所以我们需要一个维护历史版本和的线段树即可。

接下来考虑扫描线的过程中，序列维度如何变化。考虑时间版本 $r$ 当中，$a_r$ 加入的过程。设 $r$ 左侧第一个 $l$ 满足 $a_l>a_r$ ，则该序列上的 $[l+1,r]$ 则会将 $x_i$ 统一赋值为 $r$ 。

但是维护区间赋值这个操作并不适合用线段树历史和来维护。那么我们可以考虑结合单调栈来维护 $x_i$ 相同的连续段，将区间赋值操作转换为对若干个连续段的区间以及 $[r,r]$ 的区间加操作（例：在 $r$ 之前需要赋值为 $a_r$ 的一段满足 $x_i=k$，则转成对该区间加 $a_r-k$）。不难证明区间加法的过程满足颜色段均摊，完整扫描过程的区间加法次数一定是 $O(n)$ 的。

然后将所有查询挂在时间维的 $l_2-1$ 和 $r_2$ 上，边扫描边进行区间查询即可。

## 从矩阵视角理解线段树历史和

本题当中的线段树历史和需要完成以下操作：

维护序列 $x$ 作为当前时间版本序列元素总和，$\text{his}$ 作为截止至当前时间版本的历史总和。区间加法操作即对一个区间上的 $x$ 统一加一个数 $v$，历史版本和刷新操作即对所有的 $\text{his}$ 统一加上其对应位置的 $x$。

按照通常方式去思考需要一定的思维量，但是如果我们使用矩阵乘法的方式去理解就会轻松很多。

设对于线段树上的每个节点，我们要维护的是列向量 $\left[\begin{matrix}\sum x_i\\l\\\sum \text{his}_i\end{matrix}\right]$，其中 $l$ 是当前节点代表序列区间的长度。则区间当前版本和以及区间历史和都可以直接通过维护列向量的加法求解。而上述两种操作我们也可以通过矩阵操作来完成。

对于区间加法操作，有：

$$
\left[\begin{matrix}1 & v & 0 \\0 & 1 & 0\\ 0& 0 & 1 \end{matrix}\right]\times \left[\begin{matrix}\sum x_i\\l\\\sum \text{his}_i\end{matrix}\right]=\left[\begin{matrix}\sum (x_i+v)\\ l \\\sum \text{his}_i \end{matrix}\right]
$$

对于刷新历史和操作，有：

$$
\left[\begin{matrix}1 & 0 & 0 \\0 & 1 & 0\\ 1& 0 & 1 \end{matrix}\right]\times \left[\begin{matrix}\sum x_i\\l\\\sum \text{his}_i\end{matrix}\right]=\left[\begin{matrix}\sum x_i\\ l \\\sum (\text{his}_i +x_i)\end{matrix}\right]
$$

此时的单位矩阵为 $\left[\begin{matrix}1 & 0 & 0 \\0 & 1 & 0\\ 0& 0 & 1 \end{matrix}\right]$，可以作为线段树的默认懒标记。于是我们已经可以在线段树上维护矩阵乘法，完成对历史和的维护了。

## 半群结构的优化

虽然对于本题来说，维护 $3\times 3$ 的矩阵足以通过时间限制。但是不难发现，该过程的诸多运算过程都是冗余的。矩阵运算本身是一种有结合律无交换律的半群结构，那么我们在进行优化的时候，设计出来的半群结构只需要和原始运算完全一致即可。

那么我们就需要观察上述矩阵乘法当中，有哪些位置的元素是会发生变化的，那么我们的半群只需要包含这些元素即可。不难发现对于本题的矩阵 $M$，设左上角为第 $0$ 行第 $0$ 列时，只有 $M_{01},M_{20},M_{21}$ 是有效的。所以我们的半群结构可以按照上述顺序，分别设置为 $\{a,b,c\}$。

接下来为该半群设计一个等价于矩阵乘法的运算，其实就是把这三个元素放回原本的矩阵当中，观察他们的变化是什么样的。

$$
\left[\begin{matrix}1 & a & 0 \\0 & 1 & 0\\ b& c & 1 \end{matrix}\right]\times \left[\begin{matrix}1 & a' & 0 \\0 & 1 & 0\\ b'& c' & 1 \end{matrix}\right]=\left[\begin{matrix}1 & a+a' & 0 \\0 & 1 & 0\\ b+b'& a'b+c+c' & 1 \end{matrix}\right]
$$

所以设两个半群 $L=\{a,b,c\},R=\{a',b',c'\}$，则有 $L\times R=\{a+a',b+b',a'b+c+c'\}$。该半群的单位元是 $\{0,0,0\}$。再次强调，由于该半群有结合律无交换律，所以一定要注意正确的运算顺序。

向量本身不需要优化，基于矩阵的优化半群和向量的运算类似上述处理即可，留给读者自己推导。本文给出的代码也是优化半群之后的版本。为了版面，完整代码放在最后。

此外，维护区间历史最值（见[历史最值模板题](https://www.luogu.com.cn/problem/P4314)）也可以先利用 $\max,+$ 广义乘法矩阵进行理解，再做优化。而由于 [动态 DP 模板题](https://www.luogu.com.cn/problem/P4719) 使用的也是 $\max,+$ 广义矩阵乘法，故类似的动态 DP 题目都可以使用类似方式进行半群的优化。

综上，我们以时间复杂度 $O((n+q)\log n)$，空间复杂度 $O(n+q)$ 通过了本题。

## 拓展练习 1 : [[NOIP2022] 比赛](https://www.luogu.com.cn/problem/P8868)

开头就说了，本题是该拓展练习的绝佳前置练习。

给定长度 $n$ 的序列 $a,b$，对于每次询问 $[l,r]$ 求 $\sum\limits_{l'\in[l,r]}\sum\limits_{r'\in[l,r]}(\max\limits_{i\in[l',r']}a_i\times \max\limits_{i\in[l',r']}b_i)$。

基本就是把这题的一个序列扩展成两个序列。对于每个时间版本 $r$ 设 $x_i=\max\limits_{j\in[i,r]}a_i$ 和 $y_i=\max\limits_{j\in[i,r]}b_i$，维护当前版本的 $\sum x_iy_i$ 以及其对应的区间和即可。而加入 $a_r,b_r$ 时，类似本题转单调栈维护颜色段均摊，然后转区间对 $x$ 加以及区间对 $y$ 加。这两个操作对 $\sum xy$ 的影响不难做。本题中需要维护 $\begin{bmatrix}
\text{his} \\ \sum xy \\ \sum x \\ \sum y \\ l
\end{bmatrix}$ 这样的列向量，然后区间对 $x$ 加，区间对 $y$ 加，区间版本刷新也可以转成三个 $5\times 5$ 的变换矩阵。

而由于单次矩阵乘法运算量 $5^3$ 过大，类似上方做半群优化，可以发现矩阵上本质会变化的元素只有 $9$ 个。完成半群优化之后即可通过本题。具体可参考其他人的题解。

## 拓展练习 2 : [SPOJ GSS2](https://www.luogu.com.cn/problem/SP1557)

区间最大子段和，**但是子段内相同的数只会贡献一次**（比如选取子段是 $1,1,4,5$，那子段和就是 $1+4+5=10$）。

可以类似[HH 的项链](https://www.luogu.com.cn/problem/P1972)一题，记录每个位置 $i$ 的前一个相同元素位置 $\text{pre}_i$。然后同样以序列加点顺序作为时间维，正常维护序列维。对于时间版本 $r$，序列维元素 $x_i$ 代表 $[i,r]$ 区间按照本题规则计算的子段和。则 $\max\limits_{i\in[l,r]}x_i$ 则代表 $[l,r]$ 在当前版本下的最大子段和。显然对该区间求历史最值即为本题所求。而加入 $a_r$ 时的维护则考虑 $x_i$ 的意义，直接对 $[\text{pre}_r+1,r]$ 区间加 $a_r$ 即可。具体可以参考其他人的题解，建议先完成历史最值模板题。

## 本题代码

```c++
const int N = 100010;
int n, q;
int a[N];
i64 ans[N];
namespace gen
{
    const int mod = 1000000000;
    i64 fst = 1023, sec = 1025;
    void init()
    {
        for (int i = 1; i <= n; ++i)
            a[i] = fst ^ sec, fst = fst * 1023 % mod, sec = sec * 1025 % mod;
    }
}
struct query
{
    int l1, r1, r, id, flag; // flag = 1 : add -1 : sub
    bool operator<(const query &o) const { return r < o.r; }
} qu[N];
// monotone stack
struct interval
{
    int l, r, mx;
} stk[N];
int stksz;
// history sum seg-tree
inline int lc(int u) { return u << 1; }
inline int rc(int u) { return (u << 1) | 1; }
struct vec
{
    i64 a, len, his;
    vec(i64 _a = 0, i64 l = 0, i64 h = 0) : a(_a), len(l), his(h) {}
    vec operator+(const vec &o) const { return vec(a + o.a, len + o.len, his + o.his); }
};
struct mat
{
    i64 a, b, c;
    mat() { a = b = c = 0; }
    mat(i64 _a, i64 _b, i64 _c) : a(_a), b(_b), c(_c) {}
    mat(i64 v, bool flag) { (flag ? (b = 1, a = 0) : (a = v, b = 0)), c = 0; } // flag 1 : his = his + a 0 : a += v
    mat operator*(const mat &o) const { return mat(a + o.a, b + o.b, o.a * b + c + o.c); }
    vec operator*(const vec &o) const { return vec(o.a + a * o.len, o.len, b * o.a + c * o.len + o.his); }
};
struct node
{
    mat tag;
    vec info;
    void init(int val) { info = vec(val, 1, val); }
    void modify(const mat &v) { tag = v * tag, info = v * info; }
} tr[N << 2];
void pushup(int u) { tr[u].info = tr[lc(u)].info + tr[rc(u)].info; }
void pushdown(int u) { tr[lc(u)].modify(tr[u].tag), tr[rc(u)].modify(tr[u].tag), tr[u].tag = mat(); }
void build(int u, int l, int r)
{
    tr[u].tag = mat();
    if (l == r)
        return tr[u].init(0);
    int m = (l + r) >> 1;
    build(lc(u), l, m), build(rc(u), m + 1, r), pushup(u);
}
void modify(int u, int L, int R, int l, int r, const mat &v)
{
    if (L > r || R < l)
        return;
    if (l <= L && R <= r)
        return tr[u].modify(v);
    pushdown(u);
    int M = (L + R) >> 1;
    modify(lc(u), L, M, l, r, v), modify(rc(u), M + 1, R, l, r, v);
    pushup(u);
}
vec query_vec(int u, int L, int R, int l, int r)
{
    if (L > r || R < l)
        return vec();
    if (l <= L && R <= r)
        return tr[u].info;
    pushdown(u);
    int M = (L + R) >> 1;
    return query_vec(lc(u), L, M, l, r) + query_vec(rc(u), M + 1, R, l, r);
}
void clr() { build(1, 1, n), stksz = 0; }
void solve()
{
    int j = 1;
    while (!qu[j].r)
        ++j;
    for (int i = 1; i <= n; ++i)
    {
        // modify version r
        modify(1, 1, n, i, i, mat(a[i], 0));
        while (stksz && stk[stksz].mx < a[i])
            modify(1, 1, n, stk[stksz].l, stk[stksz].r, mat(a[i] - stk[stksz].mx, 0)), --stksz;
        ++stksz, stk[stksz] = {stk[stksz - 1].r + 1, i, a[i]};
        modify(1, 1, n, 1, n, mat(0, 1)); // add version r's sum to history.
        for (; j <= q && qu[j].r == i; ++j)
            ans[qu[j].id] += qu[j].flag * query_vec(1, 1, n, qu[j].l1, qu[j].r1).his;
    }
}
int main()
{
    n = 100000, gen::init();
    q = rd();
    for (int i = 1; i <= q; ++i)
    {
        int l1 = rd(), r1 = rd(), l2 = rd(), r2 = rd();
        qu[(i << 1) - 1] = {l1, r1, l2 - 1, i, -1}, qu[i << 1] = {l1, r1, r2, i, 1};
    }
    q <<= 1, std::sort(qu + 1, qu + q + 1);
    clr(), solve();
    for (int i = 1; i <= n; ++i)
        a[i] = -a[i];
    clr(), solve();
    q >>= 1;
    for (int i = 1; i <= q; ++i)
        wr(ans[i]), putchar('\n');
}
```

---

## 作者：Eraine (赞：6)

来源：BZOJ4262

编号：Luogu 10637

tag：线段树

难度：紫

$$\sum_{l\in[l1,r1]}\sum_{r\in[l2,r2]}(\max_{i\in[l,r]}a_i-\min_{i\in[l,r]}a_i)=\sum_{l\in[l1,r1]}\sum_{r\in[l2,r2]}\max_{i\in[l,r]}a_i-\sum_{l\in[l1,r1]}\sum_{r\in[l2,r2]}\min_{i\in[l,r]}a_i$$

$\max$ 和 $\min$ 没有本质区别。所以我们只考虑 $\max$。

设每个区间 $[l,r]$ 的贡献位置为最小的 $i$ 使得 $a_i=\max_{j\in[l,r]}a_j$，那么我们只要考虑出每个贡献位置在询问中的总贡献（值乘贡献次数）之和即可。对于一个 $i$，它会对所有区间 $[l,r]$ 使得 $l\le i\le r,\max_{j\in[l,i)}a_j\lt a_i,\max_{j\in(i,r]}a_j\le a_i$。显然左右端点独立。二分求出最小左端点 $L$ 和最大右端点 $R$，即转变为对所有左端点在 $[L,i]$ 且右端点在 $[i,R]$ 的区间贡献 $a_i$。转化成二维问题，可看成矩阵加。而询问即可看成矩阵求和。

那么此时问题转换成矩阵加，矩阵求和。矩阵加可以通过差分转换成单点加。一眼好像不太好矩阵求和，我们这里只能查询一条线段上的和。也就是需要记录历史和。但是我们发现对于同一水平线上（$y=k$），一个矩阵最多只会对这条水平线分割成三段，而这三段中每一段的值关于 $x$ 的一次函数。所以我们只需要维护这个一次函数就好了。

具体地，在更新时，假设目前需要更新的矩阵为 $[l_1,r_1],[l_2,r_2]$，扫描线解决第一维，扫描到 $l_1$ 时在 $[l_2,r_2]$ 上加上一次函数 $y=kx+b,k=a_i,b=-a_i(l_1-1)$，扫描到 $r_1+1$ 时在 $[l_2,r_2]$ 上加上一次函数 $y=kx+b,k=-a_i,b=a_ir_1$。注意这里的 $[l_2,r_2]$ 加上一次函数指的是该区间的所有位置全部需要加上一次函数（每个位置都是这么多贡献）。在查询时，只需代入 $x$（即当前扫描线位置）即可。查询到每一个完全包含区间时，用 $x$ 带入 $y=kx+b$ 计算 $y$ 再求和。

代码又写得很史。仅供娱乐。

$\Theta(n\log n+T\log n)$。

[submission](https://www.luogu.com.cn/record/174924557)

若有疑问或错误请指出，虚心接受您的意见。

---

## 作者：ケロシ (赞：4)

非常简单的一道题。

同样是 SgT Beats，隔壁 [P10639 BZOJ4695 最佳女选手](https://www.luogu.com.cn/problem/P10639) 做的人好多，这里就没什么人做，差评。

本质和 [P3246 [HNOI2016] 序列](https://www.luogu.com.cn/problem/P3246) 没有区别，都是离线询问然后扫描线，然后在线段树上进行区间最值操作和区间查询历史和。具体的，在时刻 $i$，将区间 $[1,i]$ 对 $a_i$ 进行最值操作，那么此时线段树上 $[1,i]$ 的值就是 $\max_{j=p}^{i}a_j$ 或者 $\min_{j=p}^{i}a_j$ 的值，那么求一段子区间的答案就是求区间的历史和，这个很好理解。这道题由于左右端点都有范围，所以需要两段历史和前缀相减，要把询问拆成 $r_2$ 时刻的 $[l_1,r_1]$ 历史和减去 $l_2-1$ 时刻的 $[l_1,r_1]$ 历史和。

然后就是经典问题，线段树区间最值操作与区间历史和。

对于最值操作，考虑 Beats。以计算 $\min$ 为例，维护最大值，次大值和最大值出现次数，最值操作时不断递归，知道等下最值修改的是小于最大值，大于次大值，这样最值操作只会影响最大值，这样就只用处理一种数了，非常方便，然后时间复杂度是对的，是 $O(n \log n)$。

对于历史和，需要记录一些 tag，例如当前区间修改的次数和修改历史和的值的 tag。注意，对于修改次数的 tag，即使区间操作没有对某区间产生影响，如最值修改的数大于最大值，这时候没有影响，但是也要推一个值的一的修改次数 tag，为了能正确维护历史和。

对与如何更新历史和有疑问的可以观察代码，这还是比较简单的。

时间复杂度 $O(n \log n)$。

```cpp
const int N = 1e5 + 5;
const int P = 1e9;
const int INF = 2.2e9;
int n, m, a[N];
vector<array<int, 4>> e[N];
ll ans[N];
void init() {
	ll fst = 1023, sec = 1025;
	n = 1e5;
	FOR(i, 1, n) {
		a[i] = fst ^ sec;
		fst = fst * 1023 % P;
		sec = sec * 1025 % P;
	}
}
struct SgT {
	int le[N << 2], ri[N << 2];
	int F[N << 2][2], G[N << 2][2], C[N << 2][2], T[N << 2][2], TC[N << 2][2];
	// F 为最大值和次大值，G 为最小值与次小值，C 为最大最小出现次数，
	// T 为最值操作值的 tag，TC 为区间操作次数的 tag
	ll S[N << 2][2], H[N << 2][2], TH[N << 2][2];
	// S 为区间和，H 为区间历史和，TH 为区间历史和的 tag
	void pushup(int u) {
		S[u][0] = S[u << 1][0] + S[u << 1 | 1][0];
		S[u][1] = S[u << 1][1] + S[u << 1 | 1][1];
		F[u][0] = max(F[u << 1][0], F[u << 1 | 1][0]);
		G[u][0] = min(G[u << 1][0], G[u << 1 | 1][0]);
		H[u][0] = H[u << 1][0] + H[u << 1 | 1][0];
		H[u][1] = H[u << 1][1] + H[u << 1 | 1][1];
		if(F[u << 1][0] > F[u << 1 | 1][0]) {
			F[u][1] = max(F[u << 1][1], F[u << 1 | 1][0]);
			C[u][0] = C[u << 1][0];
		}
		else if(F[u << 1][0] < F[u << 1 | 1][0]) {
			F[u][1] = max(F[u << 1][0], F[u << 1 | 1][1]);
			C[u][0] = C[u << 1 | 1][0];
		}
		else {
			F[u][1] = max(F[u << 1][1], F[u << 1 | 1][1]);
			C[u][0] = C[u << 1][0] + C[u << 1 | 1][0];
		}
		if(G[u << 1][0] < G[u << 1 | 1][0]) {
			G[u][1] = min(G[u << 1][1], G[u << 1 | 1][0]);
			C[u][1] = C[u << 1][1];
		}
		else if(G[u << 1][0] > G[u << 1 | 1][0]) {
			G[u][1] = min(G[u << 1][0], G[u << 1 | 1][1]);
			C[u][1] = C[u << 1 | 1][1];
		}
		else {
			G[u][1] = min(G[u << 1][1], G[u << 1 | 1][1]);
			C[u][1] = C[u << 1][1] + C[u << 1 | 1][1];
		}
	}
	void push_max(int u, int x, int c, ll h) {
		H[u][0] += 1ll * c * S[u][0] + h * C[u][0];
		// 操作时旧的和加上历史和修改的和
		TH[u][0] += 1ll * T[u][0] * c + h;
		// 历史和修改的 tag 需要加上当前的最值 tag
		F[u][0] += x;
		T[u][0] += x;
		S[u][0] += 1ll * x * C[u][0];
		TC[u][0] += c; 
	}
	void push_min(int u, int x, int c, ll h) {
		H[u][1] += 1ll * c * S[u][1] + h * C[u][1];
		TH[u][1] += 1ll * T[u][1] * c + h;
		G[u][0] += x;
		T[u][1] += x;
		S[u][1] += 1ll * x * C[u][1];
		TC[u][1] += c; 
	}
	void pushdown(int u) {
		if(TC[u][0]) {
			int val = max(F[u << 1][0], F[u << 1 | 1][0]);
			// 判断对哪边有影响
			if(F[u << 1][0] == val) push_max(u << 1, T[u][0], TC[u][0], TH[u][0]);
			else push_max(u << 1, 0, TC[u][0], 0); // 注意没有影响也要更新操作次数，维护历史和
			if(F[u << 1 | 1][0] == val) push_max(u << 1 | 1, T[u][0], TC[u][0], TH[u][0]);
			else push_max(u << 1 | 1, 0, TC[u][0], 0);
			TH[u][0] = T[u][0] = TC[u][0] = 0;
		}
		if(TC[u][1]) {
			int val = min(G[u << 1][0], G[u << 1 | 1][0]);
			if(G[u << 1][0] == val) push_min(u << 1, T[u][1], TC[u][1], TH[u][1]);
			else push_min(u << 1, 0, TC[u][1], 0);
			if(G[u << 1 | 1][0] == val) push_min(u << 1 | 1, T[u][1], TC[u][1], TH[u][1]);
			else push_min(u << 1 | 1, 0, TC[u][1], 0);
			TH[u][1] = T[u][1] = TC[u][1] = 0;
		}
	}
	void build(int u, int l, int r) {
		le[u] = l, ri[u] = r;
		if(l == r) {
			F[u][0] = G[u][0] = S[u][0] = S[u][1] = a[l];
			F[u][1] = -INF, G[u][1] = INF;
			C[u][0] = C[u][1] = 1;
			return;
		}
		int mid = l + r >> 1;
		build(u << 1, l, mid);
		build(u << 1 | 1, mid + 1, r);
		pushup(u);
	}
	void modify_max(int u, int l, int r, int x) {
		if(l <= le[u] && ri[u] <= r && F[u][0] <= x) { // 这里也要更新操作次数
			push_max(u, 0, 1, 0);
			return;
		}
		if(l <= le[u] && ri[u] <= r && F[u][1] < x && x < F[u][0]) { // 进行最值操作
			push_max(u, x - F[u][0], 1, x - F[u][0]);
			return;
		}
		pushdown(u);
		int mid = le[u] + ri[u] >> 1;
		if(l <= mid) modify_max(u << 1, l, r, x);
		if(mid < r) modify_max(u << 1 | 1, l, r, x);
		pushup(u);
	}
	void modify_min(int u, int l, int r, int x) {
		if(l <= le[u] && ri[u] <= r && G[u][0] >= x) {
			push_min(u, 0, 1, 0);
			return;
		}
		if(l <= le[u] && ri[u] <= r && G[u][1] > x && x > G[u][0]) {
			push_min(u, x - G[u][0], 1, x - G[u][0]);
			return;
		}
		pushdown(u);
		int mid = le[u] + ri[u] >> 1;
		if(l <= mid) modify_min(u << 1, l, r, x);
		if(mid < r) modify_min(u << 1 | 1, l, r, x);
		pushup(u);
	}
	ll query_max(int u, int l, int r) {
		if(l <= le[u] && ri[u] <= r) {
			return H[u][0];
		}
		pushdown(u);
		int mid = le[u] + ri[u] >> 1;
		if(r <= mid) return query_max(u << 1, l, r);
		if(mid < l) return query_max(u << 1 | 1, l, r);
		return query_max(u << 1, l, r) + query_max(u << 1 | 1, l, r);
	}
	ll query_min(int u, int l, int r) {
		if(l <= le[u] && ri[u] <= r) {
			return H[u][1];
		}
		pushdown(u);
		int mid = le[u] + ri[u] >> 1;
		if(r <= mid) return query_min(u << 1, l, r);
		if(mid < l) return query_min(u << 1 | 1, l, r);
		return query_min(u << 1, l, r) + query_min(u << 1 | 1, l, r);
	}
} t;
void solve() {
	init();
	t.build(1, 1, n);
	cin >> m;
	FOR(i, 1, m) {
		int l1, r1, l2, r2;
		cin >> l1 >> r1 >> l2 >> r2;
		// 前缀拆分一下
		e[l2 - 1].push_back({l1, r1, i, -1});
		e[r2].push_back({l1, r1, i, 1});
	}
	FOR(i, 1, n) { // 扫描线
		t.modify_max(1, 1, i, a[i]); // 更新最值
		t.modify_min(1, 1, i, a[i]);
		for(auto h : e[i]) { // 查询历史和
			ans[h[2]] += h[3] * (t.query_min(1, h[0], h[1]) - t.query_max(1, h[0], h[1]));
		}
	}
	FOR(i, 1, m) cout << ans[i] << endl;
}
```

---

## 作者：BreakPlus (赞：3)

一个不用写线段树的神秘做法。

由于数据随机，笛卡尔树的树高期望为 log。那么我们可以近似地把笛卡尔树看作线段树，在笛卡尔树上维护信息。

----

先考虑 $[l_1,r_1]$ 与 $[l_2,r_2]$ 不交的情况。

令 $\operatorname{solve}(l_1,r_1,l_2,r_2,rt)$ 表示考虑笛卡尔树上以 $rt$ 为根的子树内，询问区间为 $[l_1,r_1]$ 与 $[l_2,r_2]$ 的答案，令 $pos_{rt}$ 表示笛卡尔树上 $rt$ 这个点所管辖的**区间**。求解过程中，应满足 $[l_1,r_1],[l_2,r_2]$ 为 $pos_{rt}$ 的子区间。

先算出所有经过 $rt$ 的区间的答案。发现算完之后，最多只会向一个儿子递归一个 $\operatorname{solve}$（对 $rt$ 和区间端点的大小关系进行分讨即可）。不断递归下去算就是对的了。

如果相交，那么可能会向 $rt$ 的两个儿子分别递归子问题。复杂度不能接受。

但是，类比线段树区间查询的复杂度分析，如果能在 $pos_{rt} = [l_1,r_1] = [l_2,r_2]$ 的时候停止递归，直接返回答案，那么复杂度就是正确的。

需要预处理出每个子树内的答案。类似线段树的 build，可以比较轻松的合并信息。

```cpp
const int mod = 1e9, n = 1e5;
ll a[n+5];
struct Seg{
	ll l,r,sz;
	Seg(ll L=0, ll R=0): l(L), r(R), sz(L<=R?R-L+1:0) {}
};
Seg operator& (Seg A, Seg B){
	return Seg(max(A.l,B.l), min(A.r,B.r));
}
Seg operator| (Seg A, Seg B){
	return Seg(min(A.l,B.l), max(A.r,B.r));
}
bool operator== (Seg A, Seg B){
	return (A.l==B.l) && (A.r==B.r);
}
struct Tree{
	ll w[n+5], lc[n+5], rc[n+5]; Seg p[n+5];
	ll stk[n+5], tp, rt, ans[n+5];
	void build(){
		for(ll i=1;i<=n;i++){
			while(tp && w[stk[tp]]<w[i]) lc[i]=stk[tp],--tp;
			if(tp) rc[stk[tp]]=i;
			stk[++tp]=i;
		}
		rt=stk[1];
	}
	void dfs(ll x){
		p[x] = Seg(x, x);
		if(lc[x]) dfs(lc[x]), p[x]=p[x]|p[lc[x]];
		if(rc[x]) dfs(rc[x]), p[x]=p[x]|p[rc[x]];
	}
	void press(ll x){
		if(p[x].l==p[x].r) {
			ans[x]=w[x];
			return;
		}
		if(lc[x]) press(lc[x]);
		if(rc[x]) press(rc[x]);
		ans[x] = ans[lc[x]] + ans[rc[x]] + (x-p[x].l+1)*(p[x].r-x+1)*w[x];
	}
	ll query(ll x,Seg L,Seg R){
		if(!L.sz || !R.sz) return 0;
		if(p[x]==L && p[x]==R) return ans[x];
		ll ret = (L&Seg(p[x].l,x)).sz * (R&Seg(x,p[x].r)).sz * w[x];
		if(lc[x]) ret += query(lc[x], L&p[lc[x]], R&p[lc[x]]);
		if(rc[x]) ret += query(rc[x], L&p[rc[x]], R&p[rc[x]]);
		return ret;
	}
}t[2];

void solve(){
	ll fst=1023,sec=1025;
	for(ll i=1;i<=100000;i++) {
		a[i]=fst^sec;
		t[0].w[i]=a[i]; t[1].w[i]=-a[i];
		fst=fst*1023%mod;
		sec=sec*1025%mod;	
	}
	t[0].build(); t[0].dfs(t[0].rt); t[1].build(); t[1].dfs(t[1].rt);
	t[0].press(t[0].rt); t[1].press(t[1].rt);
	ll q=read();
	while(q--){
		ll l1=read(), r1=read(), l2=read(), r2=read();
		printf("%lld\n",t[0].query(t[0].rt,Seg(l1,r1),Seg(l2,r2))+t[1].query(t[1].rt,Seg(l1,r1),Seg(l2,r2)));
	}
}
```

---

## 作者：KingPowers (赞：2)

被放在了 **NOIP 模拟赛 T1**，赛时没注意这个序列的生成方式，写了一个不基于随机的单 $\log$ 做法，虽然好像跑得很慢。

对于题目中给的式子，$\max$ 的部分和 $\min$ 的部分其实并没有本质区别，我们只考虑 $\max$ 的部分怎么计算，$\min$ 的部分其实是对称的，也就是要求：

$$
\sum_{l\in[l_1,r_1]}\sum_{r\in[l_2,r_2]}\max_{i=l}^r a_i
$$
首先特判掉答案为 $0$ 的询问，这是平凡的。

考虑一个弱化问题：假如限制是 $l,r\in[l_1,r_1]$，也就是限制 $l,r$ 在一个区间内，那么就相当于是询问这个区间内所有子区间的最大值之和。这个问题是相对经典的，考虑扫描线。枚举右端点 $r$，则对于任意左端点 $l$ 配合单调栈+线段树区间覆盖可以维护出 $[l,r]$ 的最大值，我们发现固定右端点为 $r$ 的答案就是 $\forall p\in[l,r]$，$[p,r]$ 的最大值之和，体现在线段树上就相当于询问一个区间和。那询问所有子区间呢？不难发现相当于是询问一个区间历史版本和，如果你做过 NOIP2022 的 T4 对这一步应该非常熟悉。

现在的问题和上面的其实区别不大，我们考虑差分成上面的问题，然后一样离线下来跑扫描线，具体地需要对询问区间关系分一下类。

- 如果询问的区间满足 $l_1\le l_2\le r_1\le r_2$，那么贡献为：$[l_1,r_2]$ 所有子区间的最大值之和，减去 $[l_1,l_2)$ 所有子区间的最大值之和，再减去 $(r_1,r_2]$ 所有子区间的最大值之和。
- 如果询问的区间满足 $l_1\le l_2\le r_2\le r_1$，那么贡献为：$[l_1,r_2]$ 所有子区间的最大值之和，减去 $[l_1,l_2)$ 所有子区间的最大值之和。

以上两种情况都是两个区间有交的情况，对于无交的情况（即 $l_1\le r_1<l_2\le r_2$，如下图），我们发现好像不太能按照上面方式差分。

![](https://cdn.luogu.com.cn/upload/image_hosting/px7z6b3l.png)

如果我们继续按照上述的方式扫描线，我们发现这个询问的答案应该是：

- 当扫描的右端点 $r\in[l_2,r_2]$ 时，对答案产生区间 $[l_1,r_1]$ 的历史版本和的贡献。

我们又注意到，历史和对右端点也是可差分的，所以这种询问我们应该计算：

- 右端点扫到 $r_2$ 时区间 $[l_1,r_1]$ 的历史版本和，减去右端点扫到 $l_2-1$ 时区间 $[l_1,r_1]$ 的历史版本和。

所以直接分情况将每种询问拆开，离线后扫描线即可。

扫描线时需要配合单调栈，线段树支持区间覆盖、询问区间历史和，如果你不会维护这个可以写成矩阵乘法然后拆出非常数项。

时间复杂度 $O((n+q)\log n)$，这里 $n$ 为序列长度，$q$ 为询问个数。

```cpp
#include<bits/stdc++.h>
#define int long long
#define For(i, a, b) for(int i = (a); i <= (b); i++)
#define Rof(i, a, b) for(int i = (a); i >= (b); i--)
#define deb(x) cerr << #x"=" << x << '\n';
using namespace std;
const int N = 1e5 + 5, mod = 1e9;
int n = 1e5, q, a[N], ans1[N], ans2[N];
vector<array<int, 4>> vec[N];  //l r w id
int qpow(int x, int y){
	int res = 1;
	while(y){
		if(y & 1) res = res * x % mod;
		x = x * x % mod; y /= 2;
	}
	return res;
}
struct node{
	int sum, hsum, len;
}tr[N << 2];
struct tag{
	int t1, t2, t3, t4;
	bool empty(){return t1 == 1 && !t2 && !t3 && !t4;}
}tg[N << 2];
#define ls now << 1
#define rs now << 1 | 1
void pushup(int now){
	tr[now].sum = tr[ls].sum + tr[rs].sum;
	tr[now].hsum = tr[ls].hsum + tr[rs].hsum;
	tr[now].len = tr[ls].len + tr[rs].len;
}
void build(int l, int r, int now){
	tr[now].len = r - l + 1;
	tr[now].sum = tr[now].hsum = 0;
	tg[now] = {1, 0, 0, 0};
	if(l == r) return;
	int mid = (l + r) >> 1;
	build(l, mid, ls); build(mid + 1, r, rs);
}
tag merge(tag a, tag b){
	tag c;
	c.t1 = a.t1 * b.t1;
	c.t2 = a.t1 * b.t2 + a.t2;
	c.t3 = a.t3 * b.t1 + b.t3;
	c.t4 = a.t3 * b.t2 + a.t4 + b.t4;
	return c;
}
node mul(node a, tag b){
	node c;
	c.sum = a.sum * b.t1 + a.len * b.t3;
	c.hsum = a.sum * b.t2 + a.hsum + a.len * b.t4;
	c.len = a.len;
	return c;
}
void pushdown(int now){
	if(!tg[now].empty()){
		tr[ls] = mul(tr[ls], tg[now]);
		tg[ls] = merge(tg[ls], tg[now]);
		tr[rs] = mul(tr[rs], tg[now]);
		tg[rs] = merge(tg[rs], tg[now]);
		tg[now] = {1, 0, 0, 0};
	}
}
void modify(int x, int y, tag w, int l, int r, int now){
	if(x <= l && r <= y){
		tr[now] = mul(tr[now], w);
		tg[now] = merge(tg[now], w);
		return;
	}
	pushdown(now); int mid = (l + r) >> 1;
	if(x <= mid) modify(x, y, w, l, mid, ls);
	if(y > mid) modify(x, y, w, mid + 1, r, rs);
	pushup(now);
}
int query(int x, int y, int l, int r, int now){
	if(x <= l && r <= y) return tr[now].hsum;
	pushdown(now); int mid = (l + r) >> 1, ans = 0;
	if(x <= mid) ans += query(x, y, l, mid, ls);
	if(y > mid) ans += query(x, y, mid + 1, r, rs);
	return ans;
}
#undef ls
#undef rs
int top, st[N];
void solve_mx(){
	st[top = 0] = 0;
	build(1, n, 1);
	For(i, 1, n){
		while(top && a[st[top]] < a[i]) top--;
		modify(st[top] + 1, i, {0, 0, a[i], 0}, 1, n, 1);
		modify(1, n, {1, 1, 0, 0}, 1, n, 1);
		st[++top] = i;
		for(auto [l, r, w, id] : vec[i]) ans1[id] += w * query(l, r, 1, n, 1);
	}
}
void solve_mn(){
	st[top = 0] = 0;
	build(1, n, 1);
	For(i, 1, n){
		while(top && a[st[top]] > a[i]) top--;
		modify(st[top] + 1, i, {0, 0, a[i], 0}, 1, n, 1);
		modify(1, n, {1, 1, 0, 0}, 1, n, 1);
		st[++top] = i;
		for(auto [l, r, w, id] : vec[i]) ans2[id] += w * query(l, r, 1, n, 1);		
	}
}
void Solve(){
	cin >> q;
	For(i, 1, n) a[i] = qpow(1023, i) ^ qpow(1025, i);
	For(i, 1, q){
		int l1, r1, l2, r2;
		cin >> l1 >> r1 >> l2 >> r2;
		l2 = max(l2, l1); if(l2 > r2) continue;
		if(l2 > r1){  //case1：无交
			vec[r2].push_back({l1, r1, 1, i});
			vec[l2 - 1].push_back({l1, r1, -1, i});
		}
		else{  //case2：相交
			vec[r2].push_back({l1, r2, 1, i});
			if(r2 > r1) vec[r2].push_back({r1 + 1, r2, -1, i});
			if(l2 > l1) vec[l2 - 1].push_back({l1, l2 - 1, -1, i});
		}
	}
	solve_mx(); solve_mn();
	For(i, 1, q) cout << ans1[i] - ans2[i] << '\n';
}
signed main(){
	// freopen("meteor.in", "r", stdin);
	// freopen("meteor.out", "w", stdout);
	ios::sync_with_stdio(0);
	cin.tie(0); cout.tie(0);
	int T = 1; //cin >> T;
	while(T--) Solve();
	return 0;
}
```

---

## 作者：MatrixGroup (赞：2)

不妨认为给出的序列 $a$ 是随机的。以下只考虑 $\max$，因为 $\min$ 可以类似求出。设 $n=10^5$。

考虑设 $f_{i,j}=\begin{cases}\max\limits_{k=i}^j a_i&i\le j\\0&i>j\end{cases}$。根据经典结论，对于每个 $j$，期望 $f_{i,j}$ 的连续段个数是 $O(\log j)$ 的，且可以通过单调栈求出。

将询问离线下来，维护一个序列 $x$，每次对于一个 $j$ 令 $x_i\to x_i+f_{i,j}$，这样我们维护 $x$ 的区间和就可以回答询问（计算 $r_1$ 时的区间和减去 $l_1-1$ 时的区间和）了。

我们有 $O(n\log n)$ 次区间加与 $q$ 次区间求和，可以使用分块维护，时间复杂度 $O(n\log n+q\sqrt n)$。

```cpp
#include <bits/stdc++.h>
#define rep(i,n) for(int i=0,del##i##verme=int(n);i<del##i##verme;++i)
#define rep1(i,n) for(int i=1,parano##i##a=int(n);i<=parano##i##a;++i)
#define pb push_back
typedef long long ll;
typedef unsigned long long ull;
using namespace std;
const int N=100000;
const int B=318;
struct segtree{
	ull s[N/B+15];
	ull t[N/B+15];
	ull f[N+15];
	int bl[N+15];
	int bg[N/B+15],ed[N/B+15];
	int c;
	void init()
	{
		bl[0]=0;
		rep1(i,N)
		{
			bl[i]=(i-1)/B+1;
			if(bl[i-1]!=bl[i]) bg[bl[i]]=i;
			ed[bl[i]]=i;
			f[i]=0;
		}
		c=bl[N];
		rep1(i,c) s[i]=t[i]=0;
	}
	void add(int r,ull v)
	{
		s[bl[r]-1]+=v;
		f[r]+=v;t[bl[r]]+=ull(r-bg[bl[r]]+1)*v;
	}
	ull query(int r)
	{
		ull result=0;ll cur=0;
		for(int i=c;i>bl[r];--i)
		{
			cur+=s[i];
			result+=cur*ull(ed[i]-bg[i]+1)+t[i];
		}
		cur+=s[bl[r]];
		for(int i=ed[bl[r]];i>=r;--i)
		{
			result+=(cur+=f[i]);
		}
		return result;
	}
	void add(int l,int r,ull v)
	{
		add(r,v);
		if(l>1)add(l-1,-v);
	}
	ull query(int l,int r)
	{
		if(r==N) return query(l);
		return query(l)-query(r+1);
	}
};
segtree seg;
ll a[N+15];
ll c1=1,c2=1;
int t;
int x[40005],y[40005],z[40005],w[40005];
ll mx[40005],mn[40005];
vector<int> P[N+15],Q[N+15];
int p[N+15],c;
int total;
int main()
{
	ios_base::sync_with_stdio(false);
	cin.tie(0);
	cin>>t;
	rep(i,t)
	{
		cin>>x[i]>>y[i]>>z[i]>>w[i];
		Q[w[i]].pb(i);P[z[i]].pb(i);
	}
	a[0]=1145141919810;
	rep1(i,N)
	{
		c1=c1*1023%1000000000;c2=c2*1025%1000000000;
		a[i]=c1^c2; 
	}
	seg.init();p[c=0]=0;
	rep1(i,N)
	{
		for(int q:P[i]) mx[q]-=seg.query(x[q],y[q]);
		while(a[i]>=a[p[c]]) --c;
		p[++c]=i;
		rep1(j,c) seg.add(p[j-1]+1,p[j],ull(a[p[j]]));
		for(int q:Q[i]) mx[q]+=seg.query(x[q],y[q]);
	}
	a[0]=-1145141919810;p[c=0]=0;seg.init();
	rep1(i,N)
	{
		for(int q:P[i]) mn[q]-=seg.query(x[q],y[q]);
		while(a[i]<=a[p[c]]) --c;
		p[++c]=i;
		rep1(j,c) seg.add(p[j-1]+1,p[j],ull(a[p[j]]));
		for(int q:Q[i]) mn[q]+=seg.query(x[q],y[q]);
	}
	rep(i,t)
	{
		cout<<mx[i]-mn[i]<<'\n';
	}
	return 0;
}
```

---

## 作者：Purslane (赞：2)

# Solution

好像确实能 $\rm Segment \ Tree \ Beats$ 做，那样是 $O(n \log^2 n)$。

显然把式子里面的 $\min$ 和 $\max$ 拆开，单独计算。

考虑时间轴上时刻 $t$，线段树里面 $p$ 位置对应的是 $\max_{p \le i \le t} a_i$（或者是 $\min$）。

那么我们计算的是线段树区间 $[l_1,r_1]$ 在时刻 $[l_2,r_2]$ 之间的和。使用线段树历史版本和即可。

至于如何更新线段树？单调栈老套路了！

复杂度 $O(n \log n)$，常数不大。

```cpp
#include<bits/stdc++.h>
#define int long long
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=1e5+10;
int n,q,a[MAXN];
const int mod=1e9;
int fst=1023,sec=1025;
struct TAG {int add,tm,c;}tag[MAXN<<2];
struct INFO {int len,sum,hsum;}t[MAXN<<2];
INFO operator +(INFO A,INFO B) {return {A.len+B.len,A.sum+B.sum,A.hsum+B.hsum};}
TAG operator +(TAG A,TAG B) {return {A.add+B.add,A.tm+B.tm,A.c+B.c+A.add*B.tm};}
INFO operator +(INFO A,TAG B) {return {A.len,A.sum+A.len*B.add,A.hsum+B.c*A.len+A.sum*B.tm};}
#define lson (k<<1)
#define rson (k<<1|1)
#define mid (l+r>>1)
void build(int k,int l,int r) {
	t[k]={r-l+1,0,0},tag[k]={0,0,0};
	if(l!=r) build(lson,l,mid),build(rson,mid+1,r);
	return ;	
}
void push_down(int k,int l,int r) {
	t[lson]=t[lson]+tag[k],t[rson]=t[rson]+tag[k];
	tag[lson]=tag[lson]+tag[k],tag[rson]=tag[rson]+tag[k];
	return tag[k]={0,0,0},void();
}
void update(int k,int l,int r,int x,int y,TAG tg) {
	if(x<=l&&r<=y) return t[k]=t[k]+tg,tag[k]=tag[k]+tg,void();
	push_down(k,l,r);
	if(x<=mid) update(lson,l,mid,x,y,tg);
	if(y>mid) update(rson,mid+1,r,x,y,tg);
	return t[k]=t[lson]+t[rson],void();
}
int query(int k,int l,int r,int x,int y) {
	if(x>y) return 0;
	if(x<=l&&r<=y) return t[k].hsum;
	push_down(k,l,r);
	if(y<=mid) return query(lson,l,mid,x,y);
	if(x>mid) return query(rson,mid+1,r,x,y);
	return query(lson,l,mid,x,y)+query(rson,mid+1,r,x,y);	
}
vector<pair<pair<int,int>,pair<int,int>>> qr[MAXN];
int ans[MAXN];
signed main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	n=100000;
	ffor(i,1,100000) a[i]=fst^sec,fst=fst*1023%mod,sec=sec*1025%mod;
//	cin>>n;
//	ffor(i,1,n) cin>>a[i];
//	ffor(i,1,10) cout<<a[i]<<' ';
	cin>>q;
	ffor(i,1,q) {int l1,r1,l2,r2;cin>>l1>>r1>>l2>>r2,qr[r2].push_back({{l1,r1},{i,1}}),qr[l2-1].push_back({{l1,r1},{i,-1}});}
	build(1,1,n);
	stack<int> st; st.push(0);
	ffor(i,1,n) {
		update(1,1,n,i,i,{a[i],0,0});
		while(a[i]>a[st.top()]&&st.top()) {
			int u=st.top(); st.pop();
			update(1,1,n,st.top()+1,u,{a[i]-a[u],0,0});
		}
		st.push(i);
		update(1,1,n,1,n,{0,1,0});
		for(auto pr:qr[i]) ans[pr.second.first]+=pr.second.second*query(1,1,n,pr.first.first,pr.first.second);
	}
	build(1,1,n);
	while(!st.empty()) st.pop();
	st.push(0);
	ffor(i,1,n) {
		update(1,1,n,i,i,{a[i],0,0});
		while(a[i]<a[st.top()]&&st.top()) {
			int u=st.top(); st.pop();
			update(1,1,n,st.top()+1,u,{a[i]-a[u],0,0});
		}
		st.push(i);
		update(1,1,n,1,n,{0,1,0});
		for(auto pr:qr[i]) ans[pr.second.first]-=pr.second.second*query(1,1,n,pr.first.first,pr.first.second);
	}
	
	ffor(i,1,q) cout<<ans[i]<<'\n';
	return 0;
}
```

---

## 作者：Genius_Star (赞：1)

**不依赖数据随机。**

### 思路：

容易转化为差分问题，现在我们要求：

$$\sum_{l = l_1}^{r_1} \sum_{r = 1}^{r'} W(l, r)$$

考虑离线，单调栈维护更新 $W$ 的贡献，经典 trick。

现在我们需要支持区间加，区间历史和查询，多维护一个历史加法标记和即可。

时间复杂度为 $O((N + Q) \log N)$。

### 完整代码：

```cpp
 #include<bits/stdc++.h>
#define ls(k) k << 1
#define rs(k) k << 1 | 1
#define fi first
#define se second
#define open(s1, s2) freopen(s1, "r", stdin), freopen(s2, "w", stdout);
using namespace std;
typedef __int128 __;
typedef long double lb;
typedef double db;
typedef unsigned long long ull;
typedef long long ll;
bool Begin;
const int N = 1e5 + 10;
const int mod = 1e9;
inline ll read(){
    ll x = 0, f = 1;
    char c = getchar();
    while(c < '0' || c > '9'){
        if(c == '-')
          f = -1;
        c = getchar();
    }
    while(c >= '0' && c <= '9'){
        x = (x << 1) + (x << 3) + (c ^ 48);
        c = getchar();
    }
    return x * f;
}
inline void write(ll x){
	if(x < 0){
		putchar('-');
		x = -x;
	}
	if(x > 9)
	  write(x / 10);
	putchar(x % 10 + '0');
}
struct Node{
	int l, r, len;
	ll sum, ans;
	ll add, addh;
	int tim;
}X[N << 2];
int n, q, top, l1, r1, l2, r2, fst = 1023, sec = 1025;
int a[N], T[N];
ll ans[N];
vector<pair<pair<int, int>, int>> E[N];
vector<pair<pair<int, int>, pair<int, int>>> Q[N];
inline void pushup(int k){
	X[k].sum = X[k << 1].sum + X[k << 1 | 1].sum;
	X[k].ans = X[k << 1].ans + X[k << 1 | 1].ans;
}
inline void add(int k, ll v){
	X[k].sum += v * X[k].len;
	X[k].add += v;
}
inline void addh(int k, int tim, ll v){
	X[k].tim += tim;
	X[k].ans += X[k].sum * tim + v * X[k].len;
	X[k].addh += X[k].add * tim + v;
}
inline void push_down(int k){
	addh(k << 1, X[k].tim, X[k].addh);
	addh(k << 1 | 1, X[k].tim, X[k].addh);
	add(k << 1, X[k].add);
	add(k << 1 | 1, X[k].add);
	X[k].tim = X[k].addh = X[k].add = 0;
}
inline void build(int k, int l, int r){
	X[k].len = r - l + 1;
	X[k].l = l, X[k].r = r;
	if(l == r)
	  return ;
	int mid = (l + r) >> 1;
	build(k << 1, l, mid);
	build(k << 1 | 1, mid + 1, r);
}
inline void update(int k, int l, int r, int v){
	if(X[k].l == l && r == X[k].r){
		add(k, v);
		return ;
	}
	push_down(k);
	int mid = (X[k].l + X[k].r) >> 1;
	if(r <= mid)
	  update(k << 1, l, r, v);
	else if(l > mid)
	  update(k << 1 | 1, l, r, v);
	else{
		update(k << 1, l, mid, v);
		update(k << 1 | 1, mid + 1, r, v);
	}
	pushup(k);
}
inline ll ask(int k, int l, int r){
	if(X[k].l == l && r == X[k].r)
	  return X[k].ans;
	push_down(k);
	int mid = (X[k].l + X[k].r) >> 1;
	if(r <= mid)
	  return ask(k << 1, l, r);
	else if(l > mid)
	  return ask(k << 1 | 1, l, r);
	else
	  return ask(k << 1, l, mid) + ask(k << 1 | 1, mid + 1, r);
}
bool End;
int main(){
	q = read();
	for(int i = 1; i <= q; ++i){
		l1 = read(), r1 = read(), l2 = read(), r2 = read();
		Q[r2].push_back({{l1, r1}, {i, 1}});
		Q[l2 - 1].push_back({{l1, r1}, {i, -1}});
		n = max({n, r1, r2}); 
	}
	for(int i = 1; i <= n; ++i){
		a[i] = fst ^ sec;
		fst = 1ll * fst * 1023 % mod;
		sec = 1ll * sec * 1025 % mod;
	}
	a[n + 1] = 2e9, top = 0;;
	for(int i = 1; i <= n + 1; ++i){
		while(top && a[T[top]] < a[i]){
			int l = T[top], r = i - 1;
			E[l].push_back({{T[top - 1] + 1, T[top]}, a[T[top]]});
			E[r + 1].push_back({{T[top - 1] + 1, T[top]}, -a[T[top]]});
			--top;
		}
		T[++top] = i;
	}
	a[n + 1] = 0, top = 0;
	for(int i = 1; i <= n + 1; ++i){
		while(top && a[T[top]] > a[i]){
			int l = T[top], r = i - 1;
			E[l].push_back({{T[top - 1] + 1, T[top]}, -a[T[top]]});
			E[r + 1].push_back({{T[top - 1] + 1, T[top]}, a[T[top]]});
			--top;
		}
		T[++top] = i;
	}
	build(1, 1, n);
	for(int i = 1; i <= n; ++i){
		for(auto t : E[i])
		  update(1, t.fi.fi, t.fi.se, t.se);
		addh(1, 1, 0);
		for(auto t : Q[i])
		  ans[t.se.fi] += t.se.se * ask(1, t.fi.fi, t.fi.se);
	}
	for(int i = 1; i <= q; ++i){
		write(ans[i]);
		putchar('\n');
	}
	cerr << '\n' << abs(&Begin - &End) / 1048576 << "MB";
	return 0;
}
```

---

## 作者：DengDuck (赞：1)

这题显然有随机数据的性质，但是我是野人，所以我们把它丢到垃圾桶里去。

来点原教旨主义历史和线段树。

考虑原题这个查询肯定可以拆成四个这样形式的查询：

$$
\sum_{i=1}^L\sum_{j=1}^R  \max_{x\in [L,R]} A_x -\min_{x\in [L,R]} A_x 
$$

考虑把询问挂在所有的 $R$ 上然后扫描线，利用单调栈+历史和线段树维护每个位置到当前的 $R$ 的最大值减去最小值的值。

这样查询 $[1,L]$ 这个区间就行了。

顺便简单说说历史和线段树，历史和线段树其实本质上就是维护了一个“时间过去了多久”的懒标记和一个区间加懒标记的历史和，来维护历史和就行。

时间复杂度显然为 $\mathcal O(n\log n)$。

```cpp
#include<bits/stdc++.h>
#define LL long long
#define pLL pair<LL,LL>
#define pb push_back
using namespace std;
int T,n;
const int N=1e5+5;
const int mod = 1e9;
LL A[N],fst = 1023, sec = 1025,Ans[N];
struct Query{LL x,t,Id;};
vector<Query>Qr[N];
inline void Add(int L,int R,int t,int Id){Qr[R].pb({L,t,Id});}
struct Line{LL L,R,x;};
struct Tree{LL S,A,TH,TC,T;}t[N<<2];
#define Ls(x) (x<<1)
#define Rs(x) (x<<1|1)
#define Mid (L+R>>1)
inline void Push(int u,int L,int R,LL x,LL H,LL C)
{
	t[u].A+=C*t[u].S+H*(R-L+1);
	t[u].S+=x*(R-L+1);
	t[u].TH+=H+t[u].T*C;
	t[u].T+=x,t[u].TC+=C;
}
inline void Down(int u,int L,int R)
{
	if(t[u].T||t[u].TH||t[u].TC)
	{
		Push(Ls(u),L,Mid,t[u].T,t[u].TH,t[u].TC);
		Push(Rs(u),Mid+1,R,t[u].T,t[u].TH,t[u].TC);
		t[u].T=t[u].TH=t[u].TC=0;		
	}
}
inline void Up(int u)
{
	t[u].A=t[Ls(u)].A+t[Rs(u)].A;
	t[u].S=t[Ls(u)].S+t[Rs(u)].S;
}
void Upd(int u,int L,int R,int l,int r,LL x)
{
	if(R<l||r<L)return;
	if(l<=L&&R<=r)
	{
		Push(u,L,R,x,0,0);
		return;
	}
	Down(u,L,R);
	Upd(Ls(u),L,Mid,l,r,x),Upd(Rs(u),Mid+1,R,l,r,x);
	Up(u);
}
LL Qry(int u,int L,int R,int l,int r)
{
	if(R<l||r<L)return 0;
	if(l<=L&&R<=r)return t[u].A;	
	Down(u,L,R);
	return Qry(Ls(u),L,Mid,l,r)+Qry(Rs(u),Mid+1,R,l,r);
}
#define All 1,1,n
vector<Line>St1,St2;
int main()
{
	n=100000;
	for(int i=1;i<=n;i++) 
	{
		A[i] = fst ^ sec;
		fst = fst * 1023 % mod;
		sec = sec * 1025 % mod;
	}	
	scanf("%d",&T);
	for(int i=1,l1,l2,r1,r2;i<=T;i++)
	{
		scanf("%d%d%d%d",&l1,&r1,&l2,&r2);
		Add(l1-1,l2-1,1,i);
		Add(l1-1,r2,-1,i);
		Add(r1,l2-1,-1,i);
		Add(r1,r2,1,i);
	}
	
	for(int i=1;i<=n;i++)
	{
		LL L=i;
	
		while(!St1.empty()&&St1.back().x<A[i])
		{
			Upd(All,St1.back().L,St1.back().R,-St1.back().x);
			L=St1.back().L;
			St1.pop_back();
		}
		Upd(All,L,i,A[i]);
		St1.pb({L,i,A[i]});
		L=i;
		while(!St2.empty()&&St2.back().x>A[i])
		{
			Upd(All,St2.back().L,St2.back().R,St2.back().x);
			L=St2.back().L;
			St2.pop_back();
		}
		Upd(All,L,i,-A[i]);
		St2.pb({L,i,A[i]});
		Push(All,0,0,1);
		for(Query j:Qr[i])
		{
			Ans[j.Id]+=j.t*Qry(All,1,j.x);
		}
	}
	for(int i=1;i<=T;i++)
	{
		printf("%lld\n",Ans[i]);
	}
}
```

---


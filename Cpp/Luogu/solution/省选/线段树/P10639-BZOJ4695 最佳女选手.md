# BZOJ4695 最佳女选手

## 题目描述

给定一个长度为 $n$ 的序列，要求支持以下 $6$ 种操作：
- 给一个区间 $[l,r]$ 加上一个整数 $x$；
- 把一个区间 $[l,r]$ 内小于 $x$ 的数都变成 $x$；
- 把一个区间 $[l,r]$ 内大于 $x$ 的数都变成 $x$；
- 求区间 $[l,r]$ 的和；
- 求区间 $[l,r]$ 的最大值；
- 求区间 $[l,r]$ 的最小值；

## 说明/提示

数据保证，$1\leq n,m\leq 5\times 10^5$，$|a_i|\leq 10^8$。

当进行 $1$ 操作时，$|x| \leq 1000$；

当进行 $2$ 操作时，$|x| \leq 10^8$。

## 样例 #1

### 输入

```
2
1 2
2
2 1 2 2
4 1 2```

### 输出

```
4```

# 题解

## 作者：ran_qwq (赞：19)

势能分析线段树模板题。

我们发现操作不是整个区间赋值为 $x$，而是对于小于/大于 $x$ 的数赋值为 $x$。常规的标记下传行不通，考虑“暴力”一点的做法：

线段树维护区间和 $sm$，区间最大值 $mx$，区间最小值 $mn$，区间次大值 $mxs$，区间次小值 $mns$。这里的次大次小都是严格的。

对于 $2$ 操作（取 max）的某个区间：

如果 $mn\ge k$，则操作到这里没有任何意义，直接 return。

如果 $mn<k<mns$，则下传懒标记后 return。更新 $sm$ 时要记录区间最大值个数 $mxc$ 和区间最小值个数 $mnc$，直接打懒标记。否则暴力递归。

$3$ 操作同理，把最小最大和符号反转一下即可。

合并信息时分讨一下；下传懒标记时要更新该区间的其他信息；注意下传懒标记的顺序。

---
这里着重讲一下时间复杂度证明。

定义势能为所有“最大值小于父节点最大值”的区间在线段树上的深度和。最小值类似，这里只分析最大值。

对于区间加：

如图，会对红色区间进行操作，顺带改变黄色区间的最大值。

![](https://cdn.luogu.com.cn/upload/image_hosting/i09glm1d.png)

而可能通过这次操作成为“最大值小于父节点最大值”的区间是如图的绿色区间。

![](https://cdn.luogu.com.cn/upload/image_hosting/awhd0nj5.png)

这些绿色区间可以是操作区间（红色区间）的兄弟区间，每次的个数是 $\log n$ 级别的。所以每次区间加新增势能最多 $\log^2n$。

对于取最小值，若对一个父区间，只递归左子区间，则只能使左子区间最大值越来越接近父区间最大值，不会对势能产生正贡献。

定义一个区间的权值为该区间内 $\le x$ 的数。由此显然得出，取最小值过程必然将原区间划分为若干个权值为 $1$ 的小区间，然后不能划分，打懒标记。

最末端划分的区间必然满足以下性质：父区间次大值 $\ge x$，两个子区间次大值均 $<x$。所以父亲的最、次大值分别是两子区间的最大值。

且操作前父亲的次大值对应的子区间有势能，另一个子区间无势能。操作后父亲及两个子区间最大值均为 $x$，对势能有深度的负贡献。

即均摊下来，每访问一个区间就对势能有 $-1$ 的贡献。

需要注意的是取最大值的过程是对 min 的势能有负贡献，所以 min 的势能同理。

综上所述，min 和 max 的势能在任意时刻均是 $n\log^2n$ 级别，所以取最小值和取最大值操作的访问区间次数也是 $n\log^2n$ 级别。

即总时间复杂度 $O(n\log^2n)$。

证明参考了[这篇题解](https://blog.51cto.com/u_15064643/4123186)，代码参考了 OI-wiki。

```cpp
#include<bits/stdc++.h>
#define il inline
#define ui unsigned int
#define ll long long
#define ull unsigned ll
#define lll __int128
#define db double
#define ldb long double
#define pii pair<int,int>
#define vi vector<int>
#define vpii vector<pii>
#define fir first
#define sec second
#define gc getchar
#define pc putchar
#define mst(a,x) memset(a,x,sizeof a)
#define pb push_back
#define lb lower_bound
#define ub upper_bound
#define pct __builtin_popcount
using namespace std;
const int N=5e5+10,INF=0x3f3f3f3f,MOD=1e9+7;
const ll INFll=0x3f3f3f3f3f3f3f3f;
il int rd() {int x=0,f=1; char ch=gc(); while(ch<'0'||ch>'9') {if(ch=='-') f=-1; ch=gc();} while(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=gc(); return x*f;}
il ll rdll() {ll x=0; int f=1; char ch=gc(); while(ch<'0'||ch>'9') {if(ch=='-') f=-1; ch=gc();} while(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=gc(); return x*f;}
il void wr(int x) {if(x<-2147483647) {printf("-2147483648"); return;} if(x<0) {pc('-'),wr(-x); return;} if(x<10) {pc(x+'0'); return;} wr(x/10),pc(x%10+'0');}
il void wrll(ll x) {if(x<-9223372036854775807) return (void)printf("-9223372036854775808"); if(x<0) return pc('-'),wrll(-x); if(x<10) return (void)pc(x+'0'); wrll(x/10),pc(x%10+'0');}
il void wr(int x,char *s) {wr(x),printf("%s",s);}
il void wrll(ll x,char *s) {wrll(x),printf("%s",s);}
il int vmod(int x) {return x>=MOD?x-MOD:x;}
il int vadd(int x,int y) {return vmod(x+y);}
il int vsub(int x,int y) {return vmod(x-y+MOD);}
il int vmul(int x,int y) {return 1ll*x*y%MOD;}
int n,m,a[N];
struct SGT {
	#define ls (id<<1)
	#define rs (id<<1|1)
	#define mid (l+r>>1)
	#define smt(id) tr[id].smt
	#define mx(id) tr[id].mx
	#define mxc(id) tr[id].mxc
	#define mxs(id) tr[id].mxs
	#define mxt(id) tr[id].mxt
	#define mn(id) tr[id].mn
	#define mnc(id) tr[id].mnc
	#define mns(id) tr[id].mns
	#define mnt(id) tr[id].mnt
	#define sm(id) tr[id].sm
	struct nd {int smt,mx,mxc,mxs,mxt,mn,mnc,mns,mnt; ll sm;} tr[N<<2];
	void pu(int id) {
		sm(id)=sm(ls)+sm(rs);
		if(mx(ls)>mx(rs)) mx(id)=mx(ls),mxc(id)=mxc(ls),mxs(id)=max(mxs(ls),mx(rs));
		else if(mx(ls)<mx(rs)) mx(id)=mx(rs),mxc(id)=mxc(rs),mxs(id)=max(mx(ls),mxs(rs));
		else mx(id)=mx(ls),mxc(id)=mxc(ls)+mxc(rs),mxs(id)=max(mxs(ls),mxs(rs));
		if(mn(ls)<mn(rs)) mn(id)=mn(ls),mnc(id)=mnc(ls),mns(id)=min(mns(ls),mn(rs));
		else if(mn(ls)>mn(rs)) mn(id)=mn(rs),mnc(id)=mnc(rs),mns(id)=min(mn(ls),mns(rs));
		else mn(id)=mn(ls),mnc(id)=mnc(ls)+mnc(rs),mns(id)=min(mns(ls),mns(rs));
	}
	void ad(int &x,int k) {x!=INF&&x!=-INF&&(x+=k);}
	void apd(int id,int len,int k) {sm(id)+=1ll*len*k,ad(mx(id),k),ad(mxs(id),k),ad(mxt(id),k),ad(mn(id),k),ad(mns(id),k),ad(mnt(id),k),ad(smt(id),k);}
	void mxpd(int id,int k) {
		if(mn(id)>k) return; sm(id)+=1ll*(k-mn(id))*mnc(id),mxt(id)=k;
		if(mn(id)==mx(id)) mx(id)=k; if(mn(id)==mxs(id)) mxs(id)=k; mnt(id)=max(mnt(id),k),mn(id)=k;
	}
	void mnpd(int id,int k) {
		if(mx(id)<k) return; sm(id)+=1ll*(k-mx(id))*mxc(id),mnt(id)=k;
		if(mx(id)==mn(id)) mn(id)=k; if(mx(id)==mns(id)) mns(id)=k; mxt(id)=min(mxt(id),k),mx(id)=k;
	}
	void pd(int id,int l,int r) {
		if(smt(id)) apd(ls,mid-l+1,smt(id)),apd(rs,r-mid,smt(id)); if(mxt(id)!=-INF) mxpd(ls,mxt(id)),mxpd(rs,mxt(id)); if(mnt(id)!=INF) mnpd(ls,mnt(id)),mnpd(rs,mnt(id));
		smt(id)=0,mxt(id)=-INF,mnt(id)=INF;
	}
	void bld(int id,int l,int r) {
		if(l==r) return tr[id]={0,a[l],1,-INF,-INF,a[l],1,INF,INF,a[l]},void();
		bld(ls,l,mid),bld(rs,mid+1,r),pu(id),mxt(id)=-INF,mnt(id)=INF;
	}
	void aupd(int id,int l,int r,int L,int R,int k) {
		if(L<=l&&r<=R) return apd(id,r-l+1,k);
		pd(id,l,r),L<=mid?aupd(ls,l,mid,L,R,k):void(),R>mid?aupd(rs,mid+1,r,L,R,k):void(),pu(id);
	}
	void mxupd(int id,int l,int r,int L,int R,int k) {
		if(mn(id)>=k) return; if(L<=l&&r<=R&&mns(id)>k) return mxpd(id,k); if(l==r) return;
		pd(id,l,r),L<=mid?mxupd(ls,l,mid,L,R,k):void(),R>mid?mxupd(rs,mid+1,r,L,R,k):void(),pu(id);
	}
	void mnupd(int id,int l,int r,int L,int R,int k) {
		if(mx(id)<=k) return; if(L<=l&&r<=R&&mxs(id)<k) return mnpd(id,k); if(l==r) return;
		pd(id,l,r),L<=mid?mnupd(ls,l,mid,L,R,k):void(),R>mid?mnupd(rs,mid+1,r,L,R,k):void(),pu(id);
	}
	ll sqry(int id,int l,int r,int L,int R) {
		if(L<=l&&r<=R) return sm(id);
		pd(id,l,r); return (L<=mid?sqry(ls,l,mid,L,R):0)+(R>mid?sqry(rs,mid+1,r,L,R):0);
	}
	int mxqry(int id,int l,int r,int L,int R) {
		if(L<=l&&r<=R) return mx(id);
		pd(id,l,r); return max(L<=mid?mxqry(ls,l,mid,L,R):-INF,R>mid?mxqry(rs,mid+1,r,L,R):-INF);
	}
	int mnqry(int id,int l,int r,int L,int R) {
		if(L<=l&&r<=R) return mn(id);
		pd(id,l,r); return min(L<=mid?mnqry(ls,l,mid,L,R):INF,R>mid?mnqry(rs,mid+1,r,L,R):INF);
	}
}T;
void QwQ() {
	n=rd(); for(int i=1;i<=n;i++) a[i]=rd(); m=rd(),T.bld(1,1,n);
	for(int op,l,r;m--;) {
		op=rd(),l=rd(),r=rd();
		if(op==1) T.aupd(1,1,n,l,r,rd()); else if(op==2) T.mxupd(1,1,n,l,r,rd()); else if(op==3) T.mnupd(1,1,n,l,r,rd());
		else if(op==4) wrll(T.sqry(1,1,n,l,r),"\n"); else if(op==5) wr(T.mxqry(1,1,n,l,r),"\n"); else wr(T.mnqry(1,1,n,l,r),"\n");
	}
}
signed main() {
	int T=1; while(T--) QwQ();
}
```

---

## 作者：xiao7_Mr_10_ (赞：16)

好的如你所见，这道题一共有六种合情合理的操作其中有四个操作非常常见，想必不用多说，但是剩下两个就不太常见了。

需要维护这两个操作怎么整？~~直接分块~~。

当然我们对于这一类问题有专门的算法：吉司机线段树。

具体的洛谷好像目前有五道相关的题目，可以去做一下，这道题就是其中之一。

不会的移步到[这里](https://oi-wiki.org/ds/seg-beats/)。

对于吉司机线段树我们通常维护最值和严格次最值以及最值个数，这道题最大值和最小值都要维护。

具体的，维护最大值、最小值、最大值出现个数、最小值出现个数、严格次大值、严格次小值等，然后再维护三个标记辅助修改。加法标记的优先级最高，剩下两种标记优先级可以认为是相同的。

然后注意一个很重要的问题，这样你可能交一发只有七十分。

至于为什么会这样呢，如果一个区间里只有两个完全不同的数那么最大值同时也是严格次小值，而全都是一个数就会导致最大值等于最小值。所以对于这种情况我们要特殊考虑，在修改某一个值的时候同时考虑修改相同的其他值，这是一个坑点。

所以我们需要特判一下这种情况，无论是下传最大标记或者最小标记。

具体实现细节很多，直接讲十分干涩，不如结合注释看看到底是个怎么个事。

```cpp
#include <bits/stdc++.h>
using namespace std;
//啊！救命！有变态 
#define int long long
const int N=5e5+5,inf=1e18;
int n,a[N];
struct tree{
	int mx,mx2,mn,mn2,cmx,cmn,tmx,tmn,tag,sum;//最大值，严次大，最小值，严次小，最大值个数，最小值个数，最小值tag,最大值tag,加法tag,区间和 
}c[N<<2];
void updata(int x){
	c[x].sum=c[x<<1].sum+c[x<<1|1].sum;//这个简简单单好吧 
	if(c[x<<1].mx==c[x<<1|1].mx){
		c[x].mx=c[x<<1].mx,c[x].cmx=c[x<<1].cmx+c[x<<1|1].cmx;//个数拼在一起 
		c[x].mx2=max(c[x<<1].mx2,c[x<<1|1].mx2);
	}//最大值相等 
	else if(c[x<<1].mx>c[x<<1|1].mx){
		c[x].mx=c[x<<1].mx,c[x].cmx=c[x<<1].cmx;
		c[x].mx2=max(c[x<<1].mx2,c[x<<1|1].mx);
	}//左儿子大 
	else{
		c[x].mx=c[x<<1|1].mx,c[x].cmx=c[x<<1|1].cmx;
		c[x].mx2=max(c[x<<1].mx,c[x<<1|1].mx2);
	}//右儿子打
	//下面同理，但是维护的是最小值 
	if(c[x<<1].mn==c[x<<1|1].mn){
		c[x].mn=c[x<<1].mn,c[x].cmn=c[x<<1].cmn+c[x<<1|1].cmn;
		c[x].mn2=min(c[x<<1].mn2,c[x<<1|1].mn2);
	}
	else if(c[x<<1].mn<c[x<<1|1].mn){
		c[x].mn=c[x<<1].mn,c[x].cmn=c[x<<1].cmn;
		c[x].mn2=min(c[x<<1].mn2,c[x<<1|1].mn);
	}
	else{
		c[x].mn=c[x<<1|1].mn,c[x].cmn=c[x<<1|1].cmn;
		c[x].mn2=min(c[x<<1].mn,c[x<<1|1].mn2);
	}
}//分类讨论 
void build(int x,int l,int r){
	c[x].tmn=inf,c[x].tmx=-inf;//初始最值tag 
	if(l==r){
		c[x].sum=c[x].mx=c[x].mn=a[l];
		c[x].mx2=-inf,c[x].mn2=inf;
		c[x].cmx=c[x].cmn=1;
		return;
	}
	int mid=(l+r)>>1;
	build(x<<1,l,mid);
	build(x<<1|1,mid+1,r);
	updata(x);
}//建树 
void pushsum(int x,int l,int r,int val){
	c[x].sum+=(r-l+1ll)*val;
	c[x].mx+=val,c[x].mn+=val;
	if(c[x].mx2!=-inf)c[x].mx2+=val;//必须考虑次值/标记是否有的情况! 
	if(c[x].mn2!=inf)c[x].mn2+=val;
	if(c[x].tmx!=-inf)c[x].tmx+=val;
	if(c[x].tmn!=inf)c[x].tmn+=val;
	c[x].tag+=val;
}//下传和
void pushmin(int x,int val){
	if(c[x].mx<=val)return;//注意如果都小了没必要下传 
	c[x].sum+=(val-c[x].mx)*c[x].cmx;
	if(c[x].mn2==c[x].mx)c[x].mn2=val;//更新次/最小,很重要 
	if(c[x].mn==c[x].mx)c[x].mn=val;
	c[x].tmx=min(c[x].tmx,val),c[x].mx=val,c[x].tmn=val;
}//下传最小 
void pushmax(int x,int val){
	if(c[x].mn>val)return;
	c[x].sum+=(val-c[x].mn)*c[x].cmn;
	if(c[x].mx2==c[x].mn)c[x].mx2=val;//更新次/最大 ,很重要 
	if(c[x].mx==c[x].mn)c[x].mx=val;
	c[x].tmn=max(c[x].tmn,val),c[x].mn=val,c[x].tmx=val;
}//下传最大 
void pushdown(int x,int l,int r){
	int mid=(l+r)>>1;
	if(c[x].tag){
		pushsum(x<<1,l,mid,c[x].tag);
		pushsum(x<<1|1,mid+1,r,c[x].tag);
	}//最高优先级
	//剩下两个谁先谁后没必要 
	if(c[x].tmx!=-inf){
		pushmax(x<<1,c[x].tmx);
		pushmax(x<<1|1,c[x].tmx);
	}
	if(c[x].tmn!=inf){
		pushmin(x<<1,c[x].tmn);
		pushmin(x<<1|1,c[x].tmn);
	}
	c[x].tag=0,c[x].tmx=-inf,c[x].tmn=inf;
}//<--总体下传 
//修改 
void changesum(int x,int l,int r,int s,int t,int k){
	if(l>=s&&r<=t){
		pushsum(x,l,r,k);
		return;
	}
	pushdown(x,l,r);
	int mid=(l+r)>>1;
	if(s<=mid)changesum(x<<1,l,mid,s,t,k);
	if(t>mid)changesum(x<<1|1,mid+1,r,s,t,k);
	updata(x);
}
void changemin(int x,int l,int r,int s,int t,int k){
	if(c[x].mx<=k)return;
	if(l>=s&&r<=t&&c[x].mx2<k){
		pushmin(x,k);
		return;
	}
	pushdown(x,l,r);
	int mid=(l+r)>>1;
	if(s<=mid)changemin(x<<1,l,mid,s,t,k);
	if(t>mid)changemin(x<<1|1,mid+1,r,s,t,k);
	updata(x);
}
void changemax(int x,int l,int r,int s,int t,int k){
	if(c[x].mn>=k)return;
	if(l>=s&&r<=t&&c[x].mn2>k){
		pushmax(x,k);
		return;
	}
	pushdown(x,l,r);
	int mid=(l+r)>>1;
	if(s<=mid)changemax(x<<1,l,mid,s,t,k);
	if(t>mid)changemax(x<<1|1,mid+1,r,s,t,k);
	updata(x);
}
//查答案 
int querysum(int x,int l,int r,int s,int t){
	if(l>=s&&r<=t)return c[x].sum;
	int mid=(l+r)>>1;
	pushdown(x,l,r);
	if(s>mid)return querysum(x<<1|1,mid+1,r,s,t);
	else{
		if(t<=mid)return querysum(x<<1,l,mid,s,t);
		return querysum(x<<1,l,mid,s,t)+querysum(x<<1|1,mid+1,r,s,t);
	}
}
int querymax(int x,int l,int r,int s,int t){
	if(l>=s&&r<=t)return c[x].mx;
	int mid=(l+r)>>1;
	pushdown(x,l,r);
	if(s>mid)return querymax(x<<1|1,mid+1,r,s,t);
	else{
		if(t<=mid)return querymax(x<<1,l,mid,s,t);
		return max(querymax(x<<1,l,mid,s,t),querymax(x<<1|1,mid+1,r,s,t));
	}
}
int querymin(int x,int l,int r,int s,int t){
	if(l>=s&&r<=t)return c[x].mn;
	int mid=(l+r)>>1;
	pushdown(x,l,r);
	if(s>mid)return querymin(x<<1|1,mid+1,r,s,t);
	else{
		if(t<=mid)return querymin(x<<1,l,mid,s,t);
		return min(querymin(x<<1,l,mid,s,t),querymin(x<<1|1,mid+1,r,s,t));
	}
}
int m,op,l,r,x;
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin >> n;
	for(int i = 1;i <= n;i++)cin >> a[i];
	build(1,1,n);
	cin >> m;
	for(int i = 1;i <= m;i++){
		cin >> op >> l >> r;
		if(op==1){
			cin >> x;
			changesum(1,1,n,l,r,x);
		}
		else if(op==2){
			cin >> x;
			changemax(1,1,n,l,r,x);
		}
		else if(op==3){
			cin >> x;
			changemin(1,1,n,l,r,x);
		}
		else if(op==4)cout << querysum(1,1,n,l,r) << "\n";
		else if(op==5)cout << querymax(1,1,n,l,r) << "\n";
		else cout << querymin(1,1,n,l,r) << "\n";
	}
	return 0;
}
```

---

## 作者：rui_er (赞：12)

区间最值操作基础题，但是有点码农。

依然考虑势能线段树，维护区间和 $\textrm{sum}$、最大值 $\textrm{M1}$、次大值 $\textrm{M2}$、最大值个数 $\textrm{Mcnt}$、最小值 $\textrm{m1}$、次小值 $\textrm{m2}$、最小值个数 $\textrm{mcnt}$，另外需要区间加标记 $\textrm{tags}$、区间取最大值标记 $\textrm{tagM}$、区间取最小值标记 $\textrm{tagm}$。约定当区间只包含一个元素时，有 $\textrm{M2}=-\infty,\textrm{m2}=+\infty$，且初始情况下 $\textrm{tagM}=-\infty,\textrm{tagm}=+\infty$。

鉴于需要维护这么多信息和操作，本题的一个难点在于下传标记时的顺序需要正确实现。我的势能线段树的标记优先级为：区间加标记最优先，两种区间最值标记优先级相同。

在下传标记时，我们先下传区间加标记，同时对应地修改区间最值标记，再使用修改后的区间最值标记进行下传即可。由于势能线段树只会在仅有最大值/最小值发生变化时下传标记，因此这一部分容易实现。

可以证明时间复杂度为 $O(n\log^2n)$。

```cpp
// Problem: P10639 BZOJ4695 最佳女选手
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P10639
// Memory Limit: 512 MB
// Time Limit: 2000 ms
// 
// Powered by CP Editor (https://cpeditor.org)

//By: OIer rui_er
#include <bits/stdc++.h>
#define rep(x, y, z) for(ll x = (y); x <= (z); ++x)
#define per(x, y, z) for(ll x = (y); x >= (z); --x)
#define debug(format...) fprintf(stderr, format)
#define fileIO(s) do {freopen(s".in", "r", stdin); freopen(s".out", "w", stdout);} while(false)
#define endl '\n'
using namespace std;
typedef long long ll;

mt19937 rnd(std::chrono::duration_cast<std::chrono::nanoseconds>(std::chrono::system_clock::now().time_since_epoch()).count());
int randint(int L, int R) {
    uniform_int_distribution<int> dist(L, R);
    return dist(rnd);
}

template<typename T> void chkmin(T& x, T y) {if(x > y) x = y;}
template<typename T> void chkmax(T& x, T y) {if(x < y) x = y;}

template<int mod>
inline unsigned int down(unsigned int x) {
	return x >= mod ? x - mod : x;
}

template<int mod>
struct Modint {
	unsigned int x;
	Modint() = default;
	Modint(unsigned int x) : x(x) {}
	friend istream& operator>>(istream& in, Modint& a) {return in >> a.x;}
	friend ostream& operator<<(ostream& out, Modint a) {return out << a.x;}
	friend Modint operator+(Modint a, Modint b) {return down<mod>(a.x + b.x);}
	friend Modint operator-(Modint a, Modint b) {return down<mod>(a.x - b.x + mod);}
	friend Modint operator*(Modint a, Modint b) {return 1ULL * a.x * b.x % mod;}
	friend Modint operator/(Modint a, Modint b) {return a * ~b;}
	friend Modint operator^(Modint a, int b) {Modint ans = 1; for(; b; b >>= 1, a *= a) if(b & 1) ans *= a; return ans;}
	friend Modint operator~(Modint a) {return a ^ (mod - 2);}
	friend Modint operator-(Modint a) {return down<mod>(mod - a.x);}
	friend Modint& operator+=(Modint& a, Modint b) {return a = a + b;}
	friend Modint& operator-=(Modint& a, Modint b) {return a = a - b;}
	friend Modint& operator*=(Modint& a, Modint b) {return a = a * b;}
	friend Modint& operator/=(Modint& a, Modint b) {return a = a / b;}
	friend Modint& operator^=(Modint& a, int b) {return a = a ^ b;}
	friend Modint& operator++(Modint& a) {return a += 1;}
	friend Modint operator++(Modint& a, int) {Modint x = a; a += 1; return x;}
	friend Modint& operator--(Modint& a) {return a -= 1;}
	friend Modint operator--(Modint& a, int) {Modint x = a; a -= 1; return x;}
	friend bool operator==(Modint a, Modint b) {return a.x == b.x;}
	friend bool operator!=(Modint a, Modint b) {return !(a == b);}
};

const ll N = 5e5 + 5, inf = 0x3f3f3f3f3f3f3f3fll;

ll n, m, a[N];

struct SegTree {
    ll sum[N << 2], M1[N << 2], M2[N << 2], Mcnt[N << 2], m1[N << 2], m2[N << 2], mcnt[N << 2];
    ll tagM[N << 2], tagm[N << 2], tags[N << 2];
    #define lc(u) (u << 1)
    #define rc(u) (u << 1 | 1)
    void pushup(ll u) {
        sum[u] = sum[lc(u)] + sum[rc(u)];
        M1[u] = max(M1[lc(u)], M1[rc(u)]);
        M2[u] = -inf;
        if(M1[lc(u)] < M1[u]) chkmax(M2[u], M1[lc(u)]);
        if(M2[lc(u)] < M1[u]) chkmax(M2[u], M2[lc(u)]);
        if(M1[rc(u)] < M1[u]) chkmax(M2[u], M1[rc(u)]);
        if(M2[rc(u)] < M1[u]) chkmax(M2[u], M2[rc(u)]);
        Mcnt[u] = 0;;
        if(M1[lc(u)] == M1[u]) Mcnt[u] += Mcnt[lc(u)];
        if(M1[rc(u)] == M1[u]) Mcnt[u] += Mcnt[rc(u)];
        m1[u] = min(m1[lc(u)], m1[rc(u)]);
        m2[u] = +inf;
        if(m1[lc(u)] > m1[u]) chkmin(m2[u], m1[lc(u)]);
        if(m2[lc(u)] > m1[u]) chkmin(m2[u], m2[lc(u)]);
        if(m1[rc(u)] > m1[u]) chkmin(m2[u], m1[rc(u)]);
        if(m2[rc(u)] > m1[u]) chkmin(m2[u], m2[rc(u)]);
        mcnt[u] = 0;;
        if(m1[lc(u)] == m1[u]) mcnt[u] += mcnt[lc(u)];
        if(m1[rc(u)] == m1[u]) mcnt[u] += mcnt[rc(u)];
    }
    void pushs(ll u, ll l, ll r, ll tag) {
        sum[u] += tag * (r - l + 1);
        if(M1[u] != -inf) M1[u] += tag;
        if(M2[u] != -inf) M2[u] += tag;
        if(m1[u] != +inf) m1[u] += tag;
        if(m2[u] != +inf) m2[u] += tag;
        tags[u] += tag;
        if(tagM[u] != -inf) tagM[u] += tag;
        if(tagm[u] != +inf) tagm[u] += tag;
    }
    void pushM(ll u, ll l, ll r, ll tag) {
        if(m1[u] > tag) return;
        sum[u] += (tag - m1[u]) * mcnt[u];
        if(M2[u] == m1[u]) M2[u] = tag;
        if(M1[u] == m1[u]) M1[u] = tag;
        m1[u] = tag;
        chkmax(tagM[u], tag);
        chkmax(tagm[u], tag);
    }
    void pushm(ll u, ll l, ll r, ll tag) {
        if(M1[u] < tag) return;
        sum[u] += (tag - M1[u]) * Mcnt[u];
        if(m2[u] == M1[u]) m2[u] = tag;
        if(m1[u] == M1[u]) m1[u] = tag;
        M1[u] = tag;
        chkmin(tagM[u], tag);
        chkmin(tagm[u], tag);
    }
    void pushdown(ll u, ll l, ll r) {
        ll mid = (l + r) >> 1;
        if(tags[u]) {
            pushs(lc(u), l, mid, tags[u]);
            pushs(rc(u), mid + 1, r, tags[u]);
            tags[u] = 0;
        }
        if(tagM[u] != -inf) {
            pushM(lc(u), l, mid, tagM[u]);
            pushM(rc(u), mid + 1, r, tagM[u]);
            tagM[u] = -inf;
        }
        if(tagm[u] != +inf) {
            pushm(lc(u), l, mid, tagm[u]);
            pushm(rc(u), mid + 1, r, tagm[u]);
            tagm[u] = +inf;
        }
    }
    void build(ll u, ll l, ll r) {
        tags[u] = 0;
        tagM[u] = -inf;
        tagm[u] = +inf;
        if(l == r) {
            sum[u] = M1[u] = m1[u] = a[l];
            M2[u] = -inf;
            m2[u] = +inf;
            Mcnt[u] = mcnt[u] = 1;
            return;
        }
        ll mid = (l + r) >> 1;
        build(lc(u), l, mid);
        build(rc(u), mid + 1, r);
        pushup(u);
    }
    void modifys(ll u, ll l, ll r, ll ql, ll qr, ll k) {
        if(ql <= l && r <= qr) {
            pushs(u, l, r, k);
            return;
        }
        pushdown(u, l, r);
        ll mid = (l + r) >> 1;
        if(ql <= mid) modifys(lc(u), l, mid, ql, qr, k);
        if(qr > mid) modifys(rc(u), mid + 1, r, ql, qr, k);
        pushup(u);
    }
    void modifyM(ll u, ll l, ll r, ll ql, ll qr, ll k) {
        if(m1[u] >= k) return;
        if(ql <= l && r <= qr && m2[u] > k) {
            pushM(u, l, r, k);
            return;
        }
        pushdown(u, l, r);
        ll mid = (l + r) >> 1;
        if(ql <= mid) modifyM(lc(u), l, mid, ql, qr, k);
        if(qr > mid) modifyM(rc(u), mid + 1, r, ql, qr, k);
        pushup(u);
    }
    void modifym(ll u, ll l, ll r, ll ql, ll qr, ll k) {
        if(M1[u] <= k) return;
        if(ql <= l && r <= qr && M2[u] < k) {
            pushm(u, l, r, k);
            return;
        }
        pushdown(u, l, r);
        ll mid = (l + r) >> 1;
        if(ql <= mid) modifym(lc(u), l, mid, ql, qr, k);
        if(qr > mid) modifym(rc(u), mid + 1, r, ql, qr, k);
        pushup(u);
    }
    ll querys(ll u, ll l, ll r, ll ql, ll qr) {
        if(ql <= l && r <= qr) return sum[u];
        pushdown(u, l, r);
        ll mid = (l + r) >> 1, ans = 0;
        if(ql <= mid) ans += querys(lc(u), l, mid, ql, qr);
        if(qr > mid) ans += querys(rc(u), mid + 1, r, ql, qr);
        pushup(u);
        return ans;
    }
    ll queryM(ll u, ll l, ll r, ll ql, ll qr) {
        if(ql <= l && r <= qr) return M1[u];
        pushdown(u, l, r);
        ll mid = (l + r) >> 1, ans = -inf;
        if(ql <= mid) chkmax(ans, queryM(lc(u), l, mid, ql, qr));
        if(qr > mid) chkmax(ans, queryM(rc(u), mid + 1, r, ql, qr));
        pushup(u);
        return ans;
    }
    ll querym(ll u, ll l, ll r, ll ql, ll qr) {
        if(ql <= l && r <= qr) return m1[u];
        pushdown(u, l, r);
        ll mid = (l + r) >> 1, ans = +inf;
        if(ql <= mid) chkmin(ans, querym(lc(u), l, mid, ql, qr));
        if(qr > mid) chkmin(ans, querym(rc(u), mid + 1, r, ql, qr));
        pushup(u);
        return ans;
    }
    #undef lc
    #undef rc
}sgt;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0); cout.tie(0);
    cin >> n;
    rep(i, 1, n) cin >> a[i];
    sgt.build(1, 1, n);
    for(cin >> m; m; --m) {
        ll op;
        cin >> op;
        if(op == 1) {
            ll l, r, x;
            cin >> l >> r >> x;
            sgt.modifys(1, 1, n, l, r, x);
        }
        else if(op == 2) {
            ll l, r, x;
            cin >> l >> r >> x;
            sgt.modifyM(1, 1, n, l, r, x);
        }
        else if(op == 3) {
            ll l, r, x;
            cin >> l >> r >> x;
            sgt.modifym(1, 1, n, l, r, x);
        }
        else if(op == 4) {
            ll l, r;
            cin >> l >> r;
            cout << sgt.querys(1, 1, n, l, r) << endl;
        }
        else if(op == 5) {
            ll l, r;
            cin >> l >> r;
            cout << sgt.queryM(1, 1, n, l, r) << endl;
        }
        else {
            ll l, r;
            cin >> l >> r;
            cout << sgt.querym(1, 1, n, l, r) << endl;
        }
    }
    return 0;
}
```

---

## 作者：wjr_jok (赞：6)

和普通分块一样的套路，操作 $1$ 和询问都是很常见的，考虑怎么实现操作 $2,3$ 的同时保证询问的正确性。

发现操作 $2,3$ 分别是底部推平和顶部推平，模拟一下可以发现会有很多区间被直接铺平，可以当作一个点来处理，用一个 $tp$ 数组记录是否可以铺平即可，这样就可以节省很多时间，然后还要用到第二分块的做法：区间最大值小于推平操作底部或区间最小值大于推平操作顶部就直接铺平，反之如果最小值大于底部或最大值小于顶部就可以不操作。

由于打的是分块，所以每次修改散块时会影响到它所在的整块，需要把 $ans,max,min$ 全部重新计算，并且对于整块要保证尽量不暴力修改，所以码量巨大，无缺省源 $7.3KB$，屎山勿喷。

## Code

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=5e5+1;
int n,q,opt,l,r,s; 
int xl[N];
int x[N],y[N],fk[N],ans[N],maxx[N],minn[N],xg[N];
double tp[N];
signed main(){
	cin>>n;
	int cnt=sqrt(n);
	for(int i=1;i<=cnt;i++){
		x[i]=y[i-1]+1;
		y[i]=x[i]+cnt-1;
	}
	if(y[cnt]<n){
		cnt++;
		x[cnt]=y[cnt-1]+1;
		y[cnt]=n;
	}
	for(int i=1;i<=n;i++){
		cin>>xl[i];
	}
	for(int i=1;i<=n;i++){
		tp[i]=0.1,maxx[i]=-LLONG_MAX,minn[i]=LLONG_MAX;
		for(int j=x[i];j<=y[i];j++){
			fk[j]=i;
			ans[i]+=xl[j];
			maxx[i]=max(maxx[i],xl[j]);
			minn[i]=min(minn[i],xl[j]);
		}
	}
	cin>>q;
	for(int i=1;i<=q;i++){
		cin>>opt>>l>>r;
		if(opt==1){
			cin>>s;
			if(tp[fk[l]]!=0.1){
				for(int j=x[fk[l]];j<=y[fk[l]];j++){
					xl[j]=tp[fk[l]];
				}
				tp[fk[l]]=0.1;
			}
			if(xg[fk[l]]){
				for(int j=x[fk[l]];j<=y[fk[l]];j++){
					xl[j]+=xg[fk[l]];
				}
				xg[fk[l]]=0;
			}
			for(int j=l;j<=min(r,y[fk[l]]);j++){
				xl[j]+=s;
				ans[fk[l]]+=s;
			}
			maxx[fk[l]]=-LLONG_MAX,minn[fk[l]]=LLONG_MAX;
			for(int j=x[fk[l]];j<=y[fk[l]];j++){
				maxx[fk[l]]=max(maxx[fk[l]],xl[j]);
				minn[fk[l]]=min(minn[fk[l]],xl[j]);
			}
			if(maxx[fk[l]]==minn[fk[l]]){
				tp[fk[l]]=maxx[fk[l]];
			}
			if(fk[l]!=fk[r]){
				if(tp[fk[r]]!=0.1){
					for(int j=x[fk[r]];j<=y[fk[r]];j++){
						xl[j]=tp[fk[r]];
					}
					tp[fk[r]]=0.1;
				}
				if(xg[fk[r]]){
					for(int j=x[fk[r]];j<=y[fk[r]];j++){
						xl[j]+=xg[fk[r]];
					}
					xg[fk[r]]=0;
				}
				for(int j=x[fk[r]];j<=r;j++){
					xl[j]+=s;
					ans[fk[r]]+=s;
				}
				maxx[fk[r]]=-LLONG_MAX,minn[fk[r]]=LLONG_MAX;
				for(int j=x[fk[r]];j<=y[fk[r]];j++){
					maxx[fk[r]]=max(maxx[fk[r]],xl[j]);
					minn[fk[r]]=min(minn[fk[r]],xl[j]);
				}
				if(maxx[fk[r]]==minn[fk[r]]){
					tp[fk[r]]=maxx[fk[r]];
				}
			}
			for(int j=fk[l]+1;j<fk[r];j++){
				maxx[j]+=s;
				minn[j]+=s;
				ans[j]+=(y[j]-x[j]+1)*s;
				if(tp[j]!=0.1){
					tp[j]+=s;
				}
				else{
					xg[j]+=s;
				}
			}
		}
		if(opt==2){
			cin>>s;
			if(tp[fk[l]]!=0.1){
				for(int j=x[fk[l]];j<=y[fk[l]];j++){
					xl[j]=tp[fk[l]];
				}
				tp[fk[l]]=0.1;
			}
			if(xg[fk[l]]){
				for(int j=x[fk[l]];j<=y[fk[l]];j++){
					xl[j]+=xg[fk[l]];
				}
				xg[fk[l]]=0;
			}
			for(int j=l;j<=min(r,y[fk[l]]);j++){
				ans[fk[l]]-=xl[j];
				xl[j]=max(xl[j],s);
				ans[fk[l]]+=xl[j];
			}
			maxx[fk[l]]=-LLONG_MAX,minn[fk[l]]=LLONG_MAX;
			for(int j=x[fk[l]];j<=y[fk[l]];j++){
				maxx[fk[l]]=max(maxx[fk[l]],xl[j]);
				minn[fk[l]]=min(minn[fk[l]],xl[j]);
			}
			if(maxx[fk[l]]==minn[fk[l]]){
				tp[fk[l]]=maxx[fk[l]];
			}
			if(fk[l]!=fk[r]){
				if(tp[fk[r]]!=0.1){
					for(int j=x[fk[r]];j<=y[fk[r]];j++){
						xl[j]=tp[fk[r]];
					}
					tp[fk[r]]=0.1;
				}
				if(xg[fk[r]]){
					for(int j=x[fk[r]];j<=y[fk[r]];j++){
						xl[j]+=xg[fk[r]];
					}
					xg[fk[r]]=0;
				}
				for(int j=x[fk[r]];j<=r;j++){
					ans[fk[r]]-=xl[j];
					xl[j]=max(xl[j],s);
					ans[fk[r]]+=xl[j];
				}
				maxx[fk[r]]=-LLONG_MAX,minn[fk[r]]=LLONG_MAX;
				for(int j=x[fk[r]];j<=y[fk[r]];j++){
					maxx[fk[r]]=max(maxx[fk[r]],xl[j]);
					minn[fk[r]]=min(minn[fk[r]],xl[j]);
				}
				if(maxx[fk[r]]==minn[fk[r]]){
					tp[fk[r]]=maxx[fk[r]];
				}
			}
			for(int j=fk[l]+1;j<fk[r];j++){
				if(tp[j]!=0.1){
					tp[j]=maxx[j]=minn[j]=max(tp[j],(double)s);
					ans[j]=(y[j]-x[j]+1)*tp[j];
				}
				else if(maxx[j]<=s){
					tp[j]=maxx[j]=minn[j]=s;
					xg[j]=0;
					ans[j]=(y[j]-x[j]+1)*s;
				}
				else if(minn[j]<s){
					if(xg[j]){
						for(int k=x[j];k<=y[j];k++){
							xl[k]+=xg[j];
						}
						xg[j]=0;
					}
					maxx[j]=-LLONG_MAX,minn[j]=LLONG_MAX;
					for(int k=x[j];k<=y[j];k++){
						ans[j]-=xl[k];
						xl[k]=max(xl[k],s);
						minn[j]=min(minn[j],xl[k]);
						maxx[j]=max(maxx[j],xl[k]);
						ans[j]+=xl[k];
					}
					if(maxx[j]==minn[j]){
						tp[j]=maxx[j];
					}
				}
			}
		}
		if(opt==3){
			cin>>s;
			if(tp[fk[l]]!=0.1){
				for(int j=x[fk[l]];j<=y[fk[l]];j++){
					xl[j]=tp[fk[l]];
				}
				tp[fk[l]]=0.1;
			}
			if(xg[fk[l]]){
				for(int j=x[fk[l]];j<=y[fk[l]];j++){
					xl[j]+=xg[fk[l]];
				}
				xg[fk[l]]=0;
			}
			for(int j=l;j<=min(r,y[fk[l]]);j++){
				ans[fk[l]]-=xl[j];
				xl[j]=min(xl[j],s);
				ans[fk[l]]+=xl[j];
			}
			maxx[fk[l]]=-LLONG_MAX,minn[fk[l]]=LLONG_MAX;
			for(int j=x[fk[l]];j<=y[fk[l]];j++){
				maxx[fk[l]]=max(maxx[fk[l]],xl[j]);
				minn[fk[l]]=min(minn[fk[l]],xl[j]);
			}
			if(maxx[fk[l]]==minn[fk[l]]){
				tp[fk[l]]=maxx[fk[l]];
			}
			if(fk[l]!=fk[r]){
				if(tp[fk[r]]!=0.1){
					for(int j=x[fk[r]];j<=y[fk[r]];j++){
						xl[j]=tp[fk[r]];
					}
					tp[fk[r]]=0.1;
				}
				if(xg[fk[r]]){
					for(int j=x[fk[r]];j<=y[fk[r]];j++){
						xl[j]+=xg[fk[r]];
					}
					xg[fk[r]]=0;
				}
				for(int j=x[fk[r]];j<=r;j++){
					ans[fk[r]]-=xl[j];
					xl[j]=min(xl[j],s);
					ans[fk[r]]+=xl[j];
				}
				maxx[fk[r]]=-LLONG_MAX,minn[fk[r]]=LLONG_MAX;
				for(int j=x[fk[r]];j<=y[fk[r]];j++){
					maxx[fk[r]]=max(maxx[fk[r]],xl[j]);
					minn[fk[r]]=min(minn[fk[r]],xl[j]);
				}
				if(maxx[fk[r]]==minn[fk[r]]){
					tp[fk[r]]=maxx[fk[r]];
				}
			}
			for(int j=fk[l]+1;j<fk[r];j++){
				if(tp[j]!=0.1){
					tp[j]=maxx[j]=minn[j]=min(tp[j],(double)s);
					ans[j]=(y[j]-x[j]+1)*tp[j];
				}
				else if(minn[j]>=s){
					maxx[j]=minn[j]=s;
					tp[j]=s;
					xg[j]=0;
					ans[j]=(y[j]-x[j]+1)*s;
				}
				else if(maxx[j]>s){
					if(xg[j]){
						for(int k=x[j];k<=y[j];k++){
							xl[k]+=xg[j];
						}
						xg[j]=0;
					}
					maxx[j]=-LLONG_MAX,minn[j]=LLONG_MAX;
					for(int k=x[j];k<=y[j];k++){
						ans[j]-=xl[k];
						xl[k]=min(xl[k],s);
						maxx[j]=max(maxx[j],xl[k]);
						minn[j]=min(minn[j],xl[k]);
						ans[j]+=xl[k];
					}
					if(maxx[j]==minn[j]){
						tp[j]=maxx[j];
					}
				}
			}
		}
		if(opt==4){
			int cnt=0;
			for(int j=l;j<=min(r,y[fk[l]]);j++){
				if(tp[fk[l]]!=0.1){
					cnt+=tp[fk[l]];
				}
				else{
					cnt+=xl[j]+xg[fk[l]];
				}
			}
			if(fk[l]!=fk[r]){
				for(int j=x[fk[r]];j<=r;j++){
					if(tp[fk[r]]!=0.1){
						cnt+=tp[fk[r]];
					}
					else{
						cnt+=xl[j]+xg[fk[r]];
					}
				}
			}
			for(int j=fk[l]+1;j<fk[r];j++){
				cnt+=ans[j];
			}
			cout<<cnt<<endl;
		}
		if(opt==5){
			int cnt=-LLONG_MAX;
			for(int j=l;j<=min(r,y[fk[l]]);j++){
				if(tp[fk[l]]!=0.1){
					cnt=max(cnt,(int)tp[fk[l]]);
				}
				else{
					cnt=max(cnt,xl[j]+xg[fk[l]]);
				}
			}
			if(fk[l]!=fk[r]){
				for(int j=x[fk[r]];j<=r;j++){
					if(tp[fk[r]]!=0.1){
						cnt=max(cnt,(int)tp[fk[r]]);
					}
					else{
						cnt=max(cnt,xl[j]+xg[fk[r]]);
					}
				}
			}
			for(int j=fk[l]+1;j<fk[r];j++){
				cnt=max(cnt,maxx[j]);
			}
			cout<<cnt<<endl;
		}
		if(opt==6){
			int cnt=LLONG_MAX;
			for(int j=l;j<=min(r,y[fk[l]]);j++){
				if(tp[fk[l]]!=0.1){
					cnt=min(cnt,(int)tp[fk[l]]);
				}
				else{
					cnt=min(cnt,xl[j]+xg[fk[l]]);
				}
			}
			if(fk[l]!=fk[r]){
				for(int j=x[fk[r]];j<=r;j++){
					if(tp[fk[r]]!=0.1){
						cnt=min(cnt,(int)tp[fk[r]]);
					}
					else{
						cnt=min(cnt,xl[j]+xg[fk[r]]);
					}
				}
			}
			for(int j=fk[l]+1;j<fk[r];j++){
				cnt=min(cnt,minn[j]);
			}
			cout<<cnt<<endl;
		}
	}
	return 0;
}
```

---

## 作者：Eterna (赞：4)

势能分析线段树是显然的。

但是怎么实现有难度。

对 $2,3$ 操作：

如果递归到的当前区间，操作无效就直接返回。如果完全有效就打一个覆盖标记。

其他操作在随便维护一下。

就有：


```cpp
#include<bits/stdc++.h>
#define N 500005
#define int long long
#define rd read() 
#define gc getchar()
using namespace std;
int a[N];
int m,n;
inline int read()
{
	int x=0,ss=1,s=gc;
	while(!isdigit(s)&&s!='-')s=gc;
	if(s=='-')ss*=-1,s=gc;
	while(isdigit(s))x=(x<<1)+(x<<3)+s-'0',s=gc;
	return ss*x;
}
struct linetree
{
	int lazy[N<<2]={0},sumv[N<<2]={0},maxx[N<<2]={0},minn[N<<2]={0},cover[N<<2]={0};
	bool ico[N<<2]={0};
	void pushup(int id)
	{
		sumv[id]=sumv[id<<1]+sumv[id<<1|1];
		maxx[id]=max(maxx[id<<1],maxx[id<<1|1]);
		minn[id]=min(minn[id<<1],minn[id<<1|1]);
	}
	void init(int id,int l,int r)
	{
		if(l==r)
		{
			maxx[id]=minn[id]=sumv[id]=a[l];
			return;
		}
		int mid=l+r>>1;
		init(id<<1,l,mid);
		init(id<<1|1,mid+1,r);
		pushup(id);
	}
	void pushdown(int id,int l,int r)
	{
		if(ico[id])
		{
			int mid=l+r>>1;
			minn[id<<1]=minn[id<<1|1]=maxx[id<<1]=maxx[id<<1|1]=cover[id<<1]=cover[id<<1|1]=cover[id];
			sumv[id<<1]=cover[id]*(mid-l+1);
			sumv[id<<1|1]=cover[id]*(r-mid);
			ico[id<<1]=ico[id<<1|1]=1;
		}
		if(lazy[id])
		{
			int mid=l+r>>1;
			lazy[id<<1]+=lazy[id];
			lazy[id<<1|1]+=lazy[id];
			sumv[id<<1]+=lazy[id]*(mid-l+1);
			sumv[id<<1|1]+=lazy[id]*(r-mid);
			minn[id<<1]+=lazy[id],minn[id<<1|1]+=lazy[id];
			maxx[id<<1]+=lazy[id],maxx[id<<1|1]+=lazy[id];
		}
		cover[id]=lazy[id]=ico[id]=0;
	}
	void ad(int id,int l,int r,int x,int y,int v)
	{
		if(l>=x&&r<=y&&minn[id]>=v)return;
		if(l>=x&&r<=y&&maxx[id]<v)
		{
			maxx[id]=minn[id]=cover[id]=v;
			sumv[id]=v*(r-l+1);
			ico[id]=1;
			return;
		}
		pushdown(id,l,r);
		int mid=l+r>>1;
		if(x<=mid)ad(id<<1,l,mid,x,y,v);
		if(y>mid)ad(id<<1|1,mid+1,r,x,y,v);
		pushup(id);
	}
	void add(int id,int l,int r,int x,int y,int v)
	{
		if(l>=x&&r<=y&&maxx[id]<=v)return;
		if(l>=x&&r<=y&&minn[id]>v)
		{
			maxx[id]=minn[id]=cover[id]=v;
			sumv[id]=v*(r-l+1);
			ico[id]=1;
			return;
		}
		pushdown(id,l,r);
		int mid=l+r>>1;
		if(x<=mid)add(id<<1,l,mid,x,y,v);
		if(y>mid)add(id<<1|1,mid+1,r,x,y,v);
		pushup(id);
	}
	void insert(int id,int l,int r,int x,int y,int v)
	{
		if(l>=x&&r<=y)
		{
			lazy[id]+=v;
			sumv[id]+=(r-l+1)*v;
			maxx[id]+=v,minn[id]+=v;
			return;
		}
		pushdown(id,l,r);
		int mid=l+r>>1;
		if(x<=mid)insert(id<<1,l,mid,x,y,v);
		if(y>mid)insert(id<<1|1,mid+1,r,x,y,v);
		pushup(id);
	}
	int ask(int id,int l,int r,int x,int y)
	{
		if(l>=x&&r<=y)return sumv[id];
		pushdown(id,l,r);
		int mid=l+r>>1,ans=0;
		if(x<=mid)ans+=ask(id<<1,l,mid,x,y);
		if(y>mid)ans+=ask(id<<1|1,mid+1,r,x,y);
		return ans;
	}
	int ask1(int id,int l,int r,int x,int y)
	{
		if(l>=x&&r<=y)return maxx[id];
		pushdown(id,l,r);
		int mid=l+r>>1,ans=INT_MIN;
		if(x<=mid)ans=max(ask1(id<<1,l,mid,x,y),ans);
		if(y>mid)ans=max(ask1(id<<1|1,mid+1,r,x,y),ans);
		return ans;
	}
	int ask2(int id,int l,int r,int x,int y)
	{
		if(l>=x&&r<=y)return minn[id];
		pushdown(id,l,r);
		int mid=l+r>>1,ans=INT_MAX;
		if(x<=mid)ans=min(ask2(id<<1,l,mid,x,y),ans);
		if(y>mid)ans=min(ask2(id<<1|1,mid+1,r,x,y),ans);
		return ans;
	}
}tree;
signed main()
{
	n=rd;
	for(int i=1;i<=n;i++)a[i]=rd;
	m=rd;
	tree.init(1,1,n); 
	while(m--)
	{
		int x=rd,l=rd,r=rd;
		if(x==1)
		{
			int k=rd;
			tree.insert(1,1,n,l,r,k);
		}
		if(x==2)
		{
			int k=rd;
			tree.ad(1,1,n,l,r,k);
		}
		if(x==3)
		{
			int k=rd;
			tree.add(1,1,n,l,r,k);
		}
		if(x==4)
		{
			cout<<tree.ask(1,1,n,l,r)<<'\n';
		}
		if(x==5)
		{
			cout<<tree.ask1(1,1,n,l,r)<<'\n';
		}
		if(x==6)
		{
			cout<<tree.ask2(1,1,n,l,r)<<'\n';
		}
	}
	return 0;
}
```

跑得飞快，但是 wa 了一部分。

其实以上的势能是有问题的，考虑的并不周全。

以上是我踩的坑。

###  正确的做法

线段树维护区间和，区间最大值，区间最小值，严格区间次大值，严格区间次小值，区间最大值个数，区间最小值个数，~~常数竟然不炸~~。

标记：区间加标记，最小值增量，最大值增量。

操作 $3$：

当 $x$ 大于最大值，直接退出。

当 $x$ 在最大值和次大值之间，打标记，然后直接退出。

否则继续递归。

操作 $2$ 同理。

`pushup` 和 `pushdown` 非常长。

####  pushup

区间最大值，区间最小值，区间和的维护没有区别。

其他的分类讨论一下。看代码很好理解。


```cpp
void pushup(int id)
	{
		int l=id<<1,r=id<<1|1;
		sumv[id]=sumv[l]+sumv[r];//区间和
		if(maxx[l]==maxx[r])//最大值，次大值，最大值计数
		{
			maxx[id]=maxx[l];
			maxcnt[id]=maxcnt[l]+maxcnt[r];
			cd[id]=max(cd[l],cd[r]);
		}
		else if(maxx[l]>maxx[r])
		{
			maxx[id]=maxx[l];
			maxcnt[id]=maxcnt[l];
			cd[id]=max(cd[l],maxx[r]);
		}
		else
		{
			maxx[id]=maxx[r];
			maxcnt[id]=maxcnt[r];
			cd[id]=max(maxx[l],cd[r]);
		}
		if(minn[l]==minn[r])//同理
		{
			minn[id]=minn[l];
			mincnt[id]=mincnt[l]+mincnt[r];
			cx[id]=min(cx[l],cx[r]);
		}
		else if(minn[l]<minn[r])
		{
			minn[id]=minn[l];
			mincnt[id]=mincnt[l];
			cx[id]=min(cx[l],minn[r]);
		}
		else
		{
			minn[id]=minn[r];
			mincnt[id]=mincnt[r];
			cx[id]=min(minn[l],cx[r]);
		}
	}
```
####  pushdown

只需要注意操作 $1$ 的优先级是最高的，所以最先下传。很多人 70 分就是因为这个没有特判区间里只有两个不同的数的情况（次大值等于最小值，最大值等于次小值）。

代码封装一下更短。


```cpp
void pushadd(int id,int l,int r,int x)//操作1下传 
	{
		lazy[id]+=x;minn[id]+=x,maxx[id]+=x;
		sumv[id]+=x*(r-l+1);
		if(cd[id]!=-INT_MAX)cd[id]+=x;
		if(cx[id]!=INT_MAX)cx[id]+=x;
		if(tag1[id]!=-INT_MAX)tag1[id]+=x;
		if(tag2[id]!=INT_MAX)tag2[id]+=x;
	}
	void pushmax(int id,int x)//操作2下传
	{
		if(minn[id]>=x)return;
		sumv[id]+=(x-minn[id])*mincnt[id];
		if(minn[id]==maxx[id])maxx[id]=x;
		if(minn[id]==cd[id])cd[id]=x;
		if(tag2[id]<x)tag2[id]=x;
		minn[id]=x,tag1[id]=x;
	}
	void pushmin(int id,int x)//操作3下传
	{
		if(maxx[id]<=x)return;
		sumv[id]+=(x-maxx[id])*maxcnt[id];
		if(maxx[id]==minn[id])minn[id]=x;
		if(maxx[id]==cx[id])cx[id]=x;
		if(tag1[id]>x)tag1[id]=x;
		maxx[id]=x,tag2[id]=x;
	}
	void pushdown(int id,int l,int r)
	{
		if(lazy[id])
		{
			int mid=l+r>>1;
			pushadd(id<<1,l,mid,lazy[id]);
			pushadd(id<<1|1,mid+1,r,lazy[id]);
			lazy[id]=0;
		}
		if(tag1[id]!=-INT_MAX)
		{
			pushmax(id<<1,tag1[id]);
			pushmax(id<<1|1,tag1[id]);
			tag1[id]=-INT_MAX;
		}
		if(tag2[id]!=INT_MAX)
		{
			pushmin(id<<1,tag2[id]);
			pushmin(id<<1|1,tag2[id]);
			tag2[id]=INT_MAX;
		} 
	}
```

其他的比较好写，操作 $2,3$ 注意一下势能的判断。

操作 $2$：


```cpp
if(minn[id]>=v)return;
if(l>=x&&r<=y&&cx[id]>v)
{
  pushmax(id,v);
  return;
}
```

操作 $3$：


```cpp
if(maxx[id]<=v)return;
if(l>=x&&r<=y&&cd[id]<v)
{
  pushmin(id,v);
  return;
}
```
最后给一个完整代码。


```cpp
#include<bits/stdc++.h>
#define N 500005
#define int long long
#define rd read() 
#define gc getchar()
using namespace std;
int a[N];
int m,n;
inline int read()
{
	int x=0,ss=1,s=gc;
	while(!isdigit(s)&&s!='-')s=gc;
	if(s=='-')ss*=-1,s=gc;
	while(isdigit(s))x=(x<<1)+(x<<3)+s-'0',s=gc;
	return ss*x;
}
struct linetree
{
	int lazy[N<<2]={0},sumv[N<<2],maxx[N<<2],minn[N<<2],cd[N<<2],cx[N<<2],maxcnt[N<<2],mincnt[N<<2];
	int tag1[N<<2],tag2[N<<2];
	void pushup(int id)
	{
		int l=id<<1,r=id<<1|1;
		sumv[id]=sumv[l]+sumv[r];
		if(maxx[l]==maxx[r])
		{
			maxx[id]=maxx[l];
			maxcnt[id]=maxcnt[l]+maxcnt[r];
			cd[id]=max(cd[l],cd[r]);
		}
		else if(maxx[l]>maxx[r])
		{
			maxx[id]=maxx[l];
			maxcnt[id]=maxcnt[l];
			cd[id]=max(cd[l],maxx[r]);
		}
		else
		{
			maxx[id]=maxx[r];
			maxcnt[id]=maxcnt[r];
			cd[id]=max(maxx[l],cd[r]);
		}
		if(minn[l]==minn[r])
		{
			minn[id]=minn[l];
			mincnt[id]=mincnt[l]+mincnt[r];
			cx[id]=min(cx[l],cx[r]);
		}
		else if(minn[l]<minn[r])
		{
			minn[id]=minn[l];
			mincnt[id]=mincnt[l];
			cx[id]=min(cx[l],minn[r]);
		}
		else
		{
			minn[id]=minn[r];
			mincnt[id]=mincnt[r];
			cx[id]=min(minn[l],cx[r]);
		}
	}
	void init(int id,int l,int r)
	{
		tag1[id]=-INT_MAX,tag2[id]=INT_MAX;
		if(l==r)
		{
			maxx[id]=minn[id]=sumv[id]=a[l];
			cd[id]=-INT_MAX,cx[id]=INT_MAX;
			maxcnt[id]=mincnt[id]=1;
			return;
		}
		int mid=l+r>>1;
		init(id<<1,l,mid);
		init(id<<1|1,mid+1,r);
		pushup(id);
	}
	void pushadd(int id,int l,int r,int x)
	{
		lazy[id]+=x;minn[id]+=x,maxx[id]+=x;
		sumv[id]+=x*(r-l+1);
		if(cd[id]!=-INT_MAX)cd[id]+=x;
		if(cx[id]!=INT_MAX)cx[id]+=x;
		if(tag1[id]!=-INT_MAX)tag1[id]+=x;
		if(tag2[id]!=INT_MAX)tag2[id]+=x;
	}
	void pushmax(int id,int x)
	{
		if(minn[id]>=x)return;
		sumv[id]+=(x-minn[id])*mincnt[id];
		if(minn[id]==maxx[id])maxx[id]=x;
		if(minn[id]==cd[id])cd[id]=x;
		if(tag2[id]<x)tag2[id]=x;
		minn[id]=x,tag1[id]=x;
	}
	void pushmin(int id,int x)
	{
		if(maxx[id]<=x)return;
		sumv[id]+=(x-maxx[id])*maxcnt[id];
		if(maxx[id]==minn[id])minn[id]=x;
		if(maxx[id]==cx[id])cx[id]=x;
		if(tag1[id]>x)tag1[id]=x;
		maxx[id]=x,tag2[id]=x;
	}
	void pushdown(int id,int l,int r)
	{
		if(lazy[id])
		{
			int mid=l+r>>1;
			pushadd(id<<1,l,mid,lazy[id]);
			pushadd(id<<1|1,mid+1,r,lazy[id]);
			lazy[id]=0;
		}
		if(tag1[id]!=-INT_MAX)
		{
			pushmax(id<<1,tag1[id]);
			pushmax(id<<1|1,tag1[id]);
			tag1[id]=-INT_MAX;
		}
		if(tag2[id]!=INT_MAX)
		{
			pushmin(id<<1,tag2[id]);
			pushmin(id<<1|1,tag2[id]);
			tag2[id]=INT_MAX;
		} 
	}
	void ad(int id,int l,int r,int x,int y,int v)
	{
		if(minn[id]>=v)return;
		if(l>=x&&r<=y&&cx[id]>v)
		{
			pushmax(id,v);
			return;
		}
		pushdown(id,l,r);
		int mid=l+r>>1;
		if(x<=mid)ad(id<<1,l,mid,x,y,v);
		if(y>mid)ad(id<<1|1,mid+1,r,x,y,v);
		pushup(id);
	}
	void add(int id,int l,int r,int x,int y,int v)
	{
		if(maxx[id]<=v)return;
		if(l>=x&&r<=y&&cd[id]<v)
		{
			pushmin(id,v);
			return;
		}
		pushdown(id,l,r);
		int mid=l+r>>1;
		if(x<=mid)add(id<<1,l,mid,x,y,v);
		if(y>mid)add(id<<1|1,mid+1,r,x,y,v);
		pushup(id);
	}
	void insert(int id,int l,int r,int x,int y,int v)
	{
		if(l>=x&&r<=y)
		{
			pushadd(id,l,r,v);
			return;
		}
		pushdown(id,l,r);
		int mid=l+r>>1;
		if(x<=mid)insert(id<<1,l,mid,x,y,v);
		if(y>mid)insert(id<<1|1,mid+1,r,x,y,v);
		pushup(id);
	}
	int ask(int id,int l,int r,int x,int y)
	{
		if(l>=x&&r<=y)return sumv[id];
		pushdown(id,l,r);
		int mid=l+r>>1,ans=0;
		if(x<=mid)ans+=ask(id<<1,l,mid,x,y);
		if(y>mid)ans+=ask(id<<1|1,mid+1,r,x,y);
		return ans;
	}
	int ask1(int id,int l,int r,int x,int y)
	{
		if(l>=x&&r<=y)return maxx[id];
		pushdown(id,l,r);
		int mid=l+r>>1,ans=INT_MIN;
		if(x<=mid)ans=max(ask1(id<<1,l,mid,x,y),ans);
		if(y>mid)ans=max(ask1(id<<1|1,mid+1,r,x,y),ans);
		return ans;
	}
	int ask2(int id,int l,int r,int x,int y)
	{
		if(l>=x&&r<=y)return minn[id];
		pushdown(id,l,r);
		int mid=l+r>>1,ans=INT_MAX;
		if(x<=mid)ans=min(ask2(id<<1,l,mid,x,y),ans);
		if(y>mid)ans=min(ask2(id<<1|1,mid+1,r,x,y),ans);
		return ans;
	}
}tree;
signed main()
{
	n=rd;
	for(int i=1;i<=n;i++)a[i]=rd;
	m=rd;
	tree.init(1,1,n); 
	while(m--)
	{
		int x=rd,l=rd,r=rd;
		if(x==1)
		{
			int k=rd;
			tree.insert(1,1,n,l,r,k);
		}
		if(x==2)
		{
			int k=rd;
			tree.ad(1,1,n,l,r,k);
		}
		if(x==3)
		{
			int k=rd;
			tree.add(1,1,n,l,r,k);
		}
		if(x==4)cout<<tree.ask(1,1,n,l,r)<<'\n';
		if(x==5)cout<<tree.ask1(1,1,n,l,r)<<'\n';
		if(x==6)cout<<tree.ask2(1,1,n,l,r)<<'\n';
	}
	return 0;
}
```

其实一个维护区间的题出现了一些奇怪的操作时，就该想到势能线段树（有势能）和分块（无势能）。

---

## 作者：Purslane (赞：3)

# Solution

你说的对，但是我写了 $\rm 4.62 \ Kb$ 的代码。

$\rm Segment \ Tree \ beats$ 模板题。

这类题当然要在线段树节点上维护**区间最大值、次大值、最小值、次小值**，以及总和、最大值个数、最小值个数。

在懒标记部分，要记录最大值增加量、最小值增加量、中间平凡值的增加量。

但是这有一个麻烦的地方：在进行 `push_down` 的时候，父区间的最大值最小值增加量也许不能直接加到子区间上。因此下传的时候要考虑一下到底怎么加。

用势能分析法可以证明，这么做复杂度是 $O(n \log^2 n)$ 的。

把代码改改顺便可以把 [BZOJ4355](https://www.luogu.com.cn/problem/P10638) 给过了。

放一个巨大多抽象的代码（请忽略 `push_down` 部分的实现）：

```cpp
#include<bits/stdc++.h>
#define ll long long
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=5e5+10,INF=0x3f3f3f3f;
int n,q,a[MAXN];
struct INFO {
	int len;
	ll sum;
	int mx,smx,mxcnt;
	int mn,smn,mncnt;
}t[MAXN<<2];
struct TAG {
	int mxad,midad,mnad;
}tag[MAXN<<2];
INFO operator +(INFO A,TAG B) {
	if(A.mx==A.mn) return A.sum+=1ll*A.len*B.midad,A.mn+=B.midad,A.mx+=B.midad,A;
	A.sum+=1ll*A.mxcnt*B.mxad+1ll*A.mncnt*B.mnad+1ll*(A.len-A.mxcnt-A.mncnt)*B.midad;
	if(A.smx==A.mn) A.smx+=B.mnad,A.smn+=B.mxad;
	else A.smx+=B.midad,A.smn+=B.midad;
	A.mx+=B.mxad,A.mn+=B.mnad;
	return A;
}
TAG operator +(TAG A,TAG B) {
	return {A.mxad+B.mxad,A.midad+B.midad,A.mnad+B.mnad};
}
int calc_smx(int a,int b,int c,int d) {
	int mx=max(max(a,b),max(c,d)),ans=-INF;
	if(a!=mx) ans=max(ans,a);
	if(b!=mx) ans=max(ans,b);
	if(c!=mx) ans=max(ans,c);
	if(d!=mx) ans=max(ans,d);
	return ans;
}
int calc_smn(int a,int b,int c,int d) {
	int mn=min(min(a,b),min(c,d)),ans=INF;
	if(a!=mn) ans=min(ans,a);
	if(b!=mn) ans=min(ans,b);
	if(c!=mn) ans=min(ans,c);
	if(d!=mn) ans=min(ans,d);
	return ans;	
}
INFO operator +(INFO A,INFO B) {
	return {A.len+B.len,A.sum+B.sum,
	max(A.mx,B.mx),calc_smx(A.mx,B.mx,A.smx,B.smx),(A.mx>=B.mx?A.mxcnt:0)+(A.mx<=B.mx?B.mxcnt:0),
	min(A.mn,B.mn),calc_smn(A.mn,B.mn,A.smn,B.smn),(A.mn<=B.mn?A.mncnt:0)+(A.mn>=B.mn?B.mncnt:0)
	};	
}
#define lson (k<<1)
#define rson (k<<1|1)
#define mid (l+r>>1)
void push_down(int k,int l,int r) {
	int mn=min(t[lson].mn,t[rson].mn),mx=max(t[lson].mx,t[rson].mx);
	TAG lad,rad;
	if(t[lson].mn==mn) lad.mnad=tag[k].mnad;
	else if(t[lson].mn==mx) lad.mnad=tag[k].mxad;
	else lad.mnad=tag[k].midad;
	if(t[lson].mx==mn) lad.mxad=tag[k].mnad;
	else if(t[lson].mx==mx) lad.mxad=tag[k].mxad;
	else lad.mxad=tag[k].midad;
	if(lad.mxad==lad.mnad) lad.midad=lad.mxad;
	else lad.midad=tag[k].midad;
	t[lson]=t[lson]+lad,tag[lson]=tag[lson]+lad;
	if(t[rson].mn==mn) rad.mnad=tag[k].mnad;
	else if(t[rson].mn==mx) rad.mnad=tag[k].mxad;
	else rad.mnad=tag[k].midad;
	if(t[rson].mx==mn) rad.mxad=tag[k].mnad;
	else if(t[rson].mx==mx) rad.mxad=tag[k].mxad;
	else rad.mxad=tag[k].midad;
	if(rad.mxad==rad.mnad) rad.midad=rad.mxad;
	else rad.midad=tag[k].midad;
	t[rson]=t[rson]+rad,tag[rson]=tag[rson]+rad;
	return tag[k]={0,0,0},void();
}
void update(int k,int l,int r,int x,int y,int v) {
	if(x<=l&&r<=y) return t[k]=t[k]+TAG{v,v,v},tag[k]=tag[k]+TAG{v,v,v},void();
	push_down(k,l,r);
	if(x<=mid) update(lson,l,mid,x,y,v);
	if(y>mid) update(rson,mid+1,r,x,y,v);
	return t[k]=t[lson]+t[rson],void();	
}
void get_max(int k,int l,int r,int x,int y,int v) {
	if(t[k].mn>=v) return ;
	if(x<=l&&r<=y) {
		int val=v-t[k].mn;
		if(t[k].mn==t[k].mx) return t[k]=t[k]+TAG{val,val,val},tag[k]=tag[k]+TAG{val,val,val},void();
		if(t[k].smn>v) return t[k]=t[k]+TAG{0,0,val},tag[k]=tag[k]+TAG{0,0,val},void();
		push_down(k,l,r);
		return get_max(lson,l,mid,x,y,v),get_max(rson,mid+1,r,x,y,v),t[k]=t[lson]+t[rson],void();
	}
	push_down(k,l,r);
	if(x<=mid) get_max(lson,l,mid,x,y,v);
	if(y>mid) get_max(rson,mid+1,r,x,y,v);
	return t[k]=t[lson]+t[rson],void();
}
void get_min(int k,int l,int r,int x,int y,int v) {
	if(t[k].mx<=v) return ;
	if(x<=l&&r<=y) {
		int val=v-t[k].mx;
		if(t[k].mn==t[k].mx) return t[k]=t[k]+TAG{val,val,val},tag[k]=tag[k]+TAG{val,val,val},void();
		if(t[k].smx<v) return t[k]=t[k]+TAG{val,0,0},tag[k]=tag[k]+TAG{val,0,0},void();
		push_down(k,l,r);
		return get_min(lson,l,mid,x,y,v),get_min(rson,mid+1,r,x,y,v),t[k]=t[lson]+t[rson],void();
	}
	push_down(k,l,r);
	if(x<=mid) get_min(lson,l,mid,x,y,v);
	if(y>mid) get_min(rson,mid+1,r,x,y,v);
	return t[k]=t[lson]+t[rson],void();
}
INFO query(int k,int l,int r,int x,int y) {
	if(x<=l&&r<=y) return t[k];
	push_down(k,l,r);
	if(y<=mid) return query(lson,l,mid,x,y);
	if(x>mid) return query(rson,mid+1,r,x,y);
	return query(lson,l,mid,x,y)+query(rson,mid+1,r,x,y);	
}
void build(int k,int l,int r) {
	if(l==r) return t[k]={1,a[l],a[l],-INF,1,a[l],INF,1},void();
	return build(lson,l,mid),build(rson,mid+1,r),t[k]=t[lson]+t[rson],void();
}
signed main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>n;
	ffor(i,1,n) cin>>a[i];
	build(1,1,n);
	cin>>q;
	ffor(i,1,q) {
		int op,l,r,x;
		cin>>op>>l>>r;
		if(op==1) cin>>x,update(1,1,n,l,r,x);
		else if(op==2) cin>>x,get_max(1,1,n,l,r,x);
		else if(op==3) cin>>x,get_min(1,1,n,l,r,x);
		else {
			auto info=query(1,1,n,l,r);
			if(op==4) cout<<info.sum<<'\n';
			else if(op==5) cout<<info.mx<<'\n';
			else if(op==6) cout<<info.mn<<'\n';	
		}
	}
	return 0;
}
```

---

## 作者：ケロシ (赞：3)

非常好 SgT Beats 使我线段树能力提升。

前置知识：[Segment Tree Beats P6242 【模板】线段树 3（区间最值操作、区间历史最值）](https://www.luogu.com.cn/problem/P6242)。

对于最值操作，很容易想到这个 Beats 来维护，然后这个有取大取小两种最值操作，那么就能想到这个同时记录线段树节点区间的最大最小，次大次小，最大值与最小值的出现次数，然后最值基本思路就是当操作的最值在当前区间的最大和次大值之间的时候进行处理，这样只会对最大值有操作，这样就会很方便，而且时间复杂度是 $O(n \log n)$ 的。

然后肯定会维护一个 tag 表示当前节点取最值操作的值，然后在打加法 tag 的时候，如果加上 $x$，同时最值 tag 也需要加上 $x$ 来保证正确性，然后 pushdown 的时候先处理加法然后处理最值即可保证正确。

然后就是最关键的部分！就是打取最小的最值 tag 的时候可能会影响另外一边的信息，这里需要特判。一共有两种情况：一种是这个区间就一种数，还有一种就是区间只有两种数，这种情况更新最值的之后同时也需要将另一边也进行更改，这里不难。

对于有两种最值操作和加操作的 Beats，时间复杂度可证明上界为 $O(n\log^2n)$，常数可能较大，本篇题解作者加上快读即可卡过。

具体可以看代码。

```cpp
const int N = 5e5 + 5;
const int INF = 2e9 + 5;
int n, m, a[N];
int read() {
	int res = 0, v = 1;
	char c = getchar();
	while(c < '0' || c > '9') { if(c == '-') v = -1; c = getchar();}
	while('0' <= c && c <= '9') res = res * 10 + c - '0', c = getchar();
	return res * v;
}
struct SgT {
	int le[N << 2], ri[N << 2];
	ll S[N << 2]; // 区间和
	int F[N << 2][2], G[N << 2][2], C[N << 2][2]; // 最大，次大，最大出现次数，以及最小等同理
	int T[N << 2], TV[N << 2][2]; // T 为加法 tag，TV 为两种最值 tag
	inline void pushup(int u) {
		S[u] = S[u << 1] + S[u << 1 | 1];
		F[u][0] = max(F[u << 1][0], F[u << 1 | 1][0]);
		if(F[u << 1][0] > F[u << 1 | 1][0]) {
			F[u][1] = max(F[u << 1][1], F[u << 1 | 1][0]);
			C[u][0] = C[u << 1][0];
		}
		else if(F[u << 1][0] < F[u << 1 | 1][0]) {
			F[u][1] = max(F[u << 1][0], F[u << 1 | 1][1]);
			C[u][0] = C[u << 1 | 1][0];
		}
		else {
			F[u][1] = max(F[u << 1][1], F[u << 1 | 1][1]);
			C[u][0] = C[u << 1][0] + C[u << 1 | 1][0];
		}
		G[u][0] = min(G[u << 1][0], G[u << 1 | 1][0]);
		if(G[u << 1][0] < G[u << 1 | 1][0]) {
			G[u][1] = min(G[u << 1][1], G[u << 1 | 1][0]);
			C[u][1] = C[u << 1][1];
		}
		else if(G[u << 1][0] > G[u << 1 | 1][0]) {
			G[u][1] = min(G[u << 1][0], G[u << 1 | 1][1]);
			C[u][1] = C[u << 1 | 1][1];
		}
		else {
			G[u][1] = min(G[u << 1][1], G[u << 1 | 1][1]);
			C[u][1] = C[u << 1][1] + C[u << 1 | 1][1];
		}
	}
	inline void push_add(int u, int x) { // 加法 tag
		S[u] += 1ll * x * (ri[u] - le[u] + 1);
		F[u][0] += x;
		if(F[u][1] != -INF) F[u][1] += x;
		G[u][0] += x;
		if(G[u][1] != INF) G[u][1] += x;
		if(TV[u][0] != INF) TV[u][0] += x; // 这里最值 tag 也需要更改
		if(TV[u][1] != -INF) TV[u][1] += x;
		T[u] += x;
	}
	inline void push_max(int u, int x) { // 取最小最值 tag
		S[u] -= 1ll * (F[u][0] - x) * C[u][0];
		if(F[u][0] == G[u][1]) G[u][1] = x; // 只有两种数
		F[u][0] = x;
		TV[u][0] = x;
		if(F[u][1] == -INF) G[u][0] = x, TV[u][1] = -INF; // 只有一种数
	}
	inline void push_min(int u, int x) { // 同理
		S[u] += 1ll * (x - G[u][0]) * C[u][1];
		if(F[u][1] == G[u][0]) F[u][1] = x;
		G[u][0] = x;
		TV[u][1] = x;
		if(G[u][1] == INF) F[u][0] = x, TV[u][0] = INF;
	}
	inline void pushdown(int u) {
		if(T[u]) { // 先打加法 tag
			push_add(u << 1, T[u]);
			push_add(u << 1 | 1, T[u]);
			T[u] = 0;
		}
		if(TV[u][0] != INF) {
			int val = max(F[u << 1][0], F[u << 1 | 1][0]); // 需要判断往哪边下传
			if(F[u << 1][0] == val) push_max(u << 1, TV[u][0]);
			if(F[u << 1 | 1][0] == val) push_max(u << 1 | 1, TV[u][0]);
			TV[u][0] = INF;
		}
		if(TV[u][1] != -INF) {
			int val = min(G[u << 1][0], G[u << 1 | 1][0]);
			if(G[u << 1][0] == val) push_min(u << 1, TV[u][1]);
			if(G[u << 1 | 1][0] == val) push_min(u << 1 | 1, TV[u][1]);
			TV[u][1] = -INF;
		}
	}
	void build(int u, int l, int r) {
		le[u] = l, ri[u] = r;
		TV[u][0] = INF, TV[u][1] = -INF;
		if(l == r) {
			F[u][0] = G[u][0] = S[u] = a[l];
			F[u][1] = -INF, G[u][1] = INF;
			C[u][0] = C[u][1] = 1;
			return;
		}
		int mid = l + r >> 1;
		build(u << 1, l, mid);
		build(u << 1 | 1, mid + 1, r);
		pushup(u);
	}
	ll query_sum(int u, int l, int r) {
		if(l <= le[u] && ri[u] <= r) {
			return S[u];
		}
		pushdown(u);
		int mid = le[u] + ri[u] >> 1;
		if(r <= mid) return query_sum(u << 1, l, r);
		if(mid < l) return query_sum(u << 1 | 1, l, r);
		return query_sum(u << 1, l, r) + query_sum(u << 1 | 1, l, r);
	}
	int query_max(int u, int l, int r) {
		if(l <= le[u] && ri[u] <= r) {
			return F[u][0];
		}
		pushdown(u);
		int mid = le[u] + ri[u] >> 1;
		if(r <= mid) return query_max(u << 1, l, r);
		if(mid < l) return query_max(u << 1 | 1, l, r);
		return max(query_max(u << 1, l, r), query_max(u << 1 | 1, l, r));
	}
	int query_min(int u, int l, int r) {
		if(l <= le[u] && ri[u] <= r) {
			return G[u][0];
		}
		pushdown(u);
		int mid = le[u] + ri[u] >> 1;
		if(r <= mid) return query_min(u << 1, l, r);
		if(mid < l) return query_min(u << 1 | 1, l, r);
		return min(query_min(u << 1, l, r), query_min(u << 1 | 1, l, r));
	}
	void modify_add(int u, int l, int r, int x) {
		if(l <= le[u] && ri[u] <= r) {
			push_add(u, x);
			return;
		}
		pushdown(u);
		int mid = le[u] + ri[u] >> 1;
		if(l <= mid) modify_add(u << 1, l, r, x);
		if(mid < r) modify_add(u << 1 | 1, l, r, x);
		pushup(u);
	}
	void modify_max(int u, int l, int r, int x) {
		if(l <= le[u] && ri[u] <= r && F[u][0] <= x) return;
		if(l <= le[u] && ri[u] <= r && F[u][1] < x && x < F[u][0]) { // 当修改的数小于最大值大于次大值时进行处理
			push_max(u, x);
			return;
		}
		pushdown(u);
		int mid = le[u] + ri[u] >> 1;
		if(l <= mid) modify_max(u << 1, l, r, x);
		if(mid < r) modify_max(u << 1 | 1, l, r, x);
		pushup(u);
	}
	void modify_min(int u, int l, int r, int x) {
		if(l <= le[u] && ri[u] <= r && G[u][0] >= x) return;
		if(l <= le[u] && ri[u] <= r && G[u][1] > x && x > G[u][0]) {
			push_min(u, x);
			return;
		}
		pushdown(u);
		int mid = le[u] + ri[u] >> 1;
		if(l <= mid) modify_min(u << 1, l, r, x);
		if(mid < r) modify_min(u << 1 | 1, l, r, x);
		pushup(u);
	}
} t;
void solve() {
	n = read();
	FOR(i, 1, n) a[i] = read();
	t.build(1, 1, n);
	m = read();
	REP(_, m) {
		int opt;
		opt = read();
		if(opt == 1) {
			int l, r, x;
			l = read(); r = read(); x = read();
			t.modify_add(1, l, r, x);
		}
		if(opt == 2) {
			int l, r, x;
			l = read(); r = read(); x = read();
			t.modify_min(1, l, r, x);
		}
		if(opt == 3) {
			int l, r, x;
			l = read(); r = read(); x = read();
			t.modify_max(1, l, r, x);
		}
		if(opt == 4) {
			int l, r;
			l = read(); r = read();
			cout << t.query_sum(1, l, r) << endl;
		}
		if(opt == 5) {
			int l, r;
			l = read(); r = read();
			cout << t.query_max(1, l, r) << endl;
		}
		if(opt == 6) {
			int l, r;
			l = read(); r = read();
			cout << t.query_min(1, l, r) << endl;
		}
	}
}
```

---

## 作者：_IceCream_ (赞：2)

## Content

给你一个长度为 $n$ 的数列 $a$，需要你实现以下操作：

1. `1 l r x`，将 $[l, r]$ 区间内所有数加 $x$；
2. `2 l r x`，$\forall l \le i \le r, a_i \leftarrow \max(a_i, x)$；
3. `3 l r x`，$\forall l \le i \le r, a_i \leftarrow \min(a_i, x)$；
4. `4 l r`，输出 $\sum _ {i = l} ^ r a_i$。
5. `5 l r`，输出 $\max _ {i = l} ^ r a_i$。
6. `6 l r`，输出 $\min _ {i = l} ^ r a_i$。

## Solution

看到 $2, 3$ 操作一眼吉司机线段树板子题。

但是我更喜欢拿这道题当吉司机板子，因为隔壁的 [P6242 【模板】线段树 3](https://www.luogu.com.cn/problem/P6242) 多了一个区间历史最值。

先考虑取 min 的情况吧。

我们考虑记录一个严格次大值 $se$ 和区间最大值的个数 $cnt$，那么取 min 时就会有以下三种情况：

1. 当 $mx \le x$ 时，此时 $x$ 不会对区间造成任何修改，直接退出。
2. 当 $se \lt x \lt mx$ 时，此时只有区间中的最大值会被更新，那么区间和就会加上 $cnt \cdot (x - mx)$，打上标记就可以推出了。
3. 当 $se \ge x$ 时，此时我们不知道会更新多少个数，那么就直接暴力搜索子树。

这就是吉司机线段树的基本思想，可以势能分析证明它的复杂度是 $O(n \log^2 n)$ 的。

## Code

```cpp
#include <bits/stdc++.h>
#define int long long 
using namespace std;

const int N = 5e5 + 5, Inf = 1e18;
int n, m, a[N];

struct Seg {
	int mi, si, ci; // 最小，次小，最小个数
	int mx, sx, cx;
	int lazs, lazx, lazi;
	long long sum;
} tree[N << 2];

//void debug (int node) { printf ("Debug mi %lld si %lld ci %lld mx %lld sx %lld cx %lld lazs %lld lazx %lld lazi %lld sum %lld\n", tree[node].mi, tree[node].si, tree[node].ci, tree[node].mx, tree[node].sx, tree[node].cx, tree[node].lazs, tree[node].lazx, tree[node].lazi, tree[node].sum); }

void pushup (int node) {
	int ls = node << 1, rs = (node << 1) + 1;
	tree[node].sum = tree[ls].sum + tree[rs].sum;
	tree[node].mx = max (tree[ls].mx, tree[rs].mx);
	tree[node].mi = min (tree[ls].mi, tree[rs].mi);

        // 需要根据两棵子树的情况分讨，最小值也是一样的。
	if (tree[ls].mx == tree[rs].mx) {
		tree[node].sx = max (tree[ls].sx, tree[rs].sx);
		tree[node].cx = tree[ls].cx + tree[rs].cx;
	} else if (tree[ls].mx > tree[rs].mx) {
		tree[node].sx = max (tree[ls].sx, tree[rs].mx);
		tree[node].cx = tree[ls].cx;
	} else {
		tree[node].sx = max (tree[ls].mx, tree[rs].sx);
		tree[node].cx = tree[rs].cx;
	}
	
	if (tree[ls].mi == tree[rs].mi) {
		tree[node].si = min (tree[ls].si, tree[rs].si);
		tree[node].ci = tree[ls].ci + tree[rs].ci;
	} else if (tree[ls].mi < tree[rs].mi) {
		tree[node].si = min (tree[ls].si, tree[rs].mi);
		tree[node].ci = tree[ls].ci;
	} else {
		tree[node].si = min (tree[ls].mi, tree[rs].si);
		tree[node].ci = tree[rs].ci;
	}
}

void pushdown (int node, int l, int r) {
	int ls = node << 1, rs = (node << 1) + 1, mid = l + ((r - l) >> 1);
	int x;
	
	if (tree[node].lazs) {
		x = tree[node].lazs;
		tree[ls].sum += (mid - l + 1LL) * x; 
		tree[ls].mx += x; tree[ls].mi += x;
		tree[ls].lazs += x;
                // 记得特判
		if (tree[ls].sx != -Inf) tree[ls].sx += x;
		if (tree[ls].si != Inf) tree[ls].si += x;
		if (tree[ls].lazx != -Inf) tree[ls].lazx += x;
		if (tree[ls].lazi != Inf) tree[ls].lazi += x;
		
		tree[rs].sum += (r - mid) * x; 
		tree[rs].mx += x; tree[rs].mi += x;
		tree[rs].lazs += x;
		if (tree[rs].sx != -Inf) tree[rs].sx += x;
		if (tree[rs].si != Inf) tree[rs].si += x;
		if (tree[rs].lazx != -Inf) tree[rs].lazx += x;
		if (tree[rs].lazi != Inf) tree[rs].lazi += x;
		
		tree[node].lazs = 0;
	}
	
	if (tree[node].lazi != Inf) {
		x = tree[node].lazi;
		if (x < tree[ls].mx) {
			tree[ls].sum += (x - tree[ls].mx) * tree[ls].cx;
                        // 顺序不要搞错了！
			if (tree[ls].si == tree[ls].mx) tree[ls].si = x;
			if (tree[ls].mi == tree[ls].mx) tree[ls].mi = x;
			tree[ls].lazx = min (tree[ls].lazx, x);
			tree[ls].mx = tree[ls].lazi = x;
		}
		
		if (x < tree[rs].mx) {
			tree[rs].sum += (x - tree[rs].mx) * tree[rs].cx;
			if (tree[rs].si == tree[rs].mx) tree[rs].si = x;
			if (tree[rs].mi == tree[rs].mx) tree[rs].mi = x;
			tree[rs].lazx = min (tree[rs].lazx, x);
			tree[rs].mx = tree[rs].lazi = x;
		}
		
		tree[node].lazi = Inf;
	}
	
	if (tree[node].lazx != -Inf) {
		x = tree[node].lazx;
		if (x > tree[ls].mi) {
			tree[ls].sum += (x - tree[ls].mi) * tree[ls].ci;
			if (tree[ls].sx == tree[ls].mi) tree[ls].sx = x;
			if (tree[ls].mx == tree[ls].mi) tree[ls].mx = x;
			tree[ls].lazi = max (tree[ls].lazi, x);
			tree[ls].mi = tree[ls].lazx = x;
		}
		
		if (x > tree[rs].mi) {
			tree[rs].sum += (x - tree[rs].mi) * tree[rs].ci;
			if (tree[rs].sx == tree[rs].mi) tree[rs].sx = x;
			if (tree[rs].mx == tree[rs].mi) tree[rs].mx = x;
			tree[rs].lazi = max (tree[rs].lazi, x);
			tree[rs].mi = tree[rs].lazx = x;
		}
		
		tree[node].lazx = -Inf;
	}
}

void build (int node, int l, int r) {
	tree[node].lazi = Inf; 
	tree[node].lazx = -Inf;
	
	if (l == r) {
		tree[node].sum = tree[node].mi = tree[node].mx = a[l];
		tree[node].si = Inf; tree[node].sx = -Inf;
		tree[node].ci = tree[node].cx = 1;
		return ;
	}
	
	int mid = l + ((r - l) >> 1);
	build (node << 1, l, mid);
	build ((node << 1) + 1, mid + 1, r);
	pushup (node);
}

void modify_sum (int node, int l, int r, int s, int t, long long c) {
        // 跟 pushdown 一样的。
	if (s <= l && r <= t) {
		tree[node].sum += (r - l + 1) * c; 
		tree[node].mx += c; tree[node].mi += c;
		tree[node].lazs += c;
		if (tree[node].sx != -Inf) tree[node].sx += c;
		if (tree[node].si != Inf) tree[node].si += c;
		if (tree[node].lazx != -Inf) tree[node].lazx += c;
		if (tree[node].lazi != Inf) tree[node].lazi += c;
		return ;
	}
	
	pushdown (node, l, r);
	int mid = l + ((r - l) >> 1);
	if (s <= mid) modify_sum (node << 1, l, mid, s, t, c);
	if (t > mid) modify_sum ((node << 1) + 1, mid + 1, r, s, t, c);
	pushup (node);
}

void modify_min (int node, int l, int r, int s, int t, int c) {
	if (tree[node].mx <= c) return ;
	
	if (s <= l && r <= t && tree[node].sx < c) {
		tree[node].sum += (c - tree[node].mx) * tree[node].cx;
		if (tree[node].si == tree[node].mx) tree[node].si = c;
		if (tree[node].mi == tree[node].mx) tree[node].mi = c;
		tree[node].lazx = min (tree[node].lazx, c);
		tree[node].mx = tree[node].lazi = c;
		return ;
	}
	
	pushdown (node, l, r);
	int mid = l + ((r - l) >> 1);
	if (s <= mid) modify_min (node << 1, l, mid, s, t, c);
	if (t > mid) modify_min ((node << 1) + 1, mid + 1, r, s, t, c);
	pushup (node);
}

void modify_max (int node, int l, int r, int s, int t, int c) {
	if (tree[node].mi >= c) return ;
	
	if (s <= l && r <= t && tree[node].si > c) {
		tree[node].sum += (c - tree[node].mi) * tree[node].ci;
		if (tree[node].sx == tree[node].mi) tree[node].sx = c;
		if (tree[node].mx == tree[node].mi) tree[node].mx = c;
		tree[node].lazi = max (tree[node].lazi, c);
		tree[node].mi = tree[node].lazx = c;
		return ;
	}
	
	pushdown (node, l, r);
	int mid = l + ((r - l) >> 1);
	if (s <= mid) modify_max (node << 1, l, mid, s, t, c); 
	if (t > mid) modify_max ((node << 1) + 1, mid + 1, r, s, t, c);
	pushup (node);
}

long long query_sum (int node, int l, int r, int s, int t) {
	if (s <= l && r <= t) return tree[node].sum;
	
	pushdown (node, l, r);
	int mid = l + ((r - l) >> 1);
	long long ret = 0;
	if (s <= mid) ret += query_sum (node << 1, l, mid, s, t); 
	if (t > mid) ret += query_sum ((node << 1) + 1, mid + 1, r, s, t);
	return ret;
}

int query_min (int node, int l, int r, int s, int t) {
	if (s <= l && r <= t) return tree[node].mi;
	
	pushdown (node, l, r);
	int mid = l + ((r - l) >> 1), ret = Inf;
	if (s <= mid) ret = min (ret, query_min (node << 1, l, mid, s, t));
	if (t > mid) ret = min (ret, query_min ((node << 1) + 1, mid + 1, r, s, t));
	return ret;
}

int query_max (int node, int l, int r, int s, int t) {
	if (s <= l && r <= t) return tree[node].mx;
	
	pushdown (node, l, r);
	int mid = l + ((r - l) >> 1), ret = -Inf;
	if (s <= mid) ret = max (ret, query_max (node << 1, l, mid, s, t));
	if (t > mid) ret = max (ret, query_max ((node << 1) + 1, mid + 1, r, s, t));
	return ret; 
}

signed main () {
	
//	freopen ("1.in", "r", stdin);
//	freopen ("2.out", "w", stdout);
	
	scanf ("%lld", &n);
	for (int i = 1; i <= n; ++i) scanf ("%lld", &a[i]);
	
	build (1, 1, n);
	
	scanf ("%lld", &m);
	while (m--) {
		int opt, l, r;
		scanf ("%lld%lld%lld", &opt, &l, &r);
		
		if (opt == 1) {
			long long x;
			scanf ("%lld", &x);
			modify_sum (1, 1, n, l, r, x);
		} else if (opt == 2) {
			int x;
			scanf ("%lld", &x);
			modify_max (1, 1, n, l, r, x);
		} else if (opt == 3) {
			int x;
			scanf ("%lld", &x);
			modify_min (1, 1, n, l, r, x);
		} else if (opt == 4) printf ("%lld\n", query_sum (1, 1, n, l, r));
		else if (opt == 5) printf ("%lld\n", query_max (1, 1, n, l, r));
		else printf ("%lld\n", query_min (1, 1, n, l, r));
	} 
	return 0;
}
```

---

## 作者：Lele_Programmer (赞：2)

# P10639 题解

## 思路

吉司机线段树。

这道题不用维护历史最大和历史最小，只需要维护区间和、区间最大、区间最小、区间次大、区间次小、区间最大数量、区间最小数量，懒标记维护区间大于次大值的数字都变为什么、区间小于次小值的数字都变为什么、区间加。

于是一棵可爱的线段树就出来了：

```cpp
struct SegmentTree {
    int l,r;
    int sum,max,min;
    int cntmax,cntmin;
    int submax,submin;
    int setmax,setmin;
    int add;
} tr[N*4];
```

对于信息上传操作，先和普通的线段树一样，更新区间和和最值，然后再按照吉司机线段树的常规方法更新最大值最小值出现的次数以及次大值次小值，大概有下面几种情况：

1. 若左右最大值相等，则次大值为左次大值和右次大值的较大者。
2. 若左最大值更大，则次大值为左次大值和右最大值的较大者。
3. 若右最大值更大，则次大值为左最大值和右次大值的较大者。

最小值也是同样的道理。

于是就有了可爱的 `pushup`：

```cpp
inline void pushup(int u) {
    auto &root=tr[u],&left=tr[u<<1],&right=tr[u<<1|1];
    root.sum=left.sum+right.sum;
    root.max=max(left.max,right.max);
    root.min=min(left.min,right.min);
    if (left.max==right.max) {
        root.cntmax=left.cntmax+right.cntmax;
        root.submax=max(left.submax,right.submax);
    } else if (left.max<right.max) {
        root.cntmax=right.cntmax;
        root.submax=max(left.max,right.submax);
    } else {
        root.cntmax=left.cntmax;
        root.submax=max(left.submax,right.max);
    }
    if (left.min==right.min) {
        root.cntmin=left.cntmin+right.cntmin;
        root.submin=min(left.submin,right.submin);
    } else if (left.min<right.min) {
        root.cntmin=left.cntmin;
        root.submin=min(left.submin,right.min);
    } else {
        root.cntmin=right.cntmin;
        root.submin=min(left.min,right.submin);
    }
}
```

接下来考虑比较复杂的下传。

先看 $add$ 的下传，更新区间和、区间最大值、区间最小值、区间次大值、区间次小值以及其余三个懒标记。

```cpp
inline void pushadd(int u,int val) {
    tr[u].sum+=(tr[u].r-tr[u].l+1)*val;
    tr[u].max+=val;
    tr[u].min+=val;
    if (tr[u].setmax!=inf) tr[u].setmax+=val;
    if (tr[u].submax!=-inf) tr[u].submax+=val;
    if (tr[u].setmin!=-inf) tr[u].setmin+=val;
    if (tr[u].submin!=inf) tr[u].submin+=val;
    tr[u].add+=val;
}
```

对于将大于 $val$ 的数设为 $val$ 的懒标记 $setmax$ 的下传，如果 $val$ 比区间最大值大，那就不需要修改了，对结果没有任何影响，如果需要更改，那先更改一下区间和，还有节点的 $setmax$，然后还需要一些特判，如果区间最小值或次小值等于区间最大值，那么这里的修改还会对这两个信息产生影响，如果 $setmin$ 比 $setmax$ 还大，那就把 $setmin$ 设置为 $setmax$，最后再更改区间最大值，这里需要注意信息的更新顺序，区间最大值放在最后面更新，因为有两个特判需要用到原先的数据。当然，更新 $setmin$ 的操作道理一样。

```cpp
inline void pushsetmax(int u,int val) {
    if (val>=tr[u].max) return;
    tr[u].sum-=tr[u].cntmax*(tr[u].max-val);
    tr[u].setmax=val;
    tr[u].setmin=min(tr[u].setmin,tr[u].setmax);
    if (tr[u].submin==tr[u].max) tr[u].submin=val;
    if (tr[u].min==tr[u].max) tr[u].min=val;
    tr[u].max=val;
}

inline void pushsetmin(int u,int val) {
    if (val<=tr[u].min) return;
    tr[u].sum+=tr[u].cntmin*(val-tr[u].min);
    tr[u].setmin=val;
    tr[u].setmax=max(tr[u].setmax,tr[u].setmin);
    if (tr[u].submax==tr[u].min) tr[u].submax=val;
    if (tr[u].max==tr[u].min) tr[u].max=val;
    tr[u].min=val;
}
```

对于一个点的信息下传需要用到的函数就只有上面三个，现在写一个来集中处理：

```cpp
inline void pushdown(int u) {
    auto &root=tr[u],&left=tr[u<<1],&right=tr[u<<1|1];
    if (root.add) {
        pushadd(u<<1,root.add);
        pushadd(u<<1|1,root.add);
        root.add=0;
    }
    if (root.setmax!=inf) {
        pushsetmax(u<<1,root.setmax);
        pushsetmax(u<<1|1,root.setmax);
        root.setmax=inf;
    }
    if (root.setmin!=-inf) {
        pushsetmin(u<<1,root.setmin);
        pushsetmin(u<<1|1,root.setmin);
        root.setmin=-inf;
    }
}
```

搭建线段树，常规操作就不再多讲了：

```cpp
inline void build(int u,int l,int r) {
    tr[u]={l,r,arr[l],arr[l],arr[l],1,1,-inf,inf,inf,-inf,0};
    if (l==r) return;
    int mid=l+r>>1;
    build(u<<1,l,mid);
    build(u<<1|1,mid+1,r);
    pushup(u);
}

```

区间加，函数里面直接调用 `pushadd` 就好：

```cpp
inline void modify_add(int u,int l,int r,int k) {
    if (tr[u].l>=l && tr[u].r<=r) {
        pushadd(u,k);
    } else {
        pushdown(u);
        int mid=tr[u].l+tr[u].r>>1;
        if (l<=mid) modify_add(u<<1,l,r,k);
        if (r>mid) modify_add(u<<1|1,l,r,k);
        pushup(u);
    }
}
```

操作 $3$，对于不需要更改的区间就跳过，如果 $k$ 卡在最大值和次大值里面才改，其它的就暴搜下去：

```cpp
inline void modify_setmax(int u,int l,int r,int k) {
    if (tr[u].max<=k) return;
    if (tr[u].l>=l && tr[u].r<=r && k>tr[u].submax) {
        if (tr[u].l!=tr[u].r) pushdown(u);
        pushsetmax(u,k);
    } else {
        pushdown(u);
        int mid=tr[u].l+tr[u].r>>1;
        if (l<=mid) modify_setmax(u<<1,l,r,k);
        if (r>mid) modify_setmax(u<<1|1,l,r,k);
        pushup(u);
    }
}
```

操作 $2$ 同理：

```cpp
inline void modify_setmin(int u,int l,int r,int k) {
    if (tr[u].min>=k) return;
    if (tr[u].l>=l && tr[u].r<=r && k<tr[u].submin) {
        if (tr[u].l!=tr[u].r) pushdown(u);
        pushsetmin(u,k);
    } else {
        pushdown(u);
        int mid=tr[u].l+tr[u].r>>1;
        if (l<=mid) modify_setmin(u<<1,l,r,k);
        if (r>mid) modify_setmin(u<<1|1,l,r,k);
        pushup(u);
    }
}
```

接下来三个查询操作就和普通的线段树差不多了，这里不详细讲解：

```cpp
inline int query_sum(int u,int l,int r) {
    if (tr[u].l>=l && tr[u].r<=r) return tr[u].sum;
    pushdown(u);
    int mid=tr[u].l+tr[u].r>>1;
    int ans=0;
    if (l<=mid) ans+=query_sum(u<<1,l,r);
    if (r>mid) ans+=query_sum(u<<1|1,l,r);
    return ans;
}

inline int query_max(int u,int l,int r) {
    if (tr[u].l>=l && tr[u].r<=r) return tr[u].max;
    pushdown(u);
    int mid=tr[u].l+tr[u].r>>1;
    int ans=-inf;
    if (l<=mid) ans=max(ans,query_max(u<<1,l,r));
    if (r>mid) ans=max(ans,query_max(u<<1|1,l,r));
    return ans;
}

inline int query_min(int u,int l,int r) {
    if (tr[u].l>=l && tr[u].r<=r) return tr[u].min;
    pushdown(u);
    int mid=tr[u].l+tr[u].r>>1;
    int ans=inf;
    if (l<=mid) ans=min(ans,query_min(u<<1,l,r));
    if (r>mid) ans=min(ans,query_min(u<<1|1,l,r));
    return ans;
}
```

这里有一个注意点，线段树维护的信息中的 $setmax$ 应该初始化为正无穷，$setmin$ 应初始化为负无穷，虽然在代码 `pushsetmin` 和 `pushsetmax` 中显而易见 $setmax$ 只会一直取更大值 而 $setmin$ 只会一直取更小值，但是，如果我们将 $setmax$ 和 $setmin$ 分别初始为负无穷和正无穷的话，就说明将小于正无穷的数字全都变成正无穷，大于负无穷的数全都变为负无穷，这显然出现了矛盾，而且，当你为它们进行错误的初始化后，调用了 `pushsetmin` 和 `pushsetmax` 其中一者，那么其中一个变量会设置为 $val$，然后下一行的判定一定为真，然后再更新另一个变量为 $val$，就使得区间中所有的数字都设置为 $val$，这显然不对。

## 代码

```cpp
#include <bits/stdc++.h>

#define int long long

using namespace std;

namespace IO {
    inline void read(int &a) {
        int sym=1,num=0;
        char c=getchar();
        while (c<'0' || c>'9') {
            if (c=='-') {
                sym=-1;
        }
        c=getchar();
        }
        while (c>='0' && c<='9') {
            num=num*10+c-'0';
            c=getchar();
        }
        a=sym*num;
    }
    inline void write(int a) {
        if (a<0) {
            putchar('-');
            a*=-1;
        }
        if (a>=10) {
            write(a/10);
        }
        putchar(a%10+'0');
    }
}

using IO::read;

const int N=500005;
const int inf=9e18;

int n,m;
int arr[N];

struct SegmentTree {
    int l,r;
    int sum,max,min;
    int cntmax,cntmin;
    int submax,submin;
    int setmax,setmin;
    int add;
} tr[N*4];

inline void pushup(int u) {
    auto &root=tr[u],&left=tr[u<<1],&right=tr[u<<1|1];
    root.sum=left.sum+right.sum;
    root.max=max(left.max,right.max);
    root.min=min(left.min,right.min);
    if (left.max==right.max) {
        root.cntmax=left.cntmax+right.cntmax;
        root.submax=max(left.submax,right.submax);
    } else if (left.max<right.max) {
        root.cntmax=right.cntmax;
        root.submax=max(left.max,right.submax);
    } else {
        root.cntmax=left.cntmax;
        root.submax=max(left.submax,right.max);
    }
    if (left.min==right.min) {
        root.cntmin=left.cntmin+right.cntmin;
        root.submin=min(left.submin,right.submin);
    } else if (left.min<right.min) {
        root.cntmin=left.cntmin;
        root.submin=min(left.submin,right.min);
    } else {
        root.cntmin=right.cntmin;
        root.submin=min(left.min,right.submin);
    }
}

inline void pushsetmax(int u,int val) {
    if (val>=tr[u].max) return;
    tr[u].sum-=tr[u].cntmax*(tr[u].max-val);
    tr[u].setmax=val;
    tr[u].setmin=min(tr[u].setmin,tr[u].setmax);
    if (tr[u].submin==tr[u].max) tr[u].submin=val;
    if (tr[u].min==tr[u].max) tr[u].min=val;
    tr[u].max=val;
}

inline void pushsetmin(int u,int val) {
    if (val<=tr[u].min) return;
    tr[u].sum+=tr[u].cntmin*(val-tr[u].min);
    tr[u].setmin=val;
    tr[u].setmax=max(tr[u].setmax,tr[u].setmin);
    if (tr[u].submax==tr[u].min) tr[u].submax=val;
    if (tr[u].max==tr[u].min) tr[u].max=val;
    tr[u].min=val;
}

inline void pushadd(int u,int val) {
    tr[u].sum+=(tr[u].r-tr[u].l+1)*val;
    tr[u].max+=val;
    tr[u].min+=val;
    if (tr[u].setmax!=inf) tr[u].setmax+=val;
    if (tr[u].submax!=-inf) tr[u].submax+=val;
    if (tr[u].setmin!=-inf) tr[u].setmin+=val;
    if (tr[u].submin!=inf) tr[u].submin+=val;
    tr[u].add+=val;
}

inline void pushdown(int u) {
    auto &root=tr[u],&left=tr[u<<1],&right=tr[u<<1|1];
    if (root.add) {
        pushadd(u<<1,root.add);
        pushadd(u<<1|1,root.add);
        root.add=0;
    }
    if (root.setmax!=inf) {
        pushsetmax(u<<1,root.setmax);
        pushsetmax(u<<1|1,root.setmax);
        root.setmax=inf;
    }
    if (root.setmin!=-inf) {
        pushsetmin(u<<1,root.setmin);
        pushsetmin(u<<1|1,root.setmin);
        root.setmin=-inf;
    }
}

inline void build(int u,int l,int r) {
    tr[u]={l,r,arr[l],arr[l],arr[l],1,1,-inf,inf,inf,-inf,0};
    if (l==r) return;
    int mid=l+r>>1;
    build(u<<1,l,mid);
    build(u<<1|1,mid+1,r);
    pushup(u);
}

inline void modify_add(int u,int l,int r,int k) {
    if (tr[u].l>=l && tr[u].r<=r) {
        pushadd(u,k);
    } else {
        pushdown(u);
        int mid=tr[u].l+tr[u].r>>1;
        if (l<=mid) modify_add(u<<1,l,r,k);
        if (r>mid) modify_add(u<<1|1,l,r,k);
        pushup(u);
    }
}

inline void modify_setmax(int u,int l,int r,int k) {
    if (tr[u].max<=k) return;
    if (tr[u].l>=l && tr[u].r<=r && k>tr[u].submax) {
        if (tr[u].l!=tr[u].r) pushdown(u);
        pushsetmax(u,k);
    } else {
        pushdown(u);
        int mid=tr[u].l+tr[u].r>>1;
        if (l<=mid) modify_setmax(u<<1,l,r,k);
        if (r>mid) modify_setmax(u<<1|1,l,r,k);
        pushup(u);
    }
}

inline void modify_setmin(int u,int l,int r,int k) {
    if (tr[u].min>=k) return;
    if (tr[u].l>=l && tr[u].r<=r && k<tr[u].submin) {
        if (tr[u].l!=tr[u].r) pushdown(u);
        pushsetmin(u,k);
    } else {
        pushdown(u);
        int mid=tr[u].l+tr[u].r>>1;
        if (l<=mid) modify_setmin(u<<1,l,r,k);
        if (r>mid) modify_setmin(u<<1|1,l,r,k);
        pushup(u);
    }
}

inline int query_sum(int u,int l,int r) {
    if (tr[u].l>=l && tr[u].r<=r) return tr[u].sum;
    pushdown(u);
    int mid=tr[u].l+tr[u].r>>1;
    int ans=0;
    if (l<=mid) ans+=query_sum(u<<1,l,r);
    if (r>mid) ans+=query_sum(u<<1|1,l,r);
    return ans;
}

inline int query_max(int u,int l,int r) {
    if (tr[u].l>=l && tr[u].r<=r) return tr[u].max;
    pushdown(u);
    int mid=tr[u].l+tr[u].r>>1;
    int ans=-inf;
    if (l<=mid) ans=max(ans,query_max(u<<1,l,r));
    if (r>mid) ans=max(ans,query_max(u<<1|1,l,r));
    return ans;
}

inline int query_min(int u,int l,int r) {
    if (tr[u].l>=l && tr[u].r<=r) return tr[u].min;
    pushdown(u);
    int mid=tr[u].l+tr[u].r>>1;
    int ans=inf;
    if (l<=mid) ans=min(ans,query_min(u<<1,l,r));
    if (r>mid) ans=min(ans,query_min(u<<1|1,l,r));
    return ans;
}

signed main() {
    read(n);
    for (int i=1;i<=n;++i) {
        read(arr[i]);
    }
    build(1,1,n);
    read(m);
    while (m--) {
        int op,l,r;
        read(op); read(l); read(r);
        if (op==1) {
            int x;
            read(x);
            modify_add(1,l,r,x);
        } else if (op==2) {
            int x;
            read(x);
            modify_setmin(1,l,r,x);
        } else if (op==3) {
            int x;
            read(x);
            modify_setmax(1,l,r,x);
        } else if (op==4) {
            int ans=query_sum(1,l,r);
            printf("%lld\n",ans);
        } else if (op==5) {
            int ans=query_max(1,l,r);
            printf("%lld\n",ans);
        } else {
            int ans=query_min(1,l,r);
            printf("%lld\n",ans);
        }
    }
    return 0;
}
```

注意开 `long long`，有点卡常，虽然不开快读可以差几毫秒刚好过，但是还是做点优化吧，这份代码参考了 OI-Wiki，不过在代码实现的过程中，一些小细节有所不同，仅供参考。

---

## 作者：Aventurine_stone (赞：1)

## 1. 题目分析
看到二操作和三操作，我们很容易想到用吉司机线段树来做这道题。~~本来想用第二分块的。~~  
如果不会吉司机线段树，请先完成线段树三。
## 2. 题目做法
有六个操作，这里只讲前三个操作，后三个操作都是普通线段树的基础操作，相信大家都会。  
操作一，区间加减修改。我们只需要维护一个标记 $tag$ 即可完成。  
[区间加减代码](https://www.luogu.com.cn/paste/8brazpoe)  
操作二，吉司机线段树的基础操作之一，我们要维护一个变化标记，和区间最小值还有区间次小值即可。  
[操作二代码](https://www.luogu.com.cn/paste/8a4757lu)  
操作三，我们要维护一个变化标记，和区间最大值还有区间次大值。  
[操作三代码](https://www.luogu.com.cn/paste/zgsv3hgt)  
接下来是本体的重点，且代码非常容易写错，我因为这个调了整整一天。  
首先是上传操作。我们要维护区间和，最大值，次大值，最小值，次小值。代码稍微有点长。  
[上传操作代码](https://www.luogu.com.cn/paste/6fzf9nq3)  
然后是下传操作。我们可以分成三部分来写，然后汇总在一起，这样不仅代码短，而且容易调试。  
三部分分别是维护的三个懒标记。  
[下传操作代码](https://www.luogu.com.cn/paste/w4zvg3ds)  
如此我们便可完成此题，最后放一下完整代码。
## 3. 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=500010;
inline int read()
{
	int x=0,f=1;
	char c=getchar();
	while(c<'0'||c>'9')
		c=='-'?f=-1:1,c=getchar();
	while(c>='0'&&c<='9')
		x=(x<<1)+(x<<3)+c-'0',c=getchar();
	return x*f;
}
inline void write_int(int x)
{
	if(x<0)
		putchar('-'),x=-x;
	if(x>9)
		write_int(x/10);
	putchar(x%10+'0');
}
inline void write_ll(long long x)
{
	if(x<0)
		putchar('-'),x=-x;
	if(x>9)
		write_ll(x/10);
	putchar(x%10+'0');
}
struct tree{
	int l,r;
	int mx,cmx,mn,cmn;
	int mxcnt,mncnt;
	int tag,small,big;
	long long sum;
}t[N<<2];
int n,m;
int a[N];
inline void pushup(int idx)
{
	int l=idx*2,r=l+1;
	t[idx].sum=t[l].sum+t[r].sum;
	if(t[l].mx>t[r].mx)//最/次大 
	{
		t[idx].mx=t[l].mx;
		t[idx].mxcnt=t[l].mxcnt;
		t[idx].cmx=max(t[l].cmx,t[r].mx);
	}
	else if(t[l].mx==t[r].mx)
	{
		t[idx].mx=t[l].mx;
		t[idx].mxcnt=t[l].mxcnt+t[r].mxcnt;
		t[idx].cmx=max(t[l].cmx,t[r].cmx);
	}
	else
	{
		t[idx].mx=t[r].mx;
		t[idx].mxcnt=t[r].mxcnt;
		t[idx].cmx=max(t[l].mx,t[r].cmx);
	}
	if(t[l].mn<t[r].mn)//最/次小 
	{
		t[idx].mn=t[l].mn;
		t[idx].mncnt=t[l].mncnt;
		t[idx].cmn=min(t[l].cmn,t[r].mn);
	}
	else if(t[l].mn==t[r].mn)
	{
		t[idx].mn=t[l].mn;
		t[idx].mncnt=t[l].mncnt+t[r].mncnt;
		t[idx].cmn=min(t[l].cmn,t[r].cmn);
	}
	else
	{
		t[idx].mn=t[r].mn;
		t[idx].mncnt=t[r].mncnt;
		t[idx].cmn=min(t[l].mn,t[r].cmn);
	}
}
inline void pushadd(int u,int x)
{
	t[u].tag+=x;
	t[u].mx+=x,t[u].mn+=x;
	t[u].cmx!=-INT_MAX?t[u].cmx+=x:1;
	t[u].cmn!=INT_MAX?t[u].cmn+=x:1;
	t[u].small!=-INT_MAX?t[u].small+=x:1;
	t[u].big!=INT_MAX?t[u].big+=x:1;
	t[u].sum+=1ll*x*(t[u].r-t[u].l+1);
	if(t[u].l==t[u].r)
		t[u].tag=0;
}
inline void pushsmall(int u,int x)
{
	if(x>t[u].mn)
	{
		t[u].small=x;
		t[u].sum+=1ll*(x-t[u].mn)*t[u].mncnt;
		t[u].cmx==t[u].mn?t[u].cmx=x:1;
		t[u].mx==t[u].mn?t[u].mx=x:1;
		t[u].mn=x;
		t[u].big<x?t[u].big=x:1;
		if(t[u].l==t[u].r)
			t[u].small=-INT_MAX;
	}
}
inline void pushbig(int u,int x)
{
	if(x<t[u].mx)
	{
		t[u].big=x;
		t[u].sum-=1ll*(t[u].mx-x)*t[u].mxcnt;
		t[u].cmn==t[u].mx?t[u].cmn=x:1;
		t[u].mn==t[u].mx?t[u].mn=x:1;
		t[u].mx=x;
		t[u].small>x?t[u].small=x:1;
		if(t[u].l==t[u].r)
			t[u].big=INT_MAX;
	}
}
inline void pushdown(int idx)
{
	int l=idx*2,r=l+1;
	if(t[idx].tag)
	{
		pushadd(l,t[idx].tag);
		pushadd(r,t[idx].tag);
		t[idx].tag=0;
	}
	if(t[idx].big!=INT_MAX)
	{
		pushbig(l,t[idx].big);
		pushbig(r,t[idx].big);
		t[idx].big=INT_MAX;
	}
	if(t[idx].small!=-INT_MAX)
	{
		pushsmall(l,t[idx].small);
		pushsmall(r,t[idx].small);
		t[idx].small=-INT_MAX;
	}
}
inline void build(int idx,int l,int r)
{
	t[idx].l=l,t[idx].r=r;
	t[idx].small=-INT_MAX;
	t[idx].big=INT_MAX;
	if(l==r)
	{
		t[idx].sum=t[idx].mx=t[idx].mn=a[l];
		t[idx].cmx=-INT_MAX;
		t[idx].cmn=INT_MAX;
		t[idx].mxcnt=t[idx].mncnt=1;
		return ;
	}
	int mid=l+r>>1;
	build(idx*2,l,mid);
	build(idx*2+1,mid+1,r);
	pushup(idx);
}
inline long long sum(int idx,int l,int r)
{
	if(t[idx].r<l||t[idx].l>r)
		return 0;
	if(t[idx].l>=l&&t[idx].r<=r)
		return t[idx].sum;
	pushdown(idx);
	return sum(idx*2,l,r)+sum(idx*2+1,l,r);
}
inline int maxx(int idx,int l,int r)
{
	if(t[idx].r<l||t[idx].l>r)
		return -INT_MAX;
	if(t[idx].l>=l&&t[idx].r<=r)
		return t[idx].mx;
	pushdown(idx);
	return max(maxx(idx*2,l,r),maxx(idx*2+1,l,r));
}
inline int minn(int idx,int l,int r)
{
	if(t[idx].r<l||t[idx].l>r)
		return INT_MAX;
	if(t[idx].l>=l&&t[idx].r<=r)
		return t[idx].mn;
	pushdown(idx);
	return min(minn(idx*2,l,r),minn(idx*2+1,l,r));
}
inline void change1(int idx,int l,int r,int x)//加 
{
	if(t[idx].r<l||t[idx].l>r)
		return ;
	if(t[idx].l>=l&&t[idx].r<=r)
	{
		pushadd(idx,x);
		return ;
	}
	pushdown(idx);
	change1(idx*2,l,r,x);
	change1(idx*2+1,l,r,x);
	pushup(idx);
}
inline void change2(int idx,int l,int r,int x)//小 
{
	if(t[idx].r<l||t[idx].l>r||t[idx].mn>=x)
		return ;
	if(t[idx].l>=l&&t[idx].r<=r&&t[idx].cmn>x)
	{
		pushsmall(idx,x);
		return ;
	}
	pushdown(idx);
	change2(idx*2,l,r,x);
	change2(idx*2+1,l,r,x);
	pushup(idx);
}
inline void change3(int idx,int l,int r,int x)//大 
{
	if(t[idx].r<l||t[idx].l>r||t[idx].mx<=x)
		return ;
	if(t[idx].l>=l&&t[idx].r<=r&&t[idx].cmx<x)
	{
		pushbig(idx,x);
		return ;
	}
	pushdown(idx);
	change3(idx*2,l,r,x);
	change3(idx*2+1,l,r,x);
	pushup(idx);
}
int op,l,r,x;
int main()
{
	n=read();
	for(int i=1;i<=n;i++)
		a[i]=read();
	build(1,1,n);
	m=read();
	while(m--)
	{
		op=read(),l=read(),r=read();
		if(op==1)
		{
			x=read();
			change1(1,l,r,x);
		}
		else if(op==2)
		{
			x=read();
			change2(1,l,r,x);
		}
		else if(op==3)
		{
			x=read();
			change3(1,l,r,x);
		}
		else if(op==4)
			write_ll(sum(1,l,r)),putchar(10);
		else if(op==5)
			write_int(maxx(1,l,r)),putchar(10);
		else
			write_int(minn(1,l,r)),putchar(10);
	}
	return 0;
}
```

---

## 作者：无名之雾 (赞：1)

势能线段树入门题，但是非常的码农。


## 题意

给定一个序列，让我们实现 $6$ 种操作。

1. 区间 $[l, r]$ 加 $x$。
1. 区间 $[l, r]$ 里小于 $x$ 的数变成 $x$。
1. 区间 $[l, r]$ 里大于 $x$ 的数变成 $x$。
1. 区间 $[l, r]$ 求和。
1. 区间 $[l, r]$ 求 $\max$。
1. 区间 $[l, r]$ 求 $\min$。

## 思路

看到操作 $2$ 和 操作 $3$ 就不难想到势能线段树。

首先我们来思考如何维护操作 $3$。

区间对 $x$ 取 $\min$ 意味着只对大于 $x$ 的数有效。我们对于每个区间维护两个信息 $\text{Max}$ 和 $\text{Max2}$，即最大值与次大值。

- 如果 $\text{Max}\le x$ 那么返回即可。

- 如果 $\text{Max2}\le x \le \text{Max}$ 就将 $x$ 转换为该区间最大值。

- 如果 $ x\le\text{Max2}$ 向下递归即可。

操作 $2$ 同理。

对于本题我们依旧沿用这个思路，同时根据操作需求，我们维护：最大、次大、最大个数、最小、次小、最小个数、区间和，这几个信息；同时维护区间最大，区间最小，区间和这几个 $\text{lazytag}$。

时间复杂度可以证明是 $O(n\log^2 n)$ 的。

## 实现

注意 $\text{lazytag}$ 下传的优先级。本题可能略微卡常，建议使用结构体封装一下。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
inline int read(){
   int s=0,w=1;
   char ch=getchar();
   while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
   while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
   return s*w;
}
inline void write(int x){
    if(x==0){putchar('0');return;}
	int len=0,k1=x,c[10005];
	if(k1<0)k1=-k1,putchar('-');
	while(k1)c[len++]=k1%10+'0',k1/=10;
	while(len--)putchar(c[len]);
}
const int N=5e5+10;
int a[N];
struct SGT{
	int mx[N<<2],mx2[N<<2],mn[N<<2],mn2[N<<2],smx[N<<2],smn[N<<2];
	int add[N<<2],tr[N<<2],tmx[N<<2],tmn[N<<2];
	int ls(int p){return p<<1;}
	int rs(int p){return p<<1|1;}
	void push_up(int p){
		tr[p]=tr[ls(p)]+tr[rs(p)];
		if(mx[ls(p)]==mx[rs(p)]){
    		mx[p]=mx[ls(p)],smx[p]=smx[ls(p)]+smx[rs(p)];
    		mx2[p]=max(mx2[ls(p)],mx2[rs(p)]);
  		}
  		else if(mx[ls(p)]>mx[rs(p)]){
    		mx[p]=mx[ls(p)],smx[p]=smx[ls(p)];
    		mx2[p]=max(mx2[ls(p)],mx[rs(p)]);
  		}
  		else{
    		mx[p]=mx[rs(p)],smx[p]=smx[rs(p)];
    		mx2[p]=max(mx2[rs(p)],mx[ls(p)]);
  		}
  		if(mn[ls(p)]==mn[rs(p)]){
    		mn[p]=mn[ls(p)],smn[p]=smn[ls(p)]+smn[rs(p)];
    		mn2[p]=min(mn2[ls(p)],mn2[rs(p)]);
  		}
  		else if(mn[ls(p)]<mn[rs(p)]){
    		mn[p]=mn[ls(p)],smn[p]=smn[ls(p)];
    		mn2[p]=min(mn2[ls(p)],mn[rs(p)]);
  		}
  		else{
    		mn[p]=mn[rs(p)],smn[p]=smn[rs(p)];
    		mn2[p]=min(mn2[rs(p)],mn[ls(p)]);
  		}
	}
	void build(int p,int pl,int pr){
		tmn[p]=INT_MAX,tmx[p]=INT_MIN;
		if(pl==pr){
			tr[p]=mn[p]=mx[p]=a[pl];
			mn2[p]=INT_MAX,mx2[p]=INT_MIN;
			smx[p]=smn[p]=1;
			return ;
		}
		int mid=(pl+pr)>>1;
		build(ls(p),pl,mid);
		build(rs(p),mid+1,pr);
		push_up(p);
	}
	void add_tag(int p,int pl,int pr,int d){
		mx[p]+=d,mn[p]+=d,add[p]+=d;
		tr[p]+=d*(pr-pl+1);
		if(mx2[p]!=INT_MIN)mx2[p]+=d;
		if(mn2[p]!=INT_MAX)mn2[p]+=d;
		if(tmn[p]!=INT_MAX)tmn[p]+=d;
		if(tmx[p]!=INT_MIN)tmx[p]+=d; 
	}
	void max_tag(int p,int d){
		if(mn[p]>d)return ;
		tr[p]+=(d-mn[p])*smn[p];
		if(mx[p]==mn[p])mx[p]=d;
		if(mx2[p]==mn[p])mx2[p]=d;
		if(tmn[p]<d)tmn[p]=d;
		mn[p]=d,tmx[p]=d;
	}
	void min_tag(int p,int d){
		if(mx[p]<=d)return ;
		tr[p]+=(d-mx[p])*smx[p];
		if(mn[p]==mx[p])mn[p]=d;
		if(mn2[p]==mx[p])mn2[p]=d;
		if(tmx[p]>d)tmx[p]=d;
		mx[p]=d,tmn[p]=d;
	}  
	void push_down(int p,int pl,int pr){
		if(add[p]){
			int mid=(pl+pr)>>1;
			add_tag(ls(p),pl,mid,add[p]);
			add_tag(rs(p),mid+1,pr,add[p]);
			add[p]=0;
		}
		if(tmx[p]!=INT_MIN){
			max_tag(ls(p),tmx[p]);
			max_tag(rs(p),tmx[p]);
			tmx[p]=INT_MIN;
		}
		if(tmn[p]!=INT_MAX){
			min_tag(ls(p),tmn[p]);
			min_tag(rs(p),tmn[p]);
			tmn[p]=INT_MAX;
		}
	}
	void Add(int l,int r,int p,int pl,int pr,int d){
		if(l<=pl&&pr<=r){
			add_tag(p,pl,pr,d);
			return ;
		}
		int mid=(pl+pr)>>1;
		push_down(p,pl,pr);
		if(l<=mid)Add(l,r,ls(p),pl,mid,d);
		if(r>mid)Add(l,r,rs(p),mid+1,pr,d);
		push_up(p);
	}
	void Mmax(int l,int r,int p,int pl,int pr,int d){
		if(mn[p]>=d)return ;
		if(l<=pl&&pr<=r&&mn2[p]>d){
			max_tag(p,d);
			return ;
		}
		int mid=(pl+pr)>>1;
		push_down(p,pl,pr);
		if(l<=mid)Mmax(l,r,ls(p),pl,mid,d);
		if(r>mid)Mmax(l,r,rs(p),mid+1,pr,d);
		push_up(p);
	}
	void Mmin(int l,int r,int p,int pl,int pr,int d){
		if(mx[p]<=d)return ;
		if(l<=pl&&pr<=r&&mx2[p]<d){
			min_tag(p,d);
			return ;
		}
		int mid=(pl+pr)>>1;
		push_down(p,pl,pr);
		if(l<=mid)Mmin(l,r,ls(p),pl,mid,d);
		if(r>mid)Mmin(l,r,rs(p),mid+1,pr,d);
		push_up(p);
	}
	int Qsum(int l,int r,int p,int pl,int pr){
		if(l<=pl&&pr<=r)return tr[p];
		push_down(p,pl,pr);
		int res=0,mid=(pl+pr)>>1;
		if(l<=mid)res+=Qsum(l,r,ls(p),pl,mid);
		if(r>mid)res+=Qsum(l,r,rs(p),mid+1,pr);
		return res;
	}
	int Qmax(int l,int r,int p,int pl,int pr){
		if(l<=pl&&pr<=r)return mx[p];
		push_down(p,pl,pr);
		int res=INT_MIN,mid=(pl+pr)>>1;
		if(l<=mid)res=max(Qmax(l,r,ls(p),pl,mid),res);
		if(r>mid)res=max(Qmax(l,r,rs(p),mid+1,pr),res);
		return res;
	}
	int Qmin(int l,int r,int p,int pl,int pr){
		if(l<=pl&&pr<=r)return mn[p];
		push_down(p,pl,pr);
		int res=INT_MAX,mid=(pl+pr)>>1;
		if(l<=mid)res=min(Qmin(l,r,ls(p),pl,mid),res);
		if(r>mid)res=min(Qmin(l,r,rs(p),mid+1,pr),res);
		return res;
	}
}sgt;
signed main(){
	int n=read();
	for(int i=1;i<=n;i++)a[i]=read();
	sgt.build(1,1,n);
	int m=read();
	while(m--){
		int op=read(),l=read(),r=read();
		if(op==1){
			int x=read();
			sgt.Add(l,r,1,1,n,x);
		}
		else if(op==2){
			int x=read();
			sgt.Mmax(l,r,1,1,n,x);
		}
		else if(op==3){
			int x=read();
			sgt.Mmin(l,r,1,1,n,x);
		}
		else if(op==4)write(sgt.Qsum(l,r,1,1,n)),puts("");
		else if(op==5)write(sgt.Qmax(l,r,1,1,n)),puts("");
		else write(sgt.Qmin(l,r,1,1,n)),puts("");
	}
	return 0;
}
```

## 后记

这道题目是我期末考完试数据结构康复训练时写的。当时已经基本不会码代码了。大概断断续续写和调了 $4$ 天。

期间发生的垃圾错误包括但不限于：

数组开成了 `N>>2`，`max` 打成了 `min`，`mx` 打成了 `tmx`，`res` 没有初始化。

写这道题为了我的码力带来了极大的提升。故写此题解以祭之。

[最后附上我的提交记录](https://www.luogu.com.cn/record/list?pid=P10639&user=704275)

---

## 作者：Starrykiller (赞：0)

> 选自 数据结构做题记录 **LXIV**。

Segbeats 板子题。我们维护区间的

- $\mathrm{mx},\mathrm{secmx},\mathrm{mxcnt}$：最大值，严格次大值，最大值的个数；
- $\mathrm{mn},\mathrm{secmn},\mathrm{mncnt}$：最小值，严格次小值，最小值的个数；
- $\mathrm{sum}$：区间和。

以区间 chmax $v$ 为例，当当前区间完全包含询问区间时：

- $v\le \mathrm{mn}$：无事可做，直接返回；
- $\mathrm{mn}\lt v\lt \mathrm{secmn}$：直接修改 $\mathrm{mn}$ 即可；
- $\mathrm{secmn} \le v$：递归处理。

chmin 同理，对于 add 操作只需要维护一个 lazytag 即可。

需要注意的是，本题中同时有 chmax 和 chmin 操作，对于区间内只有 1~2 个本质不同的数的时候，需要特别处理一下。

同时需要注意 pushdown 时各个 tag 的顺序。

然后就做完了，[代码](https://www.luogu.com.cn/paste/63ppl9v5)很好写。时间复杂度可以证明是 $\Theta(m\log^2 n)$ 的。

---


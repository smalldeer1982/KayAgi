# [集训队互测 2015] Robot

## 题目描述

小 q 有 $n$ 只机器人，一开始他把机器人放在了一条数轴上，第 $i$ 只机器人在 $a_i$ 的位置上静止，而自己站在原点。

在这之后小 q 会执行一些操作，他想要命令一个机器人向左或者向右移动 $x$ 格。但是机器人似乎听不清小 q 的命令，事实上它们会以每秒 $x$ 格的速度匀速移动。

看着自己的机器人越走越远，小 q 很着急，他想知道当前离他（原点）最远的机器人有多远。

具体的操作以及询问见输入格式。注意，不同的机器人之间互不影响，即不用考虑两个机器人撞在了一起的情况。

## 说明/提示

### 样例解释

- 第一个命令执行时，各个机器人的位置为：$-20, 0, 20, 100$。
- 第二个命令执行时，各个机器人的位置为：$80, 0, 20, 100$。
- 第一个询问时，各个机器人的位置为：$180, 0, -80, 100$。
- 第三个命令执行时，各个机器人的位置为：$280, 0, -180, 100$。
- 第二个询问时，各个机器人的位置为：$-20, 0, -280, 100$。

### 数据范围

设 `command` 的个数为 $C$，`query` 的个数为 $Q$。（所以 $C + Q = m$）

对于所有的事件满足 $0 \leq t_i \leq 10^9$，对于所有的 `command` 满足 $\lvert x_i \rvert \leq 10^4$。

对于所有的机器人满足 $\lvert a_i \rvert \leq 10^9$。

所有测试数据的范围和特点如下表所示：

| 测试点编号 | 数据范围 | 特殊限制 |
| :----------: | :----------: | :----------: |
| $1$ | $n,m\leq 2000$ | 无 |
| $2$ | $n,m\leq 2000$ | 无 |
| $3$ | $n,m\leq 10^5$ | $-1 \leq x_i \leq 1$ |
| $4$ | $n,C\leq 10^5$，$Q\leq 5\times 10^5$ | 两个机器人发生碰面或者超越另一个的次数 $\leq 4\times 10^5$ |
| $5$ | $n,C\leq 10^5$，$Q\leq 5\times 10^5$ | 两个机器人发生碰面或者超越另一个的次数 $\leq 4\times 10^5$ |
| $6$ | $n,m\leq 10^5$ | 不会在 $t_i>0$ 时出现 `command` 操作 |
| $7$ | $n,m\leq 10^5$ | 不会在 $t_i>0$ 时出现 `command` 操作 |
| $8$ | $n,m\leq 10^5$ | 无 |
| $9$ | $n,C\leq 10^5$，$Q\leq 5\times 10^5$ | 无 |
| $10$ | $n,C\leq 10^5$，$Q\leq 5\times 10^5$ | 无 |


## 样例 #1

### 输入

```
4 5
-20 0 20 100
10 command 1 10
20 command 3 -10
30 query
40 command 1 -30
50 query```

### 输出

```
180
280```

# 题解

## 作者：gan_ge (赞：2)

先看测试点 $6,7$：不会在 $t_i>0$ 时出现 `command` 操作，此时若以时间 $t$ 为横坐标，机器人在数轴上的位置 $x$ 为横坐标绘出机器人的轨迹，易知其为形如 $x=kt+b$ 的一次函数图像。

但当 $t_i>0$ 时出现 `command` 操作时，该轨迹又会变成一条折线，极为不美观，此时若把折线分成若干线段，则每条线段仍满足上面的性质，但有定义域的限制。

因此考虑离线，将每个机器人的轨迹分为若干线段存储，线段总数为 $n+C$（$n$ 个机器人，每次操作会产生 $1$ 个新的线段）。

现在题目转化为：  
>现有 $n+C$ 条形如 $x=kt+b,t \in[l,r]$ 的线段，$Q$ 次询问，每次给定一个数 $t_i$，求与直线 $t=t_i$ 相交的线段中，交点纵坐标最大为多少。

显然是李超线段树，但交点坐标均为整数，比模版[P4097 【模板】李超线段树](https://www.luogu.com.cn/problem/P4097)还是好写点的。

**注意**：
1. $b$ 值可能很大，要开 `long long`； 
2. $0 \le t_i \le 10^9$，故要用动态开点线段树。
 
附代码：
```cpp
#include<bits/stdc++.h>
using namespace std;

#define ls tr[p].l
#define rs tr[p].r

typedef long long ll;
typedef long double ld;

const int N=1e5+10;

struct line{
    int k;ll b;
}p[N<<2];

int cnt=0;

ll f(int id,int x){
    return labs(1ll*p[id].k*x+p[id].b);
}

struct tree{
    int l,r,id;
}tr[N<<5];

int tot=0,rt=0;

void pushnow(int &p,int l,int r,int now){
    if(!p) p=++tot;
    int &lst=tr[p].id,mid=(l+r)>>1;
    if(f(now,mid)>f(lst,mid)) swap(now,lst);

    if(f(now,l)>f(lst,l)) pushnow(ls,l,mid,now);
    if(f(now,r)>f(lst,r)) pushnow(rs,mid+1,r,now);
}

void update(int &p,int l,int r,int ql,int qr,int now){
    if(!p) p=++tot;
    if(ql<=l&&r<=qr) return pushnow(p,l,r,now),void();
    int mid=(l+r)>>1;
    if(ql<=mid) update(ls,l,mid,ql,qr,now);
    if(qr>mid) update(rs,mid+1,r,ql,qr,now);
}

ll query(int p,int l,int r,int pl){
    if(!p) return 0;
    ll res=f(tr[p].id,pl);
    int mid=(l+r)>>1;
    if(pl<=mid) return max(res,query(ls,l,mid,pl));
    else return max(res,query(rs,mid+1,r,pl));
}

int n,m,mxt=0,a[N];

vector<pair<int,int> > ch[N];

vector<int> q;

int main(){
    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        cin>>a[i];
        ch[i].push_back({0,0});
    }
    int t,k,x; string s;
    for(int i=1;i<=m;i++){
        cin>>t>>s;
        mxt=max(mxt,t);
        if(s[0]=='c'){
            cin>>k>>x;
            if((*ch[k].rbegin()).first==t) ch[k].pop_back();
            ch[k].push_back({t,x});
        }
        else q.push_back(t);
    }
    for(int i=1;i<=n;i++){
        if((*ch[i].rbegin()).first!=mxt) ch[i].push_back({mxt,0});
        ll y=a[i];
        for(int j=1;j<(int)ch[i].size();j++){
            int l=ch[i][j-1].first,r=ch[i][j].first,k=ch[i][j-1].second;
            p[++cnt]={k,y-1ll*k*l};
            y+=1ll*(r-l)*k;
            update(rt,0,mxt,l,r,cnt);
        }
    }
    for(auto i:q)
        cout<<query(1,0,mxt,i)<<'\n';
    return 0;
}
```

---

## 作者：I_am_Lord_Voldemort (赞：2)

**所以这道题为什么要删除线段。**

观察题目，我们不难发现对于一个时间点，每个机器人有且仅有一个对应位置，所以最后会画出一些折线，折点为时间修改处。因此我们套用李超线段树的模版那道题，直接上一些线段，就可以不用删除，进而转换为坐标系为时间轴和距离的一道李超线段树模版题。

code：
```
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define ls tr[p].lc
#define rs tr[p].rc
const int maxn = 1e5 + 10; int maxt;
int n, m, tot = 0, lastans = 0;
int k[maxn << 1], b[maxn << 1];
struct Node {
    int lc, rc, nd;
}tr[maxn<<5]; int cnt = 0, rt = 0;

int cal(int x, int id) {return abs(k[id] * x + b[id]);}

void update(int &p, int l, int r, int x) {
    if(!p) p = ++ cnt;
    int mid = (l + r) >> 1;
    int &v = tr[p].nd;
    if(cal(mid, x) > cal(mid, v)) swap(v, x);
    if(cal(l, x) > cal(l, v)) update(ls, l, mid, x);
    if(cal(r, x) > cal(r, v)) update(rs, mid + 1, r, x);
}

void insert(int &p, int l, int r, int ql, int qr, int x) {
    if(!p) p = ++ cnt;
    if(ql <= l && r <= qr) {update(p, l, r, x); return;}
    int mid = (l + r) >> 1;
    if(ql <= mid) insert(ls, l, mid, ql, qr, x);
    if(mid < qr) insert(rs, mid + 1, r, ql, qr, x);
}

int query(int p, int l, int r, int x) {
    if(!p || x < l || r < x) return 0;
    int mid = (l + r) >> 1;
    int now = cal(x, tr[p].nd);
    if(l == r) return now;
    return max({now, query(ls, l, mid, x), query(rs, mid + 1, r, x)});
}

vector<pair<int, int>>tim[maxn];
vector<int>q;
int a[maxn];
signed main() {
    ios :: sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);
    cin >> n >> m;
    for(int i = 1; i <= n; ++ i) cin >> a[i], tim[i].push_back({0, 0});
    int t, l, r;
    string s;
    for(int i = 1; i <= m; ++ i) {
        cin >> t >> s; maxt = max(maxt, t);
        if(s[0] == 'c') cin >> l >> r, tim[l].push_back({t, r});
        else q.push_back(t);
    }
    for(int i = 1; i <= n; ++ i) {
        tim[i].push_back({maxt + 1, 0});
        for(int j = 0; j < tim[i].size() - 1; ++ j) {
            if(tim[i][j].first == tim[i][j + 1].first) continue;
            //cerr << i << " " << tim[i][j].first << " " << a[i] << "\n";
            k[++ tot] = tim[i][j].second; b[tot] = a[i] - tim[i][j].first * k[tot]; a[i] += (tim[i][j + 1].first - tim[i][j].first) * k[tot];
            insert(rt, 0, maxt, tim[i][j].first, tim[i][j + 1].first - 1, tot);            
        }   
    }
    for(auto i : q) cout << query(rt, 0, maxt + 1, i) << "\n";
}
```

---

## 作者：xiezheyuan (赞：2)

## 简要题意

给定 $n$ 个机器人，初始时第 $i$ 个机器人位于 $a_i$ 静止，依次进行有 $m$ 次操作，支持：

- `t command k v` 在第 $t$ 个时刻，将第 $k$ 个机器人的速度改为向正方向 $v$ 个单位每时刻。
- `t query` 询问机器人在第 $t$ 个时刻距离 $0$ 的最大距离。

$0\leq t\leq 10^9,1\leq n\leq 10^5,1\leq m\leq 6\times 10^5$，保证 $t$ 递增。

## 思路

根据小学行程问题可知，对于一次 `command` 操作，假设当前位于 $p$，若接下来没有 `command` 操作，则对于 $t'\geq t$，$t$ 时刻的位置为 $p+v(t'-t)=vt'+(p-vt)$，这是一个一次函数的形式。

与原点的距离可以看成坐标绝对值，则要求所有一次函数在 $x=t$ 的绝对值最大值，不妨将每个一次函数的取各常数相反数，改为求普通的最大值。那么这显然是一个（大概率）可以用李超线段树解决的问题。

对于原问题，我们需要修改一个一次函数，查询 $x=t$ 的一次函数最大值。修改可以拆成插入和删除，李超线段树很容易支持插入，但不容易做删除。所以可以用线段树分治，每次记录插入时改变的位置即可。时间复杂度 $O(m\log m\log V)$。

注意实现细节，否则你可能会挂在 UOJ 的 Hack 数据。

[Submission](https://uoj.ac/submission/739696)。

---

## 作者：Nygglatho (赞：1)

KTT 做法。这里的变量可能和原题有一定不同。

以下令第 $i$ 个波特当前的移动速度为 $k_i$，当前时刻的位置为 $b_i$。初始 $k_i=0,b_i=a_i$。

首先离原点最远的显然就是 $b_i$ 最大或者 $b_i$ 最小的，这里只介绍 $b_i$ 最大的情况，$b_i$ 最小的情况只需要把初始位置和操作取相反数再求最大即可。

考虑第 $p$ 次操作和第 $p-1$ 次操作之间的 $\Delta t=t_p-t_{p-1}$ 秒中发生了什么，对于第 $i$ 个波特，显然是以 $k_i$ 的速度匀速移动了 $\Delta t$ 秒，有 $b_i\gets b_i+k_i\cdot \Delta t$，那就是在每次操作之前，所有 $b_i$ 都增加 $k_i\cdot \Delta t$。

现在需要支持以下三种操作：

- 给定 $\Delta t$，$\forall 1\le i\le n,b_i\gets b_i+k_i\cdot \Delta t$，即全局修改 $b_i$。
- 给定 $pos,v$，$k_{pos}\gets v$，即 $\tt command$ 操作。
- 求 $\max b_i$，即 $\tt query$ 操作。

然后这个 $k$ 和 $b$ 可以看成一次函数，第一个操作就是所有一次函数左移 $\Delta t$ 个单位，第二个操作就是修改其中一个一次函数的斜率，这个很像 KTT 的形式。

考虑用 KTT 做，每个节点维护三个值：$\max_k,\max_b,w$。$\max_k$ 和 $\max_b$ 表示当前 $b$ 值最大（零点时函数值最大）的一次函数的 $k$ 和 $b$，$w$ 就是阈值，即子树内的一次函数再左移 $w$ 单位之后 $\max_k,\max_b$ 会改变，如果 $\max$ 不会改变则 $w=\infty$，一个叶节点 $[i,i]$ 的 $\max_k=k_i,\max_b=b_i,w=\infty$。

对于 $\max_k,\max_b$ 这两个值，合并两个区间 $[l,mid],[mid+1,r]$ 是简单的，对于 $w$，则有 $w_{[l,r]}=\min(w_{[l,mid]},w_{[mid+1,r]})$，同时，如果 $[l,mid]$ 和 $[mid+1,r]$ 的函数 $f_1(x)=\max_{[l,mid],k}x+\max_{[l,mid],b}$ 和 $f_2(x)=\max_{[mid+1,r],k}x+\max_{[mid+1,r],b}$ 在 $x\ge0$ 有交点 $(p_x,p_y)$，那么 $\max_{[l,r],k},\max_{[l,r],b}$ 肯定会在 $p_x$ 处（或者前面）发生改变，因此还有 $w_{[l,r]}\gets \min(w_{[l,r]},p_x)$。

对于所有 $b_i$ 都增加 $k_i\cdot \Delta t$ 这个操作（全体左移 $t$ 格），维护懒标记 $lazy_{[l,r]}$ 表示 $[l,r]$ 的子树中函数需要左移 $lazy_{[l,r]}$ 格。修改一个节点时，如果需要左移 $p$ 格，则 $\max_b\gets k_i\cdot p$，同时 $w\gets w-p$，然后懒标记也同时修改一下就行了，在 $\tt command$ 时再下传。然后对于全体修改，如果 $\Delta t<w_{[1,n]}$ 就修改节点 $[1,n]$ 就可以，否则就重构子树，就是递归更新左右子树，令当前节点为 $[l,r]$，如果 $lazy_{[l,r]}+\Delta t$ 小于子节点的 $w$ 就继续递归更新，否则直接修改子节点并打上懒标记，然后 pushup。

pushdown 的时候应该是不用判是否超过阈值的，因为如果 $\Delta t<w_{[1,n]}$ 显然 $\Delta t$ 也小于其子节点的 $w$。

对于一次 $\tt command$ 操作，直接找到 $[pos,pos]$，然后逐个 pushup，更新 $\max_k,\max_b,w$ 就行了。

对于 $\tt query$ 操作，显然 $\max_{[1,n],b}$ 即为当前时刻答案。

复杂度应该是 $O(n\log^2 n)$（$O(n\log^3 n)$？）可以看下 [KTT 论文（P52 浅谈函数最值的动态维护）](https://rusunoi.github.io/books/National-Team-Thesis/2020.pdf)。

[UOJ Submission](https://uoj.ac/submission/750654)

---

## 作者：Miss_SGT (赞：1)

李超树板子题。

就是动态插入、删除函数，然后求最大值与最小值。

因为李超树不好删除，直接算出一个函数出现的时间后，上线段树分治就能过了（之前唐了这么写的）。时间复杂度 $O(C \log^2 m )$，常数很大且不好写。

注意到询问的点是不降的，所以找出所在时间后直接按板子那样插入线段就行，常数小了很多，空间线性。


```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=6e5+5；
int n,m,ti[N],k[N],x[N],lst[N];
long long a[N];
struct Fun{
	long long k,b;bool vis;
	inline long long f(int x){return vis?k*x+b:-(1ll<<60);}
	inline Fun operator-(){return (Fun){-k,-b,vis};}
}val[N];
struct Miss_SGT{
	#define mid ((l+r)>>1) 
	Fun t[1<<22];
	void change(int p,int l,int r,Fun v){
		if(!t[p].vis) return t[p]=v,void();
		if(t[p].f(ti[mid])<v.f(ti[mid])) swap(t[p],v);
		if(t[p].f(ti[l])<v.f(ti[l])) change(2*p,l,mid,v);
		if(t[p].f(ti[r])<v.f(ti[r])) change(2*p+1,mid+1,r,v);
	}
	void change(int p,int l,int r,int lt,int rt,Fun v){
		if(lt<=l&&r<=rt) return change(p,l,r,v),void();
		if(lt<=mid) change(2*p,l,mid,lt,rt,v);
		if(mid<rt) change(2*p+1,mid+1,r,lt,rt,v);
	}
	long long query(int p,int l,int r,int x){
		if(l==r) return t[p].f(ti[x]);
		return max(x<=mid?query(2*p,l,mid,x):query(2*p+1,mid+1,r,x),t[p].f(ti[x]));
	}
}T1,T2; 
int main(){
	read(n),read(m);
	for(int i=1;i<=n;++i) read(a[i]),val[i]={0,a[i],1};
	for(int i=1;i<=m;++i){
		read(ti[i]);
		char op=gc();
		while(op<'a'||op>'z') op=gc();
		if(op=='c') read(k[i]),read(x[i]);
	}
	for(int i=1;i<=m;++i)if(k[i]){
		int p=lst[k[i]];
		T1.change(1,0,m,p,i-1,val[k[i]]);
		T2.change(1,0,m,p,i-1,-val[k[i]]);
		a[k[i]]+=1ll*x[p]*(ti[i]-ti[p]);
		val[k[i]]={x[i],a[k[i]]-1ll*ti[i]*x[i],1};
		lst[k[i]]=i;
	}
	for(int i=1;i<=n;++i){
		int p=lst[i];
		T1.change(1,0,m,p,m,val[i]);
		T2.change(1,0,m,p,m,-val[i]);
	}
	for(int i=1;i<=m;++i) if(!k[i]) print(max(T1.query(1,0,m,i),T2.query(1,0,m,i))),pc('\n');
	return 0;
}
```

---

## 作者：ZSB00000 (赞：0)

今天被这道题卡了好久，干脆写篇题解纪念下。  
本文将同步更新在作者的[知乎](https://zhuanlan.zhihu.com/p/1940118269441860898)和[博客](https://www.cnblogs.com/zsb00000/articles/19042440)。  
### 题目分析&&思路简介：  
容易发现，每一个机器人的运动路线都是一个分了多段的一次函数。具体的讲，就是我们设 $y_i$ 表示在当前时刻第 $i$ 个机器人所在坐标，则我们有：  
$$
y_i= \begin{cases}  
k_{i,1} \times t + d_{i,1},t \in [l_1,r_1 ]\\
k_{i,2} \times t + d_{i,2},t \in [l_2,r_2]\\
....\\
k_{i,j} \times t + d_{i,j},t \in [l_j,r_j]\\
\end{cases}
$$  
很明显，我们需要使用李超线段树维护这些信息。
但是，我们要确定每一段的开始和结尾（即需确定所有的 $[l_i,r_i]$），我们难以在线维护，所以可以考虑离线，把所有的 `command` 操作转化为一些线段，在李超树上维护。
### 具体实现：  
首先要为每一个机器人加入一个 $k=0$ 的线段作为初始值。  
然后输入所有的操作数据，记录下每一个机器人的 `command` 操作。同时注意，如果有多个同时针对同一个机器人的操作，我们只保留最后输入的那个。随后为每一个线段计算定义域,并插入李超树。  
接着就是李超树的普通操作。  
我们大体上就完成了这个题。  
不过有一些细节需注意，第一李超树的求值函数需要加上绝对值，因为题目要求离原点最远的那个，不加绝对值的话在数轴负半轴的会被漏掉；还有这个题范围超过了 `int` 的范围，记得开 `long long`。  
就先不放代码了，祝大家写题愉快！

---

## 作者：Purslane (赞：0)

# Solution

容易发现每个机器人的位置关于时间是分段一次函数，而段的总和为 $O(n+m)$。

而 $|x| = \max\{x,-x\}$，所以对于每个机器人用李超线段树维护 $pos(t)$ 和 $-pos(t)$ 的最大值即可，复杂度 $O(n \log^2 V + q \log V)$。

```cpp
#include<bits/stdc++.h>
#define ll long long 

#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=1e5+10;
int r,n,m,q,a[MAXN];
ll lstt[MAXN],lstk[MAXN],lstx[MAXN];
namespace DS{
	const int MAXM=1e7+10;
	#define mid (l+r>>1)
	struct Seg {int k;ll b;bool op;ll f(ll x) {return k*x+b;}}t[MAXM];
	int ls[MAXM],rs[MAXM],tot;
	void update(int &u,int l,int r,int x,int y,Seg sg) {
		if(x>y) return ;
		if(!u) u=++tot;
		if(x<=l&&r<=y) {
			if(!t[u].op) return t[u]=sg,void();
			if(t[u].f(mid)<sg.f(mid)) swap(t[u],sg);
			if(l==r) return ;
			if(t[u].k>sg.k) update(ls[u],l,mid,x,y,sg);
			else update(rs[u],mid+1,r,x,y,sg);
			return ;
		}
		if(x<=mid) update(ls[u],l,mid,x,y,sg);
		if(y>mid) update(rs[u],mid+1,r,x,y,sg);
		return ;
	}	
	ll query(int u,int l,int r,int pos){
		ll ans=0;
		if(!u) return 0;
		if(t[u].op) ans=max(ans,t[u].f(pos));
		if(l==r) return ans;
		if(pos<=mid) return max(ans,query(ls[u],l,mid,pos));
		else return max(query(rs[u],mid+1,r,pos),ans);
	}
};
vector<int> qr;
signed main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>n>>m;
	ffor(i,1,n) cin>>a[i],lstx[i]=a[i];
	ffor(i,1,m) {
		int t; string S;
		cin>>t>>S;
		if(S=="command") {
			int id;ll nv;
			cin>>id>>nv;
			//lstt[id]~t-1
			DS::update(r,0,1000000000,lstt[id],t-1,{lstk[id],lstx[id]-1ll*lstt[id]*lstk[id],1});
			DS::update(r,0,1000000000,lstt[id],t-1,{-lstk[id],-lstx[id]+1ll*lstt[id]*lstk[id],1});
			lstx[id]+=(t-lstt[id])*lstk[id],lstt[id]=t,lstk[id]=nv;
		}
		else qr.push_back(t);
	}
	ffor(id,1,n) {
		int t=1000000000;
		DS::update(r,0,1000000000,lstt[id],t-1,{lstk[id],lstx[id]-1ll*lstt[id]*lstk[id],1});
		DS::update(r,0,1000000000,lstt[id],t-1,{-lstk[id],-lstx[id]+1ll*lstt[id]*lstk[id],1});	
	}
	for(auto id:qr) cout<<DS::query(r,0,1000000000,id)<<'\n';
	return 0;
}
```

---


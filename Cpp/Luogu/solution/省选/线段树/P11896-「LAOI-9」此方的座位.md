# 「LAOI-9」此方的座位

## 题目描述

此方在餐厅吃饭，他发现旁边的人发出了很大的噪声。

对于每个座位 $k$ 发出的噪声，$i$ 位置接收到的噪声为 $\max(0,j-a_k\times\operatorname{abs}(i-k))$，$a_k$ 为噪声的衰退系数，$j$ 为初始噪声，具体定义见下文。

对于每个位置受到的噪声，为所有位置发出噪声到达这个位置后的**最大值**。

但是，管理人员为了减少噪声，在一些地方修建了降噪设备，如果一个位置 $i$ 满足 $b_i=1$，那么这个位置初始有一个降噪设备。而对于降噪设备，在噪声**到达**其**左边第一个和右边第一个**遇见的降噪设备后，衰退系数会变为原来的 $2$ 倍。形式化地，设对于位置 $k$ 传达到位置 $i$ 接触到的**第一个**降噪设备位置为 $x$，那么位置 $i$ 接收到的噪声为 $\max(0,j-a_k\times\operatorname{abs}(k-x)-2a_k\times\operatorname{abs}(i-x))$。

**注意：一个降噪设备只会影响到它修建后产生的噪声**。

降噪设备有一个不足，就是如果降噪设备的位置发出了噪声，那么该位置的降噪设备会被**立刻摧毁**，即不会对这次和以后发出的噪声产生效果。

所以，在某些时刻，管理人员会在一些位置上新增修建降噪设备。

现在在 $m$ 个单位时间内，每个时间可能发生三种事件。

+ 输入格式为 `1 i j`，代表 $i$ 座位的人发出了响度 $j$ 的声音。

+ 输入格式为 `2 i`，代表求 $i$ 座位的人受到的噪声。

+ 输入格式为 `3 i`，代表管理人员在位置 $i$ 上新增修建了一个降噪设备，如果这个位置原来就有降噪设备，则本次操作无效。当然，因为一个降噪设备只会影响到它修建后产生的噪声，所以在一个曾发出噪声的位置新增修建降噪设备，不会使得这个降噪设备被立即摧毁。

## 说明/提示

### 样例解释

对于前 $2$ 个样例，变化后的输入与原输入相同。

对于第 $1$ 个样例，唯一的贡献来自于位置 $1$ 产生的 $5$ 点噪音，到达位置 $3$ 时的噪音为 $\max(0,5-(3-1)\times 1)=3$。

**本题目采用捆绑测试**。

| 子任务编号 | $n\le$ | 特殊性质 | 分值 |
| :----------: | :----------: | :----------: | :----------: |
| $0$ | $2\times 10^3$ | 无 | $15$ |
| $1$ | $10^5$ | 任何时刻没有降噪设备 | $20$ |
| $2$ | $10^5$ | 没有操作 $3$ | $10$ |
| $3$ | $10^5$ | 所有 $a_i$ 均相同 | $15$ |
| $4$ | $10^5$ | 无 | $40$ |

对于 $100\%$ 的数据，满足 $1\le n,m\le 10^5,1\le a_i\le 10^9,b_i\in\{0,1\},1\le i\le n,1\le j\le 10^9$。

## 样例 #1

### 输入

```
3 2
1 1 1
0 0 0
1 1 5
2 3```

### 输出

```
3```

## 样例 #2

### 输入

```
5 5
1 2 3 4 1
1 1 0 0 1
1 1 6
1 2 8
3 1
1 1 10
2 5```

### 输出

```
6```

## 样例 #3

### 输入

```
8 5
1 2 2 1 1 2 3 1
0 0 0 0 0 0 0 0
1 1 3
2 3
3 2
1 2 4
2 5```

### 输出

```
1
0```

# 题解

## 作者：Little_Cancel_Sunny (赞：4)

## 题解：P11896 「LAOI-9」此方的座位

### 前置知识

李超线段树，线段树。

### 思路

其实和板子没什么差别，就是多了一个降噪设备。

考虑这个降噪设备的影响，不难发现它不过就是增加了线段的斜率，看个图。

![](https://cdn.luogu.com.cn/upload/image_hosting/i54e5l9g.png)

所以对于一个点发出的噪声，如果有降噪设备的存在，不过就是我们需要多维护一两条线段而已。

对于左右的最近的两个降噪设备，直接线段树维护即可。

然后就可以利用找到的左右端点确定所有线段的形状，然后直接求解即可。

### tips

1. 答案至少为 $0$。
2. 是线段！！！

### 代码

```cpp
#include<bits/stdc++.h>
#define lson k<<1
#define rson k<<1|1
#define int long long 
using namespace std;

const int N=1e6+15;
const int inf=1e18;

struct line
{
	int k,b;
	int l,r;
	int get_y(int x)
	{
		if(x>=l&&x<=r)
			return k*x+b;
		return -inf;
	}
}li[N];
struct segment_tree
{
	int lans,rans;
}t[N];
struct lc_segment_tree
{
	int id;
}lt[N];
bool fl[N];
int a[N];
int lastans,n,m,cnt;

void push_up(int k)
{
	t[k].lans=min(t[lson].lans,t[rson].lans);
	t[k].rans=max(t[lson].rans,t[rson].rans);
}

void build(int k,int l,int r)
{
	if(l==r)
	{
		if(fl[l])
			t[k].lans=t[k].rans=l;
		else 
			t[k].lans=inf,t[k].rans=-inf;
		return;
	}
	int mid=(l+r)>>1;
	build(lson,l,mid);
	build(rson,mid+1,r);
	push_up(k);
}

void update_p(int k,int l,int r,int loc,int x)
{
	if(l==r)
	{
		if(x)
			t[k].lans=t[k].rans=l;
		else 
			t[k].lans=inf,t[k].rans=-inf;
		return;
	}
	int mid=(l+r)>>1;
	if(loc<=mid)
		update_p(lson,l,mid,loc,x);
	else 
		update_p(rson,mid+1,r,loc,x);
	push_up(k);
}

int query_l(int k,int l,int r,int ln,int rn)
{
	if(l>=ln&&r<=rn)
		return t[k].rans;
	int mid=(l+r)>>1;
	if(rn<=mid)
		return query_l(lson,l,mid,ln,rn);
	else if(ln>mid)
		return query_l(rson,mid+1,r,ln,rn);
	else 
		return max(query_l(lson,l,mid,ln,rn),query_l(rson,mid+1,r,ln,rn));
}

int query_r(int k,int l,int r,int ln,int rn)
{
	if(l>=ln&&r<=rn)
		return t[k].lans;
	int mid=(l+r)>>1;
	if(rn<=mid)
		return query_r(lson,l,mid,ln,rn);
	else if(ln>mid)
		return query_r(rson,mid+1,r,ln,rn);
	else 
		return min(query_r(lson,l,mid,ln,rn),query_r(rson,mid+1,r,ln,rn));
}

void update(int k,int l,int r,int ln,int rn,int loc)
{
	int mid=(l+r)>>1;
	if(l>=ln&&r<=rn)
	{
		if(!lt[k].id)
		{
			lt[k].id=loc;
			return;
		}
//		cout<<"location "<<loc<<" "<<l<<" "<<r<<endl;
		if(li[lt[k].id].get_y(mid)<li[loc].get_y(mid))
			swap(lt[k].id,loc);
		if(li[lt[k].id].get_y(l)<li[loc].get_y(l))
			update(lson,l,mid,ln,rn,loc);
		if(li[lt[k].id].get_y(r)<li[loc].get_y(r))
			update(rson,mid+1,r,ln,rn,loc);
	}
	else 
	{
		if(rn<=mid)
			update(lson,l,mid,ln,rn,loc);
		else if(ln>mid)
			update(rson,mid+1,r,ln,rn,loc);
		else 
			update(lson,l,mid,ln,rn,loc),update(rson,mid+1,r,ln,rn,loc);
	}
}

int query(int k,int l,int r,int loc)
{
	int res=-inf;
	if(lt[k].id)
		res=li[lt[k].id].get_y(loc);
//	cout<<lt[k].id<<endl;
	if(l==r)
		return res;
	int mid=(l+r)>>1;
	if(loc<=mid)
		return max(res,query(lson,l,mid,loc));
	else 
		return max(res,query(rson,mid+1,r,loc));
}

signed main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)
		cin>>a[i];
	for(int i=1;i<=n;i++)
		cin>>fl[i];
	build(1,1,n);
	while(m--)
	{
		int opt,i,j;
		cin>>opt>>i;
		i=(i+lastans-1)%n+1;
		if(opt==1)
		{
			cin>>j;
//			j=(j+lastans-1)%n+1;
			update_p(1,1,n,i,0);
			int l=query_l(1,1,n,1,i);
			int r=query_r(1,1,n,i,n);
//			cout<<"l is "<<l<<endl;
//			cout<<"r is "<<r<<endl;
			li[++cnt]={a[i],j-(i)*a[i],max(1ll,l),i};
//			cout<<li[cnt].k<<" "<<li[cnt].b<<" "<<li[cnt].l<<" "<<li[cnt].r<<endl;
			update(1,1,n,li[cnt].l,li[cnt].r,cnt);
			li[++cnt]={-a[i],j+(i)*a[i],i,min(r,n)};
//			cout<<li[cnt].k<<" "<<li[cnt].b<<" "<<li[cnt].l<<" "<<li[cnt].r<<endl;
			update(1,1,n,li[cnt].l,li[cnt].r,cnt);
			if(l!=-inf)
			{
				li[++cnt]={2*a[i],j-(i-l)*a[i]-(l)*2*a[i],1,l};
//				cout<<li[cnt].k<<" "<<li[cnt].b<<" "<<li[cnt].l<<" "<<li[cnt].r<<endl;
				update(1,1,n,li[cnt].l,li[cnt].r,cnt);
			}
			if(r!=inf)
			{
				li[++cnt]={-2*a[i],j-(r-i)*a[i]+(r)*2*a[i],r,n};
//				cout<<li[cnt].k<<" "<<li[cnt].b<<" "<<li[cnt].l<<" "<<li[cnt].r<<endl;
				update(1,1,n,li[cnt].l,li[cnt].r,cnt);
			}
		}
		else if(opt==2)
		{
			lastans=max(query(1,1,n,i),0ll);
			cout<<lastans<<endl;
		}
		else 
			update_p(1,1,n,i,1);
	}
	return 0;
}
```

---

## 作者：zxh923 (赞：3)

先转化一下题意：

+ 操作 $1$：插入两条线段（这里忽略了降噪设备），形状如下图。

![](https://cdn.luogu.com.cn/upload/image_hosting/awp7nv5b.png)

+ 操作 $2$：对于所有经过 $i$ 位置的线段，查找这些线段的纵坐标最大值。

+ 操作 $3$：把操作 $1$ 中的线段变成下图这样。

![](https://cdn.luogu.com.cn/upload/image_hosting/05f2v1x4.png)

### 暴力

每次插入线段时，扫一遍所有位置进行更新；每次修建降噪设备时，更新所有线段。

这样做的时间复杂度是 $O(nm)$，可能比较考验代码能力。

### 正解

注意到线段可以使用李超线段树进行维护。而如果没有降噪设备，就是板子题。

考虑怎么处理降噪设备，只需要用平衡树（set）维护现有降噪设备的位置，然后在插入线段的时候找到插入位置的前驱和后继，并分成若干条线段插入李超线段树即可。

注意发出噪声的时候要拆除当前位置的降噪设备。

时间复杂度 $O(q\log^2 n)$。

### 代码

这里由于出题人当时比较幽默，所以写的平衡树（当然用 set 会好写很多）。

```
#include<bits/stdc++.h>
#define int long long
#define N 400005
#define mod 998244353
#define inf 2e18
#define eps 1e-8
using namespace std;
struct tree{
	int lc,rc,siz,v,da;
}w[N];
struct line{
	int beg;
	double k,b;
}a[N];
struct node{
	int ls,rs,id;
}tr[N<<2];
int n,m,cnt,np,root,rt,da,res,las,tot;
void pushup(int u){
	w[u].siz=w[w[u].lc].siz+w[w[u].rc].siz+1;
}
void rig(int &p){
	int q=w[p].lc;
	w[p].lc=w[q].rc;
	w[q].rc=p;
	w[q].siz=w[p].siz;
	pushup(p);
	p=q;
}
void lef(int &p){
	int q=w[p].rc;
	w[p].rc=w[q].lc;
	w[q].lc=p;
	w[q].siz=w[p].siz;
	pushup(p);
	p=q;
}
void ins(int &p,int da){
	if(!p){
		p=++np;
		w[p].siz=1;
		w[p].da=da;
		w[p].v=rand()*rand()%mod;
		return;
	}
	w[p].siz++;
	if(da>=w[p].da)ins(w[p].rc,da);
	else ins(w[p].lc,da);
	if(w[p].lc&&w[p].v>w[w[p].lc].v)rig(p);
	if(w[p].rc&&w[p].v>w[w[p].rc].v)lef(p);
	pushup(p);
}
void del(int &p,int da){
	w[p].siz--;
	if(w[p].da==da){
		if(!w[p].lc&&!w[p].rc){
			p=0;
			return;
		}
		if(!w[p].lc||!w[p].rc){
			p=w[p].lc+w[p].rc;
			return;
		}
		if(w[w[p].lc].v<w[w[p].rc].v){
			rig(p);
			del(w[p].rc,da);
			return;
		}
		else{
			lef(p);
			del(w[p].lc,da);
			return;
		}
	}
	if(w[p].da>=da)del(w[p].lc,da);
	else del(w[p].rc,da);
	pushup(p);
}
int pre(int p,int da){
	if(!p)return 0;
	if(w[p].da>=da)return pre(w[p].lc,da);
	int tmp=pre(w[p].rc,da);
	if(!tmp)return w[p].da;
	return tmp;
}
int nex(int p,int da){
	if(!p)return 0;
	if(w[p].da<=da)return nex(w[p].rc,da);
	int tmp=nex(w[p].lc,da);
	if(!tmp)return w[p].da;
	return tmp;
}
bool check(int i,int j,int x){
	if(a[i].k*x+a[i].b-a[j].k*x-a[j].b>eps)return 1;
	if(a[j].k*x+a[j].b-a[i].k*x-a[i].b>eps)return 0;
	return i<j;
}
void modify(int &u,int l,int r,int L,int R,int now){
	if(l>R||r<L)return;
	if(!u)u=++cnt;
	if(l>=L&&r<=R){
		if(check(now,tr[u].id,l)&&check(now,tr[u].id,r)){
			tr[u].id=now;
			return;
		}
		if(check(tr[u].id,now,l)&&check(tr[u].id,now,r)){
			return;
		}
		int mid=l+r>>1;
		if(check(now,tr[u].id,mid)){
			swap(now,tr[u].id);
		}
		if(check(now,tr[u].id,l)){
			modify(tr[u].ls,l,mid,L,R,now);
		}
		if(check(now,tr[u].id,r)){
			modify(tr[u].rs,mid+1,r,L,R,now);
		}
	}
	else{
		int mid=l+r>>1;
		modify(tr[u].ls,l,mid,L,R,now);
		modify(tr[u].rs,mid+1,r,L,R,now);
	}
}
void solve(int u,int l,int r,int p){
	if(!u||r<p||l>p)return;
	if(check(tr[u].id,res,p)){
		res=tr[u].id;
	}
	if(l==r)return;
	int mid=l+r>>1;
	solve(tr[u].ls,l,mid,p);
	solve(tr[u].rs,mid+1,r,p);
}
int down[N],flag[N];
signed main(){
	srand(20090923);
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>down[i];
	}
	for(int i=1;i<=n;i++){
		cin>>flag[i];
		if(flag[i]==1){
			ins(root,i);
		}
	}
	ins(root,-inf);
	ins(root,inf);
	while(m--){
		int op;
		cin>>op;
		if(op==1){
			int x,y;
			cin>>x>>y;
			x=(x+las-1)%n+1;
			if(flag[x]){
				flag[x]=0;
				del(root,x);
			}
			int fro,bac;
			fro=pre(root,x);
			bac=nex(root,x);
			if(fro!=-inf){
				int pos=y-(x-fro)*down[x];
				a[++tot]={fro,down[x],y-down[x]*x};
				modify(rt,1,mod,fro,x,tot);
				a[++tot]={1,down[x]*2,pos-down[x]*2*fro};
				modify(rt,1,mod,1,fro,tot);
			}
			else{
				int pos=y-(x-1)*down[x];
				a[++tot]={1,down[x],y-down[x]*x};
				modify(rt,1,mod,1,x,tot);
			}
			if(bac!=inf){
				int pos=y-(bac-x)*down[x];
				a[++tot]={x,-down[x],y+down[x]*x};
				modify(rt,1,mod,x,bac,tot);
				a[++tot]={bac,-down[x]*2,pos+down[x]*2*bac};
				modify(rt,1,mod,bac,n,tot);
			}
			else{
				int pos=y-(bac-x)*down[x];
				a[++tot]={x,-down[x],y+down[x]*x};
				modify(rt,1,mod,x,n,tot);
			}
		}
		else if(op==2){
			int x;
			cin>>x;
			x=(x+las-1)%n+1;
			res=0;
			solve(1,1,mod,x);
			las=max(0.0,a[res].b+x*a[res].k);
			cout<<las<<'\n';
		}
		else{
			int x;
			cin>>x;
			x=(x+las-1)%n+1;
			if(flag[x]==1)continue;
			ins(root,x);
			flag[x]=1;
		}
	}
	return 0;
}
```

---

## 作者：wwt100127 (赞：0)

## **前置知识：**
[李超线段树](https://www.luogu.com.cn/problem/P4097)。

## 本题思路
显然发出的噪音就是两段线段。

首先考虑**没有降噪设备**的时候怎么做。

发现其实就是李超线段树板子题（甚至只有没有精度差）。

加上降噪设备之后，每段线段就会再次“分裂”（~~就像光的折射一样~~），变成两条线段。

仍然是板子题。

降噪设备用 $set$ 维护即可。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
bool Beginning;

#define pb(x) push_back(x)
#define mp(x,y) make_pair(x,y)
#define se second
#define fi first
using PII=pair<int,int>;
using PIB=pair<int,bool>;
using PBI=pair<bool,int>;
using PBB=pair<bool,bool>;
using PDI=pair<double,int>;
using PID=pair<int,double>;

namespace Memory_Love{
	int read(){ int x=0; bool flag=1; char ch=getchar();
		while(ch<'0' || ch>'9'){if(ch=='-') flag=0; ch=getchar();}
		while(ch>='0' && ch<='9'){x=(x<<3)+(x<<1)+(ch^48);ch=getchar();} return flag? x:-x;}
	template<typename T> void read(T &x){ bool flag=1; x=0; char ch=getchar();
		while(ch<'0' || ch>'9'){if(ch=='-') flag=0; ch=getchar();}
		while(ch>='0' && ch<='9'){x=(x<<3)+(x<<1)+(ch^48);ch=getchar();} x=(flag? x:-x);}
	template<typename T,typename ...Args> void read(T &Re,Args &...Res){read(Re),read(Res...);}
	template<typename T> void write(T x,char ch=0){if(x<0) x=-x,putchar('-');
		static short s[35],top=-1; do{s[++top]=x%10;x/=10;}while(x);
		while(~top) putchar(s[top--]+48); if(ch) putchar(ch);}
	int gcd(int a,int b){return b==0? a:gcd(b,a%b);}
	int lcm(int a,int b){return a/gcd(a,b)*b;}
	int lowbit(int x){return (x&-x);}
} using namespace Memory_Love;
const int N=1e5+5;
const int INF=0x3f3f3f3f3f3f3f3fll;
int n,m,a[N];
set<int> S;

#define Tree(u) tree[u]
#define Point(u) LINE[u]
#define F(u,x) Point(u).f(x)
#define lson(u) (u<<1)
#define rson(u) (u<<1|1)
#define mid (left+right>>1) 
struct Line
{
	int k,b;
	Line(int K=0,int B=0){k=K,b=B;}
	int f(int x){return k*x+b;}
	bool friend operator !=(const Line &a,const Line &b){return a.k!=b.k || a.b!=b.b;}
};
struct Segment_Tree
{
	Line LINE[N<<2];
	int tree[N<<2],tot;
	Line New_Line(double k,double b){return Line(k,b);}
	bool comp(int x,int y,int pos){return F(x,pos)>F(y,pos);}
	PII Max(PII a,PII b){return a.fi>b.fi? a:b;}
	void addtag(int u,int left,int right,int x)
	{
		int &y=Tree(u);
		if(comp(x,y,mid)) swap(x,y);
		if(comp(x,y,left)) addtag(lson(u),left,mid,x);
		if(comp(x,y,right)) addtag(rson(u),mid+1,right,x);
	}
	void update(int u,int L,int R,int x,int left=1,int right=n)
	{
		if(L<=left && R>=right)
		return addtag(u,left,right,x);
		if(L<=mid) update(lson(u),L,R,x,left,mid);
		if(R>mid)  update(rson(u),L,R,x,mid+1,right);
	}
	void insert_Pre(int x,int xx,int yy,double k)
	{
		int b=yy-k*xx;
		Point(++tot)=New_Line(k,b);
		return update(1,x,xx,tot);
	}
	void insert_Nex(int x,int y,int xx,double k)
	{
		int b=y-k*x;
		Point(++tot)=New_Line(k,b);
		return update(1,x,xx,tot);
	}
	PII query(int u,int x,int left=1,int right=n)
	{
		if(left==right)
		return mp(F(Tree(u),x),Tree(u));
		PDI ans=mp(F(Tree(u),x),Tree(u));
		if(x<=mid) ans=Max(ans,query(lson(u),x,left,mid));
		else ans=Max(ans,query(rson(u),x,mid+1,right));
		return ans;
	}
}ST;

void solve(int x,int y)
{
	if(S.find(x)!=S.end()) S.erase(x);
	
	int Pre=(*--S.lower_bound(x));
	int Nex=(*S.upper_bound(x));
	
	if(Pre==-INF)
	ST.insert_Pre(1,x,y,a[x]);
	else
	{
		ST.insert_Pre(Pre,x,y,a[x]);
		ST.insert_Pre(1,Pre,y-a[x]*(x-Pre),a[x]*2);
	}
	
	if(Nex==INF)
	ST.insert_Nex(x,y,n,-a[x]);
	else
	{
		ST.insert_Nex(x,y,Nex,-a[x]);
		ST.insert_Nex(Nex,y-a[x]*(Nex-x),n,-a[x]*2);
	}
}

bool Ending;
signed main()
{
	int i,kind,x,y,last_ans=0;
	read(n,m);
	S.insert(-INF),S.insert(INF);
	for(i=1;i<=n;i++) a[i]=read();
	for(i=1;i<=n;i++)
	{
		x=read();
		if(x) S.insert(i);
	}
	while(m--)
	{
		read(kind,x);
		x=(x+last_ans-1)%n+1;
		if(kind==1)
		{
			y=read();
			solve(x,y);
		}
		if(kind==2) write(last_ans=max(ST.query(1,x).fi,0ll),'\n');
		if(kind==3) S.insert(x);
	}
	
	cerr<<"\nused:"<<(abs(&Ending-&Beginning)/1048576)<<"MB\n";
	return 0;
}
```

---


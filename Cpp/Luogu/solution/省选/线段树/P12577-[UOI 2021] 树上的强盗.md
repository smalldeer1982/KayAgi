# [UOI 2021] 树上的强盗

## 题目描述

有 $n$ 个城市，编号从 $1$ 到 $n$。所有城市通过 $n-1$ 条道路连接，形成一个连通图。每条道路都有特定的长度。

已知编号为 $i$ 的城市在时间 $t_i$ 被编号为 $a_i$ 的强盗团伙占领（$1 \leq a_i \leq n$）。从被占领的时刻 $t_i$ 开始（包括 $t_i$ 时刻），只有 $a_i$ 号团伙的成员才能通过该城市。

你需要回答 $m$ 个如下形式的查询：

- `u v b T`：判断编号为 $b$ 的团伙成员能否在时间 $T$ 从城市 $u$ 前往城市 $v$。如果无法完成旅程，还需要输出路径上第一个无法通过的城市编号。在城市间移动需要花费时间，时间等于路的长度。


## 说明/提示

### 评分标准

1. （$7$ 分）：所有 $p_i = 1$；
2. （$9$ 分）：$n, m \leq 10^3$；
3. （$11$ 分）：$p_i = i-1$，$t_i = 1$；
4. （$18$ 分）：$p_i = i-1$，$a_i = 1$，$b_i = 2$；
5. （$15$ 分）：$p_i = i-1$；
6. （$11$ 分）：$t_i = 1$；
7. （$17$ 分）：$a_i = 1$，$b_i = 2$；
8. （$12$ 分）：无额外限制。

翻译由 DeepSeek V3 完成

## 样例 #1

### 输入

```
5
1 7
1 3
2 2
2 1
1 1 2 3 3
10 4 15 15 1
8
5 3 3 1
5 3 3 2
5 3 3 3
5 3 1 1
4 3 1 2
4 3 1 3
3 4 1 3
2 1 1 100```

### 输出

```
-1
1
2
5
-1
3
4
-1```

## 样例 #2

### 输入

```
5
1 4
1 1
1 1
1 4
3 2 2 2 2
4 4 6 7 5
5
5 2 4 7
1 1 1 3
4 2 1 9
1 4 3 7
3 4 2 4```

### 输出

```
5
-1
4
4
1```

## 样例 #3

### 输入

```
5
1 4
2 1
3 3
4 1
2 1 2 3 2
8 3 7 7 9
5
1 5 2 4
1 2 1 4
5 2 1 6
1 4 3 5
1 5 4 7```

### 输出

```
2
-1
4
2
2```

# 题解

## 作者：Shunpower (赞：0)

来点暴力。

考虑把路径拆成两半分开做，我们本质上是想查一条直上直下路径上第一个点 $i$ 满足（这里的例子是向上）：

$$
a_i\ne a_Q\\
T_Q+dis_u-dis_i\ge t_i
$$

$dis$ 表示根到某个点的距离。向下的一侧 $dis_u-dis_i$ 是反过来的。

这个问题直接搞比较难做，考虑拆开第一个条件变成 $a_i<a_Q$ 和 $a_Q<a_i$ 做两遍再取较近的一个。这样相当于一个询问有四块问题，每个是找一条直上直下路径上满足某个二维偏序的最近点。我们直接离线第一维比较简单的颜色，然后树剖用线段树维护第二维，查询时二分即可。

直接朴素树剖套线段树上二分会产生 3log。但是这里的二分非常朴实无华，就是查左或右第一个小于等于某个定值的位置。所以可以用 1log 的线段树上二分来写，这样就做到 2log 了。

做法很暴力，常数略大，但是能过。不知道为什么跑得还比 @lzyqwq 老哥的有脑子做法快，可能是树剖太厉害了。

```cpp
int n,m;
vector <pii> p[N];
int c[N],t[N];
vector <int> col[N];
struct queries{
    int u,v,col;
    ll T;
    bool up;
    int id;
} Q[N<<1];
int tqt;
vector <int> ans[N];
int tot;
int dep[N],siz[N],dfn[N],bac[N],top[N],hson[N];
ll wu[N],wd[N];
ll dis[N];
int f[N][18];
int U[N];
int LCA(int u,int v){
    if(dep[u]<dep[v]) swap(u,v);
    int k=dep[u]-dep[v];
    fr2(i,17,0){
        if(k>=(1<<i)) u=f[u][i],k-=(1<<i);
    }
    if(u==v) return u;
    fr2(i,17,0){
        if(f[u][i]!=f[v][i]){
            u=f[u][i];
            v=f[v][i];
        }
    }
    return f[u][0];
}
void dfs1(int x,int fa){
    f[x][0]=fa;
    wu[x]=t[x]+dis[x];
    wd[x]=t[x]-dis[x];
    siz[x]=1;
    dep[x]=dep[fa]+1;
    int idx=0;
    for(auto y:p[x]){
        if(y.fi==fa) continue;
        dis[y.fi]=dis[x]+y.se;
        dfs1(y.fi,x);
        siz[x]+=siz[y.fi];
        if(siz[y.fi]>siz[idx]) idx=y.fi;
    }
    hson[x]=idx;
}
void dfs2(int x,int tp,int fa){
    tot++;
    dfn[x]=tot,bac[tot]=x;
    top[x]=tp;
    if(hson[x]) dfs2(hson[x],tp,x);
    for(auto y:p[x]){
        if(y.fi==fa||y.fi==hson[x]) continue;
        dfs2(y.fi,y.fi,x);
    }
}
#define mid (l+r>>1)
struct SGT{
    ll minn[N<<2];
    void pushup(int p){
        minn[p]=min(minn[p<<1],minn[p<<1|1]);
    }
    void build(int p,int l,int r){
        minn[p]=4e18;
        if(l==r) return;
        build(p<<1,l,mid);
        build(p<<1|1,mid+1,r);
        pushup(p);
    }
    void insert(int p,int l,int r,int d,ll x){
        if(l==r) return minn[p]=x,void();
        if(d<=mid) insert(p<<1,l,mid,d,x);
        else insert(p<<1|1,mid+1,r,d,x);
        pushup(p);
    }
    int lefbinary(int p,int l,int r,int T){
        if(minn[p]>T) return -1;
        if(l==r) return l;
        if(minn[p<<1]<=T) return lefbinary(p<<1,l,mid,T);
        else return lefbinary(p<<1|1,mid+1,r,T);
    }
    int rigbinary(int p,int l,int r,int T){
        if(minn[p]>T) return -1;
        if(l==r) return l;
        if(minn[p<<1|1]<=T) return rigbinary(p<<1|1,mid+1,r,T);
        else return rigbinary(p<<1,l,mid,T);
    }
    vector <pair<int,pii>> segs;
    void findsegs(int p,int l,int r,int ml,int mr){
        if(ml<=l&&r<=mr) return segs.push_back({p,{l,r}}),void();
        if(ml<=mid) findsegs(p<<1,l,mid,ml,mr);
        if(mid<mr) findsegs(p<<1|1,mid+1,r,ml,mr);
    }
    int LB(int l,int r,int T){
        segs.clear();
        findsegs(1,1,n,l,r);
        fr1(i,0,(int)segs.size()-1){
            if(minn[segs[i].fi]>T) continue;
            return lefbinary(segs[i].fi,segs[i].se.fi,segs[i].se.se,T);
        }
        return -1;
    }
    int RB(int l,int r,int T){
        segs.clear();
        findsegs(1,1,n,l,r);
        fr2(i,(int)segs.size()-1,0){
            if(minn[segs[i].fi]>T) continue;
            return rigbinary(segs[i].fi,segs[i].se.fi,segs[i].se.se,T);
        }
        return -1;
    }
} Tu,Td;
int Gfu(int u,int v,int T){
    while(top[u]!=top[v]){
        int x=Tu.RB(dfn[top[u]],dfn[u],T);
        if(x!=-1) return bac[x];
        u=f[top[u]][0];
    }
    int x=Tu.RB(dfn[v],dfn[u],T);
    if(x!=-1) return bac[x];
    return -1;
}
int Gfd(int u,int v,int T){
    int ans=-1;
    while(top[u]!=top[v]){
        int x=Td.LB(dfn[top[v]],dfn[v],T);
        if(x!=-1) ans=x;
        v=f[top[v]][0];
    }
    int x=Td.LB(dfn[u],dfn[v],T);
    if(x!=-1) ans=x;
    if(ans==-1) return -1;
    return bac[ans];
}
ll Dis(int u,int v){
    return dis[u]+dis[v]-2ll*dis[LCA(u,v)];
}
#undef mid
int main(){
#ifdef Ltp
    freopen("hack.txt","r",stdin);
    freopen("out.txt","w",stdout);
#endif
    ios::sync_with_stdio(false);
    cin>>n;
    fr1(i,2,n){
        int f,d;
        cin>>f>>d;
        p[f].pb(mp(i,d));
        p[i].pb(mp(f,d));
    }
    fr1(i,1,n) cin>>c[i],col[c[i]].pb(i);
    fr1(i,1,n) cin>>t[i];
    dfs1(1,1);
    dfs2(1,1,1);
    fr1(j,1,17) fr1(i,1,n) f[i][j]=f[f[i][j-1]][j-1];
    cin>>m;
    fr1(i,1,m){
        int u,v,b,t;
        cin>>u>>v>>b>>t;
        U[i]=u;
        int lca=LCA(u,v);
        tqt++;
        Q[tqt]={u,lca,b,t+dis[u],1,i};
        tqt++;
        Q[tqt]={lca,v,b,t+dis[u]-dis[lca]*2,0,i};
    }
    Tu.build(1,1,n);
    Td.build(1,1,n);
    sort(Q+1,Q+tqt+1,[](queries &x,queries &y){
        return x.col<y.col;
    });
    int poi=0;
    fr1(i,1,n){
        while(Q[poi+1].col<=i&&poi+1<=tqt){
            poi++;
            if(Q[poi].up){
                int x=Gfu(Q[poi].u,Q[poi].v,Q[poi].T);
                if(~x) ans[Q[poi].id].pb(x);
            }
            else{
                int x=Gfd(Q[poi].u,Q[poi].v,Q[poi].T);
                if(~x) ans[Q[poi].id].pb(x);
            }
        }
        // cerr<<"!"<<endl;
        for(auto j:col[i]){
            Tu.insert(1,1,n,dfn[j],wu[j]);
            Td.insert(1,1,n,dfn[j],wd[j]);
        }
    }
    Tu.build(1,1,n);
    Td.build(1,1,n);
    poi=tqt+1;
    fr2(i,n,1){
        while(Q[poi-1].col>=i&&poi-1>=1){
            poi--;
            if(Q[poi].up){
                int x=Gfu(Q[poi].u,Q[poi].v,Q[poi].T);
                if(~x) ans[Q[poi].id].pb(x);
            }
            else{
                int x=Gfd(Q[poi].u,Q[poi].v,Q[poi].T);
                if(~x) ans[Q[poi].id].pb(x);
            }
        }
        for(auto j:col[i]){
            Tu.insert(1,1,n,dfn[j],wu[j]);
            Td.insert(1,1,n,dfn[j],wd[j]);
        }
    }
    fr1(i,1,m){
        if(ans[i].empty()) cout<<-1<<'\n';
        else{
            sort(ans[i].begin(),ans[i].end(),[i](int &x,int &y){
                return Dis(U[i],x)<Dis(U[i],y);
            });
            cout<<ans[i][0]<<'\n';
        }
    }
    ET;
}
//ALL FOR Zhang Junhao.
```

---

## 作者：Reflection_Blue (赞：0)

下面只考虑 $v$ 是 $u$ 的祖先的情况，如果不是的话拆成两个查询（$u\rightarrow \operatorname{lca},\operatorname{lca} \rightarrow v$）即可。

如果不求第一个无法到达的点是好做的：设点 $u$ 的带权深度为 $d_u$，问题可以转化成求 $u\rightarrow v$ 路径上是否存在 $x$ 使得 $T+d_u-d_x\geq t_x\land a_x≠b$，这个直接倍增或者树剖，记录 $d_x+t_x$ 的最小值和颜色不同的次小值，查询时如果最小值颜色和 $b$ 不同就判最小值，否则判次小值即可。

考虑原题怎么做，实际上就是加一维限制，要求不带权的深度 $d'_x$ 最大（如果往下走就是最小）。先树剖，按 dfn 分成 $\log$ 个区间的问题，即求 $\max_{dfn_x\in [l,r],a_x≠b,d_x+t_x\leq d_u+T}\{d'_x\}$。这个直接做加上树剖是 $\log^3$ 的，把那个不等号在线段树维护时额外记录一下颜色，用前面的次小值技巧优化掉，时间复杂度就是 $\mathcal{O}(q\log^2n)$ 了。

~~轻松拿下锣鼓最优解。~~

---

## 作者：xxxxxzy (赞：0)

给个新做法，@lzyqwq 那个做法还是太需要脑子了。

题目大意略。我们表示一下可以从 $u$ 走到 $v$ 的条件，发现其实就是要求 $\displaystyle\bigcap_{i \in \text{path}(u, v)} ([T+\text{dist}(u,i) < t_i] \cup [a_i=b]) = 1$。

拆开 $\text{dist}(u,i)$，以 $1$ 为根，拆成 $dis_u + dis_i-2dis_{Lca}$。先考虑第一个式子。

大力分类讨论：

+ $u$ 为 $v$ 的祖先：那么 $i$ 必定是 $u$ 的后代，$\text{dist}(u,i)=dis_i - dis_u$，条件就转化为 $T+dis_i-dis_u<t_i$，变形得到 $T-dis_u<t_i-dis_i$。
+ $v$ 为 $u$ 的祖先，那么 $i$ 必定是 $u$ 的祖先，$\text{dist}=dis_u-dis_i$，条件为 $T+dis_u-dis_i<t_i$，变形得到 $T+dis_u<dis_i+t_i$。
+ $u,v$ 的 $lca$ 为 $L(u,v \ne L)$，那么进一步分类讨论，$(u,L)$ 段同第二种相同，剩下的 $(L,v)$，条件是 $T+dis_u + dis_i - 2dis_L < t_i$，转化得到 $T+dis_u-2dis_L < t_i-dis_i$。

考虑维护，会发现所有情况无乎是要求 $t_i - dis_i / t_i + dis_i$ 的最小值大于一个定值，于是开两棵线段树分开维护最小值。

再回头看一下第二个式子 $[a_i=b]$，这个简单，离线把 $a_i$ 相同的统一处理，处理的时候把 $t_i - dis_i / t_i + dis_i$ 设成 $\infty$ 即可。

最后再考虑输出第一个不能通过的城市，这个主要是实现问题，比较恶心。我的实现比较丑，先拆出来树剖的区间，再把线段树上的区间拆成若干个小区间，再二分找第一个小于等于常数的位置。

时间 $O(n \log^2 n)$，空间线性，跑得嘎嘎快在实现很丑且没有任何卡常下抢到最优解。题目本身简单但是这个傻逼实现我是再也不想写了。

https://www.luogu.com.cn/record/221186581。

---

## 作者：lzyqwq (赞：0)

> - 给出 $n$ 个点的树。边有边权。每个点有两个属性 $a_i,t_i$。
> - $q$ 次询问，每次给出 $u,v,b,T$，记 $p_1=u,\dots,p_k=v$ 为 $u$ 到 $v$ 的路径，你需要找到最小的 $i$，使得 $a_{p_i}\ne b$ 且 $T+\text{dis}(u,p_i)\ge t_i$。输出这个 $p_i$ 或报告不存在。
> - $n,q\le 10^5$。

你谷首杀。建议评紫。认为 $n,q$ 同阶。

以 $1$ 为根。首先考虑把 $\text{dis}(u,p_i)$ 的形式转化一下。记 $\text{anc}=\text{LCA}(u,v)$。将 $u\rightsquigarrow v$ 的路径拆分成 $u\rightsquigarrow \text{anc}$ 和 $\text{anc}\rightsquigarrow v$ 两部分。$\text{anc}$ 放在哪里都无所谓。记 $D_u$ 为 $u$ 到根路径的**边权和**。那么对于 $u\rightsquigarrow \text{anc}$ 上的 $p_i$ 而言 $\text{dis}(u,p_i)=D_u-D_{p_i}$，对于 $\text{anc}\rightsquigarrow v$ 上的 $p_i$ 而言 $\text{dis}(u,p_i)=D_u+D_{p_i}-2D_\text{anc}$。

以 $u\rightsquigarrow \text{anc}$ 为例。我们要找最靠前的点 $x$，使得 $a_x\ne b$ 且 $T+D_u\ge D_x+t_x$。重链剖分，按顺序考虑每一条重链（类似值域分块），先判断答案是否在重链内。判定某条重链上是否存在合法 $x$ 可以考虑求出合法点的个数，方法是，求出链上 $T+D_u\ge D_x+t_x$ 的点数，减去 $a_x=b$ 且 $T+D_u\ge D_x+t_x$ 的点数。形式是二维数点，考虑对全局和每种颜色开一个数据结构维护。

如果个数为 $0$，那么答案不在这条重链上，直接跳过，否则答案在重链上，考虑在其 dfn 区间上二分出答案的 dfn 序，判定方法一致，用区间内的个数减去区间内 $a_x=b$ 的个数即可。二分答案的时候要注意这条重链的方向是从 dfn 大的点走向 dfn 小的点还是相反。

$\text{anc}\rightsquigarrow v$ 的情况是同理的，形式也是二维数点。如果要在线则用主席树维护，时间复杂度 $\mathcal{O}\left(n\log^2n\right)$，空间复杂度 $\mathcal{O}(n\log n)$。但是我们有线性空间的做法。

考虑将询问离线，两部分分别考虑。同样以 $u\rightsquigarrow \text{anc}$ 为例。我们按照询问将 $T+D_u$ 排序，将点按 $t_x+D_x$ 排序。对全局和每种颜色用平衡树维护，按顺序扫询问，每个询问的时候新加入 $t_x+D_x\le T+D_u$ 的点，时间复杂度 $\mathcal{O}(n\log n)$。然后在这个基础上做询问即可。当然，考虑 $\text{anc}\rightsquigarrow v$ 的时候，如果这个询问已经在 $u\rightsquigarrow \text{anc}$ 的部分找到了答案就不需要再查询了。

当然我写的 `pb_ds` 平衡树常数比较大，最大点要 900ms。考虑一些常数较小的数据结构，但是我们不希望动态开点。事实上，由于每种颜色的点数之和是 $n$，我们可以对于每种颜色将点按 dfn 顺序排好，形成 $\mathcal{O}(n)$ 个长度总和为 $n$ 的序列。每个序列建立树状数组维护区间和。那么只需要将修改的位置和查询的区间映射到有序序列的下标和下标区间即可。容易二分实现。这样之后最大点来到 500ms。

总结一下，时间复杂度 $\mathcal{O}\left(n\log^2 n\right)$，空间复杂度 $\mathcal{O}(n)$。如果用诸如全局平衡二叉树或多叉线段树的更高级的数据结构可能可以做到更好的时间复杂度，但是没必要。我不知道另一个老哥重链剖分后写的什么做法，用的线段树还比我 BIT 快。可能我人傻常数大。

实现的时候需要注意重链的顺序，如果你是向上跳链并且每次往容器末尾插入一条新的重链的写法，对于 $u\rightsquigarrow \text{anc}$ 的链，容器中的顺序就是路径上的顺序；对于另一种情况，容器中的顺序是 $v\rightsquigarrow \text{anc}$ 的顺序，将其翻转才是 $\text{anc}\rightsquigarrow v$ 的顺序。同时还要考虑两个点跳到同一条重链上之后，她们之间的那一段重链归到哪部分考虑。如果你没有注意这些细节，可能会和我一样获得和陈亮舟 NOI2020 排名一样高的分数。

代码不是很难写。

```cpp
#include <bits/stdc++.h>
#define eb emplace_back
using namespace std; const int N = 100005;
int n, q, d[N], D[N], df[N], s[N], h[N], t[N], f[N], id[N], ans[N];
struct QR {
	int u, v, i, c, x, o;
	bool operator<(const QR &y) const { return x < y.x; }
} q1[N], q2[N];
struct ND { int x, u, t; } a[N]; vector<pair<int, int>> g[N], vc;
struct BIT {
	vector<int> a; int n;
	void U(int x, int v) { for (; x <= n; x += x & -x) a[x] += v; }
	int Q(int x) { int r = 0; for (; x; x -= x & -x) r += a[x]; return r; }
};
struct DS {
	vector<int> a; BIT t;
	void I() { t.a = vector<int>(a.size()); t.n = a.size() - 1; }
	void U(int x) { t.U(lower_bound(a.begin(), a.end(), x) - a.begin(), 1); }
	int Q(int l, int r) {
		return t.Q(upper_bound(a.begin(), a.end(), r) - a.begin() - 1) -
		       t.Q(lower_bound(a.begin(), a.end(), l) - a.begin() - 1);
	}
} ds[N];
void d1(int u) {
	s[u] = 1;
	for (auto [v, w] : g[u])
		if (v != f[u]) {
			d[v] = d[u] + 1; D[v] = D[u] + w; f[v] = u; d1(v);
			s[u] += s[v]; if (s[v] > s[h[u]]) h[u] = v;
		}
}
void d2(int u, int p) {
	df[u] = ++df[0]; id[df[0]] = u; t[u] = p; if (h[u]) d2(h[u], p);
	for (auto [v, w] : g[u]) if (v != h[u] && v != f[u]) d2(v, v);
}
int lca(int u, int v) {
	for (; t[u] != t[v]; u = f[t[u]]) if (d[t[u]] < d[t[v]]) swap(u, v);
	return d[u] > d[v] ? v : u;
}
int Q(int u, int v, int c, int o) {
	vc.clear();
	if (o) {
		while (t[u] != t[v])
			if (d[t[u]] > d[t[v]]) vc.eb(df[t[u]], df[u]), u = f[t[u]];
			else v = f[t[v]];
		if (d[u] > d[v]) vc.eb(df[v], df[u]);
		for (auto [l, r] : vc) {
			if (ds[0].Q(l, r) == ds[c].Q(l, r)) continue;
			int ql = l, qr = r, m, k;
			while (ql <= qr) {
				m = ql + qr >> 1;
				if (ds[0].Q(m, r) > ds[c].Q(m, r)) k = m, ql = m + 1;
				else qr = m - 1;
			}
			return id[k];
		}
	} else {
		while (t[u] != t[v])
			if (d[t[v]] > d[t[u]]) vc.eb(df[t[v]], df[v]), v = f[t[v]];
			else u = f[t[u]];
		if (d[u] <= d[v]) vc.eb(df[u], df[v]); reverse(vc.begin(), vc.end());
		for (auto [l, r] : vc) {
			if (ds[0].Q(l, r) == ds[c].Q(l, r)) continue;
			int ql = l, qr = r, m, k;
			while (ql <= qr) {
				m = ql + qr >> 1;
				if (ds[0].Q(l, m) > ds[c].Q(l, m)) k = m, qr = m - 1;
				else ql = m + 1;
			}
			return id[k];
		}
	}
	return -1;
}
int main() {
	scanf("%d", &n);
	for (int i = 2, p, d; i <= n; ++i)
		scanf("%d%d", &p, &d), g[p].eb(i, d), g[i].eb(p, d);
	for (int i = 1; i <= n; ++i) scanf("%d", &a[i].x), a[i].u = i;
	for (int i = 1; i <= n; ++i) scanf("%d", &a[i].t); d1(1); d2(1, 1);
	scanf("%d", &q); for (int i = 0; i <= n; ++i) ds[i].a.eb(0);
	for (int i = 1, u, v, c, T, x; i <= q; ++i)
		scanf("%d%d%d%d", &u, &v, &c, &T), x = lca(u, v),
		q1[i] = {u, v, i, c, T + D[u]}, ans[i] = -1,
		q2[i] = {u, v, i, c, T + D[u] - (D[x] << 1)};
	for (int i = 1; i <= n; ++i) ds[a[id[i]].x].a.eb(i), ds[0].a.eb(i);
	for (int i = 0; i <= n; ++i) ds[i].I();
	stable_sort(q1 + 1, q1 + q + 1); stable_sort(q2 + 1, q2 + q + 1);
	stable_sort(a + 1, a + n + 1, [&](ND i, ND j) {
		return i.t + D[i.u] < j.t + D[j.u];
	});
	for (int i = 1, j = 1; i <= q; ++i) {
		for (; j <= n && a[j].t + D[a[j].u] <= q1[i].x; ++j)
			ds[0].U(df[a[j].u]), ds[a[j].x].U(df[a[j].u]);
		ans[q1[i].i] = Q(q1[i].u, q1[i].v, q1[i].c, 1);
	}
	stable_sort(a + 1, a + n + 1, [&](ND i, ND j) {
		return i.t - D[i.u] < j.t - D[j.u];
	});
	for (int i = 0; i <= n; ++i) ds[i].I();
	for (int i = 1, j = 1; i <= q; ++i) {
		if (ans[q2[i].i] != -1) continue;
		for (; j <= n && a[j].t - D[a[j].u] <= q2[i].x; ++j)
			ds[0].U(df[a[j].u]), ds[a[j].x].U(df[a[j].u]);
		ans[q2[i].i] = Q(q2[i].u, q2[i].v, q2[i].c, 0);
	}
	for (int i = 1; i <= q; ++i) printf("%d\n", ans[i]); return 0;
}
```

---


# [UOI 2021] 敌人与军刀

## 题目描述

哥萨克 Vus 来到营地拜访一位朋友，这位朋友在自己的工坊里开始锻造军刀。朋友已经锻造了 $n$ 把军刀，其中第 $i$ 把军刀有两个参数——长度和锋利度，分别记为 $a_i$ 和 $b_i$，同时第 $i$ 把军刀的价格为 $cost_i$ 卢布。

最近，营地里出现了 $m$ 个敌人。首领为每个敌人提供了悬赏——抓住第 $j$ 个敌人可以获得 $profit_j$ 卢布的奖励。但不同的敌人也有不同的护甲参数——厚度和强度，分别记为 $c_j$ 和 $d_j$。

要抓住敌人，必须击穿他的护甲。为此需要一把军刀，其长度不小于护甲的厚度，且锋利度不小于护甲的强度。形式化地说，用第 $i$ 把军刀可以抓住第 $j$ 个敌人，当且仅当同时满足以下两个条件：$a_i \geq c_j$ 且 $b_i \geq d_j$。

哥萨克 Vus 想知道他最多能赚取多少卢布，以便决定是否值得从事如此危险的工作，并请你帮忙。

请注意，营地里可以赊账，因此哥萨克 Vus 在某些时刻可能拥有负数的卢布。此外，哥萨克 Vus 可以用同一把军刀抓住多个敌人。

## 说明/提示

### 评分标准

- （13 分）：对于任意两个不同的敌人 $(i,j)$，要么 $c_i > c_j$，要么 $d_i > d_j$，即不存在一个敌人其护甲的两个参数均不劣于另一个敌人；$n, m \leq 5\,000$；
- （10 分）：对于任意两个不同的敌人 $(i,j)$，要么 $c_i > c_j$，要么 $d_i > d_j$，即不存在一个敌人其护甲的两个参数均不劣于另一个敌人；$n, m \leq 10^5$；
- （13 分）：对于任意两把不同的军刀 $(i,j)$，要么 $a_i > a_j$，要么 $b_i > b_j$，即不存在一把军刀其攻击的两个参数均不劣于另一把军刀；$n, m \leq 5\,000$；
- （10 分）：对于任意两把不同的军刀 $(i,j)$，要么 $a_i > a_j$，要么 $b_i > b_j$，即不存在一把军刀其攻击的两个参数均不劣于另一把军刀；$n, m \leq 10^5$；
- （14 分）：$n, m \leq 5000$；
- （23 分）：$n, m \leq 10^5$；
- （17 分）：无额外限制。

## 样例 #1

### 输入

```
2 2
2 4 10
4 5 15
1 3 50
3 1 100```

### 输出

```
135```

# 题解

## 作者：TimSwn090306 (赞：2)

### Description

初始有 $n$ 把军刀和 $m$ 个敌人，军刀有属性 $a,b,cost$，敌人有属性 $c,d,profit$。军刀 $i$ 能杀死敌人 $j$ 当且仅当 $a_i\ge c_j ,b_i\ge d_j$。你需要选出若干军刀和若干敌人，使得每一个选出的敌人都可以被至少一把选出的军刀杀死，并最大化选出的敌人的 $profit$ 之和减去选出的军刀的 $cost$ 之和。

数据范围：$n,m\le 10^6,a,b,c,d,cost,profit\le 10^9$。

### Solution

把军刀和敌人放到二维平面上，对于选定的若干军刀，有贡献的敌人呈阶梯状（如下图）。

![](https://cdn.luogu.com.cn/upload/image_hosting/py63hvrn.png)

将所有点按 $y$ 排序，设 $f_i$ 表示考虑前 $i$ 把军刀，钦定第 $i$ 把必选的最大收益（$\sum profit-\sum cost$）。则有 $f_i=\max (f_j+w(j,i))-cost_i$，其中 $w(j,i)$ 表示上一把军刀为 $j$，新增一把军刀为 $i$ 的 $\sum profit$ 增量。简单实现可以做到 $O(n^2)\thicksim O(n^3)$，无法通过此题，需要优化。

注意到计算 $w(j,i)$ 时产生贡献的敌人的范围是一个 $([1,x_i],[y_j,y_i])$ 的矩形（如下图）。注意：若 $x_j<x_i$，转移本身是不优的，因为军刀之间存在偏序关系不优。同时 $j$ 到 $i$ 的转移的 $w(j,i)$ 也不是上述矩形，计算出来是小于真实值的，但又因为这个转移本身是不优的，故不用考虑该情况。形式化的讲，$w_{real}(j,i)\ge w(j,i),f_j+w_{real}(j,i)\le f_i \longrightarrow f_j+w(j,i)\le f_i$。

![](https://cdn.luogu.com.cn/upload/image_hosting/ui5ifbz5.png)

发现 $w(j,i)$ 和 $x_j$ 半毛钱关系没有，所以对于所有 $y$ 坐标相等的军刀，我只关心里面 $f$ 值最大的那一个，设 $l_i$ 表示 $y$ 坐标为 $i$ 的军刀里的 $f$ 最大值。

仍是从下到上枚举纵坐标 $y$，设 $p_i$ 表示若新增军刀坐标为 $(i,y)$，$cost$ 为 $0$，其 $f$ 值是多少，具体的，$p_i=\max_{j\in[1,y-1]}(l_j+sum([1,i],[j,y]))$，其中 $sum([sx,ex],[sy,ey])$ 表示矩形内敌人的 $profit$ 之和。$f_i=p_{x_i}-cost_i$。

尝试维护 $p$。不难发现新增第 $i$ 个敌人对 $p$ 的影响是 $[x_i,10^9]$ 区间加 $profit_i$，新增第 $i$ 个军刀对 $p$ 的影响是 $[1,10^9]$ 全局对 $f_i$ 取 $\max$。区间加，全局取 $\max$，单点查，线段树容易维护。

时间复杂度 $O(n\log n)$。

### Code

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;

const int maxn=2e6+5;
const ll INF=1e16;

int n,m,tot,b[maxn];
struct node{
	int type,x,y,c;
	inline bool operator < (node tmp) const{
		if (y!=tmp.y) return y<tmp.y;
		if (x!=tmp.x) return x<tmp.x;
		if (type!=tmp.type) return type<tmp.type;
		return c<tmp.c;
	}
}s[maxn];

namespace SGT{
	#define lc(rt) ((rt)<<1)
	#define rc(rt) ((rt)<<1|1)
	const int maxc=(maxn<<2);
	ll add[maxc],getmax[maxc];
	inline void lazy_add(int rt,ll k){
		add[rt]+=k;
	}
	inline void lazy_max(int rt,ll k){
		getmax[rt]=max(getmax[rt],k-add[rt]);
	}
	inline void pushdown(int rt){
		if (getmax[rt]){
			lazy_max(lc(rt),getmax[rt]);
			lazy_max(rc(rt),getmax[rt]);
			getmax[rt]=0;
		}
		if (add[rt]){
			lazy_add(lc(rt),add[rt]);
			lazy_add(rc(rt),add[rt]);
			add[rt]=0;
		}
	}
	inline void update_add(int rt,int l,int r,int ql,int qr,ll k){
		if (l>=ql && r<=qr){
			lazy_add(rt,k);
			return ;
		}
		pushdown(rt);
		int mid=(l+r)>>1;
		if (ql<=mid) update_add(lc(rt),l,mid,ql,qr,k);
		if (qr>mid) update_add(rc(rt),mid+1,r,ql,qr,k);
	}
	inline void update_max(int rt,int l,int r,int ql,int qr,ll k){
		if (l>=ql && r<=qr){
			lazy_max(rt,k);
			return ;
		}
		pushdown(rt);
		int mid=(l+r)>>1;
		if (ql<=mid) update_max(lc(rt),l,mid,ql,qr,k);
		if (qr>mid) update_max(rc(rt),mid+1,r,ql,qr,k);
	}
	inline ll query(int rt,int l,int r,int p){
		if (l==r){
			return max(0ll,getmax[rt])+add[rt];
		}
		pushdown(rt);
		int mid=(l+r)>>1;
		if (p<=mid) return query(lc(rt),l,mid,p);
		else return query(rc(rt),mid+1,r,p);
	}
}

ll f[maxn];

inline int rd(){
	int x=0; char ch=getchar();
	while (ch<'0' || ch>'9') ch=getchar();
	while (ch>='0' && ch<='9'){
		x=(x<<3)+(x<<1)+(ch-'0');
		ch=getchar();
	}
	return x;
} 

int main(){
	n=rd(),m=rd();
	for (int i=1;i<=n;i++) s[i].x=rd(),s[i].y=rd(),s[i].c=rd(),s[i].type=-1;
	for (int i=1;i<=m;i++) s[i+n].x=rd(),s[i+n].y=rd(),s[i+n].c=rd(),s[i+n].type=+1;
	
	for (int i=1;i<=n+m;i++) b[++tot]=s[i].x;
	sort(b+1,b+tot+1);
	tot=unique(b+1,b+tot+1)-b-1;
	for (int i=1;i<=n+m;i++) s[i].x=lower_bound(b+1,b+tot+1,s[i].x)-b;
	
	sort(s+1,s+n+m+1);
	memset(SGT::getmax,-0x3f,sizeof(SGT::getmax));
	
	for (int i=1;i<=n+m;i++){
		int j=i;
		while (j<=n+m && s[j].y==s[i].y) j++;
		for (int k=i;k<j;k++){
			if (s[k].type==+1){
				SGT::update_add(1,1,tot,s[k].x,tot,s[k].c);
			}
		}
		ll maxx=-INF;
		for (int k=i;k<j;k++){
			if (s[k].type==-1){
				f[k]=SGT::query(1,1,tot,s[k].x)-s[k].c;
				maxx=max(maxx,f[k]);
			}
		}
		SGT::update_max(1,1,tot,1,tot,maxx);
		
		i=j-1;
	}
	
	ll ans=-INF;
	for (int i=1;i<=n+m;i++) ans=max(ans,f[i]);
	
	printf("%lld\n",ans);
	
	return 0;
}
```

---

## 作者：Shunpower (赞：0)

简单题。

---

考虑我们本质上是花费 $cost_i$ 来获取一个左下方矩形的所有贡献。

不妨把所有矩形按照右边界排序，从右往左做 dp。$f_{i,j}$ 表示 $x$ 坐标为 $i$ 时我们能覆盖 $y$ 坐标 $\le j$ 的那部分点，加入矩形的时候改变状态中的第二维并计算代价，贡献根据状态计算就好了。

考虑压缩状态数。注意到我们的选法一定类似一个阶梯的形状，换句话说，如果我们选了一个 $(a_i,b_i)$，我们不会如果要选 $a_j<a_i$，那么必须满足 $b_j>b_i$，否则肯定是没用的。据此我们可以把第二维状态删掉，因为每次的 $j$ 其实就是上一个选中矩形的 $y$ 坐标。

设 $f_i$ 表示上一个使用的矩形是 $i$，可以写出转移：

$$
f_i\gets \max(\max\limits_{a_j\ge a_i\land b_j\le b_i}\{f_j+\sum\limits_{c_k\in(a_i,a_j]\land d_k\le b_j}profit_k\},0)-cost_i
$$

最后的答案就是 $\max(\max \{f_i+\sum\limits_{c_k\le a_i\land d_k\le b_i}profit_k\},0)$。

直接做复杂度是 $\mathcal O(n^2m)$，可以获得 $0$ 分。

注意到 $\sum\limits_{c_k\le a_i\land d_k\le b_i}profit_k$ 是一个简单的二维偏序，我们可以记作 $s_i$。

不妨套路地把它带回转移当中做补集转化（下面忽略外面的常数）：

$$
f_i\gets \max\limits_{a_j\ge a_i\land b_j\le b_i}\{f_j+s_j-\sum\limits_{c_k\le a_i\land d_k\le b_j}profit_k\}
$$

注意到 $b_j\le b_i$ 是不必要的限制，因为我们如果选了一个比上一个矩形更矮的矩形，只会让 dp 以为现在的高度受到新矩形更严格的限制，而这是不优的。于是不合法不优，我们可以直接删去这个限制。

不妨按照 $a$ 从大到小排序，那么我们的转移是：

$$
f_i\gets \max\limits_{j<i}\{f_j+s_j-\sum\limits_{c_k\le a_i\land d_k\le b_j}profit_k\}
$$

考虑套路地把 $f_j+s_j$ 放到对应 $b_j$ 的位置，并取 $\max$ 记作 $F_{b_j}$，维护一个 $G_j$ 表示当前的 $\sum\limits_{c_k\le a_i\land d_k\le j}profit_k$，那么转移实际上是：

$$
f_i\gets \max\{F_j+G_j\}
$$

这就很明确了。dp 过程中，每次 $i$ 向后移动，会导致某个 $k$ 不满足 $c_k\le a_i$，在 $G$ 上产生一个后缀加法。而 $F$ 上始终只有单点取 $\max$。故用线段树就可以简单维护了。

时间复杂度 $\mathcal O(n\log n)$。

```cpp
int n,m;
struct knife{
    int a,b,cst;
    bool operator<(const knife &p) const{
        return a>p.a;
    }
} k[N];
ll dp[N];
int c[N],d[N],pro[N];
ll sum[N];
vector <int> ofl[N];
vector <int> lsh;
#define mid (l+r>>1)
struct sgt{
    ll maxn[N<<4];
    ll lzy[N<<4];
    ll a[N<<4],b[N<<4];
    void pushup(int p){
        maxn[p]=max(maxn[p<<1],maxn[p<<1|1]);
    }
    void pushdown(int p){
        if(lzy[p]){
            maxn[p<<1]+=lzy[p];
            a[p<<1]+=lzy[p];
            maxn[p<<1|1]+=lzy[p];
            a[p<<1|1]+=lzy[p];
            lzy[p<<1]+=lzy[p],lzy[p<<1|1]+=lzy[p];
            lzy[p]=0;
        }
    }
    void build(int p,int l,int r){
        lzy[p]=a[p]=0;
        if(l==r) return b[p]=-1e18,maxn[p]=-1e18,void();
        build(p<<1,l,mid);
        build(p<<1|1,mid+1,r);
        pushup(p);
    }
    void modify(int p,int l,int r,int ml,int mr,int x){
        if(ml<=l&&r<=mr){
            lzy[p]+=x;
            a[p]+=x;
            maxn[p]+=x;
            return;
        }
        pushdown(p);
        if(ml<=mid) modify(p<<1,l,mid,ml,mr,x);
        if(mid<mr) modify(p<<1|1,mid+1,r,ml,mr,x);
        pushup(p);
    }
    void insert(int p,int l,int r,int d,ll x){
        if(l==r){
            maxn[p]=a[p]+max(b[p],x);
            b[p]=max(b[p],x);
            return;
        }
        pushdown(p);
        if(d<=mid) insert(p<<1,l,mid,d,x);
        else insert(p<<1|1,mid+1,r,d,x);
        pushup(p);
    }
} T;
struct BIT{
    ll k[N<<1];
    void add(int p,ll x){
        while(p<=n+m){
            k[p]+=x;
            p+=lowbit(p);
        }
    }
    ll ask(int p){
        ll ans=0;
        while(p){
            ans+=k[p];
            p-=lowbit(p);
        }
        return ans;
    }
} T2;
#undef mid
int main(){
#ifdef Ltp
    freopen("hack.txt","r",stdin);
    freopen("out.txt","w",stdout);
#endif
    ios::sync_with_stdio(false);
    cin>>n>>m;
    fr1(i,1,n) cin>>k[i].a>>k[i].b>>k[i].cst,lsh.pb(k[i].b);
    fr1(i,1,m){
        cin>>c[i]>>d[i]>>pro[i];
        lsh.pb(d[i]);
    }
    sort(lsh.begin(),lsh.end());
    lsh.resize(unique(lsh.begin(),lsh.end())-lsh.begin());
    fr1(i,1,n) k[i].b=lower_bound(lsh.begin(),lsh.end(),k[i].b)-lsh.begin()+1;
    fr1(i,1,m) d[i]=lower_bound(lsh.begin(),lsh.end(),d[i])-lsh.begin()+1;
    sort(k+1,k+n+1);
    T.build(1,1,n+m);
    fr1(i,1,m){
        int it=upper_bound(k+1,k+n+1,(knife){c[i],0,0})-k;
        it--;
        if(it){
            ofl[it].pb(i);
            T.modify(1,1,n+m,d[i],n+m,-pro[i]);
            T2.add(d[i],pro[i]);
        }
    }
    fr1(i,1,n){
        sum[i]=T2.ask(k[i].b);
        for(auto j:ofl[i]) T2.add(d[j],-pro[j]);
    }
    memset(dp,-0x3f,sizeof dp);
    fr1(i,1,n){
        // dp[i]=0;
        // fr1(j,1,i-1){
        //     ll pr=0;
        //     fr1(l,1,m) pr+=(c[l]<=k[i].a&&d[l]<=k[j].b?pro[l]:0);
        //     dp[i]=max(dp[i],dp[j]+sum[j]-pr);
        // }
        // dp[i]-=k[i].cst;
        dp[i]=max(T.maxn[1],0ll)-k[i].cst;
        for(auto j:ofl[i]){
            T.modify(1,1,n+m,d[j],n+m,pro[j]);
            //delete j
        }
        T.insert(1,1,n+m,k[i].b,dp[i]+sum[i]);
    }
    ll ans=0;
    fr1(i,1,n) ans=max(ans,dp[i]+sum[i]);
    cout<<ans<<'\n';
    ET;
}
//ALL FOR Zhang Junhao.
```

---

## 作者：xxxxxzy (赞：0)

简单题目，写篇题解

我们考虑把题目中的 $(a_i,b_i),(c_i,d_i)$ 转化为一个二维平面，以 $a_i,c_i$ 为 $x$ 轴，以 $b_i,d_i$ 为 $y$ 轴，这样每把军刀和敌人都化作了一个带权值的点。

我们发现，选择的军刀连线起来一定是一个单调递减的图像，否则一定不优。而每个敌人都是由其右上矩形的军刀干掉的。

这样就很简单了，把这个二维限制先扫掉一维。具体来说，按横坐标从大到小遍历，定义 $f_{i,j}$ 为扫到 $i$，后面的军刀最大的 $y$ 坐标为 $j$ 时候的最大贡献。

转移简单：

+ $f_{i+1,b_k} = -cost_k+\max(f_{i+1,j}, 0)(a_k=i)$。
+ $f_{i,j} = \max(f_{i+1,j} + \displaystyle\sum\limits_{i=c_k} [d_k\le j]p_k)$。

这个显然好用线段树维护，维护区间加单点改全局最大值，时间 $O(n \log n)$。

---

## 作者：SamHJD (赞：0)

将军刀按纵坐标排序，从下往上进行 dp：记 $f_i$ 为钦定第 $i$ 把军刀必选，能赚取的最大收益。注意到选取的军刀不存在包含关系，于是有转移：
$$
f_i=\max\limits_{y_j<y_i,x_j>x_i} \{f_j+w(1,y_j,x_i,x_j)-cost_i\}
$$
其中 $w(x_1,y_1,x_2,y_2)$ 表示 $\sum\limits_{x_i\in[x_1,x_2],y_i\in[y_1,y_2]} profit_i$​。

考虑优化，观察到 $w(1,y_j,x_i,x_j)$ 与 $x_j$ 无关，于是进一步设 $g_i$ 为 $\max\limits_{y_j=i}{f_j}$，有：
$$
g_i=\max\limits_{j<i} \{g_j+w(1,j,x_i,x_j)-cost_i\}
$$
使用扫描线，维护 $p_i$ 表示 $\max\limits_j\{g_j+\sum\limits_{x_i\in[1,i],y_i>j} profit_i\}$，即某行的 $g$ 值加上上方前 $i$ 列的 $profit$，转移可写为：
$$
g_i=p_i-cost_i
$$
考虑如何维护 $p_i$，对于纵坐标相同的敌人和军刀，先处理敌人。对于敌人 $(x,y)$ ，将 $i\ge x$ 的 $p_i$ 加上击杀奖励；对于这一行的所有军刀，按上式计算完 dp 值后，计算最大 dp 值，将 $p$ 的每一位和该值取 max。于是实现一个支持区间加、全局取 max、单点查询的数据结构即可。

---


# GTY的人类基因组计划2

## 题目背景

GTY 决心改变人类基因！！

## 题目描述

GTY 召唤了 $n$ 个人来做实验，GTY 家的房子很大，有 $m$ 个房间一开始所有人都在 $1$ 号房间里，GTY 会命令某人去某个房间等待做实验，或者命令一段区间的房间开始实验，实验会获得一些实验信息点数，点数为房间里的人数，如果一个房间里的一群人已经做过实验了那么这些人将不会增加实验信息点数（不会增加是针对这一群人的，不是对这群人中的每个人，即 $1,2,3$ 做了实验，$1,2$ 再做实验还会增加 $2$ 点实验点数）。


## 说明/提示

善用 STL。


## 样例 #1

### 输入

```
3 5 7
C 1 2
C 2 2
W 1 2
C 3 2
W 1 2
C 3 3
W 1 3```

### 输出

```
3
3
0```

# 题解

## 作者：Enzymii (赞：12)

这题没有题解？？做的人太少了。。

为什么标签是平衡树和线段树。。。

自己完全是按照提示全STL水过的啊 set map就好了。

这题开始能想到一些思路，但是不懂怎么hash。。

现在知道集合hash可以用xor的啊~

先随机一个long long范围的数字，之后xor就是整个集合的hash值了。。

~~听说用妹子生日做srand()的种子会有神秘加成~~

代码：

```cpp
#include <set>
#include <map>
#include <cmath>
#include <cstdio>
#include <cstdlib> 
#include <iostream>
#include <algorithm>
using namespace std;
#define uLL unsigned long long
#define MAXN 0x186AF
map<uLL,bool> hash;
set<int> zt;
uLL h[MAXN],an[MAXN],size[MAXN];
int at[MAXN];
char ch[8];
int main(){
    freopen("input2.txt","r",stdin);
    freopen("input2.out","w",stdout);
    srand(2001+06+28);  //这个数多少不重要啦，不小心被卡就换个就行了。。
    int n,m,q; cin>>n>>m>>q;    
    for(int i=1;i<=n;i++){
        int k1=rand()<<16|rand()%1000000000,
            k2=rand()<<16|rand()%2000000000;
        an[i]=(uLL)k1*k2; h[1]^=an[i]; at[i]=1;  //蜜汁hash
    }
    hash.clear(); zt.insert(1); size[1]=n;
    for(int i=1;i<=q;i++){
        int x,y; scanf("%s%d%d",ch,&x,&y);
        if(ch[0]=='C'){
            if(at[x]==y) continue;
            zt.erase(at[x]); zt.erase(y);
            h[at[x]]^=an[x]; size[at[x]]--;
            if(!hash[h[at[x]]]) zt.insert(at[x]);        
            at[x]=y; h[y]^=an[x]; size[y]++;             
            if(!hash[h[y]]) zt.insert(y); //直接模拟，有重复的就删
        }
        else{
            int ans=0; 
            set<int>::iterator it=zt.lower_bound(x);
            for(;it!=zt.end()&&*it<=y;it=zt.lower_bound(x)){
                ans+=size[*it]; hash[h[*it]]=1; zt.erase(it);
            } //把满足条件的i都加上 (x<=i<=y)
            printf("%d\n", ans);
        }
    }
}
```
~~其实出题人不想让我们这么水的是么~~


---

## 作者：岂非 (赞：5)

[题目传送门](https://www.luogu.com.cn/problem/P2087)

这里是一篇 **线段树** 题解~

看到题目中要求的区间求和操作以及一些特殊的统计要求，很自然的就可以想到使用线段树处理这类问题。

题目的一个难点是如何快速判断新的房间是否可以参与新的贡献，以及快速处理插入删除操作。题目中只存在单人的插入删除操作，可以考虑异或的特殊性质，即 $x=x \oplus y \oplus y$，将本房间内所有元素的随机关键值异或起来，就可以得到房间的异或和。用哈希表或是 map 维护这些异或和，就可以快速得到新的房间组成是否有贡献。

在本题中，查询操作的同时也要进行区间赋值。我们可以先在线段树上给这段区间打上不可贡献的 tag，先不急着把每个新出现的不可贡献房间统计进哈希表里去。等某一次询问或是某一次修改递归进这个叶子节点时再进行统计进哈希表去。

**上述做法正确性证明：** 本题中的每个人都是彼此不同且独立的，移动人的操作同时至多只会移动 $1$ 个人。由于每个人彼此不同，那么在移动某人前一定不会出现另一个房间含有这个人。所以在对该房间进行修改之前就不会出现另一个房间与该房间组成相同。又因为每次至多移动 $1$ 人，那么在每次移动操作就必定会访问到这个人有关联的两个叶子节点。我们就可以在询问到叶子节点时再把它统计进哈希表。

这个题用线段树做还是挺麻烦的，细节比较多，建议用 set 过的也用线段树写一写，非常考验代码能力。

注意在实现的时候询问后叶子节点的和不要真的置为 $0$，而是让 tag 为 $0$。使用 pushdown 保证访问过的节点 tag 不为 $0$。注意不要忘记本题的询问也是一种更改，需要重新计算贡献。

代码中注释写的很详细，还没看懂可以去看一下代码。

```cpp
//代码中不同函数线段树节点指针命名可能有所不同，请注意
//注意代码中部分函数可能多次定义pos，C++调用变量时会优先调用局部变量 
#include <cstdio>
#include <unordered_map>//请注意unordered_map仅可在C++11及以上版本使用 
#include <cstdlib>
#include <random>
using namespace std;
int n,m,q,x,y,tmp,pos[100010],rd[100010];
char op[5];
unordered_map <int,int> umap,umap1;//使用unordered_map会比普通map快很多
/*采用unordered_map实现hash，
缺点：常数大，理论O(1)，有几率n^2
优点：码量小，可靠性高，易调试*/ 
mt19937 rnd(1919810);
struct Node{//线段树节点，本人喜欢指针建树 
	int l,mid,r;
	int sum,xr;//xr为该节点所有人xor起来之后的值 
	int tag;//标记该节点是否可以向上贡献，1为可贡献，0为不可贡献 
	Node *lson,*rson;//lson=left_son rson=right_son 
}*head;
Node* build(int l,int r){//建树 
	Node *p=new(Node);
	p->l=l;p->r=r;p->mid=(l+r)>>1;
	p->sum=0;p->xr=tmp;p->tag=1;
	if(l==r){
		if(l==1){//建树的同时给1号房间赋初值 
			p->sum=n;
			for(int i=1;i<=n;i++){
                do{
                    rd[i]=rnd();
                }while(umap1[rd[i]]==1);//消耗一点时间防止非酋情况出现~ 
                umap1[rd[i]]=1;
				p->xr^=rd[i];
				pos[i]=1;//pos[i]表示编号为i的人当前所在的房间号 
			}
		}
		return p;
	}
	else{
		p->lson=build(p->l,p->mid);
		p->rson=build(p->mid+1,p->r);
		p->sum=p->lson->sum+p->rson->sum;//由于初始tag都是1所以现在不需乘tag 
		return p;
	}
}
void pushdown(Node *p){//很简单的pushdown，但可能需要思考一下 
	if(p->tag==0){
		p->lson->tag=0;
		p->rson->tag=0;//左右儿子分别继承父亲的不可贡献状态 
		p->tag=1;p->sum=0;//标记为可贡献状态，并把贡献清空 
	}
}
int query(Node *nod){//查询操作 
	if(nod->l>=x&&nod->r<=y){
		if(nod->tag==0) return 0;//若该节点不可贡献，直接返回0 
		if(nod->l==nod->r){//每次碰到子节点不可贡献时都单独处理 
			umap[nod->xr]=1;
		}
		nod->tag=0;//查询后该节点及其子树在下次修改前一定无法贡献 
		return nod->sum;
	}
	pushdown(nod);
	int res=0;
	if(x<=nod->mid){
		res+=query(nod->lson);
	}
	if(y>nod->mid){
		res+=query(nod->rson);
	}
	nod->sum=nod->lson->tag*nod->lson->sum+nod->rson->tag*nod->rson->sum;//向上贡献 
//注意这个题的询问实际上也是一种修改，所以记得及时计算贡献
//在这里调了好久 
	return res;
}
void subch1(int pos,Node *nod){//删除函数 
	if(nod->l==nod->r){
		if(nod->tag==0){//每次碰到子节点不可贡献时都单独处理 
			umap[nod->xr]=1;
		}
		nod->xr^=rd[x];
		if(umap[nod->xr]==0){//判断去掉这个人新的房间组成是否可以贡献 
			nod->tag=1;
		}
		else{
			nod->tag=0;
		}
		nod->sum--;//减掉这个人 
		return;
	}
	pushdown(nod);
	if(pos<=nod->mid){
		subch1(pos,nod->lson);
	}
	else{
		subch1(pos,nod->rson);
	} 
	nod->sum=nod->lson->tag*nod->lson->sum+nod->rson->tag*nod->rson->sum;
//计算删除后的贡献 
}
void subch2(int pos,Node *nod){//重新插入函数 
	if(nod->l==nod->r){
		if(nod->tag==0){//每次碰到子节点不可贡献时都单独处理 
			umap[nod->xr]=1;
		}
		nod->xr^=rd[x];
		nod->sum++;
		if(umap[nod->xr]==0){//判断加上这个人新的房间组成是否可以贡献 
			nod->tag=1;
		}
		else{
			nod->tag=0;
		}
		return;
	}
	pushdown(nod);
	if(pos<=nod->mid){
		subch2(pos,nod->lson);
	}
	else{
		subch2(pos,nod->rson);
	}
	nod->sum=nod->lson->tag*nod->lson->sum+nod->rson->tag*nod->rson->sum;
//计算贡献 
}
void change(int pos){//C操作的函数，其中pos为执行C操作前i号人的位置 
	subch1(pos,head);//先调用这个函数把i号人从原来的房间里删掉 
	subch2(y,head);//再把i号人插进y号房间里 
}
int main(){
	tmp=rnd();//所有房间的初始xr值 
	scanf("%lld%lld%lld",&n,&m,&q);
	head=build(1,m);//建树 
	for(int i=1;i<=q;i++){
		scanf("%s%lld%lld",op,&x,&y);
		if(op[0]=='C'){
			change(pos[x]);
			pos[x]=y;//更新一下i号人现在的房间位置 
		}
		else{
			printf("%lld\n",query(head));
		}
	}
	return 0;
}
```


---

## 作者：Zzxpy (赞：4)

（感谢管理大大百忙之中抽空审核！）

听到江湖上说这道题考STL赶快就过来做了。。。

~~然后标签是平衡树~~

确实这道题可以用平衡树做，但是不牵扯到排名时相比与130行的SPLAY，似乎SET要香一点。

然后这道题的基础思路也很简单，按题意模拟即可。

1.建立哈希表，记录使用过的组合。（记录组合时可以用异或，因为如果组合中不存在该数，异或可以相当于加法加入这个数的状态，而存在这个数时，又可以把这个数的状态抵消掉，不用麻烦的写加减法）

2.建立每个数的哈希值（越乱越好，~~我调这个调了一晚上~~，这道题卡哈希）

3.建立平衡树，通过平衡树来进行区间访问，从而减少工作量（不符合条件的房间是不会加入平衡树的，可以通过二分快速查询所需房间）

4.每进行一次转移人员，都要维护一下当前值能不能重新加入平衡树。

5.下面是代码

6.推销[没人看见我](https://tian0-hjyh.blog.luogu.org/)

```cpp
#define BOLI_LINGMEN
#define ITC_TL
#include<bits/stdc++.h>
#include<unordered_map>
using namespace std;
#define ll long long int
ll n,m,q,l,r,at[2123456],siz[2123456],room[2123456],val[2123456];
set<ll>s;
set<ll>::iterator it;
ll sum1=0;
unordered_map<ll,ll>h;
ll rethash(ll t) {
	return (rand()%381278*rand()%101710171017ll*rand()*1949100871)%192608170817ll;
}
char op[1];
int main() {
	srand(time(0));
	srand(rand()%10171120);
	scanf("%lld%lld%lld",&n,&m,&q);
	for(register int i=1; i<=n; i++) val[i]=rethash(i);
	for(register int i=1; i<=n; i++) at[i]=1,room[1]^=val[i];
	siz[1]=n;
	s.insert(1);
	while(q--) {
		scanf("%s%lld%lld",&op,&l,&r);
		if(op[0]=='C') {
			if(at[l]==r) continue;
			s.erase(at[l]);
			s.erase(r);
			siz[at[l]]--;
			siz[r]++;
			room[at[l]]^=val[l];
			room[r]^=val[l];
			if(!h[room[at[l]]]) s.insert(at[l]);
			if(!h[room[r]]) s.insert(r);
			at[l]=r;
		} else {
			sum1=0;
			it=s.lower_bound(l);
			for(; it!=s.end()&&*it<=r; it=s.lower_bound(l)) {
				h[room[*it]]=1;
				sum1+=siz[*it];
				s.erase(it);
			}
			printf("%lld\n",sum1);
		}
	}
	return 0;
}
```
你会发现无法编译，关于为什么。。。。

你可以在编译器中使用“-std=c++11”

也可以删去unordered这个东西，嘿嘿。

---

## 作者：FriedrichC (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P2087)

## 思路解析
本质上来说，这是一道纯粹的**模拟题**，

对于每次统计答案，每一个房间对答案的贡献实际上是这个房间人数的大小，所以我们要用数组模拟房间的人员流动的情况，并且维护房间人数的大小。

本题最大的难点在于，在区间查询时并不是所有的房间都可以对答案统计贡献，出现过的房间**人员组合情况**即为本题中**不合法**的答案贡献，反之即为**合法**。

所以我们要维护每一次出现过的情况并打上标记，因此我们很容易想到要使用 STL map 来对每种情况打标记。

但是，要如何把约 $n!$ 种组合情况转化为一个可映射的**量**呢？我们因此联想到**集合的哈希值**。

计算集合的哈希值有许多方法，而本题中最好选用将每个元素的哈希值异或起来得到集合哈希值的方法，

这是因为我们在本题中有修改操作，要**动态维护**每一个房间的人员组合情况的哈希值，

那么由于异或运算本身的性质，$a\oplus b\oplus b=a$，包含了这种状态的集合异或上这种状态本身，就可以**去除**这种状态，而若是原本不包含这种状态的集合则会**继承**上这种状态，

因此，使用异或运算就可以帮助我们快捷地更新人员流动对于哈希值的影响，在人员变动时，我们只要简单地将原始房间和转移的房间的哈希值异或上变动人员的哈希值就可以完成更新了。

那么在区间询问统计答案时，我们要查询**连续**区间的信息，并且要处理合法数据的插入和非法数据的删除的操作，可以考虑使用平衡树，但是我们只需支持这样一些简单的操作，所以可以使用 STL set，维护**目前合法**的房间号码。

在区间询问时，我们可以用 `lower_bound` 迅速定位到区间左端点的位置，然后不断向右端点搜索访问，

将访问到的 `set` 中存储的房号当前人员组合的哈希值累加入答案，再在 `set` 中删除，在 `map` 中标记。

## 其他细节
本题对于哈希值的强度要求较高，

我们常用的生成随机数的 `rand()` 函数在 Windows 系统下返回值的取值范围为 $[0,2^{15})$，在 Linux 环境下也仅为 $[0,2^{31})$，可能不足以满足我们的需求，

如果需要更大的随机数，我们需要对 `rand()` 的结果进行一些处理。

当然我们还有其他的选择，像标准库中的预定义随机数生成器，例如 `mt19937_64`，它可以返回质量更高的 $64$ 位随机数，除此之外的其他优势和具体用法，可以参考[此处](https://oi-wiki.org/misc/random/)，本文就不多赘述了。

## 附上代码
在以下代码中，用 $hs$ 数组表示每个人的哈希值，$siz$ 数组表示每个房间目前的人数，$rm$ 数组表示每个房间目前的人员组合的哈希值，$p$ 数组表示每个人目前所在的房号。

```cpp
#include<bits/stdc++.h>
#define int long long
#define maxn 100010
#define INF LLONG_MAX
using namespace std;
int n,m,q;
int hs[maxn],siz[maxn],rm[maxn],p[maxn];
map<int,bool>Map;
set<int>s;
void change(int x,int y)
{
    s.erase(p[x]); s.erase(y);//暂时全部删除
    rm[p[x]]^=hs[x]; rm[y]^=hs[x];
    siz[p[x]]--; siz[y]++;
    if(Map.find(rm[p[x]])==Map.end())s.insert(p[x]);//只加入仍可以产生贡献的房间号
    if(Map.find(rm[y])==Map.end())s.insert(y);//同上
    p[x]=y;
}
int query(int x,int y)
{
    int ans=0;
    for(auto it=s.lower_bound(x);it!=s.end();it=s.lower_bound(x))
    {
        int temp=*it;
        if(temp>y)break;//大于区间右端点
        Map[rm[temp]]=1; s.erase(it);
        ans+=siz[temp];
    }
    return ans;
}
signed main()
{
    cin>>n>>m>>q;
    mt19937_64 Rand(time(0));
    for(int i=1;i<=n;++i)
    {
        hs[i]=Rand()%INF;
        p[i]=1;
        rm[1]^=hs[i];//初始化1号房间的信息
    }
    siz[1]=n;
    while(q--)
    {
        char op;
        int x,y;
        cin>>op>>x>>y;
        if(op=='C')change(x,y);
        else cout<<query(x,y)<<'\n';
    }
	return 0;
}

```


























---

## 作者：Purslane (赞：1)

# Solution

典中典。

首先，我们需要有一种快速判断一个集合是否被覆盖过的方法。我们发现，虽然一共有 $2^n$ 种可能的集合，但实际上在整个过程中可能出现的集合只有 $O(n+q)$ 种。因此，我们可以用经典的随机数异或来描述一个集合（这样做把 $O(n+q)$ 种集合映射到 $2^{63}$ 个整数上，发生冲突的概率比较小，可以忽略不计。）下文定义权值为这个集合异或的哈希值。

但是怎样能快速确定一个集合是否被第二种操作覆盖过呢？~~你用树套树维护这个区间里面所有节点的权值好像也不是不可以，但我懒得试。~~ 我们发现，如果一个位置躺在原地不改变，那么我们并没有必要去管这个集合是否被覆盖过，因为在里面所有数都移到另一个位置或者加入一些数又删掉之前，我们都不会遇到与之相同的集合。但是根据上述的可能再次遇到他的情形，分析知道我们只需要关心修改时原位置的权值和将要修改到的位置的权值即可。因此可以做到 $O(n \log n)$。


代码：

```cpp
#include<bits/stdc++.h>
#define int long long 
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=1e5+10;
int n,m,q,id[MAXN],pos[MAXN],tot[MAXN],cnt[MAXN];
map<int,int> mp;
namespace DS {
	int flg[MAXN<<2],sum[MAXN<<2];
	#define lson (k<<1)
	#define rson (k<<1|1)
	#define mid (l+r>>1)
	void push_down(int k,int l,int r) {
		if(flg[k]) {
			flg[lson]=flg[rson]=1;
			sum[lson]=sum[rson]=0;
			flg[k]=0;
		}
		return ;
	}
	void update(int k,int l,int r,int pos,int v) {
		if(l==r) return sum[k]=v,void();
		push_down(k,l,r);
		if(pos<=mid) update(lson,l,mid,pos,v);
		else update(rson,mid+1,r,pos,v);
		return sum[k]=sum[lson]+sum[rson],void();	
	}
	int query(int k,int l,int r,int x,int y) {
		if(x<=l&&r<=y) return sum[k];
		push_down(k,l,r);
		if(y<=mid) return query(lson,l,mid,x,y);
		if(x>mid) return query(rson,mid+1,r,x,y);
		return query(lson,l,mid,x,y)+query(rson,mid+1,r,x,y);	
	}
	void modify(int k,int l,int r,int x,int y) {
		if(x<=l&&r<=y) return flg[k]=1,sum[k]=0,void();
		push_down(k,l,r);
		if(x<=mid) modify(lson,l,mid,x,y);
		if(y>mid) modify(rson,mid+1,r,x,y);
		sum[k]=sum[lson]+sum[rson];
		return ;	
	}
}using namespace DS;
mt19937 myrand(20071226);
signed main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>n>>m>>q; ffor(i,1,n) id[i]=myrand()*1ll*myrand(),pos[i]=1,tot[1]^=id[i],cnt[1]++;
	update(1,1,m,1,n);
	//考察对于 mp 的更改 我们把一个人扔走的时候再去看这个人当前的组合是否被标记过了
	mp[0]=1;
	ffor(i,1,q) {
		char ch; int x,y;
		cin>>ch>>x>>y;
		if(ch=='C') {
			if(query(1,1,m,pos[x],pos[x])==0) mp[tot[pos[x]]]=1;
			if(query(1,1,m,y,y)==0) mp[tot[y]]=1;
			tot[pos[x]]^=id[x],tot[y]^=id[x];
			cnt[pos[x]]--,cnt[y]++;
			if(mp[tot[pos[x]]]==0) update(1,1,m,pos[x],cnt[pos[x]]);
			else update(1,1,m,pos[x],0);
			if(mp[tot[y]]==0) update(1,1,m,y,cnt[y]);
			else update(1,1,m,y,0);
			pos[x]=y;
		}
		else {
			cout<<query(1,1,m,x,y)<<'\n';
			modify(1,1,m,x,y);	
		}
	}
	return 0;
}
```

---

## 作者：XiaoZi_qwq (赞：0)

# P2087 GTY的人类基因组计划2
## 前言
本文全文约 $3500$ 字，文中做法并未用到 STL 和异或哈希的，请放心食用。
## 题意概述
本题要求区间和，同时限制**同种状态只进行一次贡献**，数据范围 $10^5$，带修。  
## 分析
区间和可以使用线段树维护。  
但难点在于如何实现同种状态只进行一次贡献，我们不妨把该点分为两部分：“怎么判断同种状态”和“怎么只做出一次贡献”。  
对于第一个问题：既然要判断状态是否相同，那就进行状态压缩，由于本题只需要快速查询和修改一个状态对应的值，可以考虑**哈希表**。  
由于每一次修改操作最多产生 $2$ 个新状态，所以空间复杂度是 $O(N)$ 的。   
对于第二个问题：我们只需要在修改时**判断因为当前修改产生和消失的状态是否做出过贡献，并维护其权值**。  
具体的，对于一个状态，它只有做出过贡献才会在线段树上被打标记，而且对于已经做出贡献的状态，它在被修改之前都会因为线段树上的懒标记而不会做出第二次贡献。所以，**一个位置的状态是否做出过贡献，可以通过线段树上该位置是否有懒标记来判断**。  
同时，由于本题情境的限制，**同一种状态不会同时出现在两个位置**，这使得本算法的正确性有了保障。  
因此我们只需要判断修改前后两个位置（这个人的初始位置和目的地)的四个状态是否做出过贡献，然后维护权值即可。  
注意：修改一个位置的权值时，要将该位置上的懒标记清零 **（叶子节点的懒标记也要清零）**    
_**Talk is cheap,show me your code**_

```cpp
#include<bits/stdc++.h>
#define ls (i<<1)
#define rs (i<<1|1)
using namespace std;
inline int read(){
  register int x=0;
  char c=getchar();
  while(c<'0' || '9'<c) c=getchar();
  while('0'<=c && c<='9') x=(x<<1)+(x<<3)+c-'0',c=getchar();
  return x;
}
const int N=2e5+10,MAXN=(N<<1);
typedef unsigned long long ull;
struct HashTable{
  inline int Hash(ull x){return x%MAXN;}
  int val[MAXN+10],nxt[MAXN+10],h[MAXN+10],tot;
  ull key[MAXN+10];
  int& operator [](const ull x){
    int u=Hash(x);
    for(int i=h[u];i;i=nxt[i])
      if(key[i]==x)
        return val[i];
     tot++,nxt[tot]=h[u],h[u]=tot,key[tot]=x;
     val[tot]=-1;//为了区别“已清零”和“新元素”两种情况
     return val[tot];
  }
}h;
int n,m,q,cnt[N],bel[N];
ull pw[N],a[N];
struct Tree{int l,r,val;bool done;}t[N<<2];
void push_up(int i){t[i].val=t[ls].val+t[rs].val;}
void push_down(int i){
  if(t[i].done){
    t[ls].val=t[rs].val=0;
    t[ls].done=t[rs].done=true;
    t[i].done=0;
  }
}
void build(int i,int l,int r){
  t[i].l=l,t[i].r=r;
  if(l==r)
    return;
  int mid=l+r>>1;
  build(ls,l,mid);
  build(rs,mid+1,r);
}
void add(int i,int x,int k){
  if(t[i].l==t[i].r){
    t[i].val+=k;
    t[i].done=false;//非常重要!!!
    return;
  }
  push_down(i);
  int mid=t[i].l+t[i].r>>1;
  if(x<=mid)
    add(ls,x,k);
  else
    add(rs,x,k);
  push_up(i);
}
void update(int i,int l,int r){
  if(l<=t[i].l && t[i].r<=r){
    t[i].done=true;
    t[i].val=0;
    return;
  }
  push_down(i);
  int mid=t[i].l+t[i].r>>1;
  if(l<=mid)
    update(ls,l,r);
  if(mid<r)
    update(rs,l,r);
  push_up(i);
}
bool check(int i,int x){//通过懒标记判断一个点是否做出过贡献
  if(t[i].done) return true;
  if(t[i].l==x && t[i].r==x) return false;
  int mid=t[i].l+t[i].r>>1;
  return x<=mid?check(ls,x):check(rs,x);
}
int query(int i,int l,int r){
  if(l<=t[i].l && t[i].r<=r)
    return t[i].val;
  push_down(i);
  int mid=t[i].l+t[i].r>>1;
  if(l>mid) return query(rs,l,r);
  if(mid>=r) return query(ls,l,r);
  return query(ls,l,r)+query(rs,l,r);
}
void slove(int x,int y){//处理修改操作(两个位置，四种状态)
  int u=bel[x];
  if(!check(1,u))
    add(1,u,-h[a[u]]);
  else
    h[a[u]]=0;
  if(!check(1,y))
    add(1,y,-h[a[y]]);
  else
    h[a[y]]=0;

  a[u]-=pw[x],a[y]+=pw[x],bel[x]=y;
  cnt[u]--,cnt[y]++;

  if(h[a[u]]==-1)
    h[a[u]]=cnt[u];
  if(h[a[y]]==-1)
    h[a[y]]=cnt[y];
  if(h[a[u]])
    add(1,u,h[a[u]]);
  if(h[a[y]])
    add(1,y,h[a[y]]);
}
void init(){
  pw[1]=a[1]=bel[1]=1;
  cnt[1]=n;
  for(int i=2;i<=n;i++)
    bel[i]=1,pw[i]=pw[i-1]*131,a[1]+=pw[i];
  build(1,1,m);
  t[1].done=1;
  add(1,1,h[a[1]]=n);
}
char opt[2];
int main()
{
  n=read(),m=read(),q=read();
  init();
  for(int i=1,x,y;i<=q;i++){
    scanf("%s",opt),x=read(),y=read();
    if(opt[0]=='C')
      slove(x,y);
    else{
      printf("%d\n",query(1,x,y));
      update(1,x,y);
    }
  }
  return 0;
}
```

---

## 作者：Polarisx (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P2087)。

## 思路

容易发现最初状态只有 $1$ 个，而每次修改最多只会产生 $2$ 个新的状态，那么每次查询暴力即可，接下来的问题就是如何判断是否为新的状态。

考虑和哈希，定义 Hash 函数 $h(S)=\sum_{x\in S} x^6\bmod 998244353$，若 $h(S)=h(T)$，那么 $S,T$ 大概率是相等的，否则大概率是不相等的。

此时我们用一个 `map` 记录该状态是否出现过，用 `set` 维护有贡献的位置，那么这道题就做完了。


```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;

const int Mod=998244353;
const int Maxn=2e5+6;
mt19937 rnd(time(0));
int n,m,Q;
set<int>s;
map<int,int>mp;
int val[Maxn],pos[Maxn],sz[Maxn],t[Maxn];

inline int ghs(int x){
    return 1ll*t[x]*t[x]%Mod*t[x]%Mod*t[x]%Mod*t[x]%Mod*t[x]%Mod;
}

int main(){
    scanf("%d%d%d",&n,&m,&Q);
    for(int i=1;i<=n;i++)
        t[i]=(rnd()%Mod)*(rnd()%Mod)%Mod,val[1]=(val[1]+ghs(i))%Mod,pos[i]=1,sz[1]++;
    s.insert(1);
    
    while(Q--){
        char opt;int x,y;
        cin>>opt>>x>>y;
        if(opt=='C'){
            int now=pos[x]; s.erase(now);
            if(s.find(y)!=s.end()) s.erase(y);
            val[now]=(val[now]-ghs(x)+Mod)%Mod;
            val[y]=(val[y]+ghs(x))%Mod;
            if(!mp.count(val[now])) s.insert(now);
            if(!mp.count(val[y])) s.insert(y);
            sz[now]--,sz[y]++; pos[x]=y;
        }
        else{
            int ans=0;
            vector<int>del;
            for(auto it=s.lower_bound(x);it!=s.end() and *it<=y;it++)
                ans=(ans+sz[*it]),del.emplace_back(*it),mp[val[*it]]=1;
            for(auto i:del) s.erase(i);
            printf("%d\n",ans);
        }
    }

    system("pause");
    return 0;
}
```

---

## 作者：Exschawasion (赞：0)

很好的数据结构应用题。

本题的一个核心操作就是要统计不同集合的数量。说的更准确一些，这些不同集合是**一个可重超集的不同可重子集**。要求统计不同集合数量，很自然就能想到哈希值。

哈希值的计算方式有很多，在这里介绍一个实现简单且有效的技巧：给每个元素一个不同的哈希值，那么每个集合的哈希值就可以用**组成元素的异或和**来表示。

由于异或计算的特殊性 $a \operatorname{xor} b \operatorname{xor}b=a$，很方便地就能计算集合中增减某个元素后的结果：直接将该集合的哈希值异或上这个元素的哈希值。统计不同的哈希值可以使用平衡树，但是本题使用到的平衡树操作非常的少（仅限于插入、删除和查重），使用现成的 `std::set` 就可以了。

具体来说，本题需要两个 `set`：一个用作统计**被标记过的**集合 $A$；一个用作统计**当前出现的**集合 $B$。同时还需要保存所有集合的哈希值，这可以通过一个一维数组实现。

**转移操作**。将原属集合、转移目标异或上该元素的哈希值，同时从 $B$ 中去除原属集合、转移目标。如果发现生成了新的集合且这些集合没有被标记过（不属于 $B$），那么放到 $A$ 中。

**统计操作**。因为 `set` 是自带排序的，需要使用 `lower_bound` 来索引到**大于 $l$ 所有集合**。将索引到的集合标记（加入 $B$）、从 $A$ 中去除、并累加答案。当索引到大于 $r$ 的集合时退出循环。

哈希值的选取尽量使用值域比较大的 $\texttt{long long}$，由于 `rand` 函数返回的值域比较小，这里使用了异或魔法数字的方式，冲突率比较小。具体细节可见代码（省略头文件和部分声明）：

```
int room[maxn];
int size[maxn];
int pos[maxn];
int hsh[maxn];

set<long long> A;
set<long long> B;

int Rand() {
	return (rand() << 8) xor (rand()) xor 0xc612ec3f; // 0xc612ec3f魔法值，可任意指定
}

int main() {
	int n, m, q; cin >> n >> m >> q;
	for(int i = 1; i <= n; i++) hsh[i] = Rand();
	for(int i = 1; i <= n; i++) pos[i] = 1, room[1] = room[1] xor hsh[i];
	size[1] = n;
	while(q--) {
		char k;
		int x, y; cin >> k >> x >> y;
		if(k == 'C') {
			A.erase(pos[x]); A.erase(y);
			size[pos[x]]--, size[y]++;
			room[pos[x]] = room[pos[x]] xor hsh[x];
			room[y] = room[y] xor hsh[x];
			if(!B.count(room[pos[x]])) A.insert(pos[x]);
			if(!B.count(room[y])) A.insert(y);
			pos[x] = y;
		}
		else {
			int ans = 0;
			for(
				set<long long>::iterator it = A.lower_bound(x);
				it != A.end();
				it = A.lower_bound(x)
			) {
				int cur = *it;
				if(cur > y) break;
				B.insert(room[cur]), A.erase(it);
				ans += size[cur];
			}
			cout << ans << endl;
		}
	}
	return 0;
}
```

_附：题面中对人做实验之类的，本人认为可能需要和谐。_

---

## 作者：FutaRimeWoawaSete (赞：0)

划水了。              

这题面确实难看……不难发现一次一个人的移动最多只会多出来两种贡献，并且一种贡献贡献完了之后就不会再贡献了，于是我们只要维护区间有哪些房间要贡献即可。          

考虑大力 Hash，我们直接对于每个人随机一个值，一个房间的 Hash 值就是其中所有人的随机值按位异或起来，然后修改操作暴力改查询操作开个 set，大力维护一下中间有哪些房间要贡献，贡献完之后删掉就可以了，最后总的时间复杂度 $\Theta(q \log n)$。

```cpp
#include "bits/stdc++.h"
using namespace std;
const int Len = 1e5 + 5;
#define ull unsigned long long
map<ull,int> mp;
set<int> st;
set<int>::iterator it;
unsigned long long val[Len],Num[Len],Sd;
int n,m,q,sum[Len],bel[Len],l,r,del[Len],delcnt;bool flag[Len];
char s[5];
int main()
{
	srand(114514);
	Sd = rand();
	scanf("%d %d %d",&n,&m,&q);
	for(int i = 1 ; i <= n ; i ++) 
	{
		val[i] = 1ull * rand() * rand() * rand() , val[i] *= Sd;
		Num[1] ^= val[i];
		sum[1] ++;
		bel[i] = 1;
	}
	st.insert(1);
	while(q --)
	{
		scanf("%s",s);scanf("%d %d",&l,&r);
		if(s[0] == 'C')
		{
			if(bel[l] == r) continue;
			if(flag[bel[l]]) st.erase(bel[l]) , flag[bel[l]] = 0;
			if(flag[r]) st.erase(r) , flag[r] = 0;
			sum[bel[l]] --;
			sum[r] ++;
			Num[bel[l]] ^= val[l];
			Num[r] ^= val[l];
			if(!mp[Num[bel[l]]]) st.insert(bel[l]) , flag[bel[l]] = 1;
			if(!mp[Num[r]]) st.insert(r) , flag[r] = 1;
			bel[l] = r;
		}
		else
		{
			int res = 0;delcnt = 0;
			it = st.lower_bound(l);
			for(; it != st.end() && *it <= r ; it ++) 
			{
				mp[Num[*it]] = 1;
				res += sum[*it];
				del[++ delcnt] = *it;
			}
			for(int i = 1 ; i <= delcnt ; i ++) 
			{
				it = st.lower_bound(del[i]);
				st.erase(it);
				flag[del[i]] = 0;
			}
			printf("%d\n",res);
		}
	}
	return 0;
}
```

---

## 作者：Strelitzia (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P2087)

----

要求支持两种操作：移动和区间求和。

区间求和有特殊要求，已经作为组为单位的求过点数，

之后这个组不能在贡献点数。

----

“如果一个房间里的一群人已经做过实验了那么这些人将不会增加实验信息点数。”

看到这句话的时候就该想到用$\texttt{hash}$判重，通过异或来修改$\texttt{hash}$值，

$\texttt{map}$判重，但这里卡种子，所以打了个双哈希。

$\texttt{set}$来维护可进行实验的房号。

---

$\texttt{sum,bel}$分别是对应房号的人数和人对应哪个房号。

$\texttt{p,p2}$是随机分配给人的$\texttt{hash}$值。

$\texttt{ha,h}$是对应房间的$\texttt{hash}$值

----

```cpp
#include <map>
#include <set>
#include <ctime>
#include <cmath>
#include <queue>
#include <cstdio>
#include <cstring>
#include <climits>
#include <iostream>
#include <algorithm>
using namespace std;
template<typename T>void read(T &x) {
	T f = 1;x = 0;char s = getchar();
	while(s < '0' || s > '9') {if(s == '-')f = -1;s = getchar();}
	while(s >= '0' && s <= '9') {x = x * 10 + s - '0';s = getchar();}
	x *= f;
}
template<typename T>void print(T x) {
	if(x < 0) putchar('-'),x = -x;
	if(x > 9	) print(x / 10);
	putchar(x % 10 + '0');
}
typedef unsigned long long ull;
map<ull,int> vis;
map<ull,int> vis2;
set<int> s;
ull p[100005],p2[100005],ha[100005],h[100005];
int n,m,q,sum[100005],bel[100005];
int main() {
	read(n);read(m);read(q);
	int seed  = rand();
	for (int i = 1 ; i <= n ; ++ i) {
		p[i] = rand() * rand() * rand() * rand() * seed;
		p2[i] = rand() * seed;
		seed = rand() * rand();
		bel[i] = 1;
		ha[1] ^= p[i];
		h[1] ^= p2[i];
	}
	sum[1] = n;
	s.insert(1);
	char str[3];
	int x,y;
	for (int i = 1 ; i <= q ; ++ i) {
		scanf ("%s %d %d",str,&x,&y);
		if (*str == 'C') {
			int xx = bel[x];
			if (xx == y) continue;
			s.erase(xx);s.erase(y);
			bel[x] = y;
			ha[xx] ^= p[x];
			h[xx] ^= p2[x];
			sum[xx] --;
			if (!vis[ha[xx]] || !vis2[h[xx]]) s.insert(xx);
			ha[y] ^= p[x];
			h[y] ^= p2[x];
			sum[y] ++;
			if (!vis[ha[y]] || !vis2[h[y]]) s.insert(y);
		}
		else {
			set<int>::iterator it = s.lower_bound(x);
			int ans = 0;
			for (; it != s.end() && *it <= y ; it = s.lower_bound(x)) {
				ans += sum[*it];
				s.erase(it);
				vis[ha[*it]] = 1;
				vis2[h[*it]] = 1;
			}
			print(ans),putchar('\n');
		}
	}
	return 0;
}
```

---

## 作者：yi_heng (赞：0)

太蒟蒻了。 发题解！！！

【题解】【STL的应用，一改往常一用STL就荣获TLE的经历啊，看来以前还是使用的不够优越】

【这道题，先给所有的人随机一个值，因为是给一个集合判重，所以判重的时候，将几个人的值异或起来，用map判断是否出现过；将每一次移动后合法的集合即房间号存在set里，每一次移动时，先将相关的两个房间的序号先从set里删掉，再将合法的加入。

记录：每个房间的人数，每个人的编号，每个房间的当前异或值。】

code：

```cpp
#include<map>
#include<set>
#include<ctime>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<algorithm>
using namespace std;
set<int>s;//存合法的房间号 
map<long long,bool>mp;//判重 
long long  num[100010],p[1000010],b[1000010],h[1000010];
int n,m,q;

int main()
{
    int i,j;
    srand(1289);

    scanf("%d%d%d\n",&n,&m,&q);
    for(i=1;i<=n;++i) num[i]=(long long)rand()*rand()%1000000000*(rand()*rand()%2000000000);//给每个人随机一个值 
    s.insert(1);//因为刚开始所有人都在第一个房间，先将第一个房间加入set 
    for(i=1;i<=n;++i) h[1]^=num[i],p[1]++,b[i]=1;//h存当前房间的异或值；p存当前房间的人数；b存当前每个人在哪个房间 
    for(i=1;i<=q;++i)//询问和操作总共不超过10^5,且每次操作只移动一个人，所以范围可以使用STL 
     {
        char c;
        int x,y;
        scanf("%c",&c);
        scanf("%d%d\n",&x,&y);
        if(c=='C')
          {
            if(b[x]==y) continue;//看操作后是否换了房间 
            s.erase(b[x]); s.erase(y);//将原来的状态移出set 

            h[b[x]]^=num[x];
            p[b[x]]--;
            if (!mp[h[b[x]]]) s.insert(b[x]);

            h[y]^=num[x];
            p[y]++;
            if (!mp[h[y]]) s.insert(y);

            b[x]=y;
          }
         else
          if(c=='W')
           {
             int ans=0;
             set<int>::iterator it=s.lower_bound(x);
             for(;it!=s.end()&&*it<=y;it=s.lower_bound(x))
              {
                mp[h[*it]]=1;
                ans+=p[*it];
                s.erase(it);
              } 
             printf("%d\n",ans);
          }
     }
     return 0;
}
```

---


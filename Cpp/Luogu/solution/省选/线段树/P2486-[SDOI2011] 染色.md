# [SDOI2011] 染色

## 题目描述

给定一棵 $n$ 个节点的无根树，共有 $m$  个操作，操作分为两种：

1. 将节点 $a$ 到节点 $b$ 的路径上的所有点（包括 $a$ 和 $b$）都染成颜色 $c$。
2. 询问节点 $a$ 到节点 $b$ 的路径上的颜色段数量。

颜色段的定义是极长的连续相同颜色被认为是一段。例如 `112221` 由三段组成：`11`、`222`、`1`。

## 说明/提示

#### 数据规模与约定

对于 $100\%$ 的数据，$1 \leq n, m \leq 10^5$，$1 \leq w_i, c \leq 10^9$，$1 \leq a, b, u, v \leq n$，$op$ 一定为 `C` 或 `Q`，保证给出的图是一棵树。

除原数据外，还存在一组不计分的 hack 数据。


## 样例 #1

### 输入

```
6 5
2 2 1 2 1 1
1 2
1 3
2 4
2 5
2 6
Q 3 5
C 2 1 1
Q 3 5
C 5 1 2
Q 3 5
```

### 输出

```
3
1
2
```

# 题解

## 作者：qscqesze_lca (赞：117)

思路：很好的一道树链剖分。树剖后，线段树要记录左端点l,右端点r，左端点的颜色lc,右端点的颜色rc,区间成段更新的标记tag,区间

有多少颜色段。区间合并的时候要注意如果左子树的右端和右子树的左端颜色相同那么数量要减一。但是存在一个问题当前剖到

的链与上一次的链在相交的边缘可能颜色相同，如果颜色相同答案需要减一。所以统计答案的时候要记录下上一次剖到的链的左端

点的颜色，与当前剖到的链右端点的颜色（因为在处理出的线段树中越靠近根的点位置越左），比较这两个颜色，若相同则答案减

1。又由于有u和v两个位置在向上走，那么要记录ans1，ans2两个变量来存“上一次的左端点颜色”。有一点需要注意，当

top[u]=top[v]的时候，即已经在同一个重链上时，两边端点颜色都要考虑与对应ans比较颜色，相同答案要相应减一。详见代码：

[cpp] view plain copy print?

/*****
file name: bzoj2243.cpp

author : 2016gdgzoi334

create time: 2017年08月15日 星期二 17时00分00秒

*****/
```cpp
#include<iostream>  
#include<cstdio>  
#include<cstring>  
#include<queue>  
#include<set>  
#include<map>  
#include<vector>  
#include<stack>  
#include<cmath>  
#include<string>  
#include<algorithm>  
using namespace std;  
typedef long long ll;  
const int sigma_size=26;  
const int N=100+50;  
const int MAXN=100000+50;  
const int inf=0x3fffffff;  
const double eps=1e-8;  
const int mod=100000000+7;  
#define L(x) (x<<1)  
#define R(x) (x<<1|1)  
#define PII pair<int, int>  
#define mk(x,y) make_pair((x),(y))  
int n,m,edge_cnt,cnt,Lc,Rc;  
char str[N];  
int col[MAXN],head[MAXN],sz[MAXN],dep[MAXN],fa[MAXN],son[MAXN],top[MAXN],pos[MAXN];  
struct Edge{  
    int u,v,next;  
}edge[MAXN<<1];  
struct node{  
    int l,r;  
    int num,tag,lc,rc;  
}segtree[MAXN<<2];  
void init(){  
    edge_cnt=cnt=0;  
    memset(head,-1,sizeof(head));  
}  
void addedge(int u,int v){  
    edge[edge_cnt].u=u; edge[edge_cnt].v=v;  
    edge[edge_cnt].next=head[u]; head[u]=edge_cnt++;  
}  
void dfs1(int u,int pre,int depth){  
    sz[u]=1; fa[u]=pre; son[u]=0; dep[u]=depth;  
    for(int i=head[u];i!=-1;i=edge[i].next){  
        int v=edge[i].v;  
        if(v == pre)  
            continue;  
        dfs1(v,u,depth+1);  
        sz[u]+=sz[v];  
        if(sz[son[u]]<sz[v])  
            son[u]=v;  
    }  
}  
void dfs2(int u,int tp){  
    pos[u]=++cnt; top[u]=tp;  
    if(son[u]!=0)  
        dfs2(son[u],top[u]);  
    for(int i=head[u];i!=-1;i=edge[i].next){  
        int v=edge[i].v;  
        if(v == fa[u] || v == son[u])  
            continue;  
        dfs2(v,v);  
    }  
}  
void push_down(int rt){  
    if(segtree[rt].tag){  
        segtree[L(rt)].tag=segtree[R(rt)].tag=segtree[rt].tag;  
        segtree[L(rt)].num=segtree[R(rt)].num=1;  
        segtree[L(rt)].lc=segtree[L(rt)].rc=segtree[rt].lc;  
        segtree[R(rt)].lc=segtree[R(rt)].rc=segtree[rt].lc;  
        segtree[rt].tag=0;  
    }  
}  
void push_up(int rt){  
    segtree[rt].lc=segtree[L(rt)].lc; segtree[rt].rc=segtree[R(rt)].rc;  
    int ans=segtree[L(rt)].num+segtree[R(rt)].num;  
    if(segtree[L(rt)].rc == segtree[R(rt)].lc)  
        ans--;  
    segtree[rt].num=ans;  
}  
void build(int rt,int l,int r){  
    segtree[rt].l=l; segtree[rt].r=r; segtree[rt].num=0;  
    if(l == r)  
        return ;  
    int mid=(l+r)>>1;  
    build(L(rt),l,mid); build(R(rt),mid+1,r);  
}  
void update(int rt,int l,int r,int x){  
    if(segtree[rt].l == l && segtree[rt].r == r){  
        segtree[rt].num=segtree[rt].tag=1;  
        segtree[rt].lc=segtree[rt].rc=x;  
        return ;  
    }  
    push_down(rt);  
    int mid=(segtree[rt].l+segtree[rt].r)>>1;  
    if(r<=mid)  
        update(L(rt),l,r,x);  
    else if(l>mid)  
        update(R(rt),l,r,x);  
    else {  
        update(L(rt),l,mid,x); update(R(rt),mid+1,r,x);  
    }  
    push_up(rt);  
}  
int query(int rt,int l,int r,int L,int R){  
    if(segtree[rt].l == L)  
        Lc=segtree[rt].lc;  
    if(segtree[rt].r == R)  
        Rc=segtree[rt].rc;  
    if(segtree[rt].l == l && segtree[rt].r == r)  
        return segtree[rt].num;  
    push_down(rt);  
    int mid=(segtree[rt].l+segtree[rt].r)>>1;  
    if(r<=mid)  
        return query(L(rt),l,r,L,R);  
    else if(l>mid)  
        return query(R(rt),l,r,L,R);  
    else{  
        int ans=query(L(rt),l,mid,L,R)+query(R(rt),mid+1,r,L,R);  
        if(segtree[L(rt)].rc == segtree[R(rt)].lc)  
            ans--;  
        return ans;  
    }  
    push_up(rt);  
}  
int solve(int u,int v,int id,int c){  
    int ans=0;  
    if(id == 1){  
        while(top[u]!=top[v]){  
            if(dep[top[u]]<dep[top[v]])  
                swap(u,v);  
            update(1,pos[top[u]],pos[u],c);  
            u=fa[top[u]];  
        }  
        if(dep[u]>dep[v])  
            swap(u,v);  
        update(1,pos[u],pos[v],c);  
    }  
    else{  
        //printf("u=%d v=%d pos[u]=%d pos[v]=%d\n",u,v,pos[u],pos[v]);  
        int ans1=-1,ans2=-1; //记录上次链的左端的颜色  
        while(top[u]!=top[v]){  
            if(dep[top[u]]<dep[top[v]]){  
                swap(u,v); swap(ans1,ans2);  
            }  
            ans+=query(1,pos[top[u]],pos[u],pos[top[u]],pos[u]);  
            if(Rc == ans1)  
                ans--;  
           // printf("u=%d top[u]=%d Lc=%d Rc=%d ans=%d\n",u,top[u],Lc,Rc,ans);  
            ans1=Lc; u=fa[top[u]];  
        }  
        if(dep[u]<dep[v]){  
            swap(u,v); swap(ans1,ans2);  
        }  
        ans+=query(1,pos[v],pos[u],pos[v],pos[u]);  
        if(Rc == ans1)  
            ans--;  
        if(Lc == ans2)  
            ans--;  
        //printf("u=%d v=%d Lc=%d Rc=%d ans=%d\n",u,v,Lc,Rc,ans);  
    }  
    return ans;  
}  
int main(){  
    //freopen("in.txt","r",stdin);  
    while(~scanf("%d%d",&n,&m)){  
        init();  
        for(int i=1;i<=n;i++)  
            scanf("%d",&col[i]);  
        for(int i=1;i<n;i++){  
            int u,v;  
            scanf("%d%d",&u,&v);  
            addedge(u,v); addedge(v,u);  
        }  
        dfs1(1,1,1); dfs2(1,1); build(1,1,n);  
        //<F9>printf("%d %d\n",son[1],son[2]);  
        /*for(int i=1;i<=n;i++) 
            printf("top[i]=%d pos[i]%d\n",top[i],pos[i]); 
        printf("---------------------------------------\n"); 
        printf("\n");*/  
        for(int i=1;i<=n;i++)  
            update(1,pos[i],pos[i],col[i]);  
        while(m--){  
            scanf("%s",str);  
            int u,v;  
            if(str[0] == 'C'){  
                int c;  
                scanf("%d%d%d",&u,&v,&c);  
                solve(u,v,1,c);  
            }  
            else{  
                int u,v;  
                scanf("%d%d",&u,&v);  
                printf("%d\n",solve(u,v,2,0));  
                //printf("--------------------------------------\n");  
            }  
        }  
    }  
    return 0;  
}
```

---

## 作者：yyb_test (赞：78)

# [SDOI2011]染色

这道题有两种解法，树剖&LCT
但是实现方法却截然不同
做完本题后对树剖和LCT会有更深的认识
让我们充分认识到两者之间的优缺点

## 题解 1 -- 树链剖分
优点：暴力，直接

缺点：代码量大，常数大（毕竟是优雅的暴力）

做法：

**一、线段树：**

需要多维护两个值，lc和rc，分别记录右端
点和左端点的颜色。

在合并两个子区间的时候，如果左区间的右端点颜色=右区间的左端点颜色，则颜色带数量-1

**二、路径求和**

当然不能naive地把路径上的颜色带累加

我们发现树剖求LCA是利用两个点按照深度向上跳最后跳到一起的方法

** 自下而上，根据深度交替向上跳 **

而这个路径可以看成‘人’字型

![](http://images.cnblogs.com/cnblogs_com/tply/1142800/o_graph.png)

我们不妨把这个路径分成两边

左边和右边

我们再用变量

pos1表示**当前要往上跳的路径\上次的终点颜色**

pos2表示**另一条路径\上一次的终点颜色**

这样，如果**当前往上跳的路径\这次的起点颜色**等于 **当前要往上跳的路径\上次的终点颜色**
那么颜色段数量-1

如果**当前要往上跳的节点所在路径**发生了改变（也就是路径发生了交替），则```swap(pos1,pos2)```

然后问题就落到如何找起点终点颜色了

很简单，起点颜色就是线段树上**查询的左端点**的颜色，终点颜色就是**查询的右端点**的颜色。

在往上跳（线段树查询）的时候顺便记录一下Lc和Rc即可
```cpp
#include <algorithm>
#include <iostream>
#include <cstring>
#include <cstdio>
#include <vector>
#include <queue>

#define rg register int
#define ll long long
#define RG register 
#define il inline

using namespace std;

il int gi() {
    rg x=0,o=0;RG char ch=getchar();
    while(ch!='-'&&(ch<'0'||'9'<ch)) ch=getchar();
    if(ch=='-') o=1,ch=getchar();
    while('0'<=ch&&ch<='9') x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
    return o?-x:x;
}

#define SZ 1000002

int n,m,pos1,pos2,lc,rc,col[SZ];
char ch;

struct Edge { int to,nxt; }e[SZ<<1];
int Ehead[SZ],Ecnt=2;
il void Eadd(rg u,rg v) {
    e[Ecnt]=(Edge){v,Ehead[u]};
    Ehead[u]=Ecnt++;
    e[Ecnt]=(Edge){u,Ehead[v]};
    Ehead[v]=Ecnt++;
}

int cnt,fa[SZ],id[SZ],rid[SZ],siz[SZ],dep[SZ],son[SZ],top[SZ];
il void pou_debug() {
    for(rg i=1; i<=n; ++i) 
        printf("fa:%d id:%d son:%d siz:%d dep:%d top:%d\n",fa[i],id[i],son[i],siz[i],dep[i],top[i]);
    
}
void dfs1(rg u,rg ff) {
    fa[u]=ff,dep[u]=dep[ff]+1,siz[u]=1;
    for(rg v,i=Ehead[u]; i; i=e[i].nxt) {
        v=e[i].to;
        if(v==ff) continue;
        dfs1(v,u);
        siz[u]+=siz[v];
        if(siz[v]>siz[son[u]]) son[u]=v;
    }
}	
void dfs2(rg u,rg tp) {
    top[u]=tp,id[u]=++cnt,rid[cnt]=u;
    if(!son[u]) return;
    dfs2(son[u],tp);
    for(rg v,i=Ehead[u]; i; i=e[i].nxt) {
        v=e[i].to;
        if(v==son[u]||v==fa[u]) continue;
        dfs2(v,v);
    }
} 

#define lson rt<<1
#define rson rt<<1|1
struct Segtree { int l,r,lc,rc,c,v;  }tr[SZ<<4];
il void Seg_debug() {
    for(rg i=1; i<=n*3; ++i) 
        printf("#%d : l:%d r:%d lc:%d rc:%d c:%d v:%d\n",i,tr[i].l,tr[i].r,tr[i].lc,tr[i].rc,tr[i].c,tr[i].v);
}
il void pushup(rg rt) {
    tr[rt].v=tr[lson].v+tr[rson].v;
    if(tr[lson].rc==tr[rson].lc) --tr[rt].v;
    tr[rt].lc=tr[lson].lc;
    tr[rt].rc=tr[rson].rc;
}
il void pushcol(rg rt,rg col) {
    tr[rt].lc=tr[rt].rc=col;
    tr[rt].v=1,tr[rt].c=col;
}
il void pushdown(rg rt) {
    if(tr[rt].c) {
        if(lson) pushcol(lson,tr[rt].c);
        if(rson) pushcol(rson,tr[rt].c);
        tr[rt].c=0;
    }
}
void build(rg rt,rg l,rg r) {
    tr[rt].l=l,tr[rt].r=r;
    if(l==r) {
        tr[rt].lc=tr[rt].rc=col[rid[l]];
        tr[rt].v=1;
        return;
    }
    rg mid=l+r>>1;
    build(lson,l,mid);
    build(rson,mid+1,r);
    pushup(rt);
}
void modify(rg rt,rg L,rg R,rg x) {
    rg l=tr[rt].l,r=tr[rt].r;
    if(L<=l&&r<=R) {
        pushcol(rt,x);
        return;
    }
    pushdown(rt);
    rg mid=l+r>>1;
    if(L<=mid) modify(lson,L,R,x);
    if(R>mid) modify(rson,L,R,x);
    pushup(rt);
}
int query(rg rt,rg L,rg R) {
    rg l=tr[rt].l,r=tr[rt].r;	
    if(L<=l&&r<=R) {
    	if(l==L) lc=tr[rt].lc;
    	if(r==R) rc=tr[rt].rc;      
    	return tr[rt].v;  
    }
    pushdown(rt);
    rg mid=l+r>>1;
    if(R<=mid) return query(lson,L,R);
    if(L>mid)  return query(rson,L,R);
    rg ret=query(lson,L,R)+query(rson,L,R);
    if(tr[lson].rc==tr[rson].lc) --ret;
    return ret; 
}
il void add(rg u,rg v,rg c) {
    while(top[u]!=top[v]) {
        if(dep[top[u]]<dep[top[v]]) swap(u,v);
        modify(1,id[top[u]],id[u],c);
        u=fa[top[u]];
    }
    if(id[u]>id[v]) swap(u,v);
    modify(1,id[u],id[v],c);
}
il int ask(rg u,rg v) {
    rg ret=0;
    pos1=pos2=0;
    while(top[u]!=top[v]) {
        if(dep[top[u]]<dep[top[v]]) swap(u,v),swap(pos1,pos2);		
        ret+=query(1,id[top[u]],id[u]);
        if(rc==pos1) --ret;
        pos1=lc,u=fa[top[u]];
    }
    if(id[u]>id[v]) swap(u,v),swap(pos1,pos2);
    ret+=query(1,id[u],id[v]);
    if(lc==pos1) --ret;
    if(rc==pos2) --ret; 
    return ret;
}

int main() {
    n=gi(),m=gi();
    for(rg i=1; i<=n; ++i) col[i]=gi();
    for(rg u,v,i=1; i<n; ++i) 
        u=gi(),v=gi(),Eadd(u,v);
    dfs1(1,0);
    dfs2(1,1);
    build(1,1,n);
    for(rg a,b,c,i=1; i<=m; ++i) {
        ch=getchar();
        while(ch!='C'&&ch!='Q') ch=getchar();
        if(ch=='C') {
            a=gi(),b=gi(),c=gi();
            add(a,b,c);
        }
        if(ch=='Q') {
            a=gi(),b=gi();
            printf("%d\n",ask(a,b));
        }
    }
    return 0;
}
```
## 题解2--LCT
优点：常数小，代码短

缺点：难想，难实现，细节多

做法：

我们考虑把连接不同色点的边权值设为1,连接同色的点的边权设为0，这样我们就可以把问题转化为查询这条路径上所有的边权和，你要输出的就是这个答案加一

对于维护，我们对每个splay节点一个最左端点的值和最右端点的颜色，这样，对于它的父亲节点，就可以很轻松地找到其前驱与后继的颜色，这样便可以累计它跟前驱后继所连边的权值和了。

前驱=左儿子最右端点，后继=右儿子最左端点

** 注意：区间反转时最左和最右端点也要反转 **
```cpp
#include <algorithm>
#include <iostream>
#include <cstring>
#include <cstdio>
#include <vector>
#include <queue>

#define rg register int
#define ll long long
#define RG register 
#define il inline

using namespace std;

il int gi() {
    rg x=0,o=0;RG char ch=getchar();
    while(ch!='-'&&(ch<'0'||'9'<ch)) ch=getchar();
    if(ch=='-') o=1,ch=getchar();
    while('0'<=ch&&ch<='9') x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
    return o?-x:x;
}
#define SZ 1000010
int n,m;
char ch;

#define lson tr[x].ch[0]
#define rson tr[x].ch[1]
struct Splaytree { int w,c,lc,rc,tag,rev,fa,ch[2]; }tr[SZ];
int stk[SZ],top;

il bool isroot(rg x) { return tr[tr[x].fa].ch[0]!=x&&tr[tr[x].fa].ch[1]!=x; }

il void pushdown(rg x) {
    if(tr[x].rev) {
        swap(lson,rson);
        swap(tr[lson].lc,tr[lson].rc);
        swap(tr[rson].lc,tr[rson].rc);
        tr[lson].rev^=1,tr[rson].rev^=1;
        tr[x].rev=0;
    }
    if(tr[x].tag) {
        tr[x].lc=tr[x].rc=tr[x].c=tr[x].tag;
        tr[lson].tag=tr[rson].tag=tr[x].tag;
        tr[x].w=tr[x].tag=0;
    }
}

il void pushup(rg x) {
    pushdown(lson),pushdown(rson);
    tr[x].w=tr[lson].w+tr[rson].w;
    if(lson) {
        tr[x].lc=tr[lson].lc;
        if(tr[x].c!=tr[lson].rc) ++tr[x].w;
    }
    else tr[x].lc=tr[x].c;
    if(rson) {
        tr[x].rc=tr[rson].rc;
        if(tr[x].c!=tr[rson].lc) ++tr[x].w;
    }
    else tr[x].rc=tr[x].c;
}

il void rotate(rg x) {
    rg y=tr[x].fa,z=tr[y].fa;
    rg k=tr[y].ch[1]==x;
    if(!isroot(y)) tr[z].ch[tr[z].ch[1]==y]=x;  tr[x].fa=z;
    tr[y].ch[k]=tr[x].ch[k^1],tr[tr[x].ch[k^1]].fa=y;
    tr[x].ch[k^1]=y,tr[y].fa=x;
    pushup(y);
}

il void splay(rg x) {
    stk[top=1]=x;
    for(rg i=x; !isroot(i); i=tr[i].fa) stk[++top]=tr[i].fa;
    while(top) pushdown(stk[top--]);
    while(!isroot(x)) {
        rg y=tr[x].fa,z=tr[y].fa;
        if(!isroot(y))
            (tr[y].ch[0]==x)^(tr[z].ch[0]==y)?rotate(x):rotate(y);
        rotate(x);	
    }
    pushup(x);
}

il void access(rg x) {
    for(rg y=0; x; y=x,x=tr[x].fa) splay(x),rson=y,pushup(x);
}

il void makeroot(rg x) {
    access(x),splay(x),tr[x].rev^=1;
}

il int findroot(rg x) {
    access(x),splay(x);
    while(lson) x=lson;
    return x;
}

il void split(rg x,rg y) {
    makeroot(x),access(y),splay(y);
}

il void link(rg x,rg y) {
    makeroot(x),tr[x].fa=y;
}

int main() {
    n=gi(),m=gi();
    for(rg i=1; i<=n; ++i) tr[i].c=tr[i].lc=tr[i].rc=gi();
    for(rg u,v,i=1; i<n; ++i) u=gi(),v=gi(),link(u,v);
    for(rg a,b,c,i=1; i<=m; ++i) {
        ch=getchar();
        while(ch!='C'&&ch!='Q') ch=getchar();
        if(ch=='C') {
            a=gi(),b=gi(),c=gi();
            split(a,b);
            tr[b].tag=c;
        }
        if(ch=='Q') {
            a=gi(),b=gi();
            split(a,b);
            printf("%d\n",tr[b].w+1);
        }
    }
    return 0;
}
```
[博客链接](http://www.cnblogs.com/tply/p/8798904.html)

---

## 作者：天上一颗蛋 (赞：52)

# 写在前面

对于刚学树剖的同学~~比如我这种**大大大**蒟蒻~~来说，做这题会给你带来很大的提升：不仅可以对树剖有更深刻的理解，还可以更好的理解线段树，所以这是一道好题哦

为了更好懂，我一点一点说说思路吧

# 思路

首先这题题意不难懂，只有两个操作：区间颜色修改和区间查询颜色数量，我们分开来看：

## 区间查询颜色个数

这是这题的难点，弄懂了以后可以对线段树有个蛮大的提升吧

我们先把问题简化一下，假设这不是一棵树，只是一条连（已经树剖过了），给定每个元素的颜色，问有几段颜色（就是这题中颜色数量的定义），我们怎么做呢？

首先我们可以知道，为了保障时间复杂度，这题肯定是用线段树求解的，最先想到的是**叶子节点的颜色个数为1**，因为此时不存在有颜色会重复，按线段树的做法，现在要回溯求更大区间的颜色个数了，我们怎样求解呢？

其实分情况讨论一下就可以知道了：见下

第一种情况：

左区间：1231（颜色个数为4） 右区间：222（个数为1）

合并后：1231222（颜色个数为4+1=5）

这是第一种情况：没有重复

我们再来看第二种：

左区间：1231（颜色个数为4）右区间：121（个数为3）

合并后：1231121（颜色个数为4+3-1）

这就是第二种情况了，**左区间的最后一个颜色和右区间的第一个颜色重合**，也就重复了，所以总数减一

综上所述：我们用数组lc[ ]和rc[ ]表示区间左右颜色，线段树维护区间颜色总数，就可以解决链情况下的此问题了
```cpp
int lc[maxn << 2];//这里要开4倍大小，因为是对应线段树节点的
int rc[maxn << 2];
void build(int id,int l,int r){
	tree[id].l = l;
	tree[id].r = r;
	if(l == r){
		tree[id].c = col[ori[l]];//赋值：叶子颜色
		lc[id] = rc[id] = col[ori[l]];//赋值：区间左颜色和区间右颜色
		tree[id].sum = 1;//颜色数为1
		return ;
		}
	int mid = l + r >> 1;
	build(lid,l,mid);
	build(rid,mid + 1,r);
	tree[id].sum = tree[lid].sum + tree[rid].sum;
	if(rc[lid] == lc[rid])tree[id].sum -= 1;
	lc[id] = lc[lid];
	rc[id] = rc[rid];
	}
void pushdown(int id){
	if(tree[id].lazy != 0 && tree[id].l != tree[id].r){
		int c = tree[id].lazy;
		tree[lid].lazy = tree[rid].lazy = c;//粉刷
		tree[lid].c = tree[rid].c = c;
		lc[lid] = rc[lid] = lc[rid] = rc[rid] = c;//更新左右
		tree[lid].sum = tree[rid].sum = 1;//粉刷完以后只有一种颜色了
		tree[id].lazy = 0;
		}
	}
int query(int id,int l,int r){
	pushdown(id);
	if(tree[id].l == l && tree[id].r == r){
		return tree[id].sum;
		}
	int mid = tree[id].l + tree[id].r >> 1;
	if(mid < l){
		return query(rid,l,r);
		}
	else if(mid >= r){
		return query(lid,l,r);
		}
	else{
		int ret = query(lid,l,mid) + query(rid,mid + 1,r);
		if(rc[lid] == lc[rid])ret -= 1;
		return ret;
		}
	}
```


值得注意的是：**不要忘记大区间要继承小区间的左右端点颜色**

## 树上查询颜色个数

我们的操作时基于树形的，所以树剖过后，我们树剖的查询函数要略作修改。

![](https://cdn.luogu.com.cn/upload/pic/15749.png)

如上图：树剖就是把两点之间剖成了若干条链，我们还是要解决不同的链之间颜色重复问题。上图已经很明朗了：解决top[a]与fa[top[a]]颜色重复问题即可：

我写了个函数Qc来查询单点的颜色，其他学过树剖的应该不会太陌生：

```cpp
int query(int id,int l,int r){
	pushdown(id);
	if(tree[id].l == l && tree[id].r == r){
		return tree[id].sum;
		}
	int mid = tree[id].l + tree[id].r >> 1;
	if(mid < l){
		return query(rid,l,r);
		}
	else if(mid >= r){
		return query(lid,l,r);
		}
	else{
		int ret = query(lid,l,mid) + query(rid,mid + 1,r);
		if(rc[lid] == lc[rid])ret -= 1;
		return ret;
		}
	}
int Qc(int id,int l,int r){
	pushdown(id);
	if(tree[id].l == l && tree[id].r == r){
		return tree[id].c;
		}
	int mid = tree[id].l + tree[id].r >> 1;
	if(mid < l)return Qc(rid,l,r);
	else return Qc(lid,l,r);
	}
int Qsum(int x,int y){
	int ans = 0,Cson,Cfa;//儿子的颜色，爸爸的颜色
	while(top[x] != top[y]){
		if(dep[top[x]] < dep[top[y]])swap(x,y);
		ans += query(1,pos[top[x]],pos[x]);//累加答案
		Cson = Qc(1,pos[top[x]],pos[top[x]]);
		Cfa = Qc(1,pos[fa[top[x]]],pos[fa[top[x]]]);
		if(Cson == Cfa)ans -= 1;//重复则答案减一
		x = fa[top[x]];
		}
	if(dep[x] > dep[y])swap(x,y);
	ans += query(1,pos[x],pos[y]);
	return ans;
	}
```

## 区间修改

与普通的树剖题修改无大异，注意线段树中的颜色数量更新即区间端点继承即可

```cpp
void update(int id,int c,int l,int r){
	pushdown(id);
	if(tree[id].l == l && tree[id].r == r){
		tree[id].c = c;
		tree[id].lazy = c;
		tree[id].sum = 1;
		lc[id] = rc[id] = c;
		return ;
		}
	int mid = tree[id].l + tree[id].r >> 1;
	if(mid < l){
		update(rid,c,l,r);
		}
	else if(mid >= r){
		update(lid,c,l,r);
		}
	else{
		update(lid,c,l,mid);
		update(rid,c,mid + 1,r);
		}
	tree[id].sum = tree[lid].sum + tree[rid].sum;
	if(rc[lid] == lc[rid])tree[id].sum -= 1;
	lc[id] = lc[lid];
	rc[id] = rc[rid];
	}
void uprange(int x,int y,int c){
	while(top[x] != top[y]){
		if(dep[top[x]] < dep[top[y]])swap(x,y);
		update(1,c,pos[top[x]],pos[x]);
		x = fa[top[x]];
		}
	if(dep[x] > dep[y])swap(x,y);
	update(1,c,pos[x],pos[y]);
	}
```

# AC代码

就不多提啦，祝大家天天AC！

（重要注释已经打在上面思路部分了，这里直接给代码）

```cpp
#include<iostream>
#include<cstdio>
#include<queue>
#include<cstring>
#include<algorithm>
using namespace std;
int RD(){
    int out = 0,flag = 1;char c = getchar();
    while(c < '0' || c >'9'){if(c == '-')flag = -1;c = getchar();}
    while(c >= '0' && c <= '9'){out = out * 10 + c - '0';c = getchar();}
    return flag * out;
    }
const int maxn = 100019;
int num,na,nume,cnt;
int head[maxn];
struct Node{int v,nxt;}E[maxn * 2];
void add(int u,int v){
    E[++nume].nxt = head[u];
    E[nume].v = v;
    head[u] = nume;
    }
int size[maxn],wson[maxn],dep[maxn],fa[maxn],top[maxn],pos[maxn],ori[maxn];
int col[maxn];
void dfs1(int id,int F){
    size[id] = 1;
    for(int i = head[id];i;i = E[i].nxt){
        int v = E[i].v;
        if(v == F)continue;
        dep[v] = dep[id] + 1;
        fa[v] = id;
        dfs1(v,id);
        size[id] += size[v];
        if(size[v] > size[wson[id]])wson[id] = v;
        }
    }
void dfs2(int id,int TP){
    top[id] = TP;
    pos[id] = ++cnt;
    ori[cnt] = id;
    if(!wson[id])return ;
    dfs2(wson[id],TP);
    for(int i = head[id];i;i = E[i].nxt){
        int v = E[i].v;
        if(v == fa[id] || v == wson[id])continue;
        dfs2(v,v);
        }
    }
int lc[maxn << 2];
int rc[maxn << 2];
#define lid (id << 1)
#define rid (id << 1) | 1
struct sag_tree{
	int l,r;
	int sum,c;//区间颜色总数，叶子颜色
	int lazy;//儿子的颜色
	}tree[maxn << 2];
void build(int id,int l,int r){
	tree[id].l = l;
	tree[id].r = r;
	if(l == r){
		tree[id].c = col[ori[l]];//赋值：叶子颜色
		lc[id] = rc[id] = col[ori[l]];//赋值：区间左颜色和区间右颜色
		tree[id].sum = 1;//颜色数为1
		return ;
		}
	int mid = l + r >> 1;
	build(lid,l,mid);
	build(rid,mid + 1,r);
	tree[id].sum = tree[lid].sum + tree[rid].sum;
	if(rc[lid] == lc[rid])tree[id].sum -= 1;
	lc[id] = lc[lid];
	rc[id] = rc[rid];
	}
void pushdown(int id){
	if(tree[id].lazy != 0 && tree[id].l != tree[id].r){
		int c = tree[id].lazy;
		tree[lid].lazy = tree[rid].lazy = c;//粉刷
		tree[lid].c = tree[rid].c = c;
		lc[lid] = rc[lid] = lc[rid] = rc[rid] = c;//更新左右
		tree[lid].sum = tree[rid].sum = 1;//粉刷完以后只有一种颜色了
		tree[id].lazy = 0;
		}
	}
void update(int id,int c,int l,int r){
	pushdown(id);
	if(tree[id].l == l && tree[id].r == r){
		tree[id].c = c;
		tree[id].lazy = c;
		tree[id].sum = 1;
		lc[id] = rc[id] = c;
		return ;
		}
	int mid = tree[id].l + tree[id].r >> 1;
	if(mid < l){
		update(rid,c,l,r);
		}
	else if(mid >= r){
		update(lid,c,l,r);
		}
	else{
		update(lid,c,l,mid);
		update(rid,c,mid + 1,r);
		}
	tree[id].sum = tree[lid].sum + tree[rid].sum;
	if(rc[lid] == lc[rid])tree[id].sum -= 1;
	lc[id] = lc[lid];
	rc[id] = rc[rid];
	}
int query(int id,int l,int r){
	pushdown(id);
	if(tree[id].l == l && tree[id].r == r){
		return tree[id].sum;
		}
	int mid = tree[id].l + tree[id].r >> 1;
	if(mid < l){
		return query(rid,l,r);
		}
	else if(mid >= r){
		return query(lid,l,r);
		}
	else{
		int ret = query(lid,l,mid) + query(rid,mid + 1,r);
		if(rc[lid] == lc[rid])ret -= 1;
		return ret;
		}
	}
int Qc(int id,int l,int r){
	pushdown(id);
	if(tree[id].l == l && tree[id].r == r){
		return tree[id].c;
		}
	int mid = tree[id].l + tree[id].r >> 1;
	if(mid < l)return Qc(rid,l,r);
	else return Qc(lid,l,r);
	}
void uprange(int x,int y,int c){
	while(top[x] != top[y]){
		if(dep[top[x]] < dep[top[y]])swap(x,y);
		update(1,c,pos[top[x]],pos[x]);
		x = fa[top[x]];
		}
	if(dep[x] > dep[y])swap(x,y);
	update(1,c,pos[x],pos[y]);
	}
int Qsum(int x,int y){
	int ans = 0,Cson,Cfa;
	while(top[x] != top[y]){
		if(dep[top[x]] < dep[top[y]])swap(x,y);
		ans += query(1,pos[top[x]],pos[x]);
		Cson = Qc(1,pos[top[x]],pos[top[x]]);
		Cfa = Qc(1,pos[fa[top[x]]],pos[fa[top[x]]]);
		if(Cson == Cfa)ans -= 1;
		x = fa[top[x]];
		}
	if(dep[x] > dep[y])swap(x,y);
	ans += query(1,pos[x],pos[y]);
	return ans;
	}
int main(){
	num = RD();na = RD();
	for(int i = 1;i <= num;i++)col[i] = RD();
	int u,v;
	for(int i = 1;i <= num - 1;i++){
		u = RD();v = RD();
		add(u,v);
		add(v,u);
		}
	dfs1(1,-1);
	dfs2(1,1);
	build(1,1,num);
	char ask;
	int c;
	for(int i = 1;i <= na;i++){
		cin>>ask;
		if(ask == 'Q'){
			u = RD();v = RD();
			printf("%d\n",Qsum(u,v));
			}
		else{
			u = RD();v = RD();c = RD();
			uprange(u,v,c);
			}
		}
	return 0;
	}
```

最后，虽然dalao没帮啥忙，可是我是看大佬以前的代码查出错的，[宣传一下大佬](https://www.luogu.org/space/show?uid=32842)

最后当然是大家最喜欢的[广告](https://www.luogu.org/blog/QVQ/)啦

---

## 作者：fyfy (赞：41)

树剖，用线段树维护：

数组tot[N]表示此时的颜色段数。

数组zzz[N]表示此时最左边的节点的颜色。

数组yyy[N]表示此时最右边的节点的颜色。


则：
首先我们要明确，线段树的叶子节点一定只有一种颜色，也就是一条颜色段。

tot[父亲]=tot[左儿子]+tot[右儿子]；

if (zzz[右儿子]==yyy[左儿子]) {tot[父亲]--;}

即如果右儿子的最左边颜色和左儿子的最右边颜色相同，那么肯定有中间部分属于同一颜色段。


代码：

    
    
    
    
    
    
    
    
    
    
    
    
    
```cpp
    //fushao zuishuai
    #include <cstdio>
    #include <cstring>
    #include <iostream>
    #define k (z+y>>1)
    #define ll (r<<1)
    #define rr (r<<1|1)
    using namespace std;
    const int N=1e5+10;int a[N];
    int ys[N],s[N*2][2],o[N],cnt,dfn,n;
    int zzz[N*4],yyy[N*4],laz[N*4],tot[N*4];
    int d[N],siz[N],son[N],top[N],f[N],id[N];
    void jia(int a,int b)
    {
        s[++cnt][1]=o[a];
        s[cnt][0]=b;o[a]=cnt;
        return;
    }
    void shang(int r)
    {
        tot[r]=tot[ll]+tot[rr];
        zzz[r]=zzz[ll];yyy[r]=yyy[rr];
        if (zzz[rr]==yyy[ll]) tot[r]--;
        return;
    }
    void xiangxia(int r,int z,int y)
    {
        tot[ll]=tot[rr]=1;
        zzz[ll]=zzz[rr]=yyy[ll]=yyy[rr]=laz[ll]=laz[rr]=laz[r];
        laz[r]=0;return;
    }
    void jianshu(int r,int z,int y)
    {
        if (z==y) {
            tot[r]=1;zzz[r]=yyy[r]=ys[a[z]];
            return;
        }
        jianshu(ll,z,k);jianshu(rr,k+1,y);
        shang(r);return;
    }
    void gai(int r,int z,int y,int zz,int yy,int v)
    {
        if (z==zz&&y==yy) {
            tot[r]=1;laz[r]=zzz[r]=yyy[r]=v;
            return;
        }
        if (laz[r]) xiangxia(r,z,y);
        if (zz>k) gai(rr,k+1,y,zz,yy,v);
        else if (yy<=k) gai(ll,z,k,zz,yy,v);
        else {gai(ll,z,k,zz,k,v);gai(rr,k+1,y,k+1,yy,v);}
        shang(r);return;
    }
    int chaxun(int r,int z,int y,int zz,int yy)
    {
        if (z==zz&&y==yy) return tot[r];
        if (laz[r]) xiangxia(r,z,y);
        if (zz>k) chaxun(rr,k+1,y,zz,yy);
        else if (yy<=k) chaxun(ll,z,k,zz,yy);
        else {
            int ans=chaxun(ll,z,k,zz,k)+chaxun(rr,k+1,y,k+1,yy);
            if (zzz[rr]==yyy[ll]) ans--;
            return ans;
        }
    }
    void dfs1(int x,int fa,int dep)
    {
        f[x]=fa;d[x]=dep;siz[x]=1;
        for (int i=o[x];i;i=s[i][1]) {
            if (s[i][0]!=fa) {
                dfs1(s[i][0],x,dep+1);
                siz[x]+=siz[s[i][0]];
                if (siz[s[i][0]]>siz[son[x]]) son[x]=s[i][0];
            }
        }
        return;
    }
    void dfs2(int x,int tp)
    {
        top[x]=tp;id[x]=++dfn;a[dfn]=x;
        if (son[x]) dfs2(son[x],tp);
        for (int i=o[x];i;i=s[i][1])
        if (s[i][0]!=f[x]&&son[x]!=s[i][0])
        dfs2(s[i][0],s[i][0]);
        return;
    }
    void ranse(int x,int y,int v)
    {
        while (top[x]!=top[y]) {
            if (d[top[x]]>d[top[y]]) swap(x,y);
            gai(1,1,n,id[top[y]],id[y],v);
            y=f[top[y]];
        }
        if (d[x]>d[y]) swap(x,y);
        gai(1,1,n,id[x],id[y],v);
        return;
    }
    int newww(int r,int z,int y,int p)
    {
        if (z==y) return zzz[r];
        if (laz[r]) xiangxia(r,z,y);
        if (p>k) return newww(rr,k+1,y,p);
        else return newww(ll,z,k,p);
    }
    int xunwen(int x,int y)
    {
        int ans=0,nc,fc;
        while (top[x]!=top[y]) {
            if (d[top[x]]>d[top[y]]) swap(x,y);
            ans+=chaxun(1,1,n,id[top[y]],id[y]);
            nc=newww(1,1,n,id[top[y]]);
            fc=newww(1,1,n,id[f[top[y]]]);
            y=f[top[y]];if (nc==fc) ans--;
        }
        if (d[x]>d[y]) swap(x,y);
        ans+=chaxun(1,1,n,id[x],id[y]);
        return ans?ans:1;
    }
    int main()
    {
        int m,a,b,c;
        cin>>n>>m;char caozuo[5];
        for (int i=1;i<=n;i++) scanf("%d",&ys[i]);
        for (int i=1;i<n;i++) {
            scanf("%d%d",&a,&b);jia(a,b);jia(b,a);
        }
        dfs1(1,0,1);dfs2(1,1);jianshu(1,1,n);
        while (m--) {
            scanf("%s",caozuo);
            scanf("%d%d",&a,&b);
            switch (caozuo[0]) {
                case 'C':scanf("%d",&c);
                ranse(a,b,c);break;
```
default:

```cpp
                printf("%d\n",xunwen(a,b));break;
            }
        }
        //zhu wo zao dian AC!!!
        return 0;
    }
ok!!!
```

---

## 作者：emptysetvvvv (赞：40)

## 轻重链剖分

### 思路

本题的思维难度很小，用线段树维护区间颜色段数，重点在如何实现去重。

现有的轻重链剖分题解，基本上都是开了空间大小为 4 倍的 $\mathtt{lc,rc}$ 数组，分别维护区间左右端点颜色，其实根本没有必要，

一个 1 倍空间的 $\mathtt{col}$ 数组足以解决问题，而且贼好写。

1. **线段树上合并时的去重**（左儿子右端点 和 右儿子左端点）

我们用 $\mathtt{sum[i]}$ 表示 $i$ 所管辖区间内的颜色段数。若 $i$ 所管辖的区间为 $\mathtt{[l,r]}$，那么左儿子管辖区间为 $\mathtt{[l,mid]}$，右儿子管辖区间为 $\mathtt{[mid+1,r]}$，我们**想要判断合并时会不会计重，其实只是想知道 $\mathtt{col[mid]}$ 是否等于 $\mathtt{col[mid+1]}$**；

这样的好处是：**上方的节点不用继承儿子的颜色**，因为我们只要知道 $i$ 的管辖区间，就可以知道左右端点的颜色。

同样的，懒标记下传时，只需要将左儿子右端点 $\mathtt{col[mid]}$ 和右儿子左端点 $\mathtt{col[mid+1]}$ 修改就可以了。

2. **重链跳跃时的去重**（重链连接处 即 轻链两端点）

大部分题解都通过记录上次跳跃位置实现，之所以要记录上次跳的位置，是因为**由于有懒标记，只有查询后的颜色才是正确的（该下放的都下放了）。**

其实有一种更好写的方法，我们可以在全部查完后，重新跳一遍来判断重链连接处，详见代码。

### 代码

```cpp
#include <cstdio>
#include <vector>
using namespace std;
const int maxn = 100005;
int n, m, o[maxn], col[maxn];
vector<int> e[maxn];
int dep[maxn], fa[maxn], son[maxn], size[maxn];//dfs1
int dfn[maxn], top[maxn], clk;//clk:dfs_clock dfs2
struct SegTree {
	int sum[maxn<<2], tag[maxn<<2];
	#define ls i<<1
	#define rs i<<1|1
	inline void push_up(int i, int mid) { 
		sum[i] = sum[ls] + sum[rs];
		if(col[mid] == col[mid+1]) --sum[i];
	}
	inline void push_down(int i, int mid) {
		tag[ls] = tag[rs] = col[mid] = col[mid+1] = tag[i];
		sum[ls] = sum[rs] = 1;
		tag[i] = 0;
	}
	void build(int i, int l, int r) {
		if(l == r) { sum[i] = 1; return; }
		int mid = (l+r) >> 1;
		build(ls, l, mid);
		build(rs, mid+1, r);
		push_up(i, mid);
	}
	void ins(int i, int l, int r, int x, int y, int k) {
		if(x <= l and r <= y) { sum[i] = 1; col[l] = col[r] = tag[i] = k; return; }
		int mid = (l+r) >> 1;
		if(tag[i]) push_down(i, mid);
		if(x <= mid) ins(ls, l, mid, x, y, k);
		if(y > mid) ins(rs, mid+1, r, x, y, k);
		push_up(i, mid);
	}
	int query(int i, int l, int r, int x, int y) {
		if(x <= l and r <= y) return sum[i];
		int mid = (l+r) >> 1, ans = 0;
		if(tag[i]) push_down(i, mid);
		if(x <= mid) ans = query(ls, l, mid, x, y);
		if(y > mid) ans += query(rs, mid+1, r, x, y);
		if(x <= mid and y > mid and col[mid] == col[mid+1]) --ans;
		return ans;
	}
} t;
void dfs1(int u, int f) {
	fa[u] = f;
	dep[u] = dep[f] + 1;
	size[u] = 1;
	for(auto v : e[u])
		if(v != f) {
			dfs1(v, u);
			size[u] += size[v];
			if(size[v] > size[son[u]]) son[u] = v;
		} 
}
void dfs2(int u, int topf) {
	dfn[u] = ++clk;
	col[clk] = o[u];
	top[u] = topf;
	if(!son[u]) return;
	dfs2(son[u], topf);
	for(auto v : e[u])
		if(!dfn[v]) dfs2(v, v);
}
void modify(int x, int y, int k) {
	while(top[x] != top[y]) {
		if(dep[top[x]] < dep[top[y]]) swap(x, y);
		t.ins(1, 1, n, dfn[top[x]], dfn[x], k);
		x = fa[top[x]];
	}
	if(dfn[x] > dfn[y]) swap(x, y);
	t.ins(1, 1, n, dfn[x], dfn[y] ,k);
}
int inquire(int x, int y) {
	int u = x, v = y, ans = 0;//记录 x,y 因为还要跳第二次
	while(top[x] != top[y]) {
		if(dep[top[x]] < dep[top[y]]) swap(x, y);
		ans += t.query(1, 1, n, dfn[top[x]], dfn[x]);
		x = fa[top[x]];
	}
	if(dfn[x] > dfn[y]) swap(x, y);
	ans += t.query(1, 1, n, dfn[x], dfn[y]);
	while(top[u] != top[v]) {
		if(dep[top[u]] < dep[top[v]]) swap(u, v);
		if(col[dfn[top[u]]] == col[dfn[fa[top[u]]]]) --ans;
		u = fa[top[u]];//top[u] 和 fa[top[u]] 是轻链端点
	}
	return ans;
}
char c[2];
int main() {
	scanf("%d %d", &n, &m);
	for(int i = 1; i <= n; ++i) scanf("%d", &o[i]);
	for(int i = 1, u, v; i <= n; ++i)
		scanf("%d %d", &u, &v), e[u].push_back(v), e[v].push_back(u);
	dfs1(1, 1);
	dfs2(1, 1);
	t.build(1, 1, n);
	for(int i = 1, x, y, k; i <= m; ++i) {
		scanf("%s %d %d", c, &x, &y);
		if(c[0] == 'C') scanf("%d", &k), modify(x, y, k);
		else printf("%d\n", inquire(x, y));
	}
}
```

---

## 作者：λᴉʍ (赞：37)

转自：http://www.cnblogs.com/xzz_233/p/bzoj2243.html


~~学完LCT后赶脚树剖忘光光了~~


LCT板子题~~LCT的全是板子题~~


对每个点维护区间最左边的颜色lcol，区间最右边的颜色rcol和颜色段数tot。


合并时若左边的rcol==右边的lcol，新的tot=左tot+右tot-1；

不是就新tot=左tot+右tot


修改打个覆盖标记即可。


**注意：翻转操作要修改lcol和rcol！！！**


**注意：翻转操作要修改lcol和rcol！！！**


**注意：翻转操作要修改lcol和rcol！！！**


蒟蒻因为这个de了1.5h的bug。。。


另外常数有点点大。。（主站5180ms，氧气分站3456ms）


```cpp
// It is made by XZZ
#include<cstdio>
#include<algorithm>
#define il inline
#define rg register
#define vd void
#define sta static
typedef long long ll;
il int gi(){
    rg int x=0,f=1;rg char ch=getchar();
    while(ch<'0'||ch>'9')f=ch=='-'?-1:f,ch=getchar();
    while(ch>='0'&&ch<='9')x=x*10+ch-'0',ch=getchar();
    return x*f;
}
const int maxn=100001;
int ch[maxn][2],fa[maxn],tot[maxn],col[maxn],lcol[maxn],rcol[maxn],tag[maxn];
bool rev[maxn];
typedef const int& fast;
il vd upd(fast x){
    lcol[x]=ch[x][0]?lcol[ch[x][0]]:col[x];
    rcol[x]=ch[x][1]?rcol[ch[x][1]]:col[x];
    if(ch[x][0]&&ch[x][1])tot[x]=tot[ch[x][0]]+tot[ch[x][1]]+1-(rcol[ch[x][0]]==col[x])-(lcol[ch[x][1]]==col[x]);
    else if(ch[x][0])tot[x]=tot[ch[x][0]]+(rcol[ch[x][0]]!=col[x]);
    else if(ch[x][1])tot[x]=tot[ch[x][1]]+(lcol[ch[x][1]]!=col[x]);
    else tot[x]=1;
}
il bool isrt(fast x){return ch[fa[x]][0]!=x&&ch[fa[x]][1]!=x;}
il vd Rev(fast x){if(x)rev[x]^=1,std::swap(ch[x][0],ch[x][1]),std::swap(lcol[x],rcol[x]);}
il vd Change(fast x,int y){if(x)tag[x]=y,col[x]=lcol[x]=rcol[x]=y,tot[x]=1;}
il vd down(fast x){
    if(!isrt(x))down(fa[x]);
    if(rev[x])Rev(ch[x][0]),Rev(ch[x][1]),rev[x]=0;
    if(tag[x])Change(ch[x][0],tag[x]),Change(ch[x][1],tag[x]),tag[x]=0;
}
il vd rotate(fast x){
    sta int y,z,o;y=fa[x],z=fa[y],o=x==ch[y][1];
    if(!isrt(y))ch[z][y==ch[z][1]]=x;fa[x]=z;
    ch[y][o]=ch[x][!o];fa[ch[x][!o]]=y;
    fa[y]=x,ch[x][!o]=y;
    upd(y);
}
il vd splay(fast x){
    down(x);
    sta int y,z;
    for(y=fa[x],z=fa[y];!isrt(x);rotate(x),y=fa[x],z=fa[y])
        if(!isrt(y))rotate(((ch[y][0]==x)^(ch[z][0]==y))?x:y);
    upd(x);
}
il vd access(int x){for(rg int y=0;x;x=fa[y=x])splay(x),ch[x][1]=y,upd(x);}
il vd makert(fast x){access(x),splay(x),Rev(x);}
il vd split(fast x,fast y){makert(x),access(y),splay(y);}
il vd link(fast x,fast y){makert(x),fa[x]=y;}
int main(){
    int n=gi(),m=gi();
    for(rg int i=1;i<=n;++i)col[i]=lcol[i]=rcol[i]=gi(),tot[i]=1;
    for(rg int i=1;i<n;++i)link(gi(),gi());
    while(m--){
        sta char opt[10];sta int a,b;
        scanf("%s",opt),a=gi(),b=gi();
        split(a,b);
        if(opt[0]=='C')Change(b,gi());
        else printf("%d\n",tot[b]);
    }
    return 0;
}
```

---

## 作者：yizimi远欣 (赞：18)

### 主要思路：树链剖分 + 线段树

一看就知道是棵树，可以通过树链剖分后维护。

颜色就相当于点权，强烈暗示树链剖分。

所以重点就落在了如何维护区间颜色块数？

    1 1 2 2 3 3 3 2

我们可以这样考虑：

我们考虑小区间与小区间是不是可以合并。

如：

	1 1 2 2    3 3 3 2
    
假如我们已经知道这左右两段的左右端点和各自的颜色块数，我们可以想象一下对接这两个区间，如果左半段右端点和右半段左端点是一样的话，合起来的区间就会比原来两段区间中颜色块数之和少一个颜色块。

合并的问题解决了，那如何算其中一个区间的颜色块数？

我们和刚刚的方法相似，就是把这个区间分开，然后按照刚刚的办法合并，合并时把同块的减掉，，，

如果一直分下去，，是不是和什么数据结构有点类似，，，

**线段树！**

我们可以拿线段树模拟出来刚刚的过程，，，

于是这道题就就这么愉快的结束了

~~我不会告诉你我一个读入写错了交了一页的0分代码~~

### 代码：

```cpp
#include <algorithm>
#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <ctime>
#include <iostream>
#include <map>
#include <queue>
#include <set>
#include <stack>
#include <string>
#include <vector>
using namespace std;
#define go(i, j, n, k) for (int i = j; i <= n; i += k)
#define fo(i, j, n, k) for (int i = j; i >= n; i -= k)
#define rep(i, x) for (int i = h[x]; i; i = e[i].nxt)
#define mn 100010
#define inf 2147483647
#define ll long long
#define ld long double
#define fi first
#define se second
#define root 1, n, 1
#define lson l, m, rt << 1
#define rson m + 1, r, rt << 1 | 1
#define bson l, r, rt
//#define LOCAL
#define mod 
#define Debug(...) fprintf(stderr, __VA_ARGS__)
inline int read(){
    int f = 1, x = 0;char ch = getchar();
    while (ch > '9' || ch < '0'){if (ch == '-')f = -f;ch = getchar();}
    while (ch >= '0' && ch <= '9'){x = x * 10 + ch - '0';ch = getchar();}
    return x * f;
}
//This is AC head above...
int n, m;
struct edge{
    int v, nxt;
} e[mn << 1];
int p, h[mn];
inline void add(int a,int b){
    e[++p].nxt = h[a], h[a] = p, e[p].v = b;
}
int w[mn], dep[mn], sze[mn], fa[mn], son[mn], id[mn], ptn[mn], b[mn], top[mn], cnt;
// Array
struct tree{
    int l, r, lc, rc, sum, col;
    tree(int _l = 0, int _r = 0, int _lc = 0, int _rc = 0, int _sum = 0, int _col = 0)
        : l(_l), r(_r), lc(_lc), rc(_rc), sum(_sum), col(_col) {}
};
struct segmenttree{
    tree z[mn << 2];
    inline void update(int rt){
        z[rt].sum = z[rt << 1].sum + z[rt << 1 | 1].sum;
        if(z[rt<<1].rc == z[rt<<1|1].lc)
            z[rt].sum--;
        z[rt].lc = z[rt << 1].lc;
        z[rt].rc = z[rt << 1 | 1].rc;
    }
    inline void color(int l,int r,int rt,int v){
        z[rt].lc = z[rt].rc = v;
        z[rt].sum = 1;
        z[rt].col = v;
    }
    inline void push_col(int l,int r,int rt){
        if(z[rt].col){
            int m = (l + r) >> 1;
            color(lson, z[rt].col);
            color(rson, z[rt].col);
            z[rt].col = 0;
        }
    }
    inline void build(int l,int r,int rt){
        if(l==r){
            z[rt].lc = z[rt].rc = b[l];
            z[rt].sum = 1;
            return;
        }
        int m = (l + r) >> 1;
        build(lson);
        build(rson);
        update(rt);
    }
    inline void modify(int l,int r,int rt,int nowl,int nowr,int v){
        if(nowl<=l && r<=nowr){
            color(bson, v);
            return;
        }
        int m = (l + r) >> 1;
        push_col(bson);
        if(nowl<=m)
            modify(lson, nowl, nowr, v);
        if(m<nowr)
            modify(rson, nowl, nowr, v);
        update(rt);
    }
    inline tree query(int l,int r,int rt,int nowl,int nowr){
        if(nowl<=l && r<=nowr){
            return z[rt];
        }
        int m = (l + r) >> 1;
        push_col(bson);
        if(nowl<=m){
            if(m<nowr){
                tree res, ltr = query(lson, nowl, nowr), rtr = query(rson, nowl, nowr);
                res.sum = ltr.sum + rtr.sum + (ltr.rc == rtr.lc ? -1 : 0);
                res.lc = ltr.lc, res.rc = rtr.rc;
                return res;
            }else{
                return query(lson, nowl, nowr);
            }
        }else{
            return query(rson, nowl, nowr);
        }
    }
} tr;
// line segment tree
void dfs1(int x,int f,int deep){
    dep[x] = deep;
    fa[x] = f;
    sze[x] = 1;
    int maxson = -1;
    rep(i,x){
        int v = e[i].v;
        if(v==f)
            continue;
        dfs1(v, x, deep + 1);
        sze[x] += sze[v];
        if(maxson<sze[v])
            maxson = sze[v], son[x] = v;
    }
}
void dfs2(int x,int topf){
    id[x] = ++cnt;
    ptn[id[x]] = x;
    b[id[x]] = w[x];
    top[x] = topf;
    if(!son[x])
        return;
    dfs2(son[x], topf);
    rep(i,x){
        int v = e[i].v;
        if(v==fa[x]||v==son[x])
            continue;
        dfs2(v, v);
    }
}
// DFS
inline void tree_modify(int x,int y,int v){
    while(top[x] != top[y]){
        if(dep[top[x]] < dep[top[y]])
            swap(x, y);
        tr.modify(root, id[top[x]], id[x], v);
        x = fa[top[x]];
    }
    if(dep[x] > dep[y])
        swap(x, y);
    tr.modify(root, id[x], id[y], v);
}
inline int tree_query(int x,int y){
    int sum = 0, lxx = 0, sxy = 0;
    while(top[x] != top[y]){
        if(dep[top[x]] < dep[top[y]])
            swap(x, y), swap(lxx, sxy);
        tree res = tr.query(root, id[top[x]], id[x]);
        sum += res.sum;
        if(res.rc == lxx)
            sum--;
        lxx = res.lc;
        x = fa[top[x]];
    }
    if(dep[x] > dep[y])
        swap(x, y), swap(lxx, sxy);
    tree res = tr.query(root, id[x], id[y]);
    sum += res.sum;
    if(res.lc == lxx)
        sum--;
    if(res.rc == sxy)
        sum--;
    return sum;
}
int main(){
    n = read(), m = read();
    go(i, 1, n, 1) w[i] = read();
    go(i, 1, n - 1, 1){
        int a = read(), b = read();
        add(a, b), add(b, a);
    }
    dfs1(1, 1, 1);
    dfs2(1, 1);
    tr.build(root);
    go(i, 1, m, 1){
        char c;
        cin >> c;
        int x = read(), y = read();
        if(c=='Q')
            cout << tree_query(x, y) << "\n";
        else{
            int v = read();
            tree_modify(x, y, v);
        }
    }
#ifdef LOCAL
    Debug("\nMy Time: %.3lfms\n", (double)clock() / CLOCKS_PER_SEC);
#endif
    return 0;
}

```

#### 第十四次写题解，希望可以帮助大家理解这道题线段树维护颜色块的原理

---

## 作者：yurzhang (赞：16)

这道题的做法其实已经很明显了， ` 树链剖分 ` + ` 线段树 ` ，只是看到区间赋值心血来潮想用 ` 珂朵莉树 ` 水，结果就过了╮(╯▽╰)╭

操作 1 就是 ` 区间推平 ( assign ) ` ，操作 2 可以像找 ` 最近公共祖先 ( LCA ) ` 一样一边往上方跳一边统计，由于珂朵莉树的结点存储的是一段值相同的连续区间，我们只需要记录上一次访问的结点的值与当前结点的值比较，若不同则更新并计数。

## 值得注意的三点：

#### 1.由于我们是统计链上的连续段，所以我们应从深度大的结点往小的枚举。
#### 2.由于我们是从链的两端分别往上跳，所以我们需要分别记录两边上次访问的结点的值。
#### 3.最后处于同一条链上时，需要考虑两端的值相同的情况。

最后放上AC代码：
```cpp
#include <cstdio>
#include <set>
using std::set;

#define N 100010

struct node
{
	int l,r,v;
	node(int L,int R=-1,int V=0):l(L),r(R),v(V){}
	inline int operator<(const node&x)const{return l<x.l;}
};
set<node>s;
typedef set<node>::iterator IT;

inline IT split(int pos)
{
	IT it(--s.upper_bound(node(pos)));
	if(it->l==pos)
		return it;
	int L(it->l),R(it->r),V(it->v);
	s.erase(it),s.insert(node(L,pos-1,V));
	return s.insert(node(pos,R,V)).first;
}

inline void assign(int l,int r,int v)
{
	IT itr(split(r+1)),itl(split(l));
	s.erase(itl,itr);s.insert(node(l,r,v));
}

int n,m,a[N],x,y,z;
char opt;

int e,bg[N],nx[N<<1],to[N<<1];
inline void link(int u,int v){to[++e]=v,nx[e]=bg[u],bg[u]=e;}

int fa[N],dep[N],siz[N],ws[N];
void dfs1(int now,int f)
{
	fa[now]=f,dep[now]=dep[f]+1,siz[now]=1;
	int mx(-1);
	for(int i=bg[now];i;i=nx[i])
		if(to[i]!=f)
		{
			dfs1(to[i],now);
			siz[now]+=siz[to[i]];
			if(siz[to[i]]>mx)
				mx=siz[to[i]],ws[now]=to[i];
		}
}

int cnt,top[N],id[N],wt[N];
void dfs2(int now,int tp)
{
	top[now]=tp,id[now]=++cnt,wt[cnt]=a[now];
	if(!ws[now])
		return;
	dfs2(ws[now],tp);
	for(int i=bg[now];i;i=nx[i])
		if(to[i]!=fa[now]&&to[i]!=ws[now])
			dfs2(to[i],to[i]);
}

inline void change(int x,int y,int z)
{
	while(top[x]!=top[y])
	{
		if(dep[top[x]]>dep[top[y]])
		{
			assign(id[top[x]],id[x],z);
			x=fa[top[x]];
		}
		else
		{
			assign(id[top[y]],id[y],z);
			y=fa[top[y]];
		}
	}
	if(dep[x]>dep[y])
		assign(id[y],id[x],z);
	else
		assign(id[x],id[y],z);
}

inline int query(int x,int y)
{
	int ans(0),lasta(0),lastb(0);
	IT itl,itr;
	while(top[x]!=top[y])
	{
		if(dep[top[x]]>dep[top[y]])
		{
			itr=split(id[x]+1),itl=split(id[top[x]]);
			for(--itr;;--itr)
			{
				if(itr->v!=lasta)
					lasta=itr->v,++ans;
				if(itr==itl)
					break;
			}
			x=fa[top[x]];
		}
		else
		{
			itr=split(id[y]+1),itl=split(id[top[y]]);
			for(--itr;;--itr)
			{
				if(itr->v!=lastb)
					lastb=itr->v,++ans;
				if(itr==itl)
					break;
			}
			y=fa[top[y]];
		}
	}
	if(dep[x]>dep[y])
	{
		itr=split(id[x]+1),itl=split(id[y]);
		for(--itr;;--itr)
		{
			if(itr->v!=lasta)
				lasta=itr->v,++ans;
			if(itr==itl)
					break;
		}
	}
	else
	{
		itr=split(id[y]+1),itl=split(id[x]);
		for(--itr;;--itr)
		{
			if(itr->v!=lastb)
				lastb=itr->v,++ans;
			if(itr==itl)
					break;
		}
	}
	return ans-(lasta==lastb);
}

int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;++i)
		scanf("%d",a+i);
	for(int i=1;i<n;++i)
	{
		scanf("%d%d",&x,&y);
		link(x,y),link(y,x);
	}
	dfs1(1,0);
	dfs2(1,1);
	for(int i=1;i<=n;++i)
		s.insert(node(i,i,wt[i]));
	while(m--)
	{
		scanf("\n%c%d%d",&opt,&x,&y);
		if(opt=='C')
		{
			scanf("%d",&z);
			change(x,y,z);
		}
		else
			printf("%d\n",query(x,y));
	}
	return 0;
}
```

---

## 作者：devout (赞：14)

[博客内食用更加](https://blog.csdn.net/devout_/article/details/104374121)

看到题解里好像没有和我做法完全一样的

来发一下

这道题，显然我们需要树剖一下

然后我们考虑怎么用线段树去维护区间颜色段数

我们会想到我们需要维护这么几个东西

1.区间段数

2.区间左端点的颜色

3.区间右端点的颜色

合并的时候就是左儿子的段数加上右儿子的段数，如果左儿子的右端点和右儿子的左端点是一个颜色，那么就段数-1

因为是区间修改，所以加上一个懒标记就可以了

更新跟普通树剖一样，但是查询不太一样

这里提供一种~~适用范围更广~~的做法

我是受到了[这道题](https://www.luogu.com.cn/problem/SP6779)的启发，那道题是求树上最大子段和，需要维护的东西比较多，所以单纯用变量不太好做。

所以我让我们的query函数返回的是一个结构体来储存这一段的答案的段数，左端点，右端点分别是什么，然后我们再写一个merge函数来合并两个结构体，其实写起来和pushup差不多，大概是这个样子的

```cpp
segment_tree merge(segment_tree l,segment_tree r){
	if(!l.sum)return r;
	if(!r.sum)return l;
	segment_tree res;
	res.lcol=l.lcol,res.rcol=r.rcol;
	res.sum=l.sum+r.sum;
	if(l.rcol==r.lcol)res.sum--;
	return res;	
}
```

那么我们树剖查询的时候，开两个segment_tree类型的结构体变量l，r，分别表示x往上跳到他们的lca的这一段的颜色段数和y跳到lca这一段的颜色段数

然后依次合并就可以了

但是注意一点，merge函数是不满足交换律的，所以我们要把top[x]~x这一段放在左边。

最后合并的时候要把l的左端点颜色和右端点颜色交换一下，因为我们要把一个区间整体反转才能接到一起（可以画个图理解一下）

然后如果你~~只过了hack数据~~的话就查一下你的查询那一段有没有查反就好了

code time:

```cpp
# include <bits/stdc++.h>
using namespace std;

# define Rep(i,a,b) for(int i=a;i<=b;i++)
# define _Rep(i,a,b) for(int i=a;i>=b;i--)
# define RepG(i,u) for(int i=head[u];~i;i=e[i].next)
const int N=1e5+5;
template <typename T> void read(T &x){
	x=0;int f=1;
	char c=getchar();
	for(;!isdigit(c);c=getchar())if(c=='-')f=-1;
	for(;isdigit(c);c=getchar())x=(x<<1)+(x<<3)+c-'0';
	x*=f;
}

int n,m;
int head[N],cnt;
int a[N],_a[N];
int faz[N],son[N],dep[N],siz[N],top[N],dfn[N],tot;

struct Edge{
	int to,next;	
}e[N<<1];

void add(int x,int y){
	e[++cnt]=(Edge){y,head[x]},head[x]=cnt;	
}

struct segment_tree{
	int l,r;
	int lcol,rcol,sum;	
	int tag;
	segment_tree(){l=r=lcol=rcol=sum=tag=0;}
}seg[N<<2];

# define lc (u<<1)
# define rc (u<<1|1)

void pushup(int u){
	seg[u].sum=seg[lc].sum+seg[rc].sum;
	if(seg[lc].rcol==seg[rc].lcol)seg[u].sum--;
	seg[u].lcol=seg[lc].lcol;
	seg[u].rcol=seg[rc].rcol;	
}

void pushdown(int u){
	seg[lc].sum=1;
	seg[lc].lcol=seg[lc].rcol=seg[u].tag;
	seg[lc].tag=seg[u].tag;
	seg[rc].sum=1;
	seg[rc].lcol=seg[rc].rcol=seg[u].tag;
	seg[rc].tag=seg[u].tag;
	seg[u].tag=0;	
}

segment_tree merge(segment_tree l,segment_tree r){
	if(!l.sum)return r;
	if(!r.sum)return l;
	segment_tree res;
	res.lcol=l.lcol,res.rcol=r.rcol;
	res.sum=l.sum+r.sum;
	if(l.rcol==r.lcol)res.sum--;
	return res;	
}

void build(int u,int l,int r){
	seg[u].l=l,seg[u].r=r;
	if(l==r){seg[u].sum=1,seg[u].lcol=seg[u].rcol=_a[l];return;}
	int mid=l+r>>1;
	build(lc,l,mid);
	build(rc,mid+1,r);
	pushup(u);
}

void update(int u,int l,int r,int k){
	if(seg[u].l>=l&&seg[u].r<=r){
		seg[u].sum=1;
		seg[u].lcol=seg[u].rcol=k;
		seg[u].tag=k;
		return;
	}	
	if(seg[u].tag)pushdown(u);
	int mid=seg[u].l+seg[u].r>>1;
	if(l<=mid)update(lc,l,r,k);
	if(r>mid)update(rc,l,r,k);
	pushup(u);
}

segment_tree query(int u,int l,int r){
	if(seg[u].l>=l&&seg[u].r<=r)return seg[u];
	if(seg[u].tag)pushdown(u);
	int mid=seg[u].l+seg[u].r>>1;
	if(r<=mid)return query(lc,l,r);
	if(l>mid)return query(rc,l,r);
	return merge(query(lc,l,r),query(rc,l,r));	
}

void RouteModify(int x,int y,int k){
	while(top[x]!=top[y]){
		if(dep[top[x]]<dep[top[y]])swap(x,y);
		update(1,dfn[top[x]],dfn[x],k);
		x=faz[top[x]];	
	}
	if(dep[x]>dep[y])swap(x,y);
	update(1,dfn[x],dfn[y],k);
}

int RouteQuery(int x,int y){
	segment_tree l,r;
	while(top[x]!=top[y]){
		if(dep[top[x]]<dep[top[y]]){
			r=merge(query(1,dfn[top[y]],dfn[y]),r);
			y=faz[top[y]];	
		}
		else{
			l=merge(query(1,dfn[top[x]],dfn[x]),l);
			x=faz[top[x]];	
		}
	}
	if(dep[x]<dep[y])r=merge(query(1,dfn[x],dfn[y]),r);
	else l=merge(query(1,dfn[y],dfn[x]),l);
	swap(l.lcol,l.rcol);
	return merge(l,r).sum; 
}

void dfs1(int u,int fa){
	faz[u]=fa;
	siz[u]=1;
	dep[u]=dep[fa]+1;
	RepG(i,u){
		int v=e[i].to;
		if(v==fa)continue;
		dfs1(v,u);
		siz[u]+=siz[v];
		if(siz[v]>siz[son[u]])son[u]=v;
	}
}

void dfs2(int u,int _top){
	top[u]=_top;
	dfn[u]=++tot;
	_a[tot]=a[u];
	if(!son[u])return;
	dfs2(son[u],_top);
	RepG(i,u){
		int v=e[i].to;
		if(v==faz[u]||v==son[u])continue;
		dfs2(v,v);
	}
}

int main()
{
	memset(head,-1,sizeof(head));
	read(n),read(m);
	Rep(i,1,n)read(a[i]);
	Rep(i,1,n-1){
		int x,y;
		read(x),read(y);
		add(x,y),add(y,x);
	}
	dfs1(1,0),dfs2(1,1);
	build(1,1,n);
	Rep(i,1,m){
		char opt[10];
		int x,y,z;
		scanf("%s",opt);
		if(opt[0]=='C'){
			read(x),read(y),read(z);
			RouteModify(x,y,z);
		}
		else{
			read(x),read(y);
			printf("%d\n",RouteQuery(x,y));	
		}
	}
	return 0;
}
```


---

## 作者：_LAUV_ (赞：14)

看见大家都发了树剖的题解 那我来写一个LCT的吧~

博客里查看~： [——>戳我 戳我](https://www.cnblogs.com/HLAUV/p/10330934.html)

还不会LCT的小伙伴可以看一下这篇博客：[LCT总结](http://www.cnblogs.com/flashhu/p/8324551.html)

我初学动态树时就是看着那篇博客学的，写的很好！

那好 言归正传。

显然树上 x 到 y 的路径的问题都可以用LCT Access一下把路径剖离出来，那主要问题在于如何用Splay 来维护颜色呢？

上图（~~XP灵魂画手所作~~）
![](https://cdn.luogu.com.cn/upload/pic/50097.png)

对于Splay树的每一个节点，维护四个信息

#### c[x] : 节点本身的颜色
#### cL[x]: 节点对应子树最左端的颜色
#### cR[x]: 节点对应子树最右端的颜色
#### tot[x]: 节点对应子树区间的颜色段数

所以upDATA的时候就很显然啦~
```cpp
void pUP(int x){
	int lc=ch[x][0],rc=ch[x][1];
	
	cL[x]= lc? cL[lc]:c[x];
	cR[x]= rc? cR[rc]:c[x];
	
	if(lc && rc) tot[x]=tot[lc]+tot[rc]+1-(cR[lc]==c[x])-(cL[rc]==c[x]);
	
	if(lc &&!rc) tot[x]=tot[lc]+1-(cR[lc]==c[x]);
	
	if(!lc&& rc) tot[x]=tot[rc]+1-(cL[rc]==c[x]);
	
	if(!lc&&!rc) tot[x]=1;
}
```
其他部分就和平常的LCT没有什么区别了

哦 对，pushDOWN时要注意 区间翻转，cL和cR要一起翻

全代码~

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<algorithm>

#define For(i,a,b) for(register int i=a;i<=b;++i)
#define Dwn(i,a,b) for(register int i=a;i>=b;--i)
#define Pn putchar('\n')
#define I inline 
#define Re register

using namespace std;

const int N=1e5+5;

int ch[N][2],fa[N],c[N],cL[N],cR[N],tot[N],tag[N],st[N],top,tgC[N];
int n,m,x,y,z;
char opt;

I void read(int &v){
	v=0;
	char c=getchar();
	while(c<'0'||c>'9')c=getchar();
	while(c>='0'&&c<='9')v=v*10+c-'0',c=getchar();
}
void write(int x){
	if(x>9)write(x/10);
	int xx=x%10;
	putchar(xx+'0');
}
I bool NOrt(int x){
	return ch[fa[x]][1]==x || ch[fa[x]][0]==x;
}
I void pTAG(int x){
	swap(ch[x][0],ch[x][1]);
	swap(cL[x],cR[x]);
	tag[x]^=1;
}
I void pTGC(int x,int Col){
	c[x]=cL[x]=cR[x]=Col;
	tot[x]=1;
	tgC[x]=Col;
}
I void pDOWN(int x){
	if(tag[x]){
		if(ch[x][0])pTAG(ch[x][0]);
		if(ch[x][1])pTAG(ch[x][1]);
		tag[x]^=1;
	}
	if(tgC[x]){
		if(ch[x][0])pTGC(ch[x][0],tgC[x]);
		if(ch[x][1])pTGC(ch[x][1],tgC[x]);
		tgC[x]=0;
	}
}
I void pUP(int x){
	int lc=ch[x][0],rc=ch[x][1];
	
	cL[x]= lc? cL[lc]:c[x];
	cR[x]= rc? cR[rc]:c[x];
	
	if(lc && rc) tot[x]=tot[lc]+tot[rc]+1-(cR[lc]==c[x])-(cL[rc]==c[x]);
	
	if(lc &&!rc) tot[x]=tot[lc]+1-(cR[lc]==c[x]);
	
	if(!lc&& rc) tot[x]=tot[rc]+1-(cL[rc]==c[x]);
	
	if(!lc&&!rc) tot[x]=1;
}
I bool Wson(int x){
	return ch[fa[x]][1]==x;
}
I void Rotate(int x){
	int y=fa[x];
	int z=fa[y];
	int ws=Wson(x);
	if(NOrt(y))ch[z][Wson(y)]=x;
	fa[x]=z;
	
	ch[y][ws]=ch[x][ws^1];
	if(ch[x][ws^1])fa[ch[x][ws^1]]=y;
	
	ch[x][ws^1]=y;
	fa[y]=x;
	
	pUP(y); pUP(x);
}
I void Splay(int x){
	top=0; int now=x;
	st[++top]=now;
	while(NOrt(now))st[++top]=now=fa[now];
	while(top) pDOWN(st[top--]);
	
	while(NOrt(x)){
		int y=fa[x];
		if(NOrt(y)){
			if(Wson(y)==Wson(x))Rotate(y);
			else Rotate(x);
		}
		Rotate(x);
	}
}
I void Access(int x){
	int lst=0;
	while(x){
		Splay(x); ch[x][1]=lst; pUP(x);
		lst=x; x=fa[x];
	}
}
I void ChangeRt(int x){
	Access(x); Splay(x); pTAG(x);
}
I void Link(int x,int y){
	ChangeRt(x); fa[x]=y;
}
I void Split(int x,int y){
	ChangeRt(x); Access(y); Splay(y);
}
int main(){ 
	read(n); read(m); 
	For(i,1,n){
		read(c[i]); tot[i]=1;
		cL[i]=cR[i]=c[i]; 
	};
	For(i,1,n-1){ 
		read(x); read(y);
		Link(x,y);
	}
	For(i,1,m){ 
		opt=getchar();
		while(opt!='C'&&opt!='Q')opt=getchar();
		if(opt=='C'){
			read(x); read(y); read(z);
			Split(x,y); pTGC(y,z);
		}
		if(opt=='Q'){
			read(x); read(y);
			Split(x,y);
			write(tot[y]); Pn;
		}
	}
	return 0;
}

```

---

## 作者：hs_black (赞：4)

### [P2486](https://www.luogu.org/problem/P2486)

很经典的题~

思路: 线段树染色+"熟练"剖分(某些出题人总是喜欢把序列上的题加个树链剖分搞到树上去)

先想一想序列上怎么做吧

~~线段树是个好东西~~

每个节点维护三个信息: ls: 左端点的颜色    rs: 右端点的颜色 cnt: [l, r] 中共有几个颜色段

合并? 

fa.cnt = son1.cnt + son2.cnt - [son1.rs == son2.ls]

fa.ls = son1.ls ,       fa.rs =  son2.rs

爹的左端点颜色就是左儿子的左端点颜色, 右端点亦然

如果左儿子与右儿子相接的颜色相同, 那么等于左儿子块数加右儿子块数-1(中间两个块会合成一个)

否则直接加就行啦

修改时要打**标记** 记录有没有被覆盖

#### 回到树上问题时要特别注意的是询问

因为询问时有swap的操作, 将k记录x,y的顺序, 即相当于(x, y) 还是(y, x)

如果是(y, x), 最后还要反回来才能进行合并

在跳重链时, 总是将链接在它的左边, 最后将a左右儿子反一下再与b合并即可





```cpp
#include<iostream>
#include<cstdio>
#include<cstdio>
#define ll long long
using namespace std;
const int N = 105000*4;
int fa[N], id[N], siz[N];
int num, dep[N], son[N];
int w[N], wt[N], Top[N];
int h[N], ne[N], to[N];
int tot;
inline void add(int x,int y) {
	ne[++tot] = h[x], h[x] = tot;
	to[tot] = y;
}
void dfs1(int x,int f) {
	fa[x] = f;
	siz[x] = 1, dep[x] = dep[f] + 1;
	for (int i = h[x]; i ;i = ne[i]) {
		int y = to[i];
		if (y == f) continue;
		dfs1(y, x);
		siz[x] += siz[y];
		if (siz[y] > siz[son[x]]) son[x] = y;
	}
}
void dfs2(int x,int topf) {
	id[x] = ++num; wt[num] = w[x];
	Top[x] = topf;
	if (!son[x]) return;
	dfs2(son[x], topf);
	for (int i = h[x]; i; i = ne[i]) {
		int y = to[i];
		if (y == fa[x] || y == son[x]) continue;
		dfs2(y, y);
	}
}
int n, m;
int L[N], R[N], cnt[N], ls[N], rs[N];
int tag[N];
#define p1 p << 1
#define p2 p << 1 | 1

struct node{
	int cnt, ls, rs;
};
void update(node &fa,node i,node j) {
	fa.cnt = i.cnt + j.cnt - (i.rs == j.ls);
	fa.ls = i.ls, fa.rs = j.rs;
}

void build(int l,int r,int p) {
	L[p] = l, R[p] = r;
	if (l == r) {
		cnt[p] = 1, ls[p] = rs[p] = wt[l];
		return;
	}
	int mid = (l + r) >> 1;
	build(l, mid, p1);
	build(mid+1, r, p2);
	cnt[p] = cnt[p1] + cnt[p2] - (rs[p1] == ls[p2]);
	ls[p] = ls[p1], rs[p] = rs[p2];
}

void spread(int p) {
	if (tag[p]) {
		cnt[p1] = cnt[p2] = 1;
		tag[p1] = tag[p2] = tag[p];
		ls[p1] = ls[p2] = rs[p1] = rs[p2] = tag[p];
		tag[p] = 0;
	}
}

void change(int l,int r,int p,int c) {
	if (L[p] >= l && R[p] <= r) {
		cnt[p] = 1, tag[p] = c;
		ls[p] = rs[p] = c;
		return;
	}
	spread(p);
	if (R[p1] >= l) change(l, r, p1, c);
	if (L[p2] <= r) change(l, r, p2, c);
	cnt[p] = cnt[p1] + cnt[p2] - (rs[p1] == ls[p2]);
	ls[p] = ls[p1], rs[p] = rs[p2];
}

node ask(int l,int r,int p) {
	if (L[p] >= l && R[p] <= r) return (node){cnt[p], ls[p], rs[p]};
	spread(p);
	node i;
	if (R[p1] < l) return ask(l, r, p2);
	if (L[p2] > r) return ask(l, r, p1);
	update(i, ask(l, r, p1), ask(l, r, p2));
	return i;
}
	
void change_e(int x,int y,int c) {
	while (Top[x] != Top[y]) {
		if (dep[Top[x]] < dep[Top[y]]) swap(x, y);
		change(id[Top[x]], id[x], 1, c);
		x = fa[Top[x]];
	}
	if (dep[x] < dep[y]) swap(x, y);
	change(id[y], id[x], 1, c);
}

int sum(int x,int y) {
	node ans, a, b;
	ans = a = b = (node){0,0,0};
	int k = 1;
	while (Top[x] != Top[y]) {
		if (dep[Top[x]] < dep[Top[y]]) swap(x, y), swap(a, b), k ^= 1;
		if (a.cnt == 0) a = ask(id[Top[x]], id[x], 1);
		else update(a, ask(id[Top[x]], id[x], 1), a);
		x = fa[Top[x]];
	}
	if (dep[x] < dep[y]) swap(x, y), swap(a, b);
	if (a.cnt == 0) a = ask(id[y], id[x], 1);
	else update(a, ask(id[y], id[x], 1), a);
	if (b.cnt == 0) return a.cnt;
	if (a.cnt == 0) return b.cnt;
	if (!k) swap(a, b); // 将a, b恢复正常顺序
	swap(a.ls, a.rs); //将a左右儿子换位
	update(ans, a, b);
	return ans.cnt;
}
	
		
char s[5];
ll a, b, c;

template <typename T> 
void read(T &x) {
	x = 0; int f = 1;
	char c = getchar();
	for (;!isdigit(c); c = getchar()) if (c == '-') f = -1;
	for (;isdigit(c); c = getchar()) x = (x << 3) + (x << 1) + c - '0';
	x *= f;
}
int main() {
	read(n), read(m);
	for (int i = 1;i <= n; i++) read(w[i]);
	for (int i = 1;i < n; i++) {
		read(a), read(b);
		add(a, b); add(b, a);
	}
	dfs1(1, 0); 
	dfs2(1, 1);
	build(1, n, 1);
	while (m--) {
		scanf ("%s", s + 1);
		if (s[1] == 'C') {
			read(a), read(b), read(c);
			change_e(a, b, c);
		}
		else {
			read(a), read(b);
			printf ("%d\n", sum(a, b));
		}
	}
	return 0;
}
```



---

## 作者：kouylan (赞：4)

## 题解 P2486 【[SDOI2011]染色】

### 【题意】
求树上颜色块个数。

### 【分析】
首先，我们可以很快的想到用树链剖分。

$modify$和$query$的部分与模板相同，所以只需要思考一下$update$（上推），$pushdown$（下推）和$merge$（线段树合并）这几个函数。

#### 1. $update$函数
让我们看如下两个区间：

	left: 1 1 2 2   right: 2 3 3 2

$left$区间的个数是$2$，$right$区间的个数是$3$。但是这两个区间合并起来是

	1 1 2 2 2 3 3 2
个数是$4$，并不是$2+3=5$。

这是为什么？

很显然，我们发现$left$区间的最右边的值是$2$，$right$区间的最左边的值也是$2$。把两者合并，$left$的最右边区间与$right$的最左边区间在合并时，被合并成了同一个区间。因此合并完的区间个数要$-1$，所以是$2+3-1=4$。

在此，我们可以发现，需记录每一段区间的最左边颜色$lc$，最右边颜色$rc$，以及颜色块个数$sum$。

```cpp
void update(int o)
{
	dat[o].sum = dat[lson].sum+dat[rson].sum;
	if(dat[lson].rc==dat[rson].lc) //如果left区间的右颜色=right区间的左颜色，两区间会合并成一个区间
		dat[o].sum--; //需要-1
	dat[o].lc = dat[lson].lc;
	dat[o].rc = dat[rson].rc;
}
```

#### 2. $pushdown$函数
我们很容易得到，更新过的$left$区间和$right$区间，因为内部颜色均相同，所以$sum$都是$1$。
```cpp
void pushdown(int o,int l,int r)
{
	if(dat[o].lazy>=0)
	{
		dat[lson].sum = dat[rson].sum = 1;
		dat[lson].lc = dat[lson].rc = dat[rson].lc = dat[rson].rc = dat[o].lazy;
		dat[lson].lazy = dat[rson].lazy = dat[o].lazy;
	}
	dat[o].lazy = -1;
}
```

#### 3. $merge$函数
两线段树合并与$update$相差无几，在此就不再赘述。

下面是AC代码。
```cpp
/*
luogu P2486
*/
#include <bits/stdc++.h>
using namespace std;

#define lson o<<1
#define rson o<<1|1
#define mid (l+r>>1)

int n,q,c[100005];
int ee,h[100005],nex[100005<<1],to[100005<<1];
int cnt,mark[100005],a[100005];
int dep[100005],f[100005],son[100005],siz[100005],top[100005];
struct segtree{
	int sum;
	int lc,rc;
	int lazy;
	void init()
	{
		sum = 0;
		lc = rc = lazy = -1;
	}
}dat[100005<<2];

void addedge(int x,int y)
{
	nex[++ee] = h[x];
	to[ee] = y;
	h[x] = ee;
}

void dfs1(int x,int pre)
{
	dep[x] = dep[pre]+1;
	f[x] = pre;
	siz[x] = 1;
	for(int i=h[x];i;i=nex[i])
		if(to[i]!=pre)
		{
			dfs1(to[i],x);
			siz[x] += siz[to[i]];
			if(siz[to[i]]>siz[son[x]])
				son[x] = to[i];
		}
}

void dfs2(int x,int topx,int pre)
{
	mark[x] = ++cnt;
	a[mark[x]] = c[x];
	top[x] = topx;
	if(!son[x])
		return;
	dfs2(son[x],topx,x);
	for(int i=h[x];i;i=nex[i])
		if(to[i]!=son[x] && to[i]!=pre)
			dfs2(to[i],to[i],x);
}

void update(int o)
{
	dat[o].sum = dat[lson].sum+dat[rson].sum;
	if(dat[lson].rc==dat[rson].lc)
		dat[o].sum--;
	dat[o].lc = dat[lson].lc;
	dat[o].rc = dat[rson].rc;
}

void build(int o,int l,int r)
{
	dat[o].lazy = -1;
	if(l==r)
	{
		dat[o].sum = 1;
		dat[o].lc = dat[o].rc = a[l];
		return;
	}
	build(lson,l,mid);
	build(rson,mid+1,r);
	update(o);
}

void pushdown(int o,int l,int r)
{
	if(dat[o].lazy>=0)
	{
		dat[lson].sum = dat[rson].sum = 1;
		dat[lson].lc = dat[lson].rc = dat[rson].lc = dat[rson].rc = dat[o].lazy;
		dat[lson].lazy = dat[rson].lazy = dat[o].lazy;
	}
	dat[o].lazy = -1;
}

segtree merge(segtree a,segtree b)
{
	segtree t;
	t.sum = a.sum+b.sum;
	if(a.rc==b.lc)
		t.sum--;
	t.lc = a.lc;
	t.rc = b.rc;
	t.lazy = -1;
	return t;
}

void modify(int o,int l,int r,int ql,int qr,int v)
{
	if(l>=ql && r<=qr)
	{
		dat[o].sum = 1;
		dat[o].lc = dat[o].rc = v;
		dat[o].lazy = v;
		return;
	}
	pushdown(o,l,r);
	if(ql<=mid)
		modify(lson,l,mid,ql,qr,v);
	if(qr>mid)
		modify(rson,mid+1,r,ql,qr,v);
	update(o);
}

segtree query(int o,int l,int r,int ql,int qr)
{
	if(l>=ql && r<=qr)
		return dat[o];
	pushdown(o,l,r);
	if(qr<=mid)
		return query(lson,l,mid,ql,qr);
	else if(ql>mid)
		return query(rson,mid+1,r,ql,qr);
	return merge(query(lson,l,mid,ql,qr),query(rson,mid+1,r,ql,qr));
}

void modify_(int x,int y,int z)
{
	while(top[x]!=top[y])
	{
		if(dep[top[x]]<dep[top[y]])
			swap(x,y);
		modify(1,1,n,mark[top[x]],mark[x],z);
		x = f[top[x]];
	}
	if(dep[x]<dep[y])
		modify(1,1,n,mark[x],mark[y],z);
	else
		modify(1,1,n,mark[y],mark[x],z);
}

int query_(int x,int y)
{
	segtree l,r;
	l.init();
	r.init();
	while(top[x]!=top[y])
	{
		if(dep[top[x]]>dep[top[y]])
		{
			l = merge(query(1,1,n,mark[top[x]],mark[x]),l);
			x = f[top[x]];
		}
		else
		{
			r = merge(query(1,1,n,mark[top[y]],mark[y]),r);
			y = f[top[y]];
		}
	}
	if(dep[x]>dep[y])
		l = merge(query(1,1,n,mark[y],mark[x]),l);
	else
		r = merge(query(1,1,n,mark[x],mark[y]),r);
	return l.sum+r.sum-(l.lc==r.lc);
}

int main()
{
	cin>>n>>q;
	for(int i=1;i<=n;scanf("%d",c+i),i++);
	for(int i=1,x,y;i<n&&scanf("%d %d",&x,&y);i++)
	{
		addedge(x,y);
		addedge(y,x);
	}
	dfs1(1,0);
	dfs2(1,1,0);
	build(1,1,n);
	while(q--)
	{
		char oper;
		cin>>oper;
		if(oper=='C')
		{
			int x,y,z;
			scanf("%d %d %d",&x,&y,&z);
			modify_(x,y,z);
		}
		else if(oper=='Q')
		{
			int x,y;
			scanf("%d %d",&x,&y);
			printf("%d\n",query_(x,y));
		}
	}
	
	return 0;
}
/*
6 12
0 0 11 4 2 6 
5 4
3 5
3 1
1 2
6 5
Q 2 6
C 3 1 3
Q 4 5
Q 2 6
Q 2 3
C 3 3 5
Q 2 1
C 3 4 3
C 2 4 2
Q 1 3
Q 1 6
C 4 3 6

10 4
26 22 46 21 10 46 43 9 11 33 
2 1
3 2
4 3
5 2
6 5
7 3
8 7
9 5
10 5
C 10 1 28
C 4 5 17
Q 7 10
Q 10 7

7 20
8 2 8 1 6 15 8
4 2
2 3
5 3
1 4
6 5
7 6
C 6 3 1
Q 6 7
C 6 6 4
C 6 6 5
C 2 1 5
Q 2 3
C 7 1 6
Q 4 6
C 1 6 2
Q 7 1
C 7 5 7
Q 6 5
C 3 4 1
Q 5 4
Q 3 4
C 4 2 6
C 3 2 4
Q 5 6
Q 5 2
C 7 4 2
*/
```

### 【后记】
与这道题类似的还有[树上最大子段和](https://www.luogu.com.cn/problem/SP6779)（另附[个人题解](https://www.luogu.com.cn/blog/123298/solution-sp6779)），大家还可以做一下这道题。

祝大家AC愉快！

---

## 作者：SuperJvRuo (赞：4)

这是一篇树剖+[珂朵莉树](https://www.luogu.org/blog/ACdreamer/chtholly-tree)的题解。

首先显然是要树剖了。此题大约有一半的操作为珂朵莉树的区间赋值，可以考虑珂朵莉树骗分。（然后一不小心就A了）另一部分的操作也很好搞。

具体实现看代码：

```
#include<cctype>
#include<cstdio>
#include<set>
#include<algorithm>

inline int Read()
{
	int x=0;char c=getchar();
	while(!isdigit(c))
		c=getchar();
	while(isdigit(c))
	{
		x=x*10+(c^48);
		c=getchar();
	}
	return x;
}

const int maxn=200000+10;
int n,m;
int son[maxn],id[maxn],fa[maxn],cnt,dep[maxn],size[maxn],top[maxn],w[maxn],wt[maxn];

struct Edge
{
	int to,next;
}edge[maxn];
int head[maxn],ecnt;

void Add_edge(int u,int v)
{
	edge[++ecnt]=(Edge){v,head[u]};
	head[u]=ecnt;
	edge[++ecnt]=(Edge){u,head[v]};
	head[v]=ecnt;
}

struct node
{
	int l,r;
	mutable int v;
	node(int L,int R=-1,int V=0):l(L),r(R),v(V){}
	bool operator<(const node& o) const
	{
		return l < o.l;
	}
};
//这样的一个节点表示[l,r]内的所有数都是v。

typedef node Ret;
Ret operator + (Ret l,Ret r)
{
	return Ret(l.l?l.l:r.l,r.r?r.r:l.r,l.v+r.v-(l.r==r.l));
}
//这样的一个Ret表示左边颜色为l，右边颜色为r，共有v段颜色。

using std::set;
set<node> s;
#define IT set<node>::iterator

//split(pos)操作是指将原来含有pos位置的节点分成两部分：[l,pos−1]和[pos,r]。
IT split(int pos)
{
	IT it=s.lower_bound(node(pos));
	if(it!=s.end()&&it->l==pos) return it;
	--it;
	int L=it->l,R=it->r,V=it->v;
	s.erase(it);
	s.insert(node(L,pos-1,V));
	return s.insert(node(pos,R,V)).first;
}

//区间赋值，把l和r+1进行split，再把[l,r]合成一个节点。
void assign(int l,int r,int val=0)
{
	IT itr=split(r+1),itl=split(l);
	s.erase(itl,itr);
	s.insert(node(l,r,val));
}

void build(int l,int r)
{
	int cnt=1,last=wt[l];
	for(int i=l+1;i<=r;++i)
	{
		if(wt[i]!=last)
		{
			s.insert(node(i-cnt,i-1,last));
			cnt=1;
			last=wt[i];
		}
		else
		{
			++cnt;
		}
	}
	s.insert(node(r+1-cnt,r,last));
	s.insert(node(r+1,r+3,0));
}

Ret query(int l,int r)
{
	Ret ans=Ret(0);
	IT itr=split(r+1),itl=split(l);
	for(;itl!=itr;++itl)
	{
		ans=ans+Ret(itl->v,itl->v,1);
	}
	return ans;
}

int qRange(int x,int y)
{
	Ret lans=Ret(0),rans=Ret(0);
    //lans表示x一侧的结果，rans表示y一侧的结果
	while(top[x]!=top[y])
	{
		if(dep[top[x]]>dep[top[y]])
		{
			lans=query(id[top[x]],id[x])+lans;
			x=fa[top[x]];
		}
		else
		{
			rans=query(id[top[y]],id[y])+rans;
			y=fa[top[y]];
		}
	}
	if(dep[x]>dep[y])
	{
		lans=query(id[y],id[x])+lans;
	}
	else
	{
		rans=query(id[x],id[y])+rans;
	}
	std::swap(lans.l,lans.r);
	return (lans+rans).v;
}

void updRange(int x,int y,int k)
{
	while(top[x]!=top[y])
	{
		if(dep[top[x]]<dep[top[y]])
			std::swap(x,y);
		assign(id[top[x]],id[x],k);
		x=fa[top[x]];
	}
	if(dep[x]>dep[y])
		std::swap(x,y);
	assign(id[x],id[y],k);
}

//树剖基操
void dfs1(int x,int f,int deep)
{
	dep[x]=deep;
	fa[x]=f;
	size[x]=1;
	int maxson=-1;
	for(int i=head[x];i;i=edge[i].next)
	{
		int v=edge[i].to;
		if(v==f)
			continue;
		dfs1(v,x,deep+1);
		size[x]+=size[v];
		if(size[v]>maxson)
		{
			son[x]=v;
			maxson=size[v];
		}
	}
}

void dfs2(int x,int topf)
{
	id[x]=++cnt;
	wt[cnt]=w[x];
	top[x]=topf;
	if(!son[x])
		return;
	dfs2(son[x],topf);
	for(int i=head[x];i;i=edge[i].next)
	{
		int v=edge[i].to;
		if(v!=fa[x]&&v!=son[x])
			dfs2(v,v);
	}
}

int main()
{
	n=Read(),m=Read();
	for(int i=1;i<=n;i++)
		w[i]=Read();
	for(int i=1;i<n;i++)
	{
		int a=Read(),b=Read();
		Add_edge(a,b);
	}
	dfs1(1,0,1);
	dfs2(1,1);
	build(1,n);
	char opt[5];
	while(m--)
	{
		int x,y,z;
		scanf("%s",opt);
		if(opt[0]=='C')
		{
			x=Read(),y=Read(),z=Read();
			updRange(x,y,z);
		}
		else
		{
			x=Read(),y=Read();
			printf("%d\n",qRange(x,y));
		}
	}
	return 0;
}
```

---

## 作者：intruder (赞：3)

额，裸的线段树加上一个裸的树剖就好了，唯一需要注意的地方就在查询的时候，讨论top和fa[top[]]的时候我们需要将答案减一，然后....很难说清楚，直接看代码把。

线段树维护左端颜色右端和颜色总数，update的时候同上

        




```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#define ls u<<1,l,mid
#define rs u<<1|1,mid+1,r
#define maxn 200020
using namespace std;
void init(){
    freopen("paint.in","r",stdin);
    freopen("paint.out","w",stdout);
}
int n,m,top[maxn],f[maxn],size[maxn],tot=1,cnt,dfn[maxn],son[maxn],head[maxn*3],col[maxn],h[maxn],nu[maxn];
struct edge{
    int v,next;
}e[maxn*3];
void adde(int a,int b){
    e[tot].v=b;
    e[tot].next=head[a];
    head[a]=tot++;
}
void dfs1(int u,int fa){
    size[u]=1;h[u]=h[fa]+1;f[u]=fa;
    for(int i=head[u];~i;i=e[i].next){
        int v=e[i].v;if(v==fa)continue;
        dfs1(v,u);
        size[u]+=size[v];
        if(size[v]>size[son[u]])son[u]=v;
    }
}
void dfs2(int u,int fa,int ff){
    dfn[u]=++cnt;nu[cnt]=u;top[u]=ff;
    if(son[u])dfs2(son[u],u,ff);
    for(int i=head[u];~i;i=e[i].next){
        int v=e[i].v;if(v==fa||v==son[u])continue;
        dfs2(v,u,v);
    }
}
struct node{
    int l,r,sum,lc,rc,lazy;
}nod[maxn*4];
void push_up(int u){
    nod[u].lc=nod[u<<1].lc ,nod[u].rc=nod[u<<1|1].rc ;//我擦我擦我擦我擦我擦我擦我擦 
    nod[u].sum=nod[u<<1].sum+nod[u<<1|1].sum;
    if(nod[u<<1].rc==nod[u<<1|1].lc)nod[u].sum--;
}
void push_down(int u){
    int ll=u<<1,rr=u<<1|1;
    if(nod[u].lazy==-1)return ;
    int add=nod[u].lazy;
    nod[ll].lazy=nod[rr].lazy=nod[ll].lc=nod[ll].rc=nod[rr].lc=nod[rr].rc=add;
    nod[ll].sum=nod[rr].sum=1;
    nod[u].lazy=-1;
}
void build(int u,int l,int r){
    nod[u].l=l,nod[u].r=r,nod[u].lazy=-1;
    if(l==r){
        nod[u].sum=1;nod[u].lc=nod[u].rc=col[nu[l]];
        return;
    }
    int mid=l+r>>1;
    build(ls);build(rs);
    push_up(u);
}
void update(int u,int l,int r,int x,int y,int add){
    if(l==x&&y==r){
        nod[u].sum=1;nod[u].lc=nod[u].rc=nod[u].lazy=add;
        return;
    }
    push_down(u);
    int mid=l+r>>1;
    if(x>mid)update(rs,x,y,add);
    else if(y<=mid)update(ls,x,y,add);
    else update(ls,x,mid,add),update(rs,mid+1,y,add);
    push_up(u);
}
int query(int u,int l,int r,int x,int y){
    if(x==l&&y==r){
        return nod[u].sum;
    }
    push_down(u);
    int mid=l+r>>1;
    if(x>mid)return query(rs,x,y);
    else if(y<=mid)return query(ls,x,y);
    else {
        int ans=query(ls,x,mid)+query(rs,mid+1,y);
        if(nod[u<<1].rc==nod[u<<1|1].lc)ans--;
        return ans;
    }
}
int query_colour(int u,int l,int r,int x){
    if(l==r)return nod[u].lc;
    push_down(u);
    int mid=l+r>>1;
    if(x>mid)return query_colour(rs,x);
    else return query_colour(ls,x);
}
void change(int a,int b,int add){
    while(top[a]!=top[b]){
        if(h[top[a]]>h[top[b]])swap(a,b);
        update(1,1,cnt,dfn[top[b]],dfn[b],add);
        b=f[top[b]];
    }
    if(h[a]>h[b])swap(a,b);
    update(1,1,cnt,dfn[a],dfn[b],add);
}
int QUERY(int a,int b){
    int ans=0,nc,fc;
    while(top[a]!=top[b]){
        if(h[top[a]]>h[top[b]])swap(a,b);
        ans+=query(1,1,cnt,dfn[top[b]],dfn[b]);
        nc=query_colour(1,1,cnt,dfn[top[b]]);
        fc=query_colour(1,1,cnt,dfn[f[top[b]]]);
        b=f[top[b]];
        if(nc==fc)ans--;
    }
    if(h[a]>h[b])swap(a,b);
    ans+=query(1,1,cnt,dfn[a],dfn[b]);
    return ans==0?1:ans;
}
int main(){
    //init();
    scanf("%d%d",&n,&m);
    memset(head,-1,sizeof(head));
    for(int i=1;i<=n;i++)scanf("%d",col+i);
    for(int a,b,i=1;i<n;i++){
        scanf("%d%d",&a,&b);
        adde(a,b);adde(b,a);
    }
    dfs1(1,1);dfs2(1,1,1);
    build(1,1,cnt);
    /*for(int i=1;i<=n;i++){
        printf("%d %d\n",query_colour(1,1,cnt,dfn[i]),query(1,1,cnt,dfn[i],dfn[i]));
    }*/
    char s[5];
    int a,b,c;
    /*while(scanf("%d%d",&a,&b)!=EOF){
        printf("%d\n",query(1,1,cnt,dfn[a],dfn[b]));
    }*/
    while(m--){
        scanf("%s%d%d",s,&a,&b);
        if(s[0]=='Q')printf("%d\n",QUERY(a,b));
        else {
            scanf("%d",&c);
            change(a,b,c);
        }
    }
    return 0;
}
```

---

## 作者：Wall_breaker (赞：2)

### ~~大家好！这里蒟蒻一枚~~
## ~~我们来解读一下这道有趣（po gai）的题目~~
这是一道很有趣（kewu）的题，我花0.5h左右才将AC代码排出（~~蒟蒻的特点：慢~~）。下面我来谈谈思路。

（前置知识：树链剖分 + 线段树[%%%%%大佬讲课](https://www.luogu.org/blog/communist/shu-lian-pou-fen-yang-xie)）
#### 一.你看出树链剖分了吗？
某大佬：废话，题目标签上不写了嘛。
#### 二.如何用线段树统计初始段数？
与其他题目不同，这个树剖我们要统计三个变量：

**1.该段颜色段数。**

**2和3.该段区间左右节点颜色。**

**对于[L, R] 区间，我们只需要将左区间与右区间的段数相加，在判断中间是否能连成一段即可**

举2个栗子????：

1. "111" + "211" -> 左1 + 右2 = 总3
2. "111" + "111" ->左1 + 右1 - （1 == 1） = 总1

于是乎，对于一整段区间的统计（线段树），我们就可以得到公式：

**t[p] = t[p << 1] + t[p << 1 | 1] - (rig[p << 1] == lef[p << 1 | 1]);** （~~ps：你们懂位运算吧~~）
		
**lef[p] = lef[p << 1];**

**rig[p] = rig[p << 1 | 1];**

到这里，你已经切了33.33333%的题了！

#### 三.如何用线段树改变颜色
有了二的想法，这个就简单多了。

运用区间修改，打tag即可（不要在意码风）
```cpp
inline void modify(int p, int l, int r, int ql, int qr, int k) {
	if (l >= ql && r <= qr) {
		t[p] = 1;
		tag[p] = k;
		lef[p] = rig[p] = k;
	}
	else {
		if (tag[p]) down(p);
		int mid = l + r >> 1;
		if (mid >= ql) modify(p << 1, l, mid, ql, qr, k);
		if (mid < qr) modify(p << 1 | 1, mid + 1, r, ql, qr, k);
		t[p] = t[p << 1] + t[p << 1 | 1] - (rig[p << 1] == lef[p << 1 | 1]);
		lef[p] = lef[p << 1];
		rig[p] = rig[p << 1 | 1];
	}
}
```
#### 四.注意事项
**！！！绝对要记住，当你将树剖路径搞出来查询时，由于两段区间并不连续，因此你要手动判断头尾是否一致**
```cpp
inline void ask(int x, int y) {
	int fx = top[x], fy = top[y];
	while(fx != fy) {
		if (dfn[fx] < dfn[fy]) {
			swap(x, y);
			swap(fx, fy);
		}
		query(1, 1, cnt, seg[fx], seg[x]);//寻找该区间
		col1(1, 1, cnt, seg[fx]);//上个区间的尾
		col2(1, 1, cnt, seg[f[fx]]);//下个区间的头
		if (q1 == q2) ans --;
		x = f[fx]; fx = top[x];
	}
	if (dfn[x] > dfn[y]) swap(x, y);
	query(1, 1, cnt, seg[x], seg[y]);
}
```
#### 五.全代码
**码风之气天上来，AC之力不复回**
```
#include<bits/stdc++.h>
using namespace std;
template <typename T> inline void read(T &x) {
	x = 0;
	T f = 1;
	char c = getchar();
	for (; !isdigit(c); c = getchar()) if (c == '-') f = -1;
	for (; isdigit(c); c = getchar()) x = (x << 1) + (x << 3) + (c ^ 48);
	x *= f;
}
inline void d_read(double &x) {
	x = 0.0;
	int f = 1;
	char c = getchar();
	for (; !isdigit(c); c = getchar()) if (c == '-') f = -1;
	for (; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48);
	if (c == '.'){
		double num = 1.0;
		c = getchar();
		for (; isdigit(c); c = getchar()) x = x + (num /= 10) * (c ^ 48);
	}
	x *= f;
}

template <typename T> inline void w(T x) {
	if (x > 9) w(x / 10);
	putchar(x % 10 + 48);
}
template <typename T> inline void write(T x, char c) {
	if (x < 0){
		putchar('-');
		x = -x;
	}
	w(x);
	putchar(c);
}
int ans, cnt, q1, q2, a[100005], head[100005], dfn[100005], f[100005], son[100005], siz[100005], seg[100005], rev[100005], top[100005], lef[400005], rig[400005], t[400005], tag[400005];
struct info{
	int to, nex;
}g[200005];
inline void build(int p, int l, int r) {
	if (l == r) {
		t[p] = 1;
		lef[p] = rig[p] = a[rev[l]];
	}
	else {
		int mid = l + r >> 1;
		build(p << 1, l, mid);
		build(p << 1 | 1, mid + 1, r);
		t[p] = t[p << 1] + t[p << 1 | 1] - (rig[p << 1] == lef[p << 1 | 1]);
		lef[p] = lef[p << 1];
		rig[p] = rig[p << 1 | 1];
	}
	//cout << l << ' ' << r << ' ' << p << ' ' << lef[p] << endl;
}
inline void down(int p) {
	t[p << 1] = t[p << 1 | 1] = 1;
	tag[p << 1] = tag[p << 1 | 1] = lef[p << 1] = lef[p << 1 | 1] = rig[p << 1] = rig[p << 1 | 1] = tag[p];
	tag[p] = 0;
}
inline void modify(int p, int l, int r, int ql, int qr, int k) {
	if (l >= ql && r <= qr) {
		t[p] = 1;
		tag[p] = k;
		lef[p] = rig[p] = k;
	}
	else {
		if (tag[p]) down(p);
		int mid = l + r >> 1;
		if (mid >= ql) modify(p << 1, l, mid, ql, qr, k);
		if (mid < qr) modify(p << 1 | 1, mid + 1, r, ql, qr, k);
		t[p] = t[p << 1] + t[p << 1 | 1] - (rig[p << 1] == lef[p << 1 | 1]);
		lef[p] = lef[p << 1];
		rig[p] = rig[p << 1 | 1];
	}
}
inline void query(int p, int l, int r, int ql, int qr) {
	if (l >= ql && r <= qr) {
		ans += t[p];
	}
	else {
		if (tag[p]) down(p);
		int mid = l + r >> 1;
		if (mid >= ql && mid < qr) {
			query(p << 1, l, mid, ql, qr);
			query(p << 1 | 1, mid + 1, r, ql, qr);
			ans -= (rig[p << 1] == lef[p << 1 | 1]);
		}
		else {
			if (mid >= ql) {
				query(p << 1, l, mid, ql, qr);
			}
			if (mid < qr) {
				query(p << 1 | 1, mid + 1, r, ql, qr);
			}
		}
	}
}
inline void col1(int p, int l, int r, int k) {
	if (l == r && r == k) {
		q1 = lef[p];
	}
	else {
		if (tag[p]) down(p);
		int mid = l + r >> 1;
		if (mid >= k) col1(p << 1, l, mid, k);
		if (mid < k) col1(p << 1 | 1, mid + 1, r, k);
	}
}
inline void col2(int p, int l, int r, int k) {
	if (l == r && r == k) {
		q2 = lef[p];
	}
	else {
		if (tag[p]) down(p);
		int mid = l + r >> 1;
		if (mid >= k) col2(p << 1, l, mid, k);
		if (mid < k) col2(p << 1 | 1, mid + 1, r, k);
	}
}
inline void dfs1(int p, int fa) {
	dfn[p] = dfn[fa] + 1;
	f[p] = fa;
	siz[p] = 1;
	for (int e = head[p]; e; e = g[e].nex) {
		int u = g[e].to;
		if (u != fa) {
			dfs1(u, p);
			siz[p] += siz[u];
			if (siz[u] > siz[son[p]]) son[p] = u;
		}
	}
}
inline void dfs2(int p) {
	if (son[p]) {
		seg[son[p]] = ++ cnt;
		rev[cnt] = son[p];
		top[son[p]] = top[p];
		dfs2(son[p]);
	}
	for (int e = head[p]; e; e = g[e].nex) {
		int u = g[e].to;
		if (!top[u]) {
			seg[u] = ++ cnt;
			rev[cnt] = u;
			top[u] = u;
			dfs2(u);
		}
	}
}
inline void update(int x, int y, int z) {
	int fx = top[x], fy = top[y];
	while(fx != fy) {
		if (dfn[fx] < dfn[fy]) {
			swap(x, y);
			swap(fx, fy);
		}
		modify(1, 1, cnt, seg[fx], seg[x], z);
		x = f[fx]; fx = top[x];
	}
	if (dfn[x] > dfn[y]) swap(x, y);
	modify(1, 1, cnt, seg[x], seg[y], z);
}
inline void ask(int x, int y) {
	int fx = top[x], fy = top[y];
	while(fx != fy) {
		if (dfn[fx] < dfn[fy]) {
			swap(x, y);
			swap(fx, fy);
		}
		query(1, 1, cnt, seg[fx], seg[x]);
		col1(1, 1, cnt, seg[fx]);
		col2(1, 1, cnt, seg[f[fx]]);
		if (q1 == q2) ans --;
		x = f[fx]; fx = top[x];
	}
	if (dfn[x] > dfn[y]) swap(x, y);
	query(1, 1, cnt, seg[x], seg[y]);
}
int main(void) {
	int n, m, len = 0;
	read(n); read(m);
	for (int i = 1; i <= n; i ++) read(a[i]);
	for (int i = 1; i <= n - 1; i ++) {
		int x, y;
		read(x); read(y);
		g[++ len] = (info) {y, head[x]};
		head[x] = len;
		g[++ len] = (info) {x, head[y]};
		head[y] = len;
 	} 
 	dfs1(1, 0);
 	seg[1] = cnt = rev[1] = top[1] = 1;
 	dfs2(1);
 	build(1, 1, cnt);
 	for (int i = 1; i <= m; i ++) {
 		char c = getchar();
 		while(!isalpha(c)) c = getchar();
 		if (c == 'C') {
 			int x, y, z;
 			read(x); read(y); read(z);
 			update(x, y, z);
		}
		 else {
		 	int x, y;
		 	ans = 0;
		 	read(x); read(y);
		 	ask(x, y);
		 	write(ans, '\n');
		}
	}
	return 0;
}

```
#### 六.彩蛋
**有不对的请各位神犇指出，我有可能会改（前提是我会）**

---

## 作者：_Sein (赞：2)

## 题面描述
[~~滑稽~~](https://www.luogu.org/problem/P2486)

## 思路
~~初看不可做，再看不可做。~~

之后过了几天之后，才想起来有这道题。

铁头娃$\operatorname{LCT}$来了。

由于是统计不同的颜色段数，那么一个颜色段与另一颜色段接壤的地方，也就是左端点的$\operatorname{col}$，以及右端点的$\operatorname{col}$。

转化成$\operatorname{LCT}$也就是$\operatorname{t[rc].rcol}$，$\operatorname{t[lc].lcol}$，之后拓展时，更新状态即可。

注意，若$\operatorname{t[rc].lcol}=\operatorname{t[p].col}$，相应区间数需要减一，$\operatorname{t[lc].rcol}$同理。

## AC code
```cpp
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<cstdlib>
#include<cstring>
#define gc getchar()
using namespace std;
const int N=1e5+10;
inline void qr(int &x)
{
	x=0;int f=1;char c=gc;
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=gc;}
	while(c>='0'&&c<='9'){x=x*10+(c^48);c=gc;}
	x*=f;
}
void qw(int x)
{
	if(x<0)x=-x,putchar('-');
	if(x/10)qw(x/10);
	putchar(x%10+48);
}
struct node{int f,son[2],lcol,rcol,s,col,lz;bool rv;}t[N];
inline bool nroot(int p){return t[t[p].f].son[0]==p||t[t[p].f].son[1]==p;}
inline void update(int p)
{
	int lc=t[p].son[0],rc=t[p].son[1];
	t[p].lcol=lc?t[lc].lcol:t[p].col;
	t[p].rcol=rc?t[rc].rcol:t[p].col;
	if(lc&&rc)t[p].s=t[lc].s+t[rc].s+1-(t[p].col==t[lc].rcol)-(t[p].col==t[rc].lcol);
	else if(lc)t[p].s=t[lc].s+1-(t[p].col==t[lc].rcol);
	else if(rc)t[p].s=t[rc].s+1-(t[p].col==t[rc].lcol);
	else t[p].s=1;
}
void crv(int p){if(!p)return ;swap(t[p].lcol,t[p].rcol);swap(t[p].son[0],t[p].son[1]);t[p].rv^=1;}
void ccol(int p,int col){if(!p)return ;t[p].lcol=t[p].rcol=t[p].col=col;t[p].s=1;t[p].lz=col;}
void pushdown(int p)
{
	if(t[p].rv)t[p].rv=0,crv(t[p].son[0]),crv(t[p].son[1]);
	if(t[p].lz)ccol(t[p].son[0],t[p].lz),ccol(t[p].son[1],t[p].lz),t[p].lz=0;
}
void rotate(int p,int w)
{
	int f=t[p].f,gf=t[f].f;
	int r=t[p].son[w],R=f;t[R].son[w^1]=r;if(r)t[r].f=R;
	r=p;R=gf;if(nroot(f))t[R].son[t[R].son[1]==f]=r;t[r].f=R;
	r=f;R=p;t[R].son[w]=r;t[r].f=R;update(f),update(p);
}
void sdfs(int p){if(nroot(p))sdfs(t[p].f);pushdown(p);}
void splay(int p)
{
	for(sdfs(p);nroot(p);)
	{
		int f=t[p].f,gf=t[f].f;
		if(!nroot(f))rotate(p,t[f].son[0]==p);
		else
		{
			if(t[f].son[0]==p&&t[gf].son[0]==f)rotate(f,1),rotate(p,1);
			else if(t[f].son[0]==p&&t[gf].son[1]==f)rotate(p,1),rotate(p,0);
			else if(t[f].son[1]==p&&t[gf].son[0]==f)rotate(p,0),rotate(p,1);
			else rotate(f,0),rotate(p,0);
		}
	}
}
void access(int x)
{
	for(int y=0;x;x=t[y=x].f)
		splay(x),t[x].son[1]=y,update(x);
}
void makeroot(int x)
{
	access(x),splay(x),crv(x);
}
void split(int x,int y)
{
	makeroot(x);access(y);splay(y);
}
void change(int x,int y)
{
	int lz;qr(lz);
	split(x,y);ccol(y,lz);
}
void query(int x,int y)
{
	split(x,y);
	qw(t[y].s);puts("");
}
struct edge{int y,next;}a[N<<1];int len,last[N];
void ins(int x,int y){a[++len]=(edge){y,last[x]};last[x]=len;}
void dfs(int x)
{
	for(int k=last[x],y;k;k=a[k].next)
		if((y=a[k].y)!=t[x].f)
			t[y].f=x,dfs(y);
}
int main()
{
	int n,m;qr(n),qr(m);
	for(int i=1;i<=n;i++)qr(t[i].col),t[i].lcol=t[i].rcol=t[i].col,t[i].s=1;
	for(int i=1,x,y;i<n;i++)qr(x),qr(y),ins(x,y),ins(y,x);
	dfs(1);
	while(m--)
	{
		char s[3];int x,y;scanf("%s",s+1);qr(x),qr(y);
		if(s[1]=='Q')query(x,y);
		else change(x,y);
	}
	return 0;
}
```



---

## 作者：ComplexPug (赞：2)

树剖做法：

就是两个dfs+一个线段树

难度的取决基本==线段树的维护难度

所以对有点线段树基础的，树剖也不难做吧

这里操作有二

一：两点间路径染色

线段树的区间赋值操作

二：查询路径段的个数

考虑线段树如何做

我们发现两端区间的合并取决于他们相连接的那两个颜色

比如这张图
![](https://i.loli.net/2018/12/25/5c22341e3efd1.png)
他两边区间合并的时候，完全就是左区间答案+右区间答案也就是2+2

但是这样

![](https://i.loli.net/2018/12/25/5c22343526dcb.png)

他们合并的答案就是2+2-1了也就是中间连接的两个颜色相同时要减1

明白了这个pushup也就不难写了

这里在说一下查询操作

由于是分开查询的，所以也有可能会中间相同而没有减1

这里就有点套路(技巧？)了，留给你们想吧

光线段树上就完事了吗，当然不是

树链剖分把树给剖了当然会有影响

路径上的维护和序列维护几乎是一样的，只需要看一下两条链之间是否颜色相同就可以了

好了,再不懂就去看一下代码吧

```cpp
#include <bits/stdc++.h>
#define FOR(i,a,b) for(int i=a;i<=b;++i)
using namespace std;
const int N=100007;
int read() {
	int x=0,f=1;char s=getchar();
	for(;s>'9'||s<'0';s=getchar()) if(s=='-') f=-1;
	for(;s>='0'&&s<='9';s=getchar()) x=x*10+s-'0';
	return x*f;
}
int n,m,a[N],col[N],top[N],f[N],son[N],siz[N],dep[N],idx[N],cnt;
struct node {
	int v,nxt;
}e[N<<1];
int head[N],tot;
void add_edge(int u,int v) {
	e[++tot].v=v;
	e[tot].nxt=head[u];
	head[u]=tot;
}
void dfs1(int u,int fa) {
	dep[u]=dep[fa]+1;
	siz[u]=1;
	f[u]=fa;
	for(int i=head[u];i;i=e[i].nxt) {
		int v=e[i].v;
		if(v==fa) continue;
		dfs1(v,u);
		siz[u]+=siz[v];
		if(siz[son[u]] < siz[v]) son[u]=v;
	}
}
void dfs2(int u,int topf) {
	idx[u]=++cnt;
	a[cnt]=col[u];
	top[u]=topf;
	if(!son[u]) return;
	dfs2(son[u],topf);
	for(int i=head[u];i;i=e[i].nxt)
		if(!idx[e[i].v]) dfs2(e[i].v,e[i].v);
}
namespace seg_tree {
	#define ls (rt<<1)
	#define rs (rt<<1|1)
	struct node {
		int l,r,lc,rc;
		int sum,lazy;
	}e[N<<2];
	void pushup(int rt) {
		if(ls&&rs) {
			e[rt].sum=e[ls].sum+e[rs].sum-(e[ls].rc==e[rs].lc);
			e[rt].lc=e[ls].lc;
			e[rt].rc=e[rs].rc;
		} else e[rt]=e[ls+rs];
	}
	void build(int l,int r,int rt) {
		e[rt].l=l,e[rt].r=r;
		if(l==r) {
			e[rt].lc=e[rt].rc=a[l];
			e[rt].sum=1;
			return;
		}
		int mid=(l+r)>>1;
		build(l,mid,ls);
		build(mid+1,r,rs);
		pushup(rt);
	}
	void tag(int rt,int k) {
		e[rt].lc=e[rt].rc=k;
		e[rt].sum=1;
		e[rt].lazy=k;
	}
	void pushdown(int rt) {
		if(e[rt].lazy) {
			tag(ls,e[rt].lazy);
			tag(rs,e[rt].lazy);
			e[rt].lazy=0;
		}
	}
	void modify(int L,int R,int k,int rt) {
		if(L<=e[rt].l&&e[rt].r<=R) {
			tag(rt,k);
			return;
		}
		pushdown(rt);
		int mid=(e[rt].l+e[rt].r)>>1;
		if(L<=mid) modify(L,R,k,ls);
		if(R>mid) modify(L,R,k,rs);
		pushup(rt);
	}
	node query(int L,int R,int rt) {
		if(L<=e[rt].l&&e[rt].r<=R) return e[rt];
		pushdown(rt);
		int mid=(e[rt].l+e[rt].r)>>1;
		if(L<=mid && R>mid) {
			node a=query(L,R,ls),b=query(L,R,rs);
			node c;
			c.lc=a.lc;
			c.rc=b.rc;
			c.sum=a.sum+b.sum-(a.rc==b.lc);
			return c;
		}
		if(L<=mid) return query(L,R,ls);
		if(R>mid) return query(L,R,rs);
	}
	int ask(int L,int rt) {
		if(e[rt].l==e[rt].r) return e[rt].lc;
		pushdown(rt);
		int mid=(e[rt].l+e[rt].r)>>1;
		if(L<=mid) return ask(L,ls);
		else return ask(L,rs);
	}
}
void CC(int x,int y,int k) {
	while(top[x]!=top[y]) {
		if(dep[top[x]] < dep[top[y]]) swap(x,y);
		seg_tree::modify(idx[top[x]],idx[x],k,1);
		x=f[top[x]];
	}
	if(dep[x]>dep[y])swap(x,y);
	seg_tree::modify(idx[x],idx[y],k,1);
}
void QQ(int x,int y) {
	int ans=0;
	while(top[x]!=top[y]) {
		if(dep[top[x]] < dep[top[y]]) swap(x,y);
		ans+=seg_tree::query(idx[top[x]],idx[x],1).sum;
		ans-=(seg_tree::ask(idx[top[x]],1)==seg_tree::ask(idx[f[top[x]]],1));
		x=f[top[x]];
	}
	if(dep[x]>dep[y])swap(x,y);
	ans+=seg_tree::query(idx[x],idx[y],1).sum;
	printf("%d\n", ans);
}
int main() {
	n=read(),m=read();
	FOR(i,1,n) col[i]=read();
	FOR(i,2,n) {
		int x=read(), y=read();
		add_edge(x,y);
		add_edge(y,x);
	}
	dfs1(1,0);
	dfs2(1,1);
	seg_tree::build(1,n,1);
	FOR(i,1,m) {
		char s=getchar();
		while(s==' '||s=='\n') s=getchar();
		int x=read(), y=read(), z;
		if(s=='C') z=read(),CC(x,y,z);
		else QQ(x,y);
	}
	return 0;
}
```

---

## 作者：qq734628996 (赞：2)

两种操作：
1. 将两结点之间路径染色。
2. 询问两结点之间路径连续颜色段数。

首先考虑区间染色问题，需要支持区间修改，即要下推标记；需要区间合并，则线段树需要维护左端点颜色和右端点颜色以及连续颜色段数，合并时需要检查两区间中间颜色是否相同。

其次考虑树上的区间合并，树链剖分思想是两个结点往上跳，所以开两个维护答案，最后合并答案，需要考虑区间的反转，具体可以手推一下就出来了。

```cpp
#include <bits/stdc++.h>
using namespace std;

#define REP(i,n) for(int i = 0; i < n; i++)
#define PER(i,n) for(int i = n-1; i >= 0; i--)
#define FOR(i,l,r) for(int i = l; i <= r; i++)
#define ROF(i,l,r) for(int i = r; i >= l; i--)
#define DEBUG(x) cout << #x << "=" << x << endl;
#define SHOW1(A,n) { REP(i,n) cout<<A[i]<<(i==n-1?'\n':' '); }
#define SHOW2(A,m,n) { REP(j,m) SHOW1(A[j],n) }
#define pb push_back
#define fi first
#define se second
#define ALL(x) x.begin(),x.end()
#define SZ(x) (int)((x).size())
typedef long long LL;
typedef unsigned long long ULL;
typedef pair<int, int> pii;
typedef pair<LL, LL> pll;
const int INF = 0x3f3f3f3f, MOD = 1000000007;
const double PI = acos(-1), EPS = 1e-6;
const int MAXN = 1e5+9, MAXM = 2e5+9;

int n,q,a[MAXN],val[MAXN];
#define ls x<<1
#define rs x<<1|1
#define mid (l+r)/2
struct node {
    int lc,rc,cnt,lazy;
    void update(int val) {
        lc=rc=lazy=val;
        cnt=1;
    }
} T[MAXN<<2];
node cal(node a, node b) {
    return {a.lc,b.rc,a.cnt+b.cnt-(a.rc==b.lc),0};
}
void up(int x) {
    T[x]=cal(T[ls],T[rs]);
}
void down(int x) {
    if (T[x].lazy) {
        T[ls].update(T[x].lazy);
        T[rs].update(T[x].lazy);
        T[x].lazy=0;
    }
}
void build(int x, int l, int r) {
    if (l==r) T[x]={a[l],a[l],1,0};
    else {
        build(ls,l,mid);
        build(rs,mid+1,r);
        up(x);
    }
}
void update(int x, int l, int r, int ql, int qr, int val) {
    if (ql<=l && r<=qr) T[x].update(val);
    else {
        down(x);
        if (ql<=mid) update(ls,l,mid,ql,qr,val);
        if (mid<qr) update(rs,mid+1,r,ql,qr,val);
        up(x);
    }
}
node query(int x, int l, int r, int ql, int qr) {
    if (ql<=l && r<=qr) return T[x];
    else {
        node ans;
        down(x);
        if (ql<=mid && mid<qr) {
            node a=query(ls,l,mid,ql,qr);
            node b=query(rs,mid+1,r,ql,qr);
            ans=cal(a,b);
        } else {
            if (ql<=mid) ans=query(ls,l,mid,ql,qr);
            else ans=query(rs,mid+1,r,ql,qr);
        }
        up(x);
        return ans;
    }
}
struct edge {
    int to,nxt;
} e[MAXM];
int f[MAXN],tot;
void add(int u, int v) {
    e[tot]={v,f[u]}; f[u]=tot++;
}
int sz[MAXN],fa[MAXN],d[MAXN],son[MAXN],top[MAXN],clk,in[MAXN];
void dfs(int u) {
    sz[u]=1; d[u]=d[fa[u]]+1; son[u]=0;
    for (int i=f[u]; ~i; i=e[i].nxt) {
        int v=e[i].to;
        if (v!=fa[u]) {
            fa[v]=u; dfs(v);
            sz[u]+=sz[v];
            if (sz[v]>sz[son[u]]) son[u]=v;
        }
    }
}
void dfs(int u, int tp) {
    a[++clk]=val[u]; in[u]=clk;
    top[u]=tp;
    if (son[u]) dfs(son[u],tp);
    for (int i=f[u]; ~i; i=e[i].nxt) {
        int v=e[i].to;
        if (v!=fa[u] && v!=son[u]) dfs(v,v);
    }
}
void tree_update(int x, int y, int val) {
    while (top[x]!=top[y]) {
        if (d[top[x]]<d[top[y]]) swap(x,y);
        update(1,1,n,in[top[x]],in[x],val);
        x=fa[top[x]];
    }
    if (in[x]>in[y]) swap(x,y);
    update(1,1,n,in[x],in[y],val);
}
int tree_query(int x, int y) {
    node a{0,0,0}, b{0,0,0};
    while (top[x]!=top[y]) {
        if (d[top[x]]<d[top[y]]) swap(x,y), swap(a,b);
        if (a.cnt) a=cal(query(1,1,n,in[top[x]],in[x]),a);
        else a=query(1,1,n,in[top[x]],in[x]);
        x=fa[top[x]];
    }
    if (in[x]>in[y]) swap(x,y), swap(a,b);
    if (b.cnt) b=cal(query(1,1,n,in[x],in[y]),b);
    else b=query(1,1,n,in[x],in[y]);
    swap(a.lc,a.rc);
    return cal(a,b).cnt;
}
void init() {
    tot=fa[1]=clk=0;
    memset(f,-1,sizeof(f));
}

int main()
{
#ifdef LOCAL
    freopen("i.txt", "r", stdin);
    //freopen("o.txt", "w", stdout);
#endif //LOCAL

    while (scanf("%d%d", &n,&q)==2) {
        init();
        FOR(i,1,n) scanf("%d", &val[i]);
        REP(i,n-1) {
            int x,y; scanf("%d%d", &x,&y);
            add(x,y); add(y,x);
        }
        dfs(1);
        dfs(1,1);
        build(1,1,n);
        while (q--) {
            char op[2]; int x,y,z; scanf("%s%d%d", op,&x,&y);
            if (op[0]=='Q') printf("%d\n", tree_query(x,y));
            else scanf("%d", &z), tree_update(x,y,z);
        }
    }

    return 0;
}
```


---

## 作者：Logey (赞：2)

树剖模板题。  
剖分之后把树上的点根据 $\text{dfs}$ 序变成序列之后，就是很简单的线段树序列操作了。  
第一个操作是区间赋值，第二个操作是查询区间有多少个连续数字相同的段。  
这个操作挺套路的，在线段树的 $\text{pushUp}$ 函数和查询的时候考虑下怎么合并。  
对于线段树上的每个结点，需要记录的信息有  
$\text{lcol}:$ 该区间最左边的节点的颜色。  
$\text{rcol}:$ 该区间最右边的节点的颜色。  
$\text{cnt}$ 该区间对答案的贡献，即有多少个颜色段。  
$\text{tag}$ 懒标记，表示该点维护的区间内所有的点的颜色都被改为 $\text{tag}$。  
当合并两个儿子的信息的时候，只需要把左右儿子的 $\text{cnt}$ 加起来，然后判断一下中间颜色是否相同，相同的话就把$\text{cnt- -}$。  
查询的时候同理。  
代码也非常好写。  
```cpp
void pushUp() {
   cnt = lc->cnt + rc->cnt - (lc->rcol == rc->lcol);
   lcol = lc->lcol, rcol = rc->rcol;
}
```  

还有一个要注意的地方是查询的时候，要记录上一次查询的最上面的结点的颜色，再判断一下。  

```cpp
int Query(int u, int v) {
    int ret = 0, cu = 0, cv = 0;
    while (top[u] != top[v]) {
        if (deep[top[u]] < deep[top[v]]) {
            std::swap(u, v);
            std::swap(cu, cv);
        }
        int tmp = root->queryColor(dfn[u]);
        ret += root->queryCnt(dfn[top[u]], dfn[u]) - (cu == tmp);
        cu = root->queryColor(dfn[top[u]]);
        u = fa[top[u]];
    }
    if (dfn[u] > dfn[v]) {
        std::swap(u, v);
        std::swap(cu, cv);
    }
    ret += root->queryCnt(dfn[u], dfn[v]) - (cv == root->queryColor(dfn[v])) - (cu == root->queryColor(dfn[u]));
    return ret;
}
```

### 完整代码  

```cpp
#include <cstdio>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <iostream>
#include <climits>

const int MAXN = 1e5 + 7;

struct Edge {
    int t, next;
} edge[MAXN << 1];

int n, m;
int head[MAXN], cnt;
int col[MAXN];
int fa[MAXN], deep[MAXN], size[MAXN], son[MAXN], dfn[MAXN], ts, top[MAXN], pos[MAXN];

struct Node {
    int l, r, mid;
    Node *lc, *rc;
    int lcol, rcol, cnt;
    int tag;

    Node() {}

    Node(int l, int r, Node *lc, Node *rc) : l(l), r(r), mid((l + r) / 2), lc(lc), rc(rc), lcol(0), rcol(0), cnt(0), tag(0) {}

    static Node *build(int l, int r) {
        Node *ret;
        if (l == r) {
            ret = new Node(l, r, NULL, NULL);
            ret->lcol = ret->rcol = col[pos[l]];
            ret->cnt = 1;
        } else {
            int mid = (l + r) >> 1;
            ret = new Node(l, r, build(l, mid), build(mid + 1, r));
            ret->pushUp();
        }
        return ret;
    }

    void pushUp() {
        cnt = lc->cnt + rc->cnt - (lc->rcol == rc->lcol);
        lcol = lc->lcol, rcol = rc->rcol;
    }

    void pushDown() {
        if (tag) {
            lc->cover(tag), rc->cover(tag);
            tag = 0;
        }
    }

    void cover(int delta) {
        lcol = rcol = delta;
        tag = delta;
        cnt = 1;
    }

    void solveCover(int left, int right, int delta) {
        if (l == left && r == right) return cover(delta);
        pushDown();
        if (right <= mid) lc->solveCover(left, right, delta);
        else if (left > mid) rc->solveCover(left, right, delta);
        else lc->solveCover(left, mid, delta), rc->solveCover(mid + 1, right, delta);
        pushUp();
    }

    int queryCnt(int left, int right) {
        if (l == left && r == right) return cnt;
        pushDown();
        if (right <= mid) return lc->queryCnt(left, right);
        else if (left > mid) return rc->queryCnt(left, right);
        else  return lc->queryCnt(left, mid) + rc->queryCnt(mid + 1, right) - (lc->rcol == rc->lcol);
    }

    int queryColor(int pos) {
        if (l == pos && r == pos) return lcol;
        pushDown();
        if (pos <= mid) return lc->queryColor(pos);
        else return rc->queryColor(pos);
    }
} *root;

void dfs1(int u, int pre) {
    fa[u] = pre;
    deep[u] = deep[pre] + 1;
    size[u] = 1;
    int maxSize = 0;

    for (int e = head[u]; e; e = edge[e].next) {
        int v = edge[e].t;
        if (v == pre) continue;
        dfs1(v, u);
        size[u] += size[v];
        if (!son[u] || maxSize < size[v]) {
            maxSize = size[v];
            son[u] = v;
        }
    }
}

void dfs2(int u, int tp) {
    top[u] = tp;
    dfn[u] = ++ts;
    pos[ts] = u;
    if (son[u]) dfs2(son[u], tp);

    for (int e = head[u]; e; e = edge[e].next) {
        int v = edge[e].t;
        if (v == fa[u] || v == son[u]) continue;
        dfs2(v, v);
    }
}

void Cover(int u, int v, int delta) {
    while (top[u] != top[v]) {
        if (deep[top[u]] < deep[top[v]]) std::swap(u, v);
        root->solveCover(dfn[top[u]], dfn[u], delta);
        u = fa[top[u]];
    }
    if (dfn[u] > dfn[v]) std::swap(u, v);
    root->solveCover(dfn[u], dfn[v], delta);
}

int Query(int u, int v) {
    int ret = 0, cu = 0, cv = 0;
    while (top[u] != top[v]) {
        if (deep[top[u]] < deep[top[v]]) {
            std::swap(u, v);
            std::swap(cu, cv);
        }
        int tmp = root->queryColor(dfn[u]);
        ret += root->queryCnt(dfn[top[u]], dfn[u]) - (cu == tmp);
        cu = root->queryColor(dfn[top[u]]);
        u = fa[top[u]];
    }
    if (dfn[u] > dfn[v]) {
        std::swap(u, v);
        std::swap(cu, cv);
    }
    ret += root->queryCnt(dfn[u], dfn[v]) - (cv == root->queryColor(dfn[v])) - (cu == root->queryColor(dfn[u]));
    return ret;
}

inline void add(int u, int v) {
    edge[++cnt] = (Edge) {v, head[u]}; head[u] = cnt;
}

int main(int argc, char *argv[]) {
    scanf("%d %d", &n, &m);
    for (int i = 1; i <= n; i++) {
        scanf("%d", col + i);
    }
    int u, v;
    for (int i = 1; i < n; i++) {
        scanf("%d %d", &u, &v);
        add(u, v);
        add(v, u);
    }
    deep[1] = 1;
    dfs1(1, 0);
    dfs2(1, 1);
    root = Node::build(1, n);
    char o[10];
    int x, y, z;
    while (m--) {
        scanf("%s %d %d", o, &x, &y);
        if (o[0] == 'C') {
            scanf("%d", &z);
            Cover(x, y, z);
        } else {
            printf("%d\n", Query(x, y));
        }
    }
    return 0;
}

```


---

## 作者：Delva (赞：2)

这道题很好想，就是树链剖分将重儿子优先的dfs序用线段树维护，线段树维护区间的**第一个颜色f、最后一个颜色b、颜色
段数num**信息，若左信息是m1，右信息是m2，那么合并信息就是 :
```cpp
m.f=m1.f;
m.b=m2.b;
m.num=m1.num+m2.num-(m1.b==m2.f);
```
但是有很多细节值得注意：

1.将需要维护的数据f,r,num打包成一个结构体Msg，并且写一个combine函数合并数据（线段树维护的基本性质），这样会方便维护

2.结构体里面的所有变量一定要在构造函数里面初始化！（这个把我坑了很久）不然会WA

3.建议写一个setNode函数，这样pushDown和set函数的可读性更强

这样写出来的代码就简洁易懂了
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
const int maxn = 100003;
struct Edge{
    int next,to;Edge(){}
    Edge(int a,int b){next=a,to=b;}
}edge[maxn<<1];
int n,m;
struct Msg{bool no;//维护的信息包  //no==1：“没有信息”
    int f,b,num;Msg(int noo=0){f=b=num=0;no=noo;}
    Msg(int a,int aa,int aaa){f=a;b=aa;num=aaa;no=0;}
    void set(int x){f=b=x;num=1;}
};
Msg combine(Msg m1,Msg m2){
    if(m1.no)return m2;if(m2.no)return m1;//舍去“没有信息”
    return Msg(m1.f,m2.b,m1.num+m2.num-(m1.b==m2.f));
}
struct Node *null;
struct Node{//线段树
    Node* ch[2];Msg m;
    int l,r,mid,sets;
    Node(int a,int b){l=a,r=b,mid=a+b>>1,sets=0,ch[0]=ch[1]=null;m=Msg(0);}
    void pushUp(){m=combine(ch[0]->m,ch[1]->m);}
    void setNode(int x){sets=x;m.set(x);}
    void pushDown(){if(sets){ch[0]->setNode(sets);ch[1]->setNode(sets);sets=0;}}
}*root;
int head[maxn],cnt,val[maxn];
int tcnt,dep[maxn],siz[maxn],fa[maxn],son[maxn],top[maxn],pos[maxn],id[maxn];
void addEdge(int u,int v){
    edge[++cnt]=Edge(head[u],v);
    head[u]=cnt;
}
void dfs1(int u,int f){//处理dep,siz,fa,son(重儿子)
    dep[u]=dep[f]+1;fa[u]=f;siz[u]=1;
    for(int i=head[u];i;i=edge[i].next){
        int v=edge[i].to;if(v==f)continue;
        dfs1(v,u);siz[u]+=siz[v];
        if(!son[u]||siz[v]>siz[son[u]])son[u]=v;
    }
}
void dfs2(int u,int t){//处理id(树->线段),pos(线段->树),top(链顶节点)
    top[u]=t;id[u]=++tcnt;pos[tcnt]=u;
    if(!son[u])return;dfs2(son[u],t);
    for(int i=head[u];i;i=edge[i].next){
        int v=edge[i].to;if(id[v])continue;
        dfs2(v,v);
    }
}
void build(Node* &k=root){
    if(k->r==k->l){k->m.set(val[pos[k->l]]);return;}
    build(k->ch[0]=new Node(k->l,k->mid));
    build(k->ch[1]=new Node(k->mid+1,k->r));
    k->pushUp();
}
void set(int ql,int qr,int v,Node* &k=root){
    if(ql>k->r||qr<k->l)return;
    if(ql<=k->l&&qr>=k->r){k->setNode(v);return;}
    k->pushDown();
    set(ql,qr,v,k->ch[0]),set(ql,qr,v,k->ch[1]);
    k->pushUp();
}
Msg query(int ql,int qr,Node* &k=root){//注意以信息包返回
    if(ql>k->r||qr<k->l)return Msg(1);//不在询问区间，返回“没有信息”
    if(ql<=k->l&&qr>=k->r)return k->m;
    k->pushDown();
    return combine(query(ql,qr,k->ch[0]),query(ql,qr,k->ch[1]));
}
void setpath(int x,int y,int v){//完全是树剖lca的板子
    while(top[x]^top[y]){
        if(dep[top[x]]>dep[top[y]])set(id[top[x]],id[x],v),x=fa[top[x]];
        else set(id[top[y]],id[y],v),y=fa[top[y]];
    }if(dep[x]>dep[y])set(id[y],id[x],v);else set(id[x],id[y],v);
}
int quepath(int x,int y){Msg ans1=Msg(1);Msg ans2=Msg(1);//同样是lca板子，但要注意，combine的参数是有序的，即combine(左信息,右信息)，所以注意线段上的顺序
    while(top[x]^top[y]){
        if(dep[top[x]]>dep[top[y]])ans1=combine(query(id[top[x]],id[x]),ans1),x=fa[top[x]];
        else ans2=combine(query(id[top[y]],id[y]),ans2),y=fa[top[y]];
    }if(dep[x]>dep[y])ans1=combine(query(id[y],id[x]),ans1);else ans2=combine(query(id[x],id[y]),ans2);
	return ans1.num+ans2.num-(ans1.f==ans2.f);
}
int main(){int a,b,c;char ch;
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;++i)scanf("%d",&val[i]);
    for(int i=1;i<n;++i){scanf("%d%d",&a,&b);addEdge(a,b);addEdge(b,a);}
    dfs1(1,1);dfs2(1,1);//no root
    null=new Node(0,0);null->m=Msg(1);build(root=new Node(1,n));
    while(m--){cin>>ch;scanf("%d%d",&a,&b);
        if(ch=='Q')printf("%d\n",quepath(a,b));
        else scanf("%d",&c),setpath(a,b,c);
    }return 0;
}

```

---

## 作者：xMinh (赞：2)

# WTF？
我的非正解好像过了……

底下的题解已经把做法说的很清楚了，树剖+线段树，唯一的难点在于判重。

作为一个蒟蒻，我要说一个板子做法……我们知道树剖的时候我们要把这一条路径分成几个区间来处理，但你打上板子之后会发现，这几个区间不会连续操作，而是不断操作top最靠下的区间，可不连续的话怎么判重呢？

### LCA啊！

我们通过LCA把这条路径分成两段，而每一段都能保证从底下的区间向上面的区间依次进行操作，而每一段区间内部被线段树分成好多个小区间，小区间被递归到的顺序满足从左往右，放到树中也就是从上往下，这样设几个全局变量维护上一个区间的信息，就能很轻松的判重辣。

当然还有一点是需要注意的。对于LCA这个点本身，显然我们只能把它放到两段路径中的一段，所以我们可以利用倍增LCA的特性——先跳到LCA的子节点，然后保存下来这个子节点，就可以解决这个矛盾了。

当然LCA中有些细节的地方难以表述，看代码比较好理解。

### %%%xzz球爷太神啦！

代码
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cctype>
#define N (100000 + 10)
using namespace std;
int a[N],deep[N],f[N][25],son[N],dfn[N],top[N],tot[N],idfn[N],head[N<<1];
int sum[N<<2],tag[N<<2],ls[N<<2],rs[N<<2];
int n,m,cnt,Dfn_clock,Pre,pre,Mx,Nxt,xx,yy,Fir,Sec,Sw;

int read() {
    char c=getchar();
    int r=0,f=1;
    while (!isdigit(c)) {
        if (c=='-') f=-1;
        c=getchar();
    }
    while (isdigit(c)) {
        r=(r*10)+(c^48);
        c=getchar();
    }
    return r*f;
}

struct edge {
	int next,to;
}E[N<<1];

void Add(int x,int y) {
	E[++cnt].next=head[x];
	E[cnt].to=y;
	head[x]=cnt;
}

void Dfs1(int x,int fa) {
	deep[x]=deep[fa]+1; f[x][0]=fa; tot[x]=1;
	int Max=-1;
	for (int i=head[x];i;i=E[i].next) {
		int y=E[i].to;
		if (y!=fa) {
			Dfs1(y,x);
			tot[x]+=tot[y];
			if (tot[y]>Max) {
				Max=tot[y];
				son[x]=y;
			}
		}
	}
}

void Dfs2(int x,int tp) {
	dfn[x]=++Dfn_clock;
	idfn[Dfn_clock]=x;
	top[x]=tp;
	if (!son[x]) return;
	Dfs2(son[x],tp);
	for (int i=head[x];i;i=E[i].next) {
		int y=E[i].to;
		if (y!=f[x][0] && y!=son[x]) Dfs2(y,y);			
	}
}

void ST() {
	Mx=log2(n)+1;
	for (int i=1;i<=Mx;i++)
		for (int j=1;j<=n;j++)
			f[j][i]=f[f[j][i-1]][i-1];
}

int Lca(int x,int y) {
	if (deep[x]!=deep[y]) {
		int d=deep[x]-deep[y]-1;
		for (int i=0;i<=Mx;i++)
			if (d&(1<<i)) x=f[x][i];
		xx=x; yy=y;
		if (f[x][0]==y) return y;
		x=f[x][0];
	}
	for (int i=Mx;i>=0;i--) 
		if (f[x][i]!=f[y][i]) {
			x=f[x][i];
			y=f[y][i];
		}
	xx=x; yy=y;
	return f[x][0];
}

void Pushup(int x) {
	int l=(x<<1),r=(x<<1|1);
	sum[x]=sum[l]+sum[r];
	if (rs[l]==ls[r]) --sum[x];
	ls[x]=ls[l]; rs[x]=rs[r];
}

void Pushdown(int x) {
	int l=(x<<1),r=(x<<1|1);
	if (tag[x]) {
		tag[l]=tag[r]=tag[x];
		ls[l]=ls[r]=tag[x];
		rs[l]=rs[r]=tag[x];
		sum[l]=sum[r]=1;
		tag[x]=0;
	}
}

void Build(int l,int r,int x) {
	if (l==r) {
		sum[x]=1; 
		ls[x]=rs[x]=a[idfn[l]];
		return;
	}
	int mid=(l+r)>>1;
	Build(l,mid,x<<1);
	Build(mid+1,r,x<<1|1);
	Pushup(x);
}

void Change(int L,int R,int l,int r,int val,int x) {
	if (L<=l && r<=R) {
		sum[x]=1; 
		ls[x]=rs[x]=tag[x]=val;
		return;
	}
	int mid=(l+r)>>1;
	Pushdown(x);
	if (L<=mid) Change(L,R,l,mid,val,x<<1);
	if (R>mid) Change(L,R,mid+1,r,val,x<<1|1);
	Pushup(x);
}

int Query(int L,int R,int l,int r,int x) {
	int ans=0;
	if (L<=l && r<=R) {
		if (pre==ls[x]) --ans;
		if (!Pre) Pre=ls[x];
		if (Nxt==rs[x] && R==r) --ans;
		ans+=sum[x]; pre=rs[x];
		return ans;
 	}
 	int mid=(l+r)>>1;
 	Pushdown(x);
 	if (L<=mid) ans+=Query(L,R,l,mid,x<<1);
 	if (R>mid) ans+=Query(L,R,mid+1,r,x<<1|1);
 	return ans;
}

void TreeChange(int x,int y,int val) {
	int t1=top[x],t2=top[y];
	while (t1!=t2) {
		if (deep[t1]<deep[t2]) {
			swap(x,y); swap(t1,t2);
		}
		Change(dfn[t1],dfn[x],1,n,val,1);
		x=f[t1][0]; t1=top[x];
	}
	if (deep[x]<deep[y]) swap(x,y);
	Change(dfn[y],dfn[x],1,n,val,1);
}

int TreeQuery(int x,int y,int flag) {
	int t1=top[x],t2=top[y],ans=0;
	while (t1!=t2) {
		if (deep[t1]<deep[t2]) {
			swap(x,y); swap(t1,t2);
		}	
		ans+=Query(dfn[t1],dfn[x],1,n,1);
		Nxt=Pre; Pre=pre=0;
		x=f[t1][0]; t1=top[x];
	}
	if (deep[x]<deep[y]) swap(x,y);
	ans+=Query(dfn[y],dfn[x],1,n,1);
	if (!flag) Fir=Pre; else Sec=Pre;
	Nxt=Pre=pre=0;
	return ans;
}

int main() {
	n=read(); m=read();
	for (int i=1;i<=n;i++) a[i]=read();	
	for (int i=1;i<=n-1;i++) {
		int x=read(),y=read();
		Add(x,y); Add(y,x);
	} 
	Dfs1(1,1);
	Dfs2(1,1);
	Build(1,n,1);
	ST();
	for (int i=1;i<=m;i++) {
		char opt;int x,y,z;
		cin>>opt; x=read(),y=read();
		if (opt=='C') {
			z=read();
			TreeChange(x,y,z);
		}
		if (opt=='Q') {
			if (x==y) puts("1");
			else {
				if (deep[x]<deep[y]) swap(x,y);
				int t=Lca(x,y);
				int Answer=TreeQuery(xx,x,0)+TreeQuery(t,y,1);
				if (Fir==Sec) --Answer; Fir=Sec=0;
				printf("%d\n",Answer);
			}
		}
	}
}
```

---

## 作者：halfrot (赞：2)

题目中所给出对树的操作就是树上区间操作，可以使用树链剖分。线段树保存区间的不同颜色块的数量，关于合并两个区间的答案，可以使用辅助数组lc和rc来记录左端点和右端点的颜色，实现O(1)合并。

使用树链剖分，以及各种高级数据结构时，涉及端点、边界的问题需要特别注意。

前面那个神犇写的非常好，但我还是想补一个我的代码，因为有时候只有一份代码我是看不懂的。

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int MAXN=1e5+5;
int inline swp(int &a,int &b){
    a^=b^=a^=b;
}
int inline readint(){
    int Num;char ch;
    while((ch=getchar())<'0'||ch>'9');Num=ch-'0';
    while((ch=getchar())>='0'&&ch<='9') Num=Num*10+ch-'0';
    return Num;
}
void outint(int x){
    if(x>=10) outint(x/10);
    putchar(x%10+'0');
}
int n,m,data[MAXN];
int v[MAXN<<1],ne[MAXN<<1],fir[MAXN],cnt=0;
void add(int a,int b){
    v[++cnt]=b,ne[cnt]=fir[a],fir[a]=cnt;
    v[++cnt]=a,ne[cnt]=fir[b],fir[b]=cnt;
}
int siz[MAXN],fa[MAXN],dep[MAXN];
int top[MAXN],son[MAXN],pos[MAXN],fp[MAXN],pcnt=0;
void dfs1(int x){
    siz[x]=1,son[x]=0;
    for(int i=fir[x];i!=-1;i=ne[i]) if(v[i]!=fa[x]){
        fa[v[i]]=x,dep[v[i]]=dep[x]+1;dfs1(v[i]);
        siz[x]+=siz[v[i]];
        if(siz[son[x]]<siz[v[i]]) son[x]=v[i];
    }
}
void dfs2(int x){
    pos[x]=++pcnt,fp[pcnt]=x;
    if(!son[x]) return;
    top[son[x]]=top[x],dfs2(son[x]);
    for(int i=fir[x];i!=-1;i=ne[i]) if(v[i]!=fa[x]&&v[i]!=son[x]){top[v[i]]=v[i];dfs2(v[i]);}
}
#define lson l,mid,rt<<1
#define rson mid+1,r,rt<<1|1
int sum[MAXN<<2],laz[MAXN<<2],lc[MAXN<<2],rc[MAXN<<2];
void inline pushup(int &rt){
    sum[rt]=sum[rt<<1]+sum[rt<<1|1];if(rc[rt<<1]==lc[rt<<1|1]) sum[rt]--;
    lc[rt]=lc[rt<<1],rc[rt]=rc[rt<<1|1];
}
void inline pushdown(int &rt){
    if(laz[rt]){
        lc[rt<<1]=lc[rt<<1|1]=rc[rt<<1]=rc[rt<<1|1]=laz[rt<<1]=laz[rt<<1|1]=laz[rt],laz[rt]=0;
        sum[rt<<1]=sum[rt<<1|1]=1;
    }
}
void build(int l,int r,int rt){
    if(l==r){
        lc[rt]=rc[rt]=data[fp[l]],sum[rt]=1;
        return;
    }
    int mid=l+r>>1;
    build(lson);build(rson);
    pushup(rt);
}
void clr(int c,int L,int R,int l,int r,int rt){
    if(L<=l&&r<=R){
        laz[rt]=lc[rt]=rc[rt]=c,sum[rt]=1;
        return;
    }
    pushdown(rt);
    int mid=l+r>>1;
    if(L<=mid) clr(c,L,R,lson);
    if(R>mid) clr(c,L,R,rson);
    pushup(rt);
}
void Clr(int x,int y,int c){
    int tx=top[x],ty=top[y];
    while(tx!=ty){
        if(dep[tx]>dep[ty]) clr(c,pos[tx],pos[x],1,n,1),x=fa[tx],tx=top[x];
        else clr(c,pos[ty],pos[y],1,n,1),y=fa[ty],ty=top[y];
    }
    if(dep[x]<dep[y]) swp(x,y);clr(c,pos[y],pos[x],1,n,1);
}
int qryclr(int p,int l,int r,int rt){
    if(l==r) return lc[rt];
    pushdown(rt);
    int mid=l+r>>1;
    if(p<=mid) return qryclr(p,lson);
    else return qryclr(p,rson);
}
int qry(int L,int R,int l,int r,int rt){
    if(L<=l&&r<=R) return sum[rt];
    pushdown(rt);
    int mid=l+r>>1,sm=0;
    if(L<=mid) sm+=qry(L,R,lson);
    if(R>mid) sm+=qry(L,R,rson);
    if(L<=mid&&R>mid&&rc[rt<<1]==lc[rt<<1|1]) return sm-1;
    return sm;
}
void Qry(int x,int y){
    int tx=top[x],ty=top[y],ans=0;
    while(tx!=ty){
        if(dep[tx]>dep[ty]) ans+=qry(pos[tx],pos[x],1,n,1),ans-=qryclr(pos[tx],1,n,1)==qryclr(pos[fa[tx]],1,n,1),x=fa[tx],tx=top[x];
        else ans+=qry(pos[ty],pos[y],1,n,1),ans-=qryclr(pos[ty],1,n,1)==qryclr(pos[fa[ty]],1,n,1),y=fa[ty],ty=top[y];
    }
    if(dep[x]<dep[y]) swp(x,y);ans+=qry(pos[y],pos[x],1,n,1);
    outint(ans),putchar('\n');
}
int main(){
    memset(laz,0,sizeof(laz));
    memset(fir,-1,sizeof(fir));
    memset(ne,-1,sizeof(ne));
    n=readint(),m=readint();
    for(int i=1;i<=n;i++) data[i]=readint();
    for(int i=1;i<n;i++) add(readint(),readint());
    siz[0]=fa[1]=dep[1]=0;dfs1(1);
    top[1]=1;dfs2(1);
    build(1,n,1);
    for(int i=1;i<=m;i++){
        char opt[5];scanf("%s",opt);
        int a=readint(),b=readint();
        switch(opt[0]){
            case 'C':Clr(a,b,readint());break;
            case 'Q':Qry(a,b);break;
        }
    }
}
```

---

## 作者：回青绝影 (赞：1)

### 思路：看到两节点之间的路径上的操作，还是一棵树，就想到了树剖（然而我并不会LCT）……


------------

在建线段树和修改时问题不大加上合并区间（即线段树合并时，若左右子树橡胶的地方颜色相同就颜色段数减一），没什么区别。

##### ~~但是说实话，用树剖处理颜色段数，真的十分恶心~~


------------

但是我加了一个小（mei）小（yong）的优化，就是求了树的重心


------------

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=200001;
struct st{
    int l,r,num;
}t[N<<2];
int n,m,rt,k,cnt,ans,rc,lc;
int nxt[N<<1],last[N],a[N<<1];
int sz[N],fa[N],dep[N],id[N],c[N],top[N],son[N];
int color[N],lazy[N<<2];
void add(int x,int y){
    nxt[++k]=last[x];
    last[x]=k;
    a[k]=y;
}
void dfs(int x,int fa){			//求树的重心
    bool flag=0;
    sz[x]=1;
    for (int i=last[x];i;i=nxt[i]){
        int y=a[i];
        if (y==fa) continue;
        dfs(y,x);
        sz[x]+=sz[y];
        if (sz[y]>n/2) flag=1; 
    }
    if (!flag&&n-sz[x]<=n/2) rt=x;
}
void dfs1(int x,int f,int d){	//正常树剖
    dep[x]=d;
    fa[x]=f;
    sz[x]=1;
    int maxson=-1;
    for (int i=last[x];i;i=nxt[i]){
        if (a[i]==f) continue;
        dfs1(a[i],x,d+1);
        sz[x]+=sz[a[i]];
        if (sz[a[i]]>maxson) maxson=sz[a[i]],son[x]=a[i];
    }
}
void dfs2(int x,int topf){	//建线段数
    id[x]=++cnt;
    c[cnt]=color[x];
    top[x]=topf;
    if (!son[x]) return ;
    dfs2(son[x],topf);
    for (int i=last[x];i;i=nxt[i]){
        if (a[i]==fa[x]||a[i]==son[x]) continue;
        dfs2(a[i],a[i]);
    }
}
void pushdown(int rt,int l,int mid,int r){	//下放懒标记
    if (!lazy[rt]) return ;
    t[rt<<1].num=1;t[rt<<1].l=t[rt<<1].r=lazy[rt];
    t[rt<<1|1].num=1;t[rt<<1|1].l=t[rt<<1|1].r=lazy[rt];
    lazy[rt<<1]=lazy[rt<<1|1]=lazy[rt];
    lazy[rt]=0;
}
void change(int rt){						//	就是处理合并区间的情况
    t[rt].l=t[rt<<1].l;t[rt].r=t[rt<<1|1].r;
    t[rt].num=t[rt<<1].num+t[rt<<1|1].num;
    if (t[rt<<1].r==t[rt<<1|1].l) t[rt].num--;
}
void build(int rt,int l,int r){
    if (l==r){
       t[rt].l=t[rt].r=c[l];t[rt].num=1;
       return ;
    }
    int mid=(l+r)>>1;
    build(rt<<1,l,mid);build(rt<<1|1,mid+1,r);
    change(rt);
}
void update(int rt,int l,int r,int x,int y,int z){
    if (l==x&&r==y){
        t[rt].l=t[rt].r=z;
        t[rt].num=1;
        lazy[rt]=z;
        return ;
    }
    int mid=(l+r)>>1;
    pushdown(rt,l,mid,r);
    if (y<=mid) update(rt<<1,l,mid,x,y,z);
    else if (x>mid) update(rt<<1|1,mid+1,r,x,y,z);
    else update(rt<<1,l,mid,x,mid,z),update(rt<<1|1,mid+1,r,mid+1,y,z);
    change(rt);
}
int query(int rt,int l,int r,int x,int y,int L,int R){
    //千万不能把下面两句话写成 我才不会说我原来就是这么写的呢
    /*
    if (l==x&&r==y){
	    lc=t[rt].l;
	    rc=t[rt].r;
        return t[rt].num;
    }
    */
    //因为query下传标记时会使得l，r不在是原本的区间，而是会被分开，而所要求的是最大的那个区间的lc和rc；
    //然而，我认为也只有我这种蒟蒻会写错了
	if(L==l) lc=t[rt].l;
	if(R==r) rc=t[rt].r;
    if (l==x&&r==y){
        return t[rt].num;
    }
    int mid=(l+r)>>1;
    pushdown(rt,l,mid,r);
    if (y<=mid) return query(rt<<1,l,mid,x,y,L,R);
    else if (x>mid) return query(rt<<1|1,mid+1,r,x,y,L,R);
    else return query(rt<<1,l,mid,x,mid,L,R)+query(rt<<1|1,mid+1,r,mid+1,y,L,R)-(t[rt<<1].r==t[rt<<1|1].l?1:0);
}
void t_add(int x,int y,int z){
    while (top[x]!=top[y]){
        if (dep[top[x]]<dep[top[y]]) swap(x,y);
        update(1,1,n,id[top[x]],id[x],z);
        x=fa[top[x]];
    }
    if (dep[x]>dep[y]) swap(x,y);
    update(1,1,n,id[x],id[y],z);
}
int t_ask(int x,int y){//重点！！！
//在同时交换c1,c2与x,y是非常玄学的。
    ans=0;
	int c1=-1,c2=-1;
    while (top[x]!=top[y]){
        if (dep[top[x]]<dep[top[y]]) swap(x,y),swap(c1,c2);
        ans+=query(1,1,n,id[top[x]],id[x],id[top[x]],id[x])-(c1==rc?1:0);
        x=fa[top[x]];c1=lc;
    }
    if (dep[x]>dep[y]) swap(x,y),swap(c1,c2);
    ans+=query(1,1,n,id[x],id[y],id[x],id[y])-(c1==lc?1:0)-(c2==rc?1:0);
    return ans;
}
int main(){
    scanf("%d%d",&n,&m);
    for (int i=1;i<=n;i++) scanf("%d",&color[i]);
    for (int x,y,i=1;i<n;i++){
        scanf("%d%d",&x,&y);
        add(x,y);add(y,x);
    }
    dfs(1,0);
    memset(sz,0,sizeof(sz));
    dfs1(rt,0,1);
    dfs2(rt,rt);
    build(1,1,n);
    char c;
    for (int x,y,z,i=1;i<=m;i++){
        cin>>c;
        if (c=='C'){
            scanf("%d%d%d",&x,&y,&z);
            t_add(x,y,z);
        }else{
            scanf("%d%d",&x,&y);
            printf("%d\n",t_ask(x,y));
        }
    }
    return 0;
}
```

~~这道题就是树链剖分加一点小小的处理，但居然和模板一个难度等级(笑哭)~~

### **_欢迎巨佬来Di，QAQ_**

---

## 作者：斗神_君莫笑 (赞：1)

本题就是将树剖和连续区间数结合了一下  
二者都是板子，但是query的部分值得寻味  
[这里](https://www.luogu.org/blog/user48618/solution-p2486)详细的讲解了query的过程    
在此仅对query代码进行解释   
附图：  
![](http://images.cnblogs.com/cnblogs_com/tply/1142800/o_graph.png)
```cpp
#include<bits/stdc++.h>
#define lc (p<<1)
#define rc (p<<1|1)
using namespace std;
struct Edge{
	int u,v,nxt;
}e[200010];
int head[100010],cnt;
inline void add(int u,int v){
	e[++cnt].u=u;
	e[cnt].v=v;
	e[cnt].nxt=head[u];
	head[u]=cnt;
}
int a[100010],sub_a[100010];
int siz[100010],fa[100010],deep[100010];
void dfs1(int u,int father,int dis){
	fa[u]=father;
	siz[u]=1;deep[u]=dis;
	for(int i=head[u];i;i=e[i].nxt)
		if(e[i].v!=father){
			dfs1(e[i].v,u,dis+1);
			siz[u]+=siz[e[i].v];
		}
}
int sub[100010],dfn,top[100010];
void dfs2(int u,int is_heavy){
	if(!is_heavy)top[u]=u;//注意:只有重儿子才有top一说! 
	else top[u]=top[fa[u]];
	sub[u]=++dfn;
	sub_a[dfn]=a[u];
	int max_siz=0,max_son=0;
	for(int i=head[u];i;i=e[i].nxt){
		int v=e[i].v;
		if(v!=fa[u]&&siz[v]>max_siz)
			max_siz=siz[v],max_son=v;
	}
	if(max_son)dfs2(max_son,1);
	for(int i=head[u];i;i=e[i].nxt){
		int v=e[i].v;
		if(v!=fa[u]&&v!=max_son)
			dfs2(v,0);
	}
}
struct Node{
	int l,r,sum,lsum,rsum,lazy;
}T[400010];
inline void pushup(int p){
	T[p].sum=T[lc].sum+T[rc].sum-(T[lc].rsum==T[rc].lsum);
	T[p].lsum=T[lc].lsum;T[p].rsum=T[rc].rsum;
}
void build(int p,int l,int r){
	T[p].l=l;T[p].r=r;
	if(l==r){
		T[p].lsum=T[p].rsum=sub_a[l];
		T[p].sum=1;return;
	}
	int mid=(l+r)>>1;
	build(lc,l,mid);
	build(rc,mid+1,r);
	pushup(p);
	//printf("%d %d %d\n",T[p].l,T[p].r,T[p].sum);
}
void pushnow(int p,int v){
	T[p].sum=1;T[p].lsum=T[p].rsum=T[p].lazy=v;
}
void pushdown(int p){
	if(T[p].lazy){
		pushnow(lc,T[p].lazy);
		pushnow(rc,T[p].lazy);
		T[p].lazy=0;
	}
}
void update(int p,int ql,int qr,int v){
	if(ql<=T[p].l&&T[p].r<=qr){
		pushnow(p,v);return;
	}
	pushdown(p);
	int mid=(T[p].l+T[p].r)>>1;
	if(ql<=mid)update(lc,ql,qr,v);
	if(qr>mid)update(rc,ql,qr,v);
	pushup(p);
}
inline Node merge(Node l,Node r){
	Node ans;
	ans.lsum=l.lsum;ans.rsum=r.rsum;
	ans.sum=l.sum+r.sum-(l.rsum==r.lsum);
	return ans;
}
Node query(int p,int ql,int qr){
	if(ql<=T[p].l&&T[p].r<=qr)
		return T[p];
	pushdown(p);
	int mid=(T[p].l+T[p].r)>>1;
	if(ql<=mid&&mid<qr)
		return merge(query(lc,ql,qr),query(rc,ql,qr));
	if(ql<=mid)return query(lc,ql,qr);
	if(qr>mid)return query(rc,ql,qr);
}
void update1(int x,int y,int z){
	while(top[x]!=top[y]){
		if(deep[top[x]]<deep[top[y]])swap(x,y);
		update(1,sub[top[x]],sub[x],z);
		x=fa[top[x]];
	}
	if(deep[x]>deep[y])swap(x,y);
	update(1,sub[x],sub[y],z); 
}
//如果采取x,y分别根据深度写,那么不必交换ans1和ans2 
int query1(int x,int y){
	//很容易证明树剖每次上跳都是接在链的左端(sub变小)
	//所以维护上一次查询的左端点便可进行合并 
	int ans1=0,ans2=0,ans=0;//ans1,ans2分别为x,y上一次的左端点 
	while(top[x]!=top[y]){
		if(deep[top[x]]<deep[top[y]])swap(x,y),swap(ans1,ans2);
		//如果y的深度更深,那么有关这两个点的所有信息都应该交换 
		Node result=query(1,sub[top[x]],sub[x]);
		ans+=result.sum-(result.rsum==ans1);//更新区间序列数目,注意减去相等部分 
		ans1=result.lsum;x=fa[top[x]];//更新当前查询左端点，x上跳 
	}
	if(deep[x]>deep[y])swap(x,y),swap(ans1,ans2);//注意这一步也要交换ans1和ans2 
	//此时深度较高的点就是二者的lca 
	Node result=query(1,sub[x],sub[y]);
	ans+=result.sum-(result.lsum==ans1)-(result.rsum==ans2);
	//结合上文那篇题解理解
	// 4-1就是ans1所代表的区间 
	// 2-3就是ans2所代表的区间
	//而1-2就是result代表的区间 
	//所以我们应该将ans1和result左端点判重，ans2和result右端点判重 
	return ans;
}
int main(){
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;++i)	
		scanf("%d",&a[i]);
	for(int i=1;i<n;++i){
		int u,v;
		scanf("%d%d",&u,&v);
		add(u,v);add(v,u);
	}
	dfs1(1,0,1);
	dfs2(1,0);
	/*
	printf("---------------------------------------\n"); 
	for(int i=1;i<=n;++i)
		printf("%d %d %d\n",fa[i],top[i],sub[i]);
	printf("---------------------------------------\n"); 
	*/
	build(1,1,n);
	for(int i=1;i<=m;++i){
		char ch=getchar();
		while(ch!='Q'&&ch!='C')ch=getchar();
		if(ch=='Q'){
			int x,y;
			scanf("%d%d",&x,&y);
			printf("%d\n",query1(x,y));
		}
		if(ch=='C'){
			int x,y,z;
			scanf("%d%d%d",&x,&y,&z);
			update1(x,y,z);
		}
	}
	return 0;
} 
```


---

## 作者：程就未来 (赞：1)

## 本题思路 ：树链剖分　＋　线段树区间合并
### 首先把这棵树进行树链剖分（若不会树链剖分，请先做[这题](https://www.luogu.org/problemnew/show/P3384)）再建一棵线段树。
### 线段树中需要维护区间左端点的颜色、区间右端点的颜色、区间的颜色段数量。
### 线段树向上更新答案就等于左右子树答案之和。若左子树的右端点颜色与右子树左端点颜色相同，那么这段区间答案要-1。

```cpp
void pushup(int rt)
{
    cl[rt] = cl[ls(rt)]; cr[rt] = cr[rs(rt)];
    if(cr[ls(rt)] == cl[rs(rt)]) val[rt] = val[ls(rt)] + val[rs(rt)] - 1;//左子树的右端点颜色与右子树左端点颜色相同，那么这段区间答案要-1。
    else val[rt] = val[ls(rt)] + val[rs(rt)];
}

```
### 修改时需要下传一个懒标记记录这个点是否需要修改。
```
void pushdown(int rt)
{
    int l = ls(rt) , r = rs(rt);//ls(rt)表示rt这个节点的左儿子
    if(lazy[rt]){
        lazy[l] = lazy[r] = 1;
        val[l] = val[r] = 1;
        cl[l] = cr[l] = cl[r] = cr[r] =  cl[rt];
        lazy[rt] = 0;
    }
}
```
### 对于接下来２个操作：
#### 1.修改 ： 将输入的树上的两个的节点交替向上跳，沿路用线段树修改颜色。
```cpp
void update(int rt , int l , int r , int L , int R , int col)//线段树的区间修改
{
    if(l == L && r == R) {
        lazy[rt] = 1; 
        cl[rt] = cr[rt] = col;
        val[rt] = 1;
        return ;
    }
    pushdown(rt);
    int mid = (L + R) >> 1;
    if(r <= mid) update(ls(rt) , l , r , L , mid , col);
    else if(l > mid) update(rs(rt) , l , r , mid + 1 , R , col);
    else update(ls(rt),l,mid,L,mid,col) , update(rs(rt),mid+1,r,mid+1,R,col);
    pushup(rt);
}

void change(int x , int y , int c)//将节点a和节点b之间的路径染成c颜色
{
	while(top[x] != top[y]) {
		if(depth[top[x]] < depth[top[y]]) swap(x , y);
		update(1 , pos[top[x]] , pos[x] , 1 , n , c);
		x = par[top[x]];
	}
	if(pos[x] > pos[y]) swap(x , y);
	update(1 , pos[x] , pos[y] , 1 , n , c);
}
```
#### 2.查询 ： 将输入的树上的两个的节点交替向上跳，沿路用线段树区间查询。
#### 这里要注意一个细节：沿路的路径中如果两端路径之间的颜色相同，答案也要-1。
```cpp

int query(int rt , int l , int r , int L , int R )//查询区间颜色段数量
{ 
    if(l == L && r  == R) return val[rt];
    pushdown(rt);
    int mid = (L + R) >> 1;
    if(r <= mid) return query(ls(rt) , l , r , L , mid);
    else if(l > mid) return query(rs(rt) , l , r , mid + 1 , R);
    int ans = query(ls(rt) , l , mid , L , mid)  + query(rs(rt) , mid + 1 , r , mid + 1 , R);
    if(cr[ls(rt)] == cl[rs(rt)]) ans --;
    return ans;
} 

int qc(int rt , int l , int r , int L , int R )//查询单点颜色
{ 
    if(l == L && r  == R) return cl[rt];
    pushdown(rt);
    int mid = (L + R) >> 1;
    if(r <= mid) return qc(ls(rt) , l , r , L , mid);
    else if(l > mid) return qc(rs(rt) , l , r , mid + 1 , R);
} 


int qcolor(int x , int y)
{
    int sum = 0 ;
    int pre1 = -INF , pre2 = - INF , rc , lc;//因为节点会左右交替向上跳，所以要记录两段之前的右端点的颜色，交替上跳的时候swap一下就行了
    while(top[x] != top[y])
    {
        if(depth[top[x]] < depth[top[y]]) swap(x , y) , swap(pre1 , pre2);
        sum += query(1 , pos[top[x]] , pos[x] , 1 , n);
		lc = qc(1 , pos[top[x]] , pos[top[x]] , 1 , n);//查询左端点颜色
		rc = qc(1 , pos[x] , pos[x] , 1 , n);//查询右端点颜色
		if(rc == pre1) sum -- ;//颜色相同答案就-1
		pre1 = lc;
        x = par[top[x]];
    }
    if(pos[x] > pos[y]) swap(x , y) , swap(pre1 , pre2);
    sum += query(1 , pos[x] , pos[y] , 1 , n);
	lc = qc(1 , pos[x] , pos[x] , 1 , n) , rc = qc(1 , pos[y] , pos[y] , 1 , n);
	if(lc == pre1) sum -- ;
	if(rc == pre2) sum -- ; //最后在同一条链上的时候也要判断
    return sum;
}
```
### 最后附上我常数巨大的AC代码：
```
#include<bits/stdc++.h>
using namespace std;
#define ls(x) x << 1
#define rs(x) x << 1 | 1
const int N = 400009 , INF = 2147483647;
struct Edge{int to , nxt;} e[N];
int cl[N] , cr[N] , val[N] , lazy[N];
int depth[N] , par[N] , size[N] , top[N] , color[N] , pos[N];
int head[N] , tot = 0;
int n , T;

int read()//快读
{
    int s = 0 , w = 1;
    char ch = getchar();
    while(ch < '0' || ch > '9'){if(ch == '-') w = -1; ch = getchar();}
    while(ch >= '0' && ch <= '9'){s = (s << 1) + (s << 3) + (ch ^ 48);ch = getchar();}
    return s * w;
}

void addedge(int x , int y)
{
	e[++tot].to = y;
    e[tot].nxt = head[x];
    head[x] = tot;
}//邻接表存树

void dfs1(int x)
{
    size[x] = 1;
    for(int i = head[x] ; i ; i = e[i].nxt)
        if(e[i].to != par[x]) 
        {
            par[e[i].to] = x; 
			depth[e[i].to] = depth[x] + 1;
            dfs1(e[i].to); 
            size[x] += size[e[i].to];
        }
}

void dfs2(int x , int chain)
{
    int k = 0;
    pos[x] = ++tot;
    top[x] = chain;
    for(int i = head[x] ; i ; i = e[i].nxt)
        if(depth[e[i].to] > depth[x] && size[e[i].to] > size[k]) k = e[i].to;
    if(!k) return ;
    dfs2(k , chain);
    for(int i = head[x] ; i ; i = e[i].nxt)
        if(depth[e[i].to] > depth[x] && k != e[i].to) dfs2(e[i].to , e[i].to);
}

//  --------------------------------------------------------------------↓线段树
void pushup(int rt)
{
    cl[rt] = cl[ls(rt)]; cr[rt] = cr[rs(rt)];
    if(cr[ls(rt)] == cl[rs(rt)]) val[rt] = val[ls(rt)] + val[rs(rt)] - 1;
    else val[rt] = val[ls(rt)] + val[rs(rt)];
}

void pushdown(int rt)
{
    int l = ls(rt) , r = rs(rt);
    if(lazy[rt]){
        lazy[l] = lazy[r] = 1;
        val[l] = val[r] = 1;
        cl[l] = cr[l] = cl[r] = cr[r] =  cl[rt];
        lazy[rt] = 0;
    }
}

void update(int rt , int l , int r , int L , int R , int col)
{
    if(l == L && r == R) {
        lazy[rt] = 1; cl[rt] = cr[rt] = col; val[rt] = 1;
        return ;
    }
    pushdown(rt);
    int mid = (L + R) >> 1;
    if(r <= mid) update(ls(rt) , l , r , L , mid , col);
    else if(l > mid) update(rs(rt) , l , r , mid + 1 , R , col);
    else update(ls(rt),l,mid,L,mid,col) , update(rs(rt),mid+1,r,mid+1,R,col);
    pushup(rt);
}

int query(int rt , int l , int r , int L , int R )
{ 
    if(l == L && r  == R) return val[rt];
    pushdown(rt);
    int mid = (L + R) >> 1;
    if(r <= mid) return query(ls(rt) , l , r , L , mid);
    else if(l > mid) return query(rs(rt) , l , r , mid + 1 , R);
    int ans = query(ls(rt) , l , mid , L , mid)  + query(rs(rt) , mid + 1 , r , mid + 1 , R);
    if(cr[ls(rt)] == cl[rs(rt)]) ans --;
    return ans;
} 

int qc(int rt , int l , int r , int L , int R )
{ 
    if(l == L && r  == R) return cl[rt];
    pushdown(rt);
    int mid = (L + R) >> 1;
    if(r <= mid) return qc(ls(rt) , l , r , L , mid);
    else if(l > mid) return qc(rs(rt) , l , r , mid + 1 , R);
} 

//-------------------------------------------------------------------------↑线段树
void change(int x , int y , int c)
{
	while(top[x] != top[y]) {
		if(depth[top[x]] < depth[top[y]]) swap(x , y);
		update(1 , pos[top[x]] , pos[x] , 1 , n , c);
		x = par[top[x]];
	}
	if(pos[x] > pos[y]) swap(x , y);
	update(1 , pos[x] , pos[y] , 1 , n , c);
}

int qcolor(int x , int y)
{
    int sum = 0 ;
    int pre1 = -INF , pre2 = - INF , rc , lc;
    while(top[x] != top[y])
    {
        if(depth[top[x]] < depth[top[y]]) swap(x , y) , swap(pre1 , pre2);
        sum += query(1 , pos[top[x]] , pos[x] , 1 , n);
		lc = qc(1 , pos[top[x]] , pos[top[x]] , 1 , n);
		rc = qc(1 , pos[x] , pos[x] , 1 , n);
		if(rc == pre1) sum -- ;
		pre1 = lc;
        x = par[top[x]];
    }
    if(pos[x] > pos[y]) swap(x , y) , swap(pre1 , pre2);
    sum += query(1 , pos[x] , pos[y] , 1 , n);
	lc = qc(1 , pos[x] , pos[x] , 1 , n) , rc = qc(1 , pos[y] , pos[y] , 1 , n);
	if(lc == pre1) sum -- ;
	if(rc == pre2) sum -- ; 
    return sum;
}

int main()
{
    n = read(); T = read();
    for(int i = 1 ; i <= n ; i ++) color[i] = read();
    for(int i = 1 ; i < n ; i ++){
        int x = read() , y = read();
        addedge(x , y); addedge(y , x);
    }
    tot = 0; 
    dfs1(1); dfs2(1 , 1);

    for(int i = 1 ; i <= n ; i++) update(1 , pos[i] , pos[i] , 1 , n , color[i]); 
    while(T --){
        char str[10];
        scanf("%s",str);
        if(str[0] == 'C'){
            int x = read() , y = read() , c = read();
            change(x , y , c);
        } else {
            int x = read() , y = read();
            printf("%d\n",qcolor(x , y));
        }
    }
    return 0;
}
```


---

## 作者：顾z (赞：1)

# [顾](https://www.luogu.org/blog/RPdreamer/#)[z](https://www.cnblogs.com/-guz/)

~~你没有发现两个字里的blog都不一样嘛~~ qwq

很明显,这是一个树剖题.

但是维护起来会很麻烦.qwq

首先明确我们的线段树需要维护什么东西.

1. 我们需要维护颜色段的个数(题目要求啊,喂)

由于线段树是每次将区间分成一半,所以我们需要考虑拼接。

因此我们需要维护的东西还有

1. 当前节点的左子区间中的颜色段
2. 当前节点的右子区间中的颜色段.

如果当前节点的左子区间的右子颜色段与当前节点的右子区间的左子颜色段相同,我们就需要拼接.(可能会有些难理解,请细细品读)

然后难点就在于剖分成链之后,我们跳转的时候,链顶与新的一部分的拼接.

这里以链的下端为$L$,链的上端为$R$,简单解释一下.

>  其中红色部分为已知部分的链,黑色部分为当前所求.

很容易发现,如果要拼接,我们需要将黑色部分左右端点调换,直接$swap$即可.

![](https://i.loli.net/2018/10/22/5bcdac12488d5.png)

最后需要考虑的是当两端点在一条链上如何拼接,这里不再讨论,

请大家独立思考QwQ

~~本来应该一边切的,结果因为局部变量和重载出锅QAQ~~

``代码``

```c++
#include<cstdio>
#include<cstring>
#include<iostream>
#include<cctype>
#define ls o<<1
#define rs o<<1|1
#define R register
#define N 300008
using namespace std;
inline void in(int &x)
{
    int f=1;x=0;char s=getchar();
    while(!isdigit(s)){if(s=='-')f=-1;s=getchar();}
    while(isdigit(s)){x=x*10+s-'0';s=getchar();}
    x*=f;
}
struct cod{int lc,rc,sum;}tr[N<<2];
cod operator +( cod a, cod b)
{
	cod res;
	res.lc=a.lc;res.rc=b.rc;
	res.sum=a.sum+b.sum;
	if(a.rc==b.lc)res.sum--;
	return res;
}
int n,m,head[N],tot,a[N],tg[N<<2];
struct code{int u,v;}edge[N<<2];
inline void add(int x,int y)
{
    edge[++tot].u=head[x];
    edge[tot].v=y;
    head[x]=tot;
}
int size[N],son[N],f[N],depth[N];
void dfs1(int u,int fa)
{
    depth[u]=depth[fa]+1;f[u]=fa;size[u]=1;
    for(R int i=head[u];i;i=edge[i].u)
    {
        if(edge[i].v==fa)continue;
        dfs1(edge[i].v,u);
        size[u]+=size[edge[i].v];
        if(son[u]==-1 or size[son[u]]<size[edge[i].v])
            son[u]=edge[i].v;
    }
}
int dfn[N],fdfn[N],idx,top[N];
void dfs2(int u,int t)
{
    dfn[u]=++idx;fdfn[idx]=u;top[u]=t;
    if(son[u]==-1)return;
    dfs2(son[u],t);
    for(R int i=head[u];i;i=edge[i].u)
    {
        if(dfn[edge[i].v])continue;
        dfs2(edge[i].v,edge[i].v);
    }
}
void build(int o,int l,int r)
{
    if(l==r)
    {
        tr[o].lc=tr[o].rc=a[fdfn[l]];
        tr[o].sum=1;
        return;
    }
    int mid=(l+r)>>1;
    build(ls,l,mid);
    build(rs,mid+1,r);
    tr[o]=tr[ls]+tr[rs];
}
inline void down(int o,int l,int r)
{
    if(tg[o])
    {
        tg[ls]=tr[ls].lc=tr[ls].rc=tg[o];
        tg[rs]=tr[rs].lc=tr[rs].rc=tg[o];
        tr[ls].sum=tr[rs].sum=1;
        tg[o]=0;
    }
}
void change(int o,int l,int r,int x,int y,int z)
{
    if(x<=l and y>=r)
    {
        tr[o].lc=tr[o].rc=tg[o]=z;
        tr[o].sum=1;
        return;
    }
    down(o,l,r);
    int mid=(l+r)>>1;
    if(x<=mid)change(ls,l,mid,x,y,z);
    if(y>mid)change(rs,mid+1,r,x,y,z);
    tr[o]=tr[ls]+tr[rs];
}
cod query(int o,int l,int r,int x,int y)
{
    if(x<=l and y>=r)return tr[o];
    down(o,l,r);
    int mid=(l+r)>>1;
    if(y<=mid)return query(ls,l,mid,x,y);
    if(x>mid)return query(rs,mid+1,r,x,y);
    return query(ls,l,mid,x,y)+query(rs,mid+1,r,x,y);
}
inline void tchange(int x,int y,int z)
{
    int fx=top[x],fy=top[y];
    while(fx!=fy)
    {
        if(depth[fx]>=depth[fy])
        {
            change(1,1,n,dfn[fx],dfn[x],z);
            x=f[fx];
        }
        else 
        {
            change(1,1,n,dfn[fy],dfn[y],z);
            y=f[fy];
        }
        fx=top[x],fy=top[y];
    }
    if(dfn[x]>dfn[y])swap(x,y);
    change(1,1,n,dfn[x],dfn[y],z);
}
inline cod tquery(int x,int y)
{
    cod a,b,res;
    a.lc=a.rc=b.lc=b.rc=a.sum=b.sum=0;
    int fx=top[x],fy=top[y];
    while(fx!=fy)
    {
        if(depth[fx]>=depth[fy])
        {
            res=query(1,1,n,dfn[fx],dfn[x]);
            swap(res.lc,res.rc);
            a=a+res;
            x=f[fx];
        }
        else
        {
            res=query(1,1,n,dfn[fy],dfn[y]);
            swap(res.lc,res.rc);
            b=b+res;
            y=f[fy];
        }
        fx=top[x],fy=top[y];
    }
    if(dfn[x]>dfn[y])
    {
        swap(x,y);
        swap(a,b);
    }
    res=query(1,1,n,dfn[x],dfn[y]);
    a=a+res;
    swap(b.lc,b.rc);
    return a+b;
}
char s[8];
int main()
{
    in(n),in(m);memset(son,-1,sizeof son);
    for(R int i=1;i<=n;i++)in(a[i]);
    for(R int i=1,x,y;i<n;i++)
    {
        in(x),in(y);
        add(x,y),add(y,x);
    }
    dfs1(1,0);dfs2(1,1);build(1,1,n);
    for(R int a,b,c;m;m--)
    {
        scanf("%s",s+1);
        if(s[1]=='Q')
        {
            in(a),in(b);
            printf("%d\n",tquery(a,b).sum);
        }
        else
        {
            in(a),in(b),in(c);
            tchange(a,b,c);
        }
    }
}
```

---

## 作者：XG_Zepto (赞：1)

### 思路

树上路径修改，当然是选择树链剖分这种没有思维含量的暴力了啊。。。

颜色段的问题，考虑用线段树来维护。每个节点储存区间的颜色段数以及左右端点的颜色种类。当我们要把两个区间的信息合并的时候，只需要判断一下端点处颜色来决定要不要将颜色段数减一就行了。。。

我的写法的一个问题是，在路径查询的时候，因为我们得到的是一个“人”字形的路径，需要分别储存左边和右边的信息，加上最后在同一条重链上得到的区间信息，一共有三个区间需要合并。

![](https://www.xgzepto.cn/wp-content/uploads/2018/06/b%E7%B4%A0%E6%9D%90-300x263.png)

如图，询问$X$到$Y$的路径上的颜色段时，我们先分别将$X$和$Y$移动到了$A$和$B$，同时记录了$X$经过的路径上的信息$lres$，和$Y$经过的路径上的信息$rres$。最后，我们获得了位于同一条重链上的$A$，$B$之间的信息$res$。

由于树链剖分的性质，我们知道区间的左端点深度更小，所以$lres$，$rres$，$res$在上图状态下的左端点分别为$A$，$B$和$B$，所以在合并的时候，需要交换一下$rres$的左右端点信息。

推广一下个人博客[【[SDOI2011]染色】](https://www.xgzepto.cn/post/bzoj-2243)

### 代码实现

```
// Paint.cpp: 定义控制台应用程序的入口点。
//XG_Zepto, 5/15/2018. All rights reserved.

#include "stdafx.h"
#include <iostream>
#include <cstring>
#include <cstdio>
#include <algorithm>
#include <queue>
#define ls (p<<1)
#define rs (p<<1|1)
#define mid ((r+l)>>1)
#define NewN(k) Node(1,k,k) 
#define maxn 100100
using namespace std;
struct Edge{
    int to,next;
    Edge(int a=0,int b=0){
        to=a,next=b;
    }
}l[maxn*2];
struct Node{
    int num,lco,rco;
    Node(int a=0,int b=0,int c=0){
        num=a,lco=b,rco=c;
    }
}tree[maxn*4];
int head[maxn],cnt,n,m,top[maxn],fa[maxn],id[maxn],col[maxn];
int son[maxn],siz[maxn],dep[maxn],nco[maxn],nid,lazy[maxn*4];
inline void Add(int x,int y){
    l[++cnt]=Edge(y,head[x]);
    head[x]=cnt;
}
inline void Pre_Work(int u,int f){
    dep[u]=dep[f]+1;fa[u]=f;siz[u]=1;
    int maxsiz=-1;
    for (int i=head[u];i;i=l[i].next){
        int v=l[i].to;if (v==f) continue;
        Pre_Work(v,u);siz[u]+=siz[v];
        if (siz[v]>maxsiz) maxsiz=siz[v],son[u]=v;
    }
}
inline void Re_Build(int u,int topf){
    id[u]=++nid,nco[nid]=col[u],top[u]=topf;
    if (son[u]) Re_Build(son[u],topf);
    for (int i=head[u];i;i=l[i].next){
        int v=l[i].to;if (v==fa[u]||v==son[u]) continue;
        Re_Build(v,v);
    }
}
inline void Swap(Node &x){swap(x.lco,x.rco);} //说好的交换左右端点
inline void Pushup(int p){
    if (tree[ls].lco==0){
        tree[p]=tree[rs];
        return;
    }
    if (tree[rs].lco==0){
        tree[p]=tree[ls];
        return;
    }
    int sum=tree[ls].num+tree[rs].num;
    if (tree[ls].rco==tree[rs].lco) sum--;
    tree[p]=Node(sum,tree[ls].lco,tree[rs].rco);
}
inline Node Merge(Node x,Node y){
    if (x.lco==0) return y;
    if (y.lco==0) return x;
    int cut=(x.rco==y.lco);
    return Node(x.num+y.num-cut,x.lco,y.rco);
}
inline void Set_Up(int l,int r,int p){
    if (l==r){tree[p]=Node(1,nco[l],nco[r]);return;}
    Set_Up(l,mid,ls);Set_Up(mid+1,r,rs);Pushup(p);
}
inline void Pushdown(int p){
    int te=lazy[p];lazy[p]=0;
    Node tem=NewN(te);
    tree[ls]=tree[rs]=tem;
    lazy[ls]=lazy[rs]=te;
}
inline Node Query(int l,int r,int L,int R,int p){
    if (l>R||r<L) return Node(0,0,0);
    if (l>=L&&r<=R) return tree[p];
    if (lazy[p]) Pushdown(p);
    return Merge(Query(l,mid,L,R,ls),Query(mid+1,r,L,R,rs));
}
inline void Change(int l,int r,int L,int R,int k,int p){
    if (l>R||r<L) return;
    if (l>=L&&r<=R){
        tree[p]=NewN(k);
        lazy[p]=k;
        return;
    }
    if (lazy[p]) Pushdown(p);
    Change(l,mid,L,R,k,ls);
    Change(mid+1,r,L,R,k,rs);
    Pushup(p);
}
inline void Path_Query(int x,int y){
    Node lres=rres=res=Node(0,0,0);
    while(top[x]!=top[y]){
        if (dep[top[x]]>dep[top[y]]){
            lres=Merge(Query(1,n,id[top[x]],id[x],1),lres);
            x=fa[top[x]];
        }
       else{
            rres=Merge(Query(1,n,id[top[y]],id[y],1),rres);
            y=fa[top[y]];
        }
    }
    if (dep[x]<dep[y]){//需要判X和Y的深度
        res=Query(1,n,id[x],id[y],1);
        Swap(lres);
        res=Merge(lres,res);
        res=Merge(res,rres);
    }
    else{
        res=Query(1,n,id[y],id[x],1);
        Swap(rres);
        res=Merge(rres,res);
        res=Merge(res,lres);
    }
    cout<<res.num<<endl;
}
inline void Path_Change(int x,int y,int k){
    while(top[x]!=top[y]){
        if (dep[top[x]]<dep[top[y]]) swap(x,y);
        Change(1,n,id[top[x]],id[x],k,1);
        x=fa[top[x]];
    }
    if (dep[x]>dep[y]) swap(x,y);
    Change(1,n,id[x],id[y],k,1);
}
int main(){
    ios::sync_with_stdio(false);
    cin>>n>>m;
    for (int i=1;i<=n;i++) cin>>col[i];
    for (int i=1,t1,t2;i<=n-1;i++)
        cin>>t1>>t2,Add(t1,t2),Add(t2,t1);
    Pre_Work(1,0);Re_Build(1,1);Set_Up(1,n,1);char op;
    for (int i=1;i<=m;i++){
        cin>>op;
        if (op=='Q'){
            int t1,t2;cin>>t1>>t2;
            Path_Query(t1,t2);
        }
        else{
            int t1,t2,t3;cin>>t1>>t2>>t3;
            Path_Change(t1,t2,t3);
        }
    }
    return 0;
}
```
### 推广
安利一下个人博客，题解同步更新

https://www.xgzepto.cn/changecol-sdoi/

---

## 作者：teafrogsf (赞：1)

这题目我去年看的时候想用LCT，然后没写出来。 

再次看这道题怒来一发树剖。  

参考初学线段树时统计颜色的某道题，将区间左右端点颜色记录，上推时如果边界颜色相同就让个数-1。  

**注意每个地方都要下推。统计答案时注意边界颜色相同也要减1。查询跳链时注意与父亲颜色相同也要减1。**此外我的线段树貌似跟其他人的写法有些不同？  

P.S. $\rm namespace$大法非常好，调代码利器。~~就是容易让代码变长~~

```cpp
#include<bits/stdc++.h>
#define neko 200010
#define meko 200010
#define chkmin(a,b) ((a)<(b)?(a):(b))
#define f(i,a,b) for(register int i=(a);i<=(b);i=-(~(i)))
#define travel(i,u,v) for(register int i=head[u],v=e[i].v;i;i=e[i].next,v=e[i].v)
int n,m,t,Root;
typedef int arr[neko];
arr head,dep,siz,fa,son,w,ord,top,col;
int Sum[neko<<2],Led[neko<<2],Red[neko<<2],Pnt[neko<<2];
struct node
{
    int v,next;
}e[meko<<1];
void add(int x,int y)
{
    e[++t].v=y;
    e[t].next=head[x];
    head[x]=t;
}
namespace Seg_Tree
{
    #define mid ((l+r)>>1)
    #define ori tagl,tagr
    #define lson root<<1,l,mid
    #define rson root<<1|1,mid+1,r
    void pushup(int root)
    {
        Sum[root]=Sum[root<<1]+Sum[root<<1|1];
        if(Red[root<<1]==Led[root<<1|1])--Sum[root];
        Led[root]=Led[root<<1],Red[root]=Red[root<<1|1];
    }
    void pushdown(int root)
    {
        if(Pnt[root])
        {
            Sum[root<<1]=Sum[root<<1|1]=1;
            Led[root<<1]=Led[root<<1|1]=Red[root<<1]=Red[root<<1|1]=Pnt[root];
            Pnt[root<<1]=Pnt[root<<1|1]=Pnt[root];
            Pnt[root]=0;
        }
    }
    void build(int root,int l,int r)
    {
        if(l==r){Led[root]=Red[root]=col[ord[l]],Sum[root]=1;return;}
        build(lson);
        build(rson);
        pushup(root);
    }
    void update(int root,int l,int r,int tagl,int tagr,int x)
    {
        if(l>=tagl&&r<=tagr){Pnt[root]=x,Led[root]=Red[root]=x,Sum[root]=1;return;}	
        pushdown(root);
        if(tagl<=mid)update(lson,ori,x);
        if(tagr>mid)update(rson,ori,x);
        pushup(root);
    }
    int query(int root,int l,int r,int tagl,int tagr)
    {
        if(l>=tagl&&r<=tagr)return Sum[root];
        pushdown(root);
        int tmp=0;
        if(tagl<=mid)tmp+=query(lson,ori);
        if(tagr>mid)tmp+=query(rson,ori);
        if(tagl<=mid&&tagr>mid&&Red[root<<1]==Led[root<<1|1])--tmp;
        return tmp;
    }
    int confirm(int root,int l,int r,int tag)
    {
        if(l==r)return Led[root];
        pushdown(root);
        if(tag<=mid)return confirm(lson,tag);
        else return confirm(rson,tag);
    }
}
namespace Siz_Subdivision
{
    using namespace std;
    using namespace Seg_Tree;
    int cnt;
    void dfs(int u)
    {
        dep[u]=dep[fa[u]]+1;
        siz[u]=1;
        travel(i,u,v)
        {
            if(v!=fa[u])
            {
                fa[v]=u;
                dfs(v);
                siz[u]+=siz[v];
                if(!son[u]||siz[v]>siz[son[u]])son[u]=v; 
            } 
        }
    }
    void dfs2(int u)
    {
        w[u]=++cnt;
        ord[cnt]=u;
        if(son[fa[u]]==u)top[u]=top[fa[u]];
        else top[u]=u;
        if(son[u])dfs2(son[u]);
        travel(i,u,v)if(v!=fa[u]&&v!=son[u])dfs2(v);
    }
    void pathu(int l,int r,int x)
    {
        while(top[l]!=top[r])
        {
            if(dep[top[l]]<dep[top[r]])swap(l,r);
            update(1,1,n,w[top[l]],w[l],x);
            l=fa[top[l]];
        }if(dep[l]>dep[r])swap(l,r);
        update(1,1,n,w[l],w[r],x);
    }
    int pathq(int l,int r)
    {
        int sum=0,alp,bet;
        while(top[l]!=top[r])
        {
            if(dep[top[l]]<dep[top[r]])swap(l,r);
            sum+=query(1,1,n,w[top[l]],w[l]);
            alp=confirm(1,1,n,w[top[l]]),bet=confirm(1,1,n,w[fa[top[l]]]);
            if(alp==bet)--sum;
            l=fa[top[l]];
        }if(dep[l]>dep[r])swap(l,r);
        sum+=query(1,1,n,w[l],w[r]);
        return sum;
    }
}
int main()
{
    using namespace Siz_Subdivision;
    int x,y,z;char opt[30];
    scanf("%d%d",&n,&m),Root=chkmin(5,n);
    f(i,1,n)scanf("%d",&col[i]);
    f(i,1,n-1)scanf("%d%d",&x,&y),add(x,y),add(y,x);
    dfs(Root),dfs2(Root);Seg_Tree::build(1,1,n);
    f(i,1,m)
    {
        getchar();
        scanf("%s%d%d",opt,&x,&y);
        if(opt[0]=='C')scanf("%d",&z),pathu(x,y,z);
        else printf("%d\n",pathq(x,y));
    }return 0;
}
```

---

## 作者：【哏哏独乐】 (赞：1)

感觉题解全是C的，我来个pascal的题解。用树链剖分。线段树的每个区间记录下这个区间的左边的颜色，右边的颜色，这一段中有几种颜色就可以了。注意查询和合并时要注意左颜色和右颜色是不是一样，一样让答案-1。上代码



```cpp
const maxn=100000;
type etype=record
  from,too,head,next:longint;
end;
type notype=record
  size,w,fw,top,son,fa,deep,colour:longint;
end;
type ttype=record
  left,right,value,doubt,lc,rc:longint;
end;
var e:array[1..maxn shl 1] of etype;
    no:array[1..maxn] of notype;
    t:array[1..maxn shl 2] of ttype;
    num,index,p:longint;
procedure save(x,y:longint);
begin
  num:=num+1; e[num].from:=x; e[num].too:=y;
  e[num].next:=e[x].head; e[x].head:=num;
end;
procedure dfs1(k,dp:longint);
 var t:longint;
begin
  no[k].size:=1;
  no[k].deep:=dp;
  t:=e[k].head;
  while t<>0 do
   begin
     if no[e[t].too].size=0 then begin
                                  no[e[t].too].fa:=k;
                                  dfs1(e[t].too,dp+1);
                                  no[k].size:=no[k].size+no[e[t].too].size;
                                  if no[e[t].too].size>no[no[k].son].size then no[k].son:=e[t].too;
                                 end;
      t:=e[t].next;
     end;
end;
procedure dfs2(k,tp:longint);
  var t:longint;
begin
  index:=index+1;
  no[k].top:=tp;
  no[k].w:=index;
  no[index].fw:=k;
  if no[k].son<>0 then dfs2(no[k].son,tp);
  t:=e[k].head;
  while t<>0 do
   begin
     if no[e[t].too].w=0 then dfs2(e[t].too,e[t].too);
     t:=e[t].next;
   end;
end;
procedure pushup(k:longint);
 var lson:longint;
begin
  lson:=k shl 1;
  t[k].value:=t[lson].value+t[lson+1].value;
  t[k].lc:=t[lson].lc;
  t[k].rc:=t[lson+1].rc;
  if t[lson].rc=t[lson+1].lc then t[k].value:=t[k].value-1;
end;
procedure build(l,r,k:longint);
  var lson,mid:longint;
begin
  t[k].left:=l; t[k].right:=r;
  if l=r then begin
               t[k].lc:=no[no[l].fw].colour;
               t[k].rc:=no[no[l].fw].colour;
               t[k].value:=1;
              end
               else
               begin
                lson:=k shl 1;
                mid:=(l+r) shr 1;
                build(l,mid,lson);
                build(mid+1,r,lson+1);
                pushup(k);
               end;
end;
procedure pushdown(k:longint);
 var lson:longint;
begin
  if t[k].doubt<>0 then begin
                         lson:=k shl 1;
                         t[lson].doubt:=t[k].doubt;
                         t[lson+1].doubt:=t[k].doubt;
                         t[lson].value:=1;
                         t[lson+1].value:=1;
                         t[lson].lc:=t[lson].doubt;
                         t[lson].rc:=t[lson].doubt;
                         t[lson+1].lc:=t[lson+1].doubt;
                         t[lson+1].rc:=t[lson+1].doubt;
                         t[k].doubt:=0;
                        end;
end;
procedure update(l,r,c,k:longint);
  var lson,mid:longint;
begin
  if (l<=t[k].left) and (t[k].right<=r) then begin
                                               t[k].value:=1;
                                               t[k].lc:=c;
                                               t[k].rc:=c;
                                               t[k].doubt:=c;
                                             end
                                             else
                                               begin
                                                 pushdown(k);
                                                 lson:=k shl 1;
                                                 mid :=t[lson].right;
                                                 if l<=mid then update(l,r,c,lson);
                                                 if r>=mid+1 then update(l,r,c,lson+1);
                                                 pushup(k);
                                               end;
end;
function query(l,r,k:longint;var x,p:longint):longint;//查询时返回这个区间的左边颜色和右边颜色后面要用。
 var lson,mid,tt:longint;
begin
  tt:=0;
  if (l<=t[k].left) and (t[k].right<=r) then begin query:=t[k].value; if t[k].left=l then x:=t[k].lc; if t[k].right=r then  p:=t[k].rc end
                                        else begin
                                              pushdown(k);
                                              query:=0;
                                              lson:=k shl 1;
                                              mid :=t[lson].right;
                                              if l<=mid  then begin query:=query+query(l,r,lson,x,p); tt:=1;end;
                                              if r>=mid+1  then begin query:=query+query(l,r,lson+1,x,p); if (tt=1)and(t[lson].rc=t[lson+1].lc) then query:=query-1;end;
                                             end;
end;
procedure lca1(x,y,z:longint);
  var f1,f2:longint;
begin
  f1:=no[x].top; f2:=no[y].top;
  while f1<>f2 do
    if no[f1].deep>no[f2].deep then begin update(no[f1].w,no[x].w,z,1); x:=no[f1].fa; f1:=no[x].top; end
                               else  begin update(no[f2].w,no[y].w,z,1); y:=no[f2].fa; f2:=no[y].top; end;
  if no[x].deep>no[y].deep then update(no[y].w,no[x].w,z,1) else update(no[x].w,no[y].w,z,1);
end;
procedure lca2(x,y:longint);
 var f1,f2,t1,t2,s,ans,u:longint;
begin
  f1:=no[x].top; f2:=no[y].top;  ans:=0; t1:=0; t2:=0;
  while f1<>f2 do
    if no [f1].deep>no[f2].deep then begin u:=t1; ans:=ans+query(no[f1].w,no[x].w,1,t1,s); if u=s then ans:=ans-1; x:=no[f1].fa; f1:=no[x].top end
  //t1记录lca中路过的祖先的颜色，先用U存储t1，然后查询顺便修改t1并带回t1祖先的颜色s，如果t1和s一样那么[x,t1]和[t1,t1的祖先]是联通的所以总数减掉一，下面的也类似
                           else begin u:=t2; ans:=ans+query(no[f2].w,no[y].w,1,t2,s); if u=s then ans:=ans-1; y:=no[f2].fa; f2:=no[y].top end;
    if no[x].deep>no[y].deep then begin ans:=ans+query(no[y].w,no[x].w,1,u,s);if t2=u then ans:=ans-1; if t1=s then ans:=ans-1; end
                              else begin ans:=ans+query(no[x].w,no[y].w,1,u,s);if t1=u then ans:=ans-1; if t2=s then ans:=ans-1; end;
    writeln(ans);
end;
procedure work;
 var m,n,i,x,y,z,j:longint;
     w:char;
begin
  fillchar(e,sizeof(e),0);
  fillchar(no,sizeof(no),0);
  fillchar(t,sizeof(t),0);
  num:=0; index:=0;
  readln(n,m);
  for i:=1 to n do
   read(no[i].colour);
  for i:=1 to n-1 do
   begin
     readln(x,y);
     save(x,y);
     save(y,x);
   end;
  dfs1(1,1);
  dfs2(1,1);
  build(1,n,1);
  for i:=1 to m do
   begin
     read(w);
     if w='C' then begin readln(x,y,z); lca1(x,y,z);{ for j:=1 to n*4 do writeln(t[j].left,' ',t[j].right,' ',t[j].value,' ',t[j].lc, ' ',t[j].rc,' ',t[j].doubt);} end;
     if w='Q' then begin readln(x,y); lca2(x,y); end;
   end;
end;
begin
  work;
end.
```

---

## 作者：tiandong123 (赞：0)

~~第一次的树剖一$A$题，感动~~

这题的思路应该还是非常简单的，就是树剖加上线段树。线段树中多开两个变量，$lc$和$rc$维护区间的左边的颜色和右边的颜色，$w$维护$l--r$区间内的颜色段数

#### 考虑查询：
对于线段树上$dfs$序连续的查询，只要左子树的段数加上右子树的段数之后减掉多算的部分就是答案。只要左子树的区间最右边的颜色和右子树最左边的颜色相同的话，就意味着这个颜色段多算了一次。

#### 对于树上路径的查询:
因为我们的查询是两个节点$x$和$y$往树链顶端跳的过程

考虑去重

当一个点往上跳的时候，如果$father[top[n]]$的颜色和$top[n]$一样的话，这个颜色就会被重复算到

![](https://cdn.luogu.com.cn/upload/pic/41459.png)

~~原谅在下巨丑无比的图~~

树上奇怪的竖线表示他们是$1$号颜色的节点

当$x$往树链的顶端跳的时候，它查询了红色路径上的颜色段数，并跳到了绿色路径的下端，就是$father[top[x]]$。然后如果这个节点的颜色和$top[x]$一样的话，就代表这一段的颜色被多算了一次。

然后就是一段画风正常的树剖模板。

附上巨丑无比的代码，常数超大。。
```
#include<bits/stdc++.h>
using namespace std;
#define maxn 100008
#define pb push_back
int n,m;
int arr[maxn];
int size[maxn];
int son[maxn];
int f[maxn];
int depth[maxn];
int top[maxn];
int dfn[maxn];
int rank[maxn];
int tot=0;
vector<int> v1[maxn];

struct node{
	int l,r,w,lc,rc,lazy;
}tree[maxn*4];
void up(int k){
	tree[k].lc=tree[k*2].lc;
	tree[k].rc=tree[k*2+1].rc;
	tree[k].w=tree[k*2].w+tree[k*2+1].w-(tree[k*2].rc==tree[k*2+1].lc);
}
void ch(int k,int col){
	tree[k].lazy=col;
	tree[k].lc=col;
	tree[k].rc=col;
	tree[k].w=1;
}
void down(int k){
	ch(k*2,tree[k].lazy);
	ch(k*2+1,tree[k].lazy);
	tree[k].lazy=0;
}
void build(int k,int ll,int rr){
	tree[k].l=ll;
	tree[k].r=rr;
	tree[k].lazy=0;
	if(ll==rr){
		tree[k].w=1;
		tree[k].lc=tree[k].rc=arr[rank[ll]];
		return ;
	}
	int mid=(ll+rr)>>1;
	build(k*2,ll,mid);
	build(k*2+1,mid+1,rr);
	up(k);
}
int query(int k,int ll,int rr){
	if(tree[k].l>=ll&&tree[k].r<=rr){
	//	cout<<tree[k].l<<' '<<tree[k].r<<' '<<tree[k].w<<' '<<tree[k].lc<<' '<<tree[k].rc<<endl;
		return tree[k].w;
	}
	if(tree[k].lazy)down(k);
	int mid=(tree[k].l+tree[k].r)>>1,ans=0,ttt=0;
	if(ll<=mid){
		ttt++;
		ans+=query(k*2,ll,rr);
	}
	if(rr>mid){
		ans+=query(k*2+1,ll,rr);
		ttt++;
	}
	if(ttt==2)ans-=(tree[k*2].rc==tree[k*2+1].lc);
	return ans;
}
void change(int k,int ll,int rr,int col){
	if(tree[k].l>=ll&&tree[k].r<=rr){
		ch(k,col);
	//	cout<<tree[k].l<<' '<<tree[k].r<<' '<<col<<endl;
		return ;
	}
	if(tree[k].lazy)down(k);
	int mid=(tree[k].l+tree[k].r)>>1;
	if(ll<=mid)change(k*2,ll,rr,col);
	if(rr>mid)change(k*2+1,ll,rr,col);
	up(k);
}
void dfs_deep(int u,int fa,int deep){
	depth[u]=deep;
	f[u]=fa;
	size[u]=1;
	int len1=v1[u].size();
	for(int i=0;i<len1;i++){
		int v=v1[u][i];
		if(v!=fa){
			dfs_deep(v,u,deep+1);
			size[u]+=size[v];
			if(son[u]==-1||size[son[u]]<size[v]){
				son[u]=v;
			}
		}
	}
}
void dfs_top(int u,int t){
	top[u]=t;
	dfn[u]=++tot;
	rank[tot]=u;
	if(son[u]==-1)return ;
	dfs_top(son[u],t);
	int len1=v1[u].size();
	for(int i=0;i<len1;i++){
		int v=v1[u][i];
		if(v!=f[u]&&v!=son[u]){
			dfs_top(v,v);
		}
	}
}
int query_col(int k,int pos){
	if(tree[k].l==tree[k].r)return tree[k].lc;
	if(tree[k].lazy)down(k);
	int mid=(tree[k].l+tree[k].r)>>1;
	if(pos<=mid)return query_col(k*2,pos);
	else return query_col(k*2+1,pos);
}
int query_tree(int x,int y){
	int fx=top[x],fy=top[y],ans=0,ans1=0,last1=-1,last2=-1;
	while(fx!=fy){
		if(depth[fx]>depth[fy]){
			if(query_col(1,dfn[x])==last1)ans1++;
			last1=query_col(1,dfn[fx]);
			ans+=query(1,dfn[fx],dfn[x]);
			x=f[fx];
		}else{
			if(query_col(1,dfn[y])==last2)ans1++;
			last2=query_col(1,dfn[fy]);
			ans+=query(1,dfn[fy],dfn[y]);
			y=f[fy];
		}
		fx=top[x],fy=top[y];
	}
	if(query_col(1,dfn[x])==last1)ans1++;
	if(query_col(1,dfn[y])==last2)ans1++;
	ans+=query(1,min(dfn[x],dfn[y]),max(dfn[x],dfn[y]));
	return ans-ans1;
}
void change_tree(int x,int y,int val){
	int fx=top[x],fy=top[y];
	while(fx!=fy){
		if(depth[fx]>depth[fy]){
			change(1,dfn[fx],dfn[x],val);
			x=f[fx];
		}else{
			change(1,dfn[fy],dfn[y],val);
			y=f[fy];
		}
		fx=top[x],fy=top[y];
	}
	change(1,min(dfn[x],dfn[y]),max(dfn[x],dfn[y]),val);
	return ;
}
int main(){
	memset(son,-1,sizeof(son));
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
		scanf("%d",&arr[i]);
	for(int i=1;i<n;i++){
		int a,b;
		scanf("%d%d",&a,&b);
		v1[a].pb(b);
		v1[b].pb(a);
	}
	dfs_deep(1,0,1);
	dfs_top(1,1);
	build(1,1,n);
	for(int i=1;i<=m;i++){
		string s1;
		cin>>s1;
		int a,b,c;
		if(s1=="Q"){
			scanf("%d%d",&a,&b);
			printf("%d\n",query_tree(a,b));
		}else{
			scanf("%d%d%d",&a,&b,&c);
			change_tree(a,b,c);
		}
	}
	return 0;
}
```


---

## 作者：CreeperLordVader (赞：0)

### 为什么很多人都用数组版线段树？

#### 虽然我经常写数组版线段树，但这题很明显用结构体更好写

树链剖分的更新过程不加叙述，大家可以去看看其他DALAO的题解

## 这里主要讲线段树的更新，以及查询的过程,比其他DALAO更详细

更新时使用如下代码

```cpp
seg update(seg a,seg b)
{
	seg p;
	p.lc=p.rc=p.sum=0;
	p.lc=a.lc;
	p.rc=b.rc;
	p.sum=a.sum+b.sum;
	if(a.rc==b.lc)p.sum--;
	return p;
}
```

这样写有一个好处，update就相当于一种运算，对于所有的seg类型我都可以用这个函数来方便地合并两个seg

### 很显然，这个udpate是不满足交换律的

### 因此树链剖分查询的过程就不能像模板题那样用一个ans直接更新

#### 以下是分析的过程

设$ x $,$ y $为要查询的两个点

则我们可以把一条链从$ x $,$ y $,$ lca(x,y) $分为两段

对$ x $到$ lca(x,y) $,维护ansl

对$y$维护ansr

查询时,在向上跳的过程中,id是逐渐减小的

因此,新一次查询所得的结果应该放在左边更新(因为新一段的id更小)

### 当两点汇合时,ansl,ansr的lc都是朝着lca方向

这样就无法合并ansl,ansr

因为ansl的rc是对不上ansr的lc的

所以要交换ansl的lc,rc

code

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=100005;
struct seg
{
	int lc,rc,sum,setc;
	seg(){lc=rc=sum=setc=0;}
}tr[MAXN<<2];
int n,m,cnt;
int d[MAXN],top[MAXN],fa[MAXN];
int val[MAXN],son[MAXN];
int id[MAXN],sz[MAXN];
vector<int>v[MAXN];
void read(int& x)
{
	char c=getchar();
	x=0;
	while(c<'0'||c>'9')c=getchar();
	while(c>='0'&&c<='9')
	{
		x=x*10+c-'0';
		c=getchar();
	}
}
seg update(seg a,seg b)
{
	seg p;
	p.lc=p.rc=p.sum=0;
	p.lc=a.lc;
	p.rc=b.rc;
	p.sum=a.sum+b.sum;
	if(a.rc==b.lc)p.sum--;
	return p;
}
void pushdown(int o)
{
	if(tr[o].setc)
	{
		tr[o<<1].setc=tr[o<<1|1].setc=tr[o].setc;
		tr[o<<1].sum=tr[o<<1|1].sum=1;
		tr[o<<1].lc=tr[o<<1].rc=tr[o].setc;
		tr[o<<1|1].lc=tr[o<<1|1].rc=tr[o].setc;
		tr[o].setc=0;
	}
}
void change(int o,int l,int r,int ql,int qr,int k)
{
	if(ql<=l&&qr>=r)
	{
		tr[o].lc=tr[o].rc=k;
		tr[o].sum=1;
		tr[o].setc=k;
		return ;
	}
	int mid=(l+r)>>1;
	pushdown(o);
	if(ql<=mid)change(o<<1,l,mid,ql,qr,k);
	if(qr>mid)change(o<<1|1,mid+1,r,ql,qr,k);
	tr[o]=update(tr[o<<1],tr[o<<1|1]);
}
seg query(int o,int l,int r,int ql,int qr)
{
	if(ql<=l&&qr>=r)
	{
		return tr[o];
	}
	seg ans,ansl,ansr;
	bool okl=0,okr=0;
	int mid=(l+r)>>1;
	pushdown(o);
	if(ql<=mid)
	{
		ansl=query(o<<1,l,mid,ql,qr);
		okl=1;
	}
	if(qr>mid)
	{
		ansr=query(o<<1|1,mid+1,r,ql,qr);
		okr=1;
	}
	if(okl&&okr)ans=update(ansl,ansr);
	else if(okl)ans=ansl;
	else if(okr)ans=ansr;
	return ans;
}
void dfs(int x,int dep)
{
	d[x]=dep;
	sz[x]=1;
	for(int i=0;i<v[x].size();i++)
	{
		int y=v[x][i];
		if(!d[y])
		{
			fa[y]=x;
			dfs(y,dep+1);
			if(!son[x]||sz[son[x]]<sz[y])son[x]=y;
			sz[x]+=sz[y];
		}
	}
}
void dfs2(int x,int t)
{
	id[x]=++cnt;
	top[x]=t;
	if(son[x])dfs2(son[x],t);
	for(int i=0;i<v[x].size();i++)
	{
		int y=v[x][i];
		if(!id[y])dfs2(y,y);
	}
}
void modify(int x,int y,int k)
{
	if(d[x]<d[y])swap(x,y);
	while(top[x]!=top[y])
	{
		if(d[top[x]]<d[top[y]])swap(x,y);
		change(1,1,n,id[top[x]],id[x],k);
		x=fa[top[x]];
	}
	if(d[x]<d[y])swap(x,y);
	change(1,1,n,id[y],id[x],k);
}
seg ask(int x,int y)
{
	seg ansl,ansr;
	ansl.sum=1;
	ansl.lc=ansl.rc=query(1,1,n,id[x],id[x]).lc;
	ansr.sum=1;
	ansr.lc=ansr.rc=query(1,1,n,id[y],id[y]).rc;
	while(top[x]!=top[y])
	{
		if(d[top[x]]>d[top[y]])
		{
			ansl=update(query(1,1,n,id[top[x]],id[x]),ansl);
			x=fa[top[x]];
		}
		else
		{
			ansr=update(query(1,1,n,id[top[y]],id[y]),ansr);
			y=fa[top[y]];
		}
	}
	if(d[x]>d[y])ansl=update(query(1,1,n,id[y],id[x]),ansl);
	else ansr=update(query(1,1,n,id[x],id[y]),ansr);
	swap(ansl.lc,ansl.rc);
	return update(ansl,ansr);
}
int main()
{
	read(n);
	read(m);
	for(int i=1;i<=n;i++)
	{
		read(val[i]);
	}
	for(int i=1;i<n;i++)
	{
		int x,y;
		read(x);
		read(y);
		v[x].push_back(y);
		v[y].push_back(x);
	}
	dfs(1,1);
	dfs2(1,1);
	for(int i=1;i<=n;i++)
	{
		change(1,1,n,id[i],id[i],val[i]);
	}
	for(int i=1;i<=m;i++)
	{
		char op[2];
		scanf("%s",op);
		if(op[0]=='Q')
		{
			int x,y;
			read(x);
			read(y);
			printf("%d\n",ask(x,y).sum);
		}
		else
		{
			int x,y,k;
			read(x);
			read(y);
			read(k);
			modify(x,y,k);
		}
	}
}
```


---


# [SCOI2011] 飞镖

## 题目描述

飞镖是在欧洲颇为流行的一项运动。它的镖盘上分为20个扇形区域，分别标有1到20的分值，每个区域中有单倍、双倍和三倍的区域，打中对应的区域会得到分值乘以倍数所对应的分数。

例如打中18分里面的三倍区域，就会得到54分。

另外，在镖盘的中央，还有”小红心“和”大红心“，分别是25分和50分。

通常的飞镖规则还有一条，那就是在最后一镖的时候，必须以双倍结束战斗，才算获胜。也就是说，当还剩12分的时候，必须打中双倍的6才算赢，而打中单倍的12或者三倍的4则不算。

特别的，”大红心“也算双倍(双倍的25)。在这样的规则下，3镖能解决的最多分数是170分(两个三倍的20，最后用大红心结束)。

现在，lxhgww把原来的1到20分的分值变为了1到K分，同时把小红心的分数变为了M分(大红心是其双倍)，现在lxhgww想知道能否在3镖内（可以不一定用满3镖）解决X分。同样的，最后一镖必须是双倍（包括大红心）。


## 说明/提示

对于30%的数据，保证$1\le T\le 20$,$20\le K1,M1,X1,D1,D2,D3\le 1000$

对于100%的数据，保证$1\le T\le 10^6$,$20\le K1,M1,X1,D1,D2,D3\le 10^9$

对于所有的数据，保证$0\le A1,B1,A2,B2,C2,A3,B3,C3 \le 10^9$


## 样例 #1

### 输入

```
5
1 2 2 10 20
1 3 2 15 25
2 2 5 200 170```

### 输出

```
4```

# 题解

## 作者：Walrus (赞：3)

## Tips（写在前面）
由于此题为分类讨论题，故此文章与写代码同步进行并同步更新。

为了方便描述，下称：
	
  - $1$ 倍镖为 $1$ 镖（其余同理）。
 
引入个重要结论（不打红心）：
>任意在 $5\sim 5\times k_i$ 之间的数均可被两次数字镖（一次 $2$ 镖一次 $3$ 镖）打出来，特别的，$5\times k_i-1$ 不行，且 $5\times k + 1\sim 6\times k$ 中的 $3$ 的倍数可以被打出来（理论上 $2\sim 4 $ 也可以被打出来，但便于表述准确不将二者混为一谈）。

故无解的情况就比较简单了。

简单证明：

- 方法一：豆豆大法，即根据同余拼出需要的余数 $x\equiv p\pmod 5$。其中 $x$ 为需要拼的数。

- 方法二：分类讨论 $5$ 种模数的情况，均可表示为 $2\times x+3\times y$ 的形式，且 $x,y$ 满足 $x,y\leq k$。这里自行证明或参考其他题解。

只提一下为什么 $5\times k-1$ 不行（较为重要）。

同上，$5\times k - 1=2\times(k+1)+3\times(k-1)$，当 $k$ 取最大时，$k+1$ 越界了，取不到，可以证明不能表示为其他方案使得该数可以被表示出来。




## All cases

不一定是对的，根据个人理解，或许与其他题解有出入。

但要注意很重要的一点：**不一定要用满 $3$ 镖，只要最后一镖是 $2$ 镖即可**。所以对于每种情况可能都要多考虑。

由于第三镖较特殊，故将前两镖与第三镖分开讨论。

首先判断情况总数。第三镖显然只有大红心（小红心两倍）或者 $2$ 镖。

而前两镖要讨论红心的个数，位置无所谓。这里假定有红心就先打（即若红心只有一个则打到第一镖）。

故讨论红心个数 $0\sim2$ 个的情况数量。

- $0$ 个，则前两镖都有 $3$ 种倍数可以选择。
- $1$ 个，则第二镖有 $3$ 种倍数可以选择。
- $2$ 个，没得选。

考虑两两组合进行讨论，于是共有 $2\times 3=6$ 种情况。

这里假定前两镖红心个数为 $x$，第三镖是否为红心，用 $x/(0/1)$ 的形式呈现所有情况。

- $0/0$。即全数字，套用上述结论，由于最后一镖必须是 $2$ 镖，所以考虑“融合”两镖配合另一镖打出两镖的效果。所以又有了两种情况。
	
    - 在 $1\sim 5\times k$ 之间，融合前两镖随便打出 $3$ 镖再配合第三镖当做结论中的 $2$ 镖即可。
    - 反之，要取前两镖中的其中一个 $3$ 镖与第三镖融合，在配合前两镖中的另一镖用结论。

```cpp
int lt = x - 5 * k;//一次结论后还需要打的，也即 x - 融合镖打的
//case 1
if(2 <= x && lt + 2 <= 2 * k) res = 1;
if(2 <= x && lt + 2 <= 3 * k) res = 1;
//case 2
if(lt % 2 == 0 && (2 <= lt && lt <= 2 * k)) res = 1;
if(lt % 3 == 0 && (0 <= lt && lt <= 3 * k)) res = 1;
```

- $0/1$。比较简单，直接总数减第三镖打的再用结论。
```cpp
x -= 2 * m[i];
if(2 <= x && x <= 5 * k && x != 5 * k - 1) res = 1;
if(0 <= x && x <= 6 * k && x % 3 == 0) res = 1;
```
- $1/0$。因为红心的存在打不到 $6\times k$，只能单独打掉红心，其余同上（Case 2）套结论（这里请注意结论的描述，Case 2 与 Case 3 不能混为一谈）。
```cpp
x -= 2 * m[i];
if(2 <= x && x <= 5 * k && x != 5 * k - 1) res = 1;
```

- $1/1$。这种情况也比较简单，直接拼两次红心的倍数，然后判断剩下的数是否可以一镖解决。注意上文提示，**此种情况较特殊**。
```cpp
int f0 = x - 2 * m[i],
	f1 = x - 3 * m[i],
	f2 = x - 4 * m[i];//f0 即为特殊处理（只打两镖）
if(f0 >= 0 && ((f0 % 1 == 0 && f0 <= k * 1) || (f0 % 2 == 0 && f0 <= k * 2) || (f0 % 3 == 0 && f0 <= k * 3))) res = 1;
if(f1 >= 0 && ((f1 % 1 == 0 && f1 <= k * 1) || (f1 % 2 == 0 && f1 <= k * 2) || (f1 % 3 == 0 && f1 <= k * 3))) res = 1;
if(f2 >= 0 && ((f2 % 1 == 0 && f2 <= k * 1) || (f2 % 2 == 0 && f2 <= k * 2) || (f2 % 3 == 0 && f2 <= k * 3))) res = 1;
```

- $2/0$。这种情况同样简单，也是拼两次红心的倍数，判断剩下的数是否可以被最后一镖 $2$ 镖解决。注意上文提示，**此种情况较特殊**。
```cpp
int f[5];
rep(j, 0, 4) f[j] = x - j * m[i];
rep(j, 0, 4) {
	if(f[j] % 2 == 0 && (1 <= f[j] / 2 && f[j] / 2 <= k)) {
		res = 1;
		break;
	}
}
```

- $2/1$。最简单的一集。直接拼三次红心。注意上文提示，**此种情况较特殊**。
```cpp
int F[7];
rep(j, 2, 6) F[j] = x - j * m[i];
rep(j, 2, 6) {
	if(F[j] == 0) {
		res = 1;
		break;
	}
}
```

### Code
```cpp
#include <bits/stdc++.h>
#define rep(i, j, k) for(int i = j; i <= k; ++i)
#define pre(i, j, k) for(int i = j; i >= k; --i)
#define int long long
#define pb push_back
using namespace std;

const int N = 1e6 + 5;

int n, k[N], m[N], x[N];
int a, b, c, d, ans;

void init() {
	cin >> a >> b >> c >> d >> k[1];
	rep(i, 2, n) k[i] = (a * k[i - 1] % d * k[i - 1] % d + b * k[i - 1] % d + c) % d + 20;
	cin >> a >> b >> c >> d >> m[1];
	rep(i, 2, n) m[i] = (a * m[i - 1] % d * m[i - 1] % d + b * m[i - 1] % d + c) % d + 20;
	cin >> a >> b >> c >> d >> x[1];
	rep(i, 2, n) x[i] = (a * x[i - 1] % d * x[i - 1] % d + b * x[i - 1] % d + c) % d + 20;
}

bool check(int i, int x, string id) {
	int res = 0;
	if(id == "00") {
		int lt = x - 5 * k[i];//一次结论后还需要打的，也即 x - 融合镖打的
		//case 1
		if(2 <= x && lt + 2 <= 2 * k[i]) res = 1;
		if(2 <= x && lt + 2 <= 3 * k[i]) res = 1;
		//case 2
		if(lt % 2 == 0 && (2 <= lt && lt <= 2 * k[i])) res = 1;
		if(lt % 3 == 0 && (0 <= lt && lt <= 3 * k[i])) res = 1;
	}
	if(id == "01") {
		x -= 2 * m[i];
		if(0 <= x && x <= 5 * k[i] && x != 5 * k[i] - 1) res = 1;
		if(0 <= x && x <= 6 * k[i] && x % 3 == 0) res = 1;
	}
	if(id == "10") {
		int f1 = x - 0 * m[i],
		    f2 = x - 1 * m[i],
		    f3 = x - 2 * m[i];
		if(2 <= f1 && f1 <= 5 * k[i] && f1 != 5 * k[i] - 1) res = 1;
		if(2 <= f2 && f2 <= 5 * k[i] && f2 != 5 * k[i] - 1) res = 1;
		if(2 <= f3 && f3 <= 5 * k[i] && f3 != 5 * k[i] - 1) res = 1;
	}
	if(id == "11") {
		int f0 = x - 2 * m[i],
		    f1 = x - 3 * m[i],
		    f2 = x - 4 * m[i];//f0 即为特殊处理（只打两镖）
		if(f0 >= 0 && ((f0 % 1 == 0 && f0 <= k[i] * 1) || (f0 % 2 == 0 && f0 <= k[i] * 2) || (f0 % 3 == 0 && f0 <= k[i] * 3))) res = 1;
		if(f1 >= 0 && ((f1 % 1 == 0 && f1 <= k[i] * 1) || (f1 % 2 == 0 && f1 <= k[i] * 2) || (f1 % 3 == 0 && f1 <= k[i] * 3))) res = 1;
		if(f2 >= 0 && ((f2 % 1 == 0 && f2 <= k[i] * 1) || (f2 % 2 == 0 && f2 <= k[i] * 2) || (f2 % 3 == 0 && f2 <= k[i] * 3))) res = 1;
	}
	if(id == "20") {
		int f[5];
		rep(j, 0, 4) f[j] = x - j * m[i];
		rep(j, 0, 4) {
			if(f[j] % 2 == 0 && (1 <= f[j] / 2 && f[j] / 2 <= k[i])) {
				res = 1;
				break;
			}
		}
	}
	if(id == "21") {
		int F[7];
		rep(j, 2, 6) F[j] = x - j * m[i];
		rep(j, 2, 6) {
			if(F[j] == 0) {
				res = 1;
				break;
			}
		}
	}
	return res;
}

signed main () {
	ios::sync_with_stdio(0);
	cin.tie(nullptr), cout.tie(nullptr);


	cin >> n;
	init();
	rep(i, 1, n) {
		bool f = 0;
		if(check(i, x[i], "00")) f = 1;
		if(check(i, x[i], "01")) f = 1;
		if(check(i, x[i], "10")) f = 1;
		if(check(i, x[i], "11")) f = 1;
		if(check(i, x[i], "20")) f = 1;
		if(check(i, x[i], "21")) f = 1;
		ans += f;
	}

	cout << ans;
	return 0;
}
```

---

## 作者：yanghanyv (赞：1)

**此题是极其恶心的大分类讨论。**

## 结论

首先我们可以发现一个重要的结论，**在用两镖只打数字的情况下，可以拼出 $0$ 到 $5k$ 中除了 $5k-1$ 的所有值，以及 $0$ 到 $6k$ 中一些不连续的 $3$ 的倍数**。  
证明：  
$0$ 到 $5k$ 中 $5k-1=2(k+1)+3(k-1)$，由于其中有 $k+1$ 所以是无法拼出的，其他值可以写成类似形式，所以可以拼出。  
对于分值 $5k<s\leq 6k$ ，只要满足 $s$ 是 $3$ 的倍数就可以拼出。

## 分类标准

可以发现关于红心的条件显得很突兀，所以对红心的个数和位置进行分类。
为了描述方便，我们用 $x/y+z/w(x+y=2,z+w=1)$ 来表示前两镖有 $x$ 次数字，$y$ 次红心，最后一镖有 $z$ 次数字，$w$ 次红心。  
1. $2/0+1/0$  
这是最复杂的情况，考虑再分为两类：
	- 小于两次三倍区：将前两镖结合，套用结论。
	- 两次三倍区：将前两镖中的一次三倍与最后一镖的两倍结合，套用结论。
2. $1/1+1/0$  
只需检查 $x-2m$ 是否为 $2$ 到 $5k$ 中除了 $5k-1$ 的所有值。
3. $0/2+1/0$  
只需检查 $x-0/m/2m/3m/4m$ 是否为 $2t(1\leq t\leq k,t\in \mathbb{Z})$。
4. $2/0+0/1$  
只需检查 $x-2m$ 是否为 $0$ 到 $5k$ 中除了 $5k-1$ 的所有值或  $0$ 到 $6k$ 中 $3$ 的倍数。
5. $1/1+0/1$  
只需检查 $x-2m/3m/4m$ 是否为 $t/2t/3t(0\leq t\leq k,t\in \mathbb{Z})$。
6. $0/2+0/1$  
只需检查 $x-2m/3m/4m/5m/6m$ 是否等于 $0$。

至此，分类讨论就结束了。如果觉得很复杂可以看代码。

## 代码

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
int t,ans;
ll a1,b1,c1,d1,k,a2,b2,c2,d2,m,a3,b3,c3,d3,x;
bool flag;
bool check1(ll v){//2/0+1/0
	bool res=0;
	res=res||((v-5*k)%2==0&&v-5*k>=2&&v-5*k<=2*k)||(v-5*k+2<=2*k&&v>=2);//2+?+3
	res=res||((v-5*k)%3==0&&v-5*k>=0&&v-5*k<=3*k)||(v-5*k+2<=3*k&&v-2>=0);//2+3+3
	return res;
}
bool check2(ll v){//1/1+1/0
	return v>=2&&v<=5*k&&v!=5*k-1;
}
bool check3(ll v){//0/2+1/0
	return v>=2&&v%2==0&&v<=2*k;
}
bool check4(ll v){//2/0+0/1
	return v>=0&&((v<=5*k&&v!=5*k-1)||(v%3==0&&v<=6*k));
}
bool check5(ll v){//1/1+0/1
	return v>=0&&(v<=k||(v%2==0&&v<=2*k)||(v%3==0&&v<=3*k));
}
bool check6(ll v){//0/2+0/1
	return !v;
}
int main(){
	scanf("%d",&t);
	scanf("%lld%lld%lld%lld%lld",&a1,&b1,&c1,&d1,&k);
	scanf("%lld%lld%lld%lld%lld",&a2,&b2,&c2,&d2,&m);
	scanf("%lld%lld%lld%lld%lld",&a3,&b3,&c3,&d3,&x);
	while(t--){
		flag=0;
		flag=flag||check1(x);
		flag=flag||check2(x)||check2(x-m)||check2(x-2*m);
		flag=flag||check3(x)||check3(x-m)||check3(x-2*m)||check3(x-3*m)||check3(x-4*m);
		flag=flag||check4(x-2*m);
		flag=flag||check5(x-2*m)||check5(x-3*m)||check5(x-4*m);
		flag=flag||check6(x-2*m)||check6(x-3*m)||check6(x-4*m)||check6(x-5*m)||check6(x-6*m);
		ans+=flag;
		k=(a1*k%d1*k%d1+b1*k%d1+c1)%d1+20;
		m=(a2*m%d2*m%d2+b2*m%d2+c2)%d2+20;
		x=(a3*x%d3*x%d3+b3*x%d3+c3)%d3+20;
	}
	printf("%d",ans);
	return 0;
}
```


---

## 作者：4Beh1ndEr (赞：1)

### 一、前言

[和谐美好]选择结构题

### 二、题解

一眼做法，枚举系数，然后解线性方程。

然后就贼[和谐美好]难打。

---
---

先考虑三个飞镖都扔完 

第一个 $\{ \}$ 里的东西是系数序列，第二个 $\{ \}$ 里的东西是自变量上确界序列（下确界都是 $1$）

---

**case 1:** 只有一种系数，且一定有一个 $2m$。

$\{ 2m,  i, i \}$ $\{ 1, k, k \}$

---

**case 2:** 只有两种系数，且一定有一个 $2m$

$\{ 2m,  i, j \}$ $\{ 1, k, k \}$

---

**case 3:** 只有两种系数，且一定没有 $2m$

$ \{ i, 2, 2 \} \ \{ k, k, k \} \ \{ i, i, 2 \} \ \{ k, k, k \}$

---

**case 4:**  有三种系数

$\{ 1, 2, 3 \}$ $\{ k, k, k \}$

---

**case 5:** 一种系数都没有

$\{ m, m, m \}$ $\{ 2,2,2 \}$ （第一个变量的系数强制为 $2$）

$\{ m, m, m \}$ $\{ 0,0,0 \}$

---

对于 **Case 1—3**，我们相当于解一个类似于如下的线性方程。 $$ax + by = c$$

我们可以写出它的通解

$$\begin{cases} x = x_0 + \frac{b}{\gcd (a, b)}k \\ y = y_0 - \frac{a}{\gcd (a, b)}k \end{cases}$$

ps: $x_0,y_0$ 表示一组满足要求的特殊解。

这时我们相当于要找一组解，满足 $x \in [l_1, r_1], y \in [l_2, r_2]$。

由于只是判断存在性，我们只需要枚举 $x$ 满足要求的最大和最小值，算出对应的 $y$ 的值，判断是否在区间内，然后交换 $x,y$ 和定义域区间，再判断一下，只要有一个满足就说明有解。

对于 **Case 4** 我们只需要满足 $x \in [2, 6k]$ 即可。

对于 **Case 5** 我们直接特判

---
---

为了代码简洁，投掷次数不足三次的就多传了一个参（标记是否允许等于零），如果能理清枚举思路的话还好，如果没有理清那么我的代码可能就失去了可读性……

# 三、参考代码

```cpp
#include <cmath> 
#include <cstdio>
#include <iostream>
#include <algorithm>
using namespace std;
#define LL long long
#define rep(i,j,k) for (int i = (j); i <= (k); i++)
#define per(i,j,k) for (int i = (j); i >= (k); i--)

template <typename T>
void read (T &x) {
	x = 0;
    T f = 1; char ch = getchar ();
    while (ch < '0' || ch > '9') {
        if (ch == '-') f = -1;
        ch = getchar ();
    }
    while (ch >= '0' && ch <= '9') {
        x = (x << 3) + (x << 1) + ch - '0';
        ch = getchar ();
    }
    x *= f;
}
template <typename T, typename... Args>
void read (T &x, Args&... args) {
    read (x); read (args...);
}
template <typename T> T Max (T x, T y) { return x > y ? x : y; }
template <typename T> T Min (T x, T y) { return x < y ? x : y; }
template <typename T> T Abs (T x) { return (x > 0 ? x : -x); }

LL exgcd (LL a, LL b, LL &x, LL &y) {
    if (b == 0) {
        x = 1, y = 0;
        return a;
    }
    LL res = exgcd (b, a % b, y, x);
    y -= (a / b) * x;
    return res;
}

const int Maxn = 3;
const int Maxm = 5;

int t;
LL a[Maxn + 5][Maxm + 5];

LL x[Maxm + 5][Maxm + 5], y[Maxm + 5][Maxm + 5], _gcd[Maxm + 5][Maxm + 5];

bool check (LL Limit, LL k1, LL x1, LL X, bool zero1) {
	if (X % k1) return 0;
    X /= k1;
    LL l, r;
    if (zero1) l = 0;
    else l = x1;
    r = x1 * Limit;
    if (l <= X && X <= r) return 1;
    else return 0;
}
bool judge (LL X, LL Y, LL DX, LL DY, LL num, LL l1, LL r1, LL l2, LL r2) {
	X += DX * num, Y -= DY * num;
	return (l1 <= X && X <= r1) && (l2 <= Y && Y <= r2);
}
bool check (LL Limit, LL k1, LL x1, LL k2, LL x2, LL X, bool zero1, bool zero2) {
	LL l1 = x1, r1 = x1 * Limit, l2 = x2, r2 = x2 * Limit;

    if (zero1) l1 = 0;
    if (zero2) l2 = 0;
	
	if (X % _gcd[k1][k2]) return 0;
	LL f = x[k1][k2] * (X / _gcd[k1][k2]), s = y[k1][k2] * (X / _gcd[k1][k2]);
	LL df = k2, ds = k1;
	
	bool fl = judge (f, s, df, ds, ceil ((l1 - f) * 1.0 / df), l1, r1, l2, r2) | judge (f, s, df, ds, floor ((r1 - f) * 1.0 / df), l1, r1, l2, r2);
	swap (f, s);
	swap (df, ds);
	swap (l1, l2);
	swap (r1, r2);
	fl |= judge (f, s, df, ds, ceil ((l1 - f) * 1.0 / df), l1, r1, l2, r2) | judge (f, s, df, ds, floor ((r1 - f) * 1.0 / df), l1, r1, l2, r2);
	return fl;
}
bool check_three (LL Limit, LL x) {
	return 2 <= x && x <= 2 * Limit + 3 * Limit + Limit;
}

signed main () {
    read (t);
    rep (i, 1, 3)
        rep (j, 1, 5)
            read (a[i][j]);
    
    rep (i, 1, 3)
        rep (j, 1, 3)
            _gcd[i][j] = exgcd (i, j, x[i][j], y[i][j]);

	int cnt = 0;
    rep (step, 1, t) {
        LL k = a[1][5], m = a[2][5], x = a[3][5];
        rep (i, 1, 3) a[i][5] = ((a[i][1] * a[i][5] % a[i][4] * a[i][5] % a[i][4] + a[i][2] * a[i][5] % a[i][4] + a[i][3]) % a[i][4]) + 20;
        
        bool fl = 0;

        rep (i, 1, 3) {
            if (check (k, i, 2, x - 2 * m, 1)) fl = 1;
            if (check (k, i, 1, x - 2 * m - m, 1)) fl = 1;
            if (check (k, i, 1, x - 2 * m - 2 * m, 1)) fl = 1;
        }
        rep (i, 1, 3)
            rep (j, 1, 3) {
                if (check (k, i, 1, j, 1, x - 2 * m, 1, 1)) fl = 1;
            }
        
        rep (i, 1, 3) {
        	if (check (k, i, 1, 2, 2, x, 1, 0)) fl = 1;
        	if (check (k, i, 2, 2, 1, x, 1, 0)) fl = 1;

        	if (check (k, i, 1, 2, 1, x - m, 1, 0)) fl = 1;
        	if (check (k, i, 1, 2, 1, x - 2 * m, 1, 1)) fl = 1;
		}
        
		if (check_three (k, x)) fl = 1;

        if (((2 <= x / m && x / m <= 6) || (x / m == 0)) && x % m == 0) fl = 1;
			
		cnt += fl;
    }
    
    cout << cnt;
    return 0;
}
```

讲道理，真的卡常 ~~（虽然只是我的[和谐美好]做法）~~

---

## 作者：3493441984zz (赞：1)

# 恶心的模拟

只是思路难想一点，其他都还好做的

本文参考了网上的题解，可能会有点雷同

------------
# 思路：

- ### 我们先不考虑取中间大小红心的情况

那么我们发现，对于在$2*k+3*k$以内的除了$2*k+3*k-1$这个数的数，我们都可以用两次投镖来得到

- ### 证明：

$1.\ \ \ 2*k+3*k-1$，即：$2*(k+1)-3*(k-1)$
但是我们只能取$[1,k]$之间的数，而$k+1$越界了，所以不能被两次投镖表示

$2.\ \ \ 2*k+3*k-2$，即：$2*(k-1)+3*k$，可以用两次投镖表示

$3.\ \ \ 2*k+3*k-3$，即：$2*k+3*(k-1)$，可以用两次投镖表示

$4.\ \ \ 2*k+3*k-4$，即：$2*(k-2)+3*k$，可以用两次投镖表示

此后每$5$个一个循环，都可以被两次投镖（一次投双倍，一次投三倍）表示出来（也有特例：$1$）

那么大于$2*k+3*k$的数就只能把两个数都取三倍了，也就是$3*a+3*b$来表示

- ### 考虑加入取红心的情况

我们列出每种情况，下文的$i$表示$[1,k]$的$1-3$倍,$|$表示最后一个选的是什么，前两个顺序随意:

$1.m\ i\ |\ i$

$2.2m\ i\ |\ i$

$3.m\ m\ |\ i$

$4.m\ 2m\ |\ i$

$5.2m\ 2m\ |\ i$

$6.i\ i\ |\ 2m$

$7.m\ i\ |\ 2m$

$8.2m\ i\ |\ 2m$

$9.m\ m\ |\ 2m$

$10.m\ 2m\ |\ 2m$

$11.2m\ 2m\ |\ 2m$

十一种情况怎么来的就不用说了吧，要记得最后一个要是双倍这个限制

那么，我们对上面十一种分一下类来讨论

$A.\ 1\ 2$

$B.\ 3\ 4\ 5$

$C.\ 6$

$D.\ 7\ 8$

$E.\ 9\ 10\ 11$

- 对于$A$类，我们把要得到的分数$x-m$或者$x-2m$
然后，因为最后一次取一定要取双倍，所以我们用$2*a+3*b$来判断能否被表示出来，注意减完不能为$0$

- 对于$B$类，我们把$x-2m$或者$x-3m$或者$x-4m$,看看减完后是不是$2$的倍数，并且在$2k$范围之内

- 对于$C$类，我们把$x-3m$后，看看能否用$2a+3b$或者$3a+3b$表示出来

- 对于$D$类，我们把$x-3m$或者$x-4m$后，看看是否是$[1,k]$中某个数本身或者两倍或者三倍

- 对于$E$类，我们直接判断$x$是不是$4m$,$5m$,$6m$


------------
接下来是美滋滋的代码时间~~~

~~~cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define N 7
#define ll long long
using namespace std;
int T;
ll ans,k,m,x,k1,m1,x1;
ll a[N],b[N],c[N],d[N];
bool Check1()
{
    ll kx=k;
    if(x-k*2<=k*3+k*2&&x-k*2!=k*3+k*2-1)
        return 1;
    while((x-kx*2)%3!=0)
        kx--;
    if((x-kx*2)<=k*6)
        return 1;
    return 0;
}
bool Check2(ll now)
{
    if(now<2)
        return 0;
    if(now<=k*3+k*2&&now!=k*3+k*2-1)
        return 1;
    return 0;
}
bool Check3(ll now)
{
    if(now>=0&&now%2==0&&now/2<=k)
        return 1;
    return 0;
}
bool Check4(ll now)
{
    if(now<0)
        return 0;
    ll kx=k;
    if(now<=k*3+k*2&&now!=k*3+k*2-1)
        return 1;
    if(now%3==0&&now<=k*6)
        return 1;
    return 0;
}
bool Check5(ll now)
{
    if(now<0)
        return 0;
    if(now%3==0&&now/3<=k)
        return 1;
    if(now%2==0&&now/2<=k)
        return 1;
    if(now<=k)
        return 1;
    return 0;
}
int main()
{
    scanf("%d",&T);
    scanf("%lld%lld%lld%lld%lld",&a[1],&b[1],&c[1],&d[1],&k);
    scanf("%lld%lld%lld%lld%lld",&a[2],&b[2],&c[2],&d[2],&m);
    scanf("%lld%lld%lld%lld%lld",&a[3],&b[3],&c[3],&d[3],&x);
    for(int i=1;i<=T;++i)
	{
        if(Check1())
            ++ans;
        else 
		if(Check2(x-m)||Check2(x-2*m))
            ++ans;
        else 
		if(Check3(x-2*m)||Check3(x-3*m)||Check3(x-4*m))
            ++ans;
        else 
		if(Check4(x-2*m))
            ++ans;
        else 
		if(Check5(x-3*m)||Check5(x-4*m))
            ++ans;
        else 
		if(x==4*m||x==5*m||x==6*m)
            ++ans;
        k1=(k*k)%d[1];
        k=((k1*a[1])%d[1]+(k*b[1])%d[1]+c[1])%d[1];
        m1=(m*m)%d[2];
        m=((m1*a[2])%d[2]+(m*b[2])%d[2]+c[2])%d[2];
        x1=(x*x)%d[3];
        x=((x1*a[3])%d[3]+(x*b[3])%d[3]+c[3])%d[3];
        k+=20;
        m+=20;
        x+=20;
    }
    printf("%lld",ans);
}
~~~

---

## 作者：haohao_com (赞：1)

## 纯特判

### 首先有一个结论：
在 $5K$ 之内除了 $1$ 和 $5K−1$ 都可以用 $2a+3b$ 这种形式凑出来，证明倒着来凑，发现是每 $5$ 个一个循环就行了。

---

设 $M$ 表示小红心，$i$ 表示其他位置的 $1\sim3$ 倍区域。


---


### 先考虑没有红心的情况：
```cpp
1. i
2. i,i
3. i,i,i
```
前两个比较好判，最后那个由于 $K>20$ ，如果 $X<2K$ 显然是有解的，$X>2K$ 的情况先搞一个 $2K$ 出来，剩下的尝试用 $2a+3b$ 或 $3a+3b$ 的形式凑就好了。


---


### 然后是有红心的情况：
```cpp
M,i,i
2M,i,i
M,M,i
2M,M,i
2M,2M,i
i,i,2M
i,M,2M
i,2M,2M
M,M,2M
M,2M,2M
2M,2M,2M
M,i
M,2M
i,2M
2M
```

### 这么直接讨论太麻烦了， 分成几类：
第一类：$4，5$\
第二类：$6 ，7，8，15$\
第三类：$9$\
第四类：$10，11，17$\
第五类：$12，13，14，16，17$

~~然后大力判就好了…~~


---


### 代码如下：
###### 前面我觉得够详细，就没写注释
```cpp
#include <bits/stdc++.h>
using namespace std;
long long K,M,X,A[3],B[3],C[3],D[3];
int T,ans;
inline bool c1(register long long val){
	if (val<=1 || val==5*K-1 || val>5*K)
        return false;
	return true;
}

inline bool c2(register long long val){
	if (val<=0 || val>2*K)
        return false;
	return val%2==0;
}

inline bool c3(register long long val){
	if (val<=0 || val>6*K)
        return false;
	if (val>5*K)
        return val%3==0;
	if (val%3==0)
        return true;
	return val!=1 && val!=5*K-1;
}
inline bool c4(register long long val){
	if (val<=0 || val>3*K)
        return false;
	if (val%3==0)
        return true;
	if (val<=2*K&&val%2==0)
        return true;
	if (val<=K)
        return true;
	return false;
}
inline bool mul(){
    return (X==2*M) || (X==3*M) || (X==4*M) || (X==5*M) || (X==6*M);
}
inline bool spj(){
	if (X<=5*K&&X!=1&&X!=5*K-1)
        return true;
	long long del=X-2*K;
	if (del<=5*K&&del!=5*K-1)
        return true;
	else{
		while(del%3)
            del+=2;
		if (del>6*K)
            return false;
		return true;
	}
}
int main(){
    ios::sync_with_stdio(0);
	cin>>T;
	cin>>A[0]>>B[0]>>C[0]>>D[0]>>K;
	cin>>A[1]>>B[1]>>C[1]>>D[1]>>M);
	cin>>A[2]>>B[2]>>C[2]>>D[2]>>X;
	while(T--){
		if (spj())
            ans++;
		else if (c1(X-M) || c1(X-2*M))
            ans++;
		else if (c2(X-M) || c2(X-2*M) || c2(X-3*M) || c2(X-4*M))
            ans++;
		else if (c3(X-2*M))
            ans++;
		else if (c4(X-2*M) || c4(X-3*M) || c4(X-4*M))
            ans++;
		else if (mul()) 
            ans++;
		K=(A[0]*K%D[0]*K%D[0]+B[0]*K%D[0]+C[0]) % D[0]+20;
		M=(A[1]*M%D[1]*M%D[1]+B[1]*M%D[1]+C[1]) % D[1]+20;
		X=(A[2]*X%D[2]*X%D[2]+B[2]*X%D[2]+C[2]) % D[2]+20;
	}
	cout<<ans;
    return 0;
}
```

##### 本人写的第一篇题解，如有不对，希望谅解

---


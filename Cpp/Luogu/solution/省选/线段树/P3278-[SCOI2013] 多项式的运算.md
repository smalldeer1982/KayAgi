# [SCOI2013] 多项式的运算

## 题目描述

某天，mzry1992 一边思考着一个项目问题一边在高速公路上骑着摩托车。一个光头踢了他一脚，摩托车损坏，而他也被送进校医院打吊针。现在该项目的截止日期将近，他不得不请你来帮助他完成这个项目。


该项目的目的是维护一个动态的关于x 的无穷多项式 ，这个多项式初始时对于所有i有$a_i = 0$。

$f(x)=a_0x^0+a_1x^1+a_2x^2...$

操作者可以进行四种操作：


将$x^L$ 到$x^R$ 这些项的系数乘上某个定值v


将$x^L$ 到$x^R$ 这些项的系数加上某个定值v


将$x^L 到x^R $这些项乘上x变量


将某个定值v代入多项式F(x)，并输出代入后多项式的值，之后多项式还原为代入前的状况

经过观察，项目组发现使用者的操作集中在前三种，第四种操作不会出现超过10次。mzry1992 负责这个项目的核心代码，你能帮他实现么？


## 说明/提示

【样例解释】

操作一之后，多项式为F(x) = 7x + 7。

操作三之后，多项式为F(x) = 49x + 49。

操作五之后，多项式为F(x) = 49x^2 + 49x。

【数据范围与约定】

对于30% 的数据：N ≤ 5000，0 ≤ L ≤ R ≤ 5000，0 ≤ v ≤ 10^9


另有20% 的数据：N ≤ 10^5，0 ≤ L ≤ R ≤ 10^5，0 ≤ v ≤ 10^9，没有mulx 操作


剩下的50% 的数据：N ≤ 10^5，0 ≤ L ≤ R ≤ 10^5，0 ≤v ≤ 10^9


## 样例 #1

### 输入

```
6
add 0 1 7
query 1
mul 0 1 7
query 2
mulx 0 1
query 3```

### 输出

```
14
147
588
```

# 题解

## 作者：y2823774827y (赞：11)

第一次打$FHQ-treap$，[更好的阅读体验](https://www.cnblogs.com/y2823774827y/p/10373978.html)，不懂$FHQ-treap$的看[这里](https://www.cnblogs.com/y2823774827y/p/10321171.html)

$(1)(2)$线段树裸题，$(4)$不超过十次暴力即可

主要是处理$(3)$：$k_{l-1}x^{l-1}+k_lx^l+k_{l+1}x^{l+1}+...+k_rx^r+k_{r+1}x^{r+1}\longrightarrow$
$k_{l-1}x^{l-1}+0+k_lx^{l+1}+k_{l+1}x^{l+2}+...(k_r+k_{r+1})x^{r+1}$

把$x$的幂次看作一个序列的顺序，其实就是把$0$插入到$l-1$~$l$，把$k_r$和$k_{r+1}$并起来

区间加，区间乘，插入：平衡树裸题

**细节**：预处理插入节点前面要插入一个虚节点处理$(1)(2)l=0$的特殊情况；其实后面也要插入一些节点处理$(3)r=1e5$的右移情况，数据过水不插也能过

超短的代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
inline int Read(){
    int x(0),f(1);char c=getchar();
    while(c<'0' || c>'9'){ if(c=='-')f=-1; c=getchar(); }
    while(c>='0' && c<='9') x=(x<<3)+(x<<1)+c-'0', c=getchar();
    return x*f;
}
const LL p=20130426;
const int maxn=1e6,N=1e5+1;
LL ret,ans;
int n,root,q,cnt,f;
inline int Rand(){ return rand()%100000; }
struct Treap{
    LL key[maxn],lazy1[maxn],lazy2[maxn];
	int heap[maxn],size[maxn],son[maxn][2];
    inline void Pushdown(LL x){
        LL mu(lazy2[x]),ad(lazy1[x]);
		int lc(son[x][0]),rc(son[x][1]);
        lazy1[x]=0,lazy2[x]=1;
        if(mu!=1){
            key[lc]=key[lc]*mu%p, lazy1[lc]=lazy1[lc]*mu%p, lazy2[lc]=lazy2[lc]*mu%p;
            key[rc]=key[rc]*mu%p, lazy1[rc]=lazy1[rc]*mu%p, lazy2[rc]=lazy2[rc]*mu%p;
        }
        if(ad){
            key[lc]=(key[lc]+ad)%p, lazy1[lc]=(lazy1[lc]+ad)%p;
            key[rc]=(key[rc]+ad)%p, lazy1[rc]=(lazy1[rc]+ad)%p;
        }
    }
    inline void Update(int x){
        if(!x) return;
        size[x]=size[son[x][0]]+size[son[x][1]]+1;
    }
    int Merge(int x,int y){
        if(!x || !y) return x|y;
        Pushdown(x),Pushdown(y);
        if(heap[x] < heap[y]){
            son[x][1]=Merge(son[x][1],y); Update(x); return x;
        }else{
            son[y][0]=Merge(x,son[y][0]); Update(y); return y;
        }
    }
    void Split_r(int now,int k,int &x,int &y){
        if(!now) return (void)(x=y=0);
        Pushdown(now);
        if(size[son[now][0]]<k)
            x=now, Split_r(son[now][1], k-size[son[now][0]]-1, son[x][1], y), Update(x), Update(y);
        else
            y=now, Split_r(son[now][0], k, x, son[y][0]), Update(x), Update(y);
    }
    void Query(int now,LL v){
        if(!now) return;
        Pushdown(now);
        Query(son[now][0],v);
        ans=(ans+ret*key[now]%p)%p;
        if(f) ret=ret*v%p; else f=true;
        Query(son[now][1],v);
    }
}T;
int main(){
    srand(time(NULL));
    T.heap[root=++(cnt=N)]=Rand(), T.size[cnt]=T.lazy2[cnt]=1;
    for(LL i=1;i<cnt;++i)
        T.heap[i]=Rand(), T.size[i]=T.lazy2[i]=1,
        root=T.Merge(root,i);
    q=Read();
    int a,b,c,d,l,r; LL v;
    char s[10];
    while(q--){
        scanf(" %s",s);
        if(s[0]=='a'){
            l=Read()+1, r=Read()+1, v=Read();
            T.Split_r(root,l,a,b), T.Split_r(b,(r-(l-1)),b,c);
            T.key[b]=(T.key[b]+v)%p, T.lazy1[b]=(T.lazy1[b]+v)%p;
            root=T.Merge(a, T.Merge(b, c));
        }else if(s[0]=='q'){
            v=Read();
            ret=1,ans=f=0;
            T.Query(root,v);
            printf("%lld\n",ans);
        }else{
            LL len(strlen(s));
            if(len==3){
                l=Read()+1, r=Read()+1, v=Read();
                T.Split_r(root,l,a,b), T.Split_r(b,(r-(l-1)),b,c);
                T.key[b]=(T.key[b]*v)%p, T.lazy1[b]=(T.lazy1[b]*v)%p, T.lazy2[b]=(T.lazy2[b]*v)%p;
                root=T.Merge(a, T.Merge(b, c));
            }else{
                l=Read()+1, r=Read()+1;
                T.Split_r(root,r,a,b), T.Split_r(b,1,b,c), T.Split_r(c,1,c,d);
                T.key[c]=(T.key[c]+T.key[b])%p;
                root=T.Merge(a, T.Merge(c, d));
                T.heap[++cnt]=Rand(), T.size[cnt]=T.lazy2[cnt]=1;
                T.Split_r(root,l,a,b);
                root=T.Merge(a, T.Merge(cnt, b));
            }
        }
    }return 0;
}
```

---

## 作者：星·辉 (赞：8)

搜索`splay`出来了这个题……

看了两眼，只有区间加值、区间乘值、区间右移一位、暴力查询，加上最近刚刚写了大分块，于是就有了这篇题解。

考虑`mulx`操作的本质：

- $a_{R + 1}$ 增加 $a_R$ 。
- $a_i$ 变为 $a_{i - 1}$ ( $L < i \le R$ ) 。
- $a_L$ 变为 $0$ 。

相当于区间 $[L,R-1]$ 右移一位再进行两个单点修改。

区间右移一位怎么做？如果正常的分块，我们会对每个在区间中的块，弹出一个数，加入一个（后面的）数。这样的好处是保证了每个块的大小在修改中不会改变。

但想要这样做，要将块中的数弹出并插入到上一个块后部，需要能够快速抵消块中`tag`的影响。

考虑本题中是否能够快速抵消块中`tag`影响。

因为有前两个操作，我们需要加法`tag`和乘法`tag`。这样一个块中的数 $w$ 的实际值为 $w\times mul + add$ 。考虑在不改变`tag`的情况下插入数 $x$ （实际值），设插入后在块中这个数的值为 $y$ ，则有 $y\times mul + add = x$ 。由于这个方程是在模一个合数 $20130426$ 情况下的，可能无整数解，故无法使用上述方法。

那怎么做？上块状链表吧。

### 块状链表

将每个块的大小由定长转为不定长思考。设需要右移的区间是 $[l,r]$ ，这段区间最左和最右的散块是 $B_l, B_r$ 。右移一位即为在第 $l$ 个数前方插入一个数，并在第 $r$ 个数后方删除一个数，再修改插入的那个数。即 $B_l$ 的长度要增加 $1$ ， $B_r$ 的长度减少 $1$ 。

设块长 $k$ ，则插入或删除块中的一个数的时间复杂度是 $O(k)$ 的。从而单次`mulx`操作复杂度是 $O(k + \dfrac{N}{k})$ 的（ $N$ 为多项式最大次数）。此时 $k$ 取 $\sqrt{N}$ 为最优。

然而插入或删除一个数之后块长就变化了，若经历大量操作后块太长或块过短（块数量太多）都会导致复杂度退化。

所以先将 $k$ 设为 $\sqrt{N}$ ，若某次`mulx`操作之后某个块的长度大于 $2k$ ，就将其拆成两个块；某个块的长度小于 $\dfrac{k}{2}$ ，就将它与下一个块合并。

这样就可以保证复杂度不会退化了。

实现时，细节较多。

虽然时间复杂度是 $O(n\sqrt{n})$ ，但是却还能勉强进第一页……果然平衡树的常数还是太大了……

```cpp
#include<bits/stdc++.h>
namespace my_std{
	using namespace std;
	#define reg register
	#define Rint register int
	#define FOR(i,a,b) for(register int i=(a),ed_##i=(b);i<=ed_##i;++i)
	#define ROF(i,a,b) for(register int i=(a),ed_##i=(b);i>=ed_##i;--i)
	#define FORit(templ,arr,i,a,b) for(register templ *i=(arr)+(a),*ed_##i=(arr)+(b)+1;i!=ed_##i;++i)
	#define ROFit(templ,arr,i,a,b) for(register templ *i=(arr)+(a),*ed_##i=(arr)+(b)-1;i!=ed_##i;--i)
	#define MEM(x,v) memset(x,v,sizeof(x))
	#define Templ(T) template<typename T>
	inline int read(){
		int ans=0,f=1;char c=getchar();
		while(!isdigit(c)){ f^=(c=='-'); c=getchar(); }
		for(;isdigit(c);c=getchar()) ans=(ans<<1)+(ans<<3)+(c^48); return f?ans:-ans;
	}
	const int mod = 20130426, N = 100010, BN = 330, BLO = 325;
	inline void inc(int &x, const int &y){ x += y; if(x >= mod) x -= mod; }
	inline int ksm(int x, int y){
		x %= mod;
		int res=1;
		for(; y; y >>= 1, x = 1ll * x * x % mod) if(y & 1) res = 1ll * res * x % mod;
		return res;
	}
}
using namespace my_std;

int n;

struct Block;
inline void del_Block(Block *B);
inline Block *new_Block();

struct Block{
	Block *nxt;
	int a[BN << 1], add, mul, cnt, beg;
	inline void init(){
		nxt = nullptr;
		MEM(a, 0);
		add = 0, mul = 1, beg = 0, cnt = 0;
		return;	
	}
	inline void push_down(){
		if(mul == 1 && add == 0) return;
		FOR(i, 1, cnt) a[i] = (1ll * a[i] * mul + add) % mod;
		mul = 1, add = 0;
		return;
	}
	inline void split(){//将过大的块拆成两个
		reg Block *to = nxt;
		nxt = new_Block();
		nxt->init();
		nxt->nxt = to;
		nxt->beg = beg + BLO;
		nxt->add = add, nxt->mul = mul;
		nxt->cnt = cnt - BLO, cnt = BLO;
		FOR(i, 1, nxt->cnt) nxt->a[i] = a[i + BLO];
		return;
	}
	inline void merge(){//将过小的块与后面合并
		reg Block *to = nxt, *toto = nullptr;
		if(to == nullptr) return;
		toto = to->nxt;
		this->push_down(), to->push_down();
		if(cnt + to->cnt >= (BLO << 1)){//如果合并之后大小又过大了，就不合并，从下一个块中挖一段到这个块中
			FOR(i, 1, BLO - cnt) a[i + cnt] = to->a[i];
			FOR(i, BLO - cnt + 1, to->cnt) to->a[i - BLO + cnt] = to->a[i];
			to->cnt += cnt - BLO, to->beg -= cnt - BLO;
			cnt = BLO;
			return;
		}
		FOR(i, 1, to->cnt) a[i + cnt] = to->a[i];
		nxt = toto;
		cnt += to->cnt;
		to->nxt = nullptr;
		del_Block(to);
		return;
	}
	inline void check(){
		if(cnt > (BLO << 1)) return split();
		if(cnt <= (BLO >> 1)) return merge();
		return;
	}
};
Block *St, *del[BN << 1];//合并的时候需要垃圾回收
int dtop;

inline void del_Block(Block *B){
	del[dtop++] = B;
	return;
}
inline Block *new_Block(){
	return dtop ? del[--dtop] : new Block;
}

inline void Build(){
	St = new_Block();
	St->init();
	reg Block *now = St;
	FOR(i, 1, ceil(N / (double)BLO)){
		now->add = 0, now->mul = 1, now->beg = (i - 1) * BLO - 1, now->cnt = BLO;
		FOR(j, 1, now->cnt) now->a[j] = 0;
		now->nxt = (i == ed_i) ? nullptr : new_Block();
		if(now->nxt != nullptr) now->nxt->init();
		now = now->nxt;
	}
	return;
}

inline void update_add(int l, int r, int v){//add
	reg Block *now = St;
	
	while(now->beg + now->cnt < l) now = now->nxt;
	
	if(now->beg + now->cnt >= r){
		now->push_down();
		FOR(i, l - now->beg, r - now->beg) inc(now->a[i], v);
		return;
	}
	
	now->push_down();
	FOR(i, l - now->beg, now->cnt) inc(now->a[i], v);
	
	now = now->nxt;
	while(now->beg + now->cnt < r){
		inc(now->add, v);
		now = now->nxt;
	}
	
	now->push_down();
	FOR(i, 1, r - now->beg) inc(now->a[i], v);
	
	return;
}

inline void update_mul(int l, int r, int v){//mul
	reg Block *now = St;
	
	while(now->beg + now->cnt < l) now = now->nxt;
	
	if(now->beg + now->cnt >= r){
		now->push_down();
		FOR(i, l - now->beg, r - now->beg) now->a[i] = 1ll * now->a[i] * v % mod;
		return;
	}
	
	now->push_down();
	FOR(i, l - now->beg, now->cnt) now->a[i] = 1ll * now->a[i] * v % mod;
	
	now = now->nxt;
	while(now->beg + now->cnt < r){
		now->mul = 1ll * now->mul * v % mod, now->add = 1ll * now->add * v % mod;
		now = now->nxt;
	}
	
	now->push_down();
	FOR(i, 1, r - now->beg) now->a[i] = 1ll * now->a[i] * v % mod;
	
	return;
}

inline int query(int v){//暴力query
	Rint res = 0, bt = 0, Add, Mul;
	reg Block *now = St;
	
	while(now != nullptr){
		Add = now->add, Mul = now->mul;
		FOR(i, 1, now->cnt) inc(res, ((1ll * now->a[i] * Mul + Add) % mod) * ksm(v, bt++) % mod);
		now = now->nxt;
	}
	
	return res;
}

inline void update_shift(int l, int r){//mulx
	reg Block *now = St, *lst = nullptr, *x = nullptr;
	
	while(now->beg + now->cnt < l) now = now->nxt;
	
	if(now->beg + now->cnt >= r){
		now->push_down();
		inc(now->a[r - now->beg], now->a[r - now->beg - 1]);
		ROF(i, r - now->beg - 1, l - now->beg + 1) now->a[i] = now->a[i - 1];
		now->a[l - now->beg] = 0;
		return;
	}
	
	now->push_down();
	now->cnt++;
	ROF(i, now->cnt, l - now->beg + 1) now->a[i] = now->a[i - 1];
	now->a[l - now->beg] = 0;
	x = now;
	
	lst = now, now = now->nxt;
	while(now->beg + now->cnt < r){
		now->beg++;
		lst = now, now = now->nxt;
	}
	
	if(now->beg + 1 == r){//细节，这里如果 r 是块内的第一个数就应该把上一个块的最后一个数删除
		lst->push_down();
		now->push_down();
		inc(now->a[1], lst->a[lst->cnt]);
		lst->cnt--;
		lst->check(), x->check();
		return;
	}
	
	now->push_down();
	inc(now->a[r - now->beg - 1], now->a[r - now->beg]);
	now->cnt--;
	FOR(i, r - now->beg, now->cnt) now->a[i] = now->a[i + 1];
	now->beg++;
	now->check(), x->check();
	
}

int main(){
	n = read();
	Build();
	char opt[10];
	Rint l, r;
	FOR(i, 1, n){
		scanf("%s", opt);
		l = read();
		if(opt[0] != 'q') r = read();
		if(opt[0] == 'a'){
			update_add(l, r, read() % mod);
			continue;
		}
		if(opt[0] == 'q'){
			printf("%d\n", query(l % mod));
			continue;
		}
		if(strlen(opt) == 4){
			update_shift(l, r + 1);//为了方便将 r 加了 1
			continue;
		}
		update_mul(l, r, read() % mod);
	}
	return 0;
}
```

---

## 作者：赖今羿 (赞：4)

对于这道题，它有四种操作：
- 区间乘
- 区间加
- 区间右移一位，重叠部分系数相加
- 查询（不超过 10 次）

容易发现对于查询，我们暴力遍历一遍就行了，而对前两个操作，可以直接用标记维护。

而对于第三个操作，可以看成在 $l$ 前面插入一个 $0$，再把 $r$ 位置的数加到 $r+1$ 位置，再把 $r$ 位置的数删去。

于是变成了我们平衡树的裸题啦！

代码里用的是超短的 FHQ。

Code(数组写法)：
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 2e5 + 10, p = 20130426;
int n, cnt, rt, b[N], sz[N], ch[N][2];
ll rs, a[N], d[N], m[N];
mt19937 rnd(251);
int New(ll x) { return a[++cnt] = x % p, b[cnt] = rnd(), sz[cnt] = 1, m[cnt] = 1, cnt; }
void up(int u) { sz[u] = sz[ch[u][0]] + sz[ch[u][1]] + 1; }
void Mul(int u, ll x) { (d[u] *= x) %= p, (m[u] *= x) %= p, (a[u] *= x) %= p; }
void Add(int u, ll x) { (d[u] += x) %= p, a[u] += x; }
void down(int u) {
	if (m[u] != 1) Mul(ch[u][0], m[u]), Mul(ch[u][1], m[u]), m[u] = 1;
	if (d[u]) Add(ch[u][0], d[u]), Add(ch[u][1], d[u]), d[u] = 0;
}
void spl(int u, int k, int &x, int &y) {
	if (!u) return x = y = 0, void();
	down(u);
	if (k <= sz[ch[u][0]]) y = u, spl(ch[u][0], k, x, ch[u][0]);
	else x = u, spl(ch[u][1], k - sz[ch[u][0]] - 1, ch[u][1], y);
	up(u);
}
int mer(int x, int y) {
	if (!x || !y) return x | y;
	down(x), down(y);
	if (b[x] < b[y]) return ch[x][1] = mer(ch[x][1], y), up(x), x;
	else return ch[y][0] = mer(x, ch[y][0]), up(y), y;
}
ll q;
void dfs(int u, ll x) {
	if (!u) return;
	down(u), dfs(ch[u][0], x), (rs += a[u] * q % p) %= p, q = q * x % p, dfs(ch[u][1], x);
}
int main() {
	scanf("%d", &n);
	for (int i = 1; i <= n + 1; ++i) rt = mer(rt, New(0));
	while (n--) {
		char s[10];
		int l, r, u, v, w, y, z;
		ll x;
		scanf("%s", s);
		if (strlen(s) == 3) scanf("%d%d%lld", &l, &r, &x), ++l, ++r, spl(rt, r, v, w), spl(v, l - 1, u, v), (s[0] == 'm') ? Mul(v, x) : Add(v, x), rt = mer(mer(u, v), w);
		else if (s[0] == 'm') scanf("%d%d", &l, &r), ++l, ++r, spl(rt, r + 1, y, z), spl(y, r, w, y), spl(w, r - 1, v, w), spl(v, l - 1, u, v), a[y] += a[w], rt = mer(mer(mer(mer(u, New(0)), v), y), z);
		else scanf("%lld", &x), rs = 0, q = 1, dfs(rt, x), printf("%lld\n", rs);
	}
}
```

(指针写法)：
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int p = 20130426;
#define M(x, y) (x *= y) %= p
#define A(x, y) (x += y) %= p
mt19937 rnd(251);
struct Node {
	Node *ls, *rs;
	ll a, d, m;
	int sz, b;
	void mul(ll x) { M(d, x), M(m, x), M(a, x); }
	void add(ll x) { A(d, x), A(a, x); }
	void down() {
		if (m != 1) ls->mul(m), rs->mul(m), m = 1;
		if (d) ls->add(d), rs->add(d), d = 0;
	}
	void up() { sz = ls->sz + rs->sz + 1; }
} *null, *rt, *U, *V, *W, *Y, *Z;
Node *New(ll x) { return new Node {null, null, x, 0, 1, 1, (int)rnd()}; }
void spl(Node *p, int k, Node *&x, Node *&y) {
	if (p == null) return x = y = null, void();
	p->down();
	if (k <= p->ls->sz) y = p, spl(p->ls, k, x, p->ls);
	else x = p, spl(p->rs, k - p->ls->sz - 1, p->rs, y);
	p->up();
}
Node *mer(Node *x, Node *y) {
	if (x == null) return y;
	if (y == null) return x;
	if (x->b < y->b) return x->down(), x->rs = mer(x->rs, y), x->up(), x;
	else return y->down(), y->ls = mer(x, y->ls), y->up(), y;
}
ll q, x, rs;
int n, l, r;
char s[10];
void dfs(Node *u) {
	if (u == null) return;
	u->down(), dfs(u->ls), A(rs, u->a * q % p), M(q, x), dfs(u->rs);
}
int main() {
	scanf("%d", &n), null = new Node{null, null, 0, 0, 1, 0, 0}, rt = null;
	for (int i = 1; i <= n + 1; ++i) rt = mer(rt, New(0));
	while (n--) {
		scanf("%s", s);
		if (strlen(s) == 3) scanf("%d%d%lld", &l, &r, &x), ++l, ++r, spl(rt, r, V, W), spl(V, l - 1, U, V), (s[0] == 'm') ? V->mul(x) : V->add(x), rt = mer(mer(U, V), W);
		else if (s[0] == 'm') scanf("%d%d", &l, &r), ++l, ++r, spl(rt, r + 1, Y, Z), spl(Y, r, W, Y), spl(W, r - 1, V, W), spl(V, l - 1, U, V), Y->a += W->a, delete W, rt = mer(mer(mer(mer(U, New(0)), V), Y), Z);
		else scanf("%lld", &x), rs = 0, q = 1, dfs(rt), printf("%lld\n", rs);
	}
}
```

---

## 作者：League丶翎 (赞：4)

这道题的题面，emm...，我也不想吐槽什么了

#### 进入正题！

**分析：**

要求：

维护一个无穷多项式，次数≤100001

需要满足区间加法，区间移动，和查询（次数较少可$O(n)$查询）


这种区间修改问题，可以用看起来可以用线段树，树状数组，Splay，Treap，~~块状链表骗分~~，等等

但是是不是都可以用呢？

线段树和树状数组先排除，因为本蒟蒻还不会用线段树和树状数组直接区间移动（欢迎大神来写）

那么Splay和Treap选择那个呢？

当然要祭出 **序列之王 Splay** 了~

Treap也可以啦，但是本文暂时不讨论


首先介绍一下建图思路：

将中序遍历来代表次数，用key值来保存系数，build二分建图即可（就是快！）

等下就会知道为什么这样建图了


具体操作，具体分析


#### mul操作&add操作

目的：

1.将$x^L$到$x^R$这些项的系数乘上某个定值v

2.将$x^L$到$x^R$这些项的系数加上某个定值v

对于已经入门splay的人来说很easy吧

先将l-1旋至root，将r+1旋至ch\[root\]\[1\]，于是需要操作的区间就是以ch\[r\]\[0\]为root的子树

我们在ch\[r\]\[0\]上打上乘法标记和加法标记即可

**注意：**

下传标记时记得先乘再加

而且下传乘法标记时，不仅需要更新子节点的key值，加法标记也需要一同更新


#### mulx操作

目的：

将$x^L$到$x^R$这些项乘上x变量

这个做法就比较巧妙了

我们需要将这个区间的次数都+1，想一想算式的变化，发现：

**将这个序列向右平移一位，然后将r和r+1合并即可**


那么我们建图时以中序遍历来代表次数的操作就派上用场了

我们找到操作序列中最左侧的一个点（中序遍历时最靠前的点）

为它增加一个key值为0的左儿子，即将**l后面的整个序列**中序遍历向后推移了一位


我们找到操作序列中最右侧的一个点（中序遍历时最靠后的点）

将其与r+1合并即可，即将**r后面的整个序列**中序遍历向前推移了一位


这样我们就平移完成了！


#### query操作

目的：

将某个定值v代入多项式F(x)，并输出代入后多项式的值，之后多项式还原为代入前的状况

因为这个操作的次数不会超过10次，直接$O(n)$遍历查询即可


自认为代码可读性比较好~dalao勿喷

**Code：**

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define inf 21000000
#define mod 20130426
#define maxn 400000
ll ch[maxn][2],f[maxn],key[maxn],size[maxn],add[maxn],rid[maxn],num[maxn];
ll root,sz,n,ANS,q;
char str[10];
ll read() {
    ll ans=0,flag=1;
    char c=getchar();
    while( (c>'9' || c<'0') && c!='-' ) c=getchar();
    if(c=='-') flag=-1,c=getchar();
    while(c>='0' && c<='9') ans=ans*10+c-'0',c=getchar();
    return ans*flag;
}
bool get(int x) {return ch[f[x]][1]==x;}
void update(int x) {size[x]=1+size[ch[x][0]]+size[ch[x][1]];}
void clear(int x) {ch[x][0]=ch[x][1]=f[x]=key[x]=size[x]=add[x]=rid[x]=0;}
void pushdown(int x) {
    int l=ch[x][0];
    int r=ch[x][1];
    if(rid[x]!=1) {
        if(l) {
            key[l]=(key[l]*rid[x])%mod;
            add[l]=(add[l]*rid[x])%mod;
            rid[l]=(rid[l]*rid[x])%mod;
        }
        if(r) {
            key[r]=(key[r]*rid[x])%mod;
            add[r]=(add[r]*rid[x])%mod;
            rid[r]=(rid[r]*rid[x])%mod;
        }
        rid[x]=1;
    }
    if(add[x]!=0) {
        if(l) {
            key[l]=(key[l]+add[x])%mod;
            add[l]=(add[l]+add[x])%mod;
        }
        if(r) {
            key[r]=(key[r]+add[x])%mod;
            add[r]=(add[r]+add[x])%mod;
        }
        add[x]=0;
    }
    return ;
}
void rotate(int x) {
    int fa=f[x],ffa=f[fa],w=get(x);
    pushdown(fa),pushdown(x);
    ch[fa][w]=ch[x][w^1],f[ch[fa][w]]=fa;
    ch[x][w^1]=fa,f[fa]=x;
    f[x]=ffa;
    if(ffa)
        ch[ffa][ch[ffa][1]==fa]=x;
    update(fa),update(x);
    return ;
}
void splay(int x,int tar) {
    for(int fa;(fa=f[x])!=tar;rotate(x))
        if(f[fa]!=tar)
            rotate(get(x)==get(fa)?fa:x);
    if(!tar)
        root=x;
    return ;
}
int findx(int x) {
    int now=root;
    while(1) {
        pushdown(now);
        if(ch[now][0] && x<=size[ch[now][0]])
            now=ch[now][0];
        else {
            int tmp=(ch[now][0]?size[ch[now][0]]:0)+1;
            if(x<=tmp) return now;
            x-=tmp;
            now=ch[now][1];
        } 
    }
}
int build(int l,int r,int fa) {
    if(l>r) return 0;
    int mid=(l+r)>>1;
    int now=++sz;
    f[now]=fa;
    rid[now]=1;
    size[now]=1;
    ch[now][0]=build(l,mid-1,now);
    ch[now][1]=build(mid+1,r,now);
    update(now);
    return now;
}
void MUL() {
    int l=read(),r=read();
    ll v=read();
    l=findx(l+1);
    r=findx(r+3);
    splay(l,0);
    splay(r,l);
    key[ch[ch[root][1]][0]]=(key[ch[ch[root][1]][0]]*v)%mod;
    add[ch[ch[root][1]][0]]=(add[ch[ch[root][1]][0]]*v)%mod;
    rid[ch[ch[root][1]][0]]=(rid[ch[ch[root][1]][0]]*v)%mod;
    return ;
}
void ADD() {
    int l=read(),r=read();
    ll v=read();
    l=findx(l+1);
    r=findx(r+3);
    splay(l,0);
    splay(r,l);
    key[ch[ch[root][1]][0]]=(key[ch[ch[root][1]][0]]+v)%mod;
    add[ch[ch[root][1]][0]]=(add[ch[ch[root][1]][0]]+v)%mod;
    return ;
}
void MULX() {
    int l=read(),r=read();
    l=findx(l+1);
    r=findx(r+3);
    splay(l,0);
    splay(r,l);
    
    pushdown(l),pushdown(r);
    
    int now=r;
    while(ch[now][0])
        pushdown(now),now=ch[now][0];
    pushdown(now);
    ch[now][0]=++sz;
    clear(sz);
    f[sz]=now;
    rid[sz]=1;
    size[sz]=1;
    while(now)
        update(now),now=f[now];
    
    now=ch[r][0];
    while(ch[now][1])
        pushdown(now),now=ch[now][1];
    pushdown(now);
    key[r]=(key[r]+key[now])%mod;
    int fa=f[now],w=get(now);
    if(ch[now][0]) {
        ch[fa][w]=ch[now][0];
        f[ch[fa][w]]=fa;
    }
    else
        ch[fa][w]=0;
    clear(now);
    while(fa)
        update(fa),fa=f[fa];
    
    return ;
}
void print(int x) {
    pushdown(x);
    if(ch[x][0])
        print(ch[x][0]);
    if(q!=-1)
        ANS=(ANS+(num[q]*key[x])%mod)%mod;
    q++;
    if(ch[x][1])
        print(ch[x][1]);
    return ;
}
void QUERY() {
    ll v=read();
    ANS=0,q=-1;
    if(!v) {
        puts("0");
        return ;
    }
    num[0]=1;
    for(int i=1;i<=100001;i++)
        num[i]=(num[i-1]*v)%mod;
    print(root);
    printf("%lld\n",ANS);
    return ;
}
int main() {
    n=read();
    root=build(1,100100,0);
    while(n--) {
        scanf("%s",str);
        if(str[0]=='m' && strlen(str)==3)
            MUL();
        else if(str[0]=='a')
            ADD();
        else if(str[0]=='m' && strlen(str)==4)
            MULX();
        else if(str[0]=='q')
            QUERY();
    }
    return 0;
}
```

PS:
话说你知道2014年四川省选是什么时候么？

答案就在博客中哦~


---

## 作者：wcyQwQ (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P3278)

[可能更好的阅读体验](https://chenyu-w.github.io./2023/01/09/P3278%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%9A%84%E8%BF%90%E7%AE%97/)

## 前言

写加调一遍过并且艹到了最优解，纪念一下。

## 分析

`query` 不超过 $10$ 次，直接暴力即可，所以我们主要考虑修改操作。

考虑用 Splay 维护 $(a_0, a_1, a_2,\ldots)$，然后我们考虑一次操作的实质是什么。

对于 `mul` 和 `add`，打两个 `tag` 然后先乘后加下放标记即可。

对于 `mulx`，手玩发现他会让 $(a_L, a_{L + 1}, \ldots, a_R, a_{R + 1}) \rightarrow (0, a_L, a_L + 1, \ldots, a_{R - 1}, a_{R} + a_{R + 1})$，发现是一个区间平移加两个单点修改，上 Splay 维护序列即可。

最后 `query` 直接按照中序遍历遍历 Splay 计算即可。

## 代码

```c++
#include <bits/stdc++.h>

using namespace std;
const int N = 2e5 + 10, mod = 20130426, INF = 1 << 30;
struct node {
	int s[2], v, p, sz, mul, add;
	void init(int _v, int _p) {
		s[0] = s[1] = 0, v = _v, p = _p, mul = sz = 1;
	}
} t[N];
int root, tot;
int res, now;

inline int read() {
	int x = 0, y = 1; char c = getchar();
	while (c < '0' || c > '9') {if (c == '-') y = -1; c = getchar();}
	while (c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();
	return x * y;
}

inline void pushup(int x) {
	t[x].sz = t[t[x].s[0]].sz + t[t[x].s[1]].sz + 1;
}

inline void pushadd(int x, int v) {
	t[x].add = (t[x].add + v) % mod, t[x].v = (t[x].v + v) % mod;
}

inline void pushmul(int x, int v) {
	t[x].mul = 1ll * t[x].mul * v % mod, t[x].add = 1ll * t[x].add * v % mod, t[x].v = 1ll * t[x].v * v % mod;
}

inline void pushdown(int x) {
	pushmul(t[x].s[0], t[x].mul), pushmul(t[x].s[1], t[x].mul), t[x].mul = 1;
	pushadd(t[x].s[0], t[x].add), pushadd(t[x].s[1], t[x].add), t[x].add = 0;
}

inline void rotate(int x) {
	int y = t[x].p, z = t[y].p, k = t[y].s[1] == x;
	t[z].s[t[z].s[1] == y] = x, t[x].p = z;
	t[y].s[k] = t[x].s[!k], t[t[x].s[!k]].p = y;
	t[x].s[!k] = y, t[y].p = x;
	pushup(y), pushup(x);
}

inline void splay(int x, int k) {
	while (t[x].p != k) {
		int y = t[x].p, z = t[y].p;
		if (z != k)
			if ((t[z].s[1] == y) ^ (t[y].s[1] == x)) rotate(x);
			else rotate(y);
		rotate(x);
	}
	if (!k) root = x;
}

inline int get_k(int k) {
	int u = root;
	while (u) {
		pushdown(u);
		if (t[t[u].s[0]].sz >= k) u = t[u].s[0];
		else if (t[t[u].s[0]].sz + 1 == k) return u;
		else k -= t[t[u].s[0]].sz + 1, u = t[u].s[1];
	}
	return u;
}

inline int build(int l, int r, int p) {
	int mid = (l + r) >> 1;
	int u = ++tot;
	t[u].init(0, p);
	if (l < mid) t[u].s[0] = build(l, mid - 1, u);
	if (r > mid) t[u].s[1] = build(mid + 1, r, u);
	return pushup(u), u;
}

inline void query(int u, int v) {
	pushdown(u);
	if (t[u].s[0]) query(t[u].s[0], v);
	if (now != -1) res = (res + 1ll * t[u].v * now % mod) % mod, now = 1ll * now * v % mod;
	else now = 1;
	if (t[u].s[1]) query(t[u].s[1], v);
}

int main() {
	int q = read();
	root = build(0, 1e5 + 2, 0);
	while (q--) {
		string op; cin >> op;
		if (op == "mul") {
			int l = read() + 1, r = read() + 1, v = read();
			l = get_k(l), r = get_k(r + 2);
			splay(l, 0), splay(r, l);
			node &son = t[t[r].s[0]];
			son.v = 1ll * son.v * v % mod, son.mul = 1ll * son.mul * v % mod, son.add = 1ll * son.add * v % mod;
		}
		else if (op == "add") {
			int l = read() + 1, r = read() + 1, v = read();
			l = get_k(l), r = get_k(r + 2);
			splay(l, 0), splay(r, l);
			node &son = t[t[r].s[0]];
			son.v = (son.v + v) % mod, son.add = (son.add + v) % mod;
		}
		else if (op == "mulx") {
			int l = read() + 1, r = read() + 1;
			int lp = get_k(r), rp = get_k(r + 2);
			splay(lp, 0), splay(rp, lp);
			int k = t[t[rp].s[0]].v;
			t[rp].v += k;
			t[rp].s[0] = 0, pushup(rp), pushup(lp);
			lp = get_k(l), rp = get_k(l + 1);
			splay(lp, 0), splay(rp, lp);
			int u = ++tot;
			t[u].init(0, rp), t[rp].s[0] = u;
			pushup(rp), pushup(lp);
		}
		else {
			int v = read();
			printf("%d\n", (res = 0, now = -1, query(root, v), res));
		}
	}
	return 0;
}
```



---

## 作者：totorato (赞：2)

# 用Splay维护这家伙

首先我们需要一个(1e5+n+2)个节点的Splay，其中多了两个节点占用序列的头和尾，以便在Splay中找节点时不分类讨论有没有遇到边界情况。然后就是对几个操作的处理：

### 1.区间加、乘

在Splay中建立add域，代表加的lazy标记。同时还有mul域代表乘的lazy标记。为了方便与直观，我们还可以新增addflag和mulflag域代表是否有未下传的lazy标记。注意一点，mul域的初始值为1。

### 2.区间乘x

对于这个操作直接使用Splay灵活的树操作完成。将[l,r]区间左右两边的两个节点先splay到根节点和根节点的右子节点。此时根节点右子节点的左子树就是[l,r]区间。我们需要将这个区间向右平移一位，于是对这个子树的某些节点更新值后将子树剪下，接在平移后的位置，顺便Splay回根节点(旋旋更健康)

### 3.lazy标记的兼容性问题

标记的新增：对于区间加、乘时对某个节点打标记时的兼容性问题，我们只需要保证打标记时这个节点没有标记，就可以直接修改节点的对应域。具体的操作是pushdown一下。

标记的pushdown：通过对区间加、乘的数学分析，我们可以得出较为简单的处理方式，只要相应地合理地下穿两个标记即可，具体方法在这里略去。

### 4.询问操作

我们只需O(n)暴力获得这个多项式即可计算其值。

具体方法就是边Push\_down边中序遍历。

### 5.如何压行

对不起，200行的我发现自己根本不会。

</br>
### CODE:

```cpp
#include <iostream>
#include <cstring>
#include <cstdio>
#include <cstdlib>
#define MX 410000
#define MOD 20130426LL

using namespace std;

typedef long long ll;
typedef struct tnode
{
    ll a;
    int s[2],f,siz;
    bool mfl,pfl;
    ll mul,pls;
}node;
node t[MX];
int root,tnum;
int n;

int getp(int a){return t[t[a].f].s[1]==a;}
void upd(int a)
{
    t[a].siz=t[t[a].s[0]].siz+t[t[a].s[1]].siz+1;
}
void psd(int a)
{
    int ls=t[a].s[0],rs=t[a].s[1];
    ll mul=t[a].mul,pls=t[a].pls;
    if(t[a].mfl)
    {
        if(ls)
        {
            t[ls].mfl=1;
            t[ls].a=t[ls].a*mul%MOD;
            t[ls].mul=t[ls].mul*mul%MOD;
            t[ls].pls=t[ls].pls*mul%MOD;
        }
        if(rs)
        {
            t[rs].mfl=1;
            t[rs].a=t[rs].a*mul%MOD;
            t[rs].mul=t[rs].mul*mul%MOD;
            t[rs].pls=t[rs].pls*mul%MOD;
        }
        t[a].mfl=0,t[a].mul=1;
    }
    if(t[a].pfl)
    {
        if(ls)
        {
            t[ls].pfl=1;
            t[ls].a=(t[ls].a+pls)%MOD;
            t[ls].pls=(t[ls].pls+pls)%MOD;
        }
        if(rs)
        {
            t[rs].pfl=1;
            t[rs].a=(t[rs].a+pls)%MOD;
            t[rs].pls=(t[rs].pls+pls)%MOD;
        }
        t[a].pfl=0,t[a].pls=0;
    }
}
void rot(int a)
{
    int f=t[a].f,g=t[f].f,p=getp(a),q=getp(f);
    t[f].s[p]=t[a].s[!p],t[a].s[!p]=f,t[f].f=a;
    if(t[f].s[p])t[t[f].s[p]].f=f;
    if(t[a].f=g)t[g].s[q]=a;
    upd(f),upd(a);
}
void spl(int tar,int a)
{
    while(t[a].f!=tar)
        if(t[t[a].f].f==tar)rot(a);
        else if(getp(a)==getp(t[a].f))rot(t[a].f),rot(a);
        else rot(a),rot(a);
    if(!tar)root=a;
}
int findn(int p)
{
    int a=root,s;
    while(a)
    {
        psd(a);
        s=t[t[a].s[0]].siz;
        if(s==p-1)return a;
        else if(s<p-1)a=t[a].s[1],p-=s+1;
        else a=t[a].s[0];
    }
    return a;
}
void insrt(int &a,int f,int p,ll x)
{
    int s=t[t[a].s[0]].siz;
    if(!a)
    {
        a=++tnum;
        t[a]=(node){x,0,0,f,1,0,0,1,0};
        spl(0,a);
    }
    else if(s<=p-1)psd(a),insrt(t[a].s[1],a,p-s-1,x);
    else psd(a),insrt(t[a].s[0],a,p,x);
}
void add(int l,int r,ll x)
{
    int ls=findn(l-1),rs=findn(r+1),a;
    spl(0,ls);
    spl(ls,rs);
    a=t[rs].s[0];
    psd(a);
    t[a].a=(t[a].a+x)%MOD;
    t[a].pfl=1;
    t[a].pls=x%MOD;
}
void mul(int l,int r,ll x)
{
    int ls=findn(l-1),rs=findn(r+1),a;
    spl(0,ls);
    spl(ls,rs);
    a=t[rs].s[0];
    psd(a);
    t[a].a=(t[a].a*x)%MOD;
    t[a].mfl=1;
    t[a].mul=x%MOD;
}
void mov(int l,int r)
{
    int ls=findn(l-1),rs=findn(r+1);
    spl(0,ls),spl(ls,rs);
    int rr=findn(r);
    spl(rs,rr);
    t[rs].a+=t[rr].a;
    t[rs].s[0]=t[rr].s[0];
    t[t[rr].s[0]].f=rs;
    spl(0,rs);
    insrt(root,0,l-1,0);
}
void init()
{
    scanf("%d",&n);
    for(int i=1;i<101000;i++)insrt(root,0,rand()%i,0);
}
ll fac[MX],fnum;
void out(int a,int pos)
{
    psd(a);
    int s=t[t[a].s[0]].siz+1;
    if(s>pos)return;
    if(t[a].s[0])out(t[a].s[0],pos);
    fac[++fnum]=t[a].a;
    if(t[a].s[1])out(t[a].s[1],pos-s);
}
void calc(ll x)
{
    ll ans=0,a=1;
    fnum=0;
    out(root,100015);
    for(int i=2;i<fnum;i++)ans=(ans+fac[i]*a)%MOD,a=a*x%MOD;
    printf("%lld\n",ans);
}
void work()
{
    int a,b;ll c;
    char str[10];
    for(int i=1;i<=n;i++)
    {
        scanf("%s",str);
        if(str[0]=='a')
        {
            scanf("%d%d%lld",&a,&b,&c);
            add(a+2,b+2,c);
        }
        else if(str[0]=='m'&&str[3]=='x')
        {
            scanf("%d%d",&a,&b);
            mov(a+2,b+2);
        }
        else if(str[0]=='m'&&str[3]!='x')
        {
            scanf("%d%d%lld",&a,&b,&c);
            mul(a+2,b+2,c);
        }
        else
        {
            scanf("%lld",&c);
            calc(c);
        }
    }
}
int main()
{
    init();
    work();
    return 0;
}
```

---

## 作者：pokefunc (赞：1)

### Description

维护一个无穷多项式 $a_0x^0+a_1x^1+a_2x^2+\dots$，初始所有 $a_i=0$。

$n$ 次操作，包括：

- 将 $a_l,a_{l+1},\dots,a_r$ 加上一个值；
- 将 $a_l,a_{l+1},\dots,a_r$ 乘上一个值；
- 将 $a_l,a_{l+1},\dots,a_r$ 乘上 $x$；
- 给定 $x$，求多项式的值。

$n \le 10^5$，多项式最多 $10^5+1$ 项，求值操作不超过 $10$ 次。

### Sol

由于求值操作不超过 $10$ 次，因此求值可以暴力。

区间加和区间乘都是很简单的线段树操作。

考虑区间乘 $x$ 的实际意义，实际上就是把 $a_l,a_{l+1},\dots,a_r$ 部分整体向右平移一位，将 $a_r$ 与 $a_{r+1}$ 合并，然后将原来 $a_l$ 的地方补上 $0$，于是这就是一个区间平移和插入操作，用平衡树维护即可。

时间复杂度 $\Theta (n \log n)$。

代码用的是简单好写的 $\rm fhqTreap$。

~~能把区间加的懒标记乘上子树大小调了半个小时我都不知道自己在干嘛~~

### Hint

- 注意懒标记的初始化。
- 如果不进行空间回收，数组要开二倍。
- 注意取模，推荐使用 `x=(x%y+y)%y` 防止出现负数。
- 记得开 `long long`。

### Code

```cpp
#include<cstdio>
#include<cstdlib>
#define int long long
const int M=1e5+5;
const int Mod=20130426;
inline int read(){int x(0),op(0);char ch=getchar();while(ch<'0'||ch>'9')op|=(ch==45),ch=getchar();while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+(ch^48),ch=getchar();return op?-x:x;}
int pw[M];
namespace Treap{
    #define ls(p) t[p].ch[0]
    #define rs(p) t[p].ch[1]
    struct node{
        int val,ch[2],pri,siz;
    }t[M<<1];
    int at[M<<1],mt[M<<1],rt,nt;//at为加法懒标记，mt为乘法懒标记
    void pushup(int p){
        t[p].siz=t[ls(p)].siz+t[rs(p)].siz+1;
    }
    void pushdown(int p){//标记下传
        if(mt[p]^1){
            t[ls(p)].val*=mt[p];
            t[ls(p)].val=(t[ls(p)].val%Mod+Mod)%Mod;
            t[rs(p)].val*=mt[p];
            t[rs(p)].val=(t[rs(p)].val%Mod+Mod)%Mod;
            mt[ls(p)]*=mt[p];
            mt[ls(p)]=(mt[ls(p)]%Mod+Mod)%Mod;
            mt[rs(p)]*=mt[p];
            mt[rs(p)]=(mt[rs(p)]%Mod+Mod)%Mod;
            at[ls(p)]*=mt[p];
            at[ls(p)]=(at[ls(p)]%Mod+Mod)%Mod;
            at[rs(p)]*=mt[p];
            at[rs(p)]=(at[rs(p)]%Mod+Mod)%Mod;
            mt[p]=1;
        }
        if(at[p]){
            t[ls(p)].val+=at[p];
            t[ls(p)].val=(t[ls(p)].val%Mod+Mod)%Mod;
            t[rs(p)].val+=at[p];
            t[rs(p)].val=(t[rs(p)].val%Mod+Mod)%Mod;
            at[ls(p)]+=at[p];
            at[ls(p)]=(at[ls(p)]%Mod+Mod)%Mod;
            at[rs(p)]+=at[p];
            at[rs(p)]=(at[rs(p)]%Mod+Mod)%Mod;
            at[p]=0;
        }
    }
    void print(int p){//调试输出树的信息，可以忽略
		if(!p)return;
		pushdown(p);
		print(ls(p));
		printf("%lld ",t[p].val);
		print(rs(p));
	}
    void split(int p,int s,int &x,int &y){//fhqTreap split by size
        if(!p)return void(x=y=0);
        pushdown(p);
        int rk=t[ls(p)].siz+1;
        if(rk<=s){
            x=p;
            split(rs(p),s-rk,rs(p),y);
        }
        else{
            y=p;
            split(ls(p),s,x,ls(p));
        }
        pushup(p);
    }
    int merge(int x,int y){
        if(!x||!y)return x+y;
        if(t[x].pri<t[y].pri){
            pushdown(x);
            rs(x)=merge(rs(x),y);
            return pushup(x),x;
        }
        pushdown(y);
        ls(y)=merge(x,ls(y));
        return pushup(y),y;
    }
    void insert(int pos,int val){//在位置pos后面插入值val
        t[++nt]=(node){val,{0,0},rand(),1};at[nt]=0;mt[nt]=1;
        int x,y;
        split(rt,pos,x,y);
        rt=merge(merge(x,nt),y);
    }
    void add(int l,int r,int val){//区间加法
        int x,y,z;
        split(rt,l-1,x,y);
        split(y,r-l+1,y,z);
        t[y].val+=val;t[y].val=(t[y].val%Mod+Mod)%Mod;
        at[y]+=val;at[y]=(at[y]%Mod+Mod)%Mod;
        rt=merge(merge(x,y),z);
    }
    void mult(int l,int r,int val){//区间乘法
        int x,y,z;
        split(rt,l-1,x,y);
        split(y,r-l+1,y,z);
        t[y].val*=val;t[y].val=(t[y].val%Mod+Mod)%Mod;
        mt[y]*=val;mt[y]=(mt[y]%Mod+Mod)%Mod;
        at[y]*=val;at[y]=(at[y]%Mod+Mod)%Mod;
        rt=merge(merge(x,y),z);
    }
    void mulx(int l,int r){//区间乘x
        int x,y,z,p,q;
        split(rt,l-1,x,y);
        split(y,r-l+1,y,z);
        split(z,1,z,p);
        split(y,r-l,y,q);
        /*
        这一步分裂完之后的序列被分成了x,y,q,z,p五个部分
        将q和z加起来其中一个合并回去即可
        */
        t[q].val+=t[z].val;t[q].val=(t[q].val%Mod+Mod)%Mod;
        rt=merge(x,merge(y,merge(q,p)));
        insert(l-1,0);
    }
    int qs,tm;
    void dfs(int p){//dfs求整个序列的值
        if(!p)return;
        pushdown(p);
        dfs(ls(p));
        qs+=pw[++tm]*t[p].val%Mod;qs=(qs%Mod+Mod)%Mod;
        dfs(rs(p));
    }
    int query(int x){//查询
        qs=0;tm=-1;
        pw[0]=1;
        for(int i=1;i<M;++i)pw[i]=(pw[i-1]*x%Mod+Mod)%Mod;//预处理幂
        dfs(rt);
        return qs;
    }
}
using namespace Treap;
signed main(){
    int n=read();
    for(int i=0;i<M;++i){//插入结点
        t[++nt]=(node){0,{0,0},rand(),1};at[nt]=0;mt[nt]=1;
        rt=merge(rt,nt);
    }
    char str[10];
    for(int i=1;i<=n;++i){
        int l,r;
        scanf("%s",str);l=read();
        if(str[0]=='q')printf("%lld\n",query(l));
        else{
            l++;
            r=read()+1;
            //这里使用+1，防止出现l-1<0的情况
            if(str[3]=='x')mulx(l,r);
            else{
                int x=read();
                if(str[0]=='a')add(l,r,x%Mod);
                else mult(l,r,x%Mod);
            }
        }
    }
    return 0;
}
```



---

## 作者：RichardSong (赞：1)

# Solution

贴一发 $treap$ 题解。

这题前两种操作明显用平衡树维护区间加、区间乘。

而 $mulx$ 我们就在这一段前面插入一个 $0$ ，然后把第 $R$ 项与 $R+1$ 项合并。

实际上你可以直接把原来第 $R$ 项的节点，累加到 $R+1$ 之后，直接变成 $0$ 节点插在前面。（我没这么写，偷懒了）

由于询问不超过 $10$ 次，取出中序遍历即可。

时间复杂度：$O(nlogn)$ 。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define fir first
#define sec second
#define pb push_back
#define mp make_pair
#define lc t[p].l
#define rc t[p].r
#define Size(x) ((int)((x).size()))
#define rep(i, l, r) for(int (i) = (l); (i) <= (r); ++(i))
#define per(i, r, l) for(int (i) = (r); (i) >= (l); --(i))
#define N 100010
#define mod 20130426
typedef long long ll;
typedef pair<int,int> pii;
typedef vector<int> vii;
//inline char gc() {
//	static char now[1<<16], *S, *T;
//	if(S == T) {T = (S = now) + fread(now, 1, 1<<16, stdin); if(S == T) return EOF;}
//	return *S++;
//}
#define gc getchar
inline int read() {
    int x = 0, f = 1; char c = gc();
    while(c < '0' || c > '9') {if(c == '-') f = -1; c = gc();}
    while(c >= '0' && c <= '9') {x = (x << 3) + (x << 1) + c - 48; c = gc();}
    return x * f;
}
struct Treap {
    int l, r, w, mul, add, sz, h;
}t[N << 1];
int rt = 0, len = 0;
inline int newnode(int w) {
    t[++len] = (Treap){0, 0, w, 1, 0, 1, rand()};
    return len;
}
inline void mulr(int p, int v) {
    t[p].mul = 1ll * t[p].mul * v % mod;
    t[p].add = 1ll * t[p].add * v % mod;
    t[p].w = 1ll * t[p].w * v % mod;
}
inline void addr(int p, int v) {
    (t[p].add+= v)%= mod;
    (t[p].w+= v)%= mod;
}
inline void pushdown(int p) {
    if(t[p].mul != 1) {
        if(lc) mulr(lc, t[p].mul);
        if(rc) mulr(rc, t[p].mul);
        t[p].mul = 1;
    }
    if(t[p].add) {
        if(lc) addr(lc, t[p].add);
        if(rc) addr(rc, t[p].add);
        t[p].add = 0;
    }
}
inline void update(int p) {
    t[p].sz = t[lc].sz + 1 + t[rc].sz;
}
void split1(int p, int x, int &a, int &b) {
    if(!p) return (void)(a = b = 0);
    pushdown(p);
    if(t[lc].sz >= x) {
        split1(lc, x, a, b);
        lc = b;
        b = p;
        update(p);
    } else {
        split1(rc, x - 1 - t[lc].sz, a, b);
        rc = a;
        a = p;
        update(p);
    }
}
int merge1(int i, int j) {
    if(!i || !j) return i + j;
    if(t[i].h < t[j].h) {
        pushdown(i);
        t[i].r = merge1(t[i].r, j);
        update(i);
        return i;
    } else {
        pushdown(j);
        t[j].l = merge1(i, t[j].l);
        update(j);
        return j;
    }
}
inline void merge2(int x, int &y) {
    t[y].w+= t[x].w;
}
int X, tmp, ans;
void dfs(int p) {
    pushdown(p);
    if(lc) dfs(lc);
    (ans+= 1ll * tmp * t[p].w % mod)%= mod;
    (tmp = 1ll * tmp * X % mod)%= mod;
    if(rc) dfs(rc);
}
int main() {
    srand(20011118);
    for(int i = 1; i <= 100001; ++i) {
        rt = merge1(rt, newnode(0));
    }
    int n = read(); char opt[10];
    while(n--) {
        scanf("%s", opt);
        if(opt[0] == 'm' && opt[3] != 'x') {
            int n1, n2, n3, n4;
            int l = read() + 1, r = read() + 1, v = read();
            split1(rt, l - 1, n1, n2);
            split1(n2, r - l + 1, n3, n4);
            mulr(n3, v);
            rt = merge1(n1, merge1(n3, n4));
        }
        if(opt[0] == 'a') {
            int n1, n2, n3, n4;
            int l = read() + 1, r = read() + 1, v = read();
            split1(rt, l - 1, n1, n2);
            split1(n2, r - l + 1, n3, n4);
            addr(n3, v);
            rt = merge1(n1, merge1(n3, n4));
        }
        if(opt[0] == 'm' && opt[3] == 'x') {
            int n1, n2, n3, n4, n5, n6, n7, n8, nn = newnode(0);
            int l = read() + 1, r = read() + 1;
            split1(rt, l - 1, n1, n2);
            split1(n2, r - l + 1, n3, n4);
            split1(n3, t[n3].sz - 1, n5, n6);
            split1(n4, 1, n7, n8);
            merge2(n6, n7);
            rt = merge1(n1, merge1(nn, merge1(n5, merge1(n7, n8))));
        }
        if(opt[0] == 'q') {
            X = read(); tmp = 1;
            ans = 0;
            dfs(rt);
            printf("%d\n", ans);
        }
    }
    return 0;
}
```

---

## 作者：Rayment (赞：1)

#Solution

##其他

~~话说我好像写这个题写了四天？简直就是调试神题。~~我在调试期间还扒了楼下dalao  boshi写的题解下来对拍（为了造福人类，小数据生成器也可以去[我的博客](http://blog.csdn.net/as\_a\_kid/article/details/78995788 "我的博客")拿）。**强烈建议调试了很久的同学重构代码！！！**

发现原来的程序错了两个地方。一个是在mulx操作时下推标记的fr和ba没有下推标记，另一个是新建节点还是比较多，开给节点的空间少了，应该至少要开到2e5，数组溢出导致玄学TLE。讲讲解题的思路吧。

##方法

用splay维护系数，然后以节点在splay中的rank当做节点的幂。在对区间[l,r]进行操作时，转化为开区间(l-1,r+1)，将l-1旋至根，r+1旋至l-1的右儿子，就可以使得操作区间到r+1节点的左子树中，然后就运用懒惰标记的思想。当然为了防止转化区间时溢出，将整个区间右移两位即可。事实上，这都是套路了啊

###add&mul

对于add和mul操作，直接更改r的左儿子然后打上懒惰标记即可，注意下推标记的时候先乘再加。

###mulx

我写的mulx比较繁琐，因为中间的删除和插入操作都直接根据情况手写了一下，如果不喜欢这么繁琐的，建议转战楼下dalao的代码。说一些删除和插入需要注意的细节吧。

对于mulx操作的处理比较巧妙，需要把当前r幂的系数与r+1幂的系数进行合并，然后新建立代表l幂系数为0的节点。这里用fr代表l幂的节点，ba代表r幂的节点。在操作之前，要将根节点到fr、ba的路径上的所有标记下推。

然后删除ba。在删除的时候，把ba的左子树接到父亲节点上去。可以考虑到，当ba的父亲节点为r时，其左子树应接在父亲节点的左儿子上，其他情况接右儿子上。最后然后找到fr，并为其新建左儿子。

但为了保证下次操作findx函数的正确性，在操作完之后，要对根节点(r节点亦可)到fr、ba的链上的节点进行pushup操作。

###query

query操作因为不超过10次，可以利用O(n)的dfs出所有系数，然后暴力完成询问。

##一个相关效率问题

对于直接build所有节点还是使用时insert的效率的差别，应该是差不太多的。虽然前者的节点较多，但splay的效率是O(logn)，相比之下，差别不太大。而且本题的数据并没有什么小数据，直接一次性build可能实际比insert更快，而且更重要的是不容易出错23333

#Code
```cpp
#include <iostream>
#include <cstdio>
#define pd(x) if(add[x]||mul[x]!=1)pushdown(x)
//据说像这样在外面判断一下懒惰标记可以减小常数
using namespace std;
typedef long long ll;
const int maxn=200000,mod=20130426;
int n,cnt,rt,sz,l,r,fr,ba,f[maxn],ch[maxn][2],s[maxn];
ll v,ans,key[maxn],add[maxn],mul[maxn],tmp[maxn];
char str[10];
inline void clear(int x){f[x]=ch[x][0]=ch[x][1]=s[x]=0;key[x]=add[x]=mul[x]=0;}
inline void pushup(int x){s[x]=s[ch[x][0]]+s[ch[x][1]]+1;}
inline void pushdown(int x)
{
    int l=ch[x][0],r=ch[x][1];
    if(mul[x]!=1)
    {
        if(l) key[l]=(key[l]*mul[x])%mod,mul[l]=(mul[l]*mul[x])%mod,add[l]=(add[l]*mul[x])%mod;
        if(r) key[r]=(key[r]*mul[x])%mod,mul[r]=(mul[r]*mul[x])%mod,add[r]=(add[r]*mul[x])%mod;
        mul[x]=1;
    }
    if(add[x])
    {
        if(l) key[l]=(key[l]+add[x])%mod,add[l]=(add[l]+add[x])%mod;
        if(r) key[r]=(key[r]+add[x])%mod,add[r]=(add[r]+add[x])%mod;
        add[x]=0;
    }
}
void rotate(int x,int &k)
{
    int fa=f[x],ff=f[fa],l,r;
    if(ch[fa][0]==x) l=0;
    else l=1;r=l^1;
    if(fa==k) k=x;
    else {if(ch[ff][0]==fa) ch[ff][0]=x;else ch[ff][1]=x;}
    f[x]=ff;f[fa]=x;f[ch[x][r]]=fa;
    ch[fa][l]=ch[x][r];ch[x][r]=fa;
    pushup(fa);pushup(x);
}
void splay(int x,int &k)
{
    while(x!=k)
    {
        int fa=f[x],ff=f[fa];
        if(fa!=k)
        {
            if(ch[fa][0]==x^ch[ff][0]==fa)
              rotate(x,k);
            else
              rotate(fa,k);
        }
        rotate(x,k);
    }
}
inline int build(int l,int r,int pre)//直接建所有节点
{
    if(l>r) return 0;
    int m=(l+r)>>1;
    sz++;clear(m);
    f[m]=pre;mul[m]=1;
    ch[m][0]=build(l,m-1,m);
    ch[m][1]=build(m+1,r,m);
    pushup(m);
    return m;
}
int findx(int x)//find the kth node
{
    int now=rt;
    while(1)
    {
        if(add[now]||mul[now]!=1) pushdown(now);
        if(ch[now][0]&&x<=s[ch[now][0]]) now=ch[now][0];
        else
        {
            int t=(ch[now][0]?s[ch[now][0]]:0)+1;
            if(x<=t) return now;
            x-=t;now=ch[now][1];
        }
    }
}
void work1(int l,int r,ll v)
{
    int now;
    l=findx(l-1);r=findx(r+1);
    splay(l,rt);splay(r,ch[l][1]);now=ch[r][0];
    pd(now);
    key[now]=(key[now]+v)%mod;add[now]=(add[now]+v)%mod;
}
void work2(int l,int r,ll v)
{
    int now;
    l=findx(l-1);r=findx(r+1);
    splay(l,rt);splay(r,ch[l][1]);now=ch[r][0];
    pd(now);
    key[now]=(key[now]*v)%mod;mul[now]=(mul[now]*v)%mod;
}
void work3(int l,int r)
{
    l=findx(l-1);r=findx(r+1);
    splay(l,rt);splay(r,ch[l][1]);
    pd(l);pd(r);
    ba=ch[r][0];
    while(ch[ba][1]){pd(ba);ba=ch[ba][1];}
    pd(ba);key[r]+=key[ba];
    if(f[ba]==r) ch[f[ba]][0]=ch[ba][0],f[ch[ba][0]]=f[ba];
    else ch[f[ba]][1]=ch[ba][0],f[ch[ba][0]]=f[ba];
    while(ba!=r){ba=f[ba];pushup(ba);}//clear(ba);
    fr=r;
    while(ch[fr][0]){pd(fr);fr=ch[fr][0];}
    pd(fr);ch[fr][0]=++sz;clear(sz);
    f[sz]=fr;mul[sz]=1;s[sz]=1;fr=sz;
    while(fr!=r){fr=f[fr];pushup(fr);}
}
void dfs(int now,int pos)
{
    pd(now);
    if(s[ch[now][0]]+1>pos) return ;
    if(ch[now][0]) dfs(ch[now][0],pos);
    tmp[++cnt]=key[now];
    if(ch[now][1]) dfs(ch[now][1],pos-s[ch[now][0]]-1);
}
void query(ll v)
{
    ll x=1;
    ans=0;cnt=0;
    dfs(rt,100100);
    for(int i=2;i<cnt;i++) ans=(ans+tmp[i]*x)%mod,x=x*v%mod;
    printf("%lld\n",ans);
}
int main()
{
    scanf("%d",&n);
    rt=build(1,100100,0);
    for(int i=1;i<=n;i++)
    {
        scanf("%s",str);
        if(str[0]=='a'){scanf("%d%d%lld",&l,&r,&v);work1(l+2,r+2,v);}
        if(str[0]=='m'&&str[3]!='x'){scanf("%d%d%lld",&l,&r,&v);work2(l+2,r+2,v);}
        if(str[0]=='m'&&str[3]=='x'){scanf("%d%d",&l,&r);work3(l+2,r+2);}
        if(str[0]=='q'){scanf("%lld",&v);query(v);}
    }
    return 0;
}
```

---

## 作者：Priestess_SLG (赞：0)

比较恶心的 FHQ-Treap 板子题，~~建议先阅读某一个 c 开头 y 结尾的网站再写~~。最后一个操作十分难以维护（~~看着很拉插~~），但是发现这个操作的询问次数不超过 $10$ 次所以就直接暴力计算每一个点的系数然后相乘求答案就行。前两个操作也是简单的，即【模板】线段树 $2$（欸我是不是还没过那题），在平衡树上维护加法标记和乘法标记，在 pushdown 的时候先下传乘法标记再下传加法标记，然后区间加的时候更新加法标记和单点的值，区间乘的时候更新加法标记，乘法标记和单点的值即可。

对于向右平移 $[l,r]$ 的操作，考虑将区间用 split 操作划分为若干部分（非常粗暴的做法）：

[![pEhf639.png](https://s21.ax1x.com/2025/04/17/pEhf639.png)](https://imgse.com/i/pEhf639)

直接五次 split 划分操作划分出 $6$ 个区间，然后把粉色部分的 FHQ Treap 合并入橙色部分的 FHQ Treap 中，左边单独蓝色的区域用一个新的值为 $0$ 的结点覆盖，剩余部分直接平移到绿色部分即可。

特殊的，发现当 $l=r$ 时中间部分出现了长度为负数的区间，这个时候单独特判一下即可。跑的有点慢，但是能过。

```cpp
// #pragma GCC optimize(3,"Ofast","inline","unroll-loops")
#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/rope>
#define int long long
using namespace std;
const int N = 400010;
const int inf = 2e9;
const int mod = 20130426;
using ull = unsigned long long;
template<class _T>
using treap = __gnu_pbds::tree<_T, __gnu_pbds::null_type, less_equal<_T>, __gnu_pbds::rb_tree_tag, __gnu_pbds::tree_order_statistics_node_update>;
using POD = pair<double, double>;
struct Node {
    int l, r, siz, key, val, add, mul;
} tree[N << 1];
int cnt;
int newnode(int x) {
    ++cnt;
    tree[cnt].siz = 1;
    tree[cnt].key = rand();
    tree[cnt].val = x;
    return cnt;
}
void pushmul(int x, int val) {
    tree[x].mul = tree[x].mul * val % mod;
    tree[x].add = tree[x].add * val % mod;
    tree[x].val = tree[x].val * val % mod;
}
void pushadd(int x, int val) {
    tree[x].add = (tree[x].add + val) % mod;
    tree[x].val = (tree[x].val + val) % mod;
}
void pushdown(int rt) {
    if (tree[rt].mul != 1) {
        if (tree[rt].l) pushmul(tree[rt].l, tree[rt].mul);
        if (tree[rt].r) pushmul(tree[rt].r, tree[rt].mul);
        tree[rt].mul = 1;
    }
    if (tree[rt].add) {
        if (tree[rt].l) pushadd(tree[rt].l, tree[rt].add);
        if (tree[rt].r) pushadd(tree[rt].r, tree[rt].add);
        tree[rt].add = 0;
    }
}
void upd(int rt) {
    tree[rt].siz = tree[tree[rt].l].siz + 1 + tree[tree[rt].r].siz;
}
int merge(int x, int y) {
    if (!x || !y) return x | y;
    if (tree[x].key < tree[y].key) {
        pushdown(x);
        tree[x].r = merge(tree[x].r, y);
        upd(x);
        return x;
    } else {
        pushdown(y);
        tree[y].l = merge(x, tree[y].l);
        upd(y);
        return y;
    }
}
pair<int, int> split(int rt, int k) {
    if (!rt) return {0, 0};
    pushdown(rt);
    if (tree[tree[rt].l].siz + 1 <= k) {
        auto res = split(tree[rt].r, k - tree[tree[rt].l].siz - 1);
        tree[rt].r = res.first;
        upd(rt);
        return {rt, res.second};
    } else {
        auto res = split(tree[rt].l, k);
        tree[rt].l = res.second;
        upd(rt);
        return {res.first, rt};
    }
}
int query(int &rt, int x) {
    auto res = split(rt, x);
    auto res2 = split(res.first, x - 1);
    int val = tree[res2.second].val;
    rt = merge(merge(res2.first, res2.second), res.second);
    return val;
}
signed main() {
    // freopen("1.in", "r", stdin);
    // freopen("1.out", "w", stdout);
    // freopen("debug.err", "w", stderr);
    cin.tie(0)->sync_with_stdio(false);
    cout << fixed << setprecision(15);
    srand(time(0));
    int root = 0;
    for (int i = 1; i <= 200005; ++i) root = merge(root, newnode(0));
    int q;
    cin >> q;
    while (q--) {
        string o;
        cin >> o;
        if (o == "mul") {
            int l, r, v;
            cin >> l >> r >> v;
            ++l, ++r;
            auto res = split(root, r);
            auto res2 = split(res.first, l - 1);
            pushmul(res2.second, v);
            root = merge(merge(res2.first, res2.second), res.second);
        } else if (o == "add") {
            int l, r, v;
            cin >> l >> r >> v;
            ++l, ++r;
            auto res = split(root, r);
            auto res2 = split(res.first, l - 1);
            pushadd(res2.second, v);
            root = merge(merge(res2.first, res2.second), res.second);
        } else if (o == "mulx") {
            int l, r;
            cin >> l >> r;
            ++l, ++r;
            // assert(l!=r);
            if (l == r) {
                auto res = split(root, l - 1);
                auto res2 = split(res.second, 1);
                auto res3 = split(res2.second, 1);
                tree[res3.first].val += tree[res2.first].val;
                int nd = newnode(0);
                root = merge(res.first, merge(nd, merge(res3.first, res3.second)));
                continue;
            }
            auto res = split(root, l - 1);
            auto res2 = split(res.second, 1);
            auto res3 = split(res2.second, r - l - 1);
            auto res4 = split(res3.second, 1);
            auto res5 = split(res4.second, 1);
            tree[res5.first].val += tree[res4.first].val;
            tree[res5.first].val %= mod;
            int nd = newnode(0);
            root = merge(res.first, merge(nd, merge(res2.first, merge(res3.first, merge(res5.first, res5.second)))));
        } else {
            int x;
            cin >> x;
            int sum = 0, pwr = 1;
            for (int i = 1; i <= 200005; ++i) {
                sum = (sum + pwr * query(root, i) % mod) % mod;
                // if (query(root, i)) cout << i << ": " << query(root, i) << '\n';
                pwr = pwr * x % mod;
            }
            cout << sum << '\n';
        }
    }
    return 0;
}
```

---

## 作者：Cells (赞：0)

## 思路

FHQ 的较简单练习题。

看到这道题的前两个操作感觉是线段树，但是异常的是题目保证了查询操作不超过十次，并且还有一个区间所有项次数加一，我们重点考虑这个操作如何完成。

平衡树维护每个次的系数。

我们发现这个操作是 $a_{r + 1} \leftarrow a_{r + 1} + a_r$，$i \in [l, r - 1]$，$a_{i + 1} = a_{i}$，再一想，实质就是将 $[l,r - 1]$ 区间整体的向右移一位，特殊的是 $a_{r + 1}$ 需要加上 $a_r$，然后在这个区间前面插入一个 $0$。

还有几个小细节。首先我们要知道，节点所代表的次数是它的中序遍历的顺序，但是由于有 $0$ 次的存在，我们在处理区间的时候都需要先加一。至于查询，自然是暴力的遍历树来统计答案。

## Code

```c++
# include <bits/stdc++.h>
# define int LL//反正不卡空间,开上最好 
# define lc (t[p].l)
# define rc (t[p].r)
# define rep(i, a, b) for(int i = (a); i <= (b); ++ i)
using namespace std;

using LL = long long;
using ULL = unsigned long long;

const int N = 1e5 + 10, mod = 20130426;

int n;
int arr[N << 2];

string op;

mt19937 rnd(time(0) + (ULL)(new char));

LL qpow(LL a, LL b, LL p){
	LL res = 1;
	while(b){
		if(b & 1) res = res * a % p;
		a = a * a % p;
		b >>= 1;
	}
	
	return res % p;
}

struct FHQ{
	int idx, root;
	
	struct FHQnode{
		int l, r, sz, key, val;
		int mul, add;
	}t[N << 2];
	
	int newnode(int v){
		++ idx;
		t[idx].val = v;
		t[idx].key = rnd();
		t[idx].sz = t[idx].mul = 1;
		t[idx].l = t[idx].r = t[idx].add = 0;
		return idx;
	}
	//以下是普通的线段树二的模板 
	void fadd(int p, int v){
		t[p].val += v;
		t[p].val %= mod;
		t[p].add += v;
		t[p].add %= mod;
	}
	
	void fmul(int p, int v){
		t[p].val *= v;
		t[p].val %= mod;
		t[p].add *= v;
		t[p].add %= mod;
		t[p].mul *= v;
		t[p].mul %= mod;
	}
	
	void pushdown(int p){
		if(t[p].mul != 1){
			fmul(lc, t[p].mul);
			fmul(rc, t[p].mul);
			t[p].mul = 1;
		}
		
		if(t[p].add){
			fadd(lc, t[p].add);
			fadd(rc, t[p].add);
			t[p].add = 0;
		}
	}
	
	void pushup(int p){
		t[p].sz = t[lc].sz + t[rc].sz + 1;
	}
	
	void split(int p, int k, int &x, int &y){
		if(!p){
			x = y = 0;
			return;
		}
		
		pushdown(p);
		
		if(t[lc].sz + 1 <= k){
			x = p;
			split(rc, k - t[lc].sz - 1, rc, y);
		}
		
		else{
			y = p;
			split(lc, k, x, lc);
		}
		
		pushup(p);
	}
	
	int merge(int x, int y){
		if(!x || !y) return x | y;
		
		if(t[x].key >= t[y].key){
			pushdown(x);
			t[x].r = merge(t[x].r, y);
			pushup(x);
			return x;
		}
		
		else{
			pushdown(y);
			t[y].l = merge(x, t[y].l);
			pushup(y);
			return y;
		}
	}
	
	void help_split(int l, int r, int &x, int &y, int &z){
		split(root, r, y, z);
		split(y, l - 1, x, y);
	}
	
	int build(int l, int r, int *a){
		if(l == r) return newnode(a[l]);
		int mid = l + r >> 1;
		return merge(build(l, mid, a), build(mid + 1, r, a));
	}
	
	void insert_sec(int pos, int tot, int *a){
		int x, y;
		split(root, pos, x, y);
		root = merge(merge(x, build(1, tot, a)), y);
	}
	
	void modifyadd(int l, int r, int v){
		int x, y, z;
		help_split(l, r, x, y, z);
		fadd(y, v);
		root = merge(merge(x, y), z);
	}
	
	void modifymul(int l, int r, int v){
		int x, y, z;
		help_split(l, r, x, y, z);
		fmul(y, v);
		root = merge(merge(x, y), z);
	}
	
	void turnright(int l, int r){//右移 
		int x, y, z, y1, y2, z1, z2;
		
		help_split(l, r, x, y, z);
		split(y, r - l, y1, y2);//最后一个需要加到r+1上，所以单独分裂出来 
		split(z, 1, z1, z2);//同理，r+1需要接受y2，单独分裂 
		t[z1].val += t[y2].val;//加上 
		z = merge(z1, z2);
		y = merge(newnode(0), y1);
		root = merge(x, merge(y, z));
	}
	
	int query(int p, int v, int rnk){
		//rnk是这个根节点在遍历到的时候已经有多少节点的中序遍历小于它了 
		if(!p) return 0;
		pushdown(p);//下传标记 
		return ((query(lc, v, rnk) + query(rc, v, rnk + t[lc].sz + 1)) % mod + t[p].val * qpow(v, t[lc].sz + rnk, mod) % mod) % mod;
		//计算当前的贡献rnk不能+1，因为有0次的存在，而我们全部都将l++，r++了 
	}
	
	void display(int p){
		if(!p) return;
		display(lc);
		cout << t[p].val << " ";
		display(rc);
		if(p == root) cout << "\n\n";
	}
}t;

signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	
	cin >> n;
	rep(i, 1, (N - 5) * 2) arr[i] = 0;
	t.insert_sec(0, (N - 5) * 2, arr);
	
	int l, r, v;
	rep(i, 1, n){
		cin >> op;
		if(op == "mul"){
			cin >> l >> r >> v;
			v %= mod;
			l ++, r ++;
			t.modifymul(l, r, v);
		}
		
		else if(op == "add"){
			cin >> l >> r >> v;
			v %= mod;
			l ++, r ++;
			t.modifyadd(l, r, v);
		}
		
		else if(op == "mulx"){
			cin >> l >> r;
			l ++, r ++;
			t.turnright(l, r);
		}
		
		else{
			cin >> v;
			v %= mod;
			cout << t.query(t.root, v, 0) << "\n";
		}
	}
	
	return 0;
}
```

蛮好的练手题，只可惜我考场没切出来。

---

## 作者：__stick (赞：0)

# 题意
题目说的很清楚了，就不赘述了。

# 操作
操作 $1$ ,$2$ 没什么好说的，直接大力上线段树或者文艺平衡树即可，操作   $4$ 也很简单，因为不超过 $10$ 次，直接暴力中序遍历即可，我们重点来看操作 $3$ ，将一个区间内的变量乘上 $x$ ，实际上就是这个区间内的次数加一，也就是将这个区间内的系数整体向右平移一位，同时别忘了加上 $x^{r+1}$  那项的系数，同时原来  $\ x^{l}\ $ 的系数也就变成了零所以还要插入一个空节点 ,然后就变成了 fhq__treap 模板题了，这个题连区间和都不用维护，可谓是业界良心。

操作 $3$ ,代码：
```cpp
			cin>>l>>r;l++,r++;
			split(root,l-1,x,y),split(y,r-l,y,z),split(z,1,z,r1),split(r1,1,r1,r2);
			z->plus(r1->w);r1->w=0;//x,r1,y,z,r2
			root=merge(merge(x,merge(r1,y)),merge(z,r2));
```

由于是乘法优先级更高，所以我们在进行区间乘的时候别忘了更新加法标记。

# 代码

由于题解还没人用指针，蒟蒻决定用指针写一次。
有一些小细节：
1. 由于有操作 $3$ ，长度有可能超过 $10^{5}$ ，我们在建树的时候要多开几个节点。

2. 乘法标记记得赋初值 $1$ ，不然输出全是 $0$ （这个应该好查出来）。

3. 写操作 $3$ 的时候一定要静下心来，仔细处理区间之间的关系，最好按顺序一个一个裂开。

4. fhq_treap 老生常谈了，记得合并！

5. 多项式系数从 $0 $ 开始，而  fhq_treap 维护从 $0 $ 开始的区间会出问题，整体加一即可。

6. 求值的时候别忘了 push_down。

[ 代码戳这里 ](https://www.luogu.com.cn/paste/27fz5ycb)

---

## 作者：intel_core (赞：0)

这个题 $\text{mul,add}$ 都是数据结构基础操作， $\text{query}$ 操作由于只有10次直接单次 $O(n\log n)$ 做甚至都可以，所以重点是 $\text{mulx}$ 操作。

注意到如果我们对于 $[l,r]$ 进行 $\text{mulx}$ 操作的话，相当于把 $[l,r-1]$ 平移到 $[l+1,r]$ 之后把原来 $x^R$ 上的系数加到 $x^{R+1}$ 上。

这里给出 $\text{mulx}$ 操作的过程（在 $\text{FHQ-Treap}$ 的基础上实现）：

```cpp
void mulx(int l,int r){
	int r1,r2,r3,r4;
	split(rt,l,r1,r2);
	split(r2,r,r3,r4);
 	split(r3,r+1,r3,r4);
	add(r+1,r+1,t[r3].val);//把x^r上的系数加到x^r+1上
 	rt=merge(r1,merge(newNode(0),merge(r2,r4)));//在原来x^l的位置添加一个系数为0的项，并恢复Treap形状
}
```

完整代码就不给了，剩下的就是基础的板子。

---


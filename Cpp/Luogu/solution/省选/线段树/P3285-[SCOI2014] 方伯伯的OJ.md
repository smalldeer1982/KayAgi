# [SCOI2014] 方伯伯的OJ

## 题目描述

方伯伯正在做他的 OJ。现在他在处理 OJ 上的用户排名问题。OJ 上注册了 $n$ 个用户，编号为 $1\sim n$，一开始他们按照编号排名。

方伯伯会按照心情对这些用户做以下四种操作，修改用户的排名和编号：

1. 操作格式为 $1\ \ x\ \ y$，意味着将编号为 $x$ 的用户编号改为 $y$，而排名不变，执行完该操作后需要输出该用户在队列中的位置，数据保证 $x$ 必然出现在队列中，同时，$y$ 是一个当前不在排名中的编号。
2. 操作格式为 $2\ \ x$，意味着将编号为 $x$ 的用户的排名提升到第一位，执行完该操作后需要输出执行该操作前编号为 $x$ 用户的排名。
3. 操作格式为 $3\ \ x$，意味着将编号为 $x$ 的用户的排名降到最后一位，执行完该操作后需要输出执行该操作前编号为 $x$ 用户的排名。
4. 操作格式为 $4\ \ k$，意味着查询当前排名为 $k$ 的用户编号，执行完该操作后需要输出当前操作用户的编号。

但同时为了防止别人监听自己的工作，方伯伯对他的操作进行了加密，即将四种操作的格式分别改为了：

- $1\ \ x+a\ \ y+a$；
- $2\ \ x+a$；
- $3\ \ x+a$；
- $4\ \ k+a$；
- 其中 $a$ 为上一次操作得到的输出，一开始 $a=0$。

例如：上一次操作得到的输出是 $5$，这一次操作的输入为：$1\ \ 13\ \ 15$ 因为这个输入是经过加密后的，所以你应该处理的操作是 $1\ \ 8\ \ 10$。

现在你截获了方伯伯的所有操作，希望你能给出结果。

## 说明/提示

对于 $100\%$ 的数据，$1 \le n \le 10^8$，$1 \le m \le 10^5$。

输入保证对于所有的操作 $1,2,3$，$x$ 必然已经出现在队列中，同时对于所有操作 $1$，$1 \le y \le 2\times 10^8$，并且 $y$ 没有出现在队列中。

对于所有操作 $4$，保证 $1 \le k \le n$。

## 样例 #1

### 输入

```
10 10
1 2 11
3 13
2 5
3 7
2 8
2 10
2 11
3 14
2 18
4 9```

### 输出

```
2
2
2
4
3
5
5
7
8
11```

# 题解

## 作者：Ameyax (赞：27)

以排名或编号建树都不能完美满足所有操作的要求，所以我们同时以排名和编号为序建立两棵平衡树$T_1$, $T_2$。

$T_1$以排名为序，$T_2$以编号为序，$T_2$中保存这个编号在$T_1$中对应的节点编号。

操作一，在$T_2$中找到编号，回到$T_1$中算答案，然后直接更新$T_2$即可。

其他操作类似。

另外此题最多有$10^8$名用户，但只有$10^5$个操作，那么我们可以把没有访问过的一段用户合成一个点，访问到其中时再分裂。

$T_2$的功能单一，用std::map就好了。~~我会随便告诉你们我手写的map还没有STL快吗~~

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAX = 330000;
map<int, int> f;
int n, m, cnt, ans, root;
int read()
{
    int x = 0, f = 1; char ch = getchar();
    while (ch > '9' || ch  < '0') { if (ch == '-') f = -1; ch = getchar(); }
    while (ch <= '9' && ch >= '0') { x = x * 10 + ch - '0'; ch = getchar(); }
    return x * f;
}
struct Node
{
    int fa, son[2], siz, l, r;
} T[MAX];
void pushup(int x)
{
    T[x].siz = T[T[x].son[0]].siz + T[T[x].son[1]].siz + T[x].r - T[x].l + 1;
}
void rotate(int x)
{
    int y = T[x].fa, z = T[y].fa;
    int op = T[y].son[1] == x;
    T[x].fa = z;
    if (z) T[z].son[T[z].son[1] == y] = x;
    T[y].son[op] = T[x].son[!op];
    T[T[y].son[op]].fa = y;
    T[y].fa = x;
    T[x].son[!op] = y;
    pushup(y);
}
void splay(int x, int to)
{
    while (T[x].fa != to)
    {
        int y = T[x].fa, z = T[y].fa;
        if (z != to)
        {
            if ((T[z].son[0] == y) ^ (T[y].son[0] == x)) rotate(x);
            else rotate(y);
        } rotate(x);
    }
    pushup(x); 
    if (to == 0) root = x;
}
int query(int x)
{
    splay(x, 0);
    return T[x].siz - T[T[x].son[1]].siz;
}
int getkth(int k)
{
    int x = root;
    while (k)
    {
        int sum = T[T[x].son[0]].siz + T[x].r - T[x].l + 1;
        if (T[T[x].son[0]].siz < k && k <= sum)
        {
            k -= T[T[x].son[0]].siz;
            break;
        }
        if (sum < k)
        {
            k -= sum;
            x = T[x].son[1];
        }
        else x = T[x].son[0];
    }
    return T[x].l + k - 1;
}
void erase(int x)
{
    int pre = T[x].son[0], nxt = T[x].son[1];
    while (T[pre].son[1]) pre = T[pre].son[1];
    while (T[nxt].son[0]) nxt = T[nxt].son[0];
    if (!pre && !nxt) root = 0;
    else if (!pre)
    {
        splay(nxt, root);
        root = nxt; T[root].fa = 0;
        T[x].son[0] = T[x].son[1] = 0;
        T[x].siz = 1;
    }
    else if (!nxt)
    {
        splay(pre, root);
        root = pre; T[root].fa = 0;
        T[x].son[0] = T[x].son[1] = 0;
        T[x].siz = 1;
    }
    else
    {
        splay(pre, 0);
        splay(nxt, pre);
        T[nxt].son[0] = T[x].fa = 0;
        T[x].siz = 1;
        pushup(nxt); pushup(pre);
    }
}
void push_front(int x)
{
    if (!root) { root = x; return ; }
    int fa_ = root;
    while (T[fa_].son[0]) T[fa_].siz ++, fa_ = T[fa_].son[0];
    T[fa_].siz ++;
    T[fa_].son[0] = x;
    T[x].fa = fa_;
    splay(x, 0);
}
void push_back(int x)
{
    if (!root) { root = x; return ; }
    int fa_ = root;
    while (T[fa_].son[1]) T[fa_].siz ++, fa_ = T[fa_].son[1];
    T[fa_].siz ++;
    T[fa_].son[1] = x;
    T[x].fa = fa_;
    splay(x, 0);
}
void split(int x, int id)
{
    int L = T[x].l, R = T[x].r, ls, rs;
    if (L == R) return ;
    if (L == id)
    {
        rs = ++cnt;
        f[R] = rs; f[id] = x;
        T[rs].son[1] = T[x].son[1];
        T[T[rs].son[1]].fa = rs;
        T[x].son[1] = rs; T[rs].fa = x;
        T[rs].l = L + 1; T[rs].r = R;
        T[x].r = L;
        pushup(rs); pushup(x);
    }
    else if (R == id)
    {
        ls = ++cnt;
        f[R - 1] = ls; f[id] = x;
        T[ls].son[0] = T[x].son[0];
        T[T[ls].son[0]].fa = ls;
        T[x].son[0] = ls; T[ls].fa = x;
        T[ls].l = L; T[ls].r = R - 1;
        T[x].l = R;
        pushup(ls); pushup(x);
    }
    else
    {
        ls = ++cnt; rs = ++cnt;
        f[id] = x; f[id - 1] = ls; f[R] = rs;
        T[ls].son[0] = T[x].son[0]; T[rs].son[1] = T[x].son[1];
        T[T[ls].son[0]].fa = ls; T[T[rs].son[1]].fa = rs;
        T[x].son[0] = ls; T[x].son[1] = rs; T[ls].fa = T[rs].fa = x;
        T[x].l = T[x].r = id;
        T[ls].l = L; T[ls].r = id - 1;
        T[rs].l = id + 1; T[rs].r = R;
        pushup(ls); pushup(rs); pushup(x);
    }
    splay(x, 0);
}
void init()
{
    root = cnt = 1;
    T[root].l = 1, T[root].r = n;
    T[root].siz = n;
    f[n] = 1;
}
int main()
{
    n = read(); m = read();
    init();
    while (m --)
    {
        int opt = read();
        if (opt == 1)
        {
            int oid = read() - ans, nid = read() - ans;
            int x = f.lower_bound(oid) -> second;
            split(x, oid);
            ans = query(x);
            T[x].l = T[x].r = nid; f[nid] = x;
            printf("%d\n", ans);
        }
        else if (opt == 2)
        {
            int id = read() - ans;
            int x = f.lower_bound(id) -> second;
            split(x, id);
            ans = query(x);
            erase(x);
            push_front(x);
            printf("%d\n", ans);
        }
        else if (opt == 3)
        {
            int id = read() - ans;
            int x = f.lower_bound(id) -> second;
            split(x, id);
            ans = query(x);
            erase(x);
            push_back(x);
            printf("%d\n", ans);
        }
        else if (opt == 4)
        {
            int k = read() - ans;
            ans = getkth(k);
            printf("%d\n", ans);
        }
    }
    return 0;
}
```

---

## 作者：AubRain (赞：21)

水水水，noip2017列队弱化版？

简化版题意：写一种数据结构，查询第 $k$ 大。

~~（当然原题没有这么简单）~~

不过平衡树或者动态开点线段树都是可以的。

然后用一个 $map$（或者哈希表）存一下每个编号在线段树的哪个位置，在用另一个存一下每个位置上是哪个编号就没了。

（换成 $unordered$_$map$之后反而更慢了

代码：权值线段树写法，**代码很短**

```cpp
#include<bits/stdc++.h>
#define N 100005
#define M N*33 
#define mid ((l+r)>>1)
#define inf 100100005
using namespace std;

inline void rd(int &X){
    X=0;int w=0;char ch=0;
    while(!isdigit(ch))w|=ch=='-',ch=getchar();
    while( isdigit(ch))X=(X<<3)+(X<<1)+(ch^48),ch=getchar();
    X=w?-X:X;
}

int L,R;
map<int,int> id,id2;
int n,m,rt,cnt,ans;
int sum[M],ls[M],rs[M];

void ins(int &p,int x,int l=-inf,int r=inf){
	if(!p) p=++cnt;sum[p]++;if(l==r) return ;
	x<=mid ? ins(ls[p],x,l,mid) : ins(rs[p],x,mid+1,r);
}
int ask(int p,int x,int l=-inf,int r=inf){
	if(!sum[p] or l==r) return 0;
	return x<=mid ? ask(ls[p],x,l,mid) : ask(rs[p],x,mid+1,r)+sum[ls[p]];
}
int find(int p,int k,int l=-inf,int r=inf){
	if(l==r) return l;int num=max(0,min(R,mid)-max(L,l)+1-sum[ls[p]]);
	return num>=k ? find(ls[p],k,l,mid) : find(rs[p],k-num,mid+1,r);
}
inline void work1(int x){
	int now=(id.find(x)==id.end() ? x : id[x]);
	ans=now-L+1-ask(rt,now); ins(rt,now); id[x]=--L;id2[L]=x;	
}
inline void work2(int x){
	int now=(id.find(x)==id.end() ? x : id[x]);
	ans=now-L+1-ask(rt,now); ins(rt,now); id[x]=++R;id2[R]=x;
}
inline void change(int x,int y){
	int now=(id.find(x)==id.end() ? x : id[x]);
	ans=now-L+1-ask(rt,now); id[y]=now; id2[now]=y;
}
inline void ask(int x){
	ans=find(rt,x);ans=(id2.find(ans)==id2.end() ? ans : id2[ans]);
}
signed main(){
	rd(n);rd(m);L=1,R=n;
	while(m--){
		int pd,x,y;rd(pd);rd(x);
		if(pd==1) rd(y),change(x-ans,y-ans),printf("%d\n",ans);
		if(pd==2) work1(x-ans),printf("%d\n",ans);
		if(pd==3) work2(x-ans),printf("%d\n",ans);
		if(pd==4) ask(x-ans),printf("%d\n",ans);
	}
}
```

---

## 作者：VenusM1nT (赞：15)

FHQ Treap。居然没有 FHQ 的题解……做法一样，一个用平衡树一个用 map，不过这题的写法比较神奇，要将一段合成一个点，不然会爆空间。

见代码

```cpp
#include<bits/stdc++.h>
#define MAXN 500005
using namespace std;
int n,m,lastans;
map <int,int> M;
struct FHQTreap
{
	int root,sze,siz[MAXN],son[MAXN][2],faz[MAXN],key[MAXN],L[MAXN],R[MAXN];
	int NewNode(int l,int r)
	{
		siz[++sze]=r-l+1;
		L[sze]=l;
		R[sze]=r;
		son[sze][0]=son[sze][1]=faz[sze]=0;
		key[sze]=rand();
		M[l]=sze;
		return sze;
	}
	void PushUp(int rt)
	{
		faz[son[rt][0]]=rt;
		faz[son[rt][1]]=rt;
		siz[rt]=siz[son[rt][0]]+siz[son[rt][1]]+1+R[rt]-L[rt];
	}
	int Merge(int x,int y)
	{
		if(!x || !y) return x+y;
		if(key[x]<key[y])
		{
			son[x][1]=Merge(son[x][1],y);
			PushUp(x);
			return x;
		}
		else
		{
			son[y][0]=Merge(x,son[y][0]);
			PushUp(y);
			return y;
		}
	}
	void Split(int rt,int pos,int &l,int &r)
	{
		if(!rt) l=r=0;
		else
		{
			if(pos<=siz[son[rt][0]])
			{
				Split(son[rt][0],pos,l,r);
				son[rt][0]=r;
				r=faz[r]=rt;
			}
			else
			{
				Split(son[rt][1],pos-siz[son[rt][0]]-R[rt]+L[rt]-1,l,r);
				son[rt][1]=l;
				l=faz[l]=rt;
			}
			PushUp(rt);
		}
	}
	int FindKth(int rt,int pos)
	{
		if(pos<=siz[son[rt][0]]) return FindKth(son[rt][0],pos);
		pos-=siz[son[rt][0]];
		if(pos-R[rt]+L[rt]-1<=0) return L[rt]+pos-1;
		return FindKth(son[rt][1],pos-R[rt]+L[rt]-1);
	}
	int FindRak(int rt)
	{
		int res=siz[rt]-siz[son[rt][1]];
		while(rt!=root)
		{
			if(son[faz[rt]][1]==rt) res+=siz[faz[rt]]-siz[son[faz[rt]][1]];
			rt=faz[rt];
		}
		return res;
	}
	void Insert(int pos,int l,int r)
	{
		int x,y;
		Split(root,pos-1,x,y);
		root=Merge(Merge(x,NewNode(l,r)),y);
	}
	void Delete(int l,int r)
	{
		int x,y,z;
		Split(root,r,x,z);
		Split(x,l-1,x,y);
		root=Merge(x,z);
	}
}T;
int main()
{
	scanf("%d %d",&n,&m);
	M[1]=1;
	T.Insert(1,1,n);
	for(int i=1;i<=m;i++)
	{
		int opt,x,y;
		scanf("%d %d",&opt,&x);
		x-=lastans;
		if(opt==4)
		{
			lastans=T.FindKth(T.root,x);
			printf("%d\n",lastans);
			continue;
		}
		if(opt==1)
		{
			scanf("%d",&y);
			y-=lastans;
			int l=(--M.lower_bound(x+1))->first;
			int pos=M[l];
			int r=T.R[pos];
			lastans=T.FindRak(pos)-r+x;
			printf("%d\n",lastans);
			T.Delete(lastans-x+l,lastans-x+r);
			if(x>l) T.Insert(lastans-x+l,l,x-1);
			T.Insert(lastans,y,y);
			if(r>x) T.Insert(lastans+1,x+1,r);
		}
		else if(opt==2)
		{
			int l=(--M.lower_bound(x+1))->first;
			int pos=M[l];
			int r=T.R[pos];
			lastans=T.FindRak(pos)-r+x;
			printf("%d\n",lastans);
			T.Delete(lastans-x+l,lastans-x+r);
			if(x>l) T.Insert(lastans-x+l,l,x-1);
			if(r>x) T.Insert(lastans,x+1,r);
			T.Insert(1,x,x);
		}
		else if(opt==3)
		{
			int l=(--M.lower_bound(x+1))->first;
			int pos=M[l];
			int r=T.R[pos];
			lastans=T.FindRak(pos)-r+x;
			printf("%d\n",lastans);
			T.Delete(lastans-x+l,lastans-x+r);
			if(x>l) T.Insert(lastans-x+l,l,x-1);
			if(r>x) T.Insert(lastans,x+1,r);
			T.Insert(n,x,x);
		}
	}
	return 0;
}
```

---

## 作者：lg_zhou (赞：14)

看题解里没有写 fhq 的，来贡献一发 fhq 题解。

首先，fhq treap 可以很轻松维护知排名，求点的编号及用户编号，但不能很好的维护知用户编号来排名。我们先解决这个问题。

我们可以额外维护一个节点信息，就是每个点的父亲。如果我们知道了一个节点编号 $x$，根据 BST 的性质，则它的左子树应该排名都小于它，如果它是它父亲的右儿子，则它的父亲与它的左兄弟排名也小于它，根据每棵子树的大小信息，就可以递归求解出知节点编号求排名的问题。

如果我们知道的是用户编号而不是节点编号，只用拿 `map` 对用户编号和节点编号做一个映射即可。

但是这道题 $n \le 10^8$，不能插入这么多节点。原来每个节点都存一个用户编号，现在我们需要维护一段连续的用户编号即可。具体细节看代码。

创建一个新的节点，我们取用户编号连续段的左端点作为和节点编号做映射。由于存的是连续段，`sz(x)` 取值为连续段的长度。

```cpp
int New(int l, int r){
    mp[l] = ++tot;
    rd(tot) = rand(); sz(tot) = r-l+1;
    l(tot) = l; r(tot) = r;
    return tot;
}
```

`push_up` 的时候额外维护 `fa` 信息

```cpp
void push_up(int x){
    sz(x) = sz(ls(x))+sz(rs(x))+len(x);
    fa(ls(x)) = fa(rs(x)) = x;
}
```

`merge` 没什么区别，`split` 要注意，当前节点的 `sz` 不再为一

```cpp
int merge(int x, int y){
    if (!x || !y) return x|y;
    if (rd(x) > rd(y)){
        rs(x) = merge(rs(x),y);
        push_up(x);
        return x;
    }else{
        ls(y) = merge(x,ls(y));
        push_up(y);
        return y;
    }
}
void split(int p, int k, int &x, int &y){
    if (!p) {
        x = y = 0;
        return;
    }
    if (sz(ls(p)) >= k){
        y = p;
        split(ls(p),k,x,ls(y));
    }else{
        x = p;
        split(rs(p),k-sz(ls(p))-len(p),rs(x),y); // len(x) = r(x)-l(x)+1;
    }
    push_up(p);
}
```


需要注意，这里的 `k-sz(ls(p))-len(p)` 不会出现是负数的情况，我们不会将一个节点中的连续编号再次分裂，如果有需要分裂一个节点，会先分裂节点，再调用此函数。

知排名求用户编号：

```cpp
int find_kth(int x, int rk){
    if (rk <= sz(ls(x))) return find_kth(ls(x),rk); // 递归左边
    rk -= sz(ls(x));
    if (rk <= len(x)) return l(x)+rk-1;
    // 如果在这个节点所代表的连续编号里，那么答案就等于区间左端点
    // 所代表的用户编号加上排名再 -1
    return find_kth(rs(x),rk-len(x)); 
    // 相当于减去 sz(ls(x)) 与 len(x) 递归右边
}
```

知节点编号求排名：（求的是节点代表连续用户编号右端点的排名）

```cpp
int find_rk(int x){
    int res = sz(ls(x))+len(x); 
    // 它的左子树和它自身右端点左边的编号排名比它小
    while(x != rt && x){ // 一直循环到根
        if (rs(fa(x)) == x) res += sz(ls(fa(x)))+len(fa(x));
        // 它是右子树，父亲和左兄弟都比它小
        x = fa(x);
    }
    return res;
}
```

删除插入一段区间：

```cpp
void erase(int l, int r){
    int x,y,z;
    split(rt,l-1,x,y);
    split(y,r-l+1,y,z);
    rt = merge(x,z);
}
void insert(int p, int l, int r){
    int x,y;
    split(rt,p-1,x,y);
    rt = merge(x,merge(New(l,r),y));
}
```

主函数：

```cpp
while(m--){
    int opt,x,y;
    cin >> opt;
    if (opt == 4){
        int rk;
        cin >> rk;  rk -= lst;
        cout << (lst = find_kth(rt,rk)) << endl;
        continue;
    }
    cin >> x; x -= lst;
    if (opt == 1){
        cin >> y; y -= lst;
    }
    auto it = --mp.upper_bound(x);
    int l = (*it).fi, p = (*it).se;
    int r = r(p);
    // 找到用户编号所对应的节点编号，以及节点对应的连续用户编号段的左右端点
    
    
    cout << (lst = find_rk(p)-(r-x)) << endl;
    // 排名是 连续用户段右端点的排名减去 (右端点到编号 x 的距离)
    
    erase(lst-(x-l),lst+(r-x));
    // 将这个段删去

    if (x > l) insert(lst-(x-l),l,x-1);
    if (x < r) insert(lst,x+1,r);
    if (opt == 1) insert(lst,y,y);
    if (opt == 2) insert(1,x,x);
    if (opt == 3) insert(n,x,x);
    
    // 依题意插入新段即可
}
```







---

## 作者：uniqueharry (赞：13)

## 题解

详细描述一下题解第二篇动态开点权值线段树做法是啥意思。

我们先给每个用户赋予一个权值，它们权值的排名就是它们在题目中的排名。最开始的权值区间是 $[1,n]$，用两个指针 $L,R$ 维护值域边界。每出现一个将某个用户挪到最前面时扩展左边界，挪到最后面时拓展右边界，以这个权值为下标开一棵动态开点权值线段树。但因为序列长度很大，操作次数可以接受，所以线段树并不能记录“哪些位置有人”，而是记录哪些位置“没有人”，这样就都可以做了。

1. 将编号为 $x$ 的用户编号改为 $y$，并输出该用户的排名。

用一个 $\text{map}$  维护编号到用户权值的映射。如果 $\text{map}$ 中有 $x$ 则正常取出其权值，否则其权值就为编号本身，若令权值为 $v$，$[l, r]$ 值域区间没有数的位置数量为 $w(l,r)$，则该用户排名为 $v - L + 1 - w(l,r)$。

2. 将编号为 $x$ 的用户排名提升到第一位，并输出该用户执行该操作之前的排名。

还是按照刚才的方法求出该用户的权值，求排名的方法也类似。此时在权值线段树上修改求出的权值位置，表示这个地方已经没有人并且也不再可能有人，因为新产生人的位置只可能是在头尾，并将该编号的映射指向 $L - 1$。

3. 将编号为 $x$ 的用户排名提升到最后一位，并输出该用户执行该操作之前的排名。

和 $2$ 操作类似。

4. 求出排名为 $k$ 的用户的编号。

权值线段树可以很方便地求出第 $k$ 小的权值，求编号建立一个权值到编号的反映射即可，注意在前面几个操作的时候也要修改这个反映射。如果反映射里有求得权值的映射就正常取出编号，否则编号和权值相同，道理和 $1$ 操作中所说的差不多。

至此做完，时间复杂度 $O(m \log n)$。

---

## 作者：妩媚的ak萝莉 (赞：13)

## 题解：

大佬们都是用Splay做的，其实在数据结构运用上面，此题只是NOIP2017D2T3列队的拓展版，动态开点的线段树就可以搞定。

**我的做法的关键在**：
1. 在线段树中，利用初始状态易于计算的特点，不用实际值作为初始化内容，而直接在节点区间未被修改时计算状态。

2. 不改变编号在线段树中实际位置，而通过给节点一个cal表示区间有效点个数来确定此编号的排名

操作可以看做是这几个操作的组合：

1. 查询排名为k的编号
2. 删除编号k，并返回删除前k的排名
3. 将编号k的编号改为p
4. 向队尾或队首添加一个编号

我们开一个map记录编号在线段树的实际位置，给将1~n放在m+1~n+m位置，也就是给排列前后各预留m个位置，设置两个指针在排列前后指向以前没有插入过编号的位置，插入编号后将指针前移或后移就可以了，这样就可以实现4操作。2，3操作里用map里的数据获得编号的位置可以实现。1操作里，用cal直接在线段树上二分就行了。

总时间复杂度：$O(mlogm)$,空间$O(mlogm)$

代码：
```cpp
#include <iostream>
#include <stdio.h>
#include <algorithm>
#include <map>
using namespace std;
struct Node{
    Node* l;
    Node* r;
    int cal,val;
    Node(){
        cal=val=0;
        l=r=NULL;
    }
};
int n,q,Bi,Ai,Jia,Len,pai;
Node* Root;
map<int,int> wei;

Node* NewNode(){
    return new Node();
}

inline int Cal(Node* o,int l,int r)
{
    if(o!=NULL)
        return o->cal;
    r=min(Jia+n,r);
    l=max(Jia+1,l);
    return (l>r?0:r-l+1);
}

void update(Node* o,int l,int r,int k,int val0,int cao)
{
//	printf("%d %d %d %d %d %d\n",l,r,k,val0,cao,pai);
    o->cal+=cao;
    if(l==r){
        if(cao!=-1)
            o->val=val0;
        return;
    }
    int mid=(l+r)>>1,l_cal=Cal(o->l,l,mid);
//	cout<<"cal: "<<l_cal<<endl;
    if(k<=mid)
    {
        if(o->l==NULL){
            o->l=NewNode();
            o->l->cal=l_cal;
        }
        update(o->l,l,mid,k,val0,cao);
    }
    else
    {
        if(o->r==NULL){
            o->r=NewNode();
            o->r->cal=o->cal-1-l_cal;
        }
        pai+=l_cal;
        update(o->r,mid+1,r,k,val0,cao);
    }
}

int query(Node* o,int l,int r,int k)
{
    if(l==r){
        if(!o->val)
            o->val=l-Jia;
        return o->val;
    }
    int mid=(l+r)>>1,l_cal=Cal(o->l,l,mid);	
    if(k<=l_cal)
    {
        if(o->l==NULL){
            o->l=NewNode();
            o->l->cal=l_cal;
        }
        return query(o->l,l,mid,k);
    }
    else
    {
        if(o->r==NULL){
            o->r=NewNode();
            o->r->cal=o->cal+1-l_cal;
        }
        return query(o->r,mid+1,r,k-l_cal);
    }
}

void out(int f,int x){
    printf("After %d %d the rank is :\n",f,x);
    for(int i=1;i<=n;i++)
        printf("%d ",query(Root,1,Len,i));
    printf("\nEnd\n");

}

int main()
{
//	freopen("scoi.in","r",stdin);
//	freopen("scois.out","w",stdout);
    Root=NewNode();
    scanf("%d%d",&n,&q);
    Jia=q;
    Root->cal=n;
    Bi=Jia;
    Ai=Jia+n+1;
    Len=n+2*Jia;
    int a=0;
    while(q--)
    {
        pai=0;
        int f,x,y;
        scanf("%d%d",&f,&x);
        x-=a;
        int w=wei[x];
//		cout<<"sd:"<<w<<endl;
        if(!w) w=x+Jia;
        if(f==1)
        {
            scanf("%d",&y);
            y-=a;	
            wei[x]=-1;
            wei[y]=w;
            
            update(Root,1,Len,w,y,0);
            pai++;
            a=pai;
            printf("%d\n",a);
        }
        else if(f==2)
        {
            wei[x]=Bi;
            
            update(Root,1,Len,w,2853,-1);
            pai++;
            a=pai;
            printf("%d\n",a);
            update(Root,1,Len,Bi,x,1);
            Bi--;
        }
        else if(f==3)
        {
            wei[x]=Ai;
            
            update(Root,1,Len,w,2853,-1);
            pai++;
            a=pai;
            printf("%d\n",a);
            update(Root,1,Len,Ai,x,1);
            Ai++;
        }
        else
        {
            a=query(Root,1,Len,x);
            printf("%d\n",a);
        }
//		out(f,x);
    }
    return 0;
}
```


---

## 作者：Froggy (赞：12)

# 动态开点Splay
### splay按排名排序,map记录右端点编号,即map[k]=t[k].r
这样,map.lower_bound就可以直接找到目标节点

#### 我见许多题解的splay的2,3操作都是先erase再push_front或是push_back,不过我直接再原点上修改,这样一个change完事,可以大大减小代码量~~(也卡了常)
---
类似的题:[P3960 列队](https://www.luogu.org/problemnew/show/P3960)

---
## change函数原理:

* #### 2操作:将目标节点拆开,旋到根,将左子树向右子树合并,目标节点就变成了第一名
* #### 3操作:将目标节点拆开,旋到根,将右子树向左子树合并,目标节点就变成了最后一名
具体实现见代码里的change()函数

---
## 另:
* 1操作直接拆,修改编号,别忘了改map
* 4操作正常,按rank询问编号
~~(我一开始忘把rank-=t[son].siz了,调了一个星期QWQ)~~
# AC代码:
~~马蜂中规中矩~~
```cpp
  #include<iostream>
  #include<cstdio>
  #include<map>
  using namespace std;
  #define N 100010
  inline int read(){
      int x=0,f=1;
      char c=getchar();
      while(c<'0'||c>'9'){
          if(c=='-')f=-1;
          c=getchar();
      }
      while(c>='0'&&c<='9'){
          x=(x<<3)+(x<<1)+c-'0';
          c=getchar();
      }
      return x*f;
  }
  int root,cnt=0,n,m,lans;
  map<int,int> mp; 
  struct node{
      int ch[2],siz,l,r,fa;
  }t[N<<2];
  int newNode(int l,int r){
      int k=++cnt;
      t[k].ch[0]=t[k].ch[1]=0;
      t[k].l=l,t[k].r=r;
      t[k].siz=t[k].r-t[k].l+1;
      return k;
  }
  void up(int k){
      t[k].siz=t[t[k].ch[0]].siz+t[t[k].ch[1]].siz+t[k].r-t[k].l+1;
  }
  int get(int k){
      return t[t[k].fa].ch[1]==k;
  }
  void rorate(int k){//略
      int fa=t[k].fa,gfa=t[fa].fa;
      int d1=get(k),d2=get(fa);
      t[fa].ch[d1]=t[k].ch[d1^1];
      t[t[k].ch[d1^1]].fa=fa;
      t[gfa].ch[d2]=k;
      t[k].fa=gfa;
      t[fa].fa=k;
      t[k].ch[d1^1]=fa;
      up(fa);
      up(k);
  }
  void splay(int k,int goal){//同上
      while(t[k].fa!=goal){
          int fa=t[k].fa,gfa=t[fa].fa;
          int d1=get(k),d2=get(fa);
          if(gfa!=goal){
              if(d1==d2)rorate(fa);
              else rorate(k);
          }
          rorate(k);
      }
      if(goal==0)root=k;
  }
  int kth(int rank){
      int k=root;
      while(1){
          int son=t[k].ch[0];
          if(rank<=t[son].siz)k=son;
          else if(rank>t[son].siz+t[k].r-t[k].l+1){
              rank-=t[son].siz+t[k].r-t[k].l+1;
              k=t[k].ch[1];
          }
          else{
              rank-=t[son].siz;
              return t[k].l+rank-1;
          }
      }
  }
  int rank(int k){//按编号找排名
      splay(k,0);
      return t[t[k].ch[0]].siz+1;
  }
  inline void split(int k,int id){//分裂操作
      int l=0,r=0;
      if(t[k].l==t[k].r)return;
      mp[id]=k;
      if(t[k].l!=id){
          mp[id-1]=l=newNode(t[k].l,id-1);
          t[l].ch[0]=t[k].ch[0];
          t[t[l].ch[0]].fa=l;
          t[k].ch[0]=l;
          t[l].fa=k;
      }
      if(t[k].r!=id){
          mp[t[k].r]=r=newNode(id+1,t[k].r);
          t[r].ch[1]=t[k].ch[1];
          t[t[r].ch[1]].fa=r;
          t[k].ch[1]=r;
          t[r].fa=k;
      }
      t[k].l=t[k].r=id;
      if(l)up(l);
      if(r)up(r);
      up(k);
  }
  void change(int k,int p){//这里,IMPORTANT!
      splay(k,0);
      k=root;
      if(!t[k].ch[p])return;//如果本身就是头或尾,直接再见
      if(!t[k].ch[p^1]){//如果在遥远的另一端,左变右或右变左
          t[k].ch[p^1]=t[k].ch[p];
          t[k].ch[p]=0;
      }
      else{//在中间的话,合并子树
          k=t[k].ch[p^1];
          while(t[k].ch[p])k=t[k].ch[p];
          t[t[root].ch[p]].fa=k;
          t[k].ch[p]=t[root].ch[p];
          t[root].ch[p]=0;
          splay(t[k].ch[p],0);
      }
  }
  int main(){
      n=read();m=read();
      mp[n]=root=newNode(1,n);
      for(int i=1;i<=m;i++){
          int opt,x,y;
          opt=read();x=read();
          x-=lans;
          if(opt == 1){
              y=read(),y -= lans;
              int pos=(*mp.lower_bound(x)).second;
              split(pos,x);
              lans=rank(pos);
              t[pos].l=t[pos].r=y;
              mp[y]=pos;
              cout<<lans<<endl;
          }
          if(opt == 2 || opt == 3){
              int pos=(*mp.lower_bound(x)).second;
              split(pos,x);
              lans=rank(pos);
              change(pos,opt-2);
              cout<<lans<<endl;
          }
          if(opt==4){
              lans=kth(x);//按排名找编号
              cout<<lans<<endl;
          }
      }
      return 0;//bye~
	}
```
##### 顺便放上P3960的代码,方便大家学习~
~~不开long long见祖宗~~
```cpp
  #include<iostream>
  #include<cstdio>
  using namespace std;
  #define N 300010
  #define ll long long
  inline int read(){
      int x=0,f=1;
      char c=getchar();
      while(c<'0'||c>'9'){
          if(c=='-')f=-1;
          c=getchar();
      }
      while(c>='0'&&c<='9'){
          x=(x<<3)+(x<<1)+c-'0';
          c=getchar();
      }
      return x*f;
  }
  int n,m,q,root[N],cnt;
  struct node{
      int ch[2],fa;
      ll siz,l,r;
  }t[N*30];
  inline int newNode(ll l,ll r){
      int k=++cnt;
      t[k].ch[0]=t[k].ch[1]=0;
      t[k].l=l,t[k].r=r;
      t[k].siz=t[k].r-t[k].l+1;
      return k;
  }
  inline void up(int k){
      t[k].siz=t[t[k].ch[0]].siz+t[t[k].ch[1]].siz+t[k].r-t[k].l+1;
  }
  inline int get(int k){
      return t[t[k].fa].ch[1]==k;
  }
  inline void rorate(int k){
      int fa=t[k].fa,gfa=t[fa].fa;
      int d1=get(k),d2=get(fa);
      t[fa].ch[d1]=t[k].ch[d1^1];
      t[t[k].ch[d1^1]].fa=fa;
      t[gfa].ch[d2]=k;
      t[k].fa=gfa;
      t[fa].fa=k;
      t[k].ch[d1^1]=fa;
      up(k);
      up(fa);
  }
  inline void splay(int &root,int k,int goal){
      while(t[k].fa!=goal){
          int fa=t[k].fa,gfa=t[fa].fa;
          int d1=get(k),d2=get(d2);
          if(gfa!=goal){
              if(d1==d2)rorate(fa);
              else rorate(k);
          }
          rorate(k);
      }
      if(goal==0)root=k;
  }
  inline void Insert(int &root,ll l){
      int k=root,fa=0;
      while(k){
          fa=k;
          k=t[k].ch[1];
      }
      k=newNode(l,l);
      if(fa)t[fa].ch[1]=k;
      t[k].fa=fa;
      splay(root,k,0);
  }
  ll splitNode(int &root,int k,ll rank){
      splay(root,k,0);
      rank+=t[k].l-1;
      int tmp=newNode(rank+1,t[k].r);
      t[k].r=rank-1;
      if(t[k].ch[1]==0){
          t[k].ch[1]=tmp;
          t[tmp].fa=k;
      }
      else{
          t[tmp].ch[1]=t[k].ch[1];
          t[t[tmp].ch[1]].fa=tmp;
          t[k].ch[1]=tmp;
          t[tmp].fa=k;
      }
      up(tmp);
      up(k);
      return rank;
  }
  inline ll getKth(int &root,ll rank){
      int k=root;
      while(1){
          int son=t[k].ch[0];
          if(rank<=t[son].siz){
              k=t[k].ch[0];
          }
          else if(rank>t[son].siz+t[k].r-t[k].l+1){
              rank-=(t[son].siz+t[k].r-t[k].l+1);
              k=t[k].ch[1];
          }
          else{
              rank-=t[son].siz;
              return splitNode(root,k,rank);
          }
      }
  }
  int main(){
      n=read();m=read();q=read();
      for(int i=1;i<=n;i++){
          root[i]=newNode(1ll*(i-1)*m+1,1ll*i*m-1);
      }
      root[n+1]=newNode(1ll*m,1ll*m);
      for(int i=2;i<=n;i++){
          Insert(root[n+1],1ll*i*m);
      }

      while(q--){
          int x=read(),y=read();
          if(y==m){
              ll ans=getKth(root[n+1],x);
              printf("%lld\n",ans);
              Insert(root[n+1],ans);
          }
          else{
              ll ans=getKth(root[x],y);
              printf("%lld\n",ans);
              Insert(root[n+1],ans);
              Insert(root[x],getKth(root[n+1],x));
          }
      }
      return 0;
  }
```



---

## 作者：lyx1311 (赞：10)

主流做法是动态开点的平衡树 / 线段树，但这里介绍一种基于分类的平衡树做法（非动态开点）。

思路来源：@[kczno1](https://www.luogu.com.cn/user/9168) 的 [题解](https://www.luogu.com.cn/blog/kczno1/solution-p3285)。

---
## $\bf Solution$
### Part 1
所有用户可以被分为三类：**$\bf\small A.$ 上次操作是 2 操作的；$\bf\small B.$ 在中间没有经历过 2, 3 操作的；$\bf\small C.$ 上次操作是 3 操作的**。

初始时所有用户都在 $\bf\small B$ 集合中。对用户 $x$ 进行 2 操作时，把 $x$ 从原集合中删除，加入到 $\bf\small A$ 中；对用户 $x$ 进行 3 操作时，把 $x$ 从原集合中删除，加入到 $\bf\small C$ 中。

### Part 2
具体而言，维护三棵平衡树，分别表示 $\bf\small A,B,C$ 集合。**平衡树的中序遍历即为排名**。平衡树中的每个元素维护其 **键值、编号**（外加子树大小等其它平衡树自带信息）。

其中的键值，定义如下：

- $\bf\small A$ 中元素 **按加入顺序，依次赋键值为 $-1,-2,-3,\cdots$**
- $\bf\small B$ 中元素 **键值与初始编号（即初始排名）相同（注意不是 1 操作后的编号）**。
- $\bf\small C$ 中元素 **按加入顺序，依次赋键值为 $n+1,n+2,n+3,\cdots$**

这样定义的键值，既维护了有序性，又可以得知元素所在集合。

与此同时，再维护 **编号所对应的键值**，以便可以根据给出的编号，访问其在平衡树中的位置。可以用哈希表 / 平衡树。方便起见，代码里用 STL 中的 map 实现。

显然 $\bf\small B$ 中元素过多，不能直接记录所有元素。我们可以取其补集，即 **只记录被删除的元素**。

### Part 3
对于前三种操作，在 map 中用编号查到键值，在平衡树中查找到对应元素修改。

对于操作 4，若答案在 $\bf\small A$ 或 $\bf\small C$ 中很好做，但由于 $\bf\small B$ 记录的是补集，答案在 $\bf\small B$ 中较为难求。

答案一定在某段区间 $(L,R)$ 中，$L,R$ 是算上 $0$ 和 $n+1$ 后连续的两个被删除的元素。记 $g(x)$ 表示 **原集合 $\bf\small B$ 中满足 $t\in[1,x]$ 的 $t$ 的个数**，有 $g(L)<\text{rank}<g(R)$。在平衡树上二分求得最大的 $x$ 满足 $g(x)<\text{rank}$ ，可以算出答案。

实现时发现操作 4 在 $\bf\small B$ 中求得的答案可能被改变了编号。再开一个 map，记录初始编号为 $x$ 的数现在的编号即可。

---
## $\bf Code$
**[洛谷](https://www.luogu.com.cn/record/67392890) / [LibreOJ](https://loj.ac/s/1356624)**

使用 FHQ-Treap 实现。题解中的 $\bf\small A,B,C$ 集合分别对应代码中的 $\bf\small U,P,D$ 平衡树。



---

## 作者：fush (赞：9)

**树状数组**是个真是个全面的数据结构呢。       
题解区的大佬们太强了，各种动态开点的数据结构。      
我当初是从 https://www.luogu.me/article/zohv6lup 过来的。     
建议先看完上面的文章再回来。  


其实树状数组可以解决大部分权值线段树的问题。          
既然这道题可以用权值线段树做，那么树状数组也是可以的。      

对于树状数组中的数组，则可以用 map 代替。                  
对于 $2, 3$ 操作，我们可以在两端提前预留 $m$ 个位置。          
但是，刚开始有 $n \le 10^8$，不可能每个遍历过去。            
我们把点分成 $3$ 种。           
![1](https://cdn.luogu.com.cn/upload/image_hosting/ptyxr28c.png)
我们考虑每个节点的管理范围，第 $x$ 个点的管理范围是 $\operatorname{lowbit}(x)$。                
其中最前面那段是没用的，后面两段，我们看看他管理范围有多少落在中间的块即可。                 

[AC 记录](https://www.luogu.com.cn/record/210013015)。              
```c++
#include<bits/stdc++.h>
using namespace std;
#define endl '\n'
#define FL(a,b,c) for(int a=(b),a##end=(c);a<=a##end;++a)
#define FR(a,b,c) for(int a=(b),a##end=(c);a>=a##end;--a)
#define lowbit(x) ((x)&-(x))
constexpr int M = 1e5 + 10;
map<int, int>m1, m2, m3;
int last, n, m, x, y, op, L = M, R = M;
int f(int x){
	if(m2.count(x))return m2[x];
	if(x <= M)return 0;
	if(x <= M + n)return m2[x] = min(x - M, lowbit(x));
	return m2[x] = max(0, min(n, M + n - x + lowbit(x)));
}
void add(int x, int y){while(x <= n + M * 2)f(x), m2[x] += y, x += lowbit(x);}
int query(int x, int ans = 0){while(x)ans += f(x), x -= lowbit(x);return last = ans;}
int kth(int k){
	int ans = 0, cnt = 0;
	for(int i = log2(R); i >= 0; i--)
		if((ans += 1 << i) >= R || cnt + f(ans) >= k)ans -= (1 << i);
		else cnt += f(ans);
	return ++ans;
}
int32_t main(){
	cin.tie(0)->sync_with_stdio(0);
	cin >> n >> m, R += n;
	while(m--){
		cin >> op >> x, x -= last;
		if(!m1.count(x))m3[m1[x] = x + M] = x;
		if(op == 1)cin >> y, y -= last, m3[m1[y] = m1[x]] = y, cout << query(m1[y]) << endl;
		else if(op == 4)cout << (last = (m3.count(y = kth(x)) ? m3[y] : (y - M)))<< endl;
		else cout << query(m1[x]) << endl, add(m1[x], -1), add(m1[x] = (op ^ 2 ? ++R : L--), 1), m3[m1[x]] = x;
	}
	return 0;
}
```

---

## 作者：劉子颺 (赞：6)

大大大大大！！！！！！数据结构题。

太大了：

法一：线段树动态开点：注意n有1e8于是考虑m影响的。

法二：两个SPLAY：目的是在n有1e8时一棵维护名次，一棵维护编号。目的是解决n

原理：修改k：则剖成（1，k-1）（k，k）（k+1，n）；

最多复杂度：logn*m；

法三：：一个SPLAY，另外一个用map就可以了。用一个in记录是否到了前端与后缀。
```
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
#include<map>
using namespace std;
inline void read(int &x){//fast read
	int f=1;
	x=0;
	char ch=getchar(); 
	while(ch<'0'||ch>'9'){
		if(ch=='-'){
			f=-1;
		}
		ch=getchar();
	}
	while(ch>='0'&&ch<='9'){
		x=x*10+ch-'0';
		ch=getchar();
	}
	x*=f;
}
int n,m,d;//d is the max num that the tree could expand using by the SET
struct SET{//a set to make sure the line is priority
	#define N (int) 2e5
	int a[N*3];
	int id[N];//idx just record the left sum and that is priority
	int n;
	int insert(int idx){//维持单调的本质原因是为了保证在查询编号时可以得到在哪一块 
		n++;
		id[n]=idx;
		int i=n+d;//we have two sum should be recorded;
		a[i]=1;
		while(i>>=1){
			a[i]++;
		}
		return n;
	}
	void del(int i){// del a point and expand 1 to 3 points 
		i+=d;
		a[i]=0;
		while(i>>=1){
			a[i]--;
		}
	} 
	int rank(int i){//give you a sum and que the rank;
		i+=d;
		int ans=a[i];
		while(i){
			if(i%2==1){
				ans+=a[i-1];
			}
			i/=2;
		}
		return ans;
	}
	int get_by_rank(int x){//give you the rank ans que the sum;
		int i=1;
		while(i<=d){
			if(x<=a[i*2]){
				i*=2;
			}
			else{
				x-=a[i*2];
				i=i*2+1;
			}
		}
		return id[i-d];
	}
}pre,suf;//pre尚未开封的左端（名次小）suf尚未开封的右端（名次大） 
struct SPlAY{
	#define cl(x) c[x][0]
	#define cr(x) c[x][1]
	int fa[N];
	int c[N][2];
	int siz[N];
	int v[N];
	int rt;
	int n;
	int rank(int x){
		int ans=x;
		int i=rt;
		while(i){
			if(v[i]>x){
				i=cl(i);
			}
			else{
				ans-=siz[cl(i)]+1;
				i=cr(i); 
			}
		}
		return ans;
	}
	void sc(int y,int x,bool flag){
		fa[x]=y;
		c[y][flag]=x;
	}
	bool get(int x){
		return x==c[fa[x]][1];
	} 
	void pushup(int x){
		siz[x]=siz[cl(x)]+siz[cr(x)]+1;
	}
	void rotate(int x){
		int y=fa[x];
		bool flag=get(x);
		if(y==rt){
			fa[rt=x]=0;
		}
		else{
			sc(fa[y],x,get(y));
		}
		sc(y,c[x][!flag],flag);
		sc(x,y,!flag);
		pushup(y);
	}
	void splay(int x,int to=0/*depends on the root*/){
		int y;
		while(y=fa[x],y!=to){
			if(fa[y]==to){
				rotate(x);
				break;
			}
			else{
				rotate(get(x)==get(y)?y:x);
				rotate(x);
			}
		}
		pushup(x);
	}
	void insert(int x){//insert the sum to the SPLAY tree   
		n++;
		v[n]=x;
		siz[n]=1;
		if(!rt){
			rt=n;
			return;
		}
		int i=rt;
		while(1){
			bool d=v[i]<x;
			if(c[i][d])
				i=c[i][d];
			else{
				sc(i,n,d);
				splay(n);
				return;
			}
		}
	}
	map<int,int> dy;
	int DY(int x){//hash the changing name of the num
		if(!dy.count(x)){
			return x;
		}
		return dy[x];
	}
	int get_by_rank(int x){//got the sum get the rank值找编号 
		if(!rt){
			return DY(x);
		}
		int i=rt;
		int i0;
		int rank=1;
		while(i){
			i0=i;
			if(x>v[i]-(siz[cl(i)]+rank)){
				rank+=siz[cl(i)]+1;
				i=c[i][1];
			}
			else{
				i=c[i][0];
			}
		}
		splay(i0);
		return DY(x+rank-1);
	}
}out;
const int PRE=1;//PRE means at the head of the queue
const int SUF=2;//SUF means at the tail of the queue
struct point{
	int in,id;//in means if that has been in the queue already and the location that is
};
map<int,point> belong;//the location of the i;
point &B(int x){//这个函数的目的实在映射中寻找这个编号的位置.打传递是因为要通过这个改变belong所hash的值 
	if(!belong.count(x))
		belong[x]=(point){0,x};//如果没有hash过那么必然这时还没有过挪动到队首或队尾 
	return belong[x];
}
int get_rank(int x){//已知编号求名次 
	if(B(x).in==1){
		return pre.a[1]+1-pre.rank(B(x).id);//a 数组在这里表示最左端名次（最大），然后加一是因为计算自己。 
	}
	if(B(x).in==2){
		return n-suf.a[1]+suf.rank(B(x).id);
	}
	return pre.a[1]+out.rank(B(x).id);//如果已经加入splay内，则先加上右端所有的值然后再加上splay中的rank 
}
//引理：pre中的最大名次<out中的最小名次<=out中的最大名次<suf中的最小名次。 
int get_by_rank(int x){//已知名次求编号。 
	if(x<=pre.a[1]){//引理1 
		return pre.get_by_rank(pre.a[1]-x+1);//在pre中的名次是总名次-实际名次+1，因为pre是倒过来的 
	}
	if(x>n-suf.a[1]){//引理3 
		return suf.get_by_rank(x-(n-suf.a[1]));//减去suf之前的所有名次，则是在suf中的实际名次。 
	}//引理2 
	return out.get_by_rank(x-pre.a[1]);//减去pre中的所有名次则是在out中的名次。 
} 
int main(){
	read(n);
	read(m);
//	cout<<n<<" "<<m<<endl; 
	for(d=1;d<m;d*=2);// get the max sum may be
	d--;
	int lastans=0;//must online
	for(int i=1;i<=m;i++){
//		cout<<"number "<<i<<endl;
		int flag;
		read(flag);
		int ans;
		if(flag==4){
			int k;
			read(k);
			k-=lastans;
			ans=get_by_rank(k);//已知名次反向求编号。 
		}
		else{
			int k;
			read(k);
			k-=lastans;
			ans=get_rank(k);//这三中操作都是要求用编号求名次。 
			if(flag==1){
				int to;
				read(to);
				to-=lastans;
				B(to)=B(k);
				if(B(k).in){//出现 in 则必然是改变块，否则是原块 
					(B(k).in==PRE?pre:suf).id[B(k).id]=to;//change the sum to the loc should be and hash the change sum
				}
				else{
					out.dy[B(k).id]=to;//if not hash the change sum; 
				}
			}
			else{//必然会挪动到队首或队尾 
				if(B(k).in==0){//如果没有挪动过，那么在SPLAY插入这个下标。 
					out.insert(B(k).id);
				}
				else
					(B(k).in==PRE?pre:suf).del(B(k).id);//因为会被挪动过，所以删去原本的点。
				if(flag==2){
					B(k)=(point){PRE,pre.insert(k)};//go ahead 
				}
				else{
					B(k)=(point){SUF,suf.insert(k)};//turn back 
				}
			}
		}
		printf("%d\n",ans);
		lastans=ans;//must online
	}
	return 0;//or wrong answer
}
```

---

## 作者：Mooncrying (赞：5)

#### 先来说一些和正解无关的罢。

这个题我写了一天多才过。

逆天的是当时没看到第四个操作是求对应的编号，按求排名写的，并秉持着“脑子不够，数据结构来凑”的原则，写了四个平衡树和三个哈希——关键是真写出来了，结果发现样例最后一个数始终对不上，然后再看一遍题才发现题审错了。

说实话当时是有点崩溃的。

（所以说这里提醒大家一定要把题读好想清再写，不然大概率会见祖宗。）

不过还好，把正解写出来了。

## 好的我们回到正题

### 题目大意

- 给定一个 $n$ 个数的序列，最开始时这些数的编号为 $1$ 到 $n$，有 $m$ 次操作，需要：

	1. 将 $x$ 编号改为 $y$ 并输出排名；
    
   2. 将 $x$ 移到首位并输出之前的排名；
   
   3. 将 $x$ 移到末尾并输出之前的排名；
   
   4. 输出排名为 $x$ 的编号。
   
- $1 \le m \le 10 ^ 5$，$1 \le n \le 10 ^ 8$。

### 题意分析

- 首先 $1 \le n \le 10 ^ 8$ 这样的范围就不支持我们把所有的数都存起来了，我们需要考虑一种新的方法。

- 因为 $n$ 远大于 $m$，而每一次操作只是更改一个数，所以序列中被动过手脚的数其实远远小于从开始苟到结束的数。这些未被更改数不禁数量庞大，而且编号是连续的，这样顺着这个思路这个题就能做了。

- 维护排名就考虑维护一种区间的文艺平衡树。每个节点都让它表示一段连续的数，维护两个边界，$size$ 就维护成以该节点为根的子树覆盖的边界大小。

	同时开一个 map，将左边界与平衡树节点编号建立映射关系。
    
   这样我们执行一次操作就把一段区间拆成三段，中间的一段为当前操作的编号，这样执行各种操作就方便了，而左右两段（可能为空）相当于还在原来的位置。这样我们在写代码的时候就可以写成删去目标数所在区间的节点并将三段重新插入相应的位置即可。这样算算树上的节点最多有 $2 \times 10 ^ 5$ 个，完全允许。
    
   众所周知，map 本质是一颗平衡树，其内部封装了一棵红黑树，与 unordered_map 和 pb_ds 中的 hash_table 的查找方式不同，其查找是基于比较的查找方式，所以说它对于关键字 key 支持 lower_bound 和 upper_bound 函数，这给我们写这个题带来了不小的帮助。有不懂的同学可以先去学习一下 [map](http://c.biancheng.net/view/7173.html)。
   
- 接下来说明平衡树的代码怎么写（我这里使用的是 FHQ Treap）。

	首先：
    
   ```cpp
   #define ls(x) t[x].ls
	#define rs(x) t[x].rs
	#define fa(x) t[x].fa
	#define len(x) (t[x].r - t[x].l + 1)// 偷懒大法好
    const int N = 1e5 + 5;
	struct FHQ_Treap
	{
		int size, ls, rs, fa, key, l, r;
	}t[N << 5];
	```
	（废话）
    
   这个 $fa$ 维护父亲节点，接下来查询排名要用到。
   
   update 函数这么写：
   
   ```cpp
	void update(int x)
	{
		fa(ls(x)) = fa(rs(x)) = x;
		t[x].size = t[ls(x)].size + t[rs(x)].size + len(x);
	}
	```
	建立新结点：
    
   ```cpp
	int addnode(int l, int r)
	{
		Hash[l] = ++cnt;// map 建立映射关系
		t[cnt].size = r - l + 1;
		t[cnt].l = l; t[cnt].r = r;
		t[cnt].key = rand();
		return cnt;
	}
	```
	split 和 merge 和普通的文艺平衡树基本一样：
    
   ```cpp
	void split(int now, int pos, int &x, int &y)
	{
		if(!now) return x = y = 0, void();
		if(t[ls(now)].size < pos)
			x = now, split(rs(now), pos - t[ls(now)].size - len(now), rs(now), y);
            // 这里并不会出问题，我们会避免减成负数
		else y = now, split(ls(now), pos, x, ls(now));
		update(now);
	}
	int merge(int x, int y)
	{
		if(!x || !y) return x | y;
		if(t[x].key > t[y].key)
			return rs(x) = merge(rs(x), y), update(x), x;
		else return ls(y) = merge(x, ls(y)), update(y), y;
	}
	```
	查询排名：
    
   ```cpp
	int getrank(int now)
    // 这里的 now 一开始表示的是被操作数所在区间的平衡树节点编号
    // 查询得到的结果是当前编号节点的右端点的排名
	{
		int ans = t[now].size - t[rs(now)].size;// 其左子树和它本身肯定比它小，加入答案
		while(now != root)
		{
			if(rs(fa(now)) == now) ans += t[fa(now)].size - t[rs(fa(now))].size;
            // 如果该节点是父亲节点的右孩子，则说明左子树和父亲节点的区间一定比它小，加入答案
			now = t[now].fa;
		}
		return ans;
	}
	```
	查询排名对应的数：
    
    ```cpp
	int getnum(int now, int pos)
	{
		if(pos <= t[ls(now)].size) return getnum(ls(now), pos);
		pos -= t[ls(now)].size;
		if(pos <= t[now].r - t[now].l + 1) return t[now].l + pos - 1;
        	// 找到了该位置所在的区间，输出左端点排名 + 当前位置 - 1，易证这种写法的正确性
		else return getnum(rs(now), pos - len(now));//继续找
	}
	```
   插入和删除：
   
   ```cpp
	void Insert(int pos, int l, int r)
	{
		int x, y;
		split(root, pos - 1, x, y);
		root = merge(merge(x, addnode(l, r)), y);
	}
	void Delete(int l, int r)
	{
		int x, y, z;
		split(root, r, x, z);
		split(x, l - 1, x, y);
		root = merge(x, z);
	}// 不多解释
	```
	操作函数：
    
    ```cpp
	void work(int x, int y)
	{
		auto it = --Hash.upper_bound(x);
		int l = it -> first, pos = it -> second;
		int r = t[pos].r;
      	// 找到左端点小于等于该节点的左节点最大区间
  	   	// 语法知识不再赘述
		write(last = getrank(pos) - r + x, '\n');
      	// 输出该数所在区间的右端点排名 - （右端点 - 当前数）
		Delete(last - x + l, last - x + r);
		if(x > l) Insert(last - x + l, l, x - 1);
		if(r > x) Insert(last, x + 1, r);
		if(y == -2) Insert(1, x, x);// 对应操作 2
		else if(y == -3) Insert(n, x, x); // 对应操作 3
		else Insert(last, y, y);// 对应操作 1
        	// 按要求删除和插入
	}
	```
#### 最后放上无注释代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ls(x) t[x].ls
#define rs(x) t[x].rs
#define fa(x) t[x].fa
#define len(x) (t[x].r - t[x].l + 1)
map <int, int> Hash;
const int N = 1e5 + 10;
int n, m, root, cnt, last;
struct FHQ_Treap
{
	int size, ls, rs, fa, key, l, r;
}t[N << 5];
template <typename Tp> void read(Tp &x)
{
	Tp f = 1; x = 0; char ch = getchar();
	while(ch > '9' || ch < '0') { if(ch == '-') f = -1; ch = getchar(); }
	while(ch >= '0' && ch <= '9') { x = (x << 3) + (x << 1) + (ch ^ 48); ch = getchar(); }
	x *= f;
}
template <typename Tp> void write(Tp x, char ch)
{
	if(x < 0) putchar('-'), x = -x;
	if(x > 9) write(x / 10, 0); putchar(x % 10 + '0');
	if(ch == ' ') putchar(' '); if(ch == '\n') putchar('\n');
}
int addnode(int l, int r)
{
	Hash[l] = ++cnt;
	t[cnt].size = r - l + 1;
	t[cnt].l = l; t[cnt].r = r;
	t[cnt].key = rand();
	return cnt;
}
void update(int x)
{
	fa(ls(x)) = fa(rs(x)) = x;
	t[x].size = t[ls(x)].size + t[rs(x)].size + len(x);
}
void split(int now, int pos, int &x, int &y)
{
	if(!now) return x = y = 0, void();
	if(t[ls(now)].size < pos)
		x = now, split(rs(now), pos - t[ls(now)].size - len(now), rs(now), y);
	else y = now, split(ls(now), pos, x, ls(now));
	update(now);
}
int merge(int x, int y)
{
	if(!x || !y) return x | y;
	if(t[x].key > t[y].key)
		return rs(x) = merge(rs(x), y), update(x), x;
	else return ls(y) = merge(x, ls(y)), update(y), y;
}
int getrank(int now)
{
	int ans = t[now].size - t[rs(now)].size;
	while(now != root)
	{
		if(rs(fa(now)) == now) ans += t[fa(now)].size - t[rs(fa(now))].size;
		now = t[now].fa;
	}
	return ans;
}
int getnum(int now, int pos)
{
	if(pos <= t[ls(now)].size) return getnum(ls(now), pos);
	pos -= t[ls(now)].size;
	if(pos <= t[now].r - t[now].l + 1) return t[now].l + pos - 1;
	else return getnum(rs(now), pos - len(now));
}
void Insert(int pos, int l, int r)
{
	int x, y;
	split(root, pos - 1, x, y);
	root = merge(merge(x, addnode(l, r)), y);
}
void Delete(int l, int r)
{
	int x, y, z;
	split(root, r, x, z);
	split(x, l - 1, x, y);
	root = merge(x, z);
}
void work(int x, int y)
{
	auto it = --Hash.upper_bound(x);
	int l = it -> first, pos = it -> second;
	int r = t[pos].r;
	write(last = getrank(pos) - r + x, '\n');
	Delete(last - x + l, last - x + r);
	if(x > l) Insert(last - x + l, l, x - 1);
	if(r > x) Insert(last, x + 1, r);
	if(y == -2) Insert(1, x, x);
	else if(y == -3) Insert(n, x, x);
	else Insert(last, y, y);
}
int main()
{
	read(n); read(m);
	Hash[1] = 1; Insert(1, 1, n);
	for(int i = 1, x, y, opt; i <= m; ++ i)
	{
		read(opt); read(x); x -= last;
		switch(opt)
		{
			case 1:
				read(y); y -= last; work(x, y); break;
			case 2:
				work(x, -2); break;
			case 3:
				work(x, -3); break;	
			case 4:
				write(last = getnum(root, x), '\n'); break;	
		}
	}
}
```
码风中规中矩吧大家轻喷。。（逃

---

## 作者：Richard_H (赞：4)

梗概：一个蒟蒻不知道怎么想出来的一个愚蠢的算法，只用了 fhq treap 和简化版（我干的）的珂朵莉树

---

对于这个题，我们通过~~查看标签~~分析题目，可以大致猜到是要用平衡树解决问题，所以我们可以朝那个方向去思考这个问题。

首先，对于编号的修改，我们不难想到可以用 unordered_map 或 map 进行映射，将每次修改后的编号映射给最原始的编号，这样就方便我们后续的操作。

然后，我们注意到编号的总数量很大，数据范围是 $1 \le n \le 10^8$，如果直接按一般写法一个节点存一个点的信息绝对 MLE，但是我们又注意到操作数不多，最多只有 $10^5$，似乎整好是个用来建树的好数字，所以我们平衡树上的每个节点存的是一个区间的信息，每次对单个节点操作需要对节点进行分裂，这个后续再说。

还有一个问题，就是对于一个 treap（我只会 fhq treap），必须有一个 $key$ 值（好像大部分人喜欢叫 $val$，但是我就是爱叫他 $key$）使左儿子的 $key$ 小于父节点的 $key$ 小于右儿子的 $key$，这个在这道题里面稍微有些麻烦。但是如果我们先按开 $n$ 个点的方式思考，就简单很多。

我想到了这个思路：把一开始的第 $i$ 个点的 $key$ 赋值为 $i$，然后如果加到序列的前或后，就改成比序列最左侧的节点的 $key$ 值小的一个数，反之亦然。然后换成区间的思路，初始的平衡树只有一个节点，表示的是区间 $1 \to n$，然后对于每次需要查询或修改的序号 $x$ 我们先找到 $x$ 所在的区间所对应的节点 $u$，然后将区间分裂成最多 $3$ 段新的区间：中间区间的范围必定是 $x \to x$，$key$ 值又操作种类和当前序列的最左右节点 $key$ 值决定；$x$ 左边和右边区间的 $key$ 值为了满足平衡树的性质，可以选取原先树上比 $u$ 的 $key$ 值小的最大的 $key$ 值到比 $u$ 的 $key$ 值大的最小的 $key$ 值之间的两个数，当然要左边比右边小。为了方便我直接 $4$ 等分了来（所以为了防止掉精度我开了 `long double`）。

然后这个地方我们又遇到一个小问题，就是区间分裂和赋值，这个操作完美的体现了珂朵莉的优势，啊，不是，珂朵莉树的优势，珂朵莉树里面存的就是平衡树里面所有的区间（当然，为了方便，还是加了 $-INF$ 和 $INF$ 作为边界）。而且为了让平衡树和珂朵莉树同步修改，不得不省略了珂朵莉树的 `split` 操作，需要在修改平衡树的时候同步往珂朵莉树里面加区间。

顺便提一句，对于最后一个操作就普通的根据排名找值找到那个区间然后计算一下这个答案在区间内的位置就好了。

ps. 由于我平衡树学的不是很好，所以写的代码**比较**长，请谅解

```cpp
#include<bits/stdc++.h>
#include<ext/rope>
using namespace std;
using namespace __gnu_cxx;
typedef long long lol;
typedef long double dod;
typedef pair<int, int> pii;
typedef unsigned int uin;

struct element 
{
    int l, r; dod key;
    element (int l, int r = 0, dod key = 0) : l(l), r(r), key(key) {}
    bool operator < (const element &x) const { return l < x.l;}
};
typedef set<element>::iterator SIT;
set<element> sec;
// 珂朵莉树：找到对应某坐标所在的区间
SIT query (int x) 
{
    SIT it = sec.lower_bound (element (x));
    if (it != sec.end () && it -> l == x) return it;
    it -- ;
    return it;
}

const int N = 5e5 + 5;
const dod MAXN = 1e12, MINN = -1e12;
struct node 
{
    int l, r, ll, rr, len, sz, rnd_val;
    dod key;
} tr[N];
int root, idx;
mt19937 rnd(time(0));
int new_node (int l, int r, dod x) { tr[ ++ idx ] = {0, 0, l, r, r - l + 1, r - l + 1, rand(), x}; return idx; }
void push_up (int u) { tr[u].sz = tr[tr[u].l].sz + tr[tr[u].r].sz + tr[u].len; }

// 平衡树：按 key 只值分裂
void split (int u, dod x, int &lft, int &rht) 
{
    if (!u) lft = rht = 0;
    else if (tr[u].key < x) 
    {
        lft = u;
        split (tr[u].r, x, tr[u].r, rht);
        push_up (u);
    }
    else 
    {
        rht = u;
        split (tr[u].l, x, lft, tr[u].l);
        push_up (u);
    }
}

// 分裂出改树的最左边（key 值最小）的节点
void split_lft (int u, int &lft, int &rht) 
{
	if (!u) lft = rht = 0;
	if (tr[u].l) 
	{
		rht = u;
		split_lft (tr[u].l, lft, tr[u].l);
		push_up (u);
	}
	else
	{
		lft = u;
		rht = tr[u].r;
		tr[u].r = 0;
		push_up (u);
	}
}

// 平衡树：合并操作
int merge (int lft, int rht) 
{
    if (!lft || !rht) return lft | rht;
    if (tr[lft].rnd_val <= tr[rht].rnd_val) 
    {
        tr[lft].r = merge (tr[lft].r, rht);
        push_up (lft);
        return lft;
    }
    else 
    {
        tr[rht].l = merge (lft, tr[rht].l);
        push_up (rht);
        return rht;
    }
}

// 平衡树：按值找排名（操作 1）
int rank_of (int x) 
{
    SIT it = query (x);
    int lft = 0, rht = 0;
    split (root, it -> key, lft, rht);
    int t = tr[lft].sz + x - it -> l + 1;
    root = merge (lft, rht);

    return t;
}

// 平衡树：按排名找对应的节点
int key_of (int u, int k) 
{
    while (k) 
    {
        if (k <= tr[tr[u].l].sz) 
            u = tr[u].l;
        else if (k <= tr[tr[u].l].sz + tr[u].len) 
            break;
        else 
            k -= tr[tr[u].l].sz + tr[u].len, 
            u = tr[u].r;
    }
    return u;
}

// pull 是对节点进行排名的修改
// inv = true 表示移到最前面
// inv = false 表示移到最后面
int pull (int x, bool inv) 
{
    SIT it = query (x);
    int lft = 0, rht = 0, mid = 0;
    split (root, it -> key, lft, rht);
    int ret = tr[lft].sz + x - it -> l + 1;
    split_lft (rht, mid, rht);

    int l = it -> l, r = it -> r; dod val = it -> key;
    dod lval = MINN, rval = MAXN;
    sec.erase (it);
    if (tr[lft].sz) lval = tr[key_of (lft, tr[lft].sz)].key;
    if (tr[rht].sz) rval = tr[key_of (rht, 1)].key;
    lval = (lval + val) / 2, rval = (rval + val) / 2;
    
    if (l != x) 
        lft = merge (lft, new_node (l, x - 1, lval)), 
        sec.insert (element (l, x - 1, lval));
    if (r != x) 
        rht = merge (new_node (x + 1, r, rval), rht), 
        sec.insert (element (x + 1, r, rval));
    // 注意要在这个地方先合并一下，否则后面不好处理
    root = merge (lft, rht);
    
    if (inv) 
        val = tr[key_of (root, 1)].key - 100;
    else 
        val = tr[key_of (root, tr[root].sz)].key + 100;
    mid = new_node (x, x, val);
    sec.insert (element (x, x, val));

    if (inv) root = merge (mid, root);
    else root = merge (root, mid);

    return ret;
}

int n, T;
unordered_map<int, int> id, rev_id;

int main () {
    freopen ("in.txt", "r", stdin);
    freopen ("out.txt", "w", stdout);

    scanf ("%d%d", &n, &T);
    root = new_node (1, n, 0);
    sec.insert (element (0, 0, MINN));
    sec.insert (element (1, n, 0));
    sec.insert (element (n + 1, n + 1, MAXN));

    int lst = 0;
    while (T -- ) 
    {
        int opt, x;
        scanf ("%d%d", &opt, &x), x -= lst;
        // 这个地方在映射编号的时候要注意存不存在
        if (opt == 1) 
        {
            int y; scanf ("%d", &y), y -= lst;
            if (rev_id.find (x) != rev_id.end ()) 
            {
                int t = x;
                x = rev_id[x];
                rev_id.erase (t);
            }
            id[x] = y; rev_id[y] = x;
            lst = rank_of (x);
        }
        else if (opt == 2) 
        {
            if (rev_id.find (x) != rev_id.end()) x = rev_id[x];
            lst = pull (x, true);
        }
        else if (opt == 3) 
        {
            if (rev_id.find (x) != rev_id.end()) x = rev_id[x];
            lst = pull (x, false);
        }
        else 
        {
            int u = key_of (root, x), lft = 0, rht = 0;
            split (root, tr[u].key, lft, rht);
            lst = tr[u].ll + x - tr[lft].sz - 1;
            if (id.find (lst) != id.end()) lst = id [lst];
            root = merge (lft, rht);
        }
        printf ("%d\n", lst);
    }

    return 0;
}
```


---

## 作者：Owen_codeisking (赞：2)

这题其实跟 $[ZJOI2006]$ 书架有点像，但这题 $n\leq 10^8$，那么开三倍树状数组就水不掉这题了。所以我们考虑非平衡树的做法——动态开点线段树

动态开点线段树的精髓在于每次操作 $\log n$ 的空间。所以我们考虑对于每一个操作，若该区间未被开出来，我们手动开出那个点并且计算 $sum$，即区间的元素个数，可以由 $len(l,r)=max(0,min(r,n)-max(l,1)+1)$ 用 $O(1)$ 得到

```cpp
#define len(l,r) (max(0,min(r,n)-max(l,1)+1))
if(!now){
	now=++cnt;
	sum[now]=len(l,r);
}
```

我们对于没开出来的左儿子也要计算出 $sum$

```cpp
int mid=(l+r)>>1,k=L[now]?sum[L[now]]:len(l,mid);
```

当然，在 $query$ 的时候要记录下当前的编号，若 $l=r$ 的时候空间未被开出来，那么 $val[now]=l$

```cpp
if(!now){
	now=++cnt;
	sum[now]=len(l,r);
	if(l == r) val[now]=l;
}
```

这就是大致要点了。

操作 $1:$ 单点修改编号

操作 $2:$ 将原来的编号撤销掉，放到最前面

操作 $3:$ 将原来的编号撤销掉，放到最后面

操作 $4:$ 直接查询第 $k$ 大编号

还有注意的点：

1、编号超级大，所以考虑开一个 $map$ 记录

2、$map.count(x)$ 和 $map[x]$ 是不同的，$map.count(x)$ 是只要这个值修改过就为 $1$，否则为 $0$。而 $map[x]$ 直接返回值。所以若人工设定 $map[x]=0$，$map.count(x)$ 和 $map[x]$ 返回的值前者为 $1$，后者为 $0$。

时间复杂度 $O(m\log n)$，空间复杂度 $O(m\log n)$。由于操作 $2,3$ 一次操作开出来的是 $2\log n$ 的空间，所以空间开在 $60$ 倍左右不会被卡。

$Code\ Below:$

```cpp
#include <bits/stdc++.h>
#define len(l,r) (max(0,min(r,n)-max(l,1)+1))
using namespace std;
const int maxn=100000+10;
int n,m,rt,L[maxn*60],R[maxn*60],sum[maxn*60],val[maxn*60],cnt;
map<int,int> mp;

inline int read(){
	register int x=0,f=1;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}
	while(isdigit(ch)){x=(x<<3)+(x<<1)+ch-'0';ch=getchar();}
	return (f==1)?x:-x;
}

int modify(int &now,int l,int r,int x,int id){
	if(!now){
		now=++cnt;
		sum[now]=len(l,r);
	}
	if(l == r){
		val[now]=id;
		return 0;
	}
	int mid=(l+r)>>1,k=L[now]?sum[L[now]]:len(l,mid);
	if(x <= mid) return modify(L[now],l,mid,x,id);
	return k+modify(R[now],mid+1,r,x,id);
}

int update(int &now,int l,int r,int x,int v,int id){
	if(!now){
		now=++cnt;
		sum[now]=len(l,r);
	}
	sum[now]+=v;
	if(l == r){
		val[now]=id;
		return 0;
	}
	int mid=(l+r)>>1,k=L[now]?sum[L[now]]:len(l,mid);
	if(x <= mid) return update(L[now],l,mid,x,v,id);
	return k+update(R[now],mid+1,r,x,v,id);
}

int query(int &now,int l,int r,int x){
	if(!now){
		now=++cnt;
		sum[now]=len(l,r);
		if(l == r) val[now]=l;
	}
	if(l == r) return val[now];
	int mid=(l+r)>>1,k=L[now]?sum[L[now]]:len(l,mid);
	if(x <= k) return query(L[now],l,mid,x);
	return query(R[now],mid+1,r,x-k);
}

int main()
{
	n=read(),m=read();
	int op,x,y,Le=1,Ri=n,lastans=0;
	for(int i=1;i<=m;i++){
		op=read(),x=read()-lastans;
		if(op==1){
			y=read()-lastans;mp[y]=mp[x]?mp[x]:x;
			printf("%d\n",lastans=1+modify(rt,-m,n+m,mp[y],y));
		}
		if(op==2){
			printf("%d\n",lastans=1+update(rt,-m,n+m,mp[x]?mp[x]:x,-1,-1));
			update(rt,-m,n+m,mp[x]=--Le,1,x);
		}
		if(op==3){
			printf("%d\n",lastans=1+update(rt,-m,n+m,mp[x]?mp[x]:x,-1,-1));
			update(rt,-m,n+m,mp[x]=++Ri,1,x);
		}
		if(op==4){
			printf("%d\n",lastans=query(rt,-m,n+m,x));
		}
	}
	return 0;
}
```

---

## 作者：kczno1 (赞：2)

考虑将所有用户分成3类

原本的1->n，被提前的，被拉后的

对2,3类都开个平衡树

记录每个用户属于哪一类，以及对应的平衡树中的节点编号

平衡树也反过来记录节点对应的用户编号

这样如果在2,3类查询rank,k大就ok了

如果在1类查询rank,k大

因为节点个数是O(n)的，所以不能直接维护

所以对不在1类的点用平衡树维护


O(mlogm)

在实现中，2,3类我直接用线段树维护了

```cpp
#include<bits/stdc++.h>
using namespace std;

#define rep(i,l,r) for(int i=l;i<=r;++i)
int lastans;
#define gc (c=getchar())
int read()
{
    char c;
    while(gc<'0'); 
    int x=c-'0';
    while(gc>='0')x=x*10+c-'0';
    return x;
}
int r()
{
#ifdef ONLINE_JUDGE
    return read()-lastans;
#else
    return read();
#endif
}

const int N=1e5+5;
int n,m,d;
struct SET
{
int a[N*3],id[N],n;
int insert(int _id)
{
    ++n;
    id[n]=_id;
    int i=n+d;
    a[i]=1;
    while(i>>=1)++a[i];
    return n;
}
void del(int i)
{
    i+=d;
    a[i]=0;
    while(i>>=1)--a[i];
}
int rank(int i)
{
    i+=d;
    int ans=a[i];
    while(i)
    {
        if(i&1)ans+=a[i-1];
        i>>=1;
    }
    return ans;
}
int find_by_rank(int x)
{
    int i=1;
    while(i<=d)
    {
        if(x<=a[i*2])i*=2;
        else 
        {
            x-=a[i*2];i=i*2+1;
        }
    }
    return id[i-d];    
}
};
SET pre,suf;

struct SPLAY
{
#define cl(x) c[x][0]
#define cr(x) c[x][1]
int fa[N],c[N][2],sz[N];
int v[N],n,rt;
int rank(int x)
{
    int ans=x;
    int i=rt;
    while(i)
    if(v[i]>x)i=cl(i);
    else 
    {
        ans-=sz[cl(i)]+1;
        i=cr(i);
    }
    return ans;
}
void sc(int y,int x,bool d)
{
    fa[x]=y;c[y][d]=x;
}
bool get(int x)
{
    return x==c[fa[x]][1];
}
void up(int x)
{
    sz[x]=sz[cl(x)]+sz[cr(x)]+1;
}
void rot(int x)
{
    int y=fa[x];bool d=get(x);
    if(y==rt)fa[rt=x]=0;
    else sc(fa[y],x,get(y));
    sc(y,c[x][!d],d);
    sc(x,y,!d);
    up(y);
}
void splay(int x,int to=0)
{
    int y;
    while(y=fa[x],y!=to)
    {
        if(fa[y]==to){rot(x);break;}
        rot(get(x)==get(y)?y:x);rot(x);
    }
    up(x);
}
void insert(int x)
{
    ++n;
    v[n]=x;sz[n]=1;
    if(!rt)
    {
        rt=n;return ;
    }
    int i=rt;
    while(1)
    {
        bool d=v[i]<x;
        if(c[i][d]) i=c[i][d];
        else 
        {
            sc(i,n,d);
            splay(n);
            return ;
        }
    }
}
map<int,int>dy;
int DY(int x)
{
    if(!dy.count(x))return x;
    return dy[x];
}
int find_by_rank(int x)
{
    if(!rt)return DY(x);
    int i=rt,i0=0,rk=1;
    while(i)
    {
        i0=i;
        if(x>v[i]-(sz[cl(i)]+rk)) 
        {
            rk+=sz[cl(i)]+1;
            i=c[i][1];
        }
        else i=c[i][0];
    }
    splay(i0);
    return DY(x+rk-1);
}
}out;

const int PRE=1,SUF=2;
struct point
{
    int in,id;
};
map<int,point>belong;//i de wei zhi  
point &B(int x)
{
    if(!belong.count(x))belong[x]=(point){0,x};
    return belong[x];
}
int rk(int x)
{
    if(B(x).in==1)
    {
        return pre.a[1]+1 - pre.rank(B(x).id);
    }
    if(B(x).in==2)
    {
        return n-suf.a[1]+suf.rank(B(x).id);
    }
    return pre.a[1]+out.rank(B(x).id);
}
int find_by_rank(int x)
{
    if(x<=pre.a[1]) return pre.find_by_rank(pre.a[1]-x+1);
    if(x>n-suf.a[1]) return suf.find_by_rank(x-(n-suf.a[1]));
    return out.find_by_rank(x-pre.a[1]);
}

int main()
{
    //freopen("1.in","r",stdin);
    //freopen("1.out","w",stdout);
    n=read();m=read();
    for(d=1;d<m;d<<=1);d-=1;
    lastans=0;
    while(m--)
    {
        int type=read(),x=r(),ans;
        if(type==4)
        {
            ans=find_by_rank(x);
        }
        else 
        {
            ans=rk(x);
            if(type==1)
            {
                int y=r();
                B(y)=B(x);
                if(B(x).in) (B(x).in==PRE?pre:suf).id[B(x).id]=y;    
                else out.dy[B(x).id]=y;
            }
            else
            {
                if(B(x).in==0) out.insert(B(x).id);
                else 
                (B(x).in==PRE?pre:suf).del(B(x).id);    
                if(type==2) B(x)=(point){PRE,pre.insert(x)};
                else B(x)=(point){SUF,suf.insert(x)};
            }
        }

        printf("%d\n",lastans=ans);
    }
}    

```

---

## 作者：程就未来 (赞：2)

这道题足足调了我一晚上

乍一看这道题思路很简单，但是细节很难写。

首先标算肯定是用一棵以排名为关键字的平衡树，一棵以编号为关键字的平衡树（这颗平衡树何以用map代替）。

### 操作一
在map中找到对应编号在平衡树中的节点，修改编号，计算答案

具体可以在改变编号时记录新编号在平衡树中那个节点

用map.lower_bound(x)->second查询

修改时不必删除原来编号的映射


### 操作二 & 操作三（两种方法）
#### 1. 在map中找到对应编号在平衡树中的节点，删除，再插入到最前（后）
#### 2. 这种方法适用于splay：在map中找到对应编号在平衡树中的节点。把左子树变成这个节点的后继的左子树（把右子树变成这个节点的前驱的右子树）

### 操作四
暴力查询排名即可

这道题有一个坑点：n <= 1e8 ，但是m<=1e5 ，所以我们可以把多个编号连续的节点压缩为一个，记录这个节点的l、r（表示这个节点表示最小和最大的编号），当操作需要用到的时候再分裂（split）开。

### 关于分裂（split）操作
1.分裂操作需要分类讨论，若分出的节点在左端点上，就分裂为（l[rt],l[rt]）,(l[rt]+1,r[rt])

2.若分出的节点在右端点上，就分裂为(l[rt],r[rt]-1),(r[rt],r[rt])

3.否则分裂为(l[rt],mid-1),(mid,mid),(mid+1,r[rt]-1)

(ps:别忘记pushup了)
```cpp
void connect(int f , int son , int d) {ch[f][d] = son; par[son] = f;}

int split(int rt , int mid) {
	if(l[rt] == r[rt]) return rt;//如果只有一个就不必分裂
	int prel = ch[rt][0] , prer = ch[rt][1];
	if(mid == l[rt]) {//第一种情况
		connect(rt , New(l[rt] , l[rt]) , 0);//connect是连边
		connect(ch[rt][0] , prel , 0); 
		l[rt] = mid + 1; 
		pushup(ch[rt][0]); pushup(rt);
		return ch[rt][0];
	} else if(mid == r[rt]) {//第二种情况
		mp[mid - 1] = rt; 
		connect(rt , New(r[rt] , r[rt]) , 1);
		connect(ch[rt][1] , prer , 1);
		r[rt] = mid - 1; 
		pushup(ch[rt][1]); pushup(rt);
		return ch[rt][1];
	} else {//第三种情况
		mp[mid] = rt;
		connect(rt , New(l[rt] , mid - 1) , 0);
		connect(rt , New(mid + 1 , r[rt]) , 1);
		connect(ch[rt][0] , prel , 0);
		connect(ch[rt][1] , prer , 1);
		r[rt] = l[rt] = mid; 
		pushup(ch[rt][0]) , pushup(ch[rt][1]) , pushup(rt);
		return rt;
	}
}

```

多了这个split操作，查询排名的时候大部分不变，先查出它在那个节点，不过还要记录它在这个节点的第几个位置（rank）。
```cpp
int kth(int &x) {//引用可以记录它在第几个位置（rank）
	int rt = root;
	while(1) {
		if(x <= size[ch[rt][0]]) rt = ch[rt][0];
		else if(x > size[ch[rt][0]] + r[rt] - l[rt] + 1) {
			x = x - (size[ch[rt][0]] + r[rt] - l[rt] + 1);
			rt = ch[rt][1];
		} else {
			x -= size[ch[rt][0]];//细节，找到这个节点后更新它的rank
			return rt;
		} 
	}
}
int query(int x) {//操作四
	int rt = kth(x);
	return l[rt] + x - 1;
} 
```
最后上AC代码，splay实现的
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 1e6 + 5 , INF = 1e9;

int n , m , last = 0;

map<int , int> mp;//map

inline int read() {//快读不解释
	int s = 0 ,w = 1; char ch = getchar();
	while(ch < 48 || ch > 57) {if(ch == '-') w = -1; ch = getchar();}
	while(ch >= 48 && ch <= 57) s = (s << 1) + (s << 3) + (ch ^ 48) , ch = getchar();
	return s * w;
}

struct Splay { // 以排名为关键字 , l，r表示编号连续的r-l+1
	int ch[N][2] , par[N] , size[N] , l[N] , r[N]  , tot , root;
	//par是父指针，tot是节点总数
	int chk(int rt) {return ch[par[rt]][1] == rt;}
	
	void pushup(int rt) {size[rt] = size[ch[rt][0]] + size[ch[rt][1]] + r[rt] - l[rt] + 1;}
	
	void rotate(int rt) {
		int f = par[rt] , gf = par[f] , d = chk(rt) , son = ch[rt][d ^ 1];
		ch[f][d] = son; par[son] = f;
		ch[gf][chk(f)] = rt; par[rt] = gf;
		ch[rt][d ^ 1] = f; par[f] = rt;
		pushup(f) , pushup(rt);
	}
	
	void splay(int rt , int goal = 0) {//splay的基本操作
		while(par[rt] != goal) {
			int f = par[rt] , gf = par[f];
			if(gf != goal) {
				if(chk(rt) == chk(f)) rotate(f);
				else rotate(rt);
			} rotate(rt);
		} if(!goal) root = rt;
	}
	
	int New(int L , int R) {//新建节点
		int rt = ++tot;
		par[rt] = ch[rt][0] = ch[rt][1] = 0;
		size[rt] = R - L + 1;
		l[rt] = L ; r[rt] = R;
		mp[R] = rt;
		return rt;
	} 
	
	void connect(int p , int son , int d) {ch[p][d] = son; par[son] = p;}
	
	int split(int rt , int mid) {//分裂操作
		if(l[rt] == r[rt]) return rt;
		int prel = ch[rt][0] , prer = ch[rt][1];
		if(mid == l[rt]) {
			connect(rt , New(l[rt] , l[rt]) , 0);
			connect(ch[rt][0] , prel , 0); 
			l[rt] = mid + 1; 
			pushup(ch[rt][0]); pushup(rt);
			return ch[rt][0];
		} else if(mid == r[rt]) {
			mp[mid - 1] = rt; 
			connect(rt , New(r[rt] , r[rt]) , 1);
			connect(ch[rt][1] , prer , 1);
			r[rt] = mid - 1; 
			pushup(ch[rt][1]); pushup(rt);
			return ch[rt][1];
		} else {
			mp[mid] = rt;
			connect(rt , New(l[rt] , mid - 1) , 0);
			connect(rt , New(mid + 1 , r[rt]) , 1);
			connect(ch[rt][0] , prel , 0);
			connect(ch[rt][1] , prer , 1);
			r[rt] = l[rt] = mid; 
			pushup(ch[rt][0]) , pushup(ch[rt][1]) , pushup(rt);
			return rt;
		}
	}
	
	int kth(int &x) {
		int rt = root;
		while(1) {
			if(x <= size[ch[rt][0]]) rt = ch[rt][0];
			else if(x > size[ch[rt][0]] + r[rt] - l[rt] + 1) {
				x = x - (size[ch[rt][0]] + r[rt] - l[rt] + 1);
				rt = ch[rt][1];
			} else {
				x -= size[ch[rt][0]];
				return rt;
			} 
		}
	}
	
	int prev(int rt) {
		if(!ch[rt][0]) return rt;
		rt = ch[rt][0];
		while(ch[rt][1]) rt = ch[rt][1];
		return rt;
	}
	
	int succ(int rt) {
		if(!ch[rt][1]) return rt;
		rt = ch[rt][1];
		while(ch[rt][0]) rt = ch[rt][0];
		return rt;
	}
	
	int change(int x , int y) {//操作一
		int rt = mp.lower_bound(x) -> second;
		rt = split(rt , x); 
		l[rt] = r[rt] = y;
		mp[y] = rt;
		splay(rt);
		return size[rt] - size[ch[rt][1]];
	}
	
	int top(int x) {//操作二
		int rt = mp.lower_bound(x) -> second;
		rt = split(rt , x);
		splay(rt);
		int ans = size[rt] - size[ch[rt][1]];
		int nxt = succ(rt);
		if(!ch[rt][0]) return ans;
		if(!ch[rt][1]) {
			connect(rt , ch[rt][0] , 1);
			ch[rt][0] = 0; pushup(rt); return ans;
		}
		splay(nxt , rt);
		connect(nxt , ch[rt][0] , 0);
		ch[rt][0] = 0;
		pushup(nxt) , pushup(rt);
		return ans;
	}
	
	int bottom(int x) {//操作三
		int rt = mp.lower_bound(x) -> second;
		rt = split(rt , x);
		splay(rt);
		int ans = size[rt] - size[ch[rt][1]];
		int pre = prev(rt);
		if(!ch[rt][1]) return ans;
		if(!ch[rt][0]) {
			connect(rt , ch[rt][1] , 0);
			ch[rt][1] = 0; pushup(rt); return ans;
		}
		splay(pre , rt);
		connect(pre , ch[rt][1] , 1);
		ch[rt][1] = 0;
		pushup(pre) , pushup(rt);
		return ans;
	}
	
	int query(int x) {//操作四
		int rt = kth(x);
		return l[rt] + x - 1;
	} 	
	
	void init() {
		mp.clear();
		root = New(1 , n);
	}
} T;
int main() {
	n = read() ; m = read();
	T.init();
	while(m -- ) {
		int opt = read() , x = read() , y;
		x -= last;
		if(opt == 1) {
			y = read(); y -= last;
			last = T.change(x , y);		
		} else if(opt == 2) last = T.top(x);
		else if(opt == 3) last = T.bottom(x);
		else last = T.query(x);
		printf("%d\n",last);
	}
	return 0;
}

```


---

## 作者：GoldenPotato137 (赞：2)

[戳我获得更好的阅读体验qwq](https://www.goldenpotato.cn/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/luogu-p3285scoi2014%E6%96%B9%E4%BC%AF%E4%BC%AF%E7%9A%84oj/)

---
# Solution
这是一道数据结构大暴力题。

我们可以很显然的发现对于询问排名，**维护排名的操作，我们可以直接上一个维护下标的splay**。

因为点的数量奇多，这让我们回想起NOIP2017 列队，**我们可以用“splay 动态开点”这样的操作来解决**，即一开始我们把所有信息全部压到一个点里面去（即一个点代表一段区间），需要的时候再用“拆点”把点拆开。

问题是这破题很让人讨厌地出了两个基于编号的操作。因为我们的splay是以下标做为权值来的，失去了维护编号的能力。

怎么办呢？我们可以考虑直接记录每个编号的点在splay中的下标。很不幸的是，这里的点的编号十分巨大，没法直接开桶来存。

但是，因为我们splay维护的是一个一个区间，我们可以考虑**开一颗动态开点的线段树，然后在拆点/改编号的时候暴力区间维护一下即可。**

时间复杂度$O(mlogn)$

就酱，这题我们就切掉啦٩(๑>◡<๑)۶ 

---
# Code
```cpp
//Luogu P3285 [SCOI2014]方伯伯的OJ
//Mar,11th,2019
//动态开点splay+动态开点线段树鬼畜题
#include<iostream>
#include<cstdio>
using namespace std;
long long read()
{
	long long x=0,f=1; char c=getchar();
	while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
	while(isdigit(c)){x=x*10+c-'0';c=getchar();}
	return x*f;
}
const int N=100000*2+100;
const int M=200000000;
struct SegmentTree
{
	#define mid ((now_l+now_r)>>1)
	int son[N*20][2],w[N*20],to;
	void Change(int l,int r,int num,int now,int now_l,int now_r)
	{
		if(now_l>=l and now_r<=r)
		{
			w[now]=num;
			return;
		}
		if(l<=mid)
		{
			if(son[now][0]==0) son[now][0]=++to,w[to]=w[now];
			Change(l,r,num,son[now][0],now_l,mid);
		}
		if(r>mid)
		{
			if(son[now][1]==0) son[now][1]=++to,w[to]=w[now];
			Change(l,r,num,son[now][1],mid+1,now_r);
		}
	}
	int Query(int x,int now,int now_l,int now_r)
	{
		if(now_l==now_r) return w[now];
		if(x<=mid)
		{
			if(son[now][0]==0) return w[now];
			else return Query(x,son[now][0],now_l,mid);
		}
		else
		{
			if(son[now][1]==0) return w[now];
			else return Query(x,son[now][1],mid+1,now_r);
		}
	}
	#undef mid
}sgt;//编号->下标
struct SPLAY
{
	#define root son[0][1]
	int son[N][2],fa[N],cnt[N],no[N],size[N],to;
	inline void update(int x)
	{
		size[x]=size[son[x][0]]+size[son[x][1]]+cnt[x];
	}
	inline void rotate(int x,int type)
	{
		int y=fa[x],z=fa[y];
		fa[x]=z,son[z][y==son[z][1]]=x;
		fa[son[x][type]]=y,son[y][!type]=son[x][type];
		fa[y]=x,son[x][type]=y;
		update(y),update(x);
	}
	void splay(int x,int to)
	{
		while(fa[x]!=to)
		{
			if(fa[fa[x]]!=to and x==son[fa[x]][fa[x]==son[fa[fa[x]]][1]])
				rotate(fa[x],x==son[fa[x]][0]);
			rotate(x,x==son[fa[x]][0]);
		}
	}
	void split(int x,int K)//传入下标
	{
		splay(x,0);
		int t1=son[x][0],t2=son[x][1];
		while(son[t1][1]!=0) t1=son[t1][1];
		while(son[t2][0]!=0) t2=son[t2][0];
		splay(t1,0);
		splay(t2,root);
			
		if(K!=1)
		{
			son[x][0]=++to,fa[to]=x;
			no[to]=no[x],size[to]=cnt[to]=K-1;
			sgt.Change(no[to],no[to]+cnt[to]-1,to,1,1,M);
		}
		if(K!=cnt[x])
		{
			son[x][1]=++to,fa[to]=x;
			no[to]=no[x]+K,size[to]=cnt[to]=cnt[x]-K;
			sgt.Change(no[to],no[to]+cnt[to]-1,to,1,1,M);
		}
		no[x]=no[x]+K-1,cnt[x]=1;
	}
	int GetKth(int x,int K)//返回下标
	{
		if(size[son[x][0]]>=K) 
			return GetKth(son[x][0],K);
		K-=size[son[x][0]];
		if(K<=cnt[x])
		{
			if(cnt[x]==1)
			{
				splay(x,0);
				return x;
			}
			split(x,K);
			splay(x,0);
			return x;
		}
		K-=cnt[x];
		return GetKth(son[x][1],K);
	}
	int Change(int x,bool type)//传入编号
	{
		int t=sgt.Query(x,1,1,M),ans;
		splay(t,0);
		ans=size[son[t][0]]+x-no[t]+1;
		split(t,x-no[t]+1);
		if(son[t][0]!=0 or son[t][1]!=0)
			split(t,1);
		if(type==0)
		{
			son[fa[t]][t==son[fa[t]][1]]=0;
			update(fa[t]);
			splay(1,0);
			int now=son[root][1];
			while(son[now][0]!=0) now=son[now][0];
			son[now][0]=t,fa[t]=now;
			update(now),splay(now,0);
		}
		else
		{
			son[fa[t]][t==son[fa[t]][1]]=0;
			update(fa[t]);
			splay(3,0);
			int now=son[root][0];
			while(son[now][1]!=0) now=son[now][1];
			son[now][1]=t,fa[t]=now;
			update(now),splay(now,0);
		}
		return ans;
	}
	int Change2(int x,int y)//传入编号
	{
		int t=sgt.Query(x,1,1,M);
		split(t,x-no[t]+1);
		sgt.Change(y,y,t,1,1,M);
		no[t]=y;
		splay(t,0);
		return size[son[t][0]]+1;
	}
	int Query(int K)
	{
		return no[GetKth(root,K)];
	}
	void Init(int n)
	{
		root=++to,fa[root]=0;
		son[root][1]=++to,fa[to]=root,cnt[to]=size[to]=n,no[to]=1;
		sgt.to=1;
		sgt.Change(1,n,to,1,1,M);
		son[to][1]=to+1,fa[to+1]=to,to++;
		update(to),update(to-1),update(root);
	}
	void Print(int now)
	{
		if(now==0) return;
		Print(son[now][0]);
		cout<<"no:"<<now<<" ["<<no[now]<<","<<no[now]+cnt[now]-1<<"] "<<"size:"<<size[now]<<" cnt:"<<cnt[now]<<" sonl&r:"<<son[now][0]<<" "<<son[now][1]<<endl;
		Print(son[now][1]);
	}
	#undef root
}splay;
int n,m;
int main()
{
	n=read(),m=read();
	
	splay.Init(n);
	int ans=0;
	for(int i=1;i<=m;i++)
	{
		int op=read(),x=read()-ans;
		if(op==1)
		{
			int y=read()-ans;
			printf("%d\n",ans=splay.Change2(x,y));
		}
		else if(op==2)
			printf("%d\n",ans=splay.Change(x,0));
		else if(op==3)
			printf("%d\n",ans=splay.Change(x,1));
		else
			printf("%d\n",ans=splay.Query(x));
		//ans=0;//RTC
		//splay.Print(splay.son[0][1]);
		//cerr<<endl;
	}
	return 0;
}

```






---

## 作者：SSHhh (赞：2)

## 不想写 $Splay$ 的请看这里！

首先，先对楼上那位用线段树解决此题的dalao l_h_j致敬——因为这个思路我们是同时想到的，但他只用了一次就搞定了，我却写了足足两个晚上（最后还因为把 $20$ 写成 $27$ 调了一个小时）。。。

接下来就是题解了：(华丽的分割线)

---

在看这个做法之前，请各位神犇先略微参考一下2017年 $NOIP$ 的 $day2T3$ 列队。这道题的线段树做法涉及到两个操作：从一个序列中删除一个数 以及 给这个序列末尾添加一个数。这个操作拓展一下就变成了一个支持两边添加的线段树，就可以轻松解决2,3两个询问了。

这个其实非常好解决，只需要在线段树的左右两边各预留出一个长度为 $1e5$ 的空间，每次插入暴力把序列首位之前的一位或者序列末尾后面的一位+1即可。

询问1也没什么问题，只要用一个 $map$ (用id[i]表示) 存一下每一个编号被改成了什么以及每一个当前编号的原始编号即可。这样每一次询问就和编号修改基本无关了。

那么我们现在就剩下两个问题了：查询某人的排名 以及 查询某个排名的人。

查询某人的排名很简单，你只要用 $map$ 记录一下每一个编号的人在线段树里的位置，然后直接用线段树查询区间和即可。

但是查询某个排名的人怎么办呢？这个其实多想想也能得出做法：

因为线段树上每一个位置的值为非 0 及 1，所以我们直接二分这个人在线段树中的位置，然后判断当区间和为 $x$ 时，这个人所在的位置是否合法即可。我们只需要用一个 $map$(其实就是反着记录一下$id[i]$) 记录一下线段树上每一个位置上的值的编号，然后直接输出就行了。

最后一定要记住：$n$ 的范围是 $1e8$！二分得开到 $2^{27}$！（我就是在这里挂了一个小时 QwQ）

剩下不多说了，附上代码吧：

```cpp
#include<map>
#include<stdio.h>
#include<iostream>
#define lim 100000
#define N 20000005
#define M 100005
using namespace std;
int n,m,ans,cnt=1,sum[N],lazy[N],ls[N],rs[N];
map<int,int> id,lasid,pos,num,vispos,visnum,visid,vislasid;
void update(int i) {sum[i]=sum[ls[i]]+sum[rs[i]];}
void pushdown(int i,int l,int r)
{
	if(!lazy[i])	return;
	if(r-l<=0)	{lazy[i]=0; return;}
	int mid=(l+r)/2,v=lazy[i];
	if(!ls[i])	ls[i]=++cnt;
	if(!rs[i])	rs[i]=++cnt;
	sum[ls[i]]+=(mid-l+1)*v,sum[rs[i]]+=(r-mid)*v;
	lazy[ls[i]]+=v,lazy[rs[i]]+=v;
	lazy[i]=0;
}
void ins(int i,int l,int r,int L,int R,int v)
{
	if(!i)	return;
	pushdown(i,l,r);
	if(L<=l && r<=R) {sum[i]+=(r-l+1)*v,lazy[i]=v; return;}
	int mid=(l+r)/2;
	if(!ls[i])	ls[i]=++cnt;
	if(!rs[i])	rs[i]=++cnt;
	if(L<=mid)	ins(ls[i],l,mid,L,R,v);
	if(mid+1<=R)	ins(rs[i],mid+1,r,L,R,v);
	update(i);
}
int ques(int i,int l,int r,int L,int R)
{
	if(!i)	return 0;
	pushdown(i,l,r);
	if(L<=l && r<=R) {return sum[i];}
	int mid=(l+r)/2,ans=0;
	if(L<=mid)	ans+=ques(ls[i],l,mid,L,R);
	if(mid+1<=R)	ans+=ques(rs[i],mid+1,r,L,R);
	return ans;
}
int posi(int i) {return pos[i]?pos[i]:pos[i]=i;}
int numi(int i) {return num[i]?num[i]:num[i]=i;}
int idi(int i) {return id[i]?id[i]:id[i]=i-lim;}
int lasidi(int i) {return lasid[i]?lasid[i]:lasid[i]=i+lim;}
int main()
{
	int x,y,k;
	scanf("%d%d",&n,&m);
	int head=lim,tail=lim+n+1;
	for(int i=1;i<=m;i++)
	{
		scanf("%d%d",&k,&x);
		if(k==1)	scanf("%d",&y);
		x-=ans,y-=ans;
		int now=posi(lasidi(x));
		if(k==1)
		{
			id[lasidi(x)]=y,lasid[y]=lasidi(x);
			ans=now-head-ques(1,1,n+lim*2,head+1,now);
		}
		else if(k==2)
		{
			ans=now-head-ques(1,1,n+lim*2,head+1,now);
			ins(1,1,n+lim*2,now,now,1);
			pos[lasidi(x)]=head--,num[head+1]=lasidi(x);
		}
		else if(k==3)
		{
			ans=now-head-ques(1,1,n+lim*2,head+1,now);
			ins(1,1,n+lim*2,now,now,1);
			pos[lasidi(x)]=tail++,num[tail-1]=lasidi(x);
		}
		else
		{
			int las=head;
			for(int j=27;j>=0;j--)
				if(las+(1<<j)<tail && (las+(1<<j)-head-ques(1,1,n+lim*2,head+1,las+(1<<j)))<x)
					las+=(1<<j);
			ans=idi(numi(las+1));
		}
		printf("%d\n",ans);
	}
	return 0;
}

```



---

## 作者：吾王美如画 (赞：2)

# 唔姆
这么快乐的题怎么能少了我treap哒!
看这题还没有treap的题解我就来水一个

------------
我是先做了[P2596 [ZJOI2006]书架](https://www.luogu.org/problemnew/show/P2596)这题，看了这题我直接稍微改了一下就投了，全mle。。。。。

首先思路是一样的，都是用一个treap（splay）+map。treap以节点的序号为关键字进行排序（**不是编号**），而map是记录每个编号对应的序号。

但我们发现一个大大的问题，就是n<=10^8，显然我们不可能将每一个数都存进treap和map，存就直接mle，说不定还会tel。不过好在初始状态的编号就是1~n，所以我们先把这个1~n**当做一个整体的节点**，并同时记录每个节点的left和right，而且要对应修改num（每个节点上数的个数）。这样，等我们需要对**编号**为k的数进行修改时，只需把map[k]所在区间（a,b）删除，并重新建一个（a,map[k]-1）(map[k],map[k])和(map[k]+1,b)当然，如果a==b的话，直接进行修改就行了。

接下来对于每个操作

- 对于操作1，我们先把map[x]给拆出来，然后对应map[x]去查找排名（这是平衡树基本操作啦，只是要稍微改一点东西，大家可以看我程序里的rank函数）然后把对应的map[x]节点所记录的编号改成y。
- 对于操作2，我们要记录一个minn，即最小的序号，这时我们先查询对应节点的排名，然后再拆点，但我们这时要把map[x]改为--minn这样就是把这个数直接排在了第一个
- 对于操作3，和操作2是一样的，只需记录maxx，然后把map[x]=++maxx就行
- 对于操作4，连拆点都不用，就是平衡树标准操作，只是如果发现我们要的目标在一段区间里时，我们就输出left+（x-左子树的**数的个数**）-1

细节部分见代码啦~~码风毒瘤，我尽力了~~
```cpp
#include<cstdio>
#include<iostream>
#include<ctime>
#include<queue>
#include<string>
#include<cstring>
#include<cmath>
#include<map>
#define MAXN 2001000
#define INF 10000000
using namespace std;
int sum=0,R=0;
int n,m;
map<int,int>ma;
struct node{
       int son[2];
       int num;
       int size;
       int left;
       int right;
       int rd;
       int yuan;//这个节点所对应的编号
}tree[MAXN];
void up(int now){
     tree[now].size=tree[tree[now].son[0]].size+tree[tree[now].son[1]].size+tree[now].num;
}
void rotate(int &now,int d){
     int to=tree[now].son[!d];
     tree[now].son[!d]=tree[to].son[d];
     tree[to].son[d]=now;
     up(now);
     up(to);
     now=to;
}
void change(int &now,int x,int y,int z,int size){
     if (!now){now=++sum;tree[now].size=tree[now].num=size;tree[now].left=x;tree[now].right=y;tree[now].rd=rand();tree[now].yuan=z;return;}
     else if(tree[now].left==x){tree[now].num+=size;tree[now].size+=size;return;}; 
     int tmp=(x>tree[now].left);
     change(tree[now].son[tmp],x,y,z,size);
     if (tree[now].rd>tree[tree[now].son[tmp]].rd)rotate(now,!tmp);
     up(now);
}
void del(int &now,int x){
     if(!now)return;
     if (x==tree[now].left){
                       if(!tree[now].son[0]&&!tree[now].son[1]){
                                                      tree[now].num=0;tree[now].size=0;
                                                      if(!tree[now].num)now=0;
                       }
                       else if(tree[now].son[0]&&!tree[now].son[1]){
                                                          rotate(now,1);
                                                          del(tree[now].son[1],x);
                       }
                       else if(!tree[now].son[0]&&tree[now].son[1]){
                                                          rotate(now,0);
                                                          del(tree[now].son[0],x);
                       }
                       else {int tmp=(tree[tree[now].son[0]].rd>tree[tree[now].son[1]].rd);
                            rotate(now,tmp);
                            del(tree[now].son[tmp],x);
                       }
     }
     else{
          int tmp=(x>tree[now].left);
          del(tree[now].son[tmp],x);
     }
     up(now);
}
int rank(int now,int x){//按关键字查排名
    if (!now)return 0;
    if (tree[now].left<=x&&x<=tree[now].right)return x-tree[now].left+1+tree[tree[now].son[0]].size;
    if (tree[now].left<x) return tree[tree[now].son[0]].size+tree[now].num+rank(tree[now].son[1],x);
    if (tree[now].left>x) return rank(tree[now].son[0],x);
}
int find(int now,int x){//按排名查编号
    if(!now)return 0;
    if (tree[tree[now].son[0]].size>=x)return find(tree[now].son[0],x);
    else if (tree[tree[now].son[0]].size+tree[now].num>=x){
         if (tree[now].left==tree[now].right)return tree[now].yuan;
         else return tree[now].left+x-tree[tree[now].son[0]].size-1;
    }
    else return find(tree[now].son[1],x-tree[tree[now].son[0]].size-tree[now].num);
}
void search(int now,int x,int &left,int &right){
     if (!now)return;
     if (x>=tree[now].left&&x<=tree[now].right){left=tree[now].left;right=tree[now].right;return;}
     else if (x<tree[now].left)return search(tree[now].son[0],x,left,right);
     else return search(tree[now].son[1],x,left,right);
}
int main(){
    cin>>n>>m;
    int minn=1,maxx=n;
    memset(tree,0,sizeof(tree));
    change(R,1,n,1,n);
    int last=0;
    for(int i=1;i<=m;i++){
            int a,b,c;
            scanf("%d",&a);
            if (a==1){
                      scanf("%d%d",&b,&c);
                      b-=last;c-=last;
                      if (!ma.count(b))ma[b]=b;
                      int left,right;
                      search(R,ma[b],left,right);
                      ma[c]=ma[b];
                      del(R,left);
                      if (ma[b]>left)change(R,left,ma[b]-1,left,ma[b]-left);
                      if (ma[b]<right)change(R,ma[b]+1,right,ma[b]+1,right-ma[b]);
                      change(R,ma[b],ma[b],c,1);
                      last=rank(R,ma[b]);
                      printf("%d\n",last);
            }
            if (a==2){
                      scanf("%d",&b);
                      b-=last;
                      if (!ma.count(b))ma[b]=b;
                      last=rank(R,ma[b]);
                      int left,right;
                      search(R,ma[b],left,right);
                      del(R,left);
                      if (ma[b]>left)change(R,left,ma[b]-1,left,ma[b]-left);
                      if (ma[b]<right)change(R,ma[b]+1,right,ma[b]+1,right-ma[b]);
                      ma[b]=--minn;
                      change(R,ma[b],ma[b],b,1);
                      printf("%d\n",last);
            }
            if (a==3){
                      scanf("%d",&b);
                      b-=last;
                      if (!ma.count(b))ma[b]=b;
                      last=rank(R,ma[b]);
                      int left,right;
                      search(R,ma[b],left,right);
                      del(R,left);
                      if (ma[b]>left)change(R,left,ma[b]-1,left,ma[b]-left);
                      if (ma[b]<right)change(R,ma[b]+1,right,ma[b]+1,right-ma[b]);
                      ma[b]=++maxx;
                      change(R,ma[b],ma[b],b,1);
                      printf("%d\n",last);
            }
            if (a==4){
                      scanf("%d",&b);
                      b-=last;
                      if (!ma.count(b))ma[b]=b;
                      last=find(R,b);
                      printf("%d\n",last);
            }
    }
    return 0;
}

```

---

## 作者：lizexuanaibiancheng (赞：1)

想出了一种不同寻常的做法：

维护三棵平衡树，其中两棵维护已经明确被挪动到前 / 后的数，另一棵维护从中间区域明确挪走的数（可以理解为另外两棵树合起来）。明确挪动到前 / 后的数在树上按照顺序排序，从中间挪动走的数在树上按照值的大小排序。

我们首先不在树内改变编号，仍然记录的是 $[1 \dots n]$ 的值，在树外面对于编号特判（具体看代码中 ```Mp``` 与 ```Pm``` 的实现）。对于每一次询问位置求编号，询问编号求位置时，分情况讨论：

+ 在前面 / 后面，不用多说，平衡树模版。但是注意，根据编号求位置时需要先用一个 ```map``` 存储编号对应的树上节点，这样才能很快速的找到这个点。

+ 在中间：由于中间是存储被挪走的数，所以我们要用到一些类似于“逆推”的思想。询问位置求编号时，我们从根出发，如果答案在当前点左子树的“空隙”内，往左走，否则往右。维护在找答案的过程中左侧的点数，代表被删掉的个数。答案为左侧个数**加**要查询的位置（具体看 ```unfind``` 函数）；询问编号求位置时，先找到这个点如果该加入，应该加入哪里，然后也是维护左侧的点数，答案为要查询的编号**减**左侧个数（具体看 ```unget_k``` 函数）。

上代码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N = 2e8+10,M = 2e5+10;
int n,m;
unordered_map<int,int>Mp,Pm;// Mp[现在编号]=原来编号,Pm[原来编号]=现在编号 
unordered_map<int,bool>Front,Back;
struct Splay{
	int siz[M],ch[M][2],fa[M],len,num[M],root;
	unordered_map<int,int>mp;
	inline void pushup(int u){
		siz[u] = siz[ch[u][0]] + 1 + siz[ch[u][1]];
	}inline int newnode(int val){
		num[++len] = val;
		mp[val] = len;
		siz[len] = 1;ch[len][0] = ch[len][1] = fa[len] = 0;
		return len;
	}inline bool chk(int u){
		return (ch[fa[u]][1] == u);
	}inline void rotate(int u){
		int v = fa[u],w = fa[v];bool k = chk(u);
		fa[u] = w;
		if(w) ch[w][chk(v)] = u;
		if(ch[u][k^1]) fa[ch[u][k^1]] = v;
		ch[v][k] = ch[u][k^1];
		fa[v] = u;
		ch[u][k^1] = v;
		pushup(v);pushup(u);
	}inline void splay(int u,int x = 0){
		if(u == 0) return;
		for(int v = fa[u];(v = fa[u]) != x;rotate(u)){
			if(fa[v] != x) rotate(chk(u) == chk(v) ? v : u);
		}if(x == 0) root = u;
	}inline int get_k(int u,int k){
		if(siz[ch[u][0]]+1 == k) return u;
		if(siz[ch[u][0]]+1 > k) return get_k(ch[u][0],k);
		if(siz[ch[u][0]]+1 < k) return get_k(ch[u][1],k-siz[ch[u][0]]-1);
		return -1;
	}inline void insert_Hutao(int u,bool k){
		if(len == 1){
			root = u;
			return;
		}int x = root,y = 0;
		for(;x;y = x,x = ch[x][k]);
		fa[u] = y;ch[y][k] = u;
		splay(u);
	}inline void insert_Furina(int u){
		if(len == 1){
			root = u;
			return;
		}int x = root,y = 0;bool k = 0;
		for(;x;){
			y = x;
			if(num[u] <= num[x]) x = ch[x][0],k = 0;
			else x = ch[x][1],k = 1;
		}ch[y][k] = u;
		fa[u] = y;
		splay(u);
	}inline int unfind(int k){//返回在1~n中删除splay中节点后第k个是多少
		int x = root,y = 0,L = 0;
		for(;x;){
			y = x;
			if(num[x]-1-siz[ch[x][0]]-L >= k) x = ch[x][0];
			else L += siz[ch[x][0]]+1,x = ch[x][1];
		}splay(y);
		return k+L;
	}inline int unget_k(int p){//返回在1~n中删除splay中节点后p是第几个 
		int x = root,y = 0,L = 0;
		for(;x;){
			y = x;
			if(p <= num[x]) x = ch[x][0];
			else L += siz[ch[x][0]]+1,x = ch[x][1];
		}splay(y);
		return p-L;
	}inline int rank(int u){
		splay(u);
		return siz[ch[u][0]]+1;
	}inline int split(int l){
		int u = mp[l],rnk = rank(u);
		int L = 0,R = 0;
		if(rnk != 1) L = get_k(root,rnk-1),splay(L);
		if(rnk != siz[root]) R = get_k(root,rnk+1),splay(R);
		splay(L),splay(R,L);
		int v;
		if(R) v = ch[R][0],ch[R][0] = 0;
		else v = ch[L][1],ch[L][1] = 0;
		fa[v] = 0;
		if(R) pushup(R);
		if(L) pushup(L);
		return v;
	}
	
}Hutao[2],Furina;//不要太在意变量名,Hutao 维护前/后,Furina 维护中间部分
inline int get_Mp(int a){
	if(Mp.count(a)) return Mp[a];
	else return a;
}inline int get_Pm(int a){
	if(Pm.count(a)) return Pm[a];
	else return a;
}signed main(){
	ios_base::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin >> n >> m;
	for(int i = 1,a = 0,op,x,y;i <= m;++i){
		cin >> op >> x;
		x -= a;
		if(op == 1){
			cin >> y;
			y -= a;
			int yuanshen = get_Mp(x);//原批的代码，这辈子就这样了
			if(Mp.count(x)) Mp.erase(x);
			Mp[y] = yuanshen;
			Pm[yuanshen] = y;
			x = Mp[y];
			if(Front.count(x)){
				cout << (a = Hutao[0].rank(Hutao[0].mp[x])) << "\n";
			}else if(Back.count(x)){
				cout << (a = (n-Hutao[1].siz[Hutao[1].root]+Hutao[1].rank(Hutao[1].mp[x]))) << "\n";
			}else{
				cout << (a = (Hutao[0].siz[Hutao[0].root]+Furina.unget_k(x))) << "\n";
			}
		}else if(op == 2){
			x = get_Mp(x);
			if(Front.count(x)){
				cout << (a = Hutao[0].rank(Hutao[0].mp[x])) << "\n";
				int v = Hutao[0].split(x);
				Hutao[0].insert_Hutao(v,0);
			}else if(Back.count(x)){
				cout << (a = (n-Hutao[1].siz[Hutao[1].root]+Hutao[1].rank(Hutao[1].mp[x]))) << "\n";
				Back.erase(x);
				Hutao[1].split(x);
				Hutao[0].insert_Hutao(Hutao[0].newnode(x),0);
				Front[x] = 1;
			}else{
				cout << (a = (Hutao[0].siz[Hutao[0].root]+Furina.unget_k(x))) << "\n";
				Hutao[0].insert_Hutao(Hutao[0].newnode(x),0);
				Furina.insert_Furina(Furina.newnode(x));
				Front[x] = 1;				
			}
		}else if(op == 3){
			x = get_Mp(x);
			if(Front.count(x)){
				cout << (a = Hutao[0].rank(Hutao[0].mp[x])) << "\n";
				Front.erase(x);
				Hutao[0].split(x);
				Hutao[1].insert_Hutao(Hutao[1].newnode(x),1);
				Back[x] = 1;
			}else if(Back.count(x)){
				cout << (a = (n-Hutao[1].siz[Hutao[1].root]+Hutao[1].rank(Hutao[1].mp[x]))) << "\n";
				int v = Hutao[1].split(x);
				Hutao[1].insert_Hutao(v,1);
			}else{
				cout << (a = (Hutao[0].siz[Hutao[0].root]+Furina.unget_k(x))) << "\n";
				Hutao[1].insert_Hutao(Hutao[1].newnode(x),1);
				Furina.insert_Furina(Furina.newnode(x));
				Back[x] = 1;				
			}
		}else if(op == 4){
			if(x <= Hutao[0].siz[Hutao[0].root]){
				int v = Hutao[0].get_k(Hutao[0].root,x);
				cout << (a = get_Pm(Hutao[0].num[v])) << "\n";
				Hutao[0].splay(v);
			}else if(n-Hutao[1].siz[Hutao[1].root]+1 <= x){
				int v = Hutao[1].get_k(Hutao[1].root,x-(n-Hutao[1].siz[Hutao[1].root]));
				cout << (a = get_Pm(Hutao[1].num[v])) << "\n";
				Hutao[1].splay(v);
			}else{
				int v = Furina.unfind(x-Hutao[0].siz[Hutao[0].root]);
				cout << (a = get_Pm(v)) << "\n";
			}
		}
	}
	return 0;
}
```

码风巨丑，不喜勿喷。

---

## 作者：2344b (赞：1)

具体思路大家都讲得非常清楚了。

开一个splay维护排名序列，将未进行操作的节点合并。

用map维护一下每个编号在splay中对应节点的位置，对于合并的节点，只要记录右端点的编号即可(可以lower_bound求出)

然后模拟操作过程。

我简化了一下代码，仅提供一个可能比较精简的代码供参考。
```cpp
#include<bits/stdc++.h>
#include<bitset>
typedef long long LL;
typedef double DB;
#define REP(i,s,t) for(register int i=s;i<=t;++i)
#define PER(i,s,t) for(register int i=s;i>=t;--i)
#define FOREDGE(i,x,v) for(int i=fir[x],v=to[i];i;i=nex[i],v=to[i])
template<typename T>inline T in(){
    T ans=0;bool b=0;char ch=getchar();
    while(ch<'0'||ch>'9')b=(ch=='-'),ch=getchar();
    while(ch>='0'&&ch<='9')ans=ans*10+ch-48,ch=getchar();
    return b?-ans:ans;
}
#define II in<int>()
#define IL in<LL>()
//<-----QAQ----->
const int MX=3e5+100;
std::map<int,int>MP;
int n,m;
struct Splay{
#define ls ch[0][x]
#define rs ch[1][x]
    int fa[MX],ch[2][MX],sz[MX],L[MX],R[MX],size,root;
    void pushUp(int x){
        sz[x]=sz[ls]+sz[rs]+R[x]-L[x]+1;
    }
    int newNode(int id,int f,int lc,int rc,int l,int r){
        int x=id;fa[x]=f;
        ls=lc;rs=rc;L[x]=l;R[x]=r;
        return pushUp(x),x;
    }
    void init(int len){
        root=newNode(++size,0,0,0,1,len);R[0]=-1;
    }
    int ws(int x){
        return x==ch[1][fa[x]];
    }
    void rotate(int x){
        int f=fa[x],ff=fa[f],h=ws(x),w=ch[h^1][x];
        fa[x]=ff;if(ff)ch[ws(f)][ff]=x;
        fa[f]=x;ch[h^1][x]=f;
        if(w)fa[w]=f;ch[h][f]=w;
        pushUp(f),pushUp(x);
    }
    void splay(int x,int goal=0){
        if(x==goal)return;
        for(;fa[x]!=goal;rotate(x))if(fa[fa[x]]!=goal)rotate(ws(x)^ws(fa[x])?x:fa[x]);
        if(goal==0)root=x;
    }
    void split(int x,int id){
        if(id!=L[x])ls=fa[ls]=newNode(++size,x,ls,0,L[x],id-1),MP[id-1]=ls,pushUp(ls),fa[0]=0;
        if(id!=R[x])rs=fa[rs]=newNode(++size,x,0,rs,id+1,R[x]),MP[R[x]]=rs,pushUp(rs),fa[0]=0;
        L[x]=R[x]=id;MP[id]=x;pushUp(x);
    }
    int query(int x){
        splay(x);
        return sz[ls]+1;
    }
    void pushHead(int id){
        int x=root;
        while(ls)x=ls;
        ls=newNode(id,x,0,0,L[id],R[id]);
        pushUp(id),splay(id);
    }
    void pushTail(int id){
        int x=root;
        while(rs)x=rs;
        rs=newNode(id,x,0,0,L[id],R[id]);
        pushUp(id),splay(id);
    }
    void remove(int x){
        splay(x);
        if(!ls)return root=rs,fa[rs]=0,rs=sz[x]=0,void();
        if(!rs)return root=ls,fa[ls]=0,ls=sz[x]=0,void();
        int p=ls,s=rs;
        while(ch[1][p])p=ch[1][p];
        while(ch[0][s])s=ch[0][s];
        splay(p),splay(s,p);
        ch[0][s]=0;fa[x]=0;
        pushUp(x),pushUp(s),pushUp(p);
    }
    int rnk(int k){
        int x=root;
        for(;;){
            if(sz[ls]>=k)x=ls;
            else if(sz[x]-sz[rs]<k)k-=sz[x]-sz[rs],x=rs;
            else break;
        }
        return L[x]+k-1-sz[ls];
    }
#undef ls
#undef rs
}T;
int ans,pre;
int modify(int y,int x){
    int id=MP.lower_bound(x)->second;
    T.split(id,x);
    ans=T.query(id);
    T.L[id]=T.R[id]=y;MP[y]=id;
    return printf("%d\n",ans),ans;
}
int move(int x,void (Splay::*op)(int)){
    int id=MP.lower_bound(x)->second;
    T.split(id,x);
    ans=T.query(id);
    T.remove(id);
    (T.*op)(id);
    return printf("%d\n",ans),ans;
}
int rnk(int x){
    ans=T.rnk(x);
    return printf("%d\n",ans),ans;
}
int main(){
    n=II;m=II;
    T.init(n);
    MP[n]=1;
    REP(i,1,m)switch(II){
        case 1:pre=modify(II-pre,II-pre);break;
        case 2:pre=move(II-pre,&Splay::pushHead);break;
        case 3:pre=move(II-pre,&Splay::pushTail);break;
        case 4:pre=rnk(II-pre);break;
    }
}
```

---

## 作者：Smokey_Days (赞：0)

题目要求维护一个编号序列和一个排名序列，并支持四种操作：

1.按照编号修改编号，并返回该编号的排名。

2.将一个节点的排名提升到第一个。

3.将一个节点的排名降低到最后一个。

4.查询某个排名的编号。 

很显然是用Splay维护排名，然后开一个数组存编号咯。 

然而我们观察到这一题的数据范围是n<=10^8，那么用上述的方法显然会MLE。
故而我们考虑一个Splay节点「真的维护」一个区间。然后每一次要用到一个新的点就把原有的区间剖开。

而数组存编号也就很套路地换成map存编号。


续：这一题是我在190103的时候写完的，然而直到191003我才调出来。期间经过了十个月。

调试的突破性进展来自于对调试工具的学习使用，这使得我在巨大数据的情况下得以想办法调试。

我首先发现了size发生了错误，进而发现某个节点的size不等于其两孩子的大小之和加上它本身的大小。然后，经由此处，我发现有个节点的相邻节点是一个大小为空的节点，进而发现这个节点在被分配下标之前就被访问了。

最终，我注意到它第一次出现所相接的节点，并发现这个数事实上是一个标号。

紧接着我就顺利地调出另一个错，并通过了此题。 

注意点：

1.对于空节点的情况一定要认真考虑，因为如果空节点操作不慎的话很可能会导致一些莫名其妙的错误。

2.要注意适时更新节点。

3.千万不要搞混「标号」和「排名」！！！！！！

4.如果一个点本来就是排名最后的点而要移到排名最后，有可能会出错。 
```cpp
#include<iostream>
#include<cstdio>
#include<map>
#define error(X) printf("ERROR: %d",X)
#define debug(P) printf("(%d):%d,%d,sn:[%d,%d],FA:%d,SZ:%d\n",P,tr[P].l,tr[P].r,tr[P].sn[0],tr[P].sn[1],tr[P].fa,tr[P].sz);

bool bo=0;
class Splay{
	public:
		class Node{
			public:
				int l;
				int r;
				int sz;
				int sn[2];
				int fa;
				inline void set(int L,int R,int FA){
					l=L,r=R,fa=FA,sz=R-L+1,sn[0]=sn[1]=0;
				}
		};
		//i表示mp[i]这个节点的右端点的标号。 
		std::map<int,int> mp;
		Node tr[400005];
		int cnt,rt;
		//寻找当前节点与父亲的关系。 
		inline int fndD(int X){
			return tr[tr[X].fa].sn[1]==X;
		}
		//更新当前节点。 
		inline void updt(int X){
			tr[X].sz=tr[tr[X].sn[0]].sz+tr[tr[X].sn[1]].sz+tr[X].r-tr[X].l+1;
//			if(X==10619&&tr[X].sz<=30){prnt(tr[X].fa);}
		}
		//旋转套装。 
		inline void splayOne(int X){
			if(!X){return;}
			int D=fndD(X),D2=fndD(tr[X].fa);
//			if(X==65505||tr[X].fa==65505||tr[tr[X].fa].sn[D^1]==65505){
//				puts("FKFKFK");
//				printf("X");debug(X);
//				printf("FA");debug(tr[X].fa);
//				printf("BR");debug(tr[tr[X].fa].sn[D^1]);
//			}
			tr[tr[X].sn[D^1]].fa=tr[X].fa,tr[tr[X].fa].sn[D]=tr[X].sn[D^1];
			tr[X].sn[D^1]=tr[X].fa,tr[X].fa=tr[tr[X].sn[D^1]].fa;
			tr[tr[X].fa].sn[D2]=X,tr[tr[X].sn[D^1]].fa=X;
			updt(tr[X].sn[D^1]),updt(X);
		}
		inline void splayTwo(int X){
//			if(bo&&X==38190){debug(X);}
			int D=fndD(X),D2=fndD(tr[X].fa);
			tr[X].fa?(tr[tr[X].fa].fa?(D==D2?(splayOne(tr[X].fa),splayOne(X),0):(splayOne(X),splayOne(X),0)):(splayOne(X),0)):0;
		}
		inline void splayRnw(int X){
			while(tr[X].fa){splayTwo(X);}
			rt=X;
		}
//		inline void splayRnw(int X){
//			while(tr[X].fa){
//				int F=tr[X].fa,FF=tr[tr[X].fa].fa;
//				if(!FF)
//			}
//		}
		//找到排名为X的元素。 
		inline int fnd(int X){
			int P=rt;
			while(P){
				if(X>tr[tr[P].sn[0]].sz+tr[P].r-tr[P].l+1){
					X-=tr[tr[P].sn[0]].sz+tr[P].r-tr[P].l+1;
					P=tr[P].sn[1];
				}else if(X>tr[tr[P].sn[0]].sz){
					X-=tr[tr[P].sn[0]].sz;
					splayRnw(P);
//					debug(P);
					return tr[P].l+X-1;
				}else{
					P=tr[P].sn[0];
				}
			}
			return -1; 
		}
		//开一个新节点，以X为它的父亲。 
		inline int nwlc(int X,int L,int R){
			int P=++cnt;
//			if(P==65505){
//				printf("START:");
//				debug(P);
//			}
			tr[P].set(L,R,X);
			return P;
		}
		//将编号为X的节点单独弄成一个新的节点，然后将它的两个子节点接到它的左右，并更改相应的编号的映射 
		inline int split(int P,int X){
			if(tr[P].l==tr[P].r){return P;}
			if(P==-1){return error(192600404),192600404;}
			if(X>tr[P].l){
				int L=tr[P].sn[0];
				L?(cut(L),0):(tr[0].fa=0);
				tr[P].sn[0]=nwlc(P,tr[P].l,X-1);
				L?(cnnct(L,tr[P].sn[0],0),0):0;
				mp[X-1]=tr[P].sn[0];
//				updt(tr[P].sn[0]);
			}
			if(X<tr[P].r){
				int R=tr[P].sn[1];
				R?(cut(R),1):(tr[0].fa=0);
				tr[P].sn[1]=nwlc(P,X+1,tr[P].r);
				R?(cnnct(R,tr[P].sn[1],1),1):1;
				mp[tr[P].r]=tr[P].sn[1];
//				updt(tr[P].sn[1]);
			}
			tr[P].l=tr[P].r=X;mp[X]=P;
			updt(P);
			return P;
		}
		inline int fndMn(int X){
			int P=X,FP=tr[X].fa;
			while(P){
				FP=P;
				P=tr[P].sn[0]; 
			}
			return FP;
		}
		inline int fndMx(int X){
			int P=X,FP=tr[X].fa;
			while(P){
				FP=P;
				P=tr[P].sn[1];
			}
			return FP;
		}
		inline void cut(int X){
			int D=fndD(X);
			tr[tr[X].fa].sn[D]=0,tr[X].fa=0;
		}
		inline void cnnct(int X,int Y,int D){
			tr[Y].sn[D]=X,tr[X].fa=Y;
			updt(Y);
		}
		inline void prnt(int X,int dep=0){
			if(!X){return;}
			for(int i=1;i<=dep;++i){
				printf(" ");
			}debug(X);
			prnt(tr[X].sn[0],dep+1);
			prnt(tr[X].sn[1],dep+1);
		}
	public:
		inline int CHANGE(int X,int Y){
			int P=mp.lower_bound(X)->second;
			P=split(P,X);
			tr[P].l=tr[P].r=Y;
			mp[Y]=P;
			splayRnw(P);
			return tr[tr[P].sn[0]].sz+1;
		}
		inline int LST(int X){
			int P=mp.lower_bound(X)->second;
			P=split(P,X);
			splayRnw(P);
			int L=tr[P].sn[0],R=tr[P].sn[1],RT=tr[tr[P].sn[0]].sz+1;
			if(!L){
				return RT;
			}
			R?(R=fndMn(R),cut(L),cnnct(L,R,0),splayRnw(L)):(cut(L),cnnct(L,P,1));//此处P写成X,调了我一年。 
			return RT;
		}
		inline int RST(int X){
			int P=mp.lower_bound(X)->second;
			P=split(P,X);
			splayRnw(P);
			int L=tr[P].sn[0],R=tr[P].sn[1],RT=tr[tr[P].sn[0]].sz+1;
			if(!R){
				return RT;
			}
			L?(L=fndMx(L),cut(R),cnnct(R,L,1),splayRnw(R)):(cut(R),cnnct(R,P,0));
			return RT;
		}
		inline int ARNK(int X){
			return fnd(X);
		} 
		//初始化。 
		inline void INIT(int N){
			cnt=1;
			rt=1;
			tr[1].set(1,N,0);
			mp[N]=1;
		}
};
/*
Error:
192600404: 指定的节点不存在。
192600500: 切割的节点不是区间节点。 
*/

int n,m;
Splay T;
void init(){
	int code=0;
	scanf("%d%d",&n,&m);
	T.INIT(n);
	int op,x,y;
	for(int i=1;i<=m;++i){
		scanf("%d",&op);
		switch(op){
			case 1:{
				scanf("%d%d",&x,&y);
				x-=code,y-=code;
				printf("%d\n",code=T.CHANGE(x,y));
//				if(code==95204&&i>=80000){
//					puts("fk1");
//					printf("%d\n",x);
//					return;
//				}
				break;
			}
			case 2:{
				scanf("%d",&x);
				x-=code;
				printf("%d\n",code=T.LST(x));
				break;
			}
			case 3:{
				scanf("%d",&x);
				x-=code;
				printf("%d\n",code=T.RST(x));
				break;
			}
			case 4:{
				scanf("%d",&x);
				x-=code;
				printf("%d\n",code=T.ARNK(x));
				break;
			}
		}
//		printf("CORESIZE:%d\n",T.tr[54567].sz);
	}
}

int main(){
//	freopen("input1.in","r",stdin);
//	freopen("output1.out","w",stdout);
	init();
	return 0;
} 
```


---

## 作者：zhengrunzhe (赞：0)

提供指针Splay

Nmax=10^8 建一亿个点连编译都过不去

与NOIP2017DAY2T3列队类似 平衡树上一个点表示一个区间[l,r] 表示这个点存了编号连续地从l到r

要修改一个点时，由于无论是改编号还是提前滞后，都会破坏这个点的连续性，所以先把它单独拆出来

假设一个点A表示区间[l,r]，要修改位置x(也就是区间[x,x])，首先肯定要新建节点B表示[x,x]

1.x==l 此时B即是[l,l]，令A表示[l+1,r]，[l,l]肯定是[l+1,r]的前驱，所以先找到A原来的前驱C，把B当作C的右儿子，那么此时B即是A的新前驱了(如果A原没有前驱，直接把B当作A的左儿子)

2.x==r 此时B即是[r,r]，令A表示[l,r-1]，[r,r]肯定是[l,r-1]的后继，所以先找到A原来的后继C，把B当作C的左儿子，那么此时B即是A的新后继了(如果A原没有后继，直接把B当作A的右儿子)

3.l<x<r 此时A被拆成三个区间A[l,x-1]，B[x,x]，C[x+1,r]，由于C是B的后继，所以可以把C作为B的右儿子看作一个整体BC，BC又是A的后继，所以同理找到A原先的后继D，把BC接作D的左儿子(没有后继就把BC当作A的右儿子)

提前就是先把原位置的点提取出来记作X，然后把X从树中删除，再把X插入到树中第一个点的左儿子处，放到最后的操作反之

询问操作就是找排名为k的数，重定义size，初值等于区间[l,r]的长度即size=r-l+1，然后同样像常规平衡树那样找kth，找到对应的点后，返回对应的数

由于Mmax=10^5，点数最多不会超过十万多，稍微开大一点以防万一就ok了
```cpp
#include<map>
#include<cstdio>
#define reg register
using namespace std;
const int N=1e8+1,M=1e5+10;
int n,m,lastans;
namespace Splay
{
	struct tree
	{
		int l,r,size;
		tree *son[2],*fa;
		inline void pushup()
		{
			size=r-l+1+son[0]->size+son[1]->size;
		}
		inline bool relation()
		{
			return fa->son[1]==this;
		}
	}*root,*tail,memory_pool[M<<1],*recycle[M<<1],*null;
	int top;
	map<int,tree*>loc;
	inline void init() //写个内存池
	{
		tail=memory_pool;
		null=tail++;
		null->son[0]=null->son[1]=null->fa=null;
		null->l=null->r=null->size=top=0;
		root=null;
	}
	inline tree *newtree(reg int l,reg int r)
	{
		reg tree *p=top?recycle[--top]:tail++;
		p->l=l;p->r=r;p->size=r-l+1;
		p->son[0]=p->son[1]=p->fa=null;
		return p;
	}
	inline void erase(tree *&p)
	{
		recycle[top++]=p;
		p=null;
	}
	inline void connect(reg tree *&p,reg tree *&fa,reg bool which)
	{
		if (p!=null)p->fa=fa;
		if (fa!=null)fa->son[which]=p,fa->pushup();
	}
	inline void rotate(reg tree *&p)
	{
		reg tree *fa=p->fa;
		reg bool dir=p->relation();
		connect(p,fa->fa,fa->relation());
		connect(p->son[dir^1],fa,dir);
		connect(fa,p,dir^1);
		fa->pushup();p->pushup();
	}
	inline void splay(reg tree *p)
	{
		for (reg tree *fa;(fa=p->fa)!=null;rotate(p))
			if (fa->fa!=null)
				rotate(p->relation()==fa->relation()?fa:p);
		root=p;
	}
	inline tree *precursor(reg tree *&p)
	{
		splay(p);
		reg tree *now=p->son[0];
		while (now->son[1]!=null)now=now->son[1];
		return now;
	}
	inline tree *successor(reg tree *&p)
	{
		splay(p);
		reg tree *now=p->son[1];
		while (now->son[0]!=null)now=now->son[0];
		return now;
	}
	inline void Delete(reg tree *&p)
	{
		splay(p);
		if (p->son[0]==null&&p->son[1]==null)return erase(root);
		if (p->son[0]==null)return erase((root=p->son[1])->fa);
		if (p->son[1]==null)return erase((root=p->son[0])->fa);
		reg tree *pre=precursor(p);splay(pre);
		connect(p->son[1],pre,1);erase(p);
	}
	inline void split(reg tree *p,reg int pos)
	{
		if (p->l==p->r)return;
		reg tree *now=newtree(pos,pos),*pre=precursor(p),*nxt=successor(p);
		loc[pos]=now;
		if (pos==p->l)
			return p->l++,p->pushup(),
			(pre==null?connect(now,p,0):connect(now,pre,1)),splay(now);
		if (pos==p->r)
			return (loc[--p->r]=p)->pushup(),
			(nxt==null?connect(now,p,1):connect(now,nxt,0)),splay(now);
		connect(loc[p->r]=newtree(pos+1,p->r),now,1);
		(loc[p->r=pos-1]=p)->pushup();
		if (nxt==null)return connect(now,p,1),splay(now);
		connect(now,nxt,0);splay(now);
	}
	inline int get_rank(reg tree *p,reg int pos)
	{
		split(p,pos);splay(loc[pos]);
		return root->son[0]->size+1;
	}
	inline int find_rank(reg int ranking)
	{
		reg tree *now=root;
		while (1)
			if (ranking<=now->son[0]->size)now=now->son[0];
			else
			{
				reg int len=now->r-now->l+1;
				ranking-=now->son[0]->size+len;
				if (ranking<=0)return now->l+ranking+len-1;
				now=now->son[1];
			}
	}
}using namespace Splay;
inline int read()
{
	reg int out=0;reg char ch=getchar();
	while (ch<48||ch>57)ch=getchar();
	while (ch>47&&ch<58)out=(out<<3)+(out<<1)+ch-48,ch=getchar();
	return out;
}
inline void Init()
{
	n=read();m=read();
	loc[n]=root=newtree(1,n);
}
inline void change(int idx,int idy)
{
	reg tree *p=loc.lower_bound(idx)->second;
	printf("%d\n",lastans=get_rank(p,idx));
	loc[idx]->l=loc[idx]->r=idy;
	loc[idy]=loc[idx];
}
inline void lift_front(reg int id)
{
	reg tree *p=loc.lower_bound(id)->second;
	printf("%d\n",lastans=get_rank(p,id));
	reg int l=loc[id]->l,r=loc[id]->r;
	Delete(loc[id]);
	if (root==null){loc[id]=root=newtree(l,r);return;}
	reg tree *k=root,*nt=newtree(l,r);
	while (k->son[0]!=null)k=k->son[0];
	connect(loc[id]=nt,k,0);splay(nt);
}
inline void push_back(reg int id)
{
	reg tree *p=loc.lower_bound(id)->second;
	printf("%d\n",lastans=get_rank(p,id));
	reg int l=loc[id]->l,r=loc[id]->r;
	Delete(loc[id]);
	if (root==null){loc[id]=root=newtree(l,r);return;}
	reg tree *k=root,*nt=newtree(l,r);
	while (k->son[1]!=null)k=k->son[1];
	connect(loc[id]=nt,k,1);splay(nt);
}
inline void get_kth(reg int k)
{
	printf("%d\n",lastans=find_rank(k));
}
int main()
{
	init();Init();
	while (m--)
	{
		reg int opt=read(),x=read()-lastans;
		switch (opt)
		{
			case 1:change(x,read()-lastans);break;
			case 2:lift_front(x);break;
			case 3:push_back(x);break;
			case 4:get_kth(x);break;
		}
	}
	return 0;
}
```

---


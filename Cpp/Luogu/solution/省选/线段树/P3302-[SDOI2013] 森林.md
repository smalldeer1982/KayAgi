# [SDOI2013] 森林

## 题目描述

小 Z 有一片森林，含有 $N$ 个节点，每个节点上都有一个非负整数作为权值。初始的时候，森林中有 $M$ 条边。

小Z希望执行 $T$ 个操作，操作有两类：

 - `Q x y k` 查询点 $x$ 到点 $y$ 路径上所有的权值中，第 $k$ 小的权值是多少。此操作保证点 $x$ 和点 $y$ 连通，同时这两个节点的路径上至少有 $k$ 个点。
 - `L x y` 在点 $x$ 和点 $y$ 之间连接一条边。保证完成此操作后，仍然是一片森林。

为了体现程序的在线性，我们把输入数据进行了加密。设 $lastans$ 为程序上一次输出的结果，初始的时候 $lastans$ 为 $0$。

对于一个输入的操作 `Q x y k`，其真实操作为 `Q x^lastans y^lastans k^lastans`。

对于一个输入的操作 `L x y`，其真实操作为 `L x^lastans y^lastans`。其中 `^` 运算符表示异或，等价于 Pascal 中的 `xor` 运算符。

请写一个程序来帮助小 Z 完成这些操作。

## 说明/提示

**样例解释**

对于第一个操作 `Q 8 7 3`，此时 $lastans=0$，所以真实操作为 `Q 8^0 7^0 3^0`，也即 `Q 8 7 3`。点 $8$ 到点 $7$ 的路径上一共有 $5$ 个点，其权值为 $4\ 1\ 1\ 2\ 4$。这些权值中，第三小的为 $2$，输出 $2$，$lastans$ 变为 $2$。

对于第二个操作 `Q 3 5 1` ，此时 $lastans=2$，所以真实操作为 `Q 3^2 5^2 1^2`，也即 `Q 1 7 3`。点 $1$ 到点 $7$ 的路径上一共有 $4$ 个点，其权值为 $1\ 1\ 2\ 4$ 。这些权值中，第三小的为 $2$，输出 $2$，$lastans$ 变为 $2$。之后的操作类似。

-----
**数据范围**

| 测试点编号  | $N,M,T$ 的上界 |  `L` 操作   |  `Q` 操作  | 形态 |
| :---------: | :------------: | :---------: | :--------: | :--: |
|     $1$     |      $20$      |     N/A     |    N/A     | N/A  |
|     $2$     |     $200$      |     N/A     |    N/A     | N/A  |
|  $3\sim 4$  | $4\times 10^4$ | 无 `L` 操作 |    N/A     |  链  |
|  $5\sim 6$  | $8\times 10^4$ | 无 `L` 操作 |    N/A     |  链  |
|  $7\sim 9$  | $8\times 10^4$ | 无 `L` 操作 | 保证 $k=1$ | N/A  |
| $10\sim 11$ | $4\times 10^4$ |     N/A     | 保证 $k=1$ | N/A  |
| $12\sim 13$ | $8\times 10^4$ |     N/A     | 保证 $k=1$ | N/A  |
| $14\sim 15$ | $4\times 10^4$ | 无 `L` 操作 |    N/A     | N/A  |
| $16\sim 17$ | $8\times 10^4$ | 无 `L` 操作 |    N/A     | N/A  |
|    $18$     | $4\times 10^4$ |     N/A     |    N/A     | N/A  |
| $19\sim 20$ | $8\times 10^4$ |     N/A     |    N/A     | N/A  |

注：N/A 表示没有特殊性。

对于 $100\%$ 的测试数据，所有节点的编号在 $1\sim N$ 的范围内。节点上的权值 $\le 10^9$。$M<N$。

## 样例 #1

### 输入

```
1
8 4 8
1 1 2 2 3 3 4 4
4 7
1 8
2 4
2 1
Q 8 7 3
Q 3 5 1
Q 10 0 0
L 5 4
L 3 2
L 0 7
Q 9 2 5
Q 6 1 6```

### 输出

```
2 
2
1
4
2```

# 题解

## 作者：玫葵之蝶 (赞：50)

先贴blog：[stone41123](http://blog.csdn.net/stone41123/article/details/78167288)

此题有两种操作：

1.查询树上两点间权值第k小

2.连接两棵树

限制条件：强制在线

看到第k小大家想到的肯定是主席树，可是连边又让大家想到了LCT

我们选择使用主席树。

为什么呢？

我们肯定是要舍弃两种操作中的一种，让它变慢，另一个就快了。

然而，第k小显然没有什么优化的余地，可是连接两棵树显然就是合并两棵树

合并！我们可以想到启发式合并！它可以优化合并到$O(logn)$，一个log的消耗还是可以承受的。

于是具体实现就是，我们可以记录每棵树的大小，合并的时候把小的接到大的上面去，合并的时候我们dfs暴力修改，用父节点重建每个节点的主席树，并且更新每个节点的倍增数组（st表）。

更新倍增数组这里还是有技巧的，我们不需要dfs完了才修改，我们可以一边dfs一边改：

```cpp
void dfs(int x,int father,int rt){
    //这一段
    st[x][0]=father;
    for(int k=1;k<=16;k++){
        st[x][k]=st[st[x][k-1]][k-1];
    }
    //上面
    son[rt]++;
    dep[x]=dep[father]+1;
    fa[x]=father;
    vis[x]=1;
    insert(root[x],root[father],1,size,Hash(a[x]));
    for(int i=head[x];i;i=e[i].next){
        int u=e[i].to;
        if(u==father)continue;
        dfs(u,x,rt);
    }
}
```
这就是如何合并。

然后我们来讨论查询。

主席树大家肯定都写过，但是大部分人写的都是针对数组的，这里我们要在树上建主席树。

每一颗主席树维护的是它到根节点的数字信息，于是类似于原本的主席树，我们可以发现每一个节点和它的父亲节点维护的主席树没有太大的变化，最多只会变化logn个点，于是我们dfs时可以利用每个节点的父亲的主席树来建立它的主席树。

查询时怎么做呢？

我们可以记录四个变量，从四个节点同时查询

假设查询节点分别是$x,y$，那它们分别就是：$x,y,lca(x,y),father(lca(x,y))$

每次主席树操作时，就是这样：

```cpp
int query(int x,int y,int pre1,int pre2,int l,int r,int k){
    if(l==r)return b[l];
    int lsize=t[t[x].ls].size+t[t[y].ls].size-t[t[pre1].ls].size-t[t[pre2].ls].size;
    int mid=(l+r)>>1;
    if(k<=lsize)return query(t[x].ls,t[y].ls,t[pre1].ls,t[pre2].ls,l,mid,k);
    else return query(t[x].rs,t[y].rs,t[pre1].rs,t[pre2].rs,mid+1,r,k-lsize);
}
```
建树和原来一样：

```cpp
void insert(int &now,int pre,int l,int r,int x){
    now=++cnt;
    t[now]=t[pre];
    t[now].size++;
    if(l==r)return;
    int mid=(l+r)>>1;
    if(x<=mid)insert(t[now].ls,t[pre].ls,l,mid,x);
    else insert(t[now].rs,t[pre].rs,mid+1,r,x);
}
```
每个根节点还要先build一下：

```cpp
void build(int &now,int l,int r){
    now=++cnt;
    t[now].size=0;
    if(l==r)return;
    int mid=(l+r)>>1;
    build(t[now].ls,l,mid);
    build(t[now].rs,mid+1,r);
}
```
剩下的倍增lca的我就不说了。

还有就是这个题需要离散化，也很正常。

还有就是一个坑点，那个testcase是编号！不是组数！我被这个坑到10分。。。

剩下就是尽量优化优化常数，常数不要太大。

还要开够空间。

代码：

```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<cmath>
#include<algorithm>
#include<cstdlib>
#define ll long long
using namespace std;
inline int read(){
    int x=0;char ch=' ';int f=1;
    while(ch!='-'&&(ch<'0'||ch>'9'))ch=getchar();
    if(ch=='-')f=-1,ch=getchar();
    while(ch>='0'&&ch<='9')x=x*10+ch-'0',ch=getchar();
    return x*f;
}
struct edge{
    int to,next;
}e[320001];
int T,n,m,q,tot;
int a[80001];
int fa[80001];
int son[80001];
int head[80001];
inline void addedge(int x,int y){
    e[++tot].to=y;e[tot].next=head[x];head[x]=tot;
}
struct Node{
    int size,ls,rs;
}t[80001*600];
int cnt;
int root[80001];
void build(int &now,int l,int r){
    now=++cnt;
    t[now].size=0;
    if(l==r)return;
    int mid=(l+r)>>1;
    build(t[now].ls,l,mid);
    build(t[now].rs,mid+1,r);
}
void insert(int &now,int pre,int l,int r,int x){
    now=++cnt;
    t[now]=t[pre];
    t[now].size++;
    if(l==r)return;
    int mid=(l+r)>>1;
    if(x<=mid)insert(t[now].ls,t[pre].ls,l,mid,x);
    else insert(t[now].rs,t[pre].rs,mid+1,r,x);
}
int b[80001];
int size;
int query(int x,int y,int pre1,int pre2,int l,int r,int k){
    if(l==r)return b[l];
    int lsize=t[t[x].ls].size+t[t[y].ls].size-t[t[pre1].ls].size-t[t[pre2].ls].size;
    int mid=(l+r)>>1;
    if(k<=lsize)return query(t[x].ls,t[y].ls,t[pre1].ls,t[pre2].ls,l,mid,k);
    else return query(t[x].rs,t[y].rs,t[pre1].rs,t[pre2].rs,mid+1,r,k-lsize);
}
inline int Hash(int x){
    return lower_bound(b+1,b+size+1,x)-b;
}
int find(int x){
    return fa[x]==x?x:fa[x]=find(fa[x]);
}
int st[80001][17];
int dep[80001];
int vis[80001];
void dfs(int x,int father,int rt){
    st[x][0]=father;
    for(int k=1;k<=16;k++){
        st[x][k]=st[st[x][k-1]][k-1];
    }
    son[rt]++;
    dep[x]=dep[father]+1;
    fa[x]=father;
    vis[x]=1;
    insert(root[x],root[father],1,size,Hash(a[x]));
    for(int i=head[x];i;i=e[i].next){
        int u=e[i].to;
        if(u==father)continue;
        dfs(u,x,rt);
    }
}
inline int getlca(int x,int y){
    if(x==y)return x;
    if(dep[x]>dep[y])swap(x,y);
    for(int k=16;k>=0;k--){
        if(dep[st[y][k]]>=dep[x]){
            y=st[y][k];
        }
    }
    if(x==y)return x;
    for(int k=16;k>=0;k--){
        if(st[x][k]!=st[y][k]){
            x=st[x][k];
            y=st[y][k];
        }
    }
    return st[x][0];
}
int main(){
    T=read();
    T=1;
    while(T--){
        memset(head,0,sizeof(head));
        memset(dep,0,sizeof(dep));
        memset(vis,0,sizeof(vis));
        memset(st,0,sizeof(st));
        memset(son,0,sizeof(son));
        tot=0;
        cnt=0;
        n=read();m=read();q=read();
        for(int i=1;i<=n;i++){
            a[i]=read();
            b[i]=a[i];
            fa[i]=i;
        }
        sort(b+1,b+n+1);
        size=unique(b+1,b+n+1)-b-1;
        for(int i=1;i<=m;i++){
            int x=read(),y=read();
            addedge(x,y);addedge(y,x);
        }
        build(root[0],1,size);
        for(int i=1;i<=n;i++){
            if(!vis[i]){
                dfs(i,0,i);
                fa[i]=i;
            }
        }
        int lastans=0;
        for(int i=1;i<=q;i++){
            char ch[3];
            int x,y,k;
            scanf("%s",ch);
            x=read()^lastans;
            y=read()^lastans;
            if(ch[0]=='Q'){
                k=read()^lastans;
                int lca=getlca(x,y);
                lastans=query(root[x],root[y],root[lca],root[st[lca][0]],1,size,k);
                printf("%d\n",lastans);
            }
            else{
                addedge(x,y);
                addedge(y,x);
                int u=find(x);
                int v=find(y);
                if(son[u]<son[v]){
                    swap(u,v);
                    swap(x,y);
                }
                dfs(y,x,u);
            }
        }
    }
    return 0;
}
```

---

## 作者：IC_QQQ (赞：37)

### 树上的主席树（利用LCA）+启发式合并

有兴趣的可以去看看简化版（去掉连边操作）题目[P2633 Count on a tree](https://www.luogu.org/problemnew/show/P2633)。~~获得双倍经验~~。

这道题主要有两个操作：

1. 求路径 **（u，v）** 上第**k**小点。

2. 在点 **x,y** 间连一条无向边。

第一个操作很明显，在树上建立主席树，主席树 **i** 维护从根节点 **root** 到点 **i** 路径上所有点的信息。

查询路径 **（u，v）** 上第**k**小点也容易想到，需要用到 **LCA** 。

我们找到 **（u，v）** 的最近公共祖先 **lca** 和 **lca** 的父节点 **fa_lca** 。维护这四个点的信息进行查询就可以了。

对于第二个操作，为了使时间更优，我们需要用到启发式合并的思想。~~启发式合并听上去玄妙无比，其实很普通~~。简而言之就是记录每棵树的大小，连边时把小树连接到大树上去，重构小树中的主席树、**LCA**相关数组。

~~其他的一些操作像离散化大家都会吧。~~

### 真正的重点—关于这道题的特性：

在无数次 **RE** 第**2,3,6**个测试点后，我终于找到了坑点：问题出在 **LCA** 上。

下面是错误示范：（**ans[i][j]** 表示 **i** 的 **2^j** 级祖先）

```cpp
void update_LCA(int u,int fa){
    deep[u]=deep[fa]+1;ans[u][0]=fa;
    for(int i=1;i<=lg[deep[u]];i++)//这里的上界
        ans[u][i]=ans[ans[u][i-1]][i-1];
    for(int i=head[u];i;i=nxt[i])
        if(to[i]!=fa) update_LCA(to[i],u);
    return;
}
```
只需要这里把循环的上界从 **lg[deep[u]]** 改为 **x** ，保证 **2^x>=n** 就可以了，比如 **18,19**等等。

为什么会这样，**lg[deep[u]]** 不是 **LCA** 的通用写法吗，**LCA** 的模板题也是写的**lg[deep[u]]**。

我翻讨论区，发现也有人困惑于此。~~然而，题解都巧妙地回避了这个问题，没有解答~~。

无奈，我下载了第**2**个测试点的数据，开始了漫长的探索之路。

终于，在数据中第**16058**次操作（询问操作），我发现了问题。

**lg[deep[u]]** 的确是 **LCA** 的通用写法，没有问题，这道题上行不通是这道题的 **特性** ，因为这道题有一个特殊的操作：**连边** 。

我们来看 **get_LCA** 操作：
```cpp
int get_LCA(int u,int v){
    if(deep[u]<deep[v]) swap(u,v);
    while(deep[u]>deep[v])
        u=ans[u][lg[deep[u]-deep[v]]];
    if(u==v) return u;
    for(int i=lg[deep[u]];i>=0;i--)
        if(ans[u][i]!=ans[v][i])//重点
        	u=ans[u][i],v=ans[v][i];        	
    return ans[u][0]; 
}
```

如果我们连边重构 **update_LCA** 时采用 **lg[deep[u]]** ，可能存在一种情况：这个点 **i** 原本的 **ans[i][j]**，**j** 最大已经大于了   **lg[deep[u]]** （即原来深度更深），但是我们更新只是更新到 **lg[deep[u]]** ，它上面的状态没有改变。在执行 **get_LCA** ，进行判断时：

```cpp
if(ans[u][i]!=ans[v][i])//重点
	u=ans[u][i],v=ans[v][i];
```

本来，这一次 **u,v** 不能被改变， 由于状态没有全部更新，**u,v** 被改变了，导致**lca**找错，进而答案错误，下一次进行异或操作时数字变得很大，数组越界直接导致 **RE** 。

举个栗子大家就知道了：

![](https://i.loli.net/2019/06/05/5cf73164c7b0042630.png)

假设 **ans[x]={root,6},ans[y]={root,7}**。

从 **u,v** 出发，模拟走一遍。

**i=2**时，**u**跳到了**x**。**v**跳到了**y**。

**i=1**时，**x**跳到了**6**，**v**跳到了**7**。

好了，已经出错了。

这就是这道题的特性，连边重构 **update_LCA** 时，上界很重要。

~~至于为什么其他题上界可以是 **lg[deep[u]]** ，大家自己想想吧，不难。~~

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=8e4+5;
int T,n,m,TT,last;
int tot,row[N],s[N],size[N];
int cnt,to[4*N],nxt[4*N],head[4*N];
int from[N],lg[N],ans[N][35],deep[N];
struct Tree{
    int ls,rs,si;
}t[105*N];
int root[N],top;

int in(){
    int x=0,f=1;char ch=getchar();
    while(ch>'9'||ch<'0'){ if(ch=='-') f=-1; ch=getchar(); }
    while(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();
    return x*f;	
}

void adds(int x,int y){
    to[++cnt]=y;nxt[cnt]=head[x];head[x]=cnt;
    return;
}

void pre_work(){
    int a,b;lg[0]=-1;
    T=in();n=in();m=in();TT=in();
    for(int i=1;i<=n;i++)
        row[i]=s[i]=in(),lg[i]=lg[i>>1]+1,from[i]=i;	
    sort(row+1,row+1+n);
    tot=unique(row+1,row+1+n)-(row+1);
    for(int i=1;i<=n;i++)
        s[i]=lower_bound(row+1,row+1+tot,s[i])-row;	
    for(int i=1;i<=m;i++)
        a=in(),b=in(),adds(a,b),adds(b,a);
    return;
}

void built(int &pos,int pre,int l,int r,int wi){
    t[pos=++top]=t[pre];
    t[pos].si++;
    if(l==r) return;
    int mid=(l+r)>>1;
    if(wi<=mid) built(t[pos].ls,t[pre].ls,l,mid,wi);
    else built(t[pos].rs,t[pre].rs,mid+1,r,wi);
    return;
}

void dfs(int u,int fa,int rt){
    built(root[u],root[fa],1,tot,s[u]);
    deep[u]=deep[fa]+1;ans[u][0]=fa;
    size[rt]++;from[u]=rt;
    for(int i=1;i<=18;i++)
        ans[u][i]=ans[ans[u][i-1]][i-1];
    for(int i=head[u];i;i=nxt[i])
        if(to[i]!=fa) dfs(to[i],u,rt);
    return;
}

int get_LCA(int u,int v){
    if(deep[u]<deep[v]) swap(u,v);
    while(deep[u]>deep[v])
        u=ans[u][lg[deep[u]-deep[v]]];
    if(u==v) return u;
    for(int i=lg[deep[u]];i>=0;i--)
        if(ans[u][i]!=ans[v][i])
            u=ans[u][i],v=ans[v][i];
    return ans[u][0]; 
}

int Answer(int u,int v,int og,int fg,int l,int r,int k){
    if(l==r) return row[l];
    int sum=t[t[u].ls].si+t[t[v].ls].si-t[t[og].ls].si-t[t[fg].ls].si;
    int mid=(l+r)>>1;
    if(k<=sum) return Answer(t[u].ls,t[v].ls,t[og].ls,t[fg].ls,l,mid,k);
    return Answer(t[u].rs,t[v].rs,t[og].rs,t[fg].rs,mid+1,r,k-sum);	
}

int main(){
    pre_work();
    for(int i=1;i<=n;i++)
        if(from[i]==i) dfs(i,0,i);
    char ch[5];int x,y,k;
    for(int i=1;i<=TT;i++){
        scanf("%s",ch);x=in()^last;y=in()^last;
        if(ch[0]=='Q'){
            k=in()^last;
            int og=get_LCA(x,y),fg=ans[og][0];
            last=Answer(root[x],root[y],root[og],root[fg],1,tot,k);
            printf("%d\n",last);		
        }
        else{
            adds(x,y);adds(y,x);
            int fx=from[x],fy=from[y];
            if(size[fy]<size[fx]) dfs(y,x,fx);
            else dfs(x,y,fy);
        }
    }
    return 0;
}
```


---

## 作者：LJC00118 (赞：12)

先安利一下我的[博客](https://www.cnblogs.com/LJC00118/p/9597316.html)

看到查询第 k 小，而且是一颗树，可以联想到在树上的主席树，a 和 b 路径中第 k 小可以通过在 a, b, lca(a, b), fa[lca(a, b)] 四个节点对应的主席树上二分得到

实现主席树是很简单的，连接两个点可以启发式合并，现在最大的问题是连接两个点后还要高效的求出 LCA，一种做法是启发式合并的时候重构倍增数组，也有一种用 LCT 维护 LCA 的方法，相对简单。博主的实现是后者

需要注意的就是找到 fa[lca(a, b)] 的时候，可以模仿 LCT findroot 函数的实现，先 access(lca)，然后 splay(lca)，找到深度次大的点即可。link 之后 root 会变，进行新操作的时候要 makeroot，才能求出正确的 LCA

总而言之，需要注意的细节还是很多的，具体还是看代码实现吧

```cpp
#include <bits/stdc++.h>
using namespace std;

typedef unsigned long long ull;
typedef long long ll;

template <typename _T>
inline void read(_T &f) {
    f = 0; _T fu = 1; char c = getchar();
    while(c < '0' || c > '9') {if(c == '-') fu = -1; c = getchar();}
    while(c >= '0' && c <= '9') {f = (f << 3) + (f << 1) + (c & 15); c = getchar();}
    f *= fu;
}

const int N = 80000 + 10;

int fa[N], ch[N][2], rev[N], st[N], len;
int n, m, t;

int isroot(int u) {return ch[fa[u]][0] != u && ch[fa[u]][1] != u;}
int get(int u) {return ch[fa[u]][1] == u;}

void pushdown(int u) {
    if(rev[u]) {
        swap(ch[u][0], ch[u][1]);
        rev[ch[u][0]] ^= 1;
        rev[ch[u][1]] ^= 1;
        rev[u] ^= 1;
    }
}

void rotate(int u) {
    int old = fa[u], oldd = fa[old], k = get(u);
    if(!isroot(old)) ch[oldd][get(old)] = u; fa[u] = oldd;
    fa[ch[u][k ^ 1]] = old; ch[old][k] = ch[u][k ^ 1];
    fa[old] = u; ch[u][k ^ 1] = old;
}

void splay(int u) {
    st[len = 1] = u;
    for(int i = u; !isroot(i); i = fa[i]) st[++len] = fa[i];
    for(int i = len; i >= 1; i--) pushdown(st[i]);
    for(; !isroot(u); rotate(u)) if(!isroot(fa[u])) rotate(get(u) == get(fa[u]) ? fa[u] : u);
}

int access(int u) {
    int tmp;
    for(int i = 0; u; i = u, u = fa[u]) {
        splay(u);
        ch[u][1] = i;
        tmp = u;
    }
    return tmp;
}

void makeroot(int u) {
    access(u);
    splay(u);
    rev[u] ^= 1;
}

void link(int x, int y) {
    makeroot(x);
    fa[x] = y;
}

int LCA(int x, int y) {
    access(x);
    return access(y);
}

int rt[N], val[N * 600], lc[N * 600], rc[N * 600], a[N], b[N];
int tot = 0;

void build(int &u, int l, int r) {
    u = ++tot;
    if(l == r) return;
    int mid = (l + r) >> 1;
    build(lc[u], l, mid);
    build(rc[u], mid + 1, r);
}

void ins(int &u, int pre, int l, int r, int x) {
    u = ++tot;
    val[u] = val[pre] + 1, lc[u] = lc[pre], rc[u] = rc[pre];
    if(l == r) return;
    int mid = (l + r) >> 1;
    if(mid >= x) ins(lc[u], lc[pre], l, mid, x);
    else ins(rc[u], rc[pre], mid + 1, r, x);
}

int query(int a, int b, int c, int d, int l, int r, int k) {
    if(l == r) return l;
    int lsum = val[lc[a]] + val[lc[b]] - val[lc[c]] - val[lc[d]];
    int rsum = val[rc[a]] + val[rc[b]] - val[rc[c]] - val[rc[d]];
    int mid = (l + r) >> 1;
    if(lsum >= k) return query(lc[a], lc[b], lc[c], lc[d], l, mid, k);
    else return query(rc[a], rc[b], rc[c], rc[d], mid + 1, r, k - lsum);
}

int blen;

vector <int> g[N];
int siz[N], head[N];

int f[N]; int find(int x) {return f[x] == x ? x : f[x] = find(f[x]);}

inline void addedge(int u, int v) {
    g[u].push_back(v);
    g[v].push_back(u);
}

void dfs1(int u, int f) {
    ins(rt[u], rt[f], 1, blen, a[u]);
    for(vector <int> :: iterator it = g[u].begin(); it != g[u].end(); it++) {
        int v = *it; if(v == f) continue; dfs1(v, u);
    }
}

void Merge(int a, int b) {
    int x = find(a), y = find(b);
    if(siz[x] < siz[y]) swap(a, b), swap(x, y);
    siz[x] += siz[y]; addedge(a, b); 
    link(a, b); f[y] = x;
    dfs1(b, a);
}

int lastans = 0;

int main() {
    cin >> n;
    cin >> n >> m >> t;
    for(int i = 1; i <= n; i++) {
        scanf("%d", &a[i]);
        b[i] = a[i];
        f[i] = i; siz[i] = 1;
    }
    sort(b + 1, b + n + 1);
    blen = unique(b + 1, b + n + 1) - b - 1;
    for(int i = 1; i <= n; i++) a[i] = lower_bound(b + 1, b + blen + 1, a[i]) - b;
    build(rt[0], 1, blen);
    for(int i = 1; i <= n; i++) {
        ins(rt[i], rt[0], 1, blen, a[i]);
    }
    for(int i = 1; i <= m; i++) {
        int A, B;
        scanf("%d %d", &A, &B);
        Merge(A, B);
    }
    for(int i = 1; i <= t; i++) {
        char c = getchar();
        while(c != 'Q' && c != 'L') c = getchar();
        if(c == 'L') {
            int A, B;
            scanf("%d %d", &A, &B);
            A ^= lastans; B ^= lastans;
            Merge(A, B);
        } else {
            int A, B, K;
            scanf("%d %d %d", &A, &B, &K);
            A ^= lastans; B ^= lastans; K ^= lastans;
            makeroot(find(A));
            int lca = LCA(A, B), father;
            if(find(A) == lca) father = 0;
            else {
                access(lca); splay(lca);
                father = ch[lca][0];
                while(ch[father][1]) {
					father = ch[father][1];
					pushdown(father);
				}
            }
            printf("%d\n", lastans = b[query(rt[A], rt[B], rt[lca], rt[father], 1, blen, K)]);
        }
    }
    return 0;
}
```

---

## 作者：Oxide (赞：5)

# 博主的 BiBi 时间
简直不敢相信自己去年 $9$ 月学过主席树。。。真的一点印象都没了（~~真的太菜了~~）。

另外，这题有个坑点：**$testcase$ 是数据编号，不是数据组数！**
# Solution
主席树一般是处理区间第几大/小的问题。然而这次的场景转移到了树上。

我们可以让 $rt[u]$ 在 $rt[fa[u]]$ 的基础上建树，这样就可以用 $sum[u]+sum[v]-sum[lca(u,v)]-sum[fa[lca(u,v)]]$ 来表示这个路径的某种数值的个数。这里的数值离散化处理就行了。

加边操作我们就用启发式合并。每次选择树的大小较小的重建。

证明一下启发式合并的复杂度。我们对于每个点考虑，考虑一直合并上去的情况（启发式合并就是更改大小较小的那一坨，所以它的复杂度是取决于小坨的大小而不是大坨的），因为是合并上去（这是小坨），合并之后整个坨的大小大于等于小坨的大小 $*2$。所以这个点总共最多合并 $logn$ 次，又因为是每个点考虑的，其实这个点的合并次数就是这个点的复杂度，总复杂度我们累加即可：$O(nlogn)$。

我们算一下空间复杂度。首先我们初始建树是每个点都会建一棵树，每棵树最多加 $logn$ 个点，所以这个空间复杂度为 $S(nlogn)$。

关于后面重建的空间复杂度。之前的是 $nlogn$ 的重建次数（证明在启发式合并证明），每次重建最多加 $logn$ 个点，所以空间复杂度 $S(nlogn^2)$。

总时间复杂度应该是 $O(nlogn^2)$。

博主蒟蒻，如有错误请在评论区指出，我会在第一时间更改。
# Code
```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;

const int N = 8e4 + 5;

int n, m, q, a[N], b[N], len, cnt, head[N], nxt[N << 2], to[N << 2], sz, lc[N * 276], rc[N * 276], sum[N * 276], rt[N], siz[N], dep[N], f[N][18], p[5], lastans, root[N];
bool vis[N];

int read() {
    int x = 0, f = 1; char s;
    while((s = getchar()) < '0' || s > '9') if(s == '-') f = -1;
    while(s >= '0' && s <= '9') {x = (x << 1) + (x << 3) + (s ^ 48); s = getchar();}
    return x * f;
}

void addEdge(const int u, const int v) {
    nxt[++ cnt] = head[u], to[cnt] = v, head[u] = cnt;
}

void update(int &o, const int fa, const int l, const int r, const int p) {
    if(l > p || r < p) return;
    o = ++ sz; lc[o] = lc[fa], rc[o] = rc[fa], sum[o] = sum[fa] + 1;
    if(l == r) return;
    int mid = l + r >> 1;
    update(lc[o], lc[fa], l, mid, p); update(rc[o], rc[fa], mid + 1, r, p);
}

void dfs(const int u, const int fa, const int Root) {
    root[u] = Root; vis[u] = siz[u] = 1; f[u][0] = fa; dep[u] = dep[fa] + 1;
    update(rt[u], rt[fa], 1, len, a[u]);
    for(int i = 1; (1 << i) <= dep[u]; ++ i) f[u][i] = f[f[u][i - 1]][i - 1];
    for(int i = head[u]; i; i = nxt[i]) {
        int v = to[i];
        if(v == fa) continue;
        dfs(v, u, Root);
        siz[u] += siz[v];
    }
}

int lca(int u, int v) {
    if(dep[u] > dep[v]) swap(u, v);
    int d = dep[v] - dep[u];
    for(int i = 0; (1 << i) <= d; ++ i) if((1 << i) & d) v = f[v][i];
    if(u == v) return u;
    for(int i = 16; ~i; -- i)
        if(f[u][i] != f[v][i] && (1 << i) <= dep[v]) u = f[u][i], v = f[v][i];
    return f[u][0];
}

int query(const int l, const int r, const int k) {
    if(l == r) return l;
    int x = sum[lc[p[1]]] + sum[lc[p[2]]] - sum[lc[p[3]]] - sum[lc[p[4]]];
    int mid = l + r >> 1;
    if(x >= k) {
        for(int i = 1; i <= 4; ++ i) p[i] = lc[p[i]];
        return query(l, mid, k);
    }
    else {
        for(int i = 1; i <= 4; ++ i) p[i] = rc[p[i]];
        return query(mid + 1, r, k - x);
    }
}

void init() {
    sz = cnt = lastans = 0;
    memset(vis, 0, sizeof vis);
    memset(head, 0, sizeof head);
}

int main() {
    int u, v, k, T = read(); char s[10];
    T = 1;
    for(; T; -- T) {
        n = read(), m = read(), q = read(); init();
        for(int i = 1; i <= n; ++ i) a[i] = b[i] = read();
        sort(b + 1, b + n + 1);
        len = unique(b + 1, b + n + 1) - b - 1;
        for(int i = 1; i <= n; ++ i) a[i] = lower_bound(b + 1, b + len + 1, a[i]) - b;
        for(int i = 1; i <= m; ++ i) {
            u = read(), v = read();
            addEdge(u, v), addEdge(v, u);
        }
        for(int i = 1; i <= n; ++ i) if(! vis[i]) dfs(i, 0, i);
        while(q --) {
            scanf("%s", s);
            if(s[0] == 'Q') {
                u = read() ^ lastans, v = read() ^ lastans, k = read() ^ lastans;
                int LCA = lca(u, v);
                p[1] = rt[u], p[2] = rt[v], p[3] = rt[LCA], p[4] = rt[f[LCA][0]];
                printf("%d\n", lastans = b[query(1, len, k)]);
            }
            else {
                u = read() ^ lastans, v = read() ^ lastans;
                if(siz[root[u]] < siz[root[v]]) swap(u, v);
                siz[root[u]] += siz[root[v]];
                addEdge(u, v), addEdge(v, u);
                dfs(v, u, root[u]);
            }
        }
    }
    return 0;
}
```

---

## 作者：hongzy (赞：4)

**题意**

你有一个森林，你需要支持两个操作

- 查询两个结点路径上权值第$k$小
- 两个点之间连一条边

强制在线，结点数$\leq 8\times 10^4$

**题解**

如果可以离线，这就是一个主席树板子题，每个点开一个主席树表示树上的前缀和。询问的时候拿出来$4$棵主席树，$x,y,lca(x,y)$和$fa(lca(x,y))$，然后每次用$x,y$的信息减去$lca(x,y),fa(lca(x,y))$的信息就能得到这条链的信息

这里要求在线，可以考虑启发式合并，比如连接$x,y$，若$y$连通块比较小，就把$y$的那个连通块连做$x$的儿子，显然这样$y$的连通块父子关系会改变，需要重新dfs求倍增数组和主席树。启发式合并$O(n \log n)$，主席树带一个$\log$，复杂度应该就是$O(n \log^2n)$

注意一下主席树不要反复新建结点，一个结点建过了第二次再建直接把它原来的信息覆盖了就行。这样空间复杂度就是$O(n\log n)$了qwq

```cpp
#include <algorithm>
#include <cstdio>
#include <vector>
using namespace std;

const int N = 8e4 + 10;

int n, m, q, p, l;
int a[N], b[N], f[N][20], sz[N], d[N];
int id, T[N], ls[N * 20], rs[N * 20], s[N * 20];
vector<int> G[N];

void build(int &rt, int l, int r) {
    rt = ++ id; s[rt] = 0;
    if(l < r) {
        int mid = (l + r) >> 1;
        build(ls[rt], l, mid);
        build(rs[rt], mid + 1, r);;
    }
}

void update(int &rt, int pre, int l, int r, int x) {
    if(!rt) rt = ++ id; s[rt] = s[pre] + 1;
    if(l == r) return ;
    int mid = (l + r) >> 1;
    if(x <= mid) rs[rt] = rs[pre], update(ls[rt], ls[pre], l, mid, x);
    else ls[rt] = ls[pre], update(rs[rt], rs[pre], mid + 1, r, x);
}

int query(int u, int v, int x, int y, int l, int r, int k) {
    if(l == r) return l;
    int sum = s[ls[u]] + s[ls[v]] - s[ls[x]] - s[ls[y]];
    int mid = (l + r) >> 1;
    if(k <= sum) return query(ls[u], ls[v], ls[x], ls[y], l, mid, k);
    return query(rs[u], rs[v], rs[x], rs[y], mid + 1, r, k - sum);
}

void dfs(int u, int fa = 0) {
    f[u][0] = fa; sz[u] = 1; d[u] = d[fa] + 1;
    for(int i = 1; i <= l; i ++)
        f[u][i] = f[f[u][i - 1]][i - 1];
    update(T[u], T[fa], 1, p, a[u]);
    for(int i = 0; i < G[u].size(); i ++) {
        int v = G[u][i];
        if(v != fa) {
            dfs(v, u); sz[u] += sz[v];
        }
    }
}

int find(int u) {
    for(int i = l; i >= 0; i --)
        if(f[u][i]) u = f[u][i];
    return u;
}

int lca(int u, int v) {
    if(d[u] < d[v]) swap(u, v);
    int x = d[u] - d[v];
    for(int i = l; i >= 0; i --)
        if(x >> i & 1) u = f[u][i];
    if(u == v) return u;
    for(int i = l; i >= 0; i --)
        if(f[u][i] != f[v][i]) {
            u = f[u][i]; v = f[v][i];
        }
    return f[u][0];
}

int main() {
    scanf("%*d%d%d%d", &n, &m, &q);
    for(l = 1; (1 << l) <= n; l ++) ;
    for(int i = 1; i <= n; i ++) {
        scanf("%d", a + i); b[i] = a[i];
    }
    sort(b + 1, b + n + 1);
    p = unique(b + 1, b + n + 1) - b - 1;
    for(int i = 1; i <= n; i ++)
        a[i] = lower_bound(b + 1, b + p + 1, a[i]) - b;
    int u, v, k;
    for(int i = 1; i <= m; i ++) {
        scanf("%d%d", &u, &v);
        G[u].push_back(v);
        G[v].push_back(u);
    }
    build(T[0], 1, p);
    for(int i = 1; i <= n; i ++)
        if(!sz[i]) dfs(i);
    char op[4];
    for(int la = 0, i = 1; i <= q; i ++) {
        scanf("%s%d%d", op, &u, &v);
        u ^= la; v ^= la;
        if(* op == 'Q') {
            scanf("%d", &k); k ^= la;
            int t = lca(u, v);
            k = query(T[u], T[v], T[t], T[f[t][0]], 1, p, k);
            printf("%d\n", la = b[k]);
        }
        if(* op == 'L') {
            G[u].push_back(v);
            G[v].push_back(u);
            int x = find(u), y = find(v);
            if(sz[x] < sz[y]) {
                swap(u, v); swap(x, y);
            }
            dfs(v, u); sz[x] += sz[v];
        }
    }
    return 0;
}

```



---

## 作者：2018LZY (赞：4)

主席树+(并查集)启发式合并好题。

## 吐槽：
这道题RE了多次才A，原因竟然是数组开小了。

## 思路：
- 我们用并查集记录所属的树的根，每个点用主席树维护自己到树根路径上的所有值。在询问时，我们先用倍增求出LCA，及LCA的父亲。
那么x,y之间路径上的点就是：x到根的点+y到根的点-LCA到根的点-LCA父亲到根的点**(防止LCA减两次)**.然后就是用类似[模版](https://www.luogu.org/problem/P3834)
方法可以解决的。
- 至于加边，我们用启发式合并。什么意思呢？就是把节点数小的树接到另一棵树。增加的主席树节点为$sz$(节点数小的树的总节点数)$*\log  ~n$。

## 数据范围:

 _主席树的数据范围是一个很迷的问题，如果写错了，望见谅并私信我。_ 

首先，权值这么大，肯定要离散化的——最多有n个权值(那么主席树有n类叶子节点,同类表示同值)。

所以初始化肯定要$O(n*\log n)$的空间复杂度啦。

至于合并产生的最大(主席树)节点数又要怎么求呢？

~~肯定是写个程序跑啦~~
```cpp
#include<cstdio>
using namespace std;
const int N=8e4+10;
int f[N],pos[N];
int main()
{
	int n=N-10;f[1]=0;f[2]=1;
	for(int i=3;i<=n;i++)
	{
		for(int j=(i>>1);j>=1;j--)
			if(f[i]<f[j]+f[i-j]+j)
				f[i]=f[j]+f[i-j]+j,pos[i]=j;
		//printf("f(%d)=f(%d)+f(%d)=%d\n",i,pos[i],i-pos[i],f[i]);
		if(pos[i]!=i>>1){printf("%d no\n",i);return 0;}//这句话没有用，希望得到大佬的严谨证明 
	}
	printf("%d\n",f[n]);
	return 0;
}

```
所以数据范围大概就是310N啦。

具体看代码：
```cpp
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>
#define g getchar()
using namespace std;
const int N=8e4+10;
void qr(int &x)
{
	char c=g;x=0;
	while(!isdigit(c))c=g;
	while(isdigit(c))x=x*10+c-'0',c=g;
}
void write(int x)
{
	if(x/10)write(x/10);
	putchar(x%10+'0');
}
int n,m,T,b[N],p[N],father[N][18],dep[N],fa[N],sz[N];//father用倍增存祖宗。fa,sz用于并查集
//离散化 
bool cmp(int x,int y){return b[x]<b[y];}
void disc()
{
	sort(p+1,p+n+1,cmp);
	int &l=p[0]=0;
	for(int i=1,d=b[p[1]]-1;i<=n;i++)//不用二分的离散化
		if(b[p[i]]!=d)d=b[p[i]],b[p[i]]=++l,p[l]=d;
		else b[p[i]]=l;
	//最后，b为离散化后的值，p装原值
}
//找祖先 
int findfa(int x){return fa[x]==x?x:fa[x]=findfa(fa[x]);} 
//主席树 
struct node{int l,r,s;}tr[N*310];int cnt,root[N];
void update(int l,int r,int &x,int y,int pos)
{
	tr[x=++cnt]=tr[y];tr[x].s++;
	if(l==r)return;
	int mid=(l+r)>>1;
	if(pos<=mid)update(l,mid,tr[x].l,tr[y].l,pos);
	else 	  update(mid+1,r,tr[x].r,tr[y].r,pos);
}
int f,ff;
void LCA(int x,int y)
{
	if(dep[x]<dep[y])swap(x,y);
	for(int i=0,k=dep[x]-dep[y];k;i++)if(k>>i&1)k^=1<<i,x=father[x][i];//dep[x]-dep[y]为需要单跳的次数
	if(x!=y){for(int i=16;i>=0;i--)if(father[x][i]!=father[y][i])x=father[x][i],y=father[y][i];   f=father[x][0];}
	else f=x;//特别注意
	ff=father[f][0];f=root[f];ff=root[ff];
}
int ans;
void query(int x,int y,int k) 
{
	LCA(x,y);x=root[x];y=root[y];
	int l=1,r=p[0],mid,s;
	while(l<r) 
	{
		mid=(l+r)>>1;
		s=tr[tr[x].l].s+tr[tr[y].l].s-tr[tr[f].l].s-tr[tr[ff].l].s;
		if(k<=s)
		{
			x=tr[x].l;  y=tr[y].l;
			f=tr[f].l;ff=tr[ff].l;
			r=mid;
		}
		else
		{
			x=tr[x].r;  y=tr[y].r;
			f=tr[f].r;ff=tr[ff].r;
			l=mid+1;k-=s;
		}
	}
	write(ans=p[l]);puts("");
}
//递归
struct edge{int y,next;}a[N<<1];int len,last[N];
void ins(int x,int y){a[++len]=(edge){y,last[x]};last[x]=len;} 
void dfs(int x,int z)
{
	update(1,p[0],root[x],root[father[x][0]],b[x]);
	fa[x]=z;sz[z]++;
	dep[x]=dep[father[x][0]]+1;
	for(int i=1;i<=16;i++)father[x][i]=0;
	for(int i=1;father[x][i-1];i++)father[x][i]=father[father[x][i-1]][i-1];
	for(int k=last[x];k;k=a[k].next) 
	{
		int y=a[k].y;if(y==father[x][0])continue;
		father[y][0]=x;dfs(y,z);
	}
}
void link(int x,int y)
{
	int tx=findfa(x),ty=findfa(y);
	if(sz[tx]>sz[ty])swap(tx,ty),swap(x,y);
	father[x][0]=y;dfs(x,ty);ins(x,y);ins(y,x);
}
int main()
{
	qr(n);qr(n);qr(m);qr(T);
	for(int i=1;i<=n;i++)qr(b[i]),p[i]=i;
	disc();
	for(int i=1,x,y;i<=m;i++)qr(x),qr(y),ins(x,y),ins(y,x);
	for(int i=1;i<=n;i++)if(!fa[i])dfs(i,i);
	while(T--)
	{
		char s[2];int x,y,k;
		scanf("%s",s);qr(x);qr(y);x^=ans;y^=ans;
		if(s[0]=='Q')qr(k),query(x,y,k^ans);
		else link(x,y);
	}
	return 0;
}
```



---

## 作者：Deep_Kevin (赞：2)

# 正题

       一看到题目，就令人窒息。。。森林

      森林，也就是说一开始有很多棵树。然后要查找路径第k大。

      明显要找lca，就想到了树链剖分。每次往上跳把当前这一段记录下来，很明显要开n棵前缀主席树。

      然后再让找出来的op个区间相减（right-(left-1)），变成op个区间和op个区间相减。所以往下跳即可。

      问题就是加边要重建，而且你不知道你之前用过哪些编号。但是莫名水到30emm。

      而且时间复杂度也承担不起。

      想到一种更令人窒息的做法。

      打破思维格局，每个点继承他的父亲的原有子树，并修改当前点权值所在的链。就是说，当前主席书维护的是根到i点的信息。

      那么找答案也是十分迅捷的，x到y就可以直接用x+y-lca(x,y)-fa(lca(x,y))四棵主席树往下跳即可。

      为什么?

![](https://img-blog.csdn.net/20180528191707560)

      像上面这棵丑陋的树。x点所在的主席树记录的是蓝色三角形的信息，y点记录的是绿色所在点的信息，那么减去lca所记录的信息和lca的父亲所在点所记录的信息就可以得出来橙色线（路径）的信息啦！

      所以我们每次把这个点（lca）找出来（倍增），然后在求解即可。

      对于连边这个东西，我们会想到一种神奇的加快合并的方法——启发式合并，那么我们每次用带权并查集记录一下当前子树的大小即可，重新构图（不怕emm）。

代码<有两份，另外一份太丑陋>

```cpp
#include<cstdio>  
#include<cstdlib>  
#include<cstring>  
#include<iostream>  
#include<queue>  
using namespace std;  
  
int n,m,t;  
int d[160010];  
int f[160010][20];  
int dep[160010];  
int spj[160010];  
int root[2000010];  
int ls[25000010],rs[25000010],c[25000010];  
int we[25000010];  
struct edge{  
    int y,next;  
}s[320010];  
int tot=0,v;  
int op=0;  
int first[80010];  
int son[80010];  
int fa[80010];  
int len=0;  
queue<int> q;  
  
int read(){  
    char ch;  
    ch=getchar();  
    int t=0;  
    while(ch<'0' || ch>'9') ch=getchar();  
    while(ch>='0' && ch<='9') t=t*10+ch-'0',ch=getchar();  
    return t;  
}  
  
int findpa(int x){  
    if(fa[x]!=x) return fa[x]=findpa(fa[x]);  
    return x;  
}  
  
void ins(int x,int y){  
    len++;  
    s[len].y=y;s[len].next=first[x];first[x]=len;  
}  
  
void update(int w,int &now,int x,int y,int num){  
    if(q.empty()) now=++tot;  
    else {  
        now=q.front();  
        q.pop();  
    }  
    ls[now]=ls[w];rs[now]=rs[w];c[now]=c[w];  
    we[now]=num;  
    c[now]++;  
    if(x==y) return ;  
    if(v<=(x+y)/2) update(ls[w],ls[now],x,(x+y)/2,num);  
    else update(rs[w],rs[now],(x+y)/2+1,y,num);  
}  
  
void recycle(int now,int x){  
    if(now==0) return;  
    if(we[ls[now]]==x) recycle(ls[now],x);  
    if(we[rs[now]]==x) recycle(rs[now],x);  
    q.push(now);  
}  
  
void dfs(int x){  
    son[x]=1;  
    fa[x]=f[x][0];  
    if(fa[x]==0) fa[x]=x;  
    for(int i=1;i<=16;i++) f[x][i]=f[f[x][i-1]][i-1];  
    v=d[x];  
    recycle(root[spj[x]],x);  
    update(root[spj[f[x][0]]],root[++op],0,1e9,x);  
    spj[x]=op;  
    for(int i=first[x];i!=0;i=s[i].next){  
        int y=s[i].y;  
        if(y!=f[x][0]){  
            f[y][0]=x;  
            dep[y]=dep[x]+1;  
            dfs(y);  
            son[x]+=son[y];  
        }  
    }  
}  
  
int get_lca(int x,int y){  
    if(dep[x]<dep[y]) swap(x,y);  
    for(int i=16;i>=0;i--)  
        if(dep[f[x][i]]>=dep[y]) x=f[x][i];  
    if(x==y) return x;  
    for(int i=16;i>=0;i--)  
        if(f[x][i]!=f[y][i]){  
            x=f[x][i];  
            y=f[y][i];  
        }  
    return f[x][0];  
}  
  
int solve(int x,int y,int z,int q,int l,int r,int k){  
    if(l==r) return l;  
    int temp=c[ls[x]]+c[ls[y]]-c[ls[z]]-c[ls[q]];  
    if(k<=temp) return solve(ls[x],ls[y],ls[z],ls[q],l,(l+r)/2,k);  
    else return solve(rs[x],rs[y],rs[z],rs[q],(l+r)/2+1,r,k-temp);  
}  
  
int main(){  
    n=read();  
    n=read(),m=read(),t=read();  
    for(int i=1;i<=n;i++) d[i]=read();  
    for(int i=1;i<=m;i++){  
        int x,y;  
        x=read();y=read();  
        ins(x,y);  
        ins(y,x);  
    }  
    for(int i=1;i<=n;i++)  
        if(dep[i]==0){  
            f[i][0]=0;  
            dep[i]=1;  
            dfs(i);  
        }  
    char ch[2];  
    int x,y,k;  
    int last=0;  
    while(t--){  
        scanf("%s",ch);  
        if(ch[0]=='Q'){  
            x=read();y=read();k=read();  
            x^=last;y^=last;k^=last;  
            int lca=get_lca(x,y);  
            printf("%d\n",last=solve(root[spj[x]],root[spj[y]],root[spj[lca]],root[spj[f[lca][0]]],0,1e9,k));  
        }  
        else{  
            x=read();y=read();  
            x^=last;y^=last;  
            int u=findpa(x),v=findpa(y);  
            if(son[u]<son[v]){  
                swap(x,y);  
                swap(u,v);  
            }  
            ins(x,y);  
            ins(y,x);  
            f[y][0]=x;  
            dep[y]=dep[x]+1;  
            dfs(y);  
            son[u]+=son[y];  
        }  
    }  
}
```

---

## 作者：cirnovsky (赞：1)

# Description

小Z有一片森林，含有N个节点，每个节点上都有一个非负整数作为权值。初始的时候，森林中有M条边。

小Z希望执行T个操作，操作有两类：

1. `Q x y k`查询点x到点y路径上所有的权值中，第k小的权值是多少。此操作保证点x和点y连通，同时这两个节点的路径上至少有k个点。
2. `L x y`在点x和点y之间连接一条边。保证完成此操作后，仍然是一片森林。

为了体现程序的在线性，我们把输入数据进行了加密。设lastans为程序上一次输出的结果，初始的时候lastans为0。

- 对于一个输入的操作`Q x y k`,其真实操作为`Q x^lastans y^lastans k^lastans`。
- 对于一个输入的操作`L x y`，其真实操作为`L x^lastans y^lastans`。其中^运算符表示异或，等价于pascal中的xor运算符。

请写一个程序來帮助小Z完成这些操作。

# Solution

查询操作显然可以用主席树来完成，然而连接树的操作又让我们想到了lct。怎么办呢？~~主席树+LCT？~~(据说还真有人这么干)

启发式合并！

没错，我们用选择用主席树来完成这道题，合并时采用启发式合并。

具体来说就是每次合并时都用大小较小的树往大的合并，然后暴力遍历大小较小的树更新倍增数组和主席树即可

```cpp
#pragma GCC diagnostic error "-std=c++11"
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cstring>
#include <queue>
#define _size_ (tr[tr[x].l].size + tr[tr[y].l].size - tr[tr[lca].l].size - tr[tr[fa_lca].l].size)
#define pii pair < int , int >
#define pll pair < LL, LL >
#define mid ((l + r) >> 1)
#define mp make_pair
#define fir first
#define sec second
#define pub push_back
#define pob pop_back

using namespace std;
typedef long long LL;

#define io_e '\0'
#define io_s ' '
#define io_l '\n'
#define _DEBUG_ 1 // debug toggle
namespace Fast_IO {
	#ifndef _DEBUG_
		#define gc() (iS == iT ? (iT = (iS = ibuff) + fread(ibuff, 1, SIZ, stdin), (iS == iT ? EOF : *iS++)) : *iS++)
	#else
		#define gc() getchar()
	#endif
	const int SIZ = 1 << 21 | 1;
	char *iS, *iT, ibuff[SIZ], obuff[SIZ], *oS = obuff, *oT = oS + SIZ - 1, fu[110], c;
	int fr;
	inline void ioout() {
	    fwrite(obuff, 1, oS - obuff, stdout);
	    oS = obuff;
	}
	template <class Type>
	inline void read(Type& x) {
	    x = 0;
	    Type y = 1;
	    for (c = gc(); (c > '9' || c < '0') && c ^ '-'; c = gc())
	        ;
	    c == '-' ? y = -1 : x = (c & 15);
	    for (c = gc(); c >= '0' && c <= '9'; c = gc()) x = x * 10 + (c & 15);
	    x *= y;
	}
	inline bool blank(char ch) { return ch == ' ' || ch == '\n' || ch == '\r' || ch == '\t'; }
	inline void read(char* s) {
	    register char ch = gc();
	    for (; blank(ch); ch = gc())
	        ;
	    for (; !blank(ch); ch = gc()) *s++ = ch;
	    *s = 0;
	}
	inline void read(char& c) {
	    for (c = gc(); blank(c); c = gc())
	        ;
	}
	template <typename Type, typename... Args>
	inline void read(Type& t, Args&... args) {
	    read(t), read(args...);
	}
	template <typename... Args>
	inline void read(char* t, Args&... args) {
	    read(t), read(args...);
	}
	template <typename... Args>
	inline void read(char& t, Args&... args) {
	    read(t), read(args...);
	}
	template <class Type>
	inline void write(char lastChar, Type x) {
	    if (x < 0)
	        *oS++ = '-', x = -x;
	    if (x == 0)
	        *oS++ = '0';
	    while (x) fu[++fr] = x % 10 + '0', x /= 10;
	    while (fr) *oS++ = fu[fr--];
	    *oS++ = lastChar;
	    ioout();
	}
	inline void write(char lastChar, char x[]) {
	    for (register int i = 0; x[i]; ++i) *oS++ = x[i];
	    *oS++ = lastChar;
	    ioout();
	}
	inline void write(char lastChar, char x) {
	    *oS++ = x;
	    *oS++ = lastChar;
	    ioout();
	}
	template <typename Type, typename... Args>
	inline void write(char midChar, Type t, Args... args) {
	    write(midChar, t), write(midChar, args...);
	}
}  // namespace Fast_IO

using Fast_IO::read;
using Fast_IO::write;

const int SIZE = 9e4 + 5;
const int LSIZE = SIZE << 7;
const int GSIZE = SIZE << 1;
int n, m, q, waste;
int tot, rt[LSIZE], b[SIZE];
int pri_n, edge_tot, a[SIZE];
int Head[GSIZE], Next[GSIZE];
int Vertex[GSIZE], Weight[GSIZE];
int f[SIZE][LSIZE / SIZE >> 2];
int dp[SIZE], fa[SIZE], id[SIZE];
int size[SIZE], vis[SIZE];
struct TreeNode {
    int l, r;
    int size;
} tr[LSIZE];

void add(int x, int y, int z = 1) {
    Vertex[++edge_tot] = y, Weight[edge_tot] = z;
    Next[edge_tot] = Head[x], Head[x] = edge_tot;
}

int find_set(int x) {
    return x == fa[x] ? x : fa[x] = find_set(fa[x]);
}

int make(int l, int r) {
    int u = ++tot;
    if (l ^ r) return tr[u].l = make(l, mid), tr[u].r = make(mid + 1, r), u;
    else return 0;
}

void modify(int &u, int pre, int l, int r, int x) {
    u = ++tot;
    tr[u] = TreeNode{tr[pre].l, tr[pre].r, tr[pre].size + 1};
	if (l ^ r)
		if (mid >= x) modify(tr[u].l, tr[pre].l, l, mid, x);
		else modify(tr[u].r, tr[pre].r, mid + 1, r, x);
	else return ;
}

int query(int x, int y, int lca, int fa_lca, int l, int r, int k) {
	if (l ^ r)
		if (_size_ >= k) return query(tr[x].l, tr[y].l, tr[lca].l, tr[fa_lca].l, l, mid, k);
		else return query(tr[x].r, tr[y].r, tr[lca].r, tr[fa_lca].r, mid + 1, r, k - _size_);
	else return l;
}

void dfs(int x, int _rt_) {
	for (int i = 1; i < 17; ++i) f[x][i] = f[f[x][i - 1]][i - 1];
	modify(rt[x], rt[f[x][0]], 1, pri_n, id[x]);
#define y Vertex[i]
	for (int i = Head[x]; i; i = Next[i]) if (y ^ fa[x]) f[y][0] = x, fa[y] = x, dp[y] = dp[x] + 1, vis[x] = true, size[_rt_]++, dfs(y, _rt_);
#undef y
}

int get_lca(int x, int y) {
	if (dp[x] < dp[y]) x ^= y ^= x ^= y;
	for (int i = 16; i >= 0; --i) if (f[x][i] && dp[f[x][i]] >= dp[y]) x = f[x][i];
	if (x == y) return x;
	for (int i = 16; i >= 0; --i) if (f[x][i] ^ f[y][i]) x = f[x][i], y = f[y][i];
	return f[x][0];
}

signed main() {
	read(waste, n, m, q);
	for (int i = 1; i <= n; ++i) read(a[i]), b[i] = a[i];
	sort(b + 1, b + 1 + n);
	pri_n = unique(b + 1, b + 1 + n) - b - 1;
	for (int i = 1; i <= n; ++i) id[i] = lower_bound(b + 1, b + 1 + pri_n, a[i]) - b;
	for (int i = 1, x, y; i <= m; ++i) read(x, y), add(x, y, 1), add(y, x, 1);
	*rt = make(1, pri_n);
	for (int i = 1; i <= n; ++i) if (!vis[i]) dfs(i, i), fa[i] = i;
	int ans = 0, lastans = 0;
	for (int enum_q = 0; enum_q < q; ++enum_q) {
		char opt[5];
		int x, y, k, lca;
		read(opt), read(x, y);
		x ^= lastans, y ^= lastans;
		if (*opt == 'Q') read(k), k ^= lastans, lca = get_lca(x, y), write(io_l, lastans = ans = b[query(rt[x], rt[y], rt[lca], rt[f[lca][0]], 1, pri_n, k)]);
		else {
			add(x, y, 1);
			add(y, x, 1);
			int u = find_set(x);
			int v = find_set(y);
			if (size[u] < size[v]) x ^= y ^= x ^= y, u ^= v ^= u ^= v;
			f[y][0] = x;
			fa[y] = x;
			dp[y] = dp[x] + 1;
			vis[y] = true;
			size[u]++;
			dfs(y, v);
		}
	}
	return 0;
}
```

---

## 作者：ez_lcw (赞：1)

综合性比较强的一道题。

据说有$LCT$+主席树的毒瘤做法，我也不知道这群人码这个东西的信心从哪来 ~~但人家到底是码出来了~~

对于询问，我们考虑用**主席树**实现。

关键是怎么建才能维护一条路径上的。

对于**原树**中的节点$u$，我们在权值线段树中维护的是从根到$u$的所有点的点权。

那么对于$u$到$v$的路径上的点，我们先计算出$lca(u,v)$以及$fa[lca]$，然后我们在询问时这么计算：

```cpp
int query(int u,int v,int lca,int falca,int l,int r,int k)
{
    if(l==r) return l;
    int mid=(l+r)>>1,minus=
    t[t[u].ch[0]].size+t[t[v].ch[0]].size-t[t[lca].ch[0]].size-t[t[falca].ch[0]].size;
    if(minus>=k) 
    	return query(t[u].ch[0],t[v].ch[0],t[lca].ch[0],t[falca].ch[0],l,mid,k);
    else 
    	return query(t[u].ch[1],t[v].ch[1],t[lca].ch[1],t[falca].ch[1],mid+1,r,k-minus);
}
```

$minus$是什么意思呢，我们可以画个图看一下：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191228104834178.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2V6X2xjdw==,size_16,color_FFFFFF,t_70)

其中红色的为我们加上的部分，蓝色的为我们减去的部分，剩下的就是$u\rightarrow v$的路径了。

所以我们就可以用这种方法算第$k$大了。

对于修改，我们考虑用**启发式合并**。

我们每次加边把$size$小的树往$size$大的树合并。

然后暴力遍历那棵$size$小的树，并更新树中点的倍增数组和主席树。

完整代码如下：

```cpp
#include<bits/stdc++.h>
 
#define LN 17
#define N 80010
#define lc t[u].ch[0]
#define rc t[u].ch[1]
 
using namespace std;
 
struct Tree
{
    int ch[2],size;
}t[N<<7];
 
int testcase,n,m,q;
int tot,root[N*LN];
int nn,val[N],b[N];
int cnt,head[N],nxt[N<<1],to[N<<1];
int fa[N][LN],d[N],f[N],size[N];
bool vis[N];
 
void adde(int u,int v)
{
    to[++cnt]=v;
    nxt[cnt]=head[u];
    head[u]=cnt;
}
 
int find(int x)
{
    return x==f[x]?x:f[x]=find(f[x]);
}
 
void work()
{
    sort(b+1,b+n+1);
    nn=unique(b+1,b+n+1)-b-1;
    for(int i=1;i<=n;i++)
        val[i]=lower_bound(b+1,b+nn+1,val[i])-b;
}
 
int build(int l,int r)
{
    int u=++tot;
    if(l==r) return 0;
    int mid=(l+r)>>1;
    lc=build(l,mid);
    rc=build(mid+1,r);
    return u;
}
 
void insert(int &u,int last,int l,int r,int val)
{
    u=++tot;
    t[u]=t[last],t[u].size++;
    if(l==r) return;
    int mid=(l+r)>>1;
    if(val<=mid) insert(lc,t[last].ch[0],l,mid,val);
    else insert(rc,t[last].ch[1],mid+1,r,val);
}
 
int query(int u,int v,int lca,int falca,int l,int r,int k)
{
    if(l==r) return l;
    int mid=(l+r)>>1,minus=t[t[u].ch[0]].size+t[t[v].ch[0]].size-t[t[lca].ch[0]].size-t[t[falca].ch[0]].size;//上面讲到的计算方法
    if(minus>=k) return query(t[u].ch[0],t[v].ch[0],t[lca].ch[0],t[falca].ch[0],l,mid,k);
    else return query(t[u].ch[1],t[v].ch[1],t[lca].ch[1],t[falca].ch[1],mid+1,r,k-minus);
}
 
void dfs(int u,int rt)
{
    vis[u]=true,size[rt]++;
    for(int i=1;i<=16;i++)   
        fa[u][i]=fa[fa[u][i-1]][i-1];//更改倍增数组
    insert(root[u],root[fa[u][0]],1,nn,val[u]);//更新主席树
    for(int i=head[u];i;i=nxt[i])
    {
        int v=to[i];
        if(v==f[u])continue;
        fa[v][0]=u,f[v]=u;
        d[v]=d[u]+1;
        dfs(v,rt);
    }
}
 
int LCA(int a,int b)
{
    if(d[a]<d[b]) swap(a,b);
    for(int i=16;i>=0;i--)
        if(fa[a][i]&&d[fa[a][i]]>=d[b])
            a=fa[a][i];
    if(a==b) return a;
    for(int i=16;i>=0;i--)
        if(fa[a][i]!=fa[b][i])
            a=fa[a][i],b=fa[b][i];
    return fa[a][0];
}
 
int main()
{
    scanf("%d%d%d%d",&testcase,&n,&m,&q);
    for(int i=1;i<=n;i++)
        scanf("%d",&val[i]),b[i]=val[i];
    work();
    for(int i=1;i<=m;i++)
    {
        int u,v;
        scanf("%d%d",&u,&v);
        adde(u,v),adde(v,u);
    }
    root[0]=build(1,nn);
    for(int i=1;i<=n;i++)
    {
        if(!vis[i])
        {
            dfs(i,i);
            f[i]=i;
        }
    }
    int ans=0;
    while(q--)
    {
        char ch=getchar();
        int u,v;
        while(ch!='Q'&&ch!='L') ch=getchar();
        scanf("%d%d",&u,&v);
        u^=ans,v^=ans;
        if(ch=='Q')
        {
            int k;
            scanf("%d",&k);
            k^=ans;
            int lca=LCA(u,v);
            printf("%d\n",ans=b[query(root[u],root[v],root[lca],root[fa[lca][0]],1,nn,k)]);
        }
        if(ch=='L')
        {
            adde(u,v),adde(v,u);
            int a=find(u),b=find(v);
            if(size[a]<size[b])
            {
                swap(a,b);
                swap(u,v);
            }
            fa[v][0]=u,f[v]=u;
            d[v]=d[u]+1;
            dfs(v,a);//暴力遍历
        }
    }
}
```

---

## 作者：7KByte (赞：1)

题意，给一个森林，支持连边和查询路径第K小，强制在线

先考虑本题的弱化版，不强制在线  

我们考虑一个离线算法，先将所有操作读入。因为没有删边操作，所以我们可以将所有连边操作全部统一执行，得到最终森林的形态。然后建立一个虚拟根节点连接所有森林的根节点，得到一棵树，最后做[**Coutn on a tree**](https://www.luogu.org/problemnew/show/P2633)这题。时间复杂度$O(Nlog_2N)$

现在题目要求强制在线，我们只需要稍微修改[**Coutn on a tree**](https://www.luogu.org/problemnew/show/P2633)这题。


首先我们初始化森林的形态，统计每个节点的信息  
 - $Dist_x$  节点$x$到根的距离
 - $F_x[T]$数组 $F[x][i]$表示$x$节点的$2^i$倍祖先，用于求$LCA$
 - $Root_x$  节点$x$到根的路径上的点权构成的权值可持久化线段树的根节点编号
 - $Size_x$  以节点$x$为根的子树的节点数
 
只用一遍DFS即可
```cpp
int u[N],b[N],size[N],F[N][26],d[N];
void dfs(int x,int f){
	root[x]=insert(root[f],1,top,lower_bound(b+1,b+top+1,v[x])-b);
	size[x]=0;fa[x]=f?get(f):x;d[x]=d[f]+1;F[x][0]=f;
	for(int i=1;i<=24;i++)
	  F[x][i]=F[F[x][i-1]][i-1];
	for(int i=h[x];i;i=e[i].next)
	  if(e[i].to!=f)
	    dfs(e[i].to,x),size[x]+=size[e[i].to];
	size[x]++;
}
```

主席树和并查集

```cpp
struct node{
	int l,r;
	int sum;
}a[N<<7];
int tot=0;
int build(int l,int r){
	int p=++tot;
	a[p].sum=0;
	if(l==r)return p;
	int mid=(l+r)>>1;
	a[p].l=build(l,mid);
	a[p].r=build(mid+1,r);
	return p;
}
int insert(int now,int l,int r,int to){
	int p=++tot;
	a[p]=a[now];
	if(l==r){
		a[p].sum++;
		return p;
	}
	int mid=(l+r)>>1;
	if(mid>=to)a[p].l=insert(a[now].l,l,mid,to);
	else a[p].r=insert(a[now].r,mid+1,r,to);
	a[p].sum=a[a[p].l].sum+a[a[p].r].sum;
	return p;
}
int ask(int p,int q,int o,int h,int l,int r,int k){
	if(l==r)return l;
	int sum=(a[a[p].l].sum+a[a[q].l].sum-a[a[o].l].sum-a[a[h].l].sum);
	int mid=(l+r)>>1;
	if(sum>=k)return ask(a[p].l,a[q].l,a[o].l,a[h].l,l,mid,k);
	else return ask(a[p].r,a[q].r,a[o].r,a[h].r,mid+1,r,k-sum);
}
int fa[N],root[N],top=0;
int get(int x){
	return fa[x]==x?x:fa[x]=get(fa[x]);
}
```

对于$L$操作，根据启发式合并原理，暴力更新较小一棵子树的所有数据，再在$x$与$y$之间连边

对于$Q$操作，根据主席树的可加减性质，$root_x+root_y-root_{lca(x,y)}-root_{lca(x,y).fa}$ ，最后递归出最终答案

记得离散化

时间复杂度$O(Nlog_2N)$,空间复杂度$O(Nlog_2N)$


$Code:$

```cpp
#include<bits/stdc++.h>
#define N 80005
using namespace std;
struct edge{
	int to;
	int next;
}e[N<<1];
int n,m,t,v[N],h[N],pop=0;
void add(int x,int y){
	e[++pop].to=y;
	e[pop].next=h[x];
	h[x]=pop;
}
struct node{
	int l,r;
	int sum;
}a[N<<7];
int tot=0;
int build(int l,int r){
	int p=++tot;
	a[p].sum=0;
	if(l==r)return p;
	int mid=(l+r)>>1;
	a[p].l=build(l,mid);
	a[p].r=build(mid+1,r);
	return p;
}
int insert(int now,int l,int r,int to){
	int p=++tot;
	a[p]=a[now];
	if(l==r){
		a[p].sum++;
		return p;
	}
	int mid=(l+r)>>1;
	if(mid>=to)a[p].l=insert(a[now].l,l,mid,to);
	else a[p].r=insert(a[now].r,mid+1,r,to);
	a[p].sum=a[a[p].l].sum+a[a[p].r].sum;
	return p;
}
int ask(int p,int q,int o,int h,int l,int r,int k){
	if(l==r)return l;
	int sum=(a[a[p].l].sum+a[a[q].l].sum-a[a[o].l].sum-a[a[h].l].sum);
	int mid=(l+r)>>1;
	if(sum>=k)return ask(a[p].l,a[q].l,a[o].l,a[h].l,l,mid,k);
	else return ask(a[p].r,a[q].r,a[o].r,a[h].r,mid+1,r,k-sum);
}
int fa[N],root[N],top=0;
int get(int x){
	return fa[x]==x?x:fa[x]=get(fa[x]);
}
int u[N],b[N],size[N],F[N][26],d[N];
void dfs(int x,int f){
	root[x]=insert(root[f],1,top,lower_bound(b+1,b+top+1,v[x])-b);
	size[x]=0;fa[x]=f?get(f):x;d[x]=d[f]+1;F[x][0]=f;
	for(int i=1;i<=24;i++)
	  F[x][i]=F[F[x][i-1]][i-1];
	for(int i=h[x];i;i=e[i].next)
	  if(e[i].to!=f)
	    dfs(e[i].to,x),size[x]+=size[e[i].to];
	size[x]++;
}
int lca(int x,int y){
    if(d[x]>d[y])swap(x,y);
    for(int i=24;i>=0;i--)
      if(d[F[y][i]]>=d[x])y=F[y][i];
    if(y==x)return x;
    for(int i=24;i>=0;i--)
      if(F[x][i]!=F[y][i])
        x=F[x][i],y=F[y][i];
    return F[x][0];
}
int main()
{
	scanf("%d",&n);
	scanf("%d%d%d",&n,&m,&t);
	for(int i=1;i<=n;i++)
	  scanf("%d",&v[i]),u[i]=v[i];
	sort(u+1,u+n+1);
	for(int i=1;i<=n;i++)
	  if(u[i]!=u[i-1])
	    b[++top]=u[i];
	for(int i=1;i<=m;i++)
	{
		int x,y;scanf("%d%d",&x,&y);
		add(x,y);add(y,x);
	}
	for(int i=1;i<=n;i++)fa[i]=i;
	root[0]=build(1,top);
	for(int i=1;i<=n;i++)
	  if(fa[i]==i)dfs(i,0);
	int lastans=0;
	for(int i=1;i<=t;i++){
		char opt[2];scanf("%s",opt);
		int x,y,k;scanf("%d%d",&x,&y);
		x^=lastans;y^=lastans;
		if(opt[0]=='L'){
			if(size[get(x)]>size[get(y)])swap(x,y);
			dfs(x,y);size[get(y)]+=size[x];
			add(x,y);add(y,x);
		}
		else{
			scanf("%d",&k);k^=lastans;
			printf("%d\n",lastans=b[ask(root[x],root[y],root[lca(x,y)],root[F[lca(x,y)][0]],1,top,k)]);
		}
	}
	return 0;
}
```

---

## 作者：Honor誉 (赞：0)


题目要求的是实现两个操作：查询区间k小值和连边操作。

查询：主席树

~~连边：LCT~~

~~主席树+LCT~~

首先码量就有一定压力、程序的实现性，但是也不是不能做。

那有没有一些更容易实现的方法呢？

看起来好像区间k小值应该是主席树跑不掉了，那连边操作呢？

好像可以合并主席树。

但又好像直接时间不太行，那怎么办？

~~答：主席树+LCT~~ 

其实可以启发式合并，对每一棵原树记录它的size，每一次合并的时候就相当于将一棵树合并到另一棵树上，启发式合并，将size小的合并到size大的上面去，每次合并的时候用并查集记录，修改时直接找到并查集顶端的元素即可。

**题目要求的是树上的区间k小，所以要对于树建主席树，其实就是儿子在爸爸的主席树的基础上添加，跟普通的主席树没有太大的区别，仅仅需要dfs建树罢了。**

建树：

```cpp
void insert(int &hao,int last,int l,int r,int x)//插入点
{
	hao=++cnt;
	tr[hao]=tr[last];
	tr[hao].size++;
	if(l==r)
	{
		return;
	}
	int mid=(l+r)>>1;
	if(x<=mid)
	{
		insert(tr[hao].lson,tr[last].lson,l,mid,x);
	}else{
		insert(tr[hao].rson,tr[last].rson,mid+1,r,x);
	}
}
void dfs(int u,int root,int father)//建树（在爸爸的基础上）
{
	fa[u][0]=father;//这里更新lca，查询要用
	for(int i=1;i<=17;i++)
	{
		fa[u][i]=fa[fa[u][i-1]][i-1];
	}
	vis[u]=1;
	size[root]++;
	deep[u]=deep[father]+1;
	fas[u]=father;
	insert(rt[u],rt[father],1,cnt1,lower_bound(b+1,b+cnt1+1,a[u])-b);
	for(int i=head[u];i;i=nxt[i])
	{
		int v=to[i];
		if(v!=father)
		{
			dfs(v,root,u);
		}
	}
}
```

查询时就是像普通主席树一样。

![在这里插入图片描述](https://img-blog.csdnimg.cn/2019122810395529.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1MDE5NDY4,size_16,color_FFFFFF,t_70)

题目要求的是一条路径，所以需要四个地方的size：lca的父亲，lca,x,y

**像图中这样x到根的路径，y到根的路径减去lca到根的路径，lca的父亲到根的路径，就得到了要求的路径。**

这条路径上的点数就是$x.size+y.size-lca.size-lca的父亲.size$,同理，左边的主席树的size也可以求的，从而确定是往左找还是往右找。

查询：

```cpp
int query(int hao,int hao1,int lca,int falca,int l,int r,int k)
{
	if(l==r)
	{
		return b[l];
	}
	int mid=(l+r)/2
	int midsize=tr[tr[hao].lson].size+tr[tr[hao1].lson].size-tr[tr[lca].lson].size-tr[tr[falca].lson].size;//主席树左边的size
	if(midsize>=k)//往左找或往右找
	{
		return query(tr[hao].lson,tr[hao1].lson,tr[lca].lson,tr[falca].lson,l,mid,k);
	}else{
		return query(tr[hao].rson,tr[hao1].rson,tr[lca].rson,tr[falca].rson,mid+1,r,k-midsize);
	}
}
```

程序：

```cpp
#pragma GCC optimize(3)
#pragma GCC optimize(2)
#include<bits/stdc++.h>
#define N 80010
using namespace std;
struct data
{
	int size,lson,rson;
}tr[N*500];
int to[N<<2],nxt[N<<2],nct,head[N],fas[N],fa[N][18],cnt,rt[N],cnt1,a[N],b[N],size[N],deep[N],n,m,k,x,y,t,lastans;
char s[3];
bool vis[N];
void adde(int x,int y)
{
	to[++nct]=y;
	nxt[nct]=head[x];
	head[x]=nct;
}
int get_fa(int x)//并查集找爸爸
{
	if(fas[x]==x)
	{
		return x;
	}
	return fas[x]=get_fa(fas[x]);
}
void build(int &hao,int l,int r)//建一棵空的树，便于操作
{
	hao=++cnt;
	tr[hao].size=0;
	if(l==r)
	{
		return;
	}
	int mid=(l+r)>>1;
	build(tr[hao].lson,l,mid);
	build(tr[hao].rson,mid+1,r);
}
void insert(int &hao,int last,int l,int r,int x)//插入点
{
	hao=++cnt;
	tr[hao]=tr[last];
	tr[hao].size++;
	if(l==r)
	{
		return;
	}
	int mid=(l+r)>>1;
	if(x<=mid)
	{
		insert(tr[hao].lson,tr[last].lson,l,mid,x);
	}else{
		insert(tr[hao].rson,tr[last].rson,mid+1,r,x);
	}
}
void dfs(int u,int root,int father)//建树（在爸爸的基础上）
{
	fa[u][0]=father;//这里更新lca，查询要用
	for(int i=1;i<=17;i++)
	{
		fa[u][i]=fa[fa[u][i-1]][i-1];
	}
	vis[u]=1;
	size[root]++;
	deep[u]=deep[father]+1;
	fas[u]=father;
	insert(rt[u],rt[father],1,cnt1,lower_bound(b+1,b+cnt1+1,a[u])-b);
	for(int i=head[u];i;i=nxt[i])
	{
		int v=to[i];
		if(v!=father)
		{
			dfs(v,root,u);
		}
	}
}
int get_lca(int x,int y)
{
	if(deep[x]<deep[y])
	{
		swap(x,y);
	}
	for(int i=17;i>=0;i--)
	{
		if(deep[fa[x][i]]>=deep[y])
		{
			x=fa[x][i];
		}
	}
	if(x==y)
	{
		return x;
	}
	for(int i=17;i>=0;i--)
	{
		if(fa[x][i]!=fa[y][i])
		{
			x=fa[x][i];
			y=fa[y][i];
		}
	}
	return fa[x][0];
}
int query(int hao,int hao1,int lca,int falca,int l,int r,int k)
{
	if(l==r)
	{
		return b[l];
	}
	int mid=(l+r)/2,midsize=tr[tr[hao].lson].size+tr[tr[hao1].lson].size-tr[tr[lca].lson].size-tr[tr[falca].lson].size;//主席树左边的size
	if(midsize>=k)//往左找或往右找
	{
		return query(tr[hao].lson,tr[hao1].lson,tr[lca].lson,tr[falca].lson,l,mid,k);
	}else{
		return query(tr[hao].rson,tr[hao1].rson,tr[lca].rson,tr[falca].rson,mid+1,r,k-midsize);
	}
}
int main()
{
//	freopen("1.txt","r",stdin);
	scanf("%d",&n);
	scanf("%d%d%d",&n,&m,&t);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&a[i]);
		b[i]=a[i];
		fas[i]=i;
	}
	sort(b+1,b+n+1);//离散化
	cnt1=unique(b+1,b+n+1)-b-1;
	for(int i=1;i<=m;i++)
	{
		scanf("%d%d",&x,&y);
		adde(x,y);
		adde(y,x);
	}
	build(rt[0],1,cnt1);
	for(int i=1;i<=n;i++)
	{
		if(!vis[i])
		{
			dfs(i,i,0);
			fas[i]=i;//重新确定并查集顶端元素，不然会TLE
		}
	}
	while(t--)//操作
	{
		scanf("%s%d%d",s,&x,&y);
		x^=lastans;
		y^=lastans;
		if(s[0]=='Q')
		{
			scanf("%d",&k);
			k^=lastans;
			int lca=get_lca(x,y);
			printf("%d\n",lastans=query(rt[x],rt[y],rt[lca],rt[fa[lca][0]],1,cnt1,k));
		}else{
			adde(x,y);
			adde(y,x);
			int xx=get_fa(x),yy=get_fa(y);
			if(size[xx]<size[yy])
			{
				swap(xx,yy);
				swap(x,y);
			}
			dfs(y,xx,x);
		}
	}
	return 0;
}
```

---

## 作者：kkxhh (赞：0)

这题有两个操作，树上路径 $k$ 小显然可以直接用主席树维护，但是连边操作要怎么处理呢

我们可以考虑启发式合并

每次合并两个两棵树时，暴力修改每个节点的主席树，可以证明总的修改次数是 $O(nlogn)$ 的，这显然在我们的可承受范围内

同时我们还发现在查询时，我们还会用到两点的 $lca$，于是我们还得高效合并 $lca$ 的信息，显然倍增求 $lca$ 符合我们的需求，在合并时直接维护即可

代码如下：

```cpp
#include <cstdio>
#include <algorithm>
using namespace std;

typedef struct node{
    int ls,rs,sum;
}node;

typedef struct edge{
    int next,to;
}edge;

edge e[160010];
node t[10000010];
int n,m,q,v[80010],siz,tot,fa[18][80010],a[80010],dep[80010],root[80010],sz[80010],sf[80010],head[80010],et,lasans;

inline int read(){
    int num=0,k=1; char c=getchar();
    while(c>'9' || c<'0') k=(c=='-')?0:k,c=getchar();
    while(c>='0' && c<='9') num=num*10+c-'0',c=getchar();
    return k?num:-num;
}

inline int readopt(){
    char c=getchar();
    while(c!='Q' && c!='L') c=getchar();
    return c=='Q';
}

void addegde(int u,int v){
    e[++et].to=v; e[et].next=head[u]; head[u]=et;
    e[++et].to=u; e[et].next=head[v]; head[v]=et;
}

void update(int x) {t[x].sum=t[t[x].ls].sum+t[t[x].rs].sum;}

int build(int l,int r){
    if(l==r) return ++tot;
    int cur=++tot,mid=(l+r)>>1;
    t[cur].ls=build(l,mid); t[cur].rs=build(mid+1,r);
    update(cur);
    return cur;
}

int modify(int o,int l,int r,int q){
    if(l==r) {t[++tot].sum=t[o].sum+1; return tot;}
    int mid=(l+r)>>1,cur=++tot;
    if(q<=mid) t[cur].ls=modify(t[o].ls,l,mid,q),t[cur].rs=t[o].rs;
    else t[cur].ls=t[o].ls,t[cur].rs=modify(t[o].rs,mid+1,r,q);
    update(cur);
    return cur;
}

int find(int x){
    int l=0,r=siz+1,mid;
    while(l+1<r){
        mid=(l+r)>>1;
        if(v[mid]<x) l=mid;
        else r=mid;
    }
    return r;
}

int lca(int x,int y){
    if(dep[x]<dep[y]) swap(x,y);
    int dp=dep[x]-dep[y];
    for(int i=17;i>=0;i--) if(dp>=(1<<i)) x=fa[i][x],dp-=(1<<i);
    if(x==y) return x;
    for(int i=17;i>=0;i--){
        if(!fa[i][x] || fa[i][x]==fa[i][y]) continue;
        x=fa[i][x]; y=fa[i][y];
    }
    return fa[0][x];
}

int sfind(int x){
    if(sf[x]!=x) return sf[x]=sfind(sf[x]);
    return x; 
}

void dfs(int x,int f){
    dep[x]=dep[f]+1; fa[0][x]=f; root[x]=modify(root[f],1,siz,a[x]);
    for(int i=1;i<=17;i++) fa[i][x]=fa[i-1][fa[i-1][x]];
    for(int i=head[x];i;i=e[i].next) if(e[i].to!=f) dfs(e[i].to,x);
}

void link(int x,int y){
    if(sz[sfind(y)]>sz[sfind(x)]) swap(x,y);
    sz[sfind(x)]+=sz[sfind(y)]; sf[sfind(y)]=sfind(x);
    dfs(y,x); addegde(x,y);
}

int query(int x,int y,int k,int l,int r){
    int cur[4],ll=lca(x,y),lw,mid;
    cur[0]=root[x]; cur[1]=root[y]; cur[2]=root[ll]; cur[3]=root[fa[0][ll]];
    while(l!=r){
        mid=(l+r)>>1;
        lw=t[t[cur[0]].ls].sum+t[t[cur[1]].ls].sum-t[t[cur[2]].ls].sum-t[t[cur[3]].ls].sum;
        if(k<=lw){
            r=mid;
            for(int i=0;i<4;i++) cur[i]=t[cur[i]].ls;
        }
        else{
            l=mid+1; k-=lw;
            for(int i=0;i<4;i++) cur[i]=t[cur[i]].rs;
        }
    }
    return v[l];
}

int main(){
    read(); n=read(); m=read(); q=read();
    for(int i=1;i<=n;i++) v[++siz]=a[i]=read(),sz[i]=1,sf[i]=i,dep[i]=1;
    sort(v+1,v+1+siz);
    siz=unique(v+1,v+1+siz)-1-v;
    for(int i=1;i<=n;i++) a[i]=find(a[i]);
    root[0]=build(1,siz);
    for(int i=1;i<=m;i++){
        int x=read(),y=read();
        if(sz[sfind(y)]>sz[sfind(x)]) swap(x,y);
        sz[sfind(x)]+=sz[sfind(y)]; sf[sfind(y)]=sfind(x);
        addegde(x,y);
    }
    for(int i=1;i<=n;i++) if(!root[i]) dfs(i,0);
    while(q--){
        if(readopt()){
            int x=read()^lasans,y=read()^lasans,k=read()^lasans;
            printf("%d\n",lasans=query(x,y,k,1,siz));
        }
        else{
            int x=read()^lasans,y=read()^lasans;
            link(x,y);
        }
    }
}

```

---

## 作者：GoldenPotato137 (赞：0)

[戳我获得更好的阅读体验qwq](https://www.goldenpotato.cn/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/luogu-p3302-sdoi2013%E6%A3%AE%E6%9E%97/)

---
# Solution
拿到这道题，我们不妨先想一下静态的树上K大怎么搞。
静态树上K大有两种办法，一是树链剖分+平衡树，二是主席树做链前缀和。前者的复杂度是$O(log^2n)$的，而后者只有$O(logn)$。

我们考虑把数字全部离散化，然后开权值主席树，每颗主席树记录从它出发到根的路上每个数字出现了多少个。接下来，我们只需要找到LCA。因为数字出现个数满足可减性，因此，我们是可以“扣”出从这个点到LCA的路径的，我们把两条路径合并到一颗主席树上，做树上二分即可。

接下来考虑如何处理边合并的问题。考虑启发式暴力合并。我们把小的那棵树合并到大的那棵树上，暴力重构小的那棵树的每个点的主席树，也暴力重构每个点的depth，fa来计算LCA即可。

启发式合并中，每个点的重构次数期望为$logn$次，因此，我们的总复杂度为$O(nlog^2n)$

就酱，这题我们就切掉啦(～￣▽￣)～ 

---
# Code
**细节繁多，请各位dalao小心**
```cpp
//Luogu P3302 [SDOI2013]森林
//Mar,6th,2019
//主席树启发式合并维护动态树树链K大
#include<iostream>
#include<cstdio>
#include<vector>
#include<cstring>
#include<algorithm>
using namespace std;
long long read()
{
	long long x=0,f=1; char c=getchar();
	while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
	while(isdigit(c)){x=x*10+c-'0';c=getchar();}
	return x*f;
}
const int N=80000+2000;
struct SegmentTree
{
	#define mid ((now_l+now_r)>>1)
	static const int M=400*N;
	int son[M][2],size[M],to;
	inline void update(int now)
	{
		size[now]+=size[son[now][0]]+size[son[now][1]];
	}
	inline void Add(int now,int pre,int x,int now_l,int now_r)
	{
		if(now_l==now_r)
		{
			size[now]=size[pre]+1;
			return;
		}
		if(x<=mid) 
		{
			Add(son[now][0]=++to,son[pre][0],x,now_l,mid);
			son[now][1]=son[pre][1];
		}
		else
		{
			Add(son[now][1]=++to,son[pre][1],x,mid+1,now_r);
			son[now][0]=son[pre][0];
		}
		update(now);
	}
	int Query(int now1,int now2,int pre1,int pre2,int x,int now_l,int now_r)
	{
		if(now_l==now_r) return now_l;
		if(x<=size[son[now1][0]]-size[son[pre1][0]]+size[son[now2][0]]-size[son[pre2][0]])
			return Query(son[now1][0],son[now2][0],son[pre1][0],son[pre2][0],x,now_l,mid);
		else
			return Query(son[now1][1],son[now2][1],son[pre1][1],son[pre2][1],x-(size[son[now1][0]]-size[son[pre1][0]]+size[son[now2][0]]-size[son[pre2][0]]),mid+1,now_r);
	}
	void Print(int now,int now_l,int now_r)
	{
		cerr<<"no."<<now<<" l&r:"<<now_l<<" "<<now_r<<" sonl&r:"<<son[now][0]<<" "<<son[now][1]<<" size:"<<size[now]<<endl;
		if(now_l!=now_r)
			Print(son[now][0],now_l,mid),
			Print(son[now][1],mid+1,now_r);
	}
	#undef mid
}sgt;
vector <int> e[N];
int n,m,q,w[N],mmap[N];//mmap:离散值->真实值
int fa[N][21],size[N],depth[N],root[N];
bool vis[N];
void dfs(int now)
{
	for(int i=1;i<=20;i++)
		fa[now][i]=fa[fa[now][i-1]][i-1];
	vis[now]=true;
	for(int i=0;i<int(e[now].size());i++)
		if(vis[e[now][i]]==false)
		{
			depth[e[now][i]]=depth[now]+1;
			fa[e[now][i]][0]=now;
			root[e[now][i]]=++sgt.to;
			sgt.Add(root[e[now][i]],root[now],w[e[now][i]],1,m);
			//sgt.Print(root[e[now][i]],1,m);
			//cerr<<endl;
			dfs(e[now][i]);
		}
	vis[now]=false;
}
void Merge(int x,int y)
{
	if(size[fa[x][20]]>size[fa[y][20]]) swap(x,y);
	size[fa[y][20]]+=size[fa[x][20]];
	depth[x]=depth[y]+1;
	fa[x][0]=y;
	root[x]=++sgt.to;
	sgt.Add(root[x],root[y],w[x],1,m);
	//sgt.Print(root[x],1,m);
	//cerr<<endl;
	dfs(x);
	e[x].push_back(y);
	e[y].push_back(x);
}
int LCA(int x,int y)
{
	if(depth[x]<depth[y]) swap(x,y);
	for(int i=20;i>=0;i--)
		if(depth[fa[x][i]]>=depth[y])
			x=fa[x][i];
	if(x==y) return x;
	for(int i=20;i>=0;i--)
		if(fa[x][i]!=fa[y][i])
			x=fa[x][i],y=fa[y][i];
	return fa[x][0];
}
int Query(int x,int y,int K)
{
	if(depth[x]<depth[y]) swap(x,y);
	int lca=LCA(x,y);
	if(lca==y)
		return mmap[sgt.Query(root[x],0,(fa[lca][0]==lca?0:root[fa[lca][0]]),0,K,1,m)];
	else
		return mmap[sgt.Query(root[x],root[y],root[lca],(fa[lca][0]==lca?0:root[fa[lca][0]]),K,1,m)];
}
void Init()
{
	for(int i=0;i<=n;i++)
		e[i].reserve(4);
	for(int i=1;i<=n;i++)
	{
		root[i]=++sgt.to;
		sgt.Add(root[i],0,w[i],1,m);
	}
	for(int i=1;i<=n;i++)
		size[i]=1,depth[i]=1;
	for(int i=1;i<=n;i++)
		for(int j=0;j<=21;j++)
			fa[i][j]=i;
}
int m2;
int main()
{
	static int tmp[N];
	n=read(),n=read(),m2=read(),q=read();
	for(int i=1;i<=n;i++)
		tmp[i]=w[i]=read();
	
	sort(tmp+1,tmp+1+n);
	m=unique(tmp+1,tmp+1+n)-tmp-1;
	for(int i=1;i<=n;i++)
	{
		int temp=lower_bound(tmp+1,tmp+1+m,w[i])-tmp;
		mmap[temp]=w[i];
		w[i]=temp;
	}
	Init();
		
	for(int i=1;i<=m2;i++)
	{
		int x=read(),y=read();
		Merge(x,y);
	}
	
	int ans=0;
	char OP[5];
	for(int i=1;i<=q;i++)
	{
		scanf("%s",OP+1);
		if(OP[1]=='Q')
		{
			int x=read()^ans,y=read()^ans,K=read()^ans;
			printf("%d\n",ans=Query(x,y,K));
		}
		else
		{
			int x=read()^ans,y=read()^ans;
			Merge(x,y);
		}
		//ans=0;
	}
	return 0;
}

```





---

## 作者：_ctz (赞：0)

[更好的阅读体验$QwQ$](https://ctz45562.github.io/2019/03/01/%E9%A2%98%E8%A7%A3-%E6%B4%9B%E8%B0%B7-P3302-%E3%80%90-SDOI2013-%E6%A3%AE%E6%9E%97%E3%80%91/)

[传送门](https://www.luogu.org/problemnew/show/P3302)

强制在线资瓷连边的树上$K$大（小）值。

静态树上$K$大值可以用主席树，结合$LCA$加加减减就行。

要求连边，可以启发式合并主席树。其实也可以说重构主席树。维护一下每个点所在的树的$size$，连接两点，选择$size$较小的连到较大的上去，即重新$dfs$一遍。

由于每个点合并一次后$size$至少翻倍，所以最多被合并$logn$次。重构一个点主席树复杂度为$O(logn)$，总复杂度$O(nlog^2n)$。

维护$size$珂以用并查集。因为要改变树的形态，树剖$LCA$不能用了，珂以用倍增$LCA$或者$LCT$求$LCA$。（蒟蒻以前一直用的树剖$LCA$，结果倍增写假了调了两天$QAQ$）

空间上可以重复利用之前的点，不过蒟蒻~~懒得写~~想省时间所以没有，所以单点重构主席树要开$O(logn)$个节点，空间复杂度$O(nlog^2n)$。

细节：值域很大，需要离散化

代码：

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <cstring>

#define maxn 80005
#define inf 0x3f3f3f3f
#define pn putchar('\n')
#define px(x) putchar(x)
#define ps putchar(' ')
#define pd puts("======================")
#define pj puts("++++++++++++++++++++++")

using namespace std;

inline int read(){
    int x=0,y=0;
    char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')y=1;ch=getchar();}
    while(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
    return y?-x:x;
}
template<typename T>
inline T read(){
    T x=0;
    int y=0;
    char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')y=1;ch=getchar();}
    while(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
    return y?-x:x;
}
int h[maxn],num,F[maxn],siz[maxn];
//F是并查集
struct edge{
    int pre,to;
}e[maxn<<1];
inline void add(int from,int to){
    e[++num].pre=h[from],h[from]=num,e[num].to=to;
}
int find(int x){
    if(F[x]==x)return x;
    return F[x]=find(F[x]);
}
int n,len,dis[maxn],a[maxn],root[maxn],fa[maxn][32],lg[maxn],deep[maxn];
//dis是离散化数组
struct Chairman_Tree{
    int dat[maxn*400],ls[maxn*400],rs[maxn*400],cnt;
#define ls(x) ls[x]
#define rs(x) rs[x]
    void build(int poi,int ne,int ol){
        int l=1,r=len;
        while(l<r){
            dat[ne]=dat[ol]+1;
            int mid=l+r>>1;
            if(poi<=mid)rs(ne)=rs(ol),ol=ls(ol),ne=ls(ne)=++cnt,r=mid;	
            else ls(ne)=ls(ol),ol=rs(ol),ne=rs(ne)=++cnt,l=mid+1;
        }
        dat[ne]=dat[ol]+1;
    }//主席树重构
    int ask(int x,int y,int lc,int fl,int k){
        //lc是lca，fl为lca的父亲
        int l=1,r=len;
        while(l<r){
            int mid=l+r>>1,sum=dat[ls(x)]+dat[ls(y)]-dat[ls(lc)]-dat[ls(fl)];
            if(sum>=k)x=ls(x),y=ls(y),lc=ls(lc),fl=ls(fl),r=mid;
            else x=rs(x),y=rs(y),lc=rs(lc),fl=rs(fl),l=mid+1,k-=sum;
        }
        return dis[l];
    }//查询
}ct;
int lca(int x,int y){
    if(deep[x]<deep[y])swap(x,y);
    while(deep[x]>deep[y])x=fa[x][lg[deep[x]-deep[y]]-1];
    if(x==y)return x;
    for(register int i=lg[deep[x]];i>=0;--i)
        if(fa[x][i]!=fa[y][i])
			x=fa[x][i],y=fa[y][i];
    return fa[x][0];
}//倍增lca
void dfs(int node,int f){
    deep[node]=deep[f]+1;
    root[node]=++ct.cnt;
    ct.build(a[node],root[node],root[f]);
    fa[node][0]=f;
    int top=lg[deep[node]];
    for(register int i=1;i<=top;++i)
        fa[node][i]=fa[fa[node][i-1]][i-1];
    for(register int i=h[node];i;i=e[i].pre){
        int x=e[i].to;
        if(x!=f)siz[node]+=siz[x],dfs(x,node);
    }	
}
void merge(int x,int y){
    add(x,y),add(y,x);
    int u=find(x),v=find(y);
    if(siz[u]>siz[v])swap(x,y),swap(u,v);
    siz[v]+=siz[u];
    dfs(x,y);
}
int spget(){
	char ch=getchar();
	while(ch!='Q'&&ch!='L')ch=getchar();
	return ch=='Q';
}//获取字符的
Kafuu Chino(){
//	freopen("file.in","r",stdin);
//	freopen("juruo.out","w",stdout);
    read();
    n=read();
    int m=read(),t=read();
    for(register int i=1;i<=n;++i)
        F[i]=i,a[i]=dis[i]=read(),lg[i]=lg[i-1]+(1<<lg[i-1]==i);
    sort(dis+1,dis+1+n);
    len=unique(dis+1,dis+1+n)-dis-1;
    for(register int i=1;i<=n;++i)
        a[i]=lower_bound(dis+1,dis+1+len,a[i])-dis;
    //离散化
    for(register int i=1;i<=m;++i){
        int a=read(),b=read();
        add(a,b),add(b,a);
    }
    for(register int i=1;i<=n;++i)
        if(!deep[i])dfs(i,0);
	for(register int i=1;i<=n;++i)
		if(fa[i][0])F[i]=fa[i][0];
    //初始化并查集
	for(register int i=1;i<=n;++i)
		++siz[find(i)];
    //初始化size
    int ans=0;
    for(register int i=1;i<=t;++i){
        int s=spget(),x=read()^ans,y=read()^ans;
        if(s){
            int k=read()^ans,l=lca(x,y);
            printf("%d\n",ans=ct.ask(root[x],root[y],root[l],root[fa[l][0]],k));
        }
        else merge(x,y);
    }
}
```







---

## 作者：xudaxia (赞：0)

### [SDOI2013]森林
>询问一个森林中两点间路径经过点的第k小，动态连边。保证是一个森林。强制在线。   

首先我们可以在树上建主席树，每一个点建一颗权值线段树，继承他父亲线段树的信息。  
然后处理询问时，我们可以用$sum[x]+sum[y]-sum[lca]-sum[fa[lca]]$来表示$x,y$路径上的权值线段树。然后我们在这4个权值线段树树上二分就行了。
然后我们如何处理，动态连边呢。我们用启发式合并的思想，把小的树接在大的树上面，然后在小树里$dfs$重构就行了。  
```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<cmath>
#include<algorithm>
using namespace std;
const int N=101000;
int cnt,head[N],f[N],fa[N][23],dep[N],root[N],a[N],size[N],b[N],tot;
int sum[N*600],ch[N*600][2],num,n,m,q,ans;
struct edge{
    int to,nxt;
}e[N*2];
void add_edge(int u,int v){
    cnt++;
    e[cnt].nxt=head[u];
    e[cnt].to=v;
    head[u]=cnt;
    cnt++;
    e[cnt].nxt=head[v];
    e[cnt].to=u;
    head[v]=cnt;
}
int find(int x){
    if(f[x]==x)return x;
    else return f[x]=find(f[x]);
}
void merge(int x,int y){
    int fx=find(x),fy=find(y);
    f[fy]=fx;size[fx]+=size[fy];
}
int getlca(int x,int y){
    if(dep[x]<dep[y])swap(x,y);
    for(int i=20;i>=0;i--)
        if(dep[fa[x][i]]>=dep[y])x=fa[x][i];
    if(x==y)return x;
    for(int i=20;i>=0;i--)
        if(fa[x][i]!=fa[y][i])x=fa[x][i],y=fa[y][i];
    return fa[x][0];
}
void build(int l,int r,int &now){
    now=++num;
    if(l==r)return;
    int mid=(l+r)>>1;
    build(l,mid,ch[now][0]);
    build(mid+1,r,ch[now][1]);
}
void add(int l,int r,int x,int pre,int &now){
    now=++num;
    sum[now]=sum[pre]+1;
    if(l==r)return;
    ch[now][0]=ch[pre][0];
    ch[now][1]=ch[pre][1];
    int mid=(l+r)>>1;
    if(x>mid)add(mid+1,r,x,ch[pre][1],ch[now][1]);
    else add(l,mid,x,ch[pre][0],ch[now][0]);
}
void dfs(int u,int f){
    fa[u][0]=f;
    for(int i=1;i<=20;i++)fa[u][i]=fa[fa[u][i-1]][i-1];
    dep[u]=dep[f]+1;
    add(1,tot,a[u],root[f],root[u]);
    for(int i=head[u];i;i=e[i].nxt){
        int v=e[i].to;
        if(v==f)continue;
        dfs(v,u);
    }
}
int check(int x,int y,int lca,int flca,int l,int r,int k){
    while(l<r){
        int mid=(l+r)>>1;
        int tmp=sum[ch[x][0]]+sum[ch[y][0]]-sum[ch[lca][0]]-sum[ch[flca][0]];
        if(tmp>=k)x=ch[x][0],y=ch[y][0],lca=ch[lca][0],flca=ch[flca][0],r=mid;
        else k-=tmp,x=ch[x][1],y=ch[y][1],lca=ch[lca][1],flca=ch[flca][1],l=mid+1;
    }
    return b[l];
}
int read(){
    int sum=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){sum=sum*10+ch-'0';ch=getchar();}
    return sum*f;
}
int main(){
    int hhh=read();
    n=read(),m=read(),q=read();
    for(int i=1;i<=n;i++)f[i]=i,size[i]=1,a[i]=read(),b[i]=a[i];
    sort(b+1,b+1+n);
    tot=unique(b+1,b+1+n)-b-1;
    for(int i=1;i<=n;i++)a[i]=lower_bound(b+1,b+1+tot,a[i])-b;
    build(1,tot,root[0]);
    for(int i=1;i<=m;i++){
        int u=read(),v=read();
        add_edge(u,v);merge(u,v);
    }
    for(int i=1;i<=n;i++)
        if(f[i]==i)dfs(i,0);
    char s[3];
    while(q--){
        scanf("%s",s);
        if(s[0]=='Q'){
            int x=read(),y=read(),k=read();
            x^=ans;y^=ans;k^=ans;
            int lca=getlca(x,y);
            ans=check(root[x],root[y],root[lca],root[fa[lca][0]],1,tot,k);
            printf("%d\n",ans);
        }
        else{
            int x=read()^ans,y=read()^ans;
            if(size[x]>size[y])swap(x,y);
            add_edge(x,y);merge(x,y);dfs(y,x);
        }
    }
    return 0;
}
```

---


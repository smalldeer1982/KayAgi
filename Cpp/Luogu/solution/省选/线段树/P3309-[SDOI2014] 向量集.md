# [SDOI2014] 向量集

## 题目描述

维护一个向量集合，在线支持以下操作：

- `A x y`（$|x|,|y| \le 10^8$）：加入向量 $(x,y)$；
- `Q x y l r`（$|x|,|y| \le 10^8$，$1 \le l \le r \le t$，其中 $t$ 为已经加入的向量个数）：询问第 $l$ 个到第 $r$ 个加入的向量与向量 $(x,y)$ 的点积的最大值。

集合初始时为空。

## 说明/提示

样例解释：解密之后的输入为
```
    6 E
    A 3 2
    Q 1 5 1 1
    A 2 3
    A 1 4
    Q 1 5 1 2
    Q 4 3 2 3
```


## 样例 #1

### 输入

```
6 A
A 3 2
Q 1 5 1 1
A 15 14
A 12 9
Q 12 8 12 15
Q 21 18 19 18```

### 输出

```
13
17
17
```

# 题解

## 作者：qwaszx (赞：12)

不失一般性设当前询问的$y_0>0$，那么$\dfrac{ans}{y_0}=\max\{\dfrac{x_0}{y_0}\cdot x+y\}$，然后这个东西和斜率优化长得一样，答案一定是在凸壳上的.

于是我们维护这个凸壳.因为有区间询问所以线段树维护每个区间的凸壳.具体地，插入的时候统计当前区间已经有多少个点，如果点数等于当前区间长度那么构造出这个区间的凸壳.询问的时候拆成$\log$个区间分别跑二分/三分即可.

求凸包这里使用按$x$坐标排序的那个算法.注意如果几个点的$x$相同那么要按$y$排序.

插入的时候每个区间只会被构建一次凸包，总复杂度$O(n\log n)$，排序用归并.

查询的时候拆成$\log$个区间，每个区间$O(\log n)$三分/二分，总复杂度$O(n\log ^2 n)$

使用$vector$可以很方便地在每个节点开一个栈，但是非常吃氧(不开$O2$会T最后一个点).可以不用$stl$，用一个大栈存下所有区间的凸包，对每个线段树节点存下它所在凸包的起止点即可.

这里当然还是用无脑的$vector$了233

这道题还告诉我们所有长成$f[i]=\min\limits_{L(i)\leq j\leq R(i)}\{k(i)x(j)+F(j)\}+G(i)$的$dp$都是可做的233

```cpp
#include<iostream>
#include<cstdio>
#include<vector>
#include<cstring>
using namespace std;
const int N=2e6;
long long lastans;
struct Point{
	int x,y;
	bool operator <(const Point &a)const{return x!=a.x?x<a.x:y<a.y;}
	Point operator -(const Point &a)const{return (Point){x-a.x,y-a.y};}
	long long operator *(const Point &a)const{return 1ll*x*a.y-1ll*y*a.x;}
};
struct Node{vector<Point>st[2];}a[N];
int size[N],n;
char st[5];
long long calc(int rot,int x,int y)
{
	int o=0;
	if(y<0)x=-x,y=-y,o=1;
	int l=0,r=a[rot].st[o].size()-1;
//	cout<<rot<<" "<<l<<" "<<r<<endl;
	while(l<r)
	{
		int mid=(l+r)>>1;//cout<<l<<" "<<r<<" "<<mid<<endl;
		if(-1ll*x*(a[rot].st[o][mid+1].x-a[rot].st[o][mid].x)>=1ll*y*(a[rot].st[o][mid+1].y-a[rot].st[o][mid].y))r=mid;
		else l=mid+1;
	}
//	cout<<l<<endl;
	return 1ll*x*a[rot].st[o][l].x+1ll*y*a[rot].st[o][l].y;
}
long long query(int rot,int lt,int rt,int lq,int rq,int x,int y)
{
	if(lt>=lq&&rt<=rq)return calc(rot,x,y);
	int mid=(lt+rt)>>1;
	if(rq<=mid)return query(rot<<1,lt,mid,lq,rq,x,y);
	else if(lq>mid)return query(rot<<1|1,mid+1,rt,lq,rq,x,y);
	else return max(query(rot<<1,lt,mid,lq,mid,x,y),query(rot<<1|1,mid+1,rt,mid+1,rq,x,y));
}
void build(int rot,int len)
{
	for(int o=0;o<=1;o++)
	{
		vector<Point>tmp;tmp.clear();
		vector<Point>::iterator i=a[rot<<1].st[o].begin(),j=a[rot<<1|1].st[o].begin();
		for(;i!=a[rot<<1].st[o].end()||j!=a[rot<<1|1].st[o].end();)
			if(i==a[rot<<1].st[o].end()||(j!=a[rot<<1|1].st[o].end()&&*j<*i))tmp.push_back(*j++);
			else tmp.push_back(*i++);
		int top=0;
		for(vector<Point>::iterator i=tmp.begin();i!=tmp.end();++i)
		{
			while(top>1&&((a[rot].st[o][top-1]-a[rot].st[o][top-2])*(*i-a[rot].st[o][top-1]))>=0)--top,a[rot].st[o].pop_back();
			a[rot].st[o].push_back(*i);++top;
		}
	}
}
void update(int rot,int lt,int rt,int q,int x,int y)
{
	if(lt==rt){a[rot].st[0].push_back((Point){x,y}),a[rot].st[1].push_back((Point){-x,-y}),++size[rot];return;}
	int mid=(lt+rt)>>1;
	if(q<=mid)update(rot<<1,lt,mid,q,x,y);
	else update(rot<<1|1,mid+1,rt,q,x,y);
	++size[rot];if(size[rot]==rt-lt+1)build(rot,rt-lt+1);
}
void deco(int &x)
{
	x^=(lastans&0x7fffffff);
}
void print(int rot,int lt,int rt)
{
	printf("%d %d %d\n",rot,lt,rt);
	int mid=(lt+rt)>>1;
	if(lt!=rt)print(rot<<1,lt,mid),print(rot<<1|1,mid+1,rt);
}
int main()
{
	int enc=0;
	scanf("%d%s",&n,st+1);if(st[1]!='E')enc=1;
//	cout<<enc<<endl;
//	freopen("cswa.txt","w",stdout);
	int nn=0;//print(1,1,n);
	for(int i=1;i<=n;i++)
	{
		scanf("%s",st+1);
		if(st[1]=='Q')
		{
			int l,r,x,y;
			scanf("%d%d%d%d",&x,&y,&l,&r);
			if(enc)deco(x),deco(y),deco(l),deco(r);
//			cout<<x<<" "<<y<<" "<<l<<" "<<r<<endl;
			printf("%lld\n",lastans=query(1,1,n,l,r,x,y));
		}
		else
		{
			int x,y;
			scanf("%d%d",&x,&y);
			if(enc)deco(x),deco(y);
//			cout<<x<<" "<<y<<endl;
			update(1,1,n,++nn,x,y);
		}
//		print(1,1,n);
	}
}
```

---

## 作者：251Sec (赞：9)

显然答案在凸壳上，考虑如何维护区间的凸壳，然后可以三分答案。

考虑线段树？加点暴力求凸包的复杂度看起来很不对。考虑树状数组？我们没法把两个前缀区间的信息相减。考虑一个加强版的树状数组，想到以每个 $i$ 为右端点，维护长度为 $1,2,4,\cdots,\operatorname{lowbit}(i)$ 的区间的凸壳，暴力求凸壳的复杂度是对的。

那么对于一个询问的区间 $[l,r]$，我们要怎么找到一堆区间的并集是它呢？

![](https://cdn.luogu.com.cn/upload/image_hosting/jmg364tz.png)

草，这玩意的本质和线段树一样！那我们不如直接写个线段树。

于是我们考虑对于这个线段树维护的某个区间，当且仅当加入这个区间的最右边一个点的时候再建出这个区间的凸包，于是复杂度就是对的了！

总复杂度 $O((n+q)\log^2n)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
struct Point {
    int x, y;
    bool operator<(const Point &o) const {
        if (x != o.x) return x < o.x;
        return y < o.y;
    }
    ll operator*(const Point &o) const {
        return 1ll * x * o.y - 1ll * y * o.x;
    }
    Point& operator-=(const Point &o) {
        x -= o.x;
        y -= o.y;
        return *this;
    }
    Point operator-(const Point &o) {
        Point tmp(*this);
        tmp -= o;
        return tmp;
    }
} pt[400005];
ll Dot(const Point &a, const Point &b) {
    return 1ll * a.x * b.x + 1ll * a.y * b.y;
}
int pcnt;
int n;
struct SegTree {
    struct Node {
        vector<Point> up, dn;
    } f[1600005];
    void BuildConv(int p, int l, int r) {
        vector<Point> t, &t1 = f[p].up, &t2 = f[p].dn;
        for (int i = l; i <= r; i++) {
            t.emplace_back(pt[i]);
        }
        sort(t.begin(), t.end());
        for (auto i : t) {
            while (t1.size() >= 2 && (i - t1[t1.size() - 2]) * (t1[t1.size() - 1] - t1[t1.size() - 2]) <= 0) t1.pop_back();
            t1.emplace_back(i);
        }
        for (auto i : t) {
            while (t2.size() >= 2 && (i - t2[t2.size() - 2]) * (t2[t2.size() - 1] - t2[t2.size() - 2]) >= 0) t2.pop_back();
            t2.emplace_back(i);
        }
    }
    ll Calc(const vector<Point> &p, const Point &x) {
        int l = 0, r = p.size() - 1;
        while (r - l >= 3) {
            int m1 = l + (r - l) / 3, m2 = r - (r - l) / 3;
            if (Dot(p[m1], x) > Dot(p[m2], x)) r = m2;
            else l = m1;
        }
        ll ans = -1e18;
        for (int i = l; i <= r; i++) ans = max(ans, Dot(p[i], x));
        return ans;
    }
    void Modify(int i, int p = 1, int cl = 1, int cr = n) {
        int mid = cl + cr >> 1;
        if (i == cr) {
            BuildConv(p, cl, cr);
        }
        if (cl == cr) return;
        if (i <= mid) Modify(i, p << 1, cl, mid);
        else Modify(i, p << 1 | 1, mid + 1, cr);
    }
    ll Query(int l, int r, const Point &w, int p = 1, int cl = 1, int cr = n) {
        if (cl > r || cr < l) return -1e18;
        if (cl >= l && cr <= r) {
            if (w.y > 0) {
                return Calc(f[p].up, w);
            }
            else {
                return Calc(f[p].dn, w);
            }
        }
        int mid = cl + cr >> 1;
        return max(Query(l, r, w, p << 1, cl, mid), Query(l, r, w, p << 1 | 1, mid + 1, cr));
    }
} tr;
char s;
ll las;
void Dec(int& x) {
    if (s != 'E') x = x ^ (las & 0x7fffffff);
}
int main() {
    scanf("%d %c", &n, &s);
    for (int i = 1; i <= n; i++) {
        char op; Point w;
        scanf(" %c%d%d", &op, &w.x, &w.y);
        Dec(w.x); Dec(w.y);
        if (op == 'A') {
            pt[++pcnt] = w;
            tr.Modify(pcnt);
        }
        else {
            int l, r;
            scanf("%d%d", &l, &r);
            Dec(l); Dec(r);
            printf("%lld\n", las = tr.Query(l, r, w));
        }
    }
    return 0;
}
```

---

## 作者：kczno1 (赞：7)

ans=(x1,x2)点积(x2,y2)=x1\*x2+y1\*y2

注意到这是齐次的，实际上只跟k=x2/y2有关

ans=y2\*(x1\*k+y1)

不妨设y2>0,如果y2<0,我们只用把x1,x2,y1,y2全部取反即可。

那么就是求max(x1\*k+y1)

这显然就是要维护上凸壳。

强制在线，用二进制分组即可(可以看作一个动态的线段树，直接用线段树来实现)。

具体的说，就是当线段树的一个区间满了就build出他的凸壳。

如果有删除操作(unknown那题)的话，就只用多一个无效标记，表示当前的区间的凸壳是假的。

当一个区间满的时候，我们不立刻build，只有当他线段树的右边的兄弟满了才build。

这样修改复杂度显然是对的。

这样线段树每一层最多一个无效的，查询时还是log个区间。

(那题空间只给64MB,似乎不够啊)

```cpp
#include<bits/stdc++.h>

#define ll long long
#define mid (l+r>>1)
#define cl (k<<1)
#define cr (cl+1)
void chmax(ll &x,const ll &y) { if(x<y)x=y; }
const int N=400005;
struct point
{
    int x,y;
    friend point operator -(const point &p)
    {
        return (point){-p.x,-p.y};
    }
    friend bool operator <(const point &p1,const point &p2)
    {
        return p1.x<p2.x||p1.x==p2.x&&p1.y<p2.y;
    }
    friend point operator -(const point &p1,const point &p2) 
    {
        return (point){p1.x-p2.x,p1.y-p2.y};
    }
    friend ll operator *(const point &p1,const point &p2)//p1叉积p2 
    {
        return (ll)p1.x*p2.y-(ll)p1.y*p2.x;
    }
    friend ll dot_product(const point &p1,const point &p2)//p1点积p2 
    {
        return (ll)p1.x*p2.x+(ll)p1.y*p2.y;
    }
}now;
struct tu
{
    point *a;int n;
    void init(int _n)
    {
        n=_n;
        a=new point [n+3];
    }
    void push(const point &x)
    {
        while(n>=2&&(a[n]-a[n-1])*(x-a[n-1])>=0) --n;
        a[++n]=x;
    }
    void merge(const tu &q1,const tu &q2)
    {
        init(q1.n+q2.n);
        
        //按x为第一,y为第二归并 
        int h1=1,h2=1;
        n=0;
        for(;;)
        if(q1.a[h1]<q2.a[h2]) 
        {push(q1.a[h1++]);
         if(h1>q1.n)
         {
             while(h2<=q2.n) push(q2.a[h2++]);
             break;
         }
        }
        else
        {push(q2.a[h2++]);
         if(h2>q2.n)
         {
             while(h1<=q1.n) push(q1.a[h1++]);
             break;
         }
        }
    }
    ll erfen(const point &x)
    {
        int l=1,r=n;
        while(l!=r)
        if(dot_product(a[mid],x)<=dot_product(a[mid+1],x)) l=mid+1;
        else r=mid;
        return dot_product(a[l],x);
    }
};
struct seg
{
    tu a[2];//0=正 1=负 
    ll check()
    {
        if(now.y<0) return a[1].erfen(-now);
        return a[0].erfen(now);
    }
}a[N<<2];int tot;
int dy[N];
void init(int k,int l,int r)
{
    if(l==r)     {dy[l]=k;return ;}
    init(cl,l,mid);init(cr,mid+1,r);
}

void add()
{
    int k=dy[++tot];
    a[k].a[0].init(1);a[k].a[0].a[1]=now;
    a[k].a[1].init(1);a[k].a[1].a[1]=-now;
    while((k&1)&&k>1) 
    {
        k>>=1;
        for(int j=0;j<2;++j)
            a[k].a[j].merge(a[cl].a[j],a[cr].a[j]);
    }
}

ll ans;
int ql,qr;
void qiu(int k,int l,int r)
{
    if(ql<=l&&qr>=r) { chmax(ans,a[k].check()); return ; }
    if(ql<=mid) qiu(cl,l,mid);
    if(qr>mid) qiu(cr,mid+1,r);
}

bool encode;
inline void decode (int &x) {
 if(encode)
  x ^= (ans & 0X7FFFFFFF);
}

int main()
{
    freopen("1.in","r",stdin);
    int n;char type[5];
    scanf("%d%s",&n,type);
    encode=type[0]!='E';
    init(1,1,n);
    for(int i=1;i<=n;++i)
    {
        scanf("%s%d%d",type,&now.x,&now.y);decode(now.x);decode(now.y);
        if(type[0]=='A') add();
        else 
        { scanf("%d%d",&ql,&qr);decode(ql);decode(qr);
          ans=-(1e18);
          qiu(1,1,n);
          printf("%lld\n",ans); 
        }
    }
}
```

---

## 作者：Purslane (赞：3)

# Solution

本质上就是求之前所有向量在 $(x,y)$ 方向上投影的最大值。

然后很明显就是求出这些点的凸包，用三分法求解。（必定是单峰的。）

用线段树维护区间 $[l,r]$ 中所有点的凸包。

一个区间在询问中会被访问到，当且仅当里面所有点都加入。

因此每个区间在最后一个点加入的时候暴力合并即可。

这样每个点都最多被合并 $O(n \log n)$ 次。总体复杂度为 $O(n \log^2 n)$。

PS：归并一下可以做到线性，但是好像询问还是 $O(n \log^2 n)$ 的。所以我就懒得写归并了。

没调试一发过了。

```cpp
//1 up 0 down
#include<bits/stdc++.h>
#define ll long long
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=4e5+10;
int n; char op;
struct Node {ll x,y;};
ll operator *(Node A,Node B) {return A.x*B.x+A.y*B.y;}
struct CONVEX {int len;vector<Node> nd;}t[MAXN<<2][2];
int tot; Node st[MAXN];
void insert(Node nd,int op) {
	if(tot==0) return st[++tot]=nd,void();
	if(st[tot].x==nd.x) {
		if(op==1) st[tot].y=max(st[tot].y,nd.y);
		else st[tot].y=min(st[tot].y,nd.y);
		return ;
	}
	if(tot==1) return st[++tot]=nd,void();
	if(op==1) {
		while(tot>=2&&(nd.y-st[tot].y)*(st[tot].x-st[tot-1].x)>=(st[tot].y-st[tot-1].y)*(nd.x-st[tot].x)) tot--;
		st[++tot]=nd;
	}
	else {
		while(tot>=2&&(nd.y-st[tot].y)*(st[tot].x-st[tot-1].x)<=(st[tot].y-st[tot-1].y)*(nd.x-st[tot].x)) tot--;
		st[++tot]=nd;
	}
	return ;
}
CONVEX merge(CONVEX A,CONVEX B,int op) {
	vector<Node> C;
	for(auto nd:A.nd) C.push_back(nd);
	for(auto nd:B.nd) C.push_back(nd);
	sort(C.begin(),C.end(),[](Node A,Node B) {if(A.x!=B.x) return A.x<B.x;return A.y<B.y;});
	tot=0; for(auto nd:C) insert(nd,op);
	CONVEX res;
	ffor(i,1,tot) res.len++,res.nd.push_back(st[i]);
	return res;
}
ll get_max(Node qr,int k,int op) {
	ll ans=max(qr*t[k][op].nd[0],qr*t[k][op].nd[t[k][op].nd.size()-1]);
	int l=0,r=t[k][op].nd.size()-1;
	while(r-l+1>3) {
		int len=(r-l+1)/3,p1=l+len-1,p2=r-len+1;
		if(t[k][op].nd[p1]*qr>t[k][op].nd[p2]*qr) r=p2-1;
		else l=p1+1;
	}
	ffor(i,l,r) ans=max(ans,qr*t[k][op].nd[i]);
	return ans;
}
#define lson (k<<1)
#define rson (k<<1|1)
#define mid (l+r>>1)
void update(int k,int l,int r,int pos,Node nd) {
	if(l==r) {
		t[k][0].len=t[k][1].len=1;
		t[k][0].nd.push_back(nd),t[k][1].nd.push_back(nd);
		return ;	
	}
	if(pos<=mid) update(lson,l,mid,pos,nd);
	else update(rson,mid+1,r,pos,nd);
	if(pos==r) t[k][0]=merge(t[lson][0],t[rson][0],0),t[k][1]=merge(t[lson][1],t[rson][1],1);	
	return ;
}
ll query(int k,int l,int r,int x,int y,Node nd) {
	if(x<=l&&r<=y) return max(get_max(nd,k,0),get_max(nd,k,1));
	if(y<=mid) return query(lson,l,mid,x,y,nd);
	if(x>mid) return query(rson,mid+1,r,x,y,nd);
	return max(query(lson,l,mid,x,y,nd),query(rson,mid+1,r,x,y,nd));
}
ll lstans;
int decode(int x) {    
    return x^(lstans&0x7fffffff);
}
signed main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>n>>op;
	int cnt=0;
	ffor(i,1,n) {
		char OP; cin>>OP;
		if(OP=='A') {
			int x,y; cin>>x>>y;
			if(op!='E') x=decode(x),y=decode(y);
			++cnt; update(1,1,n,cnt,{x,y});	
		}
		else {
			int x,y,l,r; cin>>x>>y>>l>>r;
			if(op!='E') x=decode(x),y=decode(y),l=decode(l),r=decode(r);
			cout<<(lstans=query(1,1,n,l,r,{x,y}))<<'\n';
		}
	}
	
	return 0;
}
```

---

## 作者：Cutest_Junior (赞：3)

## P3339 【向量集】

### 题意

+ 空二元组数组 $a$，支持：
1. 在 $a$ 末尾加入一个二元组 $(x, y)$（下标从 $1$ 开始）；
1. 给出 $x,y,l,r$，查询 $\max\limits_{i=l}^{r}(x\times a_i.x+y\times a_i.y)$。
+ $|x|,|y|\le10^8$，$1\le n\le4\times10^5$，保证询问合法，强制在线。

### 做法

明显是斜率优化，但是有区间限制，考虑线段树维护凸包，查询时拆成 $O(\log n)$ 个被完全包含的线段树区间，每个区间一次三分，单次查询复杂度 $O(\log^2n)$。

暴力合并子树的话单次修改复杂度为 $O(n\log n)$。

注意到只有插入，可以用 `set` 维护凸包，单次修改 $O(\log^2n)$。可过。~~但是我不会写。~~

注意到只有被完全包含的线段树区间里的凸包才会被用到，而且每次修改只在数组末尾。所以每个线段树区间只需要在子树被填满那一刻合并即可，此前不会用到这个线段树区间的凸包，此后不会修改到这个线段树区间。总修改复杂度 $O(n\log n)$。

---

## 作者：bztMinamoto (赞：2)

[传送门](https://www.luogu.org/problemnew/show/P3309)

达成成就：一人独霸三页提交

自己写的莫名其妙MLE死都不知道怎么回事，照着题解打一直RE一个点最后发现竟然是凸包上一个点求错了……四个半小时就一直用来调代码了……

![](https://i.loli.net/2018/11/22/5bf69369bd582.png)

那么我们只要维护好这个凸壳，因为这是一个凸函数，所以只要在上面三分找最值即可

于是现在我们需要维护一个资瓷插入的凸壳。考虑线段树，我们发现每一次在线段树上询问的区间必然都是已经把点插满了的。那么我们可以考虑线段树上每一个节点内的所有元素都插入完之后，再构建凸壳，那么显然每个节点只会被构建一次凸包，所以复杂度是$O(nlog^2n)$

然后注意一个细节……因为我们维护好的凸包要便于分成上下凸壳，所以凸包的起点应该是$x$坐标最小的，这样才满足它左右两边分别是上凸壳和下凸壳……我按照以前的写法找$y$坐标最小的当起点然后就没有然后了……
```
//minamoto
#include<bits/stdc++.h>
#define fp(i,a,b) for(register int i=a,I=b+1;i<I;++i)
#define fd(i,a,b) for(register int i=a,I=b-1;i>I;--i)
#define ll long long
#define inf 1e18
using namespace std;
template<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}
int flag=0,all;ll lasans=0;
int read(){
    int res,f=1;char ch;
    while((ch=getchar())>'9'||ch<'0')(ch=='-')&&(f=-1);
    for(res=ch-'0';(ch=getchar())>='0'&&ch<='9';res=res*10+ch-'0');
    res*=f;if(flag)res^=(lasans&0x7fffffff);
    return res;
}
char sr[1<<21],z[20];int C=-1,Z=0;
inline void Ot(){fwrite(sr,1,C+1,stdout),C=-1;}
void print(ll x){
    if(C>1<<20)Ot();if(x<0)sr[++C]='-',x=-x;
    while(z[++Z]=x%10+48,x/=10);
    while(sr[++C]=z[Z],--Z);sr[++C]='\n';
}
const int N=4e5+5;
struct node{int x,y;}b[N],st[N];
struct seg{
    int l,r,pos,sz;seg *ch[2];
    vector<node>mp;
}pool[N<<2],*rt;
inline node operator -(node a,node b){return (node){a.x-b.x,a.y-b.y};}
inline ll operator *(node a,node b){return 1ll*a.x*b.y-1ll*b.x*a.y;}
inline ll dot(node a,node b){return 1ll*a.x*b.x+1ll*a.y*b.y;}
inline bool operator <(node a,node b){
    a=a-st[1],b=b-st[1];
    return a*b==0?1ll*a.x*a.x+1ll*a.y*a.y<1ll*b.x*b.x+1ll*b.y*b.y:a*b>0;
}
void graham(seg *p){
	int top=1,sz=p->r-p->l+1,k=1;
	fp(i,1,sz)b[i]=p->mp[i-1];
	fp(i,2,sz)if(b[i].x<b[k].x||(b[i].x==b[k].x&&b[i].y<b[k].y))k=i;
	swap(b[1],b[k]),st[1]=b[1],sort(b+2,b+sz+1);
	fp(i,2,sz){
		while(top>1&&(b[i]-st[top-1])*(st[top]-st[top-1])>=0)--top;
		st[++top]=b[i];
	}st[++top]=b[1];p->sz=top;
	vector<node>().swap(p->mp);
//	p->mp.clear();
	fp(i,1,top)p->mp.push_back(st[i]);
	fp(i,1,top-1)if(st[i+1].x<=st[i].x){p->pos=i-1;break;}
}
ll calc(seg *p,node q){
	int l,r,m1,m2;ll ans=-inf;
	q.y>0?(l=p->pos,r=p->sz-1):(l=0,r=p->pos);
	while(r-l>=3){
		m1=l+(r-l)/3,m2=r-(r-l)/3;
		dot(q,p->mp[m1])>dot(q,p->mp[m2])?r=m2:l=m1;
	}fp(i,l,r)cmax(ans,dot(q,p->mp[i]));return ans;
}
void ins(seg *p,int pos,node x){
    p->mp.push_back(x);if(pos==p->r)graham(p);if(p->l==p->r)return;
    int mid=(p->l+p->r)>>1;pos<=mid?ins(p->ch[0],pos,x):ins(p->ch[1],pos,x);
}
ll query(seg *p,int l,int r,node x){
    if(l<=p->l&&r>=p->r)return calc(p,x);
    int mid=(p->l+p->r)>>1;ll res=-inf;
    if(l<=mid)cmax(res,query(p->ch[0],l,r,x));
    if(r>mid)cmax(res,query(p->ch[1],l,r,x));
    return res;
}
void build(seg *p,int l,int r){
    p->l=l,p->r=r;if(l==r)return;int mid=(l+r)>>1;
    build(p->ch[0]=pool+ ++all,l,mid),build(p->ch[1]=pool+ ++all,mid+1,r);
}
int main(){
//	freopen("testdata.in","r",stdin);
    int n,l,r,tot=0;char s[10];node x;
    n=read(),scanf("%s",s),flag=s[0]!='E';
    build(rt=pool+ ++all,1,n);
    while(n--){
        scanf("%s",s),x.x=read(),x.y=read();
        if(s[0]=='Q')l=read(),r=read(),print(lasans=query(rt,l,r,x));
        else ins(rt,++tot,x);
    }return Ot(),0;
}
```

---

## 作者：zzw4257 (赞：2)

>支持以下操作
>
- 在序列末尾插入一个向量
- 询问$[l,r]$中向量与给定向量$(x_0,y_0)$点积最大值

$x_0x_i+y_0y_i>x_0x_j+y_0y_j$

$x_0(x_i-x_j)>y_0(y_j-y_i)$

- $-\frac{x_0}{y_0}<\frac{y_i-y_j}{x_i-x_j},y_0>0$
- $-\frac{x_0}{y_0}>\frac{y_i-y_j}{x_i-x_j},y_0\leqslant0$

意思就是$y_0>0$维护上凸壳，否则维护下凸壳

最后最优值三分即可，注意整数三分尽量增大间距(最好中间三个都保留)

---

## 作者：Pentiment (赞：1)

手玩一下样例，发现答案好像一定在凸包上。实际上有：
$$
\max\{xx_0+yy_0\}=\left\{
\begin{aligned}
&y_0\cdot\max\left\{\dfrac{x_0}{y_0}\cdot x+y\right\}&y_0>0\\
&y_0\cdot\min\left\{\dfrac{x_0}{y_0}\cdot x+y\right\}&y_0<0
\end{aligned}
\right.
$$
这就是斜率优化的形式，所以我们要维护的就是区间上/下凸壳。

如果允许离线的话，可以直接上线段树，对于每个点维护其管辖区间的凸包，询问时拆成 $\mathcal O(\log n)$ 个区间，每个区间三分即可。

现在强制在线，有种叫平衡树维护凸包的东西，套到线段树里好像就行了，但是我不会，所以想了另外一种做法：类似于二进制分组，对于线段树的一个节点 $[l,r]$，当 $r$ 被加入时才建出整个区间的凸包（反正 $r$ 加入前也查不到我这来），这样复杂度就是对的了，为 $\mathcal O(n\log^2 n)$。

不卡常。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 400005, eps = 3;
int n, len;
char qwq;
ll ans;
struct point { int x, y; } pt[N], t[N];
bool operator<(point a, point b) { return a.x == b.x ? a.y < b.y : a.x < b.x; }
ll operator*(point a, point b) { return (ll)a.x * b.y - (ll)a.y * b.x; }
point operator-(point a, point b) { return {a.x - b.x, a.y - b.y}; }
ll mul(point a, point b) { return (ll)a.x * b.x + (ll)a.y * b.y; }
ll solve(const basic_string<point> &v, point x) {
	int l = 0, r = v.size() - 1, tmp, mid1, mid2;
	while (r - l >= eps) {
		tmp = (r - l) / 3, mid1 = l + tmp, mid2 = r - tmp;
		if (mul(v[mid1], x) > mul(v[mid2], x)) r = mid2;
		else l = mid1;
	}
	ll ans = LLONG_MIN;
	for (int i = l; i <= r; i++) ans = max(ans, mul(v[i], x));
	return ans;
}
basic_string<point> u[N << 2], d[N << 2];
#define lc (p << 1)
#define rc (lc | 1)
void build(int p, int l, int r) {
	int tot = 0;
	for (int i = l; i <= r; i++) t[++tot] = pt[i];
	sort(t + 1, t + 1 + tot);
	auto &U = u[p], &D = d[p];
	for (int i = 1; i <= tot; i++) {
		while (U.size() >= 2 && (t[i] - U[U.size() - 2]) * (U[U.size() - 1] - U[U.size() - 2]) <= 0) U.pop_back();
		U.push_back(t[i]);
	}
	for (int i = 1; i <= tot; i++) {
		while (D.size() >= 2 && (t[i] - D[D.size() - 2]) * (D[D.size() - 1] - D[D.size() - 2]) >= 0) D.pop_back();
		D.push_back(t[i]);
	}
}
void upd(int p, int l, int r, int x) {
	if (x == r) build(p, l, r);
	if (l == r) return;
	int mid = (l + r) >> 1;
	x <= mid ? upd(lc, l, mid, x) : upd(rc, mid + 1, r, x);
}
ll qry(int p, int l, int r, int s, int e, point x) {
	if (s <= l && r <= e) return x.y > 0 ? solve(u[p], x) : solve(d[p], x);
	int mid = (l + r) >> 1;
	ll ans = LLONG_MIN;
	if (s <= mid) ans = max(ans, qry(lc, l, mid, s, e, x));
	if (e > mid) ans = max(ans, qry(rc, mid + 1, r, s, e, x));
	return ans;
}
void decode(int &x) { x ^= (ans & 0x7fffffff); }
int main() {
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	cin >> n >> qwq;
	char op; int l, r; point x;
	for (int i = 1; i <= n; i++) {
		cin >> op >> x.x >> x.y;
		if (qwq != 'E') decode(x.x), decode(x.y);
		if (op == 'A') pt[++len] = x, upd(1, 1, n, len);
		else {
			cin >> l >> r;
			if (qwq != 'E') decode(l), decode(r);
			cout << (ans = qry(1, 1, n, l, r, x)) << '\n';
		}
	}
}
```

---

## 作者：I_AM_CIMOTA (赞：1)

二维向量的点积：$(a,b)\cdot(c,d)=ac+bd$

假设最大值为 $mx$，则 $\frac{mx}{d}=\max\{\frac{c}{d}\cdot a+b\}$。

这就是一眼凸壳了。

考虑用线段树维护凸壳。显然我们不可能动态加点，那怎么办呢？由于在一个区间内的点没加完时，这个区间一定不会询问到，所以我们可以在一个区间内所有点都加完后再构建凸壳。

至于正负号，那就把上下凸壳都建出来就行了。

时间复杂度是双 $\log$ 的。
```cpp
#include <bits/stdc++.h>
#define int long long
#define double long double
using namespace std;

const int N=8e5+5,INF=0x3f3f3f3f3f3f3f3f;
const double EPS=1e-9,inf=1e19;
struct Comp{
	int x,y;
	Comp operator +(const Comp& b)const{return {x+b.x,y+b.y};}
	Comp operator -(const Comp& b)const{return {x-b.x,y-b.y};}
	bool operator <(const Comp& b)const{
		if(x!=b.x)return x<b.x;
		return y<b.y;
	}
}st[N];
int n,T,t[2][N<<2],ans;
bool flag;
char s[5];
vector<Comp>point[N<<2],conv[2][N<<2];

int decode(int x){return x^(ans&0x7fffffff);}

int cross(Comp a,Comp b){return a.x*b.y-a.y*b.x;}

int dir(Comp a,Comp b,Comp c){return cross(b-a,c-b);}

int calc(Comp a,int x,int y){return a.x*x+a.y*y;}

void build_conv(int u){
	int tp=2,sz=point[u].size();
	sort(point[u].begin(),point[u].end());
	st[1]=point[u][0],st[2]=point[u][1];
	for(int i=2;i<sz;i++){
		Comp newp=point[u][i];
		while(tp>1&&dir(st[tp-1],st[tp],newp)<=0)tp--;
		st[++tp]=newp;
	}
	for(int i=1;i<=tp;i++)conv[0][u].push_back(st[i]);
	tp=2;
	st[1]=point[u][0],st[2]=point[u][1];
	for(int i=2;i<sz;i++){
		Comp newp=point[u][i];
		while(tp>1&&dir(st[tp-1],st[tp],newp)>=0)tp--;
		st[++tp]=newp;
	}
	for(int i=1;i<=tp;i++)conv[1][u].push_back(st[i]);
}

int ask(int u,int x,int y,int op){
	int sz=conv[op][u].size();
	int l=0,r=sz-1;
	while(l+5<=r){
		int mid=(l+r)>>1;
		if(calc(conv[op][u][mid-1],x,y)<=calc(conv[op][u][mid],x,y))l=mid-1;
		else r=mid;
	}
	int maxn=-INF;
	for(int i=l;i<=r;i++)maxn=max(maxn,calc(conv[op][u][i],x,y));
//	printf("-> %lld %lld\n",calc(conv[op][u][l],x,y),maxn);
	return maxn;
}

void mdf(int u,int l,int r,int X,Comp p){
	point[u].push_back(p);
	if(l==r){
		conv[0][u].push_back(p);
		conv[1][u].push_back(p);
		t[0][u]=t[1][u]=p.x;
		return;
	}
	int mid=(l+r)>>1;
	if(X<=mid)mdf(u<<1,l,mid,X,p);
	else mdf(u<<1|1,mid+1,r,X,p);
	if(X==r)build_conv(u);
	t[0][u]=min(t[0][u<<1],t[0][u<<1|1]);
	t[1][u]=max(t[1][u<<1],t[1][u<<1|1]);
}

int qry(int u,int l,int r,int L,int R,int x,int y,int op){
	if(L<=l&&r<=R){
//		printf("ask: %lld %lld %lld %lld\n",u,l,r,op);
		return ask(u,x,y,op);
	}
	int mid=(l+r)>>1,res=-INF;
	if(L<=mid)res=max(res,qry(u<<1,l,mid,L,R,x,y,op));
	if(R>mid)res=max(res,qry(u<<1|1,mid+1,r,L,R,x,y,op));
	return res;
}

int cmp(int op,int a,int b){
	if(op==0)return min(a,b);
	return max(a,b);
}

int qry1(int u,int l,int r,int L,int R,int op){
	if(L<=l&&r<=R)return t[op][u];
	int mid=(l+r)>>1;
	if(R<=mid)return qry1(u<<1,l,mid,L,R,op);
	else if(L>mid)return qry1(u<<1|1,mid+1,r,L,R,op);
	return cmp(op,qry1(u<<1,l,mid,L,R,op),qry1(u<<1|1,mid+1,r,L,R,op));
}

signed main(){
	memset(t[0],0x3f,sizeof t[0]);
	memset(t[1],128,sizeof t[1]);
	scanf("%lld%s",&n,s);
	flag=(s[0]!='E');
	for(int i=1;i<=n;i++){
		int x,y,l,r;
		scanf("%s%lld%lld",s,&x,&y);
		if(flag)x=decode(x),y=decode(y);
		if(s[0]=='A')mdf(1,1,n,++T,(Comp){x,y});
		else{
			scanf("%lld%lld",&l,&r);
			if(flag)l=decode(l),r=decode(r);
			if(y==0)printf("%lld\n",ans=x*qry1(1,1,n,l,r,x>0));
			else printf("%lld\n",ans=qry(1,1,n,l,r,x,y,y>0));
		}
	}
	return 0;
} 
```

---

## 作者：tribool4_in (赞：0)

首先可以猜到合法的向量构成凸壳，然后需要维护区间构成的上凸壳。

具体的，跟斜率优化类似，考虑询问 $(x_0,y_0)$，我们需要求 $\max_i(x_0x_i+y_0y_i)$，不妨假设 $y_0>0$（反之直接把所有取反同样算一遍），设 $k=-\frac{x_0}{y_0}$，则求 $y_0\max_i(y_i-kx_i)$。发现后半部分类似斜率优化形式，考虑将 $(x_i,y_i)$ 视作一个点，相当于求一个斜率为 $k$ 的直线经过某个点，最大化斜率。因此可能的最优点是个上凸壳，最优直线一定是切在凸壳上某个点，求答案直接二分切点即可。

考虑如何维护区间构成的凸壳。直接用线段树发现 `push_up` 的复杂度是 $O(len)$ 的，于是寄了。发现此题中修改操作是从左往右的，且只需要询问一段“满了”的区间。因此可以只在一个区间满了的时候构建凸包，复杂度就对了。

代码：

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int N = 4e5 + 10;
int n;
struct Point {
    int x, y;
    Point() {}
    Point(int x, int y) : x(x), y(y) {}
};
Point operator-(const Point &a, const Point &b) { return Point(a.x - b.x, a.y - b.y); }
ll operator*(const Point &a, const Point &b) { return 1ll * a.x * b.y - 1ll * a.y * b.x; }
bool operator<(const Point &a, const Point &b) { return a.x < b.x || (a.x == b.x && a.y < b.y); }
vector<Point> t[N << 2][2];
bool full[N << 2];
void push_up(int p) {
    for (int o = 0; o < 2; o++) {
        vector<Point> v;
        for (auto itl = t[p << 1][o].begin(), itr = t[p << 1 | 1][o].begin(); itl != t[p << 1][o].end() || itr != t[p << 1 | 1][o].end();) {
            if (itr == t[p << 1 | 1][o].end() || (itl != t[p << 1][o].end() && (*itl) < (*itr))) v.push_back(*(itl++));
            else v.push_back(*(itr++));
        }
        int tot = 0;
        for (auto pt : v) {
            while (tot > 1 && (t[p][o][tot - 1] - t[p][o][tot - 2]) * (pt - t[p][o][tot - 2]) >= 0) t[p][o].pop_back(), --tot;
            t[p][o].push_back(pt), ++tot;
        }
        full[p] = 1;
    }
}
void update(int p, int l, int r, int x, Point pt) {
    if (l == r) return full[p] = 1, t[p][0].push_back(pt), t[p][1].push_back(Point(-pt.x, -pt.y));
    int mid = (l + r) >> 1;
    if (x <= mid) update(p << 1, l, mid, x, pt);
    else update(p << 1 | 1, mid + 1, r, x, pt);
    if (full[p << 1 | 1]) push_up(p);
}
ll calc(int p, int x0, int y0) {
    int o = y0 > 0 ? 0 : (x0 = -x0, y0 = -y0, 1);
    int l = 0, r = t[p][o].size() - 2, ans = t[p][o].size() - 1;
    while (l <= r) {
        int mid = (l + r) >> 1;
        if (1ll * (t[p][o][mid + 1].y - t[p][o][mid].y) * y0 <= -1ll * x0 * (t[p][o][mid + 1].x - t[p][o][mid].x)) ans = mid, r = mid - 1;
        else l = mid + 1;
    }
    return 1ll * x0 * t[p][o][ans].x + 1ll * y0 * t[p][o][ans].y;
}
ll query(int p, int l, int r, int x, int y, Point pt) {
    if (x <= l && r <= y) return calc(p, pt.x, pt.y);
    int mid = (l + r) >> 1;
    ll ans = -0x3f3f3f3f3f3f3f3f;
    if (x <= mid) ans = max(ans, query(p << 1, l, mid, x, y, pt));
    if (mid < y) ans = max(ans, query(p << 1 | 1, mid + 1, r, x, y, pt));
    return ans;
}
signed main() {
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    auto decode = [](int &x, ll lastans) { x ^= (lastans & 0x7fffffff); };
    char ch, op;
    cin >> n >> ch;
    ll lstans = 0;
    for (int i = 1, x, y, l, r, tot = 0; i <= n; i++) {
        cin >> op >> x >> y;
        if (ch != 'E') decode(x, lstans), decode(y, lstans);
        if (op == 'A') {
            update(1, 1, n, ++tot, Point(x, y));
        } else if (op == 'Q') {
            cin >> l >> r;
            if (ch != 'E') decode(l, lstans), decode(r, lstans);
            cout << (lstans = query(1, 1, n, l, r, Point(x, y))) << '\n';
        }
    }
    return 0;
}
```

---


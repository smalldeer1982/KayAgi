# 祭坛

## 题目背景

在遥远的Dgeak大陆，生活着一种叫做Dar-dzo-nye的怪物。每当这种怪物降临，人们必须整夜对抗怪物而不能安睡。为了乞求这种怪物不再降临，人们决定建造祭坛。


## 题目描述

Dgeak大陆可以看成一个用平面直角坐标系表示的巨大平面。在这个平面上，有 n 个Swaryea水晶柱，每个水晶柱可以用一个点表示。

如果 4 个水晶柱依次相连可以构成一个四边形，满足其两条对角线分别平行于 x 轴和 y 轴，并且对角线的交点位于四边形内部（不包括边界），那么这 4 个水晶柱就可以建立一个结界。其中，对角线的交点称作这个结界的中心。

例如下左图中，水晶柱 ABCD 可以建立一个结界，其中心为 O。

![](https://cdn.luogu.com.cn/upload/pic/3591.png)   ![](https://cdn.luogu.com.cn/upload/pic/3592.png)

为了起到抵御Dar-dzo-nye的最佳效果，人们会把祭坛修建在最多层结界的保护中。其中不同层的结界必须有共同的中心，这些结界的边界不能有任何公共点，并且中心处也不能有水晶柱。这里共同中心的结界数量叫做结界的层数。

为了达成这个目的，人们要先利用现有的水晶柱建立若干个结界，然后在某些结界的中心建立祭坛。

例如上右图中，黑色的点表示水晶柱（注意 P 和 O 点不是水晶柱）。祭坛的一个最佳位置为 O 点，可以建立在 3 层结界中，其结界的具体方案见下左图。当然，建立祭坛的最佳位置不一定是唯一，在上右图中，O 点左侧 1 单位的点 P 也可以建立一个在 3 层结界中的祭坛，见下右图。

![](https://cdn.luogu.com.cn/upload/pic/3593.png)   ![](https://cdn.luogu.com.cn/upload/pic/3594.png)

现在人们想知道：

1. 祭坛最佳选址地点所在的结界层数；

2. 祭坛最佳的选址地点共有多少个。


## 说明/提示

对于30%的数据 n <= 1000

另外30%的数据 n <= 10000

剩下的40%数据 n <= 100000

保证 0 <= x, y <= n


## 样例 #1

### 输入

```
26
0 5
1 1
1 5
1 9
3 5
3 10
4 0
4 1
4 2
4 4
4 6
4 9
4 11
5 0
5 2
5 4
5 8
5 9
5 10
5 11
6 5
7 5
8 5
9 10
10 2
10 5```

### 输出

```
3
2```

# 题解

## 作者：ddd (赞：9)

先离散化，之后二分答案，对于二分出的答案$k$，考虑$x$轴。对于 $x = x_0 $，设这一列共有$p$个柱子，可以建祭坛的地方上方有$s$个柱子，那么容易发现$ min(s, p - s) <= k $，所以对于每一个$x$，都可以解出一个范围。之后扫描$y$轴，同样的得到一个范围。对于$y$轴上的一行，其对答案的贡献即为其范围中有多少个$x$满足范围，所以边维护$x$轴的可行性，边统计答案。这里用到单点修改，区间查询，单点查询，线段树维护一下就可以了。复杂度 $O(nlog^2n)$，得分60 ~ 100分。

```cpp
#include <cstdio>
#include <vector>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
const int MAXN = 300005;
const int INF = 1 << 30;
const int BUFMAX = 10000000;
vector<int> x[MAXN];
vector<int> y[MAXN];
int n, q, mx, my;
int u[MAXN], v[MAXN], du[MAXN], dv[MAXN];
int sta[MAXN], ed[MAXN], now[MAXN];
int st[MAXN * 4], id[MAXN];
char BUF[BUFMAX], *buf = BUF;
inline void read(int &n) {
  n = 0;
  while(*buf < '0') buf++;
  while(*buf >= '0') {
    n = n * 10 + *buf - '0'; buf++;
  }
}
void build(int cur, int l, int r) {
  if(l == r) id[l] = cur;
  else {
    int mid = l + r >> 1;
    build(cur << 1, l, mid);
    build(cur << 1 | 1, mid + 1, r);
  }
}
void insert(int cur, int l, int r, int x, int v) {
  st[cur] += v;
  if(l == r) return;
  int mid = l + r >> 1;
  if(x <= mid) insert(cur << 1, l, mid, x, v);
  else insert(cur << 1 | 1, mid + 1, r, x, v);
}
int query(int cur, int l, int r, int a, int b) {
  if(a <= l && b >= r) return st[cur];
  int mid = l + r >> 1;
  if(b <= mid) return query(cur << 1, l, mid, a, b);
  if(a > mid) return query(cur << 1 | 1, mid + 1, r, a, b);
  return query(cur << 1, l, mid, a, b) + query(cur << 1 | 1, mid + 1, r, a, b);
}
inline int query(int x) {
  return st[id[x]];
}
int judge(int k, bool flag = false) {
  memset(st, 0, sizeof(st));
  memset(now, 0, sizeof(now));
  int ans = 0;
  for(int i = 1; i <= mx; i++) {
    int sz = x[i].size();
    if(sz < 2 * k) sta[i] = ed[i] = INF;
    else sta[i] = k; ed[i] = sz - k;
  }
  for(int i = my; i >= 1; i--) {
    int sz = y[i].size();
    int x1 = k, x2 = sz - k;
    if(sz >= 2 * k) {
      x1 = y[i][x1 - 1], x2 = y[i][x2] - 1;
      ans += query(1, 1, mx, x1, x2);
    }
    for(int j = 0; j < sz; j++) {
      int nxtx = y[i][j];
      if(nxtx >= x1 && nxtx <= x2 && query(nxtx) == 1) ans--;
      now[nxtx]++;
      if(now[nxtx] >= sta[nxtx] && now[nxtx] <= ed[nxtx]) {
        if(query(nxtx) == 0) insert(1, 1, mx, nxtx, 1);
      } else if(query(nxtx) == 1) insert(1, 1, mx, nxtx, -1);
    }
    if(flag && ans) return 1;
  }
  return ans;
}
int main() {
  fread(BUF, 1, BUFMAX, stdin);
  read(n);
  for(int i = 1; i <= n; i++) {
    read(u[i]); read(v[i]);
    du[i] = u[i];
    dv[i] = v[i];
  }
  sort(du + 1, du + n + 1);
  sort(dv + 1, dv + n + 1);
  int un = unique(du + 1, du + n + 1) - du - 1;
  int vn = unique(dv + 1, dv + n + 1) - dv - 1;
  for(int i = 1; i <= n; i++) {
    u[i] = lower_bound(du + 1, du + un + 1, u[i]) - du;
    v[i] = lower_bound(dv + 1, dv + vn + 1, v[i]) - dv;
    x[u[i]].push_back(v[i]);
    y[v[i]].push_back(u[i]);
    mx = max(mx, u[i]);
    my = max(my, v[i]);
  }
  for(int i = 1; i <= n; i++) if(y[i].size() >= 2)
    sort(y[i].begin(), y[i].end());
  build(1, 1, mx);
  int l = 1, r = min(mx, my) / 3, ans1, ans2, num;
  while(r - l > 1) {
    int mid = l + r >> 1;
    num = judge(mid, true);
    if(num) l = mid;
    else r = mid;
  }
  num = judge(r);
  if(num) {ans1 = r; ans2 = num;}
  else {ans1 = l; ans2 = judge(l);}
  printf("%d\n", ans1);
  printf("%d\n", ans2);
  return 0;
}
```

---

## 作者：Adove (赞：4)

思路：排序+线段树+扫描线；

类似的题在【SDOI2009】 虔诚的墓主人https://www.luogu.org/problemnew/show/P2154

和上题相似，我们先确定：每个水晶的贡献**只可能在当前行或当前列**；

同样地，我们选择用线段树+扫描线消掉一维；我们分两步走；

1. 扫描线从左往右扫，线段树在竖直方向，维护区间最大值。
2. 充分利用数据，扫描线从右扫回来，线段树在竖直方向，维护区间和。

对于第一步，线段树维护扫过当前点之后当前行对ans的贡献；

对于第二步，线段树维护扫过当前点之后当前行对sum的贡献。

这样问题就转化为了线段树单点修改区间求和的问题。

时间复杂度nlogn；

我们考虑用树状数组或zkw线段树来实现；

以下是zkw线段树代码↓（码风非常清奇不要学我QwQ

```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;

const int MAXN=(1<<17)-1;

int n,x,y,ans,sum;
int tree[MAXN<<1],cntl[MAXN],cntr[MAXN],cnto[MAXN],cntd[MAXN];
struct rpg{
    int x,y;
}p[MAXN];

inline int read(){
	int x=0;char ch=getchar();
	while(ch<'0'||ch>'9') ch=getchar();
	while(ch>='0'&&ch<='9') x=(x<<3)+(x<<1)+(ch^'0'),ch=getchar();
	return x;
}

bool cmp(rpg a,rpg b){
    if(a.x==b.x) return a.y<b.y;
    return a.x<b.x;
}

void init(){
    scanf("%d",&n);
    for(int i=1;i<=n;++i){
        x=read(),y=read();
        p[i]=(rpg){x,y};
        ++cntr[y];++cnto[x];
    }sort(p+1,p+n+1,cmp);
    return;
}

void solve1(){
    for(int i=1;i<=n;++i){
        --cntr[p[i].y];++cntl[p[i].y];
        --cnto[p[i].x];++cntd[p[i].x];
        tree[MAXN+p[i].y]=min(cntl[p[i].y],cntr[p[i].y]);
        for(int j=MAXN+p[i].y>>1;j;j>>=1) tree[j]=max(tree[j<<1],tree[j<<1|1]);
        if(p[i].x==p[i-1].x&&p[i].y-p[i-1].y>1){
            int mxw=0;
            int l=MAXN+p[i-1].y,r=MAXN+p[i].y;
            while(l^r^1){
                if(~l&1) mxw=max(mxw,tree[l^1]);
                if(r&1) mxw=max(mxw,tree[r^1]);
                l>>=1;r>>=1;
            }mxw=min(mxw,min(cnto[p[i].x]+1,cntd[p[i].x]-1));
            ans=max(ans,mxw);
        }
    }printf("%d\n",ans);
    return;
}

void solve2(){
    for(int i=n;i;--i){
        --cntl[p[i].y];++cntr[p[i].y];
        --cntd[p[i].x];++cnto[p[i].x];
        int mxw=min(cntl[p[i].y],cntr[p[i].y]);
        if(mxw>=ans){
        	tree[MAXN+p[i].y]=1;
        	for(int j=MAXN+p[i].y>>1;j;j>>=1) tree[j]=tree[j<<1]+tree[j<<1|1];
		}else{
            tree[MAXN+p[i].y]=0;
            for(int j=MAXN+p[i].y>>1;j;j>>=1) tree[j]=tree[j<<1]+tree[j<<1|1];
        }if(p[i+1].x==p[i].x&&p[i+1].y-p[i].y>1&&min(cntd[p[i].x]+1,cnto[p[i].x]-1)>=ans){
            int l=MAXN+p[i].y,r=MAXN+p[i+1].y;
            while(l^r^1){
                if(~l&1) sum+=tree[l^1];
                if(r&1) sum+=tree[r^1];
                l>>=1;r>>=1;
            }
        }
    }printf("%d\n",sum);
    return;
}

int main(){
    init();
    solve1();
    solve2();
    return 0;
}
```

---

## 作者：Ameyax (赞：3)

思路很简单，一行一行处理，用线段树记录一行中上方下方水晶的较小值的区间最大值，每一行维护$suml$和$sumr$。  
处理完一行就用这一行的水晶更新线段树。  
如此可以得出第一个答案。  
然后再按上述扫一遍，用线段树记录一行里上下水晶大于$ans$的个数，每一行扫描一遍，再更新线段树。  
复杂度$O(nlogn)$，另外有$O(nlog^2n)$的二分+树状数组解法，如果常数写的好比我的$nlogn$跑得快。
```cpp
#include <cstdio>
#include <cctype>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
int read()
{
	int x = 0, f = 1; char ch = getchar();
	while (!isdigit(ch)) { if (ch == '-') f = -1; ch = getchar(); }
	while (isdigit(ch)) { x = x * 10 + ch - '0'; ch = getchar(); }
	return x * f;
}
const int MAX = 100033;
int n, cntx, ans, sumans, cnt[MAX], cntup[MAX], a[MAX];
struct Point
{
	int x, y;
	int xx;
	friend bool operator < (Point a, Point b)
	{
		return a.y == b.y ? a.x < b.x : a.y < b.y;
	}
} t[MAX];
#define ls x << 1
#define rs x << 1 | 1
struct SegmentTree
{
	int sum[MAX << 2], maxn[MAX << 2];
	void pushupsum(int x) { sum[x] = sum[ls] + sum[rs]; }
	void changesum(int x, int l, int r, int p, int c)
	{
		if (l == r)
		{
			sum[x] = c;
			return;
		}
		int mid = (l + r) >> 1;
		if (p <= mid) changesum(ls, l, mid, p, c);
		else changesum(rs, mid + 1, r, p, c);
		pushupsum(x);
	}
	int querysum(int x, int l, int r, int L, int R)
	{
		if (L <= l && r <= R)
			return sum[x];
		int mid = (l + r) >> 1, re = 0;
		if (L <= mid) re += querysum(ls, l, mid, L, R);
		if (R > mid) re += querysum(rs, mid + 1, r, L, R);
		return re;
	}
	void pushupmax(int x) { maxn[x] = max(maxn[ls], maxn[rs]); }
	void changemax(int x, int l, int r, int p, int c)
	{
		if (l == r)
		{
			maxn[x] = c;
			return;
		}
		int mid = (l + r) >> 1;
		if (p <= mid) changemax(ls, l, mid, p, c);
		else changemax(rs, mid + 1, r, p, c);
		pushupmax(x);
	}
	int querymax(int x, int l, int r, int L, int R)
	{
		if (L <= l && r <= R)
			return maxn[x];
		int mid = (l + r) >> 1, re = 0;
		if (L <= mid) re = max(re, querymax(ls, l, mid, L, R));
		if (R > mid) re = max(re, querymax(rs, mid + 1, r, L, R));
		return re;
	}
} sgt;
#undef ls
#undef rs
int main()
{
	n = read();
	for (int i = 1; i <= n; i++)
	{
		t[i].x = read();
		t[i].y = read();
		a[i] = t[i].x;
	}
	sort(t + 1, t + n + 1);
	sort(a + 1, a + n + 1);
	cntx = unique(a + 1, a + n + 1) - a - 1;
	for (int i = 1; i <= n; i++)
	{
		t[i].xx = lower_bound(a + 1, a + cntx + 1, t[i].x) - a;
		cnt[t[i].xx]++;
	}
	for (int i = 1; i <= n; i++)
	{
		int j = i;
		while (t[j + 1].y == t[j].y) j++;
		int suml = 1, sumr = j - i;
		for (int k = i; k < j; k++)
		{
			if (t[k + 1].xx > t[k].xx + 1 && min(suml, sumr) > ans)
				ans = max(ans, min(sgt.querymax(1, 1, cntx, t[k].xx + 1, t[k + 1].xx - 1), min(suml, sumr)));
			suml++, sumr--;
		}
		for (int k = i; k <= j; k++)
		{
			int xx = t[k].xx;
			cntup[xx]++;
			sgt.changemax(1, 1, cntx, xx, min(cntup[xx], cnt[xx] - cntup[xx]));
		}
		i = j;
	}
	for (int i = 1; i <= cntx; i++)
		cntup[i] = 0;
	for (int i = 1; i <= n; i++)
	{
		int j = i;
		while (t[j + 1].y == t[j].y) j++;
		int suml = 1, sumr = j - i;
		for (int k = i; k < j; k++)
		{
			if (t[k + 1].xx > t[k].xx + 1 && min(suml, sumr) >= ans)
				sumans += sgt.querysum(1, 1, cntx, t[k].xx + 1, t[k + 1].xx - 1);
			suml++, sumr--;
		}
		for (int k = i; k <= j; k++)
		{
			int xx = t[k].xx;
			cntup[xx]++;
			if (min(cntup[xx], cnt[xx] - cntup[xx]) >= ans)
				sgt.changesum(1, 1, cntx, xx, 1);
			else sgt.changesum(1, 1, cntx, xx, 0);
		}
		i = j;
	}
	printf("%d\n%d\n", ans, sumans);
	return 0;
}
```

---


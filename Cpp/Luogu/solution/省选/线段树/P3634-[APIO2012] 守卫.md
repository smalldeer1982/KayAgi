# [APIO2012] 守卫

## 题目描述

APIO 王国正被忍者攻击！忍者非常厉害，因为他们在进攻的时候可以躲在 阴影里面使得其他人看不到他们。整个王国除了国王居住的 APIO 城堡以外都已 经被占领了。在城堡前，有 N 个灌木丛，从 1 到 N 编号，有 K 个忍者躲在恰好 K 个灌木丛后面。APIO 城堡里有 M 个守卫。守卫 i 监视着编号从 Ai到 Bi的连续 的一段灌木丛。每个守卫都向国王报告在他所监视范围内是否有忍者出现。作为 国王的仆人，你需要告诉国王，基于守卫的报告，哪些灌木丛后面一定躲着一个 忍者，即对于任何和守卫报告不矛盾的忍者排列方式，在这个灌木丛后面都躲着 一个忍者。

你需要写一个程序来输出所有的这些灌木丛的编号。


## 说明/提示

【样例说明 1】

在这个样例中，有两种可能的安排方式：1，3，5 或者 2，3，5。即 3 和 5 后面必然躲着一个忍者。 考虑第一个灌木丛，存在一种安排方案使得它的后面躲着忍者，但也存在一 种安排方案使得它后面没有躲忍者，因此不应该输出 1。同理，不应该输出 2。

【样例说明 2】

在这个样例中，没有灌木丛后面一定躲着忍者。

灌木的数量 1 ≤ N ≤ 100,000 ；

忍者数 1 ≤ K ≤ N ；

守卫数 0 ≤ M < 100,000 。

 
对于 10%的数据，N ≤ 20， M ≤ 100；

对于 50%的数据，N ≤ 1000， M ≤ 1000。


## 样例 #1

### 输入

```
5 3 4 
1 2 1 
3 4 1 
4 4 0 
4 5 1```

### 输出

```
3
5
```

## 样例 #2

### 输入

```
5 1 1 
1 5 1```

### 输出

```
-1```

# 题解

## 作者：by_chance (赞：11)

题意：长为 $n$ 的 $01$ 数列中有 $k$ 个 $1$，满足 $m$ 个条件。每个条件形如 $a_i$,$b_i$,$c_i$，含义如下：

- $c_i=0$ 时，区间 $[a_i,b_i]$ 中没有 $1$。
- $c_i=1$ 时，区间 $[a_i,b_i]$ 中有 $1$。

保证初始有解。求所有必定为 $1$ 的位置。

$1 \le n \le 10^5$，$0 \le m \lt 10^5$，$1 \le k \le n$，$1 \le a_i \le b_i \le n$。

------------


首先解决简单情况：
1. 丢掉所有条件给出为 $0$ 的位置。
2. 如果剩下的可能位置数与总数相同，剩下的所有位置都满足条件。
3. 如果有某个 $c_i=1$ 的区间长为 $1$，这个位置满足条件。
4. 如果有某两个 $c_i=1$ 的区间有包含关系，只用考虑小的那个。

下面来考虑剩下的情形。对所有区间按左端点递增排序，则右端点也递增。

首先可以贪心求出一组解（不考虑 $k$），这只要从左到右扫描所有区间，如果某个区间还没有 $1$，在其右端点放 $1$。同时可以求出满足前 $i$ 个区间所需要的 $1$ 的数目的最小值 $f_i$。类似的，可以求出满足后 $i$ 个区间所需要的 $1$ 的数目的最小值 $g_i$。

“某个位置必须是 $1$”等价于“某个位置是 $0$ 时无解”。只用考虑那些满足 $f_i = f_{i-1} + 1$ 的区间 $[a_i,b_i]$ 的右端点，记为 $x$。则满足前 $i$ 个区间的条件需要 $f_i$ 个 $1$。

再考虑所有完全在 $x-1$ 右侧的区间，设为后 $p$ 个。假设 $x$ 不是 $1$，所以满足前 $i$ 个区间时不会满足后 $p$ 个区间中的任何一个。那么无解的充分必要条件就是 $f_i + g_p \gt k$。

$p$ 可以二分求。时间复杂度 $O(n \log n)$。


```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+5;
int n,k,m,d[N],t,h[N],lst[N],nxt[N],cnt,st[N],top,f[N],g[N],flag;
struct range{int l,r;}p[N];
bool operator <(const range &a,const range &b){
	return a.l!=b.l?a.l<b.l:a.r<b.r;
}
int main(){
	scanf("%d%d%d",&n,&k,&m);
	for(int i=1,a,b,c;i<=m;i++){
		scanf("%d%d%d",&a,&b,&c);
		if(c==0)++d[a],--d[b+1];
		else{++t;p[t].l=a;p[t].r=b;}
	}
	for(int i=1;i<=n;i++){
		d[i+1]+=d[i];
		if(!d[i]){lst[i]=nxt[i]=++cnt;h[cnt]=i;}
	}
	if(k==cnt){
		for(int i=1;i<=cnt;i++)printf("%d\n",h[i]);
		printf("\n");
		return 0;
	}
	for(int i=1;i<=n;i++)if(!lst[i])lst[i]=lst[i-1];
	for(int i=n;i>=1;i--)if(!nxt[i])nxt[i]=nxt[i+1];
	for(int i=1;i<=t;i++)p[i].l=nxt[p[i].l],p[i].r=lst[p[i].r];
	sort(p+1,p+t+1);top=0;
	for(int i=1;i<=t;i++){
		if(p[i].l>p[i].r)continue;
		while(top&&p[st[top]].r>=p[i].r)--top;
		st[++top]=i;
	}t=top;
	for(int i=1;i<=t;i++)p[i]=p[st[i]];
	int mx=0,mn=1e9;
	for(int i=1;i<=t;i++){
		if(p[i].l>mx)f[i]=f[i-1]+1,mx=p[i].r;
		else f[i]=f[i-1];
	}
	for(int i=t;i>=1;i--){
		if(p[i].r<mn)g[i]=g[i+1]+1,mn=p[i].l;
		else g[i]=g[i+1];
	}
	for(int i=1;i<=t;i++){
		if(p[i].l==p[i].r){flag=1;printf("%d\n",h[p[i].l]);continue;}
		if(f[i]!=f[i-1]+1)continue;
		int pos=t+1,l=i+1,r=t;
		while(l<=r){
			int mid=l+r>>1;
			if(p[mid].l>p[i].r-1)pos=mid,r=mid-1;
			else l=mid+1;
		}
		if(f[i]+g[pos]>k){flag=1;printf("%d\n",h[p[i].r]);}
	}
	if(!flag)printf("-1\n");
	return 0;
}
```

---

## 作者：Unnamed114514 (赞：8)

摘要：本题解是截至目前（2024.10.1）唯一 $O(n+m)$ 做法，同时摒弃了原始的排序，给出了一种 $O(V)$ 解决区间选点的做法（似乎有非常强的扩展性？目前在研究带修方面的扩展），也是在贺了榜一的 fastIO 后成功拿到了最优解。(49 ms)

感谢 CSP-S2024 T2，否则我绝对不会过掉这道题，因为我连贪心策略都忘了。

首先把 $0$ 的位置去掉，因为这些显然都没用，然后得到新的 $1$ 的区间，同时也得到新的 $l,r$，可以用差分做到去 $0$，然后每一个前一个 $1$ 和后一个 $1$ 显然可以 $O(n)$ 维护。

如果恰好有 $k$ 个位置为 $1$，答案显然为这 $k$ 个位置。

然后转化成了区间选点问题，这是个经典的贪心：

> 设当前选的位置为 $pos$，找到区间 $[l,r]$ 满足 $l>pos$ 取 $pos$ 为这些区间中 $r$ 的最小值。

一个解法就是对 $r$ 进行排序，当 $pos<l$ 时令 $pos\gets r$。

显然我们可以选择一种方案，然后钦定这种方案中每个不选，然后直接贪心，但是这个复杂度时 $O(nm\log m)$ 的。

但是为什么解决这个问题一定需要贪心呢？我们被前人的思维深深地束缚了！

注意到区间是静态的，所以每个位置的后继位置不变，直接上 dp，定义 $dp_i$ 表示上一个选的位置为 $i$ 时下一个的答案。

我们直接维护 $mi_x$ 表示 $l\ge x$ 时 $r$ 的最小值，就是个后缀 $\min$，显然可以做到 $O(n+m)$ 初始化，没有的记得设成 $\infty$

dp 的转移已经显而易见了：

$$dp_i\gets \begin{cases}0,mi_{i+1}>n\\dp_{mi_{i+1}}+1,mi_{i+1}\le n\end{cases}$$

显然可以 $O(n)$ 地算出来。

求初始的方案直接用 $dp_0$ 的转移路径即可。

然后对于路径上的第 $i$ 个值 $x$，我们怎么判断它是否可行呢？

**Lemma**：一定存在一个区间 $[l,x]$ 使得其只被 $x$ 覆盖。

**证明**：考虑回到贪心的本质。$x$ 被选出来就一定存在一个区间 $[l,x]$ 满足上一个取的点 $pos<l$，同时后面取的点都 $>x$，显然都不在 $[l,x]$ 这个区间内。

引理告诉我们，我们需要取一个 $[l,x)$ 中的点，显然贪心地，应该是取 $x-1$。后面的取法没有影响，所以后面要取的数量显然是 $dp_{x-1}$。所以只需要比较 $i+dp_{x-1}$ 和 $k$ 的大小关系即可，能直接 $O(1)$ 算，所以时间复杂度是 $O(n)$ 的。

但是注意到如果存在 $[x,x]$ 的单元素区间的话，$x-1$ 会直接转移到 $x$，但是此时我们钦定 $x$ 不选，会锅。

但是显然如果有单元素区间 $[x,x]$，那么 $x$ 是必选的，特判一下即可。

---

## 作者：Deu5ExMach1na (赞：8)

既然题解区和网上都没人发贪心的证明，那我姑且就写一篇吧。


------------


### 0. 题意转换：
> 给定一些闭区间：

> 求最少添加多少个点能让所有区间内至少有一个点。

> 即最少点区间覆盖（瞎编的名字）。


------------


### 1. 初步分析：
发现若大区间内包含一个小区间，则可以将大区间删去。

（因为小区间内必定有点，所以也满足了大区间的约束，又因为要用最少的点，所以大区间的其他地方不需要添加点）

在删去了所有的大区间后：若我们把所有区间按左端点排序，显然，右端点也是递增的。（不然必会有包含关系）

### 2. 再度分析：
如图：这是我们排好序的区间：

$ \{ I_1$，$I_2$，$I_3$，$I_4$，$I_5$，$I_6$，……，$I_n \} $

假设我们在区间 $I_4$ 处的某一个点放置一个点，它使得 $I_1$，$I_2$，$I_3$，$I_4$ 内都有了一个点，那么可以轻易推导，我们在 $I_1$ 的最右端放一个点，它的效果和在 $I_4$ 处某个地方放一个的点是等效的。

这意味着任何一个放置方案都可以转化为只在一些区间的右端放一些点，包括最优方案。

所以我们只用找**在区间右端点放点的最优方案**。

### 3. 再再度分析：
假设我们在 $I_j$ 的右端点处放了一个点，它使 $I_j$ 至 $I_a$ 的区间满足了需求，而若在 $I_{j-1}$ 处放一个点，它使 $I_{j-1}$ 至 $I_b$ 的区间满足了需求，则 $b$ 一定小于 $a$。

换成人话，若在上一个区间放点，它的作用效果必定减小。

这说明：最优的放点方案，任意相邻的两个点，**后一个点一定紧接在前一个点的有效范围后面**，不会在里面。



------------
于是，这便得到了贪心的放点方案：

从 $1$ 扫到 $n$，必须放就放在最右端，不用放点就跳过。


---

## 作者：小塘空明 (赞：7)

**（1）：**先预处理出不被0覆盖的点，然后对每个点处理出在它左边离他最近的点和在他右边理他最近的点。

**（2）：**对于每个至少存在一个忍者的区间，先将它左右边界处理为不被0所覆盖。排序后将包含其他区间的区间去除。

**（3）：**贪心求出前i个区间最小忍者数和后i个区间最小忍者数。

**（4）：**进行判断时，若当前区间不需要忍者，则跳过。必须放到区间最右边时，即放到最右边左边一个不可行，所以二分求出覆盖最右边左边一个点的范围l-r，若
f[l-1]+g[r+1]+1>k，则必须放到区间最右边。

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<string>
#include<vector>
using namespace std;
typedef long long ll;
const ll size=1e5+10,inf=1e12;
struct node{
	ll l,r,c;
}a[size];
struct segmentree{
	ll l,r,sum,add;
	#define l(x) tree[x].l
	#define r(x) tree[x].r
	#define sum(x) tree[x].sum
	#define add(x) tree[x].add
}tree[size*4];
ll n,k,m,id,flag;
ll h[size],pl[size],pr[size];
ll top,ql[size],qr[size];
ll f[size],g[size];
vector<pair<ll,ll> >b;
ll read(){
	ll x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+ch-'0';ch=getchar();}
	return x*f;
}
void build(ll p,ll l,ll r){
	l(p)=l;r(p)=r;
	if(l==r) return;
	ll mid=(l(p)+r(p))>>1;
	build(p*2,l,mid);build(p*2+1,mid+1,r);
}
void spread(ll p){
	if(add(p)){
		add(p*2)=add(p);add(p*2+1)=add(p);
		sum(p*2)=add(p);sum(p*2+1)=add(p);
		add(p)=0;
	}
}
void change(ll p,ll l,ll r){
	if(l<=l(p)&&r(p)<=r){
		sum(p)=add(p)=1;return;
	}
	spread(p);
	ll mid=(l(p)+r(p))>>1;
	if(l<=mid) change(p*2,l,r);
	if(r>mid) change(p*2+1,l,r);
}
ll query(ll p,ll pos){
	if(sum(p)==1) return 1;
	if(l(p)==r(p)) return 0;
	spread(p);
	ll mid=(l(p)+r(p))>>1;
	if(pos<=mid) return query(p*2,pos);
	else return query(p*2+1,pos);
}
int main(){
	n=read();k=read();m=read();
	build(1,1,n);
	for(ll i=1;i<=m;i++) a[i].l=read(),a[i].r=read(),a[i].c=read();
	for(ll i=1;i<=m;i++){
		if(!a[i].c) change(1,a[i].l,a[i].r);
	}
	for(ll i=1;i<=n;i++){
		if(!query(1,i)) ql[i]=qr[i]=++id,h[id]=i;
	}
	if(id==k){
		for(ll i=1;i<=k;i++) printf("%lld\n",h[i]);
		return 0;
	}
	for(ll i=1;i<=n;i++) if(!qr[i]) qr[i]=qr[i-1];
	ql[n+1]=inf;
	for(ll i=n;i>=1;i--) if(!ql[i]) ql[i]=ql[i+1];
	for(ll i=1;i<=m;i++){
		if(a[i].c){
			ll l=a[i].l,r=a[i].r;
			l=ql[l];r=qr[r];
			if(l>r) continue;
			b.push_back(make_pair(l,r));
		}
	}
	sort(b.begin(),b.end());
	ll mx=0,mn=inf;
	for(ll i=0;i<b.size();i++){
		while(top&&pl[top]<=b[i].first&&b[i].second<=pr[top]) top--;
		pl[++top]=b[i].first;pr[top]=b[i].second;
	}
	for(ll i=1;i<=top;i++){
		if(pl[i]>mx) f[i]=f[i-1]+1,mx=pr[i];
		else f[i]=f[i-1];
	}
	for(ll i=top;i>=1;i--){
		if(pr[i]<mn) g[i]=g[i+1]+1,mn=pl[i];
		else g[i]=g[i+1];
	}
	for(ll i=1;i<=top;i++){
		if(f[i]!=f[i-1]+1) continue;
		if(pl[i]==pr[i]){
			flag=1;printf("%lld\n",h[pl[i]]);
		}
		else{
			ll x=pr[i]-1,t1=0,t2=top+1;
			ll l=1,r=i-1;
			while(l<=r){
				ll mid=(l+r)>>1;
				if(pr[mid]<x)t1=mid,l=mid+1;
				else r=mid-1;
			}
			l=i+1,r=top;
			while(l<=r){
				ll mid=(l+r)>>1;
				if(pl[mid]>x)t2=mid,r=mid-1;
				else l=mid+1;
			}
			if(f[t1]+g[t2]+1>k){
				flag=1;
				printf("%lld\n",h[pr[i]]);
			}
		}
	}
	if(!flag) printf("-1\n");
	return 0;
}
```

---

## 作者：Milky_Way (赞：6)

这是一道挺不错的题，目前还没有题解我就写一篇吧。

首先把为 0 的区间删去，重新标号，可以差分也可以线段树，我用的差分。

把包含其他线段的线段删去，原因 1 是它没有用，原因 2 下面再说。然后，贪心选取最少的点来满足所有线段，即选取还没有点在上面的线段的右端点。如下图中选取的红色方格。

![](https://images2018.cnblogs.com/blog/1326357/201803/1326357-20180307194439393-689488987.png)

倘若不删去包含其他线段的线段，如上图中的蓝色虚线，我们在贪心选取点的时候，就会先扫到蓝线的左端点而后扫到第二条红线，按照规则，我们会选择蓝线的右端点 6 号点，接下来扫到第二条红线时，由于它上面并没有点被选取，所以又会选取它的右端点 5 号点，这样显然不是最优的，这就是第 2 个原因。

选完点后，从左往右扫，每扫到一个选取的点，如果该点不是必选的（覆盖它的线段 l ≠ r），就尝试若不选它是否可行，即选取它左边相邻的点，计算出选取这个点时的最少点数，计算方法如下。

如上图，用 F[ i ] 表示前 i 条线段需要选取的最少点数，G[ i ] 表示后 i 条线段需要选取的最少点数，假设现在我们尝试不选 5 号点，计算选取 4 号点时需要选取的最少点数，然后与 k 比较，方法是二分找出右端点最大且小于 4 的线段 x，找出左端点最小且大于 4 的线段 y，若 F[ x ] + G[ y ] + 1 大于 k 则尝试失败，说明先前点是必选的。

```cpp
#include <cstdio>
#include <string>
#include <algorithm>

const int N = 100005;

struct line {
	int l, r, f;
	bool operator < (const line &cmp) const {
		return l < cmp.l;
	}
} a[N];

int b[N], L[N], R[N], be[N], F[N], G[N];

int read() {
	int x = 0, f = 1;
	char c = getchar();
	while (!isdigit(c)) {
		if (c == '-') f = -1;
		c = getchar();
	}
	while (isdigit(c)) {
		x = (x << 3) + (x << 1) + (c ^ 48);
		c = getchar();
	}
	return x * f;
}

int main() {
	int n = read(), k = read(), m = read();
	for (int i = 1; i <= m; ++ i) {		//差分标记为 0 的区间 
		a[i].l = read(), a[i].r = read(), a[i].f = read();
		if (a[i].f == 0) ++b[a[i].l], --b[a[i].r+1];
	}
	int cur = 0, cnt = 0;
	for (int i = 1; i <= n; ++ i) {		//去除为 0 的区间并重新标号 
		cur += b[i];
		if (cur == 0) L[i] = R[i] = ++cnt, be[cnt] = i;
	}
	if (cnt == k) {						//恰好满足 
		for (int i = 1; i <= cnt; ++ i) printf("%d\n", be[i]);
		return 0;
	}
	L[n + 1] = n + 1;
	for (int i = 1; i <= n; ++ i)
		if (R[i] == 0) R[i] = R[i - 1];
	for (int i = n; i >= 1; -- i)
		if (L[i] == 0) L[i] = L[i + 1];
	cnt = 0;
	for (int i = 1; i <= m; ++ i) {
		if (a[i].f == 0) continue;
		int l = L[a[i].l], r = R[a[i].r];
		if (l <= r) a[++cnt].l = l, a[cnt].r = r;
	}
	std::sort(a + 1, a + cnt + 1);
	int top = 0;
	for (int i = 1; i <= cnt; ++ i) {	//去除包含其他线段的线段 
		while (top && a[i].l >= L[top] && a[i].r <= R[top]) --top;
		L[++top] = a[i].l, R[top] = a[i].r;
	}
	int l = n + 1, r = 0;
	for (int i = 1; i <= top; ++ i) {	//贪心选取最少的点 
		if (L[i] > r) F[i] = F[i - 1] + 1, r = R[i];
		else F[i] = F[i - 1];
	}
	for (int i = top; i >= 1; -- i) {
		if (R[i] < l) G[i] = G[i + 1] + 1, l = L[i];
		else G[i] = G[i + 1];
	}
	bool ok = 0;
	for (int i = 1; i <= top; ++ i) {	//尝试不选 
		if (F[i] == F[i - 1]) continue;
		if (L[i] == R[i]) {
			printf("%d\n", be[R[i]]);
			ok = 1; continue;
		}
		int l = 1, r = i - 1, x = 0, y = top + 1;
		while (l <= r) {				//二分查找 
			int mid = l + ((r - l) >> 1);
			if (R[mid] < R[i] - 1) x = mid, l = mid + 1;
			else r = mid - 1;
		}
		l = i + 1, r = top;
		while (l <= r) {
			int mid = l + ((r - l) >> 1);
			if (L[mid] > R[i] - 1) y = mid, r = mid - 1;
			else l = mid + 1;
		}
		if (F[x] + G[y] + 1 > k) {
			printf("%d\n", be[R[i]]);
			ok = 1;
		}
	}
	if (!ok) puts("-1");
	return 0;
}
```

---

## 作者：信守天下 (赞：5)

## [洛谷传送门](https://www.luogu.com.cn/problem/P3634)
## 思路
我们可以将每个灌木丛看成一个点，一段连续的灌木丛看成一个区间。

此时，有忍者的区间可以标记为 $1$，没有的可以标记成 $0$。

显然，所有为 $0$ 的区间都是没有用的，可以直接删去，使用差分或线段树。

定义 `pair` 数组 $q[i]$ 表示左右离当前点最近的 $1$ 点的。

则对于每个 $1$ 点， $q[i].first = q[i].second = 1$。

对于每个 $0$ 点
$\begin{cases}q[i].first = q[i - 1].first\\ q[i].second = q[i + 1].second \end{cases}$

将剩余的区间进行双关键字排序，优先左边界。

可以发现，如果一个区间包含了另一个区间，那么大的区间是一定有解的。

例如一个守卫看到区间 $[1\ 5\ 1]$，另一个守卫看到区间 $[2\ 3\ 1]$。

因为 $[1,5]$ 这个区间内包含了 $[2,3]$，所以 $[1,5]$ 区间是一定满足要求的。

所以，可以直接删去所有包含另一个区间的区间。

接下来，可以用贪心求出前缀区间的忍者数和后缀区间的忍者数。

最后，利用前缀数组和后缀数组求解。

注意特判两种情况：

+ 如果当前区间不需要忍者，直接进入下一层。
+ 如果当前区间左右边界一致（即退化成点），此点一定为 $1$，标记解，答案累加。

对于其他情况，尝试在该区间能否找出其他解。

即在当前前缀解和后缀解的基础上二分寻找次优解。

如果次优解能构造方案满足要求，就不能确定点是否为 $1$。

所以，在次优解不满足要求，即忍者过多时，方案是惟一的。

直接输出确定的方案即可。
## code
~~~cpp
#include <algorithm>
#include <cstdio>
#include <iostream>
#include <vector>

using namespace std;
using LL = long long;
using PLL = pair<LL, LL>;

const LL kMaxN = 100001;
const LL Inf = 9223372036854775807LL;

struct Section1 {
  LL l, r;
  LL c;
} sec[kMaxN];

struct Tree {
  LL l, r;
  LL sum, lazy; 
} tree[kMaxN * 4];

LL n, k, m;
LL num;
LL top;        // 去重后的区间个数
LL flag;
LL h[kMaxN];   // 记录每一个为 1 的点的编号
PLL p[kMaxN];  // 去重后的区间左右边界
PLL q[kMaxN];  // 左右离当前点最近的1点
PLL f[kMaxN];  // 前缀区间和后缀区间的忍者数量

vector<PLL> vis;  // 去0后的区间

void Build(LL p, LL l, LL r) {
  tree[p].l = l;
  tree[p].r = r;
  if (l == r) {
    return;
  }
  LL mid = (tree[p].l + tree[p].r) >> 1;
  Build(p * 2, l, mid);
  Build(p * 2 + 1, mid + 1, r);
}

void Push_down(LL p) {
  if (tree[p].lazy) {
    tree[p * 2].lazy = tree[p].lazy;
    tree[p * 2 + 1].lazy = tree[p].lazy;
    tree[p * 2].sum = tree[p].lazy;
    tree[p * 2 + 1].sum = tree[p].lazy;
    tree[p].lazy = 0;
  }
}

void Update(LL p, LL l, LL r) {  // 区间覆盖
  if (l <= tree[p].l && tree[p].r <= r) {
    tree[p].sum = tree[p].lazy = 1;
    return;
  }
  Push_down(p);
  LL mid = (tree[p].l + tree[p].r) >> 1;
  if (l <= mid) {
    Update(p * 2, l, r);
  }
  if (r > mid) {
    Update(p * 2 + 1, l, r);
  }
}

LL Query(LL p, LL pos) {   // 查询单点0/1
  if (tree[p].sum == 1) {
    return 1;
  }
  if (tree[p].l == tree[p].r) {
    return 0;
  }
  Push_down(p);
  LL mid = (tree[p].l + tree[p].r) >> 1;
  if (pos <= mid) {
    return Query(p * 2, pos);
  } else {
    return Query(p * 2 + 1, pos);
  }
}

void Unique() {                  // 区间去重
  for (LL i = 1; i <= m; i++) {
    if (sec[i].c) {              // 当前区间为1
      LL l = sec[i].l;
      LL r = sec[i].r;
      l = q[l].second;           // 右边最近的点
      r = q[r].first;            // 左边最近的点
      if (l > r) {               // 左边界比右边界大(即该区间被0覆盖)
        continue;                // 不加入该区间(即删除该区间)
      }
      vis.push_back({l, r});  // 加入该区间
    }
  }

  sort(vis.begin(), vis.end());                                                             // 对去0后的区间排序
  for (LL i = 0; i < vis.size(); i++) {                                                     // 求区间去重
    for (; top && p[top].first <= vis[i].first && vis[i].second <= p[top].second; top--) {  // 当前区间包含其他区间，当前区间退栈
    }
    p[++top] = vis[i];  // 区间入栈
  }
}

int main() {
  ios_base::sync_with_stdio(0);
  cin.tie(0), cout.tie(0);
  cin >> n >> k >> m;
  Build(1, 1, n);  // 建树

  for (LL i = 1; i <= m; i++) {
    cin >> sec[i].l >> sec[i].r >> sec[i].c;
  }

  for (LL i = 1; i <= m; i++) {       // 处理每个区间
    if (!sec[i].c) {                  // 区间为0
      Update(1, sec[i].l, sec[i].r);  // 区间覆盖
    }
  }

  for (LL i = 1; i <= n; i++) {          // 处理每个点
    if (!Query(1, i)) {
      q[i].second = q[i].first = ++num;  // 左右最近的1都为自身
      h[num] = i;                        // 记录标号
    }
  }

  if (num == k) {                  // 刚好k个点
    for (LL i = 1; i <= k; i++) {  // 遍历每个点
      cout << h[i] << endl;        // 输出每个点的位置
    }
    return 0;
  }

  for (LL i = 1; i <= n; i++) {     // 处理左边最近的1点
    if (!q[i].first) {
      q[i].first = q[i - 1].first;  // 左边最近的1点的编号
    }
  }

  for (LL i = n; i >= 1; i--) {       // 处理右边最近的1点
    if (!q[i].second) {
      q[i].second = q[i + 1].second;  // 右边最近的1点的编号
    }
  }
  Unique();
  LL ls = 0;    // 在区间左端点放置忍者时已完成距离
  LL rs = Inf;  // 在区间右端点放置忍者时已完成距离

  for (LL i = 1; i <= top; i++) {       // 贪心求前i个区间的忍者数
    if (p[i].first > ls) {
      f[i].first = f[i - 1].first + 1;
      ls = p[i].second;
    } else {
      f[i].first = f[i - 1].first;
    }
  }

  for (LL i = top; i >= 1; i--) {         // 贪心求后i个区间的忍者数
    if (p[i].second < rs) {
      f[i].second = f[i + 1].second + 1;
      rs = p[i].first;
    } else {
      f[i].second = f[i + 1].second;
    }
  }

  for (LL i = 1; i <= top; i++) {
    if (f[i].first != f[i - 1].first + 1) {  // 当前区间的左边界没有放置忍者
      continue;
    }
    if (p[i].first == p[i].second) {        // 当前区间左右边界相同(即退化成点)
      flag = 1;                             // 标记有解
      cout << h[p[i].first] << endl;        // 输出当前区间的编号
    } else {                                // 寻找次优解
      LL t1 = 0;                            // 左边界
      LL t2 = top + 1;                      // 右边界
      for (LL l = 1, r = i - 1; l <= r;) {  // 二分求出次优解左边界
        LL mid = (l + r) >> 1;
        if (p[mid].second < p[i].second - 1) {
          t1 = mid;
          l = mid + 1;
        } else {
          r = mid - 1;
        }
      }
      for (LL l = i + 1, r = top; l <= r;) {  // 二分求出次优解右边界
        LL mid = (l + r) >> 1;
        if (p[mid].first > p[i].second - 1) {
          t2 = mid, r = mid - 1;
        } else {
          l = mid + 1;
        }
      }
      if (f[t1].first + f[t2].second + 1 > k) {  // 次优解不满足
        flag = 1;                                // 标记有解
        cout << h[p[i].second] << endl;          // 方案固定
      }
    }
  }
  if (!flag) {  // 无解
    cout << -1;
  }
  return 0;
}
~~~

---

## 作者：封禁用户 (赞：3)

# P3634 [APIO2012] 守卫 题解
## 题面
给 $m$ 个限制，可以是一段区间中必须有或者必须无忍者。

最多有 $k$ 个忍者，问有多少个位点一定有忍者。
## 分析
首先用差分标记一下 $0$ 忍者的区间，去掉。

然后再删去包含了其他区间的区间，没有意义。

将剩余区间按左端点排序，方便处理。

考虑计算处理到第i个区间所需的最少忍者数，如果该区间内没有已经被选择的点，贪心选择右端点使总点数最少。

倒着处理一遍，类似，不过是贪心选择左端点。

枚举每个右端点考虑不选择它而选择它的左侧端点，并二分找到不与它相交的最近的左右两个区间。

若从左侧开始处理到左侧区间的最少忍者数加从右侧开始处理到右侧区间的最少忍者数加一（选择当前区间）的所需忍者数大于 $k$ ，那么说明不选这个右端点是不合法的，所以这个点必选。
```cpp
#include <iostream> 
#include <cstdio>
#include <algorithm>
using namespace std;
const int N=1e5+10;
struct Guard {
    int a,b,c;
}g[N];
int n,k,m,zm,gcnt;
int zer[N],ref[N],rcnt,nearl[N],nearr[N],f[N],h[N];
bool ans;

bool CMP(Guard a,Guard b) {return a.a<b.a;}

int main() {
    scanf("%d%d%d",&n,&k,&m);
    for (int i=1;i<=m;i++) {
        scanf("%d%d%d",&g[i].a,&g[i].b,&g[i].c);
        if (!g[i].c) zer[g[i].a]++,zer[g[i].b+1]--;
    }
    for (int i=1;i<=n;i++) {
        zer[i]+=zer[i-1];
        if (!zer[i]) ref[nearl[i]=nearr[i]=++rcnt]=i;
        else nearl[i]=n+1;
    }
    if (rcnt==k) {for (int i=1;i<=rcnt;i++) printf("%d\n",ref[i]);return 0;}
    for (int i=2;i<=n;i++) nearr[i]=max(nearr[i],nearr[i-1]),nearl[n-i+1]=min(nearl[n-i+1],nearl[n-i+2]);
    for (int i=1;i<=m;i++) if (g[i].c&&nearl[g[i].a]<=nearr[g[i].b]) g[++zm].a=nearl[g[i].a],g[zm].b=nearr[g[i].b];
    sort(g+1,g+zm+1,CMP);
    for (int i=1;i<=zm;i++) {
        while (gcnt&&g[gcnt].a<=g[i].a&&g[i].b<=g[gcnt].b) gcnt--;
        g[++gcnt]=g[i];
    }
    for (int i=1,r=0;i<=gcnt;i++) if (g[i].a>r) f[i]=f[i-1]+1,r=g[i].b; else  f[i]=f[i-1];
    for (int i=gcnt,l=n+1;i;i--) if (g[i].b<l) h[i]=h[i+1]+1,l=g[i].a; else h[i]=h[i+1];
    for (int i=1,l,r,mid,ansl,ansr;i<=gcnt;i++)
        if (f[i]!=f[i-1])
            if (g[i].a==g[i].b) printf("%d\n",ref[g[i].b]),ans=1;
            else {
                l=1;r=i-1;ansl=0;
                while (l<=r) {
                    mid=l+r>>1;
                    if (g[mid].b<g[i].b-1) l=mid+1,ansl=mid; else r=mid-1;
                }
                l=i+1;r=gcnt;ansr=n+1;
                while (l<=r) {
                    mid=l+r>>1;
                    if (g[mid].a>g[i].b-1) r=mid-1,ansr=mid; else l=mid+1;
                }
                if (f[ansl]+1+h[ansr]>k) printf("%d\n",ref[g[i].b]),ans=1;
            }
    if (!ans) printf("-1\n");
}
```

---

## 作者：BetterGodPig (赞：3)

## 守卫

$p.s.$ ：本蒟蒻一直想不懂这道题，是在借鉴了大佬的[这篇](https://www.luogu.com.cn/blog/Mikazuki-Munechika/solution-p3634)博客后才理解的，所以这篇题解可能是对前面指的那一篇的补充。

>  题意简述：给定01区间 $[1,n]$ 与若干条件，第 $i$ 条件会限制区间 $[l_i,r_i]$ 是否有1，整个区间共有k个1，求那些位置必须是1。

首先，抛开1的数量的约束条件不管，这个题就变成了区间选点问题，贪心即可。

那么就有基本的想法就是，把不被覆盖的区间去掉后贪心处理剩下的区间。

### 关于去掉不覆盖区间

显然的想法是进行标记，这里就涉及到两种思路，线段树区间加和差分区间修改，这里选择第二种，统计完过后做一次前缀和得到答案。

### 几种情况

在去掉了不被覆盖的区间后，如果剩下的位置刚好有 $\text{k}$ 个，那么就可以把这些位置全部输出。

而对于剩下的情况，我们可以这样处理。

讨论两个区间之间的位置关系，如果是包含关系，显然可以去掉更大的那个区间，保留内层区间，即左端点更大但右端点更小的区间，这一部分可以先以左端点为关键字排序在使用单调栈维护。而对于有交集的区间，显然放在左边那个区间的右端点是更优的选择，那么为了统一处理方式，我们将无交集的也把点放在区间的最右端点，因为这样显然不会对答案造成影响。

然后就可以按照区间选点的板子贪心求前i个和后i个区间的最小点数，对每个区间判断时，首先如果 $l = r$ 那么这个区间就是必须要放的，然后再判断如果这个点不放是否合法，如果不合法就是必须要放的了，判断合法的过程即是找到覆盖当前区间右端点左边一个的位置的区间，找到前后的加起来，看是否会超过。

```cpp
#include <bits/stdc++.h>
#define pii pair<int,int>
#define mp make_pair
#define pb emplace_back
using namespace std;
const int NN = 1e5+5;
int maxn = -1,minn = 1e9+5;
int n,m,k,cnt;
int det[NN],ori[NN];
int l[NN],r[NN];
int pre[NN],nxt[NN];
vector<pii> g;
int ans[NN],tot;
int main(){
    cin>>n>>k>>m;
    for(int i(1);i <= m;++i){
        int ll,rr,opt;
        cin>>ll>>rr>>opt;
        if(!opt) ++det[ll],--det[rr+1];
        else g.pb(mp(ll,rr));
    }
    for(int i(1);i <= n;++i){
        det[i] += det[i-1];
        if(!det[i]) l[i] = r[i] = ++cnt,ori[cnt] = i;
    }
    if(cnt == k){
        for(int i(1);i <= cnt;++i){
            cout<<ori[i]<<'\n';
        }
        return 0;
    }
    for(int i(1);i <= n;++i){
        if(!l[i]) l[i] = l[i-1];
    }
    for(int i(n);i;--i){
        if(!r[i]) r[i] = r[i+1];
    }
    for(auto &tmp:g){
        tmp.first = r[tmp.first];
        tmp.second = l[tmp.second];
    }
    sort(g.begin(),g.end());
    stack<pii> s;
    for(auto tmp:g){
        while(s.size() && s.top().second >= tmp.second) s.pop();
        s.push(tmp);
    }
    g.clear();
    while(!s.empty()){
        g.pb(s.top());
        s.pop();
    }
    sort(g.begin(),g.end());
    for(int i(0);i < g.size();++i){
        if(!i) maxn = g[i].second,pre[i] = 1;
        if(g[i].first > maxn) pre[i] = pre[i-1]+1,maxn = g[i].second;
        else pre[i] = pre[i-1];
    }
    for(int i(g.size()-1);i>=0;--i){
        if(g[i].second < minn) nxt[i] = nxt[i+1]+1,minn = g[i].first;
        else nxt[i] = nxt[i+1];
    }
    for(int i(0);i < g.size();++i){
        if(g[i].first == g[i].second){
            ans[++tot] = ori[g[i].second];
            continue;
        }
        if(pre[i] != pre[i-1]+1 && i) continue;
        register int tmp = g.size(),l = i+1,r = g.size()-1;
        while(l <= r){
            int mid = (l+r)>>1;
            if(g[mid].first >= g[i].second){
                tmp = mid;
                r = mid-1;
            }else{
                l = mid+1;
            }
        }
        if(pre[i]+nxt[tmp] >= k) ans[++tot] = ori[g[i].second];
    }
    if(!tot){
        cout<<-1;
        exit(0);
    }
    for(int i(1);i <= tot;++i){
        cout<<ans[i]<<'\n';
    }
    return 0;
}
```



---

## 作者：huangxianghui (赞：2)

### Solution

首先删去不含忍者的区间，因为它们~~没用~~不参与后面的操作

使用线段树的线段覆盖处理出被0包住的区间，统计每个 0 区间的左右边界，并用前缀和统计每个点及之前有几个 0。

如果没有被 0 覆盖的点刚好等于 $k$ 时需要特判，直接输出。

处理剩下的区间，如果区间端点被 0 区间包住了，将区间端点移出 0 区间，防止对后面的操作产生影响，左端点往右挪，右端点往左挪，然后把所有 0 点删掉，并重新编号。

将区间按优先左端点排序，并使用单调队列删去包含其他线段的线段。

从左往右扫一遍线段，每次贪心在每个线段的右端点设一个忍者，如果该线段已经有一个忍者就不设，同样用前缀和数组 $f[i]$ 统计第 $i$ 条线段前有几个忍者，然后再用同样的操作从右往左再扫一遍，取每个线段的左端点，用后缀和数组 $g[i]$ 统计第 $i$ 条线段后有几个忍者。

最后一步，遍历每个可能有忍者的点（如果某区间左右端点相等，可以肯定里面有忍者），假设它左边可以放一个忍者而当前点不放，那么二分查找离该点最近的区间右端点与左端点，设区间 $i$ 的右端点和区间 $j$ 的左端点离其最近，则当 $f[i]+g[i]+1>k$ 时，说明该点必选（否则忍者数肯定不止 $k$ 个）。

完美输出，皆大欢喜。

My Code：

```cpp
#include<bits/stdc++.h>
#define ll long long
#define f(i,a,b) for (ll i=a;i<=b;i++)
#define fx(i,a,b) for (ll i=a;i>=b;i--)
#define lt(x) x<<1
#define rt(x) x<<1|1//线段树
using namespace std;
const int maxn=2e5+10;
int n,k,m,cnt,cntt;
bool tag[maxn<<2];
int num[maxn];
int ls[maxn],rs[maxn],num1[maxn],num2[maxn];
struct node
{
	int l,r;
} a[maxn],b[maxn];

int f[maxn],g[maxn],num3[maxn],outp[maxn];
bool cmp(node x,node y)
{
	if (x.l^y.l) return x.l<y.l;
	return x.r>y.r;//从小到大排左端点，再从大到小排右端点，这样才能用优先队列处理
}
inline ll read()
{
	ll l=0,f=1;
	char c=getchar();
	while (c<'0' || c>'9')
	{
		if (c=='-') f=-1;
		c=getchar();
	}
	while (c>='0' && c<='9') l=(l<<3)+(l<<1)+(c^'0'),c=getchar();
	return l*f;
}
inline void push_down(ll p,ll l,ll r)
{
	ll mid=l+r>>1;
	tag[lt(p)]|=tag[p],tag[rt(p)]|=tag[p];
}
inline void build(ll l,ll r,ll p)
{
	push_down(p,l,r);
	if (l==r)
	{
		num[l]=p;
		return;
	}
	ll mid=l+r>>1;
	build(l,mid,lt(p)),build(mid+1,r,rt(p));
}
inline void add(ll nl,ll nr,ll l,ll r,ll p)
{
	if (nl<=l && nr>=r)
	{
		tag[p]=1;
		return;
	}
	ll mid=l+r>>1;
	push_down(p,l,r);
	if (nl<=mid && !tag[lt(p)]) add(nl,nr,l,mid,lt(p));
	if (nr>mid && !tag[rt(p)]) add(nl,nr,mid+1,r,rt(p));
}
signed main()
{
	n=read(),k=read(),m=read(),build(1,n,1);
	f(i,1,m)
	{
		int a1=read(),a2=read(),a3=read();
		if (a3) a[++cnt].l=a1,a[cnt].r=a2;//重新编号区间
		else add(a1,a2,1,n,1);//0区间覆盖
	}
	build(1,n,1);
	{
		bool l=0;
		int lass=0;
		f(i,1,n)
		{
			num2[i]=num2[i-1];//0点的前缀和统计
			if (tag[num[i]])
			{
				if (!l) l=1,lass=i,++cntt,ls[cntt]=lass;//0区间的左端点统计
				num1[i]=cntt,num2[i]++;//num1数组优化，便于查找当前所在的0区间
			}
			else if (l) l=0,rs[cntt]=i-1;//右端点统计
		}
	}
	if (n-num2[n]==k)//没被0覆盖的点数量等于k
	{
		f(i,1,n)
		{
			if (!tag[num[i]]) printf("%d\n",i);
		}
		return 0;
	}
	if (rs[cntt]==0) rs[cntt]=n;
	f(i,1,cnt)
	{
		if (tag[num[a[i].l]]) a[i].l=rs[num1[a[i].l]]+1;//左端点往右挪
		if (tag[num[a[i].r]]) a[i].r=ls[num1[a[i].r]]-1;//右端点往左挪
	}
	f(i,1,n)
	{
		if (!tag[num[i]]) num3[i-num2[i]]=i;//重新编号
	}
	f(i,1,cnt) a[i].l-=num2[a[i].l],a[i].r-=num2[a[i].r];//重新对区间左右端点编号
    //下面在新序列上进行操作，和重新编号前的序列无关了
	cntt=0,sort(a+1,a+1+cnt,cmp);//排序
	f(i,1,cnt)
	{
		while (cntt && b[cntt].l<=a[i].l && b[cntt].r>=a[i].r) cntt--;//单调队列处理包含区间
		b[++cntt].l=a[i].l,b[cntt].r=a[i].r;
	}
	int sum=0;
	f(i,1,cntt)
	{
		f[i]=f[i-1];
		if (sum>=b[i].l) continue;
		sum=b[i].r,f[i]++;//贪心取区间右端点，前缀和统计
	}
	sum=n-num3[n]+1;
	fx(i,cntt,1)
	{
		g[i]=g[i+1];
		if (sum<=b[i].r) continue;
		sum=b[i].l,g[i]++;//贪心取区间左端点，后缀和统计
	}
	cnt=0;
	f(i,1,cntt)
	{
		if (f[i]==f[i-1]) continue;//该点没有忍者
		if (b[i].l==b[i].r)//左右端点相等，该草丛必定有忍者
		{
			outp[++cnt]=num3[b[i].r];
			continue;
		}
		int l=1,r=i-1,x=0,y=cntt+1;
		while (l<=r)//二分找左边离其最近的的区间右端点
		{
			int mid=(l+r)>>1;
			if (b[mid].r<b[i].r-1) x=mid,l=mid+1;
			else r=mid-1;
		}
		l=i+1,r=cntt;
		while (l<=r)//二分找右边离其最近的的区间左端点
		{
			int mid=(l+r)>>1;
			if (b[mid].l>b[i].r-1) y=mid,r=mid-1;
			else l=mid+1;
		}
		if (f[x]+g[y]+1>k) outp[++cnt]=num3[b[i].r];//判断
	}
	if (cnt) f(i,1,cnt) printf("%d\n",outp[i]);//输出
	else printf("-1");
}
```



---

## 作者：reyik (赞：2)

~~这次就不废话了~~

用差分把为$0$的区间$kacha$,重新编号

然后将包含其他线段的线段$kacha$

具体这样来：

枚举每一个线段，如果当前线段上还没有点，就选取这个线段的右端点。

然后预处理：

用$f[i]$表示前$i$条线段需要选取的最少点数，$g[i]$表示后 $i$ 条线段需要选取的最少点数

然后枚举每一个筛选出来的点

如果覆盖当前点的线段长度$>1$，那么就判断这个点能不能不选(~~这不废话~~)

二分

第一次找出右端点最大且小于$(x-1)$的线段$a$

然后找出左端点最小且大于$(x-1)$的线段$b$

如果$f[a]+f[b]+1>k$ 这$x$点必选。

```
#include <iostream>
#include <cstdio>
#include <algorithm>
#define Rint register int
#define Temp template<typename T>
using namespace std;
Temp inline void read(T &x) {
	x=0;T w=1,ch=getchar();
	while(!isdigit(ch)&&ch!='-') ch=getchar();
	if(ch=='-') w=-1,ch=getchar();
	while(isdigit(ch)) x=x*10+ch-'0',ch=getchar();
	x*=w;
} 
Temp inline void write(T x) {
	if(x<0) putchar('-'),x=-x;
	if(x>=10) write(x/10);
	putchar(x%10+'0');
}
const int maxn=1e5+10;
struct xian{
	int l,r,d;
}a[maxn];
int f[maxn],g[maxn],l[maxn],r[maxn],n,m,k,cnt=0,b[maxn],c[maxn];
bool cmp(xian a,xian b) {
	return a.l<b.l;
}
int main() {
	read(n);read(k);read(m);
	for (Rint i=1;i<=m;++i) {
		read(a[i].l);read(a[i].r);read(a[i].d);
		if(a[i].d==0) {
			++b[a[i].l];
			--b[a[i].r+1];
		}
	}
	int res=0;cnt=0;
	for (Rint i=1;i<=n;++i) {
		res+=b[i];
		if(res==0) {
			++cnt;
			l[i]=cnt;
			r[i]=cnt;
			c[cnt]=i;
		}
	}
	if(cnt==k) {
		for (Rint i=1;i<=cnt;++i) {
			write(c[i]);putchar('\n');
		}
		return 0;
	}
	l[n+1]=n+1;
	for (Rint i=1;i<=n;++i) if(r[i]==0) r[i]=r[i-1];
	for (Rint i=n;i>=1;--i) if(l[i]==0) l[i]=l[i+1];
	cnt=0;
	for (Rint i=1;i<=m;++i) {
		if(a[i].d==0) continue;
		int ll=l[a[i].l],rr=r[a[i].r];
		if(ll<=rr) {
			++cnt;
			a[cnt].l=ll;
			a[cnt].r=rr;
		}
	}
	stable_sort(a+1,a+1+cnt,cmp);
	res=0;
	for (Rint i=1;i<=cnt;++i) {
		while((res)&&(a[i].l>=l[res])&&(a[i].r<=r[res])) --res;
		++res;
		l[res]=a[i].l;r[res]=a[i].r;
	}
	int ll=n+1,rr=0;
	for (Rint i=1;i<=res;++i) {
		if(l[i]>rr) {
			f[i]=f[i-1]+1;
			rr=r[i];
		}
		else f[i]=f[i-1];
	}
	for (Rint i=res;i>=1;--i) {
		if(r[i]<ll) {
			g[i]=g[i+1]+1;
			ll=l[i];
		}
		else g[i]=g[i+1];
	}
	bool flag=false;
	for (Rint i=1;i<=res;++i) {
		if(f[i]==f[i-1]) continue;
		if(l[i]==r[i]) {
			write(c[r[i]]);putchar('\n');
			flag=true;
			continue;
		}
		int ll=1,rr=i-1,x=0,y=res+1;
		while(ll<=rr) {
			int mid=ll+((rr-ll)>>1);
			if(r[mid]<r[i]-1) x=mid,ll=mid+1;
			else rr=mid-1;
		}
		ll=i+1;rr=res;
		while(ll<=rr) {
			int mid=ll+((rr-ll)>>1);
			if(l[mid]>r[i]-1) y=mid,rr=mid-1;
			else ll=mid+1;
		}
		if((f[x]+g[y]+1)>k) {
			write(c[r[i]]);putchar('\n');
			flag=true;
		}
	}
	if(!flag) puts("-1");
	return 0;
}

```

---

## 作者：_ZSR_ (赞：1)

### [P3634 [APIO2012] 守卫](https://www.luogu.com.cn/problem/P3634)

先考虑一些简单的情况。我们把所有确定没有忍者的位置扣掉，如果剩下的位置数量恰好为 $k$，那么它们全部都可以确定。不然的话，如果某个区间里只剩一个位置了，那么这个位置可以确定。

但是其他位置也有可以确定的，我们怎么判断呢？首先，不难发现，如果一个区间包含另一个区间，那么这个区间就可以删掉了，因为满足小区间必定就会满足大区间。这样的话剩下的所有区间满足左右端点同时递增，因为包含的已经被我们删掉了。

我们考虑什么情况下一个位置是必选的。显然当不选这个位置无解的时候这个位置就必选。好像是句废话，但是这道题的关键就在这里。当我们把所有确定没有忍者的位置扣掉后，就没有位置限制了，剩下的就只是数量限制，那么无解就只能是数量多了。因此我们就要用尽可能少的点覆盖所有线段，并且我们有上面的那个性质，所以直接贪心的每次取一条线段的右端点。对于一条线段的右端点，如果它被选择了，那么它有可能是确定的。这个时候我们就要看不选它能不能满足条件。根据贪心，在不选它的情况下选它前面一个位置一定是最优的。假设 $1$ 到 $i$ 的线段的右端点都小于 $r-1$，$j$ 到 $m$ 的右端点都大于 $r-1$，那么如果覆盖 $1$ 到 $i$ 所需的最少点数加上覆盖 $j$ 到 $m$ 所需的最小点数加一大于 $k$，那么说明无解，这个点就是确定的。

$i$ 和 $j$ 都可以二分找到，覆盖的最少点数可以通过预处理 $O(n)$ 求。具体的，我们令 $f_{i}$ 表示覆盖 $1$ 到 $i$ 所需的最小点数。如果上一个选取的位置小于 $l_{i}$，那么令 $f_{i}=f_{i-1}+1$，否则令 $f_{i}=f_{i-1}$。后缀同理，贪心选择左端点即可。

code
```
#include <bits/stdc++.h>
using namespace std;
const int N=1e5+10;
int n,k,m,cnt,tot,num;
int d[N],l[N],r[N],f[N],h[N],a[N],b[N],pos[N];
struct Guard{
    int l,r,c;
    bool operator< (const Guard &t) const
    {
        if (l==t.l) return r>t.r;
        return l<t.l;
    }
}g[N];
int main()
{
    scanf("%d%d%d",&n,&k,&m);
    for (int i=1;i<=m;++i)
    {
        scanf("%d%d%d",&g[i].l,&g[i].r,&g[i].c);
        if (!g[i].c) ++d[g[i].l],--d[g[i].r+1];
    }
    for (int i=1;i<=n;++i)
    {
        d[i]+=d[i-1];
        if (!d[i])
        {
            pos[++tot]=i;
            a[i]=b[i]=tot;
        }
    }
    if (tot==k)
    {
        for (int i=1;i<=tot;++i) printf("%d\n",pos[i]);
        return 0;
    }
    a[n+1]=n+1;
    for (int i=n;i>=1;--i) if (!a[i]) a[i]=a[i+1];
    b[0]=0;
    for (int i=1;i<=n;++i) if (!b[i]) b[i]=b[i-1];
    for (int i=1;i<=m;++i)
    {
        if (g[i].c)
        {
            ++num;
            g[num].l=a[g[i].l];
            g[num].r=b[g[i].r];
        }
    }
    sort(g+1,g+num+1);
    for (int i=1;i<=num;++i)
    {
        while (cnt&&l[cnt]<=g[i].l&&g[i].r<=r[cnt]) --cnt;
        ++cnt;
        l[cnt]=g[i].l,r[cnt]=g[i].r;
    }
    int last=0;
    for (int i=1;i<=cnt;++i)
    {
        if (last<l[i]) f[i]=f[i-1]+1,last=r[i];
        else f[i]=f[i-1];
    }
    last=n+1;
    for (int i=cnt;i>=1;--i)
    {
        if (last>r[i]) h[i]=h[i+1]+1,last=l[i];
        else h[i]=h[i+1];
    }
    bool flag=false;
    for (int i=1;i<=cnt;++i)
    {
        if (f[i]==f[i-1]) continue;
        if (l[i]==r[i])
        {
            flag=true;
            printf("%d\n",pos[r[i]]);
            continue;
        }
        int L=1,R=i-1,x=0;
        while (L<=R)
        {
            int mid=L+R>>1;
            if (r[mid]<r[i]-1) L=mid+1,x=mid;
            else R=mid-1;
        }
        L=i+1,R=cnt;
        int y=cnt+1;
        while (L<=R)
        {
            int mid=L+R>>1;
            if (l[mid]>r[i]-1) R=mid-1,y=mid;
            else L=mid+1;
        }
        if (f[x]+h[y]+1>k)
        {
            flag=true;
            printf("%d\n",pos[r[i]]);
        }
    }
    if (!flag) puts("-1");
    return 0;
}
```


---

## 作者：gghack_Nythix (赞：1)

## 前言：

上课讲的写下来加深印象。

## 分析：

首先你可以把绝对没有忍者的点抽出来。那么剩下的有忍者的区间可能会裂成几块，对仍然可能有忍者的点重新标号再建立区间，即可得到一系列连续的区间，且没有题面中没有忍者的区间干扰。

那么接下来注意到如果我们得到的新区间存在包含关系，那么我们可以只留下被包含的区间，因为被包含的区间满足了，大的区间一定满足，同时，长度为一的区间必定有有一个忍者，直接特判即可。

然后我们能得到一系列的左右端点都递增的区间，我们现在要求出必选点。

注意到将忍者放在一个区间的右端点是最好的，可以节省忍者，至于为什么详见 CSP-S2024 T2。

那么我们该如何判定一个右端点是否放置忍者呢？设右端点为 $x$，则次优的地方是 $x-1$。那么如果次优的地方放下去之后忍者数量会超标，这个地方就不能放。

设有 $n$ 个区间，完全在 $x-1$ 左边是第 $1$ 个到第 $i$ 个区间，完全在 $x-1$ 右边是第 $j$ 个到第 $n$ 个区间。那么只要找到覆盖第 $1$ 个到第 $i$ 个区间个最小点数 $f_i$ 与 覆盖第 $j$ 个到第 $n$ 个区间的最小点数 $g_j$，判断是否满足 $f_i+g_j\ge k+1$，如果是的，就说明 $x-1$ 不满足题意，则只能选择 $x$ 作为忍者放置点。然后枚举 $i$，二分求个 $j$ 就做完了。

```cpp
# include <bits/stdc++.h>
# define int long long
# define pb push_back
# define ins insert
using namespace std;
const int N = 1e5 + 5;
int n , k , m , D[N]  ,lst[N] , nxt[N] , cnt , id[N] , stk[N] , top , f[N] , g[N];
struct node {
    int l , r , v;
    bool operator < (const node & hh) const {return l == hh.l ? r < hh.r : l < hh.l;}
}a[N] , nrg[N];
vector <node> rg;
signed main () {
    ios::sync_with_stdio (false) ,cin.tie(0) , cout.tie(0);
    cin >> n >> k >> m;
    for (int i = 1;i <= m;++i) cin >> a[i].l >> a[i].r >> a[i].v;
    rg.pb (node{-1,-1,-1});
    for (int i = 1;i <= m;++i) {
        if (!a[i].v) D[a[i].l] ++ , D[a[i].r + 1] -- ;
        else rg.pb (node{a[i].l , a[i].r , -1});
    }
    for (int i = 1;i <= n;++i) {
        D[i] += D[i - 1];
        if (D[i] == 0) lst[i] = nxt[i] = ++cnt , id[cnt] = i;
    }
    for (int i = 1;i <= n;++i) if (!lst[i]) lst[i] = lst[i - 1];
    for (int i = n;i >= 1;--i) if (!nxt[i]) nxt[i] = nxt[i + 1];
    for (int i = 1;i < rg.size();++i) rg[i].l = nxt[rg[i].l] , rg[i].r = lst[rg[i].r];
    sort (rg.begin () , rg.end ());
    for (int i = 1;i < rg.size();++i) {
        if (rg[i].l > rg[i].r) continue;
        while (top && rg[stk[top]].r >= rg[i].r) -- top;
        stk[++top] = i;
    }
    for (int i = 1;i <= top;++i) nrg[i] = rg[stk[i]];
    if (cnt == k) {for (int i = 1;i <= cnt;++i) cout << id[i] << "\n"; return 0;}
    int pos = 0;
    for (int i = 1;i <= top;++i) {
        if (nrg[i].l > pos) pos = nrg[i].r , f[i] = f[i - 1] + 1;
        else f[i] = f[i - 1];
    }
    pos = 1e18;
    for (int i = top;i >= 1;--i) {
        if (nrg[i].r < pos) pos = nrg[i].l , g[i] = g[i + 1] + 1;
        else g[i] = g[i + 1];
    }
    bool exs = 0;
    for (int i = 1;i <= top;++i) {
        if (nrg[i].l == nrg[i].r) {cout << id[nrg[i].r] << "\n" ; exs = 1; continue;}
        if (f[i - 1] + 1 != f[i]) continue ;
        int l = i + 1 , r = top , gp = 0;
        while (l <= r) {
            int mid = l + r >> 1;
            if (nrg[i].r <= nrg[mid].l) gp = mid , r = mid - 1;
            else l = mid + 1;
        }
        if (f[i] + g[gp] > k) {cout << id[nrg[i].r] << "\n" ; exs = 1;}
    }
    if (!exs) return cout << "-1\n" , 0;
}
```

---

## 作者：Mikazuki_Munechika (赞：0)

# P3634 [APIO2012] 守卫 解题报告
[P3634 [APIO2012] 守卫](https://www.luogu.com.cn/problem/P3634)

我们先求一下最少放几个点可以覆盖所有的。

首先你得把不合法的位置全部去除。

首先来几个分析：

1. 如果有区间有包含关系，可以只保留最内层的
2. 对于有交的区间，如果要保证放的点最少，最贪心的放置方案就是在最左边的区间的右端点放置。

我们再贪一下，对于无交的区间也全都放右端点，没有影响，对吧。

然后我们要找的是确定的方法，这就有点像扫雷对吧。我们考虑一个点是不是被确定是考虑去掉它之后方案还是否合法。

然后我们先从左到右扫，去填右端点，来覆盖所有区间。然后再看一下，如果这个区间左右端点重合了，那就必须要选，否则我们看看往左移一个位置是否还合法，经过上面的分析，可以发现这样一定是次优的。这个当然判断也是简单的，我们处理一下到前、后的前几个线段要选取的最少点数，然后我们找到最左边的与当前区间无交的区间，判断一下这个区间所需的最少点和前面的所选线段所需的最少点加一会不会超过 $ k $ 即可。

Code：

```C++
#include<bits/stdc++.h>
using namespace std;
using i64=long long;
inline int read(){
	int x=0,f=1;char c=getchar();
	while(!isdigit(c)){if(c=='-')f=-1;c=getchar();}
	while(isdigit(c)){x=(x<<1)+(x<<3)+(c^48);c=getchar();}
	return x*f;
}
const int N=1e5+5;
int n,k,m,det[N],ori[N],nxt[N],lst[N],cnt,pre[N],suf[N];
vector<pair<int,int>> v;
signed main(){
	n=read(),k=read(),m=read();
	for(int i=1,x,y,op;i<=m;i++){
		x=read(),y=read(),op=read();
		if(!op) det[x]++,det[y+1]--; else v.emplace_back(make_pair(x,y));
	}	
	for(int i=1;i<=n;i++){
		det[i]+=det[i-1];
		if(!det[i]) lst[i]=nxt[i]=++cnt,ori[cnt]=i;
	}
	for(int i=1;i<=n;i++){
		if(!lst[i]) lst[i]=lst[i-1];
	}
	for(int i=n;i>=1;i--){
		if(!nxt[i])nxt[i]=nxt[i+1];
	}
	for(int i=0;i<(int)v.size();i++){
		v[i].first=nxt[v[i].first],v[i].second=lst[v[i].second];
	}
	if(k==cnt){
		for(int i=1;i<=cnt;i++)cout<<ori[i]<<"\n";
		return 0;
	}
	sort(v.begin(),v.end());
	stack<pair<int,int>> st;
	for(int i=0;i<(int)v.size();i++){
		while(st.size()&&st.top().second>=v[i].second) st.pop();
		st.push(v[i]);
	}
	v.clear();
	while(st.size()){
		v.emplace_back(st.top());
		st.pop();
	}
	sort(v.begin(),v.end());
	int mx=0,mn=1e9;
	for(int i=0;i<(int)v.size();i++){
		if(!i) mx=v[i].second,pre[i]=1;
		if(v[i].first>mx) pre[i]=pre[i-1]+1,mx=v[i].second;else pre[i]=pre[i-1];
	}
	for(int i=(int)v.size()-1;i>=0;i--){
		if(v[i].second<mn)suf[i]=suf[i+1]+1,mn=v[i].first; else suf[i]=suf[i+1];
	}
	vector<int> res;
	for(int i=0;i<(int)v.size();i++){
		if(v[i].first==v[i].second) {res.emplace_back(ori[v[i].first]);continue;}
		if(pre[i]!=pre[i-1]+1&&i) continue;
		int ans=v.size(),l=i+1,r=(int)v.size()-1;
		while(l<=r){
			int mid=(l+r)>>1;
			if(v[mid].first>=v[i].second) ans=mid,r=mid-1; else l=mid+1;
		}
		if(pre[i]+suf[ans]>=k) res.emplace_back(ori[v[i].second]); 
	}
	if(!res.size()){
		return puts("-1"),0;
	}
	for(int i:res){
		cout<<i<<"\n";
	}
	return 0;
}
```



---


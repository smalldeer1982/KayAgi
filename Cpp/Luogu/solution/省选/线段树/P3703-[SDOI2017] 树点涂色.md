# [SDOI2017] 树点涂色

## 题目描述

Bob 有一棵 $n$ 个点的有根树，其中 $1$ 号点是根节点。Bob 在每个点上涂了颜色，并且每个点上的颜色不同。

定义一条路径的权值是：这条路径上的点（包括起点和终点）共有多少种不同的颜色。

Bob可能会进行这几种操作：

- `1 x` 表示把点 $x$ 到根节点的路径上所有的点染上一种没有用过的新颜色。


- `2 x y` 求 $x$ 到 $y$ 的路径的权值。

- `3 x` 在以 $x$ 为根的子树中选择一个点，使得这个点到根节点的路径权值最大，求最大权值。


Bob一共会进行 $m$ 次操作


## 说明/提示

共 $10$ 个测试点。

测试点 $1$，$1\leq n,m\leq1000$；

测试点 $2,3$，没有 $2$ 操作；

测试点 $4,5$，没有 $3$ 操作；

测试点 $6$，树的生成方式是，对于 $i(2\leq i \leq n)$，在 $1 \sim i-1$ 中随机选一个点作为 $i$ 的父节点；

测试点 $7$，$1\leq n,m\leq 5\times 10^4$；

测试点 $8$，$1\leq n \leq 5 \times 10^4$；

测试点9,10，无特殊限制

对所有数据，$1\leq n \leq 10^5$，$1\leq m \leq 10^5$。


## 样例 #1

### 输入

```
5 6
1 2
2 3
3 4
3 5
2 4 5
3 3
1 4
2 4 5
1 5
2 4 5```

### 输出

```
3
4
2
2```

# 题解

## 作者：Caii (赞：91)

怎么题解全是LCT，我树剖不服

第一个操作就是树链覆盖，放到序列上就是区间合并，区间合并暴力的时间复杂度是均摊 $O(1)$ 的(不考虑在其他数据结构上的时间消耗)，于是一个显然的思路就是第一个操作暴力搞，每次在重链上找到一段相同的颜色，暴力在线段树上修改，时间复杂度均摊是 $O(\log N)$ 的

线段树上维护一个节点到根节点的权值 $v$

那么第二个操作就是 $v_x+v_y-2v_{LCA(x, y)}+1$

第三个操作线段树区间最值

没了

时间复杂度:$O(N\log^2N)$

```cpp
#include <cctype>
#include <cstdio>
#include <cstring>
#include <algorithm>

#define DEBUG(args...) fprintf(stderr, args)

typedef long long LL;

#define FOR(i, l, r) for(int i = (l), i##_end = (r); i <= i##_end; ++i)
#define REP(i, l, r) for(int i = (l), i##_end = (r); i <  i##_end; ++i)
#define DFR(i, l, r) for(int i = (l), i##_end = (r); i >= i##_end; --i)
#define DRP(i, l, r) for(int i = (l), i##_end = (r); i >  i##_end; --i)

template<class T>T Min(const T &a, const T &b) {return a < b ? a : b;}
template<class T>T Max(const T &a, const T &b) {return a > b ? a : b;}
template<class T>bool Chkmin(T &a, const T &b) {return a > b ? a = b, 1 : 0;}
template<class T>bool Chkmax(T &a, const T &b) {return a < b ? a = b, 1 : 0;}

class fast_input {
private:
	static const int SIZE = 1 << 15 | 1;
	char buf[SIZE], *front, *back;

	void Next(char &c) {
	    if(front == back) back = (front = buf) + fread(buf, 1, SIZE, stdin);
		c = front == back ? (char)EOF : *front++;
	}

public :
	template<class T>void operator () (T &x) {
		char c, f = 1;
		for(Next(c); !isdigit(c); Next(c)) if(c == '-') f = -1;
		for(x = 0; isdigit(c); Next(c)) x = x * 10 + c - '0';
		x *= f;
	}
	void operator () (char &c, char l = 'a', char r = 'z') {
		for(Next(c); c > r || c < l; Next(c)) ;
	}
}input;

const int SN = 100000 + 47;
const int ST = SN << 2 | 1;
const int SE = 200000 + 47;
const int SM = 200000 + 47;

int head[SN], nxt[SE], to[SE];
int col_top[SM], col_bot[SM], col_now;
int size[SN], son[SN], fa[SN], deep[SN];
int top[SN], f[SN], g[SN], h[SN], rank;
int max[ST], tag[ST], col[ST];
int n;

void Add(int, int);
void DFS(int);
void DFS(int, int);
void Build(int, int, int);
void Update(int);
void Modify(int, int, int, int, int, int);
void PushAdd(int, int);
void PushDown(int);
int Ask(int, int, int, int, int);
void ModifyCol(int, int, int, int, int, int);
int AskCol(int, int, int, int);
void Modify(int, int);
int Ask0(int, int);
int Ask1(int);

int __lp, __lq;
int LCA(int, int);

int main() {

#ifdef Cai
	freopen("s.in", "r", stdin);
#endif

	int m, x, y, z;
	
	input(n), input(m);
	FOR(i, 2, n) input(x), input(y), Add(x, y);

	col_now = n;
	FOR(i, 1, n) col_top[i] = col_bot[i] = i;

	deep[1] = 1, DFS(1), DFS(1, -1), Build(1, 1, n);

	while(m--) {
		//DEBUG("[%d]\n", m);
		input(x), input(y);
		if(x == 1) Modify(y, ++col_now);
		else if(x == 2) input(z), printf("%d\n", Ask0(y, z));
		else printf("%d\n", Ask1(y));
	}

	return 0;

}

void Add(int x, int y) {
	static int _ = 0;
	nxt[++_] = head[x], head[x] = _, to[_] = y;
	nxt[++_] = head[y], head[y] = _, to[_] = x;
}

void DFS(int x) {
	size[x] = 1;
	for(int i = head[x]; i; i = nxt[i])
		if(to[i] != fa[x]) {
			fa[to[i]] = x, deep[to[i]] = deep[x] + 1;
			DFS(to[i]), size[x] += size[to[i]];
			if(size[to[i]] > size[son[x]]) son[x] = to[i];
		}
}

void DFS(int x, int y) {
	top[x] = y, f[x] = ++rank, h[rank] = x;
	if(son[x]) DFS(son[x], y);
	for(int i = head[x]; i; i = nxt[i])
		if(to[i] != fa[x] && to[i] != son[x])
			DFS(to[i], to[i]);
	g[x] = rank;
}

void Build(int rt, int l, int r) {
	if(l == r) {max[rt] = deep[h[l]], tag[rt] = 0, col[rt] = h[l]; return ;}
	int mid = l + r >> 1;
	Build(rt << 1, l, mid), Build(rt << 1 | 1, mid + 1, r);
	Update(rt);
}

void Update(int rt) {
	max[rt] = Max(max[rt << 1], max[rt << 1 | 1]);
}

void Modify(int rt, int l, int r, int s, int t, int k) {
	if(l == s && r == t) {PushAdd(rt, k); return ;}
	PushDown(rt);
	int mid = l + r >> 1;
	if(t <= mid)
		Modify(rt << 1, l, mid, s, t, k);
	else if(s > mid)
		Modify(rt << 1 | 1, mid + 1, r, s, t, k);
	else {
		Modify(rt << 1, l, mid, s, mid, k);
		Modify(rt << 1 | 1, mid + 1, r, mid + 1, t, k);
	}
	Update(rt);
}

void PushAdd(int rt, int x) {
	tag[rt] += x, max[rt] += x;
}

void PushDown(int rt) {
	if(tag[rt]) PushAdd(rt << 1, tag[rt]), PushAdd(rt << 1 | 1, tag[rt]);
	tag[rt] = 0;
}

int Ask(int rt, int l, int r, int s, int t) {
	if(l == s && r == t) return max[rt];
	PushDown(rt);
	int mid = l + r >> 1;
	if(t <= mid)
		return Ask(rt << 1, l, mid, s, t);
	else if(s > mid)
		return Ask(rt << 1 | 1, mid + 1, r, s, t);
	else
		return Max(Ask(rt << 1, l, mid, s, mid),
				   Ask(rt << 1 | 1, mid + 1, r, mid + 1, t));
}

void ModifyCol(int rt, int l, int r, int s, int t, int k) {
	if(l == s && r == t) {col[rt] = k; return ;}
	int mid = l + r >> 1;
	if(t <= mid)
		ModifyCol(rt << 1, l, mid, s, t, k);
	else if(s > mid)
		ModifyCol(rt << 1 | 1, mid + 1, r, s, t, k);
	else {
		ModifyCol(rt << 1, l, mid, s, mid, k);
		ModifyCol(rt << 1 | 1, mid + 1, r, mid + 1, t, k);
	}
}

int AskCol(int rt, int l, int r, int p) {
	if(l == r) return col[rt];
	int mid = l + r >> 1;
	if(p <= mid) return Max(col[rt], AskCol(rt << 1, l, mid, p));
	else return Max(col[rt], AskCol(rt << 1 | 1, mid + 1, r, p));
}

void Modify(int x, int y) {
	col_bot[y] = x, col_top[y] = 1;
	int p, q, r, c, nl = 0, nr = 0, toplastc, nextx;
	while(x) {
		p = Ask(1, 1, n, f[x], f[x]);
		c = AskCol(1, 1, n, f[x]);
		r = col_top[c];
		if(f[r] < f[top[x]]) {
			ModifyCol(1, 1, n, f[top[x]], f[x], y);
			Modify(1, 1, n, f[top[x]], g[top[x]], 1 - p);
			if(nl) Modify(1, 1, n, nl, nr, p - 1);
		}
		else {
			ModifyCol(1, 1, n, f[r], f[x], y);
			Modify(1, 1, n, f[r], g[r], 1 - p);
			if(nl) Modify(1, 1, n, nl, nr, p - 1);
		}
		if(col_bot[c] != x) {
			LCA(col_bot[c], x); // __lp is a child of x, which col is c
			if(f[__lp] != nl) {
				Modify(1, 1, n, f[__lp], g[__lp], 1);
				toplastc = __lp;
			}
		}
		if(f[r] < f[top[x]]) 
			nl = f[top[x]], nr = g[top[x]], x = fa[top[x]];
		else
			nl = f[r], nr = g[r], x = fa[r], col_top[c] = toplastc;
	}
}

int Ask0(int x, int y) {
	int lca = LCA(x, y);
	int ans = Ask(1, 1, n, f[x], f[x]) + Ask(1, 1, n, f[y], f[y]);
	ans -= 2 * Ask(1, 1, n, f[lca], f[lca]);
	return ans + 1;
}

int Ask1(int x) {
	return Ask(1, 1, n, f[x], g[x]);
}

int LCA(int x, int y) {
	while(top[x] != top[y]) 
		if(deep[top[x]] > deep[top[y]]) __lp = top[x], x = fa[top[x]];
		else __lq = top[y], y = fa[top[y]];
	if(x == y) return x;
	if(deep[x] < deep[y]) return __lq = son[x], x;
	return __lp = son[y], y;
}

/*
g++ -o s s.cpp -O2; for((i = 1; i <= 10; ++i)) do cp paint$i.in s.in; ./s > s.out; diff paint$i.out s.out -w > s.res; echo $?; done
*/

```

---

## 作者：Soulist (赞：62)

一道非常妙的 $LCT$ 题 $QwQ$，感觉做了之后会对 $access$ 的理解深一些 $QwQ$

~~（树剖大佬别打我 QAQ ）~~

首先 **操作$1$** 具有一个特性，染色操作全部都是直接染到顶点。

让人想到 LCT 的 $access$ 操作。

发现每次都是开一个新的颜色，我们可以知道：一个点到根节点有多少种颜色，体现在 LCT 上即：从此点走到根节点需要走的虚链个数 $+ 1$。

初始时每个点都是一个新颜色，即 LCT 中的所有边都是虚边。

考虑记$dis[x]$表示从根节点走到此点需要经过多少条虚链$+1$，那么最初的 $dis[x]$ 为 $dep[x]$

相对而言较为好处理的是 $2$ 操作，考虑树上差分，倍增求 $LCA$ 不难发现答案为：$dis[x] + dis[y] - 2 * dis[lca] + 1$

接下来考虑操作$3$ 操作$3$ 需要维护的是子树信息。

所以需要用一个数据结构来维护 $dis$数组 $->$ 线段树。

如果对原树按照 $dfs$ 进行遍历，在 $dfs$ 序中每棵子树对应的区间都是连续的。

那么操作$3$就变成了在线段树中询问区间最大 $dis$ 值。

现在我们来考虑最恶心的 **操作$1$**

这是一个 $access$

我们看看一般的$access$是怎么写的：

```cpp
void access( int x ) {
	for( int y = 0; x; y = x, x = t[y].fa )
    	Splay(x), t[x].son[1] = y, pushup(x);
}
```

如果将这段代码分得更细一点，其实是：

$1.$先将 $x$ 旋到$Splay$根。

$2.$将 $x$ 的右儿子变虚

$3.$将 $x$ 的虚儿子$(y)$ 变实。

然后$pushup$

我们发现这一过程中其实发生了：1.一条虚链变成了实链，2.一条实链变成了虚链。

考虑它原来的儿子，这条实链变成了虚链，那么它的儿子及其下面所有的点往根节点走的时候都要多经过一条虚链，换而言之：此儿子所管辖的子树区间的 $dis$ 值全部 $+1$

然后另一个操作为：一个虚儿子变成了实儿子，那么此儿子变成了实儿子，那么其的儿子走到根节点的路上都会少走一条虚链，等价于：此儿子所管辖的所有子树区间的 $dis$ 值全部 $-1$

注意坑点：比如这样写就是错的（伪代码）：

```cpp
void access( int x ) {
	
    for( int y = 0; x; y = x, x = t[y].fa ) {
    	Splay(x), update( rs(x), + 1 ); //更新右儿子。
        update( y, -1 ), t[x].son[1] = y;
	}
}
```

需要注意：$1.LCT$ 中的$Splay$作为辅助树，其维护的是一个中序遍历，并不是真实树中的一种父子关系，然而我们做的操作是对其真实的儿子所管辖的区间做的$+1/-1$ 所以我们要找到其原本的儿子。

所以我们对于原树，我们需要找到其右子树(深度比其大的点)中深度最小的点。

对于接上去的点，我们也需要找到其中深度最小的点。

故其实还要一个 $findroot$ 函数（某一颗子树中深度最小的点）

具体实现看代码中$access$

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int read() {
	char cc = getchar(); int cn = 0, flus = 1;
	while(cc < '0' || cc > '9') {  if( cc == '-' ) flus = -flus;  cc = getchar();  }
	while(cc >= '0' && cc <= '9')  cn = cn * 10 + cc - '0', cc = getchar();
	return cn * flus;
}
#define rep( i, s, t ) for( register int i = s; i <= t; ++ i )
#define drep( i, t, s ) for( register int i = t; i >= s; -- i )
#define Next( i, x ) for( register int i = head[x]; i; i = e[i].next )
#define Max( x, y ) ( ( (x) > (y) ) ? (x) : (y) )
const int N = 1e5 + 5;
int L[N], R[N], rev[N], id[N], head[N], n, m, cnt, tot ;
int fath[N][21], dep[N];
struct E {
	int to, next ;
} e[N * 2];
namespace Tree {
	#define ls(x) ( x * 2 )
	#define rs(x) ( x * 2 + 1 )
	struct Tr {
		int mark, mx;
	}tr[N * 4];
	void pushup( int x ) {
		if( tr[x].mark ) {
			tr[ls(x)].mark += tr[x].mark, tr[ls(x)].mx += tr[x].mark ;
			tr[rs(x)].mark += tr[x].mark, tr[rs(x)].mx += tr[x].mark ;
			tr[x].mark = 0;
		}
	}
	void build( int x, int l, int r ) {
		if( l == r ) { tr[x].mx = dep[rev[l]]; return ; }
		int mid = ( l + r ) >> 1;
		build( ls(x), l, mid ), build( rs(x), mid + 1, r );
		tr[x].mx = Max( tr[ls(x)].mx, tr[rs(x)].mx );
	}
	int query( int x, int l, int r, int ll, int rr ) {
		if( l > rr || r < ll ) return 0;
		if( l >= ll && r <= rr ) return tr[x].mx;
		pushup(x);
		int mid = ( l + r ) >> 1;
		return max( query( ls(x), l, mid, ll, rr ), query( rs(x), mid + 1, r, ll, rr ) );
	}
	void update( int x, int l, int r, int ll, int rr, int add ) {
		if( l > rr || r < ll ) return ;
		if( l >= ll && r <= rr ) {
			tr[x].mark += add, tr[x].mx = tr[x].mx + add;
			return ;
		}
		int mid = ( l + r ) >> 1;
		pushup(x);
		update( ls(x), l, mid, ll, rr, add ), update( rs(x), mid + 1, r, ll, rr, add );
		tr[x].mx = max( tr[ls(x)].mx, tr[rs(x)].mx );
	}
}
namespace LCT1 {
	#define ls(x) t[x].son[0]
	#define rs(x) t[x].son[1]
	struct LCT {
		int son[2], fa, val;
		bool mark ;
	} t[N * 2];
	int isroot( int x ) {
		return ( ls(t[x].fa) != x ) && ( rs(t[x].fa) != x ) ;
	}
	void pushmark( int x ) {
		if( t[x].mark ) {
			swap( ls(x), rs(x) ); 
			t[x].mark = 0, t[ls(x)].mark ^= 1, t[rs(x)].mark ^= 1;
		}
	}
	void rotate( int x ) {
		int f = t[x].fa, ff = t[f].fa, qwq = ( rs(t[x].fa) == x );
		t[x].fa = ff;
		if( !isroot(f) ) t[ff].son[rs(ff) == f] = x ;
		t[f].son[qwq] = t[x].son[qwq ^ 1], t[t[x].son[qwq ^ 1]].fa = f ;
		t[x].son[qwq ^ 1] = f, t[f].fa = x ;
	}
	int st[N];
	void Splay( int x ) {
		int top = 0, now = x; st[++ top] = now ;
		while( !isroot(now) ) st[++ top] = ( now = t[now].fa );
		while( top ) pushmark( st[top --] );
		while( !isroot(x) ) {
			int f = t[x].fa, ff = t[f].fa;
			if( !isroot(f) ) ( ( rs(f) == x ) ^ ( rs(ff) == f ) ) ? rotate(x) : rotate(f) ;
			rotate(x);
		}
	}
	int findrt( int x ) { //要找到深度最小的点。 
		while( ls(x) ) x = ls(x) ;
		return x;
	}
	void access( int x ) { //access 
		int son;
		for( int y = 0; x; y = x, x = t[y].fa ) {
			Splay(x);
			if( rs(x) ) son = findrt(rs(x)), Tree :: update( 1, 1, n, L[son], R[son], 1 ); //如果儿子存在才update 
			if( rs(x) = y ) son = findrt(y), Tree :: update( 1, 1, n, L[son], R[son], -1 );
			t[x].son[1] = y ; 
		}
	}
}
void add( int x, int y ) {
	e[++ cnt] = (E){ y, head[x] }, head[x] = cnt ;
	e[++ cnt] = (E){ x, head[y] }, head[y] = cnt ; 
}
void dfs( int x, int fa ) {
	L[x] = ++ tot, rev[tot] = x; // L[x],R[x]表示x管辖的区间，rev表示线段树中的位置对应点 
	LCT1::t[x].fa = fath[x][0] = fa, dep[x] = dep[fa] + 1 ;
	rep( i, 1, 19 ) fath[x][i] = fath[fath[x][i - 1]][i - 1]; //倍增处理 
	Next( i, x ) {
		int v = e[i].to ;
		if( v == fa ) continue ;
		dfs( v, x );
	}
	R[x] = tot ;
}
int LCA( int x, int y ) { //LCA
	if( dep[x] < dep[y] ) swap( x, y );
	drep( i, 19, 0 ) if( dep[fath[x][i]] >= dep[y] ) x = fath[x][i] ;
	drep( i, 19, 0 ) if( fath[x][i] != fath[y][i] ) x = fath[x][i], y = fath[y][i] ;
	return ( x == y ) ? x : fath[x][0] ;
}
signed main()
{
	n = read(), m = read() ;
	int x, y, opt, ans ;
	rep( i, 1, n - 1 ) x = read(), y = read(), add( x, y );
	dfs( 1, 1 ); LCT1 :: t[1].fa = 0; 
	Tree :: build( 1, 1, n ); //初始建树 
	
	rep( i, 1, m ) {
		opt = read(), x = read();
		if( opt == 1 ) LCT1 :: access(x);
		if( opt == 2 ) {
			y = read();
			int lca = LCA( x, y );
			int ans1 = Tree :: query( 1, 1, n, L[x], L[x] ) ;
			int ans2 = Tree :: query( 1, 1, n, L[y], L[y] ) ;
			int ans3 = ( Tree :: query( 1, 1, n, L[lca], L[lca] ) );
			printf("%d\n", ans1 + ans2 - 2 * ans3 + 1 );
		}
		if( opt == 3 ) {
			ans = Tree :: query( 1, 1, n, L[x], R[x] );
			printf("%d\n", ans );
		}	
	}
	return 0;
}

```

---

## 作者：feecle6418 (赞：49)

这篇题解是为高赞树剖题解做注解的，因为许多人看不懂那篇在说什么（我也看不懂

首先，我们在树剖时要维护什么？

维护每个点到根的答案；维护区间内答案最大值；维护这个点的颜色和区间覆盖颜色标记。其中，颜色和另外两个是分开维护的。

然后怎么维护？

每一次暴力找到相同颜色组成的段，一段一段地修改。同一段内用树剖维护。

具体如何修改？我们考虑现在正在 $x\rightarrow top_x$ 重链上的情况，设 $lst$ 为 $x$ 下面刚转移过来的节点。

$lst$ 的子树内显然维护完毕。我们需要给红圈内部分整体减去原来 $x$ 到根的段数。（红圈被吃了。。。就是图上除了 $lst$ 子树之外的部分）

![](https://cdn.luogu.com.cn/upload/image_hosting/1aztyl89.png)

我们先给 $top_x$ 的子树全减掉，再单独给 $lst$ 加回来即可。

代码如下：

```cpp
void LineModify(int x,int y,int lst) {
	while(top[x]!=top[y]) {
		if(d[top[x]]<d[top[y]])swap(x,y);
		int gyh=Query(1,1,n,pos[x],pos[x]);
		Add(1,1,n,pos[top[x]],pos[top[x]]+size[top[x]]-1,1-gyh);
		if(lst)Add(1,1,n,pos[lst],pos[lst]+size[lst]-1,gyh-1);
		Changecol(1,1,n,pos[top[x]],pos[x],tot);
		lst=top[x],x=fa[top[x]];
	}
	if(d[x]>d[y])swap(x,y);
	int gyh=Query(1,1,n,pos[x],pos[x]);
	Add(1,1,n,pos[x],pos[x]+size[x]-1,1-gyh);
	if(lst)Add(1,1,n,pos[lst],pos[lst]+size[lst]-1,gyh-1);
	Changecol(1,1,n,pos[x],pos[y],tot);
}
```

还有一个要注意的点。

假如原来这段颜色并没有被正在修改的路径完全覆盖，则需要对这段颜色所在的子树单独加一（请自行画图理解），代码如下：

```cpp
void Change(int x) {
	from[++tot]=x,to[tot]=1;
	int lst=0;
	while(x) {
		int tmp=Querycol(1,1,n,pos[x]),TO=to[tmp];
		if(from[tmp]==x)from[tmp]=to[tmp]=0;
		else to[tmp]=Climb(from[tmp],x),Add(1,1,n,pos[to[tmp]],pos[to[tmp]]+size[to[tmp]]-1,1);//就是这里
		LineModify(x,TO,lst);
		x=fa[TO],lst=TO;
	}
}
```

总体代码如下：

```cpp
#include<iostream>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<cstdio>
#include<vector>
#define pos dfn
using namespace std;
vector<int> g[100005];
int top[100005],fa[100005],dfn[100005],n,q,size[100005],son[100005],id[100005],sign;
int d[100005],tag[400005],mx[400005],from[200005],to[200005],tot,col[400005],p[100005][20];
void DFS1(int x,int f) {
	size[x]=1,fa[x]=p[x][0]=f,d[x]=d[f]+1,from[x]=to[x]=x;
	for(int i=1;i<=16;i++)p[x][i]=p[p[x][i-1]][i-1];
	for(int y:g[x]) {
		if(y==f)continue;
		DFS1(y,x);
		size[x]+=size[y];
		if(size[son[x]]<size[y])son[x]=y;
	}
}
void DFS2(int x,int tp) {
	top[x]=tp,dfn[x]=++sign,id[sign]=x;
	if(son[x])DFS2(son[x],tp);
	for(int y:g[x]) {
		if(y==fa[x]||y==son[x])continue;
		DFS2(y,y);
	}
}
void Build(int p,int l,int r) {
	if(l==r) {
		mx[p]=d[id[l]],col[p]=id[l];
		return ;
	}
	int mid=(l+r)/2;
	Build(p*2,l,mid),Build(p*2+1,mid+1,r);
	mx[p]=max(mx[p*2],mx[p*2+1]);
}
void Pushdown(int p){
	if(tag[p]){
		mx[p*2]+=tag[p],mx[p*2+1]+=tag[p];
		tag[p*2]+=tag[p],tag[p*2+1]+=tag[p];
		tag[p]=0;
	}
	if(col[p]){
		col[p*2]=col[p*2+1]=col[p];
		col[p]=0;
	}
}
int Climb(int x,int y){
	for(int i=16;i>=0;i--)if(d[p[x][i]]>d[y])x=p[x][i];
	return x;
}
int Query(int p,int l,int r,int x,int y) {
	//cout<<l<<' '<<r<<' '<<mx[p]<<endl;
	if(x<=l&&r<=y)return mx[p];
	Pushdown(p);
	int mid=(l+r)/2,ret=0;
	if(x<=mid)ret=max(ret,Query(p*2,l,mid,x,y));
	if(mid<y)ret=max(ret,Query(p*2+1,mid+1,r,x,y));
	return ret;
}
int Querycol(int p,int l,int r,int x) {
	if(l==r)return col[p];
	Pushdown(p);
	int mid=(l+r)/2;
	if(x<=mid)return Querycol(p*2,l,mid,x);
	else return Querycol(p*2+1,mid+1,r,x);
}
void Add(int p,int l,int r,int x,int y,int z) {
	if(x<=l&&r<=y){
		tag[p]+=z,mx[p]+=z;
		return ;
	}
	Pushdown(p);
	int mid=(l+r)/2,ret=0;
	if(x<=mid)Add(p*2,l,mid,x,y,z);
	if(mid<y)Add(p*2+1,mid+1,r,x,y,z);
	mx[p]=max(mx[p*2],mx[p*2+1]);
}
void Changecol(int p,int l,int r,int x,int y,int z) {
	if(x<=l&&r<=y){
		col[p]=z;
		return ;
	}
	Pushdown(p);
	int mid=(l+r)/2,ret=0;
	if(x<=mid)Changecol(p*2,l,mid,x,y,z);
	if(mid<y)Changecol(p*2+1,mid+1,r,x,y,z);
}
void LineModify(int x,int y,int lst) {
	//cout<<"Modifying:"<<x<<' '<<y<<' '<<lst<<endl;
	while(top[x]!=top[y]) {
		if(d[top[x]]<d[top[y]])swap(x,y);
		int gyh=Query(1,1,n,pos[x],pos[x]);
		Add(1,1,n,pos[top[x]],pos[top[x]]+size[top[x]]-1,1-gyh);
		if(lst)Add(1,1,n,pos[lst],pos[lst]+size[lst]-1,gyh-1);
		//cout<<"Add:"<<top[x]<<' '<<1-gyh<<endl;
		//cout<<"Add:"<<lst<<' '<<gyh-1<<endl;
		Changecol(1,1,n,pos[top[x]],pos[x],tot);
		lst=top[x],x=fa[top[x]];
	}
	if(d[x]>d[y])swap(x,y);
	int gyh=Query(1,1,n,pos[x],pos[x]);
	//cout<<"Add:"<<x<<' '<<1-gyh<<endl;
	//cout<<"Add:"<<lst<<' '<<gyh-1<<endl;
	Add(1,1,n,pos[x],pos[x]+size[x]-1,1-gyh);
	if(lst)Add(1,1,n,pos[lst],pos[lst]+size[lst]-1,gyh-1);
	Changecol(1,1,n,pos[x],pos[y],tot);
}
void Change(int x) {
	from[++tot]=x,to[tot]=1;
	int lst=0;
	while(x) {
		int tmp=Querycol(1,1,n,pos[x]),TO=to[tmp];
		//cout<<"COL:"<<x<<' '<<tmp<<' '<<TO<<endl;
		if(from[tmp]==x)from[tmp]=to[tmp]=0;
		else to[tmp]=Climb(from[tmp],x),Add(1,1,n,pos[to[tmp]],pos[to[tmp]]+size[to[tmp]]-1,1);
		LineModify(x,TO,lst);
		x=fa[TO],lst=TO;
	}
}
int LCA(int x,int y){
	while(top[x]!=top[y]) {
		if(d[top[x]]<d[top[y]])swap(x,y);
		x=fa[top[x]];
	}
	if(d[x]>d[y])swap(x,y);
	return x;
}
int main() {
	scanf("%d%d",&n,&q),tot=n;
	for(int i=1,x,y; i<n; i++)scanf("%d%d",&x,&y),g[x].push_back(y),g[y].push_back(x);
	DFS1(1,0);
	DFS2(1,1);
	Build(1,1,n);
	while(q--) {
		int opt,x,y;
		scanf("%d%d",&opt,&x);
		if(opt==1)Change(x);
		if(opt==2) {
			scanf("%d",&y);
			int lca=LCA(x,y);
			printf("%d\n",Query(1,1,n,pos[x],pos[x])+Query(1,1,n,pos[y],pos[y])-2*Query(1,1,n,pos[lca],pos[lca])+1);
		}
		if(opt==3)printf("%d\n",Query(1,1,n,pos[x],pos[x]+size[x]-1));
	}
	return 0;
}
/*
5 7
1 2
2 3
3 4
3 5
2 4 5
3 3
1 4
2 4 5
1 5
2 4 5
3 1
*/
```

---

## 作者：FlashHu (赞：28)

我太弱了连树剖都不会

于是来一波没有树剖的题解

### 闲话

这是所有LCT题目中的一个异类。

之所以认为是LCT题目，是因为本题思路的瓶颈就在于如何去维护同颜色的点的集合。

只不过做着做着，感觉后来的思路（dfn序，线段树，LCA）似乎要喧宾夺主了。。。（至少在代码上看是如此）

## 思路分析

一个一个操作来（瞎BB中，这种思路模式并不具有普遍性。。。。。。）

### 1操作

~~还好我没学树剖233333~~以至于~~（直接想到）~~只好用LCT来维护颜色。

题目透露出的神奇的性质——每一种颜色，无论在任何时刻，肯定是一条链，而且点的深度严格递增！

而且还特意指定根节点！1操作特意修改x到根节点的颜色！

想到了这里，就不难想到本题的关键模型——LCT中每个Splay辅助树维护同颜色点的集合

于是1操作==access。。。。。。
### 2操作
x到y路径？split？！

~~I'm too young too simple~~

LCT维护了集合，就只能维护集合了。随便再乱搞一下集合就被破坏了。

于是就要再外部维护了。

至于维护什么，现在其实还不能产生很好的思路。。。。。

但我们可以先想到一点：没有了LCT，还要资磁树中任意两点之间的询问？

常见的复杂度正确的方法~~（套路）~~能想到的就只有树上差分了吧（设F为状态，那么就形如F[x]+F[y]-F[lca]）

于是就可以只维护每个点到根节点路径上的颜色种数
转化一下，在LCT中就等价于每个点到根节点路径所要经过的轻边总数，这里又是一个关键点
查询F[x]+F[y]-2F[lca]+1（+1是因为lca所在的颜色被减了两次）

不会树剖，只好写倍增LCA

然后就可以转而思考如何维护这个状态了

首先初始状态就是每个点的深度，然后就接着考虑修改了。

因为状态只与轻边有关，所以在access时更改就可以啦

可以类比一下LCT维护子树信息和（可参考一下[Blog的LCT总结](http://www.cnblogs.com/flashhu/p/8324551.html)）

access中有替换右儿子的操作，等于把原来一条边变轻，新的一条边变重

那么原来那条边所指的子树状态全部要+1（多了一个轻边），新连上的边所指的子树状态全部要-1

于是问题又出现了。。。

众所周知，LCT可以维护子树信息，但不可以修改子树信息

树剖很好维护就不提了，然后我又不会树剖TOT（我太弱了）

在这紧要关头，dfn序救了我。。。。。。

一个子树，所有的点的dfn序一定是连续的区间
所以维护线段树，表示dfn序的区间，修改的时候在对应的区间修改，查询就单点查

### 3操作

所有的思路难点，在操作2冗长的思路分析中都攻克了

这里就在线段树里维护状态最大值（树剖也一样），区间查询就好啦

至于写法，线段树里的区间加减法可以写懒标记，也可以实现永久化标记（YL巨佬做法，常数暴踩本蒟蒻，目前rank1）

只不过我试了一下，dfn序线段树写永久化标记因为某些无法描述的玄学问题变得更慢了。。。。。。

 ---
 
思路就这样，有些细节在代码里（Debug一晚上带来的惨痛的经验。。。。。。）

算上in，pup，pdn和main，此程序一共有15个函数。。。。。。

```cpp
#include<cstdio>
#include<iostream>
using namespace std;
#define I inline
#define R register int
#define G ch=getchar()
#define in(z) G;\
    while(ch<'-')G;\
    z=ch&15;G;\
    while(ch>'-')z*=10,z+=ch&15,G
#define lc x<<1
#define rc x<<1|1
#define pup mx[x]=max(mx[lc],mx[rc])
#define pdn if(lz[x])upd(lc,l[x],m[x],lz[x]),upd(rc,m[x]+1,r[x],lz[x]),lz[x]=0
//都是线段树操作，本题的LCT内部没有维护信息
const int N=100009,M=N*20;
int l[M],m[M],r[M],mx[M],lz[M],f[N],c[N][2],st[N][20],o[N];
int p=1,he[N],ne[N<<1],to[N<<1],d[N],dfn[N],at[N],mr[N],now;
//at是dfn的反表示，mr表示每个点的子树在dfn序区间中的右端点（左端点是它自己）
I void dfs(R x,R fa){//建树预处理
    d[now=at[dfn[x]=++p]=x]=d[st[x][0]=f[x]=fa]+1;//一堆信息的预处理压进了一行
    for(R&i=o[x];(st[x][i+1]=st[st[x][i]][i]);++i);//倍增LCA预处理
    for(R i=he[x];i;i=ne[i])
        if(fa!=to[i])dfs(to[i],x);
    mr[x]=now;
}
I int lca(R x,R y){//求LCA
    if(d[x]<d[y])swap(x,y);
    for(R i=o[x];i>=0;--i)
        if(d[st[x][i]]>=d[y])x=st[x][i];//Debug中的错误1：>=写成了>
    if(x==y)return x;
    for(R i=o[x];i>=0;--i)
        if(st[x][i]!=st[y][i])x=st[x][i],y=st[y][i];
    return st[x][0];
}
I void build(R x,R s,R e){//建线段树
    l[x]=s;r[x]=e;m[x]=(s+e)>>1;
    if(s==e){mx[x]=d[at[s]];return;}//利用反表示找到初始状态
    build(lc,s,m[x]);build(rc,m[x]+1,e);pup;
}
I void upd(R x,R s,R e,R v){//区间修改
    if(l[x]==s&&r[x]==e){mx[x]+=v;lz[x]+=v;return;}//注意mx也要变
    pdn;
    if(e<=m[x])upd(lc,s,e,v);
    else if(s>m[x])upd(rc,s,e,v);
    else upd(lc,s,m[x],v),upd(rc,m[x]+1,e,v);
    pup;
}
I int get(R s){//单点查值，与区间查值分开了，为了减小常数
    R x=1;
    while(l[x]!=r[x]){
        pdn;x=(lc)+(s>m[x]);
    }
    return mx[x];
}
I int ask(R x,R s,R e){//区间查值
    if(l[x]==s&&r[x]==e)return mx[x];
    pdn;
    if(e<=m[x])return ask(lc,s,e);
    if(s>m[x])return ask(rc,s,e);
    return max(ask(lc,s,m[x]),ask(rc,m[x]+1,e));
}
I bool nrt(R x){//LCT部分
    return c[f[x]][0]==x||c[f[x]][1]==x;
}
I void rot(R x){
    R y=f[x],z=f[y],k=c[y][1]==x,w=c[x][!k];
    if(nrt(y))c[z][c[z][1]==y]=x;c[x][!k]=y;c[y][k]=w;
    f[w]=y;f[y]=x;f[x]=z;//Debug中的错误2：y写成了x
}
I void splay(R x){
    R y;
    while(nrt(x)){
        if(nrt(y=f[x]))rot((c[f[y]][0]==y)^(c[y][0]==x)?x:y);
        rot(x);
    }
}
I int frt(R x){//有别于传统意义下的findroot
    while(c[x][0])x=c[x][0];
    return x;
}
I void access(R x){
    for(R w,y=0;x;x=f[y=x]){
        splay(x);
        if(c[x][1])w=frt(c[x][1]),upd(1,dfn[w],dfn[mr[w]],1);
        if((c[x][1]=y))w=frt(y),upd(1,dfn[w],dfn[mr[w]],-1);
//Debug中的错误3：这里更新要找原子树的根（即深度最小的那个点）
//而不能把辅助树的根当原子树根直接upd(1,dfn[c[x][1]],dfn[mr[c[x][1]]],1)
    }
}
int main(){
    register char ch;
    R n,m,i,a,b,op,x,y;
    in(n);in(m);
    for(i=1;i<n;++i){
        in(a);in(b);
        to[++p]=b;ne[p]=he[a];he[a]=p;
        to[++p]=a;ne[p]=he[b];he[b]=p;
    }
    p=0;dfs(1,0);build(1,1,n);
    while(m--){
        in(op);in(x);
        if(op==1)access(x);
        else if(op==2){
            in(y);
            printf("%d\n",get(dfn[x])+get(dfn[y])-get(dfn[lca(x,y)])*2+1);
        }
        else printf("%d\n",ask(1,dfn[x],dfn[mr[x]]));
    }
    return 0;
}
```

---

## 作者：YellowBean_Elsa (赞：23)

[Caii神仙的题解](https://www.luogu.com.cn/blog/Cai/solution-p3703)写的很精彩，但好像不是很多人能看懂。。。

那我来发一个有较为详细的解释和一个正常版线段树的代码

```cpp
/*
coder: Feliks a Hacker of IOI == GM-YB an AKer of IMO
acknowledgement:
https://www.luogu.com.cn/blog/Cai/solution-p3703

纯树剖的解法，思路大概是这样:
称连续一段相同颜色点组成的链叫同色链 
开线段树，mx记录该区域内点到根路径中最大权值 （最大点权） 
col记录该区域最新被赋过的颜色（颜色编号开始为1-n，后从n+1开始递增） 
则一个点颜色实际颜色为含有该点区间中col值最大的（编号越大颜色越新） 
对于操作2，易证明符合可减性，故可以用求两点间距离的方法求 
（ans(u,v)=dis[u]+dis[v]-2*dis[lca(u,v)]+1） 
对于操作3，线段树查询mx的最值
最难的是操作1：
从x开始向上跳，每次跳过一条重链或同色链（哪个起点更深就跳那个）
跳的时候区间修改颜色，更新点权 
（利用跳的这一段颜色相同，注意不要把上次跳的链也更新了） 
还要注意更新原来的同色链的最顶端 
复杂度 O(nlog^2n) 
*/
#include<bits/stdc++.h>
using namespace std;
const int N=2e5+5;
int n,m;
inline int read(){
	int x=0;char ch=getchar();
	while(!isdigit(ch))ch=getchar();
	while(isdigit(ch))x=(x<<1)+(x<<3)+ch-'0',ch=getchar();
	return x;
}int v[N<<1],nex[N<<1],first[N],tot;
inline void adde(int x,int y){
	v[++tot]=y;
	nex[tot]=first[x];
	first[x]=tot;
}namespace LCA{
	queue<int> q;
	int d[N],fa[21][N],T;
	inline void bfs(){
		q.push(1);
		while(!q.empty()){
			int x=q.front();q.pop();
			for(int i=first[x];i;i=nex[i]){
				int y=v[i];if(d[y])continue;
				d[y]=d[x]+1;q.push(y);fa[0][y]=x;
				for(int j=1;j<=T;j++)
					fa[j][y]=fa[j-1][fa[j-1][y]];
			}
		}
	}inline int lca(int x,int y){
		if(x==y)return x;
		if(d[x]<d[y])swap(x,y);
		//d[x] >= d[y]
		for(int i=T;i>=0;i--)
			if(d[fa[i][x]]>=d[y])x=fa[i][x];
		if(x==y)return x;
		for(int i=T;i>=0;i--)
			if(fa[i][x]!=fa[i][y])x=fa[i][x],y=fa[i][y];
		return fa[0][x];
	}inline int spc(int x,int y){//spc(special): 见下文 op1 函数 
		//d[x]>d[y]
		for(int i=T;i>=0;i--)
			if(d[fa[i][x]]>d[y])x=fa[i][x];
		return x;
	}
}using namespace LCA;
//重链剖分 
int sz[N],gson[N];
void dfs1(int x,int f){
    int mx=0;sz[x]=1;
    for(int i=first[x];i;i=nex[i]){
        int y=v[i];if(y==f)continue;
        dfs1(y,x);sz[x]+=sz[y];
        if(sz[y]>mx){mx=sz[y],gson[x]=y;}
    }
}int id[N],w[N],top[N],cnt,num;//num 记录当前颜色种数 
void dfs2(int x,int topf){
    id[x]=++cnt;top[x]=topf;w[cnt]=x;
    if(!gson[x])return;
    dfs2(gson[x],topf);
    for(int i=first[x];i;i=nex[i]){
        int y=v[i];
        if(y==fa[0][x] || y==gson[x])continue;
        dfs2(y,y);
    }
}int cbot[N<<1],ctop[N<<1];//同色链底端和顶端 
namespace SegmentTree{
	int mx[N<<2],col[N<<2],mk[N<<2];
	//点权、颜色、懒标
	inline int Max(int x,int y){
		if(x>y)return x;
		return y;
	}inline void up(int x){
		mx[x]=Max(mx[x<<1],mx[x<<1|1]);
	}void build(int x,int l,int r){
		if(l==r){
			mx[x]=d[w[l]];
			col[x]=w[l];
			return;
		}int mid=l+r>>1;
		build(x<<1,l,mid);
		build(x<<1|1,mid+1,r);
		up(x);
	}void alter_col(int x,int l,int r,int ll,int rr,int c){//修改颜色 
		if(ll<=l && r<=rr){col[x]=c;return;}
		int mid=l+r>>1;
		if(ll<=mid)alter_col(x<<1,l,mid,ll,rr,c);
		if(rr>mid)alter_col(x<<1|1,mid+1,r,ll,rr,c);
	}int query_col(int x,int l,int r,int p){
	//单点查询颜色，注意取所有覆盖该点的区间中颜色的最值
	//因为在修改颜色时，有必要只改在区间上不改到每个点（防TLE） 
		if(l==r)return col[x];
		int mid=l+r>>1;
		if(p<=mid)return Max(col[x],query_col(x<<1,l,mid,p));
		else return Max(col[x],query_col(x<<1|1,mid+1,r,p));
	}inline void down(int x,int l,int r){
		if(!mk[x])return;
		int mid=l+r>>1,ls=x<<1,rs=x<<1|1,c=mk[x];
		mk[x]=0;
		mk[ls]+=c,mk[rs]+=c;
		mx[ls]+=c,mx[rs]+=c;
	}void alter(int x,int l,int r,int ll,int rr,int k){//修改点权 
		if(ll<=l && r<=rr){mx[x]+=k,mk[x]+=k;return;}
		down(x,l,r);
		int mid=l+r>>1;
		if(ll<=mid)alter(x<<1,l,mid,ll,rr,k);
		if(rr>mid)alter(x<<1|1,mid+1,r,ll,rr,k);
		up(x);
	}int query(int x,int l,int r,int ll,int rr){//查询区间点权最值 
		if(ll<=l && r<=rr)return mx[x];
		down(x,l,r);
		int mid=l+r>>1,res=0;
		if(ll<=mid)res=Max(res,query(x<<1,l,mid,ll,rr));
		if(rr>mid)res=Max(res,query(x<<1|1,mid+1,r,ll,rr));
		return res;
	} 
}using namespace SegmentTree;
namespace operations{
	inline void op1(int x,int k){//大boss!!!
		cbot[k]=x,ctop[k]=1;
		int last=0,ct;//上一次更新的点，防止一个位置被重复更新 
		while(x){
			int p=query(1,1,n,id[x],id[x]);
			int c=query_col(1,1,n,id[x]),r=ctop[c],l=top[x];
			//同色链和重链，跳到更深的那个 
			if(d[l]<d[r]){
				//区间修改颜色 
				alter_col(1,1,n,id[r],id[x],k);
				//可推算这一段在被覆盖后点权减小(p-1) 
				alter(1,1,n,id[r],id[r]+sz[r]-1,1-p);
				//防止重复更新 
				if(last)alter(1,1,n,id[last],id[last]+sz[last]-1,p-1);
			}else{
				alter_col(1,1,n,id[l],id[x],k);
				alter(1,1,n,id[l],id[l]+sz[l]-1,1-p);
				if(last)alter(1,1,n,id[last],id[last]+sz[last]-1,p-1);				
			}//修改被覆盖的原来同色链的顶端（注意细节） 
			if(x!=cbot[c]){
				int y=spc(cbot[c],x);
				//y 是 x 的一个儿子且在 x 原来的同色链上 
				if(y!=last){//如果 y 也被覆盖了就不能用它来更新了 
					alter(1,1,n,id[y],id[y]+sz[y]-1,1);//y 的点权：1 -> 2 
					ct=y;//注意不要急着更新链顶
					//如果还没把原同色链跳完就更新链顶显然会挂掉 
				}
			}//向上跳 
			if(d[r]<d[l])x=fa[0][l],last=l;
			else x=fa[0][r],last=r,ctop[c]=ct;//跳完原链再更新链顶 
		}
	}inline int op2(int x,int y){
		int z=lca(x,y),
			ret1=query(1,1,n,id[x],id[x]),
			ret2=query(1,1,n,id[y],id[y]),
			ret3=query(1,1,n,id[z],id[z]);
		return ret1+ret2-(ret3<<1)+1;
		//类似树上两点距离公式，在此可证明适用 
	}inline int op3(int x){
		return query(1,1,n,id[x],id[x]+sz[x]-1);
	}
}using namespace operations;
int main(){
	n=read(),m=read();
	T=(int)(log(n)/log(2.0))+1;
	for(int i=1;i<n;i++){
		int x=read(),y=read();
		adde(x,y),adde(y,x);
	}d[1]=1;bfs();
	dfs1(1,0),dfs2(1,1);
	//初始颜色与同色链 
	for(int i=1;i<=n;i++)cbot[i]=ctop[i]=i;
	build(1,1,n);num=n;
	while(m--){
		int op=read();
		if(op==1)op1(read(),++num);
		else if(op==2){
			int x=read(),y=read();
			printf("%d\n",op2(x,y));
		}else printf("%d\n",op3(read()));
	}
	return 0;//完结散花 
}
```




---

## 作者：dottle (赞：14)

提供一种更为简洁的树剖做法。

考虑对每一个节点，维护这样一条信息：

-   该点与它父亲的颜色是否相同。

若能成功求出这个信息的变化，则可以用线段树简单地维护 2、3 操作的答案。

这个信息的变化次数是多少呢？其实对于单次 1 操作，只会有 $O(\log n)$ 个节点的信息发生变化。下面是一个简短的证明。

将所有点分为两类：

1.  该点与他颜色相同的儿子是它的重儿子。
2.  该点与他颜色相同的儿子是某个轻儿子，或并没有与它颜色相同的儿子。

这样，每次 1 操作会使得某些 1 类点变为 2 类点，或使 2 类点同色儿子切换，又或是将 2 类点变为 1 类点。前两个情况的总和是 $O(\log n)$ 的，因为只有跳轻边的时候可能会有前两个情况发生。从而，第三个情况均摊下来也是 $O(\log n )$ 的。因此，我们说明了上信息的变化次数是 $O(\log n)$ 的。从而，只需要每次求出信息的变化，就可以通过这道题了。

考虑如何维护，可以对于每一个重链开两个 set：

1.  储存了若干组对 $(x,y)$，表示深度为 $x$ 的点 $k$ 轻儿子 $y$ 与他颜色相同。
2.  储存了若干个 $x$，表示深度为 $x$ 的点 $k$ 是它父亲的重儿子，且 $k$ 与其颜色不同。

具体的实现建议自己思考，也可以直接参考代码。

```cpp
#include<bits/stdc++.h>
const int N=200050;
using namespace std;

int n,m;

#define _to e[i].to
#define fore(k) for(int i=hd[k];i;i=e[i].nx)
struct edge{
    int to,nx;
}e[N];int hd[N],S;
void add(int fr,int to){
    e[++S]=(edge){to,hd[fr]},hd[fr]=S;
}

int fa[N],dp[N],sg[N],bc[N],sz[N],sn[N],tp[N],cnt;
void dfs(int k,int f){
    fa[k]=f,dp[k]=dp[f]+1,sz[k]=1;
    fore(k)if(_to!=f)
        dfs(_to,k),sz[k]+=sz[_to],sn[k]=sz[sn[k]]<sz[_to]?_to:sn[k];
}
basic_string<int> a[N];
multiset<int> s1[N];
multiset<pair<int,int>> s[N];
void df5(int k,int t){
    tp[k]=t,sg[k]=++cnt,bc[cnt]=k;a[t]+=k;
    if(sn[k])df5(sn[k],t),s1[t].insert(dp[k]-dp[t]+1);
    fore(k)if(_to!=fa[k]&&_to!=sn[k])df5(_to,_to);
}

struct sgt{
	#define ls k<<1
	#define rs k<<1|1
	#define mid ((l+r)>>1)
	int ad[N<<2],mx[N<<2];
	void pshad(int k,int p){
		ad[k]+=p,mx[k]+=p;
	}
	void pshdn(int k){
		pshad(ls,ad[k]),pshad(rs,ad[k]);
		ad[k]=0;
	}
	void pshup(int k){mx[k]=max(mx[ls],mx[rs]);}
	void build(int k,int l,int r){
		if(l^r)build(ls,l,mid),build(rs,mid+1,r),pshup(k);
		else pshad(k,dp[bc[l]]-1);
	}
	void add(int k,int l,int r,int x,int y,int p){
		if(r<x||l>y)return ;
		if(l>=x&&r<=y)return pshad(k,p);
		pshdn(k);
		add(ls,l,mid,x,y,p),add(rs,mid+1,r,x,y,p);
		pshup(k);
	}
	int qmx(int k,int l,int r,int x,int y){
		if(r<x||l>y)return 0;
		if(l>=x&&r<=y)return mx[k];
		pshdn(k);
		return max(qmx(ls,l,mid,x,y),qmx(rs,mid+1,r,x,y));
	} 
	int qsm(int k,int l,int r,int x){
		if(l^r){
			pshdn(k);
			if(x<=mid)return qsm(ls,l,mid,x);
			else return qsm(rs,mid+1,r,x);
		}else return ad[k];
	}
}T;

int lca(int x,int y){
	while(tp[x]!=tp[y]){
		if(dp[tp[x]]<dp[tp[y]])swap(x,y);
		x=fa[tp[x]];
	}
	return dp[x]<dp[y]?x:y;
}

int getv(int k){
	return T.qsm(1,1,n,sg[k]);
}

//for most of node
// - his heavy son equal to him
// - other sons not equal to him
//s a unheavy son equal to him
//s1 a heavy son not equal to him

void clear(int x){
	int pr=0;
	while(x){
		int t=tp[x],dl=dp[x]-dp[t],nw;
		while(s[t].size()&&s[t].begin()->first<=dl){
			nw=s[t].begin()->second;
			T.add(1,1,n,sg[nw],sg[nw]+sz[nw]-1,1);
			s[t].erase(s[t].begin()); 
		}
		while(s1[t].size()&&*s1[t].begin()<=dl){
			nw=a[t][*s1[t].begin()];
			T.add(1,1,n,sg[nw],sg[nw]+sz[nw]-1,-1);
			s1[t].erase(s1[t].begin());
		}
		if(pr){
			T.add(1,1,n,sg[pr],sg[pr]+sz[pr]-1,-1);
			s[t].insert({dl,pr});
			// 轻儿子 pr 与 x 颜色相同 
		}
		if(sn[x]&&s1[t].find(dl+1)==s1[t].end()){
			T.add(1,1,n,sg[sn[x]],sg[sn[x]]+sz[sn[x]]-1,1);
			s1[t].insert(dl+1);
			//重儿子 sn[x] 与 x 颜色不同 
		}
		pr=t;
		x=fa[t];
	}
} 

int getmx(int x){
	return T.qmx(1,1,n,sg[x],sg[x]+sz[x]-1)+1;
}

void solve(){
	cin>>n>>m;
	for(int i=1;i<n;i++){
		int x,y;cin>>x>>y;
		add(x,y),add(y,x);
	}
	dfs(1,0);
	df5(1,1);
	T.build(1,1,n);
	for(int i=1;i<=m;i++){
		int x,y,z;cin>>x>>y;
		if(x==1)clear(y);
		if(x==2){
			cin>>z;
			cout<<getv(y)+getv(z)-getv(lca(y,z))*2+1<<'\n';
		}
		if(x==3)cout<<getmx(y)<<'\n';
	}
}

main(){
	ios::sync_with_stdio(false);
	solve();
}

```



---

## 作者：Newuser (赞：7)

//本蒟蒻博客的同步阅读：[Newuser小站！](http://www.newuser.top/2018/04/11/shudiantuse/)

这不是纯种的LCT，，，，是LCT+LCA+DFS序（或者重链剖分）+线段树，最近学的全用进来了，，很有喧宾夺主的意味。。。

首先他是每一次都涂一种不同的颜色，就不用具体存储具体的颜色。 我们看到第1个操作，这和LCT的ACCESE很有相似之处。于是我们就想到，设定一个SPLAY就是一个颜色集合的话，那么这个操作1就是一个裸的ACCES操作就好了

第2个操作求AB两点间的路径上的权值，转化为节点到根经过了多少个splay，num[x]，num[a]+num[b]-num[lca(a,b)]*2+1 第3个操作求子树里面的最大num，可以dfs序+线段树维护。 设定num[x]为从x节点开始，往上走到根经过了多少个splay，在开始的时候所有节点都各自为一个splay,此时的num[x]就是每一个节点的深度dep，在dfs的时候就可以搞出来。 想到这个LCT,没有link,没有cut，只有虚实边的转化，于是乎只有Acces会调整他的num值（切换左右儿子的时候）。考虑到每连上去一条边，原本连到的那个结点（切换点的后继）的子树从 id[x]到id[x]+siz[x]-1都会加上一个1（多了一个虚边多了一个到根节点的splay）,之后连到的那个结点的id[x]+siz[x]-1都会减去一个1。

我们考虑线段树维护其区间max，每次ACCES加减就是max的区间修改，而第三问则直接询问子树上的区间Max。

注意我们splay维护的dfs序，在考虑切换重边的时候要考虑到找到深度最小的点（因为这个卡了两个小时的蒟蒻）。

要找LCA，由于这其实是一个静态的树，我们可以LCA转RMQ，，由于本蒟蒻很弱，直接写的倍增。。。

于是就搞定啦！

code:

```cpp
#include<stdio.h>
#include<bits/stdc++.h>
#define midd ((l+r)>>1)
#define zig(x) zigzag(x,1)
#define zag(x) zigzag(x,2)
using namespace std;
int n,m;
int owo,la[100005],nt[200005],en[200005];
void addedge(int a,int b)
{
    en[++owo]=b; nt[owo]=la[a]; la[a]=owo;
}
int idcnt,id[100005],old[100005],maxr[100005],dep[100005];
int fa[100005],ls[100005],rs[100005];
struct node
{
    int ll,rr,mx,lazy;
}z[8*100005];
void maketree(int p,int l,int r)
{
    z[p].ll=l; z[p].rr=r;
    if(l==r) { z[p].mx=dep[old[l]]; return; } 
    maketree(p<<1,l,midd);
    maketree(p<<1|1,midd+1,r);
    z[p].mx=max(z[p<<1].mx,z[p<<1|1].mx);
}
void ppd(int p)
{
	if(z[p].ll==z[p].rr||(!z[p].lazy)) return;
    z[p<<1].lazy+=z[p].lazy;
    z[p<<1|1].lazy+=z[p].lazy;
    z[p<<1].mx+=z[p].lazy;
    z[p<<1|1].mx+=z[p].lazy;
    z[p].lazy=0;
}
bool isroot(int x) { return ((!fa[x])||(ls[fa[x]]!=x&&rs[fa[x]]!=x)); } 
void zigzag(int x,int knd) 
{ 
    int y=fa[x]; int z=fa[y]; 
    if(!isroot(y)) 
    { 
        if(ls[z]==y) ls[z]=x; 
        else rs[z]=x; 
    } 
    fa[x]=z; fa[y]=x; 
    if(knd==1) 
    { 
        ls[y]=rs[x]; 
        fa[ls[y]]=y; 
        rs[x]=y; 
    } 
    else 
    { 
        rs[y]=ls[x]; 
        fa[rs[y]]=y; 
        ls[x]=y; 
    } 
}
void splay(int x) 
{ 
    int y,z; 
    while(!isroot(x)) 
    { 
        y=fa[x]; z=fa[y]; 
        if(isroot(y)) 
        { 
            if(ls[y]==x) zig(x); 
            else zag(x); 
        } 
        else 
        { 
            if(ls[z]==y) 
            { 
                if(ls[y]==x) { zig(y); zig(x); } 
                else { zag(x); zig(x); }  
            } 
            else 
            { 
                if(rs[y]==x) { zag(y); zag(x); } 
                else { zig(x); zag(x); } 
            }  
        } 
    } 
}
void update(int p,int x,int y,int d)
{
    if(x<=z[p].ll&&z[p].rr<=y) { z[p].mx+=d; z[p].lazy+=d; return; }
    if(z[p].lazy) ppd(p);
    if(z[p<<1].rr>=x&&z[p<<1].ll<=y) update(p<<1,x,y,d);
    if(z[p<<1|1].rr>=x&&z[p<<1|1].ll<=y) update(p<<1|1,x,y,d);
    z[p].mx=max(z[p<<1|1].mx,z[p<<1].mx);
}
int mmm(int x)
{
	while(ls[x]) x=ls[x];
	return x;
}
void acc(int x)
{
    for(int y=0;x;y=x,x=fa[x])
    {
        splay(x);
        if(rs[x])
        {
        	int z=mmm(rs[x]);
            update(1,id[z],maxr[z],1);
        }
        rs[x]=y;
        if(y)
        {
        	int z=mmm(y);
            update(1,id[z],maxr[z],-1);
        }
    }
}


int getmax(int p,int x,int y)
{
    if(x<=z[p].ll&&z[p].rr<=y) return z[p].mx;
    if(z[p].lazy) ppd(p);
    int lmax=-0x3f3f3f3f,rmax=-0x3f3f3f3f;
    if(z[p<<1].rr>=x&&z[p<<1].ll<=y) lmax=getmax(p<<1,x,y);
    if(z[p<<1|1].rr>=x&&z[p<<1|1].ll<=y) rmax=getmax(p<<1|1,x,y);
    return max(lmax,rmax);
}
int pa[100005][30];
int lcaa(int x,int y)
{
    if(dep[x]<dep[y]) swap(x,y);
    for(int k=dep[x]-dep[y],i=0;k;i++,k>>=1)
    {
        if(k&1) x=pa[x][i];
    }
    if(x==y) return x;
    for(int k=20;k>=0;k--)
    {
        if(pa[x][k]!=pa[y][k]) { x=pa[x][k]; y=pa[y][k]; }
    }
    return pa[x][0];
}

void dfs(int x,int ba)
{
    pa[x][0]=ba;
    dep[x]=dep[ba]+1;
    for(int k=20,i=1;i<=k;i++) pa[x][i]=pa[pa[x][i-1]][i-1];
    fa[x]=ba;
    id[x]=++idcnt;
	old[idcnt]=x;
	for(int it=la[x];it;it=nt[it])
    {
        if(en[it]!=ba)
        {
            dfs(en[it],x);
        }
    }
    maxr[x]=idcnt;
}
int query(int p,int x)
{
    if(z[p].ll==z[p].rr) return z[p].mx;
        if(z[p].lazy) ppd(p);
    if(x<=z[p<<1].rr) return query(p<<1,x);
    else return query(p<<1|1,x);
}
int main()
{
//	freopen("date.in","r",stdin);
//	freopen("zhengjie.out","w",stdout);
    int a,b;
    scanf("%d%d",&n,&m);
    for(int i=1;i<n;i++)
    {
        scanf("%d%d",&a,&b); addedge(a,b); addedge(b,a);
    }
    dfs(1,0);
    maketree(1,1,n);
    int kkk,x;
    for(int i=1;i<=m;i++)
    {
        scanf("%d",&kkk);
        if(kkk==1)
        {
            scanf("%d",&x);
            acc(x);
        }
        else if(kkk==2)
        {
            scanf("%d%d",&a,&b);
            int aha=lcaa(a,b);
            int aaaa=query(1,id[a])+query(1,id[b])-query(1,id[aha])*2+1;
            printf("%d\n",aaaa);
        }
        else
        {
            scanf("%d",&a);
            printf("%d\n",getmax(1,id[a],maxr[a]));
        }
    }
} 

```



---

## 作者：Sai0511 (赞：5)

LCT + 树剖 + 线段树。       
由于每个操作都是从一个点染到根，那么就可以很清楚的知道：颜色种数 = 颜色段数。   
接着我们可以知道两个点$x,y$的颜色种数其实就是$x$到根的颜色种数 + $y$到根的颜色种数 - $2lca(x,y)$到根的颜色种数 + 1。                   
将一个点染色时，同时会不可避免的断掉一些颜色段，使断掉的部分子树的答案会加1。  
我们用$\text{LCT}$来维护这些链。    
通过把图画出来可以知道：   
增加1的子树其实是access时原来的右儿子，  
而减少1其实是access时像现在的右儿子。      
之后就可以做了。     
```cpp
#include <bits/stdc++.h>

#define _swap(a,b) (a ^= b ^= a ^= b)
const int maxn = 1e5 + 10;

class FastIO {
    private:
        #define tn(x) (x << 1) + (x << 3)
        #define D isdigit(c = getchar())
        char c;  int T, S[10000];
    public:
        template<class Tp> inline void read(Tp& x) { x = 0;  while(!D);  while(x = tn(x) + (c & 15),D); }
        template<class Tp> inline void write(Tp x) { while(S[++T] = x % 10 + 48,x /= 10);  while(T) putchar(S[T--]); }
        template<class Tp,class... Ar> inline void read(Tp& x,Ar&... y) { read(x);  read(y...); }
        template<class Tp> inline void writeln(const Tp& x) { write(x);  putchar('\n'); }
} I;

inline void cmax(int& x,int y) { if(x < y) x = y; }
inline int _max(int x,int y) { return x > y ? x : y; }

int n, m, i, j, k, cnte, tot;
int fa[maxn], id[maxn], dep[maxn], sz[maxn], dfn[maxn], top[maxn], hson[maxn];

struct edge {
    int v;
    edge* nxt;
} pool[maxn << 1], *head[maxn], *cur = pool;
inline void adde(int u,int v) {
    edge* p = cur++;
    p -> v = v;  p -> nxt = head[u];
    head[u] = p;
}

void dfs1(int u,int pa) {
    dep[u] = dep[pa] + 1;  fa[u] = pa;  sz[u] = 1;
    for(edge* p = head[u];p;p = p -> nxt) {
        int v = p -> v;
        if(v == pa)
            continue;
        dfs1(v,u);
        sz[u] += sz[v];
        if(sz[v] > sz[ hson[u] ])
            hson[u] = v;
    }
}
void dfs2(int u,int up) {
    top[u] = up;  dfn[u] = ++tot;  id[tot] = u;
    if(hson[u])
        dfs2(hson[u],up);
    for(edge* p = head[u];p;p = p -> nxt) {
        int v = p -> v;
        if(v == fa[u] || v == hson[u])
            continue;
        dfs2(v,v);
    }
}
inline int Glca(int u,int v) {
    while(top[u] != top[v]) {
        if(dep[ top[u] ] < dep[ top[v] ])
            _swap(u,v);
        u = fa[ top[u] ];
    }
    return dep[u] < dep[v] ? u : v;
}

class Segment_Tree {
    private:
        int mx[maxn << 2], tag[maxn << 2];
    public:
        inline void push_up(int u) {
            mx[u] = _max(mx[u << 1],mx[u << 1 | 1]);
        }
        inline void push_down(int u) {
            if(!tag[u])
                return;
            mx[u << 1] += tag[u];  mx[u << 1 | 1] += tag[u];
            tag[u << 1] += tag[u];  tag[u << 1 | 1] += tag[u];
            tag[u] = 0;
        }
        void build(int l,int r,int u) {
            if(l == r)
                return mx[u] = dep[ id[l] ], void();
            int mid = (l + r) >> 1;
            build(l,mid,u << 1);
            build(mid + 1,r,u << 1 | 1);
            push_up(u);
        }
        int query(int ql,int qr,int l,int r,int u) {
            //printf("%d %d %d %d %d %d\n",ql,qr,l,r,u,mx[u]);
            if(ql <= l && r <= qr)
                return mx[u];
            push_down(u);
            int res = 0, mid = (l + r) >> 1;
            if(ql <= mid)
                cmax(res,query(ql,qr,l,mid,u << 1));
            if(mid < qr)
                cmax(res,query(ql,qr,mid + 1,r,u << 1 | 1));
            return res;
        }
        void modify(int ml,int mr,int l,int r,int u,int x) {
            if(ml <= l && r <= mr)
                return tag[u] += x, mx[u] += x, void();
            push_down(u);
            int mid = (l + r) >> 1;
            if(ml <= mid)
                modify(ml,mr,l,mid,u << 1,x);
            if(mid < mr)
                modify(ml,mr,mid + 1,r,u << 1 | 1,x);
            push_up(u);
            return;
        }
} segt;

class Link_Cut_Tree {
    private:
        int ch[maxn][2];
    public:
        int fa[maxn];
        inline bool nroot(int u) {
            return ch[ fa[u] ][0] == u || ch[ fa[u] ][1] == u;
        }
        inline int ident(int u) {
            return ch[ fa[u] ][1] == u;
        }
        inline void rotate(int u) {
            int oldf = fa[u], oldgf = fa[oldf], whi = ident(u);
            if(nroot(oldf))
                ch[oldgf][ident(oldf)] = u;
            ch[oldf][whi] = ch[u][whi ^ 1];
            fa[ ch[oldf][whi] ] = oldf;
            ch[u][whi ^ 1] = oldf;
            fa[oldf] = u;  fa[u] = oldgf;
        }
        inline void splay(int u) {
            for(int p = fa[u];nroot(u);rotate(u),p = fa[u]) {
                if(nroot(p))
                    rotate(ident(p) == ident(u) ? p : u);
            }
        }
        inline int find_root(int x) {
            while(ch[x][0])
                x = ch[x][0];
            return x;
        }
        inline void access(int x) {
            for(int y = 0, z;x;x = fa[y = x]) {
                splay(x);
                if(ch[x][1])
                    z = find_root(ch[x][1]), segt.modify(dfn[z],dfn[z] + sz[z] - 1,1,n,1,1);
                if(ch[x][1] = y)
                    z = find_root(ch[x][1]), segt.modify(dfn[z],dfn[z] + sz[z] - 1,1,n,1,-1);
            }
        }
} lct;

int main() {
    I.read(n,m);
    for(int i = 1, u, v;i < n;i++) {
        I.read(u,v);
        adde(u,v);
        adde(v,u);
    }
    dfs1(1,0);
    dfs2(1,1);
    for(int i = 1;i <= n;i++)
        lct.fa[i] = fa[i];
    segt.build(1,n,1);
    for(int op, x, y;m;m--) {
        I.read(op,x);
        if(op == 1)
            lct.access(x);
        else if(op == 2) {
            I.read(y);
            int z = Glca(x,y);
            printf("%d\n",segt.query(dfn[x],dfn[x],1,n,1) + segt.query(dfn[y],dfn[y],1,n,1) - 2 * segt.query(dfn[z],dfn[z],1,n,1) + 1);
        } else
            printf("%d\n",segt.query(dfn[x],dfn[x] + sz[x] - 1,1,n,1));
    }
    return 0;
}
```

---

## 作者：Orion545 (赞：5)

# 广告

[蒟蒻のblog](https://www.cnblogs.com/dedicatus545/p/9406690.html)

# 思路

### $LCT$

我们发现，这个1操作，好像非常像$LCT$里面的$Access$啊~

那么我们尝试把$Access$操作魔改成本题中的涂色

我们令$LCT$中的每一个$splay$链代表同一种颜色的一条链，那么$Access(u)$就相当于把这一段变成同一种颜色

注意这个东西能成立，是因为**每次涂上的都是新的一种颜色**（所以如果有$m$种颜色，每次涂其中一种，可能重复的之类的就不能这么做了）

### 线段树

接下来我们解决询问的问题：什么结构能维护链上信息和子树信息（同时）？当然是线段树了~

我们考虑开一棵以$dfs$序为下标的线段树，线段树的每个叶节点保存这个节点到根的路径权值，其他节点维护对应区间的最大值

这样，询问三就变成了区间求$max$，询问二则可以化成$w[u]+w[v]-2*w[lca]+1$这样的形式（$w[u]$表示$u$到根路径上的权值）（这个东西不管颜色怎么分布，一定是对的，证明很容易，可以自己想想）

但是这样之后，我们在修改一的时候，怎么修改线段树上的值呢？

### 维护线段树

我们发现，在修改的过程中，每一次我们从当前$splay$连向上面的$splay$时，会把一条虚边变成重边、一条重边变成虚边

那么，原来重边下的这棵子树，因为它上面的东西变成了新的颜色，而上面的东西本来是和它一个颜色的，所以重边的这棵子树中所有节点的权值要+1

而对于原来虚边下面的这棵子树来说，它上面的东西本来和它不是一个颜色的，现在是同一个颜色了，所以虚边的子树中所有节点的权值要-1

这样，我们只要在$Access$的时候，同时维护线段树的权值就可以了

### 总结

本题从与$Access$相似的修改方式开始，切入点是$LCT$，然后加入了线段树维护，并且确定了在$Access$操作的同时修改线段树的值

总时间复杂度为均摊$O(nlog^2n)$

一些实现细节可以参考代码

# Code

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cassert>
#include<cmath>
#define ll long long
using namespace std;
inline int read(){
	int re=0,flag=1;char ch=getchar();
	while(ch>'9'||ch<'0'){
		if(ch=='-') flag=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9') re=(re<<1)+(re<<3)+ch-'0',ch=getchar();
	return re*flag;
}
int n,Q,first[100010],cnte,dep[100010],st[100010][20],dfn[100010],lim[100010],back[100010],cntn;
int fa[100010];
struct edge{
	int to,next;
}e[200010];
inline void add(int u,int v){
	e[++cnte]=(edge){v,first[u]};first[u]=cnte;
	e[++cnte]=(edge){u,first[v]};first[v]=cnte;
}
void dfs(int u,int f){
	int i,v;dep[u]=dep[f]+1;st[u][0]=f;fa[u]=f;//这里把LCT的fa数组预处理好（此时没有边，都是虚边）
	dfn[u]=++cntn;back[cntn]=u;
	for(i=first[u];~i;i=e[i].next){
		v=e[i].to;if(v==f) continue;
		dfs(v,u);
	}
	lim[u]=cntn;
}
void ST(){
	for(int j=1;j<=19;j++){
		for(int i=1;i<=n;i++) 
        	st[i][j]=st[st[i][j-1]][j-1];
	}
}
int lca(int l,int r){
	int i;
	if(dep[l]>dep[r]) swap(l,r);
	for(i=19;i>=0;i--) if(dep[st[r][i]]>=dep[l]) r=st[r][i];
	if(l==r) return l;
	for(i=19;i>=0;i--){
		if(st[r][i]!=st[l][i]){
			l=st[l][i];
			r=st[r][i];
		}
	}
	return st[l][0];
}
//segment tree
int a[400010],lazy[400010];
void update(int num){
	a[num]=max(a[num<<1],a[num<<1|1]);
}
void push(int l,int r,int num){
	if(l==r||!lazy[num]) return;
	a[num<<1]+=lazy[num];a[num<<1|1]+=lazy[num];
	lazy[num<<1]+=lazy[num];lazy[num<<1|1]+=lazy[num];
	lazy[num]=0;
}
void build(int l,int r,int num){
	if(l==r){a[num]=dep[back[l]];return;}
	int mid=(l+r)>>1;
	build(l,mid,num<<1);build(mid+1,r,num<<1|1);
	update(num);
}
void change(int l,int r,int ql,int qr,int num,int ch){
	push(l,r,num);
	if(l>=ql&&r<=qr){a[num]+=ch;lazy[num]+=ch;return;}
	int mid=(l+r)>>1;
	if(mid>=ql) change(l,mid,ql,qr,num<<1,ch);
	if(mid<qr) change(mid+1,r,ql,qr,num<<1|1,ch);
	update(num);
}
int query(int l,int r,int ql,int qr,int num){
	push(l,r,num);
	if(l>=ql&&r<=qr) return a[num];
	int mid=(l+r)>>1,re=-1e9;
	if(mid>=ql) re=max(re,query(l,mid,ql,qr,num<<1));
	if(mid<qr) re=max(re,query(mid+1,r,ql,qr,num<<1|1));
	return re;
}
//link cut tree
int ch[100010][2]={0},rt[100010];//这棵splay其实什么都不用维护......只是需要它的结构罢了
int get(int pos){return ch[fa[pos]][1]==pos;}
void rotate(int x){
	int f=fa[x],ff=fa[f],son=get(x);
	ch[f][son]=ch[x][son^1];
	if(ch[f][son]) fa[ch[f][son]]=f;
	fa[f]=x;ch[x][son^1]=f;
	fa[x]=ff;
	if(rt[f]) rt[x]=1,rt[f]=0;
	else ch[ff][ch[ff][1]==f]=x;
}
void splay(int pos){
	if(rt[pos]) return;
	for(int f;!rt[pos];rotate(pos)){
		if(!rt[f=fa[pos]])
			rotate((get(f)==get(pos))?f:pos);
	}
}
int pre(int pos){
	while(ch[pos][0]) pos=ch[pos][0];
	return pos;
}
void access(int pos){
	for(int tmp=0,tt;pos;tmp=pos,pos=fa[pos]){
		splay(pos);
		if(ch[pos][1]){//重边变虚边，+1
			tt=pre(ch[pos][1]);
			change(1,n,dfn[tt],lim[tt],1,1);
		}
		rt[ch[pos][1]]=1;ch[pos][1]=tmp;rt[tmp]=0;
		if(tmp){//虚边变重边，-1
			tt=pre(tmp);
			change(1,n,dfn[tt],lim[tt],1,-1);
		}
	}
}
int main(){
	memset(first,-1,sizeof(first));
	n=read();Q=read();int i,t1,t2,t3,f;
	for(i=1;i<n;i++){
		t1=read();t2=read();
		add(t1,t2);
	}
	dfs(1,0);ST();build(1,n,1);
	for(i=1;i<=n;i++) rt[i]=1;
	while(Q--){
		t1=read();
		if(t1==1){
			t2=read();access(t2);
		}
		if(t1==2){
			t2=read();t3=read();
			f=lca(t2,t3);
			printf("%d\n",query(1,n,dfn[t2],dfn[t2],1)+query(1,n,dfn[t3],dfn[t3],1)-2*query(1,n,dfn[f],dfn[f],1)+1);
		}
		if(t1==3){
			t2=read();
			printf("%d\n",query(1,n,dfn[t2],lim[t2],1)); 
		}
	}
}
```

---

## 作者：_ctz (赞：4)

[更好的阅读体验$QwQ$](https://ctz45562.github.io/2019/02/27/%E9%A2%98%E8%A7%A3-%E6%B4%9B%E8%B0%B7-P3703-%E3%80%90-SDOI2017-%E6%A0%91%E7%82%B9%E6%B6%82%E8%89%B2%E3%80%91/)

[传送门](https://www.luogu.org/problemnew/show/P3703)

$LCT$维护树上联通块。

首先看$1$操作，起点为根的链染色，而且是~~chuan~~全新的颜色。可以自己画个图看看。


是不是有种$LCT$里的$access$的感觉？那就可以考虑用$LCT$维护树的形态，把相同颜色的点放在同一棵$splay$里。因为一定是从根开始的染色，染的是不同的颜色，初始颜色又不同，就能保证一棵$splay$一定维护一条链，符合$LCT$的性质，是可行的。（事实上这也是$LCT$维护树上联通块的常见姿势）

于是对于操作$1$，就是$access$一下。对于一个点的权值也就是从该点到根节点的路径会经过几个$splay$。因为在$access$时，每向上跳一次虚边就相当于跨过了一个$splay$，所以可以用这个性质来统计。

伪代码：

```cpp
	int fake_access(int x){
        int ans=0;
		for(;x;x=fa[x],++ans)
			splay(x);
        //统计答案不能真的access改变树的形态，所以不连儿子
        //这也是为啥叫fAKe_access——它没有真的access
		return ans;
	}

```

于是操作$2$就是$fake\_access(x)+fake\_access(y)-2*fake\_access(lca(x,y))+1$

（一定要$+1$，因为减去了$2*fake\_access(lca(x,y))$后，$lca(x,y)$自己的$splay$就被减没了）

麻烦的是操作$3$。

根据上面，一个点的权值，也就相当于一个点到根节点路径上**有几条虚边**。

那么有一条虚边变重了，它对应的子树权值就会都$-1$；有一条实边变轻了，它对应的子树权值都会$+1$。

初始权值好求，就是点的深度。子树加加减减，还要求子树权值$max$，可以用$dfs$序+线段树来维护。

能改变虚实边的就是$access$操作了。这里还要在$LCT$中要维护一下每个$splay$中深度最小的点（记为$ma[x]$，原因看下面伪代码解释）。

伪代码：

```cpp
//seg为dfs序，siz为子树大小
void access(int x){
	for(int y=0;x;y=x,x=fa[x]){
		splay(x);		
        if(son(x,1))st.add(seg[ma[son(x,1)]],seg[ma[son(x,1)]]+siz[ma[son(x,1)]]-1,1,cnt,1,1);
		//son(x,1)变轻，子树+1
		//变轻的一定是这棵splay中深度最小的点（毕竟是一条链），但是本身在splay中可能会出现它的根不是深度最小的点，所以要维护一下
        if(y)st.add(seg[ma[y]],seg[ma[y]]+siz[ma[y]]-1,1,cnt,1,-1);
        //y变重，子树-1
        //同理，变重的也是深度最小的点
		son(x,1)=y;
		update(x);
	}
}

```



这样就实现了用$LCT$维护形态，在线段树上维护信息。其实这样操作$2$也可以用线段树来查了。

时间复杂度：$O(nlog^2n)$

代码：

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <cstring>
#include <set>

#define maxn 100005
#define inf 0x3f3f3f
#define pn putchar('\n')
#define px(x) putchar(x)
#define ps putchar(' ')
#define pd puts("======================")
#define pj puts("++++++++++++++++++++++")

using namespace std;

inline int read(){
	int x=0,y=0;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')y=1;ch=getchar();}
	while(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
	return y?-x:x;
}
template<typename T>
inline T read(){
	T x=0;
	int y=0;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')y=1;ch=getchar();}
	while(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
	return y?-x:x;
}
inline int ran(){
	static int seed=45562;
	return seed=(seed*48271LL%2147483647);
}
int h[maxn],num;
struct edge{
	int to,pre;
}e[maxn<<1];
inline void add(int from,int to){
	e[++num].pre=h[from],h[from]=num,e[num].to=to;
}
int pos[maxn],seg[maxn],top[maxn],deep[maxn],fa[maxn],son[maxn],siz[maxn],cnt;
struct Segment_Tree{
	int ma[maxn<<2],tag[maxn<<2];
#define ls(x) (x<<1)
#define rs(x) (x<<1|1)
	inline void update(int node){
		ma[node]=max(ma[ls(node)],ma[rs(node)]);	
	}
	inline void datadown(int node,int d){
		ma[node]+=d;
		tag[node]+=d;
	}
	inline void pushdown(int node){
		datadown(ls(node),tag[node]);
		datadown(rs(node),tag[node]);
		tag[node]=0;
	}
	void build(int l,int r,int node){
		if(l==r){
			ma[node]=deep[pos[l]]+1;
            //因为深度是从0开始的，所以要+1
			return;
		}
		int mid=l+r>>1;
		build(l,mid,ls(node));
		build(mid+1,r,rs(node));
		update(node);
	}
	void add(int L,int R,int l,int r,int node,int d){
		if(L<=l&&R>=r){
			datadown(node,d);
			return;
		}
		if(tag[node])pushdown(node);
		int mid=l+r>>1;
		if(L<=mid)add(L,R,l,mid,ls(node),d);
		if(R>mid)add(L,R,mid+1,r,rs(node),d);
		update(node);
	}
	int ask(int L,int R,int l,int r,int node){
		if(L<=l&&R>=r)return ma[node];
		if(tag[node])pushdown(node);
		int mid=l+r>>1,ans=0;
		if(L<=mid)ans=ask(L,R,l,mid,ls(node));
		if(R>mid)ans=max(ans,ask(L,R,mid+1,r,rs(node)));
		return ans;
	}
}st;//线段树
struct Link_Cut_Tree{
	int son[maxn][2],fa[maxn],ma[maxn];
#define son(x,y) son[x][y]
#define whson(x) (son[fa[x]][1]==x)
#define root(x) (son[fa[x]][0]!=x&&son[fa[x]][1]!=x)
	inline void update(int node){
		if(son(node,0))ma[node]=ma[son(node,0)];
		else ma[node]=node;
	}
	inline void addedge(int s,int f,int wh){
		son(f,wh)=s;
		if(s)fa[s]=f;
	}
	inline void zhuan(int x){
		int f=fa[x],gf=fa[f],wh=whson(x);
		fa[x]=gf;
		if(!root(f))son(gf,whson(f))=x;
		addedge(son(x,wh^1),f,wh);
		addedge(f,x,wh^1);
		update(f),update(x);
	}
	void splay(int x){
		int y=fa[x];
		while(!root(x)){
			if(!root(y))
				zhuan(whson(x)^whson(y)?x:y);
			zhuan(x);
			y=fa[x];
		}
	}
	void access(int x){
		for(int y=0;x;y=x,x=fa[x]){
			splay(x);
			if(son(x,1))st.add(seg[ma[son(x,1)]],seg[ma[son(x,1)]]+siz[ma[son(x,1)]]-1,1,cnt,1,1);
			if(y)st.add(seg[ma[y]],seg[ma[y]]+siz[ma[y]]-1,1,cnt,1,-1);
			son(x,1)=y;
			update(x);
		}
	}
	int fake_access(int x){
		int ans=0;
		for(;x;x=fa[x],++ans)
			splay(x);
		return ans;
	}
}lct;//lct
struct Tree_Chain_Split{
	void dfs1(int node=1){
		siz[node]=1;
		lct.ma[node]=node;
		for(register int i=h[node];i;i=e[i].pre){
			int x=e[i].to;
			if(!siz[x]){
				lct.fa[x]=fa[x]=node;
				deep[x]=deep[node]+1;
				dfs1(x);
				if(siz[x]>siz[son[node]])son[node]=x;
				siz[node]+=siz[x];
			}
		}
	}
	void dfs2(int node=1){
		seg[node]=++cnt;
		pos[cnt]=node;
		if(son[node]){
			top[son[node]]=top[node];
			dfs2(son[node]);
			for(register int i=h[node];i;i=e[i].pre){
				int x=e[i].to;
				if(!seg[x])top[x]=x,dfs2(x);
			}
		}
	}
	int lca(int x,int y){
		while(top[x]!=top[y]){
			if(deep[top[x]]<deep[top[y]])swap(x,y);
			x=fa[top[x]];
		}
		return deep[x]<deep[y]?x:y;
	}//用的树剖求lca
}tcs;
int main(){
	int n=read(),m=read();
	for(register int i=1;i<n;++i){
		int a=read(),b=read();
		add(a,b),add(b,a);
	}
	tcs.dfs1(),tcs.dfs2();
	st.build(1,cnt,1);
	while(m--){
		int s=read(),x=read();
		if(s==1)lct.access(x);
		else if(s==2){
			int y=read();
			printf("%d\n",lct.fake_access(x)+lct.fake_access(y)-(lct.fake_access(tcs.lca(x,y))<<1)+1);
		}
		else printf("%d\n",st.ask(seg[x],seg[x]+siz[x]-1,1,cnt,1));
	}
}

```



---

## 作者：shadowice1984 (赞：2)

其实严格来讲这道题并不是lct?

(但是思路上还是lct的思路就对了，反正最后实现的时候一个splay就够了)

熟练压行的话百行以内可以写完？

(食用本题解时请确保您理解lct里的轻重边概念，但是并不需要熟练掌握lct)

~~(什么你不知道什么是轻重边？出门左转你站膜板区，包教包会)~~

# 本题题解

显然这是一道数据结构题，所以让我们先来分析一下资瓷什么操作

1.树上染色

2.树上询问颜色数量

3.子树询问内颜色最大值(显然子树内的所有点在子树过了子树根之后路径完全一样，所以可以只考虑到根的颜色个数)

那么我们会发现一个非常重要的性质，因为是到根节点路径染色，所以相同颜色的点必定在同一个联通块内，(也就是说不会有两段分开的颜色)

那么我们可以转化一下问题，路径上的颜色数目=路径上的分割边数+1

(这里指的分割边是指这个边连接的两个点颜色不同)

那么我们会发现其实如果把1操作看成lct的access操作，那么我们的“分割边”其实就是lct中的轻边

所以我们现在要资瓷的操作就是询问轻边数量？

那么看一下转换后的操作

1.access

2.询问路径上轻边数量

3.询问到根节点轻边数量最大

那么我们发现现在维护的东西是边而不是点，我们知道，如果是点的话在询问
u到v的路径信息时采用$ u+v-2lca(u,v)$的方式是会漏算lca这个点的，但是如果是边的话就可以直接使用$u+v-2lca(u,v)$这个式子了，因为各个路径的边是不相
交的

所以说我们想知道x到y的路径上有多少条轻边,只需要知道x到1有多少条轻边，y到1有多少条轻边，和x，y的lca有多少条轻边然后$u+v-2lca(u,v)$就行了

(下文中的”轻边数量“代指某个点到1路径上的轻边数量)

一开始这个树全部是轻边，所以每个点的轻边数量就等于这个节点的深度

我们发现当一个轻边变成重边的时候，以轻边底部的点为根的子树轻边数量-1

当一个重边变成轻边的时候，以重边底部的点为根的子树轻边数量+1

唯一的问题变成了如何在树上找到所有的轻边(咦这话我好像在哪里见过)

然后我们是可以lct暴力维护轻边的，根据lct的复杂度证明，我们最多修改nlogn条轻边，所以每次碰到一次轻重切换就在线段树上暴力修改即可，(子树问题可以通过dfs拍平转换为序列问题)

(或者链剖之后线段树/树状数组上二分没准也可以？)

由于我们只会进行nlogn次修改，所以总复杂度是$O(nlog^2n)$的

对于操作3是一个简单的区间最大值问题(因为我们维护的就是到根节点的轻边数量)

所以我们需要写一个资瓷区间加和查区间最大值的线段树(单点查值就是区间最大值233)和一个倍增找lca

然后下面简单介绍一下如何快速找到所有的轻边

显然我们在执行access操作的时候只会把链上的边变成重边

那么我们可以把在同一个重链里的点看成一个集合，在集合里按深度排序，我们只需要不停的集合的最小值，然后这个最小值和最小值的father就会构一个轻边了，当然我们还需要进行一些断开和合并集合的操作，比如轻边重合并两个集合，重变轻将一个集合分裂为两个集合

因此这需要我们实现一个**可分裂合并堆**，emm……也就是splay,(或者可以尝试下split-merge-treap？)然后就可以一路暴力跳轻边查找了

代码的话脑子清楚还是很好写的，但是如果逻辑混乱的话就非常不好写了

具体可以看注释加深理解

上代码~

```C
#include<cstdio>
#include<algorithm>
using namespace std;const int N=1e5+10;
int n;int m;int dfn[N];int nfd[N];int siz[N];int df;int f[N][22];
int v[2*N];int x[2*N];int al[N];int ct;int dep[N];int h[N];
struct splaytree//压行后的splay 
{
	int s[N][2];int fa[N];
	inline int gc(int x){return s[fa[x]][1]==x;}//检查左右儿子 
	inline void rt(int x)//二合一旋转 
	{
		int d=fa[x];int t=gc(x);s[d][t]=s[x][t^1];fa[s[x][t^1]]=d;
		s[fa[d]][gc(d)]=x;fa[x]=fa[d];s[x][t^1]=d;fa[d]=x;
	}
	inline void rtup(int x){rt((gc(x)^gc(fa[x]))?x:fa[x]);rt(x);}//双旋 
	inline void splay(int x){for(;fa[fa[x]]&&fa[x];rtup(x));if(fa[x])rt(x);}//splay 
	inline int mi(int x){for(;s[x][0];x=s[x][0]);return x;}//最小值 
	inline int getmi(int x){splay(x);return mi(x);}//查找最小值 
	inline void split(int x){splay(x);fa[s[x][1]]=0;s[x][1]=0;}//分裂 
	inline void merge(int x,int y){splay(y);s[x][0]=y;fa[y]=x;}//合并 
}spt;
struct linetree//线段树 
{
	int add[4*N];int ma[4*N];
	inline void pushdown(int p)//pushdown 
	{add[p<<1]+=add[p];add[p<<1|1]+=add[p];ma[p<<1]+=add[p];ma[p<<1|1]+=add[p];add[p]=0;}
	inline void setadd(int p,int l,int r,int dl,int dr,int plus)//区间加 
	{
		if(dl==l&&dr==r){add[p]+=plus;ma[p]+=plus;return;}
		int mid=(l+r)/2;pushdown(p);
		if(dl<mid){setadd(p<<1,l,mid,dl,min(dr,mid),plus);}
		if(mid<dr){setadd(p<<1|1,mid,r,max(dl,mid),dr,plus);}
		ma[p]=max(ma[p<<1],ma[p<<1|1]);
	}
	inline int gmax(int p,int l,int r,int dl,int dr)//查最大值 
	{
		if(dl==l&&dr==r){return ma[p];}
		int mid=(l+r)/2;pushdown(p);int res=-0x3f3f3f3f;
		if(dl<mid){res=max(res,gmax(p<<1,l,mid,dl,min(dr,mid)));}
		if(mid<dr){res=max(res,gmax(p<<1|1,mid,r,max(dl,mid),dr));}
		return res;
	}
	inline void build(int p,int l,int r)//建树 
	{
		if(r-l==1){ma[p]=dep[dfn[r]];return;}int mid=(l+r)/2;
		build(p<<1,l,mid);build(p<<1|1,mid,r);ma[p]=max(ma[p<<1],ma[p<<1|1]);
	}
}lt;
inline void add(int u,int V){v[++ct]=V;x[ct]=al[u];al[u]=ct;}//加边 
inline void dfs(int u)//dfs处理倍增lca和dfs序 
{
	siz[u]=1;dfn[++df]=u;nfd[u]=df;//倍增 
	for(int i=0;f[u][i];i++){f[u][i+1]=f[f[u][i]][i];}
	for(int i=al[u];i;i=x[i]) 
	{	
		if(siz[v[i]]){continue;}
		f[v[i]][0]=u;dep[v[i]]=dep[u]+1;dfs(v[i]);siz[u]+=siz[v[i]];
	}	
}
inline int lca(int u,int v)//查lca 
{
	if(dep[u]<dep[v]){swap(u,v);}int d=dep[u]-dep[v];
	for(int i=0;d;d>>=1,i++){if(d&1){u=f[u][i];}}if(u==v){return v;}
	for(int i=20;i>=0;i--){if(f[u][i]!=f[v][i]){u=f[u][i];v=f[v][i];}}
	return f[u][0];
}
inline void modify(int u)//修改 
{
	if(h[u]){lt.setadd(1,0,n,nfd[h[u]]-1,nfd[h[u]]+siz[h[u]]-1,1);spt.split(u);h[u]=0;}
	for(u=spt.getmi(u);u!=1;u=spt.mi(f[u][0]))//注意先分裂待修改点 
	{
		int& d=f[u][0];//然后先断开重儿子再合并新的重儿子，同时在线段树上修改 
		if(h[d]){lt.setadd(1,0,n,nfd[h[d]]-1,nfd[h[d]]+siz[h[d]]-1,1);spt.split(d);}
		lt.setadd(1,0,n,nfd[u]-1,nfd[u]+siz[u]-1,-1);spt.merge(u,d);h[d]=u;
	}
}
int main()
{
	scanf("%d%d",&n,&m);int tp;int u;int v;
	for(int i=1;i<n;i++){scanf("%d%d",&u,&v);add(u,v);add(v,u);}
	dfs(1);lt.build(1,0,n);//预处理 
	for(int i=1;i<=m;i++)
	{
		scanf("%d%d",&tp,&u);if(tp==1){modify(u);}//修改 
		else if(tp==2)//查找点值然后减去 
		{
			scanf("%d",&v);int l=lca(u,v);
			int du=lt.gmax(1,0,n,nfd[u]-1,nfd[u]);
			int dv=lt.gmax(1,0,n,nfd[v]-1,nfd[v]);
			int dl=lt.gmax(1,0,n,nfd[l]-1,nfd[l]);
			printf("%d\n",du+dv-2*dl+1);
		}else {printf("%d\n",lt.gmax(1,0,n,nfd[u]-1,nfd[u]+siz[u]-1)+1);}//区间最大值 
	}return 0;//拜拜程序~ 
}
```

---

## 作者：xyz32768 (赞：2)

我一眼以为是裸树剖，但是看完问题就知道不是那么容易了。因为只用树剖不能很好地维护操作$3$的结果。

首先，按照原树，构建出一个全部都是虚边的$LCT$，并用树剖维护每个点到根节点的路径权值$val$。可以发现，每个点到根节点的路径权值就是每个点到根节点的路径上实链的个数。

我们发现，操作$1$实际上就是$LCT$中$Access$的操作。在$Access$的操作中，如果一条实边变成虚边，那么将连接这条边的**深度较大的节点**的子树里所有点的$val$加 $1$（因为实链数量就等于虚边数量$+1$），如果一条虚边变成实边，那么将连接这条边的深度较大的节点的子树里所有点的$val$减$1$。

这样，询问$2$其实就是求$val[x]+val[y]-val[lca(x,y)]*2+1$的值，询问$3$就是求$x$的子树最大值。在以上，由于同一个子树里的节点$DFS$序是一段连续的区间，所以对于子树的修改询问，直接提取对应的$DFS$序区间即可。

代码：

```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#define p2 p << 1
#define p3 p << 1 | 1
using namespace std;
inline int read() {
    int res = 0; bool bo = 0; char c;
    while (((c = getchar()) < '0' || c > '9') && c != '-');
    if (c == '-') bo = 1; else res = c - 48;
    while ((c = getchar()) >= '0' && c <= '9')
        res = (res << 3) + (res << 1) + (c - 48);
    return bo ? ~res + 1 : res;
}
const int N = 1e5 + 5, LogN = 24;
int n, m, ecnt, nxt[N << 1], adj[N], go[N << 1], fa_s[N], lc[N], rc[N],
QAQ, fa[N][LogN], dep[N], sze[N], son[N], top[N], pos[N], idx[N], T[N << 2],
add[N << 2], ml[N];
void add_edge(int u, int v) {
    nxt[++ecnt] = adj[u]; adj[u] = ecnt; go[ecnt] = v;
}
int which(int x) {return rc[fa_s[x]] == x;}
bool is_root(int x) {
    return !fa_s[x] || (lc[fa_s[x]] != x && rc[fa_s[x]] != x);
}
void upd(int x) {
    ml[x] = lc[x] ? ml[lc[x]] : x;
}
void rotate(int x) {
    int y = fa_s[x], z = fa_s[y], b = lc[y] == x ? rc[x] : lc[x];
    if (z && !is_root(y)) (lc[z] == y ? lc[z] : rc[z]) = x;
    fa_s[x] = z; fa_s[y] = x; if (b) fa_s[b] = y;
    if (lc[y] == x) rc[x] = y, lc[y] = b;
    else lc[x] = y, rc[y] = b; upd(y); upd(x);
}
void splay(int x) {
    while (!is_root(x)) {
        if (!is_root(fa_s[x])) {
            if (which(x) == which(fa_s[x])) rotate(fa_s[x]);
            else rotate(x);
        }
        rotate(x);
    }
    upd(x);
}
void dfs1(int u, int fu) {
    int i; fa[u][0] = fu; dep[u] = dep[fu] + 1; sze[u] = 1;
    for (i = 0; i <= 19; i++) fa[u][i + 1] = fa[fa[u][i]][i];
    for (int e = adj[u], v; e; e = nxt[e]) {
        if ((v = go[e]) == fu) continue;
        dfs1(v, u); sze[u] += sze[v];
        if (sze[v] > sze[son[u]]) son[u] = v;
    }
}
void dfs2(int u, int fu) {
    if (son[u]) {
        top[son[u]] = top[u];
        idx[pos[son[u]] = ++QAQ] = son[u];
        dfs2(son[u], u);
    }
    for (int e = adj[u], v; e; e = nxt[e]) {
        if ((v = go[e]) == fu || v == son[u]) continue;
        top[v] = v; idx[pos[v] = ++QAQ] = v; dfs2(v, u);
    }
}
void build(int l, int r, int p) {
    if (l == r) return (void) (T[p] = dep[idx[l]]);
    int mid = l + r >> 1;
    build(l, mid, p2); build(mid + 1, r, p3);
    T[p] = max(T[p2], T[p3]);
}
void down(int p) {
    add[p2] += add[p]; add[p3] += add[p]; add[p] = 0;
}
void upt(int p) {
    T[p] = max(T[p2] + add[p2], T[p3] + add[p3]);
}
void change(int l, int r, int s, int e, int v, int p) {
    if (l == s && r == e) return (void) (add[p] += v);
    int mid = l + r >> 1; down(p);
    if (e <= mid) change(l, mid, s, e, v, p2);
    else if (s >= mid + 1) change(mid + 1, r, s, e, v, p3);
    else change(l, mid, s, mid, v, p2),
        change(mid + 1, r, mid + 1, e, v, p3);
    upt(p);
}
int query(int l, int r, int s, int e, int p) {
    if (l == s && r == e) return T[p] + add[p];
    int mid = l + r >> 1, res = 0; down(p);
    if (e <= mid) res = query(l, mid, s, e, p2);
    else if (s >= mid + 1) res = query(mid + 1, r, s, e, p3);
    else res = max(query(l, mid, s, mid, p2),
        query(mid + 1, r, mid + 1, e, p3));
    upt(p); return res;
}
void init() {
    int i; QAQ = top[1] = pos[1] = idx[1] = 1;
    dfs1(1, 0); dfs2(1, 0); build(1, n, 1);
    for (i = 1; i <= n; i++) fa_s[i] = fa[i][0], ml[i] = i;
}
void Access(int x) {
    int y;
    for (y = 0; x; y = x, x = fa_s[x]) {
        splay(x);
        if (rc[x]) change(1, n, pos[ml[rc[x]]], pos[ml[rc[x]]] +
            sze[ml[rc[x]]]- 1, 1, 1);
        if (y) change(1, n, pos[ml[y]], pos[ml[y]] + sze[ml[y]] - 1, -1, 1);
        rc[x] = y; if (y) fa_s[y] = x;
    }
}
int lca(int u, int v) {
    int i; if (dep[u] < dep[v]) swap(u, v);
    for (i = 20; i >= 0; i--) {
        if (dep[fa[u][i]] >= dep[v]) u = fa[u][i];
        if (u == v) return u;
    }
    for (i = 20; i >= 0; i--) if (fa[u][i] != fa[v][i])
        u = fa[u][i], v = fa[v][i];
    return fa[u][0];
}
int path_query(int u, int v) {
    int w = lca(u, v), res;
    res = query(1, n, pos[u], pos[u], 1) +
        query(1, n, pos[v], pos[v], 1);
    return res - (query(1, n, pos[w], pos[w], 1) << 1) + 1;
}
int main() {
    int i, op, x, y; n = read(); m = read();
    for (i = 1; i < n; i++) {
        x = read(); y = read();
        add_edge(x, y); add_edge(y, x);
    }
    init(); while (m--) {
        op = read(); x = read();
        if (op == 1) Access(x);
        else if (op == 2) y = read(), printf("%d\n", path_query(x, y));
        else printf("%d\n", query(1, n, pos[x], pos[x] + sze[x] - 1, 1));
    }
    return 0;
}
```

---

## 作者：Treeloveswater (赞：2)

省选Day1T3，当时我的想法是用树剖做，却只得了30分。好像就算最优美的树剖算法在时间复杂度上也会比LCT的多一个log。

正解是LCT。

操作1明显就是LCT的ACCESS操作喽。

我们将同一颜色的点放到一颗Splay里。

我们设F[i],表示该点i到根路径上不同颜色的数量。那么F[i]就等于到根中所有的虚边数量+1。

那么显然第二个结果为 F[x]+F[y]-2\*F[lca(x,y)]+1

我们用树链剖分承包LCA和F[i]的维护，那么第三个结果就是在X的子树区间取max（即线段树的区间max）。

现在难题在于第一个操作时我们该如何维护F[i]值？

考虑到题目只会使用一种新的颜色，所以我们在ACCESS的时候，如果当前点有后继，则后继+1；如果有前驱，则前驱-1。这些操作在线段树上进行即可。

那么这个题就解决了。

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define N 100005
#define M 200005
using namespace std;
struct node{
    int pos; 
    node *ch[2],*pre,*maxlson;
    bool judge();
    void setson(node *child,int lr);
    void update();
    bool isroot();
}pool[N],*null;
int n,m,cnt,tot,ui,vi,type;
int in[N],out[N],head[N],nxt[M],point[M],fatson[N],father[N],size[N],anc[N],rem[N],tree[N*4],delta[N*4],deep[N];
void PUSHDOWN(int now){
    if(!delta[now])return;
    int lson=now<<1,rson=lson+1;
    tree[lson]+=delta[now]; tree[rson]+=delta[now];
    delta[lson]+=delta[now]; delta[rson]+=delta[now];
    delta[now]=0;
}
void UPDATE(int now){
    tree[now]=max(tree[now<<1],tree[(now<<1)+1]);
}
void build(int now,int l,int r){
    if(l==r){
        tree[now]=deep[rem[l]]+1;
        return;
    }
    int mid=(l+r)>>1;
    build(now<<1,l,mid);
    build((now<<1)+1,mid+1,r);
    UPDATE(now);
}
void secchange(int now,int l,int r,int left,int right,int value){
    if(left<=l&&r<=right){
        tree[now]+=value;
        delta[now]+=value;
        return;
    }
    int mid=(l+r)>>1;
    PUSHDOWN(now);
    if(left<=mid) secchange(now<<1,l,mid,left,right,value);
    if(mid<right) secchange((now<<1)+1,mid+1,r,left,right,value);
    UPDATE(now);
}
int secquery(int now,int l,int r,int left,int right){
    if(left<=l&&r<=right){
        return tree[now];
    }
    int mid=(l+r)>>1,ans=-1e5;
    PUSHDOWN(now);
    if(left<=mid) ans=max(secquery(now<<1,l,mid,left,right),ans);
    if(mid<right) ans=max(secquery((now<<1)+1,mid+1,r,left,right),ans);
    return ans;
}
bool node::judge(){return pre->ch[1]==this;}
void node::update(){
    if(ch[0]==null) maxlson=this;
    else maxlson=ch[0]->maxlson;
}
bool node::isroot(){
    if(pre==null)return true;
    return (!(pre->ch[1]==this||pre->ch[0]==this)); 
}
void node::setson(node *child,int lr){
    ch[lr]=child;
    if(child!=null) child->pre=this;
    update();
}
node *getnew(int pos){
    node *now=pool+pos;
    now->pos=pos;
    now->ch[1]=now->ch[0]=now->pre=null;
    now->maxlson=now;
    return now;
}
void rotate(node *now){
    node *father=now->pre,*grandfa=now->pre->pre;
    int lr=now->judge();
    father->setson(now->ch[lr^1],lr);
    if(father->isroot()) now->pre=grandfa;
    else grandfa->setson(now,father->judge());
    now->setson(father,lr^1);
}
void splay(node *now){
    if(now->isroot())return;
    for(;!now->isroot();rotate(now))
    if(!now->pre->isroot()) now->judge()==now->pre->judge()? rotate(now->pre):rotate(now);
}
node *access(node *now){
    node *last=null;
    for(;now!=null;last=now,now=now->pre){
        splay(now);
        if(now->ch[1]!=null) secchange(1,1,cnt,in[now->ch[1]->maxlson->pos],out[now->ch[1]->maxlson->pos],1);
        if(last!=null) secchange(1,1,cnt,in[last->maxlson->pos],out[last->maxlson->pos],-1);
        now->setson(last,1);
    }
    return last;
}
void addedge(int x,int y){
    tot++;nxt[tot]=head[x];head[x]=tot;point[tot]=y;
    tot++;nxt[tot]=head[y];head[y]=tot;point[tot]=x;
}
void dfs(int now,int dad){
    father[now]=dad;
    size[now]=1;
    node *fa=pool+dad,*me=pool+now; me->pre=fa;
    for(int tmp=head[now];tmp;tmp=nxt[tmp]){
        int v=point[tmp];
        if(!size[v]){
            deep[v]=deep[now]+1;
            dfs(v,now);
            size[now]+=size[v];
            if(size[fatson[now]]<size[v]) fatson[now]=v;
        }
    }
}
void sign(int now,int ancestor){
    anc[now]=ancestor;
    in[now]=++cnt;
    rem[cnt]=now;
    if(fatson[now]) sign(fatson[now],ancestor);
    for(int tmp=head[now];tmp;tmp=nxt[tmp]){
        int v=point[tmp];
        if(!in[v]) sign(v,v);
    }
    out[now]=cnt;
}
int LCA(int x,int y){
    while(anc[x]!=anc[y]){
        if(deep[anc[x]]<deep[anc[y]]) swap(x,y);
        x=father[anc[x]];
    }
    if(deep[x]>deep[y]) swap(x,y);
    return x;
}
int work(int x){
    node *now=pool+x; int ans=0;
    while(now!=null){
        splay(now); now=now->pre;
        ans++;
    }
    return ans;
}
int TWO(int x,int y){return work(x)+work(y)-2*work(LCA(x,y))+1;}
int Three(int x){return secquery(1,1,cnt,in[x],out[x]);}
int main(){
    null=pool;
    null->pos=0;null->pre=null->ch[0]=null->ch[1]=null->maxlson=null;
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++) getnew(i);
    for(int i=1;i<n;i++){
        scanf("%d%d",&ui,&vi);
        addedge(ui,vi);
    }
    dfs(1,0);sign(1,1);build(1,1,cnt);
    for(int i=1;i<=m;i++){
        scanf("%d",&type);
        if(type==1){
            scanf("%d",&ui);
            node *now=pool+ui;
            access(now);
            continue;
        }
        if(type==2){
            scanf("%d%d",&ui,&vi);
            printf("%d\n",TWO(ui,vi));
            continue;
        }
        if(type==3){
            scanf("%d",&ui);
            printf("%d\n",Three(ui));
            continue;
        }
    }
    return 0;
}
```

---

## 作者：zrzring (赞：1)

[更好的阅读体验](http://zrzring.cn/index.php/archives/190)

1操作很容易联想到LCT的access，考虑对于剩下俩操作的维护，但其实对于树上点到根的路径权值具有可减性，于是维护这样一个距离，然后用树上差分回答2询问，因为一个点的子树在dfs序上是连续的一段，可以用线段树维护最大值回答3询问

这个题就成了3个板子的嵌套+巧妙的LCT，线段树和lca都是基础了不必再赘述

巧妙的LCT在于可以用这个题加深对access的理解，单独拿出access来说

```cpp
void access(int x) {
    for (int y = 0; x; y = x, x = fa[x]) {
        splay(x); rs = y; //pushup(x);
    }
}

void access(int x) {
    int c;
    for (int y = 0; x; y = x, x = fa[x]) {
        splay(x);
        if (rs) c = findrt(rs), SEG::change(1, 1, n, dfn[c], dfn[c] + siz[c] - 1, 1);
        if (rs = y) c = findrt(y), SEG::change(1, 1, n, dfn[c], dfn[c] + siz[c] - 1, -1);
    }
}
```

access实质是我们要对于x到根路径全部变成实边，我们要的是对于维护的信息进行修改

考虑性质，虚边有贡献，而实边没有贡献，在具体实现过程中，对于点x，遇到它的父亲到它为虚边则变实，然后整个子树到根节点的距离-1，然后把x的父亲原来连的实边的那个子树贡献+1，即可解决1操作

```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
#include <cstring>
#include <algorithm>
#include <queue>
#define q(x, y) SEG::query(1, 1, n, x, y)
#define inf 1e9
using namespace std;
void file() {
    freopen("read.in", "r", stdin);
    freopen("write.out", "w", stdout);
}
const int N = 1e6 + 10;
inline int read() {
    int sym = 0, res = 0; char ch = getchar();
    while (!isdigit(ch)) sym |= (ch == '-'), ch = getchar();
    while (isdigit(ch)) res = (res << 3) + (res << 1) + (ch ^ 48), ch = getchar();
    return sym ? -res : res;
}
struct EDGE {
    int u, v, nxt;
} edge[N];
int n, m, head[N], cnt, dfn[N], siz[N], depth[N], rev[N];
void add(int u, int v) {edge[++cnt] = (EDGE){u, v, head[u]}; head[u] = cnt;}
namespace SEG {
    int tmax[N], tag[N];
    #define ls x << 1
    #define rs x << 1 | 1
    void pushup(int x) {tmax[x] = max(tmax[ls], tmax[rs]);}
    void update(int x, int t) {tmax[x] += t; tag[x] += t;}
    void pushdown(int x, int l, int r, int mid) {
        if (tag[x]) {
            update(ls, tag[x]); update(rs, tag[x]); tag[x] = 0;
        }
    }
    void build(int x, int l, int r) {
        if (l == r) {tmax[x] = depth[rev[l]]; return;}
        int mid = l + r >> 1;
        build(ls, l, mid); build(rs, mid + 1, r);
        pushup(x);
    }
    void change(int x, int l, int r, int ln, int rn, int t) {
        if (ln <= l && r <= rn) {update(x, t); return;}
        int mid = l + r >> 1; pushdown(x, l, r, mid);
        if (mid >= ln) change(ls, l, mid, ln, rn, t);
        if (mid + 1 <= rn) change(rs, mid + 1, r, ln, rn, t);
        pushup(x);
    }
    int query(int x, int l, int r, int ln, int rn) {
        if (ln <= l && r <= rn) return tmax[x];
        int mid = l + r >> 1, res = 0; pushdown(x, l, r, mid);
        if (mid >= ln) res = max(res, query(ls, l, mid, ln, rn));
        if (mid + 1 <= rn) res = max(res, query(rs, mid + 1, r, ln, rn));
        return res;
    }
}
namespace LCT {
    int son[N][2], fa[N];
    #define ls son[x][0]
    #define rs son[x][1]
    bool l_r(int x) {return x == son[fa[x]][1];}
    bool isroot(int x) {return son[fa[x]][0] != x && son[fa[x]][1] != x;}
    int findrt(int x) {while (ls) x = ls; return x;}
    void rotate(int x) {
        int y = fa[x], z = fa[y], kind = l_r(x);
        if (!isroot(y)) son[z][l_r(y)] = x;
        son[y][kind] = son[x][kind ^ 1]; fa[son[x][kind ^ 1]] = y;
        son[x][kind ^ 1] = y; fa[y] = x; fa[x] = z;
    }
    void splay(int x) {
        for (int y = fa[x]; !isroot(x); y = fa[x]) {
            if (!isroot(y)) rotate(l_r(x) == l_r(y) ? y : x); rotate(x);
        }
    }
    void access(int x) {
        int c;
        for (int y = 0; x; y = x, x = fa[x]) {
            splay(x);
            if (rs) c = findrt(rs), SEG::change(1, 1, n, dfn[c], dfn[c] + siz[c] - 1, 1);
            if (rs = y) c = findrt(y), SEG::change(1, 1, n, dfn[c], dfn[c] + siz[c] - 1, -1);
        }
    }
}
namespace LCA {
    int top[N], son[N], fa[N];
    void dfs1(int u, int last) {
        depth[u] = depth[last] + 1; siz[u] = 1; fa[u] = last;
        for (int e = head[u]; e; e = edge[e].nxt) {
            int v = edge[e].v; if (v == last) continue; dfs1(v, u);
            siz[u] += siz[v]; if (siz[v] > siz[son[u]]) son[u] = v;
        }
    }
    void dfs2(int u, int front) {
        dfn[u] = ++cnt; rev[cnt] = u; top[u] = front; if (son[u]) dfs2(son[u], front);
        for (int e = head[u]; e; e = edge[e].nxt) {
            int v = edge[e].v; if (v == fa[u] || v == son[u]) continue; dfs2(v, v);
        }
    }
    int lca(int x, int y) {
        while (top[x] != top[y]) depth[top[x]] < depth[top[y]] ? y = fa[top[y]] : x = fa[top[x]];
        return depth[x] < depth[y] ? x : y;
    }
}
int main() {
    n = read(); m = read();
    for (int i = 1; i < n; i++) {
        int u = read(), v = read(); add(u, v); add(v, u);
    }
    cnt = 0; LCA::dfs1(1, 0); LCA::dfs2(1, 1); cnt = 0; SEG::build(1, 1, n);
    for (int i = 1; i <= n; i++) LCT::fa[i] = LCA::fa[i];
    for (int i = 1; i <= m; i++) {
        int opt = read(), x = read();
        if (opt == 1) LCT::access(x);
        if (opt == 2) {
            int y = read(), lca = LCA::lca(x, y);
            printf("%d\n", q(dfn[x], dfn[x]) + q(dfn[y], dfn[y]) - 2 * q(dfn[lca], dfn[lca]) + 1);
        }
        if (opt == 3) {
            printf("%d\n", q(dfn[x], dfn[x] + siz[x] - 1));
        }
    }
    return 0;
}
```

---

## 作者：hl666 (赞：1)

比较有趣的综合**树上问题**，刷**LCT**题单时做的但是发现后面LCT只是起了辅助作用233

首先我们分析每一个操作，$1$的定义就让我们联想到了```access```，我们回忆一下LCT的性质：

> LCT中每一个splay保存的都是原树上深度连续的一条链。

那么我们发现由于这里的染色是染上**全新**的一种颜色，所以每一次```access```后的每棵splay维护的都是**同种颜色**的点链，是同时符合性质和题目要求的

不过注意由于这里是染**新的颜色**，所以是可以用```access```的，如果是染成之前的某种颜色那么就不能这么做！

好了想完修改我们来考虑询问，首先看$2$操作，询问路径的颜色个数？

由于这是一棵**有根树**，结合前面的操作我们容易想到维护每个点到根节点的颜色个数记为$col_i$

容易发现这里的$col$具有**可减性**，那么维护路径颜色个数就可以用**树上差分**

具体的，路径$x,y$之间的颜色个数就是$col_x+col_y-2\cdot col_{\operatorname{LCA}(x,y)}+1$

这个和求树上两点间距离类似，不过就是$\operatorname{LCA}$的颜色会被减两次所以要加回去

然后就是$3$操作，我们发现当我们维护了$col$之后其实就是询问一个子树内最大的$col$

子树信息想到什么，**DFS序**啊！结合前面的```access```时进行的也是子树修改，我们容易想到维护**区间修改区间查最大值**的**线段树**，这样结合```access```的期望$\log$复杂度是$O(n\log^2n)$的（复杂度分析类似于LCT上的平衡树操作）

那么就代码实现方面，DFS序都要写了，那么顺带写一下**树剖**吧，一般跳的比倍增快一些

然后就是码农时刻了，建议把代码分块一下要不然很容易调死不出

奉上近$200$行的CODE

```cpp
#include<cstdio>
#include<cctype>
#define RI register int
#define CI const int&
#define Tp template <typename T>
using namespace std;
const int N=100005;
struct edge
{
    int to,nxt;
}e[N<<1]; int n,m,head[N],cnt,opt,x,y,fa,id[N],dep[N],dfn[N],size[N];
class FileInputOutput
{
    private:
        static const int S=1<<21;
        #define tc() (A==B&&(B=(A=Fin)+fread(Fin,1,S,stdin),A==B)?EOF:*A++)
        #define pc(ch) (Ftop<S?Fout[Ftop++]=ch:(fwrite(Fout,1,S,stdout),Fout[(Ftop=0)++]=ch))
        char Fin[S],Fout[S],*A,*B; int pt[15],Ftop;
    public:
        Tp inline void read(T& x)
        {
            x=0; char ch; while (!isdigit(ch=tc()));
            while (x=(x<<3)+(x<<1)+(ch&15),isdigit(ch=tc()));
        }
        Tp inline void write(T x)
        {
            if (!x) return (void)(pc('0'),pc('\n')); RI ptop=0;
            while (x) pt[++ptop]=x%10,x/=10; while (ptop) pc(pt[ptop--]+48); pc('\n');
        }
        inline void Fend(void)
        {
            fwrite(Fout,1,Ftop,stdout);
        }
        #undef tc
        #undef pc
}F;
class Segment_Tree
{
    private:
        struct Segment
        {
            int mx,tag;
        }node[N<<2];
        #define M(x) node[x].mx
        #define T(x) node[x].tag
        inline int max(CI a,CI b)
        {
            return a>b?a:b;
        }
        inline void add(CI now,CI mv)
        {
            M(now)+=mv; T(now)+=mv;
        }
        inline void pushup(CI now)
        {
            M(now)=max(M(now<<1),M(now<<1|1));
        }
        inline void pushdown(CI now)
        {
            if (T(now)) add(now<<1,T(now)),add(now<<1|1,T(now)),T(now)=0;
        }
    public:
        #define TN CI now=1,CI l=1,CI r=n
        inline void build(TN)
        {
            if (l==r) return (void)(M(now)=dep[id[l]]); int mid=l+r>>1;
            build(now<<1,l,mid); build(now<<1|1,mid+1,r); pushup(now);
        }
        #define O beg,end
        inline void modify(CI beg,CI end,CI mv,TN)
        {
            if (beg<=l&&r<=end) return add(now,mv); int mid=l+r>>1; pushdown(now);
            if (beg<=mid) modify(O,mv,now<<1,l,mid); if (end>mid) modify(O,mv,now<<1|1,mid+1,r); pushup(now);
        }
        inline int query(CI beg,CI end,TN)
        {
            if (beg<=l&&r<=end) return M(now); int mid=l+r>>1,ret=0; pushdown(now);
            if (beg<=mid) ret=max(ret,query(O,now<<1,l,mid)); if (end>mid) ret=max(ret,query(O,now<<1|1,mid+1,r)); return ret;
        }
        #undef TN
        #undef O
        #undef M
        #undef T
}T;
class Link_Cut_Tree
{
    private:
        struct splay
        {
            int ch[2],fa;
        }node[N];
        #define lc(x) node[x].ch[0]
        #define rc(x) node[x].ch[1]
        #define fa(x) node[x].fa
        inline void connect(CI x,CI y,CI d)
        {
            node[fa(x)=y].ch[d]=x;
        }
        inline int identify(CI now)
        {
            return rc(fa(now))==now;
        }
        inline bool isroot(CI now)
        {
            return lc(fa(now))!=now&&rc(fa(now))!=now;
        }
        inline void rotate(CI now)
        {
            int x=fa(now),y=fa(x),d=identify(now); if (!isroot(x)) node[y].ch[identify(x)]=now;
            fa(now)=y; connect(node[now].ch[d^1],x,d); connect(x,now,d^1);
        }
        inline void splay(int now)
        {
            for (int t;!isroot(now);rotate(now))
            t=fa(now),!isroot(t)&&(rotate(identify(now)!=identify(t)?now:t),0);
        }
        inline int findroot(int now)
        {
            while (lc(now)) now=lc(now); return now;
        }
    public:
        inline void link(CI x,CI y)
        {
            fa(x)=y;
        }
        inline void access(int x)
        {
            for (int y=0,t;x;x=fa(y=x))
            {
                splay(x); if (rc(x)) t=findroot(rc(x)),T.modify(dfn[t],dfn[t]+size[t]-1,1);
                if (rc(x)=y) t=findroot(rc(x)),T.modify(dfn[t],dfn[t]+size[t]-1,-1);
            }
        }
        #undef lc
        #undef rc
        #undef fa
}LCT;
class Light_Heavy_Division
{
    private:
        int idx,top[N],father[N],son[N];
        inline void swap(int& x,int& y)
        {
            int t=x; x=y; y=t;
        }
    public:
        #define to e[i].to
        inline void DFS1(CI now,CI fa)
        {
            size[now]=1; dep[now]=dep[fa]+1; father[now]=fa;
            for (RI i=head[now];i;i=e[i].nxt) if (to!=fa)
            {
                DFS1(to,now); size[now]+=size[to]; LCT.link(to,now);
                if (size[to]>size[son[now]]) son[now]=to;
            }
        }
        inline void DFS2(CI now,CI tf)
        {
            id[dfn[now]=++idx]=now; top[now]=tf;
            if (son[now]) DFS2(son[now],tf);
            for (RI i=head[now];i;i=e[i].nxt)
            if (to!=father[now]&&to!=son[now]) DFS2(to,to);
        }
        inline int get_LCA(int x,int y)
        {
            while (top[x]!=top[y])
            {
                if (dep[top[x]]<dep[top[y]]) swap(x,y);
                x=father[top[x]];
            }
            return dep[x]<dep[y]?x:y;
        }
        #undef to
}L;
inline void add(CI x,CI y)
{
    e[++cnt]=(edge){y,head[x]}; head[x]=cnt;
}
int main()
{
    //freopen("CODE.in","r",stdin); freopen("CODE.out","w",stdout);
    RI i; for (F.read(n),F.read(m),i=1;i<n;++i) F.read(x),F.read(y),add(x,y),add(y,x);
    for (L.DFS1(1,0),L.DFS2(1,1),T.build(),i=1;i<=m;++i)
    {
        F.read(opt); F.read(x); switch (opt)
        {
            case 1:
                LCT.access(x); break;
            case 2:
                F.read(y); fa=L.get_LCA(x,y);
                F.write(T.query(dfn[x],dfn[x])+T.query(dfn[y],dfn[y])-
                (T.query(dfn[fa],dfn[fa])<<1)+1); break;
            case 3:
                F.write(T.query(dfn[x],dfn[x]+size[x]-1)); break;
        }
    }
    return F.Fend(),0;
}
```



---

## 作者：何俞均 (赞：1)

广告：食用[$blog$](https://www.cnblogs.com/heyujun/p/10360047.html )体验更佳

> 一次只能染根到$x$，且染的颜色未出现过

这句话是我们解题的关键。

设$x$到根的颜色数为$f(x)$，则$u$到$v$的颜色数：$f(u)+f(v)-f(lca_{u,v})+1$

~~想一想，为什么？~~

很显然，如果没有$1$操作，我们直接树剖维护一下就可以了。

但是现在有了$1$操作。。。

这个$1$操作，其实是拉一条从$x$到根的链，染成一种颜色

这是不是很像$LCT$的$access$呢？

这样的话，我们就搞一颗$LCT$，$access$时，

因为每断一颗子树，那棵子树内必然要多加一个颜色段就是一个子树加，

每连上一颗子树，那棵子树内必然重复一个颜色段就是一个子树减。

那么我们用树剖维护每个点的$f(x)$

并魔改一下$access$即可

代码：

```cpp
#include <iostream> 
#include <cstdio> 
#include <cstdlib> 
#include <cstring> 
#include <cmath> 
#include <algorithm> 
using namespace std; 
inline int gi() { 
    register int data = 0, w = 1; 
    register char ch = 0; 
    while (!isdigit(ch) && ch != '-') ch = getchar(); 
    if (ch == '-') w = -1, ch = getchar(); 
    while (isdigit(ch)) data = 10 * data + ch - '0', ch = getchar(); 
    return w * data; 
} 
const int MAX_N = 1e5 + 5; 
struct Graph { int to, next; } e[MAX_N << 1]; int fir[MAX_N], e_cnt; 
void clearGraph() { memset(fir, -1, sizeof(fir)); e_cnt = 0; } 
void Add_Edge(int u, int v) { e[e_cnt] = (Graph){v, fir[u]}, fir[u] = e_cnt++; } 
int N, M; 
int dfn[MAX_N], L[MAX_N], R[MAX_N], top[MAX_N]; 
int dep[MAX_N], fa[MAX_N], son[MAX_N], size[MAX_N], tim; 
void dfs1(int x) { 
	dep[x] = dep[fa[x]] + 1, size[x] = 1; 
	for (int i = fir[x]; ~i; i = e[i].next) { 
		int v = e[i].to; if (v == fa[x]) continue; 
		fa[v] = x; dfs1(v); size[x] += size[v]; 
		if (size[son[x]] < size[v]) son[x] = v; 
	} 
} 
void dfs2(int x, int tp) { 
	top[x] = tp, L[x] = ++tim, dfn[tim] = x; 
	if (son[x]) dfs2(son[x], tp); 
	for (int i = fir[x]; ~i; i = e[i].next) { 
		int v = e[i].to; if (v == fa[x] || v == son[x]) continue; 
		dfs2(v, v); 
	} 
	R[x] = tim; 
}
int LCA(int x, int y) {
	while (top[x] != top[y]) { 
		if (dep[top[x]] < dep[top[y]]) swap(x, y); 
		x = fa[top[x]]; 
	} 
	return dep[x] < dep[y] ? x : y; 
} 
#define lson (o << 1) 
#define rson (o << 1 | 1) 
int val[MAX_N << 2], tag[MAX_N << 2];
void pushup(int o) { val[o] = max(val[lson], val[rson]); } 
void puttag(int o, int v) { tag[o] += v; val[o] += v; } 
void pushdown(int o, int l, int r) {
	if (l == r || !tag[o]) return ; 
	puttag(lson, tag[o]); 
	puttag(rson, tag[o]); 
	tag[o] = 0; 
} 
void build(int o, int l, int r) { 
	if (l == r) return (void)(val[o] = dep[dfn[l]]); 
	int mid = (l + r) >> 1; 
	build(lson, l, mid), build(rson, mid + 1, r); 
	pushup(o); 
} 
void modify(int o, int l, int r, int ql, int qr, int v) {  
	if (ql <= l && r <= qr) return (void)(puttag(o, v)); 
	pushdown(o, l, r); 
	int mid = (l + r) >> 1; 
	if (ql <= mid) modify(lson, l, mid, ql, qr, v);
	if (qr > mid) modify(rson, mid + 1, r, ql, qr, v); 
	pushup(o); 
} 
int query(int o, int l, int r, int ql, int qr) { 
	pushdown(o, l, r); 
	if (ql <= l && r <= qr) return val[o]; 
	int mid = (l + r) >> 1, res = 0; 
	if (ql <= mid) res = max(res, query(lson, l, mid, ql, qr)); 
	if (qr > mid) res = max(res, query(rson, mid + 1, r, ql, qr));
	return res; 
} 

struct Node { int ch[2], fa; bool rev; } t[MAX_N]; 
bool get(int x) { return t[t[x].fa].ch[1] == x; } 
bool nroot(int x) { return t[t[x].fa].ch[0] == x || t[t[x].fa].ch[1] == x; } 
void rotate(int x) { 
	int y = t[x].fa, z = t[y].fa, k = get(x); 
	if (nroot(y)) t[z].ch[get(y)] = x; 
	t[x].fa = z; 
	t[t[x].ch[k ^ 1]].fa = y, t[y].ch[k] = t[x].ch[k ^ 1]; 
	t[y].fa = x, t[x].ch[k ^ 1] = y; 
} 
void splay(int x) { 
	while (nroot(x)) { 
		int y = t[x].fa; 
		if (nroot(y)) get(x) ^ get(y) ? rotate(x) : rotate(y);
		rotate(x); 
	} 
} 
int findroot(int x) { while (t[x].ch[0]) x = t[x].ch[0]; return x; } 
void access(int x) { 
	for (int y = 0; x; y = x, x = t[x].fa) { 
		splay(x); 
		if (t[x].ch[1]) {
			int rt = findroot(t[x].ch[1]);
			modify(1, 1, N, L[rt], R[rt], 1); 
		}
		t[x].ch[1] = y; 
		if (t[x].ch[1]) {
			int rt = findroot(t[x].ch[1]); 
			modify(1, 1, N, L[rt], R[rt], -1); 
		} 
	} 
} 

int main () { 
	clearGraph(); 
	N = gi(), M = gi(); 
	for (int i = 1; i < N; i++) {
		int u = gi(), v = gi(); 
		Add_Edge(u, v); 
		Add_Edge(v, u); 
	} 
	dfs1(1), dfs2(1, 1); 
	for (int x = 2; x <= N; x++) t[x].fa = fa[x]; 
	build(1, 1, N);
	
	while (M--) { 
		int op = gi(); 
		if (op == 1) access(gi()); 
		if (op == 2) {
			int u = gi(), v = gi(), lca = LCA(u, v); 
			printf("%d\n", query(1, 1, N, L[u], L[u]) + query(1, 1, N, L[v], L[v]) 
				- 2 * query(1, 1, N, L[lca], L[lca]) + 1); 
		} 
		if (op == 3) {
			int x = gi(); 
			printf("%d\n", query(1, 1, N, L[x], R[x])); 
		} 
	} 
	return 0; 
} 
```

---

## 作者：Dispwnl (赞：1)

恶心题~~为什么SD光出这种题~~。。。

总的来说就是LCT+树链剖分+树上差分

先不管操作1

对于操作2，考虑树上差分，设s[i]为i点到根的权值和，则答案就是s[x]+s[y]-s[lca(x,y)]*2+1（多减了1个lca所以+1）

那么每个点的初始值就是ta的深度（因为开始每个点颜色都不一样）

发现上面的关系可以用树链剖分来解决

求出lca后单点查询x，y，lca的权值就可以解决操作2

操作3求子树最大值也是树链剖分的基本操作

主要问题是操作1

操作1就很妙了，利用了一个性质：（以下注意链和边的区分）

**LCT中实链数量（即splay的数量）=虚边数量+1**

我们把同一颜色的点放在1个splay里

由操作可得，LCT中点i到根节点有多少实链s[i]就是多少

所以access将几个splay连成1个splay，正好对应着用同一种颜色覆盖路径

然后access的时候如果一条边由虚变实（即虚边减少），这条边连的深度较大的点的子树每个点的s-1

如果一条边由实变虚（即虚边增加），这条边连的深度较大的点的子树每个点的s+1

如图：

![](https://cdn.luogu.com.cn/upload/pic/15866.png)

设6号点为根，图中红色虚边要变成实边，深度较大的节点是5（4号红边怎么变跟ta没关系）

5点的相连的**实链**合并了，但到根节点的实链总数没变，所以对应的s不变

1、2、3点到根的实链合并了，到根节点的实链总数-1，所以对应的s-1

实变虚同理~~自己yy即可~~

所以access时要加上树链剖分的区间修改操作

还有LCT中要保存当前节点在树中最左儿子的编号用以修改区间（即代码中LCT的w[i]）

于是这道~~毒瘤+码农~~题就解决了
```
# include<iostream>
# include<cstring>
# include<cstdio>
# include<cstdlib>
# define mid (l+r>>1)
# define tl (k<<1)
# define tr (k<<1|1)
using namespace std;
const int MAX=1e5+1;
struct p{
    int x,y;
}c[MAX<<1];
int n,m,num,cnt,tot,rt;
int h[MAX],ID[MAX],top[MAX],d[MAX],fa[MAX],son[MAX],siz[MAX];
struct Segment_Tree{
    struct q{
        int x,lazy;
    }s[MAX<<2];
    void pus(int k)
    {
        s[k].x=max(s[tl].x,s[tr].x);
    }
    void down(int k)
    {
        int f=s[k].lazy;
        s[k].lazy=0;
        if(!f) return;
        s[tl].lazy+=f,s[tr].lazy+=f;
        s[tl].x+=f,s[tr].x+=f;
    }
    void change(int l,int r,int k,int L,int R,int dis)
    {
        if(l==L&&r==R)
        {
            s[k].x+=dis,s[k].lazy+=dis;
            return;
        }
        down(k);
        if(R<=mid) change(l,mid,tl,L,R,dis);
        else if(L>mid) change(mid+1,r,tr,L,R,dis);
        else
        {
            change(l,mid,tl,L,mid,dis);
            change(mid+1,r,tr,mid+1,R,dis);
        }
        pus(k);
    }
    void change1(int l,int r,int k,int x,int dis)
    {
        if(l==r)
        {
            s[k].x+=dis;
            return;
        }
        down(k);
        if(x<=mid) change1(l,mid,tl,x,dis);
        else change1(mid+1,r,tr,x,dis);
        pus(k);
    }
    int ask(int l,int r,int k,int L,int R)
    {
        if(l==L&&r==R)
        return s[k].x;
        down(k);
        if(R<=mid) return ask(l,mid,tl,L,R);
        else if(L>mid) return ask(mid+1,r,tr,L,R);
        else return max(ask(l,mid,tl,L,mid),ask(mid+1,r,tr,mid+1,R));
    }
    int ask1(int l,int r,int k,int x)
    {
        if(l==r) return s[k].x;
        down(k);
        if(x<=mid) return ask1(l,mid,tl,x);
        else return ask1(mid+1,r,tr,x);
    }
}Tree1;
struct Link_Cut_Tree{
    int fa[MAX],w[MAX];
    int son[MAX][2];
    bool fl[MAX];
    bool is_root(int x)
    {
        return son[fa[x]][1]!=x&&son[fa[x]][0]!=x;
    }
    bool id(int x)
    {
        return son[fa[x]][0]==x?0:1;
    }
    void pus(int x)
    {
        if(son[x][0]) w[x]=w[son[x][0]]; 
        else w[x]=x;
    }
    void down(int x)
    {
        if(x&&fl[x])
        {
            if(son[x][1]) fl[son[x][1]]^=1;
            if(son[x][0]) fl[son[x][0]]^=1;
            swap(son[x][1],son[x][0]);
            fl[x]=0;
        }
    }
    void rot(int x)
    {
        int y=fa[x],z=fa[y],k=id(x);
        if(!is_root(y)) son[z][id(y)]=x;
        son[y][k]=son[x][k^1],fa[son[y][k]]=y;
        son[x][k^1]=y,fa[y]=x;
        fa[x]=z;
        pus(y),pus(x);
    }
    void PUS(int x)
    {
        if(!is_root(x)) PUS(fa[x]);
        down(x);
    }
    void splay(int x)
    {
        PUS(x);
        for(int y;!is_root(x);rot(x))
          if(!is_root(y=fa[x]))
          rot(id(x)==id(y)?y:x);
    }
    void access(int x)
    {
        for(int y=0;x;y=x,x=fa[x])
          {
          	splay(x);
          	int hh=w[son[x][1]];
          	if(son[x][1]) Tree1.change(1,n,1,ID[hh],ID[hh]+siz[hh]-1,1);
          	hh=w[y];
            if(y) Tree1.change(1,n,1,ID[hh],ID[hh]+siz[hh]-1,-1);
            son[x][1]=y;
            if(y) fa[y]=x;
          }
    }
}Tree2;
void add(int x,int y)
{
    c[++num]=(p){h[x],y};h[x]=num;
    c[++num]=(p){h[y],x},h[y]=num;
}
void dfs(int x,int f)
{
    fa[x]=f,d[x]=d[f]+1,siz[x]=1;
    for(int i=h[x];i;i=c[i].x)
      {
      	int y=c[i].y;
      	if(y==f) continue;
      	dfs(y,x);
      	siz[x]+=siz[y];
        if(siz[y]>siz[son[x]]) son[x]=y;
      }
}
void dfs1(int x,int tp)
{
    top[x]=tp,ID[x]=++cnt;
    if(son[x]) dfs1(son[x],tp);
    else return;
    for(int i=h[x];i;i=c[i].x)
      {
      	int y=c[i].y;
      	if(y==fa[x]||y==son[x]) continue;
      	dfs1(y,y);
      }
}
int LCA(int x,int y)
{
    while(top[x]!=top[y])
    {
        if(d[top[x]]<d[top[y]]) swap(x,y);
        x=fa[top[x]];
    }
    if(d[x]>d[y]) swap(x,y);
    return x;
}
int read()
{
    int x=0,f=1;
    char ch=getchar();
    for(;!isdigit(ch);f=(ch=='-')?-1:1,ch=getchar());
    for(;isdigit(ch);x=x*10+ch-48,ch=getchar());
    return x*f;
}
int main()
{
    n=read(),m=read();
    for(int i=1;i<n;i++)
      {
      	int x=read(),y=read();
      	add(x,y);
      }
    dfs(1,0);
    dfs1(1,1);
    for(int i=1;i<=n;i++)
      {
      	Tree1.change1(1,n,1,ID[i],d[i]);
      	Tree2.w[i]=i,Tree2.fa[i]=fa[i];
      }
    for(int i=1;i<=m;i++)
      {
      	int op=read(),x,y;
      	if(op==1)
        Tree2.access(read());
        else if(op==2)
        {
            x=read(),y=read();
            int lca=LCA(x,y);
            int s1=Tree1.ask1(1,n,1,ID[x]),s2=Tree1.ask1(1,n,1,ID[y]),s3=Tree1.ask1(1,n,1,ID[lca]);
            printf("%d\n",s1+s2-s3*2+1);
        }
        else if(op==3)
        {
            x=read();
            printf("%d\n",Tree1.ask(1,n,1,ID[x],ID[x]+siz[x]-1));
        }
      }
    return 0;
}
```
最后安利一下[博客](https://a-failure.github.io/2018/03/19/SDOI2017-%E6%A0%91%E7%82%B9%E6%B6%82%E8%89%B2/)

---

## 作者：斯德哥尔摩 (赞：1)

没有人用宏定义+namespace封装吗？来一发。。。

看到题目第一想法：树剖。

但是1操作要改一颗子树，还要分 在链上 与 不在链上 两种，可能还有树上分治什么乱七八糟的玩意，时间+空间+思考+代码 复杂度均不能接受。。。

正解：Link-Cut-Tree。。。

先构出原树的虚树LCT，并用树剖维护每个点到根节点的路径权值data，那么每个点到根节点的路径权值 data 就是每个点到根节点的路径上 实链 的个数。

于是1操作就变成了access：

如果一条实边变成虚边，那么将连接这条边的深度较大的节点的子树里所有点的 data 加 1 （因为实链数量就等于虚边数量+1 ）;

如果一条虚边变成实边，那么将连接这条边的深度较大的节点的子树里所有点的 data 减1 。

因为没有加删边，故2、3操作还是用 树剖+线段树 维护。

2操作：ans=data[ x ] + data[ y ] - data[ LCA(x,y) ] * 2 + 1

3操作：query_max( id[x] , id[x] + size[x] - 1 )

代码中为了防止 线段树 与 LCT 混淆，用了 namespace 封装。

附上代码：

```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#define MAXN 100010
using namespace std;
int n,m,c=1,d=1;
int head[MAXN],deep[MAXN],son[MAXN],size[MAXN],fa[MAXN],id[MAXN],top[MAXN];
struct node1{//前向星没话说
    int next,to;
}a[MAXN<<1];
namespace ST{
    #define LSON rt<<1//个人习惯线段树中用宏定义，程序清晰。。。
    #define RSON rt<<1|1
    #define DATA(x) a[x].data
    #define SIGN(x) a[x].c
    #define LSIDE(x) a[x].l
    #define RSIDE(x) a[x].r
    struct Sg_Tree{//线段树没话说
        int data,c,l,r;
    }a[MAXN<<2];
    inline void pushup(int rt){//上传
        DATA(rt)=max(DATA(LSON),DATA(RSON));
    }
    inline void pushdown(int rt){//标记下传
        if(!SIGN(rt)||LSIDE(rt)==RSIDE(rt))return;
        SIGN(LSON)+=SIGN(rt);DATA(LSON)+=SIGN(rt);
        SIGN(RSON)+=SIGN(rt);DATA(RSON)+=SIGN(rt);
        SIGN(rt)=0;
    }
    void buildtree(int l,int r,int rt){//建树
        int mid;
        LSIDE(rt)=l;
        RSIDE(rt)=r;
        if(l==r){
            DATA(rt)=0;//记得赋0
            return;
        }
        mid=l+r>>1;
        buildtree(l,mid,LSON);
        buildtree(mid+1,r,RSON);
        pushup(rt);
    }
    void update(int l,int r,int c,int rt){//修改
        int mid;
        if(l<=LSIDE(rt)&&RSIDE(rt)<=r){
            SIGN(rt)+=c;DATA(rt)+=c;
            return;
        }
        pushdown(rt);
        mid=LSIDE(rt)+RSIDE(rt)>>1;
        if(l<=mid)update(l,r,c,LSON);
        if(mid<r)update(l,r,c,RSON);
        pushup(rt);
    }
    int query(int l,int r,int rt){//求最大值
        int mid,ans=0;
        if(l<=LSIDE(rt)&&RSIDE(rt)<=r)return DATA(rt);
        pushdown(rt);
        mid=LSIDE(rt)+RSIDE(rt)>>1;
        if(l<=mid)ans=max(ans,query(l,r,LSON));
        if(mid<r)ans=max(ans,query(l,r,RSON));
        return ans;
    }
}
namespace LCT{
    int stack[MAXN];
    struct Link_Cut_Tree{//LCT没话说
        int son[2];
        int f,s,flag;
    }a[MAXN];
    inline bool isroot(int rt){//判根
        return a[a[rt].f].son[0]!=rt&&a[a[rt].f].son[1]!=rt;
    }
    inline void pushup(int rt){//上传
        if(!rt)return;
        if(a[rt].son[0])a[rt].s=a[a[rt].son[0]].s;
        else a[rt].s=rt;
    }
    inline void pushdown(int rt){//下传
        if(!rt||!a[rt].flag)return;
        a[a[rt].son[0]].flag^=1;a[a[rt].son[1]].flag^=1;a[rt].flag^=1;
        swap(a[rt].son[0],a[rt].son[1]);
    }
    inline void turn(int rt){//旋转
        int x=a[rt].f,y=a[x].f,k=a[x].son[0]==rt?1:0;
        if(!isroot(x)){
            if(a[y].son[0]==x)a[y].son[0]=rt;
            else a[y].son[1]=rt;
        }
        a[rt].f=y;a[x].f=rt;a[a[rt].son[k]].f=x;
        a[x].son[k^1]=a[rt].son[k];a[rt].son[k]=x;
        pushup(x);pushup(rt);
    }
    void splay(int rt){//伸展
        int top=0;
        stack[++top]=rt;
        for(int i=rt;!isroot(i);i=a[i].f)stack[++top]=a[i].f;
        while(top)pushdown(stack[top--]);
        while(!isroot(rt)){
            int x=a[rt].f,y=a[x].f;
            if(!isroot(x)){
                if((a[y].son[0]==x)^(a[x].son[0]==rt))turn(rt);
                else turn(x);
            }
            turn(rt);
        }
    }
    void access(int x){//操作1
        for(int i=0;x;i=x,x=a[x].f){
            splay(x);
            if(a[x].son[1])ST::update(id[a[a[x].son[1]].s],id[a[a[x].son[1]].s]+size[a[a[x].son[1]].s]-1,1,1);
            if(i)ST::update(id[a[i].s],id[a[i].s]+size[a[i].s]-1,-1,1);
            a[x].son[1]=i;
            if(i)a[i].f=x;
        }
    }
}
inline int read(){//读优
	int date=0,w=1;char c=0;
	while(c<'0'||c>'9'){if(c=='-')w=-1;c=getchar();}
	while(c>='0'&&c<='9'){date=date*10+c-'0';c=getchar();}
	return date*w;
}
inline void add(int x,int y){//加边
    a[c].to=y;a[c].next=head[x];head[x]=c++;
    a[c].to=x;a[c].next=head[y];head[y]=c++;
}
void dfs1(int rt){//树剖dfs1
    son[rt]=0;size[rt]=1;
    for(int i=head[rt];i;i=a[i].next){
        int will=a[i].to;
        if(!deep[will]){
            deep[will]=deep[rt]+1;
            fa[will]=rt;
            dfs1(will);
            size[rt]+=size[will];
            if(size[son[rt]]<size[will])son[rt]=will;
        }
    }
}
void dfs2(int rt,int f){//树剖dfs2
    id[rt]=d++;top[rt]=f;
    if(son[rt])dfs2(son[rt],f);
    for(int i=head[rt];i;i=a[i].next){
        int will=a[i].to;
        if(will!=fa[rt]&&will!=son[rt])
        dfs2(will,will);
    }
}
int LCA(int x,int y){//树剖求LCA
    while(top[x]!=top[y]){
        if(deep[top[x]]<deep[top[y]])swap(x,y);
        x=fa[top[x]];
    }
    if(deep[x]>deep[y])swap(x,y);
    return x;
}
void work(){//工作
    int f,x,y;
    while(m--){
        f=read();x=read();
        if(f==1)LCT::access(x);
        if(f==2){
            y=read();
            int fa=LCA(x,y);
            printf("%d\n",(ST::query(id[x],id[x],1)+ST::query(id[y],id[y],1)-ST::query(id[fa],id[fa],1)*2+1));
        }
        if(f==3)printf("%d\n",ST::query(id[x],id[x]+size[x]-1,1));
    }
}
void init(){//读入+预处理
    int x,y;
    n=read();m=read();
    for(int i=1;i<n;i++){
        x=read();y=read();
        add(x,y);
    }
    deep[1]=1;
    dfs1(1);
    dfs2(1,1);
    ST::buildtree(1,n,1);
    for(int i=1;i<=n;i++){
        ST::update(id[i],id[i],deep[i],1);
        LCT::a[i].s=i;
        LCT::a[i].f=fa[i];//记得这两句：建虚树
    }
}
int main(){//主函数So easy!
    init();
    work();
	return 0;
}

```

---


# [HAOI2017] 八纵八横

## 题目描述

Anihc 国有 $n$ 个城市，这 $n$ 个城市从 $1$ 到 $n$ 编号，$1$ 号城市为首都。城市间初始时有 $m$ 条高速公路，每条高速公路都有一个非负整数的经济影响因子，每条高速公路的两端都是城市（可能两端是同一个城市），保证任意两个城市都可以通过高速公路互达。

国正在筹划“八纵八横”的高铁建设计划，计划要修建一些高速铁路，每条高速铁路两端也都是城市（可能两端是同一个城市)，也都有一个非负整数的经济影响因子。国家还计划在“八纵八横”计划建成之后，将“一带一路”扩展为“一带一路一环”，增加“内陆城市经济环”即选择一条从首都出发沿若一系列高铁与高速公路走的路径，每条高铁或高速公路可以经过多次，每座城市也可以经过多次，最后路径又在首都结束。令“内陆城市经济环”的 GDP 为依次将这条路径上所经过的高铁或高速公路的经济影响因子异或起来（一条路经过多次则会被计算多次）。

现在 Anihc 在会议上讨论“八纵八横”的建设计划方案，他们会不断地修改计划方案，希望你能实时反馈对于当前的“八纵八横”的建设计划的方案“内陆城市经济环”的最大是多少。

初始时，八纵八横计划中不包含任何一条高铁，有以下 $3$ 种操作：

`Add x y z`

在计划中给在城市 $x$ 和城市 $y$ 之间建设一条高铁，其经济影响因子为 $z$，如果这是第 $k$ 个 `Add` 操作，则将这条高铁命名为 $k$ 号高铁。

`Cancel k`

将计划中的 $k$ 号高铁取消掉，保证此时 $k$ 号高铁一定存在。

`Change k z`

表示将第 $k$ 号高铁的经济影响因子更改为 $z$，保证此时 $k$ 号高铁一定存在。


## 说明/提示

### 数据规模与约定

令所有的经济因子二进制表示的最多位数为 $len$。数据满足以下表格：

| 数据点 | $n$ | $m$ | $Q$ | $len$ | 特殊性质 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| 1 | $\leq 5$ | $\leq 8$ | $0$ | $\leq 31$ |  |
| 2 | $\leq 100$ | $=n + 1$ | $0$ | $\leq 100$ |  |
| 3 | $\leq 100$ | $\leq 100$ | $0$ | $\leq 100$ |  |
| 4 | $\leq 500$ | $\leq 500$ | $0$ | $\leq 1000$ |  |
| 5 |$\leq 100$ | $\leq 100$ | $\leq 100$ | $\leq 200$ | 只存在 `Add` 操作 |
| 6 | $\leq 500$ | $\leq 500$ | $\leq 200$ | $\leq 1000$ |  |
| 7 | $\leq 100$ | $\leq 100$ | $\leq 1000$ | $\leq 200$ |  |
| 8 | $\leq 500$ | $\leq 500$ | $\leq 1000$ | $\leq 1000$ |  |
| 9 | $\leq 500$ | $\leq 500$ | $\leq 1000$ | $\leq 1000$ |  |
| 10 | $\leq 500$ | $\leq 500$ | $\leq 1000$ | $\leq 1000$ |  |

对于所有的数据保证：$1\leq n,m\leq 500$，$0\leq Q\leq 1000$，$1\leq len\leq 1000$，$1\leq x,y\leq n$。且 `Add` 操作不超过 $550$ 个。两个城市之间可能有多条高速公路或高铁，高速公路或高铁的两端可能是同一个城市（即：有重边，有自环）。


## 样例 #1

### 输入

```
4 4 3
1 2 1110
1 3 10
2 4 1110
2 3 100
Add 3 4 11
Change 1 101
Cancel 1```

### 输出

```
1000
1001
1111
1000```

# 题解

## 作者：xtx1092515503 (赞：30)

~~为什么大家写的都是线段树分治的呀，就没人写可删除线性基的吗，这可是少一个$\log$呢~~

首先，先介绍一下如何写可删除线性基。

不知道大家有没有用过LCT维护过动态图联通性呢？如果**可以离线**的话，我们可以在LCT上维护**关于删除时间的最大生成树**。当新加入一条边后，树上肯定成环，则只需要删掉环上删除时间最早的那条边即可。

~~没听懂没关系，反正这题也不用LCT，举这个例子只是类比一下而已~~

书归正传。如果我们要写可删除线性基的话，借鉴上面的思想，我们肯定希望在线性基中维护删除时间最晚的元素。

我们设$d_i$表示线性基中第$i$位的元素，$tms_i$表示该元素将在何时被删去。

按照贪心的思想，我们肯定希望**越高位的线性基越晚删除**——不然如果你到了时间，下面的能选而上面不能选，不是会令答案变小吗？

因此我们可以从上到下枚举每一位，能换就换，之后继续向下尝试替换。

这是尝试插入一个删除时间为$now$，值为$x$的一个```bitset```的代码：

```cpp
void ins(int now,bi x){
//	print(x);
	for(int i=1000;i>=0;i--){
		if(!x[i])continue;
		if(tms[i]<now)swap(tms[i],now),swap(x,d[i]);
		if(!now)break;
		x^=d[i];
	}
}
```
有了插入代码，自然会有查询代码，查询$now$时刻的答案：

```cpp
void ask(int now){
	bi res;
	for(int i=1000;i>=0;i--)if(tms[i]>now&&!res[i])res^=d[i];
	print(res);
}
```
这两者的复杂度都是$O(\dfrac{len^2}{w})$的，其中$len$是$01$串长度，而$w$是```bitset```常数。

------------

那么这可删除线性基在本题中有什么应用呢？

不知道大家有没有做过[[WC2011]最大XOR和路径](https://www.luogu.com.cn/problem/P4151)啊，如果做过，就应该能看出来，任意一条从首都出发再回到首都的路径，$\operatorname{xor}$值能做出贡献的，只有**环上的边**，路径上的边因为来时异或一次走时再来一次，所以异或值就被消掉了。

因此我们仍然可以借鉴那题的思想，将所有的环搜出来扔进线性基中，找到线性基中的最大值即可。只需要**保证每条边都会被包括在某个环中**即可——线性基中进行的是异或过程，自然会保留出最优的一组解，不需要的边自然会被异或两次然后抵消掉。

我们可以设$dis_x$为$x$节点到一号节点的**任意一条路径**的异或值。则当我们插入一条边$x,y,z$时，只需要往线性基中加入$dis_x\operatorname{xor}dis_y\operatorname{xor}z$即可。

当然，这个操作是要**离线**下来的——不然你怎么知道新加入的边会在啥时候被删掉呢？

至于修改——你把它变成一次删除，一次加边即可。

------------

当然，这里还可以给出一种**在线做法**（只不过多一个$\log$）：

对于插入线性基失败的某个数，记录它在插入过程中由哪些数异或起来得到了$0$。令一个集合$\mathbb{S}$表示这些数。

对于插入线性基成功的某个数，记录它在后来者的插入过程中，异或了哪些数。

当你插入一个数$x$时，维护上述集合。

当你删除一个数$x$时：

1. 如果它不在线性基中，直接删除。

2. 如果它在线性基中，且存在一个$\mathbb{S}$使得$x\in\mathbb{S}$，则删去$x$并用$\mathbb{S}$对应的那个数替代$x$即可——因为$\mathbb{S}$中所有数异或起来为$0$，故$\mathbb{S}$中任何数都可以替代$x$。在本次替代后，记得将$x$在其他集合中的**所有出现**，全都替换成替代的这个数。

3. 如果它在线性基中，且不存在一个$\mathbb{S}$使得$x\in\mathbb{S}$，则找到$\mathbb{T}_x$，并用$x$异或$\mathbb{T}_x$中所有数，即可消去$x$的影响。

------------

~~但是，因为在线做法太恶心了，笔者还是选择了离线做法~~

丑的要命的代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef bitset<1010> bi;
int n,m,q,tms[1010],ed[1010],cnt,tot,head[1010],op[1010],qwq,bkw[1010];
pair<int,int>nw[1010];
bi d[1010],dis[510],aft[1010];
struct node{
	int to,next;
	bi val;
}edge[1010];
string s;
bi read(){
	cin>>s;
	bi w(s);
	return w;
}
void ae(int u,int v){
	bi w=read();
	edge[cnt].next=head[u],edge[cnt].to=v,edge[cnt].val=w,head[u]=cnt++;
	edge[cnt].next=head[v],edge[cnt].to=u,edge[cnt].val=w,head[v]=cnt++;
}
void print(bi &x){
	bool stt=false;
	for(int i=999;i>=0;i--){
		if(x[i]||stt)putchar('0'+x[i]);
		if(x[i])stt=true;
	}
	if(!stt)putchar('0');
	putchar('\n');
}
void ins(int now,bi x){
//	print(x);
	for(int i=1000;i>=0;i--){
		if(!x[i])continue;
		if(tms[i]<now)swap(tms[i],now),swap(x,d[i]);
		if(!now)break;
		x^=d[i];
	}
}
bool vis[510];
void dfs(int x){
	for(int i=head[x];i!=-1;i=edge[i].next){
		if(vis[edge[i].to])ins(0x3f3f3f3f,dis[x]^dis[edge[i].to]^edge[i].val);
		else vis[edge[i].to]=true,dis[edge[i].to]=dis[x]^edge[i].val,dfs(edge[i].to);
	}
}
void ask(int now){
	bi res;
	for(int i=1000;i>=0;i--)if(tms[i]>now&&!res[i])res^=d[i];
	print(res);
}
int main(){
	cin>>n>>m>>q,memset(head,-1,sizeof(head)),qwq=q+1;
	for(int i=1,x,y;i<=m;i++)cin>>x>>y,ae(x,y);
	dfs(1);
	ask(0);
	for(int i=1,x,y;i<=q;i++){
		cin>>s;
		if(s[1]=='d')cin>>x>>y,op[i]=++tot,aft[tot]=(read()^dis[x]^dis[y]),nw[tot]=make_pair(x,y),bkw[tot]=tot;
		else if(s[1]=='h')cin>>x,ed[bkw[x]]=i,op[i]=--qwq,aft[qwq]=(dis[nw[x].first]^dis[nw[x].second]^read()),bkw[x]=qwq;
		else if(s[1]=='a')cin>>x,ed[bkw[x]]=i;
	}
	for(int i=1;i<=q;i++)if(!ed[i])ed[i]=0x3f3f3f3f;
	for(int i=1;i<=q;i++){
		if(op[i])ins(ed[op[i]],aft[op[i]]);
		ask(i);
	}
	return 0;
} 
```


---

## 作者：zhiyangfan (赞：15)

## P3733 [HAOI2017]八纵八横
> 给出一张 $n$ 个点 $m$ 条边的连通无向图，边带边权 $w_i$。有以下三种操作，共 $q$ 次：
> - 在点 $x,y$ 之间加入一条边权为 $w_i$ 的边，如果这是第 $i$ 个此种操作，则记这条新边为第 $i$ 条。
> - 将第 $k$ 条新边权值改为 $w'_i$。 
> - 删掉第 $k$ 条新边，保证这条边之后不会再出现。
>
> 对于初始状态和每次操作后，从图中找到一条从 $1$ 出发，并回到 $1$ 的一条权值最大路径，路径权值定义为经过边边权的异或和。点边均可多次经过，边经过多次边权也会被计算多次。($1\le n,m\le 500,1\le q,\log_2 w_i\le 10^3$，加边操作不超过 $550$ 次)

注意到本题走的路径有个非常重要的性质，那就是我们可以任意获得一个环。考虑从 $1$ 开始走，走到想获得的环的位置，走一圈后再原路返回，这样这个环我们就获得了，而走出的非环边，因为走了两边被抵消了。所以原问题中选出路径，即可变成选出若干个环，使它们包含的边异或和最大。（关于这个性质还有很多可以讨论的地方，具体可以参考 [P4151 [WC2011]最大XOR和路径](https://www.luogu.com.cn/problem/P4151)，本题解仅做感性理解）

所以现在我们的问题分为了三个部分：
- 找到所有的环。
- 计算所有环的异或最大值。
- 对某个环的权值单点修改或删除某个环。

首先对于找到所有的环，可以证明我们只需要找到一开始的连通无向图的某一生成树，则我们只需要记录剩下的边和询问加边在生成树上形成的环，就能组成所有的环。感性证明：
- 对于仅由一条非树边构成的环，已经被记录了。
- 对于由多条非树边构成的环，将这些树边在生成树上的构成的环异或组合起来就能得到。

这个过程可以用一个带权并查集实现。

然后我们需要对于找到的所有环计算异或最大值，这个显然是线性基擅长的工作。每找到一个环就把它的权值加入线性基中，询问时从高位到低位贪心即可。

最后，也是本题的难点，是对环的权值单点修改或删除某个环。注意到这两种操作其实可以并成一种，对环的权值单点异或某个值，删除就把它的权值异或到 $0$ 就好。所以现在我们要实现一个支持单点异或的线性基。考虑对于在维护线性基的同时，对每一位的基底记录 **它是由哪些值异或而成的，并选出在线性基里的值作为代表**。然后，进行单点修改时（比如修改 $x$ 位置），枚举所有值，如果它在线性基里对应的基底（如果它不在线性基里就是 $0$）是 $0$，且这个基底由 $x$ 异或而成，则选择这个值对应的基底。如果找不到，就从低位到高位枚举每个基底，选择位数尽量低的，由 $x$ 异或而成的基底。用选择的基底消去其他所有包含 $x$ 的基底（即将基底和组成部分都做一次异或），然后对这个基底进行修改，再插入线性基中即可。

为什么要这样选择基底呢？结论是，在这个基底上修改 **不会破坏原线性基的性质和影响其他基底**。首先，如我们选择的是 $0$，则表示 $x$ 不在线性基内（要么 $x$ 是 $0$，要么 $x$ 能被其他东西异或成 $0$），直接修改当然没有影响。而如果我们选择的非 $0$ 的基底，说明 $x$ 在线性基内，则需要消去其他地方的 $x$，为了保证线性基的性质，显然只能用异或的方法消除。而注意到，如果高位异或低位，就会导致低位基底在高位也存在 $1$，这会破坏线性基的性质，所以我们只能找尽量低位的基底。

这样一通操作下来，我们就能在 $\mathcal{O}(\log w_i+n)$ 的时间复杂度内完成对线性基的单点修改了，其中 $n$ 表示线性基内元素个数，$w_i$ 表示元素的值域。而回到本题，考虑对于每条新边都记录它在哪条环，和每个环的权值。进行修改操作时，找到要异或的值是多少，单点修改所在环的权值即可，上个 `std::bitset`，时间复杂度 $\mathcal{O}(\frac{q(x+m+\log w_i)\log w_i}{w}+n\log n)$，其中 $x$ 表示加入新边的个数，环的个数大约是 $\mathcal{O}(x+m)$。
```cpp
#include <cstdio>
#include <bitset>
#include <cstring>
const int N = 2e3 + 10; typedef std::bitset<N> bs; bs val[N];
inline void print(const bs& x)
{
    int flag = 0; if (x.none()) return putchar('0'), void();
    for (int i = N - 1; ~i; --i)
        if (flag && x[i] == 0) putchar('0');
        else if (x[i] == 1) putchar('1'), flag = 1;
}
inline void input(bs& x)
{
    static char s[N]; x.reset();
    scanf("%s", s); int l = strlen(s);
    for (int i = 0; i < l; ++i) if (s[i] == '1') x.set(l - i - 1);
}
bs cir[N]; int toc[N], top, n, m, p;
struct Linear_basis
{
    // pos_i 表示第 i 位基底对应的值的下标是多少；c_i 表示第 i 个值对应的基底；vis_i 表示 c_i 是由哪些值异或而成的。
    bs c[N], vis[N]; int pos[N];
    inline void modify(int x, const bs& w)
    {
        int p = 0;
        for (int i = 1; i <= top; ++i) if (c[i].none() && vis[i][x]) { p = i; break; }
        if (!p)
            for (int i = 0; i < N; ++i)
                if (pos[i] && vis[pos[i]][x]) { p = pos[i]; pos[i] = 0; break; }
        for (int i = 1; i <= top; ++i) if (i != p && vis[i][x]) c[i] ^= c[p], vis[i] ^= vis[p];
        c[p] ^= w;
        for (int i = N - 1; ~i; --i)
        {
            if (!c[p][i]) continue;
            if (!pos[i]) { pos[i] = p; break; }
            c[p] ^= c[pos[i]]; vis[p] ^= vis[pos[i]];
        }
    }
    inline bs query()
    {
        bs ret;
        for (int i = N - 1; ~i; --i)
            if (!ret[i] && pos[i]) ret ^= c[pos[i]];
        return ret;
    }
}lb;
struct DSU
{
    int f[N], size[N]; bs dis[N];
    void init(int n) { for (int i = 1; i <= n; ++i) f[i] = i, size[i] = 1; }
    int getf(int x) { return x == f[x] ? x : getf(f[x]); }
    bs getdis(int x) { return x == f[x] ? dis[x] : dis[x] ^ getdis(f[x]); }
    void merge(int x, int y, bs w, int id)
    {
        int t1, t2; 
        if ((t1 = getf(x)) == (t2 = getf(y))) 
        {
            bs d = getdis(x) ^ getdis(y) ^ w;
            cir[++top] = d; if (id) toc[id] = top;
            lb.modify(top, d);
        }
        if (size[t1] > size[t2]) std::swap(t1, t2);
        dis[t1] = getdis(x) ^ getdis(y) ^ w; 
        size[t2] += size[t1]; f[t1] = t2;
    }
}dsu;
int main()
{
    scanf("%d%d%d", &n, &m, &p); bs w, t; char op[5]; int id = 0; dsu.init(n);
    for (int i = 1; i < N; ++i) lb.vis[i][i] = 1;
    for (int i = 1, x, y; i <= m; ++i)
        scanf("%d%d", &x, &y), input(w), dsu.merge(x, y, w, 0);
    print(lb.query()); puts("");
    for (int i = 1; i <= p; ++i)
    {
        scanf("%s", op);
        if (op[0] == 'A')
        {
            int x, y; scanf("%d%d", &x, &y); input(w);
            dsu.merge(x, y, w, ++id); val[id] = w;
        }
        else
        {
            int k; scanf("%d", &k);
            if (op[1] == 'h') 
                input(w), t = w, w ^= val[k], val[k] = t, lb.modify(toc[k], w), cir[toc[k]] ^= w;
            else lb.modify(toc[k], cir[toc[k]]);
        }
        print(lb.query()); puts("");
    }
    return 0;
}
```
但是，这种黑科技如果不会，在考场上想出来显然是不太现实的，所以我们考虑一个复杂度更劣，但能通过本题的离线做法。注意到，线性基这种数据结构很容易支持加入和撤销（注意区分撤销和删除）但很难支持删除，但如果题目还要求删除，我们可以考虑上线段树分治。具体来讲，我们把所有询问离线下来，处理出所有边对应的生效区间，并把这些区间挂到线段树上，对整个线段树遍历一遍，每次遍历到一个结点时加入这个结点上挂的边（类似在线做法，用带权并查集处理加环的问题），到叶子结点时，当前的线性基即为该叶子对应时间下的线性基，可以直接输出答案。离开结点时，把在这个结点做的一切事情都撤销（可以通过栈记录都干了点啥）即可。

一些特殊的问题：
- 对于一开始就加入的环，生效区间为 $[0,q]$。
- 对于修改操作，可以看成删掉原来的边并加入一条新边。

总时间复杂度比在线做法多一只 $\log$：$\mathcal{O}(\frac{q\log q\log^2 w_i}{w}+n\log n)$。
```cpp
#include <cstdio>
#include <bitset>
#include <vector>
#include <cstring>
const int N = 2e3 + 10; typedef std::bitset<N> bs; char op[5]; int sta[N], top;
struct edge{ int u, v; bs w; edge(int u = 0, int v = 0, bs w = 0) : u(u), v(v), w(w) { } }E[N];
inline void print(const bs& x)
{
    int flag = 0; if (x.none()) return putchar('0'), void();
    for (int i = N - 1; ~i; --i)
        if (flag && x[i] == 0) putchar('0');
        else if (x[i] == 1) putchar('1'), flag = 1;
}
inline void input(bs& x)
{
    static char s[N]; x.reset();
    scanf("%s", s); int l = strlen(s);
    for (int i = 0; i < l; ++i) if (s[i] == '1') x.set(l - i - 1);
}
struct Linear_basis
{
    bs c[N]; int st[N], tp;
    inline void insert(bs x)
    {
        for (int i = N - 1; ~i; --i)
        {
            if (!x[i]) continue;
            if (c[i].none()) { st[++tp] = i, c[i] = x; break; } 
            x ^= c[i];
        }
    } 
    inline bs query()
    {
        bs ret; 
        for (int i = N - 1; ~i; --i)
            if (!ret[i] && c[i].any()) ret ^= c[i];
        return ret;
    }
    inline void del(int pos) { while (tp != pos) c[st[tp--]].reset(); }
}lb;
struct DSU
{
    int f[N], size[N]; bs dis[N];
    struct mem{ int x, y, s; mem(int x = 0, int y = 0, int s = 0) : x(x), y(y), s(s) { } }st[N]; int tp;
    inline void init(int n) { for (int i = 1; i <= n; ++i) f[i] = i, size[i] = 1; }
    int getf(int x) { return x == f[x] ? x : getf(f[x]); }
    bs getdis(int x) { return x == f[x] ? dis[x] : dis[x] ^ getdis(f[x]); }
    inline void merge(edge x)
    {
        int u = x.u, v = x.v, t1, t2; bs w = x.w;
        if ((t1 = getf(u)) == (t2 = getf(v))) return lb.insert(getdis(u) ^ getdis(v) ^ w);
        if (size[t1] > size[t2]) std::swap(t1, t2), std::swap(u, v);
        st[++tp] = mem(t1, t2, size[t2]); size[t2] += size[t1];
        dis[t1] = getdis(u) ^ getdis(v) ^ w; f[t1] = t2; 
    }
    inline void del(int pos) { while (tp != pos) f[st[tp].x] = st[tp].x, size[st[tp].y] = st[tp].s, dis[st[tp--].x] = 0; }
}dsu;
struct SegTree
{
    #define ls(k) (k << 1)
    #define rs(k) (k << 1 | 1)
    struct node{ std::vector<edge> e; int l, r; }h[N << 2];
    void build(int k, int l, int r)
    {
        h[k].l = l; h[k].r = r;
        if (l == r) return ;
        int mid = (l + r) >> 1; build(ls(k), l, mid); build(rs(k), mid + 1, r);
    }
    void change(int k, int x, int y, edge v)
    {
        if (x <= h[k].l && h[k].r <= y) return h[k].e.emplace_back(v), void();
        int mid = (h[k].l + h[k].r) >> 1;
        if (x <= mid) change(ls(k), x, y, v);
        if (mid < y) change(rs(k), x, y, v);
    }
    void query(int k)
    {
        int mem1 = lb.tp, mem2 = dsu.tp;
        for (auto v : h[k].e) dsu.merge(v);
        if (h[k].l == h[k].r) print(lb.query()), puts("");
        else query(ls(k)), query(rs(k));
        lb.del(mem1); dsu.del(mem2);
    }
}sgt;
int main()
{
    int n, m, p; scanf("%d%d%d", &n, &m, &p); bs w; sgt.build(1, 0, p); dsu.init(n);
    for (int i = 1, x, y; i <= m; ++i)
        scanf("%d%d", &x, &y), input(w), sgt.change(1, 0, p, edge(x, y, w));
    for (int i = 1; i <= p; ++i)
    {
        scanf("%s", op);
        if (op[0] == 'A')
        {
            int x, y; scanf("%d%d", &x, &y); input(w);
            E[++top] = edge(x, y, w); sta[top] = i;
        }
        else
        {
            int k;
            if (op[1] == 'a')
                scanf("%d", &k), sgt.change(1, sta[k], i - 1, E[k]), sta[k] = 0;
            else 
                scanf("%d", &k), input(w), sgt.change(1, sta[k], i - 1, E[k]), sta[k] = i, E[k].w = w;
        }
    }
    for (int i = 1; i <= top; ++i) if (sta[i]) sgt.change(1, sta[i], p, E[i]);
    sgt.query(1); return 0;
}
```

---

## 作者：SSerxhs (赞：14)

线段树分治板子题。

结论：1到n的路径异或值为原图一棵生成树中n的深度（深度也是异或计算的）随便异或几个环。

证明：考虑从1沿着树边走到n，则相当于n的深度。若想经过环，则
沿树边走到该环的某个顶点，绕环一圈，然后沿树边走回1就相当于凭空绕了个环（树边两次走过抵消了）

这启发我们用线性基处理环

考虑按时间轴线段树维护每条边（即每个环）的出现时间，则每条边对应一个区间，将线段树上打lazy标记的位置存储这条边（相当于一个永久化的标记），最后dfs一次线段树即可。

线性基虽然不支持删除，但是支持撤销。直接把改动的存进栈里，回溯的时候改回去就好了。

```cpp
#include <stdio.h>
#include <string.h>
#include <vector>
#include <bitset>
#include <algorithm>
using namespace std;
const int N=502,M=2002,O=4002,L=1000;
typedef bitset<M> bt;
bt ji[M],len[M],bl[M],sum[N],ans,cr;
vector<int> s[O];
int lj[M],nxt[M],fir[N],f[N],l[O],r[O],lb[M][3],pos[M],st[M],ys[M];
int n,m,q,i,j,x,y,z,c,bs,bbs,dt,cs,tp,ds,zbs;
bool ed[M],zd[M],dr[M];
inline void read(bt &x)
{
	c=getchar();x.reset();
	while ((c!=48)&&(c!=49)) c=getchar();
	dr[ds=1]=c^48;c=getchar();
	while ((c==48)||(c==49))
	{
		dr[++ds]=c^48;
		c=getchar();
	}
	for (int i=1;i<=ds;i++) x[ds-i]=dr[i];
}
inline void read(int &x)
{
	c=getchar();
	while ((c<48)||(c>57)) c=getchar();
	x=c^48;c=getchar();
	while ((c>=48)&&(c<=57))
	{
		x=x*10+(c^48);
		c=getchar();
	}
}
inline void add()
{
	lj[++bbs]=y;
	len[bbs]=cr;
	nxt[bbs]=fir[x];
	fir[x]=bbs;
	lj[++bbs]=x;
	len[bbs]=cr;
	nxt[bbs]=fir[y];
	fir[y]=bbs;
}
int getf(int x)
{
	if (f[x]==x) return x;
	return f[x]=getf(f[x]);
}
void out(bt x)
{
	int i;for (i=L;(i)&&(x[i]==0);i--);for (;~i;i--) putchar(x[i]|48);putchar(10);
}
int ins(bt x)
{
	for (register int i=L;~i;i--) if (x[i])
	{
		if (ed[i]) x^=ji[i]; else
		{
			ji[i]=x;
			ed[i]=1;
			return i;
		}
	}
	return -1;
}
void summ(bt &x)
{
	x.reset();
	for (register int i=L;~i;i--) if ((ed[i])&&(x[i]==0)) x^=ji[i];
}
void build(int x)
{
	while (l[x]<r[x])
	{
		l[c=x<<1]=l[x];r[c]=l[x]+r[x]>>1;
		l[c|1]=r[c]+1;r[c|1]=r[x];
		build(c);x=x<<1|1;
	}
}
void sol(int x)
{
	if ((z<=l[x])&&(r[x]<=y))
	{
		s[x].push_back(dt);
		return;
	}
	if (z<=r[x<<1]) sol(x<<1);
	if (y>r[x<<1]) sol(x<<1|1);
}
void dfs1(int x)
{
	zd[x]=1;
	for (int i=fir[x];i;i=nxt[i]) if (zd[lj[i]]) ins(sum[lj[i]]^sum[x]^len[i]); else
	{
		sum[lj[i]]=sum[x]^len[i];
		dfs1(lj[i]);
	}
}
void dfs2(int x)
{
	int cur=tp;
	for (i=0;i<s[x].size();i++)
	{
		y=ins(bl[s[x][i]]);
		if (~y) st[++tp]=y;
	}
	if (l[x]==r[x]) {summ(ans);for (i=L;(i)&&(ans[i]==0);i--);for (;~i;i--) putchar(ans[i]|48);putchar(10);}
	else {dfs2(x<<1);dfs2(x<<1|1);}
	while (tp>cur) {ed[st[tp]]=0;ji[st[tp--]].reset();}
}
int main()
{
	read(n);read(m);read(q);
	for (i=1;i<=n;i++) f[i]=i;
	while (m--)
	{
		read(x);read(y);read(cr);
		add();
	}
	dfs1(1);l[1]=0;r[1]=q;build(1);
	memset(zd,0,sizeof(zd));
	for (i=1;i<=q;i++)
	{
		c=getchar();
		while ((c!='A')&&(c!='C')) c=getchar();
		if (c=='A')
		{
			read(lb[++bs][1]);read(lb[bs][2]);read(bl[bs]);bl[bs]^=sum[lb[bs][1]]^sum[lb[bs][2]];lb[bs][0]=i;ys[++zbs]=bs;
		}
		else if (getchar()=='a')
		{
			read(x);dt=x=ys[x];
			z=lb[x][0];y=i-1;zd[x]=1;
			sol(1);
		} else
		{
			read(x);dt=ys[x];
			z=lb[ys[x]][0];y=i-1;
			sol(1);lb[++bs][1]=lb[ys[x]][1];lb[bs][2]=lb[ys[x]][2];
			lb[ys[x]=bs][0]=i;read(bl[bs]);bl[bs]^=sum[lb[bs][1]]^sum[lb[bs][2]];
		}
	}
	zd[0]=1;
	for (i=1;i<=bs;i++) if (!zd[ys[i]])
	{
		z=lb[dt=ys[i]][0];y=q;zd[ys[i]]=1;
		sol(1);
	}
	dfs2(1);
}
```


---

## 作者：teafrogsf (赞：14)

~~现在你看到的是本篇题解的第三迭代，之前的内容因为不可预知的信息危害导致内容失踪。~~

------------

  
```
线段树分治傻题。
											——zsyzsy
```
在与$Faker\_Beng,ShichengXiao$的开黑下终于了却了一大心结。~~同时被zsy吊打~~  
如果你做过$[WC2011]XOR$的话，对这题你应该有一个基本的思路：把所有的环搜出来，然后把它们插到线性基里查询异或最大值。  
于是有一个暴力的做法：对每次修改都暴力重新搜环并重构线性基，这样的复杂度应该是$O(\frac{qmL^2}{\omega})$，可以获得$70$分的好成绩。  
这样做为什么是对的呢？因为实际上我们的询问就是要求一堆环中的异或最大值，最终选出来的环有没有经过首都都没有关系，因为对于任意一个环，只要我们再走一遍，影响就消掉了。  
既然线性基不好撤销，我们考虑线段树分治。因为这样就可以把线性基存到分治结构里，最多只会同时存在$O(\log)$个线性基，所以空间复杂度是没有问题的。  
因为一开始的边是不会删除的，所以我们可以用并查集找到一开始的环边，然后搞出一个原图的生成树。那么对于之后的插入，我们可以直接找出一个唯一的环，而环上的权值和也可以方便地求出。  
于是我们可以直接求出对于每条环边的存在区间，一开始的环边就是$[0,q]$。    
注意对于环边权值的修改，我们也要划分成两个存在区间。  
然后我们直接把所有环边插到线段树里，进行线段树分治就可以了。  
这题主要的细节就是$bitset$了吧~~，但是为什么这题东西这么多啊因为数组开多了$RE$好几次~~  
时间复杂度应该是$O(n\alpha(n)+\frac{(m-n+q+q\log q)L^2}{\omega})$，$O(m-n+q)$是环的个数。  
```cpp
// luogu-judger-enable-o2
#include<bits/stdc++.h>
#define neko 510
#define meko 1010
#define feko 6010
#define pb push_back
#define	f(i,a,b) for(register int i=(a);i<=(b);i=-(~i)) 
#define	rf(i,a,b) for(register int i=(a);i>=(b);i=~(-i)) 
using namespace std;
namespace IO
{
    template<typename T>
        void read(T &x)
        {
            char c=getchar();x=0;
            for(;!isdigit(c);c=getchar());
            for(;isdigit(c);x=(x<<1)+(x<<3)+(c^'0'),c=getchar());
        }
}
typedef bitset<1005> bs;
struct Basis
{
    bs bas[meko];
//	Basis()
//	{f(i,1,1000)bas[i].reset();}
}B;
struct node
{int v,nex;bs w;}e[meko<<1];
struct edge
{int u,v,l,r;bs w;}E[meko<<1];
int n,m,q,TT;
typedef int arr[neko];
arr head,fa;
vector<int>vec[feko];
bs dis[neko];
int pos[meko];
namespace Lin_Bsis
{
    int maxbit=0;
    void print(bs x)
    {
        int flag=0;
        rf(i,maxbit,0)
        {
            if(x[i])flag=1;
            if(flag)putchar(x[i]+'0');
        }if(!flag)putchar('0');
        putchar('\n');
    }
    void insert(Basis &L,bs x)
    {
        rf(i,maxbit,0)
        {
            if(!x[i])continue;
            if(!L.bas[i].any()){L.bas[i]=x;break;}
            else x^=L.bas[i];
        }
    }
    bs query(Basis L)
    {
        bs ans;ans.reset();
        rf(i,maxbit,0)if(!ans[i])ans^=L.bas[i];
        return ans;
    }
}
namespace Seg_DC
{
    #define ori tagl,tagr
    #define lson root<<1,l,mid
    #define rson root<<1|1,mid+1,r
    using namespace Lin_Bsis;
    void update(int root,int l,int r,int tagl,int tagr,int x)
    {
        if(tagl<=l&&r<=tagr)return (void)vec[root].pb(x);
        int mid=(l+r)>>1;
        if(tagl<=mid)update(lson,ori,x);
        if(tagr>mid)update(rson,ori,x);
    }
    void dfs(int root,int l,int r,Basis bas)
    {
        for(auto x:vec[root])insert(bas,dis[E[x].u]^dis[E[x].v]^E[x].w);
        int mid=(l+r)>>1;
        if(l==r)return print(query(bas));
        else dfs(lson,bas),dfs(rson,bas);
    }
}
namespace Graph
{
    int t=0;
    int find(int x){return fa[x]^x?fa[x]=find(fa[x]):x;}
    void add(int x,int y,bs z)
    {
        e[++t].v=y,e[t].w=z;e[t].nex=head[x],head[x]=t;
        e[++t].v=x,e[t].w=z;e[t].nex=head[y],head[y]=t;
    }
    void dfs(int u,int fa)
    {
        for(register int i=head[u],v=e[i].v;i;i=e[i].nex,v=e[i].v)if(v^fa)dis[v]=dis[u]^e[i].w,dfs(v,u);
    }
}
int cmax(int x,int y){return x>y?x:y;}
int main()
{
    using namespace Graph;
    using namespace Seg_DC;
    using namespace IO;
    int x,y,cnt=0;
    string str;
    char s[20];
    read(n),read(m),read(q);
    f(i,1,n)fa[i]=i;
    f(i,1,m)
    {
        read(x),read(y),cin>>str;
        maxbit=cmax(maxbit,str.size());
        if(find(x)^find(y))fa[find(y)]=find(x),add(x,y,bs(str));
        else E[++TT]=(edge){x,y,0,q,bs(str)};
    }
    Graph::dfs(1,0);
    f(i,1,q)
    {
        scanf("%s",s);
        if(s[0]=='A')
        {
            read(x),read(y),cin>>str;
            maxbit=cmax(maxbit,str.size());
            E[++TT]=(edge){x,y,i,q,bs(str)},pos[++cnt]=TT;
        }
        else if(s[1]=='a')read(x),E[pos[x]].r=i-1,pos[x]=0;
        else
        {
            read(x),cin>>str;
            maxbit=cmax(maxbit,str.size());
            E[pos[x]].r=i-1;
            E[++TT]=(edge){E[pos[x]].u,E[pos[x]].v,i,q,bs(str)};
            pos[x]=TT;
        }
    }
    f(i,1,TT)update(1,0,q,E[i].l,E[i].r,i);
    return dfs(1,0,q,B),0;
}
```

---

## 作者：wrzSama (赞：7)

### 题目大意

给定一个 $n$ 个点 $m$ 条边的无向连通图（包含重边和自环）和 $q$ 次操作，每次操作可以增加一条边、删除一条边或更改一条边的权值。定义一条路径的价值为所有经过的边的权值异或起来的值，问第 $1$ 次操作前和每次操作后从 $1$ 号节点出发最后回到 $1$ 号节点（可以重复经过边）所能获得的最大价值。

### 思路

从 $1$ 号节点出发再回到 $1$ 号节点，能对答案产生贡献的只会是环。因为如果你走了一条链，你为了走回出发点只能原路返回或走另外一条路返回。如果原路返回它的每条边都经过了两次，异或起来对答案没有贡献；如果走另外一条路返回，那么这条路径本身就是一个环。那么，我们就可以先根据原图生成一棵树，这样每加入一条边就与这棵树生成一个环，把这个环上每条边权异或起来的值加入一个集合中。如果加入的边在图中生成了多个环，我们也只需要将它与树形成的环的价值加入集合，因为其它的环的价值可以通过这个环与集合中已有的环的价值异或得到。那么答案就是集合中任意元素异或起来的最大值。为了找到这个最大值，我们可以用线性基来维护这个集合。如果不了解线性基的，可以去[这里](http://oi-wiki.com/math/basis/)看一看。因为可能会出现删除边和更改边权的操作，所以我们要把所有操作离线下来，并在加入一条边即加入一个环的时，记录它会在什么时刻删去。在线性基中插入时，若同一位上有两个数，则让删除时间较晚的数占据这个位置，另一个数向后找位置。在线性基中查询时，则只用删除时间晚于查询时的时间的数更新答案。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll bitset<1005>
inline ll read()
{
	ll x;
	string s;
	cin>>s;
	for(register int i=s.size();i;--i) x[s.size()-i]=s[i-1]-'0';
	return x;
}
inline void write(ll x)
{
	bool flag=0;
	for(register int i=1000;i>=0;--i)
	{
		if(x[i]) flag=1;
		if(flag) putchar(x[i]+'0');
	}
	if(!flag) putchar('0');
	puts("");
}
struct node
{
	string op;
	int x,y;
	ll z;
}p[1005];
struct edge
{
	int to;
	ll val;
};
vector<edge>s[1005];
int n,m,q,t[1005],pos[1005],tot,del[1005];
ll dis[1005],a[1005];
inline void insert(ll x,int now)
{
	for(register int i=1000;i>=0;--i)
	{
		if(!x[i]) continue;
		if(t[i]<now)
		{
			swap(t[i],now);
			swap(a[i],x);
		}
		if(!now) break;
		x^=a[i];
	}
}
inline void dfs(int u,ll d)
{
	dis[u]=d;
	for(register int i=0;i<s[u].size();++i)
	{
		int v=s[u][i].to;
		ll w=s[u][i].val;
		if(dis[v]==-1) dfs(v,d^w);
		else insert(d^w^dis[v],1e9);
	}
}
inline ll query(int now)
{
	ll res=0;
	for(register int i=1000;i>=0;--i) if(t[i]>now&&!res[i]) res^=a[i];
	return res;
}
int main()
{
	scanf("%d%d%d",&n,&m,&q);
	for(register int i=1;i<=n;++i) dis[i]=-1;
	for(register int i=1;i<=m;++i)
	{
		int u,v;
		scanf("%d%d",&u,&v);
		ll w=read();
		s[u].push_back((edge){v,w});
		s[v].push_back((edge){u,w});
	}
	dfs(1,0);
	write(query(0));
	for(register int i=1;i<=q;++i)
	{
		cin>>p[i].op;
		if(p[i].op[1]=='d')
		{
			pos[++tot]=i;
			scanf("%d%d",&p[i].x,&p[i].y);
			p[i].z=read();
		}
		else if(p[i].op[1]=='a')
		{
			int k;
			scanf("%d",&k);
			del[pos[k]]=i;
		}
		else
		{
			int k;
			scanf("%d",&k);
			del[pos[k]]=i;
			p[i].x=p[pos[k]].x;
			p[i].y=p[pos[k]].y;
			p[i].z=read();
			pos[k]=i;
		}
	}
	for(register int i=1;i<=q;i=-~i)
	{
		if(p[i].op[1]!='a')
		{
			if(!del[i]) insert(dis[p[i].x]^dis[p[i].y]^p[i].z,1e9);
			else insert(dis[p[i].x]^dis[p[i].y]^p[i].z,del[i]);
		}
		write(query(i));
	}
	return 0;
}
```


---

## 作者：jiuguaiwf (赞：6)

最近在写线性基的题，想把这道肝出来

网上资料很少，找了篇可读性较高的，照着啃，痛苦之后，想发篇题解，拯救下像我一样的弱鸡

前置技能：线性基      

这是一个用来瞎搞xor，集合的利器，单次复杂度为单个向量的元素数（xor操作可以理解为log级别的）

~~啥，你不懂？~~     ~~sengxian和menci的博客百度下~~

另外，常被人忽视的线性基的代码实践，本质其实是高斯消元求倒三角矩阵


**回归本题：**

Q: 边有权值，求图里的最大xor   

dalao：找环插入线性基

Q: 带删除，修改

dalao: WTF?   (PS：线性基不支持删除)

julao: 线段树分治

对了，这就是本题精髓

~~我也是刚懂~~ 就是以时间为轴进行分治，巧妙地避开删除操作，只进行插入

上代码


~~网上没几篇能看的，我也是学别人的~~
```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<bitset>
#include<queue>
#include<vector>
#include<algorithm>
#define mx 1000
using namespace std;
typedef bitset<1105> bt;//1000位，带xor,必须bitset啊
bt dis[5050],Q;
vector<bt> val[1005<<4];//val存线段树每个节点中添加的值
int n,m,q,h[5050],cnt,vis[5005],pre[1005<<4],top;//pre是新加边的存在的起始时间
char s[1005<<4];
struct wfff{
	int fro,to;
	bt w;
}E[1005<<4];//新加的边
struct wff{
	int to,nxt;
	bt w;
}edge[1005<<4];//原有的边
struct wf{
	bt b[1105];
}fir;//初始线性基
void add(int u,int v,bt w)
{
	edge[++cnt].to=v;
	edge[cnt].nxt=h[u];
	edge[cnt].w=w;
	h[u]=cnt;
}
void readBT(bt &x)
{
	scanf("%s",s);
	int len=strlen(s)-1;
	for (int i=0;i<=len;i++)
	  x[i]=s[len-i]-'0';//读入bitset时，掉个个儿，因为后面线性基一般都按权值由高到低枚举
}
void charu(wf &a,bt x)//插入线性基
{
	if (!x.any()) return;
	for (int i=mx;i>=0;i--)//mx是最高权值位
	{
		if (!x[i]) continue;
		if (!a.b[i].any())
		{
			a.b[i]=x;
			break;
		}
		else x^=a.b[i];//线性基基本操作
	}
}
void printans(wf a)//统计答案
{
	int i;
	Q.reset();//Q保存答案
	for (i=mx;i>=0;i--)
	  if (a.b[i].any()) break;//把矩阵空行去掉
	if (i<0)
	{
		printf("0\n");//全空就输出0
		return;
	}
	int pos=i;
	for (int j=i;j>=0;j--)
	  if (a.b[j].any()&&!Q[j]) Q^=a.b[j];
	for (int i=pos;i>=0;i--)
	  if (Q[i]==0) printf("0");//基本操作
	  else printf("1");
	printf("\n");
}
void dfs(int u,int fa)
{//初始时建图跑一遍
	vis[u]=1;
	for (int i=h[u];i;i=edge[i].nxt)
	{
		int v=edge[i].to;
		if (v!=fa)
		{
			if (!vis[v])
			{
				dis[v]=dis[u]^edge[i].w;
				dfs(v,u);
			}
			else charu(fir,dis[u]^dis[v]^edge[i].w);
		}//如果下一个点已被访问，说明出现了环，xor两次会消，因此插入的便是环的权值
	}
}
void change(int l,int r,int L,int R,bt x,int root)
{
	if (l>=L&&r<=R)
	{
		val[root].push_back(x);//在管理操作的线段树节点上标记，记录将会进行哪些更改
		return;
	}
	int mid=l+r>>1;
	if (mid>=L) change(l,mid,L,R,x,root<<1);
	if (mid<R) change(mid+1,r,L,R,x,root<<1|1);
}
void query(int l,int r,wf x,int root)
{
	for (int i=val[root].size()-1;i>=0;i--) 
	  charu(x,val[root][i]);//一股脑全插入完
	if (l==r)
	{
		printans(x);//到了某一时刻，便输出答案
		return;
	}
	int mid=l+r>>1;
	query(l,mid,x,root<<1);
	query(mid+1,r,x,root<<1|1);
}
int main()
{
	scanf("%d%d%d",&n,&m,&q);
	int u,v; 
	bt w;
	for (int i=1;i<=m;i++)
	{
		w.reset();
		scanf("%d%d",&u,&v);
		readBT(w);
		add(u,v,w);
		add(v,u,w);
	}
	dfs(1,0);
	for (int i=1;i<=q;i++)
	{
		scanf("%s",s);
		if (s[0]=='C')
		{
			scanf("%d",&u);//线段树的l,r是一条边存在时间的区间了（出生到死亡）
			change(1,q,pre[u],i-1,dis[E[u].fro]^dis[E[u].to]^E[u].w,1);
			if (s[1]=='h')//同理，插入的是一个环的xor值（这也是我们为什么dfs求dis数组的原因）
			{
				pre[u]=i;//开始存在时间
				E[u].w.reset();
				readBT(E[u].w);
			}
			else pre[u]=0;//边被撤销了
		}
		else
		{
			pre[++top]=i;
			scanf("%d%d",&E[top].fro,&E[top].to);
			readBT(E[top].w);
		} 
	}
	for (int i=1;i<=top;i++)//可能有些边到最后也没被撤销，我们也要进行统计
	  if (pre[i]) change(1,q,pre[i],q,dis[E[i].fro]^dis[E[i].to]^E[i].w,1);
	printans(fir);//看清题意，改造前要输出一次
	if (q!=0) query(1,q,fir,1);//进行统计，fir会在线段树的分治过程中不断进行改变以求得结果
	return 0;
}
```

出锅或哪里不懂您联系我 ~~咕咕咕~~

还是很弱，我怎么才能变强呀

---

## 作者：xqqQwQ_ (赞：3)

非常经典的使用线段树分治维护最大异或和路径的题目。

首先看到最大异或和路径，就可以迅速联想起 [WC2011]最大 XOR 和路径。发现其实就是把每个时刻的线性基搞出来就行了，由于这个题是求 $1 \rightarrow 1$ 的路径所以甚至不需要找链。

每个时刻都重做一次肯定是会 $\text{T}$ 的。于是我们考虑一个经典做法，就是一开始的时候先随便找一个原图的生成树，然后将原图中已经存在的环丢进线性基。由于原图中的边是不会改变边权或者被删掉的，所以我们就可以不管了。对于后面的每一次加边，我们把这条新边和原图的生成树所构成的那个环给丢进线性基里面。容易证明这些插入线性基中的环可以表示出来新图中的所有环（感性理解）。

由于题目中说 $w$ 的二进制表示下的位数 $len \leq 1000$，所以必须使用 $\text{bitset}$ 来存储边的权值和线性基里面的数。

原图的生成树和环可以一开始直接用一遍 $\text{dfs}$ 得到（过程中可以直接用一开始处理出来的值，不需要带权并查集），中间的一次加边操作的时间复杂度是 $O(\frac{len ^ 2}{\omega})$ 的。于是只有加边操作的情况我们就可以在 $O(m + \frac{Q len^2}{\omega})$ 的复杂度内完成。

那么现在考虑一下有了改边权和删除操作的情况。由于改边权我们可以看作是撤销掉原来的这条边，加入一条新的权值是 $w'$ 的边，所以我们就只用考虑如何删除。线性基这个东西是不太好直接进行删除的，于是考虑线段树分治把删除变成撤销。这个是比较简单的，把每条边的时间区间 $[l, r]$ 求出来然后插入线段树里面，然后递归到每一个节点的时候开一个新的线性基来备份当前状态（由于线段树高是 $\log Q$ 的，所以空间复杂度是 $len \log Q$，不会 $\text{MLE}$），回溯的时候还原线性基即可。

时间复杂度 $O(m + \frac{Q \log Q len^2}{\omega})$。开了 $\text{O2}$ 之后跑的飞快。

```cpp
#include<bits/stdc++.h>
#define ls (num << 1)
#define rs ((num << 1) | 1)
#define mid ((l + r) >> 1)
#define pb push_back

using namespace std;

const int N = 1e3 + 7;
const int MT = 1e3 + 7;

#define bi bitset<MT + 1>

struct Ope {
    int u, v;
    bi w;
};

int n, m, Q, k;
int head[N], pre[N], ver[N];
int st[N], ed[N], unc[N], ti[N];
int cnt = 0, vis[N];
bi val[N], Xor[N], B[MT + 1], ept, col[MT + 1];
vector<Ope> upd[N << 2];
bi Ansn[MT + 1];

void add_edge(int u, int v, bi w) {
    pre[++cnt] = head[u];
    head[u] = cnt;
    ver[cnt] = v, val[cnt] = w;
    return;
}

bool ins(bi x) {
    bool flag = 0;
    for(int i = MT; ~i; --i) {
        if(x[i]) {
            if(B[i] == ept) {
                flag = 1, B[i] = x;
                break;
            }
            else x ^= B[i];
        }
    }    
    return flag;
}

bi qmx() {
    bi Ans;
    for(int i = MT; ~i; --i) {
        if(B[i] == ept) continue;
        else if(Ans[i] == 0) Ans ^= B[i];
    }
    return Ans;
}

void dfs(int nown) {
    if(vis[nown]) return;
    vis[nown] = 1;
    for(int i = head[nown]; i; i = pre[i]) {
        int v = ver[i];
        if(vis[v]) {
            ins((Xor[nown] ^ Xor[v] ^ val[i]));
            continue;
        }
        Xor[v] = Xor[nown] ^ val[i];
        dfs(v);
    }
    return;
}

void update(int num, int l, int r, int a, int b, Ope v) {
    if(a <= l && b >= r) {
        upd[num].pb(v);
        return;
    }
    if(a <= mid) update(ls, l, mid, a, b, v);
    if(b > mid) update(rs, mid + 1, r, a, b, v);
    return;
}

void solve(int num, int l, int r) {
    bi bacB[MT + 1];
    for(int i = 0; i <= MT; ++i) bacB[i] = B[i];
    for(Ope op : upd[num]) {
        int u = op.u, v = op.v; bi w = op.w;
        ins(Xor[u] ^ Xor[v] ^ w);
    }
    if(l == r) {
        Ansn[l] = qmx();
        for(int i = 0; i <= MT; ++i) B[i] = bacB[i];
        return;
    }
    solve(ls, l, mid), solve(rs, mid + 1, r);
    for(int i = 0; i <= MT; ++i) B[i] = bacB[i];
    return;
}

int main() {
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    cin >> n >> m >> Q;
    for(int i = 1; i <= m; ++i) {
        int u, v; bi w; string s;
        cin >> u >> v;
        cin >> s; reverse(s.begin(), s.end());
        for(int j = 0; j < s.length(); ++j) if(s[j] - '0' == 1) w.set(j);
        add_edge(u, v, w);
        add_edge(v, u, w);
    }
    dfs(1);
    Q++;
    for(int i = 2; i <= Q; ++i) {
        string opt; int x, y; bi z;
        cin >> opt;
        if(opt[0] == 'A') {
            ++k; cin >> x >> y; string s;
            cin >> s; reverse(s.begin(), s.end());
            for(int j = 0; j < s.length(); ++j) if(s[j] - '0' == 1) z.set(j);
            unc[k] = 1, st[k] = x, ed[k] = y, col[k] = z, ti[k] = i;
        }
        else if(opt == "Cancel") {
            cin >> x; unc[x] = 0;
            update(1, 1, Q, ti[x], i - 1, (Ope){st[x], ed[x], col[x]});
        }
        else {
            cin >> x; string s;
            cin >> s; reverse(s.begin(), s.end());
            for(int j = 0; j < s.length(); ++j) if(s[j] - '0' == 1) z.set(j);
            update(1, 1, Q, ti[x], i - 1, (Ope){st[x], ed[x], col[x]});
            ti[x] = i, col[x] = z;
        }
    }
    for(int i = 1; i <= k; ++i) {
        if(!unc[i]) continue;
        update(1, 1, Q, ti[i], Q, (Ope){st[i], ed[i], col[i]});
    }
    solve(1, 1, Q);
    for(int i = 1; i <= Q; ++i) {
        int cur = MT;
        while(Ansn[i][cur] == 0 && cur) cur--;
        for(int j = cur; ~j; --j) cout << Ansn[i][j];
        cout << '\n';
    }
    return 0;
}

/* 
    Author: _LiMLE_
    start coding at: 15:08
    finish debugging at: 15:50
*/
```

---

## 作者：太阳起晚了呢 (赞：2)

## 解

### 前置题目

1.WC2011 最大 xor 路径

2.bzoj4184 shallot  http://123.56.142.67/bzoj-4184-shallot-%e9%a2%98%e8%a7%a3/



有了这两题的基础就可以考虑首先需要找到一些环，将这些环插入异或基，再求得最大值

需要插入删除的异或基是不好完成的，考虑像 bzoj4184 一样离线使用线段树分治

此处看到 $len$ 的取值 $\leq 1000$ 所以使用容器 `bitset` 维护异或基，整体代码细节很多



实际上，我们考虑对于原图寻找到一个生成树，把非树边全部存起来维护它们的存在时间（注意，在一开始给定的边中有非树边，将其时间设为 $0-q$ 就可以了）。如此每次添加一条边，都会构成一个环，将树上路径预处理就可以方便得到环的异或值并插入异或基。为了避免空间爆炸，每次我们只需要记录能够成环的非树边的标号，不用每次都插入异或基。



异或基插入记得写 

```cpp
break
```

```cpp
#include<bits/stdc++.h>
#define mid ((lc[u]+rc[u])>>1)
#define ls (u<<1)
#define rs (u<<1 | 1)
using namespace std;
#define bs bitset<1005> 
int maxbit;
struct linearbase
{
    bs p[1005];
    void insert(bs x)
    {
        for(int i=maxbit;i>=0;i--) 
        {
            if(!x[i]) continue;
            if(!p[i].any()) {p[i]=x;break;}
            else x^=p[i];
        }
    }
    bs query()
    {
        bs tmp;
        tmp.reset();
        for(int i=maxbit;i>=0;i--) if(!tmp[i]) tmp^=p[i];
        return tmp;
    }
}Ba;
void print(bs res)
{
    bool flag=0;
    for(int i=maxbit;i>=0;i--)
    {
        if(!flag && res[i]) flag=1;
        if(flag) putchar(res[i]+'0');
    }if(!flag) putchar('0');
    putchar('\n');
}
/*
struct linearbase
{
    int p[33];
    linearbase() {memset(p,0,sizeof p);}
    void insert(int x)
    {
        for(int i=31;i>=0;i--)
        {
            if(!(x>>i)) continue;
            if(!p[i]) {p[i]=x;break;}
            x^=p[i];
        }
    }
    int query()
    {
        int res=0;
        for(int i=31;i>=0;i--) if(res^p[i]>res) res^=p[i];
        return res;
    }
};
*/
const int maxn=1200;
int n,m,P;
struct bcj
{
    int fa[maxn];
    void init()
    {
        for(int i=1;i<=n;i++) fa[i]=i;
    }
    int getfa(int u)
    {
        while(fa[u]!=u) u=fa[u]=fa[fa[u]];
        return u;
    }
    void merge(int x,int y)
    {
        x=getfa(x);y=getfa(y);
        fa[x]=y;
    }
}A;
struct node
{
    int v,next;
    bs w;
}e[maxn<<1];
int head[maxn],cnt;
void add(int u,int v,bs w)
{
    e[++cnt].next=head[u];
    e[cnt].v=v;
    e[cnt].w=w;
    head[u]=cnt;
}
bs dis[maxn];
void dfs(int u,int fa)
{
    for(int i=head[u];i;i=e[i].next)
    {
        int v=e[i].v;
        if(v==fa) continue;
        dis[v]=dis[u]^e[i].w;
        dfs(v,u);
    }
}
struct Edge
{
    int u,v,l,r;
    bs w;
}E[maxn<<1];
struct segment_tree
{
    vector<int> ver[maxn<<2];
    int lc[maxn<<2],rc[maxn<<2];
    bs ans[maxn];
    void build(int u,int l,int r)
    {
        lc[u]=l;rc[u]=r;
        if(l==r) return ;
        ver[u].clear();
        build(ls,l,mid);
        build(rs,mid+1,r);
    }
    void modify(int u,int l,int r,int x)
    {
    	//cout<<u<<' '<<l<<' '<<r<<endl;
        if(l<=lc[u] && rc[u]<=r)
        {
            ver[u].push_back(x);
            return ;
        }
        if(l<=mid) modify(ls,l,r,x);
        if(mid<r) modify(rs,l,r,x);
    }
    void query(int u,linearbase tmp)
    {
        for(int i=0;i<ver[u].size();i++)
        {
            int x=ver[u][i];
            tmp.insert(dis[E[x].u]^dis[E[x].v]^E[x].w);
            //print(dis[E[x].u]^dis[E[x].v]^E[x].w);
            //tmp.insert(ver[u][i]);
        } 
        if(lc[u]==rc[u]) {ans[lc[u]]=tmp.query();return ;}
        query(ls,tmp);query(rs,tmp);
    }
}T;
int tot;
int pos[maxn],tim;
int main()
{
//cout<<114514<<endl;
    scanf("%d%d%d",&n,&m,&P);
    A.init();
    for(int i=1;i<=m;i++)
    {
        int x,y;string st;
        scanf("%d%d",&x,&y);cin>>st;
        maxbit=max(maxbit,(int)st.size());
        if(A.getfa(x)!=A.getfa(y)) A.merge(x,y),add(x,y,bs(st)),add(y,x,bs(st));
        else E[++tot]={x,y,0,P,bs(st)};   
    }
    //cout<<114514<<endl;
    dfs(1,0);
    //cout<<114514<<endl;
    for(int i=1;i<=P;i++)
    {
    //cout<<i<<endl;
        string opt,st;
        int x,y;
        cin>>opt;
        //cout<<opt<<endl;
        if(opt[0]=='A')
        {
            scanf("%d%d",&x,&y);cin>>st;
            maxbit=max(maxbit,(int)st.size());
            E[++tot]={x,y,i,P,bs(st)};pos[++tim]=tot;
        }
        else if(opt[1]=='a')
        {
            scanf("%d",&x);
            E[pos[x]].r=i-1;
            //pos[x]=0;
        }
        else
        {
            //cout<<114514432412<<endl;
            //cout<<142314<<endl;
            scanf("%d",&x);cin>>st;
            maxbit=max(maxbit,(int)st.size());
            E[pos[x]].r=i-1;
            E[++tot]=E[pos[x]];E[tot].w=bs(st);
            E[tot].l=i;E[tot].r=P;
            pos[x]=tot;
        
        }
    }
    T.build(1,0,P);
    //cout<<114514<<endl;
    
    for(int i=1;i<=tot;i++)
	{
		//cout<<E[i].u<<' '<<E[i].v<<' '<<E[i].l<<' '<<E[i].r<<endl;
		T.modify(1,E[i].l,E[i].r,i);///MLE	
	} 
    //cout<<114514<<endl;
    T.query(1,Ba); 
    print(T.ans[0]);
    for(int i=1;i<=P;i++) print(T.ans[i]);
    return 0;
}
/*
5 8 0
4 4 1010010010000000011000010000000
1 2 1100011100010100011010101110000
3 5 100001000010001100110100
1 4 100101000000100001000000000
4 5 1010100000010000000100000001101
5 1 1010011100100001010000010000
2 5 100001010001000001001010001000
2 1 100000000010000100000000010

1111101011101110011111000011010

*/
```

思路有借鉴 @[**teafrogsf**](https://www.luogu.com.cn/user/7020) 的，不尽感激。

---

## 作者：a1co0av5ce5az1cz0ap_ (赞：1)

[Problem link](https://www.luogu.com.cn/problem/P3733)

查询的内容相当于从 $1$ 出发，走若干个环并回到自己能得到的最大异或和。

随便找一棵生成树，假设从根到点 $i$ 的边权异或和为 $d_i$，一条非树边 $(x,y,z)$ 对应的最小的环的异或和为 $d_x\oplus d_y\oplus z$，原因显然。

容易发现任意包含多条非树边的大环都可以由它们异或而成（多余部分被异或掉了）。因此考虑没一条边造成的影响。

接下来是很经典的线段树分治部分。把操作当成是有若干条非树边（最初给出的图里的也要算入）分别出现在一段连续区间的时间内，时间为 $0\sim q$。

用一个 vector 存储每个节点对应区间上所包含的边，之后对整个树进行 dfs。

每到达一个节点就向线性基中加入其异或和。搜到叶子节点就输出答案。离开节点时撤销所有添加的异或和。

可撤销的线性基很好实现。用数组记录每一次向线性基添加的值所在位置，撤销的时候把最后若干次修改位置的值重新赋值为 0 即可。

题目用的奇怪的二进制用 bitset 即可。

**线性基撤销的时候一定只撤销插入成功的次数！！！WA 50 调了一晚上……**

```cpp
//本题含量：
//OI 1%
//大便 99%
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef pair<int,int> pii;
typedef pair<int,ll> pil;
#define fi first
#define se second
const ll mod=0;
const int N=100005;
ll gcd(ll a,ll b){return b?gcd(b,a%b):a;}
void NO(){cout<<"NO\n";}
void YES(){cout<<"YES\n";}
void init(){}
mt19937 rnd((unsigned long long)new char);
#define bin bitset<1000>
void print(bin x){// bitset 输出
	bool f=1;
	for(int i=999;~i;i--)if(x[i]||!f)cout<<char('0'+x[i]),f=0;
	if(f)cout<<0;
	cout<<'\n';
}
struct three{int x,y;bin z;};

int n,m,q;
vector<three>G,V;
vector<pair<int,bin>>v[505];
int f[505];
int zx(int x){return x==f[x]?x:f[x]=zx(f[x]);}
void gettree(){// 找一个生成树
	for(auto i:G){
		int z1=zx(i.x),z2=zx(i.y);
		if(z1==z2){
			V.push_back(i);
			continue;
		}
		f[z1]=z2;
		v[i.x].push_back({i.y,i.z});
		v[i.y].push_back({i.x,i.z});
	}
}
bin d[505];
void dfs(int now,int fa,bin val){// 计算 d[i]
	for(auto [i,vv]:v[now]){
		if(i==fa)continue;
		dfs(i,now,d[i]=(val^vv));
	}
}

int lstchg[1005],cnt;
bin p[1005];
int ins(bin x){// 插入线性基，注意一定要只算插入成功的
	for(int i=999;~i;i--){
		if(!x[i])continue;
		if(p[i].count()==0){p[i]=x;lstchg[++cnt]=i;return 1;}
		x=x^p[i];
	}
	return 0;
}
void back(){p[lstchg[cnt--]]=0;}// 直接清空上一次修改的位置
bin calc(){bin ans;for(int i=999;~i;i--)if(!ans[i])ans^=p[i];return ans;}// 计算最大值

int st[1005],ed[1005],s2b[1005],CNT;
three val[1005];

vector<three>a[4015];
#define ls (p<<1)
#define rs (p<<1|1)
#define mid (l+r>>1)
void put(int p,int l,int r,int L,int R,three val){
	if(l>=L&&r<=R){
		a[p].push_back(val);
		return;
	}
	if(L<=mid)put(ls,l,mid,L,R,val);
	if(R>mid)put(rs,mid+1,r,L,R,val);
}
void calc(int p,int l,int r){
	int sum=0;
	for(auto i:a[p])sum+=ins(d[i.x]^d[i.y]^i.z);
	l==r?(l<=q+1)&&(print(calc()),1):(calc(ls,l,mid),calc(rs,mid+1,r),1);
	while(sum--)back();
}
void solve(){
	// freopen(".in","r",stdin);freopen(".out","w",stdout);
	ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
	//your code down
	cin>>n>>m>>q;
	for(int i=1;i<=m;i++){
		int x,y;string s;
		cin>>x>>y>>s;
		bin z(s);
		G.push_back({x,y,z});
	}
	for(int i=1;i<=n;i++)f[i]=i;
	gettree();
	dfs(1,1,bin("0"));
	for(int i=1;i<=q;i++){
		string s,tmp;
		int k,x,y;
		cin>>s;
		if(s=="Add"){
			cin>>x>>y>>tmp;
			bin z(tmp);
			val[i]={x,y,z};
			st[i]=s2b[++CNT]=i;
		}
		if(s=="Cancel"){
			cin>>k;
			int bef=s2b[k];
			ed[bef]=i-1;
		}
		if(s=="Change"){// 这里的实现细节比较乱，st 和 ed 是每一条边出现的两端，s2b 是从 Add 编号变为所有操作编号，val 是这条边的值
			cin>>k>>tmp;
			bin z(tmp);
			int bef=s2b[k];
			ed[bef]=i-1;
			three v=val[bef];
			st[i]=i,s2b[k]=i;
			v.z=z,val[i]=v;
		}
	}
	for(int i=1;i<=q;i++) if(st[i]&&!ed[i]) ed[i]=q+1;
	for(int i=1;i<=q;i++){
		if(st[i]){
			st[i]++;ed[i]++;// 把 0~q+1 整体右移一个
			put(1,1,q+2,st[i],ed[i],val[i]);
		}
	}
	for(auto i:V) put(1,1,q+2,1,q+2,i);
	calc(1,1,q+2);
}

int main(){init();int T;for(T=1;T--;)solve();return 0;}
```

---

## 作者：fanypcd (赞：1)

给一个线段树分治维护生成树的 SB 做法。

刚刚做了 CF938G（这题加强版），然后受了很大的影响。

直接实现一下两个操作：

1. 动态维护两点之间任意一条异或路径长

2. 加边后找到（可能出现的）环长，加入线性基

对于 1. 可以用带权并查集维护一颗生成树（题目保证任意时刻连通），2. 则用并查集判断是否出现了环，这俩都不好直接进行删除，但是可以通过记录每次的操作来逐次撤回，所以上线段树分治。

对于询问操作，分治递归到当前时间时直接在线性基中查询即可。

上个 bitset，复杂度 $O(\frac{q\log q(\log n + L)}{w})$。

Code:

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define N 505
#define V 1000
int n, m, q;
struct edge
{
	int u, v;
	bitset<V> w;
};
inline void print(const bitset<V> &x)
{
	int flag = 1;
	for(int i = V - 1; i >= 0; i--)
	{
		flag &= (x[i] == 0);
		if(!flag)
		{
			cout << x[i];
		}
	}
	cout << endl;
	return;
}
struct linebase
{
	bitset<V> p[V];
	stack<int> st;
	inline void insert(bitset<V> x)
	{
		for(int i = V - 1; i >= 0; i--)
		{
			if(!x[i])
			{
				continue;
			}
			if(p[i].none())
			{
				st.push(i);
				p[i] = x;
				break;
			}
			x ^= p[i];
		}
		return;
	}
	inline bitset<V> query()
	{
		bitset<V> ret;
		ret.reset();
		for(int i = V - 1; i >= 0; i--)
		{
			if(!ret[i] && p[i][i])
			{
				ret ^= p[i];
			}
		}
		return ret;
	}
	inline void del(int size)
	{
		while((int)st.size() != size)
		{
			p[st.top()].reset();
			st.pop();
		}
		return;
	}
};
linebase LB;
struct mergeset
{
	int fa[N], dep[N];
	bitset<V> dis[N];
	struct node
	{
		int f1, f2, dep;
	};
	stack<node> st;
	inline void init()
	{
		for(int i = 1; i <= n; i++)
		{
			fa[i] = i;
			dep[i] = 1;
		}
		return;
	}
	inline int getfa(int x)
	{
		while(x != fa[x])
		{
			x = fa[x];
		}
		return x;
	}
	inline bitset<V> qdis(int x)
	{
		bitset<V> ret;
		ret.reset();
		while(x != fa[x])
		{
			ret ^= dis[x];
			x = fa[x];
		}
		return ret;
	}
	inline void merge(edge x)
	{
		int f1 = getfa(x.u), f2 = getfa(x.v);
		if(f1 == f2)
		{
			LB.insert(qdis(x.u) ^ qdis(x.v) ^ x.w);
			return;
		}
		if(dep[f1] < dep[f2])
		{
			swap(f1, f2);
		}
		st.push((node){f1, f2, dep[f1]});
		dis[f2] = qdis(x.u) ^ qdis(x.v) ^ x.w;
		fa[f2] = f1;
		dep[f1] = max(dep[f1], dep[f2] + 1);
		return;
	}
	inline void del(int size)
	{
		while((int)st.size() != size)
		{
			fa[st.top().f2] = st.top().f2;
			dep[st.top().f1] = st.top().dep;
			dis[st.top().f2] = 0;
			st.pop();
		}
		return;
	}
};
mergeset MS;
vector<edge> tmp[N << 3];
void update(int root, int l, int r, int L, int R, edge v)
{
	if(L <= l && r <= R)
	{
		tmp[root].emplace_back(v);
		return;
	}
	int mid = (l + r) >> 1;
	if(L <= mid)
	{
		update(root << 1, l, mid, L, R, v);
	}
	if(mid < R)
	{
		update(root << 1 | 1, mid + 1, r, L, R, v);
	}
	return;
}
void dfs(int root, int l, int r)
{
	int mem1 = MS.st.size(), mem2 = LB.st.size();
	for(auto x : tmp[root])
	{
		MS.merge(x);
	}
	if(l == r)
	{
		print(LB.query());
	}
	else
	{
		int mid = (l + r) >> 1;
		dfs(root << 1, l, mid), dfs(root << 1 | 1, mid + 1, r);
	}
	MS.del(mem1), LB.del(mem2);
	return;
}
edge e[N << 1];
int last[N << 1];
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin >> n >> m >> q;
	MS.init();
	int u, v;
	bitset<V> w;
	for(int i = 1; i <= m; i++)
	{
		cin >> u >> v >> w;
		MS.merge((edge){u, v, w});
	}
	print(LB.query());
	string opt;
	int cnt = 0, x;
	for(int i = 1; i <= q; i++)
	{
		cin >> opt;
		if(opt == "Add")
		{
			cnt++;
			cin >> e[cnt].u >> e[cnt].v >> e[cnt].w;
			last[cnt] = i;
		}
		else if(opt == "Cancel")
		{
			cin >> x;
			update(1, 1, q, last[x], i - 1, e[x]);
			last[x] = 0;
		}
		else
		{
			cin >> x >> w;
			update(1, 1, q, last[x], i - 1, e[x]);
			e[x].w = w;
			last[x] = i;
		}
	}
	for(int i = 1; i <= cnt; i++)
	{
		if(last[i])
		{
			update(1, 1, q, last[i], q, e[i]);
		}
	}
	if(q)
	{
		dfs(1, 1, q);
	}
	return 0;
}
```

---

## 作者：TYxxj (赞：1)

注意题意，它原先就有一个连通无向图，后来附加了一些边。

由于它是无向图，且每条边可以走多次，所以他的最大权值环的权值就是图中任选一些环权值异或起来的最大值，这应该很好理解，因为考虑走到一个环和走回去，来和去的路径权值异或起来为零，没有影响，所以如果当前异或一个图中的环权值可以更大的话，那么走一遍这个环后肯定是更优的（但是并不代表这题是贪心，听我讲）。

所以我们可以考虑用线性基。

把环的权值都放进线性基里，最后算出答案。

注意，并不是要把所有可以形成的环都放进去，由于线性基的性质，只需要保证放进去的所有环组成的子图内包含了原图的所有环就可以了，举个例子，假设这么一张图：

![](https://cdn.luogu.com.cn/upload/image_hosting/thdu9n2v.png)

那么我们只需要放入“$A-B-C-D$”、“$A-B-D$”、“$B-C-D$”三个环中的任意两个。

由于它放入的边要改权值，并且要删边，线性基不支持删边，所以（观察数据发现）我们可以用线段树分治，这样就可以把删边、改权值全都变成加边操作，只是多了个2的常数~~吧？~~

要维护每次加边后增加的环，看似有点麻烦，但是我们可以证明每加一次边最多只会在线性基里多加一个环，而且由于原本就是一个连通图，所以可以随便建一个生成树，然后把多余的边（每条可以对应一个环！）计算对应的环——即两端点连向lca的环的权值插入线性基，Add操作加的边也是一个道理。

最后由于它的二进制数有$10004$位，我们必须用$bitset$来打线性基，其中需要一些卡空间的技巧。

WARNING：要特判P=0的情况

```cpp
#include<cstdio>
#include<cstring>
#include<vector>
#include<stack>
#include<queue>
#include<algorithm>
#include<map>
#include<cmath>
#include<bitset>
#include<iostream>
#define MAXN 7005
#define LL long long
#define ULL unsigned LL
#define rg register
#define lowbit(x) (-(x) & (x))
#define ENDL putchar('\n')
#define DB double
#define bs bitset<1005>
using namespace std;
inline int read() {
	int f = 1,x = 0;
	char s = getchar();
	while(s < '0' || s > '9') {
		if(s == '-') f = -1;
		s = getchar();
	}
	while(s >= '0' && s <= '9') {
		x = x * 10 - '0' + s;
		s = getchar();
	}
	return x * f;
}
struct it {
	int v,id;
	it() {
		id = v = 0;
	}
	it(int V,int I) {
		v = V;
		id = I;
	}
};
int n,m,i,j,s,o,k;
bs w0[MAXN],w[MAXN],sum[MAXN];
int u[MAXN],v[MAXN],tm[MAXN];
vector<it> g[MAXN];
int f[MAXN],d[MAXN],fe[MAXN];
bool vis[MAXN];
bs ans[MAXN],lc[MAXN];
inline int highbit(bs x) {
	int l = 0,r = 1000,mid;
	while(l^r) {
		mid = (l + r) >> 1;
		if((x>>(mid+1)).none()) r=mid;
		else l=mid+1;
	}
	return l;
}
inline void Cout(bs x) {
	int le = highbit(x);
	for(int i = le; i >= 0; i --) {
		putchar(x.test(i) ? '1':'0');
	}
	return ;
}
struct XXJ {
	bs F[1202];
	int cnt;
	XXJ() {
		cnt = 0;
	}
	inline void ins(bs x) {
		while(x.any()) {
			int j = highbit(x);
			if(F[j].none()) {
				F[j] = x;
				cnt ++;
				return ;
			}
			x ^= F[j];
		}
	}
} xxj[35];
vector<bs> tre[MAXN<<2];
inline void addtree(int a,int l,int r,int al,int ar,bs y) {
	if(al > r || ar < l) return ;
	if(al >= l && ar <= r) {
		tre[a].push_back(y);
		return ;
	}
	int mid = al + ar >> 1;
	addtree(a<<1,l,r,al,mid,y);
	addtree(a<<1|1,l,r,mid+1,ar,y);
	return ;
}
inline void pushdown(int a,int al,int ar,int id) {
	for(int i = 0; i < tre[a].size(); i ++) {
		xxj[id].ins(tre[a][i]);
	}
	if(al == ar) {
		bs as;
		for(int i = 1000; i >= 0; i --) {
			if(xxj[id].F[i].any() && !as.test(i)) {
				as = as ^ xxj[id].F[i];
			}
		}
		ans[al] = as;
		return ;
	}
	xxj[id+1] = xxj[id];
	int mid = al + ar >> 1;
	pushdown(a<<1,al,mid,id+1);
	xxj[id+1] = xxj[id];
	pushdown(a<<1|1,mid+1,ar,id+1);
	return ;
}
inline void dfs(int x,int fa,int ie) {
	vis[x] = 1;
	d[x] = d[fa] + 1;
	fe[x] = ie;
	f[x] = fa;
	sum[x] = sum[fa] ^ w0[ie];
	for(int i = 0; i < g[x].size(); i ++) {
		if(!vis[g[x][i].v]) {
			dfs(g[x][i].v,x,g[x][i].id);
		} else if(g[x][i].v != fa) {
			xxj[0].ins(sum[x] ^ w0[g[x][i].id] ^ sum[g[x][i].v]);
		}
	}
}
signed main() {
	string ss;
	n = read();
	m = read();
	k = read();
	for(int i = 1; i <= m; i ++) {
		s = read();
		o = read();
		cin>>ss;
		bs ww(ss);
		w0[i] = ww;
		g[s].push_back(it(o,i));
		g[o].push_back(it(s,i));
	}
	dfs(1,0,0);
	int kk = 0;
	for(int i = 1; i <= k; i ++) {
		char S[15];
		scanf("%s",S + 1);
		if(S[1] == 'A') {
			kk ++;
			u[kk] = s = read();
			v[kk] = o = read();
			cin>>ss;
			lc[kk] = sum[s] ^ sum[o];
			bs ww(ss);
			w[kk] = ww;
			tm[kk] = i;
		} else if(S[2] == 'h') {
			s = read();
			cin>>ss;
			bs ww(ss);
			addtree(1,tm[s],i-1,1,k,lc[s] ^ w[s]);
			w[s] = ww;
			tm[s] = i;
		} else {
			s = read();
			addtree(1,tm[s],i-1,1,k,lc[s] ^ w[s]);
			tm[s] = 0;
		}
	}
	for(int i = 1; i <= kk; i ++) {
		if(tm[i]) {
			addtree(1,tm[i],k,1,k,lc[i] ^ w[i]);
			tm[i] = 0;
		}
	}
	if(1) {
		bs as;
		for(int i = 1000; i >= 0; i --) {
			if(xxj[0].F[i].any() && !as.test(i)) {
				as = as ^ xxj[0].F[i];
			}
		}
		Cout(as);
		ENDL;
	}
	if(k < 1) return 0;
	pushdown(1,1,k,0);
	for(int i = 1; i <= k; i ++) {
		Cout(ans[i]);
		ENDL;
	}
	return 0;
}
```

---


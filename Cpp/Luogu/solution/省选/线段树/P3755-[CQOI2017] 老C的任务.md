# [CQOI2017] 老C的任务

## 题目描述

老 C 是个程序员。


最近老 C 从老板那里接到了一个任务——给城市中的手机基站写个管理系统。作为经验丰富的程序员，老 C 轻松地完成了系统的大部分功能，并把其中一个功能交给你来实现。

由于一个基站的面积相对于整个城市面积来说非常的小，因此每个的基站都可以看作坐标系中的一个点，其位置可以用坐标 $(x,y)$ 来表示。此外，每个基站还有很多属性，例如高度、功率等。运营商经常会划定一个区域，并查询区域中所有基站的信息。

现在你需要实现的功能就是，对于一个给定的矩形区域，回答该区域中（包括区域边界上的）所有基站的功率总和。如果区域中没有任何基站，则回答 $0$。


## 说明/提示

对于第 $1\sim2$ 个测试点，$1≤n,m≤100$；

对于第 $3\sim5$ 个测试点，$1≤n≤50000,1≤m≤10000$；

对于第 $6\sim10$ 个测试点，$1≤n≤100000,1≤m≤100000$，数据有梯度；

对于所有测试点，$-2^{31}\le x_i,y_i,p_i,x_1,y_1,x_2,y_2<2^{31},x_1\le x_2,y_1\le y_2$。


## 样例 #1

### 输入

```
4 2   
0 0 1 
0 1 2  
2 2 4  
1 0 8  
0 0 1 1 
1 1 5 6 ```

### 输出

```
11
4```

## 样例 #2

### 输入

```
3 2
-100 0 16 
1 -10 32 
1000 100 64 
0 0 0 1 
-1000 -1000 10000 10000 ```

### 输出

```
0
112```

# 题解

## 作者：niiick (赞：14)

CDQ分治的题解好少啊，明明是二维偏序，为啥楼下CDQ硬是求了个三维

由于所有基站都是在一开始给出，相当于修改操作的时间戳都在询问前面(即每个基站都有可能对询问产生贡献)，这样其实就可以省略时间戳，直接做二维偏序

具体来说就是，x,y坐标分别为一二关键字排序，**遇到相同坐标令询问排后面**

询问拆成四个的老套路就不讲了，二维偏序不用树状数组，所以也不用离散化，最后注意要开long long

```cpp
#include<iostream>
#include<cmath>
#include<algorithm>
#include<queue>
#include<cstring>
#include<cstdio>
using namespace std;
typedef long long lt;
 
lt read()
{
    lt f=1,x=0;
    char ss=getchar();
    while(ss<'0'||ss>'9'){if(ss=='-')f=-1;ss=getchar();}
    while(ss>='0'&&ss<='9'){x=x*10+ss-'0';ss=getchar();}
    return f*x;
}

const int maxn=1000010;
int n,m,tot;
struct node{lt x,y,p,opt,k,id,ans;}a[maxn],b[maxn];
lt ans[maxn];

bool cmp(node a,node b)
{
    if(a.x!=b.x) return a.x<b.x;
    else if(a.y!=b.y) return a.y<b.y;
    else return a.opt<b.opt;
}

void CDQ(int ll,int rr)
{
    if(ll==rr) return;
    int mid=ll+rr>>1;
    CDQ(ll,mid); CDQ(mid+1,rr);
 
    int t1=ll,t2=mid+1,p=ll; lt cnt=0;
    while(t2<=rr)
    {
        while(a[t1].y<=a[t2].y&&t1<=mid){
            if(a[t1].opt==1) cnt+=a[t1].p;
            b[p++]=a[t1++];
        }
        if(a[t2].opt==2) a[t2].ans+=cnt;
        b[p++]=a[t2++];
    }
 
    while(t1<=mid) b[p++]=a[t1++];
    while(t2<=rr) b[p++]=a[t2++];
    for(int i=ll;i<=rr;++i) a[i]=b[i];
}

int main()
{
    n=read();m=read();
    for(int i=1;i<=n;++i)
    {
        int x=read(),y=read();lt p=read();
        a[++tot]=(node){x,y,p,1,0,0,0};
    }

    for(int i=1;i<=m;++i)
    {
        int aa=read(),b=read(),c=read(),d=read();
        a[++tot]=(node){c,d,0,2,1,i,0};
        a[++tot]=(node){aa-1,b-1,0,2,1,i,0};
        a[++tot]=(node){aa-1,d,0,2,-1,i,0};
        a[++tot]=(node){c,b-1,0,2,-1,i,0};
    }
    
    sort(a+1,a+1+tot,cmp);

    CDQ(1,tot);
    for(int i=1;i<=tot;++i)
    if(a[i].opt==2) ans[a[i].id]+=a[i].k*a[i].ans;
    
    for(int i=1;i<=m;++i)
    printf("%lld\n",ans[i]);
    return 0;
}
```


---

## 作者：liangbowen (赞：13)

## 前言

[题目传送门！](https://www.luogu.com.cn/problem/P3755)

[更好的阅读体验？](https://www.cnblogs.com/liangbowen/p/16798839.html)

为啥要用分块呀，cdq 分治好写，而且跑得比分块快！

前置知识：三维偏序模版。

## 思路

记 $s_{i, j}$ 表示：对角坐标为 $(-\infty, -\infty)$ 到 $(i, j)$ 的矩形内的点权之和。

那么类似二维前缀和：对角坐标为 $(x1,y1)$ 到 $(x2, y2)$ 的矩形内的点权之和，可以表示成 $s_{x2,y2} -s_{x1-1,y2} - s_{x2,y1-1} + s_{x1-1,y1-1}$。

这样，我们发现，**每个询问可以拆成四个点**，用这四个点的答案即可求出询问。我们称这个拆出来的点叫**查询点**。

考虑转化为偏序问题（这样能用 cdq 求解）。

对于一个属性，记录 $a,b$ 表示 $s_{i,j}$ 中的 $i$ 与 $j$。为了方便，再记录 $c$ 表示：当前属性是普通点还是查询点。

那么，若属性 $X$ 可以计算 $Y$ 的贡献入内，需要满足：

$\begin{cases}Y_a \le X_a\\Y_b \le X_b\\Y_c < X_c\end{cases}$

前面两个限制表示**下标要包含在矩形内**才行。第三个限制表示 $X$ 是查询点 且 $Y$ 是普通点。

然后就是一个三维偏序板子了，用板子的 $O(n \log^2 n)$ 求解也能通过。但是我们可以做到 $O(n \log n)$。

这里有一个细节，$c$ 显然只能是 $0$ 或 $1$。

那么我们不必使用树状数组了，使用一个变量记录即可。

具体参考代码。

## 完整代码

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;
typedef long long LL;
const int N = 5e5 + 5;
struct Data {
	int a, b, c, k; //c: 1代表点，0代表查询的点 
	LL sum;
	int id;
} x[N], t[N];
bool operator == (Data p, Data q) {return p.a == q.a && p.b == q.b && p.c == q.c;}
bool cmp(Data p, Data q)
{
	if (p.a != q.a) return p.a < q.a;
	if (p.b != q.b) return p.b < q.b;
	return p.c < q.c;
}
void MergeSort(int l, int r) //三维偏序板子
{
	if (l >= r) return;
	int mid = (l + r) >> 1;
	MergeSort(l, mid), MergeSort(mid + 1, r);
	int i = l, j = mid + 1, cur = 0;
	LL sum = 0; //由于c只有0/1，所以用变量即可，省略树状数组
	while (i <= mid && j <= r)
		if (x[i].b <= x[j].b) sum += !x[i].c * x[i].k, t[++cur] = x[i], i++;
		else x[j].sum += sum, t[++cur] = x[j], j++;
	while (i <= mid) sum += x[i].c * x[i].k, t[++cur] = x[i], i++;
	while (j <= r) x[j].sum += sum, t[++cur] = x[j], j++;
	for (i = l, j = 1; j <= cur; i++, j++) x[i] = t[j];
}
LL ans[N];
int main()
{
	int n, m;
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= n; i++) //输入部分就是按照上文的建模来的
	{
		scanf("%d%d%d", &x[i].a, &x[i].b, &x[i].k);
		x[i].c = x[i].sum = 0;
		x[i].id = i;
	}
	int cur = n;
	for (int i = 1; i <= m; i++)
	{
		int x1, y1, x2, y2;
		scanf("%d%d%d%d", &x1, &y1, &x2, &y2);
		x[++cur] = (Data){x2, y2, 1, 1}, x[cur].id = i; //拆成四个点
		x[++cur] = (Data){x1 - 1, y2, 1, -1}, x[cur].id = i;
		x[++cur] = (Data){x2, y1 - 1, 1, -1}, x[cur].id = i;
		x[++cur] = (Data){x1 - 1, y1 - 1, 1, 1}, x[cur].id = i;
	}
	sort(x + 1, x + cur + 1, cmp); //由于c肯定不同，所以不用去重 
	MergeSort(1, cur);
	for (int i = 1; i <= cur; i++)
		if (x[i].c)
			ans[x[i].id] += x[i].sum * x[i].k;
	for (int i = 1; i <= m; i++) printf("%lld\n", ans[i]);
	return 0;
}
```

希望能帮助到大家！

---

## 作者：Diaоsi (赞：11)

[[CQOI2017]老C的任务](https://www.luogu.com.cn/problem/P3755)

离线+树状数组

怎么感觉大家写的都好麻烦...二维偏序不是用一个树状数组就可以搞定了吗...

具体做法就是将坐标离散化后按照第一维排序，按顺序扫描。

假设当前二元组的坐标为 $(a,b)$ ，我们需要知道有多少对 $(i,j)$ 满足 $i \leq a,j \leq b$ ，由于第一维已经是有序的，所以只需要看在排序之后序列中当前二元组之前有多少个二元组满足其第二维的值小于当前二元组第二维的值即可。

于是我们可以用树状数组来维护第二维，当扫描到一个二元组时，在树状数组上其第二维的位置加一。

查询时树状数组上小于当前第二维的值的数的总和即代表满足 $i \leq a,j \leq b$ 的点的个数。

回到这题，可以把功率当成该坐标上有 $p_i$ 个点，直接在树状数组上加 $p_i$ 即可，至于询问，可以将询问离线下来然后拆成四个二元组，然后按照类似于二维前缀和的方式容斥。

排序上有一些小细节，可以看代码。

既然你能找到这题，我相信你能瞬间做出来的。

```Code:```
```cpp
#include<bits/stdc++.h>
typedef long long LL;
typedef long double LD;
using namespace std;
const LL N=1000010,M=5000010,INF=0x3f3f3f3f;
inline LL max(LL x,LL y){return x>y?x:y;}
inline LL min(LL x,LL y){return x<y?x:y;}
inline void swap(LL &x,LL &y){x^=y^=x^=y;}
LL n,m,num,cnt,b[N],c[N],ans[N];
struct query{
	LL x,y;
	LL id,val,sign,op;
}q[N];
bool cmp(query a,query b){
	return (a.x!=b.x)?a.x<b.x:a.op<b.op;
}
void add(LL x,LL y){
	for(;x<N;x+=x&-x)c[x]+=y;
}
LL ask(LL x){
	LL res=0;
	for(;x;x-=x&-x)res+=c[x];
	return res;
}
int main(){
	scanf("%lld%lld",&n,&m);
	for(LL i=1;i<=n;i++){
		LL x,y,z;
		scanf("%lld%lld%lld",&x,&y,&z);
		b[++cnt]=x,b[++cnt]=y;
		q[++num]=(query){x,y,0,z,0,0};
	}
	for(LL i=1;i<=m;i++){
		LL x1,y1,x2,y2;
		scanf("%lld%lld%lld%lld",&x1,&y1,&x2,&y2);
		b[++cnt]=x2,b[++cnt]=y2;
		b[++cnt]=x1-1,b[++cnt]=y1-1;
		q[++num]=(query){x2,y2,i,0,1,1};
		q[++num]=(query){x1-1,y2,i,0,-1,1};
		q[++num]=(query){x2,y1-1,i,0,-1,1};
		q[++num]=(query){x1-1,y1-1,i,0,1,1};
	}
	sort(b+1,b+cnt+1);
	cnt=unique(b+1,b+cnt+1)-b-1;
	for(LL i=1;i<=num;i++){
		q[i].x=lower_bound(b+1,b+cnt+1,q[i].x)-b;
		q[i].y=lower_bound(b+1,b+cnt+1,q[i].y)-b;
	}
	sort(q+1,q+num+1,cmp);
	for(LL i=1;i<=num;i++)
		if(!q[i].op)add(q[i].y,q[i].val);
		else ans[q[i].id]+=q[i].sign*ask(q[i].y);	
	for(LL i=1;i<=m;i++)
		printf("%lld\n",ans[i]);
	return 0;
}
```


---

## 作者：StillEmpty (赞：10)

**良心主席树题解求通过qwq**

先举个例子，带着例子理解问题：

![example](https://cdn.luogu.com.cn/upload/image_hosting/h4yay2r8.png)

1. 离散化 $y_1, y_2, ..., y_n$ 为 $y'_1, y'_2, ..., y'_n$ ；

2. 将每个点按 $x$ 排序；

3. 如图中一样，画红色竖线分割这张图（注意竖线数量不一定等于 $n$，图中，版本 $8$ 的竖线，两个点在一根竖线上）。

4. 建立不同版本的线段树（即可持久化）对应图中的每根竖线。图中，每颗线段树表达一个 $[1, 9]$ 的序列， 维护区间和。**每颗线段树表达的序列中的第 $i$ 个数的值 /为/ $y'$ 为 $i$ 且在这颗线段树对应的竖线的左侧（或重合）的点的权值和**（这句话最重要！有点拗口，可以结合图中的绿字理解）。

5. **线段树所维护的序列中的值类似于前缀和，用两个版本的线段树维护的值相减可以求出这两个版本的线段树对应的竖线之间的点的权值和。** 想一想，你会发现图中，版本 $6$ 的线段树的 $[3, 7]$ 区间和减去版本 $3$ 的 $[3, 7]$ 区间和就是紫色框中的点的权值和。

6. 最后一步，在询问时，我们要将形如黄色框的询问转换为形如紫色框的询问。可以用二分的方法，这个你肯定会。

 _P.S. 例子中假设每个点的权值都为 $\mathit 1$。_
 
代码：

```cpp
#include <bits/stdc++.h>
using namespace std;

struct t {
    int no;
    long long val;
    bool operator<(const t &x) const {
        return val < x.val;
    }
};
struct pt {
    int rky;
    long long x, val;
    bool operator<(const pt &b) const {
        return x < b.x;
    }
};
struct node {
    int l, r;
    long long sum;
    node *lson, *rson;
};
struct line {
    long long x;
    node *root;
    line() {}
    line(long long x) {
        this->x = x;
    }
    bool operator<(const line &b) const {
        return x < b.x;
    }
};

const int N = 1e5;
int n, m, rksy, k, oriy[N + 1];
pt p[N + 1];
t rawy[N + 1];
line l[N + 1]; // 变长数组，表示竖线，长度为k

node *init(int l, int r) { // 建立版本0树
    node *o = new node{l, r, 0ll};
    if(l != r) {
        int mid = (l + r) / 2;
        o->lson = init(l, mid);
        o->rson = init(mid + 1, r);
    }
    return o;
}
node *build(node *p, int pos, long long val) { // 基于前一版本树建立新树
    if(pos < p->l || pos > p->r) {
        return p;
    }
    node *o = new node{p->l, p->r, p->sum + val};
    if(o->l != o->r) {
        o->lson = build(p->lson, pos, val), o->rson = build(p->rson, pos, val);
    }
    return o;
}
long long query(node *o, int l, int r) { // 区间和
    if(o->l > r || o->r < l) {
        return 0ll;
    }
    if(o->l >= l && o->r <= r) {
        return o->sum;
    }
    return query(o->lson, l, r) + query(o->rson, l, r);
}

int main() {
    ios::sync_with_stdio(false);
    cin >> n >> m;
    for(int i = 1; i <= n; i++) {
        rawy[i].no = i;
        cin >> p[i].x >> rawy[i].val >> p[i].val;
    }
    // 离散化
    rawy[0].val = LLONG_MIN;
    sort(rawy + 1, rawy + n + 1);
    for(int i = 1; i <= n; i++) {
        if(rawy[i].val != rawy[i - 1].val) {
            rksy++;
            oriy[rksy] = rawy[i].val;
        }
        p[rawy[i].no].rky = rksy;
    }

    sort(p + 1, p + n + 1);
    l[0].x = LLONG_MIN, p[0].x = LLONG_MIN, l[0].root = init(1, rksy);
    for(int i = 1; i <= n; i++) {
        if(p[i].x != p[i - 1].x) {
            k++;
            l[k].x = p[i].x, l[k].root = build(l[k - 1].root, p[i].rky, p[i].val);
        }
        else {
            l[k].root = build(l[k].root, p[i].rky, p[i].val);
        }
    }

    for(int i = 1; i <= m; i++) {
        long long x1, y1, x2, y2;
        cin >> x1 >> y1 >> x2 >> y2;
        if(x1 > l[k].x || x2 < l[1].x || y1 > oriy[rksy] || y2 < oriy[1]) {
            cout << 0 << endl;
            continue;
        }
        // 这里的二分有个小trick，如果找不到对应的数返回值是末指针，这么写正好还是对的（可以理解为最后放了个LLONG_MAX）。
        long long ly = lower_bound(oriy + 1, oriy + rksy + 1, y1) - oriy, ry = upper_bound(oriy + 1, oriy + rksy + 1, y2) -oriy - 1;
        cout << query((upper_bound(l + 1, l + k + 1, line(x2)) - 1)->root, ly, ry) - query((lower_bound(l + 1, l + k + 1, line(x1)) - 1)->root, ly, ry) << endl;
    }
    return 0;
}
```

---

## 作者：_lbw_ (赞：7)

注：这篇题解适合有一些基础的同学学习。对于算法的细节不会仔细说明。

问题为给定 $n$ 个整点，$m$ 次矩形查和。

定义 $\textsf{k-side}$ 矩形为二维平面中有 $\textsf{k }$条边的矩形。

先离散化，然后：

$F_1:$

差分成两个 $\textsf{3-side}$ 矩形，然后扫描线扫只有一个限制那一维，转化成单点加区间查询，树状数组解决。

时间 $\mathcal{O}(n\log n)$，空间 $\mathcal{O}(n)$.

$F_2:$

容易想到前缀和，但是空间会炸，于是考虑不会炸的主席树，按任意一维建立主席树。于是在主席树上区间查询。

时间 $\mathcal{O}(n\log n)$，空间 $\mathcal{O}(n\log n)$.

$F_3:$

差分成四个 $\textsf{2-side}$ 矩形，然后转化为二维数点，$\textsf{cdq}$ 分治或树状数组均可 。

时间 $\mathcal{O}(n\log n)$，空间 $\mathcal{O}(n)$.

$F_4:$

容易想到二维数据结构，考虑二维树状数组。

空间会爆，将用到的点离散化后再搞。可以支持动态加点。

时间 $\mathcal{O}(n\log^2 n)$，空间 $\mathcal{O}(n\log^2 n)$. 

$F_5:$

容易想到二维数据结构，考虑二维线段树。

空间不会爆。可以支持动态加点。

时间 $\mathcal{O}(n\log^2 n)$，空间 $\mathcal{O}(n\log^2 n)$. 

$F_6:$ $\textsf{kd-tree}$ ……

打住，对于 $F_1,F_3$，它们本质相同。而 $F_1$ 的普适性会稍微广。

而 $F_4,F_5,F_6$ 则是增加了时间一维，使用三维偏序做二维偏序，大材小用。

$F_2$ 可以在空间增加一个 $\log$ 的条件下支持在线。

在本题限制下，使用 $F_3$ 是最优选择，给出代码：

```cpp
const int maxn = 5e5+5;
ll n,m,b[maxn],cnt,Qc,ans[maxn];
struct node{ll x,y,id,mul,v;}qwq[maxn];
struct BIT{
	ll c[maxn],ans;
	IV add(ll pos,ll val){for(;pos<=cnt;pos+=pos&-pos)c[pos]+=val;}
	I query(ll pos){ans=0;for(;pos;pos-=pos&-pos)ans+=c[pos];return ans;}
}bit;
I Q(ll x){return lower_bound(b+1,b+1+cnt,x)-b;}
int main(){	
	Qc=n=read();m=read();
	F(i,1,n)qwq[i].x=read(),qwq[i].y=read(),qwq[i].id=0,qwq[i].v=read();
	F(i,1,m){
		ll x1=read(),y1=read(),x2=read(),y2=read();
		qwq[++Qc]=node{x2,y2,i,1,0};
		qwq[++Qc]=node{x2,y1-1,i,-1,0};
		qwq[++Qc]=node{x1-1,y2,i,-1,0};
		qwq[++Qc]=node{x1-1,y1-1,i,1,0};
	}
	F(i,1,Qc)b[i]=qwq[i].y;sort(b+1,b+1+Qc);cnt=unique(b+1,b+1+Qc)-b-1;
	sort(qwq+1,qwq+1+Qc,[](node A,node B){return A.x==B.x?A.id<B.id:A.x<B.x;});
	F(i,1,Qc)
		!qwq[i].id?bit.add(Q(qwq[i].y),qwq[i].v),0:
		ans[qwq[i].id]+=bit.query(Q(qwq[i].y))*qwq[i].mul;
	F(i,1,m)printf("%lld\n",ans[i]);return 0;
}
```




---

## 作者：SunnyYuan (赞：6)

如果询问 $x_1, y_1, x_2, y_2$，

那么询问

$(x_2, y_2)$,

$(x_2, y_1 - 1)$,

$(x_1 - 1, y_2)$

$(x_1 - 1, y_1 - 1$),

这些点到原点（不一定是 $(0, 0)$，有可能有负数）的和。

设其结果分别为 $a, b, c, d$，那么最后结果为 $a - b - c + d$（二维前缀和原理）。

问题成功转化。

---

设结构体

```
struct Node {
	int x, y;		// 位置
	int z;			// 值
};
```

为基本信息。

我们在此基础上加一个 $type$ 和 $res$，

如果 $type$ 为 $1$ 就表示要询问 $(x, y)$ 的二维前缀和，结果保存在 $res$ 中。

如果 $type$ 为 $0$ 表示 $(x, y)$ 为一个基站，其功率为 $z$。

---

对于 $type_i$ 为 $1$ 的部分，

使用 CDQ 分治统计：

$type_j < type_i$ (即 $type_j$ 为 $0$)

$x_j \leq x_i$

$y_j \leq y_i$

的各个位置的和即可。

注意开`long long`。

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
#include <unordered_map> 

#define int long long 

using namespace std;

const int N = 500010;

struct Node {
	int x, y, z;
	int type;
	int res;
}a[N], tmp[N];

bool cmp(const Node a, const Node b) {
	if (a.x != b.x) return a.x < b.x;
	if (a.y != b.y) return a.y < b.y;
	return a.type < b.type;
}

int n, m;

void cdq(int l, int r) {
	if (l == r) return;
	int mid = (l + r) / 2;
	cdq(l, mid);
	cdq(mid + 1, r);
	
	int sum = 0;
	
	int p = l, q = mid + 1, tot = l;
	while (p <= mid && q <= r) {
		if (a[p].y <= a[q].y) {
			if (!a[p].type) sum += a[p].z;
			tmp[tot++] = a[p++];
		}
		else {
			if (a[q].type) a[q].res += sum;
			tmp[tot++] = a[q++];
		}
	}
	while (p <= mid) {
		if (!a[p].type) sum += a[p].z;
		tmp[tot++] = a[p++];
	}
	while (q <= r) {
		if (a[q].type) a[q].res += sum;
		tmp[tot++] = a[q++];
	}
	for (int i = l; i <= r; i++) a[i] = tmp[i];
}

struct Query {
	int x1, y1;
	int x2, y2;
}query[N];

unordered_map<int, unordered_map<int, int> > res_a;

signed main() {
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	
	cin >> n >> m;
	for (int i = 1; i <= n; i++) {
		cin >> a[i].x >> a[i].y >> a[i].z;
		a[i].type = 0;
		a[i].res = 0;
	}
	int tot = n;
	for (int i = 1; i <= m; i++) {
		cin >> query[i].x1 >> query[i].y1 >> query[i].x2 >> query[i].y2;
		a[++tot] = {query[i].x1 - 1, query[i].y1 - 1, 0, 1, 0};
		a[++tot] = {query[i].x2, query[i].y2, 0, 1, 0};
		a[++tot] = {query[i].x2, query[i].y1 - 1, 0, 1, 0};
		a[++tot] = {query[i].x1 - 1, query[i].y2, 0, 1, 0};
	}
	sort(a + 1, a + tot + 1, cmp);
	cdq(1, tot);
	for (int i = 1; i <= tot; i++) {
		if (a[i].type) {
			res_a[a[i].x][a[i].y] = a[i].res;
		}
	}
	for (int i = 1; i <= m; i++) {
		int x1 = query[i].x1, y1 = query[i].y1;
		int x2 = query[i].x2, y2 = query[i].y2;
		
		int ans = res_a[x2][y2] - res_a[x2][y1 - 1] - res_a[x1 - 1][y2] + res_a[x1 - 1][y1 - 1];
		cout << ans << '\n';
	}
	return 0;
}
```

---

## 作者：Vocalise (赞：5)

补充一下主席树的解法。

首先是离散化。对于 $x$ 坐标只要按其将所有点排序即可，因为后面不关心它是多少。 而 $y$ 坐标就正经地离散化了，它的值域变成 $[1,n]$。

然后，按照 $x$ 坐标从小到大插入每一个点，具体来说，我们把 $x$ 轴看作时间轴， $y$ 轴看作值域轴（线段树上的轴）。对于每一个点 $(x,y,p)$ 对其在 $y$ 值处增加 $p$。这样它就代表了之前所有点在该处值的前缀和。

预处理就到这里，两个过程都是 $O(n\log n)$ 的。

然后对于一个询问 $(x1,y1,x2,y2)$。

将 $x1,x2$ 分别在原数组中二分一下，将 $y1,y2$ 在离散化 $y$ 的数组中二分一下。

然后分别在标号为 $x2$ 和 $x1-1$ 的树上询问 $[y1,y2]$ 的区间作差即可。 时间是 $O(m\log n)$。

总时间复杂度为 $O((n+m)\log n)$。

```cpp
#include <cstdio>
#include <iostream>
#include <cstring>
#include <algorithm>

typedef long long ll;
const int MAXN = 100001;
const int MAXNODE = MAXN * 20;

inline int read() {
	int x = 0, f = 1; char ch = getchar();
	while(ch > '9' || ch < '0') { if(ch == '-') f = -1; ch = getchar(); }
	do x = x * 10 + ch - 48, ch = getchar(); while(ch >= '0' && ch <= '9');
	return x * f;
}

struct Sta
{
	int x,y,p;
	Sta(int _x = 0,int _y = 0) : x(_x), y(_y) {}
	friend bool operator <(const Sta &a,const Sta &b) {
		return a.x < b.x;
	}
};

int n,m,y[MAXN]; Sta p[MAXN];
int rt[MAXNODE],lc[MAXNODE],rc[MAXNODE],cnt; ll s[MAXNODE];

void Build(int &k,int l,int r) {
	k = ++cnt;
	if(l == r) return;
	int mid = (l + r) >> 1;
	Build(lc[k],l,mid);
	Build(rc[k],mid + 1,r);
	return;
}

void Update(int &k,int pr,int l,int r,int x,int p) {
	k = ++cnt, s[k] = s[pr] + p;
	if(l == r) return;
	int mid = (l + r) >> 1;
	if(x <= mid) rc[k] = rc[pr], Update(lc[k],lc[pr],l,mid,x,p);
	else lc[k] = lc[pr], Update(rc[k],rc[pr],mid + 1,r,x,p);
	return;
}

ll Query(int k,int l,int r,int x,int y) {
	if(l > y || r < x) return 0ll;
	if(l >= x && r <= y) return s[k];
	int mid = (l + r) >> 1;
	return Query(lc[k],l,mid,x,y) + Query(rc[k],mid + 1,r,x,y);
}

int main() {
	n = read(), m = read();
	for(int i = 1;i <= n;i++) p[i].x = read(), p[i].y = read(), p[i].p = read();
	std::sort(p + 1,p + 1 + n);
	for(int i = 1;i <= n;i++) y[i] = p[i].y;
	std::sort(y + 1,y + 1 + n);
	int ny = std::unique(y + 1,y + 1 + n) - y - 1;
	for(int i = 1;i <= n;i++) p[i].y = std::lower_bound(y + 1,y + 1 + ny,p[i].y) - y;
	Build(rt[0],1,ny);
	for(int i = 1;i <= n;i++) Update(rt[i],rt[i - 1],0,ny,p[i].y,p[i].p);
	while(m--) {
		int x1 = read(), y1 = read(), x2 = read(), y2 = read();
		x1 = std::lower_bound(p + 1,p + 1 + n,Sta(x1,0)) - p;
		x2 = std::upper_bound(p + 1,p + 1 + n,Sta(x2,0)) - p - 1;
		y1 = std::lower_bound(y + 1,y + 1 + ny,y1) - y;
		y2 = std::upper_bound(y + 1,y + 1 + ny,y2) - y - 1;
		std::printf("%lld\n",Query(rt[x2],0,ny,y1,y2) - Query(rt[x1 - 1],0,ny,y1,y2));
	}
	return 0;
}

```

主席树本身大概是容易理解的。这题其实是一个**二维数点**的模板题，即在相当大的平面空间上给出若干点并询问矩形中的点数（或点权和）的问题。

---

## 作者：Sor4 (赞：5)

看上去是二维树状数组，但是空间无论如何也开不下。

然而发现没有修改操作只有询问，我们考虑离线处理。

把坐标离散化后按x坐标排序，把y坐标加入树状数组。

之后用类似扫描线的方法从x轴上面扫，把一个矩形分成四个点来统计答案。


代码...离散化写得真的烂...










    
    


    
    
    
        
        
        
        
        
        
        
        
        
        
    

    
    
    


        
    
    
    
```cpp
#include <cstdio>
#include <algorithm>
#define Rep( i , _begin , _end ) for(int i=(_begin),i##_END=(_end);i<=(i##_END);i++)
#define For( i , _begin , _end ) for(int i=(_begin),i##_END=(_end);i!=(i##_END);i++)
#define Lop( i , _begin , _end ) for(int i=(_begin),i##_END=(_end);i>=(i##_END);i--)
#define Dnt( i , _begin , _end ) for(int i=(_begin),i##_END=(_end);i!=(i##_END);i--)
using std :: max;
using std :: min;
typedef long long LL;
const int maxx = 800000 + 25;
int n,m,x,y,z,cnt,tot,x1,x2,y1,y2,num,lx,ly;
int a[maxx],b[maxx],val[maxx],u[maxx],v[maxx];
LL  T[maxx],ans[maxx];
struct Node{
    int x,y;
    int f,id;
    int v;
}A[maxx];
namespace Zyerstream{
    const int L = 1<<15;
    char buffer[L],*_,*__;
    inline char Getchar(){
        if(_ == __) __ = (_ = buffer) + fread(buffer,1,L,stdin);
        return _ == __? EOF : *_ ++;
    }
    template <class T> inline void read(T &in){
        int f = 1;char __;
        for(__ = Getchar();__ > '9' || __ < '0';__ = Getchar()) if(__ == '-') f = -1;
        for(in = 0;__ >= '0' && __ <= '9';__ = Getchar()) in = (in<<1) + (in<<3) + __ - '0';
        in *= f;
    }
}
namespace init{
    using namespace Zyerstream;
    bool cmp(Node a,Node b){
        return a.x == b.x? a.id < b.id : a.x < b.x;
    }
    int main(){
        scanf("%d%d",&n,&m);
        Rep( i , 1 , n ) read(x),read(y),read(z),a[++cnt] = x,b[cnt] = y,val[cnt] = z,u[cnt] = a[cnt],v[cnt] = b[cnt];
        Rep( i , 1 , m ){
            read(x1);read(y1);read(x2);read(y2);
            a[++cnt] = x1;b[cnt] = y1;u[cnt] = a[cnt];v[cnt] = b[cnt];
            a[++cnt] = x2;b[cnt] = y2;u[cnt] = a[cnt];v[cnt] = b[cnt];
        }
        std :: sort(u+1,u+cnt+1);
        std :: sort(v+1,v+cnt+1);
        lx = std :: unique(u+1,u+cnt+1) - u - 1;
        ly = std :: unique(v+1,v+cnt+1) - v - 1;
        Rep( i , 1 , n ){
            ++tot;
            x = std :: lower_bound(u+1,u+lx+1,a[tot]) - u;
            y = std :: lower_bound(v+1,v+ly+1,b[tot]) - v;
            A[tot].x = x;A[tot].y = y;A[tot].v = val[tot];
        }
        num = n;
        Rep( i , 1 , m ){
            ++num;
            x1 = std :: lower_bound(u+1,u+lx+1,a[num]) - u;
            y1 = std :: lower_bound(v+1,v+ly+1,b[num]) - v;
            ++num;
            x2 = std :: lower_bound(u+1,u+lx+1,a[num]) - u;
            y2 = std :: lower_bound(v+1,v+ly+1,b[num]) - v;
            A[++tot].x = x1-1;A[tot].y = y1-1;A[tot].f = 1;A[tot].id = i;
            A[++tot].x = x1-1;A[tot].y = y2;A[tot].f = -1;A[tot].id = i;
            A[++tot].x = x2;A[tot].y = y1-1;A[tot].f = -1;A[tot].id = i;
            A[++tot].x = x2;A[tot].y = y2;A[tot].f = 1;A[tot].id = i;
        }
        std :: sort(A+1,A+tot+1,cmp);
    }
}
namespace Bit{
    void Add(int x,int k){
        for(int i=x;i<=maxx;i+=i&(-i))
            T[i] += k;
    }
    LL Query(int x){
        LL ans = 0;
        for(int i=x;i;i-=i&(-i))
            ans += T[i];
        return ans;
    }
}
using namespace Bit;
int main(){
    init :: main();
    Rep( i , 1 , tot ){
        if(!A[i].id) Add(A[i].y,A[i].v);
        else ans[A[i].id] += Query(A[i].y)*A[i].f;
    }
    Rep( i , 1 , m ) printf("%lld\n",ans[i]);
    return 0;
}
```

---

## 作者：linjinkun (赞：4)

> 前言：这个分块和刚被撤下的不同，因为这个分块时间复杂度正确，能通过所有 hack。

有没有什么可以不用离线都能解决问题的简单算法？答案是分块！！

## 60pts
首先遇到这个题目，先写一个比较暴力的 $O(mn)$ 的算法，先排序，降掉一维，剩下一维询问时直接两个二分找到左端点和右端点，然后遍历从左端点到右端点有多少个数满足在第二维的范围内，求和即可。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 1e5+5;
struct node
{
	int x;
	int y;
	int p;
}a[N];
int cmp(node x,node y)
{
	return x.x == y.x?x.y<y.y:x.x<y.x;//排序规则
}
signed main()
{
    int n,m;
    scanf("%d %d",&n,&m);
    for(int i = 1;i<=n;i++)
    {
        scanf("%d %d %d",&a[i].x,&a[i].y,&a[i].p);
    }
	sort(a+1,a+n+1,cmp);//排序
    for(int i = 1;i<=m;i++)
    {
    	int x1,y1,x2,y2;
    	scanf("%d %d %d %d",&x1,&y1,&x2,&y2);
    	int l = 1,r = n,num = 0;
    	while(l<=r)
    	{
    		int mid = l+r>>1;
    		if(a[mid].x>=x1)//找到左端点
    		{
    			num = mid;
    			r = mid-1;
			}
			else
			{
				l = mid+1;
			}
		}
		l = 1,r = n;
		int num1 = 0;
		while(l<=r)
    	{
    		int mid = l+r>>1;
    		if(a[mid].x<=x2)//找到右端点
    		{
    			num1 = mid;
    			l = mid+1;
			}
			else
			{
				r = mid-1;
			}
		}
		long long sum = 0;//这里得开long long
		for(int i = num;i<=num1;i++)//遍历
		{
		    int t = a[i].y;
			if(t>=y1&&t<=y2)//如果满足
			{
				sum+=a[i].p;//加上这个基站
			}
		}
		printf("%lld\n",sum);
	}
    return 0;
}
```
[由于特殊的时间限制，我们获得了 $60$ 分的好成绩。](https://www.luogu.com.cn/record/192010065)

## 100pts
遇到这种题，正解并不好想，考虑优化，复杂度瓶颈在于二分完后的遍历，于是我思来想去都没有想出做法，最终在 [arrowpoint](https://www.luogu.com.cn/user/741839) 这位大佬的指点下茅塞顿开，AC 了此题，他是怎么想的呢，分块！我们依旧将块长调整为 $\sqrt{n}$，新建两个块长数组 $s$ 和 $s1$，$s$ 处理的是散块，$s1$ 处理的是整块，为什么要这样呢？因为我们首先要明白，分块为什么比暴力快？原因很简单，它对于整块有整体处理，这样的话对于每次询问区间 $[l,r]$ 内的各种信息，都可以遍历 $[l,r]$ 内的整块，最坏时间为 $O(\sqrt{n})$，因为最多只会有 $\sqrt{n}$ 个块，而每个块都有现成的信息，这样一来每个块都只需要 $O(1)$ 的时间就能知道这个块的信息，那总时间就是 $O(1 \times \sqrt{n}) = O(\sqrt{n})$，然后剩下的就是散块，由于散块最多两个，而散块的遍历每个块需要 $O(\sqrt{n})$ 的时间求信息，所以总时间就是 $O(2 \times \sqrt{n}) = O(\sqrt{n})$，那么整个程序整体复杂度为 $O(m\sqrt{n})$。这里的时间复杂度是忽略常数，所以 $O(2 \times \sqrt{n}) = O(\sqrt{n})$。知道了分块速度快的原因，所以说这里为什么要搞两个分块数组？因为散块不需要什么处理，不需要任何辅助加快时间的东西，自然就啥也不用动，但是整块就不一样了，它需要预处理出一些信息，对于这个题，[arrowpoint](https://www.luogu.com.cn/user/741839) 认为可以将整块处理的基本信息先排个序，因为反正都要算整个块，块里面的数怎么排序都无所谓，然后对于每个整块按照询问中的第二维二分出左右端点，然后求和就行，求和用前缀和优化，这样一来，与处理时间复杂度为 $O(\sqrt{n} \times (\sqrt{n} \times \log \sqrt{n}))=O(n \log \sqrt{n})$，$\log \sqrt{n}$ 是个常数，大约为 $9$，所以说可以默认预处理时间复杂度为 $O(n)$。上面说完整块后，散块也就很简单了，直接将两个或一个散块全部遍历一遍，判断是否满足询问条件就行了。

所有的流程大概说了一遍，但这题的细节很多，仅根据上面说的写代码是 A 不了的，现在大概说一下分块的一些公式和注意事项（个人原创）：

- **求第 $x$ 个块的左端点和右端点，设 $len$ 为块长，$n$ 为区间长度，则第 $x$ 个块的左端点为 $(x-1) \times len+1$，右端点为 $\min(x \times len,n)$。这里重点说为什么右端点不是 $x \times len$，而是 $\min(x \times len,n)$，因为当 $n$ 并不是完全平方数时，那这时就会发生 $len<\sqrt{n}$，$k>\sqrt{n}$，$k$ 指的是最大的块编号，这个时候第 $k$ 个块的长度绝对小于 $len$，所以使用 $k \times len$ 是有可能发生越界行为的。**
- **求编号为 $x$ 的数在块长为 $len$ 时所在的块编号为 $\lfloor \frac{x+len-1}{len} \rfloor$。它其实等价于 $\lceil \frac{x}{len} \rceil$ 的，如果不懂就在草稿本上分类讨论一下就能明白了。**
- **处理散块时当询问的左端点 $l$ 和右端点 $r$ 所在同一个块时，直接从 $l$ 遍历到 $r$，否则把 $l$ 这个块从 $l$ 到 $l$ 当前这个块结尾的编号全部遍历一遍，和从 $r$ 当前这个块的开头的编号到 $r$ 全部遍历一遍。**

说完这些之后，再说本题的注意事项：

- **十年 OI 一场空，不开 long long 见祖宗！**
- **程序里的二分（对于这道题），可能会有左端点找不到，或者右端点找不到，再或者左端点虽然满足大于等于询问的左端点，但却大于询问的右端点，也或者右端点虽然满足小于等于询问的右端点，但却小于询问的左端点，这些情况都说明对于这个询问，找不到满足询问要求的数，此时这次询问（或求值）答案（或贡献）已经确定为 $0$，无需继续查下去。**

讲这么详细，写代码应该没问题了，这里直接放代码了（当然，会有注释）：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 1e5+5;
struct node
{
	int x;
	int y;
	int p;
}a[N];
int cmp(node x,node y)
{
	return x.x == y.x?x.y<y.y:x.x<y.x;//照样排序
}
struct node1
{
	int y;
	int p;
}s[N],s1[N];
long long sum[N];//前缀和得开long long
int id[N];
int cmp1(node1 x,node1 y)//这个是整块的排序
{
	return x.y<y.y;
}
signed main()
{
    int n,m;
    scanf("%d %d",&n,&m);
	int len = sqrt(n);//记录块长
    for(int i = 1;i<=n;i++)
    {
        scanf("%d %d %d",&a[i].x,&a[i].y,&a[i].p);
        id[i] = (i+len-1)/len;//计算所在块编号
    }
	sort(a+1,a+n+1,cmp);
	for(int i = 1;i<=n;i++)
	{
		s[i].y = a[i].y;//设置
        s[i].p = a[i].p;//设置
        s1[i] = s[i];//设置
	}
	for(int i = 1;i<=id[n];i++)
	{
		sort(s1+(i-1)*len+1,s1+min(i*len,n)+1,cmp1);//排个序
	}
	for(int i = 1;i<=n;i++)
	{
		sum[i] = sum[i-1]+s1[i].p;//求个前缀和
	}
    for(int i = 1;i<=m;i++)
    {
    	int x1,y1,x2,y2;
    	scanf("%d %d %d %d",&x1,&y1,&x2,&y2);
    	int l = 1,r = n,num = 0;
    	while(l<=r)
    	{
    		int mid = l+r>>1;
    		if(a[mid].x>=x1)//这边寻找第一维的左端点
    		{
    			num = mid;
    			r = mid-1;
			}
			else
			{
				l = mid+1;
			}
		}
		if(!num||a[num].x>x2)//如果找不到或者不满足条件
		{
			printf("0\n");
			continue;
		}
		l = 1,r = n;
		int num1 = 0;
		while(l<=r)
    	{
    		int mid = l+r>>1;
    		if(a[mid].x<=x2)//找第一维右端点
    		{
    			num1 = mid;
    			l = mid+1;
			}
			else
			{
				r = mid-1;
			}
		}
		if(!num1||a[num1].x<x1)//如果找不到或者不满足条件
		{
			printf("0\n");
			continue;
		}
		long long ss = 0;//得开long long
		for(int i = id[num]+1;i<=id[num1]-1;i++)//求整块
		{
			int l = (i-1)*len+1,r = i*len,num2 = 0;
	    	while(l<=r)
	    	{
	    		int mid = l+r>>1;
	    		if(s1[mid].y>=y1)//在整块中二分找到第二维的左端点
	    		{
	    			num2 = mid;
	    			r = mid-1;
				}
				else
				{
					l = mid+1;
				}
			}
			if(!num2||s1[num2].y>y2)//同上
			{
				continue;
			}
			l = (i-1)*len+1,r = i*len;
			int num3 = 0;
			while(l<=r)
	    	{
	    		int mid = l+r>>1;
	    		if(s1[mid].y<=y2)//在整块中二分找到第二维的右端点
	    		{
	    			num3 = mid;
	    			l = mid+1;
				}
				else
				{
					r = mid-1;
				}
			}
			if(!num3||s1[num3].y<y1)//同上
			{
				continue;
			}
			ss+=sum[num3]-sum[num2-1];//求左端点到右端点的和
		}
		if(id[num] == id[num1])//如果在同一个块
		{
			for(int i = num;i<=num1;i++)//直接遍历
			{
				if(s[i].y>=y1&&s[i].y<=y2)
				{
					ss+=s[i].p;
				}
			}
		}
		else
		{
			for(int i = num;i<=id[num]*len;i++)//分两次，第一次
			{
				if(s[i].y>=y1&&s[i].y<=y2)
				{
					ss+=s[i].p;
				}
			}
			for(int i = (id[num1]-1)*len+1;i<=num1;i++)//第二次
			{
				if(s[i].y>=y1&&s[i].y<=y2)
				{
					ss+=s[i].p;
				}
			}
		}
		printf("%lld\n",ss);//输出
	}
    return 0;
}
```
时间复杂度：$O(n \log \sqrt{n}+m \sqrt{n} \times \log \sqrt{n})$。在 3s 内通过绰绰有余。

[效率还是不错的，估计卡常一下应该能在一秒内卡过，不过懒得弄了。](https://www.luogu.com.cn/record/192526944)

如果还有不会的地方，欢迎私信！！

附分块学习网址：[这里。](https://oi-wiki.org/ds/decompose/)

---

## 作者：critnos (赞：4)

动态开点二维树状数组。

这题给出一个静态的矩阵，然后每次求一个子矩阵的和。二维树状数组的 `add` 和 `ask` 都是 $\log ^2 n$ 的。但是空间复杂度是 $n^2$ 的。

其实只有每次 `add` 会增加 $\log ^2 n$ 的空间。也就是说把数组换成哈希表就是一个不错的算法了。

记得要离散化。如果不离散化复杂度会退化为 $\log^2 w$，$w$ 为值域。

umap 的常数可能太大了。手写一下。

时空复杂度 $n\log ^2 n$。

```cpp
#include<bits/stdc++.h>
#define lowbit(x) (x&-x)
#define ll long long
using namespace std;
int n,m;
const int mod=8010007;
int read()
{
   int s=0;
   char ch=getchar();
   while(ch<'0'||ch>'9') ch=getchar();
   while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
   return s;
}
int x[100005],y[100005],p[100005];
int x1_[100005],y1_[100005];
int x2_[100005],y2_[100005];
int h[300005];
struct has
{
	struct node
	{
		int nxt;
		ll key,v;
	}a[9000000];
	int head[mod+5];
	int cnt;
	void add(int x,ll key,int v)
	{
		a[++cnt].nxt=head[x];
		a[cnt].v=v;
		a[cnt].key=key;
		head[x]=cnt;
	}
	ll find(ll x)
	{
		for(int i=head[x%mod];i;i=a[i].nxt)
			if(a[i].key==x)
				return a[i].v;
		return 0;
	}
	void add(ll x,int p)
	{
		for(int i=head[x%mod];i;i=a[i].nxt)
			if(a[i].key==x)
			{
				a[i].v+=p;
				return;
			}
		add(x%mod,x,p);
	}
}t;
int len1,len2;
void add(int x,int y,int p)
{
	for(;x<=len1;x+=lowbit(x))
		for(int i=y;i<=len2;i+=lowbit(i))
			t.add(1ll*x*len2+i,p);
}
ll ask(int x,int y)
{
	ll s=0;
	for(;x;x-=lowbit(x))
		for(int i=y;i;i-=lowbit(i))
			s+=t.find(1ll*x*len2+i);
	return s;
}
int main()
{
	int i,j,n,m,cnt=0;
	scanf("%d%d",&n,&m);
	for(i=1;i<=n;i++)
		scanf("%d%d%d",&x[i],&y[i],&p[i]);
	for(i=1;i<=m;i++)
		scanf("%d%d%d%d",&x1_[i],&y1_[i],&x2_[i],&y2_[i]);
	for(i=1;i<=n;i++)
		h[++cnt]=x[i];
	for(i=1;i<=m;i++)
		h[++cnt]=x1_[i],h[++cnt]=x2_[i];
	sort(h+1,h+1+cnt);
	len1=unique(h+1,h+1+cnt)-h;
	for(i=1;i<=n;i++)
		x[i]=lower_bound(h+1,h+len1,x[i])-h;
	for(i=1;i<=m;i++)
	{
		x1_[i]=lower_bound(h+1,h+len1,x1_[i])-h;
		x2_[i]=lower_bound(h+1,h+len1,x2_[i])-h;
	}
	cnt=0;
	for(i=1;i<=n;i++)
		h[++cnt]=y[i];
	for(i=1;i<=m;i++)
		h[++cnt]=y1_[i],h[++cnt]=y2_[i];
	sort(h+1,h+1+ cnt);
	len2=unique(h+1,h+1+cnt)-h;
	for(i=1;i<=n;i++)
		y[i]=lower_bound(h+1,h+len2,y[i])-h;
	for(i=1;i<=m;i++)
	{
		y1_[i]=lower_bound(h+1,h+len2,y1_[i])-h;
		y2_[i]=lower_bound(h+1,h+len2,y2_[i])-h;
	}
	for(i=1;i<=n;i++)
		add(x[i],y[i],p[i]);
	for(i=1;i<=m;i++)
		printf("%lld\n",ask(x2_[i],y2_[i])+ask(x1_[i]-1,y1_[i]-1)-ask(x1_[i]-1,y2_[i])-ask(x2_[i],y1_[i]-1));
}
```


---

## 作者：mydcwfy (赞：3)

## 0. 前置知识 & 废话

本蒟蒻最近学习 CDQ 分治，看到该题，虽然想起了扫描线等方法，但为了训练 CDQ 分治，还是自然写一篇题解。

本文是使用的三维偏序，如果不懂的话，可以A [这道题](https://www.luogu.com.cn/problem/P3810)，想更多了解 CDQ 分治的，~~一波广告~~ [我的 Blog](https://www.luogu.com.cn/blog/mydcwfy-342891/cdq-fen-zhi)。

## 1. 关于 CDQ 分治

CDQ 分治是一个离线分治算法，用于解决三维的问题。

它是在解决二维的基础上，再套一个树状数组来维护时间的先后顺序，复杂度比同类的二维问题多 $\log n$。

相信你 A 了模板题，会对这算法有更深的理解。

## 2. 关于本题

1. 有 $n$ 个先给出的点，每一个点有一个权值，在给出 $m$ 个矩形边框，给出两个点 $(x_1,y_1),(x_2,y_2)$，求围住的点的总权值。
2. $n\leq 10^5,m\leq 10^5,-2^{31}\leq x_1,x_2,y_1,y_2\leq 2^{31}$。

虽然近乎于一道模板题，直接扫描线，但是我们还是可以使用一下 CDQ 分治。

CDQ 分治的关键就在于构造一个三维偏序问题。

注意，有的题解使用的是二维偏序问题，我这里为了更加与模板吻合，构造了第三维，使用标准的三维偏序。

首先，我们可以将其转化为一个二维前缀和的问题，即 $ans=\operatorname{sum}(x_2,y_2)-\operatorname{sum}(x_1-1,y_2)-\operatorname{sum}(x_2,y_1-1)+\operatorname {sum}(x_1-1,y_1-1)$（就是一个容斥原理）。

于是，问题就是求
$$
\operatorname{sum}(x_t,y_t)=\sum_{x\leq x_t,y\leq y_t}{a[x][y]}
$$
第一和第二维很简单，直接是 $x$ 和 $y$。

怎样求第三维呢？

可以发现，我们要构造为 $z<z_t$，又因为 CDQ 分治是离线，询问和答案在一起。

于是，我们可以用一个 $z$ 来标记是询问还是原来的点。

我们要加答案的是原来的点，而不是询问，所以我们将原来的点记为 0，询问记为 1。

那么，我们现在求的是：
$$
\operatorname{sum}(x_t,y_t,z_t)=\sum_{x\leq x_t,y\leq y_t,z<z_t}{a[x][y]}
$$
于是就是一个标准的偏序问题了！

## 3. 关于 Code

1. 我们需要使用 long long，因为很可能炸 int。
2. 实际使用 $z$ 的时候，我们其实不需完全使用原来的三维偏序，其实可以将 $z=0$ 时加入总和即可。

然后就是愉快的上代码时间了！

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;

typedef long long ll;
const int N=5e5+10;

struct Node{
    int a,b,c,id,f,p;
    ll sum;
    const bool operator <(const Node &t){
        if (a!=t.a) return a<t.a;
        if (b!=t.b) return b<t.b;
        return c<t.c;
    }
}k[N],tmp[N];

int n,m;
ll ans[N];

void merge_sort(int l,int r)
{
    if (l==r) return;
    int mid=l+r>>1;
    merge_sort(l,mid);merge_sort(mid+1,r);
    int j=l,i=mid+1,h=0;
    ll sum=0;
    while (j<=mid&&i<=r)//k[j].c 为 0 时就加上
        if (k[j].b<=k[i].b) sum+=(!k[j].c)*k[j].p,tmp[h++]=k[j++];
        else k[i].sum+=sum,tmp[h++]=k[i++];
    while (j<=mid) tmp[h++]=k[j++];
    while (i<=r) k[i].sum+=sum,tmp[h++]=k[i++];
    for (int i=l,t=0;t<h;++t,++i) k[i]=tmp[t];
}

int main()
{
    scanf("%d %d",&n,&m);
    for (int i=0,a,b,c;i<n;++i)
    {
        scanf("%d %d %d",&a,&b,&c);
        k[i]=(Node){a,b,0,0,0,c,0};
    }
    int tot=n;
    for (int i=0,a,b,c,d;i<m;++i)
    {
        scanf("%d %d %d %d",&a,&b,&c,&d);
        k[tot++]=(Node){a-1,b-1,1,i,1,0,0};
        k[tot++]=(Node){a-1,d,1,i,-1,0,0};
        k[tot++]=(Node){c,d,1,i,1,0,0};
        k[tot++]=(Node){c,b-1,1,i,-1,0,0};
    }

    sort(k,k+tot);
    merge_sort(0,tot-1);

    for (int i=0;i<tot;++i)
        if (k[i].c) ans[k[i].id]+=k[i].sum*k[i].f;
    for (int i=0;i<m;++i) printf("%lld\n",ans[i]);
    return 0;
}
```



---

## 作者：Engulf (赞：2)

比较板的二维数点。

把询问离线，把一个询问 $q = (x_1, y_1, x_2, y_2)$ 拆开成 $4$ 个：

- $q_1 = (x_1 - 1, y_1 - 1)$
- $q_2 = (x_1 - 1, y_2)$
- $q_3 = (x_2, y_1 - 1)$
- $q_4 = (x_2, y_2)$

那么这个询问 $q$ 的答案即为 $q_4 - q_2 - q_3 + q_1$。

把所有点和询问放到一起按照 $x$ 排序，**$x$ 值相等，先点后询问**。

然后用树状数组维护即可。

注意坐标范围过大，需要离散化，树状数组要开 $6 \cdot (n + m)$ 即 $6 \cdot 10^5$。

```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long LL;
typedef pair<int, int> PII;

const int inf = 0x3f3f3f3f;
const LL infLL = 0x3f3f3f3f3f3f3f3fLL;

const int N = 6e5 + 5;

int n, m;

struct Node {
    int type;
    int id;
    int x, y;
    int neg;
    int val;
    bool operator<(const Node &b) const {
        return x ^ b.x ? x < b.x : type < b.type;
    }
};

struct {int x, y, p;} a[N];
struct {int x1, y1, x2, y2;} b[N];

vector<int> lsh;

struct BIT {
    LL tr[N];
    void add(int i, int v) {for (; i < N; i += i & -i) tr[i] += v;}
    LL query(int i) {LL res = 0; for (; i; i -= i & -i) res += tr[i]; return res;}
}bit;

LL ans[N];

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n >> m;
    for (int i = 1; i <= n; i++) {
        cin >> a[i].x >> a[i].y >> a[i].p;
        lsh.push_back(a[i].x);
        lsh.push_back(a[i].y);
    }
    for (int i = 1; i <= m; i++) {
        cin >> b[i].x1 >> b[i].y1 >> b[i].x2 >> b[i].y2;
        lsh.push_back(b[i].x1);
        lsh.push_back(b[i].y1);
        lsh.push_back(b[i].x2);
        lsh.push_back(b[i].y2);
    }
    sort(lsh.begin(), lsh.end());
    lsh.erase(unique(lsh.begin(), lsh.end()), lsh.end());
    for (int i = 1; i <= n; i++) {
        a[i].x = lower_bound(lsh.begin(), lsh.end(), a[i].x) - lsh.begin() + 1;
        a[i].y = lower_bound(lsh.begin(), lsh.end(), a[i].y) - lsh.begin() + 1;
    }
    for (int i = 1; i <= m; i++) {
        b[i].x1 = lower_bound(lsh.begin(), lsh.end(), b[i].x1) - lsh.begin() + 1;
        b[i].y1 = lower_bound(lsh.begin(), lsh.end(), b[i].y1) - lsh.begin() + 1;
        b[i].x2 = lower_bound(lsh.begin(), lsh.end(), b[i].x2) - lsh.begin() + 1;
        b[i].y2 = lower_bound(lsh.begin(), lsh.end(), b[i].y2) - lsh.begin() + 1;
    }
    
    vector<Node> q;
    for (int i = 1; i <= n; i++) q.push_back({0, 0, a[i].x, a[i].y, 0, a[i].p});
    for (int i = 1; i <= m; i++) {
        auto &v = b[i];
        q.push_back({1, i, v.x1 - 1, v.y1 - 1, 1, 0});
        q.push_back({1, i, v.x1 - 1, v.y2, -1, 0});
        q.push_back({1, i, v.x2, v.y1 - 1, -1, 0});
        q.push_back({1, i, v.x2, v.y2, 1, 0});
    }
    sort(q.begin(), q.end());
    for (auto i: q) {
        if (i.type) ans[i.id] += i.neg * bit.query(i.y);
        else bit.add(i.y, i.val);
    }
    for (int i = 1; i <= m; i++) cout << ans[i] << "\n";
    return 0;
}
```

---

## 作者：__ycx2010__ (赞：2)

## 前言

[题目链接！](https://www.luogu.com.cn/problem/P3755)

本篇采用[cdq分治](https://www.luogu.com.cn/blog/CUT/cdq-fen-zhi)解法。

## 简化题意

直角平面坐标系重有 $n$ 个点，

第 $i$ 个点坐标为 $(x_i,y_i)$ ，权值为 $w_i$ 。

每个询问给出矩阵两对角坐标，

询问矩阵内有的点的权值之和。

## 思路

每个点有两个属性 $x$ , $y$ , $z$ ，

$x,y$ 表示坐标， $z$ 为 $0$ 表示是有权点， $z$ 为 $1$ 表示查询的点。

每个点的 $sum$ 表示以该点为右上角，原点 $O$ 为左下角的矩阵内的权值之和。

询问时运用二维前缀和。

## 时间复杂度

由于第三维是 $0$ 或 $1$ ，

所以相当于二维偏序，

时间复杂度 $O(n\log n)$ 。

## 实现

```
#include <bits/stdc++.h>
using namespace std;

const int N = 1e5 + 10, M = N * 5;

int n, m, tt;
int a[N], b[N], c[N], d[N];
long long ans[N];

struct Node {
    int a, b, c, s, id, sign;
    long long res;
    bool operator< (const Node &t) const {
        if (a != t.a) return a < t.a;
        if (b != t.b) return b < t.b;
        return c < t.c;
    }
} q[M], w[M];

void merge(int l, int r)
{
    if (l >= r) return ;
    int mid = l + r >> 1;
    merge(l, mid), merge(mid + 1, r);
    int i = l, j = mid + 1, k = l;
    long long sum = 0;
    while (i <= mid && j <= r)
        if (q[i].b <= q[j].b) sum += !q[i].c * q[i].s, w[k ++ ] = q[i ++ ];
        else q[j].res += sum, w[k ++ ] = q[j ++ ];
    while (i <= mid) sum += !q[i].c * q[i].s, w[k ++ ] = q[i ++ ];
    while (j <= r) q[j].res += sum, w[k ++ ] = q[j ++ ];
    for (int i = l; i <= r; i ++ ) q[i] = w[i];
}

int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i ++ ) 
    {
        int x, y, p;
        scanf("%d%d%d", &x, &y, &p);
        q[++ tt] = {x, y, 0, p};
    }
    for (int i = 0; i < m; i ++ )
    {
        int x1, y1, x2, y2;
        scanf("%d%d%d%d", &x1, &y1, &x2, &y2);
        q[++ tt] = {x2, y2, 1, 0, i, 1};
        q[++ tt] = {x2, y1 - 1, 1, 0, i, -1};
        q[++ tt] = {x1 - 1, y2, 1, 0, i, -1};
        q[++ tt] = {x1 - 1, y1 - 1, 1, 0, i, 1};
    }
    
    sort(q + 1, q + tt + 1);
    merge(1, tt);
    
    for (int i = 1; i <= tt; i ++ )
        if (q[i].c)
            ans[q[i].id] += q[i].sign * q[i].res;
    for (int i = 0; i < m; i ++ ) printf("%lld\n", ans[i]);
    
    return 0;
}
```

---

## 作者：pitiless0514 (赞：2)

### 题意简述（来自大佬NOIP1 QAQ）：
平面内有N个点，每个点有一个值Pi和坐标(xi,yi)，有M次查询，查询以(x1,y1)和(x2,y2)为两对角顶点的矩形内部点的值之和。

------------
#### 采用方法：CDQ分治
#### 采用原因：对于这种计算“查询”操作的题，我们可以大胆的采用CDQ分治（~~因为我们老师把他放在了CDQ分治列表~~）。

TIPS：本题解借鉴于@niiick大佬，也就是对他的题解进行一些补充，QWQ。

------------
#### CDQ分治的定义：
CDQ分治是基于时间顺序对操作序列进行的分治算法。

而离线算法又是什么呢？

**“离线”算法 是在将一系列操作保存下来，经过一系列计算，再统一输出“查询”的结果。**

那么知道了这些前置知识，我们开始看题。

# 解析：
本题其实很简单，因为我们在询问时，**并没有任何的修改操作**，那么我们就可以直接把它转换为一个二维偏序，按x为第一关键字，然后y为第二个关键字，如此进行排序。求矩形内部数值和。就像是一个二维前缀和一样，**我们计算出矩形四个点的分别对应的矩形内部功率和，然后进行容斥，即可算出答案**。而在题解中大佬们都没有具体讲解关于矩阵拆分的问题。那本人给大家讲一讲。

------------

## First
![](https://cdn.luogu.com.cn/upload/image_hosting/015w11oc.png)
我们首先建立一个坐标轴，我们可以看到在图片中心的那块矩形其实就是我们要求的那一块矩形。而给我们的点其实也就是右斜着的两个对角坐标。





## Second
![](https://cdn.luogu.com.cn/upload/image_hosting/avchugtm.png)

接下来我们选取几个点为（a1-1,b2）和(a2,b1-1)和（a2,b2）和（a1-1,b1-1）。而这几个点就是我们要求的几个点，只要我们求出这几个点的区域内的值，然后容斥一下，也就是f(a2,b2)-f(a2,b1-1)-f(a1-1,b2)+f(a1-1,b1-1)即为答案。而这时大家伙们，可能会有疑问，咦？你这个求的东西好像多了一块，怎么回事呢？看下面一步。





## Third
![](https://cdn.luogu.com.cn/upload/image_hosting/h1hsoqai.png)

虽然说多了一块，但是这个可以不用计入考虑中的，因为我们在这个涂黑的区域内是不可能再出现值的了，因为他是一个单位长度一个点，不可能小于1个单位长度的情况下出现点，既然没有点，那就更不可能有权值了，而那几个边界点（左下，左上，右下三个点）被我们用右上的点给减去了，所以是不会有任何影响的！


------------


## Fourth：
![](https://cdn.luogu.com.cn/upload/image_hosting/dev1jlg7.png)

我们可到这些被用不同颜色的笔画了斜杠的部分，可以轻易地看出这是一个容斥，也就是f(a2,b2)-f(a2,b1-1)-f(a1-1,b2)+f(a1-1,b1-1)。那为什么最后要加回来呢？因为那块小正方形被减了两次，所以加回来，最后即为答案。



### **code：**
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,m,t,ansl[1000009]; 
struct node{
	long long x,y,p,opt,k,ans,now;
}a[1000009],b[1000009];
bool comp1(node a,node b){
    if(a.x!=b.x) return a.x<b.x; //按着优先级排序
    else if(a.y!=b.y) return a.y<b.y;
    else return a.opt<b.opt;
}
void solve(int l,int r){
	if(l==r) return;//判断的一个边界条件
	long long mid=(l+r)/2;
	solve(l,mid);//递归求解
	solve(mid+1,r);
	long long j=l,cnt=0,p=l,i=mid+1;
	while(i<=r){
		while(j<=mid&&a[j].y<=a[i].y){
			if(a[j].opt==1){
			  cnt+=a[j].p;
			}
			b[p++]=a[j++];
		}
		if(a[i].opt==2) a[i].ans+=cnt;
		b[p++]=a[i++];
	}
	while(j<=mid) b[p++]=a[j++];
	while(i<=r)  b[p++]=a[i++];
	for(int i=l;i<=r;i++){
		a[i]=b[i];//更新答案
	}
}
int main(){
	scanf("%lld%lld",&n,&m);
	for(int i=1;i<=n;i++){
	t++;
	scanf("%lld%lld%lld",&a[t].x,&a[t].y,&a[t].p);
	a[t].opt=1;默认为修改操作
	a[t].k=0;
	a[t].ans=0;
	a[t].now=0;
	}
	for(int i=1;i<=m;i++){
		long long xx,yy,x2,y2;
		scanf("%lld%lld%lld%lld",&xx,&yy,&x2,&y2);
	    a[++t].x=xx-1;
	    a[t].y=yy-1;
	    a[t].opt=2;//与开始的修改操作相区分
	    a[t].p=0;
	    a[t].ans=0;
	    a[t].k=1;//加减的统计，在最后靠这个判断容斥
	    a[t].now=i;//记录答案的输出地方
	    
		a[++t].x=xx-1;
	    a[t].y=y2;
	    a[t].opt=2;
	    a[t].k=-1;
	    a[t].ans=0;
	    a[t].p=0;
	    a[t].now=i;
	    
	    a[++t].x=x2;
	    a[t].y=yy-1;
	    a[t].opt=2;
	    a[t].now=i;
	    a[t].k=-1;
	    a[t].ans=0;
	    a[t].p=0;
	    
	    a[++t].x=x2;
	    a[t].y=y2;
	    a[t].ans=0;
	    a[t].opt=2;
	    a[t].p=0;
	    a[t].k=1;
	    a[t].now=i;
	}
	sort(a+1,a+t+1,comp1);//排序
	solve(1,t);
	for(int i=1;i<=t;i++){
	ansl[a[i].now]+=a[i].k*a[i].ans;
	}//求解答案
	for(int i=1;i<=m;i++) printf("%lld\n",ansl[i]);
	return 0;
}
```

---

## 作者：cmd2001 (赞：2)

不知道为什么大家不写KD-Tree......

明明好写好调能AC的......

本题为KD-Tree裸题，直接建立KD-Tree后查询矩阵和就好。

单次复杂度为sqrt(n)，有一个证明是在二维KD-Tree上任意一条平行于坐标轴的直线不会经过超过sqrt(n)个节点。

所以本题复杂度O(n*sqrt(n))，10w随便过了。

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define debug cout
typedef long long int lli;
using namespace std;
const int maxn=1e5+1e2;

int cmp;
struct Point {
    int d[2],val;
    friend bool operator < (const Point &a,const Point &b) {
        return a.d[cmp] < b.d[cmp];
    }
}ps[maxn],nv[maxn];
struct QNode {
    int mi[2],mx[2];
}q;
int lson[maxn],rson[maxn],mi[maxn][2],mx[maxn][2],cnt;
lli su[maxn],ans; // remember to reset ans before query !

inline void fill(const int &pos,const Point &p) {
    nv[pos] = p , su[pos] = p.val;
    for(register int i=0;i<2;i++) mx[pos][i] = mi[pos][i] = p.d[i];
}
inline void up(const int &pos,const int &son) {
    su[pos] += su[son];
    for(register int i=0;i<2;i++)
        mi[pos][i] = min( mi[pos][i] , mi[son][i] ) ,
        mx[pos][i] = max( mx[pos][i] , mx[son][i] ) ;
}
inline void build(int pos,const int &dir,const int &ll,const int &rr) {
    const int mid = ( ll + rr ) >> 1;
    cmp = dir , nth_element(ps+ll,ps+mid,ps+rr+1);
    fill(pos,ps[mid]);
    if( ll < mid ) build(lson[pos]=++cnt,dir^1,ll,mid-1) , up(pos,lson[pos]);
    if( mid < rr ) build(rson[pos]=++cnt,dir^1,mid+1,rr) , up(pos,rson[pos]);
}
inline bool fullout(const int &pos) {
    for(register int i=0;i<2;i++) if( q.mx[i] < mi[pos][i] || mx[pos][i] < q.mi[i] ) return 1;
    return 0;
}
inline bool fullin(const int &pos) {
    for(register int i=0;i<2;i++) if( ! ( q.mi[i] <= mi[pos][i] && mx[pos][i] <= q.mx[i] ) ) return 0;
    return 1;
}
inline bool pointin(const Point &p) {
    for(register int i=0;i<2;i++) if( ! ( q.mi[i] <= p.d[i] && p.d[i] <= q.mx[i] ) ) return 0;
    return 1;
}
inline void query(const int &pos) {
    if( fullout(pos) ) return;
    if( fullin(pos) ) return void(ans+=su[pos]);
    if( pointin(nv[pos]) ) ans += nv[pos].val;
    query(lson[pos]) , query(rson[pos]);
}

int main() {
    static int n,m;
    scanf("%d%d",&n,&m);
    for(register int i=1;i<=n;i++) scanf("%d%d%d",ps[i].d,ps[i].d+1,&ps[i].val);
    build(cnt=1,0,1,n);
    for(register int i=1;i<=m;i++) {
        for(register int i=0;i<2;i++) scanf("%d",q.mi+i);
        for(register int i=0;i<2;i++) scanf("%d",q.mx+i);
        ans = 0 , query(1);
        printf("%lld\n",ans);
    }
    return 0;
}
```

---

## 作者：shadowice1984 (赞：2)

我知道这当然是离线扫描线啦~

单点加矩形求和，最最经典的离线扫描线问题了

一个树状数组就可以维护，真是又优雅又巧妙的算法~

说的好我选择主席树~

## 可持久化线段树/前缀和套线段树

~~(什么你不会主席树？，出门左转你站膜板区，包教包会)~~

(这里我们就默认你会了主席树，不会的话赶紧学一学，因为主席树真的很无脑)

嗯这道题就是前缀和套线段树了

因为我们发现直接离散化二维前缀和会T飞所以我们选择一维用线段树替代，另一位还是前缀和，所以我们的前缀和套线段树就是主席树了

我们考虑把x和y都离散化，然后以x为时间点，y为区间点依次在主席树上做n次单点加工作，(这里因为只是单点加所以可以标记永久化)

之后我们查询矩形区域的加法，第一维用前缀和搞定

即答案就是 **x小于等于x2**,y在y1到y2的点的点权和-**x小于x1**,y在y1到y2的点的点权和，你可以认为是两个向负无穷无限延伸的矩形相减

那么这个第二维的询问可以用主席树上的线段树操作解决，因为主席树每一个版本的线段树都是这个时间点之前各个操作的累加，也就是前缀和，而每一个前缀和都资瓷线段树操作，所以我们就这样愉快解决了两维的限制~

## 离散化和映射

其实离散化处理的不好挺让人头疼的……，这里我们掌握一个原则，我们每次都要坚持一种区间描述法不动摇，(我用的是非常邪教的左开右闭，但是这和前缀和的区间描述法是一样的)

唯一需要注意的是因为我们离散化了，所以我们需要二分查找这个询问的x和y

因为我们不想手写二分了，所以我们需要使用STL的lower_bound函数和upper_bound函数来帮助我们完成映射

lower_bound格式如下:(迭代器头，迭代器尾，比较值，比较函数)

其中迭代器头和迭代器尾如果是数组的话就传指针，如果是vector的话就传v.begin(),v.end(),注意这里的区间描述法是左闭右开的……，比较值的类型就是这个数组/vector存储的类型，比较函数就是你手写的cmp

返回值:一个迭代器/如果数组的话返回指针，迭代器/指针指向第一个**大于或等于**比较值的值

upper_bound同lower_bound只是返回值保证严格大于查找值

所以我们在数组里插入一个0x7f7f7f7f的哨兵，然后lower_bound一发左端点，upper_bound一发右端点，两个分别-1就是左开右闭的区间描述啦~

代码很短，具体细节看代码~

上代码~

```C
#include<cstdio>
#include<algorithm>
using namespace std;const int N=1e5+10;typedef long long ll;int n;int m;
struct per_linetree//主席树板子没啥好说的 
{
	int s[2][22*N];ll val[22*N];int root[N];int cnt;
	int tim;per_linetree(){root[0]=++cnt;}
	inline void cson(int p1,int p2,int t){s[t][p2]=++cnt;s[t^1][p2]=s[t^1][p1];}
	inline void sadd(int p1,int p2,int l,int r,int pos,ll plus)
	{
		val[p2]=val[p1]+plus;if(r-l==1){return;}int mid=(l+r)/2;
		if(pos<=mid){cson(p1,p2,0);sadd(s[0][p1],cnt,l,mid,pos,plus);}
		else {cson(p1,p2,1);sadd(s[1][p1],cnt,mid,r,pos,plus);}
	}
	inline ll sum(int p,int l,int r,int dl,int dr)
	{
		if((dl==l&&dr==r)||p==0){return val[p];}int mid=(l+r)/2;ll ret=0;
		if(dl<mid){ret+=sum(s[0][p],l,mid,dl,min(dr,mid));}
		if(mid<dr){ret+=sum(s[1][p],mid,r,max(dl,mid),dr);}return ret;
	}
	inline int cadd(int pos,ll plus)//这里返回一个版本号 
	{sadd(root[tim],root[tim+1]=++cnt,0,n,pos,plus);return ++tim;}
	inline ll csum(int t1,int t2,int l,int r)
	{return sum(root[t2],0,n,l,r)-sum(root[t1],0,n,l,r);}
}plt;
struct data
{
	ll v;int fr;int rk;//离散化的结构体 
	friend bool operator <(data a,data b){return a.v<b.v;}
	friend bool operator ==(data a,data b){return a.v==b.v;}
}dx[N],dy[N];int y[N];ll add[N];
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
	{
		ll x;ll y;scanf("%lld%lld%lld",&x,&y,&add[i]);
		dx[i]=(data){x,i,0};dy[i]=(data){y,i,0};//读入 
	}sort(dx+1,dx+n+1);sort(dy+1,dy+n+1);dy[1].rk=1;//离散化一发 
	for(int i=2;i<=n;i++){dy[i].rk=(dy[i]==dy[i-1])?dy[i-1].rk:i;}
	for(int i=1;i<=n;i++){y[dy[i].fr]=dy[i].rk;}//映射回原来的y 
	for(int i=1;i<=n;i++){int p=dx[i].fr;dx[i].rk=plt.cadd(y[p],add[p]);}//按照x的顺序加点 
	dx[n+1].v=0x7f7f7f7f;dy[n+1].v=0x7f7f7f7f;//插入哨兵防止upper_bound找不到值 
	for(int i=1;i<=m;i++)
	{
		ll x1;ll x2;ll y1;ll y2; 
		scanf("%lld%lld%lld%lld",&x1,&y1,&x2,&y2);
		x1=(*lower_bound(dx+1,dx+n+2,(data){x1,0,0})).rk;//lower_bound左端点 
		x2=(*(upper_bound(dx+1,dx+n+2,(data){x2,0,0})-1)).rk;//upper_bound右端点 
		y1=(*lower_bound(dy+1,dy+n+2,(data){y1,0,0})).rk;//lower_bound左端点 
		y2=(*(upper_bound(dy+1,dy+n+2,(data){y2,0,0})-1)).rk;//upper_bound右端点 
		printf("%lld\n",plt.csum(x1-1,x2,y1-1,y2));//然后查两发发前缀和就好啦~ 
	}return 0;//拜拜程序~ 
}
```



---

## 作者：lao_wang (赞：1)

使用算法：整体二分、树状数组、离散化没了。

## 前言

一眼二维偏序。

## 正文

首先做过 [\[BalkanOI2007\] Mokia 摩基亚](https://www.luogu.com.cn/problem/P4390)会知道这道题一定是一个三维偏序。

但是他真的是三维偏序吗？

~~他是啊~~。

其实他并不能算一个完整的三维偏序因为你可以说的时间戳的限制但是这个限制没有什么用。

所以我们可以通过一个类似于二维前缀和的方式询问转化成二维偏序 (也就是把一个询问转化成四个询问输出时输出第一个询问减去第二、三个询问加上第四个询问这就是我们需要输出的答案)：

1. $x_i \leq x_{2,i}$。
2. $x_{1,i} \leq x_i$。

![](https://cdn.luogu.com.cn/upload/image_hosting/oi16fjt9.png)

那么用整体二分怎么做？

由[三维偏序](https://www.luogu.com.cn/article/6xhv7leg)得到灵感。

使用整体二分限制添加 1 的输入让后用树状数组限制 2 的输入之后就做完了。（具体内用详见上面题解的二维偏序部分）

## 代码

```cpp
#include<bits/stdc++.h>
#define int long long
#define N 812345
#define lowbit(x) ((x)&(-x))
using namespace std ;
int n , m , cnt=0 , temp[N<<3] , tot=0 , q=0 , ans[N<<2] , number=0 , tr[N<<3] ;
map<int,int> mp ;
struct node{
	int x1 , x2 , opt , i , k ;
}a[N<<1],q1[N<<1],q2[N<<1];
void change(int x,int k){
	while(x<=number){
		tr[x] += k ;
		x += lowbit(x) ;
	}
}
int ask(int x){
	int ans=0 ;
	while(x){
		ans += tr[x] ;
		x -= lowbit(x) ;
	}
	return ans ;
}
void solve(int l,int r,int L,int R){
	if(L>R) return ;
	int mid=(l+r)>>1 , tot1=0 , tot2=0 ;
	for(int i=L;i<=R;i++){
		if(a[i].opt==1){
			if(mid>=a[i].x1) change(a[i].x2,a[i].k) , q1[++tot1] = a[i] ;
			else q2[++tot2] = a[i] ;
		}else if(a[i].opt==2){
			if(mid<=a[i].x1){
				ans[a[i].i] += ask(a[i].x2) ;
				q2[++tot2] = a[i] ;
			}else q1[++tot1] = a[i] ;
		}
	}
	for(int i=1;i<=tot1;i++){
		a[i+L-1] = q1[i] ;
		if(q1[i].opt==1) change(q1[i].x2,-q1[i].k) ;
	}
	for(int i=1;i<=tot2;i++) a[i+L+tot1-1] = q2[i] ;
	if(l==r) return ;
	solve(l,mid,L,L+tot1-1) ;
	solve(mid+1,r,L+tot1,R) ;
}
signed main(){
	cin >> n >> m ;
	for(int i=1;i<=n;i++) scanf("%lld%lld%lld",&a[i].x1,&a[i].x2,&a[i].k) , temp[++tot] = a[i].x1 , temp[++tot] = a[i].x2 , a[i].opt = 1 ;
	cnt = n ;
	for(int i=1;i<=m;i++){
		int x1 , x2 , y1 , y2 ;
		scanf("%lld%lld%lld%lld",&x1,&y1,&x2,&y2) ;
		temp[++tot] = x1 , temp[++tot] = y1 , temp[++tot] = x2 , temp[++tot] = y2 , temp[++tot] = x1-1 , temp[++tot] = y1-1  ;
		a[++cnt].opt = 2 ;
		a[cnt].x1 = x2 , a[cnt].x2 = y2 , a[cnt].i = ++q ;
		a[++cnt].opt = 2 ;
		a[cnt].x1 = x1-1 , a[cnt].x2 = y2 , a[cnt].i = ++q ;
		a[++cnt].opt = 2 ;
		a[cnt].x1 = x2 , a[cnt].x2 = y1-1 , a[cnt].i = ++q ;
		a[++cnt].opt = 2 ;
		a[cnt].x1 = x1-1 , a[cnt].x2 = y1-1 , a[cnt].i = ++q ;
	}
	sort(temp+1,temp+1+tot) ;
	for(int i=1;i<=tot;i++){
		while(temp[i]==temp[i+1]&&i+1<=tot) i++ ;
		mp[temp[i]] = ++number ;
	}
	for(int i=1;i<=cnt;i++){
		a[i].x1 = mp[a[i].x1] ;
		a[i].x2 = mp[a[i].x2] ;
	}
	solve(-number*2,number*2,1,cnt) ;
	for(int i=1;i<=q;i+=4) printf("%lld\n",ans[i]-ans[i+1]-ans[i+2]+ans[i+3]) ;
	return 0 ;
}
```

---

## 作者：Rainsleep (赞：1)

**前置芝士：CDQ 分治，二维前缀和**

## $\text{Solution}$

简化版题意：
+ 给定坐标系中的 $n$ 个点，以及 $m$ 次查询。点有点权。
+ 每次查询给定一个矩形区域，查询矩形区域内的点权和。

对于每一组查询点，我们不妨将其转化为二维前缀和的方式处理。即对于一个查询矩阵的四个点而言，处理出四个点到 $(0,0)$ 的前缀和，再根据二维前缀和的一般形式即可 $O(1)$ 求出询问。

考虑处理每一个询问点的二维前缀和，对于一个询问点 $(x_i,y_i)$ 来讲，我们需要求出所有满足要求的点，即

$$\begin{cases} x_j \le x_i \\ y_j \le y_i\end{cases}$$

我们发现这样做似乎会将矩形内的查询点也一并计算在内，所以我们需要同时记录一个标志 $z_i$ 用于表示该点是普通点还是查询点。普通点记为 $0$，查询点记为 $1$，那么问题就转化为了求所有满足

$$\begin{cases} x_j \le x_i \\ y_j \le y_i \\ z_j < z_i \end{cases}$$

的点的点权和，考虑 CDQ 分治直接求解三维偏序即可。

特别的，本题目中的 $z_i$ 只有 $0,1$ 两种取值，那么直接用变量储存即可，去掉了树状数组带的一只 $\log_2$，总复杂度为 $O(n\log_2n)$。

```cpp
#include<bits/stdc++.h>

using namespace std;

#define int long long

const int N = 5e5 + 10;
struct node
{
    int x, y, z, p; // 坐标(x, y)，是查询的话z = 1，否则z = 0, p是点权
    int id, sign; // 如果是查询的话 id是查询编号 sign代表sum正负
    int sum; // 二维前缀和
    
    inline bool operator < (const node &W)const
    {
        if(x != W.x)
            return x < W.x;
        if(y != W.y)    
            return y < W.y;
        return z < W.z;
    }
} q[N], w[N];
int n, m;
int ans[N];

inline void cdq(int l, int r)
{
    if(l >= r)  
        return ;
    int mid = l + r >> 1, k = 0;
    cdq(l, mid), cdq(mid + 1, r);
    int lptr = l, rptr = mid + 1, sum = 0;
    while(lptr <= mid and rptr <= r)
        if(q[lptr].y <= q[rptr].y)
            sum += !q[lptr].z * q[lptr].p, w[++ k] = q[lptr ++ ]; // 0 -> 1,1 -> 0
        else 
            q[rptr].sum += sum, w[++ k] = q[rptr ++ ];
    while(lptr <= mid)
        sum += !q[lptr].z * q[lptr].p, w[++ k] = q[lptr ++ ];
    while(rptr <= r)
        q[rptr].sum += sum, w[++ k] = q[rptr ++ ];
    for(int i = l, j = 1;j <= k; ++ j, ++ i)
        q[i] = w[j];
    return ;
}

signed main()
{
    scanf("%lld %lld", &n, &m);
    for(int i(1);i <= n; ++ i)
    {
        int x, y, p;
        scanf("%lld %lld %lld", &x, &y, &p);
        q[i] = {x, y, 0, p};
    }
    int k = n;
    for(int i(1);i <= m; ++ i)
    {
        int x1, y1, x2, y2;
        scanf("%lld %lld %lld %lld", &x1, &y1, &x2, &y2);
        q[++ k] = {x2, y2, 1, 0, i, 1}; // 右上角
        q[++ k] = {x1 - 1, y1 - 1, 1, 0, i, 1}; // 左下
        q[++ k] = {x1 - 1, y2, 1, 0, i, -1}; // 左上
        q[++ k] = {x2, y1 - 1, 1, 0, i, -1}; // 右下
    }
    sort(q + 1, q + 1 + k);
    cdq(1, k);
    for(int i(1);i <= k; ++ i)
        if(q[i].z)
            ans[q[i].id] += q[i].sum * q[i].sign;
    for(int i(1);i <= m; ++ i)
        printf("%lld\n", ans[i]);
    return 0;
}
```


---

## 作者：破忆 (赞：1)

## 【题意】

二维平面内数矩形区域内的点权和。

## 【分析】

平面数点问题，就是 $K-D\ Tree$ 的板子。

非常套路地，在每个点上维护子树内点的坐标极值，在搜索时进行剪枝。

单次操作复杂度是 $O(n^{\frac{k-1}{k}})$，那么总复杂度就是 $O(n\cdot \sqrt n)$，足以通过本题。

## 【算法】

K-D Tree

## 【代码】

```cpp
#include<bits/stdc++.h>
#define LL long long
using namespace std;
const int maxn=1e5+5,maxt=maxn*30;
const double A=0.75;
int n,m;
char gc(){
    static char buf[100000],*p1=buf,*p2=buf;
    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;
}
#define getchar gc
int read(){
    int ret=0,f=1;char ch=getchar();
    while(ch>'9'||ch<'0'){if(ch=='-')f=-f;ch=getchar();}
    while(ch>='0'&&ch<='9') ret=ret*10+ch-'0',ch=getchar();
    return ret*f;
}
struct point{
    int x[2];
    int p;
}p[maxn];
int D;
bool cmp(point x,point y){
    return x.x[D]<y.x[D];
}
struct KDT{
	int rt,tot;
	int rub[maxn],top;
	struct ele{
	    point p;
	    int mx[2],mi[2];
	    int l,r,s;
	    LL S;
	}t[maxn];
	#define ls(k) t[k].l
	#define rs(k) t[k].r
	#define s(k) t[k].s
	#define p(k) t[k].p
	#define S(k) t[k].S
	#define mid (l+r>>1)
	void pushup(int k){
	    s(k)=1;
	    S(k)=p(k).p;
	    t[k].mx[0]=t[k].mi[0]=p(k).x[0];
	    t[k].mx[1]=t[k].mi[1]=p(k).x[1];
	    if(ls(k)){
			t[k].mx[0]=max(t[k].mx[0],t[ls(k)].mx[0]);
			t[k].mx[1]=max(t[k].mx[1],t[ls(k)].mx[1]);
			t[k].mi[0]=min(t[k].mi[0],t[ls(k)].mi[0]);
			t[k].mi[1]=min(t[k].mi[1],t[ls(k)].mi[1]);
	        s(k)+=s(ls(k));
	        S(k)+=S(ls(k));
	    }
	    if(rs(k)){
			t[k].mx[0]=max(t[k].mx[0],t[rs(k)].mx[0]);
			t[k].mx[1]=max(t[k].mx[1],t[rs(k)].mx[1]);
			t[k].mi[0]=min(t[k].mi[0],t[rs(k)].mi[0]);
			t[k].mi[1]=min(t[k].mi[1],t[rs(k)].mi[1]);
	        s(k)+=s(rs(k));
	        S(k)+=S(rs(k));
	    }
	}
	int New(){
	    return top?rub[top--]:++tot;
	}
	int build(int l,int r,int d){
	    if(l>r) return 0;
	    int k=New();
	    D=d;
	    nth_element(p+l,p+mid,p+1+r,cmp);
	    p(k)=p[mid];
	    ls(k)=build(l,mid-1,d^1);
	    rs(k)=build(mid+1,r,d^1);
	    pushup(k);
	    return k;
	}
	void clear(int k,int pos){
	    if(ls(k)) clear(ls(k),pos);
	    p[pos+s(ls(k))+1]=p(k);
	    rub[++top]=k;
	    if(rs(k)) clear(rs(k),pos+s(ls(k))+1);
	}
	void check(int &k,int d){
	    int c=A*s(k);
	    if(s(ls(k))>c||s(rs(k))>c){
	        clear(k,0);
	        k=build(1,s(k),d);
	    }
	}
	void insert(int &k,point p,int d){
	    if(!k){k=New(),ls(k)=rs(k)=0,p(k)=p,pushup(k);return;}
	    if(p.x[d]<=p(k).x[d]) insert(ls(k),p,d^1);
	    else insert(rs(k),p,d^1);
	    pushup(k);
	    check(k,d);
	}
	LL query(int k,int u,int l,int d,int r){
		if(u>t[k].mx[0]||d<t[k].mi[0]||l>t[k].mx[1]||r<t[k].mi[1]) return 0;
		LL ret=0;
		if(u<=t[k].mi[0]&&t[k].mx[0]<=d&&l<=t[k].mi[1]&&t[k].mx[1]<=r) return S(k);
		if(u<=p(k).x[0]&&p(k).x[0]<=d&&l<=p(k).x[1]&&p(k).x[1]<=r) ret+=p(k).p;
		if(ls(k)) ret+=query(ls(k),u,l,d,r);
		if(rs(k)) ret+=query(rs(k),u,l,d,r);
		return ret;
	}
}T;
int main(){
	freopen("P3755.in","r",stdin);
	freopen("P3755.out","w",stdout);
	n=read(),m=read();
	for(int i=1;i<=n;i++){
		int x=read(),y=read(),p=read();
		T.insert(T.rt,(point){x,y,p},0);
	}
	for(int i=1;i<=m;i++){
		int u=read(),l=read(),d=read(),r=read();
		printf("%lld\n",T.query(T.rt,u,l,d,r));
	}
	return 0;
}
```


---

## 作者：Booksnow (赞：1)

# CDQ分治算法(二维偏序)

我一翻题解，发现只有两篇 $CDQ$ 算法。其中一篇求了个三位偏序，~~**略显复杂**~~，另外一篇呢~~叙述**太过简略**~~，最近刚好又在做 $CDQ$ 的题，所以提供一篇 $CDQ$ 算法的详细解答方案。

若不知道什么是 $CDQ$ 算法的同学可以先了解一下：
[CDQ算法传送门](https://www.luogu.com.cn/blog/TX-20060303-ldlh/solution-p4169)

## 题目大意

- 给出 $n$ 个点以及其权值，提出 $m$ 次询问。

- 每次询问给出区间范围，求区间里包含(**边界上的点也要计算在内**)点的权值和。

## 解决方案

### 初步尝试

由题意，我们可以画出一张图：

![](https://cdn.luogu.com.cn/upload/image_hosting/n4q1bk2p.png)

其实这道题就是在求红色区域内的**点权和**。如何计算？我们可以先将所有的点以 $x$ 为第一关键字、$y$ 为第二关键字**升序排列**，如下：

```cpp
inline bool cmp1(node a,node b)		//以x为第一关键词排序 
{
    if(a.x!=b.x) return a.x<b.x;
    else if(a.y!=b.y) return a.y<b.y;
    else return a.opt<b.opt;
}
```
然后我们发现，我们完全可以用 $CDQ$ 分治算法统计点  $x$ **左下方所有点的权值**。也就是说，我们按照x的升序排列后，每次分治两块，右边的一块 $x$ 坐标肯定大于左边的一块，我们只需要**比较 $y$ 坐标的大小**即可。我们在判断前对每个块**以 $y$ 为第一关键词**进行一次排序，则可以在**遍历到比左边块 $y$ 坐标大的值时**，可以**直接退出循环**。则当访问到给出区间的端点时，必然**已经遍历**过其左下方的所有点，用一个变量记录权值，我们就能分别求得区间四个端点**左下方所有点的权值和**。

到了这儿，我相信大家都能发现我们可以对答案进行**容斥**。设 $a[i].ans$ 为端点 $i$ 左下方所有点的权值和。则答案就是

$$ans=a[(a2,b2)].ans+a[a1,b1].ans-a[a1,b2].ans-a[a2,b1].ans$$

### 改正错误

但果真如此吗？经过~~一系列的错误~~，我发现，我们减去的两个区间刚好也减掉了红色部分的边界。而题目要求我们要**将边界计算在内**。所以，我们又能画出下面这张图：

![](https://cdn.luogu.com.cn/upload/image_hosting/c3smc275.png)

我们的边界分别向 $x$ 轴和 $y$ 轴**扩张**了 $1$，此时我们再进行容斥，**就会把 $x=a1-1$ 和 $y=b1-1$ 这两条线上的点容斥掉**。所以，最后的终极图为：

![](https://cdn.luogu.com.cn/upload/image_hosting/4xw1zcmk.png)

从整个矩形中减去黄色部分，由于**橙色部分被减去了两次**，需要加回来一次，最终的公式为：

$$ans=a[(a2,b2)].ans+a[a1-1,b1-1].ans-a[a1-1,b2].ans-a[a2,b1-1].ans$$

## 小结

这道题的做法很多，分块， $CDQ$ 算法， $KD-Tree$ 算法……在 $CDQ$ 中加了**容斥**的知识，可以说是一道比较综合的题目。

## Code

接下来我发出 $AC$ 代码，大家可以结合理解一下：

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn=1001001;
int n,m,tot;
//x、y存坐标，val存储点权，opt表示此次操作的性质(查询或插入)，k是容斥系数，num是询问脚标 
struct node{
	ll x,y,val,opt,k,num,ans;
}a[maxn],b[maxn];
ll ans[maxn];

inline bool cmp1(node a,node b)		//以x为第一关键词排序 
{
    if(a.x!=b.x) return a.x<b.x;
    else if(a.y!=b.y) return a.y<b.y;
    else return a.opt<b.opt;
}

inline bool cmp2(node a,node b) 	//以y为第一关键词排序 
{
	if(a.y!=b.y) return a.y<b.y;
	else if(a.x!=b.x) return a.x<b.x;
	else return a.opt<b.opt;
}
//分治核心代码 
inline void solve(int l,int r)
{
    if(l==r) return;
    int mid=(l+r)>>1;
    solve(l,mid); solve(mid+1,r);
 	//记录点权前缀和(目前遍历到的点的点权和) 
	ll cnt=0;
	int L=l,R=mid+1,temp=l; 
	sort(a+l,a+mid+1,cmp2);		//左右两块分别排序 
	sort(a+mid+1,a+r+1,cmp2); 
    while(R<=r){
        while(a[L].y<=a[R].y&&L<=mid){
            if(a[L].opt==1) cnt+=a[L].val;
            b[temp++]=a[L++];
        }
        if(a[R].opt==2) a[R].ans+=cnt;	//更新 
        b[temp++]=a[R++];
    }
    while(L<=mid) 
		b[temp++]=a[L++];
    while(R<=r) 
		b[temp++]=a[R++];
    for(int i=l;i<=r;++i)	//更新答案 
		a[i]=b[i];	
}

int main()
{
    scanf("%d%d",&n,&m);
    int x,y; ll z; 
    //将初始点看作是插入操作 
    for(int i=1;i<=n;++i){
        scanf("%d%d%lld",&x,&y,&z);
        a[++tot].x=x; a[tot].y=y;
		a[tot].val=z; a[tot].opt=1;
    }
    int x1,x2,y1,y2;
 	//opt==1表示插入，opt==2表示查询 
    for(int i=1;i<=m;++i){
        scanf("%d%d%d%d",&x1,&y1,&x2,&y2);
        a[++tot].x=x2; a[tot].y=y2;
        a[tot].opt=2; a[tot].k=1; a[tot].num=i;
        a[++tot].x=x1-1; a[tot].y=y1-1;
        a[tot].opt=2; a[tot].k=1; a[tot].num=i;
        a[++tot].x=x1-1; a[tot].y=y2;
        a[tot].opt=2; a[tot].k=-1; a[tot].num=i;
        a[++tot].x=x2; a[tot].y=y1-1;
        a[tot].opt=2; a[tot].k=-1; a[tot].num=i;
    }
    sort(a+1,a+1+tot,cmp1);
    solve(1,tot);
    for(int i=1;i<=tot;++i)		//一波容斥 
    	if(a[i].opt==2) ans[a[i].num]+=a[i].k*a[i].ans;
    for(int i=1;i<=m;++i)
    	printf("%lld\n",ans[i]);
    return 0;
}
```


---

## 作者：Isonan (赞：1)

原题传送门[>Here<](https://www.luogu.org/problemnew/show/P3755)

题解里居然没有cdq分治。。吓的蒟蒻还以为自己学的是假的cdq。

这题用cdq没什么好说的，就是标准的三维偏序问题：

初始的n个基站看作是修改操作；

求矩形内部数值和就像二维前缀和一样拆开来做；

最后离散化一下y，然后把值都丢到树状数组里。

代码：

```cpp
#include <cstdio>
#include <algorithm>

struct point{
	int opt,x,y,orig,p;
}num[800001],tem[800001];
int n,m,all[400001],top,tt,lim,t1,t2,t3,t4;
long long c[400001],ans[200001];
void update(int ind,long long num){for(;ind<=lim;ind+=ind&-ind)c[ind]+=num;}
long long query(int ind){
	long long tot=0;
	for(;ind;ind-=ind&-ind)tot+=c[ind];
	return tot;
}
void cdq(int l,int r){
	if(l==r)return;
	int mid=(l+r)>>1;
	cdq(l,mid);
	cdq(mid+1,r);
	int i=l,j=mid+1,ind=l-1;
	while(i<=mid&&j<=r){
		if(num[i].x<num[j].x||(num[i].x==num[j].x&&num[i].opt<num[j].opt)){
			if(num[i].opt==1){
				update(num[i].y,num[i].p);
			}
			tem[++ind]=num[i++];
		}
		else{
			if(num[j].opt==2){
				ans[num[j].orig]+=query(num[j].y)*(long long)num[j].p;
			}
			tem[++ind]=num[j++];
		}
	}
	while(j<=r){
		if(num[j].opt==2){
			ans[num[j].orig]+=query(num[j].y)*(long long)num[j].p;
		}
		tem[++ind]=num[j++];
	}
	for(int k=l;k<i;k++)if(num[k].opt==1)update(num[k].y,-num[k].p);
	while(i<=mid)tem[++ind]=num[i++];
	for(int k=l;k<=r;k++)num[k]=tem[k];
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++){
		scanf("%d%d%d",&t1,&t2,&t3);
		num[++tt]=(point){1,t1,t2,0,(long long)t3};
		all[++top]=t2;
	}
	for(int i=1;i<=m;i++){
		scanf("%d%d%d%d",&t1,&t2,&t3,&t4);
		num[++tt]=(point){2,t3,t4,i,1};
		num[++tt]=(point){2,t1-1,t4,i,-1};
		num[++tt]=(point){2,t3,t2-1,i,-1};
		num[++tt]=(point){2,t1-1,t2-1,i,1};
		all[++top]=t4;
		all[++top]=t2-1;
	}
	std::sort(all+1,all+top+1);
	lim=std::unique(all+1,all+top+1)-all-1;
	for(int i=1;i<=tt;i++)num[i].y=std::lower_bound(all+1,all+lim+1,num[i].y)-all;
	cdq(1,tt);
	for(int i=1;i<=m;i++)printf("%lld\n",ans[i]);
}
```

---

## 作者：yizhiming (赞：0)

## 题目大意

有一个 $2^{31}\times 2^{31}$ 大小的矩形，其中有 $n$ 个位置有值，其他位置值为 $0$，$m$ 次查询一个子矩形的和。

$1\leq n,m \leq 10^5$。

## 题目分析

注意到有值的点很少，所以我们只考虑维护有值的地方，我们先想如果是一个较小的矩形怎么做呢？用二维前缀和做到 $n^2$，或者用可持久化维护，做到单次 $n\log m$，我们发现都不是很好地适应这道题。

怎么办呢？我们想我们维护的位置很少，所以我们当前查询到了一个空的区间，直接返回 $0$ 即可，其他时候返回区间值，这东西怎么做呢？我们会发现动态开点线段树的查询和这个东西很像。

所以我们就有了一个基本的雏形，考虑用动态开点维护一维信息，另一维怎么办呢？常见套路可持久化再维护一维即可。

我们考虑按照横坐标大小排序，这样就最多会有 $n$ 个版本，然后每个版本下标是纵坐标，值是对应的值，我们考虑怎么由上个版本转移到下个版本，我们发现每次只需要将当前行所有的值直接插入到线段树上即可，这样做最多只需要插入 $n$ 次，总复杂度是 $O(n\log V)$ 的。

查询就是可持久化线段树的板子了，注意当前区间为空直接返回 $0$ 即可。

还要注意我们每次查询都要二分横坐标，找到对应的版本号才行。

## Code

注意线段树是可以维护下标为负数的情况的，但是要注意要用向下取整，而不是强制类型转换。

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <queue>
#define int long long
using namespace std;
int read(){
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
const int N = 1e5+5;
struct aa{
	int lc,rc,val,cnt;
}node[N*80];
int tot,rt[N];
void ins(int &u,int v,int l,int r,int pla,int x){
	u = ++tot;
	node[u] = node[v];
	node[u].val+=x;
	node[u].cnt++;
	if(l==r){
		return;
	}
	int mid = floor((l+r)/2.0);
	if(pla<=mid){
		ins(node[u].lc,node[v].lc,l,mid,pla,x);
	}else{
		ins(node[u].rc,node[v].rc,mid+1,r,pla,x);
	}
}
struct bb{
	int x,y,z;
	bool operator<(const bb&a)const{
		return x<a.x;
	}
}in[N];
int Maxn = 2147483647;
int num[N],cnt;
int ask1(int val){
	int l=1,r=cnt;
	int ans = 0;
	while(l<=r){
		int mid = (l+r)/2;
		if(num[mid]>=val){
			ans = mid;
			r = mid-1;
		}else{
			l = mid+1;
		}
	}
	return ans;
}
int ask2(int val){
	int l=1,r=cnt;
	int ans = 0;
	while(l<=r){
		int mid = (l+r)/2;
		if(num[mid]<=val){
			ans = mid;
			l = mid+1;
		}else{
			r = mid-1;
		}
	}
	return ans;
}
int query(int u,int v,int l,int r,int ll,int rr){
	if(node[v].cnt-node[u].cnt==0){
		return 0;
	}
	if(l==ll&&r==rr){
		return node[v].val-node[u].val;
	}
	int mid = floor((l+r)/2.0);
	if(rr<=mid){
		return query(node[u].lc,node[v].lc,l,mid,ll,rr);
	}else if(ll>mid){
		return query(node[u].rc,node[v].rc,mid+1,r,ll,rr);
	}else{
		return query(node[u].lc,node[v].lc,l,mid,ll,mid)+query(node[u].rc,node[v].rc,mid+1,r,mid+1,rr);
	}
} 
signed main(){
	int n,m;
	n = read();m = read(); 
	for(int i=1;i<=n;i++){
		in[i].x = read();in[i].y = read();in[i].z = read();
	}
	sort(in+1,in+1+n);
	for(int i=1;i<=n;i++){
		if(in[i-1].x!=in[i].x||i==1){
			cnt++;
			rt[cnt] = rt[cnt-1];
			num[cnt] = in[i].x;
		}
//		cout<<"CNT:"<<cnt<<" "<<in[i].x<<" "<<in[i].y<<" "<<in[i].z<<"\n";
		ins(rt[cnt],rt[cnt],-Maxn-1,Maxn,in[i].y,in[i].z);
	}
	int a1,b1,a2,b2;
	while(m--){
		a1 = read();b1 = read();a2 = read();b2 = read();
		a1 = ask1(a1);a2 = ask2(a2);
//		cout<<"A:"<<a1<<" "<<a2<<"\n";
		if(a1==0||a2==0){
			cout<<0<<"\n";
		}else{
			cout<<query(rt[a1-1],rt[a2],-Maxn-1,Maxn,b1,b2)<<"\n";
		}
	}
	return 0;
}

```


---

## 作者：黑影洞人 (赞：0)

# CDQ分治

对于这道题，可以参考 [P4390 [BOI2007]Mokia 摩基亚](https://www.luogu.com.cn/problem/P4390) 的做法,可以通过 CDQ 分治离线操作高效处理出答案（我常数大,不能体现出 CDQ 分治的优秀)。

可以发现,操作 $1$ 和操作 $2$ 分好了界限,于是我们只需要统计答案，不用再使用树状数组维护。

对于 CDQ 分治,我们可以先看一道例题（逆序对）：
```cpp
//这是很经典的二维偏序问题，满足下标和值的大小关系即可。
void cdq(int l,int r){
	if(l==r)return;
	int mid=(l+r)/2;
	cdq(l,mid);cdq(mid+1,r);
	int i=l,j=mid+1,k=l;
	while(i<=mid&&j<=r){
		if(a[i]<=a[j])tmp[k++]=a[i++];
		else ans+=mid-i+1,tmp[k++]=a[j++];
	}
	while(i<=mid)tmp[k++]=a[i++];
	while(j<=r)tmp[k++]=a[j++];
	for(int i=l;i<=r;i++)a[i]=tmp[i];
}
```
很显然,本题也是一个二维偏序问题。对于询问 $x$ $y$ ,查询 $\sum_{i=0}^x\sum_{j=0}^y val_{i,j}$ ，$val_{i,j}$ 为点 $(i,j)$ 的值。

对于 $i$ 的贡献,我们只需要找到 $x_i<x_j,y_i<y_j$ 对于每个数对,答案加上 $i$ 位置的权值,具体实现和逆序对相似。

先按照 $x$ 排个序,在分治算法中找到 $y_i<y_j$ 的数对即可。

```cpp
void cdq(int l,int r){
	if(l==r)return;
	int mid=(l+r)/2;
	cdq(l,mid);cdq(mid+1,r);
	int i=l,j=mid+1,k=l,cnt=0;
	while(j<=r&&i<=mid){
		if(q[i].y<=q[j].y){
			if(q[i].typ==1)cnt+=q[i].a;//对于i，yj>yi,且y点有值，那么加上
			tmp[k++]=q[i++];
		}else{
			if(q[j].typ==2)q[j].a+=cnt;//如果q[j].y<q[i].y,那么j这个点的贡献加上之前累加的cnt，因为这里的i是上一次询问的i，没动过。
			tmp[k++]=q[j++];	
		}
	}
	while(i<=mid){//再次统计一遍，以免漏掉
		if(q[i].typ==1)cnt+=q[i].a;
		tmp[k++]=q[i++];
	}
	while(j<=r){
		if(q[j].typ==2)q[j].a+=cnt;
		tmp[k++]=q[j++];
	}
	for(int i=l;i<=r;i++)q[i]=tmp[i];//归并排序
}
```
最后按照询问的时间排序,运用差分知识统计一下矩阵和即可：

```cpp
#include<cstdio>
#include<algorithm>
#define N 1919810
#define int long long
using namespace std;
int n,m,tot;
struct node{
	int x,y,typ,a,t;
}q[N],tmp[N];
bool cmp(node a,node b){
    if(a.x!=b.x)return a.x<b.x;
    else if(a.y!=b.y)return a.y<b.y;
    return a.typ<b.typ;
}
bool cmp2(node a,node b){return a.t<b.t;}
void cdq(int l,int r){
	if(l==r)return;
	int mid=(l+r)/2;
	cdq(l,mid);cdq(mid+1,r);
	int i=l,j=mid+1,k=l,cnt=0;
	while(j<=r&&i<=mid){
		if(q[i].y<=q[j].y){
			if(q[i].typ==1)cnt+=q[i].a;
			tmp[k++]=q[i++];
		}else{
			if(q[j].typ==2)q[j].a+=cnt;
			tmp[k++]=q[j++];	
		}
	}
	while(i<=mid){
		if(q[i].typ==1)cnt+=q[i].a;
		tmp[k++]=q[i++];
	}
	while(j<=r){
		if(q[j].typ==2)q[j].a+=cnt;
		tmp[k++]=q[j++];
	}
	for(int i=l;i<=r;i++)q[i]=tmp[i];
}
signed main(){
	scanf("%lld%lld",&n,&m);
	for(int i=1;i<=n;i++)q[++tot].typ=1,q[tot].t=tot,scanf("%lld%lld%lld",&q[tot].x,&q[tot].y,&q[tot].a);
	for(int i=1;i<=m;i++){
		int x,y,xx,yy;
		scanf("%lld%lld%lld%lld",&x,&y,&xx,&yy);
		q[++tot].x=xx,q[tot].y=yy,q[tot].typ=2,q[tot].t=tot;
		q[++tot].x=x-1,q[tot].y=yy,q[tot].typ=2,q[tot].t=tot;
		q[++tot].x=xx,q[tot].y=y-1,q[tot].typ=2,q[tot].t=tot;
		q[++tot].x=x-1,q[tot].y=y-1,q[tot].typ=2,q[tot].t=tot;	
	}
	sort(q+1,q+tot+1,cmp);
	cdq(1,tot);
	sort(q+1,q+tot+1,cmp2);
	for(int i=n+1;i<=tot;i++){
		printf("%lld\n",q[i].a-q[i+1].a-q[i+2].a+q[i+3].a);
		i+=3;
	}
	return 0;
}


```



---

## 作者：BigJoker (赞：0)

# Preface

这是一道 cdq 分治的好题。

# Solution

先考虑一下对于任意一个点 $i$ 其左下角所有的功率和如何计算。

满足的条件必须是 $x_j\le x_i,y_j\le y_i$ 这个会读题就行，那么如何计算一个矩形内的呢。

不难想到二维前缀和的计算公式，这里不细推。

所以可以考虑将问题进行一下转换，算每个查询点左下角的功率和，然后根据二维前缀和进行计算。

不难想到二维偏序，但是这里为了复习一下 cdq，所以采用了三维偏序。

增添了一个维度，那就是看当前这个点是询问还是本来就有功率。

这样就是一道十分正宗的三维偏序问题。

利用 cdq 分治进行解决。

第一维用排序搞定，第二维用 cdq 搞定，第三维因为只涉及到 $0/1$，所以可以考虑直接用变量来进行存储。


这道题重在将一个问题转换为一个 cdq 可以解决的问题，这种思想十分重要。

~~所以我为什么不用二维偏序~~

# Code

```cpp
#include<bits/stdc++.h>
//#define int long long
#define mem(a,x) memset(a,x,sizeof(a))
#define inf 0x3f3f3f3f
#define max(a,b) (a>b?a:b)
#define min(a,b) (a<b?a:b)
#define re register
#define il inline
using namespace std;
typedef long long LL;
const int N=1e5+5;
il int qr(){
	int s=0,f=1;
	char ch=getchar();
	while(!isdigit(ch)){if(ch=='-') f=-1;ch=getchar();}
	while(isdigit(ch)){s=s*10+ch-'0';ch=getchar();}
	return s*f;
}
il void qw(LL x){
	if(x<0) putchar('-'),x=-x;
	if(x>9) qw(x/10);
	putchar(x%10+'0');
}
int n,m;
LL ans[N][4];
struct node{
	int x,y,p,id;
}a[N*5];
bool cmpx(node x,node y){
	if(x.x^y.x) return x.x<y.x;
	if(x.y^y.y) return x.y<y.y;
	return x.id<y.id;
}
bool cmpy(node x,node y){
	return x.y<y.y;
}
il void cdq(int l,int r){
	if(l==r) return ;
	int mid=l+r>>1;
	cdq(l,mid),cdq(mid+1,r);
	sort(a+l,a+mid+1,cmpy);
	sort(a+mid+1,a+r+1,cmpy);
	int j=l;
	LL res=0;
	for(int i=mid+1;i<=r;i++){
		while(j<=mid && a[j].y<=a[i].y){
			if(!a[j].id) res+=a[j].p;
			j++;
		}
		if(a[i].id) ans[a[i].id][-a[i].p]+=res;
	}
}
int main(){
	n=qr(),m=qr();
	for(int i=1;i<=n;i++) a[i]=((node){qr(),qr(),qr(),0});
	int cnt=n;
	for(int i=1;i<=m;i++){
		int A=qr(),B=qr(),C=qr(),D=qr();
		a[++cnt]=((node){C,D,0,i});
		a[++cnt]=((node){C,B-1,-1,i});
		a[++cnt]=((node){A-1,D,-2,i});
		a[++cnt]=((node){A-1,B-1,-3,i});
	}
	sort(a+1,a+1+cnt,cmpx);
	cdq(1,cnt);
	for(int i=1;i<=m;i++) qw(ans[i][0]-ans[i][1]-ans[i][2]+ans[i][3]),putchar('\n');
	return 0;
}
```

---

## 作者：happybob (赞：0)

## 题意

给定一个二维平面，其中有多个点 $(x_i, y_i)$，对于每个点 $(x_i, y_i)$ 都有一个权值 $p_i$。给定多组询问，每次询问点对 $(x_1, y_1)$ 和点对 $(x_2, y_2)$ 之间的矩阵中的权值和。

## 解法

各位都有分块、主席树等各种写法，那我来加一个 CDQ 分治的写法。

首先我们思考如何将这个问题转化成三维偏序。

考虑点对 $(x_1, y_1)$ 和点对 $(x_2, y_2)$ 之间的矩阵和，我们可以将其转化成一个二维前缀和问题，就是将一次询问拆成四组询问，分别是：

1. 矩阵 $(x_2, y_2)$ 到 $(1, 1)$ 的和，设这个和为 $a_1$。

1. 矩阵 $(x_1 - 1, y_1 - 1)$ 到 $(1, 1)$ 的和，设这个和为 $a_2$。

1. 矩阵 $(x_2, y_1 - 1)$ 到 $(1, 1)$ 的和，设这个和为 $a_3$。

1. 矩阵 $(x_1 - 1, y2)$ 到 $(1, 1)$ 的和，设这个和为 $a_4$。

那么显然这次询问的答案即为 $a_1 + a_2 - a_3 - a_4$。

但是仔细一看这还是个二维偏序，所以给他加一维，表示这个点是询问还是给定的点。

然后就是三维偏序板子，注意这题可以不用树状数组，因为第三维只有可能是 $0$ 或 $1$。

代码：

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;

#define ll long long

constexpr int N(5e5 + 5);

int n, m;
ll ans[N];

struct Node
{
	int x, y, z, p, id, s;
	ll sum;
	/*
	* x, y: 坐标
	* z: 表示是否是询问
	* p: 权值
	* id: 询问编号
	* s: 正负性
	* sum: 和
	*/
	bool operator<(const Node& g) const
	{
		if (x ^ g.x) return x < g.x;
		if (y ^ g.y) return y < g.y;
		return z < g.z;
	}
}q[N], w[N];

inline void merge_sort(int l, int r)
{
	if (l >= r) return;
	int mid(l + r >> 1);
	merge_sort(l, mid);
	merge_sort(mid + 1, r);
	int i(l), j(mid + 1), k(0);
	ll sum(0);
	while (i <= mid && j <= r)
	{
		if (q[i].y <= q[j].y)
		{
			sum += !q[i].z * q[i].p, w[k++] = q[i++];
		}
		else
		{
			q[j].sum += sum * q[j].s;
			w[k++] = q[j++];
		}
	}
	while (i <= mid) sum += !q[i].z * q[i].p, w[k++] = q[i++];
	while (j <= r)
	{
		q[j].sum += sum * q[j].s;
		w[k++] = q[j++];
	}
	for (i = l, j = 0; j < k; i++, j++) q[i] = w[j];
}

signed main()
{
	scanf("%d%d", &n, &m);
	for (int i(0); i < n; i++)
	{
		int x, y, p;
		scanf("%d%d%d", &x, &y, &p);
		q[i] = { x, y, 0, p, 0, 0, 0 };
	}
	int p(n - 1);
	for (int i(1); i <= m; i++)
	{
		int x1, y1, x2, y2;
		scanf("%d%d%d%d", &x1, &y1, &x2, &y2);
		q[++p] = { x1 - 1, y2, 1, 0, i, -1, 0 };
		q[++p] = { x2, y1 - 1, 1, 0, i, -1, 0 };
		q[++p] = { x2, y2, 1, 0, i, 1, 0 };
		q[++p] = { x1 - 1, y1 - 1, 1, 0, i, 1, 0 };
	}
	sort(q, q + p + 1);
	merge_sort(0, p);
	for (int i(0); i <= p; i++)
	{
		if (q[i].z)
		{
			ans[q[i].id] += q[i].sum;
		}
	}
	for (int i(1); i <= m; i++) printf("%lld\n", ans[i]);
	return 0;
}
```


---

## 作者：huangrenheluogu (赞：0)

## P3755题解 离线+树状数组

[兄弟题目P2163](https://www.luogu.com.cn/problem/P2163)

看到这一道题目，我回想起了以前学习的二维前缀和，里面就用到了容斥原理。那么，这道题目我们为什么不可以用容斥原理呢？我在这里给大家讲解一下。

### 求面积

我们先规定下，$S_{x,y}$ 表示左下角和右上角为 $(0,0)$ 和 $(x,y)$ 的矩阵内的功率总和。用左上角和右上角来表示一个矩形。用 $f((x1,y1),(x2,y2))$ 表示图形面积的表示方法。

我们可以观察下面的一幅图片。

![如何计算{(x1,y1),(x2,y2)}的前缀和](https://cdn.luogu.com.cn/upload/image_hosting/j5kohsdc.png)

这一幅图片我们可以用**容斥原理**来解决。我们看下一幅图。

![计算方法](https://cdn.luogu.com.cn/upload/image_hosting/2dra3unm.png)

在这一幅图形里我标出了许多的颜色。我们可以用**绿色+紫色-蓝色-黄色**这样的方法来表示橙色矩形的面积，也可以说成是它内部的和。

于是可以得出公式：

$f((x1,y1),(x2,y2))=s_{x2,y2}+s_{x1,y1}-s_{x1,y2}-s_{x2,y1}$

**但是这里仅仅是面积，至于这里是连长都要计算的我们应该另外考虑。**

![再探索](https://cdn.luogu.com.cn/upload/image_hosting/7kujoe0l.png)

我们发现，橙色的边缘是要用到的，所以我们不用的边缘应该需要再原来的基础上 $-1$ 。

![explore](https://cdn.luogu.com.cn/upload/image_hosting/pgeo52x7.png)

对于重复的部分，我们发现，黄色部分是重复的，所以我们的重复部分也是需要 $-1$ 的。由此，公式可以变为：

$f((x1,y1),(x2,y2))=s_{x2,y2}+s_{x1-1,y1-1}-s_{x1-1,y2}-s_{x2,y1-1}$

但是再打这道题目的时候我是没有想到的，只是后来自己调试的时候才改的，所以调试也是很重要的。


### 离散化

我们注意到，$x,y$ 都是 int 范围的，所以我们数组肯定开不下，所以就需要用到离散化了。

至于用什么去离散。我认为，需要离散的东西如下：

- 树的坐标 $x,y$

- 左下角（记得减去1）和右上角的 $x,y$ 。

如何去重复的数字，都是紫题了，大家自己思考吧。

### 树状数组优化快速求解

接下来就是求解的问题了。

本题有两个限制条件，那我们是不是可以**通过枚举的顺序把一种条件抵消，并且通过数据结构把另一种抵消**呢？在这一道题目里，我们可以**离线**，并不一定出来一个马上有答案，先存着。而求答案的顺序，就是排序之后以 $x$ 轴升序扫描一遍，有点像扫描线的样子。

扫到自己之后，由于此时 $x$ 都是比自己小的，所以用树状数组统计 $y$ 比自己小的功率之和就可以了。

统计点的时候，我们可以这样开结构体，并且把基站和区间的四个角。

```cpp
struct data{
	int x,y,id,mul,xx;
   //id：序号，方便后面统计答案，并且作为排序依据，如果是基站，那么id为0
   //mul：乘，就是统计乘1还是-1，后面统计答案方便
   //xx：当前点的功率
}point[2500005];
```

但是排序部分我认为 cmp 这个函数需要说明一下。

```cpp
inline bool cmp(data x,data y){
	if(x.x==y.x){
		return x.id<y.id;//如果x一样的话，就用id来辅助，由于我把基地的id设为0，所以小的在前，大的在后，确保统计
	}
	return x.x<y.x;//以x为主体
}
```

### 编写代码

然后我们就可以写出我们的代码了。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
inline int N=2500005,INF=1e9;
int n,m,tem_y[2500005],x,y,z,tot,x_1,y_1,c[2500005],ans[2500005],pose;//tem_y离散化工具
struct data{
	int x,y,id,mul,xx;
}point[2500005];
inline void read(int &res){//读优加速
	res=0;int f=1;char ch=getchar();
	while('0'>ch||ch>'9'){
		if(ch=='-') f=-1;
		ch=getchar();
	}
	while('0'<=ch&&ch<='9'){
		res=(res<<1)+(res<<3)+(ch^48);
		ch=getchar();
	}
	res*=f;
}
inline bool cmp(data x,data y){
	if(x.x==y.x){
		return x.id<y.id;
	}
	return x.x<y.x;
}
//树状数组
inline int lowbit(int x){return x&-x;}
inline void add(int x,int k){
	while(x<=tem_y[0]){
		c[x]+=k;
		x+=lowbit(x);
	}
}
inline int get(int x){
	int res=0;
	while(x){
		res+=c[x];
		x-=lowbit(x);
	}
	return res;
}

inline int find(int x){//我用二分去寻找离散之后的值
	int mid,l=1,r=tem_y[0];
	while(l<=r){
		mid=l+r>>1;
		if(tem_y[mid]==x) return mid;
		if(tem_y[mid]>x) r=mid-1;
		else l=mid+1;
	}
}
signed main(){
	read(n),read(m);
	for(int i=1;i<=n;i++){
		read(x),read(y);read(z);
		tem_y[++tem_y[0]]=y;
		point[++tot]=(data){x,y,0,0,z};
	}
	for(int i=1;i<=m;i++){
		read(x),read(y),read(x_1),read(y_1);
      //x_1,y_1是右上角，x,y是左上角
		tem_y[++tem_y[0]]=y-1;
		tem_y[++tem_y[0]]=y_1;
      //把四个角落都弄一边，记得-1
		point[++tot]=(data){x-1,y-1,i,1,0};
		point[++tot]=(data){x_1,y_1,i,1,0};
		point[++tot]=(data){x_1,y-1,i,-1,0};
		point[++tot]=(data){x-1,y_1,i,-1,0};
	}
    
   //去重
	sort(tem_y+1,tem_y+tem_y[0]+1);
	for(int i=1;i<tem_y[0];i++) if(tem_y[i]==tem_y[i+1]) tem_y[i]=INF;
	sort(tem_y+1,tem_y+tem_y[0]+1);
	while(tem_y[tem_y[0]]==INF) --tem_y[0];
	sort(point+1,point+tot+1,cmp);
	
    for(int i=1;i<=tot;i++){
		pose=find(point[i].y);
      //分类讨论，如果是矩形的四边形就计算，反之就加入这个点
		if(point[i].id) ans[point[i].id]+=point[i].mul*get(pose);
		else add(pose,point[i].xx);
	}
	for(int i=1;i<=m;i++) printf("%lld\n",ans[i]);
	return 0;
}
```

谢谢大家。

---


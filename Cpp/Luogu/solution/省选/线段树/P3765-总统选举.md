# 总统选举

## 题目背景

黑恶势力的反攻计划被小 C 成功摧毁，黑恶势力只好投降。秋之国的人民解放了，举国欢庆。此时，原秋之国总统因没能守护好国土，申请辞职，并请秋之国人民的大救星小 C 钦定下一任。

作为一名民主人士，小 C 决定举行全民大选来决定下一任。为了使最后成为总统的人得到绝大多数人认同，小 C 认为，一个人必须获得超过全部人总数的一半的票数才能成为总统。如果不存在符合条件的候选人，小 C 只好自己来当临时大总统。为了尽可能避免这种情况，小 C 决定先进行几次小规模预选，根据预选的情况，选民可以重新决定自己选票的去向。

由于秋之国人数较多，统计投票结果和选票变更也成为了麻烦的事情，小 C 找到了你，让你帮他解决这个问题。

## 题目描述

秋之国共有 $n$ 个人，分别编号为 $1,2,…,n$，一开始每个人都投了一票，范围 $1 \sim n$，表示支持对应编号的人当总统。

共有 $m$ 次预选，每次选取编号 $[l_i,r_i]$ 内的选民展开小规模预选，在该区间内获得超过区间大小一半的票的人获胜。如果没有人获胜，则由小 C 钦定一位候选者获得此次预选的胜利（获胜者可以不在该区间内），每次预选的结果需要公布出来，并且每次会有 $k_i$ 个人决定将票改投向该次预选的获胜者。

全部预选结束后，公布最后成为总统的候选人。

## 说明/提示

对于前 $20 \%$ 的数据，$1 \leq n,m \leq 5000$。

对于前 $40 \%$ 的数据，$1 \leq n,m \leq 50000$，$\sum k_i \leq 50000$。

对于前 $50 \%$ 的数据，$1 \leq n,m \leq {10}^5$，$\sum k_i \leq 2 \times {10}^5$。

对于数据点 6~7，保证所有选票始终在 $1 \sim 10$ 之间。

对于 $100 \%$ 的数据，$1 \leq n,m \leq 5 \times {10}^5$，$\sum k_i \leq 10^6$，$1 \leq l_i \leq r_i \leq n$，$1 \leq s_i \leq n$。

## 样例 #1

### 输入

```
5 4
1 2 3 4 5
1 2 1 1 3
5 5 1 2 2 4
2 4 2 0
3 4 2 1 4```

### 输出

```
1
5
5
2
-1```

# 题解

## 作者：Ynoi (赞：40)

蒟蒻的超短题解

事实上没必要写线段树，只用随机化就行了，每次在区间里随机取k个数，然后用平衡树判断是否在区间里出现次数 超过一半即可

这样的话，如果出现次数大于一半是数存在，没有随机到出现大于一半数的概率 肯定小于 $\frac{1}{2^k}$

稳妥起见 k 取 30比较好

但是本题由于极度卡常，所以说这样可能会被卡

但是事实上由于这个数出现次数往往大于区间一半，所以事实上概率是要小于 $\frac{1}{2^k}$

所以其实$k$取小一点是可以的

我是$k$取了$14$，然后平衡树用pb_ds写

然后就成为了本题最短解

```
#include<bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/tree_policy.hpp>
using namespace __gnu_pbds;
using namespace std;
#define LL long long
#define MAXN 500005

tree<LL,null_type,less<LL>,rb_tree_tag,tree_order_statistics_node_update> s[MAXN];
int n,m,an;
int a[MAXN];
int c[MAXN],d[MAXN],f[MAXN],nn,mm = 14;
int p[MAXN];
void rd() {
	cin >> n >> m;
	for(int i = 1; i <= n; i ++) {
		scanf("%d",&a[i]);
		s[a[i]].insert(i); 
	}
}

int qwq(int x,int l,int r) {
	return s[x].order_of_key(r+1) - s[x].order_of_key(l); 
} 

int solve(int l,int r)
{
	int n = r-l+1;
	for(int i = 1; i <= mm; i ++)
	{
		int x = rand()%n+l;
		x = a[x];
		if(qwq(x,l,r) > (n>>1)) return x;
	}
	return -1;

}

signed main()
{
	rd();
	an = -1;
	for(int i = 1; i <= m; i ++)
	{
		int l,r,k,ss;
		scanf("%d%d%d%d",&l,&r,&ss,&k);
		for(int j = 1; j <= k; j ++)
			scanf("%d",&p[j]);
		int ans = solve(l,r);
		
		if(ans == -1) {
			ans = ss;
			printf("%d\n",ss);
		} else printf("%d\n",ans);
		
		for(int j = 1; j <= k; j ++) {
			s[ a[p[j]] ].erase(p[j]);
			a[p[j]] = ans;
			s[ ans ].insert(p[j]);
		}
	}
	cout<<solve(1,n)<<"\n";
	return 0;
 } 

```

---

## 作者：LengChu (赞：39)

~~蒟蒻的超长代码~~

~~理解到以后 这道题其实就是平衡树和线段树的模板而已~~

------------

### 前置技能 p2397 yyy loves Maths VI (mode)

题意是找n个数内出现次数大于n/2的数 保证存在这个数

用的方法叫做**摩尔投票法**

    首先我们注意到这样一个现象： 在任何数组中，出现次数大于该数组长度一半的值只能有一个。

    摩尔投票法的基本思想很简单，在每一轮投票过程中，从数组中找出一对不同的元素，将其从数组中删除。

    这样不断的删除直到无法再进行投票，如果数组为空，则没有任何元素出现的次数超过该数组长度的一半。如果只存在一种元素，那么这个元素则可能为目标元素。

（注意这个可能 ~~这就是这道题代码长度翻一倍的原因~~

不懂？上代码一看就懂了

```cpp
int cnt=0,t=0;//t是目前找到的众数
for(int i=1;i<=n;i++)
{
	int x;
    scanf("%d",&x);
    if(cnt==0) t=x,cnt=1;
    else 
    {
    	if(x!=t) cnt--;
    	else cnt++;
	}
}
```

这样做时间复杂度是线性的 而且连数组都不用开

------------

回到这道题

有了这个前置技能以后 这道题的第一个思路应该很明显了：用线段树维护一个区间的cnt和众数

但是用线段树维护 必须保证维护的东西满足区间可加性

显然摩尔投票法是有区间可加性的

具体来说 如果两个儿子的众数相同 这个节点的众数就等于儿子的众数 cnt就等于两个儿子的cnt相加

如果不同 这个节点的众数就等于cnt较大的那个儿子的众数 cnt就等于大的减去小的

写成代码也很简单

```
if(tree[ls].num==tree[rs].num) tree[id].num=tree[ls].num,tree[id].cnt=tree[ls].cnt+tree[rs].cnt;
else
{
	if(tree[ls].cnt>=tree[rs].cnt) tree[id].cnt=tree[ls].cnt-tree[rs].cnt,tree[id].num=tree[ls].num;
	else tree[id].cnt=tree[rs].cnt-tree[ls].cnt,tree[id].num=tree[rs].num;
}
```

那么这道题已经解决了一半了

------------

目前还有一个问题 这道题并不保证有一个元素出现的次数超过区间的一半

也就是说我们费尽千辛万苦找到的众数可能是错的qwq

这里注意 如果有一个元素出现的次数超过区间的一半的话 找到的这个数一定是正确的 但是~~凡事就怕万一~~

所以我们需要验证这个数在这个区间内出现的次数是否大于区间的长度除以2

这里用平衡树来维护 其实我也想过线段树 ~~如果点数小的话应该是可以的 但是数据辣么大我还真写不出来~~

平衡树 动态开点 加上k总共<=10^6点条件 点是能开下的

怎么验证答案呢？

对于每一个人 开一个平衡树 树中存的是**所有支持他的人的编号**

对于一个区间l,r 我们要求的是编号在l~r之间的支持编号为i的人的数量

那么用平衡树找到编号小于等于r的人中支持i的人的数量 再找到编号小于等于l-1的人 相减就可以了

怎么找呢 因为不存在重复的数 其实就是找一个数的排名啦

------------
所以这道题的主要思路就是这样了

整理一下：

首先预处理 对于每一个人建一棵平衡树 也就是在a[i]这棵平衡树中加入i这个点 表示i这个人支持a[i] 然后建好线段树

然后处理询问 先在线段树中找到区间l,r中可能是众数的那个编号x 然后在平衡树中验证x在区间l,r中出现的次数是否大于(r-l+1) 如果大于 就把s替换成x

然后修改 要修改线段树的叶子节点 在原来i支持的人的那棵平衡树中删去i 在现在i支持的人的平衡树中加上i这个点

最后的处理和中间也是一样的

------------


然后就上代码啦 码量超大 因为打了一棵线段树 一棵平衡树 为了方便 封装了线段树和平衡树 因为喜欢splay打的splay以至于跑的非常慢

要建很多棵树的话 还是封装起来比较方便

个人认为这道题思路如果理清楚了就不算难 但是要有前置知识还要打对两棵树 在考场上还是很有难度

```
#include<bits/stdc++.h>
#define ls id<<1
#define rs id<<1|1
#define inf 0x7f7f7f7f
using namespace std;
int k,aa[5000010];

struct xd_node
{
    int l,r;
    int cnt,num;//和找众数那道题一样 维护一个cnt和众数的序号 
}tree[5000010];
struct xd_tree
{
    void change(int id)
    {
        if(tree[ls].num==tree[rs].num) tree[id].num=tree[ls].num,tree[id].cnt=tree[ls].cnt+tree[rs].cnt;
        else
        {
            if(tree[ls].cnt>=tree[rs].cnt) tree[id].cnt=tree[ls].cnt-tree[rs].cnt,tree[id].num=tree[ls].num;
            else tree[id].cnt=tree[rs].cnt-tree[ls].cnt,tree[id].num=tree[rs].num;
        }
    }
    void build(int id,int l,int r)
    {
        tree[id].l=l; tree[id].r=r;
        if(l==r)
        {
            tree[id].cnt=1;
            tree[id].num=aa[l];
            return;
        }
        int mid=(l+r)>>1;
        build(ls,l,mid); build(rs,mid+1,r);
        change(id);
    }
    void updata(int id,int pos,int w)
    {
        if(tree[id].l==pos&&tree[id].r==pos)
        {
            tree[id].num=w;
            tree[id].cnt=1;
            return;
        }
        int mid=(tree[id].l+tree[id].r)>>1;
        if(mid>=pos) updata(ls,pos,w);
        else updata(rs,pos,w);
        change(id);
    }
    xd_node search(int id,int l,int r)
    {
        if(tree[id].l==l&&tree[id].r==r) return tree[id];
        int mid=(tree[id].l+tree[id].r)>>1;
        if(mid>=r) return search(ls,l,r);
        else if(mid<l) return search(rs,l,r);
        else
        {
            xd_node a=search(ls,l,mid),b=search(rs,mid+1,r),c;
            if(a.num==b.num) c.num=a.num,c.cnt=a.cnt+b.cnt;
            else
            {
                if(a.cnt>=b.cnt) c.cnt=a.cnt-b.cnt,c.num=a.num;
                else c.cnt=b.cnt-a.cnt,c.num=b.num;
            }
            return c;
        }
    }
}a;

struct splay_node
{
    int fa,ch[2],w,size;
}t[5000010];//splay节点可以公用 节点数要开很大 
struct splay_tree
{
    int root;
    void updata(int x)
    {
        t[x].size=t[t[x].ch[0]].size+t[t[x].ch[1]].size+1;
    }
    void rotate(int x)
    {
        int y=t[x].fa; int z=t[y].fa;
        int f=x==t[y].ch[1];
        t[z].ch[y==t[z].ch[1]]=x; t[x].fa=z;
        t[y].ch[f]=t[x].ch[f^1]; t[t[x].ch[f^1]].fa=y;
        t[x].ch[f^1]=y; t[y].fa=x;
        updata(y); updata(x);
    }
    void splay(int x,int goal)
    {
        while(t[x].fa!=goal)
        {
            int y=t[x].fa;
            int z=t[y].fa;
            if(z==goal) rotate(x);
            else
            {
                if((t[z].ch[0]==y)^(t[y].ch[0]==x)) rotate(x); 
                else rotate(y);
                rotate(x);
            }
        }
        if(goal==0) root=x;
    }
    void find(int x)
    {
        int id=root; if(!id) return ;
        while(t[id].ch[x>t[id].w]&&t[id].w!=x) id=t[id].ch[x>t[id].w];
        splay(id,0);
    }
    int next(int x,int f)
    {
        find(x); int id=root;
        if((t[id].w>x&&f==1)||(t[id].w<x&&f==0)) return id;
        id=t[id].ch[f];
        while(t[id].ch[f^1]) id=t[id].ch[f^1];
        return id;
    }
    void adde(int x)
    {
        int id=root,fa=0;
        while(id) t[id].size++,fa=id,id=t[id].ch[x>t[id].w];
        t[++k].w=x; if(fa) t[fa].ch[x>t[fa].w]=k;
        t[k].fa=fa; t[k].size=1; splay(k,0);
    }
    void del(int x)
    {
        int qq=next(x,0),hj=next(x,1);
        splay(qq,0); splay(hj,qq);
        t[hj].ch[0]=0; updata(hj); updata(qq);
    }
    int get(int x)//找有多少个小于等于x的数 就是找x的排名 因为有个-inf的点 所以-1 又因为ans只加了左子树的大小没有加上x这个数 所以直接返回ans
    {
        find(x); if(t[root].w!=x) x=t[next(x,0)].w;//如果不存在x这个点 找x的前驱 
        int id=root,ans=0;
        while(1)
        {
            if(t[id].w>x) id=t[id].ch[0];
            else if(t[id].w==x) 
            {
                ans+=t[t[id].ch[0]].size;
                splay(id,0);
                return ans;
            }
            else
            {
                ans+=t[t[id].ch[0]].size+1;
                id=t[id].ch[1];
            }
        }
    }
}b[500010];//对每个人建一棵splay 存储支持他的人 

int main()
{
    int n,m;
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++) b[i].adde(-inf),b[i].adde(inf);//平衡树初始化 
    for(int i=1;i<=n;i++) scanf("%d",&aa[i]),b[aa[i]].adde(i);
    a.build(1,1,n);//线段树初始化 
    for(int i=1;i<=m;i++)
    {
        int l,r,s,q;
        scanf("%d%d%d%d",&l,&r,&s,&q);
        int x=a.search(1,l,r).num;//x是最有可能是区间众数的人 
        int sum=b[x].get(r)-b[x].get(l-1);//寻找l~r区间内支持x的人的个数 
        if(sum>(r-l+1)/2) s=x;//如果这个人数超过了区间的一半 
        for(int i=1;i<=q;i++)
        {
            scanf("%d",&x);
            a.updata(1,x,s);//把x支持的人变成s 
            b[aa[x]].del(x); aa[x]=s;
            b[aa[x]].adde(x); 
        }
        printf("%d\n",s);
    }
    int x=a.search(1,1,n).num;
    int sum=b[x].get(n);
    if(sum>n/2) printf("%d",x);
    else printf("-1");
    return 0;
}
```


---

## 作者：EnofTaiPeople (赞：19)

这道题正解是“摩尔投票法”，也有随机化的期望正确做法，我想到了一个神奇的做法，甚至达到了最优解远超次优解的神奇功效！提供一个很好的写法（并不能得到最优解，但思路一样）。

算法复杂度：$O(m\sqrt{n\log_2 n}+\sum k\log_2 n)$

怎么根号分治？设块长为 $K$，当询问长度在 $K$ 以内时，我们暴力求众数，时间复杂度 $O(K)$，否则，由于众数出现次数超过 $\frac{K}{2}$，这样的数一定不超过 $\frac{2n}{K}$ 个，求每一个数字在 $[l,r]$ 出现次数时间复杂度为 $O(\log_2 n)$ 单次修改只需用平衡树维护即可，总时间复杂度为 $O(m(K+\frac{n\log_2 n)}{K})+k\log_2 n)$ 当 $K=\sqrt{n\log_2 n}$ 最优，为 $O(m\sqrt{n\log_2 n}+\sum k\log_2 n)$.

代码很好实现：
```cpp
#include<bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp>
using namespace std;
using namespace __gnu_pbds;
const int N=5e5+4,M=2e6+6,D=1000;
char buf[M+5],*p1,*p2,c;
#define gc (p1==p2&&(p2=(p1=buf)+fread(buf,1,M,stdin),p1==p2)?EOF:*p1++)
inline int read(){
    int an=0,f=1;while(!isdigit(c=gc))if(c=='-')f=-f;
    do an=an*10+(48^c);while(isdigit(c=gc));return an*f;
}
tree<int,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update>tr[N];
vector<int>cd,wp;
#define Up(a,b) upper_bound(a.begin(),a.end(),b)
#define Lw(a,b) lower_bound(a.begin(),a.end(),b)
inline void Ins(int x){
	cd.insert(Up(cd,x),x);
}
inline void Del(int x){
	cd.erase(Lw(cd,x));
}
int n,m,k,a[N],cnt[N];
int main(){
	int i,x,l,r,cs,b;n=read(),m=read();
	for(i=1;i<=n;++i){
		tr[a[i]=read()].insert(i);
		if(tr[a[i]].size()==D+1)Ins(a[i]);
	}
	for(i=1;i<=m;++i){
		l=read(),r=read(),cs=read(),b=r-l+1>>1;
		if(r-l<=D+D+5){
			for(x=l;x<=r;++x)
				if(++cnt[a[x]]>b){
					cs=a[x];break;
				}
			for(x=l;x<=r;++x)cnt[a[x]]=0;
		}else{
			for(int x:cd)
				if(tr[x].order_of_key(r+1)-tr[x].order_of_key(l)>b){
					cs=x;break;
				}
		}printf("%d\n",cs);
		for(k=read();k;--k){
			x=read();tr[a[x]].erase(x);
			if(tr[a[x]].size()==D)Del(a[x]);
			tr[a[x]=cs].insert(x);
			if(tr[a[x]].size()==D+1)Ins(cs);
		}
	}cs=-1,b=n>>1;
	for(x=1;x<=n;++x)
		if(tr[x].size()>b)cs=x;
	printf("%d\n",cs);
	return 0;
}
```

---

## 作者：kczno1 (赞：11)

正解做法好强啊，就是用线段树来实现了暴力O(n)做法。

也就是bzoj那道题(名字我忘了..)。

我的做法就是线段树维护区间>一半的那个数mx[i]。

查询的时候，询问区间被分成了log个区间，而答案一定是其中的一个mx[i]，

否则他在所有区间都<=一半，显然在大区间也<=一半。

检验时也是对每个权值开个平衡树。

时间O(nlog^2)

```cpp
#include<bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>

using namespace std;
using namespace __gnu_pbds;

#define ll long long

#define gc getchar()
int read()
{
    char ch;
    while((ch=gc)<'0');
    int x=ch-'0';
    while((ch=gc)>='0')x=x*10+ch-'0';
    return x;
}

typedef
__gnu_pbds::
tree<int,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update> 
Tree;

const int N=500005;
Tree T[N];

int n;

void add(int x,int y)
{
    T[x].insert(y);
}
void del(int x,int y)
{
    T[x].erase(y);
}
int qiu(int x,int y)
{
    return T[x].order_of_key(y);
}

int a[N],mx[N*4];
int dy[N];
#define mid (l+r>>1)
#define cl (k*2)
#define cr (cl+1)
int L[N*4],R[N*4];
int Count(int x,int l,int r)
{
    if(r-l<=20)
    {
        int ans=0;
        for(;l<=r;++l)
        if(a[l]==x)++ans;
        return ans;
    }
    return qiu(x,r+1)-qiu(x,l);
}
void up(int k)
{
    int l=L[k],r=R[k];
    if(mx[cl])
    if(Count(mx[cl],l,r)*2>r-l+1) {mx[k]=mx[cl];return ;}
    if(mx[cr])
    if(Count(mx[cr],l,r)*2>r-l+1) {mx[k]=mx[cr];return ;}
    mx[k]=0;
}
void init(int k,int l,int r)
{
    L[k]=l;R[k]=r;
    if(l==r) 
    { 
      dy[l]=k; 
      add(mx[k]=a[l]=read(),l); 
      return ;
    }
    init(cl,l,mid);init(cr,mid+1,r);
    up(k);
}

int ql,qr,ans;
void modify()
{
    int x=read();
    if(a[x]==ans)return ;
    del(a[x],x);add(a[x]=ans,x);
    int k=dy[x];
    mx[k]=ans;
    while(k>>=1)up(k);
}
bool qiu(int k,int l,int r)
{
    if(ql<=l&&qr>=r)
    {
        if(mx[k])
        {
            if(Count(mx[k],ql,qr)*2>qr-ql+1) {ans=mx[k];return 1;}
        }
        return 0;
    }
    if(ql<=mid)if(qiu(cl,l,mid))return 1;
    if(qr>mid)if(qiu(cr,mid+1,r))return 1;
    return 0;
}

int main()
{

    n=read();int m=read();
    init(1,1,n);
    
    while(m--)
    {
        ql=read();qr=read();
        
        if(!qiu(1,1,n))ans=read();
        else read();
        printf("%d\n",ans);
        
        int k=read();
        while(k--) modify();
    }
    
    if(mx[1]) printf("%d\n",mx[1]);
    else puts("-1");
}
```

---

## 作者：Isonan (赞：9)

原题传送门[>Here<](https://www.luogu.org/problemnew/show/P3765)

考虑一个很重要的性质：

如果一个人在一个区间中占有超过一半的票数，那么把这个区间分成任意两个，他肯定在至少一个区间中占有超过一半的票数。

这样就可以合并两个区间了，那就可以用线段树维护，用平衡树查询一个人在给定区间内占有多少票。

修改的时候暴力改就可以了。

代码：

```cpp
#include <cstdio>
#include <vector>
#include <cstdlib>
#include <algorithm>

int root[500001],lson[500001],rson[500001],size[500001],pri[500001],n,m,num[500001],l,r,s,k;
void pushup(int x){size[x]=size[lson[x]]+size[rson[x]]+1;}
void split(int now,int k,int &x,int &y){
    if(!now)x=y=0;
    else{
        if(now<=k)x=now,split(rson[now],k,rson[x],y);
        else y=now,split(lson[now],k,x,lson[y]);
        pushup(now);
    }
}
int merge(int x,int y){
    if(!x||!y)return x^y;
    if(pri[x]<pri[y]){
        rson[x]=merge(rson[x],y);
        pushup(x);
        return x;
    }
    else{
        lson[y]=merge(x,lson[y]);
        pushup(y);
        return y;
    }
}
int mx[4000001];
int check(int col,int l,int r){
    int t1,t2,t3,t4,ans;
    split(root[col],l-1,t1,t2);
    split(t2,r,t3,t4);
    ans=size[t3];
    root[col]=merge(merge(t1,t3),t4);
    return ans;
}
int query(int root,int l,int r,int el,int er){
    if(el<=l&&er>=r)return mx[root];
    int mid=(l+r)>>1;
    if(mid>=er)return query(root<<1,l,mid,el,er);
    else if(mid<el)return query(root<<1|1,mid+1,r,el,er);
    int col1=query(root<<1,l,mid,el,er),col2=query(root<<1|1,mid+1,r,el,er);
    int L=std::max(l,el),R=std::min(r,er);
    if(check(col1,L,R)>(R-L+1)/2)return col1;
    else if(check(col2,L,R)>(R-L+1)/2)return col2;
    return -1;
}
void modify(int root,int l,int r,int e){
    if(l==r){
        mx[root]=num[l];
        return;
    }
    int mid=(l+r)>>1;
    if(mid>=e)modify(root<<1,l,mid,e);
    else modify(root<<1|1,mid+1,r,e);
    int col1=mx[root<<1],col2=mx[root<<1|1];
    if(check(col1,l,r)>(r-l+1)/2)mx[root]=col1;
    else if(check(col2,l,r)>(r-l+1)/2)mx[root]=col2;
    else mx[root]=-1;
}
void build(int root,int l,int r){
    if(l==r){
        mx[root]=num[l];
        return;
    }
    int mid=(l+r)>>1;
    build(root<<1,l,mid);
    build(root<<1|1,mid+1,r);
    int col1=mx[root<<1],col2=mx[root<<1|1];
    if(check(col1,l,r)>(r-l+1)/2)mx[root]=col1;
    else if(check(col2,l,r)>(r-l+1)/2)mx[root]=col2;
    else mx[root]=-1;
}
int read()
{
    register char c;register int x=0;register bool flag=0;
    while(c<'0'||c>'9') (c=='-')&&(flag=1),c=getchar();
    while(c>='0'&&c<='9') x=(x<<3)+(x<<1)+c-'0',c=getchar();
    (flag)&&(x=-x);
    return x;
}
int main(){
    n=read(),m=read();
    srand(432567356);
    for(int i=1,tem;i<=n;i++){
        tem=read();
        pri[i]=rand()%1278943;
        if(!root[tem])root[tem]=i;
        else root[tem]=merge(root[tem],i);
        num[i]=tem;
    }
    build(1,1,n);
    for(int i=1;i<=m;i++){
        l=read(),r=read(),s=read(),k=read();
        int ans=query(1,1,n,l,r);
        if(ans==-1)ans=s;
        for(int j=1,tem;j<=k;j++){
            tem=read();
            if(num[tem]!=ans){
                int t1,t2,t3,t4;
                split(root[num[tem]],tem,t1,t2);
                split(t1,tem-1,t3,t4);
                root[num[tem]]=merge(t3,t2);
                split(root[ans],tem,t1,t2);
                root[ans]=merge(merge(t1,tem),t2);
                num[tem]=ans;
                modify(1,1,n,tem);
            }
        }
        printf("%d\n",ans);
    }
    printf("%d\n",mx[1]);
}
```

---

## 作者：试试事实上吗 (赞：5)

很有意思的一道题。

### Part.1

一开始拿到这道题一看，题目要求的是区间众数的出现次数，这个显然没法做，据我所知只有静态分块或者回滚莫队可以做不带修版本的，但是他要我们求的比这个要弱许多，我们可以发现一个性质，显然如果一个数出现次数超过一半，我们让它与剩下的数两两抵消，剩下的数必然只有它自己。更进一步，如果区间中一旦有一个满足条件的数，我们任意选不同的两个数抵消，剩下的必然是那个数。

我们用数据结构实现这个过程。

考虑一棵线段树，她维护区间中两两抵消还剩哪个数以及还剩多少。她的左右儿子信息合并时，我们看两个儿子剩下的数是否一样，如果一样就相加，如果不一样就取最大，然后互相抵消。

### Part.2

然后，你以为做完了？

如果真做完了那么它最多是绿题。

我们刚才假设了区间绝对满足条件，那么如果区间不满足条件呢？~~暴力找~~

一个显然的做法是对每一个总统建一个$vector$，每次找出答案后再$vector$中二分询问区间的左右端点，然后看中间数的个数是否大于$len/2$就可以了。

然而题目中有修改。~~暴力修改~~

于是实际上，我们要支持一个数据结构，插入一个数，删除一个数，查询某个数的排名（相当与二分）

这是什么？平衡树板子。

然后，然后就真的完了。

总结一下，我们每次在线段树上找出一个数，然后再在平衡树上找出区间中该数的个数检查是否合法就可以了。

#### Part.3

安利一下$LeafyTree$，即$WBLT$，她的形态与线段树差不多，常数小跑的飞快，一般比$Splay$或$FHQTreap$快两到三倍。

最后一个细节，在找排名的时候，一路走到叶子后一定要看一下这个数是不是比叶子大，如果小要$return\;0$，因为这个数可能比平衡树中的所有数都小。

### Code

```cpp
struct Node
{
    int siz,val;
    Node *lc,*rc;
    Node(int siz,int val,Node *lc,Node *rc) : siz(siz),val(val),lc(lc),rc(rc) {}
    Node() {}
}*null,*stk[maxn*3],utk[maxn*3];
int utot,a[maxn],n;

struct Leafy_Tree
{
    Node *rt[maxn];
    #define newnode(a,b,c,d) (&(*stk[utot++]=Node(a,b,c,d)))
    #define merge(a,b) newnode(a->siz+b->siz,b->val,a,b)
    inline void init()
    {
        for(int i=1;i<=n;++i)
            rt[i]=newnode(1,0x3f3f3f3f,null,null);
    }
    inline void rotate(Node *u)
    {
        if(u->lc->siz > u->rc->siz*ratio)
            u->rc=merge(u->lc->rc,u->rc),stk[--utot]=u->lc,u->lc=u->lc->lc;
        else if(u->rc->siz > u->lc->siz*ratio)
            u->lc=merge(u->lc,u->rc->lc),stk[--utot]=u->rc,u->rc=u->rc->rc;
    }
    inline void pushup(Node *u)
    {
        if(!u->lc->siz) return;
        u->siz=u->lc->siz+u->rc->siz;
        u->val=u->rc->val;
    }
    inline void insert(Node *u,int val)
    {
        if(u->siz==1)
        {
            u->lc=newnode(1,min(u->val,val),null,null);
            u->rc=newnode(1,max(u->val,val),null,null);
        }
        else insert(val > u->lc->val?u->rc:u->lc,val);
        pushup(u);rotate(u);
    }
    inline void erase(Node *u,int val)
    {
        if(u->lc->siz==1&&u->lc->val==val)
            stk[--utot]=u->lc,stk[--utot]=u->rc,*u=*u->rc;
        else if(u->rc->siz==1&&u->rc->val==val)
            stk[--utot]=u->lc,stk[--utot]=u->rc,*u=*u->lc;
        else erase(val > u->lc->val?u->rc:u->lc,val);
        pushup(u);rotate(u);
    }
    inline int rnk(Node *u,int val)
    {
        if(u->siz==1) return val>=u->val;
        return val > u->lc->val ? rnk(u->rc,val)+u->lc->siz : rnk(u->lc,val);
    }
}leafy;

struct Segment_Tree
{
    int mx[maxn],cnt[maxn];
    inline void pushup(int u)
    {
        if(mx[u<<1]==mx[u<<1|1]) mx[u]=mx[u<<1],cnt[u]=cnt[u<<1]+cnt[u<<1|1];
        else if(cnt[u<<1]>cnt[u<<1|1]) mx[u]=mx[u<<1],cnt[u]=cnt[u<<1]-cnt[u<<1|1];
        else mx[u]=mx[u<<1|1],cnt[u]=cnt[u<<1|1]-cnt[u<<1];
    }
    inline void build(int u,int l,int r)
    {
        if(l==r) {mx[u]=a[l],cnt[u]=1;return;}
        int mid=(l+r)>>1;
        build(u<<1,l,mid);build(u<<1|1,mid+1,r);
        pushup(u);
    }
    inline void modify(int u,int l,int r,int x,int val)
    {
        if(l==r) {mx[u]=val;return;}
        int mid=(l+r)>>1;
        if(x<=mid) modify(u<<1,l,mid,x,val);
        else modify(u<<1|1,mid+1,r,x,val);
        pushup(u);
    }
    inline pii query(int u,int l,int r,int x,int y)
    {
        if(x<=l&&r<=y) return make_pair(mx[u],cnt[u]);
        int mid=(l+r)>>1;
        if(y<=mid) return query(u<<1,l,mid,x,y);
        else if(x>mid) return query(u<<1|1,mid+1,r,x,y);
        else
        {
            pii a=query(u<<1,l,mid,x,y),b=query(u<<1|1,mid+1,r,x,y),c;
            if(a.first==b.first) c.first=a.first,c.second=a.second+b.second;
            else if(a.second>b.second) c.first=a.first,c.second=a.second-b.second;
            else c.first=b.first,c.second=b.second-a.second;
            return c;
        }
    }
}seg;

inline void modify(int x,int val)
{
    leafy.erase(leafy.rt[a[x]],x);
    leafy.insert(leafy.rt[val],x);
    seg.modify(1,1,n,x,val);
    a[x]=val;
}

inline int query(int x,int y)
{
    int ans=seg.query(1,1,n,x,y).first;
    if(((y-x+1)>>1)<leafy.rnk(leafy.rt[ans],y)-leafy.rnk(leafy.rt[ans],x-1)) return ans;
    else return -1;
}

template<typename T>
inline void read(T &x)
{
    char c;int f=1;
    while(!isdigit(c=getchar())) (c=='-')&&(f=-1);
    x=c^48;
    while(isdigit(c=getchar())) x=x*10+(c^48);
    x*=f;
}

int main()
{
    int l,r,s,k,m,x;
    for(int i=0;i<maxn*3;++i)
        stk[i]=&utk[i];
    null=new Node(0,0,0,0);
    read(n);read(m);
    for(int i=1;i<=n;++i)
        read(a[i]);
    leafy.init();
    seg.build(1,1,n);
    for(int i=1;i<=n;++i)
        leafy.insert(leafy.rt[a[i]],i);
    while(m--)
    {
        read(l);read(r);read(s);read(k);
        x=query(l,r);
        if(x!=-1) s=x;
        printf("%d\n",s);
        while(k--)
            read(x),modify(x,s);
    }
    printf("%d\n",query(1,n));
    return 0;
}
```



---

## 作者：401rk8 (赞：5)

Orz 第一篇题解的随机化大法，思路类似

对于尝试次数本人倾向于 $\log n$

但本人手写 fhqTreap 被卡常了，实测本人的 pb_ds(O2) 快于 Treap 快于 fhqTreap，因为想~~偷懒~~锻炼卡常能力决定就用 fhqTreap，于是：

![](https://cdn.luogu.com.cn/upload/image_hosting/h5dpqh54.png)

突然发现有时候没开 O2。。。

分享一下用到的技巧（见注释）：

```cpp
// 省略一坨头文件
namespace IO { // fread+fwrite
#define gc() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<22,stdin),p1==p2)?EOF:*p1++)
char buf[1<<22],*p1=buf,*p2=buf;
int read(){
	int x=0;char c=gc();
	while(!isdigit(c))c=gc(); // 没有负数
	for(;isdigit(c);c=gc())x=x*10-48+c;
	return x;
}
char pbuf[1<<22],*pp=pbuf;
void pc(char c) {
	if(pp-pbuf==1<<22)fwrite(pbuf,1,1<<22,stdout),pp=pbuf;
	*pp++=c;
}
void write(int x) {
	if(!x)pc('0');
	else{
    	static int s[10];int l=0;
    	if(x<0)pc('-'),x=-x;
		for(;x;x/=10)s[l++]=x%10;
		while(l)pc(s[--l]|48);
    }
}
}
using IO::pc;
using IO::read;
using IO::write;

const int N = 5e5+5, K = N+1e6+5;
int n,m,a[N];

int ind;
bool vis[N];

mt19937 mt(time(0));

int rnd(int l,int r) { return l + mt() % (r-l+1); }

struct Node {
	int val,ls,rs,siz;
	unsigned rnd;
	#define ls(x) t[x].ls
	#define rs(x) t[x].rs
} t[K];
class Treap {
private:
	int rt;
	int newnode(int x) {
		t[++ind] = (Node){x,0,0,1,mt()};
		return ind;
	}
	void up(int u) { t[u].siz = t[ls(u)].siz + t[rs(u)].siz + 1; }
	void split(int u,int x,int &l,int &r) {
		if( !u ) { l = r = 0; return; };
		if( t[u].val <= x ) l = u, split(rs(u),x,rs(l),r), up(l);
		else r = u, split(ls(u),x,l,ls(r)), up(r);
	}
	int merge(int l,int r) {
		if( !l || !r ) return l | r;
		if( t[l].rnd < t[r].rnd ) { rs(l) = merge(rs(l),r), up(l); return l; }
		else { ls(r) = merge(l,ls(r)), up(r); return r; }
	}
public:
	void insert(int x) {
		int l,r;
		split(rt,x,l,r);
		rt = merge(merge(l,newnode(x)),r);
	}
	void erase(int x) {
		int l,mid,r;
		split(rt,x,l,r), split(l,x-1,l,mid);
		rt = merge(l,r); // 不会有相同的数，即ls(mid)=rs(mid)=0
	}
	int rank(int x) {
		int l,r;
		split(rt,x,l,r);
		int k = t[l].siz;
		rt = merge(l,r);
		return k;
	}
} tr[N];

int query(int l,int r) {
    int stk[14],tp=0, res = -1, mid = (r-l+1)/2; // 防止每次算mid
	For(i,1,13) { // 实测小于13就会WA
		int x = a[rnd(l,r)];
		if( vis[x] ) continue; // 最关键的优化：查过的就不查了
		vis[x] = 1, stk[++tp] = x;
		if( tr[x].rank(r)-tr[x].rank(l-1) > mid ) { res = x; break; }
	}
	while( tp ) vis[stk[tp--]] = 0;
	return res;
}

int main() {
// 	freopen("P3765_8.in","r",stdin); 一直死在这个点
// 	freopen("a.out","w",stdout);
	n=read(),m=read();
	For(i,1,n) tr[ a[i]=read() ].insert(i);
	while( m-- ) {
		int l=read(),r=read(),s=read(),k=read();
		int win = query(l,r);
		if( win == -1 ) win = s;
		while( k-- ) {
			int x=read();
			tr[a[x]].erase(x), tr[ a[x]=win ].insert(x);
		}
		write(win),pc(10);
	}
	write(query(1,n));
	fwrite(IO::pbuf,1,IO::pp-IO::pbuf,stdout);
	return 0;
}
```

---

求赞 & 宣传一下 [blog](https://www.luogu.com.cn/blog/Rings/#)

---

## 作者：s_h_y (赞：5)

一开始使用题解的思路。写了一遍T了。。（其实Windows下大随机数据Pascal跑得还比C++略快一点的说）

我知道用C++重写一遍就能A，我知道我写的Treap有2倍常数。。但是我们不妨以提交次数为代价水一下此题。。。

正解部分：

●我们对每一个候选人开平衡树，这样我们就能询问[L,R]的选民选择该候选人的数量。比如[1,R]-[1,L-1]这样。

●开线段树维护区间众数。复杂度O(nlognlogn)。

好吧，以上我直接模拟地写一遍只有30分，其余全T。

乱搞卡常部分：

①一个区间，如果存在一个数>区间的一半，则随机选数正确的概率为1/2。选择K次出错的概率就低到1/2^K了。这个测试次数K不一定要选2^K>=αM这种，实际上，选15左右就能对绝大多数数据了（毕竟很可能本来就没有大于一半的数，这样多询问就很浪费）。这样复杂度是O(nlognK)

②一个候选人，他可能出现的总次数本来就极少，已经少于询问区间的一半了，我们这时就不需要花费logn的代价去询问，直接返回false。

③出题人最擅长构造的数据莫过于【数U出现了x次，数V出现了(x+1)次】这种极端，这时数U可能都会被问到多次，用时间戳判掉对同一个选民的重复询问即可。

④啊你发现以上的做法还是过不了，可以得90分，特别是第7个点我不知道出题人是怎么构造的而Luogu又没法下载。那么，你也不要轻易放弃信仰去用c++。你可以对区间小的数，测试次数K设置的小一些；区间大的数，测试次数K设置的大一些。。。这个时候，你的分数会在70~90分徘徊，但是当你欧气好的时候，可以抵达100分。


代码比较丑不贴了。。


---

## 作者：xudaxia (赞：4)

这题需要一个黑科技——摩尔投票。这是一个什么东西？一个神奇的方法求一个序列中出现次数大于长度一半的数。    
简而言之就是`同加异减`；  
比如有一个代表投票结果的序列。  
$$[1,2,1,1,2,1,1]$$  
我们记录一个$num$和$cnt$先别管它们是干什么的。我们模拟一遍模拟排序。    
首先读第一个数1，num==0,我们把cnt+1=1,num=1    
第二个数2，num==1$\neq$2,我们把cnt-1=0,num不变    
然后第三个数1，num==0，我们把cnt+1=1,num=1    
第四个数1，num==1=1,cnt+1=2,num不变    
第五个数2，num==1$\neq$2,我们把cnt-1=1,num不变    
第六个数1，num==1=1,cnt+1=2,num不变    
最后的num就是出现次数大于一半的数。当然必须要保证真的有一个数出现次数大于一半。要不最后的num是错的。  
摩尔投票有什么用呢，我们这道题有一个暴力的想法，对于每一个候选人建一颗平衡树，里面节点权值就是支持这个候选人的人的下标。  对于每一次询问，我们遍历每一个平衡树看看权值在$[l,r]$中的节点有多少个，求max看看大不大于区间长度一半，就可以求出候选人了，维护也挺好维护。    
但是每一次遍历平衡树太慢了，我们用摩尔投票先求出一个可能的答案，然后判断答案对应的那个平衡树就行了。然后摩尔投票有区间可加性可以用线段树维护。至此此题得到完美解决。  
```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<cstdlib>
#include<ctime>
using namespace std;
const int N=501000;
int num[N*5],cnt[N*5];
int tot,rad[N],v[N],size[N],ch[N][2],root[N],x,y,z;
int n,m,a[N];
struct node{
	int cnt,num;
};
void update(int now){
	if(num[now*2]==num[now*2+1])num[now]=num[now*2],cnt[now]=cnt[now*2]+cnt[now*2+1];
	else if(cnt[now*2]>cnt[now*2+1])num[now]=num[now*2],cnt[now]=cnt[now*2]-cnt[now*2+1];
	else num[now]=num[now*2+1],cnt[now]=cnt[now*2+1]-cnt[now*2];
}
void build(int l,int r,int now){
	if(l==r){
		num[now]=a[l];
		cnt[now]=1;
		return;
	}
	int mid=(l+r)>>1;
	build(l,mid,now*2);
	build(mid+1,r,now*2+1);
	update(now);
}
node check(int l,int r,int L,int R,int now){
	if(l==L&&r==R){
		node g;
		g.num=num[now];
		g.cnt=cnt[now];
		return g;
	}
	int mid=(l+r)>>1;
	if(L>mid)return check(mid+1,r,L,R,now*2+1);
	else if(R<=mid)return check(l,mid,L,R,now*2);
	else{
		node a=check(l,mid,L,mid,now*2);
		node b=check(mid+1,r,mid+1,R,now*2+1);
		node g;
		if(a.num==b.num)g.num=a.num,g.cnt=a.cnt+b.cnt;
		else if(a.cnt>b.cnt)g.num=a.num,g.cnt=a.cnt-b.cnt;
		else g.num=b.num,g.cnt=b.cnt-a.cnt;
		return g;
	}
}
void change(int l,int r,int x,int w,int now){
	if(l==r){
		num[now]=w;
		return;
	}
	int mid=(l+r)>>1;
	if(x>mid)change(mid+1,r,x,w,now*2+1);
	else change(l,mid,x,w,now*2);
	update(now);
}
int new_node(int x){
	int now=++tot;
	rad[now]=rand(),v[now]=x,size[now]=1;
	return now;
}
void pushup(int x){
	size[x]=size[ch[x][0]]+size[ch[x][1]]+1;
}
int merge(int x,int y){
	if(!x||!y)return x+y;
	if(rad[x]>rad[y]){
		ch[x][1]=merge(ch[x][1],y);
		pushup(x);
		return x;
	}
	else{
		ch[y][0]=merge(x,ch[y][0]);
		pushup(y);
		return y;
	}
}
void split(int &x,int &y,int now,int w){
	if(now==0)x=y=0;
	else{
		if(v[now]<=w){
			x=now;
			split(ch[x][1],y,ch[x][1],w);
		}
		else{
			y=now;
			split(x,ch[y][0],ch[y][0],w);
		}
		pushup(now);
	}
}
bool judge(int now,int l,int r){
	split(x,z,root[now],r);
	split(x,y,x,l-1);
	int tmp=size[y];
	root[now]=merge(merge(x,y),z);
	if(tmp>(r-l+1)/2)return true;
	else return false;
}
int read(){
	int sum=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){sum=sum*10+ch-'0';ch=getchar();}
	return sum*f;
}
int main(){
	srand(time(NULL));
	n=read();m=read();
	for(int i=1;i<=n;i++){
		a[i]=read();
		root[a[i]]=merge(root[a[i]],new_node(i));
	}
	build(1,n,1);
	while(m--){
		int l=read(),r=read(),s=read(),k=read();
		int f=check(1,n,l,r,1).num;
		if(judge(f,l,r))s=f;
		printf("%d\n",s);
		for(int i=1;i<=k;i++){
			f=read();
			change(1,n,f,s,1);
			split(x,z,root[a[f]],f);
			split(x,y,x,f-1);
			root[a[f]]=merge(x,z);
			split(x,z,root[s],f);
			root[s]=merge(merge(x,y),z);
			a[f]=s;
		}
	}
	int f=check(1,n,1,n,1).num;
	if(judge(f,1,n))printf("%d",f);
	else printf("-1");
	return 0;
}
```

---

## 作者：happybob (赞：2)

看到了第一篇题解，我懂了随机化的艺术。

确实，这种区间众数用随机化的错误概率很小，并且也快，那我就是用这种方法的。

显然我们知道区间众数是区间中某个数出现次数 $ > $ 区间的一半，那么我们考虑每一次随机抽不中的可能是 $\frac{1}{2}$，选 $k$ 次抽不中的概率是 $\frac{1}{2^k}$，将 $k$ 设为 $20$，每次选出的数用平衡树统计次数。跟第一篇题解一样，我用的 `pbds` 的红黑树，`pbds` 的 `splay` 会被卡。

代码：

```cpp
/*
* author: happybob
* date: 2022/3/20
* 10.34s /  63.41MB /  1.22KB C++20
* https://www.luogu.com.cn/record/71948451
*/

#include <iostream>
#include <algorithm>
#include <cstdio>
#include <algorithm>
#include <cstdlib>
#include <ctime>
#include <bits/extc++.h>
using namespace std;
using namespace __gnu_pbds;

constexpr int N(5e5 + 5), t(20);
tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> tr[N];
int n, m, a[N];

inline int getmax(int l, int r)
{
	for (register int i(1); i <= t; i++)
	{
		int place(l + rand() % (r - l + 1));
		if (tr[a[place]].order_of_key(r + 1) - tr[a[place]].order_of_key(l) > (r - l + 1) >> 1)
		{
			return a[place];
		}
	}
	return -1;
}

int main()
{
	srand(time(NULL));
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= n; i++)
	{
		scanf("%d", &a[i]);
		tr[a[i]].insert(i);
	}
	while (m--)
	{
		int l, r, s;
		scanf("%d%d%d", &l, &r, &s);
		int g(getmax(l, r));
		if (g == -1)
		{
			printf("%d\n", s);
			g = s;
		}
		else
		{
			printf("%d\n", g);
		}
		int k;
		scanf("%d", &k);
		for (int i(1); i <= k; ++i)
		{
			int x;
			scanf("%d", &x);
			tr[a[x]].erase(x);
			a[x] = g;
			tr[a[x]].insert(x);
		}
	}
	int l(1), r(n), s;
	int g(getmax(l, r));
	if (g == -1)
	{
		printf("%d\n", -1);
	}
	else
	{
		printf("%d\n", g);
	}
	return 0;
}
```


---

## 作者：bjxdw (赞：2)

做这道题前，请先做https://www.luogu.org/problemnew/show/P2397
(code)
```cpp
    scanf("%d",&n);int x;
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&x);
        if(!s) num=x,s=1;
        else 
        {
            if(num==x) s++;
            else s--;
        }
    }
    printf("%d",num);
```

考虑线段树，因为由摩尔投票法可得：最终答案会是线段树分割得区间的一坨答案中的其中一个（也可能会没有）
考虑如何合并区间：~~(如果你理解了摩尔投票法，就可以“显然”了)~~
```cpp
inline void Update(int x)//num是一个区间的答案，cnt是p2397中的s
{
    if(num[lc]==num[rc]) num[x]=num[lc],cnt[x]=cnt[lc]+cnt[rc];
    else if(cnt[lc]>cnt[rc]) num[x]=num[lc],cnt[x]=cnt[lc]-cnt[rc];
    else num[x]=num[rc],cnt[x]=cnt[rc]-cnt[lc];
}
```

然而会发现得出的总ans的个数并不一定>1/2 * size
于是我们需要加一个判断，对每一个权值建一棵平衡树，然后就是P3369了（其实可以不手打Treap或Splay，用二分加vector就可以搞定，但有一些细节问题->见code注释）
```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#include<cmath>
#include<cstdlib>
#include<vector>
using namespace std;
#define ll long long
#define lc (x<<1)
#define rc (x<<1|1)
const int INF = 0x7fffffff;
const int N   = 500009;
int Read() {int ret=0,nag=1;char c=getchar();  while (c>'9'||c<'0') {if(c=='-') nag=-1;  c=getchar();}  while (c<='9'&&c>='0')    ret=(ret<<3)+(ret<<1)+c-'0',c=getchar();  return ret*nag;}
void Print(int x) {if(x<0) putchar('-'),x=-x;  if(x>9) Print(x/10);  putchar(x%10+'0');}
int st[N],n,m,Q;
int cnt[N<<3],num[N<<3];
inline void Update(int x)
{
    if(num[lc]==num[rc]) num[x]=num[lc],cnt[x]=cnt[lc]+cnt[rc];
    else if(cnt[lc]>cnt[rc]) num[x]=num[lc],cnt[x]=cnt[lc]-cnt[rc];
    else num[x]=num[rc],cnt[x]=cnt[rc]-cnt[lc];
}
void Build(int x,int l,int r)
{
    if(l==r) {cnt[x]=1,num[x]=st[l];return;}
    int mid=(l+r)>>1;
    Build(lc,l,mid),Build(rc,mid+1,r);
    Update(x);
}
void Modify(int x,int l,int r,int w)
{
    if(l==r) {cnt[x]=1,num[x]=st[l];return;}
    int mid=(l+r)>>1;
    if(w<=mid) Modify(lc,l,mid,w);
    else Modify(rc,mid+1,r,w);
    Update(x);
}
pair<int,int> Query(int x,int l,int r,int L,int R)
{
    if(l==L&&r==R){return pair<int,int>(num[x],cnt[x]);}
    int mid=(l+r)>>1;
    if(R<=mid) return Query(lc,l,mid,L,R);
    else if(mid<L) return Query(rc,mid+1,r,L,R);
    pair<int,int> A=Query(lc,l,mid,L,mid),B=Query(rc,mid+1,r,mid+1,R);
    int numa=A.first,cnta=A.second,numb=B.first,cntb=B.second;
    if(numa==numb) return pair<int,int>(numa,cnta+cntb);
    else if(cnta>cntb) return pair<int,int>(numa,cnta-cntb);
    else return pair<int,int>(numb,cntb-cnta);
}
struct node//vector版Treap
{
    vector<int> a;
    void Insert(int x){a.insert(lower_bound(a.begin(),a.end(),x),x);}
    void Del(int x){a.erase(lower_bound(a.begin(),a.end(),x));}
    int Rank(int x){return lower_bound(a.begin(),a.end(),x)-a.begin()+1;}
    int Kth(int k){return a[k-1];}
    int Pre(int x){return a[lower_bound(a.begin(),a.end(),x)-a.begin()-1];}
    int Nxt(int x){return a[upper_bound(a.begin(),a.end(),x)-a.begin()];}
}T[N];
int main ()
{
    #ifndef ONLINE_JUDGE
    freopen("INPUT.in","r",stdin);
    freopen("OUTPUT.out","w",stdout);
    #endif
    n=Read(),Q=Read();for(int i=1;i<=n;i++)   st[i]=Read(),T[st[i]].Insert(i);
    Build(1,1,n);for(int i=1;i<=n;i++) T[i].Insert(0),T[i].Insert(n+1);//一定要有！！！因为lower_bound会出现边界问题
    while(Q--)
    {
        int l=Read(),r=Read(),s=Read(),k=Read();
        int res=Query(1,1,n,l,r).first;
        int sum=T[res].Rank(T[res].Pre(T[res].Nxt(r))) - T[res].Rank(T[res].Pre(l));
        if(sum<=(r-l+1)/2) res=s;
        Print(res),puts("");
        for(int i=1;i<=k;i++)
        {
            int x=Read();
            T[st[x]].Del(x);
            st[x]=res;Modify(1,1,n,x);
            T[st[x]].Insert(x);
        }
    }
    int res=Query(1,1,n,1,n).first;
    int sum=T[res].Rank(T[res].Pre(T[res].Nxt(n))) - T[res].Rank(T[res].Pre(1));
    if(sum<=n/2) res=-1;
    Print(res);
    return 0;
}

```

---

## 作者：ditoly (赞：2)

若只有一次询问， 我们可以这样找到可能的答案： 记当前可能的答案为 x， 权值 v 开始为 0， 每次加入一个数， 如果与 x 不同， 若 v=0 则用这个数替换 x 并使 v=1， 否则使 v 减 1；如果与 x 相同则使 v 加 1。可以发现若存在答案则必然是最后的x。 这个信息满足区间加法， 我们可以用线段树维护， 每次询问找到可能合法的答案后， 只需要检验该答案在区间内出现的次数即可， 我们对每种权值开一棵平衡树维护出现的位置即可解决，复杂度$O(n log n)$ 。


---

## 作者：404Not_Found (赞：1)

NOI2022 前来考古。

前置知识：线段树，平衡树，**摩尔投票**。

摩尔投票显然是是满足区间可加性的，可以线段树维护，具体的，用线段树维护众数以及它们在经过对拼抵消的次数。合并方法可以直接看代码：

```cpp
node push_up(node a,node b)
{
	if(a.mx==b.mx) return {a.mx,a.cnt+b.cnt};
	if(a.cnt>b.cnt) return {a.mx,a.cnt-b.cnt};
   return {b.mx,b.cnt-a.cnt};
}
```

于是这道题就做完了一大半。但是还有一个问题，绝对众数可能不存在。此时可以用平衡树维护区间一个数出现的个数。~~因为平衡树我写挂了~~可以用 pbds 来实现。

时间复杂度：$\mathcal{O}(m \log n)$，细节有点小多。

```cpp
#include<bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/tree_policy.hpp>
using namespace __gnu_pbds;
using namespace std;
const int N = 5e5+5;
const int M = 1.5e6+5;
int a[N],n,m;
struct node{
	int mx,cnt;
} t[N<<2];
//线段树
struct seg_tree{
	node push_up(node a,node b)
	{
		if(a.mx==b.mx) return {a.mx,a.cnt+b.cnt};
		if(a.cnt>b.cnt) return {a.mx,a.cnt-b.cnt};
		return {b.mx,b.cnt-a.cnt};
	}
	void build(int p,int l,int r)
	{
		if(l==r){t[p].mx=a[l];t[p].cnt=1;return;}
		int mid=(l+r)>>1;
		build(p<<1,l,mid); build(p<<1|1,mid+1,r);
		t[p]=push_up(t[p<<1],t[p<<1|1]);
	}
	void modify(int p,int l,int r,int x,int v)
	{
		if(l==r){t[p].mx=v;return;}
		int mid=(l+r)>>1;
		if(x<=mid) modify(p<<1,l,mid,x,v);
		else modify(p<<1|1,mid+1,r,x,v);
		t[p]=push_up(t[p<<1],t[p<<1|1]); 
	}
	node query(int p,int l,int r,int L,int R)
	{
		if(L<=l&&r<=R) return t[p];
		int mid=(l+r)>>1; node ls={0,0},rs={0,0};
		if(L>mid) return query(p<<1|1,mid+1,r,L,R);
		if(R<=mid) return query(p<<1,l,mid,L,R);
		ls=query(p<<1,l,mid,L,R); rs=query(p<<1|1,mid+1,r,L,R);
		return push_up(ls,rs);
	}
} seg;
//int val[M],siz[M],rnd[M],ch[M][2],cnt;
mt19937 mt(time(0));
//挂掉的 Treap
//struct Treap{
//	int root;
//	void maintain(int x){siz[x]=siz[ch[x][0]]+siz[ch[x][1]]+1;}
//	int newnode(int x){cnt++;val[cnt]=x;siz[x]=1;rnd[x]=mt();return cnt;}
//	void split(int p,int k,int& x,int& y)
//	{
//		if(!p) return x=y=0,void();
//		if(val[p]<k) split(ch[p][1],k,ch[p][1],y),x=p;
//		else split(ch[p][0],k,x,ch[p][0]),y=p;
//		maintain(p);
//	}
//	int merge(int x,int y)
//	{
//		if(!x||!y) return x+y;
//		if(rnd[x]>=rnd[y]) return ch[y][0]=merge(x,ch[y][0]),maintain(y),y;
//		return ch[x][1]=merge(ch[x][1],y),maintain(x),x;
//	}
//	void insert(int v)
//	{
//		int x,y; split(root,v,x,y);
//		root=merge(merge(x,newnode(v)),y);
//	}
//	void erase(int v)
//	{
//		int x,y,z;
//		split(root,v,x,y); split(x,v-1,x,z);
//		root=merge(x,y);
//	}
//	int getrnk(int v)
//	{
//		int x,y; split(root,v,x,y);
//		int ret=siz[x]; root=merge(x,y);
//		return ret;
//	}
//} tr[N];
tree<int,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update> s[N];
void modify(int x,int v)
{
	seg.modify(1,1,n,x,v);
//	tr[a[x]].erase(x);
//	tr[a[x]=v].insert(x);
	s[a[x]].erase(x);
	s[a[x]=v].insert(x);
}
int query(int l,int r)
{
	int ret=seg.query(1,1,n,l,r).mx;
	//if(tr[ret].getrnk(r)-tr[ret].getrnk(l-1)>((r-l+1)>>1)) return ret;
	if(s[ret].order_of_key(r+1)-s[ret].order_of_key(l)>((r-l+1)>>1)) return ret;
	return -1;
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++) scanf("%d",&a[i]);
	seg.build(1,1,n);
	for(int i=1;i<=n;i++) s[a[i]].insert(i);//tr[a[i]].insert(i);
	while(m--)
	{
		int l,r,s,k,x;
		scanf("%d%d%d%d",&l,&r,&s,&k);
		x=query(l,r);
		if(x!=-1) s=x;
		printf("%d\n",s);
		while(k--) scanf("%d",&x),modify(x,s);
	}
	printf("%d\n",query(1,n));
	return 0;
}
```

---

## 作者：斯德哥尔摩 (赞：1)

[P3765 总统选举](https://www.luogu.org/problemnew/show/P3765)

楼下几位好强啊，两位巨佬都没有给出代码，还有一位巨佬用了$STL$的平衡树，看得我好无奈啊。。。

首先得会这题：[P2397 yyy loves Maths VI (mode)](https://www.luogu.org/problemnew/show/P2397)

直接用对抗法/消去法找到众数即可。

那么，带上修改和多次询问呢？

也就是这题？

我是看这位巨佬的博客弄懂的：[链接](https://blog.csdn.net/Ab_Ever/article/details/72675837)

我们发现上述那个对抗法是可以进行区间合并的。

也就是能从$[l,mid],[mid+1,r]$合并成$[l,r]$。

记录当前的区间众数，区间众数在对抗后出现了多少次。

合并的时候，分两种情况：

1. 当两个区间的区间众数相等时，直接把次数相加。

2. 当两个区间的区间众数不相时，将出现次数多的作为合并后区间的区间众数，出现次数就是$\text{出现次数多的次数-出现次数少的次数}$。

这个合并让我们想起了什么？

或者说我们应该如何维护？

### 线段树！

修改直接单点修改，查询的时候因为维护了两个值：区间众数以及出现次数，直接返回一个结构体就好。

这题就做完了

吗？

并不。

因为“众数”不一定存在！

就是说未必有满足题目的答案，我们维护出的未必是正确答案，只是维护的那个数是“最具有成为‘众数’的潜质”的数罢了。

所以我们需要一个平衡树来检验我们求出的“区间众数”是否是真正的区间众数。

检验很简单，每个人开个$Treap$，判断在$[l,r]$内有几个人选他就行了。

差分一下，就可以在$Treap$上进行普通的二叉查找了。

复杂度是$O(\sum k_i\log_2n)$，可以通过。

附上长长的封装的代码：
```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#define MAXN 500010
using namespace std;
int n,m;
int val[MAXN];
inline int read(){
	int date=0,w=1;char c=0;
	while(c<'0'||c>'9'){if(c=='-')w=-1;c=getchar();}
	while(c>='0'&&c<='9'){date=date*10+c-'0';c=getchar();}
	return date*w;
}
namespace T{//这是个指针+结构体的裸的Treap，不习惯可以自己写，因为这是纯板子。。。
	struct node{
		node* son[2];
		int v,w,s,flag;
		node(){
			son[0]=son[1]=NULL;
			w=rand();
			v=0;
			s=flag=1;
		}
	};
	node* root[MAXN];
	inline void maintain(node* &u){
		u->s=u->flag;
		if(u->son[0]!=NULL)u->s+=u->son[0]->s;
		if(u->son[1]!=NULL)u->s+=u->son[1]->s;
	}
	inline void turn(node* &u,int f){
		node* t=u->son[f^1];
		u->son[f^1]=t->son[f];
		t->son[f]=u;
		maintain(u);
		maintain(t);
		u=t;
	}
	void insert(node* &u,int x){
		if(u==NULL){
			u=new node;
			u->v=x;
			return;
		}
		else if(u->v==x){
			u->flag++;
			maintain(u);
			return;
		}
		int y=u->v<x?1:0;
		insert(u->son[y],x);
		if(u->son[y]->w>u->w)turn(u,y^1);
		else maintain(u);
	}
	void remove(node* &u,int x){
		if(u==NULL)return;
		if(u->v==x){
			if(u->flag>1)u->flag--;
			else{
				if(u->son[0]==NULL&&u->son[1]==NULL)u=NULL;
				else if(u->son[0]!=NULL&&u->son[1]!=NULL){
					if(u->son[0]->w>u->son[1]->w){
						turn(u,1);
						remove(u->son[1],x);
					}
					else{
						turn(u,0);
						remove(u->son[0],x);
					}
				}
				else{
					if(u->son[0]==NULL)u=u->son[1];
					else u=u->son[0];
				}
			}
			if(u!=NULL)maintain(u);
		}
		else{
			if(u->v>x)remove(u->son[0],x);
			else if(u->v<x)remove(u->son[1],x);
			if(u!=NULL)maintain(u);
		}
	}
	int query(node* u,int k){//这个函数是纯的二叉查找
		if(u==NULL)return 0;
		int lsons=0;
		if(u->son[0]!=NULL)lsons=u->son[0]->s;
		if(k<u->v)return query(u->son[0],k);
		else if(k>=u->v)return lsons+u->flag+query(u->son[1],k);
	}
}
namespace ST{//线段树，也是纯板子，不习惯也可以自己写。
	#define LSON rt<<1
	#define RSON rt<<1|1
	#define DATA(x) a[x].data
	#define NUM(x) a[x].num
	#define LSIDE(x) a[x].l
	#define RSIDE(x) a[x].r
	struct Segment_Tree{
		int data,num,l,r;
	}a[MAXN<<2];
	inline void pushup(int rt){
		if(DATA(LSON)==DATA(RSON)){
			DATA(rt)=DATA(LSON);
			NUM(rt)=NUM(LSON)+NUM(RSON);
		}
		else if(NUM(LSON)>NUM(RSON)){
			DATA(rt)=DATA(LSON);
			NUM(rt)=NUM(LSON)-NUM(RSON);
		}
		else{
			DATA(rt)=DATA(RSON);
			NUM(rt)=NUM(RSON)-NUM(LSON);
		}
	}
	void buildtree(int l,int r,int rt){
		LSIDE(rt)=l;RSIDE(rt)=r;DATA(rt)=NUM(rt)=0;
		if(l==r){
			DATA(rt)=val[l];
			NUM(rt)=1;
			return;
		}
		int mid=l+r>>1;
		buildtree(l,mid,LSON);
		buildtree(mid+1,r,RSON);
		pushup(rt);
	}
	void update(int k,int c,int rt){
		if(LSIDE(rt)==RSIDE(rt)){
			DATA(rt)=c;
			NUM(rt)=1;
			return;	
		}
		int mid=LSIDE(rt)+RSIDE(rt)>>1;
		if(k<=mid)update(k,c,LSON);
		else update(k,c,RSON);
		pushup(rt);
	}
	Segment_Tree query(int l,int r,int rt){
		if(l<=LSIDE(rt)&&RSIDE(rt)<=r)return a[rt];
		int mid=LSIDE(rt)+RSIDE(rt)>>1;
		Segment_Tree ans,lson=(Segment_Tree){0,0,0,0},rson=(Segment_Tree){0,0,0,0};
		if(l<=mid)lson=query(l,r,LSON);
		if(mid<r)rson=query(l,r,RSON);
		if(lson.data==rson.data){
			ans.data=lson.data;
			ans.num=lson.num+rson.num;
		}
		else if(lson.num>rson.num){
			ans.data=lson.data;
			ans.num=lson.num-rson.num;
		}
		else{
			ans.data=rson.data;
			ans.num=rson.num-lson.num;
		}
		return ans;
	}
}
void work(){
	int l,r,s,k,x,ans;
	while(m--){
		l=read();r=read();s=read();k=read();
        
		ans=ST::query(l,r,1).data;
		if((T::query(T::root[ans],r)-T::query(T::root[ans],l-1))<=(r-l+1)/2)ans=s;
        //检验答案
		printf("%d\n",ans);//求出答案
        
		while(k--){//修改
			x=read();
			ST::update(x,ans,1);
			T::remove(T::root[val[x]],x);
			val[x]=ans;
			T::insert(T::root[val[x]],x);
		}
	}
    
	ans=ST::query(1,n,1).data;
	if((T::query(T::root[ans],r)-T::query(T::root[ans],l-1))<=n/2)ans=-1;
    //检验答案
	printf("%d\n",ans);//最后还有一遍。。。
}
void init(){//读入+预处理
	srand(2002);//随机种子随便
	n=read();m=read();
	for(int i=1;i<=n;i++){
		val[i]=read();
		T::root[i]=NULL;
	}
	ST::buildtree(1,n,1);
	for(int i=1;i<=n;i++)T::insert(T::root[val[i]],i);
}
int main(){//主函数So easy!
	init();
	work();
    return 0;
}

```

---

## 作者：wrpwrp (赞：0)

emmm...5k的代码我应该直接发还是应该剪贴板.....  
这个题目看到要维护一个人在某一个区间的票数，如果做过[P3987 我永远喜欢珂朵莉~](https://www.luogu.com.cn/problem/P3987)  的话其实很容易想到对于每一个人开一棵平衡树然后单点查询排名，再相减就搞定了，这里要注意是rk(r)-rk(l-1)，要是写rk(l)感觉就不好协调了~~你觉得我会告诉你我因为这个想了半个小时？~~    
然而我们这题期望的是找到每个区间的众数，那么如果随机抽10几个数，然后去验证，那么由于众数的出现次数会大于整个区间的一半，所以这基本上就是对的了，然而由于我写了个坑爹的splay，死活90分，多几次就T少几次就Wa，所以还是选择用线段树来找众数，思路就是根第一篇题解一样了，用摩尔投票法的思想维护cnt和当前的“众数”，那么如果两个儿子的众数相同 这个节点的众数就等于儿子的众数 cnt就等于两个儿子的cnt相加，如果不同，这个节点的众数就等于cnt较大的那个儿子的众数 cnt就等于大的减去小的，于是就可以愉快地维护了  
~~代码及其感人~~

```cpp
#include <cstdio>
#include <utility>

using std::pair;

#define R register
const int MAXN=5e5+10;

inline int read();
inline void write(int x);
inline void print(int x);

int n,m;
int a[MAXN];

struct Node
{
	int ch[2],siz,val,fa,cnt;
}t[MAXN*4];
int tot=0;

class Splay
{
	private:
		int rt;
		inline int New(int x);
		inline int get(int x);
		inline void splay(int x);
		inline void clear(int x);
		inline void update(int x);
		inline void rotate(int x);
		inline int  get(int x,int y);
		inline void connect(int x,int y,int chk);
	public:
		inline int Pre();		
		inline int Nxt();		
		inline int rk(int k);			
		inline void del(int k);
		inline void insert(int k);
		inline int find(int k);
};

class Seg_Tree
{
	private:
		int mx[MAXN<<2],cn[MAXN<<2];
		inline int Ls(int x);
		inline int Rs(int x);
		inline void update(int x);
	public:
		inline void build(int x,int l,int r);
		inline void chg(int x,int l,int r,int ad,int k);
		inline pair<int,int> find(int x,int l,int r,int LL,int RR);
};

Splay Tree[MAXN];
Seg_Tree ST;

int main()
{
	n=read();m=read();
	for(R int i=1;i<=n;i++)
	{
		a[i]=read();
		Tree[a[i]].insert(i);
	}
	ST.build(1,1,n);
	int l,r,s,k;
	for(R int i=1;i<=m;i++)
	{
		l=read();r=read();s=read();k=read();
		pair<int,int > pa=ST.find(1,1,n,l,r);
		int who=pa.second;
		int k1,k2;
		k1=Tree[who].find(l-1);
		k2=Tree[who].find(r);
		int cnt=k2-k1;
		if(cnt>(r-l+1)/2) s=who;
		for(R int j=1;j<=k;j++)
		{
			int who=read();
			Tree[a[who]].del(who);
			a[who]=s;
			ST.chg(1,1,n,who,s);
			Tree[a[who]].insert(who);
		}
		print(s);
	}
	l=1,r=n,s=-1;
	pair<int,int > pa=ST.find(1,1,n,l,r);
	int who=pa.second;
	int k1,k2;
	k1=Tree[who].find(l-1);
	k2=Tree[who].find(r);
	int cnt=k2-k1;
	if(cnt>(r-l+1)/2) s=who;
	print(s);
	return 0;
}

inline int read()
{
	char a=getchar();
	int x=0,f=1;
	for(;a>'9'||a<'0';a=getchar()) if(a=='-') f=-1;
	for(;a>='0'&&a<='9';a=getchar())
		x=x*10+a-'0';
	return x*f;
}

inline void write(int x)
{	
	if(x>=10)
		write(x/10);
	putchar(x%10+'0');
}

inline void print(int x)
{
	if(x<0) putchar('-'),x=-x;
	write(x);
	putchar('\n');
}

#define ls(x) t[x].ch[0]
#define rs(x) t[x].ch[1]
#define fa(x) t[x].fa
#define cnt(x) t[x].cnt
#define siz(x) t[x].siz
#define val(x) t[x].val

inline int Splay::New(int x)
{
	tot++;
	val(tot)=x;
	cnt(tot)=siz(tot)=1;
	fa(tot)=ls(tot)=rs(tot)=0;
	return tot;
}

inline int Splay::get(int x)
{
	return x==rs(fa(x));
}

inline int Splay::get(int x,int y)
{
	return x==rs(y);
}

inline void Splay::update(int x)
{
	siz(x)=siz(ls(x))+siz(rs(x))+cnt(x);
}

inline void Splay::connect(int x,int y,int chk)
{
	t[y].ch[chk]=x;
	fa(x)=y;
}

inline void Splay::rotate(int x)
{
	int y=fa(x);int z=fa(y);
	int chk=get(x);
	connect(t[x].ch[chk^1],y,chk);
	connect(y,x,chk^1);
	if(z) connect(x,z,get(y,z));
	else fa(x)=0;
	update(y);
}

inline void Splay::splay(int x)
{
	for(R int f=fa(x);f;rotate(x),f=fa(x))
	if(fa(f)) rotate(get(x)==get(f)?f:x);
	rt=x;
}

inline void Splay::clear(int x)
{
	fa(x)=siz(x)=cnt(x)=ls(x)=rs(x)=val(x)=0;
}

inline void Splay::insert(int k)
{
	if(!rt)
	{
		rt=New(k);
		update(rt);
		return;
	}
	int x=rt,f=0;
	while(1)
	{
		if(val(x)==k)
		{
			cnt(x)++;
			splay(x);
			return ;
		}
		f=x;x=t[x].ch[k>val(x)];
		if(!x)
		{
			x=New(k);
			connect(x,f,k>val(f));
			splay(x);
			return ;
		}
	}
}

inline int Splay::rk(int k)
{
	int res=0,x=rt;
	while(1)
	{
		if(k<val(x)) x=ls(x);
		else
		{
			res+=siz(ls(x));
			if(k==val(x)) {splay(x);return res+1;}
			res+=cnt(x);x=rs(x);
		}		
	}
}

inline int Splay::Pre()
{
	int x=ls(rt);
	while(rs(x)) x=rs(x);
	return x;
}

inline int Splay::Nxt()
{
	int x=rs(rt);
	while(ls(x)) x=ls(x);
	return x;
}

inline void Splay::del(int k)
{
	rk(k);
	if(cnt(rt)>1)
	{
		cnt(rt)--;
		update(rt);
		return;
	}
	if(!ls(rt)&&!rs(rt))
	{
		clear(rt);
		rt=0;
	return;
	}
	if(!ls(rt))
	{
		int x=rt;
		rt=rs(x);
		fa(rt)=0;
		clear(x);
		return;
	}
	if(!rs(rt))
	{
		int x=rt;
		rt=ls(x);
		fa(rt)=0;
		clear(x);
		return;
	}
	int x=rt,tmp=Pre();
	splay(tmp);
	connect(rs(x),tmp,1);
	clear(x);
	update(rt);
}

inline int Splay::find(int k)
{
	int x=rt,res=0,las;
	while(1)
	{
		las=x;
		if(val(x)<=k) res+=cnt(x)+siz(ls(x)),x=rs(x);
		else x=ls(x);
		if(x==0) {splay(las);return res;}
	}
}

inline int Seg_Tree::Ls(int x) {return x<<1;}
inline int Seg_Tree::Rs(int x) {return x<<1|1;}

inline void Seg_Tree::update(int x)
{
	if(mx[Ls(x)]==mx[Rs(x)])
	{
		mx[x]=mx[Ls(x)];
		cn[x]=cn[Ls(x)]+cn[Rs(x)];
	}
	else
	{
		if(cn[Ls(x)]>cn[Rs(x)])
		{
			mx[x]=mx[Ls(x)];
			cn[x]=cn[Ls(x)]-cn[Rs(x)];
		}
		else
		{
			mx[x]=mx[Rs(x)];
			cn[x]=cn[Rs(x)]-cn[Ls(x)];
		}
	}
}

inline void Seg_Tree::build(int x,int l,int r)
{
	if(l==r)
	{
		mx[x]=a[l];
		cn[x]=1;
		return;
	}
	int mid=l+r;mid>>=1;
	build(Ls(x),l,mid);
	build(Rs(x),mid+1,r);
	update(x);
}
inline void Seg_Tree::chg(int x,int l,int r,int ad,int k)
{
	if(l==r)
	{
		mx[x]=k;
		cn[x]=1;
		return ;
	}
	int mid=l+r;mid>>=1;
	if(ad<=mid) chg(Ls(x),l,mid,ad,k);
	else chg(Rs(x),mid+1,r,ad,k);
	update(x);
}	

inline pair<int,int> Seg_Tree::find(int x,int l,int r,int LL,int RR)
{
	if(l>=LL&&r<=RR) return std::make_pair(cn[x],mx[x]);
	int mid=l+r;mid>>=1;
	if(RR<=mid) return find(Ls(x),l,mid,LL,RR);
		else 
		if(LL>mid) return find(Rs(x),mid+1,r,LL,RR);
		else
		{
			pair<int,int> A=find(Ls(x),l,mid,LL,RR);
			pair<int,int> B=find(Rs(x),mid+1,r,LL,RR);
			pair<int,int> C;
			if(A.second==B.second)
			{
				C.second=A.second;
				C.first=A.first+B.first;
				return C;
			}
			else
			{
				if(A.first>B.first)
				{
					C.second=A.second;
					C.first=A.first-B.first;
					return C;
				}
				else
				{
					C.second=B.second;
					C.first=B.first-A.first;
					return C;
				}
			}
		}
}
```


---

## 作者：FlyInTheSky (赞：0)

 [$$ \Large \texttt{My Blog} $$](http://blog.flyinthesky.win/Luogu3765/)

------------

第一眼以为带修主席树，感觉肯定跑不过

前置知识：[Luogu 2397](https://www.luogu.org/problemnew/show/P2397)
> 求序列大于一半数的众数

本题可以采用摩尔投票法求，即将不同数两两消除，最后一定剩下的是这个众数。
**这个方法必须存在大于一半数的众数**

然后看这题，显然摩尔投票法是满足可加性的，那么线段树维护之。

但是如果不满足**存在大于一半数的众数**怎么办？

我们可以维护一个数在某个区间出现次数，这个方法是经典套路，静态则用 `vector` 排序后二分，而动态则需要名次树`Splay`维护。具体方法为在名次树上类似静态方法二分即可。

然后每次查询，更改即可。

```c++
#include<cstdio> 
#include<cstring>
#include<algorithm>
#include<iostream>
#include<cmath>
#include<set>
#include<vector>
#define ms(i, j) memset(i, j, sizeof i)
#define LL long long
#define db double
#define fir first
#define sec second
#define mp make_pair
using namespace std;

namespace flyinthesky {

	const int MAXN = 500000 + 5, INF = 2000000000;
	
	int n, m, vt[MAXN];
	struct node {
	    vector<int > a;
	    void insert(int x) {a.insert(lower_bound(a.begin(), a.end(), x), x);}
	    void del(int x) {a.erase(lower_bound(a.begin(), a.end(), x));}
	    int rank(int x) {return lower_bound(a.begin(), a.end(), x) - a.begin() + 1;}
	    int kth(int k) {return a[k - 1];}
	    int pre(int x) {return a[lower_bound(a.begin(), a.end(), x) - a.begin() - 1];}
	    int nxt(int x) {return a[upper_bound(a.begin(), a.end(), x) - a.begin()];}
	}s[MAXN];
	
	int chk(int l, int r, int i) { // 1
		if (i == 0) return 0;
		return upper_bound(s[i].a.begin(), s[i].a.end(), r) - upper_bound(s[i].a.begin(), s[i].a.end(), l - 1);
	}
	
	#define lc (o << 1)
	#define rc (o << 1 | 1)
	#define M ((l + r) >> 1)
	#define lson lc, l, M
	#define rson rc, M + 1, r 
	int cnt[MAXN * 4], num[MAXN * 4];
	void pushup(int o) { // 1
		if (num[lc] == num[rc]) num[o] = num[lc], cnt[o] = cnt[lc] + cnt[rc];
		else {
			if (cnt[lc] > cnt[rc]) cnt[o] = cnt[lc] - cnt[rc], num[o] = num[lc];
			else cnt[o] = cnt[rc] - cnt[lc], num[o] = num[rc];
		}
	}
	void build(int o, int l, int r) { // 1
		cnt[o] = num[o] = 0;
		if (l == r) return ; else {
			build(lson), build(rson);
			pushup(o);
		}
	}
	int query(int o, int l, int r, int x, int y, int &whw) {
		if (x <= l && r <= y) { // 1
			return whw = cnt[o], num[o];
		}
		int ret = 0, cc = 0;
		if (x <= M) {
			ret = query(lson, x, y, cc);
		}
		if (M < y) {
			int tmp1, tmp2;
			tmp1 = query(rson, x, y, tmp2);
			if (tmp1 == ret) cc += tmp2; else {
				if (tmp2 > cc) ret = tmp1, cc = tmp2 - cc; 
				else cc = cc - tmp2;
			}
		}
		return whw = cc, ret;
	}
	void update(int o, int l, int r, int p, int v) { // 1
		if (l == r) {
			cnt[o] = 1, num[o] = v;
			return ;
		}
		if (p <= M) update(lson, p, v);
		else update(rson, p, v);
		pushup(o);
	}

    void clean() {
    }
    int solve() {

    	clean();
    	
    	cin >> n >> m;
    	build(1, 1, n);
    	
    	for (int i = 1; i <= n; ++i) 
			scanf("%d", &vt[i]), 
			update(1, 1, n, i, vt[i]), s[vt[i]].insert(i), s[i].insert(INF), s[i].insert(-INF);
    	
    	while (m--) {
    		int l, r, si, k; scanf("%d%d%d%d", &l ,&r, &si, &k);
    		int gg, ret = query(1, 1, n, l, r, gg);
    		if (chk(l, r, ret) <= (r - l + 1) / 2) printf("%d\n", ret = si); else printf("%d\n", ret);
    		for (int x, i = 1; i <= k; ++i) {
    			scanf("%d", &x);
    			update(1, 1, n, x, ret);
    			s[vt[x]].del(x), s[vt[x] = ret].insert(x);
			}
		}
		
		int gg, ret = query(1, 1, n, 1, n, gg);
    	if (chk(1, n, ret) <= (n - 1 + 1) / 2) printf("-1\n"); else printf("%d\n", ret);
    	
        return 0;
    }
}
int main() {
	flyinthesky::solve();
    return 0;
}
```

---


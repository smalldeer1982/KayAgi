# 魔法

## 题目背景

小 Y 在 AK 曼哈顿 OI 之后，开始研究膜法。

一个精心构造的魔法阵可以产生强大的魔力，但是也有非常严苛的要求。

魔法阵的强度与咒语的数目相关，但是咒语太多可能会产生冲突，小Y当然会解决这个问题啦，但是他想考一考你。


## 题目描述

魔法阵由 $N$ 个枢纽组成。

每个枢纽可以有五种属性：金、木、水、火、土。它们之间满足相生相克的关系。

 ![](https://cdn.luogu.com.cn/upload/pic/5349.png) 

一开始，魔法阵中没有咒语。

每次，小 Y 会添加一条咒语，它会要求两个枢纽的属性满足相生/相克的关系。然后你需要回答：是否存在一种为每个枢纽分配一个属性的方案，满足所有的要求。

为了调整法阵，小 Y 有时候需要删除一条写过的咒语。

小 Y 觉得这个问题太简单了，于是他使用改变时间线的能力，让每一次操作在之前某一次操作后形成的魔法阵的基础上进行。

## 说明/提示

对于 $30\%$ 的数据，满足 $N,M\leq 100$;

对于另 $30\%$ 的数据，满足 $k_i=i-1$;

对于100%的数据，满足 $N,M \leq 100000, 0\leq k_i < i, u_i \neq v_i, 1 \leq u_i,v_i \leq N$，保证所有删除操作都合法。


## 样例 #1

### 输入

```
3 6  
0 1 1 2  
1 1 2 3  
2 2 1 3  
2 1 3 1  
2 3 1  
5 1 3 1```

### 输出

```
excited  
excited  
excited  
naive  
excited  
excited  ```

# 题解

## 作者：LightningUZ (赞：10)

总体思路是，把操作建成树，在树上求出一个操作的作用dfs序区间；对于操作的dfs序区间用线段树分治+可撤销种类并查集就可以了。



## 具体思路过程

~~如果您足够强，您就会发现这就是一堆套路拼一块~~

### 1. 只有加边

种类并查集。开五个种类维护即可。

> 不要忘记数组大小\*5

### 2. 加上删除操作

考虑线段树分治+可撤销种类并查集。

线段树分治，常用于和可撤销并查集配合，离线维护一个图的连通性，以及相关信息。这个大家应该都会，不会的也不用来做这个题了。

然后可撤销的种类并查集怎么写呢？其实非常simple，和可撤销并查集的撤销部分，代码完全一样，就形如 `while(top>last_top) back()` 的写就可以了。加五条边也是加边，为啥就不能撤，很简单的道理。

注意我们还要在过程中维护，当前是否合法。不合法当且仅当，对于同一个元素，存在两个种类拆出来的点在同一个集合里。这显然不能每次 $O(n)$ 求，但是注意到每次改两个关系，只会对这两个点有影响，$O(1)$ 的 check 一下这两个点是否合法就行。然后维护一个全局变量，表示当前是否合法。注意这个全局变量的值，也要记在撤销信息的 struct 中（撤销的时候，这个变量的值也要相应的被改变，显然）。

### 3. 加上历史版本

每个操作都有其依赖的版本，除了初始节点0。很容易联想到这是一个树形结构。把树建出来。

和序列类似，考虑一个操作的影响区间，应该是子树-若干个子子树（子子树定义为，子树中某个点的子树）。考虑它的dfs序，就是一段区间-若干个子区间。

那么我们可以枚举每一个删除操作，然后把它删除的那个点的影响区间分裂成两部分。关于具体咋实现，就是维护一下当前区间的左端点 `mx`，然后对于删除操作的dfs序区间为 `[l,r]`，加上影响区间 `[mx,l-1]`，然后更新 `mx=r+1` 即可。到最后在加上 `[mx,odfn]`，odfn就是子树的dfs序区间右端点（代码里就是这个名称）

最后在dfs序区间上跑线段树分治就行了。别忘记最后输出的是 `ans[dfn[i]]`，而不是 `ans[i]`。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
namespace Flandre_Scarlet
{
    #define N 200005
    #define F(i,l,r) for(int i=l;i<=r;++i)
    #define D(i,r,l) for(int i=r;i>=l;--i)
    #define Fs(i,l,r,c) for(int i=l;i<=r;c)
    #define Ds(i,r,l,c) for(int i=r;i>=l;c)
    #define MEM(x,a) memset(x,a,sizeof(x))
    #define FK(x) MEM(x,0)
    #define Tra(i,u) for(int i=G.st(u),v=G.to(i);~i;i=G.nx(i),v=G.to(i))
    #define p_b push_back
    #define sz(a) ((int)a.size())
    #define all(a) a.begin(),a.end()
    #define iter(a,p) (a.begin()+p)
    int I() {char c=getchar(); int x=0; int f=1; while(c<'0' or c>'9') f=(c=='-')?-1:1,c=getchar(); while(c>='0' and c<='9') x=(x<<1)+(x<<3)+(c^48),c=getchar(); return ((f==1)?x:-x);}
    template <typename T> void Rd(T& arg){arg=I();}
    template <typename T,typename...Types> void Rd(T& arg,Types&...args){arg=I(); Rd(args...);}
    void RA(int *p,int n) {F(i,1,n) *p=I(),++p;}

    int n,m;
    struct add{int t,u,v;}; // 加的一个条件（t=1生，t=2克）
    struct query{int fa; add e;}o[N]; // 一个操作（如果是删除操作，令e.u=删除的位置）
    void Input()
    {
        Rd(n,m);
        F(i,1,m)
        {
            int f,t; Rd(f,t);
            o[i].fa=f; o[i].e.t=t;
            switch(t)
            {
                case 1: 
                case 2: {o[i].e.u=I(); o[i].e.v=I(); break;}
                case 3: {o[i].e.u=I(); break;}
            }
        }
    }
    class Graph // 存储图的类
    {
    public:
        int head[N];
        struct edge{int u,v,nx;}; vector<edge> E;
        inline void adde(int u,int v)
        {
            E.p_b((edge){u,v,head[u]}); head[u]=sz(E)-1;
        }
        inline void add2(int u,int v) {adde(u,v),adde(v,u);}
        inline int  st(int u) {return u==-1?-1:head[u];}
        inline int  nx(int i) {return i==-1?-1:E[i].nx;}
        inline int  to(int i) {return i==-1?-1:E[i].v;}
        inline vector<edge> adds() {return E;}
        inline void clear() {E.clear(); MEM(head,-1);}
        Graph() {clear();}
    }G;
    class Union_Find_Back_Type // 可撤销种类并查集
    {
    public:
        int fa[N*5],sz[N*5]; bool vis[N*5]; // 五倍空间
        bool is_legal; // 当前是否合法
        struct bak{int u,v,fv,su; bool legal;} bk[N*5]; int top=0; // 把当前是否合法也要记下
        int P[N][5],tot;
        
        void clear(int n) 
        {
            tot=0;
            F(i,1,n) F(j,0,4) P[i][j]=++tot; 
            is_legal=1;

            F(i,1,tot) fa[i]=i,sz[i]=1,vis[i]=0; // 这里循环到tot （写5*n也可以）
            while(top) bk[top--]=(bak){0,0,0,0,0};
        }
        int  find(int x) {return x==fa[x]?x:find(fa[x]);}
        void merge(int u,int v)
        {
            u=find(u),v=find(v);
            if (u==v) return;
            if (sz[u]<sz[v]) swap(u,v);
            bk[++top]=(bak){u,v,fa[v],sz[u],is_legal};
            fa[v]=u; sz[u]+=sz[v];
        }
        bool same(int u,int v) {return find(u)==find(v);}
        bool illegal(int u) // 判断u是否不合法了
        {
            F(i,0,4) vis[find(P[u][i])]=0;
            F(i,0,4) 
            {
                int f=find(P[u][i]);
                if (vis[f]) return true;
                vis[f]=1;
            }
            return false;
        }
        void ke(int u,int v) // 克
        {
            F(j,0,4) merge(P[u][j],P[v][(j+2)%5]);
            if (illegal(u) or illegal(v)) is_legal=0;
            // 每次更新一下u,v即可
        }
        void sh(int u,int v) // 生
        {
            F(j,0,4) merge(P[u][j],P[v][(j+1)%5]);
            if (illegal(u) or illegal(v)) is_legal=0;
        }
        void addtype(add e)
        {
            if (e.t==1) sh(e.u,e.v);
            else        ke(e.u,e.v);
        }
        void back() // 撤销一次
        {
            bak tmp=bk[top--];
            int u=tmp.u,v=tmp.v;
            fa[v]=tmp.fv; sz[u]=tmp.su;
            is_legal=tmp.legal;
        }
    }un;
    int ans[N];
    class SegmentTree // 非常板子
    {
    public:
        vector<add> es[N<<2];
        #define ls ix<<1
        #define rs ix<<1|1
        #define lson ls,L,mid
        #define rson rs,mid+1,R
        #define inx int ix=1,int L=1,int R=(m+1)
        void adde(int l,int r,add e,inx)
        {
            if (l>r) return;
            if (l<=L and R<=r)
            {
                es[ix].p_b(e);
                return;
            }
            int mid=(L+R)>>1;
            if (l<=mid) adde(l,r,e,lson);
            if (mid<r)  adde(l,r,e,rson);
        }
        void solve(inx)
        {
            int rec=un.top;
            for(auto e:es[ix]) un.addtype(e);
            if (L==R)
            {
                ans[L]=un.is_legal;
            }
            else
            {
                int mid=(L+R)>>1;
                solve(lson); solve(rson);
            }
            while(un.top>rec) un.back();
        }
    }T;

    int idfn[N],odfn[N],tick=0;
    void DFS_init(int u) // 先处理出dfs序区间
    {
        idfn[u]=++tick;
        Tra(i,u) DFS_init(v);
        odfn[u]=tick;
    }
    int mx[N];
    void DFS(int u)
    {
        if (o[u].e.t==3) // 对于删除操作，更新一下影响区间
        {
            int p=o[u].e.u;
            T.adde(mx[p],idfn[u]-1,o[p].e);
            mx[p]=odfn[u]+1;
        }
        Tra(i,u) DFS(v);
    }
    void Soviet()
    {
        G.clear();
        F(i,1,m) G.adde(o[i].fa,i); // 加边

        DFS_init(0);
        F(i,0,m) mx[i]=idfn[i];

        DFS(0);
        F(i,1,m) if (o[i].e.t!=3) T.adde(mx[i],odfn[i],o[i].e);
        // 这些就是上面提到的处理一个区间中删除了若干的子区间的方法
        /*
        就是，维护一下当前区间的左端点 mx
        然后对于删除操作的dfs序区间为 [l,r]，加上影响区间 [mx,l-1]，然后更新 mx=r+1 即可。
        到最后在加上 [mx,odfn]，odfn就是子树的dfs序区间右端点
        （代码里就是这个名称）
        */

        un.clear(n);
        T.solve();
        F(i,1,m) puts(ans[idfn[i]]?"excited":"naive");
    }
    void IsMyWife()
    {
        Input();
        Soviet();
    }
}
#undef int //long long
int main()
{
    Flandre_Scarlet::IsMyWife();
    getchar();
    return 0;
}
```

PS: 神奇的是，最长的不是线段树分治 (约1KB)，而是可撤销种类并查集 (约2KB)

---

## 作者：will7101 (赞：10)

# 一句话题意


N个点，支持加边、删边、可持久化，每条边要求连接的两个点的差为1或2（模5意义下），问每个时刻是否有合法方案。


# 提示


先看看这两道题（可自行搜索相关题解）：


- [洛谷P2024——食物链](https://www.luogu.org/problem/show?pid=2024)

- [BZOJ4025——二分图](http://www.lydsy.com/JudgeOnline/problem.php?id=4025)


大概会做了吧？（逃


# 具体做法


我们把操作的时间结构建立出来，发现是一棵树，每个操作在父亲节点操作后的图上进行。


然后每个加入/删除操作所影响的范围是他的子树，在dfs序上是一段**连续**的区间，可以使用线段树分治。


分治的过程中可以使用带权并查集，每个点维护一个深度，代表与根节点的差值，执行合并操作时，分情况讨论即可。


注意要支持撤销，所以**不能路径压缩**。


---

## 作者：kczno1 (赞：7)

我来补充解释一下题解吧。

操作形成一个树形结构。

我们希望加入操作作用于一个连续的dfs区间，并且没有删除操作。因为删除操作是不好搞的。

dfs一遍树，如果遇到删除，那么那个加入的区间就被砍成了两个区间。

这样之后，我们就可以把每个区间放到线段树上。

之后遍历一遍线段树即可。

问题就只剩下加边；如果加的边的两点已经相连通，询问两点的差。

并查集，每个点记录跟father的差。这样信息显然是可以合并的。

如果要问两个点的差，只要知道他们跟根的差，再减一下就好了。

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N=100010;
typedef vector<int>::iterator iter;
int n,m,f[N];vector<int>son[N];
struct query
{
    int type,x,y;
}q[N];int last[N];
int dfn[N];

const int NL=5000000;
vector<int>a[N*4];
int dis[N],sz[N];
bool ok[N];
struct state
{
    int i,f0,sz0,d0;
    state (int x)
    {
        i=x;f0=f[x];sz0=sz[x];d0=dis[x];
    }
    void back()
    {
        f[i]=f0;
        sz[i]=sz0;
        dis[i]=d0;
    }
};
vector<state>st[N*4];
typedef vector<state>::iterator is;
int ql,qr,i;
#define mid (l+r>>1)
#define cl (k*2)
#define cr (cl+1)
void add(int k,int l,int r)
{
    if(ql<=l&&qr>=r)
    {
        a[k].push_back(i);
        return ;
    }
    if(ql<=mid)add(cl,l,mid);
    if(qr>mid)add(cr,mid+1,r);
}

int tot;
void dfs(int x)
{
    dfn[x]=++tot;
    if(q[x].type==3) 
    {
        i=q[x].x;
        if(!(ql=last[i]))q[x].x=0;
        else 
        {
            qr=dfn[x]-1;
            add(1,1,m);
            last[i]=0;
        }
    }
    else last[x]=dfn[x];
    
    for(iter it=son[x].begin();it!=son[x].end();++it) 
     dfs(*it);
    if(q[x].type==3) 
    {
        if(q[x].x) last[q[x].x]=tot+1;
    }
    else 
    {
       if(ql=last[x])
       {
            i=x;qr=tot;
            add(1,1,m);
         last[x]=0;
       }
    }
}

void find(int x,int &fx,int &dx)
{
    dx=0;
    while(f[x])
    {
        dx+=dis[x];
        x=f[x];
    }
    fx=x;
}
void solve(int k,int l,int r)
{
    for(iter it=a[k].begin();it!=a[k].end();++it)
    {
        i=*it;
        int x=q[i].x,y=q[i].y,d=q[i].type,dx,dy,fx,fy;
        find(x,fx,dx);find(y,fy,dy); 
        if(fx==fy)
         if(((dx-dy)%5+5)%5!=d)
         { 
           if(st[k].size())
           for(is it2=st[k].end();--it2>=st[k].begin();) it2->back();
           return;
         }
         else continue;
         
        st[k].push_back(state(fx));st[k].push_back(state(fy));
        
        if(sz[fx]>sz[fy]){swap(fx,fy);swap(dx,dy);d=-d;}
        f[fx]=fy;
        dis[fx]=-dx+d+dy;
        sz[fy]+=sz[fx];
    } 
    
    if(l==r) ok[l]=1;
    else { solve(cl,l,mid);solve(cr,mid+1,r); }
    
    if(st[k].size())
    for(is it2=st[k].end();--it2>=st[k].begin();) 
     it2->back();
} 

int main()
{
    freopen("1.in","r",stdin);
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;++i)
    {
        scanf("%d",f+i);
        son[f[i]].push_back(i);
        scanf("%d%d",&q[i].type,&q[i].x);
        if(q[i].type<3)scanf("%d",&q[i].y);
    }
    
    for(iter it=son[0].begin();it!=son[0].end();++it) 
     dfs(*it);
    
    for(i=1;i<=m;++i){sz[i]=1;f[i]=0;}
    solve(1,1,m);
    
    for(i=1;i<=m;++i)
    if(ok[dfn[i]]) puts("excited");
    else puts("naive");
}
```



---


# [Ynoi Easy Round 2016] 炸脖龙 I

## 题目背景

备餐时光，软泞蜥獾

草地中钻孔，日晷下打转

波若歌鹦苟延残喘，迷途绿龟嚎哮迷茫

“当心炸脖龙，我的孩子！

那锋爪利颚，能挠钩撕咬！

注意秋布秋布鸟，你需回避，

那暴躁冒烟恶怪大毛怪！”

手持宝剑鸣真理之语：寻觅强敌豪壮永不息——于噹噹树下稍事休憩，伫立良久，深陷思绪。

当思绪纷乱杂绪之际，炸脖龙双目如烔炬，从阴暗密林奔跃闯出，一路悲鸣低吟时啭啼！

一，二！一，二！一刺再刺，真理之语将敌斩成糜！

取其首级，置之死地，

伴随胜利，驰马归疾。

“真当是你把怪龙斩于马下？

奋勇吾儿！

来我怀里！奔走相告！衣锦还乡！

父喜不自禁窃鸣得意

波若歌鹦苟延残喘，

迷途绿龟嚎哮迷茫，

备餐时光，软泞蜥獾

草地中钻孔，日晷下打转

波若歌鹦苟延残喘，

迷途绿龟嚎哮迷茫”

——《炸脖龙之诗》

![](https://cdn.luogu.com.cn/upload/pic/21111.png)

我喊了出来...却不成人话

只能，像在水中一边融化一边下沉的方糖一样...

失去自己的轮廓...一直沉向最低处

想要爬上去的子午

维持自己是自己的连续体...

溶解的渐渐七零八落的意识...

失去了用来挣扎的双手

失去了用来挣扎的双臂

向下，

向下，

一直沉下去

向着意识的底层

沉陷下去的自我...

逐渐消失的世界...

我看到了世界

失落的...世界...

![](https://cdn.luogu.com.cn/upload/pic/21112.png)

```plain

   回归天空的话我就可以成为      了

  开什么玩笑，你才不是什么      ！

  吵死了！吵死了！我是      ！而且生来就是！

就是因为这个家伙我才失去      的资格的！

 呜呜呜，由岐姐姐，由岐姐姐！

  ...怎么会...由岐姐...

 卓司！你这家伙！

        吵死了吵死了！像你这样的普通人懂些什么！

   由岐的血慢慢在冰凉的水泥地上扩散开来

   抱在怀里的      在渐渐地流出来        本应成为      而出生

的我的被      妨碍了！

不出生的话我就没法拯救是这个世界！

            所以预言者说能当世界回归天空的此处就是尽头

   只要      回归天空的话！

 我有这么可怕吗？

              因为我是要对一切生物下达审判的存在！

       因为哥哥是凡人呢

    凡人与天才

                            救世主

   世界

                    救世主

                回天之门

  要死的是你！

            我不会死               不会死       诅咒你

       要死的是羽咲

         只要羽咲死了

                  间宫              皆

                                    守           由

                         岐

                                间宫羽咲

                          可能性

                                    和镜

                     终

                   终之空

                     空

```

![](https://cdn.luogu.com.cn/upload/pic/21113.png)

一个婴儿出生了

谁的？

不知道


虽然不知道...
但确实有一个婴儿出生了

嗯...那个婴儿在哭...

呜嘎，呜嘎，地哭着...

听到这个哭声大家都笑了

大家都在为婴儿祝福

母亲也是...

父亲也是...

并且其他人也是...

为那个婴儿的出生...

衷心祝福

世界充满着生命的祝福

但是

但不是这样的

在那里

我

我一个人在那里恐惧着

非常恐惧...

要说为什么的话...

因为那是在对世界进行诅咒

没错...

他在诅咒着那个世界，那个刚出生的婴儿

诅咒着自己的出生

我

我当场全身僵硬

在大家的笑容之中

在祝福之中

独自一人...

我啊...

我摇摇晃晃地...

接近那个婴儿

然后想要让那个婴儿停止哭泣

我想着必须要那样做才行

为什么呢？

我自己也不明白...

那是

那是，自从出生以来

就悲惨地活到今天的我能做到的

我能做到的

唯一的

唯一的赎罪啊。

![](https://cdn.luogu.com.cn/upload/pic/21114.png)

让我在这里了结了你吧…间宫卓司

这里是终之空的下面吧…这不刚好吗

跟我们的终结很相称不是吗…

这里，是只对你而言的，终结的天空…

这里就是终焉之地…

![](https://cdn.luogu.com.cn/upload/pic/21115.png)

“不行！绝对不行！”

…为什么…跟过来了…

![](https://cdn.luogu.com.cn/upload/pic/21116.png)

预定…调和吗…

原来如此…看来不管怎样对于你来说…我都已经毫无任何价值了对吧…

竟然被这家伙打倒了…真是没办法呐…

这也是现实吗…

那就接受吧…

![](https://cdn.luogu.com.cn/upload/pic/21117.png)

不知为何，我好像看到了在夜空中挺立的向日葵…

只有一瞬间…

那株向日葵…

好像在某个地方…

向日葵…

跟羽咲一起…

是啊…

我是哥哥啊…

要是…能再多当当她的哥哥就好了……

![](https://cdn.luogu.com.cn/upload/pic/21119.png)

咦……

刚才的…

那个是…那片风景…

是吗…那片风景…

我也是知道的啊…

在坡道途中的向日葵…

蔚蓝的天空和向日葵。

漂浮着大大的云朵…

羽咲戴着大大的帽子…

然后跟我走在一起…

走着走着…

为了…

两人一起…

爬上那个坡道…

因为…那个坡道的前面有很漂亮的景色…

## 题目描述

您正在打 galgame，然后您觉得这个 gal 不知所云，于是您弃坑了，开始写数据结构题：

给一个长为 $n$ 的序列，$m$ 次操作，每次操作：

1. 区间 $[l,r]$ 加 $x$；
2. 对于区间 $[l,r]$，查询：

$$a[l]^{a[l+1]^{a[l+2]^{\dots ^{a[r]}}}} \mod p$$

## 说明/提示

Idea：nzhtl1477，Solution：nzhtl1477，Code：nzhtl1477，Data：nzhtl1477

对于100%的数据，$n , m \le 500000$ , 序列中每个数在$[1,2\cdot 10^9]$内，$p \le 2 \cdot 10^7 $, 每次加上的数在$[0,2\cdot 10^9]$内

共10组数据


## 样例 #1

### 输入

```
6 4
1 2 3 4 5 6
2 1 2 10000007
2 2 3 5
1 1 4 1
2 2 4 10
```

### 输出

```
1
3
1```

## 样例 #2

### 输入

```
5 5
2 3 3 3 3
1 1 1 530739835
2 1 1 8356089
2 1 4 5496738
1 1 2 66050181
1 2 4 138625417
```

### 输出

```
4306230
697527
```

# 题解

## 作者：Leap_Frog (赞：37)

### P.S.
人生第一道由乃OI的题啊（自上次那道区间sin和被踢出Ynoi后）。  
个人觉得细节还是蛮多的QAQ（虽然代码不长）。  
奈芙莲最可爱了，比珂朵莉可爱多了。  

### Discription.
给定一个序列，设函数 $f(i,i)=a_i,f(i,j)=a^{f(i+1,j)}$。  
支持区间加，查询 $f(l,r)\:\text{mod}\:p\quad(l\le r)$。  
（原题中是用连指数表示的，这里用了递归定义的方法，希望读者能看得明白  
（笔者刚开始一直以为是 ${(a^b)}^c$，手模样例模了半天。  

### Problem.
看上去好像很小清新的，其实却是带毒瘤。  
这题是道区间询问，一看就很像线段树。  
但是我们却发现 $f(i,j)\not=f(i,k)^{f(k+1,j)}$（这也是笔者刚开始犯的错误之一。  
众所周知，线段树维护的东西需要满足区间可加性，所以这题无法用线段树维护。  
那么怎么办呢？我们请出最可爱的奈芙莲树！（奈芙莲最可爱了
#### Part. 0 ~~奈芙莲美图欣赏！感觉要被珂学家D没，不过奈芙莲最可爱了~~  
![](http://tiebapic.baidu.com/forum/w%3D580/sign=9a2a0c799118367aad897fd51e728b68/d9ce46390cd79123bda65524ba345982b3b780ef.jpg)  
#### Part. 1 奈芙莲树简介
用于解决的问题：好像范围其实挺小的，应该就只有这题了吧。  
名字由来：[Nephren Ruq Insania](https://www.luogu.com.cn/problem/P4691)  
前置知识：~~扩欧~~好吧是[扩展欧拉定理](https://blog.csdn.net/can919/article/details/82318115)  
前置知识：[树状数组2](https://www.luogu.com.cn/problem/P3368)，[线性筛筛phi](https://www.baidu.com/s?ie=UTF-8&wd=%E7%BA%BF%E6%80%A7%E7%AD%9Bphi)  
~~不会吧不会吧，不会真有人不会树状数组就爆切由乃OI吧~~。  
接下来的叙述中默认读者已经掌握了它（笔者太菜，不会证明  

#### Part. 2 奈芙莲树具体实现
首先，我们回顾一下目的：我们需要求 $f(l,r)\: \text{mod}\: p$。  
我们套上扩展欧拉定理：它等于 $a_l^{f(l+1,r)\:\text{mod}\:p+[f(l+1,r)\ge \phi(p)]\times \phi(p)}$  
（中间那个是[艾弗森括号](https://baike.baidu.com/item/%E8%89%BE%E4%BD%9B%E6%A3%AE%E6%8B%AC%E5%8F%B7/22361197?fr=aladdin)  
于是我们就把 $f(l,r)\:\text{mod}\:p$ 转化成了 $f(l+1,r)\:\text{mod}\: \phi(p)$（当然中间还要分类讨论  
我们可以证明：$p\rightarrow\phi(p)$这样的迭代只会进行 $\log p$ 次，证明如下：  
- 首先，我们设 $p=\prod_{i=1}^kp_i^{k_i}$，也就是把 $p$ 分解质因数  
- 那么 $\phi(p)=p\prod_{i=1}^k\frac{p_i-1}{p_i}$，根据定义得来  
- 如果 $p\:\text{mod}\:2=0$，那么上面的连乘符号中有一项为 $\frac12$，于是 $\phi(p)\le\frac12 p$。  
- 如果 $p\:\text{mod}\:2=1$，那么连乘符号中肯定存在一位的分子是偶数，于是 $\phi(p)\:\text{mod}\:2=0$  

于是如果我们暴力套欧拉定理，那么我们最多进行 $\log$ 次迭代。  
所以暴力的复杂度是对的！

接下来就是代码实现问题了，因为扩展欧拉定理中需要大量分类讨论。  
我们也需要进行一定量的分类讨论来解决这道题。  
1、如果 $\exists i\in[l,r],a_i=1$，那么 $f(l,r)=f(l,i)$，因为 $1^k=1,k\in \mathbb{N}$  
2、那么 $\forall i\in[l,r],a_i\ge2$，所以 $f(l,l+5)\le2^{2^{2^{2^{2^{}}}}}=2^{65536}\ge 2\times10^7\ge p$。  
　　所以如果区间长度大于 $5$ 且其中没有一个 $1$，那么这个区间的值肯定大于 $p$，我们成功的避免了分类讨论。  

于是我们只需要对于每个区间，暴力处理出第二位到第六位。  
（因为第一位是底数，我们想要判断的是指数和模数的关系  
如果这五位的值大于 $P$，那么直接递归处理。  
否则直接计算答案就好了。  

完结撒花，最后来一遍：奈芙莲最可爱了！  

### Coding.
```cpp
//不会，我并没有做什么需要让你道谢的事 ——Nephren
//奈芙莲最可爱了！奈芙莲比珂朵莉可爱多了。
//众所周知，威莲是指威廉和莲，所以威廉和莲是官配！
//上面这些忽略就好了，怕引战（
#include<bits/stdc++.h>
#define ri register
using namespace std;typedef long long ll;//这些应该没什么好解释的
const int N=500005,M=20000005;int Q,n,ph[M],p[M/10],id;ll t[N];char v[M];inline ll qry(int x);
struct node{ll v[N];int l[N];inline ll& operator[](int x) {return l[x]==id?v[x]:(l[x]=id,v[x]=qry(x));}}a;
//上面是树状数组支持区间修改单点查询，这个总应该都会了吧。
//这里我重定义了[]，用起来方便一点，而且l是用来卡常的，id在下面树状数组修改用
inline int read()
{//快读，不解释
	ri char c=getchar(),f=0;ri int t=0;
	for(;c<'0'||c>'9';c=getchar()) if(!(c^45)) f=1;
	for(;c>='0'&&c<='9';c=getchar()) t=(t<<1)+(t<<3)+(c^48);
	return f?-t:t;
}
inline void write(int x)
{//快输，不解释
	static int t[25];ri int tp=0;
	if(x==0) return(void)(putchar('0'));else if(x<0) putchar('-'),x=-x;
	while(x) t[tp++]=x%10,x/=10;
	while(tp--) putchar(t[tp]+48);
}
inline void add(ri int x,ri ll y) {id++;for(;x<=n;x+=(x&(-x))) t[x]+=y;}
//树状数组修改，id表示当前是第几次修改，呼应上文减小常数处
inline ll qry(ri int x) {ri ll r=0;for(;x;x-=(x&(-x))) r+=t[x];return r;}
//树状数组查询（用了差分的思想，不想解释
inline int ksm(ri ll x,ri ll q,ri int P) {x%=P;int r=1;for(;q;q>>=1,x=1ll*x*x%P) if(q&1) r=1ll*r*x%P;return r%P;}
//快速幂，注意点：x要开ll，x一进去就要取模，q一定要开ll，因为这个调自闭了
inline void William()
{//初始化线性筛phi[]，函数名威连
	ri int pc=0;ph[1]=1;
	for(int i=2;i<M;i++)
	{
		if(!v[i]) p[++pc]=i,ph[i]=i-1;
		for(int j=1;j<=pc&&p[j]*i<M;j++) {v[p[j]*i]=1,ph[p[j]*i]=ph[i]*(i%p[j]?p[j]-1:p[j]);if(i%p[j]==0) break;}
	}
}
inline void Neph(int l,int r,int c) {add(l,c),add(r+1,-c);}
//Nephren前半段，区间修改（差分
inline int ren(int l,int r,int P)
{//Nephren后半段，区间查询查询f(l,r)%P
	if(a[l]%P==0) return 0;else if(P==1) return 1;else if(l==r) return a[l]%P+(a[l]>=P?P:0);
//一大堆特判，应该没什么好解释的了吧，只要仔细阅读上文应该就能懂
	int ls=min(l+5,r);for(int i=l+1;i<=ls;i++) if(a[i]==1) {ls=i;break;}ll g=0,la=a[ls];
//暴力枚举前5位，注意r可能小于l+5，找到最左边的a[i]=1的位置。
	for(int i=ls-1;i>=l+1;i--) {g=la,la=1;while(g--) {la*=a[i];if(la>ph[P]) return ksm(a[l],ren(l+1,r,ph[P])+ph[P],P);}}
//对，你没看错，连快速幂都不需要直接暴力while就好了
	return ksm(a[l],la,P);//如果前五位小于l，那么就直接return快速幂
}
signed main()
{
	n=read(),Q=read(),id=0,William();//读入，初始化
	for(ri int i=1;i<=n;i++) scanf("%lld",&a[i]),add(i,a[i]-a[i-1]);
//读入，因为上面重定义[]时用了引用，所以可以直接读入
	for(ri int fg,l,r,c;Q--;)
	{
		fg=read(),l=read(),r=read(),c=read();
		if(fg==1) Neph(l,r,c);else write(ren(l,r,c)%c),putchar('\n');
	}
	return 0;
}
```
完结撒花

---

## 作者：NaCly_Fish (赞：32)

update：修正了题解代码。


zcy 神仙写的题解小蒟蒻表示看不太懂啊。。  
而且做这题之前要做 `相逢是问候`？明明是这题更简单的样子。   
好吧不扯了我们来说题解。  

先考虑一下没有修改操作应该怎么搞，这题需要用到**扩展欧拉定理**：  


$$a^b \equiv \begin{cases} a^b \ , \  (b < \varphi (p)) \\ a^{b \bmod \varphi(p) +\varphi(p)} \ , \ (b \geq \varphi(p))  \end{cases} \pmod p$$

此处的 $\varphi(p)$ 就是数论中的欧拉函数。  
然后我们就很高兴地写出了一个递归函数来求解：  
```cpp
int solve(int l,int r,int p){
    if(p==1) return 0; //模数为1,结果必然为0
    if(l==r) return a[l]%p; //查询区间大小为1,直接返回即可
    return power(a[l],solve(l+1,r,phi(p))+phi(p),p); //phi(p)就是欧拉函数,递归求解
}
```  
其中 `power` 函数输入 $a,b,p$，求 $a^b\text{ mod }p$。  
随便试几组数据，就会发现这么做是有问题的。。  
原因就在于我们没有判断 $b$ 和 $\varphi(p)$ 的大小关系，那怎么解决这个问题呢？  

这里我用了一种粗暴的方法：  
用一个 struct 来存答案，内含两个属性：一个是运算结果，一个是这个值是否大于 $\varphi(p)$。  
具体写起来是这个样子的：  
```cpp
struct node{
    int val;
    bool flag;
    node(int val=0,bool flag=false):val(val),flag(flag){}
};
```
于是我们把之前的递归函数改进成这样：  
```cpp
node solve(int l,int r,int p){
    node res;
    if(p==1) return node(0,true); 
    if(a[l]==1) return node(1,false);
    if(l==r) return a[l]<p?node(a[l],false):node(a[l]%p,true); //上面说的特判,如果a[l]>=p就需要返回true
    res = solve(l+1,r,phi(p));
    if(res.flag) res.val += phi(p); //根据下一层递归的返回值,判断指数是否应该多加上p
    return power(a[l],res.val,p);
}
```  
此处的 `power` 函数也是 `node` 类型的，里面会判断 $a^b$ 是否大于 $p$。  
至于这里为什么是和 $p$ 而不是和 $\varphi(p)$ 比较，因为这里的 $p$ 对于上一层递归来说，就是 $\varphi(p)$ 了。  

现在已经把不带修改的部分完成了！    
带上修改其实也很好做。直接写一个树状数组，区间加的时候就直接加， `solve` 函数中把 $a_l$ 改为树状数组查询第 $l$ 项。  

总结：思路很简单，代码很难写。于是这道~~大毒瘤~~题就被我们做完了。  
***
最后补充一下时间复杂度的证明： 

对于任意大于 $2$ 的整数 $n$，$\varphi(n)$ 都为偶数。而对于偶数 $n$，显然有 $\varphi(n)\le n/2$。  
所以对一个数取 $\mathcal O(\log n)$ 次欧拉函数，就会变为 $1$。   

也就是 $\varphi(p),\varphi(\varphi(p)),\varphi(\varphi(\varphi(p))) \cdots$ 这么算下去，$\mathcal O(\log p)$ 次后会得到 $1$。   
所以那个递归函数最多会进行 $\mathcal O(\log p)$ 层。  
对于每一层，都会进行一次 $\mathcal O(\log n)$ 的树状数组查询，和 $\mathcal O(\log p)$ 的快速幂。    
此外还有 $\Theta(p)$ 的预处理，计算 $[1,p]$ 所有数的欧拉函数。
所以总时间复杂度就是 $\mathcal O(p+q\log np \log p)$。 
***
献上巨丑无比的代码：  
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<iostream>
#include<cmath>
#include<bitset>
#define N 500003
#define M 20000003
#define inf 0x3f3f3f3f
#define int long long
using namespace std;

struct node{
    int rs;
    bool flag;
    node(int rs=0,bool flag=false):rs(rs),flag(flag){}
};

int a[N],phi[M],pr[M];
int n,q;
bitset<M> vis;

inline void read(int &x);
void print(int x);
inline node power(int a,int t,int p);
void init();
node solve(int l,int r,int p);
inline void add(int l,int r,int x);
inline void qwq(int i,int x);
inline int query(int i);
inline int lowbit(int x);

signed main(){
    init();
    int l,r,op,x,t;
    node ans;
    read(n),read(q);
    for(int i=1;i<=n;++i){
        read(t);
        add(i,i,t);
    }
    while(q--){
        read(op),read(l),read(r),read(x);
        if(op==1) add(l,r,x);
        else{
            ans = solve(l,r,x);
            print(ans.rs);
            putchar('\n');
        }
    }
}

node solve(int l,int r,int p){
    int ph,al = query(l);
    node res;
    if(p==1) return node(0,1);
    if(al==1) return node(1,0);
    if(l==r) return al<p?node(al,0):node(al%p,1);
    ph = phi[p];
    res = solve(l+1,r,ph);
    if(res.flag) res.rs += ph;
    return power(al,res.rs,p);
}

inline void init(){
    int cnt = 0;
    phi[1] = 1;
    for(register int i=2;i<=20000000;++i){
        if(!vis[i]){
            pr[++cnt] = i;
            phi[i] = i-1;
        }
        for(register int j=1;j<=cnt;++j){
            int t = i*pr[j];
            if(t>20000000) break;
            vis[t] = 1;
            if(i%pr[j]==0){
                phi[t] = phi[i]*pr[j];
                break;
            }
            phi[t] = phi[i]*(pr[j]-1);
        }
    }
}

inline node power(int a,int t,int p){ // 做快速幂时，判断答案是否大于等于 p 
    node res = node(1,0);
    if(a>=p){
        a %= p;
        res.flag = 1;
    }
    while(1){
        if(t&1) res.rs = res.rs*a;
        if(res.rs>=p){ 
            res.flag = 1;
            res.rs %= p;
        }
        t >>= 1;
        if(t==0) break;
        a = a*a;
        if(a>=p){
            res.flag = 1;
            a %= p;
        }
    }
    return res;
}

inline void read(int &x){
    x = 0;
    char c = getchar();
    while(c<'0'||c>'9') c = getchar();
    while(c>='0'&&c<='9'){
        x = (x<<3)+(x<<1)+(c^48);
        c = getchar();
    }
}

void print(int x){
    if(x>9) print(x/10);
    putchar(x%10+'0');
}

inline void add(int l,int r,int x){
    qwq(l,x);
    qwq(r+1,-x);
}

inline void qwq(int i,int x){
    while(i<=n){
        a[i] += x;
        i += lowbit(i);
    }
}

inline int query(int i){
    int res = 0;
    while(i){
        res += a[i];
        i -= lowbit(i);
    }
    return res;
}

inline int lowbit(int x){
    return x&(-x);
}
```

---

## 作者：zcysky (赞：28)

UPD2:被mjl叉了真刺激，然后改了改，具体可以看他的帖子。

我为啥这么菜啊。。。。。这个题挂了三次了。。。。

 ![](https://cdn.luogu.com.cn/upload/pic/9403.png) 

UPD：修改了一部分细节。


首先这个题的题面写的非常好，我个人十分满意。


奈芙莲真的很可爱啊。


首先两题前置技能：上帝与集合的正确用法，相逢是问候


套路都是一样的，考虑用拓展欧拉定理降幂。


$ a^x\ mod\ p=a^{x\ mod\  \phi({p})+(x>\phi(p)?\phi(p):0)} mod \ p$

我们发现对一个数取欧拉函数，log次就会变成1，而任何数模1肯定=0，所以就可以算出来了。


然而这么做还会有一些小问题。


首先我们发现后面的phi[p]这一项是可能不会加的。这个怎么办呢？


首先可以按照相逢是问候那题的套路返回判断是否取模，以此作为是否加上这一项的依据。


当然这么做需要讨论的东西会有点多，挺麻烦的。


后来就想到了也写在讲评里的办法，就是因为这个不断地幂次增长速度极快，很少几项就能够增长到远大于模数的地步。


那就先暴力的处理前面几项，然后再正常做，这样就减少了讨论次数。


但是这么搞还会存在一个问题，就是如果前几个常数次暴力处理的全是1，增长就是假的。


不过考虑到有1的话后面的全都被变成了1，所以完全没有必要担心这个，找到1就从1开始做好了。


然后还会存在一个问题，就是如果得到的是0次方，$x^0=1$


这个虽然数据不会存在这个问题，但是取模后会出现。


这个地方稍微注意一下就好了。


然后应该就没有什么坑了。


总体复杂度 $O(Qlog^2P)$



![](https://cdn.luogu.com.cn/upload/pic/9324.png)

然后附上我验题的时候写的被改了无数次的丑的代码。


中间有很多没用的东西懒得删了，看主要部分就好。


其实应该写树状数组的，原来打算用线段树测常数，懒得改回去了==

```cpp
#include<bits/stdc++.h>
#include<bits/stdc++.h>
const int N=500005;
const int M=20000005;
const int inf=N-4;
const int lim=20000000;
typedef long long ll;
using namespace std;
int n,m,x,phi[M],prime[M],cnt;
ll c[N],a[N];bool vis[M];
int las[N];
inline int read(){
    int f=1,x=0;char ch;
    do{ch=getchar();if(ch=='-')f=-1;}while(ch<'0'||ch>'9');
    do{x=x*10+ch-'0';ch=getchar();}while(ch>='0'&&ch<='9');
    return f*x;
}
inline int fpow(int x,ll p,int yql){
    int ans=1;
    for(;p;p>>=1,x=1LL*x*x%yql)if(p&1)ans=1LL*ans*x%yql;
    return ans;
}
inline void calcpri(){
    phi[1]=1;
    for(int i=2;i<=lim;i++){
        if(!vis[i])prime[++cnt]=i,phi[i]=i-1;
        for(int j=1;j<=cnt;j++){
            int t=i*prime[j];if(t>lim)break;
            vis[t]=1;
            if(i%prime[j]==0){phi[t]=phi[i]*prime[j];break;}
            phi[t]=phi[i]*(prime[j]-1);
        }
    }
}
ll sumv[N<<2],addv[N<<2],fone[N<<2];
#define lson (o<<1)
#define rson (o<<1|1)
inline void pushup(int o){
    sumv[o]=sumv[lson]+sumv[rson];
    fone[o]=min(fone[lson],fone[rson]);
}
inline void build(int o,int l,int r){
    fone[o]=inf;
    if(l==r){sumv[o]=a[l];if(a[l]==1)fone[o]=l;return;}
    int mid=(l+r)>>1;
    build(lson,l,mid);build(rson,mid+1,r);
    pushup(o);
}
inline void pushdown(int o,int l,int r){
    if(!addv[o])return;
    int mid=(l+r)>>1;
    addv[lson]+=addv[o];addv[rson]+=addv[o];
    sumv[lson]+=addv[o]*1LL*(mid-l+1);
    sumv[rson]+=addv[o]*1LL*(r-mid);
    fone[lson]=inf;fone[rson]=inf;
    addv[o]=0;
}
inline void change(int o,int l,int r,int q,int v){
    if(l==r){sumv[o]=v;return;}
    int mid=(l+r)>>1;
    pushdown(o,l,r);
    if(q<=mid)change(lson,l,mid,q,v);
    else change(rson,mid+1,r,q,v);
    pushup(o);
}
inline void optadd(int o,int l,int r,int ql,int qr,int v){
    if(ql<=l&&r<=qr){addv[o]+=v;sumv[o]+=1LL*(r-l+1)*v;fone[o]=inf;return;}
    int mid=(l+r)>>1;pushdown(o,l,r);
    if(ql<=mid)optadd(lson,l,mid,ql,qr,v);
    if(qr>mid)optadd(rson,mid+1,r,ql,qr,v);
    pushup(o);
}
inline ll querysum(int o,int l,int r,int q){
    if(l==r)return sumv[o];
    int mid=(l+r)>>1;pushdown(o,l,r);
    if(q<=mid)return querysum(lson,l,mid,q);
    else return querysum(rson,mid+1,r,q);
}
inline ll query(int q){
    if(las[q]==m)return a[q];
    las[q]=m;
    return a[q]=querysum(1,1,n,q);
}
inline int queryfst(int o,int l,int r,int ql,int qr){
    if(ql<=l&&r<=qr)return fone[o];
    int mid=(l+r)>>1;pushdown(o,l,r);
    int ans=inf;
    if(ql<=mid)ans=min(ans,queryfst(lson,l,mid,ql,qr));
    if(qr>mid)ans=min(ans,queryfst(rson,mid+1,r,ql,qr));
    return ans;
}
inline ll calc(int l,int r,int yql){
    if(query(l)%yql==0)return 0;
    if(yql==1)return 1;
    if(l==r)return query(l)%yql+(query(l)>=yql)*yql;
    int f=min(r,l+5);
    for(int i=l+1;i<=f;i++)if(query(i)==1){f=i;break;}
    ll last=query(f),q=0;
    for(int i=f-1;i>=l+1;i--){
        q=last,last=1;
        while(q--){
            last*=query(i);
            if(last>=phi[yql])return fpow(query(l)%yql,calc(l+1,r,phi[yql])+phi[yql],yql);
        }
    }
    return fpow(query(l)%yql,last,yql);
}
int main(){
    //freopen("data.in","r",stdin);
    //freopen("data.out","w",stdout);
    calcpri();memset(las,-1,sizeof(las));
    n=read();m=read();
    for(int i=1;i<=n;i++)a[i]=read();
    build(1,1,n);
    while(m--){
        int opt=read(),l=read(),r=read(),yql=read();
        if(opt==1)optadd(1,1,n,l,r,yql);
        else printf("%lld\n",(calc(l,r,yql))%yql);
    }
}
```

---

## 作者：Aw顿顿 (赞：10)

人生中第一道 Ynoi，本来是 900 粉 Flag 但是不小心就做出来了，那就提前庆祝 900 粉吧（虽然发这份题解的时候还没到）。

其实此题从任何一个角度来说都不难的。

-------

> [**P3934 \[Ynoi2016\] 炸脖龙 I**](https://www.luogu.com.cn/problem/P3934)
> 
> 给定一个长度为 $n$ 的区间 $a$，进行 $m$ 次操作：
>
> - 将区间 $[l,r]$ 加上 $x$。
>
> - 求 $a(l)^{a(l+1)^{\cdots^{a(r)}}}\bmod p$。

如果我们记 $f(x,x)=a_x$ 且 $f(x,y)=a^{f(x+1,j)}$，那么我们就可以用递归的形式表示操作二：求 $f(l,r)$。由于该操作并不具有可加性，考虑用奈芙莲树解决（好像是神蛙起的名字），实际上这个数据结构就是差分树状数组与扩展欧拉定理的有机结合。

## 前置知识

上一次看到次幂的次幂的次幂……还是在上帝与集合的正确用法那题，而这道题目又套上了区间操作，于是考虑前置知识：

- [**欧拉函数求值**](https://www.luogu.com.cn/blog/LinearExpectation/Scientifically-calculate-Euler-function)
- [**扩展欧拉定理**](https://www.luogu.com.cn/blog/LinearExpectation/Euler-Theorem-Fermat-Little-Theorem)
- [**树状数组基础**](https://www.luogu.com.cn/blog/LinearExpectation/Fenwick-Tree-Study-Notes)

虽然这两个扩展资料对于此题来说是不够的，但是我们在接下来的讲解之中会简单介绍具体操作，因此不必担心。另外，本文的数学公式均在模 $p$ 意义下讨论。

## 操作方法

通过扩展欧拉定理，$f(l,r)$ 可以转化为 $a_l^{t}$，其中：

$$t=\begin{cases}f(l+1,r)\bmod p+\varphi(p)&f(l+1,r)\ge\varphi(p)\\f(l+r,r)\bmod p\end{cases}$$

由因数分解可得，这样的迭代最多进行 $\log$ 次，这里给出简要证明。由 $\varphi$ 的定义可以得到：

$$\varphi(n)=n\prod\limits_{i=1}^{n}\left(1-\dfrac{1}{p_i}\right)$$

若 $n$ 是偶数则乘式中一定存在一项 $1-\frac{1}{2}$，反之则一定存在一个形如 $\frac{a}{b}$ 的因式满足 $a\equiv 2\pmod 2$，可以归纳到偶数里。因此最多进行 $\log$ 次递归就可以得到答案。接下来考虑分类化简情况：

- 如果在这一区间内存在任意一个 $a_i=1$，那么在 $i$ 之后的所有次幂都可以忽略，因为底数为 $1$。
- 如果不存在 $1$，且区间长度大于 $5$，那么简单计算：

$$f(l,l+5)\ge 2^{2^{2^{2^2}}}\ge 2\times 10^7$$

所以在扩展欧拉定理中，这样的大小已经超过了 $p$，因此不需要再进一步分类讨论。因此对于第二位到第六位的情况（第一位是底数不在乎，因此是第二位到第六位），可以暴力计算，而再之后的情况可以直接扔到递归式子里面算即可，可以用树状数组维护。

## 具体实现

首先预处理出 $\varphi$ 值。

```cpp
inline void getphi(){
	int cnt=0;phi[1]=1;
	for(int i=2;i<M;i++){
		if(!vis[i])pr[++cnt]=i,phi[i]=i-1;
		for(int j=1;j<=cnt&&pr[j]*i<M;j++){
			vis[pr[j]*i]=1;
			if(i%pr[j])phi[pr[j]*i]=phi[i]*(pr[j]-1);
			else phi[pr[j]*i]=phi[i]*pr[j];
			if(i%pr[j]==0)break;
		}
	}
}
```

具体实现上不难。对于操作一，我们只需要用差分树状数组进行两次区间加即可：

```cpp
inline void add(int x,long long y){
	id++;
	while(x<=n){
		t[x]+=y;
		x+=lowbit(x);
	}
}inline void work1(int l,int r,int c){
  add(l,c);
  add(r+1,-c);
}//区间修改 
```

而操作二首先进行特判，然后就可以分类讨论了。对于前五位进行暴力，后面的用扩展欧拉定理计算。具体操作步骤如：

- 特殊情况特殊处理。
- 取二到六位进行处理，找出最前面的 $a_i=1$ 并 $r\gets i$。
- 累乘判断是否需要递归，如需递归则规模变小。
- 否则暴力计算。

```cpp
inline int work2(int l,int r,int mod){//区间次幂查询
	if(a[l]%mod==0)return 0;
	else if(mod==1)return 1;
	else if(l==r){
		if(a[l]>=mod)return a[l]%mod+mod;
		else return a[l]%mod;
	}int len=min(l+5,r);
	for(int i=l+1;i<=len;i++)
		if(a[i]==1){
			len=i;
			break;
		}
	int g=0,last=a[len];
	for(int i=len-1;i>=l+1;i--){
		g=last,last=1;
		while(g--){
			last=last*a[i];
			if(last>phi[mod])
				return ksm(a[l],work2(l+1,r,phi[mod])+phi[mod],mod);
		}
	}return ksm(a[l],last,mod);
}
```

## 全文代码实现

本身由于是否开 $\texttt{long long}$ 的问题被弄得很晕，因此代码加了 `#define int long long` 因此可读性可能不是很好，但是在这道题这样写是没有问题的。这里提出几个注意点：

- 快速幂一律底数取模。
- 结构体中重定义 `[]` 并记录修改次数以优化常数。
- 预处理条件写 `<MAXM` 而非 `<=MAXM` 否则会越界。
- 用快写输出后记得换行。

```cpp
#include<bits/stdc++.h>
#define int long long
#define N 500005
#define M 20000005
using namespace std;
inline int read(){
   register int s=0,w=1;
   char ch=getchar();
   while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
   while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=getchar();
   return s*w;
}inline void print(int x){
    if(x<0){putchar('-');x=-x;}
    if(x>9)print(x/10);
    putchar(x%10+'0');
}inline int lowbit(int x){return x&(-x);}
int q,n,phi[M],pr[M>>3],id;
int t[N];char vis[M];
inline int query(int x){
	int s=0;//区间查询  
	while(x){
		s+=t[x];
		x-=lowbit(x);
	}return s;
}struct node{//重载 [] 运算符
	int v[N],l[N];
	inline int&operator[](int x){
		if(l[x]!=id)l[x]=id,v[x]=query(x);
		return v[x];
	}
}a;
inline void add(int x,int c){
	id++;//区间修改 记录修改次数  
	while(x<=n){
		t[x]+=c;
		x+=lowbit(x);
	}
}inline int ksm(int b,int p,int mod){
	int s=1;b%=mod;//底数先取模
	while(p){
		if(p&1)s=1ll*s*b%mod;
		b=b*b%mod;p>>=1;
	}return s;
}inline void getphi(){//预处理 phi
	int cnt=0;phi[1]=1;
	for(int i=2;i<M;i++){
		if(!vis[i])pr[++cnt]=i,phi[i]=i-1;
		for(int j=1;j<=cnt&&pr[j]*i<M;j++){
			vis[pr[j]*i]=1;
			if(i%pr[j])phi[pr[j]*i]=phi[i]*(pr[j]-1);
			else phi[pr[j]*i]=phi[i]*pr[j];
			if(i%pr[j]==0)break;
		}
	}
}inline void work1(int l,int r,int c){add(l,c);add(r+1,-c);}
inline int work2(int l,int r,int mod){
	if(a[l]%mod==0)return 0;
	else if(mod==1)return 1;
	else if(l==r){
		if(a[l]>=mod)return a[l]%mod+mod;
		else return a[l]%mod;
	}int len=min(l+5,r);
	for(int i=l+1;i<=len;i++)
		if(a[i]==1){//找 1
			len=i;
			break;
		}
	int g=0,last=a[len];
	for(int i=len-1;i>=l+1;i--){
		g=last,last=1;
		while(g--){
			last=last*a[i];
			if(last>phi[mod])
				return ksm(a[l],work2(l+1,r,phi[mod])+phi[mod],mod);
		}
	}return ksm(a[l],last,mod);
}signed main(){
	n=read();q=read();getphi();
	for(int i=1;i<=n;i++){
		scanf("%lld",&a[i]);
		add(i,a[i]-a[i-1]);//做差分 
	}for(int i=1;i<=q;i++){
		int op,l,r,c;
		op=read();l=read();r=read();c=read();
		if(op==1)work1(l,r,c);
		else print(work2(l,r,c)%c),putchar('\n');
	}return 0;
}
```

---

## 作者：monstersqwq (赞：5)

~~不用卡常的 Ynoi，妙~~

区间加区间 $a_l^{a_{l+1}^{a_{l+2}\cdots^{a_r}}}\bmod p$

连指数看起来很恶心，尝试化简。

关于指数的定理大致有欧拉定理，但是简单的欧拉定理无法解决此题，它要求 $a$ 与 $n$ 互质。

这时有一个不需要依赖互质的定理：扩展欧拉定理，[模板](https://www.luogu.com.cn/problem/P5091)。

结论：当 $b\ge \varphi(m)$ 时，$a^b\equiv a^{b \bmod \varphi(m)+\varphi(m)}\pmod m$

$\varphi(m)$ 指小于等于 $m$ 的数中与 $m$ 互质的数的个数（欧拉函数），对于此函数，有式子：

$$\varphi(m)=m\prod\limits_{i|m,i\in prime}\dfrac{i-1}{i}$$

那这个函数显然是一个积性函数，简证：

$$\varphi(\prod\limits_{i=1}^{n_1}{p1_{i}^{c1_i}})\varphi(\prod\limits_{i=1}^{n_2}{p2_{i}^{c2_i}})=\prod\limits_{i=1}^{n_1}{p1_{i}^{c1_i}}\prod\limits_{i=1}^{n_2}{p2_{i}^{c2_i}}\prod\limits_{i=1}^{n_1}{\dfrac{p1_i-1}{p1_i}}\prod\limits_{i=1}^{n_2}{\dfrac{p2_i-1}{p2_i}}$$

因为 $p1,p2$ 中无重复质数，所以该式等于：

$$\varphi(\prod\limits_{i=1}^{n_1}{p1_{i}^{c1_i}}\prod\limits_{i=1}^{n_2}{p2_{i}^{c2_i}})$$

那我们可以愉快的线性筛它了。

接下来考虑如何解决操作二，观察到一个欧拉函数神奇的性质：对一个数 $a$ 不断取 $\varphi$，最多 $O(\log a)$ 次就会取到 $1$，证明：

$a$ 是偶数时，上面的式子一定会是 $\varphi(a)=a\times \dfrac{1}{2}\times k$，其中 $k$ 是一个多个小于 $1$ 的分数之积，所以 $\varphi(a)\le \dfrac{a}{2}$。

$a$ 是奇数且大于 $1$ 时，上面的式子可以化成这样 $\varphi(a)=a\prod{\dfrac{2k}{2k+1}}$，一定是一个偶数。

那么可以在操作二如下暴力递归套扩展欧拉定理，当 $p=1$ 时该式一定为 $0$，区间长最大是 $O(\log p)$。（暂时默认满足扩展欧拉定理的条件）

$$a_l^{a_{l+1}^{a_{l+2}\cdots^{a_r}}}\bmod p=a_{l}^{a_{l+1}^{a_{l+2}\cdots^{a_r}}\bmod \varphi(p)+\varphi(p)}\bmod p$$

但是由于扩展欧拉定理的使用条件，还需要判断一个 $a_{l+1}^{a_{l+2}\cdots^{a_r}}< \varphi(p)$ 的情况。

这种情况可以在快速幂求可以用的情况时特判一下，若取过有意义的模就加上 $\varphi(p)$，没有取过就不加，这种情况因 $b<p$，$b\bmod p=b$，没有问题。这时的快速幂还有直接求出所需结果的功能，就不需要在快速幂外面再加上 $\varphi(p)$ 了。

然后这个东西需要一个支持区间修改单点查询的数据结构，拿树状数组非常好写且常数小，[附模板](https://www.luogu.com.cn/problem/P3368)。

总复杂度是预处理+操作，$O(p+m\log p\max(\log p,\log n))$，可以通过。

附很久之前写的丑陋代码：
```cpp
#include <cstdio>
#include <iostream>
#include <cmath>
#include <algorithm>
#include <string>
#include <cstring>
#include <queue>
using namespace std;
typedef long long ll;
ll phi[20000005],prime[20000005],cnt,c[500005],a[500005];
int n,m;
bool isp[20000005],flag=false;
int lowbit(int x)
{
    return x&-x;
}
void upd(int x,ll k)
{
    while(x<=n)
    {
        c[x]+=k;
        x+=lowbit(x);
    }
}
ll query(int x)
{
    ll res=0;
    while(x>=1)
    {
        res+=c[x];
        x-=lowbit(x);
    }
    return res;
}
ll poww(ll a,ll b,ll p)
{
    ll ans=1;
    flag=false;
    if(a>p)
    {
        flag=true;
        a%=p;
    }
    while(b>0)
    {
        if(b%2==1)
        {
            ans*=a;
            if(ans>p)
            {
                flag=true;
                ans%=p;
            }
        } 
        a*=a;
        if(a>p)
        {
            flag=true;
            a%=p;
        }
        b/=2;
    }
    if(flag)
        ans+=p;
    return ans;
}
ll solve(ll l,ll r,ll p)
{
    ll tmp=query(l);
    if(p==1) return 1;
    if(l==r) return tmp>=p?tmp%p+p:tmp;
    return poww(tmp,solve(l+1,r,phi[p]),p);
}
int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++)
    {
        cin>>a[i];
        upd(i,a[i]);
        upd(i+1,-a[i]);
    } 
    isp[1]=true;
    phi[1]=1;
    for(ll i=2;i<=20000000;i++)
    {
        if(isp[i]==false)
        {
            cnt++;
            prime[cnt]=i;
            phi[i]=i-1;

        }
        for(int j=1;j<=cnt;j++)
        {
            if(i*prime[j]>2e7) break;
            isp[i*prime[j]]=true;
            if(i%prime[j]==0)
            {
                phi[i*prime[j]]=phi[i]*prime[j];
                break;
            }
            else phi[i*prime[j]]=phi[i]*(prime[j]-1);
        }
    }
    for(int i=1;i<=m;i++)
    {
        int opt;
        cin>>opt;
        if(opt==1)
        {
            int l,r,x;
            cin>>l>>r>>x;
            upd(l,x);
            upd(r+1,-x);
        }
        else
        {
            int l,r,p;
            cin>>l>>r>>p;
            cout<<solve(l,r,p)%p<<endl;
        }
    }
    return 0;
}
```

---

## 作者：devout (赞：5)

[预料到$\LaTeX$要挂，给个博客链接](https://devout.blog.luogu.org/solution-p3934)

****

Ynoi竟然出了个奈芙莲的题，少见啊

Ynoi竟然有个不卡常的题，~~更少见了~~

****

这道题其实思路非常好想，本质上就是一个暴力，但是要用到拓展欧拉定理，是什么呢？

$$a^c\equiv\begin{cases}a^c,c<\phi(p) \\ a^{c\bmod \phi(p)+\phi(p)},c\geq\phi(p)\end{cases} \bmod p$$

这个东西有什么用呢？做过[这道题](https://www.luogu.com.cn/problem/P3747)的就应该很明显了

我们观察$\phi(p)$一定$\leq\frac{n}{2}$，那么也就是说最多经过$\log p$次之后，我们的$\phi(\phi(\phi(...\phi(p))))=1$，这个时候根据我们上面的拓展欧拉定理，我们就不需要继续算剩下的部分了，因为剩下的部分算完肯定是$1$

也就是说我们对于每次查询，从$x$暴力往右扫，每次都让$p=\phi(p)$，那么经过一定次数之后剩下的就不用管了，然后我们再回溯更新这一部分的答案就可以

因为有区间加之类的操作，所以我们用树状数组维护差分，就可以求出每一个位置上的数是多少了

其实这题根[这道题](https://www.luogu.com.cn/problem/P4139)也挺像的吧，但是上帝那道题的数据比较水，我们会发现，当我们的$c<\phi(p)$的时候，我们是不能$+\phi(p)$的，这个东西就非常的恶心，我们需要特判一下

特判的方法也比较简单，我们在做快速幂的过程中，每次计算完先不取模，如果发现比$p$大，$flag=1$，然后再取模，做完快速幂之后再判断如果$flag=1$，那么再加上$\phi(p)$

快速幂大概是这个样子的

```cpp
int Qpow(int base,int ind,int mod){
    int res=1;
    flag=false;
    if(base>=mod)flag=true,base%=mod;
    while(ind){
        if(ind&1){
            res=res*base;
            if(res>=mod)flag=true,res%=mod;
        }
        base=base*base;
        if(base>=mod)flag=true,base%=mod;
        ind>>=1;
    }
    return res;
}

```

~~好长啊~~

查询的时候其实是不用写$dfs$的，我们可以直接手动模拟栈，先把要求的部分的模数都预处理出来，然后从右往左算就可以

```cpp
        else{
            int now=x;
            modn[x]=p;
            p=phi[p];
            while(p>1&&now<y){
                modn[++now]=p;
                p=phi[p];
            }
            int res=1;
            _Rep(i,now,x){
                res=Qpow(ask(i),res,modn[i]);
                if(flag)res+=modn[i];
            }
            printf("%lld\n",res%modn[x]);
        }
```


由于$p\leq 2\times10^7$，所以我们要线性筛，然后这题空间500MB，放心的开longlong吧。

其他细节没什么了，~~只要不像我一样线性筛出一堆锅就好~~

****

然后是这题的复杂度，我们发现，每次询问我们最多查询$\log p$次，每次需要$\log n$的时间，然后算快速幂需要$\log p$次的时间，所以这题的总复杂度应该是$O(m\log n\log^2 p)$

~~毒瘤的lxl这题仁慈的开了3s时限~~

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;

# define Rep(i,a,b) for(int i=a;i<=b;i++)
# define _Rep(i,a,b) for(int i=a;i>=b;i--)
# define RepG(i,u) for(int i=head[u];~i;i=e[i].next)

typedef long long ll;

const int N=5e5+5;
const int M=2e7+5;

template<typename T> void read(T &x){
   x=0;int f=1;
   char c=getchar();
   for(;!isdigit(c);c=getchar())if(c=='-')f=-1;
   for(;isdigit(c);c=getchar())x=(x<<1)+(x<<3)+c-'0';
    x*=f;
}

# define int long long

int n,m;
int a[N],bit[N];
int phi[M],prime[N*10],tot;
int modn[N];
bool isp[M],flag;

int lowbit(int o){
    return o&-o;
}

void add(int o,int x){
    for(;o<=n;o+=lowbit(o))bit[o]+=x;
}

int ask(int o){
    int res=0;
    for(;o;o-=lowbit(o))res+=bit[o];
    return res;
}

void init()
{
    phi[1]=1;
    for(int i=2;i<=2e7;i++){
        if(isp[i])prime[++tot]=i,phi[i]=i-1;
        for(int j=1;j<=tot&&i*prime[j]<=2e7;j++){
            isp[i*prime[j]]=false;
            if(i%prime[j]==0){
                phi[i*prime[j]]=phi[i]*prime[j];
                break;
            }
            else phi[i*prime[j]]=phi[i]*(prime[j]-1);
        }
    }
}

int Qpow(int base,int ind,int mod){
    int res=1;
    flag=false;
    if(base>=mod)flag=true,base%=mod;
    while(ind){
        if(ind&1){
            res=res*base;
            if(res>=mod)flag=true,res%=mod;
        }
        base=base*base;
        if(base>=mod)flag=true,base%=mod;
        ind>>=1;
    }
    return res;
}

signed main()
{
    memset(isp,true,sizeof(isp));
    read(n),read(m);
    Rep(i,1,n)read(a[i]);
    Rep(i,1,n)add(i,a[i]-a[i-1]);
    init();
    Rep(i,1,m){
        int opt,x,y,p;
        read(opt),read(x),read(y),read(p);
        if(opt==1){
            add(x,p);
            add(y+1,-p);
        }
        else{
            int now=x;
            modn[x]=p;
            p=phi[p];
            while(p>1&&now<y){
                modn[++now]=p;
                p=phi[p];
            }
            int res=1;
            _Rep(i,now,x){
                res=Qpow(ask(i),res,modn[i]);
                if(flag)res+=modn[i];
            }
            printf("%lld\n",res%modn[x]);
        }
    }
    return 0;
}
```


---

## 作者：功在不舍 (赞：5)

这个题的思路大佬们都介绍的差不多了，~~但是他们的代码真的好长~~，我介绍一种对于萌新很友好的代码。

前置知识：1. 扩展欧拉定理 $a^k \equiv a^{k \% \varphi(p)+\varphi(p) } \ (mod \ p)(k>=\varphi(p))$ 

注意扩展欧拉定理的使用条件是模数大于等于欧拉函数值

2.欧拉函数通项公式: $\varphi(n)=n\prod\limits_{p|n,p\in prime}\frac{p-1}{p}  $

3.欧拉函数是积性函数: $\varphi(nm)=\varphi(n)\varphi(m) \ (gcd(n,m)=1)$

注意，$\varphi$ 函数不是完全积性函数，互质才能乘起来哦；不互质的话不能乘起来。

```cpp
#include<iostream>
#include<cstdio>
#include<map>
using namespace std; 
typedef long long ll;
ll tree[2000000];
ll n,m,p,prime[5000001],cnt,phi[20000001];
bool bj[20000001];
inline ll read(){//快读
	ll x=0,f=1;char ch=getchar();
	while(ch>'9'||ch<'0'){
		if(ch=='-')f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9'){
    	x=x*10+ch-'0';
    	ch=getchar();
    }
    return x*f;
}
void eular()
{//线性筛欧拉函数 
	phi[1]=1;bj[1]=1;//特殊处理1的情况 
	for(register ll i=2;i<=20000000;i++)
	{
		if(!bj[i])//之前没被筛掉说明是指数 
		{
			prime[++cnt]=i;
			phi[i]=i-1;//质数和前面所有数互质，欧拉函数值位i-1
		}
		for(ll j=1;j<=cnt&&prime[j]*i<=20000000;j++)
		{//尝试用 prime[j]*i 去筛掉其他的数字 
			bj[prime[j]*i]=1;//是合数，标记上 
			if(i%prime[j]==0)//欧拉筛的核心思想：让一个数字只被它的最小质因子筛一次 
			{//prime是由小到大的，如果j不是i的最小质因子，那么i应该会在之前就break了 
			//之后就不用再拿i去筛了，因为下次筛到的数的最小质因子一定是i的最小质因子 
				phi[i*prime[j]]=phi[i]*prime[j];
				break;//欧拉函数的通项公式，注意这里不是积性函数部分，i已经包含prime[j],i*prime[j]的phi就是比i的prime[j]倍 
			}
			phi[i*prime[j]]=phi[i]*phi[prime[j]];//i,prime[j]互质，利用phi的积性乘起来就好了 
	    }
	}
}//区间加、查询单点，使用简短的树状数组维护
ll lowbit(ll x){return (x&(-x));
void updata(ll x,ll cost){
	while(x<=n){
		tree[x]+=cost;
		x+=lowbit(x);
	}//把x位加上cost
}
ll query(ll x){//查询tree数组的前缀和1-x
	ll ans=0;
	while(x>0){
		ans+=tree[x];
		x-=lowbit(x);
    }
    return ans;
}
ll fastpow(ll di,ll zhi,ll p)
{
	ll flag=0,yu=1;
    if(di>=p)flag=1,di%=p;//小心，去掉这句60分，否则如果有0次方的情况就去世了 
    //数据本身不会出现0次方的情况，但是别忘了我们的fastpow是取过模的，谁知道会不会有0 
	while(zhi>0)
	{
		if(zhi%2==1)yu=yu*di;
		di=di*di;//这里和普通的快速幂不同 ，先不要对di和yu取模，
        //因为扩展欧拉定理的使用需要指数大于模数的欧拉函数值，而在我们递归调用solve的时候
        //fastpow()就是上一层solve的指数！（它的p是上一层的欧拉函数值）所以要判断是否能达到p。 
		if(yu>=p)flag=1,yu%=p;//如果达到了p就标记
		if(di>=p)flag=1,di%=p;
		zhi=zhi/2;
	}
	if(flag)yu+=p;//如果到达p，根据扩展欧拉定理加上p 
	return yu;
}
//看似是最坏O（n）的dfs，其实最多执行log层
//对一个数字不停求欧拉函数，求logn次就会变成1
//例如phi(100)->phi(40)->phi(16)->phi(8)->phi(4)-phi>(2)->1
//因为gcd(i,n)=gcd(n-i,n),任意n>2,phi(n)为偶数 
//偶数一定含有素因子2，根据欧拉函数通项公式，可以发现每次求欧拉函数都是至少折半的
//扩展欧拉定理，不知道的建议取做 欧拉定理 那个题目 
ll Query(ll l,ll r,ll p)
{//做这个题目还可以顺手切了Power Tower，把树状数组改成正常数组就好了 
	ll now=query(l);
	if(l==r||p==1)return now>=p?now%p+p:now;//注意边界有两个：p已经降到了1或者序列已经取完，还是判断w[l]和p的大小关系 
	return fastpow(now,Query(l+1,r,phi[p]),p); //递归调用solve，注意不要取余数，这可能会导致fastpow里最后加上的p白加了 
}
int main()
{
	eular();
    n=read();m=read();
    for(ll i=1;i<=n;i++)
    {
    	ll x=read();
    	updata(i,x);//维护差分原数组的差分,修改一个区间值只会影响l、r+1的差分值
        //这样query求出的tree的前缀和就是单点值，实现了区间加、求单点 
    	updata(i+1,-x);
    }
    for(ll i=1;i<=m;i++)
    {
    	ll opt,x,y,z;
        opt=read();x=read();y=read();z=read();
        if(opt==1)
        {
        	updata(x,z);//维护差分序列 
        	updata(y+1,-z);
        }
        else printf("%lld\n",Query(x,y,z)%z);//注意这里还要%p，因为fastpow()最后一次执行的时候可能加上了P，而solve里是不能取余数的 
    }
	return 0;
}

```

---

## 作者：BFqwq (赞：4)

# Nephren Ruq Insania（[Ynoi2016]JabberWocky）

Ynoi居然有奈芙莲的题好开心啊qaqqaqqaq

前置芝士：树状数组（线段树），拓展欧拉定理。

另外几篇题解都把拓欧写的很清楚了，这儿我就不再解释了。

如果不会的话建议做一做[这道题](https://www.luogu.com.cn/problem/P4139)（可以顺手A了[这题](https://www.luogu.com.cn/problem/P3747)）。

拓欧公式：

$$ a^b≡a^{b \mod φ(p)+b>=p?φ(p):0}$$

由于有拓欧，所以在查询时我们并不需要取到序列的结束，只要 $φ(p)=1$ 时我们就可以直接返回。

然后可以证明欧拉函数最多套 $\log p$ 层，模数就会变成 $1$（前面鱼鱼证过了，这里我就不证明了）。

然后就可以用一个循环，当 $φ(p)=1$ 时跳出循环，然后往回求值。

维护欧拉函数的代码如下（$lxl$ 是模数，$qwq_i$ 是该位置的模数）
```cpp
while(1){
		nw=find(i);
		qwq[i]=lxl;
		if(lxl==1){
			nw=0,k=1;break;
		}
		lxl=phi[lxl];
		i++;
    }
```
但其实如果查询区间较短，我们就没有必要取到底，要是区间结束了就直接返回。

另外，如果其中某一项的原来的值为 $1$ ，我们也可以直接返回，因为 $1$ 的任意次方都是 $1$。

```cpp
while(1){
		nw=find(i);
		qwq[i]=lxl;
		if(lxl==1){
			nw=0,k=1;break;
		}
		if(nw==1){
			k=0;
			break;
		}
    	if(i==r){
    		if(nw<lxl) break;
    		nw=nw%lxl;k=1;
    		break;
		}
		lxl=phi[lxl];
		i++;
    }
```
这儿 $k$ 对应的是公式中的 $b>φ(p)$ 是否成立，因为如果成立那么我们需要加上一个 $φ(p)$。

然后往回循环套公式求值：

```cpp
i--;
    for(;i>=l;i--){
		nw=fp(find(i),nw+k*phi[qwq[i]],qwq[i]);
		k=flag;
	}
    return nw;
```
其中，此处的快速幂略有改动，我们多了一个 $flag$ 变量记录其值是否大于模数。

```cpp
inline int fp(int a,int x,int lxl){
    int res=1;
    flag=0;
    while(x){
        if(x&1)res=res*a;
		a=a*a;
        if(res>lxl) flag=1,res%=lxl;
        if(a>lxl) flag=1,a%=lxl;
        x>>=1;
    }
    return res;
}
```
至于区间加就用树状数组维护一下就好了。

此处的复杂度理论上界应该是 $\operatorname{O}(nlog n+n\log p\log n)$

但实际上这个界限非常宽松。

```cpp
#include <bits/stdc++.h>
#define int __int128
using namespace std; 
inline int read(){
	register int x=0;
	register bool f=0;
	register char c=getchar();
	while(c<'0'||c>'9'){
		if(c=='-') f=1;
		c=getchar();
	}
	while(c>='0'&&c<='9'){
		x=(x<<3)+(x<<1)+c-48;
		c=getchar();
	}
	return f?-x:x;
}
void write(long long x){
    if(x<0) putchar('-'), x=-x;
    if(x>=10) write(x/10);
    putchar('0'+x%10);
}
const int maxn=501000;
const int maxm=20000000;
int n,m;
int a[maxn],t[maxn];
bool flag;
inline int lb(int x){
	return x&-x;
}
void add(int x,int y){
	if(!x) return;
	for(int i=x;i<=n;i+=lb(i)) t[i]+=y;
}
void change(int l,int r,int y){
	add(l,y);add(r+1,-y);
}
int find(int x){
    int res=0;
    for(int i=x;i;i-=lb(i))
        res+=t[i];
    return a[x]=res;
}
inline int fp(int a,int x,int lxl){
    int res=1;
    flag=0;
    while(x){
        if(x&1)res=res*a;
		a=a*a;
        if(res>lxl) flag=1,res%=lxl;
        if(a>lxl) flag=1,a%=lxl;
        x>>=1;
    }
    return res;
}
int phi[maxm+10],pri[maxm/2+10],tot,ans,qwq[maxn];  
bool vis[maxm+10];  
void getphi(){  
	phi[1]=1;  
	for(int i=2;i<=maxm;i++){  
    	if(!vis[i]) {  
            pri[++tot]=i;
            phi[i]=i-1;
        }  
    	for(int j=1;j<=tot;j++) {  
        	if(i*pri[j]>maxm) break;  
        	vis[i*pri[j]]=1;
        	if(i%pri[j]==0){  
            	phi[i*pri[j]]=phi[i]*pri[j];break;  
        	}  
        	else  phi[i*pri[j]]=phi[i]*(pri[j]-1);
    	}  
	}  
} 
int query(int l,int r,int lxl){
	int i=l,nw=find(l),k=0;
	if(lxl==1){
		return 0;
	}
	if(nw==1) return 1;
   	if(l==r){
    		return nw%lxl;
		}
    	while(1){
		nw=find(i);
		qwq[i]=lxl;
		if(lxl==1){
			nw=0,k=1;break;
		}
		if(nw==1){
			k=0;
			break;
		}
    	if(i==r){
    		if(nw<lxl) break;
    		nw=nw%lxl;k=1;
    		break;
		}
		lxl=phi[lxl];
		i++;
    }
    i--;
    for(;i>=l;i--){
nw=fp(find(i),nw+k*phi[qwq[i]],qwq[i]);
		k=flag;
	}
    return nw;
}
signed main(){
	getphi();
    n=read();m=read();
    for(int i=1;i<=n;i++){
        int x=read();
        change(i,i,x);
    }
    while(m--){
        int opt=read(),x=read(),y=read(),z=read();
        if(opt==1){
            change(x,y,z);
        }
        else{
            printf("%lld\n",query(x,y,z)%z);
        }
    }
    return 0;
}
```
表示看不懂zcy哥哥的解法，然后看了下lxl的代码发现他们两个根本没区别qaq

好像鱼鱼的做法跟我很像qaq
















---

## 作者：VenusM1nT (赞：3)

扩展欧拉定理。

本文同步发表于笔者的博客：[题解 P3934 Nephren Ruq Insania](https://venusnero.github.io/2019/03/05/solution_p3934/)

好毒瘤的题……之前有一道 `CF906D Power Tower` 有一种神奇的写法，为了满足扩展欧拉定理中 $b≥\varphi(p)$ 的限制，可以在进行 $\%$ 运算的时候加上一个 $p$，因为 $p>\varphi(p)$，所以就可以不用管限制，最后只要把多出的 $\%$ 掉就行了，但是这道题并不刑【哭】，写法不好就会爆精度，所以我们要考虑别的写法。

首先，我们在做那道题的时候可以使用递归的写法，但是看看这道题的出题人，emmm于是我们应该使用线性的写法，也就是可以预处理出每一次 $\%$ 的 $\varphi(p)$，然后考虑 $b≥\varphi(p)$ 的限制，我们依然是在运算时额外加上一个 $p$，但是和之前的做法不同，之前是任何运算结束后都要进行判断，我们已经知道了这样会爆精度，所以我们考虑在快速幂过程中记录是否要加上 $p$，最后再加上。

至于怎么判断是否要加 $p$，因为只要进行了 $\%$ 运算，$b$ 就有可能会 $<\varphi(p)$，所以我们就记录有没有进行 $\%$ 运算即可。

```cpp
#include<bits/stdc++.h>
#define MAXN 20000000
#define int long long
#define getchar() (p1==p2 && (p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
char buf[1<<21],*p1=buf,*p2=buf;
using namespace std;
int n,m,c[MAXN+5],pri[MAXN+5],tot,phi[MAXN+5],ha[MAXN+5];
bool isp[MAXN+5];
template <typename T> void Read(T &x)
{
	x=0;
	int fu=1;
	char ch=getchar();
	for(;!isdigit(ch);ch=getchar()) if(ch=='-') fu=-1;
	for(;isdigit(ch);ch=getchar()) x=(x<<3)+(x<<1)+(ch-48);
	x*=fu;
}
void GetPrime()
{
	phi[1]=1;
	isp[1]=1;
	for(int i=2;i<=MAXN;i++)
	{
		if(!isp[i])
		{
			pri[++tot]=i;
			phi[i]=i-1;
		}
		for(int j=1;j<=tot && i*pri[j]<=MAXN;j++)
		{
			isp[i*pri[j]]=1;
			if(i%pri[j]) phi[i*pri[j]]=phi[i]*(pri[j]-1);
			else
			{
				phi[i*pri[j]]=phi[i]*pri[j];
				break;
			}
		}
	}
}
int lowbit(int x)
{
	return x&-x;
}
void Modify(int x,int val)
{
	while(x<=n)
	{
		c[x]+=val;
		x+=lowbit(x);
	}
}
int Query(int x)
{
	int res=0;
	while(x)
	{
		res+=c[x];
		x-=lowbit(x);
	}
	return res;
}
void Mod(int &x,int p,bool &fg)
{
	if(x>=p)
	{
		x%=p;
		fg=1;
	}
}
int QuickPow(int x,int y,int p)
{
	int res=1;
	bool fg=0;
	Mod(x,p,fg);
	while(y)
	{
		if(y&1)
		{
			res=res*x;
			Mod(res,p,fg);
		}
		x=x*x;
		Mod(x,p,fg);
		y>>=1;
	}
	return res+fg*p;
}
signed main()
{
	//freopen("data.in","r",stdin);
	//freopen("outp.out","w",stdout);
	GetPrime();
	int pre=0;
	Read(n);
	Read(m);
	for(int i=1;i<=n;i++)
	{
		int x;
		Read(x);
		Modify(i,x-pre);
		pre=x;
	}
	while(m--)
	{
		int opt,x,y,z;
		Read(opt);
		Read(x);
		Read(y);
		Read(z);
		if(opt==1)
		{
			Modify(x,z);
			Modify(y+1,-z);
		}
		else
		{
			int pos=x;
			ha[pos]=z;
			z=phi[z];
			while(z>1 && pos<y)
			{
				ha[++pos]=z;
				z=phi[z];
			}
			int res=1;
			for(;pos>=x;pos--) res=QuickPow(Query(pos),res,ha[pos]);
			printf("%lld\n",res%ha[x]);
		}
	}
	return 0;
}
```

（既然是 ynoi 的题解，在结尾给一张 Nephren 的图吧qwq）

![](https://z4请更换图床a.net/images/2019/03/05/64050525_p0.png)

---

## 作者：Mobius127 (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P3934)

已经能过 [hack](https://www.luogu.com.cn/discuss/478539)，原因：做快速幂的时候需要微判一下边界。~~很好奇 lxl 为什么不卡~~

显然区间加可用线段树做。

然后操作二用扩展欧拉定理，每个 $p$ 最多递归 $\log$ 层，类似于 [这道题](https://www.luogu.com.cn/problem/P3747)。

$a^b≡a^{b\mod \varphi(p)+\varphi(p)×[b≥ϕ(p)]} (\text{mod}\ \ p)$

问题来了，扩欧有两种情况，我们如何判断？

这个简单，暴力跑一遍会不会超出即可。

然后发现这里只需单点查询，把线段树换成常数更小的树状数组。

现在我们考虑一波边界问题：

1. 当 $\text{mod}$ 为 $1$ 时，此时不管是什么数都是 $0$；

1. 底数 $\text{a}$ 为 $1$ 时，不管多少幂都是 $1$；

1. 递归到底时再判断是否需要加上 $\varphi(p)$ 即可。

1. 多取点模，这题不卡常！！1

这样就可以愉快地写代码去啦~。

### Code:

```cpp
#include <stdio.h>
#include <algorithm>
#include <string.h>
#include <bitset>
#define int long long
using namespace std;
inline int read(){
    char ch=getchar();int x=0, f=1;
    while(ch<'0'||ch>'9'){if(ch=='-') f=-1; ch=getchar();}
    while(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+ch-'0';ch=getchar();}
    return x*f;
}
const int INF=0x3f3f3f3f;
const int N=(int)(500005);
const int M=(int)(20000005);
struct BIT{
    #define lowbit(x) (x&(-x))
    int sum[N];
    void add(int x, int y){if(!y) return ;for(; x<N; x+=lowbit(x)) sum[x]+=y;}
    int query(int x){int ret=0;for(; x>0; x-=lowbit(x)) ret+=sum[x];return ret;}
}bit;
struct node{int v;bool flg;};
node ksm(int a, int b, int mo){
    node ret=(node){1, 0};
    int tmp=a%mo;if(a>=mo) ret.flg=true, ret.v%=mo;
    while(b){
        if(b&1) ret.v*=tmp;
        if(ret.v>=mo) ret.flg=true, ret.v%=mo;
        tmp*=tmp;
        if((b/2)&&tmp>=mo) ret.flg=1, tmp%=mo;
        b>>=1;
    }
    return ret;
}
int n, m, phi[M], st[M], tot, a[N];
bitset <M> u;
void pre(int lim=20000000){
    phi[1]=1;
    for(int i=2; i<=lim; i++){
        if(!u[i]) st[++tot]=i, phi[i]=i-1;
        for(int j=1; j<=tot&&i*st[j]<=lim; j++){
            u[i*st[j]]=1;
            if(i%st[j]==0){phi[i*st[j]]=phi[i]*st[j];break;}
            phi[i*st[j]]=phi[i]*(st[j]-1);
        }
    }
}
node solve(int l, int r, int p){
    int tmp=bit.query(l);//printf("--%d %d %lld %lld\n", l, r, tmp, p);
    if(p==1) return (node){0, 1}; 
    if(l==r) return tmp>=p?(node){tmp%p, 1}:(node){tmp, 0};
    if(tmp==1) return (node){1, 0};
    node mi=solve(l+1, r, phi[p]);
    if(mi.flg) mi.v+=phi[p];
    return ksm(tmp, mi.v, p);
}
signed main(){
    n=read(), m=read(), pre();
    for(int i=1; i<=n; i++)
        a[i]=read(), bit.add(i, a[i]-a[i-1]);
    for(int i=1; i<=m; i++){
        int opt=read(), l=read(), r=read();
        int p=read();
        if(opt&1) bit.add(l, p), bit.add(r+1, -p);
        else printf("%lld\n", (solve(l, r, p).v%p+p)%p);
    }
    return 0;
}

```


---

## 作者：gxy001 (赞：1)

UPD：被叉了，已修改。

### 操作1：区间加
 
这不是一个树状数组的事吗，区间加，单点查询 ~~，线段树是什么，树状数组是真的好写还不卡常~~。什么，你不会，这边请。--->[传送门](https://www.luogu.com.cn/problem/P3368)

### 操作2：询问

给定 $l,r,p$ 查询：

$$a_{l}^{a_{l+1}^{\cdots^{a_r}}} \operatorname{mod} p$$

考虑欧拉定理降幂，我们会发现 $\gcd(a_l,p)\ne 1$。

所以我们考虑用扩展欧拉定理：---> [传送门](https://www.luogu.com.cn/problem/P5091)

$$a^b\equiv\begin{cases}a^{b\operatorname{mod}\varphi(p)}&b<\varphi(p)\\a^{b\operatorname{mod}\varphi(p)+\varphi(p)}&b\ge\varphi(p)\end{cases}(\operatorname{mod}p)$$

由于本题不是模板，证明就不放了。

那么显然，本题就变成了递归的过程，在递归时要注意边界的判断：

- $l=r$ 时返回该位上的值；
- $p=1$ 时返回 $0$。

我们会注意到我们不能知道我们的指数是否取过模，所以考虑用结构体存储。

### 时间复杂度

$\mathrm {O(m\log^2p)}$，认为 $\mathrm{O(\log p),O(\log n),O(\log a_i)}$ 同级。

每次询问时的递归，$\varphi(p)$ 只需要递归 $\log p$ 次就会变成 $1$，而每次递归时需要树状数组单点查询$\mathrm{O(\log n)}$，快速幂$\mathrm{O(\log a_i)}$

### 代码

大体思路就这些，接下来就是实现了：

```cpp
#include<cstdio>
int n,m;
long long c[500010];
void update(int i,int const &x){
	for(;i<=n;i+=(i&-i))c[i]+=x;
}
long long query(int i,long long res=0){
	for(;i;i-=(i&-i))res+=c[i];
	return res;
}
struct node{
	long long v;
	bool a;
	node(long long const &_v,bool const &_a):v(_v),a(_a){}
};
node pow(long long x,long long y,int const &p){
	node res(1,false);
	if(x>=p) x%=p,res.a=true;
	while(y){
		if(y&1){
			res.v*=x;
			if(res.v>=p){
				res.a=true;
				res.v%=p;
			}
		}
		if(y>>=1){
			x=x*x;
			if(x>=p){
				res.a=true;
				x%=p;
			}
		}
	}
	return res;
}
int phi[20000005],p[1271000],cnt;
char np[20000005];
node query(int const &l,int const &r,int const &p){
	if(p==1) return node(0ll,true);
	long long t=query(l);
	if(t==1) return node(1ll,false);
	if(l==r){
		if(t>=p) return node(t%p,true);
		else return node(t,false);
	}
	node k=query(l+1,r,phi[p]);
	if(k.a) k.v+=phi[p];
	return pow(t,k.v,p);
}
int main(){
	phi[1]=1;
	for(int i=2;i<=20000000;i++){
		if(!np[i]) p[++cnt]=i,phi[i]=i-1;
		for(int j=1;j<=cnt&&i*p[j]<=20000000;j++){
			np[i*p[j]]=1;
			if(i%p[j]==0){
				phi[i*p[j]]=phi[i]*p[j];
				break;
			}
			phi[i*p[j]]=phi[i]*(p[j]-1);
		}
	}
	scanf("%d%d",&n,&m);
	for(int i=1,k=0,x;i<=n;i++){
		scanf("%d",&x);
		update(i,x-k);
		k=x;
	}
	while(m--){
		int op,l,r,x;
		scanf("%d%d%d%d",&op,&l,&r,&x);
		if(op==1){
			update(l,x);
			update(r+1,-x);
		}else{
			printf("%lld\n",query(l,r,x).v);
		}
	}
	return 0;
}
```

---

## 作者：Ame__ (赞：1)

考试考了这个题，出题人很良心没卡常给了$9s$~~但是本地测评空间炸了愉快的爆0~~，考场上脑子抽了死活觉得线段树维护区间求和行不通（，第一道自己做出来的$Ynoi$，纪念一下

### 题目描述

维护一段区间，支持区间加，并求出一段区间的

$$a_{l}^{a_{l+1}^{a_{l+2}^{....a_{r}}}} \pmod p$$

### 解题思路

对于区间加，直接上线段树就可以，但是对于第二个操作求

$$a_{l}^{a_{l+1}^{a_{l+2}^{....a_{r}}}}$$

这东西貌似很抽象？而且指数部分还不能直接用欧拉定理模$\varphi(p)$，因为指数上也是个递归的过程。

如果你做过[P4139 上帝与集合的正确用法](https://www.luogu.com.cn/problem/P4139)你就会觉得这柿子很眼熟，对的我们可以用拓展欧拉定理求啊

对于任意的正整数$a$和$p$，且$b\ge\varphi(p)$，有：

$$
a^b\equiv
a^{b\bmod\varphi(p)+\varphi(p)}
\pmod p
$$

而对于询问区间$[l,r] \pmod p$，我们设其询问结果记作$s(l,r,p)$，我们可以推出：

$s(l,r,p)=a_{l}^{s(l+1,r,p)\bmod\varphi(p)+\varphi(p)}\pmod p=a_{l}^{a_{l+1}^{s(l+2,r,p)\bmod\varphi(p)+\varphi(p)}}\pmod p=k$

假设上式中出现的模$p$意义下的指数都大于等于$\varphi(p)$

将$p$不断地变成$\varphi(p)$需要$O(log)$次之后$p$变成$1$。而指数为1可以直接计算。对于询问$s(l,r,p)$可以递归做：

$(1)$如果$l=r$或者$p=1$则直接反回$a_{l}$。

$(2)$否则递归到$s(l+1,r,\varphi(p))$，记其为$tmp$。如果$tmp\ge\varphi(p)$则返回 ，否则反回 

那么我们现在的问题在于如何判断指数是否大于$\varphi(p)$

对于$2^{2^{2^{2^2}}}\ge 2 \times 10^7$

所以，我们只需要取出$[l+1,r]$的前$5$个数，（如果$[l+1,r]$的区间长度不足$5$则取区间$[l+1,r]$内所有数，如果$[l+1,r]$内第一个$1$出现的位置为$x$则取$[l+1,x-1]$内所有数）

如果取出的数的个数为$5$则一定大于$\varphi(p)$。或者在前五个数内找到为$1$的，否则可以记录并直接往前暴力算然后判断即可

时间复杂度为$O(p+nlognlogp)$

最后注意大力卡常即可~~或者写常数更小的树状数组~~

```cpp
#include<bits/stdc++.h>
    
#define LL long long
    
#define _ 0
    
#define R register

// #define AME__DEBUG
    
using namespace std;
    
// #define AME__

/*Grievous Lady*/
    
const int BUF_SIZE = 1 << 12;
    
char buf[BUF_SIZE] , *buf_s = buf , *buf_t = buf + 1;
    
#define PTR_NEXT() \
{ \
    buf_s ++; \
    if(buf_s == buf_t) \
    { \
        buf_s = buf; \
        buf_t = buf + fread(buf , 1 , BUF_SIZE , stdin); \
    } \
}
    
template <typename _m_> inline void mian(_m_ & _n_){
    LL _x_ = 0 , _nega_ = 0;
    while(*buf_s != '-' && !isdigit(*buf_s)) PTR_NEXT(); if(*buf_s == '-'){_nega_ = 1; PTR_NEXT();}
    while(isdigit(*buf_s)){_x_ = _x_ * 10 + *buf_s - '0'; PTR_NEXT();} if(_nega_) _x_ = -_x_; (_n_) = (_x_);
}

#define int long long

template <typename _n_> bool cmax(_n_ &a , const _n_ &b){ return a < b ? a = b , 1 : 0; }
    
template <typename _n_> bool cmin(_n_ &a , const _n_ &b){ return a > b ? a = b , 1 : 0; }

const int kato = 2e7 + 10;

const int atri = 2e7;

inline int quick_pow(int a , LL b , int mod){
    int res = 1;
    for(; b ; b >>= 1 , a = 1LL * a * a % mod){
        if(b & 1){
            res = 1LL * res * a % mod;
        }
    }
    return res;
}

LL n , m , cnt , opt , l , r , p , las[kato] , a[kato] , phi[kato] , prime[kato];

bool ispri[kato];

struct tree{
    protected:

        struct node{
            node *ch[2];
            int l , r;
            LL sum , tag;
            node(int l = 0 , int r = 0 , LL sum = 0 , LL tag = 0): l(l) , r(r) , sum(sum) , tag(tag){
                ch[0] = ch[1] = NULL;
            }
            inline int mid(){
                return (l + r) >> 1;
            }
            inline void up(){
                sum = ch[0] -> sum + ch[1] -> sum;
            }
            inline void add_val(LL v){
                tag += v , sum += 1LL * (r - l + 1) * v;
            }
            inline void down(){
                if(tag){
                    ch[0] -> add_val(tag) , ch[1] -> add_val(tag) , tag = 0;
                }
            }
        }*root;

        inline void build(node *&o , int l , int r){
            o = new node(l , r);
            if(l == r){
                mian(a[l]);
                o -> sum = a[l];
                return;
            }
            build(o -> ch[0] , l , o -> mid()); build(o -> ch[1] , o -> mid() + 1 , r);
            o -> up();
        }

        inline void Modify(node *o , int l , int r , int val){
            if(l <= o -> l && o -> r <= r){
                o -> add_val(val);
                return;
            }
            o -> down();
            if(l <= o -> mid()){
                Modify(o -> ch[0] , l , r , val);
            }
            if(r > o -> mid()){
                Modify(o -> ch[1] , l , r , val);
            }
            o -> up();
        }

        inline LL ask(node *o , int x){
            if(o -> l == o -> r){
                return o -> sum;
            }
            o -> down();
            if(x <= o -> mid()){
                return ask(o -> ch[0] , x);
            }
            if(x > o -> mid()){
                return ask(o -> ch[1] , x);
            }
        }

    public:

        inline void build(int n){
            build(root , 1 , n);
        }

        inline void Modify(LL l , LL r , LL val){
            Modify(root , l , r , val);
        }

        inline LL ask(int x){
            if(las[x] == m) return a[x];
            las[x] = m;
            return a[x] = ask(root , x);
        }
}yuni;

inline int phi_(int l , int r , int mod){
    if(yuni.ask(l) % mod == 0) return 0;
    if(mod == 1) return 1;
    if(l == r) return yuni.ask(l) % mod + (yuni.ask(l) >= mod) * mod;
    int pos = min(l + 5 , r);
    for(int i = l + 1;i <= pos;i ++){ 
        if(yuni.ask(i) == 1){
            pos = i; break;
        }
    }
    LL g = 0 , last = yuni.ask(pos);
    for(int i = pos - 1 ; i >= l + 1 ; i --){
        g = last , last = 1;
        for(; g --> 0 ;){
            last *= yuni.ask(i);
            if(last > phi[mod]) return quick_pow(yuni.ask(l) % mod , phi_(l + 1 , r , phi[mod]) + phi[mod] , mod);
        }
    }
    return quick_pow(yuni.ask(l) % mod , last , mod);
}

inline void pri(){
    for(R int i = 2;i <= atri;i ++){
        if(!ispri[i]){
            prime[++ cnt] = i;
            phi[i] = i - 1;
        }
        for(R int j = 1;j <= cnt && i * prime[j] <= atri;j ++){
            ispri[i * prime[j]] = 1;
            if(i % prime[j] == 0){
                phi[i * prime[j]] = phi[i] * prime[j];
                break;
            }
            phi[i * prime[j]] = phi[i] * (prime[j] - 1);
        }
    }
}

inline int Ame_(){
#ifdef AME__
    freopen(".in" , "r" , stdin); freopen(".out" , "w" , stdout);
#endif
    mian(n) , mian(m); memset(las , -1 , sizeof(las));
    pri();
    yuni.build(n);
    for(; m --> 0 ;){
        mian(opt) , mian(l) , mian(r) , mian(p);
        if(opt == 1) yuni.Modify(l , r , p);
        if(opt == 2) printf("%lld\n" , (phi_(l , r , p)) % p);
    }
    // fclose(stdin); fclose(stdout);
    return ~~(0^_^0);
}
    
int Ame__ = Ame_();
    
signed main(){;}
```


---

## 作者：ricky0916 (赞：0)

~~某一天我写了个题解然后不小心删掉了，默哀~~

首先看到区间修改就想到树状数组（线段树）

然后我们看到所求为$ a_i^{a_{i+1}^{a_{i+2}^{{......}^{a_r}}}} $

我们会发现有个定理（扩展欧拉定理）：

$$
a^b\equiv a^{b\bmod \phi(p)+\phi(p)\times[b\ge \phi(p)]}\pmod p
$$

好，现在我们可以递归解决，只需要判断上面那一堆东西是不是大于$\phi(p)$就行了。

~~此处引用某巨佬的做法：~~

考虑到$ \phi(p)<\phi(20000000)<2^{2^{2^{2^2}}}=2^{65536} $

那么我们可以暴力算$\min(5,r-l,x)$层，其中$x$指的是$[l, \max(l+5,r) ]$之间出现的第一个1的位置，没有就忽略。结果$ \ge \phi(p) $则继续递归，否则直接快速幂。

记得预处理$ \phi(p) $。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
long long c[500010];
int n,m,phi[20000010],prime[2000010],tot;
bool check[20000010];
void init(){
	phi[1]=1;
	for(int i=2;i<=20000000;i++){
		if(!check[i]){
			prime[tot++]=i;
			phi[i]=i-1;
		}
		for(int j=0;j<tot&&i*prime[j]<=20000000;j++){
			check[i*prime[j]]=1;
			if(i%prime[j]==0){
				phi[i*prime[j]]=phi[i]*prime[j];
				break;
			}
			phi[i*prime[j]]=phi[i]*(prime[j]-1);
		}
	}
}
inline int mn(int x,int y){
	return x<y?x:y;
}
void add(int x,long long v){
	for(;x<=n;x+=x&(-x)) c[x]+=v;
}
long long sum(int x){
	long long ret=0;
	for(;x>0;x-=x&(-x)) ret+=c[x];
	return ret;
}
inline int ksm(int x,long long y,int p){
	int ret=1;
	while(y){
		if(y&1) ret=1ll*ret*x%p;
		y>>=1;
		x=1ll*x*x%p;
	}
	return ret;
}
int query(int l,int r,int p){
	long long tmp=sum(l);
	if(tmp%p==0) return 0;
	if(p==1) return 1;
	if(l==r) return tmp%p+(tmp>=p)*p;
	int f=mn(r,l+5);
	for(int i=l+1;i<=f;i++){
		if(sum(i)==1){
			f=i;
			r=i;
			break;
		}
	}
	long long las=sum(f),q=0;
	for(int i=f-1;i>=l+1;i--){
		q=las;
		las=1;
		long long tp=sum(i);
		while(q--){
			las*=tp;
			if(las>=phi[p]){
				return ksm(tmp%p,query(l+1,r,phi[p])+phi[p],p);
			}
		}
	}
	return ksm(tmp%p,las,p);
}
inline int read(){
	int x=0;
	char ch=getchar();
	while(ch<'0'||ch>'9') ch=getchar();
	while(ch>='0'&&ch<='9'){
		x=(x<<3)+(x<<1)+ch-'0';
		ch=getchar();
	}
	return x;
}
int opt,l,r,x,p;
void write(long long x){
	if(x<0){
		putchar('-');
		write(-x);
	}
	if(x/10) write(x/10);
	putchar(x%10+'0');
}
void we(long long x){
	write(x);
	putchar('\n');
}
int main(){
	init();
	n=read();
	m=read();
	for(int i=1;i<=n;i++){
		x=read();
		add(i,x);
		add(i+1,-x);
	}
	while(m--){
		opt=read();
		l=read();
		r=read();
		if(opt==1){
			x=read();
			add(l,x);
			add(r+1,-x);
		}
		else{
			p=read();
			we(query(l,r,p)%p);
		}
	}
	return 0;
}
```


---

## 作者：Sol1 (赞：0)

简单数论题。写个题解纪念我第 $3$ 个脱离题解过掉的 Ynoi（

由于我们有扩展欧拉定理：

$$x^y\equiv\begin{cases}x^y, y<p\\ x^{y\bmod \varphi(p)+\varphi(p)}, y\geq p\end{cases}\pmod p$$

同时，又有不等式：

$$\varphi(2x)\leq x$$

所以对于一个值 $v$，取 $2\log v$ 次 $\varphi$ 之后就会变成 $1$。

所以每一次查询实际上只有 $O(\log p)$ 个值是有用的。

然后为了解决掉指数上是否加 $\varphi(p)$ 的问题，可以在递归进行计算的时候保存 $2$ 个结果，分别是模 $p$ 意义下的答案，以及答案是否大于等于 $p$。在快速幂的时候，如果底数大于等于 $p$，或者在任意一次乘法中答案大于等于 $p$（注意这里包含底数的自乘，因为只要进行自乘，一定会有一个大于等于本身的值被乘进答案），则答案一定大于等于 $p$。这个结论由计算过程中变量的真实值（不取模的值）的单调性是显然的。

递归边界有 $3$ 个：$a=1$，$p=1$，$l>r$。每一个对应的返回值分别是 $(1,0)$，$(0,1)$，$(1,0)$。

由于我们每一次递归计算只需要取出一个值，所以问题退化为区间加单点求值，搞个树状数组直接维护就行了。

最终总时间 $O(p+m\log p\log n)$，空间 $O(n+p)$。

由于这两个 $\log$ 都基本上没常数，所以还是能轻松跑过去的。实测最大点略小于 1s。

```cpp
#include <iostream>
#include <cmath>
#include <cstring>
#include <cstdio>
using namespace std;

#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
char buf[1 << 21], *p1 = buf, *p2 = buf;

inline int qread() {
	register char c = getchar();
	register int x = 0, f = 1;
	while (c < '0' || c > '9') {
		if (c == '-') f = -1;
		c = getchar();
	}
	while (c >= '0' && c <= '9') {
		x = (x << 3) + (x << 1) + c - 48;
		c = getchar();
	}
	return x * f;
}

inline int Abs(const int& x) {return (x > 0 ? x : -x);}
inline int Max(const int& x, const int& y) {return (x > y ? x : y);}
inline int Min(const int& x, const int& y) {return (x < y ? x : y);}

int n, m;
long long a[500005], c[500005];
int phi[20000005], p[2000005], pcnt;
bool flag[20000005];

inline void Sieve() {
	flag[1] = 1;
	for (int i = 2;i <= 20000000;i++) {
		if (!flag[i]) {
			phi[i] = i - 1;
			p[++pcnt] = i;
		}
		for (int j = 1;j <= pcnt && i * p[j] <= 20000000;j++) {
			flag[i * p[j]] = 1;
			if (i % p[j] == 0) {
				phi[i * p[j]] = phi[i] * p[j];
				break;
			} else {
				phi[i * p[j]] = phi[i] * phi[p[j]];
			}
		}
	}
}

inline int Lowbit(int x) {
	return x & -x;
}

inline void Update(int i, long long x) {
	for (int j = i;j <= n;j += Lowbit(j)) c[j] += x;
}

inline long long Query(int i) {
	long long ans = 0;
	for (int j = i;j >= 1;j -= Lowbit(j)) ans += c[j];
	return ans;
}

inline void Read() {
	n = qread(); m = qread();
	for (int i = 1;i <= n;i++) a[i] = qread();
}

inline void Prefix() {
	for (int i = 1;i <= n;i++) Update(i, a[i] - a[i - 1]);
}

inline pair <long long, bool> Calc(int l, int r, long long mod) {
	if (l > r) return make_pair(1, 0);
	long long a = Query(l);
	if (mod == 1) return make_pair(0, 1);
	if (a == 1) return make_pair(1, 0);
	pair <long long, bool> res = Calc(l + 1, r, phi[mod]);
	long long b = res.first + 1ll * res.second * phi[mod];
	long long ans = 1;
	bool gtr = 0;
	if (a >= mod) {
		a %= mod;
		gtr = 1;
	}
	while (b) {
		if (b & 1) {
			gtr |= (ans * a >= mod);
			ans = ans * a % mod;
		}
		gtr |= (a * a >= mod);
		a = a * a % mod;
		b >>= 1;
	}
	return make_pair(ans, gtr);
}

inline void Solve() {
	while (m--) {
		int opt = qread();
		if (opt == 1) {
			int l = qread(), r = qread();
			long long x = qread();
			Update(l, x);
			Update(r + 1, -x);
		} else {
			int l = qread(), r = qread(), p = qread();
			printf("%lld\n", Calc(l, r, p));
		}
	}
}

int main() {
	//freopen("P3934_4.in", "r", stdin);
	Read();
	Sieve();
	Prefix();
	Solve();
	#ifndef ONLINE_JUDGE
	while (1);
	#endif
	return 0;
}
```

---


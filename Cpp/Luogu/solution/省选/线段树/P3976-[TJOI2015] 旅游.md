# [TJOI2015] 旅游

## 题目描述

为了提高智商，ZJY 准备去往一个新世界去旅游。这个世界的城市布局像一棵树，每两座城市之间只有一条路径可以互达。  

每座城市都有一种宝石,有一定的价格。ZJY 为了赚取最高利益,她会选择从 A 城市买入再转手卖到 B 城市。  

由于ZJY买宝石时经常卖萌，因而凡是 ZJY 路过的城市，这座城市的宝石价格会上涨。让我们来算算 ZJY 旅游完之后能够赚取的最大利润。(如 A 城市宝石价格为 $v$，则ZJY出售价格也为 $v$)


## 说明/提示

#### 数据规模与约定

- 对于 $30\%$ 的数据，保证 $n \le 100$，$q \le 10^4$。
- 对于 $100\%$ 的数据，保证 $1\le n,q \le 5\times 10^4$，在任何时刻任何城市的宝石价格都不超过 $10^9$。


## 样例 #1

### 输入

```
3
1 2 3
1 2
2 3
2
1 2 100
1 3 100```

### 输出

```
1
1```

## 样例 #2

### 输入

```
5
1 2 3 4 5
1 2
1 3
2 4
4 5
6
1 5 50
2 4 500
3 4 5000
3 5 50000
1 3 500000
2 3 5000000
```

### 输出

```
4
2
551
551
0
499499```

# 题解

## 作者：MeowScore (赞：31)

题面稍绕。给出一棵有点权的树，每次询问一条链，给出起点和终点，要求在这条链上选两个点，答案是第二个点的权值减去第一个点的权值，求这个数的最大值（必须是从起点走到终点途中后经过的减去先经过的），结果为负数输出 $0$。然后再把这条链上所有点权值加一个给定的数。

大力树剖！套线段树！

那么线段树维护点啥呢？最大值？最小值？这两个量感觉还不大够。合并区间信息、计算答案的时候都难以实现。

那维护点啥呢？我是受到了树上最大子段和的启发，以“左”“右”分类维护一些东西，我们把走下来的过程看做起点走到 LCA，然后到终点。考虑到查询的时候可能一条路径上行，一条下行，那就维护**这一段数字从左到右走一遍获得的最大值，以及从右向左走一遍获得的最大值**。这里“从右向左”“从左向右”和题面意义一致，都是后面经过的减前面经过的。对了，还有区间加的标记。

下面是线段树维护的变量以及区间信息合并：

+ `maxx` 和 `minn` 维护最大值、最小值，很好维护。

+ `lmax` 维护线段树一个节点代表的这一段区间上的数字从左到右走获得的最大值。合并：先考虑不跨区间，那就是该节点左右儿子的 `lmax`；跨区间，那就是右儿子的 `maxx` 减去左儿子的 `minn`。三者取最大值。

+ `rmax` 维护线段树一个节点代表的这一段区间上的数字从右到左走获得的最大值。合并：先考虑不跨区间，那就是该节点左右儿子的 `rmax`；跨区间，那就是左儿子的 `maxx` 减去右儿子的 `minn`。三者取最大值。

+ `tag` 维护区间加的标记。

线段树部分就是这样，比较简明~~吧~~。

注意“从左到右”的概念放到树上就是按时间戳从小到大。“从右往左”同理。

接下来是树剖部分。

起点所在的一端、终点所在的一端，分别用 `L`、`R` 两个变量维护**目前已经跳过的部分的信息**。树剖往上跳的时候如果当前跳的是起点一端的链，就把这次查询的结果和 `L` 合并。否则和 `R` 合并。树上合并的规则和线段树子区间信息合并规则是一样的。

`L` `R` 初始化：

```
L.lmax=L.rmax=0;
L.maxx=-INF;
L.minn=INF;
R=L;

```

由于一条“不拐弯的”链上，上面的点的时间戳肯定小于下面的点。所以最终答案：`ans=max(max(L.rmax,R.lmax),R.maxx-L.minn);`

如何理解？从起点出发向上走，那就是逆着时间戳走，也就是“从右向左”。而到了最高处向终点走，是顺着时间戳走的，也就是“从左向右”，虽然我们是从下往上合并信息。

还有点蒙？看看代码吧！


完整代码：

```
#include<bits/stdc++.h>
using namespace std;
const int N=50010;
const int INF=1000000099;
int t[N],a[N];//初始点权和建立在时间戳上的点权
int head[N],to[N*2],nex[N*2],cnt;
void add(int x,int y){
	cnt++;
	to[cnt]=y;
	nex[cnt]=head[x];
	head[x]=cnt;
}
int tot,dfn[N],tp[N],fa[N],sz[N],son[N],dep[N];
void dfs1(int x,int f){
	fa[x]=f;
	dep[x]=dep[f]+1;
	sz[x]=1;
	int maxn=-1;
	for(int i=head[x];i;i=nex[i]){
		int y=to[i];
		if(y==f)
			continue;
		dfs1(y,x);
		sz[x]+=sz[y];
		if(sz[y]>maxn){
			maxn=sz[y];
			son[x]=y;
		}
	}
}
void dfs2(int x,int top){
	tp[x]=top;
	tot++;
	dfn[x]=tot;
	a[tot]=t[x];
	if(son[x])
		dfs2(son[x],top);
	for(int i=head[x];i;i=nex[i]){
		int y=to[i];
		if(y==fa[x]||y==son[x])
			continue;
		dfs2(y,y);
	}
}
struct ST{
	int maxx;
	int minn;
	int lmax;
	int rmax;
	int tag;
}st[N*4];
void build(int root,int l,int r){
	if(l==r){
		st[root].maxx=a[l];
		st[root].minn=a[l];
		return;
	}
	int mid=(l+r)/2;
	build(root*2,l,mid);
	build(root*2+1,mid+1,r);
	st[root].maxx=max(st[root*2].maxx,st[root*2+1].maxx);
	st[root].minn=min(st[root*2].minn,st[root*2+1].minn);
	st[root].lmax=max(max(st[root*2].lmax,st[root*2+1].lmax),st[root*2+1].maxx-st[root*2].minn);
	st[root].rmax=max(max(st[root*2].rmax,st[root*2+1].rmax),st[root*2].maxx-st[root*2+1].minn);
}
void push_down(int root){
	int k=st[root].tag;
	st[root].tag=0;
	st[root*2].maxx+=k;
	st[root*2].minn+=k;
	st[root*2+1].maxx+=k;
	st[root*2+1].minn+=k;
	st[root*2].tag+=k;
	st[root*2+1].tag+=k;
}
void change(int root,int l,int r,int x,int y,int k){
	if(l>=x&&r<=y){
		st[root].maxx+=k;
		st[root].minn+=k;
		st[root].tag+=k;
		return;
	}
	if(st[root].tag!=0&&l!=r)
		push_down(root);
	int mid=(l+r)/2;
	if(mid>=x)
		change(root*2,l,mid,x,y,k);
	if(mid+1<=y)
		change(root*2+1,mid+1,r,x,y,k);
	st[root].maxx=max(st[root*2].maxx,st[root*2+1].maxx);
	st[root].minn=min(st[root*2].minn,st[root*2+1].minn);
	st[root].lmax=max(max(st[root*2].lmax,st[root*2+1].lmax),st[root*2+1].maxx-st[root*2].minn);
	st[root].rmax=max(max(st[root*2].rmax,st[root*2+1].rmax),st[root*2].maxx-st[root*2+1].minn);
}
ST ask(int root,int l,int r,int x,int y){
	if(l>=x&&r<=y)
		return st[root];
	if(st[root].tag!=0&&l!=r)
		push_down(root);
	int mid=(l+r)/2;
	if(mid>=y)
		return ask(root*2,l,mid,x,y);
	else{
		if(mid+1<=x)
			return ask(root*2+1,mid+1,r,x,y);
		else{
			ST L=ask(root*2,l,mid,x,y);
			ST R=ask(root*2+1,mid+1,r,x,y);
			ST res;
			res.maxx=max(L.maxx,R.maxx);
			res.minn=min(L.minn,R.minn);
			res.lmax=max(max(L.lmax,R.lmax),R.maxx-L.minn);
			res.rmax=max(max(L.rmax,R.rmax),L.maxx-R.minn);
			return res;
		}
	}
}
int main(){
	int n;
	cin>>n;
	for(int i=1;i<=n;i++)
		scanf("%d",&t[i]);
	for(int i=1;i<n;i++){
		int x,y;
		scanf("%d%d",&x,&y);
		add(x,y);
		add(y,x);
	}
	dfs1(1,1);
	dfs2(1,1);
	build(1,1,n);
	int m;
	cin>>m;
	for(int i=1;i<=m;i++){
		int x,y,k;
		ST L,R;
		L.lmax=L.rmax=0;
		L.maxx=-INF;
		L.minn=INF;
		R=L;
		scanf("%d%d%d",&x,&y,&k);
		int xx=x;
		int yy=y;
		while(tp[x]!=tp[y]){
			if(dep[tp[x]]<dep[tp[y]]){//跳终点一端的链 
				ST res=ask(1,1,n,dfn[tp[y]],dfn[y]);
				R.lmax=max(max(res.lmax,R.lmax),R.maxx-res.minn);
				R.rmax=max(max(res.rmax,R.rmax),res.maxx-R.minn);
				R.maxx=max(R.maxx,res.maxx);
				R.minn=min(R.minn,res.minn);
				y=fa[tp[y]];
			}
			else{//跳起点一端的链 	
				ST res=ask(1,1,n,dfn[tp[x]],dfn[x]);
				L.lmax=max(max(res.lmax,L.lmax),L.maxx-res.minn);
				L.rmax=max(max(res.rmax,L.rmax),res.maxx-L.minn);
				L.maxx=max(L.maxx,res.maxx);
				L.minn=min(L.minn,res.minn);
				x=fa[tp[x]];
			}
		}
		if(dep[x]<dep[y]){//跳终点一段的链 
			ST res=ask(1,1,n,dfn[x],dfn[y]);
			R.lmax=max(max(res.lmax,R.lmax),R.maxx-res.minn);
			R.rmax=max(max(res.rmax,R.rmax),res.maxx-R.minn);
			R.maxx=max(R.maxx,res.maxx);
			R.minn=min(R.minn,res.minn);
		}
		else{//跳起点一端的链 
			ST res=ask(1,1,n,dfn[y],dfn[x]);
			L.lmax=max(max(res.lmax,L.lmax),L.maxx-res.minn);
			L.rmax=max(max(res.rmax,L.rmax),res.maxx-L.minn);
			L.maxx=max(L.maxx,res.maxx);
			L.minn=min(L.minn,res.minn);
		}
		int ans=max(max(L.rmax,R.lmax),R.maxx-L.minn);
		printf("%d\n",ans);
		x=xx;//修改之前恢复成原来的 x、y 值 
		y=yy;
		while(tp[x]!=tp[y]){
			if(dep[tp[x]]<dep[tp[y]])
				swap(x,y);
			change(1,1,n,dfn[tp[x]],dfn[x],k);
			x=fa[tp[x]];
		}
		if(dep[x]>dep[y])
			swap(x,y);
		change(1,1,n,dfn[x],dfn[y],k);
	}
	return 0;
}

```

---

## 作者：devout (赞：14)

[博客内食用更佳](https://blog.csdn.net/devout_/article/details/104522793)

本来想水题的

开始以为就是一个区间维护最大值和最小值

结果开开心心的打了200行程序，一测样例，~~过不去~~

为什么呢？因为他要先买到宝石才能卖掉啊

所以白打了200行吗qwq

树剖的做法是显然的，线段树维护也是显然的

但是不能光维护最大值和最小值了

我们需要找一个$a$和$b$使$a$在$b$左边（~~形象的解释~~），让$val_a-val_b$最大

怎么办呢？暴力找吗

我们需要维护这些东西

1.区间最小值

2.区间最大值

3.区间从左边走到右边能够获得的最大利润

4.区间从右边走到左边能够获得的最大利润

为什么要分开维护3,4呢？因为我们能够发现，我们从不同方向走同一段路得到的答案显然是不一样的

对于这种返回值比较多的东西，我们可以通过结构体返回来实现

其实这种题型也不少，比如说[GSS7](https://www.luogu.com.cn/problem/SP6779)  [染色](https://devout.blog.luogu.org/solution-p2486)
都是这样的题

简单贴下合并答案的代码（这里我图省事没有新建结构体，直接用的线段树的结构体）

```cpp
segment_tree merge(segment_tree l,segment_tree r){
	segment_tree res;
	res._max=max(l._max,r._max);
	res._min=min(l._min,r._min);
	res.lmax=max(l._max-r._min,max(l.lmax,r.lmax));
	res.rmax=max(r._max-l._min,max(l.rmax,r.rmax));
	return res;
}
```


然后就很简单啦，我为了图省事，就在原来写的代码上改了改，于是成功的让我花了两个小时去debug...

如果当时重构代码的话估计还快一点qwq

树剖这种大码量的题还是要注意细节问题，比如说l,r有没有写反之类的

我就是最后询问的时候一个地方把r写成了l样例死活过不去

记得最后把l的左右swap一下

~~话说我感觉我左右写反了，为啥我要输出rmax呢qaq~~

code（我知道你们只看这个）：

```cpp
# include <bits/stdc++.h>
using namespace std;

# define Rep(i,a,b) for(int i=a;i<=b;i++)
# define _Rep(i,a,b) for(int i=a;i>=b;i--)
# define RepG(i,u) for(int i=head[u];~i;i=e[i].next)
# define debug puts("QAQ");

typedef long long ll;
const int N=1e5+5;
const int mod=1e9+7;
const double eps=1e-7;

template <typename T> void read(T &x){
	x=0;int f=1;
	char c=getchar();
	for(;!isdigit(c);c=getchar())if(c=='-')f=-1;
	for(;isdigit(c);c=getchar())x=(x<<1)+(x<<3)+c-'0';
	x*=f;
}

int n,q;
int head[N],cnt;
int faz[N],son[N],dep[N],siz[N],top[N],dfn[N],tot;
int a[N],_a[N];

struct Edge{
	int to,next;	
}e[N<<1];

void add(int x,int y){
	e[++cnt]=(Edge){y,head[x]},head[x]=cnt;	
}

struct segment_tree{
	int l,r;
	int _max,_min;
	int lmax,rmax;	
	int tag;
	segment_tree(){l=r=_max=_min=tag=0;lmax=rmax=0;}
	bool operator == (const segment_tree &cmp)const{
		return l==cmp.l&&r==cmp.r&&_max==cmp._max&&_min==cmp._min&&lmax==cmp.lmax&&rmax==cmp.rmax&&tag==cmp.tag;	
	}
}seg[N<<2];

# define lc (u<<1)
# define rc (u<<1|1)

void pushup(int u){
	seg[u]._max=max(seg[lc]._max,seg[rc]._max);
	seg[u]._min=min(seg[lc]._min,seg[rc]._min);
	seg[u].lmax=max(seg[lc]._max-seg[rc]._min,max(seg[lc].lmax,seg[rc].lmax));
	seg[u].rmax=max(seg[rc]._max-seg[lc]._min,max(seg[lc].rmax,seg[rc].rmax));
}

void pushdown(int u){
	seg[lc]._max+=seg[u].tag,seg[lc]._min+=seg[u].tag;
	seg[rc]._max+=seg[u].tag,seg[rc]._min+=seg[u].tag;
	seg[lc].tag+=seg[u].tag,seg[rc].tag+=seg[u].tag;
	seg[u].tag=0;	
}

segment_tree merge(segment_tree l,segment_tree r){
	segment_tree res;
	res._max=max(l._max,r._max);
	res._min=min(l._min,r._min);
	res.lmax=max(l._max-r._min,max(l.lmax,r.lmax));
	res.rmax=max(r._max-l._min,max(l.rmax,r.rmax));
	return res;
}

void build(int u,int l,int r){
	seg[u].l=l,seg[u].r=r;
	if(l==r){
		seg[u]._max=_a[l],seg[u]._min=_a[l];
		return;
	}
	int mid=l+r>>1;
	build(lc,l,mid);
	build(rc,mid+1,r);
	pushup(u);
}

void update(int u,int l,int r,int k){
	if(seg[u].l>=l&&seg[u].r<=r){
		seg[u]._max+=k,seg[u]._min+=k;
		seg[u].tag+=k;
		return;
	}
	if(seg[u].tag)pushdown(u);
	int mid=seg[u].l+seg[u].r>>1;
	if(l<=mid)update(lc,l,r,k);
	if(r>mid)update(rc,l,r,k);
	pushup(u);
}

segment_tree query(int u,int l,int r){
	if(seg[u].l>=l&&seg[u].r<=r)return seg[u];
	if(seg[u].tag)pushdown(u);
	int mid=seg[u].l+seg[u].r>>1;
	if(r<=mid)return query(lc,l,r);
	if(l>mid)return query(rc,l,r);
	return merge(query(lc,l,r),query(rc,l,r)); 	
}

void RouteModify(int x,int y,int k){
	while(top[x]!=top[y]){
		if(dep[top[x]]<dep[top[y]])swap(x,y);
		update(1,dfn[top[x]],dfn[x],k);
		x=faz[top[x]];
	}
	if(dep[x]>dep[y])swap(x,y);
	update(1,dfn[x],dfn[y],k);
}

int RouteQuery(int x,int y){
	segment_tree l,r;
	l._min=r._min=2e9;
	while(top[x]!=top[y]){
		if(dep[top[x]]<dep[top[y]]){
			r=merge(query(1,dfn[top[y]],dfn[y]),r);
			y=faz[top[y]];	
		}
		else{
			l=merge(query(1,dfn[top[x]],dfn[x]),l);
			x=faz[top[x]];	
		}
	}
	if(dep[x]>dep[y])l=merge(query(1,dfn[y],dfn[x]),l);
	else r=merge(query(1,dfn[x],dfn[y]),r);
	swap(l.lmax,l.rmax);
//	printf("%d %d %d %d\n",r._max,r._min,r.lmax,r.rmax);
	return merge(l,r).rmax;
}

void dfs1(int u,int fa){
	faz[u]=fa;
	siz[u]=1;
	dep[u]=dep[fa]+1;
	RepG(i,u){
		int v=e[i].to;
		if(v==fa)continue;
		dfs1(v,u);
		siz[u]+=siz[v];
		if(siz[v]>siz[son[u]])son[u]=v;
	}
}

void dfs2(int u,int _top){
	top[u]=_top;
	dfn[u]=++tot;
	_a[tot]=a[u];
	if(!son[u])return;
	dfs2(son[u],_top);
	RepG(i,u){
		int v=e[i].to;
		if(v==faz[u]||v==son[u])continue;
		dfs2(v,v);
	}
}

int main()
{
	memset(head,-1,sizeof(head));
	read(n);
	Rep(i,1,n)read(a[i]);
	Rep(i,1,n-1){
		int x,y;
		read(x),read(y);
		add(x,y),add(y,x);
	}
	dfs1(1,0),dfs2(1,1);
	build(1,1,n);
	read(q);
	while(q--){
		int x,y,c;
		read(x),read(y),read(c);
		printf("%d\n",RouteQuery(x,y));
		RouteModify(x,y,c);	
	}
	return 0;
}
```


---

## 作者：Dispwnl (赞：11)

### [博客](https://a-failure.github.io/2018/12/04/TJOI2015-旅游/)

出题人这个语文表达能力真的……

题目大意：

> 给定一棵树，每次询问从$a$走到$b$，选择两个城市$c,d(dis_{a,c}<dis_{a,d})$，使得$w_d-w_c$的值最大，求这个最大值，并且要求维护链上修改

如果是一个序列，显然用线段树就可以简单维护，这是放到树上的，所以用树链剖分维护了

考虑树链剖分处理询问的过程，两点深度大的往上沿着重链跳，直到跳到$LCA$

![](https://a-failure.github.io/img/study/travel1.png)

这样有两个问题：

- 一条链上不一定是一个编号连续的区间
- 左边链是由大的编号（线段树编号）跳到小的编号

所以要分左右链讨论，对于第一个问题，在跳链的时候维护一个最大（右边链）最小（左边链）值即可；对于第二个问题，在线段树上同时维护从左到右和从右到左的最大差值即可

对树链剖分跳链分情况讨论好像还挺常见的qwq

### 代码
```
# include<iostream>
# include<cstring>
# include<cstdio>
# include<algorithm>
# define tl (k<<1)
# define tr (k<<1|1)
# define mid (l+r>>1)
using namespace std;
const int MAX=5e4+5;
struct p{
    int minn,maxn,d,_d,tag;
    p(){d=_d=-2e9;}
}s[MAX<<2];
struct q{
    int x,y;
}c[MAX<<1];
int n,m,num,cnt;
int h[MAX],d[MAX],f[MAX],siz[MAX],son[MAX],w[MAX],re[MAX],top[MAX],id[MAX];
int read()
{
    int x=0,fl=1;
    char ch=getchar();
    for(;!isdigit(ch);fl=(ch=='-')?-1:1,ch=getchar());
    for(;isdigit(ch);x=x*10+ch-48,ch=getchar());
    return x*fl;
}
void add()
{
    int x=read(),y=read();
    c[++num]=(q){h[x],y},h[x]=num;
    c[++num]=(q){h[y],x},h[y]=num;
}
void dfs(int x=1,int fa=0)
{
    f[x]=fa,d[x]=d[fa]+(siz[x]=1);
    for(int i=h[x];i;i=c[i].x)
      if(c[i].y^fa)
      {
      	dfs(c[i].y,x),siz[x]+=siz[c[i].y];
      	if(siz[son[x]]<siz[c[i].y]) son[x]=c[i].y;
      }
}
void dfs1(int x=1,int tp=1)
{
    top[x]=tp,id[x]=++cnt,re[cnt]=x;
    if(!son[x]) return;
    dfs1(son[x],tp);
    for(int i=h[x];i;i=c[i].x)
      if((c[i].y^f[x])&&(c[i].y^son[x])) dfs1(c[i].y,c[i].y);
}
p pus(p b,p c,int Tag=0)
{
    p a;
    a.minn=min(b.minn,c.minn);
    a.maxn=max(b.maxn,c.maxn);
    a.d=max(c.maxn-b.minn,max(b.d,c.d));
    a._d=max(b.maxn-c.minn,max(b._d,c._d));
    return a.tag=Tag,a;
}
void build(int l=1,int r=n,int k=1)
{
    if(l==r) return void(s[k].minn=s[k].maxn=w[re[l]]);
    build(l,mid,tl),build(mid+1,r,tr),s[k]=pus(s[tl],s[tr]);
}
void down(int k)
{
    if(!s[k].tag) return;
    int f=s[k].tag;
    s[k].tag=0,s[tl].tag+=f,s[tr].tag+=f,s[tl].minn+=f,s[tl].maxn+=f,s[tr].minn+=f,s[tr].maxn+=f;
}
void change(int l,int r,int k,int L,int R,int dis)
{
    if(l==L&&r==R)
    {
        s[k].minn+=dis,s[k].maxn+=dis;
        return void(s[k].tag+=dis);
    }
    down(k);
    if(R<=mid) change(l,mid,tl,L,R,dis);
    else if(L>mid) change(mid+1,r,tr,L,R,dis);
    else change(l,mid,tl,L,mid,dis),change(mid+1,r,tr,mid+1,R,dis);
    s[k]=pus(s[tl],s[tr],s[k].tag);
}
void CHANGE(int x,int y,int dis)
{
    while(top[x]^top[y])
    {
        if(d[top[x]]<d[top[y]]) swap(x,y);
        change(1,n,1,id[top[x]],id[x],dis),x=f[top[x]];
    }
    if(d[x]>d[y]) swap(x,y);
    change(1,n,1,id[x],id[y],dis);
}
p ask(int l,int r,int k,int L,int R)
{
    if(l==L&&r==R) return s[k];
    down(k);
    if(R<=mid) return ask(l,mid,tl,L,R);
    if(L>mid) return ask(mid+1,r,tr,L,R);
    return pus(ask(l,mid,tl,L,mid),ask(mid+1,r,tr,mid+1,R));
}
int ASK(int x,int y)
{
    int ans=0,maxn_l=-2e9,maxn_r=-2e9,minn_r=2e9,minn_l=2e9;
    p tt;
    while(top[x]^top[y])
    {
        if(d[top[x]]<d[top[y]])
        {
            tt=ask(1,n,1,id[top[y]],id[y]),y=f[top[y]];
            ans=max(ans,max(tt.d,maxn_r-tt.minn)),maxn_r=max(maxn_r,tt.maxn),minn_r=min(minn_r,tt.minn);
        }
        else
        {
            tt=ask(1,n,1,id[top[x]],id[x]),x=f[top[x]];
            ans=max(ans,max(tt._d,tt.maxn-minn_l)),maxn_l=max(maxn_l,tt.maxn),minn_l=min(minn_l,tt.minn);
        }
    }
    if(d[x]>d[y])
    {
        tt=ask(1,n,1,id[y],id[x]);
        ans=max(ans,max(tt._d,tt.maxn-minn_l)),minn_l=min(minn_l,tt.minn);
    }
    else
    {
        tt=ask(1,n,1,id[x],id[y]);
        ans=max(ans,max(tt.d,maxn_r-tt.minn)),maxn_r=max(maxn_r,tt.maxn);
    }
    return max(ans,maxn_r-minn_l);
}
int main()
{
    n=read();
    for(int i=1;i<=n;++i)
      w[i]=read();
    for(int i=1;i<n;++i,add());
    dfs(),dfs1(),build(),m=read();
    for(int i=1,a,b,c;i<=m;++i)
      a=read(),b=read(),c=read(),printf("%d\n",ASK(a,b)),CHANGE(a,b,c);
    return 0;
}
```

---

## 作者：TKXZ133 (赞：10)

[旅游](https://www.luogu.com.cn/problem/P3976)

### 题目大意

对一颗树进行两种操作：将一条从 $u$ 到 $v$ 的链上的点的权值增加 $x$；查询从 $u$ 到 $v$ 的链上最大的 $p_i-p_j(dis_{ui}<dis_{uj})$，其中 $p_i$ 表示点 $i$ 的权值，$dis_{AB}$ 表示点 $A,B$ 间唯一路径上边的数量。

### 思路分析

先思考，如果没有 $dis_{ui}<dis_{uj}$ 这个条件，那么这个问题将十分简单，我们只需要用线段树维护链上的最大值，最小值，实现区间加操作即可。

但是多了这个限制条件，我们的做法就要做出一些改变。

首先，我们可以发现，这个条件是有方向性的。也就是说，对于一对查询的 $u,v$，如果将 $u,v$ 交换，查询的结果可能会发生变化，这与我们熟知的链上的和，最大值，最小值之类的是不同的。

那么我们可以先将问题简化，将树上问题变成序列问题。

在序列上维护这样一种带有方向性的可合并的信息，我们最常用的方法就是线段树，而线段树维护的核心就是区间合并，所以我们先思考区间合并如何实现。

容易发现，其实我们只需要维护区间的最大值 $\text{max}$，最小值 $\text{min}$，从左向右的最大差值 $\text{atob}$，从右向左的最大差值 $\text{btoa}$（十分形象）就可以解决这个问题，具体的维护方法如下：

```
a.max=max(ls.max,rs.max);
a.min=min(ls.min,rs.min);
a.atob=max(max(ls.atob,rs.atob),ls.max-rs.min);
a.btoa=max(max(ls.btoa,rs.btoa),rs.max-ls.min); 
```

剩下的线段树部分十分套路，想必大家都会写。（区间加，区间查询某个属性）

那么，我们现在既然有了序列上问题的做法，剩下的就只有把这个做法扩展到树上了。

对于一颗静态树上的链的维护和查询，最常用的方法无疑是树链剖分，树链剖分的思想主要分两个部分，一是把链拆成若干个连续的区间用线段树维护区间信息，二是将所有的区间合并成链，我们既然已经解决了第一个部分，第二个部分的做法就比较显然了。

对于一条链上的查询，如下图：

![](https://s1.328888.xyz/2023/02/13/c9B4o.md.png)

黑色箭头所指的方向是我们的 $\text{dfs}$ 序的方向，也就是我们线段树的方向，也就是说，对于线段树而言，图中黑色的 $l,r$ 是它认为的左边和右边。

但我们实际想要查询的方向是蓝色箭头所指的方向，我们发现，在从 $u\to \text{LCA}(u,v)$ 的路径上，线段树的方向与我们想要查询的方向南辕北辙，为了解决这个问题，我们在链上的合并时，先从起点和终点分别按照线段树方向维护两个链上的信息，在最后一步时将起点所在链的信息翻转，再与终点链的信息合并，从而得到完整的信息。

这么说可能有点抽象，具体看代码。

### 代码

```
#include <bits/stdc++.h>
using namespace std;
const int N=100100;//双向边，不要在乎空间，全部开双倍

int to[N],nxt[N],head[N],w[N];//链星
int top[N],fa[N],dfn[N],rnk[N],siz[N],dep[N],son[N];//树剖七件套
int idx,cnt,n,q,in1,in2,in3;

void add(int u,int v){idx++;to[idx]=v;nxt[idx]=head[u];head[u]=idx;}
void Swap(int &x,int &y){int t=x;x=y;y=t;}

struct STn{int l,r,max,min,atob,btoa,t;};//线段树节点，t是懒标记
void merge(STn &res,STn ls,STn rs){//合并信息
    res.max=max(ls.max,rs.max);
    res.min=min(ls.min,rs.min);
    res.atob=max(max(ls.atob,rs.atob),ls.max-rs.min);
    res.btoa=max(max(ls.btoa,rs.btoa),rs.max-ls.min);
} 
struct ST{//常规线段树
    STn a[N<<2];
    void add_t(int p,int k){a[p].t+=k;a[p].max+=k;a[p].min+=k;return ;}//区间加
    void push_down(int p){if(a[p].t){add_t(p<<1,a[p].t);add_t(p<<1|1,a[p].t);a[p].t=0;}return ;}//下放懒标记
    void build(int p,int l,int r){//常规建树
        a[p].l=l;a[p].r=r;a[p].t=0;
        if(a[p].l==a[p].r){a[p].min=a[p].max=w[rnk[a[p].l]];a[p].atob=a[p].btoa=0;return ;}//初值
        int mid=(a[p].l+a[p].r)>>1;
        build(p<<1,l,mid);build(p<<1|1,mid+1,r);
        merge(a[p],a[p<<1],a[p<<1|1]);return ;
    }
    void add(int p,int l,int r,int k){//常规的区间加
        if(l<=a[p].l&&a[p].r<=r){add_t(p,k);return ;}
        push_down(p);int mid=(a[p].l+a[p].r)>>1;
        if(l<=mid) add(p<<1,l,r,k);if(r>mid) add(p<<1|1,l,r,k);
        merge(a[p],a[p<<1],a[p<<1|1]);return ;
    }
    STn ask(int p,int l,int r){//常规的区间查询
        if(l<=a[p].l&&a[p].r<=r) return a[p];
        push_down(p);int mid=(a[p].l+a[p].r)>>1;
        if(r<=mid) return ask(p<<1,l,r);
        if(l>mid) return ask(p<<1|1,l,r);
        STn res;merge(res,ask(p<<1,l,r),ask(p<<1|1,l,r));
        return res;
    }
}tree;

void dfs_1(int s,int gr){//常规的树剖dfs1
    dep[s]=dep[gr]+1;fa[s]=gr;
    son[s]=-1;siz[s]=1;
    for(int i=head[s];i;i=nxt[i]){
        int v=to[i];
        if(v==gr) continue;
        dfs_1(v,s);
        siz[s]+=siz[v];
        if(son[s]==-1||siz[v]>siz[son[s]]) son[s]=v;
    }
}
void dfs_2(int s,int tp){//常规的树剖dfs2
    top[s]=tp;dfn[s]=++cnt;rnk[cnt]=s;
    if(son[s]==-1) return ;
    dfs_2(son[s],tp);
    for(int i=head[s];i;i=nxt[i]){
        int v=to[i];
        if(v!=son[s]&&v!=fa[s]) dfs_2(v,v);
    }
}

void add_all(int x,int y,int k){//常规的链上加
    while(top[x]!=top[y]){
        if(dep[top[x]]<dep[top[y]]) Swap(x,y);
        tree.add(1,dfn[top[x]],dfn[x],k);x=fa[top[x]];
    }
    tree.add(1,min(dfn[x],dfn[y]),max(dfn[x],dfn[y]),k);
}
int query(int x,int y){//不常规的查询
    STn l={0,0,-0x3f3f3f3f,0x3f3f3f3f,0,0,0},r=l;//先把两条链的初值赋上
    while(top[x]!=top[y]){
		if(dep[top[x]]<dep[top[y]]){merge(r,tree.ask(1,dfn[top[y]],dfn[y]),r);y=fa[top[y]];}//分起点和终点，不能swap
		else{merge(l,tree.ask(1,dfn[top[x]],dfn[x]),l);x=fa[top[x]];}
        //注意点：合并时 l,r 应该放在后边作为右区间进行合并
	}
	if(dep[x]>dep[y]) merge(l,tree.ask(1,dfn[y],dfn[x]),l);
	else merge(r,tree.ask(1,dfn[x],dfn[y]),r);//分两种完成最后一次合并
    return max(max(l.atob,r.btoa),r.max-l.min);//这里没有把区间翻转，而是直接利用区间信息完成合并
    //注意点：如何合并，结合图像理解
}

int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++) scanf("%d",&w[i]);
    for(int i=1;i<n;i++){
        scanf("%d%d",&in1,&in2);
        add(in1,in2);add(in2,in1);
    }//常规输入
    dfs_1(1,0);dfs_2(1,1);
    tree.build(1,1,n);//常规预处理
    scanf("%d",&q);
    while(q--){
        scanf("%d%d%d",&in1,&in2,&in3);
        cout<<max(query(in1,in2),0)<<'\n';//肯定不会亏本吧
        add_all(in1,in2,in3);//完事之后区间加
    }
    return 0;
}
```

---

## 作者：Genius_Z (赞：9)

题意：给出一棵树，询问一条链$(a,b)$上满足$dis(a,c)<dis(a,d)$的$(c,d)$中最大的$val(d)-val(c)$

因为是求链上的信息所以容易想到$LCT$

我们考虑维护最大值（记为$maxn$），最小值（记为$minn$），从左到右的最大利润（记为$lmax$），从右到左的最大利润（记为$rmax$）。

维护（应该比较好理解）：

```cpp
inl void maintain(int x) {
	t[x].maxn = max(max(t[ls(x)].maxn, t[rs(x)].maxn), t[x].w);
	t[x].minn = min(min(t[ls(x)].minn, t[rs(x)].minn), t[x].w);
	t[x].lmax = max(max(t[ls(x)].lmax, t[rs(x)].lmax), max(t[ls(x)].maxn, t[x].w) - min(t[rs(x)].minn, t[x].w));
	t[x].rmax = max(max(t[ls(x)].rmax, t[rs(x)].rmax), max(t[rs(x)].maxn, t[x].w) - min(t[ls(x)].minn, t[x].w));
}
```

维护从右到左的最大利润的原因就是交换左右儿子时左右要翻转

```cpp
inl void reverse(int x) {
	swap(t[x].lmax, t[x].rmax);
	swap(ls(x), rs(x));
	t[x].filp ^= 1;
}
```

边界条件：

```cpp
t[0].minn = inf, t[0].maxn = -inf;
```



Code：

```cpp
#include <algorithm>
#include <tuple>
#include <bitset>
#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <map>
#include <queue>
#include <set>
#include <vector>
#define inl inline
#define re register int
#define fa(x) t[x].fa
#define ls(x) t[x].child[0]
#define rs(x) t[x].child[1]
#define ll long long
const int inf = 0x3f3f3f3f;
#define lowbit(x) ((x) & (-x))
using namespace std;
template <class Read>
inl Read read() {
	Read x = 0;
	register bool w = 0;
	register char c = getchar();
	while (c > '9' || c < '0') {
		if (c == '-') w = 1;
		c = getchar();
	}
	while (c >= '0' && c <= '9') {
		x = (x << 3) + (x << 1) + (c ^ 48);
		c = getchar();
	}
	return w ? -x : x;
}
struct node {
	int fa, child[2], w, maxn, minn, add, lmax, rmax;
	bool filp;
} t[1000001];
struct edge {
	int next, to;
} e[200001];
int head[100001], tot;
inl void adde(int x, int y) {
	e[++tot] = edge{ head[x], y }, head[x] = tot;
}
inl void maintain(int x) {
	t[x].maxn = max(max(t[ls(x)].maxn, t[rs(x)].maxn), t[x].w);
	t[x].minn = min(min(t[ls(x)].minn, t[rs(x)].minn), t[x].w);
	t[x].lmax = max(max(t[ls(x)].lmax, t[rs(x)].lmax), max(t[ls(x)].maxn, t[x].w) - min(t[rs(x)].minn, t[x].w));
	t[x].rmax = max(max(t[ls(x)].rmax, t[rs(x)].rmax), max(t[rs(x)].maxn, t[x].w) - min(t[ls(x)].minn, t[x].w));
}
inl void sum(int x, int w) {
	t[x].w += w, t[x].add += w, t[x].maxn += w, t[x].minn += w;
}
inl void reverse(int x) {
	swap(t[x].lmax, t[x].rmax);
	swap(ls(x), rs(x));
	t[x].filp ^= 1;
}
inl void pushdown(int x) {
	if (t[x].add) {
		if (ls(x))sum(ls(x), t[x].add);
		if (rs(x))sum(rs(x), t[x].add);
		t[x].add = 0;
	}
	if (t[x].filp) {
		if (ls(x))reverse(ls(x));
		if (rs(x))reverse(rs(x));
		t[x].filp = 0;
	}
}
inl bool nroot(int x) { return ls(fa(x)) == x || rs(fa(x)) == x; }
inl bool poi(int x) { return rs(fa(x)) == x; }
inl void push(int x) {
	if (nroot(x))push(fa(x));
	pushdown(x);
}
inl void rotate(int x) {
	re f = fa(x), gf = fa(f), fs = poi(x), gfs = poi(f), s = t[x].child[fs ^ 1];
	if (nroot(f))t[gf].child[gfs] = x;
	t[x].child[fs ^ 1] = f, t[f].child[fs] = s;
	if (s)fa(s) = f;
	fa(f) = x, fa(x) = gf;
	maintain(f);
}
inl void splay(int x) {
	push(x);
	while (nroot(x)) {
		if (nroot(fa(x)))poi(x) == poi(fa(x)) ? rotate(fa(x)) : rotate(x);
		rotate(x);
	}
	maintain(x);
}
inl void access(int x) {
	for (re i = 0; x; x = fa(i = x))splay(x), rs(x) = i, maintain(x);
}
inl void makeroot(int x) {
	access(x), splay(x), reverse(x);
}
inl void split(int x, int y) {
	makeroot(y), access(x), splay(x);
}
inl void link(int x, int y) {
	split(x, y), fa(y) = x;
}
signed main() {
	t[0].minn = inf, t[0].maxn = -inf;
	re n = read<int>();
	for (re i = 1; i <= n; i++)t[i].maxn = t[i].minn = t[i].w = read<int>();
	for (re i = 1; i < n; i++) {
		re x = read<int>(), y = read<int>();
		link(x, y);
	}
	re m = read<int>();
	while (m--) {
		re x = read<int>(), y = read<int>(), w = read<int>();
		split(x, y), printf("%d\n", t[x].lmax), sum(x, w);
	}
}
```



---

## 作者：elijahqi (赞：7)

树链剖分，感觉蛮有难度，考场上也不好写  注意树的节点数应该是4\*N



首先我们不妨把问题简化一下，将树形图简化为一维的，那么我们可以光明正大使用线段树维护


上面这道题大家可以看一看 也有讲解


然后对于树上的操作，我们选择树链剖分降低复杂度


树链剖分dfs1我们做的是把所有的轻重儿子划分出来，如果是fa则continue;


dfs2是针对我们已经划分好的给予标记


我们首先先给重儿子标记，if (son[x]) dfs2(son[x],top);


这样的话保证了重儿子的标号是连续的同时也保证了我们在线段树上的查询是连续的


另外搜索的时候记录w数组，这是一个坑点，下面建立线段树会说


建立完重儿子开始建立轻儿子，轻儿子的每个顶都是自己，重儿子就是连续一串的顶


注意搜索轻儿子的时候因为是双向边，要判断下是否是父亲或者是否是重儿子（之前搜索过）


接下来就是建立线段树，我想这个不用多赘述了


强调一下对于建立线段树时初值的给法


我一开始给的是tree[x].max=tree[x].min=a[id[l]];


这是一种错误的给法，我们思考一下我们线段树和真正树的映射关系


我们其实像树上莫队类似我们线段树应该是我们根据深搜序来确定的


我们id里储存的相当于我们根据普通的序列去找深搜序列


然而线段树的初值是要根据深搜序寻找普通序列


然后最后查找答案的时候要注意方向性


```cpp
void solve(int x,int y,int v){
    node1 ansl,ansr;
    while (tp[x]!=tp[y]){
        if(dep[tp[x]]>dep[tp[y]]){
            ansl=update1(ansl,query(root,id[tp[x]],id[x],v));
            x=fa[tp[x]];
        }else{
            ansr=update1(query(root,id[tp[y]],id[y],v),ansr);
            y=fa[tp[y]];
        }
    }
    swap(ansl.ans,ansl.ans1);
    if (id[x]<id[y]){
        ansl=update1(ansl,query(root,id[x],id[y],v));
        ansl=update1(ansl,ansr);    
    }else{
        node1 tmpp=query(root,id[y],id[x],v);
        swap(tmpp.ans,tmpp.ans1);
        ansr=update1(tmpp,ansr);
        ansl=update1(ansl,ansr);
    }    
    printf("%d\n",ansl.ans);
//    printf("sdfsdf\n");
    //print(root);
}
```
首先如果不在同一条链我们应该选择深度大的往上跳跃


在此声明一下 tree[x].ans ans是正向差最大，ans1是逆向差最大，看水果姐那道题就可以明白


由于我们根据深搜原理可以很清楚知道tp[x]-x在深搜序中（也就是线段树是从左到右）


然而实际上我们要知道的是x->y这条路径所以根据tp的定义应该是x->tp[x]


那么没关系，做的时候按照线段树正常顺序来做，我们不是维护了ans1吗，我们直接交换一下ans和ans1就可以了


最后合并的时候其实就没有什么方向问题了，不过注意update1函数给予的两个参数的顺序一定不能写反了 写反了，合并的有向性就反了

```cpp
#include<cstdio>
#include<algorithm>
#define N 55000
#define inf 0x7fffffff
using namespace std;
inline int read(){
    int x=0;char ch=getchar();
    while (ch<'0'||ch>'9') ch=getchar();
    while (ch<='9'&&ch>='0'){x=x*10+ch-'0';ch=getchar();}
    return x;
}
struct node{
    int y,next;
}data[N<<1];
struct node1{
    int max,min,ans,ans1;
    node1(){
        ans=ans1=max=0;min=inf;
    }
};
struct node2{
    int l,r,left,right,max,min,ans,ans1,lazy;
}tree[N<<2];
int size[N],id[N],fa[N],son[N],tp[N],a[N],dep[N],h[N],cnt,root,n,num,m,w[N];
void dfs1(int x){
    size[x]=1;
    for (int i=h[x];i;i=data[i].next){
        int y=data[i].y;
        if(fa[x]==y) continue;
        dep[y]=dep[x]+1;fa[y]=x;dfs1(y);size[x]+=size[y];
        if (size[y]>size[son[x]]) son[x]=y;
    }
}
void dfs2(int x,int top){
    id[x]=++cnt;tp[x]=top;w[cnt]=a[x];
    if (son[x]) dfs2(son[x],top);
    for (int i=h[x];i;i=data[i].next){
        int y=data[i].y;
        if (y==fa[x]||y==son[x]) continue;
        dfs2(y,y);
    }
}
inline void update(int x){
    int l=tree[x].left,r=tree[x].right;
    tree[x].ans=max(tree[r].max-tree[l].min,max(tree[l].ans,tree[r].ans));
    tree[x].ans1=max(tree[l].max-tree[r].min,max(tree[l].ans1,tree[r].ans1));
    tree[x].min=min(tree[l].min,tree[r].min);
    tree[x].max=max(tree[l].max,tree[r].max);
    
}
void print(int x){
    if (tree[x].left) print(tree[x].left);
    printf("%d %d %d %d %d %d %d\n",tree[x].l,tree[x].r,tree[x].max,tree[x].min,tree[x].ans,tree[x].ans1,tree[x].lazy);
    if (tree[x].right) print(tree[x].right);
}
void build(int &x,int l,int r){
    x=++cnt;tree[x].l=l;tree[x].r=r;
    if(l==r){
        tree[x].min=tree[x].max=w[l];
        tree[x].ans=tree[x].ans1=0;return;
    }
    int mid=l+r>>1;
    build(tree[x].left,l,mid);build(tree[x].right,mid+1,r);
    update(x);
}
inline node1 update1(node1 tmp1,node1 tmp2){
    node1 ans1;
    ans1.ans=max(tmp2.max-tmp1.min,max(tmp1.ans,tmp2.ans));
    ans1.ans1=max(tmp1.max-tmp2.min,max(tmp1.ans1,tmp2.ans1));
    ans1.min=min(tmp1.min,tmp2.min);
    ans1.max=max(tmp1.max,tmp2.max);
    return ans1;
}
void pushdown(int x){
    if (!tree[x].lazy) return;
    int l=tree[x].left,r=tree[x].right;
    int lazy=tree[x].lazy;
    tree[l].lazy+=lazy;tree[r].lazy+=lazy;
    tree[l].max+=lazy;tree[r].max+=lazy;
    tree[l].min+=lazy;tree[r].min+=lazy;
    tree[x].lazy=0;
}
node1 query(int rt,int l,int r,int v){
    if(l<=tree[rt].l&&r>=tree[rt].r){
        tree[rt].lazy+=v;tree[rt].max+=v;tree[rt].min+=v;
        node1 tmp;tmp.max=tree[rt].max;tmp.min=tree[rt].min;tmp.ans=tree[rt].ans;tmp.ans1=tree[rt].ans1;
        return tmp;
    }
    int mid=(tree[rt].l+tree[rt].r)>>1;
    node1 tmp1;node1 tmp2;pushdown(rt);
    if (l<=mid) tmp1=query(tree[rt].left,l,r,v);
    if (r>mid) tmp2=query(tree[rt].right,l,r,v);
    update(rt);
    return update1(tmp1,tmp2);
}
inline void swap(int &x,int &y){
    x^=y;y^=x;x^=y;
}
void solve(int x,int y,int v){
    node1 ansl,ansr;
    while (tp[x]!=tp[y]){
        if(dep[tp[x]]>dep[tp[y]]){
            ansl=update1(query(root,id[tp[x]],id[x],v),ansl);
            x=fa[tp[x]];
        }else{
            ansr=update1(query(root,id[tp[y]],id[y],v),ansr);
            y=fa[tp[y]];
        }
    }
    swap(ansl.ans,ansl.ans1);
    if (id[x]<id[y]){
        ansl=update1(ansl,query(root,id[x],id[y],v));
        ansl=update1(ansl,ansr);    
    }else{
        node1 tmpp=query(root,id[y],id[x],v);
        swap(tmpp.ans,tmpp.ans1);
        ansr=update1(tmpp,ansr);
        ansl=update1(ansl,ansr);
    }    
    printf("%d\n",ansl.ans);
//    printf("sdfsdf\n");
    //print(root);
}
int main(){
    //freopen("bzoj3999.in","r",stdin);
//    freopen("bzoj3999.out","w",stdout);
    n=read();
    for (int i=1;i<=n;++i) a[i]=read();
    for (int i=1;i<n;++i){
        int x=read(),y=read();
        data[++num].y=y;data[num].next=h[x];h[x]=num;
        data[++num].y=x;data[num].next=h[y];h[y]=num;
    }dep[1]=1;
    dfs1(1);dfs2(1,1);
    //for (int i=1;i<=n;++i) printf("%d ",id[i]);printf("\n");
    build(root,1,n);//print(root);
    m=read();
    for (int i=1;i<=m;++i){
        int x=read(),y=read(),z=read();
        solve(x,y,z);
    }
    return 0;
}

```
最后说一下 tjoi的数据很水的即使写错了也可以过

建议大家可以看看hdu5052 tjoi应该是以他为原型改的 那道题的数据强qwq 我wa了一页 还是太菜了

<http://www.elijahqi.win/2017/09/14/hdu5052/>



---

## 作者：Leap_Frog (赞：5)

### PS.
**前方压行，前方压行！前方压行！！！**  
求勿喷压行码风。![](https://upload.orzsiyuan.com/images/emotions/wq.png)  
建议先把代码复制到本地dev-c++或VS-Code或Sublime后食用。  
47行A了此题

### Problem.
没什么好解释的了吧。

### Solution
首先，看到看到这题后，我们发现新世界呈一棵树，然后每次询问是链上询问。  
那么显然是树剖。  
然后我们就成功地把它转换为区间问题。  
区间修改：简单的区间加。  
区间询问：要求区间内$\max\{a_x-a_y\}(l_i\le x\le y\le r_i)$的最大值。  

笔者看到这题之后想到了[P1073最优贸易](https://www.luogu.com.cn/problem/P1073)。  
这两题维护的信息是一样的，但是一棵是数，一个是图。复杂度也不一样。  
最优贸易那题的区间问题是直接扫一遍，然后维护的。  

笔者又想到了另一题，是POJ上的，具体题号记不清了。![](https://upload.orzsiyuan.com/images/emotions/wq.png)  
那题貌似是没有修改操作，所以可以用st表维护差分，然后那题就做完了。  

那么我们现在来考虑这题。  
我们的区间问题必须在log的时间内解决。  
所以我们只能考虑线段树直接维护答案。  

我们考虑维护区间最大值`maxn`，最小值`minn`。  
左边的最大值`ans1`，右边的最大值`ansr`。  

然后得到`ans1`和`ans2`后就可以求出最终的答案了。  

### Coding
```cpp
#include<bits/stdc++.h>
using namespace std;
struct edge{int to,nxt;}e[100005];//边的结构体
struct que{int maxn,minn,ansl,ansr;};//查询信息的结构体
struct trn{que v;int ls,rs,fla;}t[200005];//线段树结构体
int n,m,tot,cnt,head[50005],rt,siz[50005],dep[50005],dfn[50005],f[50005],sn[50005],tp[50005],w[50005],a[50005];//树剖需要的东西
//head是链式前向星的，siz是以这个为根的子树大小。
//dep是当前节点深度，dfn是树剖中的dfs序。
//f是一个节点的付清，sn是一个节点的重儿子。  
//tp是一个节点所在的重链链顶，a是读入的权值，w是按照dfn排序的a。
inline void adde(int x,int y) {e[++tot]=(edge){y,head[x]},head[x]=tot;}//加边
inline void dfs1(int x,int fa=0)
{//树剖第一遍dfs，求出siz，dep，f，sn
	siz[x]=1,dep[x]=dep[fa]+1,f[x]=fa,sn[x]=0;
	for(int i=head[x];i;i=e[i].nxt) if(e[i].to!=fa) dfs1(e[i].to,x),siz[x]+=siz[e[i].to],(siz[e[i].to]>siz[sn[x]])?(sn[x]=e[i].to):0;
}
inline void dfs2(int x,int top)
{//树剖第二遍求dfs，求出dfn，tp
	dfn[x]=++cnt,tp[x]=top,w[cnt]=a[x];if(sn[x]) dfs2(sn[x],top);
	for(int i=head[x];i;i=e[i].nxt) if(e[i].to!=f[x]&&e[i].to!=sn[x]) dfs2(e[i].to,e[i].to);
}
inline que up(que a,que b) {return (que){max(a.maxn,b.maxn),min(a.minn,b.minn),max(b.maxn-a.minn,max(a.ansl,b.ansl)),max(a.maxn-b.minn,max(a.ansr,b.ansr))};}//合并两个区间的信息
inline void allc(int x,int c) {if(c) t[x].v.maxn+=c,t[x].v.minn+=c,t[x].fla+=c;}//修改一个区间
inline void down(int x) {allc(t[x].ls,t[x].fla),allc(t[x].rs,t[x].fla),t[x].fla=0;}//下推标记
inline void bld(int &x,int l,int r)
{//建立线段树，动态开点写习惯了
	x=++cnt;if(l==r) return (void)(t[x]=(trn){(que){w[l],w[l],0,0},0,0,0});
	bld(t[x].ls,l,(l+r)>>1),bld(t[x].rs,((l+r)>>1)+1,r),t[x].v=up(t[t[x].ls].v,t[t[x].rs].v);
}
inline que qry(int x,int l,int r,int dl,int dr,int dv)
{//线段树查询和修改，因为题目查询修改同时操作，所以可以合并（由此可见笔者的偷懒
	if(l>dr||dl>r) return (que){0,(int)1e9,0,0};else if(dl<=l&&r<=dr) return allc(x,dv),t[x].v;else down(x);
	que res=up(qry(t[x].ls,l,(l+r)>>1,dl,dr,dv),qry(t[x].rs,((l+r)>>1)+1,r,dl,dr,dv));return t[x].v=up(t[t[x].ls].v,t[t[x].rs].v),res;
}
inline int work(int x,int y,int v)
{//树剖求链信息
//这个树剖和其他的不一样，是有顺序的。
//所以我们需要分别统计两条链的信息。
	que a1=(que){0,(int)1e9,0,0},a2=(que){0,(int)1e9,0,0},tmp;
	while(tp[x]!=tp[y]) if(dep[tp[x]]>dep[tp[y]]) a1=up(qry(rt,1,n,dfn[tp[x]],dfn[x],v),a1),x=f[tp[x]];else a2=up(qry(rt,1,n,dfn[tp[y]],dfn[y],v),a2),y=f[tp[y]];
	swap(a1.ansl,a1.ansr);
	if(dfn[x]<dfn[y]) a1=up(up(a1,qry(rt,1,n,dfn[x],dfn[y],v)),a2);else tmp=qry(rt,1,n,dfn[y],dfn[x],v),swap(tmp.ansl,tmp.ansr),a1=up(a1,up(tmp,a2));
	return a1.ansl;
}
int main()
{
	scanf("%d",&n),siz[0]=0,dep[0]=0,cnt=0,tot=0,memset(head,0,sizeof(head));//一大堆初始化（笔者习惯
	for(int i=1;i<=n;i++) scanf("%d",a+i);
	for(int i=1,x,y;i<n;i++) scanf("%d%d",&x,&y),adde(x,y),adde(y,x);
	scanf("%d",&m),dfs1(1),dfs2(1,1),bld(rt,1,n);
	for(int i=1,a,b,v;i<=m;i++) scanf("%d%d%d",&a,&b,&v),printf("%d\n",work(a,b,v));
	return 0;
}
```
~~完结撒花，无耻求赞，求勿喷压行码风~~

---

## 作者：liuzhangfeiabc (赞：4)

看到没有lct题解就强行来一发

这个题维护链操作，容易让人想到可以用lct来做。

什么你说你不会lct？出门右转P3690。

用lct的一大好处就是处理正着走反着走这东西比树剖好写一点，只需要维护一个区间最大值，区间最小值，先买后卖的最大收益和最小收益，还有区间加标记即可。

区间合并的方式跟树剖类似，不过别忘了把根节点也算上。

mx[q]=max(mx[l[q]],a[q],mx[r[q]])//最大值

mn[q]=min(mn[l[q]],a[q],mn[r[q]])//最小值

mxa[q]=max(mxa[l[q]],mxa[r[q]],max(mx[r[q]],a[q])-min(a[q],mn[l[q]]))//最大收益

mna[q]=min(mna[l[q]],mna[r[q]],min(mn[r[q]],a[q])-max(a[q],mx[l[q]]))//最小收益

下放区间加标记时更新对应节点的权值，区间最大值和区间最小值，reverse时交换最大收益和最小收益并×-1即可。

还有一点好处是这个题的lct写法比较套路化，没有什么特别的操作，因此对于熟悉lct的人来说代码难度较小，对于刚接触lct的人也可以以此作为入门题。

时间复杂度O(nlogn)，亲测跑得比大多数树剖快。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define li long long
#define gc getchar()
#define pc putchar
li read(){
	li x = 0,c = gc;
	while(!isdigit(c)) c = gc;
	while(isdigit(c)){
		x = (x << 1) + (x << 3) + (c ^ '0');c = gc;
	}
	return x;
}
void print(li q){
	if(q >= 10) print(q / 10);
	pc(q % 10 + '0');
}
int n,m;
struct edge{
	int to,nxt;
}e[100010];
int cnt,fir[100010];
void ins(int u,int v){
	e[++cnt].to = v;e[cnt].nxt = fir[u];fir[u] = cnt;
	e[++cnt].to = u;e[cnt].nxt = fir[v];fir[v] = cnt;
}
int a[100010],f[100010],l[100010],r[100010],mx[100010],mn[100010],mxa[100010],mna[100010],d[100010];
bool c[100010];
void dfs(int q){
	for(int i = fir[q];i;i = e[i].nxt) if(e[i].to != f[q]){
		f[e[i].to] = q;
		dfs(e[i].to);
	}
}
inline bool is(int q){
	return l[f[q]] != q && r[f[q]] != q;
}
inline void rv(int q){
	swap(l[q],r[q]);c[q] ^= 1;swap(mxa[q],mna[q]);mxa[q] *= -1;mna[q] *= -1;
}
inline void ps(int q){
	if(d[q]){
		if(l[q]) a[l[q]] += d[q],d[l[q]] += d[q],mx[l[q]] += d[q],mn[l[q]] += d[q];
		if(r[q]) a[r[q]] += d[q],d[r[q]] += d[q],mx[r[q]] += d[q],mn[r[q]] += d[q];
		d[q] = 0;
	}
	if(c[q]){
		if(l[q]) rv(l[q]);
		if(r[q]) rv(r[q]);
		c[q] = 0;
	}
}
inline void ud(int q){
	mx[q] = mn[q] = a[q];mxa[q] = mna[q] = 0;
	if(l[q]){
		mxa[q] = max(max(mxa[q],mxa[l[q]]),mx[q] - mn[l[q]]);
		mna[q] = min(min(mna[q],mna[l[q]]),mn[q] - mx[l[q]]);
		mx[q] = max(mx[q],mx[l[q]]);
		mn[q] = min(mn[q],mn[l[q]]);
	}
	if(r[q]){
		mxa[q] = max(max(mxa[q],mxa[r[q]]),mx[r[q]] - mn[q]);
		mna[q] = min(min(mna[q],mna[r[q]]),mn[r[q]] - mx[q]);
		mx[q] = max(mx[q],mx[r[q]]);
		mn[q] = min(mn[q],mn[r[q]]);
	}
}
void ro(int q){
	if(is(q)) return;
	int p = f[q];
	if(l[f[p]] == p) l[f[p]] = q;
	else if(r[f[p]] == p) r[f[p]] = q;
	f[q] = f[p];f[p] = q;
	if(l[p] == q){
		l[p] = r[q];r[q] = p;
		if(l[p]) f[l[p]] = p;
	}
	else{
		r[p] = l[q];l[q] = p;
		if(r[p]) f[r[p]] = p;
	}
	mxa[q] = mxa[p];mna[q] = mna[p];mx[q] = mx[p];mn[q] = mn[p];
	ud(p);
}
void gx(int q){
	if(!is(q)) gx(f[q]);
	ps(q);
}
void sp(int q){
	gx(q);
	while(!is(q)){
		int p = f[q];
		if(!is(p)){
			if((l[f[p]] == p) ^ (l[p] == q)) ro(q);
			else ro(p);
		}
		ro(q);
	}
}
void ac(int q){
	int p = 0;
	while(q){
		sp(q);
		r[q] = p;
		ud(q);
		p = q;q = f[q];
	}
}
void mk(int q){
	ac(q);sp(q);rv(q);
}
void si(int u,int v){
	mk(u);ac(v);sp(v);
}
int main(){
	int i,j,u,v,w;
	n = read();
	for(i = 1;i <= n;++i) a[i] = mx[i] = mn[i] = read();
	for(i = 1;i < n;++i){
		u = read();v = read();ins(u,v);
	}
	dfs(1);
	m = read();
	for(i = 1;i <= m;++i){
		u = read();v = read();w = read();si(u,v);print(mxa[v]);pc('\n');
		d[v] += w;mx[v] += w;mn[v] += w;a[v] += w;
	}
	return 0;
}
```

---

## 作者：forgotmyhandle (赞：3)

这出题人语言表达能力真的感人……

~~希望你们看完这篇题解后不要觉得我的语言表达能力和出题人不相上下。~~

### 题目大意
给定一棵有点权的树，每次询问从 $u$ 到 $v$ 的路径上后经过的点权减去先经过的点权的最大值，再把这条路径上所有点的点权加上一个给定的数。

## 分析
俗话说得好：如果你觉得一个树上的题很难，那就先把它扔到序列上。

于是有如下两个子问题：

1. 给定序列，每次询问在 $l$ 到 $r$ 的区间内**从左向右**选两个数，令选的**左边的数**作为进价，**右边的数**作为售价，要求利润（售价减进价）最大值。
2. 给定序列，每次询问在 $l$ 到 $r$ 的区间内**从右向左**选两个数，令选的**右边的数**作为进价，**左边的数**作为售价，要求利润（售价减进价）最大值。


考虑子问题 1。显然可以线段树，维护区间最大收益。线段树上一个区间内的最大收益无非三种情况：

1. 在左儿子的区间内买进且卖出，这种情况左儿子已经维护了；
2. 在右儿子的区间内买进且卖出，这种情况右儿子已经维护了；
3. 左儿子的区间内买，右儿子的区间内卖。这种情况需要自己推：右儿子中最大值减去左儿子中最小值。

如果是子问题 2 的话就改一下第 3 种情况：右儿子的区间内买，左儿子的区间内卖，这种情况的收益也变为左儿子中最大值减去右儿子中最小值。

第三种情况需要左右儿子内区间最小值，于是再用线段树维护区间极值。
这样每次询问时在线段树上查询，若一次查询同时递归了左右两个儿子，那就像刚才讨论的那样合并左右儿子的答案。

```cpp
int Query_val(int o, int l, int r, int L, int R, int dir) { // dir 代表从左往右或从右往左
    if (L * R == 0) 
        return 0;
    if (L <= l && r <= R) 
        return val[dir][o]; // val 是二维数组，分别记录从左往右和从右往左
    pushdown(o);
    int mid = l + r >> 1, sl = 0, sr = 0, ret = 0;
    if (L <= mid) 
        ret = Query_val(o << 1, l, mid, L, R, dir), sl = 1;
    if (R > mid) 
        ret = max(ret, Query_val(o << 1 | 1, mid + 1, r, L, R, dir)), sr = 1;
    if (sl && sr) { // 同时递归了左右儿子，合并答案
        ret = max(ret, 
            !dir ? 
            Query_max(1, 1, N, mid + 1, R) - Query_min(1, 1, N, L, mid) : // 从左往右合并答案
            Query_max(1, 1, N, L, mid) - Query_min(1, 1, N, mid + 1, R)); // 从右往左合并答案
    }
    return ret;
}
```

序列上的子问题解决了，接下来来到树上。

~~**正片开始。**~~

为了方便，接下来所说的**顺树贸易**是指买进处比卖出处更接近根，**逆树贸易**是指卖出处比买进处更靠近根。不难看出子问题 1 实际上是顺树贸易，子问题 2 是逆树贸易。

既然用了树剖，那树上的一条条链就可以类比成线段树上的一个个区间，跳链时就要维护从出发点到当前点的最优贸易。以下设询问的路径起始点为 $u$，终点为 $v$，$x$ 从 $u$ 开始跳，$y$ 从 $v$ 开始跳。

以下分类讨论 $x$ 跳链与 $y$ 跳链：

假设 $x$ 刚才跳过一条链。沿用合并区间答案的思想，在合并两条链上的答案的时候，将链看成区间，**将 $x$ 现所在链顶 $t$ 与 $u$ 之间的路径视为当前区间，显然这条路径上有两条链。随后将 $u$ 到 $x$（不含）之间的路径视为当前区间的左儿子，$x$ 到 $t$ 之间的路径视为右儿子**，按子问题 2（逆树贸易）的方式合并区间答案即可。

假设 $x$ 还没跳过链，那就先让 $x$ 跳链，随后初始化 $u$ 到 $x$ 的路径上的最优贸易与最小值。

第一次跳链之后，$u$ 到 $x$（不含）之间的路径上的最优贸易与最小值就可以让 $x$ 一边跳一边维护。

$y$ 的跳链与 $x$ 类似，还是**把 $y$ 当前所在链顶 $t$ 到 $v$ 的路径视为当前区间，只不过要将 $t$ 到 $y$ 之间的路径视为左儿子，$y$（不含）到 $v$ 的区间视为右儿子**，然后按子问题 1（顺树贸易）的方式合并答案。如果没跳过链的话就先让 $y$ 跳，再初始化 $y$（不含）到 $v$ 之间的最优贸易与最大值。在那之后也是一样边跳边维护。

```cpp
    while (top[x] != top[y]) {
        if (dep[top[x]] > dep[top[y]]) {
            if (xton == inf) {
                xret = max(xret, Query_val(1, 1, N, dfn[top[x]], dfn[x], 1));
                xton = Query_min(1, 1, N, dfn[top[x]], dfn[x]);
            } else {
                xret = max(xret, max(Query_val(1, 1, N, dfn[top[x]], dfn[x], 1), 
                    Query_max(1, 1, N, dfn[top[x]], dfn[x]) - xton));
                xton = min(xton, Query_min(1, 1, N, dfn[top[x]], dfn[x]));
            }
            x = f[top[x]];
        } else {
            if (yton == -inf) {
                yret = max(yret, Query_val(1, 1, N, dfn[top[y]], dfn[y], 0));
                yton = Query_max(1, 1, N, dfn[top[y]], dfn[y]);
            } else {
                yret = max(yret, max(Query_val(1, 1, N, dfn[top[y]], dfn[y], 0), 
                    yton - Query_min(1, 1, N, dfn[top[y]], dfn[y])));
                yton = max(yton, Query_max(1, 1, N, dfn[top[y]], dfn[y]));
            }
            y = f[top[y]];
        }
    }
```

那么这样 $x$ 和 $y$ 就来到了同一条链上。在这里有四种情况：

1. $x$ 和 $y$ 都没跳过链；
2. $x$ 没跳过链，$y$ 跳过链；
3. $x$ 跳过链，$y$ 没跳过链；
4. $x$ 和 $y$ 都跳过链。

为了代码方便，在分类讨论之后会统一让 $x$ 和 $y$ 各跳链至少一次（可能会只跳某条链的一部分）使其汇合与一点 $p$，并合并 $u$ 到 $p$ 与 $p$ 到 $v$ 的答案。

第 1 种情况没什么好讨论的，就是 $u$ 和 $v$ 在同一条链上。函数可以直接返回 $u$ 到 $v$ 的答案。注意是顺树贸易还是逆树贸易。

第 2 种情况里有两种情况：

1. $x$ 的深度比 $y$ 的深度大。此时让 $x$ 向上跳到 $y$，做一个**逆树贸易**，并维护 $u$ 到 $x$ 的信息；
2. $x$ 的深度比 $y$ 的深度小。此时让 $x$ 向下跳到 $y$，做一个**顺树贸易**，并维护 $u$ 到 $x$ 的信息。

第 3 种情况里也有两种情况：

1. $x$ 的深度比 $y$ 的深度大。此时让 $y$ 向下跳到 $x$（$x$ 相对于 $y$ 向上跳），做一个**逆树贸易**，并维护 $y$ 到 $v$ 的信息；
2. $x$ 的深度比 $y$ 的深度小。此时让 $y$ 向上跳到 $x$（$x$ 相对于 $y$ 向下跳），做一个**顺树贸易**，并维护 $y$ 到 $v$ 的信息。

至于第 4 种情况，因为 $x$ 和 $y$ 都跳过链了，所以谁往哪跳都无所谓。不过我个人还是倾向于让它们汇聚在它们的 $lca$ 上。

```cpp
    if (xton == inf && yton == -inf) {
        if (dep[x] > dep[y]) 
            return Query_val(1, 1, N, dfn[y], dfn[x], 1);
        else 
            return Query_val(1, 1, N, dfn[x], dfn[y], 0);
    } else if (xton == inf) {
        if (dep[x] > dep[y]) {
            xret = Query_val(1, 1, N, dfn[y], dfn[x], 1);
            xton = Query_min(1, 1, N, dfn[y], dfn[x]);
        } else {
            xret = Query_val(1, 1, N, dfn[x], dfn[y], 0);
            xton = Query_min(1, 1, N, dfn[x], dfn[y]);
        }
    } else if (yton == -inf) {
        if (dep[x] > dep[y]) {
            yret = Query_val(1, 1, N, dfn[y], dfn[x], 1);
            yton = Query_max(1, 1, N, dfn[y], dfn[x]);
        } else {
            yret = Query_val(1, 1, N, dfn[x], dfn[y], 0);
            yton = Query_max(1, 1, N, dfn[x], dfn[y]);
        }
    } else if (dep[x] > dep[y]) {
        xret = max(xret, max(Query_val(1, 1, N, dfn[y], dfn[x], 1), Query_max(1, 1, N, dfn[y], dfn[x]) - xton));
        xton = min(xton, Query_min(1, 1, N, dfn[y], dfn[x]));
    } else {
        yret = max(yret, max(Query_val(1, 1, N, dfn[x], dfn[y], 0), yton - Query_min(1, 1, N, dfn[x], dfn[y])));
        yton = max(yton, Query_max(1, 1, N, dfn[x], dfn[y]));
    }
    int ret = max(max(xret, yret), yton - xton);
    return ret;
```

这题剩下的树上路径修改，我相信能来挑战这题的应该也不至于不会。所以代码就不贴了。接下来长达两百多行的完整代码奉上：
## 代码
```cpp
#include <iostream>
#define int long long
using namespace std;
const int N = 131072;
const int inf = 2147483647;
int head[1000005], nxt[1000005], to[1000005], cnt;
inline void add(int u, int v) { to[++cnt] = v, nxt[cnt] = head[u], head[u] = cnt; }
int dfn[1000005], top[1000005], son[1000005], dep[1000005], sz[1000005], f[1000005], ncnt;
int ww[N << 2], w[100005];
// ------------------------------------ 以下树剖板子 ---------------------------------
void dfs1(int x, int fa, int d) {
    dep[x] = d;
    f[x] = fa;
    sz[x] = 1;
    for (int i = head[x]; i != 0; i = nxt[i]) {
        int v = to[i];
        if (v != fa) {
            dfs1(v, x, d + 1);
            sz[x] += sz[v];
            if (sz[v] > sz[son[x]]) 
                son[x] = v;
        }
    }
}
void dfs2(int x, int t) {
    top[x] = t;
    dfn[x] = ++ncnt;
    ww[ncnt] = w[x];
    if (!son[x]) 
        return;
    dfs2(son[x], t);
    for (int i = head[x]; i != 0; i = nxt[i]) {
        int v = to[i];
        if (v != f[x] && v != son[x]) 
            dfs2(v, v);
    }
}
// ------------------------------------ 以下线段树 ---------------------------------------
int mx[N << 2], mn[N << 2], val[2][N << 2], tag[N << 2];
inline void pushup(int o) {
    mx[o] = max(mx[o << 1], mx[o << 1 | 1]);
    mn[o] = min(mn[o << 1], mn[o << 1 | 1]);
    val[0][o] = max(max(val[0][o << 1], val[0][o << 1 | 1]), mx[o << 1 | 1] - mn[o << 1]);
    // 从左往右合并
    val[1][o] = max(max(val[1][o << 1], val[1][o << 1 | 1]), mx[o << 1] - mn[o << 1 | 1]);
    // 从右往左合并
}
inline void pushdown(int o) {
    if (tag[o] == 0) 
        return;
    int t = tag[o];
    tag[o] = 0;
    mx[o << 1] += t, mx[o << 1 | 1] += t;
    mn[o << 1] += t, mn[o << 1 | 1] += t;
    tag[o << 1] += t, tag[o << 1 | 1] += t;
}
void Build(int o, int l, int r) {
    if (l == r) {
        mx[o] = mn[o] = ww[l];
        val[0][o] = val[1][o] = 0;
        return;
    }
    int mid = l + r >> 1;
    Build(o << 1, l, mid);
    Build(o << 1 | 1, mid + 1, r);
    pushup(o);
}
void Change(int o, int l, int r, int L, int R, int k) {
    if (L <= l && r <= R) {
        mx[o] += k;
        mn[o] += k;
        tag[o] += k;
        return;
    }
    pushdown(o);
    int mid = l + r >> 1;
    if (L <= mid) 
        Change(o << 1, l, mid, L, R, k);
    if (R > mid) 
        Change(o << 1 | 1, mid + 1, r, L, R, k);
    pushup(o);
}
int Query_min(int o, int l, int r, int L, int R) {
    if (L * R == 0) 
        return inf;
    if (L <= l && r <= R) 
        return mn[o];
    pushdown(o);
    int mid = l + r >> 1, ret = 2147483647;
    if (L <= mid) 
        ret = min(ret, Query_min(o << 1, l, mid, L, R));
    if (R > mid) 
        ret = min(ret, Query_min(o << 1 | 1, mid + 1, r, L, R));
    return ret;
}
int Query_max(int o, int l, int r, int L, int R) {
    if (L * R == 0) 
        return -inf;
    if (L <= l && r <= R) 
        return mx[o];
    pushdown(o);
    int mid = l + r >> 1, ret = -2147483647;
    if (L <= mid) 
        ret = max(ret, Query_max(o << 1, l, mid, L, R));
    if (R > mid) 
        ret = max(ret, Query_max(o << 1 | 1, mid + 1, r, L, R));
    return ret;
}
int Query_val(int o, int l, int r, int L, int R, int dir) {
    if (L * R == 0) 
        return 0;
    if (L <= l && r <= R) 
        return val[dir][o];
    pushdown(o);
    int mid = l + r >> 1, sl = 0, sr = 0, ret = 0;
    if (L <= mid) 
        ret = Query_val(o << 1, l, mid, L, R, dir), sl = 1;
    if (R > mid) 
        ret = max(ret, Query_val(o << 1 | 1, mid + 1, r, L, R, dir)), sr = 1;
    if (sl && sr) {
        ret = max(ret, 
            !dir ? 
            Query_max(1, 1, N, mid + 1, R) - Query_min(1, 1, N, L, mid) : 
            Query_max(1, 1, N, L, mid) - Query_min(1, 1, N, mid + 1, R));
    }
    return ret;
}
// ------------------------------------ 以下树剖 ---------------------------------------
int Query_path(int x, int y) {
    int xton = inf, yton = -inf, xret = 0, yret = 0;
    // xton 代表 u 到 x 之间的最小值，yton 代表 y 到 v 之间的最大值
    // xret 代表 u 到 x 之间的最大利润，yret 同理
    while (top[x] != top[y]) {
        if (dep[top[x]] > dep[top[y]]) {
            if (xton == inf) {
                xret = max(xret, Query_val(1, 1, N, dfn[top[x]], dfn[x], 1));
                xton = Query_min(1, 1, N, dfn[top[x]], dfn[x]);
            } else {
                xret = max(xret, max(Query_val(1, 1, N, dfn[top[x]], dfn[x], 1), 
                    Query_max(1, 1, N, dfn[top[x]], dfn[x]) - xton));
                xton = min(xton, Query_min(1, 1, N, dfn[top[x]], dfn[x]));
            }
            x = f[top[x]];
        } else {
            if (yton == -inf) {
                yret = max(yret, Query_val(1, 1, N, dfn[top[y]], dfn[y], 0));
                yton = Query_max(1, 1, N, dfn[top[y]], dfn[y]);
            } else {
                yret = max(yret, max(Query_val(1, 1, N, dfn[top[y]], dfn[y], 0), 
                    yton - Query_min(1, 1, N, dfn[top[y]], dfn[y])));
                yton = max(yton, Query_max(1, 1, N, dfn[top[y]], dfn[y]));
            }
            y = f[top[y]];
        }
    }
    if (xton == inf && yton == -inf) { // 都没跳过链
        if (dep[x] > dep[y]) 
            return Query_val(1, 1, N, dfn[y], dfn[x], 1); // 直接返回
        else 
            return Query_val(1, 1, N, dfn[x], dfn[y], 0);
    } else if (xton == inf) { // x 没跳过
        if (dep[x] > dep[y]) {
            xret = Query_val(1, 1, N, dfn[y], dfn[x], 1);
            xton = Query_min(1, 1, N, dfn[y], dfn[x]);
        } else {
            xret = Query_val(1, 1, N, dfn[x], dfn[y], 0);
            xton = Query_min(1, 1, N, dfn[x], dfn[y]);
        }
    } else if (yton == -inf) { // y 没跳过
        if (dep[x] > dep[y]) {
            yret = Query_val(1, 1, N, dfn[y], dfn[x], 1);
            yton = Query_max(1, 1, N, dfn[y], dfn[x]);
        } else {
            yret = Query_val(1, 1, N, dfn[x], dfn[y], 0);
            yton = Query_max(1, 1, N, dfn[x], dfn[y]);
        }
    } else if (dep[x] > dep[y]) { // 都跳过，但是 x 深度大
        xret = max(xret, max(Query_val(1, 1, N, dfn[y], dfn[x], 1), Query_max(1, 1, N, dfn[y], dfn[x]) - xton));
        xton = min(xton, Query_min(1, 1, N, dfn[y], dfn[x]));
    } else { // 都跳过，但是 y 深度大
        yret = max(yret, max(Query_val(1, 1, N, dfn[x], dfn[y], 0), yton - Query_min(1, 1, N, dfn[x], dfn[y])));
        yton = max(yton, Query_max(1, 1, N, dfn[x], dfn[y]));
    }
    int ret = max(max(xret, yret), yton - xton);
    // 合并左右区间答案
    return ret;
}
void Add(int x, int y, int k) {
    while (top[x] != top[y]) {
        if (dep[top[x]] < dep[top[y]]) 
            swap(x, y);
        Change(1, 1, N, dfn[top[x]], dfn[x], k);
        x = f[top[x]];
    }
    if (dep[x] > dep[y]) 
        swap(x, y);
    Change(1, 1, N, dfn[x], dfn[y], k);
}
// ----------------------------------平平无奇的主函数-----------------------------------------
signed main() {
    int n;
    cin >> n;
    for (int i = 1; i <= n; i++) cin >> w[i];
    for (int i = 1, u, v; i < n; i++) {
        cin >> u >> v;
        add(u, v);
        add(v, u);
    }
    dfs1(1, 0, 1);
    dfs2(1, 1);
    Build(1, 1, N);
    int m;
    cin >> m;
    while (m--) {
        int l, r, v;
        cin >> l >> r >> v;
        cout << Query_path(l, r) << "\n";
        Add(l, r, v);
    }
    return 0;
}
```
这题的分类讨论我想了很久，建议广大读者自己理解、消化这些奇奇怪怪的情况，想清楚各种分类的情况为什么是对应的贸易类型。想清楚这些，才算真正搞懂本题解之精神所在。

那么，
## ~完结撒花~~~
（撒花）（鼓掌）（欢呼）（撒花）

---

## 作者：intel_core (赞：3)

题面说的有点不太清楚，大体来说就是求树上一条链上两个数，后面-前面最大能是多少，询问之后还要把这条链的数都加上一个数。

因为是链上的问题，我们直接考虑树链剖分。

对于重链上连续的一段，我们用线段树维护这样几个值：

* 段内的最大答案 $ans$。

* 段内最大值 $mx$ ，最小值 $mn$。

* 整体下传的标记 $tag$。

把这些信息记录在一个 $\text{struct}$ 里，在信息合并的时候直接上传合并之后的新信息即可。

合并部分的代码（大体意思，不要在意 $\text{CE}$）：

```cpp
node merge(node r1,node r2){
	node new;
	new.mx=max(r1.mx,r2.mx);
 	new.mn=min(r1.mn,r2.mn);
	new.ans=max(max(r1.ans,r2.ans),r2.mx-r1.mn);	
}
```

重点在于 $\text{new.ans}$ 的计算，等号后面三个值代表两个数都在 $\text{mid}$ 左侧/右侧，两个数 $\text{mid}$ 两侧各一个的情况。

然后就可以套在树剖的板子里愉快的 $\text{AC}$ 掉这个题了。

（其实把要维护的信息封装起来在不同重链之间查询的时候也会写起来更方便不少。

因为树剖的板子写法有差异，完整代码就不贴了，$\text{merge}$ 函数已经具有足够的参考价值了。

---

## 作者：zhenjianuo2025 (赞：1)

### Solve

发现一条链上利润最大值可以用线段树维护，具体地，每个结点维护区间从左端点走到右端点的最大利润 $\text{sumlr}_u$，从右端点走到左端点的最大利润 $\text{sumrl}_u$，最大价格 $\text{mx}_u$，最小价格 $\text{mn}_u$。转移时，$\text{sumlr}_u=\max\{\text{sumlr}_{\text{lson}},\text{sumlr}_{\text{rson}},\text{mx}_{\text{rson}}-\text{mn}_{\text{lson}}\}$，$\text{sumrl}_u=\max\{\text{sumrl}_{\text{lson}},\text{sumrl}_{\text{rson}},\text{mx}_{\text{lson}}-\text{mn}_{\text{rson}}\}$。

于是想到树剖，记询问两点依次为 $u,v$，$u$ 和 $v$ 的最近公共祖先为 $\text{lca}$，$\text{lca}$ 可以通过倍增或者树剖得到。记录 $u$ 到 $\text{lca}$ 的路径上所有重链的询问结果， $v$ 到 $\text{lca}$ **下面那个结点**的路径上所有重链的询问结果。按照线段树的转移方式依次合并即可。关于 $\text{lca}$ 下面那个结点，可以倍增来求。

### Code
```cpp
#include <bits/stdc++.h>
using namespace std;
#define MAXN 50010
#define LOGN 22
int n, q, a[MAXN], fa[MAXN], anc[MAXN][LOGN], dis[MAXN], siz[MAXN], son[MAXN], tim, dfn[MAXN], top[MAXN], val[MAXN];
vector<int> g[MAXN];
inline void init(const int &u, const int &f) {
	siz[u] = 1;
	for (register int i = 0; i < g[u].size(); i++) {
		const int v = g[u][i];
		if (v == f) continue;
		fa[v] = u;
		anc[v][0] = u; 
		dis[v] = dis[u] + 1;
		init(v, u);
		siz[u] += siz[v];
		if (siz[son[u]] < siz[v]) son[u] = v;
	}
}
inline void dfs(const int &u, const int &p) {
	top[u] = p;
	dfn[u] = ++tim; val[tim] = u;
	if (!son[u]) return;
	dfs(son[u], p);
	for (register int i = 0; i < g[u].size(); i++) {
		const int v = g[u][i];
		if (v == fa[u] || v == son[u]) continue;
		dfs(v, v);
	}
}
struct Segment_Tree {
	int mx[MAXN << 2], mn[MAXN << 2], sumlr[MAXN << 2], sumrl[MAXN << 2], lzy[MAXN << 2];
	inline bool InRange(const int &l, const int &r, const int &L, const int &R) { return L <= l && R >= r; }
	inline bool OutoRange(const int &l, const int &r, const int &L, const int &R) { return r < L || R < l; }
	inline int merge(const int &fl, const int &fr, const int &mxr, const int &mnl) { return max(fl, max(fr, mxr - mnl)); }
	inline void pushup(const int &u) {
		mx[u] = max(mx[u << 1], mx[u << 1 | 1]);
		mn[u] = min(mn[u << 1], mn[u << 1 | 1]);
		sumlr[u] = max(-1000000000, merge(sumlr[u << 1], sumlr[u << 1 | 1], mx[u << 1 | 1], mn[u << 1]));
		sumrl[u] = max(-1000000000, merge(sumrl[u << 1], sumrl[u << 1 | 1], mx[u << 1], mn[u << 1 | 1]));
	}
	inline void maketag(const int &u, const int &w) {
		mx[u] += w; mn[u] += w;
		lzy[u] += w;
	}
	inline void pushdown(const int &u) {
		if (!lzy[u]) return;
		maketag(u << 1, lzy[u]); maketag(u << 1 | 1, lzy[u]);
		lzy[u] = 0;
	}
	inline void build(const int &u, const int &l, const int &r) {
		mx[u] = -1e9, mn[u] = 1e9, sumlr[u] = sumrl[u] = -1e9;
		if (l == r) {
			mx[u] = mn[u] = a[val[l]];
			return;
		}
		const int mid = (l + r) >> 1;
		build(u << 1, l, mid), build(u << 1 | 1, mid + 1, r);
		pushup(u);
	}
	inline void update(const int &u, const int &l, const int &r, const int &L, const int &R, const int &w) {
		if (InRange(l, r, L, R)) maketag(u, w);
		else if (!OutoRange(l, r, L, R)) {
			pushdown(u); 
			const int mid = (l + r) >> 1; update(u << 1, l, mid, L, R, w), update(u << 1 | 1, mid + 1, r, L, R, w);
			pushup(u);
		} 
	}
	inline pair<pair<int, int>, pair<int, int> > query(const int &u, const int &l, const int &r, const int &L, const int &R) {
		if (InRange(l, r, L, R)) return {{sumlr[u], sumrl[u]}, {mx[u], mn[u]}};
		else if (!OutoRange(l, r, L, R)) {
			pushdown(u);
			const int mid = (l + r) >> 1;
			if (R <= mid) return query(u << 1, l, mid, L, R);
			else if (L > mid) return query(u << 1 | 1, mid + 1, r, L, R);
			const pair<pair<int, int>, pair<int, int> > la = query(u << 1, l, mid, L, R), ra = query(u << 1 | 1, mid + 1, r, L, R);
			return {{merge(la.first.first, ra.first.first, ra.second.first, la.second.second), 
					  merge(la.first.second, ra.first.second, la.second.first, ra.second.second)}, 
					 {max(la.second.first, ra.second.first), min(la.second.second, ra.second.second)}};
		}
	}
} tree; 
inline int _lca(int u, int v) {
	while (top[u] != top[v]) {
		if (dis[top[u]] < dis[top[v]]) swap(u, v);
		u = fa[top[u]];
	}
	return (dis[u] < dis[v] ? u : v);
}
pair<pair<int, int>, pair<int, int> > tmp1[50010], tmp2[50010];
inline int query(int u, int v) {
	int lca = _lca(u, v), len1 = 0, len2 = 0;
	while (dis[top[u]] > dis[lca]) {
		tmp1[++len1] = tree.query(1, 1, n, dfn[top[u]], dfn[u]);
		u = fa[top[u]];
	}
	if (dfn[u] >= dfn[lca]) tmp1[++len1] = tree.query(1, 1, n, dfn[lca], dfn[u]);
	while (dis[top[v]] > dis[lca] + 1) {   // v 和 lca 下面那个点在同一个重链上 
		tmp2[++len2] = tree.query(1, 1, n, dfn[top[v]], dfn[v]);
		v = fa[top[v]];
	}
	if (dis[v] >= dis[lca] + 1) {
		int tmp = v;   // lca 下面那个点
		for (register int i = 20; i >= 0; i--)
			if (dis[anc[tmp][i]] >= dis[lca] + 1) tmp = anc[tmp][i]; 
		if (dfn[v] >= dfn[tmp]) tmp2[++len2] = tree.query(1, 1, n, dfn[tmp], dfn[v]);
	}
	int sum = -1e9, mx = -1e9, mn = 1e9;
	for (register int i = 1; i <= len1; i++) {
		swap(tmp1[i].first.first, tmp1[i].first.second);
		sum = tree.merge(sum, tmp1[i].first.first, tmp1[i].second.first, mn);
		mx = max(mx, tmp1[i].second.first);
		mn = min(mn, tmp1[i].second.second);
	}
	for (register int i = len2; i >= 1; i--) {
		sum = tree.merge(sum, tmp2[i].first.first, tmp2[i].second.first, mn);
		mx = max(mx, tmp2[i].second.first);
		mn = min(mn, tmp2[i].second.second);
	}
	return max(sum, 0);
}
inline void update(int u, int v, const int &w) {
	while (top[u] != top[v]) {
		if (dis[top[u]] < dis[top[v]]) swap(u, v);
		tree.update(1, 1, n, dfn[top[u]], dfn[u], w);
		u = fa[top[u]];
	}
	if (dfn[u] > dfn[v]) swap(u, v);
	tree.update(1, 1, n, dfn[u], dfn[v], w);
}
signed main() {
	cin >> n;
	for (register int i = 1; i <= n; i++) cin >> a[i];
	for (register int i = 1; i < n; i++) {
		int u, v;
		cin >> u >> v;
		g[u].push_back(v), g[v].push_back(u);
	}
	dis[1] = 1; init(1, 0); dfs(1, 1); tree.build(1, 1, n);
	for (register int j = 1; j <= 20; j++)
		for (register int i = 1; i <= n; i++)
			anc[i][j] = anc[anc[i][j - 1]][j - 1]; 
	cin >> q;
	while (q--) {
		int u, v, w;
		cin >> u >> v >> w;
		cout << query(u, v) << endl;
		update(u, v, w);
	}
	return 0;
} 
```


---

## 作者：tommymio (赞：1)

### 题意

给定一棵树，有 $Q$ 个询问，每次给出两个点 $a,b$，求满足 $\mathrm{dis}(a,c)<\mathrm{dis}(a,d)$ 的 $\max(val_d-val_c)$，其中 $val_x$ 为 $x$ 点的点权。支持路径加。

### 分析

毫无疑问树链剖分题。先用 $\mathrm{dfs}$ 序剖出每条链。然后我们现在先来考虑一条链的情况，可以直接使用线段树维护 $i>j,\max(v_i-v_j)$ 和 $i<j,\max(v_i-v_j)$，区间最大值，区间最小值。

再来考虑剖分时几条链之间的合并。只会存在两种情况：

- 答案在同一条链上。这种情况线段树已经维护了。
- 答案在不同链上。这种情况线段树没有维护，跳 $\text{LCA}$ 的时候根据 $a,b$ 分类讨论一下，试图更新答案。

时间复杂度 $O(n \log^2 n)$，很好想，代码就不贴了。



---

## 作者：Newuser (赞：1)

原本如果这只是 一道线段树题还是 十分简单的。对于一个区间，其路径最大差值为其max:右儿子最大差值,左儿子最大差值,右儿子MAX-左儿子MIN（或者左儿子MAX-右儿子MIN），对于这样的要返回多权值的问题，线段树传递结构体比较容易。想要做的可以转向–》水果姐系列。

但是这道题是在一个普通的树上进行的，我们就很容易想到用树链剖分来解决这个问题了。注意到要解决好一个方向怎么把控的问题。因为我们在树剖一步一步一步往上爬的时候，从询问起点往上爬和询问终点往上爬是不一样的。我的处理方式是每次都进行判断是线段树左到右还是右到左扫最大差值，之后将每段区间内的min和max记录下来（分别开两个数组从起点爬的和终点爬的），之后再将这一大段区间的min和max连接成一条链，直接暴力跑一次区间最大差值，得到最大答案就是了。

说得容易真的写得很恶心啊！！！

talk is cheap , show the code:

	#include<cstdio>
	#include<iostream>
	#include<algorithm>
	#define ls (p<<1)
	#define rs (p<<1|1)
	#define midd ((l+r)>>1)
	using namespace std;
	const int maxn=(int)5e5+5;
	int n;
	int fa[maxn];
	int owo,la[maxn],nt[maxn],en[maxn];
	inline void addedge(int a,int b)
	{
    en[++owo]=b; nt[owo]=la[a]; la[a]=owo;
	}
	int 	oldid[maxn],dep[maxn],top[maxn],newid[maxn],idcnt,siz[maxn],zerz[maxn],oldp[maxn];
	void fzb(int x,int ba)
	{
    dep[x]=dep[ba]+1; fa[x]=ba;
    int maxsize=0; zerz[x]=0; siz[x]=1;
    for(int it=la[x];it;it=nt[it])
    {
        if(en[it]==ba) continue;
        fzb(en[it],x);
        siz[x]+=siz[en[it]];
        if(siz[en[it]]>maxsize)
        {
            maxsize=siz[en[it]];
            zerz[x]=en[it];
        }
    }
	}
	void lzb(int x,int ace)
	{
    top[x]=ace; newid[x]=++idcnt; oldid[idcnt]=x;
    if(zerz[x]) lzb(zerz[x],ace);
    for(int it=la[x];it;it=nt[it])
    {
        if(en[it]==zerz[x]||en[it]==fa[x]) continue;
        lzb(en[it],en[it]);
    }
	}
	struct node
	{
    int minn,maxx,ltormax,rtolmax,lazy;
	}z[maxn<<3];
	inline void putup(int p)
	{
    z[p].maxx = max( z[ls].maxx , z[rs].maxx );
    z[p].minn = min( z[ls].minn , z[rs].minn );
    z[p].ltormax = max( z[ls].ltormax , max( z[rs].ltormax , z[rs].maxx - z[ls].minn ) );
    z[p].rtolmax = max( z[ls].rtolmax , max( z[rs].rtolmax , z[ls].maxx - z[rs].minn ) );
	}
	inline void putdowm(int p,int l,int r)
	{
    if(l==r) { z[p].lazy=0; return; }
    z[ls].lazy +=z[p].lazy; z[rs].lazy+=z[p].lazy;
    z[ls].maxx += z[p].lazy ; z[ls].minn +=z[p].lazy ;
    z[rs].maxx += z[p].lazy ; z[rs].minn +=z[p].lazy ;
    z[p].lazy = 0; 
	}
	node query(int p,int l,int r,int x,int y,int mark)
	{
    if(x<=l&&r<=y) 
    {
        return z[p];
    }
    if(z[p].lazy) putdowm(p,l,r);
    if(x>=midd+1)
    {
        return query(rs,midd+1,r,x,y,mark);
    }
    else if(y<=midd)
    {
        return query(ls,l,midd,x,y,mark);
    }
    node lll=query(ls,l,midd,x,y,mark);
    node rrr=query(rs,midd+1,r,x,y,mark);
    node aha;
    if(mark==1)
    {
        aha.rtolmax=max(lll.rtolmax,max(rrr.rtolmax,lll.maxx-rrr.minn));
        aha.maxx=max(lll.maxx,rrr.maxx);
        aha.minn=min(lll.minn,rrr.minn);
    }
    else 
    {
        aha.ltormax=max(lll.ltormax,max(rrr.ltormax,rrr.maxx-lll.minn));
        aha.maxx=max(lll.maxx,rrr.maxx);
        aha.minn=min(lll.minn,rrr.minn);
    }
    return aha;
	}
	int  xl[maxn],xr[maxn],yl[maxn],yr[maxn];
	int qqq(int x,int y)
	{
    int cntx=0,cnty=0; int ans=0;
    while(top[x]!=top[y])
    {
        if(dep[top[x]]>dep[top[y]])
        {
            node aha=query(1,1,n,newid[top[x]],newid[x],1);
            ans=max(ans,aha.rtolmax);
            xl[++cntx]=aha.minn; xr[cntx]=aha.maxx;
            x=fa[top[x]];
        }
        else
        {
            node aha=query(1,1,n,newid[top[y]],newid[y],2);
            ans=max(ans,aha.ltormax);
            yl[++cnty]=aha.minn; yr[cnty]=aha.maxx;
            y=fa[top[y]];
        }
    }
    if(dep[x]>dep[y])
    {
        node  aha=query(1,1,n,newid[y],newid[x],1);
        xl[++cntx]=aha.minn; xr[cntx]=aha.maxx;
        ans=max(ans,aha.rtolmax);
    }
    else
    {
        node aha=query(1,1,n,newid[x],newid[y],2);
        yl[++cnty]=aha.minn; yr[cnty]=aha.maxx;
        ans=max(ans,aha.ltormax);
    }
    for(int i=cnty;i>=1;i--)
    {
        xl[++cntx]=yl[i]; xr[cntx]=yr[i];//这里将他们连接成一条链子
    }
    int minn=0x3f3f3f3f;
    for(int i=1;i<=cntx;i++)
    {
        ans=max(ans,xr[i]-minn);
        minn=min(minn,xl[i]);
    }
    int maxx=-0x3f3f3f3f;
    for(int i=cntx;i>=1;i--)
    {
        ans=max(ans,maxx-xl[i]);
        maxx=max(maxx,xr[i]); 
    }//暴力跑最大差值
    if(ans<0) return 0; 
    return ans;
	}
	void maketree(int p,int l,int r)
	{
    if(l<r)
    {
        maketree(ls,l,midd);
        maketree(rs,midd+1,r);
        putup(p);
    }
    else
    {
        z[p].minn = z[p].maxx =  oldp[ oldid[l] ]; 
        z[p].ltormax = z[p].rtolmax = z[p].lazy =0;
    }
	}
	void change(int p,int l,int r,int x,int y,int cc)
	{
    if( x<=l&&r<=y ) { z[p].maxx+=cc; z[p].minn+=cc; z[p].lazy+=cc; return; }
    if(z[p].lazy) putdowm(p,l,r);
    if(x<=midd&&y>=l) change(ls,l,midd,x,y,cc);
    if(x<=r&&y>=midd+1) change(rs,midd+1,r,x,y,cc);
    putup(p);
	}
	void ccc(int a,int b,int c)
	{
    while(top[a]!=top[b])
    {
        if(dep[top[a]]<dep[top[b]]) swap(a,b);
        change(1,1,n,newid[top[a]],newid[a],c);
        a=fa[top[a]];
    }
    if(dep[a]>dep[b]) swap(a,b);
    change(1,1,n,newid[a],newid[b],c);
	}
	void ts(int p,int l,int r)
	{
    if(z[p].lazy) putdowm(p,l,r);
    if(l<r)
    {
        ts(ls,l,midd);
        ts(rs,midd+1,r);
    }
    else cout<<z[p].maxx<<' ';
	}
	int main()
	{
    scanf("%d",&n);
    for(int i=1;i<=n;i++) scanf("%d",&oldp[i]);
    int a,b,c;
    for(int i=1;i<n;i++)
    {
        scanf("%d%d",&a,&b);
        addedge(a,b); addedge(b,a);
    }
    fzb(1,0); lzb(1,1); maketree(1,1,n);
    int q; scanf("%d",&q);
    while(q--)
    {
        scanf("%d%d%d",&a,&b,&c);
        printf("%d\n",qqq(a,b));
        ccc(a,b,c);
	//        ts(1,1,n); putchar(10);
    }
	} 
欢迎来本蒟蒻博客：www.newuser.top 看看！

---

## 作者：djh0314 (赞：0)

[**传送门**](https://www.luogu.com.cn/problem/P3976)        

## 题意

有一棵 $n$ 个节点的树，每个节点有一个权值。    
有 $q$ 此操作，每次操作由 $u$ 沿最短路径到达 $v$，求 $val_i-val_j$ 的最大值，（$i$，$j$ 位于此最短路径上，且先经过 $i$，再经过 $j$），经过后，此路径上所有点的价值上升 $v$。

## 分析

作为一道树形并且是最短路径的题，我们当然先从序列上思考。

显然是用线段树来维护，重点又变成了区间上的合并。

先思考从左到右，我们合并后的总区间的答案，只有三种可能：       
1. 左区间买，左区间卖。
2. 左区间买，右区间卖。
3. 右区间买，右区间卖。

对于第一种与第三种情况，我们可以直接从左区间与右区间继承，作为第二种，显然是从左区间的最小值买，右区间的最大值卖，之后就可以维护好我们的区间合并。由于不止左至右，我们同时需要维护右到左。

我们使用结构体来维护我们的这个区间的左至右的答案，右至左的答案，区间最大值，区间最小值。        
~~~cpp
struct node {
	int mx,mn,c1,c2;//c1 左至右  c2 右至左
	inline friend node operator + (node fi,node se) {
		node res;
		res.mx=max(fi.mx,se.mx);
		res.mn=min(fi.mn,se.mn);
		res.c1=max(max(fi.c1,se.c1),se.mx-fi.mn);
		res.c2=max(max(fi.c2,se.c2),fi.mx-se.mn);
		return res;
	}
}
~~~

维护好了区间，我们自然解决了序列上的该问题，至于放在树上，我们自然可以用树链剖分来解决。

在维护树上答案时，我们的左端点时在祖先，因此我们两条链的合并还需要重新解决。

~~~cpp
dfs(1,0);
redfs(1,1);
tree.build(1,1,n);
int Q=read();
while(Q--) {
	int u=read(),v=read(),x=read();
	int lca=LCA(u,v);
	if(lca==u) {
		node res=query(v,lca);
		cout<<res.c1<<"\n";
	} else if(lca==v) {
		node res=query(u,lca);
		cout<<res.c2<<"\n";
	} else {
		node l=query(u,lca),r=query(v,lca);
		cout<<max(max(l.c2,r.c1),r.mx-l.mn)<<"\n";
	}
	change(u,v,x);
}
~~~

### 总结一下，这道题我们使用了线段树的结构体合并，以及树链剖分的作用。

---

## 作者：SrsgPrince_ (赞：0)

# Luogu P3976 [TJOI2015] 旅游 Solution

题面传送门：[Luogu P3976 [TJOI2015] 旅游](https://www.luogu.com.cn/problem/P3976)。

推荐在我的 [博客](https://www.luogu.com.cn/blog/fy123333/LuoguP3976Solution) 中查看。

## 题目分析 Hint

题目有点绕，形式化题面大概是：给定一棵树，每次询问从节点 $a$ 走到节点 $b$ 上选择两个节点 $u$ 和 $v$（$dist_{a, u} < dist_{a, v}$），并且要让在 $v$ 处的权值减去 $u$ 处的权值最大，并求这个最大值，并且要维护每一个点权值的修改。

## 思路 Solution

这道题不只是序列修改的简单线段树维护最大最小值同时区间加，有一个 $dist_{a, u} < dist_{a, v}$ 的条件，因此是树上的修改，所以使用树剖做。

首先根据题，我们不是简单的维护最大最小值，在计算答案的时候我们会出问题。我们能发现，从不同方向走一段路的答案并不一样，因此考虑从左到右的最大值和从右到左的最大值，以便于合并答案。简单列一下用线段树维护的以下几个信息：

1. $mx$，表示最大值。
2. $mn$，表示最小值。
3. $lmx$，表示这一段区间上从左到右的最大值。
4. $rmx$，表示这一段区间上从右到左的最大值。
5. $tag$，表示区间加的标记。

接下来是区间信息的合并：

1. $mx$ 是左右儿子的 $mx$ 的最大值。
2. $mn$ 是左右儿子的 $mn$ 的最小值。
3. $lmx$ 在不跨区间的情况下直接是左右儿子的 $lmx$，跨区间的情况是左儿子的 $mx$ 减去右儿子的 $mn$，信息取 $\max(mx_{lson} - mn_{rson}, lmx_{lson}, lmx_{rson})$。
4. $rmx$ 在不跨区间的情况下直接是左右儿子的 $rmx$，跨区间的情况是右儿子的 $mx$ 减去左儿子的 $mn$，信息取 $\max(mx_{rson} - mn_{lson}, rmx_{lson}, rmx_{rson})$。

然后是树剖。在往上跳链的时候如果是起点一端的，就把查询的结果和起点一端的已经跳过的信息合并，反之则和终点一端已经跳过的信息合并。

~~写完这个有种最长解的感觉。~~

接下来给出重要代码。

```cpp
struct Edge {
    int des, nxt;
} ed[maxn << 1];
inline void addEdge(int b, int e) {
    ed[++cnt] = (Edge){e, head[b]};
    head[b] = cnt;
}
struct KamisatoAyaka {
    int lft, rgt, lmax, rmax, tag, maxx, minn;
    KamisatoAyaka() {
        lft = rgt = maxx = minn = tag = 0;
        lmax = rmax = 0;
    }
    inline bool operator == (const KamisatoAyaka &rhs) const {
        return lft == rhs.lft && rgt == rhs.rgt && maxx == rhs.maxx && minn == rhs.minn && lmax == rhs.lmax && rmax == rhs.rmax && tag == rhs.tag;
    }
} ayaka[maxn << 2];
inline void pushUp(int p) {
    ayaka[p].maxx = max(ayaka[p << 1].maxx, ayaka[p << 1 | 1].maxx); // 左右儿子 maxx 的最大值
	ayaka[p].minn = min(ayaka[p << 1].minn, ayaka[p << 1 | 1].minn); // 左右儿子 minn 的最小值
	ayaka[p].lmax = max(ayaka[p << 1].maxx - ayaka[p << 1 | 1].minn, max(ayaka[p << 1].lmax, ayaka[p << 1 | 1].lmax)); // 左右儿子的 lmax 与 左儿子的 maxx 和 右儿子的 minn 的最大值
	ayaka[p].rmax = max(ayaka[p << 1 | 1].maxx - ayaka[p << 1].minn, max(ayaka[p << 1].rmax, ayaka[p << 1 | 1].rmax)); // 左右儿子的 rmax 与 右儿子的 maxx 和 左儿子的 minn 的最大值
}
inline void pushDown(int p) {
    ayaka[p << 1].maxx += ayaka[p].tag;
    ayaka[p << 1].minn += ayaka[p].tag;
    ayaka[p << 1 | 1].maxx += ayaka[p].tag;
    ayaka[p << 1 | 1].minn += ayaka[p].tag;
    ayaka[p << 1].tag += ayaka[p].tag;
    ayaka[p << 1 | 1].tag += ayaka[p].tag;
    ayaka[p].tag = 0;
}
inline KamisatoAyaka merge(KamisatoAyaka lft, KamisatoAyaka rgt) {
    // 信息的合并部分
    KamisatoAyaka res;
    res.maxx = max(lft.maxx, rgt.maxx);
	res.minn = min(lft.minn, rgt.minn);
	res.lmax = max(lft.maxx - rgt.minn, max(lft.lmax, rgt.lmax));
	res.rmax = max(rgt.maxx - lft.minn, max(lft.rmax, rgt.rmax));
	return res;
}
inline void buildTree(int p, int lft, int rgt) {
    ayaka[p].lft = lft;
    ayaka[p].rgt = rgt;
    if (lft == rgt) {
        ayaka[p].maxx = a1[lft];
        ayaka[p].minn = a1[lft];
        return;
    }
    int mid = (lft + rgt) >> 1;
    buildTree(p << 1, lft, mid);
    buildTree(p << 1 | 1, mid + 1, rgt);
    pushUp(p);
}
inline void update(int p, int lft, int rgt, int k) {
    if (ayaka[p].lft >= lft && ayaka[p].rgt <= rgt) {
        ayaka[p].maxx += k;
        ayaka[p].minn += k;
        ayaka[p].tag += k;
        return;
    }
    if (ayaka[p].tag)
        pushDown(p);
    int mid = (ayaka[p].lft + ayaka[p].rgt) >> 1;
    if (lft <= mid) 
        update(p << 1, lft, rgt, k);
    if (rgt > mid)
        update(p << 1 | 1, lft, rgt, k);
    pushUp(p);
}
inline KamisatoAyaka query(int p, int lft, int rgt) {
    if (ayaka[p].lft >= lft && ayaka[p].rgt <= rgt)
        return ayaka[p];
    if (ayaka[p].tag)
        pushDown(p);
    int mid = (ayaka[p].lft + ayaka[p].rgt) >> 1;
    if (rgt <= mid)
        return query(p << 1, lft, rgt);
    if (lft > mid)
        return query(p << 1 | 1, lft, rgt);
    return merge(query(p << 1, lft, rgt), query(p << 1 | 1, lft, rgt));
}
inline void routeUpdate(int lft, int rgt, int k) {
    while (top[lft] != top[rgt]) {
        if (dep[top[lft]] < dep[top[rgt]])
            swap(lft, rgt);
        update(1, dfn[top[lft]], dfn[lft], k);
        lft = fa[top[lft]];
    }
    if (dep[lft] > dep[rgt])
        swap(lft, rgt);
    update(1, dfn[lft], dfn[rgt], k);
}
inline int routeQuery(int l, int r) {
    KamisatoAyaka lft, rgt;
    lft.minn = rgt.minn = 2e9;
    while (top[l] != top[r]) {
        if (dep[top[l]] < dep[top[r]]) {
            rgt = merge(query(1, dfn[top[r]], dfn[r]), rgt);
            r = fa[top[r]];
        } else {
            lft = merge(query(1, dfn[top[l]], dfn[l]), lft);
            l = fa[top[l]];
        }
    }
    if (dep[l] > dep[r])
        lft = merge(query(1, dfn[r], dfn[l]), lft);
    else 
        rgt = merge(query(1, dfn[l], dfn[r]), rgt);
    swap(lft.lmax, lft.rmax);
    return merge(lft, rgt).rmax;
}
inline void dfs1(int u, int f) {
    fa[u] = f;
    siz[u] = 1;
    dep[u] = dep[f] + 1;
    for (int i = head[u]; ~i; i = ed[i].nxt) {
        int v = ed[i].des;
        if (v == f) continue;
        dfs1(v, u);
        siz[u] += siz[v];
        if (siz[v] > siz[chd[u]])
            chd[u] = v;
    }
}
inline void dfs2(int u, int tp) {
    top[u] = tp;
    dfn[u] = ++tot;
    a1[tot] = a[u];
    if (!chd[u]) return;
    dfs2(chd[u], tp);
    for (int i = head[u]; ~i; i = ed[i].nxt) {
        int v = ed[i].des;
        if (v == fa[u] || v == chd[u]) continue;
        dfs2(v, v);
    }
}
```


---

## 作者：AIskeleton (赞：0)

前置芝士：树链剖分、线段树。

首先树剖套线段树是显然的~~因为标签这么写~~。

**线段树维护什么？**

如果只维护区间最小值和区间最大值似乎不足以解决问题。

题目要求区间最值之差，而且可以发现，对于同一个区间，从左到右和从右到左所得到的答案是不同的，所以要按方向不同分开维护。

所以线段树维护四个值：

1.区间最大值。

2.区间最小值。

3.从左至右的最值之差。

4.从右至左的最值之差。

**需要什么标记？**

因为只有区间加一种操作，所以只需一个加法懒标记即可。

**如何合并和维护？**

* 区间最大值和区间最小值的维护和合并就是板子，不再赘述。区间加的操作也一样。

* 从左至右的最值之差的合并：如果不跨区间，就是两个子节点各自的从左至右的最值之差的最大值；如果跨区间，就是左儿子的最小值和右儿子的最大值之差。

* 从右至左的最值之差的合并：如果不跨区间，就是两个子节点各自的从右至左的最值之差的最大值；如果跨区间，就是右儿子的最小值和左儿子的最大值之差。

合并部分的代码：

```
tree merge(tree x,tree y)
{
	tree t;
    t.mi=min(x.mi,y.mi);
    t.ma=max(x.ma,y.ma);//最大值和最小值的合并
	t.lm=max(x.ma-y.mi,max(x.lm,y.lm));
    t.rm=max(y.ma-x.mi,max(x.rm,y.rm));//最值之差的合并要分三种情况
    return t;
}
```

**树剖如何操作？**

与[染色](https://www.luogu.com.cn/problem/P2486)这道题类似，用两个结构体变量存储当前已经跳过的部分的信息。

因为在树上，“左”、‘右’的划分应变为时间戳的大小，而跳链的操作是从下往上，即时间戳从大到小，所以结构体中存储的信息是在“右边”的，在合并的过程中要注意这一点。

求值操作的代码：

```
void c_q(int u,int v)
{
	tree L,R;L.mi=R.mi=INF;//存储信息的结构体
	while(t[u]!=t[v])
		if(d[t[u]]<d[t[v]])
        {
        	R=merge(query(1,id[t[v]],id[v]),R);//合并过程中，结构体在右
            v=fa[t[v]];
        }
		else
        {
        	L=merge(query(1,id[t[u]],id[u]),L);
            u=fa[t[u]];
        }
	if(d[u]>d[v])L=merge(query(1,id[v],id[u]),L);
    else R=merge(query(1,id[u],id[v]),R);
    swap(L.lm,L.rm);//合并两个结构体的信息，其中L的左右最值差要交换
    cout<<merge(L,R).rm<<endl;
}
```

[完整的代码](https://www.luogu.com.cn/paste/h40ftbkh)

---

## 作者：registerGen (赞：0)

本文同步发表于 [cnblogs](https://www.cnblogs.com/registergen/p/p3976_solution.html)。

我来发一个有图的题解，希望大家看着图能更明白。

## Solution

这个题应该比较好想。如果这是一个序列上的问题，我们就可以用线段树维护一个区间右减左的答案，左减右的答案：

```cpp
struct Node{
	int mx,mn,lr,rl,atag; // 区间最大值，最小值，左减右，右减左，区间加标记
	Node(){mx=lr=rl=-inf,mn=inf,atag=0;}
};

// 合并两个区间
inline Node pushUp(const Node &L,const Node &R){
	Node res;
	res.mx=std::max(L.mx,R.mx);
	res.mn=std::min(L.mn,R.mn);
	res.lr=std::max(std::max(L.lr,R.lr),L.mx-R.mn);
	res.rl=std::max(std::max(L.rl,R.rl),R.mx-L.mn);
	return res;
}

// 下传区间加标记
inline void pushA(Node &x,int atag){
	x.atag+=atag;
	x.mx+=atag;
	x.mn+=atag;
}
```

然后因为这是一个树上的问题，所以我们要树剖。然而这个题是那种类似 [GSS7](https://www.luogu.com.cn/problem/SP6779) 的毒瘤题，所以合并的时候要考虑顺序。

来放几张图：

因为 $dfn_w\le dfn_u$，所以合并一条链应该是用上面的去合并下面的：

![](https://cdn.luogu.com.cn/upload/image_hosting/aqaszn61.png)

因为 $dfn_w\le dfn_u,dfn_w\le dfn_v$，所以合并之后的顺序是这样的：

![](https://cdn.luogu.com.cn/upload/image_hosting/r5rw6kxi.png)

于是我们需要交换一下 $u\leftrightarrow w$ 这条链上的 `lr` 和 `rl`，之后就变成了这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/lg46ehv7.png)

最后把两条链合并即可。

## Code

```cpp
#include<cstdio>
#include<algorithm>

const int N=5e4;
const int inf=0x3f3f3f3f;

struct Edge{int to,nxt;}e[N*2+10];int head[N+10],tote;
inline void addEdge(int u,int v){e[++tote].to=v;e[tote].nxt=head[u];head[u]=tote;}

struct Node{
	int mx,mn,lr,rl,atag;
	Node(){mx=lr=rl=-inf,mn=inf,atag=0;}
};

int n,m,a[N+10];
int fa[N+10],dep[N+10],siz[N+10],son[N+10],dfn[N+10],rk[N+10],top[N+10],cnt;
Node t[N*4+10];

#define ls(x) (x<<1)
#define rs(x) (x<<1|1)

inline Node pushUp(const Node &L,const Node &R){
	Node res;
	res.mx=std::max(L.mx,R.mx);
	res.mn=std::min(L.mn,R.mn);
	res.lr=std::max(std::max(L.lr,R.lr),L.mx-R.mn);
	res.rl=std::max(std::max(L.rl,R.rl),R.mx-L.mn);
	return res;
}

inline void pushA(Node &x,int atag){
	x.atag+=atag;
	x.mx+=atag;
	x.mn+=atag;
}

inline void pushDown(int i){
	if(t[i].atag){
		pushA(t[ls(i)],t[i].atag);
		pushA(t[rs(i)],t[i].atag);
		t[i].atag=0;
	}
}

void build(int i,int l,int r){
	if(l==r){
		t[i].mn=t[i].mx=a[rk[l]];
		t[i].lr=t[i].rl=0;
		return;
	}
	int mid=(l+r)>>1;
	build(ls(i),l,mid);
	build(rs(i),mid+1,r);
	t[i]=pushUp(t[ls(i)],t[rs(i)]);
}

void modify(int i,int l,int r,int ql,int qr,int x){
	if(ql<=l&&r<=qr)return pushA(t[i],x),void();
	int mid=(l+r)>>1;
	pushDown(i);
	if(ql<=mid)modify(ls(i),l,mid,ql,qr,x);
	if(qr>mid) modify(rs(i),mid+1,r,ql,qr,x);
	t[i]=pushUp(t[ls(i)],t[rs(i)]);
}

Node query(int i,int l,int r,int ql,int qr){
	if(ql<=l&&r<=qr)return t[i];
	int mid=(l+r)>>1;
	pushDown(i);
	if(ql>mid) return query(rs(i),mid+1,r,ql,qr);
	if(qr<=mid)return query(ls(i),l,mid,ql,qr);
	return pushUp(query(ls(i),l,mid,ql,qr),query(rs(i),mid+1,r,ql,qr));
}

#undef ls
#undef rs

void DFS1(int u,int _fa){
	fa[u]=_fa;
	dep[u]=dep[_fa]+1;
	siz[u]=1;
	for(int i=head[u];i;i=e[i].nxt){
		int v=e[i].to;
		if(v==_fa)continue;
		DFS1(v,u);
		siz[u]+=siz[v];
		if(siz[v]>siz[son[u]])son[u]=v;
	}
}

void DFS2(int u,int _fa,int _top){
	dfn[u]=++cnt,rk[cnt]=u;
	top[u]=_top;
	if(son[u])DFS2(son[u],u,_top);
	for(int i=head[u];i;i=e[i].nxt){
		int v=e[i].to;
		if(v==_fa||v==son[u])continue;
		DFS2(v,u,v);
	}
}

void modify(int u,int v,int x){
	while(top[u]!=top[v]){
		if(dep[top[u]]<dep[top[v]])std::swap(u,v);
		modify(1,1,n,dfn[top[u]],dfn[u],x);
		u=fa[top[u]];
	}
	if(dfn[u]>dfn[v])std::swap(u,v);
	modify(1,1,n,dfn[u],dfn[v],x);
}

Node query(int u,int v){
	Node L,R;
	while(top[u]!=top[v]){
		if(dep[top[u]]>dep[top[v]]){
			L=pushUp(query(1,1,n,dfn[top[u]],dfn[u]),L);
			u=fa[top[u]];
		}
		else{
			R=pushUp(query(1,1,n,dfn[top[v]],dfn[v]),R);
			v=fa[top[v]];
		}
	}
	if(dfn[u]<dfn[v])
		R=pushUp(query(1,1,n,dfn[u],dfn[v]),R);
	else
		L=pushUp(query(1,1,n,dfn[v],dfn[u]),L);
	std::swap(L.lr,L.rl);
	return pushUp(L,R);
}

int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
		scanf("%d",a+i);
	for(int i=1;i<n;i++){
		int u,v;scanf("%d%d",&u,&v);
		addEdge(u,v),addEdge(v,u);
	}
	DFS1(1,0),DFS2(1,0,1),build(1,1,n);
	scanf("%d",&m);
	while(m--){
		int u,v,x;scanf("%d%d%d",&u,&v,&x);
		Node ans=query(u,v);
		printf("%d\n",std::max(0,ans.rl));
		modify(u,v,x);
	}
	return 0;
}
```

---


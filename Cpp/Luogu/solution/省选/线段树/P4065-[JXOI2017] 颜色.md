# [JXOI2017] 颜色

## 题目描述

可怜有一个长度为 $n$ 的正整数序列 $A_i$，其中相同的正整数代表着相同的颜色。

现在可怜觉得这个序列太长了，于是她决定选择一些颜色把这些颜色的所有位置都删去。

删除颜色 $i$ 可以定义为把所有满足 $A_j = i$ 的位置 $j$ 都从序列中删去。

然而有些时候删去之后，整个序列变成了好几段，可怜不喜欢这样，于是她想要知道有多少种删去颜色的方案使得最后剩下来的序列非空且连续。

例如颜色序列 $\{1, 2, 3, 4, 5\}$，删除颜色 $3$ 后序列变成了 $\{1, 2\}$ 和 $\{4, 5\}$ 两段，不满足条件。而删除颜色 $1$ 后序列变成了 $\{2, 3, 4, 5\}$，满足条件。

两个方案不同当且仅当至少存在一个颜色 $i$ 只在其中一个方案中被删去。


## 说明/提示

满足条件的删颜色方案有 $\{1\}, \{1, 3\}, \{1, 2, 3\}, \{1, 3, 4\}, \{2, 3, 4\}, \varnothing$。

对于 $20\%$ 的数据，保证 $1 \le \sum n \le  20$。

对于 $40\%$ 的数据，保证 $1 \le \sum n \le  500$。

对于 $60\%$ 的数据，保证 $1 \le \sum n \le  10^4$。

对于 $100\%$ 的数据，保证 $1 \le  T,\sum n \le  3 \times 10^5, 1 \le  A_i \le  n$。

$\text{Statement fixed by @Starrykiller.}$

## 样例 #1

### 输入

```
1
5
1 3 2 4 3```

### 输出

```
6```

# 题解

## 作者：Iscream2001 (赞：40)

提供一个不用自己写数据结构过此题的题解。。。

合法的区间就是包含所有的在区间内出现过得颜色。。

这种题有一种神奇的hash做法。。。

我们给所有颜色相同的位置赋一个值，使得同色的位置的值加起来等于0

然后统计答案的方法比较显然，维护一个前缀和，然后两个前缀和相同的位置就可以搞出一个合法区间。。

至于这种做法的正确性。。。感觉记得某大佬曾经证过。。。但是窝不会。。。

代码

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<ctime>
#include<cstdlib>
#include<vector>
#include<map>
#define LL long long
using namespace std;
const int N=3e5+10;
const LL mod=1e12;
int n;
int a[N];
map<LL,LL> mp;
LL f[N];
vector<int> ve[N];
int main(){
    int T;scanf("%d",&T);
    LL re=0,x,op,ans=0;
    while(T--){
        scanf("%d",&n);ans=0;
        for(int i=1;i<=n;++i){
            scanf("%d",&a[i]);
            ve[a[i]].push_back(i);
        }
        for(int i=1;i<=n;++i){
            if(ve[i].size()==0) continue;
            if(ve[i].size()==1) f[ve[i][0]]=0;
            re=0;
            for(int j=0;j<ve[i].size()-1;++j){
                x=rand()*rand()%mod*rand()%mod*rand()%mod;
                op=rand()&1;if(op) x=-x;
                f[ve[i][j]]=x;re+=x;
            }
            f[ve[i][ve[i].size()-1]]=-re;
        }
        mp.clear();re=0;mp[0]=1;
        for(int i=1;i<=n;++i){
            re+=f[i];
            ans+=mp[re];
            ++mp[re];
        }
        printf("%lld\n",ans);
        for(int i=1;i<=n;++i) ve[i].clear();
    }
    return 0;
}
```


---

## 作者：shadowice1984 (赞：28)

非常传统的一道线段树题？

下面以这道题为例介绍一下线段树的经典应用——求点对贡献

# 本题题解

我们发现删完颜色之后剩余元素必定是一个连续的区间~~(这不是题目要求嘛)~~

显然两个不同的连续区间对应着两个不同的删除颜色方案

所以我们统计方案数可以转化为统计有多少个不同的合法区间

而区间是可以被描述为点对的。

所以下面就是经典的求点对的总贡献的统计问题了。

对于这种问题我们的解决方案永远是一个——先枚举一个端点，再用数据结构解决另外一个端点(通常是线段树)

换句话讲，我们对于每个右端点，求出有多少个合法左端点，加在一起就是答案

那么对于这道题我们也是相同的思路统计，我们现在枚举右端点

假设我们枚举的右端点是i

我们考虑一个左端点l在什么时候合法

显然i之后的所有颜色要被删去，所以我们发现整个序列会被切割成几个小段

而这个l只能在和i在同一个区间里

我们设**颜色**为i的点的位置最大值为$max_{i}$，位置最小值为$min_{i}$

显然所有$max_{k}$大于$i$的颜色都会被删去，因此合法左端点至少保证在它和i之间不存在一定会被删去的颜色

**也就是说我们要找到$max_{col_{j}}$大于$i$，且离i最近的点j**

然后我们选择的左端点就必须在j~i之间，且不能选j

(显然j~i里边的点至少不会被删去(因为最右的颜色还是在i以内)，但是越过j之后因为j的颜色一定会被删掉(因为$max_{col_{j}}$大于$i$)所以不可以越过j)

但是还没有完，我们发现如果一个颜色j的$max$小于$i$，那么我们的左端点不可以落在$(min_{j},max_{j}]$之间，因为如果落在了这个区间里，显然我们会发现这个颜色j会被删掉(因为$min_{j}$在左端点之前)，但是$max_{j}$又在区间里，此时我们的区间就不是连续的了

所以我们可以设计出这样一个算法，从左到右枚举右端点i

如果这个点$i=max_{col_{i}}$的话，
我们就在线段树上区间$(min_{col_{i}},max_{col_{i}}]$赋值为1，表示这些点被禁用

现在我们唯一的问题变成如何确定$max_{col_{j}}$大于$i$，且离i最近的点j，
我们可以贪心，每次将点ipush进一个栈里，然后我们开始贪心，如果栈顶的$max$已经小于i了我们就pop,重复这个过程直到我们找到第一个$max$大于i的点作为左端点l

然后我们发现此时i到l里未被禁用的点就是所有的合法左端点，(i-l)再减去线段树的区间和就是这个右端点i的所有合法左端点数量了，枚举所有的右端点i然后把合法左端点数量加在一起就是答案了

代码的话很短，只有一个线段树和一个栈的代码量

上代码~

```C
#include<cstdio>
#include<algorithm>
#include<stack>
#include<vector>
using namespace std;const int N=3*1e5+10;typedef long long ll;
int n;int mi[N];int ma[N];int cnt;int col[N];ll res;int T;
struct linetree//资瓷区间求和，区间赋值 
{
	int val[4*N];int sev[4*N];
	inline void pushdown(int p,int len)
	{if(sev[p]){val[p<<1]=len/2;val[p<<1|1]=len-len/2;sev[p<<1]=1;sev[p<<1|1]=1;}}
	void setval(int p,int l,int r,int dl,int dr)
	{
		if(dl==l&&dr==r){val[p]=r-l;sev[p]=1;return;}
		int mid=(l+r)/2;pushdown(p,r-l);
		if(dl<mid){setval(p<<1,l,mid,dl,min(mid,dr));}
		if(mid<dr){setval(p<<1|1,mid,r,max(dl,mid),dr);}
		val[p]=val[p<<1]+val[p<<1|1];
	}
	int sum(int p,int l,int r,int dl,int dr)
	{
		if(dl==l&&dr==r){return val[p];}
		int mid=(l+r)/2;int res=0;pushdown(p,r-l);
		if(dl<mid){res+=sum(p<<1,l,mid,dl,min(dr,mid));}
		if(mid<dr){res+=sum(p<<1|1,mid,r,max(dl,mid),dr);}
		return res;
	}
}lt;
struct data{int col;int pos;};stack <data> s;//开了一个栈 
inline void clear(stack <data>& st){stack <data> emp;swap(emp,st);}
inline void solve()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++){scanf("%d",&col[i]);}
	for(int i=1;i<=n;i++){mi[i]=0x3f3f3f3f;ma[i]=0;}
	for(int i=1;i<=4*n;i++){lt.val[i]=0;lt.sev[i]=0;}
	for(int i=1;i<=n;i++){mi[col[i]]=min(mi[col[i]],i);}//处理min 
	for(int i=1;i<=n;i++){ma[col[i]]=max(ma[col[i]],i);}//处理max 
	for(int i=1;i<=n;i++)//开始枚举右端点 
	{
		if(i==ma[col[i]]&&ma[col[i]]!=mi[col[i]])//如果是右端点的话就区间赋值表示禁用 
		{lt.setval(1,0,n,mi[col[i]],ma[col[i]]);}
		else {s.push((data){col[i],i});}
		for(;!s.empty()&&ma[s.top().col]<=i;s.pop());//找到左端点下限l 
		int l=(s.empty())?0:s.top().pos;//如果栈是空的话意味着所有左端点都可能合法 
		if(i!=l){res+=i-l-lt.sum(1,0,n,l,i);}//然后减去禁用的点数就好了 
	}printf("%lld\n",res);res=0;clear(s);//记得清空 
}
int main(){scanf("%d",&T);for(int z=1;z<=T;z++){solve();}return 0;}//拜拜程序~ 
```


---

## 作者：Ebola (赞：14)

感谢 @Iscream 的思路，这里借鉴他的思路，顺便进行一下不是很严格的证明

为了方便证明，我们将他做法的加改成异或。即：**对于每个位置赋一个$[0,2^{60})$之间的随机值，使得所有颜色相同位置上的值异或和为$0$**

先来考虑区间异或和的性质。对每个二进制位分开考虑。由于所有数都是等概率随机的，所以某一个二进制位为$1$的数的数量的奇偶性肯定是随机的，那么一段区间异或和每一个二进制位的值显然就是等概率随机的，故一段区间的异或和是等概率随机的

当一段不合法区间的异或和为$0$时，我们的做法会出错

如果一个区间中出现的颜色没有被完全包含，那么我们认为这个颜色在本区间内的所有值都是随机的，所以我们认为这个区间的异或和是随机的。一共有不超过$n^2-ans$种不合法区间，所以总的出错概率是$1-(1-2^{-60})^{n^2-ans}$，最坏情况下大概为$0.0000000781$，这个数字已经非常小了

具体做的时候直接用map统计前缀异或和为$c$的位置的数量就行了

```cpp
#include<bits/stdc++.h>
using namespace std;

typedef long long LL;
const int N=300010;
map<LL,int> cnt;
vector<int> col[N];
LL val[N];int qwq,n;

LL Rand(){return (LL)rand()<<30|rand();}

void _main_()
{
    scanf("%d",&n);
    for(int i=1,x;i<=n;i++)
        scanf("%d",&x),col[x].push_back(i);
    for(int i=1;i<=n;i++)
        if(!col[i].empty())
        {
            LL sum=0;
            for(int j=0;j<col[i].size()-1;j++)
                sum^=(val[col[i][j]]=Rand());
            val[col[i].back()]=sum;
        }
    LL sum=0,ans=0;cnt[0]=1;
    for(int i=1;i<=n;i++)
    {
        sum^=val[i];
        ans+=cnt[sum];
        cnt[sum]++;
    }
    cout<<ans<<"\n";
    for(int i=1;i<=n;i++)
        col[i].clear(),val[i]=0;
    cnt.clear();
}

int main()
{
    srand(time(0));
    scanf("%d",&qwq);
    while(qwq--) _main_();
    return 0;
}
```

---

## 作者：ecnerwaIa (赞：11)

[题目](https://www.luogu.org/problemnew/show/P4065)

题目大意：给定一个颜色序列，假设删去颜色集合为$A$,求满足删去$A$后原来序列中元素是连续的方案数

例如颜色序列 $\{1, 2, 3, 4, 5\}$，删除颜色 $3$ 后序列变成了 $\{1, 2\}$ 和 $\{4, 5\}$ 两段，不满足条件。而删除颜色 $1$ 后序列变成了 $\{2, 3, 4, 5\}$，满足条件。（题目例栗子）

这题最巧妙的怕不就是把条件转化为求合法区间了吧...(我就这里卡了很久)

因为删去后要求连续，所以可以转化为删去后是一段区间

考虑两个不同的合法区间，他们删去的颜色集合一定不同，因为删去的颜色相同最后只会存在一种情况（否则你就发现了数学中的不确定性原理，滑稽）

这里指的合法与否是指剩下的区间$[L,R]$含有的每个颜色的第一次出现$fir>=L,$最后一次出现$end<=R$，这样一定能保证符合题意（这里只是将题目要求的条件转化了一下）

关于求合法区间，就不难想到$ \ \ \ $用枚举一个端点，求另一个端点合法情况$\ \ $ 的方法

然后考虑$r$枚举到了$i$，怎么求所有满足的$l$

考虑其中一种颜色，发现其实只有三种情况：令该颜色第一个出现的位置为$fir$,最后一个位置$end$，当前处理到的右端点位置为$R(fir<=end)$

1. R<fir

1. fir<=R && R<end

1. end<=R

其实第1种完全是不用考虑的，主要考虑2，3

$2 :$因为我们是枚举右端点的位置，所以$[R+1,n]$的颜色其实应该是全被删去的,那么我们在$[1,R]$就不能选在$[R+1,n]$出现的颜色

假设$L$是$i<=R\&\&end[col[i]]>R(i\in[0,R])$中最大的（默认$end[a[0]]=inf$），那么我们的左端点不能选$[1,L]$因为一旦选了$L$，而$[R+1,n]$还存在$col[L]$就不是合法的了

$3 :end<=R$那么$[fir+1,end]$都是不能选的了,因为一旦选了$[fir+1,end]$，总会有$fir$没被选也是不合法的,所以就可以$[fir+1,end]$用线段树打标记，标记是不能选的就行了

附上图片一张

![](https://cdn.luogu.com.cn/upload/pic/53412.png)

考虑多种颜色除了$\ $第2种情况$\ $L要取最大之外与一种颜色并没什么不同

那么我们可以用栈记录,因为我们$R$是单增的,我们加入栈的元素位置一定也是单增的，那只要找到栈中第一个$end[col[i]]<=R$就好了，它对应的$pos[i]$一定是$<=R$中最大的

关于初始化$:$我这里的线段树初始化直接是将$x$左右儿子清0，$s[x]=tag[x]=0$初始化的，这样子最坏情况是清2*n次，一般情况还是应该快很多

```cpp
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
inline void read(int &x){x=0;int f=1;char ch=getchar();while(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}while(isdigit(ch)){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}x=x*f;}
typedef long long LL;
const int N=300010,M=N<<1;
int stc[N],sti[N],r;//stc:栈中第i个的颜色col,sti:栈中第i个的编号id 
int a[N],fir[N],end[N],n;//fir:颜色第一个出现的位置,end:最后一个的位置 
LL ans;//long long 一定要 
struct Segment_tree{
    int s[M],l[M],r[M],rt,cnt; //s:区间可以选哪些点(即去掉第三种不能选的点还能选哪些) 
    #define lc l[x]//简化书写 
    #define rc r[x]
    inline void pushup(int x){s[x]=s[lc]+s[rc];}//不解释 
    inline void build(int &x,int L,int R){//初始建树 
		x=++cnt;lc=rc=0;s[x]=R-L+1;//初始化都能选 
		if(L==R)return;int mid=(L+R)>>1;
		build(lc,L,mid);build(rc,mid+1,R);
	}
    inline void Del(int &x,int L,int R,int ll,int rr){//将[ll,rr]标记为不能选 
    	if(!x)return;
        if(ll<=L&&R<=rr){x=0;return;}//因为s[x]=0,不会对上面造成任何贡献,所以直接删除即可 
        int mid=(L+R)>>1;
        if(ll<=mid)Del(lc,L,mid,ll,rr);
        if(rr>mid)Del(rc,mid+1,R,ll,rr);
        pushup(x);
    }inline int get(int x,int L,int R,int ll,int rr){//求[ll,rr]满足的左端点位置个数 
        if(!x)return 0;//不存在x说明我们删去了,都不能选即s[x]=0 
        if(ll<=L&&R<=rr)return s[x];
        int mid=(L+R)>>1;
        if(ll<=mid&&rr>mid)return get(lc,L,mid,ll,rr)+get(rc,mid+1,R,ll,rr);
        else if(ll<=mid)return get(lc,L,mid,ll,rr);
        else return get(rc,mid+1,R,ll,rr);
    }
}T;
void slove(){
    read(n);for(int i=1;i<=n;++i){read(a[i]);fir[i]=0;}
    for(int i=1;i<=n;++i){if(!fir[a[i]])fir[a[i]]=i;end[a[i]]=i;}
    T.rt=0;T.cnt=0;ans=0;T.build(T.rt,1,n);
    for(int i=1;i<=n;++i){
        if(i==end[a[i]]&&end[a[i]]!=fir[a[i]])T.Del(T.rt,1,n,fir[a[i]]+1,end[a[i]]);//第三种情况出现了 
        else {stc[++r]=a[i];sti[r]=i;}//第二种情况,更新一下栈 
        while(r&&end[stc[r]]<=i)r--;//因为栈中位置是单调的,那么只要找到第一个end[x]>i的即可 
        int l=(r?sti[r]:0);
        if(i!=l)ans+=T.get(T.rt,1,n,l+1,i);//[1,l]都是不能选的,从l+1开始 
    }printf("%lld\n",ans);r=0;
}int t;
int main(){
    read(t);
    while(t--)slove();
    return 0;
}

```
程序拜拜~~

---

## 作者：Nemlit (赞：4)

$Orz$ 各位题解大佬，我来膜拜一发

~~还有单调栈实在没弄懂~~

### 法一：线段树+堆

首先，讨论区间的个数的题目，我们可以想到枚举一个端点$r$，找到所有的$l$

我们不妨设：$ml[i]$为第i种颜色出现的最小位置，$mr[i]$为第i种出现的最大位置

我们想到对于一个右端点，他有那些值是不能选的：

假设有一种颜色的$mr$值比当前枚举的右端点小，则$[ml, mr]$里面的所有的左端点都不能选，对应到线段树中就是区间赋成0

再假设有一种颜色，当前枚举的右端点在$[ml[i], mr[i]]$之间，那么我们记录一个$last[i]$，表示小于当前右端点的最大的i

那么$[1, last[i]]$所有的值都不能选

然后我们要找到一个最大的last，用一个堆即可

```
#include<bits/stdc++.h>
using namespace std;
#define il inline
#define re register
#define int long long
il int read() {
    re int x = 0, f = 1; re char c = getchar();
    while(c < '0' || c > '9') { if(c == '-') f = -1; c = getchar();}
    while(c >= '0' && c <= '9') x = x * 10 + c - 48, c = getchar();
    return x * f;
}
#define rep(i, s, t) for(re int i = s; i <= t; ++ i)
#define mem(k, p) memset(k, p, sizeof(k))
#define ls k * 2
#define rs k * 2 + 1
#define maxn 300005
int n, m, a[maxn], last[maxn], ans, ml[maxn], mr[maxn], tag[maxn << 2], sum[maxn << 2];
struct node {int id, val; il bool operator < (const node&x) const{return val < x.val;}};
priority_queue<node> q;
il void pushdown(int k, int l, int r, int mid) {
	if(tag[k] == -1) return;
	sum[ls] = (mid - l + 1) * tag[k], sum[rs] = (r - mid) * tag[k];
	tag[ls] = tag[rs] = tag[k]; tag[k] = -1;
}
il void modify(int k, int l, int r, int ll, int rr, int x) {
	if(l > rr || ll > r) return;
	if(ll <= l && r <= rr) return (void)(tag[k] = x, sum[k] = (r - l + 1) * x);
	int mid = (l + r) >> 1; pushdown(k, l, r, mid);
	modify(ls, l, mid, ll, rr, x), modify(rs, mid + 1, r, ll, rr, x);
	sum[k] = sum[ls] + sum[rs];
}
il int query(int k, int l, int r, int ll, int rr) {
	if(l > rr || ll > r) return 0;
	if(ll <= l && r <= rr) return sum[k];
	int mid = (l + r) >> 1; pushdown(k, l, r, mid);
	return query(ls, l, mid, ll, rr) + query(rs, mid + 1, r, ll, rr);
}
il void solve() {
	n = read(), ans = 0, mem(tag, -1), modify(1, 1, n, 1, n, 1);
	while(!q.empty()) q.pop();
	rep(i, 1, n) ml[i] = n + 1, mr[i] = last[i] = 0;
	rep(i, 1, n) a[i] = read(), ml[a[i]] = min(ml[a[i]], i), mr[a[i]] = max(mr[a[i]], i);
	rep(i, 1, n) {
		last[a[i]] = i, q.push((node){a[i], last[a[i]]});
		if(i == mr[a[i]]) modify(1, 1, n, ml[a[i]] + 1, mr[a[i]], 0);
		while(!q.empty()) {
			int x = q.top().id;
			if(last[x] == mr[x]) q.pop();
			else break;
		}
		int pax = (q.empty() ? 1 : q.top().val + 1);
		ans += query(1, 1, n, pax, i);
	}
	printf("%lld\n", ans);
}
signed main() {
	int T = read();
	while(T --) solve();
	return 0;
}
```
### 随机化

对于每一个位置，我们需要随机一个值，然后需要保证相同的颜色的所有的随机值异或结果为$0$

由于异或满足$a\ $^$\ b = 0$，所以我们把每个颜色的除了最后一项的所有随机值异或起来，让最后一位等于这个随机值

然后我们不难发现，每一个满足条件的一段区间，他的异或的值显然是等于0的

所以问题就转化成了：有多少区间的异或和等于0

由于上述异或的性质，于是我们只需要用$map$存一下即可

跟据@$Ebola$大佬的证明，我们的错误率是很小的。

### $Code:$

```
#include<bits/stdc++.h>
using namespace std;
#define il inline
#define re register
#define debug printf("Now is Line : %d\n",__LINE__)
#define file(a) freopen(#a".in","r",stdin);freopen(#a".out","w",stdout)
#define int long long
il int read() {
    re int x = 0, f = 1; re char c = getchar();
    while(c < '0' || c > '9') { if(c == '-') f = -1; c = getchar();}
    while(c >= '0' && c <= '9') x = x * 10 + c - 48, c = getchar();
    return x * f;
}
#define rep(i, s, t) for(re int i = s; i <= t; ++ i)
#define drep(i, s, t) for(re int i = t; i >= s; -- i)
#define Next(i, u) for(re int i = head[u]; i; i = e[i].next)
#define mem(k, p) memset(k, p, sizeof(k))
#define lb(x) (x)&(-(x))
#define ls k * 2
#define rs k * 2 + 1
#define maxn 300005
int n, m, a[maxn], val[maxn];
vector<int>q[maxn];
map<int, int> p;
il int Random() {
	return 1ll * rand() * rand() * rand();
}
signed main() {
	srand(time(0));
	int T = read();
	while(T --) {
		n = read();
		rep(i, 1, n) a[i] = read(), q[a[i]].push_back(i), val[i] = 0;
		rep(i, 1, n) {
			int sum = 0;
			for(re int j = 0; j < q[i].size(); ++ j) {
				if(j == q[i].size() - 1) val[q[i][j]] = sum;
				else sum ^= (val[q[i][j]] = Random());
			}
			q[i].clear();
		}
		int ans = 0, now = 0; p[0] = 1;
		rep(i, 1, n) now ^= val[i], ans += p[now], ++ p[now];
		rep(i, 1, n) now ^= val[i], p[now] = 0;
		printf("%lld\n", ans);
	}
	return 0;
}
```

---

## 作者：justin_cao (赞：3)

贡献一个和其它的题解似乎都不一样的方法。

考虑题目实际上是留下一个区间满足对于所有颜色要么不包含要么全都包含。

考虑先枚举右端点$i$。

发现在$i$后面的颜色是要全部删掉的，那么记$i$后面的颜色在$i$之前出现位置的最大值为$j$，这个可以用个$set$来预处理。

那么显然左端点必须得$>j$。

那么现在要求的是$[j+1,i-1]$之间有多少个作为左端点是满足条件的。

考虑判断的条件是什么。

发现既然把后面的点和前面的点都删掉了，那么剩下的这个$[j+1,i]$里面是没有$i$之后的颜色了。也就是说，对于这段区间内任意一段以$i$为后缀的区间而言，对于一种颜色，出现的第一个点必定是最右边的点（这不是废话吗），那只需要考虑最左边的点限制了。

我们发现，在左右都被限制了的情况下，只需要这段区间内最左边的点的个数等于最右边的点的个数，那它就是合法的，否则不合法。

那么如果把一种颜色的左端点看成$-1$，右端点看成$1$的话，要求的实际上就是区间和为$0$的区间数量。

那么要求的实际上就是$k\in[j,i-1]$满足$sum[k]=sum[i]$的$k$的个数，其中$sum[i]$是上面假设下的前缀和。

这个用个主席树维护即可（可能也有其他方法）。

复杂度$O(Tnlogn)$。

code：
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<iostream>
#include<set>
#include<vector>
#include<queue>
#include<stack>
#include<bitset>
#define eps 1e-15
#define maxn 300010
#define maxm 410
#define inf 1000000007
#define mod 1000000007
#define mp(x,y) make_pair(x,y)
#define fi first
#define se second
using namespace std;
typedef long long ll;
typedef unsigned int uint;
typedef pair<int,int>pii;
int read()
{
    int x=0,f=1;
    char ch=getchar();
    while(ch-'0'<0||ch-'0'>9){if(ch=='-') f=-1;ch=getchar();}
    while(ch-'0'>=0&&ch-'0'<=9){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
int T,n;
int a[maxn],mx[maxn],book[maxn],sum[maxn],rt[maxn];
vector<int>v[maxn];
set<int>s;
struct Segment_Tree{
    int t[maxn*20],ls[maxn*20],rs[maxn*20],tot;
    void update(int k)
    {
        t[k]=t[ls[k]]+t[rs[k]];
    }
    void modi(int &k1,int k2,int l,int r,int x)
    {
        k1=++tot;
        if(l==r)
        {
            t[k1]=t[k2]+1;
            return;
        }
        int mid=(l+r)/2;
        if(mid>=x)  rs[k1]=rs[k2],modi(ls[k1],ls[k2],l,mid,x);
        else        ls[k1]=ls[k2],modi(rs[k1],rs[k2],mid+1,r,x);
        update(k1);
    }
    int query(int k1,int k2,int l,int r,int x)
    {
        if(l==r)  return t[k1]-t[k2];
        int mid=(l+r)/2;
        if(mid>=x)  return query(ls[k1],ls[k2],l,mid,x);
        return query(rs[k1],rs[k2],mid+1,r,x);
    }
}S;
int main()
{
    T=read();
    while(T--)
    {
        n=read();
        for(int i=1;i<=n;i++)  a[i]=read();
        for(int i=1;i<=n;i++)  v[a[i]].push_back(i);
        for(int i=n;i>=1;i--)
        {
            set<int>::iterator it=s.end();
            if(s.size())  it--,mx[i]=(*it);
            else          mx[i]=0;
            if(book[a[i]])  s.erase(v[a[i]].back());
            else            book[a[i]]=1;
            v[a[i]].pop_back();
            if(v[a[i]].size())  s.insert(v[a[i]].back());
        }
        for(int i=1;i<=n;i++)  book[i]=0;
        for(int i=1;i<=n;i++)
          if(!book[a[i]])  sum[i]-=1,book[a[i]]=1;
        for(int i=1;i<=n;i++)  book[i]=0;
        for(int i=n;i>=1;i--)
          if(!book[a[i]])  sum[i]+=1,book[a[i]]=1;
        for(int i=1;i<=n;i++)  sum[i]+=sum[i-1];
        for(int i=0;i<=n;i++)  sum[i]+=n;
        for(int i=1;i<=n;i++)  S.modi(rt[i],rt[i-1],1,n,sum[i-1]);
        ll ans=0;
        for(int i=1;i<=n;i++)
        {
            if(mx[i]>i)  continue;
            ans+=S.query(rt[i],rt[mx[i]],1,n,sum[i]);
        }
        printf("%lld\n",ans);
        for(int i=1;i<=S.tot;i++)  S.ls[i]=S.rs[i];
        S.tot=0;s.clear();
        for(int i=0;i<=n;i++)  v[i].clear(),sum[i]=book[i]=0;
    }
    return 0;
}
```

---

## 作者：Mychael (赞：3)

##线段树 + 主席树##

一定只有我这种智障会用这么奇怪的方法做这道题。。

所以决定发个题解

由题我们知道最后剩余的一定是一个区间，而且区间内的颜色不存在于区间外

所以我们的目的就是为了找到这样的区间的数量

区间由左右端点确定，我们枚举右端点，尝试维护左端点数量

①

当我们从右向左枚举到$r$，$r$右边的颜色已经在区间外，一定不能被包含入区间，所以我们记录每个位置上一个同色位置$pre[i]$，指针$r$每越过一个位置，就在$pre[i]$处打一个标记，表示这个位置不能被包含。

之后我们每次找到$r$左边第一个标记的位置，再往左一定不合法，这样我们就得到了我们的初始区间，记为$[l,r]$。这个操作可以使用线段树维护

②

考虑这个区间还会有什么不满足的地方

就是区间内的颜色不能出现在区间外

对于一个在$r$左侧的位置$i$，颜色为$c$，记颜色$c$最左边的位置为$p$，那么$[p + 1,i]$都不能被选择，因为选择其中任意一个位置，都会使颜色$c$被分割

如何维护？

另开一个线段树区间$set$为$1$即可，一个位置可能被多个区间叠加，但只能贡献$1$

由于区间$set$操作不能被撤回，所以我们更新顺序只能从左到右，但我们是从右到左枚举的，怎么办？

那就强行从左到右更新，并保存每一个版本的线段树——永久化标记主席树

这样我们就做完了这道题
复杂度$O(nlogn)$
```C++
#include<algorithm>
#include<iostream>
#include<cstring>
#include<cstdio>
#include<cmath>
#include<map>
#define Redge(u) for (int k = h[u],to; k; k = ed[k].nxt)
#define REP(i,n) for (int i = 1; i <= (n); i++)
#define mp(a,b) make_pair<int,int>(a,b)
#define cls(s) memset(s,0,sizeof(s))
#define cp pair<int,int>
#define LL long long int
using namespace std;
const int maxn = 300005,maxm = 8000005,INF = 1000000000;
inline int read(){
	int out = 0,flag = 1; char c = getchar();
	while (c < 48 || c > 57){if (c == '-') flag = -1; c = getchar();}
	while (c >= 48 && c <= 57){out = (out << 3) + (out << 1) + c - 48; c = getchar();}
	return out * flag;
}
int ls[maxm],rs[maxm],Sum[maxm],tag[maxm],rt[maxn],cnt;
void Upd(int u){
	Sum[u] = Sum[ls[u]] + Sum[rs[u]];
}
void Set(int& u,int pre,int l,int r,int L,int R){
	u = ++cnt; ls[u] = ls[pre]; rs[u] = rs[pre]; tag[u] = Sum[u] = 0;
	tag[u] = tag[pre];
	if (tag[u]){
		Sum[u] = r - l + 1;
		return;
	}
	if (l >= L && r <= R){
		tag[u] = 1; Sum[u] = r - l + 1;
		return;
	}
	int mid = l + r >> 1;
	if (mid >= L) Set(ls[u],ls[pre],l,mid,L,R);
	if (mid < R) Set(rs[u],rs[pre],mid + 1,r,L,R);
	Upd(u);
}
int Query(int u,int l,int r,int L,int R){
	if (tag[u]) return R - L + 1;
	if (l >= L && r <= R) return Sum[u];
	int mid = l + r >> 1;
	if (mid >= R) return Query(ls[u],l,mid,L,R);
	if (mid < L) return Query(rs[u],mid + 1,r,L,R);
	return Query(ls[u],l,mid,L,mid) + Query(rs[u],mid + 1,r,mid + 1,R);
}
int sum[maxn << 2],mp[maxn << 2];
void upd(int u,int l,int r){
	sum[u] = sum[u << 1] + sum[u << 1 | 1];
	int mid = l + r >> 1;
	if (mp[u << 1 | 1] == 0) mp[u] = 0;
	else if (mp[u << 1] == 0) mp[u] = mp[u << 1 | 1];
	else if (mp[u << 1 | 1] == mid + 1) mp[u] = mp[u << 1];
	else mp[u] = mp[u << 1 | 1];
}
void modify(int u,int l,int r,int pos){
	if (l == r) {sum[u] = 1; mp[u] = 0; return;}
	int mid = l + r >> 1;
	if (mid >= pos) modify(u << 1,l,mid,pos);
	else modify(u << 1 | 1,mid + 1,r,pos);
	upd(u,l,r);
}
int query(int u,int l,int r,int L,int R){
	if (!sum[u]) return l;
	if (l >= L && r <= R) return mp[u];
	int mid = l + r >> 1;
	if (mid >= R) return query(u << 1,l,mid,L,R);
	if (mid < L) return query(u << 1 | 1,mid + 1,r,L,R);
	int t1 = query(u << 1,l,mid,L,R),t2 = query(u << 1 | 1,mid + 1,r,L,R);
	if (t2 == 0) return 0;
	else if (t1 == 0) return t2;
	else if (t2 == mid + 1) return t1;
	else return t2;
}
void build(int u,int l,int r){
	sum[u] = 0;
	if (l == r){
		mp[u] = l;
		return;
	}
	int mid = l + r >> 1;
	build(u << 1,l,mid);
	build(u << 1 | 1,mid + 1,r);
	upd(u,l,r);
}
int last[maxn],pre[maxn],F[maxn];
int n,A[maxn];
int main(){
	int T = read();
	while (T--){
		n = read(); REP(i,n) A[i] = read();
		cnt = 0; build(1,1,n);
		for (int i = 1; i <= n; i++) last[i] = 0;
		for (int i = 1; i <= n; i++){
			if (!last[A[i]]) F[A[i]] = i;
			pre[i] = last[A[i]];
			last[A[i]] = i;
			rt[i] = rt[i - 1];
			if (F[A[i]] < i) Set(rt[i],rt[i - 1],1,n,F[A[i]] + 1,i);
		}
		LL ans = 0;
		for (int i = n; i; i--){
			int l = query(1,1,n,1,i),r = i;
			if (pre[i]) modify(1,1,n,pre[i]);
			if (!l) continue;
			int t = Query(rt[i],1,n,l,r);
			ans += (r - l + 1) - t;
		}
		printf("%lld\n",ans);
	}
	return 0;
}

```

---

## 作者：iao113 (赞：3)

考前发一波题解攒rp。

题解参考pxy大佬（%%%pxy大佬）。

考虑从左往右枚举区间右端点r，假设左端点l合法，那么对于每种颜色，要么分布在[1,l]∪[r,n]，要么分布在[l,r]。

对于满足第一种情况的颜色，记prec为其r在之前最后一次出现的位置，那么要满足l>max{prec}，用优先队列维护。

对于满足第二种情况的颜色，记firstc和lastc为其第一次和最后一次出现的位置，那么首先要满足r>=lastc，然后要在优先队列中删除c出现的那些位置，然后l是不能在[firstc,lastc]之中的，可以把这个区间标记一下。

于是问题就是维护一个带删除操作的优先队列，并且会不断给一些区间标记，并且询问一个区间[max{prec},r]中有多少个未标记的点，用线段树即可。 

```cpp
#include <iostream>
#include <algorithm>
#include <queue>
#include <stack>
#include <cstdio>
#include <cstring>

const int inf = 0x3f3f3f3f;
const int maxn = 300010;

using namespace std;

int T;
int N;
int C[maxn];

long long ans;
int c[maxn];
int maxi[maxn], mini[maxn], pre[maxn];

struct Node
{
	int setv, sumv;
	Node() : setv(0), sumv(0) {}
};

Node seg[4 * maxn];

void build(int o, int L, int R)
{
	seg[o].setv = -1;
	seg[o].sumv = 0;
	if (L == R) return;
	int M = (L + R) / 2;
	build(o * 2, L, M);
	build(o * 2 + 1, M + 1, R);
}

void pushdown(int o)
{
	if (seg[o].setv >= 0)
	{
		seg[o * 2].setv = seg[o * 2 + 1].setv = seg[o].setv;
		seg[o].setv = -1;
	}
}

void maintain(int o, int L, int R)
{
	if (seg[o].setv != -1) seg[o].sumv = seg[o].setv * (R - L + 1);
	else if (L == R) seg[o].sumv = 0;
	else seg[o].sumv = seg[o * 2].sumv + seg[o * 2 + 1].sumv;
}

void update(int o, int L, int R, int l, int r, int x)
{
	if (l > r) return;
	if (l <= L && R <= r) seg[o].setv = x;
	else
	{
		pushdown(o);
		int M = (L + R) / 2;
		if (l <= M) update(o * 2, L, M, l, r, x);
		else maintain(o * 2, L, M);
		if (M < r) update(o * 2 + 1, M + 1, R, l, r, x);
		else maintain(o * 2 + 1, M + 1, R);
	}
	maintain(o, L, R);
}

int query(int o, int L, int R, int l, int r)
{
	if (seg[o].setv >= 0) return seg[o].setv * (min(R, r) - max(L, l) + 1);
	if (l <= L && R <= r) return seg[o].sumv;
	int ret = 0;
	int M = (L + R) / 2;
	if (l <= M) ret += query(o * 2, L, M, l, r);
	if (M < r) ret += query(o * 2 + 1, M + 1, R, l, r);
	return ret;
}

struct Heap
{
	priority_queue<int> q, d;
	void push(int x) { q.push(x); }
	void pop() { q.pop(); }
	void pop(int x) { d.push(x); }
	int top()
	{
		while (!d.empty() && q.top() == d.top())
		{
			q.pop();
			d.pop();
		}
		return q.empty() ? 0 : q.top();
	}
	void clear()
	{
		while (!q.empty()) q.pop();
		while (!d.empty()) d.pop();
	}
};

Heap q;

int main()
{
	scanf("%d", &T);
	while (T--)
	{
		scanf("%d", &N);
		build(1, 0, N);
		ans = 0;
		q.clear();
		memset(c, 0, sizeof c);
		memset(maxi, 0, sizeof maxi);
		memset(mini, 0x3f, sizeof mini);
		for (int i = 1; i <= N; i++)
		{
			scanf("%d", &C[i]);
			pre[i] = c[C[i]]; c[C[i]] = i;
			maxi[C[i]] = max(maxi[C[i]], i);
			mini[C[i]] = min(mini[C[i]], i);
		}
		for (int i = 1; i <= N; i++)
		{
			q.push(i);
			if (maxi[C[i]] == i)
			{
				for (int j = i; j; j = pre[j]) q.pop(j);
				update(1, 0, N, mini[C[i]] + 1, maxi[C[i]], 1);
			}
			int l = q.top();
			if (i != l) ans += i - l - query(1, 0, N, l + 1, i);
		}
		printf("%lld\n", ans);
	}
	return 0;
}

```

---

## 作者：Setsugesuka (赞：1)

事实上，$ODT$ 也可以高效地解决这个问题。

简单阅读题目后，发现是要我们求这么一个东西。

给定一个序列，每个元素都有自己的一个颜色，询问有多少种删除颜色的方案使得删掉这些颜色后剩下的元素还是一段连续的区间。

首先有一个很显然的结论，对于两个不同的方案，执行这两个方案后所剩下的连续区间长的一定是不一样的。

所以，题目要我们求有多少种删除的方案，其实就等价于求有多少种合法的剩余区间。

而对于一个区间，如果它是合法的，那么对于这个区间中的每一个元素，肯定不会在这个区间外出现。

一个区间可以表示成一对点 $(l,r)$ ，一个很暴力的想法是枚举其中一个端点，然后在 $logn$ 的时间内算出另一个端点有多少种可能。

不妨枚举右端点。

我们设当前枚举到的右端点是 $R$ ，那么，对于每一种颜色，我们认为 $fir[x]$ 是它在数列中第一次出现的位置， $sec[x]$ 是它的数列中最后一次出现的位置，它们可能的情况只有三种。

![](https://cdn.luogu.com.cn/upload/image_hosting/74fd56m0.png)

对于第一种情况，他是不会影响到我们去左边取左端点的

对于第二种情况，我们需要找到一个在 $R$ 左边最近一个位置 $k$ 且满足 $sec[color[k]]>i$ ，显然只有 $[k+1,r]$ 是我们可以选的

对于第三种情况，我们只要不选 $[fir[x]+1,sec[x]]$ 即可。

不难发现我们需要实时地维护一段区间可不可以选，这就是我们喜闻乐见的区间推平， $ODT$ 可以高效地解决这一类问题。

```cpp
#pragma GCC optimize(2)
#pragma GCC optimize(3)
#include <bits/stdc++.h>
using namespace std;
const int MAXN=1e6+10;

template <class T>
inline void write(T x)
{
    if(x>9)
    {
        write(x/10);
    }
    putchar(x%10+'0');
}

inline char nc()
{
    static char buf[1000000],*p1=buf,*p2=buf;
    return p1==p2&&(p2=(p1=buf)+fread(buf,1,1000000,stdin),p1==p2)?EOF:*p1++;
}

inline void read(int &sum)
{
    char ch=nc();
    int tf=0;
    sum=0;
    while((ch<'0'||ch>'9')&&(ch!='-')) ch=nc();
    tf=((ch=='-')&&(ch=nc()));
    while(ch>='0'&&ch<='9') sum=sum*10+(ch-48),ch=nc();
    (tf)&&(sum=-sum);
}

struct node
{
    int l,r,v;
    node(){}
    node(int L,int R=-1,int V=0):l(L),r(R),v(V){}
    bool operator <(const node &o) const
    {
        return l<o.l;
    }
};

set<node> s;

inline void merge(int l)
{
    set<node>::iterator it1,it2,it3;
    it2=s.lower_bound(l);
    if(it2==s.begin())
        return;
    it1=it2,it3=it2;
    --it1,++it3;
    bool pd3=(it3!=s.end());
    if(pd3&&it1->v==it2->v&&it2->v==it3->v&&it1->v==it3->v)
    {
        int l=it1->l,r=it3->r,v=it2->v;
        s.erase(it1,++it3);
        s.insert(node(l,r,v));
    }
    else if(it1->v==it2->v)
    {
        int l=it1->l,r=it2->r,v=it2->v;
        s.erase(it1,++it2);
        s.insert(node(l,r,v));
    }
    else if(pd3&&it2->v==it3->v)
    {
        int l=it2->l,r=it3->r,v=it2->v;
        s.erase(it2,++it3);
        s.insert(node(l,r,v));
    }
}

inline set<node>::iterator split(int pos)
{
    set<node>::iterator it=s.lower_bound(node(pos));
    if(it!=s.end()&&it->l==pos) return it;
    --it;
    int L=it->l,R=it->r,V=it->v;
    s.erase(it);
    s.insert(node(L,pos-1,V));
    return s.insert(node(pos,R,V)).first;
}

inline void assignval(int l,int r,int v)
{
    set<node>::iterator itr=split(r+1),itl=split(l);
    s.erase(itl,itr);
    s.insert(node(l,r,v));
}

inline int query(int l,int r)
{
    set<node>::iterator itr=split(r+1),itl=split(l);
    int ret=0;
    for(;itl!=itr;++itl)
        if(itl->v==1) ret+=(itl->r-itl->l+1);
    return ret;
}

int a[MAXN],fir[MAXN],sec[MAXN];
int stcolor[MAXN],stindex[MAXN],tp=0;
int n;
long long ans=0;

int main()
{
    int t;
    read(t);
    while(t--)
    {
        tp=0;
        ans=0;
        s.clear();
        read(n);
        for(int i=1;i<=n;++i)
            read(a[i]),fir[i]=0;
        for(int i=1;i<=n;++i)
        {
            if(!fir[a[i]])
                fir[a[i]]=i;
            sec[a[i]]=i;
        }
        s.insert(node(1,n,1));
        for(int i=1;i<=n;++i)
        {
            if(i==sec[a[i]]&&sec[a[i]]!=fir[a[i]])
            {
                assignval(fir[a[i]]+1,sec[a[i]],0);
                merge(fir[a[i]]+1);
                merge(sec[a[i]]);
            }
            else
            {
                ++tp;
                stcolor[tp]=a[i];
                stindex[tp]=i;
            }
            while(tp&&sec[stcolor[tp]]<=i) --tp;
            int l=(tp?stindex[tp]:0);
            if(i!=l)
            {
                ans+=query(l+1,i);
                merge(i+1);
                merge(l+1);
            }
        }
        write(ans);
        putchar('\n');
    }
    return 0;
}
```


---

## 作者：ywy_c_asm (赞：1)

众所周知，统计区间个数的主要套路有两个：①枚举右端点找有多少左端点，②分治，这里来一个把这两个结合起来的做法。

显然这题的题意可以转化成求有多少区间，使得这个区间内的颜色只出现在这个区间内，那么可以根据套路我们搞出每种颜色最左边出现的位置$minl$和最右边出现的位置$maxl$，然后如果我们枚举右端点$r$的话那合法的左端点$l$显然必须满足$[l,r]$之间的最小的$minl>=l$，并且最大的$maxl<=r$，后者可以使用线段树上二分求出每个$i$之前第一个的$maxl>i$的位置，记为$lim_i$，左端点不会在$lim_i$之前。

但是$minl>=l$这个不太好满足，我们考虑分治，左端点落在$[l,mid]$上，可以先预处理出每个$x\in[l,mid]$满足$[x,mid]$中的最小的$minl>=x$，然后再枚举右端点$t$，求$[mid+1,t]$中最小的$minl$，显然合法的$x$不能超过它，同时也不能小于等于$lim_t$，然后用个前缀和统计合法的$x$就行啦~

上代码~

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#define ll long long
#define ls(_o) (_o << 1)
#define rs(_o) ((_o << 1) | 1)
using namespace std;
namespace ywy {
	inline int get() {
	    int n = 0;
	    char c;
	    while ((c = getchar()) || 23333) {
	        if (c >= '0' && c <= '9')
	            break;
	        if (c == '-')
	            goto s;
	    }
	    n = c - '0';
	    while ((c = getchar()) || 23333) {
	        if (c >= '0' && c <= '9')
	            n = n * 10 + c - '0';
	        else
	            return (n);
	    }
	s:
	    while ((c = getchar()) || 23333) {
	        if (c >= '0' && c <= '9')
	            n = n * 10 + c - '0';
	        else
	            return (n);
	    }
	}
	int ints[300001], minl[300001], maxl[300001];
	int maxn[2000001];
	void build(int l, int r, int tree) {
	    if (l == r) {
	        maxn[tree] = maxl[ints[l]];
	        return;
	    }
	    int mid = (l + r) >> 1;
	    build(l, mid, ls(tree));
	    build(mid + 1, r, rs(tree));
	    maxn[tree] = max(maxn[ls(tree)], maxn[rs(tree)]);
	}
	int query(int rl, int rr, int l, int r, int tree, int num) {
	    if (rl > rr || maxn[tree] <= num)
	        return (0);
	    if (l == r)
	        return (l);
	    int mid = (l + r) >> 1;
	    if (rl == l && rr == r) {
	        if (maxn[rs(tree)] > num)
	            return (query(mid + 1, r, mid + 1, r, rs(tree), num));
	        return (query(l, mid, l, mid, ls(tree), num));
	    }
	    if (rl > mid)
	        return (query(rl, rr, mid + 1, r, rs(tree), num));
	    if (rr <= mid)
	        return (query(rl, rr, l, mid, ls(tree), num));
	    int cjr = query(mid + 1, rr, mid + 1, r, rs(tree), num);
	    if (cjr)
	        return (cjr);
	    return (query(rl, mid, l, mid, ls(tree), num));
	}
	int lim[300001], sums[300001];
	ll ans = 0;
	void digui(int l, int r) {
	    if (l == r) {
	        if (minl[ints[l]] == l && maxl[ints[r]] == r)
	            ans++;
	        return;
	    }
	    int mid = (l + r) >> 1;
	    digui(l, mid);
	    digui(mid + 1, r);
	    sums[l - 1] = 0;
	    int imin = 1234567890;
	    for (register int i = mid; i >= l; i--) {
	        imin = min(imin, minl[ints[i]]);
	        if (imin >= i)
	            sums[i]++;
	    }
	    for (register int i = l; i <= mid; i++) sums[i] += sums[i - 1];
	    imin = 1234567890;
	    for (register int i = mid + 1; i <= r; i++) {
	        imin = min(imin, minl[ints[i]]);
	        if (imin < l || lim[i] >= mid)
	            continue;
	        int dl = max(l, lim[i] + 1), dr = min(imin, mid);
	        if (dl > dr)
	            continue;
	        ans += (sums[dr] - sums[dl - 1]);
	    }
	    for (register int i = l; i <= mid; i++) sums[i] = 0;
	}
	void ywymain() {
	    int t = get();
	    while (t) {
	        t--;
	        int n = get();
	        for (register int i = 1; i <= n; i++) {
	            ints[i] = get();
	            minl[ints[i]] = 1234567890;
	            maxl[ints[i]] = -1234567890;
	        }
	        for (register int i = 1; i <= n; i++)
	            minl[ints[i]] = min(minl[ints[i]], i), maxl[ints[i]] = max(maxl[ints[i]], i);
	        build(1, n, 1);
	        for (register int i = 1; i <= n; i++) lim[i] = query(1, i, 1, n, 1, i);
	        ans = 0;
	        digui(1, n);
	        printf("%lld\n", ans);
	    }
	}
}
int main() {
    ywy::ywymain();
    return (0);
}
```

---


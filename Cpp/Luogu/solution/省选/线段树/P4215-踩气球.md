# 踩气球

## 题目描述

六一儿童节到了，SHUXK 被迫陪着 $m$ 个熊孩子玩一个无聊的游戏：有 $n$ 个盒子从左到右排成一排，第 $i$ 个盒子里装着 $a_i$ 个气球。

SHUxK 要进行 $Q$ 次操作，每次从某一个盒子里拿出一个没被踩爆的气球，然后熊孩子们就会立刻把它踩爆。

这 $m$ 个熊孩子每个人都指定了一个盒子区间 $[l_i,r_i]$。如果某一个时刻，一个熊孩子发现自己选定的盒子区间 $[l_i,r_i]$ 中的所有气球都已经被踩爆了，他就会非常高兴（显然之后他一直会很高兴）。

为了不辜负将自己的任务强行塞给 SHUXK 的那个人的期望，SHUXK 想向你询问：

- 他每次操作过后会有多少个熊孩子很高兴。

## 说明/提示

### 数据范围及约定

对于全部数据，$1\le n \le 10^5$，$1\le m \le 10^5$，$1\le Q \le 10^5$。

输入数据保证 $1 \le \hat{x} \le 10^9$，且第 $x$ 个盒子中有尚未被踩爆的气球。



## 样例 #1

### 输入

```
5 3
1 1 1 1 1
5 5
2 2
1 3
5 
4 
2 
5 
2 
3```

### 输出

```
0 
1 
1 
2 
3```

# 题解

## 作者：hs_black (赞：11)

[推销一波个人博客](https://www.cnblogs.com/Hs-black/p/12231440.html)

来一发无脑的主席树解法⑧

## 前置芝士: 主席树

主席树亦称可持久化线段树, 它可以轻松的解决二维偏序问题, 如区间第k大, 区间不同颜色个数等问题, 不会的同学可以模板区自行学习一下

回到本题:

利用主席树, 我们可以快速的求出区间[L, R]完全覆盖的"熊孩子区间"个数, 具体来说, 对于每个"熊孩子区间"[l, r], 以左端点l 为下标, 右端点r为权值, 建立主席树. 查询区间[L, R]时, 只需拿R处的线段树减去L-1处的线段树求出[L, R]的区间和即可

定义合并两个区间$[l_1, r_1], [l_2, r_2]$新产出的答案个数为:

区间$[l_1, r_2]$包含的熊孩子区间减去$[l_1, r_1]$的区间个数再减去 $[l_2, r_2]$包含的区间个数

那么本题中每次消掉一个气球, 如果消掉气球以后此处气球个数不为零, 显然对答案没有影响, 否则将起到合并相邻的两个区间的作用

 如下图, 轴上是位置, 下面是气球个数 

![](https://cdn.luogu.com.cn/upload/image_hosting/cl0xl5bc.png)

假如本次将6处的气球????点爆, 多出的答案可以这样算, 先将区间[4, 5] 和 [6, 6]合并, 在将[4, 6]和[7, 10]合并, 注意要用并查集维护

```cpp
#include <algorithm>
#include <iostream>
#include <cstring>
#include <cstdio>
#include <vector>

using namespace std;
const int N = 500500;

template <typename T>
void read(T &x) {
    x = 0; bool f = 0;
    char c = getchar();
    for (;!isdigit(c);c=getchar()) if (c=='-') f=1;
    for (;isdigit(c);c=getchar()) x=x*10+(c^48);
    if (f) x=-x;
}

int box[N], cnt, n, m;
vector<int> v[N];

int lastans = 0;

int ls[N*4], rs[N*4], T[N*4], sum[N*4];
int update(int pre, int l, int r, int x) {
    int rt = ++cnt;
    sum[rt] = sum[pre] + 1;
    ls[rt] = ls[pre], rs[rt] = rs[pre];
    int mid = (l + r) >> 1;
    if (l < r) {
        if (x <= mid) ls[rt] = update(ls[pre], l, mid, x);
        else rs[rt] = update(rs[pre], mid + 1, r, x);
    }
    return rt;
}

int ql, qr;
int query(int pre, int now, int l, int r) {
    if (l >= ql && r <= qr) return sum[now] - sum[pre];
    int mid = (l + r) >> 1;
    int res = 0;
    if (ql <= mid) res += query(ls[pre], ls[now], l, mid);
    if (qr > mid) res += query(rs[pre], rs[now], mid + 1, r);
    return res;
}

void merge(int l1, int r1, int l2, int r2) {
    ql = l1, qr = r1;
    lastans -= query(T[l1-1], T[r1], 1, n);
    ql = l2, qr = r2;
    lastans -= query(T[l2-1], T[r2], 1, n);
    ql = l1, qr = r2;
    lastans += query(T[l1-1], T[r2], 1, n);
}

int f[N], L[N], R[N];

int find(int x) {
    return f[x] == x ? x : f[x] = find(f[x]);
}
int main() {
    read(n), read(m);
    for (int i = 1;i <= n; i++) read(box[i]), L[i] = R[i] = f[i] = i;
    for (int i = 1;i <= m; i++) {
        int l, r; read(l), read(r);
        v[l].push_back(r);
    } cnt = T[0] = 1;
    for (int i = 1;i <= n; i++) {
        T[i] = T[i-1];
        for (int j = 0;j < v[i].size(); j++)
            T[i] = update(T[i], 1, n, v[i][j]);
    }
    int k; read(k);
    for (int i = 1;i <= k; i++) {
        int a; read(a); a = (a + lastans - 1) % n + 1;
        box[a]--;
        if (!box[a]) {
        	ql = a, qr = a;
        	lastans += query(T[a-1], T[a], 1, n);
            if (a != 1 && !box[a-1]) {
                int fx = find(a-1); f[a] = fx; 
                merge(L[fx], R[fx], a, a); R[fx] = a;
            }
            if (a != n && !box[a+1]) {
                int fx = find(a+1), fy = find(a);
                merge(L[fy], R[fy], L[fx], R[fx]);
                f[fy] = fx, L[fx] = L[fy];
            }
        }
        printf ("%d\n", lastans);
    }
    return 0;
}
```



---

## 作者：TIMEONLY (赞：10)

### 题意
有一个长度为$n$的序列,有$m$个区间,进行$Q$次单点修改,每次修改给出一个$x$,让序列的第x个数减一,对于每次修改,都需要输出,当前修改后在给定的m个区间中有多少个区间的区间和为0,题目强制在线。


------------
这题的解法其实有很多种,大部分都用到了线段树,做法多种多样，有兴趣的可以在网络上搜一搜。

这里讲的是线段树加链表的做法!


------------
### 推导过程
下面是推导过程(换句话说就是有问题的思路),没有兴趣的请直接跳到下面正解部分

观察一下数据范围是$1e5$,只能在$O(nlog(n))$以内做,这题给人一种像是单点修改,区间查询的感觉,那么就考虑一下线段树(~~跟着感觉走，没毛病~~)

考虑一下用线段树维护区间和，以及区间的happy值(即题目要求的全零区间个数),节点储存了以下的信息
```cpp
boy[N];//刚好处在该区间的熊孩子个数,不下传，不上传
left[N];//当前区间剩下的气球个数
happy[N];//当前区间中已经happy的人的个数
```
将所有的熊孩子的区间加入到线段树中,找到表示其所在区间的节点,$boy$++;

每次修改后进行update，父亲节点的happy值等于左右儿子的happy的和,如果当前节点的left为0，当前节点的happy值再加上了当前节点的boy数,不断将信息上传,到达根节点,完成修改操作,答案为根节点的happy值。
##### 代码如下
```cpp
#include<cstdio>
#include<iostream>

using namespace std;

const int N=1e5+10;

int Q;
int n,m;
int a[N];

struct Seg
{
    int boy[N];
    int left[N];
    int happy[N];
    int l[N],r[N];
    
    void PushUp(int rt)
    {
        left[rt]=left[rt<<1]+left[rt<<1|1];
        happy[rt]=happy[rt<<1]+happy[rt<<1|1];
        if(!left[rt]) happy[rt]+=boy[rt];
    }
    
    void build(int rt,int ll,int rr)
    {
        l[rt]=ll;r[rt]=rr;
        if(ll==rr)
        {
            left[rt]=a[ll];
            return;
        }
        int mid=(ll+rr)>>1;
        build(rt<<1,ll,mid);
        build(rt<<1|1,mid+1,rr);
        PushUp(rt);
    }
    
    void addkid(int rt,int ll,int rr)
    {
        if(l[rt]==ll&&r[rt]==rr)
        {
            if(left[rt]==0) happy[rt]=boy[rt]+1;
            boy[rt]++;return;
        }
        int mid=(l[rt]+r[rt])>>1;
        if(rr<=mid) addkid(rt<<1,ll,rr);
        else if(ll>mid) addkid(rt<<1|1,ll,rr);
        else addkid(rt<<1,ll,mid),addkid(rt<<1|1,mid+1,rr);
        PushUp(rt);
    }
    
    void update(int rt,int x)
    {
        if(l[rt]==r[rt])
        {
            left[rt]--;
            if(!left[rt]) happy[rt]=boy[rt];
            return;
        }
        int mid=(l[rt]+r[rt])>>1;
        if(x<=mid) update(rt<<1,x);
        else update(rt<<1|1,x);
        PushUp(rt);
    }
}Tree;

int lastans;

int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
    scanf("%d",&a[i]);
    Tree.build(1,1,n);
    for(int i=1,a,b;i<=m;i++)
    {
        scanf("%d%d",&a,&b);
        Tree.addkid(1,a,b);
    }
    scanf("%d",&Q);
    for(int i=1,x;i<=Q;i++)
    {
        scanf("%d",&x);
        x=(x+lastans-1)%n+1;
        Tree.update(1,x);
        lastans=Tree.happy[1];
        printf("%d\n",lastans);
    }
    return 0;
}

```
提交一波,$0$分!!!

如果仔细分析一下上面的思路就可以发现一个问题,因为线段树是把一个大区间分成两个长度不差超过$1$的小区间,所以只用一个节点是不能表示有些熊孩子的区间值的。怎么办？

能不能在建树的时候动动手脚？先将熊孩子的区间储存下来,再进行建树,建树的时候如果当前区间长度包含了熊孩子的区间,而按线段树的方法建立的当前节点的左右儿子节点又不能完全包含熊孩子区间，就不按线段树的方法去建，而是将当前区间的儿子节点区间范围设置成,熊孩子的区间，不包含熊孩子的区间。

但是再仔细想想,上面的思路还是不行,先不说建树的难度,一组所有熊孩子的区间值右端点等于n，左端点从1到n,就可以把这样的方法卡成$O(nm)$,所以只能另想办法

刚开始的思路缺陷在于无法用一个节点表示某些熊孩子的区间值,既然不能用一个节点表示，那就尝试一下用多个节点来表示，下面进入正解部分。


------------
### 正解

建立一棵线段树,线段树上节点维护的是当前节点所表示的区间被哪些区间覆盖以及当前区间的区间和,节点储存了以下信息
```cpp
left[N*4];//当前节点还有多少个气球 
vector<int>list[N*4];//包含当前区间的熊孩子的id，不需要下传
```
关于熊孩子，定义以下信息
```cpp
need[N];//id为i的熊孩子要计入答案还需要多少区间的区间和变为0
```
##### 初始化
读入序列后先按线段树的方式建树,每读入一个熊孩子的区间,给予其一个$id$,将该熊孩子区间加入到线段树中,像普通的线段树的区间操作打$lazy$标记一样将当前熊孩子区间分成几个小段,使得每个小段都能在线段树上的节点表示出来，找到完全符合的区间,向表示当前区间的节点的list值加入熊孩子的$id$,当前熊孩子的$need$加$1$,表示熊孩子被分成的区间块数增多。
##### 操作/询问

先按普通线段树进行单点修改，上传时如果发现当前区间和为0，就对list队列中的id进行更新操作,$need[i]$--,表示id为i的熊孩子的非$0$区间个数减少了一个,如果在减少后非$0$区间个数变为$0$,将其计入答案,$ans$++。
单点修改后直接输出ans
##### 复杂度
因为线段树的性质,任何熊孩子区间最多被分成$logn$个小区间,线段树上list储存的信息数量不会超过$mlogn$个,空间不会爆炸,每个小区间最多被更新一次，更新一个熊孩子的区间次数最多不超过$logn$次,所以总共更新次数不超过$mlogn$次,所以时间复杂度在$O(nlogn)$左右
##### 代码
```cpp
#include<vector>
#include<cstdio>
#include<iostream>

#define ls rt<<1//左儿子 
#define rs rt<<1|1//右儿子 

using namespace std;

const int N=1e5+10;

int Q;
int n,m;
int a[N];
int need[N];id为i的熊孩子要计入答案还需要多少区间的区间和变为0

struct Seg
{
	int ans;//当前答案,在这里定义在结构体中只是为了方便 
	int left[N*4];//当前区间区间和 
	vector<int>list[N*4];//包含当前区间的熊孩子的id	
	vector<int>::iterator it;//vector的迭代器,用于遍历list 
	
	void build(int rt,int ll,int rr)//建树 
	{
		if(ll==rr)
		{
			left[rt]=a[ll];
			return;
		}
		int mid=(ll+rr)>>1;
		build(ls,ll,mid);
		build(rs,mid+1,rr);
		left[rt]=left[ls]+left[rs];//上传区间和 
	}
	
	void addkid(int rt,int l,int r,int ll,int rr,int id)//向线段树上加入熊孩子的信息 
	{
		if(l==ll&&r==rr)//熊孩子完全包含了该区间 
		{
			list[rt].push_back(id);//将这个熊孩子的id加入到当前节点的队列中 
			need[id]++;return;//当前熊孩子被分成的区间数量加一
		}
		int mid=(l+r)>>1;
		if(rr<=mid) addkid(ls,l,mid,ll,rr,id);
		else if(ll>mid) addkid(rs,mid+1,r,ll,rr,id);
		else addkid(ls,l,mid,ll,mid,id),addkid(rs,mid+1,r,mid+1,rr,id);
	}
	
	void update(int rt)//更新 
	{
		for(it=list[rt].begin();it!=list[rt].end();it++)//vector遍历,不懂的可以搜一下 
		{
			need[*it]--;//熊孩子块数减一 
			if(!need[*it]) ans++;//熊孩子已经没有被分开的区间了,
			//换句话说当前熊孩子指定的区间中已经没有气球了,所以要计入答案 
		}
	}
	
	void change(int rt,int l,int r,int x)//修改操作 
	{
		left[rt]--;//因为是单点修改,所以每次直接减一,没必要上传
		if(!left[rt]) update(rt);//当前区间已经没有气球了,对包含当前区间的熊孩子进行更新 
		if(l==r) return;
		int mid=(l+r)>>1;
		if(x<=mid) change(ls,l,mid,x);
		else change(rs,mid+1,r,x);
	}
}Tree;

int lastans;//上一次的答案 

int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
	scanf("%d",&a[i]);
	Tree.build(1,1,n);
	for(int i=1,a,b;i<=m;i++)
	{
		scanf("%d%d",&a,&b);
		Tree.addkid(1,1,n,a,b,i);
	}
	scanf("%d",&Q);
	for(int i=1,x;i<=Q;i++)
	{
		scanf("%d",&x);
		x=(x+lastans-1)%n+1;//按题目要求解密x 
		Tree.change(1,1,n,x);
		lastans=Tree.ans;//把lastans更新 
		printf("%d\n",lastans);
	}
	return 0;
}
```


---

## 作者：Falashiro (赞：7)

**题意：**

给定一个长度为 $N$ 的序列和 $M$ 个区间，进行 $Q$ 次单点修改操作，每次操作后询问 $M$ 个区间中有多少个区间内的数全为 $0$ 。

**转化：**

题中保证了所有数非负，所以只要一个区间的和为 $0$ ，那么这个区间内的数就全为 $0$ 。

可以用线段树维护区间和与单点修改。

对于每一个区间，我们可以把它拆成线段树上的一些节点，如果拆成了 $s$ 个节点，每当其中的一个节点的值变为 $0$ 时，将 $s$ 减 $1$ ，当 $s$ 变为 $0$ 时，输出的答案就应该加 $1$ 。

时间复杂度为 $O((m+q)logn+n)$ 。

**实现：**

对于线段树上的每一个节点，使用一个 $vector$ 数组来保存有哪些区间在拆开后的节点中包含了这个节点，在单点修改操作时，若一个节点的值变为 $0$ 时，就将保存的所有区间的 $s$ (该区间拆成的节点数)减 $1$ ，同时更新值为 $0$ 的 $s$ 的数量(即要输出的答案)。

$code:$
```cpp
#include<bits/stdc++.h>
using namespace std;
#define rint register int
#define N 100005
struct node1{
	int val;
	vector<int>vp;
}t[N<<2];
struct node2{
	int l,r,s;
}k[N];
int n,m,q,a[N],op,x,ans;
void build(int p,int l,int r){
	if(l==r){
		t[p].val=a[l];
		return;
	}
	int mid=(l+r)>>1;
	build(p<<1,l,mid);
	build((p<<1)+1,mid+1,r);
	t[p].val=t[p<<1].val+t[(p<<1)+1].val;
}
void update(int p,int x,int v,int l,int r){
	if(l==r){
		t[p].val+=v;
		if(t[p].val==0){
			for(int i=0;i<t[p].vp.size();i++){
				k[t[p].vp[i]].s--;
				if(k[t[p].vp[i]].s==0)ans++;
			}
		}
		return;
	}
	int mid=(l+r)>>1;
	if(x<=mid)update(p<<1,x,v,l,mid);
	else update((p<<1)+1,x,v,mid+1,r);
	t[p].val=t[p<<1].val+t[(p<<1)+1].val;
	if(t[p].val==0){
		for(int i=0;i<t[p].vp.size();i++){
			k[t[p].vp[i]].s--;
			if(k[t[p].vp[i]].s==0)ans++;
		}
	}
}
void split(int p,int x,int y,int l,int r,int i){
	if(x<=l&&y>=r){
		t[p].vp.push_back(i);
		k[i].s++;
		return;
	}
	int mid=(l+r)>>1;
	if(x<=mid)split(p<<1,x,y,l,mid,i);
	if(y>mid)split((p<<1)+1,x,y,mid+1,r,i);
}
void init(){
	scanf("%d%d",&n,&m);
	for(rint i=1;i<=n;i++)
		scanf("%d",&a[i]);
	for(rint i=1;i<=m;i++)
		scanf("%d%d",&k[i].l,&k[i].r);
	scanf("%d",&q);
	build(1,1,n);
	for(rint i=1;i<=m;i++)
		split(1,k[i].l,k[i].r,1,n,i);
}
int main(){
	init();
	while(q--){
		scanf("%d%",&x);
		x=(x+ans-1)%n+1;
		update(1,x,-1,1,n);
		printf("%d\n",ans);
	}
    return 0;
}
```


---

## 作者：GoldenPotato137 (赞：4)

蒟蒻博客：[QwQ](https://www.cnblogs.com/GoldenPotato/p/9787833.html)


------------
## Solution


这题十分有意思。

首先，我们可以先想想离线做法，因为在线做法可以从离线做法推出。~~（虽然这题推不出）~~

我们可以明确一点，一个熊孩子开心的时间是满足二分的要求的（如果他某个时刻开心了，那之后的时刻都会保持开心）。

对于判断一个区间是否为全0，我们可以用主席树以一个log的代价来判断。

得到每个熊孩子开心的时刻之后，我们就可以直接前缀和解决问题了。

时间复杂度$O(m*log^2)$ 

.
 

很可惜，这题强制在线。

很可惜*2，~~刚刚的做法跟正解一点关系都没有~~。

我们可以考虑用线段树。

问题是怎么判断一个熊孩子在某个操作后是否开心呢？

我们显然可以快速地判断线段树上的一个直接的区间（即这个区间可以用一个节点表示）是否全为0，问题是我们不能很快地判断一个非直接的区间是否全为0。

所以说，我们可以考虑**把熊孩子“拆开”**。

因为**一个熊孩子的区间一定可以表示为线段树上的几个直接区间，我们可以在这些直接区间上打上标记，记录这个区间被哪几个熊孩子直接包含**。

我们**再记录一下每个熊孩子被拆成了几个区间**。

**一个区间全部变为0的时候，我们把它对应的熊孩子的记录值-1，当一个熊孩子记录值为0的时候，就代表着这个熊孩子的区间被彻底干掉了**。

时间复杂度$O(mlogn+qlogn)$

.
 

就酱，这题就被我们切掉啦φ(>ω<*) 


------------
## Code
```cpp
//Luogu P4215 踩气球
//Oct,14th,2018
//有意思的线段树
#include<iostream>
#include<cstdio>
#include<vector>
using namespace std;
long long read()
{
	long long x=0,f=1; char c=getchar();
	while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
	while(isdigit(c)){x=x*10+c-'0';c=getchar();}
	return x*f;
}
const int N=100000+100;
int ans,tot[N];
struct SegmentTree
{
	#define lson (now<<1)
	#define rson (now<<1|1)
	#define mid ((now_l+now_r)/2)
	vector <int> son[N<<2];
	int IsClear[N<<2],cnt[N];
	inline void update(int now)
	{
		IsClear[now]=IsClear[lson]&IsClear[rson];
	}
	void Mark(int L,int R,int x,int now,int now_l,int now_r)
	{
		if(now_l>=L and now_r<=R)
		{
			tot[x]++;
			son[now].push_back(x);
			return;
		}
		if(L<=mid) Mark(L,R,x,lson,now_l,mid);
		if(R>mid) Mark(L,R,x,rson,mid+1,now_r);
	}
	void Sub(int x,int now,int now_l,int now_r)
	{
		if(now_l==now_r)
		{
			cnt[x]--;
			if(cnt[x]==0)
				IsClear[now]=true;
		}
		if(now_l!=now_r)
		{
			if(x<=mid) Sub(x,lson,now_l,mid);
			else Sub(x,rson,mid+1,now_r);
			update(now);
		}
		if(IsClear[now]==true)
			for(int i=0;i<int(son[now].size());i++)
			{
				tot[son[now][i]]--;
				if(tot[son[now][i]]==0)
					ans++;
			}
	}
	#undef lson
	#undef rson
	#undef mid
}sgt;
int n,m,q;
int main()
{
	n=read(),m=read();
	for(int i=1;i<=n;i++)
		sgt.cnt[i]=read();
	for(int i=1;i<=m;i++)
	{
		int L=read(),R=read();
		sgt.Mark(L,R,i,1,1,n);
	}
	
	int q=read(),lans=0;
	for(int i=1;i<=q;i++)
	{
		int x=read();
		x=(x+lans-1)%n+1;
		sgt.Sub(x,1,1,n);
		lans=ans;
		printf("%d\n",lans);
	}
	return 0;
}

```


---

## 作者：CG__HeavenHealer (赞：3)

# 【题解】 P4215 踩气球

一道另类的线段树。

在 [¶凉笙](https://www.luogu.com.cn/user/375110)  大佬的帮助下，我才写对了这道题  ~~（还是我太菜了）（写了半天的push_down写不出来，结果不用push_down~~

### 题意

有一个长度为 $n$ 的序列，给定 $m$ 个子区间，并有 $q$ 次单点修改，每次修改将序列中的一项减 $1$ 。对每次修改，输出在给定的 $m$ 个子区间（熊孩子指定的区间）中，有多少个区间的区间和为 $0$ ，强制在线。

### 解法

~~（强制在线直接干掉一切离线做法~~

如果按照常规的思路，单点修改后查询区间和，需要遍历每个子区间，复杂度 $O(mq \log n)$ ， 直接爆炸。

那么怎么维护每个子区间呢？

如果考虑维护子区间，有两个问题：

1. 统计答案时怎样避免遍历所有子区间
2. 如果一个区间被多个子区间覆盖，怎样处理

对于 $1$ ，我们可以考虑把每一个子区间拆成若干线段树
上的区间，具体就是在线段树的每个节点开一个 
```vector``` 数组记录这个线段树的区间被哪些子区间覆盖，并直接在线段树的区间上打标记；而对于 $2$ ，可以开一个数组 $cnt$ 表示每一个子区间被拆成了几个区间，当一个子区间的 $cnt$ 为 $0$ 时，说明这个子区间分散的几个区间都已经修改，这时答案就可以更新了。

复杂度 $O((m +q) \log n )$ 。

### Code：

```cpp
#include <bits/stdc++.h> 
using namespace std;
#define int long long
#define ri register int
const int N = 1e5 + 10;
inline int read() {
	ri x = 0, f = 1;
	char ch = getchar();
	while (!isdigit(ch)) {
		if (ch == '-') f = -1;
		ch = getchar();
	}
	while (isdigit(ch)) {
		x = (x << 1) + (x << 3) + (ch ^ 48);
		ch = getchar();
	}
	return f * x;
}
struct SegmentTree {
	int v;
	vector<int> ch; // 标记线段树上的区间都被id为几的熊孩子（子区间）标记
} t[N << 2];
int a[N], ans, cnt[N];// cnt 表示每个熊孩子分散到线段树上的子区间个数
int n, m, q;
#define ls u << 1
#define rs u << 1 | 1
inline void push_up(int u) { t[u].v = t[ls].v + t[rs].v; }
void build(int u, int l, int r) {
	if (l == r) return t[u].v = a[l], void();
	int mid = (l + r) >> 1;
	build(ls, l, mid);
	build(rs, mid + 1, r);
	push_up(u);
}
void add_child(int u, int l, int r, int ql, int qr, int id) { //线段树上标记熊孩子（子区间）
	if (ql <= l && r <= qr) {
		cnt[id]++;
		t[u].ch.push_back(id);
		return;
	}
	int mid = (l + r) >> 1;
	if (ql <= mid) add_child(ls, l, mid, ql, qr, id);
	if (qr > mid) add_child(rs, mid + 1, r, ql, qr, id);
}
inline void update(int u) {
	for (ri i = 0; i < t[u].ch.size(); i++) { // 更新树上节点的每个子区间
		cnt[t[u].ch[i]]--;
		if (!cnt[t[u].ch[i]]) ans++; // 只要子区间分散的每一个区间都被更新， 就说明这个区间和为0了，更新答案
	}
}
void change(int u, int l, int r, int pos, int k) {
	t[u].v += k;
	if (!t[u].v) update(u);
	if (l == r) return;
	int mid = (l + r) >> 1;
	if (pos <= mid) change(ls, l, mid, pos, k);
	else change(rs, mid + 1, r, pos, k);
} 
signed main() {
	n = read(), m = read();
	for (ri i = 1; i <= n; i++) a[i] = read();
	build(1, 1, n);
	for (ri i = 1; i <= m; i++) {
		int L = read(), R = read();
		add_child(1, 1, n, L, R, i);
	}
	q = read();
	while (q--) {
		int x = read();
		change(1, 1, n, (x + ans - 1) % n + 1, -1);
		printf("%lld\n", ans);
	}
	return 0;
}
```



---

## 作者：warzone (赞：2)

### 题目意义
给定一个长为n的数列,并指定q个区间.每次让数列中任意一个数-1,输出和为0的区间数。

既然是求区间和,那自然有两种做法:线段树和前缀和

### 题目推导
首先,写一个线段树
```cpp
class SEGMENT_TREE{
    private:
        struct point{
            long long h;
            point *l,*r;
            int from,to;
        }*head;
        inline void NEW(point *p){
            if(p->from!=p->to){
                p->l=new point;
                p->r=new point;
                p->l->from=p->from;
                p->l->to=(p->from+p->to)/2;
                p->r->from=p->l->to+1;
                p->r->to=p->to;
                NEW(p->l);
                NEW(p->r);
                p->h=p->l->h+p->r->h;
            }
            else p->h=read();//ps：写了快读
        }
        inline void DELETE(point *p){
            if(p->from!=p->to){
                DELETE(p->l);
                DELETE(p->r);
            }
            delete p;
        }
        inline void PLUS(point *p,const int&num){
            p->h--;
            if(p->from!=p->to){
                if(num<=p->l->to)PLUS(p->l,num);
                else PLUS(p->r,num);
            }
        }
        inline bool SUM(point *p,const int&l,const int&r){
            if(p->from==p->to) return p->h==0;
            if(r<=p->l->to) return SUM(p->l,l,r);
            if(l>=p->r->from) return SUM(p->r,l,r);
            return SUM(p->l,l,p->l->to)&&SUM(p->r,p->r->from,r);
        }
    public:
        SEGMENT_TREE(const int &length){
            head=new point;
            head->from=1;
            head->to=length;
            NEW(head);//建立并设置初始值
        }
        ~SEGMENT_TREE(){DELETE(head);}//内存释放
        inline void in(const int&num){PLUS(head,num);}//任意数-1
        inline bool out(const int&l,const int&r){//输出区间和是否为0
        	return SUM(head,l,r);
        }
};
```
然后像一般方式一样自减然后计算
```cpp
int l[100000],r[100000],ans=0;
int main(){
    const int n=read();
    const int m=read();
    SEGMENT_TREE tree(n);
    for(register int i=0;i<m;i++){
        l[i]=read();
        r[i]=read();
    }
    const int q=read();
    for(register int i=0,x;i<q;i++){
        x=(read()+ans-1)%n+1;
        tree.in(x);
        for(register int j=0;j<m;j++){
            if(l[j]<=x&&x<=r[j]) ans+=tree.out(l[j],r[j]);
        }
        if(ans==0) putchar('0');
        else write(ans);//ps：写了快写
        putchar('\n');
    }
    return 0;
} 
```
提交了之后,只有40,10个测试点6个TLE


------------

之前每一次都要看m个区间,于是
- 建树的时间复杂度为 O(n^2)
- 修改一次的时间复杂度为O(mlogn)
- 所有修改的时间复杂度为O(qmlogn)

后来,想到了提前标记各个区间在线段树上包含的点(此处用链表),更新点时依标记直接修改区间和并判断

由于每次只修该一个数,不可能出现小区间未被修改的情况

修改一次的时间复杂度变为O(logn),只在初始化时把存入区间的时间复杂度由O(m)变为O(mlogn)
```cpp
class SEGMENT_TREE{
    private:
    	int *h;
    	struct list{
    		list *next;
    		int id;
        };
        struct point{
            long long h;
            point *l,*r;
            int from,to;
            list *head,*tail;
        }*head;
        /*****************初始化******************/
        inline void NEW(point *p){
        	p->head=new list;
        	p->tail=p->head;
            if(p->from!=p->to){
                p->l=new point;
                p->r=new point;
                p->l->from=p->from;
                p->l->to=(p->from+p->to)/2;
                p->r->from=p->l->to+1;
                p->r->to=p->to;
                NEW(p->l);
                NEW(p->r);
                p->h=p->l->h+p->r->h;
            }
            else p->h=read();
        }
        inline void LINE(point *p,const int&l,const int&r,const int&id){//链表标记区间点(递归)
        	if(p->from==l&&p->to==r){
        		h[id]+=p->h;
        		p->tail->id=id;
        		p->tail->next=new list;
        		p->tail=p->tail->next;
            }
            else if(r<=p->l->to) LINE(p->l,l,r,id);
            else if(l>=p->r->from) LINE(p->r,l,r,id);
            else{
                LINE(p->l,l,p->l->to,id);
                LINE(p->r,p->r->from,r,id);
            }
        }
        inline void DEL(list *head,list *tail){
            if(head!=tail) DEL(head->next,tail);
            delete head;
        }
        inline void DELETE(point *p){
        	DEL(p->head,p->tail);
            if(p->from!=p->to){
                DELETE(p->l);
                DELETE(p->r);
            }
            delete p;
        }
        /*+++++++++++++++++++++++++++++++++++++*/ 
        inline void PLUS(point *p,const int&num){
        	p->h--; 
            for(list *l=p->head;l!=p->tail;l=l->next){//更新区间和
            	h[l->id]--;
            	if(h[l->id]==0) ans++;
            }
            if(p->from!=p->to){
                if(num<=p->l->to) PLUS(p->l,num);
                else PLUS(p->r,num);
            }
        }
    public:
        SEGMENT_TREE(const int &length,const int&size){
            head=new point;
            head->from=1;
            head->to=length;
            NEW(head);
            h=new int[size];
            memset(h,0,sizeof(h));
            for(register int i=0,l,r;i<size;i++){//录入各个区间并标记
            	l=read();
            	r=read();
            	LINE(head,l,r,i);
            }
        }
        ~SEGMENT_TREE(){DELETE(head);}
        inline void in(const int&num){PLUS(head,num);}
};
int main(){
    const int n=read();
    const int m=read();
    SEGMENT_TREE tree(n,m);
    const int q=read();
    for(register int i=0,x;i<q;i++){
        x=(read()+ans-1)%n+1;
        tree.in(x);
        if(ans==0) putchar('0');
        else write(ans);
        putchar('\n');
    }
    return 0;
} 
```
提交之后,40分变为70分


------------

这时,区间和的更新依旧复杂
- 不论是40分还是70分的代码,每一次修改线段树都要修改所有所对应的区间和
- 毫无疑问,指针链表速度一般
- 我们可以改为存区间中非0的标记点数,标记点为0时再去修改

AC代码
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
inline int read(){
    register char c=getchar();
    register short w=1;
    while('0'>c||c>'9'){
        if(c=='-') w=-1; 
        c=getchar();
    }
    register int a=0;
    while('0'<=c&&c<='9'){
        a=a*10+c-'0';
        c=getchar();
    }
    return a*w;
}
inline void write(const int &num){
    if(num==0) return;
    write(num/10);
    putchar(num%10+'0');
}
int ans=0;
class SEGMENT_TREE{
    private:
    	int *h;
    	struct list{
    		list *next;
    		int id;
        };
        struct point{
            long long h;
            point *l,*r;
            int from,to;
            list *head,*tail;
        }*head;
        /*****************初始化******************/
        inline void NEW(point *p){
        	p->head=new list;
        	p->tail=p->head;
            if(p->from!=p->to){
                p->l=new point;
                p->r=new point;
                p->l->from=p->from;
                p->l->to=(p->from+p->to)/2;
                p->r->from=p->l->to+1;
                p->r->to=p->to;
                NEW(p->l);
                NEW(p->r);
                p->h=p->l->h+p->r->h;
            }
            else p->h=read();
        }
       	inline int LINE(point *p,const int&l,const int&r,const int&id){//存区间中非0的标记点数(递归)
        	if(p->from==l&&p->to==r){
        		p->tail->id=id;
        		p->tail->next=new list;
        		p->tail=p->tail->next;
        		return 1;
            }
            if(r<=p->l->to) return LINE(p->l,l,r,id);
            if(l>=p->r->from) return LINE(p->r,l,r,id);
            return LINE(p->l,l,p->l->to,id)+LINE(p->r,p->r->from,r,id);
        }
        inline void DEL(list *head,list *tail){
            if(head!=tail) DEL(head->next,tail);
            delete head;
        }
        inline void DELETE(point *p){
        	DEL(p->head,p->tail);
            if(p->from!=p->to){
                DELETE(p->l);
                DELETE(p->r);
            }
            delete p;
        }
    public:
        SEGMENT_TREE(const int &length,const int&size){
            head=new point;
            head->from=1;
            head->to=length;
            NEW(head);
            h=new int[size];
            memset(h,0,sizeof(h));
            for(register int i=0,l,r;i<size;i++){
            	l=read();
            	r=read();
            	h[i]=LINE(head,l,r,i);
            }
        }
        ~SEGMENT_TREE(){DELETE(head);}
        inline void in(const int&num){
        	for(point *p=head;;){
        		p->h--;
        		if(p->h==0){//更新标记点数
        			for(list *l=p->head;l!=p->tail;l=l->next){
            			h[l->id]--;
            			if(h[l->id]==0) ans++;
                    }
                }
            	if(p->from==p->to) break;
                if(num<=p->l->to) p=p->l;
                else p=p->r;
            }
        }
        
};
int main(){
    //freopen("in.txt","r",stdin);
    //freopen("out.txt","w",stdout);
    const int n=read();
    const int m=read();
    SEGMENT_TREE tree(n,m);
    const int q=read();
    for(register int i=0,x;i<q;i++){
        x=(read()+ans-1)%n+1;
        tree.in(x);
        if(ans==0) putchar('0');
        else write(ans);
        putchar('\n');
    }
    return 0;
} 
```

---

## 作者：Tgotp (赞：1)

对于每个点维护一下这个点能向右跑的最远距离，这个很显然能用并查集维护。

然后考虑每个点建一棵线段树，然后根据左右两点的关系合并线段树。

那么在记录的最远距离左边的点一定都是已经可以加入答案的点，删去即可。

c++代码如下：
```
#include<bits/stdc++.h>
#define rep(i,x,y) for(register int i = x;i <= y; ++ i)
#define repd(i,x,y) for(register int i = x;i >= y; -- i)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
template<typename T>inline bool chkmin(T&x,T y) { return x > y ? x = y,1 : 0; }
template<typename T>inline bool chkmax(T&x,T y) { return x < y ? x = y,1 : 0; }
inline char gc()
{
	static char buf[1 << 16],*S,*T;
	if(S == T) { T = (S = buf) + fread(buf,1,1<<16,stdin); if(S == T) return EOF; }
	return *S ++ ;
}
template<typename T>inline void read(T&x)
{
	char c;int sign = 1;x = 0;
	do { c = gc(); if(c == '-') sign = -1; }while(!isdigit(c));
	do { x = x * 10 + c - '0'; c = gc();	 }while(isdigit(c));
	x *= sign;
}

const int N = 1e5 + 50,M = 4e6 + 60;
int n,m,b[N],ans,cnt;
int rt[N],t[N],ls[M],rs[M],sz[M],w[M];

void insert(int&x,int l,int r,int pos)
{
	if(!x) x = ++ cnt; ++ sz[x] ;
	if(l == r) return ;
	int mid = l + r >> 1;
	if(pos <= mid) insert(ls[x],l,mid,pos);
	else insert(rs[x],mid+1,r,pos);
}

void merge(int&x,int&y)
{
	if(!x && !y) return;
	if(!x) { x = y;return; }
	if(!y) { y = x;return; }
	sz[x] += sz[y];
	merge(ls[x],ls[y]);
	merge(rs[x],rs[y]);
	y = x; 
}

int get_fa(int x) {
	return rt[x] == x ? x : rt[x] = get_fa(rt[x]);
	}

inline void Merge(int x,int y)
{
	y = get_fa(y); x = get_fa(x);
	chkmax(t[x],t[y]);
	merge(rt[x],rt[y]);
}

void update(int&x,int l,int r,int k)
{
	if(l > k || !sz[x] || !x) return;
	if(r <= k) 
	{
		ans += sz[x];
		sz[x] = 0;
		if(x > n) x = 0;
		return ;
	}
	int mid = l + r >> 1;
	update(ls[x],l,mid,k);
	update(rs[x],mid+1,r,k);
	sz[x] = sz[ls[x]] + sz[rs[x]];
	if(sz[x] == 0 && x > n) x = 0;
}

int main()
{
//	freopen("4631.in","r",stdin);
//	freopen("4631.out","w",stdout);
	
//	freopen("1.in","r",stdin);
//	freopen("22.out","w",stdout);

	read(n); read(m);
	rep(i,1,n) read(b[i]);
	rep(i,1,n) rt[i] = ++ cnt;
	rep(i,1,m)
	{
		int l,r;
		read(l); read(r);
		insert(rt[l],1,n,r);
	}
	
	int q;
	rep(i,1,n) t[i] = i;
	read(q);b[0] = 1;b[n+1] = 1;
	rep(i,1,q)
	{
		int x;
		read(x);
		x = (x + ans - 1) % n + 1;
		-- b[x];
		if(b[x]) 
		{
			printf("%d\n",ans);
			continue;
		}
		if(!b[x-1]) Merge(x,x-1);
		if(!b[x+1]) Merge(x,x+1);
		update(rt[x],1,n,t[x]);
		printf("%d\n",ans);
	}
	return 0;
}
```
[博客](http://tgotp.science/2046-2/)

---

## 作者：Zwaire (赞：0)

# P4215 踩气球

## [LINK](https://www.luogu.com.cn/problem/P4215)

## 来一发线段树合并的题解

## 题目描述：

```
给定一个序列和一些区间，每次单点减去1，问每一步减去后有多少区间的和为0
```

## 分析：

看到多个区间进行查询，那么我们可以考虑对于区间进行维护。

对于一个区间的两个端点 $l,r$ 我们可以先对于每一个点开一个权值线段树，然后对于区间，把左端点当做下标，在右端点的线段树的对应的位置加一。这样我们的区间就维护好了。

考虑我们怎么进行统计答案，也就是修改，当我们修改时，一个点的权值减为 $0$ 的时候，我们才会考虑对于答案的影响，那么假设我们对应的一个节点 $\text{X}$ ，它的节点变为了空，那说明所有以这个点为右端点的区间需要进行合并了。

什么意思呢，假设我们的区间为 $[l, r]$ ，当我们的 $r$ 节点已经为 $0$ ，那么我们的区间是不是就变成了 $[l, r - 1]$ ，考虑对于这个点前面没有合并的点对应的两个线段树进行合并，在合并的过程中，**需要把所有大于我需要合并的目标节点的值的点全部删去**，并统计到答案中，因为我们不存在左端点比右端点大的区间，**然而对于找到前面没有合并的点，并查集维护即可**。

```c++
struct tree
{
    int ls, rs;
    int sum;
}T[N];

il void push_up(int p) {T[p].sum = T[T[p].ls].sum + T[T[p].rs].sum;}
il int get(int x) {return fa[x] == x ? x : fa[x] =  get(fa[x]);}
il void add(int p, int l, int r, int val)
{
    if(l == r)
    {
        T[p].sum++;
        return ;
    }
    int mid = (l + r) >> 1;
    if(val <= mid) 
    {
        if(!T[p].ls) T[p].ls = ++cnt;
        add(T[p].ls, l, mid, val);
    }
    if(val > mid)
    {
        if(!T[p].rs) T[p].rs = ++cnt;
        add(T[p].rs, mid + 1, r, val);
    }
    push_up(p);
    return ;
}
il void del(int p, int l, int r, int val)
{
    if(l == r)
    {
        las += T[p].sum;//统计答案
        T[p].sum = 0;
        return ;
    }
    int mid = (l + r) >> 1;
    if(val <= mid)
    {
        if(T[T[p].ls].sum) del(T[p].ls, l, mid, val);
    }
    if(T[T[p].rs].sum) del(T[p].rs, mid + 1, r, val);
    push_up(p);
    return ;
}
il void merge(int x, int y, int l, int r)
{
    if(l == r)
    {
        T[x].sum += T[y].sum;
        return ;
    }
    int mid = (l + r) >> 1;
    if(T[x].ls) {if(T[T[y].ls].sum) merge(T[x].ls, T[y].ls, l, mid);}
    else T[x].ls = T[y].ls, T[T[x].ls].sum = T[T[y].ls].sum;
    if(T[x].rs) {if(T[T[y].rs].sum) merge(T[x].rs, T[y].rs, mid + 1, r);}
    else T[x].rs = T[y].rs, T[T[x].rs].sum = T[T[y].rs].sum;
    push_up(x);
    return ;
}//线段树合并

signed main()
{
    n = re(), m = re();
    for(int i = 1; i <= n; ++i) c[i] = re();
    for_1(i, n) fa[i] = i;
    for_1(i, n) rt[i] = ++cnt;
    for_1(i, m)
    {
        int x = re(), y = re();
        add(rt[y], 1, n, x);
    }
    q = re();
    for_1(i, q)
    {
        int x = re();
        x = (x + las - 1) % n + 1;
        c[x]--;
        if(c[x] == 0)
        {
            fa[x] = x - 1;
            int k = get(x);//并查集找到左边可以进行合并的点
            del(rt[x], 1, n, k + 1);//删去大于的点，在del中统计了答案
            merge(rt[k], rt[x], 1, n);
        }
        cout<<las<<endl;
    }
}
```
完结撒花✿✿ヽ(°▽°)ノ✿

---

## 作者：lytqwq (赞：0)

~~思路顺畅，很舒服~~

### 1.暴力：

预处理熊孩子所管区间的和，每次修改后遍历一遍所有熊孩子，**修改区间和**并**看看区间和是否为0**，统计答案即可。

时间复杂度 $ O(N^2) $


### 2.正解：

每次遍历一遍熊孩子太费时间，考虑对所管区间分组，每次修改先看所在的组，然后再更新熊孩子。

所以我们祭出了主角：**线段树**。

先把盒子们建一棵线段树，然后熊孩子所管区间可以用$logN$级别的线段树节点数更新。

所以，当这个线段树节点的值为0（即没有气球时），我们更新这个节点对应的熊孩子们，统计答案即可。

显然，因为 每个线段树节点从其他数变为0的情况只会出现1次 ，更新的次数就是$N log N$级别的。

时间复杂度 $ O(N log N) $

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=100005;
int n,m,q,a[N],ans[N<<2],sum[N];
vector<int> ovo[N<<2];
int ls(int x){
	return x<<1;
}
int rs(int x){
	return x<<1|1;
}
void push_up(int p){
	ans[p]=ans[ls(p)]+ans[rs(p)];
}
void build(int l,int r,int p){
	if(l==r){
		ans[p]=a[l];
		return ;
	}
	int mid=(l+r)>>1;
	build(l,mid,ls(p));
	build(mid+1,r,rs(p));
	push_up(p);
}
void query(int nl,int nr,int l,int r,int p,int k){
	if(nl<=l&&r<=nr){
		sum[k]++;
		ovo[p].push_back(k);
		return ;
	}
	int mid=(l+r)>>1;
	if(nl<=mid){
		query(nl,nr,l,mid,ls(p),k);
	}
	if(mid+1<=nr){
		query(nl,nr,mid+1,r,rs(p),k);
	}
}
int update(int nn,int l,int r,int p){
	int re=0;
	if(l==r){
		ans[p]--;
		if(ans[p]==0){
			int len=ovo[p].size();
			for(int i=0;i<len;i++){
				sum[ovo[p][i]]--;
				if(sum[ovo[p][i]]==0){
					re++;
				}
			}
		}
		return re;
	}
	int mid=(l+r)>>1;
	if(nn<=mid){
		re=update(nn,l,mid,ls(p));
	}
	if(mid+1<=nn){
		re=update(nn,mid+1,r,rs(p));
	}
	push_up(p);
	if(ans[p]==0){
		int len=ovo[p].size();
		for(int i=0;i<len;i++){
			sum[ovo[p][i]]--;
			if(sum[ovo[p][i]]==0){
				re++;
			}
		}
	}
	return re;
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
	}
	build(1,n,1);
	for(int i=1;i<=m;i++){
		int l,r;
		scanf("%d%d",&l,&r);
		query(l,r,1,n,1,i);
	}
	scanf("%d",&q);
	int x,Lastans=0;
	for(int i=1;i<=q;i++){
		int sc;
		scanf("%d",&sc);
		x=(sc+Lastans-1)%n+1;
		Lastans+=update(x,1,n,1);
		printf("%d\n",Lastans);
	}
}
```


---


# [BJOI2014] 大融合

## 题目描述

小强要在 $N$ 个孤立的星球上建立起一套通信系统。这套通信系统就是连接 $N$ 个点的一个树。

这个树的边是一条一条添加上去的。

在某个时刻，一条边的负载就是它所在的当前能够联通的树上路过它的简单路径的数量。

![](https://cdn.luogu.com.cn/upload/pic/13969.png)

例如，在上图中，现在一共有了 $5$ 条边。其中，$(3,8)$ 这条边的负载是 $6$，因为有六条简单路径 $2-3-8$,$2-3-8-7$,$3-8,3-8-7$,$4-3-8$,$4-3-8-7$ 路过了 $(3,8)$。

现在，你的任务就是随着边的添加，动态的回答小强对于某些边的负载的询问。

## 说明/提示

对于所有数据，$1≤N,Q≤10^5$

## 样例 #1

### 输入

```
8 6
A 2 3
A 3 4
A 3 8
A 8 7
A 6 5
Q 3 8```

### 输出

```
6```

# 题解

## 作者：hezlik (赞：57)

**题目大意**：给定 $n$ 个点，要求支持两种操作 $m$ 次：
1. `A x y`，加入一条边 $(x,y)$，保证图的形态始终是森林。
2. `Q x y`，查询经过边 $(x,y)$ 的路径数量，保证 $(x,y)$ 存在于当前的树中。

**数据范围**：
* $1\leq n,m\leq 10^5$。

~~怎么大家都是什么 LCT 树链剖分线段树的，树状数组 dfs 序它不香咩。~~

首先很容易想到，我们只需要维护每个点当前的根和当前的子树大小就可以很容易做这道题了。

然后就是怎么维护的问题，我们可以先离线建出加入所有边后的树（森林），那么根可以用并查集维护，子树大小可以用树状数组 + dfs 序来维护。

具体的，对于一条边 $(x,y)$，假设 $y$ 是 $x$ 的父亲。若是加入这条边，那么我们需要将 $(y,rot_y)$ 这条链加上 $siz_x$，并将 $x$ 子树中所有点的根设为 $rot_y$；若是查询，则答案为：
$$
siz_x(siz_{rot_{y}}-siz_x)
$$

这之中涉及的所有操作均可用并查集和树状数组 + dfs 序解决。

什么？怎么用树状数组 + dfs 序维护这个东西？

对于链加操作，我们在 $y$ 处加上 $siz_x$，在 $fa_{rot_y}$ 处减去 $siz_x$，那么在查询的时候就变成了查询子树和，接下来就是 dfs 序 + 数据结构维护的经典操作了。

时间复杂度 $O(n+m\log n)$。

代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;

typedef long long LL;

const int N=100000;

int n,cq,qopt[N+9],qx[N+9],qy[N+9];
struct side{
  int y,next;
}e[N*2+9];
int lin[N+9],cs;

void Ins(int x,int y){e[++cs].y=y;e[cs].next=lin[x];lin[x]=cs;}
void Ins2(int x,int y){Ins(x,y);Ins(y,x);}

void into(){
  scanf("%d%d",&n,&cq);
  for (int i=1;i<=cq;++i){
    char opt[2];
    scanf("%s%d%d",opt,&qx[i],&qy[i]);
    if (!(qopt[i]=opt[0]=='Q')) Ins2(qx[i],qy[i]);
  }
}

int fa[N+9],ld[N+9],rd[N+9],co;

void Dfs_ord(int k,int fat){
  fa[k]=fat;
  ld[k]=++co;
  for (int i=lin[k];i;i=e[i].next)
    if (e[i].y^fat) Dfs_ord(e[i].y,k);
  rd[k]=co;
}

void Get_ord(){
  for (int i=1;i<=n;++i)
    if (!ld[i]) Dfs_ord(i,0);
}

struct union_find_set{
  int fa[N+9];
  int &operator [] (const int &p){return fa[p];}
  void Build(){for (int i=1;i<=n;++i) fa[i]=i;}
  int Query_fa(int k){return k^fa[k]?fa[k]=Query_fa(fa[k]):k;}
}uni;

int c[N+9];

void Add(int p,int v){if (!p) return;for (;p<=n;p+=p&-p) c[p]+=v;}
int Query(int p){int res=0;for (;p;p-=p&-p) res+=c[p];return res;}
int Query(int l,int r){return Query(r)-Query(l-1);}

LL ans[N+9];

void Get_ans(){
  uni.Build();
  for (int i=1;i<=n;++i) Add(ld[i],1),Add(ld[fa[i]],-1);
  for (int i=1;i<=cq;++i){
    int x=qx[i],y=qy[i];
    if (ld[x]<ld[y]) swap(x,y);
    int fy=uni.Query_fa(y),t=Query(ld[x],rd[x]);
    if (qopt[i]) ans[i]=(LL)t*(Query(ld[fy],rd[fy])-t);
    else Add(ld[y],t),Add(ld[fa[uni[x]=fy]],-t);
  }
}

void work(){
  Get_ord();
  Get_ans();
}

void outo(){
  for (int i=1;i<=cq;++i)
    if (qopt[i]) printf("%lld\n",ans[i]);
}

int main(){
  into();
  work();
  outo();
  return 0;
}
```

---

## 作者：hsfzLZH1 (赞：57)

## 题目大意

给定 $n$ 个结点和 $q$ 次操作，每个操作为如下形式：

```A x y``` 在结点 $x$ 和 $y$ 之间连接一条边。

```Q x y``` 给定一条已经存在的边 $(x,y)$ ，求有多少条简单路径，其中包含边 $(x,y)$ 。

保证在任意时刻，图的形态都是一棵森林。

$1\le n,q,x,y\le 10^5$

## 解题思路

为询问 ```Q``` 考虑另一种表述，我们发现答案等于边 $(x,y)$ 在 $x$ 侧的结点数与 $y$ 侧的结点数的乘积，即将边 $(x,y)$ 断开后分别包含 $x$ 和 $y$ 的树的结点数。为了消除断边的影响，在询问后我们再次连接边 $(x,y)$ 。

题目中的操作既有连边，又有删边，还保证在任意时刻都是一棵森林，我们不由得想到用 LCT 来维护。但是这题中 LCT 维护的是子树的大小，不像我们印象中的维护一条链的信息，而 LCT 的构造 **认父不认子** ，不方便我们直接进行子树的统计。怎么办呢？

方法是统计一个结点 $x$ 所有虚儿子（即父亲为 $x$ ，但 $x$ 在 splay 中的左右儿子并不包含 $x$ ）所代表的子树的贡献。

定义 $siz2[x]$ 为结点 $x$ 的所有虚儿子代表的子树的结点数， $siz[x]$ 为 结点 $x$ 子树中的结点数。

不同于以往我们维护 Splay 中子树结点个数的方法，我们在计算结点 $x$ 子树中的结点数时，还要加上 $siz2[x]$ ，即

```cpp
void maintain(int x){clear(0);if(x)siz[x]=siz[ch[x][0]]+1+siz[ch[x][1]]+siz2[x];}
```

而且在我们 **改变 Splay 的形态** （即改变一个结点在 Splay 上的左右儿子指向时），需要及时修改 $siz2[x]$ 的值。

在 ```rotate,splay``` 操作中，我们都只是改变了 Splay 中结点的相对位置，没有改变任意一条边的虚实情况，所以不对 $siz2[x]$ 进行任何修改。

在 ```access``` 操作中，在每次 splay 完后，都会改变刚刚 splay 完的结点的右儿子，即该结点与其原右儿子的连边和该节点和新右儿子的连边的虚实情况发生了变化，我们需要加上新变成虚边所连的子树的贡献，减去刚刚变成实边所连的子树的贡献。代码如下：

```cpp
void access(int x)
{
	for(int f=0;x;f=x,x=fa[x])
	splay(x),siz2[x]+=siz[ch[x][1]]-siz[f],ch[x][1]=f,maintain(x);
}
```

在 ```makeroot,find``` 操作中，我们都只是调用了之前的函数或者在 Splay 上条边，并不用做任何修改。

在连接两点时，我们修改了一个结点的父亲。我们需要在父亲结点的 $siz2$ 值中加上新子结点的子树大小贡献。

```cpp
st.makeroot(x);
st.makeroot(y);
st.fa[x]=y;
st.siz2[y]+=st.siz[x];
```

在断开一条边时，我们只是删除了 Splay 上的一条实边， ```maintain``` 操作会维护这些信息，不需要做任何修改。

代码修改的细节讲完了，现在我们总结一下 LCT 维护子树信息的要求和方法：

1. 维护的信息要有 **可减性** ，如子树结点数，子树权值和，但不能直接维护子树最大最小值，因为在将一条虚边变成实边时要排除原先虚边的贡献。

2. 新建一个附加值存储虚子树的贡献，在统计时将其加入本结点答案，在改变边的虚实时及时维护。

3. 其余部分同普通 LCT ，在统计子树信息时一定将其作为根节点。

4. 如果维护的信息没有可减性，如维护区间最值，可以对每个结点开一个平衡树维护结点的虚子树中的最值。


## 代码展示

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int maxn=100010;
typedef long long ll;
struct Splay
{
	int ch[maxn][2],fa[maxn],siz[maxn],siz2[maxn],tag[maxn];
	void clear(int x){ch[x][0]=ch[x][1]=fa[x]=siz[x]=siz2[x]=tag[x]=0;}
	int getch(int x){return ch[fa[x]][1]==x;}
	int isroot(int x){return ch[fa[x]][0]!=x&&ch[fa[x]][1]!=x;}
	void maintain(int x){clear(0);if(x)siz[x]=siz[ch[x][0]]+1+siz[ch[x][1]]+siz2[x];}
	void pushdown(int x)
	{
		if(tag[x])
		{
			if(ch[x][0])swap(ch[ch[x][0]][0],ch[ch[x][0]][1]),tag[ch[x][0]]^=1;
			if(ch[x][1])swap(ch[ch[x][1]][0],ch[ch[x][1]][1]),tag[ch[x][1]]^=1;
			tag[x]=0;
		}
	}
	void update(int x)
	{
		if(!isroot(x))update(fa[x]);
		pushdown(x);
	}
	void rotate(int x)
	{
		int y=fa[x],z=fa[y],chx=getch(x),chy=getch(y);
		fa[x]=z;if(!isroot(y))ch[z][chy]=x;
		ch[y][chx]=ch[x][chx^1];fa[ch[x][chx^1]]=y;
		ch[x][chx^1]=y;fa[y]=x;
		maintain(y);maintain(x);maintain(z);
	}
	void splay(int x)
	{
		update(x);
		for(int f=fa[x];f=fa[x],!isroot(x);rotate(x))
		if(!isroot(f))rotate(getch(x)==getch(f)?f:x);
	}
	void access(int x)
	{
		for(int f=0;x;f=x,x=fa[x])
		splay(x),siz2[x]+=siz[ch[x][1]]-siz[f],ch[x][1]=f,maintain(x);
	}
	void makeroot(int x)
	{
		access(x);splay(x);
		swap(ch[x][0],ch[x][1]);
		tag[x]^=1;
	}
	int find(int x)
	{
		access(x);splay(x);
		while(ch[x][0])x=ch[x][0];
		splay(x);
		return x;
	}
}st;
int n,q,x,y;
char op;
int main()
{
	scanf("%d%d",&n,&q);
	while(q--)
	{
		scanf(" %c%d%d",&op,&x,&y);
		if(op=='A')
		{
			st.makeroot(x);
			st.makeroot(y);
			st.fa[x]=y;
			st.siz2[y]+=st.siz[x];
		}
		if(op=='Q')
		{
			st.makeroot(x);st.access(y);st.splay(y);
			st.ch[y][0]=st.fa[x]=0;
			st.maintain(x);
			st.makeroot(x);st.makeroot(y);
			printf("%lld\n",(ll)(st.siz[x]*st.siz[y]));
			st.makeroot(x);
			st.makeroot(y);
			st.fa[x]=y;
			st.siz2[y]+=st.siz[x];
		}
		//for(int i=1;i<=n;i++)printf("%d %d %d %d %d %d\n",i,st.ch[i][0],st.ch[i][1],st.fa[i],st.siz[i],st.siz2[i]);
	}
	return 0;
}
```

---

## 作者：Ynoi (赞：41)

好像没有树剖的题解啊

由于这题没有删边操作

然后又没有强制在线

我们可以把最终形成的森林的形态建出来

我们可以建一个超级root　将森林变成树

我们维护每一阶段的每个点子树大小（节点个数），同时用并查集维护每个点此时的根

我们定义find(x)为这个阶段x的根
（为啥定义的是find呢，因为寻根是并查集操作）

size(x)为这个阶段x的子树大小（节点个数）


`A x y`操作：

假设x 是y的父节点

我们把x到find(x)的每个点都加上size(y)即可

路径上加一个值，我们可以用树剖来维护

最后再并查集merge一下(x,y)

`Q x y`操作：

假设x是y的父节点

则答案就是`(size(x) - size(y))*(size(y))`

这里所要用到的询问，是区间加，单点询问，可以差分后维护树状数组

下面是代码，175ms，写这篇题解的在最优解排名在第一页rk6，应该还是比较快的

```#include<bits/stdc++.h>
using namespace std;

#define MAXN 400005
#define lowbit(x) (x&(-x))
#define LL long long

int n,m;
int f[MAXN];

struct bian
{
	int x,y,ls;
}b[MAXN];
int t[MAXN],cnt;

struct aa
{
	bool opt;
	int x,y;
}p[MAXN];

void print(int x)
{
    if(x<0)
    {
        putchar('-');
        x=-x;
    }
    if(x>9)
        print(x/10);
    putchar(x%10+'0');
}

inline int read()
{
    register int x = 0 , ch = getchar();
    while( !isdigit( ch ) ) ch = getchar();
    while( isdigit( ch ) ) x = x * 10 + ch - '0' , ch = getchar();
    return x;
}

void jb(int x,int y)//建边
{
	cnt ++;
	b[cnt].x = x;
	b[cnt].y = y;
	b[cnt].ls = t[x];
	t[x] = cnt;
}

void rd()
{
	cin >> n >> m;
	for(int i = 1; i <= m; i ++)
	{
		char ch = 0;
		while(ch != 'A' && ch != 'Q') ch = getchar();
		
		if(ch == 'A') p[i].opt = 1;
		else p[i].opt = 0;
		
		p[i].x = read();
		p[i].y = read();
		if(p[i].opt == 1)
		{
			jb(p[i].x,p[i].y);
			jb(p[i].y,p[i].x);
		}	
	}
}

void csh(){//并查集初始化
	for(int i = 1; i <= n; i ++) f[i] = i; 
}

int find(int x)
{
	if(f[x] == x) return x;
	return f[x] = find(f[x]);
}

void mg(int x,int y)//mg就是merge
{
	f[find(y)] = find(x);
}

int c[MAXN];

void jia(int x,int y) {
	for(; x <= n; x += lowbit(x))
		c[x] += y;
}

int he(int x)
{
	int ans = 0;
	for(; x > 0; x -= lowbit(x))
		ans += c[x];
	return ans;
}

int ht[MAXN],th[MAXN],z[MAXN],s[MAXN],a[MAXN];
int fa[MAXN];



void dfs(int x)
{
	s[x] = 1;
	int mz = 0;
	for(int i = t[x]; i != 0; i = b[i].ls)
	{
		int y = b[i].y;
		if(y != fa[x]) {
			fa[y] = x;
			dfs(y);
			s[x] += s[y];
			if(s[y] > mz) 
			{
				mz = s[y];
				z[x] = y;
			}
		}
	}
}

void dfs2(int x,int _ht,int _th)
{
	ht[x] = _ht;
	th[x] = _th;
	
	cnt ++;
	a[x] = cnt;
	if(z[x])
	{
		dfs2(z[x],_ht,_th);
	}
	for(int i = t[x]; i != 0 ; i = b[i].ls)
	{
		int y = b[i].y;
		if(y != fa[x] && y != z[x]) {
			dfs2(y,y,_th+1);
		}
	}
}

void optA(int x,int y,int s)//x到y每个点点权+s
{
	while(ht[x] != ht[y])
	{
		jia(a[ht[x]],s);
		jia(a[x]+1,-s);
		x = fa[ht[x]];
	}
	jia(a[y],s);
	jia(a[x]+1,-s);
}

signed main()
{
	rd();
	csh();
	for(int i = 1; i <= m; i ++) {
		if(p[i].opt == 1) {
			mg(p[i].x,p[i].y);
		}
	}
	for(int i = 1; i <= n; i ++)
	{
		if(find(i) == i) {
			jb(i,n+1);
			jb(n+1,i);
		}
	}
	n ++;
	csh();
	dfs(n);
	cnt = 0;
	dfs2(n,n+1,1);
	jia(1,1);
	for(int i = 1; i <= m; i ++)
	{
		int x = p[i].x,y = p[i].y;
		if(fa[x] == y) swap(x,y);//确保y的父亲是x
			
		if(p[i].opt == 1)
		{
			optA(x,find(x),he(a[y]));
			mg(x,y);
		} else {
			LL ans = 0;
			int sa = he(a[find(x)]),sb = he(a[y]);
			ans = 1ll*(sa-sb)*sb;
			print(ans);
			puts("");
		}
	}
	
	return 0;
}

```

~~树链剖分写树链剖分，我　写　我　自　己~~

---

## 作者：_Chris° (赞：30)

# 线段树合并

~~线段树天下第一~~

很明显我们要快速求出x或y的子树大小

所以一个明显的思路是要让x或y的子树的编号连续,于是我们就可以离线啦

我们离线建立森林,每个点维护线段树的dfs序编号

那么对于加边就直接线段树合并

对于查询,我们令x为编号较大的节点(也就是x的father为y)

那么直接区间查询(d[x],d[x]+siz[x]-1)的点的个数

y同理

## Code

```cpp
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<algorithm>
#define N 100010
#define mid ((L+R)>>1)
#define ll long long
using namespace std;
struct Node{char op;int x,y;}p[N];
int n,m,q,k,d[N],g[N],fa[N],siz[N];//d:dfs序,g:并查集 
int head[N],to[N<<1],nexts[N<<1];
void add(int u,int v){to[++k] = v; nexts[k] = head[u]; head[u] = k;}
int find(int x){return g[x]==x?x:g[x]=find(g[x]);}
void dfs(int x,int f)
{
	fa[x] = f; siz[x] = 1; d[x] = ++m;//建立dfs序 
	for(int i=head[x];i;i=nexts[i])
	{
		int v = to[i];
		if(v == f) continue;
		dfs(v,x);
		siz[x] += siz[v];
	} 
}
int rt[N],ls[N*64],rs[N*64],sum[N*64];//sum区间和 
void Build(int &t,int L,int R,int x)
{
	if(!t) t = ++k;
	if(L == R) {sum[t]++; return ;}
	if(x <= mid) Build(ls[t],L,mid,x);
	else Build(rs[t],mid+1,R,x);
	sum[t] = sum[ls[t]]+sum[rs[t]];
}
void Merge(int &x,int &y,int L,int R)
{
	if(!x || !y) {x += y; return ;}
	if(L == R) {sum[x] += sum[y]; return;}
	Merge(ls[x],ls[y],L,mid);
	Merge(rs[x],rs[y],mid+1,R);
	sum[x] = sum[ls[x]]+sum[rs[x]]; 
}
int query(int t,int L,int R,int x,int y)
{
	if(!t || x > y) return 0;
	if(L == x && R == y) return sum[t];
	if(y <= mid) return query(ls[t],L,mid,x,y);
	if(x >  mid) return query(rs[t],mid+1,R,x,y);
	return query(ls[t],L,mid,x,mid)+query(rs[t],mid+1,R,mid+1,y);
}
int main()
{
	scanf("%d%d",&n,&q);
	for(int i=1;i<=q;i++)//离线 
	{
		scanf(" %c%d%d",&p[i].op,&p[i].x,&p[i].y);
		if(p[i].op == 'A')
		{
			add(p[i].x,p[i].y);
			add(p[i].y,p[i].x);
		}
	}
	for(int i=1;i<=n;i++) if(!d[i]) dfs(i,0);
	for(int i=1;i<=n;i++) Build(rt[i],1,m,d[i]),g[i] = i;//线段树维护的是dfs序编号 
	for(int i=1;i<=q;i++)
	{
		if(p[i].op == 'A')
		{
			int fx = find(p[i].x);
			int fy = find(p[i].y);
			g[fx] = fy;//并查集合并 
			Merge(rt[fy],rt[fx],1,n);//线段树合并 
		}else
		{
			if(fa[p[i].y] == p[i].x) swap(p[i].x,p[i].y);//保证x在y的下面 
			int x = p[i].x; int a = find(x);
			int ans1 = query(rt[a],1,m,d[x],d[x]+siz[x]-1);//查询x的子树大小 
			int ans2 = query(rt[a],1,m,1,d[x]-1)+query(rt[a],1,m,d[x]+siz[x],n);//查询y的子树大小 
			printf("%lld\n",(ll)ans1*(ll)ans2);
		}
	}
	return 0;
}
```


---

## 作者：FlashHu (赞：29)

LCT维护子树信息的思路总结与其它问题详见[我的LCT总结](http://www.cnblogs.com/flashhu/p/8324551.html)

## 思路分析

动态连边，LCT题目跑不了了。然而这题又有点奇特的地方。

我们分析一下，查询操作就是要让我们求出砍断这条边后，x和y各自子树大小的乘积。

掌握了LCT如何维护虚子树信息和后，做法就很清晰了。split(x,y)后，输出x的虚子树和+1与y的虚子树和+1的乘积；或者，（以y为根）输出x的子树总和与y的子树总和减去x的子树总和的乘积。

代码如下（这次我试着写了一个单旋"Spaly"，~~好像常数还小不少。。。。。。~~）
```
#include<cstdio>
#include<cstdlib>
#define R register int
#define I inline void
const int N=100009;
int f[N],c[N][2],si[N],s[N];
bool r[N];
#define lc c[x][0]
#define rc c[x][1]
inline bool nroot(R x){return c[f[x]][0]==x||c[f[x]][1]==x;}
I pushup(R x){
	s[x]=s[lc]+s[rc]+si[x]+1;
}
I pushdown(R x){
	if(r[x]){
		R t=lc;lc=rc;rc=t;
		r[lc]^=1;r[rc]^=1;r[x]=0;
	}
}
I pushall(R x){
	if(nroot(x))pushall(f[x]);
	pushdown(x);
}
I rotate(R x){
	R y=f[x],z=f[y],k=c[y][1]==x,w=c[x][!k];
	if(nroot(y))c[z][c[z][1]==y]=x;c[x][!k]=y;c[y][k]=w;
	f[w]=y;f[y]=x;f[x]=z;
	pushup(y);
}
I splay(R x){//请忽略这个spaly
	pushall(x);
	while(nroot(x))rotate(x);
	pushup(x);
}
I access(R x){
	for(R y=0;x;x=f[y=x]){
		splay(x);
		si[x]+=s[rc];
		si[x]-=s[rc=y];
		//pushup(x);试着去掉，发现对答案无影响
	}
}
I makeroot(R x){
	access(x);splay(x);
	r[x]^=1;
}
I split(R x,R y){
	makeroot(x);
    access(y);splay(y);
}
I link(R x,R y){
	split(x,y);
	si[f[x]=y]+=s[x];
	pushup(y);
}//LCT模板到此结束
#define G ch=getchar()
#define gc G;while(ch<'-')G
#define in(z) gc;z=ch&15;G;while(ch>'-')z*=10,z+=ch&15,G;
int main(){
	register char ch;
	register bool fl;
	R n,q,u,v;
	in(n);in(q);
	for(R i=1;i<=n;++i)s[i]=1;
	while(q--){
		gc;fl=ch=='A';in(u);in(v);
		if(fl)link(u,v);
		else{
			split(u,v);
			printf("%lld\n",(long long)(si[u]+1)*(si[v]+1));//可以换成上面提到的另一种
		}
	}
	return 0;
}
```

---

## 作者：Elegia (赞：14)

看到很多人用 LCT 水过了此题，本人并没写过 LCT ，所以只好用一种笨办法，但是比 LCT 常数低太多。

对这个森林的操作只有不断地连边，而没有删边，我们不妨看成这本来是一棵树，接着不断有边被“点亮”，就合并了子树。最开始读一遍，把这颗树建出来，再重新扫一遍，连边的时候，用并查集维护每个节点所在树的根。

统计每个节点的子树大小。通过 $(u, v)$ 边合并两颗树的时候 不妨设在大树中 $u$ 是较高的，把较低的那颗树的大小加到大树上，把 $u$ 一路到根节点的子树大小都加上 $\mathrm{size}(v)$ 。这个是可以用树链剖分 + 树状数组维护的。

总复杂度 $\Theta(n + q\log^2 n)$ 。常数原因比普通人写的 LCT 跑得还快。


注：样例代码只有开启 $\texttt{C++11}$ 及以上版本才可以通过编译，这是因为作者弄巧成拙，强行动用了 $\texttt{std::itoa()}$ 函数，其实没大用，就是缩行了一个循环赋值。
```cpp
#include <cstdio>

#include <algorithm>
#include <numeric>

using namespace std;

struct edge {
	int v;
	edge* next;
};

const int N = 100010;

int n;
char opt[N];
int eu[N], ev[N], p[N], f[N], son[N], sum[N], fw[N], ord[N];
int top[N];
edge* g[N];

int find(int x);
void add_edge(int u, int v);
void dfs1(int u);
void dfs2(int u);
void change(int k, int x);
void tchange(int u, int x);
int query(int k);
int low_bit(int k);

int main() {
	int q;
	scanf("%d%d", &n, &q);
	for (int i = 1; i <= q; ++i) {
		scanf(" %c%d%d", &opt[i], &eu[i], &ev[i]);
		if (opt[i] == 'A') {
			add_edge(eu[i], ev[i]);
			add_edge(ev[i], eu[i]);
		}
	}
	for (int u = 1; u <= n; ++u)
		if (!p[u]) {
			p[u] = -1;
			dfs1(u);
		}
	for (int u = 1; u <= n; ++u)
		if (p[u] == -1) {
			top[u] = u;
			dfs2(u);
		}
	iota(f + 1, f + n + 1, 1);
	for (int i = 1; i <= n; ++i) {
		tchange(i, 1);
		tchange(p[i], -1);
	}
	for (int i = 1; i <= q; ++i) {
		int u = eu[i], v = ev[i];
		if (p[u] == v)
			swap(u, v);
		int sv = query(ord[v]);
		if (opt[i] == 'A') {
			f[v] = find(u);
			tchange(u, sv);
			tchange(p[f[u]], -sv);
		} else {
			int s = query(ord[find(u)]);
			printf("%d\n", (s - sv) * sv);
		}
	}
	return 0;
}

void tchange(int u, int x) {
	while (u != -1) {
		change(ord[top[u]], x);
		change(ord[u] + 1, -x);
		u = p[top[u]];
	}
}

void dfs2(int u) {
	static int t;
	ord[u] = ++t;
	if (!son[u])
		return;
	top[son[u]] = top[u];
	dfs2(son[u]);
	for (edge* q = g[u]; q; q = q->next)
		if (p[q->v] == u && q->v != son[u]) {
			top[q->v] = q->v;
			dfs2(q->v);
		}
}

int low_bit(int k) {
	return k & -k;
}

void change(int k, int x) {
	for (; k <= n; k += low_bit(k))
		fw[k] += x;
}

int query(int k) {
	int ret = 0;
	for (; k; k -= low_bit(k))
		ret += fw[k];
	return ret;
}

void dfs1(int u) {
	sum[u] = 1;
	for (edge* q = g[u]; q; q = q->next)
		if (!p[q->v]) {
			p[q->v] = u;
			dfs1(q->v);
			sum[u] += sum[q->v];
			if (sum[son[u]] < sum[q->v])
				son[u] = q->v;
		}
}

int find(int x) {
	return f[x] == x ? x : (f[x] = find(f[x]));
}

void add_edge(int u, int v) {
	static edge pool[N * 2];
	static edge* p = pool;
	p->v = v;
	p->next = g[u];
	g[u] = p;
	++p;
}
```

---

## 作者：zyt1253679098 (赞：13)

分享一个线段树分治做法。

~~广告：如果我把洛谷的markdown用出锅了请到我的博客去看[【洛谷4219】[BJOI2014]大融合（线段树分治）](https://www.cnblogs.com/zyt1253679098/p/10265586.html)~~

分析：
=

很明显，查询的是删掉某条边后两端点所在连通块大小的乘积。

有加边和删边，想到LCT。但是我不会用LCT查连通块大小啊。~~果断弃了~~

有加边和删边，还跟连通性有关，于是开始yy线段树分治做法（不知道线段树分治？推荐一个~~伪模板~~题[BZOJ4025二分图](https://www.cnblogs.com/zyt1253679098/p/10014932.html)~~事实上这个链接是指向我的博客的~~）。把每次操作（加边或查询）看做一个时刻，一条边存在的区间就是它加入后没有被查询的时间区间的并。于是用可撤销并查集维护一下连通块大小即可。

代码：
=

~~不要再吐槽#undef了，还不是他们整天在我的标准库里加奇怪的define~~

```cpp
#include <cstdio>
#include <cstring>
#include <cctype>
#include <algorithm>
#include <map>
#include <cassert>
#undef i
#undef j
#undef k
#undef min
#undef max
#undef true
#undef false
#undef swap
#undef sort
#undef if
#undef for
#undef while
#undef printf
#undef scanf
#undef putchar
#undef getchar
#define _ 0
using namespace std;

namespace zyt
{
	template<typename T>
	inline bool read(T &x)
	{
		char c;
		bool f = false;
		x = 0;
		do
			c = getchar();
		while (c != EOF && c != '-' && !isdigit(c));
		if (c == EOF)
			return false;
		if (c == '-')
			f = true, c = getchar();
		do
			x = x * 10 + c - '0', c = getchar();
		while (isdigit(c));
		if (f)
			x = -x;
		return true;
	}
	inline bool read(char &c)
	{
		do
			c = getchar();
		while (c != EOF && !isgraph(c));
		return c != EOF;
	}
	template<typename T>
	inline void write(T x)
	{
		static char buf[20];
		char *pos = buf;
		if (x < 0)
			putchar('-'), x = -x;
		do
			*pos++ = x % 10 + '0';
		while (x /= 10);
		while (pos > buf)
			putchar(*--pos);
	}
	typedef long long ll;
	const int N = 1e5 + 10, B = 17, QUERY = 0, ADD = 1;
	int n, q;
	ll ans[N];
	struct node
	{
		bool type;
		int x, y;
	}arr[N];
	namespace UFS
	{
		int fa[N], rk[N], size[N], top;
		struct node
		{
			int x, y, fax, rky, sizey;
		}stack[N];
		void init(const int n)
		{
			for (int i = 1; i <= n; i++)
				fa[i] = i, rk[i] = size[i] = 1;
		}
		int f(const int u)
		{
			return fa[u] == u ? u : f(fa[u]);
		}
		bool merge(const int u, const int v)
		{
			int x = f(u), y = f(v);
			if (x == y)
				return false;
			if (rk[x] > rk[y])
				swap(x, y);
			stack[top++] = (node){x, y, fa[x], rk[y], size[y]};
			fa[x] = y, size[y] += size[x];
			if (rk[x] == rk[y])
				++rk[y];
			return true;
		}
		int query(const int u)
		{
			assert(f(u) < N);
			return size[f(u)];
		}
		void undo(const int bck)
		{
			while (top > bck)
			{
				--top;
				int x = stack[top].x, y = stack[top].y;
				assert(x < N && y < N);
				fa[x] = stack[top].fax;
				rk[y] = stack[top].rky;
				size[y] = stack[top].sizey;
			}
		}
	}
	namespace Segment_Tree
	{
		struct edge
		{
			int x, y, next;
		}e[N * (B + 1)];
		int head[1 << (B + 1) | 11], ecnt;
		inline void init()
		{
			memset(head, -1, sizeof(head));
		}
		inline void add(const int a, const int b, const int c)
		{
			e[ecnt] = (edge){b, c, head[a]}, head[a] = ecnt++;
		}
		inline void insert(const int rot, const int lt, const int rt, const int ls, const int rs, const int x, const int y)
		{
			if (ls <= lt && rt <= rs)
			{
				add(rot, x, y);
				return;
			}
			int mid = (lt + rt) >> 1;
			if (ls <= mid)
				insert(rot << 1, lt, mid, ls, rs, x, y);
			if (rs > mid)
				insert(rot << 1 | 1, mid + 1, rt, ls, rs, x, y);
		}
		inline void solve(const int rot, const int lt, const int rt)
		{
			int bck = UFS::top;
			for (int i = head[rot]; ~i; i = e[i].next)
				UFS::merge(e[i].x, e[i].y);
			if (lt == rt)
			{
				if (arr[lt].type == QUERY)
					ans[lt] = (ll)UFS::query(arr[lt].x) * UFS::query(arr[lt].y);
				UFS::undo(bck);
				return;
			}
			int mid = (lt + rt) >> 1;
			solve(rot << 1, lt, mid);
			solve(rot << 1 | 1, mid + 1, rt);
			UFS::undo(bck);
		}
	}
	map<pair<int, int>, int> lastins;
	int work()
	{
		read(n), read(q);
		UFS::init(n);
		Segment_Tree::init();
		for (int i = 1; i <= q; i++)
		{
			char opt;
			read(opt), read(arr[i].x), read(arr[i].y);
			if (arr[i].x > arr[i].y)
				swap(arr[i].x, arr[i].y);
			arr[i].type = (opt == 'Q' ? QUERY : ADD);
			pair<int, int> p = make_pair(arr[i].x, arr[i].y);
			if (arr[i].type == ADD)
				lastins[p] = i;
			else
			{
				Segment_Tree::insert(1, 1, q, lastins[p], i - 1, p.first, p.second);
				lastins[p] = i + 1;
			}
		}
		for (map<pair<int, int>, int>::iterator it = lastins.begin(); it != lastins.end(); it++)
			if (it->second <= q)
				Segment_Tree::insert(1, 1, q, it->second, q, it->first.first, it->first.second);
		Segment_Tree::solve(1, 1, q);
		for (int i = 1; i <= q; i++)
			if (arr[i].type == QUERY)
				write(ans[i]), putchar('\n');
		return (0^_^0);
	}
}
int main()
{
	return zyt::work();
}
```

---

## 作者：_anll_ (赞：2)

看了一眼没见到一样的做法，思路差不多的那篇用的是树状数组，这里提供一篇树剖线段树+并查集的思路。

## 思路
比较容易发现这道题维护出**当前**时刻的自身子树大小即根节点编号就可以结束了。我们知道它最后会形成一片森林，所以不妨先离线把最后的模样勾勒出。

初始时每个点都是孤立的，即我们有 $n$ 棵树。每新出现一条边，就会将某两棵树合并。对于一条边 $(x,y)$ 而言，我们不妨钦定 $x$ 是父节点，$y$ 是子节点。对于一次合并，我们需要更新部分节点的子树大小，即 $y$ 到 $rt_y$ 的路径上的所有节点都加上 $siz_x$。路径加是树剖线段树很擅长的事情，我们直接在最开始建出的树上进行树剖线段树即可。

除此以外，我们还需要将 $x$ 的整棵子树的 $rt$ 进行更新。如果直接用线段树的话会出问题，因为没办法很好地用一个区间维护当前在 $x$ 子树内的点，原因是 dfn 序和处理当前哪些点联通的关系不大。至于连通性，我们可以拿并查集进行维护。不妨在每次合并 $x,y$ 时额外将它们并到一起，就说明它们是一颗子树上的了。至于如何快速得到根节点编号，我们每次将 $x$ 所在的连通块并入 $y$ 所在的连通块中，因为在森林里 $y$ 是 $x$ 的父亲，所以这样合并后 $Findfa(x)$ 一定就是当前 $rt_x$。

处理完以上这道题就做完了，并查集的时间复杂度远小于树剖线段树，又因 $n,q$ 同级，因此时间复杂度应是 $O(n\log^2n)$。

## 代码
```cpp
#include<vector>
#include<iostream>
#define lc p<<1
#define rc p<<1|1
#define int long long
#define mid (tr[p].l+tr[p].r)/2
using namespace std;
const int N=1e5+5;
struct X{int l,x;};
struct Y{int f,l;};
struct Tr{
	int l,r,sum,laz;
}tr[N*6];
int n,m,tid,ed[N],faa[N];
int fas[N],siz[N],dep[N],son[N];
int tot,top[N],cnt[N],id[N];
vector<Y> que[N];
vector<X> edges[N];
void dfs1(int x,int fa){
	fas[x]=fa,dep[x]=dep[fa]+1,siz[x]=1;
	for(auto p:edges[x]){
		int l=p.l,a=p.x;if(l==fa) continue;
		ed[a]=l;dfs1(l,x);siz[x]+=siz[l];
		if(siz[l]>siz[son[x]]) son[x]=l;
	}
}
void dfs2(int x,int y){
	top[x]=y;id[x]=++tot;
	if(son[x]) dfs2(son[x],y);
	for(auto p:edges[x])
		if(p.l!=son[x]&&p.l!=fas[x]) dfs2(p.l,p.l);
}
void pushup(int p){
	tr[p].sum=tr[lc].sum+tr[rc].sum;
}
void build(int l,int r,int p){
	tr[p]={l,r};
	if(l==r){
		tr[p].sum=1;
		return;
	}
	build(l,mid,lc);build(mid+1,r,rc);
	pushup(p);
}
void uplz(int p,int k){
	tr[p].laz+=k;
	tr[p].sum+=(tr[p].r-tr[p].l+1)*k;
}
void pushdown(int p){
	int k=tr[p].laz;tr[p].laz=0;
	if(k) uplz(lc,k),uplz(rc,k);
}
void update(int l,int r,int p,int k){
	if(l<=tr[p].l&&tr[p].r<=r)
		return uplz(p,k);
	pushdown(p);
	if(l<=mid) update(l,r,lc,k);
	if(mid<r) update(l,r,rc,k);
	pushup(p);
}
int Find(int a,int p){
	if(tr[p].l==tr[p].r) return tr[p].sum;
	pushdown(p);
	if(a<=mid) return Find(a,lc);
	return Find(a,rc);
}
void add(int x,int fa,int k){
	while(top[x]!=top[fa]){
		update(id[top[x]],id[x],1,k);
		x=fas[top[x]];
	}
	update(id[fa],id[x],1,k);
}
int Findfa(int x){
	if(x!=faa[x]) faa[x]=Findfa(faa[x]);
	return faa[x];
}
void HB(int x,int y){
	int fx=Findfa(x),fy=Findfa(y);
	faa[fx]=fy;
	add(fas[x],fy,Find(id[x],1));
}
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	cin>>n>>m;char op;int x,y;
	for(int i=1;i<=m;i++){
		cin>>op>>x>>y;
		if(op=='A'){
			edges[x].push_back({y,++tid});
			edges[y].push_back({x,tid});
		}
		else que[tid].push_back({x,y});
	}
	for(int i=1;i<=n;i++) faa[i]=i;
	for(int i=1;i<=n;i++){
		if(fas[i]) continue;
		dfs1(i,0);dfs2(i,i);
	}
	build(1,n,1);
	for(int i=1;i<=tid;i++){
		HB(ed[i],fas[ed[i]]);
		for(auto p:que[i]){
			int f=p.f,l=p.l;
			if(dep[f]<dep[l]) swap(f,l);
			int rt=Findfa(f);
			int a=Find(id[f],1),b=Find(id[rt],1);
			cout<<a*(b-a)<<'\n';
		}
	}
	return 0;
}
```

---

## 作者：ZBHRuaRua (赞：2)

**退役蒟蒻刚学LCT，做道看上去像LCT裸题的题目练练手。**


------------

题意：

给定一个n个点的森林，初始无边，支持两种操作：

1. 连边

1. 询问某条边的“负载”（即被点对简单路径经过的次数）



------------

 看到这个连边操作就感觉很LCT，那么再看第二个操作，发现就是断边（x，y）以后
 
 **以x为根的树的大小 和 以y为根的树的大小的乘积**
 
 那么很简单了，在lct上我们不仅维护板子中的siz，同时维护一下它的所有虚边子树siz的和（这里称之为exsiz）。
 
 这样2操作就转换为了：
 
 1. split（x，y） 【LCT板子的操作】
 1. 断边
 1. makeroot（x）并且makeroot（y）
 1. 输出siz乘积即可
 
 
相信已经很好理解了，那么代码中要注意的就是每一次更改边的虚实关系时都要注意exsiz的变化和siz的变化（其实就是在access和link中要注意这个即可）以及多多update
 
 那么上代码：
 
```cpp
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<iostream>
#include<iomanip>
#include<algorithm>
using namespace std;
struct node{
	int fa,son[2],siz,exsiz,rev;
}t[100050];
inline void update(int x)
{
	t[x].siz=t[t[x].son[0]].siz+t[t[x].son[1]].siz+t[x].exsiz+1;
}
inline void pushdown(int x)
{
	if(t[x].rev)
	{
		swap(t[x].son[0],t[x].son[1]);
		if(t[x].son[0]) t[t[x].son[0]].rev^=1;
		if(t[x].son[1]) t[t[x].son[1]].rev^=1;
		t[x].rev=0;
	}
}
inline bool isroot(int x)
{
	return t[t[x].fa].son[0]!=x&&t[t[x].fa].son[1]!=x;
}
inline int get(int x)
{
	return t[t[x].fa].son[1]==x;
}
inline void rotate(int x)
{
	int f=t[x].fa;int ff=t[f].fa;int gx=get(x);int gx2=get(f);
	if(!isroot(f))
	{
		t[ff].son[gx2]=x;
	}
	t[f].son[gx]=t[x].son[gx^1];
	t[t[x].son[gx^1]].fa=f;
	t[x].son[gx^1]=f;
	t[f].fa=x;
	t[x].fa=ff;
	update(f);
	update(x);
}
int st[100050];
inline void splay(int x)
{
	int top=0;
	int y=x;
	st[++top]=y;
	while(!isroot(y))
	{
		y=t[y].fa;
		st[++top]=y;
	}
	while(top)
	{
		pushdown(st[top--]);
	}
	while(!isroot(x))
	{
		int f=t[x].fa;
		if(isroot(f))
		{
			rotate(x);
		}
		else if(get(x)==get(f))
		{
			rotate(f);
			rotate(x);
		}
		else 
		{
			rotate(x);
			rotate(x);
		}
		update(x);
	}
}
inline void access(int x)
{
	for(int y=0;x;y=x,x=t[x].fa)
	{
		splay(x);
		t[x].exsiz+=t[t[x].son[1]].siz-t[y].siz;
		t[x].son[1]=y;
		update(x);
	}
}
inline void makeroot(int x)
{
	access(x);
	splay(x);
	t[x].rev^=1;
	pushdown(x);
}
inline void link(int x,int y)
{
	makeroot(x);
	makeroot(y);
	t[x].fa=y;
	t[y].exsiz+=t[x].siz;
	update(y);
}
inline void split(int x,int y)
{
	makeroot(x);
	access(y);
	splay(y);
}
int n,q;
int main()
{
	 scanf("%d%d",&n,&q);
	 while(q--)
	 {
	 	char typ;
	 	cin>>typ;
	 	if(typ=='A')
	 	{
	 		int x,y;
	 		scanf("%d%d",&x,&y);
	 		link(x,y);
		}
		else
		{
			int x,y;
			scanf("%d%d",&x,&y);
			split(x,y);
			t[y].son[0]=t[x].fa=0;
			update(y);
			makeroot(x);
			makeroot(y);
			long long ans=(long long)(t[x].siz)*(long long)(t[y].siz);
			printf("%lld\n",ans);
			t[x].fa=y;
			t[y].exsiz+=t[x].siz;
		}
	 }
	 return 0;
 } 
```



---

## 作者：Edward_Elric (赞：1)

## 思路

很容易想到的是每次查询答案都是边两端点子树大小的乘积。
需要动态维护。

一般来说LCT是维护路径。

子树大小该怎么维护？其实是维护LCT实虚儿子的总数。

维护两个数组即可，s表示实虚儿子的总数（子树大小），fs表示虚儿子总数。每次虚实变化，我们只需要改变fs就行

一些细节：

1.link操作中，考虑连接对y祖先的影响，需要先把y旋至根节点

2.每次实虚儿子变化，我们都需要pushup维护总数z

3.最大值50000*50000 会爆掉int

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=2e5+10;
int ch[maxn][2],s[maxn],rev[maxn],fs[maxn],fa[maxn],st[maxn];
int n,q,x,y;
char op[10+5];
inline int read(){
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+ch-'0';ch=getchar();}
	return x*f;
}
void flip(int x){
	swap(ch[x][0],ch[x][1]);rev[x]^=1;
} 
void pushup(int x){
	s[x]=s[ch[x][0]]+s[ch[x][1]]+fs[x]+1;
}
int chk(int x){
	return ch[fa[x]][1]==x;
}
int get(int x){
	return ch[fa[x]][0]==x||ch[fa[x]][1]==x;
}
void pushdown(int x){
	if(!rev[x])return;
	if(ch[x][0])flip(ch[x][0]);
	if(ch[x][1])flip(ch[x][1]);
	rev[x]=0; 
}
void rotate(int x){
	int y=fa[x],z=fa[y],k=chk(x),w=ch[x][k^1];
	ch[y][k]=w;if(w)fa[w]=y;
	if(get(y))ch[z][chk(y)]=x;fa[x]=z;
	ch[x][k^1]=y;fa[y]=x;
	pushup(y);
}
void splay(int x){
	int y=x,top=0;st[++top]=y;
	while(get(y))st[++top]=y=fa[y];
	while(top)pushdown(st[top--]);
	while(get(x)){
		y=fa[x];
		if(get(y)){
			if(chk(x)==chk(y))rotate(y);
			else rotate(x); 
		}rotate(x);
	}pushup(x);
}
void access(int x){
	for(int y=0;x;x=fa[y=x])
	splay(x),fs[x]+=s[ch[x][1]]-s[ch[x][1]=y],pushup(x);
}
void makeroot(int x){
	access(x);splay(x);flip(x);
}
void split(int x,int y){
	makeroot(x);access(y);splay(y);
}
void link(int x,int y){
	split(x,y);
	fs[fa[x]=y]+=s[x];
	pushup(y); 
}
int main(){
	n=read();q=read();
	
	for(int i=1;i<=q;i++){
		scanf("%s",op);x=read();y=read();
		if(op[0]=='A')link(x,y);
		else{
			split(x,y);
			printf("%lld\n",1ll*(fs[x]+1)*(fs[y]+1));
		}
	}
	return 0;
}
```



---

## 作者：99_wood (赞：1)

## 题目大意

- 给定 $n$ 点，$m$ 个操作如下：
	1. 加入一条边，保证连边的两点原来不连通。
	2. 询问有多少条路径通过某条边。
- $1 \leq n,m \leq 10^5$

## 分析

网上大多题解都是使用 LCT 来维护，然而蒟蒻并不会 LCT，所以这里提供一种仅使用树链剖分的解法。

不难发现某条边路径数为 $siz_x \times (siz_{root} - siz_x)$，其中 $x$ 为边所连的点中深度较大的一个，$root$ 为树根，$siz$ 为子树大小。

发现最后 $n$ 个点的形态为一个森林，所以我们可以先离线下来，建好森林再倒序删边同时回答询问。

假设删去的边连接 $x$，$y$，且 $x$，$y$ 原来的深度 $dep_x < dep_y$。删边会影响 $x$ 到根路径上的点的子树大小，以及以 $top_a$，其中 $a$ 为 $y$ 所在重链中 $y$ 一下的节点。

我们可以用树剖来维护 $siz$ 和 $dep$，断开边时，将 $x$ 到根的路径上的点的 $siz$ 都减去 $siz_y$，将 $x$ 一下的重链上节点的 $top$ 修改为 $y$. 查询时，$siz_y \times (siz_{root} - siz_y)$ 即为答案。

本做法为真·用树剖来维护树剖，复杂度为 $O(m\log^2n)$，还是很快的。

## 代码

只放出修改和查询时的核心代码，细节较多，注意更新 $dep$ 和 $siz$，完整代码可以看[我的提交](https://www.luogu.com.cn/record/77665218)。

### 修改

```cpp
fa[y] = 0;
top[y] = query(1, 1, n, dfn[y]).top;
top[x] = query(1, 1, n, dfn[x]).top;
// 更新 top
if(top[y] != y){
	modify(1, 1, n, dfn[y], dfn[y] + dep[tail[top[y]]] - dep[y], y); // 修改 y 所在重链 top
	top[y] = y;
	tail[top[y]] = tail[top[x]];
	tail[top[x]] = x;
}
siz[y] = query(1, 1, n, dfn[y]).siz; // 更新 siz
while(x){
	top[x] = query(1, 1, n, dfn[x]).top;
	mul(1, 1, n, dfn[top[x]], dfn[x], -siz[y]); // 修改 x 到根的 siz
	x = fa[top[x]];
}
```

### 查询

```cpp
siz[y] = query(1, 1, n, dfn[y]).siz;
top[x] = query(1, 1, n, dfn[x]).top;
// 更新 siz 和 top
while(fa[top[x]]){
	x = fa[top[x]];
	top[x] = query(1, 1, n, dfn[x]).top;;
}
x = top[x];
// x 跳到根
siz[x] = query(1, 1, n, dfn[x]).siz;
ans[i] = 1LL * siz[y] * (siz[x] - siz[y]); //注意 long long
```

---

## 作者：xukuan (赞：1)

首先一条边的负载就是断掉这条边后两个点所在连通块的大小

这题有连边，断边，查询的操作，考虑lct

各种操作如下：

连边：直接link

查询：先split，再输出

代码：

```cpp
#pragma GCC optimize(2) 
#include<bits/stdc++.h>
#include<iostream>
#include<cstdio>
#define ll long long
using namespace std;

char buf[100010],*p1=buf,*p2=buf;
const ll N=100010;
ll n,m;
struct Link_Cut_tree{
	ll sum,size,son[2],lazy,father;
}tree[N];

inline ll read(){
	ll x=0,tmp=1;
	char ch=getchar();
	while(!isdigit(ch)){
		if(ch=='-') tmp=-1;
		ch=getchar();
	}
	while(isdigit(ch)){
		x=(x<<3)+(x<<1)+(ch^48);
		ch=getchar();
	}
	return tmp*x;
}

inline void write(ll x){
	if(x<0){
		putchar('-');
		x=-x;
	}
	ll y=10,len=1;
	while(y<=x){
		y=(y<<3)+(y<<1);
		len++;
	}
	while(len--){
		y/=10;
		putchar(x/y+48);
		x%=y;
	}
}

inline void pushup(ll p){
	tree[p].sum=tree[tree[p].son[0]].sum+tree[tree[p].son[1]].sum+tree[p].size+1;
}

inline void pushdown(ll p){
	if(tree[p].lazy){
		swap(tree[p].son[0],tree[p].son[1]);
		tree[tree[p].son[0]].lazy^=tree[p].lazy;
		tree[tree[p].son[1]].lazy^=tree[p].lazy;
		tree[p].lazy=0;
	}
}

inline bool isroot(ll p){
	return tree[tree[p].father].son[0]!=p&&tree[tree[p].father].son[1]!=p;
}

inline bool which(ll p){
	return tree[tree[p].father].son[1]==p;
}

inline void rotate(ll p){
	ll fa=tree[p].father,fafa=tree[fa].father;
	bool w=which(p);
	if(!isroot(fa)) tree[fafa].son[which(fa)]=p;
	tree[fa].son[w]=tree[p].son[w^1];
	tree[tree[p].son[w^1]].father=fa;
	tree[p].son[w^1]=fa;
	tree[fa].father=p;
	tree[p].father=fafa;
	pushup(fa); pushup(p);
}

inline void splay(ll p){
	stack<ll> st;
	while(!st.empty()) st.pop();
	st.push(p);
	for(ll i=p; !isroot(i); i=tree[i].father) st.push(tree[i].father);
	while(!st.empty()){
		pushdown(st.top());
		st.pop();
	}
	for(ll i=tree[p].father; !isroot(p); rotate(p),i=tree[p].father){
		if(!isroot(i)){
			if(which(i)==which(p)) rotate(i);
			else rotate(p);
		}
	}
	pushup(p);
}

inline void access(ll p){
	for(ll y=0; p; p=tree[y=p].father){
		splay(p);
		tree[p].size+=tree[tree[p].son[1]].sum;
		tree[p].size-=tree[tree[p].son[1]=y].sum;
		pushup(p);
	}
}

inline ll getroot(ll p){
	access(p);
	splay(p);
	while(tree[p].son[0]){
		pushdown(p);
		p=tree[p].son[0];
	}
	return p;
}

inline void makeroot(ll p){
	access(p);
	splay(p);
	tree[p].lazy^=1;
}

inline void split(ll x,ll y){
	makeroot(x);
	access(y);
	splay(y);
}

inline void link(ll x,ll y){
	split(x,y);
	tree[tree[x].father=y].size+=tree[x].sum;
	pushup(y);
}

inline void cut(ll x,ll y){
	split(x,y);
	if(tree[y].son[which(x)^1]||tree[x].father!=y||tree[x].son[1]) return;
	tree[x].father=tree[y].son[0]=0;
	pushup(y);
}

int main(){
	n=read(); m=read();
	for(ll i=1; i<=n; i++) tree[i].sum=0;
	while(m--){
		char op; cin>>op;
		if(op=='A'){
			ll x=read(),y=read();
			link(x,y);
		}
		else if(op=='Q'){
			ll x=read(),y=read();
			split(x,y);
			write((tree[x].size+1)*(tree[y].size+1)); putchar('\n');
		}
		else cout<<"FUCK op="<<op<<endl;
	}
	return 0;
}
```

---

## 作者：_Sein (赞：0)

## 题面描述
[~~题面不可描述~~](https://www.luogu.org/problem/P42196)

## 思路
貌似$\operatorname{LCT}$瞎搞维护一下虚儿子就行了。

但细节比较多啊。

通过**瞎搞**的规律，我们可以发现，答案貌似就是($x$的儿子数$+1$)$*$($y$的儿子数$+1$)。

经过询问操作的一系列操作，其实就等价于虚儿子 $+1$ $*$ 虚儿子 $+1$

好了，就这么简单。

记得$link$的时候，将$y$调到所在辅助树的根节点，维护好状态再连。

## AC code
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#define gc getchar()
using namespace std;
const int N=1e5+10;
inline void qr(int &x)
{
	x=0;char c=gc;int f=1;
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=gc;}
	while(c>='0'&&c<='9'){x=x*10+(c^48);c=gc;}
	x*=f;
}
void qw(int x)
{
	if(x<0)x=-x,putchar(x%10+48);
	if(x/10)qw(x/10);
	putchar(x%10+48);
}
struct node{int son[2],c,s,f;bool rv;}t[N<<1];
inline bool nroot(int p){return t[t[p].f].son[0]==p||t[t[p].f].son[1]==p;}
inline void update(int p){t[p].c=t[t[p].son[0]].c+1+t[p].s+t[t[p].son[1]].c;}
inline void crv(int p)
{
	if(!p)return;
	swap(t[p].son[0],t[p].son[1]);
	t[p].rv^=1;
}
void pushdown(int p)
{
	if(t[p].rv)
	{
		crv(t[p].son[1]),crv(t[p].son[0]);
		t[p].rv=0;
	}
}
void rotate(int p,int w)
{
	int f=t[p].f,gf=t[f].f;
	int r=t[p].son[w],R=f;t[R].son[w^1]=r;if(r)t[r].f=R;
	r=p;R=gf;if(nroot(f))t[R].son[t[R].son[1]==f]=r;t[r].f=R;
	r=f;R=p;t[R].son[w]=r;t[r].f=R;update(f);update(p);
}
void dfs(int p){if(nroot(p))dfs(t[p].f);pushdown(p);}
void splay(int p)
{
	for(dfs(p);nroot(p);)
	{
		int f=t[p].f,gf=t[f].f;
		if(!nroot(f))rotate(p,t[f].son[0]==p);
		else
		{
			if(t[f].son[0]==p&&t[gf].son[0]==f)rotate(f,1),rotate(p,1);
			else if(t[f].son[0]==p&&t[gf].son[1]==f)rotate(p,1),rotate(p,0);
			else if(t[f].son[1]==p&&t[gf].son[0]==f)rotate(p,0),rotate(p,1);
			else rotate(f,0),rotate(p,0);
		}
	}
}
void access(int x)
{
	for(int y=0;x;x=t[y=x].f)
	{
		splay(x);if(t[x].son[1])t[x].s+=t[t[x].son[1]].c;
		if((t[x].son[1]=y))t[x].s-=t[y].c;update(x);
	}
}
void makeroot(int x)
{
	access(x);splay(x);crv(x);
}
void link(int x,int y)
{
	makeroot(x);access(y);splay(y);t[x].f=y;//此时y不为根，信息得不到统计，因此需要access(y),splay(y); 
	t[y].s+=t[x].c;update(y);
}
void query(int x,int y)
{
	makeroot(x);access(y);splay(y);
	qw((t[x].s+1)*(t[y].s+1));puts("");
}
int main()
{
	int n,m;qr(n),qr(m);char s[10];
	while(m--)
	{
		int x,y;
		scanf("%s",s+1);qr(x),qr(y);
		if(s[1]=='A')link(x,y);
		else query(x,y);
	}
	return 0;
}
```

---

## 作者：Great_Influence (赞：0)

LCTextended。

可以发现，只需要用LCT维护树的形态，在想办法处理子树就可以了。然而LCT不支持子树操作，这时可以用伪top-tree。直接再开一个数组维护轻儿子的大小，在link和access的时候更新数组即可。（然而link没有将另一个点access、splay处理到根的习惯的我被卡了好多次）

代码：
```cpp
#include<bits/stdc++.h>
#define For(i,a,b) for(i=(a);i<=(b);++i)
#define Forward(i,a,b) for(i=(a);i>=(b);--i)
#define Rep(i,a,b) for(register int i=(a),i##end=(b);i<=i##end;++i)
#define Repe(i,a,b) for(register int i=(a),i##end=(b);i>=i##end;--i)
using namespace std;
template<typename T>inline void read(T &x)
{
	T s=0,f=1;char k=getchar();
	while(!isdigit(k)&&(k^'-'))k=getchar();
	if(!isdigit(k)){f=-1;k=getchar();}
	while(isdigit(k)){s=s*10+(k^48);k=getchar();}
	x=s*f;
}
void file()
{
	#ifndef ONLINE_JUDGE
		freopen("test.in","r",stdin);
		freopen("test.out","w",stdout);
	#endif
}
#define Chkmax(a,b) a=a>(b)?a:(b)
#define Chkmin(a,b) a=a<(b)?a:(b)
const int MAXN=1e6+7;
static int son[MAXN][2],sz[MAXN],fa[MAXN],rev[MAXN],lit[MAXN];
namespace LCT
{
	inline void refresh(int x)
	{sz[x]=sz[son[x][0]]+sz[son[x][1]]+1+lit[x];}
	inline int isroot(int x)
	{return x!=son[fa[x]][0]&&x!=son[fa[x]][1];}
	inline int isl(int x){return x==son[fa[x]][1];}
	inline void rotate(int x)
	{
		static int f,ff,k;f=fa[x],ff=fa[f];k=isl(x);
		fa[x]=ff;if(!isroot(f))son[ff][isl(f)]=x;
		son[fa[son[x][k^1]]=f][k]=son[x][k^1];
		son[fa[f]=x][k^1]=f;refresh(f);refresh(x);
	}
	inline void pushdown(int x)
	{
		if(rev[x])
			swap(son[x][0],son[x][1]),rev[son[x][0]]^=1
			,rev[son[x][1]]^=1,rev[x]=0;
	}
	inline void splay(int x)
	{
		static int sta[MAXN],top,f;
		for(register int i=x,top=0;!isroot(i);i=fa[i])
			sta[++top]=i;
		for(;top;pushdown(sta[top--]));
		for(f=fa[x];!isroot(x);rotate(x),f=fa[x])
			if(!isroot(f))rotate(isl(f)==isl(x)?f:x);
		//for(;!isroot(x);rotate(x));
	}
	inline void access(int x)
	{
		static int t;
		for(t=0;x;t=x,x=fa[x])
		{
			splay(x);
			lit[x]+=sz[son[x][1]]-sz[t];
			if(lit[x]<0)cerr<<"ERRR"<<endl;
			son[x][1]=t;refresh(x);
		}
	}
	inline void makeroot(int x)
	{access(x);splay(x);rev[x]^=1;}
	inline void link(int x,int y)
	{makeroot(x);access(y);splay(y);
		fa[x]=y;lit[y]+=sz[x];refresh(y);}
	inline long long calans(int x,int y)
	{
		makeroot(x);access(y);splay(y);
		//cout<<sz[x]<<' '<<sz[y]<<endl;
		//cout<<lit[x]<<' '<<lit[y]<<endl;
		//cout<<son[x][0]<<' '<<son[x][1]<<endl;
	//	cout<<son[y][0]<<' '<<son[y][1]<<endl;
		return 1ll*sz[x]*(sz[y]-sz[x]);
	}
}
using namespace LCT;
static int n,m;
inline void getopt(char &x)
{for(x=0;!isupper(x);x=getchar());}
inline void work()
{
	read(n);read(m);
	Rep(i,1,n)sz[i]=1;
	static char opt;
	static int x,y;
	Rep(i,1,m)
	{
		//cerr<<i<<endl;
		getopt(opt);read(x);read(y);
		if(opt=='A')link(x,y);
		else printf("%lld\n",calans(x,y));
	}
}
int main()
{
	file();
	work();
	return 0;
}
```

还是可以看到我疯狂的调试代码的。

---


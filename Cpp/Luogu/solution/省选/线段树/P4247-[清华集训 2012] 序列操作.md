# [清华集训 2012] 序列操作

## 题目背景

**滥用评测功能将被封号。**

## 题目描述

有一个长度为 $n$ 的序列，有三个操作：

1. `I a b c` 表示将 $[a,b]$ 这一段区间的元素集体增加 $c$；
2. `R a b`表示将 $[a,b]$ 区间内所有元素变成相反数；
3. `Q a b c` 表示询问 $[a,b]$ 这一段区间中选择 $c$ 个数相乘的所有方案的和 $\mod 19940417$ 的值。

## 说明/提示

**样例说明：**

做完第一个操作序列变为 `1 3 4 4 5`。

第一次询问结果为 $3 \times 4+3 \times 4+4 \times 4=40$。

做完 `R` 操作变成 `-1 -3 -4 -4 -5`。

做完 `I` 操作变为 `-2 -4 -5 -4 -5`。

第二次询问结果为 $-2-4-5-4-5=-20$。

**数据范围：**

对于 $100\%$ 的数据，$n \leq 50000, q \leq 50000$。初始序列的元素的绝对值 $\leq 10^9$，保证 $[a,b]$ 是一个合法区间，`I` 操作中 $|c| \leq 10^9$，`Q` 操作中 $1 \leq c \leq \min(b-a+1,20)$。

## 样例 #1

### 输入

```
5 5
1 2 3 4 5
I 2 3 1
Q 2 4 2
R 1 5
I 1 3 -1
Q 1 5 1```

### 输出

```
40
19940397```

# 题解

## 作者：liuzhangfeiabc (赞：71)

终于把欠下几个月的大坑填上了……

一道比较经典的线段树维护区间问题。

考虑~~众所周知的~~线段树五问：

1、每个区间需要记录哪些值？

区间维护任选c个数的乘积之和可能比较棘手，不过注意到c只有20，我们不妨暴力地把选0~20个数的答案全都记下来。

2、需要哪些标记？

区间加标记，区间取反标记。

3、如何叠加标记（在原有标记的区间增加新的标记？）

区间加标记直接叠加就行了。

处理取反标记时，与原先的标记xor。

为了方便处理，我们钦定取反标记的优先级高于区间加标记。这样的话别忘了在加一个取反标记时把原来的区间加标记也取反。

4、如何对区间进行整体修改？

先考虑取反。

由于奇数个-1相乘是-1，偶数个-1相乘是1，所以对于区间内奇数个数的答案要取反，偶数个数的答案不变。

区间加处理起来可能比较麻烦：

设区间大小为p。

原先区间内的数是a1,a2……,ap,区间加x后变成了(a1+x),(a2+x),……,(ap+x)。

考虑对区间的第i项进行修改，我们取任意一组乘积(a1+x)·(a2+x)·……·(ai+x)

把它展开：

原式=a1·a2·……·ai + x·(a1·a2·……·ai-1+a1·a2·……·ai-2·ai + ……) + x^2·(a1·a2·……·ai-2+……) + …… 

可以观察到，这个式子对答案的贡献相当于 sigma (j=1~i) x^(i-j)·(从这i个数中选出j个数的乘积之和)。

仍然不怎么好处理，不过我们可以转而去算这样一个东西：

对于一个j个数的乘积的式子，对i个数的乘积的贡献有多少。

即：这个式子在计算第i项答案时被算过多少次。

就相当于：有多少个从p个数中选i个数的方案，包含了某特定的j个数。

相当于这j个数必须选，还要从剩余(p-j)个数中任意选出(i-j)个数。

答案是C(p-j,i-j)。

那么我们就有了式子：ans[i] = sigma(j=0~i) x^(i-j)·ans[j]·C(p-j,i-j)。

杨辉三角预处理出(n,20)以内的组合数，更新答案时注意要从大到小更新。

5、如何合并区间？

ans[now][i]= sigma (j=0~i) ans[ls][j] * ans[rs][i-j]。

即：大区间选了i个数，可以是左区间选0个，右区间选i个；左区间选1个，右区间选(i-1)个，……，左区间选i个，右区间选0个。

注意特判一下选0个的情况(应该乘1而不是乘0)，在这里wa了好几次。

于是这题就做完了，~~是不是非常简单~~。

```cpp
#include<bits/stdc++.h>
#define ln q << 1
#define rn (q << 1) | 1
#define lson ln,l,mid
#define rson rn,mid + 1,r
#define md int mid = l + r >> 1
#define lint long long
using namespace std;
const int mo = 19940417;
int n,m;
int zuhe[50010][21];
struct node{
	lint c[21],c1;
	int sz;
	bool c2;
	node(){c1 = sz = c2 = 0;memset(c,0,sizeof(c));}
}t[200010];
int a[50010];
lint tmp[21];
int read(){
	int x = 0,y = 1;
	char c;
	c = getchar();
	while(c < '0' || c > '9'){
		if(c == '-') y = -1;
		c = getchar();
	}
	while(c >= '0' && c <= '9'){
		x = (x << 1) + (x << 3) + c - '0';
		c = getchar();
	}
	return x * y;
}
void print(lint q){
	if(q >= 10) print(q / 10);
	putchar(q % 10 + '0');
}
void upd(int q){//向上更新节点 
	register int i,j;
	memset(t[q].c,0,sizeof(t[q].c));
	for(i = 0;i <= 20 && i <= t[ln].sz;++i){
		for(j = 0;j + i <= 20 && j <= t[rn].sz;++j){
			t[q].c[i + j] += t[ln].c[i] * t[rn].c[j];
		}
	}
	for(i = 0;i <= 20 && i <= t[q].sz;++i) t[q].c[i] %= mo;
}
void build(int q,int l,int r){//初始化 
	t[q].sz = r - l + 1;
	if(l == r) {
		t[q].c[0] = 1;
		t[q].c[1] = (a[l] % mo + mo) % mo; 
		return;
	}
	md;
	build(lson);
	build(rson);
	upd(q);
}
void add(int q,int x){//区间加的更新 
	if(!q || !x) return;
	register int i,j;
	tmp[0] = 1;
	for(i = 1;i <= 20 && i <= t[q].sz;++i) tmp[i] = tmp[i - 1] * x % mo;
	for(i = min(20,t[q].sz);i;--i){
		for(j = 0;j < i;++j){
			t[q].c[i] = (t[q].c[i] + t[q].c[j] * tmp[i - j] % mo * zuhe[t[q].sz - j][i - j]) % mo;
		}
	}
	t[q].c1 = (t[q].c1 + x) % mo;
}
void rev(int q){//区间取反的更新 
	if(!q) return;
	for(int i = 1;i <= 20 && i <= t[q].sz;++i) t[q].c[i] = (i & 1) ? mo - t[q].c[i] : t[q].c[i];
	t[q].c1 = mo - t[q].c1;
	t[q].c2 ^= 1;
}
void psc(int q){//下传标记 
	if(t[q].c2){
		rev(ln);
		rev(rn);
		t[q].c2 = 0;
	}
	if(t[q].c1){
		add(ln,t[q].c1);
		add(rn,t[q].c1);
		t[q].c1 = 0;
	}
}
void md1(int q,int l,int r,int al,int ar,int ax){//区间加 
	if(l >= al && r <= ar){
		add(q,ax);
		return;
	}
	psc(q);
	md;
	if(mid >= al) md1(lson,al,ar,ax);
	if(mid < ar) md1(rson,al,ar,ax);
	upd(q);
}
void md2(int q,int l,int r,int al,int ar){//区间取反 
	if(l >= al && r <= ar) {
		rev(q);
		return;
	}
	psc(q);
	md;
	if(mid >= al) md2(lson,al,ar);
	if(mid < ar) md2(rson,al,ar);
	upd(q);
}
node mg(node q,node w){//合并两段区间 
	node e;
	register int i,j;
	e.sz = q.sz + w.sz;
	for(i = 0;i <= 20 && i <= q.sz;++i){
		for(j = 0;j + i <= 20 && j <= w.sz;++j){
			e.c[i + j] = (e.c[i + j] + q.c[i] * w.c[j]) % mo;
		}
	}
	return e;
}
node query(int q,int l,int r,int al,int ar){//区间查询 
	if(l >= al && r <= ar) return t[q];
	psc(q);
	md;
	if(ar <= mid) return query(lson,al,ar);
	else if(al > mid) return query(rson,al,ar);
	else return mg(query(lson,al,ar),query(rson,al,ar));
}
int main(){
	int i,j,k,l,r,x;
	char c;
	n = read();
	m = read();
	for(i = 1;i <= n;++i) a[i] = read();
	t[0].c[0] = 1; 
	zuhe[0][0] = 1;
	for(i = 1;i <= n;++i){
		zuhe[i][0] = 1;
		for(j = 1;j <= 20 && j <= i;++j) zuhe[i][j] = (zuhe[i - 1][j] + zuhe[i - 1][j - 1]) % mo;
	}//预处理组合数 
	build(1,1,n);
	for(i = 1;i <= m;++i){
		c = getchar();
		while(c != 'I' && c != 'Q' && c != 'R') c = getchar();
		l = read();
		r = read();
		if(c == 'I'){
			x = read();
			x = (x % mo + mo) % mo;
			md1(1,1,n,l,r,x);
		}
		else if(c == 'R'){
			md2(1,1,n,l,r);
		}
		else{
			x = read();
			print((query(1,1,n,l,r).c[x] % mo + mo) % mo);
			putchar('\n');
		}
	}
	return 0;
}
```



---

## 作者：Limit (赞：15)


# 题目大意

给出一个序列,支持区间加,区间变为相反数,查询区间中取 $c$ 个数的乘积的所有方案的总和.

# 分析

先从没有修改开始,查询区间中选 $c$ 个数乘积的所有方案的总和,$c$ 的范围很小,所以可以想到用线段树维护,对于每个节点维护一个数组 $f$,$f_i$ 表示这个节点的区间中选 $i$ 个数的乘积的所有方案的总和,至于合并,可以枚举两颗子树中选取的数的个数,然后相乘计算贡献(相当于一个两个多项式相乘).

对于变为相反数的操作还是很简单的,可以发现如果是偶数个数相乘那么其中的数全部变为相反数并不会对结构产生影响,如果是奇数个数相乘那最后的结果也会变成相反数,所以只要奇偶性判断一下就好了.

然后是区间加的操作,也是本题的重点.

先从找规律开始:

对于 $a_1a_2$ 中每个数都加上 $x$ 以后,$(a_1+x)(a_2+x)=a_1a_2+(a_1+a_2)x+x^2$

对于 $a_1a_2a_3$ 中每个数都加上 $x$ 以后,$(a_1+x)(a_2+x)(a_3+x)=a_1a_2a_3+(a_1a_2+a_1a_3+a_2a_3)x+(a_1+a_2+a_3)x^2+x^3$

对于 $a_1a_2a_3a_4$ 中每个数都加上 $x$ 以后,$(a_1+x)(a_2+x)(a_3+x)(a_4+x)=a_1a_2a_3a_4+(a_1a_2a_3+a_1a_2a_4+a_1a_3a_4+a_2a_3a_4)x+(a_1a_2+a_1a_3+a_1a_4+a_2a_3+a_2a_4+a_3a_4)x^2+(a_1+a_2+a_3+a_4)x^3+x^4$

$\ldots$

对于 $a_1a_2a_3\cdots a_{n-1}a_{n}$ 中每个数都加上 $x$ 以后,$(a_1+x)(a_2+x)(a_3+x)\cdots(a_{n-1}+x)(a_{n}+x)=\sum_{i=0}^{n}f_{n-i}x^i$(其中 $f_i$ 同线段树的标记,为选出 $i$ 个数的乘积的所有方案的和,注意 $f_0=1$)

但是这样时间复杂度还是要 $\mathcal{O}(n)$ 显然是不优秀的.

那么考虑在 $a$ 选出 $j$ 个数的贡献,对于 $a_{p_1}a_{p_2}a_{p_3}\cdots a_{p_{j-1}}a_{p_j}$ 这样的一段乘积会出现在所有包含这这些数的方案中,那么这段数的贡献就是这段数的乘积 $\times$ 这段数出现在的方案的个数 $\times$ 在不同长度的方案中这段数需要乘上的 $x$ 的幂次.而对于所有的长度为 $j$ 的 $p$ 数组对于的 $a$ 数组中的数的乘积的和就是 $f_j$,于是只要计算出出现的方案数之后就变得很好计算了,至于方案数的计算可以发现这 $j$ 个数是固定不能变的,如果要计算对于 $f_i$ 的贡献时就是需要在 $n-j$ 个数中再选取 $i-j$ 个数,所以方案数就是 $C_{n-j}^{i-j}$,而这个东西可以预处理以后做到 $O(1)$ 计算,于是这道题就做好了.

最后的时间复杂度是 $\mathcal{O}(N\log_2N\times c^2)$($c$ 为 $\min(N,20)$).

# 代码

```cpp
#include<bits/stdc++.h>
#define REP(i,first,last) for(int i=first;i<=last;++i)
#define DOW(i,first,last) for(int i=first;i>=last;--i)
using namespace std;
const int MAXN=5e4+7;
const long long mod=19940417;
int N,M;
long long arr[MAXN];
long long c[MAXN][22];//通过杨辉三角计算组合数
struct LazyTag//懒标记
{
	bool flips;
	long long add;
	void Clean()//清空懒标记
	{
		flips=0;
		add=0;
	}
}ForMake;
long long Mod(long long a)//因为有负数,所以手写一个取模
{
	a%=mod;
	a+=mod;
	a%=mod;
	return a;
}
LazyTag MakeLazyTag(long long add,bool flips=0)//建一个懒标记(没啥用)
{
	ForMake.add=Mod(add);
	ForMake.flips=flips;
	return ForMake;
}
struct SegmentTree//线段树部分
{
	long long choose[22];//每个节点需要计算当前区间用选c个数的乘积的的所有方案的和
	int len;//min(right-left+1,20)
	LazyTag tag;
}sgt[MAXN*4];
#define LSON (now<<1)
#define RSON (now<<1|1)
#define MIDDLE ((left+right)>>1)
#define LEFT LSON,left,MIDDLE
#define RIGHT RSON,MIDDLE+1,right
#define NOW now_left,now_right
void PushUp(int now)//合并
{
	REP(i,0,sgt[now].len)
	{
		sgt[now].choose[i]=0;
	}
	REP(i,0,sgt[LSON].len)//枚举左右子树取的数的个数
	{
		REP(j,0,sgt[RSON].len)
		{
			if(i+j<=sgt[now].len)
			{
				sgt[now].choose[i+j]+=sgt[LSON].choose[i]*sgt[RSON].choose[j]%mod;//计算对于当前区间的贡献
				sgt[now].choose[i+j]=Mod(sgt[now].choose[i+j]);
			}
		}
	}
}
void Build(int now=1,int left=1,int right=N)//建树
{
	sgt[now].len=min(20,right-left+1);
	if(left==right)
	{
		sgt[now].choose[0]=1;//注意选0个数为1
		sgt[now].choose[1]=Mod(arr[left]);
		return;
	}
	Build(LEFT);
	Build(RIGHT);
	PushUp(now);
}
long long power[22]={1};
#define LEN (right-left+1)
void DownAdd(LazyTag tag,int now,int left,int right)//加的操作
{
	if(!tag.add)
	{
		return;
	}
	REP(i,1,sgt[now].len)//先计算加的数的幂次
	{
		power[i]=Mod(power[i-1]*tag.add);
	}
	DOW(i,sgt[now].len,1)
	{
		REP(j,0,i-1)
		{
			//计算当前必须选的长度对于当前的长度的贡献
			sgt[now].choose[i]+=(sgt[now].choose[j]*power[i-j]%mod*c[LEN-j][i-j])%mod;
			sgt[now].choose[i]%=mod;
		}
	}
	sgt[now].tag.add+=tag.add;
}
void DownFlips(LazyTag tag,int now,int left,int right)//区间变为相反数
{
	if(!tag.flips)
	{
		return;
	}
	sgt[now].tag.flips^=1;
	sgt[now].tag.add=mod-sgt[now].tag.add;//注意需要将加标记也取反
	REP(i,1,sgt[now].len)
	{
		if(i&1)//奇数位置变为相反数
		{
			sgt[now].choose[i]=mod-sgt[now].choose[i];
		}
	}
}
void PushDown(int now,int left,int right)//下传懒标记
{
	DownFlips(sgt[now].tag,LEFT);
	DownFlips(sgt[now].tag,RIGHT);
	DownAdd(sgt[now].tag,LEFT);
	DownAdd(sgt[now].tag,RIGHT);
	sgt[now].tag.Clean();
}
//修改部分不多说
void UpdataAdd(int now_left,int now_right,int add,int now=1,int left=1,int right=N)
{
	if(now_right<left||right<now_left)
	{
		return;
	}
	if(now_left<=left&&right<=now_right)
	{
		DownAdd(MakeLazyTag(add),now,left,right);
		return;
	}
	PushDown(now,left,right);
	UpdataAdd(NOW,add,LEFT);
	UpdataAdd(NOW,add,RIGHT);
	PushUp(now);
}
void UpdataFlips(int now_left,int now_right,int now=1,int left=1,int right=N)
{
	if(now_right<left||right<now_left)
	{
		return;
	}
	if(now_left<=left&&right<=now_right)
	{
		DownFlips(MakeLazyTag(0,1),now,left,right);
		return;
	}
	PushDown(now,left,right);
	UpdataFlips(NOW,LEFT);
	UpdataFlips(NOW,RIGHT);
	PushUp(now);
}
long long answer[22];//记录答案
long long help[22];//帮助计算
bool check=0;//记录当前是不是第一个找到的区间
void BeforeQuery()//查询前预处理
{
	REP(i,0,21)
	{
		answer[i]=0;
	}
	answer[0]=1;
	check=0;
}
void Query(int now_left,int now_right,int now=1,int left=1,int right=N)//查询
{
	if(now_right<left||right<now_left)
	{
		return;
	}
	if(now_left<=left&&right<=now_right)
	{
		if(!check)//如果没有查询到过就赋值
		{
			REP(i,0,sgt[now].len)
			{
				answer[i]=Mod(sgt[now].choose[i]);
			}
			check=1;
		}
		else//如果查询到过需要像合并两颗子树的方式一样合并
		{
			REP(i,0,20)
			{
				help[i]=answer[i];
				answer[i]=0;
			}
			REP(i,0,20)
			{
				REP(j,0,sgt[now].len)
				{
					if(i+j<=20)
					{
						answer[i+j]+=help[i]*sgt[now].choose[j]%mod;
						answer[i+j]=Mod(answer[i+j]);
					}
				}
			}
		}
		return;
	}
	PushDown(now,left,right);
	Query(NOW,LEFT);
	Query(NOW,RIGHT);
}
int main()
{
	scanf("%d%d",&N,&M);
	REP(i,1,N)
	{
		scanf("%lld",&arr[i]);
	}
	c[0][0]=1;//杨辉三角计算组合数
	REP(i,1,N)
	{
		c[i][0]=1;
		REP(j,1,20)
		{
			c[i][j]=Mod(c[i-1][j]+c[i-1][j-1]);
		}
	}
	Build();//建树
	char opt;
	int left,right,c;
	REP(i,1,M)
	{
		cin>>opt;
		scanf("%d%d",&left,&right);
		if(opt=='I')
		{
			scanf("%d",&c);
			UpdataAdd(left,right,c);//区间加
		}
		if(opt=='R')
		{
			UpdataFlips(left,right);//区间变为相反数
		}
		if(opt=='Q')
		{
			scanf("%d",&c);
			BeforeQuery();
			Query(left,right);//查询
			printf("%lld\n",answer[c]);
		}
	}
	return 0;
}
```

---

## 作者：tommymio (赞：10)

题意简述：
- 给定一个长度为 $n$ 的序列，支持 $n$ 个操作

	- $\text{I a b c}$ 表示将 $[a,b]$ 这一段区间的元素集体增加 $c$；
	- $\text{R a b}$ 表示将 $[a,b]$ 区间内所有元素变成相反数；
	- $\text{Q a b c}$ 表示询问 $[a,b]$ 这一段区间中选择 $c$ 个数相乘的所有方案的和 $\bmod 19940417$ 的值。
    
想了 $\text{1h30min+}$ 的细节才做出来，果然我还是组合数学菜鸡啊/dk
    
前两个操作还算正常，和 **[模板]线段树2** 是本质相同的，都是相互影响的操作。观察一下，定义取相反数的优先级更高即可。

加上第三个操作就变得棘手了很多，不妨想想只有第三个操作的做法。

注意到 $c$ 很小，显然是一个基于 $c$ 的时间复杂度的做法。可以想到 $\text{DP}$ ，设 $f[l,r,i]$ 为 $[l,r]$ 中选 $i$ 个相乘，所有方案的和。那么有 

$$
f[l,r,i]=\sum_{k=0}^i f[l,j,k]\times f[j+1,r,k]
$$

其中 $j$ 为枚举的一个常数。由于这个 $j$ 可以取任何数，所以我们可以令这个 $j$ 在任何时候都取线段中点 $mid$。

根据上式，在已经有了 $[l,mid],[mid+1,r]$ 两个区间的信息以后，我们可以合并这两个区间 $[l,mid]$ 和 $[mid+1,r]$ $\to[l,r]$。看上去是不是很像线段树的 $\text{pushup}$？那么我们可以把这个 $f$ 放在线段树上维护，如果只有第三个操作时，我们可以做到 $O(nc^2 \log n)$，相比暴力的 $O(n^2c)$，这个时间复杂度是非常优秀的。

那么考虑加入前两个操作。对于第一个操作，列举出一些情况，我们发现它的情况像是这个样子：$c=2$ 时，$a_1a_2+a_2a_3+a_1a_3\to (a_1+val)(a_2+val)+(a_2+val)(a_3+val)+(a_1+val)(a_3+val)$。$a_i$ 显然是常数，那么这是一个关于 $val$ 的 $c$ 次多项式。将 $val$ 的不同次项分开计算，可得：

$$
f'[l,r,i]=\sum_{k=0}^i\left(\binom{n-i+k}{k}f[l,r,i-k]\right)val^k
$$

其中 $f'[l,r,i]$ 为区间加操作之后的 $f[l,r,i]$。

对于第二个操作，其实就是反转正负性，将答案中每个部分的符号写出来，观察并证明，可以得到当 $c$ 为奇数时，正负性不变，$c$ 为偶数时，正负性改变，形式化的表达：

$$
f'[l,r,i]=-f[l,r,i],when \ i\equiv1\pmod 2
$$

那么根据以上三个柿子维护 $f$ ，再稍微考虑一下 $1,2$ 两个操作的优先级，这题就做完了。

- **序列的绝对值$\leq 10^9$，而非序列 $\leq 10^9$ ，注意对初始序列的取模 ~~（我才不会告诉你我被这个卡了 2h~~**

- **$19970417$ 不是质数，不能使用费马小定理，而应使用杨辉三角求组合数**

- **对取模等操作进行封装会把程序卡 $\texttt{TLE}$，本题需要一定的卡常功底请慎重食用 ~~（我才不会告诉你我被这个卡了一晚上~~**

**Show the Code**
```cpp
#include<cstdio>
#define ls p<<1
#define rs p<<1|1 
#define min(a,b) ((a)<(b)? (a):(b))
typedef long long ll;
const ll mod=19940417;
int a[50005],C[50005][25];
struct Segment {Segment() {l=r=add=0;rev=1;f[0]=1;for(register int i=1;i<=20;++i) f[i]=0;} int l,r,rev,add; int f[25];} t[200005];
inline char _read() {register char s=getchar();while(s>'Z'||s<'A') s=getchar();return s;}
inline int read() {
	register int x=0,f=1;register char s=getchar();
	while(s>'9'||s<'0') {if(s=='-') f=-1;s=getchar();}
	while(s>='0'&&s<='9') {x=x*10+s-'0';s=getchar();} 
	return x*f;
}
inline void work_add(int p,int v) {
	int n=t[p].r-t[p].l+1,lim=min(n,20); v=(v%mod+mod)%mod;
	for(register int i=lim;i>=1;--i) for(register int k=1,now=v;k<=i;++k,now=(ll)now*(ll)v%mod) t[p].f[i]=(t[p].f[i]+(((ll)C[n-(i-k)][k]*(ll)t[p].f[i-k]%mod)*(ll)now%mod))%mod;
	t[p].add=(t[p].add+v)%mod;
}
inline void work_rev(int p) {int lim=min(t[p].r-t[p].l+1,20);for(register int i=1;i<=lim;i+=2) t[p].f[i]=((mod-t[p].f[i])%mod+mod)%mod;t[p].add=((mod-t[p].add)%mod+mod)%mod;t[p].rev*=-1;}
inline void pushup(int p) {int lim=min(t[p].r-t[p].l+1,20);for(register int i=1;i<=lim;++i) {t[p].f[i]=0;for(register int k=0;k<=i;++k) t[p].f[i]=(t[p].f[i]+((ll)t[ls].f[k]*(ll)t[rs].f[i-k]%mod))%mod;}}
inline void spread(int p) { 
	if(t[p].rev!=1) {work_rev(ls);work_rev(rs);t[p].rev=1;}
	if(t[p].add) {work_add(ls,t[p].add);work_add(rs,t[p].add);t[p].add=0;}
}
inline void build(int p,int l,int r) {
	t[p].rev=1; t[p].add=0; t[p].l=l; t[p].r=r; t[p].f[0]=1; if(l==r) {t[p].f[1]=a[l];return;} 
	int mid=l+r>>1; build(ls,l,mid); build(rs,mid+1,r); pushup(p);
}
inline void modify_add(int p,int l,int r,int val) {
	int L=t[p].l,R=t[p].r,mid=L+R>>1;
	if(l<=L&&R<=r) {work_add(p,val);return;} spread(p);
	if(l<=mid) modify_add(ls,l,r,val);
	if(r>mid) modify_add(rs,l,r,val);
	pushup(p);
}
inline void modify_rev(int p,int l,int r) {
	int L=t[p].l,R=t[p].r,mid=L+R>>1;
	if(l<=L&&R<=r) {work_rev(p);return;} spread(p);
	if(l<=mid) modify_rev(ls,l,r);
	if(r>mid) modify_rev(rs,l,r);
	pushup(p);
}
inline Segment ask(int p,int l,int r) {
	int L=t[p].l,R=t[p].r,mid=L+R>>1; Segment res;
	if(l<=L&&R<=r) return t[p]; spread(p);
	if(r<=mid) return ask(ls,l,r); if(l>mid) return ask(rs,l,r);
	Segment x=ask(ls,l,mid),y=ask(rs,mid+1,r); int lim=min(R-L+1,20); 
	for(register int i=1;i<=lim;++i) {res.f[i]=0;for(register int k=0;k<=i;++k) res.f[i]=(res.f[i]+((ll)x.f[k]*(ll)y.f[i-k]%mod))%mod;} 
	return res;
}
signed main() {
	int n=read(),T=read();
	for(register int i=0;i<=20;++i) {C[i][0]=1;for(register int j=1;j<=i;++j) C[i][j]=(C[i-1][j]+C[i-1][j-1])%mod;}
	for(register int i=21;i<=n;++i) {C[i][0]=1;for(register int j=1;j<=20;++j) C[i][j]=(C[i-1][j]+C[i-1][j-1])%mod;}
	for(register int i=1;i<=n;++i) a[i]=(read()%mod+mod)%mod; build(1,1,n);
	while(T--) {
		char op=_read(); int l=read(),r=read();
		if(op=='I') {int x=read();modify_add(1,l,r,x);}
		else if(op=='R') {modify_rev(1,l,r);}
		else {int x=read();printf("%d\n",ask(1,l,r).f[x]);}
	}
	return 0;
}
```







---

## 作者：KSkun (赞：7)

# 题解
本题题解同步发布于我的博客[[THUT2012]序列操作 题解 | KSkun's Blog](https://ksmeow.moe/sequence_thut12_sol/)，欢迎来逛~

这个题里面有两种标记（相反数、区间加）和一种询问。我们分开来看。
## 标记与标记的应用
这里我们规定相反数的标记比加法标记优先级更高。试想，如果应用的顺序相反，可能会造成$-a_i+add_i$变成$-(a_i+add_i)$。

首先考虑区间信息的设置。应该记下本区间长度和一个`f[21]`数组，代表这个区间内对于每个c询问的答案。规定任意的`f[0]`为0。

如果要应用一个取相反数标记，应该将上述c为奇数时的情况的f值取相反数，因为偶数次相乘负号会抵消。

如果要应用一个区间加标记，思考对答案的改变，以`f[15]`这个值为例：

假如选择前15个值相乘，变化如下

$[a_1, a_2, \cdots, a_{15}] \to [a_1 + c, a_2 + c, \cdots, a_{15} + c]$

乘起来是这样的

$f_{15} = C_{len-15}^0 \cdot c^0 \cdot f_{15} + C_{len-14}^1 \cdot c^1 \cdot f_{14} + C_{len-13}^2 \cdot c^2 \cdot f_{13} + \cdots + C_{len-0}^{15} \cdot c^{15} \cdot f_0$

那我们就明白了，倒序求f值就好了。这里的C可以开始的时候预处理打个大表，空间是够的。区间加标记应用对应的代码长这样

```cpp
inline void add(Data &dat, LL x) {
	for(int i = std::min(dat.len, 20ll); i >= 0; i--) {
		LL t = x;
		for(int j = i - 1; j >= 0; j--) {
			dat.f[i] = (dat.f[i] + dat.f[j] * C[dat.len - j][i - j] % MO * t % MO) % MO;
			dat.f[i] = (dat.f[i] + MO) % MO;
			t = t * x % MO;
		}
	}
	dat.toadd = (dat.toadd + x) % MO;
}
```

## 区间合并
重点是要计算f值。首先考虑大区间选若干个是可以拆成左边选若干个和右边选若干个乘在一起的，这样既然左右两边的答案都是一堆乘积加起来，两块直接乘在一起就相当于两两配对后加起来，因此我们合并的公式就是：

$f_k = \sum_{i=0}^k fl_i \times fr_{k-i}$

两层循环加一下就好。

# 代码
比较长，直接贴太占版面了，可以看博客里的qwq

---

## 作者：Karry5307 (赞：3)

### 题意

给定一个长度为 $n$ 的序列 $a$ 和 $q$ 次操作，每次操作形如以下三种：

- `I a b c`，表示将 $[a,b]$ 内的元素加 $c$。

- `R a b`，表示将 $[a,b]$ 内的元素变成相反数。

- `Q a b c`，表示在 $[a,b]$ 内所有选出 $c$ 个元素的乘积之和。

对于每一个询问操作，输出答案对 $19940417$ 取模的值。

$\texttt{Data Range:}1\leq n\leq q\leq 50000$

### 题解

[不一定更好的阅读体验](https://www.cnblogs.com/Karry5307/p/13669908.html)

好题啊。

看到这种题马上想到用线段树维护区间内 $(1+a_ix)$ 的乘积，然后答案就是取一项。

考虑如何打懒标记。对于相反数的话，设 $F(x)=\prod\limits_{i=1}^{n}(1+a_ix)$，那么有

$$\prod\limits_{i=1}^{n}(1-a_ix)=\sum\limits_{i=0}^{n}(-1)^i[x^i]F(x)x^i$$

这个结论大概可以手玩一下，所以说打懒标记的时候只需要奇次项取相反数即可。

接下来是区间加这个大毒瘤，还是考虑懒标记的打法。

接下来为了方便我们用 $S_k$ 表示 $a_1,a_2,\cdots a_n$ 中取 $k$ 项的所有乘积之和，那么有

$$[1+(a_1+c)x][1+(a_2+c)x][1+(a_3+c)x]=1+(S_1+3cx)+(S_2+2S_1c+3c^2)x^2+(S_3+S_2c+S_1c^2+c^3)x^3$$

注意到我们可以枚举一下多项式的 $i$ 次项系数和这一项系数里面是取 $j$ 项的所有方案数的乘积之和，那么我们得到当前枚举的 $i,j$ 对应的 $S_j$ 的系数为：

$$\frac{\binom{n}{i}\binom{i}{j}c^{i-j}}{\binom{n}{j}}$$

这里有一个组合意义的解释：首先将 $(a_i+c)x$ 看做整体，从 $n$ 个中选出 $i$ 个构成 $(a_1+c)(a_2+c)\cdots(a_i+c)x^i$ 这一项。接下来在求出这一项中对应的 $c^{i-j}$ 的系数，也就是选了 $j$ 个 $a$ 和 $i-j$ 个 $c$。最后，一共有 $\binom{n}{j}$ 种方式从这些 $a_i$ 中出选 $j$ 个，而每种方式被计算的次数都是相等的，于是得除掉，就得到这个东西被算了几次，也就是 $S_j$ 的系数。

利用一些基本的恒等式我们有

$$\frac{\binom{n}{i}\binom{i}{j}c^{i-j}}{\binom{n}{j}}=\binom{n-j}{i-j}c^{i-j}$$

于是枚举一下这个东西就没了，时间复杂度 $O(c^2n\log n)$。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef int ll;
typedef long long int li;
const ll MAXN=5e4+51,MOD=19940417; 
struct SegmentTree{
	ll l,r,tag,tag2;
	ll f[21];
};
SegmentTree tree[MAXN<<2];
ll n,qcnt,l,r,u;
char op;
ll x[MAXN],pw[MAXN],binom[MAXN][21],g[21];
inline ll read()
{
    register ll num=0,neg=1;
    register char ch=getchar();
    while(!isdigit(ch)&&ch!='-')
    {
        ch=getchar();
    }
    if(ch=='-')
    {
        neg=-1;
        ch=getchar();
    }
    while(isdigit(ch))
    {
        num=(num<<3)+(num<<1)+(ch-'0');
        ch=getchar();
    }
    return num*neg;
}
inline void conv(ll *f,ll *g,ll *res)
{
	li cur;
	for(register int i=0;i<=20;i++)
	{
		cur=0;
		for(register int j=0;j<=i;j++)
		{
			cur+=(li)f[j]*g[i-j]%MOD;
		}
		res[i]=cur%MOD;
	}
}
#define ls node<<1
#define rs (node<<1)|1
inline void update(ll node)
{
	conv(tree[ls].f,tree[rs].f,tree[node].f);
}
inline void create(ll l,ll r,ll node)
{
	tree[node]=(SegmentTree){l,r,0,1,{1}};
	if(l==r)
	{
		return (void)(tree[node].f[1]=x[l]);
	}
	ll mid=(l+r)>>1;
	create(l,mid,ls),create(mid+1,r,rs),update(node);
}
inline void spread(ll node)
{
	if(tree[node].tag2!=1)
	{
		for(register int i=1;i<=20;i+=2)
		{
			tree[ls].f[i]=(MOD-tree[ls].f[i])%MOD;
			tree[rs].f[i]=(MOD-tree[rs].f[i])%MOD;
		}
		tree[ls].tag2*=-1,tree[rs].tag2*=-1,tree[node].tag2=1;
		tree[ls].tag=(MOD-tree[ls].tag)%MOD;
		tree[rs].tag=(MOD-tree[rs].tag)%MOD;
	}
	if(tree[node].tag)
	{
		ll lenl=tree[ls].r-tree[ls].l+1,lenr=tree[rs].r-tree[rs].l+1;
		li curl,curr;
		for(register int i=1;i<=20;i++)
		{
			pw[i]=(li)pw[i-1]*tree[node].tag%MOD;
		}
		for(register int i=20;i;i--)
		{
			curl=curr=0;
			for(register int j=0;j<i;j++)
			{
				curl+=(li)tree[ls].f[j]*pw[i-j]%MOD*binom[lenl-j][i-j]%MOD;
				curr+=(li)tree[rs].f[j]*pw[i-j]%MOD*binom[lenr-j][i-j]%MOD;
			}
			tree[ls].f[i]=(tree[ls].f[i]+curl)%MOD;
			tree[rs].f[i]=(tree[rs].f[i]+curr)%MOD;
		}
		tree[ls].tag+=tree[node].tag,tree[rs].tag+=tree[node].tag;
		tree[ls].tag%=MOD,tree[rs].tag%=MOD,tree[node].tag=0;
	}
}
inline void add(ll l,ll r,ll val,ll node)
{
	if(l<=tree[node].l&&r>=tree[node].r)
	{
		ll len=tree[node].r-tree[node].l+1;
		li cur=0;
		for(register int i=1;i<=20;i++)
		{
			pw[i]=(li)pw[i-1]*val%MOD;
		}
		for(register int i=20;i;i--)
		{
			cur=0;
			for(register int j=0;j<i;j++)
			{
				cur+=(li)tree[node].f[j]*pw[i-j]%MOD*binom[len-j][i-j]%MOD;
			}
			tree[node].f[i]=(tree[node].f[i]+cur)%MOD;
		}
		return (void)(tree[node].tag=(tree[node].tag+val)%MOD);
	}
	ll mid=(tree[node].l+tree[node].r)>>1;
	spread(node);
	l<=mid?add(l,r,val,ls):(void)1,r>mid?add(l,r,val,rs):(void)1;
	update(node);
}
inline void mul(ll l,ll r,ll node)
{
	if(l<=tree[node].l&&r>=tree[node].r)
	{
		for(register int i=1;i<=20;i+=2)
		{
			tree[node].f[i]=(MOD-tree[node].f[i])%MOD;
		}
		tree[node].tag=(MOD-tree[node].tag)%MOD;
		return (void)(tree[node].tag2*=-1);
	}
	ll mid=(tree[node].l+tree[node].r)>>1;
	spread(node);
	l<=mid?mul(l,r,ls):(void)1,r>mid?mul(l,r,rs):(void)1,update(node);
}
inline SegmentTree query(ll l,ll r,ll node)
{
	SegmentTree res;
	if(l<=tree[node].l&&r>=tree[node].r)
	{
		return tree[node];
	}	
	ll mid=(tree[node].l+tree[node].r)>>1;
	spread(node),conv(l<=mid?query(l,r,ls).f:g,r>mid?query(l,r,rs).f:g,res.f);
	return res;
}
int main()
{
	n=read(),qcnt=read(),binom[0][0]=pw[0]=g[0]=1;
	for(register int i=1;i<=n;i++)
	{
		x[i]=(read()%MOD+MOD)%MOD;
	}
	for(register int i=1;i<=n;i++)
	{
		binom[i][0]=1;
		for(register int j=1;j<=20;j++)
		{
			binom[i][j]=(binom[i-1][j]+binom[i-1][j-1])%MOD;
		}
	}
	create(1,n,1);
	for(register int i=0;i<qcnt;i++)
	{
		cin>>op,l=read(),r=read();
		if(op=='I')
		{
			u=(read()%MOD+MOD)%MOD,add(l,r,u,1);
		}
		if(op=='R')
		{
			mul(l,r,1);
		}
		if(op=='Q')
		{
			u=read();
			printf("%d\n",query(l,r,1).f[u]);
		}
	}
}
```

---

## 作者：maruize (赞：2)

首先 Q 操作 $c$ 很小，可以想到在线段树每个叶子上维护 $20$ 个标记。

- 对于每个可能的 $c$ ，维护区间内选 $c$ 个数相乘的答案，记做 $t_{0}$ ~ $t_{20}$ 。(令 $t_{0}=1$ )

然后在每个节点上维护两个 tag(rv,add) 。(为了方便，先下放 rv 后 add )

考虑操作

1. merge:

$ \quad $ 可以发现把左右区间搭配一下乘起来就是答案。

$ \quad $ 即 $t[rt]_{k}=\sum_{a+b=k}t[lc]_a\cdot r[rx]_b $


2. reverse:

$ \quad \forall a\in odd \ \ , t_a=-t_a$

3. **add (hard)**

$ \quad $ 这就比较麻烦了

$ \quad $ 考虑某种方案选了 $m$ 个数： $x_1\cdot x_2 \cdot ...\cdot x_m$

$ \quad $ 区间加 $k$ 后为 $(x_1+k)\cdot(x_2+k)\cdot ...\cdot(x_m+k)$

$ \quad $ 展开，得 ( $2^m$ 项 ) : 
$t_m(new)=\sum_{choose\ \ x_1..x_m}
\sum_{s\subseteq\{1..m\} }
k^{m-|s|}\prod_{i\in s}x_i $

$ \quad (let\ \ \{1..m\}=\{x\in \mathbb{N}|1\leq x\leq m\},|s|$为$s$的大小$)$

$ \quad $ 还是很晕。。

$ \quad $ 考虑式子中的 $\prod_{i\in s}x_i$,发现是 $t_{|s|}$ 的一部分。

$\quad$ 可以猜出每个 $t_{|s|(|s|\le m)}$ 在新 $t_m$ 中有一定贡献。

$\quad$ 即 $t_{m}(new)=\prod_{|s|=0}^{m}t_{|s|}\cdot2^{m-|s|}\cdot $ 一个系数

$\quad$ 但这个系数是多少呢？？？
~~(我组合数学一团糟想了好长时间)~~

$\quad$ 设节点rt对应区间长度为 $l0$ , $|s|=r$

$\qquad$ 是 $C_{l0}^{r}$ 吗？

$\qquad$ 先选定 $m$ 才有 $t$ 。

$\qquad$ 所以是 $C_{l0}^{m}\cdot C_{m}^{r}$ ?

$\qquad$ 我当时一直以为是这个，但是其实这个是 $\prod_{i\in s}x_i$ 的出现次数。

$\qquad$ 一个 $t_r$ 是 $C_{l0}^{r}$ 个 $\prod_i x_i$ 的和。

$\qquad$ 所以系数为 
$$\frac{C_{l0}^{m}\cdot C_{m}^{r}}{C_{l0}^r}$$


$\qquad$ 也可以认为有多少个从 $l0$ 个数中选 $m$ 个数的方案，包含了某特定的 $r$ 个数。(有一个"特定"就不会算重了)

$\qquad$ 相当于这 $r$ 个数必须选，还要从剩余 $(l0-r)$ 个数中任意选出 $(m-r)$ 个数。

$$\frac{C_{l0}^{m}\cdot C_{m}^{r}}{C_{l0}^r}
=\frac{C_{l0}^{r}\cdot C_{l0-r}^{m-r}}{C_{l0}^r}=C_{l0-r}^{m-r}$$

$\quad$ 两种想法结果是一样的。

---

$\tiny{reference:}$

$\tiny{\qquad @liuzhangfeiabc \ \ 's\ \ solution}$

$\tiny{\qquad @Karry5307 \ \ 's\ \ solution}$

---

$\color{grey}{c}\color{blue}{o}\color{purple}{d}\color{orange}{e}\color{yellow}{:}$

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<algorithm>
#include<assert.h>
using namespace std;
typedef long long LL;
const int N=1e5+100,D=20,mod=19940417;//not prime
int C[N][D+10];
#define lc (rt*2)
#define rc (rt*2|1)
#define X tree[rt]
#define Lc tree[lc]
#define Rc tree[rc]
#define chk(i) (i>=mod?i-=mod:(i<0?i+=mod:i))
struct node{
	int t[D+2],add,l,r;
	bool rv;//rv/rev isn't reverse seq,is reverse num
	void tagA(int v){
		if(!v)return;
		add+=v,chk(add);
		for(int l0=r-l+1,i=min(D,l0);i>0;i--){//(**)i=min... to prevent index out of bounds 
			int a=0,k=1;
			for(int j=i;j>=0;j--)
				a+=(LL)t[j]*k%mod*C[l0-j][i-j]%mod,
				chk(a),k=(LL)k*v%mod;//(***)*v not *add
			t[i]=a;
		}
	}
	void tagR(){
		rv^=1,add=-add,chk(add);
		for(int i=1;i<=D;i+=2)t[i]=-t[i],chk(t[i]);
	}
}tree[N*4];
void pushup(int rt){
	assert(!X.rv&&!X.add);
	for(int i=0;i<=D;i++)X.t[i]=0;//***
	for(int i=0;i<=D;i++)
		for(int j=0;i+j<=D;j++)
			X.t[i+j]+=(LL)Lc.t[i]*Rc.t[j]%mod,chk(X.t[i+j]);
}
void putdown(int rt){
	if(X.rv)Lc.tagR(),Rc.tagR();//(***)rv first,add next
	Lc.tagA(X.add),Rc.tagA(X.add);
	X.rv=0,X.add=0;
}
#define in l<=X.l&&r>=X.r
#define Check if(r<X.l||l>X.r)return
void modify(int l,int r,int v,int rt){
	Check;
	if(in){X.tagA(v);return;}
	putdown(rt);//***
	modify(l,r,v,lc),modify(l,r,v,rc);
	pushup(rt);
}
void rev(int l,int r,int rt){
	Check;
	if(in){X.tagR();return;}
	putdown(rt);
	rev(l,r,lc),rev(l,r,rc);
	pushup(rt);
}
struct temp{int _[D+2];temp(int x=0){memset(_,0,sizeof(_)),_[0]=x;}};
temp mg(const temp&a,const temp&b){
	temp c;
	for(int i=0;i<=D;i++)
		for(int j=0;i+j<=D;j++)
			c._[i+j]+=(LL)a._[i]*b._[j]%mod,chk(c._[i+j]);
	return c;
}
temp query(int l,int r,int rt){
	Check temp(1);
	temp a;
	if(in){
		for(int i=0;i<=D;i++)a._[i]=X.t[i];
		return a;
	}
	putdown(rt);
	return mg(query(l,r,lc),query(l,r,rc));
}

int a[N];
void build(int l,int r,int rt){
	X.l=l,X.r=r;
	if(l==r){X.t[0]=1,X.t[1]=a[l]%mod;return;}
	int mid=(l+r)/2;
	build(l,mid,lc),build(mid+1,r,rc);
	pushup(rt);
}
int main(){
	int n,q;
	scanf("%d%d",&n,&q);
	C[0][0]=1;
	for(int i=1;i<=n;i++){
		C[i][0]=1;
		for(int j=1;j<=D;j++)C[i][j]=C[i-1][j]+C[i-1][j-1],chk(C[i][j]);//(***)chk
	}
	for(int i=1;i<=n;i++)scanf("%d",a+i);
	build(1,n,1);
	while(q--){
		char s[5];int a,b,c;
		scanf("%s%d%d",s,&a,&b);
		if(*s!='R')scanf("%d",&c);
		if(*s=='I')c%=mod,modify(a,b,c,1);//(***)%
		if(*s=='R')rev(a,b,1);
		if(*s=='Q')printf("%d\n",query(a,b,1)._[c]);
	}
	return 0;
}


```

![](不太明白：公式不要用含有非下标数字的变量名称，容易混淆 )

---

## 作者：alvis (赞：1)

补一下夏令营的题。

## 题意
对一个长度为 $n$ 的序列，实现以下几个操作。

- 区间加
- 区间取反
- 区间中选择 $c$ 个数的乘积之和

## 解决

前两个操作很 naive，但是第三个操作有点难搞。

考虑这个东西该怎么维护。

### 预处理
预处理一下组合数。

后面会说如何用。

### 建树
发现他的 $c$ 非常小（$c \le 20$），然后就想到可以**把每一个不同c的结果都存起来**。

一开始的处理：一个区间的 $c_{i+j}$ 就是其两个子区间的 $\sum _{i=0,j=0}^{i+j<=20}c_{i}\times c_{j}$ 。其中 $c_i$ 表示在左儿子区间中选择 $i$ 个，$c_j$ 表示在右儿子区间中选择 $j$ 个，$c_{i+j}$ 表示在总区间中选择 $i+j$ 个。

然后考虑加入区间加和区间取反操作。

### 区间取反
先说比较容易实现的**区间取反**。

容易发现，

当选取的数量 $k$ 为奇数时，$c_{k}$ 也应当取反；

当选取的数量 $k$ 为偶数时，$c_{k}$ 不会改变（负负得正）。

然后打上一个取反标记即可。

然后，处理一下标记的优先级，把加标记取反即可。
### 区间加

然后我们来讨论一下**区间加**。

假设原来的区间是 $a_l,a_{l+1},a_{l+2}\dots,a_r$，然后加后变为 $(a_{l}+k),(a_{l+1}+k),(a_{l+2}+k)\dots,(a_{r}+k)$ 。

设原先任意选取 $c$ 项的乘积为：$a_1 \times a_{2}\dots \times a_{c}$

则修改后 $c$ 项乘积： 

$$
\begin{aligned}(a_1+k)(a_2+k)\dots(a_c+k) & = a_1 \times a_2 \dots \times a_c+k\times(a_1\times a_2 \dots\times a_{c-1} +a_1\dots)+k^2 \times (a_1\times a_2\dots\times a_{c-2}+a_1\dots)\dots\end{aligned}
$$

而这个东西即是 ：$($原 $c$ 项的乘积 $ + \sum \limits_{i=1}^c x^{c-i}\times $ 原来 $c$ 项中选取 $i$ 项的乘积 $)$

然后可以发现这个 $c$ 项中选 $i$ 项很难处理，因为你似乎无法从当前的存储的数值直接推导出来。（这里我也不是很确定，因为我不会这样搞，如果有神仙会做请私我）

所以继续观察式子。

发现一个现象：这些和里面有一些相同的因式 $a_i \times a_{i+1}\dots \times a_{j}$，而这些因式每一次出现所带的别的东西是不一样的。

设上面的那个因式为 $t_{i,j}$ ，其一共有 $y$ 项。

则很显然的，这个因式的贡献就是 $res_y=\sum \limits_{z=0}^y x^{y-z} \times res_z \times \dbinom{size-z}{y-z}$

其意义是： 从 $size$ 个数中选 $y$ 个数，且包含了特定的 $z$ 个数。

所以预处理组合数，然后直接算就行了。

### 合并区间

查询的时候，可能需要合并两个区间的值。

与预处理类似的方法，把 $c_{i+j}$ 更新即可。

代码较长，有一些细节。

还要注意他输入的数可能为负数，所以要记得处理负数。

## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long

const int N = 50010, P = 19940417;
int n, m;
int a[N], C[N][21];

struct node {
	int sz, c[21];
	int ad, f;
}t[N << 2];

//预处理组合数
void init() {
	t[0].c[0] = 1;
	C[0][0] = 1;
	for(int i = 1;i <= n;i ++) {
		C[i][0] = 1;
		for(int j = 1;j <= i && j <= 20;j ++){
			C[i][j] = (C[i-1][j] + C[i-1][j-1]) % P;
		}
	}
}

//update更新当前节点的值
void update(int q) {
	memset(t[q].c, 0, sizeof t[q].c);
	for(int i = 0;i <= t[q << 1].sz && i <= 20;i ++) {
		for(int j = 0;i+j <= 20 && j <= t[q << 1|1].sz;j ++) {
			t[q].c[i+j] = (t[q].c[i+j] + t[q << 1].c[i] * t[q << 1|1].c[j] % P) % P;
		}
	}
}
//建树
void build(int q, int l, int r) {
	t[q].sz = (r - l + 1);
	if(l == r) {
    		//把选择 0 或 1 个的情况记下来
		t[q].c[0] = 1;
		t[q].c[1] = (a[l]%P + P) % P;
		return ;
	} 
	int mid = l+r >> 1;
	build(q << 1, l, mid);
	build(q << 1|1, mid+1, r);
	update(q);
}

//处理加标记
void puad(int q, int x) {
	if(!q || !x) return ;
	int tmp[50];
	tmp[0] = 1;
	for(int i = 1; i <= 20 && i <= t[q].sz;i ++) tmp[i] = tmp[i-1] * x % P;
	for(int i = min((int)20, t[q].sz);i != 0;i --) { 
		for(int j = 0;j < i;j ++) {
			t[q].c[i] = (t[q].c[i] + t[q].c[j] * tmp[i-j] % P * C[t[q].sz - j][i-j] ) % P;
		}
	}
	t[q].ad = (t[q].ad + x) % P;
}

//处理取反标记
void pure(int q){
	if(!q) return ;
	for(int i = 1;i <= 20 && i <= t[q].sz;i ++) {
		if(i % 2) t[q].c[i] = P - t[q].c[i];
		else continue;
	}
	t[q].f ^= 1;
	t[q].ad = P - t[q].ad;
}

void pushdown(int q) {
	if(t[q].f) {
		pure(q << 1);
		pure(q << 1|1);
		t[q].f = 0;
	} 
	if(t[q].ad) {
		puad(q << 1, t[q].ad);
		puad(q << 1|1, t[q].ad);
		t[q].ad = 0;
	}
}

//区间加
void add(int q, int stl, int str, int l, int r, int x) {
	if(stl > r || str < l) return;
	if(stl >= l && str <= r) {
		puad(q, x);
		return ;
	}
	pushdown(q);
	int mid = str + stl >> 1;
	add(q<<1, stl, mid, l, r, x);
	add(q<<1|1, mid+1, str, l, r, x);
	update(q);
}

//区间取反
void rev(int q, int stl, int str, int l, int r) {
	if(stl > r || str < l) return;
	if(stl >= l && str <= r) {
		pure(q);
		return ;
	}
	pushdown(q);
	int mid = str + stl >> 1;
	rev(q<<1, stl, mid, l, r);
	rev(q<<1|1, mid+1, str, l, r);
	update(q);
}

//合并两个区间
node merge(node a, node b) {
	node e;
	e.sz = a.sz + b.sz;
	memset(e.c, 0, sizeof e.c);
	for(int i = 0;i <= (int)20 && i <= a.sz;i ++) {
		for(int j = 0;j <= b.sz && i+j <= (int)20;j ++) {
			e.c[i+j] = (e.c[i+j] + a.c[i] * b.c[j] % P) % P;
		} 
	}
	return e;
}
//区间查询
node query(int q, int stl, int str, int l, int r) {
	if(stl >= l && str <= r) {
		return t[q];
	}
	pushdown(q);
	int mid = stl+ str >> 1;
	if(r <= mid) return query(q << 1, stl, mid, l, r);
	else if(l > mid) return query(q << 1|1, mid+1, str, l, r);
	else return merge(query(q << 1, stl, mid, l, r), query(q << 1|1, mid+1, str, l, r));
}

signed main() {
	cin >> n >> m;
	for(int i = 1;i <= n;i ++) {
		cin >> a[i];
	}
	init();
	build(1, 1, n);
	while(m --) {
		char op;
		cin >> op;
		if(op == 'I') {
			int a, b, c;
			cin >> a >> b >> c;
			c = (c % P + P) % P;
			add(1, 1, n, a, b, c);
		}
		if(op == 'R') {
			int a, b;
			cin >> a >> b;
			rev(1, 1, n, a, b);
		}
		if(op == 'Q') {
			int a, b, c;
			cin >> a >> b >> c;
			node e = query(1, 1, n, a, b);
			if(e.c[c] < 0) cout << P - e.c[c] << endl;
			else cout << e.c[c] % P << endl;
		}
	}
	
	return 0;
} 
```


---

## 作者：Stinger (赞：1)

~~由于事奔着线段树来的所以跳过怎么想到线段树这一部分~~

看到这题，想到对于线段树的节点维护一个 $f$ 数组，$f_i$ 表示在该区间内选出 $i$ 个数相乘所有方案之和。

则令 $ls$ 为左儿子，$rs$ 为右儿子，易得转移：

$$f_i=ls.f_i+rs.f_i\sum\limits^{c-1}_{i=1}ls.f_i\cdot rs.f_{c-j}$$

修改操作，如果是区间反转直接把 $i$ 为奇数的 $f_i$ 取个相反数，重点在于区间加。

先考虑计算 $\prod^k_{i=1}(a_i+x)-\prod^k_{i=1}a_i$。

观察 $\prod^k_{i=1}(a_i+x)$ 的展开式，得到上式等于 $\sum\limits^k_{i=1}x_i\cdot g_{k-i}$

$g_i$ 表示在 $a_1...a_k$ 中选出 $i$ 个数相乘的所有方案总和。

由于在一个线段树节点对应的区间中有很多长度为 $k$ 的区间，显然不能一一计算 $g$ 数组，由于 $f,g$ 定义非常相似，考虑利用 $f$ 推导 $g$。

其实可以得到，对于一个区间 $[l,r]$，$f_i=\sum\limits_{p_1,p_2..p_k\in [l,r]}\prod^k_{i=1}(a_{p_i}+x)-\prod^k_{i=1}a_{p_i}$。

也就是说，我们其实要计算：从 $[l,r]$ 区间中选出一个长度为 $k$ 的子序列，再从中选出一个长度为 $k-i$ 的子序列，计算这些子序列所有数的乘积之和。

假设 $[l,r]$ 区间长度为 $n$。

直接选出 $k-i$ 个数有 $\tbinom{n}{k-i}$ 种方案，按照上述方式选择有 $\tbinom{n}{k}\tbinom{k}{k-i}$ 种方案，即每种在区间 $[l,r]$ 直接选子序列的每种方案都被计算了 $\frac{\tbinom{n}{k}\tbinom{k}{k-i}}{\tbinom{n}{i}}=\tbinom{n-k+i}{i}$ 种方案。

那么最终答案就是，将区间 $[l,r]$ 加上一个数 $x$ 后，$f_k$ 会增加

$$\sum\limits^{i\le k}_{i=1}x_i\cdot \tbinom{n-k+i}{i}\cdot f_{k-i}$$


那么本题唯一的难点区间加操作就解决了。

区间查询按照最开始提到的转移搞一搞就行了，由于需要返回一个数组注意及时 `delete` 亿些空间防止内存泄漏（其实我没`delete`完，但足以应付这题的空间限制）。

最后注意懒标记，我`pushdown`时先考虑反转标记再考虑加法标记，那么每次一个节点收到反转标记时都要将它的加法标记取相反数。

出人意料的是这题虽然代码不短但很好写

```cpp
#include <cstdio>
#define int long long
inline int min(const int x, const int y) {return x < y ? x : y;}

const int mod = 19940417;
struct Node {
	int l, r, n, c[21], Lazy;
	bool rev;
} tree[200005];
typedef int* Array;
int a[50005], C[50005][21], n, q;

void pushup(int O) {
	for (int i = 1; i <= min(20, tree[O].n); ++ i) {
		tree[O].c[i] = tree[O << 1].c[i] + tree[O << 1 | 1].c[i];
		for (int j = 1; j < i; ++ j)
			tree[O].c[i] = (tree[O].c[i] + tree[O << 1].c[j] * tree[O << 1 | 1].c[i - j]) % mod;
	}
}
void reverse(int O) {
	for (int i = 1; i <= min(20, tree[O].n); i += 2)
		tree[O].c[i] = -tree[O].c[i];
	tree[O].Lazy = -tree[O].Lazy;
}
void add(int O, int d) {
	for (int i = min(20, tree[O].n); i; -- i) {
		int ret = 0;
		for (int j = 1, x = d; j <= i; ++ j, x = x * d % mod)
			ret = (ret + x * C[tree[O].n - i + j][j] % mod * tree[O].c[i - j]) % mod;
		tree[O].c[i] = (tree[O].c[i] + ret);
	}
}
void pushdown(int O) {
	if (tree[O].rev) {
		tree[O << 1].rev ^= 1, tree[O << 1 | 1].rev ^= 1;
		reverse(O << 1), reverse(O << 1 | 1);
		tree[O].rev = false;
	}
	if (tree[O].Lazy) {
		tree[O << 1].Lazy += tree[O].Lazy, tree[O << 1 | 1].Lazy += tree[O].Lazy;
		add(O << 1, tree[O].Lazy), add(O << 1 | 1, tree[O].Lazy);
		tree[O].Lazy = 0;
	}
}

void make_tree(int O, int L, int R) {
	tree[O].l = L, tree[O].r = R, tree[O].n = R - L + 1, tree[O].c[0] = 1;
	if (L != R) {
		make_tree(O << 1, L, L + R >> 1);
		make_tree(O << 1 | 1, (L + R >> 1) + 1, R);
		pushup(O);
	} else tree[O].c[1] = a[L];
}

void update(int O, int L, int R, int d) {
	if (L <= tree[O].l && tree[O].r <= R) {
		add(O, d), tree[O].Lazy += d; return;
	}
	int mid = tree[O].l + tree[O].r >> 1;
	pushdown(O);
	if (L <= mid) update(O << 1, L, R, d);
	if (mid < R) update(O << 1 | 1, L, R, d);
	pushup(O);
}
void Reverse(int O, int L, int R) {
	if (L <= tree[O].l && tree[O].r <= R) {
		reverse(O), tree[O].rev ^= 1; return;
	}
	int mid = tree[O].l + tree[O].r >> 1;
	pushdown(O);
	if (L <= mid) Reverse(O << 1, L, R);
	if (mid < R) Reverse(O << 1 | 1, L, R);
	pushup(O);
}
Array query(int O, int L, int R) {
	if (L <= tree[O].l && tree[O].r <= R) {
		int* c = new int[21];
		for (int i = 0; i <= 20; ++ i) c[i] = 0;
		for (int i = 1; i <= min(20, tree[O].n); ++ i) c[i] = tree[O].c[i];
		return c;
	}
	pushdown(O);
	int mid = tree[O].l + tree[O].r >> 1;
	if (mid >= R) return query(O << 1, L, R);
	if (L > mid) return query(O << 1 | 1, L, R);
	int *a = query(O << 1, L, R), *b = query(O << 1 | 1, L, R), *c = new int[21];
	for (int i = 0; i <= 20; ++ i) c[i] = 0;
	for (int i = 1; i <= min(20, tree[O].n); ++ i) {
		c[i] = a[i] + b[i];
		for (int j = 1; j < i; ++ j) c[i] = (c[i] + a[j] * b[i - j] % mod) % mod;
	}
	delete a, delete b;
	return c;
}

signed main() {
	scanf("%lld%lld", &n, &q);
	C[0][0] = 1;
	for (int i = 1; i <= n; ++ i) {
		scanf("%lld", a + i);
		C[i][0] = 1;
		for (int j = 1; j <= min(i, 20); ++ j)
			C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % mod;
	}
	make_tree(1, 1, n);
	while (q --) {
		char opt;
		int l, r, v;
		scanf(" %c%lld%lld", &opt, &l, &r);
		if (opt == 'I') scanf("%lld", &v), update(1, l, r, v);
		else if (opt == 'R') Reverse(1, l, r);
		else scanf("%lld", &v), printf("%lld\n", (query(1, l, r)[v] + mod) % mod);
	}
}
```

---

## 作者：_121017_ (赞：1)

~~最近准备 $CSP$，正好在写线段树， 考试前熬夜写了这道黑题。下午考提高组，没想到第三题居然就是线段树骗分（虽然我并没有骗到分）。~~
# 正文
就是一道线段树 $+$ 暴力的题，个人感觉还不如 [吉老师线段树？](https://www.luogu.com.cn/problem/P6242)
# 思路
对于操作一和操作二，差不多绿题的难度，难点在操作三。

#### 1. 首先我们考虑建树、操作一和操作二
这里直接放代码。
## code：
```cpp
void build(int p,int l,int r){//建树
	tree[p].size=r-l+1;//记录区间长度，后面有妙用
	if(l==r){
		tree[p].pro[0]=1;
		tree[p].pro[1]=(a[l]%mod+mod)%mod;
		return;
	}
	build(lc,l,mid);
	build(rc,mid+1,r);
	push_up(p);
}
```

---
```cpp
void change_1(int p,int l,int r,int xl,int xr,int x){//区间加
	if(l>=xl&&r<=xr){
		add(p,x);
		return;
	}
	push_down(p);//下放懒标记
	if(mid>=xl) change_1(lc,l,mid,xl,xr,x);
	if(mid<xr) change_1(rc,mid+1,r,xl,xr,x);
	push_up(p);
}
```

---
```cpp
void change_2(int p,int l,int r,int xl,int xr){//区间取反
	if(l>=xl&&r<=xr){
		opp(p);
		return;
	}
	push_down(p);//下放懒标记
	if(mid>=xl) change_2(lc,l,mid,xl,xr);
	if(mid<xr) change_2(rc,mid+1,r,xl,xr);
	push_up(p);
}
```

---
看起来基本上和线段树 2 差不多对不对？别急，我们接着来看本算法的精髓。
### 2. 接着我们来考虑如何巧妙处理操作三
我们可以看到，题目要求的 $c$ 只有 $c \leqslant 20$。我们不妨考虑暴力枚举左儿子中的 $i$ 个数与右儿子中的 $j$ 个数相乘之和。

那么我们怎么处理区间加和区间取反对操作三的影响呢？观察下面这些式子：

---
$(a+b)^2=a^2+ab+b^2$

$(a+b)^3=a^3+3a^2b+3ab^2+b^2$

$(a+b)^4=a^4+4a^3b+6a^2b^2+4ab^3+b^4$

$(a+b)^5=a^5+5a^4b+10a^3b^2+10a^2b^3+5ab^4+b^5$

$……$

---
如果单独只看系数的话就是这样子：

---
$\ \ \ \ \ \ \ \ \ \ 1$

$\ \ \ \ \ \ 1 \ \ 2\ \ 1$

$\ \ \ 1 \ \ \ 3\ \ \ 3\ \ 1$

$1\ \ \ 4\ \ \ 6\ \ \ 4\ \ \ 1$

$\ \ \ ………$


---
没错，就是大名鼎鼎的杨辉三角，我们可以预处理出杨辉三角 $n$ 行前的所有数。
## code：
```cpp 
void make_triangle(){
	tri[0][0]=1;
	for(ri i=1;i<=n;i++){
		tri[i][0]=1;
		for(ri j=1;j<=i&&j<=20;j++){
			tri[i][j]=(tri[i-1][j]+tri[i-1][j-1])%mod;
		}
	}
}
```

---
有了杨辉三角，我们可以很轻易的处理区间加，那么区间相反数呢？只要把奇次项的积取反，偶此项不变即可。
## code：
```cpp
void push_up(int p){
	memset(tree[p].pro,0,sizeof(tree[p].pro));
	for(ri i=0;i<=tree[lc].size&&i<=20;i++){
		for(ri j=0;j<=tree[rc].size&&j+i<=20;j++){
			tree[p].pro[i+j]+=tree[lc].pro[i]*tree[rc].pro[j]; 
		}
	}
	for(ri i=0;i<=20&&i<=tree[p].size;i++) tree[p].pro[i]%=mod;
}
```
```cpp
void add(int p,int x){//区间和操作
	if(!p||!x) return;
	temp[0]=1;
	for(ri i=1;i<=20&&i<=tree[p].size;i++) temp[i]=temp[i-1]*x%mod;
	for(ri i=min((long long)20,tree[p].size);i;i--){
		for(ri j=0;j<i;j++){
			tree[p].pro[i]=(tree[p].pro[i]+tree[p].pro[j]*temp[i-j]%mod*tri[tree[p].size-j][i-j])%mod;
		}
	}
	tree[p].add=(tree[p].add+x)%mod;
}
```

---
```cpp
void opp(int p){//区间取反操作
	if(!p) return;
	for(ri i=1;i<=20&&i<=tree[p].size;i++){
		if(i&1){
			tree[p].pro[i]=-tree[p].pro[i];
		}
	} 
	tree[p].add=mod-tree[p].add;
	tree[p].opp^=1;
}
```

---
```cpp
void push_down(int p){
	if(tree[p].opp){
		opp(lc);
		opp(rc);
		tree[p].opp=0;
	}
	if(tree[p].add){
		add(lc,tree[p].add);
		add(rc,tree[p].add);
		tree[p].add=0;
	}
}
```
### 3. 区间查询
分三种情况讨论：

---
- 目标区间全在左儿子

- 目标区间全在右儿子

- 目标区间一半在左、一半在右
---
第三种情况较为复杂，需要再次合并。
## code：
```cpp
Node merge(Node l,Node r){
	Node mer;
	mer.size=l.size+r.size;
	for(ri i=0;i<=20&&i<=l.size;i++){
		for(ri j=0;j+i<=20&&j<=r.size;j++){
			mer.pro[i+j]=(mer.pro[i+j]+l.pro[i]*r.pro[j])%mod;
		}
	}
	return mer;
}
```
```cpp
Node ask(int p,int l,int r,int xl,int xr){
	if(l>=xl&&r<=xr){
		return tree[p];
	}
	push_down(p);
	if(mid>=xr) return ask(lc,l,mid,xl,xr);
	else if(mid<xl) return ask(rc,mid+1,r,xl,xr);
	else return merge(ask(lc,l,mid,xl,xr),ask(rc,mid+1,r,xl,xr));
}
```
# 最后完整代码庆祝 $CSP$ 完美结（bao）束（ling）！！!
```cpp
#include<bits/stdc++.h>
#define int long long
#define ri register int
#define N 50005
#define lc p*2
#define rc lc+1
#define mid (l+r)/2 
using namespace std;
const int mod=19940417;
int n,m;
int a[N];
struct Node{
	int pro[25];
	int size;
	bool opp;
	int add;
	Node(){
		opp=add=size=0;
		memset(pro,0,sizeof(pro));
	}
}tree[N*4];
int tri[N][25],temp[25];
void make_triangle(){
	tri[0][0]=1;
	for(ri i=1;i<=n;i++){
		tri[i][0]=1;
		for(ri j=1;j<=i&&j<=20;j++){
			tri[i][j]=(tri[i-1][j]+tri[i-1][j-1])%mod;
		}
	}
}
void push_up(int p){
	memset(tree[p].pro,0,sizeof(tree[p].pro));
	for(ri i=0;i<=tree[lc].size&&i<=20;i++){
		for(ri j=0;j<=tree[rc].size&&j+i<=20;j++){
			tree[p].pro[i+j]+=tree[lc].pro[i]*tree[rc].pro[j]; 
		}
	}
	for(ri i=0;i<=20&&i<=tree[p].size;i++) tree[p].pro[i]%=mod;
}
void build(int p,int l,int r){
	tree[p].size=r-l+1;
	if(l==r){
		tree[p].pro[0]=1;
		tree[p].pro[1]=(a[l]%mod+mod)%mod;
		return;
	}
	build(lc,l,mid);
	build(rc,mid+1,r);
	push_up(p);
}
void add(int p,int x){
	if(!p||!x) return;
	temp[0]=1;
	for(ri i=1;i<=20&&i<=tree[p].size;i++) temp[i]=temp[i-1]*x%mod;
	for(ri i=min((long long)20,tree[p].size);i;i--){
		for(ri j=0;j<i;j++){
			tree[p].pro[i]=(tree[p].pro[i]+tree[p].pro[j]*temp[i-j]%mod*tri[tree[p].size-j][i-j])%mod;
		}
	}
	tree[p].add=(tree[p].add+x)%mod;
}
void opp(int p){
	if(!p) return;
	for(ri i=1;i<=20&&i<=tree[p].size;i++){
		if(i&1){
			tree[p].pro[i]=-tree[p].pro[i];
		}
	} 
	tree[p].add=mod-tree[p].add;
	tree[p].opp^=1;
}
void push_down(int p){
	if(tree[p].opp){
		opp(lc);
		opp(rc);
		tree[p].opp=0;
	}
	if(tree[p].add){
		add(lc,tree[p].add);
		add(rc,tree[p].add);
		tree[p].add=0;
	}
}
void change_1(int p,int l,int r,int xl,int xr,int x){
	if(l>=xl&&r<=xr){
		add(p,x);
		return;
	}
	push_down(p);
	if(mid>=xl) change_1(lc,l,mid,xl,xr,x);
	if(mid<xr) change_1(rc,mid+1,r,xl,xr,x);
	push_up(p);
}
void change_2(int p,int l,int r,int xl,int xr){
	if(l>=xl&&r<=xr){
		opp(p);
		return;
	}
	push_down(p);
	if(mid>=xl) change_2(lc,l,mid,xl,xr);
	if(mid<xr) change_2(rc,mid+1,r,xl,xr);
	push_up(p);
}
Node merge(Node l,Node r){
	Node mer;
	mer.size=l.size+r.size;
	for(ri i=0;i<=20&&i<=l.size;i++){
		for(ri j=0;j+i<=20&&j<=r.size;j++){
			mer.pro[i+j]=(mer.pro[i+j]+l.pro[i]*r.pro[j])%mod;
		}
	}
	return mer;
}
Node ask(int p,int l,int r,int xl,int xr){
	if(l>=xl&&r<=xr){
		return tree[p];
	}
	push_down(p);
	if(mid>=xr) return ask(lc,l,mid,xl,xr);
	else if(mid<xl) return ask(rc,mid+1,r,xl,xr);
	else return merge(ask(lc,l,mid,xl,xr),ask(rc,mid+1,r,xl,xr));
}
signed main(){
	scanf("%lld%lld",&n,&m);
	for(ri i=1;i<=n;i++){
		scanf("%lld",&a[i]);
	}
	tree[0].pro[0]=1;
	make_triangle();
	build(1,1,n);
	for(ri i=1;i<=m;i++){
		char c;
		int x,y,z;
		cin>>c;
		scanf("%lld%lld",&x,&y);
		if(c=='I'){
			scanf("%lld",&z);
			z=(z%mod+mod)%mod;
			change_1(1,1,n,x,y,z);
		}
		if(c=='R'){
			change_2(1,1,n,x,y);
		}
		if(c=='Q'){
			scanf("%lld",&z);
			printf("%lld\n",(ask(1,1,n,x,y).pro[z]%mod+mod)%mod);
		}
	}
	return 0;
}


```


---

## 作者：zhouyuhang (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P4247)

线段树的好题。首先观察数据范围：$c\leq20$，因此我们可以将每一种情况下的答案都记录下来。不妨设 $v[i]$ 表示一个区间内取 $i$ 个数相乘所有结果的总和。易得上传公式：$rt.v[i]=\sum_{j=0}^ilch.v[j]\times rch.v[i-j]$；取反公式：$rt.v[i]={(-1)}^i rt.v[i]$。但如果仅仅到这里，此题的难度还远远评不了黑。

问题出在区间加。作区间加时，我们所维护的 $v[i]$ 无法直接进行更新，需要借助之前算出的结果。假设某一种方案所选的 $c$ 个数是 $\left\{a_1,a_2…a_c\right\}$，区间加 $x$，则加后数值变为：$(a_1+x)(a_2+x)…(a_c+x)=a_1a_2…a_c+(a_1a_2…a_{c-1}+a_1…a_{c-2}a_c+…+a_2a_3…a_c)x+(a_1a_2…a_{c-2}+…+a_3a_4…a_c)x^2+…+x^c$。不难发现式子中 $x^i$ 的系数与我们的 $v[c-i]$ ~~一样但又不完全一样~~ 很像，可以考虑用 $v[c-i]$ 代替计算。由于我们算的是所有方案之和，因此只需知道 $v[c-i]$ 被用到的次数就好了。假设这一段区间的长度为 $len$，则 $v[c-i]$ 中的一种方案扩展至   $v[c]$ 有 $C_{len-c+i}^i$（有 $len-c+i$ 个数可选择，需要选择 $i$ 个数）种方案，而每一种方案都要用到这个方案一次，故 $v[c-i]$ 在 $v[c]$ 中一共被用到了 $C_{len-c+i}^i$ 次。这样就容易得出更新 $v[c]$ 的公式了：$v[c]=v[c]+\sum_{i=1}^c C_{len-i}^{c-i} x^iv[i]$。再提前根据 $C_i^j=C_{i-1}^j+C_{i-1}^{j-1}$ 预处理出组合数即可。注意取模与加法取反的顺序。

$Code$：

```cpp
#include<iostream>
#include<cstdio> 
using namespace std;
#define int long long
const int Mod=19940417,MAXN=5e4+10;
struct seg_tr{
	int l,r;
	int v[22],add_tag,mul_tag;
}tr[MAXN*4];
int n,q,a[MAXN];
int mat[MAXN][21],l[MAXN];
void add(int k,int x){
	l[0]=1;
	for(int i=1;i<=20;i++) l[i]=(l[i-1]*x)%Mod;
	int len=tr[k].r-tr[k].l+1;
	for(int i=min((int)20,len);i;i--){
		for(int j=0;j<i;j++){
			tr[k].v[i]+=((l[i-j]*tr[k].v[j]%Mod)*mat[len-j][i-j])%Mod;
		}
		tr[k].v[i]%=Mod;
	} 
	tr[k].add_tag=(tr[k].add_tag+x)%Mod;
}
void mul(int k,int x){
	for(int i=1;i<=19;i+=2) tr[k].v[i]*=x;
	tr[k].add_tag=(tr[k].add_tag*x%Mod+Mod)%Mod;
	tr[k].mul_tag*=x;
}
seg_tr push_up(seg_tr lson,seg_tr rson){
	seg_tr rt;
	rt.l=lson.l,rt.r=rson.r;
	rt.mul_tag=1,rt.add_tag=0;
	for(int i=0;i<=20;i++){
		rt.v[i]=0;
		for(int j=0;j<=i;j++)
			rt.v[i]+=(lson.v[j]*rson.v[i-j])%Mod;
		rt.v[i]=(rt.v[i]%Mod+Mod)%Mod;
	}
	return rt;
}	
void push_down(int k){
	mul(k<<1,tr[k].mul_tag);
	mul(k<<1|1,tr[k].mul_tag);
	tr[k].mul_tag=1;
	add(k<<1,tr[k].add_tag);
	add(k<<1|1,tr[k].add_tag);
	tr[k].add_tag=0;
}
void build(int k,int l,int r){
	tr[k].l=l;
	tr[k].r=r;
	fill(tr[k].v,tr[k].v+21,0);
	tr[k].mul_tag=1;
	if(l==r){
		tr[k].v[0]=1;
		tr[k].v[1]=(a[l]%Mod+Mod)%Mod;
		return;
	}
	int mid=(l+r)>>1;
	build(k<<1,l,mid);
	build(k<<1|1,mid+1,r);
	tr[k]=push_up(tr[k<<1],tr[k<<1|1]);
}
void update(int k,int l,int r,int x){
	if(tr[k].l>=l&&tr[k].r<=r){
		add(k,x);
		return;
	}
	if(tr[k].l>r||tr[k].r<l) return;
	push_down(k);
	update(k<<1,l,r,x);
	update(k<<1|1,l,r,x);
	tr[k]=push_up(tr[k<<1],tr[k<<1|1]);
}
void modify(int k,int l,int r){
	if(l<=tr[k].l&&tr[k].r<=r){
		mul(k,-1);
		return;
	}
	if(tr[k].l>r||tr[k].r<l) return;
	push_down(k);
	modify(k<<1,l,r);
	modify(k<<1|1,l,r);
	tr[k]=push_up(tr[k<<1],tr[k<<1|1]);
}
seg_tr query(int k,int l,int r){
	if(tr[k].l>=l&&tr[k].r<=r) return tr[k];
	push_down(k);
	int mid=(tr[k].l+tr[k].r)>>1;
	if(r<=mid) return query(k<<1,l,r);
	if(l>mid) return query(k<<1|1,l,r);
	return push_up(query(k<<1,l,r),query(k<<1|1,l,r));
}
void pre(){
	for(int j=0;j<=21;j++){
        mat[j][j]=1;
        for(int i=j+1;i<=n;i++){
            if(!j) mat[i][j]=1;
            else mat[i][j]=(mat[i-1][j-1]+mat[i-1][j])%Mod; 
        }
    }
}
signed main(){
	ios::sync_with_stdio(0);
	cin>>n>>q;
	for(int i=1;i<=n;i++) cin>>a[i];
	pre(); 
	build(1,1,n);
	for(int i=1;i<=q;i++){
		char op;
		int l,r,c; 
		cin>>op>>l>>r;
		if(op=='I'){
			cin>>c;
			update(1,l,r,c);
		}else if(op=='R'){
			modify(1,l,r);
		}else{
			cin>>c;
			cout<<(query(1,l,r).v[c]%Mod+Mod)%Mod<<endl;
		}
	}
	return 0;
}
```

---

## 作者：Mobius127 (赞：0)

[题传](https://www.luogu.com.cn/problem/P4247)

~~调了一天终于过了，写篇题解庆祝~~

前两个操作是个 [板子](https://www.luogu.com.cn/problem/P3373)，我们考虑操作 3。

注意到 $c \le 20$，不妨设 $f_i$ 为选 $i$ 个数相乘的方案和。

显然有 $f_i=\sum_{j=0}^{i} f_{ls, j} \times f_{rs, i-j}$，暴力时向上 $O(c^2)$ 合并，那么没有操作 1、2 的世界完成了！！1

考虑加上操作 1 怎么做，方案中原本的一个和大概长这个样子：

$$s_c=\prod_{i=1}^{c} x_i$$

每个数都加上一个 $v$：

$$s'_c=\prod_{i=1}^{c} (x_i+v)$$

类似于二项式定理，将其拆解：

$$s'_c=\sum_{cnt=0}^{c} (\prod_{p_1<p_2<...p_{cnt}} x_{p}) \times v^{c-cnt}$$

不难发现括号里面那堆东西就是旧的 $f_{cnt}$，即：

$$s'_c=\sum_{cnt=0}^{c} f_{cnt} \times v^{c-cnt}$$

也是暴力合并。

对于操作二，直接将奇数个相乘的、以及加法标记取反即可。

注意要先下传乘法标记。

时间复杂度 $O(n c^2 \log n)$。

### Code：

```cpp
#include <stdio.h>
#include <algorithm>
#include <string.h>
using namespace std;
typedef long long ll;
const int INF=0x3f3f3f3f;
const int mo=19940417;
const int R=20;
inline int read(){
	char ch=getchar();int x=0, f=1;
	while(ch<'0'||ch>'9'){if(ch=='-') f=-1; ch=getchar();}
	while(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+ch-'0';ch=getchar();}
	return x*f;
}
inline int mod(int x){return (x%mo+mo)%mo;}
namespace Solution{
	const int N=5e4+5;
	int n, m, a[N], C[N][25];
	struct node{
		node(){at=mt=len=0, f[0]=1;for(int i=1; i<=20; i++) f[i]=0;}
		int f[25], len;
		int at, mt;
	}S;
	node add(node l, node r){
		node c=S;
		c.len=l.len+r.len;
		for(int i=1; i<=min(R, c.len); i++)
			for(int j=0; j<=i; j++)
				c.f[i]=mod(c.f[i]+1ll*l.f[j]*r.f[i-j]%mo);
		return c;
	}
	node d[N*30];
	struct SegmentTree{
		#define ls k<<1
		#define rs k<<1|1
		#define mid (l+r>>1)
		void upd1(int k, int v){//区间加 
			int t=min(R, d[k].len);
			for(int i=t; i; i--)
				for(int j=1, st=v; j<=i; j++, st=1ll*st*v%mo)
					d[k].f[i]=mod(d[k].f[i]+1ll*d[k].f[i-j]*st%mo*C[d[k].len-i+j][j]%mo);
			d[k].at=mod(d[k].at+v);
		}
		void upd2(int k){//区间取反
			int t=min(R, d[k].len);
			for(int i=1; i<=t; i++)
				if(i&1) d[k].f[i]=mod(-d[k].f[i]);
			d[k].at=mod(-d[k].at);
			d[k].mt^=1; 
		}
		void pushdown(int k){
			if(d[k].mt) upd2(ls), upd2(rs);
			if(d[k].at) upd1(ls, d[k].at), upd1(rs, d[k].at);
			d[k].at=0, d[k].mt=0;
			return ;
		}
		void build(int k, int l, int r){
			d[k]=S;d[k].len=r-l+1;
			if(l==r){d[k].f[1]=a[l&r];return ;}
			build(ls, l, mid), build(rs, mid+1, r);
			d[k]=add(d[ls], d[rs]);
		}
		void change(int k, int l, int r, int x, int y, int v, bool flg){
//			if(flg) printf(">>%d %d\n", k, v);
			if(x<=l&&r<=y) return flg?upd1(k, v):upd2(k);pushdown(k);
			if(x<=mid) change(ls, l, mid, x, y, v, flg);
			if(mid<y) change(rs, mid+1, r, x, y, v, flg);
			d[k]=add(d[ls], d[rs]);
		}
		node query(int k, int l, int r, int x, int y){
			if(x<=l&&r<=y) return d[k];pushdown(k);
			if(y<=mid) return query(ls, l, mid, x, y);
			if(x>mid) return query(rs, mid+1, r, x, y);
			return add(query(ls, l, mid, x, y), query(rs, mid+1, r, x, y));
		}
		void debug(){
			for(int j=1; j<=n; j++) printf("---%d",d[1].f[j]);puts("");
		}
		#undef ls
		#undef rs
		#undef mid
	}Chtholly;	
	signed work(){
		n=read(), m=read();
		for(int i=0; i<=20; i++){
			C[i][0]=1;
			for(int j=1; j<=i; j++) 
				C[i][j]=mod(C[i-1][j]+C[i-1][j-1]);
		}
		for(int i=21; i<=n; i++){
			C[i][0]=1;
			for(int j=1; j<=20; j++) 
				C[i][j]=mod(C[i-1][j]+C[i-1][j-1]);
		}
		for(int i=1; i<=n; i++)
			a[i]=mod(read());
		Chtholly.build(1, 1, n);//Chtholly.debug();
		for(int i=1; i<=m; i++){
			char opt=getchar();
			int a, b, c;
			while(opt!='I'&&opt!='R'&&opt!='Q') opt=getchar();
			if(opt=='I') 
				a=read(), b=read(), c=mod(read()), Chtholly.change(1, 1, n, a, b, c, 1);
			else if(opt=='R')
				a=read(), b=read(), Chtholly.change(1, 1, n, a, b, 0, 0);
			else 
				a=read(), b=read(), c=read(),
				printf("%d\n", Chtholly.query(1, 1, n, a, b).f[c]);
			//Chtholly.debug();
		}
		return 0;
	}
}
signed main(){
	Solution :: work();
	return 0;
}
```

---

## 作者：Leap_Frog (赞：0)

### P.S.
### Discription.
你需要维护一个数据结构，支持
1. 区间变相反数
2. 区间加
3. 区间查询任选 k 个数的乘积和

### Solution.
线段树+二项式定理  

首先我们观察到 $k$ 很小，只有 $20$，所以我们可以考虑暴力记录不同 $k$ 的答案。  
接下来我们按照线段树题目的基本套路，直接考虑以下几件事。  
1. 合并两个节点的信息
2. 能否快速维护区间修改
3. 时空复杂度是否够、常数是否够（显然够

#### 1. 合并两个节点的信息
我们现在已知在左边选 $i$ 个的贡献和，以及在右边选 $j$ 个的贡献和，那么直接卷积起来就好了。  
$$T_{now,i+j}=\sum T_{lson,i}\times T_{rson,j}$$
~~此时可以用 FFT 快速合并~~，直接暴力平方级卷积就好了  
复杂度 $O(20^2)$

#### 2. 快速维护区间变相反数操作
这个很简单，直接区间中奇数为取 `-`，偶数位不变就好了。  

#### 3. 快速维护区间加操作
这个比较复杂，比如我们有一个~~柿~~式子
$$\prod_{i=1}^{k}a_i$$
那么如果对区间的所有 $\{a_i\}$ 加 $c$，那么式子就是
$$F_k=\prod_{i=1}^k(a_i+c)$$
$$=\sum_{i=0}^k(C_k^i\times c^i\times F_{k-i})$$
注意计算大的 $F$ 时要用到到小的 $F$，所以要从后向前扫。

### Coding.
```cpp
//愿你有一天能和你重要的人重逢。
#include<bits/stdc++.h>
using namespace std;
template<typename T>inline void read(T &x)
{
	x=0;char c=getchar(),f=0;
	for(;c<'0'||c>'9';c=getchar()) if(c=='-') f=1;
	for(;c>='0'&&c<='9';c=getchar()) x=(x<<1)+(x<<3)+(c^48);
	if(f) x=-x;
}
const int P=19940417;
struct node{int vl[25],len,rv,tg;}t[200005],_1;
int n,q,a[50005],C[50005][25],tmp[25];
inline node operator+(node a,node b)
{//线段树信息合并操作
	node c;memset(c.vl,0,sizeof(c.vl)),c.len=20;
	for(int i=0;i<=20&&i<=a.len;i++)
		for(int j=0;i+j<=20&&j<=b.len;j++)
			(c.vl[i+j]+=1ll*a.vl[i]*b.vl[j]%P)%=P;
	return c;
}
inline void up(int x) {node c=t[x<<1]+t[x<<1|1];memcpy(t[x].vl,c.vl,sizeof(t[x].vl));}
//防止丢失原来的tag信息（其实不需要，只是习惯
inline void rev(int x)
{
	for(int i=1;i<=20&&i<=t[x].len;++++i) t[x].vl[i]=t[x].vl[i]?P-t[x].vl[i]:0;
	t[x].tg=t[x].tg?P-t[x].tg:0,t[x].rv^=1;
}
inline void dwrv(int x) {if(t[x].rv) rev(x<<1),rev(x<<1|1),t[x].rv=0;}
inline void add(int x,int c)
{
	tmp[0]=1;for(int i=1;i<=20;i++) tmp[i]=1ll*tmp[i-1]*c%P;
	for(int i=min(20,t[x].len);i;i--) for(int j=0;j<i;j++) (t[x].vl[i]+=1ll*t[x].vl[j]*tmp[i-j]%P*C[t[x].len-j][i-j]%P)%=P;
	t[x].tg=(t[x].tg+c)%P;
}
inline void dwad(int x) {if(t[x].tg) add(x<<1,t[x].tg),add(x<<1|1,t[x].tg),t[x].tg=0;}
inline void down(int x) {dwrv(x),dwad(x);}
inline void build(int x,int l,int r)
{
	t[x].len=r-l+1;if(l==r) return(void)(t[x].vl[0]=1,t[x].vl[1]=(a[l]%P+P)%P);
	build(x<<1,l,(l+r)>>1),build(x<<1|1,((l+r)>>1)+1,r),up(x);
}
inline void updrev(int x,int l,int r,int dl,int dr)
{
	if(l>dr||dl>r) return;else if(dl<=l&&r<=dr) return rev(x);else down(x);
	updrev(x<<1,l,(l+r)>>1,dl,dr),updrev(x<<1|1,((l+r)>>1)+1,r,dl,dr),up(x);
}
inline void updadd(int x,int l,int r,int dl,int dr,int w)
{
	if(l>dr||dl>r) return;else if(dl<=l&&r<=dr) return add(x,w);else down(x);
	updadd(x<<1,l,(l+r)>>1,dl,dr,w),updadd(x<<1|1,((l+r)>>1)+1,r,dl,dr,w),up(x);
}
inline node query(int x,int l,int r,int dl,int dr)
{
	if(l>dr||dl>r) return _1;else if(dl<=l&&r<=dr) return t[x];else down(x);
	return query(x<<1,l,(l+r)>>1,dl,dr)+query(x<<1|1,((l+r)>>1)+1,r,dl,dr);
}
int main()
{
	C[0][0]=1,read(n),read(q),memset(_1.vl,0,sizeof(_1.vl)),_1.len=20,_1.vl[0]=1;char ch[25];
	for(int i=1;i<=50000;i++) {C[i][0]=1;for(int j=1;j<=i&&j<=20;j++) C[i][j]=(C[i-1][j-1]+C[i-1][j])%P;}
	for(int i=1;i<=n;i++) read(a[i]);
	for(build(1,1,n);q--;)
	{
		scanf("%s",ch+1);int a,b,c;read(a),read(b);
		if(ch[1]=='I') read(c),updadd(1,1,n,a,b,c);
		else if(ch[1]=='R') updrev(1,1,n,a,b);
		else read(c),printf("%d\n",(query(1,1,n,a,b).vl[c]+P)%P);
	}
	return 0;
}
```

---


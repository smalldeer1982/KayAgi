# CPU 监控

## 题目背景

Bob 家的机子很烂……真的很烂……

以至于看视频或者跑邪恶的暴力程序的时候，由于 CPU 使用率持续过高而宕机。

## 题目描述

Bob 需要一个程序来监视 CPU 使用率。这是一个很繁琐的过程，为了让问题更加简单，Bob 会慢慢列出今天会在用计算机时做什么事。 

Bob 会干很多事，除了跑暴力程序看视频之外，还会做出去玩玩和用鼠标乱点之类的事，甚至会一脚踢掉电源……这些事有的会让做这件事的这段时间内 CPU 使用率增加或减少一个值；有的事还会直接让 CPU 使用率变为一个值。 

当然 Bob 会询问：在之前给出的事件影响下，CPU 在某段时间内，使用率最高是多少。有时候 Bob 还会好奇地询问，在某段时间内 CPU 曾经的最高使用率是多少。 

为了使计算精确，使用率不用百分比而用一个整数表示。 

不保证 Bob 的事件列表没有出莫名的问题，使得使用率为负………………

## 说明/提示

数据分布如下： 

第 $1,2$ 个数据保证 $T$ 和 $E$ 均小于等于 $10^3$。 

第 $3,4$ 个数据保证只有 `Q` 类询问。

第 $5,6$ 个数据保证只有 `C` 类事件。

第 $7,8$ 个数据保证只有 `P` 类事件。

对于 $100\%$ 的数据，$1\le T,E\le 10^5$，$1\le X\le Y\le T$，$-2^{31}\leq Z\lt 2^{31}$。

## 样例 #1

### 输入

```
10
-62 -83 -9 -70 79 -78 -31 40 -18 -5 
20
A 2 7
A 4 4
Q 4 4
P 2 2 -74
P 7 9 -71
P 7 10 -8
A 10 10
A 5 9
C 1 8 10
Q 6 6
Q 8 10
A 1 7
P 9 9 96
A 5 5
P 8 10 -53
P 6 6 5
A 10 10
A 4 4
Q 1 5
P 4 9 -69```

### 输出

```
79
-70
-70
-5
79
10
10
79
79
-5
10
10```

# 题解

## 作者：He_Ren (赞：160)

Update:  
2020-1-8 修复了 ```do_val``` 函数的 bug，感谢 @z7z_Eta 提供的 hack 数据 ； 修改了部分文章内容

---

[题目传送门](https://www.luogu.org/problemnew/show/P4314)

首行求赞，反正不 FA 钱 qwq

## 0.前置

- 线段树（并能较好地理解）
- 一颗能听我把废话说完的心

## 1.题意简述

给出 $T$ 个数，$E$ 个操作（$T,E \leq 10^5$）:

- Q X Y：询问从 $X$ 到 $Y$ 的**当前**最大值
- A X Y：询问从 $X$ 到 $Y$ 的**历史**最大值（出现过的最大数）
- P X Y Z：将 $X$ 到 $Y$ 这段区间加 $Z$
- C X Y Z：将 $X$ 到 $Y$ 这段区间赋值为 $Z$

## 2.线段树

看到这道题，首先不难想到的就是线段树

如果没有查询历史最大值，这道题（对于您来说）肯定没有难度

加上历史最大值，事情就复杂了。。。

这也是这道题困难的地方，即对于 ```lazy tag``` 的理解

---

$\tiny \text{（以上都是废话）}$

---

## 3.lazy tag 的使用

其实这道题完全可以作为线段树的模板题，考察了 ```lazy tag``` 与树上节点的更新顺序的关系

### 如何理解？

```lazy tag``` 实际上可以看作是对于该节点表示的区间的**操作序列**，这也是线段树的精髓所在

```push_down``` 操作就是把父节点的操作序列接在儿子节点的序列**之后**  
（_思考：为什么一定是 “ **之后** ” ？_）

对一个点进行 ```push_down``` 操作后，该点的操作序列即被清空，因为在递归完子树后，该点答案将被更新。以下文章中的 “ 操作序列 ”，都指的是该点上一次进行 ```push_down``` 后（即上一次清空后）的操作序列

### 如何处理操作序列？

首先，相邻的同种操作可被合并

于是，对于一个点，操作序列分为以下几种（ "+" 号表示操作的先后顺序，汉字叙述可能影响您的阅读体验）：

1. $\text{加操作}$
2. $\text{加操作} + \text{赋值操作}$
3. $\text{加操作} + \text{赋值操作} + \text{加操作}$
4. $\text{加操作} + \text{赋值操作} + \text{加操作} + \text{赋值操作}$
5. $\cdots$

这个操作序列显然很难保存在每一个点上

我们发现，对于一个点，首次赋值操作之后的任何修改都可以看作赋值操作（_想一想，为什么_）

于是操作序列化简为（**重点**）：

$$\text{加操作 + 赋值操作}$$

现在，恭喜您解决了两个个很大的问题：操作序列如何保存 & 同一点上操作的先后顺序问题

于是，只用保存加和赋值两种 ```lazy tag```，便可记录该节点的操作序列

---

**如果您理解了以上内容，那么您就已经掌握了本题算法的核心。如果您还没有，也可以先看代码，再回顾以上内容**

---

其它细节详见代码

## 4.code

```cpp
#include<cstdio>
const int MAXN = 1e5 + 5;
const int inf = 0x7fffffff;

inline int max(int a,int b){ return a>b? a: b;}
inline void chk_max(int &a,int b){ if(a<b) a=b;}

int ans[MAXN<<2],max_ans[MAXN<<2];//区间最大值	区间历史最大值 

bool vis[MAXN<<2];//是否进行过区间赋值操作 
int sum[MAXN<<2], val[MAXN<<2];//上次下放之后的加和	上次下放之后的赋值操作 （赋值之后的加操作一并算入赋值，下同）
int max_sum[MAXN<<2], max_val[MAXN<<2];//上次下放之后达到的最大加和	上次下放之后赋的最大值 
/*
注意这里实际上使用了4个lazy_tag，不过如果您理解了算法的核心，您应该知道我在干什么
*/
#define ls(u) ((u)<<1)
#define rs(u) ((u)<<1|1)//个人习惯，左右儿子


inline void push_up(int u)//push_up比较简单，就是用左右儿子的答案更新本节点的答案
{
    ans[u] = max(ans[ls(u)], ans[rs(u)]);
    max_ans[u] = max(max_ans[ls(u)], max_ans[rs(u)]);
}


//我将更新lazy_tag的操作打包成函数，不然有可能在细节上出错（其实我一开始就是在这里出的错）
/*
更新加操作的tag，分为两种情况：
 1.赋过值，算作赋值操作
 2.没赋过值
*/
inline void do_sum(int u,int k,int max_k)//max_k表示父节点在上一次push_down之后达到的最大加和
{
    if(vis[u])
    {
        chk_max(max_val[u], val[u]+max_k);
        chk_max(max_ans[u], ans[u]+max_k);
        ans[u]+=k;
        val[u]+=k;
    }
    else
    {
        chk_max(max_sum[u], sum[u]+max_k);
        chk_max(max_ans[u], ans[u]+max_k);
        ans[u]+=k;
        sum[u]+=k;
    }
}

inline void do_val(int u,int k,int max_k)//max_k表示父节点在上一次push_down之后达到的最大赋值
{
	if(vis[u])
	{
		chk_max(max_val[u], max_k);
    	chk_max(max_ans[u], max_k);
	}
    else
    {
    	vis[u]=1;//该点标记为赋过值
    	max_val[u] = max_k;
    	chk_max(max_ans[u], max_k);
	}
    ans[u] = val[u] = k;
}

inline void push_down(int u)
{
    do_sum(ls(u),sum[u],max_sum[u]);
    do_sum(rs(u),sum[u],max_sum[u]);//先传递和
    
    sum[u] = max_sum[u] = 0;//下传之后清零
    
    if(vis[u])
    {
        do_val(ls(u),val[u],max_val[u]);
        do_val(rs(u),val[u],max_val[u]);
        
        vis[u] = 0;
        val[u] = max_val[u] = 0;//下传之后清零
    }
}

void build(int u,int l,int r)//建树
{
    if(l==r)
    {
        scanf("%d",&ans[u]);
        max_ans[u]=ans[u];
        return;
    }
    
    int mid=(l+r)>>1;
    build(ls(u),l,mid);
    build(rs(u),mid+1,r);
    push_up(u);
}

int query(int u,int l,int r, int ql,int qr)//Q操作
{
    if(ql<=l && r<=qr) return ans[u];
    
    push_down(u);
    int mid=(l+r)>>1, ret=-inf;
    if(ql<=mid) ret = query(ls(u),l,mid, ql,qr);
    if(mid<qr) chk_max(ret, query(rs(u),mid+1,r, ql,qr));
    
    return ret;
}

int query_max(int u,int l,int r, int ql,int qr)//A操作，与Q类似
{
    if(ql<=l && r<=qr) return max_ans[u];
    
    push_down(u);
    int mid=(l+r)>>1, ret=-inf;
    if(ql<=mid) ret = query_max(ls(u),l,mid, ql,qr);
    if(mid<qr) chk_max(ret, query_max(rs(u),mid+1,r, ql,qr));
    
    return ret;
}

void add(int u,int l,int r, int ql,int qr,int k)//P操作
{
    if(ql<=l && r<=qr)
    {
        do_sum(u,k,k);//这里max_k也填k就行了
        return;
    }
    
    push_down(u);
    int mid = (l+r)>>1;
    if(ql<=mid) add(ls(u),l,mid, ql,qr,k);
    if(mid<qr) add(rs(u),mid+1,r, ql,qr,k);
    push_up(u);
}

void assign(int u,int l,int r, int ql,int qr,int k)//C操作
{
    if(ql<=l && r<=qr)
    {
        do_val(u,k,k);
        return;
    }
    
    push_down(u);
    int mid = (l+r)>>1;
    if(ql<=mid) assign(ls(u),l,mid, ql,qr,k);
    if(mid<qr) assign(rs(u),mid+1,r, ql,qr,k);
    push_up(u);
}

//这两个函数是调试用的，用于打印序列
void print(int u,int l,int r)
{
    if(l==r)
    {
        printf("%d ",ans[u]);
        return;
    }
    push_down(u);
    int mid=(l+r)>>1;
    print(ls(u),l,mid);
    print(rs(u),mid+1,r);
}
inline void test(int t)
{
    printf("=========================================\n");
    print(1,1,t);
    printf("\n=========================================\n");
}

int main(void)
{
    int t;
    scanf("%d",&t);
    build(1,1,t);
    
    int e;
    scanf("%d",&e);
    while(e--)
    {
        char c=getchar();
        while(c!='Q' && c!='A' && c!='P' && c!='C') c=getchar();//个人习惯，感觉这么写比较保险 
        int x,y;
        scanf("%d%d",&x,&y);
        
        if(c=='Q') printf("%d\n",query(1,1,t, x,y));
        if(c=='A') printf("%d\n",query_max(1,1,t, x,y));
        if(c=='P')
        {
            int z;
            scanf("%d",&z);
            add(1,1,t, x,y,z);
            //test(t);
        }
        if(c=='C')
        {
            int z;
            scanf("%d",&z);
            assign(1,1,t, x,y,z);
            //test(t);
        }
    }
    return 0;
}
```

本题解主要用于理清自己思路，如果有与他人方法重复也不要喷qaq

实际还写了蛮长时间的。。。码字手酸，见谅qwq

如果您觉得题解有错误，可以私信或者评论

当然别忘了点赞qwq

---

## 作者：EnofTaiPeople (赞：131)

### Part1 前言
可能我是不喜爱繁杂推导的人，看了多篇题解都没能理解线段树历史最值的标记，于是手写了一个矩阵乘法的版本，就感觉都能理解了，所以这篇文章送给有一定矩阵（线性代数）基础又不能理解线段树历史最值的人。

### Part2 矩阵乘法的性质

两个矩阵 $A_{n,m},B_{m,p}$ 相乘得到 $C_{n,p}$，满足 $C_{n,p}=\sum A_{n,i}B_{i,p}$。

而处理区间最值和历史最值时，常用广义矩乘，即 $C_{n,p}=\max (A_{n,i}+B_{i,p})$。

矩阵乘法和广义矩阵乘法均具有结合律。

### Part3 区间历史最值维护

考虑序列每一个数维护一个向量 $\begin{bmatrix}a_i\\b_i\end{bmatrix}$，$a_i$ 表示当前值，$b_i$ 表示历史最值，用线段树维护区间向量和（即 $a_i,b_i$ 的最大值）。

那么区间加 $k$ 可以看作 $\begin{bmatrix}a\\b\end{bmatrix}\leftarrow\begin{bmatrix}a+k\\\max\{b,a+k\}\end{bmatrix}$，可以很容易地构造广义矩阵乘法：$\begin{bmatrix}a\\b\end{bmatrix}\begin{bmatrix}k&k\\-\infty&0\end{bmatrix}=\begin{bmatrix}a+k\\\max\{b,a+k\}\end{bmatrix}$，故可以将懒标记设为 $\begin{bmatrix}k&k\\-\infty&0\end{bmatrix}$ 这个矩阵。

不过本题需要支持区间赋值，这个操作可以转化为区间加，就是即使线段树节点被区间完包，只要最大值不等于最小值，就递归下去，根据颜色段均摊理论，这部分的均摊时间复杂度为 $O(n)$。

当然也可以给向量再加一维，使其变为 $\begin{bmatrix}a\\b\\0\end{bmatrix}$，这样就有 $\begin{bmatrix}a\\b\\0\end{bmatrix}\begin{bmatrix}-\infty&-\infty&-\infty\\-\infty&0&-\infty\\k&k&0\end{bmatrix}=\begin{bmatrix}k\\\max\{b,k\}\\0\end{bmatrix}$。

其实看到这里你已经能 AC 本题了，因为我也是[这样写的](https://hydro.ac/d/bzoj/record/63ef8141e96dda153f1cb9c9)。

### Part4 将矩阵转为标记

事实上本题没有区间最值操作，只是让你稍微理解一下历史最值的实现方式，公认的例题还是 [线段树 3](https://www.luogu.com.cn/problem/P6242)。

这道题由于拥有区间最值操作，所以要对最大值和非最大值分别打标记，当然你会发现这道题的所有标记均为加上一个值，所以可以用矩阵 $\begin{bmatrix}k&k\\-\infty&0\end{bmatrix}$ 来表示标记。

当然最初我只会使用分块来维护，本地就要跑 7s，稳稳地超时，由此可见，矩阵乘法的 $k^3$ 很多时候并不能当常数看待。

考虑两个标记结合（相乘），会得到什么：$\begin{bmatrix}k_1&k_2\\-\infty&0\end{bmatrix}\begin{bmatrix}k_3&k_4\\-\infty&0\end{bmatrix}=\begin{bmatrix}k_1+k_3&\max\{k_2,k_1+k_4\}\\-\infty&0\end{bmatrix}$，从实际意义来考虑，$A_{1,1}$ 表示当前加值，$A_{1,2}$ 表示历史最大加值。

所以我们只需要对最大值和非最大值分别记录 $tag1$ 表示当前加值，$tag2$ 表示历史最大加值，经过一系列卡常，甚至将块长调到了 $120$，终于通过了此题。

至此，线段树和分块就没什么两样了，除了常数较小。

### Part5 普通矩阵乘法与区间历史和

大致模型如 [NOIP2022 比赛](https://www.luogu.com.cn/problem/P8868)，事实上研究矩乘本来就是为了学习这道题的做法，据说都被出烂了。

题意求 $\sum\limits_{L\le l\le r\le R}\max\limits_{i=l}^ra_i\max\limits_{i=l}^rb_i$，需要用扫描线转换为历史和。

其实就是从 $1$ 到 $n$ 扫右端点，用线段树维护序列 $A_i=\max\limits_{j=i}^ra_j,B_i=\max\limits_{j=i}^rb_j$ 的乘积历史和。

容易发现 $A_i,B_i$ 是单调的，而每一次会全局与 $a_r,b_r$ 取 $\max$，直接做是不好维护的，可以用单调栈或直接暴力颜色段均摊转化为区间加，考虑每一个节点维护向量：$\begin{bmatrix}a\\b\\ab\\c\\len\end{bmatrix}$，表示区间 $A_i,B_i$ 的和，$A_iB_i$ 的和，$A_iB_i$ 的历史和，区间长度。考虑如何区间加。

我们需要 $\begin{bmatrix}a\\b\\ab\\c\\len\end{bmatrix}\leftarrow\begin{bmatrix}a+k\times len\\b\\ab+k\times b\\c\\len\end{bmatrix}$，可以构造矩阵乘法：

$\begin{bmatrix}a\\b\\ab\\c\\len\end{bmatrix}\begin{bmatrix}1&0&0&0&0\\0&1&k&0&0\\0&0&1&0&0\\0&0&0&1&0\\k&0&0&0&1\end{bmatrix}=\begin{bmatrix}a+k\times len\\b\\ab+k\times b\\c\\len\end{bmatrix}$

同理，有区间 $B_i$ 增加 $k$：

$\begin{bmatrix}a\\b\\ab\\c\\len\end{bmatrix}\begin{bmatrix}1&0&k&0&0\\0&1&0&0&0\\0&0&1&0&0\\0&0&0&1&0\\0&k&0&0&1\end{bmatrix}=\begin{bmatrix}a\\b+k\times len\\ab+k\times a\\c\\len\end{bmatrix}$

当然，操作结束时需要对区间 $1\sim r$ 更新历史和：

$\begin{bmatrix}a\\b\\ab\\c\\len\end{bmatrix}\begin{bmatrix}1&0&0&0&0\\0&1&0&0&0\\0&0&1&1&0\\0&0&0&1&0\\0&0&0&0&1\end{bmatrix}=\begin{bmatrix}a\\b\\ab\\c+ab\\len\end{bmatrix}$

至此，你已经可以在 $k^3(n+q)\log n$（其中 $k=5$） 的时间复杂度内解决此题了，在场上能获得 $76$ 分，还不够优秀。

要知道，矩阵乘法更多是用来理解标记的，而不是用在代码实现上的。

发现矩阵的主对角线永远都为 $1$，有一些项永远都为 $0$，为什么呢？因为矩阵的每一个元素 $A_{i,j}$ 都可以视作 $i$ 对 $j$ 产生的贡献，而这个贡献会形成一个有向无环图（偏序集）：$len\rightarrow a,b\rightarrow ab\rightarrow c$，可以看出，每一个矩阵最多只有 $9$ 个有效状态，这样我们就大大减小了常数，可以轻松[通过](https://uoj.ac/submission/607388)。

### Part6 后记

这些众所周知的东西能多学就多学一点吧。

---

## 作者：LZDQ (赞：97)

初一的时候废话过多，见谅。

作为一个初一的蒟蒻，居然做出这题了，真不可思议。

我以为这不就是一个模板吗。

然而到洛谷上，居然是黑题。。。

# 正题

抛开历史最值，只需要两个标记乱搞。不难发现，一个区间先赋值再加，第二个加法操作可以变成一个赋值操作。

但是这个是比较简单的，这题难点不在这。

#### 我们可以先从简单的任务入手，想一下分块

假如用分块，要维护什么？
1. 一个区间内当前的累加（假如没有赋值操作）
2. 历史最大累加（假如没有赋值操作）
3. 假如有赋值操作，维护**当前区间赋值**和**历史最大赋值**
4. 赋值后加，改成赋值操作
5. **第一次赋值前**有加法操作，记录一下第一次赋值前的**历史最大累加**就好了

总结：两种情况
1. 区间一直加
2. 区间加一些数，再赋值

根据这些就能写出分块了

------------

## 线段树

线段树比分块多 $pushdown$

先表示出一个区间经历的状态（用 $pushdown$ 作为分界线）：

1. 整个区间只有加没有赋值。用两个 $tag$ 分别表示**当前累加的值**和**历史上累加的最大的值**（如下~~图~~）

![]( https://cdn.luogu.com.cn/upload/pic/50996.png )

2. 有赋值操作。用**第一次赋值**作为分界线，前面的所有加法操作只用统计**历史最大累加**，以后的加法和赋值都看作赋值，用两个 $tag$ 表示**当前赋值**和**历史最大赋值**（如下~~图~~）

![]( https://cdn.luogu.com.cn/upload/pic/50997.png )

（这张图打错了一个字，历史最大赋值为2）

------------

然后是 $pushdown$

我们考虑，一个区间和它的左右子树，一定是左右子树先有 $tag$ 然后才是该区间有 $tag$ 最后才是该区间的 $pusdown$

#### 难点来了

怎么维护当前最大和历史最大？

我懒得画图，但是我去看别人的题解，没图简直没法看

大概分两种情况就可以了

1. 如果该区间没有赋值操作，把**区间加法**和**历史最大累加**下放
2. 否则有赋值操作。但是注意**第一次赋值前还有加法操作**，这会对历史最大值产生影响。 **先把加法下放，然后把赋值下放**。

可以考虑一些细节：两种情况加法下放的函数可以用同一个函数。

但是有一个问题，第二种情况是不用下放当前加法的。不过，就算下放了也没关系，因为待会还要下放赋值，前面的加法就没用了（历史最大累加和历史最大值会另外操作）。

这些下放有点不同，因为历史最大 和 当前 是分开计算的

pushdown 下放加法的函数（建议看注释）：
```cpp
inline void add(int k/*子树下标*/,int v/*当前累加*/,int hv/*历史最大累加*/){
	if(有区间赋值标记) return 区间赋值
    //接下来，表示子树只有区间加，没有区间赋值
    htagp[k]=maxx(htagp[k],hv+tagp[k]);  //难点，见图1，更新历史最大累加
    tagp[k]+=v;  //更新当前加法
    mx[k]+=v;  //更新当前最大
    mxh[k]=maxx(mxh[k],mx[k]-tagp[k]+htagp[k]);  //更难点，更新历史最大值
```

![]( https://cdn.luogu.com.cn/upload/pic/51088.png)

图1中，左子树的历史最大累加可以是原来的（$\colorbox{white}{\color{lightblue}{蓝大括号}}$），也可以是按照时间轴的发展最大累加（$\colorbox{white}{\color{red}{红线段}}$）

没有 图2 了，修改自己理解吧，和上面差不多

------------------

代码
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
#define lc k<<1
#define rc k<<1|1
#define ls lc,l,mid
#define rs rc,mid+1,r
const int MAXN=1e5+5,INF=0x7fffffff;
int n,m;
int a[MAXN];
int mx[MAXN<<2],mxh[MAXN<<2];
int tagp[MAXN<<2],tagc[MAXN<<2];	//常规tag
int htagp[MAXN<<2],htagc[MAXN<<2];
inline void pushup(int k){
	mx[k]=max(mx[lc],mx[rc]);
	mxh[k]=max(mxh[lc],mxh[rc]);
}
void Build(int k,int l,int r){
	tagc[k]=INF;	//赋值标记为INF表示没有赋值操作
    htagc[k]=-INF;	//防止一直是负数
	if(l==r){
		mx[k]=mxh[k]=a[l];
		return ;
	}
	int mid=l+r>>1;
	Build(ls);
	Build(rs);
	pushup(k);
	return ;
}
inline void chg(int k,int v,int hv){
	mx[k]=v;
	mxh[k]=max(mxh[k],hv);
	tagc[k]=v;
	htagc[k]=max(htagc[k],hv);
}
inline void add(int k,int v,int hv){
	if(tagc[k]!=INF) return chg(k,tagc[k]+v,tagc[k]+hv);	//转区间赋值操作
	htagp[k]=max(htagp[k],hv+tagp[k]);
	tagp[k]+=v;
	mx[k]+=v;
	mxh[k]=max(mxh[k],mx[k]-tagp[k]+htagp[k]);
}
inline void pushdwn(int k){
	add(lc,tagp[k],htagp[k]);
	add(rc,tagp[k],htagp[k]);
	tagp[k]=htagp[k]=0;
	if(tagc[k]!=INF){	//如果有赋值标记
		chg(lc,tagc[k],htagc[k]);
		chg(rc,tagc[k],htagc[k]);
		tagc[k]=INF;
	}
}
int qx,qy,qv;
int Query(int k,int l,int r){
	if(qx<=l&&r<=qy) return mx[k];
	pushdwn(k);
	int mid=l+r>>1;
	int res=-INF;
	if(qx<=mid) res=max(res,Query(ls));
	if(mid<qy) res=max(res,Query(rs));
	return res;
}
int Queryh(int k,int l,int r){
	if(qx<=l&&r<=qy) return mxh[k];
	pushdwn(k);
	int mid=l+r>>1;
	int res=-INF;
	if(qx<=mid) res=max(res,Queryh(ls));
	if(mid<qy) res=max(res,Queryh(rs));
	return res;
}
void Modifyp(int k,int l,int r){  //plus
	if(qx<=l&&r<=qy) return add(k,qv,max(qv,0));
	pushdwn(k);
	int mid=l+r>>1;
	if(qx<=mid) Modifyp(ls);
	if(mid<qy) Modifyp(rs);
	pushup(k);
	return ;
}
void Modifyc(int k,int l,int r){  // change
	if(qx<=l&&r<=qy) return chg(k,qv,qv);
	pushdwn(k);
	int mid=l+r>>1;
	if(qx<=mid) Modifyc(ls);
	if(mid<qy) Modifyc(rs);
	pushup(k);
	return ;
}
int main(){
	//freopen("4314.in","r",stdin);
	scanf("%d",&n);
	for(int i=1; i<=n; i++)
		scanf("%d",a+i);
	Build(1,1,n);
	scanf("%d",&m);
	while(m--){
		char opt[2];
		scanf("%s%d%d",opt,&qx,&qy);
		if(opt[0]=='Q') printf("%d\n",Query(1,1,n));
		else if(opt[0]=='A') printf("%d\n",Queryh(1,1,n));
		else{
			scanf("%d",&qv);
			if(opt[0]=='P') Modifyp(1,1,n);
			else Modifyc(1,1,n);
		}
	}
	return 0;
}
```

好像各位的题解都比我的简单很多？

------------

2021.1.22

被 [y_dove](https://www.luogu.com.cn/user/248872) hack了，没有考虑一个位置一直是负数并且修改成负数的情况

竟然掉紫了

---

## 作者：Froggy (赞：42)

这道题一开始的想法肯定是用当前最大值及当前的标记维护历史最大值，如果你真这样写，就会WA成 $20pts$，毕竟是道黑题，不可能这么简单！

举个反例：

```
8
1 1 10 1 1 1 1 1
3
P 1 8 100
P 1 8 -10
A 3 3
```

显然，答案是110，但如果按刚才那样维护的话就会输出100,因为第二个操作把会减小第一个操作的add标记，**儿子的历史最大值得不到及时的更新**，就会WA掉

所以，每个节点还要记录历史最大add标记

同理，还要记录历史最大覆盖标记

---

先记牢含义：（很好记吧，就是"字面"意思）

注：h是history的意思

- `add` 当前加法标记

- `hadd` 历史最大加法标记

- `cov` 当前覆盖标记

- `hcov` 历史最大覆盖标记

- `iscov` 当前是否覆盖标记，值为true/false

- `mx` 当前区间最大值

- `hmx` 历史区间最大值

两种询问照常，取区间mx/hmx的最大值即可,注意题目中只说值都在int范围内，所以保险起见，`inf` 要取 INT_MAX (2147483647)

```cpp
int Qmax(int i,int l,int r){
	if(tree[i].l>=l&&tree[i].r<=r){
		return tree[i].mx;
	}
	pushdown(i);
	int ans=-inf;
	int mid=(tree[i].l+tree[i].r)>>1;
	if(l<=mid){
		ans=max(ans,Qmax(i*2,l,r));
	}
	if(r>mid){
		ans=max(ans,Qmax(i*2+1,l,r));
	}
	return ans;
}
int Qhmax(int i,int l,int r){
	if(tree[i].l>=l&&tree[i].r<=r){
		return tree[i].hmx;
	}
	pushdown(i);
	int ans=-inf;
	int mid=(tree[i].l+tree[i].r)>>1;
	if(l<=mid){
		ans=max(ans,Qhmax(i*2,l,r));
	}
	if(r>mid){
		ans=max(ans,Qhmax(i*2+1,l,r));
	}
	return ans;
}
```

儿子更新父亲也照常，直接取max即可:

```cpp
inline void update(int i){
	tree[i].mx=max(tree[i*2].mx,tree[i*2+1].mx);
	tree[i].hmx=max(tree[i].hmx,tree[i].mx);
   //或tree[i].hmx=max(tree[i*2].hmx,tree[i*2+1].hmx);
}
```

---

### 重点是如何pushdown

先介绍一个**好科技:** 成员函数，可以使代码看起来条理更清晰，并大大减少码量，不过可能会稍微慢一点，加一些 `inline` 就没关系啦

pushdown的时候重点是要**分类讨论**：之前是否被覆盖过，即由 `iscov` 标记决定

先讲覆盖的时候：（要传 `d` 和 `hd` ,表示用于更新的当前覆盖值和用于更新的历史覆盖最大值）

- 如果iscov为`true`：用hd更新hcov，取max

- 如果iscov为`false`：iscov变为true，hcov变为hd

此外还要更新历史最大值hmx，(和hd取max)

加法的时候更复杂一些：`d` 和 `hd` 的含义同理

- 如果iscov为`true`：说明之前被覆盖过了，此时相当于用d+cov进行Cover即可

- 如果iscov为`false`：此时只有加法，用mx+hd和add+hd分别更新hmx和had,并更新mx和add标记 (把mx和add加上d)

最后，pushdown以后别忘记**清空标记**！！

```cpp

//结构体里的成员函数：
struct node{
	...
	inline void Cover(int d,int hd){//覆盖
		if(iscov){
			hcov=max(hcov,hd);
		}
		else{
			iscov=true;
			hcov=hd;
		}
		hmx=max(hmx,hd);
		cov=mx=d;
		add=0;
	}
	inline void Add(int d,int hd){//辅助Change执行加法
		hadd=max(hadd,add+hd);
		hmx=max(hmx,mx+hd);
		add+=d,mx+=d;
	}
	inline void Change(int d,int hd){//加法的分类讨论
		if(iscov)Cover(cov+d,cov+hd);
		else Add(d,hd);
	}
   /*其实还可以把Change和Add合并，泥萌别把意思混了就好*/
}

//下放标记
void pushdown(int i){
	//先下放加法
	tree[i*2].Change(tree[i].add,tree[i].hadd);
	tree[i*2+1].Change(tree[i].add,tree[i].hadd);
	tree[i].add=tree[i].hadd=0;//清空
   //再下放覆盖
	if(tree[i].iscov){
		tree[i*2].Cover(tree[i].cov,tree[i].hcov);
		tree[i*2+1].Cover(tree[i].cov,tree[i].hcov);
		tree[i].iscov=tree[i].cov=tree[i].hcov=0;//清空标记
	}
}
```

---

如何区间修改调用Change和Cover就不说了把，贴个code

```cpp
void _plus(int i,int l,int r,int d){
	if(tree[i].l>=l&&tree[i].r<=r){
		tree[i].Change(d,d);
		return;
	}
	pushdown(i);
	int mid=(tree[i].l+tree[i].r)>>1;
	if(l<=mid){
		_plus(i*2,l,r,d);
	}
	if(r>mid){
		_plus(i*2+1,l,r,d);
	}
	update(i);
}
void Cover(int i,int l,int r,int d){
	if(tree[i].l>=l&&tree[i].r<=r){
		tree[i].Cover(d,d);
		return ;
	}
	pushdown(i);
	int mid=(tree[i].l+tree[i].r)>>1;
	if(l<=mid){
		Cover(i*2,l,r,d);
	}
	if(r>mid){
		Cover(i*2+1,l,r,d);
	}
	update(i);
}
```

然后...就完了。代码就贴剪切板里了 [here](https://www.luogu.com.cn/paste/xvkzt25w)

[*Froggy's blog*](https://www.luogu.org/blog/1445353309froggy/)

#### 呱!!



---

## 作者：wzj423 (赞：20)

这道题吼啊，考察了对于lazy标记和时间轴的关系！（雾

可以发现，对于一个父子节点的关系，lazy标记实际上相当于一段操作（往往合并成一个），这段操作目前在父节点被统计而在子节点没有被统计。而下放实际上就是更新了子节点的所谓“操作序列”（我口胡的）

之前其他几篇题解提到的种种问题，我认为究其原因都是在更新序列的时候，没有记录足够的信息导致统计出错，这就需要我们显式考虑这段操作序列（不再像之前缩成一个操作），并记录足够的信息。

不难（误）发现，一段区间，先赋值再区间加，其实可以缩成一个赋值操作而不影响统计答案。所以一个点上的操作序列只有两种，单纯区间加，和先加再赋值。

这样我们分别考虑父子节点的情况，记录需要的历史最大值，就可以统计答案了。

（还有一部分更详细的说明结合代码给出）

```cpp
#include <bits/stdc++.h>

using namespace std;
//defs&tools==================================================
const int MAXN=2e5+10,INF=0x3f3f3f3f;
template <typename T> void rd(T &x) {
	x=0;int f=1;char ch=getchar();
	while(!isdigit(ch)) { if(ch=='-') f=-1; ch=getchar();}
	while(isdigit(ch)) { x=x*10+ch-'0'; ch=getchar();}
	x*=f;
}
void chkmax(int &x,int y) {
	if(y>x) x=y;
}
int a[MAXN],N,M;
//seg_tree====================================================
bool type[MAXN];//0 表示一段序列还只有加操作 
	//1表示一段序列先有加操作再有区间赋值操作 
int lc[MAXN],rc[MAXN];
int maxv[MAXN],addtag[MAXN],valtag[MAXN];
/*
	maxv 一切操作处理完之后当前区间的最大值 （包括addtag和valtag）
	addtag 上一次下放之后，区间赋值操作之前一切add操作的合并
	valtag 上一次下放后，一切区间赋值操作（合并了之后的加操作）的合并 
*/
int hmax[MAXN],hadd[MAXN],hval[MAXN];
/*
	hmaxv 区间历史最大值
	hadd 上一次下放之后，区间赋值操作之前，一切加操作合并时能达到的最大值
	hval 上一次下放后，一切区间赋值操作能达到的最大值 
*/ 
int cnt,rt;
//modules=================================================== 
void update(int x) {//信息合并 
	maxv[x]=max(maxv[ lc[x] ],maxv[ rc[x] ]);
	hmax[x]=max(hmax[ lc[x] ],hmax[ rc[x] ]);
}
/*
	AddTag函数适用于在一段加操作的末尾再添加一段加操作
	add->新加入的序列的末尾结果
	hisadd->新加入的序列的可取到的（历史）最大值
	可能的历史最大值有两个:一个从原序列出发,到hisadd(新序列截止)
							一个是原序列的可能最大值 
	按照这两个可能更新hmax和hadd 
*/
void AddTag(int x,int add,int hisadd) {
	chkmax(hadd[x],addtag[x]+hisadd);
	chkmax(hmax[x],maxv[x]+hisadd);
	addtag[x]+=add;
	maxv[x]+=add; 
}
/*
	ValTag有两种可能:
		1.在一段只有加操作的序列末尾加上一段赋值操作
		2.在一段先加再赋的序列更新末尾一段赋值操作(两段赋值操作合并) 
	因而我们需要用type标记区分 
	val -> 序列最后赋值成了啥
	hisval->序列历史最大赋值成了啥 
*/
void ValTag(int x,int val,int hisval) {
	if(type[x]) {//情况2 
		chkmax(hval[x],hisval);//之前有历史最大所以需要比较 
		chkmax(hmax[x],hisval);
		valtag[x]=val; 
		maxv[x]=val; 
	} else {//情况1 
		type[x]=true;
		hval[x]=hisval;
		chkmax(hmax[x],hisval);
		valtag[x]=val;
		maxv[x]=val; 
	}
}
/*
	当一个区间已经有了两种操作的时候,再往后面添加一个含有两种操作的序列
	add(son)->set(son)->add(father)->set(father)
	此时对于这个区间 set(son)->add(father)其实是可以合并的 
		合并成set操作后可以按照此操作下放 
*/
void Pushdown(int x) {
	//先把本节点序列内部的add操作下放到子节点 
	if(type[ lc[x] ])
		ValTag(lc[x],valtag[lc[x]]+addtag[x],valtag[lc[x]]+hadd[x]);
	else
		AddTag(lc[x],addtag[x],hadd[x]);
	if(type[ rc[x] ])
		ValTag(rc[x],valtag[rc[x]]+addtag[x],valtag[rc[x]]+hadd[x]);
	else
		AddTag(rc[x],addtag[x],hadd[x]);	 
	//再把区间赋值操作下放到子节点
	if(type[x]) {
		ValTag(lc[x],valtag[x],hval[x]);
		ValTag(rc[x],valtag[x],hval[x]);
	} 
	//清零
	type[x]=false;
	addtag[x]=hadd[x]=hval[x]=valtag[x]=0; 
} 
void Build(int &x,int L,int R) {
	x=++cnt;
	if(L==R) {
		maxv[x]=hmax[x]=a[L];
		return;
	}
	int mid=(L+R)>>1;
	Build(lc[x],L,mid);
	Build(rc[x],mid+1,R);
	update(x);
}
//[B,E]查询区间  [L,R]当前区间 
int QueryA(int x,int L,int R,int B,int E) {
	if(L==B&&R==E) return maxv[x];
	Pushdown(x);
	int mid=(L+R)>>1,ans=-INF;
	if(mid>=B) chkmax(ans,QueryA(lc[x],L,mid,B,min(mid,E)) ); 
	if(mid+1<=E) chkmax(ans,QueryA(rc[x],mid+1,R,max(mid+1,B),E) );
	return ans;
}
int QueryB(int x,int L,int R,int B,int E) {
	if(L==B&&R==E) return hmax[x];
	Pushdown(x);
	int mid=(L+R)>>1,ans=-INF;
	if(mid>=B) chkmax(ans,QueryB(lc[x],L,mid,B,min(mid,E)) ); 
	if(mid+1<=E) chkmax(ans,QueryB(rc[x],mid+1,R,max(mid+1,B),E) );
	return ans;
}
void Add(int x,int L,int R,int B,int E,int val) {
	if(L==B&&R==E) {
		if(type[x]) ValTag(x,valtag[x]+val,valtag[x]+val);
		else AddTag(x,val,val);
		return;
	}
	Pushdown(x);
	int mid=(L+R)>>1;
	if(mid>=B) Add(lc[x],L,mid,B,min(E,mid),val);
	if(mid+1<=E) Add(rc[x],mid+1,R,max(mid+1,B),E,val);
	update(x);
}
void Val(int x,int L,int R,int B,int E,int num) {
	if(L==B&&R==E) {
		ValTag(x,num,num);
		return;
	}
	Pushdown(x);
	int mid=(L+R)>>1;
	if(mid>=B) Val(lc[x],L,mid,B,min(E,mid),num);
	if(mid+1<=E) Val(rc[x],mid+1,R,max(mid+1,B),E,num);
	update(x);
}
char __t[3];
char &opt=__t[0]; 
//main======================================================== 
int main() {
	rd(N);
	//printf("N=%d\n",N);
	for(int i=1;i<=N;++i) rd(a[i]);
	Build(rt,1,N);
	rd(M);
	//printf("M=%d\n",M);
	for(int i=1;i<=M;++i) {
		scanf("%s",__t);
		int L,R,val;
		rd(L),rd(R);
		if(L>R) swap(L,R);
		if(opt=='Q') 		printf("%d\n",QueryA(rt,1,N,L,R));
		else if(opt=='A') 	printf("%d\n",QueryB(rt,1,N,L,R));
		else if(opt=='P')   rd(val),Add(rt,1,N,L,R,val);
		else if(opt=='C')   rd(val),Val(rt,1,N,L,R,val);
	}
	return 0;
}
```

---

## 作者：Missa (赞：17)

这篇文章想给写矩阵做法的人一个代码参考。这道题下两篇矩阵题解只有一篇有代码，并且可读性不算强，我自认为自己写得还算清晰。

跳过非重点，这里 [这篇文章写得很好了](https://www.luogu.com.cn/blog/_post/545411)（他矩阵的行列定义和这篇用的似乎是反的）。在每个线段树节点上维护 $\begin{bmatrix} a \\ b \\ 0\end{bmatrix}$ 表示当前区间最大值为 $a$，历史最大值为 $b$。矩阵乘法定义为 $c_{i, j} = \max\{a_{i, k} + b_{k, j}\}$，则可以用

$$
\begin{bmatrix} 
-\infty & -\infty & k \\ 
-\infty & 0 & k\\
-\infty & -\infty & 0
\end{bmatrix}
\begin{bmatrix}
a \\ b \\ 0
\end{bmatrix} 
=
\begin{bmatrix}
k \\ \max\{b, k\} \\ 0
\end{bmatrix}
$$

$$
\begin{bmatrix} 
k & -\infty & -\infty \\ 
k & 0 & -\infty\\
-\infty & -\infty & 0
\end{bmatrix}
\begin{bmatrix}
a \\ b \\ 0
\end{bmatrix} 
= 
\begin{bmatrix}
a + k \\ \max\{b, a + k\} \\ 0
\end{bmatrix} 
$$

描述操作。因此可以用矩阵更新答案，这是具有结合律的，进而可以用线段树懒标记维护。

矩阵可以用于推导，但不方便于运算。只维护不是常数的位置，其实只有 $4$ 个。

封装：

- 向量与矩阵分开封装，向量维护两个值，矩阵维护四个位置。
- 重定义向量加法、矩阵乘法、矩阵乘向量。
- 初始化：主对角线为 $0$，其余位置为 $- \infty$。

注意：

- 操作是左乘，新操作要乘在旧操作左边。

一个卡了我挺久的细节是赋值矩阵的左上角是 $-\infty$ 而不是初始化时的 $0$。

到这里，就可以用区间加区间 $\max$ 的线段树维护这一套代数系统。

```cpp
#include <bits/stdc++.h>

const int M = 1e5 + 5;

using LL = long long;

const LL inf = 1e14;

struct vec {
  LL x11, x21;
  // x31 = 0
  vec() {
    x11 = x21 = -inf;
  }
  vec(LL a, LL b) { x11 = a, x21 = b; }
  vec operator + (const vec &t) const {
    return { std::max(x11, t.x11), std::max(x21, t.x21) };
  }
} s[M << 2];

struct matrix {
  LL x11, x13, x21, x23;
  // x12 = x31 = x32 = x23 = -inf, x22 = x33 = 0
  // 带 -inf 的项不参与取 max，为 0 的项已经忽略
  matrix operator * (const matrix &t) const {
    matrix ans;
    ans.x11 = x11 + t.x11;
    ans.x13 = std::max(x11 + t.x13, x13);
    ans.x21 = std::max(x21 + t.x11, t.x21);
    ans.x23 = std::max({x21 + t.x13, t.x23, x23});
    return ans;
  }
  vec operator * (const vec &t) const {
    vec ans;
    ans.x11 = std::max(x11 + t.x11, x13);
    ans.x21 = std::max({x21 + t.x11, t.x21, x23});
    return ans;
  }
  matrix() {
    x11 = 0, x13 = x21 = x23 = -inf;
  }
} laz[M << 2];

// 以下不算重要

int n, a[M];

void pushdown(int o) {
  s[o << 1] = laz[o] * s[o << 1], laz[o << 1] = laz[o] * laz[o << 1];
  s[o << 1 | 1] = laz[o] * s[o << 1 | 1], laz[o << 1 | 1] = laz[o] * laz[o << 1 | 1];
  laz[o] = matrix();
}

void build(int o, int l, int r) {
  if (l == r) {
    s[o] = {a[l], a[l]};
    return ;
  }
  int mid = l + r >> 1;
  build(o << 1, l, mid), build(o << 1 | 1, mid + 1, r);
  s[o] = s[o << 1] + s[o << 1 | 1];
}

void mdf(int o, int l, int r, int x, int y, matrix &t) {
  if (x <= l && r <= y) {
    s[o] = t * s[o], laz[o] = t * laz[o];
    return ;
  }
  int mid = l + r >> 1; pushdown(o);
  if (x <= mid) mdf(o << 1, l, mid, x, y, t);
  if (y > mid) mdf(o << 1 | 1, mid + 1, r, x, y, t);
  s[o] = s[o << 1] + s[o << 1 | 1];
}

vec qry(int o, int l, int r, int x, int y) {
  if (x <= l && r <= y) return s[o];
  int mid = l + r >> 1;
  vec ans; pushdown(o);
  if (x <= mid) ans = ans + qry(o << 1, l, mid, x, y);
  if (y > mid) ans = ans + qry(o << 1 | 1, mid + 1, r, x, y);
  return ans; 
}

int main() {
  scanf("%d", &n);
  for (int i = 1; i <= n; i++)
    scanf("%d", &a[i]);
  build(1, 1, n);
  int m, l, r; scanf("%d", &m); while (m--) {
    char op; scanf(" %c %d %d", &op, &l, &r);
    if (op == 'Q') {
      printf("%lld\n", qry(1, 1, n, l, r).x11);
    } else if (op == 'A') {
      printf("%lld\n", qry(1, 1, n, l, r).x21);
    } else if (op == 'P') {
      matrix t; int k; scanf("%d", &k);
      t.x11 = t.x21 = k;
      mdf(1, 1, n, l, r, t);
    } else if (op == 'C') {
      matrix t; int k; scanf("%d", &k);
      t.x13 = t.x23 = k;
      t.x11 = -inf;
      mdf(1, 1, n, l, r, t);
    }
  }
}
```

用矩阵描述这些操作确实很有趣。它似乎是用代数推导直接发现了更强的代数性质（结合律），进而省略了对标记互相影响的讨论。

在哪里跌倒，就在哪里站起来。NOIp2022 T4，我来了。

---

## 作者：木xx木大 (赞：15)

[P4314 CPU监控](https://www.luogu.com.cn/problem/P4314)

发现以前写得太不清楚了以至于复习的时候看不懂自己写了啥，看题解也没太看懂，于是决定重新学一下然后自己写篇题解。

本篇题解参考 [关于线段树上的一些进阶操作](https://www.luogu.com.cn/blog/command-block/guan-yu-xian-duan-shu-shang-di-yi-suo-jin-jie-cao-zuo)


先考虑如果只有加操作怎么做。假设每个点开了一个队列，存这个点被打过的所有标记，那么 `pushdown` 操作即为将父亲节点的队列中的元素全部放进儿子节点的队列，每放入一个值，则更新 $x\leftarrow x'+tag,mx\leftarrow\max(mx,x)$。但我们不可能真的存一个队列。设队列中加法标记的前缀和为 $s[1\dots k]$，则所有更新进行完后应有 $x\leftarrow x'+s_k,mx\leftarrow\max\{x'+s_i\}=x'+\max\{s_i\}$。那么我们只需要维护历史加的最大值即可。这个东西怎么维护呢？考虑合并两个队列（的前缀和）$s_{son}[1\dots k_1],s_{fa}[1\dots k_2]$ 的过程
$$
s_{son}[i]=\begin{cases}s_{son}'[i]\quad(i\le k_1)\\s'_{son}[k_1]+s_{fa}[i-k_1]\quad(k_1<i\le k_1+k_2)\end{cases}
$$
则 $\max\{s_{son}[i]\}=\max(\max \{s'_{son}[i]\},s_{son}'[k_1]+\max\{s_{fa}[i]\})$ ，则我们需要维护 $s_{son}[k_1]$ ，即目前的加法标记即可。总结一下，代码如下

```cpp
void getsum(int ro,int sum,int hsum)//hsum:父节点上一次pushdown后的历史加法标记最大值
{
   t[ro].hsum=max(t[ro].hsum,t[ro].sum+hsum);//历史加法标记最大值
   t[ro].ans[1]=max(t[ro].ans[1],t[ro].ans[0]+hsum);//历史最大值
   t[ro].ans[0]+=sum;//当前最大值
   t[ro].sum+=sum; //当前加法标记
}
```

再加上赋值操作后，如果队列中有两种标记，不便于处理。可以发现，若存在一个赋值标记，则这个区间中的所有数会变成一样的，那么之后的加法标记都可以看成赋值标记。因此，此时的队列可以表示为一个加法标记队列紧跟着一个赋值标记队列。加法标记按上面说的处理。对于赋值标记 $a[1\dots k]$，最终产生的贡献即为 $max\{a_i\}$，再维护一个历史最大赋值标记即可。

```cpp
#include<bits/stdc++.h>
#define inl inline
#define mid (t[ro].l+t[ro].r)/2
using namespace std;
namespace FGF
{
	int n,m;
	const int N=1e5+5;
	const int INF=0x3f3f3f3f;
	int read()
	{
		int s=0,w=1;char ch=getchar();
		while(!isdigit(ch)){if(ch=='-')w=-w;ch=getchar();}
		while(isdigit(ch))s=s*10+ch-'0',ch=getchar();
		return s*w;
	}
	struct tree{
		int l,r,sum,hsum,val,hval,ans[2];
		bool vis;
	}t[N<<2]; 
	int a[N];
	inl void pushup(int ro)
	{
		t[ro].ans[0]=max(t[ro<<1].ans[0],t[ro<<1|1].ans[0]);//当前最值 
		t[ro].ans[1]=max(t[ro<<1].ans[1],t[ro<<1|1].ans[1]);//历史最值 
	}
	void build(int ro,int l,int r)
	{
		t[ro].l=l,t[ro].r=r;
		if(l==r)
		{
			t[ro].ans[0]=t[ro].ans[1]=a[l];
			return;
		}
		build(ro<<1,l,mid),build(ro<<1|1,mid+1,r);
		pushup(ro);
	}
	inl void getsum(int ro,int sum,int hsum)//hsum:父节点上一次pushdown后的最大加和 
	{
		if(t[ro].vis)//是否进行过区间赋值操作 
		{
			t[ro].hval=max(t[ro].hval,t[ro].val+hsum);
			t[ro].ans[1]=max(t[ro].ans[1],t[ro].ans[0]+hsum);
			t[ro].ans[0]+=sum;
			t[ro].val+=sum;
		}
		else
		{
			t[ro].hsum=max(t[ro].hsum,t[ro].sum+hsum);
			t[ro].ans[1]=max(t[ro].ans[1],t[ro].ans[0]+hsum);
			t[ro].ans[0]+=sum;
			t[ro].sum+=sum;
		}
	}
	inl void getval(int ro,int val,int hval)//hval:父节点上一次pushdown后的最大赋值 
	{
		if(t[ro].vis)t[ro].hval=max(t[ro].hval,hval);
		else t[ro].vis=1,t[ro].hval=hval;
		t[ro].ans[1]=max(t[ro].ans[1],hval);
		t[ro].ans[0]=t[ro].val=val;
	 }
	inl void pushdown(int ro)
	{
		getsum(ro<<1,t[ro].sum,t[ro].hsum);
		getsum(ro<<1|1,t[ro].sum,t[ro].hsum);
		t[ro].sum=t[ro].hsum=0;
		if(t[ro].vis)
		{
			getval(ro<<1,t[ro].val,t[ro].hval);
			getval(ro<<1|1,t[ro].val,t[ro].hval);
			t[ro].val=t[ro].hval=0,t[ro].vis=0;
		}
	}
	void add(int ro,int l,int r,int x)
	{
		if(t[ro].l>=l&&t[ro].r<=r)
		{
			getsum(ro,x,x);
			return;
		}
		pushdown(ro);
		if(l<=mid)add(ro<<1,l,r,x);
		if(r>mid)add(ro<<1|1,l,r,x);
		pushup(ro);
	}
	void updat(int ro,int l,int r,int x)
	{
		if(t[ro].l>=l&&t[ro].r<=r)
		{
			getval(ro,x,x);
			return;
		}
		pushdown(ro);
		if(l<=mid)updat(ro<<1,l,r,x);
		if(r>mid)updat(ro<<1|1,l,r,x);
		pushup(ro);
	}
	int query(int ro,int l,int r,int op)
	{
		if(t[ro].l>=l&&t[ro].r<=r)return t[ro].ans[op];
		pushdown(ro);
		int s=-INF;
		if(l<=mid)s=query(ro<<1,l,r,op);
		if(r>mid)s=max(s,query(ro<<1|1,l,r,op));
		return s;
	}
	void work()
	{
		n=read();
		for(int i=1;i<=n;i++)
			a[i]=read();
		build(1,1,n);
		m=read();
		while(m--)
		{
			char s[5];
			int x,y;
			scanf("%s",s);x=read(),y=read();
			if(s[0]=='Q')printf("%d\n",query(1,x,y,0));
			if(s[0]=='A')printf("%d\n",query(1,x,y,1));
			if(s[0]=='P')add(1,x,y,read());
			if(s[0]=='C')updat(1,x,y,read());
		}
	}
}
int main()
{
	FGF::work();
	return 0;
}
```

---

## 作者：mydcwfy (赞：12)

**update on 2022-01-17：更改了一个错误，感谢 [lyx1311](https://www.luogu.com.cn/user/193308)。**

## 1. 前置知识 & 废话

1. AC [该题](https://www.luogu.com.cn/problem/P3372)

2. 知道如何进行定值区间修改（即改为同一个值）。

看几篇题解都没有讲第二个（可能是对他们有些简单），似乎又没有合适的题，我还是讲一下吧。

本人因为不熟悉定值区间修改，所以调试了许久，前前后后 3 个月终于过了，所以理解较深刻。

同时，希望大家不要重蹈覆辙。

如果第一个未完成的话，请先完成。

~~广告一下~~ ：[我的博客](https://www.luogu.com.cn/blog/mydcwfy-342891/segment-tree)

如果第二个不知道的话，请往下看。

为了方便，我在接下来的讲解中，用区间加表示区间同时加上一个数，区间修改表示区间改为一个数。

## 2. 维护区间定值修改

其实，这个代码如果不加上 lazytag 的话，还是很简单的（就像区间加一样维护）。

但是，如果有 lazytag 的话，事情就变的没那么简单了。

可能很多同学直接将 c（就是改为的数的懒标记）与 lazytag 共存的话，有可能会导致时间先后不分。

到底是先加，还是先赋值？这是一个问题。

假如是先加，再赋值。

比如，以下的 Hack 数据：

```plain
Input:
3
1 1 1
4
P 1 2 1
C 1 3 5
P 1 2 -1
Q 1 1
Stdans:
4
Output:
5
```

为什么呢？很明显，我们将前面的 lazytag 也算进去了，才导致了错误。

怎样将整个操作序列压缩为 2 个懒标记呢？

可以发现，对于同一个区间，赋值过后，所有的加操作都可以看作赋值操作：

刚才的数据：

```plain
P 1 2 -1
```

等价于：

```plain
C 1 2 4
```

这时，我们相当于先加，再赋值。

注意，虽然赋值操作不是对于该区间，但是我们在递归该区间时，一定会将该区间的 lazytag 下传到该区间。

有同学可能想到赋值时清空 lazytag，但是对于后面的操作，就未免有些麻烦，所以我们不推荐这一种写法。

代码 [放这](https://www.luogu.com.cn/paste/lqbzd5ra) 了。

## 3. 带区间加的历史最大值

有同学可能直接想到是用一个 bef（当前区间历史最大值）维护，但有一个问题。

假设还没更新到，就被覆盖了呢？

例如下面的 Hack 数据：

```plain
Input:
3
1 3 2
3
P 1 2 5
P 1 2 -1
A 1 3
Stdans:
8
Output:
7
```

为什么会出现这样的错误呢？

我们应该是最大值的第一个操作，还没更新子节点，就被第二个操作所覆盖了。

这个也给了我们以启发：

我们可不可以维护 lazytag 的最大值呢？

答案是肯定的。

于是，我们就可以得出答案了。

代码就略了（ ~~逃~~ ）

## 4. 本题

### 1） 题意 & 基本思路

题意接近于模板题，就是支持 4 个操作：

1. 对一个区间进行区间加

2. 对一个区间进行区间修改
3. 查询一个区间的最大值
4. 查询一个区间的历史最大值

考虑和前面一样的思路，我们对一个区间维护了六个值：
 now,bef,c,maxc,lt,maxlt

（lt 是 lazytag 的缩写啦）。

我们再考虑开始区间修改的做法：

先加，再赋值。

### 2） 重要性质

现在有一个问题：我们将父节点的操作序列是接在子节点操作序列的那个位置？

我们再来挖掘信息。

观察 [线段树 1](https://www.luogu.com.cn/problem/P3372) 的代码的一部分：

```cpp
void modify(int p,int l,int r,int x)
{
    if (tr[p].l>=l&&tr[p].r<=r)
    {
        tr[p].sum+=(ll)(tr[p].r-tr[p].l+1)*x;
        tr[p].add+=(ll)x;
        return;
    }
    pushdown(p);//重点行
    int mid=tr[p].l+tr[p].r>>1;
    if (l<=mid) modify(p1,l,r,x);
    if (r>mid) modify(p2,l,r,x);
    pushup(p);
}
```



认真思考重点行：这个 pushdown 对我们有什么作用呢？

它告诉我们，如果子节点节点在父节点之后更新，那么父节点一定会执行 pushdown。

我们又可以得到，如果父节点还有标记，那么一定是在子节点标记之后才标记的。

十分重要，请务必理解再往下读。

### 3） 具体实现

相对来说简单一些了。

现在的 maxlt 表示在第一次赋值之前，lt 达到的最大值。

maxc 表示最大赋值。

我们看怎样从子节点转移到父节点。

画张图。

![](https://cdn.luogu.com.cn/upload/image_hosting/h3cpdlj5.png)

如果子节点已经有 c 的话，maxlt 不变。
$$
son.maxc=\max(son.maxc,fa.maxc).
$$


还有一种。

![](https://cdn.luogu.com.cn/upload/image_hosting/hmghhrm7.png)

我们也可以发现，这下整个区间的 maxlt 来自一下两个地方：

1. 原来的 maxlt
2. 原来的总和 lt 加父节点的 maxlt

这时，子节点的可更新为：
$$
son.maxlt=\max(son.maxlt,son.lt+fa.maxlt)
$$
如果父节点有 c，直接赋值给儿子节点即可。

我们将 pushdown 函数先写好：

```cpp
void change(int p,int c,int maxc)
{
	tr[p].lt=0;
    tr[p].c=c;
    tr[p].maxc=max(tr[p].maxc,maxc);
    tr[p].now=c;
    tr[p].bef=max(tr[p].bef,tr[p].maxc);
}

void add(int p,int lt,int maxlt)
{
    if (tr[p].c!=INF)
    {//已经有了赋值，无需更新 lt 与 maxlt，直接进入 change
        change(p,tr[p].c+lt,tr[p].c+maxlt);
        return ;
    }
    tr[p].maxlt=max(tr[p].maxlt,tr[p].lt+maxlt);
    tr[p].bef=max(tr[p].now+maxlt,tr[p].bef);
    tr[p].now+=lt;tr[p].lt+=lt;
    return ;
}
void pushup(int p)
{
    tr[p].now=max(tr[l(p)].now,tr[r(p)].now);
    tr[p].bef=max(tr[p].now,tr[p].bef);
}

void pushdown(int p)
{
    if (tr[p].l==tr[p].r) return;
	add(l(p),tr[p].lt,tr[p].maxlt);
    add(r(p),tr[p].lt,tr[p].maxlt);
    if (tr[p].c!=INF)
    {
		change(l(p),tr[p].c,tr[p].maxc);
        change(r(p),tr[p].c,tr[p].maxc);
        tr[p].c=INF;tr[p].maxc=-INF;
    }
	tr[p].lt=0;tr[p].maxlt=0;
    pushup(p);
}
```

我这里使用函数，代码相对简洁一些。

同时，我们写成函数的好处还有一个，就是：区间加与赋值可以使用这个函数。

一个加函数可以看做是 $lt=maxlt=x$ 的操作序列。

一个赋值函数可以看做是 $c=maxc=x$ 的操作序列。

至此，这个问题就得到解决了。

## 5. 代码

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#define l(k) (k<<1)
#define r(k) (k<<1|1)
using namespace std;

const int N=2e5+10,INF=0x7fffffff;

struct Node{
    int l,r;
    int now,bef;
    int c,maxc;
    int lt,maxlt;
}tr[N<<2];
//lt 是 lazytag 的缩写啦
int a[N];

void change(int p,int c,int maxc)
{
    // printf("change_%d %d %d %d %d\n",p,tr[p].l,tr[p].r,c,maxc);
	tr[p].lt=0;
    tr[p].c=c;
    tr[p].maxc=max(tr[p].maxc,maxc);
    tr[p].now=c;
    tr[p].bef=max(tr[p].bef,tr[p].maxc);
}

void add(int p,int lt,int maxlt)
{
    // printf("add_%d %d %d %d %d %d %d\n",p,tr[p].l,tr[p].r,lt,maxlt,tr[p].lt,tr[p].maxlt);
    if (tr[p].c!=INF)
    {
        change(p,tr[p].c+lt,tr[p].c+maxlt);
        return ;
    }
    tr[p].maxlt=max(tr[p].maxlt,tr[p].lt+maxlt);
    tr[p].bef=max(tr[p].now+maxlt,tr[p].bef);
    tr[p].now+=lt;tr[p].lt+=lt;
    return ;
}
//注意，以上是 pushdown 的操作，与真正的无关，真正的在下面 insert_change/insert_plus
void pushup(int p)
{
    tr[p].now=max(tr[l(p)].now,tr[r(p)].now);
    tr[p].bef=max(tr[p].now,tr[p].bef);
}

void pushdown(int p)
{
    if (tr[p].l==tr[p].r) return;
//	printf("plus:%d %d %d %d %d %d\n",p,tr[p].l,tr[p].r,tr[p].c,tr[p].lt,tr[p].maxlt);
	/*if (tr[l(p)].c!=INF) pushdown(l(p));
	if (tr[r(p)].c!=INF) pushdown(r(p));*/
	add(l(p),tr[p].lt,tr[p].maxlt);
    add(r(p),tr[p].lt,tr[p].maxlt);
    if (tr[p].c!=INF)
    {
//    	printf("change:%d %d %d %d %d\n",p,tr[p].l,tr[p].r,tr[p].c,tr[p].maxc);
		change(l(p),tr[p].c,tr[p].maxc);
        change(r(p),tr[p].c,tr[p].maxc);
        tr[p].c=INF;tr[p].maxc=-INF;
    }
	tr[p].lt=0;tr[p].maxlt=0;
    pushup(p);
}

void build(int p,int l,int r)
{
    tr[p]=(Node){l,r,0,-INF};
    tr[p].c=INF;tr[p].maxc=-INF;
    tr[p].lt=tr[p].maxlt=0;
    if (l==r)
    {
        tr[p].bef=tr[p].now=a[l];
        return;
    }
    int mid=l+r>>1;
    build(l(p),l,mid);
    build(r(p),mid+1,r);
    pushup(p);
}

void insert_change(int p,int l,int r,int x)
{
    if (l<=tr[p].l&&r>=tr[p].r)
    {
    	change(p,x,x);
//		printf("here:%d %d %d %d %d %d\n",p,tr[p].l,tr[p].r,tr[p].c,tr[p].maxc,tr[p].bef);
        return;
    }
    pushdown(p);
    int mid=tr[p].l+tr[p].r>>1;
    if (l<=mid) insert_change(l(p),l,r,x);
    if (r>mid) insert_change(r(p),l,r,x);
    pushup(p);
}

void insert_plus(int p,int l,int r,int x)
{
    if (l<=tr[p].l&&r>=tr[p].r)
    {
        /*if (tr[p].c!=INF) insert_change(p,l,r,x+tr[p].now);
        else tr[p].now+=x,tr[p].lt+=x,tr[p].maxlt=max(tr[p].lt,tr[p].maxlt),tr[p].bef=max(tr[p].bef,tr[p].now);*/
        add(p,x,x);
        /*if (p==4)
        {
        	printf("-------%d %d %d\n",p,tr[p].c,tr[p].lt);
        }*/
//		printf("here___:%d %d %d %d %d %d\n",p,tr[p].l,tr[p].r,tr[p].lt,tr[p].maxlt,tr[p].bef);
        return;
    }
    pushdown(p);
    int mid=tr[p].l+tr[p].r>>1;
    if (l<=mid) insert_plus(l(p),l,r,x);
    if (r>mid) insert_plus(r(p),l,r,x);
    pushup(p);
}

int querynow(int p,int l,int r)
{
    if (tr[p].l>=l&&tr[p].r<=r)
    {
   	    // printf("query_now%d %d %d %d\n",p,tr[p].l,tr[p].r,tr[p].now);
        return tr[p].now;
    }
    pushdown(p);
    int mid=tr[p].l+tr[p].r>>1,ans=-INF;
    if (l<=mid) ans=max(ans,querynow(l(p),l,r));
    if (r>mid) ans=max(ans,querynow(r(p),l,r));
    return ans;
}

int querybef(int p,int l,int r)
{
    if (tr[p].l>=l&&tr[p].r<=r)
    {
   	    // printf("query_bef%d %d %d %d\n",p,tr[p].l,tr[p].r,tr[p].bef);
        return tr[p].bef;
    }
    pushdown(p);
    int mid=tr[p].l+tr[p].r>>1,ans=-INF;
    if (l<=mid) ans=max(ans,querybef(l(p),l,r));
    if (r>mid) ans=max(ans,querybef(r(p),l,r));
    return ans;
}

int main()
{
	// freopen("randdata.in","r",stdin);
	// freopen("myans.out","w",stdout);
    int n,m;scanf("%d",&n);
    for (int i=1;i<=n;++i) scanf("%d",a+i);
    build(1,1,n);
    scanf("%d",&m);
    char op[5];
    int l,r,x;
    while (m--)
    {
        scanf("%s",op);
        scanf("%d %d",&l,&r);
        if (op[0]=='Q')
        {
            printf("%d\n",querynow(1,l,r));
        }
        else if (op[0]=='A')
        {
            printf("%d\n",querybef(1,l,r));
        }
        else{
            scanf("%d",&x);
            if (op[0]=='P') insert_plus(1,l,r,x);
            else insert_change(1,l,r,x);
        }
    }
    return 0;
}

```



---

## 作者：LDlornd (赞：9)

标准线段树。

~~说实话感觉并没有NOI+的难度……~~

但是打标记的方法十分值得我们学习，来讲讲思路吧：

------------

我最开始的想法是这样的：

关于历史最大值，可以在线段树内开一个新的权值$\ hmax\ $ (当前最大值为$\ nmax\ $)，更新方程为 $:\ hmax=max(hmax,nmax)$ 。其次关于修改，想到要打两个标记: $\ addlazy\ $和$\ changelazy\ $，最大值计算方式为 $\ nmax=changelazy+addlazy\ $ 。

然而，这样子会有一点 $\ bug\ $ ，就是很有可能会出现这样的情况：对于某个结点 $\ i\ $ ，在它的标记还没有下放的时候，它的父亲又下放了新的标记给它，于是就将原来的标记覆盖了，丢失了原来的那一次修改的值，这样在查询历史最大值的时候就有可能出现错误的答案。

在这种想法下，为了避免错误的答案，就必须在每一次有新的标记下放给 $\ i\ $ 之前，把 $\ i\ $ 上的标记全部下放，但是这样就会使得时间复杂度暴增，我们定义了$\ lazy\ $ 也就失去了它们存在的意义。实测如果这样写的话，只能得 $\ 20\ $分（$\ 2AC\ \&\ 8TLE\ $）。

------------

于是考虑新的做法（感谢 $\ GXZlegend\ $及其博客）：

声明：在以下表达中，前缀 $\ n\ $表示 $\ now\ $ ，前缀 $\ h\ $ 表示 $\ history\ $。

我们可以将标记定义成二维的$\ (add,change)\ $，最大值的计算方式为：$\ nmax=max(nmax+add,change)\ $ 以及 $\ hmax=max(hmax+add,change)\ $ ，并且在某一个节点处定义两个标记 $\ nlazy\ $（表示当前的修改标记）和 $\ hlazy\ $ （表示使得这个节点的历史最大值达到最大时的标记），事实上这两个标记都可以认为是曾经的多个标记的共同作用的结果。

然后考虑如何更新标记（把标记 $\ (c,d)\ $ 加到 $\ (a,b)\ $ 上去），不难发现：若要使得计算方式不发生改变，则新的标记为：$\ (a+c,max(d,b+c))\ $。

然后如何维护历史最大标记呢？ 由计算方式可得：若要使得 $\ hmax\ $ 最大，需要使得 $\ add\  $最大或者 $\ change\ $ 最大，所以当两个标记分别为 $\ (a,b),(c,d)\ $ 时， $\ hlazy=(max(a,c),max(b,d))\ $。

还有一点：修改操作与标记有什么关系呢？不难发现，当我们要区间加的时候，打上一个 $\ (z,-inf)\ $ 的标记，当我们要区间赋值的时候，打上一个 $\ (-inf,z)\ $ 的标记就行了。

到此为止，我们应该把所有要考虑的东西都考虑完了，于是可以愉快地开始敲代码，并且愉快地 $\ AC\ $ 此题了：

习惯指针写法，[原博客为似乎更流行的数组写法](http://www.cnblogs.com/GXZlegend/p/8315275.html)
```
#include<cstdio>
#include<cstdlib>
#include<iostream>
using namespace std;
const int MAXN=100001;
const int INF=0x3f3f3f3f;
char opt;
int T,E,x,y,z;
int arr[MAXN];
struct data{
    int add,change;
    data(int aa=0,int cc=-INF) {add=aa;change=cc;}
    data operator +(const data &a) const{return data(max(-INF,add+a.add),max(a.change,change+a.add));}
    data operator *(const data &a) const{return data(max(add,a.add),max(change,a.change));}
};
struct segtree{
    int Start,End;
    int nmax,hmax;
    data nlazy,hlazy;
    segtree *son[2];
    segtree(){
        Start=End=nmax=hmax=0;
        nlazy=hlazy=data();
        son[0]=son[1]=NULL;
    }
    inline void update(){
        nmax=max(son[0]->nmax,son[1]->nmax);
        hmax=max(son[0]->hmax,son[1]->hmax);
    }
    inline void caculate(data now,data history){
        hlazy=hlazy*(nlazy+history);
        nlazy=nlazy+now;
        hmax=max(hmax,max(nmax+history.add,history.change));
        nmax=max(nmax+now.add,now.change);
    }
    inline void pushdown(){
        son[0]->caculate(nlazy,hlazy);
        son[1]->caculate(nlazy,hlazy);
        nlazy=hlazy=data();
    }
    inline void build(int nstart,int nend){
        Start=nstart;End=nend;
        if(Start==End){nmax=hmax=arr[Start];return;}
        int mid=(Start+End)>>1;
        (son[0]=new(segtree))->build(Start,mid);
        (son[1]=new(segtree))->build(mid+1,End);
        update();
    }
    inline void modify(int nstart,int nend,data key){
        if(nstart==Start&&nend==End) {caculate(key,key);return;}
        pushdown();
        int mid=(Start+End)>>1;
        if(nstart>mid) son[1]->modify(nstart,nend,key);
        else if(nend<=mid) son[0]->modify(nstart,nend,key);
        else {son[0]->modify(nstart,mid,key);son[1]->modify(mid+1,nend,key);}
        update();
    }
    inline int query(int nstart,int nend,bool flag){
        if(nstart==Start&&nend==End) return flag?hmax:nmax;
        pushdown();
        int mid=(Start+End)>>1;
        if(nstart>mid) return son[1]->query(nstart,nend,flag);
        if(nend<=mid) return son[0]->query(nstart,nend,flag);
        else return max(son[0]->query(nstart,mid,flag),son[1]->query(mid+1,nend,flag));
    }
}*root;
inline int read(){
    int x=0,f=1;char c=getchar();
    for(;c<'0'||c>'9';c=getchar()) if(c=='-') f=-1;
    for(;c>='0'&&c<='9';c=getchar()) x=(x<<3)+(x<<1)+c-'0';
    return x*f;
}
int main(){
    T=read();
    for(int i=1;i<=T;++i) arr[i]=read();
    (root=new(segtree))->build(1,T);
    E=read();
    while(E--){
        opt=getchar();
        while(opt<'A'||opt>'Z') opt=getchar();
        x=read();y=read();
        if(opt=='Q') printf("%d\n",root->query(x,y,false));
        if(opt=='A') printf("%d\n",root->query(x,y,true));
        if(opt=='P') {z=read();root->modify(x,y,data(z,-INF));}
        if(opt=='C') {z=read();root->modify(x,y,data(-INF,z));}
    }
    return 0;
}
```
不开$\ O2\ $跑了 $\ 4992ms\ $ ，开 $\ O2\ $ 只跑了 $\ 1380ms\ $ ，请让我感叹一句 $\ O2\ $的巨大用处。

最后再吐槽一句：感觉线段树的精髓，不过就是找好 $\ lazy\ $ 以及 $\ lazy\ $ 与 $\ val\ $ 之间的计算方式，但即使如此，还是十分有趣的。

希望对大家有帮助。

---

## 作者：Aftglw (赞：6)

打标记，推标记，好麻烦。

历史最值问题、历史版本和问题，直接考虑用不动脑子的线代解法。

由于要维护两个数组 $a, b$，然后每次操作让 $b_i \leftarrow \max(a_i, b_i)$，于是直接把 $a_i, b_i$ 放入一个向量里面，记作 $\begin{bmatrix} a_i\\b_i \end{bmatrix}$。

重定义矩阵乘法，将 $\times, +$ 分别换成 $+ ,\max$，则每次更新 $b_i \leftarrow \max(a_i, b_i)$ 可以看作：

$$
\begin{bmatrix} a_i\\b_i \end{bmatrix}
\leftarrow
\begin{bmatrix} 0 & -\infty \\ 0 & 0 \end{bmatrix}
\begin{bmatrix} a_i\\b_i \end{bmatrix}
$$

用线段树维护向量，那么每次操作完让全局乘上一个固定的矩阵即可，直接打区间乘法 标记。

然后考虑区间加法。

如果区间加上 $k$：

$$
\begin{bmatrix} a_i\\b_i \end{bmatrix}
\leftarrow
\begin{bmatrix} k & -\infty \\ -\infty & 0 \end{bmatrix}
\begin{bmatrix} a_i\\b_i \end{bmatrix}
$$

然后考虑区间覆盖。

发现不对了，需要一个常数项，于是将向量改为 $\begin{bmatrix} a_i\\b_i\\0 \end{bmatrix}$

那么如果区间赋为 $k$：

$$
\begin{bmatrix} a_i\\b_i\\0 \end{bmatrix}
\leftarrow
\begin{bmatrix} -\infty & -\infty & k \\ -\infty & 0 & -\infty \\ -\infty & -\infty & 0 \end{bmatrix}
\begin{bmatrix} a_i\\b_i \\ 0 \end{bmatrix}
$$

同理每次区间加变为：

$$
\begin{bmatrix} a_i\\b_i\\0 \end{bmatrix}
\leftarrow
\begin{bmatrix} k & -\infty & -\infty \\ -\infty & 0 & -\infty \\ -\infty & -\infty & 0 \end{bmatrix}
\begin{bmatrix} a_i\\b_i\\0 \end{bmatrix}
$$

更新 $b_i$ 变为：

$$
\begin{bmatrix} a_i\\b_i\\0 \end{bmatrix}
\leftarrow
\begin{bmatrix} 0 & -\infty & -\infty \\ 0 & 0 & -\infty \\ -\infty & -\infty & 0 \end{bmatrix}
\begin{bmatrix} a_i\\b_i\\0 \end{bmatrix}
$$

发现任何操作都可以转化为了区间乘法，于是只用维护一个乘法标记就行了。

时间复杂度 $\mathcal O(n \log n)$ ，但是由于是矩阵乘法，所以常数较大，但是足以通过，[code](https://www.luogu.com.cn/paste/kf3zoztq)。

但是有些情况就过不了，比如[这题](https://www.luogu.com.cn/problem/P8868) ，所以有必要学会一定的卡常技巧（~~如果你非要把矩阵乘法完全循环展开还是可以通过那道题的~~）。

发现任何时刻任何矩阵中，除了这四个位置（$*$ 标记处），其他位置的值都是不变的。

$$
\begin{bmatrix} * & -\infty & * \\ * & 0 & * \\ -\infty & -\infty & 0 \end{bmatrix}
$$

于是可以只用维护这四个位置的值，然后根据矩阵乘法写出这四个值的转移式即可。

这样写常数约为直接矩阵乘法的 $\frac 1 4$，[code](https://www.luogu.com.cn/paste/4adm882i)。

当然还可以优化常数，比如标记永久化，只不过我就没写了。

注意 $-\infty$ 不要设得太小，会爆 `long long`。

---

## 作者：konjacq (赞：6)

一看$T,E\le10^5$就可以考虑开始非常naive的分块了.首先注意到需要维护每个点的当前值/历史最大值和块内的当前最大/历史最大值,然后查询就很容易了.  
但是注意到以上四个值并不好直接维护,所以考虑拆开来维护.容易发现如果一块内所有值全部一样,那么区间加和区间赋值实际上没有区别.

考虑每一个块内的修改,可以分为四个部分:

- 执行了数次整块区间加,打标记;
- 执行了整块区间赋值,打标记;
- 执行了数次整块区间加/赋值,打标记;
- 作为散块被修改,统计标记贡献,清空标记;

![](https://i.loli.net/2021/01/25/iAhT8VzElUMwbsu.png)

图中从左到右分别是初始状态(第四部分修改后的状态)和前三次修改后的状态.黑色是当前状态,蓝色是上一张图的状态,橙色是历史最大值.

考虑对每个区间维护七个标记:区间加$\mathrm{adt}$,区间赋值$\mathrm{ftt}$,是否进行了区间赋值$\mathrm{ftf}$,当前最大$\mathrm{nmx}$,历史最大$\mathrm{hmx}$,历史最大区间加$\mathrm{amx}$,历史最大区间赋值$\mathrm{fmx}$;对每个点再维护当前值$\mathrm{nvl}$和历史最大值$\mathrm{hvl}$标记.

然后就能写出每一个修改的操作了,分别是:

- 直接修改区间加标记,维护历史最大区间加标记,
  此时区间最大值/历史区间最大值/单个数当前值/单个数历史最大值分别是$\mathrm{nmx}+\mathrm{adt}$/$\max\{\mathrm{hmx},\mathrm{nmx}+\mathrm{amx}\}$/$\mathrm{nvl}+\mathrm{adt}$/$\max\{\mathrm{hvl},\mathrm{nvl}+\mathrm{amx}\}$;
- 记录"已经进行了区间赋值",修改区间赋值标记,维护历史最大区间赋值标记;
  四个值分别是$\mathrm{ftt}$/$\max\{\mathrm{hmx},\mathrm{fmx},\mathrm{nmx}+\mathrm{amx}\}$/$\mathrm{fmx}$/$\max\{\mathrm{hvl},\mathrm{fmx},\mathrm{nvl}+\mathrm{amx}\}$;
- 修改区间赋值标记,维护历史最大区间赋值标记;
  四个值同上;
- 令$\mathrm{nvl}\gets\begin{cases}\mathrm{nvl}+\mathrm{adt}&\mathrm{ftf}=\mathrm{false}\\\mathrm{ftt}&\mathrm{ftf}=\mathrm{true}\end{cases}$,同时扫描整个区间更新$\mathrm{nmx}$,剩下标记复位($0$或$-\infty$).
  四个值分别是$\mathrm{nmx}$/$\mathrm{hmx}$/$\mathrm{nvl}$/$\mathrm{hvl}$.

同样的,作为散块被统计贡献时,也需要统计标记贡献并清空标记.

```cpp
#include <algorithm>
#include <cstdio>
#include <cstring>
using namespace std;

typedef long long ll;

/* ---- read() & rlong() - begin ---- */
#define gc() (p0==p1&&(p1=(p0=buf)+fread(buf,1,1048576,stdin),p0==p1)?EOF:*p0++)
#define pc(c) (p2==fub+1048576?(fwrite(fub,1048576,1,stdout),*((p2=fub)++)=c):*(p2++)=c)
char buf[1048576],fub[1048576],*p0,*p1,*p2=fub;
inline int read() {
	int r=0; char c=gc(); bool f=false;
	while ((c<48||c>57)&&c!=45) c=gc(); if (c==45) {f=true; c=gc();}
	while (c>47&&c<58) {r=(r<<3)+(r<<1)+(c^48); c=gc();} return f?-r:r;
}
inline char rchar() {char c=gc(); while (c<65||c>90) c=gc(); return c;}
template <typename _typ> inline void write(_typ x) {
	static char t[25]; if (!x) {pc(48); pc(10); return;} char *p=t+1;
	t[1]=10; if (x<0) {x=-x; pc(45);} while (x) {*(++p)=(x%10)^48; x/=10;}
	while (p!=t) pc(*(p--));
}
#undef gc
#undef pc
/* ---- read() & rlong() -- end ----- */

const int q=317; int n,p[100505],l[325],r[325];
int nvl[100505],hvl[100505],adt[325],ftt[325];
int nmx[325],hmx[325],amx[325],fmx[325]; bool ftf[325];

inline void pushtag(int u) {
	if (ftf[u]) for (int i=l[u];i<=r[u];++i) {
		hvl[i]=max(hvl[i],max(nvl[i]+amx[u],fmx[u])); nvl[i]=ftt[u];
	}
	else for (int i=l[u];i<=r[u];++i) {
		hvl[i]=max(hvl[i],nvl[i]+amx[u]); nvl[i]+=adt[u];
	}
	adt[u]=amx[u]=0; fmx[u]=0x80000000; ftf[u]=false;
}

inline void recalc(int u) {
	nmx[u]=0x80000000; for (int i=l[u];i<=r[u];++i)
		{nmx[u]=max(nmx[u],nvl[i]); hmx[u]=max(hmx[u],hvl[i]);}
}

inline void modify_ad(int u,int v,int w) {
	if (p[u]==p[v]) {
		pushtag(p[u]); for (int i=u;i<=v;++i)
			hvl[i]=max(hvl[i],nvl[i]+=w); recalc(p[u]);
	}
	else {
		pushtag(p[u]); pushtag(p[v]);
		for (int i=u;i<=r[p[u]];++i) hvl[i]=max(hvl[i],nvl[i]+=w);
		for (int i=l[p[v]];i<=v;++i) hvl[i]=max(hvl[i],nvl[i]+=w);
		recalc(p[u]); recalc(p[v]); for (int i=p[u]+1;i<p[v];++i)
			ftf[i]?fmx[i]=max(fmx[i],ftt[i]+=w):amx[i]=max(amx[i],adt[i]+=w);
	}
}

inline void modify_ft(int u,int v,int w) {
	if (p[u]==p[v]) {
		pushtag(p[u]); for (int i=u;i<=v;++i)
			hvl[i]=max(hvl[i],nvl[i]=w); recalc(p[u]);
	}
	else {
		pushtag(p[u]); pushtag(p[v]);
		for (int i=u;i<=r[p[u]];++i) hvl[i]=max(hvl[i],nvl[i]=w);
		for (int i=l[p[v]];i<=v;++i) hvl[i]=max(hvl[i],nvl[i]=w);
		recalc(p[u]); recalc(p[v]); for (int i=p[u]+1;i<p[v];++i) {
			fmx[i]=max(fmx[i],ftt[i]=w); ftf[i]=true;
		}
	}
}

inline int query_mx(int u,int v) {
	int w=0x80000000; if (p[u]==p[v]) {
		pushtag(p[u]); for (int i=u;i<=v;++i) w=max(w,nvl[i]); recalc(p[u]);
	}
	else {
		pushtag(p[u]); for (int i=u;i<=r[p[u]];++i) w=max(w,nvl[i]);
		pushtag(p[v]); for (int i=l[p[v]];i<=v;++i) w=max(w,nvl[i]);
		recalc(p[u]); recalc(p[v]); for (int i=p[u]+1;i<p[v];++i)
			w=max(w,ftf[i]?ftt[i]:nmx[i]+adt[i]);
	}
	return w;
}

inline int query_hx(int u,int v) {
	int w=0x80000000; if (p[u]==p[v]) {
		pushtag(p[u]); for (int i=u;i<=v;++i) w=max(w,hvl[i]); recalc(p[u]);
	}
	else {
		pushtag(p[u]); for (int i=u;i<=r[p[u]];++i) w=max(w,hvl[i]);
		pushtag(p[v]); for (int i=l[p[v]];i<=v;++i) w=max(w,hvl[i]);
		recalc(p[u]); recalc(p[v]); for (int i=p[u]+1;i<p[v];++i)
			w=max(w,ftf[i]?max(max(hmx[i],fmx[i]),nmx[i]+amx[i]):max(hmx[i],nmx[i]+amx[i]));
	}
	return w;
}

int main() {
	int m,u,v; n=read();
	for (int i=0;i<n;++i) {nvl[i]=hvl[i]=read(); p[i]=i/q;} p[n]=p[n-1]+1;
	for (int i=0,j;j<n;r[i]=(l[i+1]=j)-1,++i) {
		nmx[i]=nvl[l[i]]; fmx[i]=0x80000000;
		for (j=l[i]+1;p[j-1]==p[j];++j) nmx[i]=max(nvl[j],nmx[i]); hmx[i]=nmx[i];
	}
	m=read(); while (m--) switch (rchar()) {
		case 65: u=read()-1; write(query_hx(u,read()-1)); break;
		case 67: u=read()-1; v=read()-1; modify_ft(u,v,read()); break;
		case 80: u=read()-1; v=read()-1; modify_ad(u,v,read()); break;
		case 81: u=read()-1; write(query_mx(u,read()-1)); break;
		default: break;
	}
	fwrite(fub,p2-fub,1,stdout); return 0;
}
```

---

## 作者：枫林晚 (赞：6)


题目大意：

给定一个区间及其各个元素的初值，要求支持如下操作：

1.区间加

2.区间赋值

3.查询区间最大值

4.查询区间历史最大值

分析：

容易想到线段树，但是细思恶极（仔细想想恶心到了极点）的是，最后查询区间历史最大值的操作。

如果只记录区间历史最大值显然不能下放，如果单纯更新区间加，区间赋值最大值，可能会出现历史最大值更新不及时的情况。如先赋值很大值，未来得及下放，又赋值很小，导致子区间历史最大值不能更新。又如如果区间加只取最大值，可能会只取最大值，导致实际上忽视了一些使区间加变小的操作。

。。。。（此处省略若千字）

所以我们记录如下几点：

1.mx(x)当前区间最大值

2.hx(x)历史区间最大值

3.ad(x)当前区间加

4.ha(x)历史最大区间加

5.ch(x)当前区间赋值

6.hc(x)历史最大区间赋值

注意 ：

这里我们所谓的ha,hc是指在上一次pushdown之后，期间进行的操作中的最大值。是可以清零的，不像hx。

初值：ha=ad=0,ch=hc=-inf。

因为每次都先进行pushdown，所以ha、hc直接随着ad、ch更新。

注意的是pushdown中的许多讨论，自己分析清楚。

其实每次都pushdown是很慢的，会tle两个点。

然后就把区间内的l、r不记录了，竟然不开O2水过。

详见代码：

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int N=100000+10;
const ll inf=1e13;
int root,n,e;
ll a[N];
int cc;
struct node{
    ll add,ch;
    ll mx,hx;
    ll had,hch;//一段时间内最值  
    #define ad(x) t[x].add
    #define ch(x) t[x].ch
    #define mx(x) t[x].mx
    #define hx(x) t[x].hx
    #define ha(x) t[x].had
    #define hc(x) t[x].hch
    #define l(x) t[x].l
    #define r(x) t[x].r
}t[4*N];
void pushup(int x)
{
    int s1=x<<1,s2=x<<1|1;
    mx(x)=max(mx(s1),mx(s2));
    hx(x)=max(hx(s1),hx(s2));
}
void build(int x,int L,int R)
{
    if(L==R)
    {
        ad(x)=0;ch(x)=-inf;ha(x)=0;hc(x)=-inf;
        mx(x)=hx(x)=a[L];
        return;
    }
    int mid=(L+R)>>1;
    ad(x)=0;ch(x)=-inf;ha(x)=0;hc(x)=-inf;
    mx(x)=hx(x)=-inf;
    build(x<<1,L,mid);
    build(x<<1|1,mid+1,R);
    pushup(x);
}
void pushdown(int x)
{
    for(int i=0;i<=1;i++)
    {
        int s=x<<1|i;
        hx(s)=max(hx(s),max(mx(s)+ha(x),hc(x)));
        if(ch(s)!=-inf) hc(s)=max(hc(s),ch(s)+ha(x));
        else ha(s)=max(ha(s),ad(s)+ha(x));
        if(ad(x))
        {
            if(ch(s)!=-inf) ch(s)+=ad(x);
            else ad(s)+=ad(x);
            mx(s)+=ad(x);
        }
        if(ch(x)!=-inf)
        {
            mx(s)=ch(s)=ch(x);
            ad(s)=0;
        }
        hc(s)=max(hc(s),max(ch(s),hc(x)));
        ha(s)=max(ha(s),ad(s));	
    }
    hc(x)=-inf;
    ad(x)=0;ch(x)=-inf;ha(x)=0;
}
void add(int x,int l,int r,int L,int R,ll c)
{
    if(l!=r)pushdown(x);
    if(L<=l&&r<=R)
    {
        ad(x)+=c;ha(x)+=c;
        mx(x)+=c;hx(x)=max(mx(x),hx(x));
        return;
    }
    
    int mid=(l+r)>>1;
    if(L<=mid) add(x<<1,l,mid,L,R,c);
    if(R>mid) add(x<<1|1,mid+1,r,L,R,c);
    pushup(x);
}
void chan(int x,int l,int r,int L,int R,ll c)
{
    if(l!=r)pushdown(x);
    if(L<=l&&r<=R)
    {
        ch(x)=c,mx(x)=c;hc(x)=c;
        hx(x)=max(hx(x),mx(x));
        return;
    }	
    int mid=(l+r)>>1;
    if(L<=mid) chan(x<<1,l,mid,L,R,c);
    if(R>mid) chan(x<<1|1,mid+1,r,L,R,c);
    pushup(x);
}
ll qx(int x,int l,int r,int L,int R)
{
    if(l!=r)pushdown(x);
    if(L<=l&&r<=R)
    {
        return mx(x);
    }
    int mid=(l+r)>>1;
    ll res=-inf;
    if(L<=mid) res=max(res,qx(x<<1,l,mid,L,R));
    if(R>mid) res=max(res,qx(x<<1|1,mid+1,r,L,R));
    return res;
}
ll qh(int x,int l,int r,int L,int R)
{
    if(l!=r)pushdown(x);
    if(L<=l&&r<=R)
    {
        return hx(x);
    }
    int mid=(l+r)>>1;
    ll res=-inf;
    if(L<=mid) res=max(res,qh(x<<1,l,mid,L,R));
    if(R>mid) res=max(res,qh(x<<1|1,mid+1,r,L,R));
    return res;
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++) scanf("%lld",&a[i]);
    root=1;
    build(1,1,n);
    scanf("%d",&e);
    char q;
    int x,y;
    ll z;
    while(e)
    {
        cin>>q;
        if(q=='Q')
        {
            scanf("%d%d",&x,&y);
            printf("%lld\n",qx(root,1,n,x,y));	
        }
        else if(q=='A')
        {
            
            scanf("%d%d",&x,&y);
            printf("%lld\n",qh(root,1,n,x,y));
        }
        else if(q=='P')
        {
            scanf("%d%d%lld",&x,&y,&z);
            add(root,1,n,x,y,z);
        }
        else{
            scanf("%d%d%lld",&x,&y,&z);
            chan(root,1,n,x,y,z);
        }
        e--;
    }
    return 0;
}
```


---

## 作者：torque (赞：4)

## 前言

某一日我同学叫我做这道题，我一看，这不就板子吗？还黑的？20分钟欻欻打完，自信提交。。。。。0分

## 题意

题意就是一段序列有``区间加``、``区间覆盖``、``查询区间最大值``、``查询区间历史最大值``

我第一次做的思路就是这样的：

用普通的线段树维护，每次更新完最大值$maxn$后维护历史最大值$maxh$，即：

$maxh=max(maxh,maxn)$

然鹅WA了，一分都没有。。。

然后在同（da）学（lao）的帮助下我明白了问题所在：

在对大区间进行操作时，容易出现历史最大值丢失的问题，即加了一个大值却又被小值覆盖掉

对pushdown进行一定修改才能过，虽然我不知道怎么改（小声

这里就介绍一种可以防止信息流失的方式：多维护两个标记（``区间历史最大加``、``区间历史最大覆盖``）

每次修改以及下放标记都要进行维护

如果我们写成这样：

+ 区间左、右端编号：$l,r$
+ 区间最大值：$maxn$
+ 区间历史最大值：$maxh$
+ 区间覆盖标记：$tag1$
+ 区间历史最大覆盖：$hc$
+ 区间加标记：$tag2$
+ 区间历史最大加：$hp$

那么它（pushdown）就是这样滴：

```cpp
void pushdown(int id){
	if(t[id].l==t[id].r) return ;
	t[id<<1].maxh=max(t[id<<1].maxh,max(t[id<<1].maxn+t[id].hp,t[id].hc));
	t[id<<1|1].maxh=max(t[id<<1|1].maxh,max(t[id<<1|1].maxn+t[id].hp,t[id].hc));
	if(t[id<<1].tag1!=-INF) t[id<<1].hc=max(t[id<<1].hc,t[id<<1].tag1+t[id].hp);
	else t[id<<1].hp=max(t[id<<1].hp,t[id<<1].tag2+t[id].hp);
	if(t[id<<1|1].tag1!=-INF) t[id<<1|1].hc=max(t[id<<1|1].hc,t[id<<1|1].tag1+t[id].hp);
	else t[id<<1|1].hp=max(t[id<<1|1].hp,t[id<<1|1].tag2+t[id].hp);
	if(t[id].tag2){
		if(t[id<<1].tag1!=-INF) t[id<<1].tag1+=t[id].tag2;
		else t[id<<1].tag2+=t[id].tag2;
		if(t[id<<1|1].tag1!=-INF) t[id<<1|1].tag1+=t[id].tag2;
		else t[id<<1|1].tag2+=t[id].tag2;
		t[id<<1].maxn+=t[id].tag2,t[id<<1|1].maxn+=t[id].tag2;
	}
	if(t[id].tag1!=-INF){
		t[id<<1].maxn=t[id<<1].tag1=t[id].tag1;
		t[id<<1|1].maxn=t[id<<1|1].tag1=t[id].tag1;
		t[id<<1].tag2=0,t[id<<1|1].tag2=0;
	}
	t[id<<1].hp=max(t[id<<1].hp,t[id<<1].tag2);
	t[id<<1|1].hp=max(t[id<<1|1].hp,t[id<<1|1].tag2);
	t[id<<1].hc=max(t[id<<1].hc,max(t[id<<1].tag1,t[id].hc));
	t[id<<1|1].hc=max(t[id<<1|1].hc,max(t[id<<1|1].tag1,t[id].hc));
	t[id].hc=t[id].tag1=-INF;
	t[id].hp=t[id].tag2=0;
}
```

这里$-INF$和$0$分别代表$tag1,hc$和$tag2,hp$不存在

如果还是不能理解就请再看看上面那段代码（因为这就是难点）

总的来说这是一道思维量、代码量兼备的好题（蒟蒻我调了一下午。。）

时间复杂度$O(ElogT)$，稳过！

## 代码
```cpp
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#define N 100001
#define INF 1ll<<31
#define int long long
#define rnt register int
using namespace std;
char s[10];
int n,m,x,y,z,d[N];
struct node{int l,r,maxn,maxh,tag1/*+*/,tag2/*=*/,hp,hc;}t[N*4];
void pushup(int id){
	t[id].maxn=max(t[id<<1].maxn,t[id<<1|1].maxn);
	t[id].maxh=max(t[id<<1].maxh,t[id<<1|1].maxh);
}
void build(int id,int l,int r){
	t[id].l=l,t[id].r=r,t[id].tag1=t[id].hc=-INF;
	if(l==r){
		t[id].maxh=t[id].maxn=d[l];
		return ;
	}
	int mid=(l+r)>>1;
	build(id<<1,l,mid);
	build(id<<1|1,mid+1,r);
	pushup(id);
}
void pushdown(int id){
	if(t[id].l==t[id].r) return ;
	t[id<<1].maxh=max(t[id<<1].maxh,max(t[id<<1].maxn+t[id].hp,t[id].hc));
	t[id<<1|1].maxh=max(t[id<<1|1].maxh,max(t[id<<1|1].maxn+t[id].hp,t[id].hc));
	if(t[id<<1].tag1!=-INF) t[id<<1].hc=max(t[id<<1].hc,t[id<<1].tag1+t[id].hp);
	else t[id<<1].hp=max(t[id<<1].hp,t[id<<1].tag2+t[id].hp);
	if(t[id<<1|1].tag1!=-INF) t[id<<1|1].hc=max(t[id<<1|1].hc,t[id<<1|1].tag1+t[id].hp);
	else t[id<<1|1].hp=max(t[id<<1|1].hp,t[id<<1|1].tag2+t[id].hp);
	if(t[id].tag2){
		if(t[id<<1].tag1!=-INF) t[id<<1].tag1+=t[id].tag2;
		else t[id<<1].tag2+=t[id].tag2;
		if(t[id<<1|1].tag1!=-INF) t[id<<1|1].tag1+=t[id].tag2;
		else t[id<<1|1].tag2+=t[id].tag2;
		t[id<<1].maxn+=t[id].tag2,t[id<<1|1].maxn+=t[id].tag2;
	}
	if(t[id].tag1!=-INF){
		t[id<<1].maxn=t[id<<1].tag1=t[id].tag1;
		t[id<<1|1].maxn=t[id<<1|1].tag1=t[id].tag1;
		t[id<<1].tag2=0,t[id<<1|1].tag2=0;
	}
	t[id<<1].hp=max(t[id<<1].hp,t[id<<1].tag2);
	t[id<<1|1].hp=max(t[id<<1|1].hp,t[id<<1|1].tag2);
	t[id<<1].hc=max(t[id<<1].hc,max(t[id<<1].tag1,t[id].hc));
	t[id<<1|1].hc=max(t[id<<1|1].hc,max(t[id<<1|1].tag1,t[id].hc));
	t[id].hc=t[id].tag1=-INF;
	t[id].hp=t[id].tag2=0;
}
int query(int id,int l,int r){
	pushdown(id);
	if(t[id].l==l && t[id].r==r) return t[id].maxn;
	int mid=(t[id].l+t[id].r)>>1;
	if(r<=mid) return query(id<<1,l,r);
	else if(l>mid) return query(id<<1|1,l,r);
	else return max(query(id<<1,l,mid),query(id<<1|1,mid+1,r));
}
int ask(int id,int l,int r){//query_history
	pushdown(id);
	if(t[id].l==l && t[id].r==r) return t[id].maxh;
	int mid=(t[id].l+t[id].r)>>1;
	if(r<=mid) return ask(id<<1,l,r);
	else if(l>mid) return ask(id<<1|1,l,r);
	else return max(ask(id<<1,l,mid),ask(id<<1|1,mid+1,r));
}
void plus(int id,int l,int r,int val){
	pushdown(id);
	if(t[id].l==l && t[id].r==r){
		t[id].hp+=val;t[id].tag2+=val;t[id].maxn+=val;
		t[id].maxh=max(t[id].maxh,t[id].maxn);
		return ;
	}
	int mid=(t[id].l+t[id].r)>>1;
	if(r<=mid) plus(id<<1,l,r,val);
	else if(l>mid) plus(id<<1|1,l,r,val);
	else{plus(id<<1,l,mid,val);plus(id<<1|1,mid+1,r,val);}
	pushup(id);
}
void change(int id,int l,int r,int val){
	pushdown(id);
	if(t[id].l==l && t[id].r==r){
		t[id].hc=t[id].tag1=t[id].maxn=val;
		t[id].maxh=max(t[id].maxh,t[id].maxn);
		return ;
	}
	int mid=(t[id].l+t[id].r)>>1;
	if(r<=mid) change(id<<1,l,r,val);
	else if(l>mid) change(id<<1|1,l,r,val);
	else{change(id<<1,l,mid,val);change(id<<1|1,mid+1,r,val);}
	pushup(id);
}
signed main(){
	scanf("%lld",&n);
	for(rnt i=1;i<=n;i=-~i) scanf("%lld",&d[i]);
	build(1,1,n);
	scanf("%lld",&m);
	for(rnt i=1;i<=m;i=-~i){
		scanf("\n%s%lld%lld",s,&x,&y);
		switch(s[0]){
			case 'Q':{
				printf("%lld\n",query(1,x,y));
				break;
			}
			case 'A':{
				printf("%lld\n",ask(1,x,y));
				break;
			}
			case 'P':{
				scanf("%lld",&z);
				plus(1,x,y,z);
				break;
			}
			case 'C':{
				scanf("%lld",&z);
				change(1,x,y,z);
				break;
			}
		}
	}
	return 0;
}
```

## 后记

毒瘤码风不喜勿喷！

[![](https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=2921431843,3149119026&fm=26&gp=0.jpg)](https://www.luogu.org/blog/oneJURUO/)

---

## 作者：little_sun (赞：3)

首先我们可以想到一个显而易见的思路：每个节点维护$\mathrm{add,set}$的$tag$,维护最大值$max$和历史最大值$Max$,然后像正常的线段树一样维护

然后你惊讶的发现你只拿到二十分（只有$Q$的部分分）

为什么呢？我们发现有些$tag$，他还没有来得及被更新就被覆盖了..而这些$tag$本来能~~改变世界~~更新答案

所以我们可以维护两个$tag$:$\mathrm{Add,Set}$表示该节点从上次下放到目前的最大$add$和$set$值

然后我们就可以快乐的用这些$tag$来维护答案了

`Code:`


``` cpp
#include <bits/stdc++.h>

#define R register
#define ll long long
#define sum(a, b, mod) ((a + b) % mod)
#define checkmax(a, b) ((a) = ((a) < (b)) ? (b) : (a))

const int MaxN = 1e5 + 10;
const int inf = 0x3f3f3f3f;

struct node
{
    int l, r;
    int Max, Add, Set;
    int max, add, set;
};

int n, m, a[MaxN];

struct SegmentTree
{
    node t[MaxN << 2];
    inline void pushup(int id)
    {
        t[id].max = std::max(t[id << 1].max, t[id << 1 | 1].max);
        t[id].Max = std::max(t[id << 1].Max, t[id << 1 | 1].Max);
    }
    inline void build(int id, int l, int r)
    {
        t[id].l = l, t[id].r = r, t[id].set = t[id].Set = -inf;
        if (l == r)
        {
            t[id].max = t[id].Max = a[(l + r) >> 1];
            return;
        }
        int mid = (l + r) >> 1;
        build(id << 1, l, mid);
        build(id << 1 | 1, mid + 1, r);
        pushup(id);
    }
    inline void checksum(int id, int add, int Add)
    {
        if (t[id].set != -inf)
        {
            checkmax(t[id].Set, t[id].set + Add);
            checkmax(t[id].Max, t[id].max + Add);
            t[id].set += add, t[id].max += add;
        }
        else
        {
            checkmax(t[id].Add, t[id].add + Add);
            checkmax(t[id].Max, t[id].max + Add);
            t[id].add += add, t[id].max += add;
        }
    }
    inline void checkset(int id, int set, int Set)
    {
        checkmax(t[id].Set, Set);
        checkmax(t[id].Max, Set);
        t[id].set = set, t[id].max = set;
    }
    inline void pushdown(int id)
    {
        checksum(id << 1, t[id].add, t[id].Add), checksum(id << 1 | 1, t[id].add, t[id].Add), t[id].add = t[id].Add = 0;
        if (t[id].set != -inf)
        {
            checkset(id << 1, t[id].set, t[id].Set), checkset(id << 1 | 1, t[id].set, t[id].Set);
            t[id].set = t[id].Set = -inf;
        }
    }
    void add(int id, int l, int r, int val)
    {
        if (t[id].l > r || t[id].r < l)
            return;
        if (l <= t[id].l && t[id].r <= r)
        {
            checksum(id, val, val);
            return;
        }
        pushdown(id), add(id << 1, l, r, val), add(id << 1 | 1, l, r, val), pushup(id);
    }
    void set(int id, int l, int r, int val)
    {
        if (t[id].l > r || t[id].r < l)
            return;
        if (l <= t[id].l && t[id].r <= r)
        {
            checkset(id, val, val);
            return;
        }
        pushdown(id), set(id << 1, l, r, val), set(id << 1 | 1, l, r, val), pushup(id);
    }
    int query_max(int id, int l, int r)
    {
        if (t[id].l > r || t[id].r < l)
            return -inf;
        if (l <= t[id].l && t[id].r <= r)
            return t[id].max;
        pushdown(id);
        return std::max(query_max(id << 1, l, r), query_max(id << 1 | 1, l, r));
    }
    int query_Max(int id, int l, int r)
    {
        if (t[id].l > r || t[id].r < l)
            return -inf;
        if (l <= t[id].l && t[id].r <= r)
            return t[id].Max;
        pushdown(id);
        return std::max(query_Max(id << 1, l, r), query_Max(id << 1 | 1, l, r));
    }
} T;

char get()
{
    char ch = getchar();
    while (ch > 'Z' || ch < 'A')
        ch = getchar();
    return ch;
}

inline int read()
{
    int x = 0, f = 1;
    char ch = getchar();
    while (ch > '9' || ch < '0')
    {
        if (ch == '-')
            f = 0;
        ch = getchar();
    }
    while (ch <= '9' && ch >= '0')
        x = (x << 1) + (x << 3) + (ch ^ 48), ch = getchar();
    return f ? x : (-x);
}

int main()
{
    scanf("%d", &n);
    for (int i = 1; i <= n; i++)
        scanf("%d", &a[i]);
    T.build(1, 1, n);
    scanf("%d", &m);
    while (m--)
    {
        char ch = get();
        int x = read(), y = read(), z;
        if (ch == 'Q')
            printf("%d\n", T.query_max(1, x, y));
        else if (ch == 'A')
            printf("%d\n", T.query_Max(1, x, y));
        else if (ch == 'P')
            z = read(), T.add(1, x, y, z);
        else
            z = read(), T.set(1, x, y, z);
    }
    return 0;
}

```

---

## 作者：i207M (赞：3)

**我i207M的线段树永不为奴！**

因为本人写线段树有一些奇怪的习惯，我的哲学是这样的：一个点有lazy标记，表示它自己的信息还没有被更新。通常的写法是“已经被更新，但子树未更新”

但是做这道题时，想搜一搜题解，发现都不是我的哲学，看不下去。于是只能硬着头皮自己琢磨，总算是写出来了，跑得还挺快。于是发一篇题解，看看有没有和我一样的线段树哲学玩家。

推荐大家写这道题时，先把不带A操作的写一遍，然后再添加A操作，~~不然Q都WA了A还怎么对~~

这样写有一个好处：一个节点只会有覆盖或加法中一种标记。

就专门说一下history操作吧：

hcg(history_change)：下放和普通change标记下放类似，直接更新。

had(history_add)：首先，我们要明白一个节点的history标记和正常标记是“并联”的，所以它们不会互相影响。

首先用had去更新hmx(history_max)，然后考虑下放：分多种情况：

1. 儿子的标记类型是覆盖：had不去更新儿子的had，否则时间错乱。用lcg(lazy_change)+had更新hcg。

2. 不然，就用lad(lazy_add)+had更新had。

------------------

代码就放几个例子吧，其他的都能仿写出来。

不开O2:2400ms；开O2:1000ms

```cpp
void up(int x)
{
	mx[x]=max(mx[ls],mx[rs]);
	hmx[x]=max(hmx[ls],hmx[rs]);
}
void build(int x,int l,int r)
{
	hcg[x]=lcg[x]=-inf;
	if(l==r)
	{
		hmx[x]=mx[x]=chu[l];
		return;
	}
	gm;
	build(ls,l,mid), build(rs,mid+1,r);
	up(x);
}
void down(int x)
{
	if(hcg[x]!=-inf)
	{
		hmx[x]=max(hcg[x],hmx[x]);
		if(rs<M)
		{
			hcg[ls]=max(hcg[x],hcg[ls]),hcg[rs]=max(hcg[x],hcg[rs]);
		}
		hcg[x]=-inf;
	}
	if(had[x])
	{
		hmx[x]=max(mx[x]+had[x],hmx[x]);
		if(rs<M)
		{
			if(lcg[ls]!=-inf) hcg[ls]=max(lcg[ls]+had[x],hcg[ls]);
			else had[ls]=max(lad[ls]+had[x],had[ls]);
			if(lcg[rs]!=-inf) hcg[rs]=max(lcg[rs]+had[x],hcg[rs]);
			else had[rs]=max(lad[rs]+had[x],had[rs]);
		}
		had[x]=0;
	}
	if(lcg[x]!=-inf)
	{
		mx[x]=lcg[x];
		if(rs<M)
		{
			lcg[ls]=lcg[rs]=lcg[x];
			lad[ls]=0,lad[rs]=0;
		}
		lcg[x]=-inf;
	}
	else if(lad[x])
	{
		mx[x]+=lad[x];
		if(rs<M)
		{
			if(lcg[ls]!=-inf) lcg[ls]+=lad[x],hcg[ls]=max(lcg[ls],hcg[ls]);
			else lad[ls]+=lad[x];
			if(lcg[rs]!=-inf) lcg[rs]+=lad[x],hcg[rs]=max(lcg[rs],hcg[rs]);
			else lad[rs]+=lad[x];
		}
		lad[x]=0;
	}
}
int askmax(int x,int l,int r,int ql,int qr)
{
	down(x);
	if(ql<=l&&r<=qr)
	{
		return mx[x];
	}
	gm; int res=-inf;
	if(ql<=mid) res=askmax(ls,l,mid,ql,qr);
	if(qr>mid) res=max(askmax(rs,mid+1,r,ql,qr),res);
	return res;
}
void add(int x,int l,int r,int ql,int qr,int k)
{
	down(x);
	if(ql<=l&&r<=qr)
	{
		lad[x]+=k;
		had[x]=max(lad[x],had[x]);
		down(x);
		return;
	}
	gm;
	if(ql<=mid) add(ls,l,mid,ql,qr,k);
	else down(ls);
	if(qr>mid) add(rs,mid+1,r,ql,qr,k);
	else down(rs);
	up(x);
}
```

----------------

友情赠送一种方法：

和 GXZlegend 的做法类似。想学习这种做法的可以去写UOJ#164

每个点维护的标记形如$(a,b)$，表示这个点的真实值是$max(x+a,b)$，这样加法就是$(val,-inf)$，覆盖就是$(-inf,val)$；

标记的合并：$(a,b)+(c,d)=(a+c,max(b+c,d))$（注意是有顺序的哦）

pushdown操作：

其中$bas=(0,-inf)$，就是空操作

```cpp
il int fit(const int &v) // 如果没有这个操作的话会爆int
{
	return max(min(v,inf),-inf);
}
struct Node
{
	int a,b;
	Node() {}
	Node(const int aa,const int bb)
	{
		a=aa,b=bb;
	}
	friend Node operator+(const Node &u,const Node &v)
	{
		return Node(fit(u.a+v.a),fit(max(u.b+v.a,v.b)));
	}
	il void upd(const Node &v)
	{
		a=max(v.a,a), b=max(v.b,b);
	}
	il int calc(int x)
	{
		return max(x+a,b);
	}
}
il void down(int x)
{
	if(his[x]!=bas)
	{
		hmx[x]=max(his[x].calc(mx[x]),hmx[x]);
		if(rs<M)
		{
			his[ls].upd(laz[ls]+his[x]);
			his[rs].upd(laz[rs]+his[x]);
		}
		his[x]=bas;
	}
	if(laz[x]!=bas)
	{
		mx[x]=laz[x].calc(mx[x]);
		if(rs<M)
		{
			laz[ls]=laz[ls]+laz[x];
			laz[rs]=laz[rs]+laz[x];
		}
		laz[x]=bas;
	}
}
```

---

## 作者：Light_Star_RPmax_AFO (赞：2)

# P4314 CPU 监控

### 前言

[P4314 CPU 监控](https://www.luogu.com.cn/problem/P4314)

[blog](https://www.luogu.com.cn/blog/JJL0610666/p4314-cpu-jian-kong)

没有了历史最大值就是模版题。

## 思路分析

首先思考在进行操作之后的 $ans$ 数组。

1. $\text{原数组}$
2. $\text{原数组} + \sum{\text{加操作}} $
3. $\text{赋值数组}$
4. $\text{赋值数组} + \sum{\text{赋值后加操作}}$

---

如何去维护呢?

考虑只有加操作怎么做，首先 `push_down`，将 $x$ 的 $tag$ 传递给 $son_x$，$ans \leftarrow last_{ans} + tag$ ，$maxn = \max{\{ans\}}$ 但是我们不可能去维护所有点的历史 **lazy tag** 所以需要取最值，那么结果就是

$max\_ans = \max\{last_{ans} + sum_i\} = last_{ans} + \max{\{sum_i\}}$

同理在维护赋值的时候也可以用 **lazy tag** ，如果赋值了则之前加操作全部清零。

---

~~别的不说了，管你听没听懂，看就完了~~ 。

# AC Code

```cpp
#include <bits/stdc++.h>
#define ls(u) (u << 1)
#define rs(u) ((u << 1) | 1)
using namespace std;

inline int read(){
	int x = 0, f = 1;
	char ch = getchar();
	while(!isdigit(ch)){
		if(ch == '-')f = -1;
		ch = getchar();
	}
	while(isdigit(ch)){
		x = (x << 1) + (x << 3) + (ch ^ 48);
		ch = getchar();
	}
	return x * f;
}
inline void print(int x){
	if(x < 0)x = -x, putchar('-');
	if(x > 9)print(x / 10);
	putchar(x % 10 + '0');
}

const int T = 1e5 + 5;
class ddd{
	public:
		int a[T], ans[T << 2], max_ans[T << 2], sum[T << 2], val[T << 2], max_sum[T << 2], max_val[T << 2];
		bool vis[T << 2];
		
		inline void build(int s, int t, int p){
			if(s == t){
				ans[p] = max_ans[p] = a[s];
				return ;
			}
			int mid = (s + t) >> 1;
			build(s, mid, ls(p));
			build(mid + 1, t, rs(p));
			push_up(p);
		}
		
		inline int query(int l, int r, int s, int t, int p){
			if(l <= s && t <= r)return ans[p];
			push_down(p);
			int mid = (s + t) >> 1, cnt = -0x7fffffff;
			if(l <= mid)cnt = query(l, r, s, mid, ls(p));
			if(mid < r)cnt = max(cnt, query(l, r, mid + 1, t, rs(p)));
			return cnt;
		}
		
		inline int query_max(int l, int r, int s, int t, int p){
			if(l <= s && t <= r)return max_ans[p];
			push_down(p);
			int mid = (s + t) >> 1, cnt = -0x7fffffff;
			if(l <= mid)cnt = query_max(l, r, s, mid, ls(p));
			if(mid < r)cnt = max(cnt, query_max(l, r, mid + 1, t, rs(p)));
			return cnt;
		}
		
		inline void add(int l, int r, int c, int s, int t, int p){
			if(l <= s && t <= r){
				updatesum(c, c, p);
				return ;
			}
			push_down(p);
			int mid = (s + t) >> 1;
			if(l <= mid)add(l, r, c, s, mid, ls(p));
			if(mid < r)add(l, r, c, mid + 1, t, rs(p));
			push_up(p); 
		}
		
		inline void change(int l, int r, int c, int s, int t, int p){
			if(l <= s && t <= r){
				updateval(c, c, p);
				return ;
			}
			push_down(p);
			int mid = (s + t) >> 1;
			if(l <= mid)change(l, r, c, s, mid, ls(p));
			if(mid < r)change(l, r, c, mid + 1, t, rs(p));
			push_up(p);
		}
	private:
		inline void push_up(int p){
			ans[p] = max(ans[ls(p)], ans[rs(p)]);
			max_ans[p] = max(max_ans[ls(p)], max_ans[rs(p)]);//push_down 用子节点更新叶节点 
		}
		
		inline void updatesum(int sums, int max_sums, int p){
			if(vis[p]){
				max_val[p] = max(max_val[p], val[p] + max_sums);
				val[p] += sums; 
			}else{
				max_sum[p] = max(max_sum[p], sum[p] + max_sums);
				sum[p] += sums;
			}
			max_ans[p] = max(max_ans[p], ans[p] + max_sums);
			ans[p] += sums;
		}
		
		inline void updateval(int vals, int max_vals, int p){
			if(vis[p]){
				max_val[p] = max(max_val[p], max_vals);
			}else{
				vis[p] = 1;
				max_val[p] = max_vals;
			}
			max_ans[p] = max(max_ans[p], max_vals); 
			ans[p] = val[p] = vals;
		}
		
		inline void push_down(int p){
			updatesum(sum[p], max_sum[p], ls(p)); 
			updatesum(sum[p], max_sum[p], rs(p));
			sum[p] = max_sum[p] = 0;
			if(vis[p]){
				updateval(val[p], max_val[p], ls(p));
				updateval(val[p], max_val[p], rs(p));
				vis[p] = 0;
				val[p] = max_val[p] = 0;
			}
		}
}u;
signed main(){
	int t = read();
	for(int i = 1;i <= t;i++)
		u.a[i] = read();
	u.build(1, t, 1); 
	int e = read();
	while(e--){
		char op;
		cin >> op;
		int x = read(), y = read();
		if(op == 'Q')
			print(u.query(x, y, 1, t, 1)), putchar('\n');
		else
			if(op == 'A')
				print(u.query_max(x, y, 1, t, 1)), putchar('\n');
			else
				if(op == 'P')
					u.add(x, y, read(), 1, t, 1);
				else
					u.change(x, y, read(), 1, t, 1);
	}
	return 0;
}

---

## 作者：WeLikeStudying (赞：2)

- 本题才是维护历史区间最大值的模板好吧。
- 批评某道二合一的令人发指的行为。

**题意**
- [题目链接](https://www.luogu.com.cn/problem/P4314)。
- 题意：维护数列使之支持区间加，区间覆盖，区间最大值查询，区间历史最大值查询。
- 如果没有后一个这就是一个简单的线段树。

**分析**
- 我们考虑可否用懒标记实现：在区间加的时候，被完整覆盖到的区间，其最大值的位置不改变，在区间覆盖的时候，被完整覆盖的区间，其最大值确定。
- 那么我们记录每个区间的最大值 $Mx$，历史最大值 $Hs$，加和懒标记 $Ad$，覆盖懒标记 $Cv$（这里还要加一个数组判断懒标记是否存在）。
- 那么上传合并自然好办，下传时应该也是类似的。
- 吗？
- 哈哈，这里是一个小坑啊，如果这样做的话，标记先增后减，那么下传的话儿子就没有更新啊。
- 所以真正正确的方法是连区间加和区间覆盖的大小也得记下在操作反复地重叠中出现的最大的那个（也就是历史标记）。
- 不过作者在学习到这里的时候不由得产生了一个疑问啊，在更新的时候不管三七二十一直接下传懒标记不就好了吗？
- emmm，仔细思考发现还是不行，因为每次下传一个的时候，整个子树都会下传，复杂度会徒增一个 $\log$（我可不想被卡爆）（传统的方法则可以将多余的操作搞一起）。

**实现细节**
- 同样的，区间覆盖对区间加也会有影响，作者采用的是优先进行区间加，其次进行区间覆盖的方法。
- 还有一个小问题，那就是区间加，区间覆盖，历史最大区间加，历史最大区间覆盖在闲置的（并没有操作）时候应该是什么样的？加和在闲置的时候显然应该是 $0$，但覆盖呢？我们可以给一个标记给它，在不用的时候将其置为 $-\infty$。
- [代码实现](https://www.luogu.com.cn/paste/4zleu418)。
- 作者 $1A$ 啦！

**总结**
- 懒标记需要仔细推敲，考虑任何操作之间的互相影响和重复操作的影响。

---

## 作者：Hadtsti (赞：1)

### 题意简述

给出长度为 $n(1\le n\le10^5)$ 的序列 $a_i$，再进行 $q(1\le q\le10^5)$ 次操作，每次操作是对给出的 $l,r$ 进行以下四种之一:

- 求 $a_l\sim a_r$ 的最大值。
- 求 $a_l\sim a_r$ 的历史最大值。
- 将 $a_l\sim a_r$ 全部加上给出的 $k$。
- 将 $a_l\sim a_r$ 全部改成给出的 $k$。

### 题目分析

这个题和吉司机线段树在同一篇论文里面，感觉挺好玩就一起看了看。

看到这个题想必很多人都想直接设置两个懒标记 $tag1$ 和 $tag2$ 表示每个结点维护区间加和区间赋值的情况，并在维护区间最大值的同时不断更新历史最大值，但这样有一个很明显的问题：一个结点在未下传标记时，其子结点的最大值没有及时算出来，所以其子结点的历史最大值也无法及时更新。

对于这一个问题，我们仍然可以采用懒标记解决。我们把着手点放在刚刚思路难以解决的，在相邻两次下传标记之间所更新的子结点的历史最大值的维护。不妨维护两次下传标记之间 $tag1$ 和 $tag2$ 的最大值 $maxtag1$ 和 $maxtag2$，这样下一次下传标记时，由于两次下传标记之间子结点维护的最大值 $Max$ 没有被更新（必须等到下传之后才更新），仍然是上一次下传标记所更新的值。那么所产生的可能的历史最大值只会是区间加得到的 $Max+maxtag1$ 或者区间赋值（如果没有区间赋值操作就没有这种情况）得到的 $maxtag2$。每次下传标记的同时，就如刚刚所说利用维护的信息更新一下历史最大值，清空标记后重新计算 $maxtag1$ 和 $maxtag2$ 即可。具体细节看代码理解。

### 代码实现
```
#include<bits/stdc++.h>
using namespace std;
int n,q,a[100010],l,r,x;
char op;
struct node
{
	int l,r;
	int mx,mxx;
	int tag1,tag2,mxtag1,mxtag2;
	bool flag;//表示有无区间赋值操作 
}tr[400010];
void rd(int &x)
{
	int f=1;
	x=0;
	char c=getchar();
	for(;c>'9'||c<'0';c=getchar())
		if(c=='-')
			f=-1;
	for(;c<='9'&&c>='0';c=getchar())
		x=(x<<3)+(x<<1)+c-'0';
	x*=f;
}
void rd(char &c)
{
	c=getchar();
	for(;c!='Q'&&c!='A'&&c!='P'&&c!='C';c=getchar());
}
void wt(int x)
{
	if(x<0)
	{
		putchar('-');
		x=-x;
	}
	if(x>=10)
		wt(x/10);
	putchar(x%10+'0');
}
void pushup(int p)
{
	tr[p].mx=max(tr[p<<1].mx,tr[p<<1|1].mx);
	tr[p].mxx=max(tr[p<<1].mxx,tr[p<<1|1].mxx);
}//子结点更新父节点 
void addtag1(int p,int tag,int mxtag)//区间加打标记 
{
	tr[p].mxx=max(tr[p].mxx,tr[p].mx+mxtag);
	tr[p].mx+=tag;
	if(tr[p].flag)//如果有区间赋值就把这次加的值加到 tag2 上 
	{
		tr[p].mxtag2=max(tr[p].mxtag2,tr[p].tag2+mxtag);//更新 tag2 最大值 
		tr[p].tag2+=tag;//一定要先更新最大值再更新 tag2！！我因此调了好久…… 
	}
	else
	{
		tr[p].mxtag1=max(tr[p].mxtag1,tr[p].tag1+mxtag);//没有区间赋值就直接加到 tag1 上。 
		tr[p].tag1+=tag;
	}
}
void addtag2(int p,int tag,int mxtag)//区间赋值打标记 
{	
	tr[p].tag2=tr[p].mx=tag;//直接赋值更新 
	tr[p].mxx=max(tr[p].mxx,mxtag);//更新历史最大值 
	if(tr[p].flag)
		tr[p].mxtag2=max(tr[p].mxtag2,mxtag);	//更新最大 tag2 
	else
	{
		tr[p].flag=1; 
		tr[p].mxtag2=mxtag;	//最开始的最大标记直接赋值为打标记的值 
	}	
}
void pushdown(int p)
{
	addtag1(p<<1,tr[p].tag1,tr[p].mxtag1);//先下传更新区间加（区间赋值优先级更高，区间加完了之后也会被全部赋值） 
	addtag1(p<<1|1,tr[p].tag1,tr[p].mxtag1);
	tr[p].tag1=tr[p].mxtag1=0;//清空标记 
	if(tr[p].flag)
	{
		addtag2(p<<1,tr[p].tag2,tr[p].mxtag2);//后下传更新区间赋值 
		addtag2(p<<1|1,tr[p].tag2,tr[p].mxtag2);
		tr[p].flag=0;
		tr[p].tag2=tr[p].mxtag2=0;//清空标记 
	}
}//下传标记 
void build(int p,int l,int r)//建树 
{
	tr[p].l=l,tr[p].r=r;
	if(l==r)
	{
		tr[p].mx=tr[p].mxx=a[l];//最大值和历史最大值初始都是 a_l 
		return;
	}
	int mid=l+r>>1;
	build(p<<1,l,mid);//左子结点 
	build(p<<1|1,mid+1,r);//右子结点 
	pushup(p);
}
void change1(int p,int l,int r,int x)//区间加 
{
	if(tr[p].l>=l&&tr[p].r<=r)
	{
		addtag1(p,x,x);//修改的话历史最大值也取更改的值就好了 
		return;
	}
	pushdown(p);
	int mid=tr[p].l+tr[p].r>>1;
	if(mid>=l)
		change1(p<<1,l,r,x);
	if(mid<r)
		change1(p<<1|1,l,r,x);
	pushup(p);
}
void change2(int p,int l,int r,int x)//区间赋值 
{
	if(tr[p].l>=l&&tr[p].r<=r)
	{
		addtag2(p,x,x);//同上 
		return;
	}
	pushdown(p);
	int mid=tr[p].l+tr[p].r>>1;
	if(mid>=l)
		change2(p<<1,l,r,x);
	if(mid<r)
		change2(p<<1|1,l,r,x);
	pushup(p);
}
int query1(int p,int l,int r)//查询最大值 
{
	if(tr[p].l>=l&&tr[p].r<=r)
		return tr[p].mx;
	pushdown(p);
	int mid=tr[p].l+tr[p].r>>1,res=INT_MIN;
	if(mid>=l)
		res=query1(p<<1,l,r);
	if(mid<r)
		res=max(res,query1(p<<1|1,l,r));
	return res;
}
int query2(int p,int l,int r)//查询历史最大值 
{
	if(tr[p].l>=l&&tr[p].r<=r)
		return tr[p].mxx;
	pushdown(p);
	int mid=tr[p].l+tr[p].r>>1,res=INT_MIN;
	if(mid>=l)
		res=query2(p<<1,l,r);
	if(mid<r)
		res=max(res,query2(p<<1|1,l,r));
	return res;
}
int main()
{
	rd(n);
	for(int i=1;i<=n;i++)
		rd(a[i]);
	build(1,1,n);
	rd(q);
	while(q--)
	{
		rd(op),rd(l),rd(r);
		switch(op)
		{
			case 'Q':
				wt(query1(1,l,r)),putchar('\n');
				break;
			case 'A':
				wt(query2(1,l,r)),putchar('\n');
				break;
			case 'P':
				rd(x);
				change1(1,l,r,x);
				break;
			case 'C':
				rd(x);
				change2(1,l,r,x);
		}
	}
	return 0;
}
```

---


# 变化的道路

## 题目描述

小 w 和小 c 在 H 国，近年来，随着 H 国的发展，H 国的道路也在不断变化着

根据 H 国的道路法，H 国道路都有一个值 $w$，表示如果小 w 和小 c 通过这条道路，那么他们的 L 值会减少 $w$，但是如果小 w 和
小 c 在之前已经经过了这条路，那么他们的 L 值不会减少

H 国有 $N$ 个国家，最开始 H 国有 $N-1$ 条道路，这 $N-1$ 条道路刚好构成一棵树

小 w 将和小 c 从 H 国的城市 1 出发，游览 H 国的所有城市，总共游览 32766 天，对于每一天，他们都希望游览结束后 L 值还是一个正数，
那么他们出发时 L 值至少为多少

H 国的所有边都是无向边，没有一条道路连接相同的一个城市

## 说明/提示

第一天，选择 1 -(1)> 2 -(0)> 1 -(3)> 3 -(2)> 4，L 值总共减少了 6，所以 L 值至少为 7

第二天，选择 1 -(1)> 2 -(0)> 1 -(3)> 3 -(4)> 4，L 值总共减少了 8，所以 L 值至少为 9

第三天及之后，选择 1 -(3)> 3 -(4)> 4 -(5)> 2，L 值总共减少了 12，所以 L 值至少为 13

subtask1 : 15分，$N = 100, rm = 233$

subtask2 : 15分，$N = 1000, rm = 2333$

subtask3 : 20分，$N = 49998, rm = 32766, l = r$

subtask4：20分，$N = 49999, rm = 32766, r = rm$

subtask5：30分，$N = 50000, rm = 32766$

对于subtask3 : $M = rm$，对于其他subtask：$M=3\times rm$

对于所有数据 : $1\leq N\leq 50000, 1\leq l\leq r\leq rm\leq 32766, 1\leq w\leq 10^9$

## 样例 #1

### 输入

```
4
1 3 3
3 4 4
2 4 5
3
1 2 1 1 2
2 3 8 2 3
3 4 2 1 1```

### 输出

```
7
9
13
由于版面原因，仅显示三行，接下来32763行都是13```

# 题解

## 作者：NaCly_Fish (赞：9)

### 解法：线段树分治 + LCT维护MST

~~好了现在赶紧自己试着写一个~~  

算是一道比较经典的线段树分治模型？(雾)  

题目说了每条边只在一个时间段中出现，那么就可以按时间建一个线段树，把这些边放到线段树中，显然最终线段树中只会有 $\text O (n \log n)$ 条边。

加完边之后就可以左右递归分治了，每走到一个节点，就把上面标记的边都加到 LCT 上，注意回溯的时候也要把这些边断掉。

每次走到叶节点，直接输出当前 LCT 中的边权和就是答案。

其中，加边的过程和普通的 LCT 维护 MST 做法一样，加边时找出连接这两点路径上权最大的边，把它断掉，再把现在这条边连上去。  

当然这个过程中断掉的边，回溯的时候也要再连上。  
可以证明，不会出现不合法的连/断边

大概就是这样了，时间复杂度为 $\text O (n \log^2 n)$。  

ps：不知道这个能不能叫“可回退化 LCT”？

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<vector>
#define N 200003
#define reg register
#define ll long long
#define ls son[u][0]
#define rs son[u][1]
#define mid ((l+r)>>1)
using namespace std;

struct edge{
    int u,v,w;
    inline edge(int u=0,int v=0,int w=0):u(u),v(v),w(w){}
}ed[N];

int a[N],st[N];
vector<int> adj[N*3];
int n,m;

inline void read(int &x){
    x = 0;
    char c = getchar();
    while(c<'0'||c>'9') c = getchar();
    while(c>='0'&&c<='9'){
        x = (x<<3)+(x<<1)+(c^48);
        c = getchar();
    }
}

struct Link_Cut_Tree{ //板子,没什么好说的
    int rev[N],pos[N],fa[N],son[N][2];

    inline void pushup(int u){
        pos[u] = u;
        if(ls&&a[pos[ls]]>a[pos[u]]) pos[u] = pos[ls];
        if(rs&&a[pos[rs]]>a[pos[u]]) pos[u] = pos[rs];
    }   

    inline void pushr(int u){
        swap(ls,rs);
        rev[u] ^= 1;
    }

    inline void pushdown(int u){
        if(!rev[u]) return;
        if(ls) pushr(ls);
        if(rs) pushr(rs);
        rev[u] = 0;
    }

    inline bool notrt(int u){
        return son[fa[u]][0]==u||son[fa[u]][1]==u;
    }

    inline void rotate(int x){
        int y = fa[x],z = fa[y];
        int k = son[y][1]==x,w = son[x][k^1];
        if(notrt(y)) son[z][son[z][1]==y] = x;
        son[x][k^1] = y;
        son[y][k] = w;
        if(w) fa[w] = y;
        fa[y] = x,fa[x] = z;
        pushup(y);
    }

    inline void splay(int x){
        reg int y = x,z = 0;
        st[++z] = y;
        while(notrt(y)) st[++z] = y = fa[y];
        while(z) pushdown(st[z--]);
        while(notrt(x)){
            y = fa[x],z = fa[y];
            if(notrt(y))
                rotate((son[z][1]==y)==(son[y][1]==x)?y:x);
            rotate(x);  
        }
        pushup(x);
    }

    inline void access(int u){
        for(reg int v=0;u;u=fa[u]){
            splay(u),rs = v;
            pushup(u),v = u;
        }
    }

    inline void makeroot(int u){
        access(u),splay(u);
        pushr(u);
    }

    inline void split(int u,int v){
        makeroot(u);
        access(v),splay(v);
    }

    inline void link(int u,int v){
        makeroot(u);
        fa[u] = v;
    }

    inline void cut(int u,int v){
        split(u,v);
        son[v][0] = fa[u] = 0;
        pushup(v);
    }

    inline int query(int u,int v){
        split(u,v);
        return pos[v];
    }

    inline int findroot(int u){
        access(u),splay(u);
        pushdown(u);
        while(ls){
            u = ls;
            pushdown(u);
        }
        splay(u);
        return u;
    }

    inline bool linked(int u,int v){
        makeroot(u);
        return findroot(v)==u;
    }
}T;

const int lim = 32766;
int s1[N],s2[N]; //这是两个栈,记录边和它的状态 删除/添加
int top,cnt;
ll ans = 1; //答案要 +1

void insert(int nl,int nr,int l,int r,int u,int k){
    if(nl<=l&&r<=nr){ //加入一条边,注意这个线段树不用也不能下传标记
        adj[u].push_back(k);
        return; 
    }
    if(nl<=mid) insert(nl,nr,l,mid,u<<1,k);
    if(nr>mid) insert(nl,nr,mid+1,r,u<<1|1,k);
}

void solve(int l,int r,int x){
    int d,u,v,w,j,lst = top,ln = adj[x].size();
    for(reg int i=0;i<ln;++i){
        j = adj[x][i];
        u = ed[j].u,v = ed[j].v;
        w = ed[j].w;
        if(T.linked(u,v)){
            d = T.query(u,v)-n;
            if(ed[d].w<=w) continue; //当前边权比路径上最大的还大,就不用加进去
            ans -= ed[d].w;
            T.cut(ed[d].u,d+n),T.cut(ed[d].v,d+n); 
			s1[++top] = d; 
			s2[top] = -1;
        } 
        T.link(u,n+j),T.link(n+j,v);
        s1[++top] = j;
        s2[top] = 1;
        ans += w;
    }
    if(l==r) printf("%lld\n",ans);
	else{
		solve(l,mid,x<<1);
		solve(mid+1,r,x<<1|1);
	}
	while(top>lst){ //回溯
		d = s1[top];
		u = ed[d].u,v = ed[d].v;
		w = ed[d].w;
		if(s2[top]==-1){
			T.link(u,d+n),T.link(v,d+n);
			ans += w;
		}else{
			T.cut(u,d+n),T.cut(v,d+n);
			ans -= w;
		}
		--top;
	}
}
	
int main(){
    int l,r,u,v,w;
    read(n);
    for(reg int i=1;i<n;++i){
        read(u),read(v),read(w);
        ed[++cnt] = edge(u,v,w);
        a[n+cnt] = w;
        insert(1,lim,1,lim,1,cnt);
    }
    read(m);
    for(reg int i=1;i<=m;++i){
        read(u),read(v),read(w),read(l),read(r);
        ed[++cnt] = edge(u,v,w);
        a[n+cnt] = w;
        insert(l,r,1,lim,1,cnt);
    }
    solve(1,lim,1);
    return 0;
}
```

---

## 作者：Kelin (赞：9)

## [题意](https://blog.csdn.net/BeNoble_/article/details/79800336)

一开始给你一棵树,再给你一些边,这些边都有一个存在时间段

$\forall i\in[1,32766]$求$i$时刻的$MST$边权和$+1$

---

## 题解

动态加边删边维护$MST$

只有加边操作比较好写,如[[WC2006]水管局长](https://www.luogu.org/problemnew/show/P4172)

维护最大边的位置即可

考虑删边怎么做$?$~~可持久化LCT?~~

考虑对时间建立一颗线段树,然后对时间分治,

那么一条边最多会加到$\log n$个区间

所以我们可以对于一个线段树区间我们暴力把属于这个区间的边连上

等把子树递归完后再暴力倒序删除刚刚连上的边

因为一条边最多会加到$\log n$个区间,所以复杂度是有保障的

加边删边可以通过$LCT$实现,复杂度$O(n\log^2n)$

其实这个代码还可以继续卡常的~~窝懒,所以就算了~~
```
#include<bits/stdc++.h>
#define fp(i,a,b) for(register int i=a,I=b+1;i<I;++i)
#define fd(i,a,b) for(register int i=a,I=b-1;i>I;--i)
#define go(u) for(register int i=fi[u],v=e[i].to;i;v=e[i=e[i].nx].to)
#define file(s) freopen(s".in","r",stdin),freopen(s".out","w",stdout)
template<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}
template<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}
using namespace std;
char ss[1<<17],*A=ss,*B=ss;
inline char gc(){return A==B&&(B=(A=ss)+fread(ss,1,1<<17,stdin),A==B)?-1:*A++;}
template<class T>inline void sd(T&x){
    char c;T y=1;while(c=gc(),(c<48||57<c)&&c!=-1)if(c==45)y=-1;x=c-48;
    while(c=gc(),47<c&&c<58)x=x*10+c-48;x*=y;
}
char sr[1<<21],z[20];int C=-1,Z;
inline void Ot(){fwrite(sr,1,C+1,stdout),C=-1;}
template<class T>inline void we(T x){
    if(C>1<<20)Ot();if(x<0)sr[++C]=45,x=-x;
    while(z[++Z]=x%10+48,x/=10);
    while(sr[++C]=z[Z],--Z);sr[++C]='\n';
}
const int N=2e5+5,M=32766;
typedef int arr[N];
typedef long long ll;
struct eg{int u,v,w;inline void in(){sd(u),sd(v),sd(w);}}e[N];
int n,m,ce;ll ans=1;vector<int>G[N];
struct LCT{
    int top,ch[N][2];arr w,mx,fa,rev,S;
    #define lc(u)(ch[u][0])
    #define rc(u)(ch[u][1])
    inline bool gf(int u){return lc(fa[u])^u;}
    inline bool ir(int u){return lc(fa[u])^u&&rc(fa[u])^u;}
    inline int cmp(int a,int b){return w[a]>w[b]?a:b;}
    inline void up(int u){mx[u]=u;mx[u]=cmp(mx[u],mx[lc(u)]),mx[u]=cmp(mx[u],mx[rc(u)]);}
    inline void down(int u){
        swap(lc(u),rc(u));rev[u]=0;
        rev[lc(u)]^=1,rev[rc(u)]^=1;
    }
    inline void rot(int u){
        int p=fa[u],k=gf(u);
        if(!ir(p))ch[fa[p]][gf(p)]=u;
        if(ch[u][!k])fa[ch[u][!k]]=p;
        ch[p][k]=ch[u][!k],ch[u][!k]=p;
        fa[u]=fa[p],fa[p]=u,up(p);
    }
    void splay(int u){
        S[top=1]=u;
        for(int i=u;!ir(i);i=fa[i])S[++top]=fa[i];
        fd(i,top,1)if(rev[S[i]])down(S[i]);
        for(int f=fa[u];!ir(u);rot(u),f=fa[u])
            if(!ir(f))rot(gf(u)==gf(f)?f:u);
        up(u);
    }
    inline void acc(int u){for(int v=0;u;u=fa[v=u])splay(u),ch[u][1]=v,up(u);}
    inline void mkrt(int u){acc(u);splay(u);rev[u]^=1;}
    inline void close(int u,int v){mkrt(u),acc(v),splay(v);}
    inline void link(int u,int v){mkrt(u),fa[u]=v;}
    inline void cut(int u,int v){close(u,v),fa[u]=ch[v][0]=0;}
    inline int qry(int u,int v){return close(u,v),mx[v];}
    #undef lc
    #undef rc
}t;
#define lc p<<1,L,mid
#define rc p<<1|1,mid+1,R
void mdy(int p,int L,int R,int a,int b,int x){
    if(a<=L&&R<=b)return G[p].push_back(x),void();
    int mid=(L+R)>>1;
    if(a<=mid)mdy(lc,a,b,x);
    if(b>mid)mdy(rc,a,b,x);
}
#define mp make_pair
#define pi pair<int,bool>
void calc(int p,int L,int R){
    stack<pi>s;
    int u,v,w,x,mid=(L+R)>>1;
    for(int i:G[p]){
        u=e[i].u,v=e[i].v,w=e[i].w;x=t.qry(u,v);
        if(w>=t.w[x])continue;ans-=t.w[x]-w;
        t.cut(u,x),t.cut(v,x),s.push(mp(x,0));
        t.link(u,i),t.link(v,i),s.push(mp(i,1));
    }
    if(L==R)we(ans);else calc(lc),calc(rc);
    while(!s.empty()){
        pi nw=s.top();s.pop();x=nw.first;
        if(nw.second)t.cut(e[x].u,x),t.cut(e[x].v,x),ans-=e[x].w;
        else t.link(e[x].u,x),t.link(e[x].v,x),ans+=e[x].w;
    }
}
int main(){
    #ifndef ONLINE_JUDGE
        file("s");
    #endif
    sd(n);ce=n;int l,r;
    fp(i,2,n)e[++ce].in(),ans+=(t.w[ce]=e[ce].w),t.link(e[ce].u,ce),t.link(e[ce].v,ce);	
    sd(m);
    while(m--)e[++ce].in(),sd(l),sd(r),mdy(1,1,M,l,r,ce),t.w[ce]=e[ce].w;
    calc(1,1,M);
return Ot(),0;
}
```

---

## 作者：Hoks (赞：3)

## 前言
LCT 题单里的，刚好我的[总结文章](https://www.luogu.com.cn/blog/Hok/cute-tree-decomposition)里把这题当做了练习题，就写篇题解吧。

## 题意分析
题意：

> 询问在第 $i$ 天的可用边的 MST 的边权和。

首先看到 MST，以及边会变为可用/不可用状态。

优先考虑下动态 MST。

动态 MST 就不讲了，详情可以见我[总结文章](https://www.luogu.com.cn/blog/Hok/post-zong-ru-men-dao-ru-tu-shu-lian-pou-fen)中的『6.1.1.』。

然后因为一条边是在一个连续的时间范围中可用/不可用，所以我们可以考虑使用线段树分治弄出来时间范围。

每走到一个节点，就把上面标记的边都加到 LCT 上，注意回溯的时候也要把这些边断掉。

走到叶子节点的时候就是时间为一个点的时候，记录下答案。

然后用 LCT 动态维护 MST 即可。
## 代码
```cpp
#include <bits/stdc++.h>
#define ls son[x][0]
#define rs son[x][1]
#define tls (x<<1)
#define trs (x<<1|1)
#define mid ((l+r)>>1)
#define int long long
using namespace std;
const int N=50010,mod=1e9+7,INF=0x3f3f3f3f3f3f3f3f,M=200010,S=N+M,lim=32766;
struct edge{int u,v,w;}e[M];
int n,m,ans=1,tot,tp;
int f[S],s[S],son[S][2],st[S],w[S],r[S],mp[S],s1[S],s2[S];
vector<int>g[S<<2];
static char buf[1000000],*paa=buf,*pd=buf;
#define getchar() paa==pd&&(pd=(paa=buf)+fread(buf,1,1000000,stdin),paa==pd)?EOF:*paa++
inline int read(void){
    int u(0),t(1);char fc(getchar());
    while(!isdigit(fc)){if(fc=='-') t=-1;fc=getchar();}
    while(isdigit(fc)) u=(u<<1)+(u<<3)+(fc^48),fc=getchar();
    return u*t;
}
inline void print(int u)
{
	if(u<0) putchar('-'),u=-u;
	if(u>9) print(u/10);
	putchar(u%10+'0');
}
inline int ksm(int a,int b,int mod)
{
	int u=a%mod,res=1;
	while(b)
	{
		if(b&1) res=res*u%mod;
		b>>=1;u=u*u%mod;
	}
	return res;
}
bool cmp(edge x,edge y){return x.w<y.w;}
bool ntrt(int x){return son[f[x]][1]==x||son[f[x]][0]==x;}
void pushup(int x)
{
	s[x]=x;
	if(w[s[ls]]>w[s[x]]) s[x]=s[ls];
    if(w[s[rs]]>w[s[x]]) s[x]=s[rs];
}
void pushson(int x){swap(ls,rs),r[x]^=1;}
void pushdown(int x)
{
	if(r[x])
	{
		if(ls) pushson(ls);
		if(rs) pushson(rs);
		r[x]=0;
	}
}
void rotate(int x)
{
	int y=f[x],z=f[y],k=(son[y][1]==x),w=son[x][!k];
	if(ntrt(y)) son[z][son[z][1]==y]=x;son[x][!k]=y;son[y][k]=w;
	if(w) f[w]=y;f[y]=x;f[x]=z;
	pushup(y);
}
void Splay(int x)
{
	int y=x,tot=0;st[++tot]=y;
	while(ntrt(y)) st[++tot]=y=f[y];
	while(tot) pushdown(st[tot--]);
	while(ntrt(x))
	{
		y=f[x];int z=f[y];
		if(ntrt(y)) rotate((son[y][0]==x)^(son[z][0]==y)?x:y);
		rotate(x);
	}
	pushup(x);
}
void access(int x){for(int y=0;x;x=f[y=x]) Splay(x),rs=y,pushup(x);}
void makert(int x){access(x);Splay(x);pushson(x);}
int findrt(int x)
{
	access(x);Splay(x);
	while(ls) pushdown(x),x=ls;
	Splay(x);return x;
}
int split(int x,int y){makert(x);access(y);Splay(y);return s[y];}
void link(int x,int y){makert(x);if(findrt(y)!=x)f[x]=y;}
void cut(int x,int y)
{
	makert(x);
	if(findrt(y)==x&&f[y]==x&&!son[y][0]) f[y]=son[x][1]=0,pushup(x);
}
bool check(int x, int y){makert(x);return findrt(y)==x;}
void modify(int u,int l,int r,int nl,int nr,int k)
{
    if(nl<=l&&r<=nr){g[u].push_back(k);return;}
    if(nl<=mid) modify(u<<1,l,mid,nl,nr,k);
    if(nr>mid) modify(u<<1|1,mid+1,r,nl,nr,k);
}
void solve(int l,int r,int x)
{
    int u,v,w,d,lst=tp;
    for(auto j:g[x])
	{
        u=e[j].u,v=e[j].v,w=e[j].w;
        if(check(u,v))
		{
            d=split(u,v)-n;if(e[d].w<=w) continue;
            ans-=e[d].w;cut(e[d].u,d+n),cut(e[d].v,d+n); 
			s1[++tp]=d,s2[tp]=-1;
        } 
        link(u,n+j),link(n+j,v);
        s1[++tp]=j,s2[tp]=1,ans+=w;
    }
    if(l==r) print(ans),puts("");
	else solve(l,mid,x<<1),solve(mid+1,r,x<<1|1);
	while(tp>lst)
	{
		d=s1[tp],u=e[d].u,v=e[d].v,w=e[d].w;
		if(s2[tp]==-1) link(u,d+n),link(v,d+n),ans+=w;
		else cut(u,d+n),cut(v,d+n),ans-=w;tp--;
	}
}
signed main()
{
	n=read();
	for(int i=1,u,v,ww;i<n;i++) u=read(),v=read(),ww=read(),e[++tot]=(edge){u,v,ww},w[n+tot]=ww,modify(1,1,lim,1,lim,tot); 
	m=read();for(int i=1,u,v,ww,l,r;i<=m;i++)
	{
		u=read(),v=read(),ww=read(),l=read(),r=read();
		e[++tot]=(edge){u,v,ww},w[n+tot]=ww,modify(1,1,lim,l,r,tot);
	}solve(1,lim,1);
	return 0;
}
```


---

## 作者：Genius_Z (赞：2)

[$\large\color{blue}\text{Blog}$](https://www.luogu.org/blog/zi-o/#)

动态维护加边删边的最小生成树。

这种问题我们普遍考虑用$LCT$解决，当如果只有时间或权值一个维度时，可以只用$LCT$，但现在两个都要维护，就要考虑套点什么东西了，显然时间一维我们可以通过线段树分治来维护，把每条边的存在时间看做区间（这题直接给出来了）。

这题非常无聊的地方就在于要输出$32766$行（一开始没有看到$wa$了很多次），还有就是答案要开$\text{long long}$，别的就没什么了。

这里主要讲一下撤销每次分治完的影响，由于线段树分治可以看做是广义的$CDQ$分治，所以做法是差不多的，每次到这个区间就加入当前区间的边，回溯的时候再撤销掉，然而重点在这个撤销上，加入是常规操作，不会的去看看[这题](https://www.luogu.org/problemnew/show/P4172)。

我们开一个栈记录每次操作的边，不管是被$link$的还是被$cut$的，给不同操作的边在栈里记录操作类型，每次进入一个线段树上的节点时要记录当前的$top$，撤销的时候撤到这里就停下，然后撤销时做相反的操作就很显然了，只要稍微注意就不会写错了，有（会）兴（卡）趣（常）的话可以看看[这一题](https://www.luogu.org/problemnew/show/P3206)，思路基本相同，但是给边方式不一样，常数大的只能得到80分。

最后是代码

Code：

```cpp
#include <set>
#include <map>
#include <cmath>
#include <queue>
#include <stack>
#include <bitset>
#include <cstdio>
#include <vector>
#include <cstdlib>
#include <cstring>
#include <ctime>
#include <iostream>
#include <algorithm>
#include <unordered_map>
#define inl inline
#define re register int
#define fa(x) t[x].fa
#define son(x,y) t[x].child[y]
#define ls(x) t[x].child[0]
#define rs(x) t[x].child[1]
#define ll long long
const int inf = 0x3f3f3f3f;
#define lowbit(x) ((x) & (-x))
using namespace std;
#ifndef _DEBUG
#define getchar() (*(IOB.in.p++))
#define putchar(c) (*(IOB.out.p++)=(c))
#define io_eof() (IOB.in.p>=IOB.in.pend)
struct IOBUF { struct { char buff[1 << 26], *p, *pend; }in; struct { char buff[1 << 26], *p; }out; IOBUF() { in.p = in.buff; out.p = out.buff; in.pend = in.buff + fread(in.buff, 1, 1 << 26, stdin); }~IOBUF() { fwrite(out.buff, 1, out.p - out.buff, stdout); } }IOB;
#endif
template<typename IO>
inl void write(IO x) {
	if (x == 0) return (void)putchar('0');
	if (x < 0)putchar('-'), x = -x;
	static char buf[30];
	char* p = buf;
	while (x) {
		*(p++) = x % 10 + '0';
		x /= 10;
	}
	while (p > buf)putchar(*(--p));
}
inl void writestr(const char *s) { while (*s != 0)putchar(*(s++)); }
template<typename IO>inl void writeln(IO x) { write(x), putchar('\n'); }
template<typename IO>inl void writesp(IO x) { write(x), putchar(' '); }
inl int readstr(char *s) {
	char *begin = s, c = getchar();
	while (c < 33 || c>127) {
		c = getchar();
	}
	while (c >= 33 && c <= 127) {
		*(s++) = c;
		c = getchar();
	}
	*s = 0;
	return s - begin;
}
template<typename IO>
inl IO read() {
	IO x = 0;
	register bool w = 0;
	register char c = getchar();
	while (c > '9' || c < '0') {
		if (c == '-') w = 1;
		c = getchar();
	}
	while (c >= '0' && c <= '9') {
		x = (x << 3) + (x << 1) + (c ^ 48);
		c = getchar();
	}
	return w ? -x : x;
}
int n, m, tot;
struct node {
	int fa, child[2], max, w;
	bool filp;
}t[500001];
inl void maintain(int x) {
	t[x].max = 0;
	if (x > n)t[x].max = x;
	if (t[t[ls(x)].max].w > t[x].w)t[x].max = t[ls(x)].max;
	if (t[t[rs(x)].max].w > t[t[x].max].w)t[x].max = t[rs(x)].max;
}
inl bool poi(int x) {
	return rs(fa(x)) == x;
}
inl bool nroot(int x) {
	return ls(fa(x)) == x || rs(fa(x)) == x;
}
inl void rotate(int x) {
	re f = fa(x), gf = fa(f), fs = poi(x), gfs = poi(f), s = son(x, fs ^ 1);
	if (nroot(f))son(gf, gfs) = x;
	son(x, fs ^ 1) = f, son(f, fs) = s;
	if (s)fa(s) = f; fa(f) = x, fa(x) = gf, maintain(f);
}
inl void reverse(int x) {
	swap(ls(x), rs(x)), t[x].filp ^= 1;
}
inl void pushdown(int x) {
	if (t[x].filp) {
		if (ls(x))reverse(ls(x));
		if (rs(x))reverse(rs(x));
		t[x].filp = 0;
	}
}
inl void push(int x) {
	if (nroot(x))push(fa(x));
	pushdown(x);
}
inl void splay(int x) {
	push(x);
	while (nroot(x)) {
		if (nroot(fa(x)))poi(x) == poi(fa(x)) ? rotate(fa(x)) : rotate(x);
		rotate(x);
	}
	maintain(x);
}
inl void access(int x) {
	for (re i = 0; x; x = fa(i = x)) {
		splay(x), rs(x) = i, maintain(x);
	}
}
inl void makeroot(int x) {
	access(x), splay(x), reverse(x);
}
inl void split(int x, int y) {
	makeroot(y), access(x), splay(x);
}
inl void link(int x, int y) {
	split(x, y), fa(y) = x;
}
inl void cut(int x, int y) {
	split(x, y), fa(y) = ls(x) = 0, maintain(x);
}
inl int findroot(int x) {
	access(x), splay(x), pushdown(x);
	while (ls(x))pushdown(x = ls(x));
	splay(x);
	return x;
}
struct edge {
	int u, v, w;
}e[500001];
vector<int>ve[400001];
int st[1000001][2], top;
ll ans = 1, lastans;
inl void insert(int k, int l, int r, int x, int y, int i) {
	if (l >= x && r <= y) {
		ve[k].push_back(i);
		return;
	}
	re mid = l + r >> 1;
	if (x <= mid)insert(k << 1, l, mid, x, y, i);
	if (y > mid)insert(k << 1 | 1, mid + 1, r, x, y, i);
}
inl void divide(int k, int l, int r) {
	re u, v, w, ltop = top;
	for (auto i : ve[k]) {
		u = e[i].u, v = e[i].v, w = e[i].w;
		makeroot(u);
		if (findroot(v) == u) {
			re now = t[u].max;
			ll d = t[now].w;
			if (w >= d)continue;
			cut(e[now - n].u, now), cut(e[now - n].v, now);
			ans -= d, st[++top][0] = now - n, st[top][1] = 1;
		}
		ans += w, st[++top][0] = i, st[top][1] = -1;
		link(u, i + n), link(v, i + n);
	}
	re mid = l + r >> 1;
	if (l == r) writeln(ans);
	else divide(k << 1, l, mid), divide(k << 1 | 1, mid + 1, r);
	while (top > ltop) {
		re now = st[top][0];
		if (~st[top][1]) {
			link(e[now].u, now + n), link(e[now].v, now + n), ans += e[now].w;
		}
		else {
			cut(e[now].u, now + n), cut(e[now].v, now + n), ans -= e[now].w;
		}
		top--;
	}
}
signed main() {
	n = read<int>();
	for (re i = 1, x, y, w; i < n; i++) {
		x = read<int>(), y = read<int>(), w = read<int>();
		e[++tot] = edge{ x,y,w }, t[n + tot].w = w;
		insert(1, 1, 32766, 1, 32766, tot);
	}
	m = read<int>();
	for (re i = 1, x, y, w, st, ed; i <= m; i++) {
		x = read<int>(), y = read<int>(), w = read<int>(), st = read<int>(), ed = read<int>();
		e[++tot] = edge{ x,y,w };
		t[n + tot].w = w;
		insert(1, 1, 32766, st, ed, tot);
	}
	divide(1, 1, 32766);
}
```



---

## 作者：Z1qqurat (赞：1)

思路简单全是套路但是写起来史杉题。首先相当于求一个最小生成树的权值，但是每条边有一个出现的时间。哎呦动态维护 MST 我会写 LCT，但是 LCT 只能加边不太支持撤销。咋整？每条边一个出现的时间段，我线段树分治先。所以说是线段树分治套 LCT。

* LCT 咋动态维护 MST 的？容易想到如果我们加入一条边 $(u, v, w)$，如果 $u, v$ 在一个环上，找出目前 MST 上 $u, v$ 路径上最大的边 $(mu, mv, mw)$，如果 $w < mw$ 就把 $(mu, mv)$ 断开连上 $(u, v)$。问题来了，怎么维护路径上最大边？如果你会 LCT 的话你发现 ```makepath(u, v)``` 一下那么 $u, v$ 路径上最大边就变成了 $v$ 子树内最大边。子树内最大边怎么维护？LCT 不好维护边的信息，我们**化边为点**。对于编号为 $id$ 的边 $(u, v, w)$，我们将其转化为编号为 $id + n$，权值为 $w$ 的点。然后维护子树内最大点权即可。

  有一些小细节问题，就是说你怎么知道你断的是哪条边。所以我们实际上维护的是子树内点权最大的点的编号，然后记录一下每个编号对应的那条边的信息：$u, v, w$。由于我的写丑了蒯的其他题的代码所以其实结构体里面的那个 $id$ 没必要存（我对边没有排序没有改变边的顺序所以不需要记录 $id$ 捏）。

* 线段树分治我会，但是怎么撤销的？众所周知，线段树分治有一个撤销这一段时间内所加的边的操作。我们把这些操作存进一个 vector，然后撤回的时候把边倒序弹出来就可以了。

* 虽然问的是最小生成树权值之和，但是我们不需要在 LCT 上额外维护这个东西。我们直接记录一个 $sum$ 表示目前 MST 上边权和，加边删边的时候改一下 $sum$ 就好了。

丢一个丑陋的代码，它常数过大甚至跑不过 P3206，大家谨慎食用。

```cpp
#include <bits/stdc++.h>
#define ll long long
#define pii pair<int, int>
#define mr make_pair
#define fi first
#define se second
using namespace std;
const int N = 3e5 + 5;
int n, m, q;
bool qr[N];
ll sum;
struct Ed{
    int u, v, w, id;
}e[N];

namespace LCT{
    int fa[N], ch[N][2], ma[N], val[N], tag[N], stk[N];
    void pushup(int p) {
        ma[p] = val[p];
        int ls = ma[ch[p][0]], rs = ma[ch[p][1]];
        if(e[ma[p]].w < e[ls].w) ma[p] = ls; 
        if(e[ma[p]].w < e[rs].w) ma[p] = rs;
        return ; 
    }
    int child(int x) {
        return (ch[fa[x]][1] == x);
    }
    bool notroot(int x) {
        return (ch[fa[x]][0] == x || ch[fa[x]][1] == x);
    }
    void reverse(int x) {
        swap(ch[x][0], ch[x][1]), tag[x] ^= 1;
        return ;
    }
    void pushdown(int x) {
        if(tag[x]) {
            if(ch[x][0]) reverse(ch[x][0]);
            if(ch[x][1]) reverse(ch[x][1]);
            tag[x] = 0;
        }
        return ;
    }
    void rotate(int x) {
        int y = fa[x], z = fa[y], k = child(x), w = ch[x][k ^ 1];
        if(notroot(y)) ch[z][child(y)] = x;
        ch[x][k ^ 1] = y, ch[y][k] = w;
        if(w) fa[w] = y;
        fa[y] = x, fa[x] = z;
        pushup(y); return ;
    }
    void splay(int x) {
        int top = 0, y = x, z;
        stk[++top] = y;
        while(notroot(y)) stk[++top] = (y = fa[y]);
        while(top) pushdown(stk[top--]);
        while(notroot(x)) {
            y = fa[x], z = fa[y];
            if(notroot(y)) {
                if(child(x) == child(y)) rotate(y);
                else rotate(x);
            }
            rotate(x);
        }
        pushup(x); return ;
    }
    void access(int x) {
        for (int y = 0; x; y = x, x = fa[y]) {
            splay(x), ch[x][1] = y, pushup(x);
        }
        return ;
    }
    void makeroot(int x) {
        access(x), splay(x);
        reverse(x); return ;
    }
    int findroot(int x) {
        access(x), splay(x);
        while(ch[x][0]) pushdown(x), x = ch[x][0];
        splay(x); return x;
    }
    void makepath(int x, int y) {
        makeroot(x), access(y), splay(y);
        return ;
    }
    void link(int x, int y) {
        makeroot(x);
        if(findroot(y) != x) fa[x] = y;
    }
    void cut(int x, int y) {
        makeroot(x);
        if(findroot(y) == x && fa[y] == x && (!ch[y][0])) {
            fa[y] = ch[x][1] = 0, pushup(x);
        }
    }
} using namespace LCT;

vector <int> tr[N << 2];
vector <pii> del;

void modify(int p, int l, int r, int x, int y, int v) {
    if(x <= l && r <= y) {
        tr[p].emplace_back(v); return ;
    }
    int mid = (l + r) >> 1;
    if(x <= mid) modify(p << 1, l, mid, x, y, v);
    if(y > mid) modify(p << 1 | 1, mid + 1, r, x, y, v);
    return ;
}

void insert(int d) {
    int u = e[d].u, v = e[d].v, w = e[d].w, id = e[d].id;
    makeroot(u);
    if(findroot(v) != u) {
        sum += w;
        link(u, id + n), link(v, id + n);
        del.emplace_back(mr(id, -1));
        return ;
    }
    makepath(u, v);
    int mx = ma[v];
    if(w < e[mx].w) {
        sum -= e[mx].w, sum += w;
        cut(e[mx].u, e[mx].id + n), cut(e[mx].v, e[mx].id + n);
        del.emplace_back(mr(mx, 1));
        link(u, id + n), link(v, id + n);
        del.emplace_back(mr(id, -1));
    }
    return ;
}

void undo() {
    int id = del.back().fi, op = del.back().se;
    if(op == 1) {
        link(e[id].u, e[id].id + n), link(e[id].v, e[id].id + n);
    } 
    else {
        cut(e[id].u, e[id].id + n), cut(e[id].v, e[id].id + n);
    }
    del.pop_back(); return ;
}

void dele(int cnt) {
    while(del.size() > cnt) undo();
    return ;
}

void query(int p, int l, int r) {
    ll summ = sum; int cnt = del.size();
    for (int i : tr[p]) insert(i);
    if(l == r) {
        printf("%lld\n", sum + 1ll);
        sum = summ, dele(cnt);
        return ;
    }
    int mid = (l + r) >> 1;
    query(p << 1, l, mid), query(p << 1 | 1, mid + 1, r);
    sum = summ, dele(cnt);
    return ;
}

int main() {
    scanf("%d", &n);
    int mm = 0, t = 32766;
    for (int i = 1; i < n; ++i) {
        int u, v, w; scanf("%d %d %d", &u, &v, &w);
        e[++mm] = {u, v, w, mm};
        val[mm + n] = mm;
        modify(1, 1, t, 1, t, mm);
    }
    scanf("%d", &m);
    for (int i = 1; i <= m; ++i) {
        int u, v, w, l, r; scanf("%d %d %d %d %d", &u, &v, &w, &l, &r);
        e[++mm] = {u, v, w, mm};
        val[mm + n] = mm;
        modify(1, 1, t, l, r, mm);
    }
    m = mm;
    query(1, 1, t);
    return 0;
}
```



---

## 作者：xiezheyuan (赞：1)

## 简要题意

给出一个 $n$ 个顶点的带权图，初始时是一个树。有 $32766$ 个时刻，有 $m$ 次更改，每次更改给出 $u_i,v_i,w_i,l_i,r_i$。表示树上新增一条无向边 $(u_i,v_i,w_i)$，仅出现在位于 $[l_i,r_i]$ 的时刻。你需要求出所有更改完成后每个时刻的图的最小生成树边权和 $+1$。

## 思路

我本来给出题组出了和这道题几乎一模一样题，但是发现重了……

看到维护每个时刻的动态图问题，我们想到线段树分治。于是我们转换为如何解决这个问题：

- 插入一条边。
- 求当前图的最小生成树边权和。
- 撤销上一次操作

前两个操作可以使用 Link Cut Tree 在 $O(\log n)$ 的时间复杂度完成（如果您不会，可以看 [我写的这篇博客](https://www.cnblogs.com/zheyuanxie/p/mst-by-lct.html)）。

然后考虑如何撤销。我们可以类似可撤销并查集那样，维护一个栈。但是无法向并查集那样维护 `fa` 数组。

我们可以利用 Link Cut Tree 中的 Cut。维护每一次连边和断边的节点。撤销时反着操作即可。至于为什么合法，这个其实不需要证。每一次操作后都满足树的性质，倒回来一定也满足。

时间复杂度不会算。不过可以过就对了。

最后注意：十年 OI 一场空，不开 `long long` 见祖宗。

## 代码

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

const int N = 2e5+5;
int n,m,t;

namespace LCT{
#define ls (son[i][0])
#define rs (son[i][1])
	int son[N][2];
	int fa[N];
	bool tag[N];
	int maxt[N],maxid[N];
	int val[N];
	
	inline void pushup(int i){
		maxt[i]=val[i],maxid[i]=i;
		if(maxt[ls]>maxt[i]){
			maxt[i]=maxt[ls];maxid[i]=maxid[ls];
		}
		if(maxt[rs]>maxt[i]){
			maxt[i]=maxt[rs];maxid[i]=maxid[rs];
		}
	}
	
	inline void reverse(int i){
		swap(ls,rs);tag[i]^=1;
	}
	
	inline void pushdown(int i){
		if(tag[i]){
			if(ls) reverse(ls);
			if(rs) reverse(rs);
			tag[i]=0;
		}
	}
	
	inline bool get(int i){
		return son[fa[i]][1]==i;
	}
	
	inline bool is_root(int i){
		return son[fa[i]][0]!=i && son[fa[i]][1]!=i;
	}
	
	void update(int i){
		if(!is_root(i)){
			update(fa[i]);
		}
		pushdown(i);
	}
	
	inline void rotate(int p){
		int q=fa[p],z=fa[q],k=get(p);
		if(!is_root(q)){
			son[z][son[z][1]==q]=p;
		}
		fa[p]=z;
		son[q][k]=son[p][!k];
		if(son[p][!k]) fa[son[p][!k]]=q;
		son[p][!k]=q;
		fa[q]=p;
		pushup(q);
		pushup(p);
	}
	
	inline void splay(int i){
		update(i);
		for(int f;f=fa[i],!is_root(i);rotate(i)){
			if(!is_root(f)){
				rotate(get(f)==get(i)?f:i);
			}
		}
	}
	
	inline void access(int i){
		int p;
		for(p=0;i;p=i,i=fa[i]){
			splay(i);
			son[i][1]=p;
			pushup(i);
		}
	}
	
	inline int find(int i){
		access(i);
		splay(i);
		while(ls) pushdown(i),i=ls;
		splay(i);
		return i;
	}
	
	inline void make_root(int i){
		access(i);
		splay(i);
		reverse(i);
	}
	
	inline void split(int u,int v){
		make_root(u);
		access(v);splay(v);
	}
	
	inline void link(int u,int v){
		make_root(u);
		if(find(v)!=u){
			fa[u]=v;
		}
	}
	
	inline void cut(int u,int v){
		make_root(u);
		if(find(v)==u&&fa[v]==u&&(!son[v][0])) son[u][1]=fa[v]=0;
	}
}

int ret=0,ec=0;

#undef ls
#undef rs
#define ls (i<<1)
#define rs (i<<1|1)
#define mid ((l+r)>>1)

struct Edge{
	int u,v,w,id,l,r;
};

vector<Edge> tree[N<<2];
Edge edges[N];

struct Undo{
	bool flag;
	int u,v;
};

stack<Undo> undo_lct;

void update(int ql,int qr,Edge v,int i,int l,int r){
	if(ql<=l&&r<=qr){
		tree[i].push_back(v);
		return;
	}
	if(ql<=mid) update(ql,qr,v,ls,l,mid);
	if(qr>mid) update(ql,qr,v,rs,mid+1,r);
}

void solve(int i,int l,int r,int ans){
	auto level=undo_lct.size();
	for(Edge eg : tree[i]){
		int u=eg.u,v=eg.v,w=eg.w,gid=eg.id;
		if(LCT::find(u)!=LCT::find(v)){
			LCT::link(u,gid+n);LCT::link(gid+n,v);
			undo_lct.push({1,u,gid+n});
			undo_lct.push({1,gid+n,v});
			ans += w;
			continue;
		}
		LCT::split(u,v);
		int mxid=LCT::maxid[v],mxv=LCT::maxt[v];
		if(mxv<=w) continue;
		ans -= mxv;
		LCT::cut(edges[mxid-n].u,mxid);
		undo_lct.push({0,edges[mxid-n].u,mxid});
		LCT::cut(mxid,edges[mxid-n].v);
		undo_lct.push({0,mxid,edges[mxid-n].v});
		LCT::link(u,gid+n);LCT::link(gid+n,v);
		undo_lct.push({1,u,gid+n});
		undo_lct.push({1,gid+n,v});
		ans += w;
	}
	if(l==r) cout<<ans<<'\n';
	else{solve(ls,l,mid,ans);solve(rs,mid+1,r,ans);}
	while(undo_lct.size()>level){
		Undo undo = undo_lct.top();
		undo_lct.pop();
		if(undo.flag==0) LCT::link(undo.u,undo.v);
		else LCT::cut(undo.u,undo.v);
	}
}

signed main(){
	ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
	cin>>n;
	t=32766; 
	for(int i=1;i<n;i++){
		cin>>edges[i].u>>edges[i].v>>edges[i].w;
		edges[i].l=1,edges[i].r=t;
		edges[i].id=i;
		LCT::splay(i+n);
		LCT::val[i+n]=edges[i].w;
		update(edges[i].l,edges[i].r,edges[i],1,1,t);
	}
	cin>>m;
	for(int i=n;i<n+m;i++){
		cin>>edges[i].u>>edges[i].v>>edges[i].w>>edges[i].l>>edges[i].r;
		edges[i].id=i;
		LCT::splay(i+n);
		LCT::val[i+n]=edges[i].w;
		update(edges[i].l,edges[i].r,edges[i],1,1,t);
	}
	solve(1,1,t,1);
	return 0;
}

```

---

## 作者：SrsgPrince_ (赞：0)

# P4319 变化的道路 Solution

题面传送门：[P4319 变化的道路](https://www.luogu.com.cn/problem/P4319)。

推荐在我的 [博客](https://www.luogu.com.cn/blog/fy123333/P4319Solution) 中查看。

## 题目分析 Hint

题目：输出共 $32766$ 行，第 $i$ 行表示第 $i$ 天游览的 $L$ 值至少为多少

题目给出的操作是求出 $i_n$ 天的最小生成树的边权和再加 $1$。

我们考虑用动态树+线段树分治做。

## 思路 Solution

这道题可以建一个线段树，然后在每个节点上记这个区间的边，然后去处理每一个点，最后会有 $n \log n$ 条边。最后遍历线段树即可。

具体做法是：每到一个节点，当这个节点上的边比现在的最小生成树上的边更优时，就换掉。可以用 stack 来记录所有的加边删边操作，方便退化。因为这道题是动态的操作，所以我们用动态树来维护其中的最小生成树，考虑使用 LCT。维护最小生成树的方法是遇到一条边后，若其联通了两个已经联通的点，那么其为返祖边，会形成环，那么我们就把环上最大的边断掉即可。可以写成 $\operatorname{split(u, v)}$，然后 $\operatorname{cut(max, u)}, \operatorname{cut(max, v)}$。如果还不是很清楚的话，可以先练一练 [P2387 [NOI2014] 魔法森林](https://www.luogu.com.cn/problem/P2387) 这道题，是道好题。这道题还要注意要开 long long，其它就没什么了，就是记得要输出 $32766$ 行。

这道题用上述做法时间复杂度 $O(n \log ^ 2 n)$，目前最优解第三。代码如下。

所有的初始化+结构体。

```cpp
const int maxn = 2e5 + 10, maxm = 4e4 + 10;
int n, m, top, cnt;
long long res[maxm];
struct Edge {
    int u, v;
    long long w;
} ed[maxn];
struct Stack {
    int id, opt;
} stk[maxn];
int fa[maxn], rev[maxn], chd[maxn][2], mx[maxn];
long long val[maxn];
```

LCT 部分。

```cpp
inline void swap(int &x, int &y) {
    x ^= y; y ^= x; x ^= y;
}
inline bool isRoot(int x) {
    return chd[fa[x]][0] != x && chd[fa[x]][1] != x;
}
inline void pushRev(int x) {
    swap(chd[x][0], chd[x][1]);
    rev[x] ^= 1;
}
inline void pushUp(int x) {
    mx[x] = x;
    if (chd[x][0] && val[mx[x]] < val[mx[chd[x][0]]]) mx[x] = mx[chd[x][0]];
    if (chd[x][1] && val[mx[x]] < val[mx[chd[x][1]]]) mx[x] = mx[chd[x][1]];
}
inline void pushDown(int x) {
    if (rev[x]) {
        if (chd[x][0]) pushRev(chd[x][0]);
        if (chd[x][1]) pushRev(chd[x][1]);
    }
    rev[x] = 0;
}
inline void update(int x) {
    if (!isRoot(x)) update(fa[x]);
    pushDown(x);
}
inline void rotate(int x) {
    int y = fa[x], z = fa[y], k = chd[y][1] == x, w = chd[x][k ^ 1];
	if (!isRoot(y)) chd[z][chd[z][1] == y] = x;
	chd[x][k ^ 1] = y;
    chd[y][k] = w;
	if (w) fa[w] = y;
    fa[y] = x; fa[x] = z;
	pushUp(y);
}
inline void splay(int x) {
    update(x);
    while (!isRoot(x)) {
        int y = fa[x], z = fa[y];
        if (!isRoot(y)) 
            rotate((chd[y][0] == x) ^ (chd[z][0] == y) ? x : y);
        rotate(x);
    }
    pushUp(x);
}
inline void access(int x) {
    for (int y = 0; x; x = fa[y = x]) {
        splay(x);
        chd[x][1] = y;
        pushUp(x);
    }
}
inline void makeRoot(int x) {
    access(x); splay(x); pushRev(x);
}
inline void split(int x, int y) {
    makeRoot(x); access(y); splay(y);
}
inline void link(int x, int y) {
    makeRoot(x);
    fa[x] = y;
}
inline int findRoot(int x) {
    access(x); splay(x);
    while (chd[x][0]) pushDown(x), x = chd[x][0];
    splay(x);
    return x;
}
inline void cut(int x, int y) {
    makeRoot(x); access(y); splay(x);
    fa[y] = chd[x][1] = 0;
    pushUp(x);
}
```

线段树部分。

```cpp
long long sum;
vector<int> tree[maxn];
inline void ret() {
    int opt = stk[top].opt, id = stk[top].id;
	int u = ed[id].u, v = ed[id].v;
    top--;
	if (opt == 0) cut(u, id), cut(v, id);
	else link(u, id), link(v, id);
}
inline void update(int rt, int l, int r, int lft, int rgt, int id) {
    if (lft <= l && r <= rgt){
        tree[rt].push_back(id);
        return;
    }
	int mid = (l + r) >> 1;
	if (lft <= mid) update(rt << 1, l, mid, lft, rgt, id);
	if (rgt > mid) update(rt << 1 | 1, mid + 1, r, lft, rgt, id);
}
inline void solve(int rt, int lft, int rgt) {
    int tmpTop = top; long long tmpSum = sum;
	for (int i = 0; i < (int)tree[rt].size(); ++i) {
		int id = tree[rt][i], u = ed[id].u, v = ed[id].v;
		split(u, v);
        int mxid = mx[v];
		if (val[mxid] <= val[id])continue;
		stk[++top] = (Stack) {mxid, 1};
        stk[++top] = (Stack) {id, 0};
		cut(ed[mxid].u, mxid);
        cut(ed[mxid].v, mxid);
		link(u, id); link(v, id);
        sum = sum - val[mxid] + val[id];
	}
    int mid = (lft + rgt) >> 1;
	if (lft == rgt) res[lft] = sum;
    else solve(rt << 1, lft, mid), solve(rt << 1 | 1, mid + 1, rgt);
	sum = tmpSum;
    while (top > tmpTop) ret();
}
int main() {
    n = quickRead(); cnt = n;
    for (int i = 1; i < n; ++i) {
        int u = quickRead(), v = quickRead(), w = quickRead();
        ed[++cnt] = (Edge) {u, v, w};
        val[cnt] = w;
        link(u, cnt); link(v, cnt);
        sum += w;
    }
    m = quickRead();
    for (int i = 1; i <= m; ++i) {
        int u = quickRead(), v = quickRead(), w = quickRead(), lft = quickRead(), rgt = quickRead();
        ed[++cnt] = (Edge) {u, v, w}; val[cnt] = w;
        update(1, 1, 32766, lft, rgt, cnt);
    }
    solve(1, 1, 32766);
    for (int i = 1; i <= 32766; ++i) quickWrite(res[i] + 1, '\n');
    return 0;
}
```


---

## 作者：violetctl39 (赞：0)

# P4319 变换的道路 题解

by ctldragon



很显然，题目要求每一天的最小生成树的边权和 +1。

天数很少，刚开始肯定会想到直接按时间顺着推，但其实仔细一想会发现有些边被弃掉之后想再找回来用是很困难的，所以顺着推是肯定不行的。

**正解：动态树+线段树分治。**

这种题一般都是可以对时间（或是询问等）建一个线段树，在每一个节点上记这个区间包含的边，然后利用标记永久化的思想来处理每一个时间点。这样最后线段树上会有 $O(n\log n)$ 条边。

然后遍历整个线段树来得到答案。

**具体实现：**

每到一个节点时，当这个节点上的边比现在最小生成树上的边更优时，就替换掉它，否则不改变。可以用一个栈来记录每次操作的加边和删边，这样回溯的时候可以回退到原来的状态。因为有动态加边和删边操作，这里可以用 LCT 来维护最小生成树。至于如何用 LCT 维护最小生成树，可以去看看[[WC2006]水管局长](https://www.luogu.com.cn/problem/P4172)和[[NOI2014]魔法森林](https://www.luogu.com.cn/problem/P2387)这两题，都是 LCT 维护最小生成树的好题。

最后本题的时间复杂度为 $O(n\log^2n)$。

**代码：**

```cpp
#include<cstdio>
#include<vector>
#define pc(x) putchar(x)
#define ll long long
#define ls (pos<<1)
#define rs (pos<<1|1)
using namespace std;
inline int read()
{
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){f=ch=='-'?-1:f;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}
	return x*f;
}
void write(ll x)
{
	if(x<0){x=-x;putchar('-');}
	if(x>9)write(x/10);
	putchar(x%10+48);
}
int n,m,top,cnt;ll ans[40000];
struct edge{int u,v;ll w;}e[200005];
struct STK{int id,op;}stk[200005];
int fa[200005],rev[200005],ch[200005][2],mx[200005];ll val[200005];
//LCT begin
inline void swap(int &x,int &y){x^=y;y^=x;x^=y;}
inline bool isroot(int x){return ch[fa[x]][0]!=x&&ch[fa[x]][1]!=x;}
inline void pushrev(int x){swap(ch[x][0],ch[x][1]);rev[x]^=1;}
inline void pushup(int x)
{
	mx[x]=x;
	if(ch[x][0]&&val[mx[x]]<val[mx[ch[x][0]]])mx[x]=mx[ch[x][0]];
	if(ch[x][1]&&val[mx[x]]<val[mx[ch[x][1]]])mx[x]=mx[ch[x][1]];
}
inline void pushdown(int x)
{
	if(rev[x])
	{
		if(ch[x][0])pushrev(ch[x][0]);
		if(ch[x][1])pushrev(ch[x][1]);
	}rev[x]=0;
}
inline void update(int x)
{
	if(!isroot(x))update(fa[x]);
	pushdown(x);
}
inline void rotate(int x)
{
	int y=fa[x],z=fa[y];
	int k=ch[y][1]==x,w=ch[x][k^1];
	if(!isroot(y))ch[z][ch[z][1]==y]=x;
	ch[x][k^1]=y;ch[y][k]=w;
	if(w){fa[w]=y;}fa[y]=x;fa[x]=z;
	pushup(y);
}
inline void splay(int x)
{
	update(x);
	while(!isroot(x))
	{
		int y=fa[x],z=fa[y];
		if(!isroot(y))rotate((ch[y][0]==x)^(ch[z][0]==y)?x:y);
		rotate(x);
	}pushup(x);
}
inline void access(int x)
{
	for(int y=0;x;x=fa[y=x])
	{splay(x);ch[x][1]=y;pushup(x);}
}
inline void makeroot(int x){access(x);splay(x);pushrev(x);}
inline void split(int x,int y){makeroot(x);access(y);splay(y);}
inline void link(int x,int y){makeroot(x);fa[x]=y;}
inline int findroot(int x)
{
	access(x);splay(x);
	while(ch[x][0])pushdown(x),x=ch[x][0];
	splay(x);return x;
}
inline void cut(int x,int y)
{
	makeroot(x);access(y);splay(x);
	fa[y]=ch[x][1]=0;pushup(x);
}
//LCT end
ll sum;
vector<int>tr[200005];
inline void ret()
{
	int op=stk[top].op,id=stk[top].id;
	int u=e[id].u,v=e[id].v;top--;
	if(op==0)cut(u,id),cut(v,id);
	else link(u,id),link(v,id);
}
inline void modify(int pos,int l,int r,int L,int R,int id)
{
	if(L<=l&&r<=R){tr[pos].push_back(id);return;}
	int mid=(l+r)>>1;
	if(L<=mid)modify(ls,l,mid,L,R,id);
	if(R>mid)modify(rs,mid+1,r,L,R,id);
}
inline void solve(int pos,int l,int r)
{
	int nowtop=top;ll nowsum=sum;
	for(int i=0;i<(int)tr[pos].size();++i)
	{
		int id=tr[pos][i],u=e[id].u,v=e[id].v;
		split(u,v);int mxid=mx[v];
		if(val[mxid]<=val[id])continue;
		stk[++top]=(STK){mxid,1};stk[++top]=(STK){id,0};
		cut(e[mxid].u,mxid);cut(e[mxid].v,mxid);
		link(u,id);link(v,id);sum=sum-val[mxid]+val[id];
	}int mid=(l+r)>>1;
	if(l==r)ans[l]=sum; else solve(ls,l,mid),solve(rs,mid+1,r);
	sum=nowsum;while(top>nowtop)ret();
}
int main()
{
	n=read();cnt=n;
	for(int i=1;i<n;++i)
	{
		int u=read(),v=read(),w=read();
		e[++cnt]=(edge){u,v,w};val[cnt]=w;
		link(u,cnt);link(v,cnt);sum+=w;
	}m=read();
	for(int i=1;i<=m;++i)
	{
		int u=read(),v=read(),w=read(),l=read(),r=read();
		e[++cnt]=(edge){u,v,w};val[cnt]=w;
		modify(1,1,32766,l,r,cnt);
	}solve(1,1,32766);
	for(int i=1;i<=32766;++i)write(ans[i]+1),pc('\n');
	return 0;
}
```


---

## 作者：JK_LOVER (赞：0)

## 题意
给你一棵有 $n$ 个节点无根有边权的树 ，和 $m$ 条在一定时间段出现的边。求问每个时间段的最小生成树。[QWQ](https://www.luogu.com.cn/blog/xzc/solution-p4319) 。
## 分析
- 对与时间段分析

对于在时间段中处理问题，我们一般采用线段树分治。那么我们就把一条边拆成了多条边。而每条边最多也只能被拆成 $\log k$ 条。那我们现在就有了 $m\times \log k$ 条边。那么我们现在对于时间的分析就结束了。

- 最小生成树分析

我们求最小生成树，回想一下有哪些算法。 $kruskal$ 和 $prim$ 算法（不会的建议再去康康）。而这两种算法对于求解最小生成树的时间复杂度分别为 $O(n\alpha(m))$ 和 $O((n+m)\log n)$ 。但是在线段树分治过程中，我们为了保证复杂度的正确，是采用的撤回操作，而不是暴力重建。而 $prim$ 算法如果要考虑是哪条边贡献，又怎么撤回边。都是非常复杂而且复杂度也极大的。

- 考虑 $kruskal$ 算法过程

$kruskal$ 为啥能用？这是由于有一步排序。这个使边权值小的先成为树边。那么如果没有排序怎么办？这就要将这两个顶点之间的简单路径中的最大值提出来。如果大于了这条边的边权，证明这条边比另一条边更优。那么现在问题就是如何查找，删除，插入。

- 查找，删除，插入。

- 查找：我们对于树上的路径查找最值一般采用 $LCT$ 和树连剖分。

- 删除，插入：如果只有其中一种操作，其实树链剖分也可做。就是把删除反向变为插入就可以了，但是有两种。这里明显 $LCT$ 实现难度，和思维量都更低。

那么这道题就可以 $\text{线段树分治+LCT}$ 来做，码量有点大，如果挑不出来，其实可以把 $LCT$ 代码找个题提交一下，线段树分治也可以提交一下模板。最后的时间复杂度为 $O(m \log k \log n)$ 。
## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long 
int read(){
	int x = 0,f = 0;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')f=1;ch=getchar();}
	while(isdigit(ch)){x=x*10+ch-'0';ch=getchar();}
	return f?-x:x;
}
const int N = 1011000;
int n,m;
struct LinkCutTree{
	int c[2],val,mx,fa;
	bool r;
}t[N];
bool nroot(int x)
{
	return t[t[x].fa].c[1] == x || t[t[x].fa].c[0] == x;
}
void pushr(int x)
{
	swap(t[x].c[1],t[x].c[0]);
	t[x].r ^= 1;
}
void pushdown(int x)
{
	if(t[x].r)
	{
		if(t[x].c[1]) pushr(t[x].c[1]);
		if(t[x].c[0]) pushr(t[x].c[0]);
		t[x].r = 0;
	}
}
void push(int x)
{
	if(nroot(x)) push(t[x].fa);
	pushdown(x);
}
void pushup(int x)
{
	if(x > n) t[x].mx = x;
	else t[x].mx = 0;
	if(t[t[t[x].c[1]].mx].val > t[t[x].mx].val) t[x].mx = t[t[x].c[1]].mx;  
	if(t[t[t[x].c[0]].mx].val > t[t[x].mx].val) t[x].mx = t[t[x].c[0]].mx; 
}
void rotate(int x)
{
	int y = t[x].fa,z = t[y].fa,k = (t[y].c[1] == x),w = t[x].c[!k];
	if(nroot(y)) t[z].c[t[z].c[1] == y] = x;
	t[x].c[!k] = y;t[y].c[k] = w;
	t[x].fa = z;if(w)t[w].fa = y;t[y].fa = x;
	pushup(y);pushup(x);
}

void splay(int x)
{
	push(x);
	while(nroot(x))
	{
//		cout<<x<<endl;
		int y = t[x].fa,z = t[y].fa;
		if(nroot(y))
		{
			rotate(((t[z].c[1] == y)^(t[y].c[1] == x))?x:y);
		}
		rotate(x);
		pushup(x);
	}
}
void access(int x)
{
	for(int y = 0;x;x = t[y].fa)
	{
		splay(x);t[x].c[1] = y;pushup(x);y = x;
	}
}
void makeroot(int x)
{
	access(x);splay(x);pushr(x);
}
void split(int x,int y)
{
	makeroot(x);access(y);splay(y);
}
void link(int x,int y)
{
	split(x,y);
	t[x].fa = y;
}
void cut(int x,int y)
{
	split(x,y);
	t[y].c[0] = t[x].fa = 0;
	pushup(y);
}
int find(int rt){
    access(rt);
	splay(rt);
    while(t[rt].c[0]) rt = t[rt].c[0];
    return rt;
}
struct Edge{int x,y,w;}e[N];
struct Stack{int x,y;}st[N];
int top = 0,tot = 0;
vector<int> T[N<<2];
void update(int u,int l,int r,int L,int R,int x)
{
	if(r < L || l > R) return;
	if(L <= l && r <= R) {T[u].push_back(x);return;}
	int mid = l + r >> 1;
	update(u<<1,l,mid,L,R,x);
	update(u<<1|1,mid+1,r,L,R,x);
}
void debug()
{
	printf("\nval:: ");
	for(int i = 1;i < n+n+m;i++)
	printf("%d ",t[i].val);
	printf("\nmx:: ");
	for(int i = 1;i < n+n+m;i++)
	printf("%d ",t[i].mx);
	printf("\n");
}
void solve(int u,int l,int r)
{
//	cout<<u<<endl;
	
	int lasttop = top;
	for(int i = 0;i < T[u].size();i++)
	{
		int id = T[u].at(i);
		int a = e[id].x,b = e[id].y,w = e[id].w;
		split(a,b);
		int Emax;
		Emax = t[b].mx;
//		debug();
//		cout<<e[id].w<<" id:: "<<t[Emax].val<<endl;
		if(t[Emax].val <= w) continue;	
		Emax -= n;
		st[++top] = (Stack){id,Emax};
		tot -= e[Emax].w;
		cut(e[Emax].x,Emax+n);cut(e[Emax].y,Emax+n);
		tot += e[id].w;
		link(a,id+n);link(b,id+n);
	}
	if(l == r)  
	{
//		if(r<=5)
		printf("%lld\n",tot+1);
	}
	else{
		int mid = l + r >> 1;
		solve(u<<1,l,mid);
		solve(u<<1|1,mid+1,r);
	}
	while(top > lasttop)
	{
		int a = st[top].x,b = st[top].y;
		cut(e[a].x,a+n);cut(e[a].y,a+n);
		link(e[b].x,b+n);link(e[b].y,b+n);
		tot -= e[a].w;
		tot += e[b].w;
		top--;
	}
}
signed main()
{
	n = read();
	for(int i = 1;i < n;i++)
	{
		e[i].x = read(),e[i].y = read(),e[i].w = read();
		link(e[i].x,n+i);
		link(e[i].y,n+i);
		tot += e[i].w;
		t[i+n].mx = i + n;
		t[i+n].val = e[i].w;
	}
	m = read();
	for(int i = n;i < m+n;i++)
	{
		e[i].x = read();e[i].y = read();e[i].w = read();
		t[i+n].mx = i+n;
		t[i+n].val = e[i].w;
		int l = read(),r = read();
		update(1,1,32766,l,r,i);
	}
	solve(1,1,32766);
	return 0;
}
```


---

## 作者：hjsjhn (赞：0)

## 题意
给定一棵树，然后给一些不定边，以及这些不定边的出现时间$l,r$，动态的求出第$i$天($i\in[1,32766]$)的最小生成树。
## 题解
建议先做一下动态维护只有加边的$MST$的题。
[水管局长](https://www.lydsy.com/JudgeOnline/problem.php?id=2594)

### 首先考虑加边操作
我们假设加入一条边$(u,v)$之后可以时最小生成树权值和变小。

此时肯定要把这条边加进去，那么为了维护最小生成树的形态，应该把这条边两端点原来所在的链上删去某条边。

容易知道这样操作之后图仍然是一棵树，那么我们考虑要删掉哪条边，由于我们只需要和最小，所以直接找出原链上权值最大的一条边，比较它与加入的边的权值大小，如果加入的边权值比链上最大权值大，就将其加入，否则不加入。

### 但是题中还有删除的操作，这个应该怎么解决
一条边影响的肯定是一段区间，假设一段时间为$[L, R]$，当一段时间$[l, r]$内这条边一直存在时显然有$L<=l, r <= R$这个和线段树的区间包含是同种形式，可以考虑用线段树对时间进行分治，线段树上某一段区间若被某一条边完全包含，我们就将其代表的节点打上永久标记，不用下推。

这样子我们在分治时进入某段区间先把将这段区间完全覆盖的边判断，对于加入的边记录下删除了哪些原链上的边，最后扫完(线段树上的)子树后暴力修改回没有没有加这段区间的状态。

我觉得其实暴力扫$[1,32766]$然后在端点处用lct加边删边应该也可以吧。求dalao指点。

## 程序
蒟蒻乱开的数组大小求dalao勿dui。
``` cpp
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cmath>
#include <cstring>
#include <vector>
#include <stack>
#define MAX_N 50007
#define MAX_M 400007
#define R 32766

typedef long long ll;

namespace lct {
    int c[MAX_M * 2][3], fa[MAX_M * 2];
    int mx[MAX_M * 2];
    ll val[MAX_M * 2];
    int q[MAX_M * 2], top;
    bool rev[MAX_M * 2];

    inline bool isroot (int x) {return c[fa[x]][0] != x && c[fa[x]][1] != x;}

    inline void pushdown (int x) {
        int ls = c[x][0], rs = c[x][1];
        if (rev[x]) {
            rev[x] ^= 1, rev[ls] ^= 1, rev[rs] ^= 1;
            std::swap(c[x][0], c[x][1]);
        }
    }

    inline void update (int x) {
        int ls = c[x][0], rs = c[x][1];
        mx[x] = x;
        if (val[mx[x]] < val[mx[ls]]) mx[x] = mx[ls];
        if (val[mx[x]] < val[mx[rs]]) mx[x] = mx[rs];
    }

    inline void rotate (int x) {
        int y = fa[x], z = fa[y], l, r;
        l = (c[y][1] == x), r = l ^ 1;
        if (!isroot(y))
            c[z][c[z][1] == y] = x;
        fa[x] = z, fa[y] = x, fa[c[x][r]] = y;
        c[y][l] = c[x][r], c[x][r] = y;
        update(y), update(x);
    }

    inline void splay (int x) {
        top = 0, q[++top] = x;
        for (int i = x; !isroot(i); i = fa[i]) q[++top] = fa[i];
        for (int i = top; i; --i) pushdown(q[i]);
        while (!isroot(x)) {
            int y = fa[x], z = fa[y];
            if (!isroot(y))
                if ((c[y][0] == x) ^ (c[z][0] == y)) rotate (x);
                else rotate (y);
            rotate (x);
        }
    }

    inline void access (int x) {
        for (int t = 0; x; t = x, x = fa[x]) 
            splay(x), c[x][1] = t, update(x);
    }

    inline void makeroot (int x) {
        access(x), splay(x), rev[x] ^= 1;        
    }

    inline void link (int x, int f) {
        makeroot(x), fa[x] = f;
    }

    inline void cut (int x, int y) {
        makeroot(x);
        access(y), splay(y);
        c[y][0] = fa[x] = 0;
    }

    inline int query (int x, int y) {
        makeroot(x);
        access(y); splay(y);
        return mx[y];
    }
};
using namespace lct;

int N, M;
ll ans, res[R + 100];

struct edge {
    int u, v, id;
    ll w;
}e[MAX_M * 2];

std::vector<int> tag[R * 6];

void modify (int x, int l, int r, int totl, int totr, int id) {
    if (l > r || l > totr || r < totl) return;
    if (totl <= l && r <= totr) {tag[x].push_back(id);return;}
    if (l == r) return;
    int mid = l + r >> 1;
    if (totl <= mid) modify (x * 2, l, mid, totl, totr, id);
    if (mid < totr) modify (x * 2 + 1, mid + 1, r, totl, totr, id);
}

void calc (int x, int l, int r) {
    std::stack<std::pair<int, int> > stk;
    int m = tag[x].size();
    for (int i = 0;i < m; ++i) {
        int id = tag[x][i], u = e[id - N - M].u, v = e[id - N - M].v, t = query(u, v);
        ll w = e[id - N - M].w;
        if (val[t] <= w) continue;
        stk.push(std::make_pair(t, 1));
        stk.push(std::make_pair(id, 0));
        cut(t, e[t - N - M].u), cut(t, e[t - N - M].v), ans -= e[t - N - M].w;
        link(id, e[id - N - M].u), link(id, e[id - N - M].v), ans += w;
    }
    if (l == r) res[l] = ans;
    else {
        int mid = l + r >> 1;
        calc(x * 2, l, mid), calc(x * 2 + 1, mid + 1, r);
    }
    while (!stk.empty()) {
        std::pair<int, int> p = stk.top(); stk.pop();
        int id = p.first;
        if (p.second == 0) cut(id, e[id - N - M].u), cut(id, e[id - N - M].v), ans -= e[id - N - M].w;
        else link(id, e[id - N - M].u), link(id, e[id - N - M].v), ans += e[id - N - M].w;
    }
}

int main () {
    scanf("%d", &N);
    for (int i = 1;i < N; ++i) {
        scanf("%d%d%lld", &e[i].u, &e[i].v, &e[i].w);
    }
    int l, r;
    scanf("%d", &M);
    for (int i = 1;i < N; ++i) {
        mx[N + M + i] = N + M + i;
        val[N + M + i] = e[i].w;
        ans += e[i].w;
        link(e[i].u, N + M + i);
        link(e[i].v, N + M + i);
    }
    for (int i = N;i < M + N; ++i) {
        scanf("%d%d%lld%d%d", &e[i].u, &e[i].v, &e[i].w, &l, &r);
        mx[N + M + i] = N + M + i;
        val[N + M + i] = e[i].w;
        modify (1, 1, R, l, r, N + M + i);
    }
    calc(1, 1, R);
    for (int i = 1;i <= R; ++i) printf("%lld\n", res[i] + 1);
    return 0;
}
```

---

## 作者：Acee (赞：0)

~~这题难道不是一眼。~~

非树边有生效区间，直接考虑线段树分治。

$L$ 显然是 $\text{MST}$ 的边权和，那么直接 LCT 维护，往上的时候撤销即可。

简单的说就是两个板子套一起。

代码是从 emacs 中拷出来的，缩进有问题，不太美观，想要的私信吧。

---


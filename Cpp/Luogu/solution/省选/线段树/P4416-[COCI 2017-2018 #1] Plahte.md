# [COCI 2017/2018 #1] Plahte

## 题目描述

小唐纳德决定有一天清洗他所有的 N 张白色床单。洗完后，他把它们放在后院的地上晾干。唐纳德放置床单的方式是**它们的边缘或角落都不接触，且没有边缘相交**，但可能会有小床单放在大床单上，或者一张床单完全覆盖另一张床单。做完这些后，唐纳德就去睡觉了。

唐纳德的朋友金姆不知怎么得知唐纳德正在晾床单，决定捉弄他。他从阁楼上找到了父亲的一个彩弹枪。和枪一起的，还有 M 颗不同颜色的彩弹球，但可能有多个球是相同颜色的。唐纳德一睡着，金姆就走进他的后院，开始用彩弹枪射击床单。我们都知道床单会渗色，所以当金姆射击最上面的床单时，那张床单会将彩弹的颜色渗透到下面所有的床单上。金姆用完所有的球后，开心地离开了唐纳德的后院。

当唐纳德醒来去收床单时，他大吃一惊。唐纳德的许多床单上都有一些新的颜色。由于唐纳德对准确的数据非常感兴趣，而他被惊吓得无法思考，他请求你告诉他每张床单上的新颜色数量。

我们可以将唐纳德的后院表示为一个无限的坐标系，床单表示为与坐标轴平行的矩形。金姆的射击可以表示为该坐标系中的点。

请注意：金姆的射击可能会错过所有床单，但每次射击的坐标是唯一的。

## 说明/提示

![](https://cdn.luogu.com.cn/upload/pic/17380.png)

题面翻译由 ChatGPT-4o 提供。

## 样例 #1

### 输入

```
2 2
1 1 3 3
5 6 10 10
3 3 1
5 1 2
```

### 输出

```
1
0```

## 样例 #2

### 输入

```
3 3
1 1 7 7
2 2 6 6
3 3 5 5
4 4 1
2 6 2
4 7 3
```

### 输出

```
3
2
1```

## 样例 #3

### 输入

```
1 3
1 1 7 7
2 6 2
4 7 3
4 4 1
```

### 输出

```
3```

# 题解

## 作者：Time_tears (赞：8)

看完了原题后，有用的信息有如下这些：

1. 矩形之间只会有包含或相离的关系（这点非常重要，是解题的关键步骤）

1. 由 1 可得矩形间会构成森林

1. 对于每个点，若它在某个矩形内，则在它的父亲内

于是原题可以分为两部分：

### part 1.  处理矩形的父子关系以及包含每个点的最小矩形

### part 2.  父亲继承儿子的信息

首先，第 2 步非常好处理，我们只需要用 set + 启发式合并就可以做到 $O(n \log n)$ 的复杂度了。

第 1 步比较麻烦，但其实有非常类似的题目：牛客网的 “圆与圆之间的距离是不能一概而论的” 

在这里有 2 种做法，我用的是比较傻的 set ，我们先对 $x$ 轴扫描线，那么每个矩形会变成上线段和下线段，对于一个矩形，若它的上线段的上方的第一个线段是上线段，那么他就被这个矩形所包含，否则就被它的父亲所包含。

![](https://cdn.luogu.com.cn/upload/image_hosting/c0951tzx.png?x-oss-process=image/resize,m_lfit,h_250,w_250)![](https://cdn.luogu.com.cn/upload/image_hosting/ge6fkv20.png?x-oss-process=image/resize,m_lfit,h_250,w_250)

然后对于点也是同理，只不过要注意下边界，就可以用 set 维护，另一种算法是线段树，这里就不赘述了。

还有一件事，注意 set 的排序顺序，要先加再查最后删

~~luogurank1代码~~

```cpp
#include<bits/stdc++.h>
#define N 200005
using namespace std;
int n,m,cnt,rt,fa[N];
int h[N],ans[N];
vector<set<int> >st;
struct node {
	int to,next;
} e[N<<1];
struct Line {
	int l,opt,id;
	Line(int L=0,int O=0,int Id=0) {
		l=L,opt=O,id=Id;
	}
	bool operator <(Line a) const {
		return l==a.l?opt>a.opt:l<a.l;
	}
};
set<Line>line;
struct Pair {
	int l,r,x,opt,id;
	bool operator <(Pair a) const {
		return x==a.x?opt<a.opt:x<a.x;
	}
} p[N],q[N];
const int Mxdt=100000;
inline char gc() {
	static char buf[Mxdt],*p1=buf,*p2=buf;
	return p1==p2&&(p2=(p1=buf)+fread(buf,1,Mxdt,stdin),p1==p2)?EOF:*p1++;
}
inline char pc(char ch,bool bj) {
	static char buf[Mxdt],*p1=buf,*p2=buf+Mxdt;
	return (bj||(*p1++=ch)&&p1==p2)&&fwrite(p1=buf,1,p1-buf,stdout),0;
}
inline int read() {
	int res=0;
	char ch=gc();
	while(ch<'0')ch=gc();
	while(ch>='0')res=(res<<3)+(res<<1)+(ch^48),ch=gc();
	return res;
}
void print(int x) {
	if(x>9)print(x/10);
	pc(x%10^48,false);
}
inline void printnum(int x,char ch) {
	if(x<0)pc('-',false),x=-x;
	print(x),pc(ch,false);
}
void Addedge(int x,int y) {
	e[++cnt]=(node) {y,h[x]},h[x]=cnt;
}
set<Line>::iterator it;
void Merge(int x,int y) {
	if(st[x].size()<st[y].size())swap(st[x],st[y]);
	for(int a:st[y])st[x].insert(a);
	st[y].clear();
}
void Dfs(int x) {
	for(int i=h[x]; i; i=e[i].next)Dfs(e[i].to),Merge(x,e[i].to);
	ans[x]=st[x].size();
}
int main() {
	n=read(),m=read();st.resize(n+1);
	for(int i=1,a,b,c,d; i<=n; ++i) {
		a=read(),b=read(),c=read(),d=read();
		p[++cnt].id=i,p[cnt].opt=1,p[cnt].l=b,p[cnt].r=d,p[cnt].x=a;
		p[++cnt].id=i,p[cnt].opt=2,p[cnt].l=b,p[cnt].r=d,p[cnt].x=c;
	}
	for(int i=1; i<=m; ++i)q[i].x=read(),q[i].l=read(),q[i].r=read();
	sort(p+1,p+cnt+1),sort(q+1,q+m+1);
	for(int i=1,j=1; i<=m; ++i) {
		while(j<=cnt&&(q[i].x>p[j].x||(q[i].x==p[j].x&&p[j].opt==1))) {
			if(p[j].opt==1) {
				if((it=line.lower_bound(Line(p[j].l)))!=line.end())
					fa[p[j].id]=((*it).opt==2)?(*it).id:fa[(*it).id];
				line.insert(Line(p[j].l-1,1,p[j].id)),line.insert(Line(p[j].r,2,p[j].id));
			} else line.erase(Line(p[j].l-1,1,p[j].id)),line.erase(Line(p[j].r,2,p[j].id));
			++j;
		}
		if((it=line.lower_bound(Line(q[i].l,3)))!=line.end()) {
			if((*it).opt==2)st[(*it).id].insert(q[i].r);
			else st[fa[(*it).id]].insert(q[i].r);
		}
	}
	cnt=0;
	for(int i=1; i<=n; ++i)if(fa[i])Addedge(fa[i],i);
	for(int i=1; i<=n; ++i)if(!fa[i])Dfs(i);
	for(int i=1; i<=n; ++i)printnum(ans[i],'\n');
	return pc('0',1);
}
```



---

## 作者：Feyn (赞：7)

[link](https://www.luogu.com.cn/problem/P4416)

首先如果把矩形抽象成点，那么这些点一定会形成一片森林。理由：矩形之间只重叠不相交，故而对于一个矩形来说一定有至多一个完全覆盖它并且最小的大矩形，也就是说每个点的出度不超过一。又由于每个点连接的点肯定严格比自己大，所以也不会构成环。综上，最后这些点会形成一片森林。而由于连边的方式特征（也可以参照题目那句“那张床单会把球的颜色渗到下面的所有床单上”，可以把“下面所有床单”想象成点到根的路径），我们可以考虑对于每一发子弹找到最小的覆盖到它的矩形，然后统计答案的时候遍历整片森林用 set 启发式合并即可（可以构造出所有子弹打在叶子上的数据，这样如果单纯叶子往根合并会死掉）。

于是问题就变成了如何建树和如何找每发子弹对应结点的问题。

对于第一个我们可以用扫描线的思想，每个矩形拆分成上下两条线（称为上下线），把横坐标离散化之后再按纵坐标排序。找每个矩形在树上的父亲这一步骤放在下线进线段树的时候进行，由于扫描线的原理，假如一个矩形和当前矩形在纵方向上没有交集，那么它要么已经被丢出去了，要么还没有考虑进来，所以此时在线段树中的所有矩形都在纵坐标上包含当前矩形。但是呢我们希望找到的是横坐标也包含的、而且最小的矩形，对于第二个要求我们可以对于每个结点维护一个栈，由于按纵坐标排了序，可以想到越后入线段树的矩形越小，所以直接查询栈顶即可，一定可以保证是符合条件的最小矩形。对于第二个条件，先说结论，直接查询所有在线段树中访问到的结点中栈顶元素的最小值即可，然后插入一条线段的时候直接把它拆到一些区间（就是按着线段树的方式拆），给对应的结点的栈插入一个元素即可。

为什么上面的那种方法是对的呢？先考虑正确性，我们访问到的所有线段树上的结点都是当前线段拆开的结点的祖先，所以假如之前的某条线段覆盖了访问到的点，那么该线段一定可以覆盖这个结点的子孙，这就保证了我们找到的点是正确的。再考虑完备性，也就是是否存在一个未曾覆盖到访问结点的线段会成为答案，而这显然是不会的，毕竟能覆盖某条线段的线段拆开来的所有节点肯定不会比短线段拆开的结点要深，所以我们找到的点一定是最优的。综上，这样找父亲的方法是正确的。

然后就没有什么了。对于一个点，直接找它在线段树中访问到的结点中最大的编号，这个编号对应的矩形显然是最小且包含它的矩形，丢到一个 set 里就可以了（主要是因为有颜色相同的子弹），所以建树和寻找每个子弹对应的结点都是 $O(N\log N)$ 的。统计答案的时候就是树上启发式合并，复杂度 $O(N\log^2N)$。实际上手时空都不太紧张。有一些需要注意的：

- 注意排序函数中纵坐标相同的时候上线段和下线段的相对位置，这关系到是否做到不重不漏的关键。
- 由于不知名原因我写 stack 会崩，所以写的是指针版的栈，可能让代码繁琐了点。
- 启发式合并要稍微注意一下写法。
- 另外就是由于一对上线段和下线段对应的区间是相同的，所以拆开来的结点也是相同的，所以处理上线段时不需要判断直接弹出栈顶元素即可。
- 代码有注释。码风氢气见谅……

```cpp
#include<bits/stdc++.h>
//#define feyn
const int N=160010;
const int M=N*3;
using namespace std;
inline void read(int &wh){
    wh=0;int f=1;char w=getchar();
    while(w<'0'||w>'9'){if(w=='-')f=-1;w=getchar();}
    while(w<='9'&&w>='0'){wh=wh*10+w-'0';w=getchar();}
    wh*=f;return;
}
inline int max(int s1,int s2){
	return s1<s2?s2:s1;
}

struct st{int data;st* next;};
inline void insert(st* &top,int data){
	st* now=new st();
	now->data=data,now->next=top;top=now;
}
inline void del(st* &top){top=top->next;}

//线段树部分 
#define lc (wh<<1)
#define rc (wh<<1|1)
#define mid (t[wh].l+t[wh].r>>1)
struct node{
	int l,r;
	st* top;//每个结点的栈 
}t[M<<2];
inline void build(int wh,int l,int r){
	t[wh].l=l,t[wh].r=r;t[wh].top=NULL;
	if(l==r)return;
	build(lc,l,mid);
	build(rc,mid+1,r);
}
inline int change(int wh,int wl,int wr,int data){
	int an=0;
	if(t[wh].top!=NULL)an=t[wh].top->data;//一路寻找所有访问到的点的栈顶的最大值 
	if(wl<=t[wh].l&&t[wh].r<=wr){//找到了拆出来的结点 
		if(data)insert(t[wh].top,data);//如果是下线段要加入 
		else del(t[wh].top);//否咋弹出来 
		return an;
	}
	if(wl<=mid)an=max(an,change(lc,wl,wr,data));
	if(wr>mid)an=max(an,change(rc,wl,wr,data));
	return an;
}
inline int ask(int wh,int pl){
	int an=0;if(t[wh].top!=NULL)an=t[wh].top->data;
	if(t[wh].l==t[wh].r)return an;
	return max(an,ask(pl<=mid?lc:rc,pl));//如题，找一个点的答案 
}
#undef lc
#undef rc
#undef mid

int m,n,b[M];
struct sq{int l,r,h,data,id;}a[N<<1];//线段，l和r是线段的端点，h是高度，data是上下 
inline bool cmp_sq(sq s1,sq s2){return s1.h==s2.h?s1.data<s2.data:s1.h<s2.h;}
struct po{int x,y,co;}p[N];//子弹对应的点，co是颜色 
inline bool cmp_po(po s1,po s2){return s1.y<s2.y;}

vector<int>son[N<<1];set<int>data[N<<1];int ff[N<<1];
inline void add_sq(int wh){
	if(a[wh].data==1){
		int fa=change(1,a[wh].l,a[wh].r,wh);
		if(fa)son[fa].push_back(wh);ff[wh]=fa;//记录父亲儿子关系，应该有更简洁的写法 
	}
	else change(1,a[wh].l,a[wh].r,0);
}//加入一条线段 

int ans[N],set_[N<<1];
inline void solve(int wh){
	set_[wh]=wh;
	for(vector<int>::iterator it=son[wh].begin();it!=son[wh].end();it++){
		int th=*it;solve(th);
		if(data[set_[th]].size()>data[set_[wh]].size())swap(set_[wh],set_[th]);
		//保证小集合向大集合合并 
		for(set<int>::iterator ii=data[set_[th]].begin();ii!=data[set_[th]].end();ii++){
			data[set_[wh]].insert(*ii);
		}
	}
	ans[a[wh].id]=data[set_[wh]].size();
	return;
}

signed main(){
	
	#ifdef feyn
	freopen("in.txt","r",stdin);
	#endif
	
	read(m);read(n);
	int x1,x2,y1,y2,co;
	int cnt_a=0,cnt_b=0;
	for(int i=1;i<=m;i++){
		read(x1);read(y1);read(x2);read(y2);
		a[++cnt_a]=(sq){x1,x2,y1,1,i};
		a[++cnt_a]=(sq){x1,x2,y2+1,-1,i};
		b[++cnt_b]=x1;b[++cnt_b]=x2;
	}
	for(int i=1;i<=n;i++){
		read(x1);read(y1);read(co);
		b[++cnt_b]=x1;p[i]=(po){x1,y1,co};
	}
	sort(b+1,b+cnt_b+1);
	int num=unique(b+1,b+cnt_b+1)-b-1;
	build(1,1,num);//对横坐标离散化 
	for(int i=1;i<=cnt_a;i+=2){
		a[i].l=a[i+1].l=lower_bound(b+1,b+num+1,a[i].l)-b;
		a[i].r=a[i+1].r=lower_bound(b+1,b+num+1,a[i].r)-b;
	}
	for(int i=1;i<=n;i++)p[i].x=lower_bound(b+1,b+num+1,p[i].x)-b;
	//离散化 
	sort(a+1,a+cnt_a+1,cmp_sq);
	sort(p+1,p+n+1,cmp_po);
	//按纵坐标排序 
	for(int i=1,j=1;i<=n;i++){
		while(j<=cnt_a&&a[j].h<=p[i].y)add_sq(j++);
		int wh=ask(1,p[i].x);
		data[wh].insert(p[i].co);
	}
	for(int i=1;i<=cnt_a;i++){
		if(a[i].data<0||ff[i])continue;
		solve(i);//如果一个点是树根那么遍历这棵树并统计答案 
	}
	for(int i=1;i<=m;i++)printf("%d\n",ans[i]);
	
	return 0;
}
```

---

## 作者：kai586123 (赞：4)

读题，有一个很重要的条件：矩形不相交。一个显然的思路：把矩形的包含关系表示出来。矩形的包含关系构成了树，原图转化为森林。

用扫描线辅助建立树的关系。按$x$排序，把矩形拆为两种操作：

- 入操作：扫描到矩形左边时在$y$相应区间上加入矩形。

- 出操作：扫描到矩形右边时在$y$相应区间上删除矩形。

维护$y$的一段区间内的矩形，可以动态开点用线段树。删除时，把这段区间设为删除的矩形的父亲即可。

把点标记在包含它的最小矩形上。同样用扫描线，把点看做$1 \times 1$的矩形处理。$O(nlogn)$。

建出森林后，用set做dsu on tree（把小set合并到大set）。$O(nlog^2n)$。

两个坑点：操作的排序顺序；线段树可能修改为$0$，注意标记下传写法。

~~所以这题为什么难度是绿的~~

```cpp
#include <bits/stdc++.h>

template <typename T = int>
inline T rd() {
	T a = 1, b = 0; char c = getchar();
	while (!isdigit(c)) a = c == '-' ? 0 : 1, c = getchar();
	while (isdigit(c)) b = b * 10 + c - '0', c = getchar();
	return a ? b : -b;
}

const int N = 80000 * 2 + 233, LIM = 1e9 + 10;

int n, m;

struct Operation {
	int x, y1, y2, t, id;
} op[N * 3];

int ls[N * 32], rs[N * 32], seg_tag[N * 32], seg_color[N * 32], root, tot;

void pushdown(int p) {
	if (seg_tag[p] != -1) {
		seg_color[ls[p]] = seg_color[rs[p]]
			= seg_tag[ls[p]] = seg_tag[rs[p]]
			= seg_tag[p];
		seg_tag[p] = -1;
	}
}

void change(int &p, int l, int r, int v, int L, int R) {
	if (p == 0)
		p = ++tot;
	if (l <= L && r >= R) {
		seg_color[p] = seg_tag[p] = v;
		return;
	}
	pushdown(p);
	int mid = (L + R) >> 1;
	if (l <= mid)
		change(ls[p], l, r, v, L, mid);
	if (r > mid)
		change(rs[p], l, r, v, mid + 1, R);
}

int query(int p, int x, int L, int R) {
	if (p == 0)
		return -1;
	if (L == R)
		return seg_color[p];
	pushdown(p);
	int mid = (L + R) >> 1, w = 0;
	if (x <= mid)
		w = query(ls[p], x, L, mid);
	else
		w = query(rs[p], x, mid + 1, R);
	if (w == -1)
		return seg_color[p];
	else return w;
}

int father[N];
std::vector<int> son[N];

std::set<int> set[N];
int which[N];

int ans[N];

void dsu_on_tree(int x) {
	if (!which[x])
		which[x] = x;

	int max_son = x;

	for (auto y : son[x]) {
		dsu_on_tree(y);
		if (set[which[y]].size() > set[which[max_son]].size())
			max_son = y;
	}

	std::swap(which[x], which[max_son]);

	for (auto y : son[x])
		for (auto i : set[which[y]])
			set[which[x]].insert(i);
	
	ans[x] = set[which[x]].size();
}

int main() {
	n = rd(), m = rd();

	for (int i = 1, j = 0; i <= n; ++i) {
		int a = rd(), b = rd(), c = rd(), d = rd();
		op[++j] = { a, b, d, -1, i };
		op[++j] = { c, b, d, 1, i };
	}

	for (int i = 1; i <= m; ++i) {
		int x = rd(), y = rd(), c = rd();
		op[n * 2 + i] = { x, y, y, 0, c };
	}

	std::sort(op + 1, op + n * 2 + m + 1,
		[](const Operation &a, const Operation &b)
		{ return a.x == b.x ? a.t < b.t : a.x < b.x; });

	memset(seg_color, -1, sizeof(seg_color));
	memset(seg_tag, -1, sizeof(seg_tag));

	for (int i = 1; i <= n * 2 + m; ++i) {
		if (op[i].t == 1)
			change(root, op[i].y1, op[i].y2, father[op[i].id], 1, LIM);
		else if (op[i].t == -1) {
			int fa = query(root, op[i].y1, 1, LIM);
			if (fa == -1) fa = 0;
			father[op[i].id] = fa;
			son[fa].push_back(op[i].id);
			change(root, op[i].y1, op[i].y2, op[i].id, 1, LIM);
		} else {
			int w = query(root, op[i].y1, 1, LIM);
			if (w != -1)
				set[w].insert(op[i].id);
		}
	}

	dsu_on_tree(0);

	for (int i = 1; i <= n; ++i)
		printf("%d\n", ans[i]);
	return 0;
}
```


---

## 作者：初春饰利 (赞：4)

题面很长，可往往真正有用的题意却没有这么长，例如说这么一句：
- 
       床单放在上面，使它们之间角或边不会互相接触，
       边也不会相交，但他可能把较小的床单放在大的上面，或者一个完全覆盖另个。

从这句话中，我们可以看出，矩形是不会相交的，且只有包含关系。所以，我们仅需记录一个矩形的父亲为包含它的所有矩形中最小的那个，原图可由此化为一棵森林。

那么，我们怎么构造一个森林呢？我们这里有两种方法：
- 用扫描线，线段树处理y轴，每次找到一个矩形之后判断这个矩形的下边界是否合法，如不合法就倍增往其父亲走，直到合法。
- 对于y轴，我们建一棵标记永久化的线段树。扫到左边界时，直接把标记打到相应区间，直接覆盖。

构造出森林过后，我们就可以在此森林上进行线段树合并或者是set启发式合并即可。
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<set>
#include<queue>
#include<ctime>
#define MAXN 200005
#define ll long long
#define maxn 15
#define maxs 1000005
#define inf 1e9
#define eps 1e-9
using namespace std;
inline char gc() {
	static char now[1<<16],*S,*T;
	if (T==S) {
		T=(S=now)+fread(now,1,1<<16,stdin);
		if (T==S) return EOF;
	}
	return *S++;
}
inline ll readlong() {
	ll x=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9') {
		if(ch=='-')f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9') {
		x*=10;
		x+=ch-'0';
		ch=getchar();
	}
	return x*f;
}
inline int read() {
	int x=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9') {
		if(ch=='-')f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9') {
		x*=10;
		x+=ch-'0';
		ch=getchar();
	}
	return x*f;
}
void putint(long long t) {
	int ans[40]= {0};
	for(; t; t/=10)ans[++ans[0]]=t%10;
	for(; ans[0]; ans[0]--)putchar('0'+ans[ans[0]]);
	putchar('\n');
}
const int N=500005;
int n,m;
struct edge{
	int to,nxt;
}e[N];
int h[N],cnt;
void add(int x,int y){
//	cout<<x<<' '<<y;
	e[++cnt]=(edge){y,h[x]};
	h[x]=cnt;
}
int pre[N],_k[N],_y[N],rt[N];
int ans[N];
int dx,dy,dv;
int g[N<<5];
int col[N<<5],f[N<<5][2];
int cntt,cnty,cnts;
int tot;
struct bed{
	int x,y,k,i;
	bool operator <(const bed &a)const{
		if(x==a.x){
			return i>a.i;
		}
		return x<a.x;
	}
}mp[N<<2];
int query(int x,int l,int r){
	if(g[x]>=0||l==r){
		return g[x];
	}
	if(!x){
		return 0;
	}
	int mid=(l+r)>>1;
	if(dx<=mid){
		return query(x<<1,l,mid);
	}
	else{
		return query(x<<1|1,mid+1,r);
	}
}
void push(int x){
	if(g[x]<0){
		return ;
	}
	g[x<<1]=g[x<<1|1]=g[x];
	g[x]=-1;
}
void modify(int x,int l,int r){
//	cout<<"Asdf"<<endl;
	if(dx<=l&&dy>=r){
		g[x]=dv;
		return ;
	}
	push(x);
	int mid=(l+r)>>1;
	if(dx<=mid){
		modify(x<<1,l,mid);
	}
	if(dy>mid){
		modify(x<<1|1,mid+1,r);
	}
}
void add_cor(int &x,int l,int r){
	if(!x){
		x=++tot;
	}
	if(l==r){
		col[x]=1;
		return;
	}
	int mid=(l+r)>>1;
	if(dx<=mid){
		add_cor(f[x][0],l,mid);
	}
	else{
		add_cor(f[x][1],mid+1,r);
	}
	col[x]=col[f[x][0]]+col[f[x][1]];
}
int merge(int a,int b,int l,int r){
	if(!a|!b){
		return a^b;
	}
	if(l==r){
		return a;
	}
	int mid=(l+r)>>1;
	f[a][0]=merge(f[a][0],f[b][0],l,mid);
	f[a][1]=merge(f[a][1],f[b][1],mid+1,r);
	col[a]=col[f[a][0]]+col[f[a][1]];
	return a;
}
void dfs(int x){
	for(int i=h[x];i;i=e[i].nxt){
		int y=e[i].to;
		if(y!=pre[x]){
			dfs(y);
			rt[x]=merge(rt[x],rt[y],1,cnts);
		}
	}
	ans[x]=col[rt[x]];
}
int main(){
	memset(g,-1,sizeof(g));
	n=read();
	m=read();
	for(int i=1;i<=n;i++){
		int a=read();
		int b=read();
		int c=read();
		int d=read();
		mp[++cntt]=(bed){a,b,d,i};
		_y[++cnty]=b;
		mp[++cntt]=(bed){c,b,d,-i};
		_y[++cnty]=d;
	}
	for(int i=1;i<=m;i++){
		int x=read();
		int y=read();
		int k=read();
		mp[++cntt]=(bed){x,y,k,0};
		_y[++cnty]=y;
		_k[++cnts]=k;
	}
	sort(_y+1,_y+1+cnty);
	cnty=unique(_y+1,_y+1+cnty)-_y-1;
	sort(_k+1,_k+1+cnts);
	cnts=unique(_k+1,_k+1+cnts)-_k-1;
	sort(mp+1,mp+cntt+1);
	for(int i=1;i<=cntt;i++){
		mp[i].y=lower_bound(_y+1,_y+1+cnty,mp[i].y)-_y;
		if(mp[i].i){
			mp[i].k=lower_bound(_y+1,_y+1+cnty,mp[i].k)-_y;
			if(mp[i].i>0){
				dx=mp[i].y;
				dy=mp[i].k;
				dv=mp[i].i;
				if((pre[dv]=query(1,1,cnty))>0){
					add(pre[dv],dv);
				}
				modify(1,1,cnty);
				continue;
			}
			dx=mp[i].y;
			dy=mp[i].k;
			dv=max(pre[-mp[i].i],0);
			modify(1,1,cnty);
			continue;
		}
		mp[i].k=lower_bound(_k+1,_k+cnts+1,mp[i].k)-_k;
		dx=mp[i].y;
		int tmp=query(1,1,cnty);
		if(tmp>0){
			dx=mp[i].k;
			add_cor(rt[tmp],1,cnts);
		}
	}
	for(int i=1;i<=n;i++){
		if(pre[i]<=0){
			dfs(i);
		}
	}
	for(int i=1;i<=n;i++){
		printf("%d\n",ans[i]);
	}
	return 0;
}

```

---

## 作者：IkunTeddy (赞：1)

# 题目分析

**引理：** 对于任意个几何图形，若他们间只存在包含或相邻关系，那么他们可以构成一个森林。

有了这个性质，我们就可以把这道题的平面直角坐标系转到树上，考虑树上算法解决。

现在我们考虑修改的影响，不难发现，这次修改会对包含其的最小矩形到根节点上的一根链产生影响，直接暴力改这根链，肯定是超时的。这里树链剖分当然可以解决，但是我们可以通过树上差分更简单的完成，然后就类似[[Vani有约会] 雨天的尾巴](https://www.luogu.com.cn/problem/P4556)一样 dfs 一遍线段树合并上去即可。

现在的问题就是，如何建出这片森林呢？矩形，二维信息，我们可以考虑扫描线降一维，这里就考虑扫 $y$ 轴，另一维用一个值域数据结化换量。

1. 如果碰到下边界，那么当前覆盖这个坐标区间的矩形，就是他的父亲。

2. 如果碰到了上边界，我们就要把这个矩形删除掉，用新的矩形来重新覆盖这段区间，这个矩形其实就是他的父亲。

![](https://cdn.luogu.com.cn/upload/image_hosting/grodiaat.png)

看上面这张图，我们先扫到红色矩形的下边界，发现 $1 \sim 6$ 这个区间并没有被覆盖，说明红色矩形没有父亲，我们再将 $1\sim 6$ 这个区间覆盖成红色。

接下来扫到蓝色矩形的下边界，发现 $2\sim 4$ 这个区间被红色覆盖了，说明蓝色矩形的父亲就是红色矩形，再将 $2\sim4$ 覆盖成蓝色。

接下来扫到蓝色区间的上边界，蓝色这个矩形就结束了，所以我们考虑把他的影响删掉，我们发现蓝色矩形一出去就是红色矩形，即他的父亲，那我们将蓝色矩形的 $2\sim 4$ 区间覆盖成他父亲的颜色，即可消除他的影响。

操作流程为：

1. 找到父亲。
2. 将自己的区间覆盖。
3. 消除自己的影响，即将自己的区间覆盖成父亲。

所以我们需要一个能够区间覆盖的数据结构，线段树或平衡树都可以。

需要合并的线段树以颜色作为下标即可统计答案。

有一个易错点是懒标记的初始值一定要设为 $-1$，因为有可能会区间覆盖成 $0$。

# Code
```cpp
#include<bits/stdc++.h>
const int maxn=2e5+10;
int n,q;
int disc[maxn*3],N,col[maxn],c;
int fa[maxn],bel[maxn];
int ans[maxn];
void Disc(int &x){ //离散化
	x=lower_bound(disc+1,disc+1+N,x)-disc;
}
struct Edge{
	int v,next;
}edge[maxn];
int head[maxn],tot;
void add_edge(int u,int v){
	edge[++tot].v=v;
	edge[tot].next=head[u];
	head[u]=tot;
}
struct Mat{
	int x1,y1,x2,y2;
}mat[maxn];
struct Upt{
	int x,y,k;
}upt[maxn];
struct scan{
	int x1,x2,id;
};
vector<scan>add[maxn*3],del[maxn*3],qry[maxn*3];
//扫描线
int rt[maxn],node;
struct Node{
	int ls,rs;
	int col,s;
	Node(){
		col=-1; //一定要设为-1
	}
}tree[maxn*16];
void pushdown(int v){
	if(tree[v].col==-1)return ;
	if(!tree[v].ls)tree[v].ls=++node;
	if(!tree[v].rs)tree[v].rs=++node;
	tree[tree[v].ls].col=tree[v].col;
	tree[tree[v].rs].col=tree[v].col;
	tree[v].col=-1;
}
int ask(int v,int l,int r,int x){
	if(!v)return 0;
	if(l==r)return tree[v].col;
	int mid=(l+r)>>1;
	pushdown(v);
	if(x<=mid)return ask(tree[v].ls,l,mid,x);
	else return ask(tree[v].rs,mid+1,r,x);
}
void pushup(int v){
	tree[v].s=tree[tree[v].ls].s+tree[tree[v].rs].s;
}
void update(int &v,int l,int r,int x,int y,int k,int flg){
	if(l>y||r<x)return ;
	if(!v)v=++node;
	if(l>=x&&r<=y){
		if(!flg)tree[v].col=k;
		else tree[v].s=k;
		return ; 
	}
	if(!flg)pushdown(v);
	int mid=(l+r)>>1;
	update(tree[v].ls,l,mid,x,y,k,flg);
	update(tree[v].rs,mid+1,r,x,y,k,flg);
	if(flg)pushup(v);
}
int merge(int x,int y,int l,int r){
	if(!x||!y)return x|y;
	if(l==r){
		tree[x].s=tree[x].s|tree[y].s;
		return x;
	}
	int mid=(l+r)>>1;
	tree[x].ls=merge(tree[x].ls,tree[y].ls,l,mid);
	tree[x].rs=merge(tree[x].rs,tree[y].rs,mid+1,r);
	pushup(x);
	return x;
}
void dfs(int u){
	for(int i=head[u];i;i=edge[i].next){
		int v=edge[i].v;
		dfs(v);
		rt[u]=merge(rt[u],rt[v],1,c);// 线段树合并
	}
	ans[u]=tree[rt[u]].s;
}
int main(){
	cin>>n>>q;
	for(int i=1;i<=n;i++){
		cin>>mat[i].x1>>mat[i].y1>>mat[i].x2>>mat[i].y2;
		disc[++N]=mat[i].x1,disc[++N]=mat[i].y1,disc[++N]=mat[i].x2,disc[++N]=mat[i].y2;
	}
	for(int i=1;i<=q;i++){
		cin>>upt[i].x>>upt[i].y>>upt[i].k;
		disc[++N]=upt[i].x,disc[++N]=upt[i].y,col[++c]=upt[i].k;
	}
	sort(disc+1,disc+1+N);
	N=unique(disc+1,disc+1+N)-disc-1;
	sort(col+1,col+1+c);
	c=unique(col+1,col+1+c)-col-1;
	for(int i=1;i<=n;i++){
		Disc(mat[i].x1),Disc(mat[i].y1),Disc(mat[i].x2),Disc(mat[i].y2);
		add[mat[i].y1].push_back({mat[i].x1,mat[i].x2,i});
		del[mat[i].y2].push_back({mat[i].x1,mat[i].x2,i});
	}
	for(int i=1;i<=q;i++){
		Disc(upt[i].x),Disc(upt[i].y);
		upt[i].k=lower_bound(col+1,col+1+c,upt[i].k)-col;
		qry[upt[i].y].push_back({upt[i].x,upt[i].k,i});
	}
	for(int i=1;i<=N;i++){ //扫描线时各操作的顺序不能错
		for(int j=0;j<add[i].size();j++){
			int id=add[i][j].id;
			fa[id]=ask(rt[0],1,N,add[i][j].x1);
			if(fa[id]==-1)fa[id]=0;
			add_edge(fa[id],id);
			update(rt[0],1,N,add[i][j].x1,add[i][j].x2,id,0);
		}
		for(int j=0;j<qry[i].size();j++){
			int id=qry[i][j].id;
			bel[id]=ask(rt[0],1,N,qry[i][j].x1);
		}
		for(int j=0;j<del[i].size();j++){
			int id=del[i][j].id;
			update(rt[0],1,N,del[i][j].x1,del[i][j].x2,fa[id],0);
		}
	}
	memset(tree,0,sizeof(tree));
	for(int i=1;i<=q;i++){
		update(rt[bel[i]],1,c,upt[i].k,upt[i].k,1,1);
	}
	for(int i=1;i<=n;i++){
		if(!fa[i])dfs(i);
	}
	for(int i=1;i<=n;i++)cout<<ans[i]<<'\n';

	return 0;
}
```

---

## 作者：_Wind_Leaves_ShaDow_ (赞：0)

观察到一维数颜色需要记录前驱，而二维数颜色看起来不好刻画前驱后继的概念，看起来不是很可做。于是我们把目光注意到该题特殊的矩形包含关系上。

分析可知若矩形 $A$ 直接包含矩形 $B$，则矩形 $A$ 的颜色集合包含 $B$ 的颜色集合。将直接包含关系建一条边，观察到形成了一个森林。

对于森林，父亲节点包含儿子节点所有集合的题目是很经典的线段树合并问题。这一部分的复杂度 $O(n\log n)$，默认 $n,q$ 同阶。

考虑如何找到一个节点的父亲节点。

对于坐标系从下往上扫描线，记录一个矩形覆盖区间，发现第一次覆盖时这一段原矩形编号即为这个点的父亲，并且由于区间不会相交这一段只有一种编号。

退出这个矩形时显然它的父亲还没有被删除，直接把自己属于的这一段覆盖成父亲的编号即可。

思考经历还是很顺利的。

```cpp
#include <bits/stdc++.h>
#define lint __int128
#define int long long
#define fi first
#define se second
#define Il inline
#define vec vector
#define pb push_back
#define IT ::iterator
#define p_q priority_queue

using namespace std;
typedef long long ll;
typedef pair<int,int> pii;
typedef double db;
const int N=3e5;
const db eps=1e-9,pi=acos(-1.0);

mt19937 rnd(time(0));
Il int rint(int l,int r){return rnd()%(r-l+1)+l;}

int n,Q,vt[N+5],lsh[N+5],dn=0,qn=0,dc=0,ans[N+5];
vec<int>v[N+5];
struct Node{int xa,ya,xb,yb;}a[N+5],qs[N+5];
struct Op{int ps,lq,rq,c,op;Il bool operator <(const Op &s)const{return (ps^s.ps?ps<s.ps:op>s.op);}}qu[N+5];
int co[(N<<2)+5],tg[(N<<2)+5];
int id=0,sg[N*16+5],ls[N*16+5],rs[N*16+5],rt[N+5];

Il void Disc(){
    for(int i=1;i<=n;i++)lsh[++dn]=a[i].xa,lsh[++dn]=a[i].xb;
    for(int i=1;i<=Q;i++)lsh[++dn]=qs[i].xa;
    sort(lsh+1,lsh+dn+1);dn=unique(lsh+1,lsh+dn+1)-lsh-1;
    for(int i=1;i<=n;i++)a[i].xa=lower_bound(lsh+1,lsh+dn+1,a[i].xa)-lsh,a[i].xb=lower_bound(lsh+1,lsh+dn+1,a[i].xb)-lsh;
    for(int i=1;i<=Q;i++)qs[i].xa=lower_bound(lsh+1,lsh+dn+1,qs[i].xa)-lsh;
    for(int i=1;i<=Q;i++)lsh[i]=qs[i].xb;
    sort(lsh+1,lsh+Q+1);dc=unique(lsh+1,lsh+Q+1)-lsh-1;
    for(int i=1;i<=Q;i++)qs[i].xb=lower_bound(lsh+1,lsh+dc+1,qs[i].xb)-lsh;
    return;
}

Il void pown(int p){
    if(tg[p]<0)return;
    tg[p<<1]=tg[p<<1|1]=co[p<<1]=co[p<<1|1]=tg[p];tg[p]=-1;
    return;
}

Il int qps(int ps,int l,int r,int p){
    if(l==r)return co[p];
    int mid=(l+r)>>1;pown(p);
    if(ps<=mid)return qps(ps,l,mid,p<<1);
    return qps(ps,mid+1,r,p<<1|1);
}

Il void cov(int ql,int qr,int l,int r,int p,int K){
    if(ql<=l&&r<=qr){co[p]=tg[p]=K;return;}
    int mid=(l+r)>>1;pown(p);
    if(ql<=mid)cov(ql,qr,l,mid,p<<1,K);
    if(qr>mid)cov(ql,qr,mid+1,r,p<<1|1,K);
    return;
}

Il void add(int ps,int l,int r,int &p){
    if(!p)p=++id;
    if(l==r){sg[p]=1;return;}
    int mid=(l+r)>>1;
    if(ps<=mid)add(ps,l,mid,ls[p]);
    else add(ps,mid+1,r,rs[p]);
    sg[p]=sg[ls[p]]+sg[rs[p]];
    return;
}

Il int merge(int x,int y){
    if(!x||!y)return x|y;
    if(!ls[x]&&!rs[x]){sg[x]|=sg[y];return x;}
    ls[x]=merge(ls[x],ls[y]),rs[x]=merge(rs[x],rs[y]);
    sg[x]=sg[ls[x]]+sg[rs[x]];
    return x;
}

Il void dfs(int p){
    for(int i:v[p])dfs(i),rt[p]=merge(rt[p],rt[i]);
    ans[p]=sg[rt[p]];
    return;
}

signed main(){
    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
    cin>>n>>Q;for(int i=1;i<=n;i++)cin>>a[i].xa>>a[i].ya>>a[i].xb>>a[i].yb;
    for(int _=1;_<=Q;_++)cin>>qs[_].xa>>qs[_].ya>>qs[_].xb;
    Disc();
    for(int i=1;i<=n;i++){
        qu[++qn]={a[i].ya,a[i].xa,a[i].xb,i,2};
        qu[++qn]={a[i].yb,a[i].xa,a[i].xb,i,0};
    }
    for(int _=1;_<=Q;_++)qu[++qn]={qs[_].ya,qs[_].xa,qs[_].xb,_,1};
    sort(qu+1,qu+qn+1);
    for(int i=1;i<=qn;i++){
        if(qu[i].op==1){
            int po=qps(qu[i].lq,1,dn,1);
            if(po)add(qu[i].rq,1,dc,rt[po]);
        }else{
            int cc=qps(qu[i].lq,1,dn,1);
            if(qu[i].op==0)cov(qu[i].lq,qu[i].rq,1,dn,1,vt[qu[i].c]);
            else vt[qu[i].c]=cc,cov(qu[i].lq,qu[i].rq,1,dn,1,qu[i].c);
        }
    }
    for(int i=1;i<=n;i++)v[vt[i]].pb(i);
    for(int i=1;i<=n;i++)if(!vt[i])dfs(i);
    for(int i=1;i<=n;i++)cout<<ans[i]<<'\n';
    return 0;
}
```

---

## 作者：Gmt丶FFF (赞：0)

#### 题意简述：

给定 $n$ 个互不相交，可以重叠的矩阵，对某些点染色，这个点上的所有矩阵会被染上这个颜色，求最后每个矩阵会有多少种颜色。

---

#### 解：

我们可以先把矩阵拆成上下两条水平线段，然后离线将染色与线段横坐标离散化，以纵坐标将矩阵将线段与染色一起处理。

维护一棵线段树，对于一个矩阵的下方线段加入，直接在线段树对应节点将其入栈，对于上方线段，直接在对应节点弹出栈顶即可，因为矩阵无相交，所以栈顶一定是需要弹出的线段。

对于染色操作，我们找到线段树对应的栈顶元素，用 set 记录一下。

由于若将大矩阵覆盖小矩阵看成大矩阵为小矩阵的父亲节点，那么不难发现这是棵森林，所以我们对于染色的节点，它们父亲也需要染这个颜色，这个就遍历一遍树用启发式合并即可。

时间复杂度：$O(n\times \log_2^2(n))$。

```cpp
#include<iostream>
#include<cstdio>
#include<vector>
#include<set> 
#include<stack>
#include<algorithm>
using namespace std;
const int N=8e4+5;
int n,m,cnt,ans[N],cnp,ru[N],len1[12*N],len2[12*N];
set<int>num[N];
vector<int>b[N];
struct node
{
	int name,x,y,h,k,flag;
}a[3*N];
struct node2
{
	int name,data;
	bool flag;
}t[3*N];
int cmp(node2 fi,node2 se)
{
	return fi.data<se.data;
}
int cmp2(node fi,node se)
{
	if(fi.h==se.h)return fi.flag<se.flag;
	return fi.h<se.h;
}
vector<int>f[12*N];
inline int ls(int x)
{
	return x<<1;
}
inline int rs(int x)
{
	return x<<1|1;
}
void update(int x,int l,int r,int nl,int nr,int id,bool flag)
{
	if(l>=nl&&r<=nr)
	{
		if(flag==0)
		{
			if(len1[x]==len2[x])f[x].push_back(id),len1[x]++,len2[x]++;
			else f[x][len1[x]++]=id;
		}
		else len1[x]--;
		return;
	}
	int mid=(l+r)>>1;
	if(mid>=nl)update(ls(x),l,mid,nl,nr,id,flag);
	if(mid<nr)update(rs(x),mid+1,r,nl,nr,id,flag);
}
int search(int x,int l,int r,int nl)
{
	int ans=0;
	if(len1[x]>0)ans=f[x][len1[x]-1];
	if(l==r)return ans;
	int mid=(l+r)>>1;
	
	if(mid>=nl)ans=max(ans,search(ls(x),l,mid,nl));
	else ans=max(ans,search(rs(x),mid+1,r,nl));
	return ans;
}
void dfs(int x)
{
	int len=b[x].size();
	for(int i=0;i<len;i++)
	{
		dfs(b[x][i]);
		if(num[b[x][i]].size()>num[x].size())swap(num[x],num[b[x][i]]);
		for(set<int>::iterator j=num[b[x][i]].begin();j!=num[b[x][i]].end();j++)num[x].insert(*j);
	}
	ans[x]=num[x].size();
}
int main()
{
	//freopen("plahteplahte.in","r",stdin);
	//freopen("Plahte.out","w",stdout);
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
	{
		scanf("%d%d%d%d",&a[i*2-1].x,&a[i*2-1].h,&a[i*2].y,&a[i*2].h);
		a[i*2-1].name=a[i*2].name=i;
		a[i*2-1].y=a[i*2].y;
		a[i*2].x=a[i*2-1].x;
		t[++cnp]={i,a[i*2-1].x,0};
		t[++cnp]={i,a[i*2-1].y,1};
		a[i*2-1].flag=0;
		a[i*2].flag=2;
	}
	for(int i=1;i<=m;i++)
	{
		scanf("%d%d%d",&a[i+2*n].x,&a[i+2*n].h,&a[i+2*n].k);
		t[++cnp]={i+2*n,a[i+2*n].x,0};
		a[i+2*n].flag=1;
	}
	sort(t+1,t+1+cnp,cmp);
	t[0].data=-1;
	for(int i=1;i<=cnp;i++)
	{
		if(t[i].data!=t[i-1].data)cnt++;
		if(t[i].flag==0)
		{
			if(t[i].name<=2*n)a[t[i].name*2-1].x=a[t[i].name*2].x=cnt;
			else a[t[i].name].x=cnt;
		}
		else a[t[i].name*2-1].y=a[t[i].name*2].y=cnt;
	}
	sort(a+1,a+1+2*n+m,cmp2);
	for(int i=1;i<=2*n+m;i++)
	{
		//cout<<a[i].name<<" "<<a[i].x<<" "<<a[i].y<<" "<<a[i].flag<<endl;
		if(a[i].flag==0)
		{
			int x=search(1,1,cnt,a[i].x);
			if(x)b[a[x].name].push_back(a[i].name),ru[a[i].name]++;
			update(1,1,cnt,a[i].x,a[i].y,i,0);
		}
		else if(a[i].flag==1)
		{
			int x=search(1,1,cnt,a[i].x);
			if(x)num[a[x].name].insert(a[i].k);
		}
		else update(1,1,cnt,a[i].x,a[i].y,i,1);
	}
	for(int i=1;i<=n;i++)if(!ru[i])dfs(i);
	for(int i=1;i<=n;i++)printf("%d\n",ans[i]);
	return 0;
}
```


---


# [THUSC 2015] 平方运算

## 题目描述

小 H 是一位勤奋的中学生，他的理想是进入自己心仪的大学学习计算机专业。为了实现这一目标。他从小就开始认真学习信息学竞赛的基础知识。

今天，小 H 学习了平方运算。为了检验自己是否熟练掌握了平方运算，小 H 决定给自己出一道题。小 H 有一个长度为 $N$ 的序列 ${X_1,X_2,\cdots,X_N}$。小 H 会时不时地取出 列中的一段连续区间 $[l,r]$，并将其中的每一个数改为原数值的平方对 $P$ 取模的结果，其中 $P$ 为某个给定的数。为了检验自己的运算是否正确，小 $H$ 还会时不时地想要知道序列中某一段连续区间 $[l,r]$ 内所有数的和是多少。

但是，小 H 现在并没有标准答案。所以，他向你求助，希望你编写一个程序，帮他计算出每次想要知道的区间内的数的和。 

## 说明/提示

$1\leq N,M\leq 10^{5}$。

$$
\begin{aligned}P\in \{233,2332,5,8192,23,45,37,4185,5850,2975,2542,\\2015,2003,2010,4593,4562, 1034,5831,9905,9977\}
\end{aligned}
$$

## 样例 #1

### 输入

```
1 3 233
1 
2 1 1
1 1 1
2 1 1
```

### 输出

```
1
1
```

## 样例 #2

### 输入

```
4 3 5
1 2 3 4 
2 1 4
1 2 4
2 2 3
```

### 输出

```
10
8
```

# 题解

## 作者：disposrestfully (赞：10)

这么一道题没人写题解.

那么一血是我的了.

> 给你一个序列,要求支持区间平方(对$P$取模)和区间求和

> 数据范围中给出了所有可能的$P$

一看就知道这个模数肯定有一些特殊性质.

模意义下的平方运算显然是具有循环节的.

然后我们打个表,发现所有循环节长度的$LCM \le 60$,并且每个数平方不超过$11$次就会进入一个循环节.

然后我们对于没有进入循环节的数暴力修改，进入循环节之后就直接跳,复杂度$O(\omega nlogn)$

``` cpp
#include<bits/stdc++.h>
#define read() Read<int>()
namespace pb_ds{   
    namespace io{
        const int MaxBuff=1<<15;
        const int Output=1<<23;
        char B[MaxBuff],*S=B,*T=B;
		#define getc() ((S==T)&&(T=(S=B)+fread(B,1,MaxBuff,stdin),S==T)?0:*S++)
        char Out[Output],*iter=Out;
        inline void flush(){
            fwrite(Out,1,iter-Out,stdout);
            iter=Out;
        }
    }
    template<class Type> inline Type Read(){
        using namespace io;
        register char ch;
        register Type ans=0; 
        register bool neg=0;
        while(ch=getc(),(ch<'0' || ch>'9') && ch!='-');
        ch=='-'?neg=1:ans=ch-'0';
        while(ch=getc(),'0'<= ch && ch<='9') ans=ans*10+ch-'0';
        return neg?-ans:ans;
    }
    template<class Type> inline void Print(register Type x,register char ch='\n'){
        using namespace io;
        if(!x) *iter++='0';
        else{
            if(x<0) *iter++='-',x=-x;
            static int s[100]; 
            register int t=0;
            while(x) s[++t]=x%10,x/=10;
            while(t) *iter++='0'+s[t--];
        }
        *iter++=ch;
    }
}
using namespace pb_ds;
using namespace std;
typedef long long ll;
const int N=1e5+5;
const int M=1e4+5;
int n,m,q,Mod;
int vis[M],p[M];
int gcd(int x,int y){
	if (!y) return x;
	return gcd(y,x%y);
}
inline int lcm(int x,int y){
	return (x*y)/gcd(x,y);
}
namespace seg{
	#define ls (x<<1)
	#define rs (ls|1)
	#define mid ((l+r)>>1)
	bool lp[N<<2];
	int now[N<<2],tag[N<<2];
	ll sum[N<<2][60];
	inline void chk(int x){
		if (p[sum[x][0]]){
			for (int i=1;i<m;++i)
				sum[x][i]=sum[x][i-1]*sum[x][i-1]%Mod;
			now[x]=0,lp[x]=1;
		}else now[x]=lp[x]=0;
	}
	inline void Add(int x,int k){
		tag[x]=(tag[x]+k)%m;
		now[x]=(now[x]+k)%m;
	}
	inline void pushup(int x){
		lp[x]=lp[ls]&lp[rs],now[x]=0;
		if (!lp[x]) sum[x][0]=sum[ls][now[ls]]+sum[rs][now[rs]];
		else{
			int lx=now[ls],rx=now[rs];
			for (int i=0;i<m;++i){
				sum[x][i]=sum[ls][lx]+sum[rs][rx];
				lx=(lx+1)%m,rx=(rx+1)%m;
			}
		}
	}
	inline void pushdown(int x){
		if (tag[x]){
			Add(ls,tag[x]);
			Add(rs,tag[x]);
			tag[x]=0;
		}
	}
	void build(int x,int l,int r){
		if (l==r){
			sum[x][0]=read();
			tag[x]=0,chk(x);
			return;
		}
		build(ls,l,mid);
		build(rs,mid+1,r);
		pushup(x);
	}
	void update(int x,int l,int r,int L,int R){
		if (L<=l && r<=R && lp[x]){
			Add(x,1);
			return;
		}
		if (l==r){
			sum[x][0]=sum[x][0]*sum[x][0]%Mod;
			chk(x);
			return;
		}
		pushdown(x);
		if (L<=mid) update(ls,l,mid,L,R);
		if (R>mid) update(rs,mid+1,r,L,R);
		pushup(x);
	}
	ll query(int x,int l,int r,int L,int R){
		if (L<=l && r<=R) return sum[x][now[x]];
		ll res=0;
		pushdown(x);
		if (L<=mid) res+=query(ls,l,mid,L,R);
		if (R>mid) res+=query(rs,mid+1,r,L,R);
		return res;
	}
}
using namespace seg;
inline void get_loop(int x){
	for (int i=1,y=x;;++i,y=y*y%Mod){
		if (vis[y]){
			p[y]=i-vis[y];
			break;
		}else vis[y]=i;
	}
	for (int y=x;vis[y];y=y*y%Mod) vis[y]=0;
}
int main(){
	n=read(),q=read(),Mod=read(),m=1;
	for (int i=0;i<Mod;++i) get_loop(i);
	for (int i=0;i<Mod;++i)
		if (p[i]) m=lcm(p[i],m);
	build(1,1,n);
	while (q--){
		int opt=read(),l=read(),r=read();
		if (opt&1) update(1,1,n,l,r);
		else Print(query(1,1,n,l,r));
	}
	io::flush();
	return 0;
}

---

## 作者：Leap_Frog (赞：8)

### P.S.
高质量好数据结构。  
一直拍挂 ![](//xn--9zr.tk/px)  
对拍建议 $n=2,m=100000$ 这样调试难度低一点 qwq。  
目前最优解看人头 rank2，不过我这种写法应该会自带大常数。  

### Description.
维护序列，要求支持：区间平方修改为模 $P$，查寻区间和。  

### Solution.
首先，我们发现，平方运算具有循环节。  
打个表会发现题目中所有模下，循环节长度 $\text{lcm}$ 最大值为 $60$。  
那么我们就可以考虑直接暴力，如果进入循环节了就直接开桶修改。  
然后就做完了欸。  
注意是区间修改，必须要打 lazetag。  
注意无法预处理一个区间的答案，因为这个区间的子区间可能会被操作。  
具体看代码及其注释吧 ![](//xn--9zr.tk/ts)  

### Coding.
```cpp
//是啊……你就是那只鬼了……所以被你碰到以后，就轮到我变成鬼了{{{
#include<bits/stdc++.h>
using namespace std;typedef long long ll;
template<typename T>inline void read(T &x)
{
	x=0;char c=getchar(),f=0;
	for(;c<48||c>57;c=getchar()) if(!(c^45)) f=1;
	for(;c>=48&&c<=57;c=getchar()) x=(x<<1)+(x<<3)+(c^48);
	f?x=-x:x;
}/*}}}*/
int n,m,P,a[100005],deg[10005];char v[10005];
struct segm{int smt,nw,sm[61],lz;char tag;}T[400005];
//tag代表当前区间是否全部进入循环节
//smt代表当前区间桶的循环节（为0代表未进入循环节
//sm表示桶，nw表示当前在桶中位置
//lz表示lazetag
//如果未进入循环节 sm[0] 表示当前这个点的权值
inline int gcd(int a,int b) {return b?gcd(b,a%b):a;}
inline int sqr(int x) {return x*x%P;}
inline void pushup(int x)
{
	T[x].tag=T[x<<1].tag&T[x<<1|1].tag;
	if(!T[x].smt) T[x].sm[0]=T[x<<1].sm[T[x<<1].nw]+T[x<<1|1].sm[T[x<<1|1].nw];
	if(T[x<<1].smt&&T[x<<1|1].smt)
	{
		int nl=T[x<<1].smt,nr=T[x<<1|1].smt,lw=T[x<<1].nw,rw=T[x<<1|1].nw;
		T[x].smt=nl/gcd(nl,nr)*nr,T[x].nw=0;//公共循环节长度是 lcm
		for(int i=0;i<T[x].smt;i++) T[x].sm[i]=T[x<<1].sm[(i+lw)%nl]+T[x<<1|1].sm[(i+rw)%nr];
		//把两个桶合并，注意两边不一定从起点开始，可能已经移动过了。  
	}
}
inline void allc(int x,int c) {T[x].nw=(T[x].nw+c)%T[x].smt,T[x].lz+=c;}
inline void pushdw(int x) {if(T[x].lz) allc(x<<1,T[x].lz),allc(x<<1|1,T[x].lz),T[x].lz=0;}
inline void INIT(int x)
{//预处理一个结点的桶信息
	for(int i=1;i<=60;i++)
	{
		T[x].sm[i]=sqr(T[x].sm[i-1]);//找到循环节
		if(T[x].sm[i]==T[x].sm[0]) {T[x].smt=i;break;}
	}
}
inline void build(int x,int l,int r)
{//无难点，不解释
	if(l==r) return T[x].sm[T[x].smt=0]=a[l],void();
	build(x<<1,l,(l+r)>>1),build(x<<1|1,((l+r)>>1)+1,r),pushup(x);
}
inline void modif(int x,int l,int r,int dl,int dr)
{
	if(l>dr||dl>r) return;else if(dl>l||r>dr)
		return pushdw(x),modif(x<<1,l,(l+r)>>1,dl,dr),modif(x<<1|1,((l+r)>>1)+1,r,dl,dr),pushup(x);
	//如果小区间和大区间无包含关系，那就正常线段树处理。  
	if(T[x].tag) return allc(x,1),void();//如果已经进入循环节，直接打lazetag
	if(l^r) return pushdw(x),modif(x<<1,l,(l+r)>>1,dl,dr),modif(x<<1|1,((l+r)>>1)+1,r,dl,dr),pushup(x);
	//没进入循环节还不是叶结点，只能暴力向下
	if(v[T[x].sm[0]]) return T[x].sm[0]=sqr(T[x].sm[0]),void();
	//如果还在循环节外面，那就暴跳，否则就预处理了
	if(!T[x].tag) INIT(x),T[x].tag=1,T[x].nw=1%T[x].smt;else T[x].nw=(T[x].nw+1)%T[x].smt;
}
inline int query(int x,int l,int r,int dl,int dr)
{//无难点，不解释
	if(dl>r||l>dr) return 0;else if(dl<=l&&r<=dr) return T[x].sm[T[x].nw];else pushdw(x);
	return query(x<<1,l,(l+r)>>1,dl,dr)+query(x<<1|1,((l+r)>>1)+1,r,dl,dr);
}
int main()
{
	read(n),read(m),read(P);queue<int>q;
	for(int i=0;i<P;i++) deg[sqr(i)]++;
	for(int i=0;i<P;i++) if(!deg[i]) q.push(i);
	while(!q.empty())
	{
		int x=q.front();q.pop(),v[x]=1;
		if(!--deg[sqr(x)]) q.push(sqr(x));
	}//topo找环
	for(int i=1;i<=n;i++) read(a[i]);
	for(build(1,1,n);m--;)
	{
		int op,l,r;read(op),read(l),read(r);
		if(op&1) modif(1,1,n,l,r);else printf("%d\n",query(1,1,n,l,r));
	}
	return 0;
}
```

---

## 作者：wangziyue_AK (赞：3)

# 思路历程
## 引言
这是我在模拟赛时切掉的题，那题模数为 $998244353$，现在来写篇题解，并提供我的思路历程。
## 思考过程（及模数为 $998244353$ 的做法）
首先，区间平方这件事乍一看很奇怪，直接做树形结构显然不大可做，也不像分块（~~因为大分块里没有这题~~），所以考虑是否存在能只做常数次的特性，比如说平方若干次后均会变成 $1$，然后不断平方数字不变，但是打表发现并没有。模拟赛中的题是对 $998244353$ 取模，考虑平方操作即为质数乘二，那么对 $a_i$ 平方 $x$ 次就会变成 $a_i^{2^x} \bmod 998244353$ 应用欧拉定理可以得到指数为 $2^x \bmod998244352$，考虑到 $998244352$ 不是质数且因数中存在二的幂次，猜测存在循环节，打表发现需 $23$ 步进入循环节，循环节长为 $24$，数论大师可以看出 $998244352=2^{23} \times 119$，所以需 $23$ 步进入循环节，而循环节则是 $2^i\bmod 119$ 的循环节。剩下的部分是平凡的，维护一棵线段树上每个节点的循环节上以及进入循环节前每一步的值，以及当前在循环节的哪个位置，区间平方即在循环节上后移并打上标记，合并即暴力把离进入循环节近的合到远的上的，因为进入循环节后由于循环节长度相同则合并依旧构成长度不变的循环节。
## 本题还需要的
这题模数范围很小，但并不是质数，不能应用欧拉定理，而且模数有 $20$ 个，唯一方便的点是模数范围很小，提供一种便利的方法：对 $1$ 至 $p-1$  每个数的平方找循环节，最后再合并为环长为最小公倍数的环，最后发现环长均不超过 $60$，入环所需步数均不超过 $10$ 步，而步数多开一定不会出错，可以直接设个十几左右。
## 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+5;
typedef long long ll;
#define p2 (p<<1)
#define p3 ((p<<1)|1)
#define st 1,n,1
#define ls l,mid,p2
#define rs mid+1,r,p3
int mod,top,to;
struct xx{
	ll x[75];int wz; 
}tr[N<<2];
int a[N];
inline void pu(int p){
	xx l=tr[p2],r=tr[p3];
	if(l.wz>r.wz) swap(l,r);//考场上写反挂了60pts
	int nl=l.wz,nr=r.wz,la=l.wz;
	while(nl<=top){//入环前
		tr[p].x[nl]=l.x[nl]+r.x[nr];
		nl++,nr++;
		if(nr==top+1) nr=to;
	}
	if(la>to){
		nl=to;
		while(nl!=la){//环中
			tr[p].x[nl]=l.x[nl]+r.x[nr];
			nl++,nr++;
			if(nr==top+1) nr=to;
		}
	}
	tr[p].wz=l.wz;
}
int lz[N<<2];
inline void gai(int p,int x){//环shang后移x位
	lz[p]+=x;
	tr[p].wz+=x;
	int k=tr[p].wz-top;
	if(k<=0) return;//k:入环后多出的步数
	int hu=top-to+1;
	k=(k+hu-1)/hu;//hu环长
	tr[p].wz-=k*hu;
}
inline void pd(int p){
	if(!lz[p]) return;
	gai(p2,lz[p]),gai(p3,lz[p]);
	lz[p]=0;
}
void bld(int l,int r,int p){
	//memset(tr[p].x,0,sizeof(tr[p].x));
	if(l==r){
		tr[p].x[1]=a[l],tr[p].wz=1;
		for(int i=2;i<=top;i++){
			int x=tr[p].x[i-1];
			tr[p].x[i]=(1ll*x*x)%mod;
		}
		int x=tr[p].x[top];
		//if(tr[p].x[to]!=(1ll*x*x)%mod) printf("111\n");
		return;
	}
	int mid=(l+r)>>1;
	bld(ls),bld(rs);
	pu(p);
}
ll qiu(int l,int r,int p,int nl,int nr){
	if(l==nl&&r==nr) return tr[p].x[tr[p].wz];
	pd(p);
	int mid=(l+r)>>1,res;
	if(nr<=mid) res=qiu(ls,nl,nr);
	else if(nl>mid) res=qiu(rs,nl,nr);
	else res=qiu(ls,nl,mid)+qiu(rs,mid+1,nr);
	pu(p);
	return res;
}
void upd(int l,int r,int p,int nl,int nr){
	if(l==nl&&r==nr) return gai(p,1);
	int mid=(l+r)>>1;
	pd(p);
	if(nr<=mid) upd(ls,nl,nr);
	else if(nl>mid) upd(rs,nl,nr);
	else upd(ls,nl,mid),upd(rs,mid+1,nr);
	return pu(p);
}
map<int,int> mp;
inline int get(int x,int p){
	mp.clear();
	int nw=x,cnt=1;
	while(1){
		mp[nw]=cnt;
		nw=(1ll*nw*nw)%p;
		//printf("000 %d\n",nw);
		cnt++;
		if(mp[nw]) break;
	}
	return cnt-mp[nw];
}
int gcd(int x,int y){
	return y==0?x:gcd(y,x%y);
}
inline void lcm(int &x,int y){
	x=x/gcd(x,y)*y;
}
int n,q;
int main(){
	scanf("%d%d%d",&n,&q,&mod);
	int nw=1;
	for(int i=1;i<mod;i++) lcm(nw,get(i,mod));
	to=12,top=to+nw-1;
	for(int i=1;i<=n;i++) scanf("%d",&a[i]);
	bld(st);
	int op,l,r;
	for(int i=1;i<=q;i++){
		scanf("%d%d%d",&op,&l,&r);
		if(op==1) upd(st,l,r);
		else printf("%lld\n",qiu(st,l,r));
	}	
	return 0;
}
```

---

## 作者：cqbzlzm (赞：0)

### Description

给你一个序列 $a$，支持一下两种操作：

- 将区间 $[l,r]$ 中每个数平方后，对一个固定值 $mod$ 取模。
- 查询区间 $[l,r]$ 中所有数之和（不取模）。

其中 $mod\in {233,2332,5,8192,23,45,37,4185,5850,2975,2542,2015,2003,2010,4593,4562,1034,5831,9905,9977}$

**数据范围：**$1\leq n,m\leq 10^5$。

### Solution

首先发现 $mod$  很特殊，我们容易打表发现当模数是这些数时，对一个数进行多次平方的值是有周期的，数据特性，所有数周期的最小公倍数小于等于 60。

具体地说，一个数回先进行若干次平方进入这个周期的环，然后再在环上反复跳跃。那么我们考虑用**线段树**维护。

我们维护下面几个东西：

1. $ok_{id}$：表示线段树维护的这个区间的所有数是否**全部**进入了环。
2. $sum_{id,i}$：表示线段树维护的这个区间的所有数都进入环的情况下，跳 $i$ 步得到的值（即平方 $i$ 次的到的值）。
3. $v_{id}$：表示线段树维护的这个区间的和 是跳几步后的结果。
4. $tag_{id}$：懒惰标记。

特殊的，为了简化代码，当一个节点表示的区间没有全部进入环时，我们用 $sum_{id,v_{id}=0}$ 记录它当前的和。

维护的时候我们需要注意，当一个数从在环外到入环的临界点我们用 $siz$ 记录一下，用函数 $\operatorname{lg}$ 来处理一下新的 $sum$ 即可。

对于仍然没有进入环的节点，我们就只能暴力跳了。因为数据特殊，所以最多不会暴力跳超过 11 次。

### Code

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int MAXN = 100000, MAXMOD = 10000;
int lcm(int a, int b) {
    return a * b / __gcd(a, b);
}
int n, q, mod, M = 1;
int a[MAXN + 5];
struct node {
    int L, R;
    bool ok; int tag, v, sum[60];
} seg[MAXN * 4 + 5];
int vis[MAXN + 5];
int siz[MAXN + 5];
void update(int id) {
    int lc = (id << 1), rc = (id << 1 | 1);
    seg[id].ok = (seg[lc].ok & seg[rc].ok);
    seg[id].v = 0;
    if (!seg[id].ok) seg[id].sum[0] = seg[lc].sum[seg[lc].v] + seg[rc].sum[seg[rc].v];
    else {
        // 从0开始从新记录循环节
        int x = seg[lc].v, y = seg[rc].v;
        for (int i = 0; i < M; i ++) {
            seg[id].sum[i] = seg[lc].sum[x] + seg[rc].sum[y];
            x = (x + 1) % M, y = (y + 1) % M;
        }
    }
    return ;
}
void pushdown(int id) {
    int lc = (id << 1), rc = (id << 1 | 1);
    (seg[lc].v += seg[id].tag ) %= M;
    (seg[rc].v += seg[id].tag ) %= M;
    (seg[lc].tag += seg[id].tag ) %= M;
    (seg[rc].tag += seg[id].tag ) %= M;
    seg[id].tag = 0;
    return ;
}
void lg(int id) {
    //处理临界点
    if (siz[seg[id].sum[0]]) {
        for (int i = 1; i < M; i ++) seg[id].sum[i] = seg[id].sum[i - 1] * seg[id].sum[i - 1] % mod;
        seg[id].ok = 1; seg[id].v = 0;
    }
    return ;
}
void build(int id, int l, int r) {
    seg[id] = {l, r, 0, 0, 0};
    if (l == r) {
        seg[id].sum[0] = a[l];
        lg(id);
        return ;
    }
    int mid = (l + r) / 2;
    build(id << 1, l, mid);
    build(id << 1 | 1, mid + 1, r);
    update(id);
    return ;
}
void modify(int id, int L, int R) {
    if (L <= seg[id].L && seg[id].R <= R) {
        if (seg[id].ok == 1) {
            seg[id].v = (seg[id].v + 1) % M;
            seg[id].tag = (seg[id].tag + 1) % M;
            //入环的，在环上跳
            return;
        } else {
            if (seg[id].L == seg[id].R) {
                seg[id].sum[0] = seg[id].sum[0] * seg[id].sum[0] % mod;
                lg(id);
                return ;
            }
            //没有入环的，暴力修改
            pushdown(id);
            modify(id << 1, L, R);
            modify(id << 1 | 1, L, R);
            update(id);
            return;
        }
    }
    if (R < seg[id].L || seg[id].R < L) return;
    pushdown(id);
    modify(id << 1, L, R);
    modify(id << 1 | 1, L, R);
    update(id);
    return ;
}
int query(int id, int L, int R) {
    if(L <= seg[id].L && seg[id].R <= R) return seg[id].sum[seg[id].v];
    if (R < seg[id].L || seg[id].R < L) return 0;
    pushdown(id);
    return query(id << 1, L, R) + query(id << 1 | 1, L, R);
}
signed main() {
    scanf("%lld%lld%lld", &n, &q, &mod);
    for (int i = 0; i < mod; i ++) {
        for (int j = 1, x = i; ; j ++, x = x * x % mod)
            if (vis[x]) {
                siz[x] = j - vis[x]; // 标记临界点
                break;
            } else vis[x] = j;
        for (int j = 1, x = i; vis[x] ; j ++, x = x * x % mod)
            vis[x] = 0;
    }
    for (int i = 0; i < mod; i ++)
	    if (siz[i]) M = lcm(siz[i], M);
    for (int i = 1; i <= n; i ++) scanf("%lld", &a[i]);
    build(1, 1, n);
    for (int i = 1; i <= q; i ++) {
        int op, l, r;
        scanf("%lld%lld%lld", &op, &l, &r);
        if(op == 1)
            modify(1, l, r);
        else
            printf("%lld\n", query(1, l, r));
    }
    return 0;
}
```



---

## 作者：luckydrawbox (赞：0)

[$\text{Link}$](https://www.luogu.com.cn/problem/P4681)

## 题意

给定长度为 $n$ 的序列和一个数 $p$，有 $m$ 个操作：

- ``1 l r``：将区间 $[l,r]$ 内的数分别平方对 $p$ 取模。
- ``2 l r``：求区间 $[l,r]$ 内的数的和。

## 分析

看到修改如此诡异，考虑分块。

注意到值域很小，且 $p$ 有时不是质数，这启发我们要从打表开始着手。

经过打表可得，对于题目中的所有 $p$，每个数进行平方运算的循环节长度 $tim\le60$，一个数要进入循环需要的次数 $lim\le11$，且对于同一个 $p$，任意两个不同的数的循环节 $lim1,lim2(lim1\le lim2)$ 满足 $lim1\mid lim2$。于是我们只要知道对于一个 $p$ 的最大循环节长度，将其作为每个数的循环节长度即可。

为了优化常数，可以预处理出每个数乘方若干次后的值。然后就是众所周知的操作：

- 对于散块，查询和修改都直接暴力即可，同时维护 $sum_{k,0\sim tim-1}$ 表示块 $k$ 修改 $0\sim tim-1$ 次后的和。
- 对于整块，查询直接 $O(1)$ 回答，修改则要分两种情况：若该块修改次数不超过 $lim$，说明可能有的数还没进入循环，当成散块暴力改；若超过 $lim$ 次，直接 $O(1)$ 改变标记即可。

等等，这样复杂度好像要带上 $\sqrt {60}$ 的常数？那不炸飞了，考虑优化。

我们发现散块的复杂度偏高了，于是可以改为在暴力的同时，只维护 $sum_{k,0}$，当后面要用到 $sum_{k,x}$ 时，重新求一下即可。感觉比较玄学，但是好像能均摊的样子，于是就过了。（

## 代码

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
long long read(){
	long long x=0,f=1;char ch=getchar();
	while(!isdigit(ch))
	{if(ch=='-') f=-1;ch=getchar();}
	while(isdigit(ch)){x=x*10+ch-48;ch=getchar();}
	return x*f;
}
void write(long long x){
    if(x<0) putchar('-'),x=-x;
    if(x>9) write(x/10);
    putchar(x%10+'0');
}
const int N=1e5+10,sN=330,S=1e4+10;
int n,m,p,len,nxt[S][61],a[N],tim[sN],lim[sN];
int id,pri[21]={233,2332,5,8192,23,45,37,4185,5850,2975
,2542,2015,2003,2010,4593,4562,1034,5831,9905,9977};
bool vis[N],fl[N];
int cnt[sN],tag[sN];
bool dos[sN][61];
int sum[sN][61],now[sN];
void init(){
	tim[0]=28;lim[0]=3;
	tim[1]=12;lim[1]=2;
	tim[2]=1;lim[2]=2;
	tim[3]=1;lim[3]=11;
	tim[4]=10;lim[4]=1;
	tim[5]=2;lim[5]=2;
	tim[6]=6;lim[6]=2;
	tim[7]=12;lim[7]=2;
	tim[8]=4;lim[8]=2;
	tim[9]=4;lim[9]=4;
	tim[10]=4;lim[10]=3;
	tim[11]=4;lim[11]=2;
	tim[12]=60;lim[12]=1;
	tim[13]=10;lim[13]=2;
	tim[14]=24;lim[14]=1;
	tim[15]=36;lim[15]=3;
	tim[16]=44;lim[16]=1;
	tim[17]=42;lim[17]=4;
	tim[18]=46;lim[18]=2;
	tim[19]=60;lim[19]=1;
}
void solve(int u){//打表 
	int P=pri[u];
	int mx=0,m2=0;
	memset(fl,0,sizeof(fl));
	for(int i=1;i<P;i++){
		memset(vis,0,sizeof(vis));
		int j=i%P;
		int len=0;
		while(!vis[j]){
			len++;
			vis[j]=1;
			j=j*j%P;
		}
		if(j==i)fl[len]=1,mx=max(mx,len);
		m2=max(m2,len);
	}
	printf("tim[%d]=%d;lim[%d]=%d;\n",u,mx,u,m2-mx);
}
void pushdown(int k){
	if(tag[k]){
		for(int i=max(k*len,1);i<=min(n,k*len+len-1);i++){
			a[i]=nxt[a[i]][tag[k]];
		}
		tag[k]=0;
	}
}
void pushup(int k){
	memset(dos[k],0,sizeof(dos[k]));
	memset(sum[k],0,sizeof(sum[k]));
	dos[k][0]=1;
	for(int i=max(k*len,1);i<=min(n,k*len+len-1);i++){
		sum[k][0]+=a[i];
	}
}
void change(int l,int r){
	int kl=l/len,kr=r/len;
	if(kl==kr){
		pushdown(kl);
		for(int i=l;i<=r;i++){
			a[i]=nxt[a[i]][1];
		}
		pushup(kl);
		return;
	}
	change(l,(kl+1)*len-1);
	change(kr*len,r);
	for(int i=kl+1;i<kr;i++){
		if(cnt[i]<=lim[id]){
			cnt[i]++;
			change(i*len,(i+1)*len-1);
			continue;
		}
		tag[i]=(tag[i]+1)%tim[id];
	}
}
int ask(int l,int r){
	int kl=l/len,kr=r/len;
	int ans=0;
	if(kl==kr){
		pushdown(kl);
		for(int i=l;i<=r;i++){
			ans+=a[i];
		}
		pushup(kl);
		return ans;
	}
	ans=ask(l,(kl+1)*len-1)+ask(kr*len,r);
	for(int i=kl+1;i<kr;i++){
		if(!dos[i][tag[i]]){
			dos[i][tag[i]]=1;
			for(int j=max(i*len,1);j<=min(n,i*len+len-1);j++){
				sum[i][tag[i]]+=nxt[a[j]][tag[i]];
			}
		}
		ans+=sum[i][tag[i]]; 
	}
	return ans;
}
int main(){
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	n=read();m=read();p=read();
	len=sqrt(n);
	init();
	for(int i=0;i<20;i++){
		if(p==pri[i]){
			id=i;
		}
	}
	for(int i=1;i<p;i++){
		nxt[i][0]=i;
	}
	for(int i=1;i<=60;i++){
		for(int j=1;j<p;j++){
			nxt[j][i]=nxt[j][i-1];
			nxt[j][i]=(nxt[j][i]*nxt[j][i])%p;
		}
	}
	for(int i=1;i<=n;i++){
		a[i]=read();
	}
	for(int k=0;k<=n/len;k++){
		pushup(k);
	}
	for(int i=1;i<=m;i++){
		int op=read(),l=read(),r=read();
		if(op==1){
			change(l,r);
		}
		else {
			write(ask(l,r));
			puts("");
		}
	}
	return 0;
}
```

---

## 作者：LCat90 (赞：0)

这个平方取模是没有办法直接线段树区间修改的。

而题目给出了 $P$ 的可能值，这启示我们找到这些 $P$ 后面的规律。

大部分题目都是靠找循环节后转化为环上修改，于是我们考虑对于一个数 $x$，不断地进行 $x\leftarrow x^2 \bmod p$ 有什么规律。通过对 $[1,P)$ 的数进行打表可知，每个数开始是杂乱变化的，最后经过很少的次数进入到循环中，且循环节的长度也很小。

自然容易想到：对于没有进入循环的点暴力跳；否则，如果当前线段树维护的这整个区间都已经进入了循环，那么我们就打上标记，表示整个环向后移动一步。而这个环上每个点的值，可以通过 ``pushup`` 得到。

时间复杂度有题解已经分析过，这里不多说，感觉挺均摊的。

--------

这里提供一份有详细注释的代码供参考，难点在于 ``pushup`` 和 ``update`` 函数的讨论、实现。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5 + 5;
int n, m, p, a[N]; 
bool vis[N];
int cg(int x) { return x * x % p; }
int lcm(int x, int y) { return x * y / __gcd(x, y); }
struct node {
	int l, r, add; // sum 表示没有进入循环节时候的 sum = b[0]
	int siz, b[61], now; bool tag; // 循环节长度，整个区间按照原序走x循环节的值 当前位置 是否进入  
} T[N << 4];
void move(int p, int x) { T[p].now = (T[p].now + x) % T[p].siz; T[p].add += x; } // 循环位置修改 
void pushdown(int p) {
	if(T[p].add) {
		move(p << 1, T[p].add); move(p << 1 | 1, T[p].add);
		T[p].add = 0;
	}
}
void pushup(int p) {
	if(!T[p << 1].tag or !T[p << 1 | 1].tag) // 还未进入 
		T[p].tag = 0, T[p].b[0] = T[p << 1].b[T[p << 1].now] + T[p << 1 | 1].b[T[p << 1 | 1].now];
	else {
		T[p].siz = lcm(T[p << 1].siz, T[p << 1 | 1].siz); T[p].tag = 1; // 更新循环节
		for(int i = 0;i <= T[p].siz; ++i) // % -1
	T[p].b[i] = T[p << 1].b[(i + T[p << 1].now) % T[p << 1].siz] + T[p << 1 | 1].b[(i + T[p << 1 | 1].now) % T[p << 1 | 1].siz];
		T[p].now = 0; // now no moving
	}
} 
void update(int p, int l, int r) {
	if(l <= T[p].l and T[p].r <= r) {
		if(T[p].tag) move(p, 1);
		else { // 没有进入循环节 
			if(T[p].l == T[p].r) { // most important
				int x = T[p].b[0];
				if(vis[x]) T[p].b[0] = cg(x);  // 还是只能暴力修改 
				else { // 刚好已经进入环 
					for(int i = cg(x); true ;i = cg(i)) { // 使得 b[0] = b[size]  
						T[p].b[++T[p].siz] = i;
						if(T[p].b[T[p].siz] == x) break ;
					}
					T[p].tag = 1; T[p].now = 1 % T[p].siz;
				}
			} else { // 直接下传 
				update(p << 1, l, r); update(p << 1 | 1, l, r); // 继续暴力修改 
				pushup(p);
			}
		}
		return ;
	}
	int mid = T[p].l + T[p].r >> 1; pushdown(p);
	if(l <= mid) update(p << 1, l, r); if(r > mid) update(p << 1 | 1, l, r);
	pushup(p);
}
void build(int p, int l, int r) {
	T[p].l = l, T[p].r = r, T[p].siz = T[p].now = 0; // b[0] 是开始的 sum 
	if(l == r) { T[p].b[0] = a[l]; return ; }
	int mid = l + r >> 1;
	build(p << 1, l, mid); build(p << 1 | 1, mid + 1, r); pushup(p);
} 
int query(int p, int l, int r) {
	if(l <= T[p].l and T[p].r <= r) return T[p].b[T[p].now];
	int mid = T[p].l + T[p].r >> 1, ans = 0; pushdown(p);
	if(l <= mid) ans += query(p << 1, l, r); if(r > mid) ans += query(p << 1 | 1, l, r);
	return ans;
}
int in[N];
void topo() { queue <int> q;
	for(int i = 0;i < p; ++i) in[cg(i)] ++;
	for(int i = 0;i < p; ++i) if(!in[i]) q.push(i);
	while(!q.empty()) {
		int p = q.front(); q.pop();
		int to = cg(p); vis[p] = 1; // 一定不在环上
		if(--in[to] == 0) q.push(to);
	}
}
signed main() {
	cin >> n >> m >> p;
	for(int i = 1;i <= n; ++i) scanf("%d", &a[i]); build(1, 1, n);
	topo(); // 预处理循环节 
	while(m--) {
		int op, l, r; scanf("%d %d %d", &op, &l, &r);
		if(op == 1) update(1, l, r);
		else printf("%d\n", query(1, l, r));
	}
	return 0;
}
```

---

## 作者：Rainsleep (赞：0)

考虑模数给定，且给定模数最大为 $9977$。

这启示我们每个数字最多平方取模 $9976$ 次就会开始重复。但是事实上可能要小得多，于是我们尝试打表验证规律。

打表程序：[code](https://www.luogu.com.cn/paste/ktvkgtvp)

我们验证了确定模数时，所有数字的最多的不超过 $11$ 次即可进入循环节，且所有循环节的 $\text{lcm} \le 60$。

>事实上，这相当于对于每个 $x$，连一条 $(x, x^2 \bmod p)$ 的边。
>
>因为会出现循环节，这相当于形成了一棵内向基环树，而对于不同的循环节，我们形成了一个基环树森林。
>而验证的东西其实就是环长。

对于找环，可以考虑拓扑排序。

我们想要用线段树维护它，但是当每个数字没有到循环节内时，我们确实没有办法维护这个整体，所以只能暴力。

而当对于某个区间已经全部踏进环内时，我们可以直接对该区间打上 **整体在环上移动一步** 的标记。

另外，对于一个区间来讲，如果左右区间 $l, r$ 的循环节已经确定，那么和的循环节长度即为左右 $l, r$ 循环节的 $\text{lcm}$。

[code](https://www.luogu.com.cn/paste/ig9tc2x5)


+ 对于复杂度，预处理为 $O(n\omega)$。
+ 设每个数暴力的次数为 $c_1$，则暴力部分的复杂度为 $O(c_1n \log n)$，其中 $c_1$ 上文已给出，最大为 $11$。
+ 设循环节长度 $\text{lcm}$ 为 $c_2$，线段树上除了叶子节点每个点还会合并一个循环节，所以这部分的复杂度为 $O(c_2\omega n)$，其中 $c_2$ 取决于左右子区间循环节长度，上文给出过 $\text{lcm}$ 最大为 $60$，$\omega$ 为线段树节点常数约为 $4$。
+ 最后是打标记的复杂度，这部分即为 $O(m \log n)$。

所以总复杂度即为 $O(c_1n \log n + c_2\omega n + m \log n)$。

upd : 2024/1/6

事实上，第一部分的 $O(c_1n\log n)$ 的复杂度并不好构造方案卡满，如果有可以提供的同学不胜感激。


---


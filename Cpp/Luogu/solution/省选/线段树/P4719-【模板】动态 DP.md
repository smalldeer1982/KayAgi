# 【模板】动态 DP

## 题目描述

给定一棵 $n$ 个点的树，点带点权。

有 $m$ 次操作，每次操作给定 $x,y$，表示修改点 $x$ 的权值为 $y$。

你需要在每次操作之后求出这棵树的最大权独立集的权值大小。

## 说明/提示

#### 数据规模与约定

- 对于 $30\%$ 的数据，保证 $n,m\le 10$。
- 对于 $60\%$ 的数据，保证 $n,m\le 10^3$。
- 对于 $100\%$ 的数据，保证 $1\le n,m\le 10^5$，$1 \leq u, v , x \leq n$，$-10^2 \leq a_i, y \leq 10^2$。


## 样例 #1

### 输入

```
10 10
-11 80 -99 -76 56 38 92 -51 -34 47 
2 1
3 1
4 3
5 2
6 2
7 1
8 2
9 4
10 7
9 -44
2 -17
2 98
7 -58
8 48
3 99
8 -61
9 76
9 14
10 93
```

### 输出

```
186
186
190
145
189
288
244
320
258
304```

# 题解

## 作者：Tweetuzki (赞：369)

不得不承认，去年提高组 D2T3 对动态 DP 起到了良好的普及效果。

动态 DP 主要用于解决一类问题。这类问题一般原本都是较为简单的树上 DP 问题，但是被套上了~~丧心病狂的~~修改点权的操作。就比如说这道题：

[【模板】动态 DP](https://www.luogu.org/problemnew/show/P4719)

> 给定一棵 $n$ 个点的树。$i$ 号点的点权为 $a_i$。有 $m$ 次操作，每次操作给定 $u, w$，表示修改点 $u$ 的权值为 $w$。你需要在每次操作之后求出这棵树的最大权独立集的权值大小。

我们首先考虑没有修改的情况下怎么做。首先先选取 $1$ 号点作为全树的根。然后我们设 $f_{i, 0}$ 表示不选择 $i$ 号点时，以 $i$ 号点为根的子树的最大权独立集；$f_{i, 1}$ 表示选择 $i$ 号点时，以 $i$ 号点为根的子树的最大权独立集。我们可以很容易地写出如下的方程：

$$ f_{i, 0} = \sum_{j} \max(f_{j, 0}, f_{j, 1})$$
$$f_{i, 1} = \sum_{j} f_{j, 0} + a_i $$

这里 $j$ 表示 $i$ 号点的所有儿子。特殊地，若点 $i$ 为叶子节点，$f_{i, 0} = 0, f_{i, 1} = a_i$。

最后的答案就是 $\max(f_{1, 0}, f_{1, 1})$。

---

接下来带上修改。

首先根据动态规划的转移方程可以发现，我们修改了一个点的点权，只会更改从这个点到根这条路径上节点的 DP 值，其他值是不会发生更改的。这时候如果我们要对整棵树重新求一遍最大权独立集，未免太过浪费。所以我们希望能够更改这条链上的 DP 值。

由于树可能会退化成一条链，这样每次更新就是 $\mathcal{O(n)}$ 的，显然不可接受。我们希望这条链只更新 $\log n$ 次……

~~点分治！~~抱歉博主太弱了，不会那个被称作“全局平衡二叉树”的厉害做法。

这时候我们请出解决树上问题的神器——重链剖分。

重链剖分有一些性质，这些性质正是它在动态 DP 中能够发挥作用的重要保障。

1. 每个点到根的路径上，最多经过 $\log n$ 条轻边。也就是说，重链的条数最多也只有 $\log n$ 条。这为动态 DP 的时间复杂度做了保障。
2. 每条重链的链尾都是叶子节点，且只有叶子节点没有重儿子。这为动态规划的初始状态和转移方式做了保障。
3. 重链剖分中，一条重链所在的区间在剖出的 DFS 序上，是连续的一段区间。这为可以使用数据结构维护区间信息，达到快速转移做了保障。

那么在宏观上，我们相当于在更新时，对于这些重链暴力地互相转移更新。接下来我们考虑一些微观问题：在一条链里，怎么支持快速修改和查询这条链的 DP 值。

我们保持 $f$ 数组的定义不变。为了迎合重链剖分划分出了轻重儿子，我们形式化地定义 $g$ 数组：$g_{i, 1}$ 表示 $i$ 号点的所有轻儿子，都不取的最大权独立集；$g_{i, 0}$ 表示 $i$ 号点的所有轻儿子，可取可不取形成的最大权独立集。这样就可以把上述的 DP 式子大大简化了（至少没有了那个 $\Sigma$）。

$$f_{i, 0} = g_{i, 0} + \max(f_{j, 0}, f_{j, 1})$$
$$f_{i, 1} = g_{i, 1} + a_i + f_{j, 0}$$

这里的 $j$ 表示 $i$ 号点的重儿子。特殊地，对于叶子节点，$g_{i, 0} = g_{i, 1} = 0$。

但是感觉这玩意儿好像不大优美？第二个转移式子中，$g_{i, 1}$ 和 $a_i$ 都只和 $i$ 有关，那么我们不妨把它们合并起来。我们重新定义 $g_{i, 1}$：表示 $i$ 号点只考虑轻儿子的取自己的最大权独立集。那么这时候，第二个方程就可以变为 $f_{i, 1} = g_{i, 1} + f_{j, 0}$。

但是这玩意儿咋区间维护嘞？回想一下当初学习斐波那契的时候，我们碰到过这样的 DP 方程：

$$f_i = f_{i - 1} + f_{i - 2}$$

这个方程涉及上一步的贡献，没法满足结合率，不太舒服。于是我们定义了一个矩阵，化加为乘，于是我们愉快地用快速幂 AC 了。

这道题我们也给它套个矩阵。对于每个点，都表示一个状态，这个状态共有两个值，于是我们考虑维护一个 $1 \times 2$ 的矩阵。

$$ \begin{vmatrix} f_{i, 0} & f_{i, 1} \end{vmatrix} $$

现在我们要从一个点的重儿子 $j$ 转移到 $i$ 上，也就是说我们需要构造出一个转移矩阵使得 $\begin{vmatrix} f_{j, 0} & f_{j, 1} \end{vmatrix}$ 能够转移到 $\begin{vmatrix} f_{i, 0} & f_{i, 1} \end{vmatrix}$。但是我们回顾一下这个转移方程（已更改 $g_{i, 1}$ 的定义）：

$$f_{i, 0} = g_{i, 0} + \max(f_{j, 0}, f_{j, 1})$$
$$f_{i, 1} = g_{i, 1} + f_{j, 0}$$


它一点也不满足矩阵乘法的形式啊！

别慌……我们大胆地重定义矩阵乘法！

我们定义一个新的运算符 $*$，对于矩阵 $\mathrm{A}, \mathrm{B}$，定义 $\mathrm{A} * \mathrm{B}$ 的结果 $\mathrm{C}$，满足：

$$\mathrm{C}_{i, j} = \max_{k}(\mathrm{A}_{i, k} + \mathrm{B}_{k, j})$$

实现到代码上，就是

```cpp
struct Matrix {
  int mat[MaxN][MaxN];
}

inline Matrix operator * (Matrix a, Matrix b) {
  Matrix c;

  for (int i = 0; i < n; ++i)
    for (int j = 0; j < n; ++j)
      for (int k = 0; k < n; ++k)
        c.mat[i][j] = max(c.mat[i][j], a.mat[i][k] + b.mat[k][j]);

  return c;
}
```

但是这个东西为什么具有结合率呢？

- 一种感性的理解：由于 $\max$ 操作和加法操作都是满足结合率的，所以这个运算满足结合率。
- 一种理性但不太严谨的证明：读者不妨拿出之笔，计算几组 $(\mathrm{A} * \mathrm{B}) * \mathrm{C}$ 和 $\mathrm{A} * (\mathrm{B} * \mathrm{C})$ 的值（如果您计算比较厉害，带上参数算当然更好）。一般情况下，证明了三个满足条件，对于所有情况都是能满足条件的。

于是我们口胡完了结合率的证明。那么我们就可以用了。接下来我们要构造一个转移矩阵，这个是相对难的一个内容。我就介绍一下我个人构造转移矩阵的拙劣方法吧。

在构造一个转移矩阵之前，我们先想办法把这玩意儿变形，变得和运算 $*$ 差不多。

$$f_{i, 0} = \max(f_{j, 0} + g_{i, 0}, f_{j, 1} + g_{i, 0})$$
$$f_{i, 1} = \max(g_{i, 1} + f_{j, 0}, -\infty)$$

接着我们把已知的状态和要转移到的状态写在一起，把未知的转移矩阵用 $\mathrm{U}$ 表示。

$$\begin{vmatrix} f_{j, 0} & f_{j, 1} \end{vmatrix} * \mathrm{U} = \begin{vmatrix} f_{i, 0} & f_{i, 1} \end{vmatrix}$$

我们原来是一个 $1 \times 2$ 的矩阵，要形成一个 $1 \times 2$ 的矩阵，那么 $\mathrm{U}$ 应当是一个 $2 \times 2$ 的矩阵。那么我们设矩阵左上、右上、左下、右下四个位置分别为 $u_1, u_2, u_3, u_4$。接下来把每个位置对应上去。

$f_{i, 0}$ 的值应该为 $\max(f_{j, 0} + u_1, f_{j, 1} + u_3)$。对应转移方程，我们发现 $u_1$ 应该就是 $g_{i, 0}$，$u_3$ 也是 $g_{i, 0}$。同样的，$f_{i, 1}$ 的值应该为 $\max(f_{j, 0} + u_2, f_{j, 1} + u_4)$。对应转移方程，我们发现 $u_2$ 应该是 $g_{i, 1}$，而不存在 $f_{j, 1}$ 项，就将 $u_4$ 赋为 $-\infty$。最后写出来，检查一遍：

$$\begin{vmatrix} f_{j, 0} & f_{j, 1} \end{vmatrix} * \begin{vmatrix} g_{i, 0} & g_{i, 1} \\ g_{i, 0} & -\infty \end{vmatrix} = \begin{vmatrix} f_{i, 0} & f_{i, 1} \end{vmatrix}$$

嗯……好像没问题？

这样子，我们对于一条重链，我们的叶子节点就存储了最初始的值，链上每个节点都对应着一个转移矩阵。我们发现这个转移矩阵和重链信息是没有任何关系的，且因为这个矩阵满足结合率，对于一条重链，我们可以之间线段树维护区间乘积（或者叫……“$*$ 积”？）。然后到了一条重链链头，因为这个点是它父亲的轻儿子，我们需要更新它父亲节点所在的点的转移矩阵。这样子一直跳到根节点就可以了。貌似……大功告成？

重链剖分剖出的 DFS 序，由于先访问了链头，所以这个区间中，链头在区间左端，链尾在区间右端。我们存储的初始信息在叶子节点（也就是链尾）上，因此我们的矩阵 $*$ 法应当是转移矩阵在前，要维护的值矩阵在后。我们要把这个矩阵前后换个顺序，再转个个儿，加上一些推算，可以变形成：

$$\begin{vmatrix} g_{i, 0} & g_{i, 0} \\ g_{i, 1} & -\infty \end{vmatrix} * \begin{vmatrix} f_{j, 0} \\ f_{j, 1} \end{vmatrix} = \begin{vmatrix} f_{i, 0} \\ f_{i, 1} \end{vmatrix}$$

这样就真的做完了。最后我写一些关于代码实现的小细节：

1. 对于一个点查其 dp 值，需要从这个点一直查到区间链尾。因此，树剖时我们需要多维护一个 $\texttt{End[i]}$（这里的 $i$ 是一条重链的链头），表示以 $i$ 为链头的这条链，链尾（叶子）节点在 DFS 序上的位置。
2. 更新线段树上某个点的转移矩阵时，传入的如果是矩阵，递归下去常数太大。一个解决方法是，在线段树外，维护一个矩阵组 $\texttt{Val[i]}$，表示每个节点对应的转移矩阵。这样在线段树更新找到对应位置时，直接赋值进来即可。

最后贴上代码。

解释一下变量名：

$\texttt{Id[i]}$ 表示 $i$ 号点在 DFS 序中的位置，$\texttt{Dfn[i]}$ 表示在 DFS 序中下标 $i$ 的位置对应的是什么点（与 $\texttt{Id[i]}$ 相反），$\texttt{Fa[i]}$ 是父亲节点，$\texttt{Siz[i]}$ 是子树大小，$\texttt{Dep[i]}$ 是该节点深度（好像没什么用），$\texttt{Wson[i]}$ 是 $i$ 号节点的重儿子，$\texttt{Top[i]}$ 表示 $i$ 号点所在重链链顶编号。

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;

const int MaxN = 100000 + 5, MaxM = 200000 + 5;
const int MaxV = 400000 + 5;
const int INF = 0x7F7F7F7F;

struct Matrix {
  int mat[2][2];

  Matrix() {
    memset(mat, -0x3F, sizeof mat);
  }

  inline Matrix operator * (Matrix b) {
    Matrix c;

    for (int i = 0; i < 2; ++i)
      for (int j = 0; j < 2; ++j)
        for (int k = 0; k < 2; ++k)
          c.mat[i][j] = max(c.mat[i][j], mat[i][k] + b.mat[k][j]);

    return c;
  }
};

int N, M; int cntv, cnte;
int A[MaxN];
int Fa[MaxN], Siz[MaxN], Dep[MaxN], Wson[MaxN];
int Top[MaxN], Id[MaxN], Dfn[MaxN], End[MaxN];
int F[MaxN][2];
int Head[MaxN], To[MaxM], Next[MaxM];
Matrix Val[MaxN];

struct SegTree {
  int L[MaxV], R[MaxV];
  Matrix M[MaxV];

  inline void Push_up(int i) {
    M[i] = M[i << 1] * M[i << 1 | 1];
  }

  void Build_Tree(int left, int right, int i) {
    L[i] = left, R[i] = right;
    if (L[i] == R[i]) {
      M[i] = Val[Dfn[L[i]]];
      return;
    }

    int mid = (L[i] + R[i]) >> 1;
    Build_Tree(L[i], mid, i << 1);
    Build_Tree(mid + 1, R[i], i << 1 | 1);
    Push_up(i);
  }

  void Update_Tree(int x, int i) {
    if (L[i] == R[i]) {
      // 直接赋值，减小常数
      M[i] = Val[Dfn[x]];
      return;
    }

    int mid = (L[i] + R[i]) >> 1;
    if (x <= mid) Update_Tree(x, i << 1);
    else Update_Tree(x, i << 1 | 1);
    Push_up(i);
  }

  // 查询一个点的 DP 值，相当于查询这条重链上链尾矩阵和链中转移矩阵的 '*' 积
  Matrix Query_Tree(int left, int right, int i) {
    if (L[i] == left && R[i] == right) return M[i];

    int mid = (L[i] + R[i]) >> 1;
    if (right <= mid)
      return Query_Tree(left, right, i << 1);
    else if (left > mid)
      return Query_Tree(left, right, i << 1 | 1);
    else
      return Query_Tree(left, mid, i << 1) * Query_Tree(mid + 1, right, i << 1 | 1);
  }
} T;

inline void add_edge(int from, int to) {
  cnte++; To[cnte] = to;
  Next[cnte] = Head[from]; Head[from] = cnte;
}

void readin() {
  scanf("%d %d", &N, &M);
  for (int i = 1; i <= N; ++i)
    scanf("%d", &A[i]);
  for (int i = 1; i < N; ++i) {
    int u, v;
    scanf("%d %d", &u, &v);
    add_edge(u, v); add_edge(v, u);
  }
}

void dfs1(int u) {
  Siz[u] = 1;

  for (int i = Head[u]; i; i = Next[i]) {
    int v = To[i];
    if (v == Fa[u]) continue;

    Fa[v] = u; Dep[v] = Dep[u] + 1;
    dfs1(v);

    Siz[u] += Siz[v];
    if (Siz[v] > Siz[Wson[u]]) Wson[u] = v;
  }
}

void dfs2(int u, int chain) {
  cntv++;
  Id[u] = cntv; Dfn[cntv] = u;
  Top[u] = chain;
  End[chain] = max(End[chain], cntv);

  // 第二次树剖时直接更新 F, G 数组（这里直接将 G 放入矩阵更新）
  F[u][0] = 0, F[u][1] = A[u];
  Val[u].mat[0][0] = Val[u].mat[0][1] = 0;
  Val[u].mat[1][0] = A[u];
  if (Wson[u] != 0) {
    dfs2(Wson[u], chain);
    // 依照定义，重儿子不应计入 G 数组
    F[u][0] += max(F[Wson[u]][0], F[Wson[u]][1]);
    F[u][1] += F[Wson[u]][0];
  }

  for (int i = Head[u]; i; i = Next[i]) {
    int v = To[i];
    if (v == Fa[u] || v == Wson[u]) continue;
    dfs2(v, v);

    F[u][0] += max(F[v][0], F[v][1]);
    F[u][1] += F[v][0];
    Val[u].mat[0][0] += max(F[v][0], F[v][1]);
    Val[u].mat[0][1] = Val[u].mat[0][0];
    Val[u].mat[1][0] += F[v][0];
  }
}

void init() {
  readin();
  dfs1(1); dfs2(1, 1);
}

void update_path(int u, int w) {
  Val[u].mat[1][0] += w - A[u];
  A[u] = w;

  Matrix bef, aft;
  while (u != 0) {
    // 计算贡献时，应当用一个 bef 矩阵还原出少掉这个轻儿子的情况，再将 aft 加入更新
    bef = T.Query_Tree(Id[Top[u]], End[Top[u]], 1);
    T.Update_Tree(Id[u], 1);
    aft = T.Query_Tree(Id[Top[u]], End[Top[u]], 1);
    u = Fa[Top[u]];

    Val[u].mat[0][0] += max(aft.mat[0][0], aft.mat[1][0]) - max(bef.mat[0][0], bef.mat[1][0]);
    Val[u].mat[0][1] = Val[u].mat[0][0];
    Val[u].mat[1][0] += aft.mat[0][0] - bef.mat[0][0];
  }
}

void solve() {
  T.Build_Tree(1, N, 1);

  for (int i = 1; i <= M; ++i) {
    int u, w;
    scanf("%d %d", &u, &w);
    update_path(u, w);
    Matrix Ans = T.Query_Tree(Id[1], End[1], 1);
    printf("%d\n", max(Ans.mat[0][0], Ans.mat[1][0]));
  }
}

int main() {
  init();
  solve();
  return 0;
}
```

附：本文同时发布于本蒟蒻的[博客](https://www.cnblogs.com/tweetuzki/p/10274788.html)。

---

## 作者：shadowice1984 (赞：186)

在上古论文中发现了一种神奇的做法……

$O(nlogn)$把树剖吊起来打……

于是轻松拿到了本题的rk1(但是这份代码封装还是很多的，应该还有很多卡常空间)

_____________________

## 本题题解

### 什么是动态dp

所谓动态dp就是一种黑科技允许你对于一个dp问题进行修改操作

先给你一个正常的dp问题，比如没有上司的舞会

然后我们要不停的修改参数此时问题的难度就由黄牌骤增至黑牌了

然后传统的做法是使用树链剖分(链分治)

我们先对整颗树做一个树剖，然后一条重链一条重链的进行dp

先来看普通的dp方程，设$Dp_{i,0}$为这个点不在独立时的最大收益，$Dp_{i,1}$为在的时候的最大收益

## $Dp_{u,0}=\sum_{v \in u.son}max(Dp_{v,0},Dp_{v,1})$

## $Dp_{u,1}=\sum_{v \in u.son}Dp_{v,0}$

然后我们发现这个东西似乎可以变换一下顺序也没什么影响，所以我们一条重链一条重链的dp

换句话说我们采取一种dfs和bfs混合的方式遍历这颗树，每次到达一个重链的顶部的时候我们直接将这个重链全部塞到队列里，然后我们递归下去遍历和重链相连的所有重链，最后处理这个重链，当处理完这个重链之后我们发现我们已经处理完了这个重链顶所在的子树了

那么我们对于重链上的每一个点，先根据轻儿子的dp值(因为轻儿子一定是其他重链的顶部所以dp值必定已经计算好)，计算出一个$ldp_{i,0/1}$

## $ldp_{u,0}=\sum_{v \in u.lightson}max(Dp_{v,0},Dp_{v,1})$

## $ldp_{u,1}=\sum_{v \in u.lightson}Dp_{v,0}$

此时我们根据这个ldp值在重链上跑一个序列的dp

## $Dp_{u,0}=ldp_{u,0}+max(Dp_{u.heavyson,0},Dp_{u.heavyson,1})$

## $Dp_{u,1}=ldp_{u,1}+Dp_{u.heavyson,0}$

此时你可能会说，这有什么用……还不是$O(n)$的dp而且还多了一堆常数

但是这意味着我们成功的将树上的问题转化为了序列问题，所以我们现在可以使用线段树维护重链上的dp值，从而可以支持快速修改

具体来讲，当我们修改一个点的值的时候，我们在对应的重链的线段树上进行修改，此时会改变重链顶部的dp值，然后会改变重链顶的father的ldp值，然后又对应了线段树上的单点修改，此时又会改变另一个重链顶的dp值，

这样反复几次，我们就可以在$O(log^2n)$时间内完成单点修改

问题来了怎么线段树上维护dp值啊

很简单，利用immortalICO神仙给出的黑科技，我们将转移写成Floyd矩乘的形式

我们将平常的矩阵乘法换成这样的形式

## $C_{i,j}=\max_{k}(A_{i,k}+B_{k,j})$

可以证明这个重定义之后的矩乘仍然具有结合律

单位矩阵是中间一行0剩余的地方全部是$- \infty$

那么我们发现事实上重链上的转移可以写成这样的矩乘

$$\begin{bmatrix} dp_{i-1,0} \\ dp_{i-1,1} \end{bmatrix} × \begin{bmatrix} ldp_{i,0} & ldp_{i,0} \\ ldp_{i,1} & -\infty \end{bmatrix}$$

然后我们就可以在线段树上愉快的维护矩阵连乘积啦，通过维护矩阵连乘积我们就可以实现$O(8log^2n)$的修改操作了

~~愚蠢的$O(nlog^2n)$做法到此结束，我们开始讲解上古魔法~~
_______________

### 上古科技：“全局平衡二叉树"

可以去翻07年的论文”QTREE 解法的一些研究"，~~(“全局平衡二叉树"这个中二的名字是论文里说的)~~

众所周知把刚才的树剖换成lct就可以做到一个log了，但是我们发现lct实在是常数太!大!了！绝对是跑不过实现的优秀的一点的树剖的

但是我们对于lct的复杂度证明却很感兴趣，为啥同样是操作了logn个数据结构，把线段树换成常数更大的splay复杂度反而少了一个log呢？(刚才这句话严格来讲是病句，常数和复杂度没有任何关联)

具体证明需要用到势能分析，但是感性理解一下就是如果我们把lct上的虚边也看成splay的边的话，我们发现整棵lct变成了一棵大splay，只是有些点度数不是2了

但是这些点度不是2的点并未破坏splay的势能分析换句话说势能分析对整颗大splay仍然生效,所以你的$log$次splay在整个大splay上只是一次splay而已

复杂度自然是均摊$O(logn)$了

但是，我们发现这是颗静态树，使用splay实在是大(常)材(数)小(过)用(大)了

于是我们考虑将lct强行静态化，换句话说，建一个像splay一样的全局平衡的树

观察到线段树只是局部平衡的，在碰到专业卡链剖的数据--链式堆(根号n个长度为根号n的链连成完全二叉树的形状)的时候会导致算上虚边之后的整颗树左倾或者右倾

此时我们发现如果在建线段树的时候做点手脚，我们把线段树换成二叉查找树bst，并且这个bst不是严格平衡的话，我们可以做到更加优秀的复杂度，使得算上虚边之后的树树高达到$O(logn)$级别

我们还是在树上dfs，但是对于重链建bst的时候我们并不建一个完美的bst，而是将每一个节点附上一个权值，权值为它所有轻儿子的siz之和+1，然后我们每次找这个链的带权重心，把他作为这一级的父亲，然后递归两边进行建bst

当然我们发现最坏情况下我们可以建出一个严重左倾或者右倾的bst

但是，我们考虑算上虚边的整颗树我们会发现一个神奇的性质，无论是经过一条重的二叉树边还是虚边，所在子树的siz至少翻一倍，而这个性质在原来的线段树上是没有的

所以这个大bst的高度是$O(logn)$的

当然，这个bst既不能旋转也不能splay，所以维护区间信息会比较吃力，但是，我们为什么要维护区间信息呢？这是动态dp啊，我们只需要维护这整个重链的矩阵连乘积就行了……，所以维护整个重链的连乘积还是可以做到的

另外这个东西看起来听玄学其实比树剖还好写……

上代码~

```C
#include<cstdio>
#include<algorithm>
using namespace std;const int N=1e5+10;
int n;int m;int v[2*N];int x[2*N];int ct;int al[N];int siz[N];int h[N];int we[N];
inline void add(int u,int V){v[++ct]=V;x[ct]=al[u];al[u]=ct;}
inline int dfs1(int u)//这里的树剖只需要一趟dfs求重儿子 
{
    siz[u]=1;int mx=0;
    for(int i=al[u];i;i=x[i])
        if(siz[v[i]]==0){siz[u]+=dfs1(v[i]);if(mx<siz[v[i]])mx=siz[v[i]],h[u]=v[i];}
    return siz[u];
}
struct mar//矩阵类 
{
    int mp[2][2];
    mar(){mp[0][0]=mp[0][1]=mp[1][0]=mp[1][1]=-0x3f3f3f3f;}
    mar(int x){mp[0][0]=mp[1][1]=0;mp[1][0]=mp[0][1]=-0x3f3f3f3f;}
    friend mar operator *(mar a,mar b)
    {
        mar c;for(int i=0;i<2;++i)
            for(int k=0;k<2;++k)
                for(int j=0;j<2;++j)c.mp[i][j]=max(c.mp[i][j],a.mp[i][k]+b.mp[k][j]);
        return c;
    }
    inline int gmx(){return max(max(mp[0][0],mp[0][1]),max(mp[1][0],mp[1][1]));}
    inline int* operator [](const int& x){return mp[x];}
};
struct bst
{
    int s[N][2];int fa[N];int st[N];int tp;int lsiz[N];bool book[N];int root;
    mar mul[N];mar w[N];bst(){w[0]=mul[0]=mar(1);}
    inline void ud(const int& x){mul[x]=mul[s[x][0]]*w[x]*mul[s[x][1]];}
    inline void gtw(const int& x,const int& v)
    {w[x][1][0]+=mul[v].gmx();w[x][0][0]=w[x][1][0];w[x][0][1]+=max(mul[v][0][0],mul[v][1][0]);fa[v]=x;}
    inline void ih(){for(int i=1;i<=n;i++)w[i][0][1]=we[i],w[i][0][0]=w[i][1][0]=0;}
    inline bool isr(const int& p){return (s[fa[p]][1]!=p)&&(s[fa[p]][0]!=p);}
    inline int sbuild(const int& l,const int& r)//对序列建bst 
    {
        if(l>r)return 0;int tot=0;for(int i=l;i<=r;i++)tot+=lsiz[st[i]];
        for(int i=l,ns=lsiz[st[i]];i<=r;i++,ns+=lsiz[st[i]])
            if(2*ns>=tot)
            {
                int rs=sbuild(l,i-1);int ls=sbuild(i+1,r);s[st[i]][0]=ls;s[st[i]][1]=rs;
                fa[ls]=st[i];fa[rs]=st[i];ud(st[i]);return st[i];//找重心递归建树 
            }
    }
    inline int build(int p)//链分治，每次处理一条链 
    {
        for(int t=p;t;t=h[t])book[t]=true;
        for(int t=p;t;t=h[t])
            for(int i=al[t];i;i=x[i])if(!book[v[i]])gtw(t,build(v[i]));
        tp=0;for(int t=p;t;t=h[t])st[++tp]=t;
        for(int t=p;t;t=h[t])lsiz[t]=siz[t]-siz[h[t]];return sbuild(1,tp);
    }
    inline void modify(int p,int W)//修改，直接无脑修改上去就行了 
    {
    	w[p][0][1]+=W-we[p];we[p]=W;
        for(int t=p;t;t=fa[t])
        	if(isr(t)&&fa[t])//如果是轻边 
			{
				w[fa[t]][0][0]-=mul[t].gmx();w[fa[t]][1][0]=w[fa[t]][0][0];
				w[fa[t]][0][1]-=max(mul[t][0][0],mul[t][1][0]);ud(t);
				w[fa[t]][0][0]+=mul[t].gmx();w[fa[t]][1][0]=w[fa[t]][0][0];
				w[fa[t]][0][1]+=max(mul[t][0][0],mul[t][1][0]);
			}else ud(t);
    }
}bst;
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)scanf("%d",&we[i]);
	for(int i=1,u,v;i<n;i++){scanf("%d%d",&u,&v);add(u,v);add(v,u);}
	dfs1(1);bst.ih();bst.root=bst.build(1);
	for(int i=1,p,w;i<=m;i++)
	{scanf("%d%d",&p,&w);bst.modify(p,w);printf("%d\n",bst.mul[bst.root].gmx());}
	return 0;//拜拜程序~ 
}
```










---

## 作者：RabbitHu (赞：71)

> 本题解同步发布于[胡小兔的博客](https://www.cnblogs.com/RabbitHu/p/9112811.html)，欢迎来访交流 >v<

猫锟在WC2018讲的黑科技——动态DP，就是一个画风正常的DP问题再加上一个动态修改操作，就像这道题一样。（这道题也是PPT中的例题）

动态DP的一个套路是把DP转移方程写成矩阵乘法，然后用线段树（树上的话就是树剖）维护矩阵，这样就可以做到修改了。

注意这个“矩阵乘法”不一定是我们常见的那种乘法和加法组成的矩阵乘法。设$A * B = C$，常见的那种矩阵乘法是这样的：

$$C_{i, j} = \sum_{k = 1}^{n} A_{i, k} * B_{k, j}$$

而这道题中的矩阵乘法是这样的：

$$C_{i, j} = \max_{k = 1}^{n} (A_{i, k} + B_{k, j})$$

这就相当于常见矩阵乘法中的加法变成了max，乘法变成了加法。类似于乘法和加法的五种运算律，这两种变化也满足“加法交换律”、“加法结合律”、“max交换律”、“max结合律”和“加法分配律“。那么这种矩阵乘法显然也满足矩阵乘法结合律，就像正常的矩阵乘法一样，可以用线段树维护。

接下来我们来构造矩阵。首先研究DP方程。

就像“没有上司的舞会”一样，$f_{i, 0}$表示子树$i$中不选$i$的最大权独立集大小，$f_{i, 1}$表示子树$i$中选$i$的最大权独立集大小。

但这是动态DP，我们需要树链剖分。假设我们已经完成了树链剖分，剖出来的某条重链看起来就像这样，右边的是在树上深度较大的点：

![](https://cdn.luogu.com.cn/upload/pic/20275.png)

此时，比这条重链的top深度大且不在这条重链上的点的DP值都是已经求出来的（这可以做到）。我们把它们的贡献，都统一于它们在这条重链上对应的那个祖先上。

具体来说，设$g_{i, 0}$表示不选$i$时，$i$不在链上的子孙的最大权独立集大小，$g_{i, 1}$表示选$i$时，$i$不在链上的子孙再加上$i$自己的最大权独立集大小。

假如$i$右面的点是$i + 1$, 那么可以得出：

$$f_{i, 0} = g_{i, 0} + \max(f_{i + 1, 0}, f_{i + 1, 1})$$

$$f_{i, 1} = g_{i, 1} + f_{i + 1, 0}$$

矩阵也就可以构造出来了：

$$\begin{bmatrix}g_{i, 0} & g_{i, 0} \\g_{i, 1} & 0\end{bmatrix} * \begin{bmatrix}f_{i + 1, 0} \\ f_{i + 1, 1}\end{bmatrix} = \begin{bmatrix}f_{i, 0} \\ f_{i, 1}\end{bmatrix}$$

读者可以动笔验证一下。（注意我们在这里用的“新矩阵乘法”的规则：原来的乘变成加，加变成取max。）

那么基本思路就很清楚了：树剖，维护区间矩阵乘积。修改的时候，对于被修改节点到根节点路径上的每个重链（由下到上），先进行单点修改，然后求出这条重链的$top$在修改之后的$f$值，然后继续修改top所在重链。

每次答案就是节点$1$的$f$值。

## 代码

代码略丑，见谅……

```cpp
#include <cstdio>
#include <cmath>
#include <cstring>
#include <algorithm>
#include <iostream>
#include <queue>
#define space putchar(' ')
#define enter putchar('\n')
using namespace std;
typedef long long ll;
template <class T>
void read(T &x){
    char c;
    bool op = 0;
    while(c = getchar(), c < '0' || c > '9')
	if(c == '-') op = 1;
    x = c - '0';
    while(c = getchar(), c >= '0' && c <= '9')
	x = x * 10 + c - '0';
    if(op) x = -x;
}
template <class T>
void write(T x){
    if(x < 0) putchar('-'), x = -x;
    if(x >= 10) write(x / 10);
    putchar('0' + x % 10);
}

const int N = 100005;
int n, m, a[N];
int ecnt, adj[N], nxt[2*N], go[2*N];
int fa[N], son[N], sze[N], top[N], idx[N], pos[N], tot, ed[N];
ll f[N][2];

struct matrix {
    ll g[2][2];
    matrix(){
	memset(g, 0, sizeof(g));
    }
    matrix operator * (const matrix &b) const {
	matrix c;
	for(int i = 0; i < 2; i++)
	    for(int j = 0; j < 2; j++)
		for(int k = 0; k < 2; k++)
		    c.g[i][j] = max(c.g[i][j], g[i][k] + b.g[k][j]);
	return c;
    }
} val[N], data[4*N];

void add(int u, int v){
    go[++ecnt] = v;
    nxt[ecnt] = adj[u];
    adj[u] = ecnt;
}

void init(){
    static int que[N];
    que[1] = 1;
    for(int ql = 1, qr = 1; ql <= qr; ql++)
	for(int u = que[ql], e = adj[u], v; e; e = nxt[e])
	    if((v = go[e]) != fa[u])
		fa[v] = u, que[++qr] = v;
    for(int qr = n, u; qr; qr--){
	sze[u = que[qr]]++;
	sze[fa[u]] += sze[u];
	if(sze[u] > sze[son[fa[u]]])
	    son[fa[u]] = u;
    }
    for(int ql = 1, u; ql <= n; ql++)
	if(!top[u = que[ql]]){
	    for(int v = u; v; v = son[v])
		top[v] = u, idx[pos[v] = ++tot] = v;
	    ed[u] = tot;
	}
    for(int qr = n, u; qr; qr--){
	u = que[qr];
	f[u][1] = max(0, a[u]);
	for(int e = adj[u], v; e; e = nxt[e])
	    if(v = go[e], v != fa[u]){
		f[u][0] += max(f[v][0], f[v][1]);
		f[u][1] += f[v][0];
	    }
    }
}

void build(int k, int l, int r){
    if(l == r){
	ll g0 = 0, g1 = a[idx[l]];
	for(int u = idx[l], e = adj[u], v; e; e = nxt[e])
	    if((v = go[e]) != fa[u] && v != son[u])
		g0 += max(f[v][0], f[v][1]), g1 += f[v][0];
	data[k].g[0][0] = data[k].g[0][1] = g0;
	data[k].g[1][0] = g1;
	val[l] = data[k];
	return;
    }
    int mid = (l + r) >> 1;
    build(k << 1, l, mid);
    build(k << 1 | 1, mid + 1, r);
    data[k] = data[k << 1] * data[k << 1 | 1];
}
void change(int k, int l, int r, int p){
    if(l == r){
	data[k] = val[l];
	return;
    }
    int mid = (l + r) >> 1;
    if(p <= mid) change(k << 1, l, mid, p);
    else change(k << 1 | 1, mid + 1, r, p);
    data[k] = data[k << 1] * data[k << 1 | 1];
}
matrix query(int k, int l, int r, int ql, int qr){
    if(ql <= l && qr >= r) return data[k];
    int mid = (l + r) >> 1;
    if(qr <= mid) return query(k << 1, l, mid, ql, qr);
    if(ql > mid) return query(k << 1 | 1, mid + 1, r, ql, qr);
    return query(k << 1, l, mid, ql, qr) * query(k << 1 | 1, mid + 1, r, ql, qr);
}
matrix ask(int u){
    return query(1, 1, n, pos[top[u]], ed[top[u]]);
}
void path_change(int u, int x){
    val[pos[u]].g[1][0] += x - a[u];
    a[u] = x;
    matrix od, nw;
    while(u){
	od = ask(top[u]);
	change(1, 1, n, pos[u]);
	nw = ask(top[u]);
	u = fa[top[u]];
	val[pos[u]].g[0][0] += max(nw.g[0][0], nw.g[1][0]) - max(od.g[0][0], od.g[1][0]);
	val[pos[u]].g[0][1] = val[pos[u]].g[0][0];
	val[pos[u]].g[1][0] += nw.g[0][0] - od.g[0][0];
    }
}

int main(){

    read(n);
    read(m);
    for(int i = 1; i <= n; i++) read(a[i]);
    for(int i = 1, u, v; i < n; i++)
	read(u), read(v), add(u, v), add(v, u);
    init();
    build(1, 1, n);
    int u, x;
    matrix t;
    while(m--){
	read(u), read(x);
	path_change(u, x);
	t = ask(1);
	write(max(t.g[0][0], t.g[1][0])), enter;
    }

    return 0;
}

```

---

## 作者：distantlight (赞：49)

虽然正解是动态dp，这技术也是很神仙了。这题其实很简单一个增量式就能过了（或者说数据水？）

首先单次查询的树形DP不用细说了
状态：
	f[u][0]=顶点u的子树，u不选，最大收益
	f[u][1]=顶点u的子树，u选，最大收益
转移方程（v是u的子节点）：
	f[u][0]=sum{max(f[v][0],f[v][1])}+V[u]
	f[u][1]=sum{f[v,0]}

一次点更新只会影响到x及其祖先节点的状态值，于是我们只要更新这些节点就可以了。就暴力重算转移方程就行了。理论上最坏情况应该是O(nm)，但是对随机数据，实际被重算的节点和重算量远小于n（本人试了生成树高度为n/2的随机数据，照样秒过）

真比赛的时候，你会选择动态dp吗？显然不会对不对呵呵

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N=100009;
struct E { int t,nxt; } es[N<<1];

// f是父节点
int n,m,cnt,dp[N][2],hd[N],a[N],f[N];

void add(int x,int y) {
    es[++cnt]=(E){y,hd[x]},hd[x]=cnt;
    es[++cnt]=(E){x,hd[y]},hd[y]=cnt;
}

void dfs(int x,int fa) {
    dp[x][1]=a[x],dp[x][0]=0,f[x]=fa;
    for (int i=hd[x];i;i=es[i].nxt) {
        if (es[i].t==fa) continue;
        dfs(es[i].t,x);
        dp[x][0]+=max(dp[es[i].t][1],dp[es[i].t][0]);
        dp[x][1]+=dp[es[i].t][0];
    }
}

int main(){
    scanf("%d%d",&n,&m);
    for (int i=1;i<=n;++i) scanf("%d",a+i);
    for (int i=1,x,y;i<n;++i) scanf("%d%d",&x,&y),add(x,y);
    dfs(1,0);
    for (int i=1,x,y;i<=m;++i) {
        scanf("%d%d",&x,&y);
        for (a[x]=y;x;x=f[x]){ // 重算所有祖先
            dp[x][1]=a[x],dp[x][0]=0;
            for (int j=hd[x];j;j=es[j].nxt) {
                if (es[j].t==f[x]) continue;
                dp[x][0]+=max(dp[es[j].t][1],dp[es[j].t][0]);
                dp[x][1]+=dp[es[j].t][0];
            }
        }
        printf("%d\n",max(dp[1][0],dp[1][1]));
    }
    return 0;
}
```

实测由于动态dp巨大的常数，这个代码比正解还要快3倍左右



---

## 作者：xyr2005 (赞：36)

# P4719



## 题目描述

给定一棵 $n$ 个点的树，点带点权。

有 $m$ 次操作，每次操作给定 $x,y$，表示修改点xx的权值为 $y$。

你需要在每次操作之后求出这棵树的最大权独立集的权值大小。

$1 \leq n,m \leq 10^5$



------



独立集 : 无向图中互不相邻的点组成的集合  

最大权独立集 : 无向图中权值和最大的独立集  



------



### 暴力

先看看问题的弱化版 : 没有修改操作 , $1 \leq n \leq 10^5$  

考虑树形dp  

用 $f[i][0]$ 表示以 $i$ 为根的子树中(包括 $i$ ) , 不选择 $i$ 能得到的最大权值和  

用 $f[i][1]$ 表示以 $i$ 为根的子树中(包括 $i$ ) , 选择 $i$ 能得到的最大权值和  

~~显然~~ $f[i][0]=\displaystyle\sum_{u \in i.son} max(f[u][0],f[u][1])$  

$f[i][1]=value[i]+\displaystyle\sum_{u \in i.son} f[u][0]$  

时间复杂度是 $O(n)$ 的

但如果每次修改后都对整棵树dp一次就变成$O(nm)$ 肯定会T



------



### 一个简单的优化

我们发现每次更改一个点的权值后 , 其实只有从这个点到根节点的路径上的dp值需要变化  

那么我们就只需要改这条链上的dp值就行了 , 那么复杂度就是 $O(\displaystyle\sum Len)$

当数据是一条链时 , 就和上一个暴力一样了



------



再考虑另一个子问题 : 有一个序列 $a_1 , a_2 ... a_n$  , 要求选出若干个数 

在保证选出的数两两不相邻的情况下 , 数字和最大 

有 $m$ 次修改权值 , $1 \leq n,m \leq 10^5$



这就要用到动态dp了

朴素的方法:

> $f[i][0]$ 表示从头到 $i$ 且 $i$ 不选得到的最大权值和
>
> $f[i][1]$ 表示从头到 $i$ 且 $i$ 选得到的最大权值和
>
> $f[i][0]=max(f[i-1][0],f[i-1][1])$  
>
> $f[i][1]=value[i]+f[i-1][0]$

接着我们把转移写成矩阵乘法的形式   

广义矩阵乘法 :   $A*B=C$          
$ C_{i,j}=max(a_{i,k}+b_{k,j} )$

```cpp
matrix operator + (const matrix &A, const matrix &B)
{
    matrix C;
    memset(C.data,-63,sizeof(C.data));
    for (int k=0;k<2;++k)
        for (int i=0;i<2;++i)
            for (int j=0;j<2;++j)
                C.data[i][j]=max(C.data[i][j],
                                 A.data[i][k]+B.data[k][j]);
    return C;
}
```



可以证明这种矩阵乘法仍具有结合律



接着尝试把转移写成乘法  

$$ \begin{bmatrix}0 & 0 \\v[i] & -\infty\end{bmatrix} \times \begin{bmatrix}f[i-1][0] \\f[i-1][1]\end{bmatrix}=\begin{bmatrix}f[i][0] \\f[i][1]\end{bmatrix} $$  


然后我们发现每个序列中的数都对应了一个矩阵


$$ \begin{bmatrix}0 & 0 \\v[i] & -\infty\end{bmatrix} $$  

当我们要查询 $[l,r]$ 的答案时 , 将 $[l,r]$ 中的所有矩阵乘起来就好了

于是想到了线段树

修改也很简单 , 在线段树上一路走下去 , 到叶子节点时候 , 直接改就行了 , 回溯时PushUp

时间复杂度 $O(mlogn)$



------



这题把问题出到了树上 , 那再套个 LCT 或树剖就好了

可以用$g[i][0/1]$ 表示 在以 $i$ 为根的子树中 , 轻儿子及其子树的dp值  

$g[i][0]=\displaystyle\sum _{u \in i.lightson}max(f[u][0],f[u][1]) $

$g[i][1]=value[i]+\displaystyle\sum _{u \in i.lightson} f[u][0]$  

那么

$f[i][0]=g[i][0]+max(f[i.heavyson][0],f[i.heavyson][1])$

$f[i][1]=g[i][1]+f[i.heavyson][0]$

然后把转移改写成矩阵乘法的形式  

$$ \begin{bmatrix}g[x][0] & g[x][0] \\g[x][1] & -\infty\end{bmatrix}\times\begin{bmatrix}f[son[i]][0] \\f[son[i]][1]\end{bmatrix}=\begin{bmatrix}f[i][0] \\f[i][1]\end{bmatrix} $$

这样就可以用 LCT 去维护了

我们在 $access$ 时维护 $g$ 数组 , 在 $PushUp$ 时维护 $f$ 数组  

修改时先 $access$ 再$Splay$ , 这时修改 , 对其他节点没有影响 , 直接改上去就好了

询问时把1号节点 $Splay$ 到根 , 输出 $max(f[x][0],f[x][1])$ 就好了

还有一个小技巧 , 初始化时先把所有儿子当做轻儿子 , 用dp值初始化 $f$ 和 $g$ 就好了

具体细节看代码吧



```cpp
#include<cstdio>
#include<cstring>
#define Finline __inline__ __attribute__ ((always_inline))
const int BUFSIZE=1<<26;
char ibuf[BUFSIZE],*p1=ibuf,*p2=ibuf+fread(ibuf,1,BUFSIZE,stdin);
char obuf[BUFSIZE],buf[13],*t=obuf;
Finline void read(int &x)
{
    char c=*p1++;
    bool f=0;
    while(c<48||c>57)
    {
        f|=c=='-';
        c=*p1++;
    }
    x=c&15;
    c=*p1++;
    while(c>=48&&c<=57) x=(x<<3)+(x<<1)+(c&15),c=*p1++;
    x=f?-x:x;
}
Finline void print(int u)
{
    static char *q=buf;
    if(!u) *t++=48;
    else
    {
    	if(u<0) *t++='-',u=-u;
        while(u) *q++=u%10+48,u/=10;
        while(q!=buf) *t++=*--q;
    }
    *t++='\n';
}
const int inf=0x3f3f3f3f,N=1000005;
Finline int max(const int &a,const int &b){return a>b?a:b;}
struct matrix{
    int a[2][2];
    Finline void New(const int &A,const int &B){a[0][0]=a[0][1]=A,a[1][0]=B,a[1][1]=-inf;}
    Finline int Max(){return max(a[0][0],a[1][0]);}
    Finline matrix operator * (const matrix &B)const
    {
        matrix c;
        for(int i=0;i<2;++i)
        {
            for(int j=0;j<2;++j)
            {
                c.a[i][j]=max(a[i][0]+B.a[0][j],a[i][1]+B.a[1][j]);
            }
        }
        return c;
    }
};
struct node{
    int fa,ch[2],f[2];
    matrix x;
}f[N];
struct edge{
    int v,nxt;
}c[N<<1];
int front[N],cnt,v[N];
Finline void add(const int &u,const int &v){c[++cnt]=(edge){v,front[u]},front[u]=cnt;}
Finline bool isroot(const int &x){return f[f[x].fa].ch[0]!=x&&f[f[x].fa].ch[1]!=x;}
Finline bool Identify(const int &x){return f[f[x].fa].ch[1]==x;}
Finline void PushUp(const int &x)
{
    f[x].x.New(f[x].f[0],f[x].f[1]);
    if(f[x].ch[0]) f[x].x=f[f[x].ch[0]].x*f[x].x;
    if(f[x].ch[1]) f[x].x=f[x].x*f[f[x].ch[1]].x;
}
Finline void rotate(const int &x)
{
    int y=f[x].fa,z=f[y].fa,k=Identify(x),w=f[x].ch[k^1];
    if(!isroot(y)) f[z].ch[Identify(y)]=x;
    f[y].ch[k]=w,f[x].ch[k^1]=y;
    if(w) f[w].fa=y;
    f[x].fa=z,f[y].fa=x;
    PushUp(y),PushUp(x);
}
Finline void Splay(const int &x)
{
    int y;
    while(!isroot(x))
    {
        y=f[x].fa;
        if(!isroot(y)) rotate(Identify(x)==Identify(y)?y:x);
        rotate(x);
    }
    PushUp(x);
}
Finline void Access(int x)
{
    for(int y=0;x;x=f[y=x].fa)
    {
        Splay(x);
        if(f[x].ch[1])
        {
            f[x].f[0]+=f[f[x].ch[1]].x.Max();
            f[x].f[1]+=f[f[x].ch[1]].x.a[0][0];
        }
        if(y)
        {
            f[x].f[0]-=f[y].x.Max();
            f[x].f[1]-=f[y].x.a[0][0];
        }
        f[x].ch[1]=y;
        PushUp(x);
    }
}
void dfs(const int &x,const int &fa)
{
    f[x].f[1]=v[x];
    for(int i=front[x];i;i=c[i].nxt)
    {
        if(c[i].v!=fa)
        {
            f[c[i].v].fa=x;
            dfs(c[i].v,x);
            f[x].f[0]+=max(f[c[i].v].f[0],f[c[i].v].f[1]);
            f[x].f[1]+=f[c[i].v].f[0];
        }
    }
    f[x].x.New(f[x].f[0],f[x].f[1]);
}
int main()
{
    int n,m,x,y;
    read(n),read(m);
    for(int i=1;i<=n;i++) read(v[i]);
    for(int i=1;i<n;i++)
    {
        read(x),read(y);
        add(x,y);
        add(y,x);
    }
    dfs(1,0);
    while(m--)
    {
        read(x),read(y);
        Access(x),Splay(x);
        f[x].f[1]+=y-v[x],v[x]=y;
        PushUp(x);
        Splay(1);
        print(f[1].x.Max());
    }
    return fwrite(obuf,1,t-obuf,stdout),0;
}
```



---

## 作者：Soulist (赞：33)

之前看题解看不懂，不会那些神仙写的递归建树什么的$.......$，更别说用全局平衡二叉树了，虽然貌似这道题可以用树剖卡过去，所以还是写个树剖的题解？

首先我们考虑朴素的暴力$dp$，显然要记两维$dp_{x,0}$表示不选，$dp_{x,1}$表示选

那么比较朴素的想法就是：

$dp_{x,1} = \sum_{v}dp_{v,0} + val[x]$

$dp_{x,0} = \sum_{v} max(dp_{v,0}, dp_{v,1})$

然后这个东西放在树上，那么我们如果直接转移，是要对其儿子进行统计，转移相对较为麻烦，所以我们先对树进行轻重链剖分，然后:

考虑记$ldp_{x,0}$表示只考虑$x$的轻儿子且x不选的$dp$值，$ldp_{x,1}$表示只考虑$x$的轻儿子且x选的$dp$值

然后$dp_{x,0}$和$dp_{x,1}$与之前仍然相同

这样弄的话有什么好处？

我们发现对于某一个点$x$，以$x$为根的子树答案其实就是其重儿子的$dp$加上其轻儿子$ldp$的值

我们接下来定义一个新定义运算，表示新矩阵乘法。


$\begin{bmatrix}a& b\\c&d\end{bmatrix}*\begin{bmatrix}k1&k2\\k3&k4\end{bmatrix}=\begin{bmatrix}max(a+k1,c+k2)&max(b+k1,d+k2)\\max(a+k3,c+k4)&max(b+k3,d+k4)\end{bmatrix}$

然后这东东仍然有结合律，所以我们可以用线段树维护。。。

考虑这道题的转移用矩阵优化

然后我们写一下这个东西的转移矩阵：

$\begin{bmatrix}dp_{son,0}\\dp_{son,1}\end{bmatrix} * \begin{bmatrix}ldp_{x,0}&ldp_{x,0}\\ldp_{x,1}&-inf\end{bmatrix} =\begin{bmatrix}dp_{x,0}\\dp_{son,1}\end{bmatrix} $ 

然后这个转移矩阵只和$ldp$值有关，所以实际上我们要求的答案-$dp$值即为几个点的$ldp$矩阵的**乘积**

之前貌似说了一句：

```cpp
我们发现对于某一个点x，以x为根的子树答案其实就是其重儿子的dp加上其轻儿子ldp的值
```

所以根据这个性质不难想到点$X$的答案即为以其为$top$的重链的矩阵乘积。。。

现在思路就比较明朗了。。

每次修改我们就直接修改这个转移矩阵的$ldp$值。

然后每次往上跳，跳到其所在重链顶部，计算一次新的$dp$值，然后用新的$dp$值去更新$top$的父亲的矩阵。。。

更新部分可以好好看看？可以想想我们怎么得到$dp$值，那么我们就怎么还原回去。。。

```cpp
#include<bits/stdc++.h>
using namespace std;
int read(){
    char cc = getchar(); int cn = 0, flus = 1;
    while(cc < '0' || cc > '9'){  if(cc == '-') flus = -flus; cc = getchar();  }
    while(cc >= '0' && cc <= '9')  cn = cn * 10 + cc - '0', cc = getchar();
    return cn * flus;
}

const int N = 1e5 + 5;

#define ls node * 2
#define rs node * 2 + 1
#define inf 999999999

struct Mat {
    int m[3][3];
    void init() {
        for( int i = 0; i <= 1; ++ i )
            for( int j = 0; j <= 1; ++ j )
                m[i][j] = -inf;
    }
}tr[N * 4], Val[N];

struct E {
    int to, next;
}e[N * 2];
struct Tree {
    int size, id, fa, top, son, dep, end;
}t[N * 2];

int n, m, cnt, ldp[N][2], dp[N][2], head[N], a[N], b[N], ctt;

void add( int x, int y ) {
    e[++cnt] = (E){ y, head[x] }, head[x] = cnt;
    e[++cnt] = (E){ x, head[y] }, head[y] = cnt;
}

//树链剖分

int dfs1( int x, int fa ) {
    t[x].dep = t[fa].dep + 1, t[x].size = 1; t[x].fa = fa;
    int tot, maxson = 0;
    for( int i = head[x]; i; i = e[i].next ) {
        int v = e[i].to;
        if( v == fa ) continue;
        t[x].size += (tot = dfs1(v, x));
        if( tot > maxson ) maxson = tot, t[x].son = v;
    }
    return t[x].size;
}

void dfs2( int x, int high ) {
    t[x].id = ++ ctt, b[ctt] = x;
    t[high].end = ctt, t[x].top = high; 
    if( !t[x].son ) {  return ;  }
    dfs2( t[x].son, high );
    for( int i = head[x]; i; i = e[i].next ) {
        int v = e[i].to;
        if( v == t[x].fa || v == t[x].son ) continue;
        dfs2(v, v);
    }
}

//预处理出初始的dp值和ldp值

void dfs3( int x ) {
    ldp[x][1] = a[x];
    for( int i = head[x]; i; i = e[i].next ) {
        int v = e[i].to;
        if( v == t[x].fa || v == t[x].son ) continue;
        dfs3( v ); ldp[x][0] += max( dp[v][1], dp[v][0] ), ldp[x][1] += dp[v][0];
    }
    dp[x][0] += ldp[x][0], dp[x][1] += ldp[x][1];
    if( !t[x].son ) return ;
    dfs3( t[x].son );
    dp[x][0] += max(dp[t[x].son][1], dp[t[x].son][0]);
    dp[x][1] += dp[t[x].son][0];
} 

//新定义矩阵乘法

Mat Mul( Mat a, Mat b ) {
    Mat ans; ans.init();
    for( int i = 0; i < 2; ++ i )  for( int j = 0; j < 2; ++ j )
    for( int k = 0; k < 2; ++ k )  ans.m[i][j] = max( ans.m[i][j], a.m[i][k] + b.m[k][j] );
    return ans;
}

//seg_Tree 

//这里的b[x]表示x这个点（线段树区间上的点）所对应的树上编号，那么初始化时我们记录一个Val[x]表示在树上编号为x的点所对应的矩阵，这样写会方便点。
void build( int node, int l, int r ) {
    if( l == r ) {
        Val[b[l]].m[0][0] = ldp[b[l]][0], Val[b[l]].m[1][0] = ldp[b[l]][1];
        Val[b[l]].m[0][1] = ldp[b[l]][0], Val[b[l]].m[1][1] = -inf;
        tr[node] = Val[b[l]];
        return ;
    }
    int mid = (l + r) >> 1;
    build( ls, l, mid ); build( rs, mid + 1, r );
    tr[node] = Mul( tr[ls], tr[rs] );
}

//ddp中询问有点不一样（跟我以前写线段树不太一样），需要特殊处理，主要是越界不能直接返回一个...全0/-inf矩阵（虽然其实也可以构造单位矩阵？）

Mat query( int node, int l, int r, int ql, int qr ) {
    if( l >= ql && r <= qr ) return tr[node];
    int mid = ( l + r ) >> 1;
    if( mid >= qr ) return query( ls, l, mid, ql, qr );
    if( mid < ql ) return query( rs, mid + 1, r, ql, qr );
    return Mul( query( ls, l, mid, ql, qr ), query( rs, mid + 1, r, ql, qr ) );
}
//树剖的跳
void update( int node, int l, int r, int wh ) {
    if( l == r && l == wh ) {
        tr[node] = Val[b[wh]];
        return ;
    }
    int mid = (l + r) >> 1;
    if( mid >= wh ) update( ls, l, mid, wh );
    else update( rs, mid + 1, r, wh );
    tr[node] = Mul( tr[ls], tr[rs] );
} 
// 树剖

Mat last, newm, k_ans;

void Change(int u, int w) {
    Val[u].m[1][0] += w - a[u];
    a[u] = w;
    while (u != 0) {
        int now = t[u].top;
        last = query(1, 1, n, t[now].id, t[now].end );
        update(1, 1, n, t[u].id);
        newm = query(1, 1, n, t[now].id, t[now].end );
        u = t[now].fa;
        Val[u].m[0][0] += max( newm.m[0][0], newm.m[1][0] ) - max( last.m[0][0], last.m[1][0] );
        Val[u].m[0][1] = Val[u].m[0][0];
        Val[u].m[1][0] += newm.m[0][0] - last.m[0][0];
  }
}
signed main()
{
    n = read(), m = read(); int x, y, z;
    for( int i = 1; i <= n; ++ i ) a[i] = read();
    for( int i = 1; i < n; ++ i ) x = read(), y = read(), add( x, y );
    dfs1(1, 0), dfs2(1, 1), dfs3(1), build( 1, 1, n );
    
    for( int i = 1; i <= m; ++ i ) {
        x = read(), y = read();
        Change( x, y ); 
        k_ans = query( 1, 1, n, t[1].id, t[1].end );
        printf("%d\n", max( k_ans.m[0][0], k_ans.m[1][0] ));
    }
    return 0;
}
```

---

## 作者：LPA20020220 (赞：28)

看到没有用$LCT$的大佬， 蒟蒻就提供一篇$LCT$的题解。

实际上$LCT$和树剖的维护方法是差不多的， 只是每个点都需要额外维护一下当前的$g(i,0/1)$。 $pushup$的时候先用$g(i,0/1)$初始化自己的矩阵， 然后用左儿子乘自己的矩阵， 再用自己乘右儿子的矩阵就好了。

为了好写， 可以先把所有儿子设为虚儿子， 然后直接用$dp[i][0/1]$初始化$g(i,0/1)$即可。

$access$的时候和树剖一样向上更新对应点的$g$值即可。

~~这是为数不多的几道LCT跑的比树剖快的题目了~~

代码如下：
```cpp
#include <cstdio>
#include <cmath>
#include <cstring>
#include <cstdlib>
#include <cctype>
#include <algorithm>
#define R register
#define IN inline
#define W while
#define gc getchar()
#define MX 100500
#define INF 1000000000
#define ll long long
bool neg;
template <class T>
IN void in(T &x)
{
	x = 0; R char c = gc;
	for (; !isdigit(c); c = gc)
	if (c == '-') neg = true;
	for (;  isdigit(c); c = gc)
	x = (x << 1) + (x << 3) + c - 48;
	if (neg) neg = false, x = -x;
}
template <class T> IN T max(T a, T b) {return a > b ? a : b;}
template <class T> IN T min(T a, T b) {return a < b ? a : b;}

int head[MX], val[MX], fat[MX], sta[MX];
ll dp[MX][2];
int dot, q, cnt, top;
struct Edge {int to, nex;} edge[MX << 1];
IN void add(R int from, R int to) {edge[++cnt] = {to, head[from]}, head[from] = cnt;}
struct Matrix
{
	ll mat[2][2];
	Matrix(){mat[0][0] = mat[0][1] = mat[1][0] = mat[1][1] = -INF;}
	IN void ini(ll a, ll b) {mat[0][0] = mat[0][1] = a, mat[1][0] = b, mat[1][1] = -INF;}
};
IN Matrix operator * (const Matrix &x, const Matrix &y)
{
	Matrix ret;
	ret.mat[0][0] = max(x.mat[0][0] + y.mat[0][0], x.mat[0][1] + y.mat[1][0]);
	ret.mat[0][1] = max(x.mat[0][0] + y.mat[0][1], x.mat[0][1] + y.mat[1][1]);
	ret.mat[1][0] = max(x.mat[1][0] + y.mat[0][0], x.mat[1][1] + y.mat[1][0]);
	ret.mat[1][1] = max(x.mat[1][0] + y.mat[0][1], x.mat[1][1] + y.mat[1][1]);
	return ret;
}
struct Node {int son[2], fat; ll f[2]; Matrix dp; bool rev;} tree[MX];
namespace LCT
{
	#define ls tree[now].son[0]
	#define rs tree[now].son[1]
	#define dad tree[now].fat
	IN bool get(R int now) {return tree[dad].son[1] == now;}
	IN bool nroot(R int now) {return tree[dad].son[0] == now || tree[dad].son[1] == now;}
	IN void pushup(R int now)
	{
		tree[now].dp.ini(tree[now].f[0], tree[now].f[1]);
		if (ls) tree[now].dp = tree[ls].dp * tree[now].dp;
		if (rs) tree[now].dp = tree[now].dp * tree[rs].dp;
	}
	IN void pushrev(R int now) {std::swap(ls, rs), tree[now].rev ^= 1;}
	IN void pushdown(R int now) {if (tree[now].rev) pushrev(ls), pushrev(rs), tree[now].rev = false;}
	IN void rotate(R int now)
	{
		R int fa = dad, grand = tree[fa].fat;
		R bool dir = get(now);
		tree[fa].son[dir] = tree[now].son[dir ^ 1];
		tree[tree[now].son[dir ^ 1]].fat = fa;
		tree[now].fat = grand;
		if (nroot(fa)) tree[grand].son[get(fa)] = now;
		tree[fa].fat = now;
		tree[now].son[dir ^ 1] = fa;
		pushup(fa); pushup(now);
	}
	IN void splay(R int now)
	{
		R int tmp = now, fa;
		sta[top = 1] = now;
		W (nroot(now)) sta[++top] = now = dad;
		W (top) pushdown(sta[top--]);
		now = tmp;
		W (nroot(now))
		{
			fa = dad;
			if (nroot(fa)) rotate(get(now) == get(fa) ? fa : now);
			rotate(now);
		}
		pushup(now);
	}
	IN void access(R int now)
	{
		for (R int x = 0; now; x = now, now = dad)
		{
			splay(now);
			if (rs)
			{
				tree[now].f[0] += max(tree[rs].dp.mat[0][0], tree[rs].dp.mat[1][0]);
				tree[now].f[1] += tree[rs].dp.mat[0][0];
			}
			if (x)
			{
				tree[now].f[0] -= max(tree[x].dp.mat[0][0], tree[x].dp.mat[1][0]);
				tree[now].f[1] -= tree[x].dp.mat[0][0];
			}
			rs = x; pushup(now);
		}
	}
	IN void makeroot(R int now) {access(now), splay(now), pushrev(now);}
	#undef ls
	#undef rs
	#undef dad
}
void DFS(R int now, R int fa)
{
	dp[now][1] = val[now];
	for (R int i = head[now]; i; i = edge[i].nex)
	{
		if (edge[i].to == fa) continue;
		tree[edge[i].to].fat = now;
		DFS(edge[i].to, now);
		dp[now][1] += dp[edge[i].to][0];
		dp[now][0] += max(dp[edge[i].to][0], dp[edge[i].to][1]);
	}
	tree[now].dp.ini(dp[now][0], dp[now][1]);
	tree[now].f[0] = dp[now][0], tree[now].f[1] = dp[now][1];
}
int main(void)
{
	int a, b, tar;
	ll buf;
	in(dot), in(q);
	for (R int i = 1; i <= dot; ++i) in(val[i]);
	for (R int i = 1; i < dot; ++i) in(a), in(b), add(a, b), add(b, a);
	DFS(1, 0);
	W (q--)
	{
		in(tar), in(buf);
		LCT::access(tar), LCT::splay(tar);
		tree[tar].f[1] += buf - val[tar]; val[tar] = buf;
		LCT::pushup(tar);
		LCT::splay(1);
		printf("%lld\n", max(tree[1].dp.mat[0][0], tree[1].dp.mat[1][0]));
	}
}
```

---

## 作者：ecnerwaIa (赞：19)

[题目](https://www.luogu.org/problemnew/show/P4719)
想都不用想,记$f[x][0]$为不选x节点的x子树最大权值和,$f[x][1]$为选x节点的x子树最大权值和

则有
#### $f[x][0]=\sum {max(f[u][0],f[u][1])}(u\in son[x])$
#### $f[x][1]=v[x]+\sum{f[u][0]}(u\in son[x])$

但是如果要变得可维护，那么就不应该存在$\sum$对吧，那我们认为将整棵树进行轻虚实边剖分（这里用的是$link-cut-tree$，复杂度比树剖少一个log），
剖分之后发现只用维护实边上信息就好了，每个节点连的虚边很好维护，access
时修改虚实边时修改即可

#### $g[x][0]=\sum{max(f[u][0],f[u][1])}(u\in son[x])$（不包括重儿子即实边相连的儿子）
#### $g[x][1]=v[x]+\sum{f[u][0]}$（不包括重儿子即实边相连的儿子）

则有

$f[x][0]=g[x][0]+max(f[u][0],f[u][1])$（u为重儿子）

$f[x][1]=g[x][1]+f[u][0]$(u为重儿子)

那么构造矩阵来维护就好了

$\begin{bmatrix}g[x][0]&g[x][0]\\g[x][1]&-\infty\end{bmatrix}\times\begin{bmatrix}f[u][0]\\f[u][1]\end{bmatrix}=\begin{bmatrix}f[x][0]\\f[x][1]\end{bmatrix}$

因为满足矩阵结合律,那么维护lct上一个节点矩阵$prd[x]=prd[lc]*val[x]*prd[rc]$($val:$单位矩阵，$prd:$以含x的链上的每个节点为根的所有子树的所有$val$的乘积)就行了

access的时候会改变右儿子（有的话）,右儿子从重变轻,相应的$g[x]$要加上对应的值,同样 令$ch[x][1]=y$，从轻变重,$g[x]$要减去对应的值

这样就愉快的A了这题
```cpp
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <algorithm>
#define max_(a,b) (a>b?a:b)
using namespace std;
//f[x][0]=sigma(f[son[x]][0],f[son[x]][1])(所有儿子)
//f[x][1]=v[x]+sigma(f[son[x]][0])(所有儿子)
//令g[x][0]=sigma(f[son[x]][0],f[son[x]][1])(轻儿子) 
//g[x][1]=sigma(f[son[x]][0])+v[x](轻儿子)
//则有f[x][0]=g[x][0]+max(f[u][0],f[u][1])
//f[x][1]=g[x][1]+f[u][0] 
//那么构造矩阵维护即可 
const int inf=(1<<30);
struct Matrix{int a[2][2];Matrix(){a[0][0]=a[0][1]=a[1][0]=a[1][1]=-inf;}};
inline Matrix operator *(Matrix A,Matrix B){
	Matrix C;
	for(int i=0;i<2;++i)
		for(int j=0;j<2;++j)
			for(int k=0;k<2;++k)
				C.a[i][j]=max_(C.a[i][j],A.a[i][k]+B.a[k][j]);
	return C;
}
const int N=100010;
int a[N],dp[N][2],d[N],nxt[N<<1],to[N<<1],tot;
inline void ins(int a,int b){to[++tot]=b;nxt[tot]=d[a];d[a]=tot;}
struct link_cut_tree{
	Matrix val[N],prd[N];
	int ch[N][2],fa[N];
	#define lc ch[x][0]
	#define rc ch[x][1]
	inline void pushup(int x){prd[x]=val[x];if(lc)prd[x]=prd[lc]*prd[x];if(rc)prd[x]=prd[x]*prd[rc];}
	inline bool root(int x){int y=fa[x];return !((ch[y][0]==x)||(ch[y][1]==x));}
	inline void rotate(int x){
		int y=fa[x],z=fa[y],k=ch[y][1]==x;
		if(!root(y))ch[z][ch[z][1]==y]=x;
		fa[x]=z;ch[y][k]=ch[x][k^1];if(ch[x][k^1])fa[ch[x][k^1]]=y;
		ch[x][k^1]=y;fa[y]=x;pushup(y);pushup(x);
	}inline void splay(int x){
		int y,z;
		while(!root(x)){
			y=fa[x],z=fa[y];
			if(!root(y)){(ch[y][1]==x)^(ch[z][1]==y)?rotate(x):rotate(y);}
			rotate(x);
		}
	}
	inline void access(int x){
		for(int y=0;x;x=fa[y=x]){
			splay(x);
			if(rc){
				val[x].a[0][0]+=max_(prd[rc].a[0][0],prd[rc].a[1][0]);
				val[x].a[1][0]+=prd[rc].a[0][0];
			}
			if(y){
				val[x].a[0][0]-=max_(prd[y].a[0][0],prd[y].a[1][0]);
				val[x].a[1][0]-=prd[y].a[0][0];
			}val[x].a[0][1]=val[x].a[0][0];
			rc=y;pushup(x);
		}
	}
	inline void modify(int x,int y){
		access(x);splay(x);
		val[x].a[1][0]-=a[x]-y;
		pushup(x);a[x]=y;
	}
	inline void dfs(int x){
		dp[x][1]=a[x];
		for(int i=d[x];i;i=nxt[i]){
			int u=to[i];
			if(u!=fa[x]){
				fa[u]=x;
				dfs(u);
				dp[x][0]+=max_(dp[u][0],dp[u][1]);
				dp[x][1]+=dp[u][0];
			}
		}
		val[x].a[0][0]=val[x].a[0][1]=dp[x][0];
		val[x].a[1][0]=dp[x][1];
		prd[x]=val[x];
	}
}my;
int n,m;
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;++i)scanf("%d",&a[i]);
	int a,b;
	for(int i=1;i<n;++i){scanf("%d%d",&a,&b);ins(a,b);ins(b,a);}
	my.dfs(1);
	for(int i=1;i<=m;++i){
		scanf("%d%d",&a,&b);
		my.modify(a,b);
		my.splay(1);
		printf("%d\n",max_(my.prd[1].a[0][0],my.prd[1].a[1][0]));
	} 
	return 0;
}
```
Update:
g维护的我想说的是不包括重儿子，即实边相连的儿子，逗号后面内容是做补充说明，现进行修改。  
防抄的话其实我也是当时看到很多的题解喜欢这么做就跟着搞了一个，望谅解。

---

## 作者：Treaker (赞：14)

$$\color{cornflowerblue}{\mathcal{Treaker}}$$
# 动态DP （树链剖分 + 矩阵）
前几天考了一道DDP，今天就来做一下这道DDP模板题。

没想到按照那道题的思路，这道题很神奇的就过了。

前置芝士：[没有上司的舞会 ](https://www.luogu.org/problem/P1352)

这道题就是没有上司的舞会的动态版（带修改）。

首先DDP的状态转移方程一般很好推。比如这道题。

设$f[x][0]$表示$x$的子树内不选$x$这个节点的贡献，$f[x][1]$表示$x$的子树内选$x$这个节点的贡献。

$$f[x][0] = \sum_{son}max(f[son][0],f[son][1])$$
$$f[x][1] = val[x] + \sum_{son}f[son][0]$$

但是好像不太好维护。

那么对于DDP，而且是用树链剖分来维护的。我们选择把重儿子单独拿出来。
并且引入$g[x][0]$表示$x$的子树内不选$x$这个节点$+$所有轻儿子的贡献。
$g[x][1]$表示$x$的子树内选$x$这个节点$+$所有轻儿子的贡献。。。则有

(我们用$v$来代表重儿子)
$$g[x][0] = \sum_{u~\in~lightson}max(f[u][0],f[u][1])$$
$$g[x][1] = \sum_{u~\in~lightson}f[u][0]$$
$$f[x][0] = g[x][0] + max(f[v][0],f[v][1])$$
$$f[x][1] = g[x][1] + val[x] + f[v][0]$$

那么构造矩阵

$$\begin{bmatrix}f[v][0] & f[v][1]\end{bmatrix} * \begin{bmatrix}g[x][0]& g[x][1] + val[x]\\g[x][0] & -\infty\end{bmatrix} = \begin{bmatrix}f[x][0]&f[x][1]\end{bmatrix}$$

这里的矩阵是要重定义的，原来矩阵乘法的乘法变成加法，加法变取$max$。（可以自己手玩一下，严谨的证明不是很会，只是知道满足结合律）

但是我们发现矩阵里没有$f$这个值呢。可是我们用的就是$f$的值啊

更神奇的事情发生了，我们发现对于一个重链的末端节点，他的$2*2$的矩阵就是左边的$1*2$的矩阵，也就是说重链的末端节点保存了$f$的准确值，我们可以通过一个一个矩阵来推出我们想要的值（跳$fa$乘矩阵，然后循环）。

那么再与树链剖分结合，我们决定把这个$2*2$矩阵放到线段树的每个节点来维护。
省去了一直跳$fa$的过程。

一直到这里我们知道了一个节点的$f$的值可以由所在重链的末端节点通过$O(logn)$的时间来求出（这也是我为什么维护一个$bot$表示一个重链的末端节点）。

注意：矩阵乘的时候要右乘坐，因为要模拟跳$fa$的过程，是从$dfs$序大的向$dfs$序小的地方，对应到线段树就是从右向左。

但是修改怎么办呢。

我们之前已经做好了铺垫（我们把重儿子与轻儿子拆开的目的就是为了方便我们的修改过程）。

我们观察这个矩阵，我们的矩阵维护的全部是$g$数组的值（还有一个$g[x][1] + val[x]$），而$g$数组本质上维护的是轻儿子，也就是说我们修改这个节点时，不会影响到其所在重链的其他节点的矩阵，我们直接单点修改即可。但是我们再看，我们的$val[x]$的更新，可能会导致$top[x]$的$f$值的更新，那么$top[x]$作为$fa[top[x]]$的轻儿子的贡献就需要更新，我们再更新，至此循环往复，一条跳到$1$所在的那条重链结束。

这里注意：我们修改的值要提前记录好了，因为我们要的是最开始的值，修改之后再算贡献可能不对。

就是这里
```cpp
inline void sec_chenge(int x)
{
	martix res;
	while(top[x] != 1)
	{
		res = query(root,dfn[top[x]],dfn[bot[x]]);
		g[fa[top[x]]][0] -= max(res.f[0][0],res.f[0][1]);
		g[fa[top[x]]][1] -= res.f[0][0];
		chenge(root,dfn[x]);
		res = query(root,dfn[top[x]],dfn[bot[x]]);
		g[fa[top[x]]][0] += max(res.f[0][0],res.f[0][1]);
		g[fa[top[x]]][1] += res.f[0][0];
		x = fa[top[x]];
	}
	chenge(root,dfn[x]);
}
```
完整代码如下：
```cpp
#include <cstdio>
#include <iostream>
#include <cstring>
#define wfx CF.LOL();
#define AK return
#define IOI 0;
using namespace std;
const int N = 1e5+5 , inf = 1e9;
inline int read()
{
	int x = 0 , f = 1;	char ch = getchar();
	while(ch < '0' || ch > '9')	{if(ch == '-')	f = -1; ch = getchar();}
	while(ch >= '0' && ch <= '9') {x = (x << 3) + (x << 1) + (ch ^ 48); ch = getchar();}
	return x * f;
}
int n , m , cnt , ans;
int a[N] , top[N] , fa[N] , dfn[N] , id[N] , size[N] , bot[N] , dep[N] , f[N][2] , g[N][2] , hs[N];
struct martix
{
	int f[2][2];
	martix() {f[0][0] = f[0][1] = f[1][0] = f[1][1] = 0;}
	inline void init() {f[0][1] = f[1][0] = -inf;}
	inline void MIN() {f[0][0] = f[0][1] = f[1][0] = f[1][1] = -inf;}
};
martix operator * (const martix &a,const martix &b)
{
	martix res; res.MIN();
	for(int k = 0;k < 2;k ++) for(int i = 0;i < 2;i ++) for(int j = 0;j < 2;j ++) res.f[i][j] = max(res.f[i][j],a.f[i][k] + b.f[k][j]);
	return res;
}
struct Tree_Div
{
	struct Edge
	{
		int to; Edge *nxt;
		Edge(int to,Edge *nxt) : to(to) , nxt(nxt) {}
	}*head[N];
	inline void add(int u,int v) {head[u] = new Edge(v,head[u]);}
	void get_tree(int x)
	{
		size[x] = 1;
		for(Edge *i = head[x];i;i = i -> nxt)
		{
			int to = i -> to;
			if(dep[to]) continue;
			dep[to] = dep[x] + 1;
			fa[to] = x;
			get_tree(to);
			size[x] += size[to];
			if(size[to] > size[hs[x]]) hs[x] = to;
		}
	}
	void dfs(int x,int topfa)
	{
		top[x] = topfa;
		dfn[x] = ++cnt;
		id[cnt] = x;
		f[x][1] = a[x];
		if(hs[x]) dfs(hs[x],topfa) , bot[x] = bot[hs[x]] , f[x][0] = max(f[hs[x]][0],f[hs[x]][1]) , f[x][1] += f[hs[x]][0];
		else bot[x] = x;
		for(Edge *i = head[x];i;i = i -> nxt)
		{
			int to = i -> to;
			if(to == hs[x] || to == fa[x]) continue;
			dfs(to,to);
			g[x][0] += max(f[to][0],f[to][1]);
			g[x][1] += f[to][0];
		}
		f[x][1] += g[x][1];
		f[x][0] += g[x][0];
	}
	#define mid ((p -> l + p -> r) >> 1)
	struct node
	{
		node *ls , *rs;
		int l , r; martix x;
		node(int l,int r) : l(l) , r(r) {ls = rs = NULL;}
		inline void up() {x = rs -> x * ls -> x;}
	}*root;
	Tree_Div() {root = NULL;}
	void build(node *&p,int l,int r)
	{
		p = new node(l,r);
		if(l == r) return (void)(p -> x.f[0][0] = g[id[l]][0] , p -> x.f[0][1] = g[id[l]][1] + a[id[l]] , p -> x.f[1][0] = g[id[l]][0] , p -> x.f[1][1] = -inf);
		build(p -> ls,l,mid); build(p -> rs,mid+1,r); p -> up();
	}
	void chenge(node *p,int x)
	{
		if(p -> l == p -> r) return (void)(p -> x.f[0][0] = g[id[x]][0], p -> x.f[0][1] = g[id[x]][1] + a[id[x]] , p -> x.f[1][0] = g[id[x]][0]);
		chenge(x <= mid ? p -> ls : p -> rs , x); p -> up();
	}
	martix query(node *p,int x,int y)
	{
		if(x <= p -> l && p -> r <= y) return p -> x; martix res; res.init();
		if(y > mid) res = res * query(p -> rs,x,y);
		if(x <= mid) res = res * query(p -> ls,x,y);
		return res;
	}
	inline void sec_chenge(int x)
	{
		martix res;
		while(top[x] != 1)
		{
			res = query(root,dfn[top[x]],dfn[bot[x]]);
			g[fa[top[x]]][0] -= max(res.f[0][0],res.f[0][1]);
			g[fa[top[x]]][1] -= res.f[0][0];
			chenge(root,dfn[x]);
			res = query(root,dfn[top[x]],dfn[bot[x]]);
			g[fa[top[x]]][0] += max(res.f[0][0],res.f[0][1]);
			g[fa[top[x]]][1] += res.f[0][0];
			x = fa[top[x]];
		}
		chenge(root,dfn[x]);
	}
	inline void LOL()
	{
		n = read(); m = read();
		for(int i = 1;i <= n;i ++) a[i] = read();
		for(int i = 1 , u , v;i < n;i ++) 
		{
			u = read(); v = read();
			add(u,v); add(v,u);
		}
		dep[1] = 1; get_tree(1);
		dfs(1,1);
		build(root,1,n);
		for(int i = 1 , x , y;i <= m;i ++)
		{
			x = read(); y = read();
			a[x] = y; sec_chenge(x);
			martix res = query(root,dfn[1],dfn[bot[1]]);
			printf("%d\n",max(res.f[0][0],res.f[0][1]));
		}
	}
}CF;
int main() {wfx AK IOI}
```


---

## 作者：Regimes (赞：12)

蒟蒻非常的菜，只会树剖求解动态dp。

这道题，就是需要我们求一棵树的最大独立集，并且这玩意还是待修的。

那么我们首先考虑不要修改的。那么这其实就是 没有上司的舞会

对于$dp[x][0/1]$我们用$0$表示 不 选择这个点，$1$表示选择这个点。

那么：

$$dp[x][1]=w[x]+\sum_{v\epsilon son}dp[v][0]$$

$$dp[x][0]=\sum_{v\epsilon son}max(dp[v][1] , dp[v][0])$$

那么类似于树剖，树剖的加速在于对于一条到根节点的路径上轻边的个数和重链

的条数都是$log_{2}n$的。

那么我们考虑将轻重儿子分开。

设$ldp[x][0/1]$表示$x$点的轻儿子在父亲$x$也选择的情况下的最大独立集。那么这

里我们就可以暂且不要考虑重儿子。

同样：

$$ldp[x][1]=\sum_{v\epsilon lightson}dp[v][0]$$

$$ldp[x][0]=\sum_{v\epsilon lightson}max(dp[v][1],dp[v][0])$$

这些都可以预处理出来

于是我们可以尝试用矩阵的形式来表示一下：

新定义一下这个矩阵：

$\begin{pmatrix} a & b \\ c & d \end{pmatrix}$
$\begin{pmatrix} k1 & k2 \\ k3 & k4 \end{pmatrix}=$

$\begin{pmatrix} max(a+k1,c+k2) & max(b+k1,d+k2) \\ max(a+k3,c+k4) & max(b+k3,d+k4)  \end{pmatrix}$

然后可以脑补一下，这是满足分配律和结合律的。

$son$表示的是$x$的重儿子

$\begin{pmatrix} dp[son][0] \\ dp[son][1] \end{pmatrix} $
$\begin{pmatrix} ldp[x][0] & ldp[x][0] \\ ldp[x][1] & -inf \end{pmatrix}=$
$\begin{pmatrix} dp[x][0] \\ dp[x][1] \end{pmatrix}$

我们知道对于一个叶子节点$dp[son][0]==0$,$dp[son][1]==0$

那么我们可以在只关心一个点的轻儿子的情况下，实现儿子向父亲$dp$值的一

个递推。

首先$O(n)$的进行预处理

然后对于每一个点，我们只需要记录它轻儿子的信息即可。

而对于每个点的修改，其实会被影响到的也只有这个点和链上轻边父亲的信息

需要被更改（因为它所在重链上的点也只关心其轻儿子）。

而对于一个点的轻儿子信息，其实就就是修改的那个轻儿子所在链的矩阵乘

积。这个用线段树可做。

复杂度$O(nlog_2^2n)$

然后带矩阵的优秀常数

贴代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 300007
#define ls (x<<1)
#define rs (x<<1|1)
#define inf 199999999
int n , m , tot , cnt ;
int son[N] , dep[N] , siz[N] , fa[N] , num[N] , bel[2*N] , top[N] , ed[N] , w[N] ;
int dp[N][2] , ldp[N][2] ;
int fire[N] , to[2*N] , nex[2*N] ;
struct node{
    int m[5][5] ;
    void init(){
        for(int i = 0 ; i <= 2 ; i++){
            for(int j = 0 ; j <= 2 ; j++ ) m[i][j] = -inf ;
        }
    }
}fox[N*4] , val[N] ;
struct OFN{
    int l ;
    int r ;
}tree[N*4] ;
void add(int u , int v){
    nex[++tot] = fire[u] ;
    fire[u] = tot ;
    to[tot] = v ;
    return ;
}
void dfs1(int x , int fr){
    fa[x] = fr ; dep[x] = dep[fr] + 1 ; siz[x] = 1 ;
    int Max = 0 ;
    for(int i = fire[x] ; i ; i = nex[i] ){
        int v = to[i] ;
        if( v == fr) continue ;
        dfs1( v , x ) ;
        siz[x] += siz[v] ;
        if( siz[v] > Max ) Max = siz[v] , son[x] = v ;
    }
    return ;
}
void dfs2(int x , int fr){
    top[x] = fr ;
    num[x] = ++cnt ;
    bel[cnt] = x ; ed[fr] = x ;
    if( son[x] ) dfs2( son[x] , fr ) ;
    for(int i = fire[x] ; i ; i = nex[i] ){
        int v = to[i] ;
        if( v == fa[x] || v == son[x] ) continue ;
        dfs2( v , v ) ;
    }
    ed[x] = ed[fr] ;
}
void dfs3(int x){
    ldp[x][1] = w[x] ;
    for(int i = fire[x] ; i ; i = nex[i] ){
        int v = to[i] ;
        if( v == son[x] || v == fa[x] ) continue ;
        dfs3( v ) ;
        ldp[x][0] += max( dp[v][0] , dp[v][1] ) ;
        ldp[x][1] += dp[v][0] ;
    }
    dp[x][0] += ldp[x][0] ; dp[x][1] += ldp[x][1] ;
    if( son[x] ){
        dfs3( son[x] ) ;
        dp[x][0] += max( dp[son[x]][1] , dp[son[x]][0] ) ;
        dp[x][1] += dp[son[x]][0] ;
    }
}
node mul(node x , node y){
    node res ;
    res.init() ;
    for(int i = 0 ; i <= 1 ; i++ ){
        for(int j = 0 ; j <= 1 ; j++ ){
            for(int k = 0 ; k <= 1 ; k++ ){
                res.m[i][j] = max( res.m[i][j] , x.m[i][k] + y.m[k][j] ) ;
            }
        }
    }
    return res ;
}
void build(int x , int l , int r ){
    tree[x].l = l ; tree[x].r = r ;
    if( l == r ){
        val[bel[l]].m[0][0] = ldp[bel[l]][0] ; val[bel[l]].m[1][0] = ldp[bel[l]][1] ;
        val[bel[l]].m[0][1] = ldp[bel[l]][0] ; val[bel[l]].m[1][1] = -inf ;
        fox[x] = val[bel[l]] ;
        return ;
    }
    int mid = ( l + r ) >> 1 ;
    build( ls , l , mid ) ; build( rs , mid + 1 , r ) ;
    fox[x] = mul( fox[ls] , fox[rs] ) ; return ;
}
node query(int x , int l , int r ){
    if( l <= tree[x].l && tree[x].r <= r ) return fox[x] ;
    int mid = ( tree[x].l + tree[x].r ) >> 1 ;
    if( mid >= r ) return query( ls , l , r ) ;
    if( mid < l ) return query( rs , l , r ) ;
    return mul( query( ls , l , r ) , query( rs , l ,  r) ) ;
}
void update(int x , int pos ){
    if( tree[x].l == tree[x].r && tree[x].l == pos ){
        fox[x] = val[bel[pos]] ;
        return ;
    }
    int mid = ( tree[x].l + tree[x].r ) >> 1 ;
    if( mid >= pos ) update( ls , pos ) ;
    else update( rs , pos ) ;
    fox[x] = mul( fox[ls] , fox[rs] ) ;
}
void change(int x , int fr ){
    val[x].m[1][0] += fr - w[x] ;
    w[x] = fr ;
    while( x != 0 ){
        int v = top[x] ;
        node last = query( 1 , num[v] , num[ed[v]] ) ;
        update( 1 , num[x] ) ;
        node now = query( 1 , num[v] , num[ed[v]] ) ;
        x = fa[v] ;
        val[x].m[0][0] += max( now.m[0][0] , now.m[1][0] ) - max( last.m[0][0] , last.m[1][0] ) ;
        val[x].m[0][1] = val[x].m[0][0] ;
        val[x].m[1][0] += now.m[0][0] - last.m[0][0] ;
    }
}
int main()
{
    scanf("%d%d" , &n , &m ) ;
    for(int i = 1 ; i <= n ; i++ ) scanf("%d" , &w[i] ) ;
    for(int i = 1 ; i <= n - 1 ; i++ ){
        int u , v ;
        scanf("%d%d" , &u , &v ) ;
        add( u , v ) ; add( v , u ) ; 
    }
    dfs1( 1 , 0 ) ; dfs2(1 , 1) ; 
    dfs3( 1 ) ; build( 1 , 1 , n ) ;
    while( m-- ){
        int u , x ;
        scanf("%d%d" , &u , &x ) ;
        change( u , x ) ;
        node res = query( 1 , num[1] , num[ed[1]] ) ;
        printf("%d\n" , max( res.m[0][0] , res.m[1][0] ) ) ;
    }
    return 0 ;
}
```



---

## 作者：mrsrz (赞：8)

动态动态规划。

假如没有修改，则是一个简单的树形DP：

设$f_{i,0}$表示以$i$为根的子树，节点$i$不选的最大独立集。

$f_{i,1}$表示以$i$为根的子树，节点$i$选的最大独立集。

则$f_{i,0}=\sum_{s\in son_{i}}\max(f_{s,0},f_{s,1})$。

$f_{i,1}=\sum_{s\in son_{i}}f_{s,0}$。

~~然后它就随手给了你一个修改~~

我们需要一个东西来快速维护转移。

考虑用一个行向量来定义$i$节点的状态$\left[ \begin{matrix} f_{i,0} & f_{i,1}\end{matrix}\right]$。

然后，如果能有一个矩阵来进行快速转移状态，就可以用线段树一类的数据结构来维护了。

考虑新定义一种矩阵运算$A\oplus B=C$，其中$C_{i,j}=\max_{k}\{a_{i,k}+b_{k,j}\}$。

可以证明，这个运算也是满足结合律、不满足交换律的，所以直接当矩阵乘法用即可。

然后，对树进行树链剖分，重定义一下状态：

$f_{i,0}$表示以$i$为根的子树，节点$i$不选，且不考虑其重儿子的最大独立集。

$f_{i,1}$表示以$i$为根的子树，节点$i$选的最大独立集。

考虑当前状态加上重儿子$p$的状态会变成什么。

设$g$表示每个点的实际DP值（加上重儿子后），则：

$g_{i,0}=f_{i,0}+\max(g_{p,0},g_{p,1})$，$g_{i,1}=f_{i,1}+g_{p,0}$。

用我们刚刚定义的矩阵乘法来写的话，就是：

$$\left[\begin{matrix}  g_{i,0} & g_{i,1}  \end{matrix}\right]= \left[\begin{matrix} f_{i,0}& f_{i,1} \end{matrix}\right]\oplus\left[\begin{matrix}  g_{p,0}& g_{p,1} \\ g_{p,0} & -\infty   \end{matrix}\right]$$

还有如下性质：

$$\left[\begin{matrix}  g_{p,0}& g_{p,1} \\ g_{p,0} & g_{p,1}   \end{matrix}\right]\oplus\left[\begin{matrix}  f_{i,0}& f_{i,1} \\ f_{i,0} & -\infty   \end{matrix}\right] =\left[\begin{matrix}\max(g_{p,0}+f_{i,0},g_{p,1}+f_{i,0})&\max(g_{p,0}+f_{i,1},g_{p,1}-\infty)\\ \max(g_{p,0}+f_{i,0},g_{p,1} + f_{i,0}) & \max(g_{p,0}+f_{i,1},g_{p,1}-\infty)        \end{matrix}\right]=\left[\begin{matrix}  g_{i,0} & g_{i,1}\\g_{i,0} & g_{i,1}  \end{matrix}\right]$$

你会发现我们每次只需要左边那个矩阵的第一行，也就是说第二行是用来占位的，所以下面构造的时候，右下角元素赋值成\\(-\infty\\)也没问题。


而对于一条重链链尾的节点，其$f_i=g_i$。

然后我们发现，$g_p$的状态也是通过$f_p$的状态乘上一个转移矩阵得来的（链尾除外）。所以自然想到用线段树维护区间的矩阵乘法（刚刚定义的$\oplus$）。

对于每个节点$i$，首先把它的$f$处理出来（此时$i$的轻儿子已经处理完毕，又因为这个轻儿子一定是一条重链的链首，所以其DP值可以一遍线段树上查询得出），然后，构建转移矩阵：

$$\left[\begin{matrix}  f_{i,0}& f_{i,1} \\ f_{i,0} & -\infty   \end{matrix}\right]$$

扔进线段树里。

之后，每条重链的链首的DP值，就可以通过线段树区间查询该重链的乘积得到。

对于修改操作，首先把这个节点对于的矩阵的值修改。这样，这条重链的值就会被修改，则上面的重链的值也会相应修改。

沿着重链往上跳，然后每次修改链首元素的父节点的矩阵即可。

由于最多跳$\log$条重链，所以单次修改的时间复杂度$O(8\log^2 n)$。

查询的话，直接查根节点的这条重链即可。单次查询$O(8\log n)$。

总时间复杂度$O(8m\log^2n)$。

注意矩阵乘法**不满足交换律**，而我的做法是自下向上合并的，所以线段树维护的时候要用右边区间的矩阵乘上左边区间的矩阵。

## Code：
```cpp
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>
#include<stack>
#define N 100005
#define inf 1000000000
struct istream{
	int c;
	template<typename T>
	inline istream&operator>>(T&d){
		int b=0;
		while(!isdigit(c=getchar()))b=c=='-';
		for(d=0;isdigit(c);c=getchar())
		d=(d<<3)+(d<<1)+(c^'0');
		if(b)d=-d;
		return*this;
	}
}cin;
int n,m,V[N],head[N],cnt=0,dep[N],top[N],fa[N],sz[N],son[N],dfn[N],idx=0,idfn[N],tail[N];
struct edge{
	int to,nxt;
}e[N<<1];
struct trans{
	int a[2][2],r,c;
	inline trans(){memset(a,0,sizeof a);}
	inline trans operator*(const trans&b)const{
		trans c;
		c.r=r,c.c=b.c;
		for(int i=0;i<r;++i)
		for(int j=0;j<c.c;++j)
		for(int k=0;k<b.r;++k){
			c.a[i][j]=std::max(c.a[i][j],a[i][k]+b.a[k][j]);
		}
		return c;
	}
}d[N<<2],s[N];
trans query(int l,int r,int o,const int&L,const int&R){
	if(L<=l&&r<=R)return d[o];
	const int mid=l+r>>1;
	if(L<=mid&&mid<R)return query(mid+1,r,o<<1|1,L,R)*query(l,mid,o<<1,L,R);else
	if(mid<R)return query(mid+1,r,o<<1|1,L,R);else
	if(L<=mid)return query(l,mid,o<<1,L,R);
}
void modify(int l,int r,int o,const int&pos,const trans&to){
	if(l==r)d[o]=to;else{
		const int mid=l+r>>1;
		if(pos<=mid)modify(l,mid,o<<1,pos,to);else
		modify(mid+1,r,o<<1|1,pos,to);
		d[o]=d[o<<1|1]*d[o<<1];
	}
}
void dfs(int now){
	sz[now]=1,son[now]=0;
	for(int i=head[now];i;i=e[i].nxt)
	if(!dep[e[i].to]){
		dep[e[i].to]=dep[now]+1;
		fa[e[i].to]=now;
		dfs(e[i].to);
		sz[now]+=sz[e[i].to];
		if(!son[now]||sz[son[now]]<sz[e[i].to])son[now]=e[i].to;
	}
}
void dfs2(int now){
	idfn[dfn[now]=++idx]=now;
	if(son[now])top[son[now]]=top[now],dfs2(son[now]);
	for(int i=head[now];i;i=e[i].nxt)
	if(e[i].to!=son[now]&&dep[e[i].to]>dep[now])dfs2(top[e[i].to]=e[i].to);
	tail[now]=(son[now])?tail[son[now]]:now;
}
void calc(int now){
	std::stack<int>q;
	for(int i=now;i;i=son[i])q.push(i);
	while(!q.empty()){
		int u=q.top();
		q.pop();
		int x=0,y=V[u];
		for(int i=head[u];i;i=e[i].nxt)
		if(dep[e[i].to]>dep[u]&&e[i].to!=son[u]){
			calc(e[i].to);
			trans q=s[e[i].to];
			x+=std::max(q.a[0][0],q.a[0][1]);
			y+=q.a[0][0];
		}
		trans q;
		q.r=q.c=2;
		q.a[0][0]=q.a[1][0]=x;
		q.a[0][1]=y;
		q.a[1][1]=-inf;
		modify(1,n,1,dfn[u],q);
	}
	s[now]=query(1,n,1,dfn[now],dfn[tail[now]]);
}
void modify(int u,int val){
	trans p=query(1,n,1,dfn[u],dfn[u]);
	p.a[0][1]+=val-V[u];
	modify(1,n,1,dfn[u],p);
	V[u]=val;
	for(int now=top[u];now!=1;now=top[now]){
		int f=fa[now];
		p=query(1,n,1,dfn[f],dfn[f]);
		trans q=query(1,n,1,dfn[now],dfn[tail[now]]);
		p.a[0][0]+=std::max(q.a[0][0],q.a[0][1])-std::max(s[now].a[0][0],s[now].a[0][1]);
		p.a[0][1]+=q.a[0][0]-s[now].a[0][0];
		p.a[1][0]=p.a[0][0];
		modify(1,n,1,dfn[f],p);
		s[now]=q;
		now=f;
	}
}
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;++i)cin>>V[i];
	for(int i=1;i<n;++i){
		int u,v;
		cin>>u>>v;
		e[++cnt]=(edge){v,head[u]};head[u]=cnt;
		e[++cnt]=(edge){u,head[v]};head[v]=cnt;
	}
	dfs(dep[1]=1);dfs2(top[1]=1);
	calc(1);
	while(m--){
		int x,y;
		cin>>x>>y;
		modify(x,y);
		trans p=query(1,n,1,1,dfn[tail[1]]);
		printf("%d\n",std::max(p.a[0][0],p.a[0][1]));
	}
	return 0;
}
```

---

## 作者：genshy (赞：4)

# 动态 dp

2020.9.5 update 更改了错误的转移矩阵

动态 $dp$ 是由猫坤大佬在 WC 2018 提出来的黑科技。

他主要解决得是带修改的 $dp$ 问题,主要思路是由矩阵乘法来维护 $dp$ 转移

我们先来看一道模板题 [动态dp](https://www.luogu.com.cn/problem/P3235)

这道题，我们先来看不带修改的情况，

转移和状态很容易就能列出来

设 $f[i][0/1]$ 表示 以 $i$ 为根的子树中，且选 (不选)  $i$ 这个点的最大权值和

转移方程可以写成：

$f[i][0] = \displaystyle \sum_{to \in son[i]} max (f[to][0],f[to][1])$

$f[i][1] = \displaystyle \sum_{to \in son[x]} f[to][0]\ + w[x]$

当我们修改一个点的权值，那么从他到根节点的路径上的点的 $dp$ 值都会受到影响。

所以，我们就可以只修改这一条链上的信息（用树链剖分来维护）。

动态 $dp$ 的思想就是将 重儿子和轻儿子的贡献分开来考虑。

设 $g[i][0] = \displaystyle \sum _{to \in 轻儿子} max(f[to][0],f[to][1])$, $g[i][1] = \displaystyle \sum_{to \in 轻儿子} f[to][0]\ +w[i] $.

解释一下 $g[i][0]$ 表示 选 或不选 $i$ 的轻儿子的最大贡献和， $g[i][1]$ 表示不选他轻儿子的价值和加上他本身的权值.

这两个可以在求 $f[x][0/1]$ 的时候顺便维护出来

那么，上面的方程就可以写成。

$f[i][0] = g[i][0] + max(f[son[i]][0],f[son][i][1])$

$f[i][1] = g[i][1] + f[son[i]][0]$ ($son[x]$  表示 $x$ 的重儿子)

定义广义矩阵乘法：

矩阵 $c$ 为 矩阵 A 和矩阵 B 的乘积 

那么，$c[i][j] = max( a[i][k] + b[k][j])$

这个其实就是把普通的矩阵乘法的乘号改为加号，加号改为取 $max$

这种矩阵乘法也满足普通矩阵乘法的性质，不相信的可以跑几组数据试试

代码实现长这样:

```cpp
node operator *(node x,node y)
{
    node ans;
    for(int i = 0; i <= n; i++)
        for(int j = 0; j <= n; j++)
            for(int k = 0; k <= n; k++)
                ans.a[i][j] = max(ans.a[i][j],x.a[i][k] + y.a[k][j]);
    return ans;
}
```

然后，我们就可以根据这个广义矩阵乘法构造一个矩阵，即，
$$
\left[
\begin{matrix}
f[to] [0] \\
f[to] [1] \\
\end{matrix}     
\right]
\tag{2} \times
\left[
\begin{matrix}
\cdots \\
\cdots \\
\end{matrix}
\right] =
\left[
\begin{matrix}
\ f[i][0] \\
\ f[i][1] \\
\end{matrix}
\right]
$$
其中 第二个矩阵是我们要 确定的转移矩阵。

第二个矩阵构造出来长这样：
$$
\left[
\begin{matrix}
f[to] [0] \\
f[to] [1] \\
\end{matrix}     
\right]
\tag{2} \times
\left[
\begin{matrix}
\ g[i][0] & g[i][1] \\
\ g[i][0] & -\infin \\
\end{matrix}
\right] =
\left[
\begin{matrix}
\ f[i][0] \\
\ f[i][1] \\
\end{matrix}
\right]
$$


但，我们发现一个问题，我们矩阵中没有这个 $f$ 值，这，我们一开始的矩阵就没法转移啊。

其实，对于每一个重链的末尾节点，他的转移矩阵就是他的 $f$ 值，

> 也就是说重链的末端节点保存了 f的准确值  -by treaker 

这样，我们就可以由这个矩阵来推出这一条重链上每个点的信息。

我们的暴力做法就是一直跳他的父亲就是一直跳他的父亲节点，再把矩阵乘起来。

但，这样的复杂度还是不能接受。我们可以把这个矩阵放到线段树上来维护。

线段树的每个叶子节点存这个点的转移矩阵，每个节点表示左右儿子矩阵的乘积，

这样就可以用 O(log n) 的时间得到我们想要的信息。

在结合树剖套线段树的做法，就能做到维护这棵树的信息。

注意：矩阵乘法要右乘，因为我们是从 dfn序大的地方跳到 dfn序小的地方，在线段树上对应的是从右往左。

我们上面的转移矩阵就需要重构一下，变成
$$
\left[
\begin{matrix}
\ g[i][0] & g[i][0] \\
\ g[i][1] &  - \infin \\
\end{matrix}     
\right]
\tag{2} \times
\left[
\begin{matrix}
f[son[x]][0]\\
f[son[x]][1]\\
\end{matrix}
\right] =
\left[
\begin{matrix}
\ f[i][0] \\
\ f[i][1] \\
\end{matrix}
\right]
$$
 修改操作，上文我们提到了 ‘当我们修改一个点的权值，那么从他到根节点的路径上的点的 $dp$ 值都会受到影响’。

我们修改的就是从这个点到根节点的路径的矩阵，我们把这条链琛出来，发现他是重链和轻边交替在一起的。

我们仔细观察一下我们构造的矩阵，发现里面维护的是轻儿子的信息，不会涉及到重儿子。  

对于重链，我们不用修改，但对于重链链顶 $top[x] $和轻边 $fa[top[x]] $交替的地方，我们需要单点修改。

因为此时链顶 $top[x]$ 属于 $fa[top[x]] $轻儿子，他的修改会对他父亲的转移矩阵造成影响。

我们关键要算出他改变之后对他父亲转移矩阵的影响。

他的 $f$ 值我们可以由下面的推出来，然后可以根据 $g$ 数组的定义算出他改变之后对他父亲的影响。

就这样在更新，每次跳重链，直到跳到根节点，我们的修改操作就大工告成了。

注意一下，我们不能修改之后在统计他的 轻儿子的值，那样可能不对，我们就只能通过增量法来修改。

记录一下原来状态的矩阵，在记录修改之后的矩阵，两者之差就是对他父亲转移矩阵的贡献。

每次修改操作的时间复杂度为 O($log^2 n$)

具体代码长这样

```cpp
void modify(int x,int val)
{
    base[dfn[x]].a[1][0] += val - w[x];//增量法统计他修改的贡献
    w[x] = val;
    while(x)
    {
        node Old = get_node(top[x]);//记录一下链顶修改之前的矩阵
        chenge(1,1,n,dfn[x]);//修改当前这个节点的转移矩阵
        node New = get_node(top[x]);//得到链顶修改之后的转移矩阵
        int fx = dfn[fa[top[x]]];
        base[fx].a[0][0] += max(New.a[0][0],New.a[1][0]) - max(Old.a[0][0],Old.a[1][0]);//算他修改对他父亲转移矩阵的影响
        base[fx].a[0][1] += max(New.a[0][0],New.a[1][0]) - max(Old.a[0][0],Old.a[1][0]);
        base[fx].a[1][0] += New.a[0][0] - Old.a[0][0];
        x = fa[top[x]];//跳链修改
    }
}
```

总代码：

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
const int inf = 233333333;
const int N = 1e5+10;
int n,m,tot,x,y,num,val,u,v;
int head[N],top[N],dep[N],siz[N],fa[N],son[N],ord[N],end[N],f[N][2],g[N][2],dfn[N],w[N];
struct bian
{
    int to,net;
}e[N<<1];
struct node
{
    int a[2][2];
    node() {memset(a,-127/3,sizeof(a));}
}tr[N<<2],base[N];
inline int read()
{
    int s = 0,w = 1; char ch = getchar();
    while(ch < '0' || ch > '9'){if(ch == '-') w = -1; ch = getchar();}
    while(ch >= '0' && ch <= '9'){s =s * 10+ch - '0'; ch = getchar();}
    return s * w;
}
node operator *(node x,node y)//广义矩阵乘法
{
    node ans;
    for(int i = 0; i <= 1; i++)
    {
        for(int j = 0; j <= 1; j++)
        {
            for(int k = 0; k <= 1; k++)
            {
                ans.a[i][j] = max(ans.a[i][j],x.a[i][k] + y.a[k][j]);
            }
        }
    }
    return ans;
}
void add(int x,int y)
{
    e[++tot].to = y;
    e[tot].net = head[x];
    head[x] = tot;
}
void get_tree(int x)//树剖预处理
{
    dep[x] = dep[fa[x]] + 1; siz[x] = 1;
    for(int i = head[x]; i; i = e[i].net)
    {
        int to = e[i].to;
        if(to == fa[x]) continue;
        fa[to] = x;
        get_tree(to);
        siz[x] += siz[to];
        if(siz[son[x]] < siz[to] || son[x] == -1) son[x] = to;
    }
}
void dfs(int x,int topp)
{
    top[x] = topp; dfn[x] = ++num; ord[num] = x;//END 记录这条重链的链尾，ord记录当前 当前这个节点的树上编号
    if(son[x] == -1)
    {
        end[topp] = num;
        return;
    }
    dfs(son[x],topp);
    for(int i = head[x]; i; i = e[i].net)
    {
        int to = e[i].to;
        if(to == fa[x] || to == son[x]) continue;
        dfs(to,to);
    }
}
void dp(int x,int fa)//预处理为没修改之前的 f 值与 g 值
{
    g[x][1] = f[x][1] = w[x];
    for(int i = head[x]; i; i = e[i].net)
    {
        int to = e[i].to;
        if(to == fa) continue;
        dp(to,x);
        f[x][0] += max(f[to][0], f[to][1]);
        f[x][1] += f[to][0];
        if(to != son[x])
        {
            g[x][0] += max(f[to][0], f[to][1]);
            g[x][1] += f[to][0];
        }
    }
}
void up(int o)
{
    tr[o] = tr[o<<1] * tr[o<<1|1];
}
void build(int o,int L,int R)//线段树建树
{
    if(L == R)
    {
    	int tmp = ord[L];
        tr[o].a[0][0] = tr[o].a[0][1] = g[tmp][0];//构造转移矩阵
        tr[o].a[1][0] = g[tmp][1]; 
        base[L] = tr[o];
        return;
    }
    int mid = (L + R)>>1;
    build(o<<1,L,mid);
    build(o<<1|1,mid+1,R);
    up(o);
}
void chenge(int o,int l,int r,int x)//单点修改
{
    if(l == r)
    {
        tr[o] = base[l];
        return;
    }
    int mid = (l + r)>>1;
    if(x <= mid) chenge(o<<1,l,mid,x);
    if(x > mid) chenge(o<<1|1,mid+1,r,x);
    up(o);
}
node query(int o,int l,int r,int L,int R)//区间查询
{
    if(L <= l && R >= r) return tr[o];
    int mid = (l + r)>>1;
    if(R <= mid) return query(o<<1,l,mid,L,R);
    if(L > mid) return query(o<<1|1,mid+1,r,L,R);
    return query(o<<1,l,mid,L,R) * query(o<<1|1,mid+1,r,L,R);
}
node get_node(int x)//得到链顶的 f 值
{
    return query(1,1,n,dfn[x],end[top[x]]);
}
void modify(int x,int val)
{
    base[dfn[x]].a[1][0] += val - w[x];//增量法统计他修改的贡献
    w[x] = val;
    while(x)
    {
        node Old = get_node(top[x]);//记录一下链顶修改之前的矩阵
        chenge(1,1,n,dfn[x]);//修改当前这个节点的转移矩阵
        node New = get_node(top[x]);//得到链顶修改之后的转移矩阵
        int fx = dfn[fa[top[x]]];
        base[fx].a[0][0] += max(New.a[0][0],New.a[1][0]) - max(Old.a[0][0],Old.a[1][0]);//算他修改对他父亲转移矩阵的影响
        base[fx].a[0][1] += max(New.a[0][0],New.a[1][0]) - max(Old.a[0][0],Old.a[1][0]);
        base[fx].a[1][0] += New.a[0][0] - Old.a[0][0];
        x = fa[top[x]];//跳链修改
    }
}
int main()
{
    n = read(); m = read();
    for(int i = 1; i <= n; i++)
    {
        w[i] = read();
        son[i] = -1;
    }
    for(int i = 1; i <= n-1; i++)
    {
    	u = read(); v = read();
    	add(u,v); add(v,u);
    }
    get_tree(1); dfs(1,1); dp(1,0); build(1,1,n);//预处理
    for(int i = 1; i <= m; i++)
    {
        x = read(); val = read();
        modify(x,val);//修改操作
        node ans = get_node(1);//得到新答案
        printf("%d\n",max(ans.a[0][0],ans.a[1][0]));
    }
    return 0;
}
```





---

## 作者：封禁用户 (赞：4)

暴力竟然进了第一页！！！

还是一道紫题！！！

我也没懂，我这$O(mh)$的算法竟然能过！！！

思路：

$dp[i][0]$记录没选此点的最大值

$dp[i][1]$记录选此点的最大值

先树形$dp$(树形$dp$应该都会吧，都来做紫题了)，然后对于每个修改都重新树形$dp$，但是只需要修改他的祖先。~~如果出题毒瘤，那就会变成~~$O(nm)$

重新计算他的祖先时，不用把每个儿子都算一遍，只需要算这个点有修改过的儿子前后两次的差值。

code time：
```cpp
 /*      西江月·证明
	即得易见平凡，仿照上例显然。
   留作习题答案略， 读者自证不难。 

	反之亦然同理，推论自然成立。 
	略去过程QED，由上可知证毕。*/
#include<set>
#include<map>
#define mod 10
#include<list>
#include<cmath>
#include<queue>
#include<ctime>
#include<stack>
#include<ctime>
#include<bitset>
#include<memory>
#include<cstdio>
#include<string>
#include<sstream>
#include<utility>
#include<cstdlib>
#include<cstring>
#include<iostream>
#include<algorithm>
#define rg register
#define bll __int128 
#define ll long long
#define inf 214232409
#define ull unsigned long long
#define debug() cout<<"SOSOSOSOSOSOSOS!!!!!!!!!"
#define C(i,j) dp[i+1][j+1]
using namespace std;
int read(){
	int ans=0,f=1;char a=getchar();while(a>'9'||a<'0'){if(a=='-')f=(-1);a=getchar();}
	while(a>='0'&&a<='9')ans=(ans<<3)+(ans<<1)+a-'0',a=getchar();return ans*f;
}//一条long long的黄金分割线---------------------------------------------------------------------------------------------
int n,m,v[100005],first[100005],cnt,fa[100005],root=1,dp[100005][2],x,y,z,now,now_val;
struct edge{
	int to,nxt;
}e[200005];
void add(int x,int y){
	e[++cnt].nxt=first[x];
	e[cnt].to=y;
	first[x]=cnt;
}
void dfs(int now,int f){
	fa[now]=f;dp[now][1]=v[now];
	for(int i=first[now],v;i;i=e[i].nxt){
		v=e[i].to;
		if(v==f)continue;
		dfs(v,now);
		dp[now][0]+=max(dp[v][0],dp[v][1]);
		dp[now][1]+=dp[v][0];
	}
}//树形dp ，不会可以先去学习一下。 
int main()
{
	n=read();m=read();
	for(int i=1;i<=n;i++)v[i]=read();
	for(int i=1;i<n;i++)add(read(),read());
	dfs(root,-1);
	for(int i=1;i<=m;i++){
		x=read();y=read();
		int fx=dp[x][0],fy=dp[x][1];
		dp[x][1]=dp[x][1]-v[x]+y;
		int now=fa[x],son=x,ldp0=fx,ldp1=fy;
		while(now+1){
			int fx=dp[now][0],fy=dp[now][1];
			dp[now][0]-=max(ldp0,ldp1)-max(dp[son][0],dp[son][1]);//根据上面dfs的树形dp递推公式统计差值 
			dp[now][1]-=ldp0-dp[son][0];//同理
			son=now,now=fa[now],ldp0=fx,ldp1=fy;//记录当前点，因为无法知道下一个点的儿子，记录当下一个点
			//还记录原来dp的值，计算差值 
		}
		v[x]=y;
		printf("%d\n",max(dp[root][0],dp[root][1]));//输出dp结果 
	}
	return 0;
}
/*
 * ┌───┐   ┌───┬───┬───┬───┐ ┌───┬───┬───┬───┐ ┌───┬───┬───┬───┐ ┌───┬───┬───┐
 * │Esc│   │ F1│ F2│ F3│ F4│ │ F5│ F6│ F7│ F8│ │ F9│F10│F11│F12│ │P/S│S L│P/B│  ┌┐    ┌┐    ┌┐
 * └───┘   └───┴───┴───┴───┘ └───┴───┴───┴───┘ └───┴───┴───┴───┘ └───┴───┴───┘  └┘    └┘    └┘
 * ┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───────┐ ┌───┬───┬───┐ ┌───┬───┬───┬───┐
 * │~ `│! 1│@ 2│# 3│$ 4│% 5│^ 6│& 7│* 8│( 9│) 0│_ -│+ =│ BacSp │ │Ins│Hom│PUp│ │Num│ / │ * │ - │
 * ├───┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─────┤ ├───┼───┼───┤ ├───┼───┼───┼───┤
 * │ Tab │ Q │ W │ E │ R │ T │ Y │ U │ I │ O │ P │{ [│} ]│ | \ │ │Del│End│PDn│ │ 7 │ 8 │ 9 │   │
 * ├─────┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴─────┤ └───┴───┴───┘ ├───┼───┼───┤ + │
 * │ Caps │ A │ S │ D │ F │ G │ H │ J │ K │ L │: ;│" '│ Enter  │               │ 4 │ 5 │ 6 │   │
 * ├──────┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴────────┤     ┌───┐     ├───┼───┼───┼───┤
 * │ Shift  │ Z │ X │ C │ V │ B │ N │ M │< ,│> .│? /│  Shift   │     │ ↑ │     │ 1 │ 2 │ 3 │   │
 * ├─────┬──┴─┬─┴──┬┴───┴───┴───┴───┴───┴──┬┴───┼───┴┬────┬────┤ ┌───┼───┼───┐ ├───┴───┼───┤ E││
 * │ Ctrl│ Win│ Alt│         Space         │ Alt│ Win│Menu│Ctrl│ │ ← │ ↓ │ → │ │   0   │ . │←─┘│
 * └─────┴────┴────┴───────────────────────┴────┴────┴────┴────┘ └───┴───┴───┘ └───────┴───┴───┘
 */
```


---

## 作者：xukuan (赞：4)

### 一道骗分好题

建树时以1为根节点，对每个点跑树形dp。

修改时从修改的点开始，往上更改，直到跑到根节点或没有影响的点为止

什么叫没有影响的点？

就是每一个点往根节点跑，直到对于有一个点，它dp的值没有改变

这样的话之后dp的值也是一样，没必要更新。

话说如果不算后面加强的数据的话，我这个代码可以跑到全站第一，管理能不能加强一下数据啊

### 代码：
```cpp
#include<bits/stdc++.h>
#include<iostream>
#include<cstdio>
#define ll long long
using namespace std;

ll n,m,a[100010],father[100010],f[100010][2];
ll ver[200010],Next[200010],head[100010],tot;
//father是父节点
//f[x][0]表示点x不选时以x为根节点的最大权独立集的权值大小
//f[x][1]表示点x选时以x为根节点的最大权独立集的权值大小

inline ll read(){//输入优化
    ll x=0,tmp=1;
    char ch=getchar();
    while(!isdigit(ch)){
    	if(ch=='-') tmp=-1;
    	ch=getchar();
    }
    while(isdigit(ch)){
    	x=(x<<3)+(x<<1)+(ch^48);
        ch=getchar();
    }
    return tmp*x;
}

inline void write(ll x){//输出优化
    if(x<0){
        putchar('-');
        x=-x;
    }
    ll y=10,len=1;
    while(y<=x){
        y=(y<<3)+(y<<1);
        len++;
    }
    while(len--){
        y/=10;
        putchar(x/y+48);
        x%=y;
    }
}

inline void addEdge(ll x,ll y){//链式前向星加边
	ver[++tot]=y;
	Next[tot]=head[x];
	head[x]=tot;
}

void dfs(ll x,ll before){//树形dp
	father[x]=before; f[x][1]=a[x];
	for(ll i=head[x]; i; i=Next[i]){
		ll y=ver[i];
		if(y==before) continue;
		dfs(y,x);
		f[x][0]+=max(f[y][0],f[y][1]);
		f[x][1]+=f[y][0];
	}
}

void update(ll k){
	if(k==1) return;
	ll x=father[k],t1=0,t2=a[x];
	for(ll i=head[x]; i; i=Next[i]){
		ll y=ver[i];
		if(y==father[x]) continue;
		t1+=max(f[y][0],f[y][1]);
		t2+=f[y][0];
	}
	if(t1==f[x][0]&&t2==f[x][1]) return;//如果没有影响，直接结束
	f[x][0]=t1; f[x][1]=t2;
	update(x);//继续更新
}

int main(){
	n=read(); m=read();
	for(ll i=1; i<=n; i++) a[i]=read();
	for(ll i=1; i<n; i++){
		ll x=read(),y=read();
		addEdge(x,y);
		addEdge(y,x);
	}
	dfs(1,0);
	while(m--){
		ll x=read(),val=read();
		f[x][1]=f[x][1]-a[x]+val;
		a[x]=val;
		update(x);
		write(max(f[1][0],f[1][1])); putchar('\n');
	}
	return 0;
}
```

---

## 作者：Spasmodic (赞：3)

看到这种 $O(n\log^2n)$ 还常数大的可以暴力 dp 过掉。

首先设 $dp(i,j)$ 表示考虑第 $i$ 个节点的子树，且要求这个节点状态为 $j$ 时的答案。

那么状态转移方程为：
$$dp(i,0)=\sum_{u\in i.son}\max(dp(u,0),dp(u,1))$$
$$dp(i,1)=v_i+\sum_{u\in i.son}dp(u,0)$$

当然了，我们肯定不能每次更新重新 dp，我们可以考虑优化。

可以发现修改$u$节点的时候只会改变 $1-u$ 这一条链的 dp 数组。

因此我们可以考虑自底向上修改这一条链上的 dp 数组，每次暴力重算即可，单次修改复杂度期望是 $O(h_ud)$，$h_u$ 是 $u$ 的高度，$d$ 是平均度数。

注意到每条边会对度数总和贡献 $1$，因此 $d=\frac{n-1}{n}=O(1)$。

代码：
```cpp
#include<bits/stdc++.h>
#define N 100005
using namespace std;
int n,m,p[N],tot,hd[N],f[N],dp[N][2];
struct edge{int t,nxt;}es[N<<1];
void add(int u,int v){es[++tot]=(edge){v,hd[u]},hd[u]=tot;}
void dfs(int x,int fa){
	dp[x][1]=p[x],dp[x][0]=0,f[x]=fa;
	for(int i=hd[x];i;i=es[i].nxt){
		if(es[i].t==fa)continue;
		dfs(es[i].t,x);
		dp[x][0]+=max(dp[es[i].t][1],dp[es[i].t][0]);
		dp[x][1]+=dp[es[i].t][0];
	}
}
int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)scanf("%d",&p[i]);
    for(int i=1,u,v;i<n;i++)scanf("%d%d",&u,&v),add(u,v),add(v,u),f[v]=u;
    dfs(1,0);
    for(int i=1,x,y;i<=m;i++){
    	scanf("%d%d",&x,&y);
    	for(p[x]=y;x;x=f[x]){
    		dp[x][1]=p[x],dp[x][0]=0;
    		for(int j=hd[x];j;j=es[j].nxt){
    			if(es[j].t==f[x])continue;
    			dp[x][0]+=max(dp[es[j].t][1],dp[es[j].t][0]);
				dp[x][1]+=dp[es[j].t][0];
			}
		}
		printf("%d\n",max(dp[1][0],dp[1][1]));
	}
	return 0;
}
```
由于这道题的数据是随机生成的，因此树的期望高度为 $O(\log n)$，则总复杂度期望为 $O(n\log n)$，不需要卡常就可以过。

当然，这种暴力遇到[这种题目](https://www.luogu.com.cn/problem/P4751)，那肯定就死了，要用其他方法。

~~然而我不会shadowice1984的上古科技，所以这篇文章到这里就结束了。~~

---

## 作者：杨铠远 (赞：2)

大佬们都写正解，太巨了，我这个蒟蒻写了一个暴力
没想到数据~~过水~~（~~其实请求加强数据是写这篇题解的目的~~），跑了大约240ms...

#### 大致思路：
树形dp维护选这个点或不选的最大值

先想象成序列上的问题

f[i][0] 表示不选i点的最大值

f[i][1] 表示选i点的最大值

因为是树形dp，就变成维护关于它和它子树的值

每次修改时暴力维护一遍显然会超时，60分

优化一：

每次维护修改的这个点到根的这条链

优化二：

修改这条链时，如果一个点修改前后信息不变，则停止修改，输出原来的答案即可

有了这两个优化，就可以AC了

### Code:

```cpp
//Code by : Y-k-y 
#include <iostream>
#include <algorithm>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <vector>
#define ll long long
const int N=200001;
using namespace std;
namespace YKY{
	inline int rnd(){//rnd版快读，read好像在linux下是关键字 
	int res=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){res=res*10+ch-'0';ch=getchar();}
	return res*f;
	}
	inline void wr(int x){
	if(x<0){putchar('-');x=-x;}if(x>9) wr(x/10);putchar(x%10+'0');
	}
	int f[N][2],val[N],head[N],ff[N];
	int n,m,tot;
	vector<int>vec[N];
	struct pp{
		int v,nxt;
	}edge[N];
	inline void add(int u,int v){
		edge[++tot].nxt=head[u],head[u]=tot;
		edge[tot].v=v;
	}
	inline void dfs(int u,int fa){
		f[u][1]=val[u];
		for(int i=head[u];i;i=edge[i].nxt){
			int v=edge[i].v;
			if(v==fa)continue;
			vec[u].push_back(v); //为了方便修改时的操作，用vector存下来（当然，邻接表也可以，但本题在O2环境下 vector更快） 
			ff[v]=u;//记录father,方便优化时使用 
			dfs(v,u);
			f[u][0]+=max(f[v][0],f[v][1]);
			f[u][1]+=f[v][0];
		}
	}
	inline int work(int u){
		int ans=0;//从当前点一直维护到修改前后不变值的那个点 
		while(233){
			int x1=f[u][1],x2=f[u][0];//记录 
			f[u][1]=val[u];f[u][0]=0;
			for(int i=0;i<(int)vec[u].size();i++){//现在，vector中只有ta的儿子 
				int v=vec[u][i];
				f[u][0]+=max(f[v][0],f[v][1]);
				f[u][1]+=f[v][0];
			}
			if(x1==f[u][1]&&x2==f[u][0])break;//退出 
			if(u==1)break;
			u=ff[u];
		}
		ans=max(f[1][0],f[1][1]);
		return ans;
	}
	int Main(){
		n=rnd();m=rnd();int x,y;
		for(int i=1;i<=n;i++)val[i]=rnd();
		for(int i=1;i<n;i++){
			x=rnd();y=rnd();
			add(x,y);add(y,x);
		}
		dfs(1,0);//预处理出答案 
		while(m--){
			x=rnd();y=rnd();
			val[x]=y;
			wr(work(x));puts("");
		}
		return 0;	
	}
}
int main(){
	return YKY :: Main();//拜拜 
}
```








---


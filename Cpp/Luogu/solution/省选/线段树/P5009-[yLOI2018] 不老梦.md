# [yLOI2018] 不老梦

## 题目背景

> 于万人中万幸得以相逢，刹那间澈净明通。  
> 成为我所向披靡的勇气和惶恐，裂山海，堕苍穹。

——银临《不老梦》。

本题原名《毒瘤分块题》。

## 题目描述

扶苏非常喜欢一边听古风歌一边写毒瘤分块题。所以这个题的题面恶意卡了分块。

给你一个序列，这个序列中的每个数字有三个参数 $v_i,a_i,b_i$。这个序列中的数有一个非常神奇的有关时间的性质：每过一个时刻，序列中第 $i$ 个数字的值 $v_i$ 会增加 $a_i \times b_i$。

现在扶苏会对你做出一些询问和对序列进行一些修改。每次操作形如：

- 查询第 $t$ 时刻区间 $[l,r]$ 的 $v$ 之和是多少。
- 在第 $t$ 时刻修改区间 $[l,r]$ 内的 $a$，将之整体加上一个整数 $x$。
- 在第 $t$ 时刻修改区间 $[l,r]$ 内的 $b$，将之整体加上一个整数 $y$。
- 在第 $t$ 时刻修改区间 $[l,r]$ 内的 $v$，将之整体加上一个整数 $z$。

规定初始时刻为时刻 $0$。

## 说明/提示

#### 【样例输入输出 1 解释】

![qwq](https://cdn.luogu.com.cn/upload/pic/38337.png)


---

#### 【数据规模与约定】

**本题共有 $17$ 个测试点，各测试点不等分。每个测试点的 $n$ 的规模如下表**。

| 测试点编号 |         $n=$          | 测试点编号 | $n=$|
| :--------: | :-------------------: | :--------: | :-------------------: |
|    $1$     |          $6$          |    $10$    |      $10^5 + 2$       |
|    $2$     |         $10$          |   $11$    | $1.5 \times 10^5 + 2$ |
|    $3$     |         $100$         |  $12$    |      $10^5 + 3$       |
|    $4$     |        $10^3$         |  $13$    | $1.5 \times 10^5 + 3$ |
|    $5$     |    $3 \times 10^3$    | $14$    |  $2 \times 10^5 + 4$  |
|    $6$     |    $3 \times 10^3$    |   $15$    |  $5 \times 10^4 + 5$  |
|    $7$     |      $10^4 + 1$       |   $16$    |      $10^5 + 5$       |
|    $8$     |      $10^5 + 1$       |  $17$    |  $2 \times 10^5 + 5$  |
|    $9$     | $1.5 \times 10^5 + 1$ |

**各测试点分值**：

- 对于第 $1$ 到第 $14$ 个测试点，每个测试点 $5$ 分。
- 对于第 $15$ 到第 $17$ 个测试点，每个测试点 $10$ 分。

**各测试点 $m$ 的取值**：

- 对于测试点 $1$，$m = 10$。
- 对于测试点 $2$，$m = 50$。
- 对于第 $3$ 到第 $17$ 个测试点，$m = n$。

**各测试点特殊性质**：

- 对于所有 $n$ 末位数字为 $6$ 的测试点，满足性质：操作所用到的时刻从 $1$ 开始，每次增加 $1$。
- 对于所有 $n$ 末位数字为 $1$ 的测试点，满足性质：所有修改操作只涉及对 $a$ 的修改，且修改区间 $x = y$。
- 对于所有 $n$ 末位数字为 $2$ 的测试点，满足性质：所有修改操作只涉及对 $a$ 的修改。
- 对于所有 $n$ 末位数字为 $3$ 的测试点，满足性质：所有修改操作不涉及对 $v$ 的修改，且对于 $b$ 的修改满足 $x= y$。
- 对于所有 $n$ 末位数字为 $4$ 的测试点，满足性质：不存在修改操作。


对于全部的测试点，保证 $1 \leq x \leq y \leq n$，$1 \leq op \leq 4$，给出的所有数字都在 32 位带符号整形的范围内，$t$ 为正数，且按照严格的升序给出。

---

#### 【提示】

- 请注意数据读入对程序效率造成的影响。
- 请注意常数因子对程序效率造成的影响。
- $n$ 的末位数字可以帮助你快速判断测试点的特殊性质。
- 当你的答案为负时，请将其取模成非负数后再进行输出。




## 样例 #1

### 输入

```
5 5
1 2 3
4 5 6
7 8 9
10 11 12
13 14 15
2 1 1 3 2 
1 3 2 3
3 4 1 4 -3
4 5 1 3 -5
1 6 1 5```

### 输出

```
377
2708```

# 题解

## 作者：DDOSvoid (赞：15)

好像没人 A 掉啊

~~果然毒瘤题，虽然不卡分块~~

~~另外写 solution 的人的语文烂的要死~~

updeta： 为什么这么多人直接交题解啊？

std 已经更改过，直接提交不能 AC 请自重（当然不影响阅读

## Solution

### 测试点 1

逐秒模拟即可

### 测试点 2 ~ 6

暴力模拟，每个位置多记时间这个标记，复杂度 $O(nm)$

### 测试点 7 ~ 9

~~其实第 7 个点，暴力也能过~~

假设一个点的值为 v，考虑单点修改 a，看下面这个图（忽略了 $\times b$

![1](https://cdn.luogu.com.cn/upload/pic/38335.png)

也就是说，如果在时间 $t$ 将 $a$ 增加 $v$，我们只需要 $sum-=v*b*t$ 即可，最终在时间 $t_1$ 查询时我们直接查询 $sum+a*b*t_1$，所以可用线段树维护区间和以及区间 $a*b$ 的和，修改就是单点修改，查询就是区间查询

### 测试点 10 ~ 11

观察 $a$ 的单点修改，修改的时候 $b$，$t$ 是常量，如果能维护 b 的区间和，那么是可以修改区间的，所以线段树 + 标记 即可

### 测试点 12 ~ 13

对 $b$ 仅有单点修改，所以上一种是一样的，再加一个对 b 的单点修改即可

### 测试点 14

仅有询问，所以直接线段树维护区间和以及区间 $a*b$ 的和即可                                                                                                                               

~~这个点好像没啥意义~~

### 测试点 15 ~ 17

仅仅是增加了 b 的区间修改，至此，我们的想法已经非常明确

即我们要维护 $\sum a$，$\sum v$，$\sum b$，$\sum a*b$，那么要维护这些值，我们需要一些标记

对于线段树处理多标记，有一个统一的规则，即对于线段树上的任意一个点，我们在递归到它的时候（即它的父亲的 tag 全部下放），它要维护的值一定是正确的。

所以接下来我们考虑的更新标记都是要传给子节点的标记

注意到 $\sum v$ 一定是形如 $\sum v - x*\sum a - y*\sum b+z$   这种形式，下面我们根据操作还确定标记

考虑区间改 a 的操作，我们需要一个 $adda$ 标记，表示 $\sum v$ 还要减多少倍的 $\sum b$，还有一个标记 $Adda$，表示 a 增加了多少，在改 a 的时候 ($a+=v$），$adda+=v*t$，$Adda+=v$，如果之前对这个点有过区间改 b 的话，最后我们只是拿 $adda*\sum b$，而 $\sum b$ 是未更新的 $\sum b$，所以还要记一个标记 $addv$ 表示 $\sum v$ 要加上多少常量，$addv-=Addb*v*t$

区间改 b 的操作类似

区间改 v ...

现在考虑具体的标记下传到值

 仅考虑左儿子的情况，形如 $adda'$ 为父亲的标记

$\sum v = \sum v-addb'*a-adda'*b+addv'*(m-l+1)$

$\sum ab=\sum ab+Adda'*Addb'*(m-l+1)+Adda'*\sum b+Addb'*\sum a$

$\sum a =\sum a + Adda'*(m-l+1)$

$\sum b=\sum b + Addb'*(m-l+1)$

注意更新顺序，下面考虑标记下传到标记

$addv=addv-addb'*Adda-adda'*Addb+addv'$

$adda=adda+adda'$

$addb=addb+addb'$

$Adda=Adda+Adda'$

$Addb=Addb+Addb'$

同样注意更新顺序

附上丑陋的 std

```cpp
#include<iostream>
#include<cstdio>
#include<cctype>
#define maxn 500010
#define ll long long
#define gc getchar
using namespace std;

int n, m, a[maxn], b[maxn], v[maxn];

const int p = 1000000007;

int read(){
	int x = 0, f = 0; char c = gc();
	while(!isdigit(c)){if(c == '-') f = 1; c = gc();}
	while(isdigit(c)){x = x * 10 + c - '0'; c = gc();}
	return f ? -x : x;
}

#define lc i << 1
#define rc i << 1 | 1
struct seg{	
	ll v, a, b, adda, addb, addv, mul, Adda, Addb, Addmul;
}T[maxn * 4]; 
inline void maintain(int i){
	T[i].v = (T[lc].v + T[rc].v) % p;
	T[i].mul = (T[lc].mul + T[rc].mul) % p;
	T[i].a = (T[lc].a + T[rc].a) % p;
	T[i].b = (T[lc].b + T[rc].b) % p;
}	

void build(int i, int l, int r){
	if(l == r){
		T[i].v = v[l]; T[i].a = a[l]; 
		T[i].b = b[l]; T[i].mul = 1ll * a[l] * b[l] % p; return ;
	} int m = l + r >> 1;
	build(lc, l, m); build(rc, m + 1, r);
	maintain(i);
}

void pushdown(int i, int l, int r){
	ll &adda = T[i].adda, &addb = T[i].addb, &addv = T[i].addv; int m = l + r >> 1;
	ll &Adda = T[i].Adda, &Addb = T[i].Addb, &Addmul = T[i].Addmul;
	
	T[lc].v = (T[lc].v - adda * T[lc].b - addb * T[lc].a + addv * (m - l + 1)) % p;
	T[rc].v = (T[rc].v - adda * T[rc].b - addb * T[rc].a + addv * (r - m)) % p;
	T[lc].mul = (T[lc].mul + Adda * Addb % p * (m - l + 1) % p + Adda * T[lc].b + Addb * T[lc].a) % p;
	T[rc].mul = (T[rc].mul + Adda * Addb % p * (r - m) % p  + Adda * T[rc].b + Addb * T[rc].a) % p;
	T[lc].a = (T[lc].a + Adda * (m - l + 1)) % p; T[rc].a = (T[rc].a + Adda * (r - m)) % p;
	T[lc].b = (T[lc].b + Addb * (m - l + 1)) % p; T[rc].b = (T[rc].b + Addb * (r - m)) % p;
	
	T[lc].addv = (T[lc].addv + addv - T[lc].Adda * addb - T[lc].Addb * adda) % p;
	T[rc].addv = (T[rc].addv + addv - T[rc].Adda * addb - T[rc].Addb * adda) % p;
	
	T[lc].adda = (T[lc].adda + adda) % p;
	T[rc].adda = (T[rc].adda + adda) % p;
	
	T[lc].addb = (T[lc].addb + addb) % p;
	T[rc].addb = (T[rc].addb + addb) % p;
	
	T[lc].Adda = (T[lc].Adda + Adda) % p;
	T[rc].Adda = (T[rc].Adda + Adda) % p;
	
	T[lc].Addb = (T[lc].Addb + Addb) % p;
	T[rc].Addb = (T[rc].Addb + Addb) % p;
	
	//T[lc].Addmul = (T[lc].Addmul + Addmul) % p;
	//T[rc].Addmul = (T[rc].Addmul + Addmul) % p;
	
	adda = addb = addv = Adda = Addb = Addmul = 0;
}	

void update_adda(int i, int l, int r, int L, int R, ll v, ll t){
	if(l > R || r < L) return ;
	if(L <= l && r <= R){
		T[i].v = (T[i].v - T[i].b * v % p * t) % p;
		T[i].a = (T[i].a + 1ll * v * (r - l + 1)) % p; T[i].mul = (T[i].mul + T[i].b * v) % p;
		T[i].adda = (T[i].adda + 1ll * v * t) % p; 
		T[i].addv = (T[i].addv - T[i].Addb * v % p * t) % p;
		T[i].Adda = (T[i].Adda + v) % p; //T[i].Addmul = (T[i].Addmul + v * T[i].Addb) % p;
		return ;
	} int m = l + r >> 1; pushdown(i, l, r);
	update_adda(lc, l, m, L, R, v, t); update_adda(rc, m + 1, r, L, R, v, t);
	maintain(i);
}

void update_addb(int i, int l, int r, int L, int R, ll v, ll t){
	if(l > R || r < L) return ;
	if(L <= l && r <= R){
		T[i].v = (T[i].v - T[i].a * v % p * t) % p;
		T[i].b = (T[i].b + 1ll * v * (r - l + 1)) % p; T[i].mul = (T[i].mul + T[i].a * v) % p;
		T[i].addb = (T[i].addb + 1ll * v * t) % p;
		T[i].addv = (T[i].addv - T[i].Adda * v % p * t) % p;
		T[i].Addb = (T[i].Addb + v) % p; //T[i].Addmul = (T[i].Addmul + v * T[i].Adda) % p;
		return ;
	} int m = l + r >> 1; pushdown(i, l, r);
	update_addb(lc, l, m, L, R, v, t); update_addb(rc, m + 1, r, L, R, v, t);
	maintain(i);
}

void update_addv(int i, int l, int r, int L, int R, int v){
	if(l > R || r < L) return ;
	if(L <= l && r <= R){
		T[i].v = (T[i].v + 1ll * v * (r - l + 1)) % p;
		T[i].addv = (T[i].addv + v) % p;
		return ;
	} int m = l + r >> 1; pushdown(i, l, r);
	update_addv(lc, l, m, L, R, v); update_addv(rc, m + 1, r, L, R, v);
	maintain(i);
}

ll query(int i, int l, int r, int L, int R, int t){
	if(l > R || r < L) return 0;
	if(L <= l && r <= R) return (T[i].v + T[i].mul * t) % p;
	int m = l + r >> 1; pushdown(i, l, r);
	return (query(lc, l, m, L, R, t) + query(rc, m + 1, r, L, R, t)) % p;
}

inline void solve_1(){
	int t = read(), x = read(), y = read();
	ll v = query(1, 1, n, x, y, t); v = (v % p + p) % p;
	printf("%lld\n", v);
}

inline void solve_2(){
	int t = read(), x = read(), y = read(), z = read();
	update_adda(1, 1, n, x, y, z, t);	
}

inline void solve_3(){
	int t = read(), x = read(), y = read(), z = read();
	update_addb(1, 1, n, x, y, z, t);	
}

inline void solve_4(){
	int t = read(), x = read(), y = read(), z = read();
	update_addv(1, 1, n, x, y, z);	
}

int main(){
	n = read(); m = read();
	for(int i = 1; i <= n; ++i) v[i] = read(), a[i] = read(), b[i] = read();
	build(1, 1, n);
	for(int i = 1; i <= m; ++i){
		int opt; opt = read();
		switch(opt){
			case 1 : solve_1(); 
			case 2 : solve_2(); 
			case 3 : solve_3(); 
			case 4 : solve_4(); 
		}
	}
	return 0;
}
```



---

## 作者：DPair (赞：6)

拿到这道题，我们不难根据三个修改操作推测我们要维护区间 $\sum a\times b, \sum a, \sum b, \sum v$ 这几个信息

其中后三个信息是显然要被维护的，而第一个信息则是配合 “时刻” 概念更新答案用的，每过一个时刻就区间加上这个值

然后三个区间修改我们显然要分别打 tag ，因此要维护 $atag, btag, vtag$ 表示区间加的量

然后我们先假装这几个信息已经够了，看看各个操作能不能实现：

首先是区间求和，这个显然只需要 $\sum v$

然后考虑区间加 $v$ 显然也可以完成

但是前 $2, 3$ 操作就不一样了，考虑我们用这两个操作修改了 $[l, r]$ 这个区间时，它的子区间信息也会改变，或者说它在下一次被搜索到之前，不同的时刻末尾 $\sum a\times b$ 的 **真实值** 可能不同，也就是说这东西是分段的

而我们现在的做法是每过一个时刻就暴力加上区间 **当前的** $\sum a \times b$，所以是不可取的

不过我们发现，如果我们可以容斥掉多余的贡献，那么就可以暴力直接加上区间当前的 $\sum a \times b$ 了

我们不妨模拟一下一次对 $a$ 的修改

假设区间 $a$ 在 $t$ 时刻加上 $x$，那么下一次 $t'$ 时刻查询该区间时，如果我们直接跑的是 $t'\sum (a+x) \times b$，那么我们会多算一个 $t\times x\times \sum b$，在 $\sum v$ 上把这东西减掉就行了，我们惊讶的发现我们的现有信息就可以容斥出正确的答案

但是如果再搜索这个区间的子区间就又会出现问题，因为子区间的 $\sum a\times b$ 也是分段的

不过也没有关系，我们发现我们容斥掉的是一个形如 $\sum t_i x_i$ 的东西，而这东西直接乘上一个 $\sum b$ 就是我们要的值

而仔细思考一下就能发现，前面这个东西是可以直接下传给儿子的！

因此我们再打两个 tag 来存每一个节点的未容斥掉的 $\sum t_i a_i, \sum t_i b_i$ 就行了

注意到不同标记之间可能也会有互动，简单处理一下即可

复杂度 $O(n\log n)$



```cpp
#include <assert.h>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <cmath>
#define debug(...) fprintf(stderr, __VA_ARGS__)
#define rep(i,s,t) for(int i=(s),i##END=(t);i<=i##END;++i)
#define per(i,t,s) for(int i=(t),i##END=(s);i>=i##END;--i)
#define REP(i,s,t) for(int i=(s),i##END=(t);i<i##END;++i)
#define PER(i,t,s) for(int i=(t),i##END=(s);i>i##END;--i)
#define elif else if
namespace MyMinMax{
template <typename T>
inline T mn(const T x, const T y) {return x < y ? x : y;}
template <typename T>
inline T mx(const T x, const T y) {return x > y ? x : y;}
template <typename T>
inline bool chmin(T &x, const T y) {return (x > y) && ((x = y), 1);}
template <typename T>
inline bool chmax(T &x, const T y) {return (x < y) && ((x = y), 1);}
template <typename T, typename ...Args>
inline T mx(const T x, const Args ...args) {return mx(x, mx(args...));}
template <typename T, typename ...Args>
inline T mn(const T x, const Args ...args) {return mn(x, mn(args...));}
}
using namespace MyMinMax;
// 省略了不重要的快读
typedef long long LL;
const int INF = 0x3f3f3f3f;
const LL INFll = 0x3f3f3f3f3f3f3f3fll;
/* My Code begins here */
const int MOD = 1e8 + 7;
inline void Sub(int &x, const int y) {((x -= y) < 0) && (x += MOD);}
inline void Add(int &x, const int y) {((x += y) >= MOD) && (x -= MOD);}
inline int SUB(int x, const int y) {((x -= y) < 0) && (x += MOD); return x;}
inline int ADD(int x, const int y) {((x += y) >= MOD) && (x -= MOD); return x;}

const int MAXN = 2e5 + 15;
int n, m;
struct NODE {
    int s, ss, sa, sb, ta, tb, ts, at, bt;
    NODE (int s = 0, int ss = 0, int sa = 0, int sb = 0, int ta = 0, int tb = 0, int ts = 0, int at = 0, int bt = 0) : s(s), ss(ss), sa(sa), sb(sb), ta(ta), tb(tb), ts(ts), at(at), bt(bt){}
}t[MAXN << 2];
inline void pushup(int rt) {
    t[rt].s = ADD(t[rt << 1].s, t[rt << 1 | 1].s);
    t[rt].ss = ADD(t[rt << 1].ss, t[rt << 1 | 1].ss);
    t[rt].sa = ADD(t[rt << 1].sa, t[rt << 1 | 1].sa);
    t[rt].sb = ADD(t[rt << 1].sb, t[rt << 1 | 1].sb);
}
inline void ua(int rt, int l, int r, int z) { Add(t[rt].ss, 1ll * t[rt].sb * z % MOD); Add(t[rt].sa, 1ll * (r - l + 1) * z % MOD); Add(t[rt].ta, z); }
inline void ub(int rt, int l, int r, int z) { Add(t[rt].ss, 1ll * t[rt].sa * z % MOD); Add(t[rt].sb, 1ll * (r - l + 1) * z % MOD); Add(t[rt].tb, z); }
inline void ua(int rt, int l, int r, int z, int p) { Add(t[rt].ss, 1ll * t[rt].sb * z % MOD); Add(t[rt].sa, 1ll * (r - l + 1) * z % MOD); Add(t[rt].ta, z); Sub(t[rt].s, 1ll * t[rt].sb * p % MOD); Add(t[rt].at, p); Sub(t[rt].ts, 1ll * t[rt].tb * p % MOD); }
inline void ub(int rt, int l, int r, int z, int p) { Add(t[rt].ss, 1ll * t[rt].sa * z % MOD); Add(t[rt].sb, 1ll * (r - l + 1) * z % MOD); Add(t[rt].tb, z); Sub(t[rt].s, 1ll * t[rt].sa * p % MOD); Add(t[rt].bt, p); Sub(t[rt].ts, 1ll * t[rt].ta * p % MOD); }
inline void us(int rt, int l, int r, int z) { Add(t[rt].s, 1ll * (r - l + 1) * z % MOD); Add(t[rt].ts, z); }
inline void au(int rt, int z) { Sub(t[rt].s, 1ll * z * t[rt].sb % MOD); Add(t[rt].at, z); Sub(t[rt].ts, 1ll * t[rt].tb * z % MOD); }
inline void bu(int rt, int z) { Sub(t[rt].s, 1ll * z * t[rt].sa % MOD); Add(t[rt].bt, z); Sub(t[rt].ts, 1ll * t[rt].ta * z % MOD); }
#define LSON rt << 1, l, mid
#define RSON rt << 1 | 1, mid + 1, r
inline void pushdown(int rt, int l, int r) {
    const int mid = (l + r) >> 1;
    if(t[rt].at) au(rt << 1, t[rt].at), au(rt << 1 | 1, t[rt].at), t[rt].at = 0;
    if(t[rt].bt) bu(rt << 1, t[rt].bt), bu(rt << 1 | 1, t[rt].bt), t[rt].bt = 0;
    if(t[rt].ts) us(LSON, t[rt].ts), us(RSON, t[rt].ts), t[rt].ts = 0;
    if(t[rt].ta) ua(LSON, t[rt].ta), ua(RSON, t[rt].ta), t[rt].ta = 0;
    if(t[rt].tb) ub(LSON, t[rt].tb), ub(RSON, t[rt].tb), t[rt].tb = 0;
}
int a[MAXN], b[MAXN], v[MAXN];
void build(int rt, int l, int r) {
    if(l == r) {t[rt].s = v[l]; t[rt].sa = a[l]; t[rt].sb = b[l]; t[rt].ss = 1ll * a[l] * b[l] % MOD; return ; }
    const int mid = (l + r) >> 1; build(LSON); build(RSON); pushup(rt);
}
void ma(int rt, int l, int r, int x, int y, int z, int p) {
    if(x <= l && r <= y) return ua(rt, l, r, z, p);
    pushdown(rt, l, r); int mid = (l + r) >> 1;
    if(x <= mid) ma(LSON, x, y, z, p);
    if(y > mid) ma(RSON, x, y, z, p);
    return pushup(rt);
}
void mb(int rt, int l, int r, int x, int y, int z, int p) {
    if(x <= l && r <= y) return ub(rt, l, r, z, p);
    pushdown(rt, l, r); int mid = (l + r) >> 1;
    if(x <= mid) mb(LSON, x, y, z, p);
    if(y > mid) mb(RSON, x, y, z, p);
    return pushup(rt);
}
void ms(int rt, int l, int r, int x, int y, int z) {
    if(x <= l && r <= y) return us(rt, l, r, z);
    pushdown(rt, l, r); int mid = (l + r) >> 1;
    if(x <= mid) ms(LSON, x, y, z);
    if(y > mid) ms(RSON, x, y, z);
    return pushup(rt);
}
int query(int rt, int l, int r, int x, int y, int p) {
    if(x <= l && r <= y) return ADD(t[rt].s, 1ll * t[rt].ss * p % MOD);
    pushdown(rt, l, r); int mid = (l + r) >> 1;
    if(x > mid) return query(RSON, x, y, p);
    if(y <= mid) return query(LSON, x, y, p);
    return ADD(query(LSON, x, y, p), query(RSON, x, y, p));
}
inline void fix(int &x) {(((x %= MOD) += MOD) >= MOD) && (x -= MOD);}
signed main(){
    read(n, m); rep(i, 1, n) {
        read(v[i], a[i], b[i]);
        fix(v[i]); fix(a[i]); fix(b[i]);
    }
    build(1, 1, n);
	while(m --) { int t, opt, l, r; read(opt, t, l, r); fix(t);
        if(opt == 1) print(query(1, 1, n, l, r, t));
        else {
			int x; read(x); fix(x); t = 1ll * t * x % MOD;
            if(opt == 2) ma(1, 1, n, l, r, x, t);
            elif(opt == 3) mb(1, 1, n, l, r, x, t);
            else ms(1, 1, n, l, r, x);
		} 
	}

}
```



---

## 作者：JiaY19 (赞：2)

这个小丑看了好久题目才发现保证 $t$ 不降。

好像与其他题解做法稍有不同。

### 思路

其他题解的标记做法非常复杂，怎么办。

我们可以使用适用性可加强大的矩阵乘法。

我们考虑维护：

$$
\begin{bmatrix}
\sum v&\sum a\times b&\sum a&\sum b&len\\
\end{bmatrix}
$$

分别表示 $v$ 的和， $a\times b$ 的和， $a$ 的和， $b$ 的和，与区间长度。

分操作考虑。

#### 时间往后移

也就是所有的 $v$ 需要加上若干倍的 $a\times b$。

那么在矩阵上也就是乘上：

$$
\begin{bmatrix}
1&0&0&0&0\\
t-last&1&0&0&0\\
0&0&1&0&0\\
0&0&0&1&0\\
0&0&0&0&1\\
\end{bmatrix}
$$

其中 $t$ 表示此时的时间，$last$ 表示上一个时间。

#### 区间加 $v$

在矩阵上为：

$$
\begin{bmatrix}
1&0&0&0&0\\
0&1&0&0&0\\
0&0&1&0&0\\
0&0&0&1&0\\
z&0&0&0&1\\
\end{bmatrix}
$$

#### 区间加 $a$

在矩阵上为：

$$
\begin{bmatrix}
1&0&0&0&0\\
0&1&0&0&0\\
0&0&1&0&0\\
0&z&0&1&0\\
0&0&z&0&1\\
\end{bmatrix}
$$

#### 区间加 $b$

在矩阵上为：

$$
\begin{bmatrix}
1&0&0&0&0\\
0&1&0&0&0\\
0&z&1&0&0\\
0&0&0&1&0\\
0&0&0&z&1\\
\end{bmatrix}
$$

应当都是比较容易理解的。

从这里就可以看出矩阵乘法的好处了，更加容易思考与实现。

然后直接使用线段树维护即可。

时间复杂度：$O(5^3n\log n)$

### Code

有一些细节。

如果直接这么写的话会只有 $\text{60pts}$。

会有一些点 $\text{TLE}$。

合理减少取模后。

可以得到 $\text{90pts}$。

将矩阵循环展开，减少一直为 $0$ 的位置。

就可以过了。

当然，如果你经常写数据结构维护矩阵，这些都是基本的（都是因为一般朴素的会被卡。

代码比较冗长，但很好写（最长的是复制粘贴的循环展开）。

```cpp
#include <bits/stdc++.h>
using namespace std;

#define x first
#define y second
#define mp(x, y) make_pair(x, y)
#define fro(i, x, y) for(int i = (x);i <= (y);i++)
#define pre(i, x, y) for(int i = (x);i >= (y);i--)
#define dbg cerr << "Line " << __LINE__ << ": "
#define EVAL(x) #x " = " << (x)

typedef int64_t i64;
typedef uint32_t u32;
typedef uint64_t u64;
typedef __int128_t i128;
typedef __uint128_t u128;
typedef pair<int, int> PII;

bool ed;

const int N = 200010;
const int mod = 1e8 + 7;

int n, m, vis[N<<1];

inline void add(i64 &x, int y)
	{ x = (x + y) + (x + y >= mod ? -mod : 0); }
struct Mat
{
	i64 a[5][5]{};
	inline void init() { a[0][0] = a[1][1] = a[2][2] = a[3][3] = a[4][4] = 1; }
	inline void init(i64 v_, i64 ab_, i64 a_, i64 b_)
		{ a[0][0] = v_, a[0][1] = ab_, a[0][2] = a_, a[0][3] = b_, a[0][4] = 1; }
	inline void clear() { memset(a, 0, sizeof a); }
	inline Mat operator*(const Mat &tmp) const
	{
		Mat c;
		c.a[0][0] = (a[0][0] * tmp.a[0][0] + a[0][1] * tmp.a[1][0] + a[0][2] * tmp.a[2][0] + a[0][3] * tmp.a[3][0] + a[0][4] * tmp.a[4][0]) % mod;
        c.a[0][1] = (a[0][0] * tmp.a[0][1] + a[0][1] * tmp.a[1][1] + a[0][2] * tmp.a[2][1] + a[0][3] * tmp.a[3][1] + a[0][4] * tmp.a[4][1]) % mod;
        c.a[0][2] = (a[0][0] * tmp.a[0][2] + a[0][1] * tmp.a[1][2] + a[0][2] * tmp.a[2][2] + a[0][3] * tmp.a[3][2] + a[0][4] * tmp.a[4][2]) % mod;
        c.a[0][3] = (a[0][0] * tmp.a[0][3] + a[0][1] * tmp.a[1][3] + a[0][2] * tmp.a[2][3] + a[0][3] * tmp.a[3][3] + a[0][4] * tmp.a[4][3]) % mod;
        c.a[0][4] = (a[0][0] * tmp.a[0][4] + a[0][1] * tmp.a[1][4] + a[0][2] * tmp.a[2][4] + a[0][3] * tmp.a[3][4] + a[0][4] * tmp.a[4][4]) % mod;
        c.a[1][0] = (a[1][0] * tmp.a[0][0] + a[1][1] * tmp.a[1][0] + a[1][2] * tmp.a[2][0] + a[1][3] * tmp.a[3][0] + a[1][4] * tmp.a[4][0]) % mod;
        c.a[1][1] = (a[1][0] * tmp.a[0][1] + a[1][1] * tmp.a[1][1] + a[1][2] * tmp.a[2][1] + a[1][3] * tmp.a[3][1] + a[1][4] * tmp.a[4][1]) % mod;
        c.a[2][0] = (a[2][0] * tmp.a[0][0] + a[2][1] * tmp.a[1][0] + a[2][2] * tmp.a[2][0] + a[2][3] * tmp.a[3][0] + a[2][4] * tmp.a[4][0]) % mod;
        c.a[2][1] = (a[2][0] * tmp.a[0][1] + a[2][1] * tmp.a[1][1] + a[2][2] * tmp.a[2][1] + a[2][3] * tmp.a[3][1] + a[2][4] * tmp.a[4][1]) % mod;
        c.a[2][2] = (a[2][0] * tmp.a[0][2] + a[2][1] * tmp.a[1][2] + a[2][2] * tmp.a[2][2] + a[2][3] * tmp.a[3][2] + a[2][4] * tmp.a[4][2]) % mod;
        c.a[3][0] = (a[3][0] * tmp.a[0][0] + a[3][1] * tmp.a[1][0] + a[3][2] * tmp.a[2][0] + a[3][3] * tmp.a[3][0] + a[3][4] * tmp.a[4][0]) % mod;
        c.a[3][1] = (a[3][0] * tmp.a[0][1] + a[3][1] * tmp.a[1][1] + a[3][2] * tmp.a[2][1] + a[3][3] * tmp.a[3][1] + a[3][4] * tmp.a[4][1]) % mod;
        c.a[3][3] = (a[3][0] * tmp.a[0][3] + a[3][1] * tmp.a[1][3] + a[3][2] * tmp.a[2][3] + a[3][3] * tmp.a[3][3] + a[3][4] * tmp.a[4][3]) % mod;
        c.a[4][0] = (a[4][0] * tmp.a[0][0] + a[4][1] * tmp.a[1][0] + a[4][2] * tmp.a[2][0] + a[4][3] * tmp.a[3][0] + a[4][4] * tmp.a[4][0]) % mod;
        c.a[4][1] = (a[4][0] * tmp.a[0][1] + a[4][1] * tmp.a[1][1] + a[4][2] * tmp.a[2][1] + a[4][3] * tmp.a[3][1] + a[4][4] * tmp.a[4][1]) % mod;
        c.a[4][2] = (a[4][0] * tmp.a[0][2] + a[4][1] * tmp.a[1][2] + a[4][2] * tmp.a[2][2] + a[4][3] * tmp.a[3][2] + a[4][4] * tmp.a[4][2]) % mod;
        c.a[4][3] = (a[4][0] * tmp.a[0][3] + a[4][1] * tmp.a[1][3] + a[4][2] * tmp.a[2][3] + a[4][3] * tmp.a[3][3] + a[4][4] * tmp.a[4][3]) % mod;
        c.a[4][4] = (a[4][0] * tmp.a[0][4] + a[4][1] * tmp.a[1][4] + a[4][2] * tmp.a[2][4] + a[4][3] * tmp.a[3][4] + a[4][4] * tmp.a[4][4]) % mod;
		return c;
	}
	inline Mat operator+(const Mat &tmp) const
		{ Mat c; fro(i, 0, 4) c.a[0][i] = (a[0][i] + tmp.a[0][i]) - (a[0][i] + tmp.a[0][i] >= mod ? mod : 0); return c; }
} t[N<<1], tg[N<<1], mat[5];

#define ls (mid<<1)
#define rs (mid<<1|1)
inline void mo(i64 &x)
	{ x = (x % mod + mod) % mod; }
inline void mat1(int t) { mat[1].a[1][0] = t; }
inline void mat2(int t) { mat[2].a[3][1] = mat[2].a[4][2] = t; }
inline void mat3(int t) { mat[3].a[2][1] = mat[3].a[4][3] = t; }
inline void mat4(int t) { mat[4].a[4][0] = t; }
inline void push(int p, const Mat &k)
	{ t[p] = t[p] * k, tg[p] = tg[p] * k, vis[p] = 1; }
inline void pdo(int p, int mid)
{
	if(vis[p])
	{
		push(ls, tg[p]), push(rs, tg[p]);
		tg[p].clear(), tg[p].init(), vis[p] = 0;
	}
}
inline void update(int p, int l, int r, int L, int R, int op)
{
	if(L <= l && r <= R) return push(p, mat[op]);
	int mid = (l + r) >> 1; pdo(p, mid);
	if(mid >= L) update(ls, l, mid, L, R, op);
	if(mid <  R) update(rs, mid + 1, r, L, R, op);
	t[p] = t[ls] + t[rs];
}
inline int ask(int p, int l, int r, int L, int R)
{
	if(L <= l && r <= R) return t[p].a[0][0];
	int mid = (l + r) >> 1; pdo(p, mid); i64 sum{};
	if(mid >= L) add(sum, ask(ls, l, mid, L, R));
	if(mid <  R) add(sum, ask(rs, mid + 1, r, L, R));
	return sum;
}
inline void build(int p, int l, int r)
{
	tg[p].init();
	if(l == r)
	{
		i64 v, a, b;
		cin >> v >> a >> b;
		mo(v), mo(a), mo(b);
		t[p].init(v, a * b % mod, a, b);
		return;
	}
	int mid = (l + r) >> 1;
	build(ls, l, mid);
	build(rs, mid + 1, r);
	t[p] = t[ls] + t[rs];
}
inline void solve()
{
	cin >> n >> m;
	build(1, 1, n); i64 last = 0;
	mat[1].init(), mat[2].init();
	mat[3].init(), mat[4].init();
	fro(i, 1, m)
	{
		i64 op, t_, x, y, z;
		cin >> op >> t_ >> x >> y;
		if(t_ != last) mat1(t_ - last), push(1, mat[1]), last = t_;
		if(op != 1) cin >> z, mo(z);
		if(op == 1) cout << ask(1, 1, n, x, y) << "\n";
		if(op == 2) mat2(z), update(1, 1, n, x, y, 2);
		if(op == 3) mat3(z), update(1, 1, n, x, y, 3);
		if(op == 4) mat4(z), update(1, 1, n, x, y, 4);
	}
}

bool st;

signed main()
{
	ios::sync_with_stdio(0), cin.tie(0);
	double Mib = fabs((&ed-&st)/1048576.), Lim = 500;
	cerr << " Memory: " << Mib << "\n", assert(Mib<=Lim);
	solve();
	return 0;
}
```

---

## 作者：_qingshu_ (赞：2)

~~我真的是贤搓这道题搓了半天。~~

先感谢一下 DDOSvoid 的题解对我的帮助。

# 题意：

给定一个长度为 $N$ 的数列，数列中的第 $i$ 个数存在存在三个参数 $v_i,a_i,b_i$，在每一个时刻每一个数的 $v_i$ 会增加上 $a_i\times b_i$。

你需要支持四种操作：

- 查询在第 $t$ 时刻的 $\sum\limits_{i=l}^rv_i$。

- 在第 $t$ 时刻将 $\forall_i\in [l,r],a_i=a_i+z$。

- 在第 $t$ 时刻将 $\forall_i\in [l,r],b_i=b_i+z$。

- 在第 $t$ 时刻将 $\forall_i\in [l,r],v_i=v_i+z$。

你需要输出每一个操作一的答案。

# 思路：

假设没有修改操作，那么我们操作一的答案只需要统计一个 $\sum v$ 就好了，可以用线段数简单实现。

考虑每一个修改：

- 操作二 与 操作三：

	因为每一时刻 $v_i$ 会加上当前时刻的 $a_i\times b_i$，但是我们的 $a_i$ 与 $b_i$ 都会在途中进行修改，所以这个答案的统计是分段的，并且会随着时间的增长而不定增长，如果尝试暴力跑每一个段统计答案，时间是一定不允许通过的。
    
	可以考虑如何把 $a_i$ 或者 $b_i$ 的增长换一个形式，看到题目数据保证 $t$ 是单调递增的，说明我们可以不用去维护修改之前的答案。考虑用对于叶子节点的 $a_i$ 的一次增长举例，设当前时间为 $t'$，修改时间为 $t$： 
    $$ans=v_i+(a_i+z)\times b_i\times(t'-t+1)+a_i\times b_i\times (t-1)$$
	这个式子我们可以考虑将其变形为：
    $$ans=v_i+(a_i+z)\times b_i\times t'-z\times b_i \times (t-1)$$
    
    我们可以神奇的发现后面的 $z\times b_i \times (t-1)$ 是一个可以在修改当时算出来的定值，且对于 $b_i$ 的每次修改同理，我们可以将每一次对于 $a_i$的修改视为直接修改再将 $v_i=v_i-z\times b_i \times t$、将 $b_i$ 的修改视为直接修改再将 $v_i=v_i-z\times a_i\times t$。
    
    当然，这是对于叶子节点的修改，如果是整段的话我们需要知道 $\sum a$ 和 $\sum b$。
    
    对于懒标记的下放，我们可以考虑记录一下增加量与儿子节点需要减去的总值。
    
- 操作四：

	因为是直接修改 $\forall_i\in[l,r],v_i$  的值，所以正常线段数维护直接加减就好了。
    
- 操作一：

	如上操作二与操作三所述，我们需要查询 $\sum\limits_{i=l}^r a_i\times b_i+ \sum\limits_{i=l}^rv_i$，方便统计，我们可以再维护一个 $\sum\limits a\times b$，这是好实现的。
    
记得取模哦。

# Code：

```cpp
#include<bits/stdc++.h>
#define mod 100000007
#define mid(lef,rig) (lef+rig>>1)
using namespace std;
long long v[200010],a[200010],b[200010];
int n,q,op;
long long t,x,y,z;
struct edge{
    int lef,rig;
    long long suma,sumb,sumv,sumab;//sum
    long long lz1a,lz1b,lz1v;//记录下放值
    long long lz2a,lz2b;//记录增加量
}tr[1000010];
inline void update(int id){
    tr[id].suma=(tr[id<<1].suma+tr[id<<1|1].suma)%mod;
    tr[id].sumb=(tr[id<<1].sumb+tr[id<<1|1].sumb)%mod;
    tr[id].sumv=(tr[id<<1].sumv+tr[id<<1|1].sumv)%mod;
    tr[id].sumab=(tr[id<<1].sumab+tr[id<<1|1].sumab)%mod;
}
inline void build(int id,int lef,int rig){
    tr[id].lef=lef;
    tr[id].rig=rig;
    if(lef==rig){
        tr[id].suma=a[lef];
        tr[id].sumb=b[lef];
        tr[id].sumv=v[lef];
        tr[id].sumab=1ll*a[lef]*b[lef]%mod;
        return;
    }
    build(id<<1,lef,mid(lef,rig));
    build(id<<1|1,mid(lef,rig)+1,rig);
    update(id);
}
#define ls(rt) (rt<<1)
#define rs(rt) (rt<<1|1)
inline void pushdown(int id){
    tr[ls(id)].sumv=(tr[ls(id)].sumv-tr[id].lz1a*tr[ls(id)].sumb-tr[id].lz1b*tr[ls(id)].suma+tr[id].lz1v*(mid(tr[id].lef,tr[id].rig)-tr[id].lef+1))%mod;
    tr[rs(id)].sumv=(tr[rs(id)].sumv-tr[id].lz1a*tr[rs(id)].sumb-tr[id].lz1b*tr[rs(id)].suma+tr[id].lz1v*(tr[id].rig-mid(tr[id].lef,tr[id].rig)))%mod;
    
    tr[ls(id)].sumab=(tr[ls(id)].sumab+tr[id].lz2a*tr[id].lz2b%mod*(mid(tr[id].lef,tr[id].rig)-tr[id].lef+1)%mod+tr[id].lz2a*tr[ls(id)].sumb+tr[id].lz2b*tr[ls(id)].suma)%mod;
    tr[rs(id)].sumab=(tr[rs(id)].sumab+tr[id].lz2a*tr[id].lz2b%mod*(tr[id].rig-mid(tr[id].lef,tr[id].rig))%mod+tr[id].lz2a*tr[rs(id)].sumb+tr[id].lz2b*tr[rs(id)].suma)%mod;
    
    tr[ls(id)].suma=(tr[ls(id)].suma+tr[id].lz2a*(mid(tr[id].lef,tr[id].rig)-tr[id].lef+1))%mod;
    tr[rs(id)].suma=(tr[rs(id)].suma+tr[id].lz2a*(tr[id].rig-mid(tr[id].lef,tr[id].rig)))%mod;
    
    tr[ls(id)].sumb=(tr[ls(id)].sumb+tr[id].lz2b*(mid(tr[id].lef,tr[id].rig)-tr[id].lef+1))%mod;
    tr[rs(id)].sumb=(tr[rs(id)].sumb+tr[id].lz2b*(tr[id].rig-mid(tr[id].lef,tr[id].rig)))%mod;
    
    tr[ls(id)].lz1v=(tr[ls(id)].lz1v+tr[id].lz1v-tr[ls(id)].lz2a*tr[id].lz1b-tr[ls(id)].lz2b*tr[id].lz1a)%mod;
    tr[rs(id)].lz1v=(tr[rs(id)].lz1v+tr[id].lz1v-tr[rs(id)].lz2a*tr[id].lz1b-tr[rs(id)].lz2b*tr[id].lz1a)%mod;

    tr[ls(id)].lz1a=(tr[ls(id)].lz1a+tr[id].lz1a)%mod;
    tr[rs(id)].lz1a=(tr[rs(id)].lz1a+tr[id].lz1a)%mod;
    
    tr[ls(id)].lz1b=(tr[ls(id)].lz1b+tr[id].lz1b)%mod;
    tr[rs(id)].lz1b=(tr[rs(id)].lz1b+tr[id].lz1b)%mod;
    
    tr[ls(id)].lz2a=(tr[ls(id)].lz2a+tr[id].lz2a)%mod;
    tr[rs(id)].lz2a=(tr[rs(id)].lz2a+tr[id].lz2a)%mod;
    
    tr[ls(id)].lz2b=(tr[ls(id)].lz2b+tr[id].lz2b)%mod;
    tr[rs(id)].lz2b=(tr[rs(id)].lz2b+tr[id].lz2b)%mod;
    
    tr[id].lz1a=tr[id].lz1b=tr[id].lz1v=tr[id].lz2a=tr[id].lz2b=0;
}
#undef ls
#undef rs
inline void fixa(int id,long long fixnum,long long time){
    tr[id].sumv=(tr[id].sumv-1ll*tr[id].sumb*fixnum%mod*time%mod)%mod;
    tr[id].suma=(tr[id].suma+1ll*fixnum*(tr[id].rig-tr[id].lef+1))%mod;
    tr[id].sumab=(tr[id].sumab+1ll*tr[id].sumb*fixnum)%mod;
    tr[id].lz1a=(tr[id].lz1a+1ll*fixnum*time)%mod;
    tr[id].lz1v=(tr[id].lz1v-1ll*tr[id].lz2b*fixnum%mod*time)%mod;
    tr[id].lz2a=(tr[id].lz2a+fixnum)%mod;
}
inline void fixb(int id,long long fixnum,long long time){
	tr[id].sumv=(tr[id].sumv-1ll*tr[id].suma*fixnum%mod*time%mod)%mod;
	tr[id].sumb=(tr[id].sumb+1ll*fixnum*(tr[id].rig-tr[id].lef+1))%mod;
	tr[id].sumab=(tr[id].sumab+1ll*tr[id].suma*fixnum)%mod;
	tr[id].lz1b=(tr[id].lz1b+1ll*fixnum*time)%mod;
	tr[id].lz1v=(tr[id].lz1v-1ll*tr[id].lz2a*fixnum%mod*time)%mod;
	tr[id].lz2b=(tr[id].lz2b+fixnum)%mod;
}
inline void fixv(int id,long long fixnum){
	tr[id].sumv=(tr[id].sumv+1ll*fixnum*(tr[id].rig-tr[id].lef+1))%mod;
	tr[id].lz1v=(tr[id].lz1v+fixnum)%mod;
}
inline void modifya(int id,int lef,int rig,long long fixnum,long long time){
    if(tr[id].lef>rig||tr[id].rig<lef)return;
    if(tr[id].lef>=lef&&tr[id].rig<=rig){
        fixa(id,fixnum,time);
        return;
    }
    pushdown(id);
    modifya(id<<1,lef,rig,fixnum,time);
    modifya(id<<1|1,lef,rig,fixnum,time);
    update(id);
}
inline void modifyb(int id,int lef,int rig,long long fixnum,long long time){
    if(tr[id].lef>rig||tr[id].rig<lef)return;
    if(tr[id].lef>=lef&&tr[id].rig<=rig){
    	fixb(id,fixnum,time);
    	return;
    }
    pushdown(id);
    modifyb(id<<1,lef,rig,fixnum,time);
    modifyb(id<<1|1,lef,rig,fixnum,time);
    update(id);
}
inline void modifyv(int id,int lef,int rig,long long fixnum){
    if(tr[id].lef>rig||tr[id].rig<lef)return;
    if(tr[id].lef>=lef&&tr[id].rig<=rig){
    	fixv(id,fixnum);
    	return;
    }
    pushdown(id);
    modifyv(id<<1,lef,rig,fixnum);
    modifyv(id<<1|1,lef,rig,fixnum);
    update(id);
}
inline long long query(int id,int lef,int rig,long long time){
	if(tr[id].lef>rig||tr[id].rig<lef)return 0;
	if(tr[id].lef>=lef&&tr[id].rig<=rig)return (tr[id].sumv+tr[id].sumab*time%mod)%mod;
	pushdown(id);
	return (query(id<<1,lef,rig,time)+query(id<<1|1,lef,rig,time))%mod;
}
int main(){
    cin>>n>>q;
    for(int i=1;i<=n;i++){
    	cin>>v[i]>>a[i]>>b[i];
    }
    build(1,1,n);
    while(q--){
        cin>>op;
        if(op==1){
            cin>>t>>x>>y;
            cout<<(query(1,x,y,t)%mod+mod)%mod<<endl;
        }
        else if(op==2){
            cin>>t>>x>>y>>z;
            z=(z%mod+mod)%mod;
            modifya(1,x,y,z,t);
        }
        else if(op==3){
            cin>>t>>x>>y>>z;
            z=(z%mod+mod)%mod;
            modifyb(1,x,y,z,t);
        }
        else if(op==4){
            cin>>t>>x>>y>>z;
            z=(z%mod+mod)%mod;
            modifyv(1,x,y,z);
        }
    }
}
```

---


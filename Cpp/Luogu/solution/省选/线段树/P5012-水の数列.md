# 水の数列

## 题目背景

${\rm CYJian}$想到了一个很好玩的游戏呢...

## 题目描述

${\rm CYJian}$现在给你一个长度为$N$的数列，你可以选择一个数$x$，然后获得一个得分，得分越大越好。

得分是这样计算的:

首先把小于等于$x$的数标记，然后你的得分就是每一个连续标记的区间的长度的平方和。

${\rm CYJian}$觉得这样太简单了，~~答案显然就是最大值嘛~~所以他就把得分改成了原来的得分除以你选择的数。

${\rm CYJian}$还是觉得这样太简单了，所以他需要你选择的数得到的区间的个数在$l$~$r$的范围内。

${\rm CYJian}$还是觉得这样太简单了，所以他加上了$T$组询问。

${\rm CYJian}$还是觉得这样太简单了，所以他决定强制在线。

## 说明/提示

${\rm Subtask\ 1(30\ pts)}:\qquad 1 \leq N,T \leq 10^2$

${\rm Subtask\ 2(30\ pts)}:\qquad 1 \leq N,T \leq 10^3$

${\rm Subtask\ 3(40\ pts)}:\qquad 1 \leq N \leq 10^6 \qquad 1 \leq T \leq 10^3$

$1 \leq Num_i \leq 10^6$

其余输入的数字均在${\rm int}$范围内。

## 样例 #1

### 输入

```
5 3
3 5 1 2 4
233 666 1 3
555 999 2 3
123 987 233 888```

### 输出

```
25 5
1 3 0
10 4
2 3 0
-1 -1
3 3 0
```

# 题解

## 作者：vectorwyx (赞：21)

题目不带修，故 $x$ 的取值只有 $O(n)$ 种。考虑预处理出所有 $x$ 对应的答案。从小到大枚举 $x$，使用并查集维护连续段的数量，长度，以及长度的平方和。这样会得到 $O(n)$ 个三元组 $(cnt,y,x)$ 表示所选数为 $x$ 时有 $cnt$ 个连续段，其长度的平方和为 $y$，对应的答案为 $\frac{y}{x}$。把所有 $cnt$ 相同的三元组放在一起按答案取 max，问题转为 rmq。

使用普通的 st 表或线段树容易被卡空间。这里采用分块+ st 表的方式，每 log 个点分为一块，整块之间用 st 表维护，零散点暴力。时间复杂度为 $O(n\log n)$，空间复杂度为 $O(n)$。

代码如下（点个赞再走吧QAQ，万分感谢！）：

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
#include<vector>
#include<queue>
#include<map>
#define pb push_back
#define sml(x,y) (x=min(x,y))
#define big(x,y) (x=max(x,y))
#define ll long long
#define db double
#define fo(i,x,y) for(register int i=x;i<=y;++i)
#define go(i,x,y) for(register int i=x;i>=y;--i)
using namespace std;
inline int read(){int x=0,fh=1; char ch=getchar(); while(!isdigit(ch)){if(ch=='-') fh=-1; ch=getchar();} while(isdigit(ch)){x=(x<<1)+(x<<3)+ch-'0'; ch=getchar();} return x*fh;}
inline void out(int *a,int n){fo(i,1,n) printf("%d ",*(a+i));puts("");}

const int N=1e6+5;
int a[N],od[N],n,siz[N],fa[N],cnt,vis[N],T,lg,tot,bel[N];
ll ans,lst;
struct frac{
	ll fz;
	int fm;
	frac(){fz=0,fm=1;}
	frac(ll x,int y){fz=x,fm=y;} 
	bool operator<(const frac&x)const{return fz*x.fm<fm*x.fz;} 
}A[N],st[N/19+5][20],Ans;

int fin(int x){return fa[x]==x?x:fa[x]=fin(fa[x]);} 
bool cmp(int x,int y){return a[x]<a[y];} 
inline void merge(int x,int y){
	int fx=fin(x),fy=fin(y);
	if(fx==fy) return;
	if(siz[fx]<siz[fy]) fa[fx]=fy,siz[fy]+=siz[fx];
	else fa[fy]=fx,siz[fx]+=siz[fy];
}

void rmq(){
	fo(i,1,n) bel[i]=(i-1)/lg+1,big(st[bel[i]][0],A[i]);
	fo(i,1,lg)
		fo(j,1,tot) st[j][i]=max(st[j][i-1],st[min(j+(1<<i-1),tot)][i-1]);
}

inline frac query(int l,int r){
	int x=log2(r-l+1); 
	return max(st[l][x],st[r-(1<<x)+1][x]);
}

int main(){
	cin>>n>>T;lg=log2(n);tot=(n-1)/lg;
	fo(i,1,n) a[i]=read(),od[i]=i,fa[i]=i,siz[i]=1;
	sort(od+1,od+1+n,cmp);
	fo(i,1,n){
		int R=i;
		while(a[od[R]]==a[od[R+1]]) R++;
		fo(j,i,R){
			int k=od[j];
			ll sum=0;
			vis[k]=1;
			if(vis[k-1]) cnt--,sum+=(ll)siz[fin(k-1)]*siz[fin(k-1)],merge(k-1,k);
			if(vis[k+1]) cnt--,sum+=(ll)siz[fin(k+1)]*siz[fin(k+1)],merge(k+1,k);
			cnt++;
			ans+=(ll)siz[fin(k)]*siz[fin(k)]-sum;
		}
		//cnt:连续段的个数，ans:长度平方和，a[od[i]]:所选数 
		big(A[cnt],frac(ans,a[od[i]]));
		//printf("%d:%lld/%d\n",cnt,ans,a[od[i]]);
		i=R;
	}
	//fo(i,1,n) printf("%d:%lld/%d\n",i,A[i].fz,A[i].fm);
	rmq();
	while(T--){
		int a=read(),b=read(),x=read(),y=read();
		int l=(a*lst+x-1)%n+1,r=(b*lst+y-1)%n+1;
		if(l>r) swap(l,r);
		x=bel[l],y=bel[r];
		Ans=frac();
		if(y-x<=1) fo(i,l,r) big(Ans,A[i]);
		else{
			fo(i,l,lg*bel[l]) big(Ans,A[i]);
			fo(i,lg*(bel[r]-1)+1,r) big(Ans,A[i]);
			big(Ans,query(bel[l]+1,bel[r]-1));
		}
		if(Ans.fz) printf("%lld %d\n",Ans.fz,Ans.fm);
		else puts("-1 -1");
		printf("%d %d %lld\n",l,r,lst);
		if(Ans.fz) lst=Ans.fz*Ans.fm%n;
		else lst=1;
	}
	return 0;
}
```


---

## 作者：tommymio (赞：17)

这题的题目背景使我们明白，原来神题都是多次加强造出来的（划掉

观察题目中给出的这个得分的性质，发现随着 $x$ 的增大，并不存在任何单调性，是一个多峰函数。直接考虑暴力枚举 $x$，并处理出对于 $x$ 的每个取值下，被标记的区间长度的平方和和区间个数。

对于限定区间个数 $tot$ $\in [l,r]$ 的询问，在预处理后，已知 $x$ 的每个取值能够取到的区间个数，对于每一区间个数取一个最值，再维护区间个数在 $\in [l,r]$ 的最值即可，使用线段树/$\text{ST}$ 表等 $\text{RMQ}$ 数据结构都可，但毒瘤出题人 $\color{black}\text{C}\color{red}\text{Yjian}$ 卡空间，只能使用空间复杂度为 $O(n + \sqrt n)$ 的分块（~~分块什么时候是数据结构了~~

对于一个确定的 $x$ ，处理出被标记的区间长度的平方和和区间个数，这是一个连通性的问题，可以使用带权并查集维护。

小于等于 $x$ 的标记也很好实现，从小到大标记。并且我们发现，如果将 $a_i$ 从小到大排序，一个 $\exists i\geq 1,a_{i-1}<x<a_i$ 的 $x$ 对答案不产生影响，因为这个影响也同样产生在 $x=a_{i-1}$。那么离散化后按照上述思路处理即可。

**Show the Code**

```cpp
#include<cstdio>
#include<vector>
#include<cmath>
#include<algorithm>
#define get_block(x) (x-1)/block+1 
#define min(a,b) ((a)<(b)? (a):(b))
typedef long long ll;
std::vector<int> t[1000001];
ll v[1000001];
int fa[1000001],size[1000001],a[1000001],c[1000001],mx[1000001],maxn[1001];
inline int read() {
	register int x=0,f=1;register char s=getchar();
	while(s>'9'||s<'0') {if(s=='-') f=-1;s=getchar();}
	while(s>='0'&&s<='9') {x=x*10+s-'0';s=getchar();}
	return x*f;
}
inline void swap(int &x,int &y) {int tmp=y;y=x;x=tmp;}
inline int find(int x) {return x==fa[x]? x:fa[x]=find(fa[x]);}
inline void merge(int x,int y,ll &res1,int &res2) {
	int fx=find(x),fy=find(y);
	if(fx!=fy) {
		res1-=(ll)size[fx]*size[fx]+(ll)size[fy]*size[fy]; --res2;
		fa[fy]=fx;size[fx]+=size[fy];res1+=(ll)size[fx]*size[fx];
	}
}
inline bool cmp(int x,int y) {return v[x]*1ll*c[y]<v[y]*1ll*c[x];}
int main() {
	int n=read(),T=read(),num=0,block=sqrt(n);
	for(register int i=1;i<=n;++i) c[++num]=a[i]=read(),fa[i]=i;
	std::sort(c+1,c+1+num); num=std::unique(c+1,c+1+num)-c-1; 
	for(register int i=1;i<=n;++i) {a[i]=std::lower_bound(c+1,c+1+num,a[i])-c;t[a[i]].push_back(i);}
	ll now=0; int tot=0;
	v[0]=-1,c[0]=1;
	for(register int x=1;x<=num;++x) {
		for(register int i=0;i<t[x].size();++i) {size[t[x][i]]=1; ++now; ++tot;}
		for(register int i=0;i<t[x].size();++i) {
			if(t[x][i]!=1&&a[t[x][i]-1]<=x) merge(t[x][i],t[x][i]-1,now,tot);
			if(t[x][i]!=n&&a[t[x][i]+1]<=x) merge(t[x][i],t[x][i]+1,now,tot);
		}
		v[x]=now;
		if(cmp(mx[tot],x)) {
			mx[tot]=x;
			if(cmp(maxn[get_block(tot)],x)) maxn[get_block(tot)]=x;
		}
	}
	ll ans=0;
	while(T--) {
		int a=read()%n,b=read()%n,x=read()%n,y=read()%n;
		int l=((a*1ll*ans%n+x-1)%n+n)%n+1,r=((b*1ll*ans%n+y-1)%n+n)%n+1;
		if(l>r) swap(l,r);
		int bl=get_block(l),br=get_block(r),id=0;
		if(bl==br) {for(register int i=l;i<=r;++i) if(cmp(id,mx[i])) id=mx[i];}
		else {
			for(register int i=l;i<=min(bl*block,n);++i) if(cmp(id,mx[i])) id=mx[i];
			for(register int i=bl+1;i<br;++i) if(cmp(id,maxn[i])) id=maxn[i];
			for(register int i=(br-1)*block+1;i<=r;++i) if(cmp(id,mx[i])) id=mx[i];
		}		
		if(id==0) {printf("-1 -1\n%d %d %d\n",l,r,ans);ans=1%n;}
		else {printf("%lld %d\n%d %d %d\n",v[id],c[id],l,r,ans);ans=(v[id]%n)*1ll*(c[id]%n)%n;}
	}
	return 0;
}
```


---

## 作者：Brilliance_Z (赞：13)

### “得分改成了原来的得分除以你选择的数”
设每一个原始得分 $sco$ 所对应的选择的数是 $x$。原始得分比较大小时，把判断条件改为 $\dfrac{sco_{\text{old}}}{x_{\text{old}}}<\dfrac{sco_{\text{new}}}{x_{\text{new}}}$ 即可。而且显然选择的数是数列中的数才更优。

### “选择的数得到的区间的个数在 $l\sim r$ 的范围内”
预处理 $res[i]$：得到的区间个数是 $i$ 的最大最终得分所对应的原始得分 $sco$ 和选择的数 $x$。再在 $res$ 上建立 ST 表。对于每个在线询问 $(l,r)$，ST 表查询 $res[l\sim r]$ 的最大值。

### $O(N)$ 预处理 $res[i]$：

设 $sco$：当前的原始得分；$cnt$：当前的区间个数。从小到大枚举数列中的数 $x$：

其在数列中的下标为 $i$，增加区间 $[i,i]$。令 $sco\leftarrow sco+1\times 1,cnt\leftarrow cnt+1$。因为连续标记的位置要合并成一个区间，所以然后要检验是否存在已有区间端点的下标为 $i-1,i+1$，若存在则要与之合并。由公式 $(a+b)^2=a^2+b^2+2\times a\times b$，设 $prod$ 表示两个区间原大小的乘积，每合并两个区间时要令 $sco\leftarrow sco+prod\times 2,cnt\leftarrow cnt-1$。注意合并区间时统一从右往左或从左往右合并，这样信息不会合并错。

**把数列中大小为 $x$ 的数全部一起按上面的操作增加区间后** ，再用此时的 $sco,x$ 更新 $res[cnt]$！！！

### 总结

1. “从小到大枚举数列中的数 $x$ ” 需要排序 $O(N\log N)$。
2. 预处理 $res[i]$ $O(N)$。
3. 在 $res$ 上建立 ST 表 $O(N\log N)$。
4. ST 表回答询问 $O(T)$。

注意题目中的要求 **“如果有多解则输出选择的数最大的一组”** ！！！

### 卡空间技巧
若 ST 表要在 `struct` 上建立，开 $O(N\log N)$ 的 `struct` 可能会爆空间。其实只要开 $O(N)$ 的 `struct` 存原序列，ST 表开 $O(N\log N)$ 的 `int` 存最值对应的下标即可。

### 代码实现

```cpp
#include<bits/stdc++.h>
using namespace std;

typedef long long LL;
typedef long double LD;
typedef pair<int,int> PII;
typedef pair<LL,int> PLI;
const int N=1e6+10;
int n,t;
LL ans;
PII num[N],vis[N];  //num={数值,下标}；vis[i]={以i（数列的下标）为一个端点的区间的大小,该区间的另一个端点}，如果不存在该区间则vis[i]={0,0}
int lg2[N];
PLI res[N]; //res[i]={得到的区间个数是i的最大最终得分所对应的原始得分,选择的数}
int st[N][20];  //卡空间技巧：st表存最值对应的下标

inline int cmp(LD x,LD y)
{
    if(fabs(x-y)<1e-15) return 0;
    if(x>y) return 1;
    return -1;
}

void st_pre()
{
    for(int i=2;i<=n;i++) lg2[i]=lg2[i>>1]+1;
    for(int l=1;l<=n;l++) st[l][0]=l;
    for(int k=1;1+(1<<k)-1<=n;k++)
        for(int l=1;l+(1<<k)-1<=n;l++)
        {
            int c=cmp(1.0*res[st[l][k-1]].first/res[st[l][k-1]].second,1.0*res[st[l+(1<<(k-1))][k-1]].first/res[st[l+(1<<(k-1))][k-1]].second);
            if(c==1) st[l][k]=st[l][k-1];
            else if(c==0)   //如果有多解则输出选择的数最大的一组
            {
                if(res[st[l][k-1]].second>res[st[l+(1<<(k-1))][k-1]].second) st[l][k]=st[l][k-1];
                else st[l][k]=st[l+(1<<(k-1))][k-1];
            }
            else st[l][k]=st[l+(1<<(k-1))][k-1];
        }
    return ;
}

PLI st_max(int l,int r)
{
    int k=lg2[r-l+1];
    int c=cmp(1.0*res[st[l][k]].first/res[st[l][k]].second,1.0*res[st[r-(1<<k)+1][k]].first/res[st[r-(1<<k)+1][k]].second);
    if(c==1) return res[st[l][k]];
    else if(c==0)
    {
        if(res[st[l][k]].second>res[st[r-(1<<k)+1][k]].second) return res[st[l][k]];
        return res[st[r-(1<<k)+1][k]];
    }
    else return res[st[r-(1<<k)+1][k]];
}

int main()
{
    scanf("%d%d",&n,&t);
    for(int i=1;i<=n;i++) res[i]={-1,1};
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&num[i].first);
        num[i].second=i;
    }
    sort(num+1,num+n+1);
    LL sco=0,cnt=0;
    for(int i=1;i<=n;i++)
    {
        int x=num[i].first,id=num[i].second;
        vis[id]={1,id};
        sco+=1;
        cnt++;

        //把右区间合并到左区间
        if(vis[id-1].first!=0)
        {
            //注意先更新sco和cnt，否则vis[id-1].first,vis[id].first的信息是合并后的
            sco+=2ll*vis[id-1].first*vis[id].first;
            cnt--;

            //画图模拟便于理解
            int backup=vis[id].first;
            vis[id].first+=vis[id-1].first;
            vis[id].second=vis[id-1].second;
            vis[vis[id-1].second].first+=backup;
            vis[vis[id-1].second].second=id;
        }
        if(vis[id+1].first!=0)
        {
            sco+=2ll*vis[id].first*vis[id+1].first;
            cnt--;
            int backup1=vis[vis[id+1].second].first,backup2=vis[id+1].second;   //注意备份vis[id+1].second！！！
            vis[vis[id+1].second].first+=vis[id].first;
            vis[vis[id+1].second].second=vis[id].second;
            vis[vis[id].second].first+=backup1;
            vis[vis[id].second].second=backup2;
        }
        if(i!=n && num[i].first==num[i+1].first) continue;  //把数列中大小为x的数全部一起按上面的操作增加区间后，再用此时的sco,x更新res[cnt]！！！
        if(cmp(1.0*res[cnt].first/res[cnt].second,1.0*sco/x)<=0) res[cnt]={sco,x};
    }
    st_pre();
    while(t--)
    {
        int a,b,x,y;
        scanf("%d%d%d%d",&a,&b,&x,&y);
        int l=(__int128(a)*ans+x-1)%n+1;
        int r=(__int128(b)*ans+y-1)%n+1;
        if(l>r) swap(l,r);
        PLI cur=st_max(l,r);
        if(cur.first<0)
        {
            printf("-1 -1\n%d %d %lld\n",l,r,ans%n);
            ans=1;
            continue;
        }
        printf("%lld %d\n%d %d %lld\n",cur.first,cur.second,l,r,ans%n);
        ans=cur.first*cur.second;
    }
    return 0;
}
```

---

## 作者：Bruteforces (赞：10)

我们从小到大枚举每一个选择的数 $x$，求出此时被标记的区间数量 $cnt$ 以及所有区间长度的平方和 $sum$。使用RMQ或者线段树（我用的是RMQ）维护区间数量 $cnt$ 在某一范围内时，$max(sum/x)$ 以及 $x$ 的值。对于每个询问直接查询即可。具体实现见代码。

本题有一些坑点：

1.RMQ做法可能会被卡空间，如果你开 $1e6*20$ 的数组的话。注意到区间数量不可能超过 $ceil(n/2)$，所以我们只要开 $5e5*20$ 的数组就可以了。（线段树应该没有这个问题）

2.本题有无解的情况，此时 $lastans$ 应该更新为 $1$ ！ 本蒟蒻因为这个原因WA了三次！

以下是蒟蒻的丑陋压行代码：
```
#include<bits/stdc++.h>
#define LL long long
#define PII pair<LL,int>
using namespace std;

const int N=1e6+7;
int n,T,A[N];
LL Ans[N];  //表示选择的数为x时，所有区间长度的平方和
int RMQ[N>>1][20];  //RMQ数组，表示区间[ i,i+(1<<j) )内，使得sum/x最大的x
int lg2[N>>1];

inline int read() {
	int x=0,f=1;char ch=getchar();
	for(;!isdigit(ch);ch=getchar())if(ch=='-')f=-1;
	for(;isdigit(ch);ch=getchar())x=x*10+ch-'0';
	return x*f;
}

int Check(int x,int y){
	if(!x)return y;
	if(!y)return x;
	if(Ans[x]*y>Ans[y]*x)return x;
	else if(Ans[x]*y<Ans[y]*x)return y;
	else return (x>y ? x : y);
}

vector<int> vec[N];  //存储每个数出现的位置
int len[N];  //表示第i个数所在区间的长度（只需要更新区间两端的值）
void Prework() {
	int mx=0;
	for(int i=1;i<=n;++i)vec[A[i]].push_back(i),mx=max(mx,A[i]);
	LL val=0;
	int cnt=0;
	for(int i=1;i<=mx;++i)if(vec[i].size()) {
		for(int j=0;j<(int)vec[i].size();++j){
			int v=vec[i][j];
			if(!len[v-1] && !len[v+1]) {
				++val;++cnt;len[v]=1;
			} else if(len[v-1] && len[v+1]) {
				val+=2LL*len[v-1]*len[v+1]+2LL*len[v-1]+2LL*len[v+1]+1;
				--cnt;
				len[v-len[v-1]]=len[v+len[v+1]]=len[v-1]+len[v+1]+1;
			} else if(len[v-1]) {
				val+=2LL*len[v-1]+1;
				len[v-len[v-1]]=len[v]=len[v-1]+1;
			} else {
				val+=2LL*len[v+1]+1;
				len[v+len[v+1]]=len[v]=len[v+1]+1;
			}
		}
		Ans[i]=val;
		RMQ[cnt][0]=Check(i,RMQ[cnt][0]);
	}
	for(int i=2;i<=(n+1)/2;++i)lg2[i]=lg2[i>>1]+1;
	for(int j=1;j<=19;++j) {
		for(int i=1;i+(1<<j)-1<=(n+1)/2;++i) {
			RMQ[i][j]=Check(RMQ[i][j-1],RMQ[i+(1<<(j-1))][j-1]);
		}
	}
}
int Query(int L,int R) {
	if(L>(n+1)/2)return 0;
	if(R>(n+1)/2)R=(n+1)/2;
	int x=lg2[R-L+1];
	return Check(RMQ[L][x],RMQ[R-(1<<x)+1][x]);
}

int main() {
	n=read(),T=read();
	for(int i=1;i<=n;++i)A[i]=read();
	Prework();
	int lastans=0;
	while(T--) {
		int a=read()%n,b=read()%n,x=read()%n,y=read()%n;
		int L=(1LL*a*lastans%n+x-1+2*n)%n+1,R=(1LL*b*lastans%n+y-1+2*n)%n+1;
		if(L>R)swap(L,R);
		int ans=Query(L,R);
		if(!ans)puts("-1 -1");else printf("%lld %d\n",Ans[ans],ans);
		printf("%d %d %d\n",L,R,lastans);
		if(!ans)lastans=1;else lastans=Ans[ans]%n*ans%n;
	}
	return 0;
}
```

---

## 作者：ComplexPlanck (赞：9)

[传送门（题目链接）](https://www.luogu.com.cn/problem/P5012)

可以看出，随着你选择的 $x$ 增大，场上被标记的元素会越来越多。

虽然答案不具有单调性，但是假设我们遍历 $w\in[1,W]$（其中 $W$ 为值域大小），然后将所有元素等于 $w$ 的元素标记。当然，它有可能和旁边的元素“连起来”。

随着时间的增加（遍历 $w$ ），越来越多的点（此处的元素）被加入到当前局面中，且它们中存在连通 / 不连通的关系，要你查询连通块的大小（连续段的长度）。

这显然是一个连通性问题，我们可以使用并查集解决。

于是我们可以使用 `std::vector` 存储每个值为 $w$ 的元素的位置，然后去标记元素们。

这时我们可以统计出选择 $w$ 时的答案 $now$ 以及连续段数 $segs$。

---
题目要求我们求出 $segs$ 在 $[L,R]$ 范围内的，当 $\dfrac{now}{w}$ 最大时的 $now$ 和 $w$。

所以我们不关心选择什么元素的时候连续段数为 $segs$，只关系连续段数为 $segs$ 时的，当 $\dfrac{now}{w}$ 最大时的 $now$ 和 $w$。

所以我们完全可以记录当连续段数为 $segs$ 的时候的当 $\dfrac{now}{w}$ 最大时的 $now$ 和 $w$。

我们这一部分完全可以全部**预处理**出来，且时间复杂度是 $\mathcal{O}(n+Wt+n\alpha(n))$，其中 $n$ 为以值域遍历序列的复杂度，$t$ 为修改连续段数为 $seg$ 时的单次操作复杂度（如果直接修改线段树的话 $t=\mathcal{O}(\log n)$，离线下来的话就是 $t=\mathcal{O}(1)$），$n\alpha(n)$ 为使用路径压缩 + 按秩合并的并查集的时间复杂度，另外由于这里要查询集合大小，所以推荐将秩指定为集合大小而非深度（这样可以少开一个数组）。

接下来我们就要查询当 $segs\in[L,R]$ 时的答案，聪明的你可能看出来了，这是我们的老朋友，静态区间最大值问题（ RMQ 问题），于是如果选择 ST 表的话，就可以做到 $\mathcal{O}(n\log n)-\mathcal{O}(1)$ 的时间复杂度。

正当问题快要解决的时候，Subtask 3 全员蹦出了 MLE，这是因为 ST 表的空间复杂度是 $\mathcal{O}(n\log n)$ 的，而显然你为了记录达到 `long long` 级别的 $now$ 和不能使用 `short` 记录的 $w$，使你单单在 ST 表上的空间复杂度就到达了 $(8+4)\times 20\times 10^6\,\text{Byte}=234575\text{KB}\approx 228.88\text{MB} $，而题目只给了 $125\text{MB}\sim 128\text{MB}$ 的空间。

所以只能退而求其次，选择时间复杂度不那么优秀，但空间复杂度为 $\mathcal{O}(n)$ 的线段树了。

然后卡过去了。

---
一点卡空间的小建议：

1. 使用 `std::vector`，`resize()` 和 `clear()`。

2. 使用线段树不要开出线段树节点的左右端点，而是放到参数列表中。

3. 修改 / 询问固定的元素，即修改用的元素，修改的位置和询问的区间不要放到参数列表里，而是独立出来，这样可以去掉一点点空间。



最后以 $111.1\text{MB}$ 卡过去了。

一个会让你挂成 $5\text{pts}$ 的坑点：$lastans$ 的数量级大约是 $(10^6)^2\times 10^6=10^{18}$，而输入的 $a\leqslant 2\times 10^9$，所以 $a\times lastans\approx 2\times 10^{27}$，会究极溢出，所以请使用 `__int128`。

---

- 关于代码中预处理 `go()` 函数的详细讲解

```cpp
void go(void)
{
    pa.resize(n + 1), large.resize(n + 1);
    // 分配空间，毕竟这是道卡空间的题
    for (int i = 1; i <= n; ++ i)
        pa[i] = i, large[i] = -1;
    // 初始化并查集的代表元素数组： pa 数组
    // large[x] ，当 x 为其自身的代表元素时，表示包含位置 x 的这个连续段的长度
    // 特别地，当 large[x] = -1 时该元素还未被标记
    i64 now = 0; int segs = 0;
    for (int i = 1; i <= maxn; ++ i)
    {
        int up = pos[i].size();
        segs += up, now += up;
        // 将 up 个散点加入其中
        // 因为暂时没有考虑这些散点和周围段的合并，所以 segs 需要增加 up
        // 而增加的 up 个段，每个段长度都为 1 ，所以 now 也需要增加 up 
        for (int j = 0; j < up; ++ j)
        {
            int x = pos[i][j], f, p;
            large[x] = 1;
            if (x > 1 && large[x - 1] != -1)
            // 当位置 x 左边有元素且已经被标记了
            {
                f = bcj_find(x), p = bcj_find(x - 1);
                // 查询其代表元素，准备合并包含这两个代表元素的两段
                if (p != f)
                // 不在同一个连续段内
                {
                    now -= 1ll * large[p] * large[p], now -= 1ll * large[f] * large[f];
                    // 扣除这两个连续段对答案的贡献
                    if (large[p] < large[f]) pa[p] = f, large[f] += large[p];
                    else pa[f] = p, large[p] += large[f];
                    // 并查集按秩合并
                    now += 1ll * large[pa[f]] * large[pa[f]];
                    // 加上这个合并后的连续段对答案的贡献
                    -- segs;
                    // 两个段合并为一段，连续段个数减去 1
                }
            }
            if (x < n && large[x + 1] != -1)
            // 这个部分是和右边合并，是同理的
            {
                f = bcj_find(x), p = bcj_find(x + 1);
                if (p != f)
                {
                    now -= 1ll * large[p] * large[p], now -= 1ll * large[f] * large[f];
                    if (large[p] < large[f]) pa[p] = f, large[f] += large[p];
                    else pa[f] = p, large[p] += large[f];
                    now += 1ll * large[pa[f]] * large[pa[f]];
                    -- segs;
                }
            }
        }
        t.modify(segs, std::make_pair(now, i));
        // 更新连续段个数为 segs 时的答案
    }
    for (int i = 1; i <= maxn; ++ i)
        pos[i].clear();
    pa.clear(), large.clear();
    pa.shrink_to_fit(), large.shrink_to_fit();
    // 清空数组，避免产生空间浪费
    return;
}
```

---
具体细节可以参见示例代码：

```cpp
// Luogu P5012
#include <bits/stdc++.h>
using i64 = long long;
using i128 = __int128;

const int N = 1000010;
int n, m, maxn = -1;
std::vector<int> pos[N];
std::vector<int> pa, large;

inline void update(std::pair<i64, int> &x, const std::pair<i64, int> &y)
{
    if (y.first == -1) return;
    if (x.first == -1 || 1ll * y.first * x.second > 1ll * y.second * x.first || (1ll * y.first * x.second == 1ll * y.second * x.first && y.second > x.second))
        x = y;
    return;
}

struct Segment_Tree
{
    std::pair<i64, int> dats[N << 2];
    std::pair<i64, int> cur;
    int change_x, ask_x, ask_y;

    void init(void)
    {
        fill(dats, dats + (n << 2) + 1, std::make_pair(-1, -1));
        return;
    }
    void change(int p, int inl, int inr)
    {
        if (inl == inr)
        {
            update(dats[p], cur);
            return;
        }
        int mid = (inl + inr) >> 1;
        if (change_x <= mid) change(p << 1, inl, mid);
        else change(p << 1 | 1, mid + 1, inr);
        update(dats[p], dats[p << 1]), update(dats[p], dats[p << 1 | 1]);
        return;
    }
    void modify(int x, std::pair<i64, int> now)
    {
        cur = now, change_x = x;
        change(1, 0, n);
        return;
    } 
    void ask(int p, int inl, int inr)
    {
        if (ask_x <= inl && inr <= ask_y)
        {
            update(cur, dats[p]);
            return;
        }
        int mid = (inl + inr) >> 1;
        if (ask_x <= mid) ask(p << 1, inl, mid);
        if (ask_y > mid) ask(p << 1 | 1, mid + 1, inr);
        return;
    }
    std::pair<i64, int> query(int l, int r)
    {
        cur = std::make_pair(-1, -1);
        ask_x = l, ask_y = r, ask(1, 0, n);
        return cur;
    }
}t;

template<typename types>
void read(types &x)
{
    x = 0; int f = 1; char ch = getchar();
    while (!isdigit(ch)) {if (ch == '-') f = -1; ch = getchar();}
    while (isdigit(ch)) x = x * 10 + ch - 48, ch = getchar();
    x *= f; return;
}
template<typename types>
void write(types x)
{
    if (x < 0) putchar('-'), x = -x;
    if (x > 9) write(x / 10);
    putchar(x % 10 + '0'); return;
}
int bcj_find(const int &x)
{
    return (x == pa[x]) ? pa[x] : (pa[x] = bcj_find(pa[x]));
}
void go(void)
{
    pa.resize(n + 1), large.resize(n + 1);
    for (int i = 1; i <= n; ++ i)
        pa[i] = i, large[i] = -1;
    i64 now = 0; int segs = 0;
    for (int i = 1; i <= maxn; ++ i)
    {
        int up = pos[i].size();
        segs += up, now += up;
        for (int j = 0; j < up; ++ j)
        {
            int x = pos[i][j], f, p;
            large[x] = 1;
            if (x > 1 && large[x - 1] != -1)
            {
                f = bcj_find(x), p = bcj_find(x - 1);
                if (p != f)
                {
                    now -= 1ll * large[p] * large[p], now -= 1ll * large[f] * large[f];
                    if (large[p] < large[f]) pa[p] = f, large[f] += large[p];
                    else pa[f] = p, large[p] += large[f];
                    now += 1ll * large[pa[f]] * large[pa[f]];
                    -- segs;
                }
            }
            if (x < n && large[x + 1] != -1)
            {
                f = bcj_find(x), p = bcj_find(x + 1);
                if (p != f)
                {
                    now -= 1ll * large[p] * large[p], now -= 1ll * large[f] * large[f];
                    if (large[p] < large[f]) pa[p] = f, large[f] += large[p];
                    else pa[f] = p, large[p] += large[f];
                    now += 1ll * large[pa[f]] * large[pa[f]];
                    -- segs;
                }
            }
        }
        t.modify(segs, std::make_pair(now, i));
    }
    for (int i = 1; i <= maxn; ++ i)
        pos[i].clear();
    pa.clear(), large.clear();
    pa.shrink_to_fit(), large.shrink_to_fit();
    return;
}

int main(void)
{
    read(n), read(m);
    for (int i = 1, inpx; i <= n; ++ i)
        read(inpx), pos[inpx].push_back(i), maxn = std::max(maxn, inpx);
    t.init(), go();

    i64 inpa, inpb, inpx, inpy, inpl, inpr, last = 0;
    for (int i = 1; i <= m; ++ i)
    {
        read(inpa), read(inpb), read(inpx), read(inpy);
        inpl = (i128(inpa) * last + inpx - 1) % n + 1;
        inpr = (i128(inpb) * last + inpy - 1) % n + 1;
        if (inpl > inpr) std::swap(inpl, inpr);
        std::pair<i64, int> ans = t.query(inpl, inpr);
        write(ans.first), putchar(' '), write(ans.second), putchar('\n');
        write(inpl), putchar(' '), write(inpr), putchar(' '), write(last % n), putchar('\n');
        last = ans.first * ans.second;
    }

    return 0;
}
```

---

## 作者：_Ponder_ (赞：4)

[水の数列](https://www.luogu.com.cn/problem/P5012)

### 题目大意

对于给定的数列 $a$，选择一个数 $x$，定义其得分为数列中所有小于等于 $x$ 的数形成的若干个连续区间的平方和除以 $x$ 所得到的数。

现进行多次询问，每次询问给定两个数 $l,r$，要求出一个得分最大的 $x$，满足数列中所有小于等于 $x$ 的数形成的若干个连续区间的个数在 $l$ 到 $r$ 之间。

强制在线。

### 思路分析

容易发现，满足条件的得分最大的 $x$ 一定是数列中的一个数。考虑反证法，如果满足条件的得分最大的 $x$ 不是数列中的数，那么一定可以将 $x$ 变成数列中最大的小于 $x$ 的数，分子不变，分母变小，得分增大。

那么这就意味着 $x$ 的取值只有 $O(n)$ 级别，又因为得分没有单调性（容易构造，比如 `1 100 4 3`），所以考虑从小到大枚举 $x$ 的取值。

由于 $x$ 单调，那么数列中被标记的数的个数也一定单调，那么就可以用并查集维护所有小于等于 $x$ 的数形成的连通块，$O(n\log n)$ 预处理出对于 $x$ 的每一个取值，得到的得分和连通块的块数。

具体的说，先将原数列排序，从小到大枚举 $x$（这里指的是枚举 $x$ 的可能取值），对于每一个数列中等于 $x$ 的数，判断是否与其左右的数合并即可。合并时可以 $O(1)$ 更新信息。

对于每一个询问，我们发现，在预处理时，已经得到了每一个 $x$ 所对应的区间个数。那么我们可以对于每一个区间长度的所有可能的 $x$ 所对应的得分取一个最值，再对于区间长度的得分 RMQ 即可。

时间复杂度由 RMQ 的数据结构决定，但不低于 $O(n\log n)$。

- 一些细节

数据在解密时可能爆 `long long`，可以开 `__int128` 或读入后先取模。

在无解时输出 `-1 -1` 后将 `lastans` 设为 $1$。

初始时 `lastans` 为 $0$。

### 代码

```
#include <iostream>
#include <cmath>
#include <cstring>
#include <algorithm>
#include <vector>

using namespace std;
const int N=1001000,M=1010;
typedef long long ll;

int T,n,tot,S,m,in1,in2,in3,in4;
int fa[N],siz[N],a[N],c[N];
int maxn[N],maxi[M],l[M],r[M],pos[N];//空间一定要开够
ll now,ans[N],lastans;

vector <int> v[N];

int find(int x){return fa[x]==x?x:fa[x]=find(fa[x]);}
void merge(int x,int y){
    x=find(x);y=find(y);
    if(x==y) return ;
    now-=1ll*siz[x]*siz[x]+siz[y]*siz[y];//去除贡献
    tot--;siz[x]+=siz[y];fa[y]=x;
    now+=1ll*siz[x]*siz[x];//增加贡献
}

bool compare(int x,int y){return 1ll*ans[x]*c[y]<1ll*ans[y]*c[x];}//分数比较大小，c[x] 是实际的 x，ans[x] 是得分的分子

void query_t(int &res,int x,int y,int g[]){
    for(int i=x;i<=y;i++)
        if(compare(res,g[i])) res=g[i];
}

int query(int x,int y){//RMQ
    int res=0;
    if(pos[x]==pos[y]){query_t(res,x,y,maxn);return res;}
    query_t(res,x,r[pos[x]],maxn);
    query_t(res,l[pos[y]],y,maxn);
    query_t(res,pos[x]+1,pos[y]-1,maxi);
    return res;
}

int main(){
    memset(l,0x3f,sizeof l);
    scanf("%d%d",&n,&T);
    S=sqrt(n);m=n;//RMQ 使用分块
    for(int i=1;i<=n;i++){
        scanf("%d",&a[i]);
        c[i]=a[i];
        pos[i]=(i-1)/S+1;//每个数所在块
    }
    for(int i=1;i<=n;i++){//初始化块端点和并查集
        fa[i]=i;siz[i]=1;
        l[pos[i]]=min(l[pos[i]],i);
        r[pos[i]]=max(r[pos[i]],i);
    }
    sort(c+1,c+m+1);//离散化
    m=unique(c+1,c+m+1)-c-1;
    for(int i=1;i<=n;i++){
        a[i]=lower_bound(c+1,c+m+1,a[i])-c;
        v[a[i]].push_back(i);//对于每一个离散化后的值开一个 vector 存下标
    }
    ans[0]=-1;
    c[0]=1;
    for(int x=1;x<=m;x++){
        now+=v[x].size();tot+=v[x].size();//等于 x 的数有 v[x].size() 个
        //now 表示平方和，tot 表示个数
        for(auto it:v[x]){//遍历所有等于 x 的数
            if(it!=1&&a[it-1]<=x) merge(it,it-1);//特判边界
            if(it!=n&&a[it+1]<=x) merge(it,it+1);//如果旁边的数 <= x 就一定被标记或即将被标记
        }
        ans[x]=now;
        if(compare(maxn[tot],x)){
            maxn[tot]=x;//更新单点答案
            if(compare(maxi[pos[tot]],x))
                maxi[pos[tot]]=x;//更新块内答案
        }
    }
    while(T--){
        scanf("%d%d%d%d",&in1,&in2,&in3,&in4);
        in1%=n;in2%=n;in3%=n;in4%=n;//读入后取模
        int l=(1ll*in1*lastans%n+in3-1+n)%n+1;
        int r=(1ll*in2*lastans%n+in4-1+n)%n+1;
        if(l>r) swap(l,r);
        int res=query(l,r);
        if(!res){printf("-1 -1\n%d %d %lld\n",l,r,lastans);lastans=1;}
        else{
            printf("%lld %d\n%d %d %lld\n",ans[res],c[res],l,r,lastans);
            lastans=1ll*(ans[res]%n)*(c[res]%n)%n;
        }
    }
    return 0;
}
```

---

## 作者：creation_hy (赞：2)

省流：线段树能过

显然在 $x$ 打上标记的点在 $\ge x$ 的点也会有标记，于是容易想到升序枚举 $x$ 暴力算，每次点亮一个点后看他左右两个点是否点亮，如果有点亮的那就合并，用并查集维护一下连通块大小即可。

然后把每个 $x$ 对应的答案及连通块数量列出来，询问就变成了区间最大值，这个空间 ST 表确实不太行，但是线段树如果只维护原始得分和点亮的值，除之后的结果现场算是可以过的。

最后注意 $lastans$ 是那两个数的乘积。。。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 1e6 + 5;
int n, m, a[N], fa[N], vis[N], sz[N], cnt;
ll sum;
vector<int> vec[N];
inline ll sq(ll x) { return x * x; }
inline int find(int x) { return x == fa[x] ? x : fa[x] = find(fa[x]); }
inline void merge(int x, int y)
{
	x = find(x), y = find(y);
	if (x != y)
	{
		sum = sum - sq(sz[x]) - sq(sz[y]) + sq(sz[x] + sz[y]);
		sz[fa[y] = x] += sz[y], cnt--;
	}
}
struct node
{
	ll k;
	int x;
	inline bool operator<(const node &t) const
	{
		return k * t.x == t.k * x ? x < t.x : k * t.x < t.k * x;
	}
} s[N];
struct SegTree
{
	node f[N << 2];
	inline int ls(int p) { return p << 1; }
	inline int rs(int p) { return p << 1 | 1; }
	inline void push_up(int p) { f[p] = max(f[ls(p)], f[rs(p)]); }
	inline void build(int p, int l, int r)
	{
		if (l == r)
		{
			f[p] = s[l];
			return;
		}
		int mid = l + r >> 1;
		build(ls(p), l, mid);
		build(rs(p), mid + 1, r);
		push_up(p);
	}
	inline node query(int p, int l, int r, int qx, int qy)
	{
		if (qx <= l && r <= qy)
			return f[p];
		int mid = l + r >> 1;
		node res({0, 0});
		if (qx <= mid)
			res = max(res, query(ls(p), l, mid, qx, qy));
		if (mid < qy)
			res = max(res, query(rs(p), mid + 1, r, qx, qy));
		return res;
	}
} seg;
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	cin >> n >> m;
	for (int i = 1; i <= n; i++)
		cin >> a[i], fa[i] = i, sz[i] = 1, vec[a[i]].emplace_back(i);
	for (int i = 1; i <= 1e6; i++)
		if (!vec[i].empty())
		{
			for (int x : vec[i])
			{
				vis[x] = 1, sum++, cnt++;
				if (vis[x - 1])
					merge(x - 1, x);
				if (vis[x + 1])
					merge(x, x + 1);
			}
			s[cnt] = max(s[cnt], (node){sum, i});
		}
	seg.build(1, 1, n);
	ll lst = 0;
	while (m--)
	{
		ll a, b, x, y, l, r;
		cin >> a >> b >> x >> y;
		l = (a * lst + x - 1) % n + 1;
		r = (b * lst + y - 1) % n + 1;
		if (l > r)
			swap(l, r);
		int pre = lst;
		auto k = seg.query(1, 1, n, l, r);
		if (k.k)
			cout << k.k << ' ' << k.x << '\n', lst = k.k * k.x % n;
		else
			cout << "-1 -1\n", lst = 1;
		cout << l << ' ' << r << ' ' << pre << '\n';
	}
	return 0;
}
```

---

## 作者：X_X_M (赞：1)

## P5012 水の数列

~~然而这么出还是太简单了~~

~~upd 2025/2/3 23:04：这题坑太多了，以后再也不乱填非常简单了咕咕咕qwq。~~

一道很好的数据结构题。

------------

给定长度为 $N$ 的序列，记 $d(x)$ 为对于所有的 $v$，使得这些序列中小于等于 $v$ 的数恰好被划分为 $x$ 个序列时，这些序列的长度的平方和除以 $v$ 所得的数的最大值。

$T$ 次询问，每次给出 $l,r$，试求 $\max_{l \leq i \leq r}d(i)$。

------------

我们将题意整理成现在这样，意在展示**只要求出每一个** $d(k),k=1,2,...,k_m$，原题就可以通过**维护一个ST表**来解决。

观察题目，注意到能取到最大值的 $v$ 一定为序列中某个值。因为如果 $v$ 在两值之间，将其调整至较小的那个值，分子不变，$v$ 变得更小。

由于 $k$ 不好遍历求解，所以我们遍历 $v$，希望对于每一个 $v$ 求出所有序列长度的平方和。

从而发现如果从小到大考虑每一个 $v$，已加入序列的数字不会再退出，所以我们可以用**并查集**维护**所有已加入序列的数所在的序列**，然后递推求解分子和 $k$。

具体来说，每次加入一个新的 $v$，无外乎三种情况：

1.$v$ 的两侧数都没有加入，此时 $k\leftarrow k+1,sum\leftarrow sum+1$。

2.$v$ 的一侧数已加入，不妨设为左侧，此时 $sum\leftarrow sum+(|left|+1)^2-|left|^2$。

3.$v$ 的两侧数已加入，此时 $k\leftarrow k-1,sum\leftarrow sum+(|left|+|right|+1)^2-|left|^2-|right|^2$。

$v$ 的左右两侧区间大小可以在**维护并查集时记录在根节点上**。

---

## 作者：user100566 (赞：1)

## 题目分析
给定一个长度为 $N(N\le10^6)$，值域为 $[1, 10^6]$ 的整数数列 $Num_1, Num_2, Num_3, \dots, Num_N$。

定义区间数 $\text{cnt}(x)$ 与分数 $\text{score}(x)$：
> 将 $Num$ 中所有 $\le x$ 的数标记后，连续标记的区间的数量（$\text{cnt}(x)$）与这些区间的长度的平方和（$\text{score}(x)$）。
>
> 下文称这样的区间为**标记连续段**。

有 $T$ 次强制在线的询问，每次询问给出 $[l, r](1\le l\le r\le n)$，你需要选择 $x$，使得 $\text{cnt}(x)\in[l,r]$，同时最大化 $\frac{\text{score}(x)}{x}$，依次输出 $\text{score}(x), x$，如果无解输出 `-1 -1`。

## 解题思路

我们发现 $\frac{\text{score}(x)}{x}$ 与 $\text{cnt}(x)$ 无关，我们可以对所有 $\text{cnt}(x)=i$，初始化求出最优的 $\text{score}(x), x$，于是询问就变成了 RMQ 问题，但本题需要特殊处理无解的情况且内存限制较严，在后文会给出具体做法。

那么如何对所有 $\text{cnt}(x)=i$，求出最优的 $\text{score}(x), x$ 呢？  
显然考虑满足 $\text{cnt}(x)=i$ 的 $x$ 是困难的，我们不妨枚举可能的 $x$，然后去更新 $\text{cnt}(x)=i$ 的最优解。

## 初始化
由于 $N\le10^6, Num_i\le10^6$，因此我们不能暴力 $O(N\times Num_{max})$ 初始化，注意到**标记是单调变化的**，随着 $x$ 的增大，一个位置一定是从非标记到有标记之后不变的，因此枚举较大的 $x$ 时可以复用较小的 $x$ 的状态。

---

考虑当前从 $x_1$ 递推到 $x_2(x_1<x_2)$，那么所有 $Num_i\in (x_1, x_2]$ 都要被打上标记，其它部分不变，考虑如何更新 $\text{cnt}(x), \text{score}(x)$。  
由于标记没有先后顺序之分，我们先考虑只给某个 $Num_i$ 打标记，分以下情况讨论：
1. $Num_{i-1}, Num_{i+1}$ 均未被标记，那么 $\text{cnt}(x), \text{score}(x)$ 均增大 $1$。
2. $Num_{i-1}, Num_{i+1}$ 有一个被标记，那么 $Num_i$ 需要与它合并为一个标记连续段，显然 $\text{cnt}(x)$ 不变，设合并的标记连续段大小为 $S$，可得：

   + 原 $\text{score}(x)=\dots+S^2$
   + 新 $\text{score}(x)=\dots+(S+1)^2=\dots+S^2+(1+2\times S)$
3. $Num_{i-1}, Num_{i+1}$ 均被标记，那么 $Num_i$ 需要与它们一起合并为一个标记连续段，显然 $\text{cnt}(x)$ 减少 $1$，设 $Num_{i-1}$ 对应的标记连续段的大小为 $S_1$， $Num_{i+1}$ 对应的标记连续段的大小为 $S_2$，可得：

   + 原 $\text{score}(x)=\dots+{S_1}^2+{S_2}^2$
   + 新 $\text{score}(x)=\dots+(S_1+1+S_2)^2=\text{score}(x)=\dots+{S_1}^2+{S_2}^2+(1+2\times S_1+2\times (S_1+1)\times S_2)$

不失一般性，我们可以将上述过程理解为以下等价步骤：
1. 在 $Num_i$ 处新建一个长度为 $1$ 的标记连续段，$\text{cnt}(x), \text{score}(x)$ 均增大 $1$。
2. 将 $Num_{i-1}$ 所在的标记连续段（如果存在）与 $Num_i$ 所在的标记连续段合并。
3. 将 $Num_{i+1}$ 所在的标记连续段（如果存在）与 $Num_i$ 所在的标记连续段合并。

每次合并两个长度分别为 $S_1, S_2$ 的标记连续段时，$\text{cnt}(x)$ 均减小 $1$，$\text{score}(x)$ 增大 $2\times S_1\times S_2$，这实际上就是完全平方公式的应用。

---

上述算法需要快速查询某个位置所在标记连续段的大小，并合并两个标记连续端，这实际上就是一个**加权并查集**的操作，而且大小 $S$ 只需要在根上维护即可。

根据题意可知，所有对答案有贡献的 $x$ 必然出现在 $Num$ 中，如若不然，设 $x$ 在 $Num$ 中的前驱为 $x'$，则 $\text{score}(x')=\text{score}(x)$，$\frac{\text{score}(x')}{x'}>\frac{\text{score}(x)}{x}$，因此我们直接按 $Num$ 中的数从小到大递推即可。

当然，也需要快速知道 $Num_i\in (x_1, x_2]$，由于我们的递推顺序是按 $Num$ 中的数从小到大，那么不存在 $Num_i\in(x_1,x_2)$，我们只需要知道 $Num_i=x_2$ 即可。

---

定义二元组 $(i, Num_i)$ 数组 $B$，然后按第二元素 $Num_i$ 升序排序，递推时按排序后的 $B$ 的第二元素 $Num_i$ 顺序枚举 $x$，根据第一元素 $i$ 得到  $Num_i=x_2$ 的位置 $i$，然后用并查集更新 $\text{cnt}(x), \text{score}(x)$。  
需要注意可能有多个 $i$ 满足 $Num_i=x_2$，使用双指针来统一更新。

枚举到某个 $x$ 时，将其与 $\text{score}(x)$ 写入 $\text{cnt}(x)$ 更新最优解，完成后我们对所有有解的 $\text{cnt}$ 都得到了最优的 $\text{score}(x), x$。

## 处理询问
有多种方式可以处理本题的 RMQ 询问，这里以 ST 算法为例说明。

设上面的预处理得到了 $A_0, A_1, A_2, \dots$，其中 $A[i]$ 表示区间长度为 $i$ 时的最优解 $\text{score}(x), x$。  
注意，一个长度为 $N$ 的数列最多有 $\lceil\frac{N}{2}\rceil$ 个连续段，因此只需要定义 $A[0\sim500000]$。

定义 $dp[i][k]$ 表示 $\text{cnt}(x)\in[i, i+2^k)$ 时的最优解，每次询问 $[l, r]$ 时可以拆分为两个 $dp[\ ][k]$，取最优的那一个即可，这和标准 ST 算法没什么差别。

但是本题目空间限制较严，有以下方式可以减少空间使用：
1. 极限化 $dp$ 的长度。  
   前面提到 $A$ 的可能下标范围为 $[0, 500000]$，因此 $dp$ 第一维长度只需要定义 $500001$。  
   因为 $2^{18}=262144, 2\times262144=524288>500000$，因此第二维的可能下标为 $[0, 18]$，第二维长度只需要定义 $19$。
2. $dp$ 值存映射。  
   如果我们直接存 $\text{score}(x), x$，前者需要一个 $\text{int32}$，后者需要一个 $\text{int64}$，总计需要 $12B$ 的大小，但是我们可以只存最优解的**映射**，例如在 $A$ 中的下标（显然最优解必然存在于 $A$ 中），那么只需要 $4B$ 的大小即可。上面对 $B$ 排序也可以采用同样的方法优化。

---

注意询问区间可能越界，前面提到 $1\le l\le r\le n$，这意味着 $r$ 可能超过 $500000$，因为不可能有大于 $500000$ 个连续段，我们可以 $r\leftarrow min(r,500000)$，如果这样后发现有 $l>r$，意味着 $l>500000$，显然无解。

下面的代码维护了一个 `max_set`，表示可能的最多标记连续段数 $S_{max}$，查询时 $r\leftarrow min(r,S_{max})$

---

无解对应的状态应该**严格小于任何有效解**，一种方法是定义无解为 $x>0, \text{score}=0$，其有效性基于上面初始化时写入的 $\text{score}$ 全为正数，这样输出答案时可以通过 $[\text{score}=0]$ 判断是否无解。

## 比较问题

题目中说"如果有多解则输出选择的数最大的一组"，但是测试数据似乎并没有体现这一点，严谨起见我们考虑这一点，以下是关于这一点的 hack 数据：

### 输入
```plain
3 1
1 4 9
0 0 1 1
```
### 答案
```plain
4 4
1 1 0
```


比较的第一关键词为 $\frac{\text{score}(x)}{x}$，第二关键词为 $x$。

比较第一关键词时，有以下比较方法：
1. 直接用浮点数存储分数结果，注意引入 $\text{eps}$ 来正确判断浮点数相等。
2. 将除法比较转换为乘法比较，例如 $[\frac{\text{score}(x)}{x}<\frac{\text{score}(x')}{x'}]=[\text{score(x)}\times x'<\text{score}(x)\times x]$。

注意运算过程中是否需要强制类型转换，例如计算浮点数除法结果时，需要先转为浮点数。  
注意第一关键词相等时要比较第二关键词。

## 题目特色
我们已经完成了题目的主要问题，但是接下来的题目特色部分坑点较多，这里展开阐述。
```cpp
l = (a * lastans + x - 1) % n + 1;
r = (b * lastans + y - 1) % n + 1;
if (l > r) swap(l, r);
```
其中 $lastans$ 表示上一次询问的最大分数(原始得分)和得到这个最大的分数的 $x$ 的乘积，即 $lastans=\text{score}(x)\times x$。

其中 $\max\{\text{score}(x)\}=(10^6)^2=10^{12}$，$\max\{x\}=10^6$，$\max\{lastans\}=\max\{\text{score}(x)\}\times\max\{x\}=10^{12}\times10^6=10^{18}$，接近 $\text{int64}$ 的上限，上面的 `a * lastans`, `b * lastans` 可能超出 $\text{int64}$ 的范围，下面给出三种解决方案：
1. 用 $\text{int128}$（`__int128`）存储这一步的中间结果。
2. 根据模运算的性质，计算时先对 $lastans$ 取模 $N$。
3. 在更新 $lastans$ 时，直接对 $lastans$ 取模 $N$，即 $lastans=(\text{score}(x)\times x)\mod N$，这样做在输出 $lastans \mod N$ 时就可以直接输出 $lastans$。

## 代码
[AC 记录](https://www.luogu.com.cn/record/195818082)

[云剪贴板存档](https://www.luogu.com.cn/paste/wiwmit34)
```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
typedef long long int64;
constexpr int MAX_N = 1000000;
constexpr int MAX_NUM = 1000000;
constexpr int MAX_STSIZE = 18;

int n, T, Num[MAX_N+1];

struct stu1{
	int x;
	int64 score;
	// 无解情况，即默认的 score/x 需要小于 1/MAX_NUM
	// 这里令 score 的默认值为 0 表示无解状态 
	inline stu1(int x_ = 1, int64 score_ = 0) : x(x_), score(score_){};
	inline friend bool operator<(const stu1& a, const stu1& b){
		int64 tmp1 = a.score*b.x, tmp2 = b.score*a.x;
		// 如果有多解则输出选择的数最大的一组
		return (tmp1==tmp2 && a.x<b.x) || tmp1<tmp2;
	};
	inline void update(const stu1& other){ if(*this<other) *this = other; };
	inline bool valid()const{ return score>0; };
} A[(MAX_N+1)/2+1];
int max_set;                         // 最多标记连续端数，用于对 r 剪枝 
int Log2[(MAX_N+1)/2];               // 用于 O(1) ST 查询 
int dp[(MAX_N+1)/2+1][MAX_STSIZE+1]; // ST 表，存对应的 A[] 下标

// 并查集，注意初始状态为 fa[x]=0，表示 x 暂未被标记，不属于任何一个标记连续段
int fa[MAX_N+1], size[MAX_N+1];
int find_set(int x){ return fa[x]==x?x:fa[x]=find_set(fa[x]); }
inline void merge(int x, int y, int& set_cnt, int64& score){ // 注意引用 & 
	x = find_set(x);
	y = find_set(y);
	--set_cnt;
	score += 2ll*size[x]*size[y];
	size[y] += size[x]; // 只需要更新根的 size 
	fa[x] = y;
}
// B[i] = (i, Num[i]) 只存储 i 
int Num_map[MAX_N];
inline bool cmp_Num_map(int a, int b){
	return Num[a]<Num[b];
}
void init(){
	for(int i=1; i<=n; ++i) Num_map[i-1] = i;
	sort(Num_map, Num_map+n, cmp_Num_map);
	
	max_set = 0;
	int set_cnt = 0; // 标记连续段数 cnt(x)
	int64 score = 0; // 分数 score(x)
	for(int i=0, j=0; i<n; i=j){
		int x = Num[Num_map[i]];
		while(j<n && Num[Num_map[j]]==x) ++j; // 用双指针维护，统一处理所有相等值 
		for(int k=i; k<j; ++k){
			int id = Num_map[k];
			// 以自己的编号为集合的编号创建新集合 
			fa[id] = id;
			size[id] = 1;
			++set_cnt;
			++score;
			// 与左边的连续段合并
			// id-1>=1 可省略，因为 fa[0] 始终为 0 
			if(id-1>=1 && fa[id-1]) merge(id, id-1, set_cnt, score);
			// 与右边的连续段合并
			// 如果 fa[] 开到 1000002 也可省略 id+1<=n
			if(id+1<=n && fa[id+1]) merge(id, id+1, set_cnt, score);
		}
		max_set = max(max_set, set_cnt);
		A[set_cnt].update(stu1(x, score));
	}
	
	// Log2[] 最多用到 max_set-1 
	Log2[0] = Log2[1] = 0;
	for(int i=2; i<max_set; ++i) Log2[i] = Log2[i>>1]+1;
	
	for(int i=1; i<=max_set; ++i) dp[i][0] = i;
	int maxk = Log2[max_set-1];
	for(int k=1; k<=maxk; ++k){
		int maxi = max_set-(1<<k)+1;
		for(int i=1; i<=maxi; ++i){
			int l = dp[i][k-1], r = dp[i+(1<<(k-1))][k-1];
			dp[i][k] = (A[l]<A[r] ? r : l);
		}
	}
}

const stu1& query(int l, int r){
	r = min(r, max_set); // 对 r 剪枝 
	if(l>r) return A[0]; // 说明 l>max_set，无解，A[0] 表示一个无解状态
	
	// ST 查询
	int k = Log2[r-l];
	int a = dp[l][k], b = dp[r-(1<<k)+1][k];
	return A[a]<A[b] ? A[b] : A[a]; 
}

int main(){
	scanf("%d%d", &n, &T);
	for(int i=1; i<=n; ++i) scanf("%d", Num+i);
	init();
	
	int lastans = 0; // 实际上是 lastans%n，正确性由模运算性质保证 
	while(T--){
		int a, b, x, y;
		scanf("%d %d %d %d", &a, &b, &x, &y);
		int l = ((int64)a*lastans+x-1)%n+1;
		int r = ((int64)b*lastans+y-1)%n+1;
		if(l>r) swap(l, r);
		
		const stu1& ans = query(l, r);
		if(ans.valid()){
			printf("%lld %d\n%d %d %d\n", ans.score, ans.x, l, r, lastans);
			lastans = ans.score*ans.x % n;
		}else{
			printf("-1 -1\n%d %d %d\n", l, r, lastans);
			lastans = 1;
		}
	}
	return 0;
}

```

---

## 作者：lllyyykkk (赞：0)

## [题目传送门](https://www.luogu.com.cn/problem/P5012)
## 思路
这题的思路其它大佬都已经说得很清楚了，这里就简单重复一下。  
首先以 $O(n)$ 的时间复杂度预处理出每一个取值的得分，用 RMQ 维护块的个数对应的得分，之后 $O(1)$ 进行查询。

但是，这题很卡空间，所以接下来对空间进行优化。
## 空间优化
注意到维护的是块的个数，而块的个数的上限是 $\displaystyle \frac{n+1}{2}$，所以在 RMQ 数组上我们就可以省下一半的空间。

另外，本题不需要用到 `__int128`，只要在读入后对 $n$ 取模即可。

## 丑陋的压行代码
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=1e6+10;
int n,T;
int ans,lastans;
long long sum[N];
int st[N>>1][20];
vector<int>ve[N];
int len[N];
inline int maxx(int x,int y){
	if(!y) return x;
	if(sum[y]*x>sum[x]*y) return y;
	if(sum[x]*y>sum[y]*x) return x;
	return max(x,y);
}
inline void prepare(){
	int Max=0,cnt=0;
	long long v=0;
	for(int i=1,x;i<=n;i++) cin>>x,ve[x].push_back(i),Max=max(Max,x);
	for(int i=1;i<=Max;i++) if(ve[i].size()){
		for(auto j:ve[i]){
			if(!len[j-1]&&!len[j+1]) v++,cnt++,len[j]=1;
			else if(!len[j-1]&&len[j+1]) v+=2ll*len[j+1]+1,len[j]=len[j+len[j+1]]=len[j+1]+1;
			else if(len[j-1]&&!len[j+1]) v+=2ll*len[j-1]+1,len[j]=len[j-len[j-1]]=len[j-1]+1;
			else cnt--,v+=2ll*len[j-1]+2ll*len[j+1]+2ll*len[j-1]*len[j+1]+1,len[j-len[j-1]]=len[j+len[j+1]]=len[j-1]+len[j+1]+1;
		}
		sum[i]=v;
		st[cnt][0]=maxx(i,st[cnt][0]);
	}
	for(int j=1;j<=19;j++) for(int i=1;i+(1<<j)-1<=(n+1)/2;i++) st[i][j]=maxx(st[i][j-1],st[i+(1<<(j-1))][j-1]);
}
inline int get(int l,int r){
	if(l>(n+1)/2) return 0;
	if(r>(n+1)/2) r=(n+1)/2;
	int p=log2(r-l+1);
	return maxx(st[l][p],st[r-(1<<p)+1][p]);
}
signed main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>n>>T;
	prepare();
	while(T--){
		int a,b,x,y,l,r;cin>>a>>b>>x>>y;
		l=(1ll*a%n*lastans%n+x%n-1+2*n)%n+1;
		r=(1ll*b%n*lastans%n+y%n-1+2*n)%n+1;
		if(l>r) swap(l,r);
		ans=get(l,r);
		!ans?cout <<"-1 -1\n":cout <<sum[ans]<<' '<<ans<<'\n';
		cout <<l<<' '<<r<<' '<<lastans<<'\n';
		lastans=!ans?1:1ll*sum[ans]%n*ans%n;
	}
	return 0;
}
``````
最后，以 $92.35MB$ 的空间通过了此题。  
[AC record](https://www.luogu.com.cn/record/197927600)

---

## 作者：poembelief (赞：0)

# 题面
[传送门](https://www.luogu.com.cn/problem/P5012)
# 分析
拿到这题后，你会发现这题对于询问要求强制在线，但是询问的对象是不发生改变的，所以我们可以从这个长度为 $N$ 的序列着手。

通过分析输出内容可以发现，数字越大原始答案越大，所以可以将 $num$ 数组排序后 $O(n)$ 地跑出所有 $x$ 对应的原始答案，也就得到了每个 $x$ 对应的真实答案（**真实答案不是整型，所以在比较真实答案大小的时候最好使用乘法而不是除法！！！**）。

对于所有 $num_i\leq x$，我们可以先把 $[i,i]$ 当成单独的一个区间来统计答案信息，然后再左右判断是否可以合并，合并时对答案信息的维护是显然的。

本题给的询问限制是区间个数，所以我们自然而然想到了在每个区间个数中找到最大的真实答案对应的信息，然后就是 RMQ 问题了，使用 st 表解决。

**注意平方的时候会爆 int ，所以得开 long long ，而 st 表开 long long 有可能会爆，所以可以保存所有 $x$ 对应的答案信息然后再跑，具体实现可看代码。**

# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
/*
	需要先把所有x的答案保存下来，然后查询的时候跑st表即可 
	t1:长度平方和 
	t2:区间数量 
*/
const int N=1e6+5;
int n,q,a,b,x,y,pos[N][23],t2,lg[N],f[N],sz[N],mx;
long long t1,ans,sum[N];
bool ins[N];
struct node{
	int x,id;
}num[N];
bool cmp(node a,node b){
	return a.x<b.x;
}
int fd(int x){
	return x==f[x]?x:f[x]=fd(f[x]);
}
bool check(int x,int y,int k){
	if(pos[x][k]==0) return 0;
	if(pos[y][k]==0) return 1;
	return 1ll*sum[pos[x][k]]*pos[y][k]>1ll*sum[pos[y][k]]*pos[x][k];
}
int main(){
//	freopen(".in","r",stdin);
//	freopen("tx.out","w",stdout);
//	freopen("tx.in","r",stdin);
	scanf("%d%d",&n,&q);
	for(int i=1;i<=n;i++){
		scanf("%d",&num[i].x);
		num[i].id=i;
		mx=max(mx,num[i].x);
	}
	sort(num+1,num+1+n,cmp);
	int now=1;
	for(int i=1;i<=mx;i++){
		while(now<=n&&num[now].x<=i){
			int x=num[now].id;
			t1++,t2++;ins[x]=1;f[x]=x;sz[x]=1;
			if(ins[x-1]){
				int v=fd(x-1);
				t1-=1ll*sz[v]*sz[v]+1ll*sz[x]*sz[x];
				sz[v]+=sz[x];
				t1+=1ll*sz[v]*sz[v];
				f[x]=v;
				t2--;
			}
			if(ins[x+1]){
				int v=fd(x+1);
				x=fd(x);
				t1-=1ll*sz[v]*sz[v]+1ll*sz[x]*sz[x];
				sz[v]+=sz[x];
				t1+=1ll*sz[v]*sz[v];
				f[x]=v;
				t2--;
			}
			now++;
		}
		sum[i]=t1;
		if(sum[pos[t2][0]]*i<=t1*pos[t2][0]){
			pos[t2][0]=i;
		}
	}
	for(int i=1;i<=22;i++){
		for(int j=1;j+(1<<(i-1))<=n;j++){
			if(check(j,j+(1<<(i-1)),i-1)){
				pos[j][i]=pos[j][i-1];
			}
			else{
				pos[j][i]=pos[j+(1<<(i-1))][i-1];
			}
		}
	}
	for(int i=2;i<=n;i++) lg[i]=lg[i>>1]+1;
	for(int i=1;i<=q;i++){
		scanf("%d%d%d%d",&a,&b,&x,&y);
		a%=n,b%=n,x%=n,y%=n;
		int l=(1ll*a*ans%n+x+n-1)%n+1;
		int r=(1ll*b*ans%n+y+n-1)%n+1;
		if(l>r) swap(l,r);
		int k=lg[r-l+1];
		long long tmp,x;
		if(check(l,r-(1<<k)+1,k)){
			tmp=sum[pos[l][k]];
			x=pos[l][k];
		}
		else{
			tmp=sum[pos[r-(1<<k)+1][k]];
			x=pos[r-(1<<k)+1][k];
		}
		if(tmp==0){
			printf("-1 -1\n");
			printf("%d %d %lld\n",l,r,ans);
			ans=1;
		}
		else{
			printf("%lld %lld\n",tmp,x);
			printf("%d %d %lld\n",l,r,ans);
			ans=1ll*tmp%n*x%n;
		}
	}
	return 0;
}
```

---

## 作者：_HiKou_ (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P5012)

首先，题目没有修改操作！所以爽爽预处理！

因为 $ans=\dfrac{sum}{x}$，在平方和 $sum$ 一定时，也就是分块策略一定时，$x$ 应为最小值。

所以可以用暴力法模拟每一种情况。操作是把原数组排序去重得到等待处理的所有 $x_i$，因为 $x$ 序列单调递增，可以保证每次都是往里面加数而不会出现删除操作。

这里我用了并查集来识别块，具体做法是：

- 设加入的数位置位于 $i$。
- 每个块的长度存于每个块的第一个数的位置，用 $d$ 数组存储。
- 当 $i-1$ 位置有数（$f_{i-1}\ne0$），代表现在的数和前方存在的块联通，那么将 $f_i$ 赋值为这个块的块头。长度 $+1$，更新答案。
- 当 $i+1$ 位置有数（$f_{i+1}\ne0$），代表现在的数所在的块和后方存在的块联通（注意！这里的数有可能已经和前面的块联通了，所以块头不一定是它本身），那么将 $d_{i+1}$ 的值加到 $d_{f[i]}$ 上，更新答案，将 $f_{i+1}$ 赋值为合并块的块头。（$f_{i+1}$ 一定是另一个块的块头，所以直接将它指向合并块的块头就行）
- 若前后都没有联通的块，块数 $+1$。
- 若前后都有联通的块，块数 $-1$。

这样子就处理出了对于可能的 $x_i$ 对应的 $sum$（因为后面需要输出原始答案所以这里存的是平方和）和块数 $k$。

接下来对 $k$ 去重，对于每个 $k$ 取 ans 最大的一组数，ans 相同取 $x$ 大的（$x$ 一定互不相同）。

注意！！一定要把比较大小的除法写成乘法！不然可能会出现 RE 或 WA 的惨烈结果！

然后处理完，现在要求的是......区间最大值！所以拿出喜闻乐见的线段树（不是），而且不用写修改操作也！太好了！

但是出题人空间卡的很紧，所以建线段树要注意！块的数量 $num_k\leq \left\lceil\dfrac{n}{2}\right\rceil$！所以空间就可以卡过了！

以及......算出的 $l$ 和 $r$ 会爆 long long，所以在计算之前，要先将所有的输入数据 $\bmod$ $n$。而且在 int 范围内代表也有可能是负数，所以算出的结果要 $+n$ 然后 $\bmod$ $n$。

代码：

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll n,t;
ll a[1000001];
ll lastans=0;
ll x[1000001],xcnt,d[1000001],f[1000001];//xcnt 表示 x 的数量
ll Find(ll x){
	if(x==f[x])return x;
	return f[x]=Find(f[x]);
}//并查集查找祖先操作
struct qwq{
	ll v,id;//值和位置
	bool operator <(qwq a){
		return v<a.v;
	}
}q[1000001];

struct awa{
	ll nx,k,ans;//每组数的 x，块数，答案
	bool operator <(awa a){
		return k<a.k;
	}
}p[514514],fin[514514];//去重前和去重后的数组组
ll fn;//最大块数
awa amax(awa a,awa b){//结构体比较操作
	/*if(a.ans/a.nx>b.ans/b.nx)return a;
	if(a.ans/a.nx<b.ans/b.nx)return b;
	if(a.nx>b.nx)return a;
	return b;*/
	if(a.ans*b.nx>b.ans*a.nx)return a;
	if(a.ans*b.nx<b.ans*a.nx)return b;
	if(a.nx>b.nx)return a;
	return b;
}


awa ma[514514*4];//最大值 线段树四倍空间
void build(ll p,ll l,ll r){
	if(l==r){
		ma[p]=fin[l];
		return ;
	}
	if(l>r)return ;
	ll mid=(l+r)>>1;
	if(l<=mid)build(p*2,l,mid);
	if(r>mid)build(p*2+1,mid+1,r);
	ma[p]=amax(ma[p*2+1],ma[p*2]);
}
awa query(ll p,ll l,ll r,ll wl,ll wr){
	if(l>=wl&&r<=wr){
		return ma[p];
	}
	awa aaa={0,0,0};//如果比较操作是除法那么会报错
	if(r<wl||l>wr)return aaa;
	if(l>r)return aaa;
	ll mid=(l+r)>>1;
	if(wl<=mid)aaa=amax(aaa,query(p*2,l,mid,wl,wr));
	if(wr>mid)aaa=amax(aaa,query(p*2+1,mid+1,r,wl,wr));
	return aaa;
}

int main(){
	scanf("%lld%lld",&n,&t);
	for(ll i=1;i<=n;i++)scanf("%lld",&a[i]),q[i].v=a[i],q[i].id=i;
	sort(q+1,q+1+n);
      for(ll i=1;i<=n;i++)if(q[i].v!=q[i-1].v)x[++xcnt]=q[i].v;//去重找 x
	ll now=1,nk=0,nowans=0;//现在处理到哪个数 现在块数 现在的答案（原始分数）
	for(ll i=1;i<=xcnt;i++){
		while(q[now].v<=x[i]&&now<=n){//防止一样的数只处理一个
			ll o=q[now].id;
			f[o]=o;
			
			if(f[o-1]&&f[o+1])nk--;
			if(f[o-1]==0&&f[o+1]==0)nk++;
			
			if(f[o-1]){
				f[o]=Find(f[o-1]);
			}
			nowans-=d[f[o]]*d[f[o]];
			d[f[o]]++;
			nowans+=d[f[o]]*d[f[o]];
			if(f[o+1]){
				nowans-=d[f[o]]*d[f[o]];
				nowans-=d[f[o+1]]*d[f[o+1]];
				d[f[o]]+=d[f[o+1]];
				nowans+=d[f[o]]*d[f[o]];
				d[f[o+1]]=0;
				f[o+1]=Find(f[o]);
			}
			now++;
		}
			p[i].nx=x[i];
			p[i].ans=nowans;
			p[i].k=nk;
	}
	for(ll i=1;i<=xcnt;i++){
		fin[p[i].k]=amax(fin[p[i].k],p[i]);
		fn=max(fn,p[i].k);
	}
	
	build(1,1,fn);//建树
	
	ll t1,t2,t3,t4;
	while(t--){
		scanf("%lld%lld%lld%lld",&t1,&t2,&t3,&t4);
		ll l,r;
		t1%=n;t2%=n;t3%=n;t4%=n;//先模
		l=((t1*lastans+t3-1)%n+n)%n+1;
		r=((t2*lastans+t4-1)%n+n)%n+1;
		if(l>r)swap(l,r);
		
		if(l>fn){//无解
			printf("-1 -1\n");
			printf("%lld %lld %lld\n",l,r,lastans%n);
			lastans=1;
			continue;
		}
		
		awa fans=query(1,1,fn,l,min(r,fn));//查找
		if(fans.k==0&&fans.nx==0&&fans.ans==0){//无解
			printf("-1 -1\n");
			printf("%lld %lld %lld\n",l,r,lastans%n);
			lastans=1;
			continue;
		}
		
		printf("%lld %lld\n",fans.ans,fans.nx);
		printf("%lld %lld %lld\n",l,r,lastans%n);
		lastans=(fans.ans%n)*(fans.nx%n);//避免爆炸
		lastans%=n;
	}
	return 0;
}
```

---

## 作者：0zhouyq (赞：0)

[传送门](https://www.luogu.com.cn/problem/P5012)

### 思路：

因为没有修改操作，可以先将选所有数的区间个数和连续标记的区间的长度的平方和之和。显然只有选数列中的数才有可能成为最优解，这里按从小到大的顺序枚举。可以使用并查集维护每一块的长度的平方和以及块数。以块数为关键字存到数组中。下面就是区间最大值问题。

将每 $\sqrt n$ 个点分为一块。提前处理出每一块的最大值。询问的时候，先按块直接枚举，剩余的点再单独枚举，取最大值就好。

### AC code:

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
ll n,t,a[1000001],f[1000001],s[1000001],siz[1000001],ans,ksh=0;
//a：原数组，f、siz：并查集的父亲和大小，s:排序用，ksh：块数，ans：选择当前的数的答案
pair<ll,ll> m[1000101],k[53000];
//m:单点的答案，k:整块的答案
bool cmp(ll x,ll y){
	return a[x]<a[y];
}
ll found(ll x){
	return x==f[x]?x:(f[x]=found(f[x]));
}
void add(ll x,ll y){
	x=found(x);
	y=found(y);
	if(x!=y){
		ksh--;
		ans+=2*siz[x]*siz[y];
		f[y]=x;
		siz[x]+=siz[y];
	}
}
bool check(pair<ll,ll> x,pair<ll,ll> y){//判断y是否比x更优
	if(x.second*y.first>=x.first*y.second){
		if(x.second*y.first==x.first*y.second) return y.second>x.second;
		return true;
	}
	return false;
}
int main(){
	scanf("%lld %lld",&n,&t);
	for(ll i=1;i<=n;i++) m[i].second=1;//初始化
	for(ll i=1;i<=52999;i++) k[i].second=1;
	for(ll i=1;i<=n;i++){
		scanf("%lld",&a[i]);
		s[i]=i;
	}
	sort(s+1,s+n+1,cmp);//排序
	ll cnt=1;
	while(cnt<=n){//枚举选的数
		ll cc=cnt;
		ll sta=a[s[cnt]];
		while(a[s[cnt]]==sta){
			f[s[cnt]]=s[cnt];
			siz[s[cnt]]=1;
			ans++;
			ksh++;
			if(f[s[cnt]-1]!=0&&s[cnt]>1) add(s[cnt]-1,s[cnt]);
			if(f[s[cnt]+1]!=0&&s[cnt]<n) add(s[cnt],s[cnt]+1);
			cnt++;
		}
		if(check(m[ksh],make_pair(ans,sta))){
			m[ksh].first=ans;
			m[ksh].second=sta;
		}
	}
	ll p=sqrt(double(n));
	ll ks=((p*(n/p)==n)?(n/p):(n/p+1));
	for(ll pt=1;pt<=ks;pt++){//处理整块
		for(ll j=(pt-1)*p+1;j<=pt*p&&j<=n;j++){
			if(check(k[pt],m[j])){
				k[pt]=m[j];
			}
		}
	}
	ll aa,b,x,y,l,r,lans=0;
	while(t--){
		scanf("%lld %lld %lld %lld",&aa,&b,&x,&y);
		l=(aa*lans+x-1)%n+1;
		r=(b*lans+y-1)%n+1;
		if(l>r) swap(l,r);
		ll tot=l,tot2=r;
		pair<ll,ll> anss=make_pair(0,1);
		while((tot-1)%p!=0&&tot<=n){
			if(check(anss,m[tot])) anss=m[tot];
			tot++;
		}
		while(tot2%p!=0&&tot2>=tot){
			if(check(anss,m[tot2])) anss=m[tot2];
			tot2--;
		}
		ll lft=(tot-1)/p+1,rgh=tot2/p;
		for(ll i=lft;i<=rgh;i++) if(check(anss,k[i])) anss=k[i];
		if(anss.first!=0){
			printf("%lld %lld\n%lld %lld %lld\n",anss.first,anss.second,l,r,lans%n);
			lans=anss.first*anss.second%n;
		}
		else{
			printf("-1 -1\n%lld %lld %lld\n",l,r,lans%n);
			lans=1;
		}
	}
	return 0;
}
```

---

## 作者：kkxacj (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P5012)

#### 前言

虽然此题卡空间但不知为何我用线段树过了，甚至[这也能过（线段树大小为二）](https://www.luogu.com.cn/record/146071622)。

#### 思路
我们肯定不会对每次操作都重新算一次，这样太费时间，可以考虑提前预处理当$x$ 为 $a_i$ 时的贡献存一下，如果要快速处理答案可以考虑存储每个数的位置和值，然后按值排序，因为当 $x \le y$ 时，且 $i \le x$，那么 $i \le y$，所以每次就判断一下左右是否有一个块，有的话就连一下，重新计算一下贡献，否则就新建一个，注意可能会有多个相同的数，要全部处理完在算贡献。

算完后在用线段树维护一下区间最大值，每次查询也就是求 $l$ 到 $r$ 的最大值，直接算就行了。

**小技巧：在处理最大值的时候可以考虑用通分的方法，这样就不用担心精度丢失了**

代码使用了 `int128`，不然本代码会 `RE`。

**code**

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int __int128
int n,t,a,b,x,y,fans,tt,v[1000010],sum,siz[1000010],cnt,bj[1000010],bj1[1000010],f[1000010],l,r,ma,ma1,oo;
int find(int x)
{
	if(f[x] == x) return x;
	return f[x] = find(f[x]);
}
struct w
{
	int z,id;
}d[1000100];
bool cmp(w xx,w yy)
{
	return xx.z < yy.z;
}
struct w1
{
	int ma,cs;
}c[1000010];
inline void build(int p,int l,int r)
{
	if(l == r) 
	{
		c[p].ma = bj[l],c[p].cs = bj1[l];
		return;
	}
	int mid = (l + r) / 2;
	build(p * 2,l,mid); build(p * 2 + 1,mid + 1,r);
	if(!c[p * 2].ma) c[p].ma = c[p * 2 + 1].ma,c[p].cs = c[p * 2 + 1].cs;
	else if(!c[p * 2 + 1].ma) c[p].ma = c[p * 2].ma,c[p].cs = c[p * 2].cs;
	else
	{
		if(c[p * 2].ma * c[p * 2 + 1].cs > c[p * 2 + 1].ma * c[p * 2].cs) c[p].ma = c[p * 2].ma,c[p].cs = c[p * 2].cs;
		else c[p].ma = c[p * 2 + 1].ma,c[p].cs = c[p * 2 + 1].cs;	
	}
}
inline void ask(int p,int l,int r,int fl,int fr)
{
//	cout<<p<<" " << c[p].l<<" "<<c[p].r<<" "<<l<<" "<<r<<" "<<c[p].ma<<" "<<c[p].cs<<" "<<ma<<" "<<ma1<<endl;
	if(l <= fl && fr <= r)
	{
		if(c[p].ma * ma1 > ma * c[p].cs || (ma == 0 && ma1 == 0)) ma = c[p].ma,ma1 = c[p].cs;
		return;
	}
	int mid = (fl + fr) / 2;
	if(l <= mid) ask(p * 2,l,r,fl,mid);
	if(mid < r) ask(p * 2 + 1,l,r,mid + 1,fr);
}
inline void read(int &x){
	x=0;int f=1;char c=getchar();
	while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
	while(isdigit(c)) x=(x<<1)+(x<<3)+c-48,c=getchar();
	x*=f;
}
inline void write(int x)
{
	if(x<0){putchar('-');write(-x);return;}
	if(x>=10)write(x/10);
	putchar(x%10+48);
}
signed main()
{
	read(n),read(t);
	for(int i = 1;i <= n;i++) read(tt),d[i].z = tt,d[i].id = i,f[i] = i;
	sort(d + 1,d + 1 + n,cmp);
	for(int i = 1;i <= n;i++)
	{
		if(d[i].z != oo) 
		{
			if(i != 1 && ((!bj[cnt] && !bj1[cnt]) || bj[cnt] * oo < sum * bj1[cnt])) bj[cnt] = sum,bj1[cnt] = oo;
			oo = d[i].z;
		}
		if(v[d[i].id - 1] && v[d[i].id + 1]) 
		{
			sum -= siz[find(d[i].id - 1)] * siz[find(d[i].id - 1)];
			sum -= siz[find(d[i].id + 1)] * siz[find(d[i].id + 1)];
			siz[find(d[i].id)] += siz[find(d[i].id + 1)] + siz[find(d[i].id - 1)] + 1; 
			f[find(d[i].id + 1)] = f[find(d[i].id - 1)] = find(d[i].id);
			sum += siz[find(d[i].id)] * siz[find(d[i].id)];
			cnt--;
		}
		else if(v[find(d[i].id - 1)]) 
		{
			sum -= siz[find(d[i].id - 1)] * siz[find(d[i].id - 1)];
			siz[find(d[i].id)] += siz[find(d[i].id - 1)] + 1;
			f[find(d[i].id - 1)] = find(d[i].id);
			sum += siz[find(d[i].id)] * siz[find(d[i].id)];
		}
		else if(v[find(d[i].id + 1)])
		{
			sum -= siz[find(d[i].id + 1)] * siz[find(d[i].id + 1)];
			siz[find(d[i].id)] += 1 + siz[find(d[i].id + 1)];
			f[find(d[i].id + 1)] = find(d[i].id);
			sum += siz[find(d[i].id)] * siz[find(d[i].id)];
		}
		else siz[d[i].id] = 1,sum++,++cnt;
		v[d[i].id] = 1;
	}
	if(((!bj[cnt] && !bj1[cnt]) || bj[cnt] * oo < sum * bj1[cnt])) bj[cnt] = sum,bj1[cnt] = oo;
	build(1,1,n);
	while(t--)
	{
		read(a),read(b),read(x),read(y); 
		ma = ma1 = 0;
		l = (a * fans + x - 1) % n + 1;
		r = (b * fans + y - 1) % n + 1;
		if(l > r) swap(l,r); 
		ask(1,l,r,1,n);
		if(ma == 0) ma = ma1 = -1;
		write(ma),printf(" "),write(ma1),puts("");
		write(l),printf(" "),write(r),printf(" "),write(fans % n),printf(" "),puts("");
		if(ma == -1) fans = 1;
		else fans = ma * ma1;
	}
	return 0;
}
```


---


# [SCOI2015] 小凸解密码

## 题目描述

小凸得到了一个密码盘，密码盘被等分成 $n$ 个扇形，每个扇形上有一个数字 $(0 \sim 9)$，和一个符号 $($ `+` 或 `*` $)$。密码盘解密的方法如下：

首先，选择一个位置开始，顺时针地将数字和符号分别记在数组 $A$ 和数组 $C$ 中。解密的方法如下：

- $B_0 = A_0$
- 当 $x > 0$ 时：
  - 若 $C_x$ 为 `+`，$B_x = (A_x + A_{x - 1}) \% 10$
  - 若 $C_x$ 为 `*`，$B_x = (A_x \times A_{x - 1}) \% 10$

操作完成后，可以得到一个长度为 $n$ 的数组 $B$，然后以 $B_0$ 为起点将 $B$ 数组顺时针写成一个环，解密就完成了，称得到的环为答案环。

现在小凸得到了一份指令表，指令表上有 2 种操作。一种指令是修改操作，即改变原来密码盘上一个位置的数字和符号。另一种指令是询问操作，具体如下：

- 首先从指令给出的位置开始完成解密，得到答案环。
- 答案环上会有一些 $0$ 连在一起，将这些连在一起的 $0$ 称为零区间，找出其中距离 $B_0$ 最远的那个零区间，输出这个距离（零区间和 $B_0$ 的距离定义为：零区间内所有 $0$ 到 $B_0$ 距离中的最小值）。

## 说明/提示

**样例解释：**

对于第 $1$ 个询问，答案环为 $\{0, 0, 0, 0, 0\}$，仅有 $1$ 个零区间，且 $B_0$ 在其中，所以距离是 $0$。  
对于第 $2$ 个询问，答案环为 $\{0, 0, 1, 0, 1\}$，有 $2$ 个零区间，$[0, 1]$ 和 $B_0$ 距离是 $0$，$[3, 3]$ 和 $B_0$ 距离是 $2$，故答案为 $2$。  
对于第 $3$ 个询问，答案环为 $\{1, 2, 2, 2, 2\}$，没有零区间，答案是 `−1`。

**数据范围：**

对于 $20 \%$ 数据，$5 \leq n \leq 10^5, 5 \leq m \leq 1000$；  
对于 $60 \%$ 数据，$5 \leq n \leq 10^5, 5 \leq m \leq 10^4$；  
对于 $100 \%$ 数据，$5 \leq n, m \leq 10^5$。


## 样例 #1

### 输入

```
5 8
0 *
0 *
0 *
0 *
0 *
2 0
1 0 1 +
1 2 1 +
2 3
1 1 1 +
1 3 1 +
1 4 1 +
2 4
```

### 输出

```
0
2
-1
```

# 题解

## 作者：AutumnKite (赞：11)

看起来楼上那个代码有点(?)长...尝试补一个，顺便加点社区贡献，给 CSP2019 攒点 RP。

倍长以后直接用线段树维护 $B$，发现每次修改只会修改最多四个 $B_i$，可以直接单点修改。

对于询问，显然可以二分答案 $md$，那么显然需要满足 $[x+md-1,n+x-md+1]$ 这段区间中存在被大于 $0$ 的数包围的全 $0$ 子段。

也就是说，我们需要求区间中被大于 $0$ 的数包围的子段数量。

基础线段树练习题。

注意特判答案为 $0$ 的情况，即 $A_x=0$ 且 $[x+1,n+x-1]$ 中没有符合条件的子段。然后 $md$ 就可以在 $[1,n/2]$ 的范围内二分了。

而答案为 $-1$ 的情况就是 $md$ 在这个范围内取任意值都不合法。当然你想特判也行。

时间复杂度 $O(q\log^2n)$。

```cpp
#include <cstdio>
#include <cctype>
#include <algorithm>
#include <cstring>
int read(){
	register int x = 0;
	register char f = 1, ch = getchar();
	for (; !isdigit(ch); ch = getchar()) if (ch == '-') f = !f;
	for (; isdigit(ch); ch = getchar()) x = (x << 3) + (x << 1) + (ch ^ '0');
	return f ? x : -x;
}
void print(int x, char ch = '\n'){
	if (x == 0) return putchar('0'), putchar(ch), void(0);
	int cnt = 0, num[25];
	for (x < 0 ? putchar('-'), x = -x : 0; x; x /= 10) num[++cnt] = x % 10;
	while (cnt) putchar(num[cnt] ^ '0'), --cnt;
	putchar(ch);
}
const int N = 200005;
char s[5];
int n, q, a[N], c[N];
namespace segt{
	struct node{
		int c, l, r, s; // c 是区间中 >0 的数量，l,r表示区间左右的数，s表示满足条件的全 0 子段数量
		void init(int v){
			s = 0;
			if (v) c = l = r = 1;
			else c = l = r = 0;
		}
	}a[N << 2];
	node operator + (const node &a, const node &b){
		node c;
		c.c = a.c + b.c, c.l = a.l, c.r = b.r;
		c.s = a.s + b.s;
		if (a.c && b.c && (!a.r || !b.l)) ++c.s;
		return c;
	}
	void modify(int u, int l, int r, int x, int v){
		if (l == r) return a[u].init(v), void(0);
		int md = (l + r) >> 1;
		if (x <= md) modify(u << 1, l, md, x, v);
		else modify(u << 1 | 1, md + 1, r, x, v);
		a[u] = a[u << 1] + a[u << 1 | 1];
	}
	node query(int u, int l, int r, int L, int R){
		if (L <= l && r <= R) return a[u];
		int md = (l + r) >> 1;
		if (R <= md) return query(u << 1, l, md, L, R);
		else if (L > md) return query(u << 1 | 1, md + 1, r, L, R);
		else return query(u << 1, l, md, L, R) + query(u << 1 | 1, md + 1, r, L, R);
	}
}
int calc(int i){ return c[i] ? a[i] * a[i - 1] % 10 : (a[i] + a[i - 1]) % 10; } // 计算 B 的值
int main(){
	n = read(), q = read();
	for (register int i = 1; i <= n; ++i){
		a[i] = read(), scanf("%s", s), c[i] = s[0] == '*';
		a[n + i] = a[i], c[n + i] = c[i];
	}
	for (register int i = 2; i <= (n << 1); ++i)
		segt :: modify(1, 1, n << 1, i, calc(i));
	while (q--){
		int op = read(), x = read() + 1;
		if (op == 1){
			a[x] = read(), scanf("%s", s), c[x] = s[0] == '*';
			a[n + x] = a[x], c[n + x] = c[x];
			if (x > 1) segt :: modify(1, 1, n << 1, x, calc(x));
			segt :: modify(1, 1, n << 1, x + 1, calc(x + 1));
			segt :: modify(1, 1, n << 1, n + x, calc(n + x));
			if (x < n) segt :: modify(1, 1, n << 1, n + x + 1, calc(n + x + 1));
			// 修改四个点的 B[i]
		}
		else{
			if (!a[x] && segt :: query(1, 1, n << 1, x + 1, n + x - 1).s == 0){ puts("0"); continue; } // 特判答案为 0 的情况
			segt :: modify(1, 1, n << 1, x, a[x]);
			segt :: modify(1, 1, n << 1, n + x, a[x]);
			// 特别处理端点的 B[i]
			int l = 0, r = n >> 1, md, ans = -2;
			while (l <= r)
				if (md = (l + r) >> 1, segt :: query(1, 1, n << 1, x + md, n + x - md).s) ans = md, l = md + 1;
				else r = md - 1;
			++ans; // 二分的其实是全 0 段两边的数到端点的距离，所以加 1
			print(ans);
			if (x > 1) segt :: modify(1, 1, n << 1, x, calc(x));
			segt :: modify(1, 1, n << 1, n + x, calc(n + x));
		}
	}
}
```

---

## 作者：劉子颺 (赞：2)

没有思维难度的一篇毒瘤但不失精致的题解

考虑只有0的区间有用 思考一下用set维护全0的一个转盘

那么需要支持区间单点分裂和合并

那么注意维护一下环的情况

实际上全0串很自闭

注意特判掉 还有一个串的也是

然后rush一下就好了 （写了4个小时GG）实际上2个小时就有80分了2333

边界注意一下

```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<set>
using namespace std;
inline void read(int &x){
	x=0;
	int f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-')f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9'){
		x=x*10+ch-'0';
		ch=getchar();
	} 
	x*=f;
}
const int N=1e5+100;
set<pair<int,int> >S;
typedef set<pair<int,int> >::iterator Iterator;
void Debug();
int A[N];
int B[N];
int C[N];
int n,m;
bool Cross=0;
void Split(int pos){
	if(!S.size())return;
	if(Cross){
		Iterator It=S.end();
		It--;
		pair<int,int>Line=(*It);
		if(pos<=Line.second||pos>=Line.first){
			
			if(pos==n-1){
				Cross=0;
				S.erase(It);
				if(Line.second+1!=Line.first){
					S.insert(make_pair(0,Line.second));
					if(Line.first<n-1)S.insert(make_pair(Line.first,n-2));					
				}
				else{
					S.insert(make_pair(0,n-2));
				}
			}
			else{
				if(pos==0){
					Cross=0;
					S.erase(It);
					if(Line.second+1!=Line.first){
						if(Line.second>0)S.insert(make_pair(1,Line.second));
						S.insert(make_pair(Line.first,n-1));						
					}
					else{
						S.insert(make_pair(1,n-1));
					}
				}
				else{
					if(pos>=Line.first){
						if(Line.second+1==Line.first){
							S.insert(make_pair(pos+1,pos-1));
						}
						else{
							if(pos>Line.first)S.insert(make_pair(Line.first,pos-1));
							S.insert(make_pair(pos+1,Line.second));							
						}
					}
					else{
						if(Line.second+1==Line.first){
							S.insert(make_pair(pos+1,pos-1));
						}
						else{
							S.insert(make_pair(Line.first,pos-1));
							if(pos<Line.second)S.insert(make_pair(pos+1,Line.second));							
						}
					}
				}
			}
			return;
		}	
	}
	pair<int,int>now=make_pair(pos,n);
	Iterator It=S.lower_bound(now);
	if(It==S.begin())return;
	It--;
	pair<int,int>Line=(*It);
	if(Line.first<=pos&&pos<=Line.second){
		S.erase(It);
		if(Line.first<pos)S.insert(make_pair(Line.first,pos-1));
		if(Line.second>pos)S.insert(make_pair(pos+1,Line.second));		
	}
}
void Insert(int pos){
	Iterator It=S.insert(make_pair(pos,pos)).first;
	if(Cross){
		
		Iterator Suc=It;
		Suc++;

		if(Suc!=S.end()){
			pair<int,int> now=(*Suc);		
			if(pos+1==now.first){
				S.erase(Suc);
				S.erase(It);
				It=S.insert(make_pair(pos,now.second)).first;
			}
			else{
				if(pos+1==now.second+1){
					S.erase(Suc);
					S.erase(It);
					It=S.insert(make_pair(now.first,pos)).first;					
				}
			}
		}
		if(It!=S.begin()){
			Iterator Pre=It;
			Pre--;
			pair<int,int> now=(*Pre);
			pair<int,int> Ins=(*It);
			if(now.second==pos-1){
				S.erase(Pre);
				S.erase(It);
				It=S.insert(make_pair(now.first,Ins.second)).first;
			}
			else{
				if(now.first-1==pos){
					S.erase(Pre);
					S.erase(It);
					It=S.insert(make_pair(Ins.first,now.second)).first;					
				}
			}
		}
	}
	else{
		if(pos==0){
			Iterator Pre=S.end();
			Pre--;
			pair<int,int> now=(*Pre);	
			if(now.second==n-1){
				Cross=1;
				S.erase(Pre);
				S.erase(It);
				It=S.insert(make_pair(now.first,pos)).first;
			}
			pair<int,int> Ins=(*It);
			Iterator Suc=It;
			Suc++;
			if(Suc!=S.end()){
				now=(*Suc);
				if(now.first==pos+1){
					S.erase(Suc);
					S.erase(It);
					It=S.insert(make_pair(Ins.first,now.second)).first;
				}
			}
			else{
				Suc=S.begin();
				now=(*Suc);
				if(now.first==pos+1){
					S.erase(Suc);
					S.erase(It);
					It=S.insert(make_pair(Ins.first,now.second)).first;
				}				
			}
		}
		else{
			if(pos==n-1){
				Iterator Suc=S.begin();
				pair<int,int> now=(*Suc);
				if(now.first==0){
					Cross=1;
					S.erase(Suc);
					S.erase(It);
					It=S.insert(make_pair(pos,now.second)).first;
				}
				pair<int,int> Ins=(*It);
				Iterator Pre=It;
				if(Pre!=S.begin()){
					Pre--;
					now=(*Pre);
					if(now.second==pos-1){
						S.erase(Pre);
						S.erase(It);
						It=S.insert(make_pair(now.first,Ins.second)).first;
					}
				}
			}
			else{
				Iterator Suc=It;
				++Suc;
				if(Suc!=S.end()){
					pair<int,int> now=(*Suc);
					if(pos+1==now.first){
						S.erase(Suc);
						S.erase(It);
						It=S.insert(make_pair(pos,now.second)).first;
					}
				}
				if(It!=S.begin()){
					Iterator Pre=It;
					Pre--;
					pair<int,int> now=(*Pre);
					pair<int,int> Ins=(*It);
					if(now.second==pos-1){
						S.erase(Pre);
						S.erase(It);
						It=S.insert(make_pair(now.first,Ins.second)).first;
					}
				}				
			}
		}
	}
}
int Cnt=0;
bool Check(int pos,int Len){
	if(pos-Len<0&&pos+Len>=n)return false;
	int R=pos+Len;
	Iterator It=S.lower_bound(make_pair(R,0));
	if(It!=S.end()){
		pair<int,int> now=(*It);
		if(now.first<=now.second){
			if(n+pos-now.second>=Len)return true;
		}
		else{
			int Mx=pos-now.second;
			if(Mx>=Len)return true;
		}
	}
	int L=pos-Len+1;
	It=S.lower_bound(make_pair(L,0));
	if(It!=S.begin()){
		It--;
		pair<int,int> now=(*It);
		if(now.second>=L){
			if(It==S.begin())return false;
			It--;
			now=(*It);
		}
		if(now.first<=now.second){
			if(n+now.first-pos>=Len)return true;
		}
		else{
			int Mx=now.first-pos;
			if(Mx>=Len)return true;
		}
	}
	return  false;
}
void Calc(int pos){
	if(!Cnt){
		cout<<-1<<'\n';
		return;
	}
	if(Cnt==n){
		cout<<0<<'\n';
		return;
	}
	if(S.size()==1){
		pair<int,int> now=(*S.begin());
		if(Cross){
			if(pos<=now.second||pos>=now.first){
				cout<<0<<'\n';
			}
			else{
				cout<<min(now.first-pos,pos-now.second)<<'\n';
			}
		}
		else{
			if(pos>=now.first&&pos<=now.second){
				cout<<0<<'\n';
			}
			else{
				cout<<min(abs(now.first-pos),abs(pos-now.second))<<'\n';
			}
		}
		return;
	}
	int L=1,R=n;
	int ans=0;
	while(L<=R){
		int mid=(L+R)>>1;
		if(Check(pos,mid)){
			ans=mid;
			L=mid+1;
		}
		else{
			R=mid-1;
		}
	}
	cout<<ans<<'\n';
}
void Debug(){
	Iterator It=S.begin();
	for(;It!=S.end();++It){
		Iterator Pre=It;
		--Pre;
		cout<<(*It).first<<" "<<(*It).second<<'\n';
		if((*Pre).second>(*It).first){
		}	
	}
	cout<<'\n';
}
int main(){
//	freopen("P5226.in","r",stdin);
//	freopen("P5226.out","w",stdout);
	read(n);read(m);
	for(int i=0;i<n;++i){
		char opt[3];
		read(A[i]);
		scanf("%s",opt+1);
		if(opt[1]=='+'){
			C[i]=1;
		}
		else{
			C[i]=0;
		}
	}
	for(int i=0;i<n;++i){
		if(C[i]==0){
			B[i]=A[i]*A[(n+i-1)%n]%10;
		}
		else{
			B[i]=(A[i]+A[(n+i-1)%n])%10;
		}
	}
	bool GG=0;
	for(int i=0;i<n;++i){
		if(B[i]!=0)GG=1;
		Cnt+=(B[i]==0);
	}
	if(!GG){
		S.insert(make_pair(0,n-1));
	}
	else{
		if(B[0]==0&&B[n-1]==0){
			int Pre=0;
			while(B[Pre+1]==0)Pre++;
			int Suc=n-1;
			while(B[Suc-1]==0)Suc--;
			S.insert(make_pair(Suc,Pre));
			for(int l=Pre+1,r;l<Suc;l=r+1){
				r=l;
				if(B[l]==0){
					while(B[r+1]==0&&r+1<n)r++;
					S.insert(make_pair(l,r));
				}
			}
			Cross=1;			
		}
		else{
			int Pre=0;
			int Suc=n;
			for(int l=Pre,r;l<Suc;l=r+1){
				r=l;
				if(B[l]==0){
					while(B[r+1]==0&&r+1<n)r++;
					S.insert(make_pair(l,r));
				}
			}		
		}
	}
	while(m--){
		int opt;
		read(opt);
		if(opt==1){
			int pos,num;
			char s[3];
			read(pos);read(num);
			scanf("%s",s+1);
			if(s[1]=='+'){
				C[pos]=1;
			}
			else{
				C[pos]=0;
			}
			A[pos]=num;
			
			int Suc=(pos+1)%n;
			if(!B[pos]){
				Cnt--;
				Split(pos);
			}
			if(C[pos]==1){
				B[pos]=(A[pos]+A[(n+pos-1)%n])%10;
			}
			else{
				B[pos]=A[pos]*A[(n+pos-1)%n]%10;
			}
			if(!B[pos])Insert(pos),Cnt++;
			if(!B[Suc]){
				Cnt--;
				Split(Suc);
			}
			if(C[Suc]==1){
				B[Suc]=(A[Suc]+A[(n+Suc-1)%n])%10;
			}
			else{
				B[Suc]=A[Suc]*A[(n+Suc-1)%n]%10;
			}
			if(!B[Suc])Insert(Suc),Cnt++;
		}
		else{
			int pos;
			read(pos);
			if(!B[pos])Split(pos),Cnt--;
			if(!A[pos])Insert(pos),Cnt++;
			Calc(pos);
			if(!A[pos])Split(pos),Cnt--;
			if(!B[pos])Insert(pos),Cnt++;
		}
	}
	return 0;
}
```


---

## 作者：Jeslan (赞：1)

## Solution to [P5226 [SCOI2015] 小凸解密码](https://www.luogu.com.cn/problem/P5226)

破环成链，将数组 $B$ 复制一遍，$[x, x+n-1]$ 对应从位置 $x$ 开始的数组 $B$。

$
[1, 2, 3, 4] \to [1, 2, 3, 4, 1, 2, 3, 4]
$

### 维护

用线段树维护数组 $B$ 的最左、次左、最右、次右零区间。注意到 $B_0$ 很特殊，可以在询问时临时修改，于是可以统一当做 $x > 0$ 的情况维护。

以维护最右、次右零区间为例，不妨设某节点维护的最右、次右零区间为 $\{t_1, t_2\}$，左右儿子的分别为 $\{l_1, l_2\}$ 和 $\{r_1, r_2\}$，考虑更新该节点。

先令 $\{t_1, t_2\} \gets \{r_1, r_2\}$；

若 $r_1$（右儿子最右零区间）为空，此时右儿子无零区间，直接令 $\{t_1, t_2\} \gets \{l_1, l_2\}$，结束；

否则，若 $r_2$（右儿子次右零区间）为空，判断 $r_1$ 和 $l_1$ 是否相邻，相邻则合并，再令 $t_2 \gets l_2$，否则令 $t_2 \gets l_1$，结束；

否则判断 $r_2$ 和 $l_1$ 是否相邻，相邻则合并，结束。

### 修改

单点修改，只会影响到四个点（pos, pos+1, pos+n, pos+n+1），依次修改即可。

### 查询

查询，考虑将数组 $B$ 平分为左右两部分，开始分类讨论。

$
[B_0, B_1, B_2, B_3, B_0] \to [B_0, B_1, B_2], [B_3, B_0]
$

两部分均无零区间，输出 $-1$；

有一部分无零区间，输出另一部分的最远零区间到 $B_0$ 的距离；

$
[1, 2, 3], [0, 1]
$

左部分的最右零区间与右部分的最左零区间不相邻（没有零区间跨越两部分），输出两部分的最远零区间到 $B_0$ 的距离的最大值；

$
[1, 0, 3], [0, 1]
$

左部分的最右零区间与右部分的最左零区间相邻（有零区间跨越两部分），此时该零区间到 $B_0$ 的距离不一定是答案，需要再与两部分的次远零区间到 $B_0$ 的距离取最大值。

$
[1, 2, 0, 4, 0], [0, 0, 0, 0, 1]
$

------------

时间复杂度 $O(m \log n)$。

```cpp
#include <iostream>

using std::min;
using std::max;

const int MAXN = 2e5+5;

struct Range {
	int l, r;
};

struct Node {
	Range l, l2, r, r2;
} node[MAXN*4];

#define mid ((l+r)>>1)
#define lc (i<<1)
#define rc ((i<<1)|1)

int n, m;
int a[MAXN], b[MAXN];
char c[MAXN];

int getB(int idx) {
	int prev = (idx-1) ? (idx-1) : (n);
	if(c[idx] == '+') return (a[idx] + a[prev]) % 10;
	else return (a[idx] * a[prev]) % 10;
}

void update(Node &t, const Node l, const Node r) {
	t.r = r.r;
	t.r2 = r.r2;
	if(t.r.l < 0) {
		t.r = l.r;
		t.r2 = l.r2;
	}
	else if(t.r2.l < 0) {
		if(l.r.r + 1 == t.r.l) {
			t.r.l = l.r.l;
			t.r2 = l.r2;
		}
		else {
			t.r2 = l.r;
		}
	}
	else if(l.r.r + 1 == t.r2.l) {
		t.r2.l = l.r.l;
	}
	t.l = l.l;
	t.l2 = l.l2;
	if(t.l.l < 0) {
		t.l = r.l;
		t.l2 = r.l2;
	}
	else if(t.l2.l < 0) {
		if(r.l.l - 1 == t.l.r) {
			t.l.r = r.l.r;
			t.l2 = r.l2;
		}
		else {
			t.l2 = r.l;
		}
	}
	else if(r.l.l - 1 == t.l2.r) {
		t.l2.r = r.l.r;
	}
}

void build(int i, int l, int r) {
	if(l == r) {
		static int cnt = 0;
		if(b[++cnt] == 0) {
			node[i].l = node[i].r = {l, r};
			node[i].l2 = node[i].r2 = {-9, -9};
		}
		else {
			node[i].l = node[i].r = {-9, -9};
			node[i].l2 = node[i].r2 = {-9, -9};
		}
		return;
	}
	build(lc, l, mid);
	build(rc, mid+1, r);
	update(node[i], node[lc], node[rc]);
}

void modify(int i, int l, int r, int idx) {
	if(l == r) {
		if(b[idx] == 0) {
			node[i].l = node[i].r = {l, r};
			node[i].l2 = node[i].r2 = {-9, -9};
		}
		else {
			node[i].l = node[i].r = {-9, -9};
			node[i].l2 = node[i].r2 = {-9, -9};
		}
		return;
	}
	if(idx <= mid) modify(lc, l, mid, idx);
	else modify(rc, mid+1, r, idx);
	update(node[i], node[lc], node[rc]);
}

Node query(int i, int l, int r, int ql, int qr) {
	if(ql <= l && r <= qr) return node[i];
	Node ret = {{-9, -9}, {-9, -9}, {-9, -9}, {-9, -9}};
	if(ql <= mid) ret = query(lc, l, mid, ql, qr);
	if(qr > mid) update(ret, ret, query(rc, mid+1, r, ql, qr));
	return ret;
}

int solve(int pos, Node resl, Node resr) {
	bool
		hasL = resl.r.l > 0,
		hasR = resr.l.l > 0,
		hasL2 = resl.r2.l > 0,
		hasR2 = resr.l2.l > 0,
		beCnt = resl.r.r + 1 == resr.l.l;
	int
		distL = resl.r.l - pos,
		distR = pos + n - resr.l.r,
		distL2 = resl.r2.l - pos,
		distR2 = pos + n - resr.l2.r;
	if(!hasL && !hasR) {
		return -1;
	}
	else if(!hasL) {
		return distR;
	}
	else if(!hasR) {
		return distL;
	}
	else {
		if(beCnt) {
			int ret = min(distL, distR);
			if(hasL2) ret = max(ret, distL2);
			if(hasR2) ret = max(ret, distR2);
			return ret;
		}
		else {
			return max(distL, distR);
		}
	}
}

int main() {
	scanf("%d %d", &n, &m);
	for(int i=1; i<=n; ++i) {
		scanf("%d %c", a+i, c+i);
	}
	for(int i=1; i<=n; ++i) {
		a[i+n] = a[i];
		c[i+n] = c[i];
		b[i+n] = b[i] = getB(i);
	}
	build(1, 1, n*2);
	while(m--) {
		int op;
		scanf("%d", &op);
		if(op == 1) {
			int pos, num;
			char opt;
			scanf("%d %d %c", &pos, &num, &opt);
			pos++;
			a[pos] = num;
			c[pos] = opt;
			b[pos] = getB(pos);
			b[pos+1] = getB(pos+1);
			a[pos+n] = a[pos];
			c[pos+n] = c[pos];
			b[pos+n] = b[pos];
			b[pos+n+1] = b[pos+1];
			modify(1, 1, n*2, pos);
			modify(1, 1, n*2, pos+1);
			modify(1, 1, n*2, pos+n);
			modify(1, 1, n*2, pos+n+1);
		}
		else if(op == 2) {
			int pos;
			scanf("%d", &pos);
			pos++;
			b[pos] = a[pos];
			b[pos+n] = b[pos];
			modify(1, 1, n*2, pos);
			modify(1, 1, n*2, pos+n);
			Node resl = query(1, 1, n*2, pos, pos+(n>>1));
			Node resr = query(1, 1, n*2, pos+(n>>1)+1, pos+n);
			b[pos] = getB(pos);
			b[pos+n] = b[pos];
			modify(1, 1, n*2, pos);
			modify(1, 1, n*2, pos+n);
			printf("%d\n", solve(pos, resl, resr));
		}
	}
	return 0;
}
```

---

## 作者：只鹅烧烤二度 (赞：1)

提供一种 set 维护多段区间的无脑解法。

首先考虑每次解码的序列是一个对于一个 B 序列 $b_i=a_{i-1} * a_i$，并从中挖掉一个数 $b_i$ 替换成 $a_i$ 对此每次的询问可以转化成先对B序列进行单点修改操作，之后再进行查询操作并修改回原B序列。其次是修改A数组的符号和数字，对 $i$ 位置的修改显然只对 $ b_i $ 以及 $ b_{i-1} $ 有关联，因此也是两处的单点修改。

重头戏在于如何维护环上距离一个点最远的连续 $0$ 区间，首先考虑将所有区间用类似 ODT 的方法 set 储存，笔者采用了一个 pair 类型的 set 实现，不同于 ODT 的方面是每次修改单点的时候应当判断是否能与周围的区间合并。注意到实际上若干个区间描述的是一个环，因此若存在两个区间 $ [0,x] $  与 $ [y,n-1] $ 本质上是一个区间。

在用 set 表示了若干个连续 $0$ 区间的集合，考虑怎样的区间有可能成为答案，单点来说是环上相对于查询点正对面的位置，具体而言是 $ (i+n/2)\mod n $ 的位置，且越远离该点的位置越劣，因此我们找到第一个 $l$ 大于该点的位置的区间各向左右拓展作为可能解，这边选择拓展 $3$ 遍为了防止有区间为环。

总而言之还是一种无脑解法就是在 set 维护方面细节比较多，但码量不算大。

时间复杂度 $ O(n\log n) $ 

```cpp
#include <bits/stdc++.h>
#define pii pair<int,int>
#define IT multiset<pii >::iterator
using namespace std;
const int N=1e5+10;
int c[N],a[N],nx,n,m,op[N],b[N];
multiset<pii > s;
void change(int pos,bool dat)
{
	if(!(c[pos]^dat)) return;
	c[pos]=dat;
	if(dat)
	{
		int nl=pos,nr=pos;
		IT it=s.lower_bound(make_pair(pos+1,0));
		if(it!=s.end()&&(*it).first==pos+1) nr=(*it).second,s.erase(it);
		//是否能与左区间合并
		it=s.lower_bound(make_pair(pos,0));
		if(it!=s.begin()) it--;
		if(!s.empty()&&(*it).second==pos-1) nl=(*it).first,s.erase(it);
        //是否能与右区间合并
		s.insert(make_pair(nl,nr));
		return;
	}//add
	IT it=s.upper_bound(make_pair(pos+1,0));it--;
	int nl=(*it).first,nr=(*it).second;s.erase(it);
	if(pos-1>=nl) s.insert(make_pair(nl,pos-1));//分裂出左区间
	if(pos+1<=nr) s.insert(make_pair(pos+1,nr));//分裂出右区间
	//del
}

int get(IT it)//计算对于链上单一区间离计算点的距离
{
	int l=(*it).first,r=(*it).second,pos=nx;
	if(l<=pos&&pos<=r) return 0;
	return min(min(abs(pos-l),n-abs(pos-l)),min(abs(pos-r),n-abs(pos-r)));
}
int cal(IT it)//计算环上单一区间对应的真实区间距离
{
	int ans=1e9;
	if((*it).second==n-1&&(*s.begin()).first==0)
		return min(get(it),get(s.begin()));
	IT it1=s.end();it1--;
	if((*it).first==0&&(*it1).second==n-1)
		return min(get(it),get(it1));
	return get(it);
}
int solve(int pos)//计算对于一个点而言最远区间距离
{
	if(s.empty()) return -1;
	nx=pos;
	IT it=s.lower_bound(make_pair(pos+n/2>=n?pos+n/2-n:pos+n/2,0));
	if(it==s.end()) it=s.begin();
	IT it1=it;
	
	int ans=-1;
	for(int i=0;i<3;i++)
	{
		ans=max(ans,cal(it));it++;
		if(it==s.end()) it=s.begin();
	}//向右延伸
	it=it1;
	for(int i=0;i<3;i++)
	{
		ans=max(ans,cal(it));
		if(it==s.begin()) it=s.end();
		it--;
	}//向左延伸
	return ans;
}
int main()
{
	scanf("%d %d",&n,&m);
	for(int i=0;i<n;i++)
	{
		char x[3];
		scanf("%d %s",&a[i],x);
		op[i]=x[0]=='*';
	}
	b[0]=op[0]?(a[0]*a[n-1]%10):((a[0]+a[n-1])%10);
	for(int i=1;i<n;i++)
		b[i]=op[i]?(a[i]*a[i-1]%10):((a[i]+a[i-1])%10);
	for(int i=0;i<n;i++)
		change(i,b[i]==0);//计算初始的b序列
	
	for(int i=1,t,pos;i<=m;i++)
	{
		scanf("%d %d",&t,&pos);
		if(t==1)
		{
			char type[3];
			scanf("%d %s",&a[pos],type);
			op[pos]=type[0]=='*';
			int las=pos==0?n-1:pos-1,nxt=pos==n-1?0:pos+1;
			
			b[pos]=op[pos]?(a[pos]*a[las]%10):((a[pos]+a[las])%10);
			change(pos,b[pos]==0);
			
			b[nxt]=op[nxt]?(a[pos]*a[nxt]%10):((a[pos]+a[nxt])%10);
			change(nxt,b[nxt]==0);
		}
		else
		{
			change(pos,a[pos]==0);//先将序列原点改编为a值
			printf("%d\n",solve(pos));
			change(pos,b[pos]==0);
		}
	}
}
```



---


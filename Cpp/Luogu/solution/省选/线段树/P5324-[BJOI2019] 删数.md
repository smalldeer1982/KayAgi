# [BJOI2019] 删数

## 题目描述

对于任意一个数列，如果能在有限次进行下列删数操作后将其删为空数列，则称这个数列可以删空。一次删数操作定义如下：  
>记当前数列长度为 $k$ ，则删掉数列中所有等于 $k$ 的数。  

现有一个长度为 $n$ 的数列 $a$，有 $m$ 次修改操作，第 $i$ 次修改后你要回答：  
经过 $i$ 次修改后的数列 $a$，至少还需要修改几个数才可删空？  

每次修改操作为单点修改或数列整体加一或数列整体减一。

## 说明/提示

**样例解释(局部)：**     
第一次修改后，数列为$1$ $2$ $3$，无需修改即可删空。   
第四次修改后，数列为$4$ $5$ $6$，需要将三个数都改掉才可能删空。   
第六次修改后，数列为$4$ $2$ $2$，将第一个数改成$3$即可删空。   
第九次修改后，数列为$1$ $-1$ $-1$，可以将第二个数改成$2$、第三个数改成$3$来删空。   

**数据范围：**   
对于 $100\%$ 的数据：      
$1\le n,m \le 150000$  
$1\le a_i \le n$  
$0\le p\le n$  
$p>0$时，$1\le x \le n$  
$p=0$时，$x=-1$ 或 $1$    
![](https://cdn.luogu.com.cn/upload/pic/57129.png) 

## 样例 #1

### 输入

```
3 9
1 2 3
1 1
0 1
0 1
0 1
2 2
3 2
0 -1
0 -1
0 -1```

### 输出

```
0
1
2
3
2
1
1
2
2```

# 题解

## 作者：枫林晚 (赞：33)

[%%yyb](https://www.cnblogs.com/cjyyb/p/10750238.html#4238627)

这里说详细一些

**推性质+猜结论**

考虑没有修改。如何快速算出。再数据结构维护修改什么的

显而易见的是，答案和数列的顺序无关，只和出现的数有关

如果开一个桶，把每个数摞成若干个柱子，然后往左推倒，那么答案就是[1,n]中未被覆盖的个数。

证明：

1.首先这是答案的下界。对于一个空位，比它大的柱子删掉之后不能跨越它，比它小的柱子又不能提前删掉。所以必须变动一个数使得这里被遮盖上。

2.可以构造出至少一种方案达到这个下界。总数是n，那么有k个空位，就必然有k个重叠的位置。把这些柱子消掉一些，放到空位上，显然没有问题。

考虑维护

1.只有p>0，就是单点高度修改了，用个桶就可以O(m)做

2.还有p=0的整体操作，发现，就是查询区间进行了平移！用一个变量st记录当前0的位置，移动时候直接--st或者++st

用线段树维护每个点被覆盖的情况

但是，当一个柱子没有落到[st+1,st+n]的区间上，并且>st+n，这样的柱子并不能贡献覆盖的，一定是之后需要修改的累赘。

所以，当st--时候，对于原来的最右端的位置，把这个位置的柱子对[p-buc+1,p]的贡献减掉1。++st时候还原

线段树维护：区间最小值，最小值出现次数，0的个数，加法标记

这样，查询时候直接区间查询0个数即可

注意，单点修改的时候，也要判断是否<=st+n

```cpp
#include<bits/stdc++.h>
#define reg register int
#define il inline
#define fi first
#define se second
#define mk(a,b) make_pair(a,b)
#define numb (ch^'0')
using namespace std;
typedef long long ll;
template<class T>il void rd(T &x){
    char ch;x=0;bool fl=false;
    while(!isdigit(ch=getchar()))(ch=='-')&&(fl=true);
    for(x=numb;isdigit(ch=getchar());x=x*10+numb);
    (fl==true)&&(x=-x);
}
template<class T>il void output(T x){if(x/10)output(x/10);putchar(x%10+'0');}
template<class T>il void ot(T x){if(x<0) putchar('-'),x=-x;output(x);putchar(' ');}
template<class T>il void prt(T a[],int st,int nd){for(reg i=st;i<=nd;++i) ot(a[i]);putchar('\n');}

namespace Miracle{
const int N=150000*3+10;
#define mid ((l+r)>>1)
#define ls (x<<1)
#define rs (x<<1|1)
int n,m;
struct node{
    int mi,cnt;
    int ans,ad;
}t[4*N];
int a[N],buc[N];
int st,lim;
void pushup(int x){
    t[x].mi=min(t[ls].mi,t[rs].mi);
    t[x].cnt=(t[ls].mi==t[x].mi?t[ls].cnt:0)+(t[rs].mi==t[x].mi?t[rs].cnt:0);
    t[x].ans=t[ls].ans+t[rs].ans;
}
void tag(int x,int c){
    t[x].mi+=c;
    t[x].ans=(t[x].mi==0)?t[x].cnt:0;
    t[x].ad+=c;
}
void pushdown(int x){
    if(t[x].ad){
        tag(ls,t[x].ad);tag(rs,t[x].ad);
        t[x].ad=0;
    }
}
void build(int x,int l,int r){
    if(l==r){
        t[x].cnt=1;t[x].ans=1;
        return;
    }
    build(ls,l,mid);
    build(rs,mid+1,r);
    pushup(x);
}
void upda(int x,int l,int r,int L,int R,int c){
    if(L<=l&&r<=R){
        tag(x,c);return;
    }
    pushdown(x);
    if(L<=mid) upda(ls,l,mid,L,R,c);
    if(mid<R) upda(rs,mid+1,r,L,R,c);
    pushup(x);
}
int query(int x,int l,int r,int L,int R){
    if(L<=l&&r<=R) return t[x].ans;
    pushdown(x);
    if(R<=mid) return query(ls,l,mid,L,R);
    if(mid<L) return query(rs,mid+1,r,L,R);
    return query(ls,l,mid,L,R)+query(rs,mid+1,r,L,R);
}
void chan(int x,int c){
    int k=x-buc[x]+1-(c>0);
    upda(1,1,lim,k,k,c);
    buc[x]+=c;
}
int main(){
    rd(n);rd(m);
    st=150000+1,lim=450000+5;//开始0位置和线段树上界
    build(1,1,lim);
    for(reg i=1;i<=n;++i){
        rd(a[i]);a[i]+=st;chan(a[i],1);
    }
    int p,x;
    while(m--){
        rd(p);rd(x);
        if(p>0){//单点修改
            if(a[p]<=st+n){
                chan(a[p],-1);
            }else{//判断是否<=st+n
                --buc[a[p]];
            }
            a[p]=st+x;
            if(a[p]<=st+n){
                chan(a[p],1);
            }else{//判断是否<=st+n
                ++buc[a[p]];
            }
        }else if(x>0){
            int pos=st+n;
            if(buc[pos]) upda(1,1,lim,pos-buc[pos]+1,pos,-1);//清除贡献
            --st;
        }else{
            ++st;
            int pos=st+n;
            if(buc[pos]) upda(1,1,lim,pos-buc[pos]+1,pos,1);//加上贡献
        }
        printf("%d\n",query(1,1,lim,st+1,st+n));
    }
    return 0;
}

}
signed main(){
	Miracle::main();
	return 0;
}

/*
   Author: *Miracle*
*/


```







---

## 作者：E_huan (赞：28)

### 转换题意+线段树



------------

前言：做法是学习洛谷题解区枫林晚大佬的，补充了一些内容，用自己的理解和表述写了这篇题解，希望能讲清楚。 

------------


题目的描述显然不能直接维护，首先肯定是要找到删空的充要条件，然后才能考虑维护。

#### 结论：

数字 $i$ 有 $cnt[i]$ 个，则覆盖区间 $[i-cnt[i]+1,i]$，那么答案就是 $[1,n]$ 中未被覆盖的个数。



#### 证明：
$1$. 正确答案 $\geqslant$ 这个答案：对于一个数，比它大的数删掉之后不能到达它，比它小的数又不能提前删掉。所以必须变动一个数使得这里被覆盖。


$2$. 可以构造出取等号的方案。总数是 $n$，那么有 $k$ 个空位，就必然有 $k$ 个重叠或不在该范围的位置。把这些数改到空位上后一定能把空位填满。


#### 操作：
$1$. 单点修改就是删除原本的贡献，加上新的贡献。


细节上注意修改的点是否在当前的 $[start+1,up]$ 之中，如果不在就不修改
。（因为当 $i$ 不在这个范围的时候，可能 $(i-cnt[i]+1)$ 会在，但其实它的贡献是不能算的，回到题目本身的意思就可以理解），还有增加减少改变的是 $cnt[i]$，所以修改的位置是 $(i-cnt[i]+1)$ 不是 $i$。


$2$. 区间 $+1/\!-\!1$ 其实就是把前面说的覆盖区间全部向右平移。


平移可以通过维护一个变量（可以理解成全局懒标记）实现，用变量 $start$ 维护，表示查询的是 $[start+1,up]$ 中 $0$ 的个数。每次区间 $+1$ 就是 $start-1$，区间 $-1$ 就是 $start+1$，细节上注意 $start$ 初值不是 $0$，否则没有减的空间。此外，每次改变 $start$ 就会有一个数移出或移入边界（只需要考虑不让 $i>up$ 造成贡献，因为 $i < start+1$ 的情况 $[i-cnt[i]+1,i]$ 一定不会有贡献，全会在 $start+1$ 左边），所以需要修改 $[up+cnt[up]+1,up]$。


$3$. 查询就查询 $[start+1,up]$ 中 $0$ 的个数即可。


#### 维护：
这些操作都可以用线段树来维护，具体见代码（有注释）。

#### 代码：


``` cpp
#include<bits/stdc++.h>
using namespace std;
#define up start+n
const int N1=150010,N2=N1*3+10;
//注意是3倍，本身start+/-是两倍(向上n向下n)，但是区间是[(i-cnt[i]+1),i]，当i=1的时候还可以向前n的长度，所以是3倍
inline int read()
{
    int res=0,f=1;
    char ch=getchar();
    while(!isdigit(ch))
    {
        if(ch=='-') f=-1;
        ch=getchar();
    } 
    while(isdigit(ch)) 
    {
        res=res*10+ch-'0';
        ch=getchar();
    }
    return res*f;
}
int n,m,start=N1,a[N1];
int cnt[N2];
struct node
{
    int cnt0;//0的个数，即答案
    int add;//加法懒标记
    int mn;//最小值，辅助求出0的个数（最小值>=0,如果是0它的个数就是答案）
    int cnt_mn;//最小值个数
    //需要求出最小值和最小值个数是因为会有懒标记，不知道这两个值的话一旦有add的修改就可能不能在不递归的情况下求出cnt0
}tr[N2<<2];
inline void pushup(int u)
{
    tr[u].mn=min(tr[u<<1].mn,tr[u<<1|1].mn);
    tr[u].cnt_mn=0;
    if(tr[u].mn==tr[u<<1].mn) tr[u].cnt_mn=tr[u<<1].cnt_mn;
    if(tr[u].mn==tr[u<<1|1].mn) tr[u].cnt_mn+=tr[u<<1|1].cnt_mn;
    tr[u].cnt0=tr[u<<1].cnt0+tr[u<<1|1].cnt0;
}
inline void Add(int u,int v)
{
    tr[u].mn+=v;
    tr[u].add+=v;
    tr[u].cnt0=(tr[u].mn==0)?tr[u].cnt_mn:0;
}
inline void pushdown(int u)
{
    if(!tr[u].add) return;
    Add(u<<1,tr[u].add); Add(u<<1|1,tr[u].add);
    tr[u].add=0;
}
void build(int u,int l,int r)
{
    if(l==r) 
    {
        tr[u]={1,0,0,1};
        return;
    }
    int mid=(l+r)>>1;
    build(u<<1,l,mid); build(u<<1|1,mid+1,r);
    pushup(u);
}
void modify(int u,int l,int r,int ml,int mr,int v)
{
    if(ml<=l&&r<=mr) {Add(u,v); return;}
    pushdown(u);
    int mid=(l+r)>>1;
    if(ml<=mid) modify(u<<1,l,mid,ml,mr,v);
    if(mr>mid) modify(u<<1|1,mid+1,r,ml,mr,v);
    pushup(u);
}
int query(int u,int l,int r,int ql,int qr)
{
    if(ql<=l&&r<=qr) return tr[u].cnt0;
    pushdown(u);
    int mid=(l+r)>>1,res=0;
    if(ql<=mid) res=query(u<<1,l,mid,ql,qr);
    if(qr>mid) res+=query(u<<1|1,mid+1,r,ql,qr);
    return res;
}
int main()
{
    build(1,1,N1*3);//初始全是0，所以要build()来初始化cnt0
    n=read(),m=read();
    for(int i=1;i<=n;i++) 
        a[i]=read()+start,cnt[a[i]]++;
    for(int i=start+1;i<=up;i++) 
        if(cnt[i])
            modify(1,1,N1*3,i-cnt[i]+1,i,1);
    while(m--)
    {
        int p=read(),x=read();
        if(p)
        {
            if(a[p]<=up) modify(1,1,N1*3,a[p]-cnt[a[p]]+1,a[p]-cnt[a[p]]+1,-1);
            cnt[a[p]]--;
            a[p]=start+x;//!!!start+x not x
            cnt[a[p]]++;
            if(a[p]<=up) modify(1,1,N1*3,a[p]-cnt[a[p]]+1,a[p]-cnt[a[p]]+1,1);
        }//注意这里是单点修改，因为cnt[]只变化了1
        else
        {
            if(x==1)
            {
                if(cnt[up]) 
                    modify(1,1,N1*3,up-cnt[up]+1,up,-1);
                start--;
            }
            else
            {
                start++;
                if(cnt[up]) 
                    modify(1,1,N1*3,up-cnt[up]+1,up,1);
            }
        }
        printf("%d\n",query(1,1,N1*3,start+1,start+n));
    }
    return 0;
}
```

---

## 作者：Sol1 (赞：19)

万能的线段树 QwQ

首先来分析一下这个问题。

对于一个长度为 $n$ 的序列，如果这个序列里面有 $k_1$ 个 $n$，$k_2$ 个 $n-k_1$，$k_3$ 个 $n-k_1-k_2$，以此类推；如果这个序列可以删空，则一定有 $\sum k=n$ 成立。

所以现在问题变成了如何快速计算 $n - \sum k$。

我们发现这个东西的值域很小，是 $O(n+m)$ 级别的，所以可以考虑在线段树上维护一个数轴，如果数 $x$ 出现了 $c_x$ 次，那么在数轴上面 $[x-c_x+1,x]$ 就都是 $1$。

这样单点修改的操作就可以直接在数轴上做 $O(\log n)$ 的单点修改了~

同时我们设置一个指针 $p_0$，可以理解为数轴上 $0$ 的位置，即数轴 $x$ 位置对应的实际值是 $x-p_0$。

这样整体修改的操作就可以直接 $O(1)$ 平移 $p_0$ 了~

这里有一个问题，就是超过 $p_0+n$ 的值不能有贡献（小于 $p_0+1$ 的值可以在查询的时候排除掉）；所以在整体加/减操作中平移 $p_0$ 的时候在数轴上做区间修改就好了~

每次查询时只需要查询 $[p_0+1,p_0+n]$ 中 $0$ 的数量就可以了~

于是这道题就做完了~

复杂度是 $O((n+m)\log n)$。

注意因为 $p_0$ 可以平移到负数，所以要对所有数都加上 $1.5\times 10^5$，这样就没有负数的问题了。

代码：

```cpp
#include <iostream>
#include <cmath>
#include <cstring>
#include <cstdio>
using namespace std;

#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
char buf[1 << 21], *p1 = buf, *p2 = buf;

inline int qread() {
	register char c = getchar();
	register int x = 0, f = 1;
	while (c < '0' || c > '9') {
		if (c == '-') f = -1;
		c = getchar();
	}
	while (c >= '0' && c <= '9') {
		x = (x << 3) + (x << 1) + c - 48;
		c = getchar();
	}
	return x * f;
}

inline int Abs(const int& x) {return (x > 0 ? x : -x);}
inline int Max(const int& x, const int& y) {return (x > y ? x : y);}
inline int Min(const int& x, const int& y) {return (x < y ? x : y);}

struct Segtree {
	int minv[2000005], minvcnt[2000005], tag[2000005];
	inline void Pushup(int p) {
		minv[p] = Min(minv[p << 1], minv[p << 1 | 1]);
		minvcnt[p] = 0;
		if (minv[p << 1] == minv[p]) minvcnt[p] += minvcnt[p << 1];
		if (minv[p << 1 | 1] == minv[p]) minvcnt[p] += minvcnt[p << 1 | 1];
		return;
	}
	inline void Pushdown(int p, int pl, int pr) {
		if (pl == pr || !tag[p]) return;
		tag[p << 1] += tag[p];
		minv[p << 1] += tag[p];
		tag[p << 1 | 1] += tag[p];
		minv[p << 1 | 1] += tag[p];
		tag[p] = 0;
	}
	inline void Build(int p, int pl, int pr) {
		if (pl == pr) {
			minv[p] = 0;
			minvcnt[p] = 1;
			return;
		}
		register int mid = pl + pr >> 1;
		Build(p << 1, pl, mid); Build(p << 1 | 1, mid + 1, pr);
		Pushup(p);
	}
	inline void Modify(int p, int pl, int pr, int l, int r, int v) {
		if (l > r) return;
		if (pl == l && pr == r) {
			tag[p] += v;
			minv[p] += v;
			return;
		}
		Pushdown(p, pl, pr);
		register int mid = pl + pr >> 1;
		if (mid >= r) Modify(p << 1, pl, mid, l, r, v);
		else if (mid + 1 <= l) Modify(p << 1 | 1, mid + 1, pr, l, r, v);
		else {
			Modify(p << 1, pl, mid, l, mid, v);
			Modify(p << 1 | 1, mid + 1, pr, mid + 1, r, v);
		}
		Pushup(p);
	}
	inline pair <int, int> Query(int p, int pl, int pr, int l, int r) {
		if (pl == l && pr == r) return make_pair(minv[p], minvcnt[p]);
		Pushdown(p, pl, pr);
		register int mid = pl + pr >> 1;
		if (mid >= r) return Query(p << 1, pl, mid, l, r);
		else if (mid + 1 <= l) return Query(p << 1 | 1, mid + 1, pr, l, r);
		else {
			pair <int, int> ans1 = Query(p << 1, pl, mid, l, mid);
			pair <int, int> ans2 = Query(p << 1 | 1, mid + 1, pr, mid + 1, r);
			pair <int, int> ans3 = make_pair(0, 0);
			ans3.first = Min(ans1.first, ans2.first);
			if (ans1.first == ans3.first) ans3.second += ans1.second;
			if (ans2.first == ans3.first) ans3.second += ans2.second;
			return ans3;
		}
	}
};
Segtree sgt;

int n, a[150005], cnt[450020], m, zero = 150005, maxv = 450015;

inline void Read() {
	n = qread(); m = qread();
	for (register int i = 1;i <= n;i++) a[i] = qread() + zero;
}

inline void Add(int x) {
	if (x <= zero + n) sgt.Modify(1, 1, maxv, x - cnt[x], x - cnt[x], 1);
	cnt[x]++;
}

inline void Del(int x) {
	cnt[x]--;
	if (x <= zero + n) sgt.Modify(1, 1, maxv, x - cnt[x], x - cnt[x], -1);
}

inline void Addall(int x) {
	sgt.Modify(1, 1, maxv, x - cnt[x] + 1, x, 1);
}

inline void Delall(int x) {
	sgt.Modify(1, 1, maxv, x - cnt[x] + 1, x, -1);
}

inline void Solve() {
	sgt.Build(1, 1, maxv);
	for (register int i = 1;i <= n;i++) {
		Add(a[i]);
	}
	pair <int, int> ans = sgt.Query(1, 1, maxv, zero + 1, zero + n);
	//printf("%d %d\n", ans.first, ans.second);
	while (m--) {
		register int p = qread(), x = qread();
		if (p) {
			x += zero;
			Del(a[p]);
			Add(x);
			a[p] = x;
		} else if (~x) {
			Delall(zero + n);
			zero--;
		} else {
			zero++;
			Addall(zero + n);
		}
		pair <int, int> ans = sgt.Query(1, 1, maxv, zero + 1, zero + n);
		if (ans.first) puts("0");
		else printf("%d\n", ans.second);
	}
}

int main() {
	Read();
	Solve();
	#ifndef ONLINE_JUDGE
	while (1);
	#endif
	return 0;
}
```



---

## 作者：Orion545 (赞：7)

# 广告

### [蒟蒻のblog](https://loj.ac/problem/3094)

# 思路

## dp部分

以下称**合法序列**为原题面中**可以删空的序列**

这个是我在模拟考场上的思路

一开始我是觉得，这个首先可以写成一个dp的形式：$dp[i][j]$表示用$j$个数字填满了目标序列的前$i$需要的步数

然后，发现只有$dp[i][i]$有意义，所以优化为$dp[i]$表示达成了构成长度为$i$的序列需要的最小步数

猜一个转移方程：$dp[i]=min_{j\in[1,i-1]}(dp[j]+max(0,(i-j)-num[i])$

这里$num[i]$表示当前询问的序列中数字$i$的出现次数，就是一个桶

转移方程的意义就是在一个长度为$j$的合法序列（下称$j$序列）后面接上$i-j$个$i$

正确性证明如下：

首先，我们可以把原序列中所有等于$i$的数字直接用上，够了就不用变新的，不够了就从别的数字那里拿一些变过来补上

问题：如何确定数字等于$i$的没有在前面的$j$序列中被转移过去？

可以发现这里**不需要考虑这种情况**：转移过去的只需要是和在前面需要的数大小不一样的，而$i$显然不和$j$序列中**任何一个数相等**，所以即使用过了$i$，也可以随便**挑一个$i$以外**的代替$i$进去前面

然后因为最终一共$n$个数填长度为$n$的序列，数总是够用的，所以这就完成了$dp$转移正确性的证明

这样可以获得**47分**的subtask（洛谷上没有subtask，是34分）

## 贪心部分

上面那个结论其实还有用处：它是贪心做法的基础

可以发现只有在$[1,n]$区间内的数是“有用”，即有可能不需要改变就可以放进合法序列里的

我们考虑这些数的“有用性”，发现：对于$j$个$i$,里面最多有$i$个是有用的

同时，如果有两种数$i<j$，令$k=j-i$，若值为$j$的数的数量大于$k$，那么这里$j$和$i$就会“冲突”，也就是$i$和以下的一小段位置只有一种数可以不修改放进去，这就意味着我们可以用区间覆盖的方式来确定“有用”的位置

**形式化地来说，设值为$i$的数字有$cnt[i]$个，那么它们可以覆盖区间$[i-cnt[i]+1,i]$**

显然，区间$[1,n]$内没有被覆盖的位置总数，就是这个询问的答案

## 数据结构优化

显然我们可以通过线段树维护最小值和最小值个数来解决这个问题

考虑两种修改

第一种修改是修改两个区间的长度，就是两次单点修改而已

第二种修改可以相当于平移询问区间

这里要注意：**只有值在询问区间里的位置才能往前覆盖**

也就是说，假设我询问的是$[2,5]$，原序列里面有$3$个$6$，那这些6都没有用

所以需要在第二种修改的时候看看会不会加入or删除整个区间

实现上因为可能会减到负数，负数还能往下覆盖，所以一共开长度为$2n+2m$的线段树，初始0位置$n+m$

# Code

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cassert>
#define ll long long
using namespace std;
inline int read(){
	int re=0,flag=1;char ch=getchar();
	while(!isdigit(ch)){
		if(ch=='-') flag=-1;
		ch=getchar();
	}
	while(isdigit(ch)) re=(re<<1)+(re<<3)+ch-'0',ch=getchar();
	return re*flag;
}
int n,m,a[1000010],cnt[1000010],ori[1000010],pos;
struct ele{//合并用的线段树元素，query的时候很方便，merge就好了
	int minn,cnt;
	ele(int mm=0,int cc=0){minn=mm;cnt=cc;}
	friend inline ele merge(const ele &a,const ele &b){
		ele re;re.minn=min(a.minn,b.minn);
		if(re.minn==a.minn) re.cnt+=a.cnt;
		if(re.minn==b.minn) re.cnt+=b.cnt;
		assert(re.minn>=0);
		return re;
	}
}seg[2000010];int tag[2000010];//有区间修改，加lazytag
inline void pushtag(int num,int w){seg[num].minn+=w;tag[num]+=w;assert(seg[num].minn>=0);}
inline void push(int l,int r,int num){
	if(l==r||!tag[num]) return;
	pushtag(num<<1,tag[num]);
	pushtag(num<<1|1,tag[num]);
	tag[num]=0;
}
inline void build(int l,int r,int num){
	if(l==r){seg[num]=ele(ori[l],1);return;}
	int mid=(l+r)>>1;
	build(l,mid,num<<1);build(mid+1,r,num<<1|1);
	seg[num]=merge(seg[num<<1],seg[num<<1|1]);
}
inline void change(int l,int r,int num,int pos,int w){
	if(l==r){seg[num].minn+=w;return;}
	int mid=(l+r)>>1;push(l,r,num);
	if(mid>=pos) change(l,mid,num<<1,pos,w);
	else change(mid+1,r,num<<1|1,pos,w);
	seg[num]=merge(seg[num<<1],seg[num<<1|1]);
}
inline void add(int l,int r,int ql,int qr,int num,int w){
	if(l>=ql&&r<=qr){pushtag(num,w);return;}
	int mid=(l+r)>>1;push(l,r,num);
	if(mid>=ql) add(l,mid,ql,qr,num<<1,w);
	if(mid<qr) add(mid+1,r,ql,qr,num<<1|1,w);
	seg[num]=merge(seg[num<<1],seg[num<<1|1]);
}
inline ele query(int l,int r,int ql,int qr,int num){
	if(l>=ql&&r<=qr) return seg[num];
	int mid=(l+r)>>1;ele re(2e9,0);push(l,r,num);
	if(mid>=ql) re=merge(re,query(l,mid,ql,qr,num<<1));
	if(mid<qr) re=merge(re,query(mid+1,r,ql,qr,num<<1|1));
	return re;
}
int main(){
	n=read();m=read();int i,t1,t2,j,tot=n+n+m+m;ele ans;
	pos=n+m;
	for(i=1;i<=n;i++) cnt[(a[i]=read()+pos)]++;
	for(i=1;i<=tot;i++) if(cnt[i])
		for(j=i;j>i-cnt[i];j--) ori[j]++;
	build(1,tot,1);
	while(m--){
		t1=read();t2=read();
		if(t1){
			//直接维护，注意不在目前范围内的位置不要change！！！
			t2+=pos;
			cnt[a[t1]]--;ori[a[t1]-cnt[a[t1]]]--;
			if(a[t1]<=pos+n&&a[t1]>pos) change(1,tot,1,a[t1]-cnt[a[t1]],-1);
			a[t1]=t2;
			if(a[t1]<=pos+n&&a[t1]>pos) change(1,tot,1,a[t1]-cnt[a[t1]],1);
			ori[a[t1]-cnt[a[t1]]]++;cnt[a[t1]]++;
		}
		else{
			//查看是否有区间需要加入or删除！！！
			if(~t2){
				pos--;
				if(cnt[pos+n+1]) add(1,tot,pos+n+1-cnt[pos+n+1]+1,pos+n+1,1,-1);
				if(cnt[pos+1]) add(1,tot,pos+1-cnt[pos+1]+1,pos+1,1,1);
			}
			else{
				pos++;
				if(cnt[pos+n]) add(1,tot,pos+n-cnt[pos+n]+1,pos+n,1,1);
				if(cnt[pos]) add(1,tot,pos-cnt[pos]+1,pos,1,-1);
			}
		}
		ans=query(1,tot,pos+1,pos+n,1);
		if(ans.minn) puts("0");
		else printf("%d\n",ans.cnt);
	}
}
```

---

## 作者：devout (赞：6)

那么显然我们可以发现最后的答案和数字的顺序是无关的，所以我们可以考虑把所有的数降序排列

比如对于排序完的又一个这样的数列

10 10 10 7 7 7 7 3 3 3

我们发现这个序列显然是可以消掉的，先把10删掉，然后相应的7,3都会删掉

那如果我们把这个数列换一下，变成

10 10 10 6 6 6 6 3 3 3

那么这个东西就消不掉了

为什么呢？我们发现，当10全部被删掉之后，我们序列里还有7个数，但是我们需要删掉6，相当于中间空出来一个格子，那么这个时候我们就必须从后面拿一个补过来

从哪里拿呢？我们可以把一个3或者一个6变成7就可以

也就是说，对于一个数$i$有$cnt_i$个，那么全部的$i-cnt_i$一定是可以消掉的

如果没有$i-cnt_i$，我们就需要从后面拿一个过来

****

我们就可以把题目中的问题转化成一个类似于多米诺骨牌的模型

我们从最大的地方推倒，然后如果有空格，就从后面一个重复的地方拿一个缓过来

因为所有数的数量是相同的，这里空了一个后面一定还有一个

所以我们只需要完成区间加减和查询区间$0$的个数

对于区间$+1,-1$的操作，就是把区间进行了一下平移

****

但是这个东西怎么维护呢？我们发现我们要维护的东西和扫描线很像，在求面积并的时候我们就是维护了区间被覆盖过得长度

所以我们~~粘个代码交上去就好了~~

于是成功的拿到了$34$分的好成绩，为什么呢？

因为我们在维护扫描线的时候因为我们只需要求一个线段树整体的情况，也就是节点$1$处的答案，所以我们不需要考虑很多，更新的时候正常上传答案就可以

但是这里不同，我们需要查询一个区间的东西，但是我们当时是标记永久化掉的，显然不太好查询，所以我们需要换用另一种维护方法 ~~大概只有我这么菜的才会这么想~~

我们维护三个量，$min$表示区间$0$的个数，$sum$表示最小值个个数，$cnt$表示$0$的个数，这样我们就很好进行更新了

****

再交上去，又WA了，为什么呢？

比如说$n=5$的时候，$a_i=\{1,3,3,4,5\}$，然后区间$+1$之后，$a_i=\{2,4,4,5,6\}$，这个时候我们发现，$6$是无论如何也推不倒的，因为我们只能从$n$开始推

所以我们不能把$[i-cnt_i+1,i],i>n$的区间算进去

怎么办呢？我们在区间左移右移的时候单独判断一下，如果他溢出了这个范围，就把这个区间整体删掉，如果他回来了，再加回来

相应的，我们在单点修改的时候也要考虑一下这种情况

然后就是代码了：

```cpp
#include <bits/stdc++.h>
using namespace std;

# define Rep(i,a,b) for(int i=a;i<=b;i++)
# define _Rep(i,a,b) for(int i=a;i>=b;i--)
# define RepG(i,u) for(int i=head[u];~i;i=e[i].next)

typedef long long ll;

const int N=6e5+5;

template<typename T> void read(T &x){
   x=0;int f=1;
   char c=getchar();
   for(;!isdigit(c);c=getchar())if(c=='-')f=-1;
   for(;isdigit(c);c=getchar())x=(x<<1)+(x<<3)+c-'0';
    x*=f;
}

int n,m;
int a[N],cnt[N];
int delta;

struct node{
    int l,r;
    int min,sum,cnt;//min,sum of min,cnt of 0
    int tag;
}seg[N<<2];

# define lc (u<<1)
# define rc (u<<1|1)

void pushup(int u){
    seg[u].min=min(seg[lc].min,seg[rc].min);
    seg[u].sum=seg[lc].sum*(seg[u].min==seg[lc].min)+seg[rc].sum*(seg[u].min==seg[rc].min);
    seg[u].cnt=seg[lc].cnt+seg[rc].cnt;
}

void renew(int u,int k){
    seg[u].min+=k;
    seg[u].cnt=(!seg[u].min)?seg[u].sum:0;
    seg[u].tag+=k;
}

void pushdown(int u){
    renew(lc,seg[u].tag);
    renew(rc,seg[u].tag);
    seg[u].tag=0;
}

void build(int u,int l,int r){
    seg[u].l=l,seg[u].r=r;
    if(l==r){
        seg[u].sum=seg[u].cnt=1;
        return;
    }
    int mid=l+r>>1;
    build(lc,l,mid);
    build(rc,mid+1,r);
    pushup(u);
}

void update(int u,int l,int r,int k){
    if(l>r)return;
    if(seg[u].l>=l&&seg[u].r<=r){
        renew(u,k);
        return;
    }
    if(seg[u].tag)pushdown(u);
    int mid=seg[u].l+seg[u].r>>1;
    if(l<=mid)update(lc,l,r,k);
    if(r>mid)update(rc,l,r,k);
    pushup(u);
}

int query(int u,int l,int r){
    if(seg[u].l>=l&&seg[u].r<=r)return seg[u].cnt;
    if(seg[u].tag)pushdown(u);
    int mid=seg[u].l+seg[u].r>>1;
    int res=0;
    if(l<=mid)res+=query(lc,l,r);
    if(r>mid)res+=query(rc,l,r);
    return res;
}

int main()
{
    read(n),read(m);
    delta=200000;
    Rep(i,1,n)read(a[i]),a[i]+=delta,cnt[a[i]]++;
    build(1,1,6e5);
    Rep(i,delta+1,delta+n)update(1,i-cnt[i]+1,i,1);
    Rep(i,1,m){
        int p,x;
        read(p),read(x);
        if(!p){
            if(x>0){
                int pos=delta+n;
                update(1,pos-cnt[pos]+1,pos,-1);
                delta--;
            }
            else{
                delta++;
                int pos=delta+n;
                update(1,pos-cnt[pos]+1,pos,1);
            }
        }
        else{
            if(a[p]<=n+delta){
                update(1,a[p]-cnt[a[p]]+1,a[p],-1);
                cnt[a[p]]--;
                update(1,a[p]-cnt[a[p]]+1,a[p],1);
            }
            else cnt[a[p]]--;
            a[p]=delta+x;
            if(a[p]<=n+delta){
                update(1,a[p]-cnt[a[p]]+1,a[p],-1);
                cnt[a[p]]++;
                update(1,a[p]-cnt[a[p]]+1,a[p],1);
            }
            else cnt[a[p]]++;
        }
        printf("%d\n",query(1,delta+1,delta+n));
    }
    return 0;
}
```


---

## 作者：lhm_ (赞：6)

先考虑对于一个序列，能使其可以删空的的修改次数。

首先可以发现，序列的排列顺序是没有影响的，所以可以将所有数放到桶里来处理。

尝试对一个没有经过修改的可以删空的序列来进行删数，一开始删去所有的$n$，然后序列长度变为$x_1$，删去所有的$x_1$，然后序列长度变为$x_2$，删去所有的$x_2$……直到对于一个长度为$x_i$的序列，其中没有$x_i$这个数，那么此时就要对序列执行修改操作了。

考虑过程，当不能连续的删数时，就需要通过修改来填补空缺。实际上，对$[1,n]$做前缀和，存在数字的位置需满足该位置的值等于该位置的下标，不然就需进行修改。

可以发现对于$[1,n]$的每个出现的数字，从其往前覆盖一条长度为该数出现次数的线段，区间$[1,n]$未被覆盖的位置个数即为需要修改的次数。

可以通过线段树来维护最小值的个数来统计未被覆盖的位置个数。

考虑加上修改操作，单点修改直接改修改前后两个数的贡献即可，整体加减可以对线段树的询问加上偏移量，比如当整体加一时，偏移量减一，询问的区间向左移动。

然后对于一些不在当前询问区间的数字的贡献需要忽略，我的处理是在询问区间右边的数字就不再计算贡献。

$code:$

```cpp
#include<bits/stdc++.h>
#define maxn 2000010
#define all 450000
#define ls (cur<<1)
#define rs (cur<<1|1)
#define mid ((l+r)>>1)
using namespace std;
template<typename T> inline void read(T &x)
{
    x=0;char c=getchar();bool flag=false;
    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}
    while(isdigit(c)){x=(x<<1)+(x<<3)+(c^48);c=getchar();}
    if(flag)x=-x;
}
int n,m,root=1,delta=150000;
int a[maxn],cnt[maxn],add[maxn];
struct node
{
    int mi,cnt;
}t[maxn];
node operator +(const node &a,const node &b)
{
    if(a.mi<b.mi) return a;
    if(a.mi>b.mi) return b;
    return (node){a.mi,a.cnt+b.cnt};
}
void pushadd(int cur,int v)
{
    t[cur].mi+=v,add[cur]+=v;
}
void pushdown(int cur)
{
    if(!add[cur]) return;
    pushadd(ls,add[cur]),pushadd(rs,add[cur]),add[cur]=0;
}
void build(int l,int r,int cur)
{
    if(l==r)
    {
        t[cur]=(node){0,1};
        return;
    }
    build(l,mid,ls),build(mid+1,r,rs),t[cur]=t[ls]+t[rs];
}
void modify(int L,int R,int l,int r,int v,int cur)
{
    if(L>R) return;
    if(L<=l&&R>=r)
    {
        pushadd(cur,v);
        return;
    }
    pushdown(cur);
    if(L<=mid) modify(L,R,l,mid,v,ls);
    if(R>mid) modify(L,R,mid+1,r,v,rs);
    t[cur]=t[ls]+t[rs];
}
node query(int L,int R,int l,int r,int cur)
{
    if(L<=l&&R>=r) return t[cur];
    pushdown(cur);
    if(R<=mid) return query(L,R,l,mid,ls);
    if(L>mid) return query(L,R,mid+1,r,rs);
    return query(L,R,l,mid,ls)+query(L,R,mid+1,r,rs);
}
int main()
{
    read(n),read(m),build(1,all,root);
    for(int i=1;i<=n;++i)
        read(a[i]),a[i]+=delta,cnt[a[i]]++;
    for(int i=1+delta;i<=n+delta;++i)
        modify(i-cnt[i]+1,i,1,all,1,root);
    while(m--)
    {
        int p,x;
        read(p),read(x);
        if(p)
        {
            if(a[p]<=n+delta) modify(a[p]-cnt[a[p]]+1,a[p]-cnt[a[p]]+1,1,all,-1,root);
            cnt[a[p]]--,x+=delta,cnt[x]++,a[p]=x;
            if(x<=n+delta) modify(x-cnt[x]+1,x-cnt[x]+1,1,all,1,root);
        }
        else
        {
            if(x==1) p=n+delta,modify(p-cnt[p]+1,p,1,all,-1,root),delta--;
            else delta++,p=n+delta,modify(p-cnt[p]+1,p,1,all,1,root);
        }
        node q=query(1+delta,n+delta,1,all,root);
        if(q.mi) puts("0");
        else printf("%d\n",q.cnt);
    }
    return 0;
}
```

---

## 作者：Great_Influence (赞：5)

先考虑不带修改怎么做。

不带修改的版本显然是道原题，根据原题的做法我们可以知道是给区间 $[i-cnt_i+1,i]$ 覆盖一次，然后求出有多少个点没有被覆盖。这可以转换成区间加 $1$ ，然后询问区间 $0$ 个数。可以通过维护区间最小值及其个数来实现。

然后带修改的话，可以单点修改每次只会修改两个区间的左端点，而区间平移可以直接将查询区间从 $[1,n]$ 变成 $[0,n-1]$ 或者 $[2,n+1]$ 。为了方便一开始就将坐标向右平移 $\max(n,m)$ ，同时给右边预留 $\max(n,m)$ 的位置。

时间复杂度 $O(m\log (n+m))$ 。

代码:
```cpp
#include<cstdio>
#include<cstdlib>
#include<cctype>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<cassert>
#include<queue>
#include<iostream>
#include<climits>
#define Rep(i,a,b) for(register int i=(a);i<=(b);++i)
#define Repe(i,a,b) for(register int i=(a);i>=(b);--i)
#define rep(i,a,b) for(register int i=(a);i<(b);++i)
#define pb push_back
#define mp make_pair
#define mx(a,b) (a>b?a:b)
#define mn(a,b) (a<b?a:b)
typedef unsigned long long uint64;
typedef unsigned int uint32;
typedef long long ll;
using namespace std;

namespace IO
{
	const uint32 Buffsize=1<<15,Output=1<<24;
	static char Ch[Buffsize],*S=Ch,*T=Ch;
	inline char getc()
	{
		return((S==T)&&(T=(S=Ch)+fread(Ch,1,Buffsize,stdin),S==T)?0:*S++);
	}
	static char Out[Output],*nowps=Out;
	
	inline void flush(){fwrite(Out,1,nowps-Out,stdout);nowps=Out;}

	template<typename T>inline void read(T&x)
	{
		x=0;static char ch;T f=1;
		for(ch=getc();!isdigit(ch);ch=getc())if(ch=='-')f=-1;
		for(;isdigit(ch);ch=getc())x=x*10+(ch^48);
		x*=f;
	}

	template<typename T>inline void write(T x,char ch='\n')
	{
		if(!x)*nowps++='0';
		if(x<0)*nowps++='-',x=-x;
		static uint32 sta[111],tp;
		for(tp=0;x;x/=10)sta[++tp]=x%10;
		for(;tp;*nowps++=sta[tp--]^48);
		*nowps++=ch;
		if(nowps-Out>=1<<23)flush();
	}

	inline void getstr(char*q)
	{
		register char ch;
		for(ch=getc();!isgraph(ch);ch=getc());
		for(;isgraph(ch);ch=getc())*q++=ch;
		*q='\0';
	}

	inline void getwd(char&x){for(x=getc();!isupper(x);x=getc());}
}
using namespace IO;

void file()
{
#ifndef ONLINE_JUDGE
	FILE*DSD=freopen("water.in","r",stdin);
	FILE*CSC=freopen("water.out","w",stdout);
#endif
}

inline void Chkmin(int&u,int v){u>v?u=v:0;}

inline void Chkmax(int&u,int v){u<v?u=v:0;}

inline void Chkmax(double&u,double v){u<v?u=v:0;}

inline void Chkmax(ll&u,ll v){u<v?u=v:0;}

inline void Chkmin(ll&u,ll v){u>v?u=v:0;}

const int MAXN=4.5e5+7;

static int n,m,a[MAXN],cnt[MAXN];

inline void init()
{
	read(n),read(m);
	Rep(i,1,n)read(a[i]),++cnt[a[i]+=max(m,n)];
}

static int cl[MAXN];

namespace Segment_Tree
{
	static int p[MAXN<<2],cn[MAXN<<2],tg[MAXN<<2];

	inline void pushup(int u)
	{
		p[u]=p[u<<1],cn[u]=cn[u<<1];
		if(p[u<<1|1]<p[u])p[u]=p[u<<1|1],cn[u]=cn[u<<1|1];
		else if(p[u<<1|1]==p[u])cn[u]+=cn[u<<1|1];
	}

	inline void pushdown(int u)
	{
		if(tg[u])
		{
			tg[u<<1]+=tg[u],tg[u<<1|1]+=tg[u];
			p[u<<1]+=tg[u],p[u<<1|1]+=tg[u];
			tg[u]=0;
		}
	}

	void build_tree(int h,int l,int r)
	{
		if(l==r){p[h]=cl[l],cn[h]=1;return;}
		int md=(l+r)>>1;
		build_tree(h<<1,l,md),build_tree(h<<1|1,md+1,r);
		pushup(h);
	}

	void modify(int h,int l,int r,int x,int y,int dt)
	{
		if(l>=x&&r<=y){p[h]+=dt,tg[h]+=dt;return;}
		int md=(l+r)>>1;pushdown(h);
		if(x<=md)modify(h<<1,l,md,x,y,dt);
		if(y>md)modify(h<<1|1,md+1,r,x,y,dt);
		pushup(h);
	}

	int query(int h,int l,int r,int x,int y)
	{
		if(l>=x&&r<=y)return p[h]?0:cn[h];
		int md=(l+r)>>1,sm=0;pushdown(h);
		if(x<=md)sm=query(h<<1,l,md,x,y);
		if(y>md)sm+=query(h<<1|1,md+1,r,x,y);
		return sm;
	}
}
using namespace Segment_Tree;

int ln;

inline void solve()
{
	static int op,x;
	static int l=max(m,n)+1,r=l+n-1;
	int ln=r+max(m,n);
	Rep(i,m+1,r)++cl[i-cnt[i]+1],--cl[i+1];
	Rep(i,2,r+1)cl[i]+=cl[i-1];
	build_tree(1,1,ln);
	Rep(i,1,m)
	{
		read(op),read(x);
		if(!op)
		{
			if(x==1)
			{
				if(cnt[r])modify(1,1,ln,r-cnt[r]+1,r,-1);
				--l,--r;
			}
			else
			{
				++l,++r;
				if(cnt[r])modify(1,1,ln,r-cnt[r]+1,r,1);
			}
		}
		else
		{
			if(a[op]<=r)
		modify(1,1,ln,a[op]-cnt[a[op]]+1,a[op]-cnt[a[op]]+1,-1);
			--cnt[a[op]];
			a[op]=x+l-1;
			++cnt[x+l-1];
			modify(1,1,ln,a[op]-cnt[a[op]]+1,a[op]-cnt[a[op]]+1,1);
		}
		write(query(1,1,ln,l,r));
	}
	flush();
}

int main()
{
	file();
	init();
	solve();
	return 0;
}
```

---

## 作者：yzhang (赞：4)

### [原题传送门](https://www.luogu.org/problemnew/show/P5324)

### [更好的阅读](https://www.cnblogs.com/yzhang-rp-inf/p/10902621.html)

#### 易知这个数列的顺序是不用考虑的

#### 我们看两个数列 $1,2,3$和$3,3,3$都能删完，再看两个数列$1,2,3,4$和$2,2,4,4$，也都能删完

#### 不难发现，我们珂以把这些数字塞进桶中，记$cnt_i$表示数字$i$出现的次数，对于每个$i$，在一颗线段树上把区间$[i-cnt_i+1,i]$赋值成1（因为一次删$cnt_i$个珂以转化成每次删$1$个，值从大向小递减），最后看[1,n]上有几个点不是1，这就是题目所求的答案

#### 单点修改就直接在线段树上单点修改，区间加减实际就相当于线段树值域平移，但这个实在太麻烦，相对的，我们珂以平移查询区间

#### 我们珂以一开始就把$1$设为$Max(n,m)+1$这样就不用考虑负数的问题了

#### 时间复杂度是$O(m\log (2*Max(n,m)+n))$

#### ~~假·完整代码（这个是假算法）~~

```cpp
#include <bits/stdc++.h>
#define N 450005 
#define M 150005
#define getchar nc
using namespace std;
inline char nc(){
    static char buf[100000],*p1=buf,*p2=buf;
    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;
}
inline int read()
{
    register int x=0,f=1;register char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+ch-'0',ch=getchar();
    return x*f;
}
inline void write(register int x)
{
    if(!x)putchar('0');if(x<0)x=-x,putchar('-');
    static int sta[20];register int tot=0;
    while(x)sta[tot++]=x%10,x/=10;
    while(tot)putchar(sta[--tot]+48);
}
int n,m,a[M],lim,cnt[N],w;
int tr[N<<3],sum[N];
inline void modify(register int x,register int l,register int r,register int pos,register int val)
{
    if(l==r)
    {
        tr[x]=val;
        return;
    }
    int mid=l+r>>1;
    if(pos<=mid)
        modify(x<<1,l,mid,pos,val);
    else
        modify(x<<1|1,mid+1,r,pos,val);
    tr[x]=tr[x<<1]+tr[x<<1|1];
}
inline int query(register int x,register int l,register int r,register int L,register int R)
{
    if(L<=l&&r<=R)
        return tr[x];
    int mid=l+r>>1,res=0;
    if(L<=mid)
        res+=query(x<<1,l,mid,L,R);
    if(R>mid)
        res+=query(x<<1|1,mid+1,r,L,R);
    return res;
}
int main()
{
    n=read(),m=read();
    lim=m+n*2;
    memset(cnt,0,sizeof(cnt));
    memset(sum,0,sizeof(sum));
    for(register int i=1;i<=n;++i)
    {
        a[i]=read();
        if((++sum[n+a[i]-cnt[a[i]+m]])==1)
            modify(1,1,lim,n+a[i]-cnt[a[i]+m],1);
        ++cnt[a[i]+m];
    }
    for(register int i=1;i<=m;++i)
    {
        int opt=read(),x=read();
        if(opt)
        {
            x-=w;
            --cnt[a[opt]+m];
            if((--sum[n+a[opt]-cnt[a[opt]+m]])==0)
                modify(1,1,lim,n+a[opt]-cnt[a[opt]+m],0);
            a[opt]=x;
            if((++sum[n+a[opt]-cnt[a[opt]+m]])==1)
                modify(1,1,lim,n+a[opt]-cnt[a[opt]+m],1);
            ++cnt[a[opt]+m];
        }
        else
            w+=x;
        write(n-query(1,1,lim,n+1-w,n+n-w)),puts("");
    }
    return 0;
}
```

#### 交一发，发现会WA46

#### 实际因为我们有种情况没有考虑：当$val>n$时，所有的都要修改，然而到线段树上就变成了一段区间，会对答案造成影响

#### 我们只需要动态插入/删除区间即可，这样线段树要维护区间最小值及其个数

#### 真·完整代码

```cpp
#include <bits/stdc++.h>
#define N 450005 
#define M 150005
#define getchar nc
using namespace std;
inline char nc(){
    static char buf[100000],*p1=buf,*p2=buf;
    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;
}
inline int read()
{
    register int x=0,f=1;register char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+ch-'0',ch=getchar();
    return x*f;
}
inline void write(register int x)
{
    if(!x)putchar('0');if(x<0)x=-x,putchar('-');
    static int sta[20];register int tot=0;
    while(x)sta[tot++]=x%10,x/=10;
    while(tot)putchar(sta[--tot]+48);
}
inline int Max(register int a,register int b)
{
    return a>b?a:b;
}
int n,m,a[M],b[N],cnt[N],c,ql,qr,lim;
int minn[N<<3],sum[N<<3],tag[N<<3];
inline void pushup(register int x)
{
    int ls=x<<1,rs=x<<1|1;
    minn[x]=minn[ls],sum[x]=sum[ls];
    if(minn[rs]<minn[x])
        minn[x]=minn[rs],sum[x]=sum[rs];
    else if(minn[rs]==minn[x])
        sum[x]+=sum[rs];
}
inline void build(register int x,register int l,register int r)
{
    if(l==r)
    {
        minn[x]=b[l];
        sum[x]=1;
        return;
    }
    int mid=l+r>>1;
    build(x<<1,l,mid);
    build(x<<1|1,mid+1,r);
    pushup(x);
}
inline void pushdown(register int x)
{
    if(tag[x])
    {
        int ls=x<<1,rs=x<<1|1;
        tag[ls]+=tag[x],tag[rs]+=tag[x];
        minn[ls]+=tag[x],minn[rs]+=tag[x];
        tag[x]=0;
    }
}
inline void modify(register int x,register int l,register int r,register int L,register int R,register int val)
{
    if(L<=l&&r<=R)
    {
        minn[x]+=val;
        tag[x]+=val;
        return;
    }
    int mid=l+r>>1;
    pushdown(x);
    if(L<=mid)
        modify(x<<1,l,mid,L,R,val);
    if(R>mid)
        modify(x<<1|1,mid+1,r,L,R,val);
    pushup(x);
}
inline int query(register int x,register int l,register int r,register int L,register int R)
{
    if(L<=l&&r<=R)
        return minn[x]?0:sum[x];
    int mid=l+r>>1,res=0;
    pushdown(x);
    if(L<=mid)
        res+=query(x<<1,l,mid,L,R);
    if(R>mid)
        res+=query(x<<1|1,mid+1,r,L,R);
    return res;
}
int main()
{
    n=read(),m=read();
    c=Max(n,m);
    for(register int i=1;i<=n;++i)
    {
        a[i]=read();
        ++cnt[a[i]+=c];
    }
    ql=c+1,qr=c+n,lim=c*2+n;
    for(register int i=m+1;i<=qr;++i)
        ++b[i-cnt[i]+1],--b[i+1];
    for(register int i=2;i<=qr+1;++i)
        b[i]+=b[i-1];
    build(1,1,lim);
    for(register int i=1;i<=m;++i)
    {
        int opt=read(),x=read();
        if(opt)
        {
            --cnt[a[opt]];
            if(a[opt]<=qr)
                modify(1,1,lim,a[opt]-cnt[a[opt]],a[opt]-cnt[a[opt]],-1);
            a[opt]=x+ql-1;
            modify(1,1,lim,a[opt]-cnt[a[opt]],a[opt]-cnt[a[opt]],1);
            ++cnt[a[opt]];
        }
        else
        {
            if(x==1)
            {
                if(cnt[qr])
                    modify(1,1,lim,qr-cnt[qr]+1,qr,-1);
                --ql,--qr;
            }
            else
            {
                ++ql,++qr;
                if(cnt[qr])
                    modify(1,1,lim,qr-cnt[qr]+1,qr,1);
            }
        }
        write(query(1,1,lim,ql,qr)),puts("");
    }
    return 0;
}

```

---

## 作者：KokiNiwa (赞：3)

这是一个有意思的题目。而且方法不当的话会觉得非常麻烦。

## 题解

按照值域我们把每个数的出现次数画成一根根的柱子，然后把柱子向左推导，$[1,n]$中未被覆盖的区间长度就是答案。于是问题变成了单点修改值，即修改两根柱子的长度。全体修改就可以理解为询问区间的平移。那么只需要拿线段树维护这个东西就行了。——摘自yyb的博客

补充一下如何维护。需要维护每个位置被覆盖的次数和区间覆盖次数的最小值与最小值出现的次数，查询的时候查询0的个数就可以了。

## 代码

[code](https://loj.ac/submission/731382)

~~代码也是对着yyb的代码写的~~

## 小问题

+ 在整体平移的时候需要看是不是有些点从外面平移到里面或者从里面平移到外面（指的是区间$[1,n]$的里面和外面）。平移到外面的就不能算了。

## 一些思考

开始这道题我想的是用线段树完成覆盖问题。但是由于我们不但要加区间，还要删区间，就只能统计次数了，不能覆盖了。在没有意识到那个小问题之前其实是可以用区间覆盖的，每个位置再记录一个当前位置为终点的区间起始点，如果区间的长度变短1个的话就可以通过查询这个区间刚好覆盖不到的那个点，即原本覆盖得到后来覆盖不到的点能不能被其他区间覆盖到，这个可以通过查询后面的所有点的左端点最小值完成，但改成了删区间，一次减少一个区间而不是一个点，就无法通过这样的方法完成了。

## 知识点

+ 需要删除的区间覆盖问题可以通过统计每个点的覆盖次数完成。（当时脑子莫名坏掉导致忘记这件事......）
+ 开始的思维部分，想象成形象的柱子推倒其实还挺形象的（其实就是覆盖前面一段区间）。

---

## 作者：Purslane (赞：1)

# Solution

看到修改序列，想到肯定是数据结构维护什么东西。但是，我们最好学会不修改的时候如何计算答案。

考虑到最大的数最后必须是 $n$，因为最大的数必须能删掉。如果我们手头有一些 $n$，那真的是太好不过了，我可以再去删 $n-cnt_n$ 了。

可以考虑我们有多少个数不用改。如果我们在 $n-cnt_n$ 之前有别的数 $v$，那么如果 $v$ 全部用完还是到达不了 $n-cnt_n$，那么 $v$ 相当于是废掉了，我们统计答案的时候不能把它算上；如果 $v$ 很强，它用完之后在 $n-cnt_n$ 之前，那么我们可以把 $v$ 以后的 $n$ 的部分改为 $v$。综合两种情况，也就是重叠的部分浪费了。

这个过程非常像**区间覆盖**。一个地方拿油漆刷两次，第二次刷的染料实际上浪费了。所以答案就是我们把所有的 $[i-cnt_i+1,i]$ 都染上色之后，$[1,n]$ 中没有被染色的部分的长度。

注意如果一个线段的右端点比 $n$ 大那么不应当让他覆盖，因为 $v-cnt_v+1$ 可能比 $n$ 小但实际上产生不了贡献。

剩下的就好做了。对于 $p>0$ 直接单点修改。$p=0$ 进行相对运动，也就是最终查询的区间 $[1,n]$ 在动。

于是我们出现了负数下标，不过很容易补救。

代码：
```cpp
/*
我们在第 x 点有 cnt_x 个数 那么可以将 [x-cnt_x+1,x] 给覆盖
我们可以认为 x 不动 , 动的是 [1,n]
故有可能遇到负的
现在你的问题是区间加区间减区间询问 0 的个数
而 0 的个数就是区间最小值的个数 这是很好处理的 
*/
#include<bits/stdc++.h>
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=600000+10;
int n,m,dt=300000,st,a[MAXN],cnt[MAXN];
namespace Segment_Tree {
	int mn[MAXN<<2],mns[MAXN<<2],tag[MAXN<<2];	
	#define lson (k<<1)
	#define rson (k<<1|1)
	#define mid (l+(r-l)/2)
	void build(int k,int l,int r) {
		mns[k]=r-l+1;
		if(l==r) return ;
		build(lson,l,mid),build(rson,mid+1,r);
		return ;	
	}
	void push_down(int k,int l,int r) {
		mn[lson]+=tag[k],mn[rson]+=tag[k],tag[lson]+=tag[k],tag[rson]+=tag[k],tag[k]=0;
		return ;	
	}
	void push_up(int k,int l,int r) {
		mn[k]=min(mn[lson],mn[rson]),mns[k]=0;
		if(mn[k]==mn[lson])	mns[k]+=mns[lson];
		if(mn[k]==mn[rson]) mns[k]+=mns[rson];
		return ;
	}
	void update(int k,int l,int r,int x,int y,int v) {
		if(x<=l&&r<=y) return tag[k]+=v,mn[k]+=v,void();
		push_down(k,l,r);
		if(x<=mid) update(lson,l,mid,x,y,v);
		if(y>mid) update(rson,mid+1,r,x,y,v);
		push_up(k,l,r);
		return ;
	}
	pair<int,int> query(int k,int l,int r,int x,int y) {
		if(x<=l&&r<=y) return {mn[k],mns[k]};
		push_down(k,l,r);
		if(y<=mid) return query(lson,l,mid,x,y);
		if(x>mid) return query(rson,mid+1,r,x,y);
		auto pr1=query(lson,l,mid,x,y);
		auto pr2=query(rson,mid+1,r,x,y);
		if(pr1.first<pr2.first) return pr1;
		if(pr1.first>pr2.first) return pr2;
		return {pr1.first,pr1.second+pr2.second};	
	}
}using namespace Segment_Tree;
int main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>n>>m; ffor(i,1,n) cin>>a[i],cnt[a[i]+dt]++;
	build(1,-dt,dt);
	ffor(i,1,n) if(cnt[i+dt]) update(1,-dt,dt,i-cnt[i+dt]+1,i,1);
	ffor(i,1,m) {
		int p,x; cin>>p>>x;	
		if(p) {
			int nx=x+st;
			if(a[p]<=n+st) update(1,-dt,dt,a[p]-cnt[a[p]+dt]+1,a[p]-cnt[a[p]+dt]+1,-1);
			cnt[dt+a[p]]--,a[p]=nx;
			cnt[dt+a[p]]++;
			if(nx<=n+st) update(1,-dt,dt,a[p]-cnt[a[p]+dt]+1,a[p]-cnt[a[p]+dt]+1,1);	
		}
		else {
			if(x==1) {
				if(cnt[dt+n+st]) update(1,-dt,dt,n+st-cnt[dt+n+st]+1,n+st,-1);
				st--;
			}
			else {
				st++;
				if(cnt[dt+n+st]) update(1,-dt,dt,n+st-cnt[dt+n+st]+1,n+st,1);
			}
		}
		auto pr=query(1,-dt,dt,1+st,n+st);
		if(pr.first==0) cout<<pr.second<<'\n';
		else cout<<0<<'\n';
	}
	return 0;
}
```

---

## 作者：creation_hy (赞：1)

## 前言

好恶心的一题。。。

细节实在太多了。。。

## 思路

这题思路还是比较好想的。

最终序列满足从 $n$ 需要开始删数一直能删下去。

那么就可以把每个数要删的数量转成一个区间 $[x-cnt_x+1,x]$，当两个区间中间隔着一些空隙时，就需要填补它，否则的话删完这个区间就没办法再删下去了。

拿线段树维护即可，答案即为整个区间 $[1,n]$ 中所有空隙，即 $0$ 的数量。

两个区间重叠怎么办？很简单：只有 $n$ 个数，所以每多重叠一块地方，就会有一块地方没有被覆盖。

$0$ 的数量怎么维护呢？可以用区间最小值维护。

线段树维护四个东西：

$tag$ 表示加法懒标记，$c0$ 表示 $0$ 的数量，$mi$ 表示区间最小值，$cnt$ 表示最小值出现的次数。

如果经历修改后最小值为 $0$，就把 $cnt\to c0$，否则 $0\to c0$。

**注意：只要区间有修改，除了 `push_down` 只传递 `tag` 以外，一定要更新 `cnt` 和 `c0`！**

线段树部分还算比较简单。

操作部分的话，$p>0$ 时就是缩短原来值的区间，增长当前值的区间。

$p=0$ 的话，其实就是平移整张图，拿一个偏移量表示当前平移了多少格即可。

另外，负数的话也是要保存的。比如 $-5$，在经历了 $6$ 次整体加一后就会被移到 $[1,n]$ 中。

处理方法是，直接找一个比较大的数 $D$，然后给所有数都加上 $D$ 即可。

~~似乎可以更毒瘤一点，扩大值域，只有主席树能过~~

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 6e5 + 5;
const int D = 3e5;
typedef long long ll;
int n, m, num[N], a[N];
struct SegTree
{
    int tag[N << 3], c0[N << 3], mi[N << 3], cnt[N << 3];
    inline int ls(int p)
    {
        return p << 1;
    }
    inline int rs(int p)
    {
        return p << 1 | 1;
    }
    inline void push_up(int p)
    {
        mi[p] = min(mi[ls(p)], mi[rs(p)]);
        cnt[p] = 0;
        if (mi[p] == mi[ls(p)])
            cnt[p] += cnt[ls(p)];
        if (mi[p] == mi[rs(p)])
            cnt[p] += cnt[rs(p)];
        c0[p] = mi[p] ? 0 : cnt[p];
    }
    inline void push_down(int p)
    {
        mi[ls(p)] += tag[p];
        c0[ls(p)] = mi[ls(p)] ? 0 : cnt[ls(p)];
        mi[rs(p)] += tag[p];
        c0[rs(p)] = mi[rs(p)] ? 0 : cnt[rs(p)];
        tag[ls(p)] += tag[p];
        tag[rs(p)] += tag[p];
        tag[p] = 0;
    }
    inline void build(int p, int l, int r)
    {
        if (l == r)
        {
            mi[p] = 0;
            c0[p] = cnt[p] = r - l + 1;
            return;
        }
        int mid = l + r >> 1;
        build(ls(p), l, mid);
        build(rs(p), mid + 1, r);
        push_up(p);
    }
    inline void update(int p, int l, int r, int dl, int dr, int k)
    {
        if (dl <= l && r <= dr)
        {
            mi[p] += k;
            tag[p] += k;
            c0[p] = mi[p] ? 0 : cnt[p];
            // cout << l << ' ' << r << ' ' << mi[p] << ' ' << cnt[p] << ' ' << c0[p] << '\n';
            return;
        }
        push_down(p);
        int mid = l + r >> 1;
        if (dl <= mid)
            update(ls(p), l, mid, dl, dr, k);
        if (mid < dr)
            update(rs(p), mid + 1, r, dl, dr, k);
        push_up(p);
    }
    inline int query(int p, int l, int r, int qx, int qy)
    {
        if (qx <= l && r <= qy)
            return c0[p];
        push_down(p);
        int mid = l + r >> 1, res = 0;
        if (qx <= mid)
            res += query(ls(p), l, mid, qx, qy);
        if (mid < qy)
            res += query(rs(p), mid + 1, r, qx, qy);
        return res;
    }
} tr;
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n >> m;
    for (int i = 1; i <= n; i++)
        cin >> num[i], num[i] += D, a[num[i]]++;
    int st = 0;
    tr.build(1, 1, N);
    for (int i = D + 1; i <= D + n; i++)
        tr.update(1, 1, N, i - a[i] + 1, i, 1);
    while (m--)
    {
        int x, k;
        cin >> x >> k;
        if (x)
        {
            k = k + D - st;
            int last = num[x];
            if (last <= D + n - st)
                tr.update(1, 1, N, last - a[last] + 1, last - a[last] + 1, -1);
            a[last]--;
            a[k]++;
            if (k <= D + n - st)
                tr.update(1, 1, N, k - a[k] + 1, k - a[k] + 1, 1);
            num[x] = k;
        }
        else
        {
            if (k == 1)
            {
                int p = D + n - st;
                tr.update(1, 1, N, p - a[p] + 1, p, -1);
                st++;
            }
            else
            {
                st--;
                int p = D + n - st;
                tr.update(1, 1, N, p - a[p] + 1, p, 1);
            }
        }
        cout << tr.query(1, 1, N, D + 1 - st, D + n - st) << '\n';
    }
    return 0;
}
```

---

## 作者：541forever (赞：0)

下午忽然想找个数据结构练下手，忽然发现了这道颇有意思的题。首先，注意到我们删除的策略是能删就删，不能删就拿尽可能大的数换成当前序列的长度来删。因此，我们可以记录 $cnt_i$ 表示 $i$ 的出现次数，我们可以用这些数覆盖掉 $[i-cnt_i+1,i]$ 的数。那些在 $[1,n]$ 中一次都未被覆盖的数的个数就是答案。考虑拿线段树维护这个东西，单点改是容易的，直接在 $cnt$ 数组上改即可，而区间加减 $1$ 的操作可以考虑给全局打一个平移的 tag。在平移时注意一下平移后值变得大于 $n$ 的那个数的 $cnt$ 会全部失效，平移后值变得小于等于 $n$ 的那个数的 $cnt$ 会全部生效。一棵维护了区间最小值以及最小值的个数支持区间加的线段树即可支持上述操作。

---


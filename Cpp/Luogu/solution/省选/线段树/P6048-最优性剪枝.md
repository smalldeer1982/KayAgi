# 最优性剪枝

## 题目背景

Nauuo 是一名出题人。

众所周知，某些出题人非常懒，导致[随便爆搜](https://www.luogu.com.cn/discuss/show/185420)加上一个[最优性剪枝](https://www.luogu.com.cn/discuss/show/184641)就能通过。Nauuo 决定把这些 naive 的暴力都卡掉。

## 题目描述

Nauuo 决定卡一个暴力搜索程序，为此她构建了一组数据。为了简化题目，你将得到这组数据产生的搜索树 $T$。$T$ 中包含 $n$ 个节点，依次编号为 $1 \sim n$，其中 $1$ 号点是 $T$ 的根节点。一个节点的深度是它到 $1$ 号点的简单路径上的节点个数。

这个程序的伪代码如下

```cpp
answer := inf

procedure dfs(node,depth)
	if (node is leaf) 
		answer := min(answer,depth)
		return
	if (depth < answer)
		for i in children of node
			dfs(i,depth+1)

dfs(1,1)
```

其中，`:=` 表示赋值运算。

翻译成人话就是说，这个暴力搜索程序将**深度优先**地遍历这棵搜索树，当访问到一个叶节点时，这个程序将用这个叶节点的深度更新答案。

同时，这个程序有一个最优性剪枝，也就是说，当这个程序访问到任意一个深度等于答案的节点时，它将不会再访问这个节点的子节点。

然而，可怜的 Nauuo 并不知道这个程序在某个节点时访问自己子节点的顺序，因此她认为每个节点访问子节点的顺序都是在所有可能的情况中等概率随机的，显然，一共有 $\prod d_i!$ 种情况，其中 $d_i$ 表示 $i$ 号节点的子节点数量。

现在她想知道这个程序访问到的节点数量的期望，以确定这个程序会不会被自己的数据卡掉。

为了避免浮点误差，答案对 $998244353$ 取模。保证答案能被表示为最简分数 $\frac{p}{q}$，你只需要输出一个 $x (0\leq x < 998244353)$ 使得 $qx \equiv p \pmod {998244353}$。

## 说明/提示

#### 样例解释

第一组样例的真实答案为 $\frac{7}{2}$。

一共只有两种情况，如果 $1$ 号节点先遍历 $3$ 号节点，则程序将访问到搜索树中所有节点。如果 $1$ 号节点先遍历 $2$ 号节点，则 $4$ 号节点不会被访问到。

第二组样例中，每个非叶节点的子节点都是唯一的，因此只有一种可能的情况，所有节点都必然被访问到。

第三组样例的真实答案为 $\frac{94}{9}$。

---

#### 数据范围

**「本题采用捆绑测试」**

对于所有测试点，保证 $1 \leq n \leq 3\times 10^5$，$1 \leq p_i < i$。

$\text{Subtask 1 (11 pts)}$ $n \leq 9$。

$\text{Subtask 2 (18 pts)}$ $n \leq 100$。

$\text{Subtask 3 (19 pts)}$ $n\leq 10^3$。

$\text{Subtask 4 (4 pts)}$ $p_i = i-1$。

$\text{Subtask 5 (8 pts)}$ $p_i =\lfloor \frac{i}{2} \rfloor$。

$\text{Subtask 6 (40 pts)}$ 无特殊限制。

---

#### 提示

如果你不知道怎么对分数取模，可以参考[这里](https://www.luogu.com.cn/problem/P3811)。



## 样例 #1

### 输入

```
4
1 1 3```

### 输出

```
499122180```

## 样例 #2

### 输入

```
3
1 2```

### 输出

```
3```

## 样例 #3

### 输入

```
13
1 1 1 3 5 4 2 3 7 4 4 6```

### 输出

```
776412285```

# 题解

## 作者：Zory (赞：2)

虽然我没有出题水平，不过感觉这题质量和难度一般般，可能是时间的缘故较少人过

官方题解中提到可以用树状数组写，给大家一份代码，因为没细看官方题解不知道其他思路是否一致

首先显然将答案写成 $\sum_x x$ 被访问到的概率，这个是基本的期望线性性，然后这里x被访问到的条件为没有访问过dep更小的点

于是容易得到一个复杂度不重要的暴力：

```cpp
vc<int> son[N];int ff[N],val[N],dep[N];
void pre(int x){ dep[x]=dep[ff[x]]+1;val[x]=(!sz(son[x])?dep[x]:INF);for(auto y:son[x]) pre(y),chmin(val[x],val[y]); }
void main()
{
    int n=qread();fo(i,2,n) son[ff[i]=qread()].PB(i);pre(1);
    fo(x,1,n) sort(all(son[x]),[&](int x,int y){return val[x]<val[y];});
    ll ans=0;
    fo(x,1,n)
    {
        ll now=1;
        for(int anc=ff[x],lst=x;anc;lst=anc,anc=ff[anc])
        {
            int cnt=0;for(auto y:son[anc]) if(y!=lst and val[y]<dep[x]) cnt++;
            now=now*invm(cnt+1)%MOD;
        }add(ans,now);
    }write(ans);
}
```

容易发现很明显每个点的权值应该是容易维护的。具体的，将孩子排序，从孩子i切换到孩子i+1时，变化的只有$[val_i,val_{i+1})=\frac{1}{i} \to \frac{1}{i+1}$，于是用个树状数组维护乘法差分即可，$O(nlogn)$

```cpp
namespace BIT
{
    ll bit[N];void clear(){ fo(i,1,N-1) bit[i]=1; }
    int lowbit(int x){return x&-x;}
    void mul(int x,ll c){ while(x<N) bit[x]=bit[x]*c%MOD,x+=lowbit(x); }
    void MUL(int l,int r,ll c){ mul(l,c),mul(r,invm(c)); }//[l,r)*=c
    ll ask(int x){ ll ret=1;while(x>=1) ret=ret*bit[x]%MOD,x-=lowbit(x);return ret; }
};
ll ans=0;
void solve(int x)
{
    add(ans, BIT::ask(dep[x]-1) );
    int m=sz(son[x]);
    #define V(i) (i>m?N:val[son[x][i-1]])
    fo(i,2,m) BIT::MUL(V(i),V(i+1),invm(i));
    fo(i,1,m)
    {
        int y=son[x][i-1];solve(y);
        if(i<m) BIT::MUL(V(i),V(i+1),i*invm(i+1)%MOD);
    }
    fo(i,1,m-2) BIT::MUL(V(i),V(i+1),i+1);if(m>1) BIT::MUL(V(m-1),N,m);
}
```

---

## 作者：Owen_codeisking (赞：1)

考试的时候没时间了，代码没写，口胡一下。

[官方题解](https://www.luogu.com.cn/blog/EternalAlexander/ea-practice-solution)


沿用题解中 subtask3 的做法，考虑每个点的贡献。枚举这个点 $x$ 和这个点的祖先 $y$，若一个点有 $n$ 个儿子，有 $m$ 个儿子子树中叶子深度最小值 $mindep<dep_x$，那么方案数为 $\Large\frac {n!}{m+1}$。注意，这 $m$ 个儿子不包括儿子 $z$，$y\rightarrow z$ 且 $x$ 在 $z$ 的子树中。其他的常数部分很简单，我们就看这部分的贡献。

现在我们需要动态维护每个点小于某个值儿子的个数，询问一条链每个值减去 $z$ 的贡献的乘积。如果没有 $z$ 的贡献，那么直接排个序，每次修改的时候更新父亲的值，用线段树就能出答案。

但是有 $z$ 的贡献的话，有些值需要减一，有些值不需要减。可以发现一个点不断往上跳的话，每个点的 $mindep$ 是单调不增的。我们可以倍增出一个点，正好 $mindep_z\ge dep_x$，从 $fa_x\rightarrow fa_z$ 上是没有 $z$ 的贡献的，剩下的到根的值是有 $z$ 的贡献的。这段区间是连续的，所以可以快速计算。

我们可以多维护一个儿子减一的乘积的线段树，这样把两段拼起来就是祖先的答案。如果这里直接使用树剖的话，时间 $O(n\log^2 n)$，肯定能过。

但是我们不需要这样，我们把单点修改区间查询改一改，每次修改的时候把子树乘一下，查询的时候单点查，这样就省去了树剖，只需要倍增和线段树就能解决该问题。

当然，逆元啥的肯定要预处理。时间 $O(n\log n)$，大概是比标程的线段树合并，长链剖分啥的常数小一点？

有时间写完再把代码贴上来。

---


# 【模板】线段树 3（区间最值操作、区间历史最值）

## 题目背景

本题是线段树维护区间最值操作与区间历史最值的模板。

## 题目描述

给出一个长度为 $n$ 的数列 $A$，同时定义一个辅助数组 $B$，$B$ 开始与 $A$ 完全相同。接下来进行了 $m$ 次操作，操作有五种类型，按以下格式给出：

- `1 l r k`：对于所有的 $i\in[l,r]$，将 $A_i$ 加上 $k$（$k$ 可以为负数）。
- `2 l r v`：对于所有的 $i\in[l,r]$，将 $A_i$ 变成 $\min(A_i,v)$。
- `3 l r`：求 $\sum_{i=l}^{r}A_i$。
- `4 l r`：对于所有的 $i\in[l,r]$，求 $A_i$ 的最大值。
- `5 l r`：对于所有的 $i\in[l,r]$，求 $B_i$ 的最大值。

在每一次操作后，我们都进行一次更新，让 $B_i\gets\max(B_i,A_i)$。


## 说明/提示

#### 样例说明 \#1 ####

| 操作次数 | 输入内容 | 操作 | 数列 | 输出结果 |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| 0 |  |  | $1,2,3,4,5$ |  |
| 1 | `3 2 5` | 求出 $[2,5]$ 所有数的和 | $1,2,3,4,5$ | `14` |
| 2 | `1 1 3 3` | 将 $[1,3]$ 内所有数加 $3$ | $4,5,6,4,5$ |  |
| 3 | `4 2 4` | 求出 $[2,4]$ 所有数的最大值 | $4,5,6,4,5$ | `6` |
| 4 | `2 3 4 1` | 将 $[3,4]$ 所有数与 $1$ 取最小值 | $4,5,1,1,5$ |  |
| 5 | `5 1 5` | 求出 $[1,5]$ 所有位置历史最大值的最大值 | $4,5,1,1,5$ | `6` |
| 6 | `3 1 4` | 求出 $[1,4]$ 所有数的和 | $4,5,1,1,5$ | `11` |

#### 数据规模与约定

- 对于测试点 $1,2$，满足 $n,m\leq 5000$；
- 对于测试点 $3,4$，满足 $op\in\{1,2,3,4\}$；
- 对于测试点 $5,6$，满足 $op\in\{1,3,4,5\}$；
- 对于全部测试数据，保证 $1\leq n,m\leq 5\times 10^5$，$-5\times10^8\leq A_i\leq 5\times10^8$，$op\in[1,5]$，$1 \leq l\leq r \leq n$，$-2000\leq k\leq 2000$，$-5\times10^8\leq v\leq 5\times10^8$。

#### 提示 ####

本题输入量较大，请使用合理高效的读入方法。


## 样例 #1

### 输入

```
5 6
1 2 3 4 5
3 2 5
1 1 3 3
4 2 4
2 3 4 1
5 1 5
3 1 4
```

### 输出

```
14
6
6
11
```

# 题解

## 作者：Utilokasteinn (赞：416)

## [P6242 【模板】线段树 3](https://www.luogu.com.cn/problem/P6242)

### 题目简介

给你一个长度为 $n$ 的序列 $a$。最开始令序列 $b=a$。

现在进行 $m$ 次操作，分为 $5$ 种：

- ```1 l r k```：将 $a_l\sim a_r$ 加上 $k$。

- ```2 l r v```：将 $a_l\sim a_r$ 对 $v$ 取最小值。

- ```3 l r```：求 $a_l\sim a_r$ 的和。

- ```4 l r```：求 $a_l\sim a_r$ 的最大值。

- ```5 l r```：求 $b_l\sim b_r$ 的最大值。

每次操作后令 $b_{i}=\max(b_{i},a_{i})$ 。

------------

### 思路

前置知识：只要会写线段树 $1$。

吉司机线段树模版题，考虑用线段树维护。（大雾）

先讲一些基础的东西，会的可以直接跳到后面。

我们从线段树 $1$ 开始。线段树 $1$ 的操作就是操作 $1$ 和 $3$。

先考虑解决操作 $4$，求区间最大值。

每个节点维护一个 $\tt maxn$ 表示该节点表示的区间的最大值。

区间加时就直接把这个 $\tt maxn$ 加上 $k$。标记下传的时候也是同理。查询的时候就方便了。

现在我们解决了操作 $1,3$ 和 $4$。

接下来我们尝试解决操作 $5$。

先引入 $2$ 个概念：

- $a_i$ 的历史最（小$/$大）值：$a_{i}$ 存放过的最（小$/$大）的数。

- 区间最（小$/$大）值操作：将 $a_l\sim a_r$ 中的数 $a_{i}$ 变为 $\min(a_i,v)$ 或 $\max(a_i,v)$。

显然在这题中，$b_i$ 就是 $a_i$ 的历史最大值，操作 $2$ 就是区间最小值操作，操作 $5$ 是求区间最大历史最大值。

看完上面的定义后，再来尝试解决一下。

操作 $5$ 的瓶颈在于区间加后无法快速更新序列 $b$。

因为一个区间总能被若干个点表示，我们先将一个区间先简化一个节点。

我们在区间加时，会对一个区间加上 $k$。

若 $k>0$，历史最大值可能被更新。

在 $k=0$，相当于什么也没做。

若 $k<0$，历史最大值不可能被更新。

想象一下我们正在对一个节点（不是任意区间）进行疯狂的区间加，此时也就是该节点的 $\tt tag$ 在一直被改变。

经过一次加法，这个 $\tt tag$ 可能变大（$k>0$），也可能变小（$k<0$）。

但是我们注意到，那么在标记下传前，当前节点的儿子的值是不会变的。

**那么显然，当 $\tt tag$ 达到最大时，下传的时候才可以使儿子达到当前最大。而只有当前最大才有可能更新历史最大。**

假设这个这个 $\tt tag$ 为 $\tt tag1$。

那么，我们只需要再设一个 $\tt tag2$ 来表示**没下传前的最大 $\tt tag1$**，那么下传更新序列 $b$ 就容易了。

注意下传时的顺序，要先更新 $\tt maxb$ 再更新 $\tt maxa$，先更新 $\tt tag2$ 再更新 $\tt tag1$。

可以过测试点 $5$ 和 $6$ 的[代码](https://www.luogu.com.cn/paste/0n5li3ba)，再往下就是完整的代码。

这里一定要理解透，不然后面肯定都看不懂。

------------
接下来进入正题，如何解决操作 $2$。

容易发现这道题的瓶颈在于进行操作 $2$ 后，无法快速更新信息，不仅区间历史最大值更新不了，甚至连区间和都不好更新。只能递归到叶子节点，然后对其取最小值，然后返回。

这样写单次修改的时间复杂度就会达到惊人的 $\mathcal{O}(n)$。

那怎么办呢？

线段树显然不能直接区间取 $\min$。

我们可以换一个思路，可以**把区间内大于 $v$ 的数都减去一个数，使得这些数都变为 $v$**。

因为不同的数要减去不同的数才能等于 $v$，显然我们不能设很多 $\tt tag$ 来表示区间内不同的数要减去的数。

那退一步来讲，若**区间内大于 $v$ 的数只有一种**，我们可以怎么做呢？

只需要维护一个 $\tt tag$ 就行了。

那怎样才能使得区间内大于 $v$ 的数只有一种呢？

只需要多递归几次就行了。

我们在线段树每个节点设以下 $3$ 个变量，分别为：

- $\tt maxn$：该区间的最大值。

- $\tt se$：该区间的严格次大值，也就是最大的比最大值小的值。

- $\tt cnt$：该区间的最大值的个数。

因为只有在区间只有一种数大于 $k$ 的时候我们才能快速更新，即只能在满足 $\tt se$ $<k<$ $\tt maxn$ 的节点上更新。

综上所述，解决方法就是**在线段树中递归，直到该区间大于 $v$ 的数只有一种就更新**。

这样做总的时间复杂度为 $\mathcal{O}(m\log^2n)$，但我不会证。

因为有人说只需要设 $3$ 个 $\tt tag$，这显然是不行的~~吧~~。所以再来说明一下为什么需要设 $4$ 个 $\tt tag$。

在没有操作 $2$ 的情况下，我们就设了 $2$ 个 $\tt tag$，来维护整个区间。

现在加入了区间取 $\min$ 操作。而区间取 $\min$ 操作只会更新区间最大值。

那么我们就需要把最大值和非最大值分开来维护，故要设 $4$ 个 $\tt tag$。

换句话说，如果不设 $4$ 个 $\tt tag$，就更新不了非最大历史最大值的历史最大值了。

------------
### 代码及其理解

首先说明，本题解主要以代码为主。个人认为代码写得很清晰，如果懂得上述思路就一定可以看懂。

先来看一下线段树每个节点需要存些什么。

以下是需要维护的 $\tt tag$：

- $\tt add1$：**该区间最大值的懒标记**。

- $\tt add2$：**该区间非最大值的懒标记**。

- $\tt add3$：**该区间最大值的懒标记的最大值**。

- $\tt add4$：**该区间非最大的值的懒标记的最大值**。

**具体地，$\tt add3$ 是在未下传懒标记前最大的 $\tt add1$ 的值，$\tt add4$ 是在未下传懒标记前最大的 $\tt add2$ 的值。**

这 $4$ 个 $\tt tag$ 只要理解透了，代码就一定可以看得懂。

其他就简单了，具体详见代码。

这里需要注意，一个区间可能只有一种数，这样就没有区间严格次大值。这时我们需要给 $\tt se$ 赋一个极小值。

建树代码如下：

```cpp
struct segment_tree{
	ll sum;
	int l,r,maxa,cnt,se,maxb;
	int add1,add2,add3,add4;
}s[2000005];
inline void push_up(int p)
{
	s[p].sum=s[p*2].sum+s[p*2+1].sum;
	s[p].maxa=max(s[p*2].maxa,s[p*2+1].maxa);
	s[p].maxb=max(s[p*2].maxb,s[p*2+1].maxb);
	if(s[p*2].maxa==s[p*2+1].maxa)
	{
		s[p].se=max(s[p*2].se,s[p*2+1].se);
		s[p].cnt=s[p*2].cnt+s[p*2+1].cnt;
	}
	else if(s[p*2].maxa>s[p*2+1].maxa)
	{
		s[p].se=max(s[p*2].se,s[p*2+1].maxa);
		s[p].cnt=s[p*2].cnt;
	}
	else
	{
		s[p].se=max(s[p*2].maxa,s[p*2+1].se);
		s[p].cnt=s[p*2+1].cnt;
	}
}
void build(int l,int r,int p)
{
	s[p].l=l,s[p].r=r;
	if(l==r)
	{
		s[p].sum=s[p].maxa=s[p].maxb=read();
		s[p].cnt=1,s[p].se=-2e9;
		return;
	}
	int mid=(l+r)/2;
	build(l,mid,p*2);
	build(mid+1,r,p*2+1);
	push_up(p);
}
```
------------
查询与普通的线段树无异，注意求和要开 ```long long```。

代码如下：

```cpp
ll query_sum(int p)
{
	if(l>s[p].r||r<s[p].l)return 0;
	if(l<=s[p].l&&s[p].r<=r)return s[p].sum;
	push_down(p);
	return query_sum(p*2)+query_sum(p*2+1);
}
int query_maxa(int p)
{
	if(l>s[p].r||r<s[p].l)return -2e9;
	if(l<=s[p].l&&s[p].r<=r)return s[p].maxa;
	push_down(p);
	return max(query_maxa(p*2),query_maxa(p*2+1));
}
int query_maxb(int p)
{
	if(l>s[p].r||r<s[p].l)return -2e9;
	if(l<=s[p].l&&s[p].r<=r)return s[p].maxb;
	push_down(p);
	return max(query_maxb(p*2),query_maxb(p*2+1));
}
```
------------
我们先来看一下修改时要如何维护 $\tt tag$ 以及其信息。

先是区间加修改的代码：
```cpp
void update_add(int p)
{
	if(l>s[p].r||r<s[p].l)return;
	if(l<=s[p].l&&s[p].r<=r)
	{
		s[p].sum+=1ll*k*s[p].cnt+1ll*k*(s[p].r-s[p].l+1-s[p].cnt);
		s[p].maxa+=k;
		s[p].maxb=max(s[p].maxb,s[p].maxa);
		if(s[p].se!=-2e9)s[p].se+=k;
		s[p].add1+=k,s[p].add2+=k;
		s[p].add3=max(s[p].add3,s[p].add1);
		s[p].add4=max(s[p].add4,s[p].add2);
		return;
	}
	push_down(p);
	update_add(p*2),update_add(p*2+1);
	push_up(p);
}
```

根据 $\tt tag$ 的定义，不难写出以上代码。

就是不管最大值还是非最大值，都加上 $k$，维护一下区间和。

然后 $\tt tag$ 也不需要管是否为最大值，都加上 $k$。

最后记录一下未下传前最大的 $\tt tag$ 的值是多少。

接着就是区间取 $\min$ 的代码：

```cpp
void update_min(int p)
{
	if(l>s[p].r||r<s[p].l||v>=s[p].maxa)return;
	if(l<=s[p].l&&s[p].r<=r&&s[p].se<v)
	{
		int k=s[p].maxa-v;
		s[p].sum-=1ll*s[p].cnt*k;
		s[p].maxa=v,s[p].add1-=k;
		return;
	}
	push_down(p);
	update_min(p*2),update_min(p*2+1);
	push_up(p);
}
```
代码做的事大致就是，先递归到一个满足 $\tt se$ $<v<$ $\tt maxa$ 的节点，然后将区间最大值都变为 $v$，更新区间和，区间最大值以及 $\tt tag$。

因为只修改最大值，所以只用更新 $\tt add1$。因为是取 $\min$，所以肯定不会更新历史最大值。

------------
最后来看一下本题的难点，```push_down``` 是如何下传懒标记。

先放上代码：

```cpp
inline void change(int k1,int k2,int k3,int k4,int p)
{
	s[p].sum+=1ll*k1*s[p].cnt+1ll*k2*(s[p].r-s[p].l+1-s[p].cnt);
	s[p].maxb=max(s[p].maxb,s[p].maxa+k3);
	s[p].maxa+=k1;
	if(s[p].se!=-2e9)s[p].se+=k2;
	s[p].add3=max(s[p].add3,s[p].add1+k3);
	s[p].add4=max(s[p].add4,s[p].add2+k4);
	s[p].add1+=k1,s[p].add2+=k2;
}
inline void push_down(int p)
{
	int maxn=max(s[p*2].maxa,s[p*2+1].maxa);
	if(s[p*2].maxa==maxn)
	    change(s[p].add1,s[p].add2,s[p].add3,s[p].add4,p*2);
	else change(s[p].add2,s[p].add2,s[p].add4,s[p].add4,p*2);
	if(s[p*2+1].maxa==maxn)
		change(s[p].add1,s[p].add2,s[p].add3,s[p].add4,p*2+1);
	else change(s[p].add2,s[p].add2,s[p].add4,s[p].add4,p*2+1);
	s[p].add1=s[p].add2=s[p].add3=s[p].add4=0;
}
```
看着就很恶心，但其实也不难。

```push_down``` 中是判断该区间的最大值是否位于左区间或右区间，是就下传最大值的 $\tt tag$，否则就下传非最大值的 $\tt tag$。

```change``` 就是下传 $\tt tag$ 以及更新儿子的信息。根据各个 $\tt tag$ 的定义都不难写出。

注意下传的顺序。

最后记得清空 $\tt tag$。

如果看不懂，就把测试点 $5$ 和 $6$ 的代码理解透彻了再来看。

------------
### 注意事项&常数优化

1. 使用快读和快写。 

2. 求和开 ```long long```。

3. 只有求和才开 ```long long```，其他用 ```int```。这样可以比全用 ```long long``` 快半秒左右。

4. 递归的时候参数尽量少。

5. 用一个结构体来储存树的各种信息，这样空间访问较连续，速度较快。

6. 在建树的时候读入，可以一定的节省空间和时间。

7. 加一些函数前加 ```inline```。

8. 修改时的更新可以用 ```change``` 代替，可以减少大量码量。

9. 注意更新顺序。

------------
### 其他

最后附上 [AC Code](https://www.luogu.com.cn/paste/0n5li3ba)，在第一篇代码的下面。

参考资料：

- [灵梦の题解](https://www.luogu.com.cn/blog/Hakurei-Reimu/solution-p6242)。

- [灵梦の洛谷日报](https://www.luogu.com.cn/blog/Hakurei-Reimu/seg-beats)。

- [OI-Wiki](http://oi-wiki.com/ds/seg-beats/)。

$\tt Updated\;on\;10.3,2020$：整篇重写。

$\tt Updated\;on\;7.31,2021$：补充了之前少写的 ```update_add```。大面积修改，删减。

$\tt Updated\;on\;4.17,2022$：几乎整篇重写。

$\tt Updated\;on\;8.14,2022$：修改了一些小错误。重写了半篇，减少了文字量，更新了代码。

$\tt Updated\;on\;1.8,2023$：删改了小部分内容，添加了部分内容，添加了测试点 $5$ 和 $6$ 的代码，解释了为什么要设 $4$ 个 $\tt tag$ 来维护。

---

## 作者：warzone (赞：152)

相信不少初学者对于 区间取 max/min 接受尚可，而对于 区间历史最值 一脸懵逼。
> 如果我们不满足于认识现有的结果，就要发掘出问题背后的脉络，  
> 认识到看起来“神机妙算”的证明，拆掉之前的**脚手架**长什么样。
> > Carl Friedrich Gauss: “凡是有自尊心的建筑师，在瑰丽的大厦建成之后，决不会把脚手架留在那里。”  
> 
> （摘自 EI's blog）

本文将指出，看似神机妙算的区间历史最值，其实是个简单的**线性代数**问题。

-----------------------------
首先我们要明晰线段树为什么能够实现区间信息的快速维护。  

对于 [【模板】线段树 1](https://www.luogu.com.cn/problem/P3372)：
> 给定序列 $a$，$m$ 次操作：
> - $\forall i\in[l,r],a_i\leftarrow a_i+k$ 。
> - 求 $\displaystyle\sum_{i=l}^r a_i$ 。

通过线段树上每个点存储 **所辖区间的 $a_i$ 之和**，即可实现快速查询。  

想一想为什么这么做是对的，易发现原因是 **加法满足结合律**：

$$a_l+a_{l+1}+\cdots+a_{mid}+a_{mid+1}+a_{mid+2}+\cdots+a_r$$
$$=(a_l+a_{l+1}+\cdots+a_{mid})+(a_{mid+1}+a_{mid+2}+\cdots+a_r)$$

接下来，通过在线段树上打 **懒标记** ，即可实现快速修改。

同样的，其原因是 **加法满足结合律和交换律**：

$$(a_i+k)+l=a_i+(k+l)$$

$$(a_l+k)+(a_{l+1}+k)+\cdots+(a_r+k)=(a_l+a_{l+1}+\cdots+a_r)+(r-l+1)k$$

在此基础上，对于[【模板】线段树 2](https://www.luogu.com.cn/problem/P3373)，分别维护加法和乘法标记，  
采取 **先乘后加** 的推标记方法，即可实现快速修改。  
其原因是 **乘法满足结合律**，且**对加法满足分配律**：
$$(a_i\times k)\times l=a_i\times(k\times l)$$
$$a_l\times k+a_{l+1}\times k+\cdots+a_r\times k=(a_l+a_{l+1}+\cdots+a_r)\times k$$

--------------------------------
接下来，我们看看最基础的区间历史最值问题。

> 给定序列 $a,b$，初始 $a=b$，$m$ 次操作：
> - $\forall i\in[l,r],a_i\leftarrow a_i+k$ 。
> - 求 $\displaystyle\max_{i=l}^ra_i$ 。
> - 求 $\displaystyle\max_{i=l}^rb_i$ 。
>   
> 每次操作后，我们都进行一次更新，让 $b_i\leftarrow \max(b_i,a_i)$。

这里，我们只要维护 $+,\max$ 两种运算，它们满足

- 交换律：$a+b=b+a,\max(a,b)=\max(b,a)$ 。
- 结合律：$(a+b)+c=a+(b+c),\max(\max(a,b),c)=\max(a,\max(b,c))$ 。
- 单位元：$a+0=0+a=a,\max(a,-\infty)=\max(-\infty,a)=a$ 。
- 加法逆元（相反数）：$a+(-a)=(-a)+a=0$ 。
- 分配律：$a+\max(b,c)=\max(a+b,a+c),\max(a,b)+c=\max(a+c,b+c)$ 。

这时，我们发现，如果将 $\max$ 作为矩阵元素的加法，  
$+$ 作为矩阵元素的乘法，就可用矩阵描述上面的操作：

> 维护向量序列 $\displaystyle\left\{{a_i\brack b_i}\right\},m$ 次操作：
> - $\forall i\in[l,r],\displaystyle{a_i\brack b_i}_{_{}}\leftarrow\begin{bmatrix}k&-\infty\\ -\infty&0\end{bmatrix}{a_i\brack b_i}$ 。
> - 求 $\displaystyle {a_l\brack b_l}+{a_{l+1}\brack b_{l+1}}+\cdots+{a_r\brack b_r}$，$+$ 为向量加法。  
> 
> 每次操作后，令 $\displaystyle{a_i\brack b_i}\leftarrow\begin{bmatrix}0&-\infty\\ 0&0\end{bmatrix}{a_i\brack b_i}$ 。


根据矩阵的运算律，相信大家已经发现了维护的方法：  
维护 向量之和 与 矩阵乘法标记 即可。

但 矩阵乘法标记 还可以再简化，因为

$$\begin{bmatrix}a&-\infty\\b&0\end{bmatrix}+\begin{bmatrix}c&-\infty\\d&0\end{bmatrix}=\begin{bmatrix}\max(a,c)&-\infty\\\max(b,d)&0\end{bmatrix}$$

$$\begin{bmatrix}a&-\infty\\b&0\end{bmatrix}\begin{bmatrix}c&-\infty\\d&0\end{bmatrix}=\begin{bmatrix}a+c&-\infty\\\max(b+c,d)&0\end{bmatrix}$$

于是对于 $\begin{bmatrix}c&-\infty\\d&0\end{bmatrix}$ 只要维护 $\displaystyle{c\brack d}$ 即可。

事实上，$c,d$ 即对应论文中的 “加减标记” 和 “历史最大加减标记”。

----------------------------
回到本题，本题在上面的基础上还支持区间取 $\min$ 和区间求和，即

> - $\forall i\in[l,r],a_i\leftarrow \min(a_i,k)$ 。
> - 求 $\displaystyle\sum_{i=l}^r a_i$ 。

回想下不维护区间历史最值时是怎样维护区间取 min 的。实际上，我们是通过摊还分析，  
划分最大值与次大值，将区间取 min 转化为 **对最大值的区间加减** 来维护的。

对于本题，沿用这一思路。  
我们将 $\displaystyle{a_i\brack b_i}$ 按照 $a_i$ 的大小划分 。具体地，每个节点维护如下信息：

- $\overrightarrow{mx}$：$a_i$ 最大的 $\displaystyle{a_i\brack b_i}_{}$ 之和。
- $\overrightarrow{se}$：$a_i$ 非最大的 $\displaystyle{a_i\brack b_i}$ 之和。
- 矩阵 $M$：对 $\overrightarrow{mx}$ 的矩阵乘法标记。
- 矩阵 $E$：对 $\overrightarrow{se}$ 的矩阵乘法标记。

线段树维护即可。

特别地，尽管区间求和不能用矩阵来表示，  
但也是可以集成到这棵线段树上的，这里留给读者作为思考题。

---------------------------
令我吃惊的是，在此之前并没有一篇题解是基于矩阵来理解吉老师线段树的，  
显然矩阵让各个操作的组织变得容易了许多。

希望这篇题解能让初学者不被繁杂的标记劝退，少走弯路，更深入地理解这个数据结构。

```cpp
/*
this code is made by warzone
2022.2.14 21:25
*/
#include<stdio.h>
#include<string.h>
typedef long long ll;
typedef unsigned int word;
struct READ{//快读
	char pool[5<<22],*top,w;
	inline READ(){fread(top=pool,5<<22,1,stdin);}
	template<typename type>
	inline READ& operator >>(type& num){
		for(w=1;'0'>*top||*top>'9';)
			w=*(top++)=='-'? -1:1;
		for(num=0;'0'<=*top&&*top<='9';)
			num=num*10+(*(top++)-'0');
		return num*=w,*this;
	}
}cin;
const int inf=0x80000000;//−∞
inline int max(const int a,const int b){
	return a>b? a:b;}
/* 向量/矩阵
⎡a⎤   ⎡a −∞⎤
⎣b⎦   ⎣b  0⎦
*/
struct matrix{
	int a,b;
	inline matrix(){}
	inline matrix(const matrix &p)=default;
	inline matrix(int A,int B):a(A),b(B){}
	inline matrix operator+(const matrix &p)const{//矩阵/向量 加法
		return matrix(max(a,p.a),max(b,p.b));}
	inline matrix operator()(const matrix &p)const{//矩阵乘法
		return matrix(a==inf||p.a==inf? inf:a+p.a,
			b==inf||p.a==inf? p.b:max(b+p.a,p.b));}
	inline bool operator!=(const matrix &p)const{
		return a!=p.a||b!=p.b;}
}const I(0,inf),vec0(inf,inf);
word n,m;
struct segment_tree{//线段树（zkw）
	ll sum[1u<<20];
	int cnt[1u<<20];
	matrix mx[1u<<20],M[1u<<20];
	matrix se[1u<<20],E[1u<<20];
	inline segment_tree(){
		for(word i=0;i<(1u<<20);++i) M[i]=E[i]=I;
		se[1u<<19]=vec0,cnt[1u<<19]=1,cin>>n>>m;
		for(int i=(1u<<19)+1,num;i<=(1u<<19|n);++i){
			se[i]=vec0,cnt[i]=1,cin>>num;
			sum[i]=mx[i].a=mx[i].b=num;
		}
		for(word i=(1u<<19|n)+1;i<(1u<<20);++i)
			se[i]=vec0,cnt[i]=1;
		for(word i=(1u<<19)-1;i;--i) pushup(i);
	}
	#define l (rt<<1)
	#define r (rt<<1|1)
	inline void pushup(const word rt){//上传信息
		sum[rt]=sum[l]+sum[r];
		if(mx[l].a>mx[r].a){
			mx[rt]=mx[l],cnt[rt]=cnt[l];
			se[rt]=se[l]+se[r]+mx[r];
		}else if(mx[l].a<mx[r].a){
			mx[rt]=mx[r],cnt[rt]=cnt[r];
			se[rt]=se[l]+se[r]+mx[l];
		}else{
			mx[rt]=mx[l]+mx[r];
			cnt[rt]=cnt[l]+cnt[r];
			se[rt]=se[l]+se[r];
		}
	}
	inline void Mmul(const matrix &p,const word id){//修改 mx
		mx[id]=p(mx[id]),M[id]=p(M[id]),sum[id]+=1ll*cnt[id]*p.a;}
	inline void Emul(const matrix &p,const word id,const word size){//修改 se
		se[id]=p(se[id]),E[id]=p(E[id]);
		sum[id]+=1ll*(size-cnt[id])*p.a;
	}
	inline void pushdown(const word rt,const word size){//下传标记
		Mmul(mx[l].a==mx[rt].a-M[rt].a? M[rt]:E[rt],l);
		Mmul(mx[r].a==mx[rt].a-M[rt].a? M[rt]:E[rt],r);
		//注意此处不能用 mx[l].a 和 mx[r].a 的大小关系来判断划分，因为标记下传后 mx 会被修改
		if(size!=1) Emul(E[rt],l,size),Emul(E[rt],r,size);
		M[rt]=E[rt]=I;
	}
	inline void plus(const word f,const word t,const int k,
		const word rt=1,const word size=1u<<18){//区间加
		if(size==0||(f==0&&t==(size<<1)-1))
			return Mmul(matrix(k,k),rt),Emul(matrix(k,k),rt,size? size<<1:1);
		auto lf=[&](word f,word t){plus(f,t,k,l,size>>1);};
		auto rf=[&](word f,word t){plus(f,t,k,r,size>>1);};
		pushdown(rt,size);
		if(f&size) rf(f&~size,t&~size);
		else if((t&size)^size) lf(f,t);
		else lf(f,size-1),rf(0,t&~size);
		pushup(rt);
	}
	inline void min(const word f,const word t,const int k,
		const word rt=1,const word size=1u<<18){//区间取 min
		if(k>=mx[rt].a) return;
		const auto lf=[&](word f,word t){min(f,t,k,l,size>>1);};
		const auto rf=[&](word f,word t){min(f,t,k,r,size>>1);};
		if(size==0||(f==0&&t==(size<<1)-1)){
			if(k>se[rt].a) return Mmul(matrix(k-mx[rt].a,k-mx[rt].a),rt);
			return pushdown(rt,size),lf(0,size-1),rf(0,size-1),pushup(rt);
		}
		pushdown(rt,size);
		if(f&size) rf(f&~size,t&~size);
		else if((t&size)^size) lf(f,t);
		else lf(f,size-1),rf(0,t&~size);
		pushup(rt);
	}
	inline ll getsum(const word f,const word t,
		const word rt=1,const word size=1u<<18){//区间求和
		if(size==0||(f==0&&t==(size<<1)-1)) return sum[rt];
		const auto lf=[&](word f,word t)->ll{return getsum(f,t,l,size>>1);};
		const auto rf=[&](word f,word t)->ll{return getsum(f,t,r,size>>1);};
		pushdown(rt,size);
		if(f&size) return rf(f&~size,t&~size);
		else if((t&size)^size) return lf(f,t);
		return lf(f,size-1)+rf(0,t&~size);
	}
	inline int geta(const word f,const word t,
		const word rt=1,const word size=1u<<18){//区间最值
		if(size==0||(f==0&&t==(size<<1)-1)) return mx[rt].a;
		const auto lf=[&](word f,word t)->ll{return geta(f,t,l,size>>1);};
		const auto rf=[&](word f,word t)->ll{return geta(f,t,r,size>>1);};
		pushdown(rt,size);
		if(f&size) return rf(f&~size,t&~size);
		else if((t&size)^size) return lf(f,t);
		return max(lf(f,size-1),rf(0,t&~size));
	}
	inline int getb(const word f,const word t,
		const word rt=1,const word size=1u<<18){//区间历史最值
		if(size==0||(f==0&&t==(size<<1)-1)) return max(mx[rt].b,se[rt].b);
		const auto lf=[&](word f,word t)->ll{return getb(f,t,l,size>>1);};
		const auto rf=[&](word f,word t)->ll{return getb(f,t,r,size>>1);};
		pushdown(rt,size);
		if(f&size) return rf(f&~size,t&~size);
		else if((t&size)^size) return lf(f,t);
		return max(lf(f,size-1),rf(0,t&~size));
	}
	#undef l
	#undef r
}tree;
int main(){
	for(int opt,l,r;m;--m)
		if(cin>>opt>>l>>r,opt==1)
			cin>>opt,tree.plus(l,r,opt);
		else if(opt==2) cin>>opt,tree.min(l,r,opt);
		else if(opt==4) printf("%d\n",tree.geta(l,r));
		else if(opt==5) printf("%d\n",tree.getb(l,r));
		else printf("%lld\n",tree.getsum(l,r));
    return 0;
}
```

---

## 作者：灵梦 (赞：150)

Update 3/29：修正了一些笔误和可能令人误解地方。

关于线段树维护区间最值操作和区间历史最值的完整方法，请参阅吉如一 2016 年的国家集训队论文 和 [我的洛谷日报](https://www.luogu.com.cn/blog/Hakurei-Reimu/seg-beats)。这篇题解大部分内容是复制于后者。谢谢大家给我的日报捧场 ^_^

## 概述 ##

首先假设我们有一个序列 $A$。那么，

- 区间最值操作是指，给定 $l,r,k$，对于所有 $i\in[l,r]$ ，将 $A_i$ 变成 $\min(A_i,k)$ 或 $\max(A_i,k)$ 的一种操作。

- 对于序列 $A$ 的某个位置 $i$，它的历史最值是指 $A_i$ 从初始化到当前达到的最大值 / 最小值，或者每一次修改操作后的值之和。我们把这三种分别称作历史最大值、历史最小值和历史版本和。而区间历史最值则是指求序列 $A$ 的历史最值的最大值 / 最小值或者代数和等的区间问题。

在这道题中，操作 $2$ 是区间最小值操作，操作 $5$ 是求历史最大值的区间最大值。

## 题解 ##

首先，让我们考虑只有操作 $2,3,4$ 的情况。我们发现，关于区间最大值的询问是可以使用带懒标记的线段树维护的，而区间和则不是很容易求出，因为这不能在下传标记时快速更新答案。

考虑到区间取 $\min$ 的操作只会对最大值不超过 $k$ 的节点产生影响，我们可以在这方面产生思路。为了使复杂度变对，线段树的一个节点要维护三个信息：区间最大值 $mx$，区间严格次大值 $se$ 和最大值的个数 $cnt$。那么，一次区间最值操作作用在这个节点上时，可以被分为以下三种情况：

- $k\geq mx$，此时该操作不会对当前节点产生影响，直接退出；
- $se<k<mx$，此时这个节点维护的区间中所有最大值都会被修改为 $k$，而最大值个数不变。将区间和加上 $cnt\cdot(k-mx)$ ，打上懒标记，然后退出即可；
- $k\leq se$，此时无法快速更新区间信息，因此我们需要继续递归到左右子树中，回溯时合并信息。

举个例子，现在要以 $k=2$ 对下面这棵线段树维护的区间取 $\min$。每个节点左侧表示区间最大值，右侧表示严格次大值。（很抱歉用了吉老师论文里的例子，因为我实在找不出比它更适合做例子的例子了）

![](https://cdn.luogu.com.cn/upload/image_hosting/2b77ype7.png)

按照上面描述的操作，我们应该沿着红色的边 DFS，最后在红色的节点上更新区间和并打上标记。

这样做的复杂度可以证明是 $O(m\log n)$ 的。原论文的证明使用了势能分析，这里给出一种更好懂的 $O((n+m)\log n)$ 下界的证明：

>显然只有暴力 DFS 的过程会影响复杂度，我们考虑一次区间最值操作中哪些节点会被搜索到。发现到达的节点区间中不同的数的个数（下称“值域”）一定会减少（因为至少将最大值与次大值合并了）。线段树每层节点表示的区间的值域一共是 $O(n)$ 的，一共 $\log$ 层加起来就是 $O(n\log n)$。再加上每次操作的复杂度，可以得到复杂度的一个下界为 $O((n+m)\log n)$。

然后，我们加入区间加减操作（操作 $1$）。发现上面方法的本质是把线段树上每个节点维护的元素分成了**最大值和非最大值**这两类，并对它们分别维护。区间最大值标记只会打在 $se<v<mx$ 的节点上，可以看成只针对最大值的加减操作；而区间加操作对于这两类值都生效。分别维护区间最大值的加减标记和非最大值的加减标记，下传时判断当前节点是否为区间最大值即可。

由于区间加减操作，某些节点的值域会增大。一次区间加减最多会影响 $O(\log^2n)$ 个节点的值域，所以用之前的证明方法可证复杂度的一个上界为 $O(n\log n+m\log^2n)$（论文里给的是 $O(m\log^2n)$）。而实际实现时会发现这个上界其实往往是跑不满的，速度几乎与大常数一个 $\log$ 接近。

目前为止，我们已经解决了测试点 $3,4$。在此总结一下，上面的这种处理区间最值的方法的核心是**数域的划分**。也就是说，我们以一个 $\log$ 的代价，将区间最值操作转化成了最值数域上的区间加减操作。

---

现在我们再考虑只有操作 $1,3,4,5$ 的情况。
我们在线段树的每个节点上维护两个值：区间当前最大值 $mx$ 和历史最大值 $mx'$，以及两个标记：区间加标记 $add$ 和历史最大加减标记 $add'$。这里唯一不容易理解的就是“历史最大加减标记”，它表示的是**从上一次下传 $add$ 到现在，区间加标记达到的最大值**。

考虑历史最值标记的合并。当节点 $x$ 下传标记到它的儿子 $ch$ 时，儿子历史最大值应与当前值取 $\max$，写成公式就是下面的样子：

$$add'_{ch}\gets\max(add'_{ch},add_{ch}+add'_x)$$

$$mx'_{ch}\gets\max(mx'_{ch},mx_{ch}+add'_x)$$

这样做的正确性是显然的，区间和可以用常规方法维护，复杂度为 $O(m\log n)$。于是我们又解决了测试点 $5,6$。

---

现在考虑将这两部分合并起来，在这里我们应用之前的思想，把一个区间的元素划分成最大值和非最大值两部分。那么区间最值操作可以转化为对最大值的加减操作，而题目中的区间加减则同时作用于这两类值。于是我们以一个 $\log$ 的代价把问题就变成了两个数域上的区间加减操作和历史最值询问。具体地说，我们需要维护四种标记：

- 最大值加减标记
- 最大值历史最大的加减标记
- 非最大值加减标记
- 非最大值历史最大的加减标记

前两个标记是只修改最大值的，所以下传时要判断当前节点是否包含区间最大值。总复杂度为 $O(m\log^2 n)$，需要注意一下常数。

如果有地方不太理解的话，可以看下面的代码：

```cpp
#include <cstdio>
#include <cctype>
#include <algorithm>
using namespace std;
typedef long long ll;
const int MAXN=550000;
const int INF=2E9+233;
int read()
{
	int x=0, w=0; char ch=0;
	while (!isdigit(ch)) w|=ch=='-', ch=getchar();
	while (isdigit(ch)) x=(x<<3)+(x<<1)+(ch^48), ch=getchar();
	return w?-x:x;
}
struct SegmentTree
{
	struct Node
	{
		int l, r;
		int mx, mx_, se, cnt; ll sum;
		int add1, add1_, add2, add2_;
	} tr[4*MAXN];
	#define lc (o<<1)
	#define rc (o<<1|1)
	void pushup(int o)
	{
		tr[o].sum=tr[lc].sum+tr[rc].sum;
		tr[o].mx_=max(tr[lc].mx_, tr[rc].mx_);
		if (tr[lc].mx==tr[rc].mx)
		{
			tr[o].mx=tr[lc].mx;
			tr[o].se=max(tr[lc].se, tr[rc].se);
			tr[o].cnt=tr[lc].cnt+tr[rc].cnt;
		}
		else if (tr[lc].mx>tr[rc].mx)
		{
			tr[o].mx=tr[lc].mx;
			tr[o].se=max(tr[lc].se, tr[rc].mx);
			tr[o].cnt=tr[lc].cnt;
		}
		else
		{
			tr[o].mx=tr[rc].mx;
			tr[o].se=max(tr[lc].mx, tr[rc].se);
			tr[o].cnt=tr[rc].cnt;
		}
	}
	void update(int o, int k1, int k1_, int k2, int k2_)
	{
		tr[o].sum+=1ll*k1*tr[o].cnt+1ll*k2*(tr[o].r-tr[o].l+1-tr[o].cnt);
		tr[o].mx_=max(tr[o].mx_, tr[o].mx+k1_);
		tr[o].add1_=max(tr[o].add1_, tr[o].add1+k1_);
		tr[o].mx+=k1, tr[o].add1+=k1;
		tr[o].add2_=max(tr[o].add2_, tr[o].add2+k2_);
		if (tr[o].se!=-INF) tr[o].se+=k2;
		tr[o].add2+=k2;
	}
	void pushdown(int o)
	{
		int tmp=max(tr[lc].mx, tr[rc].mx);
		if (tr[lc].mx==tmp)
			update(lc, tr[o].add1, tr[o].add1_, tr[o].add2, tr[o].add2_);
		else update(lc, tr[o].add2, tr[o].add2_, tr[o].add2, tr[o].add2_);
		if (tr[rc].mx==tmp)
			update(rc, tr[o].add1, tr[o].add1_, tr[o].add2, tr[o].add2_);
		else update(rc, tr[o].add2, tr[o].add2_, tr[o].add2, tr[o].add2_);
		tr[o].add1=tr[o].add1_=tr[o].add2=tr[o].add2_=0;
	}
	void build(int o, int l, int r, int* a)
	{
		tr[o].l=l, tr[o].r=r;
		tr[o].add1=tr[o].add1_=tr[o].add2=tr[o].add2_=0;
		if (l==r)
		{
			tr[o].sum=tr[o].mx_=tr[o].mx=a[l];
			tr[o].se=-INF, tr[o].cnt=1;
			return;
		}
		int mid=l+r>>1;
		build(lc, l, mid, a);
		build(rc, mid+1, r, a);
		pushup(o);
	}
	void modify1(int o, int l, int r, int k)
	{
		if (tr[o].l>r||tr[o].r<l) return;
		if (l<=tr[o].l&&tr[o].r<=r)
			{ update(o, k, k, k, k); return; }
		pushdown(o);
		modify1(lc, l, r, k), modify1(rc, l, r, k);
		pushup(o);
	}
	void modify2(int o, int l, int r, int k)
	{
		if (tr[o].l>r||tr[o].r<l||k>=tr[o].mx) return;
		if (l<=tr[o].l&&tr[o].r<=r&&k>tr[o].se)
			{ update(o, k-tr[o].mx, k-tr[o].mx, 0, 0); return; }
		pushdown(o);
		modify2(lc, l, r, k), modify2(rc, l, r, k);
		pushup(o);
	}
	ll query3(int o, int l, int r)
	{
		if (tr[o].l>r||tr[o].r<l) return 0;
		if (l<=tr[o].l&&tr[o].r<=r) return tr[o].sum;
		pushdown(o);
		return query3(lc, l, r)+query3(rc, l, r);
	}
	int query4(int o, int l, int r)
	{
		if (tr[o].l>r||tr[o].r<l) return -INF;
		if (l<=tr[o].l&&tr[o].r<=r) return tr[o].mx;
		pushdown(o);
		return max(query4(lc, l, r), query4(rc, l, r));
	}
	int query5(int o, int l, int r)
	{
		if (tr[o].l>r||tr[o].r<l) return -INF;
		if (l<=tr[o].l&&tr[o].r<=r) return tr[o].mx_;
		pushdown(o);
		return max(query5(lc, l, r), query5(rc, l, r));
	}
	#undef lc
	#undef rc
} sgt;
int a[MAXN];
int main()
{
//	freopen("segbeats.in", "r", stdin);
//	freopen("segbeats.out", "w", stdout);
	int n=read(), m=read();
	for (int i=1; i<=n; i++) a[i]=read();
	sgt.build(1, 1, n, a);
	while (m--)
	{
		int op=read(), l, r, k;
		switch (op)
		{
			case 1:
				l=read(), r=read(), k=read();
				sgt.modify1(1, l, r, k);
				break;
			case 2:
				l=read(), r=read(), k=read();
				sgt.modify2(1, l, r, k);
				break;
			case 3:
				l=read(), r=read();
				printf("%lld\n", sgt.query3(1, l, r));
				break;
			case 4:
				l=read(), r=read();
				printf("%d\n", sgt.query4(1, l, r));
				break;
			case 5:
				l=read(), r=read();
				printf("%d\n", sgt.query5(1, l, r));
				break;
		}
	}
	return 0;
}
```



---

## 作者：Mysterious_Mini (赞：85)

本文同步在[CSDN](https://blog.csdn.net/Miniqwq/article/details/119618123)上进行发表。

这是一篇刚开始学习线段树的小白都能看懂的良心学习笔记！

前置知识：含有懒标记的线段树（没别的了）。

### 总述

什么是吉司机线段树？

就是维护区间最值和区间历史最值的线段树，它的名字来源于吉如一老师，他在 $2016$ 年发表了一篇[集训队论文](https://pan.baidu.com/s/1o7xSSQ2)。

不过为啥这位老师被称为吉司机我也不知道……

废话不多说，马上进入正题吧。

### 正题

例题：[Luogu 6242](https://www.luogu.com.cn/problem/P6242)

读完题我们发现，一般线段树题目只需要用到一个数组，而这道题用了两个，多出来了个 $B$ 数组，是不是要拆成两棵树？

通过分析已知的所有关于 $B$ 数组的条件，我们找出的答案是不用！

1. $B$ 数组最初和 $A$ 数组完全相同
2. 每次操作后，将 $B$ 数组更新，使 $B_i = \max(B_i,A_i)$

这里我给出了两个条件，条件 $1$ 是 $B$ 数组的初始化，条件 $2$ 是 $B$ 数组的更新。显然可得：$B_i$ 是出现过的所有 $A_i$ 的最大值。

得出结论：$B$ 数组维护 $A$ 数组的历史最大值，**两者公用一棵线段树**。

题干分析完之后，让我们来分析一下操作。

| 操作号 | 简述 |
| :----------: | :----------: |
| $1$ | 区间加法 |
| $2$ | 区间修改为最小值 |
| $3$ | 区间求和 |
| $4$ | 区间查询最大值 |
| $5$ | 区间查询历史最大值中的最大值 |

接下来，我会分模块讲解（一定要往下看哟，有代码 /se）。

吉司机线段树本质上就是带懒标记的线段树，所以代码和线段树的前两个模板题也是大同小异的。

都有啥？

```cpp
struct SegTree {};
void pushup()
void build()
void pushdown()
void modify()
// 此处省略N个modify……
int query()
// 此处省略N个query……
```
看着就码量惊人，所以我们要在保证代码可读性的基础上尝试减少码量，原因有二：

1. 代码相对短，看着舒服（要不然会感觉像在写大 % 你）
2. 由于这题代码不可避免的长（函数多，维护操作多），所以出错的概率也会比较高，错了之后调代码会令人崩溃。为了自己的心理健康着想，还是要把代码写的漂亮一点的。

具体怎样减少码量，我会在后文进行详细的描述。

#### 线段树结构体

```cpp
struct SegTree
{
	int sum, maxst, maxnd, maxhis, maxnum, l, r;
	int lazy1, lazy2, lazy3, lazy4;
	void clear() { lazy1 = lazy2 = lazy3 = lazy4 = 0; }
} tree[NR << 2];
```

+ $sum$：区间内所有元素的和，在操作 $3$ 时会用到。
+ $maxst$：区间内的最大值，在操作 $2$ 和操作 $4$ 时会用到。
+ $maxnd$：区间内的**严格**次大值，在操作 $2$ 时会用到。
+ $maxhis$：区间内的历史最大值，在操作 $5$ 时会用到。
+ $maxnum$：区间内最大值出现的次数，在更新区间和时会用到。
+ $l$，$r$：区间左右端点，记录可以减少码量。
+ $lazy1$：维护 $A$ 数组中最大值加法**加的最多的那一次**的懒标记。
+ $lazy2$：维护 $B$ 数组中最大值加法**加的最多的那一次**的懒标记。
+ $lazy3$：维护 $A$ 数组中除了最大值之外所有元素加法**加的最多的那一次**的懒标记。
+ $lazy4$：维护 $B$ 数组中除了最大值之外所有元素加法**加的最多的那一次**的懒标记。
+ $clear()$：清空区间内的懒标记，使代码整体更加模块化。

注：

+ 为了方便，接下来我会把严格次大值称为次大值，但是读者勿忘它的真实含义！
+ 我后文会将 $sum$，$maxst$，$maxnd$，$maxnum$ 称为四大天王（还是想偷懒）。

我们运用一些 `#define` 来减少码量。

```cpp
#define sum(p) tree[p].sum
#define max1(p) tree[p].maxst
#define max2(p) tree[p].maxnd
#define maxhis(p) tree[p].maxhis
#define cnt(p) tree[p].maxnum
#define l(p) tree[p].l
#define r(p) tree[p].r
#define lzy1(p) tree[p].lazy1
#define lzy2(p) tree[p].lazy2
#define lzy3(p) tree[p].lazy3
#define lzy4(p) tree[p].lazy4
```

看着感觉像在增加码量，不过我保证，最终码量一定会减少的qwq！

我试了试，加了这坨 `#define` 总码量 3.54KB，不加 3.95KB。

#### 建树

递归的过程中，记录区间左右端点。

如果递归到了叶子结点（即 $l = r$），初始化四大天王和区间最大值的个数。由于区间里只有 $1$ 个元素 $A_l$，所以把区间最大值出现的次数设为 $1$。四大天王中除了区间次大值，都初始化为 $A_l$。由于没有第二个数了，就暂且将区间次大值初始化为 $\text{-INF}$，这样是个数就能比它大，方便更新（如果初始化的不够小，比 $A$ 数组的最小值 $-5 \times 10^8$ 大，就会造成无法更新的局面，一定要注意）。

```cpp
void build(int p, int l, int r)
{
	l(p) = l, r(p) = r;
	if(l == r) { sum(p) = max1(p) = maxhis(p) = a[l], max2(p) = -INF, cnt(p) = 1; return; }
	int mid = (l + r) >> 1; build(p << 1, l, mid), build(p << 1 | 1, mid + 1, r), pushup(p);
}
```

#### 向上更新

`pushup()` 会更新四大天王及区间最大值的出现次数。

区间最大值肯定是两个子区间最大元素中大的那一个，区间历史最大值同理。

区间和是两个子区间的和相加的结果。

对于区间最大值的出现次数：

+ 当左子区间最大元素和右子区间最大元素相等时，它们父区间的最大元素出现次数就是两个子区间相加的结果。

+ 否则，它们父区间的最大元素出现次数等于左右两个子区间中区间最大值大的那个区间的最大元素出现次数。

对于区间次大值：

+ 当左子区间最大元素和右子区间最大元素相等时，它们父区间的次大元素等于两个子区间次大元素中大的那一个。

+ 否则，它们父区间的次大元素等于最大元素小的那个子区间的最大元素和另一个子区间的次大元素中的最大值。

```cpp
void pushup(int p)
{
	max1(p) = max(max1(p << 1), max1(p << 1 | 1));
	maxhis(p) = max(maxhis(p << 1), maxhis(p << 1 | 1));
	sum(p) = sum(p << 1) + sum(p << 1 | 1);
	if(max1(p << 1) == max1(p << 1 | 1)) max2(p) = max(max2(p << 1), max2(p << 1 | 1)), cnt(p) = cnt(p << 1) + cnt(p << 1 | 1);
	if(max1(p << 1) > max1(p << 1 | 1)) max2(p) = max(max1(p << 1 | 1), max2(p << 1)), cnt(p) = cnt(p << 1);
	if(max1(p << 1) < max1(p << 1 | 1)) max2(p) = max(max1(p << 1), max2(p << 1 | 1)), cnt(p) = cnt(p << 1 | 1);
}
```

#### 下传懒标记

由于这道题维护了 $4$ 个懒标记，下传懒标记时会比较复杂，为了方便理解，我们把下传懒标记的操作拆成 $2$ 个函数：`update()` 和 `pushdown()`（其实要论关系，`update()` 其实是 `pushdown()` 的子函数）。

先来看看 `update()`。

+ $l1$ 是区间最大值加上的数。
+ $l2$ 是区间历史最大值加上的数。
+ $l3$ 是区间非最大值加上的数。
+ $l4$ 是区间历史非最大值加上的数。

更新区间和：把区间里的最大值个数乘上 $l1$，其它数的个数乘上 $l3$，它们的和就是区间和新增的部分。

更新区间次大值：如果区间不同值个数并非一，那么加上 $l3$（如果不同值个数为一，则不存在次大值，即次大值为 $\text{-INF}$）。

接下来是 $4$ 个懒标记的更新，**注意更新的顺序！**

其余变量和代码一起理解，也就不是那么难了。

```cpp
void update(int p, int l1, int l2, int l3, int l4)
{
	sum(p) += (l1 * cnt(p) + l3 * (rson(p) - lson(p) + 1 - cnt(p)));
	maxhis(p) = max(maxhis(p), max1(p) + l2);
	max1(p) += l1;
	if(max2(p) != -INF) max2(p) += l3;
	lzy2(p) = max(lzy2(p), lzy1(p) + l2), lzy1(p) += l1;
	lzy4(p) = max(lzy4(p), lzy3(p) + l4), lzy3(p) += l3;
}
```

下面该讲 `pushdown()` 了：

对于这题的 `pushdown()`，我们需要分两种情况讨论。

众所周知，一个区间可以拆成两个子区间（左右儿子），对于一个子区间，如果其包含的最大元素比另一子区间包含的最大元素大，那么父区间要以更新最大值的礼仪来接待它，否则就按照更新非最大值的礼仪来接待它。

详见代码，注意懒标记用过之后要清零。

```cpp
void pushdown(int p)
{
	int maxn = max(max1(p << 1), max1(p << 1 | 1));
	if(max1(p << 1) == maxn) update(p << 1, lzy1(p), lzy2(p), lzy3(p), lzy4(p));
	else update(p << 1, lzy3(p), lzy4(p), lzy3(p), lzy4(p));
	if(max1(p << 1 | 1) == maxn) update(p << 1 | 1, lzy1(p), lzy2(p), lzy3(p), lzy4(p));
	else update(p << 1 | 1, lzy3(p), lzy4(p), lzy3(p), lzy4(p));
	tree[p].clear();
}
```

坑点：$maxn$ 要在函数最开始记录！**不能每次在判断时比较两个子区间包含的最大元素大小！** 我因为这个，一直 Unaccepted 了一个月，花了两个晚上去食堂吃饭的时间，还因此瘦了 $2$ 斤 /kk

#### 操作 $1$

正常 `modify()` 操作，如果区间在待更新的范围内，那么把所有数都加上 $k$ ，即 `update(p, k, k, k, k)`。

```cpp
void modify1(int p)
{
	if(l(p) > y || r(p) < x) return;
	if(l(p) >= x && r(p) <= y) { update(p, k, k, k, k); return; }
	pushdown(p), modify1(p << 1), modify1(p << 1 | 1), pushup(p);
}
```

#### 操作 $2$

在操作 $1$ 的基础上有一些修改。

如果区间最大值都比 $k$ 小，那么无需更新，直接 `return`。

如果合法，还要进一步分类讨论：

+ 如果 $max2 \le k \le max1$，则只需要更新 $max1$，把 `update()` 中的 $l1$ 和 $l2$ 都设置为 $k - max1(p)$（因为 `update()` 是加法操作，所以加上相反数等于减去该数，最终就能达到更新为 $k$ 的效果了）。

+ 否则，还需要向下推进，直到符合上面的那种情况才停止。

```cpp
void modify2(int p)
{
	if(l(p) > y || r(p) < x || max1(p) <= k) return;
	if(l(p) >= x && r(p) <= y && max2(p) < k) { update(p, k - max1(p), k - max1(p), 0, 0); return; }
	pushdown(p), modify2(p << 1), modify2(p << 1 | 1), pushup(p);
}
```

#### 询问操作

很常规，就不放代码了。

这里说几个其中的坑点：

+ 求最大值时判断非法情况一定要返回极小值！
+ 求和操作的非法情况返回 $0$。

### 后记

这题要用 `long long`，给出简单证明：

因为 $1 \le n,m \le 5 \times 10^5$，$-5 \times 10^8 \le A_i \le 5 \times 10^8$，所以如果操作 $3$ 中的 $l=1,r=n$，那么结果的取值范围是 $-2.5 \times 10^{14} \le ans \le 2.5 \times 10 ^ {14}$，显然需要用到长整型。

但是细心的读者可能会看出我的所有代码都只有 `int` 的身影，这是因为我太懒，直接 `#define int long long` 了。大家写代码可不要被迷惑了哦！

---

其实，这篇文章可能不会在这个时间出现……

一个月里，Mini 的 P6242 代码一直卡在 $40$ 分。直到有一天，他闲来无事，来到了快要放弃的这题，点开了提交记录。

忽然，他看到了挨的很近的两条提交记录，作者是同一个人，一次是 $40$ 分，另一次是 $100$ 分。

他有些好奇，点开了 $40$ 分的那条提交记录，把光标放在了 WA 的 $6$ 个测试点上。忽然，他惊喜地发现，这个提交记录每个测试点首次错误的的位置都和他的废弃代码一模一样。

于是，他连忙给这两份提交记录的作者发了私信，问了他这道题应该怎么修改。很快，对方就给出了回复：

> 您的 `pushdown()` 函数有问题。

并一针见血的指出了问题所在。

Mini 将这个问题改完之后，马上 AC 了！

在此，我由衷感谢这位乐于助人的大佬 @[zhimao](https://www.luogu.com.cn/user/112921) ！

---

希望我的文章能够帮到大家！

如果您觉得这篇文章对您有帮助，可以给个赞嘛 qwq

---

## 作者：Limit (赞：29)

吉老师线段树模板题,如果想要知道更多可以去看看2016年的国集论文.

# 分析

先来看5个操作(第一感觉):

1.  区间加,只要用懒标记搞一下就好了.
2.  区间取min,吉老师线段树基本操作,记录一下最大值,最大值出现次数,严格次大值就好了.
3.  区间和,直接维护就好了.
4.  区间max,已经维护了.
5.  区间历史max,维护一下最大加标记就好了.

然后您就可以得到30分的好成绩.

考虑一下这个做法有什么问题.

可以发现问题是出在标记合并上.

可以发现在取min时最大的数的加标记会发生改变,那么需要额外维护出最大的数的加标记和其他的数的加标记(最大加标记).

在标记下传时,如果修改的子树的最大值是两子树最大值的最大值那么它的最大值的修改和其他值的修改可能不同,否则是相同的.

关于吉老师线段树的复杂度证明建议去看看论文或者其他的博客(我太菜了).

具体还是看代码吧.

# 代码

```cpp
#include<bits/stdc++.h>
#define REP(i,first,last) for(int i=first;i<=last;++i)
#define DOW(i,first,last) for(int i=first;i>=last;--i)
using namespace std;
const int MAXN=5e5+5;
const int MAX_NUM=5e5;
const long long INF=1e18;
long long maxll(long long a,long long b)
{
	if(a>b)
	{
		return a;
	}
	return b;
}
int n,m;
int arr[MAXN];
struct LazyTag
{
	long long max_add,add;//对于非最大数的最大加标记和当前加标记
	long long add_max_for_max,add_for_max;//对于最大数的最大加标记和当前加标记
	void Clean()//清空标记
	{
		add=0;
		add_for_max=0;
		max_add=0;
		add_max_for_max=0;
	}
}for_make;
LazyTag MakeTagAdd(int add)//对于加操作的修改中所有标记都是相同的
{
	for_make.Clean();
	for_make.add=add;
	for_make.max_add=add;
	for_make.add_for_max=add;
	for_make.add_max_for_max=add;
	return for_make;
}
LazyTag MakeTagMin(int min,int now_max)//对于取min操作,只有对最大值有修改
{
	for_make.Clean();
	for_make.add_for_max=min-now_max;
	for_make.add_max_for_max=min-now_max;
	return for_make;
}
struct SegmentTree
{
	long long first_max,second_max;
	long long max_num;
	long long history_max;
	long long sum;
	LazyTag tag;
}sgt[MAXN*4];
#define LSON (now<<1)
#define RSON (now<<1|1)
#define MIDDLE ((left+right)>>1)
#define LEFT LSON,left,MIDDLE
#define RIGHT RSON,MIDDLE+1,right
#define NOW now_left,now_right
void PushUp(int now)//合并子树
{
	sgt[now].history_max=maxll(sgt[LSON].history_max,sgt[RSON].history_max);//历史最大值直接取max
	sgt[now].sum=sgt[LSON].sum+sgt[RSON].sum;//区间和直接相加
	if(sgt[LSON].first_max==sgt[RSON].first_max)//对于最大值和严格次大值需要分类讨论
	{
        //如果两子树最大值相同
		sgt[now].first_max=sgt[LSON].first_max;//当前最大值就是子树最大值
		sgt[now].max_num=sgt[LSON].max_num+sgt[RSON].max_num;//最大值出现次数是子树出现次数之和
		sgt[now].second_max=maxll(sgt[LSON].second_max,sgt[RSON].second_max);//严格次大是两子树的严格次大中的大值
	}
	else
	{
		if(sgt[LSON].first_max>sgt[RSON].first_max)//如果最大值不同,那么就比较最大值
		{
			sgt[now].first_max=sgt[LSON].first_max;//最大值就是两子树的最大值
			sgt[now].max_num=sgt[LSON].max_num;//出现次数就是大的数的出现次数
			sgt[now].second_max=maxll(sgt[RSON].first_max,sgt[LSON].second_max);//严格次大值
		}
		else
		{
			sgt[now].first_max=sgt[RSON].first_max;
			sgt[now].max_num=sgt[RSON].max_num;
			sgt[now].second_max=maxll(sgt[LSON].first_max,sgt[RSON].second_max);
		}
	}
}
void Build(int now=1,int left=1,int right=n)//建树
{
	sgt[now].tag.Clean();
	if(left==right)
	{
		sgt[now].first_max=
		sgt[now].history_max=
		sgt[now].sum=
		arr[left];//直接等于初值
		sgt[now].second_max=-INF;//无严格次大
		sgt[now].max_num=1;//出现次数为1
		return;
	}
	Build(LEFT);
	Build(RIGHT);
	PushUp(now);
}
void DownMax(LazyTag tag,int now,int left,int right)//对于有最大值的下传标记
{
	sgt[now].sum+=
	1ll*tag.add_for_max*sgt[now].max_num
	+1ll*tag.add*(right-left+1-sgt[now].max_num);//计算贡献时需要分开计算
	sgt[now].tag.max_add=//对于非最大值的最大加标记的修改
	maxll(
		sgt[now].tag.max_add,
		sgt[now].tag.add+tag.max_add//和原来的加标记+下传的标记中的最大加标记的和取大值
	);
	sgt[now].tag.add_max_for_max=//对于最大值同理
	maxll(
		sgt[now].tag.add_max_for_max,
		sgt[now].tag.add_for_max+tag.add_max_for_max
	);
	sgt[now].history_max=//历史最大值也同理
	maxll(
		sgt[now].history_max,
		sgt[now].first_max+tag.add_max_for_max//注意是对于最大值的最大加标记
	);
	sgt[now].first_max+=tag.add_for_max;//加上的是对于最大值的加标记
	if(sgt[now].second_max!=INF)//如果存在严格次大值
	{
		sgt[now].second_max+=tag.add;//加上的是非最大值的加标记
	}
	sgt[now].tag.add+=tag.add;//对于加标记直接修改就可以
	sgt[now].tag.add_for_max+=tag.add_for_max;

}
void Down(LazyTag tag,int now,int left,int right)//没有最大值的标记下传
{
	tag.add_for_max=tag.add;//和上面的区别只有将最大值的修改变为非最大值的修改
	tag.add_max_for_max=tag.max_add;
    
	sgt[now].sum+=
	1ll*tag.add_for_max*sgt[now].max_num
	+1ll*tag.add*(right-left+1-sgt[now].max_num);
	sgt[now].tag.max_add=
	maxll(
		sgt[now].tag.max_add,
		sgt[now].tag.add+tag.max_add
	);
	sgt[now].tag.add_max_for_max=
	maxll(
		sgt[now].tag.add_max_for_max,
		sgt[now].tag.add_for_max+tag.add_max_for_max
	);
	sgt[now].history_max=
	maxll(
		sgt[now].history_max,
		sgt[now].first_max+tag.add_max_for_max
	);
	sgt[now].first_max+=tag.add_for_max;
	if(sgt[now].second_max!=INF)
	{
		sgt[now].second_max+=tag.add;
	}
	sgt[now].tag.add+=tag.add;
	sgt[now].tag.add_for_max+=tag.add_for_max;
}
void PushDown(int now,int left,int right)
{
	int max=maxll(sgt[LSON].first_max,sgt[RSON].first_max);//取出max
	if(max==sgt[LSON].first_max)//如果等于max,那么就是有最大值的标记下传,否则是没有最大值的下传
	{
		DownMax(sgt[now].tag,LEFT);
	}
	else
	{
		Down(sgt[now].tag,LEFT);
	}
	if(max==sgt[RSON].first_max)
	{
		DownMax(sgt[now].tag,RIGHT);
	}
	else
	{
		Down(sgt[now].tag,RIGHT);
	}
	sgt[now].tag.Clean();//清空标记
}
void UpdataAdd(int now_left,int now_right,int add,int now=1,int left=1,int right=n)//区间加的操作
{
	if(now_right<left||right<now_left)
	{
		return;
	}
	if(now_left<=left&&right<=now_right)//直接修改就可以
	{
		Down(MakeTagAdd(add),now,left,right);
		return;
	}
	PushDown(now,left,right);
	UpdataAdd(NOW,add,LEFT);
	UpdataAdd(NOW,add,RIGHT);
	PushUp(now);
}
void UpdataMin(int now_left,int now_right,int min,int now=1,int left=1,int right=n)//区间取min的操作
{
	if(now_right<left||right<now_left||sgt[now].first_max<=min/*适当剪枝*/)
	{
		return;
	}
	if(now_left<=left&&right<=now_right)
	{
		if(sgt[now].first_max>min&&min>sgt[now].second_max)//如果当前数是在最大值和严格次大值之间那么就打上标记修改
		{
			DownMax(MakeTagMin(min,sgt[now].first_max),now,left,right);
			return;
		}//否则继续递归,到叶节点一定是符合的
	}
	PushDown(now,left,right);
	UpdataMin(NOW,min,LEFT);
	UpdataMin(NOW,min,RIGHT);
	PushUp(now);
}
long long QuerySum(int now_left,int now_right,int now=1,int left=1,int right=n)//区间和,和普通线段树相同
{
	if(now_right<left||right<now_left)
	{
		return 0;
	}
	if(now_left<=left&&right<=now_right)
	{
		return sgt[now].sum;
	}
	PushDown(now,left,right);
	return QuerySum(NOW,LEFT)+QuerySum(NOW,RIGHT);
}
long long QueryMax(int now_left,int now_right,int now=1,int left=1,int right=n)//区间max
{
	if(now_right<left||right<now_left)
	{
		return -INF;
	}
	if(now_left<=left&&right<=now_right)
	{
		return sgt[now].first_max;
	}
	PushDown(now,left,right);
	return maxll(QueryMax(NOW,LEFT),QueryMax(NOW,RIGHT));
}
long long QueryHistoryMax(int now_left,int now_right,int now=1,int left=1,int right=n)//区间历史max
{
	if(now_right<left||right<now_left)
	{
		return -INF;
	}
	if(now_left<=left&&right<=now_right)
	{
		return sgt[now].history_max;
	}
	PushDown(now,left,right);
	return maxll(QueryHistoryMax(NOW,LEFT),QueryHistoryMax(NOW,RIGHT));
}
#undef LSON
#undef RSON
#undef MIDDLE
#undef LEFT
#undef RIGHT
#undef NOW
int main()
{
	scanf("%d%d",&n,&m);
	REP(i,1,n)
	{
		scanf("%d",&arr[i]);
	}
	Build();//建树
	int opt,l,r,k,v;
	REP(i,1,m)
	{
		scanf("%d",&opt);
		if(opt==1)
		{
			scanf("%d%d%d",&l,&r,&k);
			UpdataAdd(l,r,k);
		}
		if(opt==2)
		{
			scanf("%d%d%d",&l,&r,&v);
			UpdataMin(l,r,v);
		}
		if(opt==3)
		{
			scanf("%d%d",&l,&r);
			printf("%lld\n",QuerySum(l,r));
		}
		if(opt==4)
		{
			scanf("%d%d",&l,&r);
			printf("%lld\n",QueryMax(l,r));
		}
		if(opt==5)
		{
			scanf("%d%d",&l,&r);
			printf("%lld\n",QueryHistoryMax(l,r));
		}
	}
	return 0;
}
```



---

## 作者：water_tomato (赞：21)

本文同步发表于个人博客：[link](https://www.watertomato.com/%e6%9c%89%e8%b6%a3%e7%9a%84%e7%ba%bf%e6%ae%b5%e6%a0%91%e7%bb%b4%e6%8a%a4-%e5%90%89%e8%80%81%e5%b8%88%e7%ba%bf%e6%ae%b5%e6%a0%91%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0/)

本来没打算写这玩意儿，结果学习了之后觉得吉老师线段树真的很有意思，所以就决定简单写一下学习笔记。

> 本博客参考：echo 的 [博客](https://www.luogu.com.cn/blog/2806wsltz/solution-p6242) 与 代码启示，jiry_2 的 [课件](https://pan.baidu.com/s/1o7xSSQ2)。

但是个人感觉该博客对于 pushdown 部分还是有点难以理解，所以决定用自己的语言写一篇博客阐述一下。

## 吉老师线段树

> 吉如一(jiry_2)的 PDF 见博客上方博客参考部分。

模板题：[Luogu6242](https://www.luogu.com.cn/problem/P6242)。

**题意**：写一棵线段树，维护区间加、**区间取最值**、区间求和、区间最值与**区间历史最值**操作。

先不考虑历史最值问题，我们容易发现暴力维护区间取最值操作（本题中为将 $A_i$ 变成 $\min(A_i,v)$ 暴力方法即：一直往下搜直至搜到 $l=r$ 或 $v>max$ 为止，$max$ 为区间最大值）的复杂度是 $O(n^2)$ ，不可接受。我们考虑如何维护这个东西。

吉老师提出了一个很好的解决方案：对于每一个结点，我们维护区间最大值，最大值出现次数，区间严格次大值（用 $sec$ 表示）。我们维护好了这些信息之后，我们发现我们可以在区间取 $\min$ 操作时不断遍历线段树，直到 $sec<v$，由于我们维护好了区间最大值和最大值出现次数，我们可以很容易地维护其他需要维护的信息。吉老师也承认了自己在课件上的 $O(n\log n)$ 证明是伪证，但是可以确定的是，该算法的复杂度不多于 $O(n\log^2n)$。

> 如果对证明有兴趣，可以参考][吉如一的讨论](https://jiry-2.blog.uoj.ac/blog/1404)，灵梦的[洛谷日报文章](https://www.luogu.com.cn/blog/Hakurei-Reimu/seg-beats)， 以及吉如一的集训队论文。

那么，加入了历史最值操作之后要怎么维护呢？我将会下文的标记下传(pushdown)部分详细阐述。

接着将会着重写三个板块的内容：数值上传(pushup),标记下传(pushdown), 区间取最值(update_min)。

### 数值上传(pushup)

我们可以直接上传区间最大值、历史最大值和区间和。但是怎么维护区间严格次大值和最大值出现次数呢？我们先判断左右区间的区间最大值是否相同：若相同，将左右区间最大值出现次数相加，并取左右区间的严格次大值中较大的那个作为区间次大值；若不同，取最大值较大的那个区间的最大值区间次数，并将该区间的次大值与另一个区间的严格次大值比较以更新区间次大值。

该部分应该比较容易理解。

```cpp
inline void pushup(int u){
	tree[u].maxa=max(tree[ls].maxa,tree[rs].maxa);
	tree[u].maxb=max(tree[ls].maxb,tree[rs].maxb);
	tree[u].sum=tree[ls].sum+tree[rs].sum;//直接上传
	if(tree[ls].maxa==tree[rs].maxa){//三种情况，不同取法
		tree[u].sec=max(tree[ls].sec,tree[rs].sec);
		tree[u].cnt=tree[ls].cnt+tree[rs].cnt;
	}
	else if(tree[ls].maxa>tree[rs].maxa){
		tree[u].sec=max(tree[ls].sec,tree[rs].maxa);
		tree[u].cnt=tree[ls].cnt;
	}
	else{
		tree[u].sec=max(tree[ls].maxa,tree[rs].sec);
		tree[u].cnt=tree[rs].cnt;
	}
}
```

### 标记下传(pushdown)

在这里着重讲一下加入了历史最大值操作要怎么维护。

首先我们要维护四个 tag，即 $add\_a,add\_a1,add\_b,add\_b1$。

```cpp
struct Segment_Tree{
	int add_a,add_a1,add_b,add_b1;
	int maxa,sec,maxb,sum,cnt,len;
}tree[N<<3];
```

这四个 tag 分别是干什么的呢？由于在吉老师线段树中，我们区间取 $\min$ 时只会更新区间最大值的值，因此我们考虑将每个区间的数分为两类：最大数和非最大数，然后进行维护。这样我们在区间取 $\min$ 时就可以很好的只对最大值进行操作了。因此，我们用 $add\_a,add\_a1$ 分别表示当前区间最大值的加标记和当前区间非最大值的加标记（加标记是什么？参考 [【模板】线段树 1](https://www.luogu.com.cn/problem/P3372)），用 $add\_b,add\_b1$ 分别表示当前区间最大值**历史上加的最多的那次的加标记**以及对应的非最大值的历史上加的最多的那次的加标记。

什么是**历史上加的最多的那次的加标记**？我们举个例子，我们曾经给一个区间的最大值打上了 $+5$ 的加标记，然后下一个操作，这个区间的最大值要 $-2$，我们打这个标记后，$add\_a$ 就变成了 $+3$，而 $add\_b$ 仍为 $+5$。**因为他曾经加的最多的是 $5$，所以他的子区间都在某一个时刻是 $+5$ 的**，这个时刻才可能是历史最大的位置。

这四个标记理解了之后，后面就比较容易理解了。由于标记下传比较复杂，我们通常用 pushdown 和 update 两个函数来维护。对于 pushdown，我们先判断最大值在哪边，如果在左边，那么左边的最大值受到的影响是当前区间对最大值的影响，而右边的最大值受到的影响仅是当前区间对次大值的影响（当然可能左右两边都有最大值，那么两边的最大值受到的影响均是当前区间对最大值的影响）。如果最大值在右边，反过来就可以了。

```cpp
inline void pushdown(int u){
	int maxx=max(tree[ls].maxa,tree[rs].maxa);
	if(tree[ls].maxa==maxx)//最大值在左边?
		update(ls,tree[u].add_a,tree[u].add_b,tree[u].add_a1,tree[u].add_b1);//是，给最大值的标记给左边。
	else update(ls,tree[u].add_a1,tree[u].add_b1,tree[u].add_a1,tree[u].add_b1);//不是，左边的最大值获得的标记也应该是该区间的非最大值获得的标记。
	if(tree[rs].maxa==maxx)//最大值在右边?
		update(rs,tree[u].add_a,tree[u].add_b,tree[u].add_a1,tree[u].add_b1);//类似上边
	else update(rs,tree[u].add_a1,tree[u].add_b1,tree[u].add_a1,tree[u].add_b1);
	tree[u].add_a=tree[u].add_b=tree[u].add_a1=tree[u].add_b1=0;
}
```

这时候可能有疑问，我们仅仅判断了当前的最大值在哪里，怎么 $add\_b$ 也跟着走了，这个东西不是维护历史的吗？如果你理解了上面的，那么该标记表示的是**当前**最大值**历史上**加的最多的那次，所以这个标记实质上还是打给当前最大值的，当然是与 $add\_a$ 是一起的。

那么 update 呢？我们先看代码。

```cpp
inline void update(int u,int k1,int k2,int k3,int k4){
	tree[u].sum+=k1*tree[u].cnt+k3*(tree[u].len-tree[u].cnt);//更新区间和
	tree[u].maxb=max(tree[u].maxb,tree[u].maxa+k2);//更新历史最大值
	tree[u].add_b=max(tree[u].add_b,tree[u].add_a+k2);
	tree[u].add_b1=max(tree[u].add_b1,tree[u].add_a1+k4);
	tree[u].maxa+=k1;//更新当前最大值
	tree[u].add_a+=k1;
	tree[u].add_a1+=k3;
	if(tree[u].sec!=-1e18) tree[u].sec+=k3;//更新次大值
}
```

$k1,k2$ 分别表示：当前/历史最大值要加的数。

$k3,k4$ 分别表示：当前/历史非最大值要加的数。

然后我们考虑如果更新各个标记。区间和很好理解，就是最大值加的量加上非最大值加的量。对于 $add\_b$，它是历史上加的最多的那次，所以我们判断一下当前的 $add\_a$ 加上 $k1$ 是否超过了历史，若是，更新历史（如果不理解，请先理解好 $add\_b$ 的含义）。$add\_b1$ 类似。对于历史最大值，我们看看当前最大值加上历史上加的最多的时候的加标记的值（即 $k2$）是否超过了历史最大值，若超过了，更新历史最大值。其他信息的维护就很容易了，自行看上方代码即可。      

### 区间取最值(update_min)

首先，如果该区间的最大值比要取的 $v$（下面代码中为 $k$）小，显然直接返回即可。若 $sec \le v \le maxa$，那么就更新最大值。怎么更新呢？我们将 $maxa$ 变成了 $k$，也就是对于最大值，减去了 $maxa-k$，换言之，加了 $k-maxa$，用 update 函数操作即可。若不属于这两种情况中的任意一种，那就需要继续遍历到子区间。

```cpp
inline void update_min(int u,int l,int r,int L,int R,int k){
	if(l>R||r<L||k>=tree[u].maxa) return;//直接返回
	if(l>=L&&r<=R&&k>=tree[u].sec){//更新再返回
		update(u,k-tree[u].maxa,k-tree[u].maxa,0,0);
		return;
	}
	pushdown(u);//继续遍历
	int mid=(l+r)>>1;
	update_min(ls,l,mid,L,R,k);update_min(rs,mid+1,r,L,R,k);
	pushup(u);
}
```

这个函数不难理解，不多做赘述。其他函数均与普通的线段树类似，这里也不谈了。

## 完整代码

```cpp
#include<bits/stdc++.h>
#define int long long
#define ls u<<1
#define rs u<<1|1
#define getchar()(p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
using namespace std;
char buf[1<<21],*p1=buf,*p2=buf;
template <typename T>
inline void read(T& r) {
    r=0;bool w=0; char ch=getchar();
    while(ch<'0'||ch>'9') w=ch=='-'?1:0,ch=getchar();
    while(ch>='0'&&ch<='9') r=r*10+(ch^48), ch=getchar();
    r=w?-r:r;
}
const int N=5e5+5;
struct Segment_Tree{
	int add_a,add_a1,add_b,add_b1;
	int maxa,sec,maxb,sum,cnt,len;
}tree[N<<3];
int n,m,a[N];
inline void pushup(int u){
	tree[u].maxa=max(tree[ls].maxa,tree[rs].maxa);
	tree[u].maxb=max(tree[ls].maxb,tree[rs].maxb);
	tree[u].sum=tree[ls].sum+tree[rs].sum;
	if(tree[ls].maxa==tree[rs].maxa){
		tree[u].sec=max(tree[ls].sec,tree[rs].sec);
		tree[u].cnt=tree[ls].cnt+tree[rs].cnt;
	}
	else if(tree[ls].maxa>tree[rs].maxa){
		tree[u].sec=max(tree[ls].sec,tree[rs].maxa);
		tree[u].cnt=tree[ls].cnt;
	}
	else{
		tree[u].sec=max(tree[ls].maxa,tree[rs].sec);
		tree[u].cnt=tree[rs].cnt;
	}
}
inline void update(int u,int k1,int k2,int k3,int k4){
	tree[u].sum+=k1*tree[u].cnt+k3*(tree[u].len-tree[u].cnt);
	tree[u].maxb=max(tree[u].maxb,tree[u].maxa+k2);
	tree[u].add_b=max(tree[u].add_b,tree[u].add_a+k2);
	tree[u].add_b1=max(tree[u].add_b1,tree[u].add_a1+k4);
	tree[u].maxa+=k1;
	tree[u].add_a+=k1;
	tree[u].add_a1+=k3;
	if(tree[u].sec!=-1e18) tree[u].sec+=k3;
}
inline void pushdown(int u){
	int maxx=max(tree[ls].maxa,tree[rs].maxa);
	if(tree[ls].maxa==maxx)
		update(ls,tree[u].add_a,tree[u].add_b,tree[u].add_a1,tree[u].add_b1);
	else update(ls,tree[u].add_a1,tree[u].add_b1,tree[u].add_a1,tree[u].add_b1);
	if(tree[rs].maxa==maxx)
		update(rs,tree[u].add_a,tree[u].add_b,tree[u].add_a1,tree[u].add_b1);
	else update(rs,tree[u].add_a1,tree[u].add_b1,tree[u].add_a1,tree[u].add_b1);
	tree[u].add_a=tree[u].add_b=tree[u].add_a1=tree[u].add_b1=0;
}
inline void build(int u,int l,int r){
	tree[u].len=r-l+1;
	if(l==r){
		tree[u].maxa=tree[u].maxb=tree[u].sum=a[l];
		tree[u].sec=-1e18;tree[u].cnt=1;
		return;
	}
	int mid=(l+r)>>1;
	build(ls,l,mid);build(rs,mid+1,r);
	pushup(u);
}
inline void update_add(int u,int l,int r,int L,int R,int k){
	if(l>R||r<L) return;
	if(l>=L&&r<=R){
		update(u,k,k,k,k);
		return;
	}
	pushdown(u);
	int mid=(l+r)>>1;
	update_add(ls,l,mid,L,R,k);update_add(rs,mid+1,r,L,R,k);
	pushup(u);
}
inline void update_min(int u,int l,int r,int L,int R,int k){
	if(l>R||r<L||k>=tree[u].maxa) return;
	if(l>=L&&r<=R&&k>=tree[u].sec){
		update(u,k-tree[u].maxa,k-tree[u].maxa,0,0);
		return;
	}
	pushdown(u);
	int mid=(l+r)>>1;
	update_min(ls,l,mid,L,R,k);update_min(rs,mid+1,r,L,R,k);
	pushup(u);
}
inline int query_sum(int u,int l,int r,int L,int R){
	if(l>R||r<L) return 0;
	if(l>=L&&r<=R) return tree[u].sum;
	int mid=(l+r)>>1;
	pushdown(u);
	return query_sum(ls,l,mid,L,R)+query_sum(rs,mid+1,r,L,R);
}
inline int query_maxa(int u,int l,int r,int L,int R){
	if(l>R||r<L) return -1e18;
	if(l>=L&&r<=R) return tree[u].maxa;
	int mid=(l+r)>>1;
	pushdown(u);
	return max(query_maxa(ls,l,mid,L,R),query_maxa(rs,mid+1,r,L,R));
}
inline int query_maxb(int u,int l,int r,int L,int R){
	if(l>R||r<L) return -1e18;
	if(l>=L&&r<=R) return tree[u].maxb;
	int mid=(l+r)>>1;
	pushdown(u);
	return max(query_maxb(ls,l,mid,L,R),query_maxb(rs,mid+1,r,L,R));
}
signed main(){
	read(n);read(m);
	for(int i=1;i<=n;i++) read(a[i]);
	build(1,1,n);
	for(int i=1,opt,l,r,k;i<=m;i++){
		read(opt);read(l);read(r);
		if(opt==1){
			read(k);
			update_add(1,1,n,l,r,k);
		}
		else if(opt==2){
			read(k);
			update_min(1,1,n,l,r,k);
		}
		else if(opt==3){
			printf("%lld\n",query_sum(1,1,n,l,r));
		}
		else if(opt==4){
			printf("%lld\n",query_maxa(1,1,n,l,r));
		}
		else{
			printf("%lld\n",query_maxb(1,1,n,l,r));
		}
	}
	return 0;
}
```

---

## 作者：hsfzLZH1 (赞：19)

其他题解已经把本题的过程讲述得很详尽了，这里仅说一点对懒标记的理解。

所谓懒标记，本质是记录了一段操作序列，用一个值或一些值描述出来。而懒标记的下传，就是将这段操作序列的影响更新到子结点处，并且将这段操作序列添加到子结点操作序列的后面，然后清空原结点操作序列的过程。每访问到一个结点就下传该点的懒标记，意义就在于维护所有操作序列的有序性。有些操作的操作顺序不会影响到询问的结果，如区间加区间求和，此时才可以标记永久化，不下传标记。

回到本题的“历史版本最大值”，所求即为 **操作序列的前缀和的最大值** 。令 $add_x$ 表示线段树上结点 $x$ 的区间加标记， $add'_x$ 表示结点 $x$ 的历史最大加标记，设 $x$ 的儿子结点为 $y$ ，将 $x$ 的标记下传至 $y$ 时，有 $add'_y=\max\{add'_y,add_y+add'_x\}$ ，即将 $x$ 的操作序列接在 $y$ 的操作序列之后，前缀和的最大值。

最后再说一下在标记下传时需要注意的两个问题：

1. 在下传前，要先判断儿子结点的区间里有没有当前结点的区间里的最大值，如果没有，则区间非最大值加法标记会影响到儿子结点区间的最大值，区间最大值加法标记不会影响儿子结点区间。

2. 不能因为区间加标记等于 $0$ 就不下传标记，可能经过一系列操作后区间加标记变成了 $0$ ，但是历史最大加标记不为 $0$ 。

代码太丑，就不放出来啦，在理解本题应该维护哪些值哪些标记以及如何下传标记后，代码实现不会很难。

---

## 作者：_121017_ (赞：19)

一道非常恶心的线段树模板题（~~模板题都这么恶心~~），卡了我 $3$ 个小时。

# 首先讲思路：
其实只要 $AC$ 了 [这一道题](https://www.luogu.com.cn/problem/P3372) 和 [这一道题](https://www.luogu.com.cn/problem/P3373) 就可以很~~轻松加愉快~~地切掉这一题。

# 代码实现
## 1.定义结构体与优化：
直接照着搬板子就可以了。

### code：
```cpp
#include<bits/stdc++.h>
#define int long long
#define lc p*2
#define rc p*2+1
using namespace std;
int n,m,k,o,l,r;
int a[10000005];
struct node{
	int l;//左端点 
	int r;//右端点 
	int data;//区间和 
	int tag_max_1;//区间最大值 
	int tag_max_add_1;//区间最大值lazy_tag 
	int tag_max_2;//区间次大值 
	int tag_max_add_2;//区间非最大值lazy_tag 
	int tag_max_1_old;//区间历史最大值 
	int tag_max_add_1_old;//区间历史最大值lazy_tag 
	int tag_max_2_old;//区间历史次大值 
	int tag_max_add_2_old;//区间历史非最大值lazy_tag 
	int tag_max_cnt;//最大值的个数 
}tree[1000005*4];
int read(){
    char c=getchar();int s=0,f=1;
    for(;!isdigit(c);c=getchar())if(c=='-')f=-1;
    for(;isdigit(c);c=getchar())s=s*10+c-48;
    return s*f;
}//读入优化 
```
值得注意的是，结构体里这些乱七八糟的东西最好是英文翻译或者是缩写（~~不然的话就会像我一样看其他几篇题解看得头晕~~）。
## 2.主函数实现：
也没有任何难度，直接上代码。
### code：
```cpp
signed main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		a[i]=read();
	}
	//输入 
	build(1,1,n);//调用建树函数 
	for(int i=1;i<=m;i++){
		o=read(),l=read(),r=read();
		if(o==1)k=read(),change_1(1);
		if(o==2)k=read(),change_2(1);
		if(o==3)printf("%lld\n",ask_1(1));
		if(o==4)printf("%lld\n",ask_2(1));
		if(o==5)printf("%lld\n",ask_3(1));
	}
	return 0;
} 
```
## 3.建树：
只比前面两道模板题的 $build$ 函数多亿点东西，依然很容易。
### code：
```cpp
void build(int p,int l,int r){//建树 
	tree[p].l=l;//存储左端点 
	tree[p].r=r;//存储右端点 
	if(l==r){//如果访问到叶子节点 
		tree[p].data=a[l];//因为当前节点只有一个元素，所以区间和为它本身 
		tree[p].tag_max_1=a[l];//因为当前区间只有一个元素，所以最大值就是它本身 
		tree[p].tag_max_1_old=a[l];//历史最大值赋值为当前元素 
		tree[p].tag_max_2=-1e18;//因为当前区间只有一个元素，所以不存在次大值，赋值为无穷小 
		tree[p].tag_max_cnt=1;//最大值只有一个也就是它本身
		return;//返回 
	}
	int mid=(l+r)/2;
	build(lc,l,mid);//递归建造左区间 
	build(rc,mid+1,r);//递归建造右区间 
	push_up(p);//合并区间 
}
```
合并区间的代码在这里~。
### code：
```cpp
void push_up(int p){//合并区间 
	tree[p].tag_max_1=max(tree[lc].tag_max_1,tree[rc].tag_max_1);//更新区间最大值 
	tree[p].tag_max_1_old=max(tree[lc].tag_max_1_old,tree[rc].tag_max_1_old);//更新历史区间最大值 
	tree[p].data=tree[lc].data+tree[rc].data;//更新区间和 
	if(tree[lc].tag_max_1==tree[rc].tag_max_1){//如果整个区间最大值两边都有 
		tree[p].tag_max_2=max(tree[lc].tag_max_2,tree[rc].tag_max_2);//更新区间次大值为两边次大值中的最大值 
		tree[p].tag_max_cnt=tree[lc].tag_max_cnt+tree[rc].tag_max_cnt;//更新区间最大值个数为两边最大值个数之和 
	}
	if(tree[lc].tag_max_1>tree[rc].tag_max_1){//如果区间最大值位于左边 
		tree[p].tag_max_2=max(tree[lc].tag_max_2,tree[rc].tag_max_1);//更新区间次大值为左边次大值与右边最大值中的最大值 
		tree[p].tag_max_cnt=tree[lc].tag_max_cnt;//最大值个数为左边最大值的个数 
	}
	if(tree[lc].tag_max_1<tree[rc].tag_max_1){//如果区间最大值位于右边 
		tree[p].tag_max_2=max(tree[lc].tag_max_1,tree[rc].tag_max_2);//区间最大值为左边最大值与右边次大值中的最大值 
		tree[p].tag_max_cnt=tree[rc].tag_max_cnt;//区间最大值个数为右边最大值的个数 
	}
}
```
## 4. $lazy\_tag$ 处理方法：
讲出来有些复杂，直接看代码。
### code：
```cpp
void update(int k1,int k2,int k3,int k4,int p){
	//k1表示区间最大值要加的数，k2表示历史最大值要加的数，k3表示非最大值要加的数，k4表示非历史最大值最大值要加的数 
	tree[p].data+=k1*tree[p].tag_max_cnt+k3*(tree[p].r-tree[p].l+1-tree[p].tag_max_cnt);//更新区间和 
	tree[p].tag_max_1_old=max(tree[p].tag_max_1_old,tree[p].tag_max_1+k2);
	tree[p].tag_max_add_1_old=max(tree[p].tag_max_add_1_old,tree[p].tag_max_add_1+k2);
	tree[p].tag_max_add_2_old=max(tree[p].tag_max_add_2_old,tree[p].tag_max_add_2+k4);
	//如果当前区间的最大值加上最大的历史最大值要加的数大于原来的最大的历史最大值，就将值更新。如果值更新了，说明最大的历史最大值变了，那么懒标记肯定也要变。最后还要更新普通的历史最大值的懒标记
	tree[p].tag_max_add_1+=k1;//更新区间最大值lazy_tag 
	tree[p].tag_max_1+=k1;//更新区间最大值 
	tree[p].tag_max_2+=k3;//更新非区间最大值 
	tree[p].tag_max_add_2+=k3;//更新非区间最大值lazy_tag 
	if(tree[p].tag_max_2!=-1e18)tree[p].tag_max_2_old+=k3;//如果当前区间有次大值，那么次大值加上普通lazy_tag 
}
void push_down(int p){//下传懒标记 
	int maxn=max(tree[lc].tag_max_1,tree[rc].tag_max_1);//取出区间最大值 
	if(tree[lc].tag_max_1==maxn){//如果区间最大值位于左区间 
		update(tree[p].tag_max_add_1,tree[p].tag_max_add_1_old,tree[p].tag_max_add_2,tree[p].tag_max_add_2_old,lc);
		//向右儿子传递最大值lazy_tag 
	}else{
		update(tree[p].tag_max_add_2,tree[p].tag_max_add_2_old,tree[p].tag_max_add_2,tree[p].tag_max_add_2_old,lc);
		//否则向右儿子传递非最大值lazy_tag 
	} 
	if(tree[rc].tag_max_1==maxn){//如果区间最大值位于右区间 
		update(tree[p].tag_max_add_1,tree[p].tag_max_add_1_old,tree[p].tag_max_add_2,tree[p].tag_max_add_2_old,rc);
		//向左儿子传递区间最大值lazy_tag 
	}else{
		update(tree[p].tag_max_add_2,tree[p].tag_max_add_2_old,tree[p].tag_max_add_2,tree[p].tag_max_add_2_old,rc);
		//否则向右儿子传递非最大值lazy_tag
	}
	tree[p].tag_max_add_1=tree[p].tag_max_add_1_old=tree[p].tag_max_add_2=tree[p].tag_max_add_2_old=0;
	//清除lazy_tag 
}
```
## 5.区间加:
与模板一的实现有一些细微的差别，不过还是很容易解决。
### code：
```cpp
void change_1(int p){//区间加 
	if(tree[p].l>r||tree[p].r<l) return;//如果当前区间不在目标范围内，直接返回 
	if(l<=tree[p].l&&tree[p].r<=r){//如果当前区间在完全在目标范围内 
		update(k,k,k,k,p);//更新值和lazy_tag 
		return; //返回 
	}
	push_down(p);//下传lazy_tag 
	change_1(lc),change_1(rc);//分左右递归 
	push_up(p);//合并区间 
}
```
## 6.区间 $min$ 运算：
就是这个地方卡了我好久，然鹅最后发现打错了一个下标。。。
### code：
```cpp
void change_2(int p){//区间min修改 
	if(tree[p].l>r||tree[p].r<l||k>=tree[p].tag_max_1)return;//如果当前节点不在目标范围内，或者是区间最大值都比min数小，就没有继续递归下去的必要了 
	if(l<=tree[p].l&&tree[p].r<=r&&k>tree[p].tag_max_2){//如果当前区间在范围内，且min数比次大值大 
	    update(k-tree[p].tag_max_1,k-tree[p].tag_max_1,0,0,p);//则下传lazy_tag 
		return;
	}
	push_down(p);//下传lazy_tag 
	change_2(lc),change_2(rc);//递归左右区间 
	push_up(p);//更新区间 
}
```
## 7.区间求和：
与前面的一模一样啦啦啦~。
### code：
```cpp
int ask_1(int p){//区间求和 
	if(tree[p].l>r||tree[p].r<l)return 0;//如果当前节点在目标范围之外，直接返回0，不影响区间求和 
	if(l<=tree[p].l&&tree[p].r<=r)return tree[p].data;//如果当前区间完全在范围之内，直接返回当前区间和 
	push_down(p);//如果有积压的工作，直接通过下传lazy_tag的方式做完 
	return ask_1(lc)+ask_1(rc);//返回左区间与右区间的和 
}
```
## 8.区间求最大值：
把 $ask\_1$ 里的返回区间和变为返回左右区间最大值的最大值就可以了。如果越界的话必须返回负无穷，否则有可能会错。
### code：
```cpp
int ask_2(int p){//求区间最大值 
	if(tree[p].l>r||tree[p].r<l)return -1e18;//如果当前节点在目标范围之外，直接返回无穷小，不影响求区间最大值 
	if(l<=tree[p].l&&tree[p].r<=r)return tree[p].tag_max_1;//如果当前区间完全在范围之内，直接返回当前区间最大值 
	push_down(p);//如果有积压的工作，直接通过下传lazy_tag的方式做完  
	return max(ask_2(lc),ask_2(rc));//返回左区间与右区间的区间最大值的最大值 
}
```
## 9.区间求历史最大值：
把 $ask\_2$ 里的 $return\ tree[p].tag\_max\_1;$ 改成 $return\ tree[p].tag\_max\_1\_old;$ 就可以了。
### code：
```cpp
int ask_3(int p){//求区间历史最大值 
	if(tree[p].l>r||tree[p].r<l)return -1e18;//如果当前节点在目标范围之外，直接返回无穷小，不影响求区间历史最大值
	if(l<=tree[p].l&&tree[p].r<=r)return tree[p].tag_max_1_old;//如果当前区间完全在范围之内，直接返回当前区间历史最大值 
	push_down(p);//如果有积压的工作，直接通过下传lazy_tag的方式做完
	return max(ask_3(lc),ask_3(rc));//返回左区间与右区间的区间历史最大值的最大值 
}
```
# 最后送上 $AC$ 代码祝大家 $CSP\ rp++$!
```cpp
#include<bits/stdc++.h>
#define int long long
#define lc p*2
#define rc p*2+1
using namespace std;
int n,m,k,o,l,r;
int a[10000005];
struct node{
	int l;//左端点 
	int r;//右端点 
	int data;//区间和 
	int tag_max_1;//区间最大值 
	int tag_max_add_1;//区间最大值lazy_tag 
	int tag_max_2;//区间次大值 
	int tag_max_add_2;//区间非最大值lazy_tag 
	int tag_max_1_old;//区间历史最大值 
	int tag_max_add_1_old;//区间历史最大值lazy_tag 
	int tag_max_2_old;//区间历史次大值 
	int tag_max_add_2_old;//区间历史非最大值lazy_tag 
	int tag_max_cnt;//最大值的个数 
}tree[1000005*4];
int read(){
    char c=getchar();int s=0,f=1;
    for(;!isdigit(c);c=getchar())if(c=='-')f=-1;
    for(;isdigit(c);c=getchar())s=s*10+c-48;
    return s*f;
}//读入优化 
void push_up(int p){//合并区间 
	tree[p].tag_max_1=max(tree[lc].tag_max_1,tree[rc].tag_max_1);//更新区间最大值 
	tree[p].tag_max_1_old=max(tree[lc].tag_max_1_old,tree[rc].tag_max_1_old);//更新历史区间最大值 
	tree[p].data=tree[lc].data+tree[rc].data;//更新区间和 
	if(tree[lc].tag_max_1==tree[rc].tag_max_1){//如果整个区间最大值两边都有 
		tree[p].tag_max_2=max(tree[lc].tag_max_2,tree[rc].tag_max_2);//更新区间次大值为两边次大值中的最大值 
		tree[p].tag_max_cnt=tree[lc].tag_max_cnt+tree[rc].tag_max_cnt;//更新区间最大值个数为两边最大值个数之和 
	}
	if(tree[lc].tag_max_1>tree[rc].tag_max_1){//如果区间最大值位于左边 
		tree[p].tag_max_2=max(tree[lc].tag_max_2,tree[rc].tag_max_1);//更新区间次大值为左边次大值与右边最大值中的最大值 
		tree[p].tag_max_cnt=tree[lc].tag_max_cnt;//最大值个数为左边最大值的个数 
	}
	if(tree[lc].tag_max_1<tree[rc].tag_max_1){//如果区间最大值位于右边 
		tree[p].tag_max_2=max(tree[lc].tag_max_1,tree[rc].tag_max_2);//区间最大值为左边最大值与右边次大值中的最大值 
		tree[p].tag_max_cnt=tree[rc].tag_max_cnt;//区间最大值个数为右边最大值的个数 
	}
}
void update(int k1,int k2,int k3,int k4,int p){
	//k1表示区间最大值要加的数，k2表示历史最大值要加的数，k3表示非最大值要加的数，k4表示非历史最大值最大值要加的数 
	tree[p].data+=k1*tree[p].tag_max_cnt+k3*(tree[p].r-tree[p].l+1-tree[p].tag_max_cnt);//更新区间和 
	tree[p].tag_max_1_old=max(tree[p].tag_max_1_old,tree[p].tag_max_1+k2);
	tree[p].tag_max_add_1_old=max(tree[p].tag_max_add_1_old,tree[p].tag_max_add_1+k2);
	tree[p].tag_max_add_2_old=max(tree[p].tag_max_add_2_old,tree[p].tag_max_add_2+k4);
	//如果当前区间的最大值加上最大的历史最大值要加的数大于原来的最大的历史最大值，就将值更新。如果值更新了，说明最大的历史最大值变了，那么懒标记肯定也要变。最后还要更新普通的历史最大值的懒标记
	tree[p].tag_max_add_1+=k1;//更新区间最大值lazy_tag 
	tree[p].tag_max_1+=k1;//更新区间最大值 
	tree[p].tag_max_2+=k3;//更新非区间最大值 
	tree[p].tag_max_add_2+=k3;//更新非区间最大值lazy_tag 
	if(tree[p].tag_max_2!=-1e18)tree[p].tag_max_2_old+=k3;//如果当前区间有次大值，那么次大值加上普通lazy_tag 
}
void push_down(int p){//下传懒标记 
	int maxn=max(tree[lc].tag_max_1,tree[rc].tag_max_1);//取出区间最大值 
	if(tree[lc].tag_max_1==maxn){//如果区间最大值位于左区间 
		update(tree[p].tag_max_add_1,tree[p].tag_max_add_1_old,tree[p].tag_max_add_2,tree[p].tag_max_add_2_old,lc);
		//向右儿子传递最大值lazy_tag 
	}else{
		update(tree[p].tag_max_add_2,tree[p].tag_max_add_2_old,tree[p].tag_max_add_2,tree[p].tag_max_add_2_old,lc);
		//否则向右儿子传递非最大值lazy_tag 
	} 
	if(tree[rc].tag_max_1==maxn){//如果区间最大值位于右区间 
		update(tree[p].tag_max_add_1,tree[p].tag_max_add_1_old,tree[p].tag_max_add_2,tree[p].tag_max_add_2_old,rc);
		//向左儿子传递区间最大值lazy_tag 
	}else{
		update(tree[p].tag_max_add_2,tree[p].tag_max_add_2_old,tree[p].tag_max_add_2,tree[p].tag_max_add_2_old,rc);
		//否则向右儿子传递非最大值lazy_tag
	}
	tree[p].tag_max_add_1=tree[p].tag_max_add_1_old=tree[p].tag_max_add_2=tree[p].tag_max_add_2_old=0;
	//清除lazy_tag 
}
void build(int p,int l,int r){//建树 
	tree[p].l=l;//存储左端点 
	tree[p].r=r;//存储右端点 
	if(l==r){//若果访问到叶子节点 
		tree[p].data=a[l];//因为当前节点只有一个元素，所以区间和为它本身 
		tree[p].tag_max_1=a[l];//因为当前区间只有一个元素，所以最大值就是它本身 
		tree[p].tag_max_1_old=a[l];//历史最大值赋值为当前元素 
		tree[p].tag_max_2=-1e18;//因为当前区间只有一个元素，所以不存在次大值，赋值为无穷小 
		tree[p].tag_max_cnt=1;//最大值只有一个也就是它本身
		return;//返回 
	}
	int mid=(l+r)/2;
	build(lc,l,mid);//递归建造左区间 
	build(rc,mid+1,r);//递归建造右区间 
	push_up(p);//合并区间 
}
void change_1(int p){//区间加 
	if(tree[p].l>r||tree[p].r<l) return;//如果当前区间不在目标范围内，直接返回 
	if(l<=tree[p].l&&tree[p].r<=r){//如果当前区间在完全在目标范围内 
		update(k,k,k,k,p);//更新值和lazy_tag 
		return; //返回 
	}
	push_down(p);//下传lazy_tag 
	change_1(lc),change_1(rc);//分左右递归 
	push_up(p);//合并区间 
}
void change_2(int p){//区间min修改 
	if(tree[p].l>r||tree[p].r<l||k>=tree[p].tag_max_1)return;//如果当前节点不在目标范围内，或者是区间最大值都比min数小，就没有继续递归下去的必要了 
	if(l<=tree[p].l&&tree[p].r<=r&&k>tree[p].tag_max_2){//如果当前区间在范围内，且min数比次大值大 
	    update(k-tree[p].tag_max_1,k-tree[p].tag_max_1,0,0,p);//则下传lazy_tag 
		return;
	}
	push_down(p);//下传lazy_tag 
	change_2(lc),change_2(rc);//递归左右区间 
	push_up(p);//更新区间 
}
int ask_1(int p){//区间求和 
	if(tree[p].l>r||tree[p].r<l)return 0;//如果当前节点在目标范围之外，直接返回0，不影响区间求和 
	if(l<=tree[p].l&&tree[p].r<=r)return tree[p].data;//如果当前区间完全在范围之内，直接返回当前区间和 
	push_down(p);//如果有积压的工作，直接通过下传lazy_tag的方式做完 
	return ask_1(lc)+ask_1(rc);//返回左区间与右区间的和 
}
int ask_2(int p){//求区间最大值 
	if(tree[p].l>r||tree[p].r<l)return -1e18;//如果当前节点在目标范围之外，直接返回无穷小，不影响求区间最大值 
	if(l<=tree[p].l&&tree[p].r<=r)return tree[p].tag_max_1;//如果当前区间完全在范围之内，直接返回当前区间最大值 
	push_down(p);//如果有积压的工作，直接通过下传lazy_tag的方式做完  
	return max(ask_2(lc),ask_2(rc));//返回左区间与右区间的区间最大值的最大值 
}
int ask_3(int p){//求区间历史最大值 
	if(tree[p].l>r||tree[p].r<l)return -1e18;//如果当前节点在目标范围之外，直接返回无穷小，不影响求区间历史最大值
	if(l<=tree[p].l&&tree[p].r<=r)return tree[p].tag_max_1_old;//如果当前区间完全在范围之内，直接返回当前区间历史最大值 
	push_down(p);//如果有积压的工作，直接通过下传lazy_tag的方式做完
	return max(ask_3(lc),ask_3(rc));//返回左区间与右区间的区间历史最大值的最大值 
}
signed main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		a[i]=read();
	}
	//输入 
	build(1,1,n);//调用建树函数 
	for(int i=1;i<=m;i++){
		o=read(),l=read(),r=read();
		if(o==1)k=read(),change_1(1);
		if(o==2)k=read(),change_2(1);
		if(o==3)printf("%lld\n",ask_1(1));
		if(o==4)printf("%lld\n",ask_2(1));
		if(o==5)printf("%lld\n",ask_3(1));
	}
	return 0;
} 
```
实测可进最优解第一页。

---

## 作者：WeLikeStudying (赞：12)

- 有一个著名的 $\operatorname{checkmin}(l,r,x)$ 操作，表示对于 $l\le i\le r$，使得 $a_i=\min(a_i,x)$。
- 今天我们就要这个特别的操作，称作区间 $\text{checkmin}$。

**Task A**
- 修改：区间 $\operatorname{checkmin}$。
- 查询：区间和。
- 考虑均摊能够过的做法。
- 每个节点维护区间和 $S$，最大值 $Mx$，次大值 $Se$，最大值出现次数 $Num$。
- 那么递归时满足以下三个条件之一时可以停止递归：
$$l=r$$
$$Mx\le x$$
$$Se<x<Mx$$
- 看起来很像乱搞对吧，但它的聚合复杂度是 $O((n+q)\log n)$ 的，理由：
- 首先需要需要考虑线段树定位区间所必须的 $O(q\log n)$ 复杂度，这里感谢 [hgzxgzx](https://www.luogu.com.cn/user/545918) 和 [bai_tang](https://www.luogu.com.cn/user/817142) 在 [这里](https://www.luogu.com.cn/discuss/506677?page=2) 的指出错误，祝愿其信息学之路光芒璀璨。
- 为啥，哈哈，我们定义 $\varphi(u)$ 为：$u$ 的子树中满足自己的最大值与它父节点最大值不相等的节点个数。
- 总势能（所有 $\varphi(u)$ 的和）的上界显然是 $O(n\log n)$。
- $\text{checkmin}$ 操作对总势能的影响是显然的：每个不终止的情况都带来势能的减小，因为 $x\le Se<Mx$。
- 而所有 $\varphi(u)$ 之和是 $O(n\log n)$ 的，而这也是递归操作的上界（总不能减到负吧）。
- 对了有个具体的实现细节：$Se<x<Mx$ 的时候要设一个懒标记。
- 感谢[奆佬](https://www.luogu.com.cn/user/371852)的提醒，衷心祝愿其信息学之路光芒璀璨。
- 这里特别加一个提示：$\varphi(u)$ 表示的是整个子树的情况，我说每一次操作都会使得势能减小的实际指：这整个子树内至少会有一个节点由不等变得等于。
- 也可以理解为初始势能为 $O(n)$，每减少一个单位的势能需要 $O(\log n)$ 的时间。

**Task B**
- 修改：区间 $\operatorname{checkmin}$，区间加。
- 查询：区间求和。
- 如果我们维持先前的那种策略，复杂度又是多少呢？上界是 $O(n\log n+q\log^2n)$。
- 考虑区间加操作对总势能的影响：它只会让 $O(\log n)$ 个节点受到影响，但就算它们全都由之前与父亲的最大值不一样变得一样，那么总势能最多加上 $O(\log^2 n)$，同样的原因，这个上界较松。
- 势能的总和也就是它的时间复杂度上限 $O(n\log n+q\log^2 n)$。
- 具体实现还有一些细节尚待讨论：因为我们希望在懒标记互相重叠的时候仍然苟住不下传（否则大概率被卡成暴力），那么具体我们怎么做呢？
- 容易发现 $\text{add}(l,r,a)+\text{checkmin}(l,r,b)+\text{add}(l,r,c)$ 与 $\text{add}(l,r,a+c)+\text{checkmin}(l,r,b+c)$ 等价。

**Task C**
- 修改：区间加，区间覆盖。
- 查询：区间最大值，区间历史最大值。
- 增加了奇怪的东西呢。
- [还好作者专门写了博客](https://www.luogu.com.cn/blog/luo1gu1zui1bang1/solution-p4314)。
- 主要思想就是对“历史”专门开懒标记。
- 其实是在打这个之后写的（尴尬）。

**Task D**
- 修改：区间加，区间 $\text{checkmin}$。
- 查询：区间求和，区间最大值，区间历史最大值。
- [就是这个题目](https://www.luogu.com.cn/problem/P6242)。
- 个人认为难度没有梯度是这道题几乎所有帖子都是求助帖的主要原因~~而且还没人敢帮你调~~。
- ~~话说原论文好像更加猥琐。~~
- 不就是多合一套在一起吗，我 $\text{W}$ 某人何惧？
- 性质是类似的，而且区间 $\text{checkmin}$ 之后历史最大值一定不会更新，所以完全不需要记录历史最大 $\text{checkmin}$ 呢。
- 但历史最大值怎么办？如果仍然采用之前的做法的话标记的下传就会出问题。
- 发现作用在这个线段上的一切 $\text{checkmin}$ 操作只会对这个点上的最大值有影响，所以直接把 $\text{checkmin}$ 操作改为 $\text{addmax}$ 标记，意思就是对区间最大值进行的加减。
- 那这不就好维护多了吗？
- 我们维护四个标记：对次大值的加减，对最大值的加减，对次大值的加减的历史最大值，对最大值的加减的历史最大值。
- 然后合并就很无脑很好打了。

**后记**
- 在作者真正打出来这道题目的时候，题解已经过审一段时间了，但我需要重新作一些实现细节方面的提示：
- 虽然复杂度是 $O(n\log n+q\log^2 n)$ 而且跑不满，但由于常规解法一共使用 $9$ 个线段树变量，所以实际上会略有卡常，请自行搜索卡常的相关知识或者参照本代码的实现。
- 作者由于卡常，将除了区间和外的标记全都设置为 $32$ 位有符号整数，叶节点的次小值取 $-2^{31}$，所以如果执行对次小值的加法就需要特判。
- 作者由于卡常，下传懒惰标记的时候采取比较两子节点比较大小的方式下传，这是绝对不可取的！因为已经改变了节点的值了（不过采用三目比较就没有问题）！
- ~~虽然但是找到原论文代码实现也看得到类似的细节处理。~~
- [代码实现](https://www.luogu.com.cn/paste/0c6kuzw7)。
- 对于数据结构模板来说，算一道好题。
- 最后，由衷感谢 [@Mysterious_Mini](https://www.luogu.com.cn/user/476150) 的帮助，希望其信息学之路光芒璀璨。

---

## 作者：Others (赞：7)

以前想做但是不会的题&&一个脑瘫才会犯的错误我调了半天\kel

**题意：**

区间加，区间取最小值，求区间和，求区间最大值，求区间历史最大值。

**Soluion：**

这显然是把区间最值操作和区间历史最大值揉在了一起。

**Case 1：区间最值操作**

~~吉司机线段树，~~ 维护一个最大值 $Max$ 和次大值 $seMax(Second\ Max)$ 和最大值的个数 $Maxcnt$，假设对每个数取 $min(a_i,x)$，那我们在修改时判断是否有 $x\in[seMax+1,Max-1]$ 如果是就打懒惰标记。这里有个技巧就是维护两个懒标记 $Addtag$ 和 $MaxAddtag$，第二个表示的是区间里的最大值的加法懒惰标记（因为区间最值操作只修改最大值）。~~回到上面~~，如果 $x\in[seMax+1,Max-1]$ 是否，那就继续递归，这东西复杂度是 $O(n\log^2n)$，用势能法证（我不会）。

**Case 2：历史最大值**

先是分析性质，对于一个结点的状态分段，可以将一次标记下传后到下一次标记下传前作为一个阶段。

那我们维护一个 $HisAddtag$ 表示这一阶段 $Addtag$ 的最大值，下传时假设子节点 $x$，父节点 $y,HisAddtag_x=\max\{HisAddtag_x,Addtag_x+HisAddtag_y\},Addtag_x+=Addtag_y$，最大值相应更新就行了。

**Case 3：奇技淫巧**

$Case\ 1$ 里的 $Addtag,MaxAddtag,Max,seMax$ 肯定要维护， $Case\ 2$ 里的 $Addtag,HisAddtag$ 和前面的两个懒标记融合一下：$Addtag,MaxAddtag,HisAddtag,HisMaxAddtag$，这四个懒标记和上面定义的同理，~~拆分单词就行了~~， 然后一一将上面的处理带进去，融合的地方多几个判断就行了。

给一个又长又臭的代码：

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
ll qr() {
	bool f=0;
	ll x=0;
	char c=getchar();
	while(!isdigit(c)) f|=c=='-',c=getchar();
	while(isdigit(c)) x=(x<<3)+(x<<1)+(c^48),c=getchar();
	return f?~(x-1):x;
}
const ll N=500005;
struct node{ll l,r,sum,Max,Maxcnt,seMax,HisMax,Addtag,MaxAddtag,HisAddtag,HisMaxAddtag,lstMax;}tr[N<<2];
void pushup(ll p) {
	tr[p].sum=tr[p<<1].sum+tr[p<<1|1].sum;
	tr[p].HisMax=max(tr[p<<1].HisMax,tr[p<<1|1].HisMax);
	if(tr[p<<1].Max>tr[p<<1|1].Max) tr[p].Max=tr[p<<1].Max,tr[p].seMax=max(tr[p<<1].seMax,tr[p<<1|1].Max),tr[p].Maxcnt=tr[p<<1].Maxcnt;
	else if(tr[p<<1].Max<tr[p<<1|1].Max) tr[p].Max=tr[p<<1|1].Max,tr[p].seMax=max(tr[p<<1].Max,tr[p<<1|1].seMax),tr[p].Maxcnt=tr[p<<1|1].Maxcnt;
	else tr[p].Max=tr[p<<1].Max,tr[p].seMax=max(tr[p<<1].seMax,tr[p<<1|1].seMax),tr[p].Maxcnt=tr[p<<1].Maxcnt+tr[p<<1|1].Maxcnt;
}
void pushdown(ll p) {
	ll Max1=tr[p<<1].Max,Max2=tr[p<<1|1].Max; 
	tr[p<<1].HisAddtag=max(tr[p<<1].HisAddtag,tr[p<<1].Addtag+tr[p].HisAddtag);
	tr[p<<1].Addtag+=tr[p].Addtag;
	if(Max1>=Max2) {
		tr[p<<1].sum+=(tr[p<<1].r-tr[p<<1].l+1-tr[p<<1].Maxcnt)*tr[p].Addtag+tr[p<<1].Maxcnt*tr[p].MaxAddtag;
		tr[p<<1].HisMaxAddtag=max(tr[p<<1].HisMaxAddtag,tr[p<<1].MaxAddtag+tr[p].HisMaxAddtag);
		tr[p<<1].MaxAddtag+=tr[p].MaxAddtag;
		tr[p<<1].HisMax=max(tr[p<<1].HisMax,tr[p<<1].Max+tr[p].HisMaxAddtag);
		tr[p<<1].Max+=tr[p].MaxAddtag;
		tr[p<<1].seMax+=tr[p].Addtag;
	}else {
		tr[p<<1].sum+=(tr[p<<1].r-tr[p<<1].l+1)*tr[p].Addtag;
		tr[p<<1].HisMaxAddtag=max(tr[p<<1].HisMaxAddtag,tr[p<<1].MaxAddtag+tr[p].HisAddtag);
		tr[p<<1].MaxAddtag+=tr[p].Addtag;
		tr[p<<1].HisMax=max(tr[p<<1].HisMax,tr[p<<1].Max+tr[p].HisAddtag);
		tr[p<<1].Max+=tr[p].Addtag;
		tr[p<<1].seMax+=tr[p].Addtag;
	}
	tr[p<<1|1].HisAddtag=max(tr[p<<1|1].HisAddtag,tr[p<<1|1].Addtag+tr[p].HisAddtag);
	tr[p<<1|1].Addtag+=tr[p].Addtag;
	if(Max2>=Max1) {
		tr[p<<1|1].sum+=(tr[p<<1|1].r-tr[p<<1|1].l+1-tr[p<<1|1].Maxcnt)*tr[p].Addtag+tr[p<<1|1].Maxcnt*tr[p].MaxAddtag;
		tr[p<<1|1].HisMaxAddtag=max(tr[p<<1|1].HisMaxAddtag,tr[p<<1|1].MaxAddtag+tr[p].HisMaxAddtag);
		tr[p<<1|1].MaxAddtag+=tr[p].MaxAddtag;
		tr[p<<1|1].HisMax=max(tr[p<<1|1].HisMax,tr[p<<1|1].Max+tr[p].HisMaxAddtag);
		tr[p<<1|1].Max+=tr[p].MaxAddtag;
		tr[p<<1|1].seMax+=tr[p].Addtag;
	}else {
		tr[p<<1|1].sum+=(tr[p<<1|1].r-tr[p<<1|1].l+1)*tr[p].Addtag;
		tr[p<<1|1].HisMaxAddtag=max(tr[p<<1|1].HisMaxAddtag,tr[p<<1|1].MaxAddtag+tr[p].HisAddtag);
		tr[p<<1|1].MaxAddtag+=tr[p].Addtag;
		tr[p<<1|1].HisMax=max(tr[p<<1|1].HisMax,tr[p<<1|1].Max+tr[p].HisAddtag);
		tr[p<<1|1].Max+=tr[p].Addtag;
		tr[p<<1|1].seMax+=tr[p].Addtag;
	}
	tr[p].Addtag=tr[p].MaxAddtag=0;tr[p].HisAddtag=tr[p].HisMaxAddtag=-1145141919810;
}
ll l,r,x,n,m;
void build(ll l,ll r,ll p) {
	tr[p].l=l,tr[p].r=r,tr[p].Addtag=tr[p].HisAddtag=tr[p].HisMaxAddtag=tr[p].MaxAddtag=0;
	if(l==r) {tr[p].HisMax=tr[p].Max=tr[p].sum=qr(),tr[p].seMax=-1145141919810,tr[p].Maxcnt=1;return ;}
	ll mid=l+r>>1;build(l,mid,p<<1),build(mid+1,r,p<<1|1),pushup(p);
}
void update1(ll p) {
	if(l<=tr[p].l&&tr[p].r<=r) {
		tr[p].sum+=(tr[p].r-tr[p].l+1)*x,tr[p].Addtag+=x;
		tr[p].HisAddtag=max(tr[p].HisAddtag,tr[p].Addtag);
		tr[p].Max+=x,tr[p].seMax+=x,tr[p].MaxAddtag+=x;
		tr[p].HisMax=max(tr[p].HisMax,tr[p].Max);
		tr[p].HisMaxAddtag=max(tr[p].HisMaxAddtag,tr[p].MaxAddtag);
		return ;
	}
	pushdown(p);
	ll mid=tr[p].l+tr[p].r>>1;
	if(l<=mid) update1(p<<1);
	if(r>mid) update1(p<<1|1);
	pushup(p);
}
void update2(ll p) {
	if(tr[p].Max<=x) return ;
	if(l<=tr[p].l&&tr[p].r<=r&&tr[p].seMax<x) {
		tr[p].sum-=tr[p].Maxcnt*(tr[p].Max-x);
		tr[p].MaxAddtag+=x-tr[p].Max,tr[p].Max=x;
		return ;
	}
	pushdown(p);
	ll mid=tr[p].l+tr[p].r>>1;
	if(l<=mid) update2(p<<1);
	if(r>mid) update2(p<<1|1);
	pushup(p);
}
ll getsum(ll p) {
	if(l>tr[p].r||r<tr[p].l) return 0;
	if(l<=tr[p].l&&tr[p].r<=r) return tr[p].sum;
	pushdown(p);
	return getsum(p<<1)+getsum(p<<1|1);
}
ll getnowmax(ll p) {
	if(l>tr[p].r||r<tr[p].l) return -1145141919810;
	if(l<=tr[p].l&&tr[p].r<=r) return tr[p].Max;
	pushdown(p);
	return max(getnowmax(p<<1),getnowmax(p<<1|1));
}
ll getpremax(ll p) {
	if(l>tr[p].r||r<tr[p].l) return -1145141919810;
	if(l<=tr[p].l&&tr[p].r<=r) return tr[p].HisMax;
	pushdown(p);
	return max(getpremax(p<<1),getpremax(p<<1|1));
}
int main() {
	n=qr(),m=qr();
	build(1,n,1);
	for(ll i=1,op;i<=m;i++) {
		op=qr();
		if(op==1) {
			l=qr(),r=qr(),x=qr();
			update1(1);
		}else if(op==2) {
			l=qr(),r=qr(),x=qr();
			update2(1);
		}else if(op==3) {
			l=qr(),r=qr();
			printf("%lld\n",getsum(1));
		}else if(op==4) {
			l=qr(),r=qr();
			printf("%lld\n",getnowmax(1));
		}else {
			l=qr(),r=qr();
			printf("%lld\n",getpremax(1));
		}
	}
	return 0;
}
```

---


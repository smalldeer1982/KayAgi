# 「Wdoi-1」四重存在

## 题目背景

芙兰朵露·斯卡蕾特的符卡禁忌「四重存在」可以产生 $4$ 个芙兰的幻影。

但是芙兰并不满足于此。

## 题目描述

芙兰所处的地下室可以被抽象为一个巨大的平面直角坐标系。芙兰朵露会进行 $q$ 次行动，每次行动的形式如下：  

- `1 x y v` 表示芙兰在坐标 $(x,y)$ 处召唤出一个新的幻影，这个幻影拥有 $v$ 个单位的力量。  

- `2` 表示查询现有的幻影中，"**芙兰距离**"的最大值是多少。  

- `3 a` 表示查询如果忽略掉第 $a$ 个被召唤出的幻影，则剩余的幻影中"芙兰距离"的最大值是多少 。

注： 

记第 $i$ 个被召唤出的幻影编号为 $i$，坐标为 $(x_i,y_i)$，力量为 $v_i$。  

两个编号为 $u,v$ 的幻影间的"芙兰距离"等于 $|x_u-x_v|+|y_u-y_v|+v_{\max(u,v)}$。

**特殊地，编号为 $i$ 的幻影与自己的"芙兰距离"为 $v_i$。**  

$3$ 操作中第 $a$ 个召唤的幻影只是在本次询问中不参与运算，而不是被去除。

## 说明/提示

#### 数据范围与约定

**「本题采用捆绑测试：一个子任务通过，当且仅当该子任务中全部测试点通过」。**

| 子任务编号 | $q \le$ | 特殊性质 | 分值 |
| :----------: | :-------: | :--------: | :---: |
| $1$ | $500$ | 无 | $5$ |
| $2$ | $5 \times 10^3$ | A | $10$ |
| $3$ | $10^5$ | A | $20$ |
| $4$ | $10^5$ | 无 | $25$ |
| $5$ | $2 \times 10^6$ | 无 | $40$ |

其中性质 A 表示无 3 操作。

对于 $100\%$ 的数据，$-10^8 \le x,y,v \le 10^8$，记某一时刻幻影的数量为 $c$，则有 $1 \le a \le c$ 。

数据保证任意两个幻影的坐标不同，且在询问 $2,3$ 时至少已经插入 $3$ 个点。

## 样例 #1

### 输入

```
6
1 4 -4 0
1 -3 -1 0
1 -1 -1 0
2
3 2
3 3```

### 输出

```
10
8
10
```

# 题解

## 作者：x_angelkawaii_x (赞：6)

- 子任务 $1$  

按照题意模拟即可。  

时间复杂度 $\mathcal{O}(q^3)$ ，期望得分 $5$ 分  

- 子任务 $2$  

在插入每个点时更新答案即可。  

时间复杂度 $\mathcal{O}(q^2)$ ，期望得分 $15$ 分   

- 子任务 $3$  

注意到芙兰距离为曼哈顿距离+$v_{max(u,v)}$  

因此插入点 $(x_i,y_i,v_i)$ 时查询该点与其余点的最大曼哈顿距离+$v_i$ 即可更新答案  

将 $(x,y)$ 变为 $(x+y,x-y)$，最大曼哈顿距离被转化为最大切比雪夫距离。显然只有 $x,y$ 坐标最小和最大的四个点可能和 $i$ 的切比雪夫距离最大，枚举即可。  

时间复杂度 $\mathcal{O}(q)$ ，期望得分 $35$ 分  

- 子任务 $4$  

有一点可能不能参与运算，因此需要记录 $i$ 与之前点的最大"芙兰距离"与次大"芙兰距离"。  

记 '$i$ 与 $x(x<i)$ 的"芙兰距离"是 $w$' 为三元组 $(i,x,w)$，则查询忽略 $a$ 时的答案 即询问所有前两个数字不包含 $a$ 的三元组中，$w$ 的最大值是多少。  

以 $i$ 为横坐标，$x$ 为纵坐标，那么不包含 $a$ 相当于去掉了两条直线。拆成四个矩形查询，可以使用 k-d tree 维护。  

时间复杂度 $\mathcal{O}(q\sqrt{q})$，期望得分 $60$ 分  

- 子任务 $5$  

瓶颈在于 k-d tree ，所以我们想办法优化最后一步。  

一个三元组 $(i,x,w)$ 对查询 $a$ 有影响，当且仅当 $i \neq a$ 且 $x \neq a$。所以插入三元组时将区间 $[1,x-1]$，$[x+1,i-1]$，$[i+1,n]$ 中的数字对 $w$ 取 $max$，查询时单点求值即可。使用线段树即可轻松维护。  

时间复杂度 $\mathcal{O}(q\log q)$，期望得分 $100$ 分

---

## 作者：樱雪喵 (赞：4)

### 前置知识
- 曼哈顿距离转切比雪夫距离
- 线段树

### Solution

首先将答案点对钦定一个顺序，设 $a<b$，则 $dis_{a,b}=|x_a-x_b|+|y_a-y_b|+v_b$。

固定其中一个点，观察到这个式子是曼哈顿距离与一个定值的和的形式。曼哈顿距离不便于统计，我们把它转化成切比雪夫距离。令 $(x,y)\rightarrow(x+y,x-y)$，则距离式化为 $dis_{a,b}=\max(|x_a-x_b|,|y_a-y_b|)+v_b$。

考虑当 $b$ 固定时，使 $dis_{a,b}$ 最大的 $a$ 有什么特点，发现 $a$ 一定是 $x$ 坐标或 $y$ 坐标最小/最大的点之一。那么对于操作 $2$，可以在每加入一个点 $b$ 时维护当前四个方向的坐标最值，从而 $O(1)$ 统计与 $b$ 距离最远的点，不断与当前全局答案取 $\max$ 即为答案。

还有操作 $3$ 没解决，因为有一个点不能选，对于上面的算法进行改进，在每个方向上的坐标分别维护最大值、次大值，其中必然包含除去 $x$ 后的最远点对。

考虑统计距离为 $w$ 的点对 $(a,b)$ 对答案的贡献，当 $3$ 操作查询的 $x\neq a$ 且 $x\neq b$ 时，它对答案有贡献 $w$。换言之，点对 $(a,b)$ 对 $[1,a-1],[a+1,b-1],[b+1,n]$ 均有 $w$ 的贡献，在线段树上把这些区间的答案与 $w$ 取 $\max$ 即可。

询问时单点查询，经过路径上的最大距离即为所有不包含点 $x$ 点对的最大距离。

### Tips

- 统计最大值和次大值时注意判重，要判断某个点同时是横坐标和纵坐标最大值的情况。
- ~~样例比较弱，友情提供一个[小数据生成器](https://www.luogu.com.cn/paste/irnek6uw) qwq。~~

### Code

代码写丑了，见谅。

```cpp
#include<bits/stdc++.h>
#define il inline
using namespace std;
#define int long long
il int read()
{
	int xr=0,F=1;char cr=getchar();
	while(cr<'0'||cr>'9') {if(cr=='-') F=-1;cr=getchar();}
	while(cr>='0'&&cr<='9')
	    xr=(xr<<3)+(xr<<1)+(cr^48),cr=getchar();
	return xr*F;
}
const int N=2e6+5;
int cnt,w[N];
struct node {int x,y,id;};
int dis(node x,node y) {return max(abs(x.x-y.x),abs(x.y-y.y));}
node mnx[2],mxx[2],mny[2],mxy[2];
void upd(node x)
{
    if(x.x<=mnx[0].x||mnx[0].id==0) mnx[1]=mnx[0],mnx[0]=x;
    else if(x.x<=mnx[1].x||mnx[1].id==0) mnx[1]=x;

    if(x.x>=mxx[0].x||mxx[0].id==0) mxx[1]=mxx[0],mxx[0]=x;
    else if(x.x>=mxx[1].x||mxx[1].id==0) mxx[1]=x;

    if(x.y<=mny[0].y||mny[0].id==0) mny[1]=mny[0],mny[0]=x;
    else if(x.y<=mny[1].y||mny[1].id==0) mny[1]=x;

    if(x.y>=mxy[0].y||mxy[0].id==0) mxy[1]=mxy[0],mxy[0]=x;
    else if(x.y>=mxy[1].y||mxy[1].id==0) mxy[1]=x;
}
struct qaq{
    int i,x,w;
    friend bool operator <(const qaq &x,const qaq &y) {return x.w>y.w;}
}c[N];
int nowans;
struct tree
{
    int tr[N<<2];
    #define ls (now<<1)
    #define rs (now<<1|1)
    #define mid ((l+r)>>1)
    void modify(int now,int l,int r,int ml,int mr,int k)
    {
        if(ml<l||mr>r||ml>mr) return;
        if(l==ml&&r==mr) {tr[now]=max(tr[now],k);return;}
        if(mr<=mid) modify(ls,l,mid,ml,mr,k);
        else if(ml>mid) modify(rs,mid+1,r,ml,mr,k);
        else modify(ls,l,mid,ml,mid,k),modify(rs,mid+1,r,mid+1,mr,k);
    }
    int query(int now,int l,int r,int x)
    {
        if(l==r) return tr[now];
        if(x<=mid) return max(tr[now],query(ls,l,mid,x));
        else return max(tr[now],query(rs,mid+1,r,x));
    }
}seg;
signed main()
{
    int q=read(),mx=q,lst=0;
    while(q--)
    {
        int op=read();
        if(op==1)
        {
            node now; 
            now.x=read()^(lst%3),now.y=read()^(lst%3);
            w[++cnt]=read()^(lst%3); 
            now.id=cnt;
            now={now.x+now.y,now.x-now.y,now.id};
            upd(now);
            int tot=0;
            for(int i=0;i<=1;i++)
            {
                c[++tot]={cnt,mnx[i].id,dis(mnx[i],now)+w[cnt]};
                c[++tot]={cnt,mxx[i].id,dis(mxx[i],now)+w[cnt]};
                c[++tot]={cnt,mny[i].id,dis(mny[i],now)+w[cnt]};
                c[++tot]={cnt,mxy[i].id,dis(mxy[i],now)+w[cnt]};
            }
            //cout<<"qaq "<<cnt<<endl;
            sort(c+1,c+tot+1);
            int QWQ=0;
            for(int i=1;i<=8;i++)
            {
                int x=c[i].x,y=c[i].i,w=c[i].w;
                if(x==0) continue;
                if(c[i].x!=c[i-1].x) QWQ++;
                else continue;
                if(QWQ>=3) break;
                //cout<<x<<" "<<y<<" "<<w<<endl;
                seg.modify(1,1,mx,1,x-1,w),seg.modify(1,1,mx,x+1,y-1,w);
                seg.modify(1,1,mx,y+1,mx,w);
                nowans=max(nowans,w);
            }
        }
        else if(op==2) lst=nowans,printf("%lld\n",nowans);
        else
        {
            int x=read();lst=seg.query(1,1,mx,x);
            printf("%lld\n",lst);
        }
    }
    return 0;
}
```

---

## 作者：RsCb (赞：2)

本题无须线段树。

首先考虑操作 $1$ 和 $2$。

我们发现，两点的芙兰距离就是两点的曼哈顿距离加上后加入那个点的力量值。于是对于最大芙兰距离，只须在加入一个点后找到距离这个点最远的点（距离指曼哈顿距离），用这两个点之间的芙兰距离更新答案。

至于如何找到距离最远的点（如果你知道怎么找的话可以跳过这部分），我们发现：

$$
\begin{aligned}
&|x_1-x_2|+|y_1-y_2|\\
=&\max\{x_1-x_2+y_1-y_2,x_2-x_1+y_1-y_2,x_1-x_2+y_2-y_1,x_2-x_1+y_2-y_1\}\\
=&\max\{(x_1+y_1)-(x_2+y_2),(y_1-x_1)-(y_2-x_2),(x_1-y_1)-(x_2-y_2),(-x_1-y_1)-(-x_2-y_2)\}
\end{aligned}
$$

设加入一点后共有 $n$ 个点，则我们要求的最大距离为：

$$
\begin{aligned}
&\max_{i=1}^n|x_i-x_n|+|y_i-y_n|\\
=&\max_{i=1}^n(\max\{(x_i+y_i)-(x_n+y_n),(y_i-x_i)-(y_n-x_n),(x_i-y_i)-(x_n-y_n),(-x_i-y_i)-(-x_n-y_n)\})\\
=&\max\left\{\left(\max_{i=1}^n(x_i+y_i)\right)-(x_n+y_n),\left(\max_{i=1}^n(y_i-x_i)\right)-(y_n-x_n),\left(\max_{i=1}^n(x_i-y_i)\right)-(x_n-y_n),\left(\max_{i=1}^n(-x_i-y_i)\right)-(-x_n-y_n)\right\}
\end{aligned}
$$

因此，只要维护好最大的 $(x+y),(x-y),(y-x),(-x-y)$ 对应的四个点，加入新点时从这四个点中选距离最远的即可。（细节：加入新点时先更新四个最大值再找点，因为最远的点可能是它自己。）

$30\,\rm pts$ 代码：

```cpp
#include<bits/stdc++.h>
#define u first
#define v second
const int INF = 0x3f3f3f3f;
const int N = 2e6+7;
int n, q, x[N], y[N], v[N];
int far[4], max;
int lstans;
int dis0(int pos, int a){
    return (pos&1? 1:-1) * x[a] + (pos&2? 1:-1) * y[a];
}
int dis(int a, int b){
    if(!a || !b) return -INF;
    return abs(x[a]-x[b]) + abs(y[a]-y[b]) + v[std::max(a, b)];
}
int getmax(int a){
    int res = 0;
    for(int i=0; i<4; i++)
        if(!res || dis(a, res) < dis(a, far[i]))
            res = far[i];
    return res;
}
int main(){
    scanf("%d", &q);
    while(q--){
        int op; scanf("%d", &op);
        switch(op){
        case 1:{
            n++;
            scanf("%d%d%d", x+n, y+n, v+n);
            x[n] ^= lstans, y[n] ^= lstans, v[n] ^= lstans;
            for(int i=0; i<4; i++){
                if(!far[i] || dis0(i, far[i]) < dis0(i, n))
                    far[i] = n;
            }
            max = std::max(max, dis(getmax(n), n));
            break;
        }
        case 2:{
            lstans = max;
            printf("%d\n", lstans);
            lstans %= 3;
            break;
        }
        }
    }
}
```

现在考虑操作 $3$。

设一个点对 $A$ 中，$A.u$ 表示编号较大的点，$A.v$ 表示编号较小的点。设 $\operatorname{dis}(A)$ 表示点对 $A$ 中两点的芙兰距离。

我们可以维护 $\textit{max},\textit{max}_{\cancel{u}},\textit{max}_{\cancel{v}}$，分别表示所有点对中芙兰距离最大的点对、没有 $\textit{max}.u$ 的点对中芙兰距离最大的点对和没有 $\textit{max}.v$ 的点对中芙兰距离最大的点对。

设 $\operatorname{qry}(a)$ 表示没有 $a$ 的点对中芙兰距离最大的点对，则：

$$
\operatorname{qry}(a)=\begin{cases}
\textit{max}&a\ne\textit{max}.u\text{ and }a\ne\textit{max}.v\\
\textit{max}_{\cancel{u}}&a=\textit{max}.u\\
\textit{max}_{\cancel{v}}&a=\textit{max}.v
\end{cases}
$$

代码如下（其中 `maxxu` 是 $\textit{max}_{\cancel{u}}$，`maxxv` 是 $\textit{max}_{\cancel{u}}$）：
```cpp
std::pair<int, int> qry(int a){
    if(!a) return max;
    if(a == max.u)
        return maxxu;
    if(a == max.v)
        return maxxv;
    return max;
}
```

于是，操作 $2$ 的答案为 $\operatorname{dis}(\textit{max}\,)$，操作 $3$ 的答案为 $\operatorname{dis}(\operatorname{qry}(a))$。

显然，想要维护这三个点对，在加入一个点时我们不仅要找到距离该点最远的点，还要找到次远的点。

于是我们现在维护四个方向的最大值和不严格次大值对应的八个点，加入新点时从这八个点中选距离最大和次大的即可。（细节：八个点中可能出现相同的点，注意最大和次大必须是不同的两点。）

代码如下（其中 `far1` 是四个方向上的最远点，`far2` 是次远点）：
```cpp
int dis0(int pos, int a){
    return (pos&1? 1:-1) * x[a] + (pos&2? 1:-1) * y[a];
}
std::pair<int, int> getmax(int a){
    int fst = 0, snd = 0;
    for(int i=0; i<4; i++)
        if(!fst || dis(a, fst) < dis(a, far1[i]))
            fst = far1[i];
    for(int i=0; i<4; i++)
        if(fst == far1[i]){
            if(!snd || dis(a, snd) < dis(a, far2[i]))
                snd = far2[i];
        }else{
            if(!snd || dis(a, snd) < dis(a, far1[i]))
                snd = far1[i];
        }
    return {fst, snd};
}
```
```cpp
for(int i=0; i<4; i++){
    if(!far1[i] || dis0(i, far1[i]) < dis0(i, n))
        far2[i] = far1[i], far1[i] = n;
    else if(!far2[i] || dis0(i, far2[i]) < dis0(i, n))
        far2[i] = n;
}
std::pair<int, int> res = getmax(n);
std::pair<int, int> now1 = {n, res.first};
std::pair<int, int> now2 = {n, res.second};
```

我们假设已经找到了最大点和次大点，它们和当前点组成的点对分别记为 $\textit{now1}$ 和 $\textit{now2}$。

- 如果 $\operatorname{dis}(\textit{now1}\,)>\operatorname{dis}(\textit{max}\,)$，则 $\textit{max}$ 变为 $\textit{now1}$，由于之前一定不存在 $\textit{now1}.u$，因此 $\textit{max}_{\cancel{u}}$ 变为之前的 $\textit{max}$，而 $\textit{max}_{\cancel{v}}$ 变为之前情况下的 $\operatorname{qry}(\textit{now1}.v)$ 和 $\textit{now2}$ 两个中 $\operatorname{dis}$ 较大的一个。（在代码中可以先更新 $\textit{max}_{\cancel{v}}$ 再更新 $\textit{max}_{\cancel{u}}$ 最后更新 $\textit{max}$。）

- 如果 $\operatorname{dis}(\textit{now1}\,)<\operatorname{dis}(\textit{max}\,)$ 我们直接依次将 $\textit{now1},\textit{now2}$ 和 $\textit{max}_{\cancel{u}},\textit{max}_{\cancel{v}}$ 比较，如果前者中没有后者禁止的点且前者距离大于后者，那么就将前者更新到后者。

代码如下：
```cpp
if(dis(now1) > dis(max)){
    std::pair<int, int> tmp = qry(now1.v);
    maxxv = dis(now2) > dis(tmp)? now2 : tmp;
    maxxu = max;
    max = now1;
}
else{
    if(now1.v != max.u)
        maxxu = dis(now1) > dis(maxxu)? now1 : maxxu;
    if(now1.v != max.v)
        maxxv = dis(now1) > dis(maxxv)? now1 : maxxv;
    if(now2.v != max.u)
        maxxu = dis(now2) > dis(maxxu)? now2 : maxxu;
    if(now2.v != max.v)
        maxxv = dis(now2) > dis(maxxv)? now2 : maxxv;
}
```

然后，本题就完成了。但是还有一点：**记得进行题目要求的强制在线操作**。我因为忘了这个调了好久。

代码：
```cpp
#include<bits/stdc++.h>
#define u first
#define v second
const int INF = 0x3f3f3f3f;
const int N = 2e6+7;
int n, q, x[N], y[N], v[N];
int far1[4], far2[4];
std::pair<int, int> max, maxxu, maxxv;
int lstans;
int dis0(int pos, int a){
    return (pos&1? 1:-1) * x[a] + (pos&2? 1:-1) * y[a];
}
int dis(int a, int b){
    if(!a || !b) return -INF;
    return abs(x[a]-x[b]) + abs(y[a]-y[b]) + v[std::max(a, b)];
}
int dis(std::pair<int, int> a){
    return dis(a.first, a.second);
}
std::pair<int, int> getmax(int a){
    int fst = 0, snd = 0;
    for(int i=0; i<4; i++)
        if(!fst || dis(a, fst) < dis(a, far1[i]))
            fst = far1[i];
    for(int i=0; i<4; i++)
        if(fst == far1[i]){
            if(!snd || dis(a, snd) < dis(a, far2[i]))
                snd = far2[i];
        }else{
            if(!snd || dis(a, snd) < dis(a, far1[i]))
                snd = far1[i];
        }
    return {fst, snd};
}
std::pair<int, int> qry(int a){
    if(!a) return max;
    if(a == max.u)
        return maxxu;
    if(a == max.v)
        return maxxv;
    return max;
}
int main(){
    scanf("%d", &q);
    while(q--){
        int op; scanf("%d", &op);
        switch(op){
        case 1:{
            n++;
            scanf("%d%d%d", x+n, y+n, v+n);
            x[n] ^= lstans, y[n] ^= lstans, v[n] ^= lstans;
            for(int i=0; i<4; i++){
                if(!far1[i] || dis0(i, far1[i]) < dis0(i, n))
                    far2[i] = far1[i], far1[i] = n;
                else if(!far2[i] || dis0(i, far2[i]) < dis0(i, n))
                    far2[i] = n;
            }
            std::pair<int, int> res = getmax(n);
            std::pair<int, int> now1 = {n, res.first};
            std::pair<int, int> now2 = {n, res.second};
            if(dis(now1) > dis(max)){
                std::pair<int, int> tmp = qry(now1.v);
                maxxv = dis(now2) > dis(tmp)? now2 : tmp;
                maxxu = max;
                max = now1;
            }
            else{
                if(now1.v != max.u)
                    maxxu = dis(now1) > dis(maxxu)? now1 : maxxu;
                if(now1.v != max.v)
                    maxxv = dis(now1) > dis(maxxv)? now1 : maxxv;
                if(now2.v != max.u)
                    maxxu = dis(now2) > dis(maxxu)? now2 : maxxu;
                if(now2.v != max.v)
                    maxxv = dis(now2) > dis(maxxv)? now2 : maxxv;
            }
            break;
        }
        case 2:{
            lstans = dis(max);
            printf("%d\n", lstans);
            lstans %= 3;
            break;
        }
        case 3:{
            int a; scanf("%d", &a);
            lstans = dis(qry(a));
            printf("%d\n", lstans);
            lstans %= 3;
            break;
        }
        }
    }
}
```


---

## 作者：AC_love (赞：0)

题解区有两篇线段树做法的题解，复杂度 $O(m \log m)$。还有一篇线性做法的题解，但我好像没怎么看懂，于是自己写了一个和那篇题解不太一样的其他线性做法。

设 $f(i)$ 表示 $i$ 是后一个点时的最大值，$g(i)$ 表示此时前一个点的编号，$f'(i)$ 表示 $i$ 是后一个点时的非严格次大值。

考虑插入一个点时如何快速处理 $f, g, f'$ 三个数组。曼哈顿距离不好处理，考虑转成切比雪夫距离。然后我们实时维护八个点代表 $x, y$ 方向上的最大 / 次大 / 最小 / 次小值，利用这些信息可以在 $O(1)$ 时间内快速处理出 $f, g, f'$ 三个数组。

对于 $2$ 询问，显然问的是 $f$ 的全局最大值，直接维护即可，接下来考虑如何处理 $3$ 询问。

显然对于某次询问，如果此时有 $n$ 个点，询问时删除了第 $x$ 号点，显然答案应该是：

$$\max(\max_{i = 1}^{x - 1} f(i), \max_{i = x + 1}^n f'(i), \max_{i = x + 1}^n f(i) \times [g(i) \neq x])$$

为什么次大值 $f'$ 那里不需要考虑是从哪个点转移来的？因为如果次大值是从 $x$ 转移来的，那么最大值一定不是从 $x$ 来的。最大值严格不小于次大值，所以就算统计了非法的次大值也不会对答案产生影响。

第一部分可以直接处理前缀和 $O(1)$ 查询。但实际上我们不需要维护前缀和查询第一部分，这一部分我们可以一会儿扔到第三部分一起做。

第二部分看起来是个查询后缀和，但我们注意到因为 $f'(i) \le f(i)$，因此就算把 $\max_{i = 1}^{x - 1} f'(i)$ 统计进来也不会对答案产生影响。所以其实第二部分就是：

$$\max(\max_{i = 1}^{x - 1} f'(i), \max_{i = x + 1}^n f'(i))$$

换言之，就是查询整个 $f'$ 序列除了 $x$ 位置的最大值。

我们维护 $f'$ 序列的最大值，最大值的位置和次大值即可 $O(1)$ 查询。

现在难的是第三部分，如何 $O(1)$ 查询？

注意到第一部分的 $\max_{i = 1}^{x - 1} f(i)$，由于 $x$ 前面的所有数 $g$ 都不可能是 $x$，所以在后面乘上 $[g(i) \neq x]$ 也不会影响。

那么第一部分和第三部分可以合起来，长这样：

$$\max(\max_{i = 1}^{x - 1} f(i) \times [g(i) \neq x], \max_{i = x + 1}^n f(i) \times [g(i) \neq x])$$

其实这就是：

$$\max_{i = 1}^n f(i) \times [i \neq x] \times [g(i) \neq x]$$

这个东西怎么处理？

处理出 $f$ 的最大值，假设这个最大值为 $f(i)$。找到 $g(j) \neq i$ 的最大 $f(j)$ 和 $k \neq g(i)$ 且 $g(k) \neq g(i)$ 的最大 $f(k)$。当 $x = i$ 时答案为 $f(j)$，当 $x = g(i)$ 时答案为 $f(k)$，其他情况下答案为 $f(i)$，回答询问是 $O(1)$ 的。

并且我们发现在插入一个新 $f, g$ 的时候我们可以 $O(1)$ 更新 $f(i), f(j)$ 和 $f(k)$。具体做法如下：

设插入的数为 $y$。

- 若 $f(y) > f(i)$
  - 若 $g(y) = i$
    - 若 $g(k) = i$，则 $f(k) \leftarrow f(j), f(j) \leftarrow f(i), f(i) \leftarrow f(y)$
    - 反之，若 $g(k) \neq i$，则 $f(k) \leftarrow \max(f(j), f(k)), f(j) \leftarrow f(i), f(i) \leftarrow f(y)$
  - 反之，若 $g(y) \neq i$，但 $g(y) = g(i)$
    - 若 $g(j) = g(i)$ 或 $j = g(i)$，则 $f(k)$ 不变，$f(j) \leftarrow f(i), f(i) \leftarrow f(y)$
    - 反之，则 $f(k) \leftarrow \max(f(j), f(k)), f(j) \leftarrow f(i), f(i) \leftarrow f(y)$
  - 反之，则 $f(k) \leftarrow f(i), f(j) \leftarrow f(i), f(i) \leftarrow f(y)$
- 否则则判断能否用 $f(y)$ 更新 $f(j)$ 和 $f(k)$ 即可。

显然这些东西都是 $O(1)$ 的。

每一步操作都是 $O(1)$ 的，总复杂度自然是 $O(n)$ 的。

于是我们得到了一个线性做法，跑得还是飞快的，截至目前还是本题最优解来着。

---


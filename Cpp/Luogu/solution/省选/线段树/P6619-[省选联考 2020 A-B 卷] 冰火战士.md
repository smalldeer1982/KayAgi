# [省选联考 2020 A/B 卷] 冰火战士

## 题目背景

A 卷 D1T1，B 卷 D1T3。

时限 3s，内存 512MB。

## 题目描述

一场比赛即将开始。

每位战士有两个属性：温度和能量，有两派战士：冰系战士的技能会对周围造成降温冰冻伤害，因而要求场地温度不低于他的自身温度才能参赛；火系战士的技能会对周围造成升温灼烧伤害，因而要求场地温度不高于他的自身温度才能参赛。

当场地温度确定时，双方能够参赛的战士分别排成一队。冰系战士按自身温度从低到高排序，火系战士按自身温度从高到低排序，温度相同时能量大的战士排在前面。首先，双方的第一位战士之间展开战斗，两位战士消耗相同的能量，能量少的战士将耗尽能量退出比赛，而能量有剩余的战士将继续和对方的下一位战士战斗（能量都耗尽则双方下一位战士之间展开战斗）。如此循环，直至某方战士队列为空，比赛结束。

你需要寻找最佳场地温度：使冰火双方消耗总能量最高的温度的最高值。

现在，比赛还处于报名阶段，目前还没有任何战士报名，接下来你将不断地收到报名信息和撤回信息。其中，报名信息包含报名战士的派系和两个属性，撤回信息包含要撤回的报名信息的序号。每当报名情况发生变化（即收到一条信息）时，你需要立即报出当前局面下的最佳场地温度，以及该场地温度下双方消耗的总能量之和是多少。若当前局面下无论何种温度都无法开展比赛（某一方没有战士能参赛），则只要输出 `Peace`。

## 说明/提示

#### 样例 1 解释
为说明方便，约定：若第 $k$ 条信息是报名信息，则该条报名信息对应战士 $k$。样例中含有战士 $1,2,3,4,6,7,8$，由于第 $5$ 条是撤回信息，所以没有战士 $5$。

下面逐个解释每个输出：

1. 只有火系战士：战士 $1$，无法比赛，输出 `Peace`。
2. 温度为 $100 \sim 103$ 都能消耗最多的能量 $200$：战士 $1$ 对阵战士 $2$ 消耗能量 $200$，最佳温度为 $103$。
3. 温度为 $100 \sim 103$ 都能消耗最多的能量 $200$：战士 $1$ 对阵战士 $2$ 消耗能量 $200$，最佳温度为 $103$。
4. 温度 $103$ 能消耗最多的能量 $300$：首先，战士 $1$ 对阵战士 $2$ 消耗能量 $200$；然后，战士 $1$ 对阵战士 $4$ 消耗能量 $100$，最佳温度为 $103$。
5. 从现在起战士 $1$ 不再存在。温度 $100 \sim 102$ 能消耗最多的能量 $200$：战士 $2$ 对阵战士 $3$ 消耗能量 $200$，最佳温度为 $102$。

#### 样例 2

见附加文件中 `icefire2.in` 与 `icefire2.ans`。

#### 数据范围

$10\%$ 的数据：$Q \leq 100$，$x \leq 10^3$。

另有 $20\%$ 的数据：$Q \leq 10^4$，$x \leq 5000$，不存在撤回信息，且输入的 $x$ 按顺序不降。

$60\%$ 的数据（包含上述 $20\%$，下同）：$Q \leq 2 \times 10^5$，$x \leq 2 \times 10^5$。

$90\%$ 的数据：$Q \leq 2 \times 10^6$，$x \leq 2 \times 10^6$。

$100\%$ 的数据：$1 \leq Q \leq 2 \times 10^6$，$1 \leq x \leq 2 \times 10^9$，所有 $y$ 之和不超过 $2 \times 10^9$，保证不存在 $t, x, y$ 完全相同的两个战士。

## 样例 #1

### 输入

```
8
1 1 103 150
1 0 100 100
1 1 102 150
1 0 103 300
2 1
1 1 101 100
1 1 104 350
1 0 100 400```

### 输出

```
Peace
103 200
103 200
103 300
102 200
102 200
104 700
102 1000```

# 题解

## 作者：StudyingFather (赞：65)

注意到一旦双方出战名单确定，无论出战顺序如何，因为双方耗费的能量一定相同，且至少有一方能量耗尽时才能结束，因此答案是两队能量和最小值的两倍。

同时我们注意到一个性质：冰系战士的能量总和随温度升高而递增（本质上是一个前缀和），火系战士的能量总和随温度身高而下降（本质上是一个后缀和），因此如果我们把每个温度下消耗的能量标出来，答案是一个单峰曲线。

当然有两个问题：

1. 温度是离散的，因此曲线本质上也是离散的。这意味着我们可能找不到冰系战士能量和以及火系战士能量和曲线的交点；
2. 因为存在答案不变的段，三分显然不行。

不过我们还是能想到一个还算不错的算法：我们通过二分的方式来找两条曲线的交点。具体来说，我们找到使得冰系战士能量（记为 $f(k)$）小于火系战士能量（记为 $g(k)$）的最高温度 $k$，则一定有 $f(k+1) \geq g(k+1)$，这时候我们再找到一个最大的 $k'$，使得 $g(k+1)=g(k')$。

此时，最终答案必将在 $k$ 和 $k'$ 二者中取得其一，具体是哪一个取决于相应温度下能量消耗值的相对大小。

整个过程我们需要二分+树状数组（要查前后缀和）来实现，时间复杂度 $O(n \log^2 n)$，可以拿到 60 分。

考虑优化上面这个过程。树状数组肯定是没法省掉了，能不能不二分呢？答案是肯定的。

具体来说，我们采用了一种直接在树状数组上二分（倍增）的做法。这种方法的实质是利用之前计算过的信息，避免了重复计算。

假如我们现在在 $p$ 位置，我们不停尝试向前跳，跳的步长依次递减，为 $2^{20},2^{19},2^{18},\ldots,2^0$，如何判断 $p+d$ 这个位置满足要求呢？我们不用再重新计算 $p+d$ 的前缀（后缀）和，而是直接将树状数组上 $p+d$ 位置的信息累加到总和中即可。

熟悉树状数组的同学应该清楚，因为我们从高位向低位依此考虑，$p+d$ 这个位置刚好存储了 $[p+1,p+d]$ 这个区间内的所有信息，因此这样直接累加的做法是正确的。

剩下的就和原来 60 分的做法差不多了。

```cpp
// Problem : P6619 [省选联考 2020 A/B 卷] 冰火战士
// Contest : Luogu
// URL : https://www.luogu.com.cn/problem/P6619
// Memory Limit : 512 MB
// Time Limit : 3000 ms
// Powered by CP Editor (https://github.com/cpeditor/cpeditor)

#include <algorithm>
#include <iostream>
using namespace std;
struct query {
  int op;
  int k;
  int t, x, y;
} a[2000005];
struct BIT {
  long long a[2000005];
  int n;
  void init(int x) { n = x; }
  int lowbit(int x) { return x & (-x); }
  void add(int x, int y) {
    while (x <= n) a[x] += y, x += lowbit(x);
  }
  long long query(int x) {
    long long ans = 0;
    while (x) ans += a[x], x -= lowbit(x);
    return ans;
  }
  long long get(int x) { return a[x]; }
} tr0, tr1;
long long sum1;
int p[2000005], cnt;
int main() {
  ios::sync_with_stdio(false);
  cin.tie(0), cout.tie(0);
  int n;
  cin >> n;
  for (int i = 1; i <= n; i++) {
    cin >> a[i].op;
    if (a[i].op == 1) {
      cin >> a[i].t >> a[i].x >> a[i].y;
      p[++cnt] = a[i].x;
    } else
      cin >> a[i].k;
  }
  sort(p + 1, p + cnt + 1);
  cnt = unique(p + 1, p + cnt + 1) - p - 1;
  for (int i = 1; i <= n; i++)
    if (a[i].op == 1) a[i].x = lower_bound(p + 1, p + cnt + 1, a[i].x) - p;
  tr0.init(cnt), tr1.init(cnt);
  for (int i = 1; i <= n; i++) {
    if (a[i].op == 1) {
      if (!a[i].t)
        tr0.add(a[i].x, a[i].y);
      else
        tr1.add(a[i].x + 1, a[i].y), sum1 += a[i].y;
    } else {
      int k = a[i].k;
      if (!a[k].t)
        tr0.add(a[k].x, -a[k].y);
      else
        tr1.add(a[k].x + 1, -a[k].y), sum1 -= a[k].y;
    }
    long long s0 = 0, s1 = sum1;
    long long f1 = 0, f2 = 0;
    int p1 = 0, p2 = 0;
    for (int i = 20; i >= 0; i--) {
      int np = p1 + (1 << i), ns0 = s0 + tr0.get(np), ns1 = s1 - tr1.get(np);
      if (np > cnt) continue;
      if (ns0 < ns1) {
        p1 = np;
        s0 = ns0, s1 = ns1;
      }
    }
    f1 = s0, s0 = 0, s1 = sum1;
    if (p1 < cnt) {
      f2 = min(tr0.query(p1 + 1), sum1 - tr1.query(p1 + 1));
      for (int i = 20; i >= 0; i--) {
        int np = p2 + (1 << i), ns0 = s0 + tr0.get(np), ns1 = s1 - tr1.get(np);
        if (np > cnt) continue;
        if (ns0 < ns1) {
          p2 = np;
          s0 = ns0, s1 = ns1;
        } else if (min(ns0, ns1) == f2) {
          p2 = np;
          s0 = ns0, s1 = ns1;
        }
      }
    }
    if (max(f1, f2) == 0)
      cout << "Peace" << endl;
    else if (f1 > f2)
      cout << p[p1] << ' ' << f1 * 2 << endl;
    else
      cout << p[p2] << ' ' << f2 * 2 << endl;
  }
  return 0;
}
```

---

## 作者：duyi (赞：52)

[更好的阅读体验](https://www.cnblogs.com/dysyn1314/p/13196116.html)

[题目链接](https://loj.ac/problem/3299)

这个“比赛方式”被题目描述的花里胡哨，但实际上很简单：

> 假如设定比赛温度为$k$。那么，“有用”的冰系战士，就是$x_i\leq k$的这些冰系战士；“有用”的火系战士，就是$x_i\geq k$的这些火系战士。一场比赛的***价值***，就是冰火两方，“有用”的战士的$y_i$之**和**的**较小值**。具体来说，就是：
> $$
> \min\left(\sum_{i\in\text{ice},x_i\leq k}y_i,\sum_{i\in\text{fire},x_i\geq k}y_i\right)
> $$
> 我们要选择一个$k$，使得这个***价值***尽可能大。如果有多个$k$能使价值最大，则选最大的$k$。

首先容易发现，最优的$k$一定是某名战士的温度。所以我们可以把所有战士的温度先离散化，然后答案就只要在这些值里面找即可。

考虑两个函数，一个是$f_{\text{ice}}(k)=\sum_{i\in\text{ice},x_i\leq k}y_i$，一个是$f_{\text{fire}}(k)=\sum_{i\in\text{fire},x_i\geq k}y_i$。那么，我们就是要取一个$k$，使得$\min(f_{\text{ice}}(k),f_{\text{fire}}(k))$最大。

发现，$f_{\text{ice}}(k)$是单调不下降的；$f_{\text{fire}}(k)$是单调不上升的。如果把它们一起画出来，大概是“打一个叉”的样子。

![](https://cdn.luogu.com.cn/upload/image_hosting/lxoyj3ty.png)

考虑设$\text{res}(k)=\min(f_{\text{ice}}(k),f_{\text{fire}}(k))$，则画出来应该是这样，也就是图中黑色的这条线。

![](https://cdn.luogu.com.cn/upload/image_hosting/ooec0ibp.png)

发现，当$f_{\text{ice}}(k)$和$f_{\text{fire}}(k)$相交时，$\text{res}(k)$取到最大值。但是实际上，由于两个函数并不连续（$k$只能取整数），所以有两个可能的最优$k$：

- 一个是，最大的，使得$f_{\text{ice}}(k)<f_{\text{fire}}(k)$的$k$。
- 另一个是，最小的，使得$f_{\text{ice}}(k)\geq f_{\text{fire}}(k)$的$k$。

容易想到二分答案。考虑用数据结构维护$f_{\text{ice}}(k)$和$f_{\text{fire}}(k)$，我们需要支持区间加、单点查询。例如，每个冰系战士，是对所有$k\geq x_i$（一段后缀），令它们的$f_{\text{ice}}(k)$值加上$y_i$；一个火系战士，是对所有$k\leq x_i$（一段前缀），令它们的$f_{\text{fire}}(k)$值加上$y_i$。（当然，你也可以转化，或者说理解为，单点加，区间求和，这本质上是一样的）。这个数据结构，可以用线段树或树状数组。这样做，时间复杂度是$O(n\log^2n)$的，无法AC。

继续优化。你看，又是线段树，又是二分，你很容易想到线段树上二分。对每个区间，维护这个区间左端点的$f_{\text{ice}}(l)$和$f_{\text{fire}}(l)$，右端点的$f_{\text{ice}}(r)$和$f_{\text{fire}}(r)$，就可以二分了。具体来说，我们要做三次“线段树上二分”。第一次，找到【最大的，使得$f_{\text{ice}}(k)<f_{\text{fire}}(k)$的$k$】。第二次，找到【最小的，使得$f_{\text{ice}}(k)\geq f_{\text{fire}}(k)$的$k$】（当然，这里第二个$k$其实就是第一个$k$加$1$的位置。但是我们不光要知道位置，还需要知道这个位置上$\min(f_{\text{ice}}(k),f_{\text{fire}}(k))$的具体的值，所以还是需要再做一次线段树上操作的）。那么，最大价值，就是这两个$k$对应价值的较大者。然而，如果价值较大的$k$是第二个，你会发现，它后面，可能还存在价值和它一样的$k$。而根据题目要求，如果价值一样，我们要找到最后一个$k$。所以此时我们还需要把这个“最大价值”带入，再二分一次，找到价值等于这个“最大价值”的、最靠后的$k$。因此，一共需要做三次“线段树上二分”，虽然时间复杂度变成了$O(n\log n)$，但是常数实在是太大了，最终可能和树状数组实现的$O(n\log^2n)$做法得分差不多。

我们继续优化。其实，树状数组上也是可以二分的。这个“二分”的实现，其实更像“倍增”。例如用倍增法求LCA时，我们从大到小枚举当前节点的$2^{\log n}\dots 2^0$次祖先，能往上跳就往上跳。在树状数组上也是一样，每次检查从当前点，往前跳$2^i$个位置，是否“可行”。如果“可行”，就跳过去。否则位置不变。这里“往前跳$2^i$是否可行”怎么“检查”，其实就是看树状数组上$\text{curpos}+2^i$的这个位置里填的数。这是由于树状数组的性质：$c[i]$里填的是，$[i-\operatorname{lowbit}(i)+1,i]$这段区间的信息。那么$\text{curpos}+2^i$，这个位置，填的就是$[\text{curpos}+1,\text{curpos}+2^i]$这段的信息。

现在我们会在树状数组上二分了。回到本题。我们用树状数组，还是维护$f_{\text{ice}}(k)$和$f_{\text{fire}}(k)$这两个东西。修改的时候，是区间修改，可以用树状数组的套路：差分，转化为单点修改。具体来说，如果是后缀加，则直接在开始位置加；如果是前缀加，则先用一个全局变量记录，再把后缀减掉（这样只需要一次树状数组上操作）。

查询的时候，先二分出【最大的，使得$f_{\text{ice}}(k)<f_{\text{fire}}(k)$的$k$】和【最小的，使得$f_{\text{ice}}(k)\geq f_{\text{fire}}(k)$的$k$】，并查询出它们的$f$值。如果第二个$f$值更大，则带入这个值，再二分一次。就和线段树的做法类似。所以最多需要3次树状数组上操作。由于树状数组常数小得多，所以可以通过。

时间复杂度$O(n\log n)$。

注意：要使用读入优化。

参考代码（[在LOJ查看](https://loj.ac/submission/846934)）：

```cpp
//problem:LOJ3299
#include <bits/stdc++.h>
using namespace std;

#define pb push_back
#define mk make_pair
#define lob lower_bound
#define upb upper_bound
#define fi first
#define se second
#define SZ(x) ((int)(x).size())

typedef unsigned int uint;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<int,int> pii;

/* --------------- fast io --------------- */ // begin
namespace Fread{
const int SIZE=1<<20;
char buf[SIZE],*S,*T;
inline char getchar(){
	if(S==T){
		T=(S=buf)+fread(buf,1,SIZE,stdin);
		if(S==T)return EOF;
	}
	return *S++;
}
}//namespace Fread
namespace Fwrite{
const int SIZE=1<<20;
char buf[SIZE],*S=buf,*T=buf+SIZE;
inline void flush(){
	fwrite(buf,1,S-buf,stdout);
	S=buf;
}
inline void putchar(char c){
	*S++=c;
	if(S==T)flush();
}
struct _{
	~_(){flush();}
}__;
}//namespace Fwrite

#ifdef ONLINE_JUDGE
	#define getchar Fread::getchar
	#define putchar Fwrite::putchar
#endif

template<typename T>inline void read(T& x){
	x=0;int f=1;
	char c=getchar();
	while(!isdigit(c)){if(c=='-')f=-1;c=getchar();}
	while(isdigit(c))x=x*10+(c-'0'),c=getchar();
	x*=f;
}
template<typename T>inline void write(T x,bool _enter=0,bool _space=0){
	if (!x)putchar('0');else{
		if(x<0)putchar('-'),x=-x;
		static char dig[41];
		int top=0;
		while(x)dig[++top]=(x%10)+'0',x/=10;
		while(top)putchar(dig[top--]);
	}
	if(_enter)putchar('\n');
	if(_space)putchar(' ');
}

namespace Fastio{
struct reader{
	template<typename T>reader& operator>>(T& x){::read(x);return *this;}
	reader& operator>>(char& c){
		c=getchar();
		while(c=='\n'||c==' ')c=getchar();
		return *this;
	}
	reader& operator>>(char* str){
		int len=0;
		char c=getchar();
		while(c=='\n'||c==' ')c=getchar();
		while(c!='\n'&&c!=' ')str[len++]=c,c=getchar();
		str[len]='\0';
		return *this;
	}
}cin;
const char endl='\n';
struct writer{
	template<typename T>writer& operator<<(T x){::write(x,0,0);return *this;}
	writer& operator<<(char c){putchar(c);return *this;}
	writer& operator<<(const char* str){
		int cur=0;
		while(str[cur])putchar(str[cur++]);
		return *this;
	}
}cout;
}//namespace Fastio
#define cin Fastio::cin
#define cout Fastio::cout
#define endl Fastio::endl
/* --------------- fast io --------------- */ // end

const int MAXN=2e6;
int m,vals[MAXN+5],cnt_val;
struct Event{
	int op,t,x,y;
}ev[MAXN+5];

struct FenwickTree{
	int sz;
	int fire[MAXN+5],ice[MAXN+5],delta_fire;
	void modify_ice(int pos,int val){
		//后缀加 -> 单点加,查询时查前缀和
		for(int p=pos;p<=sz;p+=(p&(-p))){
			ice[p]+=val;
		}
	}
	void modify_fire(int pos,int val){
		//前缀加 -> 后缀减,总偏移量加
		delta_fire+=val;
		for(int p=pos+1;p<=sz;p+=(p&(-p))){
			fire[p]-=val;
		}
	}
	int query_min(int pos){//min(ice,fire)
		int ice_sum=0,fire_sum=delta_fire;
		for(int p=pos;p;p-=(p&(-p))){
			ice_sum+=ice[p];
			fire_sum+=fire[p];
		}
		return min(ice_sum,fire_sum);
	}
	int find1(){
		//最后一个ice-fire<0的位置
		int p=0,s=-delta_fire;
		for(int i=20;i>=0;--i){
			if(p+(1<<i)>sz)continue;
			int nxt=s+(ice[p+(1<<i)]-fire[p+(1<<i)]);
			if(nxt<0){
				s=nxt;
				p+=(1<<i);
			}
		}
		return p;
	}
	int find2(int goal_min){
		//最后一个min(ice,fire)=val的位置
		int p=0,ice_sum=0,fire_sum=delta_fire;
		for(int i=20;i>=0;--i){
			if(p+(1<<i)>sz)continue;
			int new_ice=ice_sum+ice[p+(1<<i)];
			int new_fire=fire_sum+fire[p+(1<<i)];
			if(new_ice<new_fire){
				ice_sum=new_ice;
				fire_sum=new_fire;
				p+=(1<<i);
			}
			else{
				assert(min(new_ice,new_fire)<=goal_min);
				if(min(new_ice,new_fire)==goal_min){
					ice_sum=new_ice;
					fire_sum=new_fire;
					p+=(1<<i);
				}
			}
		}
		return p;
	}
	void resize(int _sz){sz=_sz;}
	FenwickTree(){}
}T;

int main() {
	//freopen("icefire.in","r",stdin);
	//freopen("icefire.out","w",stdout);
	cin>>m;
	for(int i=1;i<=m;++i){
		cin>>ev[i].op;
		if(ev[i].op==1){
			cin>>ev[i].t>>ev[i].x>>ev[i].y;
			vals[++cnt_val]=ev[i].x;
		}
		else{
			int j;cin>>j;
			ev[i].t=ev[j].t;
			ev[i].x=ev[j].x;
			ev[i].y=-ev[j].y;
		}
	}
	sort(vals+1,vals+cnt_val+1);
	cnt_val=unique(vals+1,vals+cnt_val+1)-(vals+1);
	for(int i=1;i<=m;++i){
		ev[i].x=lob(vals+1,vals+cnt_val+1,ev[i].x)-vals;
		//cout<<ev[i].x<<endl;
	}
	T.resize(cnt_val);
	for(int i=1;i<=m;++i){
		if(ev[i].t==0)
			T.modify_ice(ev[i].x,ev[i].y);
		else
			T.modify_fire(ev[i].x,ev[i].y);
		/*
		//暴力
		pii res=mk(-1,-1);
		for(int j=1;j<=cnt_val;++j){
			res=max(res,mk(T.query_min(j),j));
		}
		*/
		int p1=T.find1();
		pii res1=mk(-1,-1);
		if(p1>0){
			res1=mk(T.query_min(p1),p1);
		}
		pii res2=mk(-1,-1);
		if(p1<cnt_val){
			int goal_min=T.query_min(p1+1);
			int p2=T.find2(goal_min);
			//assert(p2>=p1+1);
			//assert(T.query_min(p2)==goal_min);
			//assert(p2==cnt_val||T.query_min(p2+1)<goal_min);
			res2=mk(goal_min,p2);
		}
		pii res=max(res1,res2);
		
		if(res.fi==0)
			cout<<"Peace"<<endl;
		else
			cout<<vals[res.se]<<" "<<res.fi*2<<endl;
	}
	return 0;
}
```


---

## 作者：Star_Cried (赞：31)

## [省选联考 2020 A/B 卷] 冰火战士

`tag`树状数组二分

对树状数组的理解加深了！

### 转化题意

动态维护一个单调不降和一个单调不增序列，每次修改后输出两序列取最小值后的最大值和其最大位置。

### 思路

首先，阅读原题，知道最后答案一定是某个战士的温度，所以我们将温度离散化。

再次阅读，发现冰系是一个（以温度为自变量的）单调不降序列，每次修改一个战士就是修改一段后缀。火系相反，修改前缀。

深度阅读，发现题目其实就是求两个序列的交点。

于是转化成上述题意。

考虑二分答案求出两点的交，即温度最大的冰系能量和不大于火系能量和的位置。如果用树状数组动态维护每次查询的话，时间复杂度是两个 $\log$ ，无法通过。

实际上，树状数组也是可以二分的。

回忆树状数组的树形结构，**一个点 $P+2^i$ 实际上存储了 $P+1$到$P+2^i$ 的所有信息**，所以我们在树状数组上二分，实际上就是像倍增一样，**从大到小依次枚举这个点加上 $2^i$ 的祖先**，能跳则跳。

于是我们就可以A了这题了。注意我这里存储火系前缀和的方式是记录一个全局和再在树状数组上减去。

最后答案乘二。

### 实现

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cctype>
#include<cmath>
using namespace std;
inline int read(){
	int x=0,w=0;char c=getchar();
	while(!isdigit(c)) w|=c=='-',c=getchar();
	while(isdigit(c)) x=x*10+(c^48),c=getchar();
	return w?-x:x;
}
namespace star
{
	const int maxn=4e6+10;
	int n,b[maxn],cnt,sumfire;
	struct BIT{
		int c[maxn];
		inline void update(int x,int k){for(;x<=cnt;x+=x&-x)c[x]+=k;}
	}S1,S2;
	inline int query(int x){
		if(x<1 or x>cnt) return 0;
		int ans1=0,ans2=sumfire;
		for(;x;x-=x&-x) ans1+=S1.c[x],ans2+=S2.c[x];
		return min(ans1,ans2);
	}
	struct query{
		bool type;
		int t,v,op;
	}e[maxn];
	inline void work(){
		n=read();
		for(int i=1;i<=n;i++)
			if((e[i].op=read())==1)
				e[i].type=read(),e[i].t=b[++cnt]=read(),e[i].v=read();
			else e[i]=e[read()],e[i].op=2,e[i].v=-e[i].v;
		sort(b+1,b+1+cnt);
		cnt=unique(b+1,b+1+cnt)-b-1;
		for(int i=1;i<=n;i++) e[i].t=lower_bound(b+1,b+1+cnt,e[i].t)-b;
		for(int i=1;i<=n;i++){
			if(e[i].type==0) S1.update(e[i].t,e[i].v);
				else S2.update(e[i].t+1,-e[i].v),sumfire+=e[i].v;
			int x1=0,sum=-sumfire;
			for(int j=21;~j;j--){
				int to=x1|(1<<j),zp;
				if(to<=cnt and  (zp=sum+S1.c[to]-S2.c[to])<=0) sum=zp,x1=to;
			}
			int ans1=query(x1),x2=x1+1,ans2=query(x2);
			if(ans1<=0 and ans2<=0)puts("Peace");
			else if(ans1>ans2) printf("%d %d\n",b[x1],ans1<<1);
			else {
				int p=0,sum=sumfire;
				for(int j=21;~j;j--){
					int to=p|(1<<j),zp;
					if(to<=cnt and (zp=sum+S2.c[to])>=ans2) sum=zp,p=to;
				}//因为现在的情况一定是火系战士能量低所以光用火系的找答案就行了
				printf("%d %d\n",b[p],sum<<1);
			}
		}
	}
}
signed main(){
	star::work();
	return 0;
}
```

### 其他

* 三分是不正确的因为这玩意的峰不知道在哪而且会有平台。
* 如果用其他方式存火系的信息请务必考虑是否算进了当前点的值。
* ~~听说这题数据特水每次暴力移动上次答案的指针都能过~~
* 输出太大在洛谷上OLE了，但LOJ上可以提交，希望管理员修复一下~

---

## 作者：TheShadow (赞：13)

## Solution

**若有什么不明白的地方可以结合代码理解**

首先，显然的一点是选定一个温度后，消耗的总能量之和等于对该温度贡献较少一方的贡献乘 $2$ 。

分别考虑冰火战士对那些温度会有贡献。

- 冰战士：只会对温度大于等于自身温度的有贡献，所以对应的是一个单调不降的函数。

- 火战士：只会对温度小于等于自身温度的有贡献，所以对应的是一个单调不升的函数。

那么我们需要做的事就是对这两个函数取一个最小值。

若我们将最小值写成一个函数，一个显而易见的事实是：这个函数是下凸的。

这时候可能有些鸽鸽就要用三分来写了，可是会发现这东西很多地方都是连续不变的，三分可以被精心构造的数据卡掉。

这时候我们需要用到一个小技巧：将两个函数做差，由于一个不降，一个不升，所以最后得到的结果一定是不降的。

由于要找最小值的最大值，我们可以先假定冰战士的贡献严格小于火战士的贡献。那么我们要找的就是最大的使得差值小于 $0$ 的温度，这个东西显然是可以用二分来解决的。

那么这时候就有两个思路了：

1. 线段树上二分
2. 二分套树状数组

然后发现上面虽然是一个 $\log$ 的，但是由于常数问题和下面的两个 $\log$ 速度差不多，而且由于输入输出过大，都会被卡。

然后我们又可以引入另一个技巧，将二分套树状数组的复杂度优化至一个 $\log$ 。

具体来说，我们在查询树状数组上的前缀时，每次会减去一个 $lowbit$ ，那么我们倒着来，每次加入一个 $lowbit$ ，能加则加，根据二进制的性质，找出的显然是最大的。

但是火战士的贡献是给一个前缀加后缀查，我们可以考虑记录一个偏移量 $delta$ ，然后即可改为后缀加前缀查。

然后再考虑冰战士的贡献不小于火战士的贡献的情况。

由于之前求出了最大的小于的位置，那么加一就是最小的大于的情况。但是要求温度要最高，所以我们还要找到火战士中同一贡献的最高温度。这依旧可以像上面一样利用树状数组快速解决。

至此，我们就以 $O(n\log n)$ 的复杂度解决了该题。

## Code

```c++
#include<bits/stdc++.h>
#define del(a,i) memset(a,i,sizeof(a))
#define ll long long
#define inl inline
#define il inl void
#define it inl int
#define ill inl ll
#define re register
#define ri re int
#define rl re ll
#define mid ((l+r)>>1)
#define lowbit(x) (x&(-x))
#define INF 0x3f3f3f3f
using namespace std ;
template< class T > inl T read() {
	T x = 0 ; int f = 1 ; char k = getchar() ;
	for( ; k > '9' || k < '0'; k = getchar() ) if( k == '-' ) f = -1 ;
	for( ; k >= '0' && k <= '9'; k = getchar() ) x = x * 10 + k - '0' ;
	return x * f ;
}
template< class T > inl T read( T &x ) { return x = read<T>() ; }
int _num, _buf[20];
template< class T > il print( T x ) {
   	if( x == 0 ) return putchar( '0' ) ,void() ;
	if( x < 0 ) putchar( '-' ), x = -x ;
	while( x ) _buf[++_num] = x % 10, x /= 10 ;
	while( _num ) putchar( _buf[_num--] + '0' ) ;
}
ll mul( ll a, ll b, ll mod ) { long double c = 1. ; return ( a * b - (ll)( c * a * b / mod ) * mod ) % mod ; }
it qpow( int x, int m, int mod ) {
	int res = 1, bas = x ;
	while(m) {
		if( m & 1 ) res = ( 1ll * res * bas ) % mod ;
		bas = ( 1ll * bas * bas ) % mod, m >>= 1 ;
	}
	return res ;
}
const int N = 2e6 + 5 ;
int n, sz, delta, s[N];
struct Node {
	int opt, ty, x, y;
}node[N];
struct Fenwick {
	int bit[N];
	il Updata( int pos, int k ) {
		for( ri i = pos; i <= sz; i += lowbit( i ) )
			bit[i] += k ;
	}
	it Query( int pos ) {
		int res = 0 ;
		for( ri i = pos; i; i -= lowbit( i ) )
			res += bit[i] ;
		return res ;
	}
}T[2];
int main() {
//	freopen( "icefire.in", "r", stdin ) ;
//	freopen( "icefire.out", "w", stdout ) ;
	n = read<int>() ;
	for( ri i = 1; i <= n; ++i ) {
		int opt = read<int>(), ty = read<int>() ;
		if( opt == 1 ) {
			int x = read<int>(), y = read<int>() ;
			node[i] = { opt, ty, x, y } ;
			s[++sz] = x ;
		}
		else
			node[i] = { opt, ty, 0, 0 } ;
	}
	std::sort( s + 1, s + 1 + sz ) ;
	sz = std::unique( s + 1, s + 1 + sz ) - s - 1 ;
	for( ri i = 1; i <= n; ++i ) {
		int opt = node[i].opt, ty = node[i].ty ;
		if( opt == 1 ) {
			node[i].x = std::lower_bound( s + 1, s + 1 + sz, node[i].x ) - s ;
			int x = node[i].x, y = node[i].y ;
			if( ty == 0 )
				T[ty].Updata( x, y ) ;
			else {
				delta += y ;
				T[ty].Updata( x + 1, -y ) ;
			}
		}
		else {
			int x = node[ty].x, y = node[ty].y ;
			ty = node[ty].ty ;
			if( ty == 0 )
				T[ty].Updata( x, -y ) ;
			else {
				delta -= y ;
				T[ty].Updata( x + 1, y ) ;
			}
		}
		int sum = -delta, pos = 0 ;
		for( ri j = 20; j >= 0; --j ) {
			if( pos + ( 1 << j ) > sz )
				continue ;
			int tmp = sum + T[0].bit[pos + ( 1 << j )] - T[1].bit[pos + ( 1 << j )] ;
			if( tmp < 0 )
				sum = tmp, pos += 1 << j ;
		}
		int _pos = s[pos], ans = 2 * T[0].Query( pos ) ;
		if( pos < sz ) {
			int tmp = 2 * ( delta + T[1].Query( pos + 1 ) ) ;
			if( tmp >= ans ) {
				int tval = T[1].Query( pos + 1 ) ;
				sum = 0, pos = 0 ;
				for( ri j = 20; j >= 0; --j ) {
					if( pos + ( 1 << j ) > sz )
						continue ;
					int _tmp = sum + T[1].bit[pos + ( 1 << j )] ;
					if( _tmp >= tval )
						sum = _tmp, pos += 1 << j ;
				}
				_pos = s[pos], ans = tmp ;
			}
		}
		if( ans == 0 )
			puts( "Peace" ) ;
		else
			printf( "%d %d\n", _pos, ans ) ;
	}
	cerr << 1. * clock() / CLOCKS_PER_SEC << "\n" ;
	return 0;
}
```



---

## 作者：feecle6418 (赞：10)

分析比赛规则，不难得出，设 $f_i$ 为温度不高于 $i$ 的冰战士能力值和，$g_i$ 为温度不低于 $i$ 的火战士能力值和，要求 $2\max\{\min(f_i,g_i)\}$。

首先考虑 $O(n\log^2 n)$ 的暴力。二分答案，找出**最小的 $f_x\ge g_x$** 的温度 $x$。然后再倍增找出最大的 $g_x=g_y$ 的温度 $y$。则温度为 $y$ 时答案为 $(y,2g_y)$。然后找出**最大的 $f_x\le g_x$** 的温度 $x$，用 $(x,2f_x)$ 更新答案。这样可以得到 $60$ 分。

然后考虑优化。在树状数组上可不可以直接跳，代替二分？可以，但**只能解决“求最大的 $x$，使 $x$ 的前缀和满足 $P$”（$P$ 为一个条件）的问题。** 从大到小枚举 $i$，假设已经跳到的为 $w$，则 $\mathrm{lowbit}(w+2^i)=2^i$，因为 $i$ 是从大到小枚举的。那么树状数组内的 $c_{w+2^i}=s(w+1,w+2^i)$，恰好就是符合倍增的样子！代码如下：

```cpp
int now=0,s=0;
for(int j=20;j>=0;j--){
	int p=now+(1<<j);
	if(p<=W&&Judge(s+c[p]))now=p,s+=c[now];
}
```

这样，设 $w=2\times 10^6$，$h_i$ 为温度不高于 $i$ 的火战士能力值和，则最小的 $f_x\ge g_x$ 的温度 $x$ 就是最小的 $f_x\ge h_w-h_{x}+p_{x}$（$p_x$ 为温度等于 $i$ 的火战士能力值和）。也就是，最大的 $f_x< h_w-h_{x}+p_{x}$（$p_x$ 为温度等于 $i$ 的火战士能力值和）中的 $x+1$！这时已经符合树状数组上倍增的条件，可以倍增。代码：

```cpp
int now=0,sa=0,sb=0,rr,tmp;//先找到最小的s[0][1~x]>=s[1][x~W]
for(int j=20;j>=0;j--){
	int p=now+(1<<j);
	if(p<=W&&((sa+s[0][p])<(allb-sb-s[1][p]+b[p])))now=p,sa+=s[0][now],sb+=s[1][now];
}//now+1就是答案 
```

后面两次二分都可以直接被代替（因为满足树状数组二分的条件，即上面加粗句子），这里不再赘述。

注意本题对常数要求很高，离散化尽量不要用 `lower_bound` 而是直接双关键字排序。实现见代码。

总体代码如下（考场代码）：

```cpp
//Can I get a connection? Can I get, can I get a connection?
//You could see it in my, see it in my, reflection!
//Oh~
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<cstring>
#include<vector>
using namespace std;
int p1=1000000,p2=0;
char buf[1000005],wb[1000005];
int gc(){
	if(p1>=1000000)fread(buf,1,1000000,stdin),p1=0;
	return buf[p1++];
}
int rd(){
	int x=0;
	char ch=gc();
	while(ch<'0'||ch>'9')ch=gc();
	while(ch<='9'&&ch>='0')x=x*10+ch-'0',ch=gc();
	return x;
}
void pc(char x){
	if(p2>=1000000)fwrite(wb,1,1000000,stdout),p2=0;
	wb[p2++]=x;
}
void wrt(int x){
	int c[12]={0};
	if(!x)return pc('0'),void();
	while(x)c[++c[0]]=x%10,x/=10;
	while(c[0])pc(c[c[0]--]+'0');
}
int Qq,b[2000005],s[2][2000005],W=2000000,allb;
struct Que{
	int opt,t,x,y;
}t[2000005];
struct TTT{
	int x,id;
	bool operator <(const TTT yy) const {
		return x<yy.x;
	}
}a[2000005];
void A(int s[],int x,int k){
	while(x<=W)s[x]+=k,x+=x&-x;
}
int Q(int s[],int x){
	int r=0;
	while(x)r+=s[x],x-=x&-x;
	return r;
}
int Query(int s[],int l,int r){
	if(l>r)return 0;
	return Q(s,r)-Q(s,l-1);
}
int main(){
	//cout<<sizeof(t)/1024.0/1024.0;
	//freopen("icefire.in","r",stdin);
	//("icefire.out","w",stdout);
	Qq=rd();
	int S=0;
	for(int i=1,opt,k,x,y;i<=Qq;i++){
		opt=rd(),k=rd();
		if(opt==1){
			x=rd(),y=rd();
			t[i]=(Que){opt,k,x,y},a[++S]=(TTT){x,i};
		}
		else t[i]=(Que){opt,k,0,0};
	}
	sort(a+1,a+S+1);
	for(int i=1,now=1;i<=S;i++){
		if(a[i].x!=a[i-1].x)now=i;
		t[a[i].id].x=now;
	}
	for(int i=1,opt,k,x,y;i<=Qq;i++){
		opt=t[i].opt,k=t[i].t;
		if(opt==1){
			x=t[i].x,y=t[i].y,A(s[k],x,y);
			if(k==1)allb+=y,b[x]+=y;
		}
		else {
			A(s[t[k].t],t[k].x,-t[k].y);
			if(t[k].t==1)allb-=t[k].y,b[t[k].x]-=t[k].y;
		}
		int now=0,sa=0,sb=0,rr,tmp;//先找到最小的s[0][1~x]>=s[1][x~W]
		for(int j=20;j>=0;j--){
			int p=now+(1<<j);
			if(p<=W&&((sa+s[0][p])<(allb-sb-s[1][p]+b[p])))now=p,sa+=s[0][now],sb+=s[1][now];
		}//now+1就是答案 
		rr=(allb-sb)*2,sa=0;//现在要找最大的x，s[1][1~x-1]=s[1][1~now]=sb
		int gyh=0;
		for(int j=20;j>=0;j--){
			int p=gyh+(1<<j);
			if(p<=W&&((sa+s[1][p])<=sb))gyh=p,sa+=s[1][gyh];
		}//gyh+1=tmp
		tmp=gyh+1;//现在要找最大的x，s[0][1~x]<=s[1][x~W]
		now=0,sa=0,sb=0;
		for(int j=20;j>=0;j--){
			int p=now+(1<<j);
			if(p<=W&&((sa+s[0][p])<=(allb-sb-s[1][p]+b[p])))now=p,sa+=s[0][now],sb+=s[1][now];
		}//now就是答案
		int trr=sa*2;
		if(trr>rr||(trr==rr&&now>tmp))rr=trr,tmp=now;
		if(!rr)pc('P'),pc('e'),pc('a'),pc('c'),pc('e'),pc('\n');
		else wrt(a[tmp].x),pc(' '),wrt(rr),pc('\n');
	}
	fwrite(wb,1,p2,stdout);
	return 0;
}
```

---

## 作者：绝顶我为峰 (赞：9)

~~90% 的数据是来搞笑吗，真的有人会正解还不会离散化吗。~~

感觉是非常好的一题，以前树状数组只是背板子，做完这一题后算是真正理解了树状数组。

显然冰系出战的范围是一个前缀，火系出战的是一个后缀，这两个函数一个单调不增，一个单调不降，答案就是两个函数的 $\min$ 在整点处取到的最大值的两倍。

答案只有可能在两个函数交点的前后取到，一个自然的想法是直接二分出这个极值，配合线段树或树状数组容易做到 $O(Q\log^2Q)$，可以得到 $60$ 分的好成绩。

考虑怎样砍掉一只 $\log$。不难想到，线段树+二分=线段树二分，而这样就少了一个 $\log$。进行两次线段树二分，第一次二分出两函数相交前的最后一个位置，然后下一个位置就是两函数相交后的第一个位置，这样一次二分+两次线段树区间查询得到了两边的最小值的最大值。比较一下，如果是相交前的值更大，就直接输出，否则可能会出现相交后连续一段答案全部相同的情况，而题目要求出温度最大值，于是再进行一次线段树二分二分出来这一段的右端点就是答案。这样时间复杂度降为 $O(Q\log Q)$，可以通过此题……吗？

很不幸，线段树二分常数太大了，还是过不去。

这样一来我们不能使用线段树，那么只能使用树状数组了，查询很好解决，冰系直接查前缀，火系总和减去前缀即可。然后是一个**重要的 trick**，我们可以在树状数组上用倍增的方式来实现二分的操作。因为树状数组上编号为 $i$ 的节点保存的是 $(i-lowbit(i),i]$ 的信息，这样我们从高位向低位枚举，类似求 LCA 的方法，如果满足要求就跳，这样就实现了和二分一样的效果。

但是……每次倍增跳到一个新的节点不是需要查询吗？这样还是 $O(Q\log^2 Q)$ 的？

于是考虑怎样在倍增的时候 $O(1)$ 在树状数组上查询前缀和。朴素的查询是单次 $O(\log Q)$ 的且无法优化，这启示我们必须利用前面倍增得到的信息。还是回到节点 $i$ 保存的信息的范围是 $(i-lowbit(i),i]$ 上面，我们发现由于每次增加的一定都是当前数位最低的一个 $1$，换句话说，如果当前跳到的节点是 $p$，上一个节点是 $pos$，那么一定有 $p=pos+lowbit(p)$，前面 $[1,pos]$ 的前缀和已经求出了，后面 $(pos,p]$ 的信息怎么求？对前面的式子移项，得到 $pos=p-lowbit(p)$ 所以这个区间就是 $(p-lowbit(p),p]$，也就是树状数组上编号为 $p$ 的节点的值。这样我们就实现了倍增的时候 $O(1)$ 查询前缀和。

于是树状数组上倍增模拟线段树二分的全部问题都已经解决，直接和线段树二分时进行两次意义完全相同的倍增即可。

时间复杂度依然是 $O(Q\log Q)$，但树状数组常数就小得多了，可以通过。

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
int n,ans[2000001][2],node[2000001],cnt,sum;
struct element
{
    int opt,t,x,y;
}a[2000001];
inline int read()
{
    int x=0;
    char c=getchar();
    while(c<'0'||c>'9')
        c=getchar();
    while(c>='0'&&c<='9')
    {
        x=(x<<1)+(x<<3)+(c^48);
        c=getchar();
    }
    return x;
}
void print(int x)
{
    if(x>=10)
        print(x/10);
    putchar(x%10+'0');
}
inline int lowbit(int x)
{
    return x&-x;
}
inline void update(int x,int val,int tag)
{
    for(;x<=cnt;x+=lowbit(x))
        ans[x][tag]+=val;
}
inline int query(int x,int tag)
{
    int res=0;
    for(;x;x-=lowbit(x))
        res+=ans[x][tag];
    return res;
}
int main()
{
    n=read();
    for(register int i=1;i<=n;++i)
    {
        a[i].opt=read(),a[i].t=read();
        if(a[i].opt==1)
        {
            a[i].x=read(),a[i].y=read();
            node[++cnt]=a[i].x;
        }
    }
    sort(node+1,node+cnt+1);
    cnt=unique(node+1,node+cnt+1)-node-1;
    for(register int i=1;i<=n;++i)
    {
        if(a[i].opt==1)
        {
            a[i].x=lower_bound(node+1,node+cnt+1,a[i].x)-node;
            if(!a[i].t)
                update(a[i].x,a[i].y,0);
            else
            {
                sum+=a[i].y;
                update(a[i].x+1,a[i].y,1);
            }
        }
        else
            if(!a[a[i].t].t)
                update(a[a[i].t].x,-a[a[i].t].y,0);
            else
            {
                sum-=a[a[i].t].y;
                update(a[a[i].t].x+1,-a[a[i].t].y,1);
            }
        int pos=0,ans1=0,ans2=0,tmp1=0,tmp2=sum;
        for(register int j=20;~j;--j)
        {
            if((pos|(1<<j))>cnt)
                continue;
            int p=pos|(1<<j);
            tmp1+=ans[p][0];
            tmp2-=ans[p][1];
            if(tmp1>=tmp2)
            {
                tmp1-=ans[p][0];
                tmp2+=ans[p][1];
                continue;
            }
            ans1=tmp1;
            pos=p;
        }
        if(ans1&&pos==cnt)
        {
            print(node[pos]);
            putchar(' ');
            print(ans1<<1);
            putchar('\n');
            continue;
        }
        ans2=sum-query(pos+1,1);
        if((!ans1&&!ans2)||query(pos+1,0)<ans2)
        {
            puts("Peace");
            continue;
        }
        if(ans1>ans2)
        {
            print(node[pos]);
            putchar(' ');
            print(ans1<<1);
            putchar('\n');
            continue;
        }
        tmp1=0,tmp2=sum,pos=0;
        for(register int j=20;~j;--j)
        {
            if((pos|(1<<j))>cnt)
                continue;
            int p=pos|(1<<j);
            tmp1+=ans[p][0];
            tmp2-=ans[p][1];
            if(tmp1<tmp2||tmp2==ans2)
            {
                pos=p;
                continue;
            }
            tmp1-=ans[p][0];
            tmp2+=ans[p][1];
        }
        print(node[pos]);
        putchar(' ');
        print(ans2<<1);
        putchar('\n');
    }
    return 0;
}
```

---

## 作者：周子衡 (赞：9)

**算法一**

首先认真分析一下题目里那段~~又臭又长的~~比赛规则，你发现它十分鸡肋，显然当温度一定的时候，答案一定是**双方能量值的较小值的两倍。**

更简单地，假设温度为 $T$，此时冰方能参赛的战士能量值和为 $I(T)$，火方和为 $F(T)$，显然答案即为 $2\times \min \{I(T),F(T)\}$。

另一个显而易见的事实是：最优解一定在某个战士的温度值取到。所以先直接离散化一遍。暴力枚举温度和更新的话时间复杂度 $O(Q^2)$，期望得分 $20$ 分。

**算法二**

显然 $I(T)$ 是个增函数，$F(T)$ 是个减函数，所以 $\min \{I(T),F(T)\}$ 是个凸函数。可以用三分求极值。

发现我们需要动态维护 $I,F$，而这两个函数一个是前缀和一个是后缀和，直接上树状数组维护即可。

时间复杂度 $O(Q\log ^2Q)$，期望得分 $60$ 分。由于要求最大的取到极值的点，细节可能有点复杂。

**算法三**

令 $X(T)=F(T)-I(T)$，显然 $X(T)$ 是个不增函数。如果我们能二分出 $X$ 的零点，就能优化到一个 log。

考虑在线段树上维护，每个节点维护一个 $V$ 的最大值（也就是这段区间左端点的 $V$ 值）。然后能尽量往右走就往右走。

我们还要找到最大的下标。分类讨论即可。时间复杂度 $O(Q\log Q)$。

鉴于毒瘤的出题人和毒瘤的 $2\times 10^6$ 的数据范围，**注意常数，注意常数，注意常数。**

代码：

```cpp
#include<cstdio>
#include<map>
#include<algorithm>

using namespace std;

struct in
{
	int op,t,x,y,k;
}q[2100000];

int ori[2100000],ori_cnt=0;//map<int,int> mp;

struct SegmentTree
{
	struct nd
	{
		int l,r;int maxn,add,fire,add_fire;
	}t[8100000];
	void build(int l,int r,int k=1)
	{
		t[k].l=l,t[k].r=r,t[k].maxn=t[k].add=0;if(l==r)return;
		int mid=(l+r)>>1;build(l,mid,k<<1),build(mid+1,r,k<<1|1);
	}
	void spread(int k)
	{
		if(t[k].add)
		{
			t[k<<1].maxn+=t[k].add,t[k<<1|1].maxn+=t[k].add,
			t[k<<1].add+=t[k].add,t[k<<1|1].add+=t[k].add;t[k].add=0;
		}
		if(t[k].add_fire)
		{
			t[k<<1].fire+=t[k].add_fire,t[k<<1|1].fire+=t[k].add_fire,
			t[k<<1].add_fire+=t[k].add_fire,t[k<<1|1].add_fire+=t[k].add_fire;t[k].add_fire=0;
		}
	}
	void add(int l,int r,int v,int k=1)
	{
		if(l>t[k].r||r<t[k].l)return;
		if(l<=t[k].l&&t[k].r<=r){t[k].maxn+=v,t[k].add+=v;return;}
		spread(k);add(l,r,v,k<<1),add(l,r,v,k<<1|1);
		t[k].maxn=t[k<<1].maxn;
	}
	void add_fire(int l,int r,int v,int k=1)
	{
		if(l>t[k].r||r<t[k].l)return;
		if(l<=t[k].l&&t[k].r<=r){t[k].fire+=v,t[k].add_fire+=v;return;}
		spread(k);add_fire(l,r,v,k<<1),add_fire(l,r,v,k<<1|1);
		t[k].fire=t[k<<1].fire;
	}
	int find_pos(int v,int k=1)
	{
		if(t[k].maxn<v)return 0;
		if(t[k].l==t[k].r)return t[k].l;spread(k);
		if(t[k<<1|1].maxn>=v)return find_pos(v,k<<1|1);
		return find_pos(v,k<<1);
	}
	int find_fire(int v,int k=1)
	{
		if(t[k].fire<v)return 0;
		if(t[k].l==t[k].r)return t[k].l;spread(k);
		if(t[k<<1|1].fire>=v)return find_fire(v,k<<1|1);
		return find_fire(v,k<<1);
	}
	int query(int pos,int k=1)
	{
		if(t[k].l==t[k].r)return t[k].maxn;
		spread(k);int mid=(t[k].l+t[k].r)>>1;return pos<=mid?query(pos,k<<1):query(pos,k<<1|1);
	}
}T;

struct BIT
{
	int n,c[2100000];
	int lowbit(int x){return x&-x;}
	void add(int x,int v){while(x<=n){c[x]+=v;x+=lowbit(x);}}
	int pre(int x){int ans=0;while(x){ans+=c[x];x-=lowbit(x);}return ans;}
	int suf(int x){return pre(n)-pre(x-1);}
	void init(int nn){n=nn;}
}ICE,FIRE;

int fast_read()
{
	int x=0;char c=0;
	while(!(c>='0'&&c<='9'))c=getchar();
	while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}
	return x;
}

void output(int p,int x){if(x==0){puts("Peace");return;}printf("%d %lld\n",ori[p],(long long)x*2);}

int main()
{
	freopen("icefire.in","r",stdin);
	freopen("icefire.out","w",stdout);
	
	int Q=0;Q=fast_read();
	for(int i=1;i<=Q;i++)
	{
		q[i].op=fast_read();
		if(q[i].op==1){q[i].t=fast_read(),q[i].x=fast_read(),q[i].y=fast_read();ori[++ori_cnt]=q[i].x;}
		else{scanf("%d",&q[i].k);}
	}
	
	sort(ori+1,ori+ori_cnt+1);ori_cnt=unique(ori+1,ori+ori_cnt+1)-ori-1;
	for(int i=1;i<=Q;i++)if(q[i].op==1)q[i].x=lower_bound(ori+1,ori+ori_cnt+1,q[i].x)-ori;
	ICE.init(ori_cnt),FIRE.init(ori_cnt),T.build(1,ori_cnt);
	int cnt0=0,cnt1=0;
	for(int i=1;i<=Q;i++)
	{
		if(q[i].op==1)
		{
			if(q[i].t==0){ICE.add(q[i].x,q[i].y);T.add(q[i].x,ori_cnt,-q[i].y);cnt0++;}
			else
			{
				FIRE.add(q[i].x,q[i].y);T.add(1,q[i].x,q[i].y);cnt1++;
				T.add_fire(1,q[i].x,q[i].y);
			}
		}
		else
		{
			int k=q[i].k;
			if(q[k].t==0){ICE.add(q[k].x,-q[k].y);T.add(q[k].x,ori_cnt,+q[k].y);cnt0--;}
			else{FIRE.add(q[k].x,-q[k].y);T.add(1,q[k].x,-q[k].y);cnt1--;T.add_fire(1,q[k].x,-q[k].y);}
		}
		if(!cnt0||!cnt1){puts("Peace");continue;}
		int p=T.find_pos(0);
		if(p==ori_cnt){output(p,ICE.pre(ori_cnt));continue;}
		if(p==0){output(T.find_fire(FIRE.suf(1)),FIRE.suf(1));continue;}
		int val=FIRE.suf(p+1);int p2=T.find_fire(val);
		int ans1=min(ICE.pre(p),FIRE.suf(p)),ans2=min(ICE.pre(p2),FIRE.suf(p2));
		if(ans1>ans2)output(p,ans1);else output(p2,ans2);
	}
	return 0;
}
```

---

## 作者：ZBHRuaRua (赞：8)

**几个月前就已经退役的老年人看了看省选的题，发现对我来说也就只有这道弱智题比较好做QwQ**

首先数据范围 $2e6$ 十分可疑，让人感觉有线性算法，然而并没有^ ^

于是考虑 $O(nlogn)$，设 $F_i$ 为冰的能量值，$G_i$ 为火的能量值，读完题你就知道要求的是某个最大温度值，使得 $min(F_i,G_i)$ 最大，此时的能量就是 $2*min(F_i,G_i)$

容易发现，$F_i$ 单调递增，$G_i$ 单调递减，画出图像，发现我们要求的最大能量貌似就是 $F_i$ 和 $G_i$ 的交点。

作为暴力选手的我就直接上线段树了呗，显然可以发现，如果我们能够先求出最优的能量值，就可以再用一次线段树求出最大的温度值。


于是很容易想到要线段树二分了。

以温度为下标建线段树，我们在每一个节点时，可以 $O(1)$ 比较一下左子树最右的节点和右子树最左的节点的 $F_i$ 和 $G_i$，然后分类讨论一下，就能很傻瓜地求出最优能量值了。

然后将其带回线段树再求一下最大温度值就解决了。

代码：
```
#include<cstdio>
#include<iostream>
#include<iomanip>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<cstdlib>
#include<queue>
using namespace std;
inline int read()
{
	int x=0,f=1;char c=getchar();
	while(c<'0'||c>'9')
	{
		if(c=='-') f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9')
	{
		x=x*10+(c-'0');
		c=getchar();
	}
	return x*f;
}
char wr[105];
inline void write(int x)
{
	if(x==0)
	{
		putchar('0');
		return;
	}
	int tmp=x;
	if(x<0) tmp=-x;
	if(x<0) putchar('-');
	int cnt=0;
	while(tmp)
	{
		wr[++cnt]=tmp%10+'0';
		tmp/=10;
	}
	while(cnt) putchar(wr[cnt--]);
}
struct node{
	int l,r,prei,pref;
}t[8000050];
struct node2{
	int typ,pro,wd,nl;
}qry[2000050];
struct tup{
	int x,y;
};
int Q;
int a[2000050];
int b[2000050];
int cnt;
int e[2][2000050];
int noww;
inline void build(int p,int l,int r)
{
	t[p].l=l;t[p].r=r;
	if(l==r) return;
	int mid=(l+r)/2;
	build(p*2,l,mid);
	build(p*2+1,mid+1,r);
}
inline void change(int p,int pro,int tar,int v)
{
	if(t[p].l==t[p].r)
	{
		if(pro==0)
		{
			t[p].prei+=v;
		}
		else
		{
			t[p].pref+=v;
		}
		return;
	}
	int mid=(t[p].l+t[p].r)/2;
	if(tar<=mid) change(p*2,pro,tar,v);
	else change(p*2+1,pro,tar,v);
	t[p].pref=(t[p*2].pref+t[p*2+1].pref);
	t[p].prei=(t[p*2].prei+t[p*2+1].prei);
}
inline int ask(int p,int v1,int v2)
{
	if(t[p].l==t[p].r) 
	{
		noww=t[p].l;
		return min(v1+e[0][t[p].l],v2+e[1][t[p].l]);
	}
	int c1=t[p*2].r,c2=t[p*2+1].l;
	int tmp1=t[p*2].prei,tmp2=t[p*2+1].pref;
	tup ans1=(tup){tmp1+v1,e[1][c1]+tmp2+v2};tup ans2=(tup){tmp1+e[0][c2]+v1,tmp2+v2};
	int sam1=min(ans1.x,ans1.y),sam2=min(ans2.x,ans2.y);
	int hen1=min(ans1.x,ans2.x),hen2=min(ans1.y,ans2.y);
	if(sam1<sam2)
	{
		return ask(p*2+1,v1+tmp1,v2);
	}
	else if(sam1>sam2)
	{
		return ask(p*2,v1,v2+tmp2);
	}
	else
	{
		if((ans1.x>ans1.y&&ans2.x<ans2.y)||(ans1.x<ans1.y&&ans2.x>ans2.y))
		{
			if(ans1.x>ans1.y) return ask(p*2,v1,v2+tmp2);
			else return ask(p*2+1,v1+tmp1,v2);
		}
		else if(ans1.x==ans2.x&&ans1.y==ans2.y)
		{
			if(ans1.x>ans1.y) return ask(p*2,v1,v2+tmp2);
			else return ask(p*2+1,v1+tmp1,v2);
		}
		else if(ans1.x==ans2.x||ans1.y==ans2.y)
		{
			if(ans1.x==ans2.x)
			{
				return ask(p*2+1,v1+tmp1,v2); 
			}
			else
			{
				return ask(p*2,v1,v2+tmp2);
			}
		}
	}
}
inline int askmx(int p,int mxnl,int now,int v1,int v2)
{
	if(t[p].l==t[p].r) return t[p].l;
	int c1=t[p*2].r,c2=t[p*2+1].l;
	int tmp1=t[p*2].prei,tmp2=t[p*2+1].pref;
	tup ans1=(tup){tmp1+v1,e[1][c1]+tmp2+v2};tup ans2=(tup){tmp1+e[0][c2]+v1,tmp2+v2};
	int sam2=min(ans2.x,ans2.y);
	if(now>=c2) return askmx(p*2+1,mxnl,now,v1+tmp1,v2);
	else if(sam2==mxnl) return askmx(p*2+1,mxnl,now,v1+tmp1,v2);
	else return askmx(p*2,mxnl,now,v1,v2+tmp2);
}
int main()
{
	Q=read();
	for(int i=1;i<=Q;i++)
	{
		int tmp=read();
		if(tmp==1)
		{
			int p,x,y;
			p=read();x=read();y=read();
			qry[i]=(node2){1,p,x,y};
			a[++cnt]=x;
		}
		else
		{
			int k=read();
			qry[i]=(node2){2,qry[k].pro,qry[k].wd,qry[k].nl};
		}
	}
	sort(a+1,a+cnt+1);
	int num=unique(a+1,a+cnt+1)-a-1;
	build(1,1,num);
	for(int i=1;i<=Q;i++)
	{
		int l=1,r=num,M;
		while(l<=r)
		{
			int mid=(l+r)/2;
			if(a[mid]<qry[i].wd)
			{
				l=mid+1;
				M=mid;
			}
			else if(a[mid]>qry[i].wd)
			{
				r=mid-1;
				M=mid;
			}
			else
			{
				M=mid;
				break;
			}
		}
		qry[i].wd=M;
		if(qry[i].typ==1)
		{
			e[qry[i].pro][qry[i].wd]+=qry[i].nl;
			change(1,qry[i].pro,qry[i].wd,qry[i].nl);
		}
		else
		{
			e[qry[i].pro][qry[i].wd]-=qry[i].nl;
			change(1,qry[i].pro,qry[i].wd,-qry[i].nl);
		}
		int ans=ask(1,0,0);
		int answd=askmx(1,ans,noww,0,0);
		if(ans!=0)
		{
			write(a[answd]);printf(" ");write(ans*2);printf("\n");
		}
		else printf("Peace\n");
	}
	return 0;
}
```


---

## 作者：syksykCCC (赞：6)

首先，可以才想答案温度一定是某个战士的温度，而且我们只用用到温度的相对大小关系，所以可以把把温度离散化。

用 $fv_i$ 表示自身温度为 $i$ 的所有火系战士的能量和，$iv_i$ 表示自身温度为 $i$ 的所有冰系战士的能量和。

同时定义 $F(i)$ 和 $I(i)$ 表示上面两个数组的前缀和，那么，对于场温 t，上场的冰系战士的能量和就是 $I(t)$，火系战士就是 $\left(\sum fv\right) - F(t-1)$。答案显然是这两者中较小值的两倍。

再发现 $I(t)$ 是单调不降的，$\left(\sum fv\right) - F(t-1)$ 是单调不升的，那么对于两者较小值的这个函数，一定是在上面两者的交点处取到。

单峰函数怎么办？三分？

不行，因为这个函数有很多相等段，会导致三分出错。（不过据说可以给答案加一个小数点？反正我不会 /kk）

那么把两者作差，用 $I(t)$ 减去 $\left(\sum fv\right) - F(t-1)$，这个函数一定是单调不降的，而最后一个 $\le 0$ 和第一个 $>0$ 的位置之间就是交点所在。

所以，我们只用二分出最后一个使得 $I(t)- \left(\sum fv\right) + F(t-1) \le 0$ 的位置 $t$，答案能量必然在 $t$ 或者 $t+1$ 取到。

关于答案温度，如果 $t$ 的答案大于 $t+1$ 的话，那么显然就是 $t$ 对应的温度，否则，就再二分出最后一个 $F(t') \le F(t)$ 的，将 $t'$ 对应的温度作为答案就好了（也就是求出不改变答案的最大温度）。

于是可以用二分套树状数组解决，时间复杂度是 $\mathcal O(n \log^2 n)$ 的。

但这个复杂度显然是不行的，考虑进一步优化，直接在树状数组上二分。

现在改写上面两个二分的式子。

发现，第一次是二分出最大的满足 $I(t)- \left(\sum fv\right) + F(t-1) \le 0$ 的位置，把 F(t-1) 改写一下，就是 $I(t)- \left(\sum fv\right) + (F(t)-fv_t) \le 0$，也就是 $\left(\sum fv\right) - I(t) - F(t) + fv_t \ge 0$，下标只含 $t$，且有单调性，这个就可以直接在 BIT 上二分了。

第二个同理，而且方法很多，可以自行尝试。

那么时间复杂度就是 $\mathcal O(n \log n)$ 了。注意卡常，建议评测开启 O2。

```cpp
#include <cstdio>
#include <algorithm>
#define rg register
#define il inline
using namespace std;
const int N = 2e6 + 5;
inline int read()
{
	int val = 0; char c = getchar();
	while(c < '0' || c > '9') c = getchar();
	while(c >= '0' && c <= '9') { val = val * 10 + (c ^ 48); c = getchar(); }
	return val;
}
int tot, type[N], k[N], x[N], x_[N], y[N], fv[N], sum_fire;
struct binaty_indexed_tree
{
	int o[N];
	il void Modify(int p, int v)
	{
		for(; p <= tot; p += p & -p)
			o[p] += v;
	}
	il int Query(int p)
	{
		int res = 0;
		for(; p; p -= p & -p)
			res += o[p];
		return res;
	}
} ice_tr, fire_tr;
il int Value(int t)
{
	if(t < 1 || t > tot) return -1;
	return min(ice_tr.Query(t), sum_fire - fire_tr.Query(t - 1));
}
int main()
{
	rg int Q = read();
	for(rg int i = 1; i <= Q; i++)
	{
		type[i] = read();
		k[i] = read();
		if(type[i] == 1) { x_[++x_[0]] = x[i] = read(); y[i] = read(); }
	}
	sort(x_ + 1, x_ + x_[0] + 1);
	tot = unique(x_ + 1, x_ + x_[0] + 1) - x_ - 1;
	for(rg int i = 1; i <= Q; i++)
		if(type[i] == 1) x[i] = lower_bound(x_ + 1, x_ + tot + 1, x[i]) - x_;
	rg int cnt_ice = 0, cnt_fire = 0;
	for(rg int i = 1; i <= Q; i++)
	{
		if(type[i] == 1)
		{
			if(k[i] == 0) { ice_tr.Modify(x[i], y[i]); cnt_ice++; }
			else { fire_tr.Modify(x[i], y[i]); cnt_fire++; sum_fire += y[i]; fv[x[i]] += y[i]; }
		}
		else
		{
			if(k[k[i]] == 0) { ice_tr.Modify(x[k[i]], -y[k[i]]); cnt_ice--; }
			else { fire_tr.Modify(x[k[i]], -y[k[i]]); cnt_fire--; sum_fire -= y[k[i]]; fv[x[k[i]]] -= y[k[i]]; }
		}
		if(cnt_ice == 0 || cnt_fire == 0) { puts("Peace"); continue; }
		rg int pos = 0, sum = 0;
		for(rg int s = 20; ~s; s--)
		{
			int nxt = pos | (1 << s);
			if(nxt <= tot && sum + ice_tr.o[nxt] + fire_tr.o[nxt] - fv[nxt] <= sum_fire)
			{
				sum += ice_tr.o[nxt] + fire_tr.o[nxt];
				pos |= 1 << s;
			}
		}
		int ansL = Value(pos), ansR = Value(pos + 1);
		if(max(ansL, ansR) <= 0) { puts("Peace"); continue; }
		if(ansL > ansR)
		{
			printf("%d %d\n", x_[pos], ansL << 1);
			continue;
		}
		pos = 0; sum = 0;
		for(rg int s = 20; ~s; s--)
		{
			int nxt = pos | (1 << s);
			if(nxt <= tot && sum + fire_tr.o[nxt] - fv[nxt] <= sum_fire - ansR)
			{
				sum += fire_tr.o[nxt];
				pos |= 1 << s;
			}
		}
		printf("%d %d\n", x_[pos], ansR << 1);
	}
	return 0;
}
```

---

## 作者：BelowHorizon (赞：3)

考虑不修改。

答案就是求两者满足条件的和的偏小值的两倍。而又因为要求 $\max$ ，所以要使得最小值大。设两个序列为 $a,b$ 。即找到一个温度使得 $a$ 刚好小于等于 $b$ ，一个温度使得 $b$ 刚好小于等于 $a$ 。取这两个温度的较大值，就是答案。可以用二分简单的得到。

考虑修改。

需要离线将所有温度存下来，然后离散化。建出两棵线段树一棵是 $a$ 的，一棵是 $b$ 的。每次增添操作，就在对应节点上加，删除操作就在对应节点上减。然后每次线段树二分，找到不修改的那两种情况即可。时间复杂度 $O(q\log q)$

---

## 作者：tommymio (赞：2)

一个先递增再递减的函数图像最值？三分 $+$ 线段树？

这可能是我们看到这题的第一想法，但仔细观察你就会发现，函数图像在一段 $t$ 上的取值可能是相等的。裸的三分并不能直接处理这种函数图像，考虑换一种做法。

接下来我们对这题进行更具体的描述，我们有两个函数 $f_{ice}(t),f_{fire}(t)$，其中 $f_{ice}$ 是单调不降的，而 $f_{fire}$ 是单调不减的。令 $\min \{f_{ice}(t),f_{fire}(t)\}$ 最大，并给出达到这个值的最大的 $t$。

![](https://cdn.luogu.com.cn/upload/image_hosting/p9hx3qjh.png)

下图中绿色的曲线就是 $\min(f_{ice}(t),f_{fire}(t))$ 的变化趋势（因为事实上它的图象是一些离散的点），我们要求它的最大值。那它的最大值自然在绿色曲线的最高处取到（但是由于是一些离散的点，这个值未必能够取到），所以我们改而求满足 $f_{fire}(t)-f_{ice}(t)\geq0$ 最大的 $t$，和满足 $f_{fire}(t)-f_{ice}(t)$ 取到最大负整数的最大的 $t$，答案就在这两者中产生。

每加入一个点，区间增量维护 $f_{fire}(t),f_{ice}(t),f_{ice}(t)-f_{fire}(t)$，询问时直接在线段树上二分即可。当然还有其他更优秀的做法，但上文提到的这种做法很好想到。时间复杂度为 $O(n \log n)$，由于线段树常数大，需要吸氧。把线段树换成 $\texttt{BIT}$ 即可不吸氧 $\text{AC}$。

```cpp
#include<cstdio>
#include<cassert>
#include<algorithm>
#define ls p<<1
#define rs p<<1|1 
struct node {
	int t,x,y;
}opt[2000005];
int aim_val,tmp_val;
int c[2000005];
int add[8000005][2],sum[8000005][2],mx[8000005],mn[8000005];
inline int read() {
	register int x=0,f=1;register char s=getchar();
	while(s>'9'||s<'0') {if(s=='-') f=-1;s=getchar();}
	while(s>='0'&&s<='9') {x=x*10+s-'0';s=getchar();}
	return x*f;
}
inline int max(const int &x,const int &y) {return x>y? x:y;}
inline int min(const int &x,const int &y) {return x<y? x:y;}
inline void spread(int p,int l,int r) {
	int mid=l+r>>1;
	if(add[p][0]) {
		sum[ls][0]+=add[p][0]; sum[rs][0]+=add[p][0];
		add[ls][0]+=add[p][0]; add[rs][0]+=add[p][0];
		mx[ls]+=add[p][0]; mx[rs]+=add[p][0];
		mn[ls]+=add[p][0]; mn[rs]+=add[p][0];
		add[p][0]=0;
	}
	if(add[p][1]) {
		sum[ls][1]+=add[p][1]; sum[rs][1]+=add[p][1];
		add[ls][1]+=add[p][1]; add[rs][1]+=add[p][1];
		mx[ls]-=add[p][1]; mx[rs]-=add[p][1];
		mn[ls]-=add[p][1]; mn[rs]-=add[p][1];
		add[p][1]=0;
	}
}
inline void modify_add(int p,int l,int r,int L,int R,int val,int id) {
	if(L<=l&&r<=R) {
		mx[p]+=val; mn[p]+=val; 
		if(id==0) {//id==0&&val<0
			add[p][0]+=val;
			sum[p][0]+=val;
		}
		else {
			add[p][1]-=val;
			sum[p][1]-=val;
		}
		return;
	}
	int mid=l+r>>1; spread(p,l,r);
	if(L<=mid) modify_add(ls,l,mid,L,R,val,id);
	if(R>mid) modify_add(rs,mid+1,r,L,R,val,id);
	mx[p]=max(mx[ls],mx[rs]); mn[p]=min(mn[ls],mn[rs]);
	sum[p][1]=max(sum[ls][1],sum[rs][1]);
} 
inline int find_max_break(int p,int l,int r) {
	if(mn[p]>0) return -1;
	if(l==r) return l;
	int mid=l+r>>1; spread(p,l,r);
	if(mn[rs]<=0) return find_max_break(rs,mid+1,r);
	else return find_max_break(ls,l,mid);
}
inline int find_min_break(int p,int l,int r) {
	if(mx[p]<0) return -1;
	if(l==r) return l;
	int mid=l+r>>1; spread(p,l,r);
	if(mx[ls]>=0) return find_min_break(ls,l,mid);
	else return find_min_break(rs,mid+1,r); 
}
inline int find_max_aim(int p,int l,int r,int val) {
	if(l==r) return l;
	int mid=l+r>>1; spread(p,l,r);
	if(sum[rs][1]>=val) return find_max_aim(rs,mid+1,r,val);
	else return find_max_aim(ls,l,mid,val);//sum[rs][1]<val
}
inline int getVal(int p,int l,int r,int x) {
	if(l==r) {aim_val=sum[p][1]; return 2*min(sum[p][0],sum[p][1]);}
	int mid=l+r>>1; spread(p,l,r);
	if(x<=mid) return getVal(ls,l,mid,x);
	else return getVal(rs,mid+1,r,x);
}
int main() {
	freopen("icefire3.in","r",stdin);
	freopen("icefire.out","w",stdout);
	int Q=read(),num=0;
	for(register int i=1;i<=Q;++i) {
		int op=read();
		if(op==1) {
			opt[i].t=read(); opt[i].x=read(); opt[i].y=read();
			c[++num]=opt[i].x;
		}
		else {
			opt[i].t=2; opt[i].x=read();
		}
	} 
	std::sort(c+1,c+1+num); num=std::unique(c+1,c+1+num)-c-1; 
	for(register int i=1;i<=Q;++i) {
		if(opt[i].t<=1) {
			opt[i].x=std::lower_bound(c+1,c+1+num,opt[i].x)-c;
			if(opt[i].t==0) modify_add(1,1,num,opt[i].x,num,opt[i].y,0);
			else modify_add(1,1,num,1,opt[i].x,-opt[i].y,1);
		}
		else {
			int x=opt[i].x;
			if(opt[x].t==0) modify_add(1,1,num,opt[x].x,num,-opt[x].y,0);
			else modify_add(1,1,num,1,opt[x].x,opt[x].y,1);
		}
		aim_val=-1;
		int L=find_max_break(1,1,num),R=find_min_break(1,1,num);
		if(L==-1&&R==-1) printf("Peace\n");
		else {
			int res=0,tmax=0,tmp1=-1,tmp2=-1;
			if(L!=-1) res=max(res,tmp1=getVal(1,1,num,L));
			if(R!=-1) res=max(res,tmp2=getVal(1,1,num,R));
			if(res==tmp1) tmax=c[L];
			if(res==tmp2) tmax=c[R=find_max_aim(1,1,num,aim_val)];
			if(res==0) printf("Peace\n");
			else printf("%d %d\n",tmax,res);
		}
	}
	return 0;
} 
```

---

## 作者：TEoS (赞：2)

本文同步发表在[我的blog](https://www.cnblogs.com/TEoS/p/13324650.html)


------------
**题意分析**

对于每次修改后的情况，求一个最大的 $k$ ，使得温度不大于 $k$ 的冰系战士的能量和与温度不小于 $k$ 的火系战士的能量和的最小值最大。

**思路分析**

显然所求的  $k$ 一定是某战士的温度，因此先将数据进行升序排序离散化处理。此时问题就转变为，设冰系与火系战士组成的序列分别为 $a,b$ ，则求一个最大的 $x$ ，使得在 $x$ 位置 $a$ 的前缀和与 $b$ 的后缀和的最小值最大。

###### 60pts

可以发现答案具有单调性，想到二分答案。 $check$ 函数很容易想到暴力地每次查询前后缀和判断，用树状数组或线段树维护前后缀和，时间复杂度 $O(nlog^2n)$ ，可以拿到 $60$ 分。维护 $b$ 序列时，可以用倒着维护后缀和的方式维护前缀和。

注意，由于题目要求的是最大的 $x$，在 $a$ 序列的前缀和大于 $b$ 序列的后缀和的情况为答案时，此时二分到的 $x$ 应该最大的使 $a$ 的前缀和不大于 $b$ 的后缀和的 $x$ ，因此需要额外进行一次处理，找到该情况下最大的 $x$ 。

```c++
...
bool check(int x)
{
	int lsum=askl(x),rsum=askr(cnt-x+1);//分别查询 a,b 的前缀和，这里用倒着维护后缀和的方式维护前缀和
	now=min(lsum,rsum);
	return lsum<=rsum;
}//二分判断
void get()
{
	int l=1,r=cnt,mid=(l+r)>>1;
	while(l<=r)
	{
		if(askr(cnt-mid+1)<now)
			r=mid-1;
		else
			l=mid+1;
		mid=(l+r)>>1;
	}
	ans=mid;
}//额外处理
void query()
{
	int l=1,r=cnt,mid=(l+r)>>1,lsum,rsum,val;
	while(l<=r)
	{
		if(check(mid))
			l=mid+1;
		else
			r=mid-1;
		mid=(l+r)>>1;
	}
	lsum=askl(mid),rsum=askr(cnt-mid+1),val=min(lsum,rsum);
	lsum=askl(mid+1),rsum=askr(cnt-mid),now=min(lsum,rsum);
	if(now>=val)
		get();
	else
		now=val,ans=mid;
}
int main()
{
    ...
    for(int i=1;i<=Q;i++)
		if(p(i)==1)
		{
			int x=lower_bound(b+1,b+cnt+1,x(i))-b;
			if(!t(i))
				changel(x,y(i));
			else
				changer(cnt-x+1,y(i));
			query();
			if(now)
				printf("%d %d\n",b[ans],now*2);
			else
				puts("Peace");
		}
		else
		{
			int x=lower_bound(b+1,b+cnt+1,x(t(i)))-b;
			if(!t(t(i)))
				changel(x,-y(t(i)));
			else
				changer(cnt-x+1,-y(t(i)));
			query();
			if(now)
				printf("%d %d\n",b[ans],now*2);
			else
				puts("Peace");
		}
    ...
}
```

###### 100pts

每次都查询一次前后缀和显然耗费了较多的时间，想到从这里进行优化。

根据树状数组的性质： $c_x$ 存储区间 $[x-lowbit(x)+1,x]$ 中的数据 可知，可以直接对树状数组进行类似倍增的二分。这样，对于每次二分到的 $x$ ，下一次加上一个数在二进制下表现为在 $x$ 的最末位的 $1$ 后某一位添上一个 $1$ ，即若加上的数为 $y$ ，则有 $lowbit(x+y)=y$ ，因此 $c_y$ 存储的即为区间 $[x+1,y]$ 的数据，尝试是否可行即可。

由于这里是直接对树状数组进行二分，因此对 $b$ 序列倒着维护前缀和的方式不方便操作，可以先统计 $b$ 序列的总和，再用总和减去前缀和来得到后缀和。

这样可以减掉一个 $log$ 的复杂度，将时间复杂度降到 $O(nlogn)$ ，理论上可以拿到 $100$ 分。但是本题卡常十分毒瘤，卡过去还是有一定难度的。

```c++
#include<iostream>
#include<cstdio>
#include<algorithm>
#define rg register 
#define il inline
using namespace std;
const int N=2e6+10;
struct Que
{
	int p,t,x,y;
	#define p(i) q[i].p
	#define t(i) q[i].t
	#define x(i) q[i].x
	#define y(i) q[i].y
}q[N+100];
int Q,cnt,now,ans,rcnt;
int b[N],tl[N],tr[N];
il int read(){
    int w=1,num=1;
    char ch;
    while(ch=getchar(),ch<'0' || ch>'9')
        if(ch=='-') w=-1;
    num=ch-'0';
    while(ch=getchar(),ch>='0' && ch<='9')
        num=(num<<3)+(num<<1)+ch-'0';
    return num*w;
}//快读
il void changel(int p,int k)
{
	for(;p<=N;p+=p&-p)
		tl[p]+=k;
}//冰系序列修改
il int askl(int p)
{
	rg int val=0;
	for(;p;p-=p&-p)
		val+=tl[p];
	return val;
}//冰系序列查询
il void changer(rg int p,int k)
{
	for(;p<=N;p+=p&-p)
		tr[p]+=k;
}//火系序列修改
il int askr(rg int p)
{
	rg int val=0;
	for(;p;p-=p&-p)
		val+=tr[p];
	return val;
}//火系序列查询
il void query()
{
	rg int p=0,lsum=0,rsum=0;
	for(rg int i=20;i>=0;i--)
		if(p+(1<<i)<=cnt && lsum+tl[p+(1<<i)]<rcnt-rsum-tr[p+(1<<i)])
		{
			p+=(1<<i);
			lsum+=tl[p],rsum+=tr[p];
		}//树状数组二分
	rg int lans=min(lsum,rcnt-rsum),rans=min(askl(p+1),rcnt-askr(p));//分别计算两种情况的答案
	if(lans>rans)
		ans=p,now=lans;//冰系序列较小为答案的情况
	else
	{
		now=rans;
		p=0,lsum=0,rsum=0;
		for(rg int i=20;i>=0;i--)
			if(p+(1<<i)<=cnt &&(lsum+tl[p+(1<<i)]<rcnt-rsum-tr[p+(1<<i)] || min(lsum+tl[p+(1<<i)],rcnt-rsum-tr[p+(1<<i)])==now))
			{
				p+=(1<<i);
				lsum+=tl[p],rsum+=tr[p];
			}
		ans=p;
	}//火系序列较小为答案的情况
}
int main()
{
	Q=read();
	for(rg int i=1;i<=Q;i++)
	{
		p(i)=read(),t(i)=read();
		if(p(i)==1)
			x(i)=read(),y(i)=read(),b[++cnt]=x(i);
	}
	sort(b+1,b+cnt+1);
	cnt=unique(b+1,b+cnt+1)-b-1;//离散化
	for(rg int i=1;i<=Q;i++)
		if(p(i)==1)
		{
			rg int x=lower_bound(b+1,b+cnt+1,x(i))-b;
			if(!t(i))
				changel(x,y(i));
			else
				changer(x,y(i)),rcnt+=y(i);
			query();
			if(now)
				printf("%d %d\n",b[ans+1],now*2);
			else
				puts("Peace");
		}
		else
		{
			rg int x=lower_bound(b+1,b+cnt+1,x(t(i)))-b;
			if(!t(t(i)))
				changel(x,-y(t(i)));
			else
				changer(x,-y(t(i))),rcnt-=y(t(i));
			query();
			if(now)
				printf("%d %d\n",b[ans+1],now*2);
			else
				puts("Peace");
		}
	return 0;
}
```



---

## 作者：FutaRimeWoawaSete (赞：2)

一道很有趣的题目，虽然难度不大。          

我们很明显发现如果把可以参战的冰/火战士排好序后一个个对打，因为总会有一队人被耗尽，所以我们的答案即为两队冰火战士各自的能量之和取最小值然后乘上 2 。          

接着我们考虑这个数据范围，$2 \times 10 ^ 6 , 3s$ 基本上实锤了 $O(n \log n)$  。           

基本信息获取结束，考虑一下本题的特殊性质：          

- 随着温度的增高，答案呈一个单峰函数，这点很显然盲猜可以拿来用三分或二分优化。         

- 答案一定是一个战士的温度。这点我们可以这么想：因为要求温度最高，所以如果当前温度不是一个战士的温度必然可以调整到一个比当前温度高的战士的温度去，性质得证。

我们先考虑怎么暴力枚举，直接暴力离散化然后枚举每个战士的温度，用一个线段树或者树状数组维护一下前缀和后缀和即可，时间复杂度是 $O(n ^ 2 \log n)$ 。         

接着考虑优化暴力枚举，我们用一个trick：发现随着温度的增高，冰战士的能量总和是单调不减，火战士的能量总和是单调不增，把两个函数拿来做差的话得到的是一个单调递增的函数，由于在整数域上考虑，我们的答案靠近纵坐标为 $0$ 的情况。           

这样我们就可以二分了，不过需要注意的是这里有平台，即可能会有部分函数是平着的一条线，所以三分是错的。          

现在我们可以二分一个中介温度 T ，使得 T 最大并且 T 温度下冰战士的前缀能量和小于等于火战士的后缀能量和，那么答案的能量只会在 T 和 T + 1 两个温度下。           

如果 T 温度下的答案大于 T + 1 的温度那么我们就直接输出温度和能量即可。          

如果 T 温度下的答案小于等于 T + 1 的温度就需要继续做，这时候我们不清楚后面的函数是不是一个平台，所以我们得到了答案能量却不知道答案温度，不过这时候我们知道现在贡献答案的是火战士的后缀能量和，所以我们直接在来一遍二分即可，时间复杂度 $O(n \log n^2)$ 。        

不过很遗憾这是 60pts 做法，我们还得再去一只 $\log n$ 才能过这道题。    

我们考虑两种办法：在线段树上二分：二分的时候用线段树的mid作为二分界点，这时候我们可以利用线段树上维护的信息 $O(1)$ 算，接着我们就看答案是不是还是合法考虑向左向右走，时间复杂度 $O(n \log n)$ 不过这种做法常数很大实现精细卡卡常应该能过，预计得分 $[60 , 100]$ 。       


既然想到了线段树上二分，我们又发现这个玩意儿要求的都是前缀后缀，所以在树状数组上面把二分换成倍增，从大到小枚举 $2 ^ i$ 能跳就跳即可，时间复杂度 $O(n \log n)$ 。但是常数又小实现又简单，如果真在考场上说不定就想不出来这种做法~~毕竟我是第一次见这个trick~~。       

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;
const int Len = 2e6 + 5;
int n,m,c[Len][2],tot,lsh[Len],now[Len],cntIce,cntFire,allFire;
inline int read() {
    char ch = getchar();
    int x = 0, f = 1;
    while (ch < '0' || ch > '9') {
        if (ch == '-')
            f = -1;
        ch = getchar();
    }
    while ('0' <= ch && ch <= '9') {
        x = x * 10 + ch - '0';
        ch = getchar();
    }
    return x * f;
}
inline void write(int x) {
    if (x < 0)
        putchar('-'), x = -x;
    if (x > 9)
        write(x / 10);
    putchar(x % 10 + '0');
}
struct node
{
	int opt,t,x,y;
}Sec[Len]; 
int lowbit(int x){return x & (-x);}
inline void add(int x,int d,int op){while(x <= tot) c[x][op] += d , x += lowbit(x);}
inline int qry(int x,int op){int res = 0;while(x) res += c[x][op] , x -= lowbit(x) ; return res;}
inline int Calc(int x)
{
	if(x < 1 || x > tot) return -1;
	return min(qry(x , 0) , allFire - qry(x - 1 , 1));
}
int main()
{
	n = read();
	for(int i = 1 ; i <= n ; i ++) 
	{
		Sec[i].opt = read();
		if(Sec[i].opt == 1) 
		{
			Sec[i].t = read() , Sec[i].x = read() , Sec[i].y = read();
			lsh[++ tot] = Sec[i].x;
		}
		else Sec[i].t = read();
	} 
	sort(lsh + 1 , lsh + 1 + tot);
	tot = unique(lsh + 1 , lsh + 1 + tot) - lsh - 1;
	for(int i = 1 ; i <= n ; i ++) if(Sec[i].opt == 1) Sec[i].x = lower_bound(lsh + 1 , lsh + 1 + tot , Sec[i].x) - lsh;
	for(int i = 1 ; i <= n ; i ++)
	{
		if(Sec[i].opt == 1)
		{
			if(!Sec[i].t) cntIce ++;
			else cntFire ++ , allFire += Sec[i].y , now[Sec[i].x] += Sec[i].y;
			add(Sec[i].x , Sec[i].y , Sec[i].t); 
		}
		else
		{
			if(!Sec[Sec[i].t].t) cntIce --;
			else cntFire -- , allFire -= Sec[Sec[i].t].y , now[Sec[Sec[i].t].x] -= Sec[Sec[i].t].y;
			add(Sec[Sec[i].t].x , -Sec[Sec[i].t].y , Sec[Sec[i].t].t);
		}
		if(!cntIce || !cntFire){puts("Peace") ; continue;}
		int pos = 0 , sum = 0;
		for(int i = 21 ; i >= 0 ; i --)
		{
			int to = pos | (1 << i);
			if(to <= tot && sum + c[to][0] + c[to][1] - allFire - now[to] <= 0) pos = to , sum += c[to][0] + c[to][1];
		}
		int ansT = Calc(pos) , ansTT = Calc(pos + 1);
		if(ansT <= 0 && ansTT <= 0){puts("Peace") ; continue;}
		if(ansT > ansTT){write(lsh[pos]) , putchar(' ') , write(ansT << 1) , putchar('\n') ; continue;}
		pos = 0 , sum = 0;
		for(int i = 21 ; i >= 0 ; i --) 
		{
			int to = pos | (1 << i);
			if(to <= tot && allFire - (sum + c[to][1] - now[to]) >= ansTT) pos = to , sum += c[to][1]; 
		}
		write(lsh[pos]) , putchar(' ') , write(ansTT << 1) , putchar('\n');
	}
	return 0;
}
```

---

## 作者：chenxia25 (赞：1)

>### [洛谷题目页面传送门](https://www.luogu.com.cn/problem/P6619)

>有两种战士：冰和火，每个战士都有自身温度和能量。冰战士能参战当且仅当自身温度不大于场地温度，火战士相反。对于一个确定的场地温度，双方所有能参战的战士互相消耗相等的能量直到某一方没有能量了。你需要支持$2$种$q$次操作：

>1. $\texttt1\ x\ y\ z$：一个战士报名，若$x=0$是冰战士否则是火战士，自身温度为$y$，能量为$z$。$y\in\left[1,2\times10^9\right]$；
>1. $\texttt2\ x$：撤销第$x$次操作，保证第$x$次操作是报名操作。

>每次操作后，你需要选择场地温度来最大化双方消耗的总能量，在最大化总能量的前提下最大化场地温度，输出这两个值。若无法消耗能量，输出$\texttt{Peace}$。

>$q\in\left[1,2\times10^6\right]$。

设当前共有$n$个冰战士，第$i$个自身温度为$a_i$，能量为$b_i$；共有$m$个火战士，第$i$个自身温度为$c_i$，能量为$d_i$。那么对于场地温度$e$，冰战士的总能量为$\sum\limits_{i=1}^n[a_i\leq e]b_i$，火战士的总能量为$\sum\limits_{i=1}^m[c_i\geq e]d_i$，那么消耗的总能量显然是：

$$2\min\!\left(\sum\limits_{i=1}^n[a_i\leq e]b_i,\sum\limits_{i=1}^m[c_i\geq e]d_i\right)$$

显然，冰战士总能量关于$e$单调递增，火战士总能量关于$e$单调递减，那么这两个函数的$\min$就是非严格单峰的，这两个函数的差（冰减火）是单调递增的，在峰左边全负，在峰右边全正。

那么就很容易找峰了，只需要二分出最右一个差为负的位置$x$即可。于是可以基于场地温度（离散化后的，这个离散化之后一个点代表原来值域上朝右的一个区间，所以要把所有$y$和$y+1$压到离散化序列里）建一棵线段树，加/减战士时区间增加，找峰线段树二分，算答案时注意到峰左边$\min$取冰，右边$\min$取火，两边区间查最大值再取$\max$即可。

以上是我在考场上的做法。很显然，这个做法常数非常大，又是线段树又是懒标记，操作次数又多，再加上$2\times10^6$的数据范围，于是我被傻逼的CCF卡常成$60\mathrm{pts}$了（这里再吐槽一句，LOJ上是可以过的，CCF是甚么垃圾所谓的少爷机连洛谷都跑不过）。考虑优化。

一个显然的优化是，对于找到的峰$x$，不用两边区间查最大值，因为最大答案只可能在$x$和$x+1$处。但是有个问题，这并不能保证右边能最大化场地温度，这样再线段树二分即可。

然后不难想到线段树转BIT。注意到BIT不能区间修改，于是可以转差分，区间修改就变成差分数组的双点修改，单点查值就是差分数组的前缀和。那么如何在BIT上1log二分呢？注意到，线段树上的二分并不需要单调性，而这里需要二分于上的火函数和差函数都是单调的，相当于是个多余条件？暗示了我们可以转到BIT上。

这是一个很巧妙的trick：BIT倍增。解决的是这样的问题：求最右边的前缀和【某个关系】某个常数的那一处，其中前缀和数组与【某个关系】同方向单调（恰与本题吻合）。考虑二分转倍增，从左往右逼近（不能从右往左，那样就要反过来建，在这题上恰合适），从大到小枚举$2$的指数，可以发现从当前位置到当前位置加上当前枚举到的$2$的幂的位置中间那一段的和恰好是被记录的，因为$2$的指数是从大到小枚举的，所以中间那一段的长度一定是右端点的$\mathrm{lowbit}$。然后就可以正常倍增了。over。

现在加个快读快写开个洛谷自带O2即可AC。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define pb push_back
#define mp make_pair
#define X first
#define Y second
char _buf[10000000],*_st=_buf,*_ed=_buf;
#define getchar() (_st==_ed&&(_ed=(_st=_buf)+fread(_buf,1,1<<22,stdin),_st==_ed)?EOF:*_st++)
void read(int &x){//快读 
	x=0;char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))x=(x<<1)+(x<<3)+(c^48),c=getchar();
}
void prt(int x){//快写 
	if(x>=10)prt(x/10);
	putchar(x%10^48);
}
const int lowbit(int x){return x&-x;}
const int QU=2000000;
int qu;
struct query{int tp,x,y,z;}qry[QU+1];
vector<int> nums;
void discrete(){//离散化 
	sort(nums.begin(),nums.end());
	nums.resize(unique(nums.begin(),nums.end())-nums.begin());
	for(int i=1;i<=qu;i++)qry[i].y=lower_bound(nums.begin(),nums.end(),qry[i].y)-nums.begin()+1;
}
struct bitree{//BIT
	int sum0[2*QU+1]/*冰*/,sum1[2*QU+1]/*火*/;
	void init(){
		memset(sum0,0,sizeof(sum0));memset(sum1,0,sizeof(sum1));
	}
	void add0(int x,int v){//加冰 
		while(x<=nums.size())sum0[x]+=v,x+=lowbit(x);
	}
	void add1(int x,int v){//加火 
		while(x<=nums.size())sum1[x]+=v,x+=lowbit(x);
	}
	int lasne(){//最右的差为负的一处 
		int ans=0;int now=0;
		for(int i=22;~i;i--)if(ans+(1<<i)<=nums.size()&&now+sum0[ans+(1<<i)]-sum1[ans+(1<<i)]<0)ans+=1<<i,now+=sum0[ans]-sum1[ans];//倍增 
		return ans;
	}
	int laseq(int v){//最右的火函数等于v的一处，同上 
		int ans=0;int now=0;
		for(int i=22;~i;i--)if(ans+(1<<i)<=nums.size()&&now+sum1[ans+(1<<i)]>=v)ans+=1<<i,now+=sum1[ans];
		return ans;
	}
	int Sum0(int x){//冰，单点查值->前缀和 
		int res=0;
		while(x)res+=sum0[x],x-=lowbit(x);
		return res;
	}
	int Sum1(int x){//火，同上 
		int res=0;
		while(x)res+=sum1[x],x-=lowbit(x);
		return res;
	}
}bit;
int main(){
	read(qu);
	for(int i=1;i<=qu;i++){
		read(qry[i].tp);read(qry[i].x);
		if(qry[i].tp==1)read(qry[i].y),read(qry[i].z);
		else qry[i].y=qry[qry[i].x].y,qry[i].z=qry[qry[i].x].z,qry[i].x=qry[qry[i].x].x;
		nums.pb(qry[i].y);nums.pb(qry[i].y+1);//y和y+1都要pb进去 
	}
	discrete();
	for(int i=1;i<=qu;i++){
		int tp=qry[i].tp,x=qry[i].x,y=qry[i].y,z=qry[i].z;
		if(x==0)bit.add0(y,tp==1?z:-z);//差分 
		else bit.add1(1,tp==1?z:-z),bit.add1(y+1,tp==1?-z:z);//差分 
		int lasne=bit.lasne(),ans1=0,ans2=0;
		ans1=bit.Sum0(lasne);//找峰 
		if(lasne+1<=nums.size())ans2=bit.Sum1(lasne+1);//右边也要考虑一下 
		if(!ans1&&!ans2)puts("Peace"); 
		else if(ans2>=ans1)prt(nums[bit.laseq(ans2)]-1/*右边的最右处*/),putchar(' '),prt(ans2<<1),putchar('\n');
		else prt(nums[lasne]-1),putchar(' '),prt(ans1<<1),putchar('\n');
	}
	return 0;
}
```

---

## 作者：raincity (赞：0)

## 分析

卡了我一天半可还行。

> 当场地温度确定时，双方能够参赛的战士分别排成一队。冰系战士按自身温度从低到高排序，火系战士按自身温度从高到低排序，温度相同时能量大的战士排在前面。首先，双方的第一位战士之间展开战斗，两位战士消耗相同的能量，能量少的战士将耗尽能量退出比赛，而能量有剩余的战士将继续和对方的下一位战士战斗（能量都耗尽则双方下一位战士之间展开战斗）。如此循环，直至某方战士队列为空，比赛结束。

手玩一下，发现当温度确定时，设冰方所有可以参加比赛的战士能量之和为 $ice$，火方所有可以参加比赛的战士能量之和为 $fire$，消耗能量为 $2\times\min(ice,fire)$。（容易理解，不加以赘述）

然后可以发现，设温度为 $temp$ 时设冰方所有可以参加比赛的战士能量之和为 $ice_{temp}$，火方所有可以参加比赛的战士能量之和为 $fire_{temp}$ ，那么 $ice$ 和 $fire$ 都有单调性。$ice$ 单调增加，$fire$ 单调减少·。

学过一次函数的人都知道应该在 $ice_{t}=fire_t$ 的时候答案最大。

但是这是一道省选题，肯定要挖~~坟~~坑。

首先，$ice$ 和 $fire$ 的定义域为整数，而一次函数的定义域为实数，有一些细微的区别：设 $pos$ 为最后一个满足 $ice_{pos}\le fire_{pos}$ 的温度，那么 $\min(ice_{temp},fire_{temp})=\max(\min(ice_{pos},fire_{pos}),\min(ice_{pos+1},fire_{pos+1}))$。但是还有~~一口井~~一个坑：

>  使冰火双方消耗总能量最高的温度的**最高值**

所以需要找到最高温度，而且只要 $\min(ice_{pos+1},fire_{pos+1})\le \min(ice_{pos},fire_{pos})$ 就要选前者。（调了我七八个小时）

显然最佳温度肯定是某一个选手的温度，先离散化，那么问题转化为：

维护两个序列 $ice$ 和 $fire$，需要支持一下操作：

- 单点查询
- 区间增加
- 求最后一个满足 $ice_i\le fire_i$ 的位置 $i$
- 求最后一个满足 $ice_i\le fire_i$ 或者 $\min(ice_i,fire_i)=t$ 的位置 $i$

前两个操作很好维护，查分+树状数组 or 线段树就可以。

但是这题 $n$ 到 $2\times 10^6$，线段树常数又大得一匹，线段树二分很不现实。

当然也有人拿 zkw 线段树过了，我只能佩服他高超的卡常数技巧。

讲一个树状数组+倍增的想法：

倒序循环 $i=\log tot$ 至 0，维护当前位置 $curpos$，那么 $curpos+2^i$ 的位置的树状数组维护了 $(curpos,curpos+2^i]$ 的信息，能加 $2^i$ 就加（因为倒序循环 $i$，所以循环到 $i$ 的时候 $curpos$ 的低 $i$ 位都是 0，那么 $lowbit(curpos+2^i)=2^i$）

然后就可以愉快地写代码了。**注意常数**。

~~事实是我看 $2\times 10^6\times\log(2\times 10^6)$ 有点悬，然后写代码的时候大力卡常数，结果交上去最大点 2s 不到~~

## 代码

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <sys/mman.h>
#include <cmath>

namespace Read {
	char buf[1 << 21], *p;
#define getchar() *p++
	inline void read(int &ret) {
		ret = 0;
		char ch = getchar();
		while (ch < '0' || ch > '9') ch = getchar();
		while (ch >= '0' && ch <= '9') ret = ret * 10 + ch - '0', ch = getchar();
	}
} // namespace Read
using Read::read;

namespace Write {
	char buf[1 << 21], tmp[21];
	int tot, top;
	inline void flush() { fwrite(buf, 1, tot, stdout), tot = 0; }
	inline void writePeace() { buf[tot++] = 'P', buf[tot++] = 'e', buf[tot++] = 'a', buf[tot++] = 'c', buf[tot++] = 'e', buf[tot++] = '\n'; }
	inline void write(long long ans, char ch) {
		if (tot + 20 > (1 << 21))
			flush();
		while (ans) tmp[top++] = ans % 10 + '0', ans /= 10;
		while (top) buf[tot++] = tmp[--top];
		buf[tot++] = ch;
	}
} // namespace Write
using Write::flush;
using Write::write;
using Write::writePeace;

using namespace std;

const int N = 2e6 + 5;
int n, tmp[N], delta, ice[N], fire[N], tot, Log;
struct message { int op, t, x, y; } e[N];

inline int query_fire(int temp) {
	int res = 0;
	for (; temp; temp &= temp - 1) res += fire[temp];
	return res + delta;
}

inline int query_ice(int temp) {
	int res = 0;
	for (; temp; temp &= temp - 1) res += ice[temp];
	return res;
}

inline void add_fire(int temp, int energy) {
	delta += energy, ++temp;
	while (temp <= tot) {
		fire[temp] -= energy;
		temp += temp & (-temp);
	}
}

inline void add_ice(int temp, int energy) {
	while (temp <= tot) {
		ice[temp] += energy;
		temp += temp & (-temp);
	}
}

inline int multiplicate() {
	int curpos = 0, minus = -delta;
	for (register int i = Log; i >= 0; i--) {
		if (curpos + (1 << i) > tot)
			continue;
		if (minus + ice[curpos + (1 << i)] - fire[curpos + (1 << i)] <= 0)
			curpos += 1 << i, minus += ice[curpos] - fire[curpos];
	}
	return curpos;
}

inline int goforward(int mi) {
	int curpos = 0, fire_sum = delta, ice_sum = 0;
	for (register int i = Log; i >= 0; i--) {
		if (curpos + (1 << i) > tot)
			continue;
		int _fire = fire_sum + fire[curpos + (1 << i)], _ice = ice_sum + ice[curpos + (1 << i)];
		if (_ice <= _fire || min(_ice, _fire) == mi)
			curpos += 1 << i, fire_sum = _fire, ice_sum = _ice;
	}
	return curpos;
}

int main() {
    Read::p = (char*)mmap(0, 900 << 20, PROT_READ, MAP_PRIVATE, fileno(stdin), 0);
	read(n);
	int cnt = 0;
	for (register int i = 1; i <= n; i++) {
		read(e[i].op), read(e[i].t);
		if (e[i].op == 1)
			read(e[i].x), read(e[i].y), tmp[++cnt] = e[i].x;
	}
	sort(tmp + 1, tmp + cnt + 1);
	tot = unique(tmp + 1, tmp + cnt + 1) - tmp - 1, Log = log2(tot);
	for (register int i = 1; i <= n; i++)
		if (e[i].op == 1) {
			int l = 1, r = tot, mid;
			while (l <= r) {
				mid = (l + r) >> 1;
				if (tmp[mid] == e[i].x) {
					e[i].x = mid;
					break;
				} else if (tmp[mid] > e[i].x)
					r = mid - 1;
				else
					l = mid + 1;
			}	
		}
	for (register int i = 1; i <= n; i++) {
		if (e[i].op == 1) {
			if (e[i].t == 0)
				add_ice(e[i].x, e[i].y);
			else
				add_fire(e[i].x, e[i].y);
		}
		else {
			int id = e[i].t;
			if (e[id].t == 0)
				add_ice(e[id].x, -e[id].y);
			else
				add_fire(e[id].x, -e[id].y);
		}
		int p = multiplicate(), ans = min(query_ice(p), query_fire(p)) * 2, res;
		if (p < tot && (res = min(query_ice(p + 1), query_fire(p + 1)) * 2) >= ans)
			ans = res, p = goforward(ans >> 1);
		if (ans)
			write(tmp[p], ' '), write(ans, '\n');
		else
			writePeace();
	}
	flush();
	return 0;
}

```

#### THE END



---


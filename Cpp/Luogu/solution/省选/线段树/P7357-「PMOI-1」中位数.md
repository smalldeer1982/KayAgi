# 「PMOI-1」中位数

## 题目描述

给定一棵以 $1$ 为根的包含 $n$ 个节点的**有根树**。第 $i$ 个节点有点权 $a_i$。

定义函数 $f(u,v)$ 表示从 $u$ 到 $v$ 经过的所有节点的点权的**可重集**的中位数。

请注意，**本题中的中位数的定义与数学中的定义略有不同**：这里一个长度为 $t$ 的序列的中位数定义为这个序列第 $\left\lceil\frac{t+1}2\right\rceil$ 小的数。

定义函数 $\text{cover}(x_1,y_1,x_2,y_2)$ 表示从 $x_1$ 到 $y_1$ 的路径是否完全覆盖了从 $x_2$ 到 $y_2$ 的路径。如果完全覆盖，则 $\text{cover}(x_1,y_1,x_2,y_2)=1$，否则 $\text{cover}(x_1,y_1,x_2,y_2)=0$。

你需要依次处理 $q$ 次操作，按照以下格式给出：

`1 u`：表示一次操作，需要你将点 $u$ 的点权对 $1$ **异或**；

`2 u v`：表示一次询问，需要你求出 $\max\limits_{1\le i\le n,1\le j\le n}\{\text{cover}(i,j,u,v)f(i,j)\}$。

对于第二类操作，保证每次询问均满足 $u$ 不是 $v$ 的祖先且 $v$ 不是 $u$ 的祖先，且 $u \neq v$。

你需要对于每个第二类操作，输出对应的值。

## 说明/提示

【样例解释】

第一次是询问。显然，只有 $(i=4,j=8)$ 满足 $\text{cover}(i,j,u,v)=1$。此时 $f(i,j)=3$。

第二次是操作。将 $3$ 号节点的点权改为了 $2$。

第三次是询问。当 $i=4,j=3$ 时，$\text{cover}(i,j,u,v)=1$ 且 $f(i,j)=4$。不难发现，对于其他所有满足 $\text{cover}(i,j,u,v)=1$ 的节点对 $(i,j)$，均没有 $f(i,j)>4$。

【数据范围】
- Subtask 1（8 pts）：$n,q\le50$；
- Subtask 2（12 pts）：$n,q\le2\times10^3$；
- Subtask 3（16 pts）：$n,q\le4\times10^4$；
- Subtask 4（10 pts）：保证树的形态随机生成；
- Subtask 5（12 pts）：保证没有 $1$ 操作；
- Subtask 6（12 pts）：保证每次询问的 $u,v$ 都是叶子节点；
- Subtask 7（30 pts）：无特殊限制。

Subtask 4 的随机方式为：随机生成一个的排列 $p$，对于 $i\in[2,n]$，$p_i$ 向 $p_1,p_2,...,p_{i-1}$ 中等概率随机的一个点连边。

对于 $100\%$ 的数据满足，$1\le n,q,a_i \le 10^5$，保证每次询问均满足 $u$ 不是 $v$ 的祖先且 $v$ 不是 $u$ 的祖先，且 $u \neq v$。

## 样例 #1

### 输入

```
8 3
4 2 3 4 2 1 4 3
1 2
1 3
2 4
2 5
3 6
6 7
6 8
2 4 8
1 3 
2 2 3```

### 输出

```
3
4```

# 题解

## 作者：Y_B_X (赞：6)

[题目链接](https://www.luogu.com.cn/problem/P7357)


~~我不会告诉你我是因为题目背景的头像与我们班主任一毛一样才来写题解的~~

题意：  
给出一棵树，点有点权，每次将一个点的点权异或 $1$ ，  
或给出两个点 $u,v$ ，询问能覆盖 $u,v$ 的路径所形成的序列的中位数最大值。  
保证这 $u,v$ 不在一条链上，这里中位数指长为 $n$ 的序列中第 $\left\lfloor\frac{n+1}{2}\right\rfloor$ 大的数。

## $\text{Step 1}$

先看一下这种定义下的中位数的性质：

对于一个序列 $S,n=\left|S\right|$

设 $g_a=|\{i|s_i\geq a,1\leq i\leq n\}|,l_a=|\{i|s_i< a,1\leq i\leq n\}|$

则 $S$ 的中位数就是原序列中满足 $g_a\leq l_a$ 的最大的 $a$ 

如果把 $\geq a$ 的数设为 $1$ ，把 $<a$ 的数设为 $-1$ ，$a$ 是中位数时必须这些 $1$ 与 $-1$ 的和 $\geq 0$ ，且 $a$ 最大。

由于设成 $1$ 与 $-1$ 的操作在 $a$ 递增时 $-1$ 增多，可以建出一颗主席树来维护。

这套路在 [此题](https://www.luogu.com.cn/problem/P2839) 中曾出现过。

## $\text{Step 2}$

对于题目中的满足覆盖 $u,v$ 的路径的中位数最大值，是有单调性的，考虑二分。

对于一个二分的值 $mid$ 我们希望得知：把树上每个点权 $\geq mid$ 的点的 **键值** 设成 $1$ ，把点权 $<mid$  的点的**键值** 设成 $-1$ 后，查看能覆盖 $u,v$ 路径中 **键值的和的最大值** 能否 $\geq 0$ 。

由于要覆盖 $u,v$ 且 $u,v$ 不在一条路径上，考虑树上差分。

设 $f_x^a=\text{a时x到根路径键值之和}$

所以二分时要求的键值的和的最大值就是：  

$\max\limits_{x\in \operatorname{subtree}(u)}f_x^{mid}+\max\limits_{y\in \operatorname{subtree}(v)}f_y^{mid}-2f_{\operatorname{lca}(u,v)}^{mid}+w_{\operatorname{lca}(u,v)}^{mid}$

其中 $w_x^{a}$ 代表 $a$ 时 $x$ 的键值。

于是希望对每个 $a$ 维护 $dfs$ 序所代表的点的 $f_x^a$ 值，这样就容易查询子树最大值。

## $\text{Step 3}$

考虑如何用主席树维护 $f_x^a$ 值。

对于 $a=0$ 时，$f_x^a=\operatorname{dep}(x)$ ，即 $x$ 的深度，因为所有点的点权 $\geq 0$ 。

当 $a$ 变大时会导致一些点的键值从 $1$ 变成 $-1$ 

那这些点的子树内的所有点的 $f^a$ 值就会 $-2$ 。

由于主席树是以 $dfs$ 序为下标建的，这相当于区间减并可持久化。

这可以用 **标记永久化** 轻松实现。

## $\text{Step 4}$

现在只剩下最后一个问题：把点权异或 $1$

开始建主席树时顺便把每个点的点权异或 $1$ 后的值顺带着离散化并建主席树。

由于异或 $1$ 后一个点的点权要么变大一，要么减小一。

设 $t_x=2\left\lfloor\frac{x}{2}\right\rfloor+1$ ，即不比 $x$ 小的最小的奇数。

那么 $a>t_x$ 的版本无论如何都不发生改变，因为$\max(x,x\operatorname{xor}1)\leq t_x$

而 $a\leq t_x-1$ 的版本同样不发生变化，因为 $\min(x,x\operatorname{xor}1)\geq t_x-1$

所以受改动的版本仅有 $t_x$ 一个。

#### 若 $x$ 为奇数， $t_x=x$ , 异或后变小成  $x-1$ 。

那原先 $x$ 的版本中这个点的键值为 $1$ ，权值变小后要成为 $-1$ 

所以将 $x$ 的版本中这个点的子树内所有点的 $f$ 值  $-2$ 

#### 若 $x$ 为偶数， $t_x=x+1$ ，异或后变大成 $x+1$


那原先 $x+1$ 的版本中这个点的键值为 $-1$ ，权值变大后要成为 $1$ 

所以将 $x+1$ 的版本中这个点的子树内所有点的 $f$ 值  $+2$ 

这同样可用标记永久化实现。

## $\text{Step 5}$

预处理时间复杂度为 $O(n\log n)$ 

更改点权的时间复杂度单次为 $O(\log n)$

查询要套个二分，单次 $O(\log^2 n)$

### 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e5+10;
int n,m,nn,x,y,opt,tot,tt,l,L,R,mid,cnt,qx,qy;
int a[N],b[N],rt[N],ii[N];
int dfn[N],rev[N],sz[N],dep[N],f[N][20];
int to[N],nextn[N],h[N],edg;char ch;
inline void add(int x,int y){to[++edg]=y,nextn[edg]=h[x],h[x]=edg;}
#define id(x) lower_bound(b+1,b+nn+1,x)-b
struct tree{int l,r,tag,mx;}t[N<<5];
inline void read(int &x){
	x=0;ch=getchar();while(ch<48||ch>57)ch=getchar();
	while(ch>47&&ch<58)x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
}
void write(int x){if(x>9)write(x/10);putchar(48+x%10);}
void build(int &k,int l,int r){
	k=++tot;
	if(l^r){
		int mid=(l+r)>>1;
		build(t[k].l,l,mid);build(t[k].r,mid+1,r);
		t[k].mx=max(t[t[k].l].mx,t[t[k].r].mx);
	}
	else t[k].mx=dep[rev[l]];
}
void update(int &k,int kk,int l,int r,int x,int y,int v){
	k=++tot;t[k]=t[kk];
	if(x<=l&r<=y)t[k].tag+=v,t[k].mx+=v;
	else {
		int mid=(l+r)>>1;
		if(x<=mid)update(t[k].l,t[kk].l,l,mid,x,y,v);
		if(mid<y)update(t[k].r,t[kk].r,mid+1,r,x,y,v);
		t[k].mx=max(t[t[k].l].mx,t[t[k].r].mx)+t[k].tag;
	}
}
int inquiry(int k,int l,int r,int pos){
	if(l^r){
		int mid=(l+r)>>1;
		if(pos<=mid)return inquiry(t[k].l,l,mid,pos)+t[k].tag;
		else return inquiry(t[k].r,mid+1,r,pos)+t[k].tag;
	}
	else return t[k].mx;
}
int inquiry_mx(int k,int l,int r,int x,int y){
	if(x<=l&&r<=y)return t[k].mx;
	int mid=(l+r)>>1;
	if(x<=mid&&mid<y)
		return max(inquiry_mx(t[k].l,l,mid,x,y),inquiry_mx(t[k].r,mid+1,r,x,y))+t[k].tag;
	else if(x<=mid)return inquiry_mx(t[k].l,l,mid,x,y)+t[k].tag;
	else return inquiry_mx(t[k].r,mid+1,r,x,y)+t[k].tag;
}
void init(int x,int anc){
	int i,y;rev[dfn[x]=++tt]=x;
	sz[x]=1;dep[x]=dep[anc]+1;f[x][0]=anc;
	for(i=1;i^20;++i)f[x][i]=f[f[x][i-1]][i-1];
	for(i=h[x];y=to[i],i;i=nextn[i])if(y^anc)init(y,x),sz[x]+=sz[y];
	h[x]=0;
}
int lca(int x,int y){
	int i;if(dep[x]<dep[y])x^=y^=x^=y;
	for(i=19;~i;--i)if(dep[f[x][i]]>=dep[y])x=f[x][i];
	if(x==y)return x;
	for(i=19;~i;--i)if(f[x][i]^f[y][i])x=f[x][i],y=f[y][i];
	return f[x][0];
}
main(){
	read(n);read(m);register int i,j;
	for(i=1;i<=n;++i){read(a[i]),b[++nn]=a[i];if(a[i]^1)b[++nn]=a[i]^1;}
	sort(b+1,b+nn+1);nn=unique(b+1,b+nn+1)-b-1;
	for(i=1;i^n;++i)read(x),read(y),add(x,y),add(y,x);
	init(1,0);edg=0;build(rt[0],1,n);
	for(i=1;i<=n;++i)add(ii[i]=id(a[i]),i),ii[i]+=(a[i]&1)^1;
	for(i=1;rt[i]=rt[i-1],i<=nn;++i)for(j=h[i-1];x=to[j],j;j=nextn[j])
		update(rt[i],rt[i],1,n,dfn[x],dfn[x]+sz[x]-1,-2);
	while(m--){
		read(opt);read(x);
		if(opt==1){
			i=ii[x];
			if(a[x]&1)update(rt[i],rt[i],1,n,dfn[x],dfn[x]+sz[x]-1,-2);
			else update(rt[i],rt[i],1,n,dfn[x],dfn[x]+sz[x]-1,2);
			a[x]^=1;
		}
		else {
			read(y);l=lca(x,y);
			L=0;R=nn;
			while(L<R){
				mid=L+R+1>>1;cnt=0;
				cnt+=inquiry_mx(rt[mid],1,n,dfn[x],dfn[x]+sz[x]-1);
				cnt+=inquiry_mx(rt[mid],1,n,dfn[y],dfn[y]+sz[y]-1);
				cnt-=(inquiry(rt[mid],1,n,dfn[l])<<1)+(a[l]>=b[mid]?-1:1);
				if(cnt>=0)L=mid;else R=mid-1;
			}
			write(b[L]);putchar('\n');
		}
	}
}
```

---

## 作者：ducati (赞：5)

# Description

给定一棵包含 $n$ 个节点的**有根树**，其根为 $1$ 。第 $i$ 个节点有点权 $a_i$ 。

定义函数 $f(l,r)$ 表示从 $l$ 到 $r$ 经过的所有节点的点权**可重集**的中位数。

请注意，**本题中的中位数的定义与数学中的定义略有不同**：这里一个长度为 $t$ 的序列的中位数定义为这个序列第 $\left\lceil\dfrac{t+1}2\right\rceil$ 小的数。

定义函数 $cover(u,v,i,j)$ 表示从 $u$ 到 $v$ 的路径是否完全覆盖了从 $i$ 到 $j$ 的路径。如果完全覆盖，则 $cover(u,v,i,j)=1$，否则 $cover(u,v,i,j)=0$。

你需要依次处理 $q$ 次询问或操作。

`1 u`：表示一次操作，需要你将点 $u$ 的点权对 $1$ 异或；

` 2 u v`：表示一次询问，需要你查询 $\max_{1\le i\le n,1\le j\le n}\{cover(i,j,u,v) f(i,j)\}$

# Solution
## Lemma 1
根据中位数的定义，不难得到一个性质。

令 $g(x,y)=[x < y]?-1:1$ ，那么对于一个长度为 $n$ 的序列 $A$ 的中位数 $y$ 必然是在满足 $\sum_{i=1}^n g(a_i,y)$ **非负**的**前提下**的**最大值**。

## Lemma 2

根据本题中 $\lfloor$ $u,v$ 无祖先关系且 $u \neq v$ $\rceil$ 的限制，不难发现对于一条满足 $cover(i,j,u,v)=1$ 的路径， $i,j$ 分别在以 $u,v$ 为根的子树中。

换句话说，路径 $(i,j)$ 可以拆分为**独立**的三段:

①从 $i$ 到 $u$ 

②从 $u$ 到 $v$ 

③从 $v$ 到 $j$ 

---

对性质的观察到此为止。我们考虑如何快速处理操作与询问。第一步中，我们思考，如果没有修改只有询问我们该如何处理。

考虑**二分答案**。假设当前二分的值为 $mid$ ，那么 $check$ 的作用就是要去判断是否存在一条从 $i(i \in subtree(u))$到$j(j \in subtree(v))$ 的路径满足 $\sum_{u \in path(i,j)}g(A_u,mid)$ 非负。

根据 Lemma 2，我们可以**分开来**思考这三段，每一段取最优。

首先思考②，即 $\sum_{i \in path(u,v)} g(A_i,mid)$ 。显然，在 $i,j$ 变化的过程中，这是一个定值。这可以通过主席树快速求出。

然后思考①、③。这两部分基本相同，下面以①为例。

令 $pre_{f,x}$表示$\sum_{i \in path(1,f)} g(A_i,x)$ ，那么①可以写为 
$$
\max_{i \in subtree(u)} pre_{i,x}-pre_{fa_u,x}$$

这里的 $fa_u$ 表示 $u$ 的父节点。

我们尝试**预处理出**所有 $pre_{i,t}(1 \le i \le n,1 \le t \le max_{1 \le i \le n} {a_i})$，但是这样的时空复杂度全部上天。但是，当 $t$ 增加一的时候，**只有**一些 $g(i,t)$ 相比 $g(i,t-1)$ 产生了变化(从 $-1$ 变成了 $1$ )，因此**只有**一些 $pre_{i,t}$ 相比原来产生了变化。深挖下去，若 $g(i,t)$ 变化，那么对于所有在 $i$ 子树内的节点 $v$ ， $pre_{v,t}$ 均产生了一定的变化；而这个子树映射到 $dfs$ 序上对应的是连续的一段区间，于是这等价于一个**区间修改**。同时，我们也要保留这个序列的所有历史状态。

所以我们采用标记永久化的可持久化线段树(主席树)来维护 $pre$ 即可。

每次二分的时候，①可以转化为一个在 $dfs$ 序意义下的区间查询最大值，于是我们直接在对应的一棵权值线段树上进行递归查询即可。②同理。

由于 $a_i$ 与 $n$ 同阶，所以时间复杂度 $O(n \log^2 n)$ 。

---

考虑如何处理修改。

类比上面的思路，我们可以将**维护一个节点到根路径上各种值出现的次数** （即维护②的主席树）的主席树的**时间轴**改为点权的**大小顺序**，并将这棵主席树同样做**标记永久化**。

考虑到每次修改后点权只会增加或减少 $1$ ，所以两棵主席树只会**分别**有两棵权值线段树的点权与向外的连边产生变化。于是我们重造一下这 $2 \times 2=4$ 棵权值线段树即可。

时间复杂度依然是 $O(n \log^2 n)$。

---


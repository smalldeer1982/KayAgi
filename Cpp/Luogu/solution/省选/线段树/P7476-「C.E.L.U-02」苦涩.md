# 「C.E.L.U-02」苦涩

## 题目背景

回想起自己的过往的人生，YQH 觉得心中充满了苦涩。如果人生能再来一次，我一定会少做一些傻事，少真香几次，然后大胆地去追寻自己的爱。可惜没有这样一个机会了。  

## 题目描述

在 YQH 的梦中，他看到自己过去的记忆正在不断浮现在自己脑中。这些记忆带给他的是满满的苦涩。他想要强行忘记一些来减轻自己的苦涩。  
YQH 的脑中可以被分成 $n$ 个片区，每个片区相当于一个存放记忆的可重集，初始为空。他将进行 $m$ 次这三种操作：  
操作 1：区间 $l\sim r$ 的片区中都浮现了一个苦涩值为 $k$ 的记忆。    
操作 2：YQH 开始清理 $l\sim r$ 片区的记忆。如果一个片区 $k\in[l,r]$ 且 $k$ 中苦涩值最大的记忆与 $l\sim r$ 片区中苦涩值最大的记忆相等，则将这个苦涩值最大的记忆忘记。如果在同一个片区有多个相同的苦涩值最大的记忆，则只忘记一个。如果这些片区内没有记忆，则无视。  
操作 3：YQH 想知道，$l\sim r$ 片区中苦涩值最大的记忆的苦涩值是多少，如果不存在，输出`-1`。  

## 说明/提示

### 样例解释 

**样例解释一**

下面为各操作之后 YQH 的大脑的状态：  
第一次操作：$\{2\},\{2\},\{2\},\varnothing,\varnothing$  
第二次操作：$\{2\},\{2,3\},\{2,3\},\{3\},\varnothing$    
第三次操作：$\{2\},\{2,3\},\{2\},\{3\},\varnothing$    
第四次操作询问 区间 $1\sim 3$ 的最大值，所以答案是 $3$。

**样例解释二**

下面为各操作之后 YQH 的大脑的状态：  
第一次操作：$\{2\},\{2\},\{2\},\{2\},\{2\},\{2\}$  
第二次操作：$\{2\},\{2\},\{2,2\},\{2\},\{2\},\{2\}$  
第三次操作：$\{2\},\{2\},\{2,2,3\},\{2,3\},\{2\},\{2\}$   
第四次操作：$\{2\},\{2\},\{2,2\},\{2\},\{2\},\{2\}$  
第五次操作询问 $3$ 的最大值，所以答案是 $2$。  
第六次操作询问 $4$ 的最大值，所以答案是 $2$。  

### 数据范围  
|Subtask|n|m|特殊性质|
|:---:|:---:|:---:|:---:|
|$1(10pts)$|$\leq10^3$|$\le10^3$|$\diagdown$|
|$2(20pts)$|$\leq5\times10^4$|$\leq5\times10^4$|没有操作 2|
|$3(10pts)$|$\leq5\times10^4$|$\leq5\times10^4$|操作 2 中 $l=r$|
|$4(20pts)$|$\leq5\times10^4$|$\leq5\times10^4$|$\diagdown$|
|$5(20pts)$|$\leq2\times10^5$|$\leq2\times10^5$|操作 2 中 $l=r$|
|$6(20pts)$|$\leq2\times10^5$|$\leq2\times10^5$|$\diagdown$|  

对于 $100\%$ 的数据，$n,m\le2\times10^5,k\le10^9$  

## 样例 #1

### 输入

```
5 4
1 1 3 2
1 2 4 3
2 3 3
3 1 3```

### 输出

```
3```

## 样例 #2

### 输入

```
6 6
1 1 6 2
1 3 3 2
1 3 4 3
2 3 4
3 3 3
3 4 4```

### 输出

```
2
2```

# 题解

## 作者：abruce (赞：13)

如果数据水，敬请谅解，也希望提供强数据。  
如果有时间复杂度更优秀的做法，请写题解，我会感激的。  
先看部分分吧。  
### 10pts  
每个点开一个堆，然后就是常规操作了。  
### 20pts  
只有添加，没有删除，相当于区间取 max，区间 max。那就意味着我们可以用线段树维护。  
### 40pts  
发现单点删除最大值用线段树不太好操作，也不好进行标记下放和信息。上传我们考虑暴力一点，用分块维护信息，每个块开一个堆代表整块都被插入的东西，每个点也要开一个堆，然后开一个 maxx 数组代表块内最大值。  
插入的时候我们边角暴力，中间插入整块的堆，然后更新 maxx。  
删除的时候我们比较它自己的堆和它所属的块的堆。如果他自己的堆的堆顶更大，则直接删除，然后更新 maxx。如果它所属的堆更大，则删除掉之后，把它塞入块内其余点的堆里，因为它们还存在这个值，所以不用更新 maxx。  
查询的时候我们边角暴力询问单点堆顶和整块堆顶，中间的整块直接查询 maxx，就解决了。  
时间复杂度在块长为 $\sqrt{n}$ 时复杂度较优，为 $O(n\sqrt{n}logn)$。代码如下，比较短。本来这是这个题的标算，但是……  
![](https://cdn.luogu.com.cn/upload/image_hosting/afv2i9hs.png)

### 60pts(1)  
既然要 polylog，首先堆的一个 log 很难避免，我们剩下的那个 log 就可以往线段树上想。  
考虑使用标记永久化，这个永久化的标记形成了一个堆。我们再在线段树里维护一个 maxx，代表这个区间的最大值。这样，插入和查询操作就很好处理了。  
现在我们考虑删除，由于是单点，首先我们找到这个最大值，然后在线段树里找到这个标记。我们需要把这个标记移除，并将其加入这个区间的其它点内，你可以再写一个 pushdown，也可以直接跑两遍插入（这样常数要大一点）。  
时间复杂度 $O(nlog^2n)$，代码挺好写的。  
~~我终于知道 lxl 为什么直接拒了。~~  
### 60pts(2)
如果你的分块可以支持区间修改，则可以通过 60 分的数据。  
## 100pts  
我们考虑怎么优化 60 分的线段树，使它支持区间修改。  
我们可以想到先找到这一段的最大值是哪一个，然后把标记从这个区间上面移除。这样做看起来时间复杂度是不对的，但我们可以进行剪枝。如果这一个区间的最大值比我们需要删去的小，我们就不去了。  
乍一看复杂度还是不对，但我们可以分析一下。我们时间复杂度相当于对于每一个最大值的连续区间，把它在线段树上分成不超过 log 个区间。由于我们插入的时候是整段一起插入同一个值，所以插入均摊下来会产生 $mlogn$ 个线段树区间。  
我们每删除一个产生的线段树区间，最多花 $logn$ 时间递归下去删除标记。所以删除的时间复杂度为均摊 $O(mlog^2n)$ （堆的复杂度和向下递归的复杂度是并列的）由于插入和查询的复杂度也是这个量级，所以总复杂度 $O((n+m)log^2n)$。  
代码十分好写，不到 2k。如果哪里没叙述清楚，请向我提出。  
```cpp
#include <bits/stdc++.h>
#define lc id<<1
#define rc id<<1|1
using namespace std;
const int maxn=2e5+5;
struct tree {
	int l,r,mid,maxx;
	priority_queue<int> q;
} t[maxn*4];
int n,m;
void build(int id,int l,int r) {
	t[id]=(tree) {
		l,r,(l+r)/2,-1
	};
	t[id].q.push(-1);
	if(l==r)return;
	int mid=(l+r)/2;
	build(lc,l,mid);
	build(rc,mid+1,r);
}
void addtag(int id,int v) {
	t[id].q.push(v);
	t[id].maxx=max(t[id].maxx,v);
}
void pushup(int id) {
	t[id].maxx=max(max(t[lc].maxx,t[rc].maxx),t[id].q.top());
}
void pushdown(int id,int l,int r,int k) {//把 k 这个标记往 l,r 之外区间插入
	if(t[id].l>=l&&t[id].r<=r) return;
	if(l>t[id].mid)addtag(lc,k),pushdown(rc,l,r,k);
	else if(r<=t[id].mid)addtag(rc,k),pushdown(lc,l,r,k);
	else pushdown(lc,l,r,k),pushdown(rc,l,r,k);
	pushup(id);
}
void add(int id,int l,int r,int v) {
	if(t[id].l>=l&&t[id].r<=r) {
		addtag(id,v);
		return;
	}
	if(l<=t[id].mid)add(lc,l,r,v);
	if(r>t[id].mid)add(rc,l,r,v);
	pushup(id);
}
void del(int id,int l,int r,int k) {
	if(t[id].l>=l&&t[id].r<=r&&t[id].maxx<k)return;//核心：剪枝
	if(t[id].q.top()==k) {
		t[id].q.pop();
		pushdown(id,l,r,k);
		if(t[id].l==t[id].r)t[id].maxx=t[id].q.top();
		else pushup(id);
		return;//由于只pop一个，这里弄完标记就走了
	}
	if(l<=t[id].mid)del(lc,l,r,k);
	if(r>t[id].mid)del(rc,l,r,k);
	pushup(id);
}
int ask(int id,int l,int r) {
	if(t[id].l>=l&&t[id].r<=r) {
		return t[id].maxx;
	}
	int ans=t[id].q.top();
	if(l<=t[id].mid)ans=max(ans,ask(lc,l,r));
	if(r>t[id].mid)ans=max(ans,ask(rc,l,r));
	return ans;
}
int main() {
	t[0].q.push(-1),t[0].maxx=-1;
	int op,x,y,z;
	scanf("%d%d",&n,&m);
	build(1,1,n);
	for(register int i=1; i<=m; i++) {
		scanf("%d%d%d",&op,&x,&y);
		switch(op) {
			case 1: {
				scanf("%d",&z);
				add(1,x,y,z);
				break;
			}
			case 2: {
				z=ask(1,x,y);
				if(z!=-1)del(1,x,y,z);
				break;
			}
			case 3: {
				printf("%d\n",ask(1,x,y));
				break;
			}
		}
	}
	return 0;
}
```

---

## 作者：DPair (赞：11)

为什么我最后两个点线段树空间开到了 $4$ 倍照样 RE 啊，改大一点就过了的说（（

## 思路
比较考验标记永久化思维的一道题目。

首先可重集什么的不用去考虑，我们只处理最大值所以用堆就可以了。

我们考虑开一棵线段树，上面的每一个结点上都是一个 **大根堆**，并且同时维护对应区间 **最大值**。

然后我们分别考虑三个操作的实现。

首先先考虑比较简单的区间加 $k$ ，这个我们在修改到的 $\log$ 个区间上把一个 $k$ 元素入堆，注意这里我们采用 **标记永久化** 的思想，表示这个区间内所有结点都加上了一个 $k$ ，然后区间最大值照常维护即可。

然后我们考虑区间 $\max$ ，首先我们要把扫到的 $\log$ 个区间的最大值提出来，求一个 $\max$ ，但是我们由于 **标记永久化** ，有些 **子区间** 内的最大值可能还在其 **父亲区间** 的堆里面没有下传，所以我们扫的时候所有经过的结点都需要与堆顶取一个 $\max$ 。

最后是区间撤销，首先我们显然要求一遍区间 $\max$ ，然后就是撤销。

不难发现我们线段树中元素个数为 $O(m\log n)$ 级别，故我们只要能快速找到我们需要撤销的所有元素，我们的均摊复杂度就能正确。那么我们继续在线段树上扫，如果发现一段区间的最大值比整体最大值小了我们就退出，不难发现这样一来我们找到每一个需要撤销的元素的时间复杂度都是 $O(\log n)$ ，所以均摊 $O(m\log^2n)$ 。

但是，这里还涉及到一个标记下传的问题，因为对于一个我们永久化后的标记，我们可能只会对其 **部分撤销** ，因此这个标记失效的同时我们还需要保持其 **部分有效** 。不过这个也不难处理，我们遇到一个需要撤销的 **永久化标记** 之后可以分两类讨论，如果这个区间要被完全撤销，那么我们直接弹堆就行了，但是如果这个区间被部分撤销，我们弹出堆顶，并把这个标记同时下传到两个子儿子中再递归。

不难发现这样增加的节点个数还是 $\log n$ 级别的，故上面的复杂度分析依然成立。

由于 $n, m$ 同阶，最终复杂度 $O(n\log^2n)$ ，比较容易实现。

## 代码
```cpp
//王者の鼓动、今ここに列を成す！天地鸣动の力を见るがいい！シンクロ召唤！我が魂、レッド·デーモンズ·ドラゴン！
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <queue>
#define rep(i,s,t) for(int i=(s);i<=(t);++i)
#define per(i,t,s) for(int i=(t);i>=(s);--i)
#define REP(i,l,r) for(int i=(l);i<(r);++i)
#define PER(i,l,r) for(int i=(l);i>(r);--i)
#define elif else if
#define gup(x) return puts(#x), 0
//省略了不重要的东西
typedef long long LL;
#define INF 0x3f3f3f3f
#define INFll 0x3f3f3f3f3f3f3f3fll
//明镜止水之心
typedef std :: priority_queue <int> hp;
int n, m;
#define MAXN 200005
hp t[MAXN << 2];
int s[MAXN << 2];
#define LSON rt << 1, l, mid
#define RSON rt << 1 | 1, mid + 1, r
inline void pushup(int rt){s[rt] = mx(t[rt].empty()? -1 : t[rt].top(), mx(s[rt << 1], s[rt << 1 | 1]));}
inline void change(int rt, int z){t[rt].push(z);chmax(s[rt], z);}
void assign(int rt, int l, int r, int x, int y, int z){
    if(x <= l && r <= y) return change(rt, z);
    int mid = (l + r) >> 1;
    if(x <= mid) assign(LSON, x, y, z);
    if(y > mid) assign(RSON, x, y, z);
    pushup(rt);
}
int res = -1;
void query(int rt, int l, int r, int x, int y){
    if(x <= l && r <= y) return chmax(res, s[rt]);
    chmax(res, t[rt].empty()? -1 : t[rt].top());
    int mid = (l + r) >> 1;
    if(x <= mid) query(LSON, x, y);
    if(y > mid) query(RSON, x, y);
}
void resume(int rt, int l, int r, int x, int y, int z){
    if(s[rt] < z) return;
    if(x <= l && r <= y){
        if(!t[rt].empty() && t[rt].top() == z) {t[rt].pop();return pushup(rt);}
        int mid = (l + r) >> 1;
        resume(LSON, x, y, z);resume(RSON, x, y, z);
        return pushup(rt);
    }
    if(!t[rt].empty() && t[rt].top() == z){t[rt].pop();change(rt << 1, z);change(rt << 1 | 1, z);}
    int mid = (l + r) >> 1;
    if(x <= mid) resume(LSON, x, y, z);
    if(y > mid) resume(RSON, x, y, z);
    pushup(rt);
}
int main(){
    memset(s, -1, sizeof(s));
    read(n, m);
    while(m --){
        int opt, l, r;read(opt, l, r);
        if(opt == 1) assign(1, 1, n, l, r, read());
        elif(opt == 2) {
            res = -1;query(1, 1, n, l, r);
            if(~res) resume(1, 1, n, l, r, res);
        }
        else {
            res = -1;query(1, 1, n, l, r);
            print(res);
        }
    }
}
```

---

## 作者：WeLikeStudying (赞：6)

- 希望自主思考。
- 希望全力以赴。
- 希望不留遗憾。

**题意**
- [题意](https://www.luogu.com.cn/problem/P7476)。
- 维护 $n$ 个可重集 $A_1,A_2,\cdots A_n$。
- 支持三个操作：
- 给下标在 $[l,r]$ 间的集合加入元素 $k$。
- 查询下标属于 $[l,r]$ 间任何一个集合的最大值。
- 删除下标属于 $[l,r]$ 间任何一个集合的最大值（一个集合最多只删除一个）。

**分析**
- 感觉好像用线段树套堆可以搞，但是问题是我们要维护哪些信息，而且怎么样让聚合复杂度和空间过得去。
- 这是好想的，只要我们把一次区间加变成最多 $O(\log n)$ 次堆中的元素加入，这可以通过线段树本身的结构来实现，然后我们需要：
- $O(\log n)$ 左右的复杂度找到区间的最大值。（所有堆的最大值）
- 快速精确有效地删除部分堆中的元素并更新信息。（这部分的复杂度显然是由插入操作保证的，如果你让插入的元素不多那么删除的元素肯定也不多）
- 想到这里感觉自信满满啊！吼啊！这肯定是正确思路导向的对吧！那么我们赶快想怎么实现吧。

**实现**
- 我们开一棵线段树，上面的每个节点维护一个堆表示堆在该区间插入的数，整个区间内部（不考虑跨过这个大区间）的最大值。
- 如果是区间加，那么暴力加，复杂度是 $O(\log^2n)$ 的，因为要对 $O(\log n)$ 个区间进行操作。
- 如果是区间查询，那么暴力查询，复杂度是 $O(\log n)$ 的，注意标记不下传的影响。
- 最后是最麻烦的区间删除操作，我们先查询这个区间的最大值，然后暴力遍历区间直到出现以下两种情况的一种：
- 该区间的最大值小于我们要删除的值，这样直接不管它就好了。
- 该区间节点（注意不是整个区间）的最大值大于等于我们要删除的值：这个时候可能会出现两种情况，一种是该区间节点恰好被查询区间完整覆盖（这个直接暴力删除就好了），另一种是该区间节点不被查询区间完整覆盖，这个时候我们仍然选择暴力删除，但是需要在没有覆盖的区间上搞一个区间加操作。
- 这一部分看似很暴力，但正如我们之前所说的 _如果你让插入的元素不多那么删除的元素肯定也不多_ 。实际上你真的可以分析一下，假设操作删除 $k$ 个元素，那么复杂度是 $O(k\log^2 n)$ 级别，但是算上插入操作每次带来的 $O(\log n)$ 个元素，和删除操作每次带来的 $O(\log n)$ 个新元素（因为每次删除带来的只有 $O(\log n)$ 个段），所以总的段数是 $O((n+q)\log n)$，这个操作的复杂度显然不超过 $O((n+q)\log^2n)$。
- 所以所有操作总的复杂度是 $O((n+q)\log^2n)$，当然，不难看出常数挺大的，[代码实现](https://www.luogu.com.cn/paste/g3ealgcp)。

---

## 作者：Harry27182 (赞：6)

[题意](https://www.luogu.com.cn/problem/P7476)

首先我们可以发现所有的操作只与最大值有关，所以可以考虑用堆来实现。然后注意到操作都是区间操作，可以自然地想到线段树，于是我们就有了一个大体的框架：线段树维护区间最大值套大根堆。

我们设线段树上的节点表示它所对应的区间的最大值，每个节点对应的堆表示能够覆盖这个节点的元素的集合。

但是，如果有区间修改操作，每个节点的堆就需要改变，同时会影响到子节点的堆，这时候堆就相当于懒标记，需要下传。但是，我们显然不能每次 ```pushdown``` 一个堆，时间复杂度会慢，所以需要考虑标记永久化。

1. 对于插入操作，我们考虑线段树维护区间最大值的区间修改操作，如果当前的区间被操作区间完全覆盖，我们就用当前的值更新线段树节点信息，然后在对应节点的堆中加入当前的值即可，否则就向两边递归，然后 ```pushup``` 一下就行了。

2. 对于查询操作，直接线段树区间查询最大值，注意查询的时候对于堆顶元素一路取 $\max$ 即可。

3. 对于最复杂的删除操作，我们考虑先查询出这一段区间的最大值 ```maxn```，再把每个位置的这个数删除。我们考虑如果当前区间的最大值小于 ```maxn```,直接 ```return``` 就行了，因为肯定下面没有大于 ```maxn``` 的元素。如果当前堆顶元素恰好为 ```maxn```，我们直接把它删掉，但是有可能会出现下面这种情况：询问区间并不完全包含当前区间，这样就会出现误删的情况，所以我们需要把这些误删的加回去。操作完可以直接 ```return``` ，因为只需要删除一个最大的，所以后面即使有最大的也不需要被删除了。如果上述情况都不满足，直接向下递归即可。

时间复杂度看起来很暴力，但是是玄学的 $O(n\log^2n)$，具体证明可以参考其他题解。

如果不太能理解文字描述可以看看这个有注释的代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
priority_queue<int>q[800005];//覆盖每段区间的值的集合
int tr[800005],n,m,op,l,r,x;
void pushup(int k)
{
    tr[k]=max(tr[k<<1],tr[k<<1|1]);//递归儿子信息
    if(!q[k].empty())tr[k]=max(tr[k],q[k].top());//一路取max，与自己信息合并
}
void build(int k,int l,int r)
{
	if(l==r){tr[k]=-1;return;}
	int mid=(l+r)>>1;
	build(k<<1,l,mid);
	build(k<<1|1,mid+1,r);
	pushup(k);
}//建树
void change(int k,int l,int r,int x,int y,int v)
{
	if(x<=l&&r<=y)
	{
		tr[k]=max(tr[k],v);
		q[k].push(v);//如果已经包含这一段，那么可以直接加进堆中
		return;
	} 
	int mid=(l+r)>>1;
	if(x<=mid)change(k<<1,l,mid,x,y,v);
	if(y>mid)change(k<<1|1,mid+1,r,x,y,v);
	pushup(k);
}
int query(int k,int l,int r,int x,int y)
{
	if(x<=l&&r<=y)return tr[k];
	int mid=(l+r)>>1,res=-1;
	if(x<=mid)res=max(res,query(k<<1,l,mid,x,y));
	if(y>mid)res=max(res,query(k<<1|1,mid+1,r,x,y));//递归左右儿子最大值
	if(!q[k].empty())res=max(res,q[k].top());//与自己的最值合并
	return res; 
}
void erase(int k,int l,int r,int x,int y,int v)
{
	if(tr[k]<v)return;//这一段显然没有最大值了，可以直接return
	if(!q[k].empty()&&q[k].top()==v)//这一段是取到最大值的地方
	{
		q[k].pop();//删除
		if(l<x)change(k,l,r,l,x-1,v);
		if(y<r)change(k,l,r,y+1,r,v);//消除误删的影响
		if(l<r)pushup(k);
		else tr[k]=q[k].empty()?-1:q[k].top();//回溯儿子信息
		return;
	}
	int mid=(l+r)>>1;
	if(x<=mid)erase(k<<1,l,mid,x,y,v);
	if(y>mid)erase(k<<1|1,mid+1,r,x,y,v);//递归
	pushup(k);
}
int main()
{
	scanf("%d%d",&n,&m);
	build(1,1,n); 
	while(m--)
	{
		scanf("%d%d%d",&op,&l,&r);
		if(op==1)
		{
			scanf("%d",&x);
			change(1,1,n,l,r,x);
		}
		else if(op==2)
		{
			x=query(1,1,n,l,r);
			if(x!=-1)erase(1,1,n,l,r,x);
		}
		else printf("%d\n",query(1,1,n,l,r));
	}
	return 0;
}


---

## 作者：Noir_ (赞：3)

# P7476 「C.E.L.U-02」苦涩

#### 题目大意：

有n个可重集合，初始为空；将执行 $m$ 次操作；

操作有 $3$ 种：

1. 往 $l$ 到 $r$ 的集合中加入一个元素 $k$

2. 删除 $l$ 到 $r$ 集合中**最大的元素**，若该集合内有多个最大元素，则只删除一个，若 $l$ 到 $r$ 集合都无元素，则无视

3. 查询 $l$ 到 $r$ 集合中最大的元素，若 $l$ 到 $r$ 集合都无元素，则输出 $-1$

要求输出所有查询操作的答案。

##### 算法一：暴力修改查询

维护 $n$ 个 $multiset$ ，每次操作遍历 $l$ 到 $r$ 的集合，暴力修改+查询。

时间复杂度：$O(nm)$，期望得分：$10pts$

##### 算法二：特殊性质A

对于 $subtask2$ 来说，问题变成了区间赋较大值以及区间查最大值。

线段树维护区间最大，时间复杂度：$O(n\log{n})$，期望得分：$20pts$

##### 算法三：特殊性质B法一

对于 $subtask3,5$ 来说，原先的区间删最大变成了单点删最大。

考虑分块，在每个块和点中维护一个大根堆，记录块内最大值。

删除时找到区间内最大的块，遍历块内单点，比较单点中的堆的堆顶和块中的堆的堆顶，

若单点中的更大，那么直接删除，更新单点和块内的最大值；

否则，删除后将块内每个堆都加上这个点的堆，无需更新最大值。

时间复杂度：$O(n\sqrt{n}\log{n})$，期望得分：$30pts$

##### 算法四：特殊性质B法二

有了大根堆的想法，那么我们可以在线段树的最底层节点处维护大根堆，并记录最大值

每次删除，一直搜到底，$O(\log{n})$ 修改加上堆的 $O(\log{n})$ 就是 $O(\log^2{n})$

时间复杂度：$O(n\log^2{n})$，期望得分：$30pts$

##### 算法五：线段树+堆

考虑在算法四的基础上加上 $pushdown$ 操作；

在每个线段树节点都维护堆，父亲节点记录每次更改操作的值；

查询时就 $pushdown$ 下来，删除时也直接在父亲节点的堆里面删除即可；

时间复杂度：$O(n\log^2{n})$，期望得分：$60$~$100pts$

##### 算法六：标记永久化

有了算法五 $pushdown$ 操作的引入，可以想到标记永久化。

在下放修改操作时，用 $\log{n}$ 的复杂度递归下放，删除同理，加上深度复杂度 $O(\log^2{n})$

时间复杂度：$O((n+m)\log^2{n})$，期望得分：$100pts$

### code

```cpp
#include<bits/stdc++.h>
#define N 200005
#define inf 0x3f3f3f3f
#define endl '\n'
#define lc (p<<1)
#define rc (p<<1|1)
#define debug cerr<<__LINE__<<endl
using namespace std;
int n,m,tmp;
struct node{
	int maxn;priority_queue<int>q;
	inline void init(){q.emplace(maxn=-1);}//堆和最大值直接初始为-1，查询时就不需要特判了
}t[N<<2];
inline char gc(){
	static const int L=1<<22|1;static char c[L],*a,*b;
	return (a==b)&&(b=(a=c)+fread(c,1,L,stdin),a==b)?-1:*a++;
}
inline int read(){
	register int f=1,k=0;
	register char c=gc();
	while(c!='-'&&(c<'0'||c>'9')) c=gc();
	if(c=='-') f=-1,c=gc();
	while(c>='0'&&c<='9') k=(k<<3)+(k<<1)+(c^48),c=gc();
	return f*k;
}
inline void write(register int x){
    if(x<0) x=-x,putchar('-');
	if(x>9) write(x/10);
	putchar((x%10)|48);
}
inline void build(const int p,const int l,const int r){
	t[p].init();if(l==r) return;
	const register int mid=((l+r)>>1);
	build(lc,l,mid);build(rc,mid+1,r);
}
inline void pushnow(const int p,const int k){t[p].q.emplace(k),t[p].maxn=max(t[p].maxn,k);}//修改当前节点
inline void pushup(const int p){t[p].maxn=max(max(t[lc].maxn,t[rc].maxn),t[p].q.top());}//向上传递最大值
inline void pushdown(const int p,const int l,const int r,const int x,const int y,const int k){
	if(x<=l&&r<=y) return;//只修改覆盖范围在x到y之外的节点
	const register int mid=((l+r)>>1);
	if(x>mid) pushnow(lc,k),pushdown(rc,mid+1,r,x,y,k);//若当前区间覆盖范围在目标区间左侧，那么修改左区间，继续向右区间搜索
	else if(y<=mid) pushnow(rc,k),pushdown(lc,l,mid,x,y,k);//同上
	else pushdown(lc,l,mid,x,y,k),pushdown(rc,mid+1,r,x,y,k);//两边都有就都搜
	return pushup(p);//回溯
}
inline void update(const int p,const int l,const int r,const int x,const int y,const int k){
	if(x<=l&&r<=y) return pushnow(p,k);//找到合法区间就改
	const register int mid=((l+r)>>1);
	if(x<=mid) update(lc,l,mid,x,y,k);
	if(y>mid) update(rc,mid+1,r,x,y,k);
	return pushup(p);
}
inline void delet(const int p,const int l,const int r,const int x,const int y,const int k){
	if(x<=l&&r<=y) if(t[p].maxn<k) return;//剪去无用搜索
	if(t[p].q.top()==k){//要删除的元素在这个区间内
		t[p].q.pop();//更新
		pushdown(p,l,r,x,y,k);//在这个区间内继续搜
		return l==r?void(t[p].maxn=t[p].q.top()):pushup(p);//更新最底部的点，回溯
	}
	const register int mid=((l+r)>>1);
	if(x<=mid) delet(lc,l,mid,x,y,k);
	if(y>mid) delet(rc,mid+1,r,x,y,k);
	return pushup(p);
}
inline int query(const int p,const int l,const int r,const int x,const int y){
	if(x<=l&&r<=y) return t[p].maxn;
	const register int mid=((l+r)>>1);
	register int ans=t[p].q.top();
	if(x<=mid) ans=max(ans,query(lc,l,mid,x,y));
	if(y>mid) ans=max(ans,query(rc,mid+1,r,x,y));
	return ans;
}
main(void){
    n=read();m=read();
	t[0].init();build(1,1,n);
	while(m--){
		const register int op=read(),x=read(),y=read();
		if(op==1) update(1,1,n,x,y,read());
		else if(op==2) ~(tmp=query(1,1,n,x,y))?delet(1,1,n,x,y,tmp):void();
		else if(op==3) write(query(1,1,n,x,y)),putchar('\n');
	}
    return 0;
}
```

---

## 作者：Purslane (赞：2)

# Solution

这几天感觉魂不守舍，一直想不出失去了什么。

然后发现三天没写题解了！所以来写一篇。

本题用大量的**区间修改**以及集合最大值操作。因此考虑使用线段树 + 平衡树实现。

我们建立一个线段树，线段树每个节点上维护**所有完全覆盖这个区间的操作 $1$ 的 $k$ 构成的集合**，并且维护其所有子孙节点的**集合**中所有数的最大值。

对于操作 $1$，我们只需要和普通的线段树操作一样。

对于操作 $2$，我们也和普通的查询一样，不过一路中访问的节点的最大值都要加入答案。因为它们都可以完全覆盖访问区间。在你的访问区间完全覆盖当前区间而退回的时候不要忘记加上这个区间子孙结点的最大值。

对于操作 $3$，我们首先用操作 $2$ 求出最大值 $mx$。然后考虑把最大值删去。在我们访问的每个区间里面，分情况讨论。

- 如果当前区间的最大值和所有子孙的最大值都要小于 $mx$，显然删不掉，回去。
- 如果当前区间完全覆盖我们要删除的区间。如果当前区间的最大值等于 $mx$，那么我们考虑把这个 $mx$ 删掉。不过你发现，还有一些不在我们要删去区间的位置被删去了，因此我们需要用操作 $1$ 补救。否则，我们往左右两个区间递归。
- 如果当前区间被我么要删除的区间覆盖。如果当前区间的最大值等于 $mx$，直接删掉啥事没有。否则，还是往左右递归。

感觉这个复杂度极其逆天。前两个操作都是 $O(\log^2 n)$ 的树套树基本操作，我们看看第三种操作。我们发现，补救操作 $1$ 最多发生 $O(1)$ 次（换句话说，删除区间左侧的补救和右侧的补救最多各发生一次）。而对于已经被删除区间完全覆盖还往下递归的情况，可以使用势能分析法。你一次操作最多插入 $O(n \log n)$ 个数，而你为了删掉一个数，最多要暴力下传 $O(\log n)$ 次，而每次其实都是 $O(1)$ 的。

所以总的复杂度就是 $O(n \log^2 n)$。

```cpp
#include<bits/stdc++.h>
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=4e5+10;
int n,m,mx[MAXN<<2];
multiset<int> st[MAXN<<2];
#define lson (k<<1)
#define rson (k<<1|1)
#define mid (l+r>>1)
int calc(int k) {
	if(st[k].size()==0) return -1;
	return *(--st[k].end());
}
void insert(int k,int l,int r,int x,int y,int v) {
	if(x<=l&&r<=y) return st[k].insert(v),mx[k]=max(mx[k],v),void();
	if(x<=mid) insert(lson,l,mid,x,y,v);
	if(y>mid) insert(rson,mid+1,r,x,y,v);
	mx[k]=max({mx[lson],mx[rson],calc(k)});
	return ;
}
void del(int k,int l,int r,int x,int y,int v) {
	if(mx[k]<v) return ;
	if(calc(k)==v) {
		st[k].erase(st[k].find(v));
		if(l<x) insert(k,l,r,l,x-1,v);
		if(y<r) insert(k,l,r,y+1,r,v);
		mx[k]=max({mx[lson],mx[rson],calc(k)});
		return ;	
	}
	if(x<=mid) del(lson,l,mid,x,y,v);
	if(y>mid) del(rson,mid+1,r,x,y,v);
	mx[k]=max({mx[lson],mx[rson],calc(k)});
	return ;
}
int query(int k,int l,int r,int x,int y) {
	int ans=calc(k);
	if(x<=l&&r<=y) return max(ans,mx[k]);
	if(y<=mid) return max(ans,query(lson,l,mid,x,y));
	if(x>mid) return max(ans,query(rson,mid+1,r,x,y));
	return max({ans,query(lson,l,mid,x,y),query(rson,mid+1,r,x,y)});
}
int main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	memset(mx,-1,sizeof(mx));
	cin>>n>>m;
	ffor(i,1,m) {
		int op,l,r,v;
		cin>>op>>l>>r;
		if(op==1) cin>>v,insert(1,1,n,l,r,v);	
		if(op==3) {
			v=query(1,1,n,l,r);
			cout<<v<<'\n';
		}
		if(op==2) {
			v=query(1,1,n,l,r);
			if(v!=-1) del(1,1,n,l,r,v);	
		}
	}
	return 0;
}
```

---

## 作者：ACPCWATLEMLE (赞：1)

# 广告
[空间跳跃](https://www.luogu.com.cn/problem/P7476)

[my blog QAQ](https://www.cnblogs.com/yifan0305/p/16560644.html)
# 思路
一共有三个操作，别看他描述得花里胡哨的，其实就是区间加，区间删除，区间查询。

但是，由于区间加的操作，它的叶节点存储的不止有一个数字，而是一个数列，所以他和普通的线段树还不同，它的节点还要再套点其他东西。

那么，我们要套什么呢？

它不是还要查询最大值吗，那我们就套一个堆。

又有问题了，有区间操作，怎么下传懒标？将堆与孩子的堆进行合并——左偏树，想到这里，~~恭喜你，掉坑里了。~~

左偏树合并是将整个堆都合并过去，他又不只有一个孩子，它和一个孩子合并了，那其他孩子呢？~~卖了？买个 10000 元吧~~。所以左偏树不行。

既然传懒标很麻烦，那我们就不穿懒标了呗，这里介绍一个小优化——标记永久化。

什么意思呢，就是标记不下放，永远留在当前位置。

我们用堆来记录懒标，但是本题中标记永久化的不彻底，还有一种情况需要下传懒标，当堆顶元素与要删除的元素相等时，我们要下放懒标记。
# 局部代码
## 定义线段树

```cpp
struct tree {
	int len;// 代表区间长度
	ll maxx;// 代表这个区间的最大值
	priority_queue<ll> q;// 大根堆记录并维护懒标
}t[N << 4];

```
## 建树操作

```cpp
void build(int cur, int l, int r) {// 建树
	t[cur].len = r - l + 1;// 求len
	t[cur].maxx = -1;// 求max
	t[cur].q.push(-1);// -1压堆底
	if(l == r)	return ;// 到达叶子节点
	int mid = (l + r) >> 1;
	build(ls, l, mid);
	build(rs, mid + 1, r);
}

```
这些与普通线段树没什么差异。

接下来就是标记永久化。
## 标记永久化

```cpp
void addlazy(int cur, ll v) {// 永久化懒标记
	t[cur].q.push(v);// 插入懒标记
	t[cur].maxx = t[cur].maxx > v ? t[cur].maxx : v;
	// 将max值与懒标记比大小
}

```
## 更新操作
注意维护！

```cpp
void pushup(int cur) {
	t[cur].maxx = max(max(t[ls].maxx, t[rs].maxx), t[cur].q.top());
	// 将左右孩子的最大值与懒标记的最大值比大小
}

```
## 插入

```cpp
void insert(int cur, int l, int r, int ql, int qr, ll k) {// 插入
	if(ql <= l && r <= qr) {
		addlazy(cur, k);// 永久化标记
		return ;
	}
	int mid = (l + r) >> 1;
	if(ql <= mid)	insert(ls, l, mid, ql, qr, k);
	if(qr > mid)	insert(rs, mid + 1, r, ql, qr, k);
	pushup(cur);// pushup更新
}

```

## 查询
```cpp
ll ask(int cur, int l, int r, int ql, int qr) {// 查询最大苦涩值
	if(ql <= l && r <= qr) {
		return t[cur].maxx;// 返回这个区间的最大苦涩值
	}
	ll ans = t[cur].q.top();// 懒标记的最大值
	int mid = (l + r) >> 1;
	if(ql <= mid)	ans = max(ans, ask(ls, l, mid, ql, qr));
	// 左子树的最大苦涩值
	if(qr > mid)	ans = max(ans, ask(rs, mid + 1, r, ql, qr));
	// 右子树的最大苦涩值
	return ans;
}

```
## 删除
```cpp
void del(int cur, int l, int r, int ql, int qr, ll k) {
	if(ql <= l && r <= qr && t[cur].maxx < k)	return ;
	// 如果这个区间的最大值都比不过k,那就没有要删除的
	if(t[cur].q.top() == k) {// 最大的懒标记与k相等
		t[cur].q.pop();// 弹出
		pushdown(cur, l, r, ql, qr, k);// 下放懒标记
		if(l == r) {// 到达叶子节点,修改最大值
			t[cur].maxx = t[cur].q.top();
			//叶结点的最大值就是懒标最大值
		}
		else	pushup(cur);//更新最大值
		return ;
	}
	int mid = (l + r) >> 1;
	if(ql <= mid)	del(ls, l, mid, ql, qr, k);
	// 在左子树中删除
	if(qr > mid)	del(rs, mid + 1, r, ql, qr, k);
	// 在右子树中删除
	pushup(cur);
}

```
# 完整代码
拿走不谢OVO~
```cpp
#include <iostream>
#include <cstdio>
#include <queue>
#define ls (cur << 1)
#define rs (cur << 1 | 1)
typedef long long ll;
using namespace std;
const int N = 2e5 + 5;
int n, m;

struct tree {
	int len;// 代表区间长度
	ll maxx;// 代表这个区间的最大值
	priority_queue<ll> q;// 大根堆记录并维护懒标
}t[N << 4];

inline ll read() {
	ll x = 0;
	int fg = 0;
	char ch = getchar();
	while(ch < '0' || ch > '9') {
		fg |= (ch == '-');
		ch = getchar();
	}
	while(ch >= '0' && ch <= '9') {
		x = (x << 3) + (x << 1) + (ch ^ 48);
		ch = getchar();
	}
	return fg ? ~x + 1 : x;
}

void build(int cur, int l, int r) {// 建树
	t[cur].len = r - l + 1;// 求len
	t[cur].maxx = -1;// 求max
	t[cur].q.push(-1);// -1压堆底
	if(l == r)	return ;// 到达叶子节点
	int mid = (l + r) >> 1;
	build(ls, l, mid);
	build(rs, mid + 1, r);
}

void addlazy(int cur, ll v) {// 永久化懒标记
	t[cur].q.push(v);// 插入懒标记
	t[cur].maxx = t[cur].maxx > v ? t[cur].maxx : v;
	// 将max值与懒标记比大小
}

void pushup(int cur) {
	t[cur].maxx = max(max(t[ls].maxx, t[rs].maxx), t[cur].q.top());
	// 将左右孩子的最大值与懒标记的最大值比大小
}

void pushdown(int cur, int l, int r, int ql, int qr, ll k) {
// 把懒标记下放到[ql,qr]以外的其他区间中
	if(ql <= l && r <= qr)	return ;// 永久化标记
	int mid = (l + r) >> 1;
	if(ql > mid) {// 全在右子树上
		addlazy(ls, k);// 永久化标记
		pushdown(rs, mid + 1, r, ql, qr, k);// 下放标记
	}
	else {
		if(qr <= mid) {// 全在左子树上
			addlazy(rs, k);// 永久化标记
			pushdown(ls, l, mid, ql, qr, k);// 下放标记
		}
		else {// 跨左右子树
			pushdown(ls, l, mid, ql, qr, k);
			pushdown(rs, mid + 1, r, ql, qr, k);
		}
	}
	pushup(cur);
}

void insert(int cur, int l, int r, int ql, int qr, ll k) {// 插入
	if(ql <= l && r <= qr) {
		addlazy(cur, k);// 永久化标记
		return ;
	}
	int mid = (l + r) >> 1;
	if(ql <= mid)	insert(ls, l, mid, ql, qr, k);
	if(qr > mid)	insert(rs, mid + 1, r, ql, qr, k);
	pushup(cur);// pushup更新
}

void del(int cur, int l, int r, int ql, int qr, ll k) {
	if(ql <= l && r <= qr && t[cur].maxx < k)	return ;
	// 如果这个区间的最大值都比不过k,那就没有要删除的
	if(t[cur].q.top() == k) {// 最大的懒标记与k相等
		t[cur].q.pop();// 弹出
		pushdown(cur, l, r, ql, qr, k);// 下放懒标记
		if(l == r) {// 到达叶子节点,修改最大值
			t[cur].maxx = t[cur].q.top();
			//叶结点的最大值就是懒标最大值
		}
		else	pushup(cur);//更新最大值
		return ;
	}
	int mid = (l + r) >> 1;
	if(ql <= mid)	del(ls, l, mid, ql, qr, k);
	// 在左子树中删除
	if(qr > mid)	del(rs, mid + 1, r, ql, qr, k);
	// 在右子树中删除
	pushup(cur);
}

ll ask(int cur, int l, int r, int ql, int qr) {// 查询最大苦涩值
	if(ql <= l && r <= qr) {
		return t[cur].maxx;// 返回这个区间的最大苦涩值
	}
	ll ans = t[cur].q.top();// 懒标记的最大值
	int mid = (l + r) >> 1;
	if(ql <= mid)	ans = max(ans, ask(ls, l, mid, ql, qr));
	// 左子树的最大苦涩值
	if(qr > mid)	ans = max(ans, ask(rs, mid + 1, r, ql, qr));
	// 右子树的最大苦涩值
	return ans;
}

int main() {
	t[0].maxx = -1;
	t[0].q.push(-1);
	n = read();
	m = read();
	build(1, 1, n);
	for(int i = 1; i <= m; ++i) {
		int op = read();
		int l, r, k;
		if(op == 1) {
			l = read(), r = read(), k = read();
			insert(1, 1, n, l, r, k);// 插入节点
		}
		if(op == 2) {
			l = read(), r = read();
			k = ask(1, 1, n, l, r);// 找最大苦涩值
			if(k != -1)	del(1, 1, n, l, r, k);
			// 如果有最大苦涩值,删除
		}
		if(op == 3) {
			l = read(), r = read();
			printf("%lld\n", ask(1, 1, n, l, r));// 找最大苦涩值
		}
	}
	return 0;
}

```

---

## 作者：wujingfey (赞：1)

# 题意

给 $n$ 个可重集，进行 $m$ 次操作

- 操作 $1$ 向第 $l$ 到 $r$ 的每个集合插入 $k$ 元素。
- 操作 $2$ 查询 $l$ 到 $r$ 的所有元素中最大的元素 $k$，并在这些集合内删除 $k$。
- 操作 $3$ 查询 $l$ 到 $r$ 的所有元素中最大的一个 $k$ 并输出。

-----------

对比线段树模板，只是把单个元素替换成了一个对应的集合。所以考虑怎么把线段树模板魔改一下来解决这道题。

- 我们要求的是元素最大值，所以我用大根堆表示每个集合。
- 每个单点变成了集合，那对应每个节点的信息从数值变成大根堆。

```
struct NODE{
	int l,r,mx;
	priority_queue<int> pq;
}tr[N<<2];
```

- 建树操作基本不变。

```
void build(int p,int l,int r){
	tr[p].l=l, tr[p].r=r, tr[p].mx=-1;
	tr[p].pq.push(-1);
	if(l==r) return;
	int mid=(l+r)>>1;
	build(p<<1,l,mid);
	build(p<<1|1,mid+1,r);
}
```

- 向 $[l,r]$ 的每个集合插入 $k$，和普通线段树差别也不大。
- 注意：节点 $p$ 的集合推入 $k$ 表示 $p$ 包含的所有集合都推入了 $k$。如果 $p$ 内部分集合的 $k$ 被删除了，则需要下传。这个大根堆和懒标记有相似之处。
```
void f(int p,int k){
	tr[p].pq.push(k);
	tr[p].mx=max(tr[p].mx,k);
}
void push_up(int p){
	tr[p].mx=max(tr[p<<1].mx,tr[p<<1|1].mx);//两个字区间各自的最大值 
	tr[p].mx=max(tr[p].mx,tr[p].pq.top());//两个子区间共有元素中最大的 
}
void add(int p,int l,int r,int k){ 
	if(l<=tr[p].l&&tr[p].r<=r){
		f(p,k);	//这个节点所有集合都插入了k
		return;
	}
	int mid=(tr[p].l + tr[p].r)>>1;
	if(l<=mid) add(p<<1,l,r,k);
	if(mid<r) add(p<<1|1,l,r,k);
	push_up(p); //向下更新后pushup
}
```

- 删除操作。和板子线段树差别要大一些，具体看注释罢。

```
void del(int p,int l,int r,int k){
	if(l<=tr[p].l && tr[p].r<=r && tr[p].mx<k) return;//该节点都删不掉 
	if(tr[p].pq.top()==k){//这个节点要被删一部分 
		tr[p].pq.pop();//删除懒标记 
		push_down(p,l,r,k);
		//p节点内集合，可能都把k删了，可能只有部分集合删k 
		//给没被删的区段打上标记 ，下传懒标记 
		if(tr[p].l==tr[p].r) tr[p].mx=tr[p].pq.top();//叶子结点更新mx 
		push_up(p);//下传要更新 
		return;
	}
	int mid=(tr[p].l+tr[p].r)>>1;
	if(l<=mid) del(p<<1,l,r,k);
	if(mid<r) del(p<<1|1,l,r,k);
	push_up(p);
}
```
- push_down 操作

```
void push_down(int p,int l,int r,int k){
	//p节点的k下传 
	//[l,r]的k被删除了，给其他集合打标记 
	if(l<=tr[p].l&&tr[p].r<=r) return;//这个节点所有集合都要删k 
	int mid=(tr[p].l+tr[p].r)>>1;
	if(mid<l){//删除集合都在右侧 
		f(p<<1,k);//左边全部传k
		push_down(p<<1|1,l,r,k);//右边继续 
	}else if(r<=mid){//删除集合都在左侧 
		f(p<<1|1,k);
		push_down(p<<1,l,r,k);//同上 
	}else{//左右都有 
		push_down(p<<1,l,r,k);
		push_down(p<<1|1,l,r,k);
	}
	push_up(p);
}
```
- 查询操作。和普通线段树差不多。注意 $pq.top()$ 和 $mx$ 的区别：$mx$ 随时更新，表示**这些集合所有元素的最大值**，$pq.top()$ 表示**这些集合共有元素的最大值**。
```
int query(int p,int l,int r){
	if(l<=tr[p].l && tr[p].r<=r){
		return tr[p].mx;//p内所有集合都在查询区间内，用mx
	}
  int res=tr[p].pq.top();//p不一定都在查询区间内，mx可能取不到
	int mid=(tr[p].l+tr[p].r)>>1;
	if(l<=mid) res=max(res,query(p<<1,l,r));
	if(mid<r) res=max(res,query(p<<1|1,l,r));
	return res;
}
```

# CODE

```
#include<bits/stdc++.h>
using namespace std;
const int N=2e5+6;
int n,m;
struct NODE{
	int l,r,mx;
	priority_queue<int> pq;
}tr[N<<2];
void f(int p,int k){
	tr[p].pq.push(k);
	tr[p].mx=max(tr[p].mx,k);
}
void push_up(int p){
	tr[p].mx=max(max(tr[p<<1].mx,tr[p<<1|1].mx),tr[p].pq.top());
}
void push_down(int p,int l,int r,int k){
	//p节点的k下传 
	//[l,r]原本都有k，删除p内的k后，给p以外的点打上k 
	if(l<=tr[p].l&&tr[p].r<=r) return;//这个节点被删完了，传不下去 
	int mid=(tr[p].l+tr[p].r)>>1;
	if(mid<l){//删除都在右侧 
		f(p<<1,k);//左边全部传k
		push_down(p<<1|1,l,r,k);//右边继续 
	}else if(r<=mid){//删除都在左侧 
		f(p<<1|1,k);
		push_down(p<<1,l,r,k);//同上 
	}else{//左右都有 
		push_down(p<<1,l,r,k);
		push_down(p<<1|1,l,r,k);
	}
	push_up(p);
}
void build(int p,int l,int r){
	tr[p].l=l, tr[p].r=r, tr[p].mx=-1;
	tr[p].pq.push(-1);
	if(l==r) return;
	int mid=(l+r)>>1;
	build(p<<1,l,mid);
	build(p<<1|1,mid+1,r);
}
void add(int p,int l,int r,int k){ 
	if(l<=tr[p].l&&tr[p].r<=r){
		f(p,k);
		return;
	}
	int mid=(tr[p].l + tr[p].r)>>1;
	if(l<=mid) add(p<<1,l,r,k);
	if(mid<r) add(p<<1|1,l,r,k);
	push_up(p); 
}
void del(int p,int l,int r,int k){
	if(l<=tr[p].l && tr[p].r<=r && tr[p].mx<k) return;//该节点都删不掉 
	if(tr[p].pq.top()==k){//这个节点都可以删 
		tr[p].pq.pop();
		push_down(p,l,r,k);//给没被删的区段打上标记 
		if(tr[p].l==tr[p].r) tr[p].mx=tr[p].pq.top();//叶子结点更新mx 
		else push_up(p);
		return;
	}
	int mid=(tr[p].l+tr[p].r)>>1;
	if(l<=mid) del(p<<1,l,r,k);
	if(mid<r) del(p<<1|1,l,r,k);
	push_up(p);
}
int query(int p,int l,int r){
	if(l<=tr[p].l && tr[p].r<=r){
		return tr[p].mx;//p内所有集合都在查询区间内，用mx
	}
  	int res=tr[p].pq.top();//p不一定都在查询区间内，mx可能取不到
	int mid=(tr[p].l+tr[p].r)>>1;
	if(l<=mid) res=max(res,query(p<<1,l,r));
	if(mid<r) res=max(res,query(p<<1|1,l,r));
	return res;
}
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cin>>n>>m;
	build(1,1,n);
	for(int i=1;i<=m;i++){
		int op,x,y,z;
		cin>>op;
		if(op==1){
			cin>>x>>y>>z;
			add(1,x,y,z);
		}else if(op==2){
			cin>>x>>y;
			z=query(1,x,y);
			if(z==-1) continue;
			del(1,x,y,z);
		}else{
			cin>>x>>y;
			cout<<query(1,x,y)<<'\n';
		}
	}
	return 0;
}
```

---

## 作者：Autream (赞：0)

## 题意简述
维护 $n$ 个可重集，需要支持 $3$ 种操作：
- 区间插入一个数。
- 区间删除最大值，如有重复，只删除一个。
- 区间查询最大值。
## 题目分析
可以先想想 10 pts 的暴力怎么打：对于每一个位置开一个堆，然后在 $[l, r]$ 上直接修改。
区间操作自然而然地就会想到线段树。

开一颗线段树，需要维护最大值，以及每个区间的可重集，其中可重集可以配合大根堆时间区间最大值。

如果没有删除操作这道题就很方便，使用标记永久化，在遍历到每个点时把父亲插入的最大的值传下来。

接下来考虑如何处理删除操作。

显然，我们需要首先求出区间最大值，然后在线段树递归时对于每个满足被删的需求的区间分类讨论（设树上的区间为 $[l, r]$，询问给出的区间为 $[x,y]$）：
- 如果 $[l, r] \subseteq [x, y]$，那么直接弹出对顶，上传最大值即可。
- 否则，区间 $[l, x) \cup (y,r]$ 就会被多删，此时可以调用区间加的函数把多删的加回来。

均摊时间复杂度 $O(n \log ^2 n)$。
## AC Code
```cpp
// Problem: P7476 「C.E.L.U-02」苦涩
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P7476#submit
// Memory Limit: 256 MB
// Time Limit: 2000 ms
// Date: 2024/11/26 15:26:01
// Author: Li_Feiy
#include <bits/stdc++.h>
#define mem(a, x) memset(a, x, sizeof a)
#define CI const int
int read() {
	char ch = getchar();
	int r = 0, w = 1;
	while(ch < '0' || ch > '9') w = ch == '-' ? -1 : w, ch = getchar();
	while(ch >= '0' && ch <= '9') r = (r << 3) + (r << 1) + (ch ^ 48), ch = getchar();
	return r * w;
}

void print(int x) {
	if(x < 0) putchar('-'), x = -x;
	if(x >= 10) print(x / 10);
	putchar(x % 10 + '0');
}template<typename ...Args>
void print(int s, Args... args) { print(s), print(args...); }

void printl(int x) { print(x), putchar('\n'); }
template<typename ...Args>
void printl(int s, Args... args) { printl(s), printl(args...); }

void printk(int x) { print(x), putchar(' '); }
template<typename ...Args>
void printk(int s, Args ... args) { printk(s), printk(args...); }
CI N = 4e5 + 5;
int n, m;
struct Segment_Tree {
#define ls k << 1
#define rs k << 1 | 1
	std::priority_queue<int> s[N << 2];
	int ma[N << 2];
	Segment_Tree() { mem(ma, -1); }
	void pushup(int k) { ma[k] = std::max({ ma[ls], ma[rs], s[k].empty() ? -1 : s[k].top() }); }
	void update_add(int x, int y, int v, int k = 1, int l = 1, int r = n) { // 区间加
		if(y < l || x > r) return ;
		if(x <= l && r <= y) {
			s[k].push(v), ma[k] = std::max(ma[k], v); // 相当于打上一个值为 v 的标记
			return ;
		}
		int mid = l + r >> 1;
		if(x <= mid) update_add(x, y, v, ls, l, mid);
		if(y > mid) update_add(x, y, v, rs, mid + 1, r);
		pushup(k);
	}
	void update_minus(int x, int y, int v, int k = 1, int l = 1, int r = n) {
		if(y < l || x > r || ma[k] < v) return ;
		if(!s[k].empty() && s[k].top() == v) {
			s[k].pop();
			if(l < x) update_add(l, x - 1, v); // 删除多加的部分
			if(r > y) update_add(y + 1, r, v);
			pushup(k);
			return ;
		}
		int mid = l + r >> 1;
		if(x <= mid) update_minus(x, y, v, ls, l, mid);
		if(y > mid) update_minus(x, y, v, rs, mid + 1, r);
		pushup(k);
	}
	int query(int x, int y, int k = 1, int l = 1, int r = n) {
		if(y < l || x > r) return -1;
		if(x <= l && r <= y) return ma[k];
		int mid = l + r >> 1, ans = s[k].empty() ? -1 : s[k].top(); // 标记永久化的标记下传
		if(x <= mid) ans = std::max(ans, query(x, y, ls, l, mid));
		if(y > mid) ans = std::max(ans, query(x, y, rs, mid + 1, r));
		return ans;
	}
#undef ls
#undef rs
} st;
signed main() {
	n = read(), m = read();
    while(m --){
		int op = read(), l = read(), r = read();
        if(op == 1) st.update_add(l, r, read());
        else if(op == 2) {
            int ma = st.query(l, r);
            if(~ma) st.update_minus(l, r, ma);
        } else printl(st.query(l, r));
    }
	return 0;
}
```

---


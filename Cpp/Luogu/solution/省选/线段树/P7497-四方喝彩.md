# 四方喝彩

## 题目背景

>念出他们的名字，让他们，再次回到舞台。

麦克要在月亮河马戏团表演全新的杂技节目了！

## 题目描述

麦克一共有 $n$ 个新节目，每个节目的惊险值为 $a_i$。

接下来麦克可以通过若干次操作来对每个节目的惊险值进行变换：

+ 麦克使用冰球，对于所有的 $l\leq i\leq r$，第 $i$ 个节目的惊险值会增加 $x$。

+ 麦克使用土球，对于所有的 $l\leq i\leq r$，第 $i$ 个节目的惊险值会乘以 $x$。

+ 麦克使用火球，对于所有的 $l\leq i\leq r$，第 $i$ 个节目的惊险值在接下来的 $x$ 个操作中**不会受到冰球和土球的影响**。火球效果**不会被替换**。

当然观众对每个节目的惊险值也很好奇，所以你需要在操作过程中帮麦克回答对于所有 $l\leq i\leq r$，第 $i$ 个节目的惊险值之和。当然观众不希望惊险值过大，所以你需要将结果对 $10^9+7$ 取模。

------------
#### 简要题意：

给你一个长度为 $n$ 的数组 $a$，你需要支持如下几个操作：

1. `l r x`：对所有 $l\leq i\leq r$，令 $a_i$ 增加 $x$。
2. `l r x`：对所有 $l\leq i\leq r$，令 $a_i$ 乘上 $x$。
3. `l r x`：对所有 $l\leq i\leq r$，在接下来的 $x$ 个操作内，$a_i$ 将会被封锁，**不会受到操作 1 和操作 2 的影响**（设本次操作为第 $k$ 次操作，则第 $k+1,k+2,\cdots,k+x$ 次操作中的所有操作 1和操作 2 不会对区间 $\left[l,r\right]$ 产生影响）。已有的封锁效果**不会被替换**（即假设第 $3$ 次有一个操作 3 对某个位置进行封锁，封锁时间为 $5$，第 $5$ 次操作同样对这个位置进行封锁，封锁时间为 $2$ 那么实际上这个位置在第 $4$ 次操作到第 $8$ 次操作的时间内都会被封锁）（感性理解就是后面时间短的封锁不会使前面时间长的封锁失效）。
4. `l r`：询问 $\sum\limits_{l\leq i\leq r}a_i$，对 $10^9+7$ 取模。

## 说明/提示

#### 样例一解释
一开始数组为 $\{1,5,4,3,6\}$。

+ 执行第 $1$ 次操作，此时数组变为 $\{1,8,7,6,6\}$。
+ 执行第 $2$ 次操作，此时数组不变。
+ 执行第 $3$ 次操作，询问结果为 $27$。
+ 执行第 $4$ 次操作，因为此时 $a_2$ 在第 $2$ 次操作中被封锁还未解除，所以这次操作只对 $a_3$ 产生影响，数组变为 $\{1,8,28,6,6\}$。
+ 执行第 $5$ 次操作，询问结果为 $37$。

------------
#### 数据范围

**本题采用捆绑测试**。

+ Subtask 1 ( $25\%$ )：$n,m\leq2\times10^3$。
+ Subtask 2 ( $8\%$ )：没有操作 3。
+ Subtask 3 ( $17\%$ )：对于所有操作 4，保证 $l=r$。
+ Subtask 4 ( $50\%$ )：无特殊限制。

对于所有数据，$1\leq n,m\leq 2\times 10^5,0\leq a_i<10^9+7,1\leq l\leq r\leq n$，对于所有操作 1 和操作 2，保证 $0\leq x<10^9+7$，对于所有操作 3，设其为第 $k$ 次操作，保证 $0\leq x\leq m-k$。

## 样例 #1

### 输入

```
5 5
1 5 4 3 6
1 2 4 3
3 1 2 2
4 2 5
2 2 3 4
4 1 3```

### 输出

```
27
37```

## 样例 #2

### 输入

```
10 12
4 2 1 5 10 3 2 4 6 7
2 3 7 4
1 2 9 5
3 2 4 5
3 4 7 2
4 3 9
1 1 8 2
2 4 5 2
3 6 8 2
4 2 3
1 2 10 6
2 7 9 3
4 1 10```

### 输出

```
129
16
314```

# 题解

## 作者：Moon_Night (赞：8)

## [题目戳这里](https://www.luogu.com.cn/problem/P7497)

本篇题解会详细讲解本题的**思考过程**，虽然并不是新方法，但是**讲解详细**，请耐心食用。

这道题需要用用线段树实现 `区间加` , `区间乘` ，`区间和的查询` ，以及 `锁定区间（忽略其某时间范围内的修改）`。与模板有区别的地方只有最后一个功能，也就是 ```操作3``` 。我们很容易想到，线段树多维护一个封锁结束的时间，然后在修改时候判断封锁是否结束。于是我们有了：
# 错误解法--多维护一个封锁时间
（赶时间请**跳过此部分**）

我们考虑在线段树中维护一个封锁结束时间，然后这道题就变得非常简单（小看了这道题），只需在下传懒标记/修改时判断节点是否解封，决定是否进行操作。于是：

我在修改操作的```if(x<=l&&r<=y)```中添加了以下代码：
```cpp
if(tim<=block[root]) return;
// tim 为现在的时间 block[i] 为 i 节点结束封锁时间
```
在判断是否进行```pushdown```时，我们需要分类：

1. 未封锁的父亲，已封锁的儿子。此时显然不需要```pushdown```，在封锁前，就把父亲需要传给儿子的下传完了，现在父亲的懒标记里是封锁后的操作，所以不需要```pushdown```。
2. 已封锁的父亲，已封锁的儿子。此时可以```pushdown```，在封锁后，所有不应下传的都没有下传到父亲，所以父亲能传给儿子的只有封锁前的懒标记
3. 其余情况无需下传。

于是有以下代码：
```cpp
// add 为加法懒标记，times 为乘法懒标记
// block 为封锁时间
void pushdown(ll root,ll l,ll r,ll tim){
	block[ls]=max(block[ls],block[root]);
    block[rs]=max(block[rs],block[root]);
    if(block[ls]<tim||(block[root]>=tim)){
        (tree[ls]*=times[root])%=P;
        (tree[ls]+=add[root]*(mid-l+1)%P)%=P;
        (add[ls]*=times[root])%=P;
        (add[ls]+=add[root])%=P;
        (times[ls]*=times[root])%=P;
    }
    if(block[rs]<tim||(block[root]>=tim)){
        (tree[rs]*=times[root])%=P;
        (tree[rs]+=add[root]*(r-mid)%P)%=P;
        (add[rs]*=times[root])%=P;
        (add[rs]+=add[root])%=P;
        (times[rs]*=times[root])%=P;
    }
    add[root]=0; times[root]=1;
    return;
}
```
看起来十分合理，然后我们再简单地维护一下```block[i]```
```cpp
void update_block(ll root,ll l,ll r,ll x,ll y,ll tim,ll z){
    if(l>r) return;
    if(x<=l&&r<=y){
        block[root]=max(block[root],z);
		return;
    }
    pushdown(root,l,r,tim);
    if(x<=mid) update_block(ls,l,mid,x,y,tim,z);
    if(y>mid) update_block(rs,mid+1,r,x,y,tim,z);
    return;
}
```
然后我们高高兴兴地跑样例，然后大悲！样例二怎么 $\textcolor{red}{WA}$ 了？！

交上去：
![](https://cdn.luogu.com.cn/upload/image_hosting/t17vw2lj.png)
为什么？！
我们冷静思考，惊恐的发现：如果在节点 ```i``` 解封前,父节点被修改，但懒标记未下传，在解封后，父节点将懒标记传给节点 ```i``` ，那么 ```i``` 就成功地在封锁的时间被修改了！除了这个问题，还有很多问题。如： ```当一个区间有一部分被修改时，区间加加的还是r-l+1个吗？我们又要多维护一个值。``` 那么继续修改就会像打补丁一样，十分困难，这里改完那里有问题，因为我们小看了这道题。于是，我们的尝试宣告失败。

# 正确解法--拆分封锁与解封操作

那么我们怎么处理 ```封锁区间呢``` ？我们认真思考~~或参考题解~~，得到了另一个方法：将这个操作变成两个操作，```封锁``` + ```解封``` 。我们来思考一下细节。

考虑一次区间加（```[l,r]+=z```）：
>这个整区间里若有一部分还在封锁中，那么就不能将区间直接 ```+=z*（r-l+1）``` , 而是```+=未封锁元素个数*z``` 于是，我们再维护一个未封锁元素个数。

考虑一次区间乘（```[l,r]*=z```）:
>这个整区间里若有一部分还在封锁中，那么就不能直接```*=z```，而是只把未封锁的部分```*=z```，而为了复杂度，我们不可能现场统计未封锁元素的和，于是我们决定分开维护```封锁部分的区间和```，```未封锁部分的区间和```。

然后，考虑多个封锁操作重叠：
>我们不是很愿意将封锁操作合并，这很麻烦，于是就直接将多个封锁叠加，等到没有一个封锁才继续下传操作。所以维护的 ```封锁情况``` 不应该是 ```0/1``` 而是 ```--/++```。

至此，我们要维护的所有东西如下：
```cpp
struct segment{ 
    ll one,two,len,add,times,block; 
    /*
    one 代表未封锁的和
    two 代表封锁区域的和
    len 代表未封锁元素个数
    add 为加法懒标记     times为乘法懒标记
    block 为目前被封锁次数
    */
};

```
想自己尝试的同志可以先自己去写代码了。

接下来，配合代码食用，详细的注释与~~有些晦涩难懂的~~代码结合，比口述好理解得多。

```cpp
#include<iostream>
#include<cmath>
#include<cstring>
#include<algorithm>
#include<vector>
#define ls (2*root)
#define rs (2*root+1)
#define mid (l+((r-l)>>1))

using std::cin; using std::cout;
using std::max; using std::swap;
using std::vector; typedef long long ll;
const ll N=2e5+5,P=1e9+7;

struct Block{ ll l,r; }; // 封锁的区间

ll n,m,a[N];  
vector<Block> que[N]; // que[i]保存在 i 时刻，需要解封的区间

struct segment{ 
    ll one,two,len,add,times,block; 
    /*
    one 代表未封锁的和
    two 代表封锁区域的和
    len 代表未封锁元素个数
    add 为加法懒标记     times为乘法懒标记
    block 为目前被封锁次数
    */
};
struct Segment_Tree{
    segment tr[4*N];
    void pushdown(ll root){ // 下传懒标记
        if(tr[ls].block==0){ // 若整个区间被封锁，不能下传懒标记
            tr[ls].one=(tr[ls].one*tr[root].times%P+tr[root].add*tr[ls].len%P)%P;
            tr[ls].add=(tr[ls].add*tr[root].times%P+tr[root].add)%P;
            tr[ls].times=(tr[ls].times*tr[root].times)%P;
        }
        if(tr[rs].block==0){
            tr[rs].one=(tr[rs].one*tr[root].times%P+tr[root].add*tr[rs].len%P)%P;
            tr[rs].add=(tr[rs].add*tr[root].times%P+tr[root].add)%P;
            tr[rs].times=(tr[rs].times*tr[root].times)%P;
        }
        tr[root].add=0,tr[root].times=1;
        return;
    }
    void pushup(ll root){ // 子节点更新父亲
        if(tr[root].block==0){ // 若整个区间被封锁，那么子节点的one没有被修改，不能更新父亲
            tr[root].one=(tr[ls].one+tr[rs].one)%P;
            tr[root].two=(tr[ls].two+tr[rs].two)%P;
            tr[root].len=tr[ls].len+tr[rs].len;
        }// 不过在add等函数中，tr[root].block>0已经return了
        return;
    }
    void build(ll root,ll l,ll r){  // 初始化
        if(l>r) return; 
        tr[root].times=1; // 不要忘了把乘法懒标记初始化
        if(l==r){
            tr[root].one=a[l]%P;
            tr[root].len=1; // 一定不要忘初始未封锁元素个数
            return;
        }
        build(ls,l,mid); build(rs,mid+1,r);
        pushup(root);
        return;
    }
    void add(ll root,ll l,ll r,ll x,ll y,ll z){ // 区间加
        if(l>r||tr[root].block) return;
        if(x<=l&&r<=y){
            tr[root].one=(tr[root].one+tr[root].len*z%P)%P;
            tr[root].add=(tr[root].add+z)%P;
            return;
        } pushdown(root);
        if(x<=mid) add(ls,l,mid,x,y,z);
        if(y>mid) add(rs,mid+1,r,x,y,z);
        return pushup(root);
    }
    void times(ll root,ll l,ll r,ll x,ll y,ll z){ // 区间乘
        if(l>r||tr[root].block) return;
        if(x<=l&&r<=y){
            tr[root].one=(tr[root].one*z)%P;
            tr[root].add=(tr[root].add*z)%P;
            tr[root].times=(tr[root].times*z)%P;
            return;
        } pushdown(root);
        if(x<=mid) times(ls,l,mid,x,y,z);
        if(y>mid) times(rs,mid+1,r,x,y,z);
        return pushup(root);
    }
    void block(ll root,ll l,ll r,ll x,ll y){ // 封锁区间
        if(l>r) return;
        if(x<=l&&r<=y){
            if(l!=r) pushdown(root);
            if(tr[root].block==0){ // 第一次封锁
                tr[root].two=(tr[root].two+tr[root].one)%P;  tr[root].one=0;
                // 封锁整个区间，所以把所有和记到two里，one清零
                tr[root].len=0; // 解锁元素个数为零了          
            }
            ++tr[root].block; // 封锁次数+1，后面解锁时不要改回零，而是-1
            return;
        } pushdown(root);
        if(x<=mid) block(ls,l,mid,x,y);
        if(y>mid) block(rs,mid+1,r,x,y);
        return pushup(root);
    }
    void deblock(ll root,ll l,ll r,ll x,ll y){ //解封区间
        if(l>r) return;
        if(x<=l&&r<=y){
            --tr[root].block;  // 呼应上文++，解除一重封锁
            if(tr[root].block==0){ // 若已经全部解封
                if(l==r) swap(tr[root].one,tr[root].two),tr[root].len=1; // 由于整体解封，原来未解封的变成解封的，没有未解封的元素，因为这里是叶节点所以len=1
                else pushup(root); // 若不是叶节点接受子节点信息即可
            }
            return;
        } pushdown(root);
        if(x<=mid) deblock(ls,l,mid,x,y);
        if(y>mid) deblock(rs,mid+1,r,x,y);
        return pushup(root);
    }
    ll inque(ll root,ll l,ll r,ll x,ll y){ //询问，函数名有点奇怪，但是我习惯了
        if(l>r) return 0;
        if(x<=l&&r<=y) return (tr[root].one+tr[root].two)%P; // 询问整个区间的和，自然包括解封的和未解封的
        pushdown(root); ll ret=0;
        if(x<=mid) ret=inque(ls,l,mid,x,y)%P;
        if(y>mid) ret=(ret+inque(rs,mid+1,r,x,y))%P;
        return ret;
    }
} tree;

int main(){
    std::ios::sync_with_stdio(0); 
    cin>>n>>m; for(ll i=1;i<=n;cin>>a[i],++i);  // 码风较奇怪……
    tree.build(1,1,n);
    for(ll i=1,type,l,r,x;i<=m;++i){
        cin>>type>>l>>r;
        if(type==4){
            cout<<tree.inque(1,1,n,l,r)<<"\n";
            for(Block &j:que[i]) tree.deblock(1,1,n,j.l,j.r); // continue 前，一定要把操作做完啊啊啊，卡了我好久
            continue;
        }  cin>>x;
        if(type==1) tree.add(1,1,n,l,r,x);
        else if(type==2) tree.times(1,1,n,l,r,x);
        else{
            tree.block(1,1,n,l,r);
            que[i+x].push_back({l,r}); // 记录每一次解封操作
        }
        for(Block &j:que[i]) tree.deblock(1,1,n,j.l,j.r); // 于所有操作之后解封，因为 i+x 时刻也是被封锁的
    }
    return 0;
}

```
然后，就结束了。。感谢看到这里，不喜勿喷。

这道题是一道很有趣的题，希望大家，学习愉快。。。。

其余参考 [$littleKtian$](https://www.luogu.com.cn/user/104581) 巨佬的[题解](https://www.luogu.com.cn/blog/Ktian/show-ti-xie) 

---

## 作者：littleKtian (赞：7)

实际上除了封锁操作以外都是[模板题](https://www.luogu.com.cn/problem/P3373)的内容，所以我们直接考虑如何处理操作 3。

考虑将所有的封锁操作拆成两个操作（第 $k$ 次的封锁操作以及第 $k+x$ 次操作后的解除封锁操作）。同时对于线段树的每个节点，我们将原来的维护区间和改为维护区间内**所有未封锁位置的和**以及**封锁位置的和**，另外再维护区间内**未封锁位置个数**以及**这整个区间是否被封锁**（类似于扫描线）。于是我们可以实时维护出每个位置是否被封锁，并据此来进行加法和乘法操作的修改。

这里需要注意一些细节，就是在所有的加法和乘法的操作以及相应标记下传时，如果相应节点整段区间被标记为封锁，那么就**不应该对区间和以及标记进行修改**，而在其他情况下则**需要进行相应的区间和以及标记的修改**。以及具体进行封锁和解除封锁时需要根据相应情况进行维护（比如在解除封锁部分，叶节点和非叶节点的维护就不同，以及对相应节点封锁时需要下传标记以保证解除封锁时维护的正确性）。

显然此时复杂度容易证明还是 $O(n\log n)$（$n,m$ 同阶），考虑如何证明正确性。

可以发现**在封锁操作执行前，所有相应需要封锁的节点的祖先标记均已下传**，因此在此之前的操作内容已经全部传到这个节点，只需要再进行标记即可。而对于所有的解除封锁操作，在相应时段内的所有操作的标记也已经下传，而根据我们对标记下传部分的修改，相应的效果**不会被传到该节点**（相当于消去了这个时段内加法和乘法操作对这个区间的影响）。由此我们证明了这个做法的正确性。

```cpp
#include<bits/stdc++.h>
#define p 1000000007
using namespace std;
int lw[200005],la[200005];
int fl[200005],fr[200005];
int n,m,a[200005];
struct xds{
	int x,fx,len,bj[2],f;
};
#define ls(w) (w<<1)
#define rs(w) (ls(w)^1)
xds tree[800005];
int dr()
{
	int xx=0;char ch=getchar();
	while(ch<'0'||ch>'9')ch=getchar();
	while(ch>='0'&&ch<='9')xx=(xx<<1)+(xx<<3)+ch-'0',ch=getchar();
	return xx;
}
void u(int w)
{
	if(tree[w].f==0)
	{
		tree[w].x=(tree[ls(w)].x+tree[rs(w)].x)%p,tree[w].fx=(tree[ls(w)].fx+tree[rs(w)].fx)%p;
		tree[w].len=tree[ls(w)].len+tree[rs(w)].len;
	}
}
void d(int w)
{
	if(tree[w].bj[1]!=1)
	{
		int x=tree[w].bj[1];tree[w].bj[1]=1;
		tree[ls(w)].x=1ll*tree[ls(w)].x*x%p,tree[rs(w)].x=1ll*tree[rs(w)].x*x%p;
		if(tree[ls(w)].f==0)tree[ls(w)].bj[0]=1ll*tree[ls(w)].bj[0]*x%p,tree[ls(w)].bj[1]=1ll*tree[ls(w)].bj[1]*x%p;
		if(tree[rs(w)].f==0)tree[rs(w)].bj[0]=1ll*tree[rs(w)].bj[0]*x%p,tree[rs(w)].bj[1]=1ll*tree[rs(w)].bj[1]*x%p;
	}
	if(tree[w].bj[0]!=0)
	{
		int x=tree[w].bj[0];tree[w].bj[0]=0;
		tree[ls(w)].x=(tree[ls(w)].x+1ll*tree[ls(w)].len*x)%p,tree[rs(w)].x=(tree[rs(w)].x+1ll*tree[rs(w)].len*x)%p;
		if(tree[ls(w)].f==0)tree[ls(w)].bj[0]=(tree[ls(w)].bj[0]+x)%p;
		if(tree[rs(w)].f==0)tree[rs(w)].bj[0]=(tree[rs(w)].bj[0]+x)%p;
	}
}
void csh(int w,int l,int r)
{
	tree[w].bj[1]=1;
	if(l==r)
	{
		tree[w].x=a[l],tree[w].len=1;
		return;
	}
	int mid=(l+r)>>1;
	csh(ls(w),l,mid),csh(rs(w),mid+1,r);
	u(w);
}
void xg_1(int w,int L,int R,int l,int r,int x)
{
	if(tree[w].f)return;
	if(L<=l&&r<=R)
	{
		tree[w].x=(tree[w].x+1ll*tree[w].len*x)%p;
		tree[w].bj[0]=(tree[w].bj[0]+x)%p;
		return;
	}
	d(w);
	int mid=(l+r)>>1;
	if(L<=mid)xg_1(ls(w),L,R,l,mid,x);
	if(R>mid)xg_1(rs(w),L,R,mid+1,r,x);
	u(w);
}
void xg_2(int w,int L,int R,int l,int r,int x)
{
	if(tree[w].f)return;
	if(L<=l&&r<=R)
	{
		tree[w].x=1ll*tree[w].x*x%p;
		tree[w].bj[0]=1ll*tree[w].bj[0]*x%p,tree[w].bj[1]=1ll*tree[w].bj[1]*x%p;
		return;
	}
	d(w);
	int mid=(l+r)>>1;
	if(L<=mid)xg_2(ls(w),L,R,l,mid,x);
	if(R>mid)xg_2(rs(w),L,R,mid+1,r,x);
	u(w);
}
void xg_3(int w,int L,int R,int l,int r)
{
	if(L<=l&&r<=R)
	{
		if(l!=r)d(w);
		if(tree[w].f==0)tree[w].fx=(tree[w].fx+tree[w].x)%p,tree[w].x=0,tree[w].len=0;
		++tree[w].f;
		return;
	}
	d(w);
	int mid=(l+r)>>1;
	if(L<=mid)xg_3(ls(w),L,R,l,mid);
	if(R>mid)xg_3(rs(w),L,R,mid+1,r);
	u(w);
}
void xg_4(int w,int L,int R,int l,int r)
{
	if(L<=l&&r<=R)
	{
		--tree[w].f;
		if(tree[w].f==0)
		{
			if(l==r)swap(tree[w].x,tree[w].fx),tree[w].len=1;
			else u(w);
		}
		return;
	}
	d(w);
	int mid=(l+r)>>1;
	if(L<=mid)xg_4(ls(w),L,R,l,mid);
	if(R>mid)xg_4(rs(w),L,R,mid+1,r);
	u(w);
}
int cx(int w,int L,int R,int l,int r)
{
	if(L<=l&&r<=R)return (tree[w].x+tree[w].fx)%p;
	d(w);
	int mid=(l+r)>>1,x=0;
	if(L<=mid)x+=cx(ls(w),L,R,l,mid);
	if(R>mid)x+=cx(rs(w),L,R,mid+1,r);
	return x%p;
}
int main()
{
	n=dr(),m=dr();
	for(int i=1;i<=n;i++)a[i]=dr();
	csh(1,1,n);
	for(int i=1;i<=m;i++)
	{
		int opt=dr(),l=dr(),r=dr();
		if(opt<=3)
		{
			int x=dr();
			if(opt==1)xg_1(1,l,r,1,n,x);
			if(opt==2)xg_2(1,l,r,1,n,x);
			if(opt==3)
			{
				xg_3(1,fl[i]=l,fr[i]=r,1,n);
				int k=i+x;la[i]=lw[k],lw[k]=i;
			}
		}
		else printf("%d\n",cx(1,l,r,1,n));
		for(int j=lw[i];j;j=la[j])xg_4(1,fl[j],fr[j],1,n);
	}
}
```


---

## 作者：立柱已选162534 (赞：2)

# 思路（易错点大合集）

### 1. 看到这题

不就在模板的基础上维护一个时间，判断要不要更新这个节点吗？~~这题应该不是蓝吧……~~

**结果：** 只能过 Subtask 2，8pts。

**原因：** 对于类似下面这组样例的情况，在更新区间时无法确定要更新多少个节点的值，从而会寄。

```
2 3
0 0
3 1 1 1
1 1 2 1
4 1 2
```

### 2. 对拍~~或看题解~~找出为啥错了

在一个区间内维护未被封锁的节点的**数量**及它们的**和**。

然后发现记录封锁的时间难以维护，所以需要将封锁转化为**封锁与解封**两个操作，对于解封用个 vector 或者类似链式前向星的结构存下需要解封的区间，在需要解封的时间操作即可。

注意一下记录的是封锁次数而非是否被封锁，否则会将重叠的一并解封。

然鹅如果直接把封锁看成一个要下传的标记还是会寄，因为在解封时如果有重叠的封锁就会对**子树中**需要维护的“未被封锁的节点的**数量**”产生干扰，所以不能封锁下传。

芝士我拍出的错误样例：

```
5 13
6 2 9 1 7 
3 1 4 10
4 4 5 
2 4 4 6
2 3 3 6
4 3 4 
3 2 5 9
1 3 5 4
1 4 4 9
3 4 5 7
1 3 4 8
4 4 5 
1 1 5 1
4 1 5 
```

```
8
10
8
26
```
如果直接将封锁看做标记进行下传，那么操作 `3 1 4 10` 与 `3 2 5 9` 会分别下传一次，而 `3 1 5 9` 取消后会把区间 $[1,2]$ 全部解封，导致区间 $[1,2]$ 中未被封锁的节点的**数量**变成 $2$ 但应该为 $1$，所以不能把封锁操作当成标记下传。


### 3.一个小更改

要把标记**留在当前节点上**，之后遇到乘或加的操作时不再更改。

# 实现

没啥好说的，注意一下 pushup 和 pushdown 的位置就行了。

显然时间复杂度 $O(m\log n)$。

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int p=1000000007;
long long n,m,k,x,y,c,a[200005],tr[800005][3],bl[800005],tag[800005][2],cnt;
vector<int> tx[200005],ty[200005];
void add(int l,int r,int c,int kl,int kr,int pd,long long s);//可以在下传标记时直接调用 add （因为方法一样），减少码量与修改时间 
void pushdown(int c,int l,int r){ 
	int mid=(r+l)/2;
	if(tag[c][1]!=1){
		add(l,mid,c*2,l,mid,1,tag[c][1]);
		add(mid+1,r,c*2+1,mid+1,r,1,tag[c][1]);
		tag[c][1]=1;
	}
	if(tag[c][0]){
		add(l,mid,c*2,l,mid,0,tag[c][0]);
		add(mid+1,r,c*2+1,mid+1,r,0,tag[c][0]);
		tag[c][0]=0;
	}
}
void pushup(int c){
	tr[c][0]=(tr[c*2][0]+tr[c*2+1][0])%p;
	tr[c][1]=tr[c*2][1]+tr[c*2+1][1];
	tr[c][2]=(tr[c*2][2]+tr[c*2+1][2])%p;
}
void build(int l,int r,int c){
	if(l>r)return;
	if(l==r){
		tr[c][2]=tr[c][0]=a[l];
		tr[c][1]=1;
		tag[c][1]=1;
		return;
	}
	build(l,(l+r)/2,c*2);
	build((l+r)/2+1,r,c*2+1);
	pushup(c); 
	tag[c][1]=1;
}
void add(int l,int r,int c,int kl,int kr,int pd,long long s){
	if(l>kr||r<kl||l>r)return;
	if(l>=kl&&r<=kr){
		if(pd==0&&!bl[c]){//处理加 
			tr[c][0]=(tr[c][0]+s*tr[c][1])%p;
			tr[c][2]=(tr[c][2]+s*tr[c][1])%p;
			tag[c][0]=(tag[c][0]+s)%p;
		}
		if(pd==1&&!bl[c]){//处理乘 
			tr[c][0]=(tr[c][0]+(s-1)*tr[c][2])%p;
			tr[c][2]=tr[c][2]*s%p;
			tag[c][0]=tag[c][0]*s%p;
			tag[c][1]=tag[c][1]*s%p;
		}
		if(pd==2){//处理封锁/解封，为了方便一起处理
			bl[c]+=s;
			if(!bl[c]){
				if(l!=r)pushup(c);
				else tr[c][1]=1,tr[c][2]=tr[c][0];
			}
			else{
				if(l!=r)pushdown(c,l,r);
				tr[c][1]=tr[c][2]=0;
			}
		}
		return;
	}
	if(bl[c]&&pd!=2)return;
	pushdown(c,l,r);
	add(l,(l+r)/2,c*2,kl,kr,pd,s);
	add((l+r)/2+1,r,c*2+1,kl,kr,pd,s);
	if(!bl[c])pushup(c);
}
long long query(int l,int r,int c,int kl,int kr){
	if(l>kr||r<kl||l>r)return 0;
	if(l>=kl&&r<=kr)return tr[c][0];
	else {
		pushdown(c,l,r);
		return (query(l,(l+r)/2,c*2,kl,kr)+query((l+r)/2+1,r,c*2+1,kl,kr))%p;
	}
}
int main(){
	scanf("%lld%lld",&n,&m);
	for(int i=1;i<=n;i++)
		scanf("%lld",&a[i]);
	build(1,n,1);
	for(int i=1;i<=m;++i){
		scanf("%lld%lld%lld",&k,&x,&y);
		if(k==4)printf("%lld\n",query(1,n,1,x,y));//求答案 
		else scanf("%lld",&c);
		if(k<=2)add(1,n,1,x,y,k-1,c);//加法和乘法 
		if(k==3){
			add(1,n,1,x,y,2,1);//封上
			tx[i+c].push_back(x),ty[i+c].push_back(y);//先存着等解封 
		}
		for(int j=0;j<tx[i].size();++j)//解封，用vector维护避免出现同一时间多次解封的情况，注意是这次处理完再解封 
			add(1,n,1,tx[i][j],ty[i][j],2,-1);
	}
	return 0;
}
```

---

## 作者：GoldenCreeper (赞：1)

题目传送门：[P7497 四方喝彩](https://www.luogu.com.cn/problem/P7497)

---

建议做本题之前，先做 [【模板】线段树 1](https://www.luogu.com.cn/problem/P3372) 和 [P3373 【模板】线段树 2](https://www.luogu.com.cn/problem/P3373)。这样我们只需要考虑操作 3 就可以了。

开始我觉得只需要维护区间封锁的持续时间就好了，在被封锁时不更新区间，~~这道题太简单了！~~

但其实这是不对的。我们举个例子：现在有区间 $[1, 2]$ ，先把区间 $\times2$，此时父节点的乘法懒标记为 $2$ 。对第 $2$ 个节点封锁 1 个单位时间，然后再把整个区间 $\times2$，此时父节点的乘法懒标记为 $4$，然后查询第二个点。问题来了，此时要下传懒标记，但是父节点有一部分懒标记是在所求的子节点被封锁时变化的，不应该下传那部分懒标记。维护每次懒标记的时间并判断是否下传不太可行，所以这个做法是不对的。

但我们可以根据上面想到，虽然我们不能根据父节点的懒标记直接更新子节点，但我们可以记录子节点的信息，并判断如何更新。具体的讲，对于每个点，我们记录其所表示区间中被未被封锁的数量、被封锁的元素的和、未被封锁的元素的和、被封锁的时间、乘法懒标记和加法懒标记。

想清楚这些，我们就可以开始写了。

代码：

```cpp
#include <bits/stdc++.h>
#define int long long
#define ls(x) (x << 1)
#define rs(x) (x << 1 | 1)

using namespace std;

const int N = 1e6 + 10, mod = 1e9 + 7;

// 定义线段树节点的结构体
struct seg{
    int bl, unlock, lock, add, time, len; 
    // bl: 是否被封锁
    // unlock: 未被封锁的元素的惊险值之和
    // lock: 被封锁的元素的惊险值之和
    // add: 加法懒标记
    // time: 乘法懒标记
    // len: 未被封锁的元素的个数
}s[4 * N];

// 更新节点的信息, 板子内容
void pushup(int x){
    if (s[x].bl == 0){
        s[x].unlock = (s[ls(x)].unlock + s[rs(x)].unlock) % mod;
        s[x].lock = (s[ls(x)].lock + s[rs(x)].lock) % mod;
        s[x].len = (s[ls(x)].len + s[rs(x)].len) % mod;
    }
}

int n, m, a[N];

// 构建线段树
void build(int x, int l, int r){
    s[x].time = 1;
    if (l == r){
        cin >> a[l];
        s[x].unlock = a[l];
        s[x].len = 1;
        return;
    }
    int mid = (l + r) >> 1;
    build(ls(x), l, mid);
    build(rs(x), mid + 1, r);
    pushup(x);
}

void pushdown(int x, int l, int r){
    int mid = (l + r) >> 1;
    if (s[ls(x)].bl == 0){
        s[ls(x)].unlock = (s[ls(x)].unlock * s[x].time + s[x].add * s[ls(x)].len % mod) % mod;
        s[ls(x)].add = (s[ls(x)].add * s[x].time % mod + s[x].add) % mod;
        s[ls(x)].time = (s[ls(x)].time * s[x].time) % mod;
    }
    if (s[rs(x)].bl == 0){
        s[rs(x)].unlock = (s[rs(x)].unlock * s[x].time + s[x].add * s[rs(x)].len % mod) % mod;
        s[rs(x)].add = (s[rs(x)].add * s[x].time % mod + s[x].add) % mod;
        s[rs(x)].time = (s[rs(x)].time * s[x].time) % mod;
    }
    s[x].add = 0, s[x].time = 1; // 重置懒标记
}

void modify(int x, int l, int r, int ql, int qr, int k, int opr){
    if (s[x].bl) return; // 如果当前节点被封锁，则直接返回
    if (ql <= l && r <= qr){
        if (opr == 1){ // 操作类型为加法
            s[x].unlock = (s[x].unlock + k * s[x].len % mod) % mod;
            s[x].add = (s[x].add + k) % mod;
        }
        if (opr == 2){ // 操作类型为乘法
            s[x].unlock = s[x].unlock * k % mod;
            s[x].add = s[x].add * k % mod;
            s[x].time = s[x].time * k % mod;
        }
        return;
    }
    int mid = (l + r) >> 1;
    pushdown(x, l, r)
    if (ql <= mid) modify(ls(x), l, mid, ql, qr, k, opr);
    if (qr > mid) modify(rs(x), mid + 1, r, ql, qr, k, opr);
    pushup(x);
}

void Lock(int x, int l, int r, int ql, int qr){
    if (ql <= l && r <= qr){
        if (l != r) pushdown(x, l, r); // 如果当前节点不是叶子节点，则延迟更新当前节点的信息
        if (s[x].bl == 0){ // 如果当前节点未被封锁
            s[x].lock = (s[x].unlock + s[x].lock) % mod; // 更新被封锁的元素的惊险值
            s[x].unlock = s[x].len = 0; // 清空未被封锁的元素的惊险值和个数
        }
        ++s[x].bl; // 标记当前节点为被封锁
        return;
    }
    pushdown(x, l, r);
    int mid = (l + r) >> 1;
    if (ql <= mid) Lock(ls(x), l, mid, ql, qr);
    if (qr > mid) Lock(rs(x), mid + 1, r, ql, qr);
    pushup(x);
}

void unLock(int x, int l, int r, int ql, int qr){
    if (ql <= l && r <= qr){
        --s[x].bl;
        if (s[x].bl == 0){ // 如果当前节点不再被封锁
            if (l == r) swap(s[x].unlock, s[x].lock), s[x].len = 1; // 交换未被封锁的元素的惊险值和被封锁的元素的惊险值，并更新未被封锁的元素个数为 1
            else pushup(x);
        }
        return;
    }
    pushdown(x, l, r);
    int mid = (l + r) >> 1;
    if (ql <= mid) unLock(ls(x), l, mid, ql, qr);
    if (qr > mid) unLock(rs(x), mid + 1, r, ql, qr);
    pushup(x);
}

int query(int x, int l, int r, int ql, int qr){
    if (ql <= l && r <= qr) return (s[x].unlock + s[x].lock) % mod; 
    pushdown(x, l, r);
    int mid = (l + r) >> 1, ret = 0;
    if (ql <= mid) ret += query(ls(x), l, mid, ql, qr);
    if (qr > mid) ret += query(rs(x), mid + 1, r, ql, qr);
    return ret % mod;
}

vector<pair<int,int>> t[N];

signed main(){
    cin >> n >> m;
    build(1, 1, n);
    for (int i = 1;i <= m;++i){
        int op, l, r, x;
        cin >> op >> l >> r;
        if (op <= 3) cin >> x;
        if (op <= 2) modify(1, 1, n, l, r, x, op);
        if (op == 3) Lock(1, 1, n, l, r), t[i + x].push_back({l, r});
        if (op == 4) cout << query(1, 1, n, l, r) << endl;
        for (auto j : t[i]) unLock(1, 1, n, j.first, j.second); //t[i] 表示 t[i] 解封的区间
    }
    return 0;
}
```

---

## 作者：eb0ycn (赞：1)

传送门：[P7497](https://www.luogu.com.cn/problem/P7497)。

发个题解祭奠我做这道题逝去的四十个小时。

## 题意：

在线段树板子的基础上，增加一个封锁操作，每次封锁操作忽略 $x$ 回合以内的乘加操作。

## 思路（也是心路）

### 错解一

对于每次封锁操作，拆成两次操作（封锁和解封），封锁时直接给对应区间打上某个标记，解封的时候去掉。以后下传懒标记，如果发现当前区间被封锁就不下传。至于怎么增加“解封”操作，用链式前向星随便搞就行啦。

但是这个问题有很多，比如说当前区间没有被完全封锁，怎么下传懒标记？

### 错解二

（时间已经来到 13 号）

刚刚的做法样例都过不了。想想缺陷是什么：不能记录当前区间有几个数没被封锁。解决方法就是多维护三个值，表示区间未被封锁的数量，未被封锁的数的和，被封锁的数的和。

问题在于怎么下传懒标记。线段树板子下传懒标记是这样的：

```cpp
s[root<<1]=(1ll*s[root<<1]*l1[root]+1ll*(mid-l+1)*l2[root])%571373,s[root<<1|1]=(1ll*s[root<<1|1]*l1[root]+1ll*(r-mid)*l2[root])%571373;
l1[root<<1]=1ll*l1[root<<1]*l1[root]%571373,l1[root<<1|1]=1ll*l1[root<<1|1]*l1[root]%571373;
l2[root<<1]=(1ll*l2[root<<1]*l1[root]+l2[root])%571373,l2[root<<1|1]=(1ll*l2[root<<1|1]*l1[root]+l2[root])%571373;
l1[root]=1,l2[root]=0;
```

其中，加法标记的 $r-l+1$ 其实就是“未被封锁的数量”，只不过就是区间长度。同理，$s_{root}$ 表示的就是“未被封锁的数的和”。那我们类比一下，不难得出这道题的下传操作：

```cpp
if(l1[root]==1&&!l2[root])return;
if(!s3[root<<1])s1[root<<1]=(1ll*s1[root<<1]*l1[root]+1ll*len[root<<1]*l2[root])%1000000007,l1[root<<1]=1ll*l1[root]*l1[root<<1]%1000000007,l2[root<<1]=(1ll*l2[root<<1]*l1[root]+l2[root])%1000000007;
if(!s3[root<<1|1])s1[root<<1|1]=(1ll*s1[root<<1|1]*l1[root]+1ll*len[root<<1|1]*l2[root])%1000000007,l1[root<<1|1]=1ll*l1[root<<1|1]*l1[root]%1000000007,l2[root<<1|1]=(1ll*l2[root<<1|1]*l1[root]+l2[root])%1000000007;
l1[root]=1,l2[root]=0;
```

其中 $len$ 表示未被封锁的数量，$s_1$ 表示未被封锁的数的和，$s_2$ 表示被封锁的数的和，$s_3$ 就是是否整个区间被封锁。

然后你就……惊奇地发现样例二过不了。

### 正解

看看样例一有什么特点：只有一次封锁操作。

题目说了，同一区间的封锁操作时间不会更短，**但可能会被更长的覆盖**。

所以，存储封锁 buff 的数组不能单纯是 $0$ 或 $1$，而是储存当前区间叠了几个 buff。每次封锁操作把对应区间标记加一，解封的时候减一就行了。

行文至此，此题已解……吗？

肯定不是。这题有很多细节。

## 细节

1. 解封操作要 $k+x$ 时间结束以后才能进行，并且一次可能解封很多区间；

1. 对于加乘操作，如果当前区间全部被锁，直接跳过，否则要上传和下传；

1. 对于封锁操作，如果当前区间全部被覆盖在封锁区间里面，且这是第一次被锁，就要下传懒标记，不然如果子孙结点被封锁或解封，就乱套了（我在这卡了五个小时）；

1. 对于解封操作，如果当前区间被覆盖在“解放区”里面且完全解放了，并且不是叶子结点，一定要用儿子结点更新当前节点，因为儿子结点可能还没有解放；

1. 对于封锁和解封操作，如果当前区间没有全部覆盖在操作区间里面，就要递归。回溯上来以后，如果当前区间被完全封锁，就一定不能用儿子结点更新它（卡了我整整一晚上）。

现在这题算是做完了，但是敲代码也是很考验耐心的。加油，同志们！

## 代码

```cpp
#include<cstdio>
using namespace std;
int n,m,a[200001],s1[800000],s2[800000],s3[800000],len[800000],l1[800000],l2[800000],op,rl,rr,x,tot,head[200001],nxt[200001],vall[200001],valr[200001];
void build(int l,int r,int root){
	l1[root]=1,len[root]=r-l+1;
	if(l==r){s1[root]=a[l];return;}
	int mid=l+r>>1;
	build(l,mid,root<<1),build(mid+1,r,root<<1|1),s1[root]=(s1[root<<1]+s1[root<<1|1])%1000000007;
}
void pushdown(int l,int r,int root){
	if(l1[root]==1&&!l2[root])return;
	if(!s3[root<<1])s1[root<<1]=(1ll*s1[root<<1]*l1[root]+1ll*len[root<<1]*l2[root])%1000000007,l1[root<<1]=1ll*l1[root]*l1[root<<1]%1000000007,l2[root<<1]=(1ll*l2[root<<1]*l1[root]+l2[root])%1000000007;
	if(!s3[root<<1|1])s1[root<<1|1]=(1ll*s1[root<<1|1]*l1[root]+1ll*len[root<<1|1]*l2[root])%1000000007,l1[root<<1|1]=1ll*l1[root<<1|1]*l1[root]%1000000007,l2[root<<1|1]=(1ll*l2[root<<1|1]*l1[root]+l2[root])%1000000007;
	l1[root]=1,l2[root]=0;
}
void mul(int l,int r,int root){
	if(s3[root])return;
	if(rl<=l&&r<=rr){
		if(len[root])l1[root]=1ll*l1[root]*x%1000000007,l2[root]=1ll*l2[root]*x%1000000007,s1[root]=1ll*s1[root]*x%1000000007;
		return;
	}pushdown(l,r,root);
	int mid=l+r>>1;
	if(mid>=rl)mul(l,mid,root<<1);
	if(mid<rr)mul(mid+1,r,root<<1|1);
	s1[root]=(s1[root<<1]+s1[root<<1|1])%1000000007;
}
void add(int l,int r,int root){
	if(s3[root])return;
	if(rl<=l&&r<=rr){
		if(len[root])l2[root]=(l2[root]+x)%1000000007,s1[root]=(1ll*s1[root]+1ll*x*len[root])%1000000007;
		return;
	}pushdown(l,r,root);
	int mid=l+r>>1;
	if(mid>=rl)add(l,mid,root<<1);
	if(mid<rr)add(mid+1,r,root<<1|1);
	s1[root]=(s1[root<<1]+s1[root<<1|1])%1000000007;
}
void lo(int l,int r,int root){
	if(rl<=l&&r<=rr){
		if(r-l)pushdown(l,r,root);
		if(len[root])s2[root]=(s1[root]+s2[root])%1000000007,len[root]=s1[root]=0;
		++s3[root];
		return;
	}pushdown(l,r,root);
	int mid=l+r>>1;
	if(mid>=rl)lo(l,mid,root<<1);
	if(mid<rr)lo(mid+1,r,root<<1|1);
	if(!s3[root])len[root]=len[root<<1]+len[root<<1|1],s1[root]=(s1[root<<1]+s1[root<<1|1])%1000000007,s2[root]=(s2[root<<1]+s2[root<<1|1])%1000000007;
}
void unl(int l,int r,int root){
	if(rl<=l&&r<=rr){
		--s3[root];
		if(!s3[root]){
			if(l==r)s1[root]=s2[root],s2[root]=0,len[root]=1;
			else s1[root]=(s1[root<<1]+s1[root<<1|1])%1000000007,s2[root]=(s2[root<<1]+s2[root<<1|1])%1000000007,len[root]=len[root<<1]+len[root<<1|1];
		}
		return;
	}pushdown(l,r,root);
	int mid=l+r>>1;
	if(mid>=rl)unl(l,mid,root<<1);
	if(mid<rr)unl(mid+1,r,root<<1|1);
	if(!s3[root])len[root]=len[root<<1]+len[root<<1|1],s1[root]=(s1[root<<1]+s1[root<<1|1])%1000000007,s2[root]=(s2[root<<1]+s2[root<<1|1])%1000000007;
}
int query(int l,int r,int root){
	if(rl<=l&&r<=rr)return (s1[root]+s2[root])%1000000007;
	pushdown(l,r,root);
	int mid=l+r>>1,ret=0;
	if(mid>=rl)ret+=query(l,mid,root<<1);
	if(mid<rr)ret+=query(mid+1,r,root<<1|1);
	return ret%1000000007;
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;++i)scanf("%d",a+i);build(1,n,1);
	for(int i=1;i<=m;++i){
		scanf("%d%d%d",&op,&rl,&rr);
		if(op==4)printf("%d\n",query(1,n,1));
		else{
			scanf("%d",&x);
			if(op==1)add(1,n,1);
			if(op==2)mul(1,n,1);
			if(op==3)lo(1,n,1),nxt[++tot]=head[i+x],head[i+x]=tot,vall[tot]=rl,valr[tot]=rr;
		}for(int j=head[i];j;j=nxt[j])rl=vall[j],rr=valr[j],unl(1,n,1);
	}return 0;}
```

---

## 作者：xs_siqi (赞：1)

学长出的公开赛题，然后今天被拿来当模拟赛 t2 了。

这种标记比较多的一般用线段树+矩阵维护吧。

我们考虑把封锁标记拆分成加锁标记和拆锁标记分别维护。

不妨设这样一个矩阵：

$$
\left[\begin{matrix}
sum_0\\
sum_1\\
len
\end{matrix}\right]
$$

其中，$sum_0$ 表示未被封锁的数的和，$sum_1$ 表示被封锁的数的和，$len$ 表示区间未被封锁的数的数量。

我们标记某一个区间为封锁之后，对于一个区间的加操作，我们肯定不能直接加区间长度，而是未被封锁的数的数量。对于乘操作，我们只需要对于未被封锁的数乘上这个值即可。

矩阵的优点就在于，你并不需要考虑下传标记的顺序，思路比较暴力，可以直接暴力下传。

于是我们不难列出乘操作矩阵：

$$
\left[\begin{matrix}
x & 0 & 0\\
0 & 1 & 0\\
0 & 0 & 1
\end{matrix}\right]
$$

加操作矩阵：

$$
\left[\begin{matrix}
1 & 0 & x\\
0 & 1 & 0\\
0 & 0 & 1
\end{matrix}\right]
$$

然后对于下传标记的时候就直接暴力下传就好了。然后记得判断一下这个标记是否已经被全部封锁，如果全部封锁了那显然是不能下传的，否则先下传，传给没被封锁的（至于谁没被封锁直接交给儿子处理即可）。

对于上传标记，如果当前区间被全部封锁，那么也是不可以上传标记的，因为当前的标记都是被封锁的，那么 $sum_0$ 是不能被记入的。

然后最后最难实现的还是封锁标记了。对于封锁标记，这个东西显然是很难下传的。因为对于一个下传封锁标记，你就要把目前的 $sum_0$ 转移到 $sum_1$ 里去，这样就是要把一个区间换成另一个权值不相等的区间，是不可能在 $O(\log n)$ 内转移完的。所以我们考虑不下传封锁标记。

当我们遇到封锁标记的时候，我们直接上传标记。对于一个区间全部被封锁标记覆盖，那么我们就不用继续往下走了（没意义），标记也自然不用往下打。

当然还有一个标记是解锁标记。当遇到解锁标记的时候，我们只要直接到叶子节点然后慢慢上传标记就好了。但是我们在封锁标记的时候根本没有封锁叶子节点啊？这是没关系的，因为在叶子节点上传的时候，总会通过某两个子区间合并然后直接把这个封锁标记冲掉，成为一个未被覆盖的区间。

因为用了矩阵，所以自带一个 $27$ 的常数，对于常规的矩阵撰写，需要进行 $27\times 2=54 $ 次取模操作。

考虑将循环展开，对于每一个相等的数组下标，我们可以统一不取模直接加，因为每次两个东西都是小于 $10^9+7$ 的，然后两个东西相乘是 $10^{18}$ 左右。然而 `long long` 上界是 $9\times 10^{18}$，可以容纳九次取模。

然后再进行一些小优化就可以优化成只需要 $9$ 次取模了。在加上超级快读+氧气的情况下，我们可以八百多毫秒卡过去。

然而这是不够的。我们发现对于 $sum_1$ 完全没用。所以矩阵完全是可以优化成 $2\times 2$ 的，大大减少常数。

于是不难把矩阵修改成这样：

乘操作矩阵：

$$
\left[\begin{matrix}
x & 0\\
0 & 1
\end{matrix}\right]
$$

加操作矩阵：

$$
\left[\begin{matrix}
1 & x\\
0 & 1
\end{matrix}\right]
$$

开了氧气后竟然只用了两百多毫秒，我们矩阵玩家真的太牛了！

```cpp
#include<bits/stdc++.h>
#define ls (rt<<1)
#define rs (rt<<1|1)
#define pb push_back
using namespace std;
const int mod=1e9+7;
const int maxn=2e5+5;
inline char gc() {
	static char ibuf[1 << 22], *is = ibuf, *ie = ibuf;
	if (is == ie) 
		is = ibuf, ie = ibuf + fread(ibuf, 1, 1 << 22, stdin);
	return is == ie ? EOF : *is++;
}
#define getchar gc
inline void read(int &x){
	x=0;int ff=1;char ch=getchar();
	while(ch<'0'||ch>'9')<%if(ch=='-')ff=-1;ch=getchar();%>
	while('0'<=ch&&ch<='9')x=x*10+ch-'0',ch=getchar();
	x*=ff;}
struct tree{
	int a[2][2],tms,lp;//0 hav 1 nhav 2 havlen
	inline void debug(){
		for(int i=0;i<2;i++){
			for(int j=0;j<2;j++)
				printf("%d ",a[i][j]);
			printf("\n");
		}
	}
	inline void cl(){
		for(int i=0;i<2;i++)
			for(int j=0;j<2;j++)
				a[i][j]=0;
		tms=0;lp=0;
	}
	inline void my(){
		for(int i=0;i<2;i++)
			for(int j=0;j<2;j++)
				a[i][j]=0;
		for(int i=0;i<2;i++)a[i][i]=1;
	}
	inline void addtag(int x){
		cl();
		a[0][0]=1,a[1][1]=1,a[0][1]=x;
	}
	inline void muitag(int x){
		cl();
		a[0][0]=x,a[1][1]=1;
	}
	friend tree operator * (tree x,tree y){
		tree z;
		z.cl();
		z.a[0][0]=(z.a[0][0]+1ll*y.a[0][0]*x.a[0][0]+1ll*y.a[0][1]*x.a[1][0])%mod;
		z.a[0][1]=(z.a[0][1]+1ll*y.a[0][0]*x.a[0][1]+1ll*y.a[0][1]*x.a[1][1])%mod;
		z.a[1][0]=(z.a[1][0]+1ll*y.a[1][0]*x.a[0][0]+1ll*y.a[1][1]*x.a[1][0])%mod;
		z.a[1][1]=(z.a[1][1]+1ll*y.a[1][0]*x.a[0][1]+1ll*y.a[1][1]*x.a[1][1])%mod;
		z.lp=x.lp,z.tms=x.tms;
		return z;
	}
}tr[maxn*4],lz[maxn*4],ad,mu;
struct node{
	int l,r;
};
vector<node>de[maxn];
int n,m,a[maxn];
inline void pushup(int rt){
	if(tr[rt].tms)return ;
	tr[rt].a[0][0]=(tr[ls].a[0][0]+tr[rs].a[0][0])%mod;
	tr[rt].lp=(tr[ls].lp+tr[rs].lp)%mod;
	tr[rt].a[1][0]=tr[ls].a[1][0]+tr[rs].a[1][0];
}
inline void build(int rt,int l,int r){
	lz[rt].my();tr[rt].cl();
	if(l==r){
		tr[rt].a[0][0]=a[l];
		tr[rt].a[1][0]=1;
		return ;
	}
	int mid=l+r>>1;
	build(ls,l,mid),build(rs,mid+1,r);
	pushup(rt);
}
inline void pushdown(int rt){
	if(tr[ls].tms==0)
		tr[ls]=tr[ls]*lz[rt],lz[ls]=lz[ls]*lz[rt];
	if(tr[rs].tms==0)
		tr[rs]=tr[rs]*lz[rt],lz[rs]=lz[rs]*lz[rt];
	lz[rt].my();
}
inline void modify(int rt,int l,int r,int ql,int qr,tree x){//op1 + op2 *
	if(tr[rt].tms)return ;
	if(ql<=l&&r<=qr){
		tr[rt]=tr[rt]*x,lz[rt]=lz[rt]*x;
		return ;
	}
	pushdown(rt);
	int mid=l+r>>1;
	if(ql<=mid)modify(ls,l,mid,ql,qr,x);
	if(qr>mid)modify(rs,mid+1,r,ql,qr,x);
	pushup(rt);
}
inline int query(int rt,int l,int r,int ql,int qr){
	if(ql<=l&&r<=qr)return (tr[rt].a[0][0]+tr[rt].lp)%mod;
	pushdown(rt);
	int mid=l+r>>1,ans=0;
	if(ql<=mid)ans+=query(ls,l,mid,ql,qr);
	if(qr>mid)(ans+=query(rs,mid+1,r,ql,qr))%=mod;
	return ans;
}
inline void tagadd(int rt,int l,int r,int ql,int qr){
	if(ql<=l&&r<=qr){
		if(l<r)pushdown(rt);
		if((tr[rt].tms)==0){
			
			(tr[rt].lp+=tr[rt].a[0][0])%=mod;
			tr[rt].a[0][0]=0;
			tr[rt].a[1][0]=0;
		}
		++tr[rt].tms;
		return ;
	}
	pushdown(rt);
	int mid=l+r>>1;
	if(ql<=mid)tagadd(ls,l,mid,ql,qr);
	if(qr>mid)tagadd(rs,mid+1,r,ql,qr);
	pushup(rt);
}
inline void tagdel(int rt,int l,int r,int ql,int qr){
	if(ql<=l&&r<=qr){
		if((--tr[rt].tms)==0){
			if(l==r)
				swap(tr[rt].a[0][0],tr[rt].lp),
				tr[rt].a[1][0]=1;
			else pushup(rt);
		}
		return ;
	}
	pushdown(rt);
	int mid=l+r>>1;
	if(ql<=mid)tagdel(ls,l,mid,ql,qr);
	if(qr>mid)tagdel(rs,mid+1,r,ql,qr);
	pushup(rt);	
}
inline void debug(int rt,int l,int r){
	if(l==r){printf("%d:\n",l);tr[rt].debug();printf("\n");return ;}
	pushdown(rt);
	int mid=l+r>>1;
	debug(ls,l,mid),debug(rs,mid+1,r);
}
int main(){
	read(n),read(m);
	for(int i=1;i<=n;i++)read(a[i]);
	build(1,1,n);
	ad.addtag(0),mu.muitag(0);
	
	for(int op,x,y,z,i=1;i<=m;i++){
		read(op),read(x),read(y);
		if(op==1)
			read(z),ad.a[0][1]=z,
			modify(1,1,n,x,y,ad);
		if(op==2)
			read(z),mu.a[0][0]=z,
			modify(1,1,n,x,y,mu);
		if(op==3)
			read(z),
			de[i+z].pb((node){x,y}),
			tagadd(1,1,n,x,y);
		if(op==4)
			printf("%d\n",query(1,1,n,x,y));
		for(int j=0;j<de[i].size();j++)
			tagdel(1,1,n,de[i][j].l,de[i][j].r);
	}
	return 0;
} 
/*
某篇题解的 hack 数据
5 13
6 2 9 1 7 
3 1 4 10
4 4 5 
2 4 4 6
2 3 3 6
4 3 4 
3 2 5 9
1 3 5 4
1 4 4 9
3 4 5 7
1 3 4 8
4 4 5 
1 1 5 1
4 1 5 
*/
```


---

## 作者：the_same_prayers (赞：1)

### 很好的线段树蓝题，升华相当多方面的线段树理解
（另外提示一下，题目中——包括简要题意中所说的封锁操作的“覆盖”有模糊的地方，实测应该是结束封锁时间在前的会被在后的覆盖而反之不会）

------------

## 痛苦的试错
乍一看 lazytag 板子题？仅仅加了一个封锁操作，我们岂不是只要类比 `lazy_add` , `lazy_mul` 加一个 `lazy_lock` 存一下每个目的封锁区间全包含节点的时间，如果 add 和 mul 操作时间小于该节点 `lock[nown]` 时间就返回，否则访问左右区间即可？

**然而会遇到第一个错误——这是由 lazytag 过程理解不深导致的：**

倘若 lock 区间为 `lazy_add/mul` 区间的子区间，打上 `lazy_add/mul` 标记时压根不会访问到 lock 区间，直接全 WA 。

于是解决也很简单，我在标 `lazy_lock` 的时候路径上所有节点都标上 `flag[nown]=1` 不就行了？如果打 `lazy_add/mul` 标记的节点有个 flag 标记，那就向下到`flag[nown]==0` 的节点再打 `lazy_add/mul` 标记。如此一来，复杂度也最多和上次 `lazy_lock` 一样，都是同阶 $Θ(\log n)$ 的不是吗？于是满满意意调出代码——

**然而会遇到第二个错误——这是由 lazytag 复杂度理解不深导致的：**

实际上真有大怨种不严格证正确性就去调一下的话（譬如我），就会感受到所花时间全然白费之绝望的美妙！![](https://cdn.luogu.com.cn/upload/image_hosting/skaohpx2.png)——为什么会 33pt tle 呢？

我们来思考这样一个答案往往容易被忽视的问题：为什么 "lazy tag" 会降低 **add 和 mul 操作**的复杂度？

因为一段区间被划分成的小块在访问最深层小块 ($\log n$) 的路上就已经顺便做上了 `lazy_add` 标记，因此复杂度只是改变了常数（ $×2$ ）而不是改变量级（变为 $n$ ）。**但如果区间不连续，那么这种方法就立刻失效**（实际上这所谓不连续的区间就等价于几段区间），**每次我们都要扫完每个小区间包含的深度最深的节点才能为所有小块加上标记**，复杂度最坏就变为 $Θ(t\log n)$ （其中 $t$ 为小区间数），由于 $t<l_i/2<n/2$ ，我们惊人惊到姥姥家地发现，单次修改区间退化成了 $l/2$ 次单点修改 ($Θ(n\log n)$) 。倘若前 $n/2$ 次操作封锁了偶数位的单个点至结束，余下每次 add/mul 操作整个序列 $1～n$ ，(假设这是个完全二叉树的话)总复杂度甚至会来到 $Θ(nm\log n)$ ！

于是我们会发现这条路基本不可能走通了，因为底层思想依旧是老老实实更新每个没锁的小区间，无论怎么样一次操作都会有 $≥Θ(t)$ 的复杂度。那么我们何不换一个思路：

## 正解的思路

既然无法具体下分到每个小区间进行操作，那么我们不妨直接类比 "lazy tag" 思想直接对大区间进行整体操作，**省去不必要的信息以降低复杂度**。

我们会发现，和原版 "lazy tag" 不关心区间具体包含各元素之值一样，**含有封锁小区间的区间依然不关心各个封锁小区间的值而只关心它们的总和和个数，知道区间总值和封锁总值即可使用 `lazy_mul` ，知道区间长度和封锁个数即可使用 `lazy_add` 。** 我们只需要加上 `lock_sum` 和 `lock_cnt` 两个数组，每次封锁操作将全包含的区间：

`lock_sum[nown]=val[nown],lock_cnt[nown]=r-l+1`

并且 `pushup` 时更新父节点信息即可。每次 `lazy_add/mul` （只要不是区间全封锁）依旧是正常打而不管是否含有封锁，只是计算区间值和下传 `lazy_add/mul` 时要计入两个 lock 数组的影响。

**终于来到了最后一个问题——如何“解封”？**

我们之前的思路都是存储每个封锁区间的时间，修改操作的时候直接拿出来比较，从而轻松排除时间的影响。而现在每个区间的两个 lock 数组不包含时间这一维度的任何考量，又由于（该死的）互相覆盖机制不好去存储每次 lock 区间的 $sum$ 和 $cnt$ （因为你还得维护重叠区间的时间信息，多重重叠又咋办？），所以换个思路，最简单直接的方法应该是把时间这一维从维护数据中剔除掉——那么直接在主函数对应时间里加一个解封操作不就好了吗？我们只需要严格消除封锁操作的影响，将全包含区间的两个 lock 数组置零并且上传即可。

但如何解决封锁区间重叠覆盖的问题？实际上我们可以直接计数，每次封锁全包含的区间时便加一 `lock_tag[nown]` 计数，解封时减一计数，仅计数为零时才置零即可。

（注意细节，不能也不需要将 lock 有关的任何数组下传：一方面，不需要是因为修改和查询都不需要全封锁区间的 lock 相关数据，未全封锁的区间的 lock 数据又都是由子节点上传得来的根本不需要下传；另一方面，不能是因为解封时如果子区间仍有封锁信息将不能消除干净影响后续操作，想消干净就得花复杂度）

附代码：（顺带一提这题非常卡常，难道是我的代码问题吗？这不能够啊这！わからない、わかんないよ∼......我已经竭尽所能优化了还是只能吸氧）
![](https://cdn.luogu.com.cn/upload/image_hosting/bp5axkzt.png)
```cpp
#include<bits/stdc++.h>
#define N 800005
using namespace std;

long long cnt,n,m,tree[N],val[N],a[N],lazy_mul[N],lock_tag[N],lazy_add[N],mod=1000000007,lazy_lock[N],lock_sum[N],lock_cnt[N],lazy_unlock[N];//先乘后加
struct store{long long l,r;};
vector<store>unl[N];

inline long long rd()
{
	long long ans=0/*,ops=1*/;
	char ch=getchar();
	while(ch<'0'||ch>'9'){/*if(ch=='-')ops=-1;*/ch=getchar();}
	while(ch<='9'&&ch>='0')ans=(ans<<1)+(ans<<3)+(ch^48),ch=getchar();
	return ans/*ops*/;
}

inline void pushdown(long long nown,long long l,long long r)
{
	long long mid=l+r>>1;
	if(lock_tag[nown<<1]==0)
	{
		lazy_mul[nown<<1]=(lazy_mul[nown<<1]*lazy_mul[nown])%mod;
		lazy_add[nown<<1]=(lazy_add[nown<<1]*lazy_mul[nown])%mod;
		lazy_add[nown<<1]=(lazy_add[nown<<1]+lazy_add[nown])%mod;
		val[nown<<1]=((val[nown<<1]*lazy_mul[nown]-lock_sum[nown<<1]*(lazy_mul[nown]-1)+(mid-l+1-lock_cnt[nown<<1])*lazy_add[nown])%mod+mod)%mod;	
	}
	if(lock_tag[nown<<1|1]==0)
	{
		lazy_mul[nown<<1|1]=(lazy_mul[nown<<1|1]*lazy_mul[nown])%mod;
		lazy_add[nown<<1|1]=(lazy_add[nown<<1|1]*lazy_mul[nown])%mod;
		lazy_add[nown<<1|1]=(lazy_add[nown<<1|1]+lazy_add[nown])%mod;
		val[nown<<1|1]=((val[nown<<1|1]*lazy_mul[nown]-lock_sum[nown<<1|1]*(lazy_mul[nown]-1)+(r-mid-lock_cnt[nown<<1|1])*lazy_add[nown])%mod+mod)%mod;
	}
	lazy_add[nown]=0,lazy_mul[nown]=1;
}

void build_tree(long long l,long long r,long long nown)
{
	lazy_mul[nown]=1;
	if(l==r){val[nown]=a[l];return;}
	long long mid=l+r>>1;
	build_tree(l,mid,nown<<1);
	build_tree(mid+1,r,nown<<1|1);
	val[nown]=(val[nown<<1]+val[nown<<1|1])%mod;
}

void add(long long stdl,long long stdr,long long l,long long r,long long nown,long long k)
{
	if(lock_tag[nown])return;
	if(l>=stdl&&r<=stdr)
	{
		lazy_add[nown]=(lazy_add[nown]+k)%mod;val[nown]=(val[nown]+(r-l+1-lock_cnt[nown])*k)%mod;
		return;
	}
	pushdown(nown,l,r);
	long long mid=l+r>>1;
	if(mid>=stdl)add(stdl,stdr,l,mid,nown<<1,k);
	if(mid+1<=stdr)add(stdl,stdr,mid+1,r,nown<<1|1,k);
	if(lock_tag[nown]==0)
	{
		val[nown]=(val[nown<<1]+val[nown<<1|1])%mod;
		lock_sum[nown]=(lock_sum[nown<<1]+lock_sum[nown<<1|1])%mod;
		lock_cnt[nown]=lock_cnt[nown<<1]+lock_cnt[nown<<1|1];		
	}
}
void mul(long long stdl,long long stdr,long long l,long long r,long long nown,long long k)
{
	if(lock_tag[nown])return;
	if(l>=stdl&&r<=stdr)
	{
		lazy_mul[nown]=(lazy_mul[nown]*k)%mod,lazy_add[nown]=(lazy_add[nown]*k)%mod,val[nown]=(val[nown]*k-lock_sum[nown]*(k-1))%mod;
		return;
	}
	pushdown(nown,l,r);
	long long mid=l+r>>1;
	if(mid>=stdl)mul(stdl,stdr,l,mid,nown<<1,k);
	if(mid+1<=stdr)mul(stdl,stdr,mid+1,r,nown<<1|1,k);
	if(lock_tag[nown]==0)
	{
		val[nown]=(val[nown<<1]+val[nown<<1|1])%mod;
		lock_sum[nown]=(lock_sum[nown<<1]+lock_sum[nown<<1|1])%mod;
		lock_cnt[nown]=lock_cnt[nown<<1]+lock_cnt[nown<<1|1];		
	}
}
void loc(long long stdl,long long stdr,long long l,long long r,long long nown)
{
	if(l!=r)pushdown(nown,l,r);
	if(l>=stdl&&r<=stdr)
	{
		lock_cnt[nown]=r-l+1;lock_sum[nown]=val[nown];lock_tag[nown]++;
		return;
	}
	long long mid=l+r>>1;
	if(mid>=stdl)loc(stdl,stdr,l,mid,nown<<1);
	if(mid+1<=stdr)loc(stdl,stdr,mid+1,r,nown<<1|1);
	if(lock_tag[nown]==0)
	{
		val[nown]=(val[nown<<1]+val[nown<<1|1])%mod;
		lock_sum[nown]=(lock_sum[nown<<1]+lock_sum[nown<<1|1])%mod;
		lock_cnt[nown]=lock_cnt[nown<<1]+lock_cnt[nown<<1|1];		
	}
}
void unloc(int stdl,int stdr,int l,int r,int nown)
{
	if(l>=stdl&&r<=stdr)
	{
		if(--lock_tag[nown]==0)
		{
			if(l!=r)
			{
				lock_sum[nown]=(lock_sum[nown<<1]+lock_sum[nown<<1|1])%mod;
				lock_cnt[nown]=lock_cnt[nown<<1]+lock_cnt[nown<<1|1];
				val[nown]=(val[nown<<1]+val[nown<<1|1])%mod;
			}
			else lock_sum[nown]=lock_cnt[nown]=0;		
		}
		return;
	}
	pushdown(nown,l,r);
	long long mid=l+r>>1;
	if(mid>=stdl)unloc(stdl,stdr,l,mid,nown<<1);
	if(mid+1<=stdr)unloc(stdl,stdr,mid+1,r,nown<<1|1);
	if(lock_tag[nown]==0)
	{
		val[nown]=(val[nown<<1]+val[nown<<1|1])%mod;
		lock_sum[nown]=(lock_sum[nown<<1]+lock_sum[nown<<1|1])%mod;
		lock_cnt[nown]=lock_cnt[nown<<1]+lock_cnt[nown<<1|1];
	}
}
long long qry(long long stdl,long long stdr,long long l,long long r,long long nown)
{
	if(l>=stdl&&r<=stdr)return val[nown];
	long long mid=l+r>>1,ans=0;
	pushdown(nown,l,r);
	if(mid>=stdl)ans=(ans+qry(stdl,stdr,l,mid,nown<<1))%mod;
	if(mid+1<=stdr)ans=(ans+qry(stdl,stdr,mid+1,r,nown<<1|1))%mod;
	return ans;
}
int main()
{
	cin>>n>>m;
	for(register int i=1;i<=n;i++)
	{
		a[i]=rd()%mod;
	}
	build_tree(1,n,1);
	for(register int i=1;i<=m;i++)
	{
		long long op=rd(),b,c,d;
		if(op==1)b=rd(),c=rd(),d=rd()%mod,add(b,c,1,n,1,d);
		if(op==2)b=rd(),c=rd(),d=rd()%mod,mul(b,c,1,n,1,d);
		if(op==3)b=rd(),c=rd(),d=rd(),loc(b,c,1,n,1),unl[i+d].push_back({b,c});
		if(op==4)b=rd(),c=rd(),cout<<qry(b,c,1,n,1)<<endl;
		while(!unl[i].empty()){unloc(unl[i].back().l,unl[i].back().r,1,n,1),unl[i].pop_back();}
	}
}
```


---

## 作者：cosf (赞：0)

真就一个难写的板子。

如果没有操作 3，这个题就是线段树 2。

对于操作 3，我们可以把它拆成两个操作，即封锁和解封。可以额外开一个 `vector<pll> [MAXM]` 来存第 $i$ 次操作跟着的解封操作有哪些。

因为封锁的点不受到懒标记及直接操作的影响，所以我们可以维护一个 tag $t$，表示被封锁的点的点权和。考虑到封可以重复，所以参考扫描线，额外维护一个 tag $v$ 表示当前区间被覆盖的次数，不下传。由于区间加需要知道区间未被封锁的次数，所以我们再维护一个 tag $l$ 表示当前区间没被封锁的点数。这样，一共维护 $6$ 个 tag，这题就可以解决了。

做区间加乘时，如果当前区间的 $v$ 不为 $0$，则可以直接跳过，因为被完全封锁了。

封锁时，记得先把加乘懒标记下传再清空。解封时，先把标记清空（不下传）再把 $t$ 转移到区间和 $s$ 上。

总之就是一个特大难写题。

```cpp
#include <iostream>
#include <vector>
#include <array>
using namespace std;

#define MAXN 200005
#define MOD 1000000007ll
#define ls (p << 1)
#define rs (p << 1 | 1)

using ll = long long;
using pll = array<ll, 2>;

int n, m;

ll a[MAXN];

struct Tree
{
    ll s, l;
    ll a, m = 1;
    ll t, v;
} t[MAXN << 2];

void pushdown(int p)
{
    if (t[p].v)
    {
        t[p].m = 1;
        t[p].a = 0;
    }
    if (t[p].m != 1)
    {
        t[ls].s = t[ls].s * t[p].m % MOD;
        t[ls].m = t[ls].m * t[p].m % MOD;
        t[ls].a = t[ls].a * t[p].m % MOD;
        t[rs].s = t[rs].s * t[p].m % MOD;
        t[rs].m = t[rs].m * t[p].m % MOD;
        t[rs].a = t[rs].a * t[p].m % MOD;
        t[p].m = 1;
    }
    if (t[p].a)
    {
        t[ls].s = (t[ls].s + t[p].a * t[ls].l % MOD) % MOD;
        t[ls].a = (t[ls].a + t[p].a) % MOD;
        t[rs].s = (t[rs].s + t[p].a * t[rs].l % MOD) % MOD;
        t[rs].a = (t[rs].a + t[p].a) % MOD;
        t[p].a = 0;
    }
}

void pushup(int p)
{
    if (t[p].v == 0)
    {
        t[p].s = (t[ls].s + t[rs].s) % MOD;
        t[p].l = (t[ls].l + t[rs].l) % MOD;
        t[p].t = (t[ls].t + t[rs].t) % MOD;
    }
}

void build(int p, int l, int r)
{
    if (l == r)
    {
        t[p] = {a[l], 1, 0, 1, 0, 0};
        return;
    }
    int mid = (l + r) >> 1;
    build(ls, l, mid);
    build(rs, mid + 1, r);
    pushup(p);
}

void add(int p, int l, int r, int ql, int qr, ll v)
{
    if (t[p].v)
    {
        return;
    }
    if (ql <= l && r <= qr)
    {
        t[p].s = (t[p].s + t[p].l * v % MOD) % MOD;
        t[p].a = (t[p].a + v) % MOD;
        return;
    }
    pushdown(p);
    int mid = (l + r) >> 1;
    if (mid >= ql)
    {
        add(ls, l, mid, ql, qr, v);
    }
    if (mid < qr)
    {
        add(rs, mid + 1, r, ql, qr, v);
    }
    pushup(p);
}

void mul(int p, int l, int r, int ql, int qr, ll v)
{
    if (t[p].v)
    {
        return;
    }
    if (ql <= l && r <= qr)
    {
        t[p].s = t[p].s * v % MOD;
        t[p].m = t[p].m * v % MOD;
        t[p].a = t[p].a * v % MOD;
        return;
    }
    pushdown(p);
    int mid = (l + r) >> 1;
    if (mid >= ql)
    {
        mul(ls, l, mid, ql, qr, v);
    }
    if (mid < qr)
    {
        mul(rs, mid + 1, r, ql, qr, v);
    }
    pushup(p);
}

void lck(int p, int l, int r, int ql, int qr)
{
    if (ql <= l && r <= qr)
    {
        if (!t[p].v && l != r)
        {
            pushdown(p);
        }
        t[p].v++;
        t[p].l = 0;
        t[p].t = (t[p].t + t[p].s) % MOD;
        t[p].s = 0;
        return;
    }
    pushdown(p);
    int mid = (l + r) >> 1;
    if (mid >= ql)
    {
        lck(ls, l, mid, ql, qr);
    }
    if (mid < qr)
    {
        lck(rs, mid + 1, r, ql, qr);
    }
    pushup(p);
}

void ulc(int p, int l, int r, int ql, int qr)
{
    if (ql <= l && r <= qr)
    {
        t[p].v--;
        if (t[p].v == 0)
        {
            t[p].a = 0;
            t[p].m = 1;
            if (l == r)
            {
                swap(t[p].s, t[p].t);
                t[p].l = 1;
            }
            else
            {
                pushup(p);
            }
        }
        return;
    }
    pushdown(p);
    int mid = (l + r) >> 1;
    if (mid >= ql)
    {
        ulc(ls, l, mid, ql, qr);
    }
    if (mid < qr)
    {
        ulc(rs, mid + 1, r, ql, qr);
    }
    pushup(p);
}

ll sum(int p, int l, int r, int ql, int qr)
{
    if (ql <= l && r <= qr)
    {
        return (t[p].s + t[p].t) % MOD;
    }
    pushdown(p);
    int mid = (l + r) >> 1;
    ll res = 0;
    if (mid >= ql)
    {
        res = (res + sum(ls, l, mid, ql, qr)) % MOD;
    }
    if (mid < qr)
    {
        res = (res + sum(rs, mid + 1, r, ql, qr)) % MOD;
    }
    return res;
}

vector<pll> q[MAXN];

int main()
{
    cin >> n >> m;
    for (int i = 1; i <= n; i++)
    {
        cin >> a[i];
    }
    build(1, 1, n);
    for (int i = 1; i <= m; i++)
    {
        int op, l, r;
        ll x;
        cin >> op >> l >> r;
        if (op == 1)
        {
            cin >> x;
            add(1, 1, n, l, r, x);
        }
        else if (op == 2)
        {
            cin >> x;
            mul(1, 1, n, l, r, x);
        }
        else if (op == 3)
        {
            cin >> x;
            lck(1, 1, n, l, r);
            q[i + x].push_back(pll{l, r});
        }
        else
        {
            cout << sum(1, 1, n, l, r) << endl;
        }
        for (auto [l, r] : q[i])
        {
            ulc(1, 1, n, l, r);
        }
    }
    return 0;
}

```

---


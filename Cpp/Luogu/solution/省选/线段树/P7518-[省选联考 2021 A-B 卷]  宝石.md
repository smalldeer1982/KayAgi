# [省选联考 2021 A/B 卷]  宝石

## 题目背景

**链的部分分官方数据有误。这里已经修改，如仍有误请反馈。**

## 题目描述

欧艾大陆上有 $n$ 座城市，城市从 $1 \sim n$ 编号，所有城市经由 $n - 1$ 条无向道路互相连通，即 $n$ 座城市与 $n - 1$ 条道路构成了一棵树。

每座城市的集市上都会出售宝石，总共有 $m$ 种不同的宝石，用 $1 \sim m$ 编号。$i$ 号城市的集市出售的是第 $w_i$ 种宝石，一种宝石可能会在多座城市的集市出售。

K 神有一个宝石收集器。这个宝石收集器能按照顺序收集至多 $c$ 颗宝石，其收集宝石的顺序为：$P_1, P_2, \ldots , P_c$。更具体地，收集器需要先放入第 $P_1$ 种宝石，然后才能再放入第 $P_2$ 种宝石，之后再能放入第 $P_3$ 种宝石，以此类推。其中 $P_1, P_2, \ldots , P_c$ 互不相等。

K 神到达一个城市后，如果该城市的集市上出售的宝石种类和当前收集器中需要放入的种类相同，则他可以在该城市的集市上购买一颗宝石并放入宝石收集器中；否则他只会路过该城市什么都不做。

现在 K 神给了你 $q$ 次询问，每次给出起点 $s_i$ 与终点 $t_i$，他想知道如果从 $s_i$ 号城市出发，沿最短路线走到 $t_i$ 号城市后，他的收集器中最多能收集到几个宝石？（在每次询问中，收集器内初始时没有任何宝石。起点与终点城市集市上的宝石可以尝试被收集）

## 说明/提示

**【数据范围】**

对于所有测试数据：$1 \le n, q \le 2 \times {10}^5$，$1 \le c \le m \le 5 \times {10}^4$，$1 \le w_i \le m$。

每个测试点的具体限制见下表：

| 测试点编号 | $n, q \le$ | 特殊限制 |
|:-:|:-:|:-:|
| $1 \sim 2$ | $10$ | 无 |
| $3 \sim 5$ | $1000$ | 无 |
| $6 \sim 10$ | $2 \times {10}^5$ | $m \le 300$ |
| $11 \sim 14$ | $2 \times {10}^5$ | $u_i = i$，$v_i = i + 1$ |
| $15 \sim 20$ | $2 \times {10}^5$ | 无 |

## 样例 #1

### 输入

```
7 3 3
2 3 1
2 1 3 3 2 1 3
1 2
2 3
1 4
4 5
4 6
6 7
5
3 5
1 3
7 3
5 7
7 5
```

### 输出

```
2
2
2
3
1
```

## 样例 #2

### 输入

```
见附件中的 gem/gem2.in```

### 输出

```
见附件中的 gem/gem2.ans```

## 样例 #3

### 输入

```
见附件中的 gem/gem3.in```

### 输出

```
见附件中的 gem/gem3.ans```

# 题解

## 作者：wuhao2005 (赞：30)

### **题面：**
-----------
[题目链接](https://www.luogu.com.cn/problem/P7518)

### **题解：**
-----------
提供赛时思路，比较清真，只要主席树加倍增就行了

我们考虑对给进来的 $P_i$ 重标号一下，使之成为 $1\sim c$ 的序列，同时对每个 $i$ 的 $w$ 值也进行对应的重标 

那么题意可以转化为求一条路径上 $u\rightarrow v$ 的最大的 $cnt$ ，满足 $cnt\le c$ 且 $1\sim cnt$ 在这条路径上依次出现

显然在这条路径上，每个权值尽量早的出现最优

对于一条路径，可以拆分一条上链和一条下链

那么我们对于每个点 $u$ 可以倍增预处理 $f_1[u][i]$ 表示在 $u$ 到根的链上权值为 $w[u]+2^i$ 的节点最近在哪里

和 $f_2[u][i]$ 表示在 $u$ 到根的链上权值为 $w[u]-2^i$ 的节点最近在哪里（为了处理下链）

对于上链可以直接求出权值为 $1$ 的节点在哪里（因为必须从 $1$ 开始起跳，怎么查找从 $u$ 到根的链上权值为 $x$ 的节点待会讲），并从 $1$ 开始起跳，一直跳到深度不小于 $lca$ 的节点 

这样我们就得到了上链最大能匹配到哪里，不妨设为 $x$

那么我们可以在下链上二分答案，下界为 $x+1$ ，上界为 $c$，在 $v$ 到根的链上查找权值为 $mid$ 的点，并利用 $f_2$ 不断往上跳，找到最大能匹配的后缀，看看是否能和前 $1\sim x$ 拼接在一起

（答案显然具有单调性的，因为如果权值较大的点能和上链拼接在一起，那么权值较小的点更加可以和上链拼在一起了）

至于二分的下界是 $x+1$ 的原因是 $x$ 是在上链上出现的，不保证在下链上也存在 $x$ 

至于如何在线求一条到根的链上权值为 $p$ 的点最深在哪里可以主席树一下，就是每个孩子在他父亲的线段树上更改一条链就行了（可能有点表述不清，可以看代码）

复杂度 $O(n\log^2n)$ ，常数可能有点大，因为倍增的 $\log$ 是要跑满的，不过应该能过题

说句题外话，考试的时候没注意到二分的下界是 $x+1$ ，导致代码出错了

其实如果测最大的那个样例应该是可以测出来的，但是我不会手动开大 Windows 的栈空间，一个 dfs 就跑不出来，还以为思路错了，想了半天

这里记录下 Windows 下手动开大栈空间的方法

在 dev 的工具那一栏的编译选项，在“编译时加入以下命令”那个地方加上

`-Wl,--stack=1024000000`

所有局部变量和函数都是算在栈空间内的，上面那个 `=` 号后面的东西是以 `B` 为单位的

一般来说是递归深度过大导致爆栈的

和 Ubuntu 的

编译前在终端加上 `ulimit -s 1024000`

这个是以 `KB` 为单位的
### **Code：**
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ls(x) t[x].ch[0]
#define rs(x) t[x].ch[1]
const int N = 2e5+9;
int read(){
	int f=1,x=0;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-') f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+ch-'0';ch=getchar();}
	return f*x;
}

int n,m,c,q,p[N],w[N],vt[N];
int head[N],tot;
struct pp{int nxt,to;}g[N<<1];
void add(int u,int v){g[++tot].nxt=head[u],g[tot].to=v,head[u]=tot;}
int pa[N],dep[N],f[N][21];

void dfs1(int u,int fa){
	pa[u]=fa,dep[u]=dep[fa]+1,f[u][0]=fa;
	for(int i=head[u];i!=-1;i=g[i].nxt){
		int v=g[i].to;if(v==fa) continue;dfs1(v,u);
	}
	return ;
}

int lca(int u,int v){
	if(dep[u]<dep[v]) swap(u,v);
	for(int i=20;i>=0;i--) if(dep[f[u][i]]>=dep[v]) u=f[u][i];
	if(u==v) return u;
	for(int i=20;i>=0;i--) if(f[u][i]!=f[v][i]) u=f[u][i],v=f[v][i];
	return f[u][0];
}

int col[N];
int f1[N][21],f2[N][21];
void dfs2(int u,int fa){
	int hy=col[w[u]];
	col[w[u]]=u;
	f1[u][0]=col[w[u]+1],f2[u][0]=col[w[u]-1];
	for(int i=head[u];i!=-1;i=g[i].nxt){
		int v=g[i].to;if(v==fa) continue;dfs2(v,u);
	}
	col[w[u]]=hy;
	return ;
}


int rt[N],cnt;
struct seg{int ch[2],pos;}t[N*64];
int New(){++cnt;ls(cnt)=rs(cnt)=0,t[cnt].pos=0;return cnt;}
void modify(int &c,int pt,int l,int r,int x,int y){
	if(!c) c=New();if(l==r){t[c].pos=y;return ;}int mid=(l+r)>>1;
	if(x<=mid) rs(c)=rs(pt),modify(ls(c),ls(pt),l,mid,x,y);
	if(x>mid) ls(c)=ls(pt),modify(rs(c),rs(pt),mid+1,r,x,y);return ;
}
int query(int c,int l,int r,int x){
	if(!c) return 0;if(l==r) return t[c].pos;
	int mid=(l+r)>>1;if(x<=mid) return query(ls(c),l,mid,x);
	if(x>mid) return query(rs(c),mid+1,r,x);
}

void dfs3(int u,int fa){
	modify(rt[u],rt[fa],1,n,w[u],u);
	for(int i=head[u];i!=-1;i=g[i].nxt){
		int v=g[i].to;if(v==fa) continue;dfs3(v,u);
	}	
	return ;
}

int jump(int u,int d){
	if(dep[u]<d) return 0;
	for(int i=20;i>=0;i--) if(dep[f1[u][i]]>=d) u=f1[u][i];
	return w[u];
}

int jump2(int u,int d){
	for(int i=20;i>=0;i--) if(dep[f2[u][i]]>=d) u=f2[u][i];
	return w[u];
}

int check(int v,int x,int d,int se){
	int u=query(rt[v],1,n,x);
	if(dep[u]<d) return 0;
	int st=jump2(u,d);
	return (st<=(se+1));
}


int main(){
	memset(head,-1,sizeof(head));tot=0;
	n=read(),m=read(),c=read();
	for(int i=1;i<=c;i++) p[i]=read();
	for(int i=1;i<=n;i++) w[i]=read();
	for(int i=1;i<n;i++){int u=read(),v=read();add(u,v);add(v,u);}
	memset(vt,0,sizeof(vt));
	int kt=c;
	for(int i=1;i<=c;i++) vt[p[i]]=i;
	for(int i=1;i<=n;i++){if(!vt[w[i]]) vt[w[i]]=++kt;w[i]=vt[w[i]];}
	dfs1(1,0);
	for(int j=1;j<=20;j++) for(int i=1;i<=n;i++) f[i][j]=f[f[i][j-1]][j-1];
	q=read();
	memset(rt,0,sizeof(rt));memset(col,0,sizeof(col));
	dfs2(1,0);
	for(int j=1;j<=20;j++) for(int i=1;i<=n;i++) f1[i][j]=f1[f1[i][j-1]][j-1],f2[i][j]=f2[f2[i][j-1]][j-1];
	cnt=0;dfs3(1,0);
	for(int i=1;i<=q;i++){
		int u=read(),v=read();int pt=lca(u,v);
		int fi=query(rt[u],1,n,1);
		int se=min(jump(fi,dep[pt]),c);
		int l=se+1,r=c,ans=se;
		while(l<=r){
			int mid=(l+r)>>1;
			if(check(v,mid,dep[pt],se)) l=mid+1,ans=mid;
			else r=mid-1;
		}
		printf("%d\n",ans);
	}
	return 0;
}
```

---

## 作者：Lice (赞：26)

Updated 2021/4/13：更新了代码（原代码可能无法处理 $s=o$ 并且 $W_o=1$ 的情况），以及加了一些细节说明。

### Description

给定一棵树，$n$ 个顶点，每个点有一个宝石，类型为 $W_i$，约定 $W_i\in [1,m]$。你有一个收集器，可以收集至多 $c$ 个宝石，并且收集顺序必须为 $P_1,P_2,\cdots, P_c$，其中 $P_1\sim P_c$ 互不相同。先有 $q$ 次询问，每次询问一条有向路径 $s_i\to t_i$，求依次最多可以收集多少宝石。

### Hint

$1\le n, q\le 2\times 10^5$，$1\le c\le m\le 5\times 10^4$

### Solution

不知道为什么，我遇见这种树上路径问题就很自然的想到点分治，于是考场上就有了这个神奇做法。

为方便，将 $W_x$ 的含义改为原 $W_x$ 在 $P$ 中的下标，换句话说，即“排名”。

首先离线询问，对于当前分治的连通块，处理出所有包含于块内、经过分治中心的询问的答案。注意到将路径按分治中心 $o$ 分为两部分后，两部分本质不相同（显然吧），因此分别考虑 $s\to o,o\to t$ 两部分。

对于 $s\to o$ 部分，我们希望选出的宝石尽可能多，理由不仅仅是最大化答案，还因为我们可以有余地去和 $o\to t$ 部分对接。那么不难对每个点求出其到 $o$ 的路径上最多选多少宝石，具体的，求出路径上第一个 $P_1$ 出现的位置，对于每个 $x$ 求 $W_x +1$ 对应的第一个位置即可。

对于 $o\to t$ 部分，我们希望可以与前一部分对接，那必然是从 $t$ 开始，选逐渐递减的几个，并且最后那个尽可能小。用类似上面的方法也可以求出，注意如果上面包含了 $o$ 这里就最好刻意避开。

最后考虑在后半部分中任何处理询问。很显然答案有可二分性，考虑二分答案。如何检验一个 $mid$ 是否可达？不妨先在 $t\to o$ 的路径上找到第一个 $mid$ 的位置（如果找不到当然爪巴了），然后在这个位置往上递减（每次减一）地跳，看看能跳到多小，记其为 $y$。令 $s\to o$ 路径上最多选出 $x$ 个，那么若 $x+1\ge y$，说明能接上，当前这个 $mid$ 是可行的。

最后复杂度 $O(n\log n+q\log m)$，点分一只 $\log$，后面对于每个询问做一次 $O(\log m)$ 的二分答案。

### Implementation

为什么这要一个单独说明呢？因为我在考场上细节没想清楚，导致写的很谔谔（绝对没有下面代码那么简洁），花了 3 个多小时，所以清晰的实现思路同算法一样重要。

下面是我的实现，不一定是最简洁的。

首先是传询问：每一次分治中都要对询问分类：跨越分治中心 $o$ 与否。染色法是一个好东西：我们对分治块中每棵子树染上不同的颜色，如果 $s,t$ 的颜色相同，那就是下一层递归该干的事情了（注意特判 $s=t=o$。特别是 $s=o$，需要加判断 $W_o$ 是否 $=1$）。

然后是求出一条 $x\to o$ 的路径求出最多选几个宝石。一波 Dfs 求出上面第一个 $1$ 的位置，第一个 $W_x+1$ 的位置（可以借助可撤销数组完成），通过这两个再一波 Dfs 求出每个点向上选出一个值域连续段（不一定从一开始）的长度即可，先往上找到一个 $1$，然后连着走后继。

$o\to t$ 部分异曲同工，注意最后二分答案的初始左边界为，前半部分的答案 $+1$。不 $+1$ 过不了大样例？这个我也不清楚。

### Code

```cpp
#include <algorithm>
#include <cctype>
#include <cstdio>
#include <vector>

inline int read() {
  int x = 0; char c; while (!isdigit(c = getchar()));
  do x = (x << 1) + (x << 3) + c - '0'; while (isdigit(c = getchar()));
  return x;
}

const int N = 2e5 + 5;
const int M = 5e4 + 5;

int n, m, c, W[N];
int rank[N];
std::vector<int> adj[N];

struct revArray {
  int dat[M];
  std::vector<std::pair<int, int> > his;

  inline void edit(int x, int v) {
    his.emplace_back(x, dat[x]);
    dat[x] = v;
  }
  inline int operator [] (const int& x) const {
    return dat[x];
  }
  inline void back() {
    auto last = his.back();
    dat[last.first] = last.second;
    his.pop_back();
  }
} rec;

int q, ans[N];
struct request {
  int s, t, idx;
};

int maxp[N], siz[N], root;
bool centr[N];

int get_size(int x, int f) {
  siz[x] = 1;
  for (auto y : adj[x]) if (y != f && !centr[y])
    siz[x] += get_size(y, x);
  return siz[x];
}
void get_centr(int x, int f, int t) {
  maxp[x] = 0;
  for (auto y : adj[x]) if (y != f && !centr[y])
    get_centr(y, x, t), maxp[x] = std::max(maxp[x], siz[y]);
  maxp[x] = std::max(maxp[x], t - siz[x]);
  if (maxp[x] < maxp[root]) root = x;
}

int color[N];
void set_color(int x, int f, int c) {
  color[x] = c;
  for (auto y : adj[x]) if (y != f && !centr[y])
    set_color(y, x, c);
}

int nxt[N], fir[N], pre[N], inc[N], dec[N];
void get_nxt_fir(int x, int f) {
  rec.edit(W[x], x);
  nxt[x] = rec[W[x] + 1], fir[x] = rec[1];
  for (auto y : adj[x]) if (y != f && !centr[y])
    get_nxt_fir(y, x);
  rec.back();
}
void get_inc(int x, int f) {
  inc[x] = nxt[x] ? inc[nxt[x]] : W[x];
  for (auto y : adj[x]) if (y != f && !centr[y])
    get_inc(y, x);
}
void get_pre(int x, int f) {
  rec.edit(W[x], x);
  if (W[x]) pre[x] = rec[W[x] - 1];
  for (auto y : adj[x]) if (y != f && !centr[y])
    get_pre(y, x);
  rec.back();
}
void get_dec(int x, int f) {
  dec[x] = pre[x] ? dec[pre[x]] : W[x];
  for (auto y : adj[x]) if (y != f && !centr[y])
    get_dec(y, x);
}

std::vector<request> subreq[N];
std::vector<request> tosol[N];
void get_ans(int x, int f) {
  if (x != f) rec.edit(W[x], x);
  for (auto qry : tosol[x]) {
    int worst = fir[qry.s] ? inc[fir[qry.s]] : 0;
    int lb = worst + 1, ub = c;
    while (lb <= ub) {
      int mid = (lb + ub) >> 1;
      if (!rec[mid] || dec[rec[mid]] - 1 > worst) ub = mid - 1;
      else lb = mid + 1, ans[qry.idx] = mid;
    }
    ans[qry.idx] = std::max(ans[qry.idx], worst);
  }
  for (auto y : adj[x]) if (y != f && !centr[y])
    get_ans(y, x);
  if (x != f) rec.back();
}
void clear_all(int x, int f) {
  pre[x] = nxt[x] = fir[x] = 0;
  color[x] = inc[x] = dec[x] = 0;
  tosol[x].clear();
  for (auto y : adj[x]) if (y != f && !centr[y])
    clear_all(y, x);
}

void solve(int x, std::vector<request>& req) {
  if (req.empty()) return;

  maxp[root = 0] = N;
  get_centr(x, 0, get_size(x, 0));
  centr[root] = 1;

  std::vector<request> cur;
  for (auto y : adj[root]) if (!centr[y])
    set_color(y, root, y);
  for (auto qry : req)
    if (color[qry.s] == color[qry.t]) {
      if (!color[qry.s]) ans[qry.idx] = (W[root] == 1);
      else subreq[color[qry.s]].push_back(qry);
    } else cur.push_back(qry);
  
  rec.edit(W[root], root);
  fir[root] = W[root] == 1 ? root : 0;
  for (auto y : adj[root]) if (!centr[y])
    get_nxt_fir(y, root);
  rec.back();

  inc[root] = W[root];
  for (auto y : adj[root]) if (!centr[y])
    get_inc(y, root);
  
  for (auto y : adj[root]) if (!centr[y])
    get_pre(y, root);
  
  for (auto y : adj[root]) if (!centr[y])
    get_dec(y, root);
  
  for (auto qry : cur)
    tosol[qry.t].push_back(qry);
  get_ans(root, root);

  clear_all(root, 0);
  std::vector<std::vector<request> > copy;
  for (auto y : adj[root]) if (!centr[y])
    copy.push_back(subreq[y]), subreq[y].clear();
  auto it = copy.begin();
  for (auto y : adj[root]) if (!centr[y])
    solve(y, *it), ++it;
}

signed main() {
  n = read(), m = read(), c = read();

  for (int i = 1; i <= c; i++) rank[read()] = i;
  for (int i = 1; i <= n; i++) W[i] = rank[read()];

  for (int i = 1; i < n; i++) {
    int u = read(), v = read();
    adj[u].push_back(v), adj[v].push_back(u);
  }

  std::vector<request> req(q = read());
  for (int i = 0; i < q; i++)
    req[i].s = read(), req[i].t = read(), req[i].idx = i + 1;
  solve(1, req);

  for (int i = 1; i <= q; i++)
    printf("%d\n", ans[i]);
  return 0;
}
```

---

## 作者：vectorwyx (赞：17)

考场上离正解最近的一道题 >_<


------------
对于询问 $x,y$，设 $k=lca(x,y)$，那么 $x$ 到 $y$ 这段就可以分成 $x$ 到 $k$、$k$ 到 $y$。也就是先向上走（第一段）再向下走（第二段）。由于向下走始终比向上走难处理，所以需要先二分答案。设答案为 $ans$，那么向下走就变为了从 $y$ 开始，向上走到第一个拥有宝石 $P_{ans}$ 的点 $y_1$；再从 $y_1$ 开始，向上走到第一个拥有宝石 $P_{ans-1}$ 的点 $y_2$ ……以此类推，直到走到 $k$。这样就把一段向上一段向下转化成了两段向上，故我们只需要维护向上走的过程。

最直接的想法是在原树上一步步地走，每次走向当前结点的父亲然后更新答案。这样做是 $O(n)$ 的。能否更进一步呢？仔细观察这个过程，它的实质是**从当前结点向上跳到第一个拥有某种宝石的点**，然后重复这个过程直到跳过了 $k$。很容易联想到子序列自动机，借鉴一下，令 $up_{i,j}$ 表示 $i$ 及 $i$ 的祖先中离 $i$ 最近的拥有宝石 $j$ 的点是哪个，先 $O(nm)$ 地预处理出 $up$ 数组，查询时在 $up$ 数组上暴力跳，总时间复杂度为 $O(nm)+O(q\log(m)m)$。

还能不能更进一步呢？以第一段为例，在 $up$ 数组上跳的全过程是这样的：$x\rightarrow (x_1=up_{x,P_1})\rightarrow (x_2=up_{x_1,P_2})\rightarrow (x_3=up_{x_2,P_3})\cdots$。记一步表示从点 $x$ 跳到 $up_{x,w_x+1}$，记录从点 $x$ 跳 $2^0,2^1,2^2,\cdots$ 步会跳到哪里。如果忽略最开始从 $x$ 跳到 $up_{x,1}$，第一段就可以用倍增来维护了，第二段同理。

但怎么解决最开始的那一步呢？换句话说，怎么优雅地维护 $up$ 数组？注意到 $i$ 所对应的 $up$ 数组与它父亲的 $up$ 数组只有一处不同，因此我们可以把查询操作离线下来。先跑一遍 dfs 求出每一个结点 $i$ 的 $up_{i,1}$ 的值是多少，然后对于每一个结点 $i$，记录所有以 $i$ 为终点的查询操作，随后再在树上跑一遍 dfs，边回答询问边更新当前结点的 $up$ 数组。总时间复杂度为 $O(n\log{n}+q\log^2{m})$。

代码如下：
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<algorithm>
#include<vector>
#define fo(i,x,y) for(int i=x;i<=y;++i)
#define go(i,x,y) for(int i=x;i>=y;--i)
using namespace std;

inline int read(){
	int x=0,f=1;
	char ch=getchar();
	while(!isdigit(ch)){
		if(ch=='-') f=-1;
		ch=getchar();
	}
	while(isdigit(ch)){
		x=(x<<1)+(x<<3)+(ch^48);
		ch=getchar();
	}
	return x*f;
}

void file(){
	freopen("gem.in","r",stdin);
	freopen("gem.out","w",stdout);
}

const int N=2e5+5,M=305;
struct Edge{
	int to,next;
}e[N<<1];
int head[N],tot,w[N],P[N],fa[N][20],dep[N],n,m,c,lgn,lgm,up1[N][20],up2[N][20],U[N],rk[N],up[N];
int X[N],Y[N],Ans[N];
vector<int> g[N]; 
//int fl[N],block[205][M],T,top,pos[N];
//up[i]表示i及i的祖先中离i最近的拥有宝石P[1]的点
//up1[i][j]表示i及i的祖先中离i最近的拥有宝石P[rk[w[i]]+(1<<j)]的点 

void connect(int x,int y){
	e[++tot]=(Edge){y,head[x]};
	head[x]=tot; 
}

void dfs(int x,int fr){
	int t=U[w[x]];
	U[w[x]]=x;
	fa[x][0]=fr;
	dep[x]=dep[fr]+1;
	up[x]=U[P[1]];
	up1[x][0]=U[P[rk[w[x]]+1]];
	up2[x][0]=U[P[rk[w[x]]-1]];
	for(int i=head[x];i;i=e[i].next){
		int p=e[i].to;
		if(p==fr) continue;
		dfs(p,x);
	}
	U[w[x]]=t;
}

void bz(){
	fo(j,1,lgn)
		fo(i,1,n) fa[i][j]=fa[fa[i][j-1]][j-1];
	fo(j,1,lgm)
		fo(i,1,n) up1[i][j]=up1[up1[i][j-1]][j-1],up2[i][j]=up2[up2[i][j-1]][j-1];
}

int lca(int x,int y){
	if(dep[x]<dep[y]) swap(x,y);
	go(i,lgn,0) if(dep[fa[x][i]]>=dep[y]) x=fa[x][i];
	if(x==y) return x;
	go(i,lgn,0) if(fa[x][i]!=fa[y][i]) x=fa[x][i],y=fa[y][i];
	return fa[x][0];
}

int solve(int x,int y){
	//printf("solve(%d,%d)\n",x,y);
	int k=lca(x,y),now=0,_now;
	if(dep[up[x]]>=dep[k]){
		x=up[x];
		go(i,lgm,0) if(dep[up1[x][i]]>=dep[k]) x=up1[x][i];
		now=rk[w[x]];
	}
	//printf("x=%d now=%d\n",x,now);
	int L=now+1,R=m,mid,ans=now;
	while(L<=R){
		mid=(L+R)>>1;
		_now=mid+1;
		if(dep[U[P[mid]]]>dep[k]){
			y=U[P[mid]];
			go(i,lgm,0) if(dep[up2[y][i]]>dep[k]) y=up2[y][i];
			_now=rk[w[y]];
		}
		//printf("y=%d _now=%d mid=%d\n",y,_now,mid);
		if(_now-now<=1) L=mid+1,ans=mid;
		else R=mid-1;
	}
	//printf("ans=%d\n",ans);
	return ans;
}

void _dfs(int x,int fr){
	int t=U[w[x]];
	U[w[x]]=x;
	int si=g[x].size();
	fo(i,0,si-1) Ans[g[x][i]]=solve(X[g[x][i]],Y[g[x][i]]);
	for(int i=head[x];i;i=e[i].next){
		int p=e[i].to;
		if(p==fr) continue;
		_dfs(p,x);
	}
	U[w[x]]=t;
}

int main(){
	//file();
	cin>>n>>m>>c;lgn=log(n)/log(2);lgm=log(m)/log(2);
	fo(i,1,c) P[i]=read(),rk[P[i]]=i;
	fo(i,1,n) w[i]=read();
	fo(i,1,n-1){
		int x=read(),y=read();
		connect(x,y);
		connect(y,x);
	}
	dfs(1,0);
	bz();
	/*fo(i,1,n){
		printf("%d,%d:\n",i,up[i]);
		fo(j,0,lgm) printf("%d ",up1[i][j]);puts("");
		fo(j,0,lgm) printf("%d ",up2[i][j]);puts("");
	}*/
	int q=read();
	fo(i,1,q){
		X[i]=read(),Y[i]=read();
		g[Y[i]].push_back(i); 
	}
	_dfs(1,0);
	fo(i,1,q) printf("%d\n",Ans[i]);
	return 0;
}
/*
7 3 3
2 3 1
2 1 3 3 2 1 3
1 2
2 3
1 4
4 5
4 6
6 7
5
3 5
1 3
7 3
5 7
7 5
--------------------------------
2
2
2
3
1
*/
```


---

## 作者：wmy_goes_to_thu (赞：17)

我不会点分治，想不出主席树的做法，赛场果断树剖+倍增。

看到链的部分分已经很明确了，就是在链的基础上多用一个树剖多个 log 就行。

预处理部分：

定义颜色 $a$ 能接上颜色 $b$：存在 $1<x<c$，使得 $p_x=a,p_{x+1}=b$。

分别记录 $pref_a$ 表示一个节点在树剖的 dfs 序之前（从后往前树）第一个 $a$ 能接上的节点的 dfs 序值。$nxtf$ 同理。然后处理倍增数组，$pf_{i,j}=pf_{pf_{i,j-1},j-1}$，$nf$ 同理。复杂度是 $nlogn$。

查询部分：

把一个路径看成向上爬和向下跑两个部分，分别拆成若干段重链。对于向上的每一段，二分求出第一个现在的颜色能接上的节点，然后倍增得到这段重链的最后连着接上的颜色，向下跑把 $pf$ 换成 $nf$ 之后也差不多，用 $Qlog^2n$ 的速度解决。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int w[200005],p[200005],nxt[200005],dep[200005],fa[200005],ffa[200005],sz[200005],bg[200005],gb[200005],tot=0;
int nxtf[21][200005],pref[21][200005],q1[200005],q2[200005],bzf[21][200005];
vector<int>g[200005],d[200005];
void dfs1(int x,int la)
{
	sz[x]=1;
	for(int i=0;i<g[x].size();i++)
	{
		int cu=g[x][i];
		if(cu==la)continue;
		dep[cu]=dep[x]+1,fa[cu]=bzf[0][cu]=x;
		dfs1(cu,x);
		sz[x]+=sz[cu];
	}
}
void dfs2(int x,int la)
{
	bg[x]=++tot,gb[bg[x]]=x;
	if(sz[x]==1)return;
	int ans=0,w;
	for(int i=0;i<g[x].size();i++)
	{
		int cu=g[x][i];
		if(cu==la)continue;
		if(ans<sz[cu])ans=sz[cu],w=cu;
	}
	ffa[w]=ffa[x],dfs2(w,x);
	for(int i=0;i<g[x].size();i++)
	{
		int cu=g[x][i];
		if(cu==la||cu==w)continue;
		ffa[cu]=cu,dfs2(cu,x);
	}
}
int lca(int x,int y)
{
	if(dep[x]<dep[y])swap(x,y);
	for(int i=20;i>=0;i--)if(dep[x]-dep[y]>=(1<<i))x=bzf[i][x];
	if(x==y)return x;
	for(int i=20;i>=0;i--)if(bzf[i][x]!=bzf[i][y])x=bzf[i][x],y=bzf[i][y];
	return fa[x];
}
inline int read()
{
	char c=getchar();
	while(c<'0'||c>'9')c=getchar();
	int ff=0;
	while(c>='0'&&c<='9')ff=ff*10+(c-'0'),c=getchar();
	return ff;
}
int main()
{
	int n=read(),m=read(),c=read();
	for(int i=1;i<=c;i++)p[i]=read();
	for(int i=2;i<=c;i++)nxt[p[i-1]]=p[i];
	for(int i=1;i<=n;i++)w[i]=read();
	for(int i=1;i<n;i++)
	{
		int u=read(),v=read();
		g[u].push_back(v);
		g[v].push_back(u);
	}
	dep[1]=1,dfs1(1,0);
	ffa[1]=1,dfs2(1,0);
	for(int i=1;i<=n;i++)d[w[gb[i]]].push_back(i);
	for(int i=1;i<=n;i++)
	{
		int gg=nxt[w[gb[i]]],ww;
		if(!gg)continue;
		ww=lower_bound(d[gg].begin(),d[gg].end(),i)-d[gg].begin();
		if(ww!=0)pref[0][i]=d[gg][ww-1];
		if(ww!=d[gg].size())nxtf[0][i]=d[gg][ww];
	}
	for(int j=1;j<=20;j++)for(int i=1;i<=n;i++)
	{
		nxtf[j][i]=nxtf[j-1][nxtf[j-1][i]];
		pref[j][i]=pref[j-1][pref[j-1][i]];
		bzf[j][i]=bzf[j-1][bzf[j-1][i]];
	}
	int q=read();
	while(q--)
	{
		int s=read(),t=read();
		int lc=lca(s,t),gd=0,flag=0;
		while(dep[s]>=dep[lc])
		{
			if(gd==c||!(d[p[gd+1]].size()))
			{
				printf("%d\n",gd);
				flag=1;
				break;
			}
			int tttt=upper_bound(d[p[gd+1]].begin(),d[p[gd+1]].end(),bg[s])-d[p[gd+1]].begin()-1,fff=ffa[s];
			if(ffa[s]==ffa[lc])fff=lc;
			if(tttt==-1||d[p[gd+1]][tttt]<bg[fff])
			{
				s=fa[ffa[s]];
				continue;
			}
			int wz=d[p[gd+1]][tttt];
			gd++;
			for(int i=20;i>=0;i--)if(pref[i][wz]>=bg[fff])gd+=1<<i,wz=pref[i][wz];
			s=fa[ffa[s]];
		}
		if(flag)continue;
		int ott=0;
		while(ffa[t]!=ffa[lc])
		{
			ott++;
			q1[ott]=bg[ffa[t]],q2[ott]=bg[t];
			t=fa[ffa[t]];
		}
		if(t!=lc)
		{
			int tt=t;
			for(int i=20;i>=0;i--)if(dep[tt]-dep[lc]>(1<<i))tt=bzf[i][tt];
			ott++;
			q1[ott]=bg[tt],q2[ott]=bg[t];
		}
		for(int i=ott;i>=1;i--)
		{
			if(gd==c||!(d[p[gd+1]].size()))
			{
				printf("%d\n",gd);
				flag=1;
				break;
			}
			int tttt=lower_bound(d[p[gd+1]].begin(),d[p[gd+1]].end(),q1[i])-d[p[gd+1]].begin();
			if(tttt==d[p[gd+1]].size()||d[p[gd+1]][tttt]>q2[i])continue;
			int wz=d[p[gd+1]][tttt];
			gd++;
			for(int j=20;j>=0;j--)if(nxtf[j][wz]>0&&nxtf[j][wz]<=q2[i])gd+=1<<j,wz=nxtf[j][wz];
		}
		if(flag)continue;
		printf("%d\n",gd);
	}
	return 0;
}
```

---

## 作者：pigstd (赞：13)

[欢迎来博客园查看](https://www.cnblogs.com/juruo-pigstd/p/14668348.html)。

下文中令 $n,m,q,c$ 同阶。

首先令 $t_{p_i}=i,a_i=t_{a_i}$，那么就相当于找一个 $1-ans$ 的子序列。

首先考虑一个链上的情况，对于一个询问 $(u,v)$，不妨令 $u \le v$，那么显然对于每个点 $i$，它需要跳到它之后的第一个 $j$ 满足 $a_j=a_i+1$，这部分可以用桶解决，然后用倍增 $f1_{i,j}$ 表示点 $i$ 跳 $2^j$ 次之后的结果。对于每次询问 $(u,v)$，找到 $u$ 之后第一个为 $1$ 的节点然后从这个点开始跳，就可以在 $O(n\log n)$ 的时间复杂度内求出答案。

考虑上树。对于一个询问 $(u,v)$，可以将其拆成 $u \to lca$ 的上行路径和 $lca \to v$ 的下行路径。上行路径直接可以通过上述的方法解决，记此时的答案是 $ans$，然而下行路径呢？直接考虑 $lca \to v$ 是比较困难的，考虑二分答案。

不难发现，每次 $lca \to v$ 需要让当前答案递增，那么反着考虑，等价于 $v \to lca$ 让当前答案递减，类似的，设一个 $f2_{i,j}$ 为点 $i$ 跳 $2^j$ 次的结果，每次跳到它祖先中的最深的 $j$ 满足 $a_j = a_i-1$，然后对于每一个 $mid$，`check` 的过程就是让它往前跳然后看能否跳到 $ans+1$ 这个节点，这样就完成了……吗？

还有一个问题：对于每个 $mid$，你要在 $u$ 的祖先中找到第一个 $a_i=mid$ 的点 $i$，然后这样子时间复杂度就爆炸了……

考试的时候我想到这里就不会了，最终只打了暴力+链的分。实际上有个非常简单的方法，把所有询问离线下来然后再 `dfs` 的过程中，用一个桶 $t$，$t_i$ 表示当时的节点祖先中第一个 $a_j=i$ 的 $j$，一边 dfs 一边询问，就可以做到 $O(n \log^2 n)$ 的时间复杂度。

代码也蛮好写的，这种方法可能是最好写的（相比于树剖和点分治），而且跑的也蛮快，可惜考试的时候差了最后一步……


```cpp
#include<bits/stdc++.h>
#define int long long
#define pb push_back
#define mp make_pair
#define x first
#define y second
using namespace std;

inline int read()
{
    char c=getchar();int x=0;bool f=0;
    for(;!isdigit(c);c=getchar())f^=!(c^45);
    for(;isdigit(c);c=getchar())x=(x<<1)+(x<<3)+(c^48);
    if(f)x=-x;return x;
}

const int M=2e5+10;
int n,m,c,a[M],p1[M],pos1[M],pos2[M],pos3[M],ans[M],q;
int de[M],ff[M][25],f1[M][25],f2[M][25];
vector<int>e[M];vector<pair<int,int> >qt[M];

void dp()
{
	for (int j=1;j<=20;j++)
		for (int i=1;i<=n;i++)
			ff[i][j]=ff[ff[i][j-1]][j-1],
			f1[i][j]=f1[f1[i][j-1]][j-1],
			f2[i][j]=f2[f2[i][j-1]][j-1];
}
int LCA(int x,int y)
{
	if (de[x]<de[y])swap(x,y);
	for (int i=20;i>=0;i--)
		if (de[ff[x][i]]>=de[y])x=ff[x][i];
	if (x==y)return x;
	for (int i=20;i>=0;i--)
		if (ff[x][i]!=ff[y][i])
			x=ff[x][i],y=ff[y][i];
	return ff[x][0];
}
void dfs1(int u,int fa)
{
	if (a[u]==1)pos1[u]=u;else pos1[u]=pos1[fa];
	int x1=pos2[a[u]],x2=pos3[a[u]];
	pos2[a[u]]=u,pos3[a[u]]=u;
	f1[u][0]=pos2[a[u]+1],f2[u][0]=pos3[a[u]-1];
	de[u]=de[fa]+1,ff[u][0]=fa;
	for (int i=0;i<e[u].size();i++)
	{
		int to=e[u][i];if (to==fa)continue;
		dfs1(to,u);
	}
	pos2[a[u]]=x1,pos3[a[u]]=x2;
}
bool check(int x,int lca,int v,int pg)
{
	v=pos2[x];if (de[v]<de[lca])return 0;
	int now=x;
	for (int i=20;i>=0;i--)
		if (de[f2[v][i]]>=de[lca])
			now-=1<<i,v=f2[v][i];
	return now<=pg;
}
void dfs2(int u,int fa)
{
	int x=pos2[a[u]];pos2[a[u]]=u;
	for (int i=0;i<qt[u].size();i++)
	{
		int id=qt[u][i].x,s=qt[u][i].y;
		int anss=0,lca=LCA(s,u);
		s=pos1[s];if (de[s]>=de[lca])
		{
			for (int i=20;i>=0;i--)
				if (de[f1[s][i]]>=de[lca])
					s=f1[s][i];
			anss=a[s];
		}//cout<<anss<<endl;
		int tl=anss+1,tr=c,p=anss;
		while(tl<=tr)
		{
			int Mid=(tl+tr)>>1;
			if (check(Mid,lca,u,anss+1))
				tl=Mid+1,p=Mid;
			else tr=Mid-1;
		}
		ans[id]=p;
	}
	for (int i=0;i<e[u].size();i++)
		if (e[u][i]!=fa)dfs2(e[u][i],u);
	pos2[a[u]]=x;
}

signed main()
{
	n=read(),m=read(),c=read();
	for (int i=1;i<=c;i++)p1[read()]=i;
	for (int i=1;i<=n;i++)a[i]=p1[read()];
	for (int i=1;i<n;i++)
	{
		int u=read(),v=read();
		e[u].pb(v),e[v].pb(u);
	}
	dfs1(1,0),dp();
	q=read();
	for (int i=1;i<=q;i++)
	{
		int u=read(),v=read();
		qt[v].pb(mp(i,u));
	}dfs2(1,0);
	for (int i=1;i<=q;i++)
		cout<<ans[i]<<endl;
	return 0;
}
```

---

## 作者：QwQcOrZ (赞：11)

考场上 D1T1 写挂了，这题可能是我这次省选唯一能过的题了……

---

考虑将一个询问拆成两部分处理：$s_i$ 到 $\operatorname{lca}$ 的链，$lca$ 到 $t_i$ 的链。

前一部分显然可以直接预处理每个节点向上最近的 $P_1$ 种宝石的位置，和到每个节点后下一个应该收集的宝石在这个节点祖先中离他最近的位置。然后就可以直接树上倍增得到前一部分最多能收集多少宝石。

后一部分就会有点麻烦，因为从 $\operatorname{lca}$ 跳到 $t_i$ 是向儿子跳的，不能用倍增处理。

那么可以考虑二分答案，然后从 $t_i$ 跳到 $\operatorname{lca}$，在 $P$ 序列中倒序匹配。这样就跟上一部分一样了。

但是有个问题，假设当前二分到的位置是 $mid$，那么我们需要知道 $P_{mid}$ 这个宝石在 $t_i$ 的祖先中离他最近的出现的位置。

考场上我想到的是用**整体二分**来处理（如果不想写整体二分可以看下面的 dfs 版本），因为这样的话所有 $mid$ 相同的询问都会放到一起处理，那么就很好做了。

可以找到当前所有出售第 $P_{mid}$ 种宝石的节点，然后相当于要对每个节点的子树进行一个取 $\max$ 的操作（维护的最近节点的深度和当前节点取 $\max$）

可以将这些节点按深度升序排序，处理出 dfs 序，然后就变成区间覆盖操作，可以用线段树直接维护。或者和我考场代码一样按降序排序，然后变成区间内没有覆盖过的元素赋值，然后用并查集维护链表实现。

因为每种宝石只需要处理一次，所以每个节点只会做一次，这部分复杂度是 $\mathcal O(n\log n)$ 的。

这样处理出第一次跳的节点后就可以直接倍增 check 了！然后就是整体二分的事了。

总复杂度 $\mathcal O(n\log^2 n)$，瓶颈在于整体二分内的 sort 和倍增，常数很小，应该可以轻松通过。

------------

后来经过机房里的 AK 爷提醒，发现这个整体二分可以用 dfs 代替。

也就是说在 dfs 时记录每种宝石在当前点到根的路径上出现的深度最大的位置，然后处理所有终点在当前点的询问。

这样可以省去整体二分，代码感觉上就好写多了。

------------

整体二分版的代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e5+5;

int read()
{
	int s=0;
	char c=getchar(),lc='+';
	while (c<'0'||'9'<c) lc=c,c=getchar();
	while ('0'<=c&&c<='9') s=s*10+c-'0',c=getchar();
	return lc=='-'?-s:s;
}
void write(int x)
{
	if (x<0)
	{
		putchar('-');
		x=-x;
	}
	if (x<10) putchar(x+'0');
	else
	{
		write(x/10);
		putchar(x%10+'0');
	}
}
void print(int x,char c='\n')
{
	write(x);
	putchar(c);
}
struct edge
{
	int to,nxt;
}e[N*2];
int head[N],cnte=0;
void add_edge(int u,int v)
{
	e[++cnte].to=v;
	e[cnte].nxt=head[u];
	head[u]=cnte;
}
namespace LCA
{
	int fa[N],dfn[N],siz[N],son[N],deep[N],top[N],cntdfn=0;
	void dfs0(int now,int father)
	{
		fa[now]=father;
		dfn[now]=++cntdfn;
		siz[now]=1;
		son[now]=0;
		deep[now]=deep[father]+1;
		for (int i=head[now];i;i=e[i].nxt)
		{
			int to=e[i].to;
			if (to==father) continue;
			dfs0(to,now);
			siz[now]+=siz[to];
			if (siz[son[now]]<siz[to]) son[now]=to;
		}
	}
	void dfs1(int now,int father,int Top)
	{
		top[now]=Top;
		if (son[now]) dfs1(son[now],now,Top);
		for (int i=head[now];i;i=e[i].nxt)
		{
			int to=e[i].to;
			if (to==father||to==son[now]) continue;
			dfs1(to,now,to);
		}
	}
	void build()
	{
		dfs0(1,0);
		dfs1(1,0,1);
	}
	int find(int x,int y)
	{
		while (top[x]!=top[y])
		{
			if (deep[top[x]]<deep[top[y]]) swap(x,y);
			x=fa[top[x]];
		}
		if (deep[x]<deep[y]) swap(x,y);
		return y;
	}
}
using LCA::dfn;
using LCA::siz;
using LCA::deep;
struct Query
{
	int id,x,y,lca,ans0;
}q[N],tmp[N];
int Q,np[N],p[N],a[N],ans[N];
vector<int>v[N];
bool cmp_deep(int x,int y)
{
	return deep[x]>deep[y];
}
bool cmp_dfn(Query u,Query v)
{
	return dfn[u.y]<dfn[v.y];
}
namespace A
{
	int up[N],fa[N][20],last[N];
	void dfs(int now,int father)
	{
		int tmp=last[a[now]];
		last[a[now]]=now;
		up[now]=last[p[1]];
		fa[now][0]=last[p[np[a[now]]+1]];
		for (int i=head[now];i;i=e[i].nxt)
		{
			int to=e[i].to;
			if (to==father) continue;
			dfs(to,now);
		}
		last[a[now]]=tmp;
	}
	void solve(int n,int m)
	{
		dfs(1,0);
		for (int j=1;j<20;j++)
		for (int i=1;i<=n;i++) fa[i][j]=fa[fa[i][j-1]][j-1];
		for (int i=1;i<=Q;i++)
		{
			int now=up[q[i].x],u=q[i].lca;
			if (deep[now]<deep[u]) continue;
			for (int j=19;j>=0;j--)
			if (deep[fa[now][j]]>=deep[u]) now=fa[now][j];
			q[i].ans0=np[a[now]];
		}
	}
}
namespace B
{
	int up[N],fa[N][20],last[N];
	void dfs(int now,int father)
	{
		int tmp=last[a[now]];
		last[a[now]]=now;
		fa[now][0]=last[p[np[a[now]]-1]];
		for (int i=head[now];i;i=e[i].nxt)
		{
			int to=e[i].to;
			if (to==father) continue;
			dfs(to,now);
		}
		last[a[now]]=tmp;
	}
	struct dsu
	{
		int fa[N],deep[N];
		void YSGS(int l,int r)
		{
			for (int i=l;i<=r;i++) deep[i]=0;
			for (int i=l;i<=r;i++) fa[i]=i;
		}
		int find(int x)
		{
			return x==fa[x]?x:fa[x]=find(fa[x]);
		}
		void merge(int x,int y)
		{
			x=find(x),y=find(y);
			if (x==y) return;
			if (deep[x]>deep[y]) swap(x,y);
			fa[x]=y;
			if (deep[x]==deep[y]) deep[y]++;
		}
	}d;
	bool used[N];
	int tmpdfn[N];
	void binary_solve(int l,int r,int ql,int qr)//整体二分
	{
		if (ql>qr) return;
		if (l==r)
		{
			for (int i=ql;i<=qr;i++) ans[q[i].id]=l;
			return;
		}
		int mid=(l+r+1)/2;
		sort(q+ql,q+qr+1,cmp_dfn);
		d.YSGS(ql,qr);
		for (int i=ql;i<=qr;i++) used[i]=0;
		for (int i=ql;i<=qr;i++) tmpdfn[i]=dfn[q[i].y];
        //处理出up，up[i]表示第i个节点向上第一个出售第P[mid]种宝石的节点的位置
		for (int i=0;i<(int)v[p[mid]].size();i++)
		{
			int now=v[p[mid]][i];
			int L=lower_bound(tmpdfn+ql,tmpdfn+qr+1,dfn[now])-tmpdfn;
			int R=lower_bound(tmpdfn+ql,tmpdfn+qr+1,dfn[now]+siz[now])-tmpdfn-1;
			int j=L;
			if (used[j]) j=d.find(j)+1;
			while (j<=R)
			{
				up[q[j].y]=now;
				d.fa[j-1]=d.find(j);
				used[j]=1;
				j=d.find(j)+1;
			}
		}
		for (int j=ql;j<=qr;j++) if (!used[j]) up[q[j].y]=0;
		int n1=ql-1,n2=qr+1;
		for (int i=ql;i<=qr;i++)
		{
			int now=up[q[i].y],u=q[i].lca,final=mid+1;
			if (deep[now]>=deep[u])
			{
				for (int j=19;j>=0;j--)
				if (deep[fa[now][j]]>=deep[u]) now=fa[now][j];
				final=np[a[now]];
			}
			if (final<=q[i].ans0+1) tmp[++n1]=q[i];
							   else tmp[--n2]=q[i];
		}
		for (int i=ql;i<=qr;i++) q[i]=tmp[i];
		binary_solve(l,mid-1,n2,qr);
		binary_solve(mid,r,ql,n1);
	}
	void solve(int n,int m)
	{
		dfs(1,0);
		for (int j=1;j<20;j++)
		for (int i=1;i<=n;i++) fa[i][j]=fa[fa[i][j-1]][j-1];
		binary_solve(0,m,1,Q);
	}
}

signed main()
{
	freopen("gem.in","r",stdin);
	freopen("gem.out","w",stdout);
	
	int n=read(),m=read(),c=read();
	for (int i=1;i<=c;i++) np[p[i]=read()]=i;
	for (int i=1;i<=n;i++) a[i]=read();
	for (int i=1;i<n;i++)
	{
		int u=read(),v=read();
		add_edge(u,v);
		add_edge(v,u);
	}
	LCA::build();
	for (int i=1;i<=n;i++) v[a[i]].push_back(i);
	for (int i=1;i<=m;i++) sort(v[i].begin(),v[i].end(),cmp_deep);
	Q=read();
	for (int i=1;i<=Q;i++)
	{
		q[i].id=i;
		q[i].ans0=0;
		q[i].x=read();
		q[i].y=read();
		q[i].lca=LCA::find(q[i].x,q[i].y);
	}
	A::solve(n,c);
	B::solve(n,c);
	for (int i=1;i<=Q;i++) print(ans[i]);
	
	return 0;
}
```

---

## 作者：白鲟 (赞：8)

## 前言
考场上拿到题觉得很可做。

后来改着改着就不会做了。

回来晚自习一激灵会做了。

## 描述
稍加转化，可变为求树上 $u,v$ 间路径上最长从 $1$ 开始公差为 $1$ 的子等差序列长度。

## 分析
套路地将询问离线到两端点，拆成上行与下行两条路径。

上行是求从 $u$ 开始到 $u,v$ 的 LCA 的路径上的最长子序列长度；下行时求从 LCA 开始到 $v$ 的路径上从上行所得答案开始的公差为 $1$ 的最长子序列长度。

容易发现，上行只需要记录每个结点祖先中最近的后继，对每个询问从离当前 $u$ 最近的 $1$ 开始通过该记录倍增即可。

考虑下行。朴素的想法是记录每个结点祖先中最近的前驱，对 LCA 和 $v$ 中每个结点都通过该记录向上倍增，检验倍增到上行答案时深度是否大于 LCA 深度，若大于则为一组可行解。 

考场思考进行到这一地步。

后来回学校晚自习灵光一现，发现单调性，即可以二分下行倍增起点的值。于是就做完了。

时间复杂度为 $\operatorname{O}(n\log^2 n)$

## 代码
民间数据自测通过。

```cpp
#include<cctype>
#include<cstdio>
#include<vector>
using namespace std;
const int maxn=2e5,maxlog=18;
int n,m,c,u,v,tot,q,lastpos[maxn+1],p[maxn+1],no[maxn+1],w[maxn+1],head[maxn+1],suc[maxn<<1|1],to[maxn<<1|1],pos[maxn+1],depth[maxn+1],res[maxn+1],parent[maxn+1][maxlog+1],upsuc[maxn+1][maxlog+1];
vector<int> up[maxn+1],down[maxn+1];
inline void read(int &x)
{
	x=0;
	char t=getchar();
	while(!isdigit(t))
		t=getchar();
	while(isdigit(t))
	{
		x=x*10+t-'0';
		t=getchar();
	}
	return;
}
inline void add_edge(int x,int y)
{
	suc[++tot]=head[x];
	head[x]=tot;
	to[tot]=y;
	return;
}
void dfs1(int now)
{
	depth[now]=depth[parent[now][0]]+1;
	for(int i=head[now];i;i=suc[i])
		if(to[i]!=parent[now][0])
		{
			parent[to[i]][0]=now;
			for(int j=1;j<=maxlog;++j)
				parent[to[i]][j]=parent[parent[to[i]][j-1]][j-1];
			dfs1(to[i]);
		}
	return;
}
int LCA(int x,int y)
{
	if(depth[x]<depth[y])
		x^=y^=x^=y;
	for(int i=maxlog;~i;--i)
		if(depth[parent[x][i]]>=depth[y])
			x=parent[x][i];
	if(x==y)
		return x;
	for(int i=maxlog;~i;--i)
		if(parent[x][i]!=parent[y][i])
		{
			x=parent[x][i];
			y=parent[y][i];
		}
	return parent[x][0];
}
void dfs2(int now)
{
	int t=lastpos[w[now]];
	lastpos[w[now]]=depth[now];
	upsuc[depth[now]][0]=lastpos[w[now]+1];
	for(int i=1;i<=maxlog;++i)
		upsuc[depth[now]][i]=upsuc[upsuc[depth[now]][i-1]][i-1];
	for(int i=0;i<up[now].size();++i)
	{
		int thistime=lastpos[1];
		if(thistime<depth[pos[up[now][i]]])
			continue;
		++res[up[now][i]];
		for(int j=maxlog;~j;--j)
			if(upsuc[thistime][j]>=depth[pos[up[now][i]]])
			{
				res[up[now][i]]+=(1<<j);
				thistime=upsuc[thistime][j];
			}	
	}
	for(int i=head[now];i;i=suc[i])
		if(to[i]!=parent[now][0])
			dfs2(to[i]);
	lastpos[w[now]]=t;
	return;
}
void dfs3(int now)
{
	int t=lastpos[w[now]];
	lastpos[w[now]]=depth[now];
	upsuc[depth[now]][0]=lastpos[w[now]-1];
	for(int i=1;i<=maxlog;++i)
		upsuc[depth[now]][i]=upsuc[upsuc[depth[now]][i-1]][i-1];
	for(int i=0;i<down[now].size();++i)
	{
		int l=res[down[now][i]]+1,r=c,tres=l-1;
		while(l<=r)
		{
			int mid=(l+r)>>1,thistime=lastpos[mid],cnt=mid-res[down[now][i]]-1;
			for(int k=maxlog;~k;--k)
				if((1<<k)&cnt)
					thistime=upsuc[thistime][k];
			if(thistime>depth[pos[down[now][i]]])
			{
				tres=mid;
				l=mid+1;
			}
			else r=mid-1;
		}
		res[down[now][i]]=tres;
	}
	for(int i=head[now];i;i=suc[i])
		if(to[i]!=parent[now][0])
			dfs3(to[i]);
	lastpos[w[now]]=t;
	return;
}
int main()
{
	read(n);
	read(m);
	read(c);
	for(int i=1;i<=c;++i)
	{
		read(p[i]);
		no[p[i]]=i;
	}
	for(int i=1;i<=n;++i)
	{
		read(w[i]);
		w[i]=no[w[i]];
	}
	for(int i=1;i<n;++i)
	{
		read(u);
		read(v);
		add_edge(u,v);
		add_edge(v,u);
	}
	dfs1(1);
	read(q);
	for(int i=1;i<=q;++i)
	{
		read(u);
		read(v);
		pos[i]=LCA(u,v);
		up[u].push_back(i);
		down[v].push_back(i);
	}
	dfs2(1);
	dfs3(1);
	for(int i=1;i<=q;++i)
		printf("%d\n",res[i]);
	return 0;
}
```

---

## 作者：ImmortalWatcher (赞：5)

考试的时候十分傻逼，距离正解只有一步……

首先可以想到倍增，将答案分为两段，分别从 x 跳到 lca 和从 lca 跳到 y。

然后对于倍增数组的预处理，就是首先做一次 dfs，然后用一个桶记录一下往上走到任意宝石的最近的位置(我们不知道上一个要跳到哪)，然后我就发现数组存不下了。

这时候我们就需要转化题意，考试的时候我一直在想，保证p数组不重复究竟有什么用，原来是可以把宝石转化为要取的第几个宝石，那我们取的宝石就变成了一个 1~ans 的序列，这样我们的倍增就可以直接记录下一种宝石要跳到哪里了，就不需要记录所有宝石的了。

然后考场很傻逼，没有做倍增，直接暴力跳，于是就有了最初记录所有宝石的想法……

然后我们就很自然的发现左边那段解决了，右边那段我考试的时候也想出来二分枚举一下答案，然后跳上去看看合不合法就行了，起点借助一开始的桶就行了。

然后发现把询问挂在节点上可以减少时间复杂度。

~~没想到倍增的我可以退役了~~
```cpp
#include<cstdio>
#include<vector>
#include<algorithm>
using namespace std;
struct node{int last,en,next;} e[400010];
int n,m,c,p[50010],w[200010],x,y,tot,f[200010][18],f1[200010][18],f2[200010][18];
int ans[200010],dep[200010],t1[50010],t2[50010],start[200010],q;
vector<pair<int,int> >ask[200010];
void add(int x,int y)
{
	e[++tot].en=y;
	e[tot].next=e[x].last;
	e[x].last=tot;
}
int lca(int x,int y)
{
	if (dep[x]<dep[y]) swap(x,y);
	for (int i=17;i>=0;i--)
		if (dep[f[x][i]]>=dep[y]) x=f[x][i];
	if (x==y) return x;
	for (int i=17;i>=0;i--)
		if (f[x][i]!=f[y][i]) x=f[x][i],y=f[y][i];
	return f[x][0];
}
void dfs1(int x,int fa)
{
	if (w[x]==1) start[x]=x;else start[x]=start[fa];
	dep[x]=dep[fa]+1;f[x][0]=fa;
	int u=t1[w[x]],v=t2[w[x]];
	t1[w[x]]=t2[w[x]]=x;
	f1[x][0]=t1[w[x]+1];f2[x][0]=t2[w[x]-1];
	for (int i=e[x].last;i;i=e[i].next)
		if (e[i].en!=fa) dfs1(e[i].en,x);
	t1[w[x]]=u;t2[w[x]]=v;
}
bool pd(int x,int c,int z,int tail)
{
	x=t1[c];
	if (dep[x]<dep[z])return 0;
	for (int i=17;i>=0;i--)
		if (dep[f2[x][i]]>=dep[z]) c-=1<<i,x=f2[x][i];
	return c<=tail;
}
void dfs2(int x,int fa)
{
	int u=t1[w[x]];t1[w[x]]=x;
	for (int i=0;i<ask[x].size();i++)
	{
		int y=ask[x][i].first,id=ask[x][i].second;
		int z=lca(x,y);int ret=0;
		y=start[y];
		if (dep[y]>=dep[z])
		{
			for (int i=17;i>=0;i--)
				if (dep[f1[y][i]]>=dep[z])
					y=f1[y][i];
			ret=w[y];
		}
		int l=ret+1,r=c,mid,p=ret;
		while (l<=r)
		{
			mid=(l+r)>>1;
			if (pd(x,mid,z,p+1)) l=mid+1,ret=mid;
			else r=mid-1;
		}
		ans[id]=ret;
	}
	for (int i=e[x].last;i;i=e[i].next)
		if (e[i].en!=fa) dfs2(e[i].en,x);
	t1[w[x]]=u;
}
int main()
{
	scanf("%d%d%d",&n,&m,&c);
	for (int i=1;i<=c;i++)
		scanf("%d",&x),p[x]=i;
	for (int i=1;i<=n;i++)
		scanf("%d",&x),w[i]=p[x];
	for (int i=1;i<n;i++)
		scanf("%d%d",&x,&y),add(x,y),add(y,x);
	dfs1(1,0);
	for (int j=1;j<=17;j++)
		for (int i=1;i<=n;i++)
		{
			f[i][j]=f[f[i][j-1]][j-1];
			f1[i][j]=f1[f1[i][j-1]][j-1];
			f2[i][j]=f2[f2[i][j-1]][j-1];
		}
	scanf("%d",&q);
	for (int i=1;i<=q;i++)
	{
		scanf("%d%d",&x,&y);
		ask[y].push_back(make_pair(x,i));
	}
	dfs2(1,0);
	for (int i=1;i<=q;i++)
		printf("%d\n",ans[i]);
	return 0;
}
```


---

## 作者：whiteqwq (赞：4)

[P7518 [省选联考 2021 A/B 卷] 宝石](https://www.luogu.com.cn/problem/P7518)解题报告：

[更好的阅读体验](https://zybuluo.com/xiaoziyao/note/1791149)

## 题意

给定一颗$n$个点的带点权的树，以及一个长度为$c$的匹配序列，（点权与序列的值域为$[1,m]$），$q$次询问，每次询问$x$到$y$的有向路径与匹配序列匹配的最长前缀的长度。

$1\leqslant n,q\leqslant 2\times 10^5,1\leqslant c\leqslant m\leqslant 5\times 10^4$。

## 分析

考场写了一个5k的树分块$O((n+q+m\alpha(n))\sqrt{n})$的做法，然后被卡常卡成$35pts$就很离谱。

> 
（该部分可略过）
在树上撒$\sqrt{n}$个关键点，每个点与其祖先里的关键点距离为$\sqrt{n}$，然后发现可以把询问的路径分成$4$个散块和$2$个整块，散块暴力跳（记得把$lca$到另一端的路径反向，我因为反向调了一个多小时），整块可以预处理第$i$个关键点跳到祖先关键点这一条链，从位置$j$开始匹配能匹配到哪里，不难发现（我想了十几分钟）可以用并查集维护所有位置同时进行匹配，同样还要反过来做一遍。
具体地，可以把整块对应的链上权值序列当成一个普通的序列，与长度为m的串进行匹配，然后对于每个位置可以维护它在匹配的过程中到了哪一个位置，不难发现把相同的位置在匹配的过程中会不断合并，那么直接上并查集就好了。

然后发现$O(n\log n+q\log n\log m)$的树上倍增好想好写的一批。

首先进行一次转化，把点权转化为在序列中的位置，这样好做一些。

考虑预处理$x$向上跳第一个点权为$c$的点的位置，这是一个经典问题，在树上用主席树完成就好了，时空复杂度均为$O(n\log m)$。

然后再按照树上倍增的套路预处理一个$inc_{x,k}$表示$x$向上跳，从当前点权$w_x$匹配到$w_x+2^k$的位置，以及$dec_{x,k}$表示$x$向上跳，从当前点权$w_x$反向匹配到$w_x-2^k$的位置。我们首先用主席树帮忙处理出$inc_{x,0}$与$dec_{x,0}$，然后直接合并就好了。

对于询问$(x,y)$，设$z=lca(x,y)$，考虑让$x$跳到第一个点权为$1$的点开始匹配（需要特判一下跳出$x\rightarrow z$这一条链的情况），然后用树上倍增暴力跳$inc$数组直到跳出$x\rightarrow z$这一条链。

之后，我们发现$y$不能进行类似的操作，因为我们不知道结尾的点权为多少，不难发现答案具有可二分性，直接二分最后的位置，然后按照上面的方法跳$dec$就好了。

时间复杂度：$O(n\log n+q\log n\log m)$。

## 代码
常数似乎很大。
```
#include<stdio.h>
const int maxm=50005,maxn=200005,maxe=maxn<<1,maxk=25;
int n,m,c,e,q,tot;
int p[maxm],w[maxn],start[maxn],to[maxe],then[maxe],fore[maxn][maxk],dep[maxn],pos[maxm];
int lc[maxn*maxk],rc[maxn*maxk],res[maxn*maxk],rt[maxn],inc[maxn][maxk],dec[maxn][maxk];
inline void add(int x,int y){
	then[++e]=start[x],start[x]=e,to[e]=y;
}
void build(int l,int r,int &now){
	if(now==0)
		now=++tot;
	if(l==r){
		res[now]=-1;
		return ;
	}
	int mid=(l+r)>>1;
	build(l,mid,lc[now]),build(mid+1,r,rc[now]);
}
inline int newnode(int x){
	tot++,lc[tot]=lc[x],rc[tot]=rc[x],res[tot]=res[x];
	return tot;
}
void update(int l,int r,int &now,int pos,int v){
	now=newnode(now);
	if(l==r){
		res[now]=v;
		return ;
	}
	int mid=(l+r)>>1;
	if(pos<=mid)
		update(l,mid,lc[now],pos,v);
	else update(mid+1,r,rc[now],pos,v);
}
int query(int l,int r,int now,int pos){
	if(l==r)
		return res[now];
	int mid=(l+r)>>1;
	if(pos<=mid)
		return query(l,mid,lc[now],pos);
	return query(mid+1,r,rc[now],pos);
}
void dfs(int x,int last){
	dep[x]=dep[last]+1,fore[x][0]=last,rt[x]=rt[last];
	if(w[x]!=-1)
		update(1,c,rt[x],w[x],x);
	inc[x][0]=(w[x]==-1||w[x]==c)? -1:query(1,c,rt[x],w[x]+1);
	dec[x][0]=(w[x]==-1||w[x]==1)? -1:query(1,c,rt[x],w[x]-1);
	for(int i=1;i<=20;i++){
		fore[x][i]=fore[fore[x][i-1]][i-1];
		inc[x][i]=inc[x][i-1]==-1? -1:inc[inc[x][i-1]][i-1];
		dec[x][i]=dec[x][i-1]==-1? -1:dec[dec[x][i-1]][i-1];
	}
	for(int i=start[x];i;i=then[i]){
		int y=to[i];
		if(y==last)
			continue;
		dfs(y,x);
	}
}
int lca(int a,int b){
	if(dep[a]<dep[b])
		a+=b,b=a-b,a-=b;
	for(int i=20;i>=0;i--)
		if(dep[fore[a][i]]>=dep[b])
			a=fore[a][i];
	if(a==b)
		return a;
	for(int i=20;i>=0;i--)
		if(fore[a][i]!=fore[b][i])
			a=fore[a][i],b=fore[b][i];
	return fore[a][0];
}
int check(int x,int z,int now,int goal){
	x=query(1,c,rt[x],goal);
	if(x==-1||dep[x]<dep[z])
		return 0;
	for(int i=20;i>=0;i--)
		if(dec[x][i]!=-1&&dep[dec[x][i]]>dep[z])
			x=dec[x][i];
	return w[x]<=now;
}
int main(){
	scanf("%d%d%d",&n,&m,&c);
	for(int i=1;i<=m;i++)
		pos[i]=-1;
	for(int i=1;i<=c;i++)
		scanf("%d",&p[i]),pos[p[i]]=i;
	for(int i=1;i<=n;i++)
		scanf("%d",&w[i]),w[i]=pos[w[i]];
	for(int i=1;i<n;i++){
		int x,y;
		scanf("%d%d",&x,&y);
		add(x,y),add(y,x);
	}
	build(1,c,rt[0]),dfs(1,0);
	scanf("%d",&q);
	while(q--){
		int x,y,z,res=0;
		scanf("%d%d",&x,&y),z=lca(x,y);
		x=query(1,c,rt[x],1);
		if(x!=-1&&dep[x]>=dep[z]){
			for(int i=20;i>=0;i--)
				if(inc[x][i]!=-1&&dep[inc[x][i]]>=dep[z])
					x=inc[x][i];
			res=w[x];
		}
		int L=res,R=c+1;
		while(L+1<R){
			int mid=(L+R)>>1;
			if(check(y,z,res+1,mid))
				L=mid;
			else R=mid;
		}
		printf("%d\n",L);
	}
	return 0;
}
```

省选联考A卷全部题解可见：[2021省选联考A卷解题报告](https://zybuluo.com/xiaoziyao/note/1791034)

---

## 作者：KellyFrog (赞：4)

## P7518 [省选联考 2021 A/B 卷] 宝石

首先，由于 $P$ 各不相同，一个节点会对应 $P$ 上的唯一位置，令 $u$ 节点的颜色的位置为 $match_u$。那么我们就有一个普通的倍增想法：令 $f_{u,i}$ 表示从 $u$ 开始，向根走，从 $match_u$ 匹配到 $match_u + 2^i$ 结束的树上节点。

考虑如何处理 $f_{u,0}$，即到根第一个 $match=match_u+1$ 的位置，可以通过 dfs 时记录最近的各种颜色并回溯解决。

这样我们就完成了一次询问 $u\rightarrow LCA$ 的部分，接下来考虑 $LCA\rightarrow v$，倒着倍增不好处理，考虑二分答案向上跳，令 $g_{u,i}$ 表示 $u$ 从 $match_u$ 跳到 $match_u - 2^i$ 会跳到哪。

二分一个答案 $mid$，并从 $match=mid$ 开始跳，如果 $s\rightarrow LCA$ 和 $LCA\rightarrow t$ 如果并起来大于当前二分的答案，则合法。

问题就变成了如果对二分的一个 $mid$ 找出 $v$ 祖先的第一个位置满足 $match=mid$，可以用和 $f_{u,0}$ 同样的方式，把操作离线，挂在 $t$ 上，再 dfs 回溯一遍即可，总复杂度 $O(n\log n+q\log^2n)$，当然不离线的话可以主席树，复杂度是一样的

放一下考场代码，拍了两万组，所有民间数据都过了（
```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;
#define rg register
#define rep(i, s, t) for(rg int i = (s); i <= (t); i++)
#define per(i, s, t) for(rg int i = (t); i >= (s); i--)
#define mp make_pair
#define pb push_back
#define fi first
#define se second

const int N = 2e5 + 5;
const int M = 2e5 + 5;

int anc[N][21], f[N][21], g[N][21], dep[N], last1[N], last2[N], lastpos[N];
int head[N], nxt[N<<1], to[N<<1], tot;
int match[N], pos[N];
int n, m, c;
int w[N], p[N];
int ans[N];
vector<pair<int, int> > qry[N];

inline void addedge(int u, int v) {
  nxt[++tot] = head[u];
  to[tot] = v;
  head[u] = tot;
}

inline void dfs1(int u, int fat) {
  dep[u] = dep[fat] + 1;
  last1[u] = p[1] == w[u] ? u : last1[fat];
  last2[u] = p[c] == w[u] ? u : last2[fat];
  anc[u][0] = fat;

  f[u][0] = lastpos[match[u]+1];
  g[u][0] = lastpos[match[u]-1];

  rep(i, 1, 20) anc[u][i] = anc[anc[u][i-1]][i-1];
  rep(i, 1, 20) f[u][i] = f[f[u][i-1]][i-1];
  rep(i, 1, 20) g[u][i] = g[g[u][i-1]][i-1];

  int x = lastpos[match[u]];
  lastpos[match[u]] = u;

  for(rg int e = head[u]; e; e = nxt[e]) {
    rg int v = to[e];
    if(v != fat) {
      dfs1(v, u);
    }
  }

  lastpos[match[u]] = x;
}

inline int LCA(int x, int y) {
  if(dep[x] < dep[y]) swap(x, y);
  per(i, 0, 20) if(dep[anc[x][i]] >= dep[y]) x = anc[x][i];
  if(x == y) return x;
  per(i, 0, 20) if(anc[x][i] != anc[y][i]) x = anc[x][i], y = anc[y][i];
  return anc[x][0];
}

inline bool check(int u, int x, int y, int lca) {
  int res = 0;
  if(dep[lastpos[x]] >= dep[lca]) {
    u = lastpos[x];
    res = 1;
    per(i, 0, 20) {
      if(dep[g[u][i]] >= dep[lca]) {
	res += (1<<i);
	u = g[u][i];
      }
    }
  }
  return res + y >= x;
}

inline int solve(int s, int t) {
  int lca = LCA(s, t);
  int k = 0, s0 = s, t0 = t;
  if(dep[last1[s]] >= dep[lca]) {
    k = 1;
    s = last1[s];
    per(i, 0, 20) {
      if(dep[f[s][i]] >= dep[lca]) {
	k += (1<<i);
	s = f[s][i];
      }
    }
  } else {
    s = -1;
  }
  int L = k+1, R = m;
  int res = k;
  while(L <= R) {
    rg int mid = L + R >> 1;
    if(check(t, mid, k, lca)) {
      res = mid;
      L = mid + 1;
    } else {
      R = mid - 1;
    }
  }
  return res;
}

inline void dfs2(int u, int fat) {
  int x = lastpos[match[u]];
  lastpos[match[u]] = u;
  rep(i, 0, (int)qry[u].size()-1) {
    ans[qry[u][i].fi] = solve(qry[u][i].se, u);
  }
  for(rg int e = head[u]; e; e = nxt[e]) {
    rg int v = to[e];
    if(v != fat) {
      dfs2(v, u);
    }
  }
  lastpos[match[u]] = x;
}

int main() {
  freopen("gem.in", "r", stdin);
  freopen("gem.out", "w", stdout);
  scanf("%d%d%d", &n, &m, &c);
  rep(i, 1, c) {
    scanf("%d", &p[i]);
    pos[p[i]] = i;
  }
  rep(i, 1, n) scanf("%d", &w[i]);
  rep(i, 1, n) match[i] = pos[w[i]];
  rep(i, 1, n-1) {
    int u, v;
    scanf("%d%d", &u, &v);
    addedge(u, v);
    addedge(v, u);
  }
  dfs1(1, 0);
  int q; scanf("%d", &q);
  rep(i, 1, q) {
    int s, t;
    scanf("%d%d", &s, &t);
    qry[t].pb(mp(i, s));
  }
  dfs2(1, 0);
  rep(i, 1, q) printf("%d\n", ans[i]);
  fclose(stdin);
  fclose(stdout);
  return 0;
}
```

---

## 作者：hsfzLZH1 (赞：3)

考场上想到的不妙平衡树做法，本质就是把其它题解中的倍增/二分换成平衡树，常数较大，但考场亲测不卡常能过，适合码力惊人的选手。（考场上因为数组开小炸了链的部分分）

本题离线到树剖重儿子上的思想值得借鉴。

题目保证 $P_i$ 互不相同，所以我们可以令 $P_i=i$ ，并依此调整树上宝石的颜色。

#### 链上做法

首先考虑链上的解法，这一部分的做法也是本题解和其它树剖+倍增/二分做法的最大不同之处。

考虑暴力的解法。对于单个的询问 $u,v$ ，初始时匹配长度为 $0$ ，遍历树上 $u$ 到 $v$ 的简单路径，如果当前结点宝石编号为 $i$ 且当前匹配长度为 $i-1$ ，将当前匹配长度改为 $i$ 。

考虑同时处理多个询问。不妨设 $u_i\le v_i$ ，若 $u_i>v_i$ 可以将链反过来再做一遍。考虑通过某种数据结构同时维护所有的匹配长度。从 $1$ 到 $n$ 遍历每个点，若当前结点编号为 $x$ ，宝石编号为 $i$ ，则将所有 $u_j\le x\le v_j$ 且当前匹配长度为 $i-1$ 的询问的匹配长度变为 $i$ 。

对应到具体的操作上，就是：

1. 插入一个二元组 $x,id$ 。

2. 给定 $i$ ，将所有 $x=i-1$ 的二元组改为 $x=i$ 。

3. 查询 $id$ 对应的 $x$ 值。

这个可以用平衡树如 FHQ Treap 从小到大维护 $x$ 解决。单次操作时间复杂度 $O(\log n)$ 。

只需正反各做一次平衡树，就可以解决链上问题了。时间复杂度 $O(n\log n)$ 。

### 树上问题

链上问题转化为树上问题，第一个想到的就是树链剖分，将询问离线拆分到若干重链上。根据树剖的相关知识，一个询问最多被拆分到 $O(\log n)$ 条重链上。

离线后先从叶子向根处理跳的边，再从根向叶子处理跳的边，这样保证所有询问查询结点的顺序是正确的。

在重链上的部分和链的情况同等处理即可。时间复杂度 $O(n\log^2 n)$ ，空间复杂度 $O(n\log n)$ 。

### 参考代码

约等于考场代码，只有数组开大了。

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<vector>
#include<cstdlib>
#include<queue>
using namespace std;
const int maxn=600010;
int n,m,c,P[maxn],rnk[maxn],w[maxn],u,v,q,ans[maxn];
int cur,h[maxn],nxt[maxn],p[maxn];
void add_edge(int x,int y)
{
	cur++;
	nxt[cur]=h[x];
	h[x]=cur;
	p[cur]=y;
}
int fa[maxn],dep[maxn],siz[maxn],son[maxn];
int clk,dfn[maxn],top[maxn];
void dfs1(int x)
{
	siz[x]=1;
	for(int j=h[x];j;j=nxt[j])if(p[j]!=fa[x])
	{
		fa[p[j]]=x;dep[p[j]]=dep[x]+1;
		dfs1(p[j]);siz[x]+=siz[p[j]];
		if(siz[p[j]]>siz[son[x]])son[x]=p[j];
	}
}
void dfs2(int x,int t)
{
	dfn[x]=++clk;rnk[clk]=x;top[x]=t;
	if(son[x])dfs2(son[x],t);
	for(int j=h[x];j;j=nxt[j]){if(p[j]!=fa[x]&&p[j]!=son[x])dfs2(p[j],p[j]);}
}
struct node{int l,r,id,op;};
vector<node>g[maxn];
struct oper{int op,id,v,t;}s[maxn];
bool cmp1(oper x,oper y){return x.t==y.t?x.op<y.op:x.t>y.t;}
bool cmp2(oper x,oper y){return x.t==y.t?x.op<y.op:x.t<y.t;}
int cnt;
/* 
struct FHQ
{
	int a[maxn];
	void clear(){for(int i=1;i<=n;i++)a[i]=0;}
	void insert(int x,int v){a[x]=v;}
	void update(int v){for(int i=1;i<=n;i++)if(a[i]==v-1)a[i]=v;}
	int query(int x){return a[x];}
}st;*/
queue<int>pl;
struct FHQ
{
	int rt,v[maxn],tag[maxn],siz[maxn],lc[maxn],rc[maxn],fa[maxn];
	void clear(){rt=0;while(!pl.empty()){int x=pl.front();pl.pop();v[x]=tag[x]=siz[x]=lc[x]=rc[x]=fa[x]=0;maintain(x);}}
	void maintain(int x)
	{
		siz[x]=siz[lc[x]]+siz[rc[x]]+1;
	}
	void pushdown(int x)
	{
		if(lc[x])v[lc[x]]+=tag[x],tag[lc[x]]+=tag[x];
		if(rc[x])v[rc[x]]+=tag[x],tag[rc[x]]+=tag[x];
		tag[x]=0;
	}
	int merge(int x,int y)
	{
		//printf("merge %d %d\n",x,y);
		if(!x||!y)return x+y;
		if(rand()%(siz[x]+siz[y])<siz[x])
		{
			pushdown(x);rc[x]=merge(rc[x],y);maintain(x);fa[rc[x]]=x;return x;
		}
		else
		{
			pushdown(y);lc[y]=merge(x,lc[y]);maintain(y);fa[lc[y]]=y;return y;
		}
	}
	void split(int o,int val,int&x,int&y)
	{
		//printf("split %d %d %d %d\n",o,val,x,y);
		if(!o){x=y=0;return;}
		pushdown(o);
		if(v[o]<=val){x=o,split(rc[o],val,rc[x],y);if(rc[x])fa[rc[x]]=x;fa[y]=0;maintain(x);}
		else {y=o,split(lc[o],val,x,lc[y]);if(lc[y])fa[lc[y]]=y;fa[x]=0;maintain(y);}
	}
	void pushall(int x)
	{
		if(fa[x])pushall(fa[x]);
		pushdown(x);
	}
	int query(int x){pushall(x);return v[x];}
	void insert(int x,int val)
	{
		pl.push(x);
		v[x]=val;maintain(x);
		int a=0,b=0;
		split(rt,val,a,b);
		rt=merge(merge(a,x),b);
	}
	void update(int val)
	{
		int a=0,b=0,c=0;
		split(rt,val-2,a,b);
		split(b,val-1,b,c);
		v[b]++;tag[b]++;
		rt=merge(merge(a,b),c);
	}
}st;
void solveup(int x)
{
	for(int j=h[x];j;j=nxt[j])if(p[j]!=fa[x])solveup(p[j]);
	if(top[x]==x)
	{
		cnt=0;
		for(int i=0;i<(int)g[x].size();i++)if(g[x][i].op==0)
		s[++cnt]=(oper){1,g[x][i].id,ans[g[x][i].id],g[x][i].l},s[++cnt]=(oper){3,g[x][i].id,0,g[x][i].r};
		for(int i=dfn[x];top[rnk[i]]==x;i++)s[++cnt]=(oper){2,0,w[rnk[i]],i};
		sort(s+1,s+cnt+1,cmp1);st.clear();
		for(int i=1;i<=cnt;i++)
		{
			if(s[i].op==1)st.insert(s[i].id,s[i].v);
			if(s[i].op==2)st.update(s[i].v);
			if(s[i].op==3)ans[s[i].id]=st.query(s[i].id);
		}
	}
}
void solvedown(int x)
{
	if(top[x]==x)
	{
		//printf("solvedown %d\n",x);
		cnt=0;
		for(int i=0;i<(int)g[x].size();i++)if(g[x][i].op==1)
		s[++cnt]=(oper){1,g[x][i].id,ans[g[x][i].id],g[x][i].l},s[++cnt]=(oper){3,g[x][i].id,0,g[x][i].r};
		for(int i=dfn[x];top[rnk[i]]==x;i++)s[++cnt]=(oper){2,0,w[rnk[i]],i};
		sort(s+1,s+cnt+1,cmp2);st.clear();
		for(int i=1;i<=cnt;i++)
		{
			//printf("ontopof %d , %d %d %d %d\n",x,s[i].op,s[i].id,s[i].v,s[i].t);
			if(s[i].op==1)st.insert(s[i].id,s[i].v);
			if(s[i].op==2)st.update(s[i].v);
			if(s[i].op==3)ans[s[i].id]=st.query(s[i].id);
			//printf("st : ");st.print(st.rt);printf("\n");
		}
	}
	for(int j=h[x];j;j=nxt[j])if(p[j]!=fa[x])solvedown(p[j]);
} 
int main()
{
	scanf("%d%d%d",&n,&m,&c);
	for(int i=1;i<=m;i++)rnk[i]=c+2;
	for(int i=1;i<=c;i++)scanf("%d",P+i),rnk[P[i]]=i;
	for(int i=1;i<=n;i++)scanf("%d",w+i),w[i]=rnk[w[i]];
	for(int i=1;i<n;i++)scanf("%d%d",&u,&v),add_edge(u,v),add_edge(v,u);
	dep[1]=1;dfs1(1);dfs2(1,1);
	//for(int i=1;i<=n;i++)printf("%d ",dfn[i]);printf("\n");
	scanf("%d",&q);
	for(int i=1;i<=q;i++)
	{
		scanf("%d%d",&u,&v);
		while(top[u]!=top[v])
		{
			if(dep[top[u]]>dep[top[v]])g[top[u]].push_back((node){dfn[u],dfn[top[u]],i,0}),u=fa[top[u]];
			else g[top[v]].push_back((node){dfn[top[v]],dfn[v],i,1}),v=fa[top[v]];
		}
		if(dfn[u]>=dfn[v])g[top[u]].push_back((node){dfn[u],dfn[v],i,0});
		else g[top[u]].push_back((node){dfn[u],dfn[v],i,1});
	}
	solveup(1);
	solvedown(1);
	for(int i=1;i<=q;i++)printf("%d\n",ans[i]);
	return 0;
} 
```

---

## 作者：Rubyonly (赞：2)

考场上就打了 $70pts$ 的暴力，回头再看还是比较简单的

针对 $m\leq 300$ 的数据，考场上写了个 $\Theta (qm\log m)$ 的做法

大概思路是，针对每次询问，首先求出 $u$ 和 $v$ 的 $lca$

先考虑从 $u$ 往上跑到 $lca$ 的这段路程，我们可以预处理出每个节点往上，距离它最近的每个颜色的节点是什么，因为 $m\leq 300$，所以可以直接开个数组存下来，$DFS$ 时从父亲继承下来即可，然后询问时直接用这个数组暴跳即可，直到跳到距 $lca$ 最近的节点，这样可以求出一半的答案 $ans$

然后考虑从 $lca$ 往下跑到 $v$ 的这段路程，然而预处理出向下的数组不是很好实现，不妨二分一个值 $mid$，每次从 $v$ 往上暴跳，判断是否能跳到上面求出的答案 $ans$，如果跳不到，答案显然比 $mid$ 小，否则比 $mid$ 大

不过复杂度好像很危，$m\leq 300$ 并不能拿全

不妨一步步优化上面那个做法

* 预处理往上最近的每个颜色的节点

$m\leq 300$ 时，我们可以开数组记下来，但是现在 $m$ 很大，数组开不下，可以用树上主席树代替这个数组，时空复杂度就很正确了

* 暴跳

$m$ 和 $c$ 都很大了，暴跳复杂度就不对了

不妨借用倍增 $lca$ 的思路，定义 $f0[u][i]$ 表示 $u$ 向上跳，颜色序列增加 $2^i$ 所到的节点，$f1[u][i]$ 表示 $u$ 向上跳，颜色序列减少 $2^i$ 所到的节点

这样从 $u$ 往上跑和从 $lca$ 往下跑都可以倍增解决了

最后复杂度是 $\Theta (n\log n+q\log n\log m)$ 的

## 代码

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int maxn = 2e5 + 50, INF = 0x3f3f3f3f;

inline int read () {
	register int x = 0, w = 1;
	register char ch = getchar ();
	for (; ch < '0' || ch > '9'; ch = getchar ()) if (ch == '-') w = -1;
	for (; ch >= '0' && ch <= '9'; ch = getchar ()) x = x * 10 + ch - '0';
	return x * w;
}

int n, m, q, c, nodecnt;
int mp[maxn], col[maxn], root[maxn], f0[maxn][21], f1[maxn][21];
int f[maxn], size[maxn], son[maxn], deep[maxn], top[maxn];

struct Tree {
	int lch, rch, pos;
} tree[maxn * 36];

inline void Build (register int &rt, register int l, register int r) {
	tree[++ nodecnt] = tree[rt], rt = nodecnt;
	if (l == r) return tree[rt].pos = -1, void ();
	register int mid = (l + r) >> 1;
	Build (tree[rt].lch, l, mid), Build (tree[rt].rch, mid + 1, r);
}

inline void Modify (register int &rt, register int l, register int r, register int x, register int pos) {
	tree[++ nodecnt] = tree[rt], rt = nodecnt;
	if (l == r) return tree[rt].pos = pos, void ();
	register int mid = (l + r) >> 1;
	if (x <= mid) Modify (tree[rt].lch, l, mid, x, pos);
	else Modify (tree[rt].rch, mid + 1, r, x, pos);
}

inline int Query (register int rt, register int l, register int r, register int x) {
	if (l == r) return tree[rt].pos;
	register int mid = (l + r) >> 1;
	if (x <= mid) return Query (tree[rt].lch, l, mid, x);
	else return Query (tree[rt].rch, mid + 1, r, x);
}

struct Edge {
	int to, next;
} e[maxn << 1];

int tot, head[maxn];

inline void Add (register int u, register int v) {
	e[++ tot].to = v;
	e[tot].next = head[u];
	head[u] = tot;
}

inline void DFS0 (register int u, register int fa) {
	deep[u] = deep[fa] + 1, size[u] = 1, root[u] = root[fa];
	if (col[u] != -1) Modify (root[u], 1, c, col[u], u);
	if (col[u] == -1 || col[u] == c) f0[u][0] = -1;
	else f0[u][0] = Query (root[u], 1, c, col[u] + 1);
	if (col[u] == -1 || col[u] == 1) f1[u][0] = -1;
	else f1[u][0] = Query (root[u], 1, c, col[u] - 1);
	for (register int i = 1; (1 << i) <= c - col[u]; i ++) f0[u][i] = f0[f0[u][i - 1]][i - 1];
	for (register int i = 1; (1 << i) <= col[u] - 1; i ++) f1[u][i] = f1[f1[u][i - 1]][i - 1];
	for (register int i = head[u]; i; i = e[i].next) {
		register int v = e[i].to;
		if (v == fa) continue;
		f[v] = u, DFS0 (v, u), size[u] += size[v];
		if (size[son[u]] < size[v]) son[u] = v;
	}
}

inline void DFS1 (register int u, register int t) {
	top[u] = t;
	if (son[u]) DFS1 (son[u], t);
	for (register int i = head[u]; i; i = e[i].next) {
		register int v = e[i].to;
		if (v == f[u] || v == son[u]) continue;
		DFS1 (v, v);
	}
}

inline int LCA (register int u, register int v) {
	while (top[u] != top[v]) {
		if (deep[top[u]] < deep[top[v]]) swap (u, v);
		u = f[top[u]];
	}
	return deep[u] < deep[v] ? u : v;
}

inline bool Check (register int u, register int fa, register int lim, register int l) {
	u = Query (root[u], 1, c, lim);
	if (u == -1 || deep[u] < deep[fa]) return 0;
	for (register int i = 20; i >= 0; i --) 
		if (f1[u][i] != -1 && deep[f1[u][i]] > deep[fa]) u = f1[u][i];
	return col[u] <= l;
}

int main () {
	n = read(), m = read(), c = read(), memset (mp, -1, sizeof mp);
	for (register int i = 1; i <= c; i ++) mp[read()] = i;
	for (register int i = 1; i <= n; i ++) col[i] = mp[read()];
	for (register int i = 1, u, v; i <= n - 1; i ++) u = read(), v = read(), Add (u, v), Add (v, u);
	Build (root[0], 1, c), DFS0 (1, 0), DFS1 (1, 1), q = read();
	while (q --) {
		register int u = read(), v = read(), lca = LCA (u, v), ans = 0;
		u = Query (root[u], 1, c, 1);
		if (u != -1 && deep[u] >= deep[lca]) {
			for (register int i = 20; i >= 0; i --) 
				if (f0[u][i] != -1 && deep[f0[u][i]] >= deep[lca]) u = f0[u][i];
			ans = col[u];
		} else ans = 0;
		register int l = ans + 1, r = c;
		while (l <= r) {
			register int mid = (l + r) >> 1;
			if (Check (v, lca, mid, ans + 1)) l = mid + 1;
			else r = mid - 1;
		}
		printf ("%d\n", l - 1);
	}
	return 0;
}
```

---

## 作者：Krimson (赞：2)

[安利个人blog](https://www.cnblogs.com/Guts/p/14653041.html)



------------

感觉算是最简单的几种写法之一了，只需要分块+树剖。  
如果是在序列上，记录一个数组 $nxt[i][j]$ ，表示在块 $i$ 的头上以收集器中第 $j$ 个颜色出发，离开块尾之后的最多能到收集器中的第几个颜色。（为方便，后面的颜色就直接指的是在收集器中对应的位置）    

----------------
考虑如何维护这个东西。
等价于维护一个块内最长的形如 $x,x+1\dots x+l$ 序列的最长长度是多少。  
不难发现可以把这个序列拆成 $x$ 和 $x+1,x+2\dots x+l$。  
因此考虑倒过来做，从后往前枚举当前的下标，如果当前的颜色是 $c_i$，当前以 $c_i$ 开头的最长序列是 $S$ 那么就看 $c_{i-1}+S$ 是不是比当前 $c_{i-1}$ 开头的序列更长。  
同时，因为还有可能是反过来走的，所以还要记录一下反过来的数组 $pre[i][j]$。     
具体的实现可以看最下面的代码中的init函数。

------------
树剖实际上是把树上问题转换成序列问题，在每一条重链上的询问都可以看作是一个三元组 $(l,r,c)$ ，表示从 $l$ 到 $r$ 出发，初始颜色是 $c$ 。  
跳到 $lca$ 处最多经过 $\log n$ 条重链，所以有一次询问的复杂度  $
\left \{
\begin{aligned}
&	O(T)=\sum^{t}_{i=1}\sqrt{a_i}\\
&	\sum^{t}_{i=1}a_i \leq n\\
&	t\leq \log n\\
\end{aligned}
\right.
$ 

不难得到上面的最劣情况复杂度$
O(T)=t\sqrt{\frac{n}{t}}=\sqrt{nt}  
$。

所以这样子的总复杂度是$O(n\sqrt{n}+q\sqrt{n\log n})$，而且几乎跑不满，在随机数据下跑得还挺快，极限数据大概跑$0.3 - 0.5s$。  
实际上，这个还可以继续优化。  
考虑每一条重链，在链顶和链尾也像之前分块这样维护数组 $nxt$ 和 $pre$ ，时空复杂度均为 $O(n\log n)$（这里视 $n$ ，$m$ 同阶）。  
这样，每次需要在链上暴力分块的只剩下了开头和结尾两根，剩下的都可以 $O(1)$ 转移，总复杂度优化到了 $O(n\log n+q(\sqrt{n}+\log n))$  
不过考场上觉得第二种太麻烦了，而且第一个看起来能过，再加上时间不够，就没去优化。  

下面这份代码是考场上写的，理论复杂度是有些问题的，正确的分块预处理方式应该是对于每一条重链都以该重链的长度的根号为块长分块才能保证单次询问$O(\sqrt {n \log n})$。  
图一个方便，再加上实际运行效率差不多，甚至更优秀，就直接以512为块长了。  



_Code_
------------
```cpp
#include<bits/stdc++.h>
using namespace std;
#define il inline 
#define ll long long
#define ri register int 
il ll read(){
	ll x=0;
	char ch=getchar(),f=1;
	for(;ch<'0'||ch>'9';ch=getchar()) 
		if(ch=='-') f=0;
	for(;ch>='0'&&ch<='9';ch=getchar())
		x=x*10+ch-'0';
	if(f) return x;
	return -x;
}
il void write(ll x){
	if(x>9) write(x/10);
	putchar(x%10+'0');
}
il ll max(ll x,ll y){return x>y?x:y;}
il ll min(ll x,ll y){return x<y?x:y;}
il void print(ll x){
	if(x<0) putchar('-'),x=-x;
	write(x);
	putchar('\n');
}
/*
for pai
*/
int n,m,c;
const int MAXN=2e5+7;
const int MAXM=1e5+7;
int p[MAXN],w[MAXN],id[MAXN];//收集器中的颜色，当前点的颜色，颜色在收集器中对应的下标
vector<int> g[MAXN];
int fa[MAXN],top[MAXN],dfn[MAXN],siz[MAXN],dep[MAXN],son[MAXN],idfn[MAXN],dson[MAXN],ddep[MAXN];
#define B 512
void dfs1(int u,int f,int deep){
	fa[u]=f;
	ddep[u]=dep[u]=deep;
	siz[u]=1;
	int mx=-1;
	for(ri i=0;i<g[u].size();++i){
		int v=g[u][i];
		if(v==f) continue;
		dfs1(v,u,deep+1);
		siz[u]+=siz[v];
		if(siz[v]>mx){
			son[u]=v;
			mx=siz[v];
		}
	}
}
int cnt;
void dfs2(int u,int f,int topf){
	dson[topf]=u;
	dfn[u]=++cnt;
	idfn[cnt]=u;
	top[u]=topf;
	if(son[u]) dfs2(son[u],u,topf);
	for(ri i=0;i<g[u].size();++i){
		int v=g[u][i];
		if(v==son[u]||v==f) continue;
		dfs2(v,u,v);
	}
}
int bpre[B][MAXM],bnxt[B][MAXM];
int solve_1(int l,int r,int now,int flag){
	//printf("%d %d %d %d\n",l,r,flag,now);
	if(flag){
		for(ri i=l;i<=r;++i){
			int u=idfn[i];
			if(now<c&&p[now+1]==w[u]){
				++now;
			}
		}
	}
	else{
		for(ri i=r;i>=l;--i){
			int u=idfn[i];
			//print(u);
			if(now<c&&p[now+1]==w[u]) ++now;
		}
	}
	//print(now);
	return now;
}

int solve_2(int l,int r,int now,int flag){
	if(l/B==r/B) return solve_1(l,r,now,flag);
	if(flag){
		//puts("fuck");
		now=solve_1(l,l/B*B+B-1,now,flag);
		for(ri i=l/B+1;i<r/B;++i) now=bnxt[i][now];
		now=solve_1(r/B*B,r,now,flag);
	}
	else{
		//puts("fuck");
		now=solve_1(r/B*B,r,now,flag);
		for(ri i=r/B-1;i>l/B;--i) now=bpre[i][now];
		now=solve_1(l,l/B*B+B-1,now,flag);
	}
	return now;
}
int LCA(int u,int v){
	while(top[u]!=top[v]){
		if(dep[top[u]]<dep[top[v]]) swap(u,v);
		u=fa[top[u]];
	}
	if(dep[u]<dep[v]) swap(u,v);
	return v;
}
int vec[MAXN],head;
int solve_3(int u,int v){
	int now=0;
	head=0;
	int lca=LCA(u,v);
	while(top[u]!=top[lca]){
		vec[++head]=u;
		u=fa[top[u]];
	}
	for(ri i=1;i<=head;++i){
		now=solve_2(dfn[top[vec[i]]],dfn[vec[i]],now,0);
	}
	now=solve_2(dfn[lca],dfn[u],now,0);
	head=0;
	while(top[v]!=top[lca]){
		vec[++head]=v;
		v=fa[top[v]];
	}
	now=solve_2(dfn[lca],dfn[v],now,1);
	for(ri i=head;i;--i){
		now=solve_2(dfn[top[vec[i]]],dfn[vec[i]],now,1);
	}
	return now;
}
void init(){
	for(ri i=0;i<=n/B;++i){
		int l=i*B,r=min(n,l+B-1);
		for(ri j=0;j<=c;++j) bpre[i][j]=j;
		for(ri j=l;j<=r;++j){
			int v=w[idfn[j]];
			if(!id[v]) continue;
			bpre[i][id[v]-1]=max(bpre[i][id[v]-1],bpre[i][id[v]]);
		}
		for(ri j=0;j<=c;++j) bnxt[i][j]=j;
		for(ri j=r;j>=l;--j){
			int v=w[idfn[j]];
			if(!id[v]) continue;
			bnxt[i][id[v]-1]=max(bnxt[i][id[v]-1],bnxt[i][id[v]]);
		}
	}
}
int main(){
	//freopen("gem.in","r",stdin);
	//freopen("gem.out","w",stdout);
	n=read(),m=read(),c=read();
	for(ri i=1;i<=c;++i) p[i]=read(),id[p[i]]=i;
	for(ri i=1;i<=n;++i) w[i]=read();
	for(ri i=1;i<n;++i){
		int u=read(),v=read();
		g[u].push_back(v);
		g[v].push_back(u);
	}
	dfs1(1,0,1);
	dfs2(1,0,1);
	init();
	for(ri t=read();t;--t){
		int u=read(),v=read();
		print(solve_3(u,v));
	}
}
```

---

## 作者：FunnyCreatress (赞：1)

由于我脑回路比较清奇想不到二分啥的，所以看到路径就想着点分治做，结果还真能做，就来水一发题解。

首先对原树建点分树，暴力跳端点把询问挂在一个点下面使得路径过根且在子树内。对于每一层的树，需要处理以下信息：

- $f_x$ 表示从 $x$ 开始走到根，**下一个**需要收集的是第几个。
- $g_{x,i}$ 表示在根时**下一个**要收集的是 $i$，走到 $x$ 时**下一个**是第几个。

这样，对于一组询问 $s,t$，我们的答案就是 $g_{t,f_s}-1$。

$f_x$ 单独拿出来不好处理，我们扩展一个维度，设 $h_{x,i}$ 为到 $x$ 这个点时要收集的是 $i$，走到根时下一个收集哪个。

那么有转移：
$$h_{x,i}=h_{fa,i+[w_x=p_i]}$$
我们发现，每个点与父亲的 $h$ 数组只有一个位置不同，一边 dfs 一边维护数组即可求出所有 $f_x$。

处理完 $f_x$，我们来处理 $g$，这个 $g$ 明显更ex一些，可以用主席树，但有更简便的方法：

$$g_{x,i}=g_{fa,i}+[g_{fa,i}=w_x]$$

容易发现，每次只会将一种指定的值变为另一种，可以用并查集维护，不过因为不止一种合并路线，所以需要支持撤销操作，用可撤销并查集即可。

复杂度 $O(n\log^2n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e5+5;
int n,m,c,q,w[N],p[N],hd[N],nxt[N<<1],to[N<<1],tot,s[N],t[N],ans[N],id[N];
int sz[N],fa[N],dep[N];bool vst[N];vector<int> Q[N],qq[N];
void add(int x,int y){to[++tot]=y,nxt[tot]=hd[x],hd[x]=tot;}
void dfs(int x,int Fa){
	sz[x]=1;
	for(int i=hd[x],y;i;i=nxt[i])
		if(!vst[y=to[i]]&&y!=Fa)dfs(y,x),sz[x]+=sz[y];
}
int getg(int x,int Fa,int Sz){
	for(int i=hd[x],y,t;i;i=nxt[i])
		if(!vst[y=to[i]]&&y!=Fa){if(t=getg(y,x,Sz))return t;}
	return sz[x]>(Sz>>1)?x:0;
}
void build(int x,int Fa){
	dfs(x,0);int g=getg(x,0,sz[x]);fa[g]=Fa,dep[g]=dep[Fa]+1,vst[g]=1,dfs(g,0);
	for(int i=hd[g],y;i;i=nxt[i])if(!vst[y=to[i]])build(y,g);
}
void clear(int x,int Fa){
	qq[x].clear();
	for(int i=hd[x],y;i;i=nxt[i])
		if(!vst[y=to[i]]&&y!=Fa)clear(y,x);
}
int f[N],tmpf[N],g[N],rt[N],pp[N],depp[N];
void dfs2(int x,int Fa){
	if(Fa==0){for(int i=1;i<=sz[x]+1;i++)tmpf[i]=i+(p[i]==w[x]);}
	f[x]=tmpf[1];
	for(int i=hd[x],y,tc,tw;i;i=nxt[i])if(!vst[y=to[i]]&&y!=Fa){
		tc=id[w[y]];if(~tc)tw=tmpf[tc],tmpf[tc]=tmpf[tc+1];
		dfs2(y,x);
		if(~tc)tmpf[tc]=tw;
	}
}
int fnd(int x){return pp[x]==x?x:fnd(pp[x]);}
void dfs3(int x,int Fa){
	if(Fa==0){for(int i=1;i<=sz[x]+1;i++)rt[i]=g[i]=pp[i]=i,depp[i]=1;}
	for(int i=0;i<qq[x].size();i++)ans[qq[x][i]]=g[fnd(f[s[qq[x][i]]])]-1;
	for(int i=hd[x],y,tc,trt,nrt;i;i=nxt[i])if(!vst[y=to[i]]&&y!=Fa){
		tc=id[w[y]];bool fuck=0,swaped=0;
		if(~tc){
			trt=rt[tc];
			if(!rt[tc+1])rt[tc+1]=trt,rt[tc]=0,g[trt]++,fuck=1;
			else if(depp[trt]<depp[rt[tc+1]])pp[trt]=rt[tc+1],rt[tc]=0;
			else if(depp[trt]==depp[rt[tc+1]])pp[trt]=rt[tc+1],rt[tc]=0,depp[rt[tc+1]]++;
			else pp[nrt=rt[tc+1]]=trt,rt[tc]=0,swap(g[nrt],g[trt]),rt[tc+1]=trt,swaped=1;
		}
		dfs3(y,x);
		if(~tc){
			if(fuck)rt[tc]=trt,rt[tc+1]=0,g[trt]--;
			else if(!swaped)pp[trt]=trt,rt[tc]=trt;
			else rt[tc]=trt,pp[nrt]=nrt,rt[tc+1]=nrt,swap(g[nrt],g[trt]);
		}
	}
}
void solve(int x){
	dfs(x,0);int g=getg(x,0,sz[x]);vst[g]=1,dfs(g,0),clear(g,0);
	for(int i=0;i<Q[g].size();i++)qq[t[Q[g][i]]].push_back(Q[g][i]);
	dfs2(g,0),dfs3(g,0);
	for(int i=hd[g],y;i;i=nxt[i])if(!vst[y=to[i]])solve(y);
}
int main(){
	scanf("%d%d%d",&n,&m,&c);
	fill(id,id+c+1,-1);
	for(int i=1;i<=c;i++)scanf("%d",&p[i]),id[p[i]]=i;
	for(int i=1;i<=n;i++)scanf("%d",&w[i]);
	for(int i=1,x,y;i<n;i++)scanf("%d%d",&x,&y),add(x,y),add(y,x);
	build(1,0);
	scanf("%d",&q);
	for(int i=1,j,k;i<=q;i++){
		scanf("%d%d",&s[i],&t[i]);
		for(j=s[i],k=t[i];j!=k;j=fa[j])
			if(dep[j]<dep[k])swap(j,k);
		Q[j].push_back(i);
	}
	fill(vst,vst+n+1,0);
	solve(1);
	for(int i=1;i<=q;i++)printf("%d\n",ans[i]);
	return 0;
}
```

---

## 作者：Warriors_Cat (赞：1)

[洛谷题面传送门](https://www.luogu.com.cn/problem/P7518)。

题意：

* 给定 $n, m, c$、一个长为 $c$ 的序列 $p_i$ 和 一棵点权分别为 $w_i$ 的一棵树，其中 $p_i \le m$ 且互不相同。

* $q$ 组询问，每次给定 $s, t$，寻问树上 $s$ 到 $t$ 的路径的 $w_i$ 组成的一条序列与 $p$ 序列从头开始最长匹配子序列长度为多少。

* $n, q \le 2\times 10^5$，$c\le m \le 5\times 10^4$。

个人认为算是省选当中第二简单的题了，不过有些码农（

---

### Solution：

我们不妨考虑将每个序列拆成 $s\rightarrow lca$ 和 $lca\rightarrow t$ 两条链。

对于 $s\rightarrow lca$：

我们对每种权值维护一个栈，栈里表示根到当前点上每种权值有哪些点，从根节点开始搜索，当搜到一个点 $u$ 的时候就查找它的权值在 $p$ 序列中对应的是哪一个位置，并找出这个对应位置下一个位置的上的权值的栈顶上的点，并将其记为 $suf_u$，如果没有则 $suf_u = 0$。

不妨举一个例子（其实是样例），每个点括号内的数表示它的权值，$\{q_i\} = \{2, 3, 1\}$：

![](https://cdn.luogu.com.cn/upload/image_hosting/2bjq6d6n.png)

在这幅图中，点 $3$ 的权值为 $3$，在 $q$ 序列中第 $2$ 个位置，于是我们查找第三个位置的权值的栈顶，即权值 $1$ 的栈顶，发现是 $2$，于是 $suf_3 = 2$。

同理有 $suf_1 = 0, suf_2 = 0, suf_4 = 0, suf_5 = 4, suf_6 = 0, suf_7 = 6$。

同时，我们记录当前栈中权值 $p_1$ 栈顶的点，记为 $fir_u$，比如在上图中，有 $fir_1 = 1, fir_2 = 1, fir_3 = 1, fir_4 = 1, fir_5 = 5, fir_6 = 1, fir_7 = 1$。

那么，我们建一棵新的树，其中对于每一组 $(u, suf_u)$，有连边 $suf_u \rightarrow u$。

那么，对于起点 $s$，我们就可以先让 $s$ 走到 $fir_s$，然后在新的树上一直向上爬，爬到它的深度低于了 $lca$ 为止。而这个爬的实现就是倍增预处理新树上 $2^k$ 级祖先。这样 $s\rightarrow lca$ 就搞定了。

对于 $lca \rightarrow t$：

我们考虑把所有 $lca \rightarrow t$ 的询问离线下来，以 $t$ 为关键值来分类所有的询问。我们从根节点出发，照样维护每种权值的一个栈，只不过我们要记录的则是当前节点 $u$ 所在 $p$ 序列位置的上一个位置的权值的栈顶节点，记为 $pre_u$，没有则仍然有 $pre_u = 0$。

比如在上面那个例子中，有 $pre_1 = 0, pre_2 = 0, pre_3 = 1, pre_4 = 1, pre_5 = 0, pre_6 = 4, pre_7 = 1$。

同样，我们再建一棵新的树，其中对于每一组 $(u, pre_u)$，有连边 $pre_u \rightarrow u$。

考虑二分答案，二分当前能走到 $p$ 序列上的位置 $mid$。首先我们从 $t$ 跳到权值 $p_{mid}$ 的栈顶。然后像刚才一样在新树上倍增跳祖先，直到跳到 $s\rightarrow lca$ 时最远能跳到的位置。如果这个点深度比 $lca$ 小，那就不行，否则可以。

最后的答案就是两部分相加。

当然还有另外一种做法，考虑序列上的怎么做，就是像刚才那样找 $pre$ 和 $suf$，接着树剖把一个链剖成 $\log n$ 个区间，每个区间单独倍增处理就行。

over，时间复杂度为 $O(n\log n\log m)$，默认 $n, q$ 同阶，$m, c$ 同阶。

---

### Code：

实现的时候多注意细节，因为个人写得有些码农。

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <cmath>
#include <vector>
#include <queue>
#include <map>
#include <set>
using namespace std;
#define ll long long
#define ull unsigned long long
#define fi first
#define se second
#define dingyi int mid = l + r >> 1, ls = p << 1, rs = p << 1 | 1
#define y0 y_csyakioi_0
#define y1 y_csyakioi_1
#define rep(i, x, y) for(int i = x; i <= y; ++i)
#define per(i, x, y) for(int i = x; i >= y; --i)
#define repg(i, u) for(int i = head[u]; i; i = e[i].nxt)
inline int read(){
	int x = 0, f = 1; char ch = getchar();
	while(ch < '0' || ch > '9'){ if(ch == '-') f = -1; ch = getchar(); }
	while(ch >= '0' && ch <= '9'){ x = x * 10 + (ch ^ 48); ch = getchar(); }
	return x * f;
}
const int N = 200010, M = 50010;
struct edge{
	int v, nxt;
}e[N << 1], e2[N << 1];
struct node{
	int u, v, lca;
	node(int a = 0, int b = 0, int c = 0){
		u = a; v = b; lca = c;
	}
}Q[N];
int head[N], head2[N], cnt, cnt2, n, m, k, q, p[N], c[N], x, y, z;
int dep[N], posp[N], suf1[N], suf2[N], f[N][20], R[N], f2[N][20], ans[N];
bool canbe[N], vis[N];
vector <int> pos[N], ask[N];
inline void add(int u, int v){
	e[++cnt].v = v;
	e[cnt].nxt = head[u];
	head[u] = cnt;
}
inline void add2(int u, int v){
	e2[++cnt2].v = v;
	e2[cnt2].nxt = head2[u];
	head2[u] = cnt2;
}
inline void dfs1(int u, int fa){
	dep[u] = dep[fa] + 1; f[u][0] = fa;
	rep(i, 1, 17) f[u][i] = f[f[u][i - 1]][i - 1];
	pos[c[u]].push_back(u);
	if((int)pos[p[1]].size()) suf1[u] = (*(--pos[p[1]].end()));
	if(posp[c[u]] != n && (int)pos[p[posp[c[u]] + 1]].size()) suf2[u] = (*(--pos[p[posp[c[u]] + 1]].end()));
	if(suf2[u]){
		f2[u][0] = suf2[u];
		rep(i, 1, 17) f2[u][i] = f2[f2[u][i - 1]][i - 1];
	}
	repg(i, u){
		int v = e[i].v; if(v == fa) continue;
		dfs1(v, u);
	}
	pos[c[u]].pop_back();
}
inline int lca(int x, int y){
	if(dep[x] < dep[y]) swap(x, y);
	per(i, 17, 0) if(dep[f[x][i]] >= dep[y]) x = f[x][i];
	if(x == y) return x;
	per(i, 17, 0) if(f[x][i] != f[y][i]) x = f[x][i], y = f[y][i];
	return f[x][0];
}
inline void work(int idx){
	if(canbe[idx]){ R[idx] = 1; return; }
	int x = Q[idx].u, z = Q[idx].lca;
	int ans = 1;
	per(i, 17, 0) if(dep[f2[x][i]] >= dep[z]) x = f2[x][i], ans += (1 << i);
	R[idx] = ans + 1; return;
}
inline bool check(int idx, int mid){
	int y = Q[idx].v, z = Q[idx].lca, cur = y;
	//printf("%d %d %d %d\n", idx, y, z, mid);
	if(!(int)pos[p[mid]].size()) return 0;
	int x = (*(--pos[p[mid]].end()));
	//printf("%d\n", x);
	if(dep[x] < dep[z]) return 0; cur = x;
	int num = mid - R[idx];
	per(i, 17, 0) if(num >> i & 1) cur = f2[cur][i];
	if(!cur || dep[cur] < dep[z]) return 0;
	return 1;
}
inline void dfs3(int u, int fa){
	pos[c[u]].push_back(u);
	if(posp[c[u]] != 1 && (int)pos[p[posp[c[u]] - 1]].size()) suf2[u] = (*(--pos[p[posp[c[u]] - 1]].end()));
	if(suf2[u]){
		//printf("%d %d\n", u, suf2[u]);
		f2[u][0] = suf2[u];
		rep(i, 1, 17) f2[u][i] = f2[f2[u][i - 1]][i - 1];
	}
	if((int)ask[u].size()) rep(t, 0, (int)ask[u].size() - 1){
		int idx = ask[u][t];
		int l = R[idx], r = k, Ans = 0;
		while(l <= r){
			int mid = l + r >> 1;
			if(check(idx, mid)) Ans = mid, l = mid + 1;
			else r = mid - 1;
		}
		ans[idx] = Ans;
	}
	repg(i, u){
		int v = e[i].v; if(v == fa) continue;
		dfs3(v, u);
	}
	pos[c[u]].pop_back();
}
inline void mian(){
	n = read(); m = read(); k = read();
	rep(i, 1, k) p[i] = read();
	rep(i, 1, n) c[i] = read();
	rep(i, 1, n - 1){
		x = read(); y = read();
		add(x, y); add(y, x);
	}
	rep(i, 1, k) posp[p[i]] = i;
	dfs1(1, 0); q = read();
	//rep(i, 1, n) printf("%d %d %d\n", i, suf1[i], suf2[i]);
	rep(i, 1, q){
		x = read(); y = read(); z = lca(x, y);
		x = suf1[x]; if(dep[x] < dep[z]) canbe[i] = 1, x = z;
		//printf("xcy %d %d %d\n", x, y, z);
		Q[i] = node(x, y, z);
	}
	rep(i, 1, q) work(i);
	rep(i, 1, q) ask[Q[i].v].push_back(i);
	//rep(i, 1, q) printf("%d\n", R[i]);
	rep(i, 0, n) rep(j, 0, 17) f2[i][j] = 0;
	rep(i, 0, n) suf1[i] = suf2[i] = 0;
	dfs3(1, 0);
	rep(i, 1, q){
		if(!ans[i]) ans[i] = R[i] - 1;
		printf("%d\n", ans[i]);
	}
}
int main(){ int qwq = 1; while(qwq--) mian(); return 0; }
```


---

## 作者：某科学的蒟蒻 (赞：0)

写一下我在考场上的思考过程吧。

首先，对于测试点 $1∼5$ 我们可以一步一步走 $s_i$ 至 $t_i$ 的路径，求出最多能放多少块宝石。

对于测试点 $6∼10$ ，我们发现 $m$ 很小，因此我们可以用这样一种思路来解决这个部分分：求出 $s_i$ 到 $t_i$ 路径上最靠近 $s_i$ 的 $P_1$ ，假设这个 $P_1$ 宝石所在的点为 $v_1$ ，继续在 $v_1$ 到 $t_i$ 的路径上找最靠近 $v_1$ 的 $P_2$ ……以此类推。上述思路可以用**重链剖分**来实现。假设当前要在 $v_j$ 到 $t_i$ 的路径上找 $P_{j+1}$ ， $v_j$ 所在的重链的顶部为 $u_j$ ,因为重链上点的 $dfs$ 序是连续的，所以在知道所有 $P_{j+1}$ 的点的 $dfs$ 序的情况下我们可以通过二分判断 $v_j$ 至 $u_j$ 间是否有 $P_{j+1}$ 的点，以及如果有的情况下最靠近 $v_j$ 或最靠近 $u_j$ 的是哪个。因此，我们可以依次在 $s_i$ 到 $lca$ （ $s_i$ 与 $t_i$ 的 $lca$ ）， $lca$ 到 $t_i$ 的重链上尽可能的选择可选且靠前的宝石放入。对于拥有宝石 $P_i$ 的点我们可以开一个 $vector$ 来存储，按 $dfs$ 序遍历时依次放入。时间复杂度为  $O(qmlog_2n+qlog_2^2n)$ 。（没写过，不知道能不能过）

对于测试点 $11∼14$ ，即树退化为链的测试点，由于序列 $P$ 中的数各不相同，我们可以用倍增的方法来处理。下面以 $s_i$ 到 $t_i$ 从左至右考虑（反过来同理），所有的点上的宝石都出现在序列 $P$ 中（不存在的不影响）。设 $v_j$ 上的宝石为 $P_i$ ，设在 $v_j$ 右侧的最近的宝石 $P_{i+1}$ 为 $u$ ，设 $fa_{v_j,0}$ 为 $u$ ，表示 $v_j$ 对应在 $P$ 上的位置前进 $1$ (即 $2^0$ )步（在放入 $P_i$ 后再放入一颗宝石 $P_{i+1}$ )需要在链上到达的最近的点。我们可以倍增求出 $fa_{i,1},fa_{i,2}....$ 然后单次 $O(log_2n)$ 的查询即可。复杂度为 $O((n+q)log_2n)$ 。

现在考虑做掉这道题。对于从 $s_i$ 到 $lca$ 的路径，我们可以在测试点 $6∼10$ 的重链剖分上优化。我们可以在每条重链上使用倍增，判断在这条重链上最多还能放多少宝石。对于从 $lca$ 到 $t_i$ 的路径，我们可以用类似的方法处理，不过现在要改为从上至下的倍增，即沿着这条重链（从高到低）从 $v$ 跳 $2^i$ 步最近能跳到哪。

现在来说明如何预处理从上至下的倍增。在预处理树剖时每次 $dfs$ 到一条重链的叶子节点，就把这条重链拿出来用测试点 $11∼14$ 的方法处理。每个点只会处理一次，预处理复杂度为 $O(nlog_2n)$ 

一个点到根最多经过 $O(log_2n)$ 条重链，每条重链上 $O(log_2n)$ 的二分与倍增，因此总的复杂度为 $O(qlog_2^2n)$ 。

考场代码(死长烂长蚂蜂剧毒)：

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<vector>
using namespace std;
const int MaxN=(int)2e5,MaxZs=18,MaxM=(int)5e4;
int n,m,c,Numin,Pin,ug[MaxN+5][MaxZs],dg[MaxN+5][MaxZs],fa[MaxN+5],tp[MaxN+5],wson[MaxN+5],son[MaxN+5],dep[MaxN+5],q,P[MaxM+5],ge[MaxN+5];
int Head[MaxN+5],EdgeNum,dy[MaxM+5],dfn[MaxN+5],nt,sta[MaxN+5],STP,lst[MaxM+5],cx[MaxM+5],cxtot,NowLca,st,l,r,mid,fd,pw[MaxZs];
bool hap[MaxM+5];
vector<int>v[MaxM+5];
char Ci;
struct EDGE
{
	int to,nx;
}e[2*MaxN+5];
int Read()
{
	Numin=0,Pin=1;Ci=0;
	while(Ci<'0'||Ci>'9'){if(Ci=='-') Pin=-1;Ci=getchar();}
	while(Ci>='0'&&Ci<='9'){Numin=Numin*10+Ci-'0';Ci=getchar();}
	return Numin*Pin;
}
void Build(int from,int to)
{
	e[++EdgeNum].to=to;
	e[EdgeNum].nx=Head[from];
	Head[from]=EdgeNum;
}
void dfs1(int node)
{
	int mx;
	son[node]=1;
	if(fa[node] && dy[ge[node]]>0)
	{
		mx=v[P[dy[ge[node]]+1]].size();
		if(mx>0)
		{
			ug[node][0]=v[P[dy[ge[node]]+1]][mx-1];
			for(int i=1;i<MaxZs;i++)
				if(ug[ug[node][i-1]][i-1]>0)
					ug[node][i]=ug[ug[node][i-1]][i-1];
				else
					break;
		}
	}
	mx=0;
	v[ge[node]].push_back(node);
	for(int i=Head[node];i;i=e[i].nx)
		if(e[i].to!=fa[node])
		{
			dep[e[i].to]=dep[node]+1;fa[e[i].to]=node;
			dfs1(e[i].to);
			son[node]+=son[e[i].to];
			if(son[e[i].to]>mx)
			{
				mx=son[e[i].to];
				wson[node]=e[i].to;
			}
		}
	v[ge[node]].pop_back();
}
void Calc(int From,int To)
{
	STP=1;
	sta[STP]=From;
	int Now=From;
	while(Now!=To)
	{
		Now=fa[Now];
		sta[++STP]=Now;
		if(Now==To)
			break;
	}
	cxtot=0;
	for(int i=1;i<=STP;i++)
	{
		Now=sta[i];
		if(hap[P[dy[ge[Now]]+1]] && dy[ge[Now]]>0)
		{
			dg[Now][0]=lst[P[dy[ge[Now]]+1]];
			for(int j=1;j<=MaxZs;j++)
				if(dg[dg[Now][j-1]][j-1]>0)
					dg[Now][j]=dg[dg[Now][j-1]][j-1];
				else
					break;
		}
		lst[ge[Now]]=Now;
		if(!hap[ge[Now]])
		{
			hap[ge[Now]]=true;
			cx[++cxtot]=ge[Now];
		}
	}
	for(int j=1;j<=cxtot;j++)
	{
		Now=cx[j];
		hap[cx[j]]=false;
	}
}
void dfs2(int node,int TOP)
{
	tp[node]=TOP;dfn[node]=++nt;v[ge[node]].push_back(node);
	if(wson[node])
		dfs2(wson[node],TOP);
	else
	{
		Calc(node,TOP);
		return ;
	}
	for(int i=Head[node];i;i=e[i].nx)
		if(e[i].to!=fa[node] && e[i].to!=wson[node])
			dfs2(e[i].to,e[i].to);
}
void LCA(int n1,int n2)
{
	while(tp[n1]!=tp[n2])
	{
		if(dep[tp[n1]]<dep[tp[n2]])
		{
			n1^=n2;n2^=n1;n1^=n2;
		}
		n1=fa[tp[n1]];
	}
	if(dep[n1]<dep[n2])
		NowLca=n1;
	else
		NowLca=n2;
}
int check(int nl,int nr,int co)
{
	l=0;r=v[co].size();r--;
	fd=-1;
	while(l<=r)
	{
		mid=(l+r)>>1;
		if(dfn[v[co][mid]]>=nl && dfn[v[co][mid]]<=nr)
		{
			fd=v[co][mid];
			l=mid+1;
		}
		else if(dfn[v[co][mid]]>nr)
			r=mid-1;
		else
			l=mid+1;
	}
	return fd;
}
int check1(int nl,int nr,int co)
{
	l=0;r=v[co].size();r--;
	fd=-1;
	while(l<=r)
	{
		mid=(l+r)>>1;
		if(dfn[v[co][mid]]>=nl && dfn[v[co][mid]]<=nr)
		{
			fd=v[co][mid];
			r=mid-1;
		}
		else if(dfn[v[co][mid]]>nr)
			r=mid-1;
		else
			l=mid+1;
	}
	return fd;
}
void Calc_Up(int Now)
{
	int nf=0,nn;
	while(tp[Now]!=tp[NowLca])
	{
		nn=check(dfn[tp[Now]],dfn[Now],P[1]);
		if(nn>0)
			break;
		Now=fa[tp[Now]];
	}
	if(nn<=0)
		nn=check(dfn[NowLca],dfn[Now],P[1]);
	if(nn>0)
	{
		st=1;Now=nn;
		for(int i=MaxZs-1;i>=0;i--)
			if(ug[Now][i] && dfn[ug[Now][i]]>=dfn[NowLca])
			{
				st+=pw[i];
				Now=ug[Now][i];
			}
	}
}
void Calc_Down(int From)
{
	STP=0;int Now=From,nn,Nx;
	while(tp[Now]!=tp[NowLca])
	{
		sta[++STP]=tp[Now];
		Now=fa[tp[Now]];
	}
	if(!STP)
	{
		nn=check1(dfn[NowLca]+1,dfn[From],P[st+1]);
		if(nn>0)
		{
			st++;
			for(int i=MaxZs-1;i>=0;i--)
				if(dg[nn][i] && dfn[dg[nn][i]]<=dfn[From])
				{
					st+=pw[i];
					nn=dg[nn][i];
				}
		}
		return ;
	}
	nn=check1(dfn[NowLca]+1,dfn[fa[sta[STP]]],P[st+1]);
	if(nn>0)
	{
		st++;
		for(int i=MaxZs-1;i>=0;i--)
			if(dg[nn][i] && dfn[dg[nn][i]]<=dfn[fa[sta[STP]]])
			{
				st+=pw[i];
				nn=dg[nn][i];
			}
	}
	for(int i=STP;i>1;i--)
	{
		Now=sta[i];Nx=sta[i-1];
		nn=check1(dfn[Now],dfn[fa[Nx]],P[st+1]);
		if(nn>0)
		{
			st++;
			for(int j=MaxZs-1;j>=0;j--)
				if(dg[nn][j] && dfn[dg[nn][j]]<=dfn[fa[Nx]])
				{
					st+=pw[j];
					nn=dg[nn][j];
				}
		}
	}
	if(STP)
	{
		Now=sta[1];Nx=From;
		nn=check1(dfn[Now],dfn[Nx],P[st+1]);
		if(nn>0)
		{
			st++;
			for(int j=MaxZs-1;j>=0;j--)
				if(dg[nn][j] && dfn[dg[nn][j]]<=dfn[Nx])
				{
					st+=pw[j];
					nn=dg[nn][j];
				}
		}
	}
}
int main()
{
	freopen("gem.in","r",stdin);
	freopen("gem.out","w",stdout);
	pw[0]=1;
	for(int i=1;i<MaxZs;i++)
		pw[i]=pw[i-1]*2;
	n=Read();m=Read();c=Read();
	for(int i=1;i<=c;i++)
	{
		P[i]=Read();
		dy[P[i]]=i;
	}
	P[c+1]=m+1;
	for(int i=1;i<=n;i++)
		ge[i]=Read();
	int a,b;
	for(int i=1;i<n;i++)
	{
		a=Read();b=Read();
		Build(a,b);
		Build(b,a);
	}
	dfs1(1);
	dfs2(1,1);
	q=Read();
	for(int i=1;i<=q;i++)
	{
		a=Read();b=Read();
		LCA(a,b);//LCA%%%
		st=0;
		Calc_Up(a);
		Calc_Down(b);
		printf("%d\n",st);
	}
	return 0;
}


```

---

## 作者：Saliеri (赞：0)

说在前面：这是一篇非正解。本题解时间复杂度（认为 $n,q$ 同阶）为 $O(n\sqrt n + n \log^2 n)$。~~但是最大点 400 ms……数据估计饺造的~~

___

简要分析一下题目：我们可以发现一个很重要的性质： 其中 $P_i$
**互不相等**。

这给予了我们一个重要的启发：如果我们钦定在一个点收集有用的宝石，那么收集的这个宝石在宝石序列中的**位置唯一**。

然后大多数人好像就以这个性质 树剖+倍增，但是**根号分治**显然是思维难度更小的选择——在树上每 $\sqrt n$ 步并为一步地跳到目的地。显然这样跳的次数与预处理的步数都不超过 $O(\sqrt n)$，使得空间和时间都可以接受。

接下来就是实现部分：

首先将路径拆分为 $x\rightarrow lca$ 与 $lca \rightarrow y$ 两段，这样做成直上直下的路径方便处理。

延续上面的思想，为了避免路径上的分支，我们将原树重链剖分，对于每一个点预处理 $\text{jump}_{0/1,j} (j \in [1,\sqrt n])$ ，表示以这个点在宝石序列中的位置作为开始，沿重链向上/下再收集 $j$ 个宝石到达的点。（如果在这条重链上无法收集这么多宝石或者这个点上的宝石不在宝石序列中出现，则为 0）。

这个数组的预处理可以在 $O(n\sqrt n)$ 的时间内解决。

回答询问时，因为我们知道当前即将要收集什么宝石，所以就带有方向性的去找第一个下一个需要的宝石，用它所在位置的 $\text{jump}$ 数组快速跳跃即可。

但是我们发现需要维护一个操作：查询在一段重链上 第一个/最后一个 某一种颜色。

由于重链剖分的良好性质，一条重链上的 dfn 序也连续，所以我们对于每一种颜色，维护 dfn 序的 vector，需要询问时在上面二分查询即可。

对于回答询问，单次复杂度至多为 $O(\sqrt n + \log^2 n)$（至多 $O(\sqrt n)$ 步，至多 $O(\log n)$ 条重链，每一条重链上都需要一次 $O(\log n)$ 的二分）。

___

口胡一般来说是够了，还有不懂的就看代码吧。

本写法细节较多，请注意精细实现。（比如说 vector 上要设哨兵）。

因为是考场代码，所以码风像 * 一样，不喜勿喷。

```cpp
#include <map>
#include <cstdio>
#include <vector>
#include <algorithm>
inline int re() {
	char c;
	int w=1;
	while((c=getchar())<'0'||c>'9')if(c=='-')w=-1;
	int res = c-'0';
	while((c=getchar())>='0'&&c<='9')res = res*10+c-'0';
	return res*w;
}
inline int max(int a,int b) {return a>b?a:b;}
const int maxn = 2e5+5;
int n,m,c,q,nd[maxn],col[maxn];
int head[maxn],tot;
struct Edge {
	int next,to;
} e[maxn<<1];
void add_edge(int x,int y) {
	e[++tot].next = head[x];
	e[tot].to = y,head[x] = tot;
}
namespace Sol {
	const int maxb = 205,B = 200;
	int colpos[maxn],pos[maxn];
	int fa[maxn],dep[maxn],siz[maxn],son[maxn],top[maxn],in[maxn],rnk[maxn],tim;
	std :: vector <int> chain[maxn],colin[maxn],cols[maxn],tmp;
	int jumpu[maxn][maxb],jumpd[maxn][maxb];
	void dfs1(int u,int F) {
		fa[u] = F,siz[u] = 1,dep[u] = dep[F] + 1;
		for(int i=head[u],v; v=e[i].to,i; i=e[i].next) {
			if(v == F)continue;
			dfs1(v,u);
			siz[u] += siz[v];
			if(siz[v] > siz[son[u]])son[u] = v;
		}
	}
	void dfs2(int u,int T) {
		top[u] = T,in[u] = ++tim,rnk[tim] = u;
		colin[col[u]].push_back(in[u]);
		if(son[u])dfs2(son[u],T);
		for(int i=head[u],v; v=e[i].to,i; i=e[i].next)
			if(v != fa[u] && v != son[u])
				dfs2(v,v);
	}
	struct pair {
		int x,y;
		pair(int a=0,int b=0):x(a),y(b) {};
		bool operator <(pair b)const {return x==b.x?y<b.y:x<b.x;}
	};
	int LCA(int x,int y) {
		while(top[x]^top[y]) {
			if(dep[top[x]]<dep[top[y]])x^=y^=x^=y;
			x = fa[top[x]];
		}
		return dep[x]<dep[y]?x:y;
	}
	int upfir(int upb,int col){return *(--std::upper_bound(colin[col].begin(),colin[col].end(),upb));}
	int downfir(int lowb,int col) {return *std::lower_bound(colin[col].begin(),colin[col].end(),lowb);}
	int Query(int x,int y) {
		int lca = LCA(x,y),nowpos = 0;
		while(top[x] ^ top[lca]) {
			int pos = upfir(in[x],nd[nowpos+1]);
			if(pos >= in[top[x]]) {
				x = rnk[pos],++nowpos;
				while(jumpu[x][B])x = jumpu[x][B],nowpos += B;
				for(int j=B-1; j; --j)
					if(jumpu[x][j]) {x = jumpu[x][j],nowpos += j;break;}
			}
			x = fa[top[x]];
		}
		tmp.clear();
		while(top[y] ^ top[lca])
			tmp.push_back(y),y = fa[top[y]];
		if(x == lca) {
			int pos = downfir(in[x],nd[nowpos+1]);
			if(pos <= in[y]){
				x = rnk[pos],++nowpos;
				while(jumpd[x][B] && dep[jumpd[x][B]] <= dep[y])x = jumpd[x][B],nowpos += B;
				for(int j=B-1; j; --j)
					if(jumpd[x][j] && dep[jumpd[x][j]] <= dep[y]) {x = jumpd[x][j],nowpos += j;break;}
			}
		} else {
			int pos = upfir(in[x],nd[nowpos+1]);
			if(pos >= in[y]){
				x = rnk[pos],++nowpos;
				while(jumpu[x][B] && dep[jumpu[x][B]] >= dep[y])x = jumpu[x][B],nowpos += B;
				for(int j=B-1;j;--j)
					if(jumpu[x][j] && dep[jumpu[x][j]] >= dep[y]){x = jumpu[x][j],nowpos += j;break;}
			}
		}
		for(int i=tmp.size()-1; ~i; --i) {
			y = tmp[i];
			int pos = downfir(in[top[y]],nd[nowpos+1]);
			if(pos <= in[y]) {
				int tmpy = rnk[pos];
				++nowpos;
				while(jumpd[tmpy][B] && dep[jumpd[tmpy][B]] <= dep[y])tmpy = jumpd[tmpy][B],nowpos += B;
				for(int j=B-1; j; --j)if(jumpd[tmpy][j] && dep[jumpd[tmpy][j]] <= dep[y]) {tmpy = jumpd[tmpy][j],nowpos += j;break;}
			}
		}
		return nowpos;
	}
	void Solve() {
		for(int i=1; i<=c; ++i)colpos[nd[i]] = i;
		for(int i=1; i<=n; ++i)pos[i] = colpos[col[i]];
		for(int i=0; i<=m; ++i)colin[i].push_back(0);
		dfs1(1,0),dfs2(1,1);
		for(int i=0; i<=m; ++i)colin[i].push_back(n+1);
		for(int i=1; i<=n; ++i) {
			if(i == top[i]) {
				int temp = i;
				do{chain[i].push_back(temp),temp = son[temp];}while(temp);
			}
		}
		for(int i=1; i<=n; ++i) {
			if(chain[i].size()) {
				for(int j=0; j<chain[i].size(); ++j) {
					int id = chain[i][j];
					if(!pos[id])continue;
					if(cols[nd[pos[id]+1]].size()) {
						int preid = *(--cols[nd[pos[id]+1]].end());
						jumpu[id][1] = preid;
						for(int k=2; k<=B; ++k)jumpu[id][k] = jumpu[preid][k-1];
					}
					cols[col[id]].push_back(id);
				}
				for(int j=0; j<chain[i].size(); ++j)cols[col[chain[i][j]]].clear();
				for(int j=chain[i].size()-1; ~j; --j) {
					int id = chain[i][j];
					if(!pos[id])continue;
					if(cols[nd[pos[id]+1]].size()) {
						int preid = *(--cols[nd[pos[id]+1]].end());
						jumpd[id][1] = preid;
						for(int k=2; k<=B; ++k)jumpd[id][k] = jumpd[preid][k-1];
					}
					cols[col[id]].push_back(id);
				}
				for(int j=0; j<chain[i].size(); ++j)cols[col[chain[i][j]]].clear();
			}
		}
		q = re();
		for(int i=1,x,y; i<=q; ++i) {
			x = re(),y = re();
			printf("%d\n",Query(x,y));
		}
	}
}
int main() {
	freopen("gem.in","r",stdin);
	freopen("gem.out","w",stdout);
	n = re(),m = re(),c = re();
	for(int i=1; i<=c; ++i)nd[i] = re();
	for(int i=1; i<=n; ++i)col[i] = re();
	for(int i=1,x,y; i<n; ++i)x = re(),y = re(),add_edge(x,y),add_edge(y,x);
	Sol::Solve();
	return 0;
}
```

~~长度4888，非常吉利（误）~~

---

## 作者：chen_qian (赞：0)

好像这个题很人均，~~虽然我连省选资格都没有~~。还是全程自己思考做出来的一道题目。

考虑链的部分分。

为了方便，我们记 $\mathtt {pos_x}$ 表示值 $x$ 处在 $p$ 序列里的下标。

最初没有思路，然后在上学路上想到了一个思路。大概就是 NOIO 上面口胡出来的一个学名叫序列自动机的东西，大概就是记录后缀。但是后缀自动机需要存整个字符集，但是这里由于 $p$ 中每一个数都是不重复。所以直接记一个后继即可。也即 $\mathtt{up_x}$ 表示从节点 $x$ 往祖先走，到达的一个最深的值为 $\mathtt{p_{pos_x+1}}$ 的点的编号，然后每次询问的时候暴力地往上跳，复杂度是 $O(nq)$。考虑优化，使用倍增。 $\mathtt{up_{x,i}}$ 表示从节点 $x$ 往祖先走，到达的一个最深的值为 $\mathtt{p_{pos_x+2^i}}$ 的编号 且 $\mathtt{[pos_x,pos_x+2^i]}$ 间的点都已经匹配好了。找不到或中间没匹配好都赋值为 $0$ 。每次直接往上跳，复杂度 $q\log(n)$ 。注意最开始的位置需要找到第一个匹配的位置，也即区间第一次出现某个数的位置直接每种颜色维护 $\mathtt {set}$ 。

考虑树上怎么做。

由于树上可能会有拐弯的情况出现。第一次想的是再维护一个往下走的 $\mathtt{down} $ 数组，但是由于儿子不唯一，所以考虑树链剖分，对于每一个链维护倍增，然后每次把经过的链记录下来，链与链之间就是跳区间第一次出现某个数的位置，直接每种颜色维护 $\mathtt {set}$。

代码里有注释。

```cpp
#include<bits/stdc++.h>
#define N 200005
#define M 50005
#define pb push_back
#define pii pair<int,int> 
#define mp make_pair
#define fi first
#define se second
#define sit set<int> :: iterator
using namespace std;
int n,m,c,q,p[N],a[N];
int t[M],nxt[M];
int head[N],idx;
struct edge{
	int v,next;
}e[N<<1];
void add(int u,int v){
	e[++idx].v=v;
	e[idx].next=head[u];
	head[u]=idx;
}
int cnt,top[N],size[N],son[N],fa[N],dep[N],dfn[N],rev[N];
int up[N][20],down[N][20];
set<int> s[M];
vector<int> v[N];
void dfs1(int x,int f){
	fa[x]=f;
	size[x]=1;
	dep[x]=dep[f]+1;
	for(int i=head[x];i;i=e[i].next){
		int y=e[i].v;
		if(y==f) continue;
		dfs1(y,x);
		size[x]+=size[y];
		if(size[y]>size[son[x]]) son[x]=y;
	}
}
void dfs2(int x){
	if(x==son[fa[x]]) top[x]=top[fa[x]];
	else top[x]=x;
	dfn[x]=++cnt;
	rev[cnt]=x;
	s[a[x]].insert(dfn[x]);//对应颜色插入dfn序 
	v[top[x]].pb(x);//记录每一条链中的元素 
	if(son[x]) dfs2(son[x]);
	for(int i=head[x];i;i=e[i].next){
		int y=e[i].v;
		if(y==fa[x]||y==son[x]) continue;
		dfs2(y);
	}
}
vector<pii > l1;
stack<pii > l2;//因为 y->lca 的路径上是从上到下，所以要用栈 
void LCA(int x,int y){
	while(top[x]!=top[y]){
		if(dep[top[x]]>=dep[top[y]]){
			l1.pb(mp(dfn[top[x]],dfn[x]));
			x=fa[top[x]];
		}
		else{
			l2.push(mp(dfn[top[y]],dfn[y]));
			y=fa[top[y]];
		}
	}
	if(dep[x]>dep[y]) l1.pb(mp(dfn[y],dfn[x]));
	else l2.push(mp(dfn[x],dfn[y]));
}
int main(){
	scanf("%d%d%d",&n,&m,&c);
	for(int i=1;i<=c;i++){
		scanf("%d",&p[i]);
		nxt[p[i-1]]=p[i];
	}
	for(int i=1;i<=n;i++) scanf("%d",&a[i]);
	for(int i=1;i<n;i++){
		int u,v;
		scanf("%d%d",&u,&v);
		add(u,v);
		add(v,u);
	}
	dfs1(1,0);
	dfs2(1);
	for(int i=1;i<=n;i++){
		for(int j=0;j<v[i].size();j++) t[a[v[i][j]]]=0,t[nxt[a[v[i][j]]]]=0;
		for(int j=0;j<v[i].size();j++){
			int x=v[i][j];
			t[a[x]]=x;
			up[x][0]=t[nxt[a[x]]];
			for(int k=1;k<=16;k++)	up[x][k]=up[up[x][k-1]][k-1];//预处理倍增 
		}
		for(int j=0;j<v[i].size();j++) t[a[v[i][j]]]=0,t[nxt[a[v[i][j]]]]=0;
		for(int j=v[i].size()-1;j>=0;j--){
			int x=v[i][j];
			t[a[x]]=x;
			down[x][0]=t[nxt[a[x]]];
			for(int k=1;k<=16;k++) down[x][k]=down[down[x][k-1]][k-1];
		}
	}	
	scanf("%d",&q);
	while(q--){
		int u,v;
		scanf("%d%d",&u,&v);
		l1.clear();
		while(!l2.empty()) l2.pop();
		LCA(u,v);
		int now=0,ans=0;
		for(int i=0;i<l1.size();i++){
			pii x=l1[i];
			int goal=nxt[a[now]];
			if(goal==0) break;
			if(s[goal].size()==0) break;
			sit it=s[goal].upper_bound(x.se);//找下端点的前驱 
			int tmp;
			if(it==s[goal].end()) tmp=*s[goal].rbegin();
			else if(it==s[goal].begin()) continue;
			else tmp=*--it; 
			if(tmp<=x.se&&tmp>=x.fi) ans++;//判断是不是在链上 
			else continue;
			now=rev[tmp];
			for(int i=16;i>=0;i--) if(up[now][i]&&dep[up[now][i]]>=dep[rev[x.fi]]) now=up[now][i],ans+=(1<<i);//注意跳也只能在指定区域跳 
		}
		while(!l2.empty()){
			pii x=l2.top();
			l2.pop();
			int goal=nxt[a[now]];
			if(s[goal].size()==0) break;
			if(goal==0) break;
			sit it=s[goal].lower_bound(x.fi);//找后继 
			if(it==s[goal].end()) continue;
			int tmp=*it;
			if(tmp>=x.fi&&tmp<=x.se) ans++;
			else continue;
			now=rev[tmp];
			for(int i=16;i>=0;i--){
				if(down[now][i]&&dfn[down[now][i]]<=x.se) now=down[now][i],ans+=(1<<i);
			}
		}
		printf("%d\n",ans);
	}
	return 0;
}
```




---


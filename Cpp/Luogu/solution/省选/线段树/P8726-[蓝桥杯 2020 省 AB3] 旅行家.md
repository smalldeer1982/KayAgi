# [蓝桥杯 2020 省 AB3] 旅行家

## 题目描述

从前，在海上有 $n$ 个岛屿，编号 $1$ 至 $n$。居民们深受洋流困扰，无法到达比自己当前所在岛屿编号更小的岛屿。经过数年以后，岛屿上的人数随着岛屿的编号递增（可能相等）。作为一名出色的旅行家（$\mathrm{RP}$ 学家），你想从 $1$ 号岛屿出发开启一次旅程，以获得更多的 $\mathrm{RP}$，因为受到海洋的洋流影响，你只能去到比当前岛屿编号更大的岛屿。因为你比较善良，你会在离开一个岛屿的时候将你的 $\mathrm{RP}$ 分散给岛民，具体地：你的 $\mathrm{RP}$ 会除以 $2$（用去尾法取整，或者说向零取整）（当你的 $\mathrm{RP}$ 小于零时，岛民也依旧要帮你分担，毕竟你们已经建立起了深厚的友谊)。

第 $i$ 号岛屿有 $T_{i}$ 人，但是你很挑剔，每次你从 $j$ 号岛屿到达 $i$ 号岛屿时，你只会在到达的岛屿上做 $T_{i} \times T_{j}$ 件好事（一件好事可以获得 $1$ 点 $\mathrm{RP}$ )。

唯一不足的是，由于你在岛上住宿，劳民伤财，你会扣除巨量 RP，第 $i$ 号岛屿的住宿扣除 $F_{i}$ 点 $\mathrm{RP}$。

注意: 将离开一个岛屿时，先将 $\mathrm{RP}$ 扣除一半，再扣除住宿的 $\mathrm{RP}$，最后在新到达的岛屿上做好事，增加 $\mathrm{RP}$。离开 $1$ 号岛屿时需要扣除在 $1$ 号岛屿住宿的 $\mathrm{RP}$，当到达这段旅程的最后一个岛屿上时，要做完好事，行程才能结束，也就是说不用扣除在最后到达的岛屿上住宿的 $\mathrm{RP}$ 。

你因为热爱旅行（RP），所以从 $1$ 号岛屿开始旅行，初始时你有 $0$ 点 $\mathrm{RP}$。你希望选择一些岛屿经过，最终选择一个岛屿停下来，求最大的 $\mathrm{RP}$ 值是多少?

## 说明/提示

**【样例说明】**

从一号岛屿直接走到三号岛屿最优，初始 $0$ 点 $\mathrm{RP}$，扣除一半取整变成 $0$ 点。扣除在一号节点住宿的 $1 \mathrm{RP}$，在三号岛屿做好事产生 $4 \times 5=20$ 点 $\mathrm{RP}$。最终得到 $19$ 点 $R P$ 。

**【评测用例规模与约定】**

对于 $20 \%$ 的评测用例，$1 \leq n \leq 15$;

对于 $70 \%$ 的评测用例，$1 \leq n \leq 5000$;

对于所有评测用例，$1 \leq n \leq 5\times10^5,1 \leq T_{i} \leq 20000,1 \leq F_{i} \leq 2\times 10^8$。给定的 $T_{i}$ 已经按照升序排序。

建议使用 64 位有符号整数进行运算。

蓝桥杯 2020 第三轮省赛 AB 组 J 题。

Upd.2024.7.13 已添加hack数据

## 样例 #1

### 输入

```
3
4 4 5
1 10 3```

### 输出

```
19```

## 样例 #2

### 输入

```
5
969 980 1013 1016 1021
888423 945460 865822 896150 946615```

### 输出

```
246172```

# 题解

## 作者：Super_Cube (赞：4)

# Solution

设 $dp_i$ 表示在 $i$ 号岛停下的最大 rp 值，定义 $\langle x\rangle$ 表示 $x$ 向 0 取整得到的值。

可以得到：$dp_i=\displaystyle\max_{j=1}^{i-1} \left\lbrace \left\langle \dfrac{dp_j}{2}\right\rangle + T_i \times T_j - F_j \right\rbrace$。

最后答案即为： $\displaystyle\max_{i=1}^n \{ dp_i\}$。

直接做复杂度过不去，考虑斜率优化，先将 $\max$ 去掉，改写此式为：$\left\langle \dfrac{dp_j}{2}\right\rangle - F_j = - T_i \times T_j  + dp_i$。

**以下内容是之前眼瞎的时候没看见数据范围里面保证了 $T_i$ 有序时候的做法，没兴趣可以略过。**

现在的问题是式子中的斜率不单调的情况下连自变量也不单调，就不能像 [P5785](/problem/P5785) 那样用单调栈 + 二分进行维护凸包。

于是我们可以用 cdq 分治进行自变量的强制单调，这个时候你惊奇地发现斜率也随之单调了，所以在 cdq 内部处理时可以直接用单调队列维护凸包。

时间复杂度：$O(n\log n)$。

当然你可以在改写原 dp 式时像下面这样：$dp_i=T_j\times T_i+\left\langle \dfrac{dp_j}{2}\right\rangle-b_j$。

然后把它看成坐标系中的一次函数 / 一条直线，这题就变成李超线段树维护斜优 dp 了。

时间复杂度：$O(n\log V)$，其中 $V$ 为 $T$ 的值域大小。

~~这个做法代码比 cdq 短，跑得也比 cdq 快。~~

**下面是本题保证了 $T_i$ 有序的做法。**

我们对于上式进行换元：

$$
\begin{cases}
y=\left\langle \dfrac{dp_j}{2}\right\rangle - F_j\\
k=-T_i\\
x=T_j\\
b=dp_i\\
\end{cases}
$$

这样就可以很清晰的看出上式是类似于一次函数的。

我们为了让 $dp_i$ 能够取得最大值，那么就要最大化截距 $b$，因为截距中只含有 $dp_i$，只要截距最大，$dp_i$ 肯定也是最大的。

所以我们要对于所有的决策点维护一个上凸包，这样我们拿斜率为 $k$ 的直线去切的时候截距 $b$ 才能最大化。

因为给定的 $T_i$ 是保证升序的，那么说明斜率 $k$ 与自变量 $x$ 都是单调的，就可以直接用单调队列维护凸包斜率。

时间复杂度： $O(n)$。

下面是这种方法的代码。

# Code

```cpp
#include<bits/stdc++.h>
#define X(i) (a[i])
#define Y(i) (dp[i]/2-b[i])
int dp[500005];
int a[500005],b[500005];
inline double slope(int l,int r){
	if(X(l)==X(r))return (Y(r)-Y(l))*1e9;
	return (Y(r)-Y(l))*1.0/(X(r)-X(l));
}
std::deque<int>q;
int n,ans;
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;scanf("%d",&a[i++]));
	for(int i=1;i<=n;scanf("%d",&b[i++]));
	q.push_back(1);//从 1 号岛开始
	for(int i=2;i<=n;++i){
		while(q.size()>1&&slope(q[0],q[1])>=-a[i])q.pop_front();//把斜率比当前切线大的直接删掉
		dp[i]=dp[q[0]]/2+a[i]*a[q[0]]-b[q[0]];//最优决策点转移
		while(q.size()>1&&slope(*(q.end()-2),q.back())<=slope(q.back(),i))q.pop_back();//维护斜率单减
		q.push_back(i);
		ans=std::max(ans,dp[i]);
	}
	printf("%d",ans);
	return 0;
}
/*
dp[i]=dp[j]/2+a[i]*a[j]-b[j]
dp[j]/2-b[j]=-a[i]*a[j]+dp[i]
*/
```

---

## 作者：未来姚班zyl (赞：4)

## 题目大意

有 $n$ 个岛，每个岛有两个权值 $F_i$，$T_i$。设价值为 $x$，则在离开一座岛屿时，$x$ 会变为 $\frac{x}{2}-F_i$。从一座岛屿 $i$ 到达岛屿 $j$ 时，$x$ 会增加 $T_iT_j$。你初始在 $1$ 号节点，每次只能前往编号更大的节点，求最大的 $x$。

## 题目分析

设 $dp_i$ 表示在岛屿 $i$ 停留时的最大价值，则 $dp_i=\max\limits_{j<i}(\frac{dp_j}{2}-F_j+T_iT_j)$，显然括号里的式子中，把和 $j$ 有关的量当成常数，则式子为一次函数，李超线段树维护即可，复杂度 $O(n\log V)$。

这题咋没数据啊，我先挂着我的代码等有数据了再来检查。

update 2024/4/18：修改了数组大小，能够通过民间数据。

```cpp
#include<bits/stdc++.h>
#define int long long
#define R 1,1,20000
#define mid (l+r>>1)
#define lc x<<1,l,mid
#define rc x<<1|1,mid+1,r
#define rep(x,y,z) for(int x=(y);x<=(z);x++)
#define repn(x) rep(x,1,n)
inline int read(){int s=0,w=1;char c=getchar();while(c<48||c>57) {if(c=='-') w=-1;c=getchar();}while(c>=48&&c<=57)s=(s<<1)+(s<<3)+c-48,c=getchar();return s*w;}
const int N =5e5+5,llf=1e18;
using namespace std;
int n=read(),a[N],f[N],dp[N],tot,xd[N<<2],ans;
struct segment{
	int k,b;
}d[N];
int get(int x,int id){
	if(!id)return -llf;
	return d[id].k*x+d[id].b;
}
void pushdown(int x,int l,int r,int id){
	if(!xd[x])xd[x]=id;
	if(get(mid,id)>get(mid,xd[x]))swap(xd[x],id);
	if(get(l,id)>get(l,xd[x]))pushdown(lc,id);
	if(get(r,id)>get(r,xd[x]))pushdown(rc,id);
}
int query(int x,int l,int r,int p){
	if(l==r)return get(p,xd[x]);
	return max(get(p,xd[x]),p<=mid?query(lc,p):query(rc,p));
}
signed main(){
	repn(i)a[i]=read();
	repn(i)f[i]=read();
	d[++tot]={a[1],-f[1]},pushdown(R,tot);
	rep(i,2,n)dp[i]=query(R,a[i]),d[++tot]={a[i],dp[i]/2-f[i]},pushdown(R,tot),ans=max(ans,dp[i]);
	cout <<ans;
	return 0;
}
```

---

## 作者：MornStar (赞：3)

# [蓝桥杯 2020 省 AB3] 旅行家

## 题目描述

从前，在海上有 $n$ 个岛屿，编号 $1$ 至 $n$。居民们深受洋流困扰，无法到达比自己当前所在岛屿编号更小的岛屿。经过数年以后，岛屿上的人数随着岛屿的编号递增（可能相等）。作为一名出色的旅行家（$\mathrm{RP}$ 学家），你想从 $1$ 号岛屿出发开启一次旅程，以获得更多的 $\mathrm{RP}$，因为受到海洋的洋流影响，你只能去到比当前岛屿编号更大的岛屿。因为你比较善良，你会在离开一个岛屿的时候将你的 $\mathrm{RP}$ 分散给岛民，具体地：你的 $\mathrm{RP}$ 会除以 $2$（用去尾法取整，或者说向零取整）（当你的 $\mathrm{RP}$ 小于零时，岛民也依旧要帮你分担，毕竟你们已经建立起了深厚的友谊)。

第 $i$ 号岛屿有 $T_{i}$ 人，但是你很挑剔，每次你从 $j$ 号岛屿到达 $i$ 号岛屿时，你只会在到达的岛屿上做 $T_{i} \times T_{j}$ 件好事（一件好事可以获得 $1$ 点 $\mathrm{RP}$ )。

唯一不足的是，由于你在岛上住宿，劳民伤财，你会扣除巨量 RP，第 $i$ 号岛屿的住宿扣除 $F_{i}$ 点 $\mathrm{RP}$。

注意: 将离开一个岛屿时，先将 $\mathrm{RP}$ 扣除一半，再扣除住宿的 $\mathrm{RP}$，最后在 新到达的岛屿上做好事，增加 $\mathrm{RP}$。离开 $1$ 号岛屿时需要扣除在 $1$ 号岛屿住宿的 $\mathrm{RP}$，当到达这段旅程的最后一个岛屿上时，要做完好事，行程才能结束，也就是说不用扣除在最后到达的岛屿上住宿的 $\mathrm{RP}$ 。

你因为热爱旅行（RP），所以从 $1$ 号岛屿开始旅行，初始时你有 $0$ 点 $\mathrm{RP}$。你希望选择一些岛屿经过，最终选择一个岛屿停下来，求最大的 $\mathrm{RP}$ 值是多少?

$1 \leq n \leq 5\times10^5,1 \leq T_{i} \leq 20000,1 \leq F_{i} \leq 2\times 10^8$。

## 思路

首先我们设 $dp_i$ 为到达第 $i$ 座岛屿时的最大 $\mathrm{RP}$ 值。

则马上可以看出一个明显的递推式：
$$
dp_i=\max_{j=1}^{i-1}(T_i \times T_j+\lfloor \frac{dp_j}{2} \rfloor-F_j)
$$

可以得到一个 $n^2$ 的做法。~~再通过一些乱搞可以得到 $90pts$。~~

由于 $T_i$ 和 $\lfloor \frac{dp_j}{2} \rfloor-F_j$ 确定，我们可以把 $T_j$ 看成 $k$，$\lfloor \frac{dp_j}{2} \rfloor-F_j$ 看成 $b$。

则原式变成了:
$$
dp_i=\max_{j=1}^{i-1}(k\times T_i+b)
$$
是几个一次函数求最大值的形式，可以转换成维护下凸包，可怎么去维护是一个问题，于是，李超线段树应运而生。

# 李超线段树

一句话概括：**李超线段树是一种用于维护平面直角坐标系内线段关系的数据结构。**

其通常可以用于 DP 的斜率优化。

李超线段树主要支持两个操作：
-  在平面直角坐标系中加入一条直线（线段）。
-  查询与直线 $x=k$ 相交的直线交点纵坐标最大（最小）值。

与普通线段树不同的是，李超线段树的懒标记是一条线段（真·线段树）。

## 插入操作
若该区间无标记，直接打上用该线段更新的标记。

如果该区间已经有标记了，由于标记难以合并，只能把标记下传。但是子节点也有自己的标记，也可能产生冲突，所以我们要递归下传标记。

假设现在只有一条线段与其相交，如图：
![](https://cdn.luogu.com.cn/upload/image_hosting/jv9x4p4i.png)

在中点处，绿线的值大于蓝线，所以 $[l,r]$ 区间的懒标记则是绿线，然后递归更新 $[l,mid]$ 的懒标记。

借用 OI wiki 的话：

如果新线段 $f$ 更优，则将 $f$ 和 $g$ 交换。那么现在考虑在中点处 $f$ 不如 $g$ 优的情况：

1. 若在左端点处 $f$ 更优，那么 $f$ 和 $g$ 必然在左半区间中产生了交点，f 只有在左区间才可能优于 $g$，递归到左儿子中进行下传；
2. 若在右端点处 $f$ 更优，那么 $f$ 和 $g$ 必然在右半区间中产生了交点，f 只有在右区间才可能优于 $g$，递归到右儿子中进行下传；
3. 若在左右端点处 $g$ 都更优，那么 $f$ 不可能成为答案，不需要继续下传。
4. 除了这两种情况之外，还有一种情况是 $f$ 和 $g$ 刚好交于中点，在程序实现时可以归入中点处 $f$ 不如 $g$ 优的情况，结果会往 $f$ 更优的一个端点进行递归下传。

最后将 $g$ 作为当前区间的懒标记。

线段树 $\log{n}$ 的树高和递归下传的决策是李超线段树时间复杂度的保证。

在实际插入时我们还要先找到加入线段所处的区间，在原线段树上分成 $\log{n}$ 块分别递归下传（直线则可以不用）。

```cpp
int cmp(line a,line b,long long x){
	double vala=a.calc(x),valb=b.calc(x);
	if(vala-valb>eps)	return 1;
	else if(vala-valb<-eps)	return -1;
	return 0;
}
void change(int p,int l,int r,int num){
	int mid=(l+r)>>1;
	int ansmid=cmp(li[num],li[lazy[p]],mid);
	if(ansmid>0)	swap(num,lazy[p]);
	int ansl=cmp(li[num],li[lazy[p]],l),ansr=cmp(li[num],li[lazy[p]],r);
	if(ansl>0||(!ansl&&num<lazy[p]))	change(ls(p),l,mid,num);
	if(ansr>0||(!ansr&&num<lazy[p]))	change(rs(p),mid+1,r,num);
}//递归下传
void update(int p,int l,int r,int re_l,int re_r,int num){
	if(l>=re_l&&r<=re_r)    change(p,l,r,num);
	else if(!(r<re_l||l>re_r)){
		int mid=(l+r)>>1;
		update(ls(p),l,mid,re_l,re_r,num);
		update(rs(p),mid+1,r,re_l,re_r,num);
	}    
}// 直线可以省略的部分

```
以下是加入一条线段所用的代码
```cpp
void add(int xa,int ya,int xb,int yb){
	if(xa==xb)	li[++cnt]={0,max(ya,yb)};//特判斜率不存在情况
	else	li[++cnt].k=(yb-ya)*1.0/(xb-xa),li[cnt].b=ya-li[cnt].k*xa;
	update(1,1,mod1,min(xa,xb),max(xa,xb),cnt);
}
```
## 查询操作

李超线段树的查询操作跟普通的线段树差不多，但是李超线段树使用的**标记永久化**的技巧，为了保证时间复杂度而不会下传懒标记，所以最大值应由查询路径上所有懒标记线段的最大取值决定。
```cpp
struct answer{double x;int num;};
answer cmp(answer a,answer b){
	if(a.x-b.x>eps) return a;
	else if(a.x-b.x<-eps)   return b;
	return (a.num<b.num?a:b);
}
answer query(int p,int l,int r,int x){
	int mid=(l+r)>>1;
	answer ret={li[lazy[p]].calc(x),lazy[p]};
	if(l==r)	return ret;
	if(x<=mid)	return cmp(ret,query(ls(p),l,mid,x));
	else	return cmp(ret,query(rs(p),mid+1,r,x));
}
```

再次看向引入的题，我们发现维护直线下凸包就是维护最大值，用李超线段树解决即可。

tips：对于加入直线的题，可以省略 update 直接从左右边界递归下传即可

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,dp1[500005],dp2[500005],a[500005],f[500005],ans;
struct line{
	long long k,b;
	long long calc(long long x){return k*x+b;}
}li[500005];
int cmp(line a,line b,long long x){
	long long vala=a.calc(x),valb=b.calc(x);
	if(vala>valb)	return 1;
//	else if(vala<valb)	return -1;
	return 0;
}
int lazy[80005];
int ls(int x){return x<<1;}
int rs(int x){return x<<1|1;}
void change(int p,int l,int r,int num){
	int mid=(l+r)>>1;
	if(cmp(li[num],li[lazy[p]],mid))	swap(num,lazy[p]);
	bool ansl=cmp(li[num],li[lazy[p]],l),ansr=cmp(li[num],li[lazy[p]],r);
	if(ansl)	change(ls(p),l,mid,num);
	if(ansr)	change(rs(p),mid+1,r,num);
}
long long query(int p,int l,int r,int x){
	int mid=(l+r)>>1;
	long long ret=li[lazy[p]].calc(x);
	if(l==r)	return ret;
	if(x<=mid)	return max(ret,query(ls(p),l,mid,x));
	else	return max(ret,query(rs(p),mid+1,r,x));
}
int main(){
//    freopen("traveller.in","r",stdin);
//    freopen("traveller.out","w",stdout);
    ios::sync_with_stdio(false);
    cin.tie(0);cout.tie(0);
    // double st=clock();
    memset(dp1,-0x3f,sizeof(dp1));
    memset(dp2,-0x3f,sizeof(dp2));
    cin>>n;
    for(int i=1;i<=n;i++)   cin>>a[i];
    for(int i=1;i<=n;i++)   cin>>f[i];
    li[0].b=LLONG_MIN,dp1[1]=0,dp2[1]=-f[1],li[1]={a[1],dp2[1]};
	change(1,1,20000,1);
	for(int i=2;i<=n;i++){
		dp1[i]=query(1,1,20000,a[i]);
		dp2[i]=dp1[i]/2-f[i];
		li[i]={a[i],dp2[i]};
		change(1,1,20000,i);
		ans=max(ans,dp1[i]);
	}
	cout<<ans<<"\n";
}
```

---

## 作者：xhhhh36 (赞：3)

[传送门](https://www.luogu.com.cn/problem/P8726)

设 $dp_i$ 表示从岛屿 $1$ 出发在岛屿 $i$ 停下所得到的最大 RP 值。根据题意可得到以下 dp 方程：
$$dp_i=\max_{1\le j<i}\left\lfloor\dfrac{dp_j}{2}\right\rfloor-F_j+T_iT_j$$

但是这样转移是 $O(n^2)$ 的，考虑使用李超线段树优化。设 $k=T_j$，$b=\left\lfloor\dfrac{dp_j}{2}\right\rfloor-F_j$，那么原 dp 方程可以看为：每次插入一条直线 $y=kx+b$，求 $x=T_i$ 时的 $y$ 最大值。这些就是李超线段树的基本操作，直接维护即可。 

upd：记得初始化为极小值，要不然过不了 hack。
# AC code
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N=5e5+5,maxn=2e4;
struct line{
	int k,b;
}z[N];
struct node{
	int l,r,mid,mx;
}t[maxn*4];
int n,cnt,tmp;
int gety(int id,int x){
	return z[id].k*x+z[id].b;
}
int cmp(int a,int b){
	if (a>b) return 1;
	if (a<b) return -1;
	return 0;
}
void build(int u,int l,int r){
	t[u].l=l;t[u].r=r;
	if (l==r) return ;
	int mid=t[u].mid=l+r>>1;
	build(u*2,l,mid);
	build(u*2+1,mid+1,r);
}
void update(int u,int id){
	int mxl=gety(t[u].mx,t[u].l),mxr=gety(t[u].mx,t[u].r);
	int nowl=gety(id,t[u].l),nowr=gety(id,t[u].r);
	if (~cmp(mxl,nowl)&&~cmp(mxr,nowr)) return ;
	if (cmp(mxl,nowl)==-1&&cmp(mxr,nowr)==-1){
		t[u].mx=id;return ;
	}
	int mx_mid=gety(t[u].mx,t[u].mid),now_mid=gety(id,t[u].mid);
	if (cmp(mx_mid,now_mid)==-1) swap(t[u].mx,id);
	if (cmp(z[t[u].mx].k,z[id].k)==1){
		update(u*2,id);
	} else {
		update(u*2+1,id);
	}
}
void query(int u,int x){
	int now=gety(t[u].mx,x);
	if (cmp(now,tmp)==1){
		tmp=now;
	}
	if (t[u].l==t[u].r) return ;
	if (x<=t[u].mid) query(u*2,x);
	else query(u*2+1,x);
}
void add_line(int k,int b){
	cnt++;
	z[cnt].k=k;
	z[cnt].b=b;
}
int tt[N],f[N],dp[N];
signed main(){
	ios::sync_with_stdio(0);
	build(1,0,maxn);z[0].b=INT_MIN;
	cin>>n;
	for (int i=1;i<=n;i++){
		cin>>tt[i];
	}
	for (int i=1;i<=n;i++){
		cin>>f[i];
	}
	dp[1]=0;add_line(tt[1],dp[1]/2-f[1]);
	update(1,cnt);
	for (int i=2;i<=n;i++){
		tmp=INT_MIN;query(1,tt[i]);
		dp[i]=tmp;
		add_line(tt[i],dp[i]/2-f[i]);
		update(1,cnt);
	}
	cout<<dp[n]<<endl;
	return 0;
}
```

---

## 作者：tyccyt (赞：2)

我的评价：李超树优化DP板子题

## $70$ 分

设 $dp_i$ 表示从 $1$ 号点到 $i$ 号点的最大 $\mathrm{RP}$。

转移：
$$
dp[i]=\max_{1\le j <i }\frac{dp[j]}{2}-F_j+T_iT_j
$$
时间复杂度：$O(n^2)$。

实现较简单，不给出。

## $100$ 分

使用李超树优化DP

广告：[李超线段树详解](https://www.luogu.com.cn/article/imtno8p4)

设 $k_i=T_j$，$b_i=dp[i]/2-F_i$（这里 $k_i$ 表示斜率，$b_i$ 表示 $y$ 轴截距）

遍历时的横坐标也就是 $T_i$。

时间复杂度：$O(n\log_2n)$。

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
const int N=5e5+5;
const int M=5e5+5;
ll n,f[N],t[N],dp[N],k[N],b[N];
int s[M<<2],u;
inline ll g(int x,int id)
{
	return k[id]*x+b[id];
}
void update(int x,int l,int r,int t)//修改
{
	if(l==r)
	{
		if(g(l,t)>g(l,s[x]))s[x]=t;
		return;
	}
	int m=(l+r)>>1;
	if(g(m,t)>g(m,s[x]))swap(t,s[x]);
	if(g(l,t)>g(l,s[x]))
	{
		update(x<<1,l,m,t);
	}
	else if(g(r,t)>g(r,s[x]))
	{
		update(x<<1|1,m+1,r,t);
	}
}
ll query(int x,int l,int r)//查询
{
	if(l==r)return g(u,s[x]);
	int m=(l+r)>>1;
	return max(g(u,s[x]),u<=m?query(x<<1,l,m):query(x<<1|1,m+1,r));
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&t[i]);
	}
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&f[i]);
	}
	b[0]=-1e18;
	k[1]=t[1],b[1]=-f[1];//dp[1]=0的初始化
	update(1,0,M,1);
	long long ans=0;
	for(int i=2;i<=n;i++)
	{
		u=t[i];
		dp[i]=query(1,0,M);
		if(ans<dp[i])ans=dp[i];//别忘了取最大值！！！题目是在你选择的岛屿停下
		k[i]=t[i];
		b[i]=dp[i]/2-f[i];
		update(1,0,M,i);
	}
	cout<<ans;
	return 0;
}
```

---

## 作者：TheShuMo (赞：1)

数据提供者来写篇题解。

题意容易读懂，显然可以打出 $O(n^2)$ 的暴力 dp。

DP 的转移方程式就是 

$$f_i=\max^{i-1}_{j=1} (\lfloor \frac{f_j}{2} \rfloor+t_i\times t_j-w_j)$$

代码如下：
```cpp
#include<bits/stdc++.h>
#define int long long
#define pb push_back
namespace IO {
    #define int long long
    #define gh getchar
    inline int read(){char ch=gh();int x=0;bool t=0;while(ch<'0'||ch>'9')   t|=ch=='-',ch=gh();while(ch>='0'&&ch<='9') x=x*10+(ch^48),ch=gh();return t?-x:x;}
    inline char getc(){char ch=gh();while(ch<'a'||ch>'z') ch=gh();return ch;}
    inline void write(int x){if(x < 0){putchar('-');x = -x;}if(x > 9){write(x / 10);}putchar((x % 10 + '0'));}
}
using namespace IO;
using namespace std;
const int Maxn = 100010;
int f[Maxn];
int t[Maxn], w[Maxn];
signed main(){
    int n; cin >> n;
    for(int i = 1; i <= n; i++) cin >> t[i];
    for(int i = 1; i <= n; i++) cin >> w[i]; memset(f, 0xcf, sizeof f);
    f[1] = 0;
    for(int i = 1; i <= n; i++){
        for(int j = 1; j < i; j++){
            f[i] = max(f[i], f[j] / 2 + (t[i] * t[j]) - w[j]);
        }
    }int mx = f[0];
    for(int i = 1; i <= n; i++) mx = max(mx, f[i]);
    cout << mx << endl;
}
```
可是 $n =5\times 10^5$，$O(n^2)$ 的算法显然无法通过。

考虑优化，观察上面式子发现其中只有 $t_i$ 是与之有关的，而且是一次。然后就转化为 $k=t_j,b=\lfloor\frac{f_j}{2}\rfloor-w_j$ 的一次函数。并求在 $t_i$ 点上的最大值。

采用李超线段树来维护。

代码
```cpp
#include<bits/stdc++.h>
#define int long long
#define mp make_pair
#define ls u <<1
#define rs u << 1 |1
#define mid (l + r >> 1)
namespace IO {
    #define int long long 
    #define gh getchar
    inline int read(){char ch=gh();int x=0;bool t=0;while(ch<'0'||ch>'9')   t|=ch=='-',ch=gh();while(ch>='0'&&ch<='9') x=x*10+(ch^48),ch=gh();return t?-x:x;}
    inline char getc(){char ch=gh();while(ch<'a'||ch>'z') ch=gh();return ch;}
    inline void write(int x){if(x < 0){putchar('-');x = -x;}if(x > 9){write(x / 10);}putchar((x % 10 + '0'));}
}
using namespace IO;
using namespace std;
const int Maxn = 500010, mt = 2e4;
int f[Maxn];
int k[Maxn], b[Maxn]; int mx[Maxn << 2], c;
int g(int i, int x){
    return (k[i] * x + b[i]);
}
int t[Maxn], w[Maxn];
void upd(int u, int l, int r, int now){
    if(l == r){
        if(g(now, l) > g(mx[u], l)) mx[u] = now; return;
    }
    if(g(now,mid) > g(mx[u], mid)){
        if(k[now] > k[mx[u]]){
            upd(ls,l,mid,mx[u]);
        }else upd(rs,mid+1,r,mx[u]); mx[u] = now;
    }else {
        if(k[now] <= k[mx[u]]){
            upd(ls, l, mid, now);
        }else upd(rs, mid+1,r,now);
    }
}
int qry(int u, int l, int r, int d){
    if(l == r) return g(mx[u], d);
    int res = g(mx[u], d);
    if(d <= mid) return max(res, qry(ls, l, mid, d));
    else return max(res, qry(rs,mid+1,r,d)); 
}
signed main(){
    int n; cin >> n;
    for(int i = 1; i <= n; i++){
        cin >> t[i];
    }
    for(int i = 1; i <= n; i++) cin >> w[i]; 
    b[0] = -1e18; k[1] = t[1]; b[1] = -w[1]; upd(1,0,mt,1);
    for(int i = 2; i <= n; i++){
        f[i] = qry(1,1,mt,t[i]);
        k[i] = t[i]; b[i] = f[i] / 2 - w[i];
        upd(1,0,mt,i);
    }int mx = f[0];
    for(int i = 1; i <= n; i++) mx = max(mx, f[i]);
    cout << mx << endl;
}
 ```
 
 upd.2024.7.13更改了代码并通过了hack。

---

## 作者：toolong114514 (赞：1)

# P8726 [蓝桥杯 2020 省 AB3] 旅行家 题解
## 题面大意
其实题面还挺好懂的，不像以前 APIO 的某些题目那么谜语。

[传送门。](https://www.luogu.com.cn/problem/P8726)
## 解题思路
### 20pts 的部分分
$O(n!)$ 的爆搜很好写，没必要多讲。
### 70pts 的部分分
依据题面，可以轻易得出以下的状态转移方程：

记 $f_i$ 为到达第 $i$ 个岛屿（而且没有走）时所剩下 RP 的最大值。$f_1$ 初始化为 $0$。

由此可得：
$$f_i=\min_{1\le j<i}\left\lfloor\dfrac{f_j}{2}\right\rfloor+T_iT_j-F_j$$

暴力枚举 $i,j$ 转移即可，时间复杂度 $O(n^2)$。
### 正解
对上述状态转移方程，考虑斜率优化。

假定 $i$ 已确定。

记 $f_i\gets y,k=T_j,x=T_i,b=\left\lfloor\dfrac{f_j}{2}\right\rfloor-F_j$

由于要最大化 $f_i$，那么问题转化为：对于当前的若干条直线 $y=kx+b$，求它们在横坐标为 $x$ 时，纵坐标的最大值。

使用李超线段树（~~LCT~~）来维护以上信息。

对李超线段树不了解或不熟练的同学，可以先去看这道[模板题](https://www.luogu.com.cn/problem/P4097)，并特别推荐这篇[题解](https://www.luogu.com.cn/article/l9tmluvv)，讲得非常简洁清晰。

每求出一个 $f_i$，就把新的直线 $y=kx+b$ 甩进去，要用的时候直接查询即可。

记得把所有节点的区间优势线段初始化为 $y=-\infty$（一般用一个极小值去表示），不然可能会 WA！

时间复杂度为 $O(n\log n)$，可以通过本题。
## 参考代码
```cpp
#include<algorithm>
#include<iostream>
#include<cmath>
using namespace std;
#define int long long
const int INF=0x3f3f3f3f3f3f3f3f;
const int N=5e5+10;
struct ccf{
	int k,b;
	friend bool operator==(ccf pre,ccf nxt){
		return pre.k==nxt.k&&pre.b==nxt.b;
	}
}ln[4*N];
struct node{
	int l,r,bst;
}tree[N];
void build(int pos,int lft,int rgt){
	tree[pos].l=lft;
	tree[pos].r=rgt;
	if(lft==rgt) return;
	int mid=(lft+rgt)/2;
	build(pos*2,lft,mid);
	build(pos*2+1,mid+1,rgt);
}
void upd(int pos,int num){
	int mid=(tree[pos].l+tree[pos].r)/2;
	if(ln[num]==ln[tree[pos].bst]) return;
	if(ln[num].k*mid+ln[num].b>ln[tree[pos].bst].k*mid+ln[tree[pos].bst].b) swap(tree[pos].bst,num);
	if(tree[pos].l==tree[pos].r) return;
	if(ln[num].k*tree[pos].l+ln[num].b>=ln[tree[pos].bst].k*tree[pos].l+ln[tree[pos].bst].b) upd(pos*2,num);
	if(ln[num].k*tree[pos].r+ln[num].b>=ln[tree[pos].bst].k*tree[pos].r+ln[tree[pos].bst].b) upd(pos*2+1,num);
}
int ask(int pos,int kk){
	if(tree[pos].r<kk||kk<tree[pos].l) return -INF;
	if(tree[pos].l==tree[pos].r) return ln[tree[pos].bst].k*kk+ln[tree[pos].bst].b;
	return max(max(ask(pos*2,kk),ask(pos*2+1,kk)),ln[tree[pos].bst].k*kk+ln[tree[pos].bst].b);
}
int t[N],c[N],f[N];
int n,cnt,maxn=-INF,ans=-INF;
signed main(){
	ios::sync_with_stdio(false);
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>t[i];
		maxn=max(maxn,t[i]);
	}
	for(int i=1;i<=n;i++){
		cin>>c[i];
	}
	ln[0]={0,-INF};
	build(1,1,maxn);
	f[1]=0;
	ln[++cnt]={t[1],f[1]/2-c[1]};
	upd(1,cnt);
	for(int i=2;i<=n;i++){
		f[i]=ask(1,t[i]);
		ln[++cnt]={t[i],f[i]/2-c[i]};
		upd(1,cnt);
	}
	for(int i=1;i<=n;i++){
		ans=max(ans,f[i]);
	}
	cout<<ans;
	return 0;
}
```
[本代码可以通过洛谷评测](https://www.luogu.com.cn/record/160533796)。

Written by [toolong114514](www.luogu.com/user/477821/) on 2024.5.30.

---

## 作者：Xdik (赞：1)

首先很显然可以得出 $O(n^2)$ 的暴力dp： $dp_i=\max\{\lfloor\frac{dp_j}{2}\rfloor + t_i \times t_j-f_j\}$  显然过不了，考虑优化，因为式子里面有 $t_i \times t_j$ 这一项，故排除单调队列优化，线段树优化，所以考虑斜率优化，发现根本不用推式子，在这里面 $t_i $ 是自变量，$dp_i$ 是因变量，斜率就是 $t_j$ ，纵截距就是 $\lfloor\frac{dp_j}{2} \rfloor-f_j$ 然后就可以将这个式子看成一个一次函数了，那么怎么解决在前面这么多函数中 $x$ 取 $t_i$ 的最大值呢，用李超线段树就行了[不会李超线段树的戳这，可以去看看题解](https://www.luogu.com.cn/problem/P4097)

$O(n^2)$ 的暴力代码：

```cpp

#include <bits/stdc++.h>
#define int long long
#pragma GCC optimeze(2)
using namespace std;
const int N = 5e5 + 5;
long long read() {
    long long flag = 1, x = 0;
    char ch = 0;
    while (ch < '0' || ch > '9') {
        if (ch == '-')
            flag = -1;
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9') {
        x = (x << 1) + (x << 3) + ch - '0';
        ch = getchar();
    }
    return x * flag;
}
int dp[N], n, t[N], f[N],  ans = 0;
signed main() {
    n = read();
    for (int i = 1; i <= n; i++) {
        t[i] = read();
    }
    for (int i = 1; i <= n; i++) {
        f[i] = read();
    }
    memset(dp, 0xc0, sizeof dp);
    dp[1] = 0;
    for (int i = 2; i <= n; i++) {
        for (int j = 1; j < i; j++) {
             dp[i] = max(dp[i], dp[j] / 2 + t[i] * t[j] - f[j]);
         }
         ans = max(ans, dp[i]);
     }
    cout << ans;
    return 0;
}

```

AC Code:

```cpp
#include <bits/stdc++.h>
#pragma GCC optimeze(2)
#pragma GCC optimeze(3)
#define int long long
#define PII pair<int, int>
using namespace std;
const double eps=1e-9;
const int N=5e5+5; 
const int V=2e4;//题面中t的值域，也就是所有一次函数x的取值范围
int read(){
    int x=0, flag=1;
    char ch=0;
    while (ch<'0'||ch>'9'){
        if (ch=='-')
            flag=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9') {
        x=(x<<1)+(x<<3)+ch-'0';
        ch=getchar();
    }
    return x*flag;
}	
struct lcxds{
	int l,r;
	int v;
}tr[V*4];
struct line{
	double k,b;
}l[N];
int q,n,t[N],f[N],dp[N];
double c(double a,int bh){
	return a*l[bh].k+l[bh].b;
}
bool pd(double x,int i,int j){
	if(c(x,i)-c(x,j)>eps)return 1;//double有精度误差，所以用了一个eps
	if(c(x,j)-c(x,i)>eps)return 0;
}
void change(int l,int r,int p,int s,int t,int i){
	if(s>=l&&t<=r){
		if(pd(s,i,tr[p].v)&&pd(t,i,tr[p].v)){
			tr[p].v=i;
			return;
		}
		int m=(s+t)>>1;
		if(pd(m,i,tr[p].v))swap(i,tr[p].v);
		if(pd(s,i,tr[p].v))change(l,r,p*2,s,m,i);
		if(pd(t,i,tr[p].v))change(l,r,p*2+1,m+1,t,i);
		return;
	}
	int m=(s+t)>>1;
	if(m>=l)change(l,r,p*2,s,m,i);
	if(m<r)change(l,r,p*2+1,m+1,t,i);
}
int query(double k,int p,int s,int t){
	if(s==t)return tr[p].v;
	int m=(s+t)>>1,ans1=0,ans=tr[p].v;
	if(m>=k)ans1=query(k,p*2,s,m);
	else ans1=query(k,p*2+1,m+1,t);
	if(pd(k,ans1,ans))ans=ans1;
	return ans;
}//以上两个函数就是李超线段树的实现
signed main() {
	n=read();
	for(int i=1;i<=n;i++){
		t[i]=read();
	}
	for(int i=1;i<=n;i++){
		f[i]=read();
	}
	memset(dp,0xc0,sizeof dp);
	dp[1]=0;
	l[1].k=t[1],l[1].b=dp[1]/2-f[1];
	change(1,V,1,1,V,1);//先将1这根直线插进去
	int ans=0;
	for(int i=2;i<=n;i++){
		int j=query(t[i],1,1,V);//找到使值最大的那一条直线
		j=max(j,1ll);//这里要和1取一个max，避免选到0这根直线
		dp[i]=dp[j]/2+t[i]*t[j]-f[j];
		l[i].k=t[i],l[i].b=dp[i]/2-f[i];
		change(1,V,1,1,V,i);//插入直线
		ans=max(ans,dp[i]);
	}
	cout<<ans;
    return 0;
}
```

---

## 作者：Unnamed114514 (赞：1)

定义 $f_i$ 表示到达 $i$ 的答案，dp 转移方程显然：$f_i\gets\min\{\dfrac{f_j}{2}+T_i\times T_j-F_j\}$，观察到 $T_i\times T_j$ 项，所以考虑斜优。

令 $Y(j)=\dfrac{f_j}{2}-F_j,X(j)=-T_j$，$f_i\gets\min\{Y(j)-T_iX(j)\}$。

注意 $X,Y$ 均不单调，那么可以先 cdq 再斜优，代码是 $O(n\log^2n)$ 的，精细实现可以做到 $O(n\log n)$。

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
inline int read(){
	int res=0;
	char ch=getchar();
	while(ch<'0'||ch>'9') ch=getchar();
	while(ch>='0'&&ch<='9') res=(res<<1)+(res<<3)+(ch^'0'),ch=getchar();
	return res;
}
const int N=5e5+5;
int n,ql,qr,q[N],a[N],b[N],id[N];
ll f[N],ans;
inline ll Y(int i){ return f[i]/2-b[i]; }
inline int X(int i){ return -a[i]; }
inline double clac(int x,int y){ return X(x)==X(y)?1e20:(Y(x)-Y(y))*1.0/(X(x)-X(y)); }
inline bool cmp(int a,int b){ return X(a)<X(b)||(X(a)==X(b)&&Y(a)<Y(b)); }
void cdq(int l,int r){
	if(l==r) return;
	int mid=l+r>>1;
	cdq(l,mid);
	sort(id+l,id+mid+1,cmp),sort(id+mid+1,id+r+1,cmp);
	ql=1,qr=0;
	for(int i=l;i<=mid;++i){
		while(ql<qr&&clac(q[qr-1],q[qr])<clac(q[qr],id[i])) --qr;
		q[++qr]=id[i];
	}
	for(int i=mid+1;i<=r;++i){
		while(ql<qr&&clac(q[ql],q[ql+1])>a[id[i]]) ++ql;
		f[id[i]]=max(f[id[i]],f[q[ql]]/2+a[q[ql]]*a[id[i]]-b[q[ql]]);
	}
	for(int i=mid+1;i<=r;++i) id[i]=i;
	cdq(mid+1,r);
}
signed main(){
	n=read();
	for(int i=1;i<=n;++i) a[i]=read();
	for(int i=1;i<=n;++i) b[i]=read();
	for(int i=1;i<=n;++i) id[i]=i;
	memset(f,-0x3f,sizeof(f)),f[1]=0;
	cdq(1,n);
	for(int i=1;i<=n;++i) ans=max(ans,f[i]);
	printf("%lld\n",ans);
	return 0;
}
```

---


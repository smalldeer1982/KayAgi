# [NOIP2022] 比赛

## 题目描述

小 N 和小 O 会在 2022 年 11 月参加一场盛大的程序设计大赛 NOIP！小 P 会作为裁判主持竞赛。小 N 和小 O 各自率领了一支 $n$ 个人的队伍，选手在每支队伍内都是从 $1$ 到 $n$ 编号。每一个选手都有相应的程序设计水平。具体的，小 N 率领的队伍中，编号为 $i$（$1 \leq i \leq n$）的选手的程序设计水平为 $a _ i$；小 O 率领的队伍中，编号为 $i$（$1 \leq i \leq n$）的选手的程序设计水平为 $b _ i$。特别地，$\{a _ i\}$ 和 $\{b _ i\}$ 还分别构成了从 $1$ 到 $n$ 的排列。

每场比赛前，考虑到路途距离，选手连续参加比赛等因素，小 P 会选择两个参数 $l, r$（$1 \leq l \leq r \leq n$），表示这一场比赛会邀请两队中编号属于 $[l, r]$ 的所有选手来到现场准备比赛。在比赛现场，小 N 和小 O 会以掷骰子的方式挑选出参数 $p, q$（$l \leq p \leq q \leq r$），只有编号属于 $[p, q]$ 的选手才能参赛。为了给观众以最精彩的比赛，两队都会派出编号在 $[p, q]$ 内的、程序设计水平值最大的选手参加比赛。假定小 N 派出的选手水平为 $m _ a$，小 O 派出的选手水平为 $m _ b$，则比赛的精彩程度为 $m _ a \times m _ b$。

NOIP 总共有 $Q$ 场比赛，每场比赛的参数 $l, r$ 都已经确定，但是 $p, q$ 还没有抽取。小 P 想知道，对于每一场比赛，在其所有可能的 $p, q$（$l \leq p \leq q \leq r$）参数下的比赛的精彩程度之和。由于答案可能非常之大，你只需要对每一场答案输出结果对 $2 ^ {64}$ 取模的结果即可。

## 说明/提示

**【样例 1 解释】**

当 $p = 1, q = 2$ 的时候，小 N 会派出 $1$ 号选手，小 O 会派出 $2$ 号选手，比赛精彩程度为 $2 \times 2 = 4$。

当 $p = 1, q = 1$ 的时候，小 N 会派出 $1$ 号选手，小 O 会派出 $1$ 号选手，比赛精彩程度为 $2 \times 1 = 2$。

当 $p = 2, q = 2$ 的时候，小 N 会派出 $2$ 号选手，小 O 会派出 $2$ 号选手，比赛精彩程度为 $1 \times 2 = 2$。

**【样例 2】**

该样例满足测试点 $1 \sim 2$ 的限制。

**【样例 3】**

该样例满足测试点 $3 \sim 5$ 的限制。

**【数据范围】**

对于所有数据，保证：$1 \leq n, Q \leq 2.5 \times 10 ^ 5$，$1 \leq l _ i \leq r _ i \leq n$，$1 \leq a _ i, b _ i \leq n$ 且 $\{a _ i\}$ 和 $\{b _ i\}$ 分别构成了从 $1$ 到 $n$ 的排列。

| 测试点 | $n$ | $Q$ | 特殊性质 A | 特殊性质 B |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $1, 2$ | $\leq 30$ | $\leq 30$ | 是 | 是 |
| $3, 4, 5$ | $\leq 3,000$ | $\leq 3,000$ | 是 | 是 |
| $6, 7$ | $\leq 10 ^ 5$ | $\leq 5$ | 是 | 是 |
| $8, 9$ | $\leq 2.5 \times 10 ^ 5$ | $\leq 5$ | 是 | 是 |
| $10, 11$ | $\leq 10 ^ 5$ | $\leq 5$ | 否 | 否 |
| $12, 13$ | $\leq 2.5 \times 10 ^ 5$ | $\leq 5$ | 否 | 否 |
| $14, 15$ | $\leq 10 ^ 5$ | $\leq 10 ^ 5$ | 是 | 是 |
| $16, 17$ | $\leq 2.5 \times 10 ^ 5$ | $\leq 2.5 \times 10 ^ 5$ | 是 | 是 |
| $18, 19$ | $\leq 10 ^ 5$ | $\leq 10 ^ 5$ | 是 | 否 |
| $20, 21$ | $\leq 2.5 \times 10 ^ 5$ | $\leq 2.5 \times 10 ^ 5$ | 是 | 否 |
| $22, 23$ | $\leq 10 ^ 5$ | $\leq 10 ^ 5$ | 否 | 否 |
| $24, 25$ | $\leq 2.5 \times 10 ^ 5$ | $\leq 2.5 \times 10 ^ 5$ | 否 | 否 |

特殊性质 A：保证 $a$ 是均匀随机生成的 $1 \sim n$ 的排列。

特殊性质 B：保证 $b$ 是均匀随机生成的 $1 \sim n$ 的排列。

## 样例 #1

### 输入

```
0 2
2 1
1 2
1
1 2```

### 输出

```
8```

## 样例 #2

### 输入

```
见附件下的 match/match2.in。```

### 输出

```
见附件下的 match/match2.ans。```

## 样例 #3

### 输入

```
见附件下的 match/match3.in。```

### 输出

```
见附件下的 match/match3.ans。```

# 题解

## 作者：FutaRimeWoawaSete (赞：127)

**sol of P8868**

恕我直言，此题的难点在于构造双半群模型，如果只是讲解维护的信息，那么可以看懂此题，但是若在之后碰到类似的题目却还是只能瞎构造半天导致浪费大量时间，导致痛失其他题的分。

本篇题解想大致探索一下幺半群信息构造的方法，但并不是极其严谨与~~科学~~，你可以理解成民科吧！主要是市面上没有啥讲信息构造的，如果你做题不多其实很容易被坑。

------------------------------------------------------

一些极其一眼的思考：扫描线，然后转化成带历史和的 $X_{i} \times Y_{i}$，修改操作是二元信息区间覆盖，信息是求和，盲猜可做，于是难点来到如何设计双半群模型，构造信息。

------------------------------------------

从自己博客里搬点东西过来。

**半群**

给定一个集合 $D$ 以及一个集合 $D$ 上的二元运算 $\times$ 满足 $D \times D \rightarrow D$。

对于该运算满足结合律：$a,b,c \in D,(a \times b)\times c = a \times (b \times c)$。

**幺半群**

给定一个集合 $D$ 以及一个集合 $D$ 上的二元运算 $\times$ 满足 $D \times D \rightarrow D$。

对于该运算满足结合律：$a,b,c \in D,(a \times b)\times c = a \times (b \times c)$。

满足幺元存在使得：$a,\epsilon \in D,a \times \epsilon = \epsilon \times a = a$。

**交换半群**

给定一个集合 $D$ 以及一个集合 $D$ 上的二元运算 $\times$ 满足 $D \times D \rightarrow D$。

对于该运算满足结合律：$a,b,c \in D,(a \times b)\times c = a \times (b \times c)$。

对于该运算满足交换律：$a,b,c \in D,a \times b = b \times a$。

**范围**

常见的范围有序列区间，树简单路径，二维平面矩形，高维正交范围，半平面范围，圆范围。

我们一般理解成对于进行修改和查询的信息的限制。

**双半群模型**

直接~~再次~~贺一下 lxl PPT 里的图。

![zcrGPP.png](https://s1.ax1x.com/2022/12/07/zcrGPP.png)

还需要注意的是对于 $D \times M \rightarrow D$ 的 $\times$ 运算对于 $(D,+)$ 运算具有分配律。

我们称这样的模型为双半群模型。

需要注意的是，采取线段树，维护的信息至少是半群信息，然而大多数时候也是交换半群信息。

那么我们需要做到的是设计 $D,M$ 去满足上述的双半群模型，在大多数时候我们采取的下传标记信息都是维护 $D$ 的增量，根据题意也应当适当添加其它下传标记信息像区间覆盖区间乘法等等，此题就是区间覆盖。

我们根据一些表象的信息，比如这里有区间覆盖，那我们知道我们的下传标记信息至少有一个 $c_x,c_y$ 表示对于区间 $x$ 元和 $y$ 元的覆盖。

其次尝试构造 $D$。我们先来尝试一些区间覆盖的影响，假设一直修改 $x$ 那么貌似我们可以加 $\sum y$ 这样的东西。当然如果你要套路化，在观察到 $X_i \times Y_i$ 这样的结构的时候就可以以此为最高次，构造一个多项式形式的 $D$ 类信息，即维护扫描线时当前的 $\sum X_i \times Y_i,\sum X_i,\sum Y_i$ 以及 $s$ 表示区间历史和 $len$ 表示区间长，形式化地记为 $D = (s_{xy},s_x,s_y,s,len)$。

对于下传标记的信息，通过尝试修改带来的影响，或者放弃思考，套路化地设成 $M = (c_x,c_y,m_{xy},m_x,m_y,m)$，表示区间覆盖 $x/y$，**在该合并信息 $M$ 中的覆盖标记未下传前，对于子树内 $D$ 中 $s$ 的贡献需要加上 $m_{xy} \times D_{s_{xy}} + m_x \times D_{s_{x}} + m_y \times D_{s_y} + m \times D_{len}$**。

定义下传标记信息中对于贡献加法的优先级高于覆盖标记是有理由的，比如说纯区间覆盖，区间加，区间求和，一种实现方法就是下传信息时先让加标记下传，然后再下传区间覆盖标记，因为加标记的信息依赖于未被覆盖之前的区间信息，你让覆盖标记优先于加法标记下传就会让加标记无所依赖，难以维护。

在大多数时候，你要相信你通过常规的标记设计出来的 $D,M$ 是满足 $D$ 是交换半群和半群信息的，以防万一你可以验证一下。

所以只需要构造出来三类关系，$D \times M \rightarrow D,D + D \rightarrow D,M \text * M \rightarrow M$ 的具体操作就好了。

构造难度基本和 $D,M$ 的维护标记个数正相关。此题你发现 $D + D \rightarrow D$ 就是最简单的！写成代码就是：

```cpp
inline info merge(info x,info y){return info(x.s + y.s , x.sx + y.sx , x.sy + y.sy , x.sxy + y.sxy);}	
```
其次我们构造 $D \times M \rightarrow D$，直接放代码然后解释：
```cpp
inline info merge(info x,tag y,int len)
{
	x.s += y.axy * x.sxy + y.ax * x.sx + y.ay * x.sy + y.c * len;
	if(y.cx && y.cy)
	{
		x.sxy = len * y.cx * y.cy;
		x.sx = len * y.cx;
		x.sy = len * y.cy;
	}
	else if(y.cx)
	{
		x.sxy = x.sy * y.cx;
		x.sx = len * y.cx;
	}
	else if(y.cy)
	{
		x.sxy = x.sx * y.cy;
		x.sy = len * y.cy;
	}
	return x;
}
```
即对于 $s$ 我们根据定义先直接更新一遍；然后再根据是否有覆盖标记修改 $s_{xy},s_x,s_y$，这个比较简单就不多说了。

最后我们构造 $M \text{*} M \rightarrow M$。

还是贴代码解释：

```cpp
inline tag merge(tag x,tag y)//x -> y
{ 
	if(y.cx && y.cy) y.c += x.axy * y.cx * y.cy + x.ax * y.cx + x.ay * y.cy + x.c;
	else if(y.cx) 
	{
		y.ay += x.axy * y.cx + x.ay;
		y.c += x.c + x.ax * y.cx;
	}
	else if(y.cy)
	{
		y.ax += x.axy * y.cy + x.ax;
		y.c += x.c + x.ay * y.cy;
	}
	else 
	{
		y.axy += x.axy;
		y.ax += x.ax;
		y.ay += x.ay;
		y.c += x.c;
	}
	if(x.cx) y.cx = x.cx;
	if(x.cy) y.cy = x.cy;
	return y;
}
```
$M1 \text{*} M2 \rightarrow M$，设 $M1$ 作用在 $M2$ 上，设区间长为 $len$，分类讨论：

- 若 $M2$ 中的 $c_x,c_y$ 都有值，我们不妨转化为对于每个位置增量的形式($D_m$)，则当前的状态就是区间内的 $X_i,Y_i$ 都相同，考虑贡献是 ${M1}_{m_{xy}} \times \sum X_i \times Y_i$，由于 $X_i,Y_i$ 都相等，变成 ${M1}_{m_{xy}} \times {M2}_{c_x} \times M2_{c_y} \times len$，则增量是 ${M1}_{m_{xy}} \times {M2}_{c_x} \times M2_{c_y}$。类似地我们写出来其它三个增量即可。

- 若仅 $M2$ 中的 $c_x$ 有值，对于 ${M1}_{m_{xy}} \times \sum X_i \times Y_i$ 我们写成 ${M1}_{m_{xy}} \times M2_{c_x} \times \sum  Y_i$，发现对于 $\sum Y_i$ 就又可以迭代下去，将 ${M1}_{m_{xy}} \times M2_{c_x}$ 加到 $M2_{m_y}$ 上面去即可；而对于 $M1_{m_x} \times \sum X_i$ 我们写成 $M1_{m_x} \times M2_{c_x} \times len$ 的形式，即将 $M1_{m_x} \times M2_{c_x}$ 加到 $M2_{m_c}$ 上面去；然后 $M2_{m_y} \leftarrow M2_{m_y} + M1_{m_y},M2_{m_c} \leftarrow M2_{m_c} + M1_{m_c}$。

- 若仅 $M2$ 中的 $c_y$ 有值类似上述情况；

- 若 $M2$ 中的 $c_x,c_y$ 都无值，就直接对应项相加即可。

在 $M1 \text{*} M2 \rightarrow M$ 构造时，个人认为最重要的一点是，根据分讨的情况我们要转化式子，然后**将已经确定的常数项根据下传标记的定义分配到更低次幂的增量上**。

一个卡常的办法是一次单调栈弹栈过程进行到底，不要弹一次区间修改一次；将 $D,M$ 单独定义成结构体会方便调试一些。

当然如果你神通广大，直接写成矩乘然后拆拆拆也是可以的。

时间复杂度 $O((n + q) \log n)$。

单根做法相对有点平凡，而且很容易被卡常就没有讲的必要了？

```cpp
#include "bits/stdc++.h"
using namespace std;
const int Len = 2.5e5 + 5;
#define ull unsigned long long
ull n,q;
inline ull read() {
    char ch = getchar();
    ull x = 0, f = 1;
    while (ch < '0' || ch > '9') ch = getchar();
    while ('0' <= ch && ch <= '9') {
        x = x * 10 + ch - '0';
        ch = getchar();
    }
    return x * f;
}
void write(ull x) {
    if (x > 9)
        write(x / 10);
    putchar(x % 10 + '0');
}
struct info
{
	ull s,sx,sy,sxy;
	info(){s = sx = sy = sxy = 0;}
	info(ull S,ull SX,ull SY,ull SXY){s = S , sx = SX , sy = SY , sxy = SXY;}
	inline void clr(){s = sx = sy = sxy = 0;}
	inline void output(){printf("%llu %llu %llu %llu\n",s,sx,sy,sxy);}
}inf[Len << 2];
struct tag
{
	ull cx,cy,ax,ay,axy,c;
	tag(){cx = cy = ax = ay = axy = c = 0;}
	tag(ull CX,ull CY,ull AX,ull AY,ull AXY,ull C){cx = CX , cy = CY , ax = AX , ay = AY , axy = AXY , c = C;}
	inline void clr(){cx = cy = ax = ay = axy = c = 0;}
	inline bool empty(){return !(cx || cy || ax || ay || axy || c);}
	inline void output(){printf("%llu %llu %llu %llu %llu %llu\n",cx,cy,ax,ay,axy,c);}
}tg[Len << 2];
//需要实现 O + T -> O,T + T -> T,O + O -> O
//重点在于 T + T -> T 
//若 c_x,c_y 都存在，则当前的标记维护的是 cx,cy 的信息，只需要将信息叠加到 c 上即可
//若 c_x 存在，则当前 ay,c 会被影响， 
//若 c_y 存在，则当前 ax,c 会被影响，
//若都不存在，含义就是暴力更新 
//每次结束后下传一个 axy = 1 的 tag
//emmmm。
inline info merge(info x,info y){return info(x.s + y.s , x.sx + y.sx , x.sy + y.sy , x.sxy + y.sxy);}	
inline tag merge(tag x,tag y)//x -> y
{ 
	if(y.cx && y.cy) y.c += x.axy * y.cx * y.cy + x.ax * y.cx + x.ay * y.cy + x.c;
	else if(y.cx) 
	{
		y.ay += x.axy * y.cx + x.ay;
		y.c += x.c + x.ax * y.cx;
	}
	else if(y.cy)
	{
		y.ax += x.axy * y.cy + x.ax;
		y.c += x.c + x.ay * y.cy;
	}
	else 
	{
		y.axy += x.axy;
		y.ax += x.ax;
		y.ay += x.ay;
		y.c += x.c;
	}
	if(x.cx) y.cx = x.cx;
	if(x.cy) y.cy = x.cy;
	return y;
}
inline info merge(info x,tag y,int len)
{
	x.s += y.axy * x.sxy + y.ax * x.sx + y.ay * x.sy + y.c * len;
	if(y.cx && y.cy)
	{
		x.sxy = len * y.cx * y.cy;
		x.sx = len * y.cx;
		x.sy = len * y.cy;
	}
	else if(y.cx)
	{
		x.sxy = x.sy * y.cx;
		x.sx = len * y.cx;
	}
	else if(y.cy)
	{
		x.sxy = x.sx * y.cy;
		x.sy = len * y.cy;
	}
	return x;
}
#define ls(p) (p << 1)
#define rs(p) (p << 1 | 1)
inline void push_up(int p){inf[p] = merge(inf[ls(p)] , inf[rs(p)]);}
inline void push_down(int p,int l,int r)
{
	if(!tg[p].empty())
	{
		int mid = (l + r) >> 1;int l1 = (mid - l + 1) , l2 = (r - mid);
		tg[ls(p)] = merge(tg[p] , tg[ls(p)]) , tg[rs(p)] = merge(tg[p] , tg[rs(p)]);
		inf[ls(p)] = merge(inf[ls(p)] , tg[p] , l1) , inf[rs(p)] = merge(inf[rs(p)] , tg[p] , l2);
		tg[p].clr();
		return;
	}
}
void update(int p,int l,int r,int nl,int nr,tag t)
{
	if(nl <= l && nr >= r) 
	{
		tg[p] = merge(t , tg[p]);
		inf[p] = merge(inf[p] , t , r - l + 1);
		//printf("#%d %d:\n",l,r);
		//tg[p].output();
		//inf[p].output();
		return;
	}
	push_down(p , l , r);
	int mid = (l + r) >> 1;
	if(nl <= mid) update(ls(p) , l , mid , nl , nr , t);
	if(nr > mid) update(rs(p) , mid + 1 , r , nl , nr , t);
	push_up(p);
}
ull query(int p,int l,int r,int nl,int nr)
{
	if(nl <= l && nr >= r) 
	{
		/*if(l == 2 && r == 2)
		{
			printf("?%d %d:\n",l,r);
			tg[p].output();
			inf[p].output();
		}*/
		return inf[p].s;
	}
	push_down(p , l , r);
	int mid = (l + r) >> 1;ull res = 0;
	if(nl <= mid) res += query(ls(p) , l , mid , nl , nr);
	if(nr > mid) res += query(rs(p) , mid + 1 , r , nl , nr);
	return res;
}
ull a[Len],b[Len],stk[Len][2],top[2];
struct Node
{
	ull l,id;
	Node(){l = id = 0;}
	Node(ull L,ull ID){l = L , id = ID;}
}Qs[Len];
vector<Node> vec[Len];
ull Pt[Len];ull sz[Len];
signed main()
{
	freopen("match.in","r",stdin);
	freopen("match.out","w",stdout);
	int TP = read();
	n = read();
	for(int i = 1 ; i <= n ; i ++) a[i] = read();
	for(int i = 1 ; i <= n ; i ++) b[i] = read();
	q = read();
	for(int i = 1 ; i <= q ; i ++)
	{
		Qs[i].l = read() , Qs[i].id = read();
		sz[Qs[i].id] ++;
	}
	for(int i = 1 ; i <= n ; i ++) vec[i].reserve(sz[i]);
	for(int i = 1 ; i <= q ; i ++) vec[Qs[i].id].push_back(Node(Qs[i].l , i));
	for(int i = 1 ; i <= n ; i ++)
	{
		while(top[0] > 0 && a[stk[top[0]][0]] < a[i]) top[0] --;
		update(1 , 1 , n , stk[top[0]][0] + 1 , i , tag(a[i] , 0 , 0 , 0 , 0 , 0));
		stk[++ top[0]][0] = i;
		while(top[1] > 0 && b[stk[top[1]][1]] < b[i]) top[1] --;
		update(1 , 1 , n , stk[top[1]][1] + 1 , i , tag(0 , b[i] , 0 , 0 , 0 , 0));
		stk[++ top[1]][1] = i;
		update(1 , 1 , n , 1 , i , tag(0 , 0 , 0 , 0 , 1 , 0));
		int Sz = (int)vec[i].size();for(int j = 0 ; j < Sz ; j ++) Pt[vec[i][j].id] = query(1 , 1 , n , vec[i][j].l , i);	
	} 
	for(int i = 1 ; i <= q ; i ++) write(Pt[i]) , putchar('\n');
	return 0;
}
```

---

## 作者：_rqy (赞：93)

## 题意

给定 $A_{1, \dots, n}, B_{1 \dots n}$,
以及 $m$ 个提问, 每次提问给出 $l, r$, 求

$$
\sum_{p = l}^r \sum_{q = p}^r \bigl(\max\nolimits_{i=p}^q A_i\bigr)\bigl(\max\nolimits_{i=p}^q B_i\bigr).
$$

## 题解

我们离线所有询问, 对右端点 $r$ 进行扫描线.

在扫描过程中, 我们设 $X_l$ 和 $Y_l$ 分别表示
$l, \dots, r$ 范围内 $A_i$ 和 $B_i$ 的最大值.

事实上应该是 $X_{l, r}$ 和 $Y_{l, r}$. 我们只是简记.

在扫描右端点的同时, 我们维护 $A, B$ 的单调栈.
这样如果扫描到 $i$, 轮到 $i$ 入栈时, 设两个栈顶分别是 $u, v$,
那么 $u+1, \dots, i$ 区间的 $X$ 会区间修改为 $A_i$,
$v+1, \dots, i$ 区间的 $Y$ 会区间修改为 $B_i$.

如果我们要查询的 $l, r$ 的答案, 那么相当于在扫描到 $r$ 的时候,
查询 $l, \dots, r$ 区间的 _历史 $X \times Y$ 和_.

这么说可能有点奇怪, 不太好谈.

我们可以在扫描的时候, 对每个 $l$, 维护

$$S_{l, r} = \sum_{r' = l}^r X_{l, r'} \times Y_{l, r'}.$$

这样的话, 我们要查询的就是 $l, \dots, r$ 的区间 $S$ 和.

而我们的操作则是区间 $X$ 修改 (覆盖), 区间 $Y$ 修改 (覆盖),
以及**区间 $S \mathrel{+}= X \times Y$**.

因此我们可以用线段树维护. 复杂度 $O(n \log n)$.

### 细节

我们发现 tag 是若干区间 $X$ 修改 (覆盖), 区间 $Y$ 修改 (覆盖),
以及区间 $S \mathrel{+}= X \times Y$ 的复合, 可以维护为
$\mathrm{Tag}(s_X, s_Y, a_X, a_Y, a_{XY}, a)$, 表示

$$\begin{aligned}
S' &= S + a_XX + a_YY+a_{XY}X \times Y+a \\
X' &= \begin{cases} X & s_X = 0 \\ s_X & s_X \neq 0\end{cases} \\
Y' &= \begin{cases} Y & s_Y = 0 \\ s_Y & s_Y \neq 0\end{cases}
\end{aligned}$$

也就是说 $s_X, s_Y$ 表示 $X, Y$ 的区间覆盖, 而 $a_X, a_Y, a_{XY}, a$ 分别表示 $S$ 加上对应倍的 $X, Y, X \times Y, 1$.

我们要维护区间 $S$ 和, 结合上面的 $\mathrm{Tag}$ 就知道我们还要同时维护区间 $X$ 和, 区间 $Y$ 和以及区间 $X \times Y$ 和.

剩下的具体看代码.

## 代码

```cpp
#include <algorithm>
#include <cctype>
#include <cstdio>
#include <cstring>

int read() {
  int ans = 0, c;
  while (!isdigit(c = getchar()));
  do ans = ans * 10 + c - '0';
  while (isdigit(c = getchar()));
  return ans;
}

typedef unsigned long long ULL;

struct Msg {
  ULL sumX, sumY, sumXY, sumS;
  Msg() : sumX(0), sumY(0), sumXY(0), sumS(0) {}
  Msg(ULL sx, ULL sy, ULL sxy, ULL sb) : sumX(sx), sumY(sy), sumXY(sxy), sumS(sb) {}
  inline Msg operator+(const Msg &t) const {
    return Msg(sumX + t.sumX, sumY + t.sumY, sumXY + t.sumXY, sumS + t.sumS);
  }
};

struct Tag {
  // first add, then set
  ULL addX, addY, addXY, addC; // S += addX * X + addY * Y + addXY * XY + addC
  ULL setX, setY; // = 0: not set
  Tag() : addX(0), addY(0), addXY(0), addC(0), setX(0), setY(0) {}
  Tag(ULL ax, ULL ay, ULL axy, ULL ac, ULL sx, ULL sy)
    : addX(ax), addY(ay), addXY(axy), addC(ac), setX(sx), setY(sy) {}

  operator bool() const { return addX || addY || addXY || addC || setX || setY; } // check if tag is non trivial

  // tag1 * tag2: first apply tag2, then apply tag1
  inline Tag operator*(const Tag &t) const {
    ULL ax = t.addX, ay = t.addY, axy = t.addXY, ac = t.addC;
    ULL sx = t.setX, sy = t.setY;

    if (sx) {
      ac += addX * sx;
      if (sy) {
        ac += addXY * sx * sy;
      } else {
        ay += addXY * sx;
      }
    } else {
      ax += addX;
      if (sy) {
        ax += addXY * sy;
      } else {
        axy += addXY;
      }
    }

    if (sy) {
      ac += addY * sy;
    } else {
      ay += addY;
    }

    ac += addC;

    if (setX) sx = setX;
    if (setY) sy = setY;

    return Tag(ax, ay, axy, ac, sx, sy);
  }

  inline Msg apply(const Msg &m, ULL len) const { // len: length of range
    return Msg(/* sumX  */ setX ? setX * len : m.sumX,
               /* sumY  */ setY ? setY * len : m.sumY,
               /* sumXY */ setX ? (setY ? setX * setY * len : setX * m.sumY) : (setY ? m.sumX * setY : m.sumXY),
               /* sumS  */ m.sumS + addX * m.sumX + addY * m.sumY + addXY * m.sumXY + addC * len);
  }
};

const int N = 250050;
const int NN = 550000;

Tag tag[NN];
Msg msg[NN];

inline void upd(int o, int l, int r) {
  msg[o] = tag[o].apply(msg[o << 1] + msg[o << 1 | 1], r - l + 1);
}

inline void app(int o, int l, int r, const Tag &t) {
  tag[o] = t * tag[o];
  msg[o] = t.apply(msg[o], r - l + 1);
}

inline void pushd(int o, int l, int r) {
  if (tag[o]) {
    int m = (l + r) / 2;
    app(o << 1, l, m, tag[o]);
    app(o << 1 | 1, m + 1, r, tag[o]);
    tag[o] = Tag();
  }
}

void Modify(int o, int l, int r, int L, int R, const Tag &t) {
  if (L <= l && r <= R) {
    app(o, l, r, t);
    return;
  }
  pushd(o, l, r);
  int m = (l + r) / 2;
  if (L <= m) Modify(o << 1, l, m, L, R, t);
  if (R > m) Modify(o << 1 | 1, m + 1, r, L, R, t);
  upd(o, l, r);
}

ULL QueryS(int o, int l, int r, int L, int R) {
  if (L <= l && r <= R) return msg[o].sumS;
  pushd(o, l, r);
  int m = (l + r) / 2;
  ULL ans = 0;
  if (L <= m) ans += QueryS(o << 1, l, m, L, R);
  if (R > m) ans += QueryS(o << 1 | 1, m + 1, r, L, R);
  return ans;
}

struct Qry {
  int l, r, id;
  bool operator <(const Qry &t) const {
    return r < t.r;
  }
} Q[N];

int n, m, A[N], B[N];
int sA[N], sB[N];
ULL ans[N];

int main() {
  read();
  n = read();
  for (int i = 1; i <= n; ++i) A[i] = read();
  for (int i = 1; i <= n; ++i) B[i] = read();
  // Init(1, 1, n);
  m = read();
  for (int i = 0; i < m; ++i) {
    Q[i].l = read();
    Q[i].r = read();
    Q[i].id = i;
  }
  std::sort(Q, Q + m);
  int lA = 0, lB = 0;
  for (int i = 1, j = 0; i <= n; ++i) {
    while (lA && A[sA[lA]] < A[i]) --lA;
    while (lB && B[sB[lB]] < B[i]) --lB;
    Modify(1, 1, n, sA[lA] + 1, i, Tag(0, 0, 0, 0, A[i], 0)); // set X
    Modify(1, 1, n, sB[lB] + 1, i, Tag(0, 0, 0, 0, 0, B[i])); // set Y
    Modify(1, 1, n, 1, i, Tag(0, 0, 1, 0, 0, 0)); // S += X * Y
    sA[++lA] = sB[++lB] = i;
    for (; j < m && Q[j].r == i; ++j)
      ans[Q[j].id] = QueryS(1, 1, n, Q[j].l, i);
  }
  for (int i = 0; i < m; ++i)
    printf("%llu\n", ans[i]);
}
```

---

## 作者：OMG_wc (赞：76)


直接暴力做是 $O(n^2q)$ 的，可以拿到 $8$ 分的高分。

考虑离线做，对所有询问按照 $r$ 从小到大一个个来。假设当前考虑到 $r$，记 $x_i=\max\limits_{j=i}^r a_j$，$y_i=\max\limits_{j=i}^r b_j$，$f_i=\sum\limits_{j=i}^rx_j y_j$，那么对于询问 $(l,r)$，答案就是 $\sum\limits_{i=l}^r f_i$。这样时间复杂度变为 $O(n^2+nq)$，可以拿到 $20$ 分的高分，参考代码如下：

```c++
struct Node {
    int l, id;
};
vector<Node> d[N];
ULL a[N], b[N];
ULL f[N], x[N], y[N];
ULL ans[N];
int main() {
    int n, q;
    scanf("%*d%d", &n);
    for (int i = 1; i <= n; i++) {
        scanf("%llu", &a[i]);
    }
    for (int i = 1; i <= n; i++) {
        scanf("%llu", &b[i]);
    }
    scanf("%d", &q);
    for (int i = 1; i <= q; i++) {
        int l, r;
        scanf("%d%d", &l, &r);
        d[r].push_back({l, i});
    }
    for (int r = 1; r <= n; r++) {
        for (int i = 1; i <= r; i++) {
            x[i] = max(x[i], a[r]);
            y[i] = max(y[i], b[r]);
            f[i] += x[i] * y[i];
        }
        for (auto [l, id] : d[r]) {
            for (int i = l; i <= r; i++)
                ans[id] += f[i];
        }
    }
    for (int i = 1; i <= q; i++) printf("%llu\n", ans[i]);
    return 0;
}
```

考虑优化，用线段树来维护 $f_i$，这样 $O(\log n)$ 时间能求出 $\sum\limits_{i=l}^r f_i$ 。

用单调栈或者 DP 预处理出 $a,b$ 数组每个元素作为最大值往左能控制到的最远位置，这样每个 $a_r$ 只会更新一段后缀的 $x_i$ ，$b_r$ 也同理，都利用线段树来做区间覆盖。也就说，每到一个新的 $r$，在回答询问前进行下面 $3$ 个步骤：

1. 区间更新一段后缀的 $x_i$ 为 $a_r$
2. 区间更新一段后缀的 $y_i$ 为 $b_r$
3. 在 $[1,r]$ 区间每个 $f_i$ 上加上 $x_i\times y_i$

线段树记录四个信息 $s$ 表示 $f_i$ 的区间和，$xy$ 表示区间内 $\sum x_iy_i$ ，$x$ 表示区间内 $\sum x_i$，$y$ 表示区间内 $\sum y_i$ 。

定义 $6$ 个延迟标记，$c_x,c_y$ 是覆盖标记，后面四个标记 $add_{xy},add_{x},add_{y},add_c$ 分别为 $\sum x_iy_i,\sum x_i,\sum y_i,\sum1$ （相当于区间长度）的增量，也就是各自增加的倍数。

规定延迟标记的优先级为，加标记应用在覆盖标记之前，这样在下传的时候，下传的加标记会作用在原先的信息上。也就是说，如果原先存在覆盖标记，下传的加标记会退化 。

比如原先只有 $x$ 是被覆盖成 $c_x$ 的，那么 $add_y$ 和 $add_c$ 不受影响，直接和原标记合并，而 $add_{xy}\sum x_iy_i=add_{xy}c_x\sum y_i$ ，也就是 $add_{xy}$ 转换成了 $add_{xy}\times c_x$ 加到 $add_y$ 里，同理 $add_x$ 转换成 $add_x\times c_x$ 加到 $add_c$ 里。这样更新后，所有加标记又都是应用在覆盖标记之前的，**加的都是原值的倍数**。

对于区间信息的更新，首先 $s$ 应该加上 $add_{xy}\times \sum x_iy_i+add_{x}\times \sum x_i+add_{y}\times\sum y_i +add_c\times \sum1$，然后根据是否有覆盖标记来更新 $\sum x_iy_i,\sum x_i,\sum y_i$。

总时间复杂度 $O((n+q)\log n)$，[更多细节见代码](https://www.luogu.com.cn/paste/vsacq6lm)。



---

## 作者：dalao_see_me (赞：53)

这里是分治做法。

下面记 $A(l,r)=\max_{i=l}^r a_i$，$B(l,r)=\max_{i=l}^r b_i$。

## 52pts

每一个询问都分治一遍。

假设我们求好了下面两边各自的答案，现在计算跨过中间的区间的贡献。

钦定 $a$，$b$ 中的最大值都在右边，枚举右端点 $i$，那么可以在左边找到一个最靠左的 $j$。

此时贡献为 $(mid-j+1)\times A(mid+1,i)\times B(mid+1,i)$。

我们发现 $i$ 往右移动的时候 $A(mid+1,i)$ 和 $B(mid+1,i)$ 是单增的，往左同理。

可以双指针，对于每个 $i$ 求出 $j$。

再考虑 $a$ 最大值在右边，$b$ 最大值在左边的情况。依然枚举右端点 $i$，可以在左边找到一段区间（当然也可能没有）$[j,k]$ 使得区间中所有位置都满足条件。

还是双指针。

另外两种情况同理。

```cpp
inline void solve(int l, int r) {
	if (l > r) return;
	if (l == r) return void(ans += 1LL * a[l] * b[l]);
	int mid = l + r >> 1;
	solve(l, mid); solve(mid + 1, r);
	al[mid + 1] = 0; ar[mid] = 0;
	bl[mid + 1] = 0; br[mid] = 0;
	for (int i = mid; i >= l; i--) {
		al[i] = max(al[i + 1], a[i]);
		bl[i] = max(bl[i + 1], b[i]);
	}
	for (int i = mid + 1; i <= r; i++) {
		ar[i] = max(ar[i - 1], a[i]);
		br[i] = max(br[i - 1], b[i]);
	}
	for (int i = mid, j = mid; i >= l; i--) {
		while (j < r && ar[j + 1] < al[i] && br[j + 1] < bl[i]) ++j;
		ans += 1LL * al[i] * bl[i] * (j - mid);
	}
	for (int i = mid + 1, j = mid + 1; i <= r; i++) {
		while (j > l && ar[i] > al[j - 1] && br[i] > bl[j - 1]) --j;
		ans += 1LL * ar[i] * br[i] * (mid + 1 - j);
	}
	ULL s = 0;
	for (int i = mid, j = mid, k = mid + 1; i >= l; i--) {
		while (j < r && al[i] > ar[j + 1]) s += br[++j];
		while (k <= j && bl[i] > br[k]) s -= br[k++];
		ans += s * al[i];
	}
	s = 0;
	for (int i = mid + 1, j = mid + 1, k = mid; i <= r; i++) {
		while (j > l && ar[i] > al[j - 1]) s += bl[--j];
		while (k >= j && br[i] > bl[k]) s -= bl[k--];
		ans += s * ar[i];
	}
}
```
## 100pts

显然不能对每一个询问都求一遍答案，这个时候要离线。

考虑把询问挂到分治的区间上。

对于一个分治的区间 $[i,j]$：

如果 $l\le i\le j\le r$，那么挂上去并返回。

如果询问跨过了中点，就挂在这个点上并往左右子区间递归。

如果没跨过中点就往询问所在的子区间递归。

这样挂的次数是 $O(\log m)$ 的。~~觉得抽象可以看代码里的 `add`。~~

还是枚举右端点 $i$，双指针得到 $j,k$，其中 $[j,k)$ 中都是满足 $a$ 最大值在右而 $b$ 最大值在左的左端点，$[k,mid]$ 中都是满足两个最大值都在右的左端点。

每次右端点的右移都会使答案这样变化：

对于每个在 $[j,k)$ 中的左端点 $L$ 分别加上 $A(mid+1,i)\times B(L,mid)$；

对区间 $[k,mid]$ 中的每一个都加上 $A(mid+1,i)\times B(mid+1,i)$。

如果 $i$ 是某个询问的右端点（记为 $[L_2,i]$），就把 $[L_2,mid]$ 区间中的左端点的答案加起来。

可以用线段树维护这个东西。

另外的情况也同理。

```cpp
#define lx x << 1
#define rx x << 1 | 1
typedef unsigned long long ULL;
const int N = 3e5 + 5;
int n, num, m;
ULL a[N], b[N], amx[N], bmx[N], ans[N << 2], Ans[N];
struct Node {
	int l, r;
} h[N];
vector <int> t[N << 2], er[N], el[N];
struct SGT {
	ULL sum[N << 2], sumb[N << 2], tag[N << 2];
	inline void pushup(int x) {
		sum[x] = sum[lx] + sum[rx];
		sumb[x] = sumb[lx] + sumb[rx];
	}
	inline void pushdown(int x) {
		if (!tag[x]) return;
		sum[lx] += tag[x] * sumb[lx];
		sum[rx] += tag[x] * sumb[rx];
		tag[lx] += tag[x]; tag[rx] += tag[x];
		tag[x] = 0;
	}
	inline void build(int x, int L, int R, int op) {
		sum[x] = tag[x] = 0;
		if (L == R) return void(sumb[x] = op ? bmx[L] : 1);
		int mid = L + R >> 1;
		build(lx, L, mid, op);
		build(rx, mid + 1, R, op);
		pushup(x);
	}
	inline void change(int x, int l, int r, ULL w, int L, int R) {
		if (l <= L && R <= r) {
			sum[x] += w * sumb[x];
			tag[x] += w; return;
		}
		pushdown(x);
		int mid = L + R >> 1;
		if (l <= mid) change(lx, l, r, w, L, mid);
		if (r > mid) change(rx, l, r, w, mid + 1, R);
		pushup(x);
	}
	inline ULL query(int x, int l, int r, int L, int R) {
		if (l <= L && R <= r) return sum[x];
		pushdown(x);
		int mid = L + R >> 1; ULL res = 0;
		if (l <= mid) res += query(lx, l, r, L, mid);
		if (r > mid) res += query(rx, l, r, mid + 1, R);
		return res;
	}
} T[2];
inline void add(int x, int l, int r, int id) {
	if (h[id].l <= l && r <= h[id].r) {
		t[x].push_back(id);
		return;
	}
	int mid = l + r >> 1;
	if (h[id].r <= mid) add(lx, l, mid, id);
	else if (h[id].l > mid) add(rx, mid + 1, r, id);
	else {
		t[x].push_back(id);
		add(lx, l, mid, id);
		add(rx, mid + 1, r, id);
	}
}
inline void solve(int x, int l, int r) {
	if (l > r) return;
	if (l == r) {
		ans[x] = a[l] * b[l];
		for (int p : t[x]) Ans[p] += ans[x];
		return;
	}
	int mid = l + r >> 1; solve(lx, l, mid); solve(rx, mid + 1, r); ans[x] = ans[lx] + ans[rx];
	for (int i = l; i <= r; i++) {
		el[i].clear();
		er[i].clear();
	}
	vector <int> tmp;
	for (int p : t[x]) {
		if (h[p].r >= r && h[p].l <= l) tmp.push_back(p);
		else {
			er[min(h[p].r, r)].push_back(p);
			el[max(h[p].l, l)].push_back(p);
		}
	}
	amx[mid] = a[mid]; amx[mid + 1] = a[mid + 1];
	bmx[mid] = b[mid]; bmx[mid + 1] = b[mid + 1];
	for (int i = mid - 1; i >= l; i--) {
		amx[i] = max(a[i], amx[i + 1]);
		bmx[i] = max(b[i], bmx[i + 1]);
	}
	for (int i = mid + 2; i <= r; i++) {
		amx[i] = max(a[i], amx[i - 1]);
		bmx[i] = max(b[i], bmx[i - 1]);
	}
	T[0].build(1, l, mid, 0); T[1].build(1, l, mid, 1);
	for (int i = mid + 1, j = mid + 1, k = mid + 1; i <= r; i++) {
		while (j > l && amx[j - 1] < amx[i]) j--;
		while (k > j && bmx[k - 1] < bmx[i]) k--;
		if (k <= mid) T[0].change(1, k, mid, amx[i] * bmx[i], l, mid);
		if (j < k) T[1].change(1, j, k - 1, amx[i], l, mid);
		for (int p : er[i]) {
			int L = max(l, h[p].l);
			Ans[p] += T[0].query(1, L, mid, l, mid);
			Ans[p] += T[1].query(1, L, mid, l, mid);
		}
	}
	ans[x] += T[0].query(1, l, mid, l, mid) + T[1].query(1, l, mid, l, mid);
	T[0].build(1, mid + 1, r, 0); T[1].build(1, mid + 1, r, 1);
	for (int i = mid, j = mid, k = mid; i >= l; i--) {
		while (j < r && amx[j + 1] < amx[i]) j++;
		while (k < j && bmx[k + 1] < bmx[i]) k++;
		if (k > mid) T[0].change(1, mid + 1, k, amx[i] * bmx[i], mid + 1, r);
		if (k < j) T[1].change(1, k + 1, j, amx[i], mid + 1, r);
		for (int p : el[i]) {
			int R = min(r, h[p].r);
			Ans[p] += T[0].query(1, mid + 1, R, mid + 1, r);
			Ans[p] += T[1].query(1, mid + 1, R, mid + 1, r);
		}
	}
	ans[x] += T[0].query(1, mid + 1, r, mid + 1, r) + T[1].query(1, mid + 1, r, mid + 1, r);
	for (int p : tmp) Ans[p] += ans[x];
}
inline void Solve() {
	num = read(); n = read();
	for (int i = 1; i <= n; i++) a[i] = read();
	for (int i = 1; i <= n; i++) b[i] = read();
	m = read();
	for (int i = 1; i <= m; i++) {
		h[i].l = read();
		h[i].r = read();
		add(1, 1, n, i);
	}
	solve(1, 1, n);
	for (int i = 1; i <= m; i++) printf("%llu\n", Ans[i]);
}
```

---

## 作者：Little09 (赞：37)

> $q$ 次询问，每次给定区间 $[l,r]$，求所有子区间的 $a$ 最大值和 $b$ 最大值乘积的和。

先离线，然后扫描线扫过去右端点。考虑记 $f_i$ 为当前右端点下以 $i$ 为左端点的答案，那么每次新增一个点的时候会进行一些区间加操作，可以用单调栈维护一下。容易发现这些区间均摊个数是 $O(n)$ 的。查询就是历史和。那么问题变成了：

- 对 $a$ 区间 $[l,r]$ 整体 $+x$；
- 对 $b$ 区间 $[l,r]$ 整体 $+x$；
- 对于每个 $s_i$，加上 $a_i\times b_i$；
- 查询一段 $s_i$ 的和。

先回顾一下区间加，历史和是怎么做的。线段树上的每个节点维护一个类似“标记队列”，队列每一项是形如 $+x$ 的加法操作或是 `upd` 的更新历史和操作。我们不显式维护队列，只要维护这个队列的一些特征值就好了。下传标记就是合并两个队列。

考虑一下线段树节点上要维护哪些值。首先有区间和 $sum$，区间历史和 $ans$，加法标记 $add$。考虑每个标记带来的影响：

- $+x$ 标记：$sum\gets sum+x\times len$，$add\gets add+x$；
- `upd` 标记：$ans\gets ans+sum$。

考虑合并两个队列（假设儿子上的是 $1$，父亲的是 $2$）的时候会怎样，$add_1$ 和 $sum_1$ 是容易的，$ans_1\gets ans_1+sum_1\times upd_2+h_2\times len_1$，其中 $upd$ 表示队列里有多少 `upd` 操作，$h$ 表示每次 `upd` 操作的 $add$ 的和。会发现还需要维护 $upd$ 和 $h$，$upd$ 是好维护的，再看一下 $h_1\gets h_1+add_1\times upd_2+h_2$。具体推导可以[参考博客](https://www.luogu.com.cn/blog/command-block/guan-yu-xian-duan-shu-shang-di-yi-suo-jin-jie-cao-zuo)。

再回到这个题。我们还是考虑线段树节点上要维护什么。首先肯定要有的：区间 $ab$ 的和 $s$，区间 $a$ 的和 $sa$，区间 $b$ 的和 $sb$，$ab$ 的历史版本和 $ans$，加 $a$ 标记 $adda$，加 $b$ 标记 $addb$。考虑每个标记带来的影响：

- $a+x$ 标记：$s\gets s+x\times sb$，$sa\gets sa+x\times len$，$adda\gets adda+x$；
- $b+x$ 标记：$s\gets s+x\times sa$，$sb\gets sb+x\times len$，$addb\gets addb+x$；
- `upd` 标记：$ans\gets ans+s$。

考虑合并两个队列（假设儿子上的是 $1$，父亲的是 $2$）的时候会怎样，似乎除了 $ans$ 都是容易的，$ans_1\gets ans_1+s_1\times upd_2+hb_2\times sa_1+ha_2\times sb_1+h_2\times len_1$，其中 $upd$ 表示队列里有多少 `upd` 操作，$ha$ 表示每次 `upd` 操作的 $adda$ 的和，$hb$ 表示每次 `upd` 操作的 $addb$ 的和，$h$ 表示每次 `upd` 操作 $adda\times addb$ 的和。会发现还需要维护 $upd$，$ha$，$hb$，$h$。$upd$ 是好维护的，再看一下 $ha_1\gets ha_1+adda_1\times upd_2+ha_2$，$hb$ 同理。推一下 $h$ 会怎么变，可以发现：$h_1\gets h_1+adda_1\times addb_1\times upd_2+adda_1\times hb_2+addb_1\times ha_2+h_2$。

维护以上所有标记即可。上述标记维护过程写成代码如下：

```cpp
inline void spread(int u,point v)
{
	s[u].ans+=s[u].s*v.upd+s[u].sa*v.hb+s[u].sb*v.ha+v.h*s[u].l;
	s[u].h+=s[u].adda*s[u].addb*v.upd+s[u].adda*v.hb+s[u].addb*v.ha+v.h;
	s[u].ha+=s[u].adda*v.upd+v.ha;
	s[u].hb+=s[u].addb*v.upd+v.hb;
	s[u].s+=s[u].sa*v.addb+s[u].sb*v.adda+v.addb*v.adda*s[u].l;
	s[u].sa+=v.adda*s[u].l;
	s[u].sb+=v.addb*s[u].l;
	s[u].upd+=v.upd;
	s[u].adda+=v.adda;
	s[u].addb+=v.addb;
}
```

于是这道题就做完了，时间复杂度 $O(n\log n)$。

```cpp
// Author: Little09
// Problem: P8868 [NOIP2022] 比赛
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P8868
// Memory Limit: 512 MB
// Time Limit: 2000 ms
// Start Time: 2022-12-23 15:37:28
// 
// Powered by CP Editor (https://cpeditor.org)

#include <bits/stdc++.h>
using namespace std;
#define ull unsigned long long
#define mkp make_pair
#define pii pair<int,int>
#define fi first
#define se second
const int N=3e5+5;
int n,m;
struct point
{
	ull adda,addb,s,sa,sb,upd,h,ha,hb,ans,l;
}s[N*4];
ull ans[N],a[N],b[N];
inline void push_up(int u)
{
	s[u].s=s[u*2].s+s[u*2+1].s;
	s[u].sa=s[u*2].sa+s[u*2+1].sa;
	s[u].sb=s[u*2].sb+s[u*2+1].sb;
	s[u].ans=s[u*2].ans+s[u*2+1].ans;
}
inline void spread(int u,point v)
{
	s[u].ans+=s[u].s*v.upd+s[u].sa*v.hb+s[u].sb*v.ha+v.h*s[u].l;
	s[u].h+=s[u].adda*s[u].addb*v.upd+s[u].adda*v.hb+s[u].addb*v.ha+v.h;
	s[u].ha+=s[u].adda*v.upd+v.ha;
	s[u].hb+=s[u].addb*v.upd+v.hb;
	s[u].s+=s[u].sa*v.addb+s[u].sb*v.adda+v.addb*v.adda*s[u].l;
	s[u].sa+=v.adda*s[u].l;
	s[u].sb+=v.addb*s[u].l;
	s[u].upd+=v.upd;
	s[u].adda+=v.adda;
	s[u].addb+=v.addb;
}
inline void push_down(int u)
{
	spread(u*2,s[u]),spread(u*2+1,s[u]);
	s[u].h=0,s[u].ha=0,s[u].hb=0,s[u].upd=0,s[u].adda=0,s[u].addb=0;
}
void build(int u,int l,int r)
{
	s[u].l=r-l+1;
	if (l==r) return;
	int mid=(l+r)>>1;
	build(u*2,l,mid),build(u*2+1,mid+1,r);
}
void update(int u,int L,int R,int l,int r,ull x,int tp)
{
	if (l>r) return;
	if (l<=L&&R<=r) 
	{
		if (tp==0) spread(u,(point){x,0,0,0,0,0,0,0,0,0,R-L+1});
		else spread(u,(point){0,x,0,0,0,0,0,0,0,0,R-L+1});
		return;
	}
	push_down(u);
	int mid=(L+R)>>1;
	if (l<=mid) update(u*2,L,mid,l,r,x,tp);
	if (mid<r) update(u*2+1,mid+1,R,l,r,x,tp);
	push_up(u);
}
ull ask(int u,int L,int R,int l,int r)
{
	if (l<=L&&R<=r) return s[u].ans;
	int mid=(L+R)>>1;
	push_down(u);
	ull res=0;
	if (l<=mid) res+=ask(u*2,L,mid,l,r);
	if (mid<r) res+=ask(u*2+1,mid+1,R,l,r);
	return res;
}
vector<pii>t[N];
int sta[N],topa,stb[N],topb;

int main()
{
	ios_base::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	int T;
	cin >> T >> n;
	for (int i=1;i<=n;i++) cin >> a[i];
	for (int i=1;i<=n;i++) cin >> b[i];
	cin >> m;
	for (int i=1;i<=m;i++)
	{
		int l,r;
		cin >> l >> r;
		t[r].push_back(mkp(l,i));
	}
	build(1,1,n);
	topa=1,topb=1;
	a[0]=n+1,b[0]=n+1;
	for (int i=1;i<=n;i++)
	{
		while (a[sta[topa]]<a[i]) 
		{
			update(1,1,n,sta[topa-1]+1,sta[topa],-a[sta[topa]],0);
			topa--;
		}
		update(1,1,n,sta[topa]+1,i,a[i],0);
		sta[++topa]=i;
		while (b[stb[topb]]<b[i]) 
		{
			update(1,1,n,stb[topb-1]+1,stb[topb],-b[stb[topb]],1);
			topb--;
		}
		update(1,1,n,stb[topb]+1,i,b[i],1);
		stb[++topb]=i;
		spread(1,(point){0,0,0,0,0,1,0,0,0,0,0});
		for (auto j:t[i]) ans[j.se]=ask(1,1,n,j.fi,i);
	}
	for (int i=1;i<=m;i++) cout << ans[i] << '\n';
	return 0;
}

```


---

## 作者：CuiZhenhang (赞：31)

本题解为**线段树维护区间历史版本和**做法，讲解自认为较详细。

## 题意

给定 $a_{1,\dots,n}, b_{1,\dots,n}$，以及 $m$ 个询问, 每次询问给出 $l, r$ 求：

$$\sum_{p=l}^{r}\sum_{q=p}^{r}(\max_{i=p}^{q}a_i) \times (\max_{i=p}^{q}b_i)$$

数据范围：$n,m \leq 2.5 \times 10^5$。

## 题解

### 52 pts 做法

发现 $n \times m$ 为 $10^6$ 级别，考虑接近 $O(nm)$ 的做法。

对于区间最大值求和问题，一种常见的方法是考虑每个数的贡献。  
所以，令 $apre_i$ 表示 $1 \sim i$ 中最大的 $j$ 满足 $a_j \gt a_i$，$bpre_i$ 同理。  
$apre_i, bpre_i$ 可以使用单调栈 $O(n)$ 得到。

依次考虑子区间右边界从 $l$ 到 $r$ 递增。

右边界 $q$ 确定时，为表示方便，令 $A_p = \max_{i=p}^{q}a_i, B_p = \max_{i=p}^{q}b_i$。  

可以发现，当右边界 $q$ 扩展到 $k$ 时，$A_p$ 在 $1 \sim apre_k$ 处的值不变，在 $apre_k + 1 \sim k$ 处的值变为 $a_k$。$B_p$ 同理。  
因此，我们用线段树维护序列 $A_p, B_p$ 和 $\sum_{p=l}^{q}A_p \times B_p$，支持区间赋值 $A_p, B_p$。  
答案为 $\sum_{q=l}^{r}(\sum_{p=l}^{q}A_p \times B_p)$。

总时间复杂度为 $O(m n \log n)$，预期 52 pts。

### 100 pts 做法

可以发现，当右边界 $q$ 扩展到 $k$ 时，序列的修改与询问的 $l$ 无关，且不会修改 $A_{k+1,\dots,n}, B_{k+1,\dots,n}$。  
所以，右边界 $q$ 从 $1$ 开始还是从 $l$ 开始不会影响询问的答案。

由此可知，以下做法也是正确的：

$A_p, B_p$ 初始值为 $0$。  
令 $q$ 依次扩展到 $1 \sim n$，维护 $A_p, B_p, \sum A_p \times B_p$。  
然后将所有 $r \ge q$ 的询问的答案增加 $\sum_{p=l}^{r}A_p \times B_p$。

因此，每一个询问的答案是 $r = q$ 时 $\sum_{p=l}^{r}A_p \times B_p$ 的历史版本和。

---

以下讲解如何维护区间历史版本和。

对于普通的区间历史版本和，2016 年集训队论文中有介绍。
![](https://cdn.luogu.com.cn/upload/image_hosting/khxm4021.png)

类比着做，令 $S_i = A_i \times B_i$，设 $Ans_i$ 为历史版本和，同时我们让 $gt$ 为当前结束的时间（二者均不包含当前操作）。同样，定义 $C_i$，每一时刻结束都让 $C_i = Ans_i - gt \cdot S_i$。

令 $x'$ 表示修改前的 $x$ 信息，$\Delta x$ 表示修改前后 $x$ 的变化量。

$$\begin{aligned}\Delta C_i
&= \Delta Ans_i - \Delta(gt \cdot S_i) \\ 
&= \Delta gt \cdot S_i' - (gt' + \Delta gt)\cdot(S_i' + \Delta S_i) + gt' \cdot S_i' \\ 
&= -\Delta gt \cdot \Delta S_i -gt' \cdot \Delta S_i \\ 
&= -(gt' + \Delta gt) \cdot \Delta S_i \\ 
&= -gt \cdot \Delta S_i
\end{aligned}$$

维护线段树标记逻辑很麻烦，我们考虑借助矩阵理解。

先确定状态矩阵（行向量）如下：

$$\begin{bmatrix} \sum S_i & \sum A_i & \sum B_i & len & \sum C_i\end{bmatrix}$$

其中 $len$ 为当前区间的长度。  
可得转移矩阵：

$$\begin{bmatrix}
[a=b=0] & 0 & 0 & 0 & c \\ 
[a=0]b & [a=0] & 0 & 0 & ca \\ 
[b=0]a & 0 & [b=0] & 0 & cb \\ 
a \cdot b & a & b & 1 & cl \\ 
0 & 0 & 0 & 0 & 1
\end{bmatrix}$$

其中 $a$ 非零时表示将区间中所有 $A_i$ 赋值为 $a$，$b$ 同理，$c, ca, cb, cl$ 仅供计算。  
该矩阵中左上 $4 \times 4$ 的部分和 $52$ pts 的标记是等价的，结合实际意义维护即可，而 $\sum C_i$ 我们选择用矩阵维护。

这里是我对该标记的实现：

```cpp
struct Tag {
	ull a, b;
	ull c, ca, cb, cl;
	inline bool empty() const {
		return !(a || b || c || ca || cb || cl);
	}
	inline void clear() {
		a = b = 0;
		c = ca = cb = cl = 0;
	}
	inline void add(const Tag &t) {
		if (this->empty()) return (void) (*this = t);
		// matrix 1
		const ull a1s = a ? 0 : b, b1s = b ? 0 : a;
		const ull a1a = a ? 0 : 1, b1b = b ? 0 : 1;
		const ull l1s = a*b, l1a = a, l1b = b;
		const ull s1c = c, a1c = ca, b1c = cb, l1c = cl;
		// matrix 2
		const ull s2c = t.c, a2c = t.ca, b2c = t.cb, l2c = t.cl;
		// matrix result
		const ull sc =                                       s1c*1;
		const ull ac = a1s*s2c + a1a*a2c                   + a1c*1;
		const ull bc = b1s*s2c           + b1b*b2c         + b1c*1;
		const ull lc = l1s*s2c + l1a*a2c + l1b*b2c + 1*l2c + l1c*1;
		// assign
		c = sc, ca = ac, cb = bc, cl = lc;
		if (t.a) a = t.a;
		if (t.b) b = t.b;
	}
};
```

其中 `add` 方法为合并两个标记（转移矩阵）。  
P.S. `add` 方法的代码复杂程度较高，建议以可读性为重点，相信现代编译器是完全能够优化这简单的逻辑的。


将标记应用于线段树上的节点：

```cpp
struct Node {
	ull s, sa, sb, c;
	Tag tag;
} tree[N*4+10];

inline void set_val(int p, int l, int r, const Tag &tag) {
	Node &self = tree[p];
	const ull len = r - l + 1;
	const ull s = self.s, sa = self.sa, sb = self.sb;
	if (tag.a && tag.b) {
		self.s = tag.a * tag.b * len;
		self.sa = tag.a * len;
		self.sb = tag.b * len;
	} else if (tag.a) {
		self.s = tag.a * sb;
		self.sa = tag.a * len;
	} else if (tag.b) {
		self.s = tag.b * sa;
		self.sb = tag.b * len;
	}
	self.c += tag.c * s + tag.ca * sa + tag.cb * sb + tag.cl * len;
	self.tag.add(tag);
	// if (l < r) push_down(p, l, r);
	// tree[p].tag = tag;
}
```

P.S. 这里有个调试的小技巧，因为合并两个标记很难调试，所以调试时通过再次下传标记避免合并，从而方便其它部分的调试。不过这会导致线段树时间复杂度 $O(n^2)$，但调试时可以接受。

当我们把一段区间的 $A_i$ 赋值为 $v$ 时，以上矩阵 $a = v, b = 0$。  
$\sum C_i$ 可由 $\Delta C_i = -gt \cdot \Delta S_i$ 推导，得到 $c = gt, ca = 0, cb = -v \cdot gt, cl = 0$。

同理得把 $B_i$ 赋值为 $v$ 时，$a = 0, b = v, c = gt, ca = -v \cdot gt, cb = 0, cl = 0$。

所以扩展右边界时的代码如下：

```cpp
++cntR; // 扩展右边界
ull a = arr[cntR].val, b = brr[cntR].val, gt = cntR;
update(1, 1, n, arr[cntR].pre + 1, cntR, Tag { a, 0, gt, 0, -gt*a, 0 });
update(1, 1, n, brr[cntR].pre + 1, cntR, Tag { 0, b, gt, -gt*b, 0, 0 });
```

对于查询，注意 $Ans_i$ 是不包含当前操作的，所以查询的答案为 $\sum_{i=l}^{r} C_i + (gt + 1) \cdot S_i$。

总时间复杂度 $O(n \log n)$，预期 100 pts。

[完整代码](https://www.luogu.com.cn/paste/fm6c7wd4)。




---

## 作者：_ANIG_ (赞：21)

## 暴力（8pts）
显然，暴力可以直接使用 ST 表，每个询问直接暴力枚举，复杂度 $O(qn^2)$，期望得分：$8$。

## 莫队（52pts）

看到区间操作可以使用莫队。先看添加操作。例如：从区间 $[a,b]$ 转移到区间 $[a,b+1]$。

显然，此时多出来的区间是 $[a,b+1],[a+1,b+1],[a+2,b+1],···,[b+1,b+1]$。

把这些区间直接取最值，复杂度是 $O(n^2\sqrt n)$，还是很高。考虑优化转移的过程。思考转移时，哪个区间的最值会改变。显然，只需要找到 $b+1$ 左边第一个比这个数大的位置 $k$，那么 $[k+1$~$b+1,b+1]$ 这些区间的最大值都是 $b+1$，其他区间则不变。而转移需要求 $[a$~$b+1,b+1]$ 的和。定义两个数组 $m,n$，$m_i$ 表示 $A_{[i,b+1]}$ 的最大值，$n_i$ 表示 $B_{[i,b+1]}$ 的最大值。转移就可以转化成：

1. 将区间 $m_{[k+1,b+1]}$ 的值更改为 $A_{b+1}$。将区间 $n_{[k+1,b+1]}$ 的值更改为 $B_{b+1}$。

2. 求区间 $[a,b],m_i×n_i$ 的和。

其中，$A,B$ 分别表示初始的两个数组。

直接线段树维护即可，求 $k$ 可以用单调栈。复杂度 $O(n\sqrt n\log n)$。（本蒟蒻止步于此）

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int unsigned long long
struct nodes{
	int l,r,sets1,sets2,sum1,sum2,sum3;
};
struct tr{
	nodes p[1000005];
	void upset(int x){
		p[x].sum1=p[x<<1].sum1+p[x<<1|1].sum1;
		p[x].sum2=p[x<<1].sum2+p[x<<1|1].sum2;
		p[x].sum3=p[x<<1].sum3+p[x<<1|1].sum3;
	}
	void setss1(int x,int sum){
		p[x].sets1=sum;
		p[x].sum1=sum*(p[x].r-p[x].l+1);
		p[x].sum3=p[x].sum2*sum;
	}
	void setss2(int x,int sum){
		p[x].sets2=sum;
		p[x].sum2=sum*(p[x].r-p[x].l+1);
		p[x].sum3=p[x].sum1*sum;
	}
	void dnset(int x){
		if(p[x].sets1){
			setss1(x<<1,p[x].sets1);
			setss1(x<<1|1,p[x].sets1);
			p[x].sets1=0;
		}
		if(p[x].sets2){
			setss2(x<<1,p[x].sets2);
			setss2(x<<1|1,p[x].sets2);
			p[x].sets2=0;
		}
	}
	void reset(int x,int l,int r){
		p[x].l=l,p[x].r=r;p[x].sum1=p[x].sum2=p[x].sum3=p[x].sets1=p[x].sets2=0;
		if(l==r)return;
		int mid=l+r>>1;
		reset(x<<1,l,mid);
		reset(x<<1|1,mid+1,r); 
	} 
	void sets(int x,int l,int r,int sum,int lx){ 
		if(l<=p[x].l&&r>=p[x].r){
			if(lx==1){
				setss1(x,sum);
				return;
			}else{
				setss2(x,sum);
				return;
			}
		}
		int mid=p[x].l+p[x].r>>1;
		dnset(x);
		if(l<=mid)sets(x<<1,l,r,sum,lx);
		if(r>mid)sets(x<<1|1,l,r,sum,lx);
		upset(x);
	}
	int gets(int x,int l,int r,int lx){
		if(l<=p[x].l&&r>=p[x].r){
			if(lx==1)return p[x].sum1;
			if(lx==2)return p[x].sum2;
			if(lx==3)return p[x].sum3;
		}
		dnset(x);
		int mid=p[x].l+p[x].r>>1,res=0;
		if(l<=mid)res+=gets(x<<1,l,r,lx);
		if(r>mid)res+=gets(x<<1|1,l,r,lx);
		upset(x);
		return res;
	}
}p1,p2,p3;
int t,n,a[250005],b[250005],bh[250005],T,rr1,rr2,q,st[250005],ed[250005],f1[250005][25],f2[250005][25],lg2[250005],res,l1[250005],l2[250005],r1[250005],r2[250005],r[250005];
struct node{
	int l,r,bhs;
	friend bool operator<(node a,node b){
		if(bh[a.l]==bh[b.l])return a.r<b.r;
		return a.l<b.l;
	}
}p[250005];
stack<int>q1,q2;
int gets(int l,int r,int rr){
	if(l>r)return res;
	int ans=res;
	for(int i=1;i<=3*n;i++)p2.p[i]=p3.p[i];
	for(int i=r;i>=l;i--){
		int t1=r1[i],t2=r2[i];
	//	cout<<i<<" "<<t1<<" "<<t2<<" "<<rr<<endl;
		if(t1<=rr)p2.sets(1,i,t1-1,a[i],1);
		else p2.sets(1,i,rr,a[i],1);
		if(t2<=rr)p2.sets(1,i,t2-1,b[i],2);
		else p2.sets(1,i,rr,b[i],2);
		ans+=p2.gets(1,i,rr,3);
	}
	return ans;
}
signed main(){
	for(int i=1;i<=250000;i++)lg2[i]=log2(i);
	cin>>t>>n;
	T=sqrt(n);
	for(int i=1;i<=n;i++)scanf("%lld",&a[i]);
	for(int i=1;i<=n;i++)scanf("%lld",&b[i]);
	a[0]=1e9,b[0]=1e9;
	q1.push(0);q2.push(0);
	for(int i=1;i<=n;i++){
		while(q1.size()&&a[q1.top()]<=a[i])q1.pop();
		while(q2.size()&&b[q2.top()]<=b[i])q2.pop();
		l1[i]=q1.top();l2[i]=q2.top();
		q1.push(i);q2.push(i);
	}
	while(q1.size())q1.pop();while(q2.size())q2.pop();
	a[n+1]=1e9,b[n+1]=1e9;
	q1.push(n+1);q2.push(n+1);
	for(int i=n;i>=1;i--){
		while(q1.size()&&a[q1.top()]<=a[i])q1.pop();
		while(q2.size()&&b[q2.top()]<=b[i])q2.pop();
		r1[i]=q1.top();r2[i]=q2.top();
		q1.push(i);q2.push(i);
	}
	for(int i=1;i<=n;i++)bh[i]=(i-1)/T+1; 
	for(int i=1;i<=1000;i++)st[i]=ed[i-1]+1,ed[i]=i*T;
	cin>>q;
	for(int i=1;i<=q;i++){
		int l,r;
		scanf("%lld%lld",&l,&r);
		p[i]=(node){l,r,i};
	}
	sort(p+1,p+q+1);
	for(int i=1;i<=q;i++){
		if(bh[p[i].l]!=bh[p[i-1].l]){
			p1.reset(1,1,n);
			p3.reset(1,1,n);
			res=0;rr1=rr2=0;
			for(int j=ed[bh[p[i].l]];j<=p[i].r;j++){
				int t1=l1[j],t2=l2[j];
				if(t1>=ed[bh[p[i].l]])p1.sets(1,t1+1,j,a[j],1);
				else p1.sets(1,ed[bh[p[i].l]],j,a[j],1);
				if(t2>=ed[bh[p[i].l]])p1.sets(1,t2+1,j,b[j],2);
				else p1.sets(1,ed[bh[p[i].l]],j,b[j],2);
				res+=p1.gets(1,ed[bh[p[i].l]],j,3);
				rr1=max(rr1,a[j]);rr2=max(rr2,b[j]);
				p3.sets(1,j,j,rr1,1);p3.sets(1,j,j,rr2,2);
			}
			r[p[i].bhs]=gets(p[i].l,min(p[i].r,ed[bh[p[i].l]]-1),p[i].r);
			continue;
		}
		for(int j=max(p[i-1].r+1,ed[bh[p[i].l]]);j<=p[i].r;j++){
			int t1=l1[j],t2=l2[j];
		    if(t1>=ed[bh[p[i].l]])p1.sets(1,t1+1,j,a[j],1);
			else p1.sets(1,ed[bh[p[i].l]],j,a[j],1);
			if(t2>=ed[bh[p[i].l]])p1.sets(1,t2+1,j,b[j],2);
			else p1.sets(1,ed[bh[p[i].l]],j,b[j],2);
			res+=p1.gets(1,ed[bh[p[i].l]],j,3);
			rr1=max(rr1,a[j]);rr2=max(rr2,b[j]);
			p3.sets(1,j,j,rr1,1);p3.sets(1,j,j,rr2,2);
		}
		r[p[i].bhs]=gets(p[i].l,min(p[i].r,ed[bh[p[i].l]]-1),p[i].r);
	}
	for(int i=1;i<=q;i++)cout<<r[i]<<endl;
}
```


## 分块（100pts）

将询问按右端点排序。定义两个数组 $m,n$。

用 $i$ 遍历 $1-n$。

$m_j$ 表示 $A_{[j,i]}$ 的最大值，$n_j$ 表示 $B_{[j,i]}$ 的最大值。

$r_j$ 表示区间 $[j,i]$ 的答案。当 $i$ 加 $1$ 时，对于所有的 $k$，都需要让 $r_k$ 加上 $m_k×n_k$。求答案的时候就需要求 $r_{[a,b]}$ 的和。

也就是问题转化成了：

有三个数组 $m,n,r$。

需要维护三种操作：

- 数组 $m,n$ 区间赋值。

- 数组 $r$，对于区间内的每个 $k$，都让 $r_k$ 加上 $m_k×n_k$。

- 求数组 $r$ 区间和。

分块，比较难的是整块修改。可以分类讨论。对于这一块的值是否相同进行分类讨论即可，详细做法看代码。复杂度 $O(n\sqrt n)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int unsigned long long
int t,n,a[250005],b[250005],rr1,rr2,q,jl1[250005],jl3[250005],l1[250005],jl[250005],jl2[250005],sm6[250005],bh[250005],l2[250005],r1[250005],r[250005],p1[250005],sm5[250005],p2[250005],st1[250005],st2[250005],T,sm4[250005],st[250005],ed[250005],sn,sm21[250005],sm11[250005],sm3[250005];
struct node{
	int l,r,bhs;
	friend bool operator<(node a,node b){
		return a.r<b.r;
	}
}p[250005];
stack<int>q1,q2;
void gx(int u){
	if(jl1[u]||jl2[u]||jl[u]||jl3[u]){
		for(int i=st[u];i<=ed[u];i++){
			sm4[i]+=jl[u]*p1[i]*p2[i]+jl1[u]*p2[i]+jl2[u]*p1[i]+jl3[u];
		}
		jl[u]=0;jl1[u]=0;jl2[u]=0;jl3[u]=0;
	}
	if(st1[u]){
		for(int i=st[u];i<=ed[u];i++)p1[i]=st1[u];
		st1[u]=0;
	}
	if(st2[u]){
		for(int i=st[u];i<=ed[u];i++)p2[i]=st2[u];
		st2[u]=0;
	}
}
void setss(int l,int r,int sum,int lx){
	int u=bh[l];
	gx(u);
	for(int i=st[u];i<=ed[u];i++)sm3[u]-=p1[i]*p2[i];
	if(lx==1){
		for(int i=l;i<=r;i++)p1[i]=sum;
		sm11[u]=0;
		for(int i=st[u];i<=ed[u];i++)sm11[u]+=p1[i];
    }else{
		for(int i=l;i<=r;i++)p2[i]=sum;
		sm21[u]=0;
		for(int i=st[u];i<=ed[u];i++)sm21[u]+=p2[i];
	}
	for(int i=st[u];i<=ed[u];i++)sm3[u]+=p1[i]*p2[i];
}
void sets(int l,int r,int sum,int lx){
	if(bh[l]==bh[r]){
		setss(l,r,sum,lx);
		return;
	}
	int ll=bh[l]+1,rr=bh[r]-1;
	for(int i=ll;i<=rr;i++){
		if(lx==1){
			st1[i]=sum;
			sm3[i]=sum*sm21[i];
			sm11[i]=sum*T;
		}else{
			st2[i]=sum;
			sm3[i]=sum*sm11[i];
			sm21[i]=sum*T;
		}
	}
	setss(l,st[ll]-1,sum,lx);setss(ed[rr]+1,r,sum,lx);
}
void ads(int l,int r){
	gx(bh[l]);
	for(int i=l;i<=r;i++){
		sm4[i]+=p1[i]*p2[i];
	}
	sm5[bh[l]]=0;
	for(int i=st[bh[l]];i<=ed[bh[l]];i++)sm5[bh[l]]+=sm4[i];
}
void adds(int l,int r){
	if(bh[l]==bh[r]){
		ads(l,r);
		return;
	}
	int ll=bh[l]+1,rr=bh[r]-1;
	for(int i=ll;i<=rr;i++){
		if(st1[i]&&st2[i]){
			jl3[i]+=st1[i]*st2[i];
			sm5[i]+=st1[i]*st2[i]*T;
		}else if(st1[i]==0&&st2[i]==0){
			sm5[i]+=sm3[i];
			jl[i]++;
		}else if(st1[i]){
			sm5[i]+=sm21[i]*st1[i];
			jl1[i]+=st1[i];
		}else{
			sm5[i]+=sm11[i]*st2[i];
			jl2[i]+=st2[i];
		}
	}
	ads(l,st[ll]-1);ads(ed[rr]+1,r);
}
int getss(int l,int r){
	int res=0,u=bh[l];
	for(int i=l;i<=r;i++){
		res+=sm4[i]+jl[u]*p1[i]*p2[i]+jl1[u]*p2[i]+jl2[u]*p1[i]+jl3[u];
	}
	return res;
}
int gets(int l,int r){
	if(bh[l]==bh[r])return getss(l,r);
	int res=0,ll=bh[l]+1,rr=bh[r]-1;
	for(int i=ll;i<=rr;i++){
		res+=sm5[i];
	}
	return res+getss(l,st[ll]-1)+getss(ed[rr]+1,r);
}
signed main(){
	cin>>t>>n;
	T=300;
	sn=(n-1)/T+1;
	for(int i=1;i<=n;i++)bh[i]=(i-1)/T+1;
	for(int i=1;i<=sn;i++)st[i]=ed[i-1]+1,ed[i]=i*T;
	for(int i=1;i<=n;i++)scanf("%lld",&a[i]);
	for(int i=1;i<=n;i++)scanf("%lld",&b[i]);
	a[0]=1e9,b[0]=1e9;
	q1.push(0);q2.push(0);
	for(int i=1;i<=n;i++){
		while(q1.size()&&a[q1.top()]<=a[i])q1.pop();
		while(q2.size()&&b[q2.top()]<=b[i])q2.pop();
		l1[i]=q1.top();l2[i]=q2.top();
		q1.push(i);q2.push(i);
	}
	cin>>q;
	for(int i=1;i<=q;i++){
		int l,r;
		scanf("%lld%lld",&l,&r);
		p[i]=(node){l,r,i};
	}
	sort(p+1,p+q+1);
	for(int i=1;i<=q;i++){
		for(int j=p[i-1].r+1;j<=p[i].r;j++){
			int t1=l1[j],t2=l2[j];
			sets(t1+1,j,a[j],1);
			sets(t2+1,j,b[j],2);
			adds(1,j);
		}
		r[p[i].bhs]=gets(p[i].l,p[i].r);
	}
	for(int i=1;i<=q;i++)cout<<r[i]<<endl;
}
```


---

## 作者：NGC5457 (赞：19)

[可能更好的阅读体验](https://charleswu.site/archives/2455)

**[洛谷题库 P8868 [NOIP2022] 比赛](https://www.luogu.com.cn/problem/P8868)**

本文记号可能稍显凌乱，但都能在题面或者前文中找到定义。
## 部分分
### $\text{20 pts}$ - $n,Q\leq 3000$
考虑枚举所有 $\operatorname{O}(n^2)$ 个区间，预先计算它们本身的答案。记
$$\begin{aligned}g_a(l,r)&=\begin{cases}\max\{a_i\mid l\leq i\leq r\},&(1\leq l\leq r\leq n)\\0&\text{otherwise}\end{cases}\\g_b(l,r)&=\begin{cases}\max\{b_i\mid l\leq i\leq r\},&(1\leq l\leq r\leq n)\\0&\text{otherwise}\end{cases}\end{aligned}$$
则做前缀和 $s(l,r)=\sum_{i=l}^{r}g_a(l,i)g_b(l,i)$，对于询问 $[\text{ql},\text{qr}]$ 只需回答 $\sum_{i=\text{ql}}^{\text{qr}}s(i,\text{qr})$ 即可。

令 $n, Q$ 同阶，时空复杂度 $\operatorname{O}(n^2)$。
### $\text{32 pts}$ - $n\leq 2.5\times 10^5, Q\leq 5$
思考单独计算每个询问的答案。

设 $\operatorname{lbd}(i)$ 满足 $(\operatorname{lbd}(i)=1\lor a_{\operatorname{lbd}(i)-1}>a_i)\land \max\{a_j\mid \operatorname{lbd}(i)\leq j<i\}<a_i$，也即 $g_a(l,r)=\max\{a_j\mid l\leq j\leq r\}=a_i$，应满足 $\operatorname{lbd}(i)\leq l\leq i$；$\operatorname{rbd}(i)$ 同理。它们可以由前后两遍单调栈 $\operatorname{O}(n)$ 求出。

对于询问 $[\text{ql},\text{qr}]$，*从 $a$ 的角度出发考虑贡献*。记
$$f_b(p,i,j,q)=\sum_{l=p}^{i}\sum_{r=j}^{q} g_b(l,r)\quad(p\leq i\land j\leq q)$$
若对于所有 $i\in[\text{ql},\text{qr}]$，我们能求出 $f_b(\max(\operatorname{lbd}(i),\text{ql}),i,i,\min(\operatorname{rbd}(i),\text{qr}))$，那么将其乘上 $a_i$ 累加到答案中。

设想一个矩阵 $\mathbf{B}$，有 $\mathbf{B}_{l,r}=g_b(l,r)$，则现在我们有 $\text{qr}-\text{ql}+1$ 个上述询问，要求出矩阵区域和。

如果我们只计算一列中连续几行元素的和，它是一个经典扫描线问题：借助**单调栈**和**区间加线段树**，我们能轻松维护“在 $r$ 分别为 $1,2,\cdots,n$ 时，任意 $l\ (l\leq r)$ 的 $g_b(l,r)$”。更具体地，我们维护一个 $b$ 的最大值单调栈，并从小到大枚举 $r$。记现在单调栈保存的下标为 $t_1,t_2,\cdots,t_k$，令 $t_0=0$，满足 $\forall i \in [1, k),b_{t_i}>b_{t_{i+1}}$。我们试图将 $r$ 压入栈中，考虑 $g_b(l,r-1)$ 怎样变化到 $g_b(l,r)$。当我们弹出 $t_i$ 时，显然有 $\forall l\in(t_{i-1},t_i],g_b(l,r-1)=b_{t_i},g_b(l,r)=b_r\Rightarrow g_b(l,r)-g_b(l,r-1)=b_r-b_{t_i}$。于是在弹出过程中，在线段树上对区间 $(t_{i-1},t_i]$ 中每个元素加上 $b_r-b_{t_i}$，即可维护 $r$ 时的 $g_b(l,r)$；自然，如果 $l$ 在弹出过程中未被波及，则 $g_b(l,r)=g(l,r-1)$。（最后单点更新 $g_b(r,r)=b_r$）

但我们要计算的是若干连续列的和。先利用前缀和简化：有 $f_b(p,i,j,q)=f_b(p,i,1,q)-f_b(p,i,1,j-1)$。$f_b(p,i,1,q)$ 即上述过程中线段树上区间 $[p,i]$ 内元素前 $q$ 轮的***历史版本和***。不妨考虑上述过程中***每一次的增量***在最终答案中的贡献。容易发现，如果在 $r$ 处执行了某次区间加操作，增量为 $\Delta$，且下标 $l$ 在该区间内，那么它对所有 $g_b(l,r')\ \ (r'\geq r)$ 都有 $\Delta$ 的线性贡献，于是对 $f_b(p,i,1,q)\ \ (q\geq r,l\in[p,i])$ 的贡献为 $(q-r+1)\Delta={\color{blue}q\Delta}-{\color{red}(r-1)\Delta}$。易得位置 $l$ 在前 $r$ 轮累加的所有 $\Delta$ 就是 $g_a(l,r)$；而 $r,\Delta$ 只与区间加操作相关，$q$ 只与查询相关，故而我们开设另一棵线段树，维护所有 $-(r-1)\Delta$ 的区间和即可计算上述式子。

![](https://charleswu.site/wp-content/uploads/2022/11/noip_t4_partial_52pts_figure.png)

时间复杂度 $\operatorname{O}(Qn\log n)$。可以将上文中对每个询问构造的 $f_b$ 查询全部记录后，只执行一遍扫描线求出答案，最后统一回答，常数更小。

[**赛时代码**](https://www.luogu.com.cn/paste/0wmpvuvr)（$\text{52 pts}$）
### $\text{32 pts}$ - $a$ 是等概率随机生成的排列
CWOI 好像只有 hfy 赛场上写了该部分分。~~不过他的线段树被卡常了，怪出题人只给了 $\text{2s}$。~~
#### 引理
> 在 $n!$ 个全排列中等概率随机选择一个排列 $p$，$p$ 所构建的**笛卡尔树**的树高期望是 $\operatorname{O}(\log n)$ 的。

#### [证明](http://www.cs.cmu.edu/afs/cs/academic/class/15210-s12/www/lectures/lecture16.pdf)

我们试图找到一个复杂度只跟 $a$ 强相关的算法，以充分利用这一性质。

不难发现，假如有 $\operatorname{lbd}(i)\geq \text{ql}\land \operatorname{rbd}(i)\leq \text{qr}$，那么我们总是可以直接累加 $a_if_b(\operatorname{lbd}(i),i,i,\operatorname{rbd}(i))$ 到答案中，不用考虑询问给定的限制。则我们可以用上文所述方法在 $\operatorname{O}(n\log n)$ 时间内求出 $a_if_b(\operatorname{lbd}(i),i,i,\operatorname{rbd}(i))\ \ (i=1,2,\cdots,n)$。

考虑*在 $a$ 随机的情况下*，有多少位置 $i$ 不能采用上式结果，而须考虑 $\text{ql},\text{qr}$ 的影响。显然，若 $a_{\text{mx}}=g_a(\text{ql},\text{qr})$，则位置 $\text{mx}$ 的答案可能要重新计算——必有 $\operatorname{lbd}(\text{mx})\leq \text{ql}\land \operatorname{rbd}(\text{mx})\geq \text{qr}$（否则和它是区间最值的条件相悖）。

考虑不断从区间最值位置向两侧迭代，也即
$$\begin{aligned}&\begin{cases}\operatorname{lmx}_k=\text{mx},& (k=0)\\a_{\operatorname{lmx}_k}=g_a(\text{ql},\operatorname{lmx}_{k-1}-1),& (\operatorname{lmx}_{k-1}>\text{ql})\\\operatorname{lmx}_k\text{\ is undefined}&\text{otherwise}\end{cases}\\&\begin{cases}\operatorname{rmx}_k=\text{mx},& (k=0)\\a_{\operatorname{rmx}_k}=g_a(\operatorname{rmx}_{k-1}+1,\text{qr}),& (\operatorname{rmx}_{k-1}<\text{qr})\\\operatorname{rmx}_k\ \text{is undefined}&\text{otherwise}\end{cases}\end{aligned}$$
则不难说明有且仅有 $\operatorname{lmx}_k,\operatorname{rmx}_k\ \ (k=0,1,\cdots)$ 这些位置需要重新计算答案——其他所有位置 $i$ 的 $\operatorname{lbd}(i),\operatorname{rbd}(i)$ 最多延伸到（向左）$\operatorname{lmx}_k+1$ 或者（向右） $\operatorname{rmx}_k-1$，可以直接采纳预处理答案。

由于均有 $\operatorname{lmx}_k$ 是 $\operatorname{lmx}_{k-1}$ 在笛卡尔树上的子树元素（$\operatorname{rmx}$ 同理），且树高为 $\operatorname{O}(\log n)$ 的，故而暴力重算的复杂度得到保障。我们用 **ST 表**找到 $\operatorname{lmx}_k$ 和 $\operatorname{rmx}_k$，将 $\operatorname{O}(Q\log n)$ 个询问挂载到对应右端点，最后统一做一遍上文所述的扫描线，复杂度为 $\operatorname{O}(Q\log^2 n+n\log n)$。

需要使用**区间加区间求和树状数组**优化常数才能通过，或者尝试用 $\operatorname{O}(\sqrt{n})$ 修改 $\operatorname{O}(1)$ 查询的块状数据结构平衡复杂度。（实际上本解法可以直接通过上一部分分。）

**[代码](https://www.luogu.com.cn/paste/cnzhbyjj)**（$\text{84 pts}$）

## 正解（线段树）
~~当然了，我们有更简洁易写的分块做法。您可以移步别的题解。~~

我觉得出题人完全可以再给一组部分分：$\sum \text{qr}-\text{ql}+1\leq ?\times 10^5$。

设想矩阵 $\mathbf{F}$，满足 $\mathbf{F}_{i,j}=g_a(i,j)g_b(i,j)$。记
$$f(p,i,j,q)=\sum_{l=p}^{i}\sum_{r=j}^{q}\mathbf{F}_{l,r}=\sum_{l=p}^{i}\sum_{r=j}^{q}g_a(l,r)g_b(l,r)$$
则题目所给询问，等价于问左上角为 $(\text{ql},\text{ql})$，右下角为 $(\text{qr},\text{qr})$ 的子矩阵元素之和。又因为有 $\forall l,r, n\geq l>r\geq 1,\mathbf{F}_{l,r}=0$，则我们把左上角变成 $(\text{ql},1)$，不影响结果。于是就变成了求 $f(\text{ql},\text{qr},1,\text{qr})$。

我们尝试对于 $r=1,2,\cdots,n$，直接维护每个 $l$ 的 $g_a(l,r)g_b(l,r)$，同时维护 $a,b$ 两序列的最大值单调栈。由于二者可能在第 $r$ 轮内先后更新，故为行文方便，下文中 ***将用 $g_a(l)$ 直接代指目前线段树上维护的 $g_a(l,r)$*** ，$g_a(l)'$ 则是相对于目前发生了改变的值；$g_b(l)$ 同理。

则在更新 $a$ 的单调栈时，在某个位置 $l$ 产生的增量 $\Delta_a=g_a(l)'-g_a(l)$ 将会导致 $l$ 的答案从 $g_a(l)g_b(l)$ 变成 $(g_a(l)+\Delta_a)g_b(l)$；更新 $b$ 的单调栈时同理。则若我们在线段树上每个节点维护子区间的 $g_a(l)$ 之和，$g_b(l)$ 之和以及 $g_a(l)g_b(l)$ 之和，现在每个位置产生增量 $\Delta_a,\Delta_b$，有 
$$\begin{aligned}
\sum_{l}g_a(l)'g_b(l)'&=\sum_{l}(g_a(l)+\Delta_a)(g_b(l)+\Delta_b)\\&=\left(\sum_{l}g_a(l)g_b(l)\right)+\left(\sum_{l}g_a(l)\right)\Delta_b+\left(\sum_{l}g_b(l)\right)\Delta_a+\sum_{l}\Delta_a\Delta_b\end{aligned}$$

$\Delta_a,\Delta_b$ 均导致线性贡献，显然满足结合律。于是用带 $\Delta_a,\Delta_b$ **延迟标记**的线段树维护，就能在 $\operatorname{O}(\log n)$ 的时间内，在右端点扫描到 $r$ 时，查询 $g_a(l,r)g_b(l,r)$ 的区间和。

现在回顾部分分 $\operatorname{O}(n\log n)$ 处理单个查询的解法。我们分离了每一次的增量造成的贡献，并在最终线性累加回去。实际上对于上述更复杂的贡献，也能如法炮制：同样有 $f(p,i,1,q)$ 是线段树上的区间历史版本和。仍考虑 $g_a(l)g_b(l)$ 怎样变化到 $g_a(l)'g_b(l)'$。扫描到 $r$ 处更新 $a$ 的单调栈时，若在位置 $l$ 产生增量 $\Delta_a$，则对于 $q\geq r$ 的所有版本，$g_a(l,q)g_b(l,q)$ 都包含增量 $\Delta_ag_b(l)$。那么，对于某个查询 $f(p,i,1,q)\ \ (l\in[p,i],q\geq r)$，该次更新的增量造成的总贡献为 $\Delta_ag_b(l)(q-r+1)$，拆分成 ${\color{blue}\Delta_ag_b(l)}q-{\color{red}\Delta_a(r-1)g_b(l)}$。$b$ 的更新同理：${\color{blue}\Delta_bg_a(l)}q-{\color{red}\Delta_b(r-1)g_a(l)}$。

不难验证，对于一个确定的 $l$，在所有 $r\ \ (r\leq q)$ 处的两个蓝字部分贡献之和仍恰等于 $g_a(l,q)g_b(l,q)$，直接依照上文在线段树上维护区间和即可。现在着重考虑红字的求和。

我们尝试对于每个位置 $l$ 维护 $h(l)$，表示 ***扫描线扫到 $r$ 时位置 $l$ 的红字贡献之和***。
#### 引理 $1$
> 对于一棵未采用标记永久化的线段树，某个叶子结点到根的路径上，未下放延迟标记的节点是以叶子为首的一个非空前缀。
#### 引理 $2$
> **记上文中“只维护第 $r$ 轮的 $g_a(l,r)g_b(l,r)$ 区间和”线段树上，节点 $x$ 的延迟标记为 $\Delta_{a,x},\Delta_{b,x}$**。设线段树上管辖 $g_a(l)g_b(l)$ 的叶子结点为 $x_1$，它和若干祖先构成的链为 $x_1,x_2,\cdots,x_k$，$x_k$ 为某次操作递归访问的终止节点（此即引理 $1$ 中的**前缀**）。则任一时刻，$g_a(l)$ 的真实值等于 $\sum_{i=1}^k\Delta_{a,x_i}$，而 $x_i$ 采用的“$g_a(l)$”实际上是 $\sum_{j=1}^{i}\Delta_{a,x_j}$；$g_b(l)$ 之于 $\Delta_{b,x}$ 亦然。

这两条引理都是很容易验证的。

![](https://charleswu.site/wp-content/uploads/2022/12/noip_t4_sol_figure.png)

考虑怎样维护 $h(l)$ 的区间和。假若扫描线扫描到第 $r$ 轮，我们更新了 $b$ 的单调栈，使得一段区间的 $h(l)'=h(l)+\Delta_b(r-1)g_a(l)$。则将当前 $g_a(l)$ 的值记作 $c_a$，它的贡献仍然是线性的：访问线段树某一节点时，由于其所有祖先的延迟标记都已下放，我们获得的正是 $g_a(l)$ 的真实值。故可以立刻更新节点 $x_k$ 的
$$\sum_{l}h(l)'=\left(\sum_{l}h(l)\right)+\Delta_b(r-1)\sum_{l}g_a(l)$$

此后该区间可能经过了若干次更新，维护的 $g_a(l)$ 和 $\Delta_{a,x}$ *可能发生变化*，但那一次修改所采用的的 $c_a$ 是不变的（参见上图）。为了保证下放后 $h(l)$ 增量的一致性，我们将 $c_a$ 拆分成 ${\color{red}\Delta_{a,x_k}}+{\color{blue}\sum_{i=1}^{k-1}\Delta_{a,x_i}}$，$h(l)$ 的增量变成
$$c_a\Delta_b(r-1)={\color{red}\Delta_{a,x_k}}\Delta_b(r-1)+{\color{blue}\sum_{i=1}^{k-1}\Delta_{a,x_i}}\Delta_b(r-1)$$

如上图所示，蓝字就是 $x_{k-1}$ 所维护的“$g_a(l)$”，它在把标记 $\Delta_{a,x_k}$ 下放到 $x_{k-1}$ 前*保持不变*，我们将其加以利用。故而下放时，依次作如下更新：令延迟标记 $\Delta_{\beta,x}$ 为 ***应用到 $x$ 上且还未下放的 $\Delta_b(r-1)$ 之和***（$\Delta_{\alpha,x}$ 是 $\Delta_a(r-1)$ 之和）；有 $x_{k-1}$ 维护的
$$\sum_{l}h(l)'=\left(\sum_{l}h(l)\right)+\Delta_{\beta,x_k}\left(\sum_l{\color{blue}g_a(l)}\right)+\Delta_{\alpha,x_k}\left(\sum_l{g_b(l)}\right)$$
（$\sum_lg_a(l),\sum_lg_b(l)$ 暂未更新）；对于红字，我们在对 $x_k$ 作修改时即立刻保存 $\Delta_b(r-1){\color{red}\Delta_{a,x_k}}$，将其累加到另一延迟标记中，记作 $\Delta_{\text{co},x_k}$；下放时即有
$$\sum_{l}h(l)'=\left(\sum_{l}h(l)\right)+\left(\sum_{l}\Delta_{\text{co},x_k}\right)$$
（注意到红字累加的是常系数，与来自于对 $a$ 还是对 $b$ 的修改无关，故而 $a$ 的修改共用 $\Delta_{\text{co},x_k}$）

$\Delta_{\beta,x_k},\Delta_{\alpha,x_k}$ 的下放更新是简单的，将它直接累加到 $\Delta_{\beta,x_{k-1}},\Delta_{\alpha,x_{k-1}}$ 上即可；而 $\Delta_{\text{co},x_k}$ 下放时，由上图可得有
$${\Delta_{\text{co},x_{k-1}}}'=\Delta_{a,x_{k-1}}\Delta_{\beta,x_k}+\Delta_{b,x_{k-1}}\Delta_{\alpha,x_k}+\Delta_{\text{co},x_k}$$

这些更新完成后，再行处理 $\sum_{l}g_a(l),\sum_{l}g_b(l)$ 和 $\sum_{l}g_a(l)g_b(l)$ 的更新。于是我们对每个节点 $x$ 维护九元组 $(\sum_{l}g_a(l),\sum_{l}g_b(l),\sum_{l}g_a(l)g_b(l),\sum_{l}h(l),\Delta_{a,x},\Delta_{b,x},\Delta_{\alpha,x},\Delta_{\beta,x},\Delta_{\text{co},x})$。题目所给每个询问 $[\text{ql},\text{qr}]$，都只需在扫到第 $\text{qr}$ 轮时区间查询 $\sum_{l=\text{ql}}^{\text{qr}}\text{qr}g_a(l)g_b(l)-h(l)$。

时间复杂度 $\operatorname{O}(Q\log n+n\log n)$，常数大。

### 代码
[**R96818778 记录详情**](https://www.luogu.com.cn/record/96818778)

```cpp
#include <bits/stdc++.h>
using namespace std;

#define inl inline
// 快读已省略。
#define newl putchar('\n')
typedef long long ll;
typedef unsigned long long ull;
typedef pair <int, int> pint;
#define fst first
#define scd second
#define all(p) begin (p), end (p)
#define empb emplace_back

constexpr int N = 250010;
int _test, n, m, l, r, a[N], b[N]; ull ans[N];
int sta[N], topa, stb[N], topb;
vector <pint> q[N];

struct seg_tree {
	struct info { ull da, db, dalp, dbta, dco; };
	struct node { ull l, r, gasum, gbsum, gagbsum, hsum; info tag; } t[N<<2];
	info inc; ull idx, L, R;

	void build (int x, int l, int r) {
		t[x].l = l, t[x].r = r;
		if (l == r) return;
		int mid = l + r >> 1;
		build (x<<1, l, mid),
		build (x<<1|1, mid + 1, r);
	}
	inl void saku (node &nde, const info &tag) {
		static ull len; len = nde.r - nde.l + 1;
		info &_tag = nde.tag;
		const auto &[da, db, dalp, dbta, dco] = tag;
		nde.hsum += dalp * nde.gbsum + dbta * nde.gasum + dco * len;
		nde.gasum += da * len, nde.gbsum += db * len;
		nde.gagbsum += da * db * len + db * nde.gasum + da * nde.gbsum;
		_tag.dco += dco + _tag.db * dalp + _tag.da * dbta;
		_tag.da += da, _tag.db += db,
		_tag.dalp += dalp, _tag.dbta += dbta;
	}
	inl void down (int x) {
		saku (t[x<<1], t[x].tag),
		saku (t[x<<1|1], t[x].tag),
		memset (&t[x].tag, 0, 40);
	}
	inl void post (int x) {
		node &nde = t[x], &ls = t[x<<1], &rs = t[x<<1|1];
		nde.gasum = ls.gasum + rs.gasum,
		nde.gbsum = ls.gbsum + rs.gbsum,
		nde.gagbsum = ls.gagbsum + rs.gagbsum,
		nde.hsum = ls.hsum + rs.hsum;
	}
	
	void add (int x) {
		if (t[x].l >= L && t[x].r <= R)
			return saku (t[x], inc);
		ull mid = t[x].l + t[x].r >> 1; down (x);
		if (L <= mid) add (x<<1);
		if (R > mid) add (x<<1|1);
		post (x);
	}
	inl void add (int l, int r, ull da, ull db, ull idx) {
		inc = { da, db, (1ull-idx)*da, (1ull-idx)*db,
			(da&&db) * (1ull-idx)*da*db } /* 特判对r的单点更新，此时由于da,db同时更新要增加额外系数 */;
		L = l, R = r, add (1);
	}
	ull query (int x) {
		if (t[x].l >= L && t[x].r <= R)
			return t[x].gagbsum * idx + t[x].hsum;
		ull mid = t[x].l + t[x].r >> 1;
		down (x); ull res = 0;
		if (L <= mid) res += query (x<<1);
		if (R > mid) res += query (x<<1|1);
		return res;
	}
	inl ull query (int l, int r, int _idx) {
		return L = l, R = r, idx = _idx, query (1);
	}
} seg;

int main () {
	/* NOIP 2022 SC-067 吴秋实 */
	// freopen ("match.in", "r", stdin);
	// freopen ("match.out", "w", stdout);

	read (_test, n);
	for (int i = 1; i <= n; ++i) read (a[i]);
	for (int i = 1; i <= n; ++i) read (b[i]);
	seg.build (1, 1, n);
	read (m);
	for (int i = 1; i <= m; ++i)
		read (l, r), q[r].empb (l, i);
	for (int r = 1; r <= n; ++r) {
		static int dt;
		// 更新单调栈。
		while (topa && (dt = a[r] - a[sta[topa]]) > 0)
			seg.add (sta[topa-1]+1, sta[topa], dt, 0, r), --topa;
		while (topb && (dt = b[r] - b[stb[topb]]) > 0)
			seg.add (stb[topb-1]+1, stb[topb], 0, dt, r), --topb;
		seg.add (r, r, a[r], b[r], r);
		sta[++topa] = stb[++topb] = r;
		for (const auto [l, id] : q[r])
			ans[id] = seg.query (l, r, r);
	}
	for (int i = 1; i <= m; ++i)
		print (ans[i]), newl;

	return 0;
}
```

---

## 作者：EnofTaiPeople (赞：17)

题意：给定序列 $a_i$，$b_i$，设 $f(l,r)=\max\limits_{i=l}^ra_i\max\limits_{i=l}^rb_i$。求 $g(l,r)=\sum\limits_{l\le l'\le r'\le r}f(l',r')$。

设 $h(l,r)$ 表示 $\sum\limits_{i=1}^lf(i,r)$，考虑对于每一个 $r$ 维护后缀最大值，发现后缀最大值是单调不升的，于是每次右端点右移相当于进行了一次后缀赋值，显然只会有 $O(1)$ 次边块赋值，这种情况，我们需要对块重构。只有前后都是整块，才不需要重构。

对块内维护 $\sum\limits_{i=L}^xf(i,r)$，整块维护 $\sum\limits_{i=1}^Rf(i,r)$，将 $r$ 从 $1$ 枚举到 $n$，这样重构块的次数为 $O(n)$，平摊为 $O(n\sqrt n)$，可以做到 $O(1)$ 查询 $h(l,r)$。

当然，你还需要维护左端点，然后套上莫队就可以了，注意修改复杂度远远超过了查询复杂度，于是二次离线可以做到 $O(n(\sqrt n+\sqrt q))$，空间 $O(n+q)$。

因为没有对拍 $\text{NOIP}$ 连 $150$ 都没上，我已经是半退役状态，写不出代码了，但目测不到 $1s$，如果有错误请指出。

---

## 作者：pigstd (赞：13)

首先离线之后容易转换成有两个序列 $a$ 和 $b$，然后对 $a,b$ 区间加，然后求 $\sum a_ib_i$ 的历史和。

首先考虑只有一维的历史和是怎么做的，这是个经典的问题，如果你去网上搜题解，几乎所有的做法都是打三个标记。

但是这有个更好的理解方式：使用矩阵维护长度，当前的和和历史和，然后这样每个节点都是两个叶子的和，然后矩阵乘法有结合律和分配率，那么打 tag 即可。

那么原题也非常简单了，矩阵维护长度，序列 $a$ 的和，序列 $b$ 的和， $a_ib_i$ 的和和历史和。

直接写矩阵乘法会 TLE，注意到你需要维护的矩阵本质不同的数只有 $7$ 个，直接维护那 $7$ 个数然后手动矩乘即可。

[朴素实现](https://www.luogu.com.cn/paste/zp5fg5z2) [能过洛谷民间数据的实现](https://www.luogu.com.cn/paste/sdmubcwv)。


----

所以说四个简单题的 noip 我是怎么打出来这么烂的成绩的？？太小丑了吧。

---

## 作者：I_am_Accepted (赞：7)

每组询问 $[L,R]$ 要求
$$
\sum_{[l,r]\in[L,R]}(\max_{i\in[l,r]} A_i)(\max_{i\in[l,r]}B_i)
$$
顺序扫 $r$，维护 $\{a\},\{b\}$ 分别表示以每个位置为 $l$ 时的 $\max_{i\in[l,r]} A_i,\max_{i\in[l,r]}B_i$。

对于询问 $[L,R]$，答案为 $r$ 刚刚扫完 $R$ 时 $[L,R]$ 的历史乘积和。

就得到了 20pts 暴力：

```cpp
int orz,n,q,A[N],B[N],sa[N],sb[N],ta=0,tb=0;
ull a[N],b[N],c[N];
vector<pi> ask[N];
ull ans[N];
signed main(){ios::sync_with_stdio(false),cin.tie(nullptr);
	cin>>orz>>n;
	rep(i,1,n) cin>>A[i];
	rep(i,1,n) cin>>B[i];
	cin>>q;
	rep(i,1,q){
		int l,r;cin>>l>>r;
		ask[r].pb(l,i);
	}
	rep(i,1,n){
		while(ta && A[sa[ta]]<=A[i]) ta--;
		while(tb && B[sb[tb]]<=B[i]) tb--;
		rep(j,sa[ta]+1,i) a[j]=A[i];
		rep(j,sb[tb]+1,i) b[j]=B[i];
		sa[++ta]=i;
		sb[++tb]=i;
		rep(j,1,i) c[j]+=a[j]*b[j];
		for(auto j:ask[i]){
			ull x=0;
			rep(k,j.fir,i) x+=c[k];
			ans[j.sec]=x;
		}
	}
	rep(i,1,q) cout<<ans[i]<<"\n";
return 0;}
```

接下来参考 CF1083D 的做法，用两个单调栈维护后缀最大值位置，问题就转化为：

* $\{a\}$ 区间赋值。

* $\{b\}$ 区间赋值。

* 区间内 $\{c\}$ 加上对应项 $\{a\},\{b\}$ 相乘。

* 查询 $\{c\}$ 区间和。

线段树 $O(n\log n)$ 可做。

树节点维护：$c,a,b,ab$ 的和。

tag 维护：$ab,a,b,1$ 加到 $c$ 中的系数，$a,b$ 的赋值标记。

100pts 代码太丑了，不放了吧。

其实也可以用矩阵维护标记，代码更简单不过常数大。

---


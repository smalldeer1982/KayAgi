# 多项式高手

## 题目描述

已知非负整数数列 $b_1,b_2,\cdots,b_n$ 的值，另有非负整数数列 $a$ 满足 $a_1+a_2+\cdots+a_n = m$，$a_1\le a_2\le\cdots\le a_n$。请求出对于所有满足条件的数列 $a$，$a_1b_1+a_2b_2+\cdots+a_nb_n$ 的和。由于答案可能很大，你只需要输出答案对 $10^9+7$ 取模的结果。

## 说明/提示

### 样例解释

**【样例 1 解释】**

当且仅当 $a_1=6$ 时满足条件，所以答案为 $a_1\times b_1=6\times7=42$。

**【样例 2 解释】**

共有 $4$ 种可能的数列 $a$：

- $a_1=0$，$a_2=6$ 时式子的值为 $0\times9+6\times7=42$；
- $a_1=1$，$a_2=5$ 时式子的值为 $1\times9+5 \times7=44$；
- $a_1=2$，$a_2=4$ 时式子的值为 $2\times9+4\times7=46$；
- $a_1=3$，$a_2=3$ 时式子的值为 $3\times9+3\times7= 48$。

故答案为 $42+44+46+48=180$。

**【样例 3 解释】**

共有 $3$ 种可能的数列 $a$：

- $a_1=0$，$a_2=0$，$a_3=3$ 时式子的值为 $0\times9+0\times5+3\times7=21$；
- $a_1=0$，$a_2=1$，$a_3=2$ 时式子的值为 $0\times9+1\times5+2\times7=19$；
- $a_1=1$，$a_2=1$，$a_3=1$ 时式子的值为 $1\times9+1\times5+1\times7=21$。

故答案为 $21+19+21=61$。

### 大样例

**【样例 5】**

见选手目录下的 `mtt/mtt5.in` 与 `mtt/mtt5.out`。

这个样例满足测试点 $3$ 的约束条件。

**【样例 6】**

见选手目录下的 `mtt/mtt6.in` 与 `mtt/mtt6.out`。

这个样例满足测试点 $6$ 的约束条件。

**【样例 7】**

见选手目录下的 `mtt/mtt7.in` 与 `mtt/mtt7.out`。

这个样例满足测试点 $8$ 的约束条件。

**【样例 8】**

见选手目录下的 `mtt/mtt8.in` 与 `mtt/mtt8.out`。

这个样例满足测试点 $9$ 的约束条件。

### 数据范围

空间限制 $512\text{MB}$。保证时空限制均为 $\text{std}$ 的 $2$ 倍以上。

对于所有数据，$1\le n\le10^5;~1\le m\le110,000;~n\le m\le n+10^4;~0\le b_i<10^9+7$。

| 测试点 | $n=$ | $m=$ | 时间限制 |
| :----------: | :----------: | :----------: | :----------: |
| $1$ | $2$ | $6$ | $1\text s$ |
| $2$ | $6$ | $6$ | $1\text s$ |
| $3$ | $50$ | $99$ | $1\text s$ |
| $4$ | $100$ | $199$ | $1\text s$ |
| $5$ | $500$ | $999$ | $1\text s$ |
| $6$ | $5000$ | $5000$ | $1\text s$ |
| $7$ | $5000$ | $9999$ | $1\text s$ |
| $8$ | $10^5$ | $10^5$ | $3\text s$ |
| $9$ | $10^5$ | $100100$ | $3\text s$ |
| $10$ | $10^5$ | $110000$ | $0.6\text s$ |

### 出题人员

Idea：不知名用户，Solution：Konata28 & 不知名用户，Code：Konata28 & Milmon & 不知名用户，Data：不知名用户，Check：Milmon & Konata28。

本题来源于 2024.10.22 CSP-S 模拟赛。因为原版题目模数是 $998244353$，所以原版英文名为 ntt。数据点范围配置和时空限制相对原版题目略有改动。

## 样例 #1

### 输入

```
1 6
7```

### 输出

```
42```

## 样例 #2

### 输入

```
2 6
9 7```

### 输出

```
180```

## 样例 #3

### 输入

```
3 3
9 5 7```

### 输出

```
61```

## 样例 #4

### 输入

```
6 6
250863180 814744283 795773454 638846422 603293402 952439325```

### 输出

```
162287374```

# 题解

## 作者：Argon_Cube (赞：8)

简单题。

----

看到 $a$ 递增显然要将 $a$ 做差分并将 $b$ 做后缀和消去这个条件。现在我们要解决的问题变成了：

> 对于所有满足 $\sum_{i=1}^nia_i=m$ 的数列 $a$ 求 $\sum_{i}a_ib_i$ 之和。

显然我们会用生成函数去尝试描述这个东西。首先拆 $b_i$ 的贡献，枚举 $a_i=j$，经过简单的推导得到答案是

$$\sum_ib_i\sum_jj[x^{m-ij}](1-x^i)F(x)$$

其中

$$F(x)=\prod_{i=1}^{\color{red}n}\frac{1}{1-x^i}$$

这个东西和分拆数只差了一个上标 $m\to n$，那我们直接算出分拆数 $\prod_{i=1}^{\color{red}m}(1-x^i)^{-1}$ 然后再把 $(1-x^i)(n<i\leq m)$ 乘回来就行了。

算出 $F(x)$ 后暴力就是 $\Theta(m\log n)$。时间复杂度 $\Theta(m\sqrt m+(m-n)^2+m\log n)$。

```cpp
int main(int argc,char* argv[],char* envp[])
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    dp[0]=1;
    int n,m;
    cin>>n>>m;
    fori(i,1,n)
        cin>>va[i];
    reverse(rgo1(va,n));
    fori(i,1,m)
    {
        for(int j=1,k;(k=j*(j*3-1)/2)<=i;j++)
            dp[i]+=(j&1?dp[i-k]:p-dp[i-k]);
        for(int j=-1,k;(k=j*(j*3-1)/2)<=i;j--)
            dp[i]+=(-j&1?dp[i-k]:p-dp[i-k]);
        dp[i]%=p;
    }
    fori(i,n+1,m)
        ford(j,m,i)
            (dp[j]+=p-dp[j-i])%=p;
    long long ans=0;
    fori(i,1,n)
    {
        va[i]+=va[i-1];
        long long a=0;
        for(int j=0;j*i<=m;j++)
            a+=j*(dp[m-j*i]-(m>=(j+1)*i?dp[m-j*i-i]:0)+p)%p;
        ans+=va[i]%p*(a%p)%p;
    }
    cout<<ans%p;
    return 0;
}
```

---

## 作者：不知名用户 (赞：7)

### 题意

已知非负整数数列 $b_1,b_2,\cdots,b_n$ 的值，另有非负整数数列 $a$ 满足 $a_1+a_2+\cdots+a_n = m$，$a_1\le a_2\le\cdots\le a_n$。请求出对于所有满足条件的数列 $a$，$a_1b_1+a_2b_2+\cdots+a_nb_n$ 的和。由于答案可能很大，你只需要输出答案对 $10^9+7$ 取模的结果。

$1\le n\le10^5;~1\le m\le110,000;~n\le m\le n+10^4;~0\le b_i<10^9+7$。

### 做法

提供一个无脑多项式推法，不过最后可以避开多项式操作。

感谢 @[Konata28](https://www.luogu.com.cn/user/177029) 提出本做法，@[Milmon](https://www.luogu.com.cn/user/234641) 编写了该做法题解。本人将该题解做了很多补充，写成了下面的题解。

首先做转化，问题变为把 $m$ 拆分为若干个 $\leq n$ 的正整数的和，正整数 $i$ 的权值为 $s_i=b_{n-i+1}+b_{n-i+2}+\cdots+b_n$，需要求出所有拆分的权值之和。意思是把 $a$ 视作一些后缀叠起来的。

考虑写出其生成函数，但是发现权值不太好记录到系数里面，因为系数是做乘法而权值是做加法，而在值域做乘法下定义域做加法的函数是指数函数！所以再引入变量 $y$，用 $y$ 的幂表示权值。记二元生成函数 $F(x,y)=\prod\limits_{i=1}^n \dfrac{1}{1-x^iy^{s_i}}$，则只需要求所有 $x^m$ 项的 $y$ 指数与系数的积总和，等价于对 $y$ 求导之后带入 $y=1$ 的 $x^n$ 项系数，这个可以写出 $x,y$ 都是非负指数的形式后看出。

形如 $\dfrac{1}{1-x}$ 的式子的乘积可以转化成先求 $\ln$ 做加法再 $\exp$ 回去。显然不能一个一个做 $\ln\dfrac{1}{1-x}$，但是可以先对其进行一些推导加速运算。设 $f(x)=\ln\dfrac{1}{1-x}$，对 $f(x)$ 求导再积分：

$$
\begin{aligned}
\ln\dfrac{1}{1-x}&=f(x)\\
(-(-\frac{1}{(1-x)^2}))\cdot\frac{1}{\frac{1}{1-x}}&=f'(x)\\
\frac{1}{1-x}&=f'(x)\\
\sum_{i=0}^{\infty}x^i&=f'(x)\\
\sum_{i=1}^{\infty}\frac{1}{i}x^i&=f(x)
\end{aligned}
$$

（为了方便大家理解，展开了复合函数求导法则）

将上式的 $x$ 改成 $x^iy^{s_i}$ 代入：

$$
\exp\sum_{i=1}^n\ln\dfrac{1}{1-x^iy^{s_i}}
=\exp\sum_{i=1}^n\sum_{j=1}^{\infty}\dfrac{x^{ij}y^{s_ij}}{j}
$$

根据复合函数求导法则和 $(\exp x)'=\exp x$，$(\exp f(x))'=f'(x)\exp f(x)$ 以及函数加法导数加法原则，对 $y$ 求导，再代入 $y=1$ 的结果为：

$$
\left(\sum_{i=1}^n\sum_{j=1}^{\infty}s_ix^{ij}\right)\exp\left(\sum_{i=1}^n\sum_{j=1}^{\infty}\frac{1}{j}x^{ij}\right)
$$

只需求出 $x^m$ 的系数即可。因为只关心 $x^m$ 的系数，所以不需要额外的多项式乘法，直接枚举前面的 $s_ix^{ij}$ 然后和后半部分 $x^{m-ij}$ 的系数相乘即可。

后面的式子处理出来是调和级数复杂度 $\Theta(m\log n)$ 的，$\exp$ 复杂度是 $\Theta(m\log m)$。总时间复杂度 $\Theta(m(\log m+\log n))$。

需自备模数为 $10^9+7$ 的多项式 exp 板子。虽然复杂度很低，但 MTT exp 常数很大，可能需要比较优的板子。不过出这题本意就是不想让多项式过的。省去多项式板子的代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 1.1e5 + 10, mod = 1e9 + 7;
int a[N], s[N], inv[N];

int main()
{
	int n, m, i, j, ans = 0;
	scanf("%d%d", &n, &m);
	for(i=1;i<=n;i++) scanf("%d", &a[n-i+1]);
	for(i=1;i<=n;i++) s[i] = (s[i-1] + a[i]) % mod;
	poly p;
	p.resize(m+1);
	inv[1] = 1;
	for(i=2;i<=m;i++) inv[i] = 1ll * inv[mod%i] * (mod - mod / i) % mod;
	for(i=1;i<=n;i++)
		for(j=i;j<=m;j+=i)
			p[j] = (p[j] + inv[j/i]) % mod;
	exp(p);
	for(i=1;i<=n;i++)
		for(j=i;j<=m;j+=i)
			ans = (1ll * s[i] * p[m-j] + ans) % mod;
	printf("%d", ans);
	return 0;
}
```

### 如何避开大常数 MTT exp

观察 $\displaystyle\exp\left(\sum_{i=1}^n\sum_{j=1}^{\infty}\frac{1}{j}x^{ij}\right)$ 括号里面的式子，这就是 $\displaystyle\sum\limits_{i=1}^{\infty}\ln\frac{1}{1-x}$！这个式子就是商品体积为 $1,2,\cdots,n$，凑得一个价格的方案数的生成函数（[P4389](https://www.luogu.com.cn/problem/P4389)，没理解可以去翻那题的题解）。在 $m=n$ 的时候这就是[拆分数](https://www.luogu.com.cn/problem/P6189)，$m>n$ 的时候可以先跑 $m$ 的拆分数再把 $n+1,n+2,\cdots,m$ 从计数背包撤销，这样就用 $\Theta(m\sqrt m+(m-n)^2)$ 的复杂度代替了多项式 $\exp$ 操作。总复杂度 $\Theta(m\sqrt m+(m-n)^2+m\log n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 1.1e5 + 10, sqN = 350, mod = 1e9 + 7;

int f[sqN+5][N], p[N], s[N];

signed main()
{
	int n, m, i, j, ans = 0;
	scanf("%d%d", &n, &m);
	for(i=1;i<=n;i++) scanf("%d", &s[n-i+1]);
	for(i=1;i<=n;i++) s[i] = (s[i] + s[i-1]) % mod;
	int sqm = (int)sqrt(m);
	f[0][0] = p[0] = 1;
	for(i=1;i<=m/sqm;i++) for(j=0;j<=m;j++)
	{
		if(j>=i) f[i][j] = f[i][j-i];
		if(j>=sqm) f[i][j] = (f[i][j] + f[i-1][j-sqm]) % mod;
		p[j] = (p[j] + f[i][j]) % mod;
	}
	for(i=1;i<sqm;i++) for(j=i;j<=m;j++) p[j] = (p[j] + p[j-i]) % mod;
	for(i=m;i>n;i--) for(j=m;j>=i;j--) p[j] = (p[j] - p[j-i] + mod) % mod;
	for(i=1;i<=n;i++)
		for(j=i;j<=m;j+=i)
			ans = (ans + 1ll * s[i] * p[m-j] % mod) % mod;
	printf("%d", ans);
	return 0;
}
```

### 花絮

对每个 $s_i$ 算贡献不使用多项式也可以做，代码和上面是一样的。但是如果要用 MTT exp 的话对多项式板子要求非常严格，也许没经过任何卡常的板子跑不过去。

其实最开始出出来还是暴力 $\Theta(nm)$ 背包做的，然后我发现物品是独立的，可以算贡献，但是要先求出来 $1,2,\cdots,n$ 去凑出 $1,2,\cdots,m$ 的方案数，具体参见[这篇题解](https://www.luogu.com.cn/article/2eztwi30)，和他做法一样。这可以拆分数+撤销也可以直接套用 P4389 的 poly 做法，推出来的式子跟上面的式子是一样的。验题人提出了本篇题解的做法。

---

## 作者：NaCly_Fish (赞：4)

****

### 零

什么叫「转化到拆分 $m$ 为若干不超过 $n$ 的正整数」？   
什么叫「显然要将 $a$ 做差分」？   
「Ferrers 图辅助理解」怎么理解？  
为什么一个人发呆？  
谁是多项式高手？

好吧不魔怔了。  
很多分拆数的问题都可以用 q-analog 的方法推导，与组合意义解法殊途同归——本题亦不例外。
****

### 一

直接考虑 $b_k$ 这一项对答案产生的贡献，设其为 $g_k$，则：

$$g_k = [x^m]\sum_{i \geq 0} i x^i \left( [y^{k-1}]\prod_{j=0}^i \frac{1}{1-y x^j}\right)\left( [y^{n-k}] \prod_{j=i}^\infty \frac{1}{1-y x^j}\right)$$
则答案为 $\sum_k b_k g_k$。

这个 GF 的意义为：枚举第 $k$ 项位置的值，计算此时的序列 $a$ 有多少种 —— 前 $k-1$ 个位置都不大于 $i$，而后 $n-k$ 个位置都不小于 $i$。

利用 q-analog 的推导，我们设

$$P(x,y)=\prod_{j=0}^i \frac{1}{1-y x^j}$$
做换元 $y \mapsto xy$，则有
$$P(x,xy)=P(x,y) \frac{1-y}{1-y x^{i+1}}$$
在等式两端同乘 $(1-y x^{i+1})$ 并提取 $[y^k]$ 系数得到
$$\begin{aligned}x^k p_k-x^{i+k}p_{k-1} &=p_k-p_{k-1} \\ p_k&= \frac{1-x^{i+k}}{1-x^k}p_{k-1}\end{aligned}$$
由此可以直接写出原式中
$$[y^{k-1}]\prod_{j=0}^i \frac{1}{1-y x^j}=\prod_{j=1}^{k-1} \frac{1-x^{i+j}}{1-x^j}$$
故技重施，同样也能解出
$$[y^{n-k}] \prod_{j \geq i} \frac{1}{1-y x^j}=\prod_{j=1}^{n-k} \frac{x^i}{1-x^j}$$
现在就有
$$g_k=[x^m]\sum_{i \geq 0} i x^i \left( \prod_{j=1}^{k-1} \frac{1-x^{i+j}}{1-x^j}\right)\left( \prod_{j=1}^{n-k} \frac{x^i}{1-x^j}\right)$$
****

### 二

虽然把二元 GF 化简为一元，但其形式还不容易处理。可以看到连乘中可以提出 $x^{i(n-k)}$ 和其它与 $i$ 无关的部分。

重点考虑化简
$$H_k(x)=\sum_{i \geq 0} i x^{i(n-k+1)} \prod_{j=1}^{k-1} \frac{1-x^{i+j}}{1-x^j}$$
看起来还是不好算，又该 q-analog 出手了。设
$$F(x,t)=\sum_{i \geq 0} t^i \prod_{j=1}^{k-1} \frac{1-x^{i+j}}{1-x^j}$$
这样在求出 $t\partial _t F(x,t)$ 后，做换元 $t \mapsto x^{n-k+1}$ 即可得到 $H_k(x)$。我们有结论
$$F(x,t)=\prod_{j=0}^{k-1} \frac{1}{1-tx^j }$$
你应该也注意到了，这就是逆用了前一节的推导过程而已。现在可以算出

$$t \frac{\partial F(x,t)}{\partial t}= F(x,t)\sum_{j=0}^{k-1} \frac{t x^j}{1-t x^j}$$
于是就得到了 $H_k(x)$：
$$H_k(x) = \left( \prod_{j=0}^{k-1} \frac{1}{1-x^{n-j}}\right)\sum_{j=0}^{k-1} \frac{x^{n-j}}{1-x^{n-j}}$$

再带回 $g_k$ 的表达式中，就得到了

$$g_k = [x^m] \left(\prod_{j=1}^n \frac{1}{1-x^j} \right)\sum_{j=0}^{k-1} \frac{x^{n-j}}{1-x^{n-j}}$$
此时就比较容易计算了，把后面的和式拆开就得到了递推
$$g_{k+1}  = g_k + [x^m]\left(\prod_{j=1}^n \frac{1}{1-x^j} \right) \frac{x^{n-k}}{1-x^{n-k}} $$
直接计算即可，对单个 $k$ 计算此式的复杂度是 $\Theta(m/(n-k))$，总复杂度为 $\Theta(m \log m)$。不过此题模数不让跑 NTT，强行用任意模来做的常数也太大了。

当然，可以利用此题中数据的特殊性质避开 FFT。另外几篇题解中也说到了做法，这里还是提一下：

$$\prod_{j=1}^n \frac{1}{1-x^j} \equiv \left( \prod_{j=1}^\infty \frac{1}{1-x^j}\right)\left( \prod_{j=n+1}^m (1-x^j)\right) \pmod{x^{m+1}}$$
前一部分可以利用五边形数定理，以 $\Theta( m^{1.5})$ 的复杂度计算；后一部分把每一项暴力乘上去，复杂度是 $\Theta((m-n)^2)$ 的。

---

## 作者：Purslane (赞：2)

# Solution

哎我刚开始把这个题想的太简单了，过一会发现又把它想的太难了 ~~（主要是看到其他人的代码很短）~~。

前置知识：$O(n \sqrt n)$ 求 $1$ 到 $n$ 的划分数，即对 $n_0 = 1,2,\cdots,n$ 求出 $\sum a_i = n_0$，$a_i \le a_{i+1}$ 的 $a$ 的组数。

对应这种拆分问题考虑使用 Ferrers 图辅助理解。比如这样：

![](https://s21.ax1x.com/2025/05/05/pEqloCV.png)

考虑这张图的最大内接正方形，假设边长为 $h$。

则可以将图形分为 $h \times h$ 的正方形和两个最大值 $\le h$ 的整数拆分。所以我们可以得到生成函数为：

$$
\sum_{h \ge 1} x^{h \times h} \prod_{j=1}^h (\dfrac{1}{1-x^j})^2
$$

显然 $h$ 的值域是 $O(\sqrt n)$ 的。而后面那个乘积的组合意义是：对于每个权值为 $1$ 到 $h$ 的物品，做两遍完全背包（这一步很巧妙，可以直接规避卷积操作。换句话说，在 DP 的过程中已经把卷积做了一遍。）。这样我们可以 $O(n)$ 的完成 $h \leftarrow h+1$ 的变化。

代码长这样：

```cpp
ffor(h,1,B) {
  ffor(i,h,m) dp[i]=(dp[i]+dp[i-h])%MOD;
  ffor(i,h,m) dp[i]=(dp[i]+dp[i-h])%MOD;
  ffor(j,h*h,m) cnt[j]=(cnt[j]+dp[j-h*h])%MOD;
}
```

$B = \lfloor \sqrt m \rfloor$。

回到这道题。数据保证了：要么 $n$ 极其小可以爆搜（$n=2$），要么 $n \le m \le 2n-1$。

将题目改为：有 $n$ 个物品，第 $i$ 个物品的权值为 $\sum_{j=n-i+1}^n b_j$，大小为 $i$。选出若干个物品，使得物品大小和为 $m$。每组方案的权值为所有物品权值之和。求出方案权值之和。

有一个比较直接的思路：对于每个 $i$ 和 $t$，求出有多少种方案能包含至少 $t$ 个 $i$ 物品。而他等于 $m-it$ 的划分数（可以构建双射。但是这个结论真的对吗？）

写出代码（其中 `suf` 数组表示后缀和）

```cpp
ffor(j,1,n) ffor(t,1,m/j) ans=(ans+1ll*cnt[m-j*t]*suf[n-j+1])%MOD;
```

注意，$m-it$ 划分的时候，有可能会选出大小大于 $n$ 的数！所以这个双射不满足。

不过很容易修正——那些不符合要求的情况，可以直接对应为 $m-(n+1)$，$m-(n+2)$，$\cdots$，$1$（考虑删掉最大的物品。而删去最大的物品之后，$m' \le n$ 所以不会出现不合法的情况了！）

再对 `cnt` 数组套一个前缀和即可。

代码：

```cpp
#include<bits/stdc++.h>
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=2e5+10,B=330,MOD=1e9+7;
int n,m,b[MAXN],suf[MAXN]; 
int cnt[MAXN],dp[MAXN],pre[MAXN];
signed main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>n>>m;
	ffor(i,1,n) cin>>b[i];
	roff(i,n,1) suf[i]=(suf[i+1]+b[i])%MOD;
	if(n==2) {
		int ans=0;
		ffor(j,0,m) if(j<=m-j) ans=(ans+1ll*b[1]*j%MOD+1ll*b[2]*(m-j))%MOD;
		return cout<<(ans%MOD+MOD)%MOD,0;
	}
	pre[0]=cnt[0]=dp[0]=1;
	ffor(h,1,B) {
		ffor(i,h,m) dp[i]=(dp[i]+dp[i-h])%MOD;
		ffor(i,h,m) dp[i]=(dp[i]+dp[i-h])%MOD;
		ffor(j,h*h,m) cnt[j]=(cnt[j]+dp[j-h*h])%MOD;
	}
	int ans=0;
	pre[0]=1;
	ffor(i,1,m) pre[i]=(pre[i-1]+cnt[i])%MOD;
	ffor(j,1,n) ffor(t,1,m/j) ans=(ans+1ll*cnt[m-j*t]*suf[n-j+1])%MOD;
	m-=n+1;
	ffor(j,1,n) ffor(t,1,m/j) ans=(ans-1ll*pre[m-j*t]*suf[n-j+1])%MOD;
	cout<<(ans%MOD+MOD)%MOD;
	return 0;
}
```

---


# 回报

## 题目背景

> 在我看来，得到太多的人明明是我，反倒是我该思考怎么回报才对。\
——浅村悠太

## 题目描述

悠太需要帮沙季找到合适的学习用音乐。

他找到了一个包含 $n$ 首音乐的专辑，其中的音乐编号为从 $1$ 至 $n$，播放每首音乐均需要 $1$ 分钟。沙季有 A 和 B 两门需要学的课程，每次学习 A 和 B 分别需要花 $a,b$ 分钟。为了更好地帮助她，悠太打算将音乐的播放顺序重新排列。具体地，他要选择一个长为 $n$ 的排列 $p_1,\dots,p_n$，使得其中存在两个长度分别为 $a,b$ 的循环 $A,B$，且 $A$ 中的任意一个元素小于 $B$ 中的任意一个元素。

排列中的一个长为 $k$ 的循环 $C$ 是一个由不同整数组成的序列 $c_1,\dots,c_k$，满足 $1\le c_1\le n$，$c_{i+1}=p_{c_i},i=1,\dots,k-1$，且 $p_{c_k}=c_1$。

悠太想要求出有多少满足要求的排列 $p$。由于答案可能很大，你只需要告诉他答案对 $998244353$ 取模的结果。

## 说明/提示

#### 样例 1 解释

满足要求的排列有 $(2,1,3,4),(3,2,1,4),(1,3,2,4)$，共 $3$ 个。

#### 数据范围与限制

**本题采用捆绑测试，各 Subtask 的限制与分值如下。**

| Subtask No. | $n\le$ | 特殊性质 | 分值 | 依赖子任务 |
| :-: | :-: | :-: | :-: | :-: |
| $1$ | $10$ | 有 | $7$ |  |
| $2$ | $700$ | 有 | $10$ | $1$ |
| $3$ | $700$ | 无 | $20$ | $1,2$ |
| $4$ | $2000$ | 有 | $10$ | $1,2$ |
| $5$ | $2000$ | 无 | $30$ | $1,2,3,4$ |
| $6$ | $10^6$ | 有 | $20$ | $1,2,4$ |
| $7$ | $10^6$ | 无 | $3$ | $1,2,3,4,5,6$ |

特殊性质：$\min(a,b)=1$。

对于所有数据，$1\le n\le10^6$，$1\le a,b<a+b\le n$。

## 样例 #1

### 输入

```
4 2 1
```

### 输出

```
3
```

## 样例 #2

### 输入

```
678 12 34
```

### 输出

```
951781526
```

## 样例 #3

### 输入

```
1987 654 321
```

### 输出

```
27905503
```

## 样例 #4

### 输入

```
1000000 13 20
```

### 输出

```
912829543
```

# 题解

## 作者：_LiWenX_ (赞：5)

他这个题意里面的循环就是置换环，你要存在一个长度为 $A$ 和一个长度为 $B$ 的置换环使得 $A$ 中元素小于 $B$ 中元素。

比较元素的大小比较难以理解，所以可以值域和下标交换，答案显然不变，问题变成你要存在一个长度为 $A$ 和一个长度为 $B$ 的置换环使得 $A$ 中所有元素在 $B$ 中所有元素之前出现。

所以可以认为是我们要把至少一个长度为 $A$ 的置换环放到至少一个长度为 $B$ 的置换环前面，这样的限制像直接告诉你了要容斥。

所以钦定 $i$ 个长度为 $A$，$j$ 个长度为 $B$ 的置换环出来，且认为 $i$ 个环在 $j$ 个环前面，前 $i$ 个环和后 $j$ 个环内部两两不区分顺序，容斥系数就是 $(-1)^{i+j}$，设 $i$ 个长度为 $A$ 的环的方案数是 $f_i$，$j$ 个长度为 $B$ 的环的方案数是 $g_j$，剩下的数随便放都行，那么此时对答案的贡献就是 $(-1)^{i+j}f_ig_j\binom{n}{Ai+Bj}(n-Ai-Bj)!=(-1)^{i+j}f_ig_j\dfrac{n!}{(Ai+Bj)!}$。

所以如果可以计算 $f_i$，就可以使用卷积快速计算出答案。

计算 $f$ 也是简单的，长度为 $A$ 的置换环数量是 $(A-1)!$，考虑带上标号，最后外面乘上 $(Ai)!$，贡献就是 $\dfrac{1}{A}$，注意环之间不区分顺序，所以 $f_i=\dfrac{(Ai)!}{i!A^i}$，$g_i$ 同理。

求出来卷一下就做完了，时间复杂度 $O(n\log n)$，代码太过于简单就不放了。

upd：

有同学说这个容斥有点抽象，不能理解为啥是对的，那么简单证一下。

容斥系数看作是 $(-1)^{i-1}(-1)^{j-1}$，其实形式非常像子集反演：$\sum\limits_{T\subseteq  S,|T|>0} (-1)^{|T|+1}=1$。

而我们要说明这个容斥是对的，那就是说对于所有的合法排列，他最后容斥系数和为 $1$，不合法排列容斥系数为 $0$。

首先不合法排列没有考虑过，所以系数当然是 $0$。

对于合法，相信你看到上面的式子你就会了，我们其实干的就是一模一样的事情，只不过是枚举了两个集合，然后计算了类似 $\sum\limits_{T_1\subseteq  S_1,|T_1|>0} (-1)^{|T_2|+1}\sum\limits_{T_2\subseteq  S_2,|T_2|>0} (-1)^{|T_2|+1}=1$ 的东西，唯一的限制是说 $T_1$ 里面的环都在 $T_2$ 前面。我们考虑减去不合法的贡献，如果我们考虑这个式子里面的空集，那么一个元素是不合法的集合和去掉这个元素的集合形成双射，不合法的贡献必然是 $0$，所以加上限制的式子容斥系数和依然是 $1$。

所以这个容斥是对的。

---

## 作者：VinstaG173 (赞：4)

原解法被 Kubic 老师吊打了，感觉太久不做组合题思维钝化了。

### Subtask 1

枚举全排列可以做到 $O(n!n)$。

### Subtask 1,2,4,6

以下我们简称循环为圈，称长度为 $c$ 的循环为 $c$-圈。不妨假设 $b=1$。

记答案为 $f_{a,n}$，记长为 $n$ 的排列中存在 $c$-圈的方案数为 $g_{c,n}$。

考虑递推求 $f_{a,n+1}$，枚举 $n+1$ 所在圈的情况。若 $n+1$ 为 $1$-圈，则有 $g_{a,n}$ 种方案。否则 $n+1$ 所在圈长大于 $1$，枚举圈长 $k+1$，则剩余数有 $f_{a,n-k}$ 种方案。得到递推式：

$$f_{a,n+1}=g_{a,n}+\sum_{k=1}^{n-a}n^{\underline{k}}f_{a,n-k}.$$

设 $A_{\{a_1,\dots,a_c\}}$ 表示集合 $\{a_1,\dots,a_c\}$ 中的元素构成圈的排列的集合，则 $k$ 个 $A_S$ 的交集有 $\displaystyle\dfrac1{k!}\prod_{i=0}^{k-1}\binom{n-ic}c$ 种可能性，每种可能性中有 $\left((c-1)!\right)^k(n-kc)!$ 个排列，故 $\displaystyle g_{c,n}=n!\sum_{k=1}^{n/c}\dfrac{(-1)^{k-1}}{k!c^k}$，这个在 oeis 也能找到。可以 $O(n)$ 预处理。

直接做 $f$ 的递推可以做到 $O(n^2)$。注意到

$$\sum_{k=1}^{n-a}n^{\underline{k}}f_{a,n-k}=\sum_{k=a}^{n-1}\dfrac{n!}{k!}f_{a,k},$$

原递推式的计算可以前缀和优化至 $O(n)$。

### Subtask 1-3

考虑最大元素最小的 $a$-圈，设它的最大元素为 $k$，则这样的 $a$-圈共有 $(k-1)^{\underline{a-1}}$ 种可能。需要满足在 $<k$ 的数之间不构成其他 $a$-圈，且在 $>k$ 的数之间存在 $b$-圈。

考虑容斥，容斥项为前 $k-a$ 个数有 $x$ 个 $a$-圈，后 $n-k$ 个数有 $y$ 个 $b$-圈，剩下数任意排列的方案数，容斥系数为 $(-1)^{x+y-1}$。其中 $x\ge0,y\ge1$。

类似计数，则可以写出表达式：

$$\begin{aligned}
&\,\,\,\,\,\,\,\sum_{k=a}^{n-b}(k-1)^{\underline{a-1}}\cdot\sum_{x=0}^{(k-a)/a}\dfrac{((a-1)!)^x}{x!}\prod_{i=1}^x\binom{k-a-(i-1)a}{a}\sum_{y=1}^{(n-k)/b}\dfrac{((b-1)!)^y}{y!}\prod_{j-1}^y\binom{n-k-(j-1)b}{b}\cdot(-1)^{x+y-1}(n-a-xa-yb)!\\
&=\sum_{k=a}^{n-b}\dfrac{(k-1)!}{(k-a)!}\cdot(k-a)!(n-k)!\sum_{x=1}^{k/a}\sum_{y=1}^{(n-k)/b}\dfrac{(-1)^{x+y-1}(n-xa-yb)!}{(x-1)!a^{x-1}(k-xa)!y!b^y(n-k-yb)!}.
\end{aligned}$$

可以 $O(n^3)$ 计算。

### Subtask 1-5

卷积优化上式可以做到 $O(n^2\log n)$。

事实上，发现可以不用真的枚举 $k$。考虑直接容斥存在 $x$ 个较小 $a$-圈和 $y$ 个较大 $b$-圈的排列，容斥系数为 $(-1)^{x+y}$，其中 $x,y\ge1$。

则先选出 $(xa+yb)$ 在圈中的数，剩余数任意排列，然后选出的数中较小的 $xa$ 个成 $a$-圈，较大的 $yb$ 个成 $b$-圈，可以写出表达式：

$$\begin{aligned}
&\,\,\,\,\,\,\,\sum_{x=1}^{n/a}\sum_{y=1}^{n/b}\binom{n}{xa+yb}(n-xa-yb)!\dfrac{(-1)^{x+y}(xa)!(yb)!}{x!a^xy!b^y}\\
&=\sum_{x=1}^{n/a}\sum_{y=1}^{n/b}\dfrac{(-1)^{x+y}(xa)!(yb)!n!}{x!a^xy!b^y(xa+yb)!}[xa+yb\le n].
\end{aligned}$$

可以 $O(n^2)$ 计算。

### Subtask 7

用卷积优化上式，记

$$F_a=\sum_{k\ge1}\dfrac{(-1)^k(ka)!}{k!a^k}x^{ak},$$

则答案为

$$n!\sum_{k=a+b}^n\dfrac1{k!}[x^k]F_aF_b.$$

时间复杂度 $O(n\log n)$。

Code:
```cpp
int n,a,b,L;
ll f[2100003],g[2100003],ia,ib,x;
ll fac[1000003],fic[1000003],sum;
inline int C(int m,int k){
	return fac[m]*fic[k]%ntf*fic[m-k]%ntf;
}int main(){
	cin>>n>>a>>b;fac[0]=1;
	for(rg int i=1;i<=n;++i)
		fac[i]=fac[i-1]*i%ntf;
	fic[n]=qpw(fac[n]);
	for(rg int i=n;i;--i)
		fic[i-1]=fic[i]*i%ntf;
	ia=qpw(a);ib=qpw(b);
	x=ia;for(rg int i=1;i*a<=n;++i){
		f[i*a]=fac[i*a]*fic[i]%ntf*x%ntf;
		x=x*ia%ntf;if(i&1)f[i*a]=ntf-f[i*a];
	}x=ib;for(rg int i=1;i*b<=n;++i){
		g[i*b]=fac[i*b]*fic[i]%ntf*x%ntf;
		x=x*ib%ntf;if(i&1)g[i*b]=ntf-g[i*b];
	}mlt(f,g);sum=0;
	for(rg int i=a+b;i<=n;++i)
		sum=(sum+f[i]*fic[i])%ntf;
	cout<<sum*fac[n]%ntf<<"\n";
	return 0;
}
```

---

## 作者：vegetable_king (赞：1)

[可能更好的阅读体验](https://yjh965.github.io/post/p12735-hui-bao-ti-jie/)

由于某些原因，文中所有的“钦定”都被替换成了“按住”。

题目中的合法条件显然等价于，存在一个序列的分界点，使得分界点左边存在至少一个 $i$ 个大小为 $A$ 的置换环，右边存在至少一个大小为 $B$ 的置换环，“存在”“至少”这些词汇自然将我们导向容斥。

考虑对于一个合法分界点，强制按住左边有 $i$ 个大小为 $A$ 的置换环，右边有 $j$ 个大小为 $B$ 的置换环（显然需要使得 $i, j > 0$）。那么这样做的容斥系数则为 $(-1)^{i - 1}(-1)^{j - 1}$，也就是 $(-1)^{i + j}$。

那么我们观察到，对于一个排列，它的合法分界点显然是一个区间，所以我们可以使用点边容斥，但是这样时间复杂度里会多出来一个 $n$。

实际上我们并不关心分界点具体位于哪里，所以先确定好这 $i + j$ 个置换环的形态，再将剩余的数归并进来就可以直接省掉这个枚举分界点具体位置的过程。

设 $f_i$ 表示长为 $i \times A$ 的排列恰好形成 $i$ 个大小为 $A$ 的置换环的方案数，$g_i$ 表示长为 $i \times B$ 的排列恰好形成 $i$ 个大小为 $B$ 的置换环的方案数，那么我们可以列出答案式子：
$$
\sum_{i = 1}^{n / A} \sum_{j = 1}^{n / B} (-1)^{i + j} \frac{n!}{(iA + jB)!} f_i g_j
$$
暴力计算时间复杂度为 $\mathcal{O}(\frac{n^2}{AB})$。这个东西显然是可以写成卷积形式的，所以可以简单做到 $\mathcal{O}(n \log n)$。

顺带一提，如果你不会 NTT 但是又不想只拿 $77$ 分（但是场上好像也没人有 $77$），由于当 $B = 1$ 时有所有的 $g_i = 1$，所以我们只需要对阶乘的倒数做前缀和，就可以 $\mathcal{O}(n)$ 做这个性质了，成功在不使用十级算法的基础上获得 $97$ 分（$A = 1$ 也是同理）。

代码删去了多项式类以及 `modint` 类。

```cpp
// 全身全霊！MORE MORE JUMP!!
const int N = 1000005;poly f, g;
int n, A, B;mint fac[N], ifc[N], ans;
int main(){cin >> n >> A >> B, f.resize(n + 1), g.resize(n + 1);
	fac[0] = ifc[0] = f[0] = g[0] = 1;
	for (int i = 1;i <= n;i ++) fac[i] = fac[i - 1] * i, ifc[i] = ifc[i - 1] / i;
	for (int i = A;i <= n;i += A) f[i] = f[i - A] * fac[i - 1] * ifc[i - A];
	for (int i = A;i <= n;i += A + A) f[i] = -f[i];
	for (int i = B;i <= n;i += B) g[i] = g[i - B] * fac[i - 1] * ifc[i - B];
	for (int i = B;i <= n;i += B + B) g[i] = -g[i];
	f[0] = g[0] = 0, f = f * g;
	for (int i = 1;i <= n;i ++) ans += f[i] * ifc[i];
	ans *= fac[n], cout << ans;
}
```

---


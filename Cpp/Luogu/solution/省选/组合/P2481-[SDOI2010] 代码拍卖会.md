# [SDOI2010] 代码拍卖会

## 题目描述

随着 iPig 在 P++ 语言上的造诣日益提升，他形成了自己一套完整的代码库。猪王国想参加 POI 的童鞋们都争先恐后问 iPig 索要代码库。iPig 不想把代码库给所有想要的小猪，只想给其中的一部分既关系好又肯出钱的小猪，于是他决定举行了一个超大型拍卖会。

在拍卖会上，所有的 $N$ 头小猪将会按照和 iPig 的好感度从低到高，从左到右地在 iPig 面前站成一排。每个小猪身上都有 $9$ 猪币（与人民币汇率不明），从最左边开始，每个小猪依次举起一块牌子，上面写上想付出的买代码库的猪币数量（$1$ 到 $9$ 之间的一个整数）。大家都知道，如果自己付的钱比左边的猪少，肯定得不到梦寐以求的代码库，因此从第二只起，每只猪出的钱都大于等于左边猪出的价钱。最终出的钱最多的小猪（们）会得到 iPig 的代码库真传，向着保送 PKU（Pig Kingdom University）的梦想前进。

iPig 对自己想到的这个点子感到十分满意，在去现场的路上，iPig 就在想象拍卖会上会出现的场景，例如一共会出现多少种出价情况之类的问题，但这些问题都太简单了，iPig 早已不感兴趣了，他想要去研究更加困难的问题。iPig 发现如果他从台上往下看，所有小猪举的牌子从左到右将会正好构成一个 $N$ 位的整数，他现在想要挑战的问题是所有可能构成的整数中能正好被 $P$ 整除的有多少个。由于答案过大，他只想要知道答案 $\bmod\ 999911659$ 就行了。

## 说明/提示

### 样例解释

方案可以是：$12,\allowbreak 15,\allowbreak 18,\allowbreak 24,\allowbreak 27,\allowbreak 33,\allowbreak 36,\allowbreak 39,\allowbreak 45,\allowbreak 48,\allowbreak 57,\allowbreak 66,\allowbreak 69,\allowbreak 78,\allowbreak 99$，共 $15$ 种。

### 数据规模

![](https://cdn.luogu.com.cn/upload/image_hosting/y0nme218.png)


## 样例 #1

### 输入

```
2 3```

### 输出

```
15```

# 题解

## 作者：Imakf (赞：67)

## 题意转化

本题的转化非常妙妙！

对于任何一个猪猪举牌的方案，都可以看做 $9$ 个以内的**若干 “$1$ 的后缀”相加而成**！

感性理解如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/2j96qblu.png)

于是我们把一个方案拆成了若干的形如 $00000...11111$ 的数字相加！

-----

题目中让我们求 $\mod p$ 意义下为 $0$ 的方案数。

想想怎么做？

我们可以把一个数分割成若干个 $000000...11111$ 的和。

所以我们可以计算出 $n$ 个 “$1$ 的后缀”在 $\mod p$ 意义下 的值。

因为可以选至多 $9$ 种后缀，所以就可以跑 $O(n^9)$ 暴力！

~~然而这一个点都过不去啊~~

其实我们可以直接把 $\mod p$ 意义下有相同数值的后缀看成同一类

比如 $11$ 和 $1$ 在 $\mod 5$ 意义下是同一类。

**不妨记 $g[i]$ 为 $\mod p$ 意义下[余数是 $i$ 的“$1$ 的后缀”]的数量。**

(最后再讲 $g[i]$ 的求法，想看可以直接跳)

我们就可以不用暴力

而是做一个背包的转移就好了！

## 背包

设 $dp[i][j][s]$ 表示当前考虑到余数为 $i$ 的 “$1$ 的后缀”，此前已经放上了 $j$ 个“$1$ 的后缀”，此时构成的数字的 $\mod p$ 的余数是 $s$ 的方案数。

枚举“$1$ 的后缀”$\mod p$ 意义下的余数 $O(p)$，记为 $i$。

枚举当前已经铺了几个“$1$ 的后缀”。$O(9)$，记为 $j$。

为什么是 $O(9)$，因为最左边的猪是不能出价为 $0$ 的，**所以最初要强制铺一层全 **$1$。

枚举当前这种 “$1$ 的后缀”铺了几个。$O(9)$，记为 $s$。

枚举转移过来的状态$\mod p$ 意义下的余数。$O(p)$，记为 $d$。

则转移方程是：

$$dp[p][s+j][(d+s*i+p)\%p]+=\sum\limits \dbinom{g[i]+s-1}{s}dp[p-1][j][d]$$

这个 $\dbinom{g[i]+s-1}{s}$ 是什么呢？

就是在 $g[i]$ 中选 $s$ 个同种 “$1$ 的后缀”有多少种不同的方法！

证明即隔板法。

复杂度即 $O(81p^2)$

至于怎么计算这个组合数，直接按定义计算就好。

----

## 循环节的计算

那么怎么计算 $g[]$ 数组呢？

~~普及组知识？~~

定义 $s_i$ 表示 $i$ 个 $1$ 连起来形成的数, $f_i$ 为它在 $\mod p$ 意义下的值。

如 $s_5=11111$

$f_3=1\mod 5$

则显然有 $f_i=(10\times f_{i-1}+1)\%p$

显然这柿子在 $2p$ 次迭代内必然会出现循环。

可以把 $f_i$ 分成三段：

- 未进入循环段

- 循环段

- 不完整循环段

暴力统计 未进入和不完整 的，用循环节搞定循环的就好了。

代码如下：

```cpp
#include <cstring>
#include <iostream>
using namespace std;

#define mod (999911659LL)
#define MX (500 + 5)
#define LL long long

LL qpow(LL x ,LL y ,LL P){
	if(!y)	return 1;
	if(y == 1)	return x;
	LL t = qpow(x ,y >> 1 ,P);
	if(y & 1)	return t * t % P * x % P;
	return t * t % P;
}
LL g[MX] ,n ,p ,cycLen ,cycstNum;
int cycle[MX * MX] ,first[MX];
LL dp[MX][11][MX];
LL C(LL n ,LL m){
	if(m < 0)	return 0;
	LL fz = 1 ,fm = 1;
	for(int i = 0 ; i < m; ++i){
		(fz *= n - i) %= mod;
		(fm *= m - i) %= mod;
	}
	return fz * qpow(fm ,mod - 2 ,mod) % mod;
}

int main(){
	// cout << C(10 ,7);
	memset(first ,-1 ,sizeof first);
	cin >> n >> p;
	cycle[0] = 1 % p;
	first[1 % p] = 0;
	LL addition = 0;
    // first 是该数第一次出现的位置
    // cycle 是按顺序出现的数 %p
	for(int i = 1 ; ; ++i){
		cycle[i] = (cycle[i - 1] * 10 + 1) % p;
		if(~first[cycle[i]]){
			for(int j = 0 ; j < i && j < n; ++j)
				g[cycle[j]]++ ,addition = cycle[j];
			n -= i;
			cycstNum = cycle[i];
			cycLen = i - first[cycle[i]];
			break;
		}
		first[cycle[i]] = i;
	}
	n = max(n ,0LL);
	LL times = n / cycLen;
	for(int i = 0 ; i < cycLen ; ++i)
		g[cycle[i + first[cycstNum]]] += times;
	LL nn = n % cycLen;
	for(int i = 0 ; i < nn ; ++i)
		g[cycle[i + first[cycstNum]]]++ ,addition = cycle[i + first[cycstNum]];
	for(int i = 0 ; i < p ; ++i)	g[i] %= mod;
    
    // 因为我很懒，按照上文博客
    // 在计算 dp[0][][] 的时候会调用 dp[-1][][] 导致 RE
    // 所以我是倒着来的，把 dp[0] 变成 dp[p] ，dp[1] 变成 dp[p - 1]...
	dp[p + 1][0][addition] = 1;
    // 此处 addition 是强制要求选择一次全 111111... 造成的代价
	for(int i = 0 ; i < p ; ++i){	// 枚举使用的 0000...1111 %p 意义的值  
		for(int j = 0 ; j < 9 ; ++j){	// 枚举已经使用次数 
			for(int s = 0 ; s + j < 9 ; ++s){	// 枚举当前使用次数 
				LL multi = C(g[i] + s - 1 ,s);
				for(int d = 0 ; d < p ; ++d){	// 枚举已经的余数 
					// if(dp[p - i + 1][j][d]){printf("dp[%lld][%d][%lld] += multi(%lld) * dp[%lld][%d][%d](%lld);\n" ,p - i ,s + j ,(d + s * i) % p ,multi ,p - i + 1 ,j ,d ,dp[p - i + 1][j][d]);}
					(dp[p - i][s + j][(d + s * i) % p] += multi * dp[p - i + 1][j][d]) %= mod;
				}
			}
		}
	}
	LL Ans = 0;
	
	for(int i = 0 ; i < 9 ; ++i){
		(Ans += dp[1][i][0]) %= mod;
	}

	cout << Ans << endl;
	return 0;
}

​```
```

---

## 作者：灯芯糕 (赞：27)

## $ solution: $ 

这道题调了好久好久，久到都要放弃了。洛谷的第五个点是真的强，简简单单一个1，调了快4个小时！

这道题第一眼怎么都是数位DP，奈何数据范围太大，只能找性质。而这道题最重要的一个性质也很套路（敲难想），因为我们所有的方案都是 $ 111112223333 $ 这样的数，我们要求的是它的大小模 $ p $ ，所以我们考虑将它用加法拆解。于是我们惊奇的发现它可以转化成（以上面那个数为例） $ 111111111111+1111111+1111=111112223333 $ 。正因为数位上的数字单调不降，所以它可以表示为不超过9个形似 $ 111...111 $ 的数的和！   

而这种形似 $ 1111...1111 $ 的数，我们可以发现，如果我们依次枚举它的长度（ $ 1,11,111,1111...... $ ）这些数在模 $ p $ 意义下一定会产生循环节。于是我们将在模 $ p $ 意义下同余的这类数归到一起，然后**用一个数组 $ g[i] $ 记录模 $ p $ 意义下为 $ i $ 的形如 $ 11111...111 $ 的数的个数**。（因为 $ p $ 不大，所以不用枚举多久就能找到循环节）

于是题目的意思就被转换成：从所有的 $ g[i] $ 中找出（不超过）九个数，使得它们的**下标之和**能被 $ p $ 整除！（为什么是下标之和？因为上面说了 $ g[i] $ 中所有的形如 $ 1111...111 $ 的数在模 $ p $ 意义下为 $ i $ ！）

所以这道题就变成了一道计数类DP，我们设 $ f[i][j][o] $ 表示：**已经选完了下标为 $ [0,i-1] $ 的数，从中选了 $ o $ 个形如 $ 1111...11 $ 的数，它们的和模 $ p $ 等于 $ j $ 的方案数**。 考虑它的转移，如果我们要从下标为 $ i $ 的数里选出 $ k $ 个数，显然这 $ k $ 个数是可以重复的，他们的贡献都为 $ i $ ，所以相当我们从 $ g[i] $  个数里可重复的选出 $ k $ 个数（不论怎么选他们的和都为 $ k*i $ ），根据组合计数原理这样的方案有 $ C_{g[i]+k-1}^{~~~~~k} $  种。为了方便博主代码里会用 $ C[i][k] $ 代替 $ C[~g[i]+k-1~][k] $ 。

#### $ f[i+1][~(j+k*i)~mod~p~][o+k]=f[i][j][o]*C[i][k] $ 



------

------



## $ code: $ 


```cpp
#include<iostream>
#include<cstdio>
#include<iomanip>
#include<algorithm>
#include<cstring>
#include<cstdlib>
#include<ctime>
#include<cmath>
#include<vector>
#include<queue>
#include<map>
#include<set>

#define ll long long
#define db double
#define rg register int

using namespace std;

const int mod=999911659; //答案的模数

ll n;
ll g[505]; //记录余数为i的形如11111的数的个数
int p,vn,ans; //循环节长度，小模数
int a[505]; //记录余数上一次的位置（找循环节用）
int inv[11]; //逆元
int c[505][11]; //组合数
int f[505][505][11]; //计数类DP

inline int qr(){
	register char ch; register bool sign=0; rg res=0;
	while(!isdigit(ch=getchar()))if(ch=='-')sign=1;
	while(isdigit(ch))res=res*10+(ch^48),ch=getchar();
	if(sign)return -res; else return res;
}

int main(){
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	scanf("%lld%d",&n,&p); inv[1]=1;
	if(n<=p) for(rg i=1;i<=n;++i) vn=(vn*10+1)%p,++g[vn];
	else{ rg tot=1%p,m,l;
		for(rg i=1;i<=p+1;++i){
			if(a[tot]){ l=a[tot]; m=i-l; break;} //找到循环节，计算循环节长度
			a[tot]=i; ++g[tot]; tot=(tot*10+1)%p; //记录当前余数出现位置，继续寻找
		}
		for(rg i=0;i<p;++i)
			if(a[i]&&a[i]>=l){
				g[i]+=(n-a[i])/m%mod; //记录所有余数为i的形如11111的数的个数
				if((a[i]-l+1)%m==(n-l+1)%m) vn=i; //记录长度为 n 的形如1111的数的余数，后面初始DP时有用
			}
	}
	for(rg i=2;i<9;++i) inv[i]=(ll)(mod-mod/i)*inv[mod%i]%mod; //线性递推求逆元
	for(rg i=0;i<p;++i){ c[i][0]=1; if(!g[i])continue;
		for(rg j=1;j<9;++j,g[i]=(g[i]+1)%mod) //注意最后还有个++g[i]！！！
			c[i][j]=(ll)c[i][j-1]*g[i]%mod*inv[j]%mod; //用性质求i较大,j较小的逆元
	}
	f[0][vn][0]=1; //最开始有一个长度为n的形如1111111111的数
	for(rg i=0;i<p;++i)
		for(rg j=0;j<p;++j)
			for(rg o=0;o<9;++o)
				for(rg k=0;k<9-o;++k) //枚举取出多少个余数为i的形如的11111111的数
					(f[i+1][(j+k*i)%p][k+o]+=(ll)f[i][j][o]*c[i][k]%mod)%=mod;
	for(rg i=0;i<9;++i) ans=(ans+f[p][0][i])%mod; //计算答案
	printf("%d\n",ans);
	return 0;
}

```

---

## 作者：MCAdam (赞：12)

$flag\times 1$：这不是SB题吗，随便一个数位DP就行了

这个拆分的$trick$好妙啊

$flag\times 2$：这个不就是简单的背包吗

怎么重复计算了呀！

-----以上为个人吐槽-------

题意：求$n$位的数字中，有多少个数字满足单调不减且能够被$p$整除

$n\leq 10^{18}\quad p\leq 500$

因为要数位单调不减，那么可以把一个数字拆分成一大堆后缀$1$相加而成

要使整个数字可以被$p$整除，也就是这些后缀$1$相加能够被$p$整除

到这里就有一个大致的思路了，首先计算出在模$p$意义下的每一个余数有多少个后缀$1$，然后计算把这些后缀$1$拼接起来的方案数

- 计算后缀$1$的个数

不妨设$g[i]$表示模$p$为$i$的后缀$1$个数

想像一下这个过程就行了：

一开始为$0$，然后不断往左边插入一个$1$，这个余数也不断在变化

当某个余数在前面出现过时，后面的就和前面的一样了，也就是有循环节了

所以直接扫一遍找到循环节，累加答案就行了，时间复杂度$O(p)$

```cpp
memset(vis,-1,sizeof(vis)),vis[0]=0;
for(int i=1;i<=p;i++)
{
	(now=now*10+1)%=p;
	if(vis[now]==-1) vis[now]=i,g[now]++;
	else{ pos=i; break; }
}
if(pos)
{
	int len=pos-vis[now],maxn;
	ll rest=n-(pos-1),cnt;
	cnt=rest/len,maxn=rest%len;
	for(int i=pos;i<=pos+len-1;i++)
	{
		g[now]+=cnt+(i-pos+1<=maxn);
		(now=now*10+1)%=p;
	}
}
```

- 计算拼接方案

计算完$g[i]$后，要把这些后缀拼接起来，要满足的限制有三个：

1.  最后长度为$n$

2. 加起来模$p$为$0$

3. 每一位不超过$9$（非常容易忽略的限制）

首先可以很容易先去掉第一个限制，因为长度为$n$，所以最高位肯定要放一个，这样就把第一个限制去掉了，不妨设最高位的后缀$1$模$p$为$q_1$

那么问题就转变为，在一堆后缀$1$中选最多$8$个，并且加起来模$p$为$p-q1$的方案数

这样就变成了一个很简单的问题了，直接做个背包就行了

设$f[i][j]$表示选了$i$个后缀，且加起来模数为$j$的方案数

$f[i+1][j+k]+=f[i][j]\times g[k]$

然后就做完了？？？这样计算是会重复计算的！

这样计算实际上是计算出了一个“排列”，也就是每个后缀$1$先后放进来的顺序对答案是会有影响的

但实际上我们需要的答案是一个“组合”

思考重复计算了哪些部分？即对于模$p$相同的，上面的计算过程考虑它们的顺序问题

既然如此，那就强制按照一个一个余数来转移，每个余数内部直接算

设$f[i][j][k]$表示考虑了前$i$个余数，选了$j$个，加起来模$p$为$k$的方案数

转移的时候，枚举当前这个余数选了多少个来转移就好了

注意在同一个余数中，是有$g[i]$中后缀$1$，每种后缀$1$是有无数个（即没有个数上限）的

所以内部转移的方案数应该是：$\displaystyle \binom{g[i]+t-1}{t}$

因为$g$很大，所以这个组合数直接套定义来算就好了

时间复杂度$O(9^2p^2)$

注意特判$p=1$的恶心情况

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <string>
#define ll long long
using namespace std;
const ll mod=999911659;
const int N=510;
int vis[N];
ll inv[10],g[N],f[N][10][N];
inline ll C(ll x,ll y)
{
	ll ans=1;
	for(ll i=x-y+1;i<=x;i++) ans=ans*i%mod;
	for(ll i=1;i<=y;i++) ans=ans*inv[i]%mod;
	return ans;
}
int main()
{
	inv[1]=1; for(int i=2;i<=8;i++) inv[i]=(mod-mod/i)*inv[mod%i]%mod;
	int p,now=0,pos=0,q1; ll n,ans=0;
	scanf("%lld%d",&n,&p);
	memset(vis,-1,sizeof(vis)),vis[0]=0;
	for(int i=1;i<=n;i++)
	{
		now=(now*10+1)%p;
		if(vis[now]==-1) vis[now]=i,g[now]++;
		else{ pos=i; break; }
	}
	if(pos)
	{
		int len=pos-vis[now],maxn;
		ll rest=n-(pos-1),cnt;
		cnt=rest/len,maxn=rest%len;
		for(int i=pos;i<=pos+len-1;i++)
		{
			if((i-pos+1)%len==maxn) q1=now;
			(g[now]+=cnt+(i-pos+1<=maxn))%=mod;
			now=(now*10+1)%p;
		}
	}
	f[0][0][0]=1;//取第i+1个余数，即i 
	for(int i=0;i<p;i++)
		for(int j=0;j<=8;j++)
			for(int k=0;k<p;k++)
				for(int t=0;t<=8-j;t++)
					(f[i+1][j+t][(k+(t*i))%p]+=f[i][j][k]*C(g[i]+t-1,t)%mod)%=mod;
	for(int i=0;i<=8;i++)
		ans=(ans+f[p][i][p==1?0:p-q1])%mod;
	printf("%lld\n",ans);
	return 0;
}
```


---

## 作者：bztMinamoto (赞：6)

打广告->[这里](https://www.cnblogs.com/bztMinamoto/p/9542722.html)

　　这题太神仙了……题解看都看不懂……最后基本只能硬生生的理解了……

　　首先，我们考虑数列，原数列是一个不降的序列

　　考虑如下数列，$1,1,2,3,4$

　　这样我们是相当于竖着分割的

　　那么怎么转换为横着分割呢？我们可以记录大于等于$1$的数的个数，为$5$，大于等于$2$的数的个数，为$3$……

　　那么最后原数列可以转化为$11111,111,11,1$（每个数用相同个数的$1$表示），然后我们惊奇的发现他们的和和原来的$n$位数是一样的，也就是说，他们构成的整数取模之后也是一样的！

　　这就相当于在每一个位置放相当于权值大小的石头，我们一开始是竖着分，而第二种方法是横着分割

　　如果竖着分割，总共有$n$个数，如果横着割，把所有模$p$同余的看成一类，那么总共只有$p$个数（因为0,1,11,111这样下去模$p$的值肯定能构成一个循环节，所以只需要计算$p$次，剩下的可以直接计算）

　　那么我们为什么不转化为横着分割呢？设$cnt[i]$表示模$p$为$i$的数的个数，那么题目就变成从$cnt[i]$中取$9$个使下标之和被$p$整除

　　那么就可以转化为dp了，设$f[i][j][k]$表示考虑到第$i$个数，选了$k$个，他们的和模$p$为$j$，那么状态转移方程就是$f[i+1][(j+l*i)\%mod][k+l]=(f[i][j][k]*C_{cnt_i}^l+f[i+1][(j+l*i)\%mod][k+l])\%mod$

　　然后要先考虑加上一个$11111$（$n$个$1$），因为我们dp的时候是允许有前导$0$的，所以得先强制至少为$1$才行

　　细节有点多，都写在注解里了
  
```
//minamoto
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define ll long long
using namespace std;
const int mod=999911659;
ll ans,n,p,cnt[505],beg,len,pos[505],A[11],c[505][11],f[505][505][11],a;
int main(){
	scanf("%lld%d",&n,&p);
	ll sum=0;
	if(n<=p){
		//直接把循环节跑出来 
		for(int i=1;i<=n;++i) sum=(sum*10+1)%p,++cnt[sum];
		a=sum;
	}else{
		//否则去找循环节，数出每一个余数的出现次数 
		for(int i=1;i<=p+1;++i){
			sum=(sum*10+1)%p;
			if(cnt[sum]){
				beg=pos[sum],len=i-pos[sum];
				break;
			}
			++cnt[sum],pos[sum]=i;
		}
		for(int i=0;i<p;++i)
		if(cnt[i]&&pos[i]>=beg){
			cnt[i]=(n-beg+1)/len;
			if(pos[i]-beg+1<=(n-beg+1)%len) ++cnt[i];
			if((pos[i]-beg+1)%len==(n-beg+1)%len) a=i;
		}
	}
	A[1]=1,A[0]=0;
	for(int i=2;i<=8;++i)
	A[i]=(mod-mod/i)*A[mod%i]%mod;
	for(int i=0;i<p;++i){
		c[i][0]=1;
		if(cnt[i])
		for(int j=1;j<=8;++j){
			c[i][j]=cnt[i]*c[i][j-1]%mod*A[j]%mod;
			cnt[i]=(cnt[i]+1)%mod;
			//C(n,m-1)->C(n,m)
			//C(n,m-1)/m*(n-m+1)=C(n,m)
			//cnt[i]=n-m+1
		}
	}
	f[0][a][0]=1;
	//默认加n个1，因为dp的时候可以有前缀0 
	for(int i=0;i<p;++i)
	for(int j=0;j<p;++j)
	for(int k=0;k<9;++k)
	for(int l=0;l<=k;++l)
	(f[i+1][j][k]+=f[i][(j-(l*i%p)+p)%p][k-l]*c[i][l]%mod)%mod;
	for(int i=0;i<=8;++i) (ans+=f[p][0][i])%=mod;
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：xyz32768 (赞：5)

看上去是一个显然的数位 dp ，但是看到 $N\le 10^{18}$ 的数据范围就发现不是那么容易了。

本题的思路最巨之处就在于：

**将 1111111...222222...333333...44444...5555... 式的数拆成不到 9 个形如 11111111111 的数之和，并且至少要有一个 111111111111111111111111111...111( N 个 1 ) 。**

又由于 $11111111111111111...111$ 形式的数对 $P$ 取模的值随 $1$ 的个数满足周期性变化，所以我们可以用一个数组 $cnt[]$ ，储存：

$cnt[i]$ 表示 $111111111111111111...11111$ （ $1\le1$ 的个数 $\le N$）形式的数有多少个。可以利用周期性预处理出。

从小到大考虑 $11111111111111111...11$ 形式的数，可以 dp 辣！

$f[i][j][k]$ 表示考虑到 $cnt[i]$ ， 使用 $k$ 个 $11111...111$ 形式的数，它们之和模 $P$ 的值为 $j$ 的方案数

（注意 $k$ 的上界是 $8$ 不是 $9$ ，最后我们还要加上 $111111111111111...111$ （ $N$ 个 $1$））

前置公式： $n$ 种元素，每种元素有无穷多个，从中取出 $m$ 个元素的不同方案数为 $\binom{n+m-1}m$ 。

边界：

$$f[0][0][k]=\binom{cnt[0]+k-1}k$$

注意到 $cnt$ 的值很大但 $k$ 的值很小，组合数可以预处理。

枚举使用的模 $P$ 为 $i$ 的 $1111111111111111111...111$ 的个数 $h$ （ $0\le h\le k$ ） ，就能实现转移。

$$f[i][j][k]=\sum_{h=0}^k\binom{cnt[i]+h-1}hf[i-1][(j-ih\bmod P+P)\bmod P][k-h]$$

答案：

$$\sum_{k=0}^8f[P-1][(P-(111...111(N个1)))\bmod P][k]$$

这种拆分成 $111111111111111111111111111111111111...111$ 的思路真的很难想到。

代码：

```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#define For(i, a, b) for (i = a; i <= b; i++)
#define Rof(i, a, b) for (i = a; i >= b; i--)
typedef long long ll; using namespace std;
const int N = 505, M = 1e5 + 5, E = 11, PYZ = 999911659;
int CYX, b[M], f[N][N][E], dalao, orz[N], fac[N], inv[N], otz[N][N];
ll n, cnt[N];
int qpow(int a, int b) {
	int res = 1; while (b)  b & 1 ? res = 1ll * res * a % PYZ : 0,
		a = 1ll * a * a % PYZ, b >>= 1; return res;
}
int main() {
	int i, j, k, h, rep, len, gap, ans = 0;
	cin >> n >> CYX; For (i, 1, 2147483647) {
		b[i] = (b[i - 1] * 10 + 1) % CYX;
		if (orz[b[i]]) {rep = orz[b[i]]; len = i; break;}
		orz[b[i]] = i;
	}
	For (i, 1, min(1ll * rep - 1, n)) cnt[b[i]]++;
	gap = len - rep; if (rep <= n) For (i, rep, len - 1) {
		cnt[b[i]] += (n / gap + (i % gap <= n % gap))
			- ((rep - 1) / gap + (i % gap <= (rep - 1) % gap));
		if (n % gap == i % gap) dalao = b[i];
	}
	fac[0] = 1; For (i, 1, 20) fac[i] = 1ll * fac[i - 1] * i % PYZ;
	inv[20] = qpow(fac[20], PYZ - 2); Rof (i, 19, 0)
		inv[i] = 1ll * inv[i + 1] * (i + 1) % PYZ;
	For (i, 0, CYX - 1) {
		if (!cnt[i]) {
			otz[i][0] = 1; For (j, 1, 20) otz[i][j] = 0; continue;
		}
		otz[i][0] = 1; For (j, 1, 20) otz[i][j] = 1ll * otz[i][j - 1]
			* ((cnt[i] + j - 1) % PYZ) % PYZ;
		For (j, 1, 20) otz[i][j] = 1ll * otz[i][j] * inv[j] % PYZ;
	}
	For (i, 0, 8) f[0][0][i] = otz[0][i];
	For (i, 1, CYX - 1) For (j, 0, CYX - 1) For (k, 0, 8) For (h, 0, k)
		f[i][j][k] = (f[i][j][k] + 1ll * f[i - 1]
			[(j - i * h % CYX + CYX) % CYX][k - h] * otz[i][h] % PYZ) % PYZ;
	For (i, 0, 8) ans = (ans + f[CYX - 1][(CYX - dalao) % CYX][i]) % PYZ;
	cout << ans << endl; return 0;
}
```

---

## 作者：Piwry (赞：3)

其实感觉这题正解不太算数位 dp（从UltiMadow 的题单来到这里qaq）...毕竟没有经典的按数位统计答案的部分，甚至也和数位搭不上边。不过如果考虑部分分的话还是有数位 dp 成分的X

## 解析

如果 $n$ 较小，其实有一种很简单数位 dp 思路：设 $dp(i, k, r)$ 为放到第 $i$ 为，该位为 $k$，已放的数位带权（数位权，例如从低到高第 $1$ 位带权 $10^0$）和模 $p$ 的余数；再预处理下数位权模 $p$ 的值（因为是会循环的），就可以做到 $O(1)$ 转移；总复杂度 $O(n)$

然而 $n\leq 10^{18}$，显然不能这样做

&nbsp;

首先要想出一个对这题很重要的推论（这个方向想对了这题就做出一半了）

先设 $f(x)=\sum\limits_{i=0}^{x-1}10^i$。$f(x)$ 的值实际上就是一个长度为 $x$，各数位都是 $1$ 的数字

考虑这样一个数字：它由 $f(n)$ 和不超过八个的 $f(x), 0\leq x\leq n$ 相加而得

很显然不超过八个是为了避免进位。只要 yy 一下就可以发现这样的数字是一定符合题目要求的（证明应该可以考虑归纳X）

接着我们又有一个很显然的递推式：$f(x)=10\cdot f(x-1)+1$（思考下 $f(x)$ 的定义很快就能推出来了）

由于我们只关心最后的和能否被 $p$ 整除，于是相加的每个 $f(x)$ 在相加前都可以先模 $p$，刚才那个递推式也可以在**模意义下**进行；而该递推式的后一项只取决于前一项，于是一旦它在某一刻取值重复，接下来的取值就会陷入**循环**。显然最多在递推 $p$ 次后它一定就会取值重复

这样我们就可以暴力模拟地找循环节。找到循环节后，我们就能预处理出模 $p$ 为 $r, 0\leq r < p$ 的 $f(x)$ 的数量

这样，题目就被转化为：从值为 $[0, p-1]$ 的一些元素中取 $9$ 个元素，有一个指定的元素必须取（$f(n)$），且要求取的元素的值的和模 $p$ 为 $0$，问有多少种方案

&nbsp;

接下来再考虑如何解决转化后的问题

其中指定取的元素其实是不用管的；我们只需知道该元素的值 $r$，并将要求的方案的条件变为 “和模 $p$ 为 $p-r$” 即可

首先可以类推背包想到一种 dp 的思路：设 $dp(k, r)$ 表示已经选了 $k$ 个元素，其和为 $r$ 的方案数。但在考虑转移时，由于我们并不清楚某一状态里究竟选了哪些 $f(x)$，因此没法计算出转移后的方案

一种例子是：$dp(k, 2r\mod p)$ 的方案包含两种方案 $\{f(a), f(b)\}, \{f(a), f(a)\}$，其中 $f(a)=f(b)=r\pmod p$，当我们转移至 $dp(k+1, 3r\mod p)$ 时，再往第一种方案加入一个 $f(a)$ 和再往第二种方案加入一个 $f(b)$ 得出的方案实际上是一样的，而我们在只记录方案数的情况下不可能得知这点

于是我们还需再加一维限制选取的元素集合。设 $dp(k, r, m)$ 表示已经选了 $k$ 个元素，其和为 $r$，选的元素的**种类编号**在 $[1, m]$ 范围内的方案数。这里的种类编号是对每模 $p$ 的余数 $r$ 相同的一组 “发放” 一个（因为在转移时我们只关心加入的元素对和的影响），顺序随意，从 $1$ 开始编号

这样我们的转移方程就为 $dp(k, r, m)=\sum\limits_{k'=0}^k\binom{cnt(m)+(k-k')-1}{cnt(m)-1}\cdot dp(k', (r-val(m)+p)\mod p, m-1)$

其中 $cnt(m)$ 指编号为 $m$ 的元素的个数，$val(m)$ 指编号为 $m$ 的元素模 $p$ 的值（在定义编号时，我们已经要求模 $p$ 的值相同的元素才能分到一种编号）

其中 $\binom{cnt(m)+(k-k')-1}{cnt(m)-1}$ 的组合意义为：从 $cnt(m)$ 种每种无穷多的元素中选 $(k-k')$ 个，问不同的选取方案数。证明可以考虑隔板法：我们有 $(cnt(m)+(k-k')-1)$ 个小球，用 $cnt(m)-1$ 个隔板成非空的 $cnt(m)$ 段，第 $i$ 段的个数 $x$ 即代表第 $i$ 种小球选了 $x-1$ 个

## CODE

注意在初始化时只需设 `dp[0][0][0] =1`

我在一开始还另外将最后一维（$m$）为每种可能的编号取值的 `dp` 数组都设为了 `1`，就像这样：

```cpp
for(int m =0; m <= tot; ++m)/*tot 就是编号总数*/
	dp[0][0][m] =1;
```

然而对于 `dp[0][0][m]`，$m\in[1, tot]$ 的这些状态，它们在 dp 时实际上又会被 `dp[0][0][0]` 再转移一次，导致贡献重复

当然也不能设 $m$ 这维表示 “...且每种至少一个”，那样的话答案就错了（可能有方案没选到某种标号）。这里主要的错误还是**初始化了在 dp 过程中会被递推出的方案**（且像这道题，递推时不是覆盖而是**相加**）

```cpp
#include <cstdio>
#define ll long long

const int M =999911659;

/*------------------------------Val------------------------------*/

ll n, p;
int val[501], tot;
ll cnt[501];/*模 p 为 r 的 f(x) 有多少*/

/*------------------------------C------------------------------*/

int inv[9];
int c_[501][9];

void pre(){
	inv[1] =1;
	for(int i =2; i <= 8; ++i)
		inv[i] =1ll*(M-M/i)*inv[M%i]%M;
	for(int m =1; m <= tot; ++m){
		c_[m][0] =1;
		for(int k =1; k <= 8; ++k){
			int tmp =1;
			for(int i =0; i < k; ++i)
				tmp =1ll*tmp*(cnt[m]%M+k-1-i)%M;
			for(int i =1; i <= k; ++i)
				tmp =1ll*tmp*inv[i]%M;
			c_[m][k] =tmp;
		}
	}
}

/*这里为了调用方便，m, k 不是原来的含义。原来的含义见下行*/
/*C(cnt[m]+k-1, k)*/
inline int C_(int m, int k){
	return c_[m][k];
}

/*------------------------------Main------------------------------*/

bool vis[500];
int pos[500];

/*已选 k 个 f(x)，它们的和模 p 为 r，当前选了标号为 [1, m] 的 f(x)，的方案*/
int dp[9][500][501];

int main(){
	scanf("%lld%lld", &n, &p);
	int rep =0, ii =1;
	for(int nw =1%p /*p == 1*/; !vis[nw] && ii <= n; nw =(nw*10+1)%p, ++ii, rep =nw){
		vis[nw] =1;
		pos[nw] =ii;
		val[++tot] =nw;
	}
	/*循环节小于 n 时，这一段算出来也是对的 ( 这时算法就相当于认为等于 n 了 X )*/
	int res =0;/*"1...1" ( n 个 1 ) 模 p 是多少，最后统计答案需要它 ( 因为这个串要强制选 )*/
	if(ii > n){
		for(int i =1; i <= n; ++i)
			cnt[i] =1;
		res =val[tot];
	}
	else{
		res =val[tot];
		rep =pos[rep];
		for(int i =1; i <= rep-1; ++i)
			cnt[i] =1;
		for(int i =rep; i <= tot; ++i)
			cnt[i] =(n-(rep-1))/(tot-rep+1);
		for(int i =rep; i <= (n-(rep-1))%(tot-rep+1); ++i)
			++cnt[i], res =val[i];
	}
	
	pre();
//	for(int m =0; m <= tot; ++m)
//		dp[0][0][m] =1;
	dp[0][0][0] =1;
	/*为了方便，这里的转移是倒着写的X*/
	for(int k =0; k <= 8; ++k)
		for(int m =0; m < tot; ++m)
			for(int r =0; r < p; ++r)
				for(int knet =k; knet <= 8; ++knet)
					(dp[knet][(r+val[m+1]*(knet-k))%p][m+1] +=1ll*C_(m+1, knet-k)*dp[k][r][m]%M) %=M;
	
	int ans =0;
	for(int i =0; i <= 8; ++i)
		(ans +=dp[i][(0-res+p)%p][tot]) %=M;
	printf("%d", ans);
}
```

---

## 作者：Kitahara_Haruki (赞：3)

### 感谢来自楼上大佬 ***bztMinamoto*** 的讲解


>对于一个各数位非递减的数

>>如1222333，我们可以将其分成$$1111111+111111+111$$

>>其中，每一项 1 的个数为 大于等于当前数字的个数（如≥1的有7个，≥2的有6个）

>>而这样划分的好处就在于，11...11 mod P 的值的个数≤P

>>若我们以 Cnt[i] 来记录满足 mod P == i 的 11...11的个数，那么最终的问题就转化为 从这些 Cnt 值中 选出不多于 9个值 来组成数列（**注意**：必须选取含有N个1的1....1来作为数位的第一项）

>>对于Cnt的求解本蒟蒻一直写挂（一开始写得极复杂），最终采用了大佬 ***bztMinamoto*** 的写法。。。


>对于这个新问题，我们使用动态规划来解决

>>令 Dist[i][j][k] 为 在前 i 个 cnt[i] 中选 k 个值 构成的 和 mod P == j 的方案数

>>$Dist[i+1][j][k]=\sum_{l=1}^k Dist[i][(P+ j-(i*l))modP][k-l]*C_{Cnt[i]+l-1}^l$

>>>其中 $C_{Cnt[i]+l-1}^l$ 指的就是从Cnt[i]个数中可重复地选取 l 个的方案数，证明如下：
>>>>从 x 个数中可重复选取 i 个数相当于 往 i 个格子里放 x 个球

>>>>采用隔板法，又因为允许放零个球的个子，所以方案数为$C_{x+i-1}^i$

>>>为了方便我们用C[i][j]来表示$C_{Cnt[i]+j-1}^j$


## 最后代码如下
```cpp
#include<queue>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
typedef unsigned long long ll;
const ll Mod=999911659;
const int Nn=502; const int Kn=12;
ll i,j,k,l,N,P,Fri,Ans,Beg,Sum,Len,Cnt[Nn],Pos[Nn],Inv[Kn],C[Nn][Kn],Dist[2][Nn][Kn];
//	Cnt 数组求解 
//	
//	Pos 记录 每个 111...111 mod P 第一次出现的位置
//	Fri 记录 N个1 组成的 111...111 mod P 的值 
//	Beg 记录 循环节头部第一次出现的位置   
//	Len 记录 循环节个数 
void Prepare_Cnt() {
	Sum=0;
	if(N<=P){for(i=1;i<=N;i++) {Sum=(Sum*10+1)%P; Cnt[Sum]++; } Fri=Sum; } //有≤1的循环节 
	else {																   //有len个循环节 
		for(i=1;i<=P+1;i++){
			Sum=(Sum*10+1)%P;
			if(Cnt[Sum]) {Beg=Pos[Sum]; Len=i-Beg; break;}  
			Cnt[Sum]++; Pos[Sum]=i;
		}
		for(i=0;i<P;i++) if(Cnt[i] && Pos[i]>=Beg){
			Cnt[i]=(N-Beg+1)/Len;
			if(Pos[i]-Beg+1<=(N-Beg+1)%Len) Cnt[i]++;					   //在Beg前多出的部分 
			if((Pos[i]-Beg+1)%Len==(N-Beg+1)%Len) Fri=i; 
		}
	}
}
// C 数组求法 
void Prepare_C() {
	for(i=0;i<P;i++){
		C[i][0]=1;
		if(Cnt[i]) for(j=1;j<9;j++) (C[i][j]=(C[i][j-1]*Cnt[i]%Mod)*Inv[j]%Mod)%=Mod,(Cnt[i]+=1)%=Mod;
	}
}
void Prepare_Inv() {Inv[1]=1; for(i=2;i<=9;i++) Inv[i]=(Inv[Mod%i]*((Mod-Mod/i)%Mod))%Mod;}
void NowBeginDp(){
	Dist[0][Fri][0]=1; Beg=0;
	for(i=0;i<P;i++,Beg^=1)
	for(j=0;j<P;j++)
	for(k=0;k<9;k++){
		Dist[Beg^1][j][k]=0;
		for(l=0;l<=k;l++)
		if(Dist[Beg][(P+j-(l*i%P))%P][k-l])
	 	  (Dist[Beg^1][j][k]+=Dist[Beg][(P+j-(l*i%P))%P][k-l]*C[i][l]%Mod)%=Mod;
	}
}
void NowSolveAns(){
	Ans=0;
	for(i=0;i<9;i++)
	 (Ans+=Dist[Beg][0][i])%=Mod;
	cout<<Ans<<endl;
}
int main(){
	ios::sync_with_stdio(false);
	cin>>N>>P;
	Prepare_Cnt(); Prepare_Inv(); Prepare_C();
	NowBeginDp(); NowSolveAns();
	return 0;
}

```





---

## 作者：Daidly (赞：2)

神仙题，而且细节很多。

- 将递增数列转化为不超过 $9$ 个全 $1$ 后缀之和。

也就是说，我们要选择不超过 $9$ 个全 $1$ 后缀，使得和整除 $P$。为了满足题目要求的 $n$ 位数，我们先钦定一个长为 $n$ 的全 $1$ 后缀，对剩下 $8$ 个计数。

- $\{p_i\},p_i=\Big(\sum\limits_{j=0}^{i-1}10^j\Big)\bmod P$ 具有长度不超过 $p$ 的循环节。（$p_i$ 指向 $p_{i+1}$ 且大小都小于 $P$，在 $2P$ 长度内一定会出现循环节）


- 循环节的处理，可能在循环节之前还有一段数，需要特殊处理。如果 $n$ 以内没有找到循环节，那就设为 $n$。

现在记 $g[i]$ 为全 $1$ 后缀模 $P$ 为 $i$ 的后缀个数，考虑 $f[i][j][k]$ 为在前 $i$ 个后缀中，选了 $j$ 个，和模 $P$ 等于 $k$。这里的前 $i$ 个指的是 $0\sim i-1$，否则无法设定边界。

对于转移，正向考虑 $f[i][j][k]$ 对其他值的贡献，枚举第 $i+1$ 类后缀（模 $P$ 为 $i+1$ 的）选 $num$ 个：

$$
f[i+1][j+num][(k+num\times(i+1))\bmod P]=\sum {num+g[i]-1\choose num}\times f[i][j][k]
$$

这个转移系数 ${num+g[i]-1\choose num}$ 来源于隔板法：余数为 $i+1$ 的后缀有 $g[i]$ 个，而要从里面选 $num$ 个，每个后缀被选次数不限。

换个方式理解：有 $g[i]$ 个箱子，有 $num$ 个球，要将这些球放进箱子里，允许空。答案即为 ${num+g[i]-1\choose g[i]-1}$，而 $g[i]$ 太大，转化为 ${num+g[i]-1\choose num}$ 更利于计算。 

组合数的计算方式也需要注意。由于 $num+g[i]-1$ 太大，无法预处理，所以我们采用 $O(num)$ 的方式直接计算。

```cpp
int C(int nn,int mm){
	if(mm==0ll)return 1ll;
	int ans1=1ll,ans2=1ll;
	for(int i=0;i<mm;++i){
		ans1=(ans1*(nn-i))%mod;
		ans2=(ans2*(mm-i))%mod;
	}
	return ans1*qpow(ans2,mod-2ll)%mod;
}
```

记 $C=8$，则在转移中计算复杂度为 $O(C^2P^2\log P)$，$C^2P^2$ 来源于枚举，$\log P$ 来源于快速幂。很难通过，只有 $50$ 分。发现转移系数 ${num+g[i]-1\choose num}$ 与 $k$ 无关（与 $i,j$ 有关，因为 $num\leq 8-j$），考虑先计算再枚举 $k$，复杂度 $O(C^2P^2)$。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;

#define int long long

inline int read(){
	int x=0,f=1;
	char c=getchar();
	while(c<'0'||c>'9'){
		if(c=='-')f=-1;
		c=getchar();
	}
	while(c<='9'&&c>='0'){
		x=(x<<1)+(x<<3)+(c^48);
		c=getchar();
	}
	return x*f;
}

void print(int x){
	if(x<0)putchar('-'),x=-x;
	if(x>9)print(x/10);
	putchar(x%10^48);
}

const int mod=999911659;
const int N=510;
int n,p,be,len,a[N],t[N],g[N],f[N][10][N],lst[N];

void init(){
	int tmp=1%p;
	for(int i=1;;++i){
		a[i]=tmp;
		if(lst[tmp]){
			len=i-lst[tmp];
			be=lst[tmp]-1;
			break;
		}else lst[tmp]=i;
		tmp=(tmp*10+1)%p;
	}
	if(len>=n)len=n;
	for(int i=1;i<=be;++i){
		g[a[i]]++;
	}
	for(int i=be+1;i<=be+len;++i){
		g[a[i]]=(g[a[i]]+(n-i)/len+1)%mod;
	}
}

int qpow(int A,int B){
	int ans=1ll;
	while(B){
		if(B&1)ans=ans*A%mod;
		A=A*A%mod;
		B>>=1ll;
	}
	return ans;
}

int C(int nn,int mm){
	if(mm==0ll)return 1ll;
	int ans1=1ll,ans2=1ll;
	for(int i=0;i<mm;++i){
		ans1=(ans1*(nn-i))%mod;
		ans2=(ans2*(mm-i))%mod;
	}
	return ans1*qpow(ans2,mod-2ll)%mod;
}

signed main(){
	n=read(),p=read();
	init();
	f[0][0][0]=1ll;
	for(int i=0;i<=p-1;++i){
		for(int j=0;j<=8;++j){
			for(int num=0;num<=8-j;++num){
				int tmp=C(num+g[i]-1,num);
				for(int k=0;k<p;++k){
					f[i+1][j+num][(k+num*i)%p]=(f[i+1][j+num][(k+num*i)%p]+tmp*f[i][j][k]%mod)%mod;
				}
			}
		}
	}
	int ans=0,tmp=(n-be)%len;
	if(!tmp)tmp=len;
	tmp+=be;
	tmp=(p-a[tmp])%p;
	for(int j=0;j<=8;++j){
		ans=(ans+f[p][j][tmp])%mod;
	}
	print(ans);
	return 0;
}
```
感觉有帮助就点个赞吧。

---

## 作者：XXX1234 (赞：1)

一个数 $A$，可以拆成 $9$ 个连续的 $1$ 的数字。  
设其分别为 $a_i$，那么 $a$ 满足 $\sum_{i=1}^9 a_i = A$。   

e.g:  
$A=111122223344556888$ 可以分成：  
$a_1=111111111111111111,\\
a_2=11111111111111,\\
a_3=1111111111,\\
a_4=11111111,\\
a_5=111111,\\
a_6=1111,\\
a_7=111,\\
a_8=111,\\
a_9=0$   

因此,我们只要先选长为 $n$ 的这种数字 $a_1$（属于 $1$），然后再选取长度 $\leq n$ 的 $8$ 个这种数字 $a_i(2\leq i\leq 9)$，使其和 $\sum_{i=1}^9 a_i \equiv 0 \pmod{p}$ 即可。   
当我们已经选取了一组数 $a$，不必要求 $a$ 里面的数字从大到小排好序。因为我们在选好后再进行排序，也能确定这组数对应的唯一一个数。（或者直接把 $a_i$ 相加也可以。）  
由于和要保证 $\sum_{i=1}^9 a_i \equiv 0 \pmod{p}$，因此选的数要确认其余数的值。  
于是便想到枚举余数，使用 dp 进行转移计算。  
由于易知 $\{0,1,11,111,1111,11111,111111...\}$ 这些数 $\bmod \,p$ 的余数会出现循环节，所以容易计算出有多少个数的余数对应 $\left[0,p-1\right]$ 中的每一个数。  
要注意不能先枚举 $i(1\leq i\leq 9)$，再枚举 $a_i\bmod p$ 的值，这样会重复。  
如： 

1. $a=\{1,1,2,3,5,3\}$ 和 $a=\{1,1,2,3,3,5\}$ 重复（这里 $a_i$ 是余数）（对应去重方法一）。   
2. $p=100$ 时，$a=\{1,1,11,111\}$ 和 $a=\{1,1,111,11\}$ 重复（这里 $a_i$ 是原数）（对应去重方法二）。   

为了不重复，一是在最外面枚举余数；二是枚举有几个数是这个余数，再用上组合数确保情况不会重复就可以了。  
 - 组合数怎么算：若枚举 $x$ 个数是这个余数，总共有 $y$ 个数的余数为这个数，那么便是 $C_{x+y-1}^{x}$。    

$dp[i][j][k]$ 有三个状态要记录，分别对应做完了余数为 $i$ 的情况，已经用了 $j$ 个数，现在余数为 $k$。   
答案就是 $dp[p-1][9][0]$。（可以开滚动数组优化）  

## Code：
```
#include<bits/stdc++.h>
using namespace std;
const int N=500;
const long long mod=999911659;
int p,a[N+5],pos,far;
int mark[N+5],sum;
long long n,c[N+5],inv[10];
long long dp[2][10][N+5];
#define Mod_(x) (x>=p?x-p:x)
#define MOD_(x) (x>=p?(x)%p:x)
#define Mod(x) (x>=mod?x-mod:x)
#define MOD(x) (x>=mod?(x)%mod:x)
long long Pow(long long x,long long d){
	if(!d)return 1;
	long long res=Pow(x,d>>1);
	if(d&1)return MOD(MOD(res*res)*x);
	return MOD(res*res);
}
inline void init(){
	memset(mark,-1,sizeof(mark));
	mark[0]=a[0]=0;
	for(int i=1;i<=p;i++){//最多会有p-1种余数 
		a[i]=(a[i-1]*10+1)%p;
		if(mark[a[i]]!=-1){
			pos=mark[a[i]];//循环节的开头 
			break;
		}
		mark[a[i]]=far=i;//循环节的末端 
	}
	for(int i=0;i<pos&&i<=n;i++)c[a[i]]++;//不在循环节中的数的个数 
	int len=far-pos+1,k=pos;
	//len循环节的长度，k不在循环节中的个数 
	for(int i=pos;i<=far&&i<=n;i++){//计算在循环节中的数的个数 
		c[a[i]]=(n+1-k)/len;
		if(i-pos+1<=(n+1-k)%len)c[a[i]]++;
	}
	
	for(int i=1;i<=9;i++)inv[i]=Pow(i,mod-2);//1-9的逆元 
	
	if(n<=far)sum=a[n];//题解中的a1的值 
	else sum=a[(n+1-k-1)%len+pos];
}
inline long long C(long long x,long long y){//组合数 
	if(y==0)return 1;
	if(x<y)return 0;
	if(x-y<y)y=x-y;
	long long res=1;
	for(long long i=x-y+1;i<=x;i++)res=MOD(res*MOD(i));
	for(int i=1;i<=y;i++)res=MOD(res*inv[i]);
	return res;
}
int main(){
	freopen("auction.in","r",stdin);
	freopen("auction.out","w",stdout);
	int la,is=1,now;
	scanf("%lld%d",&n,&p);
	init();
	dp[1][1][sum]=1;
	for(int i=0;i<p;i++){//枚举余数为i 
		la=is,is^=1;
		memset(dp[is],0,sizeof(dp[is]));
		for(int j=9;j>=1;j--){//枚举已经用了j个数 
			for(int k=j;k>=1;k--){//枚举之前用了k个数 
				now=MOD_((j-k)*i-1+p);//现在所选的数加上之前选的数的总和的余数 
				for(int g=0;g<p;g++){//枚举之前总和的余数 
					now=Mod_(now+1);//这样写减小常数 
					dp[is][j][now]+=dp[la][k][g]*C(c[i]+j-k-1,j-k);
					dp[is][j][now]=MOD(dp[is][j][now]);
				}
			}
		}
	}
	printf("%lld",dp[is][9][0]);
	fclose(stdin);
	fclose(stdout);
	return 0;
}
```

---

## 作者：不存在之人 (赞：1)

$DP$方法：

用$f[i][j][k]$表示枚举到$cnt[i]$，目前%$p$余数是$j$，已经用了$k$个形为$111…111$的数，但是注意到这样空间复杂度可能无法承受，而i对以后的递推并无影响，所以我们把i这一维换成滚动的，变成$f[kkz][j][k]$。

所以更新方法就是$[kkz]$[$(j+i×z)$%$p$][$k+z$]$=$($f[kkz]$[$(j+i×z)$%$p$]$[k+z]+1ll×f[kkz^1][j][k]×c[i][z])$%$modd$，其中$c[i][z]$表示从$cnt[i]$中选$z$个的种类数（可重复），枚举$z$即可。

几个注意点：

1. 要乘$1ll$($1LL$同义)；

1. $cnt[i]$要开$long long$；

1. 位运算要加括号！位运算要加括号！位运算要加括号！

1. $k==0?tot=i:1$和$tot=k==0?i:1$是有很大差别的。

```cpp
#include<cstdio>
#include<cstring>
#define ll long long
#define modd 999911659
using namespace std;
int p,f[2][500][10],i,j,k,z,tot,b[501],c[501][9],len,kkz,ans,inv[501];
ll n,cnt[501];
int getc(ll u,int v)
{
	int totn=inv[v];
	for(u%=modd;v--;totn=1ll*totn*u%modd,u--);
	return totn;
}
int main()
{
	scanf("%lld%d",&n,&p);
	if(n<=p)
	{
		for(i=j=1;j<n;j++,i=(i*10+1)%p) cnt[i]++;cnt[tot=i]++;
	} 
	else
	{
		for(b[i=1%p]=len=1;!b[i=(i*10+1)%p];b[i]=++len);
		k=len;len-=b[i]-1;
		for(i=1%p,j=1;j<=k;i=(i*10+1)%p,j++) cnt[i]=1;
		for(;j<=n&&j<=k+len;j++,i=(i*10+1)%p)
		{
			cnt[i]+=(n-j+1)/len+((n-j+1)%len!=0);
			(n-j)%len==0?tot=i:1;
		}
	}
	tot=(p-tot)%p;
	for(inv[0]=inv[1]=1,i=2;i<=15;i++) inv[i]=1ll*(modd-modd/i)*inv[modd%i]%modd;
	for(i=2;i<=15;i++) inv[i]=1ll*inv[i]*inv[i-1]%modd;
	for(i=0;i<p;i++)
	  	if(cnt[i])
	    	for(j=0;j<9;j++) c[i][j]=getc(cnt[i]+j-1,j);
	f[0][0][0]=1;
	if(cnt[0]) for(i=1;i<9;i++) f[0][0][i]=c[0][i];
	for(i=1;i<p;i++)
	  	if(cnt[i])
	  	{
			kkz^=1;
			memset(f[kkz],0,sizeof(f[kkz]));
			for(j=0;j<p;j++)
		  		for(k=0;k<9;k++)
		    		if(f[kkz^1][j][k])
		    			for(z=0;k+z<9;z++)
		    				f[kkz][(j+i*z)%p][k+z]=(f[kkz][(j+i*z)%p][k+z]+1ll*f[kkz^1][j][k]*c[i][z])%modd;
		}
	for(int i=0;i<9;i++) ans=(ans+f[kkz][tot][i])%modd;
	printf("%d\n",ans);
	return 0;
}
```

---


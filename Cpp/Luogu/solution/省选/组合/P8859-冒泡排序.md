# 冒泡排序

## 题目描述

有一个值域下标均为 $1\sim n$ 的排列或圆排列 $A$，定义 $f(A)$ 为将 $A$ 升序排序所需的最小操作次数。

每次操作中，你可以选择一个元素并向前**冒泡**若干次，一次**冒泡**定义为：若这个元素小于前一个元素，则可以交换它与前一个元素。当某次无法**冒泡**时，这次操作立即停止。否则可以连续**冒泡**任意次。

比如有排列 $[3,5,2,1,4]$，一次操作可以选择元素 $1$ ，得到排列 $[3,5,1,2,4],[3,1,5,2,4]$ 或 $[1,3,5,2,4]$ 。

若有圆排列 $[2,1,4,3]$，选择元素 $1$ 后可以得到圆排列 $[1,2,4,3],[3,2,4,1]$ 或 $[3,2,1,4]$ 。注意到圆排列中第 $1$ 个元素的前一个元素为第 $n$ 个元素。

排列或圆排列被升序排序，当且仅当对于所有 $\space 2 \leq i \leq n$，元素 $i$ 的前一个元素为元素 $i-1$。

给定 $n,k,type$，你需要：
- 在 $type=1$ 时求有多少长为 $n$ 的排列 $A$ 满足 $f(A)=k$ 。
- 在 $type=2$ 时求有多少长为 $n$ 的圆排列 $A$ 满足 $f(A)=k$ 。

答案对 $10^9+7$ 取模。

## 说明/提示

#### 【样例解释 #1】

有如下合法排列：

1. $[1,4,2,3]$
2. $[1,4,3,2]$
3. $[2,1,4,3]$
4. $[2,4,1,3]$
5. $[2,4,3,1]$
6. $[3,1,2,4]$
7. $[3,1,4,2]$
8. $[3,2,1,4]$
9. $[3,2,4,1]$
10. $[3,4,1,2]$
11. $[3,4,2,1]$

#### 【样例解释 #2】

有如下合法圆排列：

1. $[1,2,5,3,4]$
2. $[1,2,5,4,3]$
3. $[1,3,2,5,4]$
4. $[1,3,5,2,4]$
5. $[1,3,5,4,2]$
6. $[1,4,2,3,5]$
7. $[1,4,2,5,3]$
8. $[1,4,3,2,5]$
9. $[1,4,3,5,2]$
10. $[1,4,5,3,2]$
11. $[1,5,2,4,3]$
12. $[1,5,3,2,4]$
13. $[1,5,3,4,2]$
14. $[1,5,4,2,3]$

需要注意的是，我们认为 $[1,2,5,3,4]$ 和 $[2,5,3,4,1]$ 等是同一个圆排列。

也就是我们认为两个圆排列不同，当且仅当存在一个 $2 \leq i \leq n$，满足两个圆排列中元素 $i$ 的前一个元素不同。

#### 【数据范围】

|   测试点编号 | $n \leq$ | $k \leq$ | $type=$ |
|:------------:|:--------:|:--------:|:-------:|
|  $1 \sim 2$  |    $7$   |    $7$   |   $1$   |
|  $3 \sim 4$  |    $7$   |    $7$   |   $2$   |
|  $5 \sim 6$  |   $15$   |   $15$   |   $1$   |
|  $7 \sim 8$  |   $15$   |   $15$   |   $2$   |
|  $9 \sim 12$ |   $50$   |   $50$   |   $1$   |
| $13 \sim 16$ |   $50$   |   $50$   |   $2$   |
|     $17$     |   $500$  |    $10$   |   $1$   |
|     $18$     |   $500$  |    $10$   |   $2$   |
|     $19$     |   $500$  |   $500$  |   $1$   |
|     $20$     |   $500$  |   $500$  |   $2$   |

对于所有数据，$1 \leq k < n \leq 500$，$1 \leq type \leq 2$。  

## 样例 #1

### 输入

```
4 2 1```

### 输出

```
11```

## 样例 #2

### 输入

```
5 2 2```

### 输出

```
14```

## 样例 #3

### 输入

```
50 10 1```

### 输出

```
808620624```

## 样例 #4

### 输入

```
50 10 2```

### 输出

```
578144115```

# 题解

## 作者：OtoriEmu (赞：13)

按之前说的来写一篇详细一点的题解。

对于 $type=1$，如果一个数前面有比它更大的数，那这个数必须要进行操作。定义 $f_{i,j}$ 表示从大到小插入第 $i$ 个数，需要操作 $j$ 次使得其升序排序的排列数。第 $i$ 个数如果放在开头则不需要操作，否则必须多操作一次。转移式即 $f_{i+1,j} \overset{+}{\gets} f_{i,j},f_{i+1,j+1} \overset{+}{\gets} i\times f_{i,j}$（事实上，这就是第一类斯特林数）。

对于 $type=2$，我们先固定掉最大值的位置，比如将其放在最后一个位置。将这个圆排列强制变成排列，依用上面的方法，所有满足在这个位置上的数比前面的数都大的位置个数就是**不需要操作**的位置的个数。这样的数显然是更新了前缀的最大值，这引导我们想到笛卡尔树，不需要操作的位置的个数就相当于笛卡尔树上左链上点的个数。下面给出一个实例，例如 $p=(3,1,2,5,4,7,6,8)$：

![](https://cdn.luogu.com.cn/upload/image_hosting/fim6g1wz.png)

容易发现，$3,5,7,8$ 不需要操作。

接下来要处理位移的问题。一次位移相当于把最左边的数挪到最右边去。最左边的数在笛卡尔树上表现为左链上最下面的点，挪到右边相当于放到根的右子树。先不考虑放到右边的表现，注意到 $3$ 挪走之后，其右子树成为 $3$ 父亲新的左子树。从此可以看出，位移操作相当于将左链底的点挪到最右，并用其右子树替代这个点。最大**可以节省的**操作次数就是在所有通过位移能达到的状态中，左链上点的个数的最大值。

同时启发我们不用考虑被挪到右边去了会发生什么，因为其必然会操作，不管就行了。

分析这个最大值是什么，可以发现就是从根到某个点向左子树走的最多的次数加一。例如上面的例子中，$8 \to 1$ 总共向左子树走了四次，也即不需要操作的点最多有五个，可得最少操作次数为 $3$。

那么现在被转成了一个数树的问题。先把 $n$ 固定在最后面，需要统计有多少棵 $n-1$ 个点的二叉树满足从根到某个点向左子树走的最多的次数为 $n-k-1$。定义 $g_{i,j}$ 表示 $i$ 个点的二叉树可以节省的最多操作次数为 $j$。每次枚举左子树和右子树能节省的操作次数，记为 $p,q$，那么新的树能节省的操作次数即为 $\max(p+1,q)$。这样枚举 $i$ 并枚举左子树的大小 $j$，以及左右子树对应的 $p,q$ 可以得到一个 $O(n^4)$ 的做法（同时要带一个 $\dbinom{i-1}{j}$ 的系数，表示 $i$ 个数中，除去最值选 $j$ 个数来构成左子树，右子树就用剩下的）。

这个东西暴力写出转移之后，发现这个东西可以采取前缀和优化的方法去掉一个 $p,q$ 的枚举。具体方法是直接枚举 $\max(p+1,q)$，从前缀和转移到前缀和，差分求出原始的 $g$。

[完整代码](https://www.luogu.com.cn/paste/pqsd39rg)。

---

## 作者：绝顶我为峰 (赞：7)

## $type=1$

一个显然的贪心策略是我们从小到大检查每个 $i$，若 $i$ 已经在第 $i$ 个位置那么跳过，否则移动 $i$ 到正确位置，因为 $[i,n]$ 中 $i$ 一定是最小值所以一定可以操作，最优性也是显然的。

接下来考虑什么时候会省下一次操作，也就是 $i$ 已经在第 $i$ 位的情况。

移动 $1\sim i-1$ 的时候 $i\sim n$ 的相对顺序是不变的，因此如果初始排列中 $i$ 的前面有大于 $i$ 的数，就必须需要一次操作来复位，否则就可以省下一次操作。

于是 $f(A)=n-\sum\limits_{i=1}^n[a_i=\max\limits_{j=1}^i a_j]$，也就是总数减掉前缀最大值的个数。

dp，记 $f_{i,j}$ 表示 $i$ 个数前缀最大值数量是 $j$ 的排列数量，从 $i$ 转移到 $i+1$ 的时候加入最小值，显然只有最小值放在开头才有贡献，于是 $f_{i,j}=f_{i-1,j-1}+(i-1)f_{i-1,j}$，最终答案是 $f_{n,n-k}$，时间复杂度 $O(n^2)$。

这个转移其实就是第一类斯特林数，一种比较直观的理解是把前缀最大值加上他后面的这一段区间看成一个圆排列，前缀最大值是这个圆排列的代表元，容易证明这是一个双射。

## $type=2$

顺着上一问的思路继续，考虑 $f(A)=k$ 的环排列的性质。

第一次操作无法经过整个环，且后续操作不会经过 $1$，因此一定存在一个位置不会被操作，我们在这里断环为链，于是环排列的 $f(A)$ 就是对在每个位置断环为链之后求排列的答案取 $\min$，进一步转化为所有可能断出的排列中前缀最大值的 $\max$。

先考虑给定一个排列怎样求 $f(A)$，可以转化成图论问题求解。对于每个点在环上找到第一个在自己后面且大于自己的数字，向它连有向边，那么环排列的答案就是图中的最长路。

注意到有且仅有 $n$ 所在的位置没有出边，且所有位置的连边都不会跨过 $n$，所以我们不妨钦定 $n$ 在序列末尾，这样环就变成了链，且不会算重。

这样连边形成的结构是一个内向树，图中的最长路等价于将有向边视为无向边后，以 $n$ 为根的树高。

容易证明对于所有满足父亲节点编号小于儿子节点编号的生成树和 $n$ 在序列末尾的排列数量是双射，因此我们只要求出满足 $i$ 的父亲小于 $i$，以 $1$ 为根的生成树中树高是 $n-k$ 的树的数量就是答案。

还是 dp，记 $g_{i,j}$ 表示 $i$ 个点组成的树高是 $j$ 的树的数量，转移考虑合并 $1$ 的子树和 $2$ 的子树，枚举两边子树的深度可以得到转移方程 $g_{i+j,\max(d_1,d_2+1)}=\dbinom {i+j-2}{i-1}g_{i,d_1}g_{j,d_2}$。

直接转移是 $O(n^4)$ 的，记 $sum_{i,j}$ 表示 $i$ 个点组成的树高小于等于 $j$ 的树的数量，就可以直接前缀和转移，时间复杂度 $O(n^3)$。

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
const int mod=1e9+7;
int n,m,t,f[501][501],g[501][501],sum[501][501],c[501][501];
inline int Mod(int x)
{
	return x>=mod? x-mod:x;
}
int main()
{
	cin>>n>>m>>t;
	if(t==1)
	{
		f[1][0]=1;
		for(int i=2;i<=n;++i)
		{
			f[i][0]=1;
			for(int j=1;j<i;++j)
				f[i][j]=Mod(f[i-1][j]+1ll*(i-1)*f[i-1][j-1]%mod);
		}
		cout<<f[n][m]<<'\n';
	}
	else
	{
		c[0][0]=1;
		for(int i=1;i<=n;++i)
		{
			c[i][0]=1;
			for(int j=1;j<=n;++j)
				c[i][j]=Mod(c[i-1][j]+c[i-1][j-1]);
		}
		g[1][1]=1;
	    for(int i=1;i<=n;++i)
	        sum[1][i]=1;
	    for(int i=2;i<=n;++i)
	        for(int j=2;j<=n;++j)
	        {
	            if(j<=i)
	                for(int k=1;k<i;++k)
	                    g[i][j]=Mod(g[i][j]+1ll*c[i-2][k-1]*Mod(1ll*g[k][j]*sum[i-k][j-1]%mod+1ll*sum[k][j-1]*g[i-k][j-1]%mod)%mod);
	            sum[i][j]=Mod(sum[i][j-1]+g[i][j]);
	        }
	    cout<<g[n][n-m]<<'\n';
	}
	return 0;
}
```

---

## 作者：Tony2 (赞：3)

分析冒泡排序的最优过程，应该是先冒泡小的数再冒泡大的数。如果轮到某个数 $i$ 冒泡时这个数已经在位置 $i$ 上了，那它就不用冒泡了。

由此简单得出排列做法，从大到小向排列内插入数字，插入的位置不在最开头时需要付出一个代价冒泡。

在圆排列中第一个操作的是数字 $1$，这个数字可以付出一个代价冒泡到任何位置并固定。那么剩下的部分又成了排列。

假设我们把 $1$ 先丢掉，剩下的 $n-1$ 个数形成一个圆，有 $n-1$ 个缝隙，对应着 $n-1$ 种把圆劈开成排列的方法，对于每种方法我们计算出冒泡次数 $a_i$。假设 $1$ 一开始所在缝隙为 $a_1$，那么整个圆排列的冒泡代价就是 $\min(a_1,\min_{i=2}^{n-1}a_i+1)$。

但是这个 $a$ 是怎么生成的？分析它生成的过程。依然是从大到小向圆排列中插入数字。假设我们设排列的正方向为顺时针，即把圆排列劈开之后读取的顺序是顺时针。插入数字时所有的间隙的代价都要 $+1$ 除了插入位置逆时针侧的间隙。整体 $+1$ 太丑了，不如设新的 $b_i=S-a_i$，其中 $S$ 为当前圆排列的大小。操作方法变为讲间隙的代价 $x$ 分裂成 $x+1,x$，新的分裂在 $x$ 的逆时针侧。

每一种生成方法都对应了一种圆排列，但是生成的 $b$ 却没法对我们的圆排列起到什么指示作用。观察生成的方法，$x$ 的后面添加一个 $x+1$ 的过程提示我们这可以表现为在树的某个节点下接一个新的节点，则 $b$ 表现为树节点的深度 $+1$。

问题一下变得清晰了起来，每次插入的节点可以编号，刚好编号为在圆排列中插入的数字。这棵树只需要满足父亲编号比儿子大即可。圆排列中 $1$ 插入的位置可以看作选择一个节点 $u$。

回到冒泡代价式子，分析此式等于 $k$ 的条件为：

1. $\forall v\ de_v\le n-k-1$
2. $de_u=n-k-2\; \text{or}\; \exists v\ de_v=n-k-1$

剩下的部分就是无脑 dp。在建树过程中需要选一个符合条件的 $u$ 出来，设计状态 $f_{i,j,0/1/2}$ 表示大小为 $i$ 的树，最大深度为 $j$，第三个状态分别表示 $u$ 未选、$u$ 选了但是不是最大深度、$u$ 选了并且是最大深度。

暴力转移 $\Theta(n^4)$，加个前缀和优化就是 $\Theta(n^3)$。

```cpp
#include <bits/stdc++.h>
#define endl '\n'
using namespace std;
const int N = 505, mod = 1e9 + 7;
int n, k, type;
void upd(int &x, int y){
	x = (x + y) % mod;
}
namespace S1{
	int f[N][N];
	void solve(){
		f[n][0] = 1;
		for (int i = n; i > 1; i--)
			for (int j = 0; j <= n - i; j++){
				upd(f[i - 1][j + 1], 1ll * f[i][j] * (n - i + 1) % mod);
				upd(f[i - 1][j], f[i][j]);
			}
		cout << f[1][k];
	}
}
namespace S2{
	int C[N][N], f[N][N][3];
	void solve(){
		for (int i = 0; i <= n; i++){
			C[i][0] = 1;
			for (int j = 1; j <= i; j++)
				C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % mod;
		}
		f[1][0][0] = f[1][0][2] = 1;
		for (int i = 2; i < n; i++)
			for (int j = 1; j < i; j++){
				int c = C[i - 2][i - j - 1];
				for (int de1 = 0, sum = 0; de1 <= j; de1++){
					upd(f[i][de1][0], 1ll * f[j][de1][0] * sum % mod * c % mod);
					if (de1 <= i - j) sum = (sum + f[i - j][de1][0]) % mod;
				}
				for (int de2 = 0, sum = f[j][0][0]; de2 <= i - j; de2++){
					upd(f[i][de2 + 1][0], 1ll * f[i - j][de2][0] * sum % mod * c % mod);
					if (de2 + 1 <= j) sum = (sum + f[j][de2 + 1][0]) % mod;
				}
				for (int de1 = 0, sum1 = 0, sum2 = 0; de1 <= j; de1++){
					upd(f[i][de1][1], 1ll * f[j][de1][0] * sum1 % mod * c % mod);
					if (de1 <= i - j) sum1 = (sum1 + f[i - j][de1][1]) % mod;
					if (de1 && de1 <= i - j) sum1 = (sum1 + f[i - j][de1 - 1][2]) % mod;
					upd(f[i][de1][1], 1ll * f[j][de1][1] * sum2 % mod * c % mod);
					if (de1 <= i - j) sum2 = (sum2 + f[i - j][de1][0]) % mod;
				}
				for (int de2 = 0, sum = f[j][0][0]; de2 <= i - j; de2++){
					upd(f[i][de2 + 1][1], 1ll * f[i - j][de2][1] * sum % mod * c % mod);
					if (de2 + 1 <= j) sum = (sum + f[j][de2 + 1][0]) % mod;
				}
				for (int de2 = 0, sum = f[j][0][1]; de2 <= i - j; de2++){
					upd(f[i][de2 + 1][1], 1ll * f[i - j][de2][0] * sum % mod * c % mod);
					if (de2 + 1 <= j) sum = (sum + f[j][de2 + 1][1]) % mod;
				}
				for (int de2 = 0, sum = f[j][0][0]; de2 <= i - j; de2++){
					if (de2 + 1 <= j) sum = (sum + f[j][de2 + 1][0]) % mod;
					upd(f[i][de2 + 1][2], 1ll * f[i - j][de2][2] * sum % mod * c % mod);
				}
				for (int de1 = 0, sum = 0; de1 <= j; de1++){
					upd(f[i][de1][2], 1ll * f[j][de1][2] * sum % mod * c % mod);
					if (de1 <= i - j) sum = (sum + f[i - j][de1][0]) % mod;
				}
				for (int de2 = 0, sum = f[j][0][2]; de2 <= i - j; de2++){
					upd(f[i][de2 + 1][1], 1ll * f[i - j][de2][0] * sum % mod * c % mod);
					if (de2 + 1 <= j) sum = (sum + f[j][de2 + 1][2]) % mod;
				}
			}
		cout << ((f[n - 1][n - k - 1][1] + f[n - 1][n - k - 2][2]) % mod + mod) % mod;
	}
}
int main(){
	ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
//	freopen("in.txt", "r", stdin);
//	freopen("out.txt", "w", stdout);
	cin >> n >> k >> type;
	if (type == 1) S1::solve();
	else S2::solve();
	return 0;
}
```

---

## 作者：ZillionX (赞：3)

# Description

对于一个排列或圆排列，每次可以将一个元素向前冒泡若干次。求升序排序的最小操作次数为 $k$ 的排列或圆排列的个数。

$n,k \le 500$，时限 1s。

# Solution

深度好题，已收藏。

## Subtask 1

观察样例，容易发现的一个结论是：最优策略下，我们对于一个给定序列，每次选择冒泡的数是单调上升的。容易发现，在该策略下，若一个数前面不存在比它大的数，则它可以在比它小的数逐一归位后自动排到相应的位置，无需花费一次操作。

因此我们需要计算的就是存在恰好 $k$ 个数满足前面有数比它大的排列个数。下面称这样的数为“好数”。

这个显然可以记录目前摆放的数的最大值和已经产生的好数个数进行 DP。容易用滚动数组做到时间 $\mathcal O(n^3)$，空间 $\mathcal O(n^2)$，若实现精细可以通过。

```cpp
namespace typ1 {
	int f[2][N][N],g[2][N][N];
	void slv() {
		int u=0;
		f[0][0][0]=g[0][0][0]=1;
		for (int i=1;i<=n;i++) g[0][i][0]=1;
		for (int i=1;i<=n;i++) {
			u^=1;
			for (int j=0;j<=n;j++)
				for (int k=0;k<=i;k++)
					f[u][j][k]=g[u][j][k]=0;
			for (int j=i;j<=n;j++)
				for (int k=0;k<=i;k++) {
					if (k) mad(f[u][j][k],1ll*f[u^1][j][k-1]*(j-i+1)%mo);
					mad(f[u][j][k],g[u^1][j-1][k]);
					mad(g[u][j][k],f[u][j][k]);
				}
			for (int k=0;k<=i;k++)
				for (int j=i;j<=n;j++)
					mad(g[u][j][k],g[u][j-1][k]);
		}
		printf("%d",f[u][n][K]);
	}
}
```

## Subtask 2

我们首先考虑是否可以套用前面的结论得到这部分的答案。观察样例 $2$，容易发现我们可以钦定某个位置的数为 $i$，然后转化为统计排列的情况。但是这部分的条件非常特殊。通过暴力验证后可以发现需要满足的条件为：

对于该排列，所有循环同构的排列中好数 $\min$ 值为 $k$。

这个显然就不是很好统计。赛时想到这里就寄了。

不清楚这样的思路是否还能继续做下去。官方题解给出的是一种本质相同但简洁的思路。我们首先把原来那个好数个数 $=k$ 的条件转化为序列前缀最大值个数 $=n-k$。这个显然是一样的。那么我们上面的那个 $\min$ 也会变为 $\max$。

注意到样例 $2$ 中钦定的是第一个数为 $1$，我们事实上可以采取一种更巧妙的钦定方法，令第 $n$ 位为 $n$。容易发现这样可以将答案转化为：

统计对于一个序列，其每个后缀的前缀最大值个数 $\max$ 值为 $k$ 的序列个数。

接下来我们考虑这玩意怎么 DP。赛后 @gzw2005 教我的是一种基于笛卡尔树构造的方法，和下面即将说的解法本质相同，即对每个数向后面第一个大于它的数连边，转化为深度相关问题。这里不赘述，有兴趣的读者可以自行尝试。

官方题解给出的做法仍然基于笛卡尔树，我们从小到大插入每一个数，记 $f_{i,j}$ 为长度为 $i$ 的序列 $\max$ 值 $\le j$ 的序列个数。枚举插入的位置 $k$，容易发现转移为

$$f_{i,j} \leftarrow \binom{i-1}{k-1} f_{k-1,\min(j-1,k-1)} f_{i-k,\min(j,i-k)}$$

答案即为 $f_{n,k}-f_{n,k-1}$，时间复杂度 $\mathcal O(n^3)$。

```cpp
namespace typ2 {
	int f[N][N],fc[N],ifc[N];
	int qpow(int x,int y=mo-2) {
		int mul=1;
		for (;y;y>>=1,x=1ll*x*x%mo)
			if (y&1) mul=1ll*mul*x%mo;
		return mul;
	}
	void init() {
		fc[0]=1;
		for (int i=1;i<=n;i++) fc[i]=1ll*fc[i-1]*i%mo;
		ifc[n]=qpow(fc[n]);
		for (int i=n-1;i>=0;i--) ifc[i]=1ll*ifc[i+1]*(i+1)%mo;
	}
	int C(int n,int m) {
		if (n<m || n<0 || m<0) return 0;
		return 1ll*fc[n]*ifc[m]%mo*ifc[n-m]%mo;
	}
	void slv() {
		init();
		K=n-K;
		f[0][0]=1;
		for (int i=1;i<=n;i++)
			for (int j=1;j<=i;j++)
				if (i<n) for (int k=1;k<=i;k++)
					mad(f[i][j],1ll*C(i-1,k-1)*f[k-1][min(j-1,k-1)]%mo*f[i-k][min(j,i-k)]%mo);
				else mad(f[i][j],f[i-1][j-1]);
		printf("%d",mdf(f[n][K],f[n][K-1]));
	}
}
```


---

## 作者：Liveddd (赞：1)

先考虑 $\text{type}=1$ 的情况。考虑一个贪心策略，每次操作将该元素操作到一个比它小的元素为止。显然这样是最优的。所以一个元素是前缀最大值时是不用操作的，容易得到 $f(A)=n-\sum_{i=1}^{n} [a_i=\max_{j=1}^ia_j]$。考虑 DP，设 $f_{i,j}$ 表示选取 $i$ 个元素有 $j$ 个元素为前缀最大值，每次插入一个最小的元素进行转移。因为插在最前面才会有贡献，于是容易得到状态转移方程 $f_{i,j}\gets f_{i-1,j-1}+(i-1)\times f_{i-1,j}$。时间复杂度 $\mathcal O(n^2)$。

再考虑 $\text{type}=2$ 的情况。我们不妨直接固定元素 $n$ 为最后一个元素，直接转化为排列的情况。

因为必然会有一个点不会被移动，所以我们可以将前面连续的一段移到序列的末尾，可以视作没有花费，但是这些移到末尾的数是一定会被操作的（因为小于元素 $n$）。这样产生的 $n$ 个新的排列的 $f(A')$ 的最小值就是原排列的 $f(A)$。

还是设计状态 $f_{i,j}$ 表示选取 $i$ 个元素有 $j$ 个元素不用操作，考虑把最大的元素插入在两段的中间。设前面一段区间有 $p$ 个不用操作，后面一段区间有 $q$ 个不用操作。

我们可以选择直接将该元素插入到中间，那么不用操作的个数为 $p+1$；或者将前面一段区间加上该元素一起移到序列的末尾，这样不用操作的个数应该是 $q$，所以得到状态转移方程 $\displaystyle f_{i,\max \{p+1,q\}}\gets \binom{i-1}{j} f_{j,p}\times f_{i-j-1,q}$。通过前缀和可以做到 $\mathcal O(n^3)$。

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
const int N=5e2+10,mod=1e9+7;
template<class T>
inline void read(T &x)
{
    x=0;bool f=0;
    char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=1;ch=getchar();}
    while(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
    if(f)x=~x+1;
}
template<class T,class ...T1>
inline void read(T &x,T1 &...x1)
{
    read(x),read(x1...);
}
int n,m,type;
int C[N][N],f[N][N];
inline int adj(int x){return (x>=mod)?x-mod:x;}
inline void init()
{
    for(int i=0;i<=n;i++)C[i][0]=1;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
        C[i][j]=adj(C[i-1][j]+C[i-1][j-1]);
}
int main()
{
    read(n,m,type);
    m=n-m;
    if(type==1)
    {
        f[0][0]=1;
        for(int i=1;i<=n;i++)
            for(int j=1;j<=m;j++)
                f[i][j]=adj(f[i-1][j-1]+1ll*(i-1)*f[i-1][j]%mod);
        printf("%lld\n",f[n][m]);
    }
    if(type==2)
    {
        n--,m--;
        init();
        f[0][0]=1;
        for(int i=1;i<=n;i++)f[0][i]=f[1][i]=1;
        for(int i=2;i<=n;i++)
            for(int j=0;j<i;j++)
                for(int k=1;k<=n;k++)
                    f[i][k]=adj(f[i][k]+1ll*C[i-1][j]*f[j][k-1]%mod*f[i-j-1][k]%mod);
        printf("%lld\n",adj(f[n][m]-f[n][m-1]+mod));
    }
    return 0;
}
```

---

## 作者：UKE_Automation (赞：0)

### P8859 冒泡排序

[$\text{Link}$](https://www.luogu.com.cn/problem/P8859)

哥们又来做拼好题了。

- $type=1$：

  考虑从大到小往序列里插数，一个数需要进行冒泡操作当且仅当它前面有比它大的数，那么设 $dp(i,j)$ 表示当前插到第 $i$ 大的数，需要的操作数为 $j$ 的序列数，转移为：
  $$
  dp(i,j)=dp(i-1,j)+dp(i-1,j-1)\times(i-1)
  $$
  直接 $O(n^2)$ 转移即可。

- $type=2$：

  事实上本题的难点在这。我们先转化一下，把需要操作的数改为不需要操作的数，此时会发现不需要操作的数就是前缀最大值所在位置。这启发我们建出笛卡尔树，而前缀最大值个数就是左链上的节点个数。

  考虑将一个数从开头放到结尾对笛卡尔树的影响是什么，事实上就是把左链最下面的节点放到根节点的右子树，然后把这个节点的右子树接到原来的父亲下面。所以实际上对于一棵笛卡尔树，其最多的不需要操作的数的个数就是走到某个节点过程中往左走的次数。

  那么我们考虑对笛卡尔树 dp，先钦定 $n$ 为根，且它只有左子树，这样圆排列就可以转化为排列了。设 $dp(i,j)$ 表示 $i$ 个点构成的笛卡尔树，最多的不需要操作的数的个数为 $j$ 的方案数。容易得到转移方程：
  $$
  dp(i,\max(p+1,q))=\sum_{j=0}^{i-1} \binom{i-1}{j}\times dp(j,p)\times dp(i-j-1,q)
  $$
  直接转移是 $O(n^4)$ 的，无法通过，不过容易用前缀和优化至 $O(n^3)$。

```cpp
#include <bits/stdc++.h>
#define il inline

using namespace std;

const int Maxn = 5e2 + 5;
const int Inf = 2e9;
const int Mod = 1e9 + 7;
il int Add(int x, int y) {return x + y >= Mod ? x + y - Mod: x + y;} il void pls(int &x, int y) {x = Add(x, y);}
il int Del(int x, int y) {return x - y < 0 ? x - y + Mod : x - y;} il void sub(int &x, int y) {x = Del(x, y);}
il int qpow(int a, int b) {int res = 1; for(; b; a = 1ll * a * a % Mod, b >>= 1) if(b & 1) res = 1ll * res * a % Mod; return res;}
il int Inv(int a) {return qpow(a, Mod - 2);}
template <typename T> il void chkmax(T &x, T y) {x = (x >= y ? x : y);}
template <typename T> il void chkmin(T &x, T y) {x = (x <= y ? x : y);}
template <typename T>
il void read(T &x) {
	x = 0; char ch = getchar(); bool flg = 0;
	for(; ch < '0' || ch > '9'; ch = getchar()) flg = (ch == '-');
	for(; ch >= '0' && ch <= '9'; ch = getchar()) x = (x << 1) + (x << 3) + (ch ^ 48);
	flg ? x = -x : 0;
}
template <typename T>
il void write(T x, bool typ = 1) {
	static short Stk[50], Top = 0;
	x < 0 ? putchar('-'), x = -x : 0;
	do Stk[++Top] = x % 10, x /= 10; while(x);
	while(Top) putchar(Stk[Top--] | 48);
	typ ? putchar('\n') : putchar(' ');
}
il void IOS() {ios::sync_with_stdio(0); cin.tie(0), cout.tie(0);}
il void File() {freopen("in.txt", "r", stdin); freopen("out.txt", "w", stdout);}
bool Beg;

int n, k, typ;

namespace S1 {
	int dp[Maxn][Maxn];
	void main() {
		dp[0][0] = 1;
		for(int i = 1; i <= n; i++) {
			for(int j = 0; j <= k; j++) {
				dp[i][j] = Add(dp[i - 1][j], 1ll * dp[i - 1][j - 1] * (i - 1) % Mod);
			}
		}
		write(dp[n][k]);
	}
}

namespace S2 {
	int dp[Maxn][Maxn];
	int fac[Maxn], inv[Maxn];
	void init() {
		fac[0] = 1; for(int i = 1; i <= n; i++) fac[i] = 1ll * fac[i - 1] * i % Mod;
		inv[n] = Inv(fac[n]); for(int i = n; i >= 1; i--) inv[i - 1] = 1ll * inv[i] * i % Mod;
	}
	int C(int n, int m) {
		if(n < 0 || m < 0 || n < m) return 0;
		return 1ll * fac[n] * inv[m] % Mod * inv[n - m] % Mod;
	}
	void main() {
		init();
		k = n - k - 1, n--;
		for(int i = 0; i <= n; i++) dp[0][i] = 1;
		for(int i = 1; i <= n; i++) {
			for(int j = 0; j < i; j++) {
				for(int p = 1; p <= k; p++) {
					pls(dp[i][p], 1ll * C(i - 1, j) * dp[j][p - 1] % Mod * dp[i - j - 1][p] % Mod);
				}
			}
		}
		write(Del(dp[n][k], dp[n][k - 1]));
	}
}

bool End;
il void Usd() {cerr << (&Beg - &End) / 1024.0 / 1024.0 << "MB " << (double)clock() * 1000.0 / CLOCKS_PER_SEC << "ms\n"; }
int main() {
	read(n), read(k), read(typ);
	if(typ == 1) S1::main();
	else S2::main();
    Usd();
	return 0;
}


```

---

## 作者：simonG (赞：0)

对于 type1 的操作，我们先考虑如何计算最少操作数。

把数从大到小插入，如果一个数插入在第一位，那么是不贡献的；反之有 $1$ 的贡献。

不妨设 $f_{i,j}$ 表示填到 $i$，贡献为 $j$ 的方案数。转移显然。

现在考虑 type2 是一个环。那么你要求的就是所有循环同构的排列中最小值为 $k$ 的排列数。

这非常难处理。所以我们改一下条件，上述贡献为 $k$ 的条件可以写成前缀最大值有 $n-k$ 个。

我们要求所有以某位置开头，绕一圈形成的排列，前缀最大值最多有 $n-k$ 个的方案数。

因为我们要计数一个环排列，所以我们得钦定一个位置。

如果钦定最后一位是 $n$，就不用绕一圈，也就是求所有后缀的前缀最大值最多有 $n-k$ 个的排列数。

我们联想到笛卡尔树之类的结构。

所有后缀的前缀最大值最多是笛卡尔树上一条到根的链最多的向左走的边数。称为“左链”的长度。

所以我们考虑笛卡尔树来做一个 dp。对于一个区间，我们枚举其最大值的位置，分成两个小区间。

因为 $n$ 被我们钦定在最优，花费了一条左走的边，直接求向左走个数最大值 $= n-k-1$ 的方案数。

所以我们设 $dp_{len,now}$ 表示长度为 $len$ 的区间，当前左链的长度最长为 $now$ 的方案数，转移前缀和优化。

复杂度 $O(n^3)$。细节看代码。

```cpp
#include<algorithm>
#include<iostream>
#include<cstdio>
#include<cstring>
#include<vector>
using namespace std;
const int mod=1e9+7,N=505;
int n,k,type,f[N][N],sum[N][N],C[N][N];
int main() {
	scanf("%d%d%d",&n,&k,&type);
	C[0][0]=1;
	for(int i=1; i<=n; i++) {
		C[i][0]=1;
		for(int j=1; j<=i; j++)
			C[i][j]=(C[i-1][j-1]+C[i-1][j])%mod;
	}
	if(type==1) {
		f[0][0]=1;
		for(int i=1; i<=n; i++)
			for(int j=0; j<=k; j++) {
				if(j) f[i][j]=(f[i][j]+1ll*f[i-1][j-1]*(i-1))%mod;
				f[i][j]=(f[i][j]+f[i-1][j])%mod;
			}
		printf("%d\n",f[n][k]);
	} else {
		int lim=n-k-2;
		f[0][0]=f[1][0]=1;
		for(int i=0; i<=lim; i++) sum[0][i]=sum[1][i]=1;
		for(int i=2; i<=n-1; i++) {
			f[i][0]=1;
			for(int t=1; t<=lim; t++) {
				for(int j=1; j<i-1; j++) {
					int ls=j,rs=i-1-j;
					int tmp=(1ll*sum[ls][t-1]*f[rs][t]+1ll*f[ls][t-1]*sum[rs][t]-1ll*f[ls][t-1]*f[rs][t]%mod)%mod;
					f[i][t]=(f[i][t]+1ll*tmp*C[i-1][ls])%mod;
				}
				f[i][t]=(f[i][t]+(f[i-1][t-1]+f[i-1][t])%mod)%mod;
			}
			sum[i][0]=f[i][0];
			for(int t=1; t<=lim; t++) sum[i][t]=(sum[i][t-1]+f[i][t])%mod;
		}
		printf("%d\n",f[n-1][lim]);
	}
	return 0;
}
```

---

## 作者：Populus_euphratica (赞：0)

先来考虑 $type = 1$ 的情况。

可以发现，如果要当前数之前的最大值比这个数大，那么就要对这个数进行操作。

考虑根据这个设计的 DP 状态。

枚举最大值是不好做的，可以考虑从大到小插入，这样就可以解决大小关系。

设 $f_{i, j}$ 表示从大到小插入到了第 $i$ 个数，需要进行 $j$ 次操作。可以得到转移如下：
$$
f_{i, j} \to f_{i + 1, j}\\
f_{i, j} \times i \to f_{i + 1, j + 1}\\
$$
第一个转移式表示放到最前面就不会再产生操作，第二个表示放到后面有 $i$ 种放入方法。

该部分时间复杂度为 $O(n ^ 2)$。

接着来考虑 $type = 2$ 的情况。

圆排列直接不好枚举，可以固定一位，比如最后一位为最大值，那么根据上面的结论，我们可以发现，不进行贡献的数就是大于前面的最大值的数。

但是在圆排列上起点是不定的，所以直接找最大值并不方便，可以考虑对于一组排列把大小关系抽象出来，而对于上面的关系，可以用一颗笛卡尔树表示，而其中不进行贡献的数就是这颗笛卡尔树的左链。

接着考虑对序列进行一次操作落在笛卡尔树上是怎么样的。

手玩一下可以发现，每次操作就是把左链底移动到右边，然后把这个点的右儿子接到左链上去。

然后就会发现，不用操作的最大值就是根节点到某个节点向左走的步数加一。

这个也是手玩一下就可以发现。

由于要最后的操作次数为 $k$，那么不操作的次数就应该是 $n - k$，而且根节点一定往左走，所以对于再往下就是 $n - k - 1$。

那么就可以把问题转换为一颗 $n - 1$ 个节点的树，有多少种方法使得其最大的不用操作数（最大的往某个向左走的步数）为 $n - k - 1$。

考虑 DP。

记 $f_{i, j}$ 表示当前根节点为 $i$，最大的不用操作数为 $j$，可以得到如下转移：

记 $i$ 表示当前的根节点，$j$ 表示其左子树的大小，那么 $i - j - 1$ 就为其右子树大小。

$ls$ 表示左子树的最大的不用操作，$rs$ 表示右子树的最大的不用操作数，那么以 $i$ 为根的树的最大的不用操作数就为 $\max(ls + 1, rs)$，因为往左子树走的时候还会再往左走一步。

那么可以得到转移：
$$
f_{j, ls} \times f_{i - j - 1, rs} \times \binom{i - 1}{j} \to f_{i, \max(ls + 1, rs)}
$$
但是这样是 $O(n ^ 4)$ 的，考虑优化。

可以对于枚举的 $ls$ 和 $rs$ 可以使用前缀和优化，最后答案做个查分即可。

设 $f_{i, j}$ 表示以 $i$ 为根的树中，最大的不用操作数不超过 $j$ 的方案数之和。

记 $j$ 表示左子树的大小，$k$ 表示最大的不用操作数不超过 $k$。

可以得到转移：
$$
f_{j, k - 1} \times f_{i - j - 1, k} \times \binom{i - 1}{j} \to f_{i, j}
$$
最后答案为：
$$
f_{n - 1, n - k - 1} - f_{n - 1, n - k - 2}
$$
时间复杂度 $O(n ^ 3)$。

代码如下（注释掉的部分是 $n ^ 4$ 的那点）
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int Maxn = 510, mod = 1e9 + 7;
int n, k, ops;
int C[Maxn][Maxn];
int f[Maxn][Maxn];
signed main(){
	ios::sync_with_stdio(false);
	cin >> n >> k >> ops;
	if(ops == 1){
		f[0][0] = 1;
		for(int i = 0 ; i <= n ; i++){
			for(int j = 0 ; j <= k ; j++){
				f[i + 1][j] = (f[i + 1][j] + f[i][j]) % mod;
				f[i + 1][j + 1] = (f[i + 1][j + 1] + f[i][j] * i % mod) % mod;
			}
		}
		cout << f[n][k] << " ";
		cout << '\n';
		return 0;
	}
	for(int i = 0 ; i <= 500 ; i++){
		for(int j = 0 ; j <= i ; j++){
			if(i == 0 || j == 0) C[i][j] = 1;
			else C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % mod;
		}
	}
	// f[0][0] = 1;
	// for(int i = 1 ; i <= n ; i++){
	// 	for(int j = 0 ; j <= i ; j++){
	// 		for(int ls = 0 ; ls <= j ; ls++){
	// 			for(int rs = 0 ; rs <= i - 1 - j ; rs++){
	// 				f[i][max(ls + 1, rs)] = (f[i][max(ls + 1, rs)] + f[j][ls] * f[i - 1 - j][rs] % mod * C[i - 1][j] % mod) % mod;
	// 			}
	// 		}
	// 	}
	// }
	for(int i = 0 ; i <= n ; i++) f[0][i] = 1;
	for(int i = 1 ; i <= n ; i++){
		for(int j = 0 ; j < i ; j++){
			for(int k = 1 ; k <= i ; k++){
				f[i][k] = (f[i][k] + f[j][k - 1] * f[i - j - 1][k] % mod * C[i - 1][j] % mod) % mod;
			}
		}
		for(int j = i + 1 ; j <= n ; j++)
			f[i][j] = f[i][j - 1];
	}
	cout << (f[n - 1][n - k - 1] - f[n - 1][n - k - 2] + mod) % mod << '\n';
	return 0;
}
```

---


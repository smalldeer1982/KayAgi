# 【MX-X13-T6】「KDOI-12」能做到的也只不过是静等缘分耗尽的那一天。

## 题目背景

待到缘分耗尽，关系断裂，我们还会在一起吗？

## 题目描述

对于一个排列 $p_{1\sim n}$，建出其大根[笛卡尔树](https://www.luogu.com.cn/problem/P5854)，并断开每个点与其右儿子（如果存在）的连边，记最后所成的森林为 $T(p)$。

例如 $p_{1\sim 5} = [1, 3, 2, 5, 4]$，其大根笛卡尔树与 $T(p)$ 分别如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/6mikhar1.png)![](https://cdn.luogu.com.cn/upload/image_hosting/otv9hnhe.png)

在给定 $n, x, y$ 的情况下，你需要回答，在 $n!$ 种 $1\sim n$ 的排列 $p_{1\sim n}$ 中，有多少种 $p$ 使得节点 $x$ 与节点 $y$ 在 $T(p)$ 中属于同一棵树。**节点指的是编号而非在 $p$ 中的权值。**

由于答案可能很大，输出的答案需要对一个质数 $P$ 取模。

## 说明/提示

**【样例解释】**

对于样例的第一组测试数据：有 $[1, 2, 3, 4], [1, 3, 2, 4], [2, 1, 3, 4], [2, 3, 1, 4], [3, 1, 2, 4], [3, 2, 1, 4]$ 共 $6$ 种排列满足条件。

对于样例的第二组测试数据：任意 $1\sim 4$ 的排列均满足条件。

**【数据范围】**

**本题使用捆绑测试。**

| 子任务编号 | 分值 | $n\leq$ | $T\leq$ | 特殊性质 |
|:--:|:--:|:--:|:--:|:--:|
| $1$ | $5$ | $8$ | $10^6$ | 无 |
| $2$ | $15$ | $2000$ | $2000$ | 无 |
| $3$ | $15$ | $2000$ | $10^6$ | 无 |
| $4$ | $25$ | $5\times10^6$ | $20$ | 无 |
| $5$ | $15$ | $10^5$ | $10^6$ | A |
| $6$ | $25$ | $5\times10^6$ | $10^6$ | 无 |

* 特殊性质 A：$P=998244353$。

对于所有数据：$1\leq T\leq10^6$，$1\le x, y\le n\le 5\times 10^6$，$10^8\le P\le 10^9 + 7$ 且 $P$ 为质数。

**【提示】**

请使用较快的读入方式。

## 样例 #1

### 输入

```
10 1000000007
4 1 4
4 2 2
4 3 2
5 4 2
7 3 5
8 2 7
10 3 8
100 99 6
1000 234 789
5000 1234 4321```

### 输出

```
6
24
8
25
882
3840
270000
220955222
251832899
768412458
```

# 题解

## 作者：Scinerely (赞：3)

#### 题目描述

多次询问，每一次给出参数 $n,x,y$，求有多少个排列 $p_{1 \sim n}$ 在建立大根笛卡尔树后断掉所有连向右儿子的边，$x,y$ 仍然存在于同一棵树中。

$T \leq 10^6 ,n \leq 5\times 10^6$。

#### 第一步 基本性质的分析

这部分默认 $x<y$。

题目的要求是 $x,y$ 在笛卡尔树断掉所有连向右儿子的边后在同一颗树中。我们希望找到一个简单的约束来描述这个条件的等价条件。

我们记录 $P(x)$ 表示 $x$ 之前第一个比它权值更大的元素的下标，$S(x)$ 表示 $x$ 之后第一个比它权值更大的元素的下标。

##### 性质1：$x$ 和编号在 $P(x)$ 及之前的元素不会在同一棵树内

我们分析一下编号为 $x$ 的元素在大根笛卡尔树中的父亲是谁？那么 $x$ 的父亲一定是 $P(x),S(x)$ 中元素权值的较小者，但是这两个元素都会是 $x$ 的祖先。但是因为 $P(x)<x$，所以 $P(x)$ 走到 $x$ 一定会走连向右儿子的边，所以 $x$ 和编号在 $P(x)$ 及之前的元素不可能最终在一棵树中。

##### 性质2: $p[P(x)+1,x]$ 的所有前缀最大值在同一棵树内。

$P(x)=x-1$ 时，肯定成立。剩余部分归纳一下。

因为 $P(x)$ 不在序列内，并且 $x$ 是序列的最右侧点。那么 $x$ 的左儿子就是 $p[P(x)+1,x-1]$ 的最大值，他们肯定在一棵树内。假设 $y$ 就是这个最大值的下标，那么递归 $p[P(y)+1,y]$ 可得结论。

##### 性质3：$P(x)$ 和 $P(y)$ 相等是 $x,y$ 在同一棵树内的充分必要条件。

- 充分性：已知 $P(x)=P(y)$，则考虑 $p[P(y)+1,y]$ 这个子段，$x,y$ 都是前缀最大值。根据性质 $2$ 可得他们肯定在一棵树内。
- 必要性：如果 $x,y$ 在一棵树内，那么 $y$ 一定是 $x$ 的祖先，并且 $y$ 只通过左儿子走到 $x$。在笛卡尔树上，$P(y)$ 是满足编号比 $y$ 小的深度最浅的祖先，而由于 $y$ 和 $x$ 在一棵树内，所以根据性质 $1$ 有 $P(y)<x$。也就是说，$P(y)$ 也是满足编号比 $x$ 小的深度最浅的祖先，也就是 $P(x)$。

#### 第二步 计数的初步设计

这部分默认 $x<y$。如果 $x=y$，答案显然是 $n!$。

枚举 $P(x)$，因为这和我们判定 $x,y$ 是否在同一棵树内有关系。

注意到我们的结论和编号在 $P(x)$ 之前，$y$ 之后的元素并没有关系，所以我们先确定出 $p[P(x),y]$ 这一个子段两两元素之间的大小关系，然后将编号在 $P(x)$ 之前和 $y$ 之后的元素插入进来。现在我们计算 $p[P(x),y]$ 离散化后有多少种可能的序列，注意到 $P(x),y$ 分别是这个序列的最大值和次大值，所以我们进一步转化为 $p[P(x)+1,y-1]$ 有多少种可能的序列。

除了 $x$ 之外，有编号在 $(P(x),x)$ 和 $(x,y)$ 之间的元素。对于编号在 $(P(x),x)$ 之间的元素，不能比 $x$ 更大；对于编号在 $(x,y)$ 之间的元素，不提出特别要求。我们肯定优先填出 $p[P(x)+1,x]$ 的离散化序列，然后将编号在 $(x,y)$ 之间的元素插入进来。$p[P(x)+1,x]$ 只需要满足 $x$ 是最大值即可，所以方案数为 $(x-P(x)-1)!$。接下来需要将编号在 $(x,y)$ 之间的元素插入进来，产生 $C_{y-P(x)-1}^{x-P(x)}$ 的系数，而这部分数本身存在大小关系，进一步产生 $(y-x-1)!$ 的系数。这部分的答案就是:
$$
(x-P(x)-1)!\times C_{y-P(x)-1}^{x-P(x)}\times (y-x-1)!
$$

$$
= (x-P(x)-1)!\times \dfrac{(y-P(x)-1)!}{(x-P(x))!(y-x-1)!}\times (y-x-1)!
$$

$$
=\dfrac{(y-P(x)-1)!}{x-P(x)}
$$

接下来插入编号在 $P(x)$ 之前和 $y$ 之后的元素，产生 $C_{n}^{(P(x)-1)+(n-y)}\times (P(x)-1+n-y)!$ 的系数。这部分的答案就是：
$$
\dfrac{(y-P(x)-1)!}{x-P(x)}\times C_{n}^{P(x)-1+n-y}\times (P(x)-1+n-y)!
$$

$$
= \dfrac{(y-P(x)-1)!}{x-P(x)}\times \dfrac{n!}{(P(x)-1+n-y)!(y-P(x)+1)!}\times (P(x)-1+n-y)!
$$

$$
= \dfrac{n!}{(x-P(x))(y-P(x))(y-P(x)+1)}
$$

枚举每一个 $P(x)$ 即可做到线性。

有一种特殊情况，就是 $x,y$ 都是前缀最大值，$P(x)=P(y)=0$。容易使用和上述方法类似的方式得到此部分答案为 $\dfrac{n!}{xy}$。

#### 算法优化

这部分默认 $x<y$ 并且不考虑 $x,y$ 都是前缀最大值的情况。

我们需要计算的是：
$$
n!\sum_{i=1}^{x-1}\dfrac{1}{(x-i)(y-i)(y-i+1)}
$$
这个形式并不好看，我们枚举 $x-i$ 并令 $d=y-x$ 得到：
$$
n!\sum_{i=1}^{x-1}\dfrac{1}{(x-i)(y-i)(y-i+1)}=n!\sum_{i=1}^{x-1}\dfrac{1}{i(i+d)(i+d+1)}
$$
看到后面需要对 $\dfrac{1}{i(i+d)(i+d+1)}$ 求和，看起来只能将其尝试拆分为 $\dfrac{A}{i}+\dfrac{B}{i+d}+\dfrac{C}{i+d+1}$ 的形式了。那一定会满足：
$$
A(i+d)(i+d+1)+Bi(i+d+1)+Ci(i+d)=1
$$
暴力展开：
$$
A(i^2+2id+d^2+i+d)+B(i^2+id+i)+C(i^2+id)=1
$$

$$
(A+B+C)i^2+(2Ad+Bd+Cd+A+B)i+(Ad^2+Ad)=1
$$

因为 $i$ 是一个不可控的变量，所以考虑让 $A+B+C$ 和 $2Ad+Bd+Cd+A+B$ 都是 $0$，而 $Ad^2+Ad$ 是 $1$。

首先，我们可以通过 $Ad^2+Ad=1$ 得到 $Ad(d+1)=1$，推出 $A=\dfrac{1}{d(d+1)}$。

通过 $A+B+C=0$ 消元，使得 $C=-A-B$，带入到 $2Ad+Bd+Cd+A+B=0$ 中，得到：

 
$$
2Ad+Bd+(-A-B)d+A+B=0
$$

$$
Ad+A+B=0
$$

此时由于 $A$ 我们已经知道了，那么 $B=-(A+Ad)=-(\dfrac{1}{d(d+1)}+\dfrac{d}{d(d+1)})=-\dfrac{1}{d}$。

这个时候 $C=-A-B=\dfrac{1}{d}-\dfrac{1}{d(d+1)}=\dfrac{1}{d+1}$。

因为 $A,B,C$ 都只和 $d$ 有关，我们就知道可以简单计算了：
$$
n!\sum_{i=1}^{x-1}\dfrac{1}{i(i+d)(i+d+1)}=n!\sum_{i=1}^{x-1} \frac{A}{i}+\frac{B}{i+d}+\frac{C}{i+d+1}
$$
预处理出逆元的前缀和容易 $O(1)$ 回答。

时间复杂度 $O(n+T)$，轻松通过本题。

```c++
#include<bits/stdc++.h>
#define int long long
using namespace std;
inline int read(){
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-f;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
int buf[1<<10];
inline void print(int x,char ch=' '){
	if(x<0) putchar('-'),x=-x;
	int tot=0;
	do{
		buf[++tot]=x%10;
		x/=10;
	}while(x);
	for(int i=tot;i;i--)
		putchar(buf[i]+'0');
	putchar(ch);
}
const int MAXN=1e7+5;
int T,mod;
int fac[MAXN],inv[MAXN],sum[MAXN];

int n,x,y;
int solve1(int n,int x,int y){
	return fac[n]*inv[x]%mod*inv[y]%mod;
}
int solve2(int n,int x,int y){
	int ans=0,k=y-x;
	ans=inv[k]*inv[k+1]%mod*sum[x-1]%mod;
	ans=(ans-inv[k]*(sum[k+x-1]-sum[k]+mod)%mod+mod)%mod;
	ans=(ans+inv[k+1]*(sum[k+x]-sum[k+1]+mod))%mod;
	return ans*fac[n]%mod;
}
signed main(){
	T=read(),mod=read();
	fac[0]=1;
	for(int i=1;i<MAXN;i++) fac[i]=fac[i-1]*i%mod;
	inv[0]=inv[1]=1;
	for(int i=2;i<MAXN;i++)
		inv[i]=inv[mod%i]*(mod-mod/i)%mod;
	for(int i=1;i<MAXN;i++)
		sum[i]=(sum[i-1]+inv[i])%mod;
	
	while(T--){
		n=read(),x=read(),y=read();
		if(x==y){
			print(fac[n],'\n');
			continue;
		}
		if(x>y) swap(x,y);
		int ans=0;
		ans=(ans+solve1(n,x,y))%mod;
		ans=(ans+solve2(n,x,y))%mod;
		print(ans,'\n');
	}
	return 0;
}
```

---

## 作者：nullqtr_pwp (赞：3)

不妨设询问的 $x<y$，而 $x=y$ 是平凡的，答案为 $n!$。令 $lst_i$ 表示上一个 $j<i,a_j>a_i$。从 $x$ 跳父亲的过程要参考 $lst,nxt$，很难，但是左链往下跳拥有很简洁的性质。考虑由 $y$ 跳左链跳到 $x$ 上。关键性质是一个左链上的 $lst_i$ 一定是相等的。

枚举 $lst_y=p$，考虑 $[p+1,y]$ 的部分，由于从右往左每次是连剩余前缀的最大值，不难发现 $i$ 在 $y$ 开头的左链上当且仅当 $a_i$ 是 $[p+1,y]$ 的前缀最大值。因此我们只关心 $x$ 是否是 $[p+1,y]$ 的前缀最大值。由于内外独立，所以根据相对大小关系，内部只需要看成一个 $y-p-1$ 大小的排列。这时 $x$ 成为的概率就是 $\frac{1}{x-p}$，即它的前缀大小。再考虑外面选取 $[p,y]$ 的方案数，此时 $p,y$ 的值必然确定，得到答案是：$\sum_{i=0}^{x-1}\frac{n!}{(y+1-\max(i,1))!}\frac{(y-i-1)!}{x-i}$。直接写是 $\mathcal O(Tn)$。

$45$ 分代码：

``` cpp
int calc(int n,int k){// length=n, kth is prefix max
	return 1ll*fac[n]*inv[k]%mod;
}
for(int i=0;i<x;++i)inc(ans,1ll*fac[i==0?n-y:n-1-y+i]*C(n,i==0?n-y:n-1-y+i)%mod*calc(y-i-1,x-i)%mod);
```

容易化简为 $\sum \frac{1}{(y-i)(y-i+1)(x-i)}$。注意到 $\frac{1}{x(x+y)}=\frac{1}{y}(\frac{1}{x}-\frac{1}{x+y})$，然后把 $\frac{1}{(x-i)(y-i)}$ 变换求和顺序看成 $\frac{1}{i(i+y-x)}$，可以转化成前面的形式。此时直接预处理 $\frac{1}{i}$ 的前缀和即可快速查询 $f(n,k)=\sum_{i=1}^n\frac{1}{i(i+k)}$。这样查询是 $\mathcal O(1)$，时间复杂度 $\mathcal O(T+\max n)$。


代码中对 $i=0$ 特殊计算了。
```cpp
namespace combi{
	int fac[maxn],ifac[maxn],inv[maxn],pre[maxn];
	void init(const int N){
		fac[0]=ifac[0]=inv[0]=1;
		F(i,1,N)fac[i]=1ll*fac[i-1]*i%mod;
		ifac[N]=qpow(fac[N],mod-2);
		dF(i,N-1,1)ifac[i]=1ll*ifac[i+1]*(i+1)%mod;
		F(i,1,N)inv[i]=1ll*ifac[i]*fac[i-1]%mod;
		F(i,1,N)pre[i]=add(pre[i-1],inv[i]);
	}
	inline int C(const int n,const int m){
		if(m>n||n<0||m<0) return 0;
		return 1ll*fac[n]*ifac[m]%mod*ifac[n-m]%mod;
	}
}
using namespace combi;
int qsum(int l,int r){ return sub(pre[r],pre[l-1]); }
int query(int n,int k){
	return 1ll*inv[k]*sub(qsum(1,n),qsum(k+1,n+k))%mod;
}
int n,x,y;
void solve(){
	cin>>n>>x>>y;
	if(x==y)return cout<<fac[n]<<'\n',void();
	if(x>y)swap(x,y);
	int ans=1ll*fac[n-y]*C(n,y)%mod*fac[y-1]%mod*inv[x]%mod;
	inc(ans,1ll*sub(query(x-1,y-x),query(x-1,y-x+1))*fac[n]%mod);
	cout<<ans<<'\n';
}
```

---

## 作者：RainWetPeopleStart (赞：2)

upd on 2025.07.10 修正了一些笔误。

一个以暴力代数推导为主做法，难点在于有继续推下去的勇气。

## $O(n^3)$ 做法

不妨设 $x<y$，$x=y$ 时答案为 $n!$。

同时，为避免边界，设 $p_0=n+1$。

考虑枚举 $p_x,p_y$，此时 $p_y$ 要是 $p_x$ 的祖先（反之则 $y$ 在 $x$ 的右子树中，矛盾），即 $p_y>p_x$。

然后考虑其他部分，对于 $x,y$  之间的位置 $i$ 一定有 $p_i<p_y$，否则 $x,y$ 分别在 $i$ 的两颗子树里，矛盾。

此时，对于 $y$ 右边的位置 $i$ 而言，没有对 $p_i$ 的限制。

同理，找到最大的满足 $i<x,p_i>p_y$ 的 $i$，记作 $ps$，$ps$ 左边没有限制，$ps,x$ 之间的位置 $i$ 有 $p_i<p_x$ 的限制（反之，$x$ 在 $i$ 的右子树里，矛盾）。

下记 $x-1$ 为 $l1$，$y-x-1$ 为 $l2$，$n-y$ 为 $l3$（$[1,x-1],[x+1,y-1],[y+1,n]$ 三段区间的长度）。

枚举 $x,y,ps$，用组合数算贡献。

具体的，$ps=0$ 时贡献为：
$$\binom{p_x-1}{l1}\binom{p_y-2-l1}{l2}(l1!)(l2!)(l3!)$$

否则，$l1$ 要变成 $x-ps-1$，$(l3!)$ 变为 $(n-3-l2-(x-ps-1))!$，还要乘上 $(n-p_y)$。

最后将贡献求和即可。[代码](https://www.luogu.com.cn/record/221789354)。

## $O(n^2)$ 做法

下记 $a=p_x-1$，$b=p_y-2$，$i=(x-ps-1)$。

想优化到 $n^2$，则需要优化枚举 $a,b,i$ 的部分，优化枚举 $a$，因为设计 $a$ 的项比较简洁。

固定 $b,i$，$a$ 的贡献是 $\sum\limits_{a\le b}\dbinom{a}{i}$，由 $\dbinom{i}{j}=\dbinom{i-1}{j}+\dbinom{i-1}{j-1}$ 知 $\sum\limits_{a\le b}\dbinom{a}{i}=\dbinom{b+1}{i+1}-\dbinom{i}{i+1}=\dbinom{b+1}{i+1}$。

然后就做到 $O(n^2)$ 了。

## $O(n)$ 做法

还要省一次枚举，考虑省掉 $b$，先从 $i=l1$ 的情况入手。

此时 $b$ 的贡献为 $\sum\limits_{b=0}^{n-2}\dbinom{b+1}{l1+1}\dbinom{b-l1}{l2}$。

用组合意义或代数推导转化一下，式子化为 $\sum\limits_{b=0}^{n-2}\dbinom{b+1}{l1+l2+1}\dbinom{l1+l2+1}{l2}$。

用上文方法可得结果为 $\dbinom{n}{l1+l2+2}\dbinom{l1+l2+1}{l2}$。

对于 $i\neq l1$，$b$ 的贡献为 $\sum\limits_{b=0}^{n-2}\dbinom{b+1}{i+1}\dbinom{b-i}{l2}(n-2-b)$。

还是化为 $\sum\limits_{b=0}^{n-2}\dbinom{b+1}{i+l2+1}\dbinom{i+l2+1}{l2}(n-2-b)$。

然后把括号拆掉，用上文方法求解即可。

$$
\begin{aligned}
& \sum\limits_{b=0}^{n-2}\dbinom{b+1}{i+l2+1}\dbinom{i+l2+1}{l2}(n-2-b)
\\= & \sum\limits_{b=0}^{n-2}(n\dbinom{b+1}{i+l2+1}\dbinom{i+l2+1}{l2}-(2+b)\dbinom{b+1}{i+l2+1}\dbinom{i+l2+1}{l2})
\\= & \sum\limits_{b=0}^{n-2}(n\dbinom{b+1}{i+l2+1}\dbinom{i+l2+1}{l2}-(i+l2+2)\dbinom{b+2}{i+l2+2}\dbinom{i+l2+1}{l2})
\\= & n\dbinom{n}{i+l2+2}\dbinom{i+l2+1}{l2}-(i+l2+2)\dbinom{n+1}{i+l2+3}\dbinom{i+l2+1}{l2}
\end{aligned}
$$

这样就 $O(n)$ 了。[代码](https://www.luogu.com.cn/record/221795548)。

## $O(n+T)$ 做法

对于 $i=l1$ 的情况，我们已经可以 $O(1)$ 计算了，接下来只需考虑 $i\neq l1$ 的情况。

先转化 $n\dbinom{n}{i+l2+2}\dbinom{i+l2+1}{l2}-(i+l2+2)\dbinom{n+1}{i+l2+3}\dbinom{i+l2+1}{l2}$，先提出 $\dbinom{i+l2+1}{l2}$，对余下的部分，有：

$$
\begin{aligned}
& n\dbinom{n}{i+l2+2}-(i+l2+2)\dbinom{n+1}{i+l2+3}
\\= & \dbinom{n}{i+l2+2}(n-\dfrac{n+1}{i+l2+3}(i+l2+2))
\\= & \dbinom{n}{i+l2+2}(\dfrac{n-2-l2-i}{i+l2+3})
\end{aligned}
$$

接下来，直接将组合数用阶乘形式展开，用式子中的 $i!,l2!,(n-3-l2-i)!$ 抵消，式子化为 $\dfrac{n!}{(i+1)(i+l2+2)(i+l2+3)}$。

然后把 $n!$ 提出来，用裂项的思想处理分数，与 $i$ 有关的部分为 $\dfrac{1}{(l2+1)(l2+2)}(\dfrac{1}{i+1}+\dfrac{l2+1}{i+l2+3}-\dfrac{l2+2}{i+l2+2})$。

预处理组合数，阶乘，$\dfrac{1}{i}$ 的前缀和即可 $O(1)$ 回答。[代码](https://www.luogu.com.cn/record/221803219)。

---

## 作者：happybob (赞：0)

考虑点 $x,y$ 在一条左链上的条件。不妨假设 $x<y$，则至少要求 $p_y > p_x$。

然后考虑若 $(x,y)$ 之间存在 $>p_y$ 的数，则访问到那个位置时必然把 $x,y$ 分开了，所以要求 $\forall z \in (x,y)$，$p_z < p_y$。

此外，找到最靠右的符合 $p_z > p_x$ 且 $z < x$ 的 $z$，要求 $p_z > p_y$，原因是若 $p_z \in (p_x,p_y)$，则 $y,z,x$ 显然形成了一个非左链的结构。

不难验证这个是充要条件。

其实这一堆条件等价于，记 $r_i$ 为 $<i$ 的最大的 $j$ 使得 $p_j > p_i$，则 $r_x = r_y$ 即为充要条件。

先考虑单组询问的做法，枚举 $r_x = i$，不妨假设 $i \geq 1$，并对 $i=0$ 单独计算贡献。则我们先将 $[i,y]$ 中的数拉出来，有 $\dbinom{n}{y-i+1}$ 种，然后 $p_i$ 必然为区间最大值，$p_y$ 为次大值，中间的东西随意排，但要求 $p_x$ 为 $(i+1,x]$ 的前缀最大值，这个方案数显然是 $\dbinom{y-i-1}{x-i}\times (x-i-1)! \times (y-x-1)!$。此外，还有 $[i,y]$ 之外的数。所以对于固定的 $i$，方案数为 $\dbinom{n}{y-i+1} \times \dbinom{y-i-1}{x-i}\times (x-i-1)! \times (y-x-1)! \times (n-y+i-1)!$，拆开即为 $\dfrac{n!}{(y-i+1)!(n-y+i-1)!} \times \dfrac{(y-i-1)!}{(x-i)!(y-x-1)!} \times (x-i-1)! \times (y-x-1)! \times (n-y+i-1)!=\dfrac{n!}{(y-i+1)!}\times \dfrac{(y-i-1)!}{x-i}=\dfrac{n!}{(x-i)(y-i)(y-i+1)}$。

即求 $\sum \limits_{i=1}^{x-1} \dfrac{1}{(x-i)(y-i)(y-i+1)}$。

注意到 $\dfrac{1}{(y-i)(y-i+1)} = \dfrac{1}{y-i} - \dfrac{1}{y-i+1}$，即求 $\sum \limits_{i=1}^{x-1} \dfrac{1}{(x-i)(y-i)}$。

裂项，这个式子的 $(y-x)$ 倍为 $\sum \limits_{i=1}^{x-1} \left(\dfrac{1}{x-i} - \dfrac{1}{y-i}\right)$。

这个直接维护 $\dfrac{1}{i}$ 前缀和就行了。复杂度 $O(n_{\max}+\log P)$。

---


# [JLOI2013] 地形生成

## 题目描述

最近IK正在做关于地形建模的工作。其中一个工作阶段就是把一些山排列成一行。每座山都有各不相同的标号和高度。为了遵从一些设计上的要求，每座山都设置了一个关键数字，要求对于每座山，比它高且排列在它前面的其它山的数目必须少于它的关键数字。 显然满足要求的排列会有很多个。

对于每一个可能的排列，IK生成一个对应的标号序列和等高线序列。标号序列就是按顺序写下每座山的标号。

等高线序列就是按顺序写下它们的高度。例如有两座山，这两座山的一个合法排列的第一座山的标号和高度为1和3，而第二座山的标号和高度分别为2和4，那么这个排列的标号序列就是1 2，而等高线序列就是3 4.

现在问题就是，给出所有山的信息，IK希望知道一共有多少种不同的符合条件的标号序列和等高线序列。


## 说明/提示

对于所有的数据，有1<=N<=1000，所有的数字都是不大于109的正整数。


## 样例 #1

### 输入

```
2
1 2
2 2```

### 输出

```
2 2```

# 题解

## 作者：wanggk (赞：8)

update：修改了一处假掉的地方，感谢 @[Enoch006](luogu://user/538683) 指出。

有两问，第一问中高度相同编号不同的山看作不同，第二问中高度相同的山看作相同。

## 第一问

题目对山的限制在于“高于它且排在它前面”的数量，比它矮的山放在哪里对它是没有影响的。因此，**对于两座高度不同的山，我们先插入高度大的，即按高度降序排序。** 高度相同时，**按照关键字从小到大排序**。 ~~对于这一问，高度相同的山怎么排其实是无所谓的，第二问中有影响，会说明（划掉的是错的，下面会说明）。~~

排完序之后只需要按顺序一个个插进去。设当前插入的山是 $i$（排序后的下标），前面有 $p$ 座严格比它高的山，这座山的关键数字是 $key$，那么对于这座山，方案数就是 $\min\{key,p\}+(i-p-1)+1=\min\{key+i,i\}$。最后所有山乘起来就可以了。

上面划掉的地方就是假了的地方。原因在于，如果我们先插入限制松的，就会导致限制它的旁边放不了限制更紧的，但是我们仍然会把这个不合法的位置统计进去，这样乘法原理就不对了。

## 第二问

这一问中相同高度的不作区分。将相同高度的一起考虑，设高度严格大于它们的有 $p$ 个。可以理解为，在 $p+1$ 个空位中可重复地塞若干个相同小球，其中每个小球能塞的空位是一段给定的前缀。

设这些小球的选择分别是 $t_1,t_2,\cdots,t_m$，由于这些小球不作区分，我们钦定 $t_1 \le t_2 \leq \cdots \leq t_n$。考虑它们加入的顺序，能塞的前缀之间是包含关系，我们先插入限制紧的。因此，**高度从大到小为第一关键字，关键数字从小到大为第二关键字。**

排序完设 $dp_{i,j}$ 表示现在插入了前 $i$ 个，第 $i$ 个插入的**空挡位置（总共有 $p+1$ 个空位）** 是 $j$ 的方案数。 由于 $t_{i-1} \leq t_i$，所以，$dp_{i,j}=sum_{i-1,j},j \in [1,\min(p,a[i].se)+1]$。

最后答案为每种高度的方案数相乘。

## 代码

```cpp
#include<bits/stdc++.h>
#define Spc putchar(' ')
#define End putchar('\n')
#define For(i,il,ir) for(int i=(il);i<=(ir);++i)
#define Fr(i,il,ir) for(int i=(il);i<(ir);++i)
#define Forr(i,ir,il) for(int i=(ir);i>=(il);--i)
#define ForE(u) for(int i=head[u];~i;i=e[i].nxt)
#define fi first
#define se second
#define mk make_pair
#define pb emplace_back
using namespace std;
typedef long long ll;
typedef pair<int,int> pii;
namespace _OvO_{
    template<typename T>
    inline void rd(T& x){
        bool f=0;x=0;char ch=getchar();
        while(ch<'0'||ch>'9'){ if(ch=='-') f=1; ch=getchar(); }
        while(ch>='0'&&ch<='9') x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
        if(f) x=-x;
    }
    template<typename T,typename... Args>
    void rd(T& first,Args&... args){ rd(first),rd(args...); }
    int write_num[50];
    inline void write(ll x){
        int len=0;
        if(x<0) putchar('-'),x=-x;
        do write_num[len++]=x%10ll; while(x/=10ll);
        while(len--) putchar(write_num[len]+'0');
    }
}using namespace _OvO_;
const int maxn=1005;
const ll mod=2011;

int n,p;
pii a[maxn];
ll f[maxn][maxn],sum[maxn],ans;

void solve1(){
    p=0,ans=1ll;
    For(i,1,n){
        while(a[p+1].fi>a[i].fi) p++;
        ans=ans*(min(a[i].se,p)+i-p)%mod;
    }write(ans);
}
void solve2()
{
    p=0,ans=1ll;
    f[0][1]=1;
    For(i,1,n){
        while(a[p+1].fi>a[i].fi) p++;
        For(j,1,n+1) sum[j]=(sum[j-1]+f[i-1][j])%mod;
        if(p==i-1){ //新的一种高度
            ans=ans*sum[n+1]%mod;//将上一段答案乘进去
            For(j,1,n+1) f[i-1][j]=(j==1),sum[j]=1ll;
        }
        For(j,1,min(p,a[i].se)+1) f[i][j]=sum[j];
        For(j,min(p,a[i].se)+2,n+1) f[i][j]=0; //后面的清空
    }
    For(j,1,n+1) sum[j]=(sum[j-1]+f[n][j])%mod;
    write(ans*sum[n+1]%mod);
}
signed main()
{
    rd(n); For(i,1,n) rd(a[i].fi,a[i].se),a[i].se--;
    sort(a+1,a+1+n,greater<pii>());
    solve1();Spc;solve2();End; return 0;
}
```

---

## 作者：heey (赞：7)


先考虑第一个问题（先假设没有山高度相同）：


我们把所有山按高度从大到小排序，设这个集合为S，设一个空集合为V。


我们把山按顺序放入集合V。


考虑第i座山放进去的时候能放的位置，因为现在前面有i - 1座山比它高，再加上本来的第i个位置，它一共有i个位置可以放。这个山的关键值如果为k，它只能在前min（k，i）个位置里挑。


所以第i个山的放的位置的组合为ci = min（k，i）种。ans = c1 \* c2 …… \* cn；


但是我们现在有山的高度相同，且关键值不同。两座高度相同的山能放的最靠后的位置，一定是关键值大的那个越靠后。所以我们先按高度从大到小，然后高度相同的关键值从小到大排序出S集合。


设[x，y]这段区间的山高度相同。所以 ci = min（x，k） + i - num。因为一座山在满足关键值的情况下，可以也放在高度相同的山前面。


所以最后 得出 ans1 = c1 \* c2 …… \* cn；


然后再看第二个问题，会产生重复情况的只有高度相同的山放一起的情况。


我们依然排序出V集合。按顺序插入山。


定义dp状态f[i][j]，表示高度相同的山里面前i座，放在前j个位置的方案数。


因为我们是插入的山，比如说在一座高度为3的山后面再插入一座高度为3的山，此时是多了一种方案，是不会重复的。


状态也是很好转移设区间[x，y]山高度相同


f[i][j] = sum（f[i - 1][k] ）；k <= min(data[i].d,x) - 1；


因为是按顺序来刷表的可以省掉一维。


又因为f[i][j - 1] = sum（f[i][j - 1]）；f[i][j] = sum（f[i - 1][k] ）；k <= min(data[i - 1].d,x) - 1；所以f[i][j] = f[i - 1][j] + f[i][j - 1]


最终方程dp[i] = dp[i - 1] + dp[i]


最后把每一区间[x，y]相同的山的ci = dp[0] + dp[1] +……dp[min(data[y].d,x) - 1]乘起来。



ans2 = c1 \* c2 …… \* cn；

就可以了。

         
```cpp
    # include <iostream>
    # include <cstdio>
    # include <cstring>
    # include <algorithm>
    using namespace std;
    const int mod = 2011;
    const int N = 1012;
    int dp[N],h[N],n,ans1 = 1,ans2 = 1;
    struct Mountain{
        int h;
        int d;
    bool operator <(const Mountain & other)const{
        if(h == other.h)return d < other.d;
        return h > other.h;
    }
    }data[N];
    void Init(){
        memset(dp,0,sizeof dp);
        dp[0] = 1;
    }
    void read(){
        scanf("%d",&n);
        for(int i = 1;i <= n;i++){
            scanf("%d %d",&data[i].h,&data[i].d);
        }
        sort(data + 1,data + n + 1);
        int num = 0;
        for(int i = 1;i <= n;i++){
            if(data[i].h != data[num].h)num = i;
            (ans1 *= min(num,data[i].d) + i - num) %= mod;
        }
        printf("%d",ans1);
    }
    void work(){
        int pos;
        for(int i = 1;i <= n;i++){
            pos = i;
            while(data[pos].h == data[i].h && pos <= n)pos++;
            pos--;Init();
            for(int j = i;j <= pos;j++){
                for(int k = 1;k <= min(data[j].d,i) - 1;k++){
                    (dp[k] = dp[k - 1] + dp[k]) %= mod;
                }
            }
            int sum = 0;
            for(int j = 0;j <= min(data[pos].d,i) - 1;j++)(sum += dp[j]) %= mod;
            (ans2 *= sum) %= mod;
            i = pos;
        }
        printf(" %d\n",ans2);
    }
    int main()
    {
       read();
       work();

```

---

## 作者：_ctz (赞：6)

[$My\ blog$](https://ctz45562.github.io/2019/06/20/洛谷-P3255-JLOI2013-地形生成)

[传送门](https://www.luogu.org/problemnew/show/P3255)

这个$DP$很有意思。

第一问就是个套路$DP$，按高度降序排序,依次把山插进去。因为题目要求的是**严格大于**，排序时高度相同的按关键值降序排序就好了。

第二问一开始想了个$O(n)$的假做法，显然数据范围是要$O(n^2)$的。。。

~~好难啊不会了告辞~~

还是排好序，我们考虑把相同高度的山一块插进去。对于每一段相同高度的区间$[l,r]$设$f(i,j)$为**这段区间**中前$i$座山，插进**所有山**中前$j$座山的前面的方案数。

每座山要么插到第$j$座山前面（$j\le $关键值），有$f(i-1,j)$种方案；要么插到前$j-1$座山前面，有$f(i,j-1)$种方案。

也就是$f(i,j)=f(i,j-1)+f(i-1,j)$。

因为相同高度的山是单独考虑的，根据乘法原理答案为所有$f(r-l+1,min\{l,H[r].cnt\})$的乘积。

$f$要滚起来，要不然清空太慢。

``` cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <cstring>

#define maxn 1005
#define inf 0x3f3f3f3f

const int mod = 2011;

using namespace std;

inline int read(){
	int x=0,y=0;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')y=1;ch=getchar();}
	while(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
	return y?-x:x;
}
struct hill{
	int h,cnt;
	bool operator < (const hill &x)const{
		if(h!=x.h)return h>x.h;
		return cnt<x.cnt;
	}
}H[maxn];
int f[2][maxn];
int main(){
	int n=read(),ans=1,sum1=0,sum2=0,p;
	for(register int i=1;i<=n;++i)H[i].h=read(),H[i].cnt=read();
	sort(H+1,H+1+n);
	for(register int i=2;i<=n;++i){
		if(H[i].h==H[i-1].h)++sum1;
		else sum2=i-1,sum1=0;
		ans=1ll*ans*(min(H[i].cnt-1,sum2)+sum1+1)%mod;
	}
	printf("%d ",ans);
	ans=1;
	for(register int i=1;i<=n;i=p+1){
		memset(f,0,sizeof f);
		p=i+1;
		while(p<=n&&H[p].h==H[i].h)++p;
		--p;
		for(register int j=1;j<=i;++j)f[0][j]=1;
		for(register int j=i;j<=p;++j)
			for(register int k=1;k<=i;++k){
				f[j-i+1&1][k]=f[j-i+1&1][k-1];
				if(k<=H[j].cnt)(f[j-i+1&1][k]+=f[j-i&1][k])%=mod;
			}
		ans=1ll*ans*f[p-i+1&1][min(i,H[p].cnt)]%mod;
	}
	printf("%d\n",ans);
}
```



---

## 作者：elijahqi (赞：5)

功夫不负有心人，经历22次wa之后我终于ac了

给定一些山，每座山有一个高度和一个关键值，现在要将这些山排成一个序列，要求每座山之前高度高于它的山的数量不能超过它的关键值

问题一：求合法的标号序列数

问题二求的是高度序列数（有重复的算一种）

针对问题一我们考虑，因为高度较小的山对于高度较大的山是没有影响的

不妨我们把高度从大到小排列，然后再依次往序列里插 同时 我们高度相同时还要针对 关键字从小到大排列，这题的难点在于有相同的我们不妨把相同高度的数据按关键值x从小到大排序，这样再插入a[i]时，和他一样高的点一定插在他的前面，但并不比它大否则我们做不了dp的

假设我们新插入一个数，那么这个数一定比我们前面的所有数都要小或者一样大

设data[i]的关键值为x，则a[i]可以插在前1~x个空档，根据乘法原理，ans=ans\*min(i,data[i].x)。此外还有之前已经解决过的相同情况如何处理，因此是ans=ans\*min(i,data[i].x+tmp),tmp表示在i之前，有多少个高度为a[i]的点。

第二问 ：更难。

不过我们一点一点分析来做

为了保证没有重复的，所以我们选择如果有相同高度就把他们拿来一起做

在这个子问题里我们再使用动态规划

比如重复的球有n个 我们前面已经插入了m-1个球 拥有m个空挡可以插

那么相当于一个小学奥数计数问题，只不过更复杂，限制更多

关于动态规划的转移方程 我们设f[i][j]表示前i个空里插前j个球的方案数

f[i][j]=∑[i−1][k](k≥1&&k≤j)

f[i][j]=f[i-1][j]+f[i-1][j-1]+f[i-1][j-2]+……+f[i-1][1]  (1<=j<=data[i].x)

这个里面分别就代表第i个插在第J个j-1个j-2个中的各种方案数 加起来就是第i个插在前j个中的方案数

 
化简o1转移

f[i][j]=f[i-1][j]+f[i][j-1]

最后再根据乘法原理就是我们的答案了（同第一问）

 
last数组用来求我们当前高度这个最长延伸到哪

```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
#define mod 2011
#define N 1100
#define LL long long
struct node{
    int key,h;
}data[N];
inline bool cmp (node a,node b){
    if (a.h==b.h) return a.key<b.key;else return a.h>b.h;
}
inline int min(int x,int y){
    return x<y?x:y;
}
inline int read(){
    int x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();
    return x*f;
}
int f[2][N],n,last[N];
int main(){
    freopen("3255.in","r",stdin);
    n=read();
    for (int i=1;i<=n;++i) data[i].h=read(),data[i].key=read();
    //for (int i=1;i<=n;++i) printf("%d %d\n",data[i].h,data[i].key);
    std::sort(data+1,data+1+n,cmp);
    int tmp=0;int ans=1;
    for (int i=1;i<=n;++i){
        if(data[i].h==data[i-1].h) tmp++;else tmp=0;
        ans=(LL)ans*min(data[i].key+tmp,i)%mod;
    }
    printf("%d ",ans);tmp=1;
    //for(int i=1;i<=n;++i) printf("%d %d\n",data[i].h,data[i].key);
    for (int i=1;i<=n;i=i+tmp,tmp=1) {
        for (int j=i+1;j<=n;++j) if (data[j].h==data[j-1].h) tmp++;else break;
        last[i]=tmp;
    } 
//    for (int i=1;i<=n;++i) printf("%d ",last[i]);printf("\n");
    ans=1;int p=0;
    for (int i=1;i<=n;i=i+last[i]){
        p=0;
        for (int j=1;j<=data[i].key;++j) f[0][j]=1;<span class="hljs-comment">//前0个球放到任意个盒子里，都只有一种方案 </span>
      //  if (last[i]==1) continue;
        for (int j=1;j<=last[i];++j){
            for (int z=1;z<=i;++z){
                f[p^1][z]=f[p^1][z-1];
<span class="hljs-comment">                //如果这个盒子i不能放，因为key[i]是递增的，所以i-1...1也不能放进这个盒子 </span>

                if (z<=data[i+j-1].key)f[p^1][z]=(f[p^1][z-1]+f[p][z])%mod  ;          
            }p^=1;
        }
        ans=(LL)ans*f[p][i]%mod;
    }
    printf("%d",ans);
    return 0;
}
```
欢迎光临蒟蒻的blog  ORZ (elijahqi.win)


---

## 作者：wangsiqi2010916 (赞：1)

先考虑第一问，先对高度 $h$ 进行排序。

如果没有重复，假设当前点为 $i$，限制数量小于等于 $p$，那么当前点的方案相当于在一个长度为 $i-1$ 的序列中的前 $p$ 个位置插入一个数，方案数为 $\min(p+1,i)$。

对于有重复的位置，假设有 $t$ 个点高度大于当前位置，那么会增加 $i-t-1$ 种方案。

相加得方案数为 $\min(p,t)+i-t$，最后相乘即可。

接下来看第二问，可以使用 DP，设 $f_{i,j}$ 表示当前为第 $i$ 个相同的数，插入到前 $j$ 个数后的方案数。

转移方程显然是 $f_{i,j}=\sum_{k=1}^{\min(t-1,p_i,j)} f_{i-1,k}$。

因为是求前缀和，可以省掉一维，转移方程为 $f_k=f_{k-1}+f_k$。

最后对所有的 $f$ 求和，然后每种情况相乘即可。

这里因为限制松的情况更多，所以应先处理它们保证不重。

代码：

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
const int mod=2011;
int n,ans,f[2005];
struct node{
	int id,x;
}a[2005];
bool cmp(node x,node y)
{
	if(x.x!=y.x) return x.x>y.x;
	return x.id<y.id;
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%d%d",&a[i].x,&a[i].id);
		a[i].id--;
	}
	sort(a+1,a+n+1,cmp);
	ans=1;
	for(int i=1,j=0;i<=n;i++)
	{
		while(a[j+1].x>a[i].x) j++;
		ans=ans*(min(a[i].id,j)+i-j)%mod;
	}
	printf("%d ",ans);
	ans=1;
	for(int i=1;i<=n;i++)
	{
		int j;
		for(int j=0;j<=n;j++) f[j]=0;
		f[0]=1;
		for(j=i;j<=n;j++)
		{
			if(a[i].x!=a[j].x) break;
			for(int k=1;k<=min(i-1,a[j].id);k++)
			{
				f[k]=(f[k-1]+f[k])%mod;
			}
		}
		int sum=0;
		j--;
		for(int k=0;k<=a[j].id;k++) sum=(sum+f[k])%mod;
		ans=ans*sum%mod;
		i=j;
	}
	printf("%d",ans);
	return 0;
}
```

---

## 作者：LEWISAK (赞：1)

update on 2025.3.9：改了毒瘤马蜂

[传送门](https://www.luogu.com.cn/problem/P3255)

[我的不老歌](https://www.cnblogs.com/lewisak/p/18751447)

# 题面大意

给你 $n$ 座山，对于每座山有高度和关键字两个变量，求让每座山前**严格**高于它的山至多有关键字个的方案数以及高度相等的山不区分的方案数。

# 题解

一个较为经典的 trick，容易发现对于任意一座山，比他矮的放哪和他的方案没有关系，于是我们先按**高度递减为第一关键字，关键字递增为第二关键字来排序**（为什么要设置第二关键字小问中会说）。

### 第一问

排完序后枚举每一座山，注意到因为设置了第二关键字，所以限制比较紧的山会先插入，那么**这座山一定可以插在高度一样的山后面**，因为高度都一样，他们的限制还比我紧，我跟着他们插肯定是合法的。

然后注意到假设比这座山更高的山有 $tot$ 座，当前山的关键字为 $a$ 那么就会有 $\min(a,tot)$ 座比他高的山可以让他插在后边。

于是第 $i$ 座山的方案数就是：$\min(a,tot)+(i-tot-1)+1$ 种，其中 $i-tot-1$ 是和第 $i$ 座一样高的数量，最后的加一是放到最前面。

### 第二问

稍微难了一点，我们设 $dp_{i,j}$ 表示第 $i$ 座山，插入到了 $j$ 的方案数，然后因为我们设置了第二关键字，所以为了去重，不妨让每一山都插在相同高度山的后面，那么 $dp_{i,j}$ 就是上一座山插在 $j$ 或以前的总方案数，这样显然是正确的，而如果上一座山。

如果到了新高度就清空，初值是 $dp_{i,1}=1$。

### 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int mod=2011;
struct nb{
	int gao,jian;
}a[1010];
int n,dp[1010][1010],sum[1010],ans;

signed main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i].gao>>a[i].jian;
		a[i].jian--;
	}
	sort(a+1,a+1+n,[](nb x,nb y){
		if(x.gao!=y.gao){
			return x.gao>y.gao;
		} 
		return x.jian<y.jian;
	});
	ans=1;
	int tot=0;
	for(int i=1;i<=n;i++){
		while(a[tot+1].gao>a[i].gao){
			tot++;
		}
		ans=ans*(min(a[i].jian,tot)+i-tot)%mod;
	}
	cout<<ans<<' ';
	tot=0,ans=1;
	dp[0][1]=1;
	for(int i=1;i<=n;i++){
		while(a[tot+1].gao>a[i].gao){
			tot++;
		}
		for(int j=1;j<=n+1;j++){
			sum[j]=(sum[j-1]+dp[i-1][j])%mod;
		}
		if(tot==i-1){
			ans=ans*sum[n+1]%mod;
			for(int j=1;j<=n+1;j++){
				sum[j]=1;
			}
		}
		for(int j=1;j<=min(tot,a[i].jian)+1;j++){
			dp[i][j]=sum[j];
		}
	}
	for(int j=1;j<=n+1;j++){
		sum[j]=(sum[j-1]+dp[n][j])%mod;
	}
	cout<<ans*sum[n+1]%mod;
	return 0;
} 
```

---


# [WC2014] 时空穿梭

## 题目描述

小X驾驶着他的飞船准备穿梭过一个 $n$ 维空间，这个空间里每个点的坐标可以用 $n$ 个实数来表示，即 $(x_1, x_2, ... , x_n)$ 。

为了穿过这个空间，小 X 需要在这个空间中选取 $c$ $(c \geq 2)$ 个点作为飞船停留的地方，而这些点需要满足以下三个条件：

$1$. 每个点的每一维坐标均为正整数，且第 $i$ 维坐标不超过 $m_i$ 。

$2$. 第 $i + 1$ $(1 \leq i < c)$ 个点的第 $j$ $(1 \leq j \leq n)$ 维坐标必须严格大于第 $i$ 个点的第 $j$ 维坐标。

$3$. 存在一条直线经过所选的所有点。在这个 $n$ 维空间里，一条直线可以用 $2n$个实数 $p_1$, $p_2$, … , $p_n$, $v_1$, $v_2$, … , $v_n$ 表示。 直线经过点 $(x_1, x_2, ... , x_n)$ ，当且仅当存在实数 $t$，使得对 $i = 1$ … $n$ 均满足 $x_i$ = $p_i + tv_i$。

小 X 还没有确定他的最终方案，请你帮他计算一下一共有多少种不同的方案满足他的要求。由于答案可能会很大，你只需要输出答案 mod $10 007$ 后的值。


## 说明/提示

【样例$1$说明】

样例数据第一组共有两种可行方案：一种是选择 $(1,1)$ , $(2,2)$ , $(3,3)$ ，另一种是选择 $(1,2)$ , $(2,3)$ , $(3,4)$ 。

【数据规模】

![](https://cdn.luogu.com.cn/upload/image_hosting/84c5gmzc.png)


## 样例 #1

### 输入

```
3
2 3
3 4
3 3
3 4 4
4 4
5 9 7 8```

### 输出

```
2
4
846```

## 样例 #2

### 输入

```
1
11 20
97665 99289 91440 92389 93960 94623 96582 93975 98359 93492 90331
```

### 输出

```
3278```

# 题解

## 作者：qwaszx (赞：10)

考虑枚举所有直线来计算答案，一条直线可以由第一个点以及最后一个点和第一个点的差向量确定. 确定差向量 $x=(x_1,x_2,\cdots ,x_n)$ 之后第一个点有 $(m_1-x_1)(m_2-x_2)\cdots(m_n-x_n)$ 种取法，令 $d=\gcd(x_1,x_2,\cdots,x_n)$，那么该差向量上的整点只有 $d+1$ 个，即 $(x_1/d,x_2/d,\cdots,x_n/d)$的 $0$ 到 $d$ 倍. 由于已经钦定了第一个点和最后一个点，所以这条直线的贡献就是
$\dbinom{d-1}{c-2}$，也就是说我们需要求出

$$
\sum_{1\leq x_i\leq m_i}\binom{\gcd\{x_i\}-1}{c-2}\prod_{i=1}^n (m_i-x_i)
$$

根据套路反演，设

$$
g(n)=\sum_{d|n}\binom{d-1}{c-2}\mu(\frac{n}{d})
$$

对所有 $c$ 求出 $g$，这部分可以做到 $O(cm\log\log m)$.

那么就有

$$
\begin{aligned}
&\sum_{1\leq x_i\leq m_i}\binom{\gcd\{x_i\}-1}{c-2}\prod_{i=1}^n (m_i-x_i)\\
=&\sum_{1\leq x_i\leq m_i}\left(\prod_{i=1}^n(m_i-x_i)\right)\sum_{d\mid x_i}g(d)\\
=&\sum_{d=1}^{\min\{m_i\}}g(d)\sum_{1\leq x_i\leq m_i/d}\prod_{i=1}^n(m_i-x_id)\\
=&\sum_{d=1}^{\min\{m_i\}}g(d)\prod_{i=1}^n\left(\sum_{x_i=1}^{m_i/d}(m_i-x_id)\right)
\end{aligned}
$$

那么直接做就是 $O(Tnm)$ 的，我也不知道能不能过. 由于 $n$ 很小所以考虑把复杂度往 $n$ 上倾斜一下，考虑整除分块，对于 $\lfloor\frac{m_i}{d}\rfloor$ 都相同的一段拿出来计算. 注意到后面那个乘积是一个关于 $d$ 的 $n$ 次多项式，那么假设已经算出系数 $t_i$，带进去就得到

$$
\begin{aligned}
&\sum_{d=L}^{R}g(d)\sum_{i=0}^nt_id^i\\
=&\sum_{i=0}^nt_i\sum_{d=L}^{R}g(d)d^i
\end{aligned}
$$

我们可以用 $O(cnm)$ 的复杂度预处理 $g(d)d^k$ 的前缀和之后 $O(n)$ 计算一段 $d$ 的和. 段数是 $O(n\sqrt{m})$ 的所以这部分复杂度是 $O(n^2\sqrt{m})$ 的.

接下来要解决的问题是多项式系数怎么算，如果每次都暴力计算的话复杂度是 $O(n^3\sqrt{m})$，不太好. 考虑这个多项式实际上是一堆一次多项式的积，而这些一次多项式的变化次数是 $O(n\sqrt{m})$ 的. 那么我们可以直接维护积的多项式，需要乘或者除以一个一次多项式，这可以在 $O(n)$ 时间内完成，那么总复杂度 $O(n^2\sqrt{m})$.

最终的复杂度为 $O(Tn^2\sqrt{m}+cnm+cm\log\log m)$

以下代码中含有大量卡常技术，~~可能不太能看，~~ 轻松最优解.

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<algorithm>
using namespace std;
const int mod=10007,mod2=mod*mod;
const int N=100005;
struct FJ
{
    int w,id;
}fj[N];
int finalans[1005],C[20][N],prime[N],p[N],prime_cnt,T,n,m[20],inv[N],pres[20],pw[20][N],s[20][N];
int qmod1(const int &x){return x>=mod?x-mod:x;}
int qmod2(const int &x){return x+(x>>31&mod);}
void prework(int n)
{
    C[0][0]=1;
    for(int i=1;i<=n;i++)
    {
        C[0][i]=1;
        for(int j=1;j<=i&&j<=18;j++)
            C[j][i]=qmod1(C[j][i-1]+C[j-1][i-1]);
    }
    for(int j=0;j<=11;j++)pw[j][1]=1;
    for(int i=2;i<=n;i++)
    {
        if(!p[i])
        {
            prime[++prime_cnt]=i;
            pw[0][i]=1;for(int j=1;j<=11;j++)pw[j][i]=1ll*pw[j-1][i]*i%mod;
        }
        for(int j=1;j<=prime_cnt&&i*prime[j]<=n;j++)
        {
            int x=i*prime[j];p[x]=1;
            for(int k=0;k<=11;k++)pw[k][x]=pw[k][i]*pw[k][prime[j]]%mod;
            if(i%prime[j]==0)break;
        }
    }
    for(int d=0;d<=18;d++)
    {
        for(int j=n;j>=1;j--)C[d][j]=C[d][j-1];C[d][0]=0;
        for(int i=1;i<=prime_cnt;i++)
            for(int j=n/prime[i];j>=1;j--)
                C[d][j*prime[i]]=qmod2(C[d][j*prime[i]]-C[d][j]);
    }
 //   for(int i=1;i<=10;i++)cout<<C[3][i]<<" ";puts("");
    inv[1]=1;
    for(int i=2;i<mod;i++)inv[i]=(mod-mod/i)*inv[mod%i]%mod;
}
int tmp[20];
struct Poly
{
    int len,a[20];
    Poly(){len=0;a[0]=1;}
    void clear(){len=0;a[0]=1;}
    void mul(int u,int v)
    {
        ++len;a[len]=0;
        for(int i=len;i>=1;i--)a[i]=(u*a[i-1]+v*a[i])%mod;
        a[0]=v*a[0]%mod;
    }
    void div(int u,int v)
    {
        for(int i=len;i>=1;i--)
        {
            tmp[i-1]=a[i]*inv[u]%mod;
            a[i-1]=(a[i-1]-tmp[i-1]*v)%mod;
        }
        --len;
        for(int i=0;i<=len;i++)a[i]=tmp[i];
    }
    int get(int i)
    {
        return a[i];
    }
    void print()
    {
        cout<<"deg:"<<len<<endl;
        for(int i=0;i<=len;i++)cout<<a[i]<<" ";puts("");
    }
}G;
struct mypair{int a,b;}w[20];
struct Q
{
    int n,c,m[20],id;
}q[1005];
int maxn[20];
int cmp(const FJ &a,const FJ &b){return a.w<b.w;}
int cmp1(const Q &a,const Q &b){return a.c<b.c;}
int main()
{
    prework(100000);
    scanf("%d",&T);
    for(int i=1;i<=T;i++)
    {
        scanf("%d%d",&q[i].n,&q[i].c);q[i].id=i;maxn[q[i].c-2]=max(maxn[q[i].c-2],q[i].n);
        for(int j=1;j<=q[i].n;j++)scanf("%d",&q[i].m[j]);
    }
    sort(q+1,q+T+1,cmp1);
    for(int nowT=1;nowT<=T;nowT++)
    {
        n=q[nowT].n;int c=q[nowT].c-2;int M=100000,tn=0;
        for(int i=1;i<=n;i++)m[i]=q[nowT].m[i],M=min(M,m[i]);
        if(c!=q[nowT-1].c-2)
        {
            for(int k=0;k<=maxn[c];k++)
            {
                for(int i=1;i<=100000;i++)s[k][i]=C[c][i]*pw[k][i]%mod;
                for(int i=1;i<=100000;i++)s[k][i]=qmod1(s[k][i]+s[k][i-1]);
            }
        }
        int sqm=sqrt(M);
        for(int i=1;i<=n;i++)
            for(int d=sqm+1,lt;d<=M;d=lt+1)
            {
                lt=min(M,m[i]/(m[i]/d));
                fj[++tn]=(FJ){lt,i};
            }
        sort(fj+1,fj+tn+1,cmp);
 //       for(int i=1;i<=tn;i++)cout<<fj[i].w<<" "<<fj[i].id<<endl;
        fj[0].w=sqm;long long ans=0;
        for(int d=1;d<=sqm;d++)
        {
            int prod=1;
            for(int i=1;i<=n;i++)
            {
                int f=m[i]/d,w;
                w=(1ll*f*m[i]-(1ll*f*(f+1)>>1)*d)%mod;
                prod=prod*w%mod;
            }
            ans+=prod*C[c][d];
 //           cout<<ans<<endl;
        }
        for(int i=1;i<=n;i++)
        {
            int f=m[i]/(sqm+1);int c1=1ll*f*m[i]%mod,c2=(1ll*f*(f+1)>>1)%mod;
            w[i]=(mypair){c2?mod-c2:0,c1};
//            cout<<i<<" "<<c1<<" "<<c2<<endl;
        }   
        G.clear();
        for(int i=1;i<=n;i++)G.mul(w[i].a,w[i].b);
        ans%=mod;
        for(int id=1;id<=tn;)
        {
            int d=fj[id].w,pred=fj[id-1].w;

//            G.print();
            for(int j=0;j<=n;j++)
            {
 //               cout<<G.get(j)<<" "<<s[j][d]-s[j][pred]<<endl;
                ans+=G.get(j)*(s[j][d]-s[j][pred]);
            }
//            cout<<(ans%mod+mod)%mod<<endl;            
            while(id<=tn&&fj[id].w==d)
            {
                int i=fj[id].id;
                G.div(w[i].a,w[i].b);
                int f=m[i]/(d+1),c1=1ll*f*m[i]%mod,c2=(1ll*f*(f+1)>>1)%mod;
                w[i]=(mypair){c2?mod-c2:0,c1};
                G.mul(w[i].a,w[i].b);
                ++id;
            }
//            cout<<ans<<endl;
        }
        
        ans%=mod;ans=(ans+mod)%mod;
        finalans[q[nowT].id]=ans;
    }
    for(int i=1;i<=T;i++)printf("%d\n",finalans[i]);
}

```

---

## 作者：dottle (赞：10)

有一个没有前途的做法，复杂度为 $O(cm\log m+Tnm)$，但是常数小，可以通过此题。并且这个做法好想好写，可以说是一个提高难度的暴力做法。

类比二维坐标系，我们有一个结论，只要若干点每一维相邻坐标值之差比相等，这些点就可以被一条直线穿过。例如三个三维点 $(1,1,4),(2,2,9),(4,4,19)$，其三维坐标值之差比分别为 $1:2$，$1:2$，$5:10$，化简后相等。下文称像 $\{1,2,4\}$ 和 $\{4,9,19\}$ 这种差之比相等的取值方案为「本质相同的方案」。

现在就有一个计数方案了，枚举每一个本质不同的方案，求出每维中于其本质相同的方案数的积。这些积的和就是答案。显然这样是不重不漏的。

现在考虑如何枚举本质不同的方案。首先我们发现其实方案数其实只和当前方案长度有关，所以我们算出与某一长度本质相同的方案数，再乘上此长度的方案数就可以了。所以我们将某一长度的方案合并计算。

容易想到一个非常朴素的 dp 方法，即对于每种本质不同的方案，我们统计其最大坐标最小的。可以钦定第一个点和最后一个点必须选，然后进行 dp。令 $f_{0/1,i,j}$ 代表选了 $i$ 个坐标，$j$ 是最大的坐标，$j$ 没有被选/被选了。可以写出代码

```cpp
f[1][1][1]=1;//这样赋初值的原因是 1 必须被选
for(int i=1;i<C;i++)
	for(int j=2;j<M;j++)
		f[0][i][j]=f[0][i][j-1]+f[1][i][j-1],
		f[1][i][j]=f[0][i-1][j-1]+f[1][i-1][j-1];
```

智慧的读者想必已经发现，这样枚举会重复计算某些方案，例如 $\{1,2,4\}$ 和 $\{1,3,7\}$ 他们本质相同，但是都会被统计进 dp 数组。所以在最后，我们需要把这些情况减去

```cpp
for(int i=2;i<C;i++)
	for(int j=2;j<M;j++){
		for(int k=j*2-1;k<M;k+=j-1)//&
			f[1][i][k]-=f[1][i][j];
		f[1][i][j]%=mod;
	}
```

解释一下标了注释那句话，一个最大坐标为 $j$ ，最小坐标为 $1$ 的方案差值扩大 $k$ 倍以后最大坐标会变为 $(j-1)k+1$。可以搓几组数据验证或者直接证明。这样我们就减掉了那些重复计算的方案。

然后考虑对于每一维，与某一长度本质相同的方案数如何 $O(1)$ 求。若该维度限制为 $m_i$ ，该方案最大坐标为 $j+1$（当然，它的最小坐标为 $1$）。它的答案应该是

![](https://s3.ax1x.com/2021/01/22/sIX77Q.png)

这个算法就是枚举把差值扩大的倍数 $k$，然后考虑最小点分别是 $1,2,3,...,(m-(kj+1)+1)$ 时各有一种方案，加起来即可。

将上面两个方法合并，就是这道题的算法了。

```cpp
#include<stdio.h>
const int M=100050,mod=10007,iv=mod/2+1,C=21;
int f[2][C][M],g[M],a[C],t,n,m,c,x;
long long ans,sm,mn,nw;
signed main(){
	scanf("%d%d%d",&t,&n,&c);
	f[1][1][1]=1;
	for(int i=1;i<C;i++)
		for(int j=2;j<M;j++)
			f[0][i][j]=(f[0][i][j-1]+f[1][i][j-1])%mod,
			f[1][i][j]=(f[0][i-1][j-1]+f[1][i-1][j-1])%mod;
	for(int i=2;i<C;i++)
		for(int j=2;j<M;j++){
			for(int k=j*2-1;k<M;k+=j-1)
				f[1][i][k]-=f[1][i][j];
			f[1][i][j]%=mod;
		}
	for(int T=0;T<t;T++){
		if(T)scanf("%d%d",&n,&c);
		ans=0,mn=M;
		for(int i=1;i<=n;i++)
			scanf("%d",&a[i]),mn=a[i]<mn?a[i]:mn;
		for(int j=c-1;j<mn;j++){
			sm=1;
			for(int i=n;i;--i)
				nw=*(a+i)/j,sm=nw*(*(a+i)-((nw+1)*j)*iv)*sm%mod;//交换了乘顺序来优化常数
			ans+=sm*f[1][c][j+1];
		}
		printf("%d\n",(ans%mod+mod)%mod);
	}
} 
```

肉眼可见预处理复杂度 $O(mc\log m)$，计算复杂度 $O(Tnm)$。常数挺小的，开个 `int`，少取点膜就过去了，还挺快。



---

## 作者：littlez_meow (赞：5)

一道莫反和组合的好题！

[题目链接](https://www.luogu.com.cn/problem/P4152)

## step 1：枚举方式
根据莫反题的经验，我们肯定要找到一种方法枚举最大公约数。

枚举每个点的坐标，再考虑经不经过同一直线，这样时间复杂度是指数级的，肯定不现实。

不如从直线出发，先枚举直线，再从直线上选整点。

但是，我们怎么枚举直线？难道对于所有 $x_i=p_i+tv_i$，我们枚举每一个 $p_i$ 和 $v_i$ 吗？这样整点也不好求。根据点斜式，只要有一个点和一个向量就能确定一条直线。我们能不能枚举第一个点和直线方向呢？显然可以，直线方向便可以是第一个点和最后一个点的差向量。

至于整点数目，还记得[ P1447 能量采集](https://www.luogu.com.cn/problem/P1447)这道题吗？其中的结论是：对于以原点 $O$ 和点 $A(x,y)$ 为端点的线段，不包括原点，过 $\gcd(x,y)$ 个整点。将线段扩展到高维，再平移使 $O$ 与枚举的的第一个的重合，就能求出整点数。

具体地，设直线的方向向量为 $(t_1,t_2,\cdots,t_n)$，第一个点为 $(x_1,x_2,\cdots,x_n)$，由于最后一个点为第一个点加上该向量，第 $i$ 维坐标不能超过 $m_i$，因此有 $x_i+t_i\le m_i$，即 $1\le x_i\le m_i-t_i$，根据乘法原理，第一个点共有 $(m_1-t_1)(m_2-t_2)\cdots(m_n-t_n)=\prod\limits_{i=1}^n{(m_i-t_i)}$ 种选法。

再考虑每一条直线的贡献。除去确定的一头一尾两个点，我们可以得到剩下的整点一共有 $\gcd(t_1,t_2,\cdots,t_n)-1$ 个，从中选出 $c-2$ 个就是贡献，即 $\dbinom{\gcd(t_1,t_2,\cdots,t_n)-1}{c-2}$。

这个式子与第一个点的位置无关，根据加法原理，我们得出了答案的表达式：

$$\sum\limits_{t_1=1}^{m_1}\sum\limits_{t_2=1}^{m_2}\cdots\sum\limits_{t_n=1}^{m_n}{\dbinom{\gcd(t_1,t_2,\cdots,t_n)-1}{c-2}\prod\limits_{i=1}^n{(m_i-t_i)}}$$

下面就是推式子时间了呢。

## step 2：推式子
为了大家看得方便，我们记 $m=\min\limits_i{m_i}$

原式为

$$\sum\limits_{t_1=1}^{m_1}\sum\limits_{t_2=1}^{m_2}\cdots\sum\limits_{t_n=1}^{m_n}{\dbinom{\gcd(t_1,t_2,\cdots,t_n)-1}{c-2}\prod\limits_{i=1}^n{(m_i-t_i)}}$$

莫反套路，枚举最大公约数，得

$$\sum\limits_{d=1}^m\sum\limits_{t_1=1}^{m_1}\sum\limits_{t_2=1}^{m_2}\cdots\sum\limits_{t_n=1}^{m_n}{[\gcd(t_1,t_2,\cdots,t_n=d)]\dbinom{d-1}{c-2}\prod\limits_{i=1}^n{(m_i-t_i)}}$$

最大公约数化为一，提取公因数 $\dbinom{d-1}{c-2}$，得

$$\sum\limits_{d=1}^m\dbinom{d-1}{c-2}\sum\limits_{t_1=1}^{\lfloor \frac{m_1}d\rfloor}\sum\limits_{t_2=1}^{\lfloor \frac{m_2}d\rfloor}\cdots\sum\limits_{t_n=1}^{\lfloor \frac{m_n}d\rfloor}{[\gcd(t_1,t_2,\cdots,t_n=1)]\prod\limits_{i=1}^n{(m_i-dt_i)}}$$

莫比乌斯反演，得

$$\sum\limits_{d=1}^m\dbinom{d-1}{c-2}\sum\limits_{t_1=1}^{\lfloor \frac{m_1}d\rfloor}\sum\limits_{t_2=1}^{\lfloor \frac{m_2}d\rfloor}\cdots\sum\limits_{t_n=1}^{\lfloor \frac{m_n}d\rfloor}\sum\limits_{k|t_1,k|t_2,\cdots,k|t_n}{\mu(k)\prod\limits_{i=1}^n{(m_i-dt_i)}}$$

枚举因数变为枚举倍数，得

$$\sum\limits_{d=1}^m\dbinom{d-1}{c-2}\sum\limits_{k=1}^{\lfloor \frac m d\rfloor}\mu(k)\sum\limits_{t_1=1}^{\lfloor \frac{m_1}{kd}\rfloor}\sum\limits_{t_2=1}^{\lfloor \frac{m_2}{kd}\rfloor}\cdots\sum\limits_{t_n=1}^{\lfloor \frac{m_n}{kd}\rfloor}\prod\limits_{i=1}^n{(m_i-kdt_i)}$$

设 $s=kd$，枚举 $s$，得

$$\sum\limits_{s=1}^m\sum\limits_{d|s}\dbinom{d-1}{c-2}\mu(\dfrac s d)\sum\limits_{t_1=1}^{\lfloor \frac{m_1}s\rfloor}\sum\limits_{t_2=1}^{\lfloor \frac{m_2}s\rfloor}\cdots\sum\limits_{t_n=1}^{\lfloor \frac{m_n}s\rfloor}\prod\limits_{i=1}^n{(m_i-st_i)}$$

到这里似乎不知道怎么推了，目前的各题解也没说后面的求积号是怎么换到前面去的。让我们记 

$$f(s,c)=\sum\limits_{d|s}\dbinom{d-1}{c-2}\mu(\dfrac s d)$$

$$g(n,s)=\sum\limits_{t_1=1}^{\lfloor \frac{m_1}s\rfloor}\sum\limits_{t_2=1}^{\lfloor \frac{m_2}s\rfloor}\cdots\sum\limits_{t_n=1}^{\lfloor \frac{m_n}s\rfloor}\prod\limits_{i=1}^n{(m_i-st_i)}$$

我们将在下一部分好好讨论怎么处理。这样，原式可化为

$$\sum\limits_{s=1}^m f(s,c)g(n,s)$$

## step 3：处理函数 $f$ 与 $g$
### 函数 $g$
先看看其他题解没说清楚的 $g(n,s)$。

其为

$$\sum\limits_{t_1=1}^{\lfloor \frac{m_1}s\rfloor}\sum\limits_{t_2=1}^{\lfloor \frac{m_2}s\rfloor}\cdots\sum\limits_{t_n=1}^{\lfloor \frac{m_n}s\rfloor}\prod\limits_{i=1}^n{(m_i-st_i)}$$

为了方便转化，拆开求积号，得

$$\sum\limits_{t_1=1}^{\lfloor \frac{m_1}s\rfloor}\sum\limits_{t_2=1}^{\lfloor \frac{m_2}s\rfloor}\cdots\sum\limits_{t_n=1}^{\lfloor \frac{m_n}s\rfloor}{(m_1-st_1)(m_2-st_2)\cdots(m_n-st_n)}$$

注意到只有最后一项和最里层求和号有关，乘法分配律提出其他项，得

$$\sum\limits_{t_1=1}^{\lfloor \frac{m_1}s\rfloor}\sum\limits_{t_2=1}^{\lfloor \frac{m_2}s\rfloor}\cdots\sum\limits_{t_{n-1}=1}^{\lfloor \frac{m_{n-1}}s\rfloor}(m_1-st_1)(m_2-st_2)\cdots(m_{n-1}-st_{n-1})\sum\limits_{t_n=1}^{\lfloor \frac{m_n}s\rfloor}{(m_n-st_n)}$$

最后一项就和前面没有关系了，当成一个常数，交换到前面，再用求积号缩写，得

$$\sum\limits_{t_n=1}^{\lfloor \frac{m_n}s\rfloor}{(m_n-st_n)}\sum\limits_{t_1=1}^{\lfloor \frac{m_1}s\rfloor}\sum\limits_{t_2=1}^{\lfloor \frac{m_2}s\rfloor}\cdots\sum\limits_{t_{n-1}=1}^{\lfloor \frac{m_{n-1}}s\rfloor}\prod\limits_{i=1}^{n-1}{(m_i-st_i)}$$

后面这玩意恰好是 $g(n-1,s)$，前面的东西可以拆开然后等差数列求和，得

$$(\lfloor\dfrac{m_n}s\rfloor m_n-\dfrac{s(\lfloor\dfrac{m_n}s\rfloor+1)\lfloor\dfrac{m_n}s\rfloor}2)g(n-1,s)$$

综上所述，我们有 

$$g(n,s)=g(n-1,s)(\lfloor\dfrac{m_n}s\rfloor m_n-\dfrac{s(\lfloor\dfrac{m_n}s\rfloor+1)\lfloor\dfrac{m_n}s\rfloor}2)$$

边界为 $g(0,s)=1$。

这就是一个常系数线性齐次递推，也不需要什么生成函数特征方程什么东西，直接不停展开，可以得到

$$g(n,s)=\prod\limits_{i=1}^n{(\lfloor\dfrac{m_i}s\rfloor m_i-\dfrac{s(\lfloor\dfrac{m_i}s\rfloor+1)\lfloor\dfrac{m_i}s\rfloor}2)}$$

就好了。

### 函数 $f$
再来看 $f(s,c)$。

其定义为

$$f(s,c)=\sum\limits_{d|s}\dbinom{d-1}{c-2}\mu(\dfrac s d)$$

怎么化简呢？虽然很像莫反的式子，但是好不容易化成这样又不能化回去。怎么办？

既然无法化简了，那就直接尝试计算！用类似埃氏筛的思想，对于每个 $c$，先枚举 $d$ 和其倍数并累加。
记第 $i$ 组数据中的 $c$ 为 $c_i$，再记 $C=\max\limits_{i} c_i$，则时间复杂度 $O(Cm\log\log m)$，完全够用。

## step 3：回到原式
将两个函数带回原式，有

$$\sum\limits_{s=1}^m f(s,c)\prod\limits_{i=1}^n{(\lfloor\dfrac{m_i}s\rfloor m_i-\dfrac{s(\lfloor\dfrac{m_i}s\rfloor+1)\lfloor\dfrac{m_i}s\rfloor}2)}$$

另外，右边这一堆看似能整除分块，但实际上即使分了块也是 $O(\sqrt m)$，还不如暴力计算的 $O(n)$。

但是，如果仅仅暴力计算，时间复杂度 $O(Tnm+Cm\log\log m)$，不算常数，极限数据大约在 $10^8$ 多，在超时的边缘疯狂试探。

怎么办？

等等，通常情况下，计算机一秒钟能跑 $10^9$，也就是说，卡卡常是能过的。

其他题解中的 dalao 已经说过计算 $O(Tn\sqrt m)$ 的做法了，在这里我就只具体讲如何卡常。详见下部分。

## step 4：卡常

让我们先写出毫无优化的代码：

```cpp
#include<bits/stdc++.h>
#define ll long long
#define F(i,a,b) for(int i(a),i##i(b);i<=i##i;++i)
#define R(i,a,b) for(int i(a),i##i(b);i>=i##i;--i)
using namespace std;
const int MOD=10007,INV=5004; 
inline int input(){
	int x;char ch;
	for(ch=getchar();ch>'9'||ch<'0';ch=getchar());
	for(x=0;ch>='0'&&ch<='9';ch=getchar()) x=(x<<3)+(x<<1)+(ch^48);
	return x;
}
vector<int>prime;
bitset<100001>v;
int mu[100001];
inline void pre_mu(){
	mu[1]=1;v[1]=1;
	F(i,2,100000){
		if(!v[i]){prime.push_back(i);mu[i]=-1;}
		for(auto j:prime){
		    ll k=(ll)i*j;
			if(k>100000) break;
			v[k]=1;
			if(i%j) mu[k]=-mu[i];
			else break;
		}
	}
	return;
}
int C[100001][19],f[100001][21];
inline void pre_cf(){
	C[0][0]=C[1][0]=C[1][1]=1;
	F(i,2,100000){
		C[i][0]=1;
		F(j,1,min(i,18)) C[i][j]=(C[i-1][j]+C[i-1][j-1])%MOD;
	}
	F(c,2,20) F(i,1,100000) for(int j(1),t(i);t<=100000;++j,t+=i) f[t][c]=(f[t][c]+(ll)C[i-1][c-2]*mu[j]+MOD)%MOD;
	return;
}
int n,m[12],c,ans;
int main(){
	pre_mu();
	pre_cf();
	R(T,input(),1){
		n=input(),c=input();
		int minm(0x7fffffff);
		F(i,1,n) m[i]=input(),minm=min(minm,m[i]);
		ans=0;
		F(s,1,minm){
			ll res(f[s][c]);
			F(i,1,n){
				int t=m[i]/s;
				res=res*((ll)t*m[i]%MOD-(ll)s*(t+1)%MOD*t%MOD*INV%MOD+MOD)%MOD;
			}
			ans=(ans+res)%MOD;
		}
		printf("%d\n",ans);
	}
	return 0;
}
```

结果是 [TLE 50pt](https://www.luogu.com.cn/record/116315038)。

我们知道，取模极其浪费时间，这里又大量取模。我们要减少取模次数，例如一起取模或变为减法。

首先，线性筛中的取模可不可以去掉？这里是为了保证质数只枚举到最小质因数以保证线性。为什么不修改数组 `v`，使其不仅仅记录是否是合数，更记录下每个数的最小质因数呢？这样，线性筛中就没有取模了。

此外，`vector` 常数也很大，直接改成普通数组。

将线性筛改为：

```cpp
int v[100001],prime[100001],head=0;
int mu[100001];
inline void pre_mu(){
	mu[1]=1;v[1]=1;
	F(i,2,100000){
		if(!v[i]){prime[++head]=i,mu[i]=-1,v[i]=i;}
		F(j,1,head){
		    ll k=(ll)i*prime[j];
			if(k>100000) break;
			v[k]=prime[j];
			if(prime[j]<v[i]) mu[k]=-mu[i];
			else break;
		}
	}
	return;
}
```

其次，这里模数特别小，一步一取模很浪费。尤其在第一层求和时，里面答案取模不超过 $10006$，个数不超过 $100000$，乘在一起，`long long` 完全够用，根本不需要取模。同样，算 $s(\lfloor\dfrac{m_i}s\rfloor+1)\lfloor\dfrac{m_i}s\rfloor$ 用 `long long` 也足够了，连 $2$ 的逆元都不用求，直接除就行，再用位运算优化。

中间改成：

```cpp
F(s,1,minm){
	ll res(f[s][c]);
	F(i,1,n){
		int t=m[i]/s;
		res=res*((ll)t*m[i]-((ll)s*(t+1)*t>>1)+MOD)%MOD;
	}
	ans+=res;
}
```

这样交上去，有 [TLE 80pt](https://www.luogu.com.cn/record/116321624)。

同样，把预处理的取模也改掉。又因为 $\mu$ 只有三个取值，我们把乘法写成三目运算符：

```cpp
inline void pre_cf(){
	C[0][0]=C[1][0]=C[1][1]=1;
	F(i,2,100000){
		C[i][0]=1;
		F(j,1,min(i,18)){
			C[i][j]=C[i-1][j]+C[i-1][j-1];
			C[i][j]=C[i][j]>MOD?C[i][j]-MOD:C[i][j];
		}
	}
	F(c,2,20) F(i,1,100000) for(int j(1),t(i);t<=100000;++j,t+=i) if(mu[j]){
		f[t][c]=f[t][c]+(ll)(mu[j]==1?C[i-1][c-2]:MOD-C[i-1][c-2]);
		f[t][c]=f[t][c]>MOD?f[t][c]-MOD:f[t][c];
	}
	return;
}
```

读入也是，`fread` 安排上，再加 O2 优化：

```cpp
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<20,stdin),p1==p2)?EOF:*p1++)
char buf[1<<20],*p1(buf),*p2(buf);
```

[就可过了](https://www.luogu.com.cn/record/116345277)。

## step 5：附上代码
如果你不想把上面的代码拼起来，欢迎来[云剪贴板](https://www.luogu.com.cn/paste/gxeoe6ty)复制。

完结撒花 qwq~

---

## 作者：不存在之人 (赞：5)

题目大意：给定一个$n$维空间，需要在这$n$维空间内选取$c$个共线的点，要求这$c$个点每维坐标均单调递增，第$i$维坐标是整数且在$[1,mi]$

为了表述方便令$||$代表中间东西的方案数，顺便设第$i$维坐标为$ai$。但是这样不简洁因此用$x$表示第$1$维坐标，$y$表示第二维坐标，$θ$表示第$n$维坐标

![](https://i.loli.net/2018/12/12/5c11124529a07.png)
```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#define M 100100
#define MOD 10007
using namespace std;
int mu[M],prime[M],tot;
bool not_prime[M];
int f[M][20],mu_f[M][20],sum[M][20][12];
int n,c,min_m,m[12],a[12];
void Linear_Shaker()
{
	int i,j;
	mu[1]=1;
	for(i=2;i<=100000;i++)
	{
		if(!not_prime[i])
		{
			prime[++tot]=i;
			mu[i]=-1;
		}
		for(j=1;prime[j]*i<=100000;j++)
		{
			not_prime[prime[j]*i]=1;
			if(i%prime[j]==0)
			{
				mu[prime[j]*i]=0;
				break;
			}
			mu[prime[j]*i]=-mu[i];
		}
	}
}
void Pretreatment()
{
	int i,j,k;
	Linear_Shaker();
	for(i=1;i<=100000;i++)
	{
		f[i][1]=1;
		for(j=2;j<=i&&j<=19;j++)
			f[i][j]=(f[i-1][j]+f[i-1][j-1])%MOD;
	}
	for(i=1;i<=100000;i++)
		for(j=1;j<=19;j++)
			for(k=100000/i;k;k--)
				(mu_f[k*i][j]+=mu[i]*f[k][j])%=MOD;
	for(i=1;i<=100000;i++)
		for(j=1;j<=19;j++)
		{
			int temp=1;
			for(k=0;k<=11;k++,temp*=i,temp%=MOD)
				(sum[i][j][k]=sum[i-1][j][k]+mu_f[i][j]*temp%MOD)%=MOD;
		}
}
void Get_A(int lower)
{
	int i,j;
	memset(a,0,sizeof a);
	a[0]=1;
	for(i=1;i<=n;i++)
	{
		int d=m[i]/lower;
		int k=-((long long)d*(d+1)>>1)%MOD;
		int b=((long long)m[i]*d)%MOD;
		for(j=n;j;j--)
			(a[j]=k*a[j-1]+b*a[j])%=MOD;
		(a[0]*=b)%=MOD;
	}
}
int main()
{
	int T,i,j,last;
	Pretreatment();
	for(cin>>T;T;T--)
	{
		scanf("%d%d",&n,&c);
		min_m=0x3f3f3f3f;
		for(i=1;i<=n;i++)
		{
			scanf("%d",&m[i]);
			min_m=min(min_m,m[i]);
		}
		int ans=0;
		for(i=1;i<=min_m;i=last+1)
		{
			last=0x3f3f3f3f;
			for(j=1;j<=n;j++)
				last=min(last,m[j]/(m[j]/i) );
			Get_A(i);
			for(j=0;j<=n;j++)
				(ans+=a[j]*(sum[last][c-1][j]-sum[i-1][c-1][j])%MOD)%=MOD;
		}
		printf("%d\n",(ans+MOD)%MOD);
	}
	return 0;
}
```

---

## 作者：Polaris_Australis_ (赞：3)

考虑枚举每一维第一个点和最后一个点的差向量 $x_i$，则对应起点的选法有 $\prod\limits_{i=1}^{n}(m_i-x_i)$ 种，且除了起点和终点外，这条线上一共有 $(\gcd\limits_{i=1}^{n}x_i)-1$ 个整点，所以除了起点和终点外其他所有点共有 $\binom{(\gcd\limits_{i=1}^{n}x_i)-1}{c-2}$ 种选法。

$$
\begin{aligned}
ans
&=\sum\limits_{x_i=1}^{m_i}\prod\limits_{i=1}^{n}(m_i-x_i)\binom{(\gcd\limits_{i=1}^{n}x_i)-1}{c-2}\\
&=\sum\limits_{d=1}^{m_i}\binom{d-1}{c-2}\sum\limits_{x_i=1}^{m_i}[\gcd\limits_{i=1}^{n}x_i=d]\prod\limits_{i=1}^{n}(m_i-x_i)\\
&=\sum\limits_{d=1}^{m_i}\binom{d-1}{c-2}\sum\limits_{x_i=1}^{\lfloor\frac{m_i}{d}\rfloor}[\gcd\limits_{i=1}^{n}x_i=1]\prod\limits_{i=1}^{n}(m_i-d\times x_i)\\
&=\sum\limits_{d=1}^{m_i}\binom{d-1}{c-2}\sum\limits_{x_i=1}^{\lfloor\frac{m_i}{d}\rfloor}\sum\limits_{e|\gcd\limits_{i=1}^{n}x_i}\mu(e)\prod\limits_{i=1}^{n}(m_i-d\times x_i)\\
&=\sum\limits_{d=1}^{m_i}\binom{d-1}{c-2}\sum\limits_{e=1}^{\lfloor\frac{m_i}{d}\rfloor}\mu(e)\sum\limits_{x_i=1}^{\lfloor\frac{m_i}{d\times e}\rfloor}\prod\limits_{i=1}^{n}(m_i-d\times e\times x_i)\\
&=\sum\limits_{T=1}^{m_i}\sum\limits_{d|T}\binom{d-1}{c-2}\mu(\dfrac{T}{d})\prod\limits_{i=1}^{n}\sum\limits_{x_i=1}^{\lfloor\frac{m_i}{T}\rfloor}(m_i-T\times x_i)\\
&=\sum\limits_{T=1}^{m_i}\sum\limits_{d|T}\binom{d-1}{c-2}\mu(\dfrac{T}{d})\prod\limits_{i=1}^{n}(m_i\times\lfloor\dfrac{m_i}{T}\rfloor-T\times\dfrac{(1+\lfloor\dfrac{m_i}{T}\rfloor)\times\lfloor\dfrac{m_i}{T}\rfloor}{2})
\end{aligned}
$$

设 $f(x,c)=\sum\limits_{d|x}\binom{d-1}{c-2}\mu(\dfrac{x}{d})$，原式可变为:
$$
\sum\limits_{T=1}^{m_i}f(T,c)\prod\limits_{i=1}^{n}(m_i\times\lfloor\dfrac{m_i}{T}\rfloor-T\times\dfrac{(1+\lfloor\dfrac{m_i}{T}\rfloor)\times\lfloor\dfrac{m_i}{T}\rfloor}{2})
$$

容易发现后面是一个关于 $T$ 的 $n$ 次多项式，设这个多项式的 $i$ 次项为 $t_i$，继续化简：

$$
\sum\limits_{T=1}^{m_i}f(T,c)\sum\limits_{i=0}^{n}t_i\times T^i=\sum\limits_{i=0}^{n}t_i\sum\limits_{T=1}^{m_i}f(T,c)\times T^i
$$

容易发现 $t$ 只与 $m_i$ 和 $\lfloor\dfrac{m_i}{T}\rfloor$ 有关，使用数论分块并对后面的式子求前缀和即可解决。

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
namespace Wilson_Inversion {
void main();
}
int main() {
	Wilson_Inversion::main();
	return 0;
}
#define int long long
namespace Wilson_Inversion {
const int mod(10007);
int T, n, c, C[100010][21], f[100010][21], g[100010][21][12], zrsm[100010][12],
	m[12];
int p[100010], cnt, mu[100010], xs[12], tmp[12], _0[12], _1[12];
bool np[100010];
int qp(int x, int y) {
	int res(1);
	x %= mod;
	while (y) {
		if (y & 1) (res *= x) %= mod;
		(x *= x) %= mod;
		y >>= 1;
	}
	return res;
}
void init() {
	for (int i(0); i <= 100000; ++i) {
		C[i][0] = 1;
		int sj(min(i, 20ll));
		for (int j(1); j <= sj; ++j)
			C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % mod;
	}
	mu[1] = 1;
	for (int i(1); i <= 11; ++i) zrsm[1][i] = 1;
	for (int i(2); i <= 100000; ++i) {
		if (!np[i]) {
			for (int j(1); j <= 11; ++j) zrsm[i][j] = qp(i, j);
			p[++cnt] = i, mu[i] = -1;
		}
		for (int j(1); j <= cnt && i * p[j] <= 100000; ++j) {
			int now(i * p[j]);
			np[now] = true;
			for (int k(1); k <= 11; ++k)
				zrsm[now][k] = zrsm[i][k] * zrsm[p[j]][k] % mod;
			if (!(i % p[j])) break;
			mu[now] = -mu[i];
		}
	}
	for (int i(1); i <= 100000; ++i) {
		if (!mu[i]) continue;
		for (int j(1); i * j <= 100000; ++j) {
			for (int k(2); k <= 20; ++k) f[i * j][k] += mu[i] * C[j - 1][k - 2];
		}
		for (int k(2); k <= 20; ++k) f[i][k] %= mod;
	}
	for (int i(1); i <= 100000; ++i) {
		for (int j(2); j <= 20; ++j) {
			for (int k(1); k <= 11; ++k) {
				g[i][j][k] = f[i][j] * zrsm[i][k] % mod;
				(g[i][j][k] += g[i - 1][j][k]) %= mod;
			}
			g[i][j][0] = (f[i][j] + g[i - 1][j][0]) % mod;
		}
	}
}
void main() {
	init();
	scanf("%lld", &T);
	while (T--) {
		scanf("%lld%lld", &n, &c);
		for (int i(1); i <= n; ++i) scanf("%lld", m + i);
		sort(m + 1, m + 1 + n);
		int ans(0);
		for (int i(1); i <= m[1];) {
			int r(m[1] / (m[1] / i));
			for (int j(2); j <= n; ++j) r = min(r, m[j] / (m[j] / i));
			for (int j(1); j <= n; ++j)
				_0[j] = m[j] * (m[j] / i) % mod,
				_1[j] = (-(m[j] / i + 1) * (m[j] / i) / 2) % mod;
			memset(xs, 0, sizeof(xs)), xs[0] = 1;
			for (int j(1); j <= n; ++j) {
				memcpy(tmp, xs, sizeof(xs)), memset(xs, 0, sizeof(xs));
				for (int k(0); k < j; ++k)
					(xs[k] += tmp[k] * _0[j]) %= mod,
					(xs[k + 1] += tmp[k] * _1[j]) %= mod;
			}
			for (int j(0); j <= n; ++j)
				(ans += (g[r][c][j] - g[i - 1][c][j]) * xs[j]) %= mod;
			i = r + 1;
		}
		printf("%lld\n", (ans % mod + mod) % mod);
	}
}

}  // namespace Wilson_Inversion
```


---

## 作者：LinkyChristian (赞：1)

很显然，题目是 [P1447 [NOI2010] 能量采集](https://www.luogu.com.cn/problem/P1447) 的加强版。

本文主要介绍两种做法，需要卡常的 $O(Tnm)$ 做法，以及不需要卡常的 $O(Tn \sqrt{m})$ 做法。

显然考虑如果要求起点必须在原点，那么从原点到点 $(a_1,a_2,a_3,...,a_n)$ 的向量上除去原点就有 $\gcd_{1}^n a_i$ 个整点可供选取。

考虑枚举向量起点，为了不重不漏计数我们强制要求选取向量终点，设 $\gcd_{1}^n a_i=d$，这条向量上取 $c$ 个点的方案数就是 $\binom{d-1}{c-2}$。

假设枚举向量为 $(a_1,a_2,a_3,...,a_n)$，那么向量起点显然有 $\prod \limits_{i=1}^n (m_i-a_i)$ 种选取方法。

那么我们能列出第一个柿子：

$$
\sum \limits_{a_i=1}^{m_i} \binom{d-1}{c-2} \prod \limits_{i=1}^n (m_i-a_i)
$$

调换枚举顺序,设 $mn=\min_{i=1}^n m_i$，并反演一下：

$$
\sum \limits_{d=1}^{mn}\binom{d-1}{c-2} \sum \limits_{k=1}^{\lfloor \frac{mn}{d} \rfloor}\mu(k) \sum \limits_{a_i=1}^{\lfloor \frac{m_i}{kd} \rfloor } \prod \limits_{i=1}^n (m_i-a_ikd)
$$

设 $T=kd$：

$$
\sum \limits_{T=1}^{mn} \sum \limits_{d|T} \binom{d-1}{c-2}\mu(\frac{T}{d})  \sum \limits_{a_i=1}^{\lfloor \frac{m_i}{T} \rfloor } \prod \limits_{i=1}^n (m_i-a_iT)
$$

设 $g(T)=\sum \limits_{T=1}^{mn} \sum \limits_{d|T} \binom{d-1}{c-2}\mu(\frac{T}{d})$,$f(d)=\binom{d-1}{c-2}$ 很显然 $g$ 是 $f$ 与 $\mu$ 的狄利克雷卷积，即 $g=f*\mu$。

这里有个~~有趣~~经典的结论，即如果 $g=f*\mu$，那么 $f=g*1$，即 $f$ 为 $g$ 的狄利克雷前缀和，$g$ 为 $f$ 的差分。

证明也很容易，我们对每个质因数 $p^k$ 来证明。

如果 $g(p^k)=\sum \limits_{i=1}^{k} f(p^i) \mu(\frac{p^k}{p^i})$ 显然 $g(p^k) = f(p^k)-f(p^{k-1})$ 将所有质因数一起考虑即可得到上述结论。

因此我们可以对每个 $c$ 预处理 $g(T)$，复杂度为 $O(cm\log\log m)$。

再对原柿进行最后一步转化：

$$
\sum \limits_{T=1}^{mn} g(T) \prod \limits_{i=1}^n \sum \limits_{a_i=1}^{\lfloor \frac{m_i}{T} \rfloor } (m_i-a_i)
$$

$$
\sum \limits_{T=1}^{mn} g(T) \prod \limits_{i=1}^n ({m_i}{\lfloor \frac{m_i}{T} \rfloor }-\frac{T(1+{\lfloor \frac{m_i}{T} \rfloor })({m_i}{\lfloor \frac{m_i}{T} \rfloor })}{2})
$$

就可以 $O(Tnm)$ 求了，精通卡常技巧的话卡一卡还是能过的。

注意少取模，以及尽量让内存连续调用，可以大大减小常数

```cpp
#include<iostream>
#define N 100010
#define mod 10007
#define M 22
#define V 100000
using namespace std;
int p[N],vis[N],tot,g[M][N],C[M][N];
void add(int& a1,int a2) {if((a1+=a2)>=mod) a1-=mod;}
int md1(int x){return x>=mod?x-mod:x;}
int T,n,m[M];
int main() {
	for(int i=2; i<=V; i++) {
        if(!vis[i]) p[++tot]=i;
        for(int j=1; j<=tot&&i*p[j]<=V; j++) {
            vis[i*p[j]]=1;
            if(i%p[j]==0) break;
        }
    }
    for(int i=0; i<=V; i++) C[0][i]=1;
    for(int j=1; j<=20; j++)
        for(int i=1; i<=V; i++) C[j][i]=md1(C[j-1][i-1]+C[j][i-1]);
    for(int c=2; c<=20; c++) {
        for(int i=1; i<=V; i++) g[c][i]=C[c-2][i-1];
        for(int i=1; i<=tot; i++)
            for(int j=V/p[i]; j; j--) add(g[c][j*p[i]],mod-g[c][j]);
    }
    cin.tie(0)->sync_with_stdio(0);
    cin>>T;
    int c;
    while(T--) {
        cin>>n>>c;int mn=0x3f3f3f3f,ans=0;
        for(int i=1; i<=n; i++) cin>>m[i],mn=min(mn,m[i]);
        for(int d=1; d<=mn; d++) {
            int res=g[c][d];
            for(int i=1,mm; i<=n; i++) {
                mm=m[i]/d;
                res=res*(1ll*m[i]*mm-(1ll+mm)*mm/2*d)%mod;
            } ans+=res;
        }  cout<<ans%mod<<'\n';
    }
    return 0;
}
```


不过也可以进行进一步的优化，考虑后面的$\prod \limits_{i=1}^n ({m_i}{\lfloor \frac{m_i}{T} \rfloor }-\frac{T(1+{\lfloor \frac{m_i}{T} \rfloor })({m_i}{\lfloor \frac{m_i}{T} \rfloor })}{2})$ 是一个关于 $T$ 的 $n$ 次多项式，我们设其为 $\sum \limits_{i=0}^n t_iT^i$。

柿子变为

$$
\sum \limits_{T=1}^{mn} g(T) \sum \limits_{i=0}^n t_iT^i
$$

$$
\sum \limits_{i=0}^n t_i \sum \limits_{T=1}^{mn} g(T) T^i
$$

显然柿子前面的部分只与 $\lfloor \frac{m_i}{T} \rfloor$ 有关,可以动态规划求解，后面的可以用前缀和求解，数论分块即可，复杂度 $O(Tn\sqrt{m})$。

---

## 作者：Purslane (赞：1)

# Solution

希望别假了啊 /kk

考虑我们在相邻两个点之间连线。那么我们会得到一些差分向量 $\vec{a_i}$。题目要求所有的 $\vec{a_i}$ 互相平行。 

考虑每个向量把所有维的最大公约数除去，我们会得到一个所有维最大公约数为 $1$ 的向量，我们称之为**本原向量**。那么很显然，所有 $\vec{a_i}$ 对应的本原向量也都是平行的，而且必定相同。

所以考虑枚举这个本原向量 $\vec{h}$。每个差分向量本质上都是 $\lambda \vec{h}$，$\lambda \in \mathbb{N+}$。所以考虑枚举 $\sum_{i=1}^{c-1} \lambda_i=t$。那么对于每一个 $1 \le i \le n$，$\vec{h}$ 对应的这一维都有 $th_i\le m_i$，也就是我们知道了 $1 \le h_i \le \lfloor \frac{m_i}{t} \rfloor$。

因此我们对于每个 $t$ 求：

$$\sum_{\gcd(h_1,h_2,\dots,h_n)=1,1 \le h_i \le \lfloor \frac{m_i}{t} \rfloor} C_{t-1}^{c-2} \prod_{i=1}^n (m_i-th_i)$$

然后考虑写成这样

$$\sum_{1 \le h_i \le \lfloor \frac{m_i}{t} \rfloor} [\gcd(h_1,h_2,\dots,h_n)=1] C_{t-1}^{c-2} \prod_{i=1}^n (m_i-th_i)$$

用莫比乌斯反演拆开得到

$$ \sum_{t=1}^{\min\{m_i\}}C_{t-1}^{c-2} \sum_{d=1}^{\min\{\lfloor \frac{m_i}{t} \rfloor\}} \mu(d) \prod_{i=1}^n \sum_{j=1}^{\lfloor \frac{m_i}{dt}\rfloor} (m_i-tdj)$$

这个东西看着就比较邪恶。然后很显然，最后面的和式可以 $O(1)$ 用等差数列计算。因此当 $t$ 一定的时候，我们就可以 $O(n \min\{\lfloor \frac{m_i}{t} \rfloor\})$ 的算出这个式子。 如果你直接枚举 $t$ 的话，差不多可以获得一个 $O(nm \log m)$ 的做法。很显然过不了。

然后考虑枚举 $td$。于是你只需要求出 $\sum_{d|n} C_{d-1}^{c-2} \mu (\frac{n}{d})$ 即可。

很显然，可以使用质数的高维前缀和。（还不能算是前缀和吧，枚举质数然后倒着加）这样就可以在 $O(cm \log m)$ 的复杂度内全给预处理出来。

所以总体复杂度是 $O(Tnm+cm \log m)$。如今的电脑算个 $5 \times 10^8$ 都有可能过！

看看我能不能冲过去。

卡常心得：

1. `inline` 和 `const`。
2. 内存小一点的基本变量类型运算快一点。
3. 少取模。
4. 数组小的一维在前面（为啥我的犇犇里面一堆人在讨论这个事情）

```cpp
#include<bits/stdc++.h>
#define ffor(i,a,b) for(int i=(a);i<=(b);++i)
#define roff(i,a,b) for(int i=(a);i>=(b);--i)
using namespace std;
const int MAXN=1e5+10,MOD=10007;
int T,n,c,mx=100000,m[MAXN];
short C[21][MAXN],f[21][MAXN];
vector<int> pr; int flg[MAXN];
void init(int mx) {
	ffor(i,2,mx) {
		if(!flg[i]) pr.push_back(i);
		for(auto v:pr) {
			if(i*v>mx) break;
			flg[i*v]=1;
			if(i%v==0) break;	
		}
	}
	return ;
}
inline short kmod(const short a) {if(a<0) return a+MOD; if(a>=MOD) return a-MOD; return a;}
int main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	init(mx);
	C[0][0]=1;
	ffor(i,1,mx) {C[0][i]=1;ffor(j,1,18) C[j][i]=kmod(C[j-1][i-1]+C[j][i-1]);}
	ffor(c,2,20) {
		ffor(i,1,mx) f[c][i]=C[c-2][i-1];
		for(auto v:pr) roff(i,mx/v,1) f[c][i*v]=kmod(f[c][i*v]-f[c][i]);
	}
	cin>>T;
	while(T--) {
		cin>>n>>c; ffor(i,1,n) cin>>m[i];
		int ans=0,mn=*min_element(m+1,m+n+1);
		ffor(td,1,mn-1) {
			short mul=f[c][td];
			ffor(i,1,n) mul=1ll*mul*(m[i]-td+m[i]%td)*(m[i]/td)/2%MOD;
			ans=kmod(ans+mul);
		}
		cout<<ans<<'\n';
	}
	return 0;
}

```

不保证下一次提交还能过。

---


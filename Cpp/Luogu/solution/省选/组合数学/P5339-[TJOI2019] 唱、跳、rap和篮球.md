# [TJOI2019] 唱、跳、rap和篮球

## 题目背景

TJOI2019 D1T3

源文件名：queue.*

时间限制: 4s 内存限制: 128M

## 题目描述

大中锋的学院要组织学生参观博物馆，要求学生们在博物馆中排成一队进行参观。他的同学可以分为四类：一部分最喜欢唱、一部分最喜欢跳、一部分最喜欢rap，还有一部分最喜欢篮球。如果队列中$k$,$k + 1$,$k + 2$,$k + 3$位置上的同学依次，最喜欢唱、最喜欢跳、最喜欢rap、最喜欢篮球，那么他们就会聚在一起讨论蔡徐坤。大中锋不希望这种事情发生，因为这会使得队伍显得很乱。大中锋想知道有多少种排队的方法，不会有学生聚在一起讨论蔡徐坤。两个学生队伍被认为是不同的，当且仅当两个队伍中至少有一个位置上的学生的喜好不同。由于合法的队伍可能会有很多种，种类数对$998244353$取模。

## 说明/提示

对于20%的数据，有$n=a=b=c=d\le500$

对于100%的数据，有$n \le 1000$ ， $a, b, c, d \le 500$

## 样例 #1

### 输入

```
4 4 3 2 1
```

### 输出

```
174
```

## 样例 #2

### 输入

```
996 208 221 132 442
```

### 输出

```
442572391
```

# 题解

## 作者：Fading (赞：60)

![ERD1q1.jpg](https://s2.ax1x.com/2019/05/10/ERD1q1.jpg)

------------

首先转换一下问题：

我们求有多少个排布方案，满足至少有$1$堆人讨论鸡你太美。

怎么求呢？

我们可以枚举有$i$堆人讨论鸡你太美，这样放置的方案数是

$$C_{n-3i}^{i}$$

为什么呢？

### 第一个方法是整体法（感谢@千年之狐_天才 大佬）

首先，对于每一种方案，有$n-4i$个没有被选中的位置。

我们可以考虑枚举这些没有被选中的位置。

把每一个讨论鸡你太美的组看成一个整体，缩成一个点。

这样就有$n-3i$个点了。

对于所有$n-3i$个点，如果被选中，成为一个讨论鸡你太美的组，那么这个点就要被**展开**代表$4$个人。

否则就代表一个人。

我们直接从这$n-3i$个点中选取$n-4i$个点作为没有被选为组的点。

这样方案数就是$C_{n-3i}^{n-4i}=C_{n-3i}^i$

显然这样的枚举对应的方案是唯一的（可以把这些选为组的点展开，再顺序标号）。

### 第二个方法是转化法。

可以考虑转化一下问题。这等价于求$1$~$n-3$放置$i$个数且$i$个数两两距离$\geq 4$的组合数$,$即$a_j+4\leq a_{j+1}$

设$b_j=a_j-3\times j,$显然

$$b_{j+1}-b_j=a_{j+1}-a_j-3$$

$$a_j+3=a_{j+1}-(b_{j+1}-b_j)\leq a_{j+1}-1$$

$1\leq a_j=b_j+3\times j\leq n-3$

$\therefore b\in[-2,n-3i-3]$

所以我们枚举$b$的组合，就可以得到满足条件的$a$的组合

所以答案就等于$b$的组合个数

$$\therefore\ ans=C_{n-3i}^i$$



------------


然后这么多位置已经固定了，怎么计算剩余不讨论鸡你太美的人的排列数呢？？？

真心难算！因为可能有些排列会有不只$i$个人讨论鸡你太美！

所以我们考虑用容斥原理，枚举有$i$~$\frac n4$组人讨论鸡你太美。

这样就可以排除干扰，对剩下的乱排列了。

设初始$4$个数最小值为$mini$

答案$ans=$

$$\sum_{i=1}^{mini}(-1)^{i-1}\cdot C_{n-3i}^i\cdot[\text{剩余n-4i个数的排列个数}]$$

这个为什么对呢？

发现枚举至少一组的时候，对于一种可行的方案（这里代指枚举方案）会算$2$次至少两组的贡献，算$3$次至少三组的贡献。

枚举至少两组的时候，会算$3$次至少三组的贡献，算$6$次至少四组的贡献。

### 枚举至少$i$组的时候，会算$C_j^i$次至少j组的贡献$(j\geq i)$

所以我们可以通过容斥

$$\sum_{i=1}^n(-1)^{i-1}C_n^i=1$$

来算出单个的贡献。这可以通过二项式展开来证明。

所以答案$ans=$

$$\sum_{i=1}^{mini}(-1)^{i-1}\cdot C_{n-3i}^i\cdot[\text{剩余n-4i个数的排列个数}]$$

------------

设喜欢$4$种大法的人初始有$x_1,x_2,x_3,x_4$个

这时候分别还剩下$x_1-i,x_2-i,x_3-i,x_4-i$个人

相当于求**有重复元素的排列**！

我们知道，如果$x_1+x_2+x_3+x_4=n$

那么排列答案就是$\frac {(n-4i)!}{(x_1-i)!(x_2-i)!(x_3-i)!(x_4-i)!}$

如果$x_1+x_2+x_3+x_4<n$，答案就是$0$。

如果$x_1+x_2+x_3+x_4>n$呢？考虑暴力枚举+排列。

$$ans=\sum_{a\leq x_1-i,b\leq x_2-i,c\leq x_3-i,d\leq x_4-i}[a+b+c+d=n-4i]\frac {(n-4i)!}{a!b!c!d!}$$

$$=(n-4i)!\sum_{a\leq x_1-i,b\leq x_2-i,c\leq x_3-i,d\leq x_4-i}[a+b+c+d=n-4i]\frac {1}{a!}\frac{1}{b!}\frac {1}{c!}\frac {1}{d!}$$

这就是一个四元卷积啦！

维护$4$个数组，里面元素全是阶乘值（显然有上界），做$NTT$即可。

~~模数真良心~~

我们前面还要用所有排列的个数减去答案，所以真正的答案其实就是

$$\sum_{i=0}^{mini}(-1)^{i}\cdot C_{n-3i}^i\cdot[\text{剩余n-4i个数的排列个数}]$$

一个标准的容斥式子。

数学真是美妙啊！！！

对了，复杂度是$O(n^2log_2n)$，比较慢。

代码如下：

```cpp
#include<bits/stdc++.h>
#define ll long long
#define ljc 998244353
using namespace std;
ll n,m,r[40006],lim;
ll a[20001],w[20001],b[20001],mini,num[4],c[20001],d[20001],fac[20010],inv[20001];
inline ll fast_pow(ll a,ll b,ll p){
    ll t=1;a%=p;
    while (b){
        if (b&1) t=t*a%p;
        b>>=1;a=a*a%p;
    }
    return t;
}
inline void NTT(ll f[],int lim,int id){
    for (int i=0;i<lim;i++){
        if (i<r[i]) swap(f[r[i]],f[i]);
    }
    w[0]=1;
    for (int len=1;len<lim;len<<=1){
        ll gen=fast_pow(3,(ljc-1)/(len<<1)*id+ljc-1,ljc);
        for (int i=1;i<len;i++) w[i]=w[i-1]*gen%ljc;
        for (int i=0;i<lim;i+=len<<1){
            ll *f1=f+i,*f2=f1+len;
            for (int j=0;j<len;j++){
                ll x=f1[j],y=f2[j]*w[j]%ljc;
                f1[j]=(x+y)%ljc;
                f2[j]=(x-y+ljc)%ljc;
            }
        }
    }
    if (id==1) return;
    ll Inv=fast_pow(lim,ljc-2,ljc);
    for (int i=0;i<lim;i++) f[i]=f[i]*Inv%ljc;
}
inline ll P(ll n,ll A,ll B,ll C,ll D){
    if (n>A+B+C+D) return 0;
    if (n<0) return 0;
    ll lim=1,len=0;
    while (lim<(A+B+C+D<<1)) lim<<=1,len++;
    for (int i=0;i<lim;i++) r[i]=(r[i>>1LL]>>1LL)|(((1LL*i)&1)<<(len-1LL));
    for (int i=0;i<lim;i++) a[i]=(i<=A)?inv[i]:0;
    for (int i=0;i<lim;i++) b[i]=(i<=B)?inv[i]:0;
    for (int i=0;i<lim;i++) c[i]=(i<=C)?inv[i]:0;
    for (int i=0;i<lim;i++) d[i]=(i<=D)?inv[i]:0;
    NTT(a,lim,1);NTT(b,lim,1);NTT(c,lim,1);NTT(d,lim,1);
    for (int i=0;i<lim;i++) a[i]=a[i]*b[i]%ljc*c[i]%ljc*d[i]%ljc;
    NTT(a,lim,-1);
    return fac[n]*a[n]%ljc;
}
inline ll C(ll m,ll n){
    if (m<n) return 0;
    return (fac[m]*inv[n]%ljc*inv[m-n]%ljc);
}
inline void init(int n){
    n*=2;
    inv[0]=inv[1]=1;fac[0]=1;
    for (int i=1;i<=n;i++) fac[i]=fac[i-1]*i%ljc;
    for (int i=2;i<=n;i++) inv[i]=(ljc-(ljc/i)*inv[ljc%i]%ljc)%ljc;
    for (int i=2;i<=n;i++) inv[i]=inv[i-1]*inv[i]%ljc;
}
int main(){
    cin>>n>>num[0]>>num[1]>>num[2]>>num[3];
    mini=min(num[0],min(num[1],min(num[2],num[3])));
    init(n);
    ll ans=0,one=1;
    for (int i=0;i<=min(mini,n/4);i++){
        ans=(ans+one*C(n-3*i,i)%ljc*P(n-4*i,num[0]-i,num[1]-i,num[2]-i,num[3]-i)%ljc)%ljc;
        one=ljc-one;		
    }
    cout<<ans;
    return 0;
}
```

---

## 作者：Elegia (赞：47)

介绍一下这道题如何做到 $\Theta(n^{3/2})$。

记 $a_{1,2,3,4}$ 表示输入的 $a,b,c,d$。

$$
P_k(x)=\sum_{j=0}^k\frac{x^j}{j!}
$$

那么根据对相邻四个的容斥，我们不难得到答案可表述为如下求和：

$$
\sum_{k=0}^{\min(\min \{a_i\}, \lfloor n/4\rfloor)} \frac{(n-3k)!}{k!}[x^{n-4k}]\prod_{i=1}^4 P_{a_i-k}(x)
$$

首先我们考虑 $\prod P_{a_i-k}$ 这个东西如何直接计算，考虑微分方程可得：

$$
P_k(x)'=P_k(x)-\frac{x^k}{k!}
$$

记 $\Pi_S(x) = \prod_{i\in S} P_{a_i-k}(x)$，那么求导可得

$$
\begin{aligned}
\Pi_S(x)' &= \Pi_S(x) \cdot \sum_{i\in S} \frac{P'_{a_i-k}(x)}{P_{a_i-k}(x)}\\
&= \Pi_S(x) \cdot \sum_{i\in S} \frac{P_{a_i-k}(x)-\dfrac{x^{a_i-k}}{(a_i-k)!}}{P_{a_i-k}(x)}\\
&= |S|\Pi_{S}(x) - \sum_{i\in S}\frac{x^{a_i-k}}{(a_i-k)!}\cdot \Pi_{S\backslash \{i\}}(x)
\end{aligned}
$$

寻此微分方程，我们可以在 $\Theta(n)$ 时间内完成乘积的计算。

然后我们不妨考虑分块，我们注意上述过程中已经算出了所有子集，不妨考虑计算 $\prod(A_i -B_i)$，令 $A_i=P_{a_i-r},B_i=P_{a_i-r}-P_{a_i-l}$，那么 $B_i$ 的所有子集乘积可以在 $\Theta(r-l)$ 的时间内维护出，因为有值项只是这么长的一段区间，其微分方程类似。因此如果我们每 $S$ 个 $l$ 重构一次 $A$，那么复杂度即为 $\Theta(n\cdot \frac nS + S\cdot n) \ge \Theta(n^{3/2})$。

更精细地分析，如果认为总共有 $K$ 项（本题中 $K=4$），那么复杂度为 $\Theta(K2^Kn \cdot \frac nS + K^22^KS\cdot n) \ge \Theta((nK)^{3/2}2^K)$。

---

## 作者：command_block (赞：30)

CXK题怎么都这么毒瘤啊/kk

设$f(k)$为钦定$k$个鸡你太美,其余放任自流的方案数。

$g(k)$为队伍中恰好有$k$个鸡你太美的方案数,我们要求的就是$g(0)$。

可以得到$f(k)=\sum\limits_{i=k}\dbinom{i}{k}g(k)$

那么二项式反演可得$g(k)=\sum\limits_{i=k}(-1)^{i-k}\dbinom{i}{k}f(k)$

设$S(a,b,c,d,n)$为随便排列的方案数,不符合题意即为$0$。

又可以得到$f(k)=\dbinom{n-3k}{k}S(a-k,b-k,c-k,d-k,n-4k)$

得$g(0)=\sum\limits_{k=0}(-1)^kf(k)$

$=\sum\limits_{k=0}(-1)^k\dbinom{n-3k}{k}S(a-k,b-k,c-k,d-k,n-4k)$

剩下的问题就是求$S$了。

$S(a,b,c,d,n)$的组合意义就是在四种颜色里面(有个数限制)取一些来涂色。

(为了方便令$X_i=\dfrac{x^i}{i!}$)

这个是EGF经典问题,考虑构造$R_k(x)=\sum\limits_{i=0}^kX_i$,就是$k$个同种颜色的EGF。

EGF卷积的意义就是随意插入混合,那么我们把四个$R$卷起来之后取第$n$项就可以得到答案了。

这样子的话要对每一个$S$都做一次NTT,复杂度$O(n^2logn)$,比较慢。

我们需要的$S$的参数比较特殊,可以针对来优化。

我们从小到大枚举$k$,那么相当于每次都会在四个$R$的后面添加一项。

我们考虑一个一个来添加,分别维护前两个EGF的卷积和后两个EGF的卷积。

最后因为只需要查询一项,$O(n)$暴力即可。

考虑前两个,后两个类似 :

$R_aR_b=(R_{a-1}+X_a)(R_{b-1}+X_b)=R_{a-1}R_{b-1}+X_aR_b+X_bR_a-X_aX_b$

$R_{a-1}R_{b-1}$上一次知道了,后面的几项$O(n)$计算即可。

综上,时间复杂度$O(n^2)$,空间$O(n)$,代码写起来比较流畅。

随手交了一发居然rk1了,不过应该很快就会被超过去。

~~这个题范围扩大3倍不过分吧~~

```cpp
#include<algorithm>
#include<cstdio>
#define ll long long
#define mod 998244353
#define Maxn 1050
using namespace std;
int r[Maxn];
ll invn,invG;
ll powM(ll a,ll t=mod-2)
{
  ll ans=1;
  while(t){
  	if(t&1)ans=ans*a%mod;
  	a=a*a%mod;
  	t>>=1;
  }return ans;
}
ll ifac[Maxn],fac[Maxn];
ll C(int n,int m)
{return fac[n]*ifac[m]%mod*ifac[n-m]%mod;}
void Init(int lim)
{
  ifac[0]=fac[0]=1;
  for (int i=1;i<=lim;i++)
    fac[i]=fac[i-1]*i%mod;
  ifac[lim]=powM(fac[lim]);
  for (int i=lim-1;i;i--)
    ifac[i]=ifac[i+1]*(i+1)%mod;
}
ll R1[Maxn],R2[Maxn];
int a,b,c,d,n;
int main()
{
  scanf("%d%d%d%d%d",&n,&a,&b,&c,&d);
  Init(n);
  int k=min(min(min(a,b),min(c,d)),n/4);
  a-=k;b-=k;c-=k;d-=k;
  for (int i=0;i<=a;i++)
    for (int j=0;j<=b;j++)
      R1[i+j]=(R1[i+j]+ifac[i]*ifac[j])%mod;
  for (int i=0;i<=c;i++)
    for (int j=0;j<=d;j++)
      R2[i+j]=(R2[i+j]+ifac[i]*ifac[j])%mod;
  ll ans=0;
  for (;k>=0;k--){
    ll buf=0;
    int tp=n-4*k;
    for (int i=0;i<=tp;i++)
      buf=(buf+R1[i]*R2[tp-i])%mod;
    buf=buf*fac[tp]%mod*C(n-3*k,k)%mod;
    ans=(ans+ ((k&1) ? mod-buf : buf) )%mod;
    a++;b++;c++;d++;
    for (int i=0;i<=a;i++)
	  R1[i+b]=(R1[i+b]+ifac[i]*ifac[b])%mod;
    for (int i=0;i<=b;i++)
	    R1[i+a]=(R1[i+a]+ifac[i]*ifac[a])%mod;
  	R1[a+b]=(-ifac[a]*ifac[b]%mod+R1[a+b]+mod)%mod;
  	for (int i=0;i<=c;i++)
      R2[i+d]=(R2[i+d]+ifac[i]*ifac[d])%mod;
    for (int i=0;i<=d;i++)
      R2[i+c]=(R2[i+c]+ifac[i]*ifac[c])%mod;
    R2[c+d]=(-ifac[c]*ifac[d]%mod+R2[c+d]+mod)%mod;
  }printf("%lld",ans);
  return 0;
}
```


---

## 作者：Hope2075 (赞：28)

~~题面非常好~~

据说要用NTT和生成函数搞

然而我都不会

于是我就用组合数强行算出来了

首先，如果每种爱好没有人数限制？

这样，我们可以分别计算至少有0组讨论cxk，至少1组，至少2组……

最后容斥一下就可以，系数为$(-1)^i$

而这种情况下，只需要选择讨论cxk的组所在位置就可以，剩下的位置就是$4^k$种情况

这个可以DP出来，但我不是这样算的

可以把讨论cxk的组插入到剩余部分中，这样就是可重复选择的组合数，也就是$(^{r+t}_t)$，$r$表示剩余部分人数，$t$表示讨论cxk的组数

或者将讨论cxk的组作为一个整体，然后求组合数也可以

接下来考虑人数限制

考虑把剩下的位置分步计算

直接的想法是这样的：

$\sum _{i=0} ^a (^n_i) \sum_{j=0} ^{n-i} (^{n-i}_j)\sum_{k=0} ^{n-i-j} (^{n-i-j}_k)$

（注意这里对人数的限制可能不完整）

也就是，先从$n$个位置中选出$i$个位置是唱，再从剩下的$n-i$个位置中选出$j$个位置是跳，再从剩下的$n-i-j$个位置中选出$k$个位置是rap，最后剩下的部分是篮球

然后你会发现，这个式子复杂度是$O(n^3)$的，再加上容斥，就是$O(n^4)$，即使用前缀和优化一下，也是$O(n^3)$的

可能还有其它方法能算出来，但我不会

如果换一个办法算？

当然可以

$\sum_{r=0}^n [(^n_r)\cdot(\sum_{k=r-b}^a (_k^r))\cdot (\sum_{k=n-r-d}^b (_k^{n-r}))]$

首先选出$r$个位置唱或跳，剩下的部分rap或篮球

然后，对两部分分别求方案数，这样就可以了

发现$\sum_{k=r-b}^a (_k^r)$和$\sum_{k=n-r-d}^b (_k^{n-r})$都可以用前缀和求出来

这样，只要枚举$r$就可以了

具体实现时，先用杨辉三角把$\leq n$的组合数求出来，然后求每一行的前缀和，随后先枚举至少有几组讨论cxk，再枚举$r$，容斥一下就可以

小心边界情况

代码

```cpp
#include<cstdio>
const long long M=998244353;
long long C[1024][1024];
long long suf[1024][1024];
int a,b,c,d,n,t;
int read(){
    int n=0;bool f=0;char c=getchar();
    while(c!='-'&&(c<'0'||c>'9'))c=getchar();
    if(c=='-'){f=1;c=getchar();};
    while(c>='0'&&c<='9'){
        n=n*10+c-'0';
        c=getchar();
    }
    if(f==1)return -n;
    else return n;
}
char res[25];
void write(long long n){
    if(n==0){putchar('0');return;};
    if(n<0){putchar('-');n=-n;}
    int t=0;
    while(n){res[t++]=n%10+'0';n/=10;};
    while(t--)putchar(res[t]);
    return;
}
void calc(){//求组合数及前缀和
    for(int i=0;i<=n;i++){
        C[i][0]=1;
        for(int j=1;j<=i;j++){
            C[i][j]=C[i-1][j-1]+C[i-1][j];
            if(C[i][j]>=M)C[i][j]-=M;
        }
    }
    for(int i=0;i<=n;i++){
        suf[i][0]=1;
        for(int j=1;j<=n;j++){
            suf[i][j]=suf[i][j-1]+C[i][j];
            if(suf[i][j]>=M)suf[i][j]-=M;
        }
    }
}
long long grange(int t,int l,int r){//求一段区间的和
    if(l>r)return 0;
    if(l<=0)return suf[t][r];//不特判会RE
    long long res=suf[t][r]-suf[t][l-1];
    if(res<0)res+=M;
    return res;
}
long long ans;
long long rs;
int main(){
    n=read();a=read();b=read();c=read();d=read();
    if(a>n)a=n;//如果求组合数的时候，只求到n
    if(b>n)b=n;//那么这里必须这样做
    if(c>n)c=n;//否则计算时会取到没计算过的数值
    if(d>n)d=n;//然后就会WA
    calc();
    //这里n,a,b,c,d表示剩余部分的人数，t表示有多少组讨论cxk
    while(n>=0&&a>=0&&b>=0&&c>=0&&d>=0){
        rs=0;
        for(int r=0;r<=n;r++){
            rs+=C[n][r]*grange(r,r-b,a)%M*grange(n-r,n-r-d,c)%M;
            if(rs>=M)rs-=M;
        }
        rs=rs*C[n+t][t]%M;
        if(t&1){
            ans-=rs;
            if(ans<0)ans+=M;
        }else{
            ans+=rs;
            if(ans>=M)ans-=M;
        }
        n-=4;a--;b--;c--;d--;t++;
    }
    ans%=M;
    if(ans<0)ans+=M;
    write(ans);
}
```

---

## 作者：JZYshuraK (赞：21)

# [TJOI2019]唱、跳、rap和篮球

这么多人过没人写题解啊

那我就随便说说了嗷

这题第一步挺套路的，就是题目要求不能存在balabala的时候考虑正难则反，要求必须存在的方案数然后用总数减，往往更简单。

这个题呢直接要求存在发现还不咋好求，反正就是存在嘛我们就容斥好了。

呐，我们就枚举至少有多少段（唱跳rap篮球）。

假设有$i$段，那么枚举一下这$i$段的位置，这是$\binom{n-3i}{i}$的。

就相当于给定长度为$n-3i$的空格，选出$i$个空格为（唱跳rap篮球）的起始点就好了。

假设每种人分别有$num[1]$到$num[4]$个，把他们都$-i$，就相当于求剩下这些人随意排列的方案数咯。

假设第$i$种人用了$now[i]$个，那么方案数为
$\frac{(n-4i)!}{\prod now[j]!}$。

这东西就是拿生成函数搞一搞就好了。

就是第一个人的生成函数是$\sum\limits_{i=0}^{num[1]} \frac{x^i}{i!}$。

把这四个生成函数乘一起，最后返回第$n-4i$项乘以$(n-4i)!$就好啦。

贴个代码

```cpp
#include <bits/stdc++.h>
#define N 1010 
using namespace std;
typedef long long ll;
const int mod = 998244353 ;
int C[N][N],num[5],len[5],fac[N<<2],inv[N<<2],b[5][N<<2];
int n;
char *p1,*p2,buf[100000];
#define nc() (p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++)
int rd() {int x=0,f=1; char c=nc(); while(c<48) {if(c=='-') f=-1; c=nc();} while(c>47) x=(((x<<2)+x)<<1)+(c^48),c=nc(); return x*f;}
int qpow(int x,int y)
{
	int ans=1;
	while(y)
	{
		if(y&1) ans=(ll)ans*x%mod;
		y>>=1;
		x=(ll)x*x%mod;
	}
	return ans;
}
void init()
{
	fac[0]=1; for(int i=1;i<=1000;i++) fac[i]=(ll)fac[i-1]*i%mod;
	inv[0]=1; for(int i=1;i<=1000;i++) inv[i]=qpow(fac[i],mod-2);
}
void ntt(int *a,int len,int flg)
{
	int i,j,k,t,w,x,tmp;
	for(i=k=0;i<len;i++)
	{
		if(i>k) swap(a[i],a[k]);
		for(j=len>>1;(k^=j)<j;j>>=1);
	}
	for(k=2;k<=len;k<<=1)
	{
		t=k>>1;
		x=qpow(3,(mod-1)/k);
		if(flg==-1) x=qpow(x,mod-2);
		for(i=0;i<len;i+=k)
			for(j=i,w=1;j<i+t;j++)
			{
				tmp=(ll)a[j+t]*w%mod;
				a[j+t]=(a[j]-tmp+mod)%mod;
				a[j]=(a[j]+tmp)%mod;
				w=(ll)w*x%mod;
			}
	}
	if(flg==-1) for(t=qpow(len,mod-2),i=0;i<len;i++) a[i]=(ll)a[i]*t%mod;
}
int calc(int k)
{
	int l=1;
	while(l<=max((num[4]-k)<<1,(n-4*k)<<1)) l<<=1;
	while(l<=(num[4]<<2)) l<<=1;
	for(int i=1;i<=4;i++)
	{
		len[i]=num[i]-k;
		for(int j=0;j<=l;j++) b[i][j]=0;
	}
	for(int i=1;i<=4;i++) for(int j=0;j<=len[i];j++) b[i][j]=inv[j];
	for(int i=1;i<=4;i++) ntt(b[i],l,1);
	for(int i=2;i<=4;i++) for(int j=0;j<l;j++) b[1][j]=(ll)b[1][j]*b[i][j]%mod;
	ntt(b[1],l,-1);
	return (ll)b[1][n-4*k]*fac[n-4*k]%mod;
}
int main()
{
	n=rd(); for(int i=1;i<=4;i++) num[i]=rd();
	for(int i=0;i<=n;i++)
	{
		C[i][0]=1;
		for(int j=1;j<=i;j++) C[i][j]=(C[i-1][j]+C[i-1][j-1])%mod;
	}
	sort(num+1,num+5);
	int l=1;
	while(l<=(num[4]<<2)) l<<=1;
	init();
	int ans=0;
	for(int i=0;(i<<2)<=min(n,num[1]<<2);i++)
	{
		int mdl=(ll)calc(i)*C[n-3*i][i]%mod;
		if(i&1) (ans-=mdl)%=mod;
		else (ans+=mdl)%=mod;
	}
	printf("%d\n",(ans+mod)%mod);
	return 0;
}
```

---

## 作者：jklover (赞：15)

本文同步发布于[我的blog](https://jkloverdcoi.github.io/2019/05/02/TJOI2019-%E9%80%89%E5%81%9A/).
- 容斥原理+ $dp$ 计数.
- 为了方便,称题目中所说的一组同学为 **位置** $k$ **在讨论蔡徐坤** ,要求出没有位置在讨论蔡徐坤的方案数.
- 显然可以容斥原理搞一搞,只需对每个 $i$ 求出钦定 $i$ 个位置在讨论蔡徐坤,其它不涉及的位置乱选的方案数.
- 其它位置乱选方案数就是有重复元素的排列数,但每个元素使用次数有限制.可以构造多项式 $(x+y+z+w)^{tot}$,$tot=n-4i$ ,将次数符合要求的对应系数求和.
- 二项式定理套两次,多项式展开为
$
(x+y+z+w)^{tot}
=\sum C_{tot}^j(\sum C_j^p x^p y^{j-p})(\sum C_{tot-j}^q z^q w^{tot-j-q})
$
- 预处理组合数前缀和,把 $x,y,z,w$ 系数都符合限制的那一段取出来计算即可.
- 考虑怎么求钦定 $i$ 个位置在讨论蔡徐坤的方案数.
- 抽象一下就是选出 $i$ 个位置,相邻两个位置之差至少为 $4$ .需要求出每个 $i$ 的方案数.
- 可以设计一个三维的 $dp$ ,状态需要记录考虑的数目,选的数目,最后一个选的位置.
- 注意到最后一个选的位置其实只有四种情况有区别,设 $f(j,i,0/1/2/3)$ 表示已经考虑了前 $j$ 个位置,选了 $i$ 个位置,最后选的位置分别是 $j,j-1,j-2,\leq j-3$ 时的方案数.将 $f(n-3,i,0/1/2/3)$ 求出即可.
- 时间复杂度 $O(n^2)$ .

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
inline int read()
{
	int out=0,fh=1;
	char jp=getchar();
	while ((jp>'9'||jp<'0')&&jp!='-')
		jp=getchar();
	if (jp=='-')
		fh=-1,jp=getchar();
	while (jp>='0'&&jp<='9')
		out=out*10+jp-'0',jp=getchar();
	return out*fh;
}
const int P=998244353;
inline int add(int a,int b)
{
	return (a + b) % P;
}
inline int mul(int a,int b)
{
	return 1LL * a * b % P;
}
void upd(int x,int &y)
{
	y=add(x,y);
}
const int MAXN=1e3+10;
int n,mx;
int C[MAXN][MAXN],sumc[MAXN][MAXN];
int f[MAXN][MAXN][4];
void init()
{
	for(int i=0;i<=n;++i)
		C[i][0]=1;
	for(int i=1;i<=n;++i)
		for(int j=1;j<=i;++j)
			C[i][j]=add(C[i-1][j],C[i-1][j-1]);
	for(int i=0;i<=n;++i)
	{
		sumc[i][0]=1;
		for(int j=1;j<=i;++j)
			sumc[i][j]=add(sumc[i][j-1],C[i][j]);
	}
	f[0][0][3]=1;
	for(int i=0;i<n;++i)
		for(int j=0;j<=mx;++j)
			for(int k=0;k<4;++k)
			{
				if(!f[i][j][k])
					continue;
				upd(f[i][j][k],f[i+1][j][k==3?k:k+1]);
				if(k==3)
					upd(f[i][j][k],f[i+1][j+1][0]);
			}
}
int lim[4];
int main()
{
	n=read();
	for(int i=0;i<4;++i)
		lim[i]=read();
	sort(lim,lim+4);
	mx=min(lim[0],n/4);//最多mx个位置讨论蔡徐坤 
	init();
	int ans=0,sgn=1;
	for(int i=0;i<=mx;++i)
	{
		int res=0,tmp=0;
		if(n<4)
			tmp=1;
		else
		{
			for(int k=0;k<4;++k)
				tmp=add(tmp,f[n-3][i][k]);
		}
		for(int k=0;k<4;++k)
			lim[k]-=i;
		int tot=n-i*4;
		for(int j=0;j<=tot;++j)
		{ 
			int lp=max(0,j-lim[1]);
			int rp=min(lim[0],j);
			int lk=max(0,tot-j-lim[3]);
			int rk=min(lim[2],tot-j);
			if(lp>rp || lk>rk)
				continue;
			int t1=lp?sumc[j][rp]-sumc[j][lp-1]:sumc[j][rp];
			int t2=lk?sumc[tot-j][rk]-sumc[tot-j][lk-1]:sumc[tot-j][rk];
			res=add(res,mul(C[tot][j],mul(t1,t2)));
		}
		res=mul(res,tmp);
		ans=add(ans,res*sgn);
		for(int k=0;k<4;++k)
			lim[k]+=i;
		sgn*=-1;
	}
	cout<<add(ans,P)<<endl;
	return 0;
}
```


---

## 作者：Weng_Weijie (赞：13)

**其他题解写的都是枚举算至少 $i$ 段的方案数，事实上算的并不是对应的方案数，因为这样可能会算重复。**

我来写一个比较正确的版本

令 $S$ 为一种方案（不一定合法），$w(S)$ 为 $S$ 中连续唱、跳、rap和篮球的**段数**

显然我们求的就是 $\displaystyle\sum_{S}[w(S)=0]$

由二项式定理：$[n=0]=(1-1)^n=\displaystyle\sum_{i=0}^n(-1)^i\binom ni$

由于右边有个组合数，为了方便，暂时不考虑 $i$ 的上界

故我们求的是 $\displaystyle\sum_{S}\sum_{i=0}^{\infty}(-1)^i\binom{w(S)}i$

交换求和顺序 $\displaystyle\sum_{i=0}^{\infty}(-1)^i\sum_{S}\binom{w(S)}i$

**所以，其他题解中算的至少 $i$ 段的方案数其实是每种方案所有连续段选 $i$ 段方案数的总和**

$\displaystyle\sum_{S}\binom {w(S)}i$ 可以通过先枚举这 $i$ 段的位置，然后计算有多少种方案满足在这些位置确实是连续段。

可以用指数型生成函数完成，也可以用其他的方法。

具体地，把连续段缩成一个元素

令 $F(x)=\dfrac{1}{i!}x^i, A(x)=\displaystyle\sum_{k=0}^{a-i}\dfrac{1}{k!}x^k, B(x), C(x), D(x)$ 同理

那么答案就是 $(n-3i)![x^{n-3i}]F(x)A(x)B(x)C(x)D(x)$

复杂度 $O(n^2\log n)$

---

## 作者：zimindaada (赞：9)

[P5339 \[TJOI2019\]唱、跳、rap和篮球](https://www.luogu.com.cn/problem/P5339)

~~题面好评。~~

我们先假设如果没有唱、跳、rap、篮球的人数限制会怎么样：那么我们可以很容易想到构造有$i$组人讨论[$\rm CXK$](https://www.baidu.com/s?ie=UTF-8&wd=%E8%94%A1%E5%BE%90%E5%9D%A4)，让剩下的人乱排。这样子虽然会出现重复，以及一些人在乱排的情况下组成了$\rm CXK$，但是很快想到可以利用~~小学的~~容斥思想，排除掉重复的情况，通过自己尝试手玩一下文氏图或者自己脑补，发现容斥系数为$(-1)^i $（$i$为**至少**有几组$\rm CXK$），这样就求出来了。

然后我们再把人数限制条件给加回来。由刚才的思路延伸下来，在有$i$组人讨论$\rm CXK$的时候，有$n-4i$个人没有在讨论。那么我们就可以用排列组合来表示分别有多少人选择了唱、跳、rap、篮球。

$$\sum_{a=0}^{n-4i}  C_{n-4i}^a \sum_{b=0}^{n-4i-a} C_{n-4i-a}^b \sum_{c=0}^{n-4i-a-b} C_{n-4i-a-b}^c$$

这个式子的意思就是依次枚举有多少人选择了唱、跳、rap、篮球，然后给每一种分配位置（由于题目意思说出了人都是一样的，所以不用再排列组合）。问题来了。这个式子，就算是用前缀和优化过，也是$O(n^2)$的，再加上枚举$i$，就是$O(n^3)$，尽管这道题有$\rm 4s$的时限，还是力不从心。

但是，我们可以用一个小技巧来解决这个问题，就是改写原式子。容易发现，原式子可以被改写成

$$\sum_{j=0}^{n-4i} C_{n-4i}^j \Bigg[\bigg(\sum_{k=a-i}^{j-(b-i)} C_{j}^k\bigg) \cdot \bigg(\sum_{l=c-i}^{n-j-(d-i)} C_{n-j}^l \bigg)\Bigg]$$

这个式子的意思就是先分出两组人，一组去唱、跳，一组rap、篮球，再依次分配这两组人。可以发现，$$和$$可以前缀和优化，所以这一个式子只需要枚举$j$，一共是$O(n^2)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int mod = 998244353;
const int maxn = 1017;
int n,a,b,c,d;
int C[maxn][maxn], pre[maxn][maxn];
inline void C_init(){
	for(int i = 0; i < maxn; ++i){
		C[i][0] = 1;
		for(int j = 1; j <= i; ++j){
			C[i][j] = (C[i-1][j-1] + C[i-1][j]) % mod;
			if(C[i][j] >= mod) C[i][j] -= mod;
		}
	}
	for(int i = 0; i < maxn; ++i){
		pre[i][0] = 1;
		for(int j = 1; j < maxn; ++j){
			pre[i][j] = (pre[i][j-1] + C[i][j]) % mod;
			if(pre[i][j] >= mod) pre[i][j] -= mod;
		}
	}
}
inline ll sum(int x, int l, int r){
	if(l > r) return 0;
	if(l <= 0) return pre[x][r];
	ll ret = (pre[x][r]-pre[x][l-1]) % mod;
	if(ret < 0) ret += mod;
	return ret;
}
ll now, ans;
int main(){
	scanf("%d%d%d%d%d",&n,&a,&b,&c,&d);
	C_init();
	for(int i = 0; i <= n && n-4*i >= 0 && a-i >= 0 && b-i >= 0 && c-i >= 0 && d-i >= 0; ++i){
		//printf("i : %d, n : %d, a : %d, b : %d, c : %d, d : %d\n", i, n-4*i, a-i, b-i, c-i, d-i);
		now = 0;
		for(int j = 0; j <= (n-4*i); ++j){
			now = (now + 1LL * C[(n-4*i)][j] * sum(j, j-(b-i), a-i) % mod * sum((n-4*i)-j, (n-4*i)-j-(c-i), (d-i)) % mod) % mod;
		}
		//printf("now1 : %lld   ", now);
		now = (now*C[n-3*i][i]) % mod;
		//printf("now2 : %lld   ", now);
		if(i & 1) ans = (ans - now + mod) % mod;
		else ans = (ans + now) % mod;
		//printf("ans : %lld\n", ans);
	}
	printf("%lld\n", ans);
	return 0;
} 
```

---

## 作者：ferrum_cccp (赞：5)

~~鸡你太美~~

[宣传博客](http://wycero4.coding.me/dest/post_solution_p5339.html)

容斥，枚举$k$表示至少$k$组讨论cxk的同学，它对答案的贡献为两部分相乘：

1. 在$n$个同学的序列中放置$k$组讨论cxk的同学，这个可以简单dp出来：$dp_{i,j}=dp_{i-1,j}+dp_{i-4,j-1}$

2. 不一定讨论cxk的同学如何排列，即从人数分别为$a-k,b-k,c-k,d-k$（以下记作$A,B,C,D$）的4组同学中选出总数为$n-4k$（以下记作$N$）的同学。

如果$A+B+C+D=N$，那么就是可重排列问题，答案为$\frac{N!}{A!B!C!D!}$。

如果$A+B+C+D>N$呢？那么我们就枚举$=N$的部分，答案为：

$\sum\limits_{i=0}^A\sum\limits_{j=0}^B\sum\limits_{k=0}^C\sum\limits_{l=0}^D[i+j+k+l=N]\frac{N!}{i!j!k!l!}$
$=N!\sum\limits_{i=0}^A\sum\limits_{j=0}^B\sum\limits_{k=0}^C\sum\limits_{l=0}^D[i+j+k+l=N]\frac 1{i!}\frac 1{j!}\frac 1{k!}\frac 1{l!}$

看到你了！卷积！

NTT

$O(n^2 log n)$
```cpp
#include<bits/stdc++.h>
#define rep(i,a,b) for(int i=(a);i<=(b);i++)
using namespace std;
typedef long long int ll;
const ll maxn=20005;
int n,a,b,c,d;const ll xrj=998244353;
ll dp[2005][2005];
ll wn[25],wn2[25];
ll ksm(ll d,ll z){
	ll ans=1;while(z){
		if(z&1)ans=ans*d%xrj;
		d=d*d%xrj;
		z>>=1;}
	return ans;}
ll r[maxn];
void ntt(ll *a,ll l,int on){
	//rep(i,0,(1<<l)-1)cout<<a[i]<<"v";;cout<<endl;
	rep(i,0,(1<<l)-1)r[i]=(r[i>>1]>>1)|((i&1)<<(l-1));
	rep(i,0,(1<<l)-1)if(i<r[i])swap(a[i],a[r[i]]);
	rep(i,0,l-1){
		int j=1<<i;
		ll x=on==-1?wn2[i+1]:wn[i+1];for(int k=0;k<1<<l;k+=j<<1){
			ll y=1;rep(m,0,j-1){
				ll p=a[k+m],q=y*a[k+j+m]%xrj;
				a[k+m]=(p+q)%xrj;
				a[k+j+m]=(p+xrj-q)%xrj;
				(y*=x)%=xrj;}}}
	if(on==-1){
		ll ny=ksm(1<<l,xrj-2);
		rep(i,0,(1<<l)-1)(a[i]*=ny)%=xrj;}
	/*rep(i,0,(1<<l)-1)cout<<a[i]<<"^";;cout<<endl;*/}
ll jc[maxn],jcny[maxn];
ll aa[maxn],bb[maxn],cc[maxn],dd[maxn];
ll work(int n,int a,int b,int c,int d){
	//cout<<"#"<<n<<" "<<a<<" "<<b<<" "<<c<<" "<<d<<endl;
	int l=0;while(1<<l<(a+b+c+d)<<1)++l;
#define haha(a,aa) rep(i,0,(1<<l)-1)aa[i]=i<=a?jcny[i]:0;
	haha(a,aa);haha(b,bb);haha(c,cc);haha(d,dd);
	ntt(aa,l,1);ntt(bb,l,1);ntt(cc,l,1);ntt(dd,l,1);
	rep(i,0,(1<<l)-1)aa[i]=aa[i]*bb[i]%xrj*cc[i]%xrj*dd[i]%xrj;
	ntt(aa,l,-1);
return aa[n]*jc[n]%xrj;}
int main(){
	cin>>n>>a>>b>>c>>d;
	rep(i,0,n)dp[i][0]=1;
	rep(i,1,n)rep(j,1,n)dp[i][j]=(dp[i-1][j]+((i>=4)?dp[i-4][j-1]:0))%xrj;
	//rep(i,1,n){rep(j,0,n)cout<<dp[i][j]<<" ";;cout<<endl;}
	rep(i,0,19)wn[i]=ksm(3,(xrj-1)>>i);
	rep(i,0,19)wn2[i]=ksm(wn[i],xrj-2);
	jc[0]=1;
	rep(i,1,4*n)jc[i]=jc[i-1]*i%xrj;
	jcny[4*n]=ksm(jc[4*n],xrj-2);
	for(int i=4*n-1;i>=0;i--)jcny[i]=jcny[i+1]*(i+1)%xrj;
	//rep(i,0,4*n)cout<<jc[i]<<" ";;cout<<endl;
	//rep(i,0,4*n)cout<<jcny[i]<<" ";;cout<<endl;
	int sgn=1;ll ans=0;
	int kk=min(n/4,min(a,min(b,min(c,d))));
	rep(k,0,kk){
		ll a1=work(n-4*k,a-k,b-k,c-k,d-k),a2=dp[n][k];
		//cout<<k<<"$"<<a1<<" "<<a2<<endl;
		(ans+=sgn*a1%xrj*a2%xrj)%=xrj;
		sgn=xrj-sgn;}
	cout<<ans<<endl;
	return 0;}

```

EDIT: 更正错误

---

## 作者：wjyyy (赞：5)

[**在我的博客查看**](https://www.wjyyy.top/3653.html)

## 题解

没学过生成函数，暴力容斥了。

感觉这种在序列上的组合问题会一下子想到容斥。

用 `c,t,r,l` 分别表示喜欢唱、跳、rap、篮球的同学。

首先，如果要用容斥解决的话，可以从序列中连续的 `c,t,r,l` 的个数入手。

首先需要计算当 $a,b,c,d$ 都无穷大，即每个位置都可以放 `c,t,r,l` 中任意一个同学时，长为 $n$ 的序列中有 $m$ 个连续的 `c,t,r,l` 的方案。

定义 $\mathrm{C}_n^m$ 为长为 $n$ 的序列里选 $m$ 个元素，且被选出的任意两个元素之间距离不小于 $4$，那么上面所提到的方案的计算式就是 $\mathrm{C}_{n-3}^m$。

而根据组合意义，$\mathrm{C}_n^m=\sum_{i=0}^{n-3}\mathrm{C}_{i}^{m-1}$。

![](https://www.wjyyy.top/wp-content/uploads/2019/06/201906151019.png)

而在本题中，$n\le 1000$，因此有效的 $\mathrm{C}_n^m$ 不超过 $1000^2$ 个，而且 $0\le m\le\lfloor\frac{n-1}4\rfloor+1$，所以常数也比较小。

递推时，只需要处理 $\mathrm{C}_i^m$ 关于 $i$ 的前缀和 $\mathrm{C}_0^m+\mathrm{C}_1^m+\cdots$，就可以做到 $O(n^2)$ 了。

有了所有的 $\mathrm{C}_n^m$ 之后，就可以开始容斥了。

当序列中有至少 $0$ 个连续的 `c,t,r,l` 时，所有位置上都可以任选。

这是一个可重组合数问题，但是由于只有四种元素，我们可以先确定四种喜好的同学分别有多少个。四种喜好的人数依次设为 $A,B,C,D(0\le A\le a,0\le B\le b,0\le C\le c,0\le D\le d)$，令 $k=\min\{a,b,c,d\}$。

那么接下来就是求合法的（$A+B+C+D=n$）四元组 $(A,B,C,D)$ 的个数了。

直接枚举是 $O(k^3)$ 的，而对于每个 $i(0\le i\le\lfloor\frac{n-1}4\rfloor)$ 都要做一遍，这是承受不了的。

我们可以通过枚举二元组 $(A,B)$ 来预处理有多少个二元组满足 $A+B=t$，再枚举 $(C,D)$，和 $(C,D)$ 能匹配上的 $(A,B)$ 的数量就是满足 $A+B=n-C-D$ 的二元组 $(A,B)$ 数量。

也就是说，如果用 $cnt_t$ 来表示有多少个二元组 $(A,B)$ 满足 $A+B=t$，那么对于二元组 $(C,D)$，能匹配上它的有 $cnt_{n-C-D}$ 种。

上面解释了一个 meet-in-middle 的思路，复杂度为 $O(k^2)$，小常数 $O(nk^2)$ 级别还是可以接受的。

这时，我们得到了合法的四元组 $(A,B,C,D)$ 的数目了，现在转化为可重排列问题，这个用阶乘算一下就可以了。

但是我们只知道数目，不知道具体的 $(A,B,C,D)$。可重排列数中，分子上是 $n!$，而分母上是 $A!B!C!D!$。根据不同的 $(A,B,C,D)$，这个数不尽相同。

我们可以在上面算贡献的时候，对于二元组 $(A,B)$，对 $cnt_{A+B}$ 的贡献就是 $\frac{1}{A!B!}$；而当 $(C,D)$ 找回去的时候，就用 $\frac1{C!D!}$ 去乘 $cnt_{n-C-D}$。

这样就有了“至少 $0$ 个”，也就是任意位置上都随便放的方案数。

至少 $1$ 个的方案数，就是把上面“至少 $0$ 个”方案数中的 $n$ 换成 $n-4$，然后乘上上面所定义的 $\C_n^1$。

依此类推，直到至少 $k$ 个会把 `c,t,r,l` 中最少的一个用完，或者至少 $\frac n4$ 个。连续的 `c,t,r,l` 填满了所有位置。

答案就是至少 $0$ 个 $-$ 至少 $1$ 个 $+$ 至少 $2$ 个 $+\cdots+(-1)^{\min(k,\frac n4)}\times$ 至少 $\min(k,\frac n4)$ 个。

时间复杂度 $O(nk^2)$，常数在 $\frac 14$ 左右。

## trick：

从这题可以看出来组合数的一种推法。当间隔不大于 $1$ 时，也就是原意义下的组合数，$\mathrm{C}_n^m=\sum_{i=0}^{n-1}\mathrm{C}_i^{m-1}$。

## Code：

```cpp
#include<cstdio>
#include<cstring>
#define p 998244353
#define ll long long
int Min(int x,int y){return x<y?x:y;}
ll qpow(ll x,ll y)
{
    ll ans=1;
    while(y)
    {
        if(y&1)
            ans=ans*x%p;
        x=x*x%p;
        y>>=1;
    }
    return ans;
}
int f[1010][300];
ll sum[300],func[1010],inv[1010];
int cnt[1010];
int main()
{
    int n;
    scanf("%d",&n);
    func[0]=1;
    f[0][0]=1;
    for(int i=1;i<=n;++i)
    {
        func[i]=func[i-1]*i%p;
        f[i][0]=1;
        for(int j=1;j<=i/4;++j)
        {
            sum[j-1]=(sum[j-1]+f[i-4][j-1])%p;
            f[i][j]=sum[j-1];
        }
    }
    inv[n]=qpow(func[n],p-2);
    for(int i=n-1;i>=0;--i)
        inv[i]=inv[i+1]*(i+1)%p;
    int a,b,c,d;
    scanf("%d%d%d%d",&a,&b,&c,&d);
    int mn=a<b?(a<c?(a<d?a:d):(c<d?c:d)):(b<c?(b<d?b:d):(c<d?c:d)),ans=0;
    //int mn=Min(Min(a,b),Min(c,d)),ans=0;
    for(int i=0,tot=n;i<=mn&&i<=n/4;++i,--a,--b,--c,--d,tot-=4)
    {
        memset(cnt,0,sizeof(cnt));
        long long op=0;
        for(int A=0;A<=a;++A)
            for(int B=0;B<=b;++B)
                cnt[A+B]=(cnt[A+B]+inv[A]*inv[B])%p;
        for(int C=0;C<=c;++C)
            for(int D=0;D<=d&&C+D<=tot;++D)
                op=(op+cnt[tot-C-D]*inv[C]%p*inv[D])%p;
        op=op*func[tot]%p;
        if(i&1)
            ans=(ans+p-op*f[n][i]%p)%p;
        else
            ans=(ans+op*f[n][i]%p)%p;
    }
    printf("%d\n",ans);
    return 0;
}
```


---

## 作者：佐世保の时雨 (赞：3)

~~题意就不用讲了吧……~~

~~鸡你太美！！！~~

#### 题意：
有4种喜好不同的人，分别最爱唱、跳、 rap、篮球，他们个数分别为 A,B,C,D ，现从他们中挑选出n个人并进行排列，规定不能出现喜爱唱、跳、 rap、篮球的人在序列中依次出现，问合法方案数。

下文将喜爱唱、跳、 rap、篮球的人依次出现的区间称为聚集区间，长度为4。

#### 思路（容斥原理 + 生成函数 + $NTT$）
首先，我们可以发现如果顺着求方案数并不好求。秉持顺难逆易的原则，我们可以考虑容斥，令 $f(k)$ 表示在长度为n的序列中出现了至少k个聚集区间的方案数，进而我们得出：$Answer=\displaystyle\sum_{k}(-1)^{k}f(k)$。

接下来，我们的目标就是求出 $f(k)$。我们可以设这k个聚集区间的起始位置 i，并把 i,i+1,i+2,i+3 缩为一个点，这样就一共剩下n-3k个点，接着，我们就可以从这n-3k个点中选取不在聚集区间内的点，这样的点一共有n-4k个，所以方案数为 $\binom{n-3k}{n-4k}=\binom{n-3k}{k}$。

我们设 $S(a,b,c,d,n)$ 表示 $4$ 种人的数量分别有a,b,c,d个，从中挑选出 $n$ 个人并进行排列的方案数。所以，$f(k)=\binom{n-3k}{k}S(A-k,B-k,C-k,D-k,n-4k)$

随后，我们把注意力放在 $S(a,b,c,d,n)$ 上，可以发现这与指数型生成函数 $EGF$ 的应用场景非常类似。所以，我们可以写出每种人的生成函数，例如第一种人的生成函数为 $\displaystyle\sum_{k}^{a}\dfrac{x^k}{k!}$。接着，我们将这四种人的生成函数进行卷积，而其中的第 $n$ 项的系数就是答案，即 $[x^{n}]\displaystyle\sum_{k}^{a}\dfrac{x^k}{k!}\displaystyle\sum_{k}^{b}\dfrac{x^k}{k!}\displaystyle\sum_{k}^{c}\dfrac{x^k}{k!}\displaystyle\sum_{k}^{d}\dfrac{x^k}{k!}$

综上，$Answer=\displaystyle\sum_{k}(-1)^{k}f(k)=\displaystyle\sum_{k}(-1)^{k}\binom{n-3k}{k}S(A-k,B-k,C-k,D-k,n-4k)$

#### 时间复杂度
如果卷积时使用 $NTT$，时间复杂度约为 $n^2\log_2n$。但由于数据不强，时限宽松，暴力进行卷积也可通过，时间复杂度约为 $n^3$。

听说还有使用其它方法 AC 的 $n\sqrt{n}$ 的算法，~~蒟蒻不会~~太强了%%%

#### 代码实现：

```cpp
#include <map>
#include <cmath>
#include <ctime>
#include <queue>
#include <cstdio>
#include <vector>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

#define LL long long
#define Int register int
#define Lc(x) Child[x][0]
#define Rc(x) Child[x][1]
#define Swap(a, b) a ^= b ^= a ^= b
#define Abs(x) ((x) < 0 ? -(x) : (x))
#define Max(x, y) ((x) < (y) ? (y) : (x))
#define Min(x, y) ((x) < (y) ? (x) : (y))
#define Isdigit(ch) (ch >= '0' and ch <= '9')

const int MAXN = 1e3 + 10;
const double Pi = acos (-1.0);
const LL Mod = 998244353, G = 3, Inv2 = 499122177, INF = 1LL << 60;

inline LL Read () {
	LL f = 0, x = 0;
	char ch = getchar ();
	
	while (!isdigit (ch) ) {
		f |= (ch == '-'), ch = getchar ();
	}
	
	while (isdigit (ch) ) {
		x = (x << 1) + (x << 3) + (ch ^ 48), ch = getchar ();
	}
	
	return f ? -x : x;
}

inline void Write (const LL &x) {
	if (x < 0 ) {
		putchar ('-'), Write (-x);
		return ;
	}
	
	if (x > 9 ) {
		Write (x / 10);
	}
	
	putchar ((x % 10) ^ 48);
	return ;
}

LL Answer;
int n, a, b, c, d;
LL Fact[MAXN], Inv[MAXN], Pow[MAXN], Sum1[MAXN], Sum2[MAXN];

inline LL Qkpow (LL Base, LL x) {
	LL Total = 1;
	
	while (x ) {
		if (x & 1 ) {
			Total = Total * Base % Mod;
		}
		
		Base = Base * Base % Mod, x >>= 1;
	}
	
	return Total;
}

inline LL Getinv (const LL x) {
	return Qkpow (x, Mod - 2);
}

inline LL Getbinom (const int n, const int m) {
	return Fact[n] * Inv[m] % Mod * Inv[n - m] % Mod;
}

inline LL Clac (const int a, const int b, const int c, const int d, const int n) {
	Int i, j;
	
	for (i = 0; i <= n; ++ i ) {
		Sum1[i] = Sum2[i] = 0;
	}
	
	Sum1[0] = 1;
	
	for (i = 0; i <= n; ++ i ) {
		for (j = 0; j <= a and i + j <= n; ++ j ) {
			Sum2[i + j] = (Sum2[i + j] + Sum1[i] * Inv[i] % Mod * Fact[i + j] % Mod * Inv[j] % Mod) % Mod;
		}
	}
	
	for (i = 0; i <= n; ++ i ) {
		Sum1[i] = Sum2[i], Sum2[i] = 0;
//		printf ("%lld ", Sum1[i]);
	}
	
//	putchar ('\n');
	
	for (i = 0; i <= n; ++ i ) {
		for (j = 0; j <= b and i + j <= n; ++ j ) {
			Sum2[i + j] = (Sum2[i + j] + Sum1[i] * Inv[i] % Mod * Fact[i + j] % Mod * Inv[j] % Mod) % Mod;
		}
	}
	
	for (i = 0; i <= n; ++ i ) {
		Sum1[i] = Sum2[i], Sum2[i] = 0;
//		printf ("%lld ", Sum1[i]);
	}
	
//	putchar ('\n');
	
	for (i = 0; i <= n; ++ i ) {
		for (j = 0; j <= c and i + j <= n; ++ j ) {
			Sum2[i + j] = (Sum2[i + j] + Sum1[i] * Inv[i] % Mod * Fact[i + j] % Mod * Inv[j] % Mod) % Mod;
		}
	}
	
	for (i = 0; i <= n; ++ i ) {
		Sum1[i] = Sum2[i], Sum2[i] = 0;
//		printf ("%lld ", Sum1[i]);
	}
	
//	putchar ('\n');
	
	for (i = 0; i <= n; ++ i ) {
		for (j = 0; j <= d and i + j <= n; ++ j ) {
			Sum2[i + j] = (Sum2[i + j] + Sum1[i] * Inv[i] % Mod * Fact[i + j] % Mod * Inv[j] % Mod) % Mod;
		}
	}
	
	for (i = 0; i <= n; ++ i ) {
		Sum1[i] = Sum2[i], Sum2[i] = 0;
//		printf ("%lld ", Sum1[i]);
	}
	
//	putchar ('\n');
	
	return Sum1[n];
}

signed main () {
	n = Read (), a = Read (), b = Read (), c = Read (), d = Read ();
	Int i;
	
	for (i = Pow[0] = Fact[0] = 1; i <= n; ++ i ) {
		Fact[i] = Fact[i - 1] * i % Mod, Pow[i] = Pow[i - 1] * 4 % Mod;
	}
	
	Inv[n] = Getinv (Fact[n]);
	
	for (i = n - 1; ~i; -- i ) {
		Inv[i] = Inv[i + 1] * (i + 1) % Mod;
	}
	
	if (a == b and b == c and c == d ) {
		for (i = 0; i <= n / 4; ++ i ) {
			Answer = (Answer + (i & 1 ? -1 : 1) * Pow[n - 4 * i] * Getbinom (n - 3 * i, i) % Mod + Mod) % Mod;;
		}
		
		Write (Answer);
		return 0;
	}
	
	for (i = 0; i <= n / 4 and i <= a and i <= b and i <= c and i <= d; ++ i ) {
//		printf ("---------i = %d---------\n", i);
		Answer = (Answer + (i & 1 ? -1 : 1) * Clac (a - i, b - i, c - i, d - i, n - 4 * i) * Getbinom (n - 3 * i, i) % Mod + Mod) % Mod;;
//		Write (Answer), putchar ('\n');
	}
	
	Write (Answer);
	
	return 0;
}
```

---

## 作者：zyc2003 (赞：3)

[题目链接](https://www.luogu.com.cn/problem/P5339)

[可能更好的阅读体验](https://www.luogu.com.cn/blog/zyc2003/tjoi2019-d1t3-chang-tiao-rap-lan-qiu-ti-xie-post)

### 题解简述

对于 $20$ 分和 $100$ 分的做法进行了讲解 , 不需要多项式知识 . 该做法的复杂度是 $\mathcal O(\dfrac{n^3}{12})$  . 

### 前置知识

不需要 : NTT

不需要 : 生成函数

需要 : 二项式定理基础

### 部分分拿法

$20$ 分难道就不是分了 ? 省选临近 , 部分分才是王道 ! 

下面我们用 $a_1,a_2,a_3,a_4$ 分别代表喜欢唱 , 喜欢跳 , 喜欢rap , 喜欢篮球的学生 , 用 $num_1,num_2,num_3,num_4$ 代表对他们的人数限制 . 

我们发现 , 对于部分分 : $n=num_1=num_2=num_3=num_4\leq 500$ , 也就是说 , 实际上每一类学生的放置没有**数量上的限制** . 那么 , 如果考虑放置 $n$ 个学生的总方案数 , 且不考虑是否**合法** , 就有 $4^n$ 种方案 . 

 题目要求不能存在 $a_1,a_2,a_3,a_4$ 连在一起的情况出现 . 正难则反 , 我们只要求出所有**不合法**的方案总数 , 然后用 $4^n$ 减去它即可 . 

所以 , 设 $f_i$ 表示已经决定了前 $i$ 个位置上的学生 , 有 $f_i$ 种方案是**不合法**的 . 首先初始状态 $f_1=f_2=f_3=0$ . 考虑 $3<i\leq n$ , 不合法情况分两种 , 第一种是 $i-3,i-2,i-1,i$ 这四个位置上恰好是 $a_1,a_2,a_3,a_4$ , 前面是否合法无所谓 ; 第二种就是 $i-3,i-2,i-1,i$ 是合法的 , 但是前面存在一些位置不合法 . 

第一种情况的总数是 $4^{i-4}$ , 意味着 $1\sim i-4$ 个位置可以随便选择 , 但是 $i-3,i-2,i-1,i$ 这四个位置要放上 $a_1,a_2,a_3,a_4$ ; 所以是 $4^{i-4}*1$ 种情况 ; 第二种情况 , 就是 $4*f_{i-1}-f_{i-4}$ . 这个式子意味着第 $i$ 个位置随便放上 $4$ 种学生的任意一种 , 有 $4*f_{i-1}$ 种情况 , 而后再扣除 $i-3,i-2,i-1,i$ 为不合法的情况 , 即 $-f_{i-4}$ . 所以有 : 

$$f_i=4^{i-4}+4*f_{i-1}-f_{i-4}\ \ (3<i\leq n)$$

最后答案为 $4^n-f_n$ , 可以拿到 20pts 的好成绩 . 

```cpp
typedef long long LL;
typedef unsigned int ui;

inline LL read() {
	LL x=0,f=1;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}
	while(isdigit(ch))x=x*10+(ch^48),ch=getchar();
	return x*f;
}
inline char char_read() {
	char ch=getchar();
	while(!isalpha(ch))ch=getchar();
	return ch;
}
inline void write(LL x) {
	if(x<0)putchar('-'),x=-x;
	if(x>9)write(x/10);
	putchar(x%10+48);
}
inline void writes(LL x) {write(x),putchar(' ');}
inline void Writes(LL x) {write(x),putchar('\n');}

#define N 1010
#define P 998244353

int n,ans;
int num[5];
int f[N];
int Qpow(int x,int p) {int ans=1;for(;p;p>>=1,x=1ll*x*x%P)if(p&1)ans=1ll*ans*x%P;return ans;} 

int main() {
	n=read();
	for(int i=1;i<=4;++i)	
		num[i]=read();
	for(int i=4;i<=n;++i) 
		f[i]=(1ll*Qpow(4,i-4)+4ll*f[i-1]%P-1ll*f[i-4])%P;
	Writes((((1ll*Qpow(4,n)-1ll*f[n])%P)+P)%P);
	return 0;
}
```

### 满分做法

现在我们的每种学生的人数有了限制 , 那该怎么做呢 ? 

首先考虑所有方案的总数 . 我们可以考虑先放第 $4$ 种学生 , 再放第 $3$ 种 , 再放第 $2$ 种 , 最后剩下的放第 $1$ 种学生 . 这样可以自然地想到动规式子 : $f_{i,k}$ 表示当前局面剩下 $i$ 个人 , 放好了**前** $k$ 种学生的总方案数 . 那么 : 

$$f_{i,k}=\sum_{j=0}^{\min(num_k,i)}C_{i}^{j}*f_{i-j,k-1} \  \ (1<k\leq 4)$$

这个式子表示 , 我在 $i$ 个位置中选择 $j$ 个位置放置第 $k$ 种学生 , 剩下的 $i-j$ 个位置放置前 $k-1$ 种学生 . 

下面考虑边界条件 . 

当 $k=1$ 时 , $f_{i,1}=[i \leq num_1]$ . 如果 $i > num_1$ , 那么学生人数不足 , 根本放不上去 . 

当 $i=0$ 时 , $f_{0,k}=1$ . 

推荐使用**记忆化搜索** , 比较方便实现 . 注意 , 这样的复杂度是 $\mathcal O(n^2)$ . 

and then ? 我们还是考虑找出所有不合法的方案 . 不过这一次有了限制 , 不能那么显然地 dp 了 ; 那么 , 设 :

$$\mathrm{mmin}=\min(n/4,num_1,num_2,num_3,num_4)$$

考虑 $n$ 个位置上有 $1,2,\dots,\mathrm{mmin}$ 个不合法的连续段 $a_1,a_2,a_3,a_4$ . 对于有 $k$ 个不合法段的情况 , 我们运用高中学过的**整体法**(没学过不要紧) , 实际上就是在 $n-3k$ 个位置中 , 选出 $k$ 个位置进行拓展成 $a_1,a_2,a_3,a_4$ 的方案数 , 也就是 $C_{n-3k}^{k}$ . 那么剩下的位置有 $n-4k$ 个 , 随意放置的方案数就是 $f_{n-4k,4}$ . 不过注意 , 每种颜色的限制应该变为 $num_i-k,i=1,2,3,4$ . 

那么 , 求出来的 $C_{n-3k}^k*f_{n-4k,4}$ 代表了什么呢 ? 代表着局面上**至少**有 $k$ 个不连续段的方案数 , 但是该方案数对一些情况**算重了** . 具体地说 , 局面上有 $k$ 个不连续段的方案数被计算了 $C_k^k$ 次 , 有 $k+1$ 个不连续段的方案数被计算了 $C_{k+1}^k$ 次 , ... , 有 $\rm mmin$ 个不连续段的方案数被计算了 $C_{\mathrm{mmin}}^k$ 次 ; 那这怎么办呢 ? 

这个时候 , 就需要我们的**容斥大法**了 ! 有一个需要知道的结论 : 

$$\sum_{i=1}^m (-1)^{i-1}*C_{m}^{i}=1$$

证明也不难 (虽然我一时间没想出来 , 还是机房的大佬 JasonL 告诉我的) . 考虑二项式展开 : 

$$\begin{aligned}
(1-1)^m &= \sum_{i=0}^m(-1)^i*C_{m}^i
\\
0&= 1+\sum_{i=1}^m(-1)^i*C_{m}^i
\\
1&= \sum_{i=1}^m(-1)^{i-1}*C_{m}^i
\end{aligned}$$

就得到了证明 . 这个容斥应当熟知 . 

设 $g_k=C_{n-3k}^k*f_{n-4k,4}$ . 那么 , 我们最终**不合法的方案总数**为 : 

$$\sum_{k=1}^{\mathrm{mmin}}(-1)^{k-1}g_k$$

比如 , 有 $3$ 个不连续段的情况 , 在 $g_1$ 中被算了 $C_3^1$ 次 , 在 $g_2$ 中被算了 $C_3^2$ 次 , 在 $g_3$ 中被算了 $C_3^3$ 次 . 而根据容斥 , $C_3^1-C_3^2+C_3^3=1$ , 最终只被算了一次 . 

那么 , 最终的答案是 : 

$$f_{n,4}-\sum_{k=1}^{\mathrm{mmin}}(-1)^{k-1}g_k$$

简单化简得 : 

$$\sum_{k=0}^{\mathrm{mmin}}(-1)^{k}g_k$$

求出来 ! 就是最终答案 .

...等等 , 时间复杂度呢 ? 每次计算 $f_{n-4k,4}$ 的复杂度为 $\mathcal O(n^2)$ , 那么总复杂度为 $\mathcal O(n^3)$ 的 , 怎么通过本题呢 ? 实际验证 , 四个数字全为 $1000$ 的情况 , 在 $500\sim 1000$ 毫秒内可以轻松跑过 . 

经分析 , 时间复杂度为 $\mathcal O(\frac{n^3}{\omega}) , \omega=12$ , 所以最坏情况下为 $\dfrac{1000^3}{12}\approx 8.3\times 10^7$ , 是能跑得过的 !

### 时间复杂度分析

考虑计算 $f_{n,k}$ , 对于 $k=4$ , 我们只用计算 $f_{n,4}$ 这一个值 , 而不用计算 $n-1,n-2,\dots$ ; 对于 $k=1$ , 这是边界条件 ; 那么只用考虑 $k=2,3$ , $f_{n,3}=f_{n-1,2}+f_{n-2,2}+\dots+f_{0,2}$ , 所以计算次数为 $2*(n+n-1+\dots+1)\approx n^2$ . 

那么 , 总计算次数约为 $n^2+(n-4*1)^2+(n-4*2)^2+\dots+0^2$ , 也就是 : 

$$\begin{aligned}
\sum_{k=0}^{\frac{n}{4}}(n-4k)^2 &=\sum_{k=0}^{\frac{n}{4}}\big ((4k)^2\big )\\
&=16\sum_{k=0}^{\frac{n}{4}} k^2 \\
&\approx 16\times \frac16 \times \frac{n}{4} \times \frac{n}{4}  \times \frac{n}{2}\\
&=\frac{n^3}{12}
\end{aligned}$$

所以 , 本算法对于 $1000$ 规模的数据还是没问题的 , 但是再大一些 , 就完全不行了 QAQ ...那样的话 NTT 或者其他的 $\mathcal O(n^2)$ 做法值得选择 .

```cpp
typedef long long LL;
typedef unsigned int ui;

inline LL read() {
	LL x=0,f=1;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}
	while(isdigit(ch))x=x*10+(ch^48),ch=getchar();
	return x*f;
}
inline char char_read() {
	char ch=getchar();
	while(!isalpha(ch))ch=getchar();
	return ch;
}
inline void write(LL x) {
	if(x<0)putchar('-'),x=-x;
	if(x>9)write(x/10);
	putchar(x%10+48);
}
inline void writes(LL x) {write(x),putchar(' ');}
inline void Writes(LL x) {write(x),putchar('\n');}

#define N 1010
#define P 998244353

int n,ans;
int num[5];
int f[N][N];
int vis[N][N],cnt; 
int C[N][N];

int dp(int x,int col) {
	if(x < 0) return 0;
	if(vis[x][col] == cnt)	
		return f[x][col];
	vis[x][col]=cnt,f[x][col]=0;
	if(x == 0) 
		f[x][col]=1;
	else if(col == 1) 
		f[x][col] = (x > num[col] ? 0 : 1);
	else {
		for(int i=0;i<=min(num[col],x);++i) 
			f[x][col]=(1ll*f[x][col]+1ll*C[x][i]*dp(x-i,col-1)%P)%P;
	}
	return f[x][col];
}
void treat() {
	for(int i=0;i<=n;++i)
		C[i][0]=1;
	for(int i=1;i<=n;++i)
		for(int j=1;j<=i;++j)
			C[i][j]=(1ll*C[i-1][j-1]+1ll*C[i-1][j])%P;
}
int fac(int x) {
	return (x&1) ? -1 : 1;//容斥系数 
}

int main() {
	n=read();
	for(int i=1;i<=4;++i)	
		num[i]=read();
	treat();
	int mmin=n/4;
	for(int i=1;i<=4;++i)	
		mmin=min(mmin,num[i]);
	for(int i=0;i<=mmin;++i) {
		cnt++;
		ans=((1ll*ans+1ll*fac(i)*C[n-3*i][i]*dp(n-4*i,4)%P)%P+P)%P;
		for(int j=1;j<=4;++j)
			num[j]--;
	}
	Writes(ans);
	return 0;
}

```



---

## 作者：_ctz (赞：3)

[$blog$](https://ctz45562.github.io/2019/12/06/%E6%B4%9B%E8%B0%B7-P5339-TJOI2019-%E5%94%B1%E3%80%81%E8%B7%B3%E3%80%81rap%E5%92%8C%E7%AF%AE%E7%90%83/)

[传送门](https://www.luogu.com.cn/problem/P5339)

好像没有朴素的$O(n^3)$容斥+$DP$的题解诶。。。

题意一脸套路容斥。枚举有$i$个不合法组，容斥系数$(-1)^i$，$C_{n-3i}^i$选位置，剩下了$a-i$、$b-i$、$c-i$、$d-i$个人和$n-4i$个位置，要给他们任意安排位置。

直接组合数学不太会做的样子，咱也不会$NTT$和生成函数，考虑$DP$。

设$f(i,j)$为前$i$种爱好放了$j$个人的方案数。

枚举每种爱好有多少人，插进当前的队伍里：$f(i,j)=\sum\limits_{k=0}^{a/b/c/d}f(i-1,j-k)\times C_j^{j-k}$

套路容斥：$ans=\sum\limits_{i=0}^{\min\{\frac{n}{4},a,b,c,d\}}(-1)^iC_{n-3i}^if(4,n-4i)$。注意每个$i$的$a,b,c,d$都不一样，需要重新$DP$。

复杂度$O(n^3)$，然而实际上常数极小甚至（应该）到不了$\dfrac{1}{10}$。

代码：
``` cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <cstring>

#define maxn 1005
#define inf 0x3f3f3f3f

const int mod = 998244353;

using namespace std;

inline int read(){
	int x=0,y=0;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')y=1;ch=getchar();}
	while(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
	return y?-x:x;
}
int f[maxn],c[maxn][maxn],a[5];
inline int calc(int n){
	memset(f,0,sizeof f);
	f[0]=1;
	for(register int i=1,sum=0;i<=4;++i){
		sum=min(sum+a[i],n);
		for(register int j=sum;j;--j)
			for(register int k=min(j,a[i]);k;--k)
				(f[j]+=1ll*f[j-k]*c[j][j-k]%mod)%=mod;
		--a[i];
	}
	return f[n];
}
inline long long pow1(int x){return x&1?-1ll:1ll;}
int main(){
	int n=read(),mi=n>>2,ans=0;
	for(register int i=1;i<=4;++i)mi=min(a[i]=read(),mi);
	c[0][0]=1;
	for(register int i=1;i<=n;++i){
		c[i][0]=1;
		for(register int j=1;j<=i;++j)c[i][j]=(c[i-1][j-1]+c[i-1][j])%mod;
	}
	for(register int i=0;i<=mi;++i)(ans+=pow1(i)*c[n-i*3][i]*calc(n-(i<<2))%mod)%=mod;
	printf("%d\n",(ans+mod)%mod);
}
```


---

## 作者：x义x (赞：2)

~~第一次鸦片战争养了我，让我怎么去做人！鸡你太美！！~~

本题解默认您有一定的[生成函数](https://www.luogu.com.cn/blog/zyxxs/x-yi-x-jiang-tan-sheng-cheng-han-shuo-ru-men)基础。

设 $f_i$ 是队伍里恰好有 $i$ 组人讨论 cxk 的队伍数，题目要求我们求 $f_0$。

众所周知“恰好”这种词非常烦，于是我们改求 $g_i=\sum_{j}\begin{pmatrix}j\\i\end{pmatrix}f_j$。

这个 $g_i$ 是什么意思呢？我们枚举 $i$ 组讨论 cxk 的人，剩下的人是否讨论 cxk 我们直接不管，这样对于每一个有 $j$ 组人讨论 cxk 的队伍方案就会被统计 $\begin{pmatrix}j\\i\end{pmatrix}$ 次。

二项式反演可以得到如何用 $g$ 求出 $f$：$f_i=\sum_{j}(-1)^{j-i}\begin{pmatrix}j\\i\end{pmatrix}g_j$。

下面思考如何统计 $g_k$。

$$g_k=\text{选定这} k\text{组人的位置的方案数}*\text{给剩下}N-4k\text{个人分配属性的方案数}$$

先看后一个部分。为了方便，这里把 $N-4k$ 记成 $N$，$a-k$ 记成 $a$，其他类似。把剩下的 $N$ 个人排成一排，每个人赋予 4 种属性的一个，求方案数，不难发现这是一个多重集排列问题，众所周知多重集排列问题与 EGF（指数生成函数）有关，于是答案就是

$$[x^N]\left(\sum_{i=0}^a\dfrac{x^i}{i!}\right)\left(\sum_{i=0}^b\dfrac{x^i}{i!}\right)\left(\sum_{i=0}^c\dfrac{x^i}{i!}\right)\left(\sum_{i=0}^d\dfrac{x^i}{i!}\right)$$

没有什么高明的计算方法，要用 NTT 卷积。

回头看前一个部分。其实它等价于在 $N-3k$ 个元素中选 $k$ 个“展开”成 4 个元素，即 $\begin{pmatrix}N-3k\\k\end{pmatrix}$。

没有这么妙的想法也没关系，设答案是 $h_{N,k}$，我们枚举第一个组的位置为 $\{i,i+1,i+2,i+3\}$，于是

$$h_{N,k}=\sum_{i=1}^{N-3}h_{N-i-3,k-1}$$

$$h_{N,k}=\sum_{i=0}^{N-4}h_{i,k-1}$$

边界条件：

$$h_{N,1}=\begin{cases}0&(N=0,1,2,3)\\N-3&(N\ge 4)\end{cases}$$

设 $h_{N,k}$ 的 OGF（普通生成函数）为 $H_k(x)$，容易知道

$$H_1(x)=(\dfrac 1{1-x})'\cdot x^4=\dfrac{x^4}{(1-x)^2}$$

$$H_k(x)=\dfrac{x^4}{1-x}\cdot H_{k-1}(x)$$

于是

$$H_k(x)=\dfrac{x^{4k}}{(1-x)^{k+1}}$$

展开后可以得到同样的结论。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;

const int p=998244353,maxN=1<<11,g=3,ig=332748118;
int W[maxN],iW[maxN];
int qpow(int a,int k){
	int ans=1;
	while(k){
		if(k&1) ans=1LL*ans*a%p;
		a=1LL*a*a%p;
		k>>=1;
	}
	return ans;
}

int R[maxN];
void NTT(int d[],int n0,bool flg){
	int x=1,len=0;while(x<n0) x<<=1,len++;
	for(int i=0;i<x;i++){
		R[i]=(R[i>>1]>>1)|((i&1)<<(len-1));
		if(i<R[i]) swap(d[i],d[R[i]]);
	}
	for(int i=1,l=maxN/(i<<1);i<x;i<<=1,l>>=1)
	for(int j=0;j<x;j+=(i<<1))
	for(int k=0;k<i;k++){
		int a0=d[j+k],a1=1LL*(flg?iW[l*k]:W[l*k])*d[j+i+k]%p;
		d[j+k]=(a0+a1)%p;d[j+i+k]=(a0-a1+p)%p;
	}
	if(flg){
		int invx=qpow(x,p-2);
		for(int i=0;i<x;i++) d[i]=1LL*d[i]*invx%p;
	}
}

int N,A,B,C,D;
int EA[maxN],EB[maxN],EC[maxN],ED[maxN];

int inv[maxN],fac[maxN],ifac[maxN];

int main(){
	int w=qpow(g,(p-1)/maxN),iw=qpow(ig,(p-1)/maxN);
	W[0]=iW[0]=1; 
	for(int i=1;i<maxN;i++)
		W[i]=1LL*W[i-1]*w%p,
		iW[i]=1LL*iW[i-1]*iw%p;
	inv[1]=1;fac[0]=fac[1]=ifac[0]=ifac[1]=1;
	for(int i=2;i<maxN;i++)
		inv[i]=1LL*inv[p%i]*(p-p/i)%p,
		fac[i]=1LL*fac[i-1]*i%p,
		ifac[i]=1LL*ifac[i-1]*inv[i]%p;
	
	int ANS=0;
	scanf("%d%d%d%d%d",&N,&A,&B,&C,&D);
	for(int i=0;i<=N/4&&i<=A&&i<=B&&i<=C&&i<=D;i++){
		int n=N-4*i,a=A-i,b=B-i,c=C-i,d=D-i,L=a+b+c+d;
		for(int j=0;j<=a;j++) EA[j]=ifac[j];
		for(int j=a+1;j<maxN;j++) EA[j]=0;
		for(int j=0;j<=b;j++) EB[j]=ifac[j];
		for(int j=b+1;j<maxN;j++) EB[j]=0;
		for(int j=0;j<=c;j++) EC[j]=ifac[j];
		for(int j=c+1;j<maxN;j++) EC[j]=0;
		for(int j=0;j<=d;j++) ED[j]=ifac[j];
		for(int j=d+1;j<maxN;j++) ED[j]=0;
		NTT(EA,L+1,0);NTT(EB,L+1,0);NTT(EC,L+1,0);NTT(ED,L+1,0);
		for(int j=0;j<maxN;j++) EA[j]=1LL*EA[j]*EB[j]%p*EC[j]%p*ED[j]%p;
		NTT(EA,L+1,1);
		int Gi=1LL*EA[n]*fac[n]%p*fac[N-3*i]%p*ifac[i]%p*ifac[N-4*i]%p;
		if(i&1) ANS=(ANS-Gi+p)%p;
		else ANS=(ANS+Gi)%p;
	}
	printf("%d\n",ANS);
}
```

---

## 作者：caidzh (赞：2)

~~鸡你太美~~

设$f(x)$为钦定$x$组鸡你太美的方案数，$g(x)$为恰好存在$x$组鸡你太美的方案数，容易得到：

$$f(x)=\sum_{i=x}\dbinom{i}{x}g(i)$$

二项式反演后得到：

$$g(x)=\sum_{i=x}(-1)^{i-x}\dbinom{i}{x}f(i)$$

我们最后求的就是$g(0)$，接下来我们考虑求$f(x)$

注意到各个鸡你太美并不重叠，所以只钦定$x$组鸡你太美的方案数可以这样计算：将每个鸡你太美组缩成一个人，这样还剩下$n-3x$个人，再在其中选择$x$个，即：$\dbinom{n-3x}{x}$

后面的计算是一个可重集排列数，可以使用$\text{EGF}$构造+$\text{NTT}$卷积完成，如果我们设有$x$组鸡你太美时可重集排列数为$A_x$，你们都想看的最终答案是：

$$g(x)=\sum_{i=x}(-1)^{i-x}\dbinom{i}{x}A_x\dbinom{n-3x}{x}$$

$A_x$的计算是$nlogn$的，因此这样做最终复杂度是$n^2logn$，可以通过这个题
```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<queue>
#define db double
#define INF 2147483647
#define LLINF 9223372036854775807
#define LL long long
using namespace std;
int inline read(){
    int num=0,neg=1;char c=getchar();
    while(!isdigit(c)){if(c=='-')neg=-1;c=getchar();}
    while(isdigit(c)){num=(num<<3)+(num<<1)+c-'0';c=getchar();}
    return num*neg;
}
const int maxn=10010,mod=998244353,G=3;
int invG,n,a,b,c,d,ans,R[maxn],len,x;
int ksm(int x,int y){
	int ans=1;while(y){if(y&1)ans=1ll*ans*x%mod;x=1ll*x*x%mod;y>>=1;}return ans;
}
void NTT(int *A,int flag){
    for(int i=0;i<x;i++)if(i<R[i])swap(A[i],A[R[i]]);
    for(int mid=1;mid<x;mid<<=1){
        int g;if(flag)g=ksm(G,(mod-1)/(mid<<1));
        else g=ksm(invG,(mod-1)/(mid<<1));
        for(int j=0;j<x;j+=(mid<<1)){
            int sum=1;
            for(int k=0;k<mid;k++){
                int A1=A[j+k],A2=1ll*sum*A[j+k+mid]%mod;
                A[j+k]=(A1+A2)%mod;A[j+k+mid]=((A1-A2)%mod+mod)%mod;sum=1ll*sum*g%mod;
            }
        }
    }
    if(!flag){
        int X=ksm(x,mod-2);
        for(int i=0;i<x;i++)A[i]=1ll*A[i]*X%mod;
    }
}
void polymul(int *a,int *b,int n,int m){
    x=1;len=0;while(n+m>=x)x<<=1,len++;
    for(int i=0;i<x;i++)R[i]=(R[i>>1]>>1)|((i&1)<<len-1);
    NTT(a,1);NTT(b,1);for(int i=0;i<=x;i++)a[i]=1ll*a[i]*b[i]%mod;NTT(a,0);
}
int fac[maxn],inv[maxn],facinv[maxn];
int A[maxn],B[maxn],C[maxn],D[maxn],num[maxn];
int calc(int x,int y){
	return 1ll*fac[x]*facinv[y]%mod*facinv[x-y]%mod;
}
int solve(int a,int b,int c,int d,int x){
	memset(A,0,sizeof(A));memset(B,0,sizeof(B));
	memset(C,0,sizeof(C));memset(D,0,sizeof(D));
	for(int i=0;i<=a;i++)A[i]=num[i];
	for(int i=0;i<=b;i++)B[i]=num[i];
	for(int i=0;i<=c;i++)C[i]=num[i];
	for(int i=0;i<=d;i++)D[i]=num[i];
	polymul(A,B,a,b);polymul(A,C,a+b,c);polymul(A,D,a+b+c,d);
	return 1ll*A[n-4*x]*fac[n-4*x]%mod*calc(n-3*x,x)%mod;
}
int main()
{
	n=read();a=read();b=read();c=read();d=read();invG=ksm(G,mod-2);
	fac[1]=fac[0]=inv[1]=facinv[1]=facinv[0]=1;
	for(int i=2;i<=n;i++){
		fac[i]=1ll*fac[i-1]*i%mod;
		inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;
		facinv[i]=1ll*facinv[i-1]*inv[i]%mod;
	}for(int i=0;i<=n;i++)num[i]=facinv[i];int tot=0;
	while(a>=0&&b>=0&&c>=0&&d>=0){
		int sum=solve(a,b,c,d,tot);
		if(tot&1)ans=(ans-sum+mod)%mod;else ans=(ans+sum)%mod;
		a--;b--;c--;d--;++tot;
	}printf("%d",ans);return 0;
}
```


---

## 作者：GKxx (赞：2)

老年退役选手来写题解了

### 题意

有$a$个人喜欢唱，$b$个人喜欢跳，$c$个人喜欢rap，$d$个人喜欢篮球，现在要从中选出$n$个人排成一队，使得不存在位置$k$满足第$k$，$k+1$，$k+2$，$k+3$个人依次喜欢唱、跳、rap、篮球，求方案数。

两种方案不同，当且仅当有一个位置上的同学的喜好不同。

### 题解

为了方便，我们将连续的唱跳rap篮球四个人称为“ikun段”。

现在要计算没有ikun段的方案数并不方便，可以考虑容斥，那么答案显然是

$$ans=\sum\limits_{i=0}^{\min\{a,b,c,d,\lfloor\frac{n}{4}\rfloor\}}(-1)^if(i)$$

其中$f(i)$表示指定$i$处ikun段，其它地方任意排列的方案数。

要指定$i$处ikun段，注意到它们不能相交，设第$j$处ikun段的开头位置为$a_j$，显然有

$$a_j+3<a_{j+1}$$

$$1\leq a_1,a_i+3\leq n$$

简单整理一下可以得到

$$1\leq a_1<a_2-3<a_3-6<\cdots<a_j-3(j-1)\leq n-3i$$

因此方案数就是$C_{n-3i}^i$。

指定了$i$处出现ikun段之后，剩下$n-4i$个位置任意排列，也就是从$a-i$个唱、$b-i$个跳、$c-i$个rap、$d-i$个篮球中选出$n-4i$个来排列。这个问题是经典的指数型生成函数问题，答案就是$h(x)$的项$x^{n-4i}$的系数乘上$(n-4i)!$，其中

$$h(x)=\left(\sum\limits_{j=0}^{a-i}\frac{x^j}{j!}\right)\left(\sum\limits_{j=0}^{b-i}\frac{x^j}{j!}\right)\left(\sum\limits_{j=0}^{c-i}\frac{x^j}{j!}\right)\left(\sum\limits_{j=0}^{d-i}\frac{x^j}{j!}\right)$$

NTT求卷积即可。

总结一下，我们要求的东西就是

$$ans=\sum\limits_{i=0}^{\min\{a,b,c,d,\lfloor\frac{n}{4}\rfloor\}}(-1)^iC_{n-3i}^i(n-4i)![x^{n-4i}]h(x)$$

组合数的分母也含有$(n-4i)!$，可以约去，但这其实无所谓。

枚举$i$，求卷积$O(n\log n)$，总复杂度$O(n^2\log n)$

~~我怀疑这题暴力求卷积+卡常优化可以比NTT快~~

```cpp
#include <cctype>
#include <cstdio>
#include <climits>
#include <algorithm>

template <typename T> inline void read(T &x) {
    int f = 0, c = getchar(); x = 0;
    while (!isdigit(c)) f |= c == '-', c = getchar();
    while (isdigit(c)) x = x * 10 + c - 48, c = getchar();
    if (f) x = -x;
}
template <typename T, typename... Args>
inline void read(T &x, Args&... args) {
    read(x); read(args...);
}
template <typename T> void write(T x) {
    if (x < 0) x = -x, putchar('-');
    if (x > 9) write(x / 10);
    putchar(x % 10 + 48);
}
template <typename T> inline void writeln(T x) { write(x); puts(""); }
template <typename T> inline bool chkmin(T &x, const T &y) { return y < x ? x = y, 1 : 0; }
template <typename T> inline bool chkmax(T &x, const T &y) { return x < y ? x = y, 1 : 0; }

typedef long long LL;

const int maxn = 1e3 + 7;
const LL P = 998244353, G = 3, Gi = 332748118;

inline LL qpow(LL x, LL k) {
    LL s = 1;
    for (; k; x = x * x % P, k >>= 1)
        if (k & 1) s = s * x % P;
    return s;
}

inline void ntt(LL *A, int *r, int lim, int tp) {
    for (int i = 0; i < lim; ++i)
        if (i < r[i]) std::swap(A[i], A[r[i]]);
    for (int mid = 1; mid < lim; mid <<= 1) {
        LL wn = qpow(tp == 1 ? G : Gi, (P - 1) / (mid << 1));
        for (int j = 0; j < lim; j += mid << 1) {
            LL w = 1;
            for (int k = 0; k < mid; ++k, w = w * wn % P) {
                LL x = A[j + k], y = w * A[j + k + mid] % P;
                A[j + k] = (x + y) % P;
                A[j + k + mid] = (x - y + P) % P;
            }
        }
    }
    if (tp == -1) {
        LL inv = qpow(lim, P - 2);
        for (int i = 0; i < lim; ++i)
            A[i] = A[i] * inv % P;
    }
}

int a, b, c, d, n, mn, mx;
LL fac[maxn], ifac[maxn];
LL ha[maxn << 3], hb[maxn << 3], hc[maxn << 3], hd[maxn << 3];
int r[maxn << 3];

inline LL g(int i) {
    std::copy(ifac, ifac + a - i + 1, ha);
    std::copy(ifac, ifac + b - i + 1, hb);
    std::copy(ifac, ifac + c - i + 1, hc);
    std::copy(ifac, ifac + d - i + 1, hd);
    int lim = 1, l = 0;
    while (lim <= a + b + c + d - 4 * i) lim <<= 1, ++l;
    for (int j = 0; j < lim; ++j)
        r[j] = (r[j >> 1] >> 1) | ((j & 1) << (l - 1));
    ntt(ha, r, lim, 1);
    ntt(hb, r, lim, 1);
    ntt(hc, r, lim, 1);
    ntt(hd, r, lim, 1);
    for (int j = 0; j < lim; ++j)
        ha[j] = ha[j] * hb[j] % P * hc[j] % P * hd[j] % P;
    ntt(ha, r, lim, -1);
    LL ret = ha[n - 4 * i];
    std::fill(ha, ha + lim, 0);
    std::fill(hb, hb + lim, 0);
    std::fill(hc, hc + lim, 0);
    std::fill(hd, hd + lim, 0);
    return ret;
}

int main() {
    read(n, a, b, c, d);
    mn = std::min({a, b, c, d, n / 4});
    mx = std::max({a, b, c, d, n});
    fac[0] = ifac[0] = 1;
    for (int i = 1; i <= mx; ++i)
        fac[i] = fac[i - 1] * i % P;
    ifac[mx] = qpow(fac[mx], P - 2);
    for (int i = mx - 1; i; --i)
        ifac[i] = ifac[i + 1] * (i + 1) % P;
    LL ans = 0;
    for (int i = 0; i <= mn; ++i) {
        LL sgn = i & 1 ? P - 1 : 1;
        LL res = sgn * fac[n - 3 * i] % P * ifac[i] % P * g(i) % P;
        ans = (ans + res) % P;
    }
    writeln((ans % P + P) % P);
    return 0;
}
```

---

## 作者：ThomasX (赞：2)

**搬运官方题解。**

------------

由于这是一个多重集的排列问题，在不考虑非法排列的情况下，我们可以利用指数生成函数来解决。

现在考虑如何从结果中去掉非法的排列：

这里我们考虑容斥，我们可以把最喜欢唱的人当作$a$，最喜欢跳的人当作$b$，最喜欢rap的人当作$c$，最喜欢篮球的人当作$d$，这个题就变成了，用给定数量的$a,b,c,d$来填充一个给定长度的序列，要求序列中不得出现子串$abcd$.

我们可以先计算不考虑序列中有子串$abcd$的结果，假设这个结果是$f_0$，然后我们可以依次计算序列中有至少$1$个字串$abcd$，至少$2$个子串$abcd$，……一直到有至少 $k(k = n/4)$ 个子串$abcd$的结果，并分别假设它们为 $f_1,f_2,\cdots,f_k$ 。

由于$f_0$中含有非法的序列，所以我们应该减去含有至少一个子串$abcd$的数量$f_1$，但因为对于每一个含有至少两个子串的$abcd$的排列，我们在$f_1$中计算了两遍，所以还应该加上$f_2$，这样我们就形成了一个容斥，最终的结果就是 $f_0 - f_1 + \cdots + (-1)^k \times f_k$ 。

由于$a,b,c,d$的数量在题目中是给定的，因此我们不能直接推出公式，只能直接通过生成函数相乘，这样的复杂度是$O(n^{2k})$，$k$为容斥的次数， 由于计算的过程是多项式相乘，我们可以使用FFT加速，不过本题的数据范围并没有要求完成这 一步。

题目中有20%的数据是 $n = a = b = c = d$ 的，这部分数据我们可以把它看作是$a,b,c,d$均有无限多个的情况，这种情况下我们很容易用指数生成函数推出公式进行容斥，复杂度可以降到$O(k)$，$k$为容斥的次数。

------------

std
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<ctime>
#include<cstring>
using namespace std;
const int mod = 998244353;

int a[4],l;
int total[1005],mid[1005],fac[1005],inv[1005];

inline int dp(int used)
{
	memset(total,0,sizeof(total));
	memset(mid,0,sizeof(mid));
	for (int i = 0; i <= a[0] - used; i++)
	{
		total[i] = 1;
	}
	for (int i = 1; i < 4; i++)
	{
		for (int j = 1; j <= a[i] - used; j++)
		{
			for (int k = 0; k + j <= l - used * 4; k++)
			{
				mid[k + j] += 1ll*total[k] * inv[k] % mod * inv[j] % mod;
				mid[k + j] %= mod;
			}
		}
		for (int j = 0; j <= l - used * 4; j++)
		{
			total[j] += 1ll * mid[j] * fac[j] % mod;
			total[j] %= mod;
			mid[j] = 0;
		}
	}
	return total[l - used * 4];
}

inline long long power(long long a, long long b)
{
	long long c = 1;
	while (b)
	{
		if (b % 2)
		{
			c *= a;
			c %= mod;
		}
		b /= 2;
		a *= a;
		a %= mod;
	}
	return c;
}

int main()
{
	clock_t st,et;
	freopen("queue.in", "r", stdin);
	freopen("queue.out", "w", stdout);
	//st = clock();
	fac[0] = inv[0] = fac[1] = inv[1] = 1;
	for (int i = 2; i <= 1000; i++)
	{
		fac[i] = 1ll*fac[i - 1] * i % mod;
		inv[i] = power(fac[i],mod - 2);
	}
	//et = clock();
	//printf("%f s\n",(double)(et - st) / CLOCKS_PER_SEC);
	int now,mini;
	long long answer;
	while (~scanf("%d%d%d%d%d",&l,&a[0],&a[1],&a[2],&a[3]))
	{
		//st = clock();
		mini = min(a[0],min(a[1],min(a[2],a[3])));
		answer = dp(0);
		now = -1;
		for (int i = 1; i * 4 <= l && i <= mini; i++)
		{
			answer += 1ll*dp(i) * fac[l - i * 3] % mod * inv[l - i * 4] % mod * inv[i] % mod * now;
			answer = (answer % mod + mod) % mod;
			now *= -1;
		}
		printf("%lld\n",answer);
		//et = clock();
		//printf("                  %f s\n",(double)(et - st) / CLOCKS_PER_SEC);
	}
	return 0;
}

```


---

## 作者：Owen_codeisking (赞：2)

发一个被 $O(n^2\log n)$ 吊打的 $O(n^3)$

~~常数这么小干嘛用NTT呢~~

### 前置知识：容斥原理

~~Fading跟我说容斥我才会知道这题是容斥的，不过我也证明了一遍容斥原理~~

首先从一个错解开始。

设 $f(i)$ 为至少有 $i$ 段唱跳 $rap$ 篮球的枚举方案数。

$$ans=f(0)-f(1)$$

很荣幸你 $WA$ 了……

因为一个合法的序列若**恰好有 $i$ 段唱跳 $rap$ 篮球**，那么一个方案会被计算 $\sum_{j=0}^{i}(-1)^j{i\choose j}$ 次，这个式子**当且仅当 $i=0$** 时为 $1$，其他时候均为 $0$。

那么恭喜你证明了一遍容斥原理！

$$ans=\sum_{i=0}^{\min(n/4,a,b,c,d)}(-1)^if(i)$$

那么现在只用计算 $f(i)$ 了。

我们把唱跳 $rap$ 篮球**视为一个元素**，那么就会有 $n-3\times i$ 个元素。

我们把问题转换成一个多重排列的方案数。

现在有 $m$ 个不同的元素，每个 $i$ 元素有 $a_i$ 个，那么方案数为

$$(\sum_{i=1}^{m}a_i)!\times \prod_{i=1}^{m}\frac {1}{a_i!}$$

那么我们只要枚举唱跳 $rap$ 篮球放几个就行了。

当然枚举不能 $O(n^4)$ 枚举，你可以 $NTT$ 三次，不过怎么开心怎么玩嘛。

因为恰好 $i$ 段排列怎么排都只会被算一次，所以答案要**除以 $i!$**

$Code\ Below:$

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int maxn=2000+10;
const int mod=998244353;
int n,a,b,c,d;ll fac[maxn],inv[maxn],f[maxn];

int main()
{
	scanf("%d%d%d%d%d",&n,&a,&b,&c,&d);
	fac[0]=fac[1]=inv[0]=inv[1]=1;
	for(ll i=2;i<=n;i++) fac[i]=fac[i-1]*i%mod;
	for(ll i=2;i<=n;i++) inv[i]=(mod-mod/i)*inv[mod%i]%mod;
	for(ll i=2;i<=n;i++) inv[i]=inv[i]*inv[i-1]%mod;
	int lim=min(n/4,min(min(a,b),min(c,d)));ll res,ans=0;
	for(int x=0;x<=lim;x++)
	{
		for(int i=0;i<=n;i++) f[i]=0;
		for(int i=0;i<=a-x;i++)
			for(int j=0;j<=min(n-4*x-i,b-x);j++) (f[i+j]+=inv[i]*inv[j])%=mod;
		res=0;
		for(int i=0;i<=c-x;i++)
			for(int j=0;j<=min(n-4*x-i,d-x);j++) (res+=inv[i]*inv[j]%mod*f[n-4*x-i-j])%=mod;
		(res*=fac[n-3*x]*inv[x]%mod)%=mod;(ans+=(x&1)?mod-res:res)%=mod;
	}
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：tzc_wk (赞：1)

~~cxk hopping~~

我们考虑先钦定 $i$ 个位置放上“鸡你太美”，其它随便填，设其方案数为 $f(i)$。

但这个 $f(i)$ 显然不是恰好有 $i$ 个“鸡你太美”的排列数——甚至不是至少 $i$ 个“鸡你太美”的排列数。

我们再设 $g(i)$ 为恰好 $i$ 个“鸡你太美”的排列数。

我们考虑 $g(j)$ 会对 $f(i)$ 产生多少的贡献的贡献，显然对于这 $g(j)$ 个不同的排列，从 $j$ 个“鸡你太美”中任意钦定 $i$ 个都会对 $f(i)$ 产生 $1$ 的贡献，故 $f(i)=\sum\limits_{j=i}g(j)\times\dbinom{j}{i}$

~~又到了喜闻乐见的二项式反演的时间了~~

这个并不是常见的二项式反演的形式，但它也可以进行二项式反演，反演一下即可得到 $g(i)=\sum\limits_{j=i}(-1)^{j-i}\dbinom{j}{i}f(j)$

最后我们要求的答案为 $g(0)$，即 $\sum\limits_{j=0}(-1)^jf(j)$

接下来我们的任务就是求出 $f(i)$，考虑现在 $n$ 个位置上放好 $i$ 个“鸡你太美”的方案数，如果我们把每个”鸡你太美“看作一个人的话，那么相当于在 $n-3i$ 个位置上选择 $i$ 个位置留给”鸡你太美“，方案数为 $\dbinom{n-3i}{i}$。最后考虑填好其他人的方案数。那我们相当于是在 $n-4i$ 个位置上选择不超过 $a-i$ 个”唱“，不超过 $b-i$ 个“跳”，不超过 $c-i$ 个”rap“，不超过 $d-i$ 个”篮球“并排成一列的方案数。

看到”排成一列“当然想到 EGF 咯。设 $F1(x)=\sum\limits_{i=0}^{a-i}\dfrac{x^i}{i!},F2(x)=\sum\limits_{i=0}^{b-i}\dfrac{x^i}{i!},F3(x)=\sum\limits_{i=0}^{c-i}\dfrac{x^i}{i!},F4(x)=\sum\limits_{i=0}^{d-i}\dfrac{x^i}{i!}$，那么显然最终答案的 EGF 为 $F1\times F2\times F3\times F4$，多项式卷积合并即可，别忘了最终乘上 $(n-4i)!$，时间复杂度 $n^2\log n$，常熟较大，跑得比较慢。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define fi first
#define se second
#define fz(i,a,b) for(int i=a;i<=b;i++)
#define fd(i,a,b) for(int i=a;i>=b;i--)
#define ffe(it,v) for(__typeof(v.begin()) it=v.begin();it!=v.end();it++)
#define fill0(a) memset(a,0,sizeof(a))
#define fill1(a) memset(a,-1,sizeof(a))
#define fillbig(a) memset(a,63,sizeof(a))
#define pb push_back
#define ppb pop_back
#define mp make_pair
template<typename T1,typename T2> void chkmin(T1 &x,T2 y){if(x>y) x=y;}
template<typename T1,typename T2> void chkmax(T1 &x,T2 y){if(x<y) x=y;}
typedef pair<int,int> pii;
typedef long long ll;
template<typename T> void read(T &x){
	x=0;char c=getchar();T neg=1;
	while(!isdigit(c)){if(c=='-') neg=-1;c=getchar();}
	while(isdigit(c)) x=x*10+c-'0',c=getchar();
	x*=neg;
}
const int pr=3;
const int MOD=998244353;
const int MAXP=1<<11;
int qpow(int x,int e){
	int ret=1;
	for(;e;e>>=1,x=1ll*x*x%MOD) if(e&1) ret=1ll*ret*x%MOD;
	return ret;
}
int n,a,b,c,d,fac[MAXP+5],ifac[MAXP+5];
int A[MAXP+5],B[MAXP+5],C[MAXP+5],D[MAXP+5];
int LEN=1,LOG=0,rev[MAXP+5],prs[MAXP+5][2],inv[MAXP+5],ipr;
void NTT(int *a,int len,int type){
	int lg=log2(len);
	for(int i=0;i<len;i++) rev[i]=(rev[i>>1]>>1)|((i&1)<<(lg-1));
	for(int i=0;i<len;i++) if(i<rev[i]) swap(a[i],a[rev[i]]);
	for(int i=2;i<=len;i<<=1){
		int W=prs[i][type<0];
		for(int j=0;j<len;j+=i){
			int w=1;
			for(int k=0;k<(i>>1);k++,w=1ll*w*W%MOD){
				int X=a[j+k],Y=1ll*a[(i>>1)+j+k]*w%MOD;
				a[j+k]=(X+Y)%MOD;a[(i>>1)+j+k]=(X-Y+MOD)%MOD;
			}
		}
	}
	if(type==-1) for(int i=0;i<len;i++) a[i]=1ll*a[i]*inv[len]%MOD;
}
int binom(int x,int y){return 1ll*fac[x]*ifac[y]%MOD*ifac[x-y]%MOD;}
int solve(int n,int x1,int x2,int x3,int x4){
	for(int i=0;i<=x1;i++) A[i]=ifac[i];
	for(int i=0;i<=x2;i++) B[i]=ifac[i];
	for(int i=0;i<=x3;i++) C[i]=ifac[i];
	for(int i=0;i<=x4;i++) D[i]=ifac[i];
	NTT(A,LEN,1);NTT(B,LEN,1);NTT(C,LEN,1);NTT(D,LEN,1);
	for(int i=0;i<LEN;i++) A[i]=1ll*A[i]*B[i]%MOD*C[i]%MOD*D[i]%MOD;
	NTT(A,LEN,-1);int ans=1ll*A[n]*fac[n]%MOD;
	for(int i=0;i<LEN;i++) A[i]=B[i]=C[i]=D[i]=0;
	return ans;
}
int main(){
	scanf("%d%d%d%d%d",&n,&a,&b,&c,&d);ipr=qpow(pr,MOD-2);
	while(LEN<=(a+b+c+d)) LEN<<=1,LOG++;
	for(int i=1;i<=LEN;i<<=1){
		inv[i]=qpow(i,MOD-2);
		prs[i][0]=qpow(pr,(MOD-1)/i);
		prs[i][1]=qpow(ipr,(MOD-1)/i);
	}
	fac[0]=1;for(int i=1;i<LEN;i++) fac[i]=1ll*fac[i-1]*i%MOD;
	ifac[LEN-1]=qpow(fac[LEN-1],MOD-2);for(int i=LEN-2;~i;i--) ifac[i]=1ll*ifac[i+1]*(i+1)%MOD;
	int ans=0;
	for(int i=0;i<=min(n/4,min(min(a,b),min(c,d)));i++){
		if(!(i&1)) ans=(ans+1ll*binom(n-3*i,i)*solve(n-4*i,a-i,b-i,c-i,d-i)%MOD)%MOD;
		else ans=(ans-1ll*binom(n-3*i,i)*solve(n-4*i,a-i,b-i,c-i,d-i)%MOD+MOD)%MOD;
	} printf("%d\n",ans);
	return 0;
}
```

注意到本题的卷积比较特殊。考虑从大到小倒着枚举 $j$，那么每次相当于是在 $F1(x),F2(x),F3(x),F4(x)$ 后面各添上一项。记 $G1(x)=F1(x)F2(x),G2(x)=F3(x)F4(x)$，那么我们每次都可以在 $\mathcal O(n)$ 的时间内更新 $G1(x),G2(x)$。并且最终我们要求的只是 $G1(x)G2(x)$ 中 $x^{n-3i}$ 项前面的系数，并不用把整个卷积都求出来，所以我们可以再次 $\mathcal O(n)$ 扫一遍求得。时间复杂度降到了 $\mathcal O(n^2)$。

似乎这么随随便便一写就抢到了除了 EI 之外的最优解？EI 给出了一个 $n^{1.5}$ 的神仙解法。storz EI yyds %%%%。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define fi first
#define se second
#define fz(i,a,b) for(int i=a;i<=b;i++)
#define fd(i,a,b) for(int i=a;i>=b;i--)
#define ffe(it,v) for(__typeof(v.begin()) it=v.begin();it!=v.end();it++)
#define fill0(a) memset(a,0,sizeof(a))
#define fill1(a) memset(a,-1,sizeof(a))
#define fillbig(a) memset(a,63,sizeof(a))
#define pb push_back
#define ppb pop_back
#define mp make_pair
template<typename T1,typename T2> void chkmin(T1 &x,T2 y){if(x>y) x=y;}
template<typename T1,typename T2> void chkmax(T1 &x,T2 y){if(x<y) x=y;}
typedef pair<int,int> pii;
typedef long long ll;
template<typename T> void read(T &x){
	x=0;char c=getchar();T neg=1;
	while(!isdigit(c)){if(c=='-') neg=-1;c=getchar();}
	while(isdigit(c)) x=x*10+c-'0',c=getchar();
	x*=neg;
}
const int MOD=998244353;
const int MAXP=1e3;
int qpow(int x,int e){
	int ret=1;
	for(;e;e>>=1,x=1ll*x*x%MOD) if(e&1) ret=1ll*ret*x%MOD;
	return ret;
}
int n,a,b,c,d,t1[MAXP+5],t2[MAXP+5];
int fac[MAXP+5],ifac[MAXP+5],ans=0;
int binom(int x,int y){return 1ll*fac[x]*ifac[y]%MOD*ifac[x-y]%MOD;}
int main(){
	scanf("%d%d%d%d%d",&n,&a,&b,&c,&d);int mn=min(n/4,min(min(a,b),min(c,d)));
	fac[0]=1;for(int i=1;i<=MAXP;i++) fac[i]=1ll*fac[i-1]*i%MOD;
	ifac[MAXP]=qpow(fac[MAXP],MOD-2);for(int i=MAXP-1;~i;i--) ifac[i]=1ll*ifac[i+1]*(i+1)%MOD;
	a-=mn;b-=mn;c-=mn;d-=mn;
	for(int i=0;i<=a;i++) for(int j=0;j<=b;j++) t1[i+j]=(t1[i+j]+1ll*ifac[i]*ifac[j]%MOD)%MOD;
	for(int i=0;i<=c;i++) for(int j=0;j<=d;j++) t2[i+j]=(t2[i+j]+1ll*ifac[i]*ifac[j]%MOD)%MOD;
	int sum=0;for(int i=0;i<=n-4*mn;i++) sum=(sum+1ll*t1[i]*t2[n-4*mn-i]%MOD)%MOD;
	sum=1ll*sum*fac[n-4*mn]%MOD;sum=1ll*sum*binom(n-3*mn,mn)%MOD;//printf("%d\n",sum);
	if(!(mn&1)) ans=sum;else ans=(MOD-sum)%MOD;
	for(int t=mn-1;~t;t--){
		a++;b++;c++;d++;
		for(int i=0;i<b;i++) t1[i+a]=(t1[i+a]+1ll*ifac[i]*ifac[a]%MOD)%MOD;
		for(int i=0;i<a;i++) t1[i+b]=(t1[i+b]+1ll*ifac[i]*ifac[b]%MOD)%MOD;
		t1[a+b]=(t1[a+b]+1ll*ifac[a]*ifac[b]%MOD)%MOD;
		for(int i=0;i<d;i++) t2[i+c]=(t2[i+c]+1ll*ifac[i]*ifac[c]%MOD)%MOD;
		for(int i=0;i<c;i++) t2[i+d]=(t2[i+d]+1ll*ifac[i]*ifac[d]%MOD)%MOD;
		t2[c+d]=(t2[c+d]+1ll*ifac[c]*ifac[d]%MOD)%MOD;
		sum=0;for(int i=0;i<=n-4*t;i++) sum=(sum+1ll*t1[i]*t2[n-4*t-i]%MOD)%MOD;
		sum=1ll*sum*fac[n-4*t]%MOD;sum=1ll*sum*binom(n-3*t,t)%MOD;//printf("%d\n",sum);
		if(!(t&1)) ans=(ans+sum)%MOD;else ans=(ans-sum+MOD)%MOD;
	} printf("%d\n",ans);
	return 0;
}
```

---


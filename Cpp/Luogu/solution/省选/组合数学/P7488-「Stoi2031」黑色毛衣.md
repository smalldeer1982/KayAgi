# 「Stoi2031」黑色毛衣

## 题目背景

> 看着那白色的蜻蜓 在空中忘了前进 还能不能 重新编织 脑海中起毛球的记忆 再说我爱你 可能雨也不会停 黑色毛衣 藏在哪里 就让回忆永远停在那里 ——《黑色毛衣》

## 题目描述

让想起了和雨在一起的时候。由于雨是一个爱玩的女孩子，所以他们有很多玩具，其中就有一种像 **白色蜻蜓** 一样的玩具，现在留在了让的身边，共有 $n$ 只。每只 **白色蜻蜓** 的翅膀长度分别是 $1,2,\dots,n$，并且可以张开成 $(0,\pi)$ 之间的任意角度。让认为使其中 $m$ 只 **白色蜻蜓** 分别张开翅膀使双翅末端的距离都为整数且互不相同的场景是在 **编织** 一份 **记忆**。他认为两份 **记忆** 相同当且仅当可以将 $m$ 只 **白色蜻蜓** 按某种方式重排后一一对应使对应的蜻蜓翅膀长度和双翅距离都相等。他想请你告诉他能编织出多少份不同的记忆。你只需要求出答案 $ans\bmod{p}$ 的值。

## 说明/提示

#### 简述版题意

求不同的腰长 $1 \le a \le n$，底长 $1 \le b \le 2a-1$ 且都为整数，腰长互不相同，底长也互不相同的 $m$ 个等腰三角形构成的不同组数。两组相同当且仅当可以使 $m$ 个三角形按某种方式重排后一一对应全等。

#### 样例解释：

限于篇幅，只对样例 $3$ 作解释。

可以 **编织** 出 $1,1,1$，$2,2,1$，$2,2,2$，$2,2,3$，$3,3,1$，$3,3,2$，$3,3,3$，$3,3,4$，$3,3,5$ 共 $9$ 种 **记忆**，取模 $7$ 后为 $2$。

**本题采用捆绑测试，每个 Subtask 的分数与限制如下。**

| Subtask No. | $m \le n \le$ | 特殊限制 | 分值 |
| :-----------: | :-----------: | :-----------: | :-----------: |
| $1$ | $10^3$ | 无 | $13$ |
| $2$ | $10^6$ | 无 | $37$ |
| $3$ | $10^{18}$ | 无 | $37$ |
| $4$ | $10^{18}$ | $p$是质数 | $13$ |

对于所有数据， $1 \le m \le n \le 10^{18},1 \le p \le 10^5$，不保证 $p$ 是质数。

## 样例 #1

### 输入

```
32 2 47
```

### 输出

```
36
```

## 样例 #2

### 输入

```
233 223 1926817
```

### 输出

```
620162
```

## 样例 #3

### 输入

```
3 1 7```

### 输出

```
2```

# 题解

## 作者：VinstaG173 (赞：5)

~~找规律~~结论题。答案为 $Q_n^m=C_n^m \times A_n^m$。直接推几项，大力猜结论。可以用数学归纳法证明如下：

设 $\forall i \le n,j \le i,Q_i^j=C_i^j \times A_i^j,$

分第 $i+1$ 只白色蜻蜓是否在 $j$ 只当中讨论（其实就是考虑 dp）得

$$\begin{aligned}
Q_{i+1}^j&=Q_i^j+Q_i^{j-1} \times (2i-j+2)\\
&=C_i^jA_i^j+(2i-j+2)C_i^{j-1}A_i^{j-1}\\
&=\frac{(i!)^2}{j![(i-j)!]^2}+\frac{(i!)^2(2i-j+2)}{(j-1)![(i-j+1)!]^2}\\
&=\frac{(i!)^2[(i-j+1)^2+(2i-j+2)j]}{j![(i-j+1)!]^2}\\
&=\frac{[(i+1)!]^2}{j![(i+1-j)!]^2}\\
&=C_{i+1}^jA_{i+1}^j.
\end{aligned}$$

$p$ 不一定是质数，直接上 exLucas。注意 $m \ge p$ 时答案是 $p$ 的倍数，所以事实上只用做 $n,m$ 很小的情况。

时间复杂度 $O(p\log{p})$。

Code:
```cpp
#include<map>
#include<list>
#include<cmath>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#define LL long long
using namespace std;
LL n,m,p,ans;
inline LL exgcd(LL a,LL b,LL &x,LL &y)
{
	if(!b)
	{
		x=1;y=0;
		return a;
	}
	LL r=exgcd(b,a%b,y,x);
	y-=(a/b)*x;
	return r;
}
inline LL mul(LL a,LL b,LL n)
{
	return a*b%n;
}
inline LL qpw(LL n,LL k,LL m)
{
	LL res=1;
	while(k)
	{
		if(k&1)res=mul(res,n,m);
		n=mul(n,n,m);
		k>>=1;
	}
	return res;
}
inline LL fac(LL n,LL pi,LL pk)
{
	if(!n)return 1;
	LL res=1;
	for(LL i=2;i<=pk;++i)
	{
		if(i%pi)res=mul(res,i,pk);
	}
	res=qpw(res,n/pk,pk);
	for(LL i=2;i<=n%pk;++i)
	{
		if(i%pi)res=mul(res,i,pk);
	}
	return mul(res,fac(n/pi,pi,pk),pk);
}
inline LL inv(LL n,LL m)
{
	LL x,y;
	exgcd(n,m,x,y);
	return (x+m)%m;
}
inline LL crt(LL b,LL m)
{
	return mul(mul(b,inv(p/m,m),p),p/m,p);
}
inline LL C(LL n,LL m,LL pi,LL pk)
{
    LL so=fac(n,pi,pk),fa=fac(m,pi,pk),mo=fac(n-m,pi,pk);
    LL k=0;
    for(LL i=n;i;i/=pi)k+=i/pi;
    for(LL i=m;i;i/=pi)k-=i/pi;
    for(LL i=n-m;i;i/=pi)k-=i/pi;
    return mul(mul(mul(so,inv(fa,pk),pk),inv(mo,pk),pk),qpw(pi,k,pk),pk);
}
inline LL exlucas(LL n,LL m)
{
	LL res=0,k=p,pk;
	LL maxx=sqrt(p)+6;
	for(LL i=2;i<maxx;++i)
	{
		if(k%i)continue;
		pk=1;while(k%i==0)pk*=i,k/=i;
		res=(res+crt(C(n,m,i,pk),pk))%p;
	}
	if(k>1)res=(res+crt(C(n,m,k,k),k))%p;
	return res;
}
int main()
{
    scanf(" %lld %lld %lld",&n,&m,&p);
    if(m>=p)return 0&puts("0");
    ans=exlucas(n,m);
    ans=ans*ans%p;
    for(int i=1;i<=m;++i)ans=ans*i%p;
    printf("%lld\n",ans);
    return 0;
}
```

---

## 作者：VinstaG173 (赞：3)

另外一种解法。

首先将题目转化为在第 $i$ 行有 $1$ 到 $2i-1$ 的格子的棋盘上放 $m$ 个车使它们互不攻击。

令题目中的棋盘 $S=(1,3,\dots,2n-1)$，正方形棋盘 $S'=(n,n,\dots,n)$，由 Ferrers 棋盘 $S=(a_1,a_2,\dots,a_n)$ 里放车的方案数满足

$$\sum_{k=0}^{n}r_k(S)x^{\underline{n-k}}=\prod_{i=1}^{n}(x+a_i-i+1)$$

有

$$\sum_{k=0}^{n}r_k(S)x^{\underline{n-k}}=\prod_{i=1}^{n}(x+i)$$

$$\sum_{k=0}^{n}r_k(S')x^{\underline{n-k}}=\prod_{i=1}^{n}(x+n-i+1)$$

容易发现两个式子的右边是一样的，所以 $r_k(S)=r_k(S')$。

然后 $r_k(S')=C_n^kA_n^k$ 可以由选 $k$ 行上有车，再选 $k$ 列的排列上有车得到。

---


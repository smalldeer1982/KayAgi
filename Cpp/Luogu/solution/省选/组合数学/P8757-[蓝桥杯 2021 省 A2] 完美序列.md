# [蓝桥杯 2021 省 A2] 完美序列

## 题目描述

一个序列中取出一些元素按照原来的顺序排列成新的序列称为该序列的一个子序列。子序列的价值为子序列中所有元素的和。

如果一个序列是单调递减的，而且除了第一个数以外的任何一个数都是上一个数的因数，则称这个序列为一个完美序列。

一个序列中的一个子序列如果是完美序列，则称为该序列的一个完美子序列。一个序列的最长完美子序列长度，称为该序列的完美长度。

给定正整数 $n$，$1$ 至 $n$ 的所有排列的完美长度的最大值，称为 $n$ 阶最大完美长度。

给定正整数 $n$，请求出 $1$ 至 $n$ 的所有排列中长度正好为 $n$ 阶最大完美长度的所有完美子序列的价值的和。


## 说明/提示

**【样例说明】**

当 $n=1$ 时，答案显然是 $1$ 。

当 $n=2$ 时, 全排列包括 $(1,2)$ 和 $(2,1)$, 其中 $(2,1)$ 拥有最长的完美子序列, 也就是 $(2,1)$ 本身, $2$ 阶最大完美长度为 $2$，答案即为 $2+1$ 。

当 $n=3$ 时，全排列包括 $(1,2,3)$、$(1,3,2)$、$(2,1,3)$、$(2,3,1)$、$(3,1,2)$、$(3,2,1)$ 。其中 $(2,1)$ 和 $(3,1)$ 都是最长的完美子序列，$3$ 阶最大完美长度为 $2$。

序列 $(1,2,3)$ 和 $(1,3,2)$ 中没有长度为 $2$ 的完美子序列。

序列 $(2,1,3)$ 中有完美子序列 $(2,1)$，价值和为 $3$。

序列 $(2,3,1)$ 中有完美子序列 $(2,1)$ 和 $(3,1)$，价值和为 $7$。

序列 $(3,1,2)$ 中有完美子序列 $(3,1)$，价值和为 $4$。

序列 $(3,2,1)$ 中有完美子序列 $(2,1)$ 和 $(3,1)$,价值和为 $7$。

答案为 $3+7+4+7=21$ 。

**【评测用例规模与约定】**

对于 $10 \%$ 的评测用例，$n \leq 10$;

对于 $20 \%$ 的评测用例，$n \leq 20$;

对于 $30 \%$ 的评测用例，$T \leq 20, n \leq 1000$;

对于 $40 \%$ 的评测用例，$T \leq 20, n \leq 10^{5}$;

对于所有评测用例，$1 \leq T \leq 10^{5}, 1 \leq n \leq 10^{6}$。

蓝桥杯 2021 第二轮省赛 A 组 J 题。

## 样例 #1

### 输入

```
5
1
2
3
5
10```

### 输出

```
1
3
21
140
2268000```

# 题解

## 作者：Demeanor_Roy (赞：3)

- [原题链接](https://www.luogu.com.cn/problem/P8757)

- 小清新组合数推导。

------------

首先考虑对于一个确定的 $n$ ，$n$ 阶最大完美长度是多少？

不难发现，由于完美子序列后一项是前一项的因子，排列又没有重复元素，所以完美子序列每一项至少除以二，那最优的子序列当然是 $2^k,2^{k-1},2^{k-2},....,2^{0}$ 如此排列，那么 $n$ 阶最大完美长度就应该为 $\lfloor \log n \rfloor + 1$ ，接下来我们用 $x$ 代替。

确定完 $x$ 的值，我们接下来试着推导一下对于一个 $1$ 到 $n$ 的排列，它可能的长度等于 $x$ 的完美子序列有哪些？

首先一个直观也可说是省事的想法就是只有上面所说的最优子序列一种，可当 $n = 3$ 时我们发现 $(3,1)$ 就出现了例外。这时不要急于否定自己，让我们仔细想想这样的例外多吗？

其实是不多的。从 $x$ 的表达式可以看出，类似 $2^k - 1$ 的这种 $n$ 最容易出现例外，当你随便列举几个例如 $3,7,15$ 这样的 $n$ 时就会发现：咦？好像例外最多就是在某一处相邻两项不是二倍关系，而是三倍关系。

这也很容易证明：因为完美子序列必须满足有 $x$ 项，第一项又不能超过 $2^x - 1$ ，那么如果存在一个有多个三倍关系或者一个更高倍关系的子序列，那 $n$ 阶最大完美长度的值就不会只是 $x$ 了。

那么哪些 $n$ 可能出现例外呢？必须是满足 $2^{x-2} \times 3 \leq n$ 才行。否则就只有最优子序列一种情况。

既然已经确定了有哪些类型的长度为 $x$ 的完美子序列，那接下来就是计算贡献了。

由于贡献是由子序列而来，而不是排列而来，所以我们只需要算出每种合法子序列的权值和，乘上它们在排列中的出现次数，再加起来就行，不需要担心因为两个合法子序列出现在一个排列而算重。

首先看次数，因为每种合法子序列长度相同，且都是在排列中，所以在所有排列中出现的次数也应相同。考虑 $x$ 个数首先排好，剩下 $n-x$ 个数随便排，就是 $(n-x)!$ ，然后我们需要把两组数按序并在一起，用插板法可得方案数为 $n \choose x$ ，那么出现次数就为 $(n-x)! \times {n \choose x}$ 。

接下来看权值和，首先最优子序列的权值和好说，就是 $2^x - 1$ 。而对于例外，相邻两项的商一定是 $x-2$ 个 $2$ 和 $1$ 个 $3$ ，那么根据 $3$ 的位置的不同就可以列出以下合式：

$$ \sum_{k=0}^{x-2}{(\sum_{i=0}^{k}{2^i} + \sum_{i=k}^{x-2}{3 \times 2^i})}$$

其中外层 $k$ 是枚举 $3$ 的位置，内层是分两部分计算权值和。

接下来再利用一些基本的和式技巧，就可以得到以下答案：

$$(3 \times x -4) \times 2^{x-1} - x + 2$$

那到此为止，这道题就完成了，时间复杂度 $O(n)$ ，下附代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define LL long long
const int N=1e6+10,mod=1e9+7;
int T,Log[N],pw[N],fct[N],inv[N],finv[N];
inline void init()
{
	pw[0]=fct[0]=inv[0]=finv[0]=fct[1]=inv[1]=finv[1]=1;
	pw[1]=2;
	for(int i=2;i<N;i++)
	{
		Log[i]=Log[i/2]+1;
		pw[i]=pw[i-1]*2%mod;
		fct[i]=(LL)fct[i-1]*i%mod;
		inv[i]=(mod-(LL)mod/i*inv[mod%i]%mod)%mod;
		finv[i]=(LL)finv[i-1]*inv[i]%mod;
	}
}
inline LL C(int x,int y)
{
	return (LL)fct[x]*finv[y]%mod*finv[x-y]%mod;
}
int main()
{
	init();
	scanf("%d",&T);
	while(T--)
	{
		int n,x,ans;
		scanf("%d",&n);
		x=Log[n]+1;
		ans=(LL)fct[n-x]*C(n,x)%mod*(pw[x]-1)%mod;
		if(x>=2&&pw[x-2]*3<=n)	ans=(ans+(LL)fct[n-x]*C(n,x)%mod*((((LL)x*3%mod-4+mod)%mod*pw[x-1]%mod-x+mod+2)%mod)%mod)%mod;
		printf("%d\n",ans);
	}
	return 0;	
} 
```

- 完结撒花~


---

## 作者：D2T1 (赞：2)

# 题解 P8757

感觉难度应该就绿，在学校五分钟想出来了。

------------

首先考虑**完美长度**是多少，显然对于一个完美子序列，第一个元素的质因数越多，它往后能延伸的完美子序列最长。而什么样的数质因数最多呢？$2^k$。

所以我们算出 $k=\lfloor\log_2(n)\rfloor$，$k+1$ 即为 $n$ 阶最大完美长度。

然后再来考虑怎么构造出长度为 $k+1$ 的完美子序列，显然有：

$$
\begin{matrix}
2^{k}&2^{k-1}&...&4&2&1
\end{matrix}
$$

当 $n\geq2^{k-1}\times3$ 时，还有：

$$
\begin{matrix}
2^{k-1}\times3&2^{k-2}\times3&...&6&3&1\\
2^{k-1}\times3&2^{k-2}\times3&...&6&2&1\\
...\\
2^{k-1}\times3&2^{k-2}&...&4&2&1
\end{matrix}
$$

易证可能的情况就只有这两种。因为题目非常良心，不让求方案数只让求和，所以我们设 $T$ 为上述所有可能方案中的所有数之和，答案即为：

$$T\times\dbinom{n}{k+1}\times(n-k-1)!$$

其中组合数代表着选 $k+1$ 个位置作为完美子序列，阶乘代表着其他位置可以随便放置。

```cpp
/*
    name: [蓝桥杯 2021 省 A2] 完美序列
    id:   P8757
    date: 2022/11/1
*/

#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

const int N = 1e6 + 10;
const ll P = 1e9 + 7;
ll fac[N], inv[N];
int t, n;

ll qp(ll a, ll b){
	ll ans = 1;
	while(b){
		if(b & 1){
			ans = ans * a % P;
		}
		a = a * a % P;
		b >>= 1;
	}
	return ans;
}
ll C(int n, int m){
	return fac[n] * inv[m] % P * inv[n-m] % P;
}

int main(){
	fac[0] = 1;
	for(int i = 1; i < N; ++ i){
		fac[i] = fac[i-1] * i % P;
	}
	inv[N-1] = qp(fac[N-1], P-2);
	for(int i = N-2; i >= 0; -- i){
		inv[i] = inv[i+1] * (i+1) % P;
	}
	scanf("%d", &t);
	while(t--){
		scanf("%d", &n);
		int k = log(n) / log(2);
		if(n == 1){
			puts("1");
			continue;
		}
		ll ans = (1 << k + 1) - 1;
		if(n >= (1 << k - 1) * 3){
			ans += k;
			for(int i = 1; i <= k; ++ i){
				ans += (1 << i) * (k - i);
				ans += (1 << i - 1) * 3 * i;
				ans %= P;
			}
		}
		printf("%lld\n", ans * C(n, k + 1) % P * fac[n-k-1] % P);
	}
	return 0;
}

```









---

## 作者：liuChF (赞：1)

## 前言

 别的题解很好，但是蒟蒻看不懂，所以写了一篇更**简单易懂**的题解，里面结合了我对这道题的理解。

## 思路

首先一个显而易见的结论是对于 $n$，它的最长完美序列的长度应该为 $x=\lfloor \log n \rfloor +1$ ，证明也很简单，我们要构造出最长的序列，怎么最长？让序列相邻两项的商为 $2$，也就是 $2^{x-1}$ $2^{x-2}$ $…$ $4$  $2$  $1$，因为如果有相邻的两项商大于 $2$，那在 $n$ 确定的情况下长度 $x$ 一定不会更优。~~这点还是显而易见的~~

然后考虑怎么计算答案，不难得出为 **所有序列的价值和** $\times$ **排列的种数**，而对于同一个长度 $x$，其排列的种类是固定的，所以我们先考虑后者的计算。

想象这里有 $n$ 个位置，先考虑这个长为 $x$ 的序列有几种放法，我们可以先选 $x$ 个位置，然后按顺序（从大到小）把序列的各项放进选的位置，很显然这有 $C_{n}^{x}$ 种方案。然后考虑剩下 $n-x$ 个数有几种放法，因为这些数没有顺序要求，所以是 $(n-x)!$ 种方案，根据乘法原理，共 $C_{n}^{x} \times (n-x)!$ 种方案，然后发现：
$$
tot=C_{n}^{x} \times (n-x)! = \dfrac {n!}{x!(n-x)!} \times (n-x)!= \dfrac {n!}{x!}
$$
它就约成这个比较简单的式子了。
 
其次就是考虑在 $x$ 确定后，完美子序列有哪几种可能。比如 $n=3$ 时，有 $(3,1)$ 和 $(2,1)$； $n=4$ 时，有 $(4,2,1)$； $n=6$ 时，有 $(6,3,1)$ 和 $(6,2,1)$ 和 $(4,2,1)$； $n=12$ 时，有 $(12,6,3,1)$ 和 $(12,6,2,1)$ 和 $(8,4,2,1)$。发现一定有的就是商**全部**为 $2$ 这一组，其次就是还有商**部分**为 $3$ ，**部分**为 $2$ 的序列，这时我们会意识到**一定没有**商为 $4$ 的两项，因为如果有，设为 $(…,4a,a,…)$ ，那这两项中间就可以再插入一个 $2a$，构成更长的完美子序列。由此，~~我们凭借敏锐的观察力~~，就会发现每一个完美字符列中，**商为 $3$ 的两项只有 $1$ 组**。什么意思？就是每一个完美字符列都可以表示为类似于 
$$
(3\times 2^{x-2},…,3\times 2^{k+1},3\times 2^{k},2^{k},…,2^{1},2^{0})
$$
的形式。为什么呢？**其本质是 $2^3<3^2$**。换句话说，**如果有 $2$ 组相邻的数商为 $3$，那一定可以替换为 $3$ 组商为 $2$ 的相邻的数**，这样序列就会更长。举个简单的例子，假设这商为 $3$ 的两组相邻，也就是 $(…,4 \times 9a,2 \times 9a,9a,3a,a,…)$，那一定可以改为 $(…,4 \times 8a,2 \times 8a,8a,4a,2a,a,…)$ 这个更长的。若这两组商为 $3$ 的不相邻也是一样的道理，所以商为 $3$ 的一定只有 $1$ 组。那一定有 $1$ 组吗？并不是，比如 $n=2^{k}$ 时就只有商全部为 $2$ 这一组。那怎么判断呢？很简单，只要 $2^{x-1}\times 3\le n$ 即可，意思就是如果其他全为 $\times 2$，只有一个 $\times 3$，还不超过 $n$，就可以，反之就不行。

最后我们考虑怎么把这些序列的和算出来。首先就是 $1$ $2$ $4$ $…$ $2^{x-2}$ $2^{x-1}$ 这一组（这里为了方便将序列倒一下，是等价的），很显然和为 $2^{x} -1$。然后考虑有一组商为 $3$ 的情况，我们可以枚举每个 $\times 3$ 的位置然后表示为：

$$
\sum_{k=0}^{x-2}(\sum_{i=0}^{k}2^{i}+3\times\sum_{i=k}^{x-2}2^{i})
$$

第一个 $\sum_{k=0}^{x-2}$ 枚举第 $k+1$ 个数为 $\times 3$ 的位置，后面两个 $\sum$ 表示前 $k$ 个数为 $(2^{0},2^{1},…,2^{k})$，第 $k+1$ 到第 $x$ 个数为 $(3 \times 2^{k},3 \times 2^{k+1},…,3 \times 2^{x-2})$。

可是我不会拆式子啊……那就列出来观察一下，以 $x=5$ 为例：

$$
\begin{array}{rrrrr|r}
1  &3\times 1  &3\times2 &3 \times 4&3\times 8&\to k=0\\
1  &2  &3\times2 &3 \times 4&3\times 8&\to k=1 \\
1  &2  &4  &3 \times 4 &3\times 8&\to k=2\\
1  &2  &4  &8 &3\times 8&\to k=3\\
\hline
1  &2  &4  &8&16
\end{array}
$$

横线下的是求过的，横线上的是我们要求的，发现可以分成两块求和:

$$
A=
\left|
    \begin{matrix}
    1  &&&\\
    1  &2  &&\\
    1  &2  &4 & \\
    1 &2&4&8
    \end{matrix}
\right|
,B=
\left|
    \begin{matrix}{}
    3\times 1  &3\times2 &3 \times 4&3\times8&\to k=0\\
      &3\times2 &3 \times 4 &3\times8&\to k=1\\
      &  &3 \times 4 &3\times8&\to k=2\\
      &&&3\times8&\to k=3
    \end{matrix}
\right|
$$

先看 $A$，发现它的每一行都是 $\{2^{i}\}$，共 $x-1$ 行，对它的每一行求和：

$$
\begin{aligned}
&(2^{1}-1)+(2^{2}-1)+(2^{3}-1)+(2^4-1)\\=&(2^1+2^2+2^3+2^4)-(5-1)\\=&(2^0+2^1+2^2+2^3+2^4-2^0)-(5-1)\\=&(2^{5}-1-2^0)-(5-1)
\end{aligned}
$$

推广一下，得到：

$$
Sum_{A}=(2^x-2)-(x-1)=2^x-x-1
$$

再看 $B$，发现可以先提出一个 $3$，然后对每一行求和，可以看成在第一行的基础上减去前 $k$ 个：

$$
\begin{aligned}
&3\times[4\times(2^4-1)-(2^1-1)-(2^2-1)-(2^3-1)]\\=&3\times[4\times(2^4-1)-(2^1+2^2+2^3)+(5-2)]\\=&3\times[4\times(2^4-1)-(2^0+2^1+2^2+2^3-2^0)+(5-2)]\\=&3\times[4\times(2^4-1)-(2^4-1-2^0)+(5-2)]
\end{aligned}
$$

推广一下，得到：

$$
\begin{aligned}
Sum_B &= 3\times [(x-1)\times(2^{x-1}-1)-(2^{x-1}-2)+(x-2)] \\ &=3\times[(x-2)\times2^{x-1}-(x-1)+2+(x-2)]\\&=3\times[(x-2)\times 2^{x-1}+1]
\end{aligned}
$$

然后可以得到：

$$
Sum=Sum_A+Sum_B=(3x-4)\times2^{x-1}-x+2
$$

然后答案就是 $tot\times Sum$。

## 做法

很明显这题要预处理，对于 $tot$，要预处理阶乘 $mul_i$ 和逆元 $inv_i$，以及其逆元阶乘 $minv_i$，对于 $Sum$，要预处理 $2^i$。对于这些都可以 $O(n)$ 预处理，最后 $O(1)$ 计算。

注意预处理的边界和取模。

## 代码

浓缩的都是精华，不到30行极简代码。

```cpp
#include <bits/stdc++.h>
#define LL long long
using namespace std;
const int N = 1e6 + 10, n = 1e6 + 1, mod = 1e9 + 7;
LL mul[N], inv[N], minv[N], pow_2[N], T, m, x, t1, t2, t3;
signed main() {
	ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
	mul[0] = mul[1] = inv[0] = minv[0] = inv[1] = pow_2[0] = minv[1] = 1;
	for (int i = 2; i <= n; i++) {
		mul[i] = (i * mul[i - 1]) % mod;
		inv[i] = ((mod - mod / i) * inv[mod % i]) % mod;
		minv[i] = (minv[i - 1] * inv[i]) % mod;
		pow_2[i - 1] = (pow_2[i - 2] * 2) % mod;
	}
	cin >> T;
	while (T--) {
		cin >> m;
		x = log2(m) + 1;
		t1 = (mul[m] * minv[x]) % mod;
		t2 = ((3 * x - 4) * pow_2[x - 1] - x + 2) % mod;
		t3 = pow_2[x] - 1;
		if (x >= 2 && pow_2[x - 2] * 3 <= m) {
			cout << t1 * (t2 + t3) % mod << '\n';
		} else {
			cout << t1 * t3 % mod << '\n';
		}
	}
	return 0;
}
```

蒟蒻好不容易打完，点个赞吧。

---

## 作者：lzyqwq (赞：1)

模拟赛场切了。这是个普及组题吧。

**[题目传送门](https://www.luogu.com.cn/problem/P8757)**

> - 称序列 $(a_1,\dots,a_k)$ 的 **价值** 为 $v(a)=\sum\limits_{i=1}^ka_i$。
> - 称序列 $(a_1,\dots,a_k)$ 是 **完美序列**，当且仅当 $\forall\,i\in[2,k]\cap\mathbb{Z},p_i\,|\,p_{i-1}\land p_i<p_{i-1}$。
> - 对于一个序列，如果她的一个子序列是 **完美序列**，则称这个子序列是原序列的一个 **完美子序列**。将一个序列的 **完美长度** 定义为其最长 **完美子序列** 的长度。
> - 对于 $1\sim n$ 的所有排列，将她们 **完美长度** 的最大值称为 **$\boldsymbol{n}$ 阶最大完美长度**，记为 $p_n$。
> - 给出 $n$，对于一个 $1\sim n$ 的排列，定义她的 **完美程度** 为她所有长度为 $p_n$ 的 **完美子序列** 的 **价值** 和。求 $1\sim n$ 的所有排列的 **完美程度** 和 $S_n$ 模 $10^9+7$ 的值。您需要回答 $T$ 个询问。
> - $T\le 10^5,n\le 10^6$。

考虑如何求 $p_n$。显然任意一个排列的 **完美子序列** 都是 $(n,\dots,1)$ 这个排列的 **完美子序列**。我们只要求这个排列的完美长度即可。

考虑 dp。记 $f_i$ 表示以 $i$ 这个 **元素** 开头（不是下标）的最长 **完美子序列** 长度。考虑 $i$ 这个元素的后继，她一定是 $i$ 的 **真因数**（即不能为她自己）。并且任意一个 $i$ 的真因数在 $(n,\dots,1)$ 中的位置一定在 $i$ 后面，因此可以作为后继。我们有：

$$f_i=\max_{j\,|\,i}(f_j+1)$$

这个可以不能直接暴力枚举 $i$ 的因数转移。考虑埃筛预处理出每个数的因数。时间复杂度用调和级数计算为 $\mathcal{O}(n\log n)$。但是预处理常数太大（可能是我的问题），因此实现时考虑每个数转移给她的倍数。

计算完 $f_i$ 之后，考虑最长 **完美子序列** 的结尾、开头是哪个数，可以得到 $p_n=\max\limits_{i=1}^n f_i$。

同时，我们还需要计算 $g_i,h_i$ 两个数组，分别表示以 $i$ 这个元素开头所有长度为 $f_i$ 的 **完美子序列** 的 **价值** 和、以 $i$ 这个元素开头长度为 $f_i$ 的 **完美子序列** 的个数。换句话说，记 $V_i$ 表示以 $i$ 这个元素开头的长度为 $f_i$ 的 **完美子序列** 集合，则 $g_i=\sum\limits_{a\in V_i}v(a),h_i=|V_i|$。


有转移：

$$g_i=\sum\limits_{j\,|\,i\,\land \,f_j+1=f_i}(g_j+h_j\times j)\\h_i=\sum\limits_{j\,|\,i\,\land\,f_j+1=f_i}h_j$$

和 $f_i$ 类似枚举倍数转移即可。

最后，我们需要计算 $s_i$ 表示开头元素在 $[1,i]$ 之间的长度为 $p_i$ 的 **完美子序列** 的 **价值** 和。换句话说，记 $(i,\dots,1)$ 这个排列的长度为 $p_i$ 的 **完美子序列** 集合为 $U_i$，则 $s_i=\sum\limits_{a\in U_i}v(a)$。考虑两种情况：

- $f_i\ge p_{i-1}$：

  - $f_i>p_{i-1}$：此时 $p_i=f_i,U_i=V_i,s_i=g_i$。
  - $f_i=p_{i-1}$：此时 $p_i=f_i,U_i=U_{i-1}\cup V_i,s_i=s_{i-1}+g_i$。

- $f_i<p_{i-1}$：此时 $p_i=p_{i-1},U_i=U_{i-1},s_i=s_{i-1}$。

接下来，考虑一个满足条件的子序列对答案的贡献，即她在哪些排列中出现。显然出现她的排列个数为 $\dbinom{n}{p_n}\times (n-p_n)!$，考虑任选 $p_n$ 个位置放这个子序列，然后剩下元素任意排。

因此可以得到 $S_n$ 的表达式：

$$\begin{aligned}S_n&=\sum\limits_{a\in U_n}\left[v(a)\times \binom{n}{p_n}\times (n-p_n)!\right]\\&=\left(\sum\limits_{a\in U_n}v(a)\right)\times\dbinom{n}{p_n}\times (n-p_n)! \\&=s_n\times \dbinom{n}{p_n}\times (n-p_n)!\end{aligned}$$

只需要求出组合数和阶乘即可。线性预处理阶乘，然后配合费马小定理以及快速幂求逆元即可。可以线性预处理阶乘逆元但是没必要。

时间复杂度为 $\mathcal{O}(n\log n)$，空间复杂度为 $\mathcal{O}(n)$。翻了一遍题解区好像我的做法挺垃圾。

**[AC Link](https://www.luogu.com.cn/record/172414844)**

**[AC Code](https://www.luogu.com.cn/paste/nwtkcsoo)**

其实我一开始发现一个长度为 $n$ 的排列的 **完美子序列** 长度不超过 $\mathcal{O}(\log n)$，考虑每一个元素至多是前一个除以 $2$。但是在我的做法里并无卵用。

---

## 作者：AgOH (赞：0)

读完题目，我们可以轻松获取如下三个结论（以下简称“$1$ 至 $n$ 的所有排列中长度正好为 $n$ 阶最大完美长度的最长完美子序列”为“最长完美子序列”：

1. $n$ 阶最大完美长度为 $\lfloor \log_2 n \rfloor + 1$
2. 每个“最长完美子序列”一定以 $1$ 为结尾
3. 每个“最长完美子序列”中一定只存在前一个数是后一个数的 $2$ 倍或 $3$ 倍，且 $3$ 倍只出现一次

第一个结论是显然的，因为下降最慢的完美序列为等比数列 $2^k,2^{k-1},\cdots,1$，故一个最大值为 $n$ 的完美序列的最大长度为 $\lfloor \log_2 n \rfloor + 1$。

第二个结论采取反证法：若存在一个最长完美子序列 $P$ 不以 $1$ 为结尾，那么一定存在一个完美子序列 $Q=(P,1)$ 比 $P$ 长，那么 $P$ 必然不是最长的，矛盾。

第三个结论采取反证法：首先，若出现了 $3$ 倍以上，即以长度 $2$ 出现了 $3$ 倍以上（例：$5,1$），但我们至少可以用长度 $3$ 来出现 $4$ 倍（$4,2,1$），也就说说若出现了 $3$ 倍以上，那么此“最长完美子序列”必然不是最长的，矛盾；其次，若出现了两个 $3$ 倍，即以长度 $3$ 出现了 $9$ 倍（例：$9,3,1$），但我们可以用长度 $4$ 来出现 $8$ 倍（$8,4,2,1$），也就是说若出现了 $9$ 倍，那么此“最长完美子序列”必然不是最长的，矛盾。

有了如上三个结论，我们就可以开始考虑如何解决这个问题了。设 $n$ 阶最大完美长度为 $len=\lfloor \log_2 n \rfloor + 1$，我们分情况讨论：

### “最长完美子序列”中不存在 $3$ 倍，即“最长完美子序列”为：$2^{len-1} \rightarrow 1$

此时“最长完美子序列”为等比数列 $2^{len-1},2^{len-2},\cdots,1$，由等比数列求和公式 $S_n=\cfrac{a_1-a_{n}q}{1-q}$，此情况下“最长完美子序列”的和为：

$$\cfrac{2^{len-1}-1 \times \frac{1}{2}}{1-\frac{1}{2}}=2^{len}-1$$

### “最长完美子序列”中存在 $3$ 倍，即“最长完美子序列”为：$3 \cdot 2^{len-2} \rightarrow 1$

注意：只有当 $n \geq 3 \cdot 2^{len-2}$ 时才会出现此情况。

设 $S_{len}$ 为存在 $3$ 倍情况下所有长度为 $len$ 的“最长完美子序列”的和，则有：

![](https://cdn.luogu.com.cn/upload/image_hosting/mekrxjkx.png)

递推预处理即可。以 $len=5$ 为例，上式的各部分如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/ysc8zx5z.png)

当然，也可以使用此递推式的通项公式 $S_{len}=2^{len-1}(3len-4) - len + 2$ 直接算出结果。

于是对于一个给定的 $n$，我们只需要判断一下是否可能出现第二种情况，根据上文所述即可获取所有“最长完美子序列”的和。

注意“最长完美子序列”是 $1$ 至 $n$ 的所有排列的子序列，也就是说每个“最长完美子序列”会出现多次，其出现次数为 $\cfrac{A_n^n}{A_{len}^{len}}=\cfrac{n!}{len!}$，在计算答案时需要乘进去。

为什么是 $\cfrac{A_n^n}{A_{len}^{len}}$ 呢？$1$ 至 $n$ 的所有排列共有 $A_n^n$ 个，而其中“最长完美子序列”的相对位置是不变的，所以除掉“最长完美子序列”的排列数 $A_{len}^{len}$。

注意到出现了有理数取余，需要预处理阶乘及其逆元 $\left[ \cfrac{n!}{len!} \equiv n! \times (len!)^{-1} \pmod p \right]$。数据规模 $n \leq {10}^6$ 不是很大，采用 $O(n \log n)$ 或者 $O(n)$ 求逆元都可以。

若采用 $O(n \log n)$ 求逆元则总时间复杂度为 $O(n \log n + T)$；若采用 $O(n)$ 求逆元则总时间复杂度为 $O(n + T)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
const int maxn = 1e6+5;
const int mod = 1e9+7;
ll qpow(ll a,ll k)
{
    ll res = 1;
    for(;k;k>>=1,a=a*a%mod) if(k&1) res = res*a%mod;
    return res;
}
ll fct[maxn]={0,1}, inv[maxn]={0,1};
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    for(int i=2;i<=1e6;i++) fct[i] = fct[i-1]*i%mod;
    for(int i=2;i<=1e6;i++) inv[i] = qpow(fct[i], mod-2);
    int t;
    cin>>t;
    while(t--)
    {
        int n;
        cin>>n;
        if(n==1) cout<<1<<'\n';
        else 
        {
            ll len = log2(n)+1;
            ll a = fct[n]*inv[len]%mod;
            ll c1 = a*((1<<len)-1)%mod;
            if(n<3*(1<<(len-2))) cout<<c1<<'\n';
            else cout<<(c1+a*((1<<(len-1))*(3*len-4)-len+2))%mod<<'\n';
        }
    }
    return 0;
}
```

---

## 作者：Augury (赞：0)

# 题解 [P8757 [蓝桥杯 2021 省 A2] 完美序列](https://www.luogu.com.cn/problem/P8757)

## 题意

如果一个序列是单调递减的，而且除了第一个数以外的任何一个数都是上一个数的因数，则称这个序列为一个完美序列。

一个序列中的一个子序列如果是完美序列，则称为该序列的一个完美子序列。一个序列的最长完美子序列长度，称为该序列的完美长度。

给定正整数 $n$，$1$ 至 $n$ 的所有排列的完美长度的最大值，称为 $n$ 阶最大完美长度。

给定正整数 $n$，请求出 $1$ 至 $n$ 的所有排列中长度正好为 $n$ 阶最大完美长度的所有完美子序列的价值的和。

## 思路

显然地，$n$ 阶最大完美长度 $len=\lfloor\log_2n\rfloor+1$，因为从 $\operatorname{highbit}(n)$ 开始，每次除 $2$ 一定不会更劣。

考虑如何证明。考虑每次除的数，构成了一个长为 $len-1$ 的序列。

1. 如果替换掉一个数。显然只可能替换成质数。
   如果 $n\ge\frac{3}{2}\operatorname{highbit}(n)$，那么可以将序列中的一位替换成 $3$，此时最大完美长度不变。
   如果替换成 $5$，显然 $n<\frac{5}{2}\operatorname{highbit}(n)$。这样最大位就比 $n$ 大了，肯定是不行的。
   大于 $5$ 的数同理。
   因此，只可能把序列中的某位替换成 $3$。
2. 如果替换掉多个数。还是值可能替换成质数。
   如果替换两个 $3$，显然 $n<\frac{9}{4}\operatorname{highbit}(n)$。这样最大位就比 $n$ 大了，肯定不行。
   显然，如果替换成更大或者更多的数，也一定不行。

在这个过程中，我们发现，这个序列中，只可能有 $2$ 和 $3$，而且最多只会有一个 $3$。

考虑计算每个数可以贡献多少次。假设现在是从小到大的第 $i$ 个数，这个数为 $x$。

首先，要在 $n$ 个位置中选 $len$ 个位置作为完美序列，剩下的 $n-len$ 个位置随便排，这部分是 $\binom{n}{len}\times(n-len)!$。

现在排列的位置确定了，考虑有多少种排列会让 $x$ 产生贡献。

1. 如果 $x$ 的因子中没有 $3$，那么如果 $n\ge\frac{3}{2}\operatorname{highbit}(n)$，则有 $len-i$ 个位置可以被替换成 $3$。
   再加上全部是 $2$ 的一种，总共就是 $1+\left
   [n\ge\frac{3}{2}\operatorname{highbit}(n)\right](n-len)$ 种。
2. 如果 $x$ 的因子中有 $3$，那么有 $i$ 个位置可以放 $3$。
   总共就是 $\left[n\ge\frac{3}{2}\operatorname{highbit}(n)\right]len$ 种。

枚举即可，复杂度 $O(n\log n+n\log P)$。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
inline int read(){
	int ans=0;bool op=0;char ch=getchar();
	while(ch<'0'||'9'<ch){if(ch=='-')op=1;ch=getchar();}
	while('0'<=ch&&ch<='9'){ans=(ans<<1)+(ans<<3)+(ch^48);ch=getchar();}
	if(op)return -ans;
	return ans;
}
const int maxn=1e6+10;
const int mod=1e9+7;
int n;
int fact[maxn];
int ifac[maxn];
int len;
int base;
int ans=0;
int inv(int a){
	int ans=1;
	for(int i=mod-2;i;i>>=1){
		if(i&1)ans=ans*a%mod;
		a=a*a%mod;
	}
	return ans;
}
int C(int a,int b){
	if(b>a||a<0||b<0)return 0;
	return fact[a]*ifac[b]%mod*ifac[a-b]%mod;
}
void real_main(){
	n=read();
	if(n==1){
		puts("1");
		return;
	}
	len=__lg(n)+1;
	base=1;
	ans=0;
	for(int i=1;i<=len;i++){//只有2的
		ans=(ans+C(n,len)*base%mod*fact[n-len]%mod)%mod;
		base<<=1;
	}
	if((1<<(len-2))*3>n){
		cout<<ans<<'\n';
		return;
	}
	base=1;
	for(int i=1;i<=len;i++){//不含3的
		ans+=C(n,len)*base*(len-i)%mod*fact[n-len]%mod;
		ans%=mod;
		base<<=1;
	}
	base=3;
	for(int i=2;i<=len;i++){//含3的
		ans+=C(n,len)*base*(i-1)%mod*fact[n-len]%mod;
		ans%=mod;
		base<<=1;
	}
	cout<<ans<<'\n';
}
signed main(){
	fact[0]=1;
	for(int i=1;i<maxn;i++)fact[i]=fact[i-1]*i%mod;
	for(int i=0;i<maxn;i++)ifac[i]=inv(fact[i]);
	int T=read();
	while(T--)real_main();
	return 0;
}
```

## 优化

这样已经可以过了，但是还可以优化一下。

容易发现，每个式子都含有`C(n,len)*fact[n-len]`。

定义 $tot=\binom{n}{len}\times(n-len)!$，即可避免预处理逆元。

或者，容易发现，$\binom{n}{len}\times(n-len)!=\frac{n!}{len!}$，而 $len=\lfloor\log_2n\rfloor+1$。所以只要预处理出前 $20$ 个阶乘的逆元即可。

观察全 $2$，除了 $tot$ 之外的部分等于 $\sum_{i=1}^{len}2^{i-1}=\sum_{i=0}^{len-1}2^i=2^{len}-1$。

观察不含 $3$，除了 $tot$ 之外的部分：

$$
\begin{array}{c}
f(len)\\
=\sum_{i=1}^len2^{i-1}(len-i)\\
=\sum_{i=1}^{len-1}2^{i-1}(len-1-i+1)\\
=\sum_{i=1}^{len-1}2^{i-1}(len-1-i)+\sum_{i=1}^{len-1}2^{i-1}\\
=f(len-1)+\sum_{i=0}^{len-2}2^i\\
=f(len-1)+2^{len-1}-1
\end{array}
$$

观察含 $3$，除了 $tot$ 之外的部分 $g(len)=g(len-1)+base\times(len-1)$。$base$ 的含义见上面的代码。

现在，我们把每一个计算都优化成了递推，可以预处理。单次询问 $O(1)$。

复杂度 $O(T+\log_2n)$，卡到了本题最优解（2023.6.30）。

[提交记录](https://www.luogu.com.cn/record/113569873)

~~[@TQI_II](https://www.luogu.com.cn/user/682409)为机房公用账号，上面也是我交的，会在下面发个评论证明一下。~~

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
inline int read(){
	int ans=0;bool op=0;char ch=getchar();
	while(ch<'0'||'9'<ch){if(ch=='-')op=1;ch=getchar();}
	while('0'<=ch&&ch<='9'){ans=(ans<<1)+(ans<<3)+(ch^48);ch=getchar();}
	if(op)return -ans;
	return ans;
}
const int maxn=1e6+10;
const int mod=1e9+7;
int n;
int fact[maxn];
int ifac[maxn];
int len;
int base;
int ans=0;
int pre2[maxn];
int pre23[maxn];
int pre33[maxn];
int inv(int a){
	int ans=1;
	for(int i=mod-2;i;i>>=1){
		if(i&1)ans=ans*a%mod;
		a=a*a%mod;
	}
	return ans;
}
signed main(){
	fact[0]=1;
	for(int i=1;i<maxn;i++)fact[i]=fact[i-1]*i%mod;
	ifac[20]=inv(fact[20]);
    for (int i=19;i>=0;i--)ifac[i]=(ifac[i+1]*(i+1))%mod;
	base=1;
	for(int i=1;(1<<(i-1))<maxn;i++){
		pre2[i]=(pre2[i-1]+base)%mod;
		pre23[i]=(pre23[i-1]+base-1)%mod;
		base<<=1;
	}
	base=3;
	for(int i=2;(1<<(i-1))<maxn;i++){
		pre33[i]=(pre33[i-1]+base*(i-1))%mod;
		base<<=1;
	}
	int T=read();
	while(T--){
		n=read();
		if(n==1){
			puts("1");
			continue;;
		}
		len=__lg(n)+1,ans=0;
		int tot=fact[n]*ifac[len]%mod;
		ans=(ans+pre2[len]*tot%mod)%mod;
		if((1<<(len-2))*3>n)cout<<ans<<'\n';
		else cout<<(ans+tot*(pre23[len]+pre33[len])%mod)%mod<<'\n';
	}
	return 0;
}
```

## update 2023.6.30

修 $\LaTeX$/kk

## update 2023.7.2

修 $\LaTeX$/kk

---

## 作者：有素质的2B铅笔 (赞：0)

## 思路

为使描述方便，先令题目描述中的“完美序列”反转（即序列单调递增且每一个数都是上一个数的倍数）。原“完美序列”与反转后的本质相同。

先考虑最大长度。

显然，当完美序列为 $1,2,4,...,2^k\ (2^k\le n<2^{k+1}\text{，即 }k=\left\lfloor\log_2n\right\rfloor)$ 时长度最大，长度为 $k+1$（下文的 $k$ 均指代 $\left\lfloor\log_2n\right\rfloor$）。

考虑有没有其他符合要求且长度为 $k+1$ 的序列。

序列的所有数都小于等于 $n$，等价于序列的最大值小于等于 $n$。序列的最大值可以看作是 $k$ 个大于 $1$ 的正整数相乘，目前 $k$ 个数都是 $2$。考虑调整这 $k$ 个数。

- 如果调整一个 $2$，将其变成 $3$，那么最大值为 $2^{k-1}\times3$，可能小于等于 $n$；但如果将一个 $2$ 变为 $4$，那么最大值为 $2^{k-1}\times4=2^{k+1}>n$，因此不可以，而将 $2$ 变为大于 $4$ 的数显然也不可以。

- 如果调整两个 $2$，将其变成两个 $3$，那么最大值为 $2^{k-2}\times3^2>2^{k-2}\times2^3>n$，因此不可以调整两个 $2$。调整两个以上的 $2$ 显然也不可以。

综上，符合条件的序列只有以下两种情况：

1. $\begin{cases}a_1=1\\a_i=a_{i-1}\times2&i\in[2,k+1]\end{cases}$

1. $\begin{cases}a_1=1\\a_i=a_{i-1}\times2&i\in[2,k+1]\text{ 且 }i\ne t\\a_t=a_{t-1}\times3&t\text{ 为 }[2,k+1]\text{ 中的一个常数}\end{cases}$

第一种情况一定成立，第二种情况在 $2^{k-1}\times3\le n$ 时才成立。

因此，总共有 $1$ 种或 $k+1$ 种不同的最长完美序列。

不管有几种序列，所有最长完美序列的长度都是一样的，因此他们在所有 $n$ 的排列中出现的次数都相同。我们只需计算出所有序列的价值之和，再乘上每一种序列的出现次数即可。

计算每一种序列的出现次数只需用插板法，原本有 $k+1$ 个不同的数，需在其中不断插入不同的数，直到最终有 $n$ 个数，因此出现次数为 $(k+2)\times(k+3)\times ...\times n=\dfrac{n!}{(k+1)!}$。

设所有最长完美序列的价值之和为 $sum$，答案即为 $sum\times\dfrac{n!}{(k+1)!}$。

对于每次询问，计算 $sum$ 的时间复杂度为 $O(\log^2n)$；预处理 $n$ 以内的阶乘与阶乘逆元的时间复杂度为 $O(n)$。因此总时间复杂度为 $O(T\log^2n+n)$。

## 代码

```cpp
#include<bits/stdc++.h>
#define LL long long
using namespace std;
inline int read() {
	int s=0,f=1; char ch=getchar();
	while (ch<48 || ch>57) {if (ch=='-') f=-1; ch=getchar();}
	while (ch>=48 && ch<=57) {s=(s<<3)+(s<<1)+(ch^48); ch=getchar();}
	return s*f;
}
const int N=1e6+5,P=1e9+7;
LL fac[N],facinv[N];
LL getinv(LL x) {
	LL res=1;
	for (int y=P-2;y;y>>=1) {
		if (y&1) res=res*x%P;
		x=x*x%P;
	}
	return res;
}
void init(int n) {
	fac[0]=1;
	for (int i=1;i<=n;++i)
	fac[i]=fac[i-1]*i%P;
	facinv[n]=getinv(fac[n]);
	for (int i=n;i>=1;--i)
	facinv[i-1]=facinv[i]*i%P;
}
int T,n;
int main() {
	init(1e6);
	T=read();
	while (T--) {
		n=read();
		int k=log2(n);
		LL sum=(1<<k+1)-1;
		if ((1<<k-1)*3<=n) {
			for (int i=1;i<=k;++i) {
				int x=1; sum=(sum+1)%P;
				for (int j=1;j<=k;++j) {
					if (i==j) x*=3;
					else x<<=1;
					sum=(sum+x)%P;
				}
			}
		}
		printf("%lld\n",sum*(fac[n]*facinv[k+1]%P)%P);
	}
	return 0;
}

```

$\text{114ms / 15.71MB}$


---


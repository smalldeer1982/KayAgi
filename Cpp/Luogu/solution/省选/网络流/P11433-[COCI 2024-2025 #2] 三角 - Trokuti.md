# [COCI 2024/2025 #2] 三角 / Trokuti

## 题目背景

译自 [COCI 2024/2025 #2](https://hsin.hr/coci/) T5。$\texttt{4s,0.5G}$。满分为 $120$。


## 题目描述


给定一张 $6n$ 个节点 $m$ 条边的无向图。保证这张图可以被**划分**成 $2n$ 个 $K_3$（大小为 $3$ 的完全图）。

求出这张图中的 $n$ 个 $K_3$，不能有重复顶点。

## 说明/提示



对于 $100\%$ 的数据，保证：

- $1\le T\le 100$；
- $1\le n,\sum n\le 300$；  
- $0\le m\le 10^6$；
- $1\le u,v\le 6n$。


| 子任务编号 | $n,\sum n$ |  特殊性质 | 得分 |  
| :--: | :--: | :--: |:--: | 
| $ 1 $    | $\le 300$ | A |   $ 13 $   |  
| $ 2 $    | $=3$ | B |  $ 18 $   |  
| $ 3 $    | $=6$ | B |  $ 18 $   |  
| $ 4 $    | $\le 300$ |   |  $ 71 $   |  

- 特殊性质 A：$m=6n$。
- 特殊性质 B：$T=1$。

## 样例 #1

### 输入

```
1
1 6
1 2
2 3
1 3
4 5
4 6
5 6```

### 输出

```
1 2 3```

## 样例 #2

### 输入

```
1
3 26
4 7
4 9
7 9
4 5
4 8
5 8
4 12
4 18
12 18
3 7
3 9
15 5
15 8
6 13
6 1
13 1
6 14
6 17
14 17
6 2
6 10
2 10
16 13
16 1
11 14
11 17```

### 输出

```
1 6 13
3 7 9
4 5 8```

# 题解

## 作者：wjwWeiwei (赞：7)

前言：很好的题，校内选拔 EC final 打星队时靠此题打到了 rank 2。


先跳了 T4 看这道题。可以观察到限制很宽松，找到一半的三角形就可以了，于是可以先想一个贪心思路：枚举边集中的一条边 $AB$，并找到另一个点 $C$ 使得 $AC$ 与 $BC$ 联通，并删除这三个点。


不过这显然会被如下的情况卡掉：


![](https://cdn.luogu.com.cn/upload/image_hosting/uzuhqn0s.png)


这样的话，找到一个三角形后，3 个同时会被破坏，找到的三角形个数最坏为 $\lceil\frac{2n}{3}\rceil$ 个，不过也很接近 $n$。


所以可以考虑打乱加入的点，使得上述情况不会出现太多。在随机数据下这样贪心成功的概率极高。本地造出 $n=300$ 的数据基本能找到 $>550$ 个三角形。


当然基于图中的那种情况有一个 $O(n^4)$ 的方法，可以解决小数据不打散点列时成功概率比较低的情况，不过这没有必要就是了。


官方 solution 说可以用 flow 找到所有三角形，不过我也不是很会。


赛事代码（去掉部分分）：


```cpp
#include<bits/stdc++.h>
#define For(i,a,b) for(int i=(a);i<=(b);i++)
using namespace std;
const int N=1e5+5;
int n,m;
int T;
int id[N];
int cnt=0;
bool vis[N];
unordered_map<int,int>um[N];
struct node{
	int u,v,w;
};
vector<node>ans;
bool fl=0;
int main(){
	srand(time(0));
	ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
	cin>>T;
	while(T--){
		cin>>n>>m;
		cnt=0;
		int up=6*n;
		int u,v;
		for(int i=1;i<=up;i++)um[i].clear();
		for(int i=1;i<=m;i++){
			cin>>u>>v;
			um[u][v]=um[v][u]=1;
		}
		cnt=0;
		while(cnt^n){
			ans.clear();
			cnt=0;
			for(int i=1;i<=up;i++)id[i]=i,vis[i]=0;
			random_shuffle(id+1,id+1+up);
			for(int i=1;i<=up;i++){
				int x=id[i];
				if(vis[x])continue;
				for(int j=1;j<=up;j++){
					int y=id[j];
					if(x==y||vis[y]||!um[x].count(y))continue;
					if(vis[x])break;
					for(int k=1;k<=up;k++){
						if(vis[k]||x==k||y==k)continue;
						if(um[x].count(k)&&um[y].count(k)){
							ans.push_back({x,y,k});cnt++;
							vis[x]=vis[y]=vis[k]=1;
							break;
						}
					}
					if(cnt==n)break;
				}
				if(cnt==n)break;
			}
		}
		for(auto p:ans)cout<<p.u<<" "<<p.v<<" "<<p.w<<"\n";
	}
	return 0;
}
```

---

## 作者：CarroT1212 (赞：2)

神奇题。首先题目说点集可被分成 $2n$ 个三元环，但是只要求找到 $n$ 个，说明大概不是什么正经题。

于是开始乱想，不难想到一个不保对的暴力：每次从图里选一个点，然后尝试找一个它参与构成的三元环，把这个三元环从图里丢掉，否则把这个点丢了。

考虑这个做法找出的三元环数的下界 $d$，可以知道它是 $\frac{2}{3}n$，因为原图的最优构造方式会得到 $2n$ 个环，而我们每次选取三元环的最极端的情况是，选的这三个点在最优解下所在的三元环互不相同，导致这一选损失了 $2$ 个环。

注意到，在 $n$ 比较大的时候，这个暴力跑不出 $n$ 个三元环的概率，**非常低**。因为 $n$ 大的时候有相当高的容错率使得我们只要选错次数不多到离谱，就不至于不合法。错误率大概是个几分之几的 $O(n)$ 次方左右的东西。

所以一个极容易实现的正解出现了：把暴力做法里的选点变成随机选点，反复跑暴力直到出现一组解，$n$ 小的情况足以在时限内被覆盖，$n$ 大的情况几次就够。

随便写就可以了，跑得飞快。

```cpp
mt19937_64 dnr(time(0));
ll rnd(ll l,ll r) { return dnr()%(r-l+1)+l; }
ll n,m,c[N*6],has[N*6][N*6];
vector<pair<ll,pll>> ans;
vector<ll> e[N*6];
bool solve() {
	ans.clear();
	for (ll i=1;i<=n*6;i++) c[i]=0;
	vector<ll> v;
	for (ll i=1;i<=n*6;i++) v.pb(i);
	while (v.size()) {
		ll p=rnd(0,(ll)v.size()-1),x=v[p],flg=0;
		for (ll y:e[x]) if (!c[y]) {
			for (ll z:e[y]) if (!c[z]&&z!=x) {
				if (has[x][z]) {
					ans.pb({x,{y,z}}),c[x]=c[y]=c[z]=1;
					v.erase(v.begin()+p),v.erase(lower_bound(v.begin(),v.end(),y)),
					v.erase(lower_bound(v.begin(),v.end(),z));
					flg=1; break;
				}
			}
			if (flg) break;
		}
		if (!flg) v.erase(v.begin()+p),c[x]=1;
	}
	if (ans.size()>=n) {
		for (ll i=0;i<n;i++) cout<<ans[i].fi<<" "<<ans[i].se.fi<<" "<<ans[i].se.se<<"\n";
		return 1;
	}
	return 0;
}
void mian() {
	scanf("%lld%lld",&n,&m);
	for (ll i=1;i<=n*6;i++) {
		e[i].clear();
		for (ll j=1;j<=n*6;j++) has[i][j]=0;
	}
	for (ll i=1,x,y;i<=m;i++) {
		scanf("%lld%lld",&x,&y);
		if (x!=y) e[x].pb(y),e[y].pb(x),has[x][y]=has[y][x]=1;
	}
	while (!solve());
}
```

当然如果你没有注意到这一步结论也可以做。以下主要是官解提到的过程。

考虑上面提到的极端情况（一个被暴力选取的三元环在最优解中占用了多个三元环里的点），实际上我们可以依次对选出的三元环检查一遍把它的三个点分别再尝试匹配会不会配出更多的三元环，直到得到 $n$ 个三元环。优秀地实现这个过程可以做到 $O(n^3)$，不过常数也许比较超人。

至于为什么这样调整一定能调出来一个 $\ge n$ 的解，考虑证明：因为没有找到 $n$ 个三元环，所以肯定有大于 $3n$ 个点处于闲置状态，它们无法自己组成三元环。而我们最多只能把图分成 $2n$ 个三元环，所以图上至少有 $n$ 个互不相交的三元环至少包含了 $2$ 个没有被暴力选到的点。那么在找到 $n$ 个三元环之前一定是还能继续调整的。

官解说有网络流做法。

---

## 作者：Kingna (赞：1)

首先第一想法，就是枚举三个顶点，但是因为会有重复的顶点干扰，所以需要写一个 dfs 回溯一些方案。

但是完全没必要！因为只需要求出一半的三角形，直接枚举三个顶点寻找，能找多少是多少，没必要回溯方案。因为若当前选择的三角形影响到后续选择，依然没关系，只需要保证最后能找到一半三角形即可，容错率非常大！

这样复杂度是 $O(6^3\times n^3)$，但是完全没关系，跑的非常快！其实还有优化空间，枚举第三个顶点时用前两个顶点的 bitset 并集即可。 

```cpp
while (1) {
  _for(i, 1, 6 * n) id[i] = i, vd[i] = 0;
  shuffle(id + 1, id + 6 * n + 1, rnd);
  vector<pair<int, pair<int, int>> > ans;
  _for(i, 1, 6 * n) {
    if (vd[id[i]]) continue;
    _for(j, i + 1, 6 * n) {
      if (vd[id[i]] || vd[id[j]] || !vis[{id[i], id[j]}]) continue;
      _for(k, j + 1, 6 * n) {
        if (vd[id[i]] || vd[id[j]] || vd[id[k]]) continue;
        if (!vis[{id[i], id[k]}] || !vis[{id[j], id[k]}]) continue;
        ans.push_back({id[i], {id[j], id[k]}});
        vd[id[i]] = vd[id[j]] = vd[id[k]] = 1;
        if (ans.size() == n) break;
      }
      if (ans.size() == n) break;
    }
    if (ans.size() == n) break;
  }
  if (ans.size() == n) {
    for (auto v : ans) cout << v.first << ' ' << v.second.first << ' ' << v.second.second << endl;
    break;
  } 
}
```

---

## 作者：zsfzhjf (赞：1)

前言：看到题解区没有解释官方题解的补一下

同样是去找三角形，看到其他题解都是打乱加点的顺序，而官方给的是，对一个已有三角形拆分成 $2$ 个新三角形

先按照顺序去找三角形，但不太可能恰好找到 $n$ 个，但是可以至少找到 $\lfloor \frac{2}{3} \cdot n \rfloor$ 个三角形，那么就相当于至少还有 $3 \cdot n$ 个点是还没有用的

若此时剩下的点还可构造出新三角形，那么就贪心的去构造

然后一共有 $2 \cdot n$ 个三角形与 $3 \cdot n$ 个未用的点，那么至少有 $n$ 个不相交的三角形是包含先前未用的 $2$ 个点

然后就可以去破环原有三角形，去同时构造 $2$ 个新三角形，这部分是 $O(n^3)$ 的。

```cpp
#include<bits/stdc++.h>
const int MAXN=1805;
int T,n,m,N;
std::vector <int> edge[MAXN],w_edge[MAXN][MAXN];//边所在三角形
std::vector <std::pair<int,int> > a_edge[MAXN];//每个点的可用边
bool is_edge[MAXN][MAXN],used[MAXN];
std::vector <std::vector<int> > ans;
inline void init(){
    ans.clear();
    for(int i=1;i<=N;i++) edge[i].clear(),a_edge[i].clear(),used[i]=0;
    for(int i=1;i<=N;i++) for(int j=1;j<=N;j++) is_edge[i][j]=0,w_edge[i][j].clear();
}
inline void add_edge(int u,int v,int w){
    if(!is_edge[u][w]||!is_edge[v][w]||!is_edge[u][v]) return;
    if(a_edge[w].size()>10) return;
    int du(0),dv(0);
    for(auto e:a_edge[w]){
        if(e.first==u||e.second==u) ++du;
        if(e.first==v||e.second==v) ++dv;
    }
    if(du>3||dv>3) return;
    a_edge[w].emplace_back(u,v);
    w_edge[u][v].emplace_back(w),w_edge[v][u].emplace_back(w);
}
inline void rem_edge(int u,int v){//选出三角形后将边去除
    for(auto w:w_edge[u][v])
        for(int i=0;i<a_edge[w].size();i++)
            if(a_edge[w][i]==std::pair <int,int> (u,v)||a_edge[w][i]==std::pair <int,int> (v,u)){
                std::swap(a_edge[w][i],a_edge[w].back());
                a_edge[w].pop_back();
                break;
            }
    w_edge[u][v].clear(),w_edge[v][u].clear();
}
inline void add_node(int u){
    used[u]=0;
    for(auto v:edge[u]) if(!used[v]) for(auto w:edge[v]) if(is_edge[u][w]) add_edge(u,v,w);
}
inline void rem_node(int u){//去除点
    used[u]=1;
    for(auto v:edge[u]) if(!used[v]) rem_edge(u,v);
}
inline void solve(){
    scanf("%d%d",&n,&m);
    N=6*n;//实际点数
    init();
    for(int i=1;i<=m;i++){
        int u,v;scanf("%d%d",&u,&v);
        edge[u].emplace_back(v),edge[v].emplace_back(u);
        is_edge[u][v]=is_edge[v][u]=1;
    }
    for(int i=1;i<=N;i++) for(auto j:edge[i]) for(auto k:edge[j]) add_edge(i,j,k);//预处理出每一条边可能属于哪个三角形，与点所可能被包含的对边
    for(int step=1;step<=n;step++){
        bool found(0);
        for(int i=1;i<=N;i++){
            if(used[i]||a_edge[i].empty()) continue;
            std::vector <int> tr={i,a_edge[i][0].first,a_edge[i][0].second};
            found=1;
            ans.emplace_back(tr);
            rem_node(tr[0]),rem_node(tr[1]),rem_node(tr[2]);
            break;
        }
        if(found) continue;//开始重组优化
        for(int t=0;t<ans.size();t++){
            if(found) break;
            for(int i=0;i<3;i++) for(int j=i+1;j<3;j++){
                if(found) break;
                int x=ans[t][i],y=ans[t][j],z=ans[t][3-i-j];
                for(auto e1:a_edge[x]) for(auto e2:a_edge[y]){
                    if(found) break;
                    if(e1.first==e2.first||e1.first==e2.second||e1.second==e2.first||e1.second==e2.second) continue;
                    add_node(z);
                    rem_node(e1.first),rem_node(e1.second),rem_node(e2.first),rem_node(e2.second);
                    std::vector <int> tr1={e1.first,e1.second,x},tr2={e2.first,e2.second,y};
                    ans[t]=tr1,ans.emplace_back(tr2);
                    found=1;
                }
            }
        }
    }
    for(auto it:ans) printf("%d %d %d\n",it[0],it[1],it[2]);
}
signed main(){
    scanf("%d",&T);
    while(T--) solve();
}
```

---

## 作者：ldll0721 (赞：0)

三级甲：瞎搞的不是正解（应该）（未证明正确性），建议还是去看正解。

首先考虑最暴力的想法：一个点一个的都去搜，搜到一个三元完全图就把这三个点删掉。但是会出现这样一种情况，就是删去的这个图影响了其他多个完全图，导致后续无法找出一个完整的三元完全图。

所以我们可以给先预处理出每个点的度数，排序一下再从度数小的点开始搜，并且在搜索图时进行一个判断，选择这个点所有图中度数之和最小的一个图，并把他们删去，这样尽可能的避免了影响图数过多。

但是如果这样写就会发生一个问题，可以发现，本题的数据范围 $1\le n,\sum n\le 300$，但是边的数量 $0\le m\le 10^6$,可得图中边的数量远远大于正常可出现边的数量。**所以必然会出现重边，而一个完全图是针对点来进行选的，而这些多余的边会严重影响我们的时间复杂度和度数大小的影响。**

**于是我们就可以通过在建边时通过去重边的方式来将边的最大值压缩至 $9\times10^4$。并且判断度数时不会因为重边影响方案，这样我们的正确性和运行时间就会极大地降低。**

然后这道紫题就这样被糊过去了（雾）。

**code：**

```
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define endl '\n'
#define maxn 2000005
int n, m, ms[maxn], cnt, h[maxn << 1], vis[maxn], tj, T,fir,sec,thi,minn,dt[maxn],mp[3005][3005];
struct node {
	int next, to;
} e[maxn << 2];
struct ans {
	int a, b, c;
} ed[maxn << 1];
struct val{
	int qz,id;
}du[maxn];
bool cmp(val x,val y){
	return x.qz<y.qz;
}
void add(int u, int v) {
	e[++cnt].to = v;
	e[cnt].next = h[u];
	h[u] = cnt;
}
void dfs(int u, int step, int fs, int se, int th) {
	if (step == 4) {
		if (u == fs) {
//			if (vis[fs] == 1 || vis[se] == 1 || vis[th] == 1)return;
//			ed[++tj] = {fs, se, th};
//			vis[fs] = vis[se] = vis[th] = 1;
            if(dt[fs]+dt[se]+dt[th]<minn){
				minn=dt[fs]+dt[se]+dt[th];
				fir=fs;sec=se;thi=th;
			}
		}
		return;
	}
	for (int i = h[u]; i; i = e[i].next) {
		int v = e[i].to;
		if ((v == fs || v == se) && (step != 3))continue;
		if (step == 1)dfs(v, step + 1, fs, v, th);
		if (step == 2)dfs(v, step + 1, fs, se, v);
		if(step==3)dfs(v,step+1,fs,se,th);
	}
}
signed main() {
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin >> T;
	while (T--) {
		memset(ed,0,sizeof(ed));
		cnt=0;tj=0;
		//memset(h,0,sizeof(h));
		//memset(vis,0,sizeof(vis));
		memset(e,0,sizeof(e));
		memset(du,0,sizeof(du));
		memset(mp,0,sizeof(mp));
		for(int i=0;i<=2000000;i++){
			vis[i]=0;
			h[i]=0;dt[i]=0;
		}
		cin >> n >> m;
		for (int i = 1; i <= m; i++) {
			int u, v;
			cin >> u >> v;
			if(mp[u][v]==1)continue;
			mp[u][v]=1;
			mp[v][u]=1;
			add(u, v);
			add(v, u);
			du[u].qz++;
			du[v].qz++;
			du[u].id=u;
			du[v].id=v;
		}
		sort(du+1,du+6*n+1,cmp);
		for(int i=1;i<=6*n;i++){
			dt[du[i].id]=du[i].qz;
		}
		for (int i = 1; i <= 6 * n; i++) {
			int id=du[i].id;
			fir=0,sec=0,thi=0,minn=2147483647;
			if(vis[id]!=1){
				dfs(id, 1, id, 0, 0);
				ed[++tj]={fir,sec,thi};
				vis[fir]=1;vis[sec]=1;vis[thi]=1;
			}
		}
		for (int i = 1; i <= n; i++) {
			cout << ed[i].a << " " << ed[i].b << " " << ed[i].c << endl;
		}
	}
	return 0;
}

```

---


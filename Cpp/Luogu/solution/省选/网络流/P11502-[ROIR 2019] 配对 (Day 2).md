# [ROIR 2019] 配对 (Day 2)

## 题目背景

翻译自 [ROIR 2019 D2T4](https://neerc.ifmo.ru/school/archive/2018-2019/ru-olymp-regional-2019-day2.pdf)。

## 题目描述

宇宙考古科学家在邻近星系的一颗行星上发现了 $n$ 件古代文物，并将它们编号为 $1$ 到 $n$。每件文物有 $k$ 个不同的参数，每个参数都是一个整数。文物 $i$ 的参数为 $a_{i, 1}, a_{i, 2}, \dots, a_{i, k}$。他们惊奇的发现，所有文物的第一个参数都是不同的，即对于所有 $i \neq j$，都有 $a_{i, 1} \neq a_{j, 1}$。但是，其他参数可能相同。

科学家们还发现了一段文字，根据这段文字，要激活文物，需要将它们按特定方案配对。称一个配对方案是有效的，当且仅当对于每个 $1\le t\le k$，可以确定一个数 $b_{t}$，使其在**每对文物**的第 $t$ 个参数值之间。也就是说，在这个配对方案中，对于所有配对的文物 $i$ 和 $j$，必须满足 $a_{i, t} \leq b_{t} \leq a_{j, t}$ 或 $a_{i, t} \geq b_{t} \geq a_{j, t}$。

现在，科学家们想知道这段文字是否解读正确。为此，你需要需要判断是否存在有效的配对方案，使得所有文物可以两两正确配对。如果可以，你还需要找到这样一个配对方案。

## 说明/提示

### 样例解释

样例 $1$ 中，一个合法的配对方案为 $(8, 6) - (3, 1), (1, 5) - (7, 2), (6, 3) - (4, 7)$。此时可以选择 $b_1=b_2=4$。

### 数据范围

数据中 Subtask 0 为样例。

| 子任务 | 分值 | 特殊性质 |
| :----------: | :----------: | :----------: |
| $1$ | $10$ | $n\le10$ |
| $2$ | $7$ | $k=1$ |
| $3$ | $15$ | 对于任意 $t$，所有 $a_{i,t}$ 互不相同 |
| $4$ | $15$ | $k\le2$ |
| $5$ | $26$ | $n\le400$ |
| $6$ | $27$ | 无特殊性质 |

对于 $100\%$ 的数据，$2\le n\le2\times10^5$，$n$ 为偶数，$1\le k\le7$，$|a_{i,j}|\le10^9$，所有 $a_{i,1}$ 互不相同。



## 样例 #1

### 输入

```
6 2
8 6
1 5
6 3
3 1
4 7
7 2```

### 输出

```
YES
1 4
2 6
3 5```

## 样例 #2

### 输入

```
4 3
1 -1 -1
2 1 1
3 -1 1
4 1 -1```

### 输出

```
NO```

# 题解

## 作者：Purslane (赞：1)

# Solution

关键观察：无论配对长啥样，$b_t$ 不变。因为他显然是 $a_{*,t}$ 的中位数。

因此我们已经可以将整张图分成一个二分图。

对于每个点，他实际上可以写成一个 $\{0,1,2\}^k$ 的向量——如果这一维是 $0$，表示 $a_{i,t} < b_t$，$1$ 表示 $a_{i,t} > b_t$，$2$ 表示 $a_{i,t}=b_t$。

两个点能不能匹配，只和它们的向量之间的关系有关——所以实际上可以用表示向量代替这个点。

这样很容易得到一个点数为 $O(3^k)$、边数为 $O(7^k)$ 的网络流模型。总复杂度为 $O(63^k)$（注意这里很难套用网络流求二分图最大匹配的 $O(m \sqrt n)$，因为边权不全是 $1$，所以有一步是过不去的。）

考虑把 $\{0,1,2\}^k$ 中的 $1$ 给替换为 $0$ 或 $2$，这一步的会产生 $O(4^k)$ 条边，左右部点之间的连边只有 $O(2^k)$ 条。这样做到了 $O(36^k)$（有点类似 P10717）。

但是，我实现了第一种，发现他过了，有没有老哥在评论区教一下复杂度分析啊 /kel

```cpp
#include<bits/stdc++.h>
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=2e5+10;
int n,k,a[MAXN][10],b[10],cnt[MAXN];
namespace F {
	const int MAXV=5000+10,MAXE=2e6+10,INF=1000000000;
	int s,t,dis[MAXV],hd[MAXV],cur[MAXV],tot=1;
	struct Edge {int to,nxt,f;}edge[MAXE];
	map<pair<int,int>,int> mp;
	void add_edge(int u,int v,int w) {
		edge[++tot]={v,hd[u],w},hd[u]=tot;
		edge[++tot]={u,hd[v],0},hd[v]=tot;
		mp[{u,v}]=tot;
		return ;
	}
	int bfs(void) {
		memset(dis,-1,sizeof(dis));
		queue<int> q;
		dis[s]=0,q.push(s);
		while(!q.empty()) {
			int u=q.front();
			q.pop();
			cur[u]=hd[u];
			for(int i=hd[u];i;i=edge[i].nxt) {
				int to=edge[i].to,f=edge[i].f;
				if(!f||dis[to]!=-1) continue ;
				dis[to]=dis[u]+1,q.push(to);
			}
		}
		return dis[t]!=-1;
	}
	int dinic(int u,int mx) {
		if(u==t) return mx;
		int ans=0;
		for(int i=cur[u];i;i=edge[i].nxt,cur[u]=i) {
			int to=edge[i].to,f=edge[i].f;
			if(!f||dis[to]!=dis[u]+1) continue ;
			int tmp=dinic(to,min(mx,f));
			if(tmp) {
				edge[i].f-=tmp,edge[i^1].f+=tmp,ans+=tmp,mx-=tmp;
				if(!mx) break ;
			}
			else dis[to]=-1;
		}
		return ans;
	}
	int max_flow(void) {
		int ans=0,tmp=0;
		while(bfs()) while(tmp=dinic(s,INF)) ans+=tmp;
		return ans;	
	}
}
vector<int> v[MAXN];
set<int> st,psl[MAXN];
int gain(int id) {
	int mul=0;
	vector<int> vc;
	ffor(i,1,k) {
		int op=-1;
		if(a[id][i]<b[i]) op=0;
		else if(a[id][i]==b[i]) op=1;
		else op=2;
		mul=mul*3+op,vc.push_back(op);
	}
	return v[mul]=vc,st.insert(mul),psl[mul].insert(id),mul;
}
int main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>n>>k;
	ffor(i,1,n) ffor(j,1,k) cin>>a[i][j],a[i][j]*=2;
	ffor(i,1,k) {
		vector<int> v;
		ffor(j,1,n) v.push_back(a[j][i]);
		v.push_back(-INT_MAX);
		sort(v.begin(),v.end());
		if(v[n/2]==v[n/2+1]) b[i]=v[n/2];
		else b[i]=v[n/2]+1;
	}
	F::s=0,F::t=pow(3,k)+1;
	ffor(i,1,n) cnt[gain(i)]++;
	for(auto id:st) if(v[id][0]==0) F::add_edge(F::s,id+1,cnt[id]); else F::add_edge(id+1,F::t,cnt[id]);
	for(auto id1:st) for(auto id2:st) if(v[id1][0]==0&&v[id2][0]!=0) {
		int flg=1;
		ffor(j,0,k-1) if(v[id1][j]==0&&v[id2][j]==0||v[id1][j]==2&&v[id2][j]==2) flg=0;
		if(flg) F::add_edge(id1+1,id2+1,F::INF);
	}
	if(F::max_flow()==n/2) cout<<"YES\n";
	else return cout<<"NO\n",0;
	for(auto id1:st) for(auto id2:st) if(v[id1][0]==0&&v[id2][0]!=0) {
		int flg=1;
		ffor(j,0,k-1) if(v[id1][j]==0&&v[id2][j]==0||v[id1][j]==2&&v[id2][j]==2) flg=0;
		if(flg) {
			int cnt=F::edge[F::mp[{id1+1,id2+1}]].f;
			ffor(tc,1,cnt) cout<<min(*psl[id1].begin(),*psl[id2].begin())<<' '<<max(*psl[id1].begin(),*psl[id2].begin())<<'\n',psl[id1].erase(psl[id1].begin()),psl[id2].erase(psl[id2].begin());
		}
	}
	return 0;
}
```

---

## 作者：modfish_ (赞：0)

## 思路
单独考虑某一维 $t$。把 $a_{1,t},a_{2,t},\dots,a_{n,t}$ 在数轴上表示出来，可以发现，如果 $b_t$ 已经确定，那么一定是 $b_t$ 左边的数和 $b_t$ 右边的数两两匹配。换言之，一定是这 $n$ 个数中，前 $\frac{n}{2}$ 小的和前 $\frac{n}{2}$ 大的两两匹配。

如果 $a_{1,t},a_{2,t},\dots,a_{n,t}$ 的中位数不在它们之间，那么前 $\frac{n}{2}$ 个数与后 $\frac{n}{2}$ 个数的划分是唯一的。不妨记录一个新的数组 $c_{i,j}$。若 $a_{i,t}$ 是这些数中前 $\frac{n}{2}$ 小的，那么 $c_{i,t}=0$；否则 $c_{i,t}=1$。那么实际上，如果序列 $c_x$ 与序列 $c_y$ 每一位上的值都不同（也就是异或值全为 $1$），那么 $x$ 和 $y$ 可以匹配。这时可以贪心地能匹配就匹配，然后就做完了。

然而，如果这些数的中位数在它们之间，那么前后的划分就不是唯一的。怎么办呢？

重新定义 $c_{i,j}$。若 $a_{i,t}$ 等于这些数的中位数，那么 $c_{i,t}=2$。

于是，如果序列 $c_x$ 与序列 $c_y$ 满足：对于任意一位 $i$，都有 $c_{x,i}=2$，或者 $c_{y,i}=2$，或者 $c_{x,i}\oplus c_{y,i}=1$，那么 $x$ 和 $y$ 可以匹配。也就是说，$2$ 可以代替 $0$ 或 $1$。

那么如何匹配成了问题。考虑到 $c_{i,1}$ 一定不为 $2$，不妨先按第一维将这 $n$ 个 $k$ 元组分成两半（$c_{i,1}=0$ 的放一边，$c_{i,1}=1$ 的放另一边）。然后把两边能够匹配的点连边。这又变成了一个二分图匹配问题。

然而，点数实在太多了。容易发现，对于某一个 $k$ 元组 $i$，决定它能与谁匹配的只有 $c_{i,2,\dots,k}$ 这个序列，而这个序列至多只有 $3^{k-1}$ 中。直接 $k$ 元组状压成一个序列即可。

那么不妨把这些序列视为点，左部和右部各 $3^{k-1}$ 个点，然后把左右之间可以匹配的点连边。问题变成了：每个点都有一个权值（也就是原来那个图中左、右部点状压后的序列为这个点的 $k$ 元组的数量），要求选出一些边，使得仅保留这些边时，每个点的度数恰好为它的权值。

首先，可以建一些中间点优化建图（把每个序列中的 $2$ 换成 $1$ 或 $0$，得到若干个 0-1 序列，然后左部每个点向它的 0-1 序列连边，右边每个点向它的 0-1 序列补集连边），把边数缩减到 $O(4^k)$。

然后不难想到网络流：源点向左部点连流量为对应点权值的边，右部点向汇点连流量为对应权值的边，中间的边流量为 $+\infty$，直接建图跑最大流就行了。如果最大流为 $\frac{n}{2}$，说明有解，根据残留网络构造解即可；否则，说明无解。

使用 Dinic 理论最坏复杂度为 $O(36^k)$，然而根本跑不满。用 HLPP 还可以做到 $O(18^k)$。总之可以过。

## 代码

```cpp
#include <bits/stdc++.h>

using namespace std;

const int maxn = 2e5 + 5, maxv = 730, maxk5 = 2e4 + 5;

int a[10][maxn], a2[10][maxn], val[maxn], ct[2][maxv], pos[maxn];
int id1[maxv], id2[maxv], id3[maxv];
int k, k2 = 1, k3 = 1;
int V;
namespace flow{
int n = 2, s = 1, t = 2;
int hd[maxv << 2], nxt[maxk5], to[maxk5], flow[maxk5], cnt = 1;
int head[maxv << 2], op[maxv << 2], inv[maxv << 2];
void match_flow(int u, int v, int w){
	nxt[++ cnt] = hd[u], to[cnt] = v, flow[cnt] = w, hd[u] = cnt;
}
void match(int u, int v, int w){
	match_flow(u, v, w), match_flow(v, u, 0);
}
void init(){
	for(int i = 0; i <= k2; i ++) id3[i] = ++ n;
	for(int i = 0; i <= k3; i ++){
		id1[i] = ++ n, op[n] = 1, inv[n] = i, id2[i] = ++ n, op[n] = 2, inv[n] = i;
		int i1 = i, c2 = 0, v = 0;
		for(int j = 0; j < k - 1; j ++){
			V = i1 % 3, i1 /= 3;
			if(V == 2) c2 |= (1 << j);
			if(V == 1) v |= (1 << j);
		}
		for(int s = 0; s <= k2; s ++){
			if((s | c2) != c2) continue;
			int v_ = v | s;
			match(id1[i], id3[v_], 1e9), match(id3[k2 ^ v_], id2[i], 1e9);
		}
		match(s, id1[i], ct[0][i]), match(id2[i], t, ct[1][i]);
	}
}
int dis[maxv << 2];
queue<int> q;
bool bfs(){
	q.push(s);
	for(int i = 1; i <= n; i ++) dis[i] = -1, head[i] = hd[i];
	dis[s] = 0;
	while(!q.empty()){
		int x = q.front();
		q.pop();
		for(int i = head[x]; i; i = nxt[i]){
			int j = to[i];
			if(dis[j] != -1 || !flow[i]) continue;
			dis[j] = dis[x] + 1;
			q.push(j);
		}
	}
	return dis[t] != -1;
}
int dfs(int x, int fl){
	if(x == t || !fl) return fl;
	int now = 0;
	for(int &i = head[x]; i; i = nxt[i]){
		int j = to[i];
		if(dis[j] != dis[x] + 1) continue;
		int nw = dfs(j, min(fl - now, flow[i]));
		now += nw, flow[i] -= nw, flow[i ^ 1] += nw;
		if(now == fl) return now;
	}
	return now;
}
int Dinic(){
	int ans = 0;
	while(bfs()) ans += dfs(s, 2e9);
	return ans;
}}
stack<int> s1[maxv], s2[maxv];
int st[maxn], tp = 0;

int main(){
	int n;
	scanf("%d %d", &n, &k);
	for(int i = 1; i <= n; i ++) for(int j = 1; j <= k; j ++) scanf("%d", &a[j][i]), a2[j][i] = a[j][i];
	for(int j = 1; j <= k; j ++) sort(a2[j] + 1, a2[j] + n + 1), k2 *= 2, k3 *= 3;
	k2 /= 2, k3 /= 3;
	k2 --, k3 --;
	int mid = n / 2;
	for(int i = 1; i <= n; i ++){
		if(a[1][i] <= a2[1][mid]) pos[i] = 0;
		else pos[i] = 1;
		for(int j = 2; j <= k; j ++){
			if(a2[j][mid] == a2[j][mid + 1]){
				if(a[j][i] < a2[j][mid]) val[i] = val[i] * 3;
				else if(a[j][i] > a2[j][mid]) val[i] = val[i] * 3 + 1;
				else val[i] = val[i] * 3 + 2;
			}else{
				if(a[j][i] <= a2[j][mid]) val[i] = val[i] * 3;
				else val[i] = val[i] * 3 + 1;
			}
		}
		ct[pos[i]][val[i]] ++;
		if(pos[i] == 0) s1[val[i]].push(i);
		else s2[val[i]].push(i);
	}
	flow::init();
	int res = flow::Dinic();
	if(res != n / 2) printf("NO\n");
	else{
		printf("YES\n");
		for(int y = 0; y <= k2; y ++){
			int x = id3[y];
			int now = 1;
			for(int i = flow::head[x]; i; i = flow::nxt[i]){
				int j = flow::to[i];
				if(flow::op[j] == 1){
					int c = flow::flow[i], d = flow::inv[j];
					if(!tp) now = 1;
					if(now == 1){
						while(c) st[++ tp] = s1[d].top(), s1[d].pop(), c --;
					}else{
						while(tp && c) printf("%d %d\n", s1[d].top(), st[tp]), tp --, s1[d].pop(), c --;
						if(c){
							now = 1;
							while(c) st[++ tp] = s1[d].top(), s1[d].pop(), c --;
						}
					}
				}else{
					int c = flow::flow[i ^ 1], d = flow::inv[j];
					if(!tp) now = 2;
					if(now == 2){
						while(c) st[++ tp] = s2[d].top(), s2[d].pop(), c --;
					}else{
						while(tp && c) printf("%d %d\n", st[tp], s2[d].top()), tp --, s2[d].pop(), c --;
						if(c){
							now = 2;
							while(c) st[++ tp] = s2[d].top(), s2[d].pop(), c --;
						}
					}
				}
			}
		}
	}
	return 0;
}
```

---


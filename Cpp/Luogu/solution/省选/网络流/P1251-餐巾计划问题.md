# 餐巾计划问题

## 题目描述

一个餐厅在相继的 $N$ 天里，每天需用的餐巾数不尽相同。假设第 $i$ 天需要 $r_i$ 块餐巾（$i = 1, 2, \dots, N$）。餐厅可以购买新的餐巾，每块餐巾的费用为 $p$ 分；或者把旧餐巾送到快洗部，洗一块需 $m$ 天，其费用为 $f$ 分；或者送到慢洗部，洗一块需 $n$ 天（$n \gt m$），其费用为 $s$ 分（$s \lt f$）。

每天结束时，餐厅必须决定将多少块脏的餐巾送到快洗部，多少块餐巾送到慢洗部，以及多少块保存起来延期送洗。但是每天洗好的餐巾和购买的新餐巾数之和，要满足当天的需求量。

试设计一个算法为餐厅合理地安排好 $N$ 天中餐巾使用计划，使总的花费最小。编程找出一个最佳餐巾使用计划。


## 说明/提示

对于 $100 \%$ 的数据，$1 \le N \le 2 \times 10^3$，$1 \le r_i \le 10^7$，$1 \le p, f, s \le 10^4$。


## 样例 #1

### 输入

```
3
1 7 5 
11 2 2 3 1
```

### 输出

```
134
```

# 题解

## 作者：Mark_ZZY (赞：199)

### 关于构图：

这是一道最小费用（费用指单价）最大流的题目。

首先，我们拆点，将一天拆成晚上和早上，每天晚上会受到脏餐巾（来源：当天早上用完的餐巾，在这道题中可理解为从原点获得），每天早上又有干净的餐巾（来源：购买、快洗店、慢洗店）。

1.从原点向每一天晚上连一条流量为当天所用餐巾x，费用为0的边，表示每天晚上从起点获得x条脏餐巾。

2.从每一天早上向汇点连一条流量为当天所用餐巾x，费用为0的边，每天白天,表示向汇点提供x条干净的餐巾,流满时表示第i天的餐巾够用 。
3.从每一天晚上向第二天晚上连一条流量为INF，费用为0的边，表示每天晚上可以将脏餐巾留到第二天晚上（注意不是早上，因为脏餐巾在早上不可以使用）。

4.从每一天晚上向这一天+快洗所用天数t1的那一天早上连一条流量为INF，费用为快洗所用钱数的边，表示每天晚上可以送去快洗部,在地i+t1天早上收到餐巾 。

5.同理，从每一天晚上向这一天+慢洗所用天数t2的那一天早上连一条流量为INF，费用为慢洗所用钱数的边，表示每天晚上可以送去慢洗部,在地i+t2天早上收到餐巾 。

6.从起点向每一天早上连一条流量为INF，费用为购买餐巾所用钱数的边，表示每天早上可以购买餐巾 。
注意，以上6点需要建反向边！3~6点需要做判断（即连向的边必须<=n）

### 关于代码：
```cpp
#include<cstdio>
#include<queue>
#include<cstring>
#include<queue>
#include<algorithm>
#define INF 2147483647
#define LL long long
using namespace std;
queue<int> f;
	int n,m,m1,t1,m2,t2,len=-1,st,ed;
	struct node{int x,y,c,d,next;} a[100000];
	int b[100000],last[100000],pre[100000],pos[100000],p[100000];
	LL dis[100000];
	bool bz[100000];
void ins(int x,int y,int c,int d)
{
	a[++len].x=x;a[len].y=y;a[len].c=c;a[len].d=d;a[len].next=last[x];last[x]=len;
	a[++len].x=y;a[len].y=x;a[len].c=0;a[len].d=-d;a[len].next=last[y];last[y]=len;
}
bool spfa()
{
	memset(bz,true,sizeof(bz));
	bz[st]=false;
	memset(dis,63,sizeof(dis));
	dis[st]=0;
	p[st]=INF;
	f.push(st);
	while(!f.empty())
	{
		int x=f.front();
		bz[x]=true;
		for(int i=last[x];i>-1;i=a[i].next)
		{
			int y=a[i].y;
			if(a[i].c>0&&dis[y]>dis[x]+a[i].d)
			{
				dis[y]=dis[x]+a[i].d;
				pos[y]=x;
				pre[y]=i;
				p[y]=min(p[x],a[i].c);
				if(bz[y])
				{
					f.push(y);
					bz[y]=false;
				}
			}
		}
		f.pop();
	}
	return dis[ed]<4557430888798830399;
}
LL flow()
{
	LL ans=0;
	while(spfa())
	{
		ans+=p[ed]*dis[ed];
		for(int i=ed;i!=st;i=pos[i])
		{
			a[pre[i]].c-=p[ed];
			a[pre[i]^1].c+=p[ed];
		}
	}
	return ans;
}
int main()
{
	int x;
	scanf("%d",&n);
	st=0,ed=2*n+1;
	memset(last,-1,sizeof(last)); 
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&x);
		ins(st,i,x,0);//每天晚上从起点获得x条脏餐巾 
		ins(i+n,ed,x,0);//每天白天,向汇点提供x条干净的餐巾,流满时表示第i天的餐巾够用 
	}
	scanf("%d %d %d %d %d",&m,&t1,&m1,&t2,&m2);
	for(int i=1;i<=n;i++)
	{
		if(i+1<=n) ins(i,i+1,INF,0);//每天晚上可以将脏餐巾留到第二天晚上 
		if(i+t1<=n) ins(i,i+n+t1,INF,m1);//每天晚上可以送去快洗部,在地i+t1天早上收到餐巾 
		if(i+t2<=n) ins(i,i+n+t2,INF,m2);//每天晚上可以送去慢洗部,在地i+t2天早上收到餐巾 
		ins(st,i+n,INF,m);//每天早上可以购买餐巾 
	}
	printf("%lld",flow());
}
```

---

## 作者：天泽龟 (赞：142)

从上到下翻完所有题解，虽然大多数都清楚地说明了**如何去建图**，但没有一篇去解释**为什么要这样建图**。况且建图时候很多奇奇怪怪的小细节并不符合常规的思路，如果没有真正去弄懂它，即使这道题水过，考场上也不会想清楚的。

## 本篇题解将充分，全面地来解释建图的过程，以及其中的诸多细节。也欢迎各位指出其中不足。


拿到题后~~根据标签~~大体上可以判断出这是一个最小费用流。题目中有一段这样说道：

	每天结束时,餐厅必须决定将多少块脏的餐巾送到快洗部,多少块餐巾送到慢洗部,以及多少块保存起来延期送洗。
    但是每天洗好的餐巾和购买的新餐巾数之和,要满足当天的需求量。
    
于是整理得，我们需要支持以下操作：
 
 - 将脏餐巾以`f元/条`送到快洗部，过m天后，干净餐巾送回来使用
 - 将脏餐巾以`s元/条`送到慢洗部，过n天后，干净餐巾送回来使用
 - 延期送洗（可能会出现之后餐巾需求过少，并不需要所有餐巾的情况）
 - 以`p元/条`购买新的餐巾
 
### 于是本题第一个难点就来了：如何处理脏餐巾和干净餐巾？

我们可以想到，每天开始的时候只有干净的餐巾可使用，每天结束的时候仅有脏的餐巾需要操作。**于是将每天拆成两个点：起始点与结束点**，分别处理不同时间段所需操作。

于是也可以想到：
 - 送到快洗部属于结束点操作，连向`i+m`天后的起始点，费用为f（表示餐巾洗好了，可使用）
 - 送到慢洗部属于结束点操作，连向`i+n`天后的起始点，费用为s
 - 延期送洗属于结束点操作，连向`i+1`的结束点，不需费用。
 - 购买新的餐巾的操作也应是连向每天起始点 的边，目前并没有确定从哪连的，但费用为p。
 

以上操作流量均为$inf$.

好了，到这里你有没有发现以上操作有什么共同点？

### 没错，他们都是连向起始点的有向边！
$\color{red} update: \text{延期送洗的操作应连向的是结束点，}$
$\color{red} \text{感谢}$ $Specialzyy$ $\color{red} \text{指出错误。}$

$\color{red} update: \text{话虽如此，但此题没有从起始点向外连的边，仍满足线性。}$



事实上，网络流24题的全称为“网络流与线性规划24题”，这也就告诉我们：  **网络流的建图一定有顺序的，建的边一定是沿源点流向汇点，否则图就会不流通。**

所以现在我们就弄明白了：我们应该将源点连接每天的**结束点**，而不是他们的起始点；起始点连向他们的汇点，容量为这天所需的餐巾数量，费用为0。

此外购买餐巾直接从源点购买即可。

---

之后跑一个裸的费用流即可。上我丑陋的代码：

```cpp
#include <iostream>
#include <cstring>
#include <queue>
#define N 2*n+1
#define inf 2147483647
using namespace std;

struct ed{
	int u,next,w,f;
}e[300000];
long long n,p,b,f,a,s,st=1,cost,ans;
int r[100000],d[100000],fir[100000],c[100000];
queue<int> q; bool v[100000];

bool spfa()
{
	for (int i=0;i<=N;i++) d[i]=inf/2,v[i]=0,c[i]=fir[i];
	q.push(0); v[0]=1; d[0]=0;
	while (!q.empty())
	{
		int k=q.front(); q.pop(); v[k]=0;
		for (int i=fir[k];i;i=e[i].next)
		{
			int u=e[i].u,w=e[i].f;
			if (d[u]>d[k]+w&&e[i].w)
			{
				d[u]=d[k]+w; if (!v[u]) v[u]=1,q.push(u); 
			} 
		}
	}
	return (d[N]<inf/2);
}

int dfs(int p,int now)
{
	if (p==N) {
		v[N]=1; ans+=now; return now;
	}
	int mw=0,used=0;  v[p]=1;
	for (int i=c[p];i;i=e[i].next){
		c[p]=1; int u=e[i].u,w=e[i].f;
		if ((!v[u]||u==N)&&d[u]==d[p]+w&&e[i].w)
		if (mw=dfs(u,min(now-used,e[i].w)))
		{
			e[i].w-=mw; e[i^1].w+=mw; used+=mw;
			cost+=w*mw; if (used==now) break;
		}
	}
	return used;
}

long long dinic()
{
	while (spfa())
	{
		v[N]=1;
		while (v[N])
		{
			memset(v,0,sizeof(v));
			dfs(0,inf);
		}
		
	}
	return cost;
}

void add(int x,int y,int w,int f)
{
	e[++st].u=y; e[st].next=fir[x]; e[fir[x]=st].w=w; e[st].f=f;
	e[++st].u=x; e[st].next=fir[y]; e[fir[y]=st].w=0; e[st].f=-f;
	
}

int main()
{
	cin>>n;
	for (int i=1;i<=n;i++) {
		cin>>r[i];
		add(0,i,r[i],0); add(i+n,N,r[i],0);
        //源点连接结束点，起始点连向他们的汇点。
	}
	cin>>p>>a>>f>>b>>s;
	for (int i=1;i<=n;i++)
	{
		add(0,i+n,inf,p);  //从源点购买餐巾
		if (i+1<=n) add(i,i+1,inf,0);   //把今天的脏毛巾拖到明天 
		if (i+a<=n) add(i,i+n+a,inf,f); //把餐巾送到快洗部
		if (i+b<=n) add(i,i+n+b,inf,s); //把餐巾送到慢洗部
	}
    //可以注意到，以上的连边均是由源点向汇点的。
	cout<<dinic()<<endl;
} 
```


---

## 作者：SCKer (赞：42)

怎么就没人来份贪心的题解呢？

~~夹在网络流大佬中的蒟蒻瑟瑟发抖~~

------------

# 分析
费用流的解法是有的，然而效率太低（ ~~不会~~ /逃）。为何不考虑贪心呢。

**贪心**：

假设我们已经确定了一共要买的餐巾数，那么，就可考虑用贪心求出最小的费用了。

对于每天需要的餐巾，一共有一下三种来源：
1. 未用过的餐巾：已经买了，免费
2. 前面慢洗出来的餐巾：
越早越好（留给后面的慢洗）
3. 前面快洗出来的餐巾：
越晚越好（尽可能留给慢洗）

根据题目的条件，可以保证其费用是递增的。

至于实现，只需要记录每一天能够用来换洗的餐巾数即可。

**三分**：

至于如何确定要买的餐巾数，枚举是一定$OK$的，只不过效率太低。我们可以猜测一下餐巾数与最小费用之间的关系，应该近似单谷函数

只有感性的认识：若餐巾数过小，则会无解，可视为无穷大；若餐巾数过多，则无需换洗餐巾，但换洗餐巾必定比不换洗要优。

于是，就愉快的三分吧（三分和二分差不多，随便看看就行了）。

-------------
# 代码
```cpp
#include <cstdio>
#include <cstdlib>
#include <cstring>

#define IL inline
#define ll long long

using namespace std;

const int maxn = 2000 + 5;
const ll INF = 0xfffffffffffff; //ans比较大，注意无穷大的取值

IL int read()
{
    char c = getchar();
    int sum = 0 ,k = 1;
    for(;'0' > c || c > '9'; c = getchar())
        if(c == '-') k = -1;
    for(;'0' <= c && c <= '9'; c = getchar()) sum = sum * 10 + c - '0';
    return sum * k;
}

int n;
int t1, t2;
ll p0, p1, p2;
int need[maxn], num[maxn];
//需要的餐巾数  ，  每天可换洗的餐巾数
IL ll min_(ll x, ll y) { return x < y ? x : y; }

IL ll check(ll rest)
{
    memset(num, 0, sizeof(num));
    int tp = 1;
    ll price = rest * p0; //先买下来
    for(int t = 1, k, ned; t <= n; ++t)
    if(need[t])
    {
        ned = need[t];
        if(rest)//如果有剩余
        {
            k = min_(ned, rest);
            rest -= k;
            num[t] += k;
            ned -= k;
            if(!ned) continue;
        }
        
        for(; tp < t && !num[tp]; ++tp);//算是一个优化，找到最早的能换洗餐巾的时间
        for(int i = tp; i <= t - t2; ++i)//慢洗，从前往后
        if(num[i])
        {
            k = min_(ned, num[i]);
            num[i] -= k;
            num[t] += k;
            price += k * p2;
            ned -= k;
            if(!ned) continue ;
        }
        for(int i = t - t1; i >= 1 && i > t - t2; --i)//快洗， 从后往前
        if(num[i])
        {
            k = min_(ned, num[i]);
            num[i] -= k;
            num[t] += k;
            price += k * p1;
            ned -= k;
            if(!ned) continue;
        }
        if(ned) return INF; //如果能用的都用上了，但还是满足不了条件，那就无解了
    }
    return price;
}

int main()
{
    ll l = 0, r = 0;
    n = read();
    for(int i = 1; i <= n; ++i) { need[i] = read(); r += need[i]; }、
    //头痛，解释不了
    p0 = read(); t1 = read(); p1 = read(); t2 = read(); p2 = read();
    l = need[1];
    //标准式三分
    for(ll k, lmid, rmid, s1, s2;l + 2 < r;)
    {
    	k = (r - l) / 3;
    	lmid = l + k;
    	rmid = r - k;
    	if(check(lmid) >= check(rmid)) l = lmid; else r = rmid;
    }
    ll ans = check(l);
    for(++l;l <= r; ++l)
        ans = min_(ans, check(l));
    printf("%lld", ans);
    return 0;
}
```

---

## 作者：echo6342 (赞：30)

网络流24题中，存在各种只是来让人练写模板熟练度的题。不过这题的建图方式算是一股清流，让人很不好想，但想到了也很不好证明，不过证明出来后真的很好写。


对于送到快洗部、慢洗部、直接购买都很好想，拆点后直接连就行了。也就是把一天拆成上午和下午两个点，上午可以接受洗完的餐巾、买新餐巾，下午可以把餐巾送去洗。也就是说，上午的“流”的意义是干净的餐巾，下午的“流”的意义是脏的餐巾。


让第i天“经过”汇点的流为ri显然是行不通的。可以把“拿去用ri个餐巾”拆成两个动作：上午把ri个干净的餐巾给汇点，下午接收从源点来的ri个脏餐巾。


还要注意的是，餐厅里可以攒干净的餐巾，所以第i天上午要连一条边到第i+1天上午。


以上过程其实可以用有上下界网络流来思考，但并不对劲的人并不想这么做。





```cpp
#include<iostream>
#include<iomanip>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<queue>
#define ll long long
#define maxn 4010
#define maxm 2000010
using namespace std;
const ll inf=0x7fffffff;
ll fir[maxn],nxt[maxm],v[maxm],fl[maxm],w[maxm],cnt;
ll mincost,n,m,p,f,s,N,dis[maxn];
bool vis[maxn];
ll read()
{
    ll x=0,f=1;
    char ch=getchar();
    while(isdigit(ch)==0 && ch!='-')
        ch=getchar();
    if(ch=='-')f=-1,ch=getchar();
    while(isdigit(ch))x=x*10+ch-'0',
        ch=getchar();
    return x*f;
}
void addedge(ll u1,ll v1,ll fl1,ll w1)
{
    w[cnt]=w1,v[cnt]=v1,fl[cnt]=fl1,nxt[cnt]=fir[u1],fir[u1]=cnt++;
    w[cnt]=-w1,v[cnt]=u1,fl[cnt]=0,nxt[cnt]=fir[v1],fir[v1]=cnt++;
}
ll spfa() 
{
    memset(dis,-1,sizeof(dis));
    memset(vis,0,sizeof(vis));
    dis[N*2+1]=0;
    deque<ll >q;
    q.push_back(N*2+1);
    while(!q.empty())
    {
        ll u=q.front();q.pop_front();
        for(ll k=fir[u];k!=-1;k=nxt[k])
        {
            ll vv=v[k];
            if(fl[k^1]>0)
            {
                if(dis[vv]>dis[u]-w[k] 
                || dis[vv]==-1)
                {
                    dis[vv]=dis[u]-w[k];
                    if(vis[vv]==0)    
                    {
                        if(q.empty()==0&&
                        dis[q.front()]>dis[vv])
                            q.push_front(vv);
                        else
                            q.push_back(vv);
                    }    
                    vis[vv]=1;
                }
            }
        }
        vis[u]=0;
    }
    return dis[0];
}
ll getfl(ll u,ll nowflow)
{
    vis[u]=1;
    if(u==N*2+1)return nowflow;
    ll tmp,sum=0;
    for(ll k=fir[u];k!=-1;k=nxt[k])
    {
        if(nowflow<=0)break;
        ll vv=v[k];
        if(vis[vv]==0 && fl[k]>0 
        && dis[vv]+w[k]==dis[u]&&
        (tmp=getfl(vv,min(nowflow,fl[k])))>0)
        {
            fl[k]-=tmp;
            fl[k^1]+=tmp;
            nowflow-=tmp;
            mincost+=tmp*w[k];
            sum+=tmp;
        }
     } 
    return sum;
}
int main()
{
    memset(fir,-1,sizeof(fir));
    N=read();
    for(ll i=1;i<=N;i++)
    {
        ll r=read();
        addedge(i,N*2+1,r,0);
        addedge(0,i+N,r,0);
    }
    p=read(),m=read(),f=read(),n=read(),s=read();
    for(ll i=1;i<=N;i++)
    {
        addedge(0,i,inf,p);
        if(i+m<=N)addedge(i+N,i+m,inf,f);
        if(i+n<=N)addedge(i+N,i+n,inf,s);
        if(i+1<=N)addedge(i,i+1,inf,0);
    }
    while(spfa()!=-1)
    {
        memset(vis,0,sizeof(vis));
        getfl(0,0x7fffffff);
    }
    cout<<mincost;
    return 0;
}
```
ex1：如果n<=2 \* 10^5，ri<=100该怎么做？

其实可以三分购买的毛巾总数，然后贪心地算出是否可行。


假设购买的毛巾总数是给定的，那么这道题就变得简单多了。在第x天将毛巾送去洗，到第x+m或x+n天才能用，这件事可以看成在第x天毛巾不够用时，花s或f乘坐时光机回到第x-n或x-m天，将毛巾变成干净的带回来。对于前面的若干天，新买的毛巾不用白不用，尽量把新买的用完。新毛巾不够用时考虑回到之前的某一天。这时肯定回到x-n或再之前的时间更划算。因为x-m及以前可以用慢洗，花费少。如果x-m天及之前没有脏毛巾了，才去第x-n到x-m天之间。这时最好取离现在更近的。这样可以让离现在更远的时间，也就是离第x-m天更近的时间，更有机会慢洗。这个过程可以用双端队列维护。


根据这个策略，对于每一个购买的毛巾总数c，都有唯一确定的总费用与之对应。因此定义f(c)为总共购买c块毛巾的费用。注意c的取值范围应该是大于某个数，因为新毛巾总数太少的时候有些天会没毛巾可用。


三分法要保证单峰。感性地想，c较小时要频繁地使用快洗，所以花在洗毛巾上的费用会很大。而c较大时购买毛巾的费用会很大。


理性地想，并不对劲的人并不理性。


设ri之和为R，这样就可以做到时间复杂度O(n log R)了呢。


 

ex2：在ex1的条件下，若快洗店更便宜，该怎么办？


那就别慢洗了。


 

是贪心能解所有网络流问题，还是网络流能解所有贪心问题呢（就是时间复杂度……）？


---

## 作者：GoPoux4 (赞：20)

最小费用最大流。

---

#### 建模

先只考虑买入餐巾，也就是不考虑送洗，不难得到一下建模方法：

将每天抽象成一个点 $i$，与汇点 $t$ 连边，容量为 $r_i$ ，费用为 $0$，代表每天需要 $r_i$ 条餐巾。由源点 $s$ 向每天连边，容量为 $\infty$，费用为 $p$，代表买入餐巾。得到下面的网络 $G$：

![aus4l8.png](https://s1.ax1x.com/2020/07/30/aus4l8.png)

发现这个图缺少信息，我们需要把送洗的信息加入图中：

对于每一天，再建一个点 $i'$，由源点 $s$ 向其连边，容量为 $r_i$，代表每天产生了 $r_i$ 条脏餐巾。若可以送洗，则连边 $i' \to (i+k)$ ，其中 $k$ 代表快洗或慢洗所需的天数，容量为 $\infty$，费用为此次送洗的费用。由于可以延迟送洗，连接 $i' \to (i+1)'$，容量 $\infty$。得到下面的网络 $G'$：

![aucmod.png](https://s1.ax1x.com/2020/07/30/aucmod.png)

在 $G'$ 上跑最小费用最大流即可。

---

$\text{Code}:$

```cpp
#pragma GCC target("avx")
#include <iostream>
#include <cstring>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <queue>
#define maxn 5005
#define maxm 500005
#define R register
#define INF 0x3f3f3f3f
using namespace std;
typedef long long lxl;

inline lxl read()
{
	lxl x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9') {if(ch=='-') f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9') {x=(x<<1)+(x<<3)+ch-'0';ch=getchar();}
	return x*f;
}

struct edge
{
	int v;
	lxl cp,w;
	int next;
}e[maxm<<1];

int head[maxn],k;

inline void add(int u,int v,lxl cp,lxl w)
{
	e[k]=(edge){v,cp,w,head[u]};
	head[u]=k++;
	e[k]=(edge){u,0,-w,head[v]};
	head[v]=k++;
}

int n,s,t;
lxl dis[maxn],flw[maxn],mincost,maxflow;
int pre[maxn];
bool vis[maxn];

inline bool SPFA()
{
	queue<int> q;
	memset(dis,-1,sizeof(dis));
	memset(vis,false,sizeof(vis));
	dis[s]=0;
	flw[s]=INF;
	vis[s]=true;
	pre[s]=-1;
	q.push(s);
	while(!q.empty())
	{
		int u=q.front();q.pop();
		vis[u]=false;
		for(int i=head[u];~i;i=e[i].next)
		{
			int v=e[i].v;
			if(!e[i].cp) continue;
			if(!~dis[v]||dis[v]>dis[u]+e[i].w)
			{
				dis[v]=dis[u]+e[i].w;
				flw[v]=min(flw[u],e[i].cp);
				pre[v]=i;
				if(!vis[v]) q.push(v),vis[v]=true;
			}
		}
	}
	return ~dis[t];
}

inline void update()
{
	for(int i=pre[t];~i;i=pre[e[i^1].v])
	{
		e[i].cp-=flw[t];
		e[i^1].cp+=flw[t];
	}
	maxflow+=flw[t];
	mincost+=dis[t]*flw[t];
}

int main()
{
	// freopen("P1251.in","r",stdin);
	n=read();
	memset(head,-1,sizeof(head));
	s=1,t=(n<<1)+2;
	for(int i=1;i<=n;++i)
	{
		int ri=read();
		add(i<<1|1,t,ri,0);
		add(s,i<<1,ri,0);
	}
	int P=read(),M=read(),F=read(),N=read(),S=read();
	for(int i=1;i<=n;++i)
	{
		add(s,i<<1|1,INF,P);
		if(i+1<=n) add(i<<1,(i+1)<<1,INF,0);
		if(i+M<=n) add(i<<1,(i+M)<<1|1,INF,F);
		if(i+N<=n) add(i<<1,(i+N)<<1|1,INF,S);
	}
	while(SPFA())
		update();
	printf("%lld\n",mincost);
	return 0;
}
```


---

## 作者：longlongzhu123 (赞：17)

*时间：2019.3.19*

**网络流24题**：【餐巾计划问题】

## 题目描述

一个餐厅在相继的 $N$ 天里,每天需用的餐巾数不尽相同。假设第 $i$ 天需要 $r_i$ 块餐巾($i=1,2,...,N$)。餐厅可以购买新的餐巾,每块餐巾的费用为 $p$ 分;或者把旧餐巾送到快洗部,洗一块需 $a$ 天,其费用为 $f$ 分;或者送到慢洗部,洗一块需 $b$ 天($b>a$),其费用为 $s$ 分($s < f$)。

每天结束时,餐厅必须决定将多少块脏的餐巾送到快洗部,多少块餐巾送到慢洗部,以及多少块保存起来延期送洗。但是每天洗好的餐巾和购买的新餐巾数之和,要满足当天的需求量。

试设计一个算法为餐厅合理地安排好 $N$ 天中餐巾使用计划,使总的花费最小。编程找出一个最佳餐巾使用计划。

## 建图（1）

考虑建出下面这张图：

![](https://cdn.luogu.com.cn/upload/pic/54489.png)

将每天当成一个点，根据当天的餐巾是否已使用，拆成**前**和**后**。  
$S$向**前**连边，费用为$p$，表示可以任意买新餐巾  
**前**向**后**连边，容量为$r_i$，表示需要使用$r_i$条餐巾。  
第$N$个**后**向$T$连边，容量为$\sum r_i$，表示需要将所有餐巾用掉。  
每天**后**向$a$天后的**前**连边，费用为$s$，表示送到快洗部（慢洗部同理）

------

这样，我们只需要控制流向**后**的流量均为$r_i$就行了。

但是，这样就出现一个问题：**我们没办法控制流向后的流量刚好流满呀？**

看来我们要改变建图方式了。

## 建图（2）

建出下面这张图：

![](https://cdn.luogu.com.cn/upload/pic/54490.png)


将每天当成一个点，根据当天的餐巾是否已使用，拆成**前**和**后**。  
$S$向**前**连边，费用为$p$，表示可以任意买新餐巾。  
**前**向$T$连边，容量为$r_i$，**表示要消耗$\textbf{r}_\textbf{i}$条餐巾。**  
$S$向**后**连边，容量为$r_i$，**表示收到用前产生的$\textbf{r}_\textbf{i}$条旧餐巾**。  
每天**后**向$a$天后的**前**连边，费用为$s$，表示送到快洗部（慢洗部同理）

------

这样建图意味着**前**的流与**后**的流意义不同。  
从$S$（或几天前的**后**）流向**前**的流表示能使用的新餐巾，  
而从$S$流向**后**的流表示使用后留下的$r_i$条旧餐巾。

我们控制了从**前**流出的餐巾（即使用数量）为$r_i$，而流进**后**的餐巾数量刚好为$r_i$

## 代码

注意上面没有讲到的一点：使用前多余的干净餐巾可以留到明天再使用。  
将今天的**前**向明天的**前**连边即可。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int kMaxN = 2000 * 2 + 10;
const int kMaxM = kMaxN * 4;
const int kInf = 4e18;
struct Graph {
  struct Arc {
    int to, cap, cost;
    int next;
  };
  Arc arcs[kMaxM << 1];
  int top, head[kMaxN];
  Graph() { top = 1; }
  void Add(int u, int v, int cap, int cost) {
    arcs[++top] = (Arc) {v, cap, cost, head[u]};
    head[u] = top;
    arcs[++top] = (Arc) {u, 0, -cost, head[v]};
    head[v] = top;
  }
  int s, t;
  queue<int> Q;
  bool in[kMaxN];
  int cost[kMaxN], flow[kMaxN], last[kMaxN];
  bool Spfa() {
    memset(flow, 0, sizeof(flow));
    memset(last, 0, sizeof(last));
    memset(cost, 0x7F, sizeof(cost));
    // 不用memset flow和last
    // 这两个数组不参与最短路计算
    // 一定要写flow[t] = 0
    // 如果有负环一定要写memset(in)
    Q.push(s);
    cost[s] = 0;
    flow[s] = kInf;
    flow[t] = 0; // !!!
    while (!Q.empty()) {
      int u = Q.front();
      Q.pop();
      in[u] = false;
      for (int i = head[u]; i; i = arcs[i].next) {
        Arc& arc = arcs[i];
        int v = arc.to;
        if (cost[u] + arc.cost < cost[v] && arc.cap) {
          cost[v] = cost[u] + arc.cost;
          flow[v] = min(flow[u], arc.cap);
          last[v] = i;
          if (!in[v]) {
            in[v] = true;
            Q.push(v);
          }
        }
      }
    }
    return flow[t] != 0;
  }
  int max_flow, min_cost;
  void Update() {
    int u = t;
    while (u != s) {
      int i = last[u];
      arcs[i].cap -= flow[t];
      arcs[i ^ 1].cap += flow[t];
      u = arcs[i ^ 1].to;
    }
    max_flow += flow[t];
    min_cost += cost[t] * flow[t];
  }
  void Ek() {
    max_flow = min_cost = 0;
    while (Spfa()) Update();
  }
};
Graph G;
int n;
int p, a, f, b, s;
#define UNUSED(I) (I)
#define USED(I) ((I) + 2001)
signed main() {
  scanf("%lld", &n);
  G.s = kMaxN - 2;
  G.t = kMaxN - 1;
  for (int i = 1; i <= n; i++) {
    int r;
    scanf("%lld", &r);
    G.Add(UNUSED(i), G.t, r, 0);
    G.Add(G.s, USED(i), r, 0);
  }
  scanf("%lld %lld %lld %lld %lld",
        &p, &a, &f, &b, &s);
  for (int i = 1; i <= n; i++) {
    G.Add(G.s, UNUSED(i), kInf, p);
    if (i + 1 <= n) G.Add(UNUSED(i), UNUSED(i + 1), kInf, 0);
    if (i + a <= n) G.Add(USED(i), UNUSED(i + a), kInf, f);
    if (i + b <= n) G.Add(USED(i), UNUSED(i + b), kInf, s);
  }
  G.Ek();
  // printf("%lld %lld\n", G.min_cost, G.max_flow);
  printf("%lld\n", G.min_cost);
  return 0;
}
```

---

## 作者：Mys_C_K (赞：9)

唔很不错的一个题，建议初学者不要看题解，自己想一想QwQ

由于不会用markdown，所以没法可视化，因此下文用<u,v,minf,maxf,cost>来表示建一条从u到v的下界是minf上界是maxf费用是cost的边，特殊的如果minf=0那么直接用<u,v,f,c>表示，意义类似。

根据上下界网络流的一般做法，可以得知这里如果minf=0那么就是一般的网络流的边。

否则<u,v,minf,maxf,c>=<S,v,minf,0>+<u,T,minf,c>+<u,v,maxf-minf,c>。

首先非常显然的，为了表示“用至少r\_i块餐巾”这个过程，把每个点x拆为px和qx。并连边<px,qx,r[x],inf,0>，来保证第x天能够有r[x]块餐巾。

然后很显然的，px表示的是早上，qx表示的是晚上，因此不难处理“买餐巾”“快、慢洗”这三个过程：分别对应着：

<S,px,inf,p>、<qx,p(x+m),inf,f>、<qx,p(x+n),inf,s>。

看起来好像没有问题了，这样就完了么？

其实应该还少了一个过程：今天有多余的餐巾没有用完，并且是干净的，这个时候不能通过快洗或是慢洗转移走，因此要<px,p(x+1),inf,0>表示这些餐巾今天不用，0代价的留到明天的过程。

然后……然后就是跑一个正常的费用流即可，显然原图的可行流是一定存在的（你至少可以每天都买新的）。所以跑一个费用流即可。


```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<climits>
#include<queue>
#define N 4020
#define M 15*N
#define P(x) x
#define Q(x) (x+n)
#define inf INT_MAX
#define INF LLONG_MAX
#define lint long long
using namespace std;
struct edges{
    int from,to,pre,resf,cost;
}e[M];int etop,h[N];
inline int add_edge(int u,int v,int f,int c)
{
    e[++etop].from=u,e[etop].to=v,e[etop].pre=h[u];
    return e[etop].resf=f,e[etop].cost=c,h[u]=etop;
}
inline int build_edge(int u,int v,int f,int c)
{
    return add_edge(u,v,f,c),add_edge(v,u,0,-c);
}
lint d[N];bool inq[N];int fr[N];queue<int> q;
inline int spfa(int s,int t,int &flow,lint &cost)
{
    for(int i=1;i<=t;i++) d[i]=INF;
    memset(inq,false,sizeof(inq));
    memset(fr,0,sizeof(fr));
    while(!q.empty()) q.pop();
    q.push(s),inq[s]=true,d[s]=0;
    while(!q.empty())
    {
        int x=q.front();q.pop(),inq[x]=false;
        for(int i=h[x],y;i;i=e[i].pre)
            if(e[i].resf&&d[y=e[i].to]>d[x]+e[i].cost)
            {
                d[y]=d[x]+e[i].cost,fr[y]=i;
                if(!inq[y]) inq[y]=true,q.push(y);
            }
    }
    if(!fr[t]) return false;int minf=inf;
    for(int i=fr[t];i;i=fr[e[i].from])
        minf=min(minf,e[i].resf);
    for(int i=fr[t];i;i=fr[e[i].from])
        e[i].resf-=minf,e[((i-1)^1)+1].resf+=minf;
    cost+=d[t]*minf,flow+=minf;return true;
}
int main()
{
    int n;scanf("%d",&n);
    int s=2*n+1,t=s+1;
//    build_edge(t,s,inf,0);
    for(int i=1;i<=n;i++)
    {
        int r;scanf("%d",&r);
        build_edge(s,Q(i),r,0);
        build_edge(P(i),t,r,0);
    }
    int p,x,y,a,b;
    scanf("%d%d%d%d%d",&p,&x,&a,&y,&b);
    for(int i=1;i<=n;i++)
    {
        build_edge(s,P(i),inf,p);
        if(i+x<=n) build_edge(Q(i),P(i+x),inf,a);
        if(i+y<=n) build_edge(Q(i),P(i+y),inf,b);
    }
    for(int i=1;i<n;i++) build_edge(P(i),P(i+1),inf,0);
    int f=0;lint c=0;
    while(spfa(s,t,f,c));
    cout<<c<<endl;return 0;
}
```

---

## 作者：不存在之人 (赞：7)

**这道题应该不难看出是道费用流的题目，但是具体怎么建图倒是值得考虑的。**

**首先根据题意，既要有每天新的餐巾，又有每天用过的餐巾，这两个信息难以只用一个表示第几天的点来表示，所以考虑拆点，把每天拆成新餐巾和旧餐巾两个点。**

**我们要保证每天的旧餐巾的产生量和新餐巾的供应量，想到与源点和汇点直接相连最容易保证这个要求，所以我们把源点向每天的旧餐巾连当天需要的餐巾数量，新餐巾向汇点连每天的餐巾数量，每流向汇点1点流量就表那一天供应了1张餐巾，而以上两种连边都是没有花费的，所以费用是0。**

**我们可以发现每天的旧餐巾不一定要洗，所有每天的旧餐巾向下一天连流量正无穷，费用是0的边。一个小细节，最后一天当然就不要向下一天连了。**

**然后考虑直接购买，直接购买对旧餐巾没有影响，它可以提供花一定费用买新餐巾，而购买没有数量上限，所以源点到每天的新餐巾连流量是正无穷，费用是p的边。**

**接下来考虑快洗和慢洗。不难发现它们的连边方式应该是很类似的。我们把每天的旧餐巾向m天后的新餐巾连流量正无穷，费用是f的边，表示快洗。同样地，我们把每天的旧餐巾向n天后的新餐巾连一条流量正无穷，费用是s的边，表示慢洗。这里要注意一个细节，就是对于第i天，i+m和i+n都是要小于等于总天数的。**

**然后跑一个费用流就行了。**

**最后是代码。**
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
long long n,p,kuai,man,feik,feim,res,q[500000];
long long head[50001],cnt,st,ed,w[50000],v[50000],inq[50000],f[50001];
struct node
{
    long long next,to,c,other,cost,from;
}a[500001];
void add(long long from,long long to,long long c,long long cost)
{
    int k1,k2;
    ++cnt;
    k1=cnt;
    a[cnt].next=head[from];
    a[cnt].from=from;
    a[cnt].to=to;
    a[cnt].c=c;
    a[cnt].cost=cost;
    head[from]=cnt;
    ++cnt;
    k2=cnt;
    a[cnt].next=head[to];
    a[cnt].from=to;
    a[cnt].to=from;
    a[cnt].c=0;
    a[cnt].cost=-cost;
    head[to]=cnt;
    a[k1].other=k2;
    a[k2].other=k1;
}
void bfs()
{
    for(int i=1;i<=n;i++)
    q[i]=0;
    memset(v,0x3f,sizeof(v));
    memset(w,0,sizeof(w));
    memset(inq,0,sizeof(inq));
    memset(f,0,sizeof(f));
    int h=1,t=1;
    q[1]=st;
    v[st]=0;
    w[st]=2e9;
    while(h<=t)
    {
        int x=q[h];
        inq[x]=0;
        for(int i=head[x];i;i=a[i].next)
        {
            int y=a[i].to;
            if(a[i].c>0&&v[y]>v[x]+a[i].cost)
            {
                w[y]=min(w[x],a[i].c);
                v[y]=v[x]+a[i].cost;
                f[y]=i;
                if(!inq[y])
                {
                    q[++t]=y;
                    inq[y]=1;
                }
            }
        }
        h++;
    }
    for(int i=f[ed];i;i=f[a[i].from])
    {
        a[i].c-=w[ed];
        a[a[i].other].c+=w[ed];
    }
}
int main()
{
    scanf("%lld",&n);
    st=0,ed=2*n+1;
    for(int i=1;i<=n;i++)
    {
        long long x;
        scanf("%lld",&x);
        add(st,i,x,0);
        add(i+n,ed,x,0);
    }
    scanf("%lld%lld%lld%lld%lld",&p,&kuai,&feik,&man,&feim);    
    for(int i=1;i<=n;i++)
    {		
        if(i+1<=n)
        add(i,i+1,2e9,0);
        if(i+kuai<=n)
        add(i,i+kuai+n,2e9,feik);		
        if(i+man<=n)
        add(i,i+man+n,2e9,feim);		
        add(st,i+n,2e9,p);
    }
    while(1)
    {
        bfs();
        if(w[ed]>0)
        res+=v[ed]*w[ed];
        else
        break;
    }
    printf("%lld\n",res);
    return 0;
}
```

---

## 作者：a2956331800 (赞：5)

来讲一个和其他题解不一样的网络流做法

- 首先我们考虑买毛巾

显然分多次买和第一天买齐是等价的

- 拆点

我们把一天拆成两个点$i,i+N$，$i$表示干净毛巾，$i+N$表示脏毛巾

现在就可以建图了

1. $S->1,d\text{(容量)}=+\infty,c\text{(费用)}=p$

表示买毛巾

2. $i->i+1,d=+\infty,c=0$

表示这一天没用完的毛巾留到下一天

3. $i+N->i+1+N,d=+\infty,c=0$

表示这一天的脏毛巾留到下一天（虽然留到之后再洗肯定是不优的，但是有可能这个毛巾最后不洗了）

4. $(N+N)->T,d=+\infty,c=0$

表示最后剩下的脏毛巾

5. $i+N->i+m,d=+\infty,c=f$

表示脏毛巾送快洗店，花费$f$，在$m$天后获得干净毛巾

6. $i+N->i+n,d=+\infty,c=s$

表示脏毛巾送慢洗店，花费$s$，在$n$天后获得干净毛巾

（注意4、5、6连边的时候不要越界）

接下来是最核心的边，不过非常鬼畜

现在按说应该对$i,i+N$建边了，但显然如果直接$i->i+N,d=r_i,c=0$的话，**送洗**的边不会被用到

- 怎么回事？

可以画个图观察一下，发现**流**是**毛巾**，就是说这样变成了让毛巾最多，那就变成全都买毛巾了

- 怎么办？

$i->i+N,d=r_i,c=-\infty$

看起来不可理解，但这样处理之后为了让费用最小，会**优先**尽可能多得走这种边，然后**其他费用最小**

然后我们把费用流跑到这次增广时**费用为正**为止（为正的这一次不计入）

- 发生了什么？

我们把费用流卡在了流满所有$i->i+N$的边且费用最小的情况

$spfa\text{费用流}$是**优先保证费用最小**，然后逐渐增大流

所以这个状态就是流满所有使用毛巾的边（也就所有毛巾的需求都满足）时最小的费用

即最小花费

$ans=cost+inf\times\sum_{i=1}^nr_i$即可

- 不能继续增广了

继续的话又会陷入令**毛巾最多**的情况中，然后就$GG$了

## 总结

所以这个鬼畜做法的关键就是利用$spfa\text{费用流}$**优先保证费用最小**的特性，同时用$-\infty$的费用强制优先填满**使用毛巾**的边，再找到费用最小的时刻，然后这时的流就是最优使用计划，真实费用最小

- $\infty=?$

首先$\infty>>p,f,s$以保证二者互不影响，即$\infty>>10000$

然后为了不爆$long long$，$\infty\times\sum_{i=1}^nr_i<=9e18$，由于$\infty\times\sum_{i=1}^nr_i<=\infty\times n\times r_{max}=\infty\times 1e10$，$\infty\text{取}1e8$即可

代码
```cpp
#include<iostream>
#include<cstdlib>
#include<cstring>
#include<cstdio>
#include<queue>
#define S 0
#define T 4010
#define inf 100000000
#define finf 0x7fffffffffffffff
using namespace std;

long long n,r[2005],i,p,f,s,ft,st,ans;

struct way
{
    long long v,d,c,next;
};
way e[300000];
long long head[4100],cur[4100],cnt;
void add(long long u,long long v,long long d,long long c)
{
    e[cnt].v=v;e[cnt].d=d;e[cnt].c=c;e[cnt].next=head[u];head[u]=cnt++;
    e[cnt].v=u;e[cnt].d=0;e[cnt].c=-c;e[cnt].next=head[v];head[v]=cnt++;
}

long long dist[4100],flow[4100],pre[4100];
long long spfa()
{
    static long long in[4100],x;
    static queue<long long> q;
    memset(dist,63,sizeof(dist));dist[S]=0;q.push(S);flow[S]=finf;
    while(!q.empty())
    {
        x=q.front();q.pop();in[x]=0;
        for(long long i=head[x];~i;i=e[i].next)
            if(e[i].d&&dist[x]+e[i].c<dist[e[i].v])
                dist[e[i].v]=dist[x]+e[i].c,pre[e[i].v]=i,flow[e[i].v]=min(flow[x],e[i].d),in[e[i].v]?0:(q.push(e[i].v),in[e[i].v]=1);
    }
    return dist[T]!=dist[4099];
}
long long fee_flow()
{
    long long ret=0,x;
    while(spfa()&&dist[T]<0)
    {
        ret+=flow[T]*dist[T];
        x=T;
        while(x!=S)
            e[pre[x]].d-=flow[T],e[pre[x]^1].d+=flow[T],x=e[pre[x]^1].v;
    }
    return ret;
}

char Getchar()
{
    static char buff[1000000],*p,*end=p;
    if(p==end)
        end=buff+fread(p=buff,1,1000000,stdin);
    if(p==end)
        return -1;
    return *(p++);
}
template<typename TT>void read(TT &x)
{
    static char rc;static long long flag;
    x=0;rc=Getchar();flag=1;
    while(!isdigit(rc))
        flag=(rc=='-'?-1:1),rc=Getchar();
    while(isdigit(rc))
        x=x*10+rc-'0',rc=Getchar();
    x*=flag;
}

int main()
{
    memset(head,-1,sizeof(head));
    read(n);
    for(i=1;i<=n;i++)
        read(r[i]),add(i,i+n,r[i],-inf),ans+=r[i]*inf;
    read(p);read(ft);read(f);read(st);read(s);
    add(S,1,inf,p);add(n+n,T,inf,0);
    for(i=1;i<n;i++)
        add(i,i+1,inf,0),add(i+n,i+n+1,inf,0);
    for(i=1;i+ft<=n;i++)
        add(i+n,i+ft,inf,f);
    for(i=1;i+st<=n;i++)
        add(i+n,i+st,inf,s);
    ans+=fee_flow();
    cout<<ans;
    return 0;
}
```

---

## 作者：ez_lcw (赞：4)

## 最小费用最大流中的 
# 建模难题：
### 餐巾计划问题

这道题只要您学会了如何**建模**，还有会**拆点**（网络流必备），然后套一波模板，就能~~轻松A掉~~。

建模方法：

思路：**建时间轴，将每一天拆为早上和晚上（干净的纸巾和脏的纸巾）**。

**1. 先建超源超汇。**

**2.超源向每一天晚上连一条容量为当天需要的纸巾数，费用为0的边。**

**3.超汇向每一天早上连一条容量为当天需要的纸巾数，费用为0的边。**

**4.每天晚上向下一天晚上连一条容量为INF，费用为0的边（将当天的脏纸巾留到下一天）。**

**5.连快洗，慢洗店的边（相信大家都会，就是从当天晚上向过k（洗的天数）后那一天早连一条容量为INF，费用为洗纸巾~~（虽然我不知道纸巾能洗）~~的费用的边）。**

**6.连买新纸巾的边，就是从超源向每天早连一条容量为INF，费用为买新纸巾费用的边。**

##### 注意：要连的点是否越界。

我是用EK加SPFA的，时间复杂度~~懒得算~~，~~为O（能过）~~。

具体代码如下：

```cpp
#include<cstdio>
#include<cstring>
#include<queue>
 
#define N 5000
#define M 12000
#define INF 0x7fffffff
 
using namespace std;
 
int n,newcost,fast,fastcost,slow,slowcost,head[N],c[M],cost[M],nxt[M],to[M],into[N],out[N],f[N],pre[N],cnt,tot,s,t,minn,ans;
//newcost为买新纸巾的费用，fast为快洗店需要的天数，fastcost为快洗店需要的费用，慢洗店slow同理，cnt为边的编号，tot为点的编号，minn为每条找到的增广路的流量。
bool vis[N];
 
queue<int>q;
 
void adde(int u,int v,int a,int b){//我用的是邻接表存边
    cnt++;
    to[cnt]=v;
    c[cnt]=a;
    cost[cnt]=b;
    nxt[cnt]=head[u];
    head[u]=cnt;
     
    cnt++;
    to[cnt]=u;
    c[cnt]=0;
    cost[cnt]=-b;
    nxt[cnt]=head[v];
    head[v]=cnt;
}
 
bool SPFA(){//套模板
    for(int i=s;i<=t;i++){//切记初始化，我被坑过n遍
        f[i]=INF;
    }
    q.push(s);
    vis[s]=true;
    f[s]=0;
    while(!q.empty()){
        int now=q.front();
        q.pop();
        vis[now]=false;
        for(int i=head[now];i;i=nxt[i]){
            if(c[i]&&f[now]+cost[i]<f[to[i]]){
                f[to[i]]=f[now]+cost[i];
                pre[to[i]]=i;
                if(!vis[to[i]]){
                    q.push(to[i]);
                    vis[to[i]]=true;
                }
            }
        }
    }
    if(f[t]==INF){
        return false;
    }else{
        return true;
    }
}
 
void EK(){//套模板
    while(SPFA()){
        minn=INF;
        for(int i=t;i!=s;i=to[pre[i]^1]){
            minn=min(minn,c[pre[i]]);
        }
        for(int i=t;i!=s;i=to[pre[i]^1]){
            c[pre[i]]-=minn;
            c[pre[i]^1]+=minn;
            ans+=minn*cost[pre[i]];
        }
    }
}
 
int main(){
    scanf("%d%d%d%d%d%d",&n,&newcost,&fast,&fastcost,&slow,&slowcost);
    cnt=1;
    tot=1;
    s=1;
    t=1+2*n+1;
    for(int i=1;i<=n;i++){//给每个点的早上点和晚上点编号
        into[i]=++tot;//into存的是早上
        out[i]=++tot;//out存的是晚上
    }
    for(int i=1;i<=n;i++){
        int ni;
        scanf("%d",&ni);
        adde(s,out[i],ni,0);//建第2条建模方法的边
        adde(into[i],t,ni,0);//建第3条建模方法的边
        adde(s,into[i],INF,newcost);//建第6条建模方法的边
        if(out[i+1]<t){
            adde(out[i],out[i+1],INF,0);//建第4条建模方法的边
        }
        if(into[i+fast]<t){
            adde(out[i],into[i+fast],INF,fastcost);//建第5（快洗店）建模方法的边
        }
        if(into[i+slow]<t){
            adde(out[i],into[i+slow],INF,slowcost);/建第5（慢洗店）建模方法的边
        }
    }
    EK();
    printf("%d\n",ans);
    return 0;
}
```
我认为：其实，做最大流关键在于建模和一些技巧的使用（如拆点，拆边，利用残量网络等等），其他的套一波模板就行了。

---

## 作者：11D_Beyonder (赞：2)

> 传送门 [$\looparrowright$](https://www.luogu.com.cn/problem/P1251)  

## 题目描述  
&emsp;&emsp;一个餐厅在相继的 $N$ 天里,每天需用的餐巾数不尽相同。假设第 $i$ 天需要 $r_i$ 块餐巾（$ i=1,2,\cdots,N$）。餐厅可以购买新的餐巾,每块餐巾的费用为 $p$ 分;或者把旧餐巾送到快洗部,洗一块需 $m$ 天,其费用为 $f$ 分;或者送到慢洗部,洗一块需 $n$ 天（$n>m$）,其费用为 $s$ 分（$s<f$）。  
&emsp;&emsp;每天结束时,餐厅必须决定将多少块脏的餐巾送到快洗部,多少块餐巾送到慢洗部,以及多少块保存起来延期送洗。但是每天洗好的餐巾和购买的新餐巾数之和,要满足当天的需求量。  
&emsp;&emsp;试设计一个算法为餐厅合理地安排好 $N$ 天中餐巾使用计划,使总的花费最小。编程找出一个最佳餐巾使用计划。  
## 输入格式  
&emsp;&emsp;由标准输入提供输入数据。文件第 $1$ 行有 $1$ 个正整数 $N$，代表要安排餐巾使用计划的天数。  
&emsp;&emsp;接下来的一行是餐厅在相继的 $N$ 天里,每天需用的餐巾数。  
&emsp;&emsp;最后一行包含 $5$ 个正整数 $p,m,f,n,s$。$p$ 是每块新餐巾的费用；$m$ 是快洗部洗一块餐巾需用天数；$f$ 是快洗部洗一块餐巾需要的费用；$n$ 是慢洗部洗一块餐巾需用天数；$s$ 是慢洗部洗一块餐巾需要的费用。  
## 输出格式  
&emsp;&emsp;将餐厅在相继的 $N$ 天里使用餐巾的最小总花费输出。  
## 输入输出样例  
### 输入 \#1  
> 3   
> 1 7 5   
> 11 2 2 3 1  

### 输出 #1  
> 134  

## 说明/提示  
&emsp;&emsp;$N\leqslant 2000$，$r_i\leqslant 10000000$，$p,f,s\leqslant10000$。时限 $4\mathrm s$。    
## 分析  
&emsp;&emsp;题目中有说：每天结束时,餐厅必须决定将多少块脏的餐巾送到快洗部,多少块餐巾送到慢洗部,以及多少块保存起来延期送洗；每天洗好的餐巾和购买的新餐巾数之和,要满足当天的需求量。也就是说，对于完整的一天，每天早晨至少要获得满足当天需求的赶紧餐巾，干净餐巾可以从快洗部或慢洗部获得，也可以直接买；每天晚上要决定脏餐巾的去处。每个状态有多种选择的问题，可以考虑分层图最短路，然而，对于此题，按照最短路的思想难以完成建图的工作；要使 $N$ 天内每一天都满足餐巾的使用需求，且要求费用最小，不妨进一步考虑最小费用最大流。  
&emsp;&emsp;不妨就将 $N$ 天作为 $N$ 个节点，再考虑早晨和晚上的不同分工，就将每个点拆成代表【早晨，夜晚】的两个点。规定：代表早晨的点编号为 $1\sim N$，代表夜晚的点编号为 $N+1\sim 2N$，源点 $\text{source}$ 的编号为 $0$，汇点 $\text{sink}$ 的编号为 $2N+1$。
&emsp;&emsp;编号为 $1\sim N$ 节点的入边用于接受干净的餐巾，包括从慢洗部、快洗部洗好的餐巾，和之间买来的毛巾：其中一部分入边为源点向 $1\sim N$ 节点的连边，容量为 $+\infty$，单位费用为 $p$，这些边用于供给干净的餐巾；另一部分为代表夜晚节点的出边，将脏餐巾送到快洗部属于夜晚的操作，会连向$m$ 天后的早晨，费用为 $f$，将脏餐巾送到慢洗部也是夜晚的操作，连向 $n$ 天后的早晨，费用为 $s$。编号为 $1\sim N$ 节点的出边都连向汇点，容量为 $r_i$，费用为 $0$。  
&emsp;&emsp;编号为 $N+1\sim 2N$ 的节点入边用于接受脏的餐巾：一部分入边的另一端为源点，这些边用于提供脏餐巾，容量为 $r_i$（接受的仅仅是当天产生的脏餐巾），费用为 $0$；另一部分入边的另一端是前几天的夜晚，这些边提供前几天夜晚遗留下的脏餐巾，容量为 $+\infty$，费用为 $0$。编号为 $N+1\sim 2N$ 的节点的出边用于处理脏毛巾：将脏餐巾送到快洗部属于夜晚的操作，会连向$m$ 天后的早晨，费用为 $f$，将脏餐巾送到慢洗部也是夜晚的操作，连向 $n$ 天后的早晨，费用为 $s$。编号为 $1\sim N$ 节点的出边都连向汇点，容量为 $r_i$，费用为 $0$。    
&emsp;&emsp;按照上述方式建图，其最大流必为 $\sum\limits_{i=1}^N r_i$，且汇点的每一条入边都满流，这就保证了每天的干净毛巾能够满足需求。网络的最小费用最大流即为答案。    

## 代码  
```cpp
/******************************************************************
Copyright: 11D_Beyonder All Rights Reserved
Author: 11D_Beyonder
Problem ID: 洛谷 P1251
Date: 7/29/2020
Description: Minimum-cost Flow
*******************************************************************/
#include<iostream>
#include<queue>
#include<cstdio>
#include<cstring>
using namespace std;
typedef long long ll;
const ll inf=0x3f3f3f3f3f3f3f3f;
const int N=2004<<2;
const int M=1000003;
struct E
{
	int to;
	ll cap;
	ll cost;
	int Next=-1;
}edge[M];
int head[N],tot;
bool inqueue[N];
ll incf[N],dis[N];
int pre[N];
int days;//餐巾使用计划天数
int source;//源点
int sink;//汇点
int p;//每块新餐巾费用
int m,f;//快洗 时间和费用
int n,s;//慢洗 时间和费用
ll r[N>>1];
void init();
inline void add_edge(int u,int v,ll cap,ll cost);
bool SPFA();
ll MCMF();
int main()
{
	cin>>days;
	int i;
	for(i=1;i<=days;i++) scanf("%lld",r+i);
	cin>>p>>m>>f>>n>>s;
	init();
	for(i=1;i<=days;i++)
	{
		add_edge(i,sink,r[i],0);//早晨的点连向汇点 满流时代表这天的毛巾够用
		add_edge(source,i+days,r[i],0);//晚上获得r[i]条脏毛巾
		add_edge(source,i,inf,p);//源点流向早上的点 可供给毛巾
		if(i+m<=days) add_edge(i+days,i+m,inf,f);//快洗
		if(i+n<=days) add_edge(i+days,i+n,inf,s);//慢洗
		if(i+1<=days) add_edge(i+days,i+1+days,inf,0);//脏毛巾存到下一天晚上
	}
	cout<<MCMF()<<endl;
	return 0;
}
void init()
{
	source=0;
	sink=2*days+1;
	tot=1;
	memset(head,-1,sizeof(head));
}
inline void add_edge(int u,int v,ll cap,ll cost)
{
	tot++;
	edge[tot].to=v;
	edge[tot].cap=cap;
	edge[tot].cost=cost;
	edge[tot].Next=head[u];
	head[u]=tot;
	tot++;
	edge[tot].to=u;
	edge[tot].cap=0;
	edge[tot].cost=-cost;
	edge[tot].Next=head[v];
	head[v]=tot;
}
bool SPFA()
{
	queue<int>q;
	memset(dis,inf,sizeof(dis));
	memset(inqueue,0,sizeof(inqueue));
	q.push(source);
	dis[source]=0;
	inqueue[source]=1;
	incf[source]=inf;
	while(!q.empty())
	{
		int x=q.front();
		q.pop();
		inqueue[x]=0;
		for(register int i=head[x];~i;i=edge[i].Next)
		{
			if(!edge[i].cap) continue;//剩余容量为0，不在残量网络中。
			int y=edge[i].to;
			if(dis[y]>dis[x]+edge[i].cost)
			{
				dis[y]=dis[x]+edge[i].cost;//松弛操作
				incf[y]=min(incf[x],edge[i].cap);//最小剩余容量
				pre[y]=i;//记录前驱
				if(!inqueue[y])
				{
					inqueue[y]=1;
					q.push(y);
				}
			}
		}
	}
	if(dis[sink]==inf) return 0;//汇点不可达，已经求出最大流
	else return 1;
}
ll MCMF()
{
	ll maxflow,mincost;
	maxflow=mincost=0;
	while(SPFA())
	{
		int x=sink;
		//沿着前驱倒着走增广路
		while(x!=source)
		{
			int y=pre[x];
			edge[y].cap-=incf[sink];
			edge[y^1].cap+=incf[sink];
			x=edge[y^1].to;
		}
		maxflow+=incf[sink];
		mincost+=dis[sink]*incf[sink];
	}
	return mincost;
}
```

---

## 作者：NaCN (赞：1)



每天需要$r[i]$块餐巾,可以买餐巾，也可以使用洗好的，下午可以选择洗两种洗衣
+ 洗一块需 $m$ 天,其费用为 $f$ 分;或者,洗一块需 $n$ 天$(n>m)$,其费用为 $s$ 分$(s<f)$。
<!--more-->

考虑把一天拆点，（又每天必须洗$r[i]$块餐巾，每天必须需要$r[i]$餐巾）

$i$表示上午,$i+Q$表示下午。

+ 则$(s,i+n,r[i],0)$,$(i,t,r[i],0)$限制了每天的必须
+ $(i+Q,i+m,INF,f)$或者$(i+Q,i+n,INF,s)$表示选择洗。
+ 然后多的毛巾可以留到明天$(i,i+1,INF,0)$
+ 需要买毛巾直接$(s,i,INF,p)$


```c++

#include <iostream>
#include <cstdio>
#include <algorithm>
#include <queue>
#include <cmath>
#include <cstring>
#include <vector>
#include <map>
#include <stack>
using namespace std;
typedef long long ll;
#define pii pair<int, int>
#define mk make_pair
#define INF 0x3f3f3f3f
const int N = 1e6 + 10;
const int mod = 1e9 + 7;
int read()
{
    int x = 0, f = 1;
    char c = getchar();
    while (c < '0' || c > '9')
    {
        if (c == '-')
            f = -1;
        c = getchar();
    }
    while (c >= '0' && c <= '9')
        x = (x << 1) + (x << 3) + c - '0', c = getchar();
    return x * f;
}
struct Edge
{
    int to, w, nxt, f;
    Edge() {}
    Edge(int v, int c, int t, int k) : to(v), w(c), nxt(t), f(k) {}
};
const int EN = 5e3 + 10;
const int EM = 5e4 + 10;
struct LeiDinic
{

    Edge e[EM << 1];
    int head[EN], scnt, dis[EN], vis[EN], cur[EN];
    ll cost;
    LeiDinic() { scnt = 1, cost = 0; }
    void addEdge(int u, int v, int w, int k)
    {
        e[++scnt] = Edge(v, w, head[u], k);
        head[u] = scnt;
        e[++scnt] = Edge(u, 0, head[v], -k); ///!!!!
        head[v] = scnt;
    }
    bool spfa(int s, int t)
    {
        memset(vis, 0, sizeof(vis));
        memset(dis, INF, sizeof(dis));
        queue<int> q;
        dis[s] = 0;
        vis[s] = 1;

        q.push(s);
        while (!q.empty())
        {
            int x = q.front();
            q.pop();
            vis[x] = 0;
            for (int i = head[x]; i; i = e[i].nxt)
            {
                int to = e[i].to;

                if (dis[to] > dis[x] + e[i].f && e[i].w)
                {
                    dis[to] = dis[x] + e[i].f;
                    if (!vis[to])
                    {
                        vis[to] = 1;
                        q.push(to);
                    }
                }
            }
        }
        return dis[t] != INF;
    }

    int dfs(int x, int t, int flow)
    {
        if (x == t)
            return flow;
        vis[x] = 1;
        int res = 0;
        for (int i = cur[x]; i && res < flow; i = e[i].nxt)
        {
            cur[x] = i;
            int to = e[i].to;
            if (!vis[to] && dis[to] == dis[x] + e[i].f && e[i].w)
            {
                int dis = dfs(to, t, min(flow - res, e[i].w));
                if (dis)
                {
                    e[i].w -= dis;
                    e[i ^ 1].w += dis;
                    cost += 1ll * e[i].f * dis;
                    res += dis;
                }
            }
        }
        vis[x] = 0;
        return res;
    }
    ll Maxflow(int s, int t)
    {
        int ans = 0, tmp;
        while (spfa(s, t))
        {
            memcpy(cur, head, sizeof(head));
            while ((tmp = dfs(s, t, INF)))
                ans += tmp;
        }
        return cost;
    }
} dc;
int a[N];
int main()
{
    int Q = read();
    for (int i = 1; i <= Q; i++)
        a[i] = read();
    int p = read(), m = read(), f = read(), n = read(), sf = read();
    int s = 2 * Q + 1, t = 2 * Q + 2;
    for (int i = 1; i <= Q; i++)
    {
        dc.addEdge(s, i, INF, p);
        dc.addEdge(i, t, a[i], 0);
        dc.addEdge(s, i + Q, a[i], 0);
        if (i + m <= Q)
            dc.addEdge(i + Q, i + m, INF, f);
        if (i + n <= Q)
            dc.addEdge(i + Q, i + n, INF, sf);
        if (i + 1 <= Q)
            dc.addEdge(i, i + 1, INF, 0);
    }
    printf("%lld\n", dc.Maxflow(s, t));
}

```


---

## 作者：Smallbasic (赞：1)

网络流好题啊

很明显~~标签告诉我们~~这是道费用流

首先肯定要从源点向每个点和从每个点向汇点连一条容量为需要餐巾数的边，费用0

每天要处理脏餐巾和接受干净餐巾。开始时只有干净餐巾可用，结束时只有脏餐巾要处理，考虑拆成两个点，表示每天开始和结束。

处理餐巾有3种：快洗和慢洗和滞留。这三种情况分别连到i+m,i+n,i+1,费用就是f,s和0.流量没有限制，就是inf

买新餐巾呢？直接从源点买，流量仍没限制，inf，费用为p

然后就是最小费用最大流板子：

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <vector>
#include <queue>

using namespace std;

#define ll long long

inline int read() {
	int s = 0;
	char ch = getchar();
	while (!isdigit(ch)) ch = getchar();
	while (isdigit(ch)) s = (s << 1) + (s << 3) + (ch & 15), ch = getchar();
	return s;
}

struct Edge {
	int from, to; ll flow, dis;
	inline Edge(int n, int m, ll s, ll l) : from(n), to(m), flow(s), dis(l) {}
};

int n, m, m1, t1, m2, t2, s, t, en = -1, dep[10005], pre[10005], last[10005];
ll dis[10005], flow[10005], mf, mc;
vector<Edge> ed;
vector<int>e[10005];

inline int min_(int a, int b) {
	return a < b ? a : b;
}

inline void addedge(int from, int to, int v, int d) {
	ed.push_back(Edge(from, to, v, d));
	e[from].push_back(++en); 
	ed.push_back(Edge(to, from, 0, -d));
	e[to].push_back(++en);
}

inline bool spfa(int s, int t) {
	memset(dis, 0x3f, sizeof(dis)); memset(flow, 0x3f, sizeof(flow)); bool vis[10005];
	deque<int> q; q.push_back(s); memset(vis, 0, sizeof(vis));
	dis[s] = 0; pre[t] = -1; vis[s] = 1; while (!q.empty()) {
		int x = q.front(); q.pop_front(); vis[x] = 0;
		for (vector<int> :: iterator it = e[x].begin(); it != e[x].end(); ++it) {
			int v = ed[(*it)].to; 
			if (ed[(*it)].flow > 0 && dis[v] > dis[x] + ed[(*it)].dis) {
				dis[v] = dis[x] + ed[(*it)].dis;  pre[v] = x; last[v] = (*it);
				flow[v] = min_(flow[x], ed[(*it)].flow);
				if (!vis[v]) {
					vis[v] = 1;
					if (!q.empty() && dis[q.front()] > dis[v]) q.push_front(v);
					else q.push_back(v);
				}
			}
		}
	} return pre[t] != -1;
}

inline void MCMF() {
	while (spfa(s, t)) {
		int now = t; mf += flow[t]; mc += flow[t] * dis[t];
		while (now != s) {
			ed[last[now]].flow -= flow[t];
			ed[last[now] ^ 1].flow += flow[t];
			now = pre[now];
		}
	}
}

int main() {
	n = read(); s = 0; t = n * 2 + 1;
	for (int i = 1; i <= n; ++i) {
		int x = read(); addedge(s, i, x, 0); addedge(i + n, t, x, 0);
	} m = read(); t1 = read(); m1 = read(); t2 = read(); m2 = read();
	for (int i = 1; i <= n; ++i) {
		if (i <= n - 1) addedge(i, i + 1, 0x3f3f3f3f, 0);
		if (i + t1 <= n) addedge(i, i + n + t1, 0x3f3f3f3f, m1);
		if (i + t2 <= n) addedge(i, i + n + t2, 0x3f3f3f3f, m2);
		addedge(s, i + n, 0x3f3f3f3f, m);
	} MCMF(); printf("%lld", mc);
	return 0;
}
```


---

## 作者：YZL11111 (赞：1)

题目链接：https://www.luogu.com.cn/problem/P1251

## 【题目描述】
一个餐厅在相继的 N 天里,每天需用的餐巾数不尽相同。假设第 i 天需要 r_i块餐巾( i=1,2,...,N)。餐厅可以购买新的餐巾,每块餐巾的费用为 p 分;或者把旧餐巾送到快洗部,洗一块需 m 天,其费用为 f 分;或者送到慢洗部,洗一块需 n 天(n>m),其费用为 s 分(s<f)。

每天结束时,餐厅必须决定将多少块脏的餐巾送到快洗部,多少块餐巾送到慢洗部,以及多少块保存起来延期送洗。但是每天洗好的餐巾和购买的新餐巾数之和,要满足当天的需求量。

试设计一个算法为餐厅合理地安排好 N 天中餐巾使用计划,使总的花费最小。编程找出一个最佳餐巾使用计划。

## 【输入格式】
由标准输入提供输入数据。文件第 1 行有 1 个正整数 N，代表要安排餐巾使用计划的天数。

接下来的 N 行是餐厅在相继的 N 天里,每天需用的餐巾数。

最后一行包含5个正整数p,m,f,n,s。p 是每块新餐巾的费用; m 是快洗部洗一块餐巾需用天数; f 是快洗部洗一块餐巾需要的费用; n 是慢洗部洗一块餐巾需用天数; s 是慢洗部洗一块餐巾需要的费用。

## 【输出格式】
将餐厅在相继的 N 天里使用餐巾的最小总花费输出

## 【解题思路】
### 难点在于建图
考虑将每天分为两部分——开始和结束，开始时获得干净的餐巾（通过购买，快洗，慢洗获得），结束时获得脏餐巾（每天早上使用后的餐巾，可理解为由源点提供）

第一步，将源点与每天的结束连一条容量为所需餐巾数（表示获得的脏餐巾数），费用为0的边，将每一天的开始与汇点同样连一条费用为0，容量为餐巾数的边（表示提供的新餐巾数）

第二步，将源点与每一天的开始连一条容量为无穷，费用为0的边（表示每天早上可以从源点购买新的餐巾）

第三步，考虑每天的脏餐巾洗与不洗，怎么洗有以下几种情况：

1.不洗，将每天的结束与第二天的结束连一条费用为0，容量为无穷的边（表示提供的脏餐巾数目）

2.快洗，将每天的结束向洗好后的开始连一条容量无穷，费用为快洗费用的边

3.慢洗，将每天的结束向洗好后的开始连一条容量无穷，费用为慢洗费用的边

建图完成

其余套板子就没问题~~（注意开longlong）~~

## 【AC代码】
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn=100010;
const int maxm=300010;
const ll INF=0x7fffffff;
struct Edge
{
    int to;
    int next;
    ll w;  //费用
    ll f;  //容量
}edge[maxm];
int dis[maxn];
int cur[maxm]; //当前弧优化
int head[maxm];
bool vis[maxn];
int n,t,cnt;
inline void init()  //数组初始化
{
    n=t=cnt=0;
    memset(cur,-1,sizeof(cur));
    memset(dis,0x3f,sizeof(dis));
    memset(head,-1,sizeof(head));
    memset(vis,false,sizeof(vis));
}
inline void Insert(int u,int v,ll w,ll f)
{
    edge[cnt].to=v;
    edge[cnt].next=head[u];
    edge[cnt].w=w;
    edge[cnt].f=f;
    head[u]=cnt++;
}
inline void insert(int u,int v,ll w,ll f)
{
    Insert(u,v,w,f);  //正向边
    Insert(v,u,-w,0); //反向边
}
inline bool spfa()  //网络流标准最短路
{
    memset(dis,0x3f,sizeof(dis));
    memset(vis,false,sizeof(vis));
    queue<int> que;
    que.push(0);
    dis[0]=0;
    vis[0]=true;
    while(!que.empty())
    {
        ll u=que.front();
        que.pop();
        vis[u]=false;
        for(int i=head[u];~i;i=edge[i].next)
        {
            int v=edge[i].to;
            if(edge[i].f&&dis[v]>dis[u]+edge[i].w)
            {
                dis[v]=dis[u]+edge[i].w;
                if(!vis[v])
                {
                    que.push(v);
                    vis[v]=true;
                }
            }
        }
    }
    return dis[t]==0x3f3f3f3f;
}
inline ll dfs(int u,ll flow,ll& Min)  //网络流标准搜索
{
    if(u==t) return flow;
    ll res=flow;
    vis[u]=true;
    for(int i=cur[u];~i;i=edge[i].next)
    {
        cur[u]=edge[i].next;
        int v=edge[i].to;
        if(!vis[v]&&edge[i].f&&dis[v]==dis[u]+edge[i].w)
        {
            ll temp=dfs(v,min(res,edge[i].f),Min);
            edge[i].f-=temp;
            edge[i^1].f+=temp;
            Min+=temp*edge[i].w;
            res-=temp;
            if(res==0) break;
        }
    }
    vis[u]=false;
    return flow-res;
}
inline void solve()
{
    init();
    scanf("%d",&n);
    t=n<<1|1;  //汇点
    for(int i=1;i<=n;++i)
    {
        ll x;
        scanf("%lld",&x);
        insert(0,i,0,x);  //源点向每天结束连上一条容量为所需餐巾的边，表示提供的脏餐巾数
        insert(i+n,t,0,x);  //每天开始向汇点连一条容量为所需餐巾的边，表示提供的新餐巾数
    }
    int a,b;
    ll p,f,s;
    scanf("%lld%d%lld%d%lld",&p,&a,&f,&b,&s);
    for(int i=1;i<=n;++i)
    {
        insert(0,i+n,p,INF);  //从源点购买餐巾
        if(i+1<=n) insert(i,i+1,0,INF);  //不洗餐巾
        if(i+a<=n) insert(i,i+n+a,f,INF); //快洗餐巾
        if(i+b<=n) insert(i,i+n+b,s,INF); //慢洗餐巾
    }
    ll flow=0,Min=0;
    while(!spfa())  //跑网络流模板
    {
        memset(vis,false,sizeof(vis));
        for(int i=0;i<cnt;++i) cur[i]=head[i];
        flow+=dfs(0,INF,Min);
    }
    printf("%lld\n",Min);  //标准输出
}
int main()
{
    solve();
    return 0;
}

```

---

## 作者：灼眼的夏娜 (赞：1)

卡了我整整一天的题啊~~~

当我百思不得其解为什么我的水管子里总是没水（一直输出0）的时候，我一

不小心手欠改了一个地方，然后就出样例了，交上去，A了！

对比前后代码：

前
```cpp
	return dis[T] == inf;
```
后
```cpp
	return dis[T] < inf;
```
~~我就是个智障......~~

网络流，众所周知，难就难在建模，这道题，我们这么想：

早上用过的餐巾会丢到晚上变成脏餐巾，相当于每一天都拆成了两个点，从

$S$到晚上有一条流量为$ri$，费用为0的边，从早上到$T$有一条流量为

$ri$，费用为0的边，而晚上堆积的脏餐巾显然是要洗掉的，那就看看是送到

快洗还是慢洗店于是就可以理解为从当前这一天，到快洗（慢洗）店洗完的

那一天有一条流量为$inf$费用为其所需要的费用，每一天到第二天都可以源

源不断的送过来洗完的脏餐巾，那就是有一条流量为$inf$，费用为0的边，

而如果是买新的餐巾的话，就是一条流量为$inf$，费用为购买的费用的边，

以上建模就完成了，总结一下：

①从源点想每天晚上连一条流量为$ri$，费用为0的边，早上向汇点连一条

同上述的边

②由晚上向第二天早连一条流量为$inf$，费用为0的边

③由晚上向快（慢）洗店洗完的那一天连一条流量为$inf$费用为其花费的边

④由源点向早上连一条流量为$inf$，费用为购买所需费用的边

接下来就是跑一个最小费用流，我把之前$Dinic$的板子改了改就交上去了，

dalao勿喷，以下是代码：

## code
```cpp
#include<iostream>
#include<cstdio>
#include<queue>
#include<algorithm>
#include<cstring>
#define R register
#define inf 2147483647

using namespace std;
typedef long long LL;
const int N = 4e6+5;
int n, p, m, f, d, s;
int S, T, last[N], pos[N], cap[N];
LL dis[N];
struct saber {
	int nxt, to, dis, cap;
}rin[N];
int head[N], cnt = 1;
bool vis[N];
queue<int> q;

inline bool spfa() {
	for(R int i = 0;i <= T;++ i) dis[i] = inf, vis[i] = 0;
	cap[S] = inf, dis[S] = 0, q.push(S);
	while(!q.empty()) {
		R int vi = q.front();
		q.pop();
		vis[vi] = false;
		for(R int i = head[vi]; i ;i = rin[i].nxt) {
			R int vc = rin[i].to;
			if(dis[vc] > dis[vi] + rin[i].dis && rin[i].cap) {
				dis[vc] = dis[vi] + rin[i].dis;
				cap[vc] = min(cap[vi], rin[i].cap);
				pos[vc] = vi;
				last[vc] = i;
				if(!vis[vc]) vis[vc] = true, q.push(vc);
			}
		}
	}
	return dis[T] < inf;
}

inline LL Dinic() {
	LL res = 0;
	while(spfa()) {
		res += dis[T] * cap[T];
		for(R int i = T; i ;i = pos[i]) {
			rin[last[i]].cap -= cap[T];
			rin[last[i] ^ 1].cap += cap[T];
		}
	}
	return res;
}

inline void add(int f, int t, int c, int d) {
	rin[++cnt].to = t, rin[cnt].dis = d, rin[cnt].cap = c, rin[cnt].nxt = head[f], head[f] = cnt;
	rin[++cnt].to = f, rin[cnt].dis = -d, rin[cnt].cap = 0, rin[cnt].nxt = head[t], head[t] = cnt;
}

int main() {
	scanf("%d",&n);
	S = 0, T = 2 * n + 1;
	for(R int i = 1, x;i <= n;++ i) {
		scanf("%d",&x);
		add(S, i, x, 0);
		add(i + n, T, x, 0);
	}
	scanf("%d%d%d%d%d",&p, &m, &f, &d, &s);
	for(R int i = 1;i <= n;++ i) {
		if(i + 1 <= n) add(i, i + 1, inf, 0);
		if(i + m <= n) add(i, i + m + n, inf, f);
		if(i + d <= n) add(i, i + d + n, inf, s);
		add(S, i + n, inf, p);
	}
	printf("%lld",Dinic());
	return 0;
}
```


---

## 作者：7KByte (赞：1)

这道题确实有点难度，如果不是网络流24恐怕很少人会想到网络流  
1.这题没有关于限制流量的条件  
2.这题没有关于两种状态之间联通不连通的要求（即割  
3.这题没有关于不相交的匹配的问题  
但这题毕竟是网络流24，还是要用网络流做（手动滑稽


---------------

我们不一定要将最大流量作为答案，而是将最大流量作为前提，很明显，将最大流作为前提的就是费用流的模型  
将问题抽象一下，就是每天需要$r_i$张干净餐巾，同时每天会产生$r_i$张脏纸巾，可以直接购买干净纸巾，也可以通过清洗将脏纸巾转化为干净纸巾  
于是我们将每一天拆成两个节点  



**从原点向其中的一个节点连容量$r_i$，费用0的边，表示每天产生$r_i$张脏餐巾，下文简称入点**  
**另一个节点向汇点连容量$r_i$，费用0的边，表示每天需要$r_i$张干净餐巾，下文简称出点**  
**第i天的入点向第i+1天的入点连容量INF，费用0的边，表示今天的脏餐巾留到明天**  
**第i天的入点向第i+m天的出点连容量INF，费用f的边，向i+n天的出点连容量INF，费用s的边，表示清洗纸巾**  
**从源点向第i天的出点连容量INF，费用p的边，表示购买纸巾，（特别注意不是从入点连向出点，因为这一天只有先用了干净餐巾才会产生脏餐巾）**  


然后直接逃模板最小费用最大流，最大流保证了每天都有$r_i$张干净餐巾  


**代码**
```cpp
#include<bits/stdc++.h>
#define INF (1ll<<50)
#define int long long
using namespace std;
struct edge{
    int to,next;
    int data,cost;
}e[200000];
int h[10000],pop=1,n,m,s=8000,t=9000,maxflow=0,ans=0;
void add(int x,int y,int z,int r){
    pop++;
    e[pop].to=y;e[pop].cost=r;e[pop].data=z;e[pop].next=h[x];h[x]=pop;
    pop++;
    e[pop].to=x;e[pop].cost=-r;e[pop].data=0;e[pop].next=h[y];h[y]=pop;
}
int flow[10000],d[10000],last[10000],v[10000];
bool spfa(){
    memset(flow,0,sizeof(flow));
    memset(last,0,sizeof(last));
    fill(d,d+10000,INF);
    memset(v,0,sizeof(v));
    flow[s]=INF;
    d[s]=0;v[s]=1;
    queue<int>q;
    q.push(s);
    while(q.size()){
        int x=q.front(),y;q.pop();v[x]=0;
        for(int i=h[x];i;i=e[i].next){
            if(!e[i].data)continue;
            if(e[i].cost+d[x]<d[y=e[i].to]){
                d[y]=d[x]+e[i].cost;
                last[y]=i;flow[y]=min(flow[x],e[i].data);
                if(v[y])continue;
                v[y]=1;q.push(y);
            }
        }
    }
    if(d[t]==INF)return false;
    return true;
}
void updata(){
    maxflow+=flow[t];
    ans+=flow[t]*d[t];
    int k=t;
    while(k!=s){
        int x=last[k];
        e[x].data-=flow[t];
        e[x^1].data+=flow[t];
        k=e[x^1].to;
    }
}
int P,M,F,N,S,r[10000];
signed main()
{
	//freopen("testdata.in","r",stdin);
    scanf("%lld",&n);
    for(int i=1;i<=n;i++)
      scanf("%lld",&r[i]);
    scanf("%lld%lld%lld%lld%lld",&P,&M,&F,&N,&S);
    memset(h,0,sizeof(h));
    for(int i=1;i<=n;i++)
      add(s,i,r[i],0),
      add(i+n,t,r[i],0);
    for(int i=1;i<=n;i++){
        add(s,i+n,INF,P);
        if(i<n)
        add(i,i+1,INF,0);
        if(i+M<=n)
        add(i,i+n+M,INF,F);
        if(i+N<=n)
        add(i,i+n+N,INF,S);
    }
    while(spfa())updata();
    printf("%lld\n",ans);
    return 0;
}
```

---

## 作者：huyufeifei (赞：1)

把题解看了一遍...大家的费用流都是拆成两个点的，那么我就来提供一种新(S)颖(B)而独(N)特(C)的思路：
## 拆成5个点！

首先想到，应该用流量来代表每天的餐巾，这样保证最大流就是保证每天有餐巾。

然后先来个最简单的模型吧。直接排成一排，从源点买，源点向每天连边，费用为购买的钱，不限流。每天向汇点连边，限流表示每天用的餐巾数。洗就是n²枚举后面的天数，与当前点连边，费用为洗的费用。

然后发现不行：你洗的话，一条餐巾就用了两次，这样总流量(买的总餐巾数)就比每天餐巾数之和少了。所以需要额外的流量来处理这个一巾多用的问题。

我有个很朴素的想法：再开一条流量，在连边的时候费用取负，把买的费用减去。

然后发现又挂了：你可能洗多次啊！每次洗都减，那还了得？

这启示我们第二次洗的时候不消除买的钱。

这就要把新买来的和之前洗过的分开处理。

然后我考虑了一会三个点，发现不行，就建了4个点，进来两个，出去两个。

还有个小问题，你洗的数量不可能超过你买的数量吧...因为我从源点那里买的时候流量为INF，所以就要在洗的时候限流。然后又多出来一个点...

到最后每个点拆成了5个点...虽然正确性没问题了但是...

你见过1w个点，n²条边的费用流吗...

大概长这样...

![按住此处拖动到新标签页中，显示图片](https://img2018.cnblogs.com/blog/1332167/201812/1332167-20181206165058561-524199611.png)

看起来比较恐怖......实测TLE，60分。

然后我优化连边一波，把n²连边改成每个5号点之间连流量INF，费用为0的链，就A了!!??

(虽然速度是正解的两倍...)

上代码：
```cpp
#include <cstdio>
#include <queue>
#include <algorithm>
#include <cstring>

typedef long long LL;
const int N = 20014, M = 2500010;
const LL INF = 0x3f3f3f3f3f3f3f3fll;

struct Edge {
    int nex, v;
    LL len, c;
}edge[M << 1]; int top = 1;

int e[N], pre[N], vis[N], Time;
LL d[N], flow[N], use[N];
std::queue<int> Q;

inline void add(int x, int y, LL z, LL w) {
    top++;
    edge[top].v = y;
    edge[top].c = z;
    edge[top].len = w;
    edge[top].nex = e[x];
    e[x] = top;

    top++;
    edge[top].v = x;
    edge[top].c = 0;
    edge[top].len = -w;
    edge[top].nex = e[y];
    e[y] = top;
    return;
}

inline bool SPFA(int s, int t) {
    memset(d, 0x3f, sizeof(d));
    //printf("%lld \n%lld \n\n", d[t], INF);
    d[s] = 0;
    vis[s] = Time;
    flow[s] = INF;
    Q.push(s);
    while(!Q.empty()) {
        int x = Q.front();
        Q.pop();
        vis[x] = 0;
        //printf("d[%d] = %lld \n", x, d[x]);
        for(int i = e[x]; i; i = edge[i].nex) {
            int y = edge[i].v;
            if(edge[i].c && d[y] > d[x] + edge[i].len) {
                d[y] = d[x] + edge[i].len;
                flow[y] = std::min(flow[x], edge[i].c);
                pre[y] = i;
                if(vis[y] != Time) {
                    vis[y] = Time;
                    Q.push(y);
                }
            }
        }
    }
    //printf("d < INF d = %lld %d \n", d[t], d[t] < INF);
    return d[t] < INF;
}

inline void update(int s, int t) {
    LL f = flow[t];
    //printf("update : f = %lld \n", f);
    while(s != t) {
        //printf("t = %d \n", t);
        int i = pre[t];
        edge[i].c -= f;
        edge[i ^ 1].c += f;
        t = edge[i ^ 1].v;
    }
    return;
}

inline LL solve(int s, int t, LL &cost) {
    LL ans = 0;
    cost = 0;
    memset(vis, 0, sizeof(vis));
    Time = 1;
    while(SPFA(s, t)) {
        ans += flow[t];
        cost += flow[t] * d[t];
        //printf("f = %lld  d = %lld \n", flow[t], d[t]);
        //printf("cost = %lld \n", cost);
        update(s, t);
        Time++;
    }
    return ans;
}

int n;
inline int id(int i, int k) {
    return (k - 1) * n + i;
}

int main() {
    int quick, slow;
    LL sc, buy, qc;
    scanf("%d", &n);
    int s = n * 5 + 1, t = n * 5 + 2;
    for(int i = 1; i <= n; i++) {
        scanf("%lld", &use[i]);
    }
    scanf("%lld%d%lld%d%lld", &buy, &quick, &qc, &slow, &sc);

    for(int i = 1; i <= n; i++) {
        add(s, i, INF, buy);
        add(id(i, 3), t, use[i], 0);
        add(i, id(i, 3), use[i], 0);
        add(id(i, 2), id(i, 3), use[i], 0);
        add(i, id(i, 4), use[i], -buy);
        add(id(i, 2), id(i, 4), use[i], 0);
        add(id(i, 4), id(i, 5), use[i], 0);
        /*for(int j = i + quick; j <= n; j++) {
            add(id(i, 5), id(j, 2), INF, qc);
        }
        for(int j = i + slow; j <= n; j++) {
            add(id(i, 5), id(j, 2), INF, sc);
        }*/
        if(i + quick <= n) {
            add(id(i, 5), id(i + quick, 2), INF, qc);
        }
        if(i + slow <= n) {
            add(id(i, 5), id(i + slow, 2), INF, sc);
        }
        if(i < n) {
            add(id(i, 5), id(i + 1, 5), INF, 0);
        }
    }

    LL cost;
    solve(s, t, cost);
    printf("%lld", cost);
    return 0;
}
```

---

## 作者：Orion545 (赞：1)

好题啊！

既可以用上下界费用流碾过去，训练对这个算法的适应能力，也可以用特殊思想（拆点）转化为普通费用流做，在24题里面也算是优秀的了！


### 建议点进题解里的你先自己思考一番，做出一些尝试，实在想不出来再看题解。不要浪费了这道好题！


[安利一波博客](http://www.cnblogs.com/dedicatus545/p/8387692.html)


## 思路


这道题乍一看，可以跑上下界费用流


代码量、难度 -> inf


其实不然，我们可以用费用流的特殊处理去掉下界


观察题目，每天要求有ri块餐巾


首先，有贪心如下：


当且仅当每天可供使用的餐巾正好满足需求时，可以有最小费用


证明：若某一天有多一块餐巾，则其根本来源一定是买多了，而且在这块餐巾参与的周转中还消费了一些清洗费用，同时它造成其余的日子里也会有餐巾被闲置


因此首先把题目转化为“每天正好使用ri”


此时考虑拆点，将每一天拆成xi,yi，其中yi连边到T，容量为ri，费用为0，表示该天需要这么多餐巾。（以下这类边表示为 (cap,cost) ）



## 建图


建图的核心是保证yi到T的边可以满流的情况下，构建费用等同于题目要求的网络。


首先定义xi为“第i天对于用完的餐巾做出的决策”，因此可以从xi到xi+1连一条边 (inf,0)，其边上的流量表示“第i+1天保留第i天中（流量）块餐巾的决策”


然后从S到xi连边 (ri,0) ，代表该天需要做出这一决策的餐巾数量，也就是该天使用了的餐巾数量


从S到yi连边(inf,p)代表新买一块。这块餐巾不需要参与xi的“旧餐巾决策”，直接连到yi


从xi到yi+m、yi+n分别连边 (inf,f) (inf,s) ，代表快洗和慢洗决策。


然后在这张图上跑S-T最小费用最大流即可


## 小结


本题通过每一天的拆点，将上下界中的下界，转化为了两个点之间的间接联系来做。其实很多上下界费用流的题目都可以运用这样的思想。


Code：


```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>
#define inf 100000000000000LL
#define ll long long
using namespace std;
inline ll read(){
    ll re=0,flag=1;char ch=getchar();
    while(ch>'9'||ch<'0'){
        if(ch=='-') flag=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9') re=(re<<1)+(re<<3)+ch-'0',ch=getchar();
    return re;
}
ll n,m,cnt,ans,flow,first[100010];
ll dis[100010],pre[100010],path[100010];
struct edge{
    ll to,next,w,cap;
}a[100010];
inline void add(ll u,ll v,ll w,ll cap){
    a[++cnt]=(edge){v,first[u],w,cap};first[u]=cnt;
    a[++cnt]=(edge){u,first[v],-w,0};first[v]=cnt;
}
void init(){
    memset(first,-1,sizeof(first));
    memset(a,0,sizeof(a));cnt=-1;ans=0;flow=0;
}
ll spfa(ll s,ll t){
    ll q[10010],head=0,tail=1,maxn=10000,i,u,v,w;
    memset(pre,-1,sizeof(pre));
    for(i=s;i<=t;i++) dis[i]=inf;
    q[0]=s;dis[s]=0;
    while(head!=tail){
        u=q[head];head=(head+1)%maxn;
        for(i=first[u];~i;i=a[i].next){
            v=a[i].to;w=a[i].w;
            if(a[i].cap&&dis[v]>dis[u]+w){
                dis[v]=dis[u]+w;
                pre[v]=u;path[v]=i;
                q[tail]=v;tail=(tail+1)%maxn;
            }
        }
    }
    return ~pre[t];
}
inline ll _min(ll l,ll r){return (l<r)?l:r;}
ll mcmf(ll s,ll t){
    ll f,u;
    while(spfa(s,t)){
        f=inf;
        for(u=t;u!=s;u=pre[u]) f=_min(f,a[path[u]].cap);
        flow+=f;ans+=dis[t]*f;
        for(u=t;u!=s;u=pre[u]){
            a[path[u]].cap-=f;
            a[path[u]^1].cap+=f;
        }
    }
}
int main(){
//    freopen("napkin.in","r",stdin);
//    freopen("napkin.out","w",stdout);
    init();
    ll i,t1,t2;
    n=read();
    for(i=1;i<=n;i++){
        t1=read();
        add(0,i,0,t1);
        add(i+n,(n<<1)+1,0,t1);、
        //S -> xi , yi -> T
    }
    for(i=1;i<n;i++) add(i,i+1,0,inf);
    // xi -> xi+1
    t1=read();
    for(i=1;i<=n;i++) add(0,i+n,t1,inf);
    // S -> yi，购买
    t1=read();t2=read();
    for(i=1;i<=n-t1;i++) add(i,i+t1+n,t2,inf);
    //快洗
    t1=read();t2=read();
    for(i=1;i<=n-t1;i++) add(i,i+t1+n,t2,inf);
    //慢洗
    mcmf(0,(n<<1)+1);
    printf("%lld",ans);
}
```

---

## 作者：t0vd (赞：1)

费用流卡不过去怎么办？

我们可能需要一种 $O(n\log^2 n)$ 的算法。

考虑逐单位流量增广费用流的过程，每增广一单位流量，增加的费用是不减的。

如果要求最小费用可行流，可以二分出增加费用大于 $0$ 的流量，然后求这个流量下的最小费用。

求特定流量下的最小费用，在这个问题中就是用给定数量的餐巾分配给每天使得满足要求的最小费用。

这个问题可以贪心，用并查集优化可以做到 $O(n\log n)$。

于是总复杂度就是 $O(n\log^2 n)$ 了。


---

## 作者：KKarshilov (赞：1)

这题用zkw是真的快……但是现在时间到4s了，又有o2和高性能，貌似普通的费用流也可以过了，大胆的发一发题解，首先，要把每一天和源点汇点建一条容量为每天的需求的边，费用为0，然后在条件满足的情况下（i + n < num of days之类的），向快洗之后那天建容量INF费用f的边，慢洗也是，注意要和下一天建边，容量INF费用0，因为可以不洗……所以还是要拆点，至于新买的，自然费用为price，容量inf，就这些

代码：







```cpp
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <functional>
#include <queue>
using namespace std;
int cnt=1,nd,price,m,f,n,s,ans;
bool inq[2005];
const int INF = 0x3f3f3f3f;
const int MAXN = 80003;
const int MAXE = 160003;
struct Edge {
    int from, to, nxt, cap, flow, cost;
    Edge() {}
    Edge(int from, int to, int nxt, int cap, int flow, int cost):from(from), to(to), nxt(nxt), cap(cap), flow(flow), cost(cost) {}
}e[MAXE];
int h[MAXN], p;
int source, sink;
int cur[MAXN];
int d[MAXN];
queue<int> q;
bool exist[MAXN];
inline void add_edge(int x, int y, int cap, int cost) {
    e[p] = Edge(x, y, h[x], cap, 0, cost); h[x] = p++;
    e[p] = Edge(y, x, h[y], 0, 0, -cost); h[y] = p++;
}
bool SPFA() {
    memset(d, 0x3f, sizeof(d));
    memset(exist, 0, sizeof(exist));
    memset(cur, -1, sizeof(cur));
    q.push(source);
    d[source] = 0;
    exist[source] = 1;
    while(!q.empty()) {
        int u = q.front(); q.pop();
        exist[u] = 0;
        for(int i = h[u]; ~i; i = e[i].nxt) {
            int v = e[i].to;
            if(e[i].cap > e[i].flow && d[v] > d[u] + e[i].cost) {
                d[v] = d[u] + e[i].cost;
                cur[v] = i;
                if(!exist[v]) {
                    q.push(v);
                    exist[v] = 1;
                }
            }
        }
    }
    return d[sink] != INF;
}
long long MCMF() {
    long long cost = 0;
    while(SPFA()) {
        int flow = INF;
        for(int i = sink; i != source; i = e[cur[i]].from) flow = min(flow, e[cur[i]].cap - e[cur[i]].flow);
        for(int i = sink; i != source; i = e[cur[i]].from) {
            e[cur[i]].flow += flow;
            e[cur[i] ^ 1].flow -= flow;
        }
        cost += flow * d[sink];
    }
    return cost;
}
int main()
{
    memset(h, -1, sizeof(h));
    scanf("%d", &nd);
    int x;source = 0; sink = 8000;
    for(int i = 1; i <= nd; i++)
    {
            scanf("%d",&x);
            add_edge(source, i, x, 0);//连源点汇点
            add_edge(nd + i, sink, x, 0);
    }
    scanf("%d%d%d%d%d", &price, &m, &f, &n, &s);
    for(int i = 1; i <= nd; i++)
    {
        if(i + 1 <= nd)add_edge(i, i + 1, INF, 0);//留到明天
        if(i + m <= nd)add_edge(i, nd + i + m, INF, f);//快洗
        if(i + n <= nd)add_edge(i, nd + i + n, INF, s);//慢洗
        add_edge(source, nd+i, INF, price);//新买
    }
    printf("%d\n",MCMF());
    return 0;
}

```

---

## 作者：Ireliaღ (赞：0)

不少大佬写了zkw费用流，但由于我太菜了，不管是建图还是板子都看得我一脸蒙，所以我来说一下我的做法

首先把每一天拆成早晚两个点，然后根据题意往超级原点和汇点连边就行了，具体可以看我代码，最小费用最大流，也用的zkw费用流

```cpp
// luogu-judger-enable-o2
#include <bits/stdc++.h>
#define int int64_t
//int64_t长得比long long好看
using namespace std;

const int MAXN = 2e3 + 5;
const int INF = 0x3f3f3f3f;

int n;

struct Edge{
    int to, val, cost;
    Edge *next, *ops;
    Edge(int to, int val, int cost, Edge *next): to(to), val(val), cost(cost), next(next){}
};

Edge *head[MAXN << 1];

void AddEdge(int u, int v, int w, int c) {
    head[u] = new Edge(v, w, c, head[u]);
    head[v] = new Edge(u, 0, -c, head[v]);
    head[u]->ops = head[v]; head[v]->ops = head[u];
}

namespace zkw{
    int s, t, ans, res;
    int dis[MAXN << 1];
    bool vis[MAXN << 1];
    bool Spfa() {
        memset(vis, false, sizeof vis);
        memset(dis, 0x3f, sizeof dis);
        deque<int> q;
        q.push_back(s);
        vis[s] = true; dis[s] = 0;
        while (!q.empty()) {
            int u = q.front(); q.pop_front(); vis[u] = false;
            for (Edge *e = head[u]; e; e = e->next) {
                int v = e->to;
                if (e->val > 0 && dis[u] + e->cost < dis[v]) {
                    dis[v] = dis[u] + e->cost;
                    if (!vis[v]) {
                        vis[v] = true;
                        if (!q.empty() && dis[v] < dis[q.front()]) q.push_front(v);
                        else q.push_back(v);
                    }
                }
            }
        }
        return dis[t] < INF;
    }
    
    int Dfs(int u, int flow) {
        if (u == t) {
            vis[u] = true;
            res += flow;
            return flow;
        }
        int used = 0; vis[u] = true;
        for (Edge *e = head[u]; e; e = e->next) {//当前弧就不加了
            int v = e->to;
            if ((!vis[v] || v == t) && e->val && dis[u] + e->cost == dis[v]) {
                int mi = Dfs(v, min(e->val, flow - used));
                if (mi) {
                    e->val -= mi;
                    e->ops->val += mi;
                    ans += e->cost * mi;
                    used += mi;
                }
                if (used == flow) break;
            }
        }
        return used;
    }
    
    void Work() {
        res = 0; ans = 0;
        while (Spfa()) {
            vis[t] = true;
            while (vis[t]) {
                memset(vis, false, sizeof vis);
                Dfs(s, INF);
            }
        }
    }
}

signed main() {
    cin >> n;
    zkw :: s = 0; zkw :: t = n * 2 + 1;
    for (int i = 1; i <= n; i++) {
        int x;
        cin >> x;
        AddEdge(0, i, x, 0);//每天获得x个脏的
        AddEdge(n + i, n * 2 + 1, x, 0);//每天生成x个干净的
    }
    int m, t1, m1, t2, m2;
    cin >> m >> t1 >> m1 >> t2 >> m2;
    for (int i = 1; i <= n; i++) {
        if (i + 1 <= n) AddEdge(i, i + 1, INF, 0);//可以把脏的拖到第二天洗
        if (i + t1 <= n) AddEdge(i, i + n + t1, INF, m1);//快洗
        if (i + t2 <= n) AddEdge(i, i + n + t2, INF, m2);//慢洗
        AddEdge(0, i + n, INF, m);//买新的
    }
    zkw :: Work();
    cout << zkw :: ans << endl;
    return 0;
}
```

---

## 作者：arfa (赞：0)

思路上方的大佬讲的很清楚了,当然把出入点改成黑白天是一个不错的技巧。

- 很显然这一天的脏纸巾可以留到明天,也可以留到快洗部和慢洗部。
- 很显然我可以从买,快洗部和慢洗部这三个地方来拿纸巾。
- 也很显然每天会用掉一些纸巾
- 更显然的是这满足流和费用的性质

代码如下:

```pascal
// luogu-judger-enable-o2
Uses math;

var
    from,reach,next,value,cost:array[-1..50010] of longint;
    dis,pre,last,flow:array[-1..50010] of int64;
    queue:array[-1..50010] of longint;
    cnt:array[-1..8100] of longint;
    vis:array[-1..8100] of boolean;
    time,money:array[1..2] of longint;
    n,m,i,j,k,tot,now,node,sink,source:longint;
    maxflow,mincost:int64;

procedure add(x,y,sum_1,sum_2:longint);
begin
    inc(tot); from[tot]:=x; reach[tot]:=y; value[tot]:=sum_1; cost[tot]:= sum_2; next[tot]:=cnt[x]; cnt[x]:=tot;
    inc(tot); from[tot]:=y; reach[tot]:=x; value[tot]:=0    ; cost[tot]:=-sum_2; next[tot]:=cnt[y]; cnt[y]:=tot;
end;

function spfa:boolean;
var head,tail,now,i:longint;
begin
    filldword(dis,sizeof(dis) div 4,maxlongint);
    filldword(flow,sizeof(flow) div 4,maxlongint);
    filldword(vis,sizeof(vis) div 4,0);
    head:=1; tail:=1;  queue[1]:=source; vis[source]:=True; dis[source]:=0; pre[sink]:=-1;

    while head<=tail do
    begin
        now:=queue[head]; vis[now]:=False; inc(head);
        i:=cnt[now];
        while i<>-1 do
        begin
            if (value[i]>0)and(dis[reach[i]]>dis[now]+cost[i]) then
            begin
                dis[reach[i]]:=dis[now]+cost[i];
                pre[reach[i]]:=now;
                last[reach[i]]:=i;
                flow[reach[i]]:=min(flow[now],value[i]);
                if vis[reach[i]]=False then
                begin
                    vis[reach[i]]:=True;
                    inc(tail); queue[tail]:=reach[i];
                end;
            end;
            i:=next[i];
        end;
    end;
    if pre[sink]=-1 then exit(False); exit(True);
end;

procedure MincostMaxflow;
begin
    maxflow:=0; mincost:=0; now:=0;
    while (spfa) do
    begin
        now:=sink;
        inc(maxflow,flow[sink]);
        inc(mincost,flow[sink]*dis[sink]);
        while now<>source do
        begin
            dec(value[last[now]],flow[sink]);
            inc(value[last[now] xor 1],flow[sink]);
            now:=pre[now];
        end;
    end;
end;

procedure Clear;
begin
    filldword(cnt,sizeof(cnt) div 4,maxlongint*2+1); tot:=1;
    fillchar(value,sizeof(value),0);
    fillchar(reach,sizeof(reach),0);
    fillchar(cost,sizeof(cost),0);
    fillchar(next,sizeof(next),0);
end;

procedure Construction_I;
begin
    source:=1; sink:=(n+1) << 1;
    for i:=1 to n do begin read(k); add(source,i+1,k,0); add(i+n+1,sink,k,0); end;
    read(k,time[1],money[1],time[2],money[2]);
    for i:=1 to n do
    begin
        if i+2<=n+1 then add(i+1,i+2,maxlongint,0);
        if i+1+times[1]<=n+1 then add(i+1,i+times[1],maxlongint,money[1]);
        if i+1+times[2]<=n+1 then add(i+1,i+times[2],maxlongint,moeny[2]);
        add(source,i+n+1,maxlongint,k);
    end;
end;

begin
    read(n); 
    Clear; Construction_I; MincostMaxflow; writeln(mincost);
end.
```

---

## 作者：FREEH (赞：0)

### 【题目】
![题目](https://cdn.luogu.com.cn/upload/pic/25941.png)
### 【构图】
- 首先，要进行拆点。把每一天拆分成am和pm，上午就是用干净餐巾，下午就是处理脏餐巾。具体构图如下（源点为S，汇点为T）：
	- 用毛巾
    	- S与每一天上午连一条流量为ri，费用为0的边，每一天下午与T连接一条流量为ri，费用为0的边。 _**表示每一天上午要给出ri条干净毛巾，下午得到ri条脏毛巾**_ 。
        
    - 处理毛巾
    	1. 不洗：每一个下午的点与下一天下午的点连接一条无限流量，费用为0的边，**表示当天下午的脏毛巾可以堆积到下一天的下午再处理**。
        1. 快洗：每一天下午的点与快洗期限后的一天连接一条无限流量，费用为快洗费用的边。
        1. 慢洗：与快洗同理。
        1. 买毛巾：S与每一天上午连一条无限流量，费用为买毛巾费用的边。
        
### 【解题反思】
- 当遇到一天有多种处理的题目时，要考虑使用**拆点**。
- 搞无穷大时要注意全局变量！！！

### 【参考程序】
```cpp
#include<cstdio>
#include<queue>
#include<iostream>
#include<cstring>
#define am(x)(n+(x))
#define pm(i) i
#define INF 2000000000
typedef long long LL;
#define int LL
using namespace std;

int cur=1,n,m,s,t,mcost,mflow,nmon,qtim,qmon,stim,smon;
int head[50005],dis[50005],flow[50005],pre[50005];
struct EDGE{
    int t,next,w,f;
}e[1000005];
void add(int a,int b,int w,int f)
{
    cur++;e[cur].t=b;e[cur].next=head[a];e[cur].w=w;e[cur].f=f;head[a]=cur;
    cur++;e[cur].t=a;e[cur].next=head[b];e[cur].w=0;e[cur].f=-f;head[b]=cur;
}

queue < int > q;
bool vis[5005];
bool SPFA(int s,int t)
{
    for (int i=1;i<=t;i++)
    	dis[i]=INF;
    memset(vis,0,sizeof vis);
    vis[s]=1;
    flow[s]=INF;
    memset(vis,0,sizeof vis);
    q.push(s);
    while (!q.empty())
    {
        int u=q.front();q.pop();
        vis[u]=false;
        for (int h=head[u];h!=-1;h=e[h].next)
        {
            int v=e[h].t,f=e[h].f;
            if (e[h].w&&dis[u]+f<dis[v])//如果边还有流量就尝试更新
            {
                dis[v]=dis[u]+f;//更新最短路径
                flow[v]=min(flow[u],e[h].w);//尽可能地流水
                pre[v]=h;//记录路径
                if (!vis[v])
                {
                    vis[v]=true;
                    q.push(v);
                }
            }
        }
    }
    return dis[t]!=INF;
}

void Update(int s,int t)
{
    int x=t;
    while (x!=s)
    {
        int i=pre[x];
        e[i].w-=flow[t];
        e[i^1].w+=flow[t];
        x=e[i^1].t;
    }//沿着记录下的路径并进行增广路
    mcost+=flow[t]*dis[t];//累计费用
}
void E_K(int s,int t)
{
    while (SPFA(s,t))//当还有多余流量时
        Update(s,t);
}

signed main()
{
    scanf("%lld",&n);
    s=0;t=2*n+1;
    memset(head,-1,sizeof head);
    for (int i=1;i<=n;i++)
    {
        int x;
        scanf("%lld",&x);
        add(s,pm(i),x,0);
        add(am(i),t,x,0);
    }
    scanf("%lld%lld%lld%lld%lld",&nmon,&qtim,&qmon,&stim,&smon);
	for (int i=1;i<=n;i++)
	{
		if (i+1<=n)
			add(pm(i),pm(i+1),INF,0);
		if (i+qtim<=n)
			add(pm(i),am(i+qtim),INF,qmon);
		if (i+stim<=n)
			add(pm(i),am(i+stim),INF,smon);
		add(s,am(i),INF,nmon);
	}
    E_K(s,t);
   	printf("%lld",mcost);
    return 0;
} 
```

---

## 作者：爱喝敌敌畏 (赞：0)

### 这道题，是我做24题的第一题

唉╮(╯▽╰)╭，说什么呢，作为蒟蒻的我=_=。

先说建模吗：

首先，我们拆点，将一天拆成晚上和早上，每天晚上会受到脏餐巾，早上跟晚上的毛巾的质量是不一样的。

1.从原点向每一天晚上连一条流量为当天所用餐巾x，费用为0的边，表示每天晚上从起点获得x条脏餐巾。

2.从每一天早上向汇点连一条流量为当天所用餐巾x，费用为0的边，表示每天白天向汇点提供x条干净的餐巾,满流时表示第i天的餐巾够用了 。

3.从每一天晚上向第二天晚上连一条流量为999999999，费用为0的边，表示每天晚上可以将用废的餐巾留到第二天晚上。

4.从每一天晚上向从这一天扔到快洗结束的那一天早上连一条流量为999999999，费用为快洗店所需要的钱数的边，表示每天晚上可以送去快洗部,在第i+t1天早上收到餐巾 。

5.同理，从每一天晚上从这一天扔到慢洗结束的那一天早上连一条流量为999999999，费用为慢洗店所用钱数的边，表示每天晚上可以送去慢洗部,在第i+t2天早上收到餐巾 。

6.从起点向每一天早上连一条流量为999999999，费用为购买餐巾所用钱数的边，表示每天早上可以购买餐巾 。

在注意不要超过n就行了。

然而、、、

非常尴尬，一个标准的ZKW炸了5个点，连续SPFA万岁！

```cpp
#include<cstdio>
#include<cstring>
using  namespace  std;
typedef  long  long  ll;
struct  node
{
    ll  y,next,other,c,d;
}a[210000];ll  last[5100],len,n,m,x1,x2,y1,y2,flow[5100],dis[5100],d[5100],b[5100],st,ed,cost,ans;
bool  v[5100];
ll  list[5100],head,tail;
inline  ll  mymin(ll  x,ll  y){return  x<y?x:y;}
void  ins(ll  x,ll  y,ll  c,ll  d)
{
    len++;
    a[len].y=y;a[len].c=c;a[len].d=d;a[len].next=last[x];last[x]=len;
    len++;
    a[len].y=x;a[len].c=0;a[len].d=-d;a[len].next=last[y];last[y]=len;
    a[len].other=len-1;
    a[len-1].other=len;
}
bool  spfa()
{
    memset(v,true,sizeof(v));v[st]=false;
    memset(dis,20,sizeof(dis));dis[st]=0;
    head=1;tail=2;list[head]=st;
    ll  inf=dis[st+1];
    while(head!=tail)
    {
        ll  x=list[head];
        for(ll  k=last[x];k;k=a[k].next)
        {
            ll  y=a[k].y;
            if(a[k].c>0  &&  dis[x]+a[k].d<dis[y])
            {
                dis[y]=dis[x]+a[k].d;
                flow[y]=mymin(flow[x],a[k].c);
                d[y]=x;b[y]=k;
                if(v[y]==true)
                {
                    v[y]=false;
                    if(dis[list[head+1]]>dis[y])
                    {
                        ll  all=head;
                        head--;if(head==0)head=n;
                        list[head]=list[all];list[all]=y;
                    }
                    else
                    {
                        list[tail++]=y;if(tail==n+1)tail=1;
                    }
                }
            }
        }
        head++;v[x]=true;
        if(head==n+1)head=1;
    }
    if(dis[ed]!=inf)
    {
        ll  y=ed,root=0;
        while(y>0)
        {
            root=b[y];y=d[y];
            a[root].c-=flow[ed];a[a[root].other].c+=flow[ed];
        }
        ans+=flow[ed];cost+=flow[ed]*dis[ed];
        return  true;
    }
    return  false;
}
int  main()
{
    scanf("%lld",&n);
    st=0;ed=n*2+1;
    for(ll  i=1;i<=n;i++)
    {
        ll  x;scanf("%lld",&x);
        ins(st,i*2,x,0);ins(i*2-1,ed,x,0);
    }
    scanf("%lld%lld%lld%lld%lld",&m,&x1,&y1,&x2,&y2);
    for(ll  i=1;i<n;i++)
    {
        ins(i*2,i*2+2,999999999,0);
        ins(st,i*2-1,999999999,m);
    }
    ins(st,n*2-1,99999999,m);
    ll  edd=n-x1;
    for(ll  i=1;i<=edd;i++)ins(i*2,(i+x1)*2-1,999999999,y1);
    edd=n-x2;
    for(ll  i=1;i<=edd;i++)ins(i*2,(i+x2)*2-1,999999999,y2);
    flow[st]=999999999;n=n*2+2;
    while(spfa()==true);
    printf("%lld\n",cost);
    return  0;
}
```

---

## 作者：jpwang (赞：0)

其实我比较好奇这道题为什么一般费用流会卡不过去呢？


对于普通的费用流算法是通过不停地spfa寻找最优路径增广的，那么每次spfa的时候常数是很大的，而且贼大，导致一些稠密图是卡不过去的，即使加上什么slf lll优化之类的。


怎么办呢？上zkw费用流就A了，而且速度还是很可观的

```cpp
#include <stdio.h>
#include <string.h>
#define rep(i, st, ed) for (int i = st; i <= ed; i += 1)
#define erg(i, st) for (int i = ls[st]; i; i = e[i].next)
#define fill(x, t) memset(x, t, sizeof(x))
#define min(x, y) (x)<(y)?(x):(y)
#define ll long long
#define INF 0x3f3f3f3f
#define N 4001
#define E N * 21 + 1
struct edge{int x, y, w, c, next;}e[E];
inline int read(){
    char ch = getchar(); int x = 0;
    while (ch > '9' || ch < '0'){
        ch = getchar();
    }
    while (ch <= '9' && ch >= '0'){
        x = (x << 1) + (x << 3) + ch - '0';
        ch = getchar();
    }
    return x;
}
int ls[N];
inline void addEdge(int &cnt, int x, int y, int w, int c){
    cnt += 1; e[cnt] = (edge){x, y, w, c, ls[x]}; ls[x] = cnt;
    cnt += 1; e[cnt] = (edge){y, x, 0, -c, ls[y]}; ls[y] = cnt;
}
int cur[N], vis[N], dis[N];
ll ans;
inline int find(int now, int ed, int mn){
    if (now == ed || !mn){
        return mn;
    }
    int ret = 0;
    vis[now] = 1;
    for (int &i = cur[now]; i; i = e[i].next){
        if (e[i].w > 0 && dis[e[i].y] + e[i].c == dis[now] && !vis[e[i].y]){
            int d = find(e[i].y, ed, min(mn - ret, e[i].w));
            ans += d * e[i].c;
            e[i].w -= d;
            e[i ^ 1].w += d;
            ret += d;
            if (ret == mn){
                break;
            }
        }
    }
    return ret;
}
inline int modify(int st, int ed){
    int mn = INF, inf = INF;
    rep(now, st, ed){
        if (vis[now]){
            erg(i, now){
                if (!vis[e[i].y] && e[i].w > 0){
                    mn = min(mn, -dis[now] + e[i].c + dis[e[i].y]);
                }
            }
        }
    }
    if (mn == inf){
        return 0;
    }
    rep(i, st, ed){
        if (vis[i]){
            dis[i] += mn;
        }
    }
    return 1;
}
inline void zkw(int st, int ed){
    do{
        rep(i, st, ed){
            vis[i] = 0;
            cur[i] = ls[i];
        }
        while (find(st, ed, INF)){
            rep(i, st, ed){
                vis[i] = 0;
                cur[i] = ls[i];
            }
        }
    } while (modify(st, ed));
}
int main(void){
    int n = read();
    int st = 0, ed = n * 2 + 1;
    int edgeCnt = 1;
    rep(i, 1, n){
        int r = read();
        addEdge(edgeCnt, st, i, r, 0);
        addEdge(edgeCnt, i + n, ed, r, 0);
    }
    int ap = read(), am = read(), af = read(), an = read(), as = read();
    rep(i, 1, n){
        addEdge(edgeCnt, st, i + n, INF, ap);
        if (i < n){
            addEdge(edgeCnt, i, i + 1, INF, 0);
        }
        if (i + am <= n){
            addEdge(edgeCnt, i, i + n + am, INF, af);
        }
        if (i + an <= n){
            addEdge(edgeCnt, i, i + n + an, INF, as);
        }
    }
    ans = 0;
    zkw(st, ed);
    printf("%lld\n", ans);
    return 0;
}
```

---


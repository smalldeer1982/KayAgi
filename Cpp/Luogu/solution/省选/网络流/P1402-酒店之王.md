# 酒店之王

## 题目描述

XX 酒店的老板想成为酒店之王，本着这种希望，第一步要将酒店变得人性化。由于很多来住店的旅客有自己喜好的房间色调、阳光等，也有自己所爱的菜，但是该酒店只有 $p$ 间房间，一天只有固定的 $q$ 道不同的菜，每个房间只能住一位客人，每道菜也只能给一位客人食用。

有一天来了 $n$ 个客人，每个客人说出了自己喜欢哪些房间，喜欢哪道菜。但是很不幸，可能做不到让所有顾客满意（满意的条件是住进喜欢的房间且吃到喜欢的菜）。

要怎么分配，能使最多顾客满意呢？

## 说明/提示

#### 数据规模与约定

对于全部的测试点，保证 $1 \leq n,p,q \leq 100$。

## 样例 #1

### 输入

```
2 2 2
1 0
1 0
1 1
1 1
```

### 输出

```
1```

# 题解

## 作者：Godのfather (赞：71)

# 酒店之王解题报告
---
## （一）前置技能
1.[网络流最大流](https://www.luogu.org/problemnew/show/P3376)（$dinic$, $Edmonds-Karp$都可以）

2.建图（邻接链表，反向边^1的小技巧）

达成了 1 阅读本文将很轻松，达成了 2 阅读代码将很轻松

## （二）题目描述
[题目传送门](https://www.luogu.org/problemnew/show/P1402)

简单地阐述一下题意：

有 $n$ 个 $A$ 类节点，$p$ 个 $B$ 类节点， $q$ 个 $C$ 类节点。每个 $A$ 与一个 $B$ 和一个 $C$ 构成一组匹配（每个$A$只能与给定的$B$、$C$匹配，且每个$B$、$C$只能匹配一个$A$）,求最大匹配数。

## （三）解题思路

简化之后的题意很像二分图匹配，二分图匹配是一个点匹配一个点，而本题是一个点匹配两个点。

起先，我是想将 $A$ 类节点放在左边，$B$ 类节点放中， $C$ 类最右。顺着题意用$A$匹配$B$和$C$的，然后发现，这样子根本无法建图!!!

因为题目只给出了$A$——$B$, $A$——$C$的关系，根本不知道$B$与$C$的关系。倘若按上面方式建图的话，$B$和$C$就会成为并列的节点。很明显这是不符合题意的。

那该如何建图呢?

既然已经知道$B$与$A$的关系、$A$与$C$的关系，不妨直接将$A$放在中间，$RT$:

![](https://cdn.luogu.com.cn/upload/pic/47662.png)

如此，得到了一张~~三分~~图，再求此图的最大匹配即可。

### 方法一：匈牙利算法

从$A$出发直接向$B$和$C$跑两次二分图匹配即可。这里不作详细解释。

### 方法二：网络流最大流

按照网络流的正常操作，建立一个超级源点$S$，连接所有$B$，流量为1; 建立一个超级汇点$T$, 使所有$C$都连向$T$，流量为1。再根据题目所给的关系连接$B$——$A$、$A$——$C$。

可能很多同学看到这里都会想：会了会了，然后再跑网络流最大流嘛。

不要以为这样就可以了。这可是~~三分~~图匹配呀，哪有那么简单!

看下面这幅图你就会知道哪里错了。

![](https://cdn.luogu.com.cn/upload/pic/47664.png)

如果光是按上述方法建图的话，那么图就会变成上面那样，最大流跑出来是2。

然而我们知道，最大流不能是2，因为任意$B$、$C$只能匹配一个$A$。

如何解决上述问题呢?

很简单，只需要将$A$拆分为两个点即可，$RT$。

![](https://cdn.luogu.com.cn/upload/pic/47669.png)

连接$A$和$A'$,流量为1。

即可避免多个$B$、$C$重复匹配一个$A$的情况了。

终于可以上代码了：（我**太菜了**,不会$dinic$,所以只能写$E-K$了）

```
#include<bits/stdc++.h>
using namespace std;
const int maxn = 105, maxm = 10000005, INF = 2147483647;
int head[maxn<<2], ver[maxm], edge[maxm], Next[maxm], tot;
void add(int x,int y,int z)
{
	ver[++tot] = y, edge[tot] = z, Next[tot] = head[x], head[x] = tot;
	ver[++tot] = x, edge[tot] = 0, Next[tot] = head[y], head[y] = tot;
}
int n, p, q;
//A：1~n, B：n+1~n+p, C：n+p+1~n+p+q, A'：n+p+q+1~n+p+q+n 
int s, t, maxflow, incf[maxn<<2], pre[maxn<<2];bool vis[maxn<<2];
bool bfs()
{
	for(int i=1; i<=n+p+q+n+2; i++) vis[i] = false;
	queue<int> Q;
	Q.push(s), vis[s] = true, incf[s] = INF;
	while(!Q.empty())
	{
		int x = Q.front(); Q.pop();
		for(int i=head[x]; i; i=Next[i])
		   if(edge[i])
		   {
		   	  int y = ver[i];
		   	  if(vis[y]) continue;
		   	  incf[y] = min(incf[x], edge[i]), pre[y] = i;
		   	  vis[y] = true;
		   	  if(y == t) return true;
		   	  Q.push(y);
		   }
	}
	return false;
}
void update()
{
	int x = t;
	while(x!=s)
	{
		int i = pre[x];
		edge[i] -= incf[t];
		edge[i^1] += incf[t];
		x = ver[i^1];
	}
	maxflow+=incf[t];
}
int main()
{
	tot = 1;
	scanf("%d%d%d",&n,&p,&q);
	s = n+p+q+n+1, t = n+p+q+n+2;
	for(int i=1; i<=n; i++)
	   for(int j=1; j<=p; j++)
	   {
		   bool x;
		   scanf("%d",&x); 
		   if(x) add(j+n, i, 1);
	   }
	for(int i=1; i<=n; i++)
	   for(int j=1; j<=q; j++)
	   {
	   	   bool x;
	   	   scanf("%d",&x);
	   	   if(x) add(i+n+p+q, j+n+p, 1);
	   }
	for(int i=1; i<=p; i++) add(s, i+n, 1);
	for(int i=1; i<=q; i++) add(i+n+p, t, 1);
	for(int i=1; i<=n; i++) add(i, i+n+p+q, 1);
	while(bfs()) update();
	printf("%d", maxflow);
	return 0;
}
```

## （四）总结
这道题是一道非常好的题目，它的建图方式很新颖。

网络流的题目考的无非就是建图，只要把图建好了，~~还有什么题搞不掂?~~

最后的最后，今天是2018的最后一天，祝大家在新的一年里**RP++**!更上一层楼!

---

## 作者：YoungNeal (赞：26)

题解在[博客](http://www.cnblogs.com/YoungNeal/p/8570432.html)食用效果更佳哦~

### Solution
第一眼看到就是网络流，但是怎么保证每个人不会被重复(分身)利用，每间房子和每道菜都只用一次呢？

拆点。

但是最开始的思路繁琐了很多，不是把人当做中间点，而是把菜和房间都当作中间点拆开，然后再把人拆开。。 

这样的做法好sb，结果莫名 wa 了三个点，于是瞟了一眼题解，说把人当作中间点，这样只拆人即可。

恍然大悟，从超级源点向每道菜连流量为 1 的边，说明一道菜只能被用一次，同理，从每个房间向超级汇点连流量为 1 的边。然后把人拆点即可。

好题啊~
### Code
```
// By YoungNeal
#include<queue>
#include<cstdio>
#include<cstring>
#include<iostream>
using namespace std;

int s,t,flow;
int a[1005];
int pre[1005];
int head[1005];
int n,p,q,cnt=1;

struct Edge{
    int to,nxt,flow;
}edge[1000005];

void add(int x,int y,int z){
    edge[++cnt].to=y;
    edge[cnt].nxt=head[x];
    edge[cnt].flow=z;
    head[x]=cnt;
}

bool bfs(){
    queue<int> q;
    memset(a,0,sizeof a);
    a[s]=0x3f3f3f3f;
    q.push(s);
    while(q.size()){
        int u=q.front();q.pop();
        for(int i=head[u];i;i=edge[i].nxt){
            int to=edge[i].to;
            if(!edge[i].flow) continue;
            if(a[to]) continue;
            a[to]=min(a[u],edge[i].flow);
            pre[to]=i;
            q.push(to);
        }
    }
    if(!a[t]) return 0;
    flow+=a[t];
    return 1;
}

void update(){
    int m=t;
    for(;pre[m];m=edge[pre[m]^1].to)
        edge[pre[m]].flow-=a[t],edge[pre[m]^1].flow+=a[t];
}

signed main(){
    scanf("%d%d%d",&n,&p,&q);
    s=2*n+q+p+1,t=s+1;
    for(int i=1;i<=n;i++){
        for(int x,j=1;j<=p;j++){
            scanf("%d",&x);
            if(x^1) continue;
            add(j,p+i,1);
            add(p+i,j,0);
        }
    }
    for(int i=1;i<=n;i++){
        for(int x,j=1;j<=q;j++){
            scanf("%d",&x);
            if(x^1) continue;
            add(p+n+q+i,p+n+j,1);
            add(p+n+j,p+n+q+i,0);
        }
    }
    for(int i=1;i<=n;i++) add(p+i,p+n+q+i,1),add(p+n+q+i,p+i,0);
    for(int i=1;i<=p;i++) add(s,i,1),add(i,s,0);
    for(int i=p+1+n;i<=p+n+q;i++) add(i,t,1),add(t,i,0);
    while(bfs()) update();
    printf("%d",flow);
    return 0;
}
```

---

## 作者：Aoki_灏 (赞：11)

萌新第二次弱弱发个题解

~~感觉难得认真做题~~
在dalao帮助下终于懂了建图操作~~

不懂网络流先去[板子](https://www.luogu.org/problemnew/show/P3376)

很容易想到网络流跑一遍最大流

所以这题难点大概就是建图

所以我卡了很久

大家都能想到这个建图
![](https://cdn.luogu.com.cn/upload/pic/16199.png)

其中1.2为房，5 6为人，3.4为菜，500为终点

然后高兴去交 60分emmmmmm

百思不得其解

参考daolao后知道了一些神奇的情况

[感谢这位dalao](https://www.luogu.org/space/show?uid=50971)

像这种情况![](https://cdn.luogu.com.cn/upload/pic/16195.png)

答案应该是1
但这个图跑下来是3

于是就不对了

仔细思考就有了建两个人的点的方法

一个连房子
一个连菜

再加一个点来限流的操作可以保证每个人只选一房一菜

图如下
![](https://cdn.luogu.com.cn/upload/pic/16196.png)

于是就成了！！！！！！
然后就AC了
就是这样

~~虽然我不懂为啥有时建图一样却是错的，大概要注意一下建图顺序大家摸索摸索~~
总之很神奇

样例最终图如下
![](https://cdn.luogu.com.cn/upload/pic/16197.png)

~~看起来和第一个图没啥差别所以我卡了很久~~

然后代码就很简单了
这里dinic

```
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <cstdlib>
#include <queue>
#define N 10003
#define INF (1<<30)
using namespace std;
int head[N],deep[N],ans;
int n,m,n1,m1,m0,ed,st;
int cnt=1;//注意从2开始存，保证异或

struct node
{
    int to,w,fr;
    int _nt;
}edge[N];
void add(int x,int y,int z)//这里前向星
{
    cnt++;
    edge[cnt].to=y;
    edge[cnt]._nt=head[x];
    edge[cnt].w=z;
    head[x]=cnt;
}

int bfs(int s,int t)//传统dinic不解释
{
    memset(deep,0,sizeof(deep));
    queue<int> q;
    q.push(s);
    deep[s]=1;
    while(!q.empty())
    {
        int tmp=q.front();
        q.pop();
        for(int i=head[tmp];i!=-1;i=edge[i]._nt)
        {
            int v=edge[i].to;
           if(deep[v]||edge[i].w<=0)continue;
            deep[v]=deep[tmp]+1;
            q.push(v);
            if(v==t)return 1;
        }

    }
    if(deep[t])return 1;
    else return 0;
}
int dfs(int u,int ed,int flow)
{
    if(u==ed)return flow;
    int ans=0;
    for(int i=head[u];i!=-1&&ans<flow;i=edge[i]._nt)
    {
        int v=edge[i].to;
        if(deep[v]!=deep[u]+1)continue;
        if(!edge[i].w)continue;
        int x=dfs(v,ed,min(edge[i].w,flow-ans));
        edge[i].w-=x;
        edge[i^1].w+=x;
        ans+=x;

    }
    return ans;
}

int dinic(int s,int t)//dinic操作
{
    int sum=0;
    while(bfs(s,t))
        sum+=dfs(s,t,INF);
    return sum;

}
int main()
{

    memset(head,-1,sizeof(head));
    scanf("%d%d%d",&n,&m1,&m0);
    st=0;ed=500;//建源点和汇点
    for(int i=1;i<=m1;i++)//首先建房
    {
        add(0,i,1);
        add(i,0,0);
    }
    for(int i=1;i<=m0;i++)//再建菜
    {
        add(i+m1,ed,1);
        add(ed,i+m1,0);

    }
    for(int i=1;i<=n;i++)//再建两个人
    {
        add(i+m1+m0,i+m1+m0+n,1);
        add(i+m1+m0+n,i+m1+m0,0);
    }
    for(int i=1;i<=n;i++)//再连边，房子的边
    {
        for(int j=1;j<=m1;j++)
        {
            int x;
            scanf("%d",&x);
            if(x==1)
                add(j,i+m1+m0,1),add(i+m1+m0,j,0);
        }
    }
    for(int i=1;i<=n;i++)//再连菜
    {
        for(int j=1;j<=m0;j++)
        {
            int x;
            scanf("%d",&x);
            if(x==1)
             add(i+n+m1+m0,m1+j,1),add(m1+j,i+n+m1+m0,0);
 
               
        }
    }

    printf("%d",dinic(st,ed));//直接输出

    return 0;
}

```

这题可能有玄学建图顺序，大概这样比较保险

然后就讲完了

emmmmmmmmmmm真长（苦笑）

顺便[双倍经验](https://www.luogu.org/problemnew/show/P1231)

估计都能懂吧~


---

## 作者：钱逸凡 (赞：7)

~~这么水真有省选/NOI-吗？
蒟蒻只用了24分钟就秒杀了~~~~~~

## 很明显的最大流（或者说二分图匹配）

不会最大流的[可以去我的洛谷日报捧场](https://www.luogu.org/blog/ONE-PIECE/wang-lao-liu-di-zong-jie)

## 很显然要这么建图：

## s流向房间，房间流向顾客，顾客流向菜，菜流向t，每条边流量限制为1，然后跑最大流。

然而这样可能会错：

请看下图:

![](https://cdn.luogu.com.cn/upload/pic/32626.png)

某顾客一个人霸占了两个房间和两个菜，导致最大流为2（实际应该为1，因为只满足了1个顾客）的情况，我们要限制每个顾客只用一个房间和一个菜

怎么限制呢？

# 主要思想：拆点

为什么？~~刷水题刷多了就很自然的会这么想~~

为了限制容量。  什么意思？

每个顾客肯定只能住一间房间和吃一道菜：

所以我们把一个顾客拆成两个点：入点和出点，然后连一条入点到出点的边，容量限制为1，这样每个顾客就最多只经过一次了，跑出来的最大流就是正解。

刚才那张图拆了点就是这样：
![](https://cdn.luogu.com.cn/upload/pic/32628.png)

图画的很丑，但还是能看懂的（应该吧）


------------

然后就是代码了
## 我写的EK：
```
#include<iostream>
#include<cstring>
#include<cstdio>
#include<queue>
#include<algorithm>
using namespace std;
const int inf=1<<30;
inline int Read(){
	int x=0,f=1;
	char c=getchar();
	while(c>'9'||c<'0'){if(c=='-')f=-1;c=getchar();}
	while(c>='0'&&c<='9')x=x*10+c-'0',c=getchar();
	return x*f;
}
int n,p,q,s,t;
struct Node{
	int v;
	int val;
	int next;
}node[101101];
int head[1010],top=1;
inline void addedge(int u,int v,int val){
	node[++top].v=v;
	node[top].val=val;
	node[top].next=head[u];
	head[u]=top;
}
inline void add(int u,int v,int val){
	addedge(u,v,val);
	addedge(v,u,0);
}
int vis[1010];
struct P{
	int fa;
	int pos;
}pre[101011];
bool bfs(){
	memset(vis,0,sizeof(vis));
	queue<int>q;
	q.push(s);
	while(!q.empty()){
		int u=q.front();
		q.pop();
		for(int i=head[u];i;i=node[i].next){
			int d=node[i].v;
			if(node[i].val!=0&&vis[d]==0){
			pre[d].fa=u;
			pre[d].pos=i;
			if(d==t)return 1;
			q.push(d);
			vis[d]=1;	
		}
		}
	}
	return 0;
}
int maxflow=0;
int EK(){
	maxflow=0;
	int mi;
	while(bfs()){
		mi=inf;
		for(int i=t;i!=s;i=pre[i].fa)
		mi=min(mi,node[pre[i].pos].val);
		for(int i=t;i!=s;i=pre[i].fa){
			node[pre[i].pos].val-=mi;
			node[pre[i].pos^1].val+=mi;
		}
		maxflow+=mi;
	}
	return maxflow;
}
int main(){
	n=Read(),p=Read(),q=Read();
	register int i,j;
	int f;
	s=1001,t=1002;
	for(i=1;i<=n;i++)add(i,i+n,1);//i表示顾客入点，i+n表示顾客出点
	for(i=1;i<=p;i++)add(s,200+i,1);//200+i表示房间
	for(i=1;i<=q;i++)add(300+i,t,1);//300+i表示菜 
	for(i=1;i<=n;i++){
		for(j=1;j<=p;j++){
		f=Read();
		if(f==1)add(200+j,i,1);	
		}
	} 
	for(i=1;i<=n;i++){
		for(j=1;j<=q;j++){
			f=Read();
			if(f==1)add(i+n,300+j,1);
		}
	}
	printf("%d",EK());
	return 0;
}
```


------------

## 二分图中EK不够高效，于是我们还可以选择Dinic

[不会DInic的来捧场啊](https://www.luogu.org/blog/ONE-PIECE/wang-lao-liu-jiang-xie-zhi-dinic)

Dinic代码：
```
#include<iostream>
#include<cstring>
#include<cstdio>
#include<queue>
#include<algorithm>
using namespace std;
const int inf=1<<30;
inline int Read(){
	int x=0,f=1;
	char c=getchar();
	while(c>'9'||c<'0'){if(c=='-')f=-1;c=getchar();}
	while(c>='0'&&c<='9')x=x*10+c-'0',c=getchar();
	return x*f;
}
int n,p,q,s,t;
struct Node{
	int v;
	int val;
	int next;
}node[101101];
int head[1010],top=1;
inline void addedge(int u,int v,int val){
	node[++top].v=v;
	node[top].val=val;
	node[top].next=head[u];
	head[u]=top;
}
inline void add(int u,int v,int val){
	addedge(u,v,val);
	addedge(v,u,0);
}
int inque[1010],dep[1010];
bool bfs(){
	memset(inque,0,sizeof(inque));
	memset(dep,0x3f,sizeof(dep));
	queue<int>q;
	q.push(s);
	dep[s]=0;
	while(!q.empty()){
		int u=q.front();
		q.pop();
		inque[u]=0;
		for(int i=head[u];i;i=node[i].next){
			int d=node[i].v;
			if(node[i].val&&dep[d]>dep[u]+1){
				dep[d]=dep[u]+1;
				if(inque[d]==0){
					q.push(d);
					inque[d]=1;
				}
			}
		}
	}
	return dep[t]!=0x3f3f3f3f;
}
int maxflow=0;
int vis;
int dfs(int u,int flow){
	if(u==t){
		vis=1;
		maxflow+=flow;
		return flow;
	}
	int used=0;
	for(int i=head[u];i;i=node[i].next){
		int d=node[i].v;
		if(node[i].val&&dep[d]==dep[u]+1){
			int mi=dfs(d,min(node[i].val,flow-used));
			if(mi){
				node[i].val-=mi;
				node[i^1].val+=mi;
				used+=mi;
			}
		}
		if(used==flow)break;
	}
	return used;
}
int Dinic(){
	maxflow=0;
	while(bfs()){
		vis=1;
		while(vis)vis=0,dfs(s,inf);
	}
	return maxflow;
}
int main(){
	n=Read(),p=Read(),q=Read();
	register int i,j;
	int f;
	s=1001,t=1002;
	for(i=1;i<=n;i++)add(i,i+n,1);//i表示顾客入点，i+n表示顾客出点
	for(i=1;i<=p;i++)add(s,200+i,1);//200+i表示房间
	for(i=1;i<=q;i++)add(300+i,t,1);//300+i表示菜 
	for(i=1;i<=n;i++){
		for(j=1;j<=p;j++){
		f=Read();
		if(f==1)add(200+j,i,1);	
		}
	} 
	for(i=1;i<=n;i++){
		for(j=1;j<=q;j++){
			f=Read();
			if(f==1)add(i+n,300+j,1);
		}
	}
	printf("%d",Dinic());
	return 0;
}
```


------------

## Dinic还有当前弧优化（不过这题数据实在太水，体现不出优势）：

```
#include<iostream>
#include<cstring>
#include<cstdio>
#include<queue>
#include<algorithm>
using namespace std;
const int inf=1<<30;
inline int Read(){
	int x=0,f=1;
	char c=getchar();
	while(c>'9'||c<'0'){if(c=='-')f=-1;c=getchar();}
	while(c>='0'&&c<='9')x=x*10+c-'0',c=getchar();
	return x*f;
}
int n,p,q,s,t;
struct Node{
	int v;
	int val;
	int next;
}node[101101];
int head[1010],top=1;
inline void addedge(int u,int v,int val){
	node[++top].v=v;
	node[top].val=val;
	node[top].next=head[u];
	head[u]=top;
}
inline void add(int u,int v,int val){
	addedge(u,v,val);
	addedge(v,u,0);
}
int inque[1010],dep[1010],cur[1010];
bool bfs(){
	register int i;
	for(i=1;i<=t;i++)dep[i]=inf,inque[i]=0,cur[i]=head[i];
	queue<int>q;
	q.push(s);
	dep[s]=0;
	while(!q.empty()){
		int u=q.front();
		q.pop();
		inque[u]=0;
		for(i=head[u];i;i=node[i].next){
			int d=node[i].v;
			if(node[i].val&&dep[d]>dep[u]+1){
				dep[d]=dep[u]+1;
				if(inque[d]==0){
					q.push(d);
					inque[d]=1;
				}
			}
		}
	}
	return dep[t]!=inf;
}
int maxflow=0;
int vis;
int dfs(int u,int flow){
	if(u==t){
		vis=1;
		maxflow+=flow;
		return flow;
	}
	int used=0;
	for(int i=cur[u];i;i=node[i].next){
		cur[u]=i;
		int d=node[i].v;
		if(node[i].val&&dep[d]==dep[u]+1){
			int mi=dfs(d,min(node[i].val,flow-used));
			if(mi){
				node[i].val-=mi;
				node[i^1].val+=mi;
				used+=mi;
			}
		}
		if(used==flow)break;
	}
	return used;
}
int Dinic(){
	maxflow=0;
	while(bfs()){
		vis=1;
		while(vis)vis=0,dfs(s,inf);
	}
	return maxflow;
}
int main(){
	n=Read(),p=Read(),q=Read();
	register int i,j;
	int f;
	s=401,t=402;
	for(i=1;i<=n;i++)add(i,i+n,1);//i表示顾客入点，i+n表示顾客出点
	for(i=1;i<=p;i++)add(s,200+i,1);//200+i表示房间
	for(i=1;i<=q;i++)add(300+i,t,1);//300+i表示菜 
	for(i=1;i<=n;i++){
		for(j=1;j<=p;j++){
		f=Read();
		if(f==1)add(200+j,i,1);	
		}
	} 
	for(i=1;i<=n;i++){
		for(j=1;j<=q;j++){
			f=Read();
			if(f==1)add(i+n,300+j,1);
		}
	}
	printf("%d",Dinic());
	return 0;
}
```

---

## 作者：_louhc (赞：5)

# [P1402 酒店之王](https://www.luogu.org/problemnew/show/P1402)  

[安利博客](https://www.cnblogs.com/louhancheng/p/10118878.html)

------

# 算法

网络最大流。这里不详细讲，请大家先掌握。

# 思路

> 注意，以下出现的所有边边权皆为1，且其反向边边权为0

我们以房间、菜、人为点建图。
像这样：

![](https://img2018.cnblogs.com/blog/1431616/201812/1431616-20181214131744366-1260908236.png)


S(=0)表示额外建的一个起始点，Ri(=i + n + n)表示第i个房间，Di(=i+n+n+p)表示第i种菜，由于人只有一个，而网络流处理只经过一个点不方便，我们采用一种神奇方法——拆点！也就是说，把一个人看做两个点，要匹配这个人必须经过这个人两点之间的边，这样就可以控制这个人只匹配一次。如图，Pi(=i)、Pi'(=i+n)表示第i个人。

然后建边。如图，将S与所有Ri相连，将所有的Di与T相连，S作为源点，T作为汇点。如果Pi喜欢Rj，就将Pi与Rj相连。如果Pi喜欢Dj，就将Dj与Pi'之间相连。当然，Pi与Pi'之间也要连一条边。

然后就可以套网络最大流辣。最后得出的答案即为满意数。

# 拓展

有一天来了n批客人，每批客人喜欢的菜、房间都相同。第i批客人有gi位客人。其余同原题。

> HINT:我们可以把每批客人当做2个点Pi、Pi'，~~在Pi、Pi'之间连gi条边~~连一条权为gi的边即可。菜、房间每种有多个同理。

# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define open(s) freopen( s".in", "r", stdin ), freopen( s".out", "w", stdout )
#define MAXN 405
#define MAXM 40005

int n, p, q;
int hd[MAXN], nxt[MAXM << 1], to[MAXM << 1], val[MAXM << 1], tot(1);
int ans, dis[MAXN];
queue<int> Q;

int x, y;
int S, T;

void Add( int x, int y, int z ){ nxt[++tot] = hd[x]; hd[x] = tot; to[tot] = y; val[tot] = z; }

bool BFS(){
	while( !Q.empty() ) Q.pop();
	memset( dis, 0, sizeof dis );
	Q.push(S); dis[S] = 1;
	while( !Q.empty() ){
		x = Q.front(); Q.pop();
		for ( int i = hd[x]; i; i = nxt[i] )
			if ( val[i] && !dis[to[i]] ){
				dis[to[i]] = dis[x] + 1;
				Q.push( to[i] );
				if ( to[i] == T ) return 1;
			}
	}
	return 0;
}

int DFS( int x, int fl ){
	if ( x == T ) return fl;
	int res(fl), k;
	for ( int i = hd[x]; i && res; i = nxt[i] ){
		if ( val[i] && dis[to[i]] == dis[x] + 1 ){
			k = DFS( to[i], min( res, val[i] ) );
			if ( !k ) dis[to[i]] = 0;
			val[i] -= k; val[i^1] += k; res -= k;
		}
	}
	return fl - res;
}

int main(){
	scanf( "%d%d%d", &n, &p, &q );
	S = 0; T = 1 + n + n + p + q;
	for ( int i = 1; i <= n; ++i ) Add( i, i + n, 1 ), Add( i + n, i, 0 );
	for ( int i = 1; i <= p; ++i ) Add( S, i + n + n, 1 ), Add( i + n + n, S, 0 );
	for ( int i = 1; i <= q; ++i ) Add( i + n + n + p, T, 1 ), Add( T, i + n + n + p, 0 );
	
	for ( int i = 1; i <= n; ++i )
		for ( int j = 1; j <= p; ++j ){
			int t; scanf( "%d", &t );
			if ( t ) Add( j + n + n, i, 1 ), Add( i, j + n + n, 0 );
		}
	for ( int i = 1; i <= n; ++i )
		for ( int j = 1; j <= q; ++j ){
			int t; scanf( "%d", &t );
			if ( t ) Add( i + n, j + n + n + p, 1 ), Add( j + n + n + p, i + n, 0 );
		}
	int t;
	while( BFS() )
		while( ( t = DFS( S, 0x7f7f7f7f ) ) > 0 ) ans += t;
	printf( "%d\n", ans );
	return 0;
}

```

# 总结

这类题目如果要用网络最大流解决，一般来说，将“选择者”放中间，并且要拆点，“被选物”放两边，直接与源点、汇点相连。但是这种做法“被选物”不能多于两种。

如果多于两种，要怎么做呢？ 我也不知道 QAQ）求教大佬QAQ

---

## 作者：Adun (赞：5)

# **这道题对不起NOI-**


-看标签，网络流。就吓到了（弱鸡至今不会打网络流）。

-再看这道题我就想到了，在匈牙利中跑匈牙利算法结果是n的6次方**（直接炸）**；

-再想了一想其实很简单，跑两个二分图就行了。

-可以构造两个二分图，人为中间集合，房间和菜分别是坐集合和右集合，依次从某人出发同时对两个集合找增广路，

-若对某一个二分图没有找到增广路，则退边（从这个人出发找到的这条增广路不行)，

-如果都找到了，就更新答案；


上代码（数组名有点奇怪，将就看吧！）

```cpp
#include "stdafx.h"
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;

const int MAXN = 105;

int n, p, q, i, j, ans;
int people[MAXN], vis[MAXN], dis[MAXN], people_[MAXN];
int room[MAXN][MAXN], dish[MAXN][MAXN], take_[MAXN], take[MAXN], eat[MAXN];

inline int room_(int k)
{
    for (int i = 1; i <= n; i++)
        if (room[k][i] && !vis[i])
        {
            vis[i] = 1;

            if (take[i] == 0 || room_(take[i]))
            {
                people[k] = 1;
                take[i] = k;
                return 1;
            }
        }
    return 0;
}

inline int food_(int k)
{
    for (int i = 1; i <= n; i++)
        if (dish[k][i] && !dis[i])
        {
            dis[i] = 1;

            if (eat[i] == 0 || food_(eat[i]))
            {
                eat[i] = k;
                return 1;
            }
        }
    return 0;
}

int main()
{
    ios::sync_with_stdio(0);

    cin >> n >> p >> q;

    for (i = 1; i <= n; i++)
        for (j = 1; j <= p; j++)
            cin >> room[i][j];

    for (i = 1; i <= n; i++)
        for (j = 1; j <= q; j++)
            cin >> dish[i][j];

    for (;;)
    {
        for (i = 1; i <= n; i++)
            if (!people[i])
            {
                memset(vis, 0, sizeof(vis));
                memset(dis, 0, sizeof(dis));

                for (j = 1; j <= n; j++) people_[j] = people[j];
                for (j = 1; j <= n; j++) take_[j] = take[j];

                if (room_(i) && food_(i))
                {
                    ans++;
                    continue;
                }
                else
                {
                    for (j = 1; j <= n; j++) people[j] = people_[j];
                    for (j = 1; j <= n; j++) take[j] = take_[j];
                }
            }
        break;
    }

    cout << ans << endl;
    return 0;
}
```
**VS2017(^\_^)**


---

## 作者：zh_dou (赞：2)

其实这道题和某道[P1231 教辅的组成](https://www.luogu.org/problem/P1231)几乎是双倍经验，考点也一样

## 分析
这道题是一道最大匹配问题，结合数据范围可以很容易的想到网络流

我们发现酒店的房间和菜都是和人有关的，所以我们把人和房间、菜分别连边，并且从原点s向
房间连边，菜向汇点连边

但是每一个顾客的贡献只能计算一次，
也就是只能和一道菜和一个房间匹配。

如果像上面那样连边会造成错误，如：

![](https://cdn.luogu.com.cn/upload/image_hosting/i615vkqi.png)

X点的贡献变成了2，实际应是1

所以我们考虑将代表人的点拆开，分为两组，
一组为入点，一组为出点

房间向入点连边，出点向菜连边，入点和出点之间连边

所有的边流量为1，代表只能使用一次
即：

$\begin{aligned}&S\xrightarrow{1}P_{room}\\&P_{meal}\xrightarrow{1}T \\&P_{room}\xrightarrow{1}P_{people}.in\\&P_{people}.out\xrightarrow{1}P_{meal}\\&P_{people}.in\xrightarrow{1}P_{people}.out\end{aligned}$

## 代码
$\mathcal{Code:}$
```cpp
#include<map>
#include<queue>
#include<cmath>
#include<cstdio>
#include<string>
#include<cstring>
#include<cstdlib>
#include<iostream>
#include<algorithm>
using namespace std;
#define N 100010
#define int long long
#define debug cout<<__LINE__<<" "<<__FUNCTION__<<"\n"
inline int read(){
 	int x=0,y=1;
 	char ch=getchar();
 	while(ch<'0'||ch>'9'){if(ch=='-')y=-1;ch=getchar();}
 	while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}
 	return x*y;
}
int n_1,n_2,n_3,m_1,m_2,s,t,dep[N];
int head[N],used[N],tot=1,front;//tot赋1方便找反向边
int ans;
struct Node{
    int nxt,to,dis;
}edge[N<<1];
inline void add(int x,int y,int z){
    edge[++tot].nxt=head[x];
    edge[tot].to=y;
    edge[tot].dis=z;
    head[x]=tot;
}
queue<int> q;
inline int bfs(){
	register int i;
	for(i=0;i<=n_1+n_1+n_2+n_3+2;i++) dep[i]=-1,used[i]=head[i];
    //记得在初始化时一定算好大小点的数量
	dep[s]=0;
	q.push(s);
	while(!q.empty()){
		front=q.front();q.pop();
		for(i=head[front];i;i=edge[i].nxt){
			if(edge[i].dis&&dep[edge[i].to]==-1){
				dep[edge[i].to]=dep[front]+1;q.push(edge[i].to);
			}
		}
	}
	return dep[t]!=-1;
}
int dfs(int now,int limit){
	if(!limit||now==t) return limit;
	int flow=0;
	for(int &i=used[now],pro;i;i=edge[i].nxt){
		if(dep[edge[i].to]==dep[now]+1&&(pro=dfs(edge[i].to,min(limit,edge[i].dis)))){
			edge[i].dis-=pro;
			edge[i^1].dis+=pro;
			flow+=pro;
			limit-=pro;
		}
	}
	return flow;
}
inline void Dinic(){//最大流板子
	while(bfs()) ans+=dfs(s,1000000001LL);
}
signed main(){
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	n_1=read();n_2=read();n_3=read();//people room meal
	s=0;t=n_1+n_1+n_2+n_3+1;//S和T的取值(个人习惯)
	register int i,j,u;
	for(i=n_1+n_1+1;i<=n_1+n_1+n_2;i++){//从S到P_room
		add(s,i,1);add(i,s,0);
	}
	for(i=n_1+n_1+n_2+1;i<=n_1+n_1+n_2+n_3;i++){//从P_meal到T
		add(i,t,1);add(t,i,0);
	}
	for(i=1;i<=n_1;i++){//从P_people.in到P_people.out
		add(i,i+n_1,1);add(i+n_1,i,0);
	}
	for(i=1;i<=n_1;i++){//从P_room到P_people.in
		for(j=1;j<=n_2;j++){
			u=read();
			if(u){
				add(j+n_1+n_1,i,1);add(i,j+n_1+n_1,0);
			}
		}
	}
	for(i=1;i<=n_1;i++){//从P_people.out到P_meal
		for(j=1;j<=n_3;j++){
			u=read();
			if(u){
				add(i+n_1,j+n_1+n_1+n_2,1);add(j+n_1+n_1+n_2,i+n_1,0);
			}
		}
	}
	Dinic();
	cout<<ans<<"\n";
//	fclose(stdin);
//	fclose(stdout);
	return 0;
}

```


---

## 作者：lukelin (赞：2)

### 前言
[安利一下我的博客](https://www.cnblogs.com/linzhengmin/p/11089837.html)  
如果有人不会网络流，那么安利一下我[网络最大流Dinic的博客](https://www.cnblogs.com/linzhengmin/p/9313216.html)  
关于网络流，我多久没有碰这个算法了...  
今天旁边的巨佬@Chhokmah在做网络流，于是我也顺便做了一下。  
这确实是一道网络流好题。  
### 题解
这道题目难点主要是构图。  
这道题的构图一开始很容易想到建一个超级源点连房间，房间连人，人连菜，菜连汇点。  
最后跑一遍最大流求出答案。  
然后交了一下直接WA 60(当场自闭)。  
仔细一想发现有一个问题  
比如下面这组数据  
```
1 3 3
1 1 1
1 1 1
```
答案应该是1，但当前的算法输出是三，算法的错误是中间的人被**重复利用**了。  
于是我们想到了一个技巧，**拆点**。  
把一个人**拆成两个点**，中间连接一条流量为1的边，这样保证了一个人最多只会被利用一次。  
于是重新构图：  
建一个超级源点连房间，房间连人1，人1连人2，人2连菜，菜连汇点。  
注:其中人1和人2是同一个人。  
然后接着跑一遍网络流求出答案即可。  
### 代码
```cpp
#include <cstdio> 
#include <cstring>
#include <queue>
#include <algorithm>

using namespace std;

const long long MAX = (1ll << 62);

int read(){
    int x = 0; int zf = 1; char ch = ' ';
    while (ch != '-' && (ch < '0' || ch > '9')) ch = getchar();
    if (ch == '-') zf = -1, ch = getchar();
    while (ch >= '0' && ch <= '9') x = x * 10 + ch - '0', ch = getchar(); return x * zf;
}

struct Edge{
    int to, next;
    long long dis;
} edges[210000];

int cur[10010], head[10010], edge_num = -1;

void addEdge2(int from, int to, long long dis){
    edges[++edge_num].to = to;
    edges[edge_num].dis = dis;
    edges[edge_num].next = head[from];
    head[from] = edge_num;
}

void addEdge(int from, int to, long long dis){
    addEdge2(from, to, dis), addEdge2(to, from, 0);
}

int d[10010];
int s, t;

long long DFS(int u, long long flow){
    if (u == t) return flow;
    long long _flow = 0, __flow;
    for (int& c_e = cur[u]; c_e != -1; c_e = edges[c_e].next){
        int v = edges[c_e].to;
        if (d[v] == d[u] + 1 && edges[c_e].dis > 0){
            __flow = DFS(v, min(flow, edges[c_e].dis));
            flow -= __flow;
            edges[c_e].dis -= __flow;
            _flow += __flow;
            edges[c_e ^ 1].dis += __flow;
            if (!flow)
                break;
        }
    }
    if (!_flow) d[u] = -1;
    return _flow;
}

bool BFS(){
    memset(d, -1, sizeof(d));
    queue<int> que; que.push(s);
    d[s] = 0; int u, _new;
    while (!que.empty()){
        u = que.front(), que.pop();
        for (int c_e = head[u]; c_e != -1; c_e = edges[c_e].next){
            _new = edges[c_e].to;
            if (d[_new] == -1 && edges[c_e].dis > 0){
                d[_new] = d[u] + 1;
                que.push(_new);
            }
        }
    }
    return (d[t] != -1);
}

int n;

void dinic(){
    long long max_flow = 0;
    while (BFS()){
        for (int i = 0; i <= n; ++i) cur[i] = head[i];
        max_flow += DFS(s, MAX);
    }
    printf("%lld", max_flow);
}

int main(){
    memset(head, -1, sizeof(head));
    int N = read(), p = read(), q = read();
    s = 0;
    for (int j = 1; j <= p; ++j)
        addEdge(s, j, 1);
    for (int i = 1; i <= N; ++i)
        for (int j = 1; j <= p; ++j)
            if (read() == 1)
                addEdge(j, p + q + i, 1);
    for (int i = 1; i <= N; ++i)
        addEdge(p + q + i, p + q + N + i, 1);
    for (int i = 1; i <= N; ++i)
        for (int j = 1; j <= q; ++j)
            if (read() == 1)
                addEdge(p + q + N + i, p + j, 1);
    n = t = p + q + N * 2 + 1;
    for (int j = 1; j <= q; ++j)
        addEdge(p + j, t, 1);
    dinic();
    return 0;
}
```

---

## 作者：Waddles (赞：1)

这个题其实不难想，将0定义为超级源点，向每个房间建一条流量为1的边，然后将10000定义为超级汇点，每道菜向它建一条流量为1的边，然后根据输入建图就OK了，这里需要注意的是，不能让一个人被用了多次，因为每一个人只能匹配一次，将一个人拆成两个人一个接收，一个输出，两人之间建边，使一个人只能流入流出一次，就没问题了

样例如下图

![111.PNG](https://i.loli.net/2019/08/21/qLkdzIsepWfgAKU.png)

其中4,6表示第一个人，5,7表示第二个人，2,3表示2间房子，8,9表示两道菜

我在这里设每个人编号为i和i+n（拆成2个），房间编号为i+1926，菜编号为i+817，然后按上面的建边跑最大流

我写的是Dinic算法，模板题写法，思路是每次BFS求出节点深度，然后while(1)跑DFS找增广路，找不到增广路就退出，重新BFS求深度

当然还可以用其他算法搞（如ISAP）

这个题数据小，不用其他优化

复杂度上界$O(n^2m)$

下面上code:

```
#include<map>
#include<cmath>
#include<stack>
#include<queue>
#include<cstdio>
#include<vector>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
typedef long long ll;
template<class Read>void in(Read &x){
    x=0;
    int f=0;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
        f|=(ch=='-');
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        x=(x<<1)+(x<<3)+(ch^48);
        ch=getchar();
    }
    x=f?-x:x;
    return;
}
struct Node{
    int next;
    int to;
    int sum;
}a[20005];
int n,p,q,top=1,head[100005],f[100005],v[100005];
queue<int>Q;
void add(int x,int y,int c){//建边
    a[++top].next=head[x];
    a[top].to=y;
    a[top].sum=c;
    head[x]=top;
}
bool bfs(){//BFS把层次理出来
    for(int i=0;i<=n;i++)f[i]=f[i+n]=20190817;//初始化最大值
    for(int i=817+1;i<=817+q;i++)f[i]=20190817;
    for(int i=1926+1;i<=1926+p;i++)f[i]=20190817;
    f[10000]=20190817;
    f[0]=0;
    memset(v,0,sizeof(v));//初始每个点都没用过
    Q.push(0);
    while(!Q.empty()){
        int x=Q.front();
        Q.pop();
        v[x]=0;
        for(int i=head[x];i;i=a[i].next){
            int y=a[i].to;
            if(f[y]>f[x]+1&&a[i].sum!=0){
                f[y]=f[x]+1;
                if(!v[y]){
                    v[y]=1;
                    Q.push(y);//入队
                }
            }
        }
    }
    return f[10000]==20190817?0:1;//如果不能到达，结束
}
int dfs(int x,int y){//找增广路
    if(x==10000)return y;//到目的地，返回权值
    for(int i=head[x];i;i=a[i].next){
        int u=a[i].to;
        if(f[u]==f[x]+1&&a[i].sum!=0){//往后找
            int g=min(y,a[i].sum);
            int l=dfs(u,g);
            if(l!=0){
                a[i].sum-=l;
                a[i^1].sum+=l;
                return l;
            }
        }
    }
    return 0;
}
void Dinic(){//dinic模板
    int ans=0;
    while(bfs()){
        while(1){
            int sum=dfs(0,20190817);
            if(sum==0)break;
            ans+=sum;
        }
    }
    printf("%d\n",ans);
}
int main(){
	in(n);in(q);in(p);
    for(int i=1;i<=q;i++){//源点与房间建边
        add(0,i+1926,1);
        add(i+1926,0,0);
    }
    for(int i=1;i<=p;i++){//菜与汇点建边
        add(i+817,10000,1);
        add(10000,i+817,0);
    }
    for(int i=1;i<=n;i++){
        add(i+n,i,1);//1个人拆成2个
        add(i,i+n,0);
    }
    for(int i=1;i<=n;i++){
        for(int j=1;j<=q;j++){
            int x;
            in(x);
            if(x==1){
                add(j+1926,i+n,1);//房间与建边
                add(i+n,j+1926,0);
            }
        }
    }
    for(int i=1;i<=n;i++){
        for(int j=1;j<=p;j++){
            int x;
            in(x);
            if(x==1){
                add(i,j+817,1);//与菜建边
                add(j+817,i,0);
            }
        }
    }
    Dinic();
	return 0;
}
```

---

## 作者：Ireliaღ (赞：1)

**ISAP最大流**

刚做完[一道题](https://www.luogu.org/problemnew/show/P1231)，发现这道题跟它一样，稍微改改就A了

简单地说，三分图匹配，需要对中间一层进行拆点来防止重复选择。

## 建图

- 设有$n_1$个人，$n_2$个房间，$n_3$个菜品

- 设超级原点为$0$，超级汇点为$n_1 \times 2 + n_2 + n_3 + 1$

- 对于$\forall i \in [1, n_1]$，从$i$向$n_1 + i$建立容量为$1$的边

- 对于$\forall i \in [1, n_2]$，从$0$向$n_1 \times 2 + i$建立容量为$1$的边

- 对于$\forall i \in [1, n_3]$，从$n_1 \times 2 + n_2 + i$向$n_1 \times 2 + n_2 + n_3 + 1$建立容量为$1$的边

- 对于可以匹配的$\forall i \in [1, n_2]$，$\forall j \in [1, n_1]$，从$n_1 \times 2 + i$向$j$建立容量为$1$的边

- 对于可以匹配的$\forall i \in [1, n_1]$，$\forall j \in [1, n_3]$，从$n_1 + i$向$n_1 \times 2 + n_2 + j$建立容量为$1$的边

## 代码

懒得写当前弧优化了，ISAP已经挺快了。

```cpp
// luogu-judger-enable-o2
// luogu-judger-enable-o2
#include <iostream>
#include <queue>
#include <cstring>

using namespace std;

const int INF = 0x3f3f3f3f;
const int MAXN = 105;

int n, m1, m2;

struct Edge{
    int to, val;
    Edge *nxt, *ops;
    Edge(int to, int val, Edge *nxt): to(to), val(val), nxt(nxt) {}
};

Edge *head[MAXN << 2];

void AddEdge(int u, int v, int w) {
    head[u] = new Edge(v, w, head[u]);
    head[v] = new Edge(u, 0, head[v]);
    head[u]->ops = head[v]; head[v]->ops = head[u];
}

int dep[MAXN << 2], gap[MAXN << 2], res, s, t;

void Bfs() {
    memset(dep, -1, sizeof(dep));
    memset(gap, 0, sizeof(gap));
    dep[t] = 0; gap[dep[t]]++;
    queue<int> q; q.push(t);
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (Edge *e = head[u]; e; e = e->nxt) {
            int v = e->to;
            if (dep[v] != -1) continue;
            dep[v] = dep[u] + 1;
            gap[dep[v]]++;
            q.push(v);
        }
    }
}

int Dfs(int u, int flow) {
    if (u == t) {
        res += flow;
        return flow;
    }
    int used = 0;
    for (Edge *e = head[u]; e; e = e->nxt) {
        int v = e->to;
        if (e->val && dep[v] == dep[u] - 1) {
            int mi = Dfs(v, min(e->val, flow - used));
            if (mi) {
                e->val -= mi;
                e->ops->val += mi;
                used += mi;
            }
            if (used == flow) return used;
        }
    }
    gap[dep[u]]--;
    if (gap[dep[u]] == 0) dep[s] = n + n + m1 + m2 + 3;
    dep[u]++;
    gap[dep[u]]++;
    return used;
}

void Isap() {
    res = 0;
    Bfs();
    while (dep[s] <= n + n + m1 + m2 + 3) Dfs(s, INF);
}

int main() {
    cin >> n >> m1 >> m2;
    s = 0; t = n + n + m1 + m2 + 1;
    for (int i = 1; i <= n; i++) AddEdge(m1 + i, m1 + n + i, 1);
    for (int i = 1; i <= m1; i++) AddEdge(s, i, 1);
    for (int i = 1; i <= m2; i++) AddEdge(m1 + n + n + i, t, 1);
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m1; j++) {
            int x;
            cin >> x;
            if (x == 1) AddEdge(j, m1 + i, 1);
        }
    }
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m2; j++) {
            int x;
            cin >> x;
            if (x == 1) AddEdge(m1 + n + i, m1 + n + n + j, 1);
        }
    }
    Isap();
    cout << res << endl;
    return 0;
}
```

---

## 作者：7KByte (赞：1)

不说废话  



------------
## 题面：
有p个房间q道菜，有n个人每人喜欢一些菜和房间，只有同时选他喜欢的菜和房间才满意，最多能满意多少人

----

## 思路：
乍一看绝对二分图，$X$集表示房间$Y$集表示菜，对于每个人，将他喜欢的菜和房间连边，然后求最大匹配即可  
然而，0分 


显然这种方法是行不通的，为什么？因为一个人会喜欢多个菜和房间，那么我们匹配的时候不能够保证每个人只选择一对菜和房间  
既然要限制每个人的选择，显然网络流的流量限制是最佳选择  
我们将源点连向每道菜，容量1，将菜连向喜欢它的人，流量1，再将人连向他喜欢的房间，流量1，最后将每个房间连向汇点流量1  
跑一遍最大流即可
依旧，0分


我们还是没有抓住问题的关键，关键在于一个人只能选择一对房间和菜，也只能贡献1的满意度，在我们刚才构造的网络中，虽限制的菜和房间只被选择一次，但对人依旧没有限制。  
人在网络中是以点的形式表示的，于是我们可以想到拆点，即将一个点拆成一个对点（一个入点一个出点，再在入点和出点中连边），在这题中我们连容量为1的边限制一人只被选一次。
![](https://cdn.luogu.com.cn/upload/pic/47729.png)  
最后跑最大流即可 



--------

```
#include<bits/stdc++.h>
using namespace std;
struct edge{
	int to,next,data;
}e[200010];
int h[10005],s=0,t=10000,n,u,v,pop=1;
void add(int x,int y,int dat){
	pop++;
	e[pop].to=y;e[pop].data=dat;
	e[pop].next=h[x];h[x]=pop;
}
int dist[10005];queue<int>q;
bool bfs(){
	memset(dist,0,sizeof(dist));
	while(!q.empty())q.pop();
	q.push(s);dist[s]=1;
	//cout<<"ss";
	while(!q.empty()){
		int x=q.front();q.pop();
		for(int i=h[x];i;i=e[i].next)
		  if(!dist[e[i].to]&&e[i].data){
		  	dist[e[i].to]=dist[x]+1;
		  	q.push(e[i].to);if(e[i].to==t)return true;
		  }
	}
	return false;
}
int dfs(int p,int flow){
	//printf("kk");
	if(p==t)return flow;
	int rest=flow,k;
	for(int i=h[p];i&&rest;i=e[i].next){
		if(e[i].data&&dist[p]+1==dist[e[i].to])
		  {
		  	k=dfs(e[i].to,min(rest,e[i].data));
		  	if(!k)dist[e[i].to]=-1;
		  	e[i].data-=k;
		  	e[i^1].data+=k;
		  	rest-=k;
		  }
	}
	return flow-rest;
}
int main()
{
	memset(h,0,sizeof(h));
	scanf("%d%d%d",&n,&u,&v);
	for(int i=1;i<=u;i++){add(s,i,1);add(i,s,0);} 
	for(int i=1;i<=n;i++){
		int x;
		for(int j=1;j<=u;j++){
			scanf("%d",&x);
			add(j,i+u,x);add(i+u,j,0);
		}
	}
	for(int i=1;i<=n;i++){
		add(i+u,i+u+n,1);
		add(i+u+n,i+u,0);
    }
    for(int i=1;i<=n;i++){
		int x;
		for(int j=1;j<=v;j++){
			scanf("%d",&x);
			add(i+u+n,j+u+n+n,x);add(j+u+n+n,i+u+n,0);
		}
	}
	for(int i=1;i<=v;i++){
		add(i+u+n+n,t,1);
		add(t,i+u+n+n,0);
	}
	int ans=0,x;
	while(bfs())
	    ans+=dfs(s,(1<<30));
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：yangzechenc (赞：1)

# 标签NOI- =_= !! 
其实也没那么难iwi ~~然而WA了n次大概是我太弱了~~

有3类点：房间、菜以及客人，我们先一通乱连边，当然要把人放中间，然后房间向人连，人再向菜连，边权为1（现实意义是显然的）。接着建一个超级源，向每个房间连边，边权也为1（即房间只选一次，除非你能说服两个客人同居XD）；再建一个超级汇，每道菜向它连边，边权为1（难道你想让两个人吃一盘菜？！不可取不可取iwi）。

完了......？tan90.

再考虑一个问题，我们还没有对人进行限制，所以这样可能出现一个人选择很多道菜很多个房间的霸权主义。怎么处理呢？~~为了维护世界的和平防止秩序被破坏~~ 我们考虑把客人劈开即拆成两个点，再在这两个点中连一条边权为1的边，即限制霸权主义的出现。然后就是easy的网络流啦XD

code（dinic）：

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<queue>
#include<map>
using namespace std;
const int inf=1e9+7;
int n,p,q,s,t;
queue<int>que;
int dep[10010];
struct edge{
	int v,nt,c;
}; 
edge e[200010];
int list[10010],l=2;
inline int read(){
	char ch=getchar();
	int rt,ck=1;
	while ((ch<'0'||ch>'9')&&ch!='-')	ch=getchar();
	if (ch=='-'){
		ck=-1;
		ch=getchar();
	}
	rt=ch-'0';	ch=getchar();
	while (ch>='0'&&ch<='9'){
		(rt*=10)+=ch-'0';
		ch=getchar();
	}
	return rt*ck;
}
inline void add(int u,int v,int c){
	e[l].v=v;	e[l].nt=list[u];	list[u]=l;	e[l].c=c;
	l++;
	return;
}
inline bool bfs(){
	memset(dep,0,sizeof(dep));
	dep[s]=1;	que.push(s);
	int u;
	while (!que.empty()){
		u=que.front();	que.pop();
		for (int i=list[u];i;i=e[i].nt){
			if (e[i].c>0&&dep[e[i].v]==0){
				dep[e[i].v]=dep[u]+1;
				que.push(e[i].v);
			}
		}
	}
	if (dep[t]==0)	return 0;
	return 1;
}
inline int dfs(int u,int flow){
	if (u==t)	return flow;
	for (int i=list[u];i;i=e[i].nt){
		if (dep[e[i].v]==dep[u]+1&&e[i].c!=0){
			int di=dfs(e[i].v,min(flow,e[i].c));
			if (di>0){
				e[i].c-=di;
				e[i^1].c+=di;
				return di;
			}
		}
	}
	return 0;
} 
int dinic(){
	int rt=0;
	while (bfs()){
		while (int d=dfs(s,inf))
			rt+=d;
	}
	return rt;
}
int main(){
	n=read();	p=read();	q=read();
	s=0;	t=2*n+p+q+1;
	for (int i=1;i<=p;i++){
		add(s,2*n+i,1);
		add(2*n+i,s,0);
	}
	for (int i=1;i<=q;i++){
		add(t,2*n+p+i,0);
		add(2*n+p+i,t,1);
	}
	for (int i=1;i<=n;i++){
		int ope;
		for (int j=1;j<=p;j++){
			ope=read();
			if (ope==1){
				add(2*n+j,n+i,1);
				add(n+i,2*n+j,0);
			}
		}
	}
	for (int i=1;i<=n;i++){
		add(i,i+n,0);
		add(i+n,i,1);
	}
	for (int i=1;i<=n;i++){
		int ope;
		for (int j=1;j<=q;j++){
			ope=read();
			if (ope){
				add(j+p+2*n,i,0);
				add(i,j+p+2*n,1);
			}
		}
	}
	cout<<dinic()<<endl;
	return 0;
}
```

---

## 作者：Dispwnl (赞：1)


这道题差不多就是[教辅的组成](https://www.luogu.org/problemnew/show/1231 "教辅的组成")的数据缩小版……

房间连源点，容量为$1$

菜连汇点，容量为$1$

人再连接房间和菜

这样能得到$60$分的好成绩

发现问题，人可能被用了多次

如图所示

 ![](https://cdn.luogu.com.cn/upload/pic/12506.png) 

红线、蓝线都是合理的

然而人被经过了两次，所以要控制人（点）的流量

所以把人拆成两个点，一个点与房间连，一个点与菜连

两点再连，容量为$1$

跑最大流就行了

### 代码：
```cpp
# include<iostream>
# include<cstdio>
# include<cstring>
# include<queue>
using namespace std;
const int t=500,INF=1e8;
struct p{
    int x,y,dis;
}c[200001];
int n,p,q,num;
int h[501],d[501];
void add(int x,int y,int dis)
{
    c[num].x=h[y];c[num].y=x;c[num].dis=0;h[y]=num++;
    c[num].x=h[x];c[num].y=y;c[num].dis=dis;h[x]=num++;
}
bool bfs()
{
    queue<int> qu;
    memset(d,0,sizeof(d));
    d[0]=1;
    qu.push(0);
    while(!qu.empty())
    {
        int tt=qu.front();
        qu.pop();
        for(int i=h[tt];i;i=c[i].x)
          if(!d[c[i].y]&&c[i].dis)
          {
              d[c[i].y]=d[tt]+1;
              qu.push(c[i].y);
          }
    }
    return d[t];
}
int dfs(int x,int dix)
{
    if(!dix||x==t) return dix;
    int sum=0;
    for(int i=h[x];i;i=c[i].x)
      if(d[c[i].y]==d[x]+1&&c[i].dis)
      {
          int dis=dfs(c[i].y,min(dix,c[i].dis));
          if(dis)
          {
              dix-=dis;
              sum+=dis;
              c[i].dis-=dis;
              c[i^1].dis+=dis;
              if(!dix) break;
        }
      }
    if(!sum) d[x]=-1;
    return sum;
}
int dinic()
{
    int tot=0;
    while(bfs())
    tot+=dfs(0,INF);
    return tot;
}
int main()
{
    scanf("%d%d%d",&n,&p,&q);
    for(int i=1;i<=p;i++)
      add(0,i,1);
    for(int i=1;i<=q;i++)
      add(i+p,t,1);
    for(int i=1;i<=n;i++)
      add(i+p+q,i+p+q+n,1);
    for(int i=1;i<=n;i++)
      for(int j=1;j<=p;j++)
        {
            int x;
            scanf("%d",&x);
            if(x) add(j,i+p+q,1);
        }
    for(int i=1;i<=n;i++)
      for(int j=1;j<=q;j++)
        {
            int x;
            scanf("%d",&x);
            if(x) add(i+p+q+n,j+p,1);
        }
    printf("%d",dinic());
    return 0;
}
```

---

## 作者：suyiheng (赞：0)

```c++
机房里的同学称这道题为“三分图匹配”，其实正解还是网络最大流。

正文：
建图思路：
1、创建一个超级原点和一个超级汇点。
2、从超级原点向每一个食品连一条容量为一的边。
3、将每一个人拆成两个点r[i]1,r[i]2,中间连一条容量为一的边。
4、从每一个食品向每一个喜欢他的人的r[i]1连一条容量为一的边。
5、从每一个人的r[i]2向每一个他喜欢的房间连一条容量为一的边。
6、从每一个房间向超级汇点连一条容量为一的边。

最后从超级原点向超级汇点跑一边裸的最大流就好了！（当然超级汇点向超级原点跑最大流也可以）
#include<iostream>
#include<cstdio>
#include<vector>
#include<queue>
using namespace std;
int n,a,b,x,y,z,c[1001][1001],f[1001],r[1001],k,ans;
void bfs(){
	while(1){
		for(int i=1;i<=k;i++){
			r[i]=0;
			f[i]=0;
		}
		f[0]=100000;
		queue<int> q;
		q.push(0);
		while(!q.empty()){
			x=q.front();
			q.pop();
			for(int i=0;i<=k;i++){
				if(c[x][i]&&!f[i]){
					f[i]=min(f[x],c[x][i]);
					r[i]=x;
					q.push(i);
				}
			}
		}
		if(f[k]==0)break;
		for(int i=k;i!=0;i=r[i]){
			c[r[i]][i]-=f[k];
			c[i][r[i]]+=f[k];
		}
		ans+=f[k];
	}
}
int main(){
	scanf("%d %d %d",&n,&a,&b);
	k=n*2+a+b+1;
	for(int j=1;j<=a;j++)c[0][j]=1;
	for(int j=1;j<=b;j++)c[a+2*n+j][k]=1;
	for(int j=1;j<=n;j++)c[a+j][a+n+j]=1;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=a;j++){
			scanf("%d",&x);
			if(x==1){
				c[j][a+i]=1;
			}
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=b;j++){
			scanf("%d",&x);
			if(x==1){
				c[a+i+n][2*n+a+j]=1;
			}
		}
	}
	
	bfs();
	printf("%d",ans);
}
```

---

## 作者：QwQ2000 (赞：0)

最大流

分三类点 房间 人  菜

限制每个人只能用一次 把人拆点

然后不要写跪模板就好啦=w=

```cpp

#include <cstdio>
#include <vector>
#include <cstring>
#include <queue>
#include <algorithm>
#include <iostream>

using namespace std;

struct edge {
    int u,v,c,f;
    edge() { }
    edge(int a,int b,int cc,int d):u(a),v(b),c(cc),f(d) { };
};

const int N=1001,INF=int(1e9),s=0,t=1000;

int n=0,p=0,q=0,room[N][N],dish[N][N],f[N],prev[N],d[N],vis[N],cur[N];
vector<edge> e;
vector<int> g[N];
int exist[N][N];

inline void addEdge(int u,int v,int c=1) {
    if (exist[u][v])
        return;
    e.push_back(edge(u,v,c,0));
    e.push_back(edge(v,u,0,0));
    g[u].push_back(e.size()-2);
    g[v].push_back(e.size()-1);
    exist[u][v]=1;
}

inline void build() {
    //S:0 T:1000
    //房间1~p 人p+1~p+n p+n+1~p+2n 菜p+2n+1~p+2n+q
    for (int i=1; i<=p; ++i)
        addEdge(0,i);
    for (int i=1; i<=p; ++i)
        for (int j=1; j<=n; ++j)
            if (room[j][i])
                addEdge(i,p+j);
    for (int i=1; i<=n; ++i)
        addEdge(p+i,p+n+i);
    for (int i=1; i<=n; ++i)
        for (int j=1; j<=q; ++j)
            if (dish[i][j]) {
                addEdge(p+n+i,p+2*n+j);
                addEdge(p+2*n+j,1000);
            }
}

int bfs() {
    memset(vis,0,sizeof(vis));
    memset(d,0,sizeof(d));
    queue<int> q;
    d[s]=1;
    vis[s]=1;
    q.push(s);
    while (!q.empty()) {
        int x=q.front();
        q.pop();
        for (int i=0;i<g[x].size();++i) {
            edge e0=e[g[x][i]];
            if (!vis[e0.v] && e0.c>e0.f) {
                vis[e0.v]=1;
                q.push(e0.v);
                d[e0.v]=d[x]+1;
            }
        }
    }
    return vis[t];
}

int dfs(int x,int a) {
    if (x==t || a==0)
        return a;
    int flow=0,f=0;
    for (int& i=cur[x];i<g[x].size();++i) {
        edge& e0=e[g[x][i]];
        if (d[x]+1==d[e0.v] && (f=dfs(e0.v,min(a,e0.c-e0.f)))>0) {
            e0.f+=f;
            e[g[x][i]^1].f-=f;
            flow+=f;
            a-=f;
            if (a==0)
                break;
        }
    }
    return flow;
}

int maxFlow() {
    int flow=0;
    while (bfs()) {
        memset(cur,0,sizeof(cur));
        flow+=dfs(s,INF);
    }
    return flow;
}

int main(void) {
    scanf("%d %d %d",&n,&p,&q);
    for (int i=1; i<=n; ++i)
        for (int j=1; j<=p; ++j)
            scanf("%d",&room[i][j]);
    for (int i=1; i<=n; ++i)
        for (int j=1; j<=q; ++j)
            scanf("%d",&dish[i][j]);
    build();
    printf("%d\n",maxFlow());
    return 0;
}

```

---

## 作者：plane (赞：0)

构图挺简单的一道最大流问题。

构图只需要增加一个虚拟的S和虚拟的T节点，并把一个人拆为两个人（为了限制一个人只能用一次）。然后跑一遍网络流就行


---


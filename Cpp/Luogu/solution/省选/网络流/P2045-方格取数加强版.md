# 方格取数加强版

## 题目描述

给出一个 $n\times n$ 的矩阵,每一格有一个非负整数 $A_{i,j}$（$A_{i,j} \le 10^3$），现在从 $(1,1)$ 出发，可以往右或者往下走，最后到达 $(n,n)$，每达到一格，把该格子的数取出来，该格子的数就变成 $0$，这样一共走 $K$ 次，现在要求 $K$ 次所达到的方格的数的和最大。

## 说明/提示

每个格子中的数不超过 $1000$。

## 样例 #1

### 输入

```
3 1
1 2 3
0 2 1
1 4 2```

### 输出

```
11```

# 题解

## 作者：xht (赞：26)

题目地址：[P2045 方格取数加强版](https://www.luogu.org/problemnew/show/P2045)

1. 点边转化：把每个格子 $(i,j)$ 拆成一个入点一个出点。
2. 从每个入点向对应的出点连两条有向边：一条容量为 $1$ ，费用为格子 $(i,j)$ 中的数；另一条容量为 $k-1$ ，费用为 $0$ 。
3. 从 $(i,j)$ 的出点到 $(i,j+1)$ 和 $(i+1,j)$ 的入点连有向边，容量为 $k$ ，费用为 $0$ 。
4. 以 $(1,1)$ 的入点为源点， $(n,n)$ 的出点为汇点，求最大费用最大流。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 5e3 + 6, M = 2e5 + 6;
const int inf = 0x3f3f3f3f, _inf = 0xcfcfcfcf;
int Head[N], Edge[M], Leng[M], Cost[M], Next[M], tot = 1;
int d[N], f[N], p[N];
bool v[N];
int n, k, s = 1, t, ans;

inline void add(int x, int y, int z, int c) {
	Edge[++tot] = y;
	Leng[tot] = z;
	Cost[tot] = c;
	Next[tot] = Head[x];
	Head[x] = tot;
	Edge[++tot] = x;
	Leng[tot] = 0;
	Cost[tot] = -c;
	Next[tot] = Head[y];
	Head[y] = tot;
}

inline int num(int i, int j, int k) {
	return (i - 1) * n + j + k * n * n;
}

inline bool spfa() {
	queue<int> q;
	memset(d, 0xcf, sizeof(d));
	memset(v, 0, sizeof(v));
	q.push(s);
	d[s] = 0;
	v[s] = 1;
	f[s] = inf;
	while (q.size()) {
		int x = q.front();
		v[x] = 0;
		q.pop();
		for (int i = Head[x]; i; i = Next[i]) {
			if (!Leng[i]) continue;
			int y = Edge[i];
			if (d[y] < d[x] + Cost[i]) {
				d[y] = d[x] + Cost[i];
				f[y] = min(f[x], Leng[i]);
				p[y] = i;
				if (!v[y]) {
					q.push(y);
					v[y] = 1;
				}
			}
		}
	}
	return d[t] != _inf;
}

void upd() {
	int x = t;
	while (x != s) {
		int i = p[x];
		Leng[i] -= f[t];
		Leng[i^1] += f[t];
		x = Edge[i^1];
	}
	ans += d[t] * f[t];
}

int main() {
	cin >> n >> k;
	t = 2 * n * n;
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= n; j++) {
			int c;
			scanf("%d", &c);
			add(num(i, j, 0), num(i, j, 1), 1, c);
			add(num(i, j, 0), num(i, j, 1), k - 1, 0);
			if (j < n) add(num(i, j, 1), num(i, j + 1, 0), k, 0);
			if (i < n) add(num(i, j, 1), num(i + 1, j, 0), k, 0);
		}
	while (spfa()) upd();
	cout << ans << endl;
	return 0;
}
```


---

## 作者：秋日私语 (赞：21)

安利个人[](http://blog.csdn.net/A_Comme_Amour/article/details/79580875)博客

题目
-

[传送门](https://www.luogu.org/problemnew/show/P2045)
给出一个n*n的矩阵,每一格有一个非负整数Aij,(Aij <= 1000)现在从(1,1)出发,可以往右或者往下走,最后到达(n,n),每达到一格,把该格子的数取出来,该格子的数就变成0,这样一共走K次,现在要求K次所达到的方格的数的和最大
题解
-

做了几道网络流的题目，对建图有一些理解。
1. 超级源点和超级汇点分别连向（1,1）（n , n），容量为k，费用为0，仅表示一共可以走k次；
2. 对于方格中的每个点，拆成两个点，分别为入点和出点。入点和出点之间连两条边，一条容量为1，费用为点的权值，表示每个点的数只可以取一次；另一条容量为inf，费用为0，仅表示可以经过无数次；
3. 对于在其下方或右边点的点，连一条容量为inf，费用为0的边，表示且仅表示一种联通的关系

最大费用最大流，实现上有一个小技巧，即把费用设为负数，再取相反数即可
代码
-


```
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<iostream>
#include<queue>
using namespace std;
const int maxn=100001;
const int inf=1e9;

int n,m,S,T,k,maxflow,mincost,last[maxn],pre[maxn],dis[maxn],flow[maxn];
bool vis[maxn];
struct Edge{
	int next,to,flow,dis;
}edge[maxn<<1];
int num_edge=-1,head[maxn];
queue <int> q;
int id(int x,int y) {return n*(x-1)+y;}

void add_edge(int from,int to,int flow,int dis)//flow流量 dis费用 
{
	edge[++num_edge].next=head[from];
	edge[num_edge].flow=flow;
	edge[num_edge].dis=dis;
	edge[num_edge].to=to;
	head[from]=num_edge;
}
void add(int x,int y,int z,int f) {add_edge(x,y,z,f); add_edge(y,x,0,-f);}

bool spfa(int s,int t)
{
	memset(dis,0x7f,sizeof(dis));
	memset(flow,0x7f,sizeof(flow));
	memset(vis,0,sizeof(vis));
	while (!q.empty()) q.pop();
	dis[s]=0; pre[t]=-1; q.push(s); vis[s]=1;
	int tot=0;
	while (!q.empty())
	{
		int now=q.front(); q.pop(); vis[now]=0;
//		printf("%d ",now); if (++tot==200) return 0;
		for (int i=head[now]; i!=-1; i=edge[i].next)
		{
			int to=edge[i].to;
			if  (edge[i].flow>0 && dis[to]>dis[now]+edge[i].dis)
			{
				dis[to]=edge[i].dis+dis[now];
				flow[to]=min(edge[i].flow,flow[now]);
				last[to]=i;
				pre[to]=now;
				if (!vis[to])
				{
					q.push(to); vis[to]=1;
				}
			}
		}
	}
	return pre[t]!=-1;
}

void MCMF(int s,int t)
{
	while (spfa(s,t))
	{
		int now=t;
		maxflow+=flow[t];
		mincost+=flow[t]*dis[t];
		while (now!=s)
		{
			edge[last[now]].flow-=flow[t];//dis . flow
			edge[last[now]^1].flow+=flow[t];
			now=pre[now];
		}
	}
}

int main()
{
	memset(head,-1,sizeof(head));
	scanf("%d%d",&n,&k);
	S=0; T=2*n*n+1;
	add(S,id(1,1),k,0); add(id(n,n)+n*n,T,k,0);
	for (int i=1; i<=n; i++)
		for (int j=1; j<=n; j++)
		{
			int x; scanf("%d",&x); x=-x;
			add(id(i,j),id(i,j)+n*n,1,x);
			add(id(i,j),id(i,j)+n*n,inf,0);
			if (i<n) add(id(i,j)+n*n,id(i+1,j),inf,0);
			if (j<n) add(id(i,j)+n*n,id(i,j+1),inf,0);
		}
	for (int i=0; i<=num_edge; i++) 
//	printf("%d: %d %d %d %d\n",i,edge[i^1].to,edge[i].to,edge[i].dis,edge[i].flow);
	n=T;//点数 
	MCMF(S,T);
	printf("%d",-mincost);
	return 0;
}
```

总结
-

限制走的次数一般转化为网络流中边权的问题；
拆点连容量为1的边表示只能取一次；容量为inf的边表示可以走的关系
又出错了：id（n，n）向T连边而不是id（n，n）。又调了好长时间

---

## 作者：芝麻糊糊 (赞：3)

高级版

《一看就是网络流，思想简单，bug难调，写这篇题解主要是给大家提个醒，，（外加题解太少。）

楼上思路清晰，那我主要说说程序

SPFA优化：注意顺序

建边时，因为是拆点，所以应设流量唯一，但走了一遍可以继续走，高能预警！！此时只能走k-1次；

其余的边可以走k-1次；》

初级版

如果刚做了方格取数，容易被误导。。

因为k次，拒绝暴力

容易想起，对边的次数有限制，方向明确，网络流啊！

上代码

    
```cpp
#include<cstdio>
#include<algorithm>
#define inf 0x7fffffff
#define mini 0x7fffffff/2
#define mew 5050000
using namespace std;
int n,k,ks,js,ahavev,amoney,pos=1;
int lata[mew],head[mew],qe[mew],used[mew];
struct s
{
    int last,now,canv,money;
}data[mew];
struct ss
{
    int fromd,num,havev,cost;
}vivo[mew];
void add(int a,int b,int c,int d)
{
    data[++pos].last=head[a];
    data[pos].now=b;
    data[pos].canv=c;
    data[pos].money=d;
    head[a]=pos;
}
void change(int &a,int &b)
{
    int kk=a;a=b;b=kk;
}
int search()
{
    int p=0,q=0;
    for(int i=1;i<=n;i++)
    {
        vivo[i].cost=mini;
        vivo[i].fromd=0;
        vivo[i].havev=0;
        vivo[i].num=0;
        used[i]=0;
    }
    vivo[ks].cost=0;//写错过
    vivo[ks].havev=mini;//写错过
    used[ks]=1;
    qe[0]=ks;
    for(;q<=p;q++)
     {                                                //写错过
        for(int t=head[qe[q%n]];t;t=data[t].last)
         if(data[t].canv&&vivo[data[t].now].cost>vivo[qe[q%n]].cost+data[t].money)
           {
                vivo[data[t].now].cost=vivo[qe[q%n]].cost+data[t].money;
                vivo[data[t].now].fromd=t;
                vivo[data[t].now].num=qe[q%n];
                vivo[data[t].now].havev=min(vivo[qe[q%n]].havev,data[t].canv);//写错过 
                if(used[data[t].now]==0)
                {
                    used[data[t].now]=1;
                    qe[++p%n]=data[t].now;
                if(vivo[qe[p%n]].cost<vivo[qe[(q+1)%n]].cost) 
                change(qe[p%n],qe[(q+1)%n]);
                }
           }
        used[qe[q%n]]=0;
     }
     if(vivo[js].cost!=mini) return 1;//写错过*2
     return 0;
}
void mimi()
{
    while(search())
    {
        ahavev+=vivo[js].havev;
        amoney+=vivo[js].cost*vivo[js].havev;
        int nn=js;
        while(nn)
        {
            data[vivo[nn].fromd].canv-=vivo[js].havev;
            data[vivo[nn].fromd^1].canv+=vivo[js].havev;
            nn=vivo[nn].num;
        }        
    }
    printf("%d\n",-amoney);
}
int main()
{
    freopen("f.in","r",stdin);
    freopen("f.out","w",stdout);
    scanf("%d%d",&n,&k);
    for(int i=1;i<=n;i++)
      for(int j=1;j<=n;j++)
        scanf("%d",&lata[(i-1)*n+j]);
    for(int i=1;i<=n*n;i++)
    {
        add(i*2-1,i*2,1,-lata[i]); 
        add(i*2,i*2-1,0,lata[i]);
        add(i*2-1,i*2,k-1,0); 
        add(i*2,i*2-1,0,0);
    }      
    int zs=n*(n-1);
    for(int i=1;i<n*n;i++)
    {
        if(i>zs) 
        {
            add(i*2,i*2+1,k,0);
            add(i*2+1,i*2,0,0); 
            continue;
        }
        if(i%n==0) 
        {
            add(i*2,(i+n)*2-1,k,0);
            add((i+n)*2-1,i*2,0,0);
            continue;
        }
        add(i*2,i*2+1,k,0);
        add(i*2+1,i*2,0,0); 
        add(i*2,(i+n)*2-1,k,0);
        add((i+n)*2-1,i*2,0,0);
    }
    add(n*n-1,n*n,k,0);
    add(n*n,n*n-1,0,0);
    ks=1;
    js=2*n*n;
    n=js;
    mimi();
    return 0;
}
```

---

## 作者：吾王美如画 (赞：3)

# 唔姆
感觉这题是道比较好的费用流，所以来写篇题解qwq

------------

既然这是加强版，那先看一下原版[P1004 方格取数](https://www.luogu.org/problemnew/show/P1004)

很明显原版一看就是dp，那我们这题可不可以用dp呢？。。。。。。。。。显然不行。~~大家肯定都是看了标签才来做的啊~~

那我们接着看，既然要取k次，并且每个数只能取一次，求最大取值，又限制流量，还要求价值，这一眼就看出来是个费用流。确定了方法，我们来想想怎么建图。
- 首先，为了限制每个数字只能取一次，我们把每个格子拆成两个点，在他们之间连上一条费用为A[i][j]流量为1的边，因为每个数只能取一次

- 接着，我们发现，一个格子的数被取走了，并不代表这个格子不能走了，只是不能获得价值了，于是我们在被拆开的两点间再连一条费用为0流量为**k-1**的边，用于限制走k次

- 然后，我们只要把格子和格子之间出点和入点连边，费用为0流量为k

最后直接跑个最大费用最大流就好了QAQ

~~码风巨毒，请见谅~~
```cpp
#include<queue>
#include<cstdio>
#include<iostream>
#include<cstring>
#define MAXM 100010
#define MAXN 3000
using namespace std;
int to[MAXM],next[MAXM],w[MAXM],cost[MAXM],head[MAXN*2];
int n,k,S,T,ansl=0,ansc=0;
int cnt=-1;
int pre1[MAXN*2],pre2[MAXN*2],low[MAXN*2],dis[MAXN*2];
void link(int a,int b,int c,int d){
     cnt++;
     next[cnt]=head[a];
     w[cnt]=c;
     cost[cnt]=d;
     to[cnt]=b;
     head[a]=cnt;
     cnt++;
     next[cnt]=head[b];
     w[cnt]=0;
     cost[cnt]=-d;
     to[cnt]=a;
     head[b]=cnt;
}
bool spfa(){
     queue<int>q;
     fill(dis,dis+MAXN*2-1,-1);
     int vis[MAXN*2];
     memset(vis,0,sizeof(vis));
     q.push(S);
     dis[S]=0;
     vis[S]=1;
     low[S]=66666666;
     while(!q.empty()){
                       int now=q.front();
                       vis[now]=0;
                       q.pop();
                       for(int i=head[now];i!=-1;i=next[i]){
                               if (w[i]>0&&cost[i]+dis[now]>dis[to[i]]){
                                                                        dis[to[i]]=dis[now]+cost[i];
                                                                        low[to[i]]=min(low[now],w[i]);
                                                                        pre1[to[i]]=now;
                                                                        pre2[to[i]]=i;
                                                                        if (!vis[to[i]]){
                                                                                         vis[to[i]]=1;
                                                                                         q.push(to[i]);
                                                                        }
                               }
                       }
     }
     return dis[T]!=-1;
}
void work(){
     while(spfa()){
                   int now=T;
                   while(now!=S){
                                 int y=pre2[now];
                                 w[y]-=low[T];
                                 w[y^1]+=low[T];
                                 now=pre1[now];
                   }
                   ansl+=low[T];
                   ansc+=low[T]*dis[T];
     }
}
int num(int a,int b){
    return (a-1)*n+b;
}
int tu[60][60];
int main(){
    memset(head,-1,sizeof(head));
    cin>>n>>k;
    S=num(1,1);T=num(n,n)+MAXN;
    for(int i=1;i<=n;i++){
            for(int j=1;j<=n;j++){
                    scanf("%d",&tu[i][j]);
            }
    }
    for(int i=1;i<=n;i++){
            for(int j=1;j<=n;j++){
                    link(num(i,j),num(i,j)+MAXN,1,tu[i][j]);link(num(i,j),num(i,j)+MAXN,k-1,0);
                    if (i+1<=n) link(num(i,j)+MAXN,num(i+1,j),k,0);
                    if (j+1<=n) link(num(i,j)+MAXN,num(i,j+1),k,0);
            }
    }               
    work();
    cout<<ansc<<endl;
    return 0;
}

```

---

## 作者：Night_Aurora (赞：3)

把一个点拆成两个点，一个入点，一个出点。

入点到出点有两条边：1.流量为1费用为当前格的负数，2.流量为无穷大费用为0的边

可以保证一个数只会取一次。由于格子数都是正数，所以不会发生优先走0费的边的情况

与此同时把(a,b)的出点与(a+1,b)与(a,b+1)的入点连一条无限流量无费用的边表示移动

超级源链接(1,1)的入点，流量K费用0

(N,N)出点链接超级汇，流量K费用0

这样就完全转化成费用流模板了

不过这算法对负权格子没用，牢记牢记









```cpp
#include <stdio.h>
#include <string.h>
#include <queue>
#define MXE 600000
#define INP(x,y) ((x)*50+(y))
#define OUP(x,y) ((x)*50+(y)+3000)
#define MXP 7000
#define SP 0
#define TP 6500
#define INF 0x3FFFFFFF
#define min(a,b) (a>b?b:a)
#define max(a,b) (a>b?a:b)
int N,K;
int Rect[60][60];
typedef struct Edge
{
    int Fr,To;
    int MF,NF;
    int Cost;
    Edge*Back;
}EG,*LPEG;
int EHead[MXP],ENext[MXE];
EG EDat[MXE];
int Elt;
LPEG AddEdge(int Fr,int To,int MF,int C)
{
    ++Elt;
    ENext[Elt]=EHead[Fr];
    EDat[Elt].Fr=Fr;
    EDat[Elt].To=To;
    EDat[Elt].MF=MF;
    EDat[Elt].NF=0;
    EDat[Elt].Cost=C;
    EHead[Fr]=Elt;
    return EDat+Elt;
}
void AddPair(int Fr,int To,int MF,int Cs)
{
    LPEG G,B;
    G=AddEdge(Fr,To,MF,Cs);
    B=AddEdge(To,Fr,0,-Cs);
    G->Back=B;
    B->Back=G;
}
```
class MCMF
```cpp
{
    int Vist[MXP];
    int SVist[MXP];
    int Dist[MXP];
    std::queue<int> Qe;
    LPEG Back[MXP];
    void SPFA();
    int Flow();
```
public:






```cpp
    int MinCost();
};
void MCMF::SPFA()
{
    int wp,we;
    LPEG bf;
    memset(Vist,0,sizeof(Vist));
    memset(SVist,0,sizeof(SVist));
    Qe.push(SP);
    Vist[SP]=1;
    Dist[SP]=0;
    SVist[SP]=1;
    while(!Qe.empty())
    {
        wp=Qe.front();Qe.pop();
        SVist[wp]=0;
        for(we=EHead[wp];we;we=ENext[we])
        {
            bf=EDat+we;
            if(bf->MF==bf->NF)continue;
            if(Vist[bf->To]&&Dist[wp]+bf->Cost>=Dist[bf->To])
                continue;
            Dist[bf->To]=Dist[wp]+bf->Cost;
            Back[bf->To]=bf;
            Vist[bf->To]=1;
            if(!SVist[bf->To])
                Qe.push(bf->To);
            SVist[bf->To]=1;
        }
    }
}
int MCMF::Flow()
{
    int wp,ret=0;
    int wl=INF;
    LPEG wf;
    wp=TP;
    while(wp-SP)
    {
        wf=Back[wp];
        wp=wf->Fr;
        wl=min(wl,wf->MF-wf->NF);
    }
    wp=TP;
    while(wp-SP)
    {
        wf=Back[wp];
        ret+=wf->Cost*wl;
        wf->NF+=wl;
        wf->Back->NF-=wl;
        wp=wf->Fr;
    }
    return ret;
}
int MCMF::MinCost()
{
    int ret=0;
    SPFA();
    while(Vist[TP])
    {
        ret+=Flow();
        SPFA();
    }
    return ret;
}
void Input()
{
    scanf("%d %d",&N,&K);
    int wia,wib;
    for(wia=1;wia<=N;++wia)
        for(wib=1;wib<=N;++wib)
        {
            scanf("%d",Rect[wia]+wib);
            AddPair(INP(wia,wib),OUP(wia,wib),1,-Rect[wia][wib]);
            AddPair(INP(wia,wib),OUP(wia,wib),INF,0);
        }
    for(wia=1;wia<=N;++wia)
        for(wib=1;wib<=N;++wib)
        {
            if(wia<N)
                AddPair(OUP(wia,wib),INP(wia+1,wib),INF,0);
            if(wib<N)
                AddPair(OUP(wia,wib),INP(wia,wib+1),INF,0);
        }
    AddPair(SP,INP(1,1),K,0);
    AddPair(OUP(N,N),TP,K,0);
}
MCMF Mc;
void AC()
{
    int Res=Mc.MinCost();
    printf("%d\n",-Res);
}
int main()
{
    Input();
    AC();
    return 0;
}
```

---

## 作者：tzc_wk (赞：2)

## 网络瘤大法好！

我们考虑将每一个点拆成入点和出点两个点，然后按照以下方式建图：

1. 连一条从超级源点到 $(1,1)$ 的入点，流量为 $k$，费用为 $0$ 的边，表示最多可以走 $k$ 次

2. 同理，连一条从 $(n,n)$ 的出点到超级汇点，流量为 $k$，费用为 $0$ 的边。

3. 对于每个点，在入点和出点之间连两条边，一条流量为 $1$，费用为 $a_{i,j}$，表示只能取一次，另一条流量为 $\infty$ ，费用为 $0$ 的边，表示取完之后就没有了，

4. 对于每个点，在这个点的出点与这个点右、下方的点的出点之间连一条容量为 $\infty$，费用为 $0$ 的边。

然后跑最大费用最大流即可。

注意把所有边变为负数，转化为最小费用最大流。

```cpp
/*
数据不清空，爆零两行泪。
多测不读完，爆零两行泪。
边界不特判，爆零两行泪。
贪心不证明，爆零两行泪。
D P 顺序错，爆零两行泪。
大小少等号，爆零两行泪。
变量不统一，爆零两行泪。
越界不判断，爆零两行泪。
调试不注释，爆零两行泪。
溢出不 l l，爆零两行泪。
*/
#include <bits/stdc++.h>
using namespace std;
#define fi			first
#define se			second
#define fz(i,a,b)	for(int i=a;i<=b;i++)
#define fd(i,a,b)	for(int i=a;i>=b;i--)
#define put(x)		putchar(x)
#define eoln        put('\n')
#define space		put(' ')
//#define int long long
inline int read(){
	int x=0,neg=1;char c=getchar();
	while(!isdigit(c)){
		if(c=='-')	neg=-1;
		c=getchar();
	}
	while(isdigit(c))	x=x*10+c-'0',c=getchar();
	return x*neg;
}
inline void print(int x){
	if(x<0){
		putchar('-');
		print(abs(x));
		return;
	}
	if(x<=9)	putchar(x+'0');
	else{
		print(x/10);
		putchar(x%10+'0');
	}
}
int ecnt=1,head[100005];
struct edge{
	int to,nxt,cap,cost;
} e[100005];
inline void addedge(int u,int v,int f,int c){
	e[++ecnt].to=v;e[ecnt].cap=f;e[ecnt].cost=c;e[ecnt].nxt=head[u];head[u]=ecnt;
}
bool vis[6010];
int dist[6010],flow[6010],pre[6010],pos[6010];
inline bool spfa(int s,int t){
	memset(vis,1,sizeof(vis));
	memset(dist,63,sizeof(dist));
	queue<int> q;
	vis[s]=0;
	dist[s]=0;
	flow[s]=0x3f3f3f3f;
	q.push(s);
	while(!q.empty()){
		int x=q.front();
//		cout<<x<<endl;
		vis[x]=true;
		for(int i=head[x];i;i=e[i].nxt){
			int y=e[i].to;
//			cout<<y<<endl;
			if(e[i].cap>0&&dist[y]>dist[x]+e[i].cost){
				dist[y]=dist[x]+e[i].cost;pos[y]=x;pre[y]=i;
				flow[y]=min(flow[x],e[i].cap);
//				cout<<flow[y]<<endl;
				if(vis[y]){
					q.push(y);
					vis[y]=false;
				}
			}
		}
		q.pop();
	}
//	cout<<flow[t]<<endl;
	return dist[t]<0x3f3f3f3f;
}
inline int Dinic(int s,int t){
	int sum=0;
	while(spfa(s,t)){
		sum+=flow[t]*dist[t];
		for(int i=t;i!=s;i=pos[i]){
			e[pre[i]].cap-=flow[t];
			e[pre[i]^1].cap+=flow[t];
		}
	}
	return sum;
}
int n=read(),k=read();
inline int id(int x,int y,int c){
	return (n*(x-1)+y)*2-(c%2);
}
const int dx[]={1,0};
const int dy[]={0,1};
signed main(){
	fz(i,1,n){
		fz(j,1,n){
			int v=read();
			addedge(id(i,j,1),id(i,j,2),1,-v);
			addedge(id(i,j,2),id(i,j,1),0,v);
			addedge(id(i,j,1),id(i,j,2),0x3f3f3f3f,0);
			addedge(id(i,j,2),id(i,j,1),0,0);
			for(int l=0;l<2;l++){
				int x=i+dx[l],y=j+dy[l];
				if(x<1||x>n||y<1||y>n)	continue;
				addedge(id(i,j,2),id(x,y,1),0x3f3f3f3f,0);
				addedge(id(x,y,1),id(i,j,2),0,0);
			}
		}
	}
	addedge(0,id(1,1,1),k,0);
	addedge(id(1,1,1),0,0,0);
	addedge(id(n,n,2),2*n*n+1,k,0);
	addedge(2*n*n+1,id(n,n,2),0,0);
	cout<<-Dinic(0,2*n*n+1)<<endl;
	return 0;
}
```

~~最后，祝大家新年快乐！~~

---

## 作者：MaxDYF (赞：2)

[安利一下我的博客](https://www.luogu.org/blog/MaxDYF/)

[还有我的知乎](https://www.zhihu.com/people/maxdyf)

### 一道挺好的费用流模板。
当看到只能走K次时，根据直觉~~盲目猜测~~，初步判断可以转换为**网络流的边流量限制**，即限制汇入汇点的总流量。

然而这题还有一个“方格中的数字”，要求求最大，于是，就有了费用流的费用限制。

但是，费用流的全称为“**最小费用**最大流”，但是这题要求求**最大“费用”**（即数字之和），所以这题其实是“最大费用最大流”？？？

思考到这里，来想想怎么建图。

### First
首先，方格中的数字，我们只能够**取一次**，于是我们可以考虑对每个点$x$进行**拆点**，拆分为“入点”与“出点”，分别记为$x'$和$x''$，然后连一条边，即$x'\xrightarrow{flow=1,cost=a_{i,j}} x''$，其中$a_{i,j}$表示每个点的数字，限制经过每个点获取的数字。

但是，每个点被取走数字后，并不是不能再走了，而只是数字变为$0$，于是我们再在$x’$与$x''$之间建一条边$x'\xrightarrow{flow=inf,cost=0}x''$。

### Second
然后呢，每个点可以走到下方的点或右方的点，于是我们将其连接：

设$x_{i,j}$、$x_{i,j+1}$与$x_{i+1,j}$

$x_{i,j}''\xrightarrow{flow=inf,cost=0}x_{i,j+1}'$。

$x_{i,j}''\xrightarrow{flow=inf,cost=0}x_{i+1,j}'$。

即表示可以走无数次，但不增加其$cost$。

### Third

此时我们还没有连接源点与汇点，虽然连接哪里是显而易见的了……

我们设源点为$S$，汇点为$T$，因为我们只能走$K$次，所以我们把源点流出的流量与流入汇点的流量都设置为$K$，$cost$设为$0$，即：

$S\xrightarrow{cost=0,flow=K}x'_{1,1}$,
$x'_{n,n}\xrightarrow{cost=0,flow=K}T$

于是，建边部分就完成了！

### Summary

总的来说建边的过程还是很好想的，下面来总结一下。

1. $\sum {x'_{i,j}},{x''_{i,j}},$

	$x'\xrightarrow{flow=1,cost=a_{i,j}} x''$

1. $\sum {x_{i,j}},$

	$x_{i,j}''\xrightarrow{flow=inf,cost=0}x_{i,j+1}'$,
    
	$x_{i,j}''\xrightarrow{flow=inf,cost=0}x_{i+1,j}'$。

1. 
	$S\xrightarrow{cost=0,flow=K}x'_{1,1}$,
    
	$x'_{n,n}\xrightarrow{cost=0,flow=K}T$



### About Network Flow
前面说了，这题的实质是“最大费用最大流”，所以直接照着板子打费用流是不行的。这里提供两种解决方法：

1、赋值费用时赋值为相反数，然后原来**最大的**就变成**最小的**……然后取$minflow$的相反数输出。

2、在SPFA部分的判断条件部分的$cost[y]>cost[x]+edge[i].cost$改为$cost[y]<cost[x]+edge[i].cost$，然后$mincost$就变成了$maxcost$辣。

先贴我的$EK$代码。

### CODE：
```cpp
//Luogu P2045
//Solution: EK Network Flow, Minimum Cost Maximum Flow 
//Written by MaxDYF
#include <bits/stdc++.h>
using namespace std;
const int NODE = 1000000;
const int EDGE = 1000000;
const int inf = 1e9;
//Index of Edge
struct Edge{
	int to, nxt, flow, cost;
}edge[EDGE << 1];
int head[NODE], cnt = 1;

//Indexs of EK Network Flow
int flow[NODE];
int cost[NODE];
int pre[NODE]; //record the last NODE of the present NODE in the road.
int last[NODE];//record the last EDGE of the present NODE.

//The Start and End
int S, T;

//The Indexs to record result
int maxflow, mincost;

//Something for SPFA
bool vis[NODE];
queue<int> que;

//The functions
void add(int, int, int, int);
bool spfa();
void work();

//All the things above here are about the Network Flow.
//And the things under here are about the Problem.
int a[60][60];//record the map

//They are for Spliting NODEs
int start[60][60];
int end[60][60];

//main function
int main()
{
	int n, k, cnt = 1;
	cin >> n >> k;
	//set the Start and the End
	S = 0;
	T = 2 * n * n + 1;
	for(int i = 1; i <= n; ++i)
	{
		for(int j = 1; j <= n; ++j)
		{
			cin >> a[i][j];
			a[i][j] = -a[i][j];
			//One of the MOST IMPORTANT things: split each NODE into 2 NODEs
			start[i][j] = ++cnt;
			end[i][j] = ++cnt;
		}
	}
	//Tips:
	//In this problem, the "cost" is refer to the Price of the Node.
	//So we have to get the "Max 'Cost'" instead of "Min 'Cost'".
	//To achieve our goal, we can turn the "cost"
	//to its opposite number.
	//And get the opposite number of the answer.
	//:) 
	for(int i = 1; i <= n; ++i)
	{
		for(int j = 1; j <= n; ++j)
		{
			//Add edge for these two NODEs
			add(start[i][j], end[i][j], 1, a[i][j]);
			//set the Flow of the Edge between them to 1
			//to make sure that the Number can only be taken once.
			add(start[i][j], end[i][j], inf, 0);
			//to make sure that this Node can be walked many times.
			if(i < n)
				add(end[i][j], start[i+1][j], inf, 0);
			if(j < n)
				add(end[i][j], start[i][j+1], inf, 0);
			//just means they are connected, 
			//and can't get any "cost"(or price) any more.
		}
	}
	add(S, start[1][1], k, 0);
	add(end[n][n], T, k, 0);
	//make sure there are only "k" roads being collected.
	work();
	cout << -mincost;
}

//functions
bool spfa()
{
	//init
	memset(vis, 0, sizeof vis);
	memset(flow, 0x3f, sizeof flow);
	memset(cost, 0x3f, sizeof cost);
	cost[S] = 0;
	pre[T] = -1;
	que.push(S);
	vis[S] = 1;
	//main work of SPFA
	while (!que.empty())
	{
		int x = que.front();
		que.pop();
		vis[x] = 0;
		for (int i = head[x]; i; i = edge[i].nxt)
		{
			int y = edge[i].to;
			//if the present node is not the CHEAPEST
			if((cost[y] > cost[x] + edge[i].cost) && (edge[i].flow > 0))
			{
				//update the node
				//and its "pre" and "last"
				cost[y] = cost[x] + edge[i].cost;
				flow[y] = min(flow[x], edge[i].flow);
				pre[y] = x;
				last[y] = i;
				if(!vis[y])
				{
					vis[y] = 1;
					que.push(y);
				}
			}
		}
	}
	return pre[T] != -1; 
}
void add(int x, int y, int flow, int cost)
{
	edge[++cnt] = Edge{y, head[x], flow, cost};
	head[x] = cnt;
	edge[++cnt] = Edge{x, head[y], 0, -cost};
	head[y] = cnt;
}
void work()
{
	//EK Network Flow Algorithm
	//Nothing worth saying.
	//Isn't it?
	//If you can't understand it,
	//you'd better learn The EK Algorithm first.
	while(spfa())
	{
		maxflow += flow[T];
		mincost += flow[T] * cost[T];
		int now = T;
		while(now != S)
		{
			edge[last[now]].flow -= flow[T];
			edge[last[now] ^ 1].flow += flow[T];
			now = pre[now];
		}
	}
}
```


---

## 作者：Victorique (赞：1)

考虑如何建图。还是老样子先拆点，然后把每两个点之间连接两条边，一条流量为1，费用为-点权，处理是否走这个点。一条流量无限，没有费用，因为哪怕一个点选过了，它的地方还是可以重复走过去的。
然后把经由一个点能到达的另一个点连边。因为要走k次，所以由s向1号点入点连边，n号点出点向t连边，流量为k，费用为0。然后一边最小费用最大流板子即可。
然后发现这些个题解里没有用原始对偶来实现的，所以弱弱的拿出自己代码，勉强还是能在最优解第一页里的，膜拜那些50ms都不到就跑完的dalao们。
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<queue>
#define ll long long
#define rp (i-1)*n+j 
#define cp (i-1)*n+j+n*n 
#define inf 50000000
#define re register
using namespace std;
struct po
{
	int from,to,dis,nxt,w;
}edge[250001];
int head[250001],cur[1000001],dep[60001],n,m,s,t,u,num=-1,x,y,l,tot,sum,k;
int dis[6001],b[6001],xb[20001],flow[20001],a[55][55];
inline int read()
{
    int x=0,c=1;
    char ch=' ';
    while((ch>'9'||ch<'0')&&ch!='-')ch=getchar();
    while(ch=='-')c*=-1,ch=getchar();
    while(ch<='9'&&ch>='0')x=x*10+ch-'0',ch=getchar();
    return x*c;
}
inline void add_edge(int from,int to,int w,int dis)
{
	edge[++num].nxt=head[from];
	edge[num].to=to;
	edge[num].w=w;
	edge[num].dis=dis;
	head[from]=num;
}
inline void add(int from,int to,int w,int dis)
{
	add_edge(from,to,w,dis);
	add_edge(to,from,0,-dis);
}
inline bool spfa()
{
	memset(b,0,sizeof(b));
	memset(dis,100,sizeof(dis));
	deque<int> q;
	while(!q.empty())
	q.pop_back();
	dis[t]=0;b[t]=1;
	q.push_back(t);
	while(!q.empty())
	{
		int u=q.front();
		q.pop_front();
		b[u]=0;
		for(re int i=head[u];i!=-1;i=edge[i].nxt)
		{
			int v=edge[i].to;
			if(edge[i^1].w>0&&dis[v]>dis[u]-edge[i].dis)
			{
				dis[v]=dis[u]-edge[i].dis;
				if(!b[v])
				{
					b[v]=1;
					if(!q.empty()&&dis[v]<dis[q.front()])
					q.push_front(v);
					else
					q.push_back(v);
				}
			}
		}
	}
	return dis[s]<inf;
}
inline int dfs(int u,int low)
{
	if(u==t)
	{
		b[t]=1;
		return low;
	}
	int diss=0;
	b[u]=1;
	for(re int i=head[u];i!=-1;i=edge[i].nxt)
	{
		int v=edge[i].to;
		if(!b[v]&&edge[i].w!=0&&dis[v]==dis[u]-edge[i].dis)
		{
			int check=dfs(v,min(low,edge[i].w));
			if(check>0)
			{
				tot+=check*edge[i].dis;
				low-=check;
				diss+=check;
				edge[i].w-=check;
				edge[i^1].w+=check;
				if(low==0) break;
			}
		}
	}
	return diss;
}
inline void max_flow()
{
	int ans=0;
	while(spfa())
	{
		b[t]=1;
		while(b[t]==1)
		{
			memset(b,0,sizeof(b));
			ans=dfs(s,inf);
		}
	}
}
int main()
{
	memset(head,-1,sizeof(head));
	n=read();k=read();
	for(re int i=1;i<=n;i++)
	 for(re int j=1;j<=n;j++)
	 	a[i][j]=read();
	s=0;t=n*n*2+1;
	add(s,1,k,0);add(n*n*2,t,k,0);
	for(re int i=1;i<=n;i++)
	 for(re int j=1;j<=n;j++)
	 {
	 	add(rp,cp,1,-a[i][j]);
	 	add(rp,cp,inf,0);
	 	if(i<n)
	 	add(cp,rp+n,inf,0);
	 	if(j<n)
	 	add(cp,rp+1,inf,0);
	 }
	max_flow();
	cout<<-tot;
} 
```

---

## 作者：Dispwnl (赞：1)

作为一个蒟蒻竟然能不看题解A掉这道题

当然要写片题解来庆祝一下（^-^）

其实这题似乎是 [深海机器人问题](https://www.luogu.org/problemnew/show/4012 "深海机器人问题") 的简化版

都是最大费用最大流（瞎起名字）

把坐标压为点

建图
对于每个点

分为入点和出点

两点间连容量为1（只能取一次）费用为-点权（跑最小费用最大流）的边

但只能取一次不代表只能过一次

所以两点间再连容量为INF费用为0的边

对于原来每一个点

如果它下面还有点

就将两点的出点和入点连容量为INF费用为0的边

然后跑最小费用最大流就行了

注意答案为负数

记得加负号

```cpp
# include<iostream>
# include<cstdio>
# include<cstring>
# include<queue>
# define pu(x,y) (x-1)*n+y
using namespace std;
const int MAX=4000001,Max=10001,INF=1e8;
struct p{
    int x,y,dis,cn;
}c[MAX];
int n,k,num,tot1,t;
int h[Max],d[Max],pre[Max];
bool use[Max];
void add(int x,int y,int dis,int cn)
{
    c[num].x=h[y];c[num].y=x;c[num].dis=0;c[num].cn=-cn;h[y]=num++;
    c[num].x=h[x];c[num].y=y;c[num].dis=dis;c[num].cn=cn;h[x]=num++;
}
void EK()
{
    while(k--)
    {
        queue<int> qu;
        qu.push(1);
        memset(d,1,sizeof(d));
        d[1]=0;
        while(!qu.empty())
        {
            int tt=qu.front();
            qu.pop();
            use[tt]=0;
            for(int i=h[tt];i;i=c[i].x)
              if(d[c[i].y]>d[tt]+c[i].cn&&c[i].dis)
              {
                  d[c[i].y]=d[tt]+c[i].cn;
                  pre[c[i].y]=i;
                  if(!use[c[i].y])
                  {
                      use[c[i].y]=1;
                      qu.push(c[i].y);
                }
              }
        }
        if(d[t]>1e7) return;
        int hh=t,sum=INF;
        while(pre[hh])
        {
            int l=pre[hh];
            sum=min(sum,c[l].dis);
            hh=c[l^1].y;
        }
        hh=t;
        while(pre[hh])
        {
            int l=pre[hh];
            c[l].dis-=sum;
            c[l^1].dis+=sum;
            tot1+=sum*c[l].cn;
            hh=c[l^1].y;
        }
    }
}
int main()
{
    scanf("%d%d",&n,&k);
    int N=2500;
    t=n*n+N;
    for(int i=1;i<=n;i++)
      for(int j=1;j<=n;j++)
        {
            int x,hh;
            scanf("%d",&x);
            hh=pu(i,j);
            add(hh,hh+N,1,-x);
            add(hh,hh+N,INF,0);
            if(i!=n)
            add(hh+N,pu(i+1,j),INF,0); 
            if(j!=n)
            add(hh+N,pu(i,j+1),INF,0);
        }
    EK();
    printf("%d",-tot1);
    return 0;
}
```

---

## 作者：zxxzdq (赞：1)

###  首先，这道题不能用DP，会被卡掉！！！
#### 其次，这道题是网络流中的费用流
## 网络流，~~Are you kidding me???~~
##### 既然是网络流，那么我们需要知道如何
# 建边
##### 我们现在知道权值在点上，但费用在边上
##### 我们需要把一个点拆成两个点A,B就行了，这两个点之间，A->B的容量为1，费用为这个点的权值，B->A的容量为0，费用为这个点的权值的相反数
## 话不多说，上代码
    
```cpp
  #include<bits/stdc++.h>
  using namespace std;
  #define inf 0x3f3f3f3f
  #define maxm 500005
  #define maxn 6010
  int T,m,n,v[maxm],r[maxm],cost[maxm],nex[maxm],head[maxn];
  int dist[maxn],inc[maxn],pr[maxn],vis[maxn];
  int tot,s,t,ans1,ans2,K;

  void add(int x,int y,int z,int c){
      v[++tot]=y,r[tot]=z,cost[tot]=c;
      nex[tot]=head[x],head[x]=tot;//邻接表存正图
      v[++tot]=x,r[tot]=0,cost[tot]=-c;
      nex[tot]=head[y],head[y]=tot;//邻接表存反图
  }
  int num(int a,int b,int c){
      int ans=(a-1)*n+b+c*n*n;
      return ans;
  }
  int spfa(){
      s=1,t=2*n*n;
      queue<int> q;
      q.push(s);
      memset(dist,-1,sizeof(dist));
      memset(vis,0,sizeof(vis));
      vis[s]=1,dist[s]=0,inc[s]=inf;
      while(!q.empty()){
          int cur=q.front();
          vis[cur]=0;
          q.pop();
          for(int i=head[cur];i;i=nex[i]){
              if(!r[i]) continue;
              int ne=v[i];
              if(dist[ne]<dist[cur]+cost[i]){
                  dist[ne]=dist[cur]+cost[i];
                  inc[ne]=min(inc[cur],r[i]);
                  pr[ne]=i;
                  if(!vis[ne]) vis[ne]=1,q.push(ne);
                  }
              }
          }
      if(dist[t]==-1) return false;
      return true;
  }
  void update(){
      int tmp=t;
      while(tmp!=s){
          int tm=pr[tmp];
          r[tm]-=inc[t];
          r[tm^1]+=inc[t];
          tmp=v[tm^1];
      }
      ans1+=inc[t];
      ans2+=dist[t]*inc[t];
  }
  int main(){
    ans1=ans2=0;
    memset(v,0,sizeof(v));
    memset(r,0,sizeof(r));
    memset(cost,0,sizeof(cost));
    memset(nex,0,sizeof(nex));
    memset(head,0,sizeof(head));
    memset(inc,0,sizeof(inc));
    memset(pr,0,sizeof(pr));
    scanf("%d%d",&n,&K);
    tot=1;
    for(int i=1;i<=n;i++)
    for(int j=1;j<=n;j++){
        int c;
        scanf("%d",&c);
        add(num(i,j,0),num(i,j,1),1,c);
        add(num(i,j,0),num(i,j,1),K-1,0);
        if(j!=n) add(num(i,j,1),num(i,j+1,0),K,0);
        if(i!=n) add(num(i,j,1),num(i+1,j,0),K,0);
    }
    while(spfa()) update();
    printf("%d\n",ans2);
  }
```

---

## 作者：Gypsophila (赞：0)

### Description

给出一个 $n*n$ 的矩阵,每一格有一个非负整数 $A_{i,j}$ ,($A_{i,j} <= 1000$)现在从 $(1,1)$ 出发,可以往右或者往下走,最后到达 $(n,n)$ ,每达到一格,把该格子的数取出来,该格子的数就变成 $0$ ,这样一共走 $K$ 次,现在要求 $K$ 次所达到的方格的数的和最大

### Solution

一条边 $(a,b)$ 表示容量为 $a$ ，费用为 $b$ 。

把每个点拆成两个点，入点和出点。入点用来接受边，出点用来发出边

源点向 $(1,1)$ 连一条边 $(k,0)$ ，$(n,n)$ 向汇点连一条 $(k,0)$ ，表示可以走 $k$ 次

每个点往他的右和下分别连一条 $(\infty, 0)$ 表示联通关系

每个点的入点与出点之间连两条边 $(1,x)$ 和 $(\infty, 0)$。$x$ 是该点的权值。

这是因为每个点只能取一次。

然后跑一遍最大费用最大流就完事啦

小技巧：把费用取负然后跑最小费用最大流


### Code

[看代码戳这里](https://www.cnblogs.com/acfunction/p/10105245.html)

---

## 作者：QwQ2000 (赞：0)

费用流 建图方式在注释里写了

把一个点拆开确保走的次数正确

用费用表示取数

最后求最大费用最大流


另外这个题的数据范围我怀疑有问题……

我改了好几次边数

开50w边WA

改100w边就A了 莫名其妙……

```cpp

#include <cstdio>
#include <algorithm>

using namespace std;

const int N=51,E=1000000,S=0,T=30000,INF=1e9;

int n=0,a[N][N],k=0;
int edge=0,next[E],to[E],head[E],cap[E],cost[E],flow[E];
int dis[E],prev[E],inq[E],q[E],pos[E],front=0,tail=0;

void addEdge(int u,int v,int c,int w) {
    cap[edge]=c,cost[edge]=w,to[edge]=v,next[edge]=head[u],head[u]=edge++;
    cap[edge]=0,cost[edge]=-w,to[edge]=u,next[edge]=head[v],head[v]=edge++;
    flow[edge-1]=flow[edge-2]=0;
}

//拆点 连两条边 cap=1 cost=a[i][j]和cap=k cost=0
//拆开的第一个点1~n^2 第二个点n^2+1~2n^2 
//S=0 T=30000
void build() {
    addEdge(S,1,k,0);
    addEdge(2*n*n,T,k,0);
    for (int i=1;i<=n;++i)
        for (int j=i;j<=n;++j) {
            addEdge(i+(j-1)*n,i+(j-1)*n+n*n,1,a[j][i]);
            addEdge(i+(j-1)*n,i+(j-1)*n+n*n,k,0);
            if (j!=n)
                addEdge(i+(j-1)*n+n*n,i+j*n,k,0);
            if (i!=n)
                addEdge(i+(j-1)*n+n*n,i+1+(j-1)*n,k,0);
            if (i!=j) {
                addEdge(j+(i-1)*n,j+(i-1)*n+n*n,1,a[i][j]);
                addEdge(j+(i-1)*n,j+(i-1)*n+n*n,k,0);
                if (i!=n)
                    addEdge(j+(i-1)*n+n*n,j+i*n,k,0);
                if (j!=n)
                    addEdge(j+(i-1)*n+n*n,j+1+(i-1)*n,k,0);
            }
        }
}

int spfa() {
    for (int i=S;i<=2*n*n;++i)
        dis[i]=-INF;
    dis[T]=-INF;
    prev[T]=-1;
    q[tail++]=S;
    inq[S]=1;
    dis[S]=0;
    while (front<tail) {
        int x=q[front++];
        inq[x]=0;
        for (int i=head[x];i!=-1;i=next[i]) {
            int v=to[i];
            if (cost[i]+dis[x]>dis[v] && flow[i]<cap[i]) {
                dis[v]=cost[i]+dis[x];
                prev[v]=x;
                pos[v]=i;
                if (!inq[v]) {
                    q[tail++]=v;
                    inq[v]=1;
                }
            }

        }
    }
    return prev[T]==-1?0:1;
}

long long mcmf() {
    long long cst=0;
    int f=0;
    while (spfa()) {
        f=INF;
        for (int i=T;i!=S;i=prev[i])
            f=min(f,cap[pos[i]]-flow[pos[i]]);
        cst+=f*dis[T];
        for (int i=T;i!=S;i=prev[i]) {
            flow[pos[i]]+=f;
            flow[pos[i]^1]-=f;
        }
    }
    return cst;
}

int main(void) {
    for (int i=0;i<=E;++i)
        head[i]=-1;
    scanf("%d %d",&n,&k);
    for (int i=1;i<=n;++i)
        for (int j=1;j<=n;++j)
            scanf("%d",&a[i][j]);
    build();
    printf("%lld\n",mcmf());
    return 0;
}

```

---


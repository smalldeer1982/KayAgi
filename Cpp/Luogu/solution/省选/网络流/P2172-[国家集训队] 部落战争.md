# [国家集训队] 部落战争

## 题目背景

lanzerb 的部落在 A 国的上部，他们不满天寒地冻的环境，于是准备向A国的下部征战来获得更大的领土。

## 题目描述

A 国是一个 $M\times N$ 的矩阵，其中某些地方是城镇，某些地方是高山深涧无人居住。lanzerb 把自己的部落分成若干支军队，他们约定：

每支军队可以从任意一个城镇出发，并只能从上往向下征战，不能回头。途中只能经过城镇，不能经过高山深涧。

如果某个城镇被某支军队到过，则其他军队不能再去那个城镇了。
每支军队都可以在任意一个城镇停止征战。

所有军队都很奇怪，他们走的方法有点像国际象棋中的马。不过马每次只能走 $1\times2$ 的路线，而他们只能走 $R\times C$ 的路线。

lanzerb 的野心使得他的目标是统一全国，但是兵力的限制使得他们在配备人手时力不从心。假设他们每支军队都能顺利占领这支军队经过的所有城镇，请你帮 lanzerb 算算至少要多少支军队才能完成统一全国的大业。

## 说明/提示

#### 数据规模与约定

对于 $100\%$ 的数据，$1\le M,N\le 50,1\le R,C\le 10$。

## 样例 #1

### 输入

```
3 3 1 2
...
.x.
...```

### 输出

```
4```

## 样例 #2

### 输入

```
5 4 1 1
....
..x.
...x
....
x...```

### 输出

```
5
```

# 题解

## 作者：mgzc (赞：11)

# [题面](https://www.luogu.org/problemnew/show/P2172)

​	我们可以将'.'抽象为一个可以通过的点, 将'x'抽象为一个不可通过的点.

​	那么题意便可以转化为: 一条路径可以看做从任意一个没有到达过的可通过的点出发到任意一个其他的可以通过却没有被到达过的点的一条路径, 要使每个点都被经过, 并且每个点都只能被经过一次, 这不是网络流中的最小路径覆盖吗, 大家可以去看一下[魔术球问题](https://www.luogu.org/problemnew/show/P2765), 魔术球问题就是最小路径覆盖的板子题.

​	对于这种题目, 我们将图中的每一个点拆为两个点<i, a>, <i, b>, 从源点向<i, a>连边, 从<i, b>向汇点连边, 若可从点$i$到达点$j$, 就从点<i, a>向点<j, b>连一条边, 由于每个点都只能出现一次, 所以这些边的容量都是1, 然后跑一遍最大流即可, 这里还要注意一下的是, 军队只能向下走, 所以八个方向变为了四个方向, 分别是(c, r), (c, -r), (r, c), (r, -c).

​	跑完了最大流之后, 答案怎样统计呢, 我们最初每个可通过的点都是一条边, 所以最初有'.'的点数这么多条边, 我们不妨设这个数为$sum$, 那么每次从点$i$向点$j$连边, 其实就意味着将两点之间的路径合并, 那么就会减少一条边, 我们又知道一个定理:**最小点(在这个题中是路径(覆盖 = 点数 - 最大独立集 = 点数 - 最小割 = 点数 - 最大流**, 所以最后的答案便是$sum$ - $dinic()$的值, $dinic()$是一个函数, 他返回的是最大流的流量. 

​	接下来还是看代码吧, 感觉解析应该没什么人会看...

# 具体代码

```cpp
#include <iostream>
#include <cstring>
#include <cstdio>
#include <queue>
#define INF 1e9
using namespace std;

int m, n, R, C, mapp[105][105], u[4], v[4], S, T, head[100005], cnt = 1, cur[100005], d[100005], vis[100005], ans, sum;
struct node
{
	int to, flow, next; 
} edge[1000005];

inline int read()
{
	int x = 0, w = 1;
	char c = getchar();
	while(c < '0' || c > '9') { if (c == '-') w = -1; c = getchar(); }
	while(c >= '0' && c <= '9') { x = x * 10 + c - '0'; c = getchar(); }
	return x * w;
}

inline void add(int u, int v, int w)
{
	edge[++cnt] = { v, w, head[u] }; head[u] = cnt;
	edge[++cnt] = { u, 0, head[v] }; head[v] = cnt; 
}

bool bfs()
{
	memset(d, 0, sizeof(d)); d[S] = 1;
	queue<int> q; q.push(S);
	while(!q.empty())
	{
		int u = q.front(); q.pop();
		for(int i = head[u]; i; i = edge[i].next)
		{
			int v = edge[i].to;
			if(!d[v] && edge[i].flow > 0) { d[v] = d[u] + 1; q.push(v); }
		}
	}
	return d[T]; 
}

int dfs(int u, int a)
{
	if(u == T || !a) return a;
	int flow = 0;
	for(int &i = cur[u]; i; i = edge[i].next)
	{
		int v = edge[i].to;
		if(d[v] == d[u] + 1 && edge[i].flow > 0)
		{
			int f = dfs(v, min(a, edge[i].flow));
			a -= f; flow += f; edge[i].flow -= f; edge[i ^ 1].flow += f; 
		}
		if(!a) break; 
	}
	if(a) d[u] = -1;
	return flow; 
}

int dinic()
{
	int flow = 0;
	while(bfs())
	{
		memcpy(cur, head, sizeof(head));
		flow += dfs(S, INF); 
	}
	return flow; 
}

int main()
{
	m = read(); n = read(); R = read(); C = read();
	for(int i = 1; i <= m; i++)
		for(int j = 1; j <= n; j++)
		{
			char c; cin>>c;
			mapp[i][j] = (c == 'x');
			if(mapp[i][j] == 1) sum++; 
		}
	u[0] = C; u[1] = C; u[2] = R; u[3] = R; v[0] = R; v[1] = -R; v[2] = -C; v[3] = C;  
	S = 2 * m * n + 1; T = S + 1; 
	for(int i = 1; i <= m; i++)
		for(int j = 1; j <= n; j++)
		{
			add(S, (i - 1) * n + j, 1);
			add((i - 1) * n + j + m * n, T, 1);
			if(!mapp[i][j])
				for(int k = 0; k < 4; k++)
				{
					int x = i + u[k], y = j + v[k];
					if(x >= 1 && x <= m && y >= 1 && y <= n && !mapp[x][y]) add((i - 1) * n + j, (x - 1) * n + y + m * n, 1); 
				}
		}
	printf("%d\n", m * n - sum - dinic()); 
	return 0;
}

```

​	~~话说为啥我自己的博客二级标题总是显示不出来呢~~

---

## 作者：Reaepita (赞：11)

这题与 [ TJOI2013攻击装置 ] 有点类似

不过此题中的军队只会**向下走**

注意最后的问题

**至少要多少支军队才能完成统一全国的大业**

所以这道题可以很容易的被我们转换成二分图匹配中的

最小路径覆盖

一开始每个点都是独立的为一条路径，总共有 $n$ 条不相交路径。

我们每次在二分图里找一条匹配边就相当于把两条路径合成了一条路径，

也就相当于路径数减少了1。

所以找到了几条匹配边，路径数就减少了多少。

所以有

最小路径覆盖=原图的结点数-新图的最大匹配数。

对于每个可以放军队的点

我们将军队一步能够走到的点和军队所在的点建边

进行二分图匹配

最后用是 $.$ 的结点的个数-最大匹配数就是最后的答案了

采用匈牙利算法实现

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#define g(i,j) (i-1)*m+j
using namespace std;
const int maxn=1000000+10,maxl=1000000*2+10; 
int vis[maxn],n,m,link[maxn],head[maxn],cnt=0,t=0,r,c;
char a[60][60];
struct data
{
    int v,next;
}e[maxl];
inline void add(int u,int v)
{
    e[++cnt]=(data){v,head[u]};
    head[u]=cnt;
}
template<class T>inline void read(T &x)
{
    x=0;char ch=getchar();
    while(ch>'9'||ch<'0')ch=getchar();
    while(ch<='9'&&ch>='0')x=(x<<3)+(x<<1)+(ch^'0'),ch=getchar(); 
}
int dx[10],dy[10];
bool find_(int u)
{
    for(int i=head[u];i;i=e[i].next)
    {
        int v=e[i].v;
        if(vis[v]!=t)
        {
            vis[v]=t;
            if(link[v]==-1||find_(link[v]))
            {
                link[v]=u;
                return true;
            }
        }
    }
    return false;
}
void get_char(char &x)
{
    x=getchar();
    while(x!='.'&&x!='x')x=getchar();
    return ;
}
int main()
{
    int ans=0;
    memset(link,-1,sizeof(link));
    read(n),read(m),read(r),read(c);
    dx[1]=r,dy[1]=c;
    dx[2]=r,dy[2]=-c;
    dx[3]=c,dy[3]=r;
    dx[4]=c,dy[4]=-r;
    for(int i=1;i<=n;i++)
    for(int j=1;j<=m;j++)
    get_char(a[i][j]);
    for(int i=1;i<=n;i++)
    for(int j=1;j<=m;j++)
    if(a[i][j]=='.'){
        for(int k=1;k<=4;k++)
        {
            int x=i+dx[k],y=j+dy[k];
            if(x<1||x>n||y<1||y>m||a[x][y]=='x')continue;
            add(g(i,j),g(x,y));
        }
    }
    for(int i=1;i<=n;i++)
    for(int j=1;j<=m;j++)
    if(a[i][j]=='.'){
        ++t;
        if(find_(g(i,j)))
        ans++;
    }
    printf("%d\n",t-ans);
}
```

---

## 作者：jun头吉吉 (赞：8)

# P2172 【[国家集训队]部落战争】
[$My\ Blog$](https://chen-jia-liang.gitee.io/blog/2020/07/15/%E9%A2%98%E8%A7%A3-P2172-%E3%80%90-%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F-%E9%83%A8%E8%90%BD%E6%88%98%E4%BA%89%E3%80%91/)
## 题意
有一个$M\times N$的方阵，只有一部分点可以走。部队可以从任意点出发，向下走$R\times C$（或$C\times R$），每个点只能走一次，问最少需要几支部队才能走完所有点
## 题解
首先，我们如果把所有可以走的路径连上边，那么原题就等价于**在一张图上，可以从任意一个点出发，每个点只能访问一次，求至少要几条路径**。

我们来看一看上面的那个问题，很容易的发现，其就是[**最小路径覆盖问题**](https://www.luogu.com.cn/problem/P2764)~~如果你AC了那题可以直接改一改提交了~~，这里来介绍一下其做法：

1. 把每个点拆成两个点$i_x$和$i_y$
2. 源点向$i_x$连接一条流量为$1$的边，$i_y$向汇点连一条流量为$1$的边
3. 对于一条$u\to v$的边，从$u_x$向$v_y$连一条流量为$1$的边

很显然，那就是一个**二分图匹配**，一开始每个点都是单独的，后来对于二分图中匹配的操作，实质上就是把$u$连到了$v$上，路径书就减少了一，于是：
$$\text{最小路径覆盖数}=\text{点数}-\text{最大匹配数}$$
正确性不言而喻~~反正我也不会证~~
```cpp
#pragma optimize(2)
#include<bits/stdc++.h>
using namespace std;
const int maxn=401000,maxe=1000010*2;
struct Graph{
	struct node{
		int v,w,nxt;
	}e[maxe<<1];
	int head[maxn],cur[maxn],tot;
	int dis[maxn];
	int s,t;
	void init(int _s,int _t){s=_s,t=_t;tot=1;memset(head,0,sizeof head);}
	Graph(int _s=0,int _t=0){init(_s,_t);}
	void add(int u,int v,int w){
		//printf("%d %d %d\n",u,v,w);
		e[++tot]=(node){v,w,head[u]},head[u]=tot;
		e[++tot]=(node){u,0,head[v]},head[v]=tot;
	}
	#define v e[i].v
	inline bool bfs(){
		queue<int>q;
		memset(dis,0,sizeof dis);
		memcpy(cur,head,sizeof head);
		dis[s]=1;q.push(s);
		while(q.size()){
			int u=q.front();q.pop();
			for(int i=head[u];i;i=e[i].nxt)
				if(!dis[v]&&e[i].w){
					dis[v]=dis[u]+1,q.push(v);
					if(v==t)return true;
				}
		}
		return  false;
	}
	int dfs(int u,int flow){
		if(u==t)return flow;
		int rest=flow;
		for(int i=cur[u];i&&rest;i=e[i].nxt){
			if(dis[v]==dis[u]+1&&e[i].w){
				int tmp=dfs(v,min(rest,e[i].w));
				rest-=tmp,e[i].w-=tmp,e[i^1].w+=tmp;
			}
			cur[u]=i;
		}
		if(rest==0)dis[u]=-1;
		return flow-rest;
	}
	#undef v
	int dinic(){
		int ans=0;
		while(bfs())
			while(int sth=dfs(s,2e9))
				ans+=sth;
		return ans;
	}
}G;
int m,n,r,c,sum;
char ch[100][100];
#define P1(i,j) ((i)-1)*n+(j)
#define P2(i,j) ((i)-1)*n+(j)+n*m
bool check(int x,int y){
	return x>=1&&x<=m&&y>=1&&y<=n&&ch[x][y]=='.';
}
signed main(){
	cin>>m>>n>>r>>c;
	G.init(0,n*m*2+1);
	for(int i=1;i<=m;i++){
		cin>>ch[i]+1;
		for(int j=1;j<=n;j++)
			if(ch[i][j]=='.'){
				sum++;
				G.add(G.s,P1(i,j),1);
				G.add(P2(i,j),G.t,1);
			}
	}
	for(int i=1;i<=m;i++)
		for(int j=1;j<=n;j++)
			if(ch[i][j]=='.'){
				if(check(i+r,j+c))G.add(P1(i,j),P2(i+r,j+c),1);
				if(check(i+r,j-c))G.add(P1(i,j),P2(i+r,j-c),1);
				if(check(i+c,j+r))G.add(P1(i,j),P2(i+c,j+r),1);
				if(check(i+c,j-r))G.add(P1(i,j),P2(i+c,j-r),1);
				
			}
	cout<<sum-G.dinic();
}
```

---

## 作者：Victorique (赞：3)

这题，我只能说一句CTLL（当然你们并不知道这是啥意思）。。

首先来说一下我一开始AC的方法。

当然是考虑网络流，连边思路应该挺明显的，就是具体处理的时候有点麻烦。按照最小路径覆盖的思想，每个点入点连源，出点连汇，出点汇点之间**不连边**。然后从每个点的入点向能达到的每个点的出点连边，之后跑网络流，用总点数减去最大流即可。

```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<queue>
#define ll long long
#define inf 50000000
#define re register
#define qid(a,b) (a-1)*m+b
#define min(a,b) a<b?a:b
using namespace std;
struct po{
	int nxt,to,w;
};
po edge[30005];
int head[5002],num=-1,n,m,s,t,dep[5002],cur[5002],k,tot;
char map[52][52];
inline int read()
{
    int x=0,c=1;
    char ch=' ';
    while((ch>'9'||ch<'0')&&ch!='-')ch=getchar();
    while(ch=='-')c*=-1,ch=getchar();
    while(ch<='9'&&ch>='0')x=x*10+ch-'0',ch=getchar();
    return x*c;
}
inline void add_edge(int from,int to,int w)
{
	edge[++num].nxt=head[from];
	edge[num].to=to;
	edge[num].w=w;
	head[from]=num;
}
inline void add(int from,int to,int w)
{
	add_edge(from,to,w);
	add_edge(to,from,0);
}
inline bool bfs()
{
	memset(dep,0,sizeof(dep));
	queue<int> q;
	while(!q.empty())
	q.pop();
	q.push(s);
	dep[s]=1;
	while(!q.empty()){
		int u=q.front();
		q.pop();
		for(re int i=head[u];i!=-1;i=edge[i].nxt){
			int v=edge[i].to;
			if(edge[i].w>0&&!dep[v]){
				dep[v]=dep[u]+1;
				if(v==t)
				return 1;
				q.push(v);
			}
		}
	}
	return 0;
}
inline int dfs(int u,int low)
{
	if(u==t)
	return low;
	int diss=0;
	for(re int& i=cur[u];i!=-1;i=edge[i].nxt){
		int v=edge[i].to;
		if(edge[i].w!=0&&dep[v]==dep[u]+1){
			int check=dfs(v,min(low,edge[i].w));
			if(check){
				low-=check;
				diss+=check;
				edge[i].w-=check;
				edge[i^1].w+=check;
				if(low==0) break;
			}
		}
	}
	return diss;
}
inline int dinic(){
	int ans=0;
	while(bfs()){
		for(re int i=s;i<=t;++i)
		cur[i]=head[i];
		while(int d=dfs(s,inf))
		ans+=d;
	}
	return ans;
}
int main()
{
	memset(head,-1,sizeof(head));
	n=read();m=read();int R=read(),C=read();
	for(re int i=1;i<=n;i++)
	 for(re int j=1;j<=m;j++)
	 cin>>map[i][j];
	 int N=n*m;
	s=0;t=n*m*2+1;
	for(re int i=1;i<=n;i++)
	 for(re int j=1;j<=m;j++){
	 	if(map[i][j]=='.'){
	 		add(s,qid(i,j),1),add(qid(i,j)+N,t,1);
	 		int tx=i+R,ty=j+C;
	 		if(tx>=1&&tx<=n&&ty>=1&&ty<=m)
	 		add(qid(i,j),qid(tx,ty)+N,1);
	 		tx=i+C,ty=j-R;
	 		if(tx>=1&&tx<=n&&ty>=1&&ty<=m)
	 		add(qid(i,j),qid(tx,ty)+N,1);
	 		tx=i+C,ty=j+R;
	 		if(tx>=1&&tx<=n&&ty>=1&&ty<=m)
	 		add(qid(i,j),qid(tx,ty)+N,1);
	 		tx=i+R,ty=j-C;
	 		if(tx>=1&&tx<=n&&ty>=1&&ty<=m)
	 		add(qid(i,j),qid(tx,ty)+N,1);
	 		tot++;
	 	}
	}
	cout<<tot-dinic();
	
}
```
然后我交上去了之后，仔细回味了一下这道题，总觉得在哪里见过的样子。。。然后发现了一个令人绝望的事实，我们的国家集训队，出了一道搜索！！！！！！！！！

惊不惊喜，意不意外！

先说一下具体方法，就是不拆点，能影响的暴力连起来，然后枚举所有点深搜遍历，如果枚举时发现当前点并没有被遍历到过，我们就把计数器+1，最后答案就是总点数减去计数器的值。。。

或许你会说，每个点只能经过一次，难道不会互相影响么，我们这个棋子堵了下一个棋子的路怎么办。。然而我们如果从每个棋子都从左向右遍历边的话，我们就一直可以得到最优解，也就是说注意一下连边顺序即可。。。

#没有剪枝，没有高端操作，只是搜索！

就这样我们也可以A掉这个题。

这个题的数据范围比较小，貌似网络流优化好了也可以0ms，但是你的空间。。会比搜索略大。。

---

## 作者：Z1qqurat (赞：2)

眼力见题。有一些障碍物不可以走，以及一种类似于马的走法。

首先看到这种想到图论，可以直接到达是一种很常见的建边方式。于是我们在可以到达的点之间连**单向边**，并且点 $(x,y)$ 可以直接到达 $(xx,yy)$ 不仅需要满足 $(x,y)$ 可以通过马的那种走法到 $(xx,yy)$，而且需要 $x \le xx$，$y \le yy$。所以原先有八个方向，现在只有四个，是这道题的特殊之处，体现为 $dx \ge 0$。

再想想，军队不能到达别人到过的点，求最少的可以覆盖所有点的军队数，很像一个最小路径点覆盖问题。而且它满足是一个二分图，所以直接跑匈牙利求最大匹配，用总的**不是障碍物**的点的数量减去最大匹配数即可。

需要注意的是，为了方便我们将二维的点压成一维的点，具体就是点 $(x,y)$ 对应一维坐标 $(x-1) \times m + y$，原题是 $n$ 行 $m$ 列的矩阵，所以别把 $m$ 写成 $n$ 了！表示方向的函数要写在输入了 $r$ 和 $c$ 之后，要不然 $dx$ 和 $dy$ 就都是 $0$ 了。

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int N = 6005;
int n, m, vis[N], match[N], r, c, nm, cnt, dx[10], dy[10];
char ch[55][55];
vector <int> G[N];

int c4g(int x, int y) {
	return (x - 1) * m + y; 
}

bool hungary(int u, int col) {
	for (int v : G[u]) {
		if(vis[v] == col) continue;
		vis[v] = col;
		if(!match[v] || hungary(match[v], col)) return match[v] = u, 1;
	}
	return 0;
}

int main() {
	scanf("%d%d%d%d", &n, &m, &r, &c); nm = n * m;
	int num = 0;
	if(r == c) {
		num = 2;
		dx[0] = dx[1] = r;
		dy[0] =r, dy[1] = -r;
	}
	else {
		num = 4;
		dx[0] = dx[1] = r, dx[2] = dx[3] = c;
		dy[0] = c, dy[1] = -c, dy[2] = r, dy[3] = -r;
	}
	for (int i = 1; i <= n; ++i) {
		for (int j = 1; j <= m; ++j) {
            cin >> ch[i][j];
            if(ch[i][j] == 'x') cnt++;
        }
	}
	for (int i = 1; i <= n; ++i) {
		for (int j = 1; j <= m; ++j) {
			if(ch[i][j] == 'x') continue;
			int x = c4g(i, j);
			for (int k = 0; k < num; ++k) {
				int nx = i + dx[k], ny = j + dy[k];
				if(nx >= 1 && nx <= n && ny >= 1 && ny <= m && ch[nx][ny] == '.') {
					G[x].emplace_back(c4g(nx, ny));
				}
			}
		}
	}
	int ans = 0;
	for (int i = 1; i <= n; ++i) {
		for (int j = 1; j <= m; ++j) {
			if(ch[i][j] == 'x') continue;
			int x = c4g(i, j);
			ans += hungary(x, x);
		} 
	}
	printf("%d\n", nm - cnt - ans);
	return 0;
}
```

---

## 作者：Lumos壹玖贰壹 (赞：2)

#### 前言
蒟蒻好久没做网络流了，最近借着做图论就刷到了网络流的题，~~用了差不多半天才弄懂这个模型.....~~
### 题意
给你一个$N×M$的的网格图，有一些格子被抠掉了(为'×')。军队只能向下走一个$C×R$的对角线，且两支军队不能经过同一个格子，问至少要多少支这样的军队才能将没被抠掉的各自完全覆盖。$1≤M,N≤50,1≤R,C≤10$
### 分析
+ 网格图不好分析。从每个没被抠掉格子向它一步能走到的（且没被抠掉的）格子连一条有向边，把原网格图变成一个$DAG$
+ 然后就变成了$DAG$上求最小路径覆盖了，就变成了个[板子](https://www.luogu.com.cn/problem/P2764)
### $DAG$最小路径覆盖
搞了半个下午才（以自己的方式）理解，看跟大部分题解不太一样，如果有锅欢迎指正
1. 拆点：把每个点（例如$a$）拆成左右两个点($a_x$和$a_y$)，再建源点和汇点
2. 连边：从源点向每个左部点连流量为１的边，从每个右部点向汇点连流量为１的边。对于$DAG$中存在的边$A->B$，从$A_x$向$B_y$连一条流量为１的边。
3. 答案：所有点的个数$-$网络最大流

>建模解释：网络流的图中从左侧点($A_x$)往右侧点($B_y$)的一条边表示A和B被同一条路径覆盖，并且B是该路径上A的后面一个点。即左部点连出去的边表示对应点的后继是谁，连向右部点的边表示对应点的前驱是谁。因为路径不可相交，所以每个点只有(但可以没有)一个前驱、一个后继，所以边的流量都是１。

> 答案解释：一个流表示两个点在一条路径上。可以假设把每个点都需要一条单独的路径覆盖，那么一个流就减少了一条路径。所以最小路径覆盖$=$总点数$-$最大流

### $Code$
```cpp
#include<bits/stdc++.h>
#define ll long long
#define ri register int
using namespace std;
const int maxn = 5010,INF = 0x7f7f7f7f;
int head[maxn],now[maxn],dep[maxn],n,m,s,t,r,c,tot = 1;
struct edge{
    int to,nex,fl;
}e[30010];
char mape[60][60];
inline int rd(){
    int res = 0,f = 0;
    char ch = getchar();
    for(;!isdigit(ch);ch = getchar()) if(ch == '-') f = 1;
    for(;isdigit(ch);ch = getchar()) res = (res<<3) + (res<<1) + ch - 48;
    return f ? -res : res;
}
inline void add(int u,int v,int w){
    e[++tot] = (edge){v,head[u],w}; head[u] = tot;
    e[++tot] = (edge){u,head[v],0}; head[v] = tot;
}
bool bfs(){
    for(ri i = 1;i <= m*n*2+2;++i) dep[i] = 0,now[i] = head[i];
    queue<int> q;
    dep[s] = 1; q.push(s);
    while(!q.empty()){
        int u = q.front(); q.pop();
        for(ri i = head[u];i;i = e[i].nex){
            int v = e[i].to;
            if(!dep[v] && e[i].fl) dep[v] = dep[u] + 1,q.push(v);
        }
    }
    if(dep[t])
        return 1;
    return 0;
}
int dinic(int u,int maxflow){
    if(u == t || maxflow == 0) return maxflow;  
    int i,rest = maxflow,k;
    for(i = now[u];i;i = e[i].nex){
        int v = e[i].to;
        if(e[i].fl && rest && dep[v] == dep[u] + 1){
            k = dinic(v,min(rest,e[i].fl));
            if(!k){dep[v] = 0;continue;}
            rest -= k;
            e[i].fl -= k;
            e[i ^ 1].fl += k;
        }
        if(!rest) break;
    }
    return maxflow - rest;
}
inline int id(int x,int y) {return (x-1)*n+y;}
int main(){
    m = rd(); n = rd(); r = rd(); c = rd();
    int dir_x[4]={-c,-r,r,c}; 
    int dir_y[4]={r,c,c,r};
    s = n*m*2+1; t = n*m*2+2;
    for(ri i = 1;i <= m;++i)
        scanf("%s",mape[i]+1);
    int cnt = 0;
    for(ri i = 1;i <= m;++i)
      for(ri j = 1;j <= n;++j)
        if(mape[i][j]=='.'){
            cnt++;
            int now = id(i,j),nx,ny;
            add(s,now,1); add(now+n*m,t,1);
            for(ri k = 0;k < 4;++k){
                nx = j + dir_x[k]; ny = i + dir_y[k];
                if(nx < 1||nx > n || ny > m) continue;
                int ne = id(ny,nx);
                add(now,ne+n*m,1);
            }
        }
    ll ans = 0;
    while(bfs()) ans += dinic(s,INF);
    ans = cnt - ans;
    printf("%lld\n",ans);
    return 0;
}
```

---

## 作者：ShineEternal (赞：1)

# 写在前面：
如想获取更佳阅读效果，请点击[这里](https://blog.csdn.net/kkkksc03/article/details/88623999),如有疑问欢迎私信作者！
# 题目链接：https://www.luogu.org/problemnew/show/P2172
# 分析：
不要被【国家集训队】的标签吓到，其实这题不是很难。

本题可以对比P4304 [TJOI2013]攻击装置：互不攻击的网络流问题来想。

这道题唯一添加的条件就是只能从上往下征战，于是我们就从8个方向缩减到了四个放向，哪四个呢？

```cpp
aa[1]=r;bb[1]=-c;
aa[2]=r;bb[2]=c;
aa[3]=c;bb[3]=-r;
aa[4]=c;bb[4]=r;
```
~~变量名较丑~~ 

然后还是要循环每一个点来把它能攻击到的点扔进vector里。

还有这题的数据范围其实也挺小，适合练习二分图初级。

然后就是这种题目也是不用else break；了！

因为不存在单调性

# 代码：

```cpp
#include<cstdio>
#include<iostream>
#include<vector>
using namespace std;
int aa[5];
int bb[5];
struct ben
{
	int first,second;
};
vector<ben>v[55][55];
int vis[55][55];
ben link[55][55];
int t;
int a[55][55];
bool find(ben tmp)
{
    int x=tmp.first;
    int y=tmp.second;
    for(int i=0;i<v[x][y].size();i++)
    {
        int p=v[x][y][i].first;
        int q=v[x][y][i].second;
        if(vis[p][q]!=t)
        {
            vis[p][q]=t;
            int ls=link[p][q].first;
            int ls2=link[p][q].second;
            if((ls==0&&ls2==0)||find(link[p][q]))
            {
                link[p][q].first=x;
                link[p][q].second=y;
                return 1; 
            }
        }
    }
    return 0;
}
int main()
{
	int n,m,r,c;
	int ans=0;
	scanf("%d%d%d%d",&m,&n,&r,&c);
	for(int i=1;i<=m;i++)
	{
		for(int j=1;j<=n;j++)
		{
			char s;
			cin>>s;
			if(s=='.')
			{
				a[i][j]=0;
				ans++;
			}
			else
			a[i][j]=1;
		}
	}
	aa[1]=r;bb[1]=-c;
	aa[2]=r;bb[2]=c;
	aa[3]=c;bb[3]=-r;
	aa[4]=c;bb[4]=r;
	for(int i=1;i<=m;i++)
	{
		for(int j=1;j<=n;j++)
		{
			for(int k=1;k<=4;k++)
			{
				int x=i+aa[k];
				int y=j+bb[k];
				if(x>0&&x<=m&&y>0&&y<=n&&a[x][y]==0)
				{
					ben tmp;
					tmp.first=x;
					tmp.second=y;
					v[i][j].push_back(tmp);
				}
			}
		}
		
	}
	int cnt=0;
    for(int i=1;i<=m;i++)
    {
        for(int j=1;j<=n;j++)
        {
            if(a[i][j]==1)
            continue;
            t++;
            ben tmp;
            tmp.first=i;
            tmp.second=j;
            if(find(tmp))
            {
                cnt++;
            }
            //else
            //break;
        }
    }
    printf("%d\n",t-cnt);
    return 0;
}
```



---

## 作者：niiick (赞：1)

由于蒟蒻实在太蒟，所以看到题目想到的竟然是有上下界网络流=_=

每个城镇拆成入点和出点，由其**入点向出点连边，下界1，上界1**，表示必须且只能经过一次

对于u能到达的城镇v，**u的出点向v的入点连边，下界0，上界inf**

虚拟源点s向每个入点连边，下界0，上界inf

每个出点向虚拟汇点t连边，下界0，上界inf

按照有上下界网络流套路建图后求s到t的**最小流**即可

```cpp
//niiick
#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>
#include<queue>
using namespace std;
typedef long long lt;

int read()
{
    int f=1,x=0;
    char ss=getchar();
    while(ss<'0'||ss>'9'){if(ss=='-')f=-1;ss=getchar();}
    while(ss>='0'&&ss<='9'){x=x*10+ss-'0';ss=getchar();}
    return f*x;
}

const int inf=1e9;
const int maxn=100010;
int n,m,r,c;
struct node{int v,f,nxt;}E[maxn<<1];
int head[maxn],tot=1;
int lev[maxn],deg[maxn];
int rem[55][55];
char ss[110];
int nX[]={1,1},nY[]={-1,1};

void add(int u,int v,int f)
{
    E[++tot].nxt=head[u];
    E[tot].v=v; E[tot].f=f;
    head[u]=tot;
    
    E[++tot].nxt=head[v];
    E[tot].v=u; E[tot].f=0;
    head[v]=tot;
}

int bfs(int s,int t)
{
    queue<int> q; q.push(s);
    memset(lev,-1,sizeof(lev)); lev[s]=0;
    while(!q.empty())
    {
        int u=q.front(); q.pop();
        for(int i=head[u];i;i=E[i].nxt)
        {
            int v=E[i].v;
            if(lev[v]==-1&&E[i].f)
            {
                lev[v]=lev[u]+1;
                if(v==t) return 1;
                q.push(v);
            }
        }
    }
    return 0;
}

int dfs(int u,int cap,int t)
{
    if(u==t) return cap;
    int flow=cap;
    for(int i=head[u];i;i=E[i].nxt)
    {
        int v=E[i].v;
        if(lev[v]==lev[u]+1&&E[i].f&&flow)
        {
            int f=dfs(v,min(E[i].f,flow),t);
            E[i].f-=f; E[i^1].f+=f;
            flow-=f;
        }
    }
    return cap-flow;
}

int dicnic(int s,int t)
{
    int maxf=0;
    while(bfs(s,t)) maxf+=dfs(s,inf,t);
    return maxf;
}

int main()
{
    n=read();m=read();
    r=read();c=read();
    
    for(int i=1;i<=n;++i)
    {
        scanf("%s",&ss);
        for(int j=0;j<m;++j)
        if(ss[j]=='x') rem[i][j+1]=1;
    }
    
    int s=n*m*2+1,t=s+1;
    for(int i=1;i<=n;++i)
    for(int j=1;j<=m;++j)
    {
        if(rem[i][j]) continue;
        int u=(i-1)*m+j;
        add(s,u,inf); add(u+n*m,t,inf);//l=0,r=inf
        
        add(u,u+n*m,0);//l=1,r=1
        deg[u]--; deg[u+n*m]++;
    }
    
    for(int i=1;i<=n;++i)
    for(int j=1;j<=m;++j)
    {
        if(rem[i][j]) continue;
        int u=(i-1)*m+j;
        for(int k=0;k<2;++k)
        {
            int x=i+nX[k]*r,y=j+nY[k]*c,v=(x-1)*m+y;
            if(x>=1&&x<=n&&y>=1&&y<=m) 
            if(!rem[x][y]) add(u+n*m,v,inf);
        }
        if(r!=c)
        for(int k=0;k<2;++k)
        {
            int x=i+nX[k]*c,y=j+nY[k]*r,v=(x-1)*m+y;
            if(x>=1&&x<=n&&y>=1&&y<=m) 
            if(!rem[x][y]) add(u+n*m,v,inf);
        }
    }
    
    int ss=t+1,tt=ss+1;
    for(int i=1;i<=t;++i)
    {
        if(deg[i]>0) add(ss,i,deg[i]);
        else if(deg[i]<0) add(i,tt,-deg[i]);
    }
    add(t,s,inf);
    
    dicnic(ss,tt);
    int ans=E[tot].f;
    head[t]=E[head[t]].nxt;
    head[s]=E[head[s]].nxt;
    printf("%d",ans-dicnic(t,s));
    return 0;
}
```

---

## 作者：CQ_Bab (赞：1)

# 前言
这是发的第二篇网络流题解了。
# 思路
我们一读完题目就能想到的就是要拆点，我们就可以将一个下标为 $x$ 和 $y$ 的点拆成 $x\times m+y$ 以及 $(x+n)\times m+y$ 就行，然后我们再来进一步思考就能够发现这不就是[最小路径覆盖](https://www.luogu.com.cn/problem/P2764)吗？那么我们就能知道答案等于总成整数减去最大流。然后我们就可以来思考如何建图了，其实和模板差不多还是拆了后先将不加 $n\times m$ 的点连上原点一条流量为 $1$，再将加 $n\times m$ 的连上汇点一条流量为 $1$ 的点，最后看一下它能到达的四个点是否符合要求，若符合则将它与能到达的点加上 $n\times m$ 连上一条边，再跑最大流即可。
# 代码
```
#include <bits/stdc++.h>
using namespace std ;
#define int long long
#define rep(i,x,y) for(int i=x;i<=y;i++)
#define rep1(ix,u,y) for(int ix=u;ix>=y;ix--)
#define fire signed
const int M=1e6+10;
int tot=1,head[M],s,t;
int d[M],n,m,r,c;
struct node {
	int x,y,z;
} edg[M];
inline void add(int x,int y,int z) {//模板不讲 
	edg[++tot].x=y;
	edg[tot].y=head[x];
	edg[tot].z=z;
	head[x]=tot;
	edg[++tot].x=x;
	edg[tot].y=head[y];
	edg[tot].z=0;
	head[y]=tot;
}
inline bool bfs() {//模板不讲 
	memset(d,0,sizeof d);
	queue<int>q;
	q.push(s);
	d[s]=1;
	while(!q.empty()) {
		int x=q.front();
		q.pop();
		for(int i=head[x]; i; i=edg[i].y) {
			int j=edg[i].x;
			if(edg[i].z&&!d[j]) {
				q.push(j);
				d[j]=d[x]+1;
				if(j==t) return 1;
			}
		}
	}
	return false;
}
inline int Dinic(int x,int res) { //模板不讲 
	if(x==t) return res;
	int plus=res,k=0;
	for(int i=head[x]; i&&plus; i=edg[i].y) {
		if(edg[i].z&&d[edg[i].x]==d[x]+1) {
			int j=edg[i].x;
			k=Dinic(j,min(plus,edg[i].z));
			if(!k) d[j]=0;
			edg[i].z-=k;
			edg[i^1].z+=k;
			plus-=k;
		}
	}
	return res-plus;
}
char a[1010][1010];
int id(int x,int y) { //运用哈希求一个特殊值 
	return x*m+y;
}
int dx[5],dy[5];
fire main() {
	cin>>n>>m>>r>>c;
	s=0;
	dx[1]=r,dx[2]=r,dx[3]=dx[4]=c;
	dy[1]=c,dy[2]=-c;
	dy[3]=r;
	dy[4]=-r;
	int cnt=0;
	vector<pair<int,int> >v;
	t=2*(n+1)*m+1;
	rep(i,1,n) {
		rep(j,1,m) {
			cin>>a[i][j];
			if(a[i][j]=='.') {
				v.push_back(make_pair(i,j)); //记录 
				cnt++; //统计城镇数 
			}
		}
	}
	rep(i,0,cnt-1) {
		int x=v[i].first,y=v[i].second;
		add(s,id(x,y),1);//连原点 
		add(n*m+id(x,y),t,1); //连汇点 
		rep(i,1,4) { //看周围四个点 
			int tx=x+dx[i],ty=y+dy[i];
			if(tx<1||ty<1||tx>n||ty>m||a[tx][ty]!='.') continue; //不符合要求 
			add(id(x,y),n*m+id(tx,ty),1); //否则就连上一条 
		}
	}
	while(bfs()) cnt-=Dinic(s,INT_MAX); //减去最大流 
	cout<<cnt<<endl;
	return false;
}
```

---

## 作者：Genius_Star (赞：0)

### 思路：

由题可知，由 $(i,j)$ 可以走到 $(i+r,j+c),(i+r,j-c),(i+c,j+r),(i+c,j-r)$。

那么考虑建图，现在相当于要在一个有向图中，找出最少的路径，使得这些路径经过了所有的点，即**最小路径覆盖**问题。

考虑将 $i$ 点拆为 $(i,i + n \times m)$，那么若要连边，则由 $i$ 向 $j + n \times m$ 连边，这样就得到了二分图。

那么**最小路径覆盖**就等于**原图的结点数**减去**新图的最大匹配数**。

跑匈牙利即可。

### 证明：

首先有将点 $i$ 拆为 $(i,i+ n \times m)$，若有 $x \to i + n \times m,i \to y + n \times m$，相当于 $i$ 前面连着 $x$ 后面连着 $y$。

在开始时，一个匹配都没有，即假设每个点就是一条路径，总共有 $n$ 条。

若现在 $(x,y + n \times m)$ 匹配上了，那么相当于将 $x$ 处的路径与 $y$ 处的路径合并。

那么我们每次在二分图里找一条匹配边就相当于把两条路径合成了一条路径，也就相当于路径数减少了 $1$。

所以找到了几条匹配边，路径数就减少了多少。

所以有**最小路径覆盖**等于**原图的结点数**减去**新图的最大匹配数**。

### 完整代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef double db;
const int N=2505,M=55;
inline int read(){
    int x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')
          f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=(x<<1)+(x<<3)+(c^48);
        c=getchar();
    }
    return x*f;
}
inline void write(int x){
	if(x<0){
		putchar('-');
		x=-x;
	}
	if(x>9)
	  write(x/10);
	putchar(x%10+'0');
}
inline char get_char(){
	char c;
    c=getchar();
    while(c!='.'&&c!='x')
	  c=getchar();
    return c;
}
int n,m,r,c,cnt,id,ans;
int a[N],f[N];
int A[M][M];
bool F[M][M];
vector<int> E[N];
inline bool check(int x,int y){
//	cerr<<x<<' '<<y<<'\n';
	if(x<1||x>n||y<1||y>m)
	  return 0;
	if(!F[x][y])
	  return 0;
	return 1;
}
inline void add(int u,int v){
//	cerr<<u<<' '<<v<<'\n';
	E[u].push_back(v);
}
inline bool dfs(int u){
	for(auto v:E[u]){
		if(f[v]==id)
		  continue;
		f[v]=id;
		if(!a[v]||dfs(a[v])){
			a[v]=u;
			return 1;
		} 
	}
	return 0;
}
inline void Match(){
	for(int i=1;i<=cnt;i++){
		id=i;
		if(dfs(i))
		  ans--;
	}
}
int main(){
	n=read(),m=read(),r=read(),c=read();
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			A[i][j]=++cnt;
			if(get_char()=='.'){
				F[i][j]=1;
				ans++;
			}
		}
		getchar();
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if(!F[i][j])
			  continue;
			if(check(i+r,j+c))
			  add(A[i][j],A[i+r][j+c]);
			if(check(i+r,j-c))
			  add(A[i][j],A[i+r][j-c]);
			if(check(i+c,j+r))
			  add(A[i][j],A[i+c][j+r]);
			if(check(i+c,j-r))
			  add(A[i][j],A[i+c][j-r]);
		}
	}
	Match();
	write(ans);
	return 0;
}
```

---

## 作者：BIG_CUTE_BUG (赞：0)

[题传](https://www.luogu.com.cn/problem/P2172)

## 思路

可以从任意点开始走，所以从源点向每个点连边 $+\infty$。

每个点当且仅当走一次，所以拆点，下界为 $1$，上界为 $1$。

每个点都可以停，所以每个点都向汇点连边 $+\infty$。

每个点再向自己可以走到的点连边，容量大于等于 $1$ 就行。

要求流量最小，实际就是很板的上下界最小流。

## Code

```cpp
//拆点过后跑下界最小流 
#include<bits/stdc++.h>
using namespace std;
const int N= 1e4+ 5, M= 1e5+ 5, inf= 1e8;
int dx[5], dy[5];
int n, m, r, c, s, t, S, T, f[M], e[M], nxt[M], cnt, head[N], cur[N], d[N], q[N];
bool arv[52][52];
void add(int u, int v, int w)
{
	e[cnt]= v, f[cnt]= w, nxt[cnt]= head[u], head[u]= cnt++;
	e[cnt]= u, f[cnt]= 0, nxt[cnt]= head[v], head[v]= cnt++;
}
bool bfs()
{
	int hh= 1, tt= 1;
	memset(d, -1, sizeof d);
	q[1]= S, cur[S]= head[S], d[S]= 0;
	while(hh<= tt)
	{
		int u= q[hh++];
		for(int i= head[u]; ~i; i= nxt[i])
		{
			if(d[e[i]]!= -1 || !f[i]) continue;
			d[e[i]]= d[u]+ 1, cur[e[i]]= head[e[i]];
			if(e[i]== T) return 1;
			q[++tt]= e[i];
		}
	}
	return 0;
}	
int find(int u, int lim)
{
	if(u== T) return lim;
	int flow= 0;
	for(int i= cur[u]; ~i && flow< lim; i= nxt[i])
	{
		cur[u]= i;
		if(d[e[i]]!= d[u]+ 1 || !f[i]) continue;
		int p= find(e[i], min(f[i], lim- flow));
		if(!t) d[e[i]]= -1;
		flow+= p, f[i]-= p, f[i^ 1]+= p;
	}
	return flow;
}
signed main()
{
	memset(head, -1, sizeof head);
	ios:: sync_with_stdio(0); cin.tie(0); cout.tie(0);
	cin>> n>> m>> r>> c;
	dx[0]= r, dy[0]= c; dx[1]= r, dy[1]= -c; dx[2]= c, dy[2]= r; dx[3]= c, dy[3]= -r;
	char ch; t= n* m* 2+ 5; T= t+ 1; S= T+ 1;
	for(int i= 1; i<= n; i++) for(int j= 1; j<= m; j++) cin>> ch, arv[i][j]= (ch== '.');
	for(int i= 1; i<= n; i++) for(int j= 1; j<= m; j++) if(arv[i][j])
	{
		add(s, ((i- 1)* m+ j)<< 1, inf); add(((i- 1)* m+ j)<< 1| 1, t, inf);
		add(S, ((i- 1)* m+ j)<< 1| 1, 1); add(((i- 1)* m+ j)<< 1, T, 1);
		for(int k= 0; k< 4; k++)
		{
			int x= i+ dx[k], y= j+ dy[k];
			if(!arv[x][y] || x< 1 || y< 1 || x> n || y> m) continue;
			add(((i- 1)* m+ j)<< 1| 1, ((x- 1)* m+ y)<< 1, inf);
		}
	}
	add(t, s, inf);
	int res= 0, flow;
	while(bfs()) while(flow= find(S, inf)) res+= flow;
	res= f[cnt- 1]; f[cnt- 1]= f[cnt- 2]= 0; S= t; T= s;
	while(bfs()) while(flow= find(S, inf)) res-= flow;
	cout<< res;
	return 0;
}
```

---

## 作者：sangshang (赞：0)

## 题意
有 $m\times n$ 的网格，对于网格上的一点 $(i,j)$，如果是城市，则需要占领，即必须通过，且只能通过一次；否则，不能通过，无需占领。最少需几个军队？

对于每个军队，其行动范围又两个数据控制 $R,C$，若现在为 $(i,j)$，下一步能到 $\{(i+R,j+C),(i+R)(j-C),(i+C,j+R),(i+C,j-R)\}$ 处。

## 分析

“_并只能从上往向下征战，不能回头。_”这句话明显在提醒我们，这是一个有向无环图。“_假设他们每支军队都能顺利占领这支军队经过的所有城镇，请你帮 lanzerb 算算至少要多少支军队才能完成统一全国的大业。_”题意已经很裸了，是要我们求最少覆盖路径。

具体的，遍历整个网格，枚举每个网格可到达得点，如果两点都是城市，就建一条边，表示可行的一条路径，求出最少覆盖路径。

## 求解

假设现在每个点都布置一个军队，每个军队都只经过一个点。现在要将一些能合并为一条路径的点合并。对于每个点，只能有一个出度，或是路径的终点；只能有一个入度，或是路径的起点。

将一个点 $u\in V$ 拆成两个点 $u_1,u_2$。分别表示进入 $u$；从 $u$ 离开。对于原图中的边 $(i,j)\in E$，连接 $i_1,j_2$，表示能够从 $i$ 走出，走向 $j$，并将两点并为一条路线。因为对于每个点，只能有一个出度，或是路径的终点；只能有一个入度，或是路径的起点。所以路径的合并过程，实际上是二分图最大匹配。

这里建议使用网络流 Dinic 求解。从源点 $s$ 向所有 $i_1,i\in V$ 连一条边，容量为一，表示只能匹配一次；从 $i_2,i\in V$ 向汇点 $t$ 连一条容量为一的边，表示只能被匹配一次。对于一条连边 $(i,j)\in E$，从 $i_1$ 到 $j_2$ 连一条容量为一的边，表示可以匹配。

最后求出的最大匹配就是能将几个点合并为一条路线，即能省出几个军队。用城市数减匹配数就是答案。

## C++ Code
```cpp
#include <bits/stdc++.h>
using namespace std;

class Dinic {
	public:
		typedef int TYPE;
		static const int maxn = (55 * 55) << 1, maxm = 0x7f7f7f7f, inf = 0x7f7f7f7f;
		class edge {
			public:
				int to, rev;
				TYPE flow;
				edge(int to, TYPE flow, int rev): to(to), flow(flow), rev(rev) {}
				edge() {}
		};
		std::vector<edge>vec[maxn];
		int h[maxn], Cur[maxn], n, m, s, t;
		bool vis[maxn], Map[55][55];
		Dinic(int n, int m, int s, int t): n(n), m(m), s(s), t(t),
			h({0}), Cur({0}), vis({false}) {}
		Dinic() {}
		inline void Add_Edge(int from, int to, TYPE flow) {
			vec[from].push_back(edge(to, flow, vec[to].size()));
			vec[to].push_back(edge(from, 0, vec[from].size() - 1));
		}
		inline bool bfs() {
			int q[maxn], front = 0, back = -1;
			std::memset(q, 0, sizeof(q));
			std::memset(h, inf, sizeof(h));
			h[t] = 0;
			std::memset(Cur, 0, sizeof(Cur));
			for (q[++back] = t; front <= back;) {
				int u = q[front++];
				for (edge &e : vec[u]) {
					int v = (e.to);
					if (vec[v][e.rev].flow && h[v] == inf) {
						h[v] = h[u] + 1;
						q[++back] = v;
					}
				}
			}
			return h[s] != inf;
		}
		inline TYPE dfs(int u, TYPE flow) {
			if (u == t || !flow) {
				return flow;
			}
			TYPE res = 0;
			vis[u] = true;
			int sz = vec[u].size();
			for (int i = Cur[u]; i < sz && flow; ++i) {
				edge &e = vec[u][i];
				int v = (e.to);
				if (e.flow && h[v] + 1 == h[u] && !vis[v]) {
					TYPE Preflow = dfs(v, std::min(flow, e.flow));
					e.flow -= Preflow, vec[v][e.rev].flow += Preflow;
					res += Preflow, flow -= Preflow;
				}
			}
			vis[u] = false;
			return res;
		}
		inline TYPE GetMaxFlow() {
			TYPE MaxFlow = 0;
			while (bfs()) {
				TYPE GetFlow;
				while ((GetFlow = dfs(s, inf))) {
					MaxFlow += GetFlow;
				}
			}
			return MaxFlow;
		}
		inline void InPut(int &NodeNum, int &Cnt) {
#define id(a,b) ((a-1)*M+b)
			Cnt = 0;
			int N, M, R, C;
			scanf("%d%d%d%d", &N, &M, &R, &C);
			this[0] = Dinic(((N * M) << 1) + 2, M, 0, ((N * M) << 1) + 1);
			int nex[4][2] = {{R, C}, {R, -C}, {C, R}, {C, -R}};
			NodeNum = N * M;
			for (int i = 1; i <= N; ++i) {
				for (int j = 1; j <= M; ++j) {
					char tmp;
					std::cin >> tmp;
					if (tmp == 'x') {
						Map[i][j] = false;
					} else {
						Map[i][j] = true;
						++Cnt;
					}
				}
			}
			for (int i = 1; i <= N; ++i) {
				for (int j = 1; j <= M; ++j) {
					if (Map[i][j]) {
						for (int k = 0; k < 4; ++k) {
							int X = i + nex[k][0], Y = j + nex[k][1];
							if (X >= 1 && X <= N && Y >= 1 && Y <= M) {
								if (Map[X][Y]) {
									Add_Edge(id(i, j), id(X, Y) + NodeNum, 1);
								}
							}
						}
					}
				}
			}
			for (int i = 1; i <= NodeNum; ++i) {
				Add_Edge(s, i, 1);
				Add_Edge(i + NodeNum, t, 1);
			}
		}
		inline void Solve() {
			int NodeNum, Cnt;
			InPut(NodeNum, Cnt);
			int MaxFlow = GetMaxFlow();
			printf("%d\n", Cnt - MaxFlow);
		}
};
Dinic Main;

int main() {
	Main.Solve();
	return 0;
}
```


---

## 作者：_qingshu_ (赞：0)

挺好的一道偏板子的最小路径覆盖，但是因为 fastio 调了一个上午 qwq。

# 题意：

给定一个 $N \times M$ 的由 ```.``` 与 ```x``` 构成的图，每一次可以在本图寻找任意 ```.``` 点作为起点，每一次可以向下走 $R \times C$ 格到达一个 ```.``` 点，且已经走过的格子不能再次行走，询问最少数量路径覆盖全部 ```.``` 点。

# 建模：

本题解虽然演示代码是 HLPP 做法，但于板子并未做改动，依旧仅需关注建模特点，这个是通用的。所以要用 Dinic 的可以放心食用。

首先考虑记录所有 ```.``` 点的个数为 $sum$。最后答案输出的时候会使用。

对于一个最小路径覆盖问题，我们考虑把一个点拆解成两个点称作**入点**与**出点**，但是与寻常拆点不同的是，两点之间并无连边。

考虑建立超级源 $s$ 与超级汇 $t$。因为本题所有 ```.``` 点均可作为起始点，所以给每一个入点与 $s$ 都连上一条流量为 1 的边。同理，给每一个出点与 $t$ 都连上一条流量为 1 的边。

对于每一个点往下可以走到的四个方向遍历一遍，如果可以到达就把该点与目标点的出点建立一条流量为 1 的边。

# 结论证明，思路：

这样，我们每一次寻找到的增广路（推进到的下一个点）的顺序应该是一定的。

```
源点、入点、出点、汇点。
```

这种顺序本质上可以理解为合并一条路径，为什么呢？首先考虑重复使用的问题，因为每一次仅仅会选择一个入点与一个出点，所以这个条边的流量一定会被清零，不会出现重复使用的情况（包括反悔，因为反悔不影响使用情况，依然成立）。

既然合并了两个点作为一条路径，只要其他的点与这两个点联系上，我们就可以看做再合并进来，所以把最大流表示出来其实是一条一条的路径。

因为最大流会把整张图的**最大**流量表示出来，而无法被计算进答案的可以看做是每一条路径的起点（比如说两个点之间建立路径，对最大流的贡献仅仅有 1），而我们询问的最小路径覆盖问题的答案就是起点的数量。也就是开始提到的 $sum$ 减去网络最大流。

# code：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,r,c,s,t,sum;
char mp[100][100];
struct edge{
	int to,nxt;
	long long val;
}e[5200010];
int head[5200010],tot=1,h[5200010];
struct cmp{
	inline bool operator ()(int x,int y)const{
		return h[x]<h[y];
	}
};
priority_queue<int,vector<int>,cmp>qq;
queue<int>q;
long long over[5200010],vist[5200010],gap[5200010];
void add(int u,int v,long long w){
	e[++tot].to=v;
	e[tot].nxt=head[u];
	e[tot].val=w;
	head[u]=tot;
	
	e[++tot].to=u;
	e[tot].nxt=head[v];
	e[tot].val=0;
	head[v]=tot;
}
bool bfs(){
	for(int i=1;i<=t;i++){
		h[i]=1e9;
	}
	h[t]=0;
	q.push(t);
	while(!q.empty()){
		int x=q.front();
		q.pop();
		for(int i=head[x];i;i=e[i].nxt){
			int v=e[i].to;
			if(e[i^1].val&&h[v]>h[x]+1){
				h[v]=h[x]+1;
				q.push(v); 
			}
		}
	}
	return (h[s]!=0);
}
void push(int x){
	for(int i=head[x];i;i=e[i].nxt){
		int v=e[i].to;
		if(e[i].val&&h[x]==h[v]+1){
			int k=min(over[x],e[i].val);
			e[i].val-=k;
			e[i^1].val+=k;
			over[x]-=k;
			over[v]+=k;
			if(v!=s&&v!=t&&!vist[v]){
				vist[v]=1;
				qq.push(v);
			}
			if(!over[x]){
				return;
			}
		}
	}
}
void relable(int x){
	h[x]=1e9;
	for(int i=head[x];i;i=e[i].nxt){
		int v=e[i].to;
		if(e[i].val&&h[x]>h[v]+1){
			h[x]=h[v]+1;
		}
	}
}
long long hlpp(){
	if(!bfs()){
		return 0;
	}
	h[s]=2*n*m+2;
	for(int i=1;i<=2*n*m+2;i++){
		if(h[i]!=1e9){
			gap[h[i]]++;
		}
	}
	for(int i=head[s];i;i=e[i].nxt){
		int v=e[i].to;
		if(e[i].val&&h[v]!=1e9){
			e[i^1].val=e[i].val;
			over[v]=e[i].val;
			e[i].val=0;
			if(v!=s&&v!=t&&!vist[v]){
				vist[v]=1;
				qq.push(v);
			}
		}
	}
	while(!qq.empty()){
		int x=qq.top();
		qq.pop();
		vist[x]=0;
		push(x);
		if(over[x]){
			gap[h[x]]--;
			if(!gap[h[x]]){
				for(int i=1;i<=2*n*m+2;i++){
					if(i!=t&&i!=s&&h[i]<=2*n*m+2&&h[i]>h[x]){
						h[i]=2*n*m+2+1;
					}
				}
			}
			relable(x);
			gap[h[x]]++;
			vist[x]=1;
			qq.push(x);
		}
	}
	return over[t];
}
int main(){
	cin>>n>>m>>r>>c;
	s=2*n*m+1;
	t=2*n*m+2;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cin>>mp[i][j];
			sum+=(mp[i][j]=='.');
		}
	}
	int cx[]={c, c, r,r};
	int cy[]={r,-r,-c,c};
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if(mp[i][j]=='.'){
				add(s,(i-1)*m+j,1);
				add((i-1)*m+j+n*m,t,1);
				for(int k=0;k<4;k++){
					int nowx=i+cx[k],nowy=j+cy[k];
					if(nowx>=1&&nowx<=n&&nowy>=1&&nowy<=m&&mp[nowx][nowy]=='.'){
						add((i-1)*m+j,(nowx-1)*m+nowy+n*m,1); 
					}
				}
			}
		}
	}
	cout<<sum-hlpp();
}
```

完结撒花✿✿ヽ(°▽°)ノ✿。

update：

23.12.18：
修改了关于 $\LaTeX$ 公式与汉字之间缺少空格。

---

## 作者：Gaode_Sean (赞：0)

由于每支军队只能自上而下地跳，所以按矩阵中的路径建出的图是一个 DAG。

此时我们可以很快想到最小点路径覆盖问题。考虑将所有城镇转化成点，再对每个点都拆出一个虚点，构建一个二分图，最后跑一遍二分图最大匹配即可（实在太典了，故不再赘述）。

答案为城镇的数量减去二分图的最大匹配数。

## AC Code
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=55,M=2e4+5;
int s,t,n,m,r,c,tot=1,ans,maxflow;
int ver[2*M],edge[2*M],head[M],nxt[2*M],now[M],d[M];
char ch[N][N];
queue<int> q;
int pos(int x,int y){return (x-1)*m+y;}
void add(int x,int y,int z)
{
	ver[++tot]=y,edge[tot]=z,nxt[tot]=head[x],head[x]=tot;
	ver[++tot]=x,edge[tot]=0,nxt[tot]=head[y],head[y]=tot;
}
bool bfs()
{
	for(int i=1;i<=2*n*m+2;i++) d[i]=0;
	while(!q.empty()) q.pop();
	q.push(s); d[s]=1,now[s]=head[s];
	while(!q.empty())
	{
		int x=q.front(); q.pop();
		for(int i=head[x];i;i=nxt[i])
		{
			if(edge[i]&&!d[ver[i]])
			{
				q.push(ver[i]);
				now[ver[i]]=head[ver[i]];
				d[ver[i]]=d[x]+1;
				if(ver[i]==t) return 1;
			}
		}
	}
	return 0;
}
int dinic(int x,int flow)
{
	if(x==t) return flow;
	int rest=flow,k,i;
	for(i=now[x];i&&rest;i=nxt[i])
	{
		if(edge[i]&&d[ver[i]]==d[x]+1)
		{
			k=dinic(ver[i],min(rest,edge[i]));
			if(!k) d[ver[i]]=0;
			edge[i]-=k,edge[i^1]+=k,rest-=k;
		}
	}
	now[x]=i;
	return flow-rest;
}
int main()
{
    scanf("%d%d%d%d",&n,&m,&r,&c);
    s=2*n*m+1,t=s+1;
    int dx[4]={r,r,c,c},dy[4]={-c,c,-r,r};
    for(int i=1;i<=n;i++) scanf("%s",ch[i]+1);
    for(int i=1;i<=n;i++)
    {
    	for(int j=1;j<=m;j++)
    	{
    		if(ch[i][j]=='.')
    		{
    			ans++,add(s,pos(i,j),1),add(pos(i,j)+n*m,t,1);
    			for(int k=0,x,y;k<4;k++)
    			{
    				x=i+dx[k],y=j+dy[k];
    				if(x>=1&&x<=n&&y>=1&&y<=m&&ch[x][y]=='.') add(pos(i,j),pos(x,y)+n*m,1);
				}
			}
		}
	}
	int flow=0;
	while(bfs())
	{
		while(flow=dinic(s,1e9)) maxflow+=flow;
	}
	printf("%d",ans-maxflow);
	return 0;	
}
```

---

## 作者：gyyyyx (赞：0)

[题面](https://www.luogu.com.cn/problem/P2172)

很套路的题。

一眼丁真，看到网格优先考虑建图。

将每个点向可以走到的点连边，会构成一个有向图。显然，答案就是这个有向图的**最小不相交路径覆盖**。

思路是将每个点拆成两个，一个存入边，一个存出边，那显然这样构造出来的图是一个二分图。

可以证明：**原图最小不相交路径覆盖=原图点数-新图最大匹配**。

二分图的最大匹配用 $\text{Dinic}$ 求出来就行了。

所以答案就是 $sum-\text{Dinic}()$，注意用的是 $sum$ 不是 $nm$，因为要减去不能走的点。

代码：

```cpp
#include<bits/stdc++.h>
#define inf 0x3f3f3f3f
#define N 5005
using namespace std;
#define id(x,y) (((x)-1)*m+(y))
int n,m,r,c,s,t,sum;
int dx[4],dy[4];
bool a[55][55];
struct Edge{
	int nxt,to,w;
	Edge(int a=0,int b=0,int c=0)
	:nxt(a),to(b),w(c){}
};
struct Edge e[N*6];
int head[N],cnt(1);
inline void AddEdge(int x,int y,int z){
	e[++cnt]=Edge(head[x],y,z);head[x]=cnt;
	e[++cnt]=Edge(head[y],x,0);head[y]=cnt;
}
int dis[N],now[N];
inline bool bfs(){
	memset(dis,0,sizeof(dis));dis[s]=1;
	queue <int> q;q.push(s);now[s]=head[s];
	while(!q.empty()){
		int u(q.front());q.pop();
		for(int i(head[u]);i;i=e[i].nxt){
			int v(e[i].to);
			if(e[i].w&&!dis[v]){
				dis[v]=dis[u]+1;
				now[v]=head[v];
				q.push(v);
			}
		}
	}
	return dis[t];
}
int dfs(int u,int limit){
	if(u==t) return limit;
	int f(0);
	for(int i(now[u]);i&&limit;now[u]=i=e[i].nxt){
		int v(e[i].to);
		if(e[i].w&&dis[v]==dis[u]+1){
			int x(dfs(v,min(limit,e[i].w)));
			e[i].w-=x;e[i^1].w+=x;limit-=x;f+=x;
		}
	}
	if(!f) dis[u]=0;
	return f;
}
inline int Dinic(){
	int ans(0),res;
	while(bfs())
		while(res=dfs(s,inf))
			ans+=res;
	return ans;
}
int main(){
	scanf("%d%d%d%d",&n,&m,&r,&c);
	s=0;t=(n*m<<1)+1;
	for(int i(1);i<=n;++i)
		for(int j(1);j<=m;++j){
			char ch;scanf(" %c",&ch);
			a[i][j]=(ch=='x');
			sum+=!a[i][j];
		}
	dx[0]=r;dy[0]=c;
	dx[1]=r;dy[1]=-c;
	dx[2]=c;dy[2]=r;
	dx[3]=c;dy[3]=-r;
	for(int i(1);i<=n;++i)
		for(int j(1);j<=m;++j){
			if(a[i][j]) continue;
			int u(id(i,j));
			AddEdge(s,u,1);
			AddEdge(u+n*m,t,1);
			for(int k(0);k<4;++k){
				int _i(i+dx[k]),_j(j+dy[k]);
				if(_i>n||_j<1||_j>m) continue;
				if(a[_i][_j]) continue;
				AddEdge(u,id(_i,_j)+n*m,1);
			}
		}
	printf("%d\n",sum-Dinic());
	return 0;
}
```

---

## 作者：mjsdnz (赞：0)

+ [原题链接](https://www.luogu.com.cn/problem/P2172)

## 题目大意

给一张地图，其中有能走的点和不能走的点，并且给你 $R$ 和 $C$，表示行走路线（比如象棋中的马就是 $R=1$，$C=2$）。每个能走的点只能走一次，且只能向下走。可以从任一点开始，任一点结束，求出走完所有能走的点的最少开始次数。

## 建模

把题意化简完就会发现，这道题就是最小路径覆盖，这里简单说一下最短路径覆盖的思想：

既然要求最短路径覆盖，那么我们吧覆盖表示一下，**覆盖=点总数-最大独立集**，最大独立集其实就是最小割，因此**覆盖=点总数-最小割**，又因为最小割就是最大流，所以**覆盖=点总数-最大流**。

问题转换完了，模型也就出来了。利用拆点的思想，将一个点拆为入点和出点，以限制一个点的经过次数。源点连向所有入点，所有出点连向汇点，入点连向对应出点，流量都为一。对于可以联通的两点 $i$ 和 $j$，将 $i$ 的入点连向 $j$ 的出点，流量为一。最后跑最大流即可。

注意：

  + 由于只能往下走，所以不要在连边的时候连向上的边，一个点最多需要四次行走。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
const int inf=0x3f3f3f3f;
const int N = 3e4 + 10;
const int M = 3e5 + 10;
int cnt = 1;
int head[N];
int n, m;
int s, t;
int now[N];
int dep[N];
struct edge {
	int u, v, c, val, nxt;
	edge(int u = 0, int v = 0, int c = 0, int val = 0, int nxt = 0): u(u), v(v), c(c), val(val), nxt(nxt) {}
} e[M];
void ADD(int u, int v, int c, int val) {
	cnt++;
	e[cnt] = edge(u, v, c, val, head[u]);
	head[u] = cnt;
}
void add_edge(int u, int v, int c, int val) {
	ADD(u, v, c, val);
	ADD(v, u, 0, -val);
}
bool bfs() {
	queue<int>q;
	memset(dep, 0, sizeof dep);
	memcpy(now, head, sizeof head);
	dep[s] = 1;
	q.push(s);
	while (!q.empty()) {
		int u = q.front();
		q.pop();
		for(int i=head[u];i;i=e[i].nxt){
			int v=e[i].v;
			int c=e[i].c;
			if(!c||dep[v]!=0) continue;
			dep[v]=dep[u]+1;
			q.push(v);
		}
	}
	return dep[t]!=0;
}
int dfs(int u,int t,int flow){
	if(u==t) return flow;
	int nowflow=0;
	for(int i=now[u];i&&nowflow<flow;i=e[i].nxt){
		now[u]=i;
		int v=e[i].v;
		int c=e[i].c;
		if(!c||dep[v]!=dep[u]+1)continue;
		int ff=dfs(v,t,min(flow-nowflow,c));
		if(ff) nowflow+=ff,e[i].c-=ff,e[i^1].c+=ff;
	}
	return nowflow;
}
int maxflow(){
	int ans=0;
	while(bfs()){
		int nowflow;
		while((nowflow=dfs(s,t,inf))) ans+=nowflow;
	}
	return ans;
}
int r, c;
int dx[4];
int dy[4];
int mp[55][55];
int tot;
int main()
{
	cin>>n>>m>>r>>c;
	int sum=0;
	s=n*m*2+1,t=s+1;
	dx[0]=r,dx[1]=c,dx[2]=r,dx[3]=c;
	dy[0]=-c,dy[1]=-r,dy[2]=c,dy[3]=r;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			char cc;
			cin>>cc;
			if(cc=='.'){
				mp[i][j]=++tot;
				sum++;
			}
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if(!mp[i][j])continue;
			add_edge(s,mp[i][j],1,0);
			add_edge(mp[i][j]+n*m,t,1,0);
			for(int k=0;k<4;k++){
				int x=i+dx[k],y=j+dy[k];
				if(x<1||y<1||x>n||y>m||mp[x][y]==0)continue;
				add_edge(mp[i][j],mp[x][y]+n*m,1,0);
			}
		}
	}
	cout<<sum-maxflow();
}
```

---

## 作者：Foreverxxx (赞：0)

~~不知道多少倍~~经验：[TJOI2013 攻击装置](https://www.luogu.com.cn/problem/P4304)，[长脖子鹿放置](https://www.luogu.com.cn/problem/P5030)，[骑士共存问题](https://www.luogu.com.cn/problem/P3355)。

### 正文

读题，题目要求每个点都要被覆盖到，并且每个点只能被一支军队到达，那么这道题很明显就是一个**最小路径覆盖问题**。

我们对每个点进行考虑，由题意，每个点最终都会**匹配**另外一个点，而我们要求的，便是所有点都被匹配的所需的最少的点数。

所以我们想到了二分图匹配。

那么我们就有了一个定理：在二分图中，最小路径覆盖数 = 点数-最大匹配数。证明参考[二分图相关定理及其证明](https://blog.csdn.net/qq_34564984/article/details/52778763)。

我们稍微思考一下一种特殊情况，如果一个城镇不能被其它任何一个点到达，那么答案会不会发生变化（其实大家应该都知道吧）？

当然不会，毕竟我们统计所有点的数量的时候，会将这个点算进去，使得总点数加一，而在二分图匹配过程中，这个点是不参与匹配的，那么最终这个点在覆盖中会被单独算一次，结论仍然正确。

### 一些细节

1. 注意计算过程中的所有点都应该是城镇而不能是高山深涧。

2. 注意判断是否越界。

3. 坐标量偏移数组应该在输入第一行后再赋值。

Code

```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read(){
	int sss=0;
	char chh=getchar();
	while(chh<'0'||chh>'9') chh=getchar();
	while(chh>='0'&&chh<='9'){
		sss=sss*10+chh-'0';
		chh=getchar();
	}
	return sss;
}
int n,m,r,c;
int sum=0,ans=0;
char maze[55][55];
int matched[10005],vis[10005];
int head[10005],to[10005],nxt[10005],tot=0;
void add(int u,int v){
	to[++tot]=v;
	nxt[tot]=head[u];
	head[u]=tot;
}
bool in(int x,int y){
	return 1<=x&&x<=n&&1<=y&&y<=m;
}
int calc(int x,int y){
	return m*(x-1)+y;
}
bool find(int now){
	for(register int i=head[now];i;i=nxt[i]){
		int u=to[i];
		if(vis[u]!=sum){
			vis[u]=sum;
			if(!matched[u]||find(matched[u])){
				matched[u]=now;
				return true;
			}
		}
	}
	return false;
}
int solve(){
	sum=ans=0;
	for(register int i=1;i<=n;i++){
		for(register int j=1;j<=m;j++){
			if(maze[i][j]=='.'){
				sum++;
				if(find(calc(i,j))) ans++;
			}
		}
	}
	return sum-ans;
}
int main(){
	n=read(),m=read(),r=read(),c=read();
	int dx[]={r,r,c,c},dy[]={c,-c,r,-r};
	for(register int i=1;i<=n;i++){
		for(register int j=1;j<=m;j++){
			cin>>maze[i][j];
		}
	} 
	for(register int i=1;i<=n;i++){
		for(register int j=1;j<=m;j++){
			if(maze[i][j]=='.'){
				for(register int k=0;k<4;k++){
					int tx=i+dx[k],ty=j+dy[k];
					if(in(tx,ty)&&maze[tx][ty]=='.'){
						add(calc(i,j),calc(tx,ty));
					}
				}
			}
		}
	}
	printf("%d",solve());
	return 0;
}
```

---

## 作者：BMTXLRC (赞：0)

看题不难发现是一道边覆盖的题，考虑用二分图打。

这篇题解是一篇少见的二分图题解（

### Part 1：建图

既然已经给出了走的路线，建图思路就很明确了，**把一个点与一个点所能到达的所有点连上边**。

根据二分图的定义，不难得知，图中不可能有环，因此**这是一个二分图**。

建图时用一个函数将数组对应的点 $(x,y)$ 转成 $(x-1)\times m+y$。

```cpp
int change(int x,int y){return (x-1)*m+y;}
```


为了不使建边重复，我们讨论 $r=c$ 和 $r\neq c$。

- 如果 $r=c$：

此点可以到达接下来的两个点：$(i+r,j+c)$ 和 $(i+r,j-c)$。

- 如果 $r\neq c$：

此点可以到达四个点：$(i+r,j+c)$，$(i+r,j-c)$，$(i+c,j+r)$ 和 $(i+c,j-r)$。

注意建边时还要判断此点合法，即：

- 没有数组越界。

- 此点不为 `x`。

判断函数如下：

```cpp
bool check_matrix(int x,int y){
    if(f[x][y]==0) return false;
    if(x<=n&&x>=1&&y<=m&&y>=1) return true;
    return false;
}
```

建边这一部分就到此结束了：

```cpp
for(register int i=1;i<=n;i++){
    for(register int j=1;j<=m;j++){
        if(check_matrix(i,j)==false) continue;
        if(r!=c){
            if(check_matrix(i+r,j+c)) add(change(i,j),change(i+r,j+c));
            if(check_matrix(i+c,j+r)) add(change(i,j),change(i+c,j+r));
            if(check_matrix(i+c,j-r)) add(change(i,j),change(i+c,j-r));
            if(check_matrix(i+r,j-c)) add(change(i,j),change(i+r,j-c));
        }else{
            if(check_matrix(i+r,j+c)) add(change(i,j),change(i+r,j+c));
            if(check_matrix(i+r,j-c)) add(change(i,j),change(i+r,j-c));
        }
    }
}
```

### Part2：匈牙利算法

给大家两个小优化（如果算是的话）：

- 邻接表存图。

- 不需要每次采用 $\texttt{memset}$ 进行处理，可以记一个数组 $dfn_i$ 表示第 $i$ 轮是否遍历到此点。如果此轮遍历到了，就不需要遍历了。

```cpp
bool dfs(int x){
    for(register int i=head[x];i;i=a[i].nxt){
        int y=a[i].to;
        if(dfn[y]-id){
            dfn[y]=id;
            if(!g[y]||dfs(g[y])){
                g[y]=x;
                return true;
            }
        }
    }
    return false;
}
```

答案为 $sum-ans$，其中 $sum$ 为 `.` 的个数，$ans$ 为最大匹配。

### Part3：其他提醒

输入字符的时候建议使用 $\texttt{getchar}$。

一定要判边界。

### Part4：总代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e4+5;
int n,m,r,c,f[55][55],head[N],cnt,ans=0,g[N],dfn[N],id=1,sum=0;
struct edge{int to,nxt;}a[N];
void add(int x,int y){
    a[++cnt].to=y;
    a[cnt].nxt=head[x];
    head[x]=cnt;
}
bool check_matrix(int x,int y){
    if(f[x][y]==0) return false;
    if(x<=n&&x>=1&&y<=m&&y>=1) return true;
    return false;
}
int change(int x,int y){return (x-1)*m+y;}
bool dfs(int x){
    for(register int i=head[x];i;i=a[i].nxt){
        int y=a[i].to;
        if(dfn[y]-id){
            dfn[y]=id;
            if(!g[y]||dfs(g[y])){
                g[y]=x;
                return true;
            }
        }
    }
    return false;
}
int main(){
    scanf("%d %d %d %d",&n,&m,&r,&c);
    for(register int i=1;i<=n;i++){
        for(register int j=1;j<=m;j++){
            char ch=getchar();
            while(ch!='.'&&ch!='x') ch=getchar();
            if(ch=='.') f[i][j]=1,sum++;
            else f[i][j]=0;
        }
    }
    for(register int i=1;i<=n;i++){
        for(register int j=1;j<=m;j++){
            if(check_matrix(i,j)==false) continue;
            if(r!=c){
                if(check_matrix(i+r,j+c)) add(change(i,j),change(i+r,j+c));
                if(check_matrix(i+c,j+r)) add(change(i,j),change(i+c,j+r));
                if(check_matrix(i+c,j-r)) add(change(i,j),change(i+c,j-r));
                if(check_matrix(i+r,j-c)) add(change(i,j),change(i+r,j-c));
            }else{
                if(check_matrix(i+r,j+c)) add(change(i,j),change(i+r,j+c));
                if(check_matrix(i+r,j-c)) add(change(i,j),change(i+r,j-c));
            }
        }
    }
    for(register int i=1;i<=n;i++){
        for(register int j=1;j<=m;j++,id++){
            if(f[i][j]==1) ans+=dfs(change(i,j));
        }
    }
    printf("%d",sum-ans);
}
```


---

## 作者：Dispwnl (赞：0)

因为每个点只让过一次

还可以从任意一个点出发或结束

所以~~很容易~~想到网络流的最小路径覆盖

把每个点一分为二

源点与每个点的入点连容量为1的边

每个点的出点与汇点连容量为1的边

这保证可以从任意一个点出发或结束

每个点的入点与它能到达的点的出点连容量为1的边

跑最大流就行了

最后输出'.'的总数-最大流

因为这有一个结论：

### 路径覆盖中的每条简单路径除了最后一个顶点之外都有唯一的后继和它对应；因此匹配边数就是非路径结尾的结点数；因此，匹配边数达到最大时，非路径结尾的结点数大道最大，故路径结尾的节点数目最少。
```cpp
# include<iostream>
# include<cstdio>
# include<cstring>
# include<queue>
# define pu(x,y) (x-1)*m+y
using namespace std;
const int MAX=100001,t=100000,inf=1e8;
struct p{
	int x,y,dis;
}c[MAX<<1];
int n,m,R,C,num,tot,SUM;
int h[MAX],d[MAX],pre[MAX];
char a[51][51];
void add(int x,int y,int dis)
{
	c[num]=(p){h[y],x,0};
	h[y]=num++;
	c[num]=(p){h[x],y,dis};
	h[x]=num++;
}
int dfs(int x,int dix)
{
	if(!dix||x==t) return dix;
	int sum=0;
	for(int i=h[x];i;i=c[i].x)
	  if(d[c[i].y]==d[x]+1&&c[i].dis)
	  {
	  	int dis=dfs(c[i].y,min(c[i].dis,dix));
	  	if(dis)
	  	{
	  		dix-=dis;
	  		sum+=dis;
	  		c[i].dis-=dis;
	  		c[i^1].dis+=dis;
	  		if(!dix) break;
		}
	  }
	if(!sum) d[x]=-2;
	return sum;
}
bool bfs()
{
	queue<int> qu;
	qu.push(0);
	memset(d,0,sizeof(d));
	d[0]=1;
	while(!qu.empty())
	{
		int tt=qu.front();
		qu.pop();
		for(int i=h[tt];i;i=c[i].x)
		  if(!d[c[i].y]&&c[i].dis)
		  {
		  	d[c[i].y]=d[tt]+1;
		  	qu.push(c[i].y);
		  }
	}
	return d[t];
}
int dinic()
{
	int tot=0;
	while(bfs()) tot+=dfs(0,inf);
	return tot;
}
int main()
{
	scanf("%d%d%d%d",&n,&m,&R,&C);
	int ff=pu(n,m);
	for(int i=1;i<=n;i++)
	  for(int j=1;j<=m;j++)
	  	cin>>a[i][j];
	for(int i=1;i<=n;i++)
	  for(int j=1;j<=m;j++)
	    if(a[i][j]=='.')
	    {
	    	SUM++;
	    	int hh=pu(i,j),x,y;
	    	x=i+R,y=j+C;
			if(a[x][y]=='.'&&x>=1&&y>=1&&x<=n&&y<=m)
			add(hh,pu(x,y)+ff,1);
			x=i+R,y=j-C;
			if(a[x][y]=='.'&&x>=1&&y>=1&&x<=n&&y<=m)
			add(hh,pu(x,y)+ff,1);
			x=i+C,y=j+R;
			if(a[x][y]=='.'&&x>=1&&y>=1&&x<=n&&y<=m)
			add(hh,pu(x,y)+ff,1);
			x=i+C,y=j-R;
			if(a[x][y]=='.'&&x>=1&&y>=1&&x<=n&&y<=m)
			add(hh,pu(x,y)+ff,1);
			add(0,hh,1),add(hh+ff,t,1);
		}
	printf("%d",SUM-dinic());
	return 0;
}
```
代码挺无脑

然而我还是WA了一片

---


# 奶牛隐藏

## 题目背景

这本是一个非常简单的问题，然而奶牛们由于下雨已经非常混乱，无法完成这一计算，于是这个任务就交给了你。(奶牛混乱的原因看题目描述)


## 题目描述

在一个农场里有 $n$ 块田地。某天下午，有一群牛在田地里吃草，他们分散在农场的诸多田地上，农场由 $m$ 条无向的路连接，每条路有不同的长度。

突然，天降大雨，奶牛们非常混乱，想要快点去躲雨。已知每个田地都建立有一个牛棚，但是每个牛棚只能容纳一定数量的牛躲雨，如果超过这个数量，那多出的牛只能去别的田地躲雨。奶牛们每移动 $1$ 的距离花费 $1$ 时间，奶牛们想知道它们全部都躲进牛棚，最少需要多少时间。(即最后一头奶牛最少要花多久才能躲进牛棚)。


## 说明/提示

#### 样例输入输出 1 解释

$1$ 号点的两只牛直接躲进 $1$ 号牛棚，剩下的 $5$ 只中，$4$ 只跑去 $2$ 号点，还有一只沿 $1 \to 2 \to 3$ 躲进 $3$ 号点, $3$ 号点的 $2$ 只牛也直接躲进去，这样最慢的牛花费的时间是 $110$。

#### 数据规模与约定

对于 $100\%$ 的数据，保证：
- $1 \leq n \leq 200$，$1 \leq m \leq 1500$。
- $1 \leq u, v \leq n$，$1 \leq w \leq 10^{15}$，$1 \leq s_i, p_i \leq 10^{16}$。


## 样例 #1

### 输入

```
3 4 
7 2 
0 4 
2 6 
1 2 40 
3 2 70 
2 3 90 
1 3 120
```

### 输出

```
110```

# 题解

## 作者：ker_xyxyxyx_xxs (赞：5)

[P2402 奶牛隐藏](https://www.luogu.com.cn/problem/P2402)

二分答案 $ + $ 网络流

建图：

1、源点 $ \rightarrow $ 每块田，边权为牛的数量

2、每个牛棚 $ \rightarrow $ 汇点，边权为牛棚最多能容纳的牛

3、对中间的边进行二分答案。具体操作如下。

使用 floyd 对两个点之间的最短距离预处理，对最小时间进行二分答案。如果在这个时间内可以从 $ i $ 号田地走向 $ j $ 号牛棚，就连一条边，容量为 $ \infty $ ，最终检验最大流是否等于牛的数量即可。

一些易错点：

1、存在重边，邻接矩阵需要加上 $ min $。

2、邻接矩阵每个点到自己的距离需要赋值为 $ 0 $。

3、二分需要清空之前的数组。
 
Code
```cpp
 # include <bits/stdc++.h>
using namespace std;
# define int long long
const int N = 1e6 + 5;
const int M = 2e6 + 5;
const int inf = 1e18; 
const int maxn = 200 + 5;

typedef struct {
	int x , y , z , next;
}Node;
Node edge[M];
int E = 1 , elast[N];
int S , T;

void add(int x , int y , int z) {
	E ++ , edge[E].x = x , edge[E].y = y , edge[E].z = z , edge[E].next = elast[x] , elast[x] = E;
}

int dis[N] , cnt[N];
void bfs(int start) {
    queue<int> q;
    q.push(start);
    dis[start] = 0;
    cnt[S] = 1;
    while (!q.empty()) {
        int cur = q.front();
        q.pop();
        for (int i = elast[cur] ; i ; i = edge[i].next) {
            int v = edge[i].y;
            if (dis[v] != -1) continue;
            dis[v] = dis[cur] + 1;
            q.push(v);
            cnt[dis[v]] ++;
        }
    }
}
int cur[N];
int dfs(int u , int flow) {
    if (u == T) return flow;
    int delta = 0;
    for (int i = cur[u] ; i ; i = edge[i].next) {
        cur[u] = i;
        int v = edge[i].y;
        if (edge[i].z > 0 && dis[u] == dis[v] + 1) {
            int temp = dfs(v , min(flow - delta , edge[i].z));
            edge[i].z -= temp;
            edge[i ^ 1].z += temp;
            delta += temp;
            if (delta == flow) return delta;
        }
    }
    if (dis[S] >= T + 1) return delta;
    cur[u] = elast[u];
    if (-- cnt[dis[u]] == 0) dis[S] = T + 1;
    cnt[++ dis[u]] ++;
    return delta;
}
int Isap() {
    int ans = 0;
    memset(cnt , 0 , sizeof cnt);
    memset(dis , -1 , sizeof dis);
    bfs(T);
    for (int i = 0 ; i <= T ; i ++) {
        cur[i] = elast[i];
    }
    while (dis[S] < T + 1) ans += dfs(S , inf);
    return ans;
}
int n , m;
int a[N] , b[N] , Dis[maxn][maxn];
void rebuild(int maxv) {
	for (int i = 1 ; i <= n ; i ++) {
    	add(S , i , a[i]) , add(i , S , 0);
    	add(n + i , T , b[i]) , add(T , n + i , 0);
    	for (int j = 1 ; j <= n ; j ++) {
    		if (Dis[i][j] <= maxv) add(i , n + j , inf) , add(n + j , i , 0);
		}
	}
}
void init() {
	memset(elast , 0 , sizeof elast);
	E = 1;
}
bool check(int cnt) {
	if (Isap() == cnt) return true;
	else return false;
}
int Cnt = 0;
signed main() {
	cin >> n >> m;
	for (int i = 1 ; i <= n ; i ++) {
		cin >> a[i] >> b[i];
		Cnt += a[i];
	}
	memset(Dis , 0x3f , sizeof Dis);
	for (int i = 1 ; i <= n ; i ++) Dis[i][i] = 0;
	for (int i = 1 ; i <= m ; i ++) {
		int x , y , z;
		cin >> x >> y >> z;
		Dis[x][y] = min(Dis[x][y] , z);
		Dis[y][x] = min(Dis[y][x] , z);
	}
	for (int k = 1 ; k <= n ; k ++) {
		for (int i = 1 ; i <= n ; i ++) {
			for (int j = 1 ; j <= n ; j ++) {
				Dis[i][j] = min(Dis[i][j] , Dis[i][k] + Dis[k][j]);
			}
		}
	}
    S = 0 , T = n << 1 | 1;
    int l = 0 , r = inf;
    int ans = 0;
	while (l <= r) {
    	int mid = (l + r) >> 1;
        init();
		rebuild(mid);
		bool flag = check(Cnt);
        if (!flag) l = mid + 1;
        else r = mid - 1 , ans = mid;
	}
	if (ans == 0) cout << "-1" << endl;
	else cout << ans << endl;
	return 0;
}
```

---

## 作者：FlashHu (赞：5)

~~@MloVtry 大犇 第一眼以为是取最后一次最大费用~~+1


然而很快就把这种诡异的办法给自己推翻掉了。


例子很简单。。。。。。



 ![](https://cdn.luogu.com.cn/upload/pic/13023.png) 

这张图的意思是，有3块田，1、2处各有一头牛，2、3处各有一个容量为1的棚。如果建费用流的图，就会长这个样子对吧。


试想一下跑费用流会发生什么。。。。。。


第一次，由S->2->T,没有费用；


第二次，由S->1->2->3->T,费用为2，跑完了。


然而，滑稽了。事实上，我们可以让两头牛一起动，1->2,2->3,最大的费用只有1。


因为费用流每次把最短的挑走了，使我们反而找不到答案。所以万万不能跑费用流了。


---

还是考虑**二分答案跑最大流最小割**吧。


然而看到下面几位大犇拼命卡INF，我自己也瞬间崩溃。。。。。。


于是，有必要来减少二分次数了。


既然点数是有限的，那么它们两两相连所产生的边数也不多，顶多几万条。而longlong取值范围太大了，即使二分，也需要跑五六十下（假如没卡INF大小的话），卡了以后也还是不小。


所以，可以把**边按长度离散化**，在边的集合上进行二分。把点两两之间的最短距离用**floyd**算出来以后，按长度**sort**一下，再按次序加入边集合中。还要按照长度的取值范围分成若干个小集合（即离散化）。因为已经有序了，所以直接在取值范围的序列上二分就好了。


加上一个比较方便的做法。把**每个值在边集中的对应位置**也记录下来。二分完，跑最大流最小割的时候，在这个位置之后的边（也就是边长比mid大的边，因为sort加离散化后较长的边加在了后面）都直接跳过。这样做又省去了重新建边的时间。


---

然后我就WA了，~~连样例都没过~~


调试了下发现，当我二分到70的时候，居然满流了。。。。。。


原来我没拆点，结果1<->2长度40的边和2<->3长度70的边连起来了。。。。。。


**所以一定要拆点！！！**边加两次就是了。


和楼上大犇有一点点区别，就是边的容量可以不用开到INF了，等于起点对应的牛数量就可以了（从那里只能跑出那么多牛嘛）。~~说不定可以优化常数~~


附上样例建图



 ![](https://cdn.luogu.com.cn/upload/pic/13060.png) 

---
吐槽一句~~TM这题目数据范围也没给清楚~~


所以还是要开longlong的，实测开intWA一个点。。。。。。


具体细节就看下面代码吧。加了不少优化，32s成功冲到当前本题rank1~~开了O2~~，欢迎超越。

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
typedef long long LL;
#define R register int
#define RL register LL
const int N=1009,M=200009;
const LL INF=1ll<<50;
struct EDGE{
    int a,b;
    LL l;
}e[M];//两点之间的连边存在这里排序
int S=0,T,SZ,he[N],ne[M],to[M],q[N],d[N],cur[N],grp[M];
LL LIM,f[M],mem[M],val[M],g[N][N];
#define G c=getchar()
#define in(z) G;\
    while(c<'-')G;\
    z=c&15;G;\
    while(c>'-')z*=10,z+=c&15,G;
#define min(x,y) x<y?x:y
#define min2(x,y) if(x>y)x=y
#define add(U,V,F)\
    to[++p]=V;ne[p]=he[U];he[U]=p;mem[p]=F;\
    to[++p]=U;ne[p]=he[V];he[V]=p;
inline bool cmp(EDGE x,EDGE y){return x.l<y.l;}
inline bool bfs()
{
    memset(d+1,0,SZ);
    for(R h=0,t=1;h<t;++h)
        for(R i=he[q[h]];i;i=ne[i])
            if(i<LIM&&f[i]&&!d[to[i]])
                d[q[t++]=to[i]]=d[q[h]]+1;
    return d[T];
}//i<LIM忽略编号超过限制的边
LL dfs(R u,RL mf)
{
    if(u==T)return mf;
    for(R&i=cur[u];i;i=ne[i])
        if(i<LIM&&f[i]&&d[to[i]]==d[u]+1)
        {
            RL cf=dfs(to[i],min(f[i],mf));
            if(cf){f[i]-=cf;f[i^1]+=cf;return cf;}
        }
    return 0;
}//以上是dinic模板
int main()
{
    R n,m,p=1,h=0,t=0,i,j,k,u,v;
    RL s,sum=0,res;
    register char c;
    in(n);in(m);T=n*2+1;SZ=(T+1)<<2;//S,T就是源汇点啦，SZ维护数组的长度
    for(i=1;i<=n;++i)
    {
        in(s);add(S,i,s);sum+=s;//统计一下牛的总数也就是总流量
        in(s);add(i+n,T,s);
    }
    for(i=1;i<=n;++i){add(i,i+n,mem[(i<<2)-2])};//mem之前存下了对应点的牛数
    for(i=1;i<=n;++i)
        for(j=1;j<i;++j)
            g[i][j]=INF;
    while(m--)
    {
        in(u);in(v);if(u<v){t=u;u=v;v=t;}
        in(s);min2(g[u][v],s);
    }
    for(k=1;k<=n;++k)
        for(i=1;i<=n;++i)
        {
            if(k==i)continue;
            s=k>i?g[k][i]:g[i][k];
            if(t==INF)continue;
            for(j=1;j<(min(k,i));++j)
                min2(g[i][j],s+g[k][j]);
            for(j=k+1;j<=i;++j)
                min2(g[i][j],s+g[j][k]);
        }//以上是Floyd，只用了半个矩阵，可能跑的快点吧
    for(i=1;i<=n;++i)
        for(j=1;j<i;++j)
            if(g[i][j]!=INF)
                e[h++]=(EDGE){i,j,g[i][j]};//加进去准备排序
    sort(e,e+h,cmp);
    s=0;
    for(i=0;i<h;++i)
    {
        if(s<e[i].l)//离散化，s放的是上一块的取值
        {            //值增加了，处理上一块
            grp[t]=p+1;//grp记下取值在边集数组中对应位置
            val[t++]=s;//val记下上一块的值
            s=e[i].l;//更新s
        }
        add(e[i].a,e[i].b+n,mem[(e[i].a<<2)-2]);
        add(e[i].b,e[i].a+n,mem[(e[i].b<<2)-2]);
    }
    grp[t]=p+1;val[t++]=s;
    grp[t]=p+3;val[t]=-1;//收下尾
    h=1;
    while(h!=t)//二分开始
    {
        LIM=grp[m=(h+t)>>1];//确定限制，dinic时忽略编号超过此限制的边
        memcpy(f,mem,(p+1)<<3);//每次把记好的边流量copy一下再跑
        res=0;
        while(bfs())
        {
            memcpy(cur,he,SZ);//加当前弧优化
            while((s=dfs(S,INF)))
                res+=s;
        }
        sum==res?t=m:h=m+1;
    }
    printf("%lld",val[h]);
    return 0;
}
```

---

## 作者：jun头吉吉 (赞：3)

# P2402 【奶牛隐藏】
## 题意

一张无向图上有$n$个点，每个点上有$s_i$头牛，可以容纳$p_i$头牛，如果有一条边$(u,v,w)\in G$，那么一头牛可以用$w$的时间从$u$到$v$

问至少需要多久时间可以使全部的牛躲进牛棚。

## 题解
看到让所有的牛进入牛棚，这个时间很明显是可以二分的。因为如果$t$的时间所有的牛可以躲进，那么$t^\prime>t$还有什么理由躲不进呢。

那么考虑这些时间有什么特点。假设我们用一个集合$S$来放所有的$dis[i][j]$，那么如果有一个$t\notin S$，那么如果$t$可行，$S$中第一个比它小的数字也同样可行。此时在检验这个数字~~纯粹是在浪费评测机资源~~ ~~也不会慢多少~~

于是我们把所有的时间存进$\texttt{set}$里，在放进一个数组，对这个数组进行二分，此时次数为$\log_2(n^2)$

~~于是剩下的检验操作有手就行了~~。建两排点，一排为牛，另一排为牛棚。超级源点$S$连到牛，流量为$s_i$，牛棚连到超级汇点$T$，流量为$p_i$，$\forall dis[i][j]\le mid$的点，连一条从牛$i$连接到牛棚$j$，流量为$+\infty$的边。跑一遍最大流，若$flow=\sum_{i=1}^n s_i$，则此方案可行

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=4010,maxe=100010*2;
#define int long long 
struct Graph{
    struct node{
        int v,w,nxt;
    }e[maxe<<1];
    int head[maxn],cur[maxn],tot;
    int dis[maxn];
    int s,t;
    void init(int _s,int _t){s=_s,t=_t;tot=1;memset(head,0,sizeof head);}
    Graph(int _s=0,int _t=0){init(_s,_t);}
    void add(int u,int v,int w){
        //printf("%d %d %d\n",u,v,w);
        e[++tot]=(node){v,w,head[u]},head[u]=tot;
        e[++tot]=(node){u,0,head[v]},head[v]=tot;
    }
    #define v e[i].v
    inline bool bfs(){
        queue<int>q;
        memset(dis,0,sizeof dis);
        memcpy(cur,head,sizeof head);
        dis[s]=1;q.push(s);
        while(q.size()){
            int u=q.front();q.pop();
            for(int i=head[u];i;i=e[i].nxt)
                if(!dis[v]&&e[i].w){
                    dis[v]=dis[u]+1,q.push(v);
                    if(v==t)return true;
                }
        }
        return  false;
    }
    int dfs(int u,int flow){
        if(u==t)return flow;
        int rest=flow;
        for(int i=cur[u];i&&rest;i=e[i].nxt){
            if(dis[v]==dis[u]+1&&e[i].w){
                int tmp=dfs(v,min(rest,e[i].w));
                rest-=tmp,e[i].w-=tmp,e[i^1].w+=tmp;
            }
            cur[u]=i;
        }
        if(rest==0)dis[u]=-1;
        return flow-rest;
    }
    #undef v
    int dinic(){
        int ans=0;
        while(bfs())
            while(int sth=dfs(s,2e9))
                ans+=sth;
        return ans;
    }
}; 
Graph G;
int f[300][300];
int s[300],p[300];
int n,m,u,v;int w,sum;
const int inf=199000000900;
bool check(int x){
	G.init(0,2*n+1);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			if(f[i][j]<=x||i==j)
				G.add(i,j+n,inf);
	for(int i=1;i<=n;i++)G.add(G.s,i,s[i]),G.add(i+n,G.t,p[i]);
	int tmp=G.dinic();
	return tmp>=sum;
}
set<int>a; 
vector<int>vec;
signed main(){
	memset(f,0x3f,sizeof f);
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
		scanf("%lld%lld",&s[i],&p[i]),sum+=s[i];
	for(int i=1;i<=m;i++)
		scanf("%d%d%lld",&u,&v,&w),
		f[u][v]=f[v][u]=min(f[v][u],w);
	for(int k=1;k<=n;k++)
		for(int i=1;i<=n;i++)
			for(int j=1;j<=n;j++)
				f[i][j]=min(f[i][j],f[i][k]+f[k][j]);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			if(f[i][j]!=0x3f3f3f3f3f3f3f3f)
				a.insert(f[i][j]);
	vec.assign(a.begin(),a.end());
	int l=0,r=vec.size()-1,ans=-1;
	for(;l<=r;){
		int mid=l+r>>1;
		if(check(vec[mid]))ans=vec[mid],r=mid-1;
		else l=mid+1;
	}cout<<ans;
}
```

---

## 作者：MloVtry (赞：3)

【嗨呀一血好开心】

这个题第一眼以为是取max的费用流...还是太年轻

不过转念一想：哎呀最大最小不是二分吗？

然后就搞了个二分答案，然后网络流判定就好了

其实查一下记录会发现这道题一多半是我交的（......），被卡一组要死要活的，感觉和某手游的回头沟一样诱人心醉....

所以这里提示一下坑点：答案不保证在inf范围内....

（但是也没枚举太太太太太大，会T掉....）

嘛，建图的话还是比较中规中矩的

弗洛伊德求出任意两点最短路

把每个格子拆开，牛为x部，棚子为y部，xi--->yj 连边，cost为最短路，容量为inf

然后新建s与t，s与每个xi连边，容量为有几头牛，花费0

yi向t连边，容量为牛棚大小，花费0

然后就是代码

（Dinic）


```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<queue>
#include<cmath>
#define inf 199000000010
#define R register
#define N 6000
#define M 100000
#define ll long long 
using namespace std;
ll map[250][250],say;
ll cal[250],can[250],cat,cant;
ll n,m,s,t;
ll out(ll x)
{
    return x+n;
}
void fl()
{
    for(ll k=1;k<=n;++k)
    {
        for(ll i=1;i<=n;++i)
        {
            for(ll j=1;j<=n;++j)
            {
                map[i][j]=min(map[i][j],map[i][k]+map[k][j]);
            }
        }
    }
/*    for(ll i=1;i<=n;++i)
    {
        for(ll j=1;j<=n;++j)
        {
            cout<<map[i][j]<<" ";
        }
        cout<<endl;
    }*/
}
ll tot=1,from[M],head[N],to[M],next[M],cup[M],len[M],cpp[M];
ll mflow,mcost;
void buid(ll u,ll v,ll c,ll l)
{
    next[++tot]=head[u];
    head[u]=tot;
    to[tot]=v,from[tot]=u;
    cup[tot]=c,len[tot]=l;
    cpp[tot]=c;
}
void buidall()
{
    for(ll i=1;i<=n;++i)
    {
        for(ll j=1;j<=n;++j)
        {
            buid(i,out(j),inf,map[i][j]);
            buid(out(j),i,0,-map[i][j]);
        }
    }
}
ll use[N],itc[N],vis[N];
queue<ll> q;
bool bfs(ll ans)
{
    memset(itc,0,sizeof(itc));
    memset(vis,0,sizeof(vis));
    vis[s]=1,itc[s]=1,q.push(s);
    while(!q.empty())
    {
        ll now=q.front();q.pop();
        for(ll i=head[now];i;i=next[i])
        {
            ll j=to[i];
            if(cup[i]&&abs(len[i])<=ans&&!vis[j])
            {
                vis[j]=1;
                itc[j]=itc[now]+1;
                q.push(j);
            }
        }
    }
    return vis[t];
}
ll didit(ll now,ll want,ll ans)
{
    if(now==t||want==0) return want;
    ll f,iget=0;
    for(ll i=use[now];i;i=next[i])
    {
        ll j=to[i];
        if(itc[j]==itc[now]+1&&len[i]<=ans)
        {
            f=didit(j,min(want,cup[i]),ans);
            if(f==0)
            {
                use[now]=i;
                continue;
            }
            want-=f;
            iget+=f;
            cup[i]-=f;
            cup[i^1]+=f;
            use[now]=i;
            if(want==0) break;
        }
    }
    return iget;
}
void max_flow(ll ans)
{
    mflow=0;
    while(bfs(ans))
    {
        for(ll i=1;i<=N;++i) use[i]=head[i];
        mflow+=didit(s,inf,ans);
    }
}
int main()
{
    memset(map,20,sizeof(map));
    s=N-1,t=N-2;
    scanf("%lld%lld",&n,&m);
    for(ll i=1;i<=n;++i) scanf("%lld%lld",&cal[i],&can[i]),cat+=cal[i],cant+=can[i],map[i][i]=0;
    for(ll i=1;i<=m;++i)
    {
        R ll aa,bb,cc;
        scanf("%lld%lld%lld",&aa,&bb,&cc);
        map[aa][bb]=min(map[aa][bb],cc);
        map[bb][aa]=min(map[bb][aa],cc);
    }
    fl();
    buidall();
    for(ll i=1;i<=n;++i)
    {
        buid(s,i,cal[i],0);
        buid(i,s,0,0);
        buid(out(i),t,can[i],0);
        buid(t,out(i),0,0);
    }
    ll l=1,r=inf,ans;
    while(l<=r)
    {
        ans=(l+r)>>1;
        for(ll i=2;i<=tot;++i) cup[i]=cpp[i];
        max_flow(ans);
        if(mflow==cat) r=ans-1;
        else l=ans+1;
    }
    if(l>=inf) {printf("-1\n");return 0;}
    printf("%lld",l);
    return 0;
}
//ps.别问我inf是怎么来的，这不花了一下午试出来了嘛【捂脸】
```

---

## 作者：WuMin4 (赞：1)

## 题意

给出一个边带权无向图，每个点有一些奶牛和一个牛棚，牛棚有最大容量。奶牛可以同时移动，移动时间为边权。问使得每个点的牛棚都能容纳下该点的奶牛的最小时间为多少。

## 思路

最小时间显然考虑二分答案。发现 $n\le 200$，于是我们可以对原图使用 Floyd 求出任意两点之间的最短距离。

若最小时间为 $t$，则点 $i$ 的奶牛可以移动到满足 $dis_{i,j}\le d$ 的所有 $j$ 点。

于是我们建立二分图模型，设左部点 $i$ 为奶牛，右部点 $j$ 为牛棚。建立超级源汇点 $S,T$，将 $S$ 与 $i$ 连边，容量为牛的数量。$j$ 与 $T$ 连边，容量为牛棚容量。将 $dis_{i,j}\le d$ 的点进行连边，容量无限大。当最大流等于牛的数量时，则代表所有牛可以在 $d$ 的时间内躲进牛棚，否则不能。

注意图存在重边，以及牛可以呆在自己的牛棚里，即 $dis_{i,i}=0$。

## 代码

这里只给出关键部分，其中 `mf` 为最大流。

```cpp
struct node{
	int x,y;
}a[1505];
int n,m,dis[205][205],tot;
bool check(int mid){
	mf::init(2*n);
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			if(dis[i][j]<=mid){
				mf::add(i,n+j,mf::INF);
			}
		}
	}
	for(int i=1;i<=n;i++)
		mf::add(mf::S,i,a[i].x),mf::add(i+n,mf::T,a[i].y);
	return mf::isap()==tot;
}
signed main() {
	ios::sync_with_stdio(false);
	cin.tie(nullptr),cout.tie(nullptr);
	cin>>n>>m;
	memset(dis,0x3f,sizeof(dis));
	for(int i=1;i<=n;i++)
		cin>>a[i].x>>a[i].y,dis[i][i]=0,tot+=a[i].x;
	for(int x,y,d,i=1;i<=m;i++)
		cin>>x>>y>>d,dis[x][y]=dis[y][x]=min(dis[x][y],d);
	for(int k=1;k<=n;k++)
		for(int i=1;i<=n;i++)
			for(int j=1;j<=n;j++)
				dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]);
	int l=1,r=1e15,mid,res=1e15+1;
	while(l<=r){
		mid=(l+r)/2;
		if(check(mid)) res=mid,r=mid-1;
		else l=mid+1;
	}
	cout<<(res==1e15+1?-1:res);
	return 0;
}
```

[记录](https://www.luogu.com.cn/record/210361796)

---

## 作者：mqmhaaaa1 (赞：1)

首先看得出来这是网络流，但很多人可能会误以为这是费用流题目，很明显这不是，因为**牛可以同时走**。

所以我们便想到一个神奇的东西——**二分答案**。

所以我们可以先 floyd 预处理出所有点之间最短时间，然后二分最短时间 $mid$，把两点之间最短时间小于等于 $mid$ 的点加一条流量为 $inf$ 的边，跑一遍最大流，如果流量等于初始奶牛数量，说明时间可以更短，就往小的缩，反之亦然。

但是，这是**错误的**。

因为我们发现如果之间在两点之间这样建图，比如说这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/b0cv8yzn.png)

点 $1 \to 3$，$1 \to 2$。

但 $3,2$ 之间不可达，如果直接建图会导致本来只能在 $1,2$ 或 $1,3$ 之间的流量在 $2,3$ 之间转移，所以我们可以拆个点，如下。

![](https://cdn.luogu.com.cn/upload/image_hosting/t56v52k8.png)

把一个点拆为入点，出点（对应 $o,i$）。

由出点连向入点，源点连向出点，入点连向汇点（注意，自己的出点也要连向自己的入点）。

这样做保证了流量只会在目标点之间流动，满足了要求。

然后详见代码


```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
inline void write(ll x) {static ll sta[35];ll top = 0;do {sta[top++] = x % 10, x /= 10;} while (x);while (top) putchar(sta[--top] + 48);}
inline ll read() {ll x = 0, w = 1;char ch = 0;while (ch < '0' || ch > '9') {  if (ch == '-') w = -1;ch = getchar();}while (ch >= '0' && ch <= '9') {x = x * 10 + (ch - '0'); ch = getchar(); }return x * w; }
const ll N=1e3+10,M=2e6+10,inf=0x3f3f3f3f3f3f3f3f;
ll to[M<<1],nxt[M<<1],w[M<<1],bh[N],tot=1;
ll head[N],st[N];
bool vis[N];
inline void add(ll u,ll v,ll z){
	to[++tot]=v;
	nxt[tot]=bh[u];
	w[tot]=z;
	bh[u]=tot;

	to[++tot]=u;
	nxt[tot]=bh[v];
	w[tot]=0;
	bh[v]=tot;
}
ll s,t;
inline bool bfs(){
	for(ll i=s;i<=t;i++){
		head[i]=bh[i];
		st[i]=0;
	}
	queue<ll>q;
	q.push(s);
	st[s]=0;vis[s]=1;
	while(q.size()){
		ll u=q.front();q.pop();
		vis[u]=0;
		for(ll i=bh[u];i;i=nxt[i]){
			ll v=to[i];
			if(w[i]&&!st[v]&&v!=s){
				st[v]=st[u]+1;
				if(!vis[v]){
					vis[v]=1;
					q.push(v);
				}
			}
		}
	}
	return st[t];
}
ll mxf=0;
ll dic(ll u,ll flow){
	vis[u]=1;
	if(u==t){
		mxf+=flow;return flow;
	}
	ll zy=0;
	for(ll i=head[u];i&&flow;i=nxt[i]){
		ll v=to[i];head[u]=i;
		if(w[i]&&(!vis[v]||v==t)&&st[v]==st[u]+1){
			ll jb=dic(v,min(w[i],flow));
			w[i]-=jb,w[i^1]+=jb;
			zy+=jb;flow-=jb;
			if(!flow)break;
		}
	}
	vis[u]=0;
	return zy;
}
ll n,m;
ll si[210],pi[210];
ll dis[210][210];
void floyd(){
	for(ll i=1;i<=n;i++)dis[i][i]=0;
	for(ll k=1;k<=n;k++){
		for(ll i=1;i<=n;i++){
			for(ll j=1;j<=n;j++){
				if(dis[i][k]+dis[k][j]<dis[i][j])dis[i][j]=dis[i][k]+dis[k][j];
			}
		}
	}
}//floyd 
int main(){
	n=read();m=read();
	s=0;t=2*n+1;
	ll sums=0,sump=0;
	memset(dis,0x3f3f,sizeof dis);
	for(ll i=1;i<=n;i++){
		si[i]=read();pi[i]=read();
		sums+=si[i];sump+=pi[i];
	} 
	for(ll i=1;i<=m;i++){
		ll u=read(),v=read(),val=read();
		dis[u][v]=dis[v][u]=min(val,dis[u][v]);
	}
	floyd();
	if(sums>sump){
		putchar('-');putchar('1');
		return 0;
	}//记得判无解 
	ll l=0,r=inf;
	ll ans=inf;
	while(l<r){
		ll mid=(l+r)/2;
		if(l>=100000000000000000){
			ans=-1;
			break;
		}//记得判无解 
		memset(bh,0,sizeof bh);
		tot=1;mxf=0;
		for(ll i=1;i<=n;i++){
			add(s,i,si[i]);add(i+n,t,pi[i]);
			add(i,i+n,inf);
		}
		for(ll i=1;i<=n;i++){
			for(ll j=1;j<=n;j++){
				if(i==j||mid<dis[i][j])continue;
				add(i,j+n,inf);
			}
		}
		while(bfs()){
			vis[t]=1;
			while(vis[t]){
				memset(vis,0,sizeof vis);
				dic(s,inf);
			} 
		}
		
		if(sums==mxf)r=mid,ans=mid;
		else l=mid+1;
	}
	if(ans>0)write(ans);
	else cout<<ans;
	//Accept (& v &)
	return 0;
}
```

---

## 作者：splendore (赞：0)

看到题目中的 $n\le 200$，就知道可以考虑某些图论算法。

但不是费用流，别像我一样想歪了。

又看到题目隐含着需要一个最短路，那直接写一手 Floyd，然后看到题目要求最小值，想到二分答案应该比较好解决，然后发现 $check()$ 函数不太好写，题目里要维护的东西比较杂，但再回望一下 $n\le 200$，于是掏出 Dinic 写最大流。

具体上，每次 $check()$ 需要重新建图。

设当前二分到的时间为 $mid$，就将每对距离小于 $mid$ 的田地与雨棚连边，容量为 $inf$。从源点向每个田地建一条容量为牛的数量的边。然后从每个雨棚向汇点连一条容量为雨棚容量的边即可。

建完图跑一边最大流，如果最大流大于等于总流量返回真，否则返回假。

代码略长。
```
#include<cstdio>
#include<queue>
#include<cstring>
using namespace std;
typedef long long LL;
const int N=405,M=N*N*4+N*4+5;
const LL inf=0x3f3f3f3f3f3f3f3f;
struct edge{int y;LL f;int pre;}e[M];int elen=1,last[N];
void ins(int x,int y,LL f){
	e[++elen]={y,f,last[x]};last[x]=elen;
	e[++elen]={x,0,last[y]};last[y]=elen;
}
int n,m;
LL sum=0;
int h[N],cur[N],st,ed;
bool v[N];
bool bh(){
	memset(h,0,sizeof(h));h[st]=1;
	memset(v,0,sizeof(v));v[st]=1;
	queue<int>q;q.push(st);
	while(!q.empty()){
		int x=q.front();q.pop();
		v[x]=0;
		for(int k=last[x];k;k=e[k].pre){
			int y=e[k].y;
			if(e[k].f&&!h[y]){
				h[y]=h[x]+1;
				if(!v[y]){
					v[y]=1;
					q.push(y);
				}
			}
		}
	}
	return h[ed];
}
LL dfs(int x,LL f){
	if(x==ed)return f;
	LL sx=0;
	for(int k=cur[x];k;k=e[k].pre){
		cur[x]=k;
		int y=e[k].y;
		if(e[k].f&&h[y]==h[x]+1&&sx<f){
			LL sy=dfs(y,min(e[k].f,f-sx));
			e[k].f-=sy;e[k^1].f+=sy;sx+=sy;
			if(sx==f)return f;
		}
	}
	return sx;
}
LL g[N][N];
int a[N],b[N];
bool check(LL mid){
	elen=1;
	memset(last,0,sizeof(last));
	for(int i=1;i<=n;++i){
		ins(st,i,a[i]);
		ins(i+n,ed,b[i]);
		for(int j=1;j<=n;++j)
			if(i==j||g[i][j]<=mid)
				ins(i,j+n,inf);
	}
	LL mxf=0;
	while(bh()){
		memcpy(cur,last,sizeof(cur));
		mxf+=dfs(st,inf);
	}
	return mxf>=sum;
}
int main(){
	scanf("%d%d",&n,&m);
	st=0;ed=n*2+1;
	for(int i=1;i<=n;++i){
		scanf("%d%d",&a[i],&b[i]);
		sum+=a[i];
	}
	memset(g,0x3f,sizeof(g));
	for(int i=1,x,y;i<=m;++i){
		LL c;
		scanf("%d%d%lld",&x,&y,&c);
		g[x][y]=g[y][x]=min(g[x][y],c);
	}
	for(int k=1;k<=n;++k)
		for(int i=1;i<=n;++i)
			for(int j=1;j<=n;++j)
				g[i][j]=min(g[i][j],g[i][k]+g[k][j]);
	LL l=0,r=inf-1,ans=0;
	while(l<=r){
		LL mid=(l+r)>>1;
		if(check(mid))r=mid-1,ans=mid;
		else l=mid+1;
	}
	printf("%lld\n",ans?ans:-1);
	return 0;
}
```

---

## 作者：xubaichuan (赞：0)

### [题目传送门 - P2402 奶牛隐藏](https://www.luogu.com.cn/problem/P2402)
---
### 前置知识
* 二分答案
* 最大流
* 全源最短路

---

看到“最小”的第一反应就是二（~~bao~~）分（~~li~~）答案，但是该怎么 check() 呢？

不妨把每个田地里的牛和牛棚看成两个点，每个田地里的牛向每个牛棚连一条边，容量为 $\infty$，表示该田地里的牛可以到达任意一个牛棚且不限数量，再从源点向牛连一条容量为 $s_i$ 的边，牛棚向汇点连一条容量为 $p_i$ 的边，最后跑最大流 check() 看最大流是否等于牛的总数。

如果看到这里的你就迫不及待地开始实现，会悲催得连样例都过不了，一定要先预处理田地两两的最短距离，只有当 $dist_{i,j} \le mid$ 时才能从 $i$ 号田地的牛向 $j$ 号田地的牛棚连边。

---
### 接下来就是激动人心的 Code 环节了

```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long LL;

struct edge{int from,to,nex; LL w; };

const LL INF=0x3f3f3f3f3f3f3f3f;
const int MAX_N=450;
int n,m,s=MAX_N-2,t=MAX_N-1;
LL sums,ss[MAX_N],pp[MAX_N];
LL dist[MAX_N][MAX_N],ans=-1LL;
int cnt,head[MAX_N],now[MAX_N];
edge e[MAX_N*MAX_N*2];
int dep[MAX_N];
queue<int> q;

void add(int u,int v,LL w){
    e[++cnt]=(edge){u,v,head[u],w};
    head[u]=cnt;
    e[++cnt]=(edge){v,u,head[v],0LL};
    head[v]=cnt;
}

bool bfs(){
    memcpy(now,head,sizeof(head));
    memset(dep,0,sizeof(dep));
    dep[s]=1; q.push(s);
    
    while(!q.empty()){
        int u=q.front(); q.pop();
        for(int i=head[u];i;i=e[i].nex){
            int v=e[i].to;
            if(e[i].w&&!dep[v]){
                dep[v]=dep[u]+1;
                q.push(v);
            }
        }
    }
    return dep[t];
}

LL dfs(int u,LL sum){
    if(u==t) return sum;
    LL k,flow=0;
    for(int i=now[u];i&&sum>0;i=e[i].nex){
        now[u]=i;
        int v=e[i].to;
        if(e[i].w&&dep[v]==dep[u]+1){
            k=dfs(v,min(sum,e[i].w));
            if(!k){
                dep[v]=-1;
                continue;
            }
            e[i].w-=k;
            e[i^1].w+=k;
            sum-=k;
            flow+=k;
        }
    }
    return flow;
}

LL Dinic(){
    LL maxflow=0;
    while(bfs()) maxflow+=dfs(s,INF);
    return maxflow;
}

bool check(LL maxt){
    cnt=1;
    memset(head,0,sizeof(head));
    for(int i=1;i<=n;i++){
        add(s,i,ss[i]);
        add(i+n,t,pp[i]);
        for(int j=1;j<=n;j++){
            if(dist[i][j]<=maxt){
                add(i,j+n,INF);
            }
        }
    }
    return Dinic()==sums;
}

int main(){
    scanf("%d %d",&n,&m);
    memset(dist,0x3f,sizeof(dist));
    for(int i=1;i<=n;i++){
        scanf("%lld %lld",&ss[i],&pp[i]);
        sums+=ss[i];
        dist[i][i]=0LL;
    }
    
    int u,v; LL w;
    while(m--){
        scanf("%d %d %lld",&u,&v,&w);
        dist[u][v]=min(dist[u][v],w);
        dist[v][u]=min(dist[v][u],w);
    }

    //Floyed求两点间的最短路
    for(int k=1;k<=n;k++)
        for(int i=1;i<=n;i++)
            for(int j=1;j<=n;j++){
                dist[i][j]=min(dist[i][j],dist[i][k]+dist[k][j]);
            }

    //二分答案
    LL l=0,r=1e18;
    while(l<=r){
        LL mid=(l+r)/2;
        if(check(mid)){
            ans=mid;
            r=mid-1;
        }else{
            l=mid+1;
        }
    }
    printf("%lld",ans);
    return 0;
}
```

这是本蒟蒻的第一篇题解，写得不好请见谅。(๑¯ω¯๑)

---

## 作者：_qingshu_ (赞：0)

这题调 $inf$ 确实好烦阿（怒。
# 思路：

一开始没仔细看题，以为是所有奶牛的总时间最少....建了个图发现挂了。

如何使最后的到达的奶牛时间最少？直接建图跑是跑不出来的，我们无法确定现在更新的残量网络具体是那哪一批奶牛的移动时间，所以需要考虑多次建图。

如果允许的最后到达时间越长，那么可能到达雨棚的奶牛就越多。如果越短，那么到达雨棚的奶牛就会越少，满足单调性。

$n\le 200$，我们可以先用 floyd 求出全源最短路方便后续处理，时间复杂度 $\mathfrak{O}(n^3)$。

考虑二分答案，每一次我们二分出允许到达的最长时间，然后重新建图，如果有两点之间最短路小于当前 $mid$。那么两点之间建立一条流量为 $inf$ 的边，考虑朴素建图会出现多次经过边导致总长度错误，可以拆点解决这个问题。

最后把源点与每一个点的入点链接上流量等同于该田奶牛数的边，把汇点与每一个点的出点链接上流量等同于该雨棚容量的边，最后跑一下最大流判断是否所有奶牛都有棚子就好了。

# 坑点：

- 数据挺大的，记得开 long long。

- 注意二分最大值应当小于 floyd 初始最大值。

- 如果无法全部躲进牛棚，输出 $-1$。

- 记得清图。

# Code：

```cpp
#include<bits/stdc++.h>
#define inf 100000000000000000
using namespace std;
int n,m,s,t;
struct edge{
    int to,nxt;
    long long val;
}e[5200010];
long long dis[520][520];
long long head[5200010],tot=1,ine[5200010],oute[5200010];
inline void add(int u,int v,long long val){
    e[++tot].to=v;
    e[tot].nxt=head[u];
    e[tot].val=val;
    head[u]=tot;

    e[++tot].to=u;
    e[tot].nxt=head[v];
    e[tot].val=0;
    head[v]=tot;
}
long long sum,ans;
long long dep[5200010],now[5200010];
inline bool bfs(){
    queue<int>q;
    q.push(s);
    for(int i=1;i<=t;i++)dep[i]=inf;
    dep[s]=0;now[s]=head[s];
    while(!q.empty()){
        int x=q.front();q.pop();
        for(int i=head[x];i;i=e[i].nxt){
            int v=e[i].to;
            if(e[i].val&&dep[v]==inf){
                dep[v]=dep[x]+1;
                now[v]=head[v];
                q.push(v);
                if(v==t)return true;
            }
        }
    }
    return false;
}
inline long long dfs(int x,long long sum){
    if(x==t)return sum;
    long long res=0;
    for(int i=now[x];i&&sum;i=e[i].nxt){
        int v=e[i].to;now[x]=i;
        if(e[i].val&&dep[v]==dep[x]+1){
            long long k=dfs(v,min(e[i].val,sum));
            e[i].val-=k;
            e[i^1].val+=k;
            sum-=k;
            res+=k;
        }
    }
    return res;
}
inline void dinic(){
    while(bfs()){
        ans+=dfs(s,inf);
    }
}
inline bool check(long long time){
    memset(head,0,sizeof head);tot=1;ans=0;
    for(int i=1;i<=n;i++){
        add(s,i,ine[i]);
        add(i+n,t,oute[i]);
    }
    for(int i=1;i<=n;i++){
        for(int j=1;j<=n;j++){
            if(dis[i][j]<=time){
                add(i,j+n,inf);
            }
        }
    }
    dinic();
    // cout<<ans<<" "<<time<<endl;
    return (sum==ans);
}
int main(){
    cin>>n>>m;
    s=52013;t=52014;
    for(int i=1;i<=n;i++){
        for(int j=i+1;j<=n;j++){
            dis[i][j]=dis[j][i]=inf;
        }
    }
    for(long long i=1;i<=n;i++){
        cin>>ine[i]>>oute[i];
        sum+=ine[i];
    }
    for(long long i=1,u,v,w;i<=m;i++){
        cin>>u>>v>>w;
        dis[u][v]=dis[v][u]=min(dis[u][v],w);
    }
    for(int k=1;k<=n;k++){
        for(int i=1;i<=n;i++){
            for(int j=1;j<=n;j++){
                dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]);
            }
        }
    }
    long long lef=0,rig=inf-1,qans=-1;
    while(lef<=rig){
        long long mid=lef+rig>>1;
        if(check(mid)){
            rig=mid-1;
            qans=mid;
        }
        else{
            lef=mid+1;
        }
    }
    cout<<qans<<endl;
}
```

---

## 作者：mjsdnz (赞：0)

+ [原题链接](https://www.luogu.com.cn/problem/P2402)

## 题目大意

有 $n$ 块田地，第 $i$ 块田地上有 $s_{i}$ 头牛和能容纳 $p_{i}$ 头牛的牛棚，田地和田地之间有 $m$ 条无向边连接，经过每条边都需要一定的时间，求出全部牛都进入牛棚的最少时间。

## 建模

我们先想一个简单的问题，给你一个定值 $k$，让你判断在 $k$ 时间内能否让所有的牛都进入牛棚。

首先每个田地之间的最短路都可以求出来，毕竟 $n \le 200$。

下面建立最小割模型，将源点与每块田地建边，流量为田地上的牛的数量，每个田地上的牛棚向汇点连边，流量为牛棚的容量。若一个田地到另一个田地的距离小于 $k$，则一块的田地与另一块的牛棚建边，流量为无穷大（注意自己也要和自己建边）。最后跑最大流，也就是最小割，最小割割掉的边就是牛经过的边，若最小割等于牛的总数，则可行，否则不行。

举个例子：

![栗子](https://gitcode.net/mjsdnz/picture/-/raw/master/%E9%A2%98%E8%A7%A3/graph.png)

通过上面的简化问题我们可以很快发现，我们只要将 $k$ 二分即可找到全部牛都进入牛棚的最少时间。

## 代码:

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N=2e3+10;
const int M=2e5+10;
const int inf=5e18;
const int MX=2e17;
int head[N];
int now[N];
int dep[N];
int cnt=1;
struct edge{
	int u, v, c, nxt;
	edge(int u=0,int v=0,int c=0,int nxt=0):u(u),v(v),c(c),nxt(nxt){}
}e[M];
void ADD(int u,int v,int c){
	cnt++;
	e[cnt]=edge(u,v,c,head[u]);
	head[u]=cnt;
}
void add_edge(int u,int v,int c){
	ADD(u,v,c);
	ADD(v,u,0);
}
int n,m;
int s,t;
vector<pair<int,int>>g[205];
int dis[205][205];
struct Node{
	int num,dis;
	Node(int num,int dis):num(num),dis(dis){}
	bool operator<(const Node &a)const{
		return dis>a.dis;
	}
}; 
void dj(int x){
	for(int i=1;i<=n;i++) dis[x][i]=inf;
	dis[x][x]=0;
	priority_queue<Node>q;
	q.push(Node(x,dis[x][x]));
	while(q.size()){
		int u=q.top().num;
		q.pop();
		for(auto e:g[u]){
			int v=e.first;
			int val=e.second;
			if(dis[x][v]>dis[x][u]+val){
				dis[x][v]=dis[x][u]+val;
				q.push(Node(v,dis[x][v]));
			}
		}
	}
}
int a[N],b[N];
void init(){
	memset(head,0,sizeof head);
	cnt=1;
	for(int i=1;i<=n;i++) {
		add_edge(s,i,a[i]);
		add_edge(i+n,t,b[i]);
	}
}
bool bfs(){
	memset(dep,0,sizeof dep);
	memcpy(now,head,sizeof head);
	queue<int>q;
	dep[s]=1;
	q.push(s);
	while(!q.empty()){
		int u=q.front();
		q.pop();
		for(int i=head[u];i;i=e[i].nxt){
			int v=e[i].v;
			int c=e[i].c;
			if(dep[v]||!c) continue;
			dep[v]=dep[u]+1;
			q.push(v);
		}
	}
	return dep[t]!=0;
}
int dfs(int u,int t,int flow){
	if(u==t) return flow;
	int nowflow=0;
	for(int i=now[u];i&&nowflow<flow;i=e[i].nxt){
		int v=e[i].v;
		int c=e[i].c;
		now[u]=i;
		if(dep[v]!=dep[u]+1||!c)continue;
		int ff=dfs(v,t,min(c,flow-nowflow));
		if(ff) e[i].c-=ff,e[i^1].c+=ff,nowflow+=ff;
		else dep[v]=0;
	}
	return nowflow;
}
int maxflow(){
	int ans=0;
	while(bfs()){
		int nowflow;
		while((nowflow=dfs(s,t,inf))) ans+=nowflow;
	}
	return ans;
}
signed main(){
	int sum=0;
	cin>>n>>m;
	s=n*2+1,t=n*2+2;
	for(int i=1;i<=n;i++){
		cin>>a[i]>>b[i];
		sum+=a[i];
	}
	for(int i=1;i<=m;i++){
		int uu,vv,val;
		cin>>uu>>vv>>val;
		g[uu].push_back({vv,val});
		g[vv].push_back({uu,val});
	}
	for(int i=1;i<=n;i++) dj(i);
	int l=0,r=MX;
	int ans=-1;
	while(l<r){
		int mid=(l+r)>>1;
		init();
		for(int i=1;i<=n;i++){
			for(int j=1;j<=n;j++){
				if(dis[i][j]<=mid){
					add_edge(i,j+n,inf);
				}
			}
		}
		int f=maxflow();
		if(f==sum){
			ans=mid;
			r=mid;
		}
		else l=mid+1;
	}
	cout<<ans;
}
```

---

## 作者：AIskeleton (赞：0)

[博客园查看](https://www.cnblogs.com/AIskeleton/p/16318988.html)

> [P2402 奶牛隐藏](https://www.luogu.com.cn/problem/P2402)

> 有 $n$ 个点和 $m$ 条有边权无向边，对于每个点有牛的数量 $s_i$ 和牛棚容量 $p_i$。

> 求问所有牛全部进入牛棚所需的最小时间，无解输出 -1。
> $1\le n\le 200,1\le m\le 1500,1\le w\le 10^{15},1\le s_i,p_i\le 10^{16}$。

看到 $n\le 200$，可以想到用 Floyd 跑一遍全源最短路。

```cpp
int edge[N][N];
for(int i=1;i<=n;i++)
	for(int j=1;j<=n;j++)
		edge[i][j]=(i==j?0:INF);
for(int i=1,u,v,w;i<=m;i++){
	u=rd(),v=rd(),w=rd();
	edge[u][v]=min(edge[u][v],w);
	edge[v][u]=min(edge[v][u],w);
}for(int k=1;k<=n;k++)
  for(int i=1;i<=n;i++)
	for(int j=1;j<=n;j++)
	  edge[i][j]=min(edge[i][j],edge[i][k]+edge[k][j]);
```

看到求**最少时间**，考虑**二分答案**。

```cpp
while(l<=r){
	mid=(l+r)>>1;
	if(check(mid))r=mid-1,ans=mid;
	else l=mid+1;
}wr(ans?ans:-1);
```

看到**“牛进入牛棚”**这样的描述，很容易想到**二分图匹配**。

网络流的建边方法：

- 首先将每个点分成牛和牛棚两个点。
- 从源点向每个表示牛的点连一条流量为目标点的牛的数量的边。
- 从每个表示牛棚的点向汇点连一条流量为当前点牛棚容量的边。
- 如果两点之间距离小于当前的时间，就连一条流量为两点中表示牛的点的牛的数量的边。

```cpp
for(int i=1;i<=n;i++)	I(st,i,s[i]);
for(int i=1;i<=n;i++)	I(i+n,ed,p[i]);
for(int i=1;i<=n;i++)
  for(int j=1;j<=n;j++)
	if(edge[i][j]<=lim)
	  I(i,j+n,s[i]);
```
其实建边的方法就是**二分图多重最大权匹配**的板子。

建边后直接跑网络流板子即可。

几个细节点：
1. 二分答案的右边界赋值一定要小于 floyd 的边权初始极值。
1. 因为有拆点，所以数组一定要开两倍空间。
1. 注意题目中的边都是无向边。
1. 存在重边，邻接矩阵取两点之间距离最小值。
1. 不开 long long 见祖宗。

完整代码：

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N=600,M=2e5,INF=3e18;
int rd(){
	int w=0,v=1;char c=getchar();while(c<'0'||c>'9'){if(c=='-')v=-1;c=getchar();}
	while(c>='0'&&c<='9')w=(w<<1)+(w<<3)+(c&15),c=getchar();return w*v;
}void wr(int x){if(x<0)putchar('-'),x=-x;if(x>9)wr(x/10);putchar(x%10+'0');}

int fir[N],cnt=1;
struct E{int v,w,nt;}e[M];
void I(int u,int v,int w){
	e[++cnt]=(E){v,w,fir[u]};fir[u]=cnt;
	e[++cnt]=(E){u,0,fir[v]};fir[v]=cnt;
}void cl(){memset(e,0,sizeof(e));memset(fir,0,sizeof(fir));cnt=1;}

int cur[N],d[N],st,ed;
queue <int>q;
bool bfs(){
	memset(d,0,sizeof(d));
	for(int i=0;i<=ed;i++)	cur[i]=fir[i];
	q.push(st);d[st]=1;
	while(q.size()){
		int u=q.front(),V;q.pop();
		for(int i=fir[u];i;i=e[i].nt)
			if(e[i].w&&!d[V=e[i].v])
				q.push(V),d[V]=d[u]+1;
	}return d[ed];
}int dfs(int u,int fl){
	if(u==ed)return fl;int f,V,s=0;
	for(int i=cur[u];i;i=e[i].nt){
		cur[u]=i;
		if(e[i].w&&d[V=e[i].v]==d[u]+1){
			f=dfs(V,min(fl,e[i].w));
			e[i].w-=f;e[i^1].w+=f;
			s+=f;fl-=f;if(!fl)break;
		}
	}if(!s)d[u]=0;return s;
}int dinic(){int ans=0;while(bfs())ans+=dfs(st,INF);return ans;}

int n,m,ans,s[N],p[N];
int s1,s2;
int l=1,r=INF-1,mid;

int edge[N][N];
void floyd(){
	for(int k=1;k<=n;k++)
		for(int i=1;i<=n;i++)
			for(int j=1;j<=n;j++)
				edge[i][j]=min(edge[i][j],edge[i][k]+edge[k][j]);
}

bool check(int lim){
	cl();
	for(int i=1;i<=n;i++)	I(st,i,s[i]);
	for(int i=1;i<=n;i++)	I(i+n,ed,p[i]);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			if(edge[i][j]<=lim)
				I(i,j+n,s[i]);
	return (dinic()==s1)?1:0;
}

signed main(){
	n=rd(),m=rd();st=0,ed=n*2+1;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			edge[i][j]=(i==j?0:INF);
	for(int i=1;i<=n;i++){
		s[i]=rd(),p[i]=rd();
		s1+=s[i];s2+=p[i];
	}for(int i=1,u,v,w;i<=m;i++){
		u=rd(),v=rd(),w=rd();
		edge[u][v]=min(edge[u][v],w);
		edge[v][u]=min(edge[v][u],w);
	}floyd();
	if(s1>s2){wr(-1);return 0;}
	while(l<=r){
		mid=(l+r)>>1;
		if(check(mid))r=mid-1,ans=mid;
		else l=mid+1;
	}wr(ans?ans:-1);
}
```

---

## 作者：KobeWu (赞：0)

### 解题之前
第一次看到这道题已经是一个月前了，那个时候刚学会网络流模板，不怎么会建模，所以看到这道题毫无头绪，不管怎么建模都无法解决。于是，我就开始找一些很接近于模板的水题水了。
### 题目分析
根据题目描述，我们可以知道，题目给你一个$n$个点$m$条边的无向图，每个节点有一定数量的奶牛和一个可以容纳一定数量奶牛的牛棚，求让每个奶牛都到达牛棚的最少时间，其中一头奶牛走一个单位的距离需要花费一个单位的时间，并且所有奶牛同时开始行动（混乱的奶牛们啊）。

首先，考虑直接建模。那么先来分析一下题目的限制。$First, \ $每个牛棚都只能容纳一定数量的奶牛，这显然是一个限制. $Second, \ $每个节点中只有一定数量的奶牛，这显然也是一个限制. $Third, \ $？？似乎找不到其他的条件了。

对于这两个限制，我们考虑设置一个超级源$S$和一个超级汇$T$，然后建两层点，第一层表示奶牛，第二层表示牛棚，再从$S$向第一层点连边，边权为对应节点的奶牛数量，从第二层点向$T$连边，边权为对应节点的牛棚能容纳奶牛的数量。那么，第一层点和第二层点之间呢？在这个残破不堪的半成品网络图中跑什么网络流能得到答案呢？

这种思路貌似行不通。

于是，重新审题。其实，如果我们直接开始建模，那一定是网络流模板做得太多了，而且我们还忽视了一个重要的条件。我们要求的是什么？
>	所有奶牛全都躲进牛棚所用的最少时间

而且题目还好心地补充了一句
>	即最后一头奶牛最少要花多久才能躲进牛棚

这不是相当于让最大值最小吗？

二分答案！

那如何判定呢？借鉴一下之前我们直接建模时的思路，从$S$向第一层点连边，边权为对应节点的奶牛数量，从第二层点向$T$连边，边权为对应节点的牛棚能容纳的奶牛数量。对于第一层点和第二层点间的边，我们可以枚举每对点{ $a,b$ }，如果他们之间的最短距离小于等于当前的$mid$值，则说明在$a$（或是$b$）点的奶牛可以在限定时间内走到b（或是a）点的牛棚，也就是说我们需要从第一层中的a（或是b）点向第二层中的a（或是b）点连边，边权为$\infty$。至于任意两点间的最短路长度，跑$Floyd$预处理出来就行了。

基于这个网络图，我们可以发现，从$S$到$T$的最大流就是能在当前$mid$的时间内成功躲雨的最大奶牛数量。所以，如果$S$到$T$的最大流等于奶牛总数，那么当前的$mid$就可能成为答案。由此即可判定。

最后分析一下复杂度：

空间复杂度：主要的空间用于存我们建的网络图，从$S$向第一层点连了$n$条边，从第二层点向$T$连了$n$条边，第一层点和第二层点之间最多会连$n^2$条边。一看$n \leq 200$，空间显然不成问题。

时间复杂度：首先，$Floyd$是$\Theta(n^3)$的。其次，题目没有给边权的范围，我们大胆猜测最长的最短路的长度不会超过$int$的范围
~~（毕竟我用来存最短路长度的$dis$数组是$int$类型的都能过）~~。所以二分答案的$log$不会超过$31$。至于网络流，考虑到网络图是一个二分图，而且总共$2n+2$个节点、最多$n^2+2n$条边，那么总的时间复杂度最坏为$\Theta(n^3+\log_2(2^{31})\times n^{2.5})$，毫无压力。

以下是我的代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define MAXN 210
#define MAXM 1510
#define MXN 410
#define MXM 40410
#define INF 2147473600
#define Min(a,b) ((a)<(b)?(a):(b))
#define int long long
int N,M,sum,S,T;
struct Node
{
	int num,val;
}a[MAXN];
int pre_hd[MAXN],pre_ed[MAXM<<1],pre_val[MAXN<<1],pre_nxt[MAXM<<1],pre_tot;
int dis[MAXN][MAXN];
int hd[MXN],ed[MXM<<1],val[MXM<<1],nxt[MXM<<1],tot;
int curArc[MXN],dep[MXN]; bool inq[MXN]; queue <int> Q;
inline int rd()
{
	int ret=0,f_f=1; char c=getchar();
	while(c<'0' || c>'9') {if(c=='-') f_f=-1; c=getchar();}
	while(c>='0' && c<='9') ret=(ret<<1)+(ret<<3)+c-'0',c=getchar();
	return ret*f_f;
}
inline void pre_AddEdge(int u,int v,int w) {pre_ed[++pre_tot]=v,pre_val[pre_tot]=w,pre_nxt[pre_tot]=pre_hd[u],pre_hd[u]=pre_tot;}
inline void Floyd()
{
	for (int k=1;k<=N;k++)
		for (int i=1;i<=N;i++)
			for (int j=1;j<=N;j++)
				if (dis[i][k] != -1 && dis[k][j] != -1 && (dis[i][j] == -1 || dis[i][j] > dis[i][k] + dis[k][j]))
					dis[i][j]=dis[i][k]+dis[k][j];
}
inline void AddEdge(int u,int v,int w) {ed[++tot]=v,val[tot]=w,nxt[tot]=hd[u],hd[u]=tot;}
inline void Build(int ky)
{
	memset(hd,-1,sizeof(hd)),tot=1;
	for (register int i=1;i<=N;i++)
		for (register int j=1;j<=N;j++)
			if (dis[i][j] != -1 && dis[i][j] <= ky)
				AddEdge(i,j+N,INF),AddEdge(j+N,i,0);
	S=0,T=N+N+1;
	for (register int i=1;i<=N;i++)
		AddEdge(S,i,a[i].num),AddEdge(i,S,0),AddEdge(i+N,T,a[i].val),AddEdge(T,i+N,0);
}
inline bool Bfs()
{
	for (register int i=0;i<=N+N+1;i++)
		curArc[i]=hd[i],dep[i]=INF,inq[i]=false;
	dep[S]=0,inq[S]=true;
	while (!Q.empty()) Q.pop(); Q.push(S);
	while (!Q.empty())
	{
		register int u=Q.front(); Q.pop(),inq[u]=false;
		for (register int p=hd[u];p!=-1;p=nxt[p])
		{
			register int v=ed[p];
			if (val[p] > 0 && dep[v] > dep[u] + 1)
			{
				dep[v]=dep[u]+1;
				if (!inq[v]) inq[v]=true,Q.push(v);
			}
		}
	}
	return dep[T] != INF;
}
inline int Dfs(int u,int Flow)
{
	if (u == T) return Flow;
	int curFlow,tot=0;
	for (register int p=curArc[u];p!=-1;p=nxt[p])
	{
		curArc[u]=p;
		register int v=ed[p];
		if (val[p] > 0 && dep[v] == dep[u] + 1)
		{
			curFlow=Dfs(v,min(Flow,val[p]));
			if (curFlow != 0)
			{
				val[p]-=curFlow;
				val[p^1]+=curFlow;
				Flow-=curFlow,tot+=curFlow;
				if (Flow <= 0) break;
			}
		}
	}
	return tot;
}
inline int Dinic()
{
	register int maxFlow=0;
	while (Bfs())
	{
		register int Flow=Dfs(S,INF);
		while (Flow != 0)
		{
			maxFlow+=Flow;
			Flow=Dfs(S,INF);
		}
	}
	return maxFlow;
}
inline bool check(int ky)
{
	Build(ky);
	return Dinic() == sum;
}
signed main()
{
	N=rd(),M=rd(),sum=0;
	for (register int i=1;i<=N;i++)
		a[i].num=rd(),a[i].val=rd(),sum+=a[i].num;
	memset(pre_hd,-1,sizeof(pre_hd)),pre_tot=0;
	memset(dis,-1,sizeof(dis));
	for (register int i=1;i<=N;i++) dis[i][i]=0;
	for (register int i=1,u,v,w;i<=M;i++)
	{
		u=rd(),v=rd(),w=rd();
		if (dis[u][v] == -1 || dis[u][v] > w) dis[u][v]=dis[v][u]=w;
		pre_AddEdge(u,v,w),pre_AddEdge(v,u,w);
	}
	Floyd();
	register int l=0,r=0,mid,ans=-1;
	for (register int i=1;i<=N;i++)
		for (register int j=1;j<=N;j++)
			r=max(r,dis[i][j]);
	while (l <= r)
	{
		mid=(l+r)>>1;
		if (check(mid))
			ans=mid,r=mid-1;
		else l=mid+1;
	}
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：happybob (赞：0)

首先可以发现可以二分答案。接着考虑如何 `check`。

假设二分当前距离最大值为 $x$，显然对于点对 $(i,j)$，当 $dis(i,j) \leq x$ 时，$i$ 的所有奶牛可以到 $j$ 点避雨。可以最短路预处理 $dis$。然而题目限制仍然难以下手。

考虑二分图模型，每个点分成两个点，一个是这个点的奶牛，即 $s_i$，另一个是牛棚，即 $p_i$。

源点 $S$ 向每个奶牛点 $i$ 连边，容量为 $s_i$。每个牛棚点向汇点 $T$ 连边，容量为 $p_i$。这保证了每个奶牛点最多只出去 $s_i$，每个牛棚最多只承受 $p_i$。

对于上文提到的点对 $(i,j)$，我们从 $i$ 的奶牛点连一条边向 $j$ 的牛棚点，容量为 $+\infty$。这意味着每个奶牛点可以去某个牛棚的牛数不限。不过由于我们已经限定了 $s_i$ 的容量，所以是正确的。

跑一遍最大流，当流量为 $\sum \limits_{i=1}^n s_i$ 时，表示存在方案使得所有牛到棚子且满足题目要求。否则不存在。

```cpp
#include <bits/stdc++.h>
using namespace std;

#define int long long

const int N = 2e5 + 5, M = 205;

int dis[M][M], sums = 0;
vector<pair<int, int> > G[N];
int e[N], h[N], c[N], ne[N], idx;
int s[N], p[N], n, m, d[N], cur[N];
bool vis[N];
int S = 0, T;

struct Node
{
	int u, d;
	Node(int _u, int _d): u(_u), d(_d){}
	bool operator<(const Node& g) const
	{
		return d > g.d;
	}
};

int dijkstra(int s)
{
	for (int i = 1; i <= n; i++) vis[i] = 0;
	dis[s][s] = 0;
	priority_queue<Node> q;
	q.push(Node(s, 0));
	while (q.size())
	{
		int u = q.top().u;
		q.pop();
		if (vis[u]) continue;
		vis[u] = 1;
		for (auto j : G[u])
		{
			if (dis[s][j.first] > dis[s][u] + j.second)
			{
				dis[s][j.first] = dis[s][u] + j.second;
				q.push(Node(j.first, dis[s][j.first]));
			}
		}
	}
}

inline void add(int u, int v, int w)
{
	e[idx] = v, c[idx] = w, ne[idx] = h[u], h[u] = idx++;
}

inline void adde(int u, int v, int w)
{
	add(u, v, w);
	add(v, u, 0);
}

inline bool bfs()
{
	queue<int> q;
	for (int i = 0; i <= T; i++)
	{
		d[i] = -1, cur[i] = 0;
	}
	d[S] = 0, cur[S] = h[S];
	q.push(S);
	while (q.size())
	{
		int u = q.front();
		q.pop();
		for (int i = h[u]; ~i; i = ne[i])
		{
			int j = e[i];
			if (c[i] > 0 && d[j] == -1)
			{
				d[j] = d[u] + 1;
				cur[j] = h[j];
				if (j == T) return 1;
				q.push(j);
			}
		}
	}
	return 0;
}

inline int dfs(int u, int lim)
{
	if (u == T) return lim;
	int sum = 0;
	for (int i = cur[u]; ~i && sum < lim; i = ne[i])
	{
		cur[u] = i;
		int j = e[i];
		if (d[j] == d[u] + 1 && c[i] > 0)
		{
			int p = dfs(j, min(c[i], lim - sum));
			if (!p) d[j] = -1;
			sum += p;
			c[i] -= p;
			c[i ^ 1] += p;
		}
	}
	return sum;
}

int dinic()
{
	int res = 0;
	while (bfs())
	{
		int p;
		while (p = dfs(S, (int)9e18)) res += p;
	}
	return res;
}

inline bool check(int x)
{
	T = 2 * n + 1;
	for (int i = 0; i <= 605; i++)
	{
		h[i] = -1;
	}
	idx = 0;
	for (int i = 1; i <= n; i++)
	{
		adde(S, i, s[i]);
		for (int j = 1; j <= n; j++)
		{
			if (dis[i][j] <= x)
			{
				adde(i, j + n, (int)9e18);
			}
		}
		adde(i + n, T, p[i]);
	}
	return dinic() == sums;
}

signed main()
{
	ios::sync_with_stdio(0), cin.tie(nullptr), cout.tie(nullptr);
	cin >> n >> m;
	for (int i = 1; i <= n; i++) cin >> s[i] >> p[i], sums += s[i];
	for (int i = 1; i <= n; i++)
	{
		for (int j = 1; j <= n; j++)
		{
			dis[i][j] = 9e18;
		}
	}
	for (int i = 1; i <= m; i++)
	{
		int u, v, w;
		cin >> u >> v >> w;
		G[u].emplace_back(make_pair(v, w));
		G[v].emplace_back(make_pair(u, w));
	}
	for (int i = 1; i <= n; i++) dijkstra(i);
	int l = 0, r = (int)2e18, res = -1;
	while (l <= r)
	{
		int mid = l + ((r - l) >> 1);
		if (check(mid))
		{
			res = mid;
			r = mid - 1;
		}
		else l = mid + 1;
	}
	cout << res << "\n";
	return 0;
}
```


---


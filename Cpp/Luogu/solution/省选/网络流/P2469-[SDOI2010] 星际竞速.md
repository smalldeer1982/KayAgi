# [SDOI2010] 星际竞速

## 题目描述

10 年一度的银河系赛车大赛又要开始了。作为全银河最盛大的活动之一，夺得这个项目的冠军无疑是很多人的梦想，来自杰森座 $\alpha$ 星的悠悠也是其中之一。

赛车大赛的赛场由 $N$ 颗行星和 $M$ 条双向星际航路构成，其中每颗行星都有一个不同的引力值。大赛要求车手们从一颗与这 $N$ 颗行星之间没有任何航路的天体出发，访问这 $N$ 颗行星每颗恰好一次，首先完成这一目标的人获得胜利。

由于赛制非常开放，很多人驾驶着千奇百怪的自制赛车来参赛。这次悠悠驾驶的赛车名为超能电驴，这是一部凝聚了全银河最尖端科技结晶的梦幻赛车。作为最高科技的产物，超能电驴有两种移动模式：高速航行模式和能力爆发模式。在高速航行模式下，超能电驴会展开反物质引擎，以数倍于光速的速度沿星际航路高速航行。在能力爆发模式下，超能电驴脱离时空的束缚，使用超能力进行空间跳跃——在经过一段时间的定位之后，它能瞬间移动到任意一个行星。

天不遂人愿，在比赛的前一天，超能电驴在一场离子风暴中不幸受损，机能出现了一些障碍：在使用高速航行模式的时候，只能由每个星球飞往引力比它大的星球，否则赛车就会发生爆炸。

尽管心爱的赛车出了问题，但是悠悠仍然坚信自己可以取得胜利。他找到了全银河最聪明的贤者——你，请你为他安排一条比赛的方案，使得他能够用最少的时间完成比赛。

## 说明/提示

样例一说明：先使用能力爆发模式到行星 $1$，花费时间 $1$。

然后切换到高速航行模式，航行到行星 $2$，花费时间 $10$。

之后继续航行到行星 $3$ 完成比赛，花费时间 $1$。

虽然看起来从行星 $1$ 到行星 $3$ 再到行星 $2$ 更优，但我们却不能那样做，因为那会导致超能电驴爆炸。

【数据规模和约定】

对于 $30\%$ 的数据 $N\leq 20$，$M\leq 50$；

对于 $70\%$ 的数据 $N\leq 200$，$M\leq 4\times 10^3$；

对于 $100\%$ 的数据 $N\leq 800$，$M\leq 1.5\times 10^4$。

输入数据中的任何数都在 $1 \sim 10^6$ 之间。

输入数据保证任意两颗行星之间至多存在一条航道，且不会存在某颗行星到自己的航道。

## 样例 #1

### 输入

```
3 3
1 100 100
2 1 10
1 3 1
2 3 1```

### 输出

```
12```

## 样例 #2

### 输入

```
3 3
1 2 3
1 2 100
1 3 100
2 3 100```

### 输出

```
6```

## 样例 #3

### 输入

```
4 5
100 1000 10 100
1 2 100
2 3 100
4 3 100
1 3 20
2 4 20```

### 输出

```
230```

# 题解

## 作者：George1123 (赞：64)

**广告：[blog](https://www.luogu.com.cn/blog/Wendigo/)**

[P2469 【\[SDOI2010\]星际竞速】](https://www.luogu.com.cn/problem/P2469)

### 此题算法：费用流

>这题难度占洛谷网络流题前$10\%$——$Wendigo$。

拿到这题时，思路真是多样，可惜**全是错的**，如下:

**1.$s\to 1\sim  n$ 流量 $1$ ，$1\sim n\to t$ 流量 $1$ ，中间连流量 $1$ 费用 $w_i$ 的路径（小编号连大编号），每个点（包括 $s$ ）到非自己的点 $i$ 连流量 $1$ 费用 $a_i$ 的边。**

>$BUG$：一条路径的费用（长度）会被算多遍。

**2.$s\to mid$ 流量 $1$ ，$mid\to 1_x\sim n_x$ 流量 $1$ ，$1_y\sim n_y\to t$ 流量 $1$ ，$i_x\to i_y$ 流量 $1$ 费用 $-a_i$ ，中间连流量 $1$ 费用 $w_i$ 的路径（小编号连大编号），到非自己的点 $i$ 连流量 $1$ 费用 $a_i$ 的边。**

>$BUG$:费用流算法跑不了有负权边的图。

**正解：**

想象有 $n+1$ 个人接力跑 ，分别在点 $s$ 和 $1\sim n$ 上 ，开始时接力棒在 $s$ 那个人手上。

这时候他拿着接力棒开始跑，到达某个星球后停止，把接力棒交给该星球上的选手，并打卡结束比赛。

该选手又出发，循环此过程。每个星球只可以打卡一次，必须打卡。路上走过的路程相当于费用。

最后的最大流最小费用就是答案，而原问题与此等效。

![jlp.jpg](https://i.loli.net/2020/01/07/N3zTUKgpy1XfE8O.jpg)

**连边：拆 $i$ 点为 $i_x$ 和 $i_y$**

1. $s\to 1_x\sim n_x$ 流量 $1$ ，费用 $0$（相当于星球上的等待者） 。

2. $s\to 1_y\sim n_y$ 流量 $1$ ，费用 $a_i$（相当于能力爆发模式）。

3. $1_y\sim n_y\to t$ 流量 $1$ ，费用 $0$（相当于打卡）。

4. $u_x\to v_y$ 流量 $1$ ，费用 $w$（相当于星际航路）。


## 以下是代码 $+$ 注释

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=2e3+10;
const int M=2e6+10;
const int inf=1e8;
int d(){int x; scanf("%d",&x); return x;}
int n,m,p,s,t,a[N],fans,cans; 
struct edge{
	int adj,nex,fw,r;
}e[M];
int g[N],top=1;
void add(int x,int y,int z,int w){
	e[++top]=(edge){y,g[x],z,w};
	g[x]=top;
}
void Add(int x,int y,int z,int w){
	// printf("%d-%d %d %d\n",x,y,z,w);
	add(x,y,z,w),add(y,x,0,-w);
}
int dep[N],cur[N];
bool vis[N];
queue<int> Q;
bool spfa(){ //模板就不用说了
	for(int i=1;i<=p;i++)
		vis[i]=0,dep[i]=inf,cur[i]=g[i];
	Q.push(s),vis[s]=1,dep[s]=0;
	while(Q.size()){
		int x=Q.front(); Q.pop();
		vis[x]=0;
		for(int i=g[x];i;i=e[i].nex){
			int to=e[i].adj,d=e[i].r;
			if(e[i].fw&&dep[to]>dep[x]+d){
				dep[to]=dep[x]+d;
				if(!vis[to]){
					vis[to]=1;
					Q.push(to);
				}
			}
		}
	}
	return dep[t]!=inf;
}
int dfs(int x,int F){
	if(!F||x==t)
		return F;
	int flow=0,f;
	vis[x]=1;
	for(int i=cur[x];i;i=e[i].nex){
		int to=e[i].adj; cur[x]=i;
		if(!vis[to]&&dep[x]+e[i].r==dep[to]&&
		(f=dfs(to,min(F,e[i].fw)))>0){
			e[i].fw-=f;
			e[i^1].fw+=f;
			flow+=f,F-=f;
			if(!F){
				vis[x]=0;
				break;
			} 
		}
	}
	return flow;
}
int main(){
	n=d(),m=d(),p=t=2*n+2,s=t-1;
	for(int i=1,x;i<=n;i++){ //如上说明连边
		a[i]=d(); Add(i+n,t,1,0); 
		Add(s,i,1,0),Add(s,i+n,1,a[i]);
	}
	for(int i=1;i<=m;i++){
		int x=d(),y=d(),z=d();
		if(x>y) swap(x,y);
		if(z<a[y]) Add(x,y+n,1,z);
	}
	while(spfa()){ //跑最小费用最大流。
		int D=dfs(s,inf);
		fans+=D,cans+=D*dep[t];
	}
	printf("%d\n",cans);
	return 0;
}
```
网络流题重在思考。

**写题解不易，快为博主点个赞吧。**

谢谢大家! !




---

## 作者：xyz32768 (赞：31)

回顾最小路径覆盖问题的解法：

先将$n$个点拆点为$i$和$i'$。然后由源点向所有的$i$点连一条容量为$1$的边，再由所有的$i'$点向汇点连一条容量为$1$的边，对于每条边$u->v$，由$u$向$v'$连一条容量为$1$的边，跑一遍最大流后，$n$减去最大流就是最小路径覆盖。

为什么可以这样做呢？可以发现，上面其实是一个二分图，最大流实际上就是最大匹配数。在这里可以发现，匹配中每连一条边，路径的数量就减$1$，所以得出$\mbox{最小路径覆盖}=n-\mbox{最大匹配数}$。

可以把上面的思想运用于此题，用最小费用最大流求解此题。

还是一样，先拆点。

1、由源点向所有的$i$点连一条容量为$1$费用为$0$的边。

2、由所有的$i'$点向汇点连一条容量为$1$费用为$0$的边。

3、对于每条边$u->v$(假设$u<v$)，由$u$向$v'$连一条容量为$1$费用为通过此条边的耗时的边。

4、由源点向所有的$i'$点连一条容量为$1$费用为$Ai$的边。

跑一遍最小费用最大流即为答案。

代码：

```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
inline int read() {
    int res = 0; bool bo = 0; char c;
    while (((c = getchar()) < '0' || c > '9') && c != '-');
    if (c == '-') bo = 1; else res = c - 48;
    while ((c = getchar()) >= '0' && c <= '9')
        res = (res << 3) + (res << 1) + (c - 48);
    return bo ? ~res + 1 : res;
}
const int N = 3005, M = 6e4 + 5, INF = 0x3f3f3f3f;
int n, m, ecnt = 1, nxt[M], adj[N], go[M], cap[M], cost[M], S, T, dis[N],
que[M], len, a[N], Ans;
bool vis[N], walk[N];
void add_edge(int u, int v, int w, int x) {
    nxt[++ecnt] = adj[u]; adj[u] = ecnt; go[ecnt] = v;
    cap[ecnt] = w; cost[ecnt] = x;
    nxt[++ecnt] = adj[v]; adj[v] = ecnt; go[ecnt] = u;
    cap[ecnt] = 0; cost[ecnt] = -x;
}
bool spfa() {
    int i; que[len = 1] = S;
    memset(dis, INF, sizeof(dis)); dis[S] = 0;
    memset(walk, 0, sizeof(walk));
    for (i = 1; i <= len; i++) {
        int u = que[i]; vis[u] = 0;
        for (int e = adj[u], v; e; e = nxt[e])
            if (cap[e] > 0 && dis[u] + cost[e] < dis[v = go[e]]) {
                dis[v] = dis[u] + cost[e];
                if (!vis[v]) vis[que[++len] = v] = 1;
            }
    }
    return dis[T] < INF;
}
int dfs(int u, int flow) {
    if (u == T) return Ans += dis[T] * flow, flow;
    int res = 0, delta; walk[u] = 1;
    for (int e = adj[u], v; e; e = nxt[e])
        if (cap[e] > 0 && !walk[v = go[e]] && dis[u] + cost[e] == dis[v]) {
            delta = dfs(v, min(cap[e], flow - res));
            if (delta) {
                cap[e] -= delta; cap[e ^ 1] += delta;
                res += delta; if (res == flow) break; 
            }
        }
    return res;
}
int solve() {
    Ans = 0;
    while (spfa()) dfs(S, INF);
    return Ans;
}
int main() {
    int i, x, y, z; n = read(); m = read(); S = 1; T = (n << 1) + 2;
    for (i = 1; i <= n; i++) a[i] = read();
    for (i = 1; i <= m; i++) {
        x = read(); y = read(); z = read();
        if (x > y) swap(x, y);
        if (z < a[y]) add_edge(x + 1, y + n + 1, 1, z);
    }
    for (i = 1; i <= n; i++) add_edge(S, i + 1, 1, 0),
        add_edge(i + n + 1, T, 1, 0), add_edge(S, i + n + 1, 1, a[i]);
    printf("%d\n", solve());
    return 0;
}
```

---

## 作者：liuzhangfeiabc (赞：17)

说一个与众不同的建图法。

首先我们假设所有的点都是直接跳跃过去的，此时代价是sigma ai。

然后我们考虑走图上的一条边意味着什么？

我们要付出边权的代价，但同时**终点就不需要通过跳跃到达了**，因此会省下终点点权的代价。

再考虑原始的最小路径覆盖，每条匹配边对应原图上一条选中的边。

而在本问题中，每一对匹配的终点的点权是会省下的。

所以我们可以这样建图：

每个点拆成两个点i和i'，s向i连边，容量1费用0，i'向t连边，容量1费用-ai，对于原图上的一条边(u,v)，u向v'连边，容量1费用为边权。

此时我们只需要用点权和减去这张图的**最小费用流**(不是最小费用最大流，即当汇点的dis>=0时直接退出)即可。

亲测跑得比其他建图法略快一些。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define gc getchar()
#define pc putchar
#define li long long
inline li read(){
    li x = 0,y = 0,c = gc;
    while(!isdigit(c)) y = c,c = gc;
    while(isdigit(c)) x = (x << 1) + (x << 3) + (c ^ '0'),c = gc;
    return y == '-' ? -x : x;
}
inline void print(li q){
    if(q < 0) pc('-'),q = -q;
    if(q >= 10) print(q / 10);
    pc(q % 10 + '0');
}
int n,m,a[2010],s,g,h,t,q[200010];
struct edge{
    int to,nxt,val,cst;
}e[50010];
int cnt = 1,fir[2010],dq[2010],dis[2010],ans;
bool inq[2010];
inline void ins(int u,int v,int w,int x){
    e[++cnt].to = v;e[cnt].nxt = fir[u];fir[u] = cnt;e[cnt].val = w;e[cnt].cst = x;
    e[++cnt].to = u;e[cnt].nxt = fir[v];fir[v] = cnt;e[cnt].val = 0;e[cnt].cst = -x;
}
#define inf 987654321
bool bfs(){
    int i,j;
    h = t = 0;
    for(i = 1;i <= g;++i) dis[i] = inf,inq[i] = 0;
    dis[s] = 0;q[++t] = s;inq[s] = 1;
    while(h < t){
        j = q[++h];inq[j] = 0;
        for(i = fir[j];i;i = e[i].nxt) if(e[i].val > 0){
            if(dis[e[i].to] > dis[j] + e[i].cst){
                dis[e[i].to] = dis[j] + e[i].cst;
                if(!inq[e[i].to]){
                    inq[e[i].to] = 1;
                    q[++t] = e[i].to;
                }
            }
        }
    }
    return dis[g] < 0;
}
bool vis[2010];
int dfs(int q,int fl){
    if(q == g) return fl;
    vis[q] = 1;
    int as = 0,tp;
    for(int &i = dq[q];i;i = e[i].nxt) if(e[i].val > 0 && !vis[e[i].to] && dis[e[i].to] == dis[q] + e[i].cst){
        tp = dfs(e[i].to,min(fl,e[i].val));
        fl -= tp;as += tp;
        e[i].val -= tp;e[i ^ 1].val += tp;
        if(!fl){
            vis[q] = 0;return as;
        }
    }
    return as;
}
int wk(){
    int as = 0,tp;
    while(bfs()){
        for(int i = 1;i <= g;++i) dq[i] = fir[i],vis[i] = 0;
        while((tp = dfs(s,inf)) != 0) as += dis[g] * tp;
    }
    return as;
}
int main(){
    int i,u,v,w;
    n = read();m = read();
    for(i = 1;i <= n;++i) a[i] = read(),ans += a[i];
    s = n * 2 + 1;g = n * 2 + 2;
    for(i = 1;i <= n;++i) ins(s,i,1,0),ins(i + n,g,1,-a[i]);
    for(i = 1;i <= m;++i){
        u = read();v = read();w = read();
        if(u > v) swap(u,v);
        ins(u,v + n,1,w);
    }
    print(ans + wk());
    return 0;
}
```

---

## 作者：司马智泽 (赞：9)

上下界费用流赛高！！！

最大的好处是不用脑子就能想到23333

但是时空都大了不少

感谢出题人给了2s，因为我最慢点跑了1s多23333

首先要拆点，把一个点拆成两个i1和i2，源点连i1，费用为跳跃的费用；i2连汇点，费用为0；i1连i2，上下界都为1；对于边i->j，i2连j1，费用为航行费用。

最后跑个模板

```
//lgp2469
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<queue>
using namespace std;
const int inf=0x3f3f3f3f;
const int maxn=800+9;
const int maxm=15000+9;

int n,m,s,t,S,T;
struct data{
	int to,next,val,cost;
}edge[maxm<<2];
int cnte,head[maxn<<1];
void addedge(int a,int b,int c,int d){
	edge[cnte].to=b;
	edge[cnte].val=c;
	edge[cnte].cost=d;
	edge[cnte].next=head[a];
	head[a]=cnte++;
}

queue<int> Q;
bool inif[maxn<<1];
int cost[maxn<<1],flow[maxn<<1],pre[maxn<<1];
int bfs(){
	while(!Q.empty()) Q.pop();
	memset(inif,false,sizeof(inif));
	memset(cost,0x3f,sizeof(cost));
	cost[S]=0;
	flow[S]=inf;
	Q.push(S);
	inif[S]=true;
	while(!Q.empty()){
		int now=Q.front();Q.pop();
		inif[now]=false;
		for(int i=head[now];i!=-1;i=edge[i].next){
			if(edge[i].val==0) continue;
			int to=edge[i].to;
			if(cost[to]>cost[now]+edge[i].cost){
				cost[to]=cost[now]+edge[i].cost;
				flow[to]=min(flow[now],edge[i].val);
				pre[to]=i;
				if(!inif[to]){
					Q.push(to);
					inif[to]=true;
				}
			}
		}
	}
	if(cost[T]==inf) return -1;
	int alpha=flow[T],p=T;
	while(p!=S){
		edge[pre[p]].val-=alpha;
		edge[pre[p]^1].val+=alpha;
		p=edge[pre[p]^1].to;
	}
	return cost[T]*alpha;
}

int main(){
	memset(head,-1,sizeof(head));
	scanf("%d %d",&n,&m);
	s=2*n+1,t=2*n+2;
	S=2*n+3,T=2*n+4;
	addedge(t,s,inf,0),addedge(s,t,0,0);
	for(int i=1;i<=n;i++){
		int in;scanf("%d",&in);
		addedge(s,2*i-1,1,in),addedge(2*i-1,s,0,-in);
		addedge(2*i,t,1,0),addedge(t,2*i,0,0);
		addedge(S,2*i,1,0),addedge(2*i,S,0,0);
		addedge(2*i-1,T,1,0),addedge(T,2*i-1,0,0);
	}
	for(int i=1;i<=m;i++){
		int a,b,d;scanf("%d %d %d",&a,&b,&d);
		if(a>b) swap(a,b);
		addedge(2*a,2*b-1,1,d),addedge(2*b-1,2*a,0,-d);
	}
	int ans=0;
	while(1){
		int ret=bfs();
		if(ret==-1) break;
		ans+=ret;
	}
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：AubRain (赞：5)

## 最小代价路径覆盖

题意：给一张 **DAG** ,边有边权，从每个点出发有点权（途中经过节点没有点权的代价）。求最小代价使得每个点都被经过。

**费用流。**

首先令答案 $=\sum$ 点权，代表每个点自己构成一条路径（不经过边）。

建图，把每个点拆成左部点A和右部点B，如果在原图上有边 $x->y$ ,就从 $xA$ 向连一条 $yB$ 连一条流量为 $1$ 费用为**(边权-y点权) ** 的边，代表可以走这条边，使得 $x$ 和 $y$ 处于同一条路径上，就会消去 $y$ 点权的代价，加上边的代价。

然后最小费用最大流即可。如果最短路为负才更新答案，否则不更新。

```cpp
#include<bits/stdc++.h>
#define N 2005
#define M 50005
#define inf 0x3f3f3f3f
using namespace std;

inline void rd(int &x){
    x=0;char ch=0;int w=0;
    while(!isdigit(ch)) ch=getchar(),w|=ch=='-';
    while( isdigit(ch)) x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
    x=w?-x:x;
}

int n,m,s,t,ans;
int head[N],cnt=1;
int mn[N],d[N],a[N],pre[N],v[N];
struct nd{int nxt,to,v,c;}e[M];
#define For(x) for(int y,i=head[x];(y=e[i].to);i=e[i].nxt)

inline void add(int x,int y,int v,int c){
    e[++cnt]=(nd){head[x],y,v, c};head[x]=cnt;
    e[++cnt]=(nd){head[y],x,0,-c};head[y]=cnt;
}

bool SPFA()
{
    memset(d,0x3f,sizeof d);
    queue<int> q;q.push(s);d[s]=0;mn[s]=inf;
    while(!q.empty()){
        int x=q.front();q.pop();v[x]=0;
        For(x) if(e[i].v&&d[y]>d[x]+e[i].c)
        {
            pre[y]=i; d[y]=d[x]+e[i].c;
            mn[y]=min(mn[x],e[i].v);
            if(!v[y]) v[y]=1,q.push(y);
        }
    }
    return d[t]!=inf;
}
void up()
{
    if(d[t]<0) ans+=d[t]*mn[t];
    for(int i,x=t;x!=s;x=e[i^1].to)
        i=pre[x],e[i].v-=mn[t],e[i^1].v+=mn[t];
}
void build()
{
    s=N-1;t=N-2;
    for(int i=1;i<=n;i++)
        rd(a[i]),ans+=a[i],add(s,i,1,0);
    for(int x,y,c,i=1;i<=m;i++){
        rd(x),rd(y),rd(c);
        if(x>y) swap(x,y);
        add(x,y+n,1,c-a[y]);
    }
    for(int i=1;i<=n;i++)
        add(i+n,t,1,0);
}
signed main(){
    rd(n);rd(m);build();
    while(SPFA()) up();
    cout<<ans;
}
```

---

## 作者：revenger (赞：5)

这道题一看是个图论题//废话图都建好了能不是图论题吗

再经过分析发现不能跑最短路，因为要求是经过每个点一次。

所以这道题应该是一道网络流的题目。

对于经过每个点一次，和最小路径覆盖比较相似，但是每条边都有一个边权。

所以答案就是最小费用最大流。

思路和最小路径覆盖类似，先进行拆点，把每个点u拆成u和u‘。

对于跳跃模式【忘了叫什么模式了】就从源点往u'连一条流量为1，费用为边权的边。

对于星球间的航道(u,v)【假设u<v】就从u往v'连一条流量为1，费用为边权的边。

从源点往每一个点u连一条流量为1，费用为0的边，从每个点u’往汇点连一条流量为1，费用为0的边。

这样保证每个点都能被经过。流量为1保证了每个点最多被经过一次。

然后跑一遍最小费用最大流，输出费用即可。

因为不会用dij的费用流//听说跑的挺快？

于是就用了基础的spfa跑费用流。代码：

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<queue>
using namespace std;
int head[1605],nxt[1000005],point[1000005],remain[1000005],w[1000005],sum;
int dis[1605],exist[1605],lastedge[1605];
int n,m,a,b,c;
#define min(a,b) a<b?a:b
const int inf=1e9+7;
queue<int>q;
void add(int x,int y,int flow,int cost)
{
    ++sum;nxt[sum]=head[x];head[x]=sum;point[sum]=y;remain[sum]=flow;w[sum]=cost;
    ++sum;nxt[sum]=head[y];head[y]=sum;point[sum]=x;remain[sum]=0;w[sum]=-cost; 
}
int addflow(int s,int t)
{
    int now=t,flow=inf;
    while(now!=s)
    {
        flow=min(flow,remain[lastedge[now]]);
        now=point[lastedge[now]^1];
    }
    now=t;
    while(now!=s)
    {
        remain[lastedge[now]]-=flow;
        remain[lastedge[now]^1]+=flow;
        now=point[lastedge[now]^1];
    }
    return flow;
}
bool spfa(int s,int t,int &flow,int &cost)
{
    memset(dis,0x7f,sizeof(dis));
    dis[s]=0;
    exist[s]=1;
    q.push(s);
    while(!q.empty())
    {
        int now=q.front();q.pop();
        exist[now]=0;
        for(int tmp=head[now];tmp!=-1;tmp=nxt[tmp])
        {
            int u=point[tmp],v=w[tmp];
            if(remain[tmp]&&dis[u]>dis[now]+v)
            {
                dis[u]=dis[now]+v;
                lastedge[u]=tmp;
                if(!exist[u])
                {
                    q.push(u);
                    exist[u]=1;
                }
            }
        }
    }
    if(dis[t]>inf)
    return 0;
    int add=addflow(s,t);
    flow+=add;
    cost+=add*dis[t];
    return 1;
}
void mfmc(int s,int t,int &flow,int &cost)
{
    flow=cost=0;
    while(spfa(s,t,flow,cost));
    return;
}
void swap(int &x,int &y)
{
    x^=y,y^=x,x^=y;
}
int main()
{
    sum=-1;
    memset(nxt,-1,sizeof(nxt));
    memset(head,-1,sizeof(head));
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&a);
        add(0,i+n,1,a);
        add(0,i,1,0);
        add(i+n,n<<1|1,1,0);
    }
    for(int i=1;i<=m;i++)
    {
        scanf("%d%d%d",&a,&b,&c);
        if(a>b) swap(a,b);
        add(a,b+n,1,c);
    }
    int maxflow,mincost;
    mfmc(0,n<<1|1,maxflow,mincost);
    printf("%d",mincost);
} 
```
PS：这道题扩大了时限，要不然普通的spfa费用流会被卡最后两个点╮(╯▽╰)╭
还好改时限了23333


---

## 作者：jun头吉吉 (赞：4)

# 一道网络流神仙题
[~~更好~~的阅读体验](https://chen-jia-liang.gitee.io/blog/2020/07/15/%E9%A2%98%E8%A7%A3-P2469-%E3%80%90-SDOI2010-%E6%98%9F%E9%99%85%E7%AB%9E%E9%80%9F%E3%80%91/)
## 题意
有一张$n$个点$m$条边的图，从一个不属于$n$个点的点出发，可以用一定时间通过一条边，也可以用$a_i$的时间到点$i$，求遍历所有点恰好一次的时间
## 题解
首先，看到**恰好一次**，我们必然想到**拆点**。因此，我们先把点$i$拆成$i_x$与$i_y$。$i_y$连向汇点，流量为$1$，费用为$0$，这是毋庸置疑的。现在，我们的问题是如何处理$a_i$与边的关系。

我们来考虑$i_y$可以从哪里来。显然，其：
1. 从其它点经过**星际航路**过来
2. 使用**能力爆发模式**使用$a_i$的代价飞过来。

对于$\;1$，我们可以从起点的$\ _x$连到当前点的$\ _y$，流量为$1$，费用为$w$

对于$\; 2$，我们可以从源点向他连一条流量为$1$，费用为$a_i$的边

#### 那么$i_x$的流量又是从哪来的呢
因为每个点我们只访问一次，因此只要从源点向每个入点连一条流量为$1$，费用为$0$的边就可以了
## 代码
```cpp
#pragma optimize(2)
#include<bits/stdc++.h>
using namespace std;
template<typename T>
inline void read(T &x){
	x=0;char c=getchar();bool f=false;
	for(;!isdigit(c);c=getchar())f!=c=='-';
	for(;isdigit(c);c=getchar())x=x*10+c-'0';
	if(f)x=-x;
}
template<typename T ,typename ...Arg>
inline void read(T &x,Arg &...args){
	read(x);read(args...);
}
template<typename T>
inline void write(T x){
	if(x<0)putchar('-'),x=-x;
	if(x>=10)write(x/10);
	putchar(x%10+'0');
}
const int maxn=100005;
const int maxe=100005;
struct Graph{
	int s,t;
	int dis[maxn],pre[maxn],lste[maxn],flow[maxn];
	bool inq[maxn];
	struct node{
		int v,w,cost,nxt;
		node(int _v=0,int _w=0,int _c=0,int _n=0){v=_v,w=_w,cost=_c,nxt=_n;}
	}e[maxe];
	int tot,head[maxn];
	void init(int _s,int _t){
		memset(head,0,sizeof head);
		tot=1;s=_s,t=_t;
	}
	inline void add(int u,int v,int w,int c){
		e[++tot]=node(v,w,c,head[u]);head[u]=tot;
		e[++tot]=node(u,0,-c,head[v]);head[v]=tot;
	}
	bool spfa(){
		queue<int>q;
		memset(dis,63,sizeof dis);
		memset(flow,63,sizeof flow);
		memset(inq,0,sizeof inq);
		dis[s]=0,pre[t]=-1;q.push(s);
		while(!q.empty()){
			int u=q.front();q.pop();inq[u]=0;
			#define v e[i].v
			for(int i=head[u];i;i=e[i].nxt){
				if(e[i].w>0&&dis[v]>dis[u]+e[i].cost){
					dis[v]=dis[u]+e[i].cost;
					pre[v]=u,lste[v]=i;//lste 表示顶点v是由哪条边过来的
					flow[v]=min(flow[u],e[i].w);
					if(!inq[v])inq[v]=1,q.push(v);
				}
			}
			#undef v
		}
		return pre[t]!=-1;
	}
	pair<int,int> mcmf(){
		int mincost=0,maxflow=0;
		while(spfa()){
			int u=t;
			maxflow+=flow[t],mincost+=flow[t]*dis[t];
			while(u!=s){
				int E=lste[u];
				e[E].w-=flow[t],e[E^1].w+=flow[t];
				u=pre[u];
			}
		}
		return make_pair(mincost,maxflow);
	}
}G;
int n,m;
int a,u,v,w;
signed main(){
	read(n,m);
	G.init(0,n+n+1);
	for(int i=1;i<=n;i++){
		read(a);
		G.add(i+n,G.t,1,0);
		G.add(G.s,i,1,0);
		G.add(G.s,i+n,1,a);
	}
	for(int i=1;i<=m;i++){
		read(u,v,w);if(u>v)swap(u,v);
		G.add(u,v+n,1,w);
	}
	write(G.mcmf().first);
}
```

---

## 作者：chdy (赞：4)

这道题目很经典，它和两个模型有关系，在此我写一篇题解来阐述。

1. 读完题发现这是一个无源汇上下界可行流，嗯 再加上最小费用流。

2. 费用流 还是 最小路径覆盖的费用流。

这两种思想无疑都是基于 要把整张图便利一遍且费用最小这个思想建立的。
也就是说从某种意义上来看 2是1的子集。

这也意味着而且我们根本不需要了解上下界网络流直接通过 最小点覆盖的模型加上费用即可完成这个问题的求解。

当然对于往后的学习 上下界网络流也是必要的。但是本人学习上下界网络流时间较短，所以这里讲一种类似于最小点覆盖的网络流。

题解: 满足题中的条件 每个点都经过一次且费用最小，那么显然的是我们可以以最大流来限制流量 合理建图让其一定能跑出最大流 且此时 加上边权即可求出最小费用。

建图：每个点只能经过一次所以需要拆一下点 u,u1 u1连向汇点 表示这个点跑到了。
我们通过 u1连向汇点流量为1来限制。

接下来开始往图中加入决策，首先我们从哪个地方开始都是可以的所以S向各个点的1节点连边 流量1 费用为跳跃时间 这个决策表示一开始我从哪个点开始，思考一下开始了然后呢 直接汇到汇点发现这条流消失了，但是这流还存在着其价值，我们从源点向各个节点的0节点费用为0流量为1，表示刚刚那条消失的流的重现 当前点向下一个点的1点连边费用为普通飞行时间我们发现这个流很有可能会再次消失 那无妨我们根节点向每个节点都连上述的边即可解决问题。

上述就是我对这题的全部思考，如果觉得很迷得话不妨去学习一下上下界可行流。

```cpp
//#include<bits/stdc++.h>
#include<iomanip>
#include<iostream>
#include<cstdio>
#include<cstring>
#include<string>
#include<queue>
#include<deque>
#include<cmath>
#include<ctime>
#include<cstdlib>
#include<stack>
#include<algorithm>
#include<vector>
#include<cctype>
#include<utility>
#include<set>
#include<bitset>
#include<map>
#define INF 1000000000
#define ll long long
#define min(x,y) (x>y?y:x)
#define max(x,y) (x>y?x:y)
#define RI register long long
#define up(p,i,n) for(int i=p;i<=n;++i)
#define db double
using namespace std;
char buf[1<<15],*fs,*ft;
inline char getc()
{
    return (fs==ft&&(ft=(fs=buf)+fread(buf,1,1<<15,stdin),fs==ft))?0:*fs++;
}
inline int read()
{
    int x=0,f=1;char ch=getc();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getc();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getc();}
    return x*f;
}
const int MAXN=810,maxn=40010;
int n,m,S,T,sum,maxflow,len=1,t,h;
int lin[MAXN<<1],ver[maxn],e[maxn],nex[maxn],e1[maxn];
int q[maxn],dis[maxn],in[maxn],vis[maxn],pre[maxn];
inline void add(int x,int y,int z,int z1)
{
    ver[++len]=y;nex[len]=lin[x];lin[x]=len;e[len]=z;e1[len]=z1;
    ver[++len]=x;nex[len]=lin[y];lin[y]=len;e[len]=0;e1[len]=-z1;
}
inline int spfa()//最小费用最大流
{
    for(int i=1;i<=T;++i)dis[i]=INF;
    t=h=0;dis[S]=0;q[++t]=S;vis[S]=1;in[S]=INF;
    while(h++<t)
    {
        int x=q[h];vis[x]=0;
        for(int i=lin[x];i;i=nex[i])
        {
            int tn=ver[i];
            if(!e[i])continue;
            if(dis[tn]>dis[x]+e1[i])
            {
                dis[tn]=dis[x]+e1[i];
                in[tn]=min(in[x],e[i]);
                pre[tn]=i;
                if(!vis[tn])q[++t]=tn,vis[tn]=1;
            }
        }
    }
    return dis[T]!=INF;
}
inline void EK()
{
    while(spfa())
    {
        int x=T,i=pre[x];
        maxflow+=in[T];
        sum+=in[T]*dis[T];
        while(x!=S)
        {
            e[i]-=in[T];
            e[i^1]+=in[T];
            x=ver[i^1];i=pre[x];
        }
    }
}
int main()
{
    //freopen("1.in","r",stdin);
    n=read();m=read();
    S=n<<1|1;T=S+1;
    for(int i=1;i<=n;++i)
    {
        int x=read();
        add(S,i,1,0);//从这个点开始跑
        add(S,i+n,1,x);//连向u1 直接跳跃
        add(i+n,T,1,0);//连向汇点
    }
    for(int i=1;i<=m;++i)
    {
        int x,y,z;
        x=read();y=read();z=read();
        if(x>y)swap(x,y);
        add(x,y+n,1,z);//每个点连向其能跑到的点
    }
    EK();
    printf("%d\n",sum);
    return 0;
}

```
正确性不言而喻 完结撒花~

---

## 作者：mgzc (赞：2)

# [题面](https://www.luogu.org/problemnew/show/P2469)
~~[这里有惊喜(推销博客ing)](https://www.cnblogs.com/ztlztl/p/10568317.html)~~

巨佬一眼就能看出这是最小路径覆盖, 我这个蒟蒻还是太弱了...

我们可以知道跳跃值为点权w[i], 两点之间距离为边权ww

对于每个点, 在最小路径覆盖问题中, 假设每个点都是一条路径, 即每个点都由能力爆发得到, 那么最初的答案便是$ans$ = $\sum_{ i = 1}^{n}$, 对于每一条连接u和v的边, 可以看做不使用能力爆发而从u往v走, 那么我们就减少了点v的点权, 加上了这一条边的代价, 即从$min(u, v)$向$max(u, v)$连一条容量为1, 费用为$ww - w[v]$, 那么只要每次增广找到一条费用为负的边就可以减少总时间, 即当$d[T]$小于0时就可以将$ans += d[T]$, 所以, 只要当此次增广无法到达T或者$d[T]$ > 0时就可以return 0了.

**具体代码**

```cpp
#include <iostream>
#include <cstring>
#include <cstdio>
#include <queue>
#define N 5005
using namespace std;

int n, m, S, T, head[N], cnt = 1, p[N], vis[N], w[N];
struct node
{
	int from, to, next;
	long long flow, cost; 
} edge[100005];
long long a[N], d[N], ans; 

inline int read()
{
	int x = 0, w = 1;
	char c = getchar();
	while(c < '0' || c > '9') { if (c == '-') w = -1; c = getchar(); }
	while(c >= '0' && c <= '9') { x = x * 10 + c - '0'; c = getchar(); }
	return x * w;
}

inline void add(int u, int v, int w, int cost)
{
	edge[++cnt] = { u, v, head[u], w, cost }; head[u] = cnt;
	edge[++cnt] = { v, u, head[v], 0, -cost }; head[v] = cnt; 
}

bool SPFA()
{
	memset(d, 0x3f, sizeof(d)); memset(a, 0x3f, sizeof(a));
	queue<int> q; q.push(S); d[S] = 0;
	while(!q.empty())
	{
		int u = q.front(); q.pop(); vis[u] = 0; 
		for(int i = head[u]; i; i = edge[i].next)
		{
			int v = edge[i].to;
			if(d[v] > d[u] + edge[i].cost && edge[i].flow > 0)
			{
				d[v] = d[u] + edge[i].cost; a[v] = min(a[u], edge[i].flow);
				p[v] = i; if(!vis[v]) { vis[v] = 1; q.push(v); }
			}
		}
	}
	if(d[T] == d[0] || d[T] > 0) return 0;
	if(d[T] < 0) ans += (d[T] * a[T]);
	for(int i = T; i != S; i = edge[p[i]].from)
	{
		edge[p[i]].flow -= a[T]; edge[p[i] ^ 1].flow += a[T]; 
	}
	return 1; 
}

int main()
{
	n = read(); m = read(); S = 2 * n + 1; T = S + 1; 
	for(int i = 1; i <= n; i++) { w[i] = read(); ans += w[i]; add(S, i, 1, 0); }
	for(int i = 1; i <= n; i++) add(i + n, T, 1, 0);
	for(int i = 1; i <= m; i++)
	{
		int u = read(), v = read(), ww = read();
		if(u > v) swap(u, v);
		add(u, v + n, 1, ww - w[v]); 
	}
	while(SPFA());
	printf("%lld\n", ans); 
	return 0;
}


```



---

## 作者：陈雪森 (赞：1)

**网络流的题，难点基本在于建图，
此题的建图方法为先将这n个点拆为两部分。**

1.由源点向第一部分点连容量为1，费用为零的点。
 
2.由第二部分点向汇连容量为1，费用为零的点。
 
3.由第一部分点向第二部分点连容量为1，费用为耗时。

4.源点向第二部分的点连容量为1，费用为航行时间。

5.最后跑一边最小费用最大流，即可求出答案。 

```cpp
#include<cstdio>
#include<cstring>
#include<iostream> 
#include<algorithm>
#include<queue>
using namespace std;
#define N 2610
#define M 35010
int ver[M],nxt[M],head[N],tot=1,incf[M],edge[M],cost[M];
int m,n,d[N],s=1,t,pre[N],maxflow,ans;
bool v[N];
void add(int x,int y,int z,int c){//链式前向星存储； 
	ver[++tot]=y;//记录终点 ； 
	edge[tot]=z;//记录初始流量； 
	cost[tot]=c;//记录单位费用； 
	nxt[tot]=head[x];
	head[x]=tot;
}
bool spfa(){
	queue<int>q;
	memset(d,0x3f,sizeof(d));//赋为最大值；因为此题求的是最小值； 
	memset(v,0,sizeof(v));
	q.push(s),d[s]=0;v[s]=1;	//用spfa求最短路； 
	incf[s]=1<<30;//增广路上各边的最小剩余容量； 
	while(q.size()){
		int x=q.front();
		v[x]=0;//记得清零；否则会超时； 
		q.pop();
		for(int i=head[x];i;i=nxt[i]){
			if(!edge[i])continue;//剩余容量为0，不在残量网络中 ，不用进行遍历； 
			int y=ver[i];
			if(d[y]>d[x]+cost[i]){
				d[y]=d[x]+cost[i];
				incf[y]=min(incf[x],edge[i]);
				pre[y]=i;//记录前驱，便于找到最短路的实际方案； 
				if(!v[y])v[y]=1,q.push(y);
			}
		}
	}
	if(d[t]==d[0])return false;//若用d[0]，则不能把s设为零。 到不了汇点，此时已求出最大流 
	return true;
}
void update(){//更新增广路和反向边的剩余容量； 
	int x=t;
	while(x!=s){
		int i=pre[x];
		edge[i]-=incf[t];
		edge[i^1]+=incf[t];
		x=ver[i^1];//利用成对变换的思想； 
	}
//	maxflow+=incf[t];求最大流，不过此题用不上； 
	ans+=d[t]*incf[t];//单位费用*路程 
}
int main(){
	scanf("%d%d",&n,&m);
	t=n*2+2;//因为将这n个点进行拆点所以点的总量为2*n加上源点和汇点； 
	//总共为2*n+1； 
	for(int i=1;i<=n;i++){
		int x;
		scanf("%d",&x);
		add(s,i+n,1,x);//源点向拆分的第二部分点连边。 
		add(i+n,s,0,-x);
	}
	for(int i=1;i<=n;i++) add(i+n,t,1,0),add(t,i+n,0,0);//第二部分点与汇点连边。 
	for(int i=1;i<=n;i++) add(s,i,1,0),add(i,s,0,0);//起点向第一部分点连边。 
	for(int i=1;i<=m;i++){
		int x,y,z;
		scanf("%d%d%d",&x,&y,&z);
		if(x>y)swap(x,y);//保证边是由小编号连向大编号； 
		add(x,y+n,1,z);//拆分的点连边； 
		add(y+n,x,0,-z);
	}
	while(spfa()) update();//求最小费用最大流，不过此题用不到最大流； 
	printf("%d",ans);
	return 0;
}
```


---

## 作者：k，火魂 (赞：0)

~~个人感觉这道题还是很有难度的~~

这道题看到以后很容易想到费用流问题，但是这道题感觉有点不是很套路。看到每个星球只能而且必须经过一次，先想到拆点，点与点之间连边，流一费零，出点与汇点连边，流一费零，源点与入点连跃迁边，然后，……~~不会跑费用了，挂逼了~~。我自认为这样连边应该也是可以跑的，~~但是我这种蒟蒻当然不会了~~。


大佬告诉我正解

将每个点拆点。

源点向每个点的入点连一条容量为1费用为0的边。

源点向每个点的出点连一条容量为1费用为瞬移到该点所需时间的边。

每个点的出点向汇点连一条容量为1费用为0的边。

对于每条边(i,j)，从i点入点向j点出点连一条容量为1费用为航路所需时间的边。

流到该点出点的某入点对应的星球，在之前的某一时刻一定由某种合法方式达到过，追溯到头一定是某个瞬移到的点（因为图中没有环），“追溯”的过程就是这一条路径。

~~别问我怎么想到的，我反正没想到，借鉴了题解~~。

为什么这么练是对的，每条出点都与汇点相连，流量为一，这样每条出边只走一次，保证每个星球只经过一次。而每个出点直接与源点相连，因为保证最大流，所以每座星球都会被经过。源点向入点连得边可以看成是别的星球开过来的，入点向出点连边看做开到那个星球，至于s向出点连边看成跃迁。每次跑到t其实都可以看做回到了s。

可以自己把样例走一遍大概就可以领会了。


```cpp
#include<iostream>
#include<cstring>
#include<queue>
#include<cstdio>
using namespace std;
const int N=10000,M=100000,inf=1<<30;

#define itn int
int n,m,s,t,maxflow,tot=1,ans;
int a[810];
int ver[2*M],hea[N],edge[2*M],cost[2*M],nex[2*M];
int incf[N],d[N],pre[N];
bool v[N];
queue<int>q;

inline void add(int x,int y,int z,int c){
	ver[++tot]=y;edge[tot]=z;cost[tot]=c;
	nex[tot]=hea[x];hea[x]=tot;
}

inline bool bfs()
{
//	cout<<t<<"aaaaaaaaaaaa"<<endl;
	memset(d,0x3f,sizeof(d));
	memset(v,0,sizeof(v));
	while(q.size())q.pop();
	q.push(s);incf[s]=inf;v[s]=1;
	d[s]=0;
	while(q.size()){
		int x=q.front();q.pop();v[x]=0;
//		cout<<x<<" ";
		for(int i=hea[x];i;i=nex[i]){
			int y=ver[i];
			if(!edge[i])continue;
			if(d[y]>d[x]+cost[i]){
				d[y]=d[x]+cost[i];
				pre[y]=i;
				incf[y]=min(incf[x],edge[i]);
				if(!v[y])q.push(y),v[y]=1;
			}
		}
	}
	if(d[t]==d[0])return false;
	else return true;
}

inline void calc(){
//	cout<<t<<endl;
	int x=t;
	while(x!=s){
		int i=pre[x];
		edge[i]-=incf[t];
		edge[i^1]+=incf[t];
		x=ver[i^1];
	}
	maxflow+=incf[t];
	ans+=d[t]*incf[t];
}

int main()
{
	scanf("%d%d",&n,&m);
	s=n+n+1,t=s+1;
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
		add(s,n+i,1,a[i]);
		add(n+i,s,0,-a[i]);
		add(i+n,t,1,0);
		add(t,i+n,0,0);
		add(s,i,1,0);
		add(i,s,0,0);
	}
	for(int i=1;i<=m;i++){
		int x,y,z;scanf("%d%d%d",&x,&y,&z);
		if(x>y)swap(x,y);
		add(x,y+n,1,z);add(y+n,x,0,-z);
	}
	while(bfs())calc();
	printf("%d",ans);
	return 0;
}
```


---


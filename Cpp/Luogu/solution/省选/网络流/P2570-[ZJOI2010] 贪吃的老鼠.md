# [ZJOI2010] 贪吃的老鼠

## 题目描述

奶酪店里最近出现了 $m$ 只老鼠！它们的目标就是把生产出来的所有奶酪都吃掉。奶酪店中一天会生产 $n$ 块奶酪，其中第 $i$ 块的大小为 $p_i$，会在第 $r_i$ 秒被生产出来，并且必须在第 $d_i$ 秒之前将它吃掉。第 $j$ 只老鼠吃奶酪的速度为 $s_j$，因此如果它单独吃完第 $i$ 块奶酪所需的时间为 $p_i/s_j$。老鼠们吃奶酪的习惯很独特，具体来说：

1. 在任一时刻，一只老鼠最多可以吃一块奶酪；
2. 在任一时刻，一块奶酪最多被一只老鼠吃。

由于奶酪的保质期常常很短，为了将它们全部吃掉，老鼠们需要使用一种神奇的魔法来延长奶酪的保质期。将奶酪的保质期延长 $T$ 秒是指所有的奶酪的 $d_i$ 变成 $d_i+T$。同时，使用魔法的代价很高，因此老鼠们希望找到最小的 $T$ 使得可以吃掉所有的奶酪。

## 说明/提示

### 样例说明

第一组数据中：

第 $0$ 到第 $1$ 秒：

第一只老鼠吃第一块奶酪；

第 $1$ 到第 $3.5$ 秒：

- 第一只老鼠吃第二块奶酪；
- 第二只老鼠吃第一块奶酪；

第 $3.5$ 到第 $4.5$ 秒：第一只老鼠吃第一块奶酪。

### 数据规模

$30\%$ 的数据中，$1 \le n,m \le 5$；

$100\%$ 的数据中，$1 \le K \le 5$，$1 \le n,m \le 30$，$1 \le p_i \le 10^5$，$0 \le r_i<d_i \le 10^7$，$1 \le s_j \le 10^5$。

## 样例 #1

### 输入

```
2
2 2
13 0 4
10 1 3
4
2
1 1
1 0 2
1
```

### 输出

```
0.5
0
```

# 题解

## 作者：YksKuusiTAlv (赞：20)

* 这是我最后一次交题解，交题解纯属因为题解区根本没有正确的证明，实在是懒得改什么 Latex 了，爱过不过吧。

感觉这题非常神仙，题解区几乎没有令人满意的 “差分建图” 正确性的证明，感谢 @p_b_p_b 和 @精神小火 指导。

先用一些套路，我们可以想到二分答案，把蛋糕出现的时间离散化，把老鼠分成若干个不相交的区间。

此时唯一的问题是 怎么解决不能让很多老鼠同时吃一个蛋糕。

首先考虑一个结论 ： 在所有奶酪能被吃的时间相等的情况下，设他们能吃的时间是 $time$ ， 我们把老鼠按速度 $v$ 从大到小排序，奶酪从大到小按 $p$ 排序，那么这些老鼠可以按照题目要求吃掉这些奶酪，当且仅当 $\forall i , time (\sum_{j=1} ^i v_j) \geq \sum_{j=1}^i p_j$ 。

考虑如果这个结论成立，我们该怎么建图， 先把 $v$ 按从大到小排序。

$\sum_{j=1}^i v_j=\sum_{j=1}^i \sum_{k=j}^i(v_k-v_{k+1}) = \sum_{k=1}^i (v_k - v_{k+1}) \times k $

我们把一个点的意义设置为 $v_k-v_{k+1}$ ，从这个点向每个奶酪连 $(v_k-v_{k+1}) \times time$ ，原点向第 $k$ 个点连 $k \times (v_k-v_{k+1}) \times time$ 。

此时，考虑一种不满足上述结论的奶酪，假设前 $t$ 的时候他不满足，那么在这 $t$ 个的时候，所有点向这前 $t$ 个点的集合连的总流量是 $\sum_{i=1}^n (v_{i}-v_{i+1}) \times \min(i,t)=\sum_{i=1}^t v_i$ ，满足我们的需求。


再来考虑结论的正确性，可能略微有点抽象。

考虑在可以被无线划分的时间轴上一个类似归纳的过程，记 $\Delta$ 为最小的时间单位。

首先明确一个事情，我们可以通过让 $v_a$ 吃 $\Delta$ 的 $p_a$ , 让 $v_b$ 吃 $\Delta$ 的 $p_b$ ，再让 $v_a$ 吃 $\Delta$ 的 $p_b$ , 让 $v_b$ 吃 $\Delta$ 的 $p_a$ ，这样我们达到了一个目的：让两只 $\frac{v_a+v_b}{2}$ 的老鼠吃了 $2 \Delta$ 的 $p_a, p_b$ 。

扩展上述操作，调整 $\Delta$ 的系数，我们就可以做到把老鼠加权平均。

再考虑去归纳，如果 $\Delta$ 之后，所有的老鼠仍然满足条件，那么命题就得证了，下文的 $v_i, p_i$ 都是从大到小排序之后的。

我们只需要让 $v_i$ 吃 $p_i$ $\Delta$ 的时间，然后去加权平均调整这些老鼠，使他仍然满足条件即可， 我们可以按如下方式调整：

把 $v_1$ 和 $v_2$ 加权调整使得恰好满足 $v_1 \times left \geq p_1 , left$ 是剩下的时间。

再把 $v_2$ 和 $v_3$ 加权调整使得恰好满足 $v_2 \times left \geq p_2 , left$ 是剩下的时间。

不断重复上述过程，一定会得到满足。

一种特殊的情况是 $v_1,v_2$ 无论如何加权都大于 $p_1$ ，我们找到他后面第一个可以加权恰好等于 $p_1$ 的 $v_i$ 然后调整即可。

---

## 作者：Creeper_LKF (赞：12)

# 宣传
首先宣传一波：[我的博客](https://www.cnblogs.com/CreeperLKF/p/9175053.html)
# 题面
原题面还是比较简洁的，不描述了
# 题解
这份题解主要在于证明，解法也会提到，如果有疑问可以参考其它DL的题解。 

## 二分答案+最大流

建图方式：

1. 首先对所有时间点离散化，记两个时间点之间的时间段长度为$tim$，然后把老鼠从大到小排序最后加个数字0，差分得到$m$个差分值，记为$d$，依次编号为$1,2,3...$  
1. 对奶酪建点，对时间点间的时间段拆点，拆成m个老鼠差分值  
1. 源点连向奶酪，容量 *p*  
1. 奶酪连向奶酪保质期内的时间段的老鼠差分点，容量为 *老鼠差分值$*$时间段长度*  
1. 老鼠差分点连向终点，容量为 *老鼠差分值$*$时间段长度$*$老鼠差分点编号（排序后从大到小）*  
1. 然后跑最大流，奶酪满流即为合法  
--------下面配合一个实例来讲解证明为什么这样是对的（反正我是想不到的）  
--------为了区分老鼠速度和差分后的速度，我们将拆出来的点称为“老鼠差分点“或”老鼠点“或指代意义的”点“
![图例](https://cdn.luogu.com.cn/upload/pic/21011.png)
## 举个例子  
老鼠分别有速度7,4,2  
差分得到3,2,2  
然后我们假设时间段长度为2  
然后老鼠到t的流量限制为6,8,12  
然后和奶酪的流量限制为6,4,4

## 证明

- --------当且仅当这张图所有奶酪到起点的边满流的时候有解，其中如果一个老鼠$x$在一个时间段内吃了奶酪$y$，那么从该时间段$m-x$到$m$的老鼠差分点到奶酪$y$都会有流量$t*d_i$。这张图的工作原理是比较简单的（如果看不懂可以参考一下其它DL的博客）  
- 最主要难以证明的是题目需要满足的两个要求。


------------

首先证明这张图满足一个老鼠同一时间只吃一个奶酪  

- --------如果一个从大到小排名第$k$的老鼠吃了同一时间段的$x$块奶酪（如果不在同一时间段的话就不会有非法状态，如果有重叠则重叠部分和这个问题等价），设第$i$块奶酪吃了时间$t_i$，那么我们假设一个非法状态，也就是$(\Sigma{t_i}) > tim$，也就是一个老鼠同时吃多块奶酪，所以这个时候k号老鼠差分点产生的流量至少为$\Sigma{(t_i)}*d_k$，我们记为流量，但是我们对该老鼠的限制有$k*tim*d_k$，我们记为容量，我们要证明非法状态的$流量 > 容量$，在网络流中不存在。  
这个时候我们有两种情况：
	1. --------速度更快的老鼠还可以吃且可以吃超额部分（超额部分就是引起一只老鼠需要在同一时间吃两个奶酪的部分），那么就可以分担这个老鼠的任务，所以不存在这样的非法状态
	2. ---------速度更快的老鼠吃不完超额部分，那么这些老鼠一定是已经吃过了，所以根据差分上面$k-1$个老鼠差分点对这个老鼠差分点产生了流量负担，这个负担加上原有的流量为$\Sigma{(t_i)}*d_k+(k-1)*d_k*tim=k*tim*t_k+(\Sigma{(t_i)}-tim)$，由于$(\Sigma{(t_i)}-tim)>0$，所以$\Sigma{(t_i)}*d_k+(k-1)*d_k*tim>k*d_k*tim$，所以$流量 > 容量$，在网络流中无法实现  



------------


然后证明这张图满足一个奶酪同时只被一只老鼠吃  

- --------这个比较简单，一样假设一共有x只老鼠吃了奶酪，每一个吃了时间$t_i$，然后假设非法状态$(\Sigma{t_i}) > tim$，然后由于排名靠前的老鼠吃了的话那么在差分点中对排名较后的老鼠也会有时间上的影响，也就是吃了同一个奶酪的排名最后的老鼠流量为$\Sigma{(t_i)}*d_k$，大于边的容量$ti*d_k$，所以状态不存在。

代码如下：
```cpp
#include <cstdio>
#include <cctype>
#include <cstring>
#include <iostream>

//User's Lib

#include <cmath>
#include <algorithm>

using namespace std;

#define DEBUG_PORT
#define DEBUG

#ifdef ONLINE_JUDGE
#undef DEBUG_PORT
#undef DEBUG
#endif

#ifdef DEBUG_PORT
#if __cplusplus >= 201103L
#ifdef DEBUG
template<typename T>
extern inline void Debug(T tar){
    cerr << tar << endl;
}
template<typename Head, typename T, typename... Tail>
extern inline void Debug(Head head, T mid, Tail... tail){
    cerr << head << ' ';
    Debug(mid, tail...);
}
#else
# pragma GCC diagnostic push
# pragma GCC diagnostic ignored "-Wunused-parameter"
template<typename Head, typename T, typename... Tail>
extern inline void Debug(Head head, T mid, Tail... tail){
    return ;
}
# pragma GCC diagnostic pop
# pragma message "Warning : pragma used"
#endif
#else
# pragma message "Warning : C++11 Not Use"
#ifdef DEBUG
template <typename T>
extern inline void Debug(T tar){
    cerr << tar << endl;
}
#else
# pragma GCC diagnostic push
# pragma GCC diagnostic ignored "-Wunused-parameter"
template <typename T>
extern inline void Debug(T tar){
    return ;
}
# pragma GCC diagnostic pop
# pragma message "Warning : pragma used"
#endif
#endif
#else
# pragma GCC diagnostic push
# pragma GCC diagnostic ignored "-Wunused-parameter"
template<typename Head, typename T, typename... Tail>
extern inline void Debug(Head head, T mid, Tail... tail){
    return ;
}
template <typename T>
extern inline void Debug(T tar){
    return ;
}
# pragma GCC diagnostic pop
# pragma message "Warning : pragma used"
#endif

char buf[11111111], *pc = buf;

extern inline void Main_Init(){
    static bool INITED = false;
    if(INITED) fclose(stdin), fclose(stdout);
    else {
        fread(buf, 1, 11111111, stdin); 
        INITED = true;           
    }
}

static inline int read(){
    int num = 0;
    char c, sf = 1;
    while(isspace(c = *pc++));
    if(c == 45) sf = -1, c = *pc ++;
    while(num = num * 10 + c - 48, isdigit(c = *pc++));
    return num * sf;
}

namespace LKF{
    template <typename T>
    extern inline T abs(T tar){
        return tar < 0 ? -tar : tar;
    }
    template <typename T>
    extern inline void swap(T &a, T &b){
        T t = a;
        a = b;
        b = t;
    }
    template <typename T>
    extern inline void upmax(T &x, const T &y){
        if(x < y) x = y;
    }
    template <typename T>
    extern inline void upmin(T &x, const T &y){
        if(x > y) x = y;
    }
    template <typename T>
    extern inline T max(T a, T b){
        return a > b ? a : b;
    }
    template <typename T>
    extern inline T min(T a, T b){
        return a < b ? a : b;
    }
}

//Source Code

const int MAXK = 33;
const int MAXN = 2018;
const int MAXM = 99999;
const double INF = 1e16;
const double eps = 1e-6;

inline bool comp(const double &a, const double &b){
    double tmp = a - b;//int???
    if(fabs(tmp) < eps) return 0;
    return a > b ? 1 : -1;
}

int s = MAXN - 10, t = s + 1;

struct Queue{
    int s, t;
    int q[MAXN];
    Queue(){s = 1, t = 0;}
    inline void clear(){
        s = 1, t = 0;
    }
    inline bool empty(){
        return s > t;
    }
    inline int size(){
        return t - s + 1;
    }
    inline void push(int tar){
        q[++ t] = tar;
    }
    inline int front(){
        return q[s];
    }
    inline void pop(){
        s ++;
    }
};

struct Graph{
    int tot;
    int beginx[MAXN], endx[MAXM], nxt[MAXM];
    double res[MAXM];
    Graph(){
        tot = 1;
    }
    inline void Init(){
        tot = 1;
        memset(beginx, 0, sizeof(beginx));
    }
    inline void add_edge(int u, int v, double r){
        // Debug(u, "->", v, "[label = \"", r, "\"]");//Debug...
        nxt[++ tot] = beginx[u], beginx[u] = tot, endx[tot] = v, res[tot] = r;
        nxt[++ tot] = beginx[v], beginx[v] = tot, endx[tot] = u, res[tot] = 0;
    }
};

struct ISap{
    Graph g;
    Queue mession;
    double max_f;
    int cur[MAXN], d[MAXN], num[MAXN], pre[MAXN];
    inline void bfs(){
        mession.clear();
        mession.push(t);
        memset(d, 0, sizeof(d));
        memset(num, 0, sizeof(num));
        d[t] = 1;
        int u, v;
        while(!mession.empty()){
            u = mession.front();
            mession.pop();
            num[d[u]] ++;
            for(int i = g.beginx[u]; i; i = g.nxt[i]){
                v = g.endx[i];
                if(!d[v] && comp(g.res[i ^ 1], 0)){
                    d[v] = d[u] + 1;
                    mession.push(v);
                }
            }
        }
    }
    inline double dfs(int u, double now_f){
        if(u == t) return now_f;
        double ret_f = 0;
        for(int &i = cur[u]; i; i = g.nxt[i]){
            int v = g.endx[i];
            if(comp(g.res[i], 0) && d[u] == d[v] + 1){
                double ret = dfs(v, min(g.res[i], now_f));
                ret_f += ret, now_f -= ret;
                g.res[i] -= ret, g.res[i ^ 1] += ret;
                if(d[s] >= MAXN - 4 || !comp(now_f, 0)) return ret_f;
            }
        }
        if(-- num[d[u]] == 0) d[s] = MAXN - 4;
        ++ num[++ d[u]];
        cur[u] = g.beginx[u];
        return ret_f;
    }
    inline double ISAP(){
        bfs();
        max_f = 0;
        memcpy(cur, g.beginx, sizeof(cur));
        while(d[s] < MAXN - 5)
            max_f += dfs(s, INF);
        return max_f;
    }
}isap;

int n, m, sum;
int p[MAXK], r[MAXK], d[MAXK], ss[MAXK];
double tmp_arr[MAXK << 1];
int cnt;

inline bool check(double tar){
    cnt = 0;
    isap.g.Init();
    for(int i = 1; i <= n; i++)
        tmp_arr[++ cnt] = r[i], tmp_arr[++ cnt] = d[i] + tar;
    sort(tmp_arr + 1, tmp_arr + 1 + cnt);
    cnt = unique(tmp_arr + 1, tmp_arr + 1 + cnt) - tmp_arr - 1;
    for(int i = 1; i <= n; i++)
        isap.g.add_edge(s, i, p[i]);
    for(int i = 2; i <= cnt; i++){
        double lst = tmp_arr[i - 1], tim = tmp_arr[i] - lst;
        for(int j = 1; j <= m; j++)
            isap.g.add_edge(n + (i - 2) * m + j, t, j * tim * ss[j]);
        for(int j = 1; j <= n; j++)
            if(r[j] <= lst && d[j] + tar >= tmp_arr[i])
                for(int k = 1; k <= m; k++)
                    isap.g.add_edge(j, n + (i - 2) * m + k, tim * ss[k]);
    }
    return !comp(isap.ISAP(), sum);
}

int main(){
    Main_Init();
    int T = read();
    while(T --){
        n = read(), m = read();
        sum = 0;
        for(int i = 1; i <= n; i++)
            sum += (p[i] = read()), r[i] = read(), d[i] = read();
        for(int i = 1; i <= m; i++)
            ss[i] = read();
        ss[m + 1] = 0;
        int tmp = ss[1];
        sort(ss + 1, ss + 1 + m, greater<int>());
        for(int i = 1; i <= m; i++)
            ss[i] -= ss[i + 1];
        double l = 0, r = 1.0 * sum / tmp, mid;
        while(fabs(r - l) > eps){
            mid = (l + r) / 2.0;
            if(check(mid)) r = mid;
            else l = mid;
        }
        printf("%.5lf\n", mid);
    }
    Main_Init();
    return 0;
}
```

---

## 作者：xtx1092515503 (赞：7)

这题太神仙了，必须写篇题解记录一下。

首先，一眼能看出的是需要二分保质期$T$。然后呢？

然后就是十分神仙的建图了。

首先，对于时间离散化是必须的。一共$n$块奶酪，每块有出现和消失两个时间点，故共有$2n$个时间点。离散化后，我们共得到$2n-1$块时间块。

然后，最神仙的一点来了：

我们将老鼠按照速度从大到小排序，并在最后添加一只速度为$0$的老鼠。之后，进行差分。

举个例子：$2\ 9\ 4\ 5\xrightarrow{\text{排序并加0}}9\ 5\ 4\ 2\ 0\xrightarrow{\text{差分}}4\ 1\ 2\ 2$。

这样差分有什么用呢？

题面中有如下限制：
$\text{(1)在任一时刻,一只老鼠最多可以吃一块奶酪;}$
$\text{(2)在任一时刻，一块奶酪最多被一只老鼠吃。}$

为了满足如上限制，我们进行了拆点。现在我们看看拆点是如何实现如上限制的：

这段是二分的$check$函数。

$sz$是奶酪大小；$s$和$t$是奶酪出现和消失的时间点；$v$是一个$vector，用来离散化$；$CC$是计数器，用来编号；$head$与$cnt$是前向星；$ae$用来连边；$EPS$是精度；$S$是源点，$T$是汇点；$sp$是差分后的老鼠。

```cpp
bool che(double ip){
	memset(head,-1,sizeof(head)),cnt=0,res=0,v.clear();
	for(register int i=1;i<=n;i++)ae(S,i,sz[i]),v.push_back(s[i]),v.push_back(ip+t[i]);
	sort(v.begin(),v.end()),CC=n;
	for(register int i=1;i<=m;i++){
		for(register int j=1;j<v.size();j++){
			if(v[j]-v[j-1]<EPS)continue;
			CC++,ae(CC,T,(v[j]-v[j-1])*sp[i]*i);
			for(register int k=1;k<=n;k++)if(((double)s[k]-v[j-1])<EPS&&ip+t[k]-v[j]>-EPS)ae(k,CC,sp[i]*(v[j]-v[j-1]));
		}
	}
	Dinic();
	return sum-res<EPS;
}
```


------------

可以看到，我们对于每块奶酪，都从源点连来$sz$单位的流量。如果流量跑满，就意味着合法。同时，我们进行了离散化。就是这两行的内容。
```cpp
for(register int i=1;i<=n;i++)ae(S,i,sz[i]),v.push_back(s[i]),v.push_back(ip+t[i]);
sort(v.begin(),v.end()),CC=n;
```


------------

然后，我们开始枚举老鼠（循环$i$），再枚举时间段（循环$j$）。如果相邻的两个时间点是相同的（即差$<EPS$），就跳过。

就是这三行。
```cpp
for(register int i=1;i<=m;i++){
		for(register int j=1;j<v.size();j++){
			if(v[j]-v[j-1]<EPS)continue;
```


------------

然后，我们为（在$j$时间段内的老鼠$i$）提供一个编号（$CC$），并向汇点连去$((v[j]-v[j-1])*sp[i]*i)$的流量。

奇怪，为什么是这么多呢？

我们看一下它的含义：

$(v[j]-v[j-1])$：该时间段的长度。也就是说，后面乘上的东西应该是老鼠每秒的速度，这样得到在这么长的时间段里老鼠可以吃掉多少奶酪。


我们看一下后面的东西：

$sp[i]*i$

这个东西的意思是，差分值乘上它的编号。

为什么是这个呢？我们观察一下差分过程。设$diff$为差分数组，$org$为原数组。

则有$\Sigma diff_i*i=\Sigma org_i$。

或者看图：

![](https://cdn.luogu.com.cn/upload/image_hosting/ah8628a3.png)


------------

我们以上面举的差分例子为例：

$4\ 1\ 2\ 2\xrightarrow{sp[i]*i}4\ 2\ 6\ 8$

这样连的话，就可以保证前面那两条限制。这就相当于在每一横条上取走一部分。如果从竖向来看的话，就是每只老鼠工作一部分。

![](https://cdn.luogu.com.cn/upload/image_hosting/gn8wtqdl.png)

这样子，我们就知道了为什么要连这么多流量。


------------
之后就比较简单了。

这段是对于时间段$j$的$i$老鼠，我们枚举每块奶酪，如果这块奶酪存在的时间包含了这块奶酪，则连边，连的是这段时间里，这只老鼠最多能在一块奶酪上付出的努力，即$(sp[i]*(v[j]-v[j-1]))$。

就是这段代码：
```cpp
for(register int k=1;k<=n;k++)if(((double)s[k]-v[j-1])<EPS&&ip+t[k]-v[j]>-EPS)ae(k,CC,sp[i]*(v[j]-v[j-1]));
```


------------
然后，最恶心的$check$函数部分就讲完了。我们最后再梳理一下过程：

#### 1.差分老鼠速度

#### 2.开始二分

##### 2.1.离散化时间点，求出时间段，并由源点连来（奶酪大小）单位的流量

##### 2.2.求出某时间段的某老鼠最多可以贡献多少流量，并向汇点连这么多的流量

##### 2.3.求出所有包含这一时间段的奶酪，并连向该老鼠

##### 2.4.求最大流



------------
以上就是这道神仙又巧妙的题的全过程。希望对你有帮助。

**来都来了，点个赞呗~~~**

附:注意网络流要写实数网络流，而非整数网络流。

代码：
```cpp
#pragma GCC optimize(3)
#include<bits/stdc++.h>
using namespace std;
const double EPS=1e-7;
int TT,n,m,sz[50],s[50],t[50],sp[50],sum,CC;
namespace MaxFlow{
	const int N=10000,M=200000;
	int head[N],cur[N],dep[N],cnt,S,T;
	double res;
	struct node{
		int to,next;
		double val;
	}edge[M];
	inline void ae(int u,int v,double w){
		edge[cnt].next=head[u],edge[cnt].to=v,edge[cnt].val=w,head[u]=cnt++;
		edge[cnt].next=head[v],edge[cnt].to=u,edge[cnt].val=0,head[v]=cnt++;
	}
	queue<int>q;
	inline bool bfs(){
		memset(dep,0,sizeof(dep)),q.push(S),dep[S]=1;
		while(!q.empty()){
			register int x=q.front();q.pop();
			for(register int i=cur[x]=head[x];i!=-1;i=edge[i].next)if(edge[i].val>EPS&&!dep[edge[i].to])dep[edge[i].to]=dep[x]+1,q.push(edge[i].to);
		}
		return dep[T]>0;
	}
	bool reach;
	inline double dfs(int x,double flow){
//		printf("%d %lf\n",x,flow);
		if(x==T){
			res+=flow;
			reach=true;
			return flow;
		}
		double used=0;
		for(register int &i=cur[x];i!=-1;i=edge[i].next){
			if(edge[i].val<EPS||dep[edge[i].to]!=dep[x]+1)continue;
			register double ff=dfs(edge[i].to,min(edge[i].val,flow-used));
			if(ff>EPS){
				edge[i].val-=ff;
				edge[i^1].val+=ff;
				used+=ff;
				if(abs(flow-used)<EPS)break;
			}
		}
		return used;
	}
	inline void Dinic(){
		while(bfs()){
			reach=true;
			while(reach)reach=false,dfs(S,1e9);
		}
	}
}
using namespace MaxFlow;
double L,R;
vector<double>v;
bool che(double ip){
	memset(head,-1,sizeof(head)),cnt=0,res=0,v.clear();
	for(register int i=1;i<=n;i++)ae(S,i,sz[i]),v.push_back(s[i]),v.push_back(ip+t[i]);
	sort(v.begin(),v.end()),CC=n;
	for(register int i=1;i<=m;i++){
		for(register int j=1;j<v.size();j++){
			if(v[j]-v[j-1]<EPS)continue;
			CC++,ae(CC,T,(v[j]-v[j-1])*sp[i]*i);
			for(register int k=1;k<=n;k++)if(((double)s[k]-v[j-1])<EPS&&ip+t[k]-v[j]>-EPS)ae(k,CC,sp[i]*(v[j]-v[j-1]));
		}
	}
	Dinic();
	return sum-res<EPS;
}
void solve(){
	while(R-L>EPS){
		double mid=(L+R)/2;
		if(che(mid))R=mid;
		else L=mid;
	}
}
int main(){
	scanf("%d",&TT);
	while(TT--){
		scanf("%d%d",&n,&m),sum=0,L=R=0,S=2*n*m+n+1,T=2*n*m+n+2;
		for(register int i=1;i<=n;i++)scanf("%d%d%d",&sz[i],&s[i],&t[i]),sum+=sz[i];
		R=sum;
		for(register int i=1;i<=m;i++)scanf("%d",&sp[i]);
		sort(sp+1,sp+m+1);
		for(register int i=m;i;i--)sp[i]-=sp[i-1];
		reverse(sp+1,sp+m+1);
//		for(int i=1;i<=m;i++)printf("%d ",sp[i]);puts("");
		solve();
		printf("%lf\n",L);
	}
	return 0;
}
```


---

## 作者：BillYang (赞：7)

欢迎来[我的博客](https://blog.bill.moe/ZJOI2010-mouse)坐坐。  
## 题目分析
本题的建图方式非常玄学，然而看本题时我根本没想到是网络流，当成DP想了半天（~~完了我现在看DP是网络流，看网络流是DP~~）。  

首先二分答案和将时间离散化是很容易想到的。  

现在先不考虑在一个时刻，每一块奶酪只能被一只老鼠吃。  
那么我们可以得到这样的建图方法：  
- 源点向奶酪连边，容量为奶酪大小。  
- 将老鼠按照离散化后的时间段拆点，每一个时间段向对应的可以吃的奶酪连边，容量为老鼠的速度$v\times dur$，其中$dur$是时间段大小。  
- 老鼠向汇点连边，容量INF。  

现在我们来考虑每一块奶酪只能被一只老鼠吃。  
将老鼠按速度排序后做个差分。  
如9 4 1改为5 3 1。  
修改建图方式：  
- 源点向奶酪连边，容量为奶酪大小。  
- 将老鼠按照离散化后的时间段拆点，每一个时间段向对应的可以吃的奶酪连边，容量为老鼠的差分后速度$v\times dur$，其中$dur$是时间段大小。  
- 编号为$i$的老鼠向汇点连边，容量为差分后速度$i\times v[i]\times dur$。  

我们来解释一下这样建图的原因。  
先考虑每一块奶酪只能被一只老鼠吃。  
首先，可以吃的奶酪量可以看做各个老鼠速度的线性组合。  
而差分后线性基没有改变，所以张量不变。  
其次，由于时间可以无限拆分，那么张量最大值即为老鼠差分后速度之和，即为吃的最快的老鼠原速度，因此张量$=0\sim$ 最大值。因此我们只需要限制最大值即可，在第二种建边的时候已经限制，全部满流时最大。  
然后，考虑每一只老鼠只能吃一块奶酪。  
类似上面所说的，我们可以将老鼠吃不同的奶酪也看做线性组合，同样只需要限制最大值，即为所有老鼠一起吃奶酪，在第三种建边时已经限制，全部满流时最大。  

-----
## 代码
```cpp
#include<bits/stdc++.h>

using namespace std;

inline int Get_Int() {
	int num=0,bj=1;
	char x=getchar();
	while(!isdigit(x)) {if(x=='-')bj=-1;x=getchar();}
	while(isdigit(x)) {num=num*10+x-'0';x=getchar();}
	return num*bj;
}

const int maxn=3005;
const double eps=1e-6;

int dcmp(double x) {
	if(fabs(x)<=eps)return 0;
	return x>eps?1:-1;
}

struct Edge {
	int from,to;
	double cap,flow;
	Edge(int x=0,int y=0,double c=0,double f=0):from(x),to(y),cap(c),flow(f) {}
};

struct Dinic {
	int n,m,s,t;
	vector<Edge> edges;
	vector<int> G[maxn];
	bool vst[maxn];
	int dist[maxn],cur[maxn];
	void init(int n) {
		this->n=n;
		edges.clear();
		for(int i=1; i<=n; i++)G[i].clear();
	}
	void AddEdge(int x,int y,double v) {
		edges.push_back(Edge(x,y,v,0));
		edges.push_back(Edge(y,x,0,0));
		m=edges.size();
		G[x].push_back(m-2);
		G[y].push_back(m-1);
	}
	bool bfs() {
		fill(vst+1,vst+n+1,0);
		queue<int> Q;
		Q.push(t);
		vst[t]=1;
		while(!Q.empty()) {
			int Now=Q.front();
			Q.pop();
			for(int id:G[Now]) {
				Edge& e=edges[id^1];
				int Next=e.from;
				if(!vst[Next]&&dcmp(e.cap-e.flow)>0) { 
					vst[Next]=1;
					dist[Next]=dist[Now]+1;
					if(Next==s)return 1;
					Q.push(Next);
				}
			}
		}
		return vst[s];
	}
	double dfs(int Now,double a) {
		if(Now==t||dcmp(a)==0)return a;
		double flow=0;
		for(int &i=cur[Now]; i<G[Now].size(); i++) {
			int id=G[Now][i];
			Edge &e=edges[id];
			int Next=e.to;
			if(dist[Now]-1!=dist[Next])continue;
			double nextflow=dfs(Next,min(a,e.cap-e.flow));
			if(dcmp(nextflow)>0) {
				e.flow+=nextflow;
				edges[id^1].flow-=nextflow;
				flow+=nextflow;
				a-=nextflow;
				if(a==0)break;
			}
		}
		return flow;
	}
	double maxflow(int s,int t) {
		this->s=s;
		this->t=t;
		double flow=0;
		while(bfs()) {
			memset(cur,0,sizeof(cur));
			flow+=dfs(s,1e18);
		}
		return flow;
	}
} dinic;

struct Cheese {
	int p,x,y;
} a[maxn];

int n,m,v[maxn],sum=0;
double Time[maxn];

bool Check(double t) {
	int S=n+n*m*2+1,T=n+n*m*2+2;
	dinic.init(T);
	for(int i=1; i<=n; i++) {
		dinic.AddEdge(S,i,a[i].p);
		Time[i]=a[i].x;
		Time[n+i]=a[i].y+t;
	}
	sort(Time+1,Time+2*n+1);
	for(int i=2; i<=2*n; i++) {
		double x=Time[i]-Time[i-1];
		if(x<eps)continue;
		for(int j=1; j<=m; j++) {
			int y=n+(i-1)*m+j;
			dinic.AddEdge(y,T,j*v[j]*x);
			for(int k=1; k<=n; k++)
				if(dcmp(Time[i-1]-a[k].x)>=0&&dcmp(Time[i]-a[k].y-t)<=0)dinic.AddEdge(k,y,v[j]*x);
		}
	}
	return dcmp(dinic.maxflow(S,T)-sum)>=0;
}

int main() {
	int t=Get_Int();
	while(t--) {
		n=Get_Int();
		m=Get_Int();
		sum=0;
		for(int i=1; i<=n; i++) {
			a[i].p=Get_Int();
			a[i].x=Get_Int();
			a[i].y=Get_Int();
			sum+=a[i].p;
		}
		for(int i=1; i<=m; i++)v[i]=Get_Int();
		double Left=0,Right=sum/v[1]+1;
		sort(v+1,v+m+1,greater<int>());
		for(int i=1; i<m; i++)v[i]-=v[i+1];
		while(Right-Left>eps) {
			double mid=(Left+Right)/2;
			if(Check(mid))Right=mid;
			else Left=mid;
		}
		printf("%0.4lf\n",(Left+Right)/2);
	}
	return 0;
}
```

---

## 作者：miaowey (赞：6)

myblog: http://blog.csdn.net/miaomiao\_ymxl/article/details/54849702

思路：

网络流好题

应该容易想到二分答案和离散化奶酪的时间点


先考虑朴素的建图，也就是不考虑每个时刻可以有多只老鼠在不同的小时刻吃同一个奶酪

1.我们将源点每个奶酪链流量为p[i]的边

2.然后把每只老鼠的每个时间段拆为一个点，再将其与对应的奶酪连边，流量为这只老鼠可以在这个时间段吃多少奶酪

3.所有的老鼠向汇点连边，无限流量


然而题目有限制，每个时刻可以有多只老鼠在不同的小时刻吃同一个奶酪，做法很巧妙，我们可以对老鼠的速度再进行拆点，把s[]从大到小排序然后与下一个作差，如”9 6 2 1” -> “3 4 1 1”，然后再将其与汇点连边的流量改为（rat为老鼠编号，dur为时间段大小，s为作差后的数组）rat\*s[rat]\*dur即可


为什么呢？

可以发现速度进行过如此处理之后，

```cpp
9 = 3+4+1+1
6 = 4+1+1
2 = 1+1
1 = 1
9+6+2+1 = 3*1 + 4*2 + 1*3 + 1*4
```
(下面所有的s数组均为作差后的数组)
1.所以，当我们把老鼠点到汇点的流量限制设为rat\*s[rat]\*dur后，对于每一只老鼠，它‘吃’的量不超过实际可以‘吃’的量。（上述式子解释了，实际包括编号比它小的老鼠的吃的量）

2.每个老鼠点与奶酪的连边为s[rat]\*dur，这样可以保证每只老鼠实际不可以超过自己这段时间可以吃的奶酪。

3.（对于第2点的解释）实际这段时间奶酪被吃的量不超过最快的老鼠的速度在这个时间段可以吃的量，如果每只老鼠在2点所述的边满流，那么实际相当于吃的最快的老鼠吃了这一整个时间段。而任何其它的情况均可以用别的老鼠凑出来，且由于第一点不会不合法


最后，每次二分答案，重新构图跑最大流，检查是否满流即可。


代码：

‘’























```cpp
//miaomiao 2017.2.3
#include<cstdio>
#include<cmath>
#include<cstring>
#include<algorithm>
#include<vector>
#include<queue>
using namespace std;
#define pb push_back
#define Set(a, v) memset(a, v, sizeof(a))
#define For(i, a, b) for(int i = (a); i <= (int)(b); i++)
#define MN (30+5)
#define N (3000+5)
#define eps (1e-6)
struct Edge{
    int from, to;
    double cap, flow;
};
struct Dinic{
    vector<int> G[N];
    vector<Edge> edges;
    int m, s, t;
    int cur[N], d[N]; 
    void init(){
        For(i, 0, N-1) G[i].clear();
        edges.clear(); 
    }
    void AddEdge(int u, int v, double cap){
        edges.pb((Edge){u, v, cap, 0});    
        edges.pb((Edge){v, u, 0, 0});
        m = edges.size();
        G[u].pb(m-2); G[v].pb(m-1);
    }
    bool Bfs(){
        queue<int> q;
        q.push(s); Set(d, 0);
        d[s] = 1; 
        int now;
        while(!q.empty()){
            now = q.front(); q.pop();
            For(i, 0, G[now].size()-1){
                Edge &e = edges[G[now][i]];
                if(!d[e.to] && e.cap-e.flow > eps){
                    d[e.to] = d[now]+1;
                    q.push(e.to);
                }
            }
        }
        return d[t];
    }
    double dfs(int now, double Mint){
        if(Mint < eps || now == t) return Mint;
        double f;
        double ret = 0.0;
        for(int &i = cur[now]; i < G[now].size(); i++){
            Edge &e = edges[G[now][i]];
            if(d[e.to]==d[now]+1 && (f=dfs(e.to, fmin(Mint, e.cap-e.flow)))>eps){
                e.flow += f; Mint -= f;
                edges[G[now][i]^1].flow -= f;
                ret += f;
                if(Mint < eps) return ret;
            }
        }
        return ret;
    }
    double Maxflow(){
        double ret = 0.0;
        while(Bfs()){
            Set(cur, 0);
            ret += dfs(s, (1LL<<60)*1.0);
        }
        return ret;
    }
}Din;
int n, m;
double L, R, rp[MN], rr[MN], rd[MN], rs[MN], Ti[MN*2];
void solve(){
    double mid, la, sum = 0;
    int pn;
    For(i, 1, n) sum += rp[i];
    while(R-L > eps){
        mid = (L+R)/2.0;
        Din.init();
        For(i, 1, n) Din.AddEdge(0, i, rp[i]);
        For(i, 1, n){
            Ti[2*i-1] = rr[i]; Ti[2*i] = rd[i]+mid;            
        }
        sort(Ti+1, Ti+2*n+1);
        Din.s = 0; Din.t = m*2*n+n+1; pn = n;
        For(rat, 1, m){
            la = Ti[1];
            For(i, 2, 2*n){
                if(Ti[i]-la < eps) continue;
                ++pn; Din.AddEdge(pn, Din.t, rat*rs[rat]*(Ti[i]-la));
                For(j, 1, n)
                    if(rr[j]-la < eps && (rd[j]+mid)-Ti[i] > -eps)
                        Din.AddEdge(j, pn, rs[rat]*(Ti[i]-la));
                la = Ti[i];
            }
        }
        if(sum-Din.Maxflow() < eps) R = mid;
        else L = mid;
    }
    printf("%lf\n", L);
}
int main(){
    int T;
    double tot;
    scanf("%d", &T);
    while(T--){
        tot = 0.0;
        scanf("%d%d", &n, &m);
        For(i, 1, n) scanf("%lf%lf%lf", &rp[i], &rr[i], &rd[i]), tot += rp[i];
        For(i, 1, m) scanf("%lf", &rs[i]); sort(rs+1, rs+m+1, greater<int>());
        R = tot/rs[1] + 1.0; L = 0;
        For(i, 1, m-1) rs[i] -= rs[i+1];
        solve();
    }
    return 0;
}
‘’
```

---


# [CTSC1999] 家园 / 星际转移问题

## 题目描述

由于人类对自然资源的消耗，人们意识到大约在 2300 年之后，地球就不能再居住了。于是在月球上建立了新的绿地，以便在需要时移民。令人意想不到的是，2177 年冬由于未知的原因，地球环境发生了连锁崩溃，人类必须在最短的时间内迁往月球。

现有 $n$ 个太空站位于地球与月球之间，且有 $m$ 艘公共交通太空船在其间来回穿梭。每个太空站可容纳无限多的人，而太空船的容量是有限的，第 $i$ 艘太空船只可容纳  $h_i$ 个人。每艘太空船将周期性地停靠一系列的太空站，例如 $(1,3,4)$ 表示该太空船将周期性地停靠太空站 $134134134\dots$。每一艘太空船从一个太空站驶往任一太空站耗时均为 $1$。人们只能在太空船停靠太空站(或月球、地球)时上、下船。

初始时所有人全在地球上，太空船全在初始站。试设计一个算法，找出让所有人尽快地全部转移到月球上的运输方案。

## 说明/提示

#### 数据规模与约定

对于 $100\%$ 的数据，保证：

- $1 \leq n \leq 13$。
- $1 \leq m \leq 20$。
- $1 \leq k \leq 50$。
- $1 \leq r_i \leq n + 2$。
- $-1 \leq S_{i, j}\leq n$。

## 样例 #1

### 输入

```
2 2 1
1 3 0 1 2
1 3 1 2 -1
```

### 输出

```
5```

# 题解

## 作者：litble (赞：68)

思路：枚举+并查集+最大流

感觉楼下用答案枚举超过一个大数就说明无解不太科学......还是用并查集判断是否有解法。将一艘飞船可以到达的所有星球并查集连起来，最后如果地球和月球无法连接，则无解。

然后枚举答案。

所有的点为“第i个星际站在第t秒”这样一个状态的点，那么枚举的答案每增加1，就需要新建“一套”地球和太空站的点。

源点向每一个“地球”连一条容量为inf的边，每个空间站向下一时间的该空间站连一条容量为inf的边，代表时间间的转移。

每个飞船现在在哪个星球，下一秒会飞到哪一个星球都可以计算得到，所以直接连边，容量为飞船载人量。

月球就是汇点。

然后跑最大流，如果最大流大于需要转移的人数了，那么就得到了解。

由于我用的最大流算法是dinic，所以枚举然后每次建立新边，在残量网络上跑最大流，反而比二分答案后建立新图重跑最大流快。

代码里的说明不是很详细，因为说明都在上面了。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int inf=0x3f3f3f3f,M=1000005;
int n,m,k,s,t,tot=1,ans,mx;
int f[100],p[100],g[100][100],num[100];//这里不开这么大第二个点会RE，不知道为什么
int ne[M],to[M],h[M],flow[M],lev[M],q[M];
int find(int x) {
    if(f[x]==x) return x;
    f[x]=find(f[x]);return f[x];
}
void uni(int x,int y) {//并查集的连接操作
    x=find(x),y=find(y);
    if(x!=y) f[x]=y;
}
void add(int x,int y,int z) {
    to[++tot]=y,ne[tot]=h[x],h[x]=tot,flow[tot]=z;
    to[++tot]=x,ne[tot]=h[y],h[y]=tot,flow[tot]=0;
}
int dfs(int x,int liu) {
    if(x==t) return liu;
    int kl,sum=0;
    for(int i=h[x];i;i=ne[i])
        if(flow[i]>0&&lev[to[i]]==lev[x]+1) {
        kl=dfs(to[i],min(flow[i],liu-sum));
        sum+=kl,flow[i]-=kl,flow[i^1]+=kl;
        if(sum==liu) return sum;
    }
    return sum;
}
int bfs() {
    for(int i=1;i<=ans*(n+1);++i) lev[i]=0;
    int he=1,ta=1,x;lev[t]=0,q[1]=s;
    while(he<=ta) {
        x=q[he],++he;
        if(x==t) return 1;
        for(int i=h[x];i;i=ne[i])
            if(flow[i]>0&&!lev[to[i]])
            lev[to[i]]=lev[x]+1,q[++ta]=to[i];
    }
    return 0;
}
int main()
{
    int x,y;
    scanf("%d%d%d",&n,&m,&k);
    s=0,t=M-2;
    for(int i=1;i<=n+2;++i) f[i]=i;
    for(int i=1;i<=m;++i) {
        scanf("%d%d",&p[i],&num[i]);
        for(int j=0;j<num[i];++j) {
            scanf("%d",&g[i][j]);
            if(g[i][j]==0) g[i][j]=n+1;
            if(g[i][j]==-1) g[i][j]=n+2;
            if(j!=0) uni(g[i][j-1],g[i][j]);
        }
    }
    if(find(n+1)!=find(n+2)) {puts("0");return 0;}//如果没有转移方案
    for(ans=1;;++ans) {//枚举答案
        add(s,(ans-1)*(n+1)+n+1,inf);//n+1是地球，汇点是月球。向地球连inf的边
        for(int i=1;i<=m;++i) {
            x=(ans-1)%num[i],y=ans%num[i];
            if(g[i][x]==n+2) x=t;
            else x=(ans-1)*(n+1)+g[i][x];
            if(g[i][y]==n+2) y=t;
            else y=ans*(n+1)+g[i][y];
            add(x,y,p[i]);//一艘飞船一条边
        }
        while(bfs()) mx+=dfs(s,inf);//dinic网络流
        if(mx>=k) {printf("%d\n",ans);return 0;}
        for(int i=1;i<=n+1;++i) add((ans-1)*(n+1)+i,ans*(n+1)+i,inf);//时间间的转移
    }
    return 0;
}

```

---

## 作者：Adove (赞：59)

这是一道分层图最大流问题

样例的分层图大概长这样↓

![](https://cdn.luogu.com.cn/upload/pic/15957.png)

按时间分层，连边，跑最大流即可，dinic利用残量网络可以跑得更快一些。

对于无解的判断可以用并查集。

上代码↓

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;

const int INF=2e9;

int n,m,s,t,np=1,p,mfl;
int l[21][21],f[21],h[5005],cur[5005],tp[5005],q[50050];
struct rpg{
	int li,nx,ln;
}a[50050];

void add(int ls,int nx,int ln){
	a[++np]=(rpg){h[ls],nx,ln};
	h[ls]=np;
	a[++np]=(rpg){h[nx],ls,0};
	h[nx]=np;
}

int find(int x){
	if(f[x]==x) return x;
	else return f[x]=find(f[x]);
}void un(int a,int b){
	int fa=find(a),fb=find(b);
	if(fa!=fb) f[fa]=fb;
}

bool bfs(int ps){
	memset(tp,0,sizeof(tp));
	int hd=1,tl=1;
	q[hd]=s;
	tp[s]=1;
	while(hd<=tl){
		int nw=q[hd++];
		for(int i=h[nw];i;i=a[i].li){
			if(a[i].ln&&!tp[a[i].nx]){
				tp[a[i].nx]=tp[nw]+1;
				q[++tl]=a[i].nx;
			}
		}
	}return tp[t];
}

int dfs(int u,int maxn){
	if(u==t||!maxn) return maxn;
	int sum=0;
	for(int& i=cur[u];i;i=a[i].li){
		if(a[i].ln&&tp[a[i].nx]==tp[u]+1){
			int f=dfs(a[i].nx,min(maxn,a[i].ln));
			if(f){
				maxn-=f;
				sum+=f;
				a[i].ln-=f;
				a[i^1].ln+=f;
				if(!maxn) break;
			}
		}
	}return sum;
}

void dnc(int ps){
	while(bfs(ps)){
		for(int i=0;i<=ps;++i) cur[i]=h[i];
		while(int d=dfs(s,INF)) mfl+=d;
	}
}

int main(){
	
	scanf("%d%d%d",&n,&l[0][0],&p);t=n+1;
	for(int i=1;i<=n+1;++i) f[i]=i;
	
	for(int i=1;i<=l[0][0];++i){
		scanf("%d%d",&l[0][i],&l[i][0]);
		for(int j=1;j<=l[i][0];++j){
			scanf("%d",&l[i][j]);
			if(l[i][j]==-1) l[i][j]=n+1;
			if(j>1) un(l[i][j],l[i][j-1]);
		}
	}if(find(0)!=find(n+1)){
		puts("0");
		return 0;
	}
	
	for(int ti=1;;++ti){
		
		for(int i=0;i<=n;++i){
			add(i+(ti-1)*(n+2),i+ti*(n+2),INF);
		}add(n+1+ti*(n+2),n+1+(ti-1)*(n+2),INF);
		for(int i=1;i<=l[0][0];++i){
			int tmp=(ti-1)%l[i][0]+1;
			add(l[i][tmp]+(ti-1)*(n+2),l[i][ti%l[i][0]+1]+ti*(n+2),l[0][i]);
		}
		
		dnc((ti+1)*(n+2));
		if(mfl>=p){
			printf("%d\n",ti);
			return 0;
		}
		
	}return 0;
}
```

---

## 作者：LittleFall (赞：31)

菜鸡大学生放一下用*效率*和*行数*换来的*可读性*（真的有吗）代码题解。

---
### 算法思路
整体思路是使用并查集判断是否有解，再按时间分层建图，然后**枚举时间**在残量网络中跑最大流看什么时候最大流大于等于人数，当前时间就是答案。

建图方法其它大佬说的很详细了，我这里就直接说了：

1. 层: $0$到$t$层，表示时间，每层有$(n+2)$个点数.
2. 节点: 
	- 源点: $0$ 
	- 汇点: $(n+2)*t+n+1$（第t层的月球）
	- 第f层地球: $(n+2)*f+0$
	- 第f层空间站i: $(n+2)*f+i$
	- 第f层月球: $(n+2)*f+n+1$.
3. 弧:
	- ($t$层节点, $t+1$层对应节点, INF)
	- ($t$层节点, $t$时刻飞船路径到达的节点, 飞船容量)
4. 最大流:
	- 满足最大流大于等于初始人数的最小时间$t$即为答案

需要注意的是，因为没有单独建源点和汇点，跑出的最大流可能会恰大于人数k，如果以等于人数k去判断，会TLE到爆炸（血泪教训）。

---
### 代码
需要C++11

1. dinic板子

可以调用的函数一共有两个，分别是添加边的addEdge和求最大流的maxflow。
addEdge会自动添加反向弧。

```cpp
struct Dinic
{
    void addEdge(int from, int to, int cap);
    int maxflow(int _s, int _t);
}dinic;
```
需要两个全局常数 `const int M = 100016, INF = 1000000007;`

2. 飞船

get_path可以接收天数，返回某条弧的起始点。
```cpp
struct SpaceShip
{
	int limit; //人数限制
	int cycle; //周期
	vector<int> path; //路径
	pair<int,int> get_path(int day)
	{
		return {path[day%cycle], path[(day+1)%cycle]};
	}
}ship[32];
```

3. 并查集

为了减少全局变量和全局函数强行struct。
```cpp
struct UnionFindSet
{
	int fa[20]={};
	void init()
	{
		for(int i=1;i<20;++i)
			fa[i] = i;
	}
	int find(int a)
	{
		return fa[a]==a ? a : fa[a]=find(fa[a]);
	}
	void add(int a, int b)
	{
		fa[find(a)] = find(b);
	}
	bool check(int a, int b)
	{
		return find(a) == find(b);
	}
}ufs;
```

    
4. 主干代码: 读入与判断无解


```cpp
	int n=read(), m=read(), k=read(); //太空站数,太空船数,人数
	ufs.init();
	for(int i=0; i<m; ++i)
	{
		ship[i].limit = read();
		ship[i].cycle = read();
		for(int j=0; j<ship[i].cycle; ++j)
		{
			int star=read();
			if(star==-1) star=n+1; //将月球的-1变成n+1
			ship[i].path.push_back(star);
			ufs.add(star, ship[i].path[0]);
		}
	}
	if(!ufs.check(0,n+1))
	{
		printf("0\n");
		return 0;
	}
```

5. 主干代码：枚举答案
```cpp
	for(int day=1, maxflow=0; ; ++day)
	{
		int off1 = (day-1)*(n+2), off2 = day*(n+2); //上一层和本层的偏移量
		for(int i=0; i<=n+1; ++i)
			dinic.addEdge(off1+i, off2+i, INF); //不转移
		for(int i=0, s, t; i<m; ++i)
		{
			tie(s,t) = ship[i].get_path(day-1);;
			dinic.addEdge(off1+s, off2+t, ship[i].limit);  //转移
		}
		maxflow += dinic.maxflow(0, off2+n+1);
		if(maxflow>=k)
		{
			printf("%d\n",day );
			return 0;
		}
	}
```

除了这些之外，还有一个快读板子，因为和题目关系不大，就不单独列出了。

### 完整代码
```cpp
/* LittleFall : Hello! */
#include <bits/stdc++.h>
using namespace std; typedef long long ll; inline int read();
const int M = 100016, INF = 1000000007;

struct Dinic
{
    struct Edge
    {
        int from, to, cap, flow;
    };
    int s, t; //节点数,边数,源点编号,汇点编号
    vector<Edge> edges; //边表,edges[e]和edges[e^1]互为反向弧
    vector<int> G[M]; //邻接表,G[i][j]表示节点i的第j条边在e中的序号
    bool vis[M]; //bfs用
    int d[M]; //从起点到i的距离
    int cur[M]; //当前弧下标
    void addEdge(int from, int to, int cap)
    {
        edges.push_back({from, to, cap, 0});
        edges.push_back({to, from, 0, 0});
        G[from].push_back(edges.size() - 2);
        G[to].push_back(edges.size() - 1);
    }
    bool BFS()
    {
        memset(vis, 0, sizeof(vis));
        queue<int> q;
        q.push(s);
        d[s] = 0;
        vis[s] = 1;
        while(!q.empty())
        {
            int u = q.front();
            q.pop();
            for(int id : G[u])
            {
                Edge &e = edges[id];
                if(!vis[e.to] && e.cap > e.flow)
                {
                    vis[e.to] = 1;
                    d[e.to] = d[u] + 1;
                    q.push(e.to);
                }
            }
        }
        return vis[t];
    }
    int DFS(int u, int a)
    {
        if(u == t || a == 0) return a;
        int flow = 0, f;
        for(int &i = cur[u]; i < (int)G[u].size(); ++i)
        {
            Edge &e = edges[G[u][i]];
            if(d[u] + 1 == d[e.to] && 
                (f = DFS(e.to, min(a, e.cap - e.flow))) > 0)
            {
                e.flow += f;
                edges[G[u][i] ^ 1].flow -= f;
                flow += f;
                a -= f;
                if(a == 0) break;
            }
        }
        return flow;
    }
    int maxflow(int _s, int _t)
    {
        s = _s;
        t = _t;
        int flow = 0;
        while(BFS())
        {
            memset(cur, 0, sizeof(cur));
            flow += DFS(s, INF);
        }
        return flow;
    }
}dinic;

/* 按时间分层的最大流算法
层: 表示时间,从0开始,每层有(n+2)的偏移.
节点: 
	源点: 0 
	汇点: (n+2)*t+n+1
	第f层地球: (n+2)*f+0
	第f层空间站i: (n+2)*f+i
	第f层月球: (n+2)*f+n+1.
弧:
	(t层节点, t+1层对应节点, INF)
	(t层节点, t时刻飞船路径到达的节点, 飞船容量)
最大流:
	满足最大流等于初始人数的最小时间t即为答案
*/
struct SpaceShip
{
	int limit;
	int cycle;
	vector<int> path;
	pair<int,int> get_path(int day)
	{
		return {path[day%cycle], path[(day+1)%cycle]};
	}
}ship[32];
struct UnionFindSet
{
	int fa[20]={};
	void init()
	{
		for(int i=1;i<20;++i)
			fa[i] = i;
	}
	int find(int a)
	{
		return fa[a]==a ? a : fa[a]=find(fa[a]);
	}
	void add(int a, int b)
	{
		fa[find(a)] = find(b);
	}
	bool check(int a, int b)
	{
		return find(a) == find(b);
	}
}ufs;
int main(void)
{
	#ifdef _LITTLEFALL_
	freopen("in.txt","r",stdin);
    #endif

	int n=read(), m=read(), k=read(); //太空站数,太空船数,人数
	ufs.init();
	for(int i=0; i<m; ++i)
	{
		ship[i].limit = read();
		ship[i].cycle = read();
		for(int j=0; j<ship[i].cycle; ++j)
		{
			int star=read();
			if(star==-1) star=n+1;
			ship[i].path.push_back(star);
			ufs.add(star, ship[i].path[0]);
		}
	}
	if(!ufs.check(0,n+1))
	{
		printf("0\n");
		return 0;
	}

	for(int day=1, maxflow=0; ; ++day)
	{
		int off1 = (day-1)*(n+2), off2 = day*(n+2); //上一层和本层的偏移量
		for(int i=0; i<=n+1; ++i)
			dinic.addEdge(off1+i, off2+i, INF); //不转移
		for(int i=0, s, t; i<m; ++i)
		{
			tie(s,t) = ship[i].get_path(day-1);;
			dinic.addEdge(off1+s, off2+t, ship[i].limit);  //转移
		}
		maxflow += dinic.maxflow(0, off2+n+1);
		if(maxflow>=k)
		{
			printf("%d\n",day );
			return 0;
		}
	}
    return 0;
}


inline int read(){
    int x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9') {if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
```




---

## 作者：VanillaYuzume (赞：28)

# 星际转移问题

题目:[自己康](https://www.luogu.org/problem/P2754)

## 解法:(~~咱很菜 咱不知道怎么讲这一题~~)
根据题意 和样例数据 可以yy出下面这张图

![](https://cdn.luogu.com.cn/upload/image_hosting/w3dld7mc.png)

每个点可能会存多次 而每条边也会根据时间变化发生改变      
所以 我们以时间为基准 来进行分层     
此时 问题就转变为 从0开始枚举时间 每次枚举时间后 添加一定量的边  
使新图与旧图产生联系 当图中的最大流量比总人数大的时候 输出这时的时间

因为飞船会根据一定周期发生位置变化 所以我们可以通过 **当前时间mod周期**
当前时间 飞船所在的位置 和 飞船上一时间所在的位置  
之后 我们把两个位置连在一起 其中 这条边的权值为飞船$i$的容量$hp[i]$  
$ship[i][j]$ 第 $i$ 艘船在周期中第 $j$ 次的位置     
 
根据yy的图可以发现 以源点为0来计算    
不同的点(出去源点和汇点)共有n+2个(n个太空站 地球 月球)   
(下面n=n+2_(:зゝ∠)_)                     
**把每个空间站(包括地月)与它们在上一天的点连在一起**
```cpp
ae((day-1)*n+i,day*n+i,inf);
ae(day*n+i,(day-1)*n+i,0);
```

之后依次枚举每个飞船的情况 把飞船当前点与它们在上一天的点连在一起  
(!注 每条边为飞船的容量

**代码酱 OVO↓**

```cpp
//CTSC1999 家园
#include <bits/stdc++.h>
using namespace std;

#include <bits/stdc++.h>
using namespace std;

#define N 500001
#define M 100
#define maxt 500
#define v to[i]
#define inf 0x7f7f7f7f

int n,m,k,s,t;
int sum,ans,day;//day:0->maxt
int dep[N],vis[N];
int ship[M][M],turn[M],hp[M];//船[i]在[j]时刻的位置 船i的循环周期 船i容量 
int head[N],to[N],from[N],nex[N],w[N],ecnt;

void ae(int x,int y,int z){
    from[ecnt]=x;
    to[ecnt]=y;
    w[ecnt]=z;
    nex[ecnt]=head[x];
    head[x]=ecnt++;
}

bool bfs(){
    memset(dep,-1,sizeof(dep));
    queue<int> q;
    dep[s]=1;
    q.push(s);
    while(!q.empty()){
        int u=q.front();
        q.pop();
        for(int i=head[u];i!=-1;i=nex[i]){
            if(dep[v]==-1 and w[i]>0){
                dep[v]=dep[u]+1;
                q.push(v);
            }
        }
    }
    return dep[t]!=-1;
}

int dfs(int u,int low){
    if(u==t)
        return low;
    int ret=low;
    for(int i=head[u];i!=-1;i=nex[i]){
        if(dep[v]==dep[u]+1 and w[i]>0){
            int flow=dfs(v,min(ret,w[i]));
            if(flow>0){
                w[i]-=flow;
                w[i^1]+=flow;
            }
            ret-=flow;
            if(!ret)
                break;
        }
    }
    return low-ret;
}

int dinic(){
    int res=0;
    while(bfs()){
        res+=dfs(s,inf);
    }
    return res;
}

void init(){
    int x;
    scanf("%d%d%d",&n,&m,&k);
    n+=2;//n=太空站数+2(地球+月球
    for(int i=1;i<=m;i++){
        scanf("%d%d",&hp[i],&turn[i]);
        for(int j=1;j<=turn[i];j++){
            scanf("%d",&ship[i][j]);
            ship[i][j]+=2;//月球1 地球2 其他星球全+2
        }
    }
}

int main(){
    init();
    sum=0,day=0;
    memset(head,-1,sizeof(head));
    s=0,t=10000;//乱搞 把汇点设为一个很大的数
    
    while(day<maxt){    
        
        ae(s,day*n+2,inf);//第day天的地球和源点连在一起
        ae(day*n+2,s,0);
        
        ae(day*n+1,t,inf);//第day天的月亮和汇点连在一起
        ae(t,day*n+1,0);
        
        if(day!=0){//如果不是第0天 即初状态
            for(int i=1;i<=n;i++){//把同一星球前后两天连起来
                ae((day-1)*n+i,day*n+i,inf);
                ae(day*n+i,(day-1)*n+i,0);
            }
            for(int i=1;i<=m;i++){
                //通过取余得到第day天 飞船i到循环的哪个地方
                int x=ship[i][(day-1)%turn[i]+1];//上一个地方
                int y=ship[i][day%turn[i]+1];//下一个地方
                ae((day-1)*n+x,day*n+y,hp[i]);
                ae(day*n+y,(day-1)*n+x,0);
            }
        }
        
        sum+=dinic();
        if(sum>=k)
            break;
        day++;
    }
    if(day==maxt){
        printf("0\n");
        return 0;
    }
    else{
        printf("%d\n",day);
        return 0;
    }
    return 0;
}
```

---

## 作者：谦谦君子 (赞：9)

# 算法：网络流（最大流）+并查集（判联通）


# 思路：
我们发现每一天飞船停靠的地方是不一样的，于是我们~~很自然~~佛瑞想到我们可以对每个空间站的每个时间点进行拆点（就相当于是一个动态图，每过一个时间点都可以建一个图）
总结来说就是对于这种一个点（表面意义上的一个点，比如说一个位置）对应多种情况的（比如说随着时间的推移有着不同的状态，而且这种状态>2），我们考虑在类似于分层图上面跑网络流。

## 接下来是建图：


首先地球是起始站，源点肯定要向每个时刻的地球连边吧，容量INF。然后月球是终点，所以要向每个时刻的月球连边，容量INF。之后对于在空间站的人们就是两种情况：
1. 人们可以选择此时在该空间站的飞船，飞向下一个空间站（/地球/月球）。
2. 无法移动，所以留在此处。

显然我们把时刻拆开之后，很轻易就能计算出对于每个飞船，当前时刻的位置和下一时刻的位置，直接在分层图上连边即可，容量为最大载重。因为人有可能无法移动，而且空间站的容量为无限大，所以对于每个空间站，要向下一个时刻连一条边，容量INF。
## 总结来说：
-  源点向每个时刻的地球连容量为INF的边
-  同理，向每个时刻的月球连容量为INF的边
-  t时刻的x空间站向t+1时刻的x空间站连一条边（人们可以留在该空间站）
-  若x空间站可以到达y空间站，则从t时刻的x空间站在向t+1时刻的y空间站连一条流量为飞船流量限制的边

**最后，当当前的最大流已经超过总人数时，则此时所有人都已经被运到月球，此时输出时间就好了**

# 最后的最后，注意：
-  首先需要判断是否会有答案，即地球到太阳是否连通，在这里用并查集就可以了
-  注意n要+=2，地球和月球也算空间站

**这些都理解以后就是一个板子题了!**

# 代码附上：(dinic)
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=100005;
const int maxm=1005;
const int INF=0x3f3f3f3f;
int n,m,k,Time,Tot,sum,tot=1,S,T=10000;
//S,T即起点，终点
int head[maxn],dep[maxn],cur[maxn],fa[maxn],num[maxn],cap[maxn],to[maxm][maxm];
//没啥好说的
vector<int> v[maxm];
queue<int> q;
struct node
{
	int from,to,next;
	int val;
}edge[maxn];

inline int read()
{
	int s=0,f=1;
	char c=getchar();
	while (c<'0'||c>'9')
	{
		if (c=='-')
		{
			f=-1;
		}
		c=getchar();
	}
	while (c>='0'&&c<='9')
	{
		s=s*10+c-48;
		c=getchar();
	}
	return s*f;
}

inline void add(int x,int y,int z)
{
	edge[++tot].next=head[x];
	edge[tot].from=x;
	edge[tot].to=y;
	edge[tot].val=z;
	head[x]=tot;
	edge[++tot].next=head[y];
	edge[tot].from=y;
	edge[tot].to=x;
	edge[tot].val=0;
	head[y]=tot;
}
//链式前向星,双向边
inline int find(int x)
{
	if (fa[x]==x)
	{
		return x;
	}
	else
	{
		return fa[x]=find(fa[x]);
	}
}
//并查集
inline void unionn(int x,int y)
{
	int sx=find(x),sy=find(y);
	if (sx!=sy)
	{
		fa[sx]=sy;
	}
}
//判断连通
inline bool bfs()
{
	memset(dep,-1,sizeof(dep));
	memcpy(cur,head,sizeof(head));
	q.push(S);
	dep[S]=0;
	while (!q.empty())
	{
		int u=q.front();
		q.pop();
		for (int i=head[u];i;i=edge[i].next)
		{
			int v=edge[i].to;
			if (dep[v]==-1&&edge[i].val)
			{
				dep[v]=dep[u]+1;
				q.push(v);
			}
		}
	}
	if (dep[T]==-1)
	{
		return false;
	}
	return true;
}
inline int dfs(int u,int low)
{
	if (u==T)
	{
		return low;
	}
	int ret=low;
	for (int i=head[u];i;i=edge[i].next)
	{
		int to=edge[i].to,w=edge[i].val;
		if (dep[to]==dep[u]+1&&w>0)
		{
			int flow=dfs(to,min(ret,w));
			if (flow>0)
			{
				edge[i].val-=flow;
				edge[i^1].val+=flow;
			}
			ret-=flow;
			if (!ret)
			{
				break;
			}
		}
	}
	return low-ret;
}
inline int dinic()
{
	int ret=0;
	while (bfs())
	{
		ret+=dfs(S,INF);
	}
	return ret;
}

//dinic板子不多说
int mian()							//不要直接复制哦
{
	n=read(),m=read(),k=read();
	for (int i=1;i<=n+2;i++)
	{
		fa[i]=i;
	}
	for (int i=1;i<=m;i++)
	{
		cap[i]=read(),num[i]=read();
		for (int j=1;j<=num[i];j++)
		{
			int p=read();
			if (p==-1)
			{
				p=n+2;
			}
			else if (p==0)
			{
				p=n+1;
				//方便一点
			}
			v[i].push_back(p);
			if (j!=1)
			{
				unionn(p,v[i][v[i].size()-2]);
			}
		}
	}
	//v存的是每个飞船停留的地方
	if (find(n+1)!=find(n+2))
	{
		cout<<"0"<<endl;
		return 0;
	}
	n+=2;
	add(S,n-1,INF);
	add(n,T,INF);
	while (1)
	{
		Time++;
		//枚举每个时间段
		for (int i=1;i<=m;i++)
		{
			int now=v[i][Time%num[i]],pre=v[i][(Time-1+num[i])%num[i]];
			add(n*(Time-1)+pre,n*Time+now,cap[i]);
		}
		add(S,n*Time+n-1,INF);
		add(Time*n+n,T,INF);
		for (int j=1;j<=n;j++)
		{
			add((Time-1)*n+j,Time*n+j,INF);
		}
		//建图
		sum+=dinic();
		if (sum>=k)
		{
			cout<<Time<<endl;
			break;
		}
	}
	return 0;
}
```
**不要复制！！！后果自负qaq**

## 求赞ovo最后看完觉得有帮助的点个赞再走哦qaq


---

## 作者：Aftglw (赞：7)

# [P2754 星际转移问题](https://www.luogu.com.cn/problem/P2754)

## 思路

首先，对于地球能否到达月球的问题，考虑使用并查集维护。

对于每艘飞船能够到达的站点，放进一个集合里，若两艘飞船的集合有交集，那么就合并两个集合，最后只要地球和月亮在同一个集合里即可到达。

然后就是多少天送完的问题。

想要最少天数送完，那么每次就尽可能地多送，考虑最大流。

那么怎么建图？

先放 $n+4$ 个点（ $n$ 个空间站 + 地球和月球 + 源点 +汇点 ），想当然地，源点-->地球，容量为 $k$ （初始时地球上的人数），月球指向汇点，容量 $inf$ 。（这里为了方便，地球为 $0$ ，月球为 $n+1$ ）

![](https://cdn.luogu.com.cn/upload/image_hosting/hpcqii3z.png)

那么怎么表示太空船在各个太空站之间的移动呢？

分层。

按时间分层。举个例子：存在第 $i$ 艘飞船的航线为 $(3,1,2)$ ，那么在第一个时刻，它在第 $3$ 个空间站；在第二个时刻，它在第 $1$ 个空间站；以此类推。于是我们连接第一时刻的 $3$ 与第二时刻的 $1$ ，即 $(1,3)$ --> $(2,1)$ ，容量为 $h_i$ （第 $i$ 艘飞船的容量）。当 $(1,3)$ 有流向 $(2,1)$ 的流时，就表示第一时刻到第二时刻，有人乘坐第 $i$ 艘飞船从空间站 $3$ 到了空间站 $1$ 。

这样便得到了一个横向为时间，纵向为站点的分层图。

又因为地球、月球、空间站的容量无限，所以各个站点在每个时刻联通，即 $(1,x)$ --> $(2,x)$ --> $(3,x)$ --> $\dots$ , $x$ 为 $n+2$ 个站点中的任意一个，相当于人停在该站点不动。双因为，无论哪个时刻到达月球都算送达，所以每个时刻的月球都向 $t$ 连边，即 $(y,n+1)$ --> $t$ ，$y$ 为任意一个时刻。

最后从 $1$ 开始枚举时间，直到源点流出的 $k$ 份流量全部流入了汇点再跳出。

样例建图如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/tr0uzyo3.png)

直到第六个时刻，该网络的最大流才为 $1$ ，共历时 $5$ 个时刻，答案为 $5$ 。

## Code

```
#include<bits/stdc++.h>
//#define int long long //祖宗
#define mp(a,b) make_pair(a,b)
using namespace std;
inline int read()
{
	int s=0,w=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-') w=-1;ch=getchar();}
	while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
	return s*w;
}
const int N=3000,M=5e5+5;
int first[N],nex[M],to[M],w[M],num=1; 
int n,m,k,s,t,ans,Maxflow;
int h[N],r[N],p[25][25];
inline void add(int u,int v,int val)
{
	nex[++num]=first[u];
	first[u]=num;
	to[num]=v;
	w[num]=val;
}
inline void Add(int u,int v,int val)
{
	add(u,v,val);
	add(v,u,0);
}
namespace ISAP
{
	int dep[N],gap[N],cur[N],NUM;
	void bfs()
	{
		memset(dep,-1,sizeof(dep));
		queue<int> q;
		q.push(t);
		dep[t]=0;gap[0]=1;
		while(!q.empty())
		{
			int u=q.front();q.pop();
			for(int i=first[u];i;i=nex[i])
			{
				int v=to[i];
				if(dep[v]!=-1) continue;
				dep[v]=dep[u]+1;
				gap[dep[v]]++;
				q.push(v);
			}
		}
	}
	inline int dfs(int u,int in)
	{
		if(u==t) return in;
		int out=0;
		for(int i=cur[u];i;i=nex[i])
		{
			cur[u]=i;
			int v=to[i];
			if(!w[i]||dep[v]!=dep[u]-1) continue;
			int res=dfs(v,min(w[i],in-out));
			w[i]-=res;
			w[i^1]+=res;
			out+=res;
			if(out==in) return out;
		}
		gap[dep[u]]--;
		if(!gap[dep[u]]) dep[s]=NUM+1;
		dep[u]++;
		gap[dep[u]]++;
		return out;
	}
	void work(int t)
	{
		NUM=(n+1)*(t+1)+2;//当前网络的点的个数（供ISAP用，如果你是Dinic就无视它）
		bfs();
		while(dep[s]<NUM)
		{
			memcpy(cur,first,sizeof(first));
			Maxflow+=dfs(s,1e9);
		}
	}	
}
namespace UFS//并查集,判断是否联通 
{
	int fa[N];
	void init(){for(int i=0;i<N;++i) fa[i]=i;}
	inline int getfa(int u)
	{
		if(fa[u]==u) return u;
		return fa[u]=getfa(fa[u]);
	}
	inline void merge(int u,int v)
	{
		int a=getfa(u),b=getfa(v);
		if(a!=b) fa[a]=b;
	}
}
inline int turn(int t,int p){return (t-1)*(n+2)+p;}//将t时p地的位置转化为点的编号 
main()
{//0->地球
 //n+1->月球 
	using namespace UFS;
	init();
	n=read(),m=read(),k=read();s=N-1,t=N-2;
	for(int i=1;i<=m;++i)
	{
		h[i]=read();r[i]=read();
		for(int j=1;j<=r[i];++j)
		{
			p[i][j]=read();//第i艘船第j个站点的位置为p[i][j]
			if(p[i][j]==-1) p[i][j]=n+1;
			if(j!=1)merge(p[i][j],p[i][j-1]);
			//位置p[i][j]与位置p[i][j+1]之间可以通过第i艘船到达 
		}
	}
	if(getfa(0)!=getfa(n+1))
	{
		printf("0");
		return 0;
	}
	int ans=2;//枚举时间,t==1时,人都在地球上
	Add(s,turn(1,0),k);//从源点到t==1时的地球 
	Add(turn(1,n+1),t,1e9);
	Maxflow=0;
	while(1)
	{
		Add(turn(ans,n+1),t,1e8);//从当前时刻的月亮到汇点
		for(int i=0;i<=n+1;++i) Add(turn(ans-1,i),turn(ans,i),1e9);//与上一时刻
		for(int i=1;i<=m;++i)
		{
			int a=turn(ans,p[i][(ans-1)%r[i]+1]);//第i艘船第ans时刻所在的点 
			int b=turn(ans-1,p[i][(ans-2)%r[i]+1]);//第i艘船第ans-1时刻所在的点 
			//分析一下就理解了
			Add(b,a,h[i]);
		}
		ISAP::work(ans);//不用重置，每次加完边后在残余网络上跑，将每次流量累积即为该网络的最大流
		if(Maxflow>=k)
		{
			printf("%d",ans-1);
			return 0;
		}
		ans++;
	}
	return 0;
}
/*   卑劣的手打分层图
     time->			ans
place	       da1   da2   ...  ans
  |  earth     0_1   0_2   ... 0_ans
  V station_1  1_1   1_1   ... 1_ans
       .        .     .    ...   .
       .	.     .    ...   .
n+1   moon    n+1_1 n+1_2 ... n+1_ans
*/
```


---

## 作者：lolte (赞：3)

### 这是GD初二蒟蒻 $lolte$ 的题解

爆刷网络流ing

做的时候想了0.5h都没想出来怎么建模，看了一下 @litble 的题解就茅塞顿开了，于是也想去说一下我的理解。

---

在跑网络流之前，先把有无可行方案解决。使用并查集。

先把每个太空站和地球和月亮分别看成一个单独的点，然后根据太空船所停靠的点，将太空船所停靠的点**合并**。最后比较地球和月亮的**祖先节点**是否相同即可。

---

考虑按时刻递增来枚举答案，$ans$ 从 $1$ 开始不断往下枚举。

考虑网络流。

由于到达月亮的乘客即可不再管，所以可知**月亮为该网络汇点 $v$ **。

那是不是与其相对的地球就是起点了呢？

答案很明显：不是。

因为人流量延太空船的移动而移动，而地球不一定是初始点，故地球不为源点，亦可知没有符合条件的其他点可为源点。故我们设一个新点为源点 $s$，且源点与任何时刻的地球之间的流量均为 $inf$。（因为人最初在地球上）

因为人流量延太空船的移动而移动，且根据时刻来进行统计，故考虑根据时刻来建边。明显，若每个太空站以及地球分别只是一个点，那么无法表示出时刻。故考虑在每个时刻建立一套**不包括月亮**的新点，以表示时刻差异。

然后根据每艘太空船的移动，建立一条**上一时刻的点到当前时刻的点**的边，其容量显然为太空船的容量。

之后在每一时刻跑一遍网络流，若最大流不小于总人数，那么就输出答案，否则继续做。

---

### code
dinic,189ms(无O2)
```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read(){
    int x=0,f=0;
    char ch=getchar();
    for (;ch<'0'||ch>'9';ch=getchar()) f^=(ch=='-');
    for (;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';
    return f ? -x : x;
}
const int maxn=100,maxm=1000000,inf=2147483600;
int n,m,k,dep[maxm],head[maxm],q[maxm],l,r,ans,maxflow=0;
int fa[maxn],lo[maxn],g[maxn][maxn],cnt=1,qwq[maxn],cur[maxm];
int s=maxm-5,t=maxm-4;
bool vis,inq[maxm];
struct node{
    int to,nxt,w;
}e[maxm];
inline void add(int u,int v,int w) {
    e[++cnt].to=v;
    e[cnt].w=w;
    e[cnt].nxt=head[u];
    head[u]=cnt;
}
inline int getf(int x) {
    return x==fa[x] ? x : fa[x]=getf(fa[x]);
}
void merge(int a,int b) {
    int t1=getf(a),t2=getf(b);
    if (t1!=t2) {
        fa[t1]=t2;
    }
}
bool bfs(){
    memset(dep,0x7f,sizeof(dep));
    memset(inq,0,sizeof(inq));
    memcpy(cur,head,sizeof(head));
    l=1;r=0;
    q[++r]=s;inq[s]=1;dep[s]=0;
    while (l<=r) {
        int u=q[l++];
        inq[u]=0;
        for (int i=head[u];i;i=e[i].nxt) {
            int v=e[i].to;
            if (e[i].w&&dep[v]>dep[u]+1) {
                dep[v]=dep[u]+1;
                if (!inq[v]) {
                    inq[v]=1;
                    q[++r]=v;
                }
            }
        }
    }
    return dep[t]<maxm+10000;
}
int dfs(int u,int flow) {
    if (u==t) {
        maxflow+=flow;
        vis=1;
        return flow;
    }
    int goflow=0,used=0;
    for (int &i=cur[u];i;i=e[i].nxt) {
        int v=e[i].to;
        if (e[i].w&&dep[v]==dep[u]+1) {
            goflow=dfs(v,min(e[i].w,flow-used));
            if (!goflow) continue;
            e[i].w-=goflow;
            e[i^1].w+=goflow;
            used+=goflow;
            if (used==flow) break;
        }
 	}
 	return used;
}
void dinic(){
    while (bfs()) {
        vis=1;
        while (vis) {
            vis=0;
            dfs(s,inf);
        }
    }
}
int main(){
    int a=0,b=0;
    n=read();
    m=read();
    k=read();
    for (int i=1;i<=n+2;++i) fa[i]=i;
    for (int i=1;i<=m;++i) {
        qwq[i]=read();
        lo[i]=read();
        for (int j=1;j<=lo[i];++j) {
            g[i][j]=read();//记录每艘太空船每个时间所在的地方 
            if (!g[i][j]) g[i][j]=n+1;//这个是地球 
            else if (g[i][j]==-1) g[i][j]=n+2;//月亮 
            if (j>1) merge(g[i][j-1],g[i][j]);//合并 
        }
    }
    if (getf(n+1)!=getf(n+2)) {//判断 
        puts("0");
        return 0;
    }
    for (ans=1;;++ans) {//枚举时刻 
        add(s,ans*(n+1),inf);//源点向地球连边 
        add(ans*(n+1),s,0);
        for (int i=1;i<=m;++i) {
            a=(ans-1)%lo[i]+1;//上一时刻 
            b=ans%lo[i]+1;//当前 
            if (g[i][a]==n+2) a=t;//月亮 
            else a=(ans-1)*(n+1)+g[i][a];//新时刻节点 
            if (g[i][b]==n+2) b=t;//同上 
            else b=ans*(n+1)+g[i][b];
            add(a,b,qwq[i]);//建边，容量为太空船容量 
            add(b,a,0);
        }
        dinic();
        if (maxflow>=k) {
            printf("%d\n",ans);
            return 0;
        }
        for (int i=1;i<=n+1;++i) {
            add((ans-1)*(n+1)+i,ans*(n+1)+i,inf);
            add(ans*(n+1)+i,(ans-1)*(n+1)+i,0);
        }
    }
    return 0;
}
```

---

## 作者：Celtic (赞：2)

分层图最大流。

我们对于每一个时间都建一层包含地球和空间站图。

建立源点，从源点向每层的地球连边权是 $inf$ 的边，表示原来在地球上的人。

汇点就是月球。

考虑边的转移，因为每艘飞船要 $1$ 的时间从一站到下一站，所以从每两站之间都从上一层向下一层连一条容量为该飞船容量的边。

因为人下飞船后可以等待，所以对于每个空间站从上一层到下一层连边权为 $inf$ 的边。

计算答案可以二分，也可以直接枚举。从源点向汇点的最大流超过 $k$ 时这个答案就是可行的，

因为 dinic 可以在残量网络上跑所以可能枚举要比二分重新跑快。

最后是无解的情况，只需要把每艘飞船能到达的站点合并到一个并查集中，看地球和月球是否在一个并查集内即可。

$\sf{Code}$

```cpp
#include<bits/stdc++.h>
#define N 2001001
#define MAX 2001
#define re register
#define inf 1e15
using namespace std;
typedef long long ll;
typedef double db;
inline void read(re ll &ret)
{
	ret=0;re char c=getchar();re bool pd=false;
	while(!isdigit(c)){pd|=c=='-';c=getchar();}
	while(isdigit(c)){ret=(ret<<1)+(ret<<3)+(c&15);c=getchar();}
	ret=pd?-ret:ret;
	return;
}
ll n,m,k,h[N],r[N],tmp,head[N],cnt=-1,fa[N],s,t,ans,all,maxn,now[N],dep[N];
vector<ll>v[N];
struct edge
{
	ll from,to,dis,nxt;
}e[N];
inline void add(re ll u,re ll v,re ll d)
{
	e[++cnt].from=u;
	e[cnt].to=v;
	e[cnt].dis=d;
	e[cnt].nxt=head[u];
	head[u]=cnt;
	return;
}
inline ll find(re ll deep)
{
	return fa[deep]==deep?deep:fa[deep]=find(fa[deep]);
}
inline bool bfs()
{
	memset(dep,0,(maxn+1)*sizeof(ll));
	dep[t]=0;
	queue<ll>q;
	q.push(s);
	dep[s]=2;
	while(!q.empty())
	{
		re ll ver=q.front();
		q.pop();
		now[ver]=head[ver];
		for(re int i=head[ver];~i;i=e[i].nxt)
		{
			if(!dep[e[i].to]&&e[i].dis)
			{
				dep[e[i].to]=dep[ver]+1;
				q.push(e[i].to);
			}
		}
	}
	return dep[t];
}
inline ll dfs(re ll ver,re ll lim)
{
	if(ver==t)
		return lim;
	re ll out=0;
	for(re ll (&i)=now[ver];(~i)&&lim;i=e[i].nxt)
	{
		if(e[i].dis&&dep[e[i].to]==dep[ver]+1)
		{
			re ll tmp=dfs(e[i].to,min(lim,e[i].dis));
			e[i].dis-=tmp;
			e[i^1].dis+=tmp;
			lim-=tmp;
			out+=tmp;
		}
		if(!lim)
			break;
	}
	if(!out)
		dep[ver]=0;
	return out;
}
inline ll dinic(re ll s,re ll t)
{
	re ll ret=0;
	while(bfs())
		ret+=dfs(s,inf);
	return ret;
}
signed main()
{
	memset(head,-1,sizeof(head));
	read(n);
	read(m);
	read(k);
	s=0;
	t=N-1;
	for(re int i=s;i<=t;i++)
		fa[i]=i;
	for(re int i=1;i<=m;i++)
	{
		read(h[i]);
		read(r[i]);
		for(re int j=1;j<=r[i];j++)
		{
			read(tmp);
			if(tmp==-1)
				tmp=n+2;
			else if(!tmp)
				tmp=n+1;
			v[i].push_back(tmp);
			if(j>1)
			{
				re ll r1=find(v[i][j-2]),r2=find(v[i][j-1]);
				fa[r1]=r2;
			}
		}
	}
	if(find(n+1)!=find(n+2))
	{
		puts("0");
		exit(0);
	}
	for(ans=1;;ans++) 
	{
		add(s,(ans-1)*(n+1)+n+1,inf);
		add((ans-1)*(n+1)+n+1,s,0);
		maxn=ans*(n+1)+n+1;
		for(re int i=1;i<=m;i++)
		{
			re ll x=(ans-1)%r[i],y=ans%r[i];
			re ll tmp1=v[i][x],tmp2=v[i][y];
			if(tmp1==n+2)
				tmp1=t;
			else
				tmp1=(ans-1)*(n+1)+tmp1;
			if(tmp2==n+2)
				tmp2=t;
			else
				tmp2=ans*(n+1)+tmp2;
			add(tmp1,tmp2,h[i]);
			add(tmp2,tmp1,0);
		}
		all+=dinic(s,t);
		if(all>=k)
		{
			printf("%lld\n",ans);
			exit(0);
		}
		for(re int i=1;i<=n+1;i++)
		{
			add((ans-1)*(n+1)+i,ans*(n+1)+i,inf);
			add(ans*(n+1)+i,(ans-1)*(n+1)+i,0);
		}
	}
	exit(0);
}
```


---

## 作者：RemiliaScar1et (赞：2)

### 星际转移问题

题目链接 [$link$](https://www.luogu.com.cn/problem/P2754)

如果将太空船视作边的话，有解就是 $0$ 和 $n+1$ 号点联通。

所以，我们可以试着用并查集或者搜索寻找是否有解。

无解不说了，来看看有解时怎么找最快解。

直接解是不大可行的，我们可以从另外一个角度来思考：**如果我们用 $q$ 天能否将所有人运到月球**。

在网络流中，我们可以利用**分层图**的概念将流量与距离结合判断。

具体到题来讲，我们**可以将一个图分为 $q+1$ 层(每天分一层)。 使用 $<x,n>$ 来记第 $n$ 层的第 $x$ 号点**。

可以初步得到如下的点：~~请无视掉左下的输入法QwQ~~

![](https://img.imgdb.cn/item/601b6fb13ffa7d37b341060d.png)

然后考虑怎样转移。

在第 $0$ 天的时候所有人都在起点，所以 $S_0$ 向 $<0,0>$ 连一条容量为总人数 $k$ 的边。

而汇点无论在哪一天，只要你到了月球，那就算到终点了，所以所有的 $<n+1,i>$ 都要连向 $T_0$。

对于每个太空船，当天数固定时，它连接的两个空间站也是固定的。我们就依据此来建边。

比如有一个太空船，它在第一天从 $0$号 到 $1$ 号点运行，那么我们就在 $<0,0>$ 连一条边到 $<1,1>$ ，容量为太空船容 $r_i$。

但是还有个问题，人还能在空间站停留，且空间站可以容纳无限多的人，所以我们要让每一个 $x$ 和 $i$ 从 $<x,i>$ 连一条容量为 $+\infty$ 的边到 $<x,i+1>$。

一种可能的建边情况:

![](https://img.imgdb.cn/item/601b74493ffa7d37b343db83.png)

感性理解一下，原问题的每个方案都能对应一个可行流。

所以我们可以在建立出来的图中跑最大流，判定是否等于 $k$ 就可以了。

这个 $q$ 可以二分，但是这个图有一些特殊性质。

通过上面构建图的方式，我们可以知道，**这个图的点数是和 $q$ 成正比的**。

于是从网络流的原理出发，我们可以在点增多时，在原网络上直接增加，继续增广。

也就是这个题直接从小到大枚举 $q$ 可能比直接二分来得更优，反正 $q$ 也不会大到哪里去。

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N=2e5+10,M=4e5+10,INF=1e8;

int n,m,k;
int S,T;
int head[N],ver[M],nxt[M],cc[M],tot=0;
void add(int x,int y,int c)
{
	ver[tot]=y; cc[tot]=c; nxt[tot]=head[x]; head[x]=tot++;
	ver[tot]=x; cc[tot]=0; nxt[tot]=head[y]; head[y]=tot++;
}
int q[N],d[N],cur[N];
struct node
{
	int h,r,pos[22];
} sp[N];

int fa[N];
int find(int x)
{
	int x_root=x;
	while(fa[x_root]!=x_root)
		x_root=fa[x_root];
	while(x!=x_root)
	{
		int tmp=fa[x];
		fa[x]=x_root; x=tmp;
	}
	return x_root;
}

int id(int xx,int dd)
{
	return dd*(n+2)+xx;
}

bool bfs()
{
	int hh=0,tt=0;
	memset(d,-1,sizeof d);
	q[0]=S,d[S]=0,cur[S]=head[S];
	while(hh<=tt)
	{
		int x=q[hh++];
		for(int i=head[x];~i;i=nxt[i])
		{
			int y=ver[i];
			if(d[y]==-1 && cc[i])
			{
				d[y]=d[x]+1;
				cur[y]=head[y];
				if(y==T) return 1;
				q[++tt]=y;
			}
		}
	}
	return 0;
}

int find(int u,int lim)
{
	if(u==T) return lim;
	int flow=0;
	for(int i=cur[u];~i && flow<lim;i=nxt[i])
	{
		int y=ver[i];
		cur[u]=i;
		if(d[y]==d[u]+1 && cc[i])
		{
			int tmp=find(y,min(cc[i],lim-flow));
			if(!tmp) d[y]=-1;
			cc[i]-=tmp; cc[i^1]+=tmp; flow+=tmp;
		}
	}
	return flow;
}

int dinic()
{
	int res=0,flow;
	while(bfs())
	{
		while(flow=find(S,INF)) res+=flow;
	}
	return res;
}

int main()
{
	scanf("%d%d%d",&n,&m,&k);
	S=N-8,T=N-9;
	memset(head,-1,sizeof head);
	for(int i=0;i<N;++i)  fa[i]=i;
	for(int i=0;i<m;i++)
	{
		int rr,hh;
		scanf("%d%d",&rr,&hh);
		sp[i].r=rr,sp[i].h=hh;
		for(int j=0;j<hh;j++)
		{
			int x;
			scanf("%d",&x);
			if(x==-1) x=n+1;
			sp[i].pos[j]=x;
			if(j)
			{
				int lst=sp[i].pos[j-1];
				fa[find(lst)]=find(x);//并查集合并
			}
		}
	}
	if(find(0)!=find(n+1))
	{
		printf("0");
		return 0;
	}
	add(S,id(0,0),k);
	add(id(n+1,0),T,INF);
	int q=1,res=0;//从第一天开始
	while(1)
	{
		add(id(n+1,q),T,INF);//当前天数的终点向汇点连边
		for(int i=0;i<=n+1;i++)
			add(id(i,q-1),id(i,q),INF);//空间站之间的边
		for(int i=0;i<m;i++)
		{
			int r=sp[i].h;
			int a=sp[i].pos[(q-1)%r] ,b=sp[i].pos[q%r];
			add(id(a,q-1),id(b,q),sp[i].r);

		}
		res+=dinic();
		if(res>=k) break;
		++q;
	}
	printf("%d",q);
}

```

---

## 作者：issue_is_fw (赞：1)

**这个问题的难点在于如何表示时间的流逝**

$很容易想到源点是地球,然后中间一串的空间站,最后连向汇点月球$

$空间站间各自连边,流量是飞船的容量$

这样跑最大流跑出来的其实是**一天**能到的最多的人,不能满足要求

$假如我们再开一条上面的链呢?也许就能表示两天的最大流了。$

$所以思路大概有点轮廓,我们需要的是一个类似分层图的东西$

$按照时间分层,就能表示x天的最大流$

---

$每天的图都是地球-空间站-月球$

$那么源点向每一天的地球连边,容量inf$

$每一天的月球向汇点连边,容量inf$

$对于每个飞船,前一天的位置向后一天位置连边,表示时间的流逝,容量是飞船容量$

$对于每天的空间站向下一天的这个空间站连边,容量inf,表示人可以停在这个空间站$

枚举答案跑最大流即可

```
#include <bits/stdc++.h>
using namespace std;
const int inf=1e9;
const int maxn=2e5+10;
struct edge{
	int to,flow,nxt;
}d[maxn]; int head[maxn],cnt=1,ans;
void add(int u,int v,int flow){
	d[++cnt]=(edge){v,flow,head[u] },head[u]=cnt;
	d[++cnt]=(edge){u,0,head[v]},head[v]=cnt;
}
int dis[maxn],p[maxn],num[maxn],g[209][209],pre[maxn];
int n,m,k,s,t;
int find(int x){
	return x==pre[x]?x:pre[x]=find( pre[x] );
}
void join(int q,int w){
	pre[find(q)]=find(w);
}
bool bfs()
{
	queue<int>q;
	for(int i=0;i<=ans*(n+1);i++)	dis[i]=0;
	dis[t]=0;
	dis[s]=1,q.push(s);
	while( !q.empty() )
	{
		int u=q.front(); q.pop();
		for(int i=head[u];i;i=d[i].nxt )
		{
			int v=d[i].to;
			if( dis[v]==0&&d[i].flow )
			{
				dis[v]=dis[u]+1;
				if( v==t )	return true;
				q.push( v );
			}
		}
	}
	return false;
}
int dinic(int u,int flow)
{
	if( u==t )	return flow;
	int res=flow;
	for(int i=head[u];i;i=d[i].nxt)
	{
		int v=d[i].to;
		if( dis[v]==dis[u]+1&&d[i].flow )
		{
			int temp=dinic(v,min(res,d[i].flow) );
			if( temp==0 )	dis[v]=0;
			d[i].flow-=temp;
			d[i^1].flow+=temp;
			res-=temp;
		}
		if( res==0 )	break;
	}
	return flow-res;
}
int main()
{
	cin >> n >> m >> k;
	s=0,t=1e5;
	for(int i=1;i<=n+2;i++)	pre[i]=i;
	for(int i=1;i<=m;i++)//太空船 
	{
		cin >> p[i] >> num[i];
		for(int j=0;j<num[i];j++)
		{
			cin >> g[i][j];
			if( g[i][j]==0 )	g[i][j]=n+1;//起点
			if( g[i][j]==-1 )	g[i][j]=n+2;//汇点
			if( j!=0 )	join( g[i][j-1],g[i][j] ); 
		}
	}
	if( find(n+1)!=find(n+2) )
	{
		cout << 0;
		return 0;
	}
	int kk=0;
	for(ans=1;;ans++)
	{
		add( s,ans*(n+1),inf );//源点连向今天的地球 
		for(int i=1;i<=m;i++)
		{
			int x=(ans-1)%num[i],y=ans%num[i];
			if( g[i][x]==n+2 )	x=t;//月亮是汇点 
			else	x=(ans-1)*(n+1)+g[i][x];//每层有n+1个点
			if( g[i][y]==n+2 )	y=t;
			else	y=ans*(n+1)+g[i][y];
			add(x,y,p[i] );
		}
		while( bfs() )	kk+=dinic(s,inf);
		if( kk>=k )
		{
			cout << ans;
			return 0;
		}
		for(int i=1;i<=n+1;i++)
			add( (ans-1)*(n+1)+i,ans*(n+1)+i,inf );//在这个站停下来 
	}
}
```

---

## 作者：Memorize (赞：1)

这道题给出了太空船的飞行路线 相当于给出了空间站之间的关系 但是每一天飞船的位置都不一样 于是这样就启示我们以时间分层 因为总时间不确定 所以我们需要枚举答案

针对每一天建图 流量代表人数 某一时刻总流量>=k 那么就是答案

建模步骤:

1.建设源点S与地球连边 容量为inf

2.上一天的位置与这一天的位置连边 容量为载人数

3.因为人可以选择不上飞船 且空间站容量无限 所以上一天的这个位置与这一天这个位置连边 容量为inf

统计流量 >=k时即为答案






           



```cpp
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<algorithm>
#define maxn 500
using namespace std;
int n,m,k,s,t,qhead,qtail,k1=-1,d=0,ans=0;
int cost[maxn+50],p[maxn+50],boat[maxn+50][maxn+50],dis[maxn*maxn+50];
int queue[maxn*maxn+50],f[maxn*maxn+50],head[maxn*maxn+50],c[maxn*maxn+50];
struct node{
    int to,next,c;
}e[maxn*maxn+50];
void add(int u,int v,int c)
{
    e[++k1].next=head[u],e[k1].to=v,e[k1].c=c,head[u]=k1;
    e[++k1].next=head[v],e[k1].to=u,e[k1].c=0,head[v]=k1;
}
int find(int x)
{
    if(x==f[x]) return x;
    return f[x]=find(f[x]);
}
bool judge()
{
    for(int i=1;i<=m;i++) 
    for(int j=1;j<p[i];j++)
    {
        int fx=find(boat[i][j]);
        int fy=find(boat[i][j+1]);
        if(fx!=fy) f[fx]=fy;
    }
    if(find(0)!=find(n+1)) return false;
    return true;
}
bool bfs(int tail)
{
    memset(dis,-1,sizeof(dis));
    qhead=qtail=dis[t+1]=0;
    queue[++qtail]=t+1;
    while(qhead<qtail)
    {
        int p=queue[++qhead];
        for(int i=head[p];i!=-1;i=e[i].next)
        {
            if(e[i].c && dis[e[i].to]==-1)
             dis[e[i].to]=dis[p]+1,queue[++qtail]=e[i].to;
        }
    }
    if(dis[tail]==dis[t+2]) return false;
    return true;
}
int dfs(int u,int c)
{
    int inc=0;
    if(u==n+1+d*(n+2) || !c) return c;
    for(int i=head[u];i!=-1;i=e[i].next)
      if(dis[e[i].to]==dis[u]+1 && e[i].c)
      {
           int flow=dfs(e[i].to,min(e[i].c,c-inc));
           e[i].c-=flow,e[i^1].c+=flow,inc+=flow;
           if(inc==c) break;
      }
    if(!inc) dis[u]==-1;
    return inc;  
}
void Dinic(int d)
{
    for(int i=0;i<=n+1;++i) 
    add(i+(d-1)*(n+2),i+d*(n+2),0xfff);
    for(int i=1,b;i<=m;i++)
    {
b=c[i]+1<=p[i]?c[i+1]:1;
        add(boat[i][c[i]]+(d-1)*(n+2),boat[i][b]+d*(n+2),cost[i]);
        c[i]=b;
    }
    while(bfs(n+1+d*(n+2))) ans+=dfs(t+1,0xfff);
}
int main()
{
    memset(head,-1,sizeof(head));
    scanf("%d%d%d",&n,&m,&k);t=maxn*maxn;
    for(int i=0;i<=n;i++) f[i]=i;f[t]=t;
    for(int i=1;i<=m;i++)
    {
        scanf("%d%d",&cost[i],&p[i]);
        for(int j=1;j<=p[i];j++) 
        {
          scanf("%d",&boat[i][j]);
          if(boat[i][j]==-1) boat[i][j]=n+1;    
        }
    }    
    add(t+1,0,0xfff);
    for(int i=1;i<=m;i++) c[i]=1;
    while(1)
    {
        d++;Dinic(d);
        if(ans>=k) {printf("%d",d);exit(0);}
        if(d>=1010) {printf("0");exit(0);}//粗略的计算一下最大天数 当然保险也可以更大一点(别超时...) 
    }
    return 0;
}
```

---

## 作者：Infiltrator (赞：0)

[$\Large\color{#FFBBFF}\textit{Tian-Xing's blog}$](https://Tian-Xing.github.io)

------------

# Description

[传送门](https://www.luogu.com.cn/problem/P2754)

------------

# Solution

判断有无解可以使用并查集，如果最后地球和月球能处在同一个集合中，那么肯定可以到达，只是时间长短的问题。

因为多个飞船是同时飞行的，这样的问题不好直接处理。考虑星球的个数特别少，这时可以考虑按照时间轴建立分层图，$S$向每个时间点的地球连容量为$INF$的有向边，每个星球向下个时间点的同一个星球连容量为$INF$的有向边，表示这个星球的人等待到了下个时间点；每个飞船所在星球向飞船下个时间点到达的星球连容量为承载人的数量的有向边，表示可以进行飞行转移。

然后枚举时间，如果某个时间点最大流的比$k$大就输出时间，每次直接在残余网络上进行增广即可。

------------

# Code

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <queue>
using namespace std;

const int N = 50050;	
const int M = 100050;
const int INF = 999999999;

int n, m, s, t, head[N], num = 1, vis[N], d[N], mincost, maxflow, cur[N], k, a[5550][5550], fa[N], tim, b[500];

struct Node
{
	int next, to, flow;
} edge[M * 2];

void Addedge(int u, int v, int w)
{
	edge[++num] = (Node){head[u], v, w};
	head[u] = num;
}

void Add(int u, int v, int w)
{
//	cout << u << " " << v << endl;
	Addedge(u, v, w);
	Addedge(v, u, 0);
	return;
}

template <class T>
void Read(T &x)
{
	x = 0; int p = 0; char st = getchar();
	while (st < '0' || st > '9') p = (st == '-'), st = getchar();
	while (st >= '0' && st <= '9') x = (x << 1) + (x << 3) + st - '0', st = getchar();
	x = p ? -x : x;
	return;
}

template <class T>
void Put(T x)
{
	if (x < 0) putchar('-'), x = -x;
	if (x > 9) Put(x / 10);
	putchar(x % 10 + '0');
	return;
}

int Find(int x) { return fa[x] == x ? fa[x] : Find(fa[x]); }

void Merge(int a, int b)
{
	int pa = Find(a), pb = Find(b);
	if (pa == pb) return;
	else fa[pa] = pb;	
} 

bool Bfs()
{
    queue<int> q;
    for (int i = 0; i <= t; i++) d[i] = 0;
    d[s] = 1; q.push(s);
    while (!q.empty())
    {
        int u = q.front(); q.pop();
        for (int i = head[u]; i; i = edge[i].next)
            if (!d[edge[i].to] && edge[i].flow)
            {
                d[edge[i].to] = d[u] + 1;
                q.push(edge[i].to);
                if (edge[i].to == t) return 1;
            }
    }
    return 0;
}

int Dinic(int x, int flow)
{
    if (x == t || !flow) return flow;
    int rest = flow;
    for (int i = head[x]; i && rest; i = edge[i].next)
        if (edge[i].flow && d[edge[i].to] == d[x] + 1)
        {
            int v = edge[i].to;
            int tmp = Dinic(v, min(rest, edge[i].flow));
            rest -= tmp;
            edge[i].flow -= tmp;
            edge[i ^ 1].flow += tmp;
            if (!tmp) d[v] = 0;
        }
    return flow - rest;
}

int Maxflow()
{
	int maxflow = 0, tmp;
	while (Bfs())
	{
		tmp = Dinic(s, INF);
		if (tmp) maxflow += tmp;
	}
	return maxflow;
}

void Solve()
{
	while(Bfs())
	{
		for (int i = 0; i <= t; i++) cur[i] = head[i];
		maxflow += Dinic(s, INF);
	}
	return; 
}

int Id(int a, int b)
{
	if (b == t) return t;
	return (n + 1) * a + b;
}

int main()
{
	Read(n); Read(m); Read(k);
	t = 50000;
	for (int i = 1; i <= t; i++) fa[i] = i;
	for (int i = 1; i <= m; i++)
	{
		Read(b[i]); Read(a[i][0]);
		for (int j = 1; j <= a[i][0]; j++) 
		{
			Read(a[i][j]);
			if (a[i][j] == 0) a[i][j] = n + 1;
			if (a[i][j] == -1) a[i][j] = t;
			if (j > 1) Merge(a[i][j], a[i][j - 1]);
		}
		Merge(a[i][1], a[i][a[i][0]]);
	}
	if (Find(t) != Find(n + 1)) { puts("0"); return 0; }
	for (tim = 1; ; tim++)
	{
		Add(s, Id(tim - 1, n + 1), INF);
		for (int i = 1; i <= m; i++) 
		{
			int pos1 = tim % a[i][0] == 0 ? a[i][0] : tim % a[i][0], pos2 = (tim + 1) % a[i][0] == 0 ? a[i][0] : (tim + 1) % a[i][0];
		//	if (a[i][pos1] == t) continue;
			Add(Id(tim - 1, a[i][pos1]), Id(tim, a[i][pos2]), b[i]);
		}
		while(Bfs())
		{
			maxflow += Dinic(s, INF);
		}
		if (maxflow >= k) { Put(tim); return 0; }
		for (int i = 1; i <= n + 1; i++) Add(Id(tim - 1, i), Id(tim, i), INF);
	}
	return 0;
}
```

---


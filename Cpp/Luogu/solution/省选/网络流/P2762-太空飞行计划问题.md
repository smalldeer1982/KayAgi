# 太空飞行计划问题

## 题目描述

W 教授正在为国家航天中心计划一系列的太空飞行。每次太空飞行可进行一系列商业性实验而获取利润。现已确定了一个可供选择的实验集合 $ E = \{ E_1, E_2, \cdots, E_m \} $，和进行这些实验需要使用的全部仪器的集合 $ I = \{ I_1, I_2, \cdots, I_n \} $。实验 $ E_j $ 需要用到的仪器是 $ I $ 的子集 $ R_j \subseteq I $。

配置仪器 $ I_k $ 的费用为 $ c_k $ 美元。实验 $ E_j $ 的赞助商已同意为该实验结果支付 $ p_j $ 美元。W 教授的任务是找出一个有效算法，确定在一次太空飞行中要进行哪些实验并因此而配置哪些仪器才能使太空飞行的净收益最大。这里净收益是指进行实验所获得的全部收入与配置仪器的全部费用的差额。

对于给定的实验和仪器配置情况，编程找出净收益最大的试验计划。

## 说明/提示

感谢 @FlierKing 提供 spj

$1 \leq n, m \leq 50 ，1 \leq c,p < 2^{31}  $。

这道题数据是在 Windows 生成的，输入数据中所有的换行都是 `\r\n` 而不是 `\n`  
读入某实验需要用到的仪器编号的时候，可以这么读入。(感谢@zhouyonglong的提供)
```cpp
char tools[10000];
memset(tools,0,sizeof tools);
cin.getline(tools,10000);
int ulen=0,tool;
while (sscanf(tools+ulen,"%d",&tool)==1)//之前已经用scanf读完了赞助商同意支付该实验的费用
{//tool是该实验所需仪器的其中一个      
    //这一行，你可以将读进来的编号进行储存、处理，如连边。
    if (tool==0) 
        ulen++;
    else {
        while (tool) {
            tool/=10;
            ulen++;
        }
    }
    ulen++;
}
```

## 样例 #1

### 输入

```
2 3
10 1 2
25 2 3
5 6 7```

### 输出

```
1 2
1 2 3
17```

# 题解

## 作者：Ajwallet (赞：150)

更改内容：对建模图有改动

# 题目大意
有$m$个实验，`每个实验只可以进行一次`，但会获得相应的奖金，有$n$个仪器，每个实验都需要一定的仪器，`每个仪器可以运用于多个实验`，但需要一定的价值，问奖金与代价的差的最大值是多少？
# 解题思路
这道题无非是让我们权衡奖金与代价，这两者是有我没他的，怎么去处理呢，我们先建立一张图，所有的实验与源点相连，容量为其奖金，所有的器材与汇点相连，容量为其价格，中间实验与器材相连，容量为无穷大。

这个时候跑最小割，其必定会割掉连接实验或容器的边，因为中间的边的代价为无穷大，一定不会被割掉。

跑最小割相当于选择部分的实验和部分的仪器，剩下的实验和仪器就会被割掉，此时再用实验的总价值减去可能得到的最大值，即为其所要求的答案

如下图
![](https://cdn.luogu.com.cn/upload/pic/21712.png)

代码这里就不放出了，楼下的题解个个都比本蒟蒻的好，关键还是在于建模

---

## 作者：一扶苏一 (赞：105)

## Description

W  教授正在为国家航天中心计划一系列的太空飞行。每次太空飞行可进行一系列商业性实验而获取利润。现已确定了一个可供选择的实验集合E={E1，E2，…，Em}，和进行这些实验需要使用的全部仪器的集合I={I1，I2，…In}。实验Ej需要用到的仪器是I的子集Rj。配置仪器Ik的费用为ck美元。实验Ej的赞助商已同意为该实验结果支付pj美元。W教授的任务是找出一个有效算法，确定在一次太空飞行中要进行哪些实验并因此而配置哪些仪器才能使太空飞行的净收益最大。这里净收益是指进行实验所获得的全部收入与配置仪器的全部费用的差额。

对于给定的实验和仪器配置情况，编程找出净收益最大的试验计划。

## Limitation

$1~\leq~n,~m~\leq~50$

## Solution

为啥题解里没人讲证明啊QAQ

简化一下题意以后，发现题意是这样的：

> 给定一张图，有左侧的点和右侧的点，左侧的点点权为正（对应试验），右侧的点点权为负（对应器材），如果选择了左侧的某个点就必须要选右边的一部分点。要求最大化点权和。

如果将左侧的点和右侧的点之间对应连边，如果该实验要求该器材就连一条边，那么问题就被转化为了这样一个问题：

> 给定一个有向图，点有点权，选择一个子图，满足子图上如果选择了一个点就必须选择它后继的所有点。最大化点权和。

这是一个经典的网络流问题，如果一个点被选择了则后继必须被选择，那么称该图是 **闭合的**，因此该问题叫做**最大权闭合子图问题**。可以使用最小割解决。

具体的建图方法为：

> 源点向所有正权点连结一条容量为权值的边
>
> 保留原图中所有的边，容量为正无穷
>
> 所有负权点向汇点连结一条容量为权值绝对值的边

则原图的最大权闭合子图的点权和即为所有正权点权值之和减去建出的网络流图的最小割。

以下约定源点为 $s$，汇点为 $t$。

在最小割图上，如果割掉 $s$ 和 $u$ 之间的边，代表**不选择** $u$ 进入子图，如果割掉 $v$ 和 $t$ 之间的边，代表**选择** $v$ 进入子图。

求完最小割后，如果点 $i$ 与 $s$ 相连，那么子图上会选择点 $i$，如果 $i$ 与 $t$ 相连，则不选择点 $i$。

#### 考虑证明：

(部分证明内容参考[CaptainChen的博客](https://blog.csdn.net/can919/article/details/77603353))

##### 先证明得到的子图是闭合的：

首先考虑由于求得是最小割，一个点要么和 $s$ 相连，要么和 $t$ 相连，否则一定割掉它向 $s$ 或 $t$ 的一条边是没有意义的，因为割掉该边不会改变图的不连通性，最小割不会割掉它。

由于原图中的边全部是正无穷，最小割只会割掉源点和正权点之间或负权点和汇点之间的边。

考虑如果选择了正权点 $u$，为了保证 $s-t$ 不连通，必须割掉 $u$ 所有后继中的负权点。这证明了如果选择了一个正权点那么所有的后继负权点都会被选择。

如果选择了正权点 $u$，设 $v$ 是 $u$ 的后继且 $v$ 的的权值为正，由于没有割掉 $u$，通过 $u-v$ 之间的正无穷边总能使得 $s-v$ 联通，于是割掉 $s-v$ 的边是没有意义的，最小割不会割掉这条边，这证明了如果选择了一个正权点那么该点的所有后继正权点都会被选择。

点权为 $0$ 的情况同理。

考虑事实上选择的闭合子图的过程是不可能从一个负权点开始的，因为去掉这个负权点直接选择它的后继显然优于选择该点。于是只考虑选择正权点就可以包括所有的情况。证毕。

##### 再证明得到的是最大权子图：

考虑如果 $i$ 与 $s$ 联通，那么选择 $i$，否则不选择 $i$。所以最小割割掉的权值和是 不被选择的正权点权值和 + 被选择的负权点的权值的绝对值和 ，即 最小割 = $\min\{$没被选择的正权点权值和 + 被选择的负权点的权值的绝对值和$\}$

于是

$$\text{最大权闭合子图的权值和}~=~\max\{\text{被选择的点权和}\}~=~\text{正点权和} - \min\{\text{没被选择的正权点之和 + 被选择的负权点绝对值和}\}~=~\text{正点权和} - \text{最小割}$$

证毕。

于是本题只需要按照上述方法建图即可。输出方案只需要输出与 $s$ 联通的点。

## Code

```cpp
#include <cstdio>
#include <cstring>
#include <queue>
#include <vector>
#include <algorithm>
#ifdef ONLINE_JUDGE
#define freopen(a, b, c)
#endif

typedef long long int ll;

namespace IPT {
	const int L = 1000000;
	char buf[L], *front=buf, *end=buf;
	char GetChar() {
		if (front == end) {
			end = buf + fread(front = buf, 1, L, stdin);
			if (front == end) return -1;
		}
		return *(front++);
	}
}

template <typename T>
inline bool qr(T &x) {
	char ch = IPT::GetChar(), lst = ' ';
	while ((ch > '9') || (ch < '0')) lst = ch, ch=IPT::GetChar();
	while ((ch >= '0') && (ch <= '9')) x = (x << 1) + (x << 3) + (ch ^ 48), ch = IPT::GetChar();
	if (lst == '-') x = -x;
  return (ch != '\r') && (ch != '\n');
}

namespace OPT {
	char buf[120];
}

template <typename T>
inline void qw(T x, const char aft, const bool pt) {
	if (x < 0) {x = -x, putchar('-');}
	int top=0;
	do {OPT::buf[++top] = static_cast<char>(x % 10 + '0');} while (x /= 10);
	while (top) putchar(OPT::buf[top--]);
	if (pt) putchar(aft);
}

const int maxn = 110;
const int INF = 10000000;

struct Edge {
  int u, v, flow;
  Edge *nxt, *bk;

  Edge(const int _u, const int _v, const int _fl, Edge* &h) {
    this->u = _u; this->v = _v; this->flow = _fl; this->nxt = h; h = this;
  }
};
Edge *hd[maxn], *fir[maxn];
inline void cont(const int _u, const int _v, const int _flow) {
  auto u = new Edge(_u, _v, _flow, hd[_u]), v = new Edge(_v, _u, 0, hd[_v]);
  (u->bk = v)->bk = u;
}

int n, m, s, t, ans;
int MU[maxn], val[maxn], trial[maxn], tol[maxn], dist[maxn];
std::vector<int>tool[maxn];
std::queue<int>Q;

bool bfs();
int dfs(const int u, int canag);

int main() {
	freopen("1.in", "r", stdin);
  qr(m); qr(n);
  for (int i = 1, x = 0; i <= m; ++i) {
    qr(MU[i]); ans += MU[i];
    bool k;
    do {
      k = qr(x);
      tool[i].push_back(x);
      x = 0;
    } while (k);
    trial[i] = ++t;
  }
  for (int i = 1; i <= n; ++i) {qr(val[i]); tol[i] = ++t;}
  s = ++t; ++t;
  for (int i = 1; i <= m; ++i) {
    cont(s, trial[i], MU[i]);
    for (auto j : tool[i]) cont(trial[i], tol[j], INF);
  }
  for (int i = 1; i <= n; ++i) cont(tol[i], t, val[i]);
  while (bfs()) {
    for (int i = 1; i <= t; ++i) fir[i] = hd[i];
    ans -= dfs(s, INF);
  }
  for (int i = 1; i <= m; ++i) if (dist[i]) qw(i, ' ', true);
  putchar('\n');
  for (int i = tol[1]; i <= tol[n]; ++i) if (dist[i]) qw(i - m, ' ', true);
  putchar('\n');
  qw(ans, '\n', true);
  return 0;
}

bool bfs() {
  memset(dist, 0, sizeof dist);
  Q.push(s); dist[s] = 1;
  while (!Q.empty()) {
    int u = Q.front(); Q.pop();
    for (auto e = hd[u]; e; e = e->nxt) if (e->flow > 0) {
      if (dist[e->v]) continue;
      dist[e->v] = dist[u] + 1;
      Q.push(e->v);
    }
  }
  return dist[t];
}

int dfs(const int u, int canag) {
  if ((u == t) || (!canag)) return canag;
  int _flow = 0;
  for (auto &e = fir[u]; e; e = e->nxt) if (e->flow > 0) {
    int v = e->v;
    if (dist[v] != (dist[u] + 1)) continue;
    int f = dfs(v, std::min(canag, e->flow));
    _flow += f; e->flow -= f; e->bk->flow += f;
    if (!(canag -= f)) break;
  }
  return _flow;
}
```



---

## 作者：huangzirui (赞：88)

这里大概讲一下转换成最大流以后怎么输出。

一个结论就是假如我们跑的是 Dinic 那么我们最后一次网络流（这一次网络流并没有起任何作用，只是确认了无更多残余流量可以退出了。）中所有被分到层的都一定被选上了。

没有更多残余流量其实意味着这个图已经被割成了两部分，一个实验如果有层数意味着它没有被割掉（被选上了），一个仪器如果有层数意味着它已经被割掉了（也是被选上了）。

于是只要在最后输出所有有层数的点就行了。

---

## 作者：FlierKing (赞：71)

PS：本人因读入问题WA了好多次= =。第一个测试点是样例，如果手测样例过但是第一个测试点WA可以参考下我的读入方式。


以下内容参考 胡伯涛 《最小割模型在信息学竞赛中的应用》，感谢他为我们提供这么优秀的论文。

这道题是最大权闭合图。

1. 对于每个实验，连一条从s到实验，边权为实验利益的边。

2. 对于每个需要的仪器，连一条从实验到器材，边权为INF的边。

3. 对于每个仪器，连一条从器材到t，边权为器材耗费的边。

按照上面建图，求最小割即最大流，然后用实验利益总和减去最大流即为最大净收益，具体证明可以在论文中查阅。


关于求方案，由于n,m只有50，我们可以考虑枚举删除器材和t之间的边，如果删去后的最大流和原来的最大流的差值等于这条边的边权，那么这条边就是必须满流的，也就是这个器材是必要的。再根据需要的器材我们容易知道要做的实验有哪些。


最大流我用的是SAP多路增广加当前弧优化

```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <queue>
#include <vector>
#define ll long long
#define pb push\_back
#define MAXN 2000
#define MAXM 800000 
#define INF 1073741823 
using namespace std;
    int n,m,tmp,s,t,sz=1,yans,sum,rem,num,ulen,cou;
    int val[MAXN],cost[MAXN],H[MAXN],gap[MAXN],cur[MAXN],pre[MAXM],to[MAXM],v[MAXM],las[MAXN],yv[MAXM];
    vector <int> req[MAXN];
    bool canuse1[MAXN],canuse2[MAXN];
    char c[10010];
void ins(int x,int y,int z)
{
    sz++;to[sz]=y;v[sz]=z;pre[sz]=las[x];las[x]=sz;
    sz++;to[sz]=x;v[sz]=0;pre[sz]=las[y];las[y]=sz;
}
void init()
{
    s=1,t=2+n+m;
    for (int i=1;i<=n;i++)
    {
        ins(s,i+1,val[i]);
        for (int j=0;j<req[i].size();j++)
            ins(i+1,1+n+req[i][j],INF);
    }
    for (int i=1;i<=m;i++)
        ins(i+n+1,t,cost[i]);
}
void bfs()
{
    memset(gap,0,sizeof(gap));
    memset(H,-1,sizeof(H));
    H[t]=0,gap[0]=1;
    queue<int> q;
    q.push(t);
    while (!q.empty())
    {
        tmp=q.front();
        q.pop();
        for (int i=las[tmp];i;i=pre[i])
        if (H[to[i]]==-1)
        {
            H[to[i]]=H[tmp]+1;
            gap[H[to[i]]]++;
            q.push(to[i]);
        }
    }
}
int dfs(int x,int F)
{
    if (x==t) return F;
    int used=0,w;
    for (int i=cur[x];i;i=pre[i])
    if (v[i]>0&&H[to[i]]+1==H[x])
    {
        w=min(v[i],F-used);
        w=dfs(to[i],w);
        v[i]-=w,v[i^1]+=w,used+=w;
        if (v[i]>0) cur[x]=i;
        if (F==used) return F;
    }
    gap[H[x]]--;
    if (!gap[H[x]]) H[s]=t+2;
    cur[x]=las[x];
    gap[++H[x]]++;
    return used;
}
int SAP()
{
    int ans=0;
    for (int i=s;i<=t;i++)
        cur[i]=las[i];
    while (H[s]<t+2)
        ans+=dfs(s,INF);
    return ans; 
}
int main()
{
    scanf("%d%d",&n,&m);
    for (int i=1;i<=n;i++)
    {
        scanf("%d",&val[i]);
        sum+=val[i];
        memset(c,0,sizeof(c));
        cin.getline(c,10000);
        ulen=0;
        while (sscanf(c+ulen,"%d",&num)==1)
        {
            req[i].pb(num);
            if (num==0) ulen++;
            else while (num)
            {
                num/=10;
                ulen++;
            }
            ulen++;
        }
    }
    for (int i=1;i<=m;i++)
        scanf("%d",&cost[i]);
    init();
    memcpy(yv,v,sizeof(v));
    bfs();
    yans=SAP();
    for (int i=las[t];i;i=pre[i])
    {
        memcpy(v,yv,sizeof(yv));
        rem=v[i^1];
        v[i^1]=0;
        bfs();
        tmp=SAP();
        if (yans-tmp==rem) canuse1[to[i]-n-1]=true;
        v[i^1]=rem;
    }
    for (int i=1;i<=n;i++)
    {
        canuse2[i]=true;
        for (int j=0;j<req[i].size();j++)
            if (!canuse1[req[i][j]])
            {
                canuse2[i]=false;
                break;
            }
    }
    for (int i=1;i<=n;i++)
        if (canuse2[i]) printf("%d ",i);
    putchar('\n');
    for (int i=1;i<=m;i++)
        if (canuse1[i]) printf("%d ",i);
    putchar('\n');
    printf("%d",sum-yans);
    return 0;
}
···

---

## 作者：xiejinhao (赞：33)

# 0 ~~扯淡~~

好吧做完了之后并不知道题解里写的“最大权闭合图”。

当时写这题就乱构造了一下，因为在网络流 24 题中，所以大概想了一下模型。一开始想的是费用流，但是发现并不可行，因为有的实验用的仪器与其他实验有可能重复，然后就有后效性。

所以我索性建图跑了个最大流，考虑了“仪器-汇点”的边的情况，发现答案如此奇妙……后面想了一下这样的正确性显然。

~~然后就不小心过掉了~~

其实看了题解之后我才知道原来这题算法的正确名称。



# 1 正文

## 建图求解

建图比较简单，先不考虑流量什么的，显然是实验向仪器连一条有向边。

上面扯的时候已经提到费用流不是那么的可行……所以先考虑最大流。建立超级源点向实验连边，所有仪器向超级汇点连边。接下来正面考虑流量限制。

- 我们发现，实验向仪器的流量应该为 $inf$，然后超级源点向实验 $i$ 连一条流量为 $p_i$ 的边，用来限制每个实验的收益。

- 考虑仪器。应该从仪器 $j$ 向超级汇点连一条流量限制为 $c_j$ 的边。

先不考虑上面仪器费用限制的正负问题，我们来考虑这样抛出最大流是什么结果。

我们知道一个~~显然的~~事实，最大流 $=$ 最小割。既然从最大流的方向解释不了，考虑下最小割。显然 “实验-仪器” 的边是不能割断的，不然就不会最小割了（流量 $inf$）；所以只会从 “源点-实验” 和 “仪器-汇点”的边中选择。

我们上面对这两类边进行了流量限制，那么割去 “源点-实验”的边意味着我们耗费这么多代价牺牲了这个实验，也就是不选；割去“仪器-汇点”的边，意味着我们用这条的代价购买了仪器（因为我们用正权连的边）。

- 答案为实验收益的总和 $-$ 上图的最大流。

我们发现这样的构造很巧妙，因为实际上像一个小小的容斥（雾。我们选择舍弃一些实验，那么剩下的实验就是要选择的，并且再此还选择了一些仪器，所以答案显然。

考虑正确性，如何保证剩余的实验一定会用到选到的仪器，并且不会多余？我们选择割掉“源点-实验”的边时，一定要保证满流，不然就割不掉了，那么仪器也是显然。然后胡思乱想一下正确性显然。（感性理解

（如果要看严谨证明请移步其他题解）

然后就求完了。

## 思路总结

上面讲的应该比较清楚了。

- 超级源点向实验 $i$ 连一条流量为 $p_i$ 的边；

- 实验向对应仪器连一条流量为 $+∞$ 的边；

- 仪器 $j$ 向超级汇点 连一条流量为 $c_j$ 的边；

- 跑最大流，答案为“实验收入总和 - 最大流”。

好吧查了一下这就是“最大权闭合图”的板子题。感性理解就好了吧 $QwQ$~

# 代码

（~~我知道你们只看这个~~）

但是给代码前还是分析一下时间复杂度。如果使用 $dinic$ 或者 $EK$ 应该都可以过，也可以卡满。考虑最坏清空，每个实验都需要所有仪器，边数为 $nm$，然后如果能卡满，$dinic$ 就是 $O(n^3m)$，$EK$ 就是 $O(n^3m^2)$，也许能卡满。（$EK$ 是否能过本人没试过）

（所以我写的 $dinic$

当然预流推进更加优秀啦（~~而且应该是卡不满的~~

~~~cpp
#include<bits/stdc++.h>
#define inf (1 << 28)
using namespace std;

const int N = 1e2 + 10;
const int M = 6e3 + 10;

int head[N], ver[M], Next[M], edge[M], cnt;

void add(int x, int y, int v) {
	ver[++cnt] = y, edge[cnt] = v;
	Next[cnt] = head[x], head[x] = cnt;
	
	ver[++cnt] = x, edge[cnt] = 0;
	Next[cnt] = head[y], head[y] = cnt;
} 

int d[N], s, t;

bool bfs() {
	memset(d, 0, sizeof d), d[s] = 1;
	queue<int> q; q.push(s);
	while(q.size()) {
		int x = q.front(); q.pop();
		for(int i = head[x]; i; i = Next[i])
			if(edge[i] and !d[ver[i]]) {
				d[ver[i]] = d[x] + 1;
				if(ver[i] == t) return 1;
				q.push(ver[i]);
			}
	}
	return 0;
}

int dinic(int x, int flow) {
	if(x == t) return flow;
	int rest = flow, k;
	for(int i = head[x]; i and rest; i = Next[i]) 
		if(edge[i] and d[ver[i]] == d[x] + 1) {
			k = dinic(ver[i], min(rest, edge[i]));
			if(!k) d[ver[i]] = 0;
			edge[i] -= k, edge[i ^ 1] += k;
			rest -= k;
		} 
	return flow - rest;
}

int read() {
	static char c;
	static int x;
	if(c == '\n') return c = 0, -1;
	while(!isdigit(c = getchar())); 
	x = c ^ 48;
	while(isdigit(c = getchar()))
		x = x * 10 + (c ^ 48);
	return x;
}

int main() {
	int m, n, maxflow = 0, flow, sum = 0;
	scanf("%d %d", &m, &n);
	s = n + m + 1, t = s + 1, cnt = 1;
	for(int i = 1, x; i <= m; i++) { 
		scanf("%d", &x), add(s, i, x), sum += x;
		while(~(x = read())) add(i, m + x, inf);
	}
	for(int i = 1, x; i <= n; i++) 
		scanf("%d", &x), add(m + i, t, x);
	while(bfs())
		while((flow = dinic(s, inf)))
			maxflow += flow;
	for(int i = 1; i <= m; i++) 
		if(d[i]) printf("%d ", i);
	puts("");
	for(int i = 1; i <= n; i++)
		if(d[i + m]) printf("%d ", i);
	printf("\n%d\n", sum - maxflow);
	return 0;
}
~~~

# 后话

- 完结撒花❀❀❀

- 可以求波赞吗 $\rm QAQ$

---

## 作者：xMinh (赞：32)

# 来自一个蒟蒻的证明过程
### [luogu2762 太空飞行计划问题](https://www.luogu.org/problemnew/show/P2762)
这题真的太费脑子了……一开始的想法太天真，就是先用源点连接仪器，然后仪器连实验，实验和实验自连，边权是实验的净收益，但是这样后来证明是不行的，因为题面的意思是多个实验可以共用一个仪器。所以说就算某个实验的收益为负数，但是它用到的仪器能为别的实验所用，那么就相当与你花了这个实验的赞助商给你的钱为别的实验买仪器。    
实在想不出来，看题解。
应该的建图方法是源点连接实验，边权是实验经费，实验和仪器之间连inf，然后仪器和汇点之间连接，边权是买仪器的钱，这样跑出来的最大流用总经费减去就行了。    
下面看图    
![image](https://cdn.luogu.com.cn/upload/pic/14118.png)
这个图中就是一个明显的亏本实验，那么这么建图的话流到最后的就是24，赞助商给的经费，所以最后用总经费减去最大流的时候就直接减去这个经费，就相当于没选这个实验。    
对于之前pass掉我程序的那个想法，用这种建图也可以实现。    
![image](https://cdn.luogu.com.cn/upload/pic/14149.png)
正确性显然。    
这个题最难的一点就在于如何输出方案。介入本人太蒟蒻，只能看题解。题解提供的方案是最后一遍增广的分层图中有层数的，也就是遍历到的点是选过的。这个大概的解释方法就是整张图看做最小割之后分成了两个集合，一个包括源点，一个包括汇点。    
为什么要看做最小割呢？之前我们说过，如果某个实验的收益为负数，但是它用到的仪器能为别的实验所用，那么就相当与你花了这个实验的赞助商给你的钱为别的实验买仪器，具象化在这个图上，就是仪器那个点给这个实验一个流，把这个实验流出去的抵消掉了。当然，也会存在那种无论怎么买仪器都不划算的实验，这样的实验有一个特点，因为它不能供给仪器的需求，所以源点到它的残流一定是0，就是说不管是正向边还是反向边都是0，同样的那些可以供给的，源点到它的残留一定大于0，也就是正向边或者反向边大于0，说明做这个实验能赚钱。    
那么，因为这种必须要删掉的实验，它的经费最终肯定要从总经费里面减掉，我们就不算它，而剩下的那些实验，它们所需要的仪器一起流到汇点，就是最大流。所以说，最小割也是割掉这些仪器与汇点之间的边。    
由此我们可以证出，在最小割中，与源点同一集合的实验和仪器，必选。
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<queue>
#define rint register int
#define inv inline void
#define inb inline bool
#define ini inline int
#define big 1e9
using namespace std;
int n,m,all,cnt,head[10001],cur[10001],dis[10001],ans,tot,s=0,t=151;
bool flag;
struct node
{
    int from,to,dis,num,next;
}ljb[10001];
ini read()
{
    char c;int r=0;
    while (c<'0' || c>'9') c=getchar();
    while (c>='0' && c<='9')
    {
        r=r*10+c-'0';
        c=getchar();
    }
    if (c=='\r') flag=1;
    return r;
}
inv add(int x,int y,int z)
{
    ljb[++cnt].from=x;
    ljb[cnt].to=y;
    ljb[cnt].dis=z;
    ljb[cnt].num=cnt;
    ljb[cnt].next=head[x];
    head[x]=cnt;
}
queue<int> q;
inb bfs()
{
    q.push(s);
    memset(dis,128,sizeof(dis));
    dis[s]=0;
    while(!q.empty())
    {
        int x=q.front();
        q.pop();
        for (rint i=head[x];i!=-1;i=ljb[i].next)
        {
            int y=ljb[i].to;
            if (dis[y]<0 && ljb[i].dis>0)
            {
                dis[y]=dis[x]+1;
                q.push(y);
            }
        }
    }
    if (dis[t]>0) return 1;
    return 0;
}
ini dfs(int x,int low)
{
    if (x==t) return low;
    for (rint& i=cur[x];i!=-1;i=ljb[i].next)
    {
        int y=ljb[i].to;
        if (dis[y]==dis[x]+1 && ljb[i].dis>0)
        {
            int flow=dfs(y,min(low,ljb[i].dis));
            if (flow)
            {
                ljb[i].dis-=flow;
                ljb[ljb[i].num^1].dis+=flow;
                return flow;
            }
        }
    } 
    return 0;
} 
int main()
{
    m=read();n=read();
    for (rint i=s;i<=t;i++) head[i]=-1;cnt=-1;
    for (rint i=1;i<=m;i++)
    {
        int x;x=read();all+=x;
        add(s,i,x);add(i,s,0);
        flag=0;
        while (!flag)
        {
            x=read();
            add(i,x+50,big);
            add(x+50,i,0);
        }
    }
    for (rint i=1;i<=n;i++)
    {
        int x;x=read();
        add(i+50,t,x);
        add(t,i+50,0);
    }
    while (bfs())
    {
        for (rint i=s;i<=t;i++) cur[i]=head[i];
        do
        {
            tot=dfs(s,big);
            ans+=tot;
        }
        while (tot);
    }
    for (rint i=1;i<=m;i++) if (dis[i]>0) cout<<i<<" ";
    printf("\n");
    for (rint i=1;i<=n;i++) if (dis[i+50]>0) cout<<i<<" ";
    printf("\n");
    printf("%d",all-ans);
 }
```

---

## 作者：wanghaoyu1008 (赞：15)

这道题其实是网络流的经典题，我发题解整体思路不过是大众方法，但一方面想讲详细点（楼上的$dalao$都各有理解，但我一个都没懂，倒是最后的几篇让我有些思路）；另一方面是想给出另一种读入方法，以减轻大家的苦痛。

此题是求最小割，然而我刚开始并没有看出来。首先讲讲它的正确性吧：（构图其他题解已经很清楚了，实在不明白可以看程序）

我们看到，构成一个割的点集恰好是{源点及所有A（要做的实验）和a（要用的实验器材）}、{B（所有不做的实验）和b（不用的实验器材）及汇点}，此处实验要不要做是主观条件（可以做也可以不做），而实验器材用不用是根据要做的实验决定的。

由于实验及器材之间的边是不可割的，因此a（要用的实验器材）一定在A（要做的实验）的点集中；而b（不要用的实验器材）与A（要做的实验）间并无连边，因此无法通过A（要做的实验）与源点联通，就只能与B（所有不做的实验）属于同一集合啦！

我们这样给边赋值，对于每个割，用所有实验的奖金($w_A+w_B$)减去该割($w_B+w_a$)就是该方案的答案($w_A-w_a$)，最大化答案就是最小化割值。

至于最后所做实验和所用仪器，直接输出{源点及所有A（要做的实验）和a（要用的实验器材）}（其实等价于输出跑最大流时最后与源点连通的点）中的点（除源点）就好了。

以下是代码（有点压行）：
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
const int N=202;
const int M=1e4+4;
const int S=256;
const int INF=1e9+7;

int n,m;
struct graph{//最大流（最小割）模板
	int cnt,l[N],x[M],e[M],f[M],d[N];
	int hd,tl,q[N],r[N];
	graph(){cnt=1;}
	void pshe(int u,int v,int c){
		++cnt;x[cnt]=l[u];l[u]=cnt;e[cnt]=v;f[cnt]=c;
		++cnt;x[cnt]=l[v];l[v]=cnt;e[cnt]=u;f[cnt]=0;
	}
	bool bfs(){
		memset(d,0,sizeof(d));
		d[1]=1;hd=0;tl=1;q[0]=1;
		int nw,i;
		while(hd!=tl){
			nw=q[hd];++hd;
			for(i=l[nw];i;i=x[i])
				if(f[i]&&!d[e[i]]){
					d[e[i]]=d[nw]+1;
					q[tl]=e[i];++tl;
				}
		}
		return d[n+m+2];
	}
	int dfs(int v,int c){
		int i,t,w=0;
		if(v==n+m+2)return c;
		for(i=r[v];i;i=x[i])
			if(f[i]&&d[e[i]]==d[v]+1){
				t=c-w;t=dfs(e[i],min(f[i],t));
				f[i]-=t;if(f[i])r[v]=i;f[i^1]+=t;
				w+=t;if(w==c)return c;
			}
		if(!w)d[v]=0;
		return w;
	}
	int mxflw(){
		int ans=0;
		while(bfs()){memcpy(r,l,sizeof(r));ans+=dfs(1,INF);}
		return ans;
	}
}g;

inline int read(int &x){
//返回值代表本行是否还有数
//其实该读入的鲁棒性还不够好，如果行末有空格就GG了
    char c;x=0;
    while(c<'0'||c>'9')c=getchar();
    while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}
	return c=='\r'||c=='\n'?0:1;
}

int main()
{
	int i,t,w,sm=0;
	read(m);read(n);
	for(i=1;i<=m;i++){
		t=read(w);g.pshe(1,i+1,w);sm+=w;
		while(t){t=read(w);g.pshe(i+1,m+w+1,INF);}
	}
	for(i=1;i<=n;i++){read(w);g.pshe(m+i+1,n+m+2,w);}
	sm-=g.mxflw();
	for(i=1;i<=m;i++)if(g.d[i+1])printf("%d ",i);printf("\n");
	for(i=1;i<=n;i++)if(g.d[m+i+1])printf("%d ",i);
    printf("\n%d",sm);
	return 0;
}
```

既然程序已经通过测试了，就需要反思：都已经是网络流24题中的习题了（就是用网络流做，有少数题例外），为什么我一开始想不到呢？一点原因是我刚刚学网络流，许多套路还不知道；更重要的是我一看到费用就被带偏，这是一种极不可取的思路，信息学竞赛中许多题看山不是山，如果这样一定会吃亏。

至于如何想到该做法，非吾之力所能及也，我日后尽力吧，有欲求者请咨询$dalao$。

---

## 作者：邮差将军 (赞：13)

~~看见题解没有模拟退火的方法果断来一篇~~

网络流的题第一反应看模拟退火可不可行

发现数据范围才50，那么就果断上

然后就开始快乐调参数

部分成果如下
![模拟退火](https://img-blog.csdnimg.cn/20190927110703248.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzA2MTM0MA==,size_16,color_FFFFFF,t_70)

AC代码：
```cpp
#include <bits/stdc++.h>
typedef long long ll;
using namespace std;
const double dT = 0.997;
const int MAXN = 55;
int m, n;
int tim[MAXN];
int need[MAXN][MAXN], cnt[MAXN];
int pay[MAXN], cost[MAXN];
int vis[MAXN], ansvis[MAXN];//记录当前取哪些、答案取哪些
int ans = 0;

char tools[10000];
void readline(int id)
{
    scanf("%d", &pay[id]);
    memset(tools,0,sizeof(tools));
    cin.getline(tools,10000);
    int ulen=0,tool;
    while(sscanf(tools+ulen,"%d",&tool)==1)
    {
        need[id][++cnt[id]] = tool;
        if(tool==0) ulen++;
        else
        {
            while(tool)
            {
                tool/=10;
                ulen++;
            }
        }
        ulen++;
    }
}

//计算当前的花费
int calc()
{
    int ret = 0;
    memset(tim, 0, sizeof(tim));
    for(int i = 1; i <= m; i++)
    {
        if(!vis[i]) continue;
        ret += pay[i];
        for(int j = 1; j <= cnt[i]; j++)
        {
            int tool = need[i][j];
            tim[tool]++;
        }
    }
    for(int i = 1; i <= n; i++) if(tim[i]) ret -= cost[i];
    return ret;
}

void SA()
{
    double T = 1e8;
    while(T > 1e-12)
    {
        int id = rand() % m + 1;
        if(vis[id])
        {
            vis[id] = 0;
            int dans = calc();
            if(dans > ans)
            {
                ans = dans;
                for(int i = 1; i <= m; i++) ansvis[i] = vis[i];
            }
            else if(exp((1.0*(dans-ans))/T) * RAND_MAX > rand()) {}
            else vis[id] = 1;
        }
        else
        {
            vis[id] = 1;
            int dans = calc();
            if(dans > ans)
            {
                ans = dans;
                for(int i = 1; i <= m; i++) ansvis[i] = vis[i];
            }
            else if(exp((1.0*(dans-ans))/T) * RAND_MAX > rand()) {}
            else vis[id] = 0;
        }
        T *= dT;
    }
}

void output()
{
    memset(tim, 0, sizeof(tim));
    for(int i = 1; i <= m; i++)
    {
        if(ansvis[i])
        {
            printf("%d ", i);
            for(int j = 1; j <= cnt[i]; j++) tim[need[i][j]]++;
        }
    }
    putchar(10);
    for(int i = 1; i <= n; i++) if(tim[i]) printf("%d ", i);
    putchar(10);
    printf("%d\n", ans);
}

int main()
{
    srand(unsigned(time(0)));
    scanf("%d%d", &m, &n);
    for(int i = 1; i <= m; i++) readline(i);
    for(int i = 1; i <= n; i++) scanf("%d", &cost[i]);
//    for(int i = 1; i <= m; i++)
//    {
//        printf("#%d ", cnt[i]);
//        for(int j = 1; j <= cnt[i]; j++) printf("%d ", need[i][j]);
//        putchar(10);
//    }
    for(int i = 1; i <= 200; i++) SA();
    output();
    
    return 0;
}
```

---

## 作者：loceaner (赞：9)

## 思路

> 问题模型：最大权闭合图
>
> 转化模型：网络最小割

这道题是网络流中一个比较重要的模型：**最大权闭合图转最大流**

建立超级源点$S$和超级汇点$T$，然后每个实验连一条从$S$到实验，流量为实验收益的边，每个仪器连一条从仪器到$T$, 流量为仪器耗费的边，然后需要的仪器就连一条从实验到仪器流量为$inf$（无穷大）的边，因为实验到仪器的边的流量为正无穷，所以最小割一定不会在上面，根据最大流最小割定理，最大流就等于最小割，我们按照以上所说建图，求出最大流，之后用实验利益的总和减去最大流，得出的就是最大净收益

最大流算法我用的是$\text{Dinic}$算法，因为这样方便输出，为什么？因为如果$d[i]$不为$0$就说明它一定用过，这样就能方便输出啦~

## 代码

```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;

const int A = 1e5 + 11;
const int B = 1e6 + 11;
const int mod = 1e9 + 7;
const int inf = 0x3f3f3f3f;

inline int read() {
	char c = getchar(); int x = 0, f = 1;
	for ( ; !isdigit(c); c = getchar()) if(c == '-') f = -1;
	for ( ; isdigit(c); c = getchar()) x = x * 10 + (c ^ 48);
	return x * f;
}

int m, n, cnt, opt, S, T, ans, head[A], d[A], q[A];
struct node { int from, to, nxt, val; } e[A];

inline void add(int from, int to, int val) {
	e[cnt].to = to;
	e[cnt].val = val;
	e[cnt].nxt = head[from];
	head[from] = cnt++;
}

inline bool makelevel(int s, int t) {
	memset(d, 0, sizeof(d));
	memset(q, 0, sizeof(q));
	int l = 0, r = 0;
	d[s] = 1; q[r++] = s;
	while (l < r) {
		int x = q[l++];
		if (x == t) return true;
		for (int i = head[x]; i != -1; i = e[i].nxt) {
			int to = e[i].to;
			if (d[to] == 0 && e[i].val > 0) {
				d[to] = d[x] + 1;
				q[r++] = e[i].to;
			}
		}
	}
	return false;
}

int dfs(int x, int flow, int t) {
	if (x == t) return flow;
	int sum = 0;
	for (int i = head[x]; i != -1; i = e[i].nxt) {
		int to = e[i].to;
		if (d[to] == d[x] + 1 && e[i].val > 0) {
			int tmp = dfs(to, min(flow - sum, e[i].val), t);
			e[i].val -= tmp, e[i ^ 1].val += tmp;
			sum += tmp;
			if (sum == flow) return sum;
		}
	}
	return sum;
}

int main() {
	memset(head, -1, sizeof(head));
	m = read(), n = read();
	int S = 0, T = 555;
	int w, tot = 0, x;
	for (int i = 1; i <= m; i++) {
		scanf("%d", &w), tot += w;
		add(S, i, w), add(i, S, 0);
		while (getchar() == ' ') {
			scanf("%d", &x);
			add(i, x + m, inf);
			add(x + m, i, 0);
		}
	}
	for (int i = 1; i <= n; i++) {
		x = read();
		add(i + m, T, x), add(T, i + m, 0);
	}
	while (makelevel(S, T)) ans += dfs(S, inf, T);
	ans = tot - ans;
	for (int i = 1; i <= m; i++) if (d[i]) cout << i << ' '; puts("");
	for (int i = 1; i <= n; i++) if (d[i + m]) cout << i << ' '; puts("");
	cout << ans << '\n';
	return 0;
}
```

---

## 作者：封禁用户 (赞：7)

最大权闭合图模型题，最大流最小割。从起点往每个权值为正的点建立一条边，容量为点权值。每个权值为负的点往终点建立一条边，容量为权值的绝对值。如果选A就必须选B 则就从A建立一条往B的边，容量为正无穷。然后正权值加起来减去最大流就是能选出来最大权闭合图所有点加起来的值。最大权闭合图的点就是从起点开始广搜，权值为0的点不走，能走到的点就是被选中的点。dinic最后一次bfs的d数组正好可以用来判断这个条件。
```
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<vector>
#include<queue>
#define inf 0x3fffffff
using namespace std;
const int maxn=555;
int first[maxn],sign,cur[maxn];
int s,t,d[maxn];
struct node
{
    int to,w,next;
} edge[maxn*50];
void creat()
{
    memset(first,-1,sizeof(first));
    sign=0;
}
void add_edge(int u,int v,int w)
{
    edge[sign].to=v;
    edge[sign].w=w;
    edge[sign].next=first[u];
    first[u]=sign++;
  
    edge[sign].to=u;
    edge[sign].w=0;
    edge[sign].next=first[v];
    first[v]=sign++;
}
int bfs()
{
    queue<int>q;
    memset(d,0,sizeof(d));
    d[s]=1;
    q.push(s);
    while(!q.empty())
    {
        int top=q.front();
        q.pop();
        for(int i=first[top]; ~i; i=edge[i].next)
        {
            int to=edge[i].to;
            if(edge[i].w>0&&d[to]==0)
            {
                d[to]=d[top]+1;
                if(to==t)
                    return 1;
                q.push(to);
            }
        }
    }
    return d[t]!=0;
}
int dfs(int top,int flow)
{
    if(top==t)
        return flow;
    int ans=0,x=0;
    for(int i=cur[top]; ~i; i=edge[i].next)
    {
        int to=edge[i].to;
        if(edge[i].w>0&&d[to]==d[top]+1)
        {
            x=dfs(to,min(flow-ans,edge[i].w));
            edge[i].w-=x;
            edge[i^1].w+=x;
            if(edge[i].w)
                cur[top] = i;
            ans+=x;
            if(ans==flow)
                return flow;
        }
    }
    if(ans==0)
        d[top]=0;
    return ans;
}
int dinic(int n)
{
    int ans=0;
    while(bfs())
    {
        for(int i=0; i<=n; i++)
            cur[i]=first[i];
        ans+=dfs(s,inf);
    }
    return ans;
}
 
int main()
{
    int n,m;
    scanf("%d%d",&m,&n);
    creat();
    s=0,t=n+m+1;
    int sum=0;
    for(int i=1; i<=m; i++)
    {
        int x;
        char c;
        scanf("%d",&x);
        sum+=x;
        add_edge(s,n+i,x);
        while(1)
        {
            scanf("%d%c",&x,&c);
            add_edge(n+i,x,inf);
            if(c=='\n'||c=='\r')break;
        }
    }
    for(int i=1; i<=n; i++)
    {
        int w;
        scanf("%d",&w);
        add_edge(i,t,w);
    }
    sum-=dinic(t);
  
    for(int i=1; i<=m; i++)
    {
        if(d[i+n])
            printf("%d ",i);
    }
    printf("\n");
    for(int i=1; i<=n; i++)
        if(d[i])
            printf("%d ",i);
    printf("\n");
    printf("%d\n",sum);
    return 0;
}
```

---

## 作者：天上一颗蛋 (赞：5)

# P2762 太空飞行计划问题

题目描述
W 教授正在为国家航天中心计划一系列的太空飞行。每次太空飞行可进行一系列商业性实验而获取利润。现已确定了一个可供选择的实验集合E={E1，E2，…，Em}，和进行这些实验需要使用的全部仪器的集合I={I1，I2，…In}。实验Ej需要用到的仪器是I的子集RjÍI。配置仪器Ik的费用为ck美元。实验Ej的赞助商已同意为该实验结果支付pj美元。W教授的任务是找出一个有效算法，确定在一次太空飞行中要进行哪些实验并因此而配置哪些仪器才能使太空飞行的净收益最大。这里净收益是指进行实验所获得的全部收入与配置仪器的全部费用的差额。

对于给定的实验和仪器配置情况，编程找出净收益最大的试验计划。

输入输出格式
输入格式：
第1行有2 个正整数m和n。m是实验数，n是仪器数。接下来的m 行，每行是一个实验的有关数据。第一个数赞助商同意支付该实验的费用；接着是该实验需要用到的若干仪器的编号。最后一行的n个数是配置每个仪器的费用。

输出格式：
第1 行是实验编号；第2行是仪器编号；最后一行是净收益。

---

最大权闭合子图：源点连正点权（即实验收益），容量为正；负点权（器材花费）连汇点，容量为**负的负**（花费较总收益来说原本就是负的，连得时候连正的就行），有关系的实验和器材之间连边容量为正无穷，答案为**全部实验收益 - 上面图跑出来的最小割**

解释：正点之间与负点连边为INF最小割跑出来，要么割正边，**意义就是舍弃这个实验**，要么割负的负边，**意义为买器材花钱**，无论怎样，要是使得放弃实验钱与花的器材钱最少（也就是最小割），答案即为最优

# Code

```cpp
#include<iostream>
#include<cstdio>
#include<queue>
#include<cstring>
#include<algorithm>
#define ll long long
using namespace std;
int RD(){
    int out = 0,flag = 1;char c = getchar();
    while(c < '0' || c >'9'){if(c == '-')flag = -1;c = getchar();}
    while(c >= '0' && c <= '9'){out = out * 10 + c - '0';c = getchar();}
    return flag * out;
    }
const int maxn = 10019,INF = 1e9;;
int nl,nr,nume = 1;
int s,t,maxflow;
int head[maxn],cur[maxn];
struct Node{
    int v,dis,nxt;
    }E[maxn << 2];
void add(int u,int v,int dis){
    E[++nume].nxt = head[u];
    E[nume].v = v;
    E[nume].dis = dis;
    head[u] = nume;
    }
int d[maxn];
bool bfs(){
    queue<int>Q;
    memset(d,0,sizeof(d));
    for(int i = 1;i <= t;i++)cur[i] = head[i];
    Q.push(s);
    d[s] = 1;
    while(!Q.empty()){
        int u = Q.front();
        Q.pop();
        for(int i = head[u];i;i = E[i].nxt){
            int v = E[i].v;
            if(E[i].dis && !d[v]){
                d[v] = d[u] + 1;
                Q.push(v);
                if(v == t)return 1;
                }
            }
        }
    return 0;
    }
int Dinic(int u,int flow){
    if(u == t)return flow;
    int rest = flow,k;
    for(int i = cur[u];i != -1;i = E[i].nxt){
        cur[u] = i;
        int v = E[i].v;
        if(E[i].dis && d[v] == d[u] + 1){
            k = Dinic(v,min(rest,E[i].dis));
            if(!k)d[v] = 0;
            E[i].dis -= k;
            E[i ^ 1].dis += k;
            rest -= k;
            }
        if(rest == 0)break;
        }
    return flow - rest;
    }
int tot,ans;
int main(){
    memset(head,-1,sizeof(head));
    nl = RD();nr = RD();
    s = nl + nr + 1,t = s + 1;
    int temp;
    for(int i = 1;i <= nl;i++){
        temp = RD();
        tot += temp;
        add(s,i,temp);
        add(i,s,0);
        char tools[10000];
        memset(tools,0,sizeof tools);
        cin.getline(tools,10000);
        int ulen=0,tool;
        while (sscanf(tools+ulen,"%d",&tool)==1)//之前已经用scanf读完了赞助商同意支付该实验的费用
            {//tool是该实验所需仪器的其中一个      
                //这一行，你可以将读进来的编号进行储存、处理，如连边。
                add(i,tool + nl,INF);
                add(tool + nl,i,0);
                if (tool==0) 
                    ulen++;
                else {
                    while (tool) {
                        tool/=10;
                        ulen++;
                    }
                }
                ulen++;
            }
        }
    for(int i = 1 + nl;i <= nr + nl;i++){
        temp = RD();
        add(i,t,temp);
        add(t,i,0);
        }
    int flow = 0;
    while(bfs())while(flow = Dinic(s,INF))maxflow += flow;
    ans = tot - maxflow;
    if(ans < 0){
        printf("0\n");
        return 0;
        }
    for(int i = 1;i <= nl;i++){
        if(d[i])printf("%d ",i);
        }
    printf("\n");
    for(int i = 1 + nl;i <= nr + nl;i++){
        if(d[i])printf("%d ",i - nl);
        }
    printf("\n");
    printf("%d\n",ans);
    return 0;
    }
```

---

## 作者：miemieQWQ (赞：4)

仔细把握一下题意, 一个仪器可以用于多个实验, 不然就是费用流(难道不是直接贪心吗?)

大致思路:

假设先把所有的赞助全部拿到, 即没有任何仪器费用的收益.

然后再计算出仪器的费用减去, 因为有些实验可能亏钱, 不能做,

自然就得不到赞助商的报酬咯, 也要减去. 整理一下, 发现可以转化为网络**最小割**.

构图:

源点 (实验收益) 实验 (无穷大) 仪器 (实验费用) 汇点

跑一遍最大流, 一减就是答案!


**PS** 本题真正坑点在于如何读入:

因为输入数据不标准, 我们要让自己的程序适应性强

其实就是遇到'\n'就要读下一行, 搞不好疯狂TLE直接爆零

(上网搜了一下, 惊奇地发现回车和换行居然不一样 0x0A, 0x0D)

所以我们要改良一下我们的读入优化, 正确地判断结束


```cpp
#include <bits/stdc++.h> 
using namespace std;

inline bool EXrnum(int &res) //遇到'\n'跳出的读入优化 
{
    res = 0; char ch = getchar();
    while (!isdigit(ch)) { if (ch == '\n') return false; ch = getchar(); }
    while (isdigit(ch)) { res = res * 10 + ch - '0'; ch = getchar(); }
    if (ch == '\n') return false; else return true;
}

const int N = 129, oo = 0x3f3f3f3f;
struct Edge{ int to, cap, rev; };
struct NetworkFlows
{
    int m, n, Source, Sink, ans;
    int level[N], current[N];
    vector<Edge> G[N];
    
    inline void addEdge(int u, int v, int c)
    {
        int Gus = G[u].size(), Gvs = G[v].size();
        G[u].push_back((Edge){v, c, Gvs});
        G[v].push_back((Edge){u, 0, Gus});
    }
    void Build()
    {
        Source = 101, Sink = 102;
        scanf("%d%d", &m, &n);
        for (int i = 1, x; i <= m; i++)
        {
            scanf("%d", &x); ans += x; //先把所有实验的收益加起来 
            addEdge(Source, i, x); //源点与实验连边(边权为实验收益) 
            while (EXrnum(x)) addEdge(i, x + 50, oo);
            addEdge(i, x + 50, oo); //实验与匹配仪器连无穷大边 
        }
        for (int i = 1, x; i <= n; i++)
        {
            scanf("%d", &x);
            addEdge(i + 50, Sink, x); //仪器与汇点连边(边权为abs(仪器费用)) 
        }
    }
    bool BFS()
    {
        memset(current, 0, sizeof (current));
        memset(level, -1, sizeof (level));
        queue<int> q;
        q.push(Source), level[Source] = 0;
        
        int u, v;
        while (!q.empty())
        {
            u = q.front(), q.pop();
            for (int i = 0; i < (int)G[u].size(); i++)
            {
                v = G[u][i].to;
                if (G[u][i].cap > 0 && level[v] == -1)
                {
                    level[v] = level[u] + 1;
                    q.push(v);
                }
            }
        }
        return ~level[Sink];
    }
    int DFS(int V, int f)
    {
        if (V == Sink) return f;
        for (int &i = current[V]; i < (int)G[V].size(); i++)
        {
            Edge &E = G[V][i];
            if (E.cap > 0 && level[E.to] > level[V])
            {
                int delta = DFS(E.to, min(E.cap, f));
                if (delta > 0)
                {
                    E.cap -= delta;
                    G[E.to][E.rev].cap += delta;
                    return delta;
                }
            }
        } 
        return 0;
    }
    int max_flow() //最大流就是最小割, 就是(亏钱的实验收益 + 购买仪器的费用) 
    {
        int maxFlow = 0, delta; 
        while (BFS())
        {
            if ((delta = DFS(Source, oo)) > 0) maxFlow += delta;
        }
        return maxFlow;
    }
    void Work()
    {
        ans -= max_flow(); //减去后就是最后的最大收益
        for (int i = 1; i <= m; i++) //最后一次BFS建立分层图有等级的点就是所求 
            if (level[i] != -1) printf("%d ", i); 
        printf("\n"); 
        for (int i = 1; i <= n; i++)
            if (level[i+50] != -1) printf("%d ", i);
        printf("\n%d\n", ans); 
    }
} NF;

int main()
{
    NF.Build();
    NF.Work();
    return 0;
}
/***************
INPUT:
4 5     
10 2 3   
12 1   
13 4   
10 4 5  
6 7 8 9 9  
OUTPUT():
2 3 4 (实验编号) 
1 4 5 (仪器编号) 
11      (净收益)
***************/
```

---

## 作者：Ireliaღ (赞：3)

**ISAP最大流**

## 思路

这道题需要收益最大，也就是求出最小割，应使用最大流求解。

## 读入

对于一整行不知道有多少个数据，并且结尾还是`\r\n`，我们可以使用C++的`stringstream`，把整行用`getline`读进一个`string`，然后放入`stringstream`，从里面读取数据

## 建图

* 我们设$0$为超级源点，$n + m + 1$为超级汇点，每个实验对应$[1, m]$，每个仪器对应$[m + 1, n]$

* 对于$\forall i \in [1, m]$

  * 从$0$向$i$连边，容量为费用
  
  * 对于$\forall j \in R_i$，从$i$向$m + j$连边，容量为$\infty$
  
* 对于$\forall j \in [1, n]$

  * 从$j + m$向$n + m + 1$连边，容量为费用
  
## 输出

显然，最终输出的那个数是总费用减最大流。

那么如何输出方案？

根据ISAP的分层原理，我们把`gap`优化去掉~~（貌似这就成普通的SAP了）~~，使得最终流完的深度区分更明显。这样，跑完一遍最大流后，被割掉的点深度趋近于$0$，没被割掉的点深度趋近于$n + m$，那么我们取中间值作为分界线，深度大于这个值的点就是我们留下来的点，输出即可

## 程序实现

```cpp
// luogu-judger-enable-o2
// luogu-judger-enable-o2
// luogu-judger-enable-o2
#include <iostream>
#include <string>
#include <sstream>
#include <queue>
#include <cstring>
#include <algorithm>

using namespace std;

const int MAXN = 55;
const int INF = 0x3f3f3f3f;

int n, m;

struct Edge{
    int to, val;
    Edge *next, *ops;
    Edge(int to, int val, Edge *next): to(to), val(val), next(next){}
};

Edge *head[MAXN << 1];

inline void AddEdge(int u, int v, int w) {
    head[u] = new Edge(v, w, head[u]);
    head[v] = new Edge(u, 0, head[v]);
    head[u]->ops = head[v]; head[v]->ops = head[u];
}

int s, t, dep[MAXN << 1], /*gap[MAXN << 1], */res;

void Bfs() {
    memset(dep, -1, sizeof(dep));
    //memset(gap, 0, sizeof(gap));
    dep[t] = 0; //gap[dep[t]]++;
    queue<int> q; q.push(t);
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (Edge *e = head[u]; e; e = e->next) {
            int v = e->to;
            if (dep[v] != -1) continue;
            dep[v] = dep[u] + 1;
            //gap[dep[v]]++;
            q.push(v);
        }
    }
}

int Dfs(int u, int flow) {
    if (u == t) {
        res += flow;
        return flow;
    }
    int used = 0;
    for (Edge *e = head[u]; e; e = e->next) {
        int v = e->to;
        if (e->val && dep[v] == dep[u] - 1) {
            int mi = Dfs(v, std :: min(e->val, flow - used));
            if (mi) {
                e->val -= mi;
                e->ops->val += mi;
                used += mi;
            }
            if (used == flow) return used;
        }
    }
    //gap[dep[u]]--;
    //if (gap[dep[u]] == 0) dep[s] = n + m + 3;
    dep[u]++;
    //gap[dep[u]]++;
    return used;
}

void Work() {
    res = 0;
    Bfs();
    while (dep[s] <= n + m + 2) Dfs(s, INF);
}

int main() {
    cin >> m >> n;
    s = 0; t = n + m + 1;
    int tot = 0;
    string str;
    stringstream ss;
    for (int i = 1; i <= m; i++) {
        int x;
        cin >> x;
        tot += x;
        AddEdge(s, i, x);
        ss.clear();
        getline(cin, str);
        ss << str;
        while (ss >> x) AddEdge(i, x + m, INF);
    }
    for (int i = 1; i <= n; i++) {
        int x;
        cin >> x;
        AddEdge(i + m, t, x);
    }
    Work();
    /*for (int i = 1; i <= m; i++) cout << dep[i] << ' ';
    cout << endl;
    for (int i = m + 1; i <= n + m; i++) cout << dep[i] << ' ';
    cout << endl;*/
    for (int i = 1; i <= m; i++) {
        if (dep[i] > n + m >> 1) cout << i << ' ';
    }
    cout << endl;
    for (int i = m + 1; i <= n + m; i++) {
        if (dep[i] > n + m >> 1) cout << i - m << ' ';
    }
    cout << endl;
    cout << tot - res << endl;
    return 0;
}
```

*PS：虽然本代码可以AC此题，但是由于最后输出方案的方法有一点点玄学成分，所以如果针对这份代码刻意制造毒瘤数据，有可能是可以HACK掉的*

---

## 作者：Skyjoy (赞：2)

**这道题是一道基础的最大权闭合图转最大流（最小割）**

许多大佬都把思路讲得很详细了，那我就着重讲一讲代码中的细节和总结吧

# 思路

- 这道题的精髓在于联系了实验和设备

- 建立源点 $S$ 和汇点 $T$ 。此时，图中的流量自然就是钱了。首先，先把每一个实验与 $S$ 连线，流量为实验收益。之后，把实验和仪器连线，流量是 $inf$ 。最后把仪器和 $T$ 连线，流量为仪器费用。

- 然后用 $Dinic$ 跑一手最大流模板，用实验总收益减去最大流就行了。而那些选中的实验和仪器只用找那些走过的节点（与源点距离不为0的节点）输出即可。

# 代码讲解（主要给像我一样刚学网络流的）

首先，我们用 $1-m$ 表示实验，用 $m+1-m+n$ 表示仪器（基操）。然后我们读入数据时，如果小伙伴们懒得修改快读的话，建议还是用 scanf ，然后进行特判，这样会方便很多。至于 $Dinic$ 和 $SPFA$ 的写法这里就不讲解了，这里放上代码：

```cpp
#include<bits/stdc++.h>
#define N 5010
#define inf 0x7fffffff
using namespace std;
int read(){
	int x=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-'){
			f=-1;
		}
		ch=getchar();
	}
	while(ch>='0'&&ch<='9'){
		x=(x<<3)+(x<<1)+ch-'0';
		ch=getchar();
	}
	return x*f;
}
int n,m,head[N],s=0,t=2333,cnt=1,dis[N],ans,w,x;
struct edge{
	int to,next,val;
}e[N<<1];
void add(int u,int v,int w){
	e[++cnt].to=v,e[cnt].next=head[u],e[cnt].val=w,head[u]=cnt;
	e[++cnt].to=u,e[cnt].next=head[v],e[cnt].val=0,head[v]=cnt;
}
int SPFA(){//SPFA 还没死透
	memset(dis,0,sizeof(dis));
	queue<int>q;
	q.push(s);
	dis[s]=1;
	while(!q.empty()){
		int u=q.front();
		q.pop();
		for(int i=head[u];i;i=e[i].next){
			int v=e[i].to;
			if(!dis[v]&&e[i].val){
				dis[v]=dis[u]+1;
				q.push(v);
			}
		}
	}
	return dis[t];
}
int MCMF(int u,int cur){
	if(u==t||!cur){
		return cur;
	}
	int sum=0,tmp;
	for(int i=head[u];i;i=e[i].next){
		int v=e[i].to;
		if(dis[v]==dis[u]+1&&e[i].val){
			sum+=(tmp=MCMF(v,min(cur-sum,e[i].val)));
			e[i].val-=tmp,e[i^1].val+=tmp;
		}
	}
	if(!sum){
		dis[u]=-1;
	}
	return sum;
}
int Dinic(){//Dinic 模板
	int maxflow=0;
	while(SPFA()){
		maxflow+=MCMF(s,inf);
	}
	return maxflow;
}
int main(){
	m=read(),n=read();
	for(int i=1;i<=m;i++){
		scanf("%d",&w);
		ans+=w;
		add(s,i,w);
		while(getchar()==' '){//读入判断
			scanf("%d",&x);
			add(i,x+m,inf);
		}
	}
	for(int i=1;i<=n;i++){
		w=read();
		add(i+m,t,w);
	}
	ans-=Dinic();
	for(int i=1;i<=m;i++){
		if(dis[i]){//走过的输出
			printf("%d ",i);
		}
	}
	printf("\n");
	for(int i=1;i<=n;i++){
		if(dis[i+m]){//走过的输出
			printf("%d ",i);
		}
	}
	printf("\n%d",ans);
	return 0;
}
```

# 总结

网络流的模板部分其实很简单，但是题目的精髓在于建模。大家一定要想好模型，三思而后码，这样才能学号网络流。

# 僵卧孤村不自哀，[创宇](https://www.luogu.com.cn/user/147999) AK IOI 

---

## 作者：w12144 (赞：0)

解题思路基本与其他题解一致，这里主要说说我对为什么最后一次分层就是方案的理解。我比较喜欢通俗直观的解释问题，所以，我的理解也会比较通俗。

首先可以确定，最后一次分层之前，网络流里已经没有增广路径了，接着就退出while循环，这个很好理解。

然后想想看为点分层的条件，一个是还没有分层，另一个就是边的容量大于0。再结合问题想想，如果我要做一个实验，那么我必须要盈利，如果我得不到利益，我肯定不会去做对吧。放到图里就是从源点流出一道流到对应的实验，然后这个流分别流向这个实验需要的仪器，在流到汇点时，仪器与汇点连接的边的容量之和，一定要小于源点到实验这条边的容量，也就是说我的花费要小于我的利益，才能有收益。

那么对于容量大于0的边（从源点到实验对应的点），其实剩余的容量就是我做这个实验的收益了，这也可以解释总收益减去最大流（即总花费）是净收益。那些残量为0的边说明这个实验得不到收益，那就不选，在分层时就不会分配到值。好了，那么那些残量大于0的边所连的实验就是要做的实验了。

至于仪器嘛，因为实验与仪器之间的边容量是inf，所以只要实验选了，分了层了，它需要的仪器自然也会分到层。

这就是我对这个问题的理解，有问题的欢迎讨论。
```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <queue>
#define max 10005
#define nump 105
#define inf 0x7fffffff
using namespace std;
int n, m,s,t,cnt=-1;
int head[nump], cur[nump],depth[nump];
struct node {
	int next, to, c;
}edge[max];
void add_edge(int from, int to, int c) {
	edge[++cnt].next = head[from];
	edge[cnt].to = to;
	edge[cnt].c = c;
	head[from] = cnt;
}
bool bfs() {//构造分层图
	memset(depth, 0, sizeof(depth));
	for (int i = 0; i <= 105; i++) cur[i] = head[i];//复制head数组

	queue<int> Q;//定义一个bfs寻找分层图时的队列
	depth[s] = 1;//源点深度为1
	Q.push(s);
	do {
		int u = Q.front();//取队首元素
		Q.pop();
		for (int i = head[u]; i != -1; i = edge[i].next)
			if (edge[i].c > 0 && depth[edge[i].to] == 0) {
				depth[edge[i].to] = depth[u] + 1;	
				Q.push(edge[i].to);
			}
	} while (!Q.empty());

	if (depth[t] == 0) return 0;
	return 1;
}
int dfs(int u, int dist) {
	if (u == t || dist == 0) return dist; 
	for (int i = cur[u]; i != -1; i = edge[i].next) {
		cur[u] = i;
		if (depth[edge[i].to] == depth[u] + 1 && edge[i].c) { 
			int di = dfs(edge[i].to, min(dist, edge[i].c));
			if (di > 0) {//若增广成功
				edge[i].c -= di;//正向边减少
				edge[i ^ 1].c += di;//反向边增加
				return di;//向上传递
			}
		}
	}
	return 0;//没有增广路，返回0
}
int dinic() {
	int ans = 0,d;//记录最大流量
	while (bfs())	//如果存在一条增广路
		while (d = dfs(s, inf))//进行增广操作，增加的流量累加到最大流量中
			ans += d;
	return ans;
}
int main() {
	memset(head, -1, sizeof(head));
	cin >> m >> n;
	s = 0, t = 102;
	int sum=0;
	for (int i = 1,eo,to; i <= m; i++) {
		scanf("%d", &eo);//实验花费
		sum += eo;
		add_edge(s, 50+i, eo);
		add_edge(50+i, s, 0);

		char tools[10000];
		memset(tools, 0, sizeof tools);
		cin.getline(tools, 10000);
		int ulen = 0, tool;
		while (sscanf(tools + ulen, "%d", &tool) == 1)//之前已经用scanf读完了赞助商同意支付该实验的费用
		{//tool是该实验所需仪器的其中一个      
			add_edge(50 + i, tool, inf);
			add_edge(tool, 50 + i, 0);
			if (tool == 0)
				ulen++;
			else {
				while (tool) {
					tool /= 10;
					ulen++;
				}
			}
			ulen++;
		}
	}
	for (int i = 1,cost; i <= n; i++) { 
		scanf("%d", &cost); 
		add_edge(i, t, cost);
		add_edge(t, i, 0);
	}
	int ans = dinic();
	
	for (int i = 51; i <= 50+m; i++) {
		if (depth[i] != 0) printf("%d ", i - 50);
	}
	cout << endl;
	for (int i = 1; i <= n; i++) {
		if (depth[i] != 0) printf("%d ", i);
	}
	cout << endl;
	cout << sum - ans << endl;
	return 0;
}
```

---

## 作者：破壁人 (赞：0)

分析：

我们先把题目抽象出清晰的数学结构：

有两个点集E和L，从E中选第i个点会获得pi的收益，

从L中选第i个点会扣除ci的的收益，

两个点集之间有关系，选了E中的某个点后，必须从L中选出某些规定的点。

这样，题目就很明显的转化成了，选还是不选的问题。这就是最小割模型了。

建图：

设源点S汇点T，S向E中的点连容量为pi的边，

Ei向所有与它有关系的L中的点连容量为INF的边，保证一起取到。

Li向T连容量为ci的边。

这样，用pi的和减去最小割就是答案了。

那么还有一个问题如何确定方案呢？

我们先确定要用哪些仪器，删掉某个仪器连向T的边，

跑一遍最大流，如果原图最大流与其的差值等于这条边的容量，

则说明这个仪器是需要的，再通过仪器确定实验。

代码：
```pascal

#include<iostream>
#include<cstring>
#include<algorithm>
#include<cstdio>

using namespace std;

const int inf=1e9;

int n,m,p[51],c[51],x,p1[51][51],S=0,T,sum=0,ans,mi=inf,yu=0;
int to[6001],w[6001],w1[6001],next[6001],first[201],e1=0;
int d[201],f[6001],cur[201],e[201],now,check[51];

int read()
{
    char ch=getchar();yu=0;
    while((ch<'0')||(ch>'9')) {if(ch=='\n') return 0;ch=getchar();}
    while((ch>='0')&&(ch<='9')) yu=yu*10+ch-'0',ch=getchar();
    if(ch=='\n') return 0;
    return yu;
}

void insert(int o,int p,int q)
{
    to[e1]=p;w[e1]=w1[e1]=q;next[e1]=first[o];first[o]=e1++;
    to[e1]=o;w[e1]=w1[e1]=0;next[e1]=first[p];first[p]=e1++;
}

int sap()
{
    int yus=0;
    for(int i=0;i<=T;i++) cur[i]=first[i];
    memset(e,-1,sizeof(e));
    memset(d,0,sizeof(d));
    memset(f,0,sizeof(f));
    e[S]=now=S;f[0]=T;
    while(d[S]<T)
    {
        bool bo=false;
        for(int i=cur[now];i!=-1;i=next[i])
            if((d[now]==(d[to[i]]+1))&&(w1[i]>0))
            {
                cur[now]=i;
                e[to[i]]=now;
                now=to[i];
                bo=true;
                mi=min(mi,w1[i]);
                if(now==T)
                {
                    yus+=mi;
                    while(now!=S)
                    {
                        w1[cur[e[now]]]-=mi;
                        w1[cur[e[now]]^1]+=mi;
                        now=e[now];
                    }
                    mi=inf;
                }
                break;
            }
        if(bo) continue;int mmi=T;
        for(int i=first[now];i!=-1;i=next[i])
            if((w1[i]>0)&&(mmi>d[to[i]])) mmi=d[to[i]],cur[now]=i;
        if(!(--f[d[now]])) break;
        f[d[now]=(mmi+1)]++;
        now=e[now];
    }
    return yus;
}

int main()
{
    memset(first,-1,sizeof(first));
    scanf("%d%d",&m,&n);
    for(int i=1;i<=m;i++)
    {
        scanf("%d",&p[i]);sum+=p[i];
        while(true) 
        {
            x=read();
            p1[i][++p1[i][0]]=yu;
            if(!x)break;
        }
        S+=p1[i][0];
    }
    for(int i=1;i<=n;i++) scanf("%d",&c[i]);
    S+=n+m+1;T=S+1;
    for(int i=1;i<=m;i++) 
    {
        insert(S,i,p[i]);
        for(int j=1;j<=p1[i][0];j++) insert(i,m+p1[i][j],inf);
    }
    for(int i=1;i<=n;i++) insert(i+m,T,c[i]);
    ans=sap();
    memset(check,0,sizeof(check));
    for(int i=1;i<=n;i++)
    {
        for(int j=0;j<=e1;j++) w1[j]=w[j];
        w1[first[m+i]]=0;
        if(ans-sap()==w[first[m+i]]) check[i]=true;
    }
    for(int i=1;i<=m;i++)
    {
        bool b1=true;
        for(int j=1;j<=p1[i][0];j++)
            if(!check[p1[i][j]]) {b1=false;break;}
        if(b1) cout<<i<<' ';
    }
    cout<<endl;
    for(int i=1;i<=n;i++)
        if(check[i]) cout<<i<<' ';
    cout<<endl;
    cout<<sum-ans<<endl;
    return 0;
}
```

---

## 作者：feng_chengjie (赞：0)

##题目

W 教授正在为国家航天中心计划一系列的太空飞行。每次太空飞行可进行一系列商业

性实验而获取利润。现已确定了一个可供选择的实验集合E={E1，E2，…，Em}，和进行这

些实验需要使用的全部仪器的集合I={I1，I2，…In}。实验Ej需要用到的仪器是I的子集Rj。

配置仪器Ik的费用为ck美元。实验Ej的赞助商已同意为该实验结果支付pj美元。W教授的

任务是找出一个有效算法，确定在一次太空飞行中要进行哪些实验并因此而配置哪些仪器才

能使太空飞行的净收益最大。这里净收益是指进行实验所获得的全部收入与配置仪器的全部

费用的差额。

«编程任务：

对于给定的实验和仪器配置情况，编程找出净收益最大的试验计划。


##题解

如果把实验的收入和仪器的支出分别看作是一条路的两个限制容量，那么完成一个实验所需的最小资金消耗就是这条路径的最大流，也就是最小割。

注意：如果某实验的报酬大于消耗，则该实验的最小损失为实验报酬，即不做该实验，在后面ans=sum(实验报酬)-Maxflow时刚好把该实验减去

创建超级根节点和超级汇节点，建立

根—(实验报酬)—实验—(无穷)—仪器—(仪器耗费)—汇

的图，ans=sum(实验报酬)-Maxflow


##代码

```cpp
#include<cstdio>
#include<algorithm>
#include<queue>
#include<cstring>

using namespace std; 

const int INF = 0x7fffffff;
const int MAXN = 1010;
struct Edge{
    int to,c,nxt;
}e[10010];

int head[MAXN],dis[MAXN],cur[MAXN];
int s,t,tot=1;
queue<int>q;

int read(int &x)
{
    x = 0;char ch = getchar();
    for (; ch<'0'||ch>'9'; ch = getchar());
    for (; ch>='0'&&ch<='9'; ch = getchar())
        x = x*10+ch-'0';
    if (ch==10||ch==13) return 0;
    return 1;
}
void add_edge(int u,int v,int w)
{
    e[++tot].c = w,e[tot].to = v,e[tot].nxt = head[u];
    head[u] = tot;
    e[++tot].c = 0,e[tot].to = u,e[tot].nxt = head[v];
    head[v] = tot;
}
bool bfs()
{
    memset(dis,-1,sizeof(dis));
    dis[s] = 0;
    q.push(s);
    while (!q.empty())
    {
        int u = q.front();
        q.pop();
        for (int i=head[u]; i; i=e[i].nxt)
        {
            int v = e[i].to;
            if (dis[v]==-1&&e[i].c>0)
            {
                dis[v] = dis[u]+1;
                q.push(v);
            }
        }
    }
    return dis[t]!=-1;
}
int dfs(int u,int low)
{
    if(u==t || low==0)
        return low;
    int res=0;
    for(int i=head[u];i;i=e[i].nxt)
    {
        int v=e[i].to;
        if(e[i].c>0 && dis[v]==dis[u]+1)
        {
            int w=dfs(v,min(e[i].c,low));
            e[i].c-=w;
            e[i^1].c+=w;
            res+=w;
            low-=w;
            if(low==0)
            {
                break;    
            }
        }    
    }
    return res;
}
int main()
{
    int ans = 0,sum = 0,m,n,flag;
    read(m),read(n);
    s = 0,t = n+m+1;
    for (int x,i=1; i<=m; ++i)
    {
        flag = 1;
        read(x);
        sum += x;
        add_edge(s,i,x);
        while (flag) 
        {
            flag = read(x);
            add_edge(i,x+m,INF);
        }
    }
    for (int x,i=1; i<=n; ++i)
    {
        read(x);
        add_edge(i+m,t,x);
    }
    while (bfs())
    {
        memset(cur,0,sizeof(cur));
        ans += dfs(s,INF);    
    }
    for (int i=1; i<=m; ++i)
        if (dis[i]!=-1) printf("%d ",i);
    printf("\n");
    for (int i=m+1; i<=t; ++i)
        if (dis[i]!=-1) printf("%d ",i-m);
    printf("\n%d\n",sum-ans);
    return 0;
}
```

---

## 作者：FREEH (赞：0)

### 【题目大意】

- 有n项试验，做每一项试验有一些收入，而每一种试验要用到若干种仪器，每一种仪器要一些费用，问要做什么实验、配置什么设备，才能使净收益最大？输出最大净收益、做哪些试验、需要配备哪些仪器。

### 【解题思路】

- 假设全部试验都可以做且不用支出，那是最好的，但是现在需要支出，那么只要使支出最小化，那么收入就是最大了。那么这就用了最小割思想。

- 构图：源点连接着每一项实验，边的容量是试验的收入；每一项实验连接着需要的仪器，边的容量是无穷大；每一个仪器连接着汇点，边的容量是仪器的费用。然后求一个最大流，而最大流就是最小割，答案就出来了。

- 如果源点和其中一个试验的边的剩余容量还是原来的容量，就证明这项试验没有被割，所以输出这项试验；仪器也是一样的道理。

### 【解题反思】

- 在这题之中，输入仪器是若干个，没有给定数目，因此可以这样输入。

- 其中，要用到sstream库。

### 【参考程序】
```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<sstream>
#define min(a,b)(a<b?a:b)
using namespace std;
struct EDGE{int f,t,c,next;};
EDGE edge[100005];
int head[100005],cur=-1,s,t,n,m,sz,value;
bool visit[100005],viu[100005],viv[100005];
const int oo=1000000000;
void add(int u,int v,int c)
{
	cur++;
	edge[cur].f=u;
	edge[cur].t=v;
	edge[cur].c=c;
	edge[cur].next=head[u];
	head[u]=cur;
}
int dfs(int now,int mi)
{
	if (visit[now]) return 0;
	if (now==t) return mi;
	visit[now]=true;
	int h=head[now];
	while (h!=-1)
	{
		int to=edge[h].t;
	
		if (edge[h].c!=0)
		{
			int res=dfs(to,min(mi,edge[h].c));
			if (res)
			{
				edge[h].c-=res;
				edge[h^1].c+=res; 
				return res;
			}
		}
		h=edge[h].next;
	}
	return 0;
}
int main()
{
	cur=-1;
	memset(edge,0,sizeof(edge));
	memset(head,-1,sizeof(head));
	
	scanf("%d%d",&n,&m);
	s=n+m+1,t=n+m+2;
	int sum=0;
	string st;
	stringstream ss;
	for (int i=1;i<=n;i++)
	  {	
	      scanf("%d",&value);
		  sum+=value;
		  add(s,i,value);
		  add(i,s,0);
		  getline(cin,st);
		  ss.clear();
		  ss.str(st);
		  while (ss>>sz) add(i,sz+n,oo),add(sz+n,i,0);
	  }
	for (int i=1;i<=m;i++)
	  {
		  scanf("%d",&value);
		  add(i+n,t,value);
		  add(t,i+n,0);
	  }
	int ans=0;
	while (1)
	  {
		  memset(visit,0,sizeof(visit));
		  int res=dfs(s,oo);
		  if (res) ans+=res;else break;	
	  }
	for (int i=1;i<=n;i++) if (visit[i]) printf("%d ",i);
	printf("\n");
	for (int i=1;i<=m;i++) if (visit[i+n]) printf("%d ",i);
	printf("\n");
	cout<<sum-ans;
	return 0;
}

```

---


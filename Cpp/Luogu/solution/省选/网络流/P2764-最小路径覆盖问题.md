# 最小路径覆盖问题

## 题目描述

给定有向图 $G=(V,E)$ 。设 $P$ 是 $G$ 的一个简单路（顶点不相交）的集合。如果 $V$ 中每个顶点恰好在 $P$ 的一条路上，则称 $P$ 是 $G$ 的一个路径覆盖。$P$ 中路径可以从 $V$ 的任何一个定点开始，长度也是任意的，特别地，可以为 $0$。$G$ 的最小路径覆盖是 $G$ 所含路径条数最少的路径覆盖。设计一个有效算法求一个 DAG（有向无环图）$G$ 的最小路径覆盖。


## 说明/提示

对于 $100\%$ 的数据，$1\leq n\leq 150$，$1\leq m\leq 6000$。

由 @FlierKing 提供 SPJ

## 样例 #1

### 输入

```
11 12
1 2
1 3
1 4
2 5
3 6
4 7
5 8
6 9
7 10
8 11
9 11
10 11```

### 输出

```
1 4 7 10 11
2 5 8
3 6 9
3```

# 题解

## 作者：totorato (赞：82)

(不需要利用二分图匹配相关定理)


## 分析：

我们首先将原图用n条路径覆盖，每条边只经过每个节点。

现在尽量合并更多的路径(即将两个路径通过一条边首尾相连)。

可以知道，每合并两条路径，图中的路径覆盖数就会减少1。

所以我们只需要利用网络流合并相关的路径即可。


## 答案求解：

首先将每个节点拆成(Xi,Yi)两个节点，建立源点和汇点，分别连接(S,Xi)和(Yi,T)。

然后对于每一条原图中的边，建立边(Xi,Yi)即可。

这样每一条增广路都只会经过2个节点(Xa,Yb)，对应合并的两个节点。

由于每个节点至多与一个节点合并，故边(S,Xi)和(Yi,T)容量为1。

此时的最大流对应的就是最多可以合并的路径数。


## 方案输出：

由于本人没有想到什么好的输出方法，故只能比较蠢地根据网络流的残余流量构造每一条路径(利用并查集维护路径起点)，然后从起点递归输出。


``cpp











```cpp
#include <iostream>
#include <cstring>
#include <cstdio>
#define MX 20001
#define S 0
#define T ((n<<1)+1)
#define oo 12312312
using namespace std;
typedef struct edge_t
{
    int u,v,c;
}edge;
edge e[MX];
int fst[MX],nxt[MX],lnum;
int n,m;
void addeg(int nu,int nv,int nc)
{
    nxt[++lnum]=fst[nu];
    fst[nu]=lnum;
    e[lnum]=(edge){nu,nv,nc};
}
void input()
{
    int a,b;
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++)
    {
        scanf("%d%d",&a,&b);
        addeg(a,n+b,1);
        addeg(n+b,a,0);
    }
    for(int i=1;i<=n;i++)addeg(S,i,1),addeg(i,S,0);
    for(int i=n+1;i<=n<<1;i++)addeg(i,T,1),addeg(T,i,0);
}
void init()
{
    memset(fst,0xff,sizeof(fst));
    lnum=-1;
}
int dep[MX],q[MX];
int bfs(int frm,int to)
{
    int x,y,h=0,t=1;
    memset(dep,0xff,sizeof(dep));
    q[++h]=frm;
    dep[frm]=0;
    while(h>=t)
    {
        x=q[t++];
        for(int i=fst[x];i!=-1;i=nxt[i])
        {
            y=e[i].v;
            if(e[i].c&&dep[y]==-1)
            {
                dep[y]=dep[x]+1;
                q[++h]=y;
            }
        }
    }
    return (dep[to]>=0);
}
int dinic(int to,int x,int mn)
{
    if(x==to)return mn;
    int a,now=0,y;
    for(int i=fst[x];i!=-1;i=nxt[i])
    {
        y=e[i].v;
        if(e[i].c&&dep[y]==dep[x]+1)
        {
            a=dinic(to,y,min(mn-now,e[i].c));
            now+=a;
            e[i].c-=a;
            e[i^1].c+=a;
            if(now==mn)break;
        }
    }
    return now;
}
void output(int x)
{
    printf("%d ",x);
    for(int i=fst[x];i!=-1;i=nxt[i])
        if(e[i].c==0&&e[i].v>n)
            output(e[i].v-n);
}
int fa[MX];
int findfa(int x){return x==fa[x]?x:fa[x]=findfa(fa[x]);}
void work()
{
    int tot=0;
    while(bfs(S,T))tot+=dinic(T,S,+oo);
    for(int i=1;i<=n;i++)fa[i]=i;
    for(int i=0;i<=lnum;i++)
        if(e[i].u>=1&&e[i].u<=n&&e[i].v>n&&e[i].v<T&&e[i].c==0)
            fa[findfa(e[i].v-n)]=findfa(e[i].u);
    for(int i=1;i<=n;i++)
        if(findfa(i)==i)
            output(i),putchar('\n');
    printf("%d\n",n-tot);
}
int main()
{
    init();
    input();
    work();
    return 0;
}
```
```cpp

---

## 作者：eternal风度 (赞：36)

# 先吐槽一下
~~觉得这道题目还不错，很有价值，就想写一篇题解~~

嗯，其实我的思想和楼下的差不多，但是输出路径的方法有很大不同，当然这个也应人而异了，不同的人有不同的爱好嘛，但还是希望题解可以通过，在luogu上留下自己的痕迹 @w@ 谢谢

# 开始讲
1. 首先需要看懂题目(~~没错，我看了很久~~)，是让很多条不相交的路径去覆盖所给的图，问最少要多少条并输出它们。

2. 然后需要证明一个东西：我们一开始把每个点看做一条路径，考虑路径合并的问题，每两条路径首尾相连接起来是不是路径数就会减一？(~~显然~~)。而我们会要尽量减少它们的数量。

3. 想一下怎么可以求出**点可以连起来的路径**的数量最小值，根据上面2提到的那一点，我们就可以考虑把可以合并的点数全部求出来，再拿总点数去减，是不是就是我们要求的答案了？

 **那么问题就转化为了求哪些点可以“合并”**。然后再往后看，~~嗯，标签是网络流~~，就考虑建图跑吧。

4. 有了上面的基础应该就不难想了，**把每个点分开成两个**，X[i]与源点S连容量为1的边，Y[i]与汇点T连容量为1的边(**每个点只能在一条路径上**)，然后数据读入的边**X[i] --1--> Y[j]**这个毋庸置疑了吧。**最后跑Dinic求最大流就行了就行了**(我建议把样例的图根据我讲的画出来容易理解，~~其实不难~~)

4. 最后考虑怎么输出路径，很容易想到，在Dinic的DFS过程中可以记录每个点流向的那个点(就是会在原图上相连的点，标记一下每一条“输出边”的开头位置，暴力跳着输出就ok)

5. 实在不行还是一边看代码吧
# code
PS:个人认为~~自己的代码风格还是易懂的~~


```

#include<iostream>
#include<cstdlib>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<iomanip>
#include<algorithm>
#include<ctime>
#include<queue>
#include<stack>
#include<vector>
#define rg register
#define il inline
#define lst long long
#define ldb long double
#define N 550
#define M 100050
using namespace std;
const int Inf=1e9;
il int read()
{
    rg int s=0,m=0;rg char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')m=1;ch=getchar();}
    while(ch>='0'&&ch<='9')s=(s<<3)+(s<<1)+(ch^48),ch=getchar();
    return m?-s:s;
}

int n,m,S,T,ans;
int to[N],tag[N],dep[N];
int hd[N],cur[N],cnt=1;
struct EDGE{int to,nxt,c;}ljl[M<<1];
il void add(rg int p,rg int q,rg int o)
{
    ljl[++cnt]=(EDGE){q,hd[p],o},hd[p]=cnt;
    ljl[++cnt]=(EDGE){p,hd[q],0},hd[q]=cnt;
}

queue<int> Q;
il bool BFS()
{
    for(rg int i=S;i<=T;++i)dep[i]=0;
    while(!Q.empty())Q.pop();
    Q.push(S),dep[S]=1;
    while(!Q.empty())
    {
        rg int now=Q.front();Q.pop();
        for(rg int i=hd[now];i;i=ljl[i].nxt)
        {
            rg int qw=ljl[i].to;
            if(!dep[qw]&&ljl[i].c>0)
            {
                dep[qw]=dep[now]+1;
                Q.push(qw);
            }
        }
    }
    return dep[T];
}

int dfs(rg int now,rg int aim,rg int flow)
{
    if(now==aim)return flow;
    for(rg int &i=cur[now];i;i=ljl[i].nxt)
    {
        rg int qw=ljl[i].to;
        if(ljl[i].c>0&&dep[qw]==dep[now]+1)
        {
            rg int kk=dfs(qw,aim,min(flow,ljl[i].c));
            if(kk>0)
            {
                to[now]=qw;//标记一下，方便判断
                if(now!=S)tag[qw-n]=1;//记录to[]
                ljl[i].c-=kk,ljl[i^1].c+=kk;
                return kk;
            }
        }
    }
    return 0;
}

il int Dinic()
{
    rg int ans=0;
    while(BFS())
    {
        for(rg int i=S;i<=T;++i)cur[i]=hd[i];
        while(int kk=dfs(S,T,Inf))ans+=kk;
    }
    //以上为模板，就不需要解释了吧
    for(rg int i=1;i<=n;++i)
        if(!tag[i])//没标记就是开始的地方
        {
            rg int now=i;
            printf("%d ",now);
            while(to[now]&&to[now]!=T)//暴力跳并输出
            {
                printf("%d ",to[now]-n);
                now=to[now]-n;
            }
            puts("");
        }
    return ans;
}

int main()
{
    n=read(),m=read();
    S=0,T=2*n+1;
    for(rg int i=1;i<=n;++i)
        add(S,i,1),add(i+n,T,1);//见3
    for(rg int i=1;i<=m;++i)
    {
        rg int p=read(),q=read();
        add(p,q+n,1);//见3
    }
    printf("%d\n",n-Dinic());//这个证明了的
    return 0;
}

```
## 想打一下广告(~~嘘~~)
如果你觉得我讲的还行，或者让你清晰了很多，可以顶一顶[我的cnblogs博客](http://www.cnblogs.com/cjoierljl/)

里面有一套网络流题目的详讲，~~我自认为还行~~：[戳我](https://www.cnblogs.com/cjoierljl/p/9411270.html)

---

## 作者：Z1qqurat (赞：24)

之前学二分图的时候就很惊讶于将原图拆点的最大匹配转化，直到刷网络流的时候再次遇到这个问题。其实方案输出无论是网络流还是二分图都是同样的原理，但是感觉现有的资料都很少有仔细解释其正确性和本质的，就自己思考出了一种解释。

* 首先我们假设现在原图内每个点都是一条路径，此时最少路径数为 $n$。

* 考虑合并路径，现有两条路径 $s \rightsquigarrow t$ 和 $s' \rightsquigarrow t'$，当且仅当 $t$ 与 $s'$ 之间有边 $(t, s')$ 相连才能合并这两条路径。也就是说，只有**两条路径首尾相连**的时候可以合并。

* 现在考虑将点 $u$ 拆为出点 $u$ 和入点 $u + n$，当我们在 $u, v$ 之间连边的时候，在新图上我们连 $u, v + n$；并将源点 $S$ 和所有 $u$ 连边，所有 $u + n$ 和汇点 $T$ 连边。初始时设所有边的容量为 $1$。

  我们思考一次增广代表着什么。增广的时候，相当于找到一条从左部点 $s$ 到右部点 $t$ 的**长为奇数的交错路径，也就是二分图匹配中的增广路**（交错路径由未匹配边——匹配边——未匹配边交错构成，若交错路径长度为 $2l + 1$，第奇数条边为未匹配边，第偶数条边为匹配边，未匹配边比匹配边多一条，只是网络流中的匹配边是满流边的反向边），而找到一条增广路**相当于将所有满流边的反向边（即匹配边）所连接两条路径之间的合并关系取消，无流边（即未匹配边）所连接的两条路径合并**，又因为未匹配边比匹配边多一条，那么这样就可以保证**每次增广都能多合并一组路径，每次使路径条数减少 $1$**。那么说明只要我们求出的是最大流（最大匹配），那么一定是使得合并的路径最多，所以最后的最少路径数 $minpath = n - maxflow$。

  比如下面这个图，选出增广路径 $1 \rightarrow 6 \rightarrow 3 \rightarrow 8$，相当于分别合并以 $1$ 结尾和以 $2$ 开头，以 $3$ 结尾和以 $4$ 开头的路径，取消对以 $2$ 开头和以 $3$ 结尾的路径的合并。

  ![](https://pic.imgdb.cn/item/64aab3c31ddac507ccceebbb.png)

* 接下来考虑如何输出方案。首先我们需要找出所有的起点，什么样的点会是起点？如果对于右部点 $u$，存在满流边 $(v, u)$，那么说明 $v$ 在所选出的某条路径上肯定是 $u - n$ 的前驱（因为在最大流过程中合并了以 $v$ 结尾和以 $u - n$ 开头的路径），$u - n$ 就肯定不是路径的起点。所以**如果 $u - n$ 是路径的起点，那么没有流量经过点 $u$，也就是说边 $(u, T)$ 流量为 $0$。** 于是所有满足 $(i + n, T)$ 流量为 $0$ 的点 $i$ 都是路径起点。

  确定了路径起点，我们就来解决对于某个特定起点 $i$ 如何找以 $i$ 为起点的路径。如果边 $(i, j)$ 是满流边，那么说明点 $j - n$ 在路径上是点 $i$ 的后继。所以我们只需要对于 $i$ 找出这样的 $j$，然后再以 $j - n$ 为起点往后找满流边所连接的后继（对于每个 $i$，这样的 $j$ 肯定也是唯一的，因为二分图中我们每条正向边的容量都只有 $1$）。记得在 dfs 的时候先输出点 $i$ 并且把路径上的所有点都打上标记防止反复输出（以保证路径不交）。

所有的分析证明都是自己想的，如有错误请指出。

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <cmath>
#include <queue>
#include <vector>
#define ll long long
#define pii pair<int, int>
#define mr make_pair
using namespace std;
const int N = 305, M = 2e4 + 5;
int n, m, cnt = 1, to[M], limit[M], nxt[M], head[N], cur[N], dis[N], dy[N];
bool vis[N];
queue <int> q;
vector <int> Sena; //存起点

void AddEdge(int u, int v, int w) {
    to[++cnt] = v, limit[cnt] = w, nxt[cnt] = head[u], head[u] = cnt;
    to[++cnt] = u, limit[cnt] = 0, nxt[cnt] = head[v], head[v] = cnt;
    return ;
}

int Augmenting(int u, int rest, int t) {
    if(u == t) return rest;
    int ret = 0;
    for (int i = cur[u]; i && rest; i = nxt[i]) {
        cur[u] = i;
        int v = to[i], c = min(rest, limit[i]);
        if(dis[v] == dis[u] + 1 && c) {
            int f = Augmenting(v, c, t);
            rest -= f, ret += f;
            limit[i] -= f, limit[i ^ 1] += f;
        }
    }
    if(!ret) dis[u] = -1;
    return ret;
}

int MaxFlow(int s, int t) {
    int maxflow = 0;
    while(1) {
        memset(dis, -1, sizeof(dis));
        memcpy(cur, head, sizeof(head));
        while(!q.empty()) q.pop();
        q.push(s), dis[s] = 0;
        bool Shu = 0;
        while(!q.empty()) {
            if(Shu) break;
            int u = q.front(); q.pop();
            for (int i = head[u]; i; i = nxt[i]) {
                int v = to[i];
                if(limit[i] && dis[v] == -1) {
                    dis[v] = dis[u] + 1;
                    if(v == t) {
                        Shu = 1; break;
                    }
                    q.push(v);
                }
            }
        }
        if(dis[t] == -1) return maxflow;
        maxflow += Augmenting(s, 1e9, t);
    }
}

void Ritsu(int u) { //找以 u 开头的路径
    printf("%d ", u);
    vis[u] = 1;
    for (int i = head[u]; i; i = nxt[i]) {
        int v = to[i];
        if(v > n && v <= 2 * n && !limit[i] && !vis[v - n]) {
            Ritsu(v - n);
        }
    }
    return ;
}

void Oukawa() { //输出方案
    for (int i = 1 + n; i <= 2 * n; ++i) {
        if(limit[dy[i]] == 1) Sena.push_back(i - n);
    }
    for (int i = 0; i < Sena.size(); ++i) {
        Ritsu(Sena[i]); puts("");
    }
    return ;
}

int main() {
    scanf("%d %d", &n, &m);
    for (int i = 1; i <= m; ++i) {
        int u, v; scanf("%d %d", &u, &v);
        AddEdge(u, v + n, 1);
    }
    int s = 2 * n + 1, t = 2 * n + 2;
    for (int i = 1; i <= n; ++i) {
        AddEdge(s, i, 1);
        AddEdge(i + n, t, 1);
        dy[i + n] = cnt - 1;
    }
    int ans = n - MaxFlow(s, t);
    Oukawa();
    printf("%d\n", ans);
    return 0;
}
```

---

## 作者：Adove (赞：21)

一道二分图的题，在网络流上体现为：最小路径覆盖=点的总数-网络最大流。

建模方式：

![](https://cdn.luogu.com.cn/upload/pic/15945.png)

拆点后源点向1~n连接权为1的边，n+1~2n向汇点连权为1的边。

对于原图中相连的两个点x->y，二分图中体现为x->y+n。

最后的方案可以利用残量网络用并查集维护。

即从1到n枚举，从每个点向外扫一圈，如果有流从这条边经过，并流向y+n，则合并x与y。

然后n^2输出方案即可。

上代码↓

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;

const int INF=2e9;

int n,m,x,y,s,s1,t,np=1,mfl,mct;
int h[305],cur[305],tp[305],ln[305],q[12505],f[305];
bool vis[305];
struct rpg{
	int li,nx,ln,ct;
}a[12505];

void add(int ls,int nx,int ln,int ct){
	a[++np]=(rpg){h[ls],nx,ln,ct};
	h[ls]=np;
	a[++np]=(rpg){h[nx],ls,0,-ct};
	h[nx]=np;
}

bool bfs(){
	memset(tp,0,sizeof(tp));
	int hd=1,tl=1;
	q[hd]=s1;
	tp[s1]=1;
	while(hd<=tl){
		int nw=q[hd++];
		for(int i=h[nw];i;i=a[i].li){
			if(a[i].ln&&!tp[a[i].nx]){
				tp[a[i].nx]=tp[nw]+1;
				q[++tl]=a[i].nx;
			}
		}
	}return tp[t];
}

int dfs(int u,int maxn){
	if(u==t||!maxn) return maxn;
	int sum=0;
	for(int& i=cur[u];i;i=a[i].li){
		if(a[i].ln&&tp[a[i].nx]==tp[u]+1){
			int f=dfs(a[i].nx,min(maxn,a[i].ln));
			if(f){
				maxn-=f;
				sum+=f;
				a[i].ln-=f;
				a[i^1].ln+=f;
				if(!maxn) break;
			}
		}
	}return sum;
}

void dnc(){
	while(bfs()){
		for(int i=0;i<=t;++i) cur[i]=h[i];
		while(int d=dfs(s1,INF)) mfl+=d;
	}
}

int find(int x){
	if(f[x]==x) return x;
	else return f[x]=find(f[x]);
}

void un(int a,int b){
	int fa=find(a),fb=find(b);
	if(fa!=fb) f[fa]=fb;
}

int main(){
	scanf("%d%d",&n,&m);
	t=(n<<1)+1;
	for(int i=1;i<=m;++i){
		scanf("%d%d",&x,&y);
		add(x,y+n,1,-1);
	}for(int i=1;i<=n;++i){
		add(s,i,1,-1);
		add(i+n,t,1,0);
	}dnc();
	
	mfl=n-mfl;
	for(int i=1;i<=n;++i) f[i]=i;
	
	for(int i=1;i<=n;++i){
		for(int j=h[i];j;j=a[j].li){
			if(!a[j].ln&&a[j].nx-n<=n&&a[j].nx){
				un(i,a[j].nx-n);
			}
		}
	}
	for(int i=n;i;--i){
		bool fl=0;
		for(int j=1;j<=n;++j){
			if(find(j)==i){
				printf("%d ",j);
				fl=1;
			}
		}if(fl) puts("");
	}
	printf("%d\n",mfl);
	return 0;
}
```

---

## 作者：夜刀神十香ღ (赞：14)

首先我们要明白一个定理：一张图中，路径数（点不重复）=点数-点之间匹配数（连边且不重复）。

这个很好证明。因为当点之间没有边时，路径数=点数-0=点数；当有一条边（x，y）时，相当于把这两个点合在一起，所以路径数=点数-1；以此类推。

所以我们要求最小路径覆盖，点数不变，那么就要使匹配数最大，就变成了求最大匹配的问题。

同飞行员匹配问题一样，我们把一个点拆开两个点，然后有边的两个点之间连流量为1的边，st到每个出点连一条流量为1的边，每个入点到ed连一条流量为1的边，跑一遍最大流就可以知道最大匹配了，用总点数减一减就可以得出答案。

关于方案输出的问题，用last记录一下前一个访问这个点的是哪个，用s记录一下当前这个点访问谁。具体可以到上面的链接中学习，每找到一个路径的结尾（s[i]==i）那么就递归访问t，输出即可。

~~（注意：为了防作弊把数组开小了1/10）~~

```cpp
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<queue>
using namespace std;
int n,m,last[31],len=1,st,ed,h[31],t[31],s[31];
struct node{int y,c,next; } a[12001];
queue<int>f;
bool pd[310];
int min(int x,int y) { return x<y?x:y; }
void ins(int x,int y,int c)
//建边函数
{
	len++; a[len].y=y; a[len].c=c; a[len].next=last[x]; last[x]=len;
	len++; a[len].y=x; a[len].c=0; a[len].next=last[y]; last[y]=len;
}
bool bfs()
{
	memset(h,0,sizeof(h));
	h[st]=1; f.push(st);
	while(!f.empty())
	{
		int x=f.front();
		for(int i=last[x];i!=0;i=a[i].next)
		{
			int y=a[i].y;
			if(h[y]==0 && a[i].c>0) { h[y]=h[x]+1; f.push(y); }
		}
		f.pop();
	}
	return h[ed];
}
int dfs(int x,int k)
{
	if(x==ed) return k;
	int d=0;
	for(int i=last[x];i!=0;i=a[i].next)
	{
		int y=a[i].y;
		if(d==k) return k;
		if(h[y]==h[x]+1 && a[i].c>0)
		{
			int my=dfs(y,min(a[i].c,k-d));
			d+=my; a[i].c-=my; a[i^1].c+=my;
			if(my!=0 && x!=st && y!=ed) { s[x]=y-n; t[y-n]=x; }
		}
	}
	if(d==0) h[x]=0;
	return d;
}
//bfs和dfs是两个很常见的网络流函数
int mf()
//maxflow最大流缩写
//求最大流的函数
{
	int k=0;
	while(bfs())
	{
		int dx=dfs(st,1e9);
		while(dx!=0) { k+=dx; dx=dfs(st,1e9); }
	}
	return k;
}
void op(int x)
//output输出函数
{
	if(x==0) return;
	if(t[x]!=x) op(t[x]);
	pd[x]=true;
	printf("%d ",x);
}
int main()
//从主函数开始阅读是个好习惯
{
	memset(pd,false,sizeof(pd));
	scanf("%d %d",&n,&m); st=0; ed=2*n+1;
	for(int i=1;i<=n;i++) s[i]=t[i]=i;
	for(int i=1;i<=m;i++)
	{
		int x,y; scanf("%d %d",&x,&y);
		ins(x,y+n,1);
        //输入并建边
	}
	for(int i=1;i<=n;i++) { ins(st,i,1); ins(i+n,ed,1); }
    //同样是建边，很好理解，希望自己理解
	int p=mf();
    //求最大流
	for(int i=n;i>=1;i--)
		if(s[i]==i && pd[i]==false) { op(i); printf("\n"); }
	//输出
	printf("%d",n-p);
	return 0;
}
```

---

## 作者：Lyccrius (赞：10)

我们知道，一条路径可以由两条不相交的路径首尾相接而成。在一开始每个点都是一条独立的路径，我们不断重复路径合并的过程，最终可以得到一个路径覆盖。

考虑一条路径，路径上的每一个点都有一条入边和出边。特别的，路径的起点没有入边，路径的终点没有出边。

“对于任意……都有唯一……” 这是一个很好的性质，我们可以将它抽象成二分图，这是因为二分图匹配后的每一个匹配点都有唯一一个点与之匹配。（这句话是我在 **[洛谷网校省选计划 2022](https://class.luogu.com.cn/course/yugu22sx1a)** 期间看到的，凭借这句话我秒切了这道紫题，同时[我也在省选计划的帮助下成功入选省队](https://www.luogu.com.cn/discuss/599515)。洛谷好闪，拜谢洛谷！大家快来报名！）

考虑将路径上点之间之间的合并关系类比为二分图上的匹配关系。由于二分图每个点只能匹配一次，而问题中的点可以合并两次。我们尝试解决这个矛盾，发现一个点最多的两次合并分别是作为起点和终点出现的，于是可以将一个点拆分为作为终点的点和作为起点的点，也可以理解为入度点和出度点。

对于一个点 $u$，我们用编号为 $u$ 的点表示作为终点的点，用编号为 $u+n$ 的点表示作为起点的点。显而易见在二分图中一个终点会与一个起点匹配，表示原图中的两条路径合并。

对于原图中的一条边 $(u,v)$，我们在二分图中连一条边 $(u,v+n)$ 即可。

使用匈牙利算法求出二分图的最大匹配数，即为原图的最大合并次数。

在一开始每个点都是一条独立的路径，每次合并将两条路径合并为一条路径，那么最终路径即为点数减去最大匹配数，这样求得的路径覆盖即为最小路径覆盖。

关于路径覆盖方案的输出，我们考虑二分图与原图的转化关系：一个点在原图中作为一条路径的起点出现，说明其在二分图中作为起点的对应点没有与另一个作为终点的点匹配。于是我们扫描二分图中的每个起点，如果没有匹配上则说明它是一条路径的起点，其在路径上的后继结点即为它作为终点对应点所匹配的作为起点的点，重复此过程不断输出，直至当前点作为终点对应点没有被匹配。

```cpp
#include <iostream>

const int maxN = 150;
const int maxM = 6000;

int n, m;
int u, v;

namespace graph {
    struct Vertex {
        int vis;
        int head;
        int match;
    } vertex[2 * maxN + 10];

    struct Edge {
        int head;
        int next;
    } edge[maxM + 10];

    int ecnt;

    void addEdge(int tail, int head) {
        ecnt++;
        edge[ecnt].head = head;
        edge[ecnt].next = vertex[tail].head;
        vertex[tail].head = ecnt;
        return;
    }

    bool DFS(int u, int t) {
        for (int e = vertex[u].head; e; e = edge[e].next) {
            int v = edge[e].head;
            if (vertex[v].vis == t) continue;
            vertex[v].vis = t;
            if (vertex[v].match == 0 || DFS(vertex[v].match, t)) {
                vertex[v].match = u;
                vertex[u].match = v;
                return true;
            }
        }
        return false;
    }
}

void print(int u) {
    while (u != - n) {
        std::cout << u << ' ';
        u = graph::vertex[u].match - n;
    }
    std::cout << '\n';
    return;
}

int main() {
    int matched = 0;
    std::cin >> n >> m;
    for (int i = 1; i <= m; i++) std::cin >> u >> v, graph::addEdge(u, n + v);
    for (int i = 1; i <= n; i++) if (graph::DFS(i, i)) matched++;
    for (int i = 1; i <= n; i++) if (graph::vertex[i + n].match == 0) print(i);
    std::cout << n - matched << '\n';
    return 0;
}
```

---

## 作者：Asurudo (赞：9)

二分图匹配相关定理以及证明就不再赘述了，前面的题解讲的都很明白了，匈牙利也好$dinic$也好，第一问的最少路径数都能得到，所以本篇题解着重讲一下第二问，路径输出的问题。

对于第一问，我们根据

最小路径覆盖 = 点的总数 - 网络最大流

这一二分图定理，用$dinic$算法求出网络最大流后，得到残余网络。

在这期间不需要对第二问的路径输出做任何预处理，当跑完最大流获得残余网络后，我们在残余网络上做文章。

图片借用@A·H_题解中的图片，其中$S$为超级源点，$T$为超级汇点。左边拆出的和超级源点$S$直接相连的$N$个点的集合，我们把它叫做集合$X$；右边拆出的和超级汇点$T$直接相连的$N$个点的集合，我们把它叫做集合$Y$。
![](https://cdn.luogu.com.cn/upload/pic/15945.png)

根据$dinic$算法和求第一问的流程我们可以得知，对于集合$X$到集合$Y$的每一条有向边，我们在建图时也会建一条它的反向边。所以对于集合$Y$中的每一个点，其在最初始建图时固定会有一条指向超级汇点的有向边，且该有向边的权值为$1$，代表流量为$0$，容量为$1$。其还会有一些指向$X$中的点的有向边，这些有向边的初始权值为$0$，代表流量为$0$，容量为$1$。

现在思考，如果某在$Y$的点$P$不为某条简单路的起点，而为中间点或者终点，以$P$为起点的有向边，权值会怎样？有两对四条有向边的权值一定会发生变化！举个例子，如果有超级源点向$X$中的一点流出流量，然后该$X$中的一点再将流量流向在$Y$中的$P$，则$P$一定会将流量流向超级汇点。于是以$P$为终点的一条来自$X$的有向边，以及以$P$为起点的一条流向超级汇点的有向边的权值，从原来的$1$，都变为了$0$，他们对应的反向边的权值也会变化。

所以从中，我们可以抓住一条判定某点是否为起点的方法：遍历集合$Y$，若其到超级汇点的有向边的权值还为原来的$1$，证明没有$X$中的点有流量流向它，则其一定没有前驱点，也就是其为起点！

所以我们可以通过一遍遍历将起点全部找到。起点收入囊中以后我们用$dfs$去找每一个点的下一个点，于是就能打印出简单路径。起点和遍历过的点自然要用$visit$数组标记一下，选过的点不能再选了，这样我们每个简单路径的点的集合才能形成一个全集的划分，而不是覆盖。

代码中，超级源点$S$标号为$0$，集合$X$中的点标号为$1--N$,集合$Y$中的点标号为$N+1--2N$，超级汇点$T$中的点标号为$2N+1$。

```cpp
#include<bits/stdc++.h>
#define _for(i,a,b) for(register int i = (a);i < b;i ++)
#define _rep(i,a,b) for(register int i = (a);i > b;i --)
#define INF 0x3f3f3f3f
#define MOD 100000000
#define maxn 100003
#define pb push_back
#define debug() printf("Miku Check OK!\n")
typedef long long ll;

using namespace std;
typedef pair<int,int> P;
inline ll read()
{
    ll ans = 0;
    char ch = getchar(), last = ' ';
    while(!isdigit(ch)) last = ch, ch = getchar();
    while(isdigit(ch)) ans = (ans << 1) + (ans << 3) + ch - '0', ch = getchar();
    if(last == '-') ans = -ans;
    return ans;
}
inline void write(ll x)
{
    if(x < 0) x = -x, putchar('-');
    if(x >= 10) write(x / 10);
    putchar(x % 10 + '0');
}
int ver[maxn],Next[maxn],head[maxn],val[maxn];
int d[maxn];
int n,m,s,t,tot,maxflow;
void add(int x,int y,int w)
{
    ver[++tot] = y,Next[tot] = head[x],head[x] = tot,val[tot] = w;
}
bool bfs()
{
    memset(d,0,sizeof(d));
    queue<int> q;
    q.push(s);d[s] = 1;
    while(!q.empty())
    {
        int x = q.front();q.pop();
        for(int i = head[x]; i; i = Next[i])
            if(val[i] && !d[ver[i]])
            {
                q.push(ver[i]);
                d[ver[i]] = d[x]+1;
                if(ver[i]==t)
                    return true;
            }
    }
    return false;
}
int dinic(int x,int flow)
{
    if(x==t) return flow;
    // k为子节点增量 
    int rest = flow, k;
    for(int i = head[x]; i && rest; i = Next[i])
    {
        if(val[i] && d[ver[i]] == d[x]+1)
        {
            k = dinic(ver[i],min(rest,val[i]));
            if(!k) d[ver[i]] = 0;
            val[i] -= k;
            val[i^1] += k;
            rest -= k;
        }
    }
    return flow - rest;
}
vector<int> st;
int vvis[maxn];
void go(int i,vector<int>& rnt)
{
    rnt.pb(i);
    for(int j = head[i]; j ; j = Next[j])
    {
        int y = ver[j];
        if(y>n && !vvis[y-n] && !val[j])
        {
            vvis[y-n] = 1;
            go(y-n,rnt);
        }
    }
}
int main()
{
    n = read();m = read();
    tot = 1;maxflow = 0;s = 0;t = 2*n+1;
    _for(i,1,m+1)
    {
        int x = read();int y = read();
        add(x,y+n,1);add(y+n,x,0);
    }
    _for(i,1,n+1)
    {
        add(0,i,1);add(i,0,0);
        add(i+n,2*n+1,1);add(2*n+1,i+n,0);
    }  
    int flow = 0;
    while(bfs()) 
        while(flow = dinic(s,INF))
            maxflow += flow;
    vvis[0] = 1;
    _for(i,1,n+1)
    {
        for(int j = head[i+n]; j ; j = Next[j])
            if(ver[j]==2*n+1 && val[j]==1)
                st.pb(i),vvis[i] = 1; 
    }
    
    vector<int> tmp;
    _for(i,0,st.size())
    {
        vvis[st[i]] = 1,go(st[i],tmp);
        _for(j,0,tmp.size()-1)
            printf("%d ",tmp[j]);
        printf("%d\n",tmp[tmp.size()-1]);
        tmp.clear();
    }
    
    write(n-maxflow);
    return 0;
}
```


---

## 作者：ZPC2048 (赞：5)

发现网络流的做法大佬都说的差不多了，我这个蒟蒻就发一个这类问题输出路径的比较自然的方法吧。

因为路径覆盖问题中两点之间如果**有流**则代表$DAG$中这条有向边被选中作为路径的一部分，那么显然，设拆点$i$分别为$x_i$, $y_i$，遍历所有的$y_i$，**易得当$y_i$没有流流入流出时，说明点$i$为一个起点**。然后从点$i$开始dfs输出路径即可。

PS：我的算法使用的是带当前弧优化的ISAP，学习资料是咕咕日报，可自行查找。

```cpp
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<queue>
#include<algorithm>

using namespace std;

const int MAXN = 150 << 2;
const int MAXM = 6000 + 100;
const int INF = 1 << 30;

struct Edge {
    int bg, ed, nxt, flow;
    Edge(int bg = 0, int ed = 0, int nxt = 0, int flow = 0) :
        bg(bg), ed(ed), nxt(nxt), flow(flow) {};
};

struct Map {
    Edge edge[MAXM << 1];
    int head[MAXN], count = 1;
    inline void insert(int bg, int ed, int flow) {
        edge[++count] = Edge(bg, ed, head[bg], flow);
        head[bg] = count;
        edge[++count] = Edge(ed, bg, head[ed], 0);
        head[ed] = count;
    }
}A;

int depth[MAXN], gap[MAXN], cur[MAXN];
int n, m;
bool vis[MAXN];

void bfs(int s, int t) {
    memset(depth, 0, sizeof(depth));
    memset(gap, 0, sizeof(depth));
    queue<int> que;
    que.push(t);
    depth[t] = 1;
    gap[1] = 1;
    while (!que.empty()) {
        int now = que.front();
        que.pop();
        for (int i = A.head[now]; i; i = A.edge[i].nxt) {
            int v = A.edge[i].ed;
            if (depth[v]) continue;
            que.push(v);
            depth[v] = depth[now] + 1;
            ++gap[depth[v]];
        }
    }
}

int dfs(int now, int flow, int s, int t) {
    if (now == t) return flow;
    int used = 0;
    for (int i = cur[now]; i; i = A.edge[i].nxt) {
        cur[now] = i;
        int v = A.edge[i].ed;
        if (A.edge[i].flow && depth[v] + 1 == depth[now]) {
            int change = dfs(v, min(flow - used, A.edge[i].flow), s, t);
            A.edge[i].flow -= change;
            A.edge[i ^ 1].flow += change;
            used += change;
        }
        if (used == flow) return used;
    }
    --gap[depth[now]];
    if (!gap[depth[now]]) depth[s] = (n << 1) + 1;
    ++depth[now];
    ++gap[depth[now]];
    return used;
}

int ISAP(int s, int t) {
    bfs(s, t);
    int ans = 0;
    while (depth[s] <= (n << 1)) {
        memcpy(cur, A.head, sizeof(A.head));
        ans += dfs(s, INF, s, t);
    }
    return ans;
}

void print(int now, int s, int t) {
    printf("%d ", now);
    for (int i = A.head[now]; i; i = A.edge[i].nxt) {
        if (A.edge[i].flow || A.edge[i].ed == s || A.edge[i].ed == now + n) continue;//这里要注意的是不要把边连回自己
        print(A.edge[i].ed - n, s, t);//下一个点应从xi出发搜索，所以要减n
        return;
    }
}

int main() {
    memset(vis, false, sizeof(vis));
    int x, y, s, t, ans;
    scanf("%d%d", &n, &m);
    s = 2 * n + 5, t = s + 1, ans = n;
    for (int i = 1; i <= n; ++i) {
        A.insert(s, i, 1);
        A.insert(i + n, t, 1);
    }
    for (int i = 1; i <= m; ++i) {
        scanf("%d%d", &x, &y);
        A.insert(x, y + n, 1);
    }
    ans -= ISAP(s, t);
    for (int i = 1; i <= n; ++i) {
        bool flag = false;
        for (int j = A.head[i + n]; j; j = A.edge[j].nxt) //查找yi
            if (A.edge[j].flow && A.edge[j].ed != i && A.edge[j].ed != t) {
                flag = true;
                break;
            }
        if (!flag) {
            print(i, s, t);//递归输出
            printf("\n");
        }
    }
    printf("%d\n", ans);
    return 0;
}
```


---

## 作者：Isonan (赞：3)

原题传送门[>Here<](https://www.luogu.org/problemnew/show/P2764)

题目大意：要求用最少数量的链不重复地覆盖一个图的所有点。

通常做法：将每个点拆开，拆成$x_i,y_i$两个点，

1.从源点向$x_i$连边，流为1；

2.对于原图中的每跳边$(u,v)$，从$x_u$向$y_v$连边，流为1；

3.从$y_i$向汇点连边，流为1.

这样跑一边最大流，可以证明匹配后每个点入度最多为一，出度也最多为一，满足链的条件，同时因为求的是最大匹配，该方案必定用了最少的链数，所以是正确的。

代码：

```cpp
// luogu-judger-enable-o2
#include <cstdio>
#include <cstring>
#define min(X,Y) ((X)<(Y)?(X):(Y))

int n,m,head[401],nxt[320001],b[320001],v[320001],k=1,h,t,S,T,d[401],ans,net[401];
int pre[401],p[401],dis[401],q[501];
void push(int s,int t,int val){
    nxt[++k]=head[s];
    head[s]=k;
    b[k]=t;
    v[k]=val;
}
void link(int s,int t,int val){
    push(s,t,val);
    push(t,s,0);
}
bool bfs(){
    memset(dis,0,sizeof dis);
    dis[S]=1;
    h=t=0;
    q[++t]=S;
    while(h<t){
        ++h;
        for(int i=head[q[h]];i;i=nxt[i])
            if(v[i]&&!dis[b[i]]){
                dis[b[i]]=dis[q[h]]+1;
                q[++t]=b[i];
                if(b[i]==T)return 1;
            }
    }
    return 0;
}
int dfs(int x,int flow){
    if(x==T||!flow)return flow;
    int used=0;
    for(int i=p[x];i;i=nxt[i])
        if(v[i]&&dis[b[i]]==dis[x]+1){
            int w=dfs(b[i],min(flow-used,v[i]));
            v[i]-=w;
            v[i^1]+=w;
            used+=w;
            if(w)p[x]=i,net[x]=b[i]-n;
            if(used==flow)return flow;
        }
    if(!used)dis[x]=0;
    return used;
}
void print(int x){
    printf("%d ",x);
    if(net[x]>0)print(net[x]);
}
int main(){
    scanf("%d%d",&n,&m);
    T=n+n+1;
    for(int i=1,t1,t2;i<=m;i++){
        scanf("%d%d",&t1,&t2);
        link(t1,t2+n,1);
    }
    for(int i=1;i<=n;i++)link(S,i,1),link(i+n,T,1);
    while(bfs()){
        memcpy(p,head,sizeof p);
        ans+=dfs(S,2);
    }
    for(int i=1;i<=n;i++)
        if(net[i])d[net[i]]++;
    for(int i=1;i<=n;i++)if(!d[i])print(i),putchar('\n');
    printf("%d",n-ans);
}
```

---

## 作者：Lamb_Carp (赞：3)

# advertisement

这位靓仔，你都来看我的题解了，真的不来[我的博客](https://www.cnblogs.com/carp-oier/p/17731169.html)看一看嘛

# prologue

看见题解区好多神犇都是用**网络流**来做的，但是蒟蒻在刚学完**二部图**之后就来刷题了，对于这个题的路径输出有一个**比较新颖**的搞法，所以说就来写了这篇题解。

# analysis

首先，我们为了将它转换成为一个**二部图**，我们需要对它进行拆点操作（~~其实最后我跑起来并没有拆点~~），然后对它进行分析。

**（下面左部为出度的点，右部为入度的点）**

这个时候，原图中的每条路径转化到新图中，每一个点都可以对应出来一个匹配。每一条路径的**终点**都会对应到**左部**一个**非匹配点**。这个时候我们要求**最小路径覆盖**，就等价于**左部非匹配点最少**，即这个图的**最大匹配**。我们求最大匹配可以使用**匈牙利算法**（之后输出合法路径需要）。

记我们的**最大匹配**为 $m$，**最小路径覆盖**就为 $n - m$。

之后我们再考虑怎么去输出合法路径。

我们观察我们上面匈牙利算法中的 $match$ 数组，每一个**右部**点的 $match$ 都会对应到我们一个新图中的一个**左部点**，我们再将这个点放到**右部点**来看，会由它的 $match$ 对应一个**左部点**。重复以上过程，直到我们无法再匹配**左部点**。

这个不断往回匹配的过程我们可以用**递归**来解决，边界条件就是匹配到 $0$。我们只需要在跑这个递归的过程中用一个 vector 来记录路径就行。

# code time

（我下面的这个 $cnt$ 写的稀碎，我知道为啥，但是调不出来，除了占空间之外好像没啥缺点，还能当作一个~~（虚假的）~~可持久化来看）

```cpp#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define rl register ll
#define x first
#define y second

typedef pair<ll, ll> pll;

const ll N = 160;

ll n, m;

bool st[N], g[N][N];

ll cnt, pre_cnt;

ll match[N];

pll pre[N];

vector<ll> path[N];

inline bool find(ll u)
{
	for(rl i=1; i <= n; ++ i) if(g[u][i] && !st[i])
	{
		st[i] = true;
		
		ll t = match[i];
		if(!t || find(t))
		{
			match[i] = u;
			return true;
		}
	}
	
	return false;
}

inline void get_path(ll u)
{
	path[cnt].push_back(u);
	st[u] = 1;
	if(!pre[u].y) { cnt ++ ; return ;}
	get_path(pre[u].y);
}

inline bool cmp(pll a, pll b)
{
	return a.y > b.y;
}

int main()
{
	cin >> n >> m;
	
	for(rl i=1; i <= m; ++ i)
	{
		ll a, b;
		cin >> a >> b;
		g[a][b] = true; 
	}
	
	ll res = 0;
		
	for(rl i=1; i <= n; ++ i)
	{
		memset(st, 0, sizeof st);
		if(find(i)) res ++ ;
	}
	
	memset(st, 0, sizeof st);
	
	for(rl i=1; i <= n; ++ i)
		pre[i] = {i, match[i]};
	
	for(rl i=n; i; -- i) if(!st[i] && pre[i].x) get_path(pre[i].x);
	
	for(rl i=cnt - n + res; i < cnt; ++ i)
	{
		for(rl j : path[i])
			cout << j << " ";
			
		cout << endl;
	}
	
	cout << n - res << endl;
	return 0;
}
```

---

## 作者：Potassium (赞：2)

建图思路很明确，拆点跑最大匹配，但这明显是个二分图的题题解居然只有一篇匈牙利算法。

发一种和之前那篇匈牙利思路略有不同的题解。

本题的难点就是如何输出，那么我们不妨在建图的时候加入一个原则，即：**连边时位于左图的顶点编号小于位于右图的。**

![](https://cdn.luogu.com.cn/upload/pic/52363.png )

也就是说，形如左图的边是允许的，而形如右图的边是不允许的。

这很好理解吧~

在输出的时候，只要不停往上找即可。

上代码

```c
#include<stdio.h>
int n,m,e[200][200],vis[200],mt[200],p[200];
int dfs(int p,int t){
	int i;
	for(i=p;i<=n;i++){//从p开始找右半边匹配
		if(e[p][i]&&vis[i]!=t){
			vis[i]=t;
			if(!mt[i]||dfs(mt[i],t))return mt[i]=p;
		}
	}
	return 0;
}
int maxflow(){
	int i,ans=0;
	for(i=1;i<=n;i++)if(dfs(i,i))ans++;
	return ans;
}
int main(){
	int i,a,b,x;
	scanf("%d%d",&n,&m);
	for(i=0;i<m;i++){
		scanf("%d%d",&a,&b);
		if(a>b){int t=a;a=b;b=t;}//保证a<b
		e[a][b]=1;
	}
	int ans=maxflow();
	for(i=n;i;i--)if(!p[i]){
		x=i;
		do{
			printf("%d ",x);
			x=mt[x];p[x]=1;//p[i]表示已输出
		}while(x);
		printf("\n");
	}
	printf("%d",n-ans);
	return 0;
}
```


---

## 作者：Phoenix_ZH (赞：1)

要求的是最少路径数将所有的点都覆盖掉。

由konig定理知：最小点覆盖=最大匹配数；
而该题抽出模型就成了：最小路径覆盖；
最小路径覆盖=点数-最大匹配数；

如何理解这个结论呢？(这个解释并不严谨，只是为了帮助理解，请勿喷)
	加入1-->2-->3;
	可以转化为1-->2';2-->3';
	1,2,3在X中，1',2',3'在Y中；路径数=3-2；符合结论；
	再举例1-->2,1-->3,2-->4,3-->4;
	可以转化为1-->2',1-->3',2-->4',3-->4';最大匹配数为2；最少路径数为2.符合结论
由上面的例子可以分析一下：
	x与x'都处于匹配边中时，说明点x处于一条路径中；而一条路径中的开头点与结尾点的x和x'只能选择其中一个。此时(该路径中的)点个数-边数=1;
那么有多少个“1”就说明有多少条路径。就可以说明最小路径覆盖=点数-最大匹配数；

证明了以上的结论后，就可以考虑建模了：
	把一个点拆成x，x'，s向所有的x连边，所有的x' 向t连边， 如果x1-->y1，就将x1向y1’连边，所有的边容量为1(反边容量为0)；
	然后开始跑最大流，实际上跑出来的最大流就是最大匹配数，那么最小边覆盖=n-ans；
接着要开始说明每一条路径：
	从1-n都枚举一边，每一个点连向的是x',并且如果最大流流向了x'(流向了x’就说明该边流量为0），然后输出该值，继续dfs。
	注意要排除s，t的点；
    ```
#include<bits/stdc++.h> 
using namespace std;
const int maxn=600000+5;
int n,m,k=1,head[maxn];
struct node
{
	int to,next,w;
}edge[maxn*2];
void add(int u,int v,int w)
{
	edge[++k].to=v;edge[k].next=head[u];head[u]=k;edge[k].w=w;
}
int s,t,ans,deep[maxn];
bool bfs()
{
	queue<int>q;
	memset(deep,0,sizeof(deep));
	deep[s]=1;q.push(s);
	while(!q.empty())
	{
		int x=q.front();q.pop();
		for(int i=head[x];i;i=edge[i].next)
		{
			if(edge[i].w&&!deep[edge[i].to])
			{
				deep[edge[i].to]=deep[x]+1;
				q.push(edge[i].to);
			}
		}
	}
	if(deep[t])return 1;
	return 0;
}
int dfs(int x,int F)
{
	if(x==t)return F;
	int f=0;
	for(int i=head[x];i;i=edge[i].next)
	{
		if(deep[edge[i].to]==deep[x]+1&&edge[i].w)
		{
			int w=dfs(edge[i].to,min(F,edge[i].w));
			edge[i].w-=w;edge[i^1].w+=w;f+=w;F-=w;	
		}
	}
	if(!f)deep[x]=0;
	return f;
}
void dinic()
{
	while(bfs())
	{
		ans+=dfs(s,0x3f3f3f3f);
	}
}
int vis[maxn];
void work(int x)
{
	for(int i=head[x];i;i=edge[i].next)
	{
		int TO=edge[i].to;
		if(TO>2*n)continue;
		if(TO>n)TO-=n;
		if(edge[i].w==0&&!vis[TO])
		{
			int x=edge[i].to;
			if(x>n)x-=n;
			cout<<x<<' ';
			vis[x]=1;
			work(x);
		}
	}
}
int main()
{
	cin>>n>>m;
	s=2*n+1;t=s+1;
	for(int i=1;i<=n;i++)add(s,i,1),add(i,s,0);
	for(int i=1;i<=m;i++)
	{
		int a,b;
		cin>>a>>b;
		add(a,b+n,1);add(b+n,a,0);
	}
	for(int i=1;i<=n;i++)add(i+n,t,1),add(t,i+n,0);
	dinic();
	for(int i=1;i<=n;i++)
	{
		if(!vis[i])
		{
			vis[i]=1;
			cout<<i<<' ';
			work(i);
			cout<<endl;
		}
	}
	cout<<n-ans<<endl;
	return 0;
}
```


---

## 作者：little_sun (赞：0)

1.建立两个集合$x$和$y$

2.如果有一条边$<u,v>$,则从$x$集合中的$u$点连向$y$集合的$v$点，容量为$inf$

3.从$s$向$x$中每一个点连边，从$y$中每一个点向$t$连边，容量为$1$

答案就是$n-$最大匹配

为什么呢？因为如果如果两个点匹配，就意味着他们可以用一条边连接，路径数量就$-1$
 
```cpp
#include <bits/stdc++.h>

#define R register
#define ll long long
#define cmax(a, b) ((a < b) ? b : a)
#define cmin(a, b) ((a < b) ? a : b)
#define sum(a, b, mod) ((a + b) % mod)

const int MaxN = 2e4 + 10;
const int MaxM = 5e5 + 10;
const int inf = (1 << 30);

struct edge
{
    int to, next, cap;
};

edge e[MaxM];
int n, m, s = 20000, t = 20001, cnt = 1, ans;
int head[MaxN], dep[MaxN], cur[MaxN], a[MaxN], vis[MaxN], to[MaxN];

inline void add(int u, int v, int c)
{
    ++cnt;
    e[cnt].to = v;
    e[cnt].next = head[u];
    e[cnt].cap = c;
    head[u] = cnt;
}

inline void add_edge(int u, int v, int c) { add(u, v, c), add(v, u, 0); }

inline int read()
{
    int x = 0;
    char ch = getchar();
    while (ch > '9' || ch < '0')
        ch = getchar();
    while (ch <= '9' && ch >= '0')
        x = (x << 1) + (x << 3) + (ch ^ 48), ch = getchar();
    return x;
}

inline int bfs()
{
    memset(dep, 0, sizeof(dep));
    memcpy(cur, head, sizeof(head));
    std::queue<int> q;
    dep[s] = 1;
    q.push(s);
    while (!q.empty())
    {
        int u = q.front();
        q.pop();
        for (int i = head[u]; i; i = e[i].next)
        {
            int v = e[i].to, c = e[i].cap;
            if (dep[v] || !c)
                continue;
            dep[v] = dep[u] + 1;
            q.push(v);
        }
    }
    return dep[t];
}

inline int dinic(int u, int flow)
{
    if (u == t)
        return flow;
    int rest = flow;
    for (int i = cur[u]; i && (flow - rest < flow); i = e[i].next)
    {
        int v = e[i].to, c = e[i].cap;
        if (dep[v] != dep[u] + 1 || !c)
            continue;
        int k = dinic(v, cmin(rest, c));
        if (!k)
            dep[v] = dep[u] + 1;
        else
        {
            e[i].cap -= k;
            e[i ^ 1].cap += k;
            rest -= k;
            if (e[i].to > n)
                vis[e[i].to - n] = 1;
            to[u] = e[i].to;
        }
    }
    if (flow - rest < flow)
        dep[u] = -1;
    return flow - rest;
}

inline void solve()
{
    int now = 0;
    while (bfs())
        while ((now = dinic(s, inf)))
            ans += now;
}

int main()
{
    n = read(), m = read();
    for (int i = 1; i <= m; i++)
    {
        int u = read(), v = read();
        add_edge(u, v + n, inf);
    }
    for (int i = 1; i <= n; i++)
        add_edge(s, i, 1), add_edge(i + n, t, 1);
    solve();
    for (int i = 1; i <= n; i++)
    {
        if (vis[i])
            continue;
        printf("%d ", i);
        int t = i;
        while (to[t])
        {
            printf("%d ", to[t] - n);
            t = to[t] - n;
        }
        puts("");
    }
    printf("%d\n", n - ans);
    return 0;
}
```



---

## 作者：Ireliaღ (赞：0)

**最大流=最小割**

ISAP最大流+指针存图

## 建图

* 把原图每一个节点$i$拆成入点$i$和出点$i + n$，设超级源点为$0$，超级汇点为$n \times 2 + 1$

* 对于$\forall i \in [1, n]$，从$0$向$i$连边，容量$1$

* 对于$\forall i \in [1, n]$，从$i + n$向$n \times 2 + 1$连边，容量$1$

* 对于输入一条边$u \to v$，从$u$向$v + n$连边，容量$1$

## 输出

我们要找到**没被割掉并且是一条路径起点的点**，然后递归输出这条路径，具体见代码

最终路径数为$n - maxflow$

## 代码


```cpp
// luogu-judger-enable-o2
#include <queue>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int MAXN = 65;
const int MAXM = 6e3 + 5;
const int INF = 0x3f3f3f3f;

int n, m;

struct Edge{
    int to, val;
    Edge *nxt, *ops;
    Edge(int to, int val, Edge *nxt): to(to), val(val), nxt(nxt) {}
};

namespace ISAP{
    Edge *head[MAXN << 1], *cur[MAXN << 1];
    int s, t, dep[MAXN << 1], gap[MAXN << 1], res;
    
    void AddEdge(int u, int v, int w) {
        head[u] = new Edge(v, w, head[u]);
        head[v] = new Edge(u, 0, head[v]);
        head[v]->ops = head[u]; head[u]->ops = head[v];
    }
    
    void Bfs() {
        memset(dep, -1, sizeof(dep));
        memset(gap, 0, sizeof(gap));
        dep[t] = 0; gap[dep[t]]++;
        queue<int> q; q.push(t);
        while (!q.empty()) {
            int u = q.front(); q.pop();
            for (Edge *e = head[u]; e; e = e->nxt) {
                int v = e->to;
                if (dep[v] != -1) continue;
                dep[v] = dep[u] + 1;
                gap[dep[v]]++;
                q.push(v);
            }
        }
    }
    
    int Dfs(int u, int flow) {
        if (u == t) {
            res += flow;
            return flow;
        }
        int used = 0;
        for (Edge *e = head[u]; e; e = e->nxt) {
            int v = e->to;
            if (e->val && dep[v] == dep[u] - 1) {
                int mi = Dfs(v, min(e->val, flow - used));
                if (mi) {
                    e->val -= mi;
                    e->ops->val += mi;
                    used += mi;
                }
                if (used == flow) return used;
            }
        }
        gap[dep[u]]--;
        if (gap[dep[u]] == 0) dep[s] = n * 2 + 3;
        dep[u]++;
        gap[dep[u]]++;
        return used;
    }
    
    void Work() {
        res = 0;
        Bfs();
        while (dep[s] <= n << 1) Dfs(s, INF);
    }
    
    void Print(int u) {//输出路径
        cout << u << ' ';
        for (Edge *e = head[u]; e; e = e->nxt) {
            int v = e->to;
            if (e->val == 0 && v > n && v <= n << 1) {
                Print(v - n);
                return;
            }
        }
    }
}

int main() {
    ios :: sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);
    cin >> n >> m;
    ISAP :: s = 0; ISAP :: t = n * 2 + 1;
    for (int i = 1; i <= m; i++) {
        int x, y;
        cin >> x >> y;
        ISAP :: AddEdge(x, y + n, 1);
    }
    for (int i = 1; i <= n; i++) {
        ISAP :: AddEdge(0, i, 1);
        ISAP :: AddEdge(i + n, n * 2 + 1, 1);
    }
    ISAP :: Work();
    /*for (Edge *e = ISAP :: head[0]; e; e = e->nxt) {
        if (e->val == 0) ISAP :: Print(e->to), cout << endl;
    }*/
    //for (int i = 1; i <= n; i++) if (!nots[i]) ISAP :: Print(i), cout << endl;
    for (int i = 1; i <= n; i++) {//找起点
        bool ff = false;
        for (Edge *e = ISAP :: head[i + n]; e; e = e->nxt) {
            int v = e->to;
            if (e->val && v >= 1 && v <= n) {
                ff = true;
                break;
            }
        }
        if (!ff) ISAP :: Print(i), cout << endl;
    }
    cout << n - ISAP :: res << endl;
    return 0;
}
```

~~反抄袭自寻~~

---

## 作者：xiekeyi98 (赞：0)

看到很多dalao写的都是网络流解法，本弱因为先学匈牙利后学网络流的缘故，所以二分图相关都尝试能通过匈牙利就用匈牙利做。

这道题首先要注意的一点是：他是有向图！有向图！
如果当做无向图，利用我一开始想的一知半解的【最短路径覆盖数 = 顶点数 - 最大匹配数】(很好想，只要考虑到多合并一个点，就少一条的情况），就会过样例但是却WA的不知道到哪里去了。

所以对于有向图的最短路径情况，我们应该将他转成二分图的情况。如何转换呢？拆点！
![拆点](http://thyrsi.com/t6/387/1539685008x-1566701873.jpg)
之前看到题解有人写的拆点，百思不得其解为啥要拆。看到这张图秒懂。

代码里也有注释，看代码吧(代码输出路径参考了题解里唯一一个匈牙利的的老哥)
```cpp
// 核心在于拆点。
// 一开始认为这种情况和普通的二分图没什么区别，所以直接正常建图跑匈牙利了
// (因为初学匈牙利，还建了双向边)
// 后来发现只能过一个点，于是查了查题解。
// 发现【有向图】的最短路径覆盖问题和二分图最短路径覆盖问题是不一样的(但是可以转化)
// 如 1->2->3，直接匈牙利显然问题多多。
// 但是如果变成 1 -> 2 -> 2' -> 3 . 这时候在做匈牙利，问题就迎刃而解啦(注意之后输出的时候合并)
//
#include<bits/stdc++.h>
using namespace std ;
const int maxn = 10100;
struct Edge
{
	int to ;
	int nxt = -1 ;
}edge[maxn];
int tol = 0 ; 
int head[maxn];
int n , m ;

void init()
{
	tol = 0 ;
	memset(head,-1,sizeof(head));
	memset(edge,-1,sizeof(edge));
}
void addedge( int u , int v )
{
	edge[tol].to = v ;
	edge[tol].nxt = head[u];
	head[u] = tol++;
}


bool used[maxn];
int linker[maxn];

int dfs( int u )
{
	for( int i = head[u] ; ~i ; i = edge[i].nxt )
	{
		int to = edge[i].to ;
		if( !used[to] )
		{
			used[to] = true ;
			if( linker[to] == 0 || dfs(linker[to]) )
			{
				linker[to] = u ;
				linker[u] = to ;
				return 1 ;
			}
		}
	}
	return 0 ;
}

int xiongyali(int n )
{
	int res = 0;
	for( int i = 1 ; i <= n ; i++)
	{
		memset(used,0,sizeof(used));
		if( dfs(i) )
			res++;
	}
	return res;
}




void print( int x)
{
	x += n; //为了统一操作，所以我们先加一次
	do 
	{
		x = x - n ;
		cout << x << ' ' ;
		used[x] = 1 ;
		x = linker[x]; 
		// linker[x]是个大于n的，所以每次要相减
	}
	while(x);
	cout << endl;
}
int main()
{
	init();
	cin >> n >> m ;
	for( int i = 1 ; i <= m ; i++)
	{
		int u , v ;
		cin >> u >> v ;
		addedge(u,v+n);
		//addedge(v+n,u); 加上会RE，不知道为什么。
	}
	int res = xiongyali(n);
	memset(used,0,sizeof(used));
//	cout << "DEBUG" << endl ;
//	for( int i = 1 ; i <= n ; i++)
//		cout << i << "->" << linker[i] << endl;  
//	cout << endl ;
	for( int i = 1 ; i <= n ; i++)
	{
		if( !used[i] )
			print(i);
			//dfs2(i , vector<int>() );
	}
	//cout << res << endl ;
	// 最短路径覆盖数 = 顶点数 - 最大匹配边数 = 顶点数 - 最多匹配点数
	cout << n - res << endl ; 
	return 0 ;
}



```




---

## 作者：SGOI_Aromyase (赞：0)

顺着luogu试炼场刷网络流，还是挺好的..

上一题是P2765 魔术球问题

正解是转换成二分图，进行最小覆盖的匹配，找路径也因此会容易很多.

##  emmm....扯远了，回到这道题。

我们把一个点拆成两个，分别放在这个二分图的两边，对于一条路径，我们将from点和to点，左右各一个进行连边

Dinic找最大匹配（蒟蒻不会匈牙利qwq）。求出点数（当然，也是二分图总点数的一半）-最大匹配。

为什么要找点数-最大匹配呢？

我们可以发现，如果路径总点数为n，那么在同一个路径上的(n-1)个点，会因为匹配而删掉。

那么留下的点，必然是一条路径的开始（或结束）

两道题都是这样的建模，各自都十分抽象..

找路径的方法：

base是汇点一侧的点，需要额外增加的序号。参考这段代码后面的完整代码。
```
bool ok[505];
void dfss(int u)
{
	ok[u]=true;
	printf("%d ",u);
	for(int i=0;i<a[u].size();i++){
		ro c=edge[a[u][i]];
		if(c.to>base&&c.flow<1&&ok[c.to-base]==0) dfss(c.to-base);
	}
}

void find()
{
	for(int i=1;i<=n;i++) if(!ok[i]){
		dfss(i);
		printf("\n");
	}
}
```

完整代码：
```
#include<bits/stdc++.h>
using namespace std;
#define maxn 2005
#define en 2003
#define base 1000
#define me(x,y) memset(x,y,sizeof(x))
#define fo(i,a,b) for(int i=a;i<=b;i++)
#define inf 0x3f3f3f3f
int n,m,ans;
struct ro{
	int fr,to,flow;
};
vector<ro> edge;
vector<int> a[maxn];
int d[maxn];
queue<int> q;
bool bfs()
{
	me(d,-1);d[0]=0;q.push(0);
	while(!q.empty()){
		int now=q.front();q.pop() ;
		for(int i=0;i<a[now].size();i++){
			ro c=edge[a[now][i]];
			if(c.flow<1||d[c.to]!=-1) continue;
			d[c.to]=d[now]+1;
			q.push(c.to);
		}
	}
	return (d[en]!=-1);
}
int dfs(int u,int flow)
{
	if(u==en) return flow;
	int cnt=0;
	for(int i=0;i<a[u].size();i++){
		ro c=edge[a[u][i]];
		if(c.flow<1||d[c.to]!=d[u]+1) continue;
		int qwq=dfs(c.to,min(c.flow,flow));
		cnt+=qwq;
		flow-=qwq;
		edge[a[u][i]].flow-=qwq;
		edge[a[u][i]^1].flow+=qwq;
		if(flow==0) break;
	}
	if(cnt==0) d[u]=-1;
	return cnt;
}

void getb(int fr,int to,int flow)
{
	ro c;c.fr=fr,c.to=to;c.flow=flow;
	edge.push_back(c);
	a[fr].push_back(edge.size()-1);
	swap(c.fr,c.to);c.flow=0;
	edge.push_back(c);
	a[to].push_back(edge.size()-1);
}

void sc()
{
	cin>>n>>m;
	fo(i,1,n) getb(0,i,1),getb(base+i,en,1);
	fo(i,1,m){
		int fr,to;scanf("%d%d",&fr,&to);
		getb(fr,to+base,1);
	}
}
bool ok[505];
void dfss(int u)
{
	ok[u]=true;
	printf("%d ",u);
	for(int i=0;i<a[u].size();i++){
		ro c=edge[a[u][i]];
		if(c.to>base&&c.flow<1&&ok[c.to-base]==0) dfss(c.to-base);
	}
}

void find()
{
	for(int i=1;i<=n;i++) if(!ok[i]){
		dfss(i);
		printf("\n");
	}
}


int main()
{
	sc();
	while(bfs()) ans+=dfs(0,inf);
	find();
	cout<<n-ans;
	return 0;
}
```

---

## 作者：秋日私语 (赞：0)

更好的阅读体验点[这里](https://blog.csdn.net/A_Comme_Amour/article/details/79671753)

题目
-

[传送门](https://www.luogu.org/problemnew/show/P2764)

题解
-

原理：最小路径覆盖数=点数-匹配数；
很好理解：两个点可以匹配，相当于是放到并查集里面，并查集的个数就是路径的条数；

但是我对建图的理解一直就是错误的；

我原来跑了二分图染色分成了两个集合，在里面跑二分图匹配；错误之处在于我错误的没有拆点；

于是我又认为每个点只能走一次，所以就每个点向所拆的点之间连了容量为1的边；错误之处在于电和点之间无法确立联系；

正确的建图方法是：每个点都拆点 i 和i+n 但是不相连；S连向i 容量1； i+n连向T 容量1；如果两个点相连x连向 y+n （体会一下这样建图的巧妙）；可以说两个点具有*隐形*的联系；

以 1-->2-->3为例

![这里写图片描述](https://img-blog.csdn.net/20180323193209466?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FfQ29tbWVfQW1vdXI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

但是建图有难倒了我；nxt[]和pre[]分别记录点的后继和前驱；递归输出；

代码
-


```
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<iostream>
#include<queue>
using namespace std;
const int maxn=1000001;
const int inf=1e9;
queue <int> q;
int n,m,k,maxflow,a[maxn],S,T;
struct Edge{
	int next,to,dis;
}edge[maxn<<1];
int num_edge=-1,head[maxn],cur[maxn],deep[maxn];
int nxt[maxn],pre[maxn];//分别表示点i的前一个点和后一个点是什么 

void add_edge(int from,int to,int dis)
{
	edge[++num_edge].next=head[from];
	edge[num_edge].dis=dis;
	edge[num_edge].to=to;
	head[from]=num_edge;
}
void add(int x,int y,int z) {add_edge(x,y,z); add_edge(y,x,0);}

bool bfs(int s,int t)
{
	memset(deep,0x7f,sizeof(deep));
	for (int i=0; i<=t; i++) cur[i]=head[i];
	while (!q.empty()) q.pop();
	q.push(s); deep[s]=0;
	while (!q.empty())
	{
		int now=q.front(); q.pop();
		for (int i=head[now]; i!=-1; i=edge[i].next)
		{
			int to=edge[i].to;
			if (deep[to]>inf && edge[i].dis)
			{
				deep[to]=deep[now]+1;
				q.push(to);
			}
		}
	}
	return deep[t]<inf;
}

int dfs(int now,int t,int limit)
{
	if (now==t || !limit) return limit;
	int flow=0,f;
	for (int i=cur[now]; i!=-1; i=edge[i].next)
	{
		int to=edge[i].to; cur[now]=i;
		if (deep[to]==deep[now]+1 && (f=dfs(to,t,min(limit,edge[i].dis))))
		{
			flow+=f;
			limit-=f;
			edge[i].dis-=f;
			edge[i^1].dis+=f;
			if (!limit && now!=S && to!=T) nxt[now]=to-n; pre[to-n]=now;
			if (!limit) break;
		}
	}
	return flow;
}

void Dinic(int s,int t)
{
	while (bfs(s,t))
		maxflow+=dfs(s,t,inf);
}
bool vis[maxn];
void shuchu(int x)
{
	if (!x) return;//到达了源点 
	if (pre[x]!=x) shuchu(pre[x]);
	vis[x]=1;
	printf("%d ",x);
}

int main()
{
	memset(head,-1,sizeof(head));
	scanf("%d%d",&n,&m);
	S=0; T=2*n+1;
	for (int i=1; i<=n; i++) nxt[i]=pre[i]=i;
	for (int i=1; i<=n; i++) {add(S,i,1); add(i+n,T,1);}
	for (int i=1; i<=m; i++)
	{
		int x,y; scanf("%d%d",&x,&y);
		add(x,y+n,1);
	}
//	for (int i=0; i<=num_edge; i++) printf("%d: %d %d %d\n",i,edge[i^1].to,edge[i].to,edge[i].dis);
	Dinic(S,T);
//	for (int i=1; i<=n; i++) printf("%d %d\n",nxt[i],pre[i]);
	for (int i=n; i>=1; i--)
		if (nxt[i]==i && !vis[i]) {shuchu(i); printf("\n");}
	printf("%d",n-maxflow);
	return 0;
}
```

总结
-

输出方法

---

## 作者：Sym_Je (赞：0)

        P2764 最小路径覆盖问题    
  
  [https://www.luogu.org/problemnew/show/P2764]()  
  
  今天我们来看一下这道题 ，首先我们得先知道啥是 《最小路径覆盖》 ,从字面上来看，就是用最少的几条简单路径来覆盖所有点 。   
  本体就是然我们输出这张有向无环图的图的最小路径覆盖，和其值 。      
  这道题我们还是用网络流或二分图来做(因为裂开点的后半段只与一个裂开点的前半段相匹配)来做 , 首先肯定然后是建图，这也是网络流中最关键的一步 。    
  如何建图呢，我们能直接建么？，这肯定是不行的啊，因为这样建完之后，我们就无法回溯了，因为我们要建一个炒鸡大始点与汇点(因为我们不知道 $s$ 与 $t$ )，如果不裂点，就会很迷 ，最大流就会为不准 。    
  然后我们用总的 $n - dinic()$ 就是答案 ， 为啥呢，我们可以画画看,其实最大流就是有多少个点可以合到一起去 。  
  因为我们首先是把 $s$ ，向所有点的前半连 $1$ 边 ，所以每个点都只有 $1$的流量,当我们汇到 $t$ 时，肯定是由一个裂开点的后半段流过来 ,所以我们只要看有多少个匹配了，就是这几个点合成了一个大点，最后数有几个点就好咯 。
  然后我们来想如何输出，我们先从 $t$ 点走我们看 $t$ ，点是由那几个点的贡献来的，然后我们一直找匹配点就好咯 。   
  
  
  
 
 
 ```
 
 评测状态
Accepted  100
用时: 47ms / 内存: 4880KB
 
 #include<bits/stdc++.h>
#define debug cout<<"2333" 
using namespace std;

const int maxn=150001;
const int inf=1e8;
int num=1;
struct Edge
{
	int from,nt,to,dis;
}edge[maxn];
int head[maxn],dep[maxn],vis[maxn],viss[maxn];

void add(int from,int to,int dis)
{
	edge[++num].nt=head[from];
	edge[num].from=from;
	edge[num].to=to;
	edge[num].dis=dis;
	head[from]=num;
}

void ADD(int a,int b,int c)
{
	add(a,b,c);
	add(b,a,0);
}

int n,m,s=0,t=50010;

int bfs()
{
	queue<int> q;
	memset(dep,0,sizeof(dep));
	dep[s]=1;
	q.push(s);
	while(!q.empty())
	{
		int u=q.front();
		q.pop();
		for(int i=head[u];i!=-1;i=edge[i].nt)
		{
			int v=edge[i].to;
			if(dep[v]==0&&edge[i].dis)
				dep[v]=dep[u]+1,q.push(v);
		}
	}
	return dep[t]!=0;
}

int dfs(int u,int dist)
{
	if(u==t) return dist;
	for(int i=head[u];i!=-1;i=edge[i].nt)
	{
		int v=edge[i].to;
		if(dep[v]==dep[u]+1&&edge[i].dis)
		{
			int di=dfs(v,min(dist,edge[i].dis));
			if(di)
			{
				edge[i].dis-=di;
				edge[i^1].dis+=di;
				return di;
			}
		}
	}
	return 0;
}

int dinic()
{
	int ss=0;
	while(bfs())
		while(int di=dfs(s,inf))
			ss+=di;
	return ss;
}

int sy,a[maxn];

void work(int u)
{
	for(int i=head[u];i!=-1;i=edge[i].nt)
	{
		int v=edge[i].to;
		if(vis[v]) continue;
		if(edge[i].dis==0&&edge[i^1].dis==0)
		{
			cout<<v<<" ";
			vis[v]=1;
			work(v);
		}
	}
	return ;
}

void print(int u)
{
	if(u<=s) return ;
	printf("%d ",u);
	for(int i=head[u];i!=-1;i=edge[i].nt)
	{
		if(!edge[i].dis&&edge[i].to<=2*n) print(edge[i].to-n);
	}
}

int main()
{
	memset(head,-1,sizeof(head)); 
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;++i)
		ADD(s,i,1),ADD(i+n,t,1);
	int now=num;
	for(int i=1;i<=m;++i)
	{
		int u,v;
		scanf("%d%d",&u,&v);
		ADD(u,v+n,1);
	}
	int tot=n;
	tot-=dinic();
	for(int i=head[t];i!=-1;i=edge[i].nt)
	{
		if(edge[i].dis){/*cout<<edge[i].to<<"*"		int v=edge[i].to;//如果这条边有贡献，呢么就不走，因为这条边所连的点肯定会从一个没贡献的边到达
		print(v-n);cout<<"\n";
	}
	cout<<tot<<endl;
	return 0;
}



```


  

---


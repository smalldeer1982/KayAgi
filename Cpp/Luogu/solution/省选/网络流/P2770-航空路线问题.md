# 航空路线问题

## 题目描述

给定一张航空图，图中顶点代表城市，边代表两城市间的直通航线，并且不存在任何两个城市在同一条经线上。现要求找出一条满足下述限制条件的且途经城市最多的旅行路线。

1. 从最西端城市出发，单向从西向东途经若干城市到达最东端城市，然后再单向从东向西飞回起点（可途经若干城市）。

2. 除起点城市外，任何城市只能访问一次。

对于给定的航空图，试设计一个算法找出一条满足要求的最佳航空旅行路线。

## 说明/提示

**数据规模与约定**

对于 $100\%$ 的数据，保证 $1 \leq n < 100$，$1 \leq v \leq \frac{n \times (n - 1)}{2}$，$s_i$ 的长度不超过 $15$，且仅可能包含大小写字母与数字，$x, y$ 一定是输入中给出的城市名，且不会有同一组 $x, y$ 被给出两次。


## 样例 #1

### 输入

```
8 9
Vancouver
Yellowknife
Edmonton
Calgary
Winnipeg
Toronto
Montreal
Halifax
Vancouver Edmonton
Vancouver Calgary
Calgary Winnipeg
Winnipeg Toronto
Toronto Halifax
Montreal Halifax
Edmonton Montreal
Edmonton Yellowknife
Edmonton Calgary```

### 输出

```
7
Vancouver
Edmonton
Montreal
Halifax
Toronto
Winnipeg
Calgary
Vancouver ```

# 题解

## 作者：w4p3r (赞：75)

## 思路：
这道题求出答案应该不难，

对于每个点拆成Ai和Bi两个点，两个点之间的容量为1，边权为1，**（因为每个点只能选一次，每选一个点可以对答案造成1的贡献）**
**（若i为1或n容量应为2，因为这两个点可以选两次）**

对于每条从u到v的边，让Bu向Av建一条容量为1，边权为0的边**（因为每条边只能选一次，选边并不会对答案造成影响）**

最后从源点向A1建一条容量为2，边权为0,的边

从Bn向汇点建一条容量为2，边权为0的边

跑**最大费用最大流**即可

问题是如何输出城市呢？

我的思路是进行两遍dfs，

第一次dfs找到一条1到n所有边的flow都为0的路径正序输出，

第二次dfs找到另一条1到n所有边的flow都为0的路径倒序输出（这次n不输出）

还是有一定坑点的，具体看代码吧

## 代码：

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<vector>
#include<cmath>
#include<queue>
#include<map>
#define inf 0x7fffffff/2
#define eps 1e-6
#define N 100010
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
inline ll read()
{
	char ch=getchar();
	ll s=0,w=1;
	while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){s=s*10+ch-'0';ch=getchar();}
	return s*w;
}
int n,m;
map<string,int>ma;
struct edge
{
	int next,to,fl,v;
}e[N<<1];
int head[N],cnt=1;
int dist[N],pre[N],vis[N],minn[N];
queue<int>Q;
int s,t,val,flag[N],check;
string ss[N];
inline void add_edge(int from,int to,int fl,int v){e[++cnt].to=to;e[cnt].next=head[from];e[cnt].fl=fl;e[cnt].v=v;head[from]=cnt;}
void update(int x,int flow)
{
	e[pre[x]].fl-=flow;
	e[pre[x]^1].fl+=flow;
	if(e[pre[x]^1].to)update(e[pre[x]^1].to,flow);
}
inline int spfa()
{
	memset(vis,0,sizeof(vis));while(!Q.empty())Q.pop();
	for(register int i=1;i<=t;i++)dist[i]=-inf;
	minn[s]=inf;dist[s]=0;Q.push(s);vis[s]=1;
	while(!Q.empty())
	{
		int x=Q.front();Q.pop();vis[x]=0;
		for(register int i=head[x];i;i=e[i].next)
		{
			if(dist[e[i].to]<dist[x]+e[i].v&&e[i].fl)
			{
				dist[e[i].to]=dist[x]+e[i].v;
				pre[e[i].to]=i;
				minn[e[i].to]=min(minn[x],e[i].fl);
				if(!vis[e[i].to])
				{
					vis[e[i].to]=1;
					Q.push(e[i].to);
				}
			}
		}
	}
	if(dist[t]==-inf)return -inf;
	update(t,minn[t]);val+=minn[t];
	return minn[t]*dist[t];
}
inline int EK()
{
	int sum=0;
	while(1)
	{
		int x=spfa();
		if(x==-inf)return sum;
		sum+=x;
	}
}//最大费用最大流
void dfs1(int x)
{
	cout<<ss[x]<<endl;//第一遍dfs正序输出
	vis[x]=1;//不让第二次dfs再找到这个点
	for(register int i=head[x];i;i=e[i].next)
	{
		if(e[i].to>n&&e[i].to<=2*n&&e[i].fl==0){dfs1(e[i].to-n);break;}//第一次dfs只找一条路径，找到就break
	}
}
void dfs2(int x)
{
	vis[x]=1;
	for(register int i=head[x];i;i=e[i].next)
	{
		if(e[i].to>n&&e[i].to<=2*n&&e[i].fl==0&&!vis[e[i].to-n]){dfs2(e[i].to-n);}//不走第一次路径走过的点
	}
	cout<<ss[x]<<endl;//第二次dfs倒序输出
}//vis[n]在第一次dfs已经设为1，不会输出第二次
int main()
{
	n=read(),m=read();t=n*2+1;
	for(register int i=1;i<=n;i++)
	{
		cin>>ss[i];ma[ss[i]]=i;
	}
	for(register int i=1;i<=m;i++)
	{
		string s1,s2;
		cin>>s1>>s2;
		int x=ma[s1],y=ma[s2];
		if(x>y)swap(x,y);//让西边的点向东边建边
        if(x==1&&y==n)check=1;//如果有直接1-n的路径
		add_edge(x,y+n,1,0);add_edge(y+n,x,0,0);
	}
	add_edge(s,n+1,inf,0);add_edge(n+1,s,0,0);
	add_edge(n,t,inf,0);add_edge(t,n,0,0);
	for(register int i=1;i<=n;i++)
	{
		if(i!=1&&i!=n)add_edge(i+n,i,1,1),add_edge(i,i+n,0,-1);
		else add_edge(i+n,i,2,1),add_edge(i,i+n,0,-1);
	}
    //对于我的代码,1-n是Bi,n+1-2*n是Ai
	int maxflow=EK();
	if(val==2)printf("%d\n",maxflow-2);//1和n被重复计算，应该减去
	else if(val==1&&check){printf("%d\n",2);cout<<ss[1]<<endl<<ss[n]<<endl<<ss[1]<<endl;return 0;}//如果有1-n直接的路径即使只有1条也是满足条件的
	else {printf("No Solution!\n");return 0;}
	memset(vis,0,sizeof(vis));
	dfs1(1);dfs2(1);//输出城市
	return 0;
}
```


**如果认为我这篇题解对你有帮助的可以给我点一下赞qwq。如果有任何疑问，或者认为我的题解有什么问题的话，请务必私信我，感激不尽！我会努力把我的题解写得最好的!**

---

## 作者：皎月半洒花 (赞：28)

说一点实现上的小细节吧。主要内容是「跟其他题解不一样的东西」。

发现大家在做这个题的时候，都是特判的「是否存在一条直接连通 $1$ 和 $n$」 的路径，然后直接输出。首先这么做，较为麻烦(虽然也就只多了一两二三行)，其次正确性有待考究。

这个地方就需要思考，为什么大家的实现需要特判这个细节？原因是假设只有 $1\leftrightarrow n$ 这一条边，那么这条路需要走两次。但是连边 $(u,v)$ 的时候大家都是写的 `add(u',v,1,0)`，导致只能走一次。个人认为，由于这是个基础题，所以每个细节都需要写的十分合理，但这个地方显然就不合理。

网络流题讲究对着限制找`flow`，对着代价找`cost`。这个题目里显然只限制了一个点至多走一次，但是没限制一条边至多走一次——虽然本质上，没啥很大区别，因为点至多一次决定了边至多一次——但是这从某种程度上决定了对这个题建模的理解程度。所以我认为，为了更好地实现「网络流24题」的网络流教学任务，应该在连边 $(u,v)$ 时如是写：

```cpp
add(u',v,Inf,0)
```

这样有两个好处：

1、只需要特判无解，根本不需要那些无聊的判来判去判流量多少，影响代码的美观和简练。

2、体现了这个题建模的本质意义。因为已经有拆点保证了题目中的要求的限制，如果再硬生生加上一个「边也至多走一次」，就是在无中生有、暗度陈仓(雾)。而精准的建模是网络流学习阶段所必须掌握的东西。

```cpp
int main(){
    cnt = -1 ;
    cin >> _n >> _m ;
    x = _n * 2 ; y = 1 + _n ;
    _s = 0 ; _t = _n + _n + 1 ;
    memset(head, -1, sizeof(head)) ;
    add(_s, 1, 2, 0) ; add(x, _t, 2, 0) ;
    add(1, y, 2, -1) ; add(_n, x, 2, -1) ;
    for (int i = 1 ; i <= _n ; ++ i)
        cin >> s, rt[t[s] = i] = s ;
    for (int i = 1 ; i <= _n ; ++ i)
        add(i, i + _n, 1, -1) ;
    for (int i = 1 ; i <= _m ; ++ i){
        cin >> s >> ss ;
        int p = t[s] ;
        int q = t[ss] ;
        if (p > q) swap(p, q) ;
        //cout << p << " " << q << endl ;
        add(p + _n, q, I, 0) ;
    }
    buc[1] = 1 ;
    n = _t + 1 ; ek() ;
    if (!ret)
        return puts("No Solution!"), 0 ;
    cout << -res - 2 << endl ;
    dfs(1, l) ; cout << rt[1] << endl ;
    for (int i = 0 ; i < l ; ++ i)
        cout << rt[ans[i]] << '\n' ; l = 0 ;
    for (int i = 0 ; i <= cnt ; ++ i)
        if (ct(i) == -1 && !fw(i) && !buc[fr(i)])
            ans[++ l] = fr(i) ;
    sort(ans + 1, ans + l + 1, comp) ;
    for (int i = 1 ; i <= l ; ++ i)
        cout << rt[ans[i]] << '\n' ;
    return cout << rt[1] << endl, 0 ;
}

```

btw，其实只需要dfs一遍即可。由于访问过程一定是单调的，所以将走完一遍后那些没走过的节点排序输出即可。

---

## 作者：辰星凌 (赞：14)


# **【题解】【网络流24题】航空路线问题 [P2770] [Loj6122]**

[更好的阅读体验](https://www.cnblogs.com/Xing-Ling/p/11405914.html)

**传送门：[航空路线问题 $[P2770]$](https://www.luogu.org/problem/P2770) [$[Loj6122]$](https://loj.ac/problem/6122)**

## **【题目描述】**

给出一张有向图，每个点（除了起点 $1$）每条边都只能经过一次，求出从 $1$ 到 $n$ 在回到 $1$ 的一条路径，使得经过的点个数最大，并输出路径。


**【数据范围】**

$100\%$ $n \leqslant 100$

-------

## **【分析】**

这是一道网络瘤题目。

那么，如何建模呢？

### **【建模】**

俗话说得好啊：**网络瘤，网络瘤，网络建模最毒瘤。**
稍微一不注意踩到了坑就 $GG$ 。

把题意转换一下，实际上是求从 $1$ 到 $n$ 的两条互不相交的路径。
限制条件是除起点、终点外的每条边、每个点只能经过一次，那么就可以进行**拆点**，把**点可以经过的最大次数**作为**点内部的流量**，**节点数**作为点**内部的费用**，最后用 $MCMF$ 求一个最大流最大花费。

求出的**最大流**就是**所找到的路径数**，如果它小于等于 $1$，就说明找不到这样一条路径。
但有一种特殊情况需要特判：起点、终点只有一条边相连，这时候虽然只能找到一条路径，可 $1$ 能直通 $n$ 并直接回来，是合法的路径。

然后就是 **美** $(sang)$ **妙** $(xin)$ **绝** $(bing)$ **伦** $(kuang)$ 的建图了：

首先把每个点拆为**入点**和**出点**，并连一条**流量**（**可经过次数**）为 $1$，费用（**节点数**）为 $1$ 的边，起点、终点要单独拆，**流量**设为 $2$ 。

而对于输入的边 $(x,y)$，要把 $x$ 的**出点**与 $y$ 的**入点**相连（其实是个很简单的道理，一开始死活想不明白，而大佬们的题解基本都没讲，可能是觉得太简单了吧，我太蒻了。。。）。

### **【求答案】**

答案分三种情况：

$(1).$ 当**最大流**等于 $2$ 时，**最大花费**减 $2$ 即为可经过的最大节点数，减 $2$ 是因为起点、终点都经过了两次。

$(2).$ 当处于上述 $1$ 直通 $n$ 的情况时，答案为 $2$，路径为：起点→终点→起点。

$(3).$ 其他情况均为无解。

另外，情况 $(1)$ 中输出路径时写两个 $dfs$ 遍历**满流边**：

第一次随便跑，记录下跑过的节点编号，要注意的是这时候只能跑出一条路，所以找到路后要立马 $break$。 

第二次跳过这些节点找剩下那条路径，由于**最大流**（**所找到的路径数**）最多为 $2$，所以这里是否 $break$ 都无所谓（可能会快一丢丢吧）。

## **【Code】**

```cpp
#include<algorithm>
#include<iostream>
#include<string>
#include<cstdio>
#include<queue>
#include<map>
#define LL long long
#define Re register int
using namespace std;
const int N=103,M=40000,inf=2e9;
int x,y,o=1,n,m,h,t,st,ed,flag,cyf[N],pan[N],pre[N],dis[N],head[N];LL maxcost,maxflow;
struct QAQ{int w,to,next,flow;}a[M<<1];queue<int>Q;string CH,ch[N];map<string,int>ip;
inline void add(Re x,Re y,Re z,Re w){a[++o].flow=z,a[o].w=w,a[o].to=y,a[o].next=head[x],head[x]=o;}
inline void add_(Re a,Re b,Re flow,Re w){add(a,b,flow,w),add(b,a,0,-w);}
inline int SPFA(Re st,Re ed){
    for(Re i=0;i<=ed;++i)dis[i]=-inf,pan[i]=0;
    Q.push(st),pan[st]=1,dis[st]=0,cyf[st]=inf;
    while(!Q.empty()){
    	Re x=Q.front();Q.pop();pan[x]=0;
    	for(Re i=head[x],to;i;i=a[i].next)
            if(a[i].flow&&dis[to=a[i].to]<dis[x]+a[i].w){//最长路 
            	dis[to]=dis[x]+a[i].w,pre[to]=i;
            	cyf[to]=min(cyf[x],a[i].flow);//最小残余网络 
            	if(!pan[to])pan[to]=1,Q.push(to);
            }
    }
    return dis[ed]!=-inf;
}
inline void EK(Re st,Re ed){
    while(SPFA(st,ed)){
    	Re x=ed;maxflow+=cyf[ed],maxcost+=(LL)cyf[ed]*dis[ed];
    	while(x!=st){
            Re i=pre[x];
            a[i].flow-=cyf[ed];
            a[i^1].flow+=cyf[ed];
            x=a[i^1].to;
    	}
    }
}
inline void dfs1(Re x){
    pan[x]=1;//记录一下第一次选的点，第二次就不选它们了
    cout<<ch[x-n]<<endl;//第一次正序输出。记得减n
    for(Re i=head[x],to;i;i=a[i].next)
    	if((to=a[i].to)<=n&&!a[i].flow){dfs1(to+n);break;}//出点x>n到入点to<=n,再从to的出点搜下去
}
inline void dfs2(Re x){
    for(Re i=head[x],to;i;i=a[i].next)
    	if((to=a[i].to)<=n&&!a[i].flow&&!pan[to+n])dfs2(to+n);//出点x>n到入点to<=n,再从to的出点搜下去 
    cout<<ch[x-n]<<endl;//第二次倒序输出。记得减n 
}
int main(){
    cin>>n>>m;st=1,ed=n<<1;
    for(Re i=1;i<=n;++i)cin>>ch[i],ip[ch[i]]=i;
    for(Re i=2;i<n;++i)add_(i,n+i,1,1);//1~n表示入点，n+1~2n表示出点 
    add_(1,1+n,2,1),add_(n,n+n,2,1);//起点和中点可以经过两次 
    while(m--){
    	cin>>CH;x=ip[CH];
    	cin>>CH;y=ip[CH];
    	if(x>y)swap(x,y);
    	flag|=x==1&&y==n; 
    	add_(x+n,y,1,0);//刚从x的出点出来，接下来连到y的入点 
    }
    EK(st,ed);
    if(maxflow==2)printf("%d\n",maxcost-2);//找到了两条路 
    else if(maxflow==1&&flag){//只有一条从1直通n的边 
    	printf("2\n");
    	cout<<ch[1]<<endl<<ch[n]<<endl<<ch[1]<<endl;//这里要输出三个 
    	return 0;
    }
    else return !printf("No Solution!\n");
    for(Re i=1;i<=n+2;++i)pan[i+n]=0;
    dfs1(1+n),dfs2(1+n);//根据边的残余网络来判断是否选了该边，所以从出点开始搜，这里害我调了一个多小时
}
```



---

## 作者：zubizakeli (赞：9)

看网上的题解都是用网络流写的。难道就我一个人想到dp吗 qwq (逃

　**题解：**
　　
  	
    	首先，我们可以把题意转化成从最左边的点走两条不相交的路线到达最右边的点，且使经过的点最多。标程是最大费用最大流。

		为了限流，我们把每个点i拆成两个点xi,yi，x1->y1、xn->yn连一条容量为2，费用为1的边，其他点xi->yi连一条容量为1，费用为1的边。若有i->j可达（i<j），则连yi->xj。最后求x1->yn的最大费用最大流即可。若最大流等于2，则有解，为最大费用-2（因为起点和终点重复计算了）；否则无解。

——————————手动分割———————————
 
		然而，其实这题还有另一种解法！！！

		我们设dpi,j表示两条路线分别走到了i点和j点。且只往>max（i,j）的点转移。

		有同学可能会问：那如果i<j-1,而且（i+1,j）这个状态要由（i,j）转移过来怎么办呢？

		其实完全不用担心这个问题，因为（i+1,j）这个状态可以由(i+1,j-x）的状态转移过来。

		我们可以这么想，假设我们已经知道了最终答案要经过哪些点，甲和乙现在同时站在起点，对于下一个要经过的点，若在甲的路线上，就让甲走到该点，在乙的路线上就让乙走到该点。所以只往最右边的点的右边走也是可以走出最优解的。
        
 ```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<map>
#define LL long long
#define RI register int
using namespace std;
const int INF = 0x7ffffff ;
const int N = 100 + 10 ;

inline int read() {
	int k = 0 , f = 1 ; char c = getchar() ;
	for( ; !isdigit(c) ; c = getchar())
	  if(c == '-') f = -1 ;
	for( ; isdigit(c) ; c = getchar())
	  k = k*10 + c-'0' ;
	return k*f ;
}
int n, m ; bool road[N][N] ; int dp[N][N], pre[N][N], typ[N][N], hh[N], gg[N] ; 
map<int,string>p ;
map<string,int>pp ;

int dfs(int x,int y) {  // 找最优解 
	if(dp[x][y]) return dp[x][y] ;
	if(x+y == 1) return 0 ; 
	int mm = min(x,y) ;
	for(int i=0;i<mm;i++) {
		if(road[i][x]) {
			dp[y][x] = dp[x][y] = max(dp[x][y],dfs(i,y)+1) ;
		}		
		if(road[i][y]) {
			dp[y][x] = dp[x][y] = max(dp[x][y],dfs(i,x)+1) ;
		}	
	}
	if(!dp[x][y]) return -INF ;  // 返回负无穷很关键，不然若从（1，x）[x>1]出发走的点更多的话最后统计的答案就会出错 
	return dp[x][y] ;
}
int tot = 0 ;
void dfss(int x,int y) {  // 寻找方案 
	hh[++tot] = x, gg[tot] = y ;
	if(x+y == 1) return ;
	int mm = min(x,y) ;
	for(int i=0;i<mm;i++) {
		if(dp[i][y] == dp[x][y]-1 && road[i][x]) {  // 不能只判断dp值，只有i,x两个点联通才能从（i,y)转移 
			dfss(i,y) ; return ;
		}
		if(dp[x][i] == dp[x][y]-1 && road[i][y]) {
			dfss(x,i) ; return ;
		}
	}
}


int main() {
	n = read(), m = read() ; string s ;
	for(int i=1;i<=n;i++) {
		cin>>s ; p[i] = s ; pp[s] = i ;
	}
	for(int i=1;i<=m;i++) {
		string s1, s2 ; cin>>s1>>s2 ;
		int x = pp[s1], y = pp[s2] ;
		road[x][y] = road[y][x] = 1 ;
		if(x == 1) road[0][y] = road[y][0] = 1 ;
		else if(y == 1) road[0][x] = road[x][0] = 1 ;
	}
	dfs(n,n) ;
	if(!dp[n][n]) { printf("No Solution!") ; return 0 ; }
	printf("%d\n",dp[n][n]) ;
	for(int i=1;i<n;i++) if(dp[i][n] == dp[n][n]-1) { dfss(i,n) ; break ; }
	sort(hh+1,hh+tot+1) ; sort(gg+1,gg+tot+1) ;
	int sz1 = unique(hh+1,hh+tot+1) - (hh+1) ;
	int sz2 = unique(gg+1,gg+tot+1) - (gg+1) ;
	cout<<p[1]<<"\n" ;
	for(int i=1;i<=sz1;i++) if(hh[i] > 1) cout<<p[hh[i]]<<"\n" ;
	for(int i=sz2;i;i--) if(gg[i] > 1) cout<<p[gg[i]]<<"\n" ; cout<<p[1]<<"\n" ;
	return 0 ;
}
```

（~~我才不会说我是因为想不出怎么建模才写的dp qwq~~）

---

## 作者：StudyingFather (赞：7)

我们的任务是在图上找两条只在起点和终点相交的路径。

将点 $x$ 拆分成 $x_1,x_2$。对于除了起点和终点之外的其他点，连 $x_1 \to x_2$，流量为 $1$（只允许经过一次），费用为 $0$ 的边。而对于起点和终点，连 $x_1 \to x_2$，流量为 $2$（要经过两次），费用为 $0$ 的边。

对于 $u \to v$ 这样一条路径，连一条 $u_2 \to v_1$，流量为 $1$，费用为 $1$ 的边。

跑最大费用最大流即可。如果最大流等于 $2$ 则有解。费用即为经过的城市数。

特别地，当最大流等于 $1$ 时，可能存在一条 $s \to t \to s$ 的路径，需要特判这种情况。

输出方案的话，直接在残量网络上 DFS 两次寻找路径即可。注意第二次 DFS 的时候需要倒序输出。

```cpp
#include <cstring>
#include <iostream>
#include <string>
#include <map>
#include <queue>
#define INF 0x3f3f3f3f
using namespace std;
map<string,int> m1;
map<int,string> m2;
struct edge
{
 int v,w,c,next;
}e[80005];
struct node
{
 int v,e;
}p[205];
int head[205],dis[205],vis[205];
int n,m,s,t,cnt=1,maxw,minf;
void addedge(int u,int v,int w,int c)
{
 e[++cnt].v=v;
 e[cnt].w=w;
 e[cnt].c=c;
 e[cnt].next=head[u];
 head[u]=cnt;
}
bool spfa()
{
 queue<int> q;
 memset(dis,INF,sizeof(dis));
 dis[s]=0,vis[s]=1;
 q.push(s);
 while(!q.empty())
 {
  int u=q.front();
  q.pop();
  vis[u]=0;
  for(int i=head[u];i;i=e[i].next)
   if(e[i].w&&dis[u]-e[i].c<dis[e[i].v])
   {
    dis[e[i].v]=dis[u]-e[i].c;
    p[e[i].v].v=u;
    p[e[i].v].e=i;
    if(!vis[e[i].v])
    {
     vis[e[i].v]=1;
     q.push(e[i].v);
    }
   }
 }
 return dis[t]!=INF;
}
void dfs1(int u)
{
 vis[u]=1;
 cout<<m2[u-n]<<endl;
 for(int i=head[u];i;i=e[i].next)
  if(e[i].v<=n&&!e[i].w)
  {
   dfs1(e[i].v+n);
   break;
  }
}
void dfs2(int u)
{
 for(int i=head[u];i;i=e[i].next)
  if(e[i].v<=n&&!vis[e[i].v+n]&&!e[i].w)
   dfs2(e[i].v+n);
 cout<<m2[u-n]<<endl;
}
int main()
{
 bool flag=false;
 cin>>n>>m;
 s=1,t=2*n;
 for(int i=1;i<=n;i++)
 {
  string str;
  cin>>str;
  m1[str]=i;
  m2[i]=str;
  if(i==1||i==n)
  {
   addedge(i,i+n,2,0);
   addedge(i+n,i,0,0);
  }
  else
  {
   addedge(i,i+n,1,0);
   addedge(i+n,i,0,0);
  }
 }
 for(int i=1;i<=m;i++)
 {
  string s,t;
  cin>>s>>t;
  int u=m1[s],v=m1[t];
  if(u==1&&v==n)flag=true;
  addedge(u+n,v,1,1);
  addedge(v,u+n,0,-1);
 }
 while(spfa())
 {
  int minw=INF;
  for(int i=t;i!=s;i=p[i].v)
   minw=min(minw,e[p[i].e].w);
  for(int i=t;i!=s;i=p[i].v)
  {
   e[p[i].e].w-=minw;
   e[p[i].e^1].w+=minw;
  }
  maxw+=minw;
  minf+=minw*dis[t];
 }
 if(maxw!=2&&!flag)cout<<"No Solution!"<<endl;
 else if(maxw!=2&&flag)
 {
  cout<<2<<endl;
  cout<<m2[1]<<endl<<m2[n]<<endl<<m2[1]<<endl;
 }
 else
 {
  cout<<-minf<<endl;
  dfs1(n+1);
  dfs2(n+1);
 }
 return 0;
}
```


---

## 作者：guodong (赞：5)

## 航空路线问题

tag：每个点只能经过一次

解决方案：拆点

逆向思维一下：从西到东的一条路径==从东到西的一条路径

那么题目就转化成了：找出从东向西两条不相交的路径。

$Q$:点最多？

$A$:那就费用流呀。

$Q$:只能两条路径？

$A$:那就拆起点$S->S'$,边权为2，费用为0。

> 连边指南：

> add(x,x',1);

> add(x',y,1);

> add(S,S',2);

$Q$:输出方案？

$A$:$dfs$两次。

$Q$:城市名称怎么处理？

$A$:```map```一下

$Q$:代码？

$A$:没有！

$Q$:那你锅了怎么办？

$A$:私信!$uid:81372$

---

## 作者：totorato (赞：4)

# 最大费用最大流

题意即是求1~n的两条不相交路径，使得路径经过的点总数最多。

由于航线不能重叠，所以每个点只能经过一次(最后一个点和第一个点最多两次)。

所以我们可以对满足这个要求的图求一次最大流，得到的肯定是流量小于等于2的流。

这样，根据满流的边，我们就可以知道到底这个流对应的经过了哪几个点。

又因为要求点数最多，我们求最大费用最大流即可。

(代码较为冗长可能没有什么参考价值)

```cpp
#include <iostream>
#include <cstring>
#include <cstdio>
#include <map>

#define MX 80001
#define oo 12312312
#define S 1
#define T (n<<1)

using namespace std;

typedef struct edge_t
{
	int u,v,c,w;
}edge;
edge e[MX];
int fst[MX],nxt[MX],lnum;
int n,m,check;
map<string,int>mp;
string name[1001];

void addeg(int nu,int nv,int nc,int nw)
{
	nxt[++lnum]=fst[nu];
	fst[nu]=lnum;
	e[lnum]=(edge){nu,nv,nc,nw};
}

void input()
{
	string str1,str2;
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
	{
		cin>>str1;
		mp[str1]=i;
		name[i]=str1;
		addeg(i,n+i,1,1);
		addeg(n+i,i,0,-1);
	}
	for(int i=1;i<=m;i++)
	{
		cin>>str1>>str2;
		int a=mp[str1],b=mp[str2];
		if(a>b)swap(a,b);
		if(a==1&&b==n)check=1;
		addeg(a+n,b,1,1),addeg(b,a+n,0,-1);
	}
	addeg(1,n+1,1,1),addeg(n+1,1,0,-1);
	addeg(n,n*2,1,1),addeg(n*2,n,0,-1);
}

void init()
{
	memset(fst,0xff,sizeof(fst));
	lnum=-1;
}

int q[MX],pre[MX],dis[MX],inq[MX];
int spfa(int *flow,int *cost)
{
	int h=0,t=1,x,y;
	memset(dis,0x9f,sizeof(dis));
	memset(inq,0,sizeof(inq));
	memset(pre,0,sizeof(pre));
	q[++h]=S;
	dis[S]=0;
	pre[S]--;
	inq[S]=1;
	while(h>=t)
	{
		x=q[(t++)%MX];
		inq[x]=0;
		for(int i=fst[x];i!=-1;i=nxt[i])
		{
			y=e[i].v;
			if(e[i].c&&dis[y]<dis[x]+e[i].w)
			{
				dis[y]=dis[x]+e[i].w;
				pre[y]=i;
				if(!inq[y])
				{
					q[(++h)%MX]=y;
					inq[y]=1;
				}
			}
		}
	}
	if(dis[T]<0)return 0;
	int now=pre[T],mxf=+oo,cst=0;
	while(now!=-1)
	{
		mxf=min(mxf,e[now].c);
		cst+=e[now].w;
		now=pre[e[now].u];
	}
	now=pre[T];
	while(now!=-1)
	{
		e[now].c-=mxf;
		e[now^1].c+=mxf;
		now=pre[e[now].u];
	}
	*flow+=mxf;
	*cost+=cst*mxf;
	return 1;
}

int ans[1001];int anum=0;
void out(int x)
{
	ans[++anum]=x;
	for(int i=fst[x];i!=-1;i=nxt[i])
		if(e[i].c==0&&e[i].w>=0)
		{
			out(e[i].v);
			e[i].c=1;
			return;
		}
}

int main()
{
	int cost=0,flow=0;
	init();
	input();
	while(spfa(&flow,&cost));
	if(flow==0||(flow==1&&!check)){printf("No Solution!\n");return 0;}
	else if(flow==1&&(flow==1&&check)){cout<<2<<endl<<name[1]<<endl<<name[n]<<endl<<name[1]<<endl;return 0;}
	else
	{
		printf("%d\n",cost/2-1);
		out(S);
		for(int i=1;i<=anum;i++)if(ans[i]<=n)cout<<name[ans[i]]<<endl;
		anum=0;
		out(S);
		for(int i=anum-2;i>=1;i--)if(ans[i]<=n)cout<<name[ans[i]]<<endl;
	}
	return 0;
}
```

---

## 作者：poorpool (赞：3)

**upd：代码已经更改，应该没有错了吧……我好菜啊**

**前置技能**：HDU3376 Matrix Again

所以看到这个题，我们也会想着用最大费用最大流解决，因为从起点飞到终点再飞回来，就等于从起点飞两次到终点且这两次飞行除了起点终点之外没有访问超过一次的点。


考虑拆点限流，除起点终点以外的点容量是1（花费代表边权），起点终点容量是2。


输出方案的话，我是dfs两遍找出两条起点到终点的路径，然后分别正着倒着输出。

```cpp
#include <iostream>
#include <cstring>
#include <cstdio>
#include <string>
#include <queue>
#include <map>
using namespace std;
int n, m, hea[205], cnt, uu, vv, minCost, ss, tt, dis[205], pre[205], maxFlow;
int opt[2][105], tot[2];
const int oo=0x3f3f3f3f;
bool vis[205];
queue<int> d;
string qaq, qwq, ovo[105];
map<string,int> a;
struct Edge{
	int too, nxt, val, cst;
}edge[40005];
void add_edge(int fro, int too, int val, int cst){
	edge[cnt].nxt = hea[fro];
	edge[cnt].too = too;
	edge[cnt].val = val;
	edge[cnt].cst = cst;
	hea[fro] = cnt++;
}
void addEdge(int fro, int too, int val, int cst){
	add_edge(fro, too, val, cst);
	add_edge(too, fro, 0, -cst);
}
bool spfa(){
	memset(dis, 0x3f, sizeof(dis));
	memset(pre, -1, sizeof(pre));
	d.push(ss);
	vis[ss] = true;
	dis[ss] = 0;
	while(!d.empty()){
		int x=d.front();
		d.pop();
		vis[x] = false;
		for(int i=hea[x]; i!=-1; i=edge[i].nxt){
			int t=edge[i].too;
			if(dis[t]>dis[x]+edge[i].cst && edge[i].val>0){
				dis[t] = dis[x] + edge[i].cst;
				pre[t] = i;
				if(!vis[t]){
					vis[t] = true;
					d.push(t);
				}
			}
		}
	}
	return dis[tt]!=oo;
}
void mcmf(){
	while(spfa()){ 
		int tmp=oo;
		for(int i=pre[tt]; i!=-1; i=pre[edge[i^1].too])
			tmp = min(tmp, edge[i].val);
		for(int i=pre[tt]; i!=-1; i=pre[edge[i^1].too]){
			edge[i].val -= tmp;
			edge[i^1].val += tmp;
			minCost += tmp * edge[i].cst;
		}
		maxFlow += tmp;
	}
}
void dfs(int x, int o){
	opt[o][++tot[o]] = x;
	for(int i=hea[x]; i!=-1; i=edge[i].nxt){
		int t=edge[i].too;
		if(i&1)	continue;
		if(edge[i^1].val){
			edge[i^1].val--;
			dfs(t, o);
			return ;
		}
	}
}
int main(){
	memset(hea, -1, sizeof(hea));
	cin>>n>>m;
	for(int i=1; i<=n; i++){
		cin>>qaq;
		ovo[i] = qaq;
		a[qaq] = i;
	}
	ss = 0; tt = 2 * n + 1;
	addEdge(ss, 1, 2, 0);
	addEdge(2*n, tt, 2, 0);
	addEdge(1, 1+n, 1, -1);
	addEdge(n, n+n, 1, -1);
	for(int i=1; i<=m; i++){
		cin>>qaq>>qwq;
		uu = a[qaq]; vv = a[qwq];
		if(uu>vv)	swap(uu, vv);
		addEdge(uu+n, vv, oo, 0);
	}
	for(int i=1; i<=n; i++)
		addEdge(i, i+n, 1, -1);
	mcmf();
	if(maxFlow==0){
		cout<<"No Solution!"<<endl;
		return 0;
	}
	cout<<(-minCost-2)<<endl;
	dfs(1, 0);
	dfs(1, 1);
	for(int i=1; i<=tot[0]; i++)
		if(opt[0][i]>=1 && opt[0][i]<=n)
			cout<<ovo[opt[0][i]]<<endl;
	bool flag=false;
	for(int i=tot[1]; i>=1; i--)
		if(opt[1][i]>=1 && opt[1][i]<=n){
			if(!flag){
				flag = true;
				continue;
			}
			cout<<ovo[opt[1][i]]<<endl;
		}
	return 0;
}
```

---

## 作者：bztMinamoto (赞：0)

打广告：[blog](https://www.cnblogs.com/bztMinamoto/p/9508234.html)

感觉楼下大佬们说的好简洁……

完了这题好厉害……字符串什么的好麻烦……

要求从$1$到$n$的路径，不重复，经过边数最多

每一个点拆成两个，$A_i,B_i$，然后$A_i$到$B_i$连容量为$1$，费用为$1$的边，保证每个点只被选一次

然后$1$和$n$的话要容量为$2$

然后有连边的话，$B_i$向$A_j$连边，容量$1$，费用$1$

要选的点最多，那么就是要费用最大，所以跑一个最大费用流

然后找方案的话，直接dfs，然后正着和倒着输出

有几个细节，写在代码里了
```
//minamoto
#include<iostream>
#include<cstdio>
#include<cstring>
#include<queue>
#include<map>
#define inf 0x3f3f3f3f
using namespace std;
const int N=5005,M=500005;
int ver[M],Next[M],head[N],edge[M],flow[M],tot=1;
int dis[N],disf[N],Pre[N],last[N],vis[N],maxflow,maxcost;
int n,m,s,t;bool check=0;
queue<int> q;
map<string,int> mp;
string name[N];
inline void add(int u,int v,int f,int e){
	ver[++tot]=v,Next[tot]=head[u],head[u]=tot,flow[tot]=f,edge[tot]=e;
	ver[++tot]=u,Next[tot]=head[v],head[v]=tot,flow[tot]=0,edge[tot]=-e;
}
bool spfa(){
	memset(dis,0xef,sizeof(dis));
	q.push(s),dis[s]=0,disf[s]=inf,Pre[t]=-1;
	while(!q.empty()){
		int u=q.front();q.pop();vis[u]=0;
		for(int i=head[u];i;i=Next[i]){
			int v=ver[i];
			if(flow[i]&&dis[v]<dis[u]+edge[i]){
				dis[v]=dis[u]+edge[i],last[v]=i,Pre[v]=u;
				disf[v]=min(disf[u],flow[i]);
				if(!vis[v]) vis[v]=1,q.push(v);
			}
		}
	}
	return ~Pre[t];
}
void dinic(){
	while(spfa()){
		int u=t;maxflow+=disf[t],maxcost+=disf[t]*dis[t];
		while(u!=s){
			flow[last[u]]-=disf[t];
			flow[last[u]^1]+=disf[t];
			u=Pre[u];
		}
	}
}
int ans[1005];int num=0;
void out(int u){
	ans[++num]=u;
	for(int i=head[u];i;i=Next[i]){
		if(flow[i]==0&&edge[i]>=0){
			out(ver[i]);
			flow[i]=1;
			return;
		}
	}
}
int main(){
	//freopen("testdata.in","r",stdin);
	string s1,s2;
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;++i){
		cin>>s1;
		mp[s1]=i;
		name[i]=s1;
		add(i,i+n,1,1);
	}
	for(int i=1;i<=m;++i){
		cin>>s1>>s2;
		int a=mp[s1],b=mp[s2];
		if(a>b) swap(a,b);
		if(a==1&&b==n) check=1;
		add(a+n,b,1,1);
	}
	add(1,n+1,1,1),add(n,n+n,1,1);
	s=1,t=n+n;
	dinic();
	if(!maxflow||(maxflow==1&&!check)) return puts("No Solution!"),0;
	if(maxflow==1&&check){cout<<2<<'\n'<<name[1]<<'\n'<<name[n]<<'\n'<<name[1]<<'\n';return 0;}
	printf("%d\n",maxcost/2-1);
	//这里的最多城市数是这个
	//因为考虑如果边连成一个环，边数等于点数
	//然后每个点拆成两个，除以二
	//然后因为s'和t'被重复了两次，减去1 
	out(s);
	for(int i=1;i<=num;++i) if(ans[i]<=n) cout<<name[ans[i]]<<'\n';
	num=0;
	out(s);
	for(int i=num-2;i;--i) if(ans[i]<=n) cout<<name[ans[i]]<<'\n';
	//最后两个肯定是t和t'，不用管 
	return 0;
}
```

---


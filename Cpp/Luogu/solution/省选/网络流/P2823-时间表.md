# 时间表

## 题目背景

小 A 是一个电话服务中心的主管，他的团队有一大批人。他们团队中的每个人都会花费他们的时间参加会议和通过电话与客户通话，当然还有研究团队的项目也是要花费他们的时间的。


## 题目描述

他们中的每个人在每个小时只能在参加会议、和客户通话、研究项目三者中选择一个来进行。为了提高效率，每个小时必须完整地奉献到这一项工作中，不能中途改变。

小 A 所在的地方很奇怪，他们一个星期有 $D$ 天，从 $1$ 到 $D$ 标号。为了照顾员工的嗓子，第 $i$ 个人在每个星期最多能够与客户通话 $L_i$ 小时。

开会是已经计划好的事情，对于每个人他们需要在什么时间参加会议是确定的。这个电话服务中心每天要有 $H$ 个小时的时间是可以回复客户的电话的，为了简便，这 $H$ 个小时被从 $1$ 到 $H$ 标号。

对于每周的每个小时，有多少客户会连接到电话服务中心是已知的。因此，小 A 知道他在第 $i$ 天的第 $j$ 个小时必须安排 $R_{i,j}$ 个员工来和客户通话。如果第 $k$ 个人在第 $i$ 天的第 $j$ 个小时没有会议可以和客户通话，那么 $F_{k,i,j}$ 的值为 $1$，如果有会议则为 $0$。

再次说明，小  A的世界十分奇怪，他们除了每周可能不是 $7$ 天以外，每天也可能不是 $24$ 个小时。

小 A 需要为每个员工创建一个时间表。由于员工也需要吃饭和休息，每天都会有一个午休时间，这段时间是从 $L_{\text{T}_\text{begin}}$ 开始到 $L_{\text{T}_\text{end}}$ 结束（$L_{\text{T}_\text{begin}}$ 和 $L_{\text{T}_\text{end}}$ 也包含在内）。小 A 需要确保每个员工在这段时间内至少有一个小时是没有参加会议或与客户通话的，以便他们可以吃饭和休息，或者做自己想做的事情。

如果某个人在某个小时内没有会议也没有和客户通话，那他在这个小时就可以去研究公司项目，研究公司项目也算在工作时间之内。另外，他们有可能会去研究自己的项目，然而这是不算在工作时间内的。

小 A 想要知道，他是否有可能安排出这样一个时间表，并且满足：

- 每个人每天最多花费 $N$ 个小时在参加会议和客户通话上；
- 每个人每周最多花费 $L_i$ 个小时和客户通话；
- 每个人在午休时间至少有一个小时没有参加会议或和客户通话；
- 对于第 $i$ 天第 $j$ 个小时，恰好有 $R_{i,j}$ 个人可以与客户通话。


## 说明/提示

对于 $100\%$ 的数据满足有

$1 \leq T \leq 5,1 \leq N \leq H \leq 70$

$1 \leq D, P\leq 70,1 \leq L_i \leq N\times D, 0 \leq R_{i, j} \leq 15$

$0 \leq F_{k, i, j} \leq 1,1 \leq L_{\text{T}_\text{begin}} \leq L_{\text{T}_\text{end}} \leq N$。


## 样例 #1

### 输入

```
2
2 2 3 2
4 1
2 3
0 1 1
0 1 0
1 1 1
1 1 1
1 1 1
1 0 1
2 2 3 2
4 1
2 3
0 1 2
0 1 0
1 1 1
1 1 1
1 1 1
1 0 1```

### 输出

```
Yes
No```

# 题解

## 作者：未来姚班zyl (赞：3)

#### 前言：这是一道纯网络~~瘤~~流
## 题目大意
题目十分长，但有许多废话，看了老久才大概知道意思。去掉没用的信息，这题的大意如下（替换掉了一些原题中的字母，方便理解以及阅读俺的代码）：

有一个公司，共 $n$ 人。这些要工作 $day$ 天，每天长 $hour$ 小时。

工作分为两类：打电话，开会。

现在有如下的两大类限制：

- 对员工的限制
		
	1. 一位员工在同一小时内只能做一份工作，或者~~摸鱼~~休息。
	
	2. 总共只能打 $L_{i}$ 小时电话。

	3. 每个人每天最多工作 $N$ 小时。
    
	4. 在某些小时，某个人必须参加会议。
    
	5. 在午休时间 $[l,r]$ 中，必须休息一个小时。
- 对工作的限制：第 $i$ 天的第 $j$ 小时，必须有 $need_{i,j}$ 个人选择打电话。
    
然后就会发现，原题中有不少信息与这题毫无关系。（有研究项目肯定研究自己的，所以将其视为休息）。
## 题目分析
把题意概括出来后，题目就很~~繁琐~~简单了。只需对每个限制依次处理了。

#### 小技巧：如果碰到限制条件多的网络流题目，在纸上按限制条件左右分层（方便连边），按元素上下分层（方便建点），画出草图。

像这题，可以按照下图分层：

![](https://cdn.luogu.com.cn/upload/image_hosting/jkqlhw66.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

其中，$lim\ A_{i}$ 对应了对员工的限制，$lim\ B$ 对应对工作的限制，红线代表按人分，绿线代表按边分，紫线代表按小时分。

至于没有写出的两条限制，$lim\ A_1$ 是本题的运作原理，$lim\ A_4$ 将贯穿加边的过程。

至于为什么要这样分，往下看。

现在，根据上面的草图，从左往右一层一层开始建图开始建图。首先要知道，由于工作只对打电话给出限制，所以会议能不去就不去，建图以打电话的工作为中心，这同时也是 $lim\ A_4$ 不列出来分层的原因。
- 第一层，新建 $n$ 个点，编号 $1\sim n$，代表了员工 $i$，由原点向点 $i$ 连流量为 $L_i$ 的边。
- 第二层，新建 $n\times day$ 个点，编号 $(n+1)\sim (n+n\times day)$，我们暂时用 $Id_{i,j}$ 表示这一层中，第 $i$ 个人在第 $j$ 天的打电话工作（类似的表示将在后面讲述如何设计具体数值）。由于 $lim\ A_4$ 的存在，我们用 $N$ 减去这一天的会议总数，就能得到这一天最多能打多少小时电话，设其为 $x$，则点 $i$ 向点 $Id_{i,j}$ 连流量为 $x$ 的边。
- 第三层，新建 $2\times n\times day$ 个点，编号 $(n+n\times day+1)\sim(n+3\times n\times day)$，设 $Idrest_{i,j}$ 表示第 $i$ 个人在第 $j$ 天的午休段的打电话工作，$Idwork_{i,j}$ 表示非午休段的打电话工作。前者只需用午休段的总时间减去期间会议的数量再减去休息的一个小时，设为 $x$，后者只需用总时间减去午休段的时间减去除午休外的会议的数量，设为 $y$。则点 $Id_{i,j}$ 向 $Idrest_{i,j}$ 连流量为 $x$ 的边，向 $Idwork_{i,j}$ 连流量为 $y$ 的边。
- 第四层，新建 $day\times hour$ 个点，编号 $(n+3\times n\times day+1)\sim(n+3\times n\times day+day\times hour)$，设 $Idcall_{i,j}$ 为第 $i$ 天第 $j$ 小时的打电话工作，则将其向汇点连流量为 $need_{i,j}$ 的边。对于午休时间段，如果第 $k$ 个人没有会议，则点 $Idrest_{k,i}$ 向 $Idcall_{i,j}$ 连流量为 $1$ 的边，对于非午休时间段，就由 $Idwork_{k,i}$ 连。

建图就到这里了，对于这么多编号，可以发现，我们建的点依次组成矩形，可以用点在当前矩形中的标号加上之前的点的总数，这样编号就不重复了，具体可以看代码。

对于判定有无解，如果出现了边权小于 $0$，则说明有人超过了工作量限制，肯定无解。否则，最大流等于 $\sum\limits_{1\le i\le day,1\le j\le hour}need_{i,j}$ 则有解，否则无解。

```cpp
#include<bits/stdc++.h>
#define ll long long
#define L x<<1
#define R x<<1|1
#define mid (l+r>>1)
#define rep(x,y,z) for(int x=(y);x<=(z);x++)
#define per(x,y,z) for(int x=(y);x>=(z);x--)
#define ull unsigned long long
#define ui unsigned int
inline int read(){int s=0,w=1;char c=getchar();while(c<48||c>57) {if(c=='-') w=-1;c=getchar();}while(c>=48&&c<=57) s=(s<<1)+(s<<3)+c-48,c=getchar();return s*w;}
inline void pf(ll x){if(x<0) putchar('-'),x=-x;if(x>9)pf(x/10);putchar(x%10+48);}
const int N =2.2e4+5,M=4e7+5,inf=2147000000;
using namespace std;
int n,m,s,t,sum,h[N],nxt[M],now[N],to[M],cnt=1,dep[N];ll w[M],ans;
inline void add(int a,int b,ll c){
	to[++cnt]=b,nxt[cnt]=h[a],h[a]=cnt,w[cnt]=c;
	to[++cnt]=a,nxt[cnt]=h[b],h[b]=cnt,w[cnt]=0;
}
inline bool bfs(){
	queue<int>q;
	memset(dep,-1,sizeof(dep));
	dep[s]=0,q.push(s),now[s]=h[s];
	while(!q.empty()){
		int x=q.front();q.pop();
		for(int i=h[x];i;i=nxt[i]){
			int y=to[i];
			if(w[i]==0||dep[y]!=-1)continue;
			dep[y]=dep[x]+1,q.push(y),now[y]=h[y];
			if(y==t)return 1;
		}
	}
	return 0;
}
inline int dfs(int x,ll lim){
	if(x==t)return lim; 
	ll k,tmp=0;
	for(int i=now[x];i&&lim;i=nxt[i]){
		now[x]=i;
		int y=to[i];
		if(!w[i]||dep[y]^(dep[x]+1))continue;
		k=dfs(y,min(lim,w[i]));
		if(k==0)dep[y]=-1;
		w[i]-=k,w[i^1]+=k,tmp+=k,lim-=k;
	}
	return tmp;
}
int T,lim_week[75],lim_day,day,hour,rest_s,rest_e,need_cal[75][75],need_sum;
inline void clear(){
	ans=need_sum=0,cnt=1,memset(h,0,sizeof(h)),memset(now,0,sizeof(now));
}
bool meeting[75][75][75];
inline int Id_wd(int i,int j){
	return n+(i-1)*day+j;
}
inline int Id_wd_restime(int i,int j){
	return n+n*day+(i-1)*day+j;
}
inline int Id_wd_worktime(int i,int j){
	return n+2*n*day+(i-1)*day+j;
}
inline int Id_cal_dh(int i,int j){
	return n+3*n*day+(i-1)*hour+j;
}
//这四个函数就是求编号的函数
int main(){
	T=read();
	while(T--){
		clear();
		n=read(),day=read(),hour=read(),lim_day=read();
		s=0,t=n+3*n*day+day*hour+1;
		rep(i,1,n)lim_week[i]=read();
		rest_s=read(),rest_e=read();
		rep(i,1,day)rep(j,1,hour)need_cal[i][j]=read(),need_sum+=need_cal[i][j];
		rep(i,1,n)rep(j,1,day)rep(k,1,hour)meeting[i][j][k]=read(),meeting[i][j][k]^=1;
		rep(i,1,n)add(s,i,lim_week[i]);
		rep(i,1,n)rep(j,1,day){
			int x=lim_day;
			rep(k,1,hour)x-=meeting[i][j][k];
			add(i,Id_wd(i,j),x);
		} 
		rep(i,1,n)rep(j,1,day){
			int sum=rest_e-rest_s;
			rep(k,rest_s,rest_e)sum-=meeting[i][j][k];
			add(Id_wd(i,j),Id_wd_restime(i,j),sum);
			sum=hour-(rest_e-rest_s+1);
			rep(k,1,rest_s-1)sum-=meeting[i][j][k];
			rep(k,rest_e+1,hour)sum-=meeting[i][j][k];
			add(Id_wd(i,j),Id_wd_worktime(i,j),sum);
		}
		rep(i,1,n)rep(j,1,day){
			rep(k,rest_s,rest_e)if(!meeting[i][j][k])add(Id_wd_restime(i,j),Id_cal_dh(j,k),1);
			rep(k,1,rest_s-1)if(!meeting[i][j][k])add(Id_wd_worktime(i,j),Id_cal_dh(j,k),1);
			rep(k,rest_e+1,hour)if(!meeting[i][j][k])add(Id_wd_worktime(i,j),Id_cal_dh(j,k),1);
		}
		rep(i,1,day)rep(j,1,hour)add(Id_cal_dh(i,j),t,need_cal[i][j]);
		bool f=1;
		for(int i=2;i<=cnt;i+=2)if(w[i]<0){
			f=0;break;
		}
		if(!f){
			printf("No\n");
			continue;
		}
		while(bfs())ans+=dfs(s,inf);
		printf("%s\n",ans==need_sum?"Yes":"No");
	}
	return 0;
}
```


---

## 作者：Macesuted (赞：3)

[前往我的个人博客以获得更佳阅读体验](https://www.macesuted.cn/article/lg2823/)

---

[题面](https://www.luogu.com.cn/problem/P2823)

# 题意

在一个神奇的公司，该公司有 $P$ 名员工，一个星期有 $D$ 天，每天有 $H$ 小时。

每名员工在每一个小时都在做一件事：工作，开会，或者休息。员工在一段时间内的工作时间为该员工在这段时间内进行“工作”事件和“开会”事件的小时数。每个员工每周进行“工作”事件的时间不能超过 $L_i$ 小时，每个员工每天总工作时间不可超过 $N$ 小时。

现在公司已经为每位用户确定好了“开会”事件发生的时间，用 $F_{k,i,j}$ 表示，$F_{k,i,j}=0$ 表示 $k$ 号员工在第 $i$ 天的第 $j$ 小时需要进行“开会”事件，$F_{k,i,j}=1$ 表示 $k$ 号员工在第 $i$ 天的第 $j$ 小时可以选择进行“工作”或者“休息”事件。

由于公司业务要求，每周的第 $i$ 天的第 $j$ 小时需要有正好 $R_{i,j}$ 人在进行“工作”事件。

该公司还有午休事件，为每一天的 $L_{T_{begin}} \sim L_{T_{end}}$ 小时段。每名员工在该时间段内都必须要有至少一个小时在进行“休息”事件。

现将所有的条件告诉你，需要你求出是否存在一种员工的时间分配方案（即为每个员工指定每天的每一小时在进行的事件类型）满足所有的限制条件。如果有这样的方案输出 `Yes`，否则输出 `No`。

# 分析

题面相当恶臭，各类限制条件的关系也挺复杂的，但思维难度并不高。~~因此该题考察的是语文水平。~~

由于题目中的限制都是在对时间区间内的工作时间进行限制，考虑网络流，将“工作”事件时间作为流量，按题意模拟建图即可。

先建立源点 $S$ 与汇点 $T$，接下来考虑每一个限制条件。

1. **每个员工每周最多进行“工作”事件 $L_i$ 小时**：建立 $P$ 个点 $A_i$，约束第 $i$ 个员工的每周工作时间。从 $S$ 向每个 $A_i$ 连一条流量为 $L_i$ 的边即可。
2. **每个员工每天最多工作 $N$ 小时**：建立 $D \times P$ 个点 $B_{i,j}$，约束第 $i$ 个员工在第 $j$ 天的工作时间。从 $A_i$ 向每个 $B_{i,j}$ 连一条流量为 $N-\sum_{k=1}^{H} [F_{i,j,k}=0]$ 的边即可。（因为第 $j$ 天已有一些时间必须要进行“开会”事件）
3. **每个员工午休时间需要有至少一个小时进行“休息”事件**：建立 $D \times P$ 个点 $C_{i,j}$，约束第 $i$ 个员工在第 $j$ 天的午休时间段内的工作时间。从每个 $B_{i,j}$ 向 $C_{i,j}$ 连一条流量为 $L_{T_{end}}-L_{T_{begin}}-\sum_{k=1}^{H} [F_{i,j,k}=0]$ 的边即可（该边流量为午休时间段内能进行的最长的“工作”事件的总时间 $-1$）。
4. 考虑工作分配的方案：建立 $D \times H$ 个点 $E_{i,j}$ 约束第 $i$ 天第 $j$ 小时总的进行“工作”事件的人数。从 $C_{i,j}$ 或 $D_{i,j}$（取决于是否在休息时间）向每个满足 $F_{i,j,k}=1$ 的 $k$ 对应的 $E_{j,k}$ 连一条流量为 $1$ 的边。
5. **第 $i$ 天的第 $j$ 小时需要有正好 $R_{i,j}$ 人进行“工作”事件**：从 $E_{i,j}$ 向 $T$ 连一条流量为 $R_{i,j}$ 的边即可。

最后跑最大流，如果最大流等于 $\sum_{i=1}^{D} \sum_{j=1}^{H} R_{i,j}$ **且中途没有建立过负权边**则说明存在合法方案。

（说中途没有建立过负权边是因为在第 $2$ 步和第 $3$ 步的建图过程中边权可能小于零，原因是强制指定的开会时间已经超过员工每日工作时长的限制，则显然不存在合法方案）

# 代码

```cpp
/**
 * @author Macesuted (macesuted@qq.com)
 * @copyright Copyright (c) 2021
 */

#include <bits/stdc++.h>
using namespace std;

namespace io {

// fread

}  // namespace io
using io::getch;
using io::getstr;
using io::putch;
using io::putstr;
using io::read;
using io::write;

template <size_t maxn>
class Dinic {

// Dinic

};

#define INF 0x3f3f3f3f3f3f3f3f
#define maxn 75

Dinic<20005> dinic;

int f[maxn][maxn], g[maxn][maxn];

int main() {
    int _ = read<int>();
    while (_--) {
        int P = read<int>(), D = read<int>(), H = read<int>(), N = read<int>();
        int S = P + 2 * P * D + D * H + 1, T = S + 1;
        dinic.INIT(T);
        for (register int i = 1; i <= P; i++) dinic.addEdge(S, i, read<int>());
        int tl = read<int>(), tr = read<int>();
        long long tot = 0;
        for (register int i = 1; i <= D; i++)
            for (register int j = 1, t; j <= H; j++)
                dinic.addEdge(P + 2 * P * D + (i - 1) * H + j, T, t = read<int>()), tot += t;
        for (register int k = 1; k <= P; k++)
            for (register int i = 1; i <= D; i++) {
                f[k][i] = g[k][i] = 0;
                for (register int j = 1; j <= H; j++)
                    if (read<int>()) {
                        if (tl <= j && j <= tr)
                            dinic.addEdge(P + P * D + (k - 1) * D + i, P + 2 * P * D + (i - 1) * H + j, 1), g[k][i]++;
                        else
                            dinic.addEdge(P + (k - 1) * D + i, P + 2 * P * D + (i - 1) * H + j, 1);
                    } else
                        f[k][i]++;
            }
        bool flag = false;
        for (register int i = 1; i <= P; i++)
            for (register int j = 1; j <= D; j++) {
                dinic.addEdge(i, P + (i - 1) * D + j, N - f[i][j]);
                if (N - f[i][j] < 0) flag = true;
            }
        for (register int i = 1; i <= P; i++)
            for (register int j = 1; j <= D; j++) {
                dinic.addEdge(P + (i - 1) * D + j, P + P * D + (i - 1) * D + j, g[i][j] - 1);
                if (g[i][j] - 1 < 0) flag = true;
            }
        putstr((!flag && dinic.maxFlow(S, T) == tot) ? "Yes" : "No"), putch('\n');
    }
    return 0;
}
```

---


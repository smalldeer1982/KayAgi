# [CQOI2009] 跳舞

## 题目描述

一次舞会有 $n$ 个男孩和 $n$ 个女孩。

每首曲子开始时，所有男孩和女孩恰好配成 $n$ 对跳交谊舞。每个男孩都不会和同一个女孩跳两首（或更多）舞曲。

有一些男孩女孩相互喜欢，而其他相互不喜欢（不会“单向喜欢”）。每个男孩最多只愿意和 $k$ 个不喜欢的女孩跳舞，而每个女孩也最多只愿意和 $k$ 个不喜欢的男孩跳舞。

给出每对男孩女孩是否相互喜欢的信息，舞会最多能有几首舞曲？

## 说明/提示

#### 数据规模与约定

- 对于 $100\%$ 的数据，保证 $1\leq n\leq 50$，$0\leq k\leq 30$。

## 样例 #1

### 输入

```
3 0
YYY
YYY
YYY```

### 输出

```
3```

# 题解

## 作者：yybyyb (赞：34)

如果这题换个问法：能不能跳a支舞曲

我们来看看

把每个人拆成喜欢和不喜欢两个点

从S向每个男生连容量为a的边，表示限制a支舞曲

再从男生连向喜欢和不喜欢的两个点，

但是这样子没法限制，因为只说了不能和超过K个不喜欢的人跳舞

所以可以直接从S连向男生喜欢，容量为a

再从男生喜欢连向男生不喜欢连边，容量为K

这样的话就解决了这个问题

接下来就很好办了

男生喜欢连向女生喜欢

男生不喜欢连向女生不喜欢

而女生之间的连边类似于男生

（你就想，如果这个图反过来是一样的，所以怎么连边就很清晰了）

这个时候跑最大流

求出来的就是最大的匹配数

如果最大流恰好等于a\*n

也就是恰好a\*n组匹配，意味着可行


现在再来看这个问题

既然要求最大的a

所以就二分一下

然后每次把图重构一下流量

二分就行了

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<set>
#include<map>
#include<vector>
#include<queue>
using namespace std;
#define MAX 300
#define MAXL 100000
#define INF 1000000000
inline int read()
{
    int x=0,t=1;char ch=getchar();
    while((ch<'0'||ch>'9')&&ch!='-')ch=getchar();
    if(ch=='-')t=-1,ch=getchar();
    while(ch<='9'&&ch>='0')x=x*10+ch-48,ch=getchar();
    return x*t;
}
struct Line
{
    int v,next,w;
}e[MAXL];
int h[MAX],cnt;
int ans,S,T,n,m,K;
inline void Add(int u,int v,int w)
{
    e[cnt]=(Line){v,h[u],w};
    h[u]=cnt++;
    e[cnt]=(Line){u,h[v],0};
    h[v]=cnt++;
}
int level[MAX];
int cur[MAX];
bool BFS()
{
    memset(level,0,sizeof(level));
    level[S]=1;
    queue<int> Q;
    Q.push(S);
    while(!Q.empty())
    {
        int u=Q.front();Q.pop();
        for(int i=h[u];i!=-1;i=e[i].next)
        {
            int v=e[i].v;
            if(e[i].w&&!level[v])
                level[v]=level[u]+1,Q.push(v);
        }
    }
    return level[T];
}
int DFS(int u,int flow)
{
    if(flow==0||u==T)return flow;
    int ret=0;
    for(int &i=cur[u];i!=-1;i=e[i].next)
    {
        int v=e[i].v;
        if(e[i].w&&level[v]==level[u]+1)
        {
            int dd=DFS(v,min(flow,e[i].w));
            flow-=dd;ret+=dd;
            e[i].w-=dd;e[i^1].w+=dd;
        }
    }
    return ret;
}
int Dinic()
{
    int ret=0;
    while(BFS())
    {
        for(int i=S;i<=T;++i)cur[i]=h[i];
        ret+=DFS(S,INF);
    }
    return ret;
}
char g[MAX][MAX];
void Build(int mid)
{
    memset(h,-1,sizeof(h));
    cnt=0;
    for(int i=1;i<=n;++i)
    {
        Add(S,i,mid);
        Add(i+n+n,T,mid);
        Add(i,i+n,K);
        Add(i+n+n+n,i+n+n,K);
    }
    for(int i=1;i<=n;++i)
        for(int j=1;j<=n;++j)
            if(g[i][j]=='Y')
                Add(i,j+n+n,1);
            else
                Add(i+n,j+n+n+n,1);
}
int main()
{
    n=read();K=read();
    S=0;T=n+n+n+n+1;
    for(int i=1;i<=n;++i)
        scanf("%s",g[i]+1);
    int l=0,r=n;
    while(l+1<r)
    {
        int mid=(l+r)>>1;
        Build(mid);
        if(Dinic()==mid*n)l=mid;
        else r=mid;
    }
    Build(r);
    printf("%d\n",Dinic()==r*n?r:l);
    return 0;
}

```

---

## 作者：天上一颗蛋 (赞：21)

## P3153 [CQOI2009]跳舞

题目描述
一次舞会有n个男孩和n个女孩。每首曲子开始时，所有男孩和女孩恰好配成n对跳交谊舞。每个男孩都不会和同一个女孩跳两首（或更多）舞曲。有一些男孩女孩相互喜欢，而其他相互不喜欢（不会”单向喜欢“）。每个男孩最多只愿意和k个不喜欢的女孩跳舞，而每个女孩也最多只愿意和k个不喜欢的男孩跳舞。给出每对男孩女孩是否相互喜欢的信息，舞会最多能有几首舞曲？

输入输出格式
输入格式：
第一行包含两个整数n和k。以下n行每行包含n个字符，其中第i行第j个字符为'Y'当且仅当男孩i和女孩j相互喜欢。

输出格式：
仅一个数，即舞曲数目的最大值。

---
# 分析

首先看的出这道题是一个**匹配问题**，自然联想到网络流算法

既然是网络流，那么就一定有网络容量来达到**限制**的目的，最后对应题意的要求。而**通过题意找限制条件，构建模型最后用最大流求解，是最大流类题目的核心解法**

现在我们来看看这题有什么限制：

1.所有男孩/女孩都要跳舞，不能在旁边干看着

2.不会和同一人跳舞

3.只能和k个不喜欢的人跳舞

依据这些条件，我们怎么构建模型呢？

# 建模

我们一个一个分析：

1.都要跳舞

既然不能干看着，那么一首舞曲中，每个人都得跳，换言之，若是本题答案为ans，那么最终每人都能跳ans只舞，

所以我们**二分答案**，在某个模型下跑最大流，最后检查答案，若满足条件：（跳舞的总数就是ans * N（人数））我们就往上搜，否则就往下搜，不断缩小二分范围，找到答案 ~~（其实貌似数据范围可以直接枚举）~~

2.不会和同一人跳舞

匹配的基本知识，男女连边容量为1即可，不再赘述

3.能和k个不喜欢的人跳舞

我们要求能跳舞的场数最多，自然就想k尽可能多一点，虽然k是不能改变的，但是依据贪心的思想，我们**能不用k就尽量不用k**，换言之，如果和舞伴互相喜欢，就不用消耗k的次数了。

为了达到喜欢的人互相跳舞不消耗k，我们需要**分裂点**：将每个男/女分裂为喜欢和不喜欢两个部分，然后连边如下图

![](https://cdn.luogu.com.cn/upload/pic/17515.png)

a为二分出来的答案
源点连男容量为a保证了一个人可以跳a场舞，来进行最大流以及答案验证
（深色为喜欢，浅一点为不喜欢）

若两人相互喜欢，则有：

![](https://cdn.luogu.com.cn/upload/pic/17516.png)

这样直接连喜欢，s到t的路上没有占用k，即k的次数无消耗；容量为1保证了只和同一人跳一次舞

---
若两人不互相喜欢，则有

![](https://cdn.luogu.com.cn/upload/pic/17517.png)

不喜欢的人跳舞不愿意，需要消耗k，路径被夹在k之间，最大流从之间通过消耗k，达到目的；容量为1同样保证了只和同一人跳一次舞

建模完毕

最后跑最大流，验证是否合法，继续二分即可得到最终答案

**注：重复建图记得初始化**

# AC Code

```cpp
#include<iostream>
#include<cstdio>
#include<queue>
#include<cstring>
#include<algorithm>
#define ll long long
using namespace std;
int RD(){
    int out = 0,flag = 1;char c = getchar();
    while(c < '0' || c >'9'){if(c == '-')flag = -1;c = getchar();}
    while(c >= '0' && c <= '9'){out = out * 10 + c - '0';c = getchar();}
    return flag * out;
    }
const int maxn = 100019,INF = 1e9;
int num,k,nume = 1;
int dance[190][190];
int s,t,maxflow;
int head[maxn << 2];
struct Node{
    int v,dis,nxt;
    }E[maxn << 3];
void add(int u,int v,int dis){
    E[++nume].nxt = head[u];
    E[nume].v = v;
    E[nume].dis = dis;
    head[u] = nume;
    }
int d[maxn];
bool bfs(){
    queue<int>Q;
    memset(d,0,sizeof(d));
    d[s] = 1;
    Q.push(s);
    while(!Q.empty()){
        int u = Q.front();Q.pop();
        for(int i = head[u];i;i = E[i].nxt){
            int v = E[i].v;
            if(E[i].dis && !d[v]){
                d[v] = d[u] + 1;
                if(v == t)return 1;
                Q.push(v);
                }
            }
        }
    return 0;
    }
int Dinic(int u,int flow){
    if(u == t)return flow;
    int rest = flow,k;
    for(int i = head[u];i;i = E[i].nxt){
        int v = E[i].v;
        if(d[v] == d[u] + 1 && rest && E[i].dis){
            k = Dinic(v,min(rest,E[i].dis));
            if(!k)d[v] = 0;
            E[i].dis -= k;
            E[i ^ 1].dis += k;
            rest -= k;
            }
        }
    return flow - rest;
    }
void build(int a){
    memset(head,0,sizeof(head));
    nume = 1;//初始化
    for(int i = 1;i <= num;i++){
        add(s,i,a);
        add(i,s,0);//连汇点到男生喜欢
        add(i,i + num,k);
        add(i + num,i,0);//连男喜欢到不喜欢
        add(i + 2 * num,i + 3 * num,k);
        add(i + 3 * num,i + 2 * num,0);//连女不喜欢到喜欢
        add(i + 3 * num,t,a);
        add(t,i + 3 * num,0);//女喜欢到源点
        }
    for(int i = 1;i <= num;i++){
        for(int j = 1;j <= num;j++){
            if(dance[i][j]){
                add(i,j + 3 * num,1);
                add(j + 3 * num,i,0);
                }
            else{
                add(i + num,j + 2 * num,1);
                add(j + 2 * num,i + num,0);
                }
            }
        }
    }
bool check(int mid){
    build(mid);
    maxflow = 0;
    int flow = 0;
    while(bfs())while(flow = Dinic(s,INF))maxflow += flow;
    if(maxflow == mid * num)return 1;
    return 0;
    }
int search(int l,int r){
    int ans;
    while(l <= r){
        int mid = l + r >> 1;
        if(check(mid))l = mid + 1,ans = mid;
        else r = mid - 1;
        }
    return ans;
    }
int main(){
    num = RD();k = RD();
    char temp;
    for(int i = 1;i <= num;i++){
        for(int j = 1;j <= num;j++){
            cin>>temp;
            if(temp == 'Y')dance[i][j] = 1;
            }
        }
    s = num * 4 + 1;t = s + 1;
    printf("%d\n",search(0,num + k));
    return 0;
    }
```

---

## 作者：ker_xyxyxyx_xxs (赞：7)

[P3153 [CQOI2009]跳舞](https://www.luogu.com.cn/problem/P3153)

UPD：上次没过，修改了一下

题意略，算法：网络流中的最大流。

考虑拆点，首先画出原点和汇点，接着一列表示男生点，另一列表示女生点，再拆点。将每个男生拆为喜欢和不喜欢两个点，需要连接所喜欢和不喜欢的女生的点，具体示意如下：
![](https://cdn.luogu.com.cn/upload/image_hosting/54xqau70.png)

需要注意的时，由于每个人都可以和自己喜欢的很多人跳无数次，所以要连容量 $ inf $ ，但只能和自己不喜欢的人们跳 $ k $ 次，所以连容量 $ k $，可以保证正确性。

接下来就是如上文所说的，中间的一条边表示对应的一对关系，每个人的喜欢节点向喜欢的人连边，不喜欢节点向不喜欢的人连边，因为只能跳一次，所以容量为 $ 1 $ 。

但是源汇点与每个人之间的边怎么考虑呢？众所周知，网络流中一个点的流出量等于其流入量，所以人的个数 $ \cdot $ 每条边流量 $ = $ 源点量，对每条边流量进行二分即可，如果源点出量大于最大流，则需要减小每条边的出量，反之同。而为了求最多对，则求最大流。( $ ISAP $ 算法）。

### 总结思路
按上图进行建图，对每条边的流量二分答案，如果所有出流量大于最大流，则减小每条边流量。

为方便理解建图，样例建图如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/gha4mtg6.png)

## Tips

接下来说一些关于代码实现方面的内容

1、由于 $ mid $ 在边上，所以每次二分需要重新建边

2、二分下界 $ 0 $ 上界 $ n $ 

3、**提前解释一下代码中建图的实现**

建图分为三个板块：

一、左半部分点

![](https://cdn.luogu.com.cn/upload/image_hosting/bd173jbh.png)
 
二、右半部分点

![](https://cdn.luogu.com.cn/upload/image_hosting/izjvfh7a.png)

tips: $ \lfloor \frac{n}{m} \rfloor = \lceil \frac{n+1}{m} \rceil $

三、中间部分

讨论第i个男孩，直接对应每一个女生，如果喜欢就从喜欢节点连向喜欢节点，不喜欢就从不喜欢节点连向不喜欢节点。~~作者写累了写不动了就略了，因为是最简单的一部分~~


$ Code $
```cpp
# include <iostream>
# include <cstdio>
# include <cstring>
# define int long long
using namespace std;
const int inf = 0x3f3f3f3f;
const int maxn = 1e6 + 5;
const int maxm = 50 + 5;
int n , k;

char c[maxm];
int S , T;
int like[maxm][maxm];
int cnt[maxn] , dis[maxn];
typedef struct {
	int x , y , z , next;
} Edge;
Edge edge[maxn];
int E = 1  , elast[maxn];
void add(int x , int y , int z) {
	E ++;
	edge[E].x = x;
	edge[E].y = y;
	edge[E].z = z;
	edge[E].next = elast[x];
	elast[x] = E;
}
void rebuild(int mid) {
	for (int i = 1 ; i <= n ; i ++) {
		add(i + 1 , n + 1 + ((i - 1) << 1) + 1, inf);
		add(n + 1 + ((i - 1) << 1) + 1 , i + 1 , 0);
		add(i + 1 , n + 1 + ((i - 1) << 1) + 2 , k);
		add(n + 1 + ((i - 1) << 1) + 2 , i + 1 , 0);
		for (int j = 1 ; j <= n ; j ++) {
			if (like[i][j] == 1) {
				add(n + 1 + ((i - 1) << 1) + 1 , n * 3 + 1 + (j << 1) - 1 , 1);
				add(n * 3 + 1 + (j << 1) - 1 , n + 1 + ((i - 1) << 1) + 1 , 0);
			} else {
				add(n + 1 + ((i - 1) << 1) + 2 , n * 3 + 1 + (j << 1) , 1);
				add(n * 3 + 1 + (j << 1) , n + 1 + ((i - 1) << 1) + 2 , 0);
			}
		}

	}
	for (int i = 1 ; i <= n << 1 ; i ++) {
		if (i & 1) {
			add(n * 3 + 1 + i , ((i + 1) >> 1) + n * 5 + 1 , inf);
			add(((i + 1) >> 1) + n * 5 + 1 , n * 3 + 1 + i , 0);
		} else {
			add(n * 3 + 1 + i , n * 5 + 1 + (i >> 1) , k);
			add(n * 5 + 1 + (i >> 1) , n * 3 + 1 + i , 0);
		}
	}
	for (int i = 1 ; i <= n ; i ++) {
		add(1 , i + 1 , mid);
		add(i + 1 , 1 , mid);
	}
	for (int i = n * 5 + 1 + 1 ; i <= T - 1 ; i ++) {
		add(i , T , mid);
		add(T , i , mid);
	}

}
int dfs(int u , int flow) {
	int temp , delta;
	delta = 0;
	if (u == T) return flow;
	for (int i = elast[u] ; i ; i = edge[i].next) {
		int v = edge[i].y;
		if (edge[i].z > 0 && dis[u] == dis[v] + 1) {
			temp = dfs(v , min(flow - delta , edge[i].z));
			edge[i].z -= temp;
			edge[i ^ 1].z += temp;
			delta += temp;
			if (delta == flow || dis[1] >= T) return delta;
		}
	}
	if (dis[1] >= T) return delta;
	cnt[dis[u]] --;
	if (cnt[dis[u]] == 0) dis[1] = T;
	dis[u] = dis[u] + 1;
	cnt[dis[u]] ++;
	return delta;
}
signed main() {
	cin >> n >> k;
	for (int i = 1 ; i <= n ; i ++) {
		scanf("%s" , &c);
		for (int j = 0 ; j < n ; j ++) {
			if (c[j] == 'Y') {
				like[i][j + 1] = 1;
			} else {
				like[i][j + 1] = 0;
			}
		}
	}
	S = 1;
	T = n * 6 + 2;
	int ans;
	int l = 0 , r = n, Ans;
	while (l <= r) {
		int mid = l + r >> 1;
		E = 1;
		memset(elast , 0 , sizeof elast);
		memset(dis , 0 , sizeof dis);
		rebuild(mid);
		ans = 0;
		while (dis[1] < T) {
			ans += dfs(1 , inf + 1);
		}
		if (ans == n * mid){
			l = mid + 1;
			Ans = mid;
		} else {
			r = mid - 1;
		}
	}
	printf("%d\n" , Ans);
	return 0;
}

```




---

## 作者：huangkx (赞：5)

## 闲话

这道题是 2022 年暑假的最后一道题，这篇题解是 2022 年暑假的最后一篇题解。

## 思路

容易发现答案具有单调性，于是考虑二分答案。假设当前的舞曲数量为 $x$，考虑建立网络流模型判断 $x$ 是否满足条件。

- 建立源点和汇点。
- 对于每个人，把 TA 拆成 “喜欢点” 和 “不喜欢点”。
- 由源点向每个男孩的 “喜欢点” 连容量为 $x$ 的弧。
- 由每个男孩的 “喜欢点” 向他的 “不喜欢点” 连容量为 $k$ 的弧。
- 由每个男孩的 “喜欢点” 向他喜欢的女孩的 “喜欢点” 连容量为 $1$ 的弧；由每个男孩的 “不喜欢点” 向他不喜欢的女孩的 “不喜欢点” 连容量为 $1$ 的弧。
- 由每个女孩的 “不喜欢点” 向她的 “喜欢点” 连容量为 $k$ 的弧。
- 由每个女孩的 “喜欢点” 向汇点连容量为 $x$ 的弧。

此时该网络的最大流即为可以跳舞的人的对数。若最大流等于 $n x$，则 $x$ 满足条件。

若使用 $\texttt {Dinic}$ 算法求解网络最大流，则时间复杂度为 $\mathcal { O } ( n ^ 4 \log n )$。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
const int INF = 1e9;
const int MAXN = 5e1;
const int MAXNODE = 1e3;
int n, k;
int l, r, mid;
char c[MAXN + 5][MAXN + 5];
struct Node{
	int v, w, anti;
	Node(): v(0), w(0), anti(0){}
	Node(int V, int W, int ANTI): v(V), w(W), anti(ANTI){}
};
vector < vector < Node > > g(MAXNODE + 5);
int dep[MAXNODE + 5];
int cur[MAXNODE + 5];
queue < int > q;
void Add(int u, int v, int w)
{
	g[u].push_back(Node(v, w, g[v].size()));
	g[v].push_back(Node(u, 0, g[u].size() - 1));
}
bool BFS(int s, int t, int n)
{
	for(int u = 1; u <= n; u ++) dep[u] = 0; dep[s] = 1;
	for(int u = 1; u <= n; u ++) cur[u] = 0;
	while( ! q.empty()) q.pop(); q.push(s);
	while( ! q.empty()){
		int u = q.front();
		q.pop();
		for(int i = 0; i < g[u].size(); i ++){
			if(g[u][i].w > 0 && dep[g[u][i].v] == 0){
				dep[g[u][i].v] = dep[u] + 1;
				q.push(g[u][i].v);
			}
		}
	}
	return dep[t] > 0;
}
int DFS(int u, int t, int minflow, int n)
{
	if(u == t) return minflow;
	for(int &i = cur[u]; i < g[u].size(); i ++){
		if(g[u][i].w > 0 && dep[g[u][i].v] == dep[u] + 1){
			int inc = DFS(g[u][i].v, t, min(minflow, g[u][i].w), n);
			if(inc > 0){
				g[u][i].w -= inc;
				g[g[u][i].v][g[u][i].anti].w += inc;
				return inc;
			}
		}
	}
	return 0;
}
int Dinic(int s, int t, int n)
{
	int res = 0;
	while(BFS(s, t, n) == true){
		while(true){
			int inc = DFS(s, t, INF, n);
			if(inc == 0) break;
			res += inc;
		}
	}
	return res;
}
bool Check(int x)
{
	for(int u = 1; u <= 4 * n + 2; u ++) g[u].clear();
	for(int u = 1; u <= n; u ++) Add(4 * n + 1, u, x);
	for(int u = 1; u <= n; u ++) Add(u, n + u, k);
	for(int u = 1; u <= n; u ++) for(int v = 1; v <= n; v ++){
		if(c[u][v] == 'Y') Add(u, 2 * n + v, 1);
		if(c[u][v] == 'N') Add(n + u, 3 * n + v, 1);
	}
	for(int u = 1; u <= n; u ++) Add(3 * n + u, 2 * n + u, k);
	for(int u = 1; u <= n; u ++) Add(2 * n + u, 4 * n + 2, x);
	return Dinic(4 * n + 1, 4 * n + 2, 4 * n + 2) == n * x;
}
int main()
{
	scanf("%d%d", &n, &k);
	for(int u = 1; u <= n; u ++) for(int v = 1; v <= n; v ++) cin >> c[u][v];
	l = 0, r = n + 1;
	while(l + 1 < r){
		mid = (l + r) >> 1;
		if(Check(mid) == true) l = mid;
		else r = mid;
	}
	printf("%d\n", l);
	return 0;
}
```

2022.8.31

---

## 作者：BzhH (赞：2)

读完这到题，感觉上像是一道二分图匹配得问题，但是它对于每一个点又有一些限制，所以可以考虑拆点，将男生和女生都拆成两个点，并连一条容量为k的边
![](https://cdn.luogu.com.cn/upload/image_hosting/v5wmxct6.png)

对于一对相互喜欢的男女，在男l与女r之间连一条容量为1的边，如果不喜欢那么就在男r与女l之间连一条容量为1的边，枚举可以有和舞曲数量m，在S与男l，女r与T之间连一条容量为m的边，如果该流网络存在满流的最大流，那么这个答案就是合法的，因为此题答案并不大，所以可以直接枚举

代码
```
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
const int N = 1005, M = 1e5 + 5, INF = 1e8;

int n, k, idx, S, T;
int head[N], ver[M], net[M], cpt[M];
int d[N], cur[N], q[N];

void add(int a, int b, int c)
{
    net[idx] = head[a], ver[idx] = b, cpt[idx] = c, head[a] = idx++;
    net[idx] = head[b], ver[idx] = a, cpt[idx] = 0, head[b] = idx++;
}

bool bfs()
{
    int front = 0, tail = 0;
    memset(d, -1, sizeof(d));
    q[0] = S, d[S] = 0, cur[S] = head[S];
    while (front <= tail)
    {
        int u = q[front++];
        for (int i = head[u]; ~i; i = net[i])
        {
            int v = ver[i];
            if (d[v] == -1 && cpt[i])
            {
                d[v] = d[u] + 1;
                cur[v] = head[v];
                if (v == T)
                    return true;
                q[++tail] = v;
            }
        }
    }
    return false;
}

int find(int u, int limit)
{
    if (u == T)
        return limit;
    int flow = 0;
    for (int i = cur[u]; ~i && flow < limit; i = net[i])
    {
        cur[u] = i;
        int v = ver[i];
        if (d[v] == d[u] + 1 && cpt[i])
        {
            int x = find(v, min(limit - flow, cpt[i]));
            if (!x)
                d[v] = -1;
            cpt[i] -= x, cpt[i ^ 1] += x, flow += x;
        }
    }
    return flow;
}

int dinic()
{
    int flow, res = 0;
    while (bfs())
    {
        while (flow = find(S, INF))
            res += flow;
    }
    return res;
}

int main()
{
    memset(head, -1, sizeof(head));
    S = 0, T = N - 1;
    scanf("%d%d", &n, &k);
    for (int i = 1; i <= n; i++)
    {
        for (int j = 1; j <= n; j++)
        {
            char a;
            scanf(" %c", &a);
            if (a == 'Y')
                add(i, 3 * n + j, 1);
            else
                add(n + i, 2 * n + j, 1);
        }
    }
    for (int i = 1; i <= n; i++)
    {
        add(i, n + i, k), add(2 * n + i, 3 * n + i, k);
        add(S, i, 0), add(3 * n + i, T, 0);
    }
    int ans = 55;
    while(ans--)
    {
        for (int i = 0; i < idx; i += 2)
        {            
            if (cpt[i ^ 1])
                cpt[i] += cpt[i ^ 1], cpt[i ^ 1] = 0;
            if (ver[i ^ 1] == S || ver[i] == T)
                cpt[i] = ans;
        }
        if (dinic() == ans * n)
        {
            printf("%d", ans);
            return 0;
        }
    }
    printf("%d", ans);
    return 0;
}
```


---

## 作者：mjsdnz (赞：1)

+ [原题链接](https://www.luogu.com.cn/problem/P3153)

## 题目大意

给 $n$ 个男孩和 $n$ 个女孩，选出来 $n$ 对跳一次舞，且两个人只能共同跳一次舞，要求跳舞次数最大。有的男孩女孩互相喜欢（一个人可能有很多喜欢的人），且不会有单相思，一个男孩只会和他不喜欢的女孩跳 $k$ 次舞，女孩也同理。

## 建模
首先考虑 $k$ 的限制，通过直觉或者几次尝试我们发现可以用网络流问题中比较经典的拆点思想。

把一个人拆成两个点，一个向喜欢的人连边，一个向不喜欢的人连边，流量均为一。自己从向喜欢的人连边的点向向不喜欢的人连边的点连边，流量为 $k$。（都为有向边）

如果没有需要 $n$ 对来组成一首曲子的限制的话，我们可以直接设源点到每个男孩之间有一条流量为无限的边，女孩到汇点之间也有一条。不过由于场次的限制我们需要一些改变。

我们可以先把无限的流量改为一，然后跑多次最大流。如果流量是 $n$ 则说明可以跳舞，增加一次答案后将源点向男孩，女孩向汇点的边全部重置一遍，然后接着跑最大流。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5 + 10;
const int M = 2e6 + 10;
const int inf = 0x3f3f3f3f;
int n, k, s, t;
int cnt = 1;
int head[N];
struct edge {
	int u, v, c, nxt;
	edge(int u = 0, int v = 0, int c = 0, int nxt = 0) : u(u), v(v), c(c), nxt(nxt) {}
} e[M * 2];
void ADD(int u, int v, int c) {
	cnt++;
	e[cnt] = edge(u, v, c, head[u]);
	head[u] = cnt;
}
void add_edge(int u, int v, int c) {
	ADD(u, v, c);
	ADD(v, u, 0);
}
int dep[N];
int now[N];
bool bfs() {
	memset(dep, 0, sizeof dep);
	memcpy(now, head, sizeof head);
	queue<int>q;
	dep[s] = 1;
	q.push(s);
	while (!q.empty()) {
		int u = q.front();
		q.pop();
		for (int i = head[u]; i; i = e[i].nxt) {
			int v = e[i].v;
			int c = e[i].c;
			if (dep[v] != 0 || !c) continue;
			dep[v] = dep[u] + 1;
			q.push(v);
		}
	}
	return dep[t] != 0;
}
int dfs(int u, int t, int flow) {
	if (u == t) return flow;
	int nowflow = 0;
	for (int i = now[u]; i; i = e[i].nxt) {
		now[u] = i;
		int v = e[i].v;
		int c = e[i].c;
		if (dep[v] != dep[u] + 1 || !c ) continue;
		int ff = dfs(v, t, min(flow, c));
		if (ff) flow -= ff, nowflow += ff, e[i].c -= ff, e[i ^ 1].c += ff;
	}
	return nowflow;
}
bool maxflow() {
	int mxflow = 0;
	int nowflow;
	while (bfs()) {
		while ((nowflow = dfs(s, t, inf))) mxflow += nowflow;
		if (mxflow >= n) return 1;
	}
	return 0;
}
int re1[N];
int re2[N];
int main() {
	cin >> n >> k;
	s = n * 4 + 1, t = n * 4 + 2;
	for (int i = 1; i <= n; i++) {
		add_edge(i, n * 2 + i, k);
		add_edge(n * 3 + i, n + i, k);
		string a;
		cin >> a;
		for (int j = 0; j < n; j++) {
			if (a[j] == 'Y') add_edge(i, j + 1 + n, 1);
			else add_edge(n * 2 + i, j + 1 + n*3, 1);
		}
	}
	int tot = 0;
	for (int i = 1; i <= n; i++) add_edge(s, i, 1), re1[i] = cnt - 1, add_edge(i + n, t, 1), re2[i] = cnt - 1;
	while (maxflow()) {
		tot++;
		for (int i = 1; i <= n; i++) {
			e[re1[i]].c += e[re1[i] ^ 1].c;
			e[re1[i] ^ 1].c = 0;
			e[re2[i]].c += e[re2[i] ^ 1].c;
			e[re2[i] ^ 1].c = 0;
		}
	}
	cout << tot;
}
```

---

## 作者：Erotate (赞：0)

### Solution

不妨二分舞曲的数目，对于每一次二分都重新建图。考虑把男孩和女孩都分成三部分，喜欢和不喜欢，以及自己本身。

首先连源点到男孩本身，流量为二分的舞曲数量。接着连男孩本身和喜欢部分，流量为无限，表示能和喜欢的女孩条无限多首舞曲。再连男孩本身和不喜欢部分，流量为 $k$，因为最多和不喜欢的女孩跳 $k$ 首舞曲。女孩同理。

最后按照题目要求，把相互喜欢的男孩的喜欢部分和女孩的喜欢部分连起来，因为他们都只会和相同的人跳一次，所以流量为 $1$。如果一个男孩和一个女孩相互不喜欢，就连他们的不喜欢部分，流量依然为 $1$。

最后的最后，别忘记把女孩本身和汇点连起来，跑最大流即可。

### Code

```cpp
#include<bits/stdc++.h>
#define endl '\n'
using namespace std;
const int N=305,M=1e6+5,inf=2e9;
struct edge{
	int v,nxt,w;
}e[M<<1];
int head[N],cnt;
int n,k,S,T,dep[N],cur[N];
char ch[N][N];
int b(int x){return x;}
int blk(int x){return n+x*2-1;}
int bdlk(int x){return n+x*2;}
int g(int x){return n*5+1;}
int glk(int x){return n*3+x*2-1;}
int gdlk(int x){return n*3+x*2;}
void Add(int x,int y,int w){
	e[++cnt]=((edge){y,head[x],w});
	head[x]=cnt;
}
void add(int x,int y,int w){
	Add(x,y,w),Add(y,x,0);
}
void init(){
	memset(cur,0,sizeof(cur));
	memset(head,0,sizeof(head));
	cnt=1;
}
bool bfs(int st,int ed){
	memset(dep,0,sizeof(dep));
	queue<int>q;
	q.push(st);
	cur[st]=head[st],dep[st]=1;
	while(!q.empty()){
		int u=q.front();
		q.pop();
		for(int i=head[u];i;i=e[i].nxt){
			int v=e[i].v;
			if(!dep[v] && e[i].w){
				dep[v]=dep[u]+1;
				cur[v]=head[v];
				q.push(v);
			}
		}
	}
	return dep[ed];
}
int dfs(int u,int frm){
	int to=0;
	if(u==T) return frm;
	for(int i=cur[u];i && frm;i=e[i].nxt){
		int v=e[i].v;
		cur[u]=i;
		if(e[i].w && dep[v]==dep[u]+1){
			int tmp=dfs(v,min(frm,e[i].w));
			e[i].w-=tmp,e[i^1].w+=tmp;
			frm-=tmp,to+=tmp;
		}
	}
	if(!to) dep[u]=0;
	return to;
}
int Dinic(){
	int flw=0;
	while(bfs(S,T)) flw+=dfs(S,inf);
	return flw;
}
bool check(int x){
    init();
	for(int i=1;i<=n;++i) add(S,b(i),x);
	for(int i=1;i<=n;++i) add(b(i),blk(i),inf),add(b(i),bdlk(i),k);
	for(int i=1;i<=n;++i)
		for(int j=1;j<=n;++j){
			if(ch[i][j]=='Y') add(blk(i),glk(j),1);
			else add(bdlk(i),gdlk(j),1);
		}
	for(int i=1;i<=n;++i) add(glk(i),g(i),inf),add(gdlk(i),g(i),k);
	for(int i=1;i<=n;++i) add(g(i),T,x);
	return Dinic()==n*x;
}
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(nullptr),cout.tie(nullptr);
	cin>>n>>k;
	S=0,T=6*n+1;
	for(int i=1;i<=n;++i) cin>>ch[i]+1;
	int l=0,r=n,ans=0;
	while(l<=r){
		int mid=l+r>>1;
		if(check(mid)){
			ans=mid;
			l=mid+1;
		}else r=mid-1;
	}
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：yllcm (赞：0)

这题建模还是很简单的：先二分答案 $x$，然后建图：

* $(S,i)$，其中 $i$ 是表示男生的点，流量为 $x$。
* $(j,T)$，其中 $j$ 是表示女生的点，流量为 $x$。
* $(i,i_0)$，$i_0$ 是表示不喜欢的点，流量为 $k$。
* $(i,i_1)$，表示喜欢，流量为 $\inf$。
* 第三、四类边对女生同理，之后喜欢向喜欢连，不喜欢向不喜欢连，流量为 $1$。

不过我们需要补充一个说明：任何一个流量方案和原来的跳舞方案一一对应。不妨把相互匹配的男生和女生之间连一条边，显然这构成一个 $x$ 正则二分图，我们需要证明它能被拆成恰好 $x$ 个完美匹配。

考虑归纳，显然删去一组完美匹配会得到一个 $x-1$ 正则二分图，所以原命题等价于：任何 $r$ 正则图都存在完美匹配。

这是个经典问题，考虑 Hall 定理。

* Hall 定理，即对于左部点中任意一个子集 $S$，定义和 $v$ 相邻的点集合为 $N(v)$，我们需要证明 $|S|\leq|\cup_{v\in S}N(v)|$。

假设 $R=\cup_{v\in S}N(v)$，假设 $|R|<|L|$，那么 $|R|\times k<|L|\times k$，右边是 $L$ 连向 $R$ 的边集大小，左边是 $R$ 的邻边集合大小。显然前者是后者的子集，矛盾。故得证。

```cpp
#include<bits/stdc++.h>
#define ll long long
#define ull unsigned long long
#define db double
#define ldb long double
#define pb push_back
#define mp make_pair
#define pii pair<int, int>
using namespace std;
inline int read() {
    int x = 0; bool op = 0;
    char c = getchar();
    while(!isdigit(c))op |= (c == '-'), c = getchar();
    while(isdigit(c))x = (x << 1) + (x << 3) + (c ^ 48), c = getchar();
    return op ? -x : x;
}
template<int N> struct MFL {
  	const int INF = 1e9;
    int n, etot, S, T, head[N], to[N], nxt[N], flow[N];
    void addedge(int u, int v, int w) { 
        to[++etot] = v; flow[etot] = w; nxt[etot] = head[u]; head[u] = etot;
    }
    void add(int u, int v, int w) {
        addedge(u, v, w); addedge(v, u, 0);
        return ;
    }
    void init(int nn, int ns, int nt) {
        n = nn; S = ns; T = nt; etot = 1;
        memset(head, 0, sizeof(head));
        return ;
    }
    int lev[N], cur[N];
    bool bfs() {
        for(int i = 0; i <= n; i++)cur[i] = head[i], lev[i] = 0;
        queue<int> q;
        q.push(S); lev[S] = 1;
        while(q.empty() == false) {
            int u = q.front(); q.pop();
            for(int i = head[u]; i; i = nxt[i]) {
                if(lev[to[i]] || flow[i] == 0)continue;
                lev[to[i]] = lev[u] + 1;
                if(to[i] == T)return true;
                q.push(to[i]);
            }
        }
        return false;
    }
    int dinic(int u, int fl) {
        if(u == T)return fl;
        int rest = fl;
        for(int i = cur[u]; i && rest; i = nxt[i]) {
            cur[u] = i;
            if(lev[to[i]] ^ (lev[u] + 1) || flow[i] == 0)continue;
            int inc = dinic(to[i], min(flow[i], rest));
            if(inc == 0)lev[to[i]] = 0;
            flow[i] -= inc; flow[i ^ 1] += inc; rest -= inc;
        }
        return fl - rest;
    }
    int query() {
        int mxfl = 0, fl = 0;
        while(bfs()) {
            while(fl = dinic(S, INF))mxfl += fl;
        }
        return mxfl;
    }
};
const int N = 5e3 + 10;
const int MAXN = 1e6 + 10;
const int INF = 1e9;
MFL<MAXN> mf;
int n, k, tot, id[N][2];
char g[N][N];
bool check(int x) {
    mf.init(tot + 1, 0, tot + 1);
    for(int i = 1; i <= n; i++) {
        mf.add(mf.S, i, x);
        mf.add(i, id[i][0], k);
        mf.add(i, id[i][1], INF);
    }
    for(int i = n + 1; i <= n * 2; i++) {
        mf.add(i, mf.T, x);
        mf.add(id[i][0], i, k);
        mf.add(id[i][1], i, INF);
    }
    for(int i = 1; i <= n; i++) {
        for(int j = 1; j <= n; j++) {
            if(g[i][j] == 'Y')mf.add(id[i][1], id[j + n][1], 1);
            else mf.add(id[i][0], id[j + n][0], 1);
        }
    }
    if(mf.query() < x * n)return false;
    return true;
} 
int main() {
    n = read(); k = read();
    for(int i = 1; i <= n; i++)scanf("%s", g[i] + 1);
    tot = 2 * n;
    for(int i = 1; i <= n * 2; i++) {
        id[i][0] = ++tot; id[i][1] = ++tot;
    }
    int lef = 0, rig = n + 1;
    while(lef + 1 < rig) {
        int mid = lef + rig >> 1;
        if(check(mid))lef = mid;
        else rig = mid;
    }
    printf("%d\n", lef);
    return 0;
}
```


---

## 作者：Foreverxxx (赞：0)

### 思路

先思考，能否用网络流直接求解，不过好像不现实。因为如果没有先确定一个答案，无法判断是否可以有这么多舞曲。

然后就发现答案具有单调性，且题目中有“最多”二字。

所以我们考虑二分，每次二分一个答案，判断是否合法。

具体地，我们二分一个值 $mid$，表示每个人可以跳的舞曲的数量，然后进行连边。

对于连边的方式，由于题目中指出了有喜欢和不喜欢两种类型，所以我们需要对每个人进行拆点，拆成喜欢和不喜欢两个点。

对于不喜欢的人的跳舞数量 $k$，只需要从喜欢向不喜欢连一条流量为 $k$ 的边就行了，因为这 $k$ 支舞是包含在每个人总共可以跳舞的数量 $mid$ 中的。

然后按照要求，从男生喜欢向女生喜欢连流量为 $1$ 的边，从男生不喜欢向女生不喜欢连流量为 $1$ 的边。

然后跑最大流，判断是否可以跳 $mid \times n$ 支舞出来就可以了。

### 一些细节

1. 对于源点和汇点，我们需要分别连向男生和女生，也就是说，如果源点连向男生，女生就得连向汇点。

2. 从源点出发，只需要向男生喜欢连上流量为 $mid$ 的边就可以了，而对于汇点，则从女生喜欢连向汇点，容量也为 $mid$。至于此处为什么是从女生喜欢连向汇点，画一个图理解一下就可以了。

Code

```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read(){
	int sss=0;
	char chh=getchar();
	while(chh<'0'||chh>'9') chh=getchar();
	while(chh>='0'&&chh<='9'){
		sss=sss*10+chh-'0';
		chh=getchar();
	}
	return sss;
}
int n,k,s,t;
char choice[55][55];
int depth[1005];
int head[1005],to[1000005],val[1000005],nxt[1000005],tot=1;
void add(int u,int v,int w){
	to[++tot]=v;
	val[tot]=w;
	nxt[tot]=head[u];
	head[u]=tot;
}
bool bfs(){
	memset(depth,0,sizeof depth); depth[s]=1;
	queue<int> q; q.push(s);
	while(!q.empty()){
		int x=q.front(); q.pop();
		for(register int i=head[x];i;i=nxt[i]){
			int u=to[i];
			if(val[i]&&!depth[u]){
				depth[u]=depth[x]+1;
				q.push(u);
			}
		}
	}
	return depth[t];
}
int dfs(int now,int flow){
	if(now==t) return flow;
	int out_flow=0;
	for(register int i=head[now];i&&flow;i=nxt[i]){
		int u=to[i];
		if(val[i]&&depth[u]==depth[now]+1){
			int tmp=dfs(u,min(val[i],flow));
			val[i]-=tmp; val[i^1]+=tmp;
			flow-=tmp; out_flow+=tmp;
		}
	}
	if(out_flow==0) depth[now]=0;
	return out_flow;
}
int Dinic(){
	int ret=0;
	while(bfs()) ret+=dfs(s,1e9);
	return ret;
}
void rebuild(int mid){
    memset(head,-1,sizeof head); tot=1;
    for(register int i=1;i<=n;i++){
        add(s,i,mid); add(i,s,0);
        add(i,i+n,k); add(i+n,1,0);
        add(i+n+n+n,i+n+n,k); add(i+n+n,i+n+n+n,0);
        add(i+n+n,t,mid); add(t,i+n+n,0);
    }
    for(register int i=1;i<=n;i++){
    	for(register int j=1;j<=n;j++){
    		if(choice[i][j]=='Y'){
    			add(i,j+n+n,1); add(j+n+n,i,0);
			}
            else {
            	add(i+n,j+n+n+n,1); add(j+n+n+n,i+n,0);
			}
		}
	}
       
}
bool check(int mid){
	rebuild(mid);
	return Dinic()==mid*n;
}
int main(){
	n=read(),k=read();
	s=0,t=4*n+1;
	for(register int i=1;i<=n;i++){
		for(register int j=1;j<=n;j++){
			cin>>choice[i][j];
		}
	}
	int l=0,r=n,mid,ans=0;
	while(l<=r){
		mid=(l+r)>>1;
		if(check(mid)) l=mid+1,ans=mid;
		else r=mid-1;
	}
	printf("%d",ans);
	return 0;
}
```

---

## 作者：FutaRimeWoawaSete (赞：0)

~~我又是冲着网络流来的~~    

首先梳理一下这道题，对这道题有了个印象：给了你一些限制然后让你求一个什么东西的最大值。    

欸，感觉是最大流。    

接着就开始梳理条件，也就是两条：    

- 两两之间只能跳一次
- 每人最多和不喜欢的人跳 $k$ 次    

照着最大流画葫芦，先糊了个最大流图的样子试着求了一下最大流发现这玩意儿和答案没有任何关系啊……又想了想发现我们其实求的是一个流的最少的人最多可以流多少，现在却只能找到所有人最多可以流多少……    

有亿点懵，开始思考这个最大流的值可能会和我们的答案有什么关系，发现了答案的单调性，脑子里瞬间就想到了二分答案，而我们判断当前答案是否合法也就是判当前是否能跳 $ans$ 支舞的话，我们直接建一个 $S$ ，向每个男生连一条容量 $ans$ 的边，如果最后还能满流，这不就好了吗？对于女生就直接向 $T$ 连也就是如果此时 $ans \times n = F$ ，刚好也和最大流的值挂上了勾！    

找到了比较正确的思路，接着就是思考比较棘手的流量限制，首先满流的情况不能动，那么我们还要有一个 $k$ 次的限制的话，就只能拆成喜欢和不喜欢两种点了，原本连向 $S$ 和 $T$ 的边就接到喜欢点上面，而对于每个男女生而言，都由喜欢点向不喜欢点连一个容量为 $k$ 的点，这样就保证了我们没改变满流情况并且限制了 $k$ 。

对于男女之间的连边，如果两人互相~~爱慕~~，就直接将男生代表着喜欢的点向女生代表着喜欢的点连一条容量为 $1$ 的边；相反，就将男生代表着不喜欢的点向女生连一条容量为 $1$ 的边。     

然后就是实现的一些细节问题，注意一下清空数组和建边别写错……    

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<queue>
using namespace std;
const int Len = 50 * 50 * 5 + 5,Inf = 1e9;
int n,k,head[Len],cnt = 1,cur[Len],s,t,N,Ans,dep[Len],ans;
struct node
{
	int next,to,w;
}edge[Len << 1];
void add(int from,int to,int w)
{
	edge[++ cnt].to = to;
	edge[cnt].next = head[from];
	edge[cnt].w = w;
	head[from] = cnt;
}
int BFS()
{
	queue<int> q;
	memset(dep , 0 , sizeof dep);
	q.push(s);dep[s] = 1;cur[s] = head[s];
	while(!q.empty())
	{
		int p = q.front() ; q.pop();
		for(int e = head[p] ; e ; e = edge[e].next)
		{
			int to = edge[e].to;
			if(!dep[to] && edge[e].w)
			{
				dep[to] = dep[p] + 1;
				cur[to] = head[to];
				if(to == t) return dep[to];
				q.push(to);
			}
		}
	}
	return 0;
}
int dfs(int u,int In)
{
	if(u == t) return In;
	int Out = 0;
	for(int e = cur[u] ; e ; e = edge[e].next)
	{
		int to = edge[e].to;
		if(edge[e].w && dep[to] == dep[u] + 1)
		{
			int res = dfs(to , min(In , edge[e].w));
			In -= res;
			Out += res;
			edge[e].w -= res;
			edge[e ^ 1].w += res;
		}
	}
	return (!Out) ? dep[u] = 0 : Out;
}
char ss[55][55];
int Lclone(int x){return (x << 1) - 1;}
int Dclone(int x){return x << 1;}
bool check(int res)
{
	memset(head , 0 , sizeof head) ; cnt = 1;
	ans = 0;
	int num = n << 1;
	for(int i = 1 ; i <= n ; i ++) 
	{
		add(s , Lclone(i) , res) , add(Lclone(i) , s , 0);//s -> i : res
		add(Lclone(i) , Dclone(i) , k) , add(Dclone(i) , Lclone(i) , 0);//Like -> Dislike: k
	}
	for(int i = 1 ; i <= n ; i ++)
	{
		add(num + Lclone(i) , t , res) , add(t , num + Lclone(i) , 0);//num + Lclone(i) -> t : res
		add(num + Dclone(i) , num + Lclone(i) , k) , add(num + Lclone(i) , num + Dclone(i) , 0);
	}
	for(int i = 1 ; i <= n ; i ++)
		for(int j = 1 ; j <= n ; j ++)
		{
			if(ss[i][j] == 'Y') add(Lclone(i) , num + Lclone(j) , 1) , add(num + Lclone(j) , Lclone(i) , 0);
			else add(Dclone(i) , num + Dclone(j) , 1) , add(num + Dclone(j) , Dclone(i) , 0); 
		}
	while(BFS()) ans += dfs(s , Inf);
	if(ans == res * n) return true;
	return false;
}
int main()
{
	scanf("%d %d",&n,&k);
	s = 0 , t = (n << 2) + 1;
	for(int i = 1 ; i <= n ; i ++) scanf("%s",ss[i] + 1);
	int l = 0 , r = n;
	while(l <= r)
	{
		int mid = (l + r) >> 1;
		if(check(mid)) l = mid + 1 , Ans = mid;
		else r = mid - 1;
	}
	printf("%d\n",Ans);
	return 0;
}
```

---

## 作者：破壁人 (赞：0)

分析：

首先我们发现直接求答案并不容易，我们可以考虑二分答案。

那么对于答案m，如何判断是否可行呢？用网络流。

我们用Ai表示第i个男生，Bi表示第i个女生。

然后，我们把每个男生和女生都复制一遍，Ai复制为ai,Bi复制为bi。

如果Ai和Bj相互喜欢，则Ai向Bi连一条容量为1的边

如果Ai和Bj不相互喜欢，则ai向bi连一条容量为1的边

然后Ai向ai连一条容量为k的边，bi向Bi连一条容量为k的边。

这样就可以表示最多只愿意和不喜欢的人跳k次舞。

接着，建立源点s汇点t，s向A连容量为m的边，B向t连容量为m的边。

那么，跑最大流之后的残余网络中，s向A的n条边全为0的话就表示答案可行，否则就不可行。

代码：
```cpp
#include<iostream>
#include<cstring>
#include<cstdio>

using namespace std;

int e[1001],d[1001],f[1001],x;
int n,k,a[1001][1001],b[1001][1001];

bool check(int o)
{
    for(int i=1;i<=4*n+1;i++)
        for(int j=1;j<=4*n+1;j++) a[i][j]=b[i][j];   
    for(int i=1;i<=n;i++) a[0][i]=a[i+2*n][1+4*n]=o;
    memset(e,0,sizeof(e));
    memset(d,0,sizeof(d));
    memset(f,0,sizeof(f));
    f[0]=4*n+2;
    x=0;
    e[0]=0;
    while(d[0]<4*n+2)
    {
        bool bo=false;
        for(int i=0;i<=4*n+1;i++)
            if((a[x][i]>0)&&(d[i]+1==d[x]))
            {
                e[i]=x;
                x=i;
                bo=true;
                break;
            }
        if(bo)
        {
            if(x==1+4*n)
            {
                int mi=1e9;
                while(x!=0)
                {
                    mi=min(mi,a[e[x]][x]);
                    x=e[x];
                }
                x=4*n+1;
                while(x!=0)
                {
                    a[e[x]][x]-=mi;
                    a[x][e[x]]+=mi;
                    x=e[x];
                }
            }
            continue;
        }
        int mi=4*n+1;
        for(int i=0;i<=4*n+1;i++)
            if(a[x][i]) mi=min(mi,d[i]);
        f[d[x]]--;
        if(f[d[x]]==0) break;
        d[x]=mi+1;
        f[d[x]]++;
        x=e[x];
    }
    for(int i=1;i<=n;i++)
        if(a[0][i]!=0) return false;
    return true;
}

int main()
{
    scanf("%d%d",&n,&k);
    memset(a,0,sizeof(a));
    for(int i=1;i<=n;i++)
    {
        b[i][i+n]=b[i+3*n][i+2*n]=k;
        char ch[100];
        scanf("%s",ch);
        for(int j=1;j<=n;j++)
            if(ch[j-1]=='Y') 
                b[i][j+2*n]=1;else b[i+n][j+3*n]=1;
    }
    int l=0,r=n;
    while(l<r)
    {
        int mid=(l+r+1)/2;
        if(check(mid)) l=mid;else r=mid-1;
    }
    cout<<l<<endl;
    return 0;
}
```

---

## 作者：winmt (赞：0)

垃圾网络流1A，怎么能没有题解？

**增加超级源汇+分裂点+最大流+二分**。

###分析：

**男，女各分裂成喜欢yes和不喜欢no两个点**

若男女是cp，则每个男yes-->每个女yes 容量1

若男女不是cp，则每个男no-->每个女no 容量1

**控制：每个男孩都不会和同一个女孩跳两首（或更多）舞曲。**

每个男yes-->自己no 容量k

每个女no-->自己yes 容量k

**控制：每个男孩最多只愿意和k个不喜欢的女孩跳舞，而每个女孩也最多只愿意和k个不喜欢的男孩跳舞。**

最后二分x（暴力枚举ok，数据弱爆了！）

S--->每个男yes 容量x

每个女yes--->T 容量x

若最大流==x\*人数（即满流） 则成立。

**控制：每首曲子开始时，所有男孩和女孩恰好配成n对跳交谊舞。**

\_【ISAP】\_


 
 
 
 
 
 
 
 
     
     
```cpp
#include<iostream>
#include<fstream>
#include<cstdio>
#include<algorithm>
#include<string>
#include<vector>
#include<queue>
#include<deque>
#include<utility>
#include<map>
#include<set>
#include<cmath>
#include<cstdlib>
#include<ctime>
#include<functional>
#include<sstream>
#include<cstring>
#include<bitset>
#include<stack>
using namespace std;
int n,m,s,t,cnt,x,y,z,k,ans;
char ss[55][55];
struct sdt
{
    int cap,flow,u,v;
}e[200005];
int nxt[200005],fir[10005],d[10005],par[10005],num[10005],cur[10005];
bool vis[10005];
int read()
{
    int x=0;char c=getchar();
    while(c<48||c>57)c=getchar();
    while(c>47&&c<58)x*=10,x+=c-48,c=getchar();
    return x;
}
void add(int u,int v,int cp,int fl)
{
    e[++cnt].u=u;e[cnt].v=v;e[cnt].cap=cp;e[cnt].flow=fl;
    nxt[cnt]=fir[u];fir[u]=cnt;
}
void bfs()
{
    memset(vis,0,sizeof(vis));
    memset(d,0,sizeof(d));
    queue<int>q;
    d[t]=0;
    vis[t]=1;
    q.push(t);
    while(!q.empty())
    {
        int k=q.front();
        q.pop();
        for(int i=fir[k];i;i=nxt[i])
        {
            if(!vis[e[i].v] && e[i].cap==0)
            {
                vis[e[i].v]=1;
                d[e[i].v]=d[k]+1;
                q.push(e[i].v);
            }
        }
    }
}
int agument()
{
    int p=t;
    int ans=2147483647;
    while(p!=s)
    {
        ans=min(ans,e[par[p]].cap-e[par[p]].flow);
        p=e[par[p]].u;
    }
    p=t;
    while(p!=s)
    {
        e[par[p]].flow+=ans;
        e[par[p]^1].flow-=ans;
        p=e[par[p]].u;
    }
    return ans;
}
int isap()
{
    memset(num,0,sizeof(num));
    int flow=0;
    for(int i=1;i<=n;i++)
    {
        num[d[i]]++;
        cur[i]=fir[i];
    }
    int p=s;
    while(d[s]<n)
    {
        if(p==t)
        {
            flow+=agument();
            p=s;
        }
        bool ok=0;
        for(int i=cur[p];i;i=nxt[i])
        {
            if(e[i].cap>e[i].flow && d[p]==d[e[i].v]+1)
            { 
                ok=1; 
                par[e[i].v]=i; 
                cur[p]=i; 
                p=e[i].v; 
                break; 
            } 
        }
        if(!ok)
        {
            int mn=n-1;
            for(int i=fir[p];i;i=nxt[i])
            {
                if(e[i].cap>e[i].flow)mn=min(mn,d[e[i].v]);
            }
            if(--num[d[p]]==0)break;
            num[d[p]=mn+1]++;
            cur[p]=fir[p];
            if(p!=s)p=e[par[p]].u;
        }
    }
    return flow;
}
void build(int yhy)
{
    memset(nxt,0,sizeof(nxt));
    memset(fir,0,sizeof(fir));
    cnt=1;
    for(int i=1;i<=m;i++)
    {
        add(1,1+i,yhy,0);
        add(1+i,1,0,0);
        add(1+2*m+i,t,yhy,0);
        add(t,1+2*m+i,0,0);
        for(int j=0;j<m;j++)
        {
            if(ss[i][j]=='Y')
            {
                add(1+i,1+2*m+j+1,1,0);
                add(1+2*m+j+1,i+1,0,0);
            }
            else
            {
                add(1+m+i,1+3*m+j+1,1,0);
                add(1+3*m+j+1,1+i+m,0,0);
            }
        }
        add(1+i,1+m+i,k,0);
        add(1+m+i,1+i,0,0);
        add(1+3*m+i,1+2*m+i,k,0);
        add(1+2*m+i,1+3*m+i,0,0);
    }
}
int main()
{
    m=read();
    k=read();
    n=2+4*m;
    s=1;
    t=2+4*m;
    for(int i=1;i<=m;i++)
    {
        for(int j=0;j<m;j++)
        {
            cin>>ss[i][j];
        }
    }
    int l=0,r=m;
    while(l<=r)
    {
        int mid=(l+r)/2;
        build(mid);
        bfs();
        if(isap()==mid*m)
        {
            l=mid+1;
            ans=mid;
        }
        else
        {
            r=mid-1;
        }
    }
    printf("%d\n",ans);
    return 0;
}
```

---


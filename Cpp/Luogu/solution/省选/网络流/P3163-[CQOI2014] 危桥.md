# [CQOI2014] 危桥

## 题目描述

Alice 和 Bob 居住在一个由 $N$ 座岛屿组成的国家，岛屿被编号为 $0$ 到 $N-1$。某些岛屿之间有桥相连，桥上的道路是双向的，但一次只能供一人通行。其中一些桥由于年久失修成为危桥，最多只能通行两次。

Alice 希望在岛屿 $a_1$ 和 $a_2$ 之间往返 $a_n$ 次（从 $a1$ 到 $a2$ 再从 $a2$ 到 $a1$ 算一次往返）。同时，Bob 希望在岛屿 $b_1$ 和 $b_2$ 之间往返 $b_n$ 次。这个过程中，所有危桥最多通行两次，其余的桥可以无限次通行。请问 Alice 和 Bob 能完成他们的愿望吗？


## 说明/提示

对于所有数据，$4 \leq N\leq 50,\ 0 \leq a_1, a_2, b_1, b_2 \leq N-1,\ 1 \leq a_n, b_n \leq 50$。

## 样例 #1

### 输入

```
4 0 1 1 2 3 1
XOXX
OXOX
XOXO
XXOX
4 0 2 1 1 3 2
XNXO
NXOX
XOXO
OXOX
```

### 输出

```
Yes
No
```

# 题解

## 作者：SovietPower✨ (赞：97)

这种题大多是多源多汇跑网络流。往返$a_n/b_n$次可以看做去$a_n/b_n$次，直接把危桥能走的次数看做$1$。

先不考虑别的，直接按原图建模：危桥建双向边容量为$1$，普通桥容量为$INF$；然后源点$S$向$a_1,b_1$分别连容量$a_n,b_n$的边，$a_2,b_2$分别向汇点$T$连容量$a_n/b_n$的边。

这样跑出来的最大流会有两个问题（好多题解都没提问题二？）：

一是，$b_2\to T$的$b_n$的一部分流量可能是来自$a_1$的，同理$a_2\to T$的一些流量可能来自$b_1$。

二是，危桥只能走一次，但这样可能会正反走两次。

也就是不能直接判断是否满流来判断是否可行。办法是，交换$b_1,b_2$（$S$连$b_2$，$b_1$连$T$），重新建图，再跑最大流。只有两次均满流才一定存在可行方案。

交换$b_1,b_2$后再判断是否满流，如果你觉得问题一显然已经被解决了可以跳过下面这段。

> 如果满流且仍然存在问题一那种情况呢？画个图。

> 假设第一次跑最大流，$a_1\to b_2$的流量为$x$，那么$b_1\to b_2$的流量为$b_n-x$，$b_1\to a_2$的流量也是$x$，$a_1\to a_2$的流量是$a_n-x$。

> 而第二次跑最大流，因为是无向图，$a_1\to a_2$和$b_2\to b_1$的流量可以不变，还是$a_n-x,b_n-x$。那么$a_1\to b_2$和$b_2\to a_1$的流量也都还是$x$。

> 而这两次说明了什么呢，$a_1$可以流到$b_1$ $x$流量，还可以流到$b_2$ $x$流量，同时不影响$a_1$与$a_2$，$b_1$与$b_2$之间的流量。因为是无向图，将$a_1\to b_1$的流量反向，就可以得到$b_1\to b_2$ $x$的流量。$b_1,b_2$之间的流就合法了。

> 同理$a_1,a_2$之间的流也合法。

> 所以如果交换$b_1,b_2$后仍满流，一定不存在问题一那种情况。

对于问题二，~~好多题解都没有写也许是太显然了？~~

> 假如$a_1\to a_2$正向经过了一座危桥，而$b_1\to b_2$反向经过了这座桥，那么交换$b_1,b_2$，以$b_2$为起点后，$a_1\to a_2,b_2\to b_1$两条路径都是正向通过了这条边，就受到了流量的限制。

> 所以如果仍满流，不存在问题二。

所以两遍最大流就可以了。

代码就不需要放了。。

---

## 作者：UltiMadow (赞：50)

update on 2024.6.10: 把剪切板的内容搬到了正文中。

先来一个结论：

首先建出给定的网络流图，危桥容量为 2，其他容量为 $+\infty$，然后建出超级源点 $s,t$；

接着连 $s\to a_1$，容量为 $2\times a_n$；连 $s\to b_1$，容量为 $2\times b_n$；连 $a_2\to t$，容量为 $2\times a_n$；连 $b_2\to t$，容量为 $2\times b_n$，并跑一遍最大流；

接下来连 $s\to a_1$，容量为 $2\times a_n$；连 $s\to b_2$，容量为 $2\times b_n$；连 $a_2\to t$，容量为 $2\times a_n$；连 $b_1\to t$，容量为 $2\times b_n$，并跑一遍最大流；

若这两遍最大流跑出来的结果均为 $2\times(a_n+b_n)$ 则结果为 ```Yes```，否则为 ```No```。

证明如下：

对于网络流来说，对于每条边有一个不等式，对于每个点有一个流量平衡的方程。

我们记 $f_A(u,v)$ 为 $A$ 走 $u\to v$ 这条边多少次；$f_B(u,v)$ 为 $B$ 走 $u\to v$ 这条边多少次，根据网络流的思想，有 $f(u,v)=-f(v,u)$。

有不等式：
$$
|f_A(u,v)|+|f_B(u,v)|\le C(u,v)\\
\Leftrightarrow \begin {cases}
f_A(u,v)+f_B(u,v)\le C(u,v)\\
f_A(u,v)-f_B(u,v)\le C(u,v)\\
-f_A(u,v)+f_B(u,v)\le C(u,v)\\
-f_A(u,v)-f_B(u,v)\le C(u,v)
\end {cases}\\
\Leftrightarrow \begin {cases}
f_A(u,v)+f_B(u,v)\le C(u,v)\\
f_A(u,v)-f_B(u,v)\le C(u,v)\\
f_A(v,u)+f_B(v,u)\le C(u,v)\\
f_A(v,u)-f_B(v,u)\le C(u,v)
\end {cases}\\
\Leftrightarrow \begin {cases}
f_A(u,v)+f_b(u,v)\le C(u,v)\\
f_A(u,v)-f_b(u,v)\le C(u,v)\\
\end {cases}\\
$$
令 $f_1=f_A+f_B,f_2=f_A-f_B$，
$$
\text{原式}\Leftrightarrow\begin{cases}
f_1(u,v)\le C(u,v)\\
f_2(u,v)\le C(u,v)
\end{cases}
$$
等式：
$$
\begin{cases}
\sum_v f_B(a_1,v)=0\\
\sum_v f_A(a_1,v)=2\times a_n\\
\sum_v f_B(v,a_2)=0\\
\sum_v f_A(v,a_2)=2\times a_n\\
\sum_v f_B(b_1,v)=2\times b_n\\
\sum_v f_A(b_1,v)=0\\
\sum_v f_B(v,b_1)=2\times b_n\\
\sum_v f_A(v,b_1)=0\\
\end{cases}\\
\Leftrightarrow
\begin{cases}
\sum_v f_1(a_1,v)=2\times a_n\\
\sum_v f_2(a_1,v)=2\times a_n\\
\sum_v f_1(v,a_2)=2\times a_n\\
\sum_v f_2(v,a_2)=2\times a_n\\
\sum_v f_1(b_1,v)=2\times b_n\\
\sum_v f_2(b_1,v)=-2\times b_n\\
\sum_v f_1(v,b_2)=2\times b_n\\
\sum_v f_2(v,b_2)=-2\times b_n\\
\end{cases}\\
\Leftrightarrow
\begin{cases}
\sum_v f_1(a_1,v)=2\times a_n\\
\sum_v f_2(a_1,v)=2\times a_n\\
\sum_v f_1(v,a_2)=2\times a_n\\
\sum_v f_2(v,a_2)=2\times a_n\\
\sum_v f_1(b_1,v)=2\times b_n\\
\sum_v f_2(v,b_1)=2\times b_n\\
\sum_v f_1(v,b_2)=2\times b_n\\
\sum_v f_2(b_2,v)=2\times b_n\\
\end{cases}\\
$$
接下来：

$$
\begin{cases}
f_1=f_A+f_B\\
f_2=f_A-f_B
\end{cases}\\
\Leftrightarrow
\begin{cases}
f_A=\frac{f_1+f_2}2\\
f_B=\frac{f_1-f_2}2
\end{cases}\\
$$
于是能解出 $f_1,f_2$ 就能一一对应地求出 $f_A,f_B$。

发现 $f_1$ 即为第一遍网络流的结果，$f_2$ 即为第二遍网络流的结果，于是跑两遍上述网络流即可。

接下来，我们又得到了几个结论：

1. 这题不可以扩展到有向图上，因为扩展到有向图上之后第一步的不等式转化并不成立；
2. 这题不可以扩展到多于两个「小朋友」，因为找不到 $f_A,f_B$ 与 $f_1,f_2$ 这种变换了；
3. 这题不可以扩展到一条「危桥」能走奇数次，因为这样解出来的 $f_1,f_2$ 可能不为整数。

code:
```cpp
#include<bits/stdc++.h>
#define MAXN 1010
#define inf 0x3f3f3f3f
using namespace std;
int n;
int sa,ta,an,sb,tb,bn;
struct Node{int to,nxt,flow;}Edge[MAXN<<4],sav[MAXN<<4];
int Head[MAXN],cnt_Edge;
int head[MAXN],cnt_edge;
void add(int u,int v,int w){
	sav[++cnt_edge]=(Node){v,head[u],w};
	head[u]=cnt_edge;
}
void add_edge(int u,int v,int w){add(u,v,w);add(v,u,0);}
void Add(int u,int v,int w){
	Edge[++cnt_Edge]=(Node){v,Head[u],w};
	Head[u]=cnt_Edge;
}
void Add_Edge(int u,int v,int w){Add(u,v,w);Add(v,u,0);}
int nhe[MAXN<<1],dep[MAXN<<1];
int q[MAXN<<2];
bool bfs(int s,int t){
	int l=1,r=1;q[1]=s;
	memset(dep,0,sizeof(dep));
	memcpy(nhe,Head,sizeof(nhe));
	dep[s]=1;
	while(l<=r){
		int u=q[l++];
		for(int i=Head[u];i;i=Edge[i].nxt){
			int v=Edge[i].to,w=Edge[i].flow;
			if(!w||dep[v])continue;
			dep[v]=dep[u]+1;q[++r]=v;
			if(v==t)return true;
		}
	}return false;
}
int dfs(int u,int t,int flow){
	int rest=flow;if(u==t)return flow;
	for(int i=nhe[u];i&&rest;i=Edge[i].nxt){
		int v=Edge[i].to,w=Edge[i].flow;nhe[u]=i;
		if(!w||dep[v]!=dep[u]+1)continue;
		int now=dfs(v,t,min(rest,w));
		if(!now)dep[v]=-1;
		Edge[i].flow-=now;Edge[i^1].flow+=now;
		rest-=now;
	}return flow-rest;
}
int dinic(int s,int t){
	int ret=0;
	while(bfs(s,t)){
		int flow;
		while((flow=dfs(s,t,inf)))
			ret+=flow;
	}return ret;
}
char c[MAXN];
int main(){
	while(scanf("%d%d%d%d%d%d%d",&n,&sa,&ta,&an,&sb,&tb,&bn)!=EOF){
		sa++;ta++;sb++;tb++;cnt_edge=1;
		for(int i=1;i<=n;i++){
			scanf("%s",c+1);
			for(int j=1;j<=n;j++){
				if(c[j]=='O')add_edge(i,j,2);
				if(c[j]=='N')add_edge(i,j,inf);
			}
		}
		memcpy(Head,head,sizeof(Head));cnt_Edge=cnt_edge;
		for(int i=2;i<=cnt_edge;i++)Edge[i]=sav[i];
		int s=n+1,t=n+2;
		Add_Edge(s,sa,2*an);Add_Edge(s,sb,2*bn);
		Add_Edge(ta,t,2*an);Add_Edge(tb,t,2*bn);
		int now=dinic(s,t);bool ans=false;
		if(now==2*(an+bn))ans=true;
		memcpy(Head,head,sizeof(Head));cnt_Edge=cnt_edge;
		for(int i=2;i<=cnt_edge;i++)Edge[i]=sav[i];
		Add_Edge(s,sa,2*an);Add_Edge(s,tb,2*bn);
		Add_Edge(ta,t,2*an);Add_Edge(sb,t,2*bn);
		now=dinic(s,t);bool ans2=false;
		if(now==2*(an+bn))ans2=true;
		ans=(ans&&ans2);
		printf("%s\n",ans?"Yes":"No");
		memset(Head,0,sizeof(Head));memset(head,0,sizeof(head));
		for(int i=2;i<=cnt_Edge;i++)sav[i]=(Node){0,0,0};
		for(int i=2;i<=cnt_Edge;i++)Edge[i]=(Node){0,0,0};
		cnt_Edge=cnt_edge=1;
	}
	return 0;
}
```

---

## 作者：xyz32768 (赞：9)

很容易想到建图方案。也就是说，对于图上的任意一条边，如果有普通的桥相连，那么建一条容量为$\infty$的边，否则是危桥，建一条容量为$2$的边。然后把往返$an$次和$bn$次看成走$2*an$次和$2*bn$次，由源点向$a1$和$b1$连容量分别为$2*an$和$2*bn$的边，再由$a2$和$b2$向汇点连容量分别为$2*an$和$2*bn$的边，判断最大流是否等于$2(an+bn)$。

注意坑点：从$a1$发出的流量有可能跑到$b2$处。所以还要再建一遍图，源点向$a1,b2$建边，$a2,b1$向汇点建边，如果两次最大流**都等于**$2(an+bn)$，那么有解。否则无解。

代码：

```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
inline int read() {
    int res = 0; bool bo = 0; char c;
    while (((c = getchar()) < '0' || c > '9') && c != '-');
    if (c == '-') bo = 1; else res = c - 48;
    while ((c = getchar()) >= '0' && c <= '9')
        res = (res << 3) + (res << 1) + (c - 48);
    return bo ? ~res + 1 : res;
}
inline char get() {
    char c; while ((c = getchar()) != 'X' && c != 'O' && c != 'N');
    return c;
}
const int N = 2e4 + 5, M = 55, INF = 0x3f3f3f3f;
int n, A1, A2, An, B1, B2, Bn, ecnt, nxt[N], adj[N], go[N], cap[N],
S, T, len, que[N], lev[N];
char s[M][M];
void add_edge(int u, int v, int w) {
    nxt[++ecnt] = adj[u]; adj[u] = ecnt; go[ecnt] = v; cap[ecnt] = w;
    nxt[++ecnt] = adj[v]; adj[v] = ecnt; go[ecnt] = u; cap[ecnt] = 0;
}
bool bfs() {
    int i; memset(lev, -1, sizeof(lev));
    lev[que[len = 1] = S] = 0;
    for (i = 1; i <= len; i++) {
        int u = que[i];
        for (int e = adj[u], v; e; e = nxt[e])
            if (cap[e] > 0 && lev[v = go[e]] == -1) {
                lev[que[++len] = v] = lev[u] + 1;
                if (v == T) return 1;
            }
    }
    return 0;
}
int dinic(int u, int flow) {
    if (u == T) return flow;
    int res = 0, delta;
    for (int e = adj[u], v; e; e = nxt[e])
        if (cap[e] > 0 && lev[u] < lev[v = go[e]]) {
            delta = dinic(v, min(cap[e], flow - res));
            if (delta) {
                cap[e] -= delta; cap[e ^ 1] += delta;
                res += delta; if (res == flow) break;
            }
        }
    if (res != flow) lev[u] = -1;
    return res;
}
int solve() {
    int ans = 0;
    while (bfs()) ans += dinic(S, INF);
    return ans;
}
void work() {
    int i, j, res1, res2;
    A1 = read() + 2; A2 = read() + 2; An = read();
    B1 = read() + 2; B2 = read() + 2; Bn = read();
    for (i = 1; i <= n; i++) for (j = 1; j <= n; j++)
        s[i][j] = get(); S = 1; T = n + 2;
    ecnt = 1; memset(adj, 0, sizeof(adj));
    for (i = 1; i <= n; i++) for (j = 1; j <= n; j++) {
        if (i == j) continue;
        if (s[i][j] == 'O') add_edge(i + 1, j + 1, 2);
        else if (s[i][j] == 'N') add_edge(j + 1, i + 1, INF);
    }
    add_edge(S, A1, An << 1); add_edge(S, B1, Bn << 1);
    add_edge(A2, T, An << 1); add_edge(B2, T, Bn << 1);
    res1 = solve();
    ecnt = 1; memset(adj, 0, sizeof(adj));
    for (i = 1; i <= n; i++) for (j = 1; j <= n; j++) {
        if (i == j) continue;
        if (s[i][j] == 'O') add_edge(i + 1, j + 1, 2);
        else if (s[i][j] == 'N') add_edge(j + 1, i + 1, INF);
    }
    add_edge(S, A1, An << 1); add_edge(S, B2, Bn << 1);
    add_edge(A2, T, An << 1); add_edge(B1, T, Bn << 1);
    res2 = solve();
    puts(res1 == (An + Bn << 1) && res2 == (An + Bn << 1) ? "Yes" : "No");
}
int main() {
    while (~scanf("%d", &n)) work();
    return 0;
}
```

---

## 作者：TheAutumnGlory (赞：8)

~~调了半天TLE，发现初始化的位置有问题。（自闭）~~

### 题意:
给你一个无向图，其中有一些岛屿间有桥，有一些没有，然后桥又有一些是危桥，只能走两次。 ~~（危桥难道不应该只能走一次吗）~~ 

然后 $Alice$ 和 $Bob$ ~~两个拆桥大队队员来了~~ ，$Alice$希望在$a_1$和$a_2$两个岛屿之间往返$a_n$次，$Bob$希望在$b_1$和$b_2$两个岛屿之间往返$b_n$次，问两个人的希望能不能成功。 ~~（可是希望多半要落空,Alice 和 Bob的也不例外...）~~

### 分析：
题目让我们判断是否这个图能完成$Alice$ 和 $Bob$的愿望是否能成功。

往返$a_n$次相当于从$a_1$~$a_2$走$2 \times a_n$次，$b_n$同理。

然后我们就可以明了，为什么会有危桥允许走两次~~的奇葩设定~~了。

于是我们就可以看成从$a_1$ ~ $a_2$ 走$ a_n$次，$b_n$同理，且危桥只能走一次。

然后我们就可以建出一个图，发现从$a_1$ ~ $a_2$ 走 $a_n$ 次相当于从$a_1$ ~$a_2$的最大流，且流量不能小于$a_n$，$b_n$依然同理。

到这里难道这道题就$A$了吗？？？

**有可能会出现一些流量在$a_1$，$b_2$间往返，一些在$b_1$,$a_2$中往返，总之瞎 流。**

于是我们可以交换$b_1$，$b_2$（$a_1$,$a_2$也可以）再跑一次最大流，如果最大流也不小于$a_n$,$b_n$即可行。

**那么会不会出现两次都在瞎流呢？？？**

拿$nodgd$的话来讲：**如果两次都在瞎流，那么一定能在图中找到一个不在瞎流且合法的流。**

### 注意：

- 这道题是从$0$~$n-1$编号，所以需要$a_1,a_2,b_1,b_2+1$
- 有多组数据，不要忘了初始化
- 注意输出是"Yes"而不是"YES" ~~(可能只有我一个人犯了这样的错）~~
- 为了方便，我们可以将源点到$a_1,b_1$ 汇点到$a_2$,$b_2$的边权设为$a_n$,$b_n$这样保证最大流不会超过$a_n,b_n$最后只需要判断是否$flow$是否等于$a_n+b_n$
- 此图是**无向图**

$code(isap):$
```
#include<bits/stdc++.h>
using namespace std;
const int inf=1e9;
const int N=20005;
const int M=100005;
char ma[105][105];
int n,a1,a2,an,b1,b2,bn,S,T;
int Next[M],End[M],len[M],tot;
int Last[N],_last[N],gap[N],dis[N];
inline void cb(int x,int y,int z){
    End[tot]=y,Next[tot]=Last[x],len[tot]=z,Last[x]=tot++;
    End[tot]=x,Next[tot]=Last[y],len[tot]=z,Last[y]=tot++;
}
void bfs(){
    for(int i=1;i<=T;i++) dis[i]=T,gap[i]=0,_last[i]=Last[i];
    gap[0]=dis[T]=0;
    queue<int> q;
    q.push(T);
    while(q.size()){
        int x=q.front();
        q.pop();
        for(int i=Last[x];i;i=Next[i]){
            int y=End[i];
            if(dis[y]>dis[x]+1){
                dis[y]=dis[x]+1;
                q.push(y);
            }
        }
    }
    for(int i=1;i<=T;i++) gap[dis[i]]++;
    return;
}
int isap(int x,int flow){
    if(x==T) return flow;
    int flow_now=0;
    for(int &i=_last[x];i;i=Next[i]){
        int y=End[i];
        if(len[i] && dis[x]==dis[y]+1){
            int f=isap(y,min(len[i],flow-flow_now));
            flow_now+=f;
            len[i]-=f;
            len[i^1]+=f;
            if(flow==flow_now || dis[S]==T) return flow_now;
        }
    }
    gap[dis[x]]--;
    if(!gap[dis[x]]) dis[S]=T;
    dis[x]++;
    gap[dis[x]]++;
    _last[x]=Last[x];
    return flow_now;
}
void _main(){
    a1++,a2++,b1++,b2++;
    S=n*n+1,T=S+1,tot=2;
    for(int i=1;i<=n;i++)
        scanf("%s",ma[i]+1);
    for(int i=1;i<=n;i++){
        for(int j=i+1;j<=n;j++){
            if(ma[i][j]=='O') cb(i,j,1);
            else if(ma[i][j]=='N') cb(i,j,inf);
        }
    }
    //建立源点，汇点的限制流量(边权)
    cb(S,a1,an),cb(a2,T,an);
    cb(S,b1,bn),cb(b2,T,bn);
    int flow=0;
    bfs();
    while(dis[S]<T) flow+=isap(S,inf);
    memset(Last,0,sizeof(Last));
    if(flow!=an+bn){
        puts("No");
        return;
    }
    tot=2;
    for(int i=1;i<=n;i++){
        for(int j=i+1;j<=n;j++){
            if(ma[i][j]=='O') cb(i,j,1);
            else if(ma[i][j]=='N') cb(i,j,inf);
        }
    }
    cb(S,a1,an),cb(a2,T,an);
    cb(S,b2,bn),cb(b1,T,bn);
    bfs();
    while(dis[S]<T) flow-=isap(S,inf);
    if(flow!=0) puts("No");
    else puts("Yes");
    memset(Last,0,sizeof(Last));
    return;
}
int main(){
    while(scanf("%d%d%d%d%d%d%d",&n,&a1,&a2,&an,&b1,&b2,&bn)!=EOF) _main();
    return 0;
}
```

---

## 作者：SDNetFriend (赞：6)

​	

这个题还蛮有意思的，总结下来就是个最大流的变形。  
最大流很好分析，因为是往返，在无向图里面，危桥可以跑两次，那么就把危桥作为最大流量为1的边，建边跑最大流，如果满流了说明可行 。  
似乎这样就结束了。

#### 但这个题重点在于可能会出现这种情况

![](https://cdn.luogu.com.cn/upload/image_hosting/0nlcpfzx.png)

这样显然仍然会跑出满流，但实际上并不是我们想要的情况，所以考虑解决办法。  
这里我们就可以重新建图，新的图让S连接 b2，T连接 b1。    

证明过程如下（大概）

我们定$f(a,b)$为 a 到 b 的流量，因为无向图，所以也是b到a的流量。  

首先如果出现了如图所示的情况，说明
$$
f(a1,b2)=f(b1,a2)>0
$$
但实际上我们希望的情况是
$$
f(a1,a2)=an\space f(b1,b2)=bn
$$
也就是说，正向建图和反向建图，两个对应汇点（第一次的 a2b2 和第二次的 a2b1）的流量应该分别为

$$
f(a1,a2)+f(b1,a2)\space f(b1,b2)+f(a1,b2)
$$

$$
f(a1,a2)+f(b2,a2)\space f(b1,b2)+f(a1,b1)
$$

显然如果只有$f(a1,a2)$ $f(b1,b2)$那么就会是我们期望的结果，如果正反向图没对点有一个除了这两项以外的项不存在还能跑到满流就说明是期望的情况。  

#### 剩下我们来考虑正反向图额外项都存在的情况

以 a1 和 a2 点为例，如果额外项均存在，并且能满流，说明 b1 和 b2 都有连向 a1 和 a2 的边，并且这些边最小流量的一对也可以满流。  

那么就说明这实际上是一条 a1->b1 或者 b2->a2 的增广路，就不用过多考虑，大概是下图这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/xjhfw000.png)

（由刚才的结论，黑色和红色的流量各自相等，分别为两次的额外流，如果都跑出了满流那么说明a1到a2只需要利用一条两条路流量最小的那条增广就可以达到满流）

考虑了这些以后，两种情况下发现我们的结论都是成立的。

接下来就放下代码



```cpp
#include <iostream>
#include <algorithm>
#include <cstdio>
#include <cstring>
#include <queue>
using namespace std;
const int MAXN=1005,INF=1000005;
int s=51,t=52;
int n,a1,a2,an,b1,b2,bn,ans=0,sum;
int hed[MAXN],to[MAXN*MAXN*2],nxt[MAX*MAXN*2],w[MAXN*MAXN*2],cnt=1;
int dep[MAXN];
char c[MAXN][MAXN];
queue<int> que;
inline void inst(int x,int y,int _w){
	nxt[++cnt]=hed[x];
	to[cnt]=y;
	w[cnt]=_w;
	hed[x]=cnt;
	nxt[++cnt]=hed[y];
	to[cnt]=x;
	hed[y]=cnt;
	w[cnt]=_w;
}
inline void clear(){
	memset(hed,0,sizeof hed);
	cnt=1;
	ans=0;
}
inline bool BFS(){
	memset(dep,0,sizeof dep);
	dep[s]=1;
	que.push(s);
	while(!que.empty()){
		int u=que.front();
		que.pop();
		for(register int i=hed[u];i;i=nxt[i]){
			int v=to[i];
			if(!w[i]||dep[v])continue;
			dep[v]=dep[u]+1;
			que.push(v);
		}
	}
	return dep[t];
}
int DFS(int u,int in){
	if(u==t||!in)return in;
	int out=0;
	for(register int i=hed[u];i;i=nxt[i]){
		int v=to[i];
		if(!w[i]||dep[v]!=dep[u]+1)continue;
		int res=DFS(v,min(w[i],in));
		w[i]-=res;
		w[i^1]+=res;
		in-=res;
		out+=res;
		if(!in)return out;
	}
	if(!out)dep[u]=0;
	return out;
}
inline void solve(){
	for(register int i=1;i<=n;++i)
		for(register int j=i+1;j<=n;++j){
			if(c[i][j]=='N')
				inst(i,j,INF);
			else if(c[i][j]=='O')
				inst(i,j,1);
		}
	inst(s,a1,an);
	inst(s,b1,bn);
	inst(a2,t,an);
	inst(b2,t,bn);
	while(BFS())
		ans+=DFS(s,INF);
}
int main(){
	while(~scanf("%d%d%d%d%d%d%d",&n,&a1,&a2,&an,&b1,&b2,&bn)){
		++a1;++b1;++a2;++b2;
		for(register int i=1;i<=n;++i)
			for(register int j=1;j<=n;++j)
				cin>>c[i][j];
		sum=0;
		clear();
		solve();
		if(ans==an+bn)++sum;
		clear();
		swap(b1,b2);
		solve();
		if(ans==an+bn)++sum;
		swap(b1,b2);
		if(sum==2)
			printf("Yes\n");
		else
			printf("No\n");
	}
	return 0;
}
```


---

## 作者：Orion545 (赞：6)

# 广告

[蒟蒻のblog](http://www.cnblogs.com/dedicatus545/p/8781597.html)

# 正文

这道题中惟一的特别之处，就在于“危桥”这一个只能走两次的东西

我的第一想法是做一个dp，但是这道题只需要能不能走，也没有必要

网络流？貌似是个很好的选择

我们把所有边作为无向边加入图中，流量上限inf

危桥则作为上限2的无向边

从源点连边到a1b1，汇点连边到a2b2，流量都是2\*an或2\*bn，相当于一次把两遍走了

最后，只要看看最大流不是(2\*an+2\*bn)

然而有个问题，万一我们最终求得的最大流中，是a1流到b2、b1流到a2呢？

此时有一个好办法：我们把源点连边到a1b2，汇点连边到a2b1，如果还能满流，就OK了

具体为什么？自己画图理解一下即可~

# Code

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define inf 1e9
using namespace std;
int n,cnt=-1,first[110],dep[110],cur[110],a1,a2,an,b1,b2,bn;
struct edge{
	int to,next,w;
}a[10010];
inline void add(int u,int v,int w){
	a[++cnt]=(edge){v,first[u],w};first[u]=cnt;
	a[++cnt]=(edge){u,first[v],w};first[v]=cnt;
}
bool bfs(int s,int t){
	int q[110],head=0,tail=1,u,v,i;
	for(i=s;i<=t;i++) dep[i]=-1,cur[i]=first[i];
	q[0]=s;dep[s]=0;
	while(head<tail){
		u=q[head++];
		for(i=first[u];~i;i=a[i].next){
			v=a[i].to;
			if(~dep[v]||!a[i].w) continue;
			dep[v]=dep[u]+1;q[tail++]=v;
		}
	}
	return ~dep[t];
}
int dfs(int u,int t,int limit){
	if(u==t||!limit) return limit;
	int i,v,f,flow=0;
	for(i=first[u];~i;i=a[i].next){
		v=a[i].to;
		if(dep[v]==dep[u]+1&&(f=dfs(v,t,min(limit,a[i].w)))){
			a[i].w-=f;a[i^1].w+=f;
			flow+=f;limit-=f;
			if(!limit) return flow;
		}
	}
	return flow;
}
int dinic(int s,int t){
	int re=0;
	while(bfs(s,t)) re+=dfs(s,t,inf);
	return re;
}
void init(){memset(first,-1,sizeof(first));memset(a,0,sizeof(a));cnt=-1;}
int e[110][110];
int main(){
	int i,j,tmp1,tmp2;char s[110];
	while(~scanf("%d%d%d%d%d%d%d",&n,&a1,&a2,&an,&b1,&b2,&bn)){
		init();a1++;a2++;b1++;b2++;
		for(i=1;i<=n;i++){
			scanf("%s",s);
			for(j=1;j<=n;j++){
				if(s[j-1]=='X') e[i][j]=0;
				if(s[j-1]=='O') e[i][j]=2;
				if(s[j-1]=='N') e[i][j]=1;
			}
		}
		for(i=1;i<=n;i++){
				for(j=i+1;j<=n;j++){
				if(e[i][j]) add(i,j,((e[i][j]==1)?inf:2));
			}
		}
		add(0,a1,an<<1);add(0,b1,bn<<1);add(a2,n+1,an<<1);add(b2,n+1,bn<<1);
		tmp1=dinic(0,n+1);
		init();
		for(i=1;i<=n;i++){
				for(j=i+1;j<=n;j++){
				if(e[i][j]) add(i,j,((e[i][j]==1)?inf:2));
			}
		}
		add(0,a1,an<<1);add(0,b2,bn<<1);add(a2,n+1,an<<1);add(b1,n+1,bn<<1);
		tmp2=dinic(0,n+1);
		if((tmp1!=(an<<1)+(bn<<1))||(tmp2!=(an<<1)+(bn<<1))) puts("No");
		else puts("Yes");
	}
}
```

---

## 作者：Foreverxxx (赞：1)

### 思路

首先考虑分开跑网络流，不过这明显不怎么合理，因为某一条路径可能会被重复使用。

如果说，我们需要 $a_n$ 次 从 $a_1$ 到达 $a_2$，同时需要 $b_n$ 次从 $b_1$ 到达 $b_2$，则说明，从 $a_1$ 出发到达 $a_2$ 的总次数之和 $b_1$ 到达 $b_2$ 的总次数为 $a_n+b_n$。

所以我们考虑，从源点向两个起点 $a_1$ 和 $b_1$ 连边，从两个终点 $a_2$ 和 $b_2$ 向汇点连边，根据题意中的“往返”要求，又因为危桥正好可以通过 $2$ 次，我们只需要保证在通过次数除以 $2$ 后，保证最大流的答案为 $a_n + b_n$ 即可。

不过此时涉及到了一个问题：按照上述方法建图，如果是从 $a_1$ 流向 $b_2$ 或者从 $b_1$ 流向 $a_2$，这明显不合理。

所以我们再来考虑如何解决这一个问题。

解决方法很简单，只需要把 $b_1$ 和 $b_2$ 交换一下，再跑一次最大流，保证答案依然为 $a_n + b_n$ 就行了，因为第一次网络流跑出来的那些不符合情况的答案不会被统计到第二次网络流的答案中来，第二次网络流的那些不符合情况的流量也不会在第一次网络流的答案出现。

Code

```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read(){
	int sss=0;
	char chh=getchar();
	while(chh<'0'||chh>'9') chh=getchar();
	while(chh>='0'&&chh<='9'){
		sss=sss*10+chh-'0';
		chh=getchar();
	}
	return sss;
}
inline char get_char(){
	char chh=getchar();
	while(chh!='N'&&chh!='X'&&chh!='O') chh=getchar();
	return chh;
}
int n,a1,a2,an,b1,b2,bn;
int s,t;
char edge[55][55];
int depth[55];
int head[55],to[1000005],val[1000005],nxt[1000005],tot=1;
void add(int u,int v,int w){
	to[++tot]=v;
	val[tot]=w;
	nxt[tot]=head[u];
	head[u]=tot;
}
void build(){
	memset(head,-1,sizeof head); tot=1;
	for(register int i=1;i<=n;i++){
		for(register int j=i+1;j<=n;j++){
			if(edge[i][j]=='N'){
				add(i,j,1e9); add(j,i,1e9);
			}
			else if(edge[i][j]=='O'){
				add(i,j,1); add(j,i,1);
			}
		}
	}
	add(s,a1,an); add(a1,s,an);
	add(s,b1,bn); add(b1,s,bn);
	add(a2,t,an); add(t,a2,an);
	add(b2,t,bn); add(t,b2,bn);
}
bool bfs(){
	memset(depth,0,sizeof depth); depth[s]=1;
	queue<int> q; q.push(s);
	while(!q.empty()){
		int x=q.front(); q.pop();
		for(register int i=head[x];i;i=nxt[i]){
			int u=to[i];
			if(val[i]&&!depth[u]){
				depth[u]=depth[x]+1;
				q.push(u);
			}
		}
	}
	return depth[t];
}
int dfs(int now,int flow){
	if(now==t) return flow;
	int out_flow=0;
	for(register int i=head[now];i&&flow;i=nxt[i]){
		int u=to[i];
		if(val[i]&&depth[u]==depth[now]+1){
			int tmp=dfs(u,min(val[i],flow));
			val[i]-=tmp; val[i^1]+=tmp;
			flow-=tmp; out_flow+=tmp;
		}
	}
	if(out_flow==0) depth[now]=0;
	return out_flow;
}
int Dinic(){
	int ret=0;
	while(bfs()) ret+=dfs(s,1e9);
	return ret;
}
int main(){
	while(scanf("%d%d%d%d%d%d%d",&n,&a1,&a2,&an,&b1,&b2,&bn)!=EOF){
		a1++,a2++,b1++,b2++;
		s=0,t=n+1;
		for(register int i=1;i<=n;i++){
			for(register int j=1;j<=n;j++){
				edge[i][j]=get_char();
			}
		}
		build();
		if(Dinic()==an+bn){
			swap(b1,b2);
			build();
			if(Dinic()==an+bn) puts("Yes");
			else puts("No");
		}
		else puts("No");
	}
	return 0;
}
```

---

## 作者：magolor (赞：1)

做这道题的人好少……


Dinic正常建图，源点连a1,b1       ，       a2,b2连汇点。

跑完以后是不一定对的， 有可能a1跑到b2去了，那么反过来，源点连a1,b2       ，       a2,b1连汇点。

如果这样也跑过，就说明对了，记得答案是2\*(an\_bn)，和最大流比较一下是不是满流。

记得初始化和多组数据，【以及Yes和No的大小写！！！】

（Dinic板子略有压行）










        


    


```cpp
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
#define MAXN 100
#define MAXM 10000
#define INF 0x3f3f3f3f
struct Edge
{
    int to,nex,c;
    Edge(){}
    Edge(int _to, int _nex, int _c):to(_to),nex(_nex),c(_c){}
};
Edge e[MAXM+5];
int first[MAXN+5], level[MAXN+5], cur[MAXN+5], q[MAXN+5], n, tot, S, T, a1, a2, an, b1, b2, bn, F1, F2;
char g[MAXN+5][MAXN+5]; 
void Add(int a, int b, int w)
{
    e[tot] = Edge(b,first[a],w);
    first[a] = tot++;
    e[tot] = Edge(a,first[b],0);
    first[b] = tot++;
    return;
}
void Init(int N)
{
    memset(first,-1,sizeof(first)), tot = 0, S = 0, T = N;
    return;
}
bool BFS()
{
    memset(level,0,sizeof(level)), q[0] = S, level[S] = 1;
    for(int head = 0, tail = 1; head < tail; )
        for(int t = q[head++], u = first[t]; u != -1; u = e[u].nex)
            if(!level[e[u].to] && e[u].c > 0)
            {
                level[e[u].to] = level[t] + 1;
                q[tail++] = e[u].to;
                if(e[u].to == T)
                    return true;
            }
    return false;
}
int DFS(int p, int f)
{
    if(p == T)
        return f;
    int tag = 0, del;
    for(int &u = cur[p]; u != -1; u = e[u].nex)
        if(level[e[u].to] == level[p]+1 && e[u].c > 0)
        {
            del = DFS(e[u].to,min(f-tag,e[u].c));
            e[u].c -= del, e[u^1].c += del, tag += del;
            if(tag == f)
                return tag;
        }
    return tag;
}
int Dinic()
{
    int ans = 0;
    for(; BFS(); ans += DFS(S,INF))
        for(int i = 0; i <= n+1; i++)
            cur[i] = first[i];
    return ans;
}
int main()
{
    for(; ~scanf("%d%d%d%d%d%d%d",&n,&a1,&a2,&an,&b1,&b2,&bn); puts((F1<2*(an+bn) || F2<2*(an+bn) ? "No" : "Yes")))
    {
        a1++, a2++, b1++, b2++;
        for(int i = 1; i <= n; i++)
            scanf("%s",g[i]+1);
        Init(n+1);
        for(int i = 1; i <= n; i++)
            for(int j = 1; j < i; j++)
                if(g[i][j] == 'O')
                    Add(i,j,2), Add(j,i,2);
                else if(g[i][j] == 'N')
                    Add(i,j,INF), Add(j,i,INF);
        Add(S,a1,an*2), Add(S,b1,bn*2), Add(a2,T,an*2), Add(b2,T,bn*2), F1 = Dinic();
        Init(n+1);
        for(int i = 1; i <= n; i++)
            for(int j = 1; j < i; j++)
                if(g[i][j] == 'O')
                    Add(i,j,2), Add(j,i,2);
                else if(g[i][j] == 'N')
                    Add(i,j,INF), Add(j,i,INF);
        Add(S,a1,an*2), Add(S,b2,bn*2), Add(a2,T,an*2), Add(b1,T,bn*2), F2 = Dinic();
    }
     return 0;
}
```

---

## 作者：Hongse_Fox (赞：0)

[题目链接](https://www.luogu.com.cn/problem/P3163)
# 零.前记
网络流初始化的时候千万不能忘记源点和汇点

# 一.大体思路
本题有的边可以走无数次，有的边只可以走2次

因此不难想到这是一道网络流

这里有2个源点和2个汇点

因此我们可以用一个超级源点和一个超级汇点

再跑一遍网络流

# 二.实现细节
不难发现有的情况下光用超级源点超级汇点会翻车

例如这样:

![](https://s1.ax1x.com/2020/04/11/G7R7ng.png)

虽然肉眼可见答案是no

但是流量还是对的

因此我们必须要分别跑两次，第二次把b1b2反过来

这样不会影响对的情况，但肯定可以排除错误的情况

另外，题目求的是两点之间来往anbn次

相当于从a1到a2 $2\times an$次

从b1到b2 $2\times bn$次

这样就可以用网络流解决了

# 三.具体代码
```
#include<cstdio>
#include<cctype>
#include<queue>
#include<iostream>
using namespace std;
const int INF=0x7fffffff;
inline int fan(int a){return a%2==0? a-1:a+1;}
inline void swap(int &a,int &b){int t=a;a=b;b=t;}
inline int R(){
	int r=0;char c=getchar();
	while(!isdigit(c)) c=getchar();
	while(isdigit(c)) r=(r<<1)+(r<<3)+(c^48),c=getchar();
	return r;
}
struct node{
	int to,next,flow;
}edge[5050];
int n,a1,a2,an,b1,b2,bn,head[55],tot,dis[55],s,t,gap[55],cur[55],ans;
inline void add(int from,int to,int flow){
	edge[++tot].flow=flow;
	edge[tot].next=head[from];
	edge[tot].to=to;
	head[from]=tot;
	return ;
}
inline void bfs(int start){
    for(register int i=1;i<t;i++) dis[i]=-1;
    int l=0,r=1;
    int dl[205];
    dl[1]=start;
    while(l<r){
        l++;
        int u=dl[l];
        for(register int i=head[u];i;i=edge[i].next){
            if(edge[i].flow || dis[edge[i].to]>0) continue;
            dis[edge[i].to]=dis[u]+1;
            gap[dis[edge[i].to]]++;
            r++;
            dl[r]=edge[i].to;
        }
    }
    if(dis[s]==-1) dis[s]=t;
    return ;
}
inline int isap(int now,int nowflow){
    if(now==t) return nowflow;
    int sum=0;
    for(register int i=head[now];i;i=edge[i].next){
        if(!edge[i].flow || dis[edge[i].to]!=dis[now]-1) continue;
        int akak=isap(edge[i].to,min(nowflow-sum,edge[i].flow));
        sum+=akak;edge[i].flow-=akak;edge[fan(i)].flow+=akak;
        if(dis[s]>=t || nowflow==sum) return sum;
    }
    cur[now]=head[now];
    if(!--gap[dis[now]]) dis[s]=t;
    dis[now]++;
    gap[dis[now]]++;
    return sum;
}
int mp[55][55];
inline void clear(){
	ans=0;tot=0;
	for(register int i=1;i<=n+2;i++) head[i]=gap[i]=cur[i]=dis[i]=0;
	for(register int i=1;i<=n;i++){
		for(register int j=1;j<=n;j++){
			if(mp[i][j]==1) add(i,j,INF),add(j,i,0);
			if(mp[i][j]==2) add(i,j,2),add(j,i,0);
		}
	}
	add(s,a1,2*an);add(a1,s,0);add(t,a2,0);add(a2,t,2*an);
	add(s,b1,2*bn);add(b1,s,0);add(t,b2,0);add(b2,t,2*bn);
}
int main(){
	while(cin>>n){
		s=n+1,t=n+2;
		a1=R()+1,a2=R()+1,an=R();
		b1=R()+1,b2=R()+1,bn=R();
		for(register int i=1;i<=n;i++){
			for(register int j=1;j<=n;j++){
				char ch=getchar();
				while(ch!='N'&&ch!='X'&&ch!='O') ch=getchar();
				if(ch=='X') mp[i][j]=0;
				if(ch=='N') mp[i][j]=1;
				if(ch=='O') mp[i][j]=2;
			}
		}
		clear();
		for(register int i=1;i<=t;i++) cur[i]=head[i];
		bfs(t);
		while(dis[s]<t){
			ans+=isap(s,INF);
		}
		if(ans<2*(an+bn)){
			printf("No\n");
			continue;
		}
		
		swap(b1,b2);
		clear();
		for(register int i=1;i<=t;i++) cur[i]=head[i];
		bfs(t);
		while(dis[s]<t){
			ans+=isap(s,INF);
		}
		if(ans<2*(an+bn)) printf("No\n");
		else printf("Yes\n");
	}
}
```
# 四.后记
本题考查的是对多源点汇点的考察

注意在网络流中出现的窜流的情况

可以通过多次换点来解决问题

Finally,谢谢大家

[更好的阅读体验](https://www.luogu.com.cn/blog/HongseFox/solution-p3163)

---

## 作者：撤云 (赞：0)

### $Solution$
首先往返$n$次等价于走$2n$次。

将 $a_n*2,b_n*2$;

那么我们直接按原图构图，然后：

$(S,a_1,a_n),(S,b_1,b_n),(a_2,T,a_n),(b_2,T,b_n)$

但直接判断最大流是否等于$a_n+b_n$是不对的。因为$a_2$可能有来自$b_1$的流量，$b_2$也有可能有来自$a_1$的流量。

所以我们可以将$b_1$和$b_2$交换再跑一次最大流。如果两次最大流都等于$a_n+b_n$ 那么有解。

至于证明，将$a_1->a_2$的流量设为$x$然后在推一下就没了，自己想想吧

### $Code$

``` cpp
#include<bits/stdc++.h>
#define int long long
#define rg register
#define file(x) freopen(x".in","r",stdin);freopen(x".out","w",stdout);
using namespace std;
const int inf=1e12;
int read(){
    int x=0,f=1;char c=getchar();
    while(c<'0'||c>'9') f=(c=='-')?-1:1,c=getchar();
    while(c>='0'&&c<='9') x=x*10+c-48,c=getchar();
    return f*x;
}
struct node{
    int to,next,v;
}a[200001];
int head[100001],cnt=1,n,m,s,t,x,y,z,dep[100001],a1,a2,an,b1,b2,bn;
void add(int x,int y,int c){
    a[++cnt].to=y,a[cnt].next=head[x],a[cnt].v=c,head[x]=cnt;
    a[++cnt].to=x,a[cnt].next=head[y],a[cnt].v=0,head[y]=cnt;
}
queue<int> q;
int bfs(){
    memset(dep,0,sizeof(dep));
    q.push(s);
    dep[s]=1;
    while(!q.empty()){
        int now=q.front();
        q.pop();
        for(int i=head[now];i;i=a[i].next){
            int v=a[i].to;
            if(!dep[v]&&a[i].v>0)
                dep[v]=dep[now]+1,q.push(v);
        }
    }
    if(dep[t])
        return 1;
    return 0;
}
int dfs(int k,int list){
    if(k==t||!list)
       return list;
    for(int i=head[k];i;i=a[i].next){
        int v=a[i].to;
        if(dep[v]==dep[k]+1&&a[i].v>0){
            int p=dfs(v,min(list,a[i].v));
            if(p){
                a[i].v-=p;
                a[i^1].v+=p;
                return p;
            }
        }
    }
    return dep[k]=0;
}
int Dinic(){
    int ans=0,k;
    while(bfs())
        while((k=dfs(s,inf)))
            ans+=k;
    return ans;
}
char c[101][101];
bool build(){
    s=0,t=n+1;
    memset(head,0,sizeof(head)),cnt=1;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++){
            if(c[i][j]=='O')
                add(i,j,2);
            if(c[i][j]=='N')
                add(i,j,inf);
        }
    add(s,a1,an),add(a2,t,an);
    add(s,b1,bn),add(b2,t,bn);
    return Dinic()==an+bn;
}
main(){
    while(scanf("%d%d%d%d%d%d%d",&n,&a1,&a2,&an,&b1,&b2,&bn)!=EOF){
        a1++,a2++,b1++,b2++,an*=2,bn*=2;
        for(int i=1;i<=n;i++)
            scanf("%s",c[i]+1);
        int ans=build();
        swap(b1,b2);
        ans+=build();
        if(ans==2) puts("Yes");
        else puts("No");
    }
}

```

---

## 作者：wanglichao1121 (赞：0)

算是练习dinic模板了（3个月没打了居然一遍打对了）

建图没什么问题，就是裸的图（个人感觉可以先并查集一波把普通桥连接的点并起来加速）

此题注意点：

1.炒鸡原点到两个原点的流量是不同的（2an、2bn），不是INF

2.流完一次交换b1b2再来一遍可以保证这个流不是从a流到b

3.第二次流前重新建图！！（应该只有我会忘记建吧）

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,h,t,a1,a2,an,b1,b2,bn,flow,now;char ch;
int dis[52],l[52],d[52][52];char c[52][52];
char getch()
{
    for(ch=getchar();ch!='O' && ch!='N' && ch!='X';ch=getchar());
    return ch;
}
bool bfs()
{
    for(int i=1;i<=n+1;i++)
        dis[i]=0;
    for(h=1,t=1,l[1]=0,dis[0]=1;h<=t;h++)
        for(int i=1;i<=n+1;i++)
            if(d[l[h]][i] && !dis[i])
                l[++t]=i,dis[i]=dis[l[h]]+1;
    return dis[n+1];
}
int dfs(int now,int maxflow)
{
    if(now==n+1) return maxflow;
    int flow=0;
    for(int i=0;i<=n+1;i++)
    if(dis[i]==dis[now]+1 && d[now][i])
    {
        int thi=dfs(i,min(maxflow,d[now][i]));
        d[now][i]-=thi;d[i][now]+=thi;
        maxflow-=thi;flow+=thi;
        if(maxflow==0) return flow;
    }
    if(flow==0)
        dis[now]=-1;
    return flow;
}
void INIT()
{
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
        switch(c[i][j])
        {
            case'O':d[j][i]=d[i][j]=2;break;
            case'N':d[j][i]=d[i][j]=flow;break;
            case'X':d[j][i]=d[i][j]=0;break;
        }
    for(int i=0;i<=n+1;i++)
        d[0][i]=d[i][0]=d[i][n+1]=d[n+1][i]=0;
    d[a1][0]=d[0][a1]=an<<1;d[b1][0]=d[0][b1]=bn<<1;
    d[a2][n+1]=d[n+1][a2]=an<<1;d[b2][n+1]=d[n+1][b2]=bn<<1;
    now=0;
}
int main()
{
    while(~scanf("%d%d%d%d%d%d%d",&n,&a1,&a2,&an,&b1,&b2,&bn))
    {
    a1++;a2++;b1++;b2++;
    flow=an+bn<<1;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
            c[i][j]=getch();
    INIT();
    while(now<flow && bfs()) now=now+dfs(0,flow);
    if(now<flow)
    {
        puts("No");
        continue;
    }
    swap(b1,b2);
    INIT();
    while(now<flow && bfs()) now=now+dfs(0,flow);
    if(now<flow)
        puts("No");
    else
        puts("Yes");
    }
    return 0;
}
```

---

## 作者：LoliconAutomaton (赞：0)

题解很多人都在前面写过了，我就在这里放一个ISAP的板子好了
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <queue>
#define N 30007
#define INF 0x3f3f3f3f
using namespace std;
struct Graph {
    struct Edge {
        int to, nxt, cap;
        Edge() {}
        Edge(const int& to, const int& nxt, const int& cap) : to(to), nxt(nxt), cap(cap) {}
    } e[N << 2];
    int n, s, t;
    int tot, head[N], d[N], cur[N], pre[N], gap[N];
    inline void clear(int n, int s, int t) {
        this -> n = n; this -> s = s; this -> t  = t; tot = 0;
        memset(head, -1, sizeof(head));
        memset(cur, 0, sizeof(cur));
        memset(pre, 0, sizeof(pre));
    }

    inline void AddEdge(const int& u, const int& v, const int& c) {
        e[tot] = Edge(v, head[u], c), head[u] = tot++;
        e[tot] = Edge(u, head[v], 0), head[v] = tot++;
    }

    inline void bfs() {
        queue<int> q;
        memset(d, -1, sizeof(d));
        memset(gap, 0, sizeof(gap));
        d[t] = 0; gap[d[t]] = 1; q.emplace(t);
        while (!q.empty()) {
            int u = q.front(); q.pop();
            for (int i = head[u]; ~i; i = e[i].nxt) {
                int v = e[i].to;
                if (d[v] == -1) {
                    d[v] = d[u] + 1;
                    ++gap[d[v]];
                    q.emplace(v);
                }
            }
        }
    }

    inline int ISAP() {
        memcpy(cur, head, sizeof(cur));
        int flow = 0, u = (pre[s] = s);
        bfs();
        while (d[s] < n + 2) {
            if (u == t) {
                int f = INF;
                for (int i = s; i != t; i = e[cur[i]].to)
                    if (f > e[cur[i]].cap) f = e[cur[(u = i)]].cap;
                flow += f;
                for (int i = s; i != t; i = e[cur[i]].to)
                    e[cur[i]].cap -= f, e[cur[i] ^ 1].cap += f;
            }
            int c;
            for (c = cur[u]; ~c; c = e[c].nxt) {
                int v = e[c].to;
                if (e[c].cap && d[u] == d[v] + 1) break;
            }
            if (~c) {
                cur[u] = c;
                pre[e[c].to] = u;
                u = e[c].to;
            } else {
                if (--gap[d[u]] == 0) break;
                int mn = n + 2;
                for (int i = head[u]; ~i; i = e[i].nxt) {
                    int v = e[i].to;
                    if (e[i].cap && mn > d[v]) {
                        mn = d[v];
                        cur[u] = i;
                    }
                }
                d[u] = mn + 1;
                ++gap[d[u]];
                u = pre[u];
            }
        }
        return flow;
    }
} G[2];

int n, a1, a2, an, b1, b2, bn;

int main()
{
    //freopen("test.in", "r", stdin);
    while (scanf("%d%d%d%d%d%d%d", &n, &a1, &a2, &an, &b1, &b2, &bn) == 7) {
        getchar();
        G[0].clear(n, n, n + 1), G[1].clear(n, n, n + 1);
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < n; ++j) {
                char ch = getchar();
                if (i == j || ch == 'X') continue;
                if (ch == 'O') G[0].AddEdge(i, j, 2), G[1].AddEdge(i, j, 2);
                if (ch == 'N') G[0].AddEdge(i, j, INF), G[1].AddEdge(i, j, INF);
            }
            getchar();
        }
        G[0].AddEdge(n, a1, an << 1); G[0].AddEdge(n, b1, bn << 1);
        G[0].AddEdge(a2, n + 1, an << 1); G[0].AddEdge(b2, n + 1, bn << 1);
        G[1].AddEdge(n, a1, an << 1); G[1].AddEdge(n, b2, bn << 1);
        G[1].AddEdge(a2, n + 1, an << 1); G[1].AddEdge(b1, n + 1, bn << 1);
        int f1 = G[0].ISAP(), f2 = G[1].ISAP();
        if (f1 == ((an + bn) << 1) && f2 == ((an + bn) << 1)) printf("Yes\n");
        else printf("No\n");
    }
    return 0;
}
```

---


# [SCOI2014] 方伯伯运椰子

## 题目描述

四川的方伯伯为了致富，决定引进海南的椰子树。方伯伯的椰子园十分现代化，椰子园中有一套独特的交通系统。

现在用点来表示交通节点，边来表示道路。这样，方伯伯的椰子园就可以看作一个有  $N+2$ 个交通节点， $M$ 条边的有向无环图。 $N +1$ 号点为入口， $N +2$ 号点为出口。每条道路都有  $6$ 个参数， $u_i,v_i,a_i,b_i,c_i,d_i$。分别表示，该道路从  $u_i$ 号点通向  $v_i$ 号点，将它的容量压缩一次要  $a_i$ 的花费，容量扩大一次要  $b_i$ 的花费，该条道路当前的运输容量上限为  $c_i$，并且每单位运输量通过该道路要  $d_i$ 的费用。

在这个交通网络中，只有一条道路与起点相连。因为弄坏了这条道路就会导致整个交通网络瘫痪，聪明的方伯伯决定绝不对这条道路进行调整，也就是说，现在除了这条道路之外，对其余道路都可以进行调整。

有两种调整方式：

- 选择一条道路，将其进行一次压缩，这条道路的容量会下降  $1$ 单位。

- 选择一条道路，将其进行一次扩容，这条道路的容量会上升  $1$ 单位。

一条道路可以被多次调整。

由于很久以前，方伯伯就请过一个工程师，对这个交通网络进行过一次大的优化调整。所以现在所有的道路都被完全的利用起来了，即每条道路的负荷都是满的（每条道路的流量等于其容量）。

但方伯伯一想到自己的海南椰子会大丰收，就十分担心巨大的运输量下，会导致过多的花费。因此，方伯伯决定至少进行一次调整，调整之后，必须要保持每条道路满负荷，且总交通量不会减少。

设调整后的总费用是  $Y$，调整之前的总费用是  $X$。现在方伯伯想知道，最优调整比率是多少，即假设他进行了  $k$ 次调整， $\dfrac{X-Y}{k}$最大能是多少？

注：总费用 = 交通网络的运输花费 + 调整的花费

## 说明/提示

对于所有数据，$1\le N\le 5\times 10^3$， $M\le 3\times10^3$， $1\le u_i,v_i\le N+2$， $0\le a_i,b_i\le 500$， $0\le c_i\le 10^4$， $0\le d_i\le 10^3$。

## 样例 #1

### 输入

```
5 10
1 5 13 13 0 412
2 5 30 18 396 148
1 5 33 31 0 39
4 5 22 4 0 786
4 5 13 32 0 561
4 5 3 48 0 460
2 5 32 47 604 258
5 7 44 37 75 164
5 7 34 50 925 441
6 2 26 38 1000 22```

### 输出

```
103.00```

# 题解

## 作者：雨季 (赞：13)

# 题解

题目要求 总交通量不减少  
若 总交通量 增加的话，一定不优  
所以 总交通量 守恒  
也就是 ****我们不生产流量 ，我们只做流量的搬运工****  

那么我们可以  
将 压缩 看成 **退流**  
将 扩容 看成 **增广**  
那么 $X-Y \Rightarrow \Delta$总费用  $\Rightarrow$  压缩导致的费用$-$扩容导致的费用  
压缩 $\Rightarrow$  $(v,u,c)(c!=0)$ 边权$\ a-d $   
增广 $\Rightarrow$ $(u,v,inf)\ \ \ \ \ \ \ \ \ $ 边权$\  b+d$  
这样建图后，会出现一些环，每一个环，都是一个流量搬运的途径  

令 $$max\{\ (X-Y)/k\ \}=ans$$
则对于图中任意一个环，有 $$ans>=(X-Y)/k $$可推知 $$ ans \times k-(X-Y)>=0 $$  
我们可以二分一个$mid$  
当 $mid>=ans$ 时，$mid \times k-(X-Y)>=0 $   
当 $mid<\ \ \ ans$ 时，$mid \times k-(X-Y)<\ \ \ 0$   
并将费用$ (a-d\ or\ b+d) $存成边权，将$\ k\ $看成是环上的点数 $($环上的点数$=$环上的边数$=$ $k)$  
也就是找到一个点就 $+mid$，相当于是将边权看成了 $($边权$+mid)$   
那么，当 $mid \times k-(X-Y)<0\Rightarrow \sum e[i]<0(e[i]$为边权$)$ 时，这个环为一个负环   
于是我们二分的判断条件就可以换成图中是否有负环  
即  
当$\ mid>=ans\ $时，$mid \times k-(X-Y)>=0\ $ 无负环   
当$\ mid<\ \ \ ans\ $时，$mid \times k-(X-Y)< 0\ \ \ \ $ 有负环  
然后$spfa$判负环即可 
# 代码
```
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
#define eps 1e-3
#define inf 1e9
#define N 5005

int n,m;
inline int read() {
	int tmp=0,w=1;
	char ch=0;
	while(!isdigit(ch)) {if(ch=='-') w=-1;ch=getchar();}
	while(isdigit(ch)) tmp=(tmp<<1)+(tmp<<3)+ch-'0',ch=getchar();
	return tmp*w;
}

struct node {
	int v,f,nex;
}e[N<<1];
int tot,h[N];
void add(int u,int v,int f) {
	e[++tot].v=v,e[tot].f=f,e[tot].nex=h[u],h[u]=tot;
}

bool vis[N];
double dis[N];
bool spfa(int x,double mid) {
	vis[x]=1;
	int xx;
	for(int i=h[x];i;i=e[i].nex) {
		xx=e[i].v;
		if(dis[xx]>dis[x]+e[i].f+mid) {
			dis[xx]=dis[x]+e[i].f+mid;
			if(vis[xx]) return 1;
			if(spfa(xx,mid)) return 1;
		}
	}
	vis[x]=0;
	return 0;
}
bool pd(double mid) {
	memset(vis,0,sizeof(vis));
	memset(dis,0,sizeof(dis));
	for(int i=1;i<=n;++i) if(spfa(i,mid)) return 1;
	return 0;
}
void Bsearch() {
	double l=0,r=inf,mid;
	while(r-l>=eps) {
		mid=(l+r)/2;
		if(pd(mid)) l=mid;
		else r=mid;
	}
	printf("%.2lf",l);
}

int main()
{
	n=read()+2,m=read();
	int u,v,a,b,c,d;
	for(int i=1;i<=m;++i) {
		u=read(),v=read(),a=read(),b=read(),c=read(),d=read();
		if(c!=0) add(v,u,a-d);
		add(u,v,b+d);
	}
	Bsearch();
	return 0;
}
```

---

## 作者：Dispwnl (赞：5)

> 修改了一下排版

这题神TM标签网络流~~似乎用到了网络流的思想~~……

首先，这题肯定是分数规划，因为ta要求调整之后必须要保持每条道路满负荷，且总交通量不会减少

如果总交通量增加，花费肯定会增加，即大于调整前的花费

所以要保持流量不变，我们考虑网络流的思想

压缩$\rightarrow$网络流里的退流

扩充$\rightarrow$网络流里的增广

所以对于原图给定每一条边$(u,v)$，我们在新图里对应建两条边

$(v,u)$，边权为$a_i-d_i$（你压缩一单位花费$a_i$，同时这条边少了一单位流量所以花费减去$d_i$），对应压缩

$(u,v)$，边权为$b_i+d_i$（你扩充一单位花费$b_i$，同时这条边多了一单位流量所以花费加上$d_i$），对应扩充

我们令$tot=max(\frac{X-Y}{k})$，所以$tot\ge \frac{X-Y}{k}$

即$tot\times k\ge X-Y$

所以我们二分一个数$mid$，即调整比率

我们可以发现，在新图中xjb跑，经过的点数（也是边数）就是调整次数，即$k$

因为你调整一次就相当于经过新图里的一条边，同时加上这条边的贡献$w$（就是边权）

我们可以把$X-Y$化为$X-(X+\sum w)$，即$-\sum w$

所以问题就转为了比较$mid\times k$和$-\sum w$的大小

即$mid\times k+\sum w$是否大于0

然后原问题就转化为在新图里找负环

要是有负环，说明$mid\times k<X-Y$

反之说明$mid\times k\ge X-Y$

这样问题就解决了

还有一点，题目中要求不调整源点连接的那一条边，所以特判一下~~但没特判好像也能过~~

### 代码
```
# include<iostream>
# include<cstring>
# include<cstdio>
# include<queue>
using namespace std;
const int MAX=1e4+1;
const double ops=1e-3;
struct p{
	int x,y;
	double dis;
}c[MAX];
int n,m,num;
int h[MAX];
double d[MAX];
bool use[MAX];
int read()
{
	int x=0;
	char ch=getchar();
	for(;!isdigit(ch);ch=getchar());
	for(;isdigit(ch);x=x*10+ch-48,ch=getchar());
	return x;
}
void add(int x,int y,double dis)
{
	c[++num]=(p){h[x],y,dis},h[x]=num;
}
bool spfa(int x,double mid)
{
	use[x]=1;
	for(int i=h[x];i;i=c[i].x)
	  if(d[c[i].y]>d[x]+c[i].dis+mid)
	  {
	  	d[c[i].y]=d[x]+c[i].dis+mid;
	  	if(use[c[i].y]) return 1;
	  	if(spfa(c[i].y,mid)) return 1;
	  }
	use[x]=0;
	return 0;
}
bool look(double mid)
{
	memset(d,0,sizeof(d));
	memset(use,0,sizeof(use));
	for(int i=1;i<=n+2;i++)
	  if(spfa(i,mid)) return 1;
	return 0;
}
int main()
{
	n=read(),m=read();
	for(int i=1;i<=m;i++)
	  {
	  	int x=read(),y=read();
		double A=read(),B=read(),dis=read(),cn=read();
	  	if(x==n+1) A=0,B=0,cn=0;
		if(dis) add(y,x,A-cn);
	  	add(x,y,B+cn);
	  }
	double l=0,r=1e8,ans;
	while(l<=r)
	{
		double mid=(l+r)/2;
		if(look(mid))
		ans=mid,l=mid+ops;
		else r=mid-ops;
	}
	printf("%.2lf",ans);
	return 0;
}
```


---

## 作者：_WA自动机 (赞：4)


#### 更好的阅读体验点[这里](https://wa-automaton.github.io/2019/04/22/SCOI2014-Luogu-P3288-方伯伯运椰子/)~



# 题解
~~真是个语文题~~  
在艰难看懂了题意之后，我们可以发现，方伯伯实际上是在DAG上跑网络流。所以问题可以简化为：给一个网络图，可以进行增广或者退流，对边i增广一次的费用为$b_i+d_i$,退流一次的费用为$a_i-d_i$,（注意边权为0的边不能退流）最终使得总流量不变（增广和退流都需要花费，所以总流量变大肯定不优），并最大化原式。

题面给的$(X-Y)/k$太难看了，我们给它换一下：
令$Y=X+\Delta w$，
则原式变为$-\Delta w/k$。

如何保持流量不变的情况下，优化增广的费用？

我们需要一个定理：
> 消圈定理：一个流是当前流量下的最小费用流，等价于当前残量网络上没有负费用圈。

> 证明：假设残量网络上存在负费用圈，我们可以把原来不经过负圈的流沿着这个负圈增广一次，则我们的流量会不变，并且减少了所花的费用。

所以：我们现在的目标就是在残量网络上沿着负圈增广,且$\text{maximize}\{-\Delta w/k\}$.
因为我们要最大化比值，所以我们显然要选择**一个**最优的环进行增广。选择多个环，答案显然会变劣（求的是平均值嘛）。这就是一个最小（大）平均值回路问题了。套用分数规划的思路，二分+bellman-ford判断负环就可以了。

# 代码
```cpp
// luogu-judger-enable-o2
#include <cstdio>
#include <cstring>
#include <queue>

using std::queue;

const int maxn=5000+1000;
const double eps=1e-6;

struct Edge
{
    int to,next;double w;
}edge[maxn<<1];

int head[maxn],cnt;
int u[maxn],v[maxn],a[maxn],b[maxn],c[maxn],d[maxn];

inline void add(int u,int v,double w)
{
    edge[++cnt].next=head[u];
    edge[cnt].to=v;
    edge[cnt].w=w;
    head[u]=cnt;
}

bool spfa(int s,int n)
{
    static bool vis[maxn];
    static double d[maxn];
    static int cnt[maxn];
    queue<int> q;
    q.push(s);
    for (int i=1;i<=n;++i) d[i]=1e18;
    memset(vis,0,sizeof(vis));
    memset(cnt,0,sizeof(cnt));
    vis[s]=true;d[s]=0;
    while (!q.empty())
    {
        int u=q.front();q.pop();
        vis[u]=false;
        for (int i=head[u];i;i=edge[i].next)
        {
            int v=edge[i].to;
            if (d[v]>d[u]+edge[i].w)
            {
                d[v]=d[u]+edge[i].w;
                cnt[v]=cnt[u]+1;
                if (cnt[v]>=n) return true;
                if (!vis[v]) vis[v]=true,q.push(v);
            }
        }
    }
    return false;
}

inline bool check(double mid,int n,int m)
{
    cnt=0;
    memset(head,0,sizeof(head));
    for (int i=1;i<=m;++i)
    {
        add(u[i],v[i],mid+(b[i]+d[i]));
        if (c[i]>0) add(v[i],u[i],mid+(a[i]-d[i]));
    }
    return spfa(n-1,n);
}

int main()
{
    int n,m;
    scanf("%d%d",&n,&m);
    n+=2;
    double sigma=0;
    for (int i=1;i<=m;++i)
        scanf("%d%d%d%d%d%d",u+i,v+i,a+i,b+i,c+i,d+i),sigma+=a[i]+b[i]+(double)c[i]*d[i];
    double l=0,r=sigma;
    while (l+eps<r)
    {
        // printf("%.3lf %.3lf\n",l,r);
        double mid=(l+r)/2;
        if (check(mid,n,m)) l=mid;
        else r=mid;
    }
    printf("%.2lf",l);
}
```

---

## 作者：hegm (赞：2)

### [P3288 [SCOI2014]方伯伯运椰子](https://www.luogu.com.cn/problem/P3288)

依然是分数规划，先把原来的式子转化一下：

$\dfrac{X-Y}{k} \to \dfrac{\sum(abs(c_i-f_i)\times (-)d_i-cost(c_i-f_i))}{\sum abs(c_i-f_i)}$。（$f_i$ 为 $i$ 现在的流量）

老规矩，分数规划二分 $mid$。

$\dfrac{\sum(abs(c_i-f_i)\times (-)d_i-cost(c_i-f_i))}{\sum abs(c_i-f_i)}<mid$

将 $cost(c_i,f_i)=abs(c_i-f_i)\times a_i(b_i)$ 带入，移项。

$\sum abs(c_i-f_i)\times ((-)d_i-a_i(b_i)-mid)<0$

将 $a,b,d,-d$ 拆分开。

当 $c_i-f_i$ 为正时：

$\sum abs(c_i-f_i)\times (-a_i+d_i-mid)<0$

当 $c_i-f_i$ 为负时：

$\sum abs(c_i-f_i)\times (-b_i-d_i-mid)<0$

我们考虑它的实际意义，观察二分性质。

我们二分出的 $mid$ 对应的是 $\dfrac{X-Y}{k}$ 的最大值，也就是说不存在 $\sum abs(c_i-f_i)\times ((-)d_i+a_i(b_i)-mid)>0$

如果我们在原本的图的基础上建立一个新图：

- $v_i\to u_i$ 是一条边权为 $-a_i+d_i-mid$ 的边。（因为这时候 $abs(c_i-f_i)>0$ 对应的是 $v_i\to u_i$，也就是压缩一次）

- $u_i\to v_i$ 是一条边权为 $-b_i-d_i-mid$ 的边。（原因同理）

那么如何判断是否有大于 `0` 的情况捏？

同时还要注意一个隐藏条件，每个点的出入度是不变的，也就是说我们要选一个环使得他的和大于 `0`。

我们发现不好判断，判正环那比的上判负环。

所以我们把边权全部都乘上 $-1$。

问题得解，只需要在新图之上判断是否存在负环即可！
若有负环，说明 $mid$ 太小。否则是 $mid$ 太大。

注意，你的 $v_i\to u_i$ 的前提是 $c_i>0$。

其余的就看代码吧。

### CODE

```cpp
#include<bits/stdc++.h>
#define N 1000006
const double eps=1e-9;
const int inf=1e9;
using namespace std;
int read()
{
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
int n,m,head[N],tot;
struct fig
{
	int to,next;
	double val,ini;
}k[N];
double dis[N];
bool vis[N];
void add(int from,int to,int val)
{
	k[++tot].to=to;
	k[tot].next=head[from];
	k[tot].ini=(double)val;
	head[from]=tot;
}
bool spfa(int now)
{
	vis[now]=1;
	for(int i=head[now],to;i;i=k[i].next)
	{
		to=k[i].to;
		if(dis[to]>dis[now]+k[i].val)
		{
			dis[to]=dis[now]+k[i].val;
			if(vis[to]||spfa(to))return 1;
		}
	}
	vis[now]=0;
	return 0;
}
bool check(double mid)
{
	for(int i=1;i<=tot;i++)k[i].val=k[i].ini+mid;
	for(int i=1;i<=n;i++)dis[i]=0,vis[i]=0;
	for(int i=1;i<=n;i++)
	{
		if(spfa(i))
		return 1;
	}
	return 0;
}
int main()
{
	n=read()+2;m=read();
	for(int i=1,u,v,a,b,c,d;i<=m;i++)
	{
		u=read();v=read();a=read();
		b=read();c=read();d=read();
		add(u,v,b+d);
		if(c!=0)add(v,u,a-d);
	}
	double l=0,r=inf,mid;
	while(r-l>eps)
	{
		mid=(l+r)/2.0;
		if(check(mid))l=mid;
		else r=mid;
	}
	printf("%.2f",r);
	return 0;
}
```

---

## 作者：凄魉 (赞：2)

这个题您们的这个找负环很优秀啊，不仅思路很对很正确，复杂度也吊锤我费用流啊……

但是直接费用流也可以啊QAQ(当然要先二分)

建图思路：你发现增加就是增广，但压缩这个减少不太好搞啊，这时候我们有一个比较妙的思路，先把这张图给压缩没，然后我们再反悔（类似于网络流中的反向边思路）。

即对于除起点的那条边外，对一条边$(u,v,a,b,c,d)$在费用流中建两条边：(假设当前二分的值为$mid$)

$u->v$建一条容量为$c$，费用为$d-a-mid$的边，这条边的含义为我们一开始把每条边都给压缩没了，但是这显然不是最优的，那么我们反悔的时候也就是增广了（反悔压缩==增广）。

$u->v$再建一条容量为$\infty$，费用为$d+c+mid$的边，这条边的含义就是题目中的扩容。

这样最小费用最大流过后，我们的实际费用为 原图每条边的容量$\times$（单位压缩费用+$mid$）+网络流跑出来的费用。

每次二分就check当前跑出来的费用能不能严格小于原来的费用就ok了，我自认为代码还是写的比较清楚，有没讲明白的地方就私信我吧QAQ

```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<cmath>
using namespace std;
#define INF 0x3f3f3f3f
#define M 51000
#define N 5010
const double eps=1e-4;
struct node{
	int fr,to,next,res;double d;
}q[M];
struct Edge{
	int fr,to,a,b,c,d;
}E[3010];
int head[N],ss,flow[N],lst[N],que[N<<6],S,T,m;double dis[N],X;bool inq[N];
void addedge(int x,int y,int r,double d)
{
	q[++ss]=(node){x,y,head[x],r, d};head[x]=ss;
	q[++ss]=(node){y,x,head[y],0,-d};head[y]=ss;
}
bool spfa()
{
	memset(flow,0x3f,sizeof(flow));
	int f=1,e=0;
	for (int i=0;i<=T;++i) dis[i]=1ll<<60;
	que[++e]=S;dis[S]=0;
	while(f<=e)
	{
		int u=que[f++];
		inq[u]=false;
		for (int j=head[u];~j;j=q[j].next)
			if (q[j].res&&dis[q[j].to]>dis[u]+q[j].d)
			{
				int t=q[j].to;
				dis[t]=dis[u]+q[j].d;
				flow[t]=min(flow[u],q[j].res);
				lst[t]=j;
				if (!inq[t]) que[++e]=t,inq[t]=true;
			}
	}
	return dis[T]<(1ll<<59);
}
bool check(double C)
{
	memset(head,-1,sizeof(head));ss=-1;double all=0;
	for (int l=1;l<=m;++l)
		if (E[l].fr==S) addedge(E[l].fr,E[l].to,E[l].c,E[l].d);
		else
		{
			addedge(E[l].fr,E[l].to,E[l].c,-E[l].a-C+E[l].d);
			addedge(E[l].fr,E[l].to,INF,E[l].b+C+E[l].d);
			all+=(E[l].a+C)*E[l].c;
		}
	while(spfa())
	{
		all+=dis[T]*flow[T];
		for (int i=T;i^S;i=q[lst[i]].fr)
		{
			q[lst[i]].res-=flow[T];
			q[lst[i]^1].res+=flow[T];
		}
	}
	return X-all>eps;
}
int main()
{
	int n;double l=0,r=0,mid;
	scanf("%d%d",&n,&m);S=n+1;T=n+2;
	for (int i=1;i<=m;++i)
	{
		scanf("%d%d%d%d%d%d",&E[i].fr,&E[i].to,&E[i].a,&E[i].b,&E[i].c,&E[i].d);
		r+=E[i].c*E[i].d;
	}
    X=r;
	while(r-l>eps)
	{
		mid=(l+r)/2;
		if (check(mid)) l=mid;
		else r=mid;
	}
	printf("%.2lf",l);
	return 0;
}
```

---

## 作者：xwh_hh (赞：1)

打了网络流标签却不用网络流板子的题。  
先说一个简单问题：求给定图平均边权最小的环。  
这个比较典，二分平均边权 $x$，将图中所有边边权减小 $x$，只需判图中是否有负环即可，spfa。  
显然最优环一定是简单环（否则将环分裂，必有一个不劣）。  
然后想这个问题，显然交通量无法增加（因为从起点出发的边不可调整），同时要求不能减少，故只能不变。  
考虑残量网络，对于每一条可修改的边，增大流量相当于花 $b+d$ 的代价增加 $1$ 的流量，减小流量（要求初始流量不为零）相当于花 $a-d$ 的代价减小 $1$ 的流量（即反向边增大 $1$ 的流量）。  
为保持流量平衡，必然修改环。为使最优调整比率最大，显然只能动 $1$ 个平均边权最小的环。使用上述方法即可。  
复杂度最坏 $O(nmh)$，$h$ 为二分次数，可过。
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
struct edge{
	int v;
	double w;
};
vector<edge>g[5005];
queue<int>q;
int vis[5005];
double dis[5005];
bool h[5005];
bool spfa(int u){
	memset(h,0,sizeof(h));
	memset(vis,0,sizeof(vis));
	fill(dis+1,dis+1+n,1e10);
	q=queue<int>();
	dis[u]=0;
	q.push(u);
	vis[u]=1;
	while(!q.empty()){
		int u=q.front(); q.pop();
		vis[u]++;
		h[u]=0;
		if(vis[u]>n) return true;
		for(int i=0;i<g[u].size();i++){
			if(dis[g[u][i].v]>dis[u]+g[u][i].w+1e-6){
				dis[g[u][i].v]=dis[u]+g[u][i].w;
				if(!h[g[u][i].v]){
					q.push(g[u][i].v);
					h[g[u][i].v]=1;
				}
			}
		}
	}
	return false;
}
int s;
int main(){
	cin>>n>>m; n+=2;
	for(int i=1;i<=m;i++){
		int u,v,a,b,c,d;
		cin>>u>>v>>a>>b>>c>>d;
		if(c)g[v].push_back({u,a-d});
		g[u].push_back({v,b+d});
		if(u==n-1) s=v;//起点边不能改
	}
	double l=-3e4,r=3e4;
	while(l+1e-4<r){
		double m=(l+r)/2;
		for(int i=1;i<=n;i++){
			for(int j=0;j<g[i].size();j++){
				g[i][j].w-=m;
			}
		}
		if(spfa(s)) r=m;
		else l=m;
		for(int i=1;i<=n;i++){
			for(int j=0;j<g[i].size();j++){
				g[i][j].w+=m;
			}
		}
	}
	cout<<fixed<<setprecision(2)<<-l;//注意比率定义
	return 0;
}
```

---

## 作者：沉辰 (赞：1)

解：  
分数规划+负环   
我们一开始会想到网络流。    

首先我们假设图中一开始流量为0，目前我们处于增广阶段，那么对于题目中的两种调整方式  
压缩  就相当于增广时退流   
扩容  就相当于不断增广   
因为要“调整之后，必须要保持每条道路满负  荷，且总交通量不会减少”，那么单纯扩容显然是不会更优的  
可能存在的更优方案为   在保证最大流不变的情况下使得压缩的扩容的总费用加起来最少。
也就是说存在如下残量网络：   
扩容  u -> v  花费 b+d   
压缩  （即相当于反向边有流量的话） 满足 c>0 时 v -> u  花费  -(b-a) 即a-b  



然后我们考虑对问题求解，（这一看就是分数规划） 我们就想起了二分。  
假设当前答案为 ans ,令 Z=X-Y  
那么不优的情况一定满足 Z >= ans * k 也就是 Z - ans * k >=0  
==> ans * k -Z <= 0  
Z=X-Y 也就是说 Z=调整之前的总费用是 - 调整后的总费用  

也就是  Z=Σ我们在残量网络中走过的边权和  k=我们在残量网络中经过的点   
到这里，我们要知道一个定理。   
消圈定理   
所谓消圈定理，就是在某个流 ff 中，如果其对应的残余网络没有负圈（剩余流量为 00 的边视为不存在），

那它一定就是当前流量下的最小费用流  。

反之亦然。即「ff 是最小费用流等价于其残余网络中没有负圈」。

有了这个定理，我们就好做了。  
我们二分ans,将每条边边权加上ans（把Σ降掉），判断是否存在负环  
搞定。

还不懂得看代码吧。  
[代码](http://www.cnblogs.com/adelalove/p/8496554.html)

---

## 作者：MrMorning (赞：1)

#题解

目标就是

$$Maximize\ \lambda = \frac{X-Y}{k}$$

按照分数规划的一般规律，

构造：

$$g(\lambda) = \lambda k + Y - X$$

由于总流量不变，我们考虑转移流量。

注意到，对于每条边，我们如果增加其容量则会增加(b[i]+d[i]+lambda)点值，如果减少就是(a[i]-d[i]+lambda)点值。

如果可以构成一个负环，那么就一定可以更优。

所以我们二分$\lambda$，check即可。

#代码

```cpp
#include <bits/stdc++.h>
using namespace std;
#define eps 1e-5
struct haha {
  int x, y, a, b, c, d;
};
struct edge {
  int from, to;
  double cost;
};
const int maxn = 5005;
vector<edge> G[maxn];
haha b[maxn];
int n, m;
int vis[maxn], flag;
double dist[maxn];
void add_edge(int from, int to, double cost) {
  G[from].push_back((edge){from, to, cost});
}
void dfs(int i) {
  vis[i] = 1;
  for (int j = 0; j < G[i].size(); j++) {
    edge &e = G[i][j];
    if (dist[e.to] > dist[i] + e.cost) {
      if (vis[e.to])
        flag = 1;
      else {
        dist[e.to] = dist[i] + e.cost;
        dfs(e.to);
      }
    }
  }
  vis[i] = 0;
}
bool check(double lambda) {
  for (int i = 1; i <= n; i++)
    G[i].clear();
  for (int i = 1; i <= m; i++) {
    if (b[i].c)
      add_edge(b[i].y, b[i].x, b[i].a - b[i].d + lambda);
    add_edge(b[i].x, b[i].y, b[i].b + b[i].d + lambda);
  }
  flag = 0;
  memset(vis, 0, sizeof(vis));
  memset(dist, 0, sizeof(dist));
  for (int i = 1; i <= n && !flag; i++) {
    dfs(i);
  }
  return flag;
}
int main() {
  // freopen("input", "r", stdin);
  scanf("%d %d", &n, &m);
  n += 2;
  for (int i = 1; i <= m; i++)
    scanf("%d%d%d%d%d%d", &b[i].x, &b[i].y, &b[i].a, &b[i].b, &b[i].c, &b[i].d);
  double L = 0, R = 10000000;
  while (R - L > eps) {
    double mid = (L + R) / 2;
    if (check(mid))
      L = mid;
    else
      R = mid;
  }
  printf("%.2f\n", L);
}
```
#总结

1. 图上的分数规划问题要考虑分摊到每个边上。

2. 分数规划问题要注意double的赋值。


最后做一个广告：欢迎访问[我的博客](www.cnblogs.com/gengchen)


---

## 作者：complete_binary_tree (赞：0)

[原题传送门](https://www.luogu.com.cn/problem/P3288)

看到容量的增加，很容易想到网络流的退流和增广。

所以，可以把增加容量看成 $u \to v$ 连接一条 $b + d$ 的边（$b$ 扩容费用，$d$ 维护费用），减少容量看成 $v \to u$ 连接一条 $a - d$ 的边（$a$ 减容费用，$d$ 维护费用）。

这样就可以开心的跑网络流……了？不对，题目要求 $\frac{X - Y}{k}$，还要保留两位小数。

考虑分数规划。如果 $\frac{X - Y}{k} < mid$，那么 $X - Y < k \cdot mid$。

考虑 $X - Y$ 是什么。$Y = X + \sum w$，所以说 $-\sum w < k \cdot mid$。

又 $k$ 是经过的边数，也就是可以把 $mid$ 合并到每条边上，即 $-\sum_1^k (mid + w) < 0$。所以我们把每个边权加上 $mid$，然后跑 $\text{SPFA}$ 判负环，有负环答案往上调，$l = mid$，否则 $r = mid$。

时间复杂度 $O(nm \log V)$。代码：

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N = 5e3 + 5, M = 3e3 + 5;

int n, m, u[M], v[M], a[M], b[M], c[M], d[M];

struct edge {
    int to, nxt; double w;
    edge() {}
    edge( int to, double w, int nxt ) : to( to ), nxt( nxt ), w( w ) {}
} e[M << 1];
int head[N], cnt;
void add( int u, int v, double w ) { e[++cnt] = edge( v, w, head[u] ), head[u] = cnt; }

void prework( double k ) {
    cnt = 0;
    memset( head, 0, sizeof head );
    for( int i = 1; i <= m; ++i ) {
        if( c[i] ) add( v[i], u[i], k + a[i] - d[i] );
        add( u[i], v[i], k + b[i] + d[i] );
    }
}

int vis[N], inq[N];
double dis[N];

bool spfa() {
    queue<int> q;
    q.push( n + 1 );
    memset( vis, 0, sizeof vis );
    memset( inq, 0, sizeof inq );
    for( int i = 1; i <= n + 2; ++i ) dis[i] = 1e9;
    dis[n + 1] = 0;
    while( !q.empty() ) {
        int u = q.front(); q.pop();
        inq[u] = 0;
        for( int i = head[u]; i; i = e[i].nxt ) {
            int v = e[i].to;
            if( dis[u] + e[i].w < dis[v] ) {
                dis[v] = dis[u] + e[i].w;
                if( !inq[v] ) {
                    inq[v] = 1;
                    q.push( v );
                    vis[v]++;
                    if( vis[v] > n ) return 1;
                }
            }
        }
    }
    return 0;
}

int main(){
    scanf( "%d%d", &n, &m );
    for( int i = 1; i <= m; ++i )
        scanf( "%d%d%d%d%d%d", &u[i], &v[i], &a[i], &b[i], &c[i], &d[i] );
    double l = 0, r = 1e9;
    while( r - l >= 1e-5 ) {
        double mid = 0.5 * ( l + r );
        prework( mid );
        if( spfa() ) l = mid;
        else r = mid;
    }
    printf( "%.2lf", l );
    return 0;
}
```

---

## 作者：Day_Dreamer_H (赞：0)

# P3288 题解
## 题目大意
$N+2$ 个点，$M$ 条有向边，每条边从 $u_i$ 到 $v_i$，第 $i$ 条边可以增加一点容量代价为 $b_i$ 或减小一点容量代价为 $a_i$ 以及当前容量 $c_i$ 和一单位通过所需的代价 $d_i$。

要求最后**每条边仍然是满流量而且总交通量不变**，求调整后总费用与调整前总费用之差除以调整次数。
## 思路
一眼分数规划。

首先我们试着满足流量不变的条件，那我们肯定不能只加不减了。

然后我们要把原图中的每一条边拆成两个，分别是 $u_i$ 到 $v_i$，边权为 $a_i-d_i$ 和 $v_i$ 到 $u_i$，边权为 $b_i+d_i$。

这里的边权就是我们增加或减少一点流量所能造成的总代价（操作代价加通过当前边代价）。

我们要知道有这么一件事：**一个流是当前流量下的最小费用流，相当于当前残量网络上没有负费用圈**。

那么就是要判断是否存在负环，若存在则 $l=mid$，反之 $r=mid$。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const double eps = 1e-5;
int n,m;
int vis[5005];
double dis[5005];
vector<pair<int,int> >adj[5005];
bool spfa(int x,double y){
//	cout<<q.front()<<" "<<q.size()<<endl;
	vis[x] = true;
	for(int j = 0;j<adj[x].size();j++){
//		cout<<" from "<<cur<<" to "<<adj[cur][j].first<<endl;
		if(dis[adj[x][j].first]>dis[x]+adj[x][j].second+y){
//			cout<<"?";
			dis[adj[x][j].first] = dis[x]+adj[x][j].second+y;
			if(vis[adj[x][j].first]||spfa(adj[x][j].first,y))return true;
		}
	}
	vis[x] = false;
	return false;
}
bool check(double x){
	memset(vis,0,sizeof(vis));
	memset(dis,0,sizeof(dis));
	for(int i = 1;i<=n;i++){
		if(spfa(i,x)){
			return true;
		}
	}
	return false;
}
int main(){
	cin>>n>>m;
	n+=2;
	for(int i = 0;i<m;i++){
		int u,v,a,b,c,d;
		scanf("%d %d %d %d %d %d",&u,&v,&a,&b,&c,&d);
		if(c!=0)adj[v].push_back(make_pair(u,a-d));
		adj[u].push_back(make_pair(v,b+d));
	}
	double l = 0,r = 1e9;
	while(r-l>eps){
		double mid = (l+r)/2;
		if(check(mid)){
			l = mid;
		}else{
			r = mid;
		}
	}
	printf("%.2f",r);
	return 0;
}
```

---

## 作者：minkite (赞：0)

###   概念
$\qquad$流量：每条边经过的次数

   $\qquad$原点：流量的来源。
   
   $\qquad$汇点:流量的最终终点（在本题对应终点）。
   
   $\qquad$残量网络：这条边（流）中还能有多少流量通过。



$\qquad$首先，题目要求总交通量不变，所以我们要求总交通守恒，不生产，只搬运。

$\qquad$我们可以对应扩容和压缩对应建两条边：

$\qquad$压缩$(v,u,ai-di)$（从$v$到$u$有一条边权$ai-di$的路）边权为$ai-di$是因为压缩$1$，花费$ai$，但减少$1$个单位，费用减少$di$。之所以要从$(v,u)$从$u$走到$v$之后，如果想压缩可以再从$v$走向$u$，把第一次带过去的流量换回去，相当于悔棋。

$\qquad$扩容$ ( u,u,ai+di) $（从$u$到$u$有一条边权$ai+di$的路）边权为$bi+di$是因为扩容$1$，花费$bi$，增加$di$,如果想扩容，就可以从自己再跑向自己，达到扩容。

$\qquad$我们令$tot=max( \dfrac{x-y}{k})$ 即$tot\ge \dfrac{x-y}{k}$

所以$tot*k \ge x-y$

$\qquad$我们二分$mid$调整比率，也就是$tot-k$我们可以发现$k$实际上就是在我们在初始化时建的新图上跑一次边数，因为实际上每一条边都是以次调节。我们还可以把$X-Y$转化为$X-(X+\sum{}{}di)$也就是$-X$
所以问题就变成了比较$mid*k$与$-\sum{}{}di$的大小。若$(mid*k)+\sum{}{}di$小于零，$mid*k$小于$X-Y$，否则$mid*k$大于$X-Y$,题目就变成了求负环。
代码


---

## 作者：miaowey (赞：0)

本题可以用分数规划（这是什么？TAT）做啊。。。。

它的思路是这个样子的：先想了一下，加容量等于是在原来的基础上加了一条无限容量的价格为a-d的边，减容量等于是在原来的基础上加了一条容量为c的价格为b+d的边（因为必须满流）,然而题目所求的是比率。可以发现因为必须满流且总流量不变，所以流量是在各个路上转移的，所以前面所说要加的边可以形成环，每一个环代表一种流量转移的方案。再思考可以发现，比率与到底我流这个环的流量多少没有关系，那么就可以直接看最大负权环除以环中的节点个数即可（节点个数等于环个数），那么接下来的事情就是用spfa和二分了！！！









    

        
            


    




    
```cpp
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<iostream>
#include<algorithm>
#include<vector>
#include<queue>
using namespace std;
#define LL long long
#define pb push_back
#define Set(a, v) memset(a, v, sizeof(a))
#define For(i, a, b) for(int i = (a); i <= (int)(b); i++)
#define Forr(i, a, b) for(int i = (a); i >= (int)(b); i--)
#define MAXN (5000+5)
#define INF 0x3f3f3f3f
struct node{
    int v, dis;
};
int n, s, t, num[MAXN];
vector<node> G[MAXN];
double dis[MAXN];
bool inq[MAXN];
bool spfa(double add){
    queue<int> q;
    Set(inq, 0); Set(num, 0);
    For(i, 1, n) dis[i] = INF*1.0;
    inq[s] = true; dis[s] = 0;
    q.push(s);
    while(!q.empty()){
        int now = q.front(); q.pop();
        inq[now] = false;
        if(num[now] > n) return true;
        For(i, 0, G[now].size()-1){
            int v = G[now][i].v;
            double nd = add + (double)G[now][i].dis;
            if(dis[v] > dis[now]+nd){
                dis[v] = dis[now]+nd;
                if(!inq[v]){
                    num[v]++; inq[v] = true;
                    q.push(v);
                }
            }
        }
    }
    return false;
}
int main(){
    freopen("test.in", "r", stdin);
    freopen("test.out", "w", stdout);
    int m;
    scanf("%d%d", &n, &m);
    s = n+1, t = n+2;
    n += 2;
    double L = 0, R = 0;
    For(i, 1, m){
        int u, v, a, b, c, d;
        scanf("%d%d%d%d%d%d", &u, &v, &a, &b, &c, &d);
 //       if(u == s || v == s) continue;
        if(c) G[v].pb((node){u, a-d});
        G[u].pb((node){v, b+d});
        if(a-d < 0) R += d-a;
    }
    while(R-L > 1e-3){
        double mid = (L+R)/2;
        if(spfa(mid)) L = mid;
        else R = mid;
    }
    printf("%.2lf\n", L);
    return 0;
}

```

---


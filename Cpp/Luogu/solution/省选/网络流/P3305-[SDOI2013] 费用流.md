# [SDOI2013] 费用流

## 题目描述

Alice 和 Bob 在图论课程上学习了最大流和最小费用最大流的相关知识。

> 最大流问题：给定一张有向图表示运输网络，一个源点 $S$ 和一个汇点 $T$ ，每条边都有最大流量。
> 
> 一个合法的网络流方案必须满足：
> 
> 1. 每条边的实际流量都不超过其最大流量且非负；
> 2. 除了源点 $S$ 和汇点 $T$ 之外，对于其余所有点，都满足该点总流入流量等于该点总流出流量；而 $S$ 点的净流出流量等于 $T$ 点的净流入流量，这个值也即该网络流方案的总运输量。
>
> 最大流问题就是对于给定的运输网络，求总运输量最大的网络流方案。

![](https://cdn.luogu.com.cn/upload/image_hosting/20ipdo37.png)

上图表示了一个最大流问题。对于每条边，右边的数代表该边的最大流量，左边的数代表在最优解中，该边的实际流量。需要注意到，一个最大流问题的解可能不是唯一的。

对于一张给定的运输网络，Alice 先确定一个最大流，如果有多种解，Alice 可以任选一种；之后 Bob 在每条边上分配单位花费（单位花费必须是非负实数），要求所有边的单位花费之和等于 $P$。

总费用等于每一条边的实际流量乘以该边的单位花费。需要注意到，Bob 在分配单位花费之前，已经知道 Alice 所给出的最大流方案。现在 Alice 希望总费用尽量小，而 Bob 希望总费用尽量大。我们想知道，如果两个人都执行最优策略，最大流的值和总费用分别为多少。


## 说明/提示

**【样例说明】**

对于 Alice，最大流的方案是固定的。两条边的实际流量都为 $10$。

对于 Bob，给第一条边分配 $0.5$ 的费用，第二条边分配 $0.5$ 的费用。总费用为：$10\times 0.5+10\times 0.5=10$。可以证明不存在总费用更大的分配方案。

**【数据规模和约定】**

对于 $20\%$ 的测试数据，所有有向边的最大流量都是 $1$。

对于 $100\%$ 的测试数据，$N\le 100$，$M\le 1000$。

对于 $100\%$ 的测试数据：所有点的编号在 $1\sim N$ 范围内，$1 \le \text{每条边的最大流量} \le 50000$，$1\le P\le 10$，给定运输网络中不会有起点和终点相同的边。


## 样例 #1

### 输入

```
3 2 1
1 2 10
2 3 15```

### 输出

```
10
10.0000```

# 题解

## 作者：硫代硫酸钠 (赞：8)

首先不要被标题迷惑哦,这个题跟费用流关系不大.

然后就是重边,个人认为重边不应去除,理由如下:

显然根据本题的模型,在答案的最大流方案中流量最高的边收费p即可.

这样就导致简单合并边可能不对. ~~虽然这种做法能骗到80~~

正解:

在答案的最大流方案中流量最高的边收费p,要求答案最大流方案流量最多的边实际流量最小.考虑二分流量上界,对于上界判断是否能形成最大流.

本蒟蒻第一道实数二分...

```cpp
#include<algorithm>
#include<cctype>
#include<cmath>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<iostream>
#include<map>
#include<queue>
#include<stack>
#include<vector>
#define size 500010
#define debug(x) cerr<<#x<<"="<<x
#define gc getchar()
#define tp to[p]
#define inf 1e9+9
#define eps 1e-5
#define ll long long
#define db double
#define rep(i,s,n) for (register int i=s;i<=n;i++)
#define drep(i,n,s) for (register int i=n;i>=s;i--)
#define il inline
using namespace std;

il ll r()
{
    char c; ll x,f=1;
    for (c=gc;!isdigit(c);c=gc) if (c=='-') f=-1; x=c-'0';
    for (c=gc;isdigit(c);c=gc) x=(x<<1)+(x<<3)+c-'0';
    return f*x;
}

int head[size],to[size],nxt[size],num=1,S,T,sta[size],q[size],n,m,cur[size];
db mx,len[size],lim=1e15,lenn[size],p;

void add(int x,int y,db z)
{
    num++; to[num]=y;lenn[num]=z; nxt[num]=head[x];head[x]=num;
}

void create(int x,int y,db z) { add(x,y,z); add(y,x,0); }

bool bfs()
{
	int f=0,r=0;
	memset(sta,-1,sizeof(sta));
	q[++r]=S,sta[S]=0;
	while (f<r)
	{
		int x=q[++f]; 
		for (int p=head[x];p;p=nxt[p])
			if (len[p]>0&&sta[tp]==-1) sta[tp]=sta[x]+1,q[++r]=tp;		
	}
	if (~sta[T]) return 1; return 0; 
}

db dfs(int x,db flow)
{
	if (x==T) return flow;
	db now=0,used=0;
	for (int &p=cur[x];p;p=nxt[p])
		if (len[p]>0&&sta[tp]==sta[x]+1)
		{
			now=dfs(tp,min(len[p],flow-used)); used+=now;
			len[p]-=now; len[p^1]+=now; if (used==flow) break;
		}
	return used; 
}

void init()
{
	rep(i,1,num) len[i]=min(lenn[i],lim); 
}

db dinic()
{
	db ans=0;
	while (bfs())
	{
		rep(i,1,n) cur[i]=head[i];
		ans+=dfs(S,1e9+7); 
	}
	return ans;
}

int main()
{
    n=r(),m=r(); S=1,T=n; cin>>p;
    rep(i,1,m) 
    {
    	int x,y; db z;
       	scanf("%d%d%lf",&x,&y,&z); create(x,y,z);
    }
    init(); 
    db mf=dinic();printf("%.4lf\n",mf);
	db lb=0,rb=1e9,ans=0;
	while (rb-lb>0.00001) 
	{
		db mid=(lb+rb)/2;
		lim=mid; init();
		db nowflow=dinic();
		if (fabs(nowflow-mf)<0.00001) rb=mid,ans=mid;
		else lb=mid; 
	}
    lim=ans; init(); int t=dinic();  db mx=0;
    for (int i=1;i<=num;i+=2)  mx=max(mx,len[i]); printf("%.5lf",mx*p); 
    return 0;
}

```

---

## 作者：我的妹妹syf (赞：6)

题目做了一年，终于调出来了。

二分+最大流，好像时间复杂度要求不高，不过有些东西要注意到。

1、有重边，T的话有可能是因为这个。

2、应该对小数进行二分，解释起来有点烦，但一定要考虑到。

邻接表+dinic，略长，第一次用dinic。







```cpp
#include<iostream>
#include<algorithm>
#include<cstring>
#include<cstdio>
#include<iomanip>
#include<queue>
using namespace std;
struct Edge{
    double va;
    int to,fx;
    Edge(){}
    Edge(int a,double b,int c):to(a),va(b),fx(c){};
};
double GX(double a,double b){
    if(a<b) return a;
    return b;
}
queue<int> q;
int n,m,s,t;
vector<Edge> lu[128],cop[128];
int dis[128];
int done[128];
int ans;
double dfs(int pl,double p){
    if(pl==t) return p;
    double f;
    int len=lu[pl].size();
    for(int i=0;i<len;i++){
        Edge &now=lu[pl][i];
        if(now.va&&dis[now.to]==dis[pl]+1){
            f=dfs(now.to,GX(p,now.va));
            if(f){
                now.va-=f;
                lu[now.to][now.fx].va+=f;
                return f;
            }
        }
    }
    return 0;
}
bool bfs(){
    int st,len;
    q.push(1);
    memset(dis,-1,sizeof(dis));
    dis[1]=0;
    while(!q.empty()){
        st=q.front();
        q.pop();
        len=lu[st].size();
        for(int i=0;i<len;i++){
            Edge &now=lu[st][i];
            if(now.va&&dis[now.to]==-1){
                dis[now.to]=dis[st]+1;
                q.push(now.to);
            }
        }
    }
    return dis[t]!=-1;
}
bool pc(double a){
    double tot=0;
    double f;
    for(int i=1;i<=n;i++){
        memset(done,-1,sizeof(done));
        for(int j=0;j<lu[i].size();j++){
            if(done[lu[i][j].to]==-1){
                lu[i][j].va=GX(a,cop[i][j].va);
                done[lu[i][j].to]=j;
            }
            else{
                lu[i][done[lu[i][j].to]].va+=GX(a,cop[i][j].va);
            }
        }
    }
    while(bfs()){
        while((f=dfs(1,a))&&f>0.00001) tot+=f;
    }
    return tot==ans;
}
int main(){
    cin>>n>>m>>s;
    t=n;
    for(int i=0;i<m;i++){
        int a,b;
        double c;
        cin>>a>>b>>c;
        cop[a].push_back(Edge(b,c,cop[b].size()));
        cop[b].push_back(Edge(a,0.0,cop[a].size()-1));
        lu[a].push_back(Edge(b,0.0,lu[b].size()));
        lu[b].push_back(Edge(a,0.0,lu[a].size()-1));
    }
    int f;
    for(int i=1;i<=n;i++){
        memset(done,-1,sizeof(done));
        for(int j=0;j<lu[i].size();j++){
            if(done[lu[i][j].to]==-1){
                lu[i][j].va=cop[i][j].va;
                done[lu[i][j].to]=j;
            }
            else{
                lu[i][done[lu[i][j].to]].va+=cop[i][j].va;
            }
        }
    }
    while(bfs()){
        while(f=dfs(1,1008610086)) ans+=f;
    }
    cout<<ans<<"\n";
    double l=0,r=100000086,mid;
    while(r-0.00001>l){
        mid=(l+r)/2;
        if(!pc(mid)) l=mid+0.00001;
        else r=mid;
    }
    cout<<fixed<<setprecision(4)<<double(l*s)<<"\n";
    return 0;
}-
```

---

## 作者：TheAutumnGlory (赞：4)

~~这道题标题写着费用流，可好像实际上跟费用流没有甚关系（这不是废话吗，不然nodgd给你放在最大流里干嘛 雾）~~

### 题意：
给出一个图，然后$Alice$在图上 ~~（很臭不要脸的）~~ 先跑一个最大流，只要每个节点流入量=流出量就是一个合法的“最大流”，

然后$Bob$选一些边加费用，所有边的加的最费用=P。

总费用$=\sum$ 每条边的实际流量 $\times$ 这条边的费用

然后$Ailce$希望最终的总费用最小，$Bob$希望最终的总费用最大。且都采用**最优策略**，求出最大流和总费用。

----
显然$Bob$的策略为：
> 哪里流量大，就把费用一次性全给它那一条边
>
> 也就找到实际流量最大的一条边，将这条边的费用为P，**总费用=实际流量$\times$P**

$Alice$的策略为：
> 让实际流量最大的边，最后流出的流量最小且合法

-----

#### 实现：

第一步：求原图最大流一次。
第二部：求最大实际流量的最小值（~~显然~~**二分**）
> 验证 最大实际流量=K 是否可行

> 将原图的容量大于>K的边的容量设为K

> 然后求最大流，验证是否等于原来的最大流即可


**小技巧：因为原图不变，变的只是权值，所以可以只修改边权，而不用重新建图 ~~（其实也快不了多少）~~**

$code(isap):$
```
#include<bits/stdc++.h>
using namespace std;
const int N=2005;
const int M=10005;
const double inf=1e10;
int n,m,p,S,T,w[N];
int Next[M],End[M],tot;
int Last[N],_last[N],dis[N],gap[N];
double len[M],flow_past;
void cb(int x,int y,int z,int z0=0){
    End[tot]=y,Next[tot]=Last[x],len[tot]=z,Last[x]=tot++;
    End[tot]=x,Next[tot]=Last[y],len[tot]=z0,Last[y]=tot++;
}
void cg(double z){
    len[tot++]=z;
    len[tot++]=0;
}
void bfs(){
    for(int i=1;i<=T;i++) dis[i]=n,gap[i]=0;
    gap[0]=0;
	dis[n]=0;
    queue<int> q;
    q.push(n);
    while(q.size()){
        int x=q.front();
        q.pop();
        for(int i=Last[x];i;i=Next[i]){
            int y=End[i];
            if(dis[y]>dis[x]+1){
                dis[y]=dis[x]+1;
                q.push(y);
            }
        }
    }
    for(int i=1;i<=T;i++) gap[dis[i]]++,_last[i]=Last[i];
}
double isap(int x,double flow){
    if(x==T) return flow;
    double flow_now=0;
    for(int &i=_last[x];i;i=Next[i]){
        int y=End[i];
        if(len[i]>1e-10 && dis[x]==dis[y]+1){
            double f=isap(y,min(flow-flow_now,len[i]));
            flow_now+=f;
            len[i]-=f;
            len[i^1]+=f;
            if(flow_now+1e-10>=flow || dis[S]==n) return flow_now;
        }
    }
    gap[dis[x]]--;
    if(!gap[dis[x]]) dis[S]=n;
    dis[x]++;
    gap[dis[x]]++;
    _last[x]=Last[x];
    return flow_now;
}
bool check(double k){
    tot=2;
    for(int i=1;i<=m;i++) cg(min((double)w[i],k));
    double flow=0;
    bfs();
    while(dis[S]<T) flow+=isap(S,inf);
    if(flow+1e-10<flow_past) return false;
    return true;
}
int main(){
    scanf("%d %d %d",&n,&m,&p);
    S=1,tot=2,T=n;
    int maxn=0;
    for(int i=1;i<=m;i++){
        int x,y;
        scanf("%d %d %d",&x,&y,&w[i]);
		cb(x,y,w[i]);
        maxn=max(maxn,w[i]);
    }
    bfs();
    while(dis[S]<T) flow_past+=isap(S,inf);
    printf("%0.lf\n",flow_past);
    double l=1,r=maxn+1,ans=0;
    while(r-l>1e-7){
        double mid=(l+r)*0.5;
        if(check(mid)) r=mid;
        else l=mid;
    }
    printf("%.4lf\n",l*p);
    return 0;
}
```

---

## 作者：gyh20 (赞：2)

二分 + 网络流

初看可能像博弈论，但有一个重要的条件： Bob 在 Alice 选之后选。所以说，作为 Bob 就会把所有费用放在 Alice 经过边上流量最大的边。

二分答案，判断最大边流量不超过 $x$ 的时候是否有最大流。

```cpp
#pragma GCC optimize(2)
#pragma GCC optimize(3)
#pragma GCC optimize("Ofast")
#pragma GCC optimize("inline")
#include<cstdio>
#include<queue>
#include<cstring>
#define re register
#define in inline
using namespace std;
const int Mxdt=5000;	 
inline char gc(){
	static char buf[Mxdt],*p1=buf,*p2=buf;
	return p1==p2&&(p2=(p1=buf)+fread(buf,1,Mxdt,stdin),p1==p2)?EOF:*p1++;
}
inline int read()
{
	int res=0;char ch=gc();
	while(ch<'0')ch=gc();
	while(ch>='0')res=(res<<3)+(res<<1)+(ch^48),ch=gc();
	return res;
}
inline double min(re double x,re double y){
	return x<y?x:y;
}
struct edge{
	int to,next;
	double w;
}e[2002],e1[2002];
int n,dis[102],gap[102],mxd,ans,cnt=1,head[102],m,s,t,a,b,c,v[102],p;
double dlt;
queue<int>q;
inline void add(re int x,re int y,re int z){
	e1[++cnt].to=y;
	e1[cnt].w=z;
	e1[cnt].next=head[x];
	head[x]=cnt;
	e1[++cnt].to=x;
	e1[cnt].w=0;
	e1[cnt].next=head[y];
	head[y]=cnt;
}
inline double dfs(re int x,re double y){
	if(x==t)return y;
	re double tmp=0;
	for(re int i=head[x];i;i=e[i].next){
		int z=e[i].to;
		if(e[i].w>1e-5&&dis[x]==dis[z]+1){
			dlt=dfs(z,min(y,e[i].w));
			tmp+=dlt;
			e[i].w-=dlt;
			e[i^1].w+=dlt;
			if(dis[s]==n||(y-=dlt)<1e-5)return tmp;
		}
	}
	if(!(--gap[dis[x]]))dis[s]=n;
	++gap[++dis[x]];
	return tmp;
}
inline double fabs(re double x){
	return x<0?-x:x;
}
inline double sap(){
	re double ans=0;
	q.push(t);
	memset(v,0,sizeof(v));
	memset(gap,0,sizeof(gap));
	memset(dis,0,sizeof(dis));
	v[t]=1;
	dis[t]=0;
	while(!q.empty()){
			re int tmp=q.front();
			q.pop();
			for(re int i=head[tmp];i;i=e[i].next){
				if(!v[e[i].to]){
					v[e[i].to]=1;
					++gap[dis[e[i].to]=dis[tmp]+1];
					q.push(e[i].to);
				}
			}
		}
	while(dis[s]<n)ans+=dfs(s,1e9);
	return ans;
}
int main(){
	n=read();
	m=read();
	p=read();
	s=1,t=n;
	re double r=0;
	for(re int i=1;i<=m;++i){
		a=read();
		b=read();
		c=read();
		add(a,b,c);
		if((double)c>r)r=(double)c;
	}for(re int i=2;i<=cnt;++i)e[i]=e1[i];
	re double lsy_ak_ioi=sap();
	printf("%.0lf\n",lsy_ak_ioi);
	re double l=0;
	while(r-l>1e-4){
		re double mid=(l+r)/2;
		for(re int i=2;i<=cnt;++i)e[i].w=e1[i].w<mid?e1[i].w:mid;
		if(fabs(sap()-lsy_ak_ioi)>1e-5)l=mid;
		else r=mid;
	}
	printf("%.4lf",l*(double)p);
}
```


---

## 作者：wangxuye (赞：2)

1A还是很开心啊~~虽然做的时候打错了一个东西调了很久~~  
### 题目链接  
 [[SDOI2013] 费用流](https://www.luogu.org/problemnew/show/P3305)  
### 题目大意  
给定一张运输网络，求最大流以及给所有边赋一个价格$c_i$，且$\sum c_i=P$，此时的$\sum c_i*f_i$的最小值，$f_i$为第$i$条边上的流量。  
### 题目思路  
第一小问的最大流就不用说了。  
第二小问中不要被那个$P$误导了，只要贪心一下就知道肯定是把一条边变成$P$，而其他都是$0$。再贪心一下就知道肯定是给流量最大的那条边。那么问题就转化成了在最大流中，使得流量最大的边流量最小。最大值最小，是不是很熟悉，二分不就可以了？  

上代码:  
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=100010,M=1000010;
const int inf=0x3f3f3f3f;
const double eps=1e-10;

int head[N],ver[M],edge1[M],nxt[M],d[N]; 
double edge[M],maxflow=0;
int n,m,p,tot=1,s,t;
bool visit[N];
inline void add(int x,int y,int z) //加边 
{
	ver[++tot]=y,edge[tot]=edge1[tot]=z,nxt[tot]=head[x],head[x]=tot;
	ver[++tot]=x,edge[tot]=edge1[tot]=0,nxt[tot]=head[y],head[y]=tot;
}

queue<int> q;
inline bool bfs() //bfs遍历残余网络 
{
	while(q.size()) q.pop();
	q.push(s);
	memset(d,0,sizeof(d));
	d[s]=1;
	while(q.size())
	{
		int x=q.front();
		q.pop();
		for(int i=head[x];i;i=nxt[i])
		{
			int y=ver[i];
			if(edge[i]>eps&&!d[y])
			{
				d[y]=d[x]+1;
				q.push(y);
				if(y==t) return true;
			}
		}
	}
	return false;
}
inline double dinic(int x,double flow) //dinic 
{
	if(x==t||flow<eps) return flow;
	double rest=flow,k;
	for(int i=head[x];i&&rest>eps;i=nxt[i])
	{
		int y=ver[i];
		if(edge[i]>eps&&d[y]==d[x]+1)
		{
			k=dinic(y,min(edge[i],rest));
			if(k<eps) d[y]=0;
			rest-=k;
			edge[i]-=k;
			edge[i^1]+=k;
		}
	}
	return flow-rest;
}

inline ll read()
{
	ll s=0;
	bool flag=false;
	char ch=getchar();
	for(;ch<'0'||ch>'9';ch=getchar()) if(ch=='-') flag=true;
	for(;'0'<=ch&&ch<='9';ch=getchar()) s=(s<<3)+(s<<1)+(ch^48);
	if(flag) return -s;
	return s;
}
inline void write(ll x)
{
	if(!x)
	{
		putchar('0'),putchar(' ');
		return ;
	}
	if(x<0) putchar('-'),x=-x;
	char ch[20];
	int tot=0;
	while(x) ch[++tot]=x%10,x/=10;
	for(int i=tot;i;i--) putchar(ch[i]^'0');
	putchar(' ');
}
inline void writeln(ll x)
{
	write(x);
	putchar('\n');
}

int main()
{
	n=read(),m=read(),p=read(),s=1,t=n;
	double l=0,r=0;
	for(int i=1;i<=m;i++)
	{
		int a=read(),b=read(),c=read();
		add(a,b,c);
		r=max(r,(double)c);
	}
	double flow=0;
	while(bfs()) //先算出最大流，记为maxflow 
		while((flow=dinic(s,inf))>eps) maxflow+=flow;
	for(int i=1;i<=100;i++) //也可以写成l+eps<r 
	{
		double mid=(l+r)/2;
		for(int j=1;j<=tot;j++) edge[j]=min((double)edge1[j],mid); //更新边权 
		double maxn=0;
		while(bfs()) //算出每条边最大流量为mid时的最大总流量，记为maxn 
			while((flow=dinic(s,inf))>eps) maxn+=flow;
		if(abs(maxflow-maxn)<eps) r=mid; //若maxn<maxflow，那么mid要变大 
		else l=mid; //否则要变小 
	}
	printf("%.0lf\n%.4lf\n",maxflow,l*p);
	return 0;
}
```

---

## 作者：Lagerent (赞：1)

好题。

考虑现在 Alice 已经跑出了一种最大流，Bob 的策略。

显然，将费用全灌到流量最大的边上，策略最优。

相应地，Alice 要保证在最大流不变的前提下，流量最大的边尽可能的小。

考虑二分。每次二分出流量的最大值，将其设置成为最大容量，然后看跑出的最大流是否与原图相等即可。若相等，即试着再次减少最大流量；若不相等，则试着扩大最大流量。

警示后人：注意变量类型。~~不要像我一样把一个 double 型的变量定义成 int 然后调了好久。~~

```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
#define rep(a, b, c) for(int (a) = (b); (a) <= (c); ++ (a))
#define per(a, b, c) for(int (a) = (b); (a) >= (c); -- (a))
using namespace std;

const int N = 110, M = 2010, inf = 1e9;
const double eps = 1e-8;

int n, m, S, T, p;
int hd[N], to[M], nt[M], idx;
int cur[N], q[N], d[N];
double f[M], t[M], max_flow;

void add(int u, int v, double c) {
	to[idx] = v, f[idx] = c, nt[idx] = hd[u], hd[u] = idx ++ ;
	to[idx] = u, f[idx] = 0, nt[idx] = hd[v], hd[v] = idx ++ ;
}

bool bfs() {
	int hh = 0, tt = 1;
	memset(d, -1, sizeof d);
	d[S] = 0, q[0] = S, cur[S] = hd[S];
	while(hh <= tt) {
		int u = q[hh ++ ];
		for(int i = hd[u]; ~i; i = nt[i]) {
			int v = to[i];
			if(d[v] == -1 && f[i]) {
				d[v] = d[u] + 1;
				cur[v] = hd[v];
				if(v == T) return true;
				q[ ++ tt] = v;
			}
		}
	}
	return false;
}

double find(int u, double limit) {
	if(u == T) return limit;
	double flow = 0;
	for(int i = cur[u]; ~i && flow < limit; i = nt[i]) {
		cur[u] = i;
		int v = to[i];
		if(f[i] && d[v] == d[u] + 1) {
			double t = find(v, min(f[i], limit - flow));
			if(!t) d[v] = -1;
			f[i] -= t, f[i ^ 1] += t, flow += t;
		} 
	}
	return flow;
}

double dinic() {
	double res = 0, flow;
	while(bfs()) while(flow = find(S, inf)) res += flow;
	return res;
}

bool check(double mid) {
	for(int i = 0; i < idx; i += 2) {
		f[i] += f[i ^ 1];
		f[i ^ 1] = 0;
		f[i] = min(t[i], mid);
	}
	return fabs(dinic() - max_flow) < eps;
}

int main() {
	memset(hd, -1, sizeof hd);
	scanf("%d%d%d", &n, &m, &p);
	S = 1, T = n;
	while(m -- ) {
		int a, b; double c;
		scanf("%d%d%lf", &a, &b, &c);
		add(a, b, c);
	}
	rep(i, 0, idx - 1) t[i] = f[i];
	printf("%.0lf\n", max_flow = dinic());
	double l = 0, r = 50000;
	while(r - l > eps) {
		double mid = (l + r) / 2;
		if(check(mid)) r = mid;
		else l = mid;
	}
	printf("%.5lf\n", l * p);
	return 0;
}
```

---

## 作者：maomao9173 (赞：1)

#### [题目链接  $Click$  $Here$](https://www.luogu.org/problemnew/show/P3305)

非常有趣的一个题目。

关键结论：所有的单位费用应该被分配在流量最大的边上。

即：在保证最大流的前提下，使最大流量最小。这里我们采用二分的方法，每次判断让所有边的流量$<=mid$时是否依然有最大流，求得最小的最大流量$*p$即可。

为什么会有实数流量呢？或许是因为流量最大的边不一定满流吧。被小小的坑了一下。

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 400010;
const int M = 400010;
const int INF = 0x3f3f3f3f;

int u[N], v[N], flow[N]; double f[N];

int n, m, p, cnt = -1, head[N];

struct edge {
	int nxt, to; double f;
}e[M];

void add_edge (int from, int to, double flw) {
	e[++cnt].nxt = head[from];
	e[cnt].to = to;
	e[cnt].f = flw;
	head[from] = cnt;
}

void add_len (int u, int v, double f) {
	add_edge (u, v, f);
	add_edge (v, u, 0);
}

queue <int> q;
int cur[N], deep[N];

bool bfs (int s, int t) {
	memcpy (cur, head, sizeof (head));
	memset (deep, 0x3f, sizeof (deep));
	deep[s] = 0; q.push (s);
	while (!q.empty ()) {
		int u = q.front (); q.pop ();
		for (int i = head[u]; ~i; i = e[i].nxt) {
			int v = e[i].to;
			if (deep[v] == INF && fabs (e[i].f) > 1e-8) {
				deep[v] = deep[u] + 1;
				q.push (v);
			}
		}
	}
	return deep[t] != INF;
}

double dfs (int u, int t, double lim) {
	if (u == t || fabs (lim) < 1e-8) {
		return lim;
	}
	double tmp = 0, flow = 0;
	for (int &i = cur[u]; ~i; i = e[i].nxt) {
		int v = e[i].to;
		if (deep[v] == deep[u] + 1) {
			tmp = dfs (v, t, min (lim, e[i].f));
			lim -= tmp;
			flow += tmp;
			e[i ^ 0].f -= tmp;
			e[i ^ 1].f += tmp;
			if (fabs (lim) < 1e-8) break;
		}
	}
	return flow;
} 

double Dinic (int s, int t) {
	double res = 0;
	while (bfs (s, t)) {
		res += dfs (s, t, INF);
	}
	return res;
}

double max_flow;

bool can_use (double flw) {
	cnt = -1; int s = 1, t = n;
	memset (head, -1, sizeof (head));
	for (int i = 1; i <= m; ++i) {
		add_len (u[i], v[i], min (f[i], flw));
	}
	return fabs (Dinic (s, t) - max_flow) < 1e-8;
}

int main () {
	memset (head, -1, sizeof (head));
	cin >> n >> m >> p;
	for (int i = 1; i <= m; ++i) {
		cin >> u[i] >> v[i] >> f[i];
		add_len (u[i], v[i], f[i]);
	}
	int s = 1, t = n; max_flow = Dinic (s, t);
	printf ("%.0lf\n", max_flow);
	double l = 0, r = INF;
	while (r - l > 1e-8) {
		double mid = (l + r) / 2.0;
		if (can_use (mid)) {
			r = mid;
		} else {
			l = mid;
		}
	}
	printf ("%.4lf\n", r * p);
} 

```



---

## 作者：JPGOJCZX (赞：0)

节选自：[图论学习笔记（三）：二分图、网络流](https://www.luogu.com.cn/article/grmv2d6x)

[安利一下我的博客](https://www.cnblogs.com/JPGOJCZX/p/18948152)

第一问直接跑网络最大流就可以了，我们考虑第 $2$ 问。很显然，$\text{Bob}$ 一定会将所有花费 $P$ 全部加在流量最大的边上。那么 $\text{Alice}$ 的最优策略就出来了，那就是在最大流不变的情况下，让流量最大的边的流量尽可能小。

由于要让最大值最小，因此我们考虑二分答案。不过直接二分最大流不是那么好搞，因此我们考虑改变每条边的容量来间接改变最大流。一个显然的事实就是我们最终确定出的最大流一定至少有一条边流了 $mid$ 的流量，否则还可以从原点找到增广路来增广。因此我们二分出容量上限 $mid$，将所有容量大于 $mid$ 的边改为 $mid$，跑一遍网络最大流。如果这个时候最大流没有变，那么就将答案更新为 $mid \times P$。

最后，这道题要用到实数二分，细节比较多，要多加小心啊。

完整代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N = 2e2 + 9, M = 5e3 + 9, INF = 1e18 + 9;
const double eps = 1e-6;
struct Edge{
    int v, nex;
    double c;
} e[M << 1];
int head[N], ecnt = 1;
void addEdge(int u, int v, double c){
    e[++ecnt] = Edge{v, head[u], c};
    head[u] = ecnt;
}
int cur[N], dep[N], n, m, p, s, t;
bool bfs();
double dfs(int u, double flow);
int fl[M];
double ans;
vector <int> vec;
signed main(){
    scanf("%lld%lld%lld", &n, &m, &p);
    s = 1, t = n;
    for(int i = 1; i <= m; i++){
        int u, v, c;
        scanf("%lld%lld%lld", &u, &v, &c);
        addEdge(u, v, c);
        vec.push_back(ecnt);
        fl[ecnt] = c;
        addEdge(v, u, 0);
    }
    while(bfs())
        ans += dfs(s, INF);
    double l = 0, r = 5e4, res = 0;
    while(fabs(l - r) > eps) {
        double mid = (l + r) / 2;
        for(int i : vec){
            e[i].c = min(mid, 1.0 * fl[i]);
            e[i ^ 1].c = 0; 
        }
        double tmp = 0;
        while(bfs())
            tmp += dfs(s, INF);
        if(fabs(tmp - ans) < 10 * eps){
            res = mid;
            r = mid - eps;
        } else
            l = mid + eps;
    }
    printf("%0.0f\n%0.4lf", ans, res * p);
    return 0;
}
```

---

## 作者：Elma_ (赞：0)

显然，对于 Alice 提供的一个可行的最大流方案，Bob 会将其中流量最大的一条边的费用设为 $P$，其余边的费用设为 $0$。因此为了使费用最小，Alice 需要使她给出的最大流中流量最大的边的流量尽可能小。

于是我们二分各边流量的最大值，每次 check 的时候将所有边的流量对 $\mathrm{mid}$ 取 $\min$，然后跑最大流和原图的最大流比较即可。具体实现时需要注意实数二分的一些细节。

```cpp
#define int long long
 
const int maxn = 1e6 + 5;
const int maxm = 26;
const int mod = 1e9 + 7;
const double inf = 1e15;
const double eps = 10e-7;
 
inline int min(int x, int y) { return x < y ? x : y; }
inline int max(int x, int y) { return x > y ? x : y; }

struct node {
    int nxt, to;
    double flow;
} edge[maxn << 1];
int n, m, s, t, p, tot = 1, head[maxn];
double len[maxn], maxLen;

inline void addedge(int u, int v, double w) {
    edge[++tot] = (node){head[u], v, w}, head[u] = tot;
}

queue <int> q;
int dep[maxn];

inline bool bfs(int s, int t) {
    for (int i = 1;i <= n;i++) dep[i] = 0;
    dep[s] = 1, q.push(s);
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (int i = head[u];i;i = edge[i].nxt) {
            int v = edge[i].to;
            if (!dep[v] && len[i] > 0) {
                dep[v] = dep[u] + 1;
                q.push(v);
            }
        }
    }
    return dep[t];
}

int cur[maxn];

inline double dfs(int u, double rest = 1e9) {
    if (u == t) return rest;
    double flow = 0;
    for (int i = cur[u];i;i = edge[i].nxt) {
        cur[u] = i;
        int v = edge[i].to;
        if (len[i] > 0 && dep[v] == dep[u] + 1) {
            double x = dfs(v, fmin(rest, len[i]));
            len[i] -= x;
            len[i ^ 1] += x;
            rest -= x;
            flow += x;
        }
        if (rest < eps) break;
    }
    return flow;
}

inline double dinic() {
    double ans = 0;
    while (bfs(s, t)) {
        for (int i = 1;i <= n;i++) cur[i] = head[i];
        ans += dfs(s);
        //printf("%.4lf\n", ans);
    }
    return ans;
}

signed main(void) {
    n = read(), m = read(), s = 1, t = n, cin >> p;
    for (int i = 1;i <= m;i++) {
        int u, v; double w;
        u = read(), v = read(), cin >> w;
        addedge(u, v, w), addedge(v, u, 0);
        maxLen = fmax(maxLen, w);
    }
    for (int i = 2;i <= tot;i++) len[i] = fmin(edge[i].flow, inf);
    double maxFlow = dinic();
    printf("%.4lf\n", maxFlow);
    double l = 0, r = maxLen + 1, ans = 0;
    while (r - l > eps) {
        double mid = (l + r) / 2;
        for (int i = 2;i <= tot;i++) {
            len[i] = fmin(edge[i].flow, mid);
        }
        if (fabs(dinic() - maxFlow) < eps) r = ans = mid;
        else l = mid;
    }
    double mx = 0;
    for (int i = 2;i <= tot;i++) {
        len[i] = fmin(edge[i].flow, ans);
    }
    dinic();
    for (int i = 1;i <= tot;i += 2) {
        mx = fmax(mx, len[i]);
    }
    printf("%.4lf\n", mx * p);
    return 0;
}
```


---

## 作者：magolor (赞：0)

来发一个不一样的题解：

**全网络为啥都找不到一个用long long写的题解呢？**

就是不喜欢double，任性用long long调了3个小时……


总之Bob最优方案就是把所有费用放在实际最大流边上（反证法）

Alice就要在最大流的所有方案中选**最大流边最小**：二分答案

本人用二分long long 法， 将数据都乘以精度，算出来再除掉精度就好了


不要问我怎么知道的，记住：**初始化，把边计数器初始化为0！！！！不是1！！！！**（因为用u^1操作）








```cpp
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
#define MAXN 200
#define MAXM 2000
#define BASE 10000000
#define INF 10611095670000000ll
#define ll long long
#define mid ((lef+rig)>>1)
#define gc() getchar()
inline int read(int ans = 0, int sgn = ' ', int ch = gc())
{
    for(;ch < '0' || ch > '9'; sgn=ch,ch=gc());
    for(;ch >='0' && ch <='9'; (ans*=10)+=ch-'0',ch=gc());
    return sgn-'-' ? ans : -ans;
}
struct Edge
{
    int to,nex;
    ll c;
    Edge(int _to=0, int _nex=0, ll _c=0):to(_to),nex(_nex),c(_c){}
}e[MAXM+5];
int first[MAXN+5], q[MAXN+5], level[MAXN+5], cur[MAXN+5], A[MAXM+5], B[MAXM+5], C[MAXM+5], tot = 1, N, M, P, S, T;
ll lef, rig, W;
inline void Add(int a, int b, ll c)
{
    e[tot] = Edge(b,first[a],c), first[a] = tot++;
    e[tot] = Edge(a,first[b],0), first[b] = tot++;
    return;
}
inline bool BFS()
{
    memset(level,0,sizeof(level)), q[0] = S, level[S] = 1;
    for(register int head = 0, tail = 1, t, u, v; head-tail; )
        for(t = q[head++], head %= MAXN, u = first[t]; u+1; u = e[u].nex)
            if(e[u].c > 0 && !level[v=e[u].to])
            {
                level[v] = level[t]+1, q[tail++] = v, tail %= MAXN;
                if(v == T)
                    return true;
            }
    return false;
}
ll DFS(int p, ll f, ll tag = 0, ll del = 0)
{
    if(p == T)
        return f;
    for(register int &u = cur[p], v; u+1; u = e[u].nex)
        if(e[u].c > 0 && level[v=e[u].to] == level[p]+1)
        {
            del = DFS(v,min(e[u].c,f-tag)), e[u].c -= del, e[u^1].c += del, tag += del;
            if(f == tag)
                return tag;
        }
    return tag;
}
inline ll Dinic(ll ans = 0)
{
    for(register int i; BFS(); ans += DFS(S,INF))
        for(i = 0; i <= N; cur[i] = first[i], i++);
    return ans;
}
inline void Build(ll k)
{
    memset(first,-1,sizeof(first)), tot = 0;
    for(register int i = 1; i <= M; Add(A[i],B[i],min(k,1ll*BASE*C[i])), i++);
    return;
}
int main()
{
    N = read(), M = read(), P = read(), S = 1, T = N;
    for(register int i = 1; i <= M; A[i]=read(), B[i]=read(), C[i]=read(), rig = max(rig,1ll*C[i]), i++);
    for(Build(INF), W = Dinic(), lef = 1, rig *= BASE; lef < rig; )
        if(Build(mid), Dinic() < W)
            lef = mid+1;
        else
            rig = mid;
    printf("%lld\n%.5lf\n",W/BASE,1.*rig/BASE*P);
     return 0;
}
```

---


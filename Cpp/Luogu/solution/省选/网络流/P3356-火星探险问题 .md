# 火星探险问题 

## 题目描述

火星探险队的登陆舱将在火星表面着陆，登陆舱内有多部障碍物探测车。登陆舱着陆后，探测车将离开登陆舱向先期到达的传送器方向移动。  

探测车在移动中还必须采集岩石标本。每一块岩石标本由最先遇到它的探测车完成采集。每块岩石标本只能被采集一次。岩石标本被采集后，其他探测车可以从原来岩石标本所在处通过。探测车不能通过有障碍的地面。  

本题限定探测车只能从登陆处沿着向南或向东的方向朝传送器移动，而且多个探测车可以在同一时间占据同一位置。如果某个探测车在到达传送器以前不能继续前进，则该车所采集的岩石标本将全部损失。


用一个 $p \times q$ 网格表示登陆舱与传送器之间的位置。登陆舱的位置在 
$(x_1,y_1)$ 处，传送器的位置在 $(x_py_q)$ 处。

$$\begin{bmatrix} (x_1,y_1) & (x_2,y_1) & \dots & (x_{p-1},y_1) & (x_p,y_1) \\ (x_1,y_2) & (x_2,y_2) & \dots & (x_{p-1},y_2) & (x_p,y_2) \\ \dots & \dots & \dots & \dots & \dots \\ (x_1,y_{q-1}) & (x_2,y_{q-1}) & \dots & (x_{p-1},y_{q-1}) & (x_p,y_{q-1}) \\ (x_1,y_q) & (x_2,y_q) & \dots & (x_{p-1},y_q) & (x_p,y_q) \end{bmatrix}$$

给定每个位置的状态，计算探测车的最优移动方案，使到达传送器的探测车的数量最多，而且探测车采集到的岩石标本的数量最多。


## 说明/提示

【数据范围】
对于 $100\%$ 的数据，$1 \le n,p,q \le 35$。


## 样例 #1

### 输入

```
2
10
8
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 1 1 0 0 0
0 0 0 1 0 2 0 0 0 0
1 1 0 1 2 0 0 0 0 1
0 1 0 0 2 0 1 1 0 0
0 1 0 1 0 0 1 1 0 0
0 1 2 0 0 0 0 1 0 0
0 0 0 0 0 0 0 0 0 0```

### 输出

```
1 1
1 1
1 1
1 1
1 0
1 0
1 1
1 1
1 1
1 1
1 0
1 0
1 1
1 0
1 0
1 0
2 1
2 1
2 1
2 1
2 0
2 0
2 0
2 0
2 1
2 0
2 0
2 1
2 0
2 1
2 1
2 1```

# 题解

## 作者：Akoasm_X (赞：18)

**网络流24题的题解我之前也有写过一些，里面也有网络流知识的教学，讲得好不好看看也无妨**
[**传送门**](https://www.luogu.com.cn/blog/CN-jingying-Xu/wang-lao-liu-suan-fa-yi-ji-24-ti-wei-wan-jie-post)

### 12ms，发现跑得蛮快的，分享一下做法(2021.3.28)

首先这题要用到网络流就不用我多说了，题目限制了两个量：车的数量 和 最大的总价值。

1. 我们把车的数量当作流量，最大总价值当作花费，就变成了最大费用最大流，接着我们在加边时把花费取负，加进去跑最小费用最大流，此时的最小费用再取负就是最大花费。当然，最大花费是多少并不重要

2. 对于岩石标本来讲，点权为1的价值，但只能拿一次，于是我把点拆开计算，从入点向出点连边，容量为 1 ，花费为 -1。对于没有障碍的点，也从入点向出点连边，容量无穷大，但因为没有标本可以采集所以花费为0

3. 探测车行走的话，就是从左侧/上侧的出点向右侧/下侧的入点连边，这个边对车没有限制，所以容量无穷大，花费为0

4. 从虚拟源点向（ 1，1 ）的入点连边，容量为 探测车 的数量，再从（ m , n ）的出点向虚拟汇点连边，容量也是 探测车 的数量，花费都是0

5. 然后愉快地跑完MCMF后，发现**并不要求输出花费而是输出路径**，~~行吧，下一题~~

6. 在计算过程中会修改边的容量，修改过就表示我们走过去了，所以我就把边枚举了出来，建了个新图，跑了一遍dfs

7. 但是也不用枚举所有边，指枚举点和点之间的连边就可以了，枚举出点，找出入点，由于这些边一开始容量都是 inf ,后来修改过程中 inf - va（现在的容量）就代表这条路径所经过的探测车有几个，那就在新图上连边，边权是 inf - va

8. 之后就跑一边dfs就可以了,如果还是不清楚可以看代码注释

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn = 10021;
const int maxm = 10021;
const int inf = 2147483647;
int n,m,cnt,str,end,tot = -1,maxcost,p;
int head[maxn],pre[maxn],last[maxn],flow[maxn],d[maxn],pos[50][50];
bool vis[maxn],v[maxn];
struct node
{
	int net,va,cost,to;
}data[maxm<<3];

int read() 
{
	int res=0;
	char c=getchar();
	while (c<'0'||c>'9')
		c=getchar();
	while (c>='0'&&c<='9')
	{
		res=res*10+c-'0';
		c=getchar();
	}
	return res;
}

void add(int a,int b,int va,int cost)
{
	data[++tot].cost = cost;
	data[tot].net = head[a];
	data[tot].to = b;
	data[tot].va = va;
	head[a] = tot;
	data[++tot].cost = -cost;
	data[tot].net = head[b];
	data[tot].to = a;
	data[tot].va = 0;
	head[b] = tot;
}

bool SPFA()
{
	memset(d,0x3f,sizeof(d));
	memset(flow,0x3f,sizeof(flow));
	memset(vis,0,sizeof(vis));
	queue<int> q;
	q.push(str);
	vis[str] = 1;
	d[str] = 0;
	pre[end] = -1;
	while(!q.empty())
	{
		int from = q.front();q.pop();
		vis[from] = 0;
		for(int i=head[from];i!=-1;i=data[i].net)
		{
			int to = data[i].to ;
			int va = data[i].va ;
			int cost = data[i].cost ;
			if(va&&d[to]>d[from]+cost)
			{
				d[to] = d[from]+cost;
				pre[to] = from; 
				last[to] = i;
				flow[to] = min(flow[from],va); 
				if(!vis[to])
				{
					vis[to] = 1;
					q.push(to);
				}
			}
		}
	}
	return pre[end] != -1;
}

void MCMF()
{
	while(SPFA())
	{
		int now = end;
		maxcost += flow[end]*d[end];
		while(now!=str)
		{
			data[last[now]].va -= flow[end];
			data[last[now]^1].va += flow[end];
			now = pre[now];
		}
	}
}

void print(int id,int x)
{
	int temp = x - 2 * n * m;//真实的坐标点
	for(int i=head[x];i!=-1;i=data[i].net)
	{
		int to = data[i].to ;
		int va = data[i].va ;
		if(!va)	continue;//表示这条边已经不能有车通过了 
		int tt = to - 2 * n * m;
		if(temp+1==tt)	printf("%d 1\n",id);//向右 
		else			printf("%d 0\n",id);//向下 
		data[i].va--;
		print(id,to);
		break;
	}
}

int main()
{
	memset(head,-1,sizeof(head));
	cnt = read();m = read();n = read();
	str = 3 * n * m + 1;end = 3 * n * m + 2;
	//区间[1,n*m]内是入点，(n*m,2*n*m]是出点，(2*n*m,3*n*m]是新图上的点 
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			pos[i][j] = ++p;//先给每个点一个编号 
	add(str,1,cnt,0);
	add(2*n*m,end,cnt,0);//对应分析4 
	for(int i=1;i<=n;i++)//对应分析2 
	{
		for(int j=1;j<=m;j++)
		{
			int x = read();
			if(x==2)	add(pos[i][j],pos[i][j]+n*m,1,-1);
			if(x!=1)	add(pos[i][j],pos[i][j]+n*m,inf,0);
			else	v[pos[i][j]] = 1;//标记一下不能走的边 
		}
	}
	for(int i=1;i<=n;i++)//对应分析3 
		for(int j=2;j<=m;j++)
			add(pos[i][j-1]+n*m,pos[i][j],inf,0);
	for(int i=2;i<=n;i++)
		for(int j=1;j<=m;j++)
			add(pos[i-1][j]+n*m,pos[i][j],inf,0);
	MCMF();//愉快地跑一边MCMF，其中过程很常规 
	for(int x=1+n*m;x<2*n*m;x++)
	{//枚举出点 
		if(v[x-n*m])	continue;//跳过障碍 
		for(int i=head[x];i!=-1;i=data[i].net)
		{
			int va = data[i].va ;
			int to = data[i].to ;
			if(to+n*m==x)	continue;//去掉连向自身的入点 
			if(va==inf)	continue;//去掉不会有车经过的边 
			if(to!=end)
				add(x+m*n,to+2*n*m,inf-va,0);
		}
	}
	for(int i=1;i<=cnt;i++)//dfs求解即可 
		print(i,1+2*n*m);
	return 0;
}
```
有何不当之处还请大佬指出，不妨留个赞，感谢支持！

---

## 作者：spli (赞：13)

# Sol
- 建图：

1. 拆点，i,i

```cpp
    2. if(a[i][j]==1) continue;
    add_edge(i,i',inf,0);
    if(a[i][j]==2) add_edge(i,i',1,1);
    3. if(a[i][j]==1) continue;
    if(a[i][j+1]!=1&&存在(i,j+1)) add_edge(p[i][j]+num,p[i][j+1],inf,0);
    if(a[i+1][j]!=1&&存在(i+1,j)) add_edge(p[i][j]+num,p[i+1][j],inf,0);
    4. if(a[1][1]!=1) add_edge(S,1,car,0);
    if(a[n][m]!=1) add_edge(p[n][m]+num,T,car,0);
```
- 分析
每个点不限制走过次数

所以自己到自己的流量为inf

如果这个点是石块，**另外连边**：add\_edge(i,i',1,1);（费用流不可叠加）



------------


# Notice

反向弧的流量就是当前弧流过的流量

`if(!e[i^1].fl) continue;

        e[i^1].fl--;`

这句话判断是否可以走

如果可以，就将流量减1，代表已经走过一次

输出时要注意特判

从A到B，应该直接dfs(B')而不是dfs(B)

否则可能返回上一个点


# Code
    
    
    
    
    
    
    
```cpp
    // by spli
    #include<cstring>
    #include<cstdio>
    #include<algorithm>
    #include<iostream>
    #include<queue>
    using namespace std;
    typedef pair<int,int> Pair;
    const int N=100;
    const int inf=0x3f3f3f3f;
    int car,m,n;
    int a[N][N],p[N][N];
    struct node{
        int to,nxt,fl,c;
    }e[N*N*N];int head[N*N],cnt;
    queue<int>q;
    int dis[N*N*2];
    bool vis[N*N*2];
    int pe[N*N*2],pv[N*N*2];
    void add(int f,int t,int fl,int c){
        e[cnt]=(node){t,head[f],fl,c};
        head[f]=cnt++;
    }
    void add_edge(int f,int t,int fl,int c){
        add(f,t,fl,c);
        add(t,f,0,-c);
    }
    bool spfa(int S,int T){
        for(int i=S;i<=T;++i) dis[i]=-inf;
        dis[S]=0;
        vis[S]=1;
        q.push(S);
        while(!q.empty()){
            int u=q.front();
            q.pop();
            vis[u]=0;
            for(int i=head[u];~i;i=e[i].nxt){
                int v=e[i].to;
                if(e[i].fl>0&&dis[v]<dis[u]+e[i].c){
                    dis[v]=dis[u]+e[i].c;
                    pe[v]=i;
                    pv[v]=u;
                    if(!vis[v]){
                        vis[v]=1;
                        q.push(v);
                    }
                }
            }
        }
        return dis[T]>(-inf);
    }
    Pair mcf(int S,int T){
        int C=0,F=0;
        int flow=0;
        while(spfa(S,T)){
            flow=inf;
            for(int i=T;i!=S;i=pv[i])
                flow=min(flow,e[pe[i]].fl);
            C+=flow*dis[T];
            F+=flow;
            for(int i=T;i!=S;i=pv[i])
                e[pe[i]].fl-=flow,e[pe[i]^1].fl+=flow;
        }
        return Pair(F,C);
    }
    void DFS(int x,int y,int pos,int k,int T){
        int kx,ky,mov;
        for(int i=head[pos];~i;i=e[i].nxt){
            int v=e[i].to;
            if(v==0) continue;
            if(v==T) continue;
            if(v==pos-n*m) continue;
            if(!e[i^1].fl) continue;
            e[i^1].fl--;
            if(v>n*m){
                DFS(x,y,v,k,T);
                return;
            }
            if(v==p[x][y]+1) kx=x,ky=y+1,mov=1;
            else kx=x+1,ky=y,mov=0;
            printf("%d %d\n",k,mov);
            DFS(kx,ky,v+n*m,k,T);//不能写DFS(V) 
            return;
        }
    }
    int main(){
        memset(head,-1,sizeof(head));
        scanf("%d%d%d",&car,&m,&n);
        int num=n*m,now=0;
        int S=0,T=num*2+1;
        for(int i=1;i<=n;++i)
            for(int j=1;j<=m;++j){
                scanf("%d",&a[i][j]);
                p[i][j]=++now;
                if(a[i][j]==1) continue;
                if(a[i][j]==2) add_edge(p[i][j],p[i][j]+num,1,1),add_edge(p[i][j],p[i][j]+num,inf,0);
                if(a[i][j]==0) add_edge(p[i][j],p[i][j]+num,inf,0);
            }
        if(a[1][1]!=1) add_edge(S,1,car,0);
        for(int i=1;i<=n;++i)
            for(int j=1;j<=m;++j){
                if(a[i][j]==1) continue;
                if(a[i][j+1]!=1&&p[i][j+1]) add_edge(p[i][j]+num,p[i][j+1],inf,0);
                if(a[i+1][j]!=1&&p[i+1][j]) add_edge(p[i][j]+num,p[i+1][j],inf,0);
            }
        if(a[n][m]!=1) add_edge(p[n][m]+num,T,car,0);
        Pair ans=mcf(S,T);
        int f=ans.first;
        for(int i=1;i<=f;++i)
            DFS(1,1,1,i,T);
        return 0;
    }

```

---

## 作者：wuzhoupei (赞：6)

这个题是【网络流24题】中的一道；

然而我一看这个题就去想 DP 了；

所以呢，我写一个 DP 的题解；

首先，由于每个车可以走下和右两个方向；

而且每个格子可以被任意多的车走；

唯一的限制是有障碍的的地方不能走；

这是路径的限制；

还有石头只能取一次；

所以我们就做一个DP；

来求一条由 (1,1) 到 (n,m) 的路径；

使得这个路径上的石头最多；

这就是个裸的 DP 了；

只需要记录当前点是从哪个点转移过来的；

最后 dfs 输出就好了；

~~DP 结束，然而不会这道题的网络流。。。。~~


-------------------------------


```cpp
#include "iostream"
#include "stdio.h"
#include "algorithm"
#include "queue"
#define II int
#define R register
#define IL inline
#define I 50
using namespace std;


II inq[I][I], dis[I][I], from[I][I], nu[I][I];

II bx[2]={1,0}, by[2]={0,1};

II who,n,m,all;

queue <II> Qx,Qy;


IL void bfs()
{
    for(R II i=1;i<=n;i++)
    {
        for(R II j=1;j<=m;j++)
        {
            dis[i][j]=-1e9;
            from[i][j]=-1;
        }
    }

    dis[n][m]=nu[n][m];
    for(R II x=n;x;x--)
    {
        for(R II y=m;y;y--)
        {
            if(nu[x][y]==-1) continue ;
            for(R II i=1;i>=0;i--)
            {
                R II xx=x+bx[i], yy=y+by[i];
                if(xx && yy && xx<=n && yy<=m && dis[x][y]<=dis[xx][yy]+nu[x][y] && nu[xx][yy]!=-1) {
                    dis[x][y]=dis[xx][yy]+nu[x][y];
                    from[x][y]=i;
                }
            }
        }
    }
}


IL void dfs(R II x,R II y)
{
//    cout<<x<<" "<<y<<endl;
    nu[x][y]=0;
    R II o=from[x][y];
    if(x==n && y==m) return ;
    printf("%d %d\n",who,o);
    dfs(x+bx[o],y+by[o]);
}


int main()
{
    scanf("%d",&all);
    scanf("%d%d",&n,&m);  swap(n,m);
    for(R II i=1;i<=n;i++)
    {
        for(R II j=1;j<=m;j++)
        {
            R II x;
            scanf("%d",&x);
            if(x==1) x=-1;
            nu[i][j]=x;
        }
    }
    
    for(who=1;who<=all;who++) 
    {
        bfs();
        dfs(1,1);
    }
    
    exit(0);
}
```

---

## 作者：FREEH (赞：4)

### 【题目】
![题目](https://cdn.luogu.com.cn/upload/pic/25964.png)
### 【解题思路】
1. 求出答案
	- 把每一个格点拆分成两个点（表示：点1表示进入该格子，点2表示出来该格子），并且把点1和点2连接一条有向边：
    
    	- 当这个点有岩石时，容量为1，费用为1；
        - 当这个点不是岩石时，容量为无穷大，费用为0。
    - 把每一个格点的点2与其相邻的点的点1连接一条容量无穷大，费用为0的边
    - 然后只要把费用取相反数，然后跑最小费用最大流即可。
2. 输出方案
	- 枚举每一辆车，然后从源点开始不断地在残余网络中跑dfs，然后输出车辆和方向。
	- 输出方案时要注意不要输出拆点得出的点1或点2、源点和汇点.
    
### 【解题反思】
- 输出方案时要注意一些虚构的点不要输出。如：拆点得出的点1或点2、源点和汇点。

### 【参考程序】
```cpp
#include<cstdio>
#include<queue>
#include<iostream>
#include<cstring>
using namespace std;

#define nxt(x) (x+m*n)
#define INF 0x3f3f3f3f
int cur=1,n,m,s,t,mcost,mflow,car,ID;
int head[5005],dis[5005],flow[5005],pre[5005];
int Map[105][105],p[105][105];
struct EDGE{
    int t,next,w,f;
}e[100005];
void add(int a,int b,int w,int f)
{
    cur++;e[cur].t=b;e[cur].next=head[a];e[cur].w=w;e[cur].f=f;head[a]=cur;
    cur++;e[cur].t=a;e[cur].next=head[b];e[cur].w=0;e[cur].f=-f;head[b]=cur;
}

queue < int > q;
bool vis[5005];
bool SPFA(int s,int t)
{
    memset(dis,0x3f,sizeof dis);
    memset(vis,0,sizeof vis);
    dis[s]=0;
    vis[s]=1;
    flow[s]=INF;
    q.push(s);
    while (!q.empty())
    {
        int u=q.front();q.pop();
        vis[u]=false;
        for (int h=head[u];h!=-1;h=e[h].next)
        {
            int v=e[h].t,f=e[h].f;
            if (e[h].w&&dis[u]+f<dis[v])//如果边还有流量就尝试更新
            {
                dis[v]=dis[u]+f;//更新最短路径
                flow[v]=min(flow[u],e[h].w);//尽可能地流水
                pre[v]=h;//记录路径
                if (!vis[v])
                {
                    vis[v]=true;
                    q.push(v);
                }
            }
        }
    }
    return dis[t]!=INF;
}

void Update(int s,int t)
{
    int x=t;
    while (x!=s)
    {
        int i=pre[x];
        e[i].w-=flow[t];
        e[i^1].w+=flow[t];
        x=e[i^1].t;
    }//沿着记录下的路径并进行增广路
    mflow+=flow[t];
    mcost+=flow[t]*dis[t];//累计费用
}
void E_K(int s,int t)
{
    while (SPFA(s,t))//当还有多余流量时
        Update(s,t);
}

void dfs(int x,int y,int u,int k)
{
	int kx,ky,mov;
	for (int h=head[u];h!=-1;h=e[h].next)
	{
		int v=e[h].t;
		if (v==s) continue;
		if (v==t) continue;
		if (v==u-n*m) continue;
		if (!e[h^1].w) continue;
		e[h^1].w--;
		if (v>n*m)
		{
			dfs(x,y,v,k);
			return;
		}
		if (v==p[x][y]+1)
		{
			kx=x;
			ky=y+1;
			mov=1;
		}
		else
		{
			kx=x+1;
			ky=y;
			mov=0;
		}
		printf("%d %d\n",k,mov);
		dfs(kx,ky,v+n*m,k);
		return;
	}
}
int main()
{
    scanf("%d%d%d",&car,&m,&n);
    s=0;t=n*m*2+1;
    memset(head,-1,sizeof head);
    for (int i=1;i<=n;i++)
    	for (int j=1;j<=m;j++)
    	{
    		scanf("%d",&Map[i][j]);
    		p[i][j]=++ID;
    	}
	if (Map[1][1]!=1) add(s,1,car,0);
	if (Map[n][m]!=1) add(nxt(p[n][m]),t,car,0);
	for (int i=1;i<=n;i++)
		for (int j=1;j<=m;j++)
		{
			if (Map[i][j]==1) continue;
			add(p[i][j],nxt(p[i][j]),INF,0);
			if (Map[i][j]==2)
				add(p[i][j],nxt(p[i][j]),1,-1);
			
			if (Map[i+1][j]!=1&&p[i+1][j])
			{
				add(nxt(p[i][j]),p[i+1][j],INF,0);
			}
			if (Map[i][j+1]!=1&&p[i][j+1])
			{
				add(nxt(p[i][j]),p[i][j+1],INF,0);
			}
		}
    E_K(s,t);
    for (int i=1;i<=mflow;i++)
    	dfs(1,1,1,i);
    return 0;
} 
```

---

## 作者：cunzai_zsy0531 (赞：3)

# P3356题解-by zsy

[题目链接](https://www.luogu.com.cn/problem/P3356)

网络流题目套路：

1. 分析如何通过最大流/最小（大）费用来表示题目中变量。
1. 根据1的分析建图，保证这个表示是正确的。
1. 跑HLPP/Dinic/ISAP（最大流）或者mcmf。

一般的网络流题目，难点在第2步上。也不排除有些题目第一步的表示非常妙。

这道题是典型的建图题，我们会发现题目中两个变量：采集标本的数量和探测车的数量。很容易想到用最大流控制探测车，用最大费用求出最大标本数量。

考虑建图：

1. $S$ ~ $X_{1,1}$ 流量探测车数量$n$，费用0，表示初始状态。
1. 拆点，$X_{i,j}$和$Y_{i,j}$，分别表示走到此点和走过此点。若此点有石头，则$X_{i,j}$ ~ $Y_{i,j}$，流量1，费用1，表示取了这块石头。另外，只要这个点可以走，就连一条边$X_{i,j}$ ~ $Y_{i,j}$，流量INF，费用0，表示走过这个点。
1. 点之间的连线，$Y_{i,j}$到$X_{i+1,j}和X_{i,j+1}$分别表示向南走和向东走。
1. $Y_{p,q}$ ~ $T$，流量INF，费用0，表示完成任务。

这样我们会发现，我们通过建图中的(1)控制了探测车数量，然后通过(2)(3)完成了取石头的构图。接下来就是皆大欢喜的跑mcmf啦！

上代码：
```cpp
#include<iostream>
#include<cstdio>
#include<queue>
#include<cstring>
#define nm (n*m)
using namespace std;
const int N=35*35*2+5,M=35+5,INF=0x3f3f3f3f;//注意两点：maxn一定要开够；INF要小于INTmax/2，不然加起来可能会爆
struct Edge{int u,v,f,w,nxt;}e[N*2];
int h[N],pre[N],flow[N],dist[N],last[N];
bool vis[N];
int a[M][M],p[M][M];
int W,n,m,mc,mf,s,t,tot=1;
inline void add(int u,int v,int f,int w){//双向边
	e[++tot]=(Edge){u,v,f,w,h[u]};h[u]=tot;
	e[++tot]=(Edge){v,u,0,-w,h[v]};h[v]=tot;
}
bool spfa(){
	for(int i=1;i<=nm*2+2;++i) dist[i]=-INF;
	memset(flow,0x3f,sizeof(flow));
	memset(vis,0,sizeof(vis));
	queue<int>q;
	q.push(s);
	dist[s]=0;
	vis[s]=1;
	pre[t]=-1;//判断能否到达汇点
	while(!q.empty()){
		int u=q.front();
		q.pop();
		vis[u]=0;
		for(int i=h[u];i;i=e[i].nxt){
			int v=e[i].v,f=e[i].f,w=e[i].w;
			if(f&&dist[v]<dist[u]+w){//改符号成最大费用最大流
				dist[v]=dist[u]+w;
				flow[v]=min(flow[u],f);
				last[v]=i;
				pre[v]=u;
				if(!vis[v]){
					vis[v]=1;
					q.push(v);
				}
			}
		}
	}
	return pre[t]!=-1;//这里就是上面提到的判断
}
void mcmf(){
	while(spfa()){
		mf+=flow[t];
		mc+=flow[t]*dist[t];
		int now=t;
		while(now!=s){//增广之后的流量处理
			e[last[now]].f-=flow[t];
			e[last[now]^1].f+=flow[t];//不要忘了反向边加流量
			now=pre[now];
		}
	}
}
void dfs(int x,int cnt){//输出路径函数，顺着方向dfs即可，注意是判断反向边流量来判定这条边有没有走过，走了几次。
	if(x==nm) return; 
	int u,v;
	u=x+nm;
	if(x%m){
		v=x+1;
		int i=h[u];
		while(i&&e[i].v!=v) i=e[i].nxt;
		if(e[i^1].f){
			e[i^1].f--;
			printf("%d 1\n",cnt);
			dfs(v,cnt);
			return;
		}
	}
	if(x<=nm-m){
		v=x+m;
		int i=h[u];
		while(i&&e[i].v!=v) i=e[i].nxt;
		if(e[i^1].f){
			e[i^1].f--;//走到一次就减一，控制住了这个点走过探测车的数量。
			printf("%d 0\n",cnt);
			dfs(v,cnt);
			return;
		}
	}
}
int main(){
	scanf("%d%d%d",&W,&m,&n);s=nm*2+1,t=nm*2+2;
	for(int i=1;i<=n;++i){
		for(int j=1;j<=m;++j){
			scanf("%d",&a[i][j]);
			p[i][j]=(i-1)*m+j;
		}
	}
    //下面就是建边了
	for(int i=1;i<=n;++i){
		for(int j=1;j<=m;++j){
			if(a[i][j]==1) continue;
			add(p[i][j],p[i][j]+nm,INF,0);
			if(a[i][j]==2) add(p[i][j],p[i][j]+nm,1,1);//有石头，加一条取石头边
		}
	}
	add(s,1,W,0);
	for(int i=1;i<=n;++i){
		for(int j=1;j<=m;++j){
			if(a[i][j]==1) continue;
			if(j+1<=m&&a[i][j+1]!=1) add(p[i][j]+nm,p[i][j+1],INF,0);
			if(i+1<=n&&a[i+1][j]!=1) add(p[i][j]+nm,p[i+1][j],INF,0);
		}
	}
	add(nm*2,t,INF,0);
	mcmf();
	for(int i=1;i<=mf;++i) dfs(1,i);
	return 0;
} 
```
# 谢谢大家！

---

## 作者：Cyhlnj (赞：3)

一个点同一时间只有一辆车，这个条件并没有用

因为你可以一辆车一辆车走

于是这个题就和[深海机器人问题](https://www.luogu.org/problemnew/show/4012)一样了，只需要把一个位置拆成两个点就好了

输出方案就DFS一下，记一个数组，每次搜过它就++，如果等于这条边流过的流量就不能走

然后就没了~~记得检查数组大小，不然WA两遍还不知道数组开小了~~


---

```cpp
# include <bits/stdc++.h>
# define RG register
# define IL inline
# define Fill(a, b) memset(a, b, sizeof(a))
using namespace std;
typedef long long ll;
const int _(5010), __(1e6 + 10), INF(2e9);

IL ll Read(){
    char c = '%'; ll x = 0, z = 1;
    for(; c > '9' || c < '0'; c = getchar()) if(c == '-') z = -1;
    for(; c >= '0' && c <= '9'; c = getchar()) x = x * 10 + c - '0';
    return x * z;
}

int n, p, q, id[50][50], tmp[__], mp[50][50], num, ans[__], len;
int cnt, fst[_], w[__], to[__], nxt[__], dis[_], vis[_], S, T, cost[__], pe[_], pv[_], max_flow;
queue <int> Q;

IL void Add(RG int u, RG int v, RG int f, RG int co){
    cost[cnt] = co; w[cnt] = f; to[cnt] = v; nxt[cnt] = fst[u]; fst[u] = cnt++;
    cost[cnt] = -co; w[cnt] = 0; to[cnt] = u; nxt[cnt] = fst[v]; fst[v] = cnt++;
}

IL bool Bfs(){
    Q.push(S); Fill(dis, 127); dis[S] = 0; vis[S] = 1;
    while(!Q.empty()){
        RG int u = Q.front(); Q.pop();
        for(RG int e = fst[u]; e != -1; e = nxt[e]){
            if(!w[e] || dis[to[e]] <= dis[u] + cost[e]) continue;
            dis[to[e]] = dis[u] + cost[e];
            pe[to[e]] = e; pv[to[e]] = u;
            if(!vis[to[e]]) vis[to[e]] = 1, Q.push(to[e]);
        }
        vis[u] = 0;
    }
    if(dis[T] >= dis[T + 1]) return 0;
    RG int ret = INF;
    for(RG int u = T; u != S; u = pv[u]) ret = min(ret, w[pe[u]]);
    for(RG int u = T; u != S; u = pv[u]) w[pe[u]] -= ret, w[pe[u] ^ 1] += ret;
    max_flow += ret;
    return 1;
}

IL void Dfs(RG int x, RG int y){
    RG int Id = id[x][y], d0 = id[x + 1][y], d1 = id[x][y + 1];
    for(RG int e = fst[Id + num]; e != -1; e = nxt[e]){
        if(tmp[e] >= w[e ^ 1]) continue;
        if(to[e] == d0){
            ++tmp[e]; ans[++len] = 0;
            Dfs(x + 1, y);
            return;
        }
        if(to[e] == d1){
            ++tmp[e]; ans[++len] = 1;
            Dfs(x, y + 1);
            return;
        }
    }
        
}

int main(RG int argc, RG char *argv[]){
    Fill(fst, -1);
    n = Read(); q = Read(); p = Read();
    for(RG int i = 1; i <= p; ++i)
        for(RG int j = 1; j <= q; ++j)
            id[i][j] = ++num;
    T = num + num + 1;
    for(RG int i = 1; i <= p; ++i)
        for(RG int j = 1; j <= q; ++j)
            mp[i][j] = Read();
    Add(S, id[1][1], n, 0); Add(id[p][q] + num, T, n, 0);
    for(RG int i = 1; i <= p; ++i)
        for(RG int j = 1; j <= q; ++j){
            if(mp[i][j] == 1) continue;
            if(!mp[i][j]) Add(id[i][j], id[i][j] + num, INF, 0);
            else Add(id[i][j], id[i][j] + num, INF, 0), Add(id[i][j], id[i][j] + num, 1, -1);
        }
    for(RG int i = 1; i <= p; ++i)
        for(RG int j = 1; j <= q; ++j){
            if(mp[i][j] == 1) continue;
            if(i < p && mp[i + 1][j] != 1) Add(id[i][j] + num, id[i + 1][j], INF, 0);
            if(j < q && mp[i][j + 1] != 1) Add(id[i][j] + num, id[i][j + 1], INF, 0);
        }
    while(Bfs());
    for(RG int i = 1; i <= max_flow; ++i){
        len = 0; Dfs(1, 1);
        for(RG int j = 1; j <= len; ++j) printf("%d %d\n", i, ans[j]);
    }
    return 0;
}

```

---

## 作者：OIer_ACMer (赞：2)

~~当你把大数据放到火星地貌上一比对你就知道这台探测器逆天的性能了。~~

------------
## 大致思路：
由于这道题题目过于~~恶臭~~冗长，我在这里大致把题目意思说一下：

现在在点 $(1,1)$ 处有 $k$ 个探测车，他们都要去往点 $(n,m)$ 处，探测车只能向下或向右行驶，现在要求尽可能多的收集石头，并输出每一辆探测车的路径。

这个题目看起来似乎和 $k$ 取方格数有异曲同工之妙，又觉得像是一个背包 DP，但是标签上大大地写着“网络流”三字，那么我们就从网络流入手。

首先，我们可以发现，这道题与 $k$ 取方格数的区别在于这道题因为**权值在点上**，所以我们拆点，对于障碍的点不做处理，其余的点都拆为**入点和出点用来限流**，好了，最困难的部分我们已经度过了，接下来就是在这个图上跑最大费用最大流，为了方便，我们直接无视障碍点（就是干脆将除了障碍物的点都拆点了）。

拆点步骤如下：

1. 首先将从原点到起点的流量设置为 $k$，花费为 $0$。

2. 将每一个石块入点到每一个石块出点的流量设置为 $1$，花费为 $1$。

3. 将每一个石块出点到每一个石块入点的流量设置为无穷大，花费为 $0$。

4. 将每一个空白点入点到每一个空白点出点的流量设置为无穷大，花费为依旧 $0$。

5. 之后就开始对路径上的点进行拆分，将每一个点出点到可到达的点入点的流量设置为无穷大，花费为 $0$。

6. 同时将终点到汇点的流量设置为 $k$，花费为 $0$。

最后就是路径输出了，在路径输出的过程中我们直接在残余网络上寻找答案就可以了，由于我们根据残余网络的性质可以知道，**由于是反向边，一开始边全部都是 $0$，只要有一条边的边权大于了 $0$，就说明这条边走过了，被采用了，对答案做了贡献**。因此边权为大于 $0$ 时，就说明它对答案有贡献，就直接输出就可以了。

------------
## 代码如下：

```c++
#include <bits/stdc++.h>
using namespace std;
#define int long long
inline int read()
{
    register int x = 0, f = 1;
    char ch = getchar();
    while (ch < '0' || ch > '9')
    {
        if (ch == '-')
        {
            f = -1;
        }
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9')
    {
        x = x * 10 + ch - '0';
        ch = getchar();
    }
    return x * f;
}
const int inf = 0x3f3f3f3f;
const int N = 3e3 + 100; 
const int M = 1e6 + 100; 
const int b[2][2] = {1, 0, 0, 1};
struct Edge
{
    int to, w, cost, next;
} edge[M];
int head[N], cnt, n, m, mp[N][N];
void addedge(int u, int v, int w, int cost)
{
    edge[cnt].to = v;
    edge[cnt].w = w;
    edge[cnt].cost = cost;
    edge[cnt].next = head[u];
    head[u] = cnt++;
    edge[cnt].to = u;
    edge[cnt].w = 0;
    edge[cnt].cost = -cost;
    edge[cnt].next = head[v];
    head[v] = cnt++;
}
int d[N], incf[N], pre[N];
bool vis[N];
bool spfa(int s, int t)
{
    memset(d, 0xcf, sizeof(d));
    memset(vis, false, sizeof(vis));
    memset(pre, -1, sizeof(pre));
    queue<int> q;
    q.push(s);
    vis[s] = true;
    incf[s] = inf;
    d[s] = 0;
    while (!q.empty())
    {
        int u = q.front();
        q.pop();
        vis[u] = false;
        for (int i = head[u]; i != -1; i = edge[i].next)
        {
            int v = edge[i].to;
            int w = edge[i].w;
            int cost = edge[i].cost;
            if (!w)
            {
                continue;
            }
            if (d[v] < d[u] + cost)
            {
                d[v] = d[u] + cost;
                pre[v] = i;
                incf[v] = min(incf[u], w);
                if (!vis[v])
                {
                    vis[v] = true;
                    q.push(v);
                }
            }
        }
    }
    return pre[t] != -1;
}

int update(int s, int t)
{
    int x = t;
    while (x != s)
    {
        int i = pre[x];
        edge[i].w -= incf[t];
        edge[i ^ 1].w += incf[t];
        x = edge[i ^ 1].to;
    }
    return d[t] * incf[t];
}
void init()
{
    memset(head, -1, sizeof(head));
    cnt = 0;
}
int solve(int st, int ed)
{
    int ans = 0;
    while (spfa(st, ed))
    {
        ans += update(st, ed);
    }
    return ans;
}
int get_id(int x, int y, int k)
{
    return (x - 1) * m + y + k * n * m;
}
void print(int pos)
{
    int x = 1, y = 1;
    while ("%zx") 
    {
        if (x == n && y == m)
        {
            return;
        }
        for (int i = head[get_id(x, y, 1)]; i != -1; i = edge[i].next)
        {
            int v = edge[i].to;
            if (edge[i ^ 1].w == 0)
            {
                continue;
            }
            if (v == get_id(x, y + 1, 0))
            {
                edge[i ^ 1].w--;
                printf("%d %d\n", pos, 1);
                y++;
                break;
            }
            else if (v == get_id(x + 1, y, 0))
            {
                edge[i ^ 1].w--;
                printf("%d %d\n", pos, 0);
                x++;
                break;
            }
        }
    }
}
signed main()
{
    init();
    int k, st = N - 1, ed = st - 1;
    k = read();
    m = read();
    n = read();
    for (int i = 1; i <= n; i++)
    {
        for (int j = 1; j <= m; j++)
        {
            mp[i][j] = read();
        }
    }
    for (int i = 1; i <= n; i++)
    {
        for (int j = 1; j <= m; j++)
        {
            if (mp[i][j] == 2)
            {
                addedge(get_id(i, j, 0), get_id(i, j, 1), 1, 1);
                addedge(get_id(i, j, 0), get_id(i, j, 1), inf, 0);
            }
            else if (mp[i][j] == 0)
            {
                addedge(get_id(i, j, 0), get_id(i, j, 1), inf, 0);
            }
        }
    }
    for (int i = 1; i <= n; i++)
    {
        for (int j = 1; j <= m; j++)
        {
            if (mp[i][j] == 1)
            {
                continue;
            }
            else
            {
                if (i + 1 <= n && mp[i + 1][j] != 1)
                {
                    addedge(get_id(i, j, 1), get_id(i + 1, j, 0), inf, 0);
                }
                if (j + 1 <= m && mp[i][j + 1] != 1)
                {
                    addedge(get_id(i, j, 1), get_id(i, j + 1, 0), inf, 0);
                }
            }
        }
    }
    addedge(st, get_id(1, 1, 0), k, 0);
    addedge(get_id(n, m, 1), ed, k, 0);
    solve(st, ed);
    for (int i = 1; i <= k; i++)
    {
        print(i);
    }
    return 0;
}

```

[AC 记录](https://www.luogu.com.cn/record/126877644)

---

## 作者：ningago (赞：2)

## P3356 火星探险问题

### 建图：

因为（有些点）有点权，所以拆点为边，出点向入点连边，容量 $\inf$ 费用 $0$，如果有岩石，**再**连一条边，容量 $1$ 费用 $1$（因为只能由一辆车进行采集）。

从源点向点 $(1,1)$ 连边，容量 $n$ 费用 $0$，$(p,q)$ 向源点连边，容量 $\inf$ 费用 $0$。

每个点（出点）向下方和右方（入）点连容量 $n$ 费用 $0$ 的边，但需保证边的两端都不是障碍。

如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/zhg5j4qb.png)

### 打印路径

如果一条边的容量为 $f$，流量为 $r$ $(r\leq f)$，根据 EK 和 dinic 算法的特点，最终的容量为 $f - r$ ，而反向边容量为 $r$。

所以，可以从源点进行打印，如果右边的 $r > 0$ 则走右边，否则走下边。每次确定方向后，将该边容量加一（即 $r$ 减一），以便确定下一条路径。

### 注意事项

- 不能把 $(1,1),(p,q)$ 作为源点和汇点，因为这两个点也可能有岩石。

- 输入的 $p,q$ 是反的。

### Code：

```cpp
#include <cstdio>
#include <queue>
#include <cstring>

#define N 3500
#define M 1000010
#define inf 0x3f3f3f3f

int min(int x,int y){return x < y ? x : y;}
int n,m,s,S,T,cnt,ans1,ans2;
int a[N][N],b[N][N];
int h[N],cur[N],e[M << 1],f[M << 1],c[M << 1],ne[M << 1],idx = -1;
void add_edge(int x,int y,int z,int zz)
{
    ne[++idx] = h[x];
    h[x] = idx;
    e[idx] = y;
    f[idx] = z;
    c[idx] = zz;
}

void add(int x,int y,int z,int zz)
{
    add_edge(x,y,z,zz);
    add_edge(y,x,0,-zz);
}
int dis[N];
bool vis[N];
bool spfa()
{
    memset(dis,-0x3f,sizeof(dis));
    memcpy(cur,h,sizeof(h));
    std::queue <int> q;
    q.push(S);
    vis[S] = 1;
    int ds = dis[S];
    dis[S] = 0;
    while(!q.empty())
    {
        int t = q.front();
        q.pop();
        vis[t] = 0;
        for(int i = h[t];~i;i = ne[i])
        {
            int nx = e[i];
            if(f[i] && dis[nx] < dis[t] + c[i])
            {
                dis[nx] = dis[t] + c[i];
                if(!vis[nx])
                {
                    q.push(nx);
                    vis[nx] = 1;
                }
            }
        }
    }
    return dis[T] != ds;
}

int dfs(int k,int flow)
{
    if(k == T)
        return flow;
    vis[k] = 1;
    int res = 0;
    for(int &i = cur[k];~i && res < flow;i = ne[i])
    {
        int nx = e[i];
        if(f[i] && !vis[nx] && dis[nx] == dis[k] + c[i])
        {
            int t = dfs(nx,min(f[i],flow - res));
            if(t)
            {
                ans2 += t * c[i];
                f[i] -= t;
                f[i ^ 1] += t;
                res += t;
            }
        }
    }
    vis[k] = 0;
    return res;
}

int MCMF()
{
    int res = 0,x;
    while(spfa())
        while((x = dfs(S,inf)))
            res += x;
    return res;
}

void write(int x,int y,int id)
{
    if(x == n && y == m)
        return;
    int right = 0,righti,down = 0,downi;
    for(int i = h[b[x][y] + cnt];~i;i = ne[i])
    {
        int nx = e[i];
        if(nx == b[x + 1][y] && x != n)
        {
            down += inf - f[i];
            if(inf - f[i])
                downi = i;
        }
        if(nx == b[x][y + 1] && y != m)
        {
            right += inf - f[i];
            if(inf - f[i])
                righti = i;
        }
    }
    if(down)
    {
        f[downi]++;
        printf("%d 0\n",id);
        write(x + 1,y,id);
    }
    else if(right)
    {
        f[righti]++;
        printf("%d 1\n",id);
        write(x,y + 1,id);
    }
}

int main()
{
    #ifdef CHECK
    freopen("maker.txt","r",stdin);
    freopen("std.txt","w",stdout);
    #endif
    memset(h,-1,sizeof(h));
    scanf("%d%d%d",&s,&m,&n);
    S = 0,T = n * m * 2 + 1;
    for(int i = 1;i <= n;i++)
    {
        for(int j = 1;j <= m;j++)
        {
            scanf("%d",&a[i][j]);
            b[i][j] = ++cnt;
        }
    }
    for(int i = 1;i <= n;i++)
    {
        for(int j = 1;j <= m;j++)
        {
            if(i == 1 && j == 1)
                add(S,b[i][j],s,0);
            if(i == n && j == m)
                add(b[i][j] + cnt,T,inf,0);
            if(a[i][j] != 1)
            {
                add(b[i][j],b[i][j] + cnt,inf,0);
                if(i != n && a[i + 1][j] != 1)
                    add(b[i][j] + cnt,b[i + 1][j],inf,0);
                if(j != m && a[i][j + 1] != 1)
                    add(b[i][j] + cnt,b[i][j + 1],inf,0);
                if(a[i][j] == 2)
                    add(b[i][j],b[i][j] + cnt,1,1);
            }
        }
    }
    ans1 = MCMF();
    for(int i = 1;i <= s;i++)
        write(1,1,i);
    return 0;
}
```

---

## 作者：Xlon_Rainfi (赞：1)

# $\large\mathfrak{1st.\ Preamble|}$ 前言

这都什么年代了网络流 24 题居然还能写题解！

个人认为这篇题解讲的还是比较详细的。

# $\large\mathfrak{2nd.\ Solution|}$ 题解

看到题目的第一眼，我的反应是这样的：这不跟[深海机器人问题](https://www.luogu.com.cn/problem/P4012)差不多吗？`Ctrl-C` `Ctrl-V` 秒了。

不过我还是讲讲怎么建模吧。

这里我定义点 $(x,y)$ 表示第 $x$ 行第 $y$ 列的数，和题目中的是反过来的 ~~（题目里的那种表示方法有点反人类）~~。

## 建模

把一个点 $(x,y)$ 拆成 $(x,y)_1$ 和 $(x,y)_2$ 两个点，$x_1$ 为入点，$x_2$ 为出点。

### 平坦无障碍（$0$）

1. 建边 $(x,y)_1 \rightarrow (x,y)_2$，容量为 $\inf$，费用为 $0$，代表这个点可以走无数次，没有收益。
2. 建边 $(x,y)_2 \rightarrow (x+1,y)_1$，容量为 $\inf$，费用为 $0$，代表这个从这个点向南到下面那个点可以走无数次。
3. 建边 $(x,y)_2 \rightarrow (x,y+1)_1$，容量为 $\inf$，费用为 $0$，代表这个从这个点向东到右边那个点可以走无数次。

### 障碍（$1$）

没法走，不用管它。

### 石块（$2$）

和平坦无障碍的相比，只需要再多加一条边 $(x,y)_1 \rightarrow (x,y)_2$，容量为 $1$，费用为 $1$，代表只可以捡一次石块，收益为 $1$。

最后跑最大费用最大流即可。

## 输出

我建完模就直接输出费用，然后开开心心地跑去测样例，丫的，居然要输出路径！我当场懵逼，冥（cha）思（kan）苦（ti）想（jie）后得到了下面的方法：

对于每条路径，从起点开始搜索，每搜到一个点，选一条反向边有剩余容量（说明被走过）的临边走过去，并把反向边的剩余容量减去 $1$，直到走到终点。

如果看不懂可以看代码：

```cpp
void put_ans(int a){
    int x=1,y=1;    // 从起点开始搜索
    while(1){
        if(x>=q&&y>=p)return;  // 到达终点
        int u=B(x,y);
        for(int i=head[u];i;i=e[i].pre){
            int v=e[i].to;
            if(!e[i^1].w)continue;  // 反向边有剩余容量
            if(v==A(x+1,y)){x++,e[i^1].w--,printf("%d 0\n",a);break;}  // 向南走
            if(v==A(x,y+1)){y++,e[i^1].w--,printf("%d 1\n",a);break;}  // 向东走
        }
    }
}
```

# $\large\mathfrak{3rd.\ Code|}$ 代码

我是把边权设为负数跑最小费用最大流的方式求解最大费用最大流。代码压行请见谅。

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const ll inf=1e18,N=5e3+10,M=5e4+10;
inline int read(){
	int x=0,f=1;char ch=getchar();
	while (ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}
	while (ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}
	return x*f;
}
ll e_cnt=1,head[N];
struct EDGE{ll from,to,w,c,pre;}e[M<<1];
ll n,p,q,s,t,ans,cost;
ll dis[N],pre[N];
inline void add(ll from,ll to,ll w,ll c){
    e[++e_cnt]=(EDGE){from,to,w,c,head[from]};
    head[from]=e_cnt;
}
inline void add_edge(ll u,ll v,ll w,ll c){
    add(u,v,w,c),add(v,u,0,-c);
}
inline int A(int x,int y){return (x-1)*p+y;}    // (x,y)_1
inline int B(int x,int y){return A(x,y)+p*q;}   // (x,y)_2
//------------------最大费用最大流板子---------------------
bool spfa(ll s,ll t){
    bool inq[N];
    memset(pre,-1,sizeof(pre));
    for(int i=1;i<=t;i++)dis[i]=inf,inq[i]=0;
    queue<ll>que;
    dis[s]=0,inq[s]=1,que.push(s);
    while(!que.empty()){
        ll u=que.front();
        que.pop();
        inq[u]=0;
        for(int i=head[u];i;i=e[i].pre){
            if(e[i].w>0){
                ll v=e[i].to,c=e[i].c;
                if(dis[u]+c<dis[v]){
                    dis[v]=dis[u]+c;
                    pre[v]=i;
                    if(!inq[v]){
                        que.push(v);
                        inq[v]=1;
                    }
                }
            }
        }
    }
    return dis[t]!=inf;
}
void mincost(ll s,ll t){
    while(spfa(s,t)){
        ll v=t,flow=inf;
        while(pre[v]!=-1){
            ll i=pre[v],u=e[i].from;
            flow=min(flow,e[i].w);
            v=u;
        }
        v=t;
        while(pre[v]!=-1){
            ll i=pre[v],u=e[i].from;
            e[i].w-=flow;
            e[i^1].w+=flow;
            v=u;
        }
        cost+=dis[t]*flow;
        ans+=flow;
    }
}
//------------end of 最大费用最大流-------------
void put_ans(int a){
    int x=1,y=1;    // 从起点开始搜索
    while(1){
        if(x>=q&&y>=p)return;  // 到达终点
        int u=B(x,y);
        for(int i=head[u];i;i=e[i].pre){
            int v=e[i].to;
            if(!e[i^1].w)continue;  // 反向边有剩余容量
            if(v==A(x+1,y)){x++,e[i^1].w--,printf("%d 0\n",a);break;}  // 向南走
            if(v==A(x,y+1)){y++,e[i^1].w--,printf("%d 1\n",a);break;}  // 向东走
        }
    }
}
int main(){
    n=read(),p=read(),q=read();
    s=p*q*2+1,t=s+1;
    for(int i=1;i<=q;i++){
        for(int j=1;j<=p;j++){
            int x;
            x=read();
            if(x!=1){    // 0和2有三条相同边，合在一起，1啥也不干
                add_edge(A(i,j),B(i,j),inf,0);
                if(i+1<=q)add_edge(B(i,j),A(i+1,j),inf,0);
                if(j+1<=p)add_edge(B(i,j),A(i,j+1),inf,0);
                if(x==2)add_edge(A(i,j),B(i,j),1,-1);  // 2多建一条边
            }
        }
    }
    add_edge(s,A(1,1),n,0);
    add_edge(B(q,p),t,n,0);
    mincost(s,t);
    for(int i=1;i<=ans;i++)put_ans(i);
    return 0;
}
```

[AC 记录](https://www.luogu.com.cn/record/172049267)

# $\large\mathfrak{4th.\ Postscript|}$ 后记

第一遍编号标错居然可以拿 $84$ 分（只有 #5 没过），这数据着实有点水……

---

## 作者：Exber (赞：1)

## 题意

- 给定一个 $p\times q$ 的网格，每个格子可能是平地、障碍或者石子；

- 可以选择 $n$ 条从 $(1,1)$ 到 $(p,q)$ 的路线（只能往右或者往下走），经过有石子的格子会把石子取走，取走后该格子变为平地；

- 请输出你选择的 $n$ 条路径使得取到的石子数量最多。

## 做法

最小费用最大流。

首先因为石子在点上，所以需要把每个点拆成入点 $(x,y)$ 和出点 $(x,y)\prime$。

先从 $(x,y)\prime$ 分别向 $(x+1,y)$ 和 $(x,y+1)$ 连流量为 $inf$，费用为 $0$ 的边。

然后来考虑 $(x,y)$ 和 $(x,y)\prime$ 之间的连边：
- 对于空地，直接在 $(x,y)$ 和 $(x,y)\prime$ 之间连一条流量为 $inf$，费用为 $0$ 的边。

- 对于有石子的点，因为只能取一次该点上的石子，但是该点能经过多次，所以 $(x,y)$ 和 $(x,y)\prime$ 之间需要**连两条边**：一条流量为 $1$，费用为 $-1$，表示取走该点的石子；另一条流量为 $inf$，费用为 $0$ 表示不取该点的石子。

- 而对于障碍，$(x,y)$ 和 $(x,y)\prime$ 之间**不需要连任何边**，表示该点无法通行。

接下来从源点向 $(1,1)$ 连一条流量为 $n$，费用为 $0$ 的边，从$(1,1)\prime$ 向汇点连一条流量为 $n$，费用为 $0$ 的边，代表有 $n$ 条路径。

最后跑一次最小费用最大流，再输出一下路径即可。

输出路径可以跑 $n$ 遍 `dfs`，每次只经过反向边流量 $>0$ 的边。

值得注意的一点是，**需要先读入 $q$，再读入 $p$**。

## AC 代码

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <queue>

using namespace std;

#define S 5000005
#define MS 100005

int q,n,m,s,t;
int esum,to[S],nxt[S],c[S],cost[S],h[MS];
int dis[MS],cur[MS];
bool vis[MS];
int maxflow,mincost;

inline int id(int x,int y)
{
	return (x-1)*m+y;
}

inline int getx(int x)
{
	return (x-1)/m+1;
}

inline int gety(int x)
{
	return (x-1)%m+1;
}

inline void init()
{
	esum=1;
	memset(h,0,sizeof(h));
	s=0;
	t=n*m*2+1;
}

inline void add(int x,int y,int w,int v)
{
	to[++esum]=y;
	c[esum]=w;
	cost[esum]=v;
	nxt[esum]=h[x];
	h[x]=esum;
}

inline bool spfa()
{
	memset(dis,127,sizeof(dis));
	memset(vis,0,sizeof(vis));
	int inf=dis[0];
	queue<int> q;
	q.push(s);
	dis[s]=0;
	vis[s]=true;
	while(!q.empty())
	{
		int u=q.front();
		q.pop();
		vis[u]=false;
		for(int i=h[u];i;i=nxt[i])
		{
			int v=to[i];
			if(c[i]>0&&dis[u]+cost[i]<dis[v])
			{
				dis[v]=dis[u]+cost[i];
				if(!vis[v])
				{
					vis[v]=true;
					q.push(v);
				}
			}
		}
	}
	return dis[t]<inf;
}

int dfs(int u,int w)
{
	if(u==t)
	{
		return w;
	}
	vis[u]=true;
	int sum=0;
	for(int &i=cur[u];i;i=nxt[i])
	{
		int v=to[i];
		if(c[i]>0&&dis[v]==dis[u]+cost[i]&&!vis[v])
		{
			int re=dfs(v,min(w,c[i]));
			mincost+=re*cost[i];
			c[i]-=re;
			c[i^1]+=re;
			w-=re;
			sum+=re;
			if(w==0)
			{
				break;
			}
		}
	}
	return sum;
}

inline void mcmf()
{
	maxflow=0;
	mincost=0;
	while(spfa())
	{
		for(int i=s;i<=t;i++)
		{
			cur[i]=h[i];
		}
		maxflow+=dfs(s,1e8); 
	}
}

void out(int num,int x,int y) // 输出路径 
{
	if(x==n&&y==m) // 走到了 
	{
		return;
	}
	int u=n*m+id(x,y); // 获得 (x,y)' 的编号 
	for(int i=h[u];i;i=nxt[i])
	{
		int v=to[i];
		if(v>n*m) // 判断走到的是不是入点 
		{
			continue; 
		}
		int nx=getx(v),ny=gety(v); // 获得走到的 x 和 y 
		if(c[i^1]>0&&(nx>x||ny>y)) // 如果是往右或者往下，并且反向边有流量 
		{
			c[i^1]--; // 反向边走过一次了，流量 -- 
			printf("%d %d\n",num,(int)(nx==x)); // 输出 
			out(num,nx,ny);
			return; // 找到路了，直接 return 
		}
	}
}

int main()
{
	scanf("%d%d%d",&q,&m,&n); // 注意读入顺序 
	init(); 
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{ 
			if(i<n)
			{
				add(n*m+id(i,j),id(i+1,j),1e8,0);
				add(id(i+1,j),n*m+id(i,j),0,0);
			}
			if(j<m)
			{
				add(n*m+id(i,j),id(i,j+1),1e8,0);
				add(id(i,j+1),n*m+id(i,j),0,0);
			}
			int x;
			scanf("%d",&x);
			if(x==1) // 障碍，不需要建边 
			{
				continue;
			}
			add(id(i,j),n*m+id(i,j),1e8,0);
			add(n*m+id(i,j),id(i,j),0,0);
			if(x==2) // 石子，可以取一次 
			{
				add(id(i,j),n*m+id(i,j),1,-1);
				add(n*m+id(i,j),id(i,j),0,1);
			}
		}
	} 
	add(s,id(1,1),q,0);
	add(id(1,1),s,0,0);
	add(n*m+id(n,m),t,q,0);
	add(t,n*m+id(n,m),0,0);
	mcmf();
	for(int i=1;i<=q;i++) // 记得要输出多条路径 
	{
		out(i,1,1);
	}
	return 0;
}
```

---

## 作者：Booksnow (赞：1)

# 费用流

## 题目大意

给你一张 $P \times Q$ 的地图，其上共有三种地形：

- $mp[i][j]=0$，表示地图的第 $i$ 行第 $j$ 列是平坦地形，可以随意通过。

- $mp[i][j]=1$，表示地图的第 $i$ 行第 $j$ 列是障碍地形，不可通过。

- $mp[i][j]=2$，表示地图的第 $i$ 行第 $j$ 列是岩石标本，可以随意通过，但只能记录一次通过表示采集。

现在，有 $n$ 辆探测车，它们**只能向东或向南走**，你需要在保证他们**能够到达终点**的情况下，**尽可能获得多的岩石标本**（注意：若探测车没有到达终点，则其采集到的岩石标本**作废**）

## 题目分析

显然，此题可以用**最大费用最大流**解决。

### 考虑如何建图：

- 对于每一个为 $2$ 的节点，只能被采集一次，我们很自然的想到了通过拆点来解决。把节点 $i$ 拆成节点 $i_1$ 和 $i_2$ ，实现岩石标本采集一次的操作其实就是在 $i_1$ 与 $i_2$ 之间连一条流量为 $1$ ，费用也为 $1$ 的边。但在被采集过后， $2$ 节点还可以被经过无数次，对应的建边是再建一条流量为正无穷，费用为 $0$ 的边。

- 对于每一个为 $1$ 的节点，显然任何点都不会向它连边，他也不会向任何点连边。

- 对于每一个为 $0$ 的节点，其实理论上来说我们应该可以不用拆点，因为除 $1$ 外每个节点的点权都是正无穷，没有必要将点权转化为边权来限制流量，但是为了方便，我们还是把其拆成两个点，中间用一条流量为正无穷，费用为 $0$ 的边将他们连接起来。

具体可参考下面的建图代码：

```cpp
//建图(总结点数位2*p*q，源点位0,汇点为2*p*q+1)
//将所有点全部拆开
//拆开点之间的连边：0->0，流量INF，费用0,1->1流量1，费用1 
for(register int i=1;i<=p;i++){
	for(register int j=1;j<=q;j++){
		if(mp[i][j]==1) continue; //任何点都不与障碍物连边
		int u=Get_id(i,j),v; //u表示现在的节点编号，v表示目标节点编号 
		//设节点i的拆点为i' 
		//向外连边:u'->v
		for(register int k=0;k<=1;k++){
			int nx=i+dx[k],ny=j+dy[k];
			if(nx>p||ny>q) continue; //不超出边界
			if(mp[nx][ny]==1) continue; //障碍物 
			v=Get_id(nx,ny);
			Add(u+p*q,v,INF,0),Add(v,u+p*q,0,0);
		}
		//自己连接自己:u->u' 
		//对于岩石标本，建立两组边，第一组对答案产生贡献的限流1，表示他只能被采集一次
		//第二组表示岩石标本可以和普通地面一样，可以在任意时刻抵达 
		if(mp[i][j]==2) Add(u,u+p*q,1,1),Add(u+p*q,u,0,-1); //当前节点为岩石标本 
			//初开障碍物外任何点可以任意到达 
		Add(u,u+p*q,INF,0),Add(u+p*q,u,0,0);
	}
}
```
### 如何打印路径

对于路径，我们只需要从 $(1,1)$ 处在残次图上跑一边 $DFS$ ，找到那些**被流经的边**，将其打印下来即可

参考代码如下:

```cpp
inline void DFS(int x,int y,int u,int k)
{
	int kx,ky,mov;
	for(register int i=first[u];i!=-1;i=nex[i]){
		int to=v[i];
		if(to==s||to==t||to==u-p*q||!w[i^1]) continue;
		w[i^1]--; //经过的次数--，知道为0，说明该边上经过的探测车都已经被考虑完了
		if(to>p*q) { DFS(x,y,to,k); return; } //如果到达i'即连接其他点的拆点 
		if(to==Get_id(x,y)+1) kx=x,ky=y+1,mov=1; //判断走向了哪一个点 
		else kx=x+1,ky=y,mov=0;
		printf("%d %d\n",k,mov);
		DFS(kx,ky,to+p*q,k); //递归 
		return;
	}
}
```
### 注意

本题的 $p$ 和 $q$ 的**输入顺序**，先输入的列，再输入的行，~~我调了一年才发现，简直服了。~~

## CODE

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=1e2,INF=0x3f3f3f3f;
const int dx[2]={0,1},dy[2]={1,0};
int n,p,q;
int s,t,ans,maxf;
int mp[N][N];
inline int read()
{
	int s=0,w=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-') w=-1;ch=getchar();}
	while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
	return s*w;
}
int tot=-1,v[N*N*N],w[N*N*N],pay[N*N*N],nex[N*N*N],first[2*N*N];
inline void Add(int x,int y,int z,int c)
{
	nex[++tot]=first[x];
	first[x]=tot;
	v[tot]=y,w[tot]=z,pay[tot]=c;
}
inline int Get_id(int x,int y) { return (x-1)*q+y; }
bool vis[2*N*N];
//Min[i]表示到达点i经过的边流量最小的一个 
int dis[2*N*N],pre[2*N*N],Min[2*N*N];
inline bool SPFA()
{
	for(register int i=s;i<=t;i++) vis[i]=false;
	for(register int i=s;i<=t;i++) dis[i]=-INF;
	queue<int> q; q.push(s);
	vis[s]=true,dis[s]=0,Min[s]=INF;
	while(!q.empty()){
		int now=q.front(); q.pop();
		vis[now]=false;
		for(register int i=first[now];i!=-1;i=nex[i]){
			int to=v[i];
			if(!w[i]) continue; //没有流量 
			if(dis[to]<dis[now]+pay[i]){ //最长路更新 
				dis[to]=dis[now]+pay[i];
				Min[to]=min(Min[now],w[i]);
				pre[to]=i;
				if(!vis[to]) q.push(to),vis[to]=true;
			}
		}
	}
	return dis[t]!=-INF;
}
inline void EK()
{
	while(SPFA()){
		maxf+=Min[t];
		int temp=t,i;
		while(temp!=s){
			i=pre[temp];
			w[i]-=Min[t]; 
			w[i^1]+=Min[t];
			temp=v[i^1];
		}
	}
}
inline void DFS(int x,int y,int u,int k)
{
	int kx,ky,mov;
	for(register int i=first[u];i!=-1;i=nex[i]){
		int to=v[i];
		if(to==s||to==t||to==u-p*q||!w[i^1]) continue;
		w[i^1]--;
		if(to>p*q) { DFS(x,y,to,k); return; } //如果到达i'即连接其他点的拆点 
		if(to==Get_id(x,y)+1) kx=x,ky=y+1,mov=1; //判断走向了哪一个点 
		else kx=x+1,ky=y,mov=0;
		printf("%d %d\n",k,mov);
		DFS(kx,ky,to+p*q,k); //递归 
		return;
	}
}
int main()
{
	memset(first,-1,sizeof(first));
	n=read(),q=read(),p=read();
	for(register int i=1;i<=p;i++)
		for(register int j=1;j<=q;j++)  mp[i][j]=read();
	s=0,t=2*p*q+1;
	//建图(总结点数位2*p*q，源点位0,汇点为2*p*q+1)
	//将所有点全部拆开
	//拆开点之间的连边：0->0，流量INF，费用0,1->1流量1，费用1 
	for(register int i=1;i<=p;i++){
		for(register int j=1;j<=q;j++){
			if(mp[i][j]==1) continue; //任何点都不与障碍物连边
			int u=Get_id(i,j),v; //u表示现在的节点编号，v表示目标节点编号 
			//设节点i的拆点为i' 
			//向外连边:u'->v
			for(register int k=0;k<=1;k++){
				int nx=i+dx[k],ny=j+dy[k];
				if(nx>p||ny>q) continue; //不超出边界
				if(mp[nx][ny]==1) continue; //障碍物 
				v=Get_id(nx,ny);
				Add(u+p*q,v,INF,0),Add(v,u+p*q,0,0);
			}
			//自己连接自己:u->u' 
			//对于岩石标本，建立两组边，第一组对答案产生贡献的限流1，表示他只能被采集一次
			//第二组表示岩石标本可以和普通地面一样，可以在任意时刻抵达 
			if(mp[i][j]==2) Add(u,u+p*q,1,1),Add(u+p*q,u,0,-1); //当前节点为岩石标本 
			//初开障碍物外任何点可以任意到达 
			Add(u,u+p*q,INF,0),Add(u+p*q,u,0,0);
		}
	}
	if(mp[1][1]!=1) Add(s,1,n,0),Add(1,s,0,0);
	if(mp[p][q]!=1) Add(Get_id(p,q)+p*q,t,n,0),Add(t,Get_id(p,q)+p*q,0,0);
	EK();
	for(register int i=1;i<=maxf;i++) DFS(1,1,1,i);
	return 0;
}
```


---

## 作者：incra (赞：0)

### Sol
考虑建模：

考虑把每个点拆成 $(i,j)_1$ 和 $(i,j)_2$，分别表示入点和出点。（此处拆点是为了添加每个点上的岩石被选一次的限制。）

那么此时就要跑最大费用最大流，考虑把边权取反，那么就变成了常规的最小费用最大流。

1. 对于 $g_{i,j}\neq 1$，连一条 $(i,j)_1\to (i,j)_2$ 的边，流量 $+\infty$，费用 $0$。
1. 对于 $g_{i,j}= 2$，连一条 $(i,j)_1\to (i,j)_2$ 的边，流量 $1$，费用 $-1$。表示每个岩石至多被选 $1$ 次。
1. 对于 $(i,j)$ 满足 $i<n$，连一条 $(i,j)_2\to (i+1,j)_1$ 的边，流量 $+\infty$，费用 $0$。
2. 对于 $(i,j)$ 满足 $j<m$，连一条 $(i,j)_2\to (i,j+1)_1$ 的边，流量 $+\infty$，费用 $0$。
3. 连一条 $s\to (1,1)_1$ 的边，流量 $+\infty$，费用 $0$。
4. 连一条 $(n,m)_2\to t$ 的边，流量 $+\infty$，费用 $0$。

对于方案的处理，尽可能地往右，然后往下，这样考虑的方案一定和网络流的方案相等。
### Code
```
#include <bits/stdc++.h>
#define x first
#define y second
#define pb push_back
#define pf push_front
#define desktop "C:\\Users\\incra\\Desktop\\"
#define IOS ios :: sync_with_stdio (false),cin.tie (0),cout.tie (0)
using namespace std;
typedef long long LL;
typedef unsigned long long ULL;
typedef pair <int,int> PII;
const int dx[] = {1,0,-1,0},dy[] = {0,-1,0,1};
template <typename T1,typename T2> bool tomax (T1 &x,T2 y) {
	if (y > x) return x = y,true;
	return false;
}
template <typename T1,typename T2> bool tomin (T1 &x,T2 y) {
	if (y < x) return x = y,true;
	return false;
}
LL power (LL a,LL b,LL p) {
	LL ans = 1;
	while (b) {
		if (b & 1) ans = ans * a % p;
		a = a * a % p;
		b >>= 1;
	}
	return ans;
}
int fastio = (IOS,0);
#define endl '\n'
#define puts(s) cout << (s) << endl
const int N = 1000010,N1 = 40,M = 1000010,INF = 1e8;
int k,m,n,s,t;
int g[N1][N1];
int h[N],h2[N],e[M],ne[M],w[M],f[M],idx;
int d[N],flow[N],q[N],pre[N];
bool st[N];
int get (int x,int y) {
	return (x - 1) * m + y;
}
void add_edge_ (int h[],int a,int b,int c,int d) {
	e[idx] = b;
	f[idx] = c;
	w[idx] = d;
	ne[idx] = h[a];
	h[a] = idx++;
}
void add_edge (int h[],int a,int b,int c,int d) {
	add_edge_ (h,a,b,c,d),add_edge_ (h,b,a,0,-d);
}
bool SPFA () {
	int hh = 0,tt = 0;
	q[tt++] = s;
	memset (d,0x3f,sizeof  (d));
	memset (flow,0,sizeof (flow));
	d[s] = 0,flow[s] = INF;
	while (hh != tt) {
		int u = q[hh++];
		if (hh == N) hh = 0;
		st[u] = 0;
		for (int i = h[u];~i;i = ne[i]) {
			int v = e[i];
			if (f[i] && d[v] > d[u] + w[i]) {
				d[v] = d[u] + w[i];
				pre[v] = i;
				flow[v] = min (flow[u],f[i]);
				if (!st[v]) {
				    q[tt++] = v;
				    if (tt == N) tt = 0;
					st[v] = 1;
				}
			}
		}
	}
	return flow[t] > 0;
}
void EK (int &ans1,int &ans2) {
	ans1 = ans2 = 0;
	while (SPFA ()) {
		int tmp = flow[t];
		ans1 += tmp,ans2 += tmp * d[t];
		for (int i = t;i != s;i = e[pre[i] ^ 1]) f[pre[i]] -= tmp,f[pre[i] ^ 1] += tmp;
	}
}
void print (int id,int u) {
	for (int i = h2[u];~i;i = ne[i]) {
		int v = e[i];
		if (!f[i]) continue;
		f[i]--;
		if (v == u + 1) cout << id << ' ' << 1 << endl;
		else cout << id << ' ' << 0 << endl;
		print (id,v);
		return ;
	}
}
void mian () {
	memset (h,-1,sizeof (h));
	memset (h2,-1,sizeof (h2));
	cin >> k >> m >> n;
	s = 2 * n * m + 1,t = 2 * n * m + 2;
	add_edge (h,s,1,k,0),add_edge (h,2 * n * m,t,k,0);
	for (int i = 1;i <= n;i++) for (int j = 1;j <= m;j++) {
		cin >> g[i][j];
		if (g[i][j] == 2) add_edge (h,get (i,j),get (i,j) + n * m,1,-1);
		if (g[i][j] != 1) add_edge (h,get (i,j),get (i,j) + n * m,INF,0);
	}
	for (int i = 1;i <= n;i++) for (int j = 1;j <= m;j++) {
		if (i + 1 <= n) add_edge (h,get (i,j) + n * m,get (i + 1,j),INF,0);
		if (j + 1 <= m) add_edge (h,get (i,j) + n * m,get (i,j + 1),INF,0);
	}
	int ans1,ans2;
	EK (ans1,ans2);
	for (int i = n * m + 1;i <= 2 * n * m - 1;i++) {
		if (g[(i - n * m - 1) / m + 1][(i - n * m - 1) % m + 1] == 1) continue;
		for (int _ = h[i];~_;_ = ne[_]) {
			int j = e[_];
			if (j + n * m == i) continue;
			if (f[_] == INF) continue;
			if (j != t) add_edge (h2,i - n * m,j,INF - f[_],0);
		}
	}
	for (int i = 1;i <= k;i++) print (i,1);
}
int main () {
	int T = 1;
	// cin >> T;
	while (T--) mian ();
	return 0;
}
```

---

## 作者：gyyyyx (赞：0)

感觉就是方格取数加强版的双倍经验啊。

考虑网络流，一条源汇点间的流表示一辆车的行动路线。

按照方格取数加强版的套路，对于所有非障碍点 $u$，我们将其拆点成 $u_1,u_2$，然后 $u_1\to u_2$ 连容量为 $1$，若 $u$ 中有石头，费用为 $1$，否则为 $0$。

然后再连 $u_1\to u_2$，容量为 $+\infty$，费用为 $0$。

这两条边分别表示第一次走到这个点和之后再走这个点的情况，也就是第一次可以拿到石头，之后无论走多少次都拿不到石头。

然后就是正常 $(x,y)\to(x+1,y)$ 和 $(x,y)\to(x,y+1)$ 的连边了，注意拆了点所以要区分出点和入点。

之后跑最大费用最大流即可。

输出方案的话每次找反图上的汇点到源点的一条路径即可。

代码：

```cpp
#include<bits/stdc++.h>
#define INF 0x3f3f3f3f
#define N 10000
#define M 50000
using namespace std;
int n,k,m,g[50][50],S,T;
struct Edge{
	int nxt,to,flw,cst,dir;
	Edge(int a=0,int b=0,int c=0,int d=0,int e=-1)
	:nxt(a),to(b),flw(c),cst(d),dir(e){}
} e[M];
int head[N],cnt(1);
inline void AddEdge(int x,int y,int f,int c,int d=-1){
	e[++cnt]=Edge(head[x],y,f,c,d);head[x]=cnt;
	e[++cnt]=Edge(head[y],x,0,-c);head[y]=cnt;
}
bool vis[N];
int dis[N],cur[N];
queue <int> q;
inline bool BFS(){
	memset(vis,0,sizeof(vis));
	memset(dis,0x3f,sizeof(dis));
	q.push(S);dis[S]=0;vis[S]=1;
	while(!q.empty()){
		int u(q.front());q.pop();
		cur[u]=head[u];vis[u]=0;
		for(int i(head[u]);i;i=e[i].nxt){
			int v(e[i].to);
			if(e[i].flw&&dis[v]>dis[u]+e[i].cst){
				dis[v]=dis[u]+e[i].cst;
				if(!vis[v]) q.push(v),vis[v]=1;
			}
		}
	}
	return dis[T]^dis[0];
}
int DFS(int u,int limit){
	if(u==T||!limit) return limit;
	vis[u]=1;int f(0);
	for(int i(cur[u]);i&&limit;i=e[i].nxt){
		cur[u]=i;int v(e[i].to);
		if(!vis[v]&&e[i].flw&&dis[v]==dis[u]+e[i].cst){
			int t(DFS(v,min(limit,e[i].flw)));
			limit-=t;f+=t;e[i].flw-=t;e[i^1].flw+=t;
		}
	}
	if(!f) dis[u]=0;
	return vis[u]=0,f;
}
inline void MCMF(){
	while(BFS())
		while(DFS(S,INF));
}
void Find(int u,int now){
	if(u==n*m) return;u+=n*m;
	for(int i(head[u]);i;i=e[i].nxt)
		if((~e[i].dir)&&e[i^1].flw){
			printf("%d %d\n",now,e[i].dir);
			Find(e[i].to,now);--e[i^1].flw;break;
		}
}
int main(){
	scanf("%d%d%d",&k,&m,&n);
	for(int i(1);i<=n;++i)
		for(int j(1);j<=m;++j)
			scanf("%d",&g[i][j]);
	AddEdge(S=(n*m<<1)+1,1,k,0);
	AddEdge(n*m<<1,T=S+1,k,0);
	for(int i(1);i<=n;++i)
		for(int j(1);j<=m;++j)
			if(g[i][j]^1){
				int id((i-1)*m+j);
				AddEdge(id,id+n*m,1,-(g[i][j]==2));
				AddEdge(id,id+n*m,INF,0);
			}
	for(int i(1);i<=n;++i)
		for(int j(1);j<=m;++j){
			int id((i-1)*m+j);
			if(i<n) AddEdge(id+n*m,id+m,INF,0,0);
			if(j<m) AddEdge(id+n*m,id+1,INF,0,1);
		}
	MCMF();
	for(int i(1);i<=k;++i) Find(1,i);
	return 0;
}
```

---

## 作者：bwartist (赞：0)

[可能更好的阅读体验](https://www.cnblogs.com/bwartist/p/18002150)

---

# part1 费用流建图

比较显然，把车的数量当成流量，把捡到的石头数量当成费用。然后跑最大费用最大流。

因为费用是针对点而不是边，所以要拆点，每个点分为入点和出点。

- 对于向下走，向右走建边：从**起点的出点**向**终点的入点**连边，容量为 $inf$，费用为 $0$。
- 对于每一个格子，如果当前格子是石头，那么我们想要的效果是，可以经过无数次，但是只有第一次能得到费用，所以我们把经过这个点的情况分为两种：第一次和第二次及之后。所以从入点到出点建两条边，一条边容量为 $1$，费用为 $1$，一条边容量为 $inf$，费用为 $0$。
- 对于每一个格子，如果当前点是障碍，不连接入点和出点，以达到不能经过的效果。
- 对于每一个格子，如果当前格子是空格，从入点到出点建一条容量为 $inf$，费用为 $0$。表示可以无数次经过，但是没有费用。

# part2 找方案

网络流找方案的做法是什么？在残留网络上，如果一条**正向边**对应的反向边的容量大于 $0$，那么**流经这条边的流量**就为**其反向边的容量**。

费用流也是一样的。

所以我们找到那些有流量的边，这些边就是机器人经过的边，建一个新图，在图上跑 DFS 即可。

# part3 一些细节

注意到题目中的要求是 “使到达传送器的探测车的数量最多，而且探测车采集到的岩石标本的数量最多”。

在费用流中，如果没有负权边，那么一定是流量越大，最大费用越大。相应的，在本题中，探测车的数量越多，采到的岩石标本一定单调不减，所以直接跑最大费用流是没有问题的。

--- 

注意原题中格子的标号方式与普遍的标号方式不同。

# Code

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=5005,MAXM=1e5+5;
struct E{int nxt,to,cap,w;}e[MAXM];
int head[MAXN];
int cnt=1;
void add(int u,int v,int cap,int w){
    e[++cnt]={head[u],v,cap,w};head[u]=cnt;
    e[++cnt]={head[v],u,0,-w};head[v]=cnt;
}
int dis[MAXN],flow[MAXN];
bool in[MAXN];
int las[MAXN];
const int INF=0x3f3f3f3f;
int n,S,T;
bool spfa(){
    queue<int> q;
    for(int i=1;i<=n;i++)   dis[i]=-INF,flow[i]=0;
    flow[S]=INF,dis[S]=0;
    q.push(S),in[S]=1;
    while(!q.empty()){
        int u=q.front();q.pop();in[u]=0;
        for(int i=head[u];i;i=e[i].nxt){
            int v=e[i].to;
            if(dis[v]<dis[u]+e[i].w&&e[i].cap){
                dis[v]=dis[u]+e[i].w;
                flow[v]=min(flow[u],e[i].cap);
                las[v]=i;
                if(!in[v])  q.push(v),in[v]=1;
            }
        }
    } 
    return dis[T]>-INF;
}
void EK(int &ans,int &cost){
    ans=cost=0;
    while(spfa()){
        int dlt=flow[T];
        ans+=dlt,cost+=dis[T]*dlt;
        int u=T;
        while(u!=S){
            int i=las[u];
            e[i].cap-=dlt,e[i^1].cap+=dlt;
            u=e[i^1].to;
        }
    }
}
int N,M,K;
int id(int x,int y,int z){return (x-1)*M+y+z*N*M;}
int dir[4][2]={{0,1},{1,0}};
int mp[55][55];
#define pii pair<int,int>
#define fi first
#define se second
vector<pii> G[MAXN];
int Print;
void dfs(int u){
    int y=(u%M==0?M:u%M);
    for(pii &t:G[u]){
        int v=t.fi;
        if(!t.se)   continue;
        int ty=(v%M==0?M:v%M);
        if(y==ty)   printf("%d 0\n",Print);
        else printf("%d 1\n",Print);
        dfs(v);
        t.se--;
        break;
    }
}
int main(){
    #ifndef ONLINE_JUDGE
        freopen(".in","r",stdin);
        freopen(".out","w",stdout);
    #endif
    scanf("%d%d%d",&K,&M,&N);
    n=N*M*2+2;S=n-1,T=n;
    for(int i=1;i<=N;i++){
        for(int j=1;j<=M;j++){
            int v;scanf("%d",&v);
            if(v==1)    continue;
            mp[i][j]=v;
            
            add(id(i,j,0),id(i,j,1),INF,0);
            if(v==2)    add(id(i,j,0),id(i,j,1),1,1);
            for(int k=0;k<=1;k++){
                int di=i+dir[k][0],dj=j+dir[k][1];
                if(di<1||dj<1||di>N||dj>M)  continue;
                add(id(i,j,1),id(di,dj,0),INF,0);
            }
        }
    }
    add(S,id(1,1,0),K,0);
    add(id(N,M,1),T,K,0);
    
    int ans,cost;
    EK(ans,cost);
    for(int i=2;i<=cnt;i+=2){
        int u=e[i^1].to,v=e[i].to;
        if(v>=1&&v<=N*M&&u>=N*M+1&&u<=N*M*2){//从出点到入点的边
            if(e[i^1].cap)    G[u-M*N].push_back({v,e[i^1].cap});
        }
    }
    for(Print=1;Print<=ans;Print++){
        dfs(1);
    }
    return 0;
}
```

---

## 作者：Basori_Tiara (赞：0)

不难，但是挺恶心人的。

考虑这个题比较板，看到他的限制条件：要求最大化机器人进传送点的数量并最大化收取石头数量，很容易就能想到费用流，而石头只能取一次的设计很容易就能破解。

首先把格子拆点，然后如果一个地方有石头，入点向出点连一条 $(1,-1)$ 的边表示这块石头只能由一个人来取一次，对于没障碍的锁有点，入点向出点都再连一条 $(\inf,0)$ 的边表示这个点可以随便走而不关乎代价。

然后相通的格子之间，出点向入点连边，跑一下费用流就好了。

但是这个题还要求输出方案，所以我们对于每个 $(i,j)$ 都记录一个新的编号 $id_{(i,j)}=(i-1)\times m+j$，然后在网络流上把所有非 $0$ 反向边拿出来建一张新图，然后乱搜增广路就行了，因为这个正着是增广路所以反着来无论怎么走哪怕只有还有一条边有一点流量都一定还会有增广路的，否则违反前提条件。

找到增广路后方向可以用编号判断，优先级是列比行高。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int k,n,m;
int mp[50][50];
int dx[2]={1,0};
int dy[2]={0,1};
class LTDZ{
	public:
	int dep[1000005];
	int E[1000005];
	int nxt[1000005];
	int head[1000005];
	int flow[1000005];
	bool in[1000005];
	int pos[1000005];
	int cost[1000005];
	int cnt=1;
	int s,t,n;
	void addedge(int u,int v,int fl,int co){
		cnt++;
		E[cnt]=v;
		flow[cnt]=fl;
		cost[cnt]=co;
		nxt[cnt]=head[u];
		head[u]=cnt;
		return;
	}
	void Add(int u,int v,int fl,int co){
		addedge(u,v,fl,co);
		addedge(v,u,0,-co);
		return;
	}
	bool SPFA(){
		queue<int> q;
		q.push(s);
		for(int i=1;i<=n;i++){
			dep[i]=1e16;
		}
		dep[s]=0;
		in[s]=true;
		while(!q.empty()){
			int t=q.front();
			q.pop();
			in[t]=false;
			for(int i=head[t];i;i=nxt[i]){
				int v=E[i];
				int fl=flow[i];
				int co=cost[i];
				if(fl&&dep[t]+co<dep[v]){
					dep[v]=dep[t]+co;
					if(!in[v]){
						q.push(v);
						in[v]=true;
					}
				}
			}
		}
		return dep[t]<10000000000000000;
	}
	bool vis[1000005];
	int ansflow,anscost;
	int dfs(int cur,int mini,int Pre){
		vis[cur]=true;
		if(cur==t){
			ansflow+=mini;
			return mini;
		}
		int fl=0;
		for(int i=pos[cur];i;i=nxt[i]){
			pos[cur]=i;
			if(i==Pre)continue;
			int v=E[i];
			int F=flow[i];
			int C=cost[i];
			if(F&&dep[cur]+C==dep[v]&&(v==t||!vis[v])){
				int tmp=dfs(v,min(mini-fl,F),i^1);
				if(tmp){
					flow[i]-=tmp;
					flow[i^1]+=tmp;
					fl+=tmp;
					anscost+=tmp*C;
					if(fl==mini){
						break;
					}
				}
			}
		}
		vis[cur]=false;
		return fl;
	}
	void dinic(){
		while(SPFA()){
			do{
				for(int i=1;i<=n;i++){
					vis[i]=false;
					pos[i]=head[i];
				}
				dfs(s,1e16,0);
			}while(vis[t]);
		}
		return;
	}
}G;
vector<int> need[50][50];
struct node{
   int v,flow;
};
vector<node>ljb[100005];
void dfs(int cur,int id){
   for(int i=0;i<ljb[cur].size();i++){
      int v=ljb[cur][i].v;
      int flow=ljb[cur][i].flow;
      if(!flow)continue;
      ljb[cur][i].flow--;
      dfs(v,id);
      if(v==cur-1){
         printf("%lld %lld\n",id,1ll);
      }
      else{
         printf("%lld %lld\n",id,0ll);
      }
      return;
   }
   return;
}
signed main(){
   scanf("%lld",&k);
   scanf("%lld%lld",&m,&n);
   for(int i=1;i<=n;i++){
      for(int j=1;j<=m;j++){
         scanf("%lld",&mp[i][j]);
      }
   }
   for(int i=1;i<=n;i++){
      for(int j=1;j<=m;j++){
         int now=(i-1)*m+j;
         if(mp[i][j]==2){
            G.Add(now,now+n*m,1,-1);
         }
         if(mp[i][j]^1)G.Add(now,now+n*m,1e9,0);
      }
   }
   for(int i=1;i<=n;i++){
      for(int j=1;j<=m;j++){
         if(mp[i][j]==1)continue;
         for(int k=0;k<2;k++){
            int xx=i+dx[k];
            int yy=j+dy[k];
            if(xx>n||yy>m)continue;
            if(mp[xx][yy]==1){
               continue;
            }
            int now=(i-1)*m+j;
            int nxt=(xx-1)*m+yy;
            G.Add(now+n*m,nxt,1e9,0);
         }
      }
   }
   G.s=2*n*m+1;
   G.t=2*n*m+2;
   G.n=2*n*m+2;
   G.Add(G.s,1,k,0);
   G.Add(2*n*m,G.t,k,0);
   G.dinic();
   for(int i=1;i<=n;i++){
      for(int j=1;j<=m;j++){
         int now=(i-1)*m+j;
         for(int j=G.head[now];j;j=G.nxt[j]){
            int v=G.E[j];
            if(v<=n*m||v>2*n*m)continue;
            if(v==now+n*m)continue;
            if(G.flow[j]==0)continue;
            ljb[now].push_back(node{v-n*m,G.flow[j]});
         }
      }
   }
   int ans=G.ansflow;
   int pos=0;
   while(ans--){
      dfs(n*m,++pos);
   }
   return 0;
}
```

---

## 作者：happybob (赞：0)

考虑拆点，每个点对 $(x,y)$ 拆成入点 $u$ 和出点 $v$。连 $x \xrightarrow{cap=+\infty,cost=0} y$。如果这个地方有石头，再连一条 $x \xrightarrow{cap=1,cost=1} y$，表示石头只能被取一次。对于两个点，从出点连向入点，容量为 $+\infty$，费用为 $0$。跑最大费用最大流。

最后输出方案时，从起点 $n$ 次搜索，每次从残留网络上反向边容量 $>0$ 的地方走并更新容量即可。

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <climits>
#include <cstring>
#include <string>
#include <queue>
using namespace std;

#define int long long

const int N = 5e5 + 5, M = 40;

int n, p, q, ec[M][M];
int e[N], h[N], c[N], cs[N], ne[N], idx, S = 0, T;
int ll[M][M][2];
int nowp = 0;

int dx[] = { 1, 0 };
int dy[] = { 0, 1 };

int dis[N], cur[N];
bool isin[N];

inline int get_in(int x, int y)
{
	return (x - 1) * q + y;
}

inline int get_out(int x, int y)
{
	return get_in(x, y) + p * q;
}

inline void add(int u, int v, int w, int g)
{
	g = -g;
	e[idx] = v, c[idx] = w, cs[idx] = g, ne[idx] = h[u], h[u] = idx++;
	e[idx] = u, c[idx] = 0, cs[idx] = -g, ne[idx] = h[v], h[v] = idx++;
}

inline bool spfa()
{
	for (int i = 0; i <= T; i++) dis[i] = INT_MAX, cur[i] = -1;
	queue<int> q;
	q.push(S);
	dis[S] = 0, cur[S] = h[S];
	while (q.size())
	{
		int u = q.front();
		q.pop();
		isin[u] = 0;
		for (int i = h[u]; ~i; i = ne[i])
		{
			int j = e[i];
			if (dis[j] > dis[u] + cs[i] && c[i] > 0)
			{
				cur[j] = h[j];
				dis[j] = dis[u] + cs[i];
				if (!isin[j])
				{
					q.push(j);
					isin[j] = 1;
				}
			}
		}
	}
	return (dis[T] != INT_MAX);
}

inline int dfs(int u, int lim)
{
	if (u == T) return lim;
	isin[u] = 1;
	int sum = 0;
	for (int i = cur[u]; ~i && sum < lim; i = ne[i])
	{
		cur[u] = i;
		int j = e[i];
		if (dis[j] == dis[u] + cs[i] && c[i] > 0 && !isin[j])
		{
			int p = dfs(j, min(lim - sum, c[i]));
			sum += p;
			c[i] -= p;
			c[i ^ 1] += p;
		}
	}
	isin[u] = 0;
	return sum;
}

int dinic()
{
	int res = 0, p;
	while (spfa())
	{
		while (p = dfs(S, INT_MAX)) res += p;
	}
	return res;
}

void dfss(int x, int y)
{
	if (x == p && y == q)
	{
		return;
	}
	int g = get_out(x, y);
	if (ll[x][y][0] != -1 && c[ll[x][y][0] ^ 1] > 0)
	{
		printf("%d %d\n", nowp, 0);
		c[ll[x][y][0] ^ 1]--;
		dfss(x + dx[0], y + dy[0]);
		return;
	}
	if (ll[x][y][1] != -1 && c[ll[x][y][1] ^ 1] > 0)
	{
		printf("%d %d\n", nowp, 1);
		c[ll[x][y][1] ^ 1]--;
		dfss(x + dx[1], y + dy[1]);
		return;
	}
}

signed main()
{
	memset(h, -1, sizeof h);
	memset(ll, -1, sizeof ll);
	S = 10000, T = 10001;
	scanf("%lld%lld%lld", &n, &q, &p);
	add(S, get_in(1, 1), n, 0);
	add(get_out(p, q), T, n, 0);
	for (int i = 1; i <= p; i++)
	{
		for (int j = 1; j <= q; j++) scanf("%lld", &ec[i][j]);
	}
	if (ec[1][1] == 1 || ec[p][q] == 1) return 0;
	for (int i = 1; i <= p; i++)
	{
		for (int j = 1; j <= q; j++)
		{
			if (ec[i][j] == 1) continue;
			add(get_in(i, j), get_out(i, j), INT_MAX, 0);
			if (ec[i][j] == 2) add(get_in(i, j), get_out(i, j), 1, 1);
			for (int k = 0; k < 2; k++)
			{
				int nx = i + dx[k], ny = j + dy[k];
				if (nx >= 1 && nx <= p && ny >= 1 && ny <= q && ec[nx][ny] != 1)
				{
					add(get_out(i, j), get_in(nx, ny), INT_MAX, 0);
					ll[i][j][k] = h[get_out(i, j)];
				}
			}
		}
	}
	int hh = dinic();
	for (int i = 1; i <= n; i++)
	{
		nowp = i;
		dfss(1, 1);
	}
	return 0;
}
```


---

## 作者：0xyz (赞：0)

### 一、题意简述

有一个 $p\times q$ 的地图，有 $n$ 个机器人，每个机器人要从左上角的 $(1,1)$ 到达右下角的 $(p,q)$。

#### 1. 对于机器人的限制：

1. 一共 $n$ 个机器人。

2. 机器人只能往下走或者往右走。

#### 2. 对于格子的限制：

1. 每个标着 $1$ 的格子不能走。

2. 每个标着 $2$ 的格子只能对答案造成 $1$ 的贡献。

3. 每个格子可以被多个机器人走过。

求答案最大时，$n$ 个机器人的可能路线。

### 二、分析

#### 1. 建模

首先，这是一道网络流的题目。考虑使用费用流求解。由于答案要最大，所以跑最大费用最大流。由于题目的限制跟机器人走的次数有关，所以将机器人经过的次数，因为每个机器人走不了回头路，所以也就是经过的机器人的个数，作为流量。

然后依据题目限制建图。首先，对于格子的限制，每个标着 $2$ 的格子，无论被经过多少次，都只能对答案造成 $1$ 的贡献，但是所有不是障碍的格子都可以被机器人走过多次。

题目对于每个格子造成贡献的次数有限制，但是网络流中没有“点权”的概念。于是考虑拆点，将每个点拆成入点和出点。

首先每个不是障碍的格子都可以走无限次，但是走的时候不会造成贡献。于是将对应入点和出点之间连一条流量为 $\infty$，费用为 $0$ 的边。由于标了 $2$ 的格子也可以走无限次，所以也要连。

然后我们看到标了 $2$ 的格子可以造成 $1$ 次 $1$ 的贡献，所以再从对应入点向出点连一条流量为 $1$，费用为 $1$ 的边。

障碍格子由于不能走，对应的入点和出点之间不连边。

接下来就是对于机器人的移动来连边了。因为机器人可以向下和向右移动，不造成贡献，所以每个格子的出点向右边和下面格子的入点连一条流量为 $\infty$，费用为 $0$ 的边。

最后就是对于机器人数量的限制。由于只有 $n$ 个机器人，所以我们要手动将最大流限制成 $n$。于是建立一个起点，让它向 $(1,1)$ 的入点连一条流量为 $n$，费用为 $0$ 的边。然后所有流的终点就是 $(p,q)$ 的出点。

#### 2. 最大费用最大流

##### SSP

用 spfa 跑若干次最大费用最大流，直到没有残余流量。由于最大流为 $n$，所以总的时间复杂度是 $O(n\times p^2\times q^2)$。

##### Primal Dual

使用 Primal Dual 算法，时间复杂度 $O(p^2\times q^2+n\times p\times q\log(p\times q))$，比时间复杂度 $O(n\times p^2\times q^2)$ 的 SSP 算法快。

由于有反向边，所以不能直接跑 dijkatra。但是注意到要跑很多遍最短路，所以可以用类似 Jhonson 全源最短路的方法优化，求出势后权非负且最短路不变。

这个算法就是先跑一遍 spfa，预处理出所有点的势，然后再跑多次 dijkstra 求出最长路。每跑一次更新每条边的残余流量。

#### 3. 输出

我们发现机器人选择了一条路的表现就是它的流量减少，它的反向边流量增加。所以我们可以进行 dfs，每一次遍历到一条边就判断它的流量是不是少了，如果少了就将其加一，然后经过这条边。

注意一条边可能未必在原图里，所以要将新加的所有边的方向标为 $2$，原有的边按照方向标为 $0$ 和 $1$，在 dfs 时输出即可。

### 三、代码

#### 1.SSP

最慢的点 4ms，一共 20ms。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int _=20010,inf=1e5;
int C=1,nxt[_],h[_],t[_],v[_],d[_],c[_],st,ed,id=0,Q;
int in[_],p[_],V[_],di[_],n,P,f[_];
inline void add(int x,int y,int z,int w,int D){
	nxt[++C]=h[x];h[x]=C;t[C]=y;v[C]=V[C]=z;c[C]=w;di[C]=D;
	nxt[++C]=h[y];h[y]=C;t[C]=x;v[C]=V[C]=0;c[C]=-w;
}
inline bool spfa(){
	for(int i=0;i<=ed;i++)d[i]=-inf,f[i]=inf,in[i]=0;
	queue<int>q;q.push(st);d[st]=0;in[st]=1;
	while(!q.empty()){
		int x=q.front();q.pop();in[x]=0;
		for(int i=h[x];i;i=nxt[i])
			if(v[i]&&d[t[i]]<d[x]+c[i]){
				d[t[i]]=d[x]+c[i];p[t[i]]=i;f[t[i]]=min(f[x],v[i]);
				if(!in[t[i]])in[t[i]]=1,q.push(t[i]);
			}
	}
	return d[ed]!=-inf;
}
void dfs(int k,int x){
	if(x==ed)return;
	for(int i=h[x];i;i=nxt[i])
		if(v[i]<V[i]){
			v[i]++;
			if(di[i]<2)printf("%d %d\n",k,di[i]);
			dfs(k,t[i]);
			return;
		}
}
int main(){
	ios::sync_with_stdio(0);
	cin>>n>>Q>>P;st=0;ed=P*Q*2;
	add(0,1,n,0,2);
	for(int i=1,x;i<=P;i++)
		for(int j=1;j<=Q;j++){
			cin>>x;id++;
			if(x!=1)add(id,id+P*Q,inf,0,2);
			if(x==2)add(id,id+P*Q,1,1,2);
			if(i<P)add(id+P*Q,id+Q,inf,0,0);
			if(j<Q)add(id+P*Q,id+1,inf,0,1);
		}
	while(spfa())
		for(int x=ed;x!=st;x=t[p[x]^1])v[p[x]]-=f[ed],v[p[x]^1]+=f[ed];
	for(int i=1;i<=n;i++)dfs(i,1);
	return 0;
}
```

#### 2.Primal Dual

最慢的点 4ms，一共 19ms。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int _=10010,inf=1e5;
int C=1,nxt[_],h[_],t[_],v[_],d[_],c[_],st,ed,id=0,Q;
int e[_],in[_],p[_],V[_],di[_],n,P;
inline void add(int x,int y,int z,int w,int D){
	nxt[++C]=h[x];h[x]=C;t[C]=y;v[C]=V[C]=z;c[C]=w;di[C]=D;
	nxt[++C]=h[y];h[y]=C;t[C]=x;v[C]=V[C]=0;c[C]=-w;
}
inline bool dij(){
	priority_queue<pair<int,int> >q;
	for(int i=0;i<=ed;i++)d[i]=-inf,in[i]=0;
	q.push({d[st]=0,st});
	while(!q.empty()){
		int x=q.top().second;q.pop();
		if(in[x])continue;in[x]=1;
		for(int i=h[x],j;i;i=nxt[i])
			if(v[i]&&d[t[i]]<d[x]+(j=c[i]+e[x]-e[t[i]])){
				p[t[i]]=i;
				q.push({d[t[i]]=d[x]+j,t[i]});
			} 
	}
	return d[ed]!=-inf;
}
void dfs(int k,int x){
	if(x==ed)return;
	for(int i=h[x];i;i=nxt[i])
		if(v[i]<V[i]){
			v[i]++;
			if(di[i]<2)printf("%d %d\n",k,di[i]);
			dfs(k,t[i]);
			return;
		}
}
int main(){
	ios::sync_with_stdio(0);
	cin>>n>>Q>>P;st=0;ed=P*Q*2;
	add(0,1,n,0,2);
	for(int i=1,x;i<=P;i++)
		for(int j=1;j<=Q;j++){
			cin>>x;id++;
			if(x!=1)add(id,id+P*Q,inf,0,2);
			if(x==2)add(id,id+P*Q,1,1,2);
			if(i<P)add(id+P*Q,id+Q,inf,0,0);
			if(j<Q)add(id+P*Q,id+1,inf,0,1);
		}
	for(int i=0;i<=ed;i++)e[i]=-inf;
	queue<int>q;q.push(st);e[st]=0;in[st]=1;
	while(!q.empty()){
		int x=q.front();q.pop();in[x]=0;
		for(int i=h[x];i;i=nxt[i])
			if(v[i]&&e[t[i]]<e[x]+c[i]){
				e[t[i]]=e[x]+c[i];
				if(!in[t[i]])in[t[i]]=1,q.push(t[i]);
			}
	}
	while(dij()){
		int fl=inf;
		for(int i=0;i<=ed;i++)e[i]+=d[i];
		for(int x=ed;x!=st;x=t[p[x]^1])fl=min(fl,v[p[x]]);
		for(int x=ed;x!=st;x=t[p[x]^1])v[p[x]]-=fl,v[p[x]^1]+=fl;
	}
	for(int i=1;i<=n;i++)dfs(i,1);
	return 0;
}
```

### 四、花絮

我亲测这题有时不用连反向边也可以过……不知道为什么。

[AC 记录](https://www.luogu.com.cn/record/109788202)

---

## 作者：Zekrom (赞：0)

###  我的路径输出怎么跟样例输出不一样？？？？    
## 没关系，路径不止一条    
常见的网络流输出方案模板：    



```cpp
for(int i=1;i<=n;i++){
    for(int j=head[i];j;j=edge[j].next){
        if(!c)      
            //输出方案
    }
}
```
拆点建边后，对于一边的边流量为inf，而我们要的是可以走到石头的边，没关系，这样做就行了   
```cpp
for(int i=1;i<=n;i++){
    for(int j=head[i];j;j=edge[j].next){
        if(edge[i^1].c)
            //输出方案
    }
}
```    
反向边有流量，图中一定走过该条路   
然后dfs输出即可   
对于其他的实现技巧，见其他题解即可   
本题解主要讲讲路径的实现方法   
上代码   
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<queue>
#define N 40
#define inf 0x3f3f3f3f
using namespace std;
int head[N*N*2],tot=1,d[N*N*2],pre[N*N*2],flow[N*N*2],ans,k,s,t,n,m,a[N][N];
bool vis[N*N*2]; 
struct Edge{
	int v,next,val,c;
}edge[N*N*2*4];
inline int read(){
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-f;ch=getchar();
	}while(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+ch-'0';ch=getchar();
	}return  x*f;
}
inline int num(int x,int y,int z){return ((x-1)*m+y)*2+z;}
inline void add(int x,int y,int z,int k){
	edge[++tot].v=y;edge[tot].val=k;edge[tot].c=z;edge[tot].next=head[x];head[x]=tot;
	edge[++tot].v=x;edge[tot].val=-k;edge[tot].c=0;edge[tot].next=head[y];head[y]=tot;
}
bool spfa(){
	queue<int>q;q.push(s);memset(vis,0,sizeof(vis));memset(d,0xcf,sizeof(d));d[s]=0;flow[s]=inf;
	while(q.size()){
		int u=q.front();q.pop();vis[u]=0;
		for(int i=head[u];i;i=edge[i].next){
			int v=edge[i].v,c=edge[i].c,z=edge[i].val;
			if(!c)continue;
			if(d[v]<d[u]+z){
				d[v]=d[u]+z;
				pre[v]=i;
				flow[v]=min(flow[u],c);
				if(!vis[v])vis[v]=1,q.push(v);
			}
		}
	}return d[t]!=0xcfcfcfcf;
}
void update(){
	int x=t;
	while(x!=s){
		int i=pre[x];
		edge[i].c-=flow[t];edge[i^1].c+=flow[t];x=edge[i^1].v;
	}
	ans+=d[t]*flow[t];
}
void dfs(int val,int x){
	if(x==num(n,m,2))return ;
	for(int i=head[x];i;i=edge[i].next){
		int v=edge[i].v,c=edge[i].c;
		if(edge[i^1].c&&v>x){   //走过该条边 
			edge[i^1].c++;
			printf("%d %d\n",val,v-x==1);
			return dfs(val,v+1); 
		}
	}
}
int main(){
	k=read();
	m=read();n=read();s=0;t=n*m*2+5;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++){
			a[i][j]=read();
			if(a[i][j]==1)continue;
			if(a[i][j]==2)add(num(i,j,1),num(i,j,2),1,1),a[i][j]=0;
			add(num(i,j,1),num(i,j,2),inf,0);
			if(i>1)add(num(i-1,j,2),num(i,j,1),inf,0);
			if(j>1)add(num(i,j-1,2),num(i,j,1),inf,0); 
		}
	add(s,num(1,1,1),k,0);add(num(n,m,2),t,k,0);
	while(spfa())update();
	for(int i=1;i<=k;i++){
		dfs(i,num(1,1,2));
	}
}
```




---


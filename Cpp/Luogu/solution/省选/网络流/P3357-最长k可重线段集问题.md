# 最长k可重线段集问题

## 题目描述

给定平面 $x-O-y$ 上 $n$ 个开线段组成的集合 $I$，和一个正整数 $k$ 。试设计一个算法，从开线段集合 $I$ 中选取出开线段集合 $S\subseteq I$ ,使得在 $x$ 轴上的任何一点 $p$，$S$ 中与直线 $x=p$ 相交的开线段个数不超过 $k$，且$\sum\limits_{z\in S}|z|$达到最大。这样的集合 $S$ 称为开线段集合 $I$ 的最长  $k$ 可重线段集。$\sum\limits_{z\in S}|z|$ 称为最长  $k$ 可重线段集的长度。

对于任何开线段 $z$，设其断点坐标为 $(x_0,y_0)$ 和 $(x_1,y_1)$，则开线段 $z$ 的长度 $|z|$ 定义为：
$$|z|=\lfloor\sqrt{(x_1-x_0)^2+(y_1-y_0)^2}\rfloor$$

对于给定的开线段集合 $I$ 和正整数 $k$，计算开线段集合 $I$ 的最长 $k$ 可重线段集的长度。


## 说明/提示

$1\leq n\leq 500$，$1 \leq k \leq 13$，坐标值在 `int` 范围内。


## 样例 #1

### 输入

```
4 2
1 2 7 3
6 5 8 3
7 8 10 5
9 6 13 9 ```

### 输出

```
17```

# 题解

## 作者：皎月半洒花 (赞：36)


感觉这题压根没有正常的题解啊……

喷的原因可以去看我的上一篇题解:[P3358Sol 戳我](https://www.luogu.com.cn/blog/pks-LOVING/solution-p3358)
 
由于这题需要用到 P3358 的前置芝士，所以大家如有需要可以去做完 P3358 这题再来。

_____

> 给定平面 $\text{x-o-y}$上 $n$ 个开线段组成的集合 $\text{I}$，和一个正整数 $\rm k$ 从开线段集合 $\text{I}$ 中选取出开线段集合 $\text{S}\in \text{I}$, 使得在 x 轴上的任何一点 $\text{p}$ ， $\text{S}$ 中与直线 $\text{x}=\text{p}$ 相交的开线段个数不超过 $\text{k}$ ，且 $\sum_{\text{z} \in \text{S}}|z|$ 达到最大。这样的集合 $\text{S}$ 称为开线段集合 $\text{I}$ 的最长 $\text{k}$ 可重线段集的长度。
>
> 对于任何开线段 $\text{z}$，设其端点坐标为 $( x_0 , y_0 )$ 和 $( x_1 , y_1 )$，则开线段 $\text{z}$ 的长度 $|\text{z}|$ 定义为： $|z| = \lfloor \sqrt{ ( x_1 - x_0 ) ^ 2 + ( y_1 - y_0 )^2 } \rfloor$。对于给定的开线段集合 $\text{I}$ 和正整数 $\text{k}$ ，计算开线段集合 $\text{I}$ 的最长 $\text{k}$ 可重线段集的长度。
>
> $1\leq n\leq500,$ $1 \leq k \leq 13$.

发现和「区间集」那题没啥区别，只用关心 $x$ 轴，换一下长度的求法…好像有点不对？因为如果存在两条线段均垂直于 $x$ 轴，且两条线的左右端点分别都是 $x_i$ ，这样的话，建出图来这俩线段是串在一起不交的，但是本质上应该交。

于是自然想到，要换种表示方法在 $x$ 轴上表示一个线段。那么如果是在数轴上，比较简单的方式就是扩域。每个线段 $i$ 的左右端点 $(l_i,r_i)$ 变换成 $(2\times l_i,2\times r_i)$——听上去很不错，这样的话就相当于每个下标多了一个空间。那么对于一个左右端点相同的区间 $(x,x)$ ，就可以连边成 $(2\cdot x,2\cdot x + 1)$。这样的话，原本左右端点不用的区间也要改——由于那些相同的区间右端点加了 $1$，所以如果存在这样两个线段 $(p,p)$ 、 $(p,q)$ ，那么原本不交的两个区间，在扩域之后变成了相交的 $(2p,2p+1)$、$(2p,2q)$ 。

处理方式很简单，对于一个 $p\not=q$ 的区间 $(p,q)$，连边 $(2p+1,2q)$ 即可。思考这么做为啥是对的。对于原本存在的两个均不垂直 $x$ 轴的线段，他们如果相交，那么交的那一端，$r_1-l_2\geq 1$ ；如果不交，那么有 $l_2-r_1\geq 1$ 。扩域之后就变成了 $\geq 2$ 。所以如果只是左端点增加 $1$ ，根本不影响判定。

```cpp
int len[N] ;
pint base[N] ;
int _n, _k, tot ;
map <int, int> Id, buc ;
map <int, int> :: iterator t ;

int calc(int a, int b, int c, int d){
    return (int)sqrt((ll)(a - c) * (a - c) + (ll)(b - d) * (b - d)) ;
}
int main(){
    int a, b, c, d ;
    cin >> _n >> _k ; cnt = -1 ;
    memset(head, -1, sizeof(head)) ;
    for (int i = 1 ; i <= _n ; ++ i){
        cin >> a >> b >> c >> d ;
        len[i] = calc(a, b, c, d) ;
        base[i].ft = a << 1 ;
        base[i].sc = c << 1 ;
        if (a == c)
            ++ base[i].sc ;
        else ++ base[i].ft ;
    }
    for (int i = 1 ; i <= _n ; ++ i){
        if (!Id.count(base[i].ft)) buc[base[i].ft] ++ ;
        if (!Id.count(base[i].sc)) buc[base[i].sc] ++ ;
    }
    add(0, 1, _k, 0) ; add(1, 0, 0, 0) ;
    for (t = buc.begin() ; t != buc.end() ; ++ t)
        Id[t -> ft] = ++ tot ; _s = 0 ; _t = tot + 1 ;
    for (int i = 1 ; i <= tot ; ++ i)
        add(i, i + 1, I, 0), add(i + 1, i, 0, 0) ;
    for (int i = 1 ; i <= _n ; ++ i){
        //cout << Id[base[i].ft] << " " << Id[base[i].sc] << endl ;
        add(Id[base[i].ft], Id[base[i].sc], 1, -len[i]) ;
        add(Id[base[i].sc], Id[base[i].ft], 0, len[i]) ;
    }
    n = _t + 1 ; ek() ;
    cout << -ans << endl ;
}
```



---

## 作者：qzhwlzy (赞：10)

## [传送门](https://www.luogu.com.cn/problem/P3357)
### 题目大意
给定平面 $x-O-y$ 内 $n$ 个开线段（类比开区间，应该是不取两端点的线段）和正整数 $k$ ，要求从这些线段中选择若干个，使得任意平行 $y$ 轴的直线 $x=p$ 都不和大于 $k$ 个线段相交，求选出线段的长度和的最大值（此处端点为 $(x_1,y_1)$ 和 $(x_2,y_2)$ 的线段长度定义为 $\left\lfloor{\sqrt{(x_1-x_2)^2+(y_1-y_2)^2}}\right\rfloor$ ）（如图 $11$ ，答案为 $17$，$4$ 个线段都选即可）。

![](https://cdn.luogu.com.cn/upload/image_hosting/zguscq9w.png)
### 思路
想到之前的[P3358](https://www.luogu.com.cn/problem/P3358)，我们可以发现，这一题与那题的区别就是那题在数轴上而这题在平面内，于是我们考虑：能不能将这些线段变成数轴上的区间呢？（这样就可以直接用 P3358 的代码了）发现可以将这些线段投影到$x$轴上，这样就完成了我们将线段转换到区间的愿望（如下图 $11.2$ ）。此时将代码改一下上交，就会获得 $9$ 分的好成绩。

![](https://cdn.luogu.com.cn/upload/image_hosting/mifrg8st.png)

为什么呢？画图分析，我们发现若线段像图 11.3 一样不平行 $y$ 轴（即 $x_1\not= x_2$ ）时我们的代码正确，但是一旦出现如图 11.4 一样的、平行于 $y$ 轴的线段（即 $x_1 = x_2$ ），则将其投影到 $x$ 轴上后，先不说交不交的问题，甚至这条“线段”都不存在（因为是开区间所以不取两端点的值）。

于是我们想到可以**拆点**（扩域），把区间 $(x_i,x_j)$ 变成 $(2\times x_i,2\times x_j)$ （后文省略乘号），这样就可以空出许多奇数的点，如 $1,3,5$ 等.此时若遇到平行$y$轴的线段就可以把区间变成 $(2x_i,2x_i+1)$ 。但此时又出现了一个新的问题，由于是开线段变成的开区间，那么原来区间 $(x_i,x_i)$ 和 $(x_i,x_j)$ （假定 $x_j>x_i$ ）不交，但是被我们改过后区间变成了 $(2x_i,2x_i+1)$ 和 $(2x_i,2x_j)$ ，之间是相交的，会导致答案错误，所以，我们应该把不平行 $y$ 轴的线段变成的区间 $(x_i,x_j)$ 也改变，变成 $(2x_i+1,2x_j)$ ，这样就不会出现上述的区间不交变成相交的问题了。

但是这样会不会让原来相交的区间变成不交呢？可以证明不会：（如图 11.3 ）设两区间分别为 $(x_1,x_2)$ 和 $(x_3,x_4)$ ，那么改变之后变成了 $(2x_1+1,2x_2)$ 和 $(2x_3+1,2x_4)$ ：若原来两区间相交，则 $x_3>x_2$ ，更具体地， $x_3-x_2\ge 1$ （应该是 $>0$ 的，在本题中由于输入的都是整数，故 $\ge1$ ），所以改变之后的 $2x_3+1-2x_2\ge 3> 1$ ，仍然相交；若原来两区间不交，则同理 $x_2-x_3\ge 1$ ，改变后的 $2x_2-(2x_3+1)\ge 1$ ，仍然不交。
### 细节
- 距离要向下取整，可以用 cmath 库的 floor 函数。
- ~~不开 long long 见祖宗~~（ $WA\ \  On\ \  Test\ 4$ ）

### 代码
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<queue>
#include<cmath>
#include<algorithm>
#define maxn 5005
#define maxm 50005
#define ll long long
#define inf 0x3fffffff
using namespace std;
ll n,k,s,t;
ll xx1[maxn],yy1[maxn],xx2[maxn],yy2[maxn],diss[maxn];
ll num[maxn],cnt=0;
ll head[maxn],tt=1;
struct node{
	ll to,dis,cost,nex;
}a[maxm*2];
void add(ll from,ll to,ll dis,ll cost){
	a[++tt].to=to;a[tt].dis=dis;a[tt].cost=cost;a[tt].nex=head[from];head[from]=tt;
	a[++tt].to=from;a[tt].dis=0;a[tt].cost=-cost;a[tt].nex=head[to];head[to]=tt;
}
bool vis[maxn];
ll costs[maxn];
bool spfa(){
	memset(vis,0,sizeof(vis));
	memset(costs,0x3f,sizeof(costs));
	queue<int> q;
	vis[s]=1;
	q.push(s);
	costs[s]=0;
	while(!q.empty()){
		ll top=q.front();
		q.pop();
		vis[top]=0;
		for(ll i=head[top];i;i=a[i].nex){
			if(costs[top]+a[i].cost<costs[a[i].to]&&a[i].dis){
				costs[a[i].to]=costs[top]+a[i].cost;
				if(!vis[a[i].to]){
					vis[a[i].to]=1;
					q.push(a[i].to);
				}
			}
		}
	}
	if(costs[t]==costs[0]){
		return 0;
	}
	return 1;
}
ll ans=0,anscost=0;
ll dfs(ll x,ll minn){
	if(x==t){
		vis[t]=1;
		ans+=minn;
		return minn;
	}
	int use=0;
	vis[x]=1;
	for(ll i=head[x];i;i=a[i].nex){
		if((!vis[a[i].to]||a[i].to==t)&&costs[a[i].to]==costs[x]+a[i].cost&&a[i].dis){
			ll search=dfs(a[i].to,min(minn-use,a[i].dis));
			if(search>0){
				use+=search;
				anscost+=(a[i].cost*search);
				a[i].dis-=search;
				a[i^1].dis+=search;
				if(use==minn){
					break;
				}
			}
		}
	}
	return use;
}
void dinic(){
	while(spfa()){
		do{
			memset(vis,0,sizeof(vis));
			dfs(s,inf);
		}while(vis[t]);
	}
	printf("%lld",-anscost);
}
ll dis(ll xx1,ll yy1,ll xx2,ll yy2){
	return floor((double)sqrt((ll)(xx1-xx2)*(xx1-xx2)+(yy1-yy2)*(yy1-yy2)));
}
int main(){
	scanf("%lld%lld",&n,&k);
	for(int i=1;i<=n;i++){
		scanf("%lld%lld%lld%lld",&xx1[i],&yy1[i],&xx2[i],&yy2[i]);//读入线段
		diss[i]=dis(xx1[i],yy1[i],xx2[i],yy2[i]);//计算距离
		xx1[i]*=2;//扩域
		xx2[i]*=2;
		if(xx1[i]==xx2[i]){
			xx2[i]++;
		}else{
			xx1[i]++;
		}
		num[++cnt]=xx1[i];
		num[++cnt]=xx2[i];
	}
	sort(num+1,num+1+cnt);//离散化
	ll len=unique(num+1,num+1+cnt)-num-1;
	t=len;
	s=len+1;
	add(s,1,k,0);//建边(具体原因可以参考P3378)
	for(ll i=1;i<t;i++){
		add(i,i+1,k,0);
	}
	for(ll i=1;i<=n;i++){
		add(lower_bound(num+1,num+1+len,xx1[i])-num,lower_bound(num+1,num+1+len,xx2[i])-num,1,-1*diss[i]);
	}
	dinic();//最小费用最大流模板
	return 0;
}
/*
4 2
-1 0 0 3
-1 1 0 2
-1 2 0 1
1 1 2 2
*/
```
---------------------------
注：文章节选自我的博客，故图片是“图11”而非“图1”

---

## 作者：KSkun (赞：9)

本题解同步发布于我的博客[网络流24题题解 | KSkun's Blog](https://ksmeow.moe/graph\_flow\_24prob\_sol/)，欢迎来逛w


这个题的分析基于[【P3358】最长k可重区间集问题 - 洛谷](https://www.luogu.org/problemnew/show/P3358)的分析，如果没有看过这个题建议先把这个题做一做，再来考虑本题。


## 题解

这个题只是把最长k可重区间集问题的开区间改成了开线段。我们想一下区间变成线段带来了什么变化：首先是长度的求法变了，这个不会对建模产生影响。能产生影响的是线段是可以垂直于x轴的。这就意味着当我们以线段的左右端点x坐标连边时会遇到x坐标相同的情况，这显然是不应出现的。我们采用拆点的策略解决这个问题。假如拆出来的点分别是X点和Y点如果x坐标相同，就从X向Y连，否则从Y向X连。其他的部分与上面那个题相同。


## 代码

（MCMF板子写的不是很漂亮qwq，凑合着看一下吧）

```cpp
// Code by KSkun, 2018/1
#include <cstdio>
#include <cstring>
#include <cmath>
#include <vector>
#include <queue>
#include <algorithm>
typedef long long LL;

struct io {
    char buf[1 << 26], *s;
    
    io() {
        fread(s = buf, 1, 1 << 26, stdin);
    }
    
    inline LL read() {
        register LL res = 0, neg = 1;
        while(*s < '0' || *s > '9') if(*(s++) == '-') neg = -1;
        while(*s >= '0' && *s <= '9') res = res * 10 + *s++ - '0';
        return res * neg;
    }
} ip;

#define read ip.read

const int MAXN = 1000005;
const int INF = 2e9;

struct Edge {
    LL to, cap, cost, rev;
    Edge(int to, LL cap, LL cost, int rev): to(to), cap(cap), cost(cost), rev(rev) {}
};

std::vector<Edge> vec[MAXN];
std::queue<int> que;
LL f[MAXN];
int pre[MAXN], pree[MAXN];
LL dis[MAXN];
bool inque[MAXN];

inline void addedge(int u, int v, LL cap, LL cost) {
    vec[u].push_back(Edge(v, cap, cost, vec[v].size()));
    vec[v].push_back(Edge(u, 0, -cost, vec[u].size() - 1));
}

// SPFA Min Cost Flow

LL flow = 0, cost = 0;

inline void min_cost_flow(int s, int t) {
    for(;;) {
        memset(f, 0, sizeof f);
        memset(dis, 0x3f, sizeof dis);
        memset(inque, 0, sizeof inque);
        while(!que.empty()) que.pop();
        que.push(s);
        dis[s] = 0;
        inque[s] = true;
        f[s] = INF;
        while(!que.empty()) {
            int u = que.front();
            que.pop();
            inque[u] = false; 
            for(int i = 0; i < vec[u].size(); i++) {
                int v = vec[u][i].to;
                if(vec[u][i].cap > 0 && dis[v] > dis[u] + vec[u][i].cost) {
                    pre[v] = u;
                    pree[v] = i;
                    f[v] = std::min(vec[u][i].cap, f[u]);
                    dis[v] = dis[u] + vec[u][i].cost;
                    if(!inque[v]) {
                        que.push(v);
                        inque[v] = true;
                    }
                }
            }
        }
        if(f[t] == 0) break;
        for(int u = t; u != s; u = pre[u]) {
            vec[pre[u]][pree[u]].cap -= f[t];
            vec[u][vec[pre[u]][pree[u]].rev].cap += f[t];
        }
        flow += f[t];
        cost += 1ll * f[t] * dis[t];
    }
}

struct Seg {
    LL l, r, len;
    Seg(LL x1, LL x2, LL len): l(x1), r(x2), len(len) {}
};

inline LL getlen(LL x1, LL y1, LL x2, LL y2) {
    return floor(sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1)));
}

LL n, k, xa, xb, ya, yb, S, T, N;
std::vector<LL> tmp;
std::vector<Seg> segs; 

int main() {
    n = read();
    k = read();
    for(int i = 0; i < n; i++) {
        xa = read();
        ya = read();
        xb = read();
        yb = read();
        LL len = getlen(xa, ya, xb, yb);
        if(xa > xb) {
            std::swap(xa, xb);
        }
        xa <<= 1;
        xb <<= 1;
        if(xa == xb) xb |= 1; else xa |= 1; // 这里就是拆点 
        tmp.push_back(xa);
        tmp.push_back(xb);
        segs.push_back(Seg(xa, xb, len));
    }
    std::sort(tmp.begin(), tmp.end());
    N = std::unique(tmp.begin(), tmp.end()) - tmp.begin();
    for(int i = 0; i < segs.size(); i++) {
        segs[i].l = std::lower_bound(tmp.begin(), tmp.begin() + N, segs[i].l) - tmp.begin() + 1;
        segs[i].r = std::lower_bound(tmp.begin(), tmp.begin() + N, segs[i].r) - tmp.begin() + 1;
    }
    S = N + 1;
    T = S + 1;
    addedge(S, 1, k, 0);
    for(int i = 0; i < N; i++) {
        addedge(i, i + 1, INF, 0);
    }
    for(int i = 0; i < segs.size(); i++) {
        addedge(segs[i].l, segs[i].r, 1, -segs[i].len);
    }
    addedge(N, T, INF, 0);
    min_cost_flow(S, T);
    printf("%lld", -cost);
    return 0;
}
```

---

## 作者：Booksnow (赞：2)

# 最长 $k$ 可重线段集

## 题目大意

给定平面 $x-O-y$ 上 $n$ 个开线段组成的集合 $I$ ，和一个正整数 $k$ 。试设计一个算法，从开线段集合 $I$ 中选取开线段集合 $S \subseteq I$ ，使得在 $x$ 轴上的任意一点 $P$ ， $S$ 中与直线 $x=p$ 相交的开线段个数不超过 $k$ ，且 $\sum_{z \in S}|z|$ 最大。这样的集合 $S$ 称为开线段集合 $I$ 的最长 $k$ 可重线段集。 $\sum_{z\in S}|z|$ 称为最长 $k$ 可重线段集的长度。

对于任意开线段 $z$ ，设其端点坐标为 $(x_0,y_0)$ 和 $(x_1,y_1)$ ，则开线段 $z$ 的长度 $|z|$ 定义为：

$$ |z|=[\sqrt{(x_1-x_0)^2+(y_1-y_0)^2}]  $$ 

对于给定的开线段集合 $I$ 和正整数 $k$ ，计算开线段集合 $I$ 的最长 $k$ 可重线段集的长度。

## 分析

想要解决此题，可以先看一下与该题基本如出一辙的：[最长 $k$ 可重区间集[题解]](https://www.cnblogs.com/Defoliation-ldlh/p/14457168.html)

其实这道题和上述此题非常类似，只不过将水平的区间转化为了一些基本无规律处于二维平面内的线段。

那么我们还是可以把问题转化到 $x$ 上，我们发现其实 $y$ 坐标和题目的限制关系不大，我们只需要解决**横坐标**部分即可。

其实我们只需要把线段两个端点的 $x$ 坐标转化为何上述题目一样的区间即可，就可以得到和上述题目一样的过程，具体分析可以点击**上方链接**，下面直接给出建图思路：

- 将每个线段的左右端点的 $x$ 坐标储存起来，并将线段 $i$ 拆成 $i$ 与 $i'$ 分别表示点 $i$ 的入点与出点，对于每对拆点，在他们中间连接一条流量为 $1$ ，费用为线段长度的边。

- 建立一个**超级源点**和**超级汇点**，超级源点向真正的源点连接一条流量为 $k$ ，费用为 $0$ 的边，并再将源点向每条线段的入点连接一条流量为 $1$ ，费用为 $0$ 的边，每条线段的出点向超级汇点连接一条流量为 $1$ ，费用为 $0$ 的边。

- 对于左右端点形成的区间互不相交的线段，在他们之间建立一条流量为 $+\infty$ ，费用为 $0$ 的边。

这样就可以直接跑最大费用了。

需要注意两个地方：

- 本文一开始的链接中详细论述了线段连接**有序性**的必要，所以我们必须要排序或是要保证线段连接的有序。

- 对于两条线段，如果他们完全相同的话，我们仍然需要将其**计算在限制**内，所以需要进行特殊判断，不能进行连边。

最后代码如下：

## CODE

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N=5e2+10,INF=0x7fffffff;
int n,k,s,t,_s,ans;
struct node{ int l,r,len; }sec[N];
inline int read()
{
	int s=0,w=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-') w=-1;ch=getchar();}
	while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
	return s*w;
}
inline bool cmp(node x,node y) { return x.l<y.l; }
int tot=-1,v[2*N*N],w[2*N*N],pay[2*N*N],nex[2*N*N],first[2*N];
inline void Add(int x,int y,int z,int c)
{
	nex[++tot]=first[x];
	first[x]=tot;
	v[tot]=y,w[tot]=z,pay[tot]=c;
}
bool vis[2*N];
int pre[2*N],dis[2*N],Min[2*N]; 
inline bool SPFA()
{
	for(register int i=s;i<=t;i++) dis[i]=-INF;
	for(register int i=s;i<=t;i++) vis[i]=false;
	queue<int> q;
	q.push(s);
	vis[s]=true,dis[s]=0,Min[s]=INF;
	while(!q.empty()){
		int now=q.front(); q.pop();
		vis[now]=false;
		for(register int i=first[now];i!=-1;i=nex[i]){
			int to=v[i];
			if(!w[i]) continue;
			if(dis[to]<dis[now]+pay[i]){
				dis[to]=dis[now]+pay[i];
				Min[to]=min(Min[now],w[i]);
				pre[to]=i;
				if(!vis[to]) q.push(to),vis[to]=true;
			}
		}
	}
	return dis[t]!=-INF;
}
inline void EK()
{
	while(SPFA()){
		ans+=Min[t]*dis[t];
		int temp=t,i;
		while(temp!=s){
			i=pre[temp];
			w[i]-=Min[t];
			w[i^1]+=Min[t];
			temp=v[i^1];
		}
	}
}
signed main()
{
	memset(first,-1,sizeof(first));
	n=read(),k=read();
	for(register int i=1;i<=n;i++){
		int _x1=read(),_y1=read(),_x2=read(),_y2=read();
		sec[i].l=min(_x1,_x2),sec[i].r=max(_x1,_x2);
		sec[i].len=(int)sqrt((_x1-_x2)*(_x1-_x2)+(_y1-_y2)*(_y1-_y2));
	}
	s=0,_s=2*n+1,t=2*n+2;
	sort(sec+1,sec+n+1,cmp);
	Add(s,_s,k,0),Add(_s,s,0,0);
	for(register int i=1;i<=n;i++){
		Add(_s,i,1,0),Add(i,_s,0,0);
		Add(i,i+n,1,sec[i].len),Add(i+n,i,0,-sec[i].len);
		Add(i+n,t,1,0),Add(t,i+n,0,0);
	}
	for(register int i=1;i<=n;i++){
		for(register int j=i+1;j<=n;j++){
            if(sec[i].l==sec[i].r&&sec[j].l==sec[j].r&&sec[i].l==sec[j].l) continue;
    		if(sec[j].l>=sec[i].r||sec[i].l>=sec[j].r) Add(i+n,j,INF,0),Add(j,i+n,0,0);
		}
	}
	EK();
	printf("%lld\n",ans);
	return 0;
}
```


---

## 作者：cunzai_zsy0531 (赞：1)

# P3357本人的题解

[题目链接](https://www.luogu.com.cn/problem/P3357)

网络流题目，关键在于建模。

这题是个最大费用最大流，最大流保证k可重，最大费用就是题目求的最长的长度。

建模：

0. 对于输入的$x_i$和$y_i$，我们计算此线段的长度$Len_i$：

$Len_i$ = $\sqrt{x^2_i+y^2_i}$

1. $S$->$1$ 流$k$，费用0

1. $i-1$到$i$，流$k$，费用0

1. $i$->$j$($i\le j$) 因为可能出现$x$坐标相同（线段平行于$y$轴）的情况，所以这里要拆点，每个点拆为$i*2-1$和$i*2$。我们设这两个点为$X_i$和$Y_i$。将$i$和$j$离散化之后：若$i=j$，那么连$X_i$和$Y_i$；若$i\neq j$，连$Y_i$和$X_j$。流都是k，费用都是$Len_i$。

1. 连$X_n$,$Y_n$到$t$，流$k$，费用0。

建模毕。

然后就是mcmf板子，注意最大费用最大流最好是边权取反然后跑正常的，但是本人比较懒就直接在SPFA中换了个符号：
```cpp
if(f&&dist[v]>dist[u]+w)
```
这里把`>`直接改了`<`，数据小的话应该没问题。

注意初始化要改成
```cpp
memset(dist,0xcf,sizeof(dist));
```
其他没什么了，上代码：

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<queue>
#include<cmath>
using namespace std;
const int N=1000+5,INF=0x3f3f3f3f;
struct Edge{int u,v,f,w,nxt;}e[N*N];
int h[N],flow[N],dist[N],pre[N],last[N];
bool vis[N];
int l[N],r[N],a[N*2],len[N];
int n,m,s,t,k,tot=1,mc,mf;
inline void add(int u,int v,int f,int w){//建图，建双向边
	e[++tot]=(Edge){u,v,f,w,h[u]};h[u]=tot;
	e[++tot]=(Edge){v,u,0,-w,h[v]};h[v]=tot;
}
bool spfa(){
	memset(dist,0xcf,sizeof(dist));//跑最大费用，dist要赋无穷小
	memset(vis,0,sizeof(vis));
	memset(flow,0x3f,sizeof(flow));
	queue<int>q;
	q.push(s);
	dist[s]=0;
	vis[s]=1;
	pre[t]=-1;
	while(!q.empty()){
		int u=q.front();
		q.pop();
		vis[u]=0;
		for(int i=h[u];i;i=e[i].nxt){
			int v=e[i].v,f=e[i].f,w=e[i].w;
			if(f&&dist[v]<dist[u]+w){//这里改了符号
				dist[v]=dist[u]+w;
				flow[v]=min(flow[u],f);
				pre[v]=u;
				last[v]=i;
				if(!vis[v]){
					vis[v]=1;
					q.push(v);
				}
			}
		}
	}
	return pre[t]!=-1;
}
void mcmf(){//mcmf板子
	while(spfa()){
		mf+=flow[t];
		mc+=flow[t]*dist[t];
		int now=t;
		while(now!=s){
			e[last[now]].f-=flow[t];
			e[last[now]^1].f+=flow[t];
			now=pre[now];
		}
	}
}
int main(){
	scanf("%d%d",&n,&k);
	for(int i=1,y1,y2;i<=n;++i){
		scanf("%d%d%d%d",&l[i],&y1,&r[i],&y2);
		if(l[i]>r[i]) swap(l[i],r[i]);
		len[i]=sqrt(pow(y1-y2,2)+pow(r[i]-l[i],2));//计算Len[i]
		l[i]<<=1,r[i]<<=1;
		if(l[i]==r[i]) r[i]++;
		else l[i]++;
		a[i]=l[i],a[i+n]=r[i];
	}
    //下面是拆点
	sort(a+1,a+2*n+1);
	m=unique(a+1,a+2*n+1)-a-1;s=m+1,t=m+2;
	for(int i=1,L,R;i<=n;++i){
		L=lower_bound(a+1,a+m+1,l[i])-a;
		R=lower_bound(a+1,a+m+1,r[i])-a; 
		add(L,R,1,len[i]);
	}
	for(int i=1;i<=m;++i){
		if(i==1) add(s,i,k,0);
		else{
			add(i-1,i,k,0);
			if(i==m) add(i,t,k,0),add(i,t,k,0);
		}
	}
	mcmf();
	printf("%d\n",mc);//输出最大费用
	return 0;
}
```


---

## 作者：ZPC2048 (赞：1)

~~写完P3358题解再过来水一波，双倍经验QWQ~~

前置题解：[P3358 最长k可重区间集问题 题解](https://www.luogu.org/blog/ZPC2048/solution-p3358)

本题思路与P3358几乎完全一样，本题就是将一条线段投影到$x$轴上去做P3358。除了需要特判$x_{0}=x_{1}$，即线段垂直于$x$轴的情况外，代码几乎不用改。**注意$length_{i}$的计算爆$int$** ~~十年OI一场空，不开long long见祖宗~~

```cpp
#include<cstdio>
#include<cstring>
#include<cmath>
#include<queue>
#include<algorithm>

using namespace std;

const int MAXN = 500 + 20;
const int MAXE = MAXN * 400;
const long long INF = 0x3f3f3f3f3f3f3f3f;

struct Segment {
    long long l, r, length;
    Segment(long long l = 0, long long r = 0, long long length = 0) :
        l(l), r(r), length(length) {};
    bool operator < (const Segment &A) const {
        return l == A.l ? r < A.r : l < A.l;
    }
}I[MAXN];

struct Edge {
    int bg, ed, nxt, flow;
    long long cost;
    Edge(int bg = 0, int ed = 0, int nxt = 0, int flow = 0, long long cost = 0) :
        bg(bg), ed(ed), nxt(nxt), flow(flow), cost(cost) {};
};

struct Map {
    Edge edge[MAXE];
    int head[MAXN << 1], count = 1;
    inline void insert(int bg, int ed, int flow, long long cost) {
        edge[++count] = Edge(bg, ed, head[bg], flow, cost);
        head[bg] = count;
        edge[++count] = Edge(ed, bg, head[ed], 0, -cost);
        head[ed] = count;
    }
}A;

long long dis[MAXN << 1];
int pre[MAXN << 1][3];//node edge flow
bool vis[MAXN << 1];

bool bfs(int s, int t) {
    memset(dis, 0x3f, sizeof(dis));
    memset(pre, 0, sizeof(pre));
    memset(vis, false, sizeof(vis));
    queue<int> que;
    que.push(s);
    dis[s] = 0;
    pre[s][2] = 0x3f3f3f3f;
    while (!que.empty()) {
        int now = que.front();
        que.pop();
        vis[now] = false;
        for (int i = A.head[now]; i; i = A.edge[i].nxt) {
            int v = A.edge[i].ed;
            if (dis[v] > dis[now] + A.edge[i].cost && A.edge[i].flow) {
                dis[v] = dis[now] + A.edge[i].cost;
                pre[v][0] = now;
                pre[v][1] = i;
                pre[v][2] = min(pre[now][2], A.edge[i].flow);
                if (!vis[v]) {
                    que.push(v);
                    vis[v] = true;
                }
            }
        }
    }
    return dis[t] != INF;
}

long long EK(int s, int t) {
    long long ans = 0;
    while (bfs(s, t)) {
        int now = t, change = pre[t][2];
        while (pre[now][0]) {
            int e = pre[now][1];
            A.edge[e].flow -= change;
            A.edge[e ^ 1].flow += change;
            now = pre[now][0];
        }
        ans += change * dis[t];
    }
    return ans;
}

int main() {
    int n, k, s, S, T;
    long long x0, y0, x1, y1;
    scanf("%d%d", &n, &k);
    s = n * 2 + 1; S = s + 1; T = S + 1;
    for (int i = 1; i <= n; ++i) {
        scanf("%lld%lld%lld%lld", &x0, &y0, &x1, &y1);
        I[i] = Segment(min(x0, x1), max(x0, x1), (long long)floor(sqrt((x0 - x1) * (x0 - x1) + (y0 - y1) * (y0 - y1))));
    }
    sort(I + 1, I + n + 1);
    A.insert(S, s, k, 0);
    for (int i = 1; i <= n; ++i) {
        A.insert(i, i + n, 1, -I[i].length);
        A.insert(s, i, 1, 0);
        A.insert(i + n, T, 1, 0);
        for (int j = i + 1; j <= n; ++j) {
            if (I[i].l == I[i].r && I[j].l == I[j].r && I[i].l == I[j].l) continue;//特判一下两条重合且垂直于x轴的线段
            if (I[i].r <= I[j].l || I[i].l >= I[j].r) {
                A.insert(i + n, j, 1, 0);
            }
        }
    }
    printf("%lld\n", -EK(S, T));
}
```


---

## 作者：Tastoya (赞：0)

这题和 P3358 一模一样，建模形式直接不用变，就两点不一样，一是 $len$ 变化了，加入 $y$ 后再更新即可。

还有就是可能会出现 $x_0 = x_1$ 的情况，即一条开线段垂直 $x$ 轴，如果我们依旧按照上一题的建图方法，就会出现负权环，无法跑出答案。

我们就可以把一个点拆成入点和出点，这样无论是否是不是垂直都可以一样建，注意开 `long long`，不开 `long long` 可能只有 $9$ 分。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define lowbit(x) ((x)&(-x))
#define sqr(x) ((x)*(x))
typedef long long LL;

const int maxm = 1e5+5;
const LL INF = 0x3f3f3f3f3f3f3f3f;

struct edge{
    LL u, v, cap, flow, cost, nex;
} edges[maxm];

struct Points{
    LL l, r, len;
} point[505];

LL head[maxm], cur[maxm], cnt, fa[1024<<1], n, d[1024<<1], allx[1024];
bool inq[1024<<1];

void init() {
    memset(head, -1, sizeof(head));
}

void add(int u, int v, LL cap, LL cost) {
    edges[cnt] = edge{u, v, cap, 0, cost, head[u]};
    head[u] = cnt++;
}

void addedge(int u, int v, LL cap, LL cost) {
    add(u, v, cap, cost), add(v, u, 0, -cost);
}

bool spfa(int s, int t, int &flow, LL &cost) {
    for(int i = 0; i <= n+2; ++i) d[i] = INF; //init()
    memset(inq, false, sizeof(inq));
    d[s] = 0, inq[s] = true;
    fa[s] = -1, cur[s] = INF;
    queue<int> q;
    q.push(s);
    while(!q.empty()) {
        int u = q.front();
        q.pop();
        inq[u] = false;
        for(int i = head[u]; i != -1; i = edges[i].nex) {
            edge& now = edges[i];
            int v = now.v;
            if(now.cap > now.flow && d[v] > d[u] + now.cost) {
                d[v] = d[u] + now.cost;
                fa[v] = i;
                cur[v] = min(cur[u], now.cap - now.flow);
                if(!inq[v]) {q.push(v); inq[v] = true;}
            }
        }
    }
    if(d[t] == INF) return false;
    flow += cur[t];
    cost += 1LL*d[t]*cur[t];
    for(int u = t; u != s; u = edges[fa[u]].u) {
        edges[fa[u]].flow += cur[t];
        edges[fa[u]^1].flow -= cur[t];
    }
    return true;
}

int MincostMaxflow(int s, int t, LL &cost) {
    cost = 0;
    int flow = 0;
    while(spfa(s, t, flow, cost));
    return flow;
}

void run_case() {
    init();
    LL l, r, y1, y2;
    int k, xcnt = 0;
    cin >> n >> k;
    for(int i = 1; i <= n; ++i) {
        cin >> l >> y1 >> r >> y2;
        LL tmp = 1LL*floor(sqrt(sqr(r-l)+sqr(y2-y1)));
        if(l > r) swap(l, r);
        l <<= 1, r <<= 1;
        if(l == r) r|=1; else l|=1;
        allx[++xcnt] = l, allx[++xcnt] = r, point[i] = Points{l, r, tmp};
    }
    sort(allx+1,allx+1+xcnt);
    int len = unique(allx+1,allx+1+xcnt)-allx;
    for(int i = 1; i <= n; ++i) {
        point[i].l = lower_bound(allx+1,allx+len,point[i].l)-allx;
        point[i].r = lower_bound(allx+1,allx+len,point[i].r)-allx;
    }
    for(int i = 1; i < len-1; ++i)
        addedge(i, i+1, INF, 0);
    int s = 0, t = len;
    for(int i = 1; i <= n; ++i) {
        addedge(point[i].l, point[i].r, 1, -point[i].len);
    }
    addedge(s, 1, k, 0), addedge(len-1, t, k, 0);
    LL cost = 0;
    n = len;
    MincostMaxflow(s, t, cost);
    cout << -cost;
}

int main() {
    ios::sync_with_stdio(false), cin.tie(0);
    run_case();
    cout.flush();
    return 0;
}
```


---

## 作者：Nt_Tsumiki (赞：0)

[传送门](https://www.luogu.com.cn/problem/P3357)

### 题意

给定平面上一个个开线段的集合 $I$，和一个数 $k$。有开线段集合 $S\subseteq I$ ,且使得在 $x$ 轴上的任何一点 $p$，$S$ 中与直线 $x=p$ 相交的开线段个数不超过 $k$，且$\sum\limits_{z\in S}|z|$达到最大，则开线段集合 $S$ 称为开线段集合 $I$ 的最长 $k$ 可重线段集。$\sum\limits_{z\in S}|z|$ 称为最长 $k$ 可重线段集的长度。

### 做法

先来看一下 P3358 是怎么做的。

首先需要了解一个网络流基本模型：一流对多流（可以类比电流），主要用来解决一些可以同时选（可以类比串联）以及不同时选（可以类比并联）的问题。

对于 P3358，明显对于两个不相互重叠的集合可以都选，可以用同一个流，而对于两个不重合的集合，则选择就有了限制，需要用两个流。

再将其与模型结合一下，我们可以对于数轴上的点每个点和其后面的点连在一起，流量 $k$，费用 $0$（对应并联），对于每个开区间，其左端点和右端点连在一起，流量 $1$，费用 $len$（对应串联），但由于其中无用的点太多，所以可以离散化一下，最后再将源点 $s$ 和 $1$ 连在一起，将 $cnt$ 和汇点 $t$ 连在一起，跑费用流即可。

而这道题看似跟 P3358 没什么区别，因为只有一个关于 $x$ 轴的限制，所以也可以近似地看做区间，但是因为变成了平面上的线段，所以如果有两条两个端点的横坐标都相等的线段，就不会连到一起，但是不应该这样。

考虑扩域。我们把每个点拆成两个点，如果有左右端点横坐标相同的线段存在，就把右端点的横坐标改为 $2 \times x+1$，理所当然左端点不变为 $2 \times x$。

但问题又来了，扩域之后可能会导致两个本来不交的两个线段交在一起，如何解决？答案是，接着扩域。

我们可以对于一条左右端点的横坐标不相等的点的左端点的横坐标改为 $2 \times x_l+1$，右端点保持不变。

考虑这样做的正确性。很明显对于原先不交的线段 $(a,a)$ 和 $(a,b)$，扩域之后，$(a,a)$ 的右端点变成了 $2 \times a+1$，$(a,b)$ 的左端点变成了 $2 \times a+1$，相对位置保持不变。而对于两个不交的线段，扩域之后不交还是不交，没有变化。

注意要先扩域再离散化，否则会 T 掉。

### Code

```cpp
#include <algorithm>
#include <iostream>
#include <cstring>
#include <cstdio>
#include <cmath>
#include <queue>

#define int long long
#define INF 1145141919

namespace Dinic_mcmf {
    struct Node {
        int to,nxt,dis,val;
    }e[100001];

    int tot=1,s,t,mcmf,head[10001],cur[10001],vis[10001],dis[10001];

    void add(int x,int y,int k,int v) { e[++tot]=(Node){y,head[x],k,v},head[x]=tot; }

    bool SPFA(int n) {
        for (int i=1;i<=n;i++) dis[i]=-1e9;
        memset(vis,0,sizeof vis); vis[s]=1;
        std::queue<int> q; q.push(s);
        while (!q.empty()) {
            int x=q.front(); q.pop(); vis[x]=0;
            for (int i=head[x];i;i=e[i].nxt) {
                int y=e[i].to; cur[x]=head[x];
                if (e[i].dis and dis[y]<dis[x]+e[i].val) {
                    dis[y]=dis[x]+e[i].val;
                    if (!vis[y]) q.push(y),vis[y]=1;
                }
            }
        }
        return dis[t]!=-1e9;
    }

    int dfs(int x,int flow) {
        if (x==t) return flow;
        int res=0; vis[x]=1;
        for (int i=cur[x];i and flow;i=e[i].nxt) {
            int y=e[i].to; cur[x]=i;
            if (e[i].dis and dis[y]==dis[x]+e[i].val and !vis[y]) {
                int k=dfs(y,std::min(e[i].dis,flow));
                e[i].dis-=k,e[i^1].dis+=k,res+=k,flow-=k,mcmf+=k*e[i].val;
            }
        }
        vis[x]=0; return res;
    }
}
using namespace Dinic_mcmf;
using namespace std;
int n,k,cnt,ans;
int l[100001],r[100001],len[100001],b[100001];

int ddis(int x1,int y1,int x2,int y2) { return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2)); }

signed main() {
    scanf("%lld%lld",&n,&k);
    for (int i=1,x1,y1,x2,y2;i<=n;i++) {
        scanf("%lld%lld%lld%lld",&x1,&y1,&x2,&y2); len[i]=ddis(x1,y1,x2,y2);
        x1*=2,x2*=2;
        if (x1==x2) x2++;
        else x1++;
        l[i]=x1,r[i]=x2,b[++cnt]=l[i],b[++cnt]=r[i];
    }
    sort(b+1,b+cnt+1); 
    cnt=unique(b+1,b+cnt+1)-b-1; t=cnt+1;
    for (int i=1;i<=n;i++) l[i]=lower_bound(b+1,b+cnt+1,l[i])-b,r[i]=lower_bound(b+1,b+cnt+1,r[i])-b;
    for (int i=2;i<=cnt;i++) add(i-1,i,k,0),add(i,i-1,0,0);
    add(s,1,k,0),add(1,s,0,0);
    add(cnt,t,k,0),add(t,cnt,0,0);
    for (int i=1;i<=n;i++) add(l[i],r[i],1,len[i]),add(r[i],l[i],0,-len[i]);
    while (SPFA(t)) ans+=dfs(s,INF);
    printf("%lld\n",mcmf);
    return 0;
}
```

---


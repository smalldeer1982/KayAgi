# 最长k可重区间集问题

## 题目描述

给定实直线 $\text{L}$ 上 $n$ 个开区间组成的集合 $\mathbf{I}$，和一个正整数 $k$，试设计一个算法，从开区间集合 $\mathbf{I}$ 中选取出开区间集合 $\mathbf{S}\subseteq\mathbf{I}$，使得在实直线 $\text{L}$ 上的任意一点 $x$，$\text{S}$ 中包含 $x$ 的开区间个数不超过 $k$，且 $\sum_{z\in\text{S}}\lvert z\rvert$ 达到最大（$\lvert z\rvert$ 表示开区间 $z$ 的长度）。

这样的集合 $\mathbf{S}$ 称为开区间集合 $\mathbf{I}$ 的最长 $k$ 可重区间集。$\sum_{z\in\text{S}}\lvert z\rvert$ 称为最长 $k$ 可重区间集的长度。

对于给定的开区间集合 $\mathbf{I}$ 和正整数 $k$，计算开区间集合 $\mathbf{I}$ 的最长 $k$ 可重区间集的长度。

## 说明/提示

对于 $100\%$ 的数据，$1\le n\le 500$，$1\le k\le 3$，$1 \le l < r \le 10^5$。

## 样例 #1

### 输入

```
4 2
1 7
6 8
7 10
9 13 ```

### 输出

```
15```

# 题解

## 作者：皎月半洒花 (赞：196)

感觉此题大部分题解都一点也不负责任。

本人十分不赞同，对于一道网络流题，一篇题解只说怎么建图不说思路的行为。我就想请问，难道做一道题的目的，就只在于做这一道题吗？A了就好？原理思路什么爱管不管？这能叫题解？

网络流题的重点就是在于建图。如果这都能一笔带过，那还做个锤子？

毫不夸张的说，如果张三做网络流题的时候就这么似是而非，就算他勤勤恳恳地做完了24题，省选的时候也运气好遇到了网络流题，做出来的概率绝对不高，或者说就根本不可能做出来。

你说，网络流题是什么？到现在为止还只是一个靠经验和阅历通杀的题目类别。所以网络流题需要格外重视经验的积累，知其然知其所以然。

总之呢，一道网络流题，不仔细分析思路直接告诉你怎么建图，就是在耍流氓。

_____

> 给定实直线 $ L $ 上 $ n $ 个开区间组成的集合 $ I $，和一个正整数 $ k $，试设计一个算法，从开区间集合 $ I $ 中选取出开区间集合 $ S \subseteq I $，使得在实直线 $ L $ 的任何一点 $ x $，$ S $ 中包含点 $ x $ 的开区间个数不超过 $ k $。且 $ \sum\limits_{z \in S} | z | $ 达到最大。这样的集合 $ S $ 称为开区间集合 $ I $ 的最长 $ k $ 可重区间集。$ \sum\limits_{z \in S} | z | $ 称为最长 $ k $ 可重区间集的长度。
>
> 对于给定的开区间集合 $ I $ 和整数 $ k $，计算开区间集合 $ I $ 的最长 $ k $ 可重区间集的长度。
>
> $ 1 \leq n \leq 500, 1 \leq k \leq 3 $

首先一拿出来，这不就是匹配问题嘛？一个点最多匹配 $k$ 个区间。于是每个位置建一个点，然后连向覆盖自己的点，然后…好像不太对？其一他没给下标的取值范围，其二一个线段覆盖多个点，要么都覆盖要么都不覆盖，这个限制很难表示…

于是好像不知道从何处入手了。发现一个这样的性质，就是永远不会选择 $k$ 个以上交于 $1$ 点的区间。也就是说，如果两个区间彼此之间没有交，就可以同时选；否则能不能同时选，看情况。这像极了「限制」，也就是如果两个区间之间没有交，那两者不存在限制；否则存在 $k$ 的限制。

根据一开始的匹配，可以猜到大致上用网络流是可行的。并且似乎网络流很适合用流量来表征限制。那么考虑，如果两个区间不存在限制，那么应该怎么办——网络流类似电流，所以此时如果串联的话，就代表着可以同时选；那么如果存在限制，就意味着不能串联。根据这一点，考虑如何串联。发现本质上是将两个不交的区间中间连 $f=\infty,c=0$ 的边。

这一点就引申出两个建图方法，其本质是相同的：

1、建立一个超级源 $\rm S$ 和一个源 $\rm S'$ ，中间连 $f=k,c=0$ 的边，目的是提供初始流量。$\rm S'$ 向每个区间的左端点连一条 $f=1,c=-1$ 边。然后区间左端点向右端点连边 $f=1,c=-len$ 表示贡献，每个右端点再向 $\rm T $ 连边即可。如果两个区间不交，就由一个区间的 $r$ 连向另一个区间的 $l$ （当然要按秩啦）。思考这样做的合理性，对于相交的区间，一定是并联；否则的话就是串联（其实叫做混连，但是问题不大）。

2、建立一个源 $\rm S$ 连向数轴上的 $0$ 位置，$f=k,c=0$。然后数轴上每个 $i>0$ 向 $i+1$ 连边 $f=k,c=0$。最后 $maxright$ 向 $\rm T$ 连边。对于一个区间，连法跟1相同。

注意：

1、为什么要拆点？此处拆点的作用值得注意。对于一个区间，本质上应该抽象成一个点。但是在流图里是不存在「点权」这个概念的。所以需要把点权转边权，拆点的作用便在于此。

2、其实上面两个方法，可以通过初中物理里面什么「判断两个电路图是否等价」的知识来解决的233

3、由于本题保证了「开区间」，所以可以直接 $l\to r,len=r-l$ 。当然如果是闭区间，只需要改成 $l\to r+1$ 即可。

4、上面的第二个方案，发现最终可能存在很多数轴上的点 $i$ 只与 $i-1,i+1$ 连了 $f=k,c=0$ 的边，所以是没用的，离散化掉就好了。 

```cpp
const int N = 200010 ;
const int I = 998244353 ;

#define ft first
#define sc second
#define to(k) e[k].to
#define fr(k) e[k].from
#define fw(k) e[k].flow
#define ct(k) e[k].cost
#define next(k) e[k].next
#define pint pair<int, int>

struct Edge{
    int to ;
    int from ;
    int flow ;
    int cost ;
    int next ;
}e[N * 2] ;

int _s ;
int _t ;
int ans ;
int res ;
int cnt ;
int n, m ;
int g[N] ;
int vis[N] ;
int dis[N] ;
int pre[N] ;
int head[N] ;
int _last[N] ;
queue <int> q ;

void add(int u, int v, int f, int c){
    to(++ cnt) = v ;
    next(cnt) = head[u] ;
    fw(cnt) = f ; ct(cnt) = c ;
    fr(cnt) = u ; head[u] = cnt ;
}
bool spfa(){
    fill(g, g + n + 1, I) ;
    fill(dis, dis + n + 1, I) ;
    fill(vis, vis + n + 1, 0) ;
    q.push(_s) ; vis[_s] = 1 ; dis[_s] = 0 ;
    while (!q.empty()){
        int x = q.front() ;
        q.pop() ; vis[x] = 0 ;
        for (int k = head[x] ; ~k ; k = next(k))
            if (dis[to(k)] > dis[x] + ct(k) && fw(k)){
                dis[to(k)] = dis[x] + ct(k) ;
                g[to(k)] = min(fw(k), g[x]) ;
                pre[to(k)] = x ; _last[to(k)] = k ;
                if (!vis[to(k)]){
                    q.push(to(k)) ;
                    vis[to(k)] = 1 ;
                }
            }
    }
    return (bool)(dis[_t] < I) ;
}
void ek(){
    while (spfa()){
        int x = _t ;
        res += g[_t] ;
        ans += g[_t] * dis[_t] ;
        //cout << g[_t] << " " << ans << endl ;
        while (x != _s){
            fw(_last[x]) -= g[_t] ;
            fw(_last[x] ^ 1) += g[_t] ;
            x = pre[x] ;
        }
    }
}

int len[N] ;
pint base[N] ;
int _n, _k, tot ;
map <int, int> Id, buc ;
map <int, int> :: iterator t ;

int main(){
    int u, v, f, c ;
    cin >> _n >> _k ; cnt = -1 ;
    memset(head, -1, sizeof(head)) ;
    for (int i = 1 ; i <= _n ; ++ i){
        cin >> base[i].ft >> base[i].sc ;
        len[i] = base[i].sc - base[i].ft ;
    }
    for (int i = 1 ; i <= _n ; ++ i){
        if (!Id.count(base[i].ft)) buc[base[i].ft] ++ ;
        if (!Id.count(base[i].sc)) buc[base[i].sc] ++ ;
    }
    add(0, 1, _k, 0) ; add(1, 0, 0, 0) ;
    for (t = buc.begin() ; t != buc.end() ; ++ t)
        Id[t->ft] = ++ tot ; _s = 0 ; _t = tot + 1 ;
    for (int i = 1 ; i <= tot ; ++ i)
        add(i, i + 1, I, 0), add(i + 1, i, 0, 0) ;
    for (int i = 1 ; i <= _n ; ++ i){
        //cout << Id[base[i].ft] << " " << Id[base[i].sc] << endl ;
        add(Id[base[i].ft], Id[base[i].sc], 1, -len[i]) ;
        add(Id[base[i].sc], Id[base[i].ft], 0, len[i]) ;
    }
    n = _t + 1 ; ek() ;
    cout << -ans << endl ;
}
```



---

## 作者：chdy (赞：45)

~~遍观所有题解发现都在教怎么建图。。~~ 这对我这个蒟蒻显得非常不友好。

下面是我的理解：

1.    拿到这道题后画了几个图 发现每个每个点被覆盖 当且仅当线段的起点或者终点被覆盖 完全可以离散成点因为一条线段的中间的点是不必要的。

2. 对于每个点我们发现其最多被覆盖k次，也就是说一条线段能覆盖好多点但是一个点最多被覆盖k次，如果我们将每条线段连向源点表示使用当前这条线段 而这条线段需要连向自己覆盖的那些点 这些点连向汇点 容量为k表示自己最多被覆盖k次。

3. 我们让最终被覆盖的点通过汇点的流量限制保证了这个条件后，但是这并不正确，因为这是费用流，这条线段的值肯定是其长度，而流量为1，如果为多的话费用将会被统计的不正确，但是为1的话一条线段的流必然流向某个点 但是我们想让这一条流流过所有的点那么怎么办？

4. 可以发现这变成了一个一流对多流的问题，问题自然也被转换成了如何使用一条流流过若干个点，发现想要这么做必然这些点得横着连到一块然后使用一条流流过他们，所以就有本题的基本模型了把一些点串联起来。

相似题目：志愿者的招募(不过这个是强制要流

5. 本题是最多可以k个也就是不强制要流反而强者限制流，那么我们就从源点放出k流，然后由于最多k条流所以在任意时刻都满足条件的，可以不使用线段所以每个相邻两点之间连上容量为k费用为0的边 然后线段连接l和r 费用为其长度，跑费用流即可。

综上我们发现这是一个一流对多流的问题，可以这样进行解决。

update 2020 10 9:

大概是退役后第一次执笔.

是这样的 一流对多流是经典的模型 怎么做就是志愿者招募的那个建模方法。

尽管其有更优秀的线性规划做法，但是其网络流的建模也是相当经典。

于是做法也就呼之欲出了。

code：
```cpp
//#include<bits/stdc++.h>
#include<iomanip>
#include<iostream>
#include<cstdio>
#include<cstring>
#include<string>
#include<queue>
#include<deque>
#include<cmath>
#include<ctime>
#include<cstdlib>
#include<stack>
#include<algorithm>
#include<vector>
#include<cctype>
#include<utility>
#include<set>
#include<bitset>
#include<map>
#define INF 1000000000
#define ll long long
#define min(x,y) ((x)>(y)?(y):(x))
#define max(x,y) ((x)>(y)?(x):(y))
#define RI register ll
#define db double
using namespace std;
char buf[1<<15],*fs,*ft;
inline char getc()
{
    return (fs==ft&&(ft=(fs=buf)+fread(buf,1,1<<15,stdin),fs==ft))?0:*fs++;
}
inline int read()
{
    int x=0,f=1;char ch=getc();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getc();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getc();}
    return x*f;
}
inline void put(int x)
{
    x<0?x=-x,putchar('-'):0;
    int num=0;char ch[20];
    while(x)ch[++num]=x%10+'0',x/=10;
    num==0?putchar('0'):0;
    while(num)putchar(ch[num--]);
    putchar('\n');return;
}
const int MAXN=510,maxn=50010;
int n,k,S,T,len=1,P,sum,t,h,cnt,top;
int l[MAXN],r[MAXN],b[MAXN<<1],c[MAXN<<1];
int vis[maxn],dis[maxn];
int q[maxn],pre[maxn],in[maxn];
int lin[maxn],nex[maxn],ver[maxn],e[maxn],e1[maxn];
inline void add(int x,int y,int z,int z1)
{
    ver[++len]=y;nex[len]=lin[x];lin[x]=len;e[len]=z;e1[len]=z1;
    ver[++len]=x;nex[len]=lin[y];lin[y]=len;e[len]=0;e1[len]=-z1;
}
inline void discrete()
{
    sort(b+1,b+1+top);
    for(int i=1;i<=top;++i)if(i==1||b[i]!=b[i-1])c[++cnt]=b[i];
    for(int i=1;i<=n;++i)
    {
        l[i]=lower_bound(c+1,c+1+cnt,l[i])-c;
        r[i]=lower_bound(c+1,c+1+cnt,r[i])-c;
    }
}
inline int spfa()
{
    for(int i=1;i<=T;++i)dis[i]=-INF;
    t=h=0;dis[S]=0;q[++t]=S;vis[S]=1;in[S]=INF;
    while(h++<t)
    {
        int x=q[h];vis[x]=0;
        for(int i=lin[x];i;i=nex[i])
        {
            int tn=ver[i];
            if(!e[i])continue;
            if(dis[tn]<dis[x]+e1[i])
            {
                dis[tn]=dis[x]+e1[i];
                in[tn]=min(in[x],e[i]);
                pre[tn]=i;
                if(!vis[tn])q[++t]=tn,vis[tn]=1;
            }
        }
    }
    return dis[T]!=-INF;
}
inline void EK()
{
    while(spfa())
    {
        int x=T,i=pre[x];
        sum+=in[T]*dis[T];
        while(x!=S)
        {
            e[i]-=in[T];
            e[i^1]+=in[T];
            x=ver[i^1];i=pre[x];
        }
    }
}
int main()
{
    //freopen("1.in","r",stdin);
    n=read();k=read();
    for(int i=1;i<=n;++i)
    {
        l[i]=read(),r[i]=read();
        if(l[i]>r[i])swap(l[i],r[i]);
        b[++top]=l[i],b[++top]=r[i];
    }
    discrete();
    S=cnt+1;T=S+1;
    for(int i=1;i<=cnt;++i)
    {
        if(i==1)add(S,i,k,0);
        if(i==cnt)add(i,T,k,0),add(i-1,i,k,0);
        if(i!=1&&i!=cnt)add(i-1,i,k,0);
    }
    for(int i=1;i<=n;++i)add(l[i],r[i],1,c[r[i]]-c[l[i]]);
    EK();put(sum);
    return 0;
}

```
~~撒花~~~


---

## 作者：xuxinyu (赞：21)

建模方法一：

 ![](https://cdn.luogu.com.cn/upload/pic/12259.png) 

建模方法二：

 ![](https://cdn.luogu.com.cn/upload/pic/12260.png) 

代码链接：

http://www.cnblogs.com/TheRoadToTheGold/p/8080899.html


---

## 作者：stdlifg (赞：18)

**    所有点向下一个点连容量为k费用为0的边

l和r连容量为1费用为区间长度的边

然后跑最大流最大费用流

(最大费用就是把边权取相反数跑最小费用

最后再输出最终费用的相反数)

原因
你想要费用尽量大

因为i->i+1费用为0

只有l->r有费用

而且费用为区间长度

所以跑最大费用也就是求最长区间**

    
    
    
    
```cpp
    #include <algorithm>
    #include <iostream>
    #include <cstring>
    #include <cstdio>
    #include <vector>
    #include <queue>
    #define ul unsigned long long
    #define rg register int
    #define ll long long
    #define il inline
    #define INF 2147483647
    #define SZ 10000000
    using namespace std;
    int n,N,k,s,t,a[SZ],l[SZ],r[SZ];
```
/\*
N : 原数组大小

n : 离散化之后的数组大小

a[] : 离散数组

k : 可重迭数

l , r 所给区间左端点和右端点

\*/
```cpp
    struct Edge{int to,nxt,w,c;}e[SZ];
    int Ehead[SZ],pv[SZ],pe[SZ],Ecnt=2;
    il void Eadd(int u,int v,int w,int cost)
    {
        e[Ecnt]=(Edge){v,Ehead[u],w,cost};
        Ehead[u]=Ecnt++;
        e[Ecnt]=(Edge){u,Ehead[v],0,-cost};
        Ehead[v]=Ecnt++;
    }
```
/\*
加边函数

pv[i] : spfa时使得i点dis值松弛的节点

(最短路的上一节点)

pe[i] : i与pv[i]连接的边

e[i].w : 流量

e[i].c : 费用

\*/
        
```cpp
    // 费用流板子 '_'↓↓↓
    ll dis[SZ];
    int vis[SZ];
    queue <int> Q;
    bool spfa()
    {
        memset(dis,63,sizeof(dis));
        dis[s]=0; Q.push(s);
        while(!Q.empty())
        {
            rg u=Q.front();
            Q.pop();
            for(rg i=Ehead[u];i;i=e[i].nxt)
            {
                rg v=e[i].to;
                if((e[i].w)&&(dis[v]>dis[u]+e[i].c))
                {
                    dis[v]=dis[u]+e[i].c;
                    pe[v]=i;
                    pv[v]=u;
                    if(!vis[v])
                    {
                        vis[v]=1;
                        Q.push(v);
                    }
                }
            }
            vis[u]=0;
        }    
        return dis[t]<dis[0];
    }
    il void costflow()
    {
        ll Ans=0;
        while(spfa())
        {
            rg di=INF;
            for(rg i=t;i!=s;i=pv[i])
             di=min(di,e[pe[i]].w);
            for(rg i=t;i!=s;i=pv[i])
            {
                e[pe[i]].w-=di;
                e[pe[i]^1].w+=di;
                Ans+=1ll*di*e[pe[i]].c;
            }
        }
        printf("%lld",-Ans);
    }
    // 费用流板子 '_'↑↑↑
    int main()
    {
        scanf("%d%d",&N,&k);
        for(rg i=1;i<=N;++i)
        {
            scanf("%d%d",&l[i],&r[i]);
            if(l[i]>r[i]) swap(l[i],r[i]);
            a[i]=l[i];a[i+N]=r[i];
        }
        sort(a+1,a+N+N+1);
        n=unique(a+1,a+N+N+1)-a-1;
        for(rg i=1;i<=N;++i)
        {
            rg L=lower_bound(a+1,a+n+1,l[i])-a;
            rg R=lower_bound(a+1,a+n+1,r[i])-a;
            Eadd(L,R,1,l[i]-r[i]);
        }
```
/\*
利用unique和lower\_bound离散化

原理是把输入到l[i]与r[i]出现的所有数字

排完序后利用unique去重

注意那些+1-1什么的

\*/
```cpp
        for(rg i=1;i<n;++i)
         Eadd(i,i+1,INF,0);
        s=n+1;t=n+2;
        Eadd(s,1,k,0);
        Eadd(n,t,k,0);
        costflow();
        while(1);
        return 0;
}
```

---

## 作者：lgswdn_SA (赞：16)

UPD on 8/14： 把线性规划那部分内容的锅修了。

---
我稍微说一下我对这道题目的理解吧。

我们考虑这个数轴（即区间要覆盖的东西），其中每个点都需要满足自己被覆盖不超过 $k$ 次。但是这是个非常静态的东西，不大适合用网络流去模拟。我们把这个问题“动态化”。

怎么动态呢？我们可以考虑可以看成不断地加入区间然后叠加起来。首先，我们看到每个点的 $k$ 限制类似于容量，于是我们考虑拆点，点容量转化为边容量。每一个区间加入进来，即水流从源点流到 $l$ 来，然后再从 $r$ 离开，即流向汇点，以上非常好理解，不过是不能做的，因为离散化后这个代价不好算，而且还不能保证每一个流进来的 $l$ 一定从自己对应的 $r$ 流出去。不过这个方法对后面的解法有很大的帮助和启发。我们放一下图。

![image.png](https://i.loli.net/2020/08/08/WdTOae3rU9jVCSP.png)

上面拆点和把 $k$ 设为容量的思路正解还可以用。

其中每种颜色的流入和流出对应一个区间。

既然叠加不行，**我们反过来，考虑从 $k$ 中剥离**。什么叫剥离呢？我们形象化一下，把这道题想象成有 $k$ 个人和 $m$ 个任务，每个任务的时间的开区间为  $l,r$。那么我们肯定是这样安排的，第 $l$ 时间来一个人，然后第 $r+1$ 时间再还回来，然后给你 $len$ 的收益。这样的话一切就好做很多了。其中人数我们转化成容量，然后从中拿一个人出来然后第 $r+1$ 分钟换回来这个操作转化成从 $l$ 到 $r+1$ 的边。上图对应的此种解法的图如下。

![image.png](https://i.loli.net/2020/08/08/hMT1aZ8P5WjpFn4.png)  
（很形象了吧 qwq）

然后对于每个区间代表的边，费用为 len，其他边费用为 0，跑一遍最大费用最大流即可。注意要离散化。

我个人觉得有一些网络流问题的流量去形象化可以有更好的理解和思路，因为网络流本身就是一个这样的过程（这个单位的水流应该往哪里走）。有时候把网络流问题去代数化是个非常好的选择，但是有些时候反其道而行之去形象化说不定会有更好的思路和理解呢~。

复杂度的话，点数 $O(n)$，边数 $O(n)$，流量是 $k$，所以理论复杂度还是 $O(n^2k)$，实际复杂度是网络流的玄学复杂度。

---

上面提到了把网络流代数化是个很好的选择，那么我这里再放一个基于线性规划的网络流推导吧。（不想看的可以直接跳过看代码）。

设 $p_i$ 为数轴上第 $i$ 处被几个线段覆盖，$x_i$ 为第 $i$ 个区间选不选，$z_{i,j}$ 表示第 $i$ 个区间覆不覆盖第 $j$ 个点。

$$
p_1=\sum x_i\times z_{i,1} \le k
$$
$$
p_2=\sum x_i\times z_{i,2} \le k
$$
$$
...
$$
$$
p_n=\sum x_i\times z_{i,n} \le k
$$

不等式转化为等式。

$$
p_1=(\sum x_i\times z_{i,1})+y_1 = k
$$
$$
p_2=(\sum x_i\times z_{i,2})+y_2 = k
$$
$$
...
$$
$$
p_n=(\sum x_i\times z_{i,n})+y_n = k
$$

其中 $y$ 的范围是 $0\le y\le k$。

整个方程中对于不同的 $z$ 每个变量出现次数不一致，我们考虑上下两项做差分。（套路）

$$
p_1-p_0=(\sum x_i\times z_{i,1})+y_1 = k
$$
$$
p_2-p_1=(\sum x_i\times (z_{i,2}-z_{i,1}))-y_1+y_2=0
$$
$$
...
$$
$$
p_{n+1}-p_{n}=(\sum x_i\times -z_{i,n})-y_n = -k
$$

这样对于每个 $i$，$x_i\times z_{i,j}$ 不为 $0$ 当且仅当 $i=$ 区间的左端点或右端点，且一正一负。

线性规划方程转换为网络流建边大致方法是，常数项和源汇连边，系数正代表流出，系数负代表流入。

于是我们得到建边

- 对于常数项 $k$ 和 $-k$，$S\to 1,c=k; n+1\to T, c=k$。
- 对于 $y$，$i\to i+1, c=k$。
- 对于 $x$ 和 $z$，$s_i\to t_i+1, c=1$。

考虑题目求的目标函数最小值，于是最小费用最大流即可。

---
 
$\downarrow\texttt{Finally, the code that you want.} \downarrow$

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2009,inf=0x3f3f3f3f;
typedef pair<int,int>pii;

struct Edge{int to,nxt,c,w;}e[N*2]; int hd[N],tot=1;
void add(int u,int v,int c,int w){e[++tot]=(Edge){v,hd[u],c,w};hd[u]=tot;}
void addh(int u,int v,int c,int w){add(u,v,c,w),add(v,u,0,-w);}

int n,k,s,t,mflow,cost,tmp;
int d[N]; bool in[N]; 
bool spfa(){ 
	queue<int>q; q.push(s); memset(d,0,sizeof(d)); d[s]=1;
	while(!q.empty()) {
		int u=q.front(); q.pop(); in[u]=0;
		for(int i=hd[u],v;i;i=e[i].nxt)
			if(e[i].c&&d[v=e[i].to]<d[u]+e[i].w) {
				d[v]=d[u]+e[i].w;
				if(!in[v]) q.push(v),in[v]=1;
			}
	}
	return d[t]>0;
}
int dinic(int u,int flow) {
	int rest=flow; if(u==t) return flow; in[u]=1;
	for(int i=hd[u],v;i&&rest;i=e[i].nxt)
		if(!in[v=e[i].to]&&e[i].c&&d[v]==d[u]+e[i].w) {
			int used=dinic(v,min(e[i].c,rest));
			if(!used) d[v]=-1;
			rest-=used, e[i].c-=used, e[i^1].c+=used, cost+=used*e[i].w;
		}
	in[u]=0;
	return flow-rest;
}
pii flow(int ret=0,int tmp=0) {
	while(spfa()) while(tmp=dinic(s,inf)) ret+=tmp;
	return make_pair(ret,cost);
}
//上面为最大费用最大流MCMF模板 

struct Interval {int l,r,len;}a[N]; 
struct Num {int id,lr,val;}num[N]; int cnum;
bool cmp(const Num &a,const Num &b) {
	return a.val<b.val;
}

int main() {
	scanf("%d%d",&n,&k);
	for(int i=1;i<=n;i++) {
		scanf("%d%d",&a[i].l,&a[i].r); a[i].len=a[i].r-a[i].l;
		num[i]=(Num){i,0,a[i].l}, num[i+n]=(Num){i,1,a[i].r};
	} 
	sort(num+1,num+2*n+1,cmp);
	for(int i=1;i<=n;i++) {
		scanf("%d%d",&a[i].l,&a[i].r);
		if(a[i].l>a[i].r) swap(a[i].l,a[i].r);
		a[i].len=a[i].r-a[i].l;
		num[i]=(Num){i,0,a[i].l}, num[i+n]=(Num){i,1,a[i].r};
	}
	//上面为读入+离散化 
	s=cnum+1, t=cnum+2;
	for(int i=1;i<cnum;i++) addh(i,i+1,k,0);
	addh(s,1,k,0), addh(cnum,t,k,0);
	for(int i=1;i<=n;i++)
		addh(a[i].l,a[i].r,1,a[i].len);
	//上面为建边 
	printf("%d",flow().second);
	return 0;
}
```

---

## 作者：bztMinamoto (赞：10)

因为一个zz错误调了一个早上……汇点写错了……spfa也写错了……

楼上大佬们说的都挺清楚了……我就来讲讲为什么这样是对的吧……

做法：把数轴上的每一个点向它右边的点连一条边，容量为$k$，费用为$0$，然后把每一个区间的左端点向右端点连边，容量为$1$，费用为区间长度，然后求一个最大费用最大流。因为坐标太大，记得离散

然而并不是很明白为什么这样做是对的……想了想，把网络流当成一个水流好了，水从左流到右，那么如果是在一个区间内，不可能满流（因为被区间左端点至右端点那一条边给分去了一部分流），但是被分去的那一部分流会在区间右端点被流回来，所以不想交的区间是没有影响的（因为是开区间，所以右端点和另一区间左端点重合并没有影响）。然后如果区间内还有其他区间的左端点，又会分流，一直这样下去，直到有超过$k$个区间覆盖了同一点，那样流就不够了，不会再分（因为从源点也只有$k$的流），那么只要求出了一个最大流，就是一个满足题目条件的方案。又因为要使长度最大，那么我们要让区间的流带上费用，求一个最大费用流即可

---

## 作者：mydiplomacy (赞：7)

【题意】
给出n个区间，每个区间权值为区间长度。求一种取区间的方案，使得每个数最多被取k次，且权值和最大。


【思路】
最小费用最大流。

连边方法：

i -> i+1,容量为k，费用为0

对每个区间，left -> right，容量为1，费用为-1*区间长度

（要求的是最大权值，故连负边）

跑mcf，输出最小费的相反数即可。



【优化】

用上面的算法可以得到63分。为什么会TLE最后四个点？


设想有一个区间是[1,10000000],那么我们的算法就需要连10000000条边，10000000个点。这会导致算法TLE

于是做一个离散化即可AC

【代码】

```cpp
#include<iostream>
#include <algorithm>
const int maxn=50005,maxm=500005,inf=1<<30;
using namespace std;
//邻接表存边
struct Node
{
    int v,c,w;
    Node *next,*rev;
}pool[maxm],*h[maxn],*pree[maxn];

int n,m,s,t,tot,src,sink;
int dis[maxn],q[maxn],prev[maxn];
bool vis[maxn];
int ls[maxm],lsh[maxn];
int Left[maxn],Right[maxn];
int pas[maxn];
int tots=0,totl=0;
//增加边
void addEdge(int u,int v,int c,int w)
{
//	cout<<u<<' '<<v<<' '<<c<<' '<<w<<endl;
    Node *p=&pool[++tot],*q=&pool[++tot];
    p->v=v; p->c=c; p->w=w; p->next=h[u]; p->rev=q; h[u]=p;
    q->v=u; q->c=0; q->w=-w; q->next=h[v]; q->rev=p; h[v]=q;
}
//最小费用最大流模板
bool spfa(){
    for(int i=1;i<maxn;i++) dis[i]=1<<30;
    for(int i=1;i<maxn;i++) vis[i]=0;
    int front=0,rear=0;
    vis[src]=1,dis[src]=0;
    q[rear++]=src;
    while(front<rear)
    {
        int u=q[front++];
        vis[u]=0;
        for(Node *p=h[u];p;p=p->next)
        {
            if(p->c>0 && dis[p->v]>dis[u]+p->w)
            {
                dis[p->v]=dis[u]+p->w;
                prev[p->v]=u;
                pree[p->v]=p;
                if(!vis[p->v])
                {
                    vis[p->v]=1;
                    q[rear++]=p->v;
                }
            }
        } 
    }
    if(dis[sink]<inf) return true;
    return false;
}

int augment(){
    int u=sink;
    int delta=inf;
    while(u!=src)
    {
        delta=min(delta,pree[u]->c);
        u=prev[u];
    }
    u=sink;
    while(u!=src)
    {
        pree[u]->c-=delta;
        pree[u]->rev->c+=delta;
        u=prev[u];
    }
    return delta;
}
int ans1, ans2;
void mincostflow()
{
    int delta=0;
    while(spfa()==true)
    {
        delta=augment();
        ans1+=delta;//最大流
        ans2+=delta*dis[sink];//最小费
    }
}

int main()
{
	int K;
	cin>>n>>K;
	for(int i=1;i<=n;i++)
	{
		cin>>Left[i]>>Right[i];
		ls[++tots]=Left[i];//离散化
		ls[++tots]=Right[i];
		pas[i]=Right[i]-Left[i];
	}
	sort(ls+1,ls+tots+1);
	for(int i=1;i<=tots;i++)
	{
		if(ls[i]!=ls[i-1]) lsh[++totl]=ls[i];//应该也可以用unique代替，但本人太蒟蒻不会库函数
	}
	//for(int i=1;i<=totl;i++)
	//{
	//	cout<<"match "<<i<<' '<<lsh[i]<<endl;//验证离散化正确性
	//}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=totl;j++)
		{
			if(Left[i]==lsh[j]) Left[i]=j;
			if(Right[i]==lsh[j]) Right[i]=j;
		}
	}
    //按上述方法建边，src为原点，sink为汇点
    src=0;
    for(int i=1;i<=n;i++)
    {
        sink=max(sink,Right[i]);
        addEdge(Left[i], Right[i], 1,-pas[i]);
    }
    for(int i=1;i<=sink-1;i++)
    {
        addEdge(i,i+1,K,0);
    }
    addEdge(src,1,K,0);
    addEdge(sink,sink+1,K,0);
    sink++;
    mincostflow();
    cout<<-1*ans2<<endl;//记得最后取相反数
    return 0;
}
```

done

---

## 作者：Tony_Wong (赞：6)

思路和[花姐的](https://www.luogu.com.cn/blog/pks-LOVING/solution-p3358)一样,提供一张比较好看的图

样例的建图:
![](https://cdn.luogu.com.cn/upload/image_hosting/3n6bgyda.png)

[我的博客-题解原文](https://tony031218.github.io/2020/04/21/%E3%80%8C%E7%BD%91%E7%BB%9C%E6%B5%8124%E9%A2%98%E3%80%8D%E6%9C%80%E9%95%BFk%E5%8F%AF%E9%87%8D%E5%8C%BA%E9%97%B4%E9%9B%86%E9%97%AE%E9%A2%98-%E9%A2%98%E8%A7%A3/)

## 题目大意
给定一个开区间的集合$\mathbf{I}$,从$\mathbf{I}$中取出一些开区间,组成集合$\mathbf{S}$

使对于任何一个$x$,满足$\mathbf{S}$中包含$x$的区间数不超过$k$,且$\mathbf{S}$中开区间总长度最大

求最大的长度

## 题解
如果两个区间没有重叠的话,则可以同时选择,在图上表现为串联

如果两个区间有重叠的话,则不能同时选择,在图上表现为并联(服从总流量的约束)

先对所有节点进行离散化,注意离散化前统计出区间的长

1. 从 源点 向 节点1 接一条 **流量为$k$,费用为$0$** 的边(最大流量为k,对答案无贡献)
2. 从 每个节点$i$ 向 节点$i+1$ 接一条 **流量为$inf$,费用为$0$** 的边(可以随意通过,对答案无贡献)
3. 从 最后一个节点 向 汇点 接一条 **流量为$inf$,费用为$0$** 的边(总流量有1.控制,对答案无贡献)(可以包含在2.里)
4. 从 每个区间的左端点 向 其右端点 接一条 **流量为$1$,费用为区间长** 的边(只可用一次,对答案贡献为区间长度)

求出最大费用最大流,最大费用即为最终的结果

## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;

inline int read() {
    int x = 0; int f = 1; char ch = getchar();
    while (!isdigit(ch)) {if (ch == '-') f = -1; ch = getchar();}
    while (isdigit(ch))  {x = x * 10 + ch - 48; ch = getchar();}
    return x * f;
}

const int maxn = 2010;
const int inf  = 0x3f3f3f3f;
const int ninf = 0xc0c0c0c0;

int n, m, s, t, ansflow;
int vis[maxn], d[maxn], p[maxn], a[maxn];
long long anscost;

struct Edge {
	int from, to, cap, flow, cost;
	Edge(int u, int v, int c, int f, int w): from(u), to(v), cap(c), flow(f), cost(w){}
};
vector<Edge> edges;
vector<int> G[maxn];
void add(int u, int v, int c, int w) {
	edges.push_back(Edge(u, v, c, 0, w));
	edges.push_back(Edge(v, u, 0, 0,-w));
	int mm = edges.size();
	G[u].push_back(mm - 2);
	G[v].push_back(mm - 1);
}

bool BellmanFord(int& flow, long long& cost) {
    memset(d, 0xc0, sizeof(d));
	memset(vis, 0, sizeof(vis));
	d[s] = 0; vis[s] = 1; p[s] = 0; a[s] = inf;
	queue<int> Q;
	Q.push(s);
	while (!Q.empty()) {
		int x = Q.front(); Q.pop();
		vis[x] = 0;
		for (int i = 0; i < G[x].size(); ++i) {
			Edge& e = edges[G[x][i]];
			if (e.cap > e.flow && d[e.to] < d[x] + e.cost) {
				d[e.to] = d[x] + e.cost;
				p[e.to] = G[x][i];
				a[e.to] = min(a[x], e.cap - e.flow);
				if (!vis[e.to]) {
					Q.push(e.to);
					vis[e.to] = 1;
				}
			}
		}
	}
	if (d[t] == ninf) return false;
	flow += a[t];
	cost += (long long)d[t] * (long long)a[t];
	for (int u = t; u != s; u = edges[p[u]].from) {
		edges[p[u]].flow += a[t];
		edges[p[u] ^ 1].flow -= a[t];
	}
	return true;
}

int MaxCostMaxFlow(long long& cost) {
	int flow = 0; cost = 0;
	while (BellmanFord(flow, cost));
	return flow;
}

struct Interval {
    int l, r, len;
}inter[510];
int nums[1020], old[1020];

int main() {
    int n_ = read(), k = read();
    for (int i = 1; i <= n_; ++i) {
        inter[i].l = read(); inter[i].r = read();
        inter[i].len = inter[i].r - inter[i].l;
        nums[i * 2 - 1] = inter[i].l;
        nums[i * 2] = inter[i].r;
    }
    
    // 离散化
    for (int i = 1; i <= n_ * 2; ++i) old[i] = nums[i];
    sort(old + 1, old + 1 + n_ * 2);
    int len = unique(old + 1, old + 1 + n_ * 2) - old - 1;
    for (int i = 1; i <= n_ * 2; ++i) nums[i] = lower_bound(old + 1, old + 1 + len, nums[i]) - old;
    for (int i = 1; i <= n_; ++i) {
        inter[i].l = nums[i * 2 - 1];
        inter[i].r = nums[i * 2];
    }
    
    s = 0; n = len + 2; t = n - 1;
    add(s, 1, k, 0);  // 建边1.
    for (int i = 1; i <= len; ++i) {
        add(i, i + 1, inf, 0); // 建边2.3.
    }
    for (int i = 1; i <= n_; ++i) {
        add(inter[i].l, inter[i].r, 1, inter[i].len); //建边4.
    }
    ansflow = MaxCostMaxFlow(anscost);
    printf("%d\n", anscost);
    return 0;
}
```

---

## 作者：Adove (赞：6)

这题我用类似暴力的方法~~吸氧1376ms~~过了。

https://www.luogu.org/record/show?rid=6275933

思路：分层图最长路dfs+剪枝。

对于这n个区间，我们将其按左端点为关键字排序，复制k份，分为k层。

对于**不重叠的两段区间**，从左边区间连到同层右边的区间，边权为右边区间长；并从右边区间连到下层左边区间同位置的区间，边权为左边区间长

对于**重叠的两段区间**，点数过多时不连边，否则从左边连向下一层的右边区间，边权为右边线段长。

最后，另起源点s，连向第一层的各段区间，边权为各段区间长。

跑一遍分层图最长路，注意**选过的区间不能再选**。

上代码↓

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;

const int INF=2e9;

int n,k,s,np,ans;
int h[1500005],ln[1500005],q[1500005];
bool boom[5005];
struct lint{
	int l,r;
}line[5005];
struct rpg{
	int li,nx,ln;
}a[1500005];

inline void add(int ls,int nx,int ln){
	a[++np]=(rpg){h[ls],nx,ln};
	h[ls]=np;
}

bool cmp(lint a,lint b){
	return a.l<b.l;
}

void dfs(int x){
	for(register int i=h[x];i;i=a[i].li){
		if(!boom[a[i].nx%n]&&ln[a[i].nx]<ln[x]+a[i].ln){
			ln[a[i].nx]=ln[x]+a[i].ln;
			boom[a[i].nx%n]=1;
			dfs(a[i].nx);
			boom[a[i].nx%n]=0;
		}
	}
}

int main(){
	scanf("%d%d",&n,&k);
	for(register int i=1;i<=n;++i){
		scanf("%d%d",&line[i].l,&line[i].r);
	}sort(line+1,line+n+1,cmp);
	for(register int i=1;i<=n;++i){
		add(s,i,line[i].r-line[i].l);
	}
	for(int l=0;l<k;++l){
		for(register int i=1;i<n;++i){
			for(int j=i+1;j<=n;++j){
				if(i!=j){
					if(line[i].r<=line[j].l){
						add(i+n*l,j+n*l,line[j].r-line[j].l);
						add(j+n*l,i+n*(l+1),line[i].r-line[i].l);
					}else if(n<400){
						add(i+n*l,j+n*(l+1),line[j].r-line[j].l);
					}
				}
			}
		}
	}dfs(s);
	for(register int i=n*(k-1);i<=n*k;++i)
		ans=max(ln[i],ans);
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：ZPC2048 (赞：5)

这题的题解怎么清一色的都是离散化连距离的...蒟蒻前来贡献一发另类思路的费用流解法QWQ

考虑用最小路径覆盖的思路解这道题。将每个区间抽象成一条线段（~~这不就是[P3357 最长k可重线段集问题](https://www.luogu.org/problemnew/show/P3357)么~~）然后把线段的集合分层，每层的线段集合中的线段互不相交，总共最多叠$k$层，求最大收益。可以证明放第$i$层时，其中的线段一定与前$i-1$层有相交部分。

### 证明：费用流采用的是最短路，每次寻找到的一条路径一定是当前情况下的最大收益，如果放第$i$层时有线段和前$i-1$层不相交，则在前$i-1$的某层放置这条线段可以在该层取得更大的收益，这与最短路算法矛盾，证毕。~~（感觉好像很奇怪的样子）~~

这样“贪心”地找到最后第$k$层，得到收益一定最大。（到这里思路说完了，有兴趣的大佬们可以自行思考实现问题）

考虑代码实现。将线段缩成点并拆成**两个点$x_{i}$和$y_{i}$**。
- 超级源点向$S$（这个点不是超级源点，只是个中转站，负责限流，其实要不要无所谓~~当时我脑抽了~~）连接$flow=k,cost=0$的边
- 从$S$向$x_{i}$连$flow=1,cost=0$的边
- $x_{i}$向$y_{i}$连$flow=1,cost=-length_{i}$的边
- $y_{i}$向与自己不相交的$x_{j}$连边（记住两两之间只需要其中一个连就行了，即不要出现$y_{i}$连了$x_{j}$之后，$y_{j}$又连$x_{i}$的情况，这二者等价，防止出现负环）
- $y_{i}$向超级汇点连$flow=k,cost=0$的边

最后跑费用流就好了。

```cpp
#include<cstdio>
#include<cstring>
#include<cmath>
#include<queue>
#include<algorithm>

using namespace std;

const int MAXN = 500 + 20;
const int MAXE = MAXN * 200;
const int INF = 0x3f3f3f3f;

struct Segment {
    int l, r, length;
    Segment(int l = 0, int r = 0, int length = 0) :
        l(l), r(r), length(length) {};
    bool operator < (const Segment &A) const {
        return l == A.l ? r < A.r : l < A.l;
    }
}I[MAXN];

struct Edge {
    int bg, ed, nxt, flow, cost;
    Edge(int bg = 0, int ed = 0, int nxt = 0, int flow = 0, int cost = 0) :
        bg(bg), ed(ed), nxt(nxt), flow(flow), cost(cost) {};
};

struct Map {
    Edge edge[MAXE];
    int head[MAXN << 1], count = 1;
    inline void insert(int bg, int ed, int flow, int cost) {
        edge[++count] = Edge(bg, ed, head[bg], flow, cost);
        head[bg] = count;
        edge[++count] = Edge(ed, bg, head[ed], 0, -cost);
        head[ed] = count;
    }
}A;

int dis[MAXN << 1], pre[MAXN << 1][3];//node edge flow
bool vis[MAXN << 1];

bool bfs(int s, int t) {
    memset(dis, 0x3f, sizeof(dis));
    memset(pre, 0, sizeof(pre));
    memset(vis, false, sizeof(vis));
    queue<int> que;
    que.push(s);
    dis[s] = 0;
    pre[s][2] = INF;
    while (!que.empty()) {
        int now = que.front();
        que.pop();
        vis[now] = false;
        for (int i = A.head[now]; i; i = A.edge[i].nxt) {
            int v = A.edge[i].ed;
            if (dis[v] > dis[now] + A.edge[i].cost && A.edge[i].flow) {
                dis[v] = dis[now] + A.edge[i].cost;
                pre[v][0] = now;
                pre[v][1] = i;
                pre[v][2] = min(pre[now][2], A.edge[i].flow);
                if (!vis[v]) {
                    que.push(v);
                    vis[v] = true;
                }
            }
        }
    }
    return dis[t] != INF;
}

int EK(int s, int t) {
    int ans = 0;
    while (bfs(s, t)) {
        int now = t, change = pre[t][2];
        while (pre[now][0]) {
            int e = pre[now][1];
            A.edge[e].flow -= change;
            A.edge[e ^ 1].flow += change;
            now = pre[now][0];
        }
        ans += change * dis[t];
    }
    return ans;
}

int main() {
    int n, k, x0, x1, s, S, T;
    scanf("%d%d", &n, &k);
    s = n * 2 + 1; S = s + 1; T = S + 1;
    for (int i = 1; i <= n; ++i) {
        scanf("%d%d", &x0, &x1);
        I[i] = Segment(min(x0, x1), max(x0, x1), abs(x1 - x0));//听说有可能出现x0>x1?
    }
    sort(I + 1, I + n + 1);//脑子抽了的产物
    A.insert(S, s, k, 0);
    for (int i = 1; i <= n; ++i) {
        A.insert(i, i + n, 1, -I[i].length);
        A.insert(s, i, 1, 0);
        A.insert(i + n, T, 1, 0);
        for (int j = i + 1; j <= n; ++j) {//一定要防止重复连边（j=i+1）
            if (I[i].r <= I[j].l || I[i].l >= I[j].r) {
                A.insert(i + n, j, 1, 0);
            }
        }
    }
    printf("%d\n", -EK(S, T));//记得取负
}
```


---

## 作者：diqiuyi (赞：0)

怎么题解区都是 flow，没有人写 dp 吗？

设 $f_{i,j,k}$ 表示当前位置还没有到达右端点的 $3$ 个区间分别为 $i,j,k$ 时答案的最大值。那么我们扫到一个区间的左端点时，就把用没它的状态更新有它的状态，到右端点就用有它的状态更新没它的状态，转移是不难的。

每个端点处只会涉及到 $O(n^{k-1})$ 个状态，所以复杂度是 $O(n^k)$ 的。由于空间限制比较小，需要进行卡常，令 $i\le j \le k$ 就可以有 $\dfrac{1}{6}$ 的空间常数，可以通过。
```cpp
#include <bits/stdc++.h>
#define ll long long	 
using namespace std;
int n,k,tot,len[505],id[505];
vector<pair<int,int> > v[100005];
vector<int> f[505][505];//这里的存的其实是 i,j-i,k-j
int main(){
	ios::sync_with_stdio(0),cin.tie(0);
	cin>>n>>k;
	for(int i=1,l,r;i<=n;i++) cin>>l>>r,len[i]=r-l,v[l].push_back({1,i}),v[r].push_back({-1,i});
	for(int i=0;i<=n;i++)
		for(int j=(!i?0:1);j<n-i;j++)
			f[i][j].resize(n-i-j+2);
	for(int i=1;i<=100000;i++){
		sort(v[i].begin(),v[i].end());
		for(auto x:v[i])
			if(x.first==1){
				id[x.second]=++tot;
				f[0][0][tot]=f[0][0][0]+len[x.second];
				if(k>1)
					for(int i=1;i<tot;i++)
						f[0][i][tot-i]=f[0][0][i]+len[x.second];
				if(k>2)
					for(int i=1;i+1<tot;i++)
						for(int j=1;i+j<tot;j++)
							f[i][j][tot-i-j]=f[0][i][j]+len[x.second];
			}
			else{
				int I=id[x.second];
				f[0][0][0]=max(f[0][0][0],f[0][0][I]);
				if(k>1)
					for(int i=1;i<=tot;i++)
						if(i^I)
							f[0][0][i]=max(f[0][0][i],I>i?f[0][i][I-i]:f[0][I][i-I]);
				if(k>2)
					for(int i=1;i<tot;i++)
						if(i!=I)
							for(int j=1;i+j<=tot;j++)
								if(i+j!=I)
									f[0][i][j]=max(f[0][i][j],(I<i?f[I][i-I][j]:I<i+j?f[i][I-i][j+i-I]:f[i][j][I-i-j]));
			}
	}
	int ans=0;
	for(int i=0;i<=n;i++)
		for(int j=(!i?0:1);j<n-i;j++)
			for(int k=(!j?0:1);i+j+k<=n;k++)
				ans=max(ans,f[i][j][k]);
	cout<<ans<<'\n';
	return 0;
}
```

---

## 作者：issue_is_fw (赞：0)

这个问题想通了也确实不难

**问题:把区间看成一个点不好处理点权,所以要转化为边权**

首先把区间拆成左端点和右端点,左右端点的边流量1,费用区间长度

这个应该不难理解,每个区间只能选一次嘛,价值是长度

<br/>

**问题:每个点不能有超过k个区间覆盖**

**其实就是我们同一时间的流量不能大于k**

就是说,从源点到汇点流的过程中,任意时刻不能同时在k条路径上走

否则就是同一个区域内选了k个区间,这是不满足的

我选了某个区间,直到这个区间的右端点,我已经把流量分出1了

这个时候流量还剩k-1,在达到那个右端点之前,我最多能选k-1个区间

比如对于(1,5),(8,9),(2,10)来说,图大概这个样子

![](https://img-blog.csdnimg.cn/2020081912092738.png)
假如从1流到5了,如果k=1,那么没有流量从1流到2之后了

假如从1留到5了,k=2,那么还有1的流量可以继续往后流到2

那么到2了因为还有流量1,所以可以选择从2流到10,也就是选择(2,10)

当然也可以从2流到5,之后再做选择。

**具体连边**

**所有坐标离散化,左边的点连向右边的点,流量k,边权0**

**对于每个区间,左端点连向右端点,流量1,边权为区间长度**

```
#include <bits/stdc++.h>
using namespace std;
const int inf=1e9;
const int maxn=2e5+10;
int n,k,li[maxn],ri[maxn],b[maxn],top,s,t,flow[maxn];
struct edge{
	int to,nxt,flow,w;
}d[maxn]; int head[maxn],cnt=1;
void add(int u,int v,int flow,int w){
	d[++cnt]=(edge){v,head[u],flow,w},head[u]=cnt;
	d[++cnt]=(edge){u,head[v],0,-w},head[v]=cnt;
}
int dis[maxn],vis[maxn],pre[maxn];
bool spfa()
{
	queue<int>q;
	for(int i=0;i<=t;i++)	dis[i]=-inf,vis[i]=0;
	q.push(s),dis[s]=0;
	flow[s]=inf;
	while( !q.empty() )
	{
		int u=q.front(); q.pop();
		vis[u]=0;
		for(int i=head[u];i;i=d[i].nxt )
		{
			int v=d[i].to;
			if( dis[v]<dis[u]+d[i].w&&d[i].flow )
			{
				dis[v]=dis[u]+d[i].w;
				if( !vis[v] )	vis[v]=1,q.push(v);
				flow[v]=min( flow[u],d[i].flow );
				pre[v]=i;
			}
		}
	}
	if( dis[t]==-inf )	return false;
	return true;
}
int dinic()
{
	int maxflow=0,mincost=0;
	while( spfa() )
	{
		int x=t;
		maxflow+=flow[t],mincost+=flow[t]*dis[t];
		while( x!=s )
		{
			int i=pre[x];
			d[i].flow-=flow[t];
			d[i^1].flow+=flow[t];
			x=d[i^1].to;
		}
	}
	return mincost;
}
int main()
{
	cin >> n >> k;
	for(int i=1;i<=n;i++)
	{
		++top; cin >> b[top];
		++top; cin >> b[top];
		li[i]=b[top-1],ri[i]=b[top];
	}
	sort(b+1,b+1+top);
	top=unique(b+1,b+1+top)-b-1;
	s=0,t=top+1;
	for(int i=1;i<=n;i++)
	{
		int len=ri[i]-li[i];
		li[i]=lower_bound( b+1,b+1+top,li[i] )-b;
		ri[i]=lower_bound( b+1,b+1+top,ri[i] )-b;
		add( li[i],ri[i],1,len);
	}
	for(int i=0;i<t;i++)	add(i,i+1,k,0);
	cout << dinic();
}
```

---

## 作者：_Sein (赞：0)

### 最长k可重区间集问题

题意可以转化为对于任意一个点，最多被覆盖 $k$ 次，相信这个大家都没什么问题吧？

那么现在我们就是出于如何构建出图的阶段了。

也就是我们要选择一个区间 $(l,r)$ ，也就意味着我们要覆盖区间 $(l,r)$ 内所有的点一次(不含端点)，如何快速表达这个东西。

我们不妨以 $\sum\limits _{(u,v)\in E}flow(u,v)$ 表示 $v$ 点(不含源汇)的 **未覆盖次数** ，那么一开始我们有 $(i,i+1)$ 容量为 $k$ 的初始边，费用为 $0$ ， 表示最多被覆盖 $k$ 次。

接着表达出上面这个东西 

> 我们要选择一个区间 $(l,r)$ ，也就意味着我们要覆盖区间 $(l,r)$ 内所有的点一次(不含端点)，如何快速表达这个东西。

也就是说我们可以通过这样一条边，使得网络流中 $l+1,l+2,\cdots,r-1$ 这些经过这些点的流量减一，进而表示出它们被覆盖一次，于是我们建 $(l,r)$ 一条容量为 $1$ ，表示只能选一次， 费用为 $r-l$， 如果经过这条边，就表示选择了这个区间。

最后跑最大费用最大流就可以了。

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <cmath>
#include <cstdlib>
#include <vector>

using namespace std;

const int N = 2005;

struct edge { int y, c, w, next; } a[N << 1]; int len, last[N];
struct node { int l, r, c; } seg[N]; int arr[N], siz;

void ins(int x, int y, int c, int w) { 
	a[++len] = (edge) { y, c, w, last[x] }; last[x] = len;
	a[++len] = (edge) { x, 0, -w, last[y] }; last[y] = len;
}

int q[N << 2], d[N], f[N], S, T, prv[N], ans; bool v[N];

bool spfa() {
	memset(d, 0xcfcfcfcf, sizeof d); memset(f, 0, sizeof f);
	d[S] = 0; f[S] = 0x3f3f3f3f; int l = 1, r = 0; v[q[++r] = S] = 1;
	for (int x = q[l]; l <= r; x = q[++l]) {
		v[x] = 0; for (int k = last[x], y; k; k = a[k].next) {
			if (d[y = a[k].y] < d[x] + a[k].w && a[k].c) {
				d[y] = d[x] + a[k].w; f[y] = min(f[x], a[k].c);
				if (!v[y]) v[q[++r] = y] = 1; prv[y] = k;
			}
		}
	}
	return f[T] > 0;			
}	

void upd() {
	ans += f[T] * d[T]; int k = prv[T];
	while (k) {
		a[k].c -= f[T]; 
		a[k ^ 1].c += f[T];
		k = prv[a[k ^ 1].y];
	}
}

int get(int x) {
	int l = 1, r = siz;
	while (l < r) {
		int mid = l + r >> 1;
		if (arr[mid] < x) l = mid +1;
		else r = mid;
	}
	return l;
}

int main() {
	len = 1; memset(last, 0, sizeof last);
	siz = 0;
	int n, m; scanf("%d%d", &n, &m);
	for (int i = 1, l, r; i <= n; ++i) {
		scanf("%d%d", &l, &r);
		seg[i].l = l; seg[i].r = r; seg[i].c = r - l;
		arr[++siz] = l; arr[++siz] = r;
	}
	
	sort(arr + 1, arr + siz +1); int cnt = 0;
	for (int i = 1; i <= siz; ++i) if (i == 1 || arr[i - 1] != arr[i]) arr[++cnt] = arr[i];
	siz = cnt; for (int i = 1; i <= n; ++i) seg[i].l = get(seg[i].l), seg[i].r = get(seg[i].r);
	
	S = 0; T = siz + 1;
	for (int i = 0; i < T; ++i) ins(i, i + 1, m, 0);
	for (int i = 1; i <= n; ++i) ins(seg[i].l, seg[i].r, 1, seg[i].c);
	
	ans = 0;
	while (spfa()) upd();
	printf("%d\n", ans); 
	return 0;
}
```

---


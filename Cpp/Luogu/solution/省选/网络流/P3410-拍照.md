# 拍照

## 题目描述

小 B 有 $N$ 个下属，现小 B 要带着一些下属让别人拍照。

有 $M$ 个人，每个人都愿意付给小 B 一定钱来和 $N$ 个下属中的一些人进行合影。如果这一些下属没带齐那么就不能拍照，小 B 也不会得到钱。

注意：带下属不是白带的！！！对于每个下属，如果他带了那么小 B 需要给他一些钱，保证当他拍照时配合。

## 说明/提示

对于 $10\%$ 的数据每个人都要求让全部 $N$ 个人合影。

对于 $30\%$ 的数据 $N, M\le 15$。

另有 $10\%$ 的数据答案为 $0$。

对于 $50\%$ 的数据 $N, M\le 40$。

另有 $10\%$ 的数据每个人只愿意拍一个人。

对于 $100\%$ 的数据 $1\leq N, M\le100$，费用是 $[1, 5\times 10^8]$ 间的整数。

## 样例 #1

### 输入

```
2 3
10 1 2 0
25 2 3 0
5 6 7```

### 输出

```
17```

# 题解

## 作者：Rachel_in (赞：37)

介绍一下闭合图的概念，闭合图是建立在有向图上的，就是对于一个集合内每个点，它能达到的所有点都在这个集合里面。

对于样例：
```
输入
2 3
10 1 2 0
25 2 3 0
5 6 7

输出
17
```
我们构成的图为：
![](https://cdn.luogu.com.cn/upload/pic/59707.png)

对于最大权值闭合图，我们需要用**最小割**来做。

我们重新构图：
![](https://cdn.luogu.com.cn/upload/pic/59708.png)

**前置结论**：最大权值=闭合图的正权值之和-最小割

**理解边的含义**：

我们做的最小割一定不会切到无穷大的边，所以割里的边都是$S->u$或者$u->T$。

**对于割掉一个$S->u$的边含义为在闭合图中不选择$u$这个点,对于割掉一个$u->T$的边含义为在闭合图中选择$u$这个点。**

(注意：这里边的含义很难去想它为什么要这么定义的时候，先看下去，之后会明白的)

举个例子：我们在网络流那张图里割去权值为10,5,7这些边，含义为不选择要求1，选择1,3这些点，也就是一共选择要求2,1,3这三个点，这不是一个闭合图，因为2这个点没选。然后我们发现网络流里有非0流的，不是割，**也就是说如果选择的不是网络流的割，那么选到的点集必定不是闭合图**。

证明：如果$S$与$T$连通，则存在点$u$,$v$，使得$S$到$u$有边，$u$到$v$连通，$v$到$T$有边，所以$v$一定是$u$的后继，但选择了$u$，没有选择$v$，不是闭合子图。

**得出结论：只有$S$与$T$不连通时，才能得到闭合子图。**


于是我们要求出的是割，至于要将答案最大化：

最小割=不选的$S$到$u$的边权和+选择的$u$到$S$的边权和

闭合图最大权值=全部正权点之和-不选的正权点之和+选择的负权点之和

加上选择的负权点之和就相当于减去选择的负权点的绝对值之和，也就是选择的$u$到$S$的边权和

所以:

**闭合图最大权值=全部正权点之和-不选的$S$到$u$的边权和-选择的$u$到$S$的边权和**

也就是：

**闭合图最大权值=全部正权点之和-最小割**

应该可以理解边的含义了吧

[部分参考博客](https://blog.csdn.net/can919/article/details/77603353)

**代码**：

```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read(){
	int res=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-f;ch=getchar();}
	while(ch>='0'&&ch<='9'){res=(res<<3)+(res<<1)+ch-'0';ch=getchar();}	
	return res*f;
}
const int N=255;
const int M=40555;
const int inf=1e7;
int S,T,n,m,fir[N],cur[N],dep[N],nxt[M],go[M],val[M],cnt=1,maxflow,ans;
queue<int> Q;
inline void Add(int u,int v,int w){
	nxt[++cnt]=fir[u];
	fir[u]=cnt;
	go[cnt]=v;
	val[cnt]=w;
}
inline bool bfs(){
	for(int i=S;i<=T;i++) dep[i]=-1;
	dep[S]=0;
	Q.push(S);
	while(!Q.empty()){
		int u=Q.front();Q.pop();
		for(int e=fir[u];e;e=nxt[e]){
			int v=go[e];	
			if(dep[v]==-1&&val[e]>0){
				dep[v]=dep[u]+1;	
				Q.push(v);
			}			
		}		
	}
	if(dep[T]==-1) return 0;
	else return 1;
}
int dfs(int u,int flow){
	if(u==T) return flow;
	for(int &e=cur[u];e;e=nxt[e]){
		int v=go[e];	
		if(dep[v]==dep[u]+1&&val[e]>0){
			int f=dfs(v,min(flow,val[e]));
			if(f>0){
				val[e]-=f;val[e^1]+=f;	
				return f;
			}			
		}	
	}
	return 0;
}
void Dinic(){
	while(bfs()){
		for(int i=S;i<=T;i++) cur[i]=fir[i];		
		while(int d=dfs(S,inf)){
			maxflow+=d;
		}
	}
}
int main(){
	m=read();n=read();
	S=0;T=m+n+1;
	for(int i=1;i<=m;i++){
		int w=read();	
		ans+=w;
		Add(S,i,w);Add(i,S,0);
		int x=read();
		while(x){
			Add(i,m+x,inf);Add(m+x,i,0);
			x=read();
		}
	}	
	for(int i=1;i<=n;i++){
		int w=read();
		Add(m+i,T,w);Add(T,m+i,0);
	}
	Dinic();
	printf("%d",ans-maxflow);
	return 0;
}
```


---

## 作者：iotang (赞：6)

这个题就是求一个**最大权闭合图**

那么最大权闭合图是什么鬼？我尝试着讲简单一点……

在一个图中，一些点构成一个集合，且集合中的出边指向的终点也在这个集合中，则我们称这个集合为闭合图。

整个图中点的权值之和最大的闭合图，为最大权闭合图。

最大权闭合图可以用**网络流**来求

造出一个超级源点S和一个超级汇点T，把S连边到所有带有正权的点上，容量是这个点的权；把所有带负权的点连边到T，容量是这个点的权的相反数。原来的边呢，把它们的容量都设成无限大。

之后我们跑一遍最大流。

答案就是图中的**所有正权值之和减去最小割容量**。


大家都知道，最大流的值是最小割的容量。

想象一下，这个图中的最小割也对应了一个权闭合图，因为这里的最小割一定不会包含容量是无限大的边和与S相连的边。

而为什么所有正权值之和减去最小割容量就是答案呢？

设某个割的对应的闭合图的权值是ans，容量是cut；

那么**ans+cut=所有正权点的权值之和**；

要使ans最大，那么cnt要最小。

cnt最小的情况就是最小割啦

求出来的ans就是最大权闭合图的权啦


本人代码变量名非常奇特，大家凑合看一下吧

这里是写的大法师版的ISAP，代码量~~压行压到~~仅1K出头，编程复杂度贼小，速度还不慢(0ms)，很有性价比

```cpp
//by iot
#include<bits/stdc++.h>
using namespace std;
inline int gotcha()
{
    register int a=0,b=1,c=getchar();
    while(!isdigit(c))b^=c=='-',c=getchar();
    while(isdigit(c))a=(a<<3)+(a<<1)+c-48,c=getchar();
    return b?a:-a;
}
const int _ = 204 , __ = 10202<<1 , $ = 100 , inf = 0x3f3f3f3f;
int to[__],ne[__],v[__],he[_],ecnt=1;
void adde(int a,int b,int c){to[++ecnt]=b,v[ecnt]=c,ne[ecnt]=he[a],he[a]=ecnt;}
int n,m,S=201,T=202,gap[_]={0},dis[_]={0};
int dfs(int d,int flw)
{
    if(d==T || flw==0)return flw;
    int i,w,mid=n-1,los=flw;
    for(i=he[d];i;i=ne[i])
        if(v[i]>0)
        {
            if(dis[d]==dis[to[i]]+1)
            {
                w=dfs(to[i],min(los,v[i])),v[i]-=w,v[i^1]+=w,los-=w;
                if(dis[S]>=n)return flw-los;if(!los)break;
            }
            mid=min(mid,dis[to[i]]);
        }
    if(flw==los){if(!(--gap[dis[d]]))dis[S]=n;dis[d]=mid+1,gap[dis[d]]++;}
    return flw-los;
}
int isap(){register int ans=0;gap[1]=n;while(dis[S]<n)ans+=dfs(S,inf);return ans;}
int main()
{
    register int i,j,k,a,b,sum=0;
    m=gotcha(),n=gotcha();
    for(i=1;i<=m;i++)
    {
        a=gotcha(),adde(S,i,a),adde(i,S,0),sum+=a;
        for(a=gotcha();a!=0;a=gotcha())adde(i,a+$,inf),adde(a+$,i,0);
    }
    for(i=1;i<=n;i++)a=gotcha(),adde(i+$,T,a),adde(T,i+$,0);n=_;
    printf("%d\n",sum-isap());
    return 0;
}
```

---

## 作者：arfa (赞：5)

图片来自于 [$Hi\ Ho$](https://www.cnblogs.com/TreeDream/p/5942354.html)。

简化一下题面 : 

- 一些人要拍照,拍照要一些 小 $B$ 的下属一起拍,拍完了这些人会给小 $B$ 钱。
- 给了一个下属的钱就可以让他拍很多次照片。
- 求小 $B$ 的纯利润 (最大)。

很显然样例中可以全部人都拍,全部下属都给钱。 很显然这是一个**最大权闭合子图**问题。

先说一说什么是权闭合子图:

![](https://cdn.luogu.com.cn/upload/pic/40625.png)

这里有的权闭合子图有 $(3).(4).(2,4).(3,4).(1,3,4).(2,3,4).(1,2,3,4)$。我们在一个图中可以选一些点,形成一个集合 $V$,但是要保证**这些点所连 (有向边) 到的点也要在 $V$ 里面**。所以很显然 $(1)$ 不是权闭合子图因为 $3,4$ 没有进入。

很显然这种图可以用二分图展示:

![](https://cdn.luogu.com.cn/upload/pic/40628.png)

其中我们可以浅浅的理解,哪些点要哪些点。而如果我们建立了一个超汇的话,就可以知道 **如果我们把让所有 $B$点连超汇,流量为所付的钱, $A$点连超源,流量为给的钱** ,那么我们就可以直接求 **最大权闭合子图** 了。因为我们流一条超源向 $A$ 点的边就等于给他拍照拿他钱,而流 $B$ 点向超汇的就是付给他钱 (而且仅仅一次,因为只流一次)。那么 $A$ 向 $B$ 边的流量就可以设置为 $inf$。

但是要知道结论: 最大权闭合子图的权值等于所有正权点之和减去最小割。(其中最小割等于最大流)

我们就跑一遍最大流就好啦。

(没想到连 _ 也可以当变量 $qwq$)

```pascal
// luogu-judger-enable-o2
Uses math;

Const _=100;

var
    value,reach,next:array[-1..50000] of longint;
    gap,dis,cnt:array[-1..50000] of longint;
    i,l,r,n,m,source,sink,sum,tot,ans:longint;
    maxflow:int64;

procedure add(l,r,sum:longint);
begin
    inc(tot);
    reach[tot]:=r;
    value[tot]:=sum;
    next[tot]:=cnt[l];
    cnt[l]:=tot;
end;

function Dfs(now,flow:longint):longint;
var i,k,mindis,ret:longint;
begin
    mindis:=n-1; ret:=flow;
    if now=sink then exit(flow);
    i:=cnt[now];
    while i<>-1 do
    begin
        if value[i]>0 then
        begin
            if dis[now]=dis[reach[i]]+1 then
            begin
                k:=Dfs(reach[i],min(ret,value[i]));
                dec(value[i],k); inc(value[i xor 1],k);
                dec(ret,k);
                if dis[source]>=n then exit(flow-ret);
                if ret=0 then break;
            end;
            mindis:=min(mindis,dis[reach[i]]);
        end;
        i:=next[i];
    end;
    if ret=flow then
    begin
        dec(gap[dis[now]]);
        if gap[dis[now]]=0 then dis[source]:=n;
        dis[now]:=mindis+1;
        inc(gap[dis[now]]);
    end;
    exit(flow-ret);
end;

begin
    filldword(cnt,sizeof(cnt) div 4,maxlongint*2+1); tot:=1;
    read(m,n); source:=0; sink:=n+m+1; 
    for i:=1 to m do
    begin
        read(l); inc(sum,l); add(source,i,l); add(i,source,0); read(l);
        while l<>0 do begin add(i,l+_,maxlongint div 843); add(l+_,i,0); read(l); end;
    end;
    for i:=1 to n do begin read(l); add(i+_,sink,l); add(sink,i+_,0); end;

    n:=n+m+_+1; gap[source]:=n;
    while dis[source]<n do inc(maxflow,Dfs(source,maxlongint div 842));

    writeln(sum-maxflow);
end.
```



---

## 作者：Naoxiaoyu (赞：3)

# 思路
思考这道题，直接用最大流难以解决问题，不妨换个思路。\
我们将初始状态设为不计带这些下属所需费用情况下，带所有下属拍照方案赚取费用之和，设为 $t$。\
对于每个方案，如果我们选择要带这些下属，那么就要从 $t$ 中减去带这些下属要花的费用，如果我们选择不带这些下属，则需要减去这些下属带来的收益，即这些下属可以赚的费用。

现在，我们成功将原问题转化为**求出最小的每个下属选或不选产生的代价，再用总拍照赚取费用 $t$ 减去这个最小代价**，这样即可求出我们想要的最大收益。

所有，原先的问题就被转换为最小割问题，具体可参考下方内容。

# 建图及实现
- 首先，建一个超级源点和一个超级汇点，将源点和所有方案连边，容量为方案产生的收益。
- 然后，将所有方案带他所需要带的下属连边，容量为无限。
- 最后，将每个下属和汇点连边，容量为带这个下属所需的费用。

最小割问题即是割掉一些边，使源点的水无法流到汇点，求割掉的边的最小容量。

根据最大流最小割定理，我们知道**最小割等于最大流**。

因为方案和下属之间的边容量为无限，所以最小割不可能割掉两者之间的边，被割掉的只能是源点与方案之间的边和下属与汇点之间的边，正好契合刚才的思路。**当一遍最小割跑完之后，每个方案要么舍弃了赚取的收益，要么付出了赚取收益的代价，也就是带某些下属所需的费用**。

解法显而易见，在图中跑一遍最大流，再用初始状态的总赚取费用减去即可。

# AC code
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int inf=0x3f3f3f3f;
int m,n,s,t;
int ans=0;
int a[110],b[110];
struct Edge{
	int to,net,val;
}e[300010];
int h[300010],tot=1;
int dis[300010],now[300010];
void add(int u,int v,int w)
{
	e[++tot].to=v;
	e[tot].net=h[u];
	e[tot].val=w;
	h[u]=tot;
	
	e[++tot].to=u;
	e[tot].net=h[v];
	e[tot].val=0;
	h[v]=tot;
}
bool bfs()
{
	for(int i=0;i<=t;i++)
	{
		dis[i]=inf;
	}
	dis[s]=0;
	queue<int> q;
	q.push(s);
	now[s]=h[s];
	while(!q.empty())
	{
		int x=q.front();
		q.pop();
		for(int i=h[x];i;i=e[i].net)
		{
			int y=e[i].to;
			if(e[i].val&&dis[y]==inf)
			{
				dis[y]=dis[x]+1;
				q.push(y);
				now[y]=h[y];
				if(y==t) return 1;
			}
		}
	}
	return 0;
}
int dfs(int x,int flow)
{
	if(x==t) return flow;
	int k,res=0;
	for(int i=now[x];i;i=e[i].net)
	{
		now[x]=i;
		int y=e[i].to;
		if(dis[y]==dis[x]+1&&e[i].val)
		{
			k=dfs(y,min(flow,e[i].val));
			e[i].val-=k;
			e[i^1].val+=k;
			res+=k;
			flow-=k;
		}
	}
	return res;
}
int main()
{
	scanf("%d%d",&m,&n);
	s=0,t=n+m+1;
	int sum=0;
	for(int i=1;i<=m;i++)
	{
		scanf("%d",&a[i]);
		add(s,i,a[i]);
		sum+=a[i];
		int x;
		while(scanf("%d",&x))
		{
			if(x==0) break;
			add(i,m+x,inf);
		}
	}
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&b[i]);
		add(m+i,t,b[i]);
	}
	while(bfs())
	{
		ans+=dfs(s,inf);
	}
	printf("%d\n",sum-ans);
	return 0;
}
```

---

## 作者：Long·J·William (赞：3)

思路：最大权闭合子图

m个请求与s连边，权值为方案价值；

n个员工与t连边，权值为员工花费；

方案与牵扯到的员工连边，权值为inf；

然后跑最大流，总流量就是最优方案的总花费；

然后，总收益=总价值-总花费。


代码实现：

```cpp
 1 #include<cstdio>
 2 #include<cstring>
 3 #define inf 1000000
 4 #define maxn 300
 5 #define maxm 300000
 6 int n,m,s,t,tw,tot;
 7 int a,b,c;
 8 int d[maxn],q[maxn],head,tail;
 9 int h[maxn],hs=1;
10 struct edge{int s,n,w;}e[maxm];
11 inline int min(int x,int y){return x<y?x:y;}
12 void add(int q,int z,int w){
13     e[++hs]=(edge){z,h[q],w},h[q]=hs;
14     e[++hs]=(edge){q,h[z]},h[z]=hs;
15 }
16 void bfs(){
17     memset(d,0,sizeof(d));
18     head=tail=0;
19     q[head++]=s,d[s]=1;
20     while(head>tail){
21         a=q[tail++];
22         for(int i=h[a];i;i=e[i].n)
23         if(!d[e[i].s]&&e[i].w){
24             d[e[i].s]=d[a]+1;
25             if(e[i].s==t) return;
26             q[head++]=e[i].s;
27         }
28     }
29 }
30 int ap(int k,int w){
31     if(k==t) return w;
32     int uw=w;
33     for(int i=h[k];i&&uw;i=e[i].n)
34     if(e[i].w&&d[e[i].s]==d[k]+1){
35         int nw=ap(e[i].s,min(uw,e[i].w));
36         if(nw) e[i].w-=nw,e[i^1].w+=nw,uw-=nw;
37         else d[e[i].s]=0;
38     }
39     return w-uw;
40 }
41 void Dinic(){while(bfs(),d[t]) tw+=ap(s,inf);}
42 int main(){
43     scanf("%d%d",&m,&n);
44     s=0,t=n+m+1;
45     for(int i=1;i<=m;i++){
46         scanf("%d",&a);
47         tot+=a;
48         add(s,i,a);
49         while(scanf("%d",&a)&&a) add(i,a+m,inf);
50     }
51     for(int i=1;i<=n;i++) scanf("%d",&a),add(i+m,t,a);
52     Dinic();
53     printf("%d\n",tot-tw);
54     return 0;
55 }
博客原址：http://www.cnblogs.com/J-william/p/6596496.html
```

---

## 作者：Engulf (赞：2)

在本题中，我们可以发现，选择了一个要求 $q_i$，那么 $q_i$ 所有需要的点都必须选择，不然无法获得收益。

那这显然可以转换为网络流的一个经典问题：**最大权值闭合图**。

最大权值闭合图是**最小割**的一个问题模型，参见 [OI Wiki - 最小割](https://oi-wiki.org/graph/flow/min-cut/#2)。

### 定义

> 最大权值闭合图，即给定一张有向图，每个点都有一个权值（可以为正或负或 $0$），你需要选择一个权值和最大的子图，使得子图中每个点的后继都在子图中。

_摘自 [OI Wiki - 最小割](https://oi-wiki.org/graph/flow/min-cut/#2)_。

符合本题的定义。

### 求出最大权值闭合图

可以使用最小割来求解该问题。

步骤：

1. 建立超级源点 $s$ 和超级汇点 $t$，所有**正权点**都连一条到 $s$ 的边，流量为点权；**负权点**都连一条到 $t$ 的边，流量为点权的**绝对值**，原图中的所有边权流量都赋值为 $+\infty$。
2. 求出网络的**最小割**。
3. 设原图正权点和为 $w$，答案就是 $w - c(s,t)_{\min}$。

证明：

1. 最大权值闭合图一定是一个**割**。反证法：若不是割，即 $s$ 和 $t$ 连通，即存在点 $(u,v)$，$s$ 连通 $u$，$v$ 连通 $t$，$u$ 连通 $v$，即 $v$ 是 $u$ 的后继，不符合最大权值闭合图的定义。
2. 割去的边必定和 $s$ 或 $t$ 连通。因为割要最小，不可能去割边权是 $+\infty$ 的边。
3. 割完之后的图，权值和 $=$ 所有正权值和 $-$ 不选择的正权点 $+$ 选择的负权点和。所有不选的点之和 $=$ 割掉的边流量之和 $=$ 最小割 $c(s,t)_{\min}$，上式转换为所有正权值和 $- c(s,t)_{\min}$。

_证明过程参考 [OI Wiki - 最小割](https://oi-wiki.org/graph/flow/min-cut/#2)_。

### Code

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 1e5 + 5, inf = 1 << 30;
int n, m, maxflow;
int s, t;
int flow[N], dep[N];
int ans;
struct edge
{
	int to, nxt;
}e[N << 1];
int head[N], idx = 1;
void add(int x, int y, int w)
{
	e[ ++ idx] = {y, head[x]}, head[x] = idx, flow[idx] = w;
	e[ ++ idx] = {x, head[y]}, head[y] = idx, flow[idx] = 0;
}
bool bfs()
{
	memset(dep, 0, sizeof dep);
	queue<int> q;
	q.push(s), dep[s] = 1;
	while (!q.empty())
	{
		int u = q.front(); q.pop();
		for (int i = head[u]; i; i = e[i].nxt)
		{
			int v = e[i].to;
			if (flow[i] && !dep[v])
			{
				dep[v] = dep[u] + 1;
				q.push(v);
			}
		}
	}
	return dep[t];
}
int dfs(int u, int in)
{
	if (u == t) return in;
	int out = 0;
	for (int i = head[u]; i && in; i = e[i].nxt)
	{
		int v = e[i].to;
		if (flow[i] && dep[v] == dep[u] + 1)
		{
			int fl = dfs(v, min(flow[i], in));
			flow[i] -= fl, flow[i ^ 1] += fl;
			in -= fl, out += fl;
		}
	}
	if (!out) dep[u] = 0;
	return out;
}

int main()
{
	scanf("%d%d", &m, &n);
	s = 0, t = 1 + m + n;
	for (int i = 1, w, x; i <= m; i ++ )
	{
		scanf("%d", &w), ans += w;
		add(s, i, w);
		while (scanf("%d", &x), x) add(i, x + m, inf);
	}
	for (int i = 1, x; i <= n; i ++ )
		scanf("%d", &x), add(i + m, t, x);
	while (bfs()) maxflow += dfs(s, inf);
	printf("%d\n", ans - maxflow);
	return 0;
}
```

---

## 作者：ker_xyxyxyx_xxs (赞：2)

[P3410 拍照](https://www.luogu.com.cn/problem/P3410)

最大权值闭合子图

使用总价值 $ - $ 最小割即可。

考虑最小割如何连边。

源点向每个人的要求连边，边权为拍照的价值。

每个人的要求向需要拍照的人连边，边权为 $ \infty $ 表示必须要在一起不能断开。

每个人向汇点连边，边权为让这个人拍照的花费。

最大流最小割定理求出最小割计算即可。

Code

```cpp
 # include <bits/stdc++.h>
using namespace std;

const int N = 1e6 + 5;
const int M = 2e6 + 5;
const int inf = 1e9; 

typedef struct {
	int x , y , z , next;
}Node;
Node edge[M];
int E = 1 , elast[N];
int S , T;

void add(int x , int y , int z) {
	E ++ , edge[E].x = x , edge[E].y = y , edge[E].z = z , edge[E].next = elast[x] , elast[x] = E;
}

int dis[N] , cnt[N];
void bfs(int start) {
    queue<int> q;
    q.push(start);
    dis[start] = 0;
    cnt[S] = 1;
    while (!q.empty()) {
        int cur = q.front();
        q.pop();
        for (int i = elast[cur] ; i ; i = edge[i].next) {
            int v = edge[i].y;
            if (dis[v] != -1) continue;
            dis[v] = dis[cur] + 1;
            q.push(v);
            cnt[dis[v]] ++;
        }
    }
}
int cur[N];
int dfs(int u , int flow) {
    if (u == T) return flow;
    int delta = 0;
    for (int i = cur[u] ; i ; i = edge[i].next) {
        cur[u] = i;
        int v = edge[i].y;
        if (edge[i].z > 0 && dis[u] == dis[v] + 1) {
            int temp = dfs(v , min(flow - delta , edge[i].z));
            edge[i].z -= temp;
            edge[i ^ 1].z += temp;
            delta += temp;
            if (delta == flow) return delta;
        }
    }
    if (dis[S] >= T + 1) return delta;
    cur[u] = elast[u];
    if (-- cnt[dis[u]] == 0) dis[S] = T + 1;
    cnt[++ dis[u]] ++;
    return delta;
}
int Isap() {
    int ans = 0;
    memset(cnt , 0 , sizeof cnt);
    memset(dis , -1 , sizeof dis);
    bfs(T);
    for (int i = 0 ; i <= T ; i ++) {
        cur[i] = elast[i];
    }
    while (dis[S] < T + 1) ans += dfs(S , inf);
    return ans;
}

int m , n , sum = 0;
int main() {
	cin >> m >> n;
    S = 0 , T = n + m + 1;
	for (int i = 1 ; i <= m ; i ++) {
		int x , y;
		cin >> x;
		sum += x;
		add(S , i , x) , add(i , S , 0);
		while (cin >> y && y != 0) add(i , m + y , inf) , add(m + y , i , 0); 
	}
	for (int i = 1 ; i <= n ; i ++) {
		int x;
		cin >> x;
		add(m + i , T , x) , add(T , m + i , 0);
	}
	cout << sum - Isap() << endl;
	return 0;
}
```

---

## 作者：wxwoo (赞：2)

[$$\color{#0e90d2}\huge{\texttt{my blog}}$$](https://wxwoo.github.io/2019/03/25/solution-p3410/)

******

[原题目链接](https://www.luogu.org/problemnew/show/P3410)

每张合影可选可不选，选了必须带一些特定人：~~明显的~~最大权闭合子图

最大权闭合子图：

> 给定一个有向图，点有点权，选择一个子图，满足子图上如果选择了一个点就必须选择它后继的所有点。最大化点权和。

经典的网络流问题，具体使用最小割求解。

根据*最大流最小割定理*，最大流=最小割，所以这题可以使用最大流算法求解

我们将合影和人都看成一个点，然后如下建边：

> 1. 源点向合影连流量为利润的边
>
> 1. 人向汇点连流量为花费的边
>
> 1. 每个合影向需要的人连流量为inf的边

接下来我们思考这样建边的正确性

在最小割模型中，连一条流量为$inf$的边意为连一条不可割边

那么这个图中的可割边就只有合影和人了

跑最大流（最小割）即为计算最优方案下的花费

最终答案（最大净利润）为全部合影能赚到的钱减去最小割

代码如下

```cpp
#include<cstdio>
#include<cstring>
using namespace std;
const int inf=1e9;
const int N=3e5+1;
struct edge
{
    int from,to,next,cap,flow;
}e[N];
int cnt,n,m,sour,sink,head[N],ans,q[N],l[N],p[N];
inline int min(int i,int j)
{
    return i<j?i:j;
}
inline void add(int u,int v,int l)
{
    e[++cnt]=(edge){u,v,head[u],l,0};
    head[u]=cnt;
    e[++cnt]=(edge){v,u,head[v],0,0};
    head[v]=cnt;
}
inline bool find()
{
    memset(l,0,sizeof(l));
    int h=1,t=1;
    q[1]=sour;
    l[sour]=1;
    while(h<=t)
    {
        int x=q[h++];
        for(int i=head[x];i;i=e[i].next)
            if(!l[e[i].to]&&e[i].cap>e[i].flow)
            {
                q[++t]=e[i].to;
                l[e[i].to]=l[x]+1;
                if(e[i].to==sink)
                    return true;
            }
    }
    return false;
}
int dfs(int x,int now)
{
    if(x==sink||!now)
        return now;
    int t=now,detla;
    for(int i=head[x];i;i=e[i].next)
    {
        if(e[i].cap>e[i].flow&&l[e[i].to]==l[x]+1)
        {
            detla=dfs(e[i].to,min(t,e[i].cap-e[i].flow));
            if(!detla)
                l[e[i].to]=0;
            e[i].flow+=detla;
            e[((i-1)^1)+1].flow-=detla;
            t-=detla;
            if(t==0)
                break;
        }
    }
    return now-t;
}
inline void dinic()
{
    while(find())
        ans+=dfs(sour,inf);
}
inline void read(int &x)
{
    char ch=getchar();
    int f=1;
    x=0;
    while(!('0'<=ch&&ch<='9'))
    {
        if(ch=='-')
            f=-1;
        ch=getchar();
    }
    do
    {
        x=(x<<3)+(x<<1)+ch-48;
        ch=getchar();
    }while('0'<=ch&&ch<='9');
    x*=f;
}
int main()
{
    read(m);
    read(n);
    int res=0;
    sour=0;
    sink=m+n+1;
    for(int i=1;i<=m;i++)
    {
        int val,x;
        read(val);
        res+=val;//计算总收益
        add(sour,i,val);
        read(x);
        while(x!=0)
        {
            add(i,x+m,inf);
            read(x);
        }
    }
    for(int i=m+1;i<=n+m;i++)
    {
        int val;
        read(val);
        add(i,sink,val);
    }
    dinic();
    printf("%d",res-ans);//ans即为总花费
    return 0;
}
```

> ~~双倍经验：[P2762 太空飞行计划问题](https://www.luogu.org/problemnew/show/P2762)，快去骗经验啊qwq~~

---

## 作者：CmsMartin (赞：1)

## 题意描述

[题目传送门](https://www.luogu.com.cn/problem/solution/P3410)

## 思路

这道题是一个经典的网络流模型：**最大权闭合子图**。

先说做法：

1. 新建原点 $s$ 与汇点 $t$；

2. 将 $s$ 与图中每一个正权点相连，权值为该正权点点权；

3. 将 $t$ 与图中每一个负权点相连，权值为该负权点点权的绝对值；

4. 根据输入连边，边权为 $\infty$。

最后，答案为正权点和 - 最大流。

下面给出证明：

设集合 $S$ 和集合 $T$ 是原图的 $s-t$ 割。

记 $w$ 为当前的收益 ， $Cnt$ 为当前的割。

则 $w = S_\text{正权和} - |S_\text{负权和}|$。

显然 $Cut = \text{正权和} - S_\text{正权和} + |S_\text{负权和}|$。

加起来就有：$w + Cut = \text{正权和}$。

移项得：$w = \text{正权和} - Cut$。

显然当 $Cut$ 取最小值（即最小割）时 $w$ 取最大值。

由最大流最小割定理得：$\max_w = \text{正权和} - \text{最大流}$。

证必。

知道了这一点，这道题就可以瞬切了。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

#define int long long

const int MAXN = 50010 , MAXM = 500010 , INF = 1 << 30;

int N , M;

int Head[MAXN * 4];
int Cnt = 1;
struct Edge {
    int Next , To;
    int Val;
} G[MAXM * 15];

void _add(int u , int v , int w) {
    G[++Cnt].To = v;
    G[Cnt].Val = w;
    G[Cnt].Next = Head[u];
    Head[u] = Cnt;
}

void Add(int a , int b , int c) {
    _add(a , b , c);
    _add(b , a , 0);
}

int Dep[MAXN * 4];
int Hash[MAXN * 4];

int S , T;
int Max_Flow;

void Bfs() {
    memset(Dep , -1 , sizeof Dep);
    memset(Hash , 0 , sizeof Hash);
    queue<int> q;
    q.push(T);
    Dep[T] = 0;
    while(!q.empty()) {
        int u = q.front();
        q.pop();
        for(int i = Head[u]; i; i = G[i].Next) {
            int v = G[i].To;
            if(Dep[v] != -1) continue;
            q.push(v);
            Dep[v] = Dep[u] + 1;
            Hash[Dep[v]]++;
        }
    }
}

int Dfs(int u , int flow) {
    if(u == T) {
        Max_Flow += flow;
        return flow;
    }
    int used = 0;
    for(int i = Head[u]; i; i = G[i].Next) {
        int v = G[i].To;
        if(G[i].Val && Dep[v] + 1 == Dep[u]) {
            int Min = Dfs(v , min(flow - used , G[i].Val));
            if(Min) {
                G[i].Val -= Min;
                G[i ^ 1].Val += Min;
                used += Min;
            }
            if(used == flow) {
                return used;
            }
        }
    }
    Hash[Dep[u]]--;
    if(Hash[Dep[u]] == 0) Dep[S] = N + M + 10;
    Dep[u]++;
    Hash[Dep[u]]++;
    return used;
}

int ISAP() {
    Max_Flow = 0;
    Bfs();
    while(Dep[S] < N + M + 10) Dfs(S , INF);
    return Max_Flow;
}

int Sum;

signed main() {
    scanf("%lld%lld" ,&N ,&M);

    S = 0;
    T = N + M + 1;

    for(int i = 1 , k , x; i <= N; i++) {
        scanf("%lld%lld" ,&k ,&x);
        Sum += k;
        Add(S , i , k);
        while(x) {
            Add(i , N + x , INF);
            scanf("%lld" ,&x);
        }
    }

    for(int i = 1 , k; i <= M; i++) {
        scanf("%lld" ,&k);
        Add(N + i , T , k);
    }

    printf("%lld\n" ,Sum - ISAP());

    return 0;
}
```

---

## 作者：智子 (赞：1)

## 题目分析

如果我们将要求拍照的人和下属之间按照要求关系连有向边，我们就会发现题目实际上是要求我们求出有向图的最大权闭合子图。即，在一张有向图上选择一个点集，要求点集中的每一个点的后继也都在这个点集中，使点集中点权和最大。

对于这类问题，有一个结论：**从源点向所有正权点连边，边权为原点权；从所有负权点向汇点连边，边权为原点权的绝对值；原图中的边权设为正无穷。则最大权闭合子图的权值和 = 所有正权点的权值和 - 新图的最小割。**

### 对结论的证明

我们先做如下约定：

1. 割掉源点与正权点 $u$ 之间的边，表示不选择点 $u$ 进入子图。
2. 割掉负权点 $v$ 与汇点之间的边，表示选择点 $v$ 进入子图。

则我们跑一遍最小割后得到的一定是闭合子图，证明如下：考虑任意得到的子图内的任意正权点 $u$，若存在其后继节点 $v$ 没有被选择进入子图，分为两种情况：如果 $v$ 权值为负，按照上述约定，点 $v$ 与汇点间的边会被保留，源点与汇点联通，与最小割的定义矛盾；如果 $v$ 权值为正，按照上述约定，源点与点 $v$ 间的边会被割掉，但点 $u$ 与点 $v$ 联通，不割掉源点与点 $v$ 间的边仍然是一个割，且权值和更小，与最小割的定义矛盾。

因为最大权闭合子图的权值和为：

被选的正权点权值和 - 被选的负权点权值和的绝对值

等价于 

所有正权点的权值和 - (不被选的正权点的权值和 + 被选的负权点权值和的绝对值)

而根据先前的约定，我们可以得到：

最小割 = 不被选的正权点的权值和 + 被选的负权点权值和的绝对值

所以

**最大权闭合子图的权值和 = 所有正权点的权值和 - 新图的最小割**

## 代码实现

因为最大流=最小割，所以跑一边最大流即可。笔者在这里选择使用 Dinic 算法来实现代码。

```cpp
#include<bits/stdc++.h>
using namespace std;

const int MAXN = 200 + 5;
const int MAXM = 1000000 + 5;
const int INF = INT_MAX;

queue<int> q;
int head[MAXN], to[MAXM], nxt[MAXM], flow[MAXM], cap[MAXM];
int tot = 1;
int dep[MAXN], cur[MAXN];
int m, n, s, t;

void addEdge(int u, int v, int c, int f) {
    tot++;
    to[tot] = v;
    nxt[tot] = head[u];
    flow[tot] = f;
    cap[tot] = c;
    head[u] = tot;
}

bool bfs() {
    memset(dep, 0, sizeof(dep));
    while(!q.empty()) q.pop();
    q.push(s);
    dep[s] = 1;
    while(!q.empty()) {
        int u = q.front(); q.pop();
        for(int i = head[u]; i != 0; i = nxt[i]) {
            if(cap[i] > flow[i] && dep[to[i]] == 0) {
                dep[to[i]] = dep[u] + 1;
                q.push(to[i]);
                if(to[i] == t) return true;
            }
        }
    }
    return false;
}

int dinic(int u, int f) {
    if(u == t || f == 0) {
        return f;
    }
    int rest = f;
    for(int& i = cur[u]; i != 0; i = nxt[i]) {
        if(cap[i] > flow[i] && dep[to[i]] == dep[u] + 1) {
            int k = dinic(to[i], min(rest, cap[i] - flow[i]));
            if(k == 0) {
                dep[to[i]] = 0;
            }
            flow[i] += k;
            flow[i ^ 1] -= k;
            rest -= k;
            if(rest == 0) break;
        }
    }
    return f - rest;
}

int main() {
    scanf("%d%d", &m, &n);
    s = m + n + 1;
    t = m + n + 2;
    int sum = 0;
    for(int i = 1; i <= m; i++) {
        int v, p;

        scanf("%d", &v);
        sum += v;
        addEdge(s, i, v, 0);
        addEdge(i, s, 0, 0);
        while(1) {
            scanf("%d", &p);
            if(p == 0) break;
            addEdge(i, p + m, INF, 0);
            addEdge(p + m, i, 0, 0);
        }
    }
    for(int i = 1; i <= n; i++) {
        int v;

        scanf("%d", &v);
        addEdge(i + m, t, v, 0);
        addEdge(t, i + m, 0, 0);
    }
    int maxflow = 0;
    while(bfs()) {
        memcpy(cur, head, sizeof(head));
        maxflow += dinic(s, INF);
    }
    printf("%d\n", sum - maxflow);

    return 0;
}

```


---

## 作者：_zuoqingyuan (赞：0)

这个东西好像叫最大权闭合子图？

# 思路分析

**闭合子图**定义如下：对于有向图 $G(V,E)$，存在点集 $S$，使得 $S\subseteq V$ 且对于任意 $(u,v)\in E,u\in S$，$v$ 也位于集合 $S$ 中，则称 $S$ 对应的子图为闭合子图。

**最大权闭合子图**定义如下：假设有向图内的每一个节点 $u$ 都拥有一个权值 $w_u$，最大化 $\sum_{u\in S}w_u$ 的值的闭合子图的点集 $S$ 即最大权闭合子图。

我们以本题样例为例：

我们将每个“拍照请求”和“下属”看成点。“拍照请求”对应的点的点权为拍照的人给出的酬劳，“下属”对应的点的点权为下属索要的**酬劳的相反数**。将每个“拍照请求”向对应的“下属”连有向边，得到一张点带权的有向图 $G$，**此时 $G$ 的任意闭合子图均为一种合法方案**，可自行模拟。

根据题意，我们要求出有向图 $G$ 的最大权闭合子图的点权和，通用的方法为最小割。

### 建模方法：

1. 建立超级源点 $s$ 和超级汇点 $t$。

2. 对所有正点权的点 $u$ 连有向边 $s\to u$，边权为 $u$ 的点权。

3. 对所有负点权的点 $v$ 连有向边 $v\to t$，边权为 $v$ 的**点权的相反数**。

4. 原有向图中节点正常连边 $u\to v$，边权为 $\infty$。

5. 答案即为**所有正点权之和减去最小割的值**。

### 正确性证明：

首先给出定义：

**简单割**：对于网络 $G(V,E)$ 中，如果存在边集 $E'\subseteq E$ 且删去 $E'$ 后 $s,t$ 不联通，则称 $E'$ 为一组简单割。

**最小割**：对于每条边 $(u,v)$，用 $c(u,v)$ 表示这条边的容量，最小化 $\sum_{(u,v)\in E'}c(u,v)$ 的简单割 $E'$ 即为最小割。

显然，最小割只会割去 $s\to u$ 或 $v\to t$ 这两种边（因为 $u\to v$ 边容量为 $\infty$，求的是最小割，割去显然不优）。对于点 $u$，我们认为割去 $s\to u$ 边等价于**不选择点** $u$。对于点 $v$，我们认为割去 $v\to t$ 边等价于**选择点** $v$（为什么这样解释可关注下文）。

>- 证明选择的方案合法：
>
>**我们思考那些方案是不合法的**：对于原有向图 $G(V,E)$，假设在求出最小割后，存在 $(u,v)\in E$ 且选择 $u$ 但没有选择 $v$，则方案不合法。
>
>这**等价于**保留 $s\to u$ 的同时也保留 $v\to t$。因为 $s\to u\to v\to t$ 路径上边的剩余容量均大于 $0$，则存在一条增广路，可以继续增广。因为此时已经求出了最小割，**显然和“最小割等于最大流定理”相矛盾**。
>
>故假设不成立，合法性显然。

---------

>- 证明选择的方案最优：
>
>对于**任意**简单割 $E$，我们令其**对应**的闭合子图为 $T$。
>
>$E$ 的容量和有两部分，分别是 $s\to u$ 的容量和（**等价于不选择的 $u$ 的权值和**）以及 $v\to t$ 的容量和（**等价于选择的 $v$ 的权值和的相反数**），记两者分别是 $w_1,-w_2$，$E$ 的容量和为 $W_E$。同理，我们也可以将 $T$ 分为两部分，分别是选择的正点权和以及选择的负点权和。分别记为 $w_3,w_2$，$T$ 的权值和为 $W_T$。
>
>我们将 $E,T$ 的容量和与权值和相加，得到 $W_E+W_T=w_1+w_3$，即为原有向图 $G$ 中所有正点权之和。故**任意一组简单割既其对应的闭合子图权值之和一定**。
>
>为了使 $W_T$ 部分尽可能大，必须令 $W_E$ 部分尽可能小，根据最小割定义，按照上述方式求得的方案最优性显然。

综上所属，可证的该算法的正确性。

# Code：

```cpp
#include <iostream>
#include <cstdio>
#include <queue>
using namespace std;
const int N=210,M=40205,inf=1e9+10;
int n,m,s,t,ver[N],to[M],val[M],nxt[M],idx=1,sum,d[N],now[N],mincut;
queue<int>q;
void add(int x,int y,int z){
	to[++idx]=y,nxt[idx]=ver[x],ver[x]=idx,val[idx]=z;
	to[++idx]=x,nxt[idx]=ver[y],ver[y]=idx,val[idx]=0;
}
bool bfs(){
	while(q.size())q.pop();
	for(int i=s;i<=t;i++)d[i]=0,now[i]=ver[i];
	d[s]=1,q.push(s);
	while(q.size()){
		int x=q.front();q.pop();
		for(int i=ver[x];i;i=nxt[i]){
			if(val[i]&&!d[to[i]]){
				d[to[i]]=d[x]+1,q.push(to[i]);
				if(to[i]==t)return 1;
			}
		}
	}
	return 0;
}
int dinic(int x,int flow){
	if(x==t||!flow)return flow;
	int used=0,f;
	for(int i=now[x];i;i=nxt[i]){
		now[x]=i;
		if(val[i]&&d[to[i]]==d[x]+1){
			f=dinic(to[i],min(val[i],flow-used));
			if(!f)d[to[i]]=0;
			else val[i]-=f,val[i^1]+=f,used+=f;
			if(used==flow)break;
		}
	}
	return used;
}
int main(){
	scanf("%d %d",&n,&m);
	s=0,t=n+m+1;
	for(int i=1,w;i<=n;i++){
		scanf("%d",&w);
		add(s,i,w),sum+=w;
		for(int x;scanf("%d",&x)&&x!=0;){
			add(i,n+x,inf);
		}
	}
	for(int i=1,w;i<=m;i++){
		scanf("%d",&w);
		add(n+i,t,w);
	}
	while(bfs())for(int flow;(flow=dinic(s,inf));)mincut+=flow;
	printf("%d\n",sum-mincut);
	return 0;
} 
```

引用：[浅谈网络流的各种建模方法 Part2.6 by strcmp](https://www.luogu.com.cn/article/k2hh2bok)。很好的文章，推荐看一看。

如有错误，请指出。

---

## 作者：lao_wang (赞：0)

大家在其他题解中看到的直接告诉你这个是什么类型的题目，用什么概念去求，让后就放代码，在这里我会用通俗易懂的话来讲这道题为什么这样建图。

读题可知一个事情，如果要使得可以让这个来拍照的人拍照只有两种可能性：

1. 给的钱已经大于了所需要的属下需要的钱。
2. 经过其他与之有交集（跟他有相同需要属下的人）的属下总共的和大于需要的属下总共需要的钱。

我们就可以将其题目转化成有 $M$ 个人他们可以给某些属下发钱，他们有 $N$ 个属下，其中每个属下想要的钱是固定的。我们可以让 $M$ 个人中任意个数的人给他们想发钱的属下（可以不发满）如果全部属下都不能再收钱那么就将钱给你，求在每个属下都发满的前提下你能得到多少钱。

这样的话，我们就只需要假设这 $M$ 个人都发钱，让后求每个人手上剩下的钱。这也就变成了求 $N$ 个属下可以得到多少钱，之后让 $M$ 个人能发的钱的总和减去 $N$ 个属下总共能得到的钱就是本题的答案。

所以我们就可以用网络流来求解，将源点与拍照的人相连，流量为他们给的钱，再将他们与他们所需要的属下相连，流量为无穷大，最后将属下连向汇点。跑一个最大流，让 $M$ 个人给的钱的总和减去最大流就为答案了。

## 代码
~~~cpp
#include<bits/stdc++.h>
#define int long long 
#define inf 2147483647
#define N 223 
using namespace std ;
int n , m , head[N] , now[N] , cnt=0 , s , t , dep[N] , ans=0 , sum=0 ;
bool f[N] ;
struct node{
	int to , next , w ;
}e[N<<12]; //谁会认真的算这个东西 
void newnet(int u,int v,int w){
	e[cnt].to = v ;
	e[cnt].w = w ;
	e[cnt].next = head[u] ;
	head[u] = cnt++ ;
}
bool bfs(){
	for(int i=1;i<=t;i++) dep[i] = inf , now[i] = head[i] , f[i] = 0 ;
	queue<int> q ;
	q.push(s) ;
	dep[s] = 0 ;
	while(!q.empty()){
		int u=q.front() ;
		q.pop() ;
		f[u] = 0 ;
		for(int i=head[u];~i;i=e[i].next){
			int x=e[i].to ;
			if(dep[u]+1<dep[x]&&e[i].w){
				dep[x] = dep[u]+1 ;
				if(!f[x]){
					f[x] = 1 ;
					q.push(x) ;
				}
			}
		}
	}
	return dep[t]!=inf ;
}
int dfs(int u,int sum){
	if(u==t) return sum ;
	int use=0 ;
	for(int i=now[u];~i;i=e[i].next){
		now[u] = i ;
		int x=e[i].to ;
		if(dep[x]!=dep[u]+1||!e[i].w) continue ;
		int temp=dfs(x,min(sum,e[i].w)) ;
		if(!temp) continue ;
		e[i].w -= temp ;
		e[i^1].w += temp ;
		use += temp ;
		if(use==sum) break ;
	}
	return use ;
}
void dinic(){
	while(bfs())
		ans += dfs(s,inf) ;
	cout << max(sum-ans,1ll*0) << endl ;
}
int read(){
	int x=0 , f=1 ;
	char a=getchar() ;
	while(!(a>='0'&&a<='9')){
		if(a=='-') f = -f ;
		a = getchar() ;
	}
	while(a>='0'&&a<='9'){
		x *= 10 ;
		x += a-'0' ;
		a = getchar() ;
	}
	return x ;
}
signed main(){
	memset(head,-1,sizeof(head)) ;
	cin >> m >> n ;
	s = n+m+1 ;
	t = s+1 ;
	for(int i=1;i<=m;i++){
		int c=read() , to ;
		sum += c ;
		newnet(s,i,c) ;
		newnet(i,s,0) ;
		while(to=read()){
			newnet(i,m+to,inf) ;
			newnet(m+to,i,0) ;
		}
	}
	for(int i=1;i<=n;i++){
		int c=read() ;
		newnet(i+m,t,c) ;
		newnet(t,i+m,0) ;
	}
	dinic() ;
	return 0 ;
}
~~~
~~在最后祝在谷CS2玩家能像我一样，哥本哈根胶囊一发出粉~~

---

## 作者：__ZTY__ (赞：0)

网络流的很好题目，在学完最大流最小割后就可以入手。

题面是很易懂的，没有简述的必要了。

这种问最大收益的网络流，很容易让人想到总收益和减最小割。

由于所用算法实在太好想，建图相对就显得很复杂。

看题目的描述，有 $n$ 个下属，$m$ 个人，这样就一眼二部图。

建立超级源点 $s$，超级汇点 $t$，其中 $n$ 个人连 $s$，$m$ 个下属连 $t$，中间根据联系再连一些边，模型就已经构思好了。

接下来思考其内核，既然已经想到最小割，那就看有什么是绝对不能割的。

当选择第 $i$ 个人时，想要获得其收益，就必须要选择所对应的下属，那么这里的边是不能割的，便将其置为 $inf$。

所以对于每个人，向其要求的下属连边，边权为 $inf$。

$s$ 向每个人连边，边权为其拍照的收益。

下属向 $t$ 连边，边权为下属的费用。

![](https://cdn.luogu.com.cn/upload/image_hosting/dpacnczd.png)

以上为样例情况，其最小割为 $18$，总收益为 $35$，符合输出。

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e5+9,inf=1<<30;
inline int read(){
	char c=getchar();
	int s=0,f=1;
	while(!isdigit(c)){if(c=='-'){f=-1;}c=getchar();}
	while(isdigit(c)){s=s*10+c-'0';c=getchar();}
	return s*f;
}
struct Edge{int to,next,w;}edge[N];
int cnt=1,head[N],cur[N];
inline void add(int u,int v,int w){
	edge[++cnt]=(Edge){v,head[u],w};
	head[u]=cnt;
}
int dep[N];int n,m,s,t;
inline bool bfs(){
	memset(dep,0,sizeof(dep));
	queue<int>q;
	q.push(s);dep[s]=1;
	memcpy(cur,head,sizeof(head));
	while(!q.empty()){
		int u=q.front();q.pop();
		for(int i=head[u];i;i=edge[i].next){
			int v=edge[i].to,w=edge[i].w;
			if(w>0&&!dep[v]){
				dep[v]=dep[u]+1;q.push(v);
			}
		}
	}
	return dep[t]!=0;
}
inline int dfs(int u,int flow){
	int rest=flow;
	if(u==t){return flow;}
	for(int i=cur[u];i&&rest;i=edge[i].next){
		cur[u]=i;
		int v=edge[i].to,w=edge[i].w;
		if(dep[v]==dep[u]+1&&w>0){
			int tmp=dfs(v,min(rest,w));
			rest-=tmp;
			edge[i].w-=tmp;
			edge[i^1].w+=tmp;
			if(!tmp){dep[v]=0;}
		}
	}
	return flow-rest;
}
inline int dinic(){
	int ans=0;
	while(bfs()){ans+=dfs(s,inf);}
	return ans;
}
signed main(){
	m=read();n=read();
    s=0;t=n+m+1;int sum=0;
	for(int i=1;i<=m;i++){
		int w=read();sum+=w;
		add(s,i,w);add(i,s,0);
		int x=read();
		while(x){
			add(i,m+x,inf);add(m+x,i,0);
			x=read();
		}
	}	
	for(int i=1;i<=n;i++){
		int w=read();
		add(m+i,t,w);add(t,m+i,0);
	}
	cout<<sum-dinic();
	return 0;
}

```


---

## 作者：_qingshu_ (赞：0)

# 题意：

小 B 有 $N$ 个下属。有 $M$ 个可能会拍照的人，每一个人如果拍了照就会支付给小 B 一定的钱，但是他会指定部分下属一起拍照。而携带下属是需要一定费用的，询问最大收益。

# 思路：

这是一个最大权值闭合图的问题，这里简单介绍一下概念：**在一个有向图中，用部分点构成一个集合，且该集合所有点的出边指向点也在该集合内**。而图中所有点点权和最大的一个闭合图称之为**最大权值闭合图**。

我们定义 $sum$ 为如果所有人都照了相且不考虑支出的情况下的和。

对于一个拍照的人来说我们如何使用网络流来分辨我们的最优抉择是否涵盖这个人呢？考虑将超级源向每个可能拍照的人连接一条流量为如果这个人拍照的支出，将每一个下属向超级汇连接一条流量为带这个下属的支出的边，最后在把每个拍照的人需求的下属连接一条无限流量的边。

就样例来说，图如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/tyyq35vv.png?x-oss-process=image/resize,m_lfit,h_1700,w_2250)

只看一个客户的话，如果我们选择这个客人拍照对于总收入是亏损的，那么我们可以理解为拿这个客人的钱去支付等值的一部分对应下属的需求（有下属可以不支付完，先交部分的钱）。那么我们一定会少赚这个人拍了照会给我们的钱，这个数值也是流量。

如果这个客人他拍了照之后支付的钱可以付得起带下属的钱，那么我们就把 $sum$ 减去带下属的钱表示花费了这么多钱带走了这几个下属，然后这两个下属到超级汇的边的流量为 $0$，~~表示之后的人可以白嫖~~。

对于多个客户一起支付同一个个下属的情况，就会用到先前说的预先支付，也就是说，即使之前并没有选择这个人拍照，但是流量的减少是实打实的，比如说样例中先处理完客户一的最优策略是把第一个下属支付完，第二个下属支付 $5$ 元，这个时候第二个下属只需要 $1$ 元就可以带走了，客户二给予的 $25$ 元支付第二个下属剩下的与第三个下属全部的费用是足够的。那么我们就把情况的理解认为两个客户都拍照了。

总体正确性来说，这个客户是否拍照的选择都是暂时的，如果最后没有人和他共同支付且总体是赚钱的，我们认为他不会被选，那么先前预先支付的钱我们本来就拿不到，所以是正确的。

# code:

```cpp
#include<bits/stdc++.h>
#define inf 2147483647
using namespace std;
int n,m,s,t,u,v;
long long w,ans,dis[520010];
int tot=1,now[520010],head[520010];
int k;
struct node{
	int to,net;
	long long val;
}e[520010];
inline void add(int u,int v,long long w){
	tot++;
	e[tot].to=v;
	e[tot].val=w;
	e[tot].net=head[u];
	head[u]=tot;
	tot++;
	e[tot].to=u;
	e[tot].val=0;
	e[tot].net=head[v];
	head[v]=tot;
}
int bfs(){
	for(int i=1;i<=90020;i++){
		dis[i]=inf;
	}
	queue<int>q;
	q.push(s);
	dis[s]=0;
	now[s]=head[s];
	while(!q.empty()){
		int x=q.front();
		q.pop();
		for(int i=head[x];i;i=e[i].net){
			int v=e[i].to;
			if(e[i].val>0&&dis[v]==inf){
				q.push(v);
				now[v]=head[v];
				dis[v]=dis[x]+1;
				if(v==t){
					return 1;
				}
			}
		}
	}
	return 0;
}
int dfs(int x,long long sum){
	if(x==t){
		return sum;
	}
	long long k,res=0;
	for(int i=now[x];i&&sum;i=e[i].net){
		now[x]=i;
		int v=e[i].to;
		if(e[i].val>0&&(dis[v]==dis[x]+1)){
			k=dfs(v,min(sum,e[i].val));
			if(k==0){
				dis[v]=inf;
			}
			e[i].val-=k;
			e[i^1].val+=k;
			res+=k;
			sum-=k;
		}
	}
	return res;
}
int sum;
int main(){
	cin>>m>>n;
	s=90001;
	t=90002;
	for(int i=1;i<=m;i++){
		cin>>k;
		sum+=k;
		add(s,i,k);
		while(cin>>k&&k){
			add(i,k+m,inf);
		}
	}
	for(int i=1;i<=n;i++){
		cin>>k;
		add(m+i,t,k);
	}
	while(bfs()){
		ans+=dfs(s,inf);
	}
	cout<<sum-ans;
}
```
update：

- 修改了 LaTeX。

- 修改了部分文笔混乱，再次修改了 LaTeX，如果依然有误恳请具体指出，感激不尽。

---

## 作者：sjr3065335594 (赞：0)

## 题意简述

求一个有向图的最大权闭合子图。

## 思路

我们建立一个超级源点 $S$ 和一个超级汇点 $T$，给每个要求与 $S$ 建边，每个下属与 $T$ 建边，边权分别为他们给的或者要的价钱（要的价钱就可建成负数边）。

接下来，如果我们在图上去掉一些边，意思是这些边上的下属或者要求就不选，如果这个图合法，那么就可以用这张图上的所有边权之和更新答案。

这张图合不合法主要看其是不是一张闭合图，这里给出方法：**在 $S$ 和 $T$ 不连通的时候，这张图就是一张闭合图**。

那我们要把下属与 $T$ 之间的边变成正的，如果删掉这条边才代表选这个点，我们就考虑给每个要求和其需要的下属建一条边权为正无穷的边，直接求出这张图的最小割再用所有要求的价值总和减去最小割就是答案。

## 代码实现

```cpp
#include<bits/stdc++.h>
#define ll long long
#define mkp(x,y) make_pair(x,y)
using namespace std;
const int N=1e5+5;
const int M=1e6+5;
const int INF=1e9+7;
int n,m,s,t,cnt=-1,sum,maxflow,lv[N],head[N],cur[N];
struct EDGE {
	int v,next,w;
}edge[M];
void add_edge(int x,int y,int z) {
	edge[++cnt]=(EDGE){y,head[x],z};
	head[x]=cnt;
} 
queue<int>q;
bool bfs() {
	memset(lv,-1,sizeof(lv));
	q.push(s);
	memcpy(cur,head,sizeof(head));
	lv[s]=1;
	while(!q.empty()) {
		int u=q.front();q.pop();
		for(int i=head[u];~i;i=edge[i].next) {
			int v=edge[i].v,val=edge[i].w;
			if(lv[v]==-1&&val>0) {
				lv[v]=lv[u]+1;
				q.push(v);
			}
		}
	}
	return lv[t]!=-1;
}
int dfs(int p=s,int flow=INF) {
	if(p==t)return flow;
	int rest=flow;
	for(int i=cur[p];~i;i=edge[i].next) {
		cur[p]=i;
		int v=edge[i].v,val=edge[i].w;
		if(lv[v]==lv[p]+1&&val>0) {
			int k=dfs(v,min(val,rest));
			edge[i].w-=k;
			edge[i^1].w+=k;
			rest-=k;
		}
	}
	return flow-rest;
}
void dinic() {
	while(bfs()) {
		maxflow+=dfs();
	}
}
int main() {
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	scanf("%d%d",&n,&m);
	memset(head,-1,sizeof(head));
	s=0,t=n+m+1;
	for(int i=1;i<=n;i++) {
		int x;
		scanf("%d",&x);
		sum+=x;
		add_edge(s,i+m,x);
		add_edge(i+m,s,0);
		while(1) {
			int v;
			scanf("%d",&v);
			if(v==0)break;
			add_edge(i+m,v,INF);
			add_edge(v,i+m,0);
		}
	}
	for(int i=1,val;i<=m;i++) {
		scanf("%d",&val);
		add_edge(i,t,val);
		add_edge(t,i,0);
	}
	dinic();
	printf("%d\n",sum-maxflow);
	return 0;
}

```


---

## 作者：Aisaka_Taiga (赞：0)

求最小割。

我们把题目中的信息提取出来，得到下面的关系：

同意拍照的人给的钱 $-$ 给下属的钱 $=$ 最后赚到的钱。

那么我们建一个超级原点表示给 $m$ 个人钱的人，他向这 $m$ 个人连边，流量为每一个人一开始输入的值 $v_{i}$。

我们建一个超级汇点表示这次给下属的钱的总和，所以从 $n$ 个下属中向超级汇点连边，流量为最后一行的对应的值 $w_{i}$。

我们对于 $m$ 个人，向每一个需要合影的下属连边，流量为 $+\infty$。

我们最后在上面的图跑出来的最大流，假设我们一开始 $m$ 个人都给钱了，最后点分为两类，一类是真正给了钱的人，还有一类就是没给钱导致我们变相亏钱的人和我们给钱的同事。

所以我们可以看到，后面那一类是让我们亏钱的，我们应该尽量让他小！

所以我们转化为了求最小割。

$m$ 个人向 $n$ 个下属连边的流量为 $+\infty$ 是为了防止后面求最小割被考虑到。

最后答案就是一开始我们假设都给钱的 $m$ 个人的总和，减去我们亏的钱的总和，也就是求出来的最小割。

```cpp
/*
 * @Author: Aisaka_Taiga
 * @Date: 2023-08-30 21:35:33
 * @LastEditTime: 2023-08-30 21:42:33
 * @LastEditors: Aisaka_Taiga
 * @FilePath: \Desktop\P3410.cpp
 * 心比天高，命比纸薄。
 */
#include <bits/stdc++.h>

#define INF 0x7fffffff
#define int long long
#define N 1000100

using namespace std;

inline int read(){int x=0,f=1;char ch=getchar();while(!isdigit(ch)){f=ch!='-';ch=getchar();}while(isdigit(ch)){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}return f?x:-x;}

int n, m, head[N], dis[N], ans, cnt = 1, s, t, sum;
struct node{int v, next, w;}e[N];

inline void add(int u, int v, int w){e[++ cnt] = (node){v, head[u], w}; head[u] = cnt;}

inline int bfs()
{
    memset(dis, 0, sizeof dis);
    dis[s] = 1;
    queue<int> q;
    q.push(s);
    while(!q.empty())
    {
        int u = q.front(); q.pop();
        for(int i = head[u]; i; i = e[i].next)
        {
            int v = e[i].v;
            if(!dis[v] && e[i].w)
                dis[v] = dis[u] + 1, q.push(v);
        }
    }
    return dis[t];
}

inline int dfs(int u, int in)
{
    if(u == t) return in;
    int out = 0;
    for(int i = head[u]; i; i = e[i].next)
    {
        int v = e[i].v;
        if(dis[v] == dis[u] + 1 && e[i].w)
        {
            int res = dfs(v, min(in, e[i].w));
            e[i].w -= res;
            e[i ^ 1].w += res;
            in -= res;
            out += res;
            if(!in) break;
        }
    }
    if(!in) dis[u] = 0;
    return out;
}

signed main()
{
    m = read(), n = read();
    s = n + m + 1, t = s + 1;
    for(int i = 1; i <= m; i ++)
    {
        int x = read();
        sum += x;
        add(s, i, x);
        add(i, s, 0);
        while(1)
        {
            x = read();
            if(x == 0) break;
            add(i, m + x, INF);
            add(m + x, i, 0);
        }
    }
    for(int i = 1; i <= n; i ++)
    {
        int x = read();
        add(m + i, t, x);
        add(t, m + i, 0);
    }
    while(bfs()) ans += dfs(s, 1e18);
    ans = sum - ans;
    cout << ans << endl;
    return 0;
}
```

---

## 作者：Foreverxxx (赞：0)

推荐一道比较相似的题目：[太空飞行计划问题](https://www.luogu.com.cn/problem/P2762)。

显然，如果我们选择了这 $m$ 个人中的一个，那么我们必须保证他所选择的所有人都被选到，所以我们考虑最小割。

具体的，对于第 $i$ 个人，我们从源点向其连接一条容量为 $value$ 的边，然后从这个点向他所要求的人连接一条容量为 $inf$ 的边。此时，由于最小割的性质，整张图会被切割为两部分，而最小割不会割掉流量为 $inf$ 的边，如果源点与这个人的边被割掉，则这他所选择的人都会被选入汇点这部分，即每个人都被选择；如果没有被割掉则不需要考虑。

对于那 $n$ 个人，我们只需要向汇点连流量为 $value$ 的边就行了。

现在这张图，我们称之为**闭合图**。

> 闭合图，指某些点构成的集合中，任意点连接的任意出边所指向的点，均属于这个集合。

在这道题中，我们可以把边理解为三部分组成。

1. 源点连向这 $m$ 个人的边。
2. 这 $m$ 个人连向这 $n$ 个人的边。
3. 这 $n$ 个人连向汇点的边。

不难看出，这个网络就是一张闭合图。

在闭合图中的最大权值，有一个结论，即**最大权值 = 闭合图的正权值之和 - 最小割**。对于上述算法的正确性，参考[证明](https://www.cnblogs.com/do-while-true/p/15712351.html)（实在理解不了就记结论吧）。

所以说，我们可以把源点连向这 $m$ 个人的边作为正权边，而把这 $n$ 个人连向汇点的边作为负权边看待，答案即为闭合图的最大权值。

对于统计答案而言，把所有边都按照原来的正权值赋值，跑最小割，而正权值之和，只需要记录这 $m$ 个人开的价格即可。

Code

```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read(){
	int sss=0;
	char chh=getchar();
	while(chh<'0'||chh>'9') chh=getchar();
	while(chh>='0'&&chh<='9'){
		sss=sss*10+chh-'0';
		chh=getchar();
	}
	return sss;
}
int n,m,s,t;
int depth[205];
int head[205],to[1000005],val[1000005],nxt[1000005],tot=1;
void add(int u,int v,int w){
	to[++tot]=v;
	val[tot]=w;
	nxt[tot]=head[u];
	head[u]=tot;
}
bool bfs(){
	memset(depth,0,sizeof depth); depth[s]=1;
	queue<int> q; q.push(s);
	while(!q.empty()){
		int x=q.front(); q.pop();
		for(register int i=head[x];i;i=nxt[i]){
			int u=to[i];
			if(val[i]&&!depth[u]){
				depth[u]=depth[x]+1;
				q.push(u);
			}
		}
	}
	return depth[t];
}
int dfs(int now,int flow){
	if(now==t) return flow;
	int out_flow=0;
	for(register int i=head[now];i&&flow;i=nxt[i]){
		int u=to[i];
		if(val[i]&&depth[u]==depth[now]+1){
			int tmp=dfs(u,min(val[i],flow));
			val[i]-=tmp; val[i^1]+=tmp;
			flow-=tmp; out_flow+=tmp;
		}
	}
	if(out_flow==0) depth[now]=0;
	return out_flow;
}
int Dinic(){
	int ret=0;
	while(bfs()) ret+=dfs(s,1e9);
	return ret;
}
int main(){
	m=read(),n=read(); int sum=0;
	s=0,t=201; int value,x;
	for(register int i=1;i<=m;i++){
		value=read(); sum+=value;//记录这m个人出的价格
		add(s,i,value); add(i,s,0);
		while(true){
			x=read(); if(!x) break;
			add(i,m+x,1e9); add(m+x,i,0);
		}
	}
	for(register int i=1;i<=n;i++){
		value=read();
		add(i+m,t,value),add(t,i+m,0);
	}
	printf("%d",sum-Dinic());
	return 0;
}
```

---


# [JSOI2009] 游戏

## 题目描述

小 AA 和小 YY 得到了《喜羊羊和灰太狼》的电影票，都很想去观看，但是电影票只有一张，于是他们用智力游戏决定胜负，赢得游戏的人可以获得电影票。

在 $N \times M$ 的迷宫中有一个棋子，小 AA 首先任意选择棋子放置的位置。然后，小 YY 和小 AA 轮流将棋子移动到相邻的格子里。游戏的规则规定，在一次游戏中，同一个格子不能进入两次，且不能将棋子移动到某些格子中去。当玩家无法继续移动棋子时，游戏结束，最后一个移动棋子的玩家赢得了游戏。

例如下图所示的迷宫，迷宫中 `.` 表示棋子可以经过的格子，而 `#` 表示棋子不可以经过的格子：

```cpp
                                 .##
                                 ...
                                 #.# 
```                                 
若小 AA 将棋子放置在 $(1,1)$，则小 AA 则无论如何都无法赢得游戏。

而若小 AA 将棋子放置在 $(3,2)$ 或 $(2,3)$，则小 AA 能够赢得游戏。例如，小 AA 将棋子放置在 $(3,2)$，小 YY 只能将它移动到 $(2,2)$，此时小 AA 再将棋子移动到 $(2,3)$，就赢得了游戏。

小 AA 和小 YY 都是绝顶聪明的小朋友，且从不失误。小 AA 到底能不能赢得这场游戏，从而得到珍贵的电影票呢？

## 说明/提示

- 对 $30\%$ 的数据，有 $n,m \leq 5$；
- 对 $100\%$ 的数据，有 $1 \leq n,m \leq 100$。


## 样例 #1

### 输入

```
3 3
.##
...
#.#```

### 输出

```
WIN
2 3
3 2```

# 题解

## 作者：SunsetGlow95 (赞：23)

# P4055 \[JSOI2009\]游戏 题解

## 题意

在一个格点图上，两方轮流移动棋子一步，不能移到已走过的位置，移不动者输。问如何设定棋子的初始位置，使得后手必胜？

## 分析

将这题可以分类为一类 **二分图博弈** 问题。

### 为什么是二分图？

这是一个常用的转换技巧，在许多网络流题目中体现的更精湛。一般一个网格图按照国际象棋的染色方式，可以被染成一个二分图。

![](https://cdn.luogu.com.cn/upload/image_hosting/lzc6358l.png)

对于点 $(x,y)$，颜色就是 $x+y$ 的奇偶。

### 转换后要怎么做？

首先给出一个大家都知道的结论：**在这个博弈中，如果初始在二分图的所有最大匹配上，那么先手必胜，反之后手必胜。**

### 为什么我是对的？

先给出样例的拟图：

![](https://cdn.luogu.com.cn/upload/image_hosting/ts6mmiuw.png)

其中加粗的点为在任意最大匹配上的点。不妨先称为“粗点”，相对地有“细点”。

可以发现，从一个粗点出发（如 $(2,2)$），只需要任意选择一个在任意一个最大匹配上的匹配点（$(2,3)$ 或 $(3,2)$）即可。只要先手走的是最大匹配，无论后手怎么走，因为题目要求不能回头，所以一定可以继续沿着一个最大匹配走。

梳理一下这是怎么回事：只要先手在粗点，那么无论对方怎么走，永远可以再次走最大匹配。如果不可以，这就与最大匹配的“最大”矛盾了。

反之，如果在细点上，那么后手一定可以在一个粗点上出发，即后手必胜。

所以，题目所求的就转化为：**求在一个二分图上，有哪些点不一定在最大匹配上。**

只要求出这个细点集，空（也就是说，存在完美匹配，任意点皆为粗点）即输出 `LOSE`，非空输出 `WIN` 即可。

## 具体地怎么实现？

首先用任意可以解决二分图最大匹配问题的算法（匈牙利或 Dinic）都可以。此时我们知道，不在当前匹配的点必然是细点。

接下去，我们可以做一个 DFS。如果一个点 $P$ 已被证实是细点，设它有一边连着 $Q$，且 $Q$ 在最大匹配上，则 $Q$ 的匹配点也是细点。如样例，如果当前 $(2,2)$ 匹配 $(2,3)$，当我们从 $(3,2)$ 开始 DFS 时，就会发现 $(2,3)$ 是细点。想想看，将 $(2,2)\Rightarrow(2,3)$ 换成 $(2,2)\Rightarrow(3,2)$ 都是最大匹配。根据这样的性质，找出所有的细点即可。

## 主要代码

```cpp
constexpr int MXN = 101;
constexpr int MXPTS = 10001;

bool enable[MXPTS];
int n, m, pts;

inline int id(int x, int y) { return x * m + y; }

int head[MXPTS], to[MXPTS << 2], nxt[MXPTS << 2], es;  // for base graph
int link[MXPTS], vis[MXPTS];                           // for bi-graph
void init() {
  fill(head, head + pts, -1);
  fill(link, link + pts, -1);
  fill(vis, vis + pts, -1);
}
void addedge(int f, int t) {
  to[es] = t;
  nxt[es] = head[f];
  head[f] = es++;
}
bool ask(int cur, int t) {
  if (vis[cur] == t) return false;
  vis[cur] = t;
  for (int i(head[cur]); ~i; i = nxt[i]) {
    if (!~link[to[i]] || ask(link[to[i]], t)) {
      link[to[i]] = cur;
      return true;
    }
  }
  return false;
}
void makepair() {
  for (int i(0); i != n; ++i) {
    for (int j(0); j != m; ++j) {
      if (!((i + j) & 1) && enable[id(i, j)]) ask(id(i, j), id(i, j));
    }
  }
  for (int i(0); i != pts; ++i) {
    if (~link[i]) link[link[i]] = i;
  }
}

bool cango[MXPTS], ans;

void findfake(int cur) {
  ans = cango[cur] = true;
  for (int i(head[cur]); ~i; i = nxt[i]) {
    if (~link[to[i]] && !cango[link[to[i]]]) findfake(link[to[i]]);
  }
}

int main() {
  cin >> n >> m;
  pts = n * m;
  init();
  for (int i(0); i != pts; ++i) {
    char c;
    cin >> c;
    if (c == '.') enable[i] = true;
  }
  for (int i(0); i != n; ++i) {
    for (int j(0); j != m; ++j) {
      if (enable[id(i, j)]) {
        if (i != n - 1 && enable[id(i + 1, j)])
          addedge(id(i, j), id(i + 1, j)), addedge(id(i + 1, j), id(i, j));
        if (j != m - 1 && enable[id(i, j + 1)])
          addedge(id(i, j), id(i, j + 1)), addedge(id(i, j + 1), id(i, j));
      }
    }
  }
  makepair();
  for (int i(0); i != pts; ++i) {
    if (enable[i] && !~link[i]) {
      findfake(i);
    }
  }
  puts(ans ? "WIN" : "LOSE");
  for (int i(0); i != n; ++i) {
    for (int j(0); j != m; ++j) {
      if (cango[id(i, j)]) cout << i + 1 << ' ' << j + 1 << endl;
    }
  }
  return 0;
}
```

---

## 作者：juju527 (赞：14)

### 博弈论

考虑没有障碍的情况和固定起点的情况

[P4136 谁能赢呢？](https://www.luogu.com.cn/problem/P4136)

这里我们可以考虑经典操作**黑白染色**

因为每一次走都是从黑到白或者从白到黑

继续黑白染色的经典操作**建立二分图**

对于每一个点，除去障碍，它能走到的点都连一条边

我们考虑二分图是否是完美匹配的二分图

即所有点都在最大匹配的方案中

那么此时后者必胜

因为完美匹配情况下，先者无论选哪一个，后者选先者对应的那个匹配点即可

而选到最后先者一定选完或被困死

若不是完美匹配，先者应选非二分图必须点出发，先者必胜

**非二分图必须点即某一个最大匹配方案下该点不被选中**

那么在那个匹配方案下，我们下一步一定会进入最大匹配方案中的点

由于偶数条边的路径可以以非最大匹配点出发和结尾

所以在下一步可能进入另一个非二分图必须点，这样同样是先者必胜

若选最大匹配方案中的点，下一步后者只能选最大匹配方案中的点

因为奇数条边的路径两端都是非最大匹配方案内点是不和法的

这样就相当于让后手变成了先手

那么题目要求的所有可行的点就是我们要求二分图的所有非二分图必须点

具体求法是随便跑一个最大匹配方案

然后对于不在方案里的点都通过方案中的边走看能不能回到自己这一边

回到自己边的哪些点都是非二分图必须点

因为原本的匹配边能换成一条非匹配边

可以看下dfs2

~~自己乱yy的写法~~

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=105,maxm=105;
struct Edge{
	int to;
	int nxt;
}e[8*maxn*maxm];
int cnt;
int head[maxn*maxm];
int dx[4]={-1,0,0,1};
int dy[4]={0,-1,1,0};
int ban[maxn][maxm];
int tim;
int tp;
int s[maxn*maxm];
int p[maxn*maxm];
int vis[maxn*maxm];
bool flag[maxn*maxm];
bool color[maxn*maxm];
int read(){
	int x=0,y=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')y=-1;ch=getchar();}
	while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+(ch^48),ch=getchar();
	return x*y;
}
void add(int u,int v){
	e[cnt].to=v;
	e[cnt].nxt=head[u];
	head[u]=cnt++;
	return ;
}
int dfs1(int x){
	for(int i=head[x];i!=-1;i=e[i].nxt){
		int tmp=e[i].to;
		if(vis[tmp]==tim)continue;
		vis[tmp]=tim;
		if(p[tmp]==0||dfs1(p[tmp])){
			p[tmp]=x;
			p[x]=tmp;
			return 1;
		}
	}
	return 0;
}
void dfs2(int x){
	vis[x]=tim;
	for(int i=head[x];i!=-1;i=e[i].nxt){
		int tmp=e[i].to;
		if(p[tmp]==0||p[tmp]==x||vis[p[tmp]]==tim)continue;
		s[++tp]=p[tmp];
		dfs2(p[tmp]);
	}
	return ;
}
int main(){
	int n,m,sum=0;
	n=read();m=read();
	memset(head,-1,sizeof(head));
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			char c;
			cin>>c;
			if(c=='#')ban[i][j]=1;
			else sum++;
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if((i+j)&1)continue;
			if(ban[i][j])continue;
			int u=(i-1)*m+j;
			for(int k=0;k<4;k++){
				int x=i+dx[k],y=j+dy[k];
				if(x<1||x>n||y<1||y>m||ban[x][y])continue;
				int v=(x-1)*m+y;
				add(u,v);
				add(v,u);
			}
		}
	}
	int ans=0;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if((i+j)&1)continue;
			int u=(i-1)*m+j;
			if(p[u])continue;
			tim++;
			ans+=dfs1(u);
		}
	}
	if(sum%2==0&&ans==sum/2){printf("LOSE");return 0;}
	printf("WIN\n");
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			int u=(i-1)*m+j;
			if(p[u])flag[u]=1;
		}
	}
	tim++;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			int u=(i-1)*m+j;
			if(flag[u]||ban[i][j])continue;
			s[++tp]=u;
			dfs2(u);
		}
	}
	sort(s+1,s+tp+1);
	for(int i=1;i<=tp;i++){
		int x=s[i]/m+1,y=s[i]%m;
		if(y==0){x--;y=m;}
		printf("%d %d\n",x,y);
	}
	return 0;
}

```

---

## 作者：jpwang (赞：7)

握漕这题竟然没人写，沾沾自喜一下

容易想到把矩阵黑白染色连边，这样就得到了一个二分图，求一遍最大匹配

对于先手而言，若二分图不存在完美匹配，则放在非匹配点一定是最优的。因为后手的第一步必定走到一个匹配点，先手只需要保证一直沿着匹配边走即可，因为不可能存在非匹配边、匹配边交叉出现的增广路，即先手总是能比后手多走一步（根据最大匹配的定义）

若二分图存在完美匹配，那么先手无论如何放置都会输，具体同理;-P

那么跑一遍网络流求完最大匹配后dfs求出非匹配点，这些都是可行的放置方案

大概就是这样，注意加当前弧优化

#Code
```cpp
#include <stdio.h>
#include <string.h>
#include <algorithm>
#include <queue>
#define rep(i,st,ed) for (int i=st;i<=ed;++i)
#define fill(x,t) memset(x,t,sizeof(x))
using std:: min;
std:: queue<int> que;
const int INF=0x3f3f3f3f;
const int L=205;
const int N=80005;
const int E=640005;
struct edge{int x,y,w,next;}e[E];
int dis[N],rc[L][L],vis[N],bel[N],chs[N];
int cur[N],ls[N],n,m,edCnt=1;
int dx[4][2]={{-1,0},{1,0},{0,-1},{0,1}};
bool flag=false;
char str[L];
void addEdge(int x,int y,int w) {
    e[++edCnt]=(edge){x,y,w,ls[x]}; ls[x]=edCnt;
    e[++edCnt]=(edge){y,x,0,ls[y]}; ls[y]=edCnt;
    // printf("%d %d %d\n", x,y,w);
}
int get_pos(int x,int y) {return (x-1)*m+y;}
int bfs(int st,int ed) {
    while (!que.empty()) que.pop();
    que.push(st);
    rep(i,st,ed) dis[i]=-1; dis[st]=1;
    while (!que.empty()) {
        int now=que.front(); que.pop();
        for (int i=ls[now];i;i=e[i].next) {
            if (e[i].w>0&&dis[e[i].y]==-1) {
                dis[e[i].y]=dis[now]+1;
                if (e[i].y==ed) return 1;
                que.push(e[i].y);
            }
        }
    }
    return 0;
}
int find(int now,int ed,int mn) {
    if (now==ed||!mn) return mn;
    int ret=0;
    for (int &i=cur[now];i;i=e[i].next) {
        if (e[i].w>0&&dis[now]+1==dis[e[i].y]) {
            int d=find(e[i].y,ed,min(mn-ret,e[i].w));
            ret+=d; e[i].w-=d; e[i^1].w+=d;
            if (ret==mn) break;
        }
    }
    return ret;
}
int dinic(int st,int ed) {
    int ret=0;
    while (bfs(st,ed)) {
        rep(i,st,ed) cur[i]=ls[i];
        ret+=find(st,ed,INF);
    }
    return ret;
}
void dfs(int now,int lim) {
    if (vis[now]) return ;
    vis[now]=1;
    if (bel[now]==lim) {
        chs[now]=1;
        flag=true;
    }
    for (int i=ls[now];i;i=e[i].next) {
        if (e[i].w==lim) dfs(e[i].y,lim);
    }
}
int main(void) {
    scanf("%d%d",&n,&m);
    rep(i,1,n) {
        scanf("%s",str);
        rep(j,1,m) if (str[j-1]=='#') rc[i][j]=1;
    }
    rep(i,1,n) rep(j,1,m) {
        int now=get_pos(i,j);
        if (((i^j)&1)&&!rc[i][j]) {
            bel[now]=1;
            addEdge(0,now,1);
            rep(k,0,3) {
                int p=i+dx[k][0],q=j+dx[k][1];
                if (p>0&&p<=n&&q>0&&q<=m&&!rc[p][q]) addEdge(now,get_pos(p,q),1);
            }
        } else if (!((i^j)&1)&&!rc[i][j]) {
            addEdge(now,n*m+1,1);
        }
    }
    int mxFlow=dinic(0,n*m+1);
    dfs(0,1); fill(vis,0);
    dfs(n*m+1,0);
    if (flag) {
        puts("WIN");
        rep(i,1,n) rep(j,1,m) {
            if (chs[get_pos(i,j)]) {
                printf("%d %d\n", i,j);
            }
        }
    } else puts("LOSE");
    return 0;
}
```

---

## 作者：CaoXian (赞：5)

很妙的题目，难点在于如何想到把棋子的移动转化为二分图的匹配。

对于这种每次移动只能移到相邻各自的棋盘问题，可以先对棋盘进行黑白染色，染完色后就可以发现：每次移动必定从黑格移动到白格，或从白格移动到黑格。

而且很明显的一点是：黑格和白格构成了一个二分图，相邻的格子在二分图里就有连边。

于是尝试把移动棋子和二分图结合在一起：假设棋子是在黑格里，棋子的一次移动相当于从黑点集到白点集的一条边；多次移动的话就是多条边，同时也就构成了一条链。

接下来我们只考虑从黑点集到白点集的边（即忽略白点集到黑点集的边），这样思考仍然是对的，因为一个白点若连接到了一个作为起点的黑点，那么下一步肯定是走到这个黑点的。

根据题目给出的条件：同一个格子不能进入两次。转化到这个二分图里就是：同一个点或同一条边不能经过两次。

什么时候游戏结束了呢？就是不存在一个没有作为起点的黑点与一个没有作为终点的白点之间有连边，因为这样就肯定存在一种方案使得棋子可以走到这个黑点然后再走到这个白点。

综合上面这些信息，我们可以想到二分图最大匹配。

下面开始分析，加粗的地方是比较重要或者可能有点绕，不容易理解的部分。

如果二分图有**完美匹配**，那么先手必胜（这里指先移动棋子的玩家），因为他永远可以将这个棋子移动到它的配对点上，而后手只能将这个棋子移动到一个**其配对点没有被经过的点上**或者无法移动，所以最后一步一定是先手的。

如果二分图没有完美匹配，那么后手必胜：后手将棋子放在一个**不属于这个二分图的某种最大匹配的点**，先手一定会移动到某个匹配点上，然后相当于回到了上面那种情况，只不过先手后手反转了而已。

先手不可能可以将棋子从非匹配点移动到非匹配点上，因为这样就和**最大匹配**矛盾了（此时可以在这两点之间连边）。

对于求具体方案，我们需要找到所有的**不属于这个二分图的某种最大匹配的点**，也就是最大匹配的非必需点。

我们可以先求出一种最大匹配，从非匹配点开始搜索，找到和非匹配点相邻的**已匹配点**，那么类比匈牙利算法求最大匹配，我们是可以将这个非匹配点和**与其相邻的已匹配点的配对点**替换的，这个时候仍然是一个合法的最大匹配，同时也将一个已匹配点换成了非匹配点。一直这么搜索下去就好了。

上面这一段分析可能会有比较模糊的地方，可以结合代码理解一下，代码里有注释：

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int dx[] = {1, 0, -1, 0};
const int dy[] = {0, 1, 0, -1};
int n, m, u, v, cnt, sz, match[10005], id[105][105];
bool vis[10005];
char ch;
queue<int> q;
vector< pair<int, int> > ans;
vector<int> st, g[10005];
//匈牙利
bool dfs(int now) {
	for(const auto& i : g[now]) {
		if(vis[i]) continue;
		vis[i] = true;
		if(!match[i] || dfs(match[i])) {
			match[now] = i, match[i] = now;
			return true;
		}
	}
	return false;
}
int solve() {
	int ret = 0;
	for(const auto& i : st) {
		if(!match[i]) {
			memset(vis, false, sizeof(vis));
			if(dfs(i)) ++ret;
		}
	}
	return ret;
}
int main() {
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	cin >> n >> m;
	for(int i = 1; i <= n; ++i) {
		for(int j = 1; j <= m; ++j) {
			cin >> ch;
			if(ch == '.') id[i][j] = ++cnt;//给每个空地编号
		}
	}
	for(int i = 1; i <= n; ++i) {
		for(int j = 1; j <= m; ++j) {
			if(!id[i][j]) continue;
			if((i + j) & 1) {//只从黑格/白格开始连边
				st.push_back(id[i][j]);
				for(int k = 0; k < 4; ++k) {
					u = i + dx[k], v = j + dy[k];
					if(u >= 1 && u <= n && v >= 1 && v <= m && id[u][v]) {//建边
						g[id[i][j]].push_back(id[u][v]);
						g[id[u][v]].push_back(id[i][j]);
					}
				}
			}
		}
	}
	if((solve() << 1) == cnt) cout << "LOSE";//如果有完美匹配的话一定会输
	else {
		cout << "WIN\n";
		while(!q.empty()) q.pop();
		memset(vis, false, sizeof(vis));
		for(int i = 1; i <= cnt; ++i) {
			if(!match[i]) {//非当前最大匹配点一定可以作为一个后手必胜的起点
				vis[i] = true;
				q.push(i);
			}
		}
		while(!q.empty()) {
			u = q.front();
			q.pop();
			for(const auto& i : g[u]) {
				if(match[i]) {
					if(!vis[match[i]]) {//相当于把当前非匹配点和另一个已匹配的点的配对点替换，仍然是一个可行的最大匹配，所以那个点的配对点是非必需点
						vis[match[i]] = true;
						q.push(match[i]);
					}
				}
			}
		}
		for(int i = 1; i <= n; ++i) {
			for(int j = 1; j <= m; ++j) {
				if(vis[id[i][j]]) ans.push_back(make_pair(i, j));//统计答案
			}
		}
		for(const auto& i : ans) cout << i.first << " " << i.second << '\n';
	}
	return 0;
}
```

---

## 作者：Sharing666 (赞：4)

## 题意

- 在一个 $n*m$ 的有障碍方阵中，两个人轮流移动棋子走到相邻的方格。

- 先手决定棋子的初始位置。

- 最后移动棋子的玩家获胜。

- 问先手是否有必胜策略，如果有，输出所有能获胜的棋子初始位置。

## 分析

看到这种向相邻方格移动棋子的题，很容易想到**黑白染色建二分图**。

相邻的方格只要没有障碍，就连一条**双向边**。

每次操作可以转换为从左部走到右部或从右部走到左部。

那么，如果**这个二分图是完全匹配**，无论先手选哪个点，后手都会选最大匹配中这个点对应的点。

因此这时**后手**有必胜策略。

**如果这个图不是完全匹配**，一定有一个点剩下来，也就是最大匹配不需要的点。

先手只要一开始把棋子放在这个点，后手无论怎么走，走到的点都在最大匹配内。

于是后手就变成了第一种情况的先手，先手使用上面后手的策略。

因此这时**先手**有必胜策略。

因为最大匹配方案不止一种，所以所有最大匹配方案剩下的点都可以作为棋子的初始位置。

但是枚举每种方案的时间复杂度太大了。

我们可以先任意求一种方案，设剩下的点为 $i$。

从 $i$ 开始遍历二分图，假设 $i$ 有一条边一个**异侧点** $j$，$j$ 有一条在已求方案内的边连 $i$ 的**同侧点** $k$，那么一定可以不选 $j$ 到 $k$ 这条边，改选 $i$ 到 $j$ 的边。

$k$ 即改选后的方案剩下的点。

按照到现在为止的思路写就可以 AC 这道题。

但是当我看到讨论区的[这个帖子](https://www.luogu.com.cn/discuss/405533)后，发现我没有考虑**图不连通**的情况。~~然而造数据的人貌似也没有考虑。~~

其实很好解决，每个连通块都建一遍图就行。为了方便，我用了 $\text{dfs}$ 建图。

```cpp
#include <iostream>
#include <cstring>
#include <cstdio>
using namespace std;

int n,m,tot; //tot是联通块的编号 
int npy[10002]; //匹配方案 
char a[102][102];
int mark[102][102]; //每个点所属的联通块 
int cnt,head[10002]; //链式前向星 
int arrx[4]={0,1,0,-1};
int arry[4]={1,0,-1,0}; //方向数组 
bool vis[10002],ans[10002],lft[10002]; //lft记录每个点是否属于左部 

struct edge{
	int to,nxt;
}e[40002];

void addedge(int A,int B) {
	e[++cnt].to=B;
	e[cnt].nxt=head[A];
	head[A]=cnt;
}

int num(int x,int y) {
	return (x-1)*m+y;
} //坐标->编号 

void build(int x,int y) {
	for(int i=0;i<4;i++) {
		int xx=x+arrx[i],yy=y+arry[i];
		if(!xx || !yy || xx>n || yy>m || a[xx][yy]=='#') continue;
		addedge(num(x,y),num(xx,yy));
		if(mark[xx][yy]) continue;
		mark[xx][yy]=tot;
		build(xx,yy);
	}
} //每个联通块dfs建图 

bool dfs(int u) {
	for(int i=head[u];i;i=e[i].nxt) {
		int v=e[i].to;
		if(!vis[v]) {
			vis[v]=1;
			if(!npy[v] || dfs(npy[v])) {
				npy[v]=u,npy[u]=v;
				return 1;
			}
		}
	}
	return 0;
} //匈牙利 

void dfs2(int u,int rt) {
	if(ans[u]) return ;
	ans[u]=1;
	for(int i=head[u];i;i=e[i].nxt) {
		int v=e[i].to;
		if(npy[v]) dfs2(npy[v],rt);
	}
} //找其他最大匹配方案不需要的点 

int main() {
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++) cin>>a[i]+1;
	bool anss=0;
	for(int i=1;i<=n;i++) 
		for(int j=1;j<=m;j++) 
			if(!mark[i][j] && a[i][j]=='.') {
				cnt=0,tot++;
				memset(head,0,sizeof head);
				memset(e,0,sizeof e);
				memset(npy,0,sizeof npy);
				build(i,j);
				for(int k=1;k<=n;k++) 
					for(int l=1;l<=m;l++) {
						if(mark[k][l]!=tot || (k+l)%2==0) continue;
						lft[num(i,j)]=1;
						memset(vis,0,sizeof vis);
						dfs(num(k,l));
					}
				bool flag=0;
				for(int k=1;k<=n;k++) 
					for(int l=1;l<=m;l++) 
						if(mark[k][l]==tot && !npy[num(k,l)]) flag=1;
				//判断是否为完全匹配 
				anss|=flag;
				if(!flag) continue; 
				for(int k=1;k<=n;k++) 
					for(int l=1;l<=m;l++) 
						if(mark[k][l]==tot && !npy[num(k,l)]) dfs2(num(k,l),num(k,l));
			}
	if(!anss) {
		printf("LOSE\n");
		return 0;
	}
	printf("WIN\n");
	for(int i=1;i<=n;i++) 
		for(int j=1;j<=m;j++) 
			if(ans[num(i,j)]) printf("%d %d\n",i,j);
	return 0;
}
```
~~码风不好看 TwT。~~

---

## 作者：血の祈り (赞：4)


### 题目描述

小AA和小YY得到了《喜羊羊和灰太狼》的电影票，都很想去观看，但是电影票只有一张，于是他们用智力游戏决定胜负，赢得游戏的人可以获得电影票。

在N*M的迷宫中有一个棋子，小AA首先任意选择棋子放置的位置。然后，小YY和小AA轮流将棋子移动到相邻的格子里。游戏的规则规定，在一次游戏中，同一个格子不能进入两次，且不能将棋子移动到某些格子中去。当玩家无法继续移动棋子时，游戏结束，最后一个移动棋子的玩家赢得了游戏。

例如下图所示的迷宫，迷宫中”.”表示棋子可以经过的格子，而”#”表示棋子不可以经过的格子：
```
                             .##
                             ...
                             #.# 
```
1
2
3
4
若小AA将棋子放置在(1,1)，则小 AA 则无论如何都无法赢得游戏。 

而若小AA将棋子放置在(3,2)或(2,3)，则小AA能够赢得游戏。例如，小AA将棋子放置在(3,2)，小YY只能将它移动到(2,2)，此时小AA再将棋子移动到(2,3)，就赢得了游戏。

小AA和小YY都是绝顶聪明的小朋友，且从不失误。小AA到底能不能赢得这场游戏，从而得到珍贵的电影票呢？ 

### 输入输出格式 

#### 输入格式： 

输入数据首先输入两个整数 N,M，表示了迷宫的边长。接下来 N 行，每行 M 个字符，描述了迷宫。 

#### 输出格式： 
若小 AA 能够赢得游戏，则输出一行”WIN”，然后输出所有可以赢得游戏的起始位置，按行优先顺序输出，每行一个。

否则输出一行”LOSE”（不包含引号）。 

### 输入输出样例 
#### 输入样例#1： 

3 3 

.## 

… 

#.# 

#### 输出样例#1： 

WIN 

2 3 

3 2 

#### 说明 

对30%的数据，有1<=n,m<=5,对100%的数据，有1<=n,m<=100.

### 分析

这道题要是没有不可到的地方，就和[这道题](https://www.luogu.org/problemnew/show/P4136)一样了，然而，它有阻挡，所以自然想到二分图匹配，对于先手而言，若二分图不存在完美匹配，则放在非匹配点一定是最优的。因为后手的第一步必定走到一个匹配点，先手只需要保证一直沿着匹配边走即可，因为不可能存在非匹配边、匹配边交叉出现的增广路，即先手总是能比后手多走一步（根据最大匹配的定义），若二分图存在完美匹配，那么先手无论如何放置都会输，具体同理，那么先判断是否是完美匹配，若是这道题也就完了，不是的话找到非匹配点就行了，时间：4500ms。 

上代码
```
#include<bits/stdc++.h>
using namespace std;
int next[200001],head[200001],now=0,point[200001],match[200001],x[200001],y[200001],mat[200001],dx[5]={0,0,0,1,-1},dy[5]={0,1,-1,0,0};
bool visit[200001],mark[200001];
char ch[200][200];
void add(int x,int y){ 
	next[++now]=head[x];
	head[x]=now;
	point[now]=y;
}
bool dfs(int k){
    for(int i=head[k],u;i;i=next[i]){
    	if(!visit[u=point[i]]){
            visit[u]=1;
            if(dfs(match[u])||match[u]==-1){
                match[u]=k;
                mat[k]=u;
                return true;
            }
        }
	}
    return false;
}
int main(){
    int n,m,u=0,v=0,flag=0,fi=0;
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++){
    	scanf("%s",ch[i]+1);
	}
    for(int i=1;i<=n;i++){
        fi^=1;
        for(int j=fi+1;j<=m;j+=2){
        	if(ch[i][j]=='.'){
                x[++u]=i*m+j;
                for(int k=1;k<=4;k++){
                    int xx=i+dx[k],yy=j+dy[k];
                    if(ch[xx][yy]=='.'){
                    	add(i*m+j,xx*m+yy);
						add(xx*m+yy,i*m+j);
					}
                }
            }
		}	
    }
    fi=1;
    for(int i=1;i<=n;i++){
        fi^=1;
        for(int j=fi+1;j<=m;j+=2){
        	if(ch[i][j]=='.'){
        		y[++v]=i*m+j;
			}
		}
    }
    memset(match,-1,sizeof(match));
    for(int i=1;i<=u;i++){
        memset(visit,0,sizeof(visit));
        if(!dfs(x[i])){
        	flag=1;
			mark[x[i]]=1;
		}
    }
    for(int i=1;i<=v;i++){
        if(match[y[i]]==-1){
        	mark[y[i]]=1;
			flag=1;
		}else{
            memset(visit,0,sizeof(visit));
            visit[y[i]]=1;
            if(dfs(match[y[i]])){
            	match[y[i]]=-1;
				mark[y[i]]=1;
				flag=1;
			}
        }
    }
    for(int i=1;i<=v;i++){
        memset(visit,0,sizeof(visit));
        if(!dfs(y[i])){
        	flag=1;
			mark[y[i]]=1;
		}
    }
    for(int i=1;i<=u;i++){
        if(match[x[i]]==-1){
        	mark[x[i]]=1;
			flag=1;
		}else{
            memset(visit,0,sizeof(visit));
            visit[x[i]]=1;
            if(dfs(match[x[i]])){
            	match[x[i]]=-1;
				mark[x[i]]=1;
				flag=1;
			}
        }
    }
    if(!flag){
        printf("LOSE\n");
        return 0;
    }
    printf("WIN\n");
    for(int i=1;i<=n;i++){
    	for(int j=1;j<=m;j++){
    		if(mark[i*m+j]){
    			printf("%d %d\n",i,j);
			}
		}
	}
}
```

---

## 作者：SunnyYuan (赞：3)

## 思路

**我主要讲一讲怎么找到可以让先手赢的点。**

---

先说一说基本思路：

可以想到将该图黑白染色，让其成为二分图。

然后再在每个白点上连接其可以到达的点。

1. 存在完美匹配，先手必败。

因为不论先手将棋子放在哪里，后手都可以走这个点的所在的最大匹配边，总能在先手移动完以后做出移动，所以先手必败。

![](https://cdn.luogu.com.cn/upload/image_hosting/l1a9i8ce.png)

2. 不存在完美匹配，先手必胜。

先手可以将棋子放在非匹配点，后手必走非匹配边来到匹配点，那么先手就可以一直走匹配边，所以先手必胜。

![](https://cdn.luogu.com.cn/upload/image_hosting/mi6rlpy6.png)

---

实际上非匹配点可以看作非必须点，删掉它也不会影响最大匹配数量。

所以实际上我们现在就要想一想怎样才能找到非必须点。

如果我们发现一个点 $u$ 沿着一条边到达一个匹配点 $v$，且该点的匹配点不是 $u$，那么我们就可以将原来的一条匹配边换成 $u-v$。

![](https://cdn.luogu.com.cn/upload/image_hosting/d7kbh1yf.png)

于是，我们只要从一个点 $u$ 开始 dfs 如果还能回到同侧的一个匹配点，那么那个匹配点就是非必须点。

我们通过这种方法就可以找到所有可以让先手赢的点。

## 代码

```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 110, K = N * N;
const int dx[4] = {1, 0, -1, 0};
const int dy[4] = {0, 1, 0, -1};

vector<int> e[K];

int n, m;
char g[N][N];
int a[N][N];
bool vis[K];
int match[K];

int dfs(int u) {
    for (int to : e[u]) {
        if (!vis[to]) {
            vis[to] = true;
            if ((!match[to]) || dfs(match[to])) {
                match[to] = u;
                match[u] = to;
                return 1;
            }
        }
    }
    return 0;
}

int win[K];

void getwin(int u) {
    vis[u] = true;
    for (int to : e[u]) {
        if ((!match[to]) || (match[to] == u) || vis[match[to]]) continue;
        win[match[to]] = true;
        getwin(match[to]);
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    cin >> n >> m;
    for (int i = 1; i <= n; i++) cin >> (g[i] + 1);

    for (int i = 1; i <= n; i++) iota(a[i] + 1, a[i] + m + 1, (i - 1) * m + 1);
    int c = 0;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            if (((i + j) & 1) && (g[i][j] != '#')) {
                for (int k = 0; k < 4; k++) {
                    int nx = i + dx[k], ny = j + dy[k];
                    if (nx < 1 || ny < 1 || nx > n || ny > m || g[nx][ny] == '#') continue;
                    e[a[i][j]].push_back(a[nx][ny]);
                    e[a[nx][ny]].push_back(a[i][j]);
                }
            }
            if (g[i][j] != '#') c++;
        }
    }

    int cnt = 0;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            if (((i + j) & 1) && (g[i][j] != '#')) {
                memset(vis, 0, sizeof(vis));
                cnt += dfs(a[i][j]);
            }
        }
    }
    if (cnt == (c >> 1) && (!(c & 1))) {
        cout << "LOSE\n";
        return 0;
    }
    cout << "WIN\n";
    memset(vis, 0, sizeof(vis));
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            if ((!match[a[i][j]]) && (g[i][j] != '#')) {
                win[a[i][j]] = 1;
                getwin(a[i][j]);
            }
        }
    }

    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            if (win[a[i][j]]) {
                cout << i << ' ' << j << '\n';
            }
        }
    }
    return 0;
}
```

---

## 作者：hejianxing (赞：3)

[link](https://www.luogu.com.cn/problem/P4055)

# 题目大意

题目说得比较清楚。

# 题解

前置知识：二分图最大匹配、基础博弈论。

每个点只能走一次的四联通点阵，可以想到二分图匹配。

将其套路地奇偶分点，相邻两点连边（显然不能为 `#`）。

先求一个最大匹配。

如果是完美匹配，那么 `LOSE`.因为小 AA 将棋子放到任意一点，小 YY 都能走匹配边走到另一部，小 AA 就只能走非匹配边。每一点都有一条匹配边，最后小 YY 会走最后一条匹配边，这时所有点都走完了。小 AA 败。

现在考虑 `WIN`.

首先，若小 AA 选择非匹配点，那么小 AA 必胜。显然，非匹配点的邻接点都为匹配点，否则就不是最大匹配。当小 AA 放下棋子后，小 YY 走到匹配点上。然后，小 AA 走匹配边。则小 YY 此时只能走非匹配边。以非匹配点为开始的一条路径，路径的结尾只能是匹配点。这个点只有一条边连出，为匹配边。最后，小 AA 会通过这条匹配边走到结尾，小 AA 胜。

所以小 AA 选非匹配点时胜利。

再来观察下图。黑点为匹配点，边权为 $1$ 的是匹配边。

![这是一张图片](https://cdn.luogu.com.cn/upload/image_hosting/hsclzy46.png?x-oss-process=image/resize,m_lfit,h_370,w_425)

我们还有另一种方案：

![这是一张图片](https://cdn.luogu.com.cn/upload/image_hosting/iejlbr6d.png?x-oss-process=image/resize,m_lfit,h_370,w_425)

那么点 $1$ 和 $5$ 都是必胜点。

由此断言：答案为**非最大匹配必须点**。

如果一个点 $p$ 是**非最大匹配必须点**，那么存在一个最大匹配，使点 $p$ 不是匹配点。在这个最大匹配上实行上述方案，小 AA 必胜。

我们发现，只需要对一个点尝试增广，如果增广出一条路径，长度与当前最大匹配的路径长度相等，那这个点就是一个非最大匹配必须点。

由于一个点可能在 $X$ 部，也可能在 $Y$ 部，分类讨论的话要写两个增广函数。可以将两部记录匹配点的数组 $cx$ 和 $cy$ 合并，统一为 $cxy$，$cxy_i$ 记录点 $i$ 对应的匹配点编号。这样的话需要建双向边，所以其实是用增大常数的代价换来较小的编程复杂度。

时间复杂度 $O(n^4)$.

# 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 40005;//不能开太大，否则 memset 时会 TLE
int n, m, cnt = 0, fir[N], nxt[N], to[N], vis[N], cxy[N], p[105][105], tot = 0, xt, cans = 0;
char a[105][105];
int dx[5] = {0, 1, 0, -1};
int dy[5] = {1, 0, -1, 0};
struct node {
    int x, y;
} ans[N];
void ade(int u, int v) {
    cnt++, nxt[cnt] = fir[u], fir[u] = cnt, to[cnt] = v;
    cnt++, nxt[cnt] = fir[v], fir[v] = cnt, to[cnt] = u;
}
void getp() {//重标号
    for (int i = 1; i <= n; i++)
        for (int j = ((i & 1) ? 1 : 2); j <= m; j += 2)
            if (a[i][j] == '.')
                p[i][j] = ++tot;
    xt = tot;
    for (int i = 1; i <= n; i++)
        for (int j = ((i & 1) ? 2 : 1); j <= m; j += 2)
            if (a[i][j] == '.')
                p[i][j] = ++tot;
}
void ADE(int x, int y) {//将 (x,y) 与邻接点连边
    for (int i = 0; i < 4; i++) {
        int xx = x + dx[i], yy = y + dy[i];
        if (xx >= 1 && xx <= n && yy >= 1 && yy <= m && a[xx][yy] == '.') ade(p[x][y], p[xx][yy]);
    }
}
int dfs(int r) {//找增广路径
    vis[r] = 1;
    for (int i = fir[r]; i; i = nxt[i])
        if (!vis[to[i]]) {
            vis[to[i]] = 1;
            if (!cxy[to[i]] || dfs(cxy[to[i]])) {
                cxy[cxy[r]] = 0, cxy[r] = to[i], cxy[to[i]] = r;
                return 1;
            }
        }
    return 0;
}
void match() {
    for (int i = 1; i <= xt; i++)
        if (!cxy[i])
            memset(vis, 0, sizeof(vis)), dfs(i);
}
int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++) scanf("%s", a[i] + 1);
    getp();
    for (int i = 1; i <= n; i++)
        for (int j = ((i & 1) ? 1 : 2); j <= m; j += 2)//只枚举偶点
            if (a[i][j] == '.')
                ADE(i, j);
    match();//先求一种最大匹配方案
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++)
            if (a[i][j] == '.') {
                memset(vis, 0, sizeof(vis));
                if (!cxy[p[i][j]] || dfs(cxy[p[i][j]])) ans[++cans].x = i, ans[cans].y = j;
            }
    if (!cans) { printf("LOSE"); return 0; }//没有非匹配点
    printf("WIN\n");
    for (int i = 1; i <= cans; i++) printf("%d %d\n", ans[i].x, ans[i].y);
    return 0;
}
```

# END


---

## 作者：Cosmos_zzx (赞：2)

## [[JSOI2009] 游戏](https://www.luogu.com.cn/problem/P4055)

考虑没有障碍的情况和固定起点的情况：

**[谁能赢呢？](https://www.luogu.com.cn/problem/P4136)**

其实这一题是一个二分图博弈问题，每个网格图都可以被二分图染色：
![](https://cdn.luogu.com.cn/upload/image_hosting/1m3731he.png)

在这个图里，对于每一个点，去掉不能走的点，与它能走到的点都连一条边。

对于点 $(x,y)$，颜色就是 $x+y$ 的奇偶。

引用[这篇题解](https://www.luogu.com.cn/article/simbqsj9)的一句话：
> 首先给出一个大家都知道的结论：在这个博弈中，如果初始在二分图的所有最大匹配上，那么先手必胜，反之后手必胜。

再引用一句：
> 首先给出一个大家都知道的结论：在这个博弈中，**如果初始在二分图的所有最大匹配上**，**那么先手必胜，反之后手必胜**。

**为什么？**

![](https://cdn.luogu.com.cn/upload/image_hosting/aou6wkis.png)

粗圆圈的点为最大匹配点，由于这个是无向图，所以对于一条匹配边，其两点都为匹配点（为什么 $4,5$ 不是 $3$ 的匹配点？因为在所有最大匹配方案中，$3$ 可以跟 $4$ 匹配，又可以跟 $5$ 匹配，$4,5$ 没有在所有方案中出现，这是综合了所有最大匹配方案的图）。

我们称加粗的点为粗点，反之为细点。

如果先手选的起点是粗点，那么后手只需要随便选择一个在**任意一个最大匹配上**与**该点匹配**的匹配点，重复此操作，后手必赢。

反之，如果先手选的起点是细点，**则先手必胜**。

所以，题目的意思就变成了求**所有的细点**，如果这个图是个完美匹配，先手就**输了**。

那我们该怎么做？每次以每一个点为起点做一次匈牙利吗？显然不行。

我们可以发现，如果 $x$ 已经被证实是细点，那么 $x$ 的匹配点 $y$ 的另一些匹配点都为细点，做一遍 ```dfs```即可。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e6+115;
int n,m,path[N],use[N],tim;
char aa[101][101];
int dx[4]={0,0,-1,1};
int dy[4]={-1,1,0,0};
vector<int> adj[N];
bool dfs(int x)
{
	for(auto i:adj[x])
	{
		if(use[i]!=tim)
		{
			use[i]=tim;
			if(!path[i] || dfs(path[i]))
			{
				path[i]=x;
				path[x]=i;
				return 1;
			}
		}
	}
	return 0;
}
bool flag[N];
int st[N],top;
void dfs2(int u)
{
	use[u]=tim;
	for(auto i:adj[u])
	{
		if(path[i]==0 || path[i]==u || use[path[i]]==tim)continue;
		st[++top]=path[i];
		dfs2(path[i]);
	}
}
signed main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			cin>>aa[i][j];
	int sum=0;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			if(aa[i][j]=='#')continue;
			sum++;
			if((i+j) & 1)continue;
			for(int k=0;k<4;k++)
			{
				int tx=i+dx[k];
				int ty=j+dy[k];
				if(tx>=1 && tx<=n && ty>=1 && ty<=m && aa[tx][ty]=='.')
				{
				adj[(i-1)*m+j].push_back((tx-1)*m+ty);
				adj[(tx-1)*m+ty].push_back((i-1)*m+j);
				}
			}
		}
	}
	int ans=0;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			if((i+j) & 1)continue;
			tim++;
			if(dfs((i-1)*m+j))
			{
				ans++;
			}
		}
	}
	if(ans==sum/2 && sum%2==0)cout<<"LOSE\n";
	else
	{
		tim++;
		cout<<"WIN\n";
		for(int i=1;i<=n;i++)
		{
			for(int j=1;j<=m;j++)
			{
				int ttt=(i-1)*m+j;
				if(path[ttt])flag[ttt]=1;
			}
		}
		for(int i=1;i<=n;i++)
		{
			for(int j=1;j<=m;j++)
			{
				int ttt=(i-1)*m+j;
				if(flag[ttt] || aa[i][j]=='#')continue;
				st[++top]=ttt;
				dfs2(ttt);
			}
		}
		sort(st+1,st+1+top);
		for(int i=1;i<=top;i++)
		{
			int tx=st[i]/m+1,ty=st[i]%m;
			if(ty==0)tx--,ty=m;
			cout<<tx<<' '<<ty<<endl;
		}
	}
	return 0;
}
```

---

## 作者：LJ26yanxingyu (赞：2)

## 分析
对于这一类有关棋盘的问题，首先我们就可以想到二分图，然后看一看数据范围，$1 \le n,m \le 100$，很明显就是匈牙利算法。

首先，按奇偶性染色将棋盘转化为二分图，如果这是完全匹配的图，那么放棋子的人必输，因为无论怎么放，都会放到一个匹配点，另一个人都可以通过匹配边到另一个点，由于无法回头，走过的边不能再走，放棋子的人只能走一条非匹配边又到一个匹配点，由于是完全匹配的图，所以另一个人肯定又能走一条匹配边，如此循环，直到放棋子的人走不下去为止。

而如果这是非完全匹配的图，则恰恰相反，放棋子的人必赢，他只用把棋子放到图中最大匹配上非必需的点，则另一个人只能走到一个最大匹配上的必需点，因为如果这是一个非必需点，那么肯定又可以增广，然后放棋子的人就可以沿着最大匹配边走到另一个点，又是一个循环，直到另一个人走不了为止。

所以我们只用先判断是不是完全匹配图，再找到所有非必需的点输出即可。

注：最大匹配的非必需点是指删掉它后最大匹配数不变的点。

## 做法

先求最大匹配再从没选入最大匹配的点 dfs，如果找到一个与从没选入最大匹配的点同一侧的点，那么它也是非必需的点因为它一定可以被没选入最大匹配的那个点替代。

## code
```cpp
#include<bits/stdc++.h>

using namespace std;

int n,m,tim=1;
char a[105][105];
int f[105][105];
int clor[10005];
int k[10005];
bool mark[10005],book[10005];
struct jie{
	int net,to;
}e[40005];
int hed[10005],W=1;
void _add(int a1,int b1){
	e[W]=(jie){hed[a1],b1},hed[a1]=W++;
	return;
}
bool _dfs(int x){
	for(int j=hed[x];j;j=e[j].net){
		int y=e[j].to;
		if(mark[y])continue;
		mark[y]=1;
		if(k[y]==0||_dfs(k[y])){
			k[y]=x;
			return true;
		}
	}
	return false;
}
void _fid(int x){
	if(book[x])return;
	book[x]=1;
	for(int j=hed[x];j;j=e[j].net){
		int y=e[j].to;
		_fid(k[y]);
	}
	return;
}

int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++){
		scanf("%s",a[i]+1);
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if(a[i][j]=='#')continue;
			f[i][j]=tim++;
			if(a[i-1][j]=='.')_add(f[i][j],f[i-1][j]),_add(f[i-1][j],f[i][j]);
			if(a[i][j-1]=='.')_add(f[i][j],f[i][j-1]),_add(f[i][j-1],f[i][j]);
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			clor[f[i][j]]=(i+j)%2;
		}
	}
	int ans=0;
	for(int i=1;i<=tim-1;i++){
		if(clor[i]){
			memset(mark,0,sizeof(mark));
			ans+=_dfs(i);
		}
	}
	if(ans*2==tim-1){
		printf("LOSE\n");
		return 0;
	}
	printf("WIN\n");
	for(int i=1;i<=tim-1;i++){
		if(k[i])k[k[i]]=i;
	}
	for(int i=1;i<=tim-1;i++){
		if(k[i]==0)_fid(i);
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if(book[f[i][j]]){
				printf("%d %d\n",i,j);
			}
		}
	}
	return 0;
}
``````

---

## 作者：AC_love (赞：2)

似乎没有人解释这道题怎么用 Dinic 做，那我来讲一下 Dinic 做法吧。

考虑对所有棋盘进行黑白染色，然后将黑格白格做一下二分图匹配。

这时我们发现：如果刚好可以做出一个完美匹配的话，不管把棋子放到哪，都是先手必胜的。

为什么呢？因为不管棋子当前被移动到了哪里，先手只需要把这个棋子移动到完美匹配中当前这个格子匹配的另一个格子即可。由于整个匹配是个完美匹配，就导致后手永远不可能找到一个机会把先手堵死。因此此时小 AA 必败。

那么如果不是完美匹配呢？

那么我们发现，小 AA 只要把棋子放在一个不在完美匹配中的格子，就一定能取得胜利。

为什么呢？

首先，有一个显而易见的结论是：不可能有两个不在完美匹配中的格子相邻。

因为这样的话，这两个格子一定可以匹配到一起，之前的匹配就不是最大匹配。

也就是说，一个不在完美匹配中的格子周围的格子一定都在完美匹配中。

此时先手一步只能走到在完美匹配中的格子，后手却可以选择与之匹配的格子走进去。这样的话相当于还在刚才的完美匹配中，但是后手却变成了先手。此时后手必胜。

如何找棋子开局时的落点？直接找不在完美匹配中的格子即可。

如何找不在完美匹配中的格子呢？

首先我们先随便跑一个完美匹配出来，把不在完美匹配中的点都标记一下。

然后我们去找和有标记的点在同侧的所有能走到有标记的点的点，它们都是可以被替换的，所以也打上标记。

具体做法就是对于所有点都 `dfs` 一遍，看看能不能走到一个和它颜色相同的有标记的点即可。

然而：由于 AC_love 很菜，不会匈牙利，所以我们来想一想怎么用 Dinic 求不再完美匹配中的点。

我们知道，用 Dinic 求二分图最大匹配时，首先把二分图一边的点都连向一个超级源点，另一边的点都连向超级汇点，然后所有边容量为 $1$，直接跑最大流。

根据流量守恒，我们不难发现：如果超级源点到某个点流量是 $1$ 的话，那么这个点一定在最大匹配中。反之则一定不在。同理如果某个点到超级汇点流量是 $1$ 的话，它也一定在最大匹配中，反之不在。

那么我们只需要在跑完 Dinic 之后找到超级源点，看看它到哪个点的流量为 $0$，那个点就一定不在最大匹配中。

然后再找到超级汇点，看它的残量网络中到哪些点流量为 $1$，残量网络中流量为 $1$，那么在原网络中流量就一定为 $0$，那个点也不在最大匹配中。

核心代码：

```cpp
	dinic();
	for(int i = 0; i < e[S].size(); i = i + 1)
		if(e[S][i].len)
		{
			v.push_back(e[S][i].ed);
			sig[e[S][i].ed] = 1;
		}
	for(int i = 0; i < e[T].size(); i = i + 1)
		if(!e[T][i].len)
		{
			v.push_back(e[T][i].ed);
			sig[e[T][i].ed] = 1;
		}
```

---

## 作者：Fzrcy (赞：1)

对于该题，考虑黑白染色，建立二分图，跑出最大匹配。

若最大匹配为完美匹配，则先手必败。因为无论先手将棋子放在哪个点，后手只需沿着匹配边即可，此时先手只能走非匹配边，即先手必败（只会出现所有棋子都走完或被困死的情况，因为每个点都是匹配点）。

若不存在完美匹配，则先手必胜。因为先手只需将棋子放在非匹配点上，然后只需沿着匹配边即可，此时后手只能走非匹配边，即后手必败。

统计可以使先手必胜的节点：非匹配点，存在路径为 匹配边-非匹配边-匹配边...非匹配边 的匹配点。

```cpp
#include <bits/stdc++.h>
#define rep(i, a, b) for(int i=(a); i<=(b); i++)
using namespace std;

bool M1;

const int N=2e4+11;

int h[N], nt[N<<1], to[N<<1], ecnt;
void link(int u, int v){
//    printf("%d %d\n", u, v);
    nt[++ecnt]=h[u], h[u]=ecnt, to[ecnt]=v;
}

int n, match[N], vis[N], ci, m;
int ban[101][101], Node;

bool dfs(int u){
    for(int i=h[u]; i; i=nt[i]){
        int v=to[i];
        if(vis[v]==ci) continue;
        vis[v]=ci;
        if(!match[v]||dfs(match[v])){
            match[v]=u, match[u]=v; return true;
        }
    }
    return false;
}

int aa[N], Top;
void Dfs(int u){
    vis[u]=ci;
    for(int i=h[u]; i; i=nt[i]){
        int v=to[i];
        if(!match[v]||match[v]==u||vis[match[v]]==ci)continue;
        aa[++Top]=match[v], Dfs(match[v]);
    }
}

bool M2;

int main(){
    fprintf(stderr, "%.2lf\n", 1.*((&M2)-(&M1))/1024./1024.);
    scanf("%d %d", &n, &m);
    rep(i, 1, n){
        static char s[120];
        scanf("%s", s+1);
        rep(j, 1, m)
            if(s[j]=='#') ban[i][j]=1;
            else Node++;
    }
    const int dx[]={-1, 0, 0, 1};
    const int dy[]={0, -1, 1, 0};
    rep(i, 1, n) rep(j, 1, m){
        if((i+j)&1)continue;
        if(ban[i][j])continue;
        rep(o, 0, 3){
            int x=i+dx[o], y=j+dy[o];
            if(x<1||y<1||x>n||y>m||ban[x][y]) continue;
            link((i-1)*m+j, (x-1)*m+y);
            link((x-1)*m+y, (i-1)*m+j);
        }
    }
    int cnt=0;
    rep(i, 1, n) rep(j, 1, m){
        if((i+j)&1)continue;
        if(match[(i-1)*m+j]||ban[i][j])continue;
        ci++, cnt+=dfs((i-1)*m+j);
    }
    if(Node%2==0&&cnt==Node/2)
        puts("LOSE"), exit(0);
//    printf("%d\n", cnt);
    ci++, puts("WIN");
//    rep(i, 1, n) rep(j, 1, m) if(match[(i-1)*m+j]) cout<<(i-1)*m+j<<" ";
//    cout<<'\n';
    rep(i, 1, n) rep(j, 1, m){
        int x=(i-1)*m+j;
        if(match[x]||ban[i][j])continue;
        aa[++Top]=x, Dfs(x);
    }
    sort(aa+1, aa+Top+1);
    rep(i, 1, Top){
        int x=aa[i]/m, y=aa[i]%m;
        if(y==0)x--, y=m;
        x++;
        printf("%d %d\n", x, y);
    }
    return 0;
}
```

---

## 作者：Zekrom (赞：1)

写了挺久分享一下写这道题的思路：  
1. 首先判断出是一道二分图完备匹配的问题，若最大匹配为完备匹配，则必输，反证法：如果不是完备匹配，从非匹配点出发到达匹配点后，因为不存在增广路径，则沿着匹配边走，必胜   
2. 如果不是完备匹配，要求求出所有的非匹配点，观察样例（1，1）和（4，1）匹配，（2，2）和（3，2）或（2，3）匹配，本来应该只有（2，3），（3，2）其中一点，为什么两点都是呢，因为在另外一组最大匹配中，另外一点成为了非匹配点。所以要对每组匹配中已匹配的右部点删去后重新匹配，若匹配成功，则这个右部点可以成为非匹配点   
3. 对每个点（i，j）hash-> m*(i-1)+j,解hash横坐标i=(x-1)/m+1,y=(x-1)%m+1,使用函数利于对点的处理和代码美观  
4. 黑白染色，不需要dfs进行染色，判断（i+j)(坐标和）为奇数的为左部点，为偶数的记为右部点   

一道很好的二分图的题，很快打的题解没注意排版，上代码了   
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define N 110 
using namespace std;
int n,m,cnt_tot,cnt_left,match[N*N],ans,cnt,head[N*N],tot;
bool a[N][N],vis[N*N],flag[N][N];
struct Edge{
	int v,next;
}edge[N*N*4];
inline int read(){int x=0,f=1;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-f;ch=getchar();}while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+ch-'0',ch=getchar();return x*f;}
inline void add(int x,int y){edge[++tot].v=y;edge[tot].next=head[x];head[x]=tot;}
inline int num(int x,int y){return m*(x-1)+y;}
inline int getl(int a){return (a-1)/m+1;}
inline int getr(int a){return (a-1)%m+1;}
bool dfs(int x){
	for(int i=head[x];i;i=edge[i].next){
		int v=edge[i].v;
		if(vis[v])continue;vis[v]=1;
		if(!match[v]||dfs(match[v])){
			match[v]=x;
			return true;
		}
	}return false;
}
int main(){
	n=read();m=read();
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			char ch;
			cin>>ch;
			if(ch=='.'){
				a[i][j]=1,cnt_tot++;
				if((i+j)%2)cnt_left++;  //左匹配点个数 
			}
		}
	}
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m-1;j++){
			if(a[i][j]&&a[i][j+1])
				add(num(i,j),num(i,j+1)),add(num(i,j+1),num(i,j));
		}
	for(int j=1;j<=m;j++)
		for(int i=1;i<=n-1;i++){
			if(a[i][j]&&a[i+1][j])
				add(num(i,j),num(i+1,j)),add(num(i+1,j),num(i,j));
		}
		

	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			if(a[i][j]&& ((i+j)%2) ) // 黑白染色，横纵坐标之和为偶数的为左部点 
			{
				memset(vis,0,sizeof(vis));
				if(dfs(num(i,j)))ans++;
				else {
					flag[i][j]=1;
				}
			}
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			if(a[i][j]&&((i+j)%2==0)){
				if(!match[num(i,j)]){
					flag[i][j]=1;
				} 
				else{
					memset(vis,0,sizeof(vis));
					vis[num(i,j)]=1;
					if(dfs(match[num(i,j)])){
						flag[i][j]=1;
						match[num(i,j)]=0;
					}
				}
			}
	memset(match,0,sizeof(match)); 
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			if(a[i][j]&& ((i+j)%2==0) ) // 黑白染色，横纵坐标之和为奇数的为右部点 
			{
				memset(vis,0,sizeof(vis));
				if(dfs(num(i,j)))ans++;
				else {
					flag[i][j]=1;
				}
			}
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			if(a[i][j]&&((i+j)%2)){
				if(!match[num(i,j)]){
					flag[i][j]=1;
				} 
				else{
					memset(vis,0,sizeof(vis));
					vis[num(i,j)]=1;
					if(dfs(match[num(i,j)])){
						flag[i][j]=1;
						match[num(i,j)]=0;
					}
				}
			}
	

	if((cnt_left*2==cnt_tot)&&ans==cnt)printf("LOSE\n");    //如果为完备匹配 
	else {
		printf("WIN\n");
		for(int i=1;i<=n;i++)
			for(int j=1;j<=m;j++)
				if(flag[i][j])printf("%d %d\n",i,j);
	} 
	return 0;
}


```


---

## 作者：DengDuck (赞：1)

这道题我们考虑对棋盘黑白染色，这样可以形成一个二分图，相邻的点连双向边。

接下来肯定是考虑最大匹配了。

我们有一个结论：如果所有点都匹配成功，那么先手必败。

这个大家可以想一下，因为所有点都是匹配成功的，无论选择哪一个点，后手都可以选择它的配对点。

接下来先手再走一步，走到一个新的点，我们再选择配对点。

如此反复，直到先手没有新的点可以走为止。

否则，先手可以走匹配失败的点，这个点没有匹配点。

就算在某个方案这个点有相连的，我们从当前状态转移，肯定要使其他的点失配，所以最后肯定还是先手必胜。

因此，我们对于每个点，看看是否在某个方案中它是失配的，如果是，那么这个点就是使先手必胜的点。

这道题数据很水，所以我的通过代码可能没有处理一些情况。

```cpp
#include <bits/stdc++.h>
#define LL int
using namespace std;
const LL dx[2] = { 0, -1 };
const LL dy[2] = { -1, 0 };
struct node {
    LL rx, ry, nxt;
} a[1000005];
LL n, m, tot, f[105][105][2], h[105][105];
bool vis[105][105];
void add(LL x, LL y, LL xx, LL yy) {
    a[++tot] = { xx, yy, h[x][y] };
    h[x][y] = tot;
}
char c[105][105];
void link(LL x, LL y) {
    for (int i = 0; i < 2; i++) {
        LL xx = x + dx[i], yy = y + dy[i];
        if (xx == 0 || yy == 0 || xx == n + 1 || yy == m + 1)
            continue;
        if (c[xx][yy] == '.') {
            add(x, y, xx, yy);
            add(xx, yy, x, y);
        }
    }
}
bool dfs(LL x, LL y) {
    for (LL i = h[x][y]; i; i = a[i].nxt) {
        LL xx = a[i].rx, yy = a[i].ry;
        if (vis[xx][yy])
            continue;
        vis[xx][yy] = 1;
        if (f[xx][yy][1] == 0 || dfs(f[xx][yy][0], f[xx][yy][1])) {
            f[f[x][y][0]][f[x][y][1]][0] = 0, f[f[x][y][0]][f[x][y][1]][1] = 0;
            f[xx][yy][0] = x, f[xx][yy][1] = y;
            f[x][y][0] = xx, f[x][y][1] = yy;
            return 1;
        }
    }
    return 0;
}
int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++) {
        scanf("%s", c[i] + 1);
    }
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            if (c[i][j] == '#')
                continue;
            link(i, j);
        }
    }
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            if (c[i][j] == '#')
                continue;
            if (f[i][j][1] == 1)
                continue;
            memset(vis, 0, sizeof(vis));
            if (f[i][j][1] == 0)
                dfs(i, j);
        }
    }
    puts("WIN");
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            if (c[i][j] == '.') {
                memset(vis, 0, sizeof(vis));
                if (f[i][j][0] == 0 || dfs(f[i][j][0], f[i][j][1]))
                    printf("%d %d\n", i, j);
            }
        }
    }
}
```

---

## 作者：xuhanxi_dada117 (赞：0)

# P4055 [JSOI2009] 游戏 题解

[题目传送门](https://www.luogu.com.cn/problem/P4055)

## 题目大意

给定一个存在障碍的方格棋盘，先手先将一个棋子放在某个位置，之后后手和先手轮流走（相邻格子），不能重复走，直到某人走不了时他就输了，求先手放在哪些位置可以使他必胜？

## 解法

首先，像这种**走方格**的问题，一般来说可以黑白染色。这是因为染色后我们会发现：**每走一步都会改变所在格的颜色**。从图论的角度来看，我们把棋盘格转换成了**二分图**，黑白格是两侧的节点，相邻关系则是图上的连边。

然后要注意，原题中的先手，在走路的环节其实是后手，下面的描述都将从后手胜的角度来探讨。

原题中说到的二人博弈问题，一个简单的思路是：给相邻的黑白格尽量两两匹配，然后找一个**没有匹配点的**点做起始点，这样无论先手走到哪里，后手都可以**走到它的匹配点**，这样到最后一定是先手赢。

例如下面这张二分图：

![](https://cdn.luogu.com.cn/upload/image_hosting/vubkajtf.png)

容易找到一个最大匹配：

![](https://cdn.luogu.com.cn/upload/image_hosting/81anxvb3.png)

此时，以未被匹配的 $3$ 号点为起点，无论怎么走，都只能走到有色点（否则就不是最大匹配了）。例如，先手走到 $7$ 号蓝色点，后手就去蓝色的对应点 $2$ 号，先手走到 $6$ 号绿色点，后手就去绿色的对应点 $4$ 号，此时，先手无路可走。

所以，$3$ 就是答案之一。

为什么是之一呢？因为上图还有一种匹配方式：
![](https://cdn.luogu.com.cn/upload/image_hosting/9rvzope8.png)

所以，$1$ 号点也是必胜点。

所以，必胜点的充要条件是：在一个二分图上，该点不一定在最大匹配上。

但是，无论是是匈牙利还是 Dinic 求二分图最大匹配，都不能枚举全部匹配，算出所有答案（超时）。

此时，有一个性质：（下记一个匹配上的某点 $u$ 的对应点为 $match[u]$）

+ 若 $u$ 不在最大匹配上（答案点），则对于任何 $u$ 的有连边点 $v$，$match[v]$ 也可以不在最大匹配上。

这也很好理解——让 $v$ 换一个点匹配就行了。

于是乎，我们可以通过 dfs 或 bfs 的方式，在一个最大匹配的基础上，求出所有答案点。

时间复杂度方面，虽然原图有 $10000$ 个点，但是 Dinic 在二分图这种有分层的图上表现非常出色，足以通过这道题。

## 代码

```cpp
#include<bits/stdc++.h>
#define N0 110
#define N 10010
#define E 100010
#define inf (1ll<<45)
using namespace std;
typedef long long ll;
ll n,m,s,t,nE,nV,hd[N];
char ch[N0][N0];
ll id(ll x,ll y){
	return y+(x-1)*m;
}
struct edge{
	ll to,w,nxt,frm;
}e[E];
void add(ll u,ll v,ll w){
	e[++nE]=(edge){v,w,hd[u],u};
	hd[u]=nE;
}
ll dx[5]={0,0,-1,1,0};
ll dy[5]={0,-1,0,0,1};
ll lev[N],cur[N],to[N];
bool ok[N],fl;
bool bfs(){
	fill(lev,lev+nV+1,0);
	queue<ll> q;
	q.push(s);lev[s]=1;
	while(!q.empty()){
		ll u=q.front();q.pop();
		for(int i=hd[u];i;i=e[i].nxt){
			ll v=e[i].to;
			if(lev[v]||!e[i].w)
				continue;
			q.push(v);
			lev[v]=lev[u]+1;
		}
	}return lev[t];
}
ll dfs(ll u,ll flow){
	if(u==t) return flow;
	ll sum=0;
	for(int i=cur[u];i;i=e[i].nxt){
		cur[u]=i;
		ll v=e[i].to;
		if(lev[v]!=lev[u]+1||!e[i].w)
			continue;
		ll dt=dfs(v,min(e[i].w,flow));
		sum+=dt;flow-=dt;
		e[i].w-=dt;e[i^1].w+=dt; 
	}return sum;
}
void Dinic(){
	ll maxflow=0;
	while(bfs()){
		for(int u=1;u<=nV;++u)
			cur[u]=hd[u];
		maxflow+=dfs(s,inf);
	}
}
// ok[] 代表某个点是不是答案点。
void find(ll u){  //通过 dfs 寻找所有答案点。
	for(int i=hd[u];i;i=e[i].nxt){
		ll v=e[i].to;
		if(v>=s) continue;
		if(ok[to[v]]) continue;
		ok[to[v]]=true;find(to[v]);
	}
}
queue<ll> q;
int main(){nE=1;
	ios::sync_with_stdio(false);
	cin.tie(NULL);cout.tie(NULL);
	cin>>n>>m;
	for(int i=1;i<=n;++i)
		for(int j=1;j<=m;++j)
			cin>>ch[i][j];
	s=n*m+1,t=n*m+2,nV=t;
    //建图。
	for(int i=1;i<=n;++i)
		for(int j=1;j<=m;++j){
			if(ch[i][j]=='#')
				continue;
			if((i+j)%2==1){
				add(id(i,j),t,1);
				add(t,id(i,j),0);
				continue;
			}
			add(id(i,j),s,0);
			add(s,id(i,j),1);
			for(int k=1;k<=4;++k){
				ll nx=i+dx[k],ny=j+dy[k];
				if(nx<1||ny<1||nx>n||ny>m)
					continue;
				if(ch[nx][ny]=='#')
					continue;
				add(id(i,j),id(nx,ny),1);
				add(id(nx,ny),id(i,j),0);
			}
		}
    Dinic();
	for(int i=hd[s];i;i=e[i].nxt){
		ll v=e[i].to,w=e[i].w;
		if(w) ok[v]=fl=true,q.push(v);
	}// 判断哪些点不在匹配上。
	for(int i=hd[t];i;i=e[i].nxt){
		ll v=e[i].to,w=e[i].w;
		if(!w) ok[v]=fl=true,q.push(v);
	}
	for(int i=2;i<=nE;i+=2){
		ll u=e[i].frm,v=e[i].to;
		if(u>=s||v>=s) continue;
		if(!e[i].w) to[u]=v,to[v]=u;
	}// 计算 match[] (代码里是 to[])
	while(!q.empty()){
		ll u=q.front();
		q.pop();find(u);
	}//比较抽象的写法，也可以先求 to[],这样就不用存了再 find.
	if(!fl) cout<<"LOSE";
	else{
		cout<<"WIN\n";//输出答案。
		for(int i=1;i<=n;++i)
			for(int j=1;j<=m;++j)
				if(ok[id(i,j)])
					cout<<i<<" "<<j<<"\n"; 
	}
	return 0;
}
```

---

## 作者：_anll_ (赞：0)

第一道二分图博弈论，纪念一下。
## 思路
一般在棋盘上的都可以尝试按照国际象棋棋盘那样进行黑白染色，[like](https://www.luogu.com.cn/problem/P3355)。对于这道题，你会发现我们每次都是从一个点走到另外一个相邻点，即从 A 色走到 B 色。

对于二分图博弈论，有一个很广为人知~~虽然我今天才知道~~的结论是：如果初始在**任意最大匹配必选点**，则先手必胜，否则后者必胜。原因是在该点一定能走到与其最大匹配的点，而从下一个点走无论如何都能走到另外满足这种情况的点。这题要求后手必胜，所以应该选择**不一定能有最大匹配的点**。

考虑如何通过 Dinic 完成。先随便跑个网络流，不难发现，如果跑完后存在点 $x$，在原图中超级源点连向 $x$ 有流量，或点 $x$ 连向超级汇点有流量，则说明点 $x$ 没有找到最大匹配。而存在最大匹配的一组 $x,y$（我们默认在原图中是 $x$ 指向 $y$），当且仅当它们的边在原图中没有流量。于是我们只需要找到不存在最大匹配的点，尝试深搜更新它可以跑到的点的匹配点即可。

## 代码
人困困的可能讲的也迷迷的。具体看代码吧。
```cpp
#include<queue>
#include<cstring>
#include<iostream>
#define int long long
using namespace std;
const int P=105,N=P*P,inf=1e11;
struct Edge{int l,w,nxt;}edges[N<<3];
int n,m,s,t,tt=1,head[N],mp[P][P],pp[P][P];
int cur[N],vu[N],st[N],pr[N];
int pos[4][2]={{1,0},{-1,0},{0,1},{0,-1}};
void add_edge(int f,int l,int w){
	edges[++tt]={l,w,head[f]};
	head[f]=tt;
}
void add(int x1,int y1,int x2,int y2){
	if(x2<1||x2>n||y2<1||y2>m||mp[x2][y2]) return;
	int f=(x1-1)*m+y1,l=(x2-1)*m+y2;
	add_edge(f,l,1);add_edge(l,f,0);
}
bool bfs(){
	memset(vu,0,sizeof(vu));
	queue<int> qo;
	qo.push(s);vu[s]=1;
	while(!qo.empty()){
		int x=qo.front();qo.pop();
		if(x==t) return 1;
		for(int i=head[x];i;i=edges[i].nxt){
			int l=edges[i].l,w=edges[i].w;
			if(!w||vu[l]) continue;
			vu[l]=vu[x]+1;qo.push(l);
		}
	}
	return 0;
}
int dfs(int las,int x,int mf,int an=0){
	if(x==t) return mf;
	for(int i=cur[x];i;i=edges[i].nxt){
		cur[x]=i;
		int l=edges[i].l,w=edges[i].w;
		if(vu[l]!=vu[x]+1||!w) continue;
		int f=min(mf,w);f=dfs(x,l,f);
		mf-=f,an+=f;
		edges[i].w-=f,edges[i^1].w+=f;
		if(!mf) break;
	}
	if(!an) vu[x]=0;
	return an;
}
int Dinic(int ans=0){
	while(bfs()){
		memcpy(cur,head,sizeof(head));
		ans+=dfs(0,s,inf);
	}
	return ans;
}
void dfs2(int x){
	if(st[x]) return;
	st[x]=1;
	for(int i=head[x];i;i=edges[i].nxt){
		int l=edges[i].l,w=edges[i].w;
		if(l==s||l==t) continue;
		dfs2(pr[l]);
	}
}
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);  
	cin>>n>>m;char a;int tot=0;
	s=n*m+1,t=n*m+2;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cin>>a;
			if(a=='#') mp[i][j]=1,tot++;
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=((i%2)^1)+1;j<=m;j+=2){
			if(mp[i][j]) continue;
			pp[i][j]=1;
			for(int k=0;k<4;k++)
				add(i,j,i+pos[k][0],j+pos[k][1]);
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if(mp[i][j]) continue;
			if(!pp[i][j]){
				add_edge((i-1)*m+j,t,1);
				add_edge(t,(i-1)*m+j,0);
			}
			else{
				add_edge(s,(i-1)*m+j,1);
				add_edge((i-1)*m+j,s,0);
			}
		}
	}
	if(n*n-tot-2*Dinic()==0){cout<<"LOSE\n";exit(0);}
	cout<<"WIN\n";
	for(int i=head[s];i;i=edges[i].nxt){
		int x=edges[i].l;
		for(int j=head[x];j;j=edges[j].nxt){
			int l=edges[j].l;
			if(s==l||t==l||edges[j].w) continue;
			pr[x]=l;
		}
	}
	for(int i=head[t];i;i=edges[i].nxt){
		int x=edges[i].l;
		for(int j=head[x];j;j=edges[j].nxt){
			int l=edges[j].l;
			if(s==l||t==l||edges[j^1].w) continue;
			pr[x]=l;
		}
	}
	for(int i=head[s];i;i=edges[i].nxt){
		int l=edges[i].l,w=edges[i].w;
		if(w) dfs2(l);
	}
	for(int i=head[t];i;i=edges[i].nxt){
		int l=edges[i].l,w=edges[i].w;
		if(!w) dfs2(l);
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			int x=(i-1)*m+j;
			if(st[x]) cout<<i<<" "<<j<<endl;
		}
	}
	return 0; 
}
```

---

## 作者：封禁用户 (赞：0)

在无向图上称为无向图地理游戏（UVG 游戏）。

具体证明如下：

### UVG 游戏
全名：Undirected Vertex Geography Game

无向图地理游戏，指在一个无向图中，只有一个起点，上面有一个棋子，两个玩家轮流沿着边推动棋子，不能走重复的点，无法行动则失败。

### 结论
如果无向图 $G$ 的所有最大匹配都经过起点，则先手必胜；否则如果存在一组最大匹配使得该匹配不经过起点，则先手必败。

### 证明
仍然从两个方面来证明充要，采用反证法。

+ 无向图 $G$ 的所有最大匹配都经过起点，则先手必胜。

证明：先手策略为 move-along，即顺着最大匹配走，此时后手一定走了一条非匹配边。

假设先手失败，则当前仅当走到了一个非匹配点，此时没有另外的出边了，但是注意到我们可以将走过的路径反转，这样仍然是最大匹配，且不再经过起点，所以假设不成立，先手必胜。

+ $G$ 存在一组最大匹配使得该匹配不经过起点，则先手必败。

证明：先手随便选一个点走，此时后手策略为 move-along $MM$，假设先手获胜，则一定走到了一个非匹配点，而起点也是非匹配点，容易发现这是一条增广路，可以将匹配扩大，所以不符合最大匹配，假设不成立，先手必败。


因此本题只需要判断每个点是否在二分图所有的最大匹配中，每次删掉一个点暴力增广一次即可。

### Code
```cpp
#include <bits/stdc++.h>
#define pii pair<int,int>
using namespace std;
const int N=5e3+5,M=1e5+5;
int n,m;
char s[N][N];
int id[N][N];
int tot;
vector<int> g[M];
vector<pii> st;
int xlink[M],ylink[M],pre[M];
queue<int> q;
bool check(int y){
	if(ylink[y]){
		q.push(ylink[y]);
		return 0;
	}
	while(y){
		ylink[y]=pre[y];
		swap(xlink[pre[y]],y);
	}
	return 1;
}
int bfs(int p){
	while(!q.empty()) q.pop();
	for(int i=1;i<=tot;i++){
		if(i==p) continue;
		if(!xlink[i]) q.push(i);
		pre[i]=0;
	}
	while(!q.empty()){
		int x=q.front();
		q.pop();
		for(auto y:g[x]){
			if(y==p||pre[y]) continue;
			pre[y]=x;
			if(check(y)) return 1;
		}
	}
	return 0;
}
int work(int x){
	int cnt=0;
	for(int i=1;i<=tot;i++) xlink[i]=ylink[i]=pre[i]=0;
	while(bfs(x)) cnt++;
	return cnt;
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++){
		scanf("%s",s[i]+1);
		for(int j=1;j<=m;j++) if(s[i][j]!='#') id[i][j]=++tot;
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if(i+j&1){
				if(id[i-1][j]) g[id[i][j]].push_back(id[i-1][j]);
				if(id[i][j-1]) g[id[i][j]].push_back(id[i][j-1]);
				if(id[i+1][j]) g[id[i][j]].push_back(id[i+1][j]);
				if(id[i][j+1]) g[id[i][j]].push_back(id[i][j+1]);
			}
		}
	}
	int cnt=work(0);
	//printf("%d\n",cnt);
	//for(int i=1;i<=tot;i++) printf("%d %d %d\n",i,xlink[i],g[i].size());
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if(s[i][j]=='#') continue;
			int x=id[i][j];
			if(i+j&1){
				if(xlink[x]){
					int y=xlink[x];
					xlink[x]=0,ylink[y]=0;
					if(bfs(x)) st.push_back({i,j});
					else xlink[x]=y,ylink[y]=x;
				}else st.push_back({i,j});
			}else{
				int y=x;
				if(ylink[y]){
					x=ylink[y];
					xlink[x]=0,ylink[y]=0;
					if(bfs(y)) st.push_back({i,j});
					else xlink[x]=y,ylink[y]=x;
				}else st.push_back({i,j});				
			}
			//if(cnt==work(id[i][j])) st.push_back({i,j});
			//printf("%d %d %d %d\n",i,j,cnt,work(id[i][j]));
		}
	}
	if(st.empty()) printf("LOSE");
	else{
		printf("WIN\n");
		for(auto tmp:st) printf("%d %d\n",tmp.first,tmp.second);
	}
	return 0;
}
```

---


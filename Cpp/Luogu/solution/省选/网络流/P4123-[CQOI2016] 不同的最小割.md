# [CQOI2016] 不同的最小割

## 题目描述

学过图论的同学都知道最小割的概念：对于一个图，某个对图中结点的划分将图中所有结点分成两个部分，如果结点 $s,t$ 不在同一个部分中，则称这个划分是关于 $s,t$ 的割。对于带权图来说，将所有顶点处在不同部分的边的权值相加所得到的值定义为这个割的容量，而 $s,t$ 的最小割指的是在关于 $s,t$ 的割中容量最小的割。

而对冲刺 NOI 竞赛的选手而言，求带权图中两点的最小割已经不是什么难事了。我们可以把视野放宽，考虑有 $N$ 个点的无向连通图中所有点对的最小割的容量，共能得到 $N(N-1)/2$ 个数值。这些数值中互不相同的有多少个呢？这似乎是个有趣的问题。

## 说明/提示

$1\leq N\leq 850,1\leq M\leq 8500,1\leq w\leq 100000$。

## 样例 #1

### 输入

```
4 4
1 2 3
1 3 6
2 4 5
3 4 4```

### 输出

```
3```

# 题解

## 作者：shadowice1984 (赞：15)

你要相信一件事，dinic的渐进复杂度**下界**是O(V^2E)不是，一般情况下跑的比香港记者还快……，比如这道题的渐进复杂度是O(V^2E^2)……但是你可以凭借信仰过去

## 最小割树

最短路有最短路径树，那么最小割也有最小割树，我们考虑这样一个过程，我们现在做完了一个最小割，那么我们根据最小割的定义，我们可以推出来这样一个事实，如果原来的图是一个连通图，那么我们会发现，整个图被分为了两个联通块，而且只能分为两个联通块

那么这种做一个操作使得联通块一分为二的想法，让我们很自然的想到了树的一个性质，删一条边，整棵树分为两个联通块

那么我们似乎发现一件事，如果我们将最小割视为一条边，那么我们可以以一种奇妙的方式将无向图最小割间的逻辑关系映射到一只树上

具体来讲，对于树上**任意**两个相邻的节点S，T，我们满足删去它们之间的边之后两个**不联通点集**分布情况和对这个图执行一个S-T最小割之后，无向图分裂为的两个**不联通点集**的点分布情况相等，并且这个边的边权等于最小割

(通俗一点讲，最小割操作之后图分为两个联通块，删边操作后树分裂为两个联通块，我们通过一些技巧保证这4个联通块在点集意义上相等)

那么我们现在至少对于N-1个点，我们已经确保了对它们执行删边操作完全等价于执行最小割了，现在我们考虑树上任意两点u-v，我们枚举删除路径上的随意一条边，会发现这样相当于枚举删除后联通块情况，因此**选取最小的边**割掉即可

(也可用反证法，如果路径上的所有值都小于u-v最小割，由于割后必然分开了路径上的一些点，因此也就找出了新的最小割，与原来任意相邻点的边权都是最小割矛盾，得证)

现在我们发现对于最小割树上任意两点，最小割总是等于树上路径边权最小值，此时我们不要犯傻去写个倍增，而是采取**枚举最小值**，由于每个边权都有可能成为最小值，所以我们呢只需unique一下这个边权就好，或者可以直接set在线维护

## 求最小割树

答案很简单，分治

为什么是分治？，请注意我们在映射的时候是如何映射的，我们要求删掉这条边后联通块分布是等价于最小割的，因此我们可以这样做，我们一开始随便选两个点，之后跑一个最小割，那么此时我们分裂为两个点集，由于树的特点，我们不可以在两个点集之间再次连边，所以我们再次在两个点集间任意选择点连边即可，以后每次递归处理问题，只要保证分开的点集不会被再次连边即可

确定分开点集的方式，残量网络上和s相连的归到一个点集，然后补集归到T的点集，可以证明这总是一种可行方案

连边操作是在原图上跑最小割，因为**我们连边本来是没有次序的**，我们的映射保证的相邻点删边在点集意义上等价于相邻点最小割，而这个最小割明显是全图意义的。

那么具体来讲肯定有一些trick啦，比如写代码的时候每次按深度排一下序，那么我们呢会发现两个点集以深度是否为∞分成了两个区间，此时我们就可以像CDQ分治一样写这个程序了

本体中由于只是统计边的值种类，不需要真的把树建出来

剩下的细节就交给代码好了233

上代码~

```C
#include<cstdio>
#include<algorithm>
#include<set>
#include<queue>
using namespace std;
const int N=900;const int M=9000;
struct data{int v;int nxt;int cot;}edge[2*M];
int alist[N];int cnt=1;int reset[2*M];int n;int m;
inline void add(int u,int v,int cot)
{
    edge[++cnt].v=v;edge[cnt].nxt=alist[u];alist[u]=cnt;edge[cnt].cot=cot;reset[cnt]=cot;
    edge[++cnt].v=u;edge[cnt].nxt=alist[v];alist[v]=cnt;edge[cnt].cot=cot;reset[cnt]=cot;
}int dep[N];queue <int> q;int a[N];//按深度排序 
inline bool cmp(int a,int b){return dep[a]<dep[b];}
inline bool bfs(int s,int t)//dinic板子 
{
    for(int i=1;i<=n;i++){dep[i]=0x3f3f3f3f;}
    dep[s]=0;q.push(s);
    while(!q.empty())
    {
        int now=q.front();q.pop();int nxt=alist[now];
        while(nxt)
        {
            int v=edge[nxt].v;int cot=edge[nxt].cot;
            if(dep[v]==0x3f3f3f3f&&cot!=0)
            {dep[v]=dep[now]+1;q.push(v);}
            nxt=edge[nxt].nxt;
        }
    }return dep[t]!=0x3f3f3f3f;
}
int dfs(int x,int t,int lim)
{
    if(x==t){return lim;}int nxt=alist[x];int nowflow=0;
    while(nxt)
    {
        if(lim==0)break;
        int v=edge[nxt].v;int cot=edge[nxt].cot;
        if(dep[v]==dep[x]+1&&cot!=0)
        {
            int del=dfs(v,t,min(lim,cot));lim-=del;nowflow+=del;
            edge[nxt].cot-=del;edge[nxt^1].cot+=del;
        }nxt=edge[nxt].nxt;
    }if(nowflow==0){dep[x]=0x3f3f3f3f;}
    return nowflow;
}set <int> se;
inline void solve(int l,int r)//由于按深度排序了，一个点集就是一个区间 
{
    if(r==l){return;}int res=0;int s=a[l];int nxt=alist[a[l]];
    while(bfs(a[l],a[r])){res+=dfs(a[l],a[r],0x3f3f3f3f);}//计算边权 
    se.insert(res);sort(a+l,a+r+1,cmp);int cut;//暴力找分割点了，懒得写lower_bound 
    for(int i=l;i<=r;i++){if(dep[a[i]]==0x3f3f3f3f){cut=i;break;}}
    for(int i=1;i<=cnt;i++){edge[i].cot=reset[i];}//记得复位整个图 
	solve(l,cut-1);solve(cut,r);//然后分治就好了 
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++)
    {int u;int v;int cot;scanf("%d%d%d",&u,&v,&cot);add(u,v,cot);}
    for(int i=1;i<=n;i++){a[i]=i;}solve(1,n);//初始化点集 
    printf("%d",se.size());return 0;//拜拜程序~ 
}
```


---

## 作者：agicy (赞：8)

update:在 2021 年 1 月 4 日更新挂掉的图像。

[点此食用更佳](https://www.lu-anlai.com/oi/solution/luogu-p4123/)

题目链接：[Luogu P4123](https://www.luogu.com.cn/problem/P4123)/[BZOJ 4519](https://www.lydsy.com/JudgeOnline/problem.php?id=4519)/[LibreOJ 2042](https://loj.ac/problem/2042)/CQOI D1T1

# 题目

## 题意简述

一张 $n$ 个点 $m$ 条边的图，每一对点的最小割中，有多少个互不相同。

## 数据范围

$$1\leq n\leq 850$$
$$1\leq m\leq 8500$$
$$1\leq w\leq 10^5$$

## 时空限制

$$\text{Luogu}:3\text{s}/500\text{MiB}$$
$$\text{BZOJ}:20\text{s}/512\text{MiB}$$
$$\text{LibreOJ}:1\text{s}/256\text{MiB}$$

# 题解

## 思路

下面先介绍**最小割树**。

显然，对于某一个点来说，如果我们将它与另外一个点先求一遍最小割，那么整个图将会变成具有两个残留网络（如果原图不连通将会有更多）。

形如下面这个样子：

![Luogu-P4123-Z1.webp](https://www.lu-anlai.com/wp-content/uploads/2020/05/Luogu-P4123-Z1.webp)

其中 $1$ 和 $2$ 的最小割为 $4$，有两种割法（用红、蓝标识）。而残余的边则分别属于两个联通块，下面我们用蓝组割法为例。

![Luogu-P4123-Z2.webp](https://www.lu-anlai.com/wp-content/uploads/2020/05/Luogu-P4123-Z2.webp)

为了生成最小割树，我们应该向最小割树中的 $1$ 和 $2$ 连一条边权为 $4$ 的边。

再举一个例子。

![Luogu-P4123-Z3.webp](https://www.lu-anlai.com/wp-content/uploads/2020/05/Luogu-P4123-Z3.webp)

$1$ 和 $3$ 的最小割为 $9$，所以我们应该向最小割树中的 $1$ 和 $3$ 连一条边权为 $9$ 的边。

最后生成的最小割树长下面这个样子。

![Luogu-P4123-Z4.webp](https://www.lu-anlai.com/wp-content/uploads/2020/05/Luogu-P4123-Z4.webp)

我们可以发现，**每对点间路径的边权最小值即为它们之间的最小割**。

当然本题并不需要生成最小割树，只需要按层次来构造这棵树即可，保留边权，用 `std::set` 统计答案。

最后提醒一下，因为本题是无向边，所以反向边流量直接设成 $w_i$ 即可，防止加更多的边浪费空间。

## 代码

鉴于使用了网络流，本题不分析时间复杂度。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define reg register
typedef long long ll;
typedef unsigned long long ull;
#define INF 0X3F3F3F3F
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++)
static char buf[100000],*p1=buf,*p2=buf;
inline int read(void){ //读入优化
	reg bool f=false;
	reg char ch=getchar();
	reg int res=0;
	while(ch<'0'||'9'<ch)f|=(ch=='-'),ch=getchar();
	while('0'<=ch&&ch<='9')res=10*res+ch-'0',ch=getchar();
	return f?-res:res;
}

const int MAXN=850+5; //点数数据范围
const int MAXM=8500+5; //边数数数据范围

inline void Read(void);
inline void Work(void);

int main(void){
	Read();
	Work();
	return 0;
}

int n,m;
int cnt=1,head[MAXN],to[MAXM<<1],w[MAXM<<1],W[MAXM<<1],Next[MAXM<<1]; //邻接表存边

inline void Add_Edge(reg int u,reg int v,reg int len){
	Next[++cnt]=head[u];
	to[cnt]=v;
	w[cnt]=len;
	W[cnt]=len; //用 W[] 存储原图的边权，防止 Dinic 后边权出现变化
	head[u]=cnt;
	return;
}

inline void Add_Tube(reg int u,reg int v,reg int len){
	Add_Edge(u,v,len); //正常的边
	Add_Edge(v,u,len); //本题是无向边，所以反向边流量直接设为 w，防止加更多的边浪费空间。
	return;
}

inline void Read(void){
	n=read(),m=read();
	for(reg int i=1;i<=m;++i){ //按照要求读入
		static int u,v,w;
		u=read(),v=read(),w=read();
		Add_Tube(u,v,w); //加边
	}
	return;
}

int dep[MAXN];
queue<int> Q;

inline bool BFS(int s,reg int t){ //BFS 判断是否联通
	memset(dep,-1,sizeof(dep));
	while(!Q.empty())Q.pop();
	dep[s]=1,Q.push(s);
	while(!Q.empty()){
		reg int ID=Q.front();
		Q.pop();
		for(reg int i=head[ID];i;i=Next[i])
			if(dep[to[i]]==-1&&w[i]>0){
				dep[to[i]]=dep[ID]+1;
				Q.push(to[i]);
			}
	}
	return dep[t]!=-1; //返回汇点是否可达
}

int cur[MAXN]; //用于当前弧优化

inline int DFS(reg int ID,reg int t,reg int lim){
	if(ID==t)
		return lim;
	reg int flow=0;
	for(reg int &i=cur[ID];i;i=Next[i])
		if(dep[to[i]]==dep[ID]+1&&w[i]>0){
			reg int f=DFS(to[i],t,min(lim-flow,w[i]));
			if(f){
				flow+=f;
				w[i]-=f;
				w[i^1]+=f;
				if(flow==lim)
					break;
			}
		}
	return flow;
}

inline int Dinic(reg int s,reg int t){
	reg int res=0;
	while(BFS(s,t)){
		memcpy(cur,head,sizeof(head)); //复制邻接表表头
		res+=DFS(s,t,INF);
	}
	return res;
}

bool vis[MAXN];

inline void DFS(reg int ID){
	vis[ID]=true;
	for(reg int i=head[ID];i;i=Next[i])
		if(!vis[to[i]]&&w[i]>0)
			DFS(to[i]);
	return;
}

int fa[MAXN];
set<int> S;

inline void Work(void){
	for(reg int i=2;i<=n;++i)
		fa[i]=1; //初始化
	for(reg int i=2;i<=n;++i){
		reg int s=i,t=fa[i]; //求最小割的点对
		memcpy(w,W,sizeof(W)); //拷贝边权
		int ans=Dinic(s,t); //记录最小割
		S.insert(ans); //插入 set
		memset(vis,false,sizeof(vis)); //清空标记
		DFS(s); //开始寻找被隔开的点对
		for(reg int j=i;j<=n;++j)
			if(fa[j]==t&&vis[j])
				fa[j]=s;
	}
	printf("%d\n",(int)S.size()); //输出多少种，set 自动去重
	return;
}
```

---

## 作者：Orion545 (赞：6)

# 广告

[蒟蒻のblog](http://www.cnblogs.com/dedicatus545/p/8760390.html)

# 正文

首先我们明确一点：这道题不是让你把$n^2$个最小割跑一遍【废话】

但是最小割过程是必要的，因为最小割并没有别的效率更高的算法(Stoer-Wagner之类的？)

那我们就要尽量找办法减少做最大流（求最小割）的次数

# 最小割树

就像最小生成树一样，最小割也有自己的生成树

我们新建立一个有n个点，没有边的无向图

我们在原无向图中任选两个点S,T，求出S-T最小割，那么可以在S-T中间加一条权值等于最小割值得无向边

然后，分别对S属于的点集合和T属于的点集合递归做上面的过程，直到当前处理的集合只剩下一个点了

现在，对于这棵新树（显然是一棵树，可以自己退一下为什么），有一个结论：

树上任意两个点在原图中的对应点之间的最小割值等于这两个点的树上路径中边权的最小值

证明？我也不知道啊！

但是这个算法的正确性是可以保证的（你也可以感性理解一下qwq）

# 做法

有了这个“大杀器”以后，这道题也就迎刃而解了~

因为它需要求不同的种类数，因此我们只要把所有搞出来的最小割值放到一个set里面，最后set的size就是种类数（答案）了

# Code

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<set>
#define inf 1e9
inline int read(){
	int re=0,flag=1;char ch=getchar();
	while(ch>'9'||ch<'0'){
		if(ch=='-') flag=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9') re=(re<<1)+(re<<3)+ch-'0',ch=getchar();
	return re*flag;
}
int n,m,cnt=-1,dep[1010],first[1010],cur[1010],vis[1010];
std::set<int>s;
struct edge{
	int to,next,w,W;
}a[20010];
inline void add(int u,int v,int w){
	a[++cnt]=(edge){v,first[u],w,w};first[u]=cnt;
	a[++cnt]=(edge){u,first[v],w,w};first[v]=cnt;
}
void clear(){
	for(int i=0;i<=cnt;i++) a[i].w=a[i].W;
}
bool bfs(int s,int t){
	int q[1010],head=0,tail=1,i,u,v;
	for(i=1;i<=n;i++) dep[i]=-1,cur[i]=first[i];
	q[0]=s;dep[s]=0;
	while(head<tail){
		u=q[head++];
		for(i=first[u];~i;i=a[i].next){
			v=a[i].to;
			if(~dep[v]||!a[i].w) continue;
			dep[v]=dep[u]+1;q[tail++]=v;
		}
	}
	return ~dep[t];
}
int _min(int l,int r){return (l>r)?r:l;}
int dfs(int u,int t,int limit){
	if(u==t||!limit) return limit;
	int i,v,f,flow=0;
	for(i=cur[u];~i;i=a[i].next){
		v=a[i].to;cur[u]=i;
		if(dep[v]==dep[u]+1&&(f=dfs(v,t,_min(limit,a[i].w)))){
			a[i].w-=f;a[i^1].w+=f;
			flow+=f;limit-=f;
			if(!limit) return flow;
		}
	}
	return flow;
}
int dinic(int s,int t){
	int re=0;
	while(bfs(s,t)) re+=dfs(s,t,inf);
	return re;
}
void find(int u){
	int i,v;vis[u]=1;
	for(i=first[u];~i;i=a[i].next){
		v=a[i].to;
		if(!vis[v]&&a[i].w) find(v);
	}
}
void check(int ss,int tt){
	clear();
	s.insert(dinic(ss,tt));
	memset(vis,0,sizeof(vis));
	find(ss);
}
int p[1010];
int main(){
	memset(first,-1,sizeof(first));memset(vis,1,sizeof(vis));
	int i,t1,t2,t3,ss,tt,j;
	n=read();m=read();
	for(i=1;i<=m;i++){
		t1=read();t2=read();t3=read();
		add(t1,t2,t3);
	}
	for(i=2;i<=n;i++) p[i]=1;
	for(i=2;i<=n;i++){
		ss=i;tt=p[i];
		check(ss,tt);
		for(j=i;j<=n;j++)
			if(p[j]==tt&&vis[j]) p[j]=ss;
	}
	std::cout<<s.size();
}
```

---

## 作者：EnofTaiPeople (赞：3)

首先明确最小割树的定义：对于任意树上的边 $(u,v)$，删除图上的点 $u,v$，树上的边 $(u,v)$，之后，图会分成两部分，一部分在树上与 $u$ 连通，另一部分在树上与 $v$ 连通，树上边 $(u,v)$ 的边权为图上 $u,v$ 之间的最小割。

同时，图上任意两点的最小割是它们的树上路径边权最小值。

于是，只要将树建出来，就可以实现 $O(1)$ 查询最小割啦！

问题来了：怎么建树？

事实上，最小割树的性质告诉我们，其实只要不断加边就可以了，具体做法是：

1. 定义 $build(l,r)$ 为将区间 $[l,r]$的节点建树；
2. 求出 $MinCut(a_l,a_r)$；
3. 判断 $[l,r]$ 中那些点与 $a_l$ 连通，那些点与 $a_r$ 连通，并将其划分为 $[l,lc],[rc,r]$，可以用最后一次广搜节点是否被搜到为标准判断；
4. 递归：$build(l,lc),build(rc,r)$；
5. $n$ 遍深搜求出树上任意两点路径上的最小边权。

然后查询就可以啦！

##   code
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1005,M=30005;
char buf[M+5],*p1,*p2,c;
#define gc (p1==p2&&(p2=(p1=buf)+fread(buf,1,M,stdin),p1==p2)?EOF:*p1++)
inline int read(){
	int x=0;while(!isdigit(c=gc));
	do x=x*10+(48^c);while(isdigit(c=gc));return x;
}
int ed[M],w[M],tot,n,m,s,t,a[N],b[N];
vector<int>lk[N];
int q[N],l,r,d[N],now[N],sz[N],gt;
struct Eg{int u,v,w;}eg[N]; 
inline bool bfs(){
	int x,y;
	for(x=1;x<=n;++x)d[x]=now[x]=0;
	d[q[l=r=1]=t]=1;
	while(l<=r){
		x=q[l++];
		for(int i:lk[x])
			if(w[i^1]&&!d[y=ed[i]]){
				d[q[++r]=y]=d[x]+1;
				if(y==s)return 1;
			}
	}return 0;
} 
int disp(int x,int fl){
	if(x==t)return fl;
	int i,y,k,rs=fl;
	for(int &g=now[x];g<sz[x];++g)
		if(w[i=lk[x][g]]&&d[y=ed[i]]==d[x]-1)
			if(k=disp(y,min(w[i],rs))){
				w[i]-=k,w[i^1]+=k;
				if(!(rs-=k))return fl;
			}
	d[x]=0;return fl-rs;
}
void build(int l,int r){
	if(l>=r)return;int i,lc=l-1,rc=r+1;
	eg[++gt]={s=a[l],t=a[r]};
	while(bfs())eg[gt].w+=disp(s,INT_MAX);
	for(i=l;i<=r;++i)
		b[d[a[i]]?--rc:++lc]=a[i];
	for(i=l;i<=r;++i)a[i]=b[i];
	for(i=1;i<=m;++i)
		w[i+i]+=w[i+i+1]-w[i+i]>>1,w[i+i+1]=w[i+i];
	return build(l,lc),build(rc,r);
}
set<int>ans;
void dfs(int x,int pr,int mc){
	int y;ans.insert(mc);
	for(int i:lk[x])
		if((y=ed[i])!=pr)
			dfs(y,x,min(w[i],mc));
}
int main(){
	n=read(),m=read();int i;
	for(i=1;i<=m;++i){
		lk[ed[i+i]=read()].push_back(i+i+1);
		lk[ed[i+i+1]=read()].push_back(i+i);
		w[i+i]=w[i+i+1]=read();
	}
	for(i=1;i<=n;++i)sz[a[i]=i]=lk[i].size();
	build(1,n);
	for(i=1;i<=n;++i)lk[i].clear();
	for(i=1;i<n;++i){
		w[i+i]=w[i+i+1]=eg[i].w;
		lk[ed[i+i]=eg[i].v].push_back(i+i+1);
		lk[ed[i+i+1]=eg[i].u].push_back(i+i);
	}
	for(i=1;i<=n;++i)dfs(i,0,INT_MAX);
	printf("%llu\n",ans.size()-1);
	return 0;
}
```

---

## 作者：mkx2023275 (赞：2)

# 最小割树

设求一对点最小割的时间复杂度为 $O(t)$，则最小割树可以用 $O(nt)$ 的时间复杂度求出任意两个点的最小割，相比于枚举点对依次求最小割的 $O(n ^ 2 t)$ 效率更高。

## 算法流程

### 分治

我们假设有一张需要求解的图。

![](https://cdn.luogu.com.cn/upload/image_hosting/2cp0d3a4.png)

我们任意取两个点，并求最小割。

![](https://cdn.luogu.com.cn/upload/image_hosting/pjbvfu9l.png)

其中 $S$ 和 $T$ 表示要求最小割的两个点，红色点和蓝色点表示被割开的两部分，绿色代表割边。

此时我们发现，任意一个红点和一个蓝点的最小割一定不大于 $S$ 到 $T$ 的最小割，原因也很简单，任意一对红蓝点都可以通过上面的方式割开。

但是我们只知道答案上界，求具体值还需要把左面集合和右面集合取两点的情况计算。于是我们分别递归红色和蓝色求解。以红色为例，还是选择两个点，此时一个要求是原来选过的 $S$，另一个我们设为 $F$。求 $S$ 和 $F$ 的最小割，割边用紫色表示，用灰色框表示割开的两个集合。

![](https://cdn.luogu.com.cn/upload/image_hosting/i76pjg8f.png)

此时和之前一样，我们发现，在不同集合内的最小割不超过 $S$ 和 $F$ 的最小割，证明同上。然后再往下递归，右面同理。递归结束后，所有限制所构成的上界就是答案。

### 建树

此时我们突然发现，这些点可以构造一棵带边权的树，使得任意两个点之间的所有边权的最小值正好为这两个点的最小割，构造方法如下：

1. 按上面方法取 $S$ 和 $T$ 并求出最小割。
2. 将 $S$ 和 $T$ 之间连一条边权为最小割的边。
3. 分别递归割开的两个集合，重复以上操作。

然后直接求树上两个点之间的最小边权即可。

## 代码实现

其实这题不需要真正将树建出来，直接用 $ans$ 数组维护就行，具体看代码。

还有一点是 $S$ 和 $T$ 的取值。使用数组维护递归点集，每次取数组的前两项，这样的话求往下递归的两部分时如果从前往后枚举每一项，$S$ 和 $T$ 都会跑到最前面，下一次递归就又能取到了。

把所有最小割的值放到一个数组里，排序去重。

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 860, M = 8510 * 4, INF = 2e9;

int n, m, S, T, Q;
int h[N], e[M], f[M], ne[M], idx;
int q[N], d[N], cur[N];
int ans[N][N], q3[N], q1[N], q2[N];
int res[N * N];

void add(int a, int b, int c)
{
    e[idx] = b, f[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
    e[idx] = a, f[idx] = 0, ne[idx] = h[b], h[b] = idx ++ ;
}

bool bfs()
{
    int hh = 0, tt = 0;
    memset(d, -1, sizeof d);
    q[0] = S, d[S] = 1, cur[S] = h[S];
    while (hh <= tt)
    {
        int t = q[hh ++ ];
        for (int i = h[t]; ~i; i = ne[i])
        {
            int ver = e[i];
            if (d[ver] == -1 && f[i])
            {
                d[ver] = d[t] + 1;
                cur[ver] = h[ver];
                if (ver == T)  return true;
                q[ ++ tt] = ver;
            }
        }
    }
    return false;
}

int find(int u, int limit)
{
    if (u == T) return limit;
    int flow = 0;
    for (int i = cur[u]; ~i && flow < limit; i = ne[i])
    {
        cur[u] = i;
        int ver = e[i];
        if (d[ver] == d[u] + 1 && f[i])
        {
            int t = find(ver, min(f[i], limit - flow));
            if (!t) d[ver] = -1;
            f[i] -= t, f[i ^ 1] += t, flow += t;
        }
    }
    return flow;
}

int dinic()
{
	for (int i = 0; i < idx; i += 2)
		f[i] = (f[i] + f[i ^ 1]), f[i ^ 1] = 0;
    int r = 0, flow;
    while (bfs()) while (flow = find(S, INF)) r += flow;
    return r;
}

void solve(int l, int r)
{
	if (l == r) return;
	S = q3[l], T = q3[l + 1];
	int t = dinic(), ss = q3[l], tt = q3[l + 1];
	ans[S][T] = ans[T][S] = t;
	int top1 = 0, top2 = 0;
	for (int i = l; i <= r; i ++ )
		if (d[q3[i]] >= 0) q1[ ++ top1] = q3[i];
		else q2[ ++ top2] = q3[i];
	for (int i = 1; i <= top1; i ++ ) q3[i + l - 1] = q1[i];
	for (int i = 1; i <= top2; i ++ ) q3[top1 + i + l - 1] = q2[i];
	solve(l, l + top1 - 1), solve(l + top1, r);
	for (int i = 1; i <= top1; i ++ )
		for (int j = 1; j <= top2; j ++ )
		{
			int ii = q3[i + l - 1], jj = q3[j + top1 + l - 1];
			ans[ii][jj] = ans[jj][ii] = min(min(ans[ii][ss], ans[tt][jj]), ans[ss][tt]);
		}
}

int main()
{
    scanf("%d%d", &n, &m);
    memset(h, -1, sizeof h);
    memset(ans, 0x3f, sizeof ans);
    while (m -- )
    {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        add(a, b, c), add(b, a, c);
    }
    for (int i = 1; i <= n; i ++ ) q3[i] = i;
    
    solve(1, n);
    
    int top = 0;
    for (int i = 1; i <= n; i ++ )
    	for (int j = i + 1; j <= n; j ++ )
    		res[ ++ top] = ans[i][j];
    sort(res + 1, res + 1 + top);
    top = unique(res + 1, res + 1 + top) - res - 1;
    
    printf("%d\n", top);
	
    return 0;
}
```

---

## 作者：LEWISAK (赞：1)

广告：[myblog](https://www.cnblogs.com/lewisak)

ISAP 代码。

## 题目大意

求对于所有点对的最小割的不同值个数

## 题解

这里要介绍一个新科技，最小割树。

我们注意到最小割会将图分为两个联通块，如果我们把联通块视为子树，最小割视为边，那么你会发现这就是一颗树！

具体实现上，为了方便我们找 $s$ 和 $t$ 分别的联通块，考虑割完后从 $s$ 为起点跑 bfs 求深度后将点按深度排序把不能到达的扔后面，于是 $s$ 的联通块就是左子树，$t$ 所在的联通块就是右子树，在建树时把所有最小割存进 set 里，答案即为 set 的大小。（set 自动去重）

### 代码

```cpp
#include<bits/stdc++.h>
//#define int long long
//↑被卡常力
using namespace std;
namespace kong{bool st;}
namespace zhu{
int n,m,head[1001000],lead[1001000],dep[1001000],gap[1001000],a[1001000],tot=1,inf,yuan[2002000];
set<int> se;
queue<int> q;
struct{
	int nxt,to,w,fr;
}e[2002000];
void add(int u,int v,int w){
	e[++tot]={head[u],v,w,u};
	yuan[tot]=w;
	head[u]=tot;
	e[++tot]={head[v],u,w,v};
	yuan[tot]=w;
	head[v]=tot;
	return;
}
void bfs(int t,int flag){
//flag 为 1 时是正向跑，反之为反向跑（ISAP 需要）
	q.push(t);
	dep[t]=1;
	gap[1]++;
	while(!q.empty()){
		int x=q.front();
		q.pop();
		for(int i=head[x];i;i=e[i].nxt){
			int v=e[i].to,w=e[i].w;
			if(dep[v]==inf&&(flag||w)){
				q.push(v);
				dep[v]=dep[x]+1;
				gap[dep[v]]++;
			}
		}
	}
	return;
}
int dfs(int x,int s,int t,int flow){//ISAP 板子
	if(x==t) return flow;
	int rest=flow;
	for(int i=lead[x];i&&rest;i=e[i].nxt){
		lead[x]=i;
		int v=e[i].to,w=e[i].w;
		if(dep[x]==dep[v]+1&&w>0){
			int k=dfs(v,s,t,min(rest,w));
			rest-=k;
			e[i].w-=k;
			e[i^1].w+=k;
		}
	}
	if(rest){
		gap[dep[x]]--;
		if(!gap[dep[x]]){
			dep[s]=n+1;
		}
		dep[x]++;
		gap[dep[x]]++;
	}
	return flow-rest;
}
int ISAP(int s,int t){
	int ans=0;
	memset(dep,0,sizeof(dep));
	memset(gap,0,sizeof(gap));
	inf=dep[0];
	bfs(t,1);
	while(dep[s]<=n){
		for(int i=1;i<=n;i++){
			lead[i]=head[i];
		}
		ans+=dfs(s,s,t,1e18);
	}
	memset(dep,0x3f,sizeof(dep));//ISAP 求的 dep是错的，要重新求。
	memset(gap,0,sizeof(gap));
	inf=dep[0];
	bfs(s,0);
	return ans;
}
bool cmp(int x,int y){
	return dep[x]<dep[y];
}
void solve(int l,int r){
	if(r==l) return;
//	cout<<a[l]<<" "<<a[r]<<'\n';
	int ans=ISAP(a[l],a[r]),cut=0;
//	for(int i=l;i<=r;i++){
//		cout<<dep[i]<<' ';
//	}
//	cout<<'\n';
	se.insert(ans);
	sort(a+l,a+r+1,cmp);
	for(int i=l;i<=r;i++){//找分割点
		if(dep[a[i]]==inf){
			cut=i;
			break;
		}
	}
	for(int i=1;i<=tot;i++){//最大流会更改边权，记得还原！
		e[i].w=yuan[i];
	}
	solve(l,cut-1);solve(cut,r);
}
string main(){//没有防抄袭，这是 namespace 里的假主函数
	cin>>n>>m;
	for(int i=1;i<=m;i++){
		int u,v,w;
		cin>>u>>v>>w;
		add(u,v,w);
		a[i]=i;
	}
	solve(1,n);
	cout<<se.size()<<'\n';
	return "我们来玩「乙女解剖」的游戏吧";//没有防抄袭，这是 namespace 里的假主函数
}
}
namespace kong{bool ed;double MB(){return (&st-&ed)/1048576.0;}}
signed main(){
	cerr<<zhu::main()<<'\n'<<kong::MB();
}
```

---

## 作者：Charlie_ljk (赞：1)

- [推一下自己的最小割树学习笔记](https://www.cnblogs.com/Charlieljk/p/18729786)。

# 最小割树

最小割树就是通过分治建出一棵树，树上两点的最小割就等于原图上的最小割，树上两点路径唯一，其最小割就等于路径上边权的最小值。

建树时，任意选择两点最为 $s,t$ 跑最小割，求得 $ans_{s,t}$，并将其分为两个集合 $S,T$，对于 $x\in S,y\in T$，有 $ans_{x,y}=ans_{y,x}=\min(ans_{s,t},ans_{x,s},ans_{t,y})$。

之后对于这两部分再分别跑最小割，重复上述步骤，就能在理论（网络流的复杂度跑不满） $O(n^3m)$ 的复杂度内建出一棵最小割树。

# 答案处理

求出任意两点间的最小割，之后用 map 存一下或排序后去重求得不同的最小割的个数。

## 建树

建树就是对于每一层分治将 $s,t$ 连上边权为 $ans_{s,t}$ 的边即可，$ans_{s,t}$ 为本次最小割跑出的答案。

因为原图两点的最小割就等于树上两点路径上边权的最小值，根据这点就可以有很多种处理方式了，具体有树上倍、lca 等多种求法，但是本题 $Q$ 与 $n^2$ 同级，就不如以每个点为根遍历一遍树，复杂度 $O(n^2)$。

## 不建树

根据上面的式子，对于 $x\in S,y\in T$，有 $ans_{x,y}=ans_{y,x}=\min(ans_{s,t},ans_{x,s},ans_{t,y})$。

所以可以在分治的同时处理出答案，不需要把树建出来。

# 一些细节

- 每一次跑最小割前要将所有边恢复初始状态。
- 本题为无向图，要所以可以不用对于每一个边再建一条流量为 $0$ 的反边了，建双向边即可。
- 注意分治时每层的 $s,t$ 不同，根据需要保存本层的 $s,t$。

# 代码如下

使用的是不把树建出来的方法。

```cpp
#include<bits/stdc++.h>
#define ll long long
#define mkp make_pair
using namespace std;
const int N=855,M=17010,inf=0x3f3f3f3f;
#ifdef __linux__
#define gc getchar_unlocked
#define pc putchar_unlocked
#else
#define gc _getchar_nolock
#define pc _putchar_nolock
#endif
inline bool blank(const char x) {return !(x^32)||!(x^10)||!(x^13)||!(x^9);}
template<typename Tp> inline void read(Tp &x) {x=0; register bool z=true; register char a=gc(); for(;!isdigit(a);a=gc()) if(a=='-') z=false; for(;isdigit(a);a=gc()) x=(x<<1)+(x<<3)+(a^48); x=(z?x:~x+1);}
inline void read(double &x) {x=0.0; register bool z=true; register double y=0.1; register char a=gc(); for(;!isdigit(a);a=gc()) if(a=='-') z=false; for(;isdigit(a);a=gc()) x=x*10+(a^48); if(a!='.') return x=z?x:-x,void(); for(a=gc();isdigit(a);a=gc(),y/=10) x+=y*(a^48); x=(z?x:-x);}
inline void read(char &x) {for(x=gc();blank(x)&&(x^-1);x=gc());}
inline void read(char *x) {register char a=gc(); for(;blank(a)&&(a^-1);a=gc()); for(;!blank(a)&&(a^-1);a=gc()) *x++=a; *x=0;}
inline void read(string &x) {x=""; register char a=gc(); for(;blank(a)&&(a^-1);a=gc()); for(;!blank(a)&&(a^-1);a=gc()) x+=a;}
template<typename T,typename ...Tp> inline void read(T &x,Tp &...y) {read(x),read(y...);}
template<typename Tp> inline void write(Tp x) {if(!x) return pc(48),void(); if(x<0) pc('-'),x=~x+1; register int len=0; register char tmp[64]; for(;x;x/=10) tmp[++len]=x%10+48; while(len) pc(tmp[len--]);}
inline void write(const double x) {register int a=6; register double b=x,c=b; if(b<0) pc('-'),b=-b,c=-c; register double y=5*powl(10,-a-1); b+=y,c+=y; register int len=0; register char tmp[64]; if(b<1) pc(48); else for(;b>=1;b/=10) tmp[++len]=floor(b)-floor(b/10)*10+48; while(len) pc(tmp[len--]); pc('.'); for(c*=10;a;a--,c*=10) pc(floor(c)-floor(c/10)*10+48);}
inline void write(const pair<int,double>x) {register int a=x.first; if(a<7) {register double b=x.second,c=b; if(b<0) pc('-'),b=-b,c=-c; register double y=5*powl(10,-a-1); b+=y,c+=y; register int len=0; register char tmp[64]; if(b<1) pc(48); else for(;b>=1;b/=10) tmp[++len]=floor(b)-floor(b/10)*10+48; while(len) pc(tmp[len--]); a&&(pc('.')); for(c*=10;a;a--,c*=10) pc(floor(c)-floor(c/10)*10+48);} else cout<<fixed<<setprecision(a)<<x.second;}
inline void write(const char x) {pc(x);}
inline void write(const bool x) {pc(x?49:48);}
inline void write(char *x) {fputs(x,stdout);}
inline void write(const char *x) {fputs(x,stdout);}
inline void write(const string &x) {fputs(x.c_str(),stdout);}
template<typename T,typename ...Tp> inline void write(T x,Tp ...y) {write(x),write(y...);}
int n,m,s,t,cs[N],ct[N],dep[N],ans[N*N>>1],node[N],f[N][N];
int tot=1,now[N],head[N],nxt[M],to[M],w[M]; unordered_map<int,bool>vis;
inline void add(int x,int y,int z)
{
	nxt[++tot]=head[x],to[head[x]=tot]=y,w[tot]=z;
	nxt[++tot]=head[y],to[head[y]=tot]=x,w[tot]=z;
}
inline bool bfs()
{
	queue<int>q; memset(dep,0,sizeof(dep));
	for(memcpy(now,head,sizeof(now)),q.push(s),dep[s]=1;!q.empty();)
	{
		int x=q.front(); q.pop();
		for(int i=head[x],y;y=to[i];i=nxt[i]) if(w[i]&&!dep[y])
		{dep[y]=dep[x]+1,q.push(y); if(y==t) return true;}
	} return false;
}
inline int dfs(int x,int sum)
{
	if(x==t||!sum) return sum; int sur,res=0;
	for(int &i=now[x],y;y=to[i];i=nxt[i]) if(w[i]&&dep[y]==dep[x]+1)
	{
		if(!(sur=dfs(y,min(sum,w[i])))) {dep[y]=-1; continue;}
		w[i]-=sur,w[i^1]+=sur,res+=sur; if(!(sum-=sur)) break;
	} return res;
}
inline void build(int l,int r)
{
	if(l>=r) return ; s=node[l],t=node[r]; int res=0,ns=0,nt=0;
	for(int i=2;i<tot;i+=2) w[i]=w[i^1]=w[i]+w[i^1]>>1;
	while(bfs()) res+=dfs(s,inf); f[s][t]=f[t][s]=res;
	for(int i=l,x;i<=r;i++) dep[x=node[i]]?cs[++ns]=x:ct[++nt]=x;
	for(int i=1;i<=ns;i++) node[l+i-1]=cs[i];
	for(int i=1;i<=nt;i++) node[l+ns+i-1]=ct[i];
	int os=s,ot=t; build(l,l+ns-1),build(l+ns,r); 
	for(int i=1,j,x,y;i<=ns;i++) for(x=node[l+i-1],j=1;j<=nt;j++)
		y=node[l+ns+j-1],f[x][y]=f[y][x]=min({f[x][os],f[ot][y],res});
}
signed main()
{
	read(n,m),memset(f,0x3f,sizeof(f));
	for(int x,y,z;m--;) read(x,y,z),add(x,y,z);
	for(int i=1;i<=n;i++) node[i]=i; build(1,n); tot=0;
	for(int i=1,j;i<=n;i++) for(j=i+1;j<=n;j++) ans[++tot]=f[i][j];
	sort(ans+1,ans+1+tot),write(unique(ans+1,ans+1+tot)-ans-1);
}
```

---

## 作者：yanwh1 (赞：1)

在做本题之前建议先去做 [P4214 [CERC2015] Juice Junctions](https://www.luogu.com.cn/problem/P4214)。

在会做这道题之前，需要学会前置芝士：最小割树！

# 最小割树
您是否经常因为要求多次最小割而烦恼？您是否因为多次求最小割而导致超时？它来啦，它来啦！最小割树，让您不再惧怕网络流，从此走上 OI 巅峰！

这个算法十分神奇（~~因为我现在也没弄清它的原理~~），因为它可以将求图中两点最小割改为求树上两点最小割，复杂度骤减，那这么牛的算法应该怎么写呢？
## 建树
最小割树建树的过程其实就是分治。首先任意选取两个点 $a$ 和 $b$，然后跑这两个点的最小割。跑完之后可以发现图中的点要么与 $a$ 相连，要么与 $b$ 相连，于是我们把这些点分成两个集合，分治下去重复以上操作（注意，每次跑最小割都是在原图上跑）。
## 查询
查询操作相对比较简单。因为我们已经将图转换为一棵树，所以我们只需要在树上做最小割。于是我们只需搜索一遍树便能找到两点的最小割。
# 思路解析
就算学会最小割树后暴力求最小割也是会超时的，于是我们可以思考：是否可以以此搜索查多个点呢？答案是可行的。每次我们以图上任意一点开始搜索，查找图上其它点与它的最小割，于是查询操作就变成 $O(n \times m)$。
# 代码实现

```cpp
#include<bits/stdc++.h>
using namespace std;
#define rint register int
inline int read(){
    int f=0,t=0;
    char c=getchar();
    while(!isdigit(c)) t|=(c=='-'),c=getchar();
    while(isdigit(c)) f=(f<<3)+(f<<1)+c-48,c=getchar();
    return t?-f:f;
}inline void write(long long x) {
    if(x<0) putchar('-'),x=-x;
    if(x>9) write(x/10);
    putchar('0'+x%10);
}const int N=855,M=8505,inf=INT_MAX;
int head[M],to[M<<1],nxt[M<<1],w[M<<1],cnt=1,n,m,s,t,ans;map<int,int>mp; 
inline void add(int u,int v,int vl){nxt[++cnt]=head[u],to[cnt]=v,w[cnt]=vl,head[u]=cnt;}
int dis[N],now[N],rs[N],rs1[N],rs2[N];
queue<pair<int,int>>qe;
struct edge{int v,w;};
vector<edge>qwe[N];
inline int bfs(){
	for(rint i=1;i<=n;i++)dis[i]=inf;
	queue<int>q;q.push(s),dis[s]=0,now[s]=head[s];
	while(!q.empty()){
		int u=q.front();q.pop();
		for(rint i=head[u];i;i=nxt[i]){
			int v=to[i],vl=w[i];
			if(vl&&dis[v]==inf){
				q.push(v);
				dis[v]=dis[u]+1;
				now[v]=head[v];
				if(v==t)return 1;
			}
		}
	}return 0;
}inline int dfs(int u=s,int mn=inf){
	if(u==t||!mn)return mn;
	int k,res=0;
	for(rint i=now[u];i;i=nxt[i]){
		now[u]=i;int v=to[i],vl=w[i];
		if(vl&&dis[v]==dis[u]+1){
			k=dfs(v,min(vl,mn));
			if(!k)dis[v]=inf;
			w[i]-=k,w[i^1]+=k;
			qe.push(make_pair(i,k));
			res+=k,mn-=k;
			if(!mn)break;
		}
	}return res;
}inline int dinic(int u,int v){
	s=u,t=v;int ans=0;
	while(bfs())ans+=dfs();
	while(!qe.empty()){
		pair<int,int> res=qe.front();qe.pop();
		w[res.first]+=res.second;
		w[res.first^1]-=res.second;
	}return ans;
}inline void build(int l,int r){
	int m1=0,m2=0;
	if(l==r)return;
	int ans=dinic(rs[l],rs[l+1]);
	qwe[rs[l]].push_back({rs[l+1],ans});
	qwe[rs[l+1]].push_back({rs[l],ans});
	for(rint i=l;i<=r;i++){
		if(dis[rs[i]]!=inf)rs1[++m1]=rs[i];
		else rs2[++m2]=rs[i];
	}for(rint i=1;i<=m1;i++)rs[i+l-1]=rs1[i];
	for(rint i=1;i<=m2;i++)rs[i+l+m1-1]=rs2[i];
	build(l,l+m1-1),build(l+m1,r);
}inline void query(int u,int f,int mx,int mn){
	for(rint i=0;i<qwe[u].size();i++){
		int v=qwe[u][i].v,w=qwe[u][i].w;
		if(f==v)continue;
		if(v<mx){
			if(!mp[min(mn,w)]){
				mp[min(mn,w)]=1;
				ans++;
			}
		}query(v,u,mx,min(mn,w));
	}
}
signed main(){
	n=read(),m=read();
	for(rint i=1;i<=n;i++)rs[i]=i;
	for(rint i=1;i<=m;i++){
		int u=read(),v=read(),e=read();
		add(u,v,e),add(v,u,e);
	}build(1,n);
	for(rint i=2;i<=n;i++)
		query(i,0,i,inf);
	write(ans);
	return 0;
}
```

---

## 作者：Eznibuil (赞：1)

~~什么年代了还在用短小精悍的 Gusfield？快使用又臭又长的 Gomory-Hu！~~

具体细节参见[我的另一篇博客](/blog/_post/537433)。

对于此题，求出最小割树后对于树边 `std::sort` 再 `std::unique` 即可。时间复杂度 $O(n^2+n\tau)$（$\tau$ 为求最小割的时间复杂度）。

Gomory-Hu 卡到最优解第二不在话下（忽略提交答案的）。
```cpp
#include<assert.h>
#include<stdio.h>
#include<stdlib.h>
#include<algorithm>
#include<vector>
const int N=2001,M=100001;
bool vis[N],C[N][N];
int f,s,t,len,las[N],nex[M],en[M],vol[M],he,ta,q[N],dis[N],cnt[N],maxfl,sh[N],fa[N],ans[N][N];
#define addedg(e,d,g) (nex[len]=las[e],las[e]=len,en[len]=d,vol[len++]=g)
#define addfl(e,d,g) (addedg(e,d,g),addedg(d,e,g))
std::vector<int>rs[N];
bool bfs()
{
	int x;
	for(int i=he=ta=0;i<f;i++)
		vis[sh[i]]=0,cnt[sh[i]]=dis[sh[i]]=0;
	vis[q[ta++]=sh[t]]=1,dis[sh[t]]=0;
	while(he<ta)
	{
		cnt[dis[x=q[he++]]]++;
		for(int _:rs[x])
			for(int i=las[_];~i;i=nex[i])
				if(!vis[sh[en[i]]])
					vis[sh[en[i]]]=1,dis[sh[en[i]]]=dis[x]+1,q[ta++]=sh[en[i]];
	}
	assert(sh[s]!=sh[t]);
	return vis[sh[s]];
}
int dfs(int x,int fl)
{
	if(x==sh[t])
		return maxfl+=fl,fl;
	int d=0;
	for(int _:rs[x])
		for(int i=las[_],j;~i;i=nex[i])
			if(vol[i]&&dis[sh[en[i]]]==dis[x]-1)
			{
				d+=j=dfs(sh[en[i]],vol[i]<fl-d?vol[i]:fl-d),vol[i]-=j,vol[i^1]+=j;
				if(d==fl)
					return d;
			}
	cnt[dis[x]]--;
	if(!cnt[dis[x]])
		dis[sh[s]]=f;
	return cnt[++dis[x]]++,d;
}
void tag(int x)
{
	vis[x]=1;
	for(int _:rs[x])
		for(int i=las[_];~i;i=nex[i])
			if(vol[i^1]&&!vis[sh[en[i]]])
				tag(sh[en[i]]);
	return;
}
int mf(int S,int T)
{
	s=S,t=T;
	for(int i=maxfl=0;i<len;i+=2)
		vol[i]=vol[i^1]=vol[i]+vol[i^1]>>1;
	if(bfs())
		while(dis[sh[s]]<f)
			dfs(sh[s],1000000000);
	for(int i=0;i<f;i++)
		vis[sh[i]]=0;
	return tag(sh[t]),maxfl;
}
std::vector<std::pair<std::pair<int,int>,int>>GomoryHu(std::vector<int>R)
{
	for(int i:R)
		assert(sh[i]==i);
	if(R.size()==1)
	{
		for(int i=0;i<f;i++)
			C[R[0]][sh[i]]=1;
		return std::vector<std::pair<std::pair<int,int>,int>>();
	}
	std::vector<int>R1,R2;
	std::vector<std::pair<std::pair<int,int>,int>>T,T1,T2;
	bool v[N];
	int r1=R[0],r2=R[1],d=mf(r1,r2),tmp[N],rp,rpp;
	for(int i=0;i<f;i++)
		tmp[i]=-1,v[i]=vis[i];
	for(int i:R)
		if(vis[sh[i]])
			R2.emplace_back(i);
		else
			R1.emplace_back(i);
	for(int i=0,k;i<f;i++)
		if(v[k=sh[i]]&&k!=r2)
			for(int j=rs[k].size()-1;~j;j--)
				tmp[rs[k][j]]=sh[rs[k][j]],sh[rs[k][j]]=r2,rs[r2].emplace_back(rs[k][j]),rs[k].pop_back();
	T1=GomoryHu(R1),T.insert(T.end(),T1.begin(),T1.end());
	for(int i=0;i<f;i++)
		if(~tmp[i])
			sh[i]=tmp[i],tmp[i]=-1,rs[sh[i]].emplace_back(i);
	for(int i=rs[r2].size()-1;~i&&sh[rs[r2][i]]!=r2;i--)
		rs[r2].pop_back();
	for(int i=0,k;i<f;i++)
		if(!v[k=sh[i]]&&k!=r1)
			for(int j=rs[k].size()-1;~j;j--)
				tmp[rs[k][j]]=sh[rs[k][j]],sh[rs[k][j]]=r1,rs[r1].emplace_back(rs[k][j]),rs[k].pop_back();
	T2=GomoryHu(R2),T.insert(T.end(),T2.begin(),T2.end());
	for(int i=0;i<f;i++)
		if(~tmp[i])
			sh[i]=tmp[i],tmp[i]=-1,rs[sh[i]].emplace_back(i);
	for(int i=rs[r1].size()-1;~i&&sh[rs[r1][i]]!=r1;i--)
		rs[r1].pop_back();
	for(int i:R1)
		if(C[i][r2])
		{
			rp=i,C[i][r2]=0;
			break;
		}
	for(int i:R2)
		if(C[i][r1])
		{
			rpp=i,C[i][r1]=0;
			break;
		}
	return T.emplace_back(std::make_pair(rp,rpp),d),T;
}
int main()
{
	int n,m,u,v,w;
	std::vector<int>R;
	scanf("%d%d",&n,&m),f=n;
	for(int i=0;i<f;i++)
		las[i]=-1,R.emplace_back(i),sh[i]=i,rs[i].emplace_back(i);
	while(m--)
		scanf("%d%d%d",&u,&v,&w),addfl(u-1,v-1,w);
	auto T=GomoryHu(R);
	std::sort(T.begin(),T.end(),[](std::pair<std::pair<int,int>,int>a,std::pair<std::pair<int,int>,int>b){return a.second<b.second;}),printf("%d",std::unique(T.begin(),T.end(),[](std::pair<std::pair<int,int>,int>a,std::pair<std::pair<int,int>,int>b){return a.second==b.second;})-T.begin());
	return 0;
}
```

---

## 作者：YZren (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P4123)

## 前置芝士

[最小割树](https://www.luogu.com.cn/problem/P4897)（~~感觉此题比模版简单~~）

# 思路

在最小割树每次计算最小割时用 map 看是否有过该值，如果没有就用 map 存一下，再将 $ans$ 加一。

# Code

```cpp
#include<bits/stdc++.h>
#define int long long
#define endl "\n"
#define f(i,j,k) for(int i=j;i<=k;i++)
#define F(i,j,k) for(int i=j;i>=k;i--)
using namespace std;
const int maxn=4e4+10;
inline int read(){
	int x=0,f=1;char ch=getchar();
	while (ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}
	while (ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}
	return x*f;
}
inline void write(int x){
	if(x<0) {x=~(x-1); putchar('-');}
	if(x>9) write(x/10);
	putchar(x%10+'0');
}
int n,m,q,S,T,u,v,w,Uto,Vto,ans,node[maxn],sum,dis[maxn],cur[maxn],cnt=1,cS[maxn],cT[maxn];
struct edge{int to,val,id,loc;}; vector<edge> vec[maxn];
map<int,int> intmap;
inline void add(int x,int y,int z){Uto=vec[x].size();Vto=vec[y].size();vec[x].push_back({y,z,Vto,++cnt});vec[y].push_back({x,0,Uto,++cnt});};
inline bool bfs(){
	memset(dis,-1,sizeof(dis));
	queue<int> q; q.push(S); dis[S]=0;
	while(!q.empty()){
		int p=q.front(); q.pop();
		for(auto y:vec[p]) if(dis[y.to]==-1&&y.val) dis[y.to]=dis[p]+1,q.push(y.to);
	}
	memset(cur,0,sizeof(cur));
	return dis[T]!=-1;
}
inline int dfs(int x,int inc){
	if(x==T) return inc;
	int delta=inc;
	f(i,cur[x],(int)vec[x].size()-1){
		cur[x]=i;
		if(vec[x][i].val&&dis[vec[x][i].to]==dis[x]+1){
			int d=dfs(vec[x][i].to,min(delta,vec[x][i].val));
			vec[x][i].val-=d; vec[vec[x][i].to][vec[x][i].id].val+=d;
			delta-=d; if(!d) dis[vec[x][i].to]=-1;
			if(!delta) break;
		}
	}
	return inc-delta;
}
inline void init(){
	f(i,1,n) f(j,0,(int)vec[i].size()-1){
		if(vec[i][j].loc%2==1) continue;
		vec[i][j].val+=vec[vec[i][j].to][vec[i][j].id].val;
		vec[vec[i][j].to][vec[i][j].id].val=0;
	}
}
inline void Dinic(){
	sum=0; init();
	while(bfs()) sum+=dfs(S,LLONG_MAX);
	if(intmap.find(sum)==intmap.end()) intmap[sum]=1,ans++;
}
inline void build(int l,int r){
	if(l>=r) return ; 
	S=node[l]; T=node[l+1];
	Dinic(); int nodeS=0,nodeT=0;
	f(i,l,r) dis[node[i]]!=-1?cS[++nodeS]=node[i]:cT[++nodeT]=node[i];
	f(i,1,nodeS) node[l+i-1]=cS[i];
	f(i,1,nodeT) node[l+nodeS+i-1]=cT[i];
	build(l,l+nodeS-1); build(l+nodeS,r);
}
inline void work(){
	n=read(); m=read();
	f(i,1,m) u=read(),v=read(),w=read(),add(u,v,w),add(v,u,w);
	f(i,1,n) node[i]=i;
	build(1,n); write(ans);
}
signed main(){work();return 0;}
```

---

## 作者：chenzizai2021 (赞：0)

# 本题解需要开O2！！！
# 邻接矩阵题解
用Gomory-Hu Tree求出所有的点对的最小割，再统计即可；

#### 代码如下
```cpp
#include<iostream>
#include<cstring>
#include<algorithm>
using namespace std;
const int maxn=855,INF=0x7fffffff/2;
int N,M,S,T,map[maxn][maxn],g[maxn][maxn],dis[maxn],gap[maxn],vst[maxn],Q,f[maxn][maxn],fa[maxn];
int DFS(int x,int maxf)//SAP
{if(x==T)return maxf;
 int ret=0;
 for(int i=1;i<=N;i++)
    {if(g[x][i]>0&&dis[x]==dis[i]+1)
       {int dlt=DFS(i,min(maxf,g[x][i]));
        maxf-=dlt;
        ret+=dlt;
        g[x][i]-=dlt;
        g[i][x]+=dlt;
        if(dis[S]==N||!maxf)return ret;
       }
    }
 if(!(--gap[dis[x]]))dis[S]=N;
 gap[++dis[x]]++;
 return ret;
}
void DFS(int x)
{vst[x]=1;
 for(int i=1;i<=N;i++)
    if(g[x][i]&&!vst[i])DFS(i);
}
void Gusfield()
{for(int i=1;i<=N;i++)
    for(int j=1;j<=N;j++)
	   f[i][j]=INF;
 for(int i=2;i<=N;i++)fa[i]=1;
 for(int i=2;i<=N;i++)
    {memcpy(g,map,sizeof(map));
     memset(gap,0,sizeof(gap));
     memset(dis,0,sizeof(dis));
     memset(vst,0,sizeof(vst));
     S=fa[i];
     T=i;
     int ans=0;
     gap[0]=N;
     while(dis[S]<N)ans+=DFS(S,INF);
     DFS(S);
     for(int j=i+1;j<=N;j++)
        if(vst[j]==0&&fa[j]==fa[i])fa[j]=i;
     for(int j=1;j<i;j++)
        f[i][j]=f[j][i]=min(f[fa[i]][j],ans);
    }
}
int main()
{scanf("%d%d",&N,&M);
 memset(map,0,sizeof(map));
 for(int i=1;i<=M;i++)
    {int u,v,w;
	 scanf("%d%d%d",&u,&v,&w);
	 map[u][v]+=w;//可能有重边 
	 map[v][u]+=w; 
    }
 Gusfield();
 int *c=new int [N*(N-1)+1];
 c[0]=0;
 for(int i=1;i<=N;i++)
    for(int j=i+1;j<=N;j++)
       {c[++c[0]]=f[i][j];
       }
 sort(c+1,c+c[0]+1);
 cout<<unique(c+1,c+1+c[0])-c-1;//去重后个数 
 delete[]c;
}
```

---

## 作者：ysy20021208 (赞：0)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**分析与题解：**这道题是最小割树的模板题，对于题目中给出的图，我们求出这个图的最小割树，在求出最小割树的同时维护两点之间的最小割，这样我们就能通过排序来求得一共有多少不同的最小割。

```c++
// luogu-judger-enable-o2
#include <queue>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
#define N 1000
#define M 10000
#define inf 1000000000
int n,m,s,t,mincut,ans,point[N],tmp[N],dis[N],cut[N][N],number[N*N],cnt;
int cur[N],head[N],to[M<<1],val[M<<1],nxt[M<<1],idx=1;bool vis[N];
void add(int a,int b,int c)
    {nxt[++idx]=head[a],to[idx]=b,val[idx]=c,head[a]=idx;}
bool bfs() 
{
    memset(dis,-1,sizeof dis);
    queue <int> q;q.push(s),dis[s]=0;
    while(!q.empty())
    {
        int p=q.front();q.pop();
        if(p==t) return true;
        for(int i=head[p];i;i=nxt[i])
            if(val[i]>0&&dis[to[i]]==-1)
                dis[to[i]]=dis[p]+1,q.push(to[i]);
    } return false;
}
int dfs(int p,int flow)
{
    int now,temp=flow;
    if(p==t) return flow;
    for(int i=cur[p];i;i=nxt[i])
        if(val[i]>0&&dis[to[i]]==dis[p]+1)
        {
            now=dfs(to[i],min(val[i],temp));
            if(!now) dis[to[i]]=-1;
            temp-=now,val[i]-=now,val[i^1]+=now;
            if(val[i]) cur[p]=i;
            if(!temp) break;
        } return flow-temp;
}
void dinic() {while(bfs()) memcpy(cur,head,sizeof head),mincut+=dfs(s,inf);}
void dfs1(int p)
{
    vis[p]=true;
    for(int i=head[p];i;i=nxt[i])
        if(val[i]&&vis[to[i]]==false) dfs1(to[i]);
}
void build(int l,int r)
{
    if(l==r) return;
    for(int i=2;i<=idx;i+=2) val[i]=val[i^1]=(val[i]+val[i^1])/2;
    int lx=l,rx=r;s=point[l],t=point[r];
    mincut=0,dinic(),memset(vis,0,sizeof vis),dfs1(s);
    for(int i=1;i<=n;i++) if(vis[i])
        for(int j=1;j<=n;j++) if(!vis[j])
            cut[i][j]=cut[j][i]=min(cut[i][j],mincut);
    for(int i=l;i<=r;i++)
        if(vis[point[i]]) tmp[lx++]=point[i]; else tmp[rx--]=point[i];
    for(int i=l;i<=r;i++) point[i]=tmp[i];
    build(l,lx-1),build(rx+1,r);
}
int main()
{
    scanf("%d%d",&n,&m),memset(cut,0x7f7f,sizeof cut);
    for(int i=1,a,b,c;i<=m;i++)
        scanf("%d%d%d",&a,&b,&c),add(a,b,c),add(b,a,c);
    for(int i=1;i<=n;i++) point[i]=i; build(1,n);
    for(int i=1;i<=n;i++) for(int j=1;j<=n;j++)
        if(i!=j) number[++cnt]=cut[i][j];
    sort(number+1,number+cnt+1);
    for(int i=1,tmp=0;i<=cnt;i+=tmp,ans++,tmp=0)
        while(number[i]==number[i+tmp]&&i+tmp<=cnt) tmp++;
    printf("%d\n",ans);
}
```

---


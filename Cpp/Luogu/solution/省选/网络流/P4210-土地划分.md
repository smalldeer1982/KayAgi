# 土地划分

## 题目描述

$Y$ 国有 $N$ 座城市，并且有 $M$ 条双向公路将这些城市连接起来，并且任意两个城市至少有一条路径可以互达。$Y$ 国的国王去世之后，他的两个儿子 A 和 B 都想成为新的国王，但他们都想让这个国家更加安定，不会用武力解决问题。于是他们想将这个国家分成两个小国家 A 国和 B 国。现在，A 拥有 $1$ 号城市，B 拥有 $N$ 号城市，其他的城市还尚未确定归属哪边（划分之后的国家内部城市可以不连通）。由于大家都想让国家变得更好，而某些城市的人民愿意国王的 A 儿子作为他们的领袖，而某些城市更看好 B，而为了交通的便捷，如果划分后的公路连接两个同一个国家的城市，那么更利于城市之间的交流。于是大臣们设计了一种对土地划分的评分机制，具体如下：对于城市 $i$，如果它划分给 A 国，将得到 $\mathit{VA}_i$ 的得分；划分给 B 国，将得到 $\mathit{VB}_i$ 的得分。对于一条公路 $i$，如果它连接两个 A 国的城市，将得到 $\mathit{EA}_i$ 的得分；连接两个 B 国的城市，将得到 $\mathit{EB}_i$ 的得分；否则，这条公路将失去意义，将扣除 $\mathit{EC}_i$ 的得分。现请你找到最优的土地划分，使得这种它的评分最高。

## 说明/提示

对于全部数据，$n \le 10^4$，$m \le 4\times 10^4$。

保证运算过程中及最终结果不超过 $32$ 位带符号整数类型的表示范围。


## 样例 #1

### 输入

```
3 3 
8 
9 
1 2 2 6 2 
2 3 8 5 7 
1 3 9 4 1```

### 输出

```
11```

# 题解

## 作者：Rainy7 (赞：7)

- **分析**

  考虑**最小割**。
  
  可以用**总和减去最小扣除分数**来算答案。
  
  对于每个城市，可以分给A或者B。所以不妨设置一个源点 $s$ ，汇点 $t$ 。**源点代表A，汇点代表B。**
  
  即连边 $(s,i,va_i)$ 和 $(i,t,vb_i)$ 。再考虑城市与城市之间的连边。
  
  但是城市之间的连边会被两个城市所属A或B的影响。
  
  所以可以将一些边权除以 $2$ ，具体连边如下：
  
  对于2个城市先建立**双向边**：$(u,v,\frac{ea}{2}+\frac{eb}{2}+ec)$ 。
  
  然后再连边：$(s,u,\frac{ea}{2})(s,v,\frac{ea}{2})(u,t,\frac{eb}{2})(v,t,\frac{eb}{2})$ 。
  
  这样就可以巧妙的解决这个所属A，B的情况了。
  
  因为数据可能**有奇数**，所以开始先**全部乘二**。

------------

- **代码**

  ``` cpp
  #include<iostream>
  #include<cstdio>
  #include<cmath>
  #include<queue>
  #include<cstring>
  using namespace std;
  const int Maxn=100005,Maxm=800005;
  const int inf=1e9;
  struct edge{
      int v,w,nx;
  }e[Maxm];
  int n,m,ne=-1,f[Maxn],deep[Maxn];
  int cur[Maxn];
  queue<int>q;
  void read(int u,int v,int w)
  {	e[++ne].v=v;
      e[ne].w=w;
      e[ne].nx=f[u];
      f[u]=ne;
  }
  bool bfs(int s,int t)
  {	memset(deep,0x7f,sizeof(deep));
      while(!q.empty())q.pop();
      for(int i=0;i<=n;i++)cur[i]=f[i];
      deep[s]=0;
      q.push(s);
      while(!q.empty())
      {	int now=q.front();
          q.pop();
          for(int k=f[now];k!=-1;k=e[k].nx)
              if(deep[e[k].v]>inf&&e[k].w)
              {	deep[e[k].v]=deep[now]+1;
                  q.push(e[k].v);
              }
      }
      if(deep[t]<inf)return 1;
      return 0;
  }
  int dfs(int now,int t,int limit)
  {	if(!limit||now==t)return limit;
      int flow=0,x;
      for(int i=cur[now];i!=-1;i=e[i].nx)
      {	cur[now]=i;
          if(deep[e[i].v]==deep[now]+1)
          {	x=dfs(e[i].v,t,min(limit,e[i].w));
              if(!x)continue;
              flow+=x;
              limit-=x;
              e[i].w-=x;
              e[i^1].w+=x;
              if(!limit)break;
          }
      }
      return flow;
  }
  int dinic(int s,int t)
  {	int maxflow=0;
      while(bfs(s,t))maxflow+=dfs(s,t,inf);
      return maxflow;
  }
  int main()
  {	int s,t,sum=0;
      scanf("%d%d",&n,&m);
      for(int i=0;i<=n+1;i++)f[i]=-1;
      s=0;t=n+1;
      read(s,1,inf);
      read(n,t,inf);
      for(int i=2;i<=n-1;i++)
      {	int x;
          scanf("%d",&x);
          x*=2;
          sum+=x;
          read(s,i,x);read(i,s,0);
      }
      for(int i=2;i<=n-1;i++)
      {	int x;
          scanf("%d",&x);
          x*=2;
          sum+=x;
          read(i,t,x);read(t,i,0);
      }
      for(int i=1;i<=m;i++)
      {	int u,v,x1,x2,x3;
          scanf("%d%d%d%d%d",&u,&v,&x1,&x2,&x3);
          x1*=2;x2*=2;x3*=2;
          sum+=x1+x2;
          read(u,v,(x1/2+x2/2+x3));
          read(v,u,(x1/2+x2/2+x3));
          read(s,u,x1/2);read(u,s,0);
          read(s,v,x1/2);read(v,s,0);
          read(u,t,x2/2);read(t,u,0);
          read(v,t,x2/2);read(t,v,0);
      }
      n++;
      printf("%d\n",(sum-dinic(s,t))/2);
      return 0;
  }
  ```

---

## 作者：滑大稽 (赞：6)

题外话：这其实是一道挺好的题，不知道为什么做的人这么少 ~~（一题多解应该就算好题了吧）~~

我来提供一种新的思路，与现有的题解处理方式都不怎么一样。

首先，给城市划分的建边都是一样的：对于$ \forall i \in [2,n-1] $，建边$s \to i $及 $i \to t$ ，边权分别为 $VA_i$,$VB_i$。然后对于$1$,$n$,建边$s \to 1 $和$n \to t $，边权均为 $+\infty$，防止其被割掉

最核心的思路是关于边该怎么处理，这里我仿造了[P1361](https://www.luogu.com.cn/problem/P1361)的建边方法，对于每条边建一个虚拟点，往其连接的两个点都由虚拟点连一条边权为$+\infty$的边，同样防止其被割掉

然后就是对于$EC_i$的处理了，其值为负数，无法最小割。但我们可以换一种思路，就对于每一条边，最先就把它的贡献减去$EC_i$，然后再把$EA_i$和$EB_i$分别加上$EC_i$，然后你就会发现，假如这条边没有贡献，他的$EC_i$已经被减掉了，不用管它，然后假如有贡献，一定是$EA_i$和$EB_i$二者其一。我们已经预先加上了$EC_i$，两者正好相抵消，相当于$EC_i$的影响被消除了。

到这里，思路也就清晰了，对于任意一条边，首先把它的贡献从答案中减去$EC_i$，然后把$EA_i$和$EB_i$分别加上$EC_i$。这样，就可以类比P1361的建图了：每条边建两个虚拟点，分别代表两个点都在A集合或B集合。然后分别往对应点连正无穷的边（两个虚拟点方向相反），源汇点分别往虚拟点连贡献大小的边。最后设$sum=\sum_{i=2}^{n-1}VA_i+VB_i $,则$sum-\sum EC_i-Maxflow()$即为答案

这方法复杂度好像没有其他题解除以2的思路优，稍微卡卡常只能到940ms，但多一种思路还是不错的。

代码有点丑，就上一段关键代码（处理边那里）就行了

```cpp
for(int i=1;i<=m;i++)
{
	int a=read(),b=read(),x=read(),y=read(),z=read();//数据读入
    
	x+=z,y+=z;
	ans+=x+y-z;//上面提到的处理
    
	add(n+i*2-1,a,inf);
	add(n+i*2-1,b,inf);
	add(s,n+i*2-1,x);//第一个虚拟点（同属A集合）的建边
    
	add(a,n+i*2,inf);
	add(b,n+i*2,inf);
	add(n+i*2,t,y);//第二个虚拟点（同属B集合）的建边
}
```


---

## 作者：cuking (赞：5)

先模一下楼下大佬，~~没有他的题解我都不会做~~

我这里整体思路跟楼下大佬一样，不过加入了一个重要的优化，就是合并重边

注意在处理点和边的时候都从源点向某点连边，也从某点到汇点连边，如果分别连边，
边的数量是2N+5M，但是合并下再连，边的数量就降到了2N+M,跑起来飞快


```cpp
#include<stdio.h>
#include<string.h>
typedef struct Es
{
    int v,d;
    Es*f,*n;
}Es;
const int S=10000;
const int T=10001;
Es e[200000],*E=e;
Es*lin[10002];
int dep[10002];
int queue[10002];
int sud[10000];
int utd[10000];
void insert1(int u,int v,int d)
{
    *E=(Es){v,d,E+1,lin[u]};
    lin[u]=E++;
    *E=(Es){u,0,E-1,lin[v]};
    lin[v]=E++;
}
void insert2(int u,int v,int d)
{
    *E=(Es){v,d,E+1,lin[u]};
    lin[u]=E++;
    *E=(Es){u,d,E-1,lin[v]};
    lin[v]=E++;
}

bool bfs()
{
    memset(dep,-1,sizeof dep);
    int h=0,t=1,tqf;
    dep[queue[0]=S]=1;
    while(h!=t)
    {
        tqf=queue[h++];
        for(Es*p=lin[tqf];p;p=p->n)
        if(p->d&&dep[p->v]==-1)
        {
            dep[p->v]=dep[tqf]+1;
            queue[t++]=p->v;
        }
    }
    return dep[T]!=-1;
}
int dfs(int tu,int min)
{
    if(tu==T)return min;
    int ans=0,t;
    for(Es*p=lin[tu];p&&min;p=p->n)
    if(p->d&&dep[p->v]==dep[tu]+1)
    {
        ans+=t=dfs(p->v,min<p->d?min:p->d);
        min-=t;
        p->d-=t;
        p->f->d+=t;
    }
    if(!ans)dep[tu]=-1;
    return ans;
}
int match()
{
    int ans=0;
    while(bfs())ans+=dfs(S,2000000000);
    return ans;
}
int main()
{
    int N,M,i,tu,tv,Va,Vb,Ea,Eb,Ec,sum=0;
    scanf("%d%d",&N,&M);
    for(i=1;i<N-1;i++)
    {
        scanf("%d",&Va);
        sum+=Va<<=1;
        sud[i]+=Va;
    }
    for(i=1;i<N-1;i++)
    {
        scanf("%d",&Vb);
        sum+=Vb<<=1;
        utd[i]+=Vb;
    }
    while(M--)
    {
        scanf("%d%d%d%d%d",&tu,&tv,&Ea,&Eb,&Ec);
        tu--;tv--;sum+=(Ea<<1)+(Eb<<1);
        sud[tu]+=Ea;sud[tv]+=Ea;
        utd[tu]+=Eb;utd[tv]+=Eb;
        insert2(tu,tv,Ea+Eb+(Ec<<1));
    }
    sud[0]=2000000000;
    utd[N-1]=2000000000;
    for(i=0;i<N;i++)
    {
        insert1(S,i,sud[i]);
        insert1(i,T,utd[i]);
    }
    printf("%d",sum-match()>>1);
}
```

没吸氧也没加快读，也没有inline，register什么的，总时间仅284ms，合并边之后确实神速

---

## 作者：MiniLong (赞：2)

一道好题，主要难点就是求**不同分组的负贡献**。

如果先不考虑两个节点不同集合带来的负贡献的话，那么就是分组问题的模板。对于两个相同集合的点，建立虚点 $x'$，使得 $s \to x'$ 边权 $EA$，然后 $x' \to u$，$x' \to v$ 边权 $inf$，连到 $t$ 同理。

然后考虑将这个负贡献加进来，因为不能直接表现，所以要将其转化为相同分组的贡献。因为最后的答案是 $sum - mincut$，所以可以想到**在这个最小割中将贡献转为正，然后在权值和中不加上它，最后的贡献就是负的了**（相当于 $sum - (mincut + EC)=sum - mincut - EC$）。

有了这个思路，那么接下来的就很好理解了。将两个虚点 $x',y'$ 与源点或汇点的 $s \to x'$，$y' \to t$ 中的边权都加上 $EC$，然后在 $sum$ 中加上**一个** $EC$。此时，若这两个节点在同一集合，那么 $mincut$ 中会有一个 $EC$，$sum$ 中多加的一个 $EC$ 和它正好抵消了。若它们不在同一集合，那么 $mincut$ 中会有两个 $EC$，此时的贡献正好多了个 $-EC$，巧妙地将它的负贡献表示出来了。

```cpp
#include <bits/stdc++.h>
#define _rep(i, x, y) for(int i = x; i <= y; ++i)
#define _req(i, x, y) for(int i = x; i >= y; --i)
#define _rev(i, u) for(int i = head[u]; i; i = e[i].nxt)
#define pb(x) push_back(x)
#define mst(f, i) memset(f, i, sizeof f)
using namespace std;
#ifdef ONLINE_JUDGE
#define debug(...) 0
#else
#define debug(...) fprintf(stderr, __VA_ARGS__), fflush(stderr)
#endif
namespace fastio{
    template<typename T> inline void read(T &t){
        T x = 0, f = 1;
        char c = getchar();
        while(!isdigit(c)){
            if(c == '-') f = -f;
            c = getchar();
        }
        while(isdigit(c)) x = x * 10 + c - '0', c = getchar();
        t = x * f;
    }
    template<typename T, typename ... Args> inline void read(T &t, Args&... args){
        read(t);
        read(args...);
    }
    template<typename T> void write(T t){
        if(t < 0) putchar('-'), t = -t;
        if(t >= 10) write(t / 10);
        putchar(t % 10 + '0');
    }
    template<typename T, typename ... Args> void write(T t, Args... args){
        write(t), putchar(' '), write(args...);
    }
    template<typename T> void writeln(T t){
        write(t);
        puts("");
    }
    template<typename T> void writes(T t){
        write(t), putchar(' ');
    }
};
using namespace fastio;
typedef long long ll;
typedef pair<int, int> PII;
const int N = 1e6 + 5, inf = 2e9, M = 105;
int n, m, k, s, t;
int ecnt = 1, head[N];
struct edge{
	int v, w, nxt;
}e[N << 1];
int in[N];
void add(int u, int v, int w){
	e[++ecnt] = edge{v, w, head[u]}, head[u] = ecnt;
	e[++ecnt] = edge{u, 0, head[v]}, head[v] = ecnt;
}
int cur[N], num[N];
bool bfs(int s, int t){
	mst(num, 0);
	queue<int> q;
	num[s] = 1, cur[s] = head[s], q.push(s);
	while(q.size()){
		int u = q.front(); q.pop();
		_rev(i, u){
			int v = e[i].v;
			if(e[i].w && !num[v]){
				num[v] = num[u] + 1;
				cur[v] = head[v];
				q.push(v);
			}
		}
	}
	return num[t];
}
int dfs(int u, int in){
	int out = 0;
	if(u == t) return in;
	for(int i = cur[u]; i && in; i = e[i].nxt){
		int v = e[i].v;
		cur[u] = i;
		if(e[i].w && num[v] == num[u] + 1){
			int d = dfs(v, min(in, e[i].w));
			in -= d, out += d;
			e[i].w -= d, e[i ^ 1].w += d;
		}
	}
	if(!out) num[u] = 0;
	return out;
}
int Dinic(){
	int Flow = 0;
	while(bfs(s, t)) Flow += dfs(s, inf);
	return Flow;
}
int sum, cnt;
int main(){
	read(n, m), s = 0, t = n + m * 2 + 1;
	add(s, 1, inf), add(n, t, inf);
	_rep(i, 2, n - 1){
		int x; read(x), sum += x;
		add(s, i, x);
	}
	_rep(i, 2, n - 1){
		int x; read(x), sum += x;
		add(i, t, x);
	}
	cnt = n;
	_rep(i, 1, m){
		int x, y, a, b, c; read(x, y, a, b, c), sum += a + b + c;
		int cur1 = ++cnt, cur2 = ++cnt;
		add(s, cur1, a + c), add(cur2, t, b + c);
		add(cur1, x, inf), add(cur1, y, inf), add(x, cur2, inf), add(y, cur2, inf);
	}
	writeln(sum - Dinic());
    return 0;
}
```

---

## 作者：Meteorshower_Y (赞：2)

## 前言
明天就要 CSP 了，希望涨点 RP。  
[如果你要看题，请点击这里](https://www.luogu.com.cn/problem/P4210)，或者看下面。

## 题目描述
对于一些点，将他们划分到两个集合，划分到某个集合会有特定的收益，某两个点划分到同一集合会有额外收益，但是分在不同的集合会额外的代价（减分项）。询问最大收益。

## 解题思路
看到题目的第一眼……这不 [文理分科](https://www.luogu.com.cn/problem/P4313) 吗。  
考虑网络流最小割，先将所有收益加起来，将割掉一边表示不选这个条件的代价 或 额外代价 $(Ec)$，总权值和减去最小的代价就是最大收益。

下面考虑建图：  
对于 $Ea$ 和 $Eb$，我们可以像文理分科一样，对每一对点建一个额外的点，然后这个额外的点与这一对点连上 $inf$ 的边，防止隔断，把 $Ea$ 和 $Eb$ 分别作为与 $S$ 和 $T$ 连边的流量，割掉它就代表我不打算满足这个条件。  
对于 $Ec$ 来说，我们就在这两个点之间连一条流量为 $Ec$ 的，当这一对点一个归在了 $S$，另一个归在了 $T$，那么这条边会被隔断，表示额外代价。  
图建出来是这样的：
![](https://cdn.luogu.com.cn/upload/image_hosting/rneq5gj7.png)  
两个点都被分到了 $S$:
![](https://cdn.luogu.com.cn/upload/image_hosting/qsc45t7r.png)  
两个点都被分到了 $T$:
![](https://cdn.luogu.com.cn/upload/image_hosting/egrk4r8s.png)  
两个点一个分到了 $S$，一个分到了 $T$:
![](https://cdn.luogu.com.cn/upload/image_hosting/yimjsouv.png)  
然后就是网络流最小割（最大流）的板子了。

### Code
```cpp
#define Aniciry	Meteorshower_Y
#include<iostream>
#include<cstring>
#include<climits>
#include<cstdio>
#include<queue>
using namespace std;
const int N = 1e4+10;
const int M = 4e4+10;
const int inf = 0x3f3f3f3f;
namespace Netflow
{
    struct edge{
        int from, to;
        int flow, next;
    }a[(N+M*8)<<2];
    int head[N+M*3], cnt = 1;
    int vis[M*3], s, t, tot;
    auto solve() -> int;
    auto bfs(int s, int t) -> int;
    auto dinic(int x, int flow) -> int;
    auto add_edge(int from, int to, int flow) -> void;
    auto Add_edge(int from, int to, int flow) -> void;
}
using namespace Netflow;
int n, m, all, va[N], vb[N];
int x, y, EA, EB, EC;
int main()
{
    scanf("%d%d", &n, &m);
    Netflow::s = n+1; Netflow::t = s+1; Netflow::tot = t;
    for(int i = 2; i < n; i += 1) scanf("%d", &va[i]);
    for(int i = 2; i < n; i += 1) scanf("%d", &vb[i]);
    for(int i = 2; i < n; i += 1) all += va[i] + vb[i];
    for(int i = 2; i < n; i += 1) add_edge(s, i, va[i]);
    for(int i = 2; i < n; i += 1) add_edge(i, t, vb[i]);
    for(int i = 1; i <= m; i += 1)
    {
        scanf("%d%d", &x, &y);
        scanf("%d%d%d", &EA, &EB, &EC);
        all += EA + EB;   
        
        tot += 1; add_edge(s, tot, EA);
        add_edge(tot, x, inf); add_edge(tot, y, inf);
        
        tot += 1; add_edge(tot, t, EB);
        add_edge(x, tot, inf); add_edge(y, tot, inf);
        
        add_edge(x, y, EC); add_edge(y, x, EC);
    }
    add_edge(s, 1, inf); add_edge(n, t, inf);
    printf("%d", all-solve());
    return 0;
}
namespace Netflow
{
    auto solve() -> int
    {
        int maxflow = 0, nowflow;
        while(bfs(s, t) == true)
            while((nowflow = dinic(s, inf)))
                maxflow += nowflow;
        return maxflow;
    }
    auto bfs(int s, int t) -> int
    {
        memset(vis, 0, sizeof(vis));
        queue<int> q; q.push(s);
        vis[s] = 1; int x, y;
        while(!q.empty())
        {
            x = q.front(); q.pop();
            for(int i = head[x]; i; i = a[i].next)
            {
                y = a[i].to;
                if(!vis[y] and a[i].flow)
                {
                    vis[y] = vis[x]+1;
                    if(y == t) return true;
                    q.push(y);
                }
            }
        }
        return false;
    }
    auto dinic(int x, int flow) -> int
    {
        if(x == t) return flow;
        int rest = flow, y, k;
        for(int i = head[x]; i; i = a[i].next)
        {
            y = a[i].to;
            if(vis[y] == vis[x]+1 and a[i].flow)
            {
                k = dinic(y, min(rest, a[i].flow));
                if(!k) vis[y] = 0;
                a[i].flow -= k;
                a[i^1].flow += k;
                if(!(rest -= k)) break;
            }
        }
        return flow-rest;
    }
    auto add_edge(int from, int to, int flow) -> void
    {
        Add_edge(from, to, flow);
        Add_edge(to, from, 0);
    }
    auto Add_edge(int from, int to, int flow) -> void
    {
        cnt += 1;
        a[cnt].from = from;
        a[cnt].to = to;
        a[cnt].flow = flow;
        a[cnt].next = head[from];
        head[from] = cnt;
    }
}
```

### 结语
最后在这里祝天下 OIer CSP RP++  
\完结撒花/

---

## 作者：Ptilopsis_w (赞：1)

## 分析

题目相当于给每个点划分所属集合，并求出所有划分方案中的最大价值。

这是一类比较经典的最小割模型，于是考虑最小割，即将答案转化为所有的得分减去最少的发生冲突的得分。

以下设 $S$ 集合为题目中被划分到 $A$ 中的点, $T$ 集合为题目中被划分到 $B$ 中的点。

首先每个点 $i$ 被划分到 $S$ 具有 $va_i$ 的价值，我们就连一条 $S \stackrel{va_i}{\longrightarrow} i$ 的边，代表将 $i$ 割离 $S$ 的代价为 $va_i$, $T$ 同理。

然后就是每条边的限制，这里两个点在同一集合内就有价值的限制非常类似于 [P4313 文理分科](https://www.luogu.com.cn/problem/P4313)，于是我们可以把这道题的思路套过来: 对于每条边，新建两个节点 $e, e'$，分别用来表示 $x,y$ 同时划分在 $S$ 和 $T$ 的贡献，我们可以连 $S \stackrel{ea}{\longrightarrow} e, e \stackrel{\inf}{\longrightarrow} x, e \stackrel{\inf}{\longrightarrow} y$ 三条边代表如果 $x,y$ 其中一个没划分在 $S$ 中，就需要花费 $ea$ 的代价；$T$ 这边同理: $x \stackrel{\inf}{\longrightarrow} e', y \stackrel{\inf}{\longrightarrow} e', e' \stackrel{eb}{\longrightarrow} T$。

最有还有个限制是如果 $x,y$ 处在不同集合内需要额外的 $ec$ 的代价，这个可以连上 $x \stackrel{ec}{\longleftrightarrow} y$ 的边达到限制。

最后跑一个最小割即可得出答案，此做法与边权的奇偶性无关，且不需要多余的转化，但是连边数较多，属于套路型做法罢。

## Code

```c++
#include <climits>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <queue>
using namespace std;

const int N = 1e4+5;
const int M = 4e4+10;
const int INF = 0x3f3f3f3f;

namespace netflow {
    struct edge { 
        int to, next;
        int flow;
    } e[(N*2+M*8)*2];
    int head[N+M*2], ecnt = 1;
    int dis[N+M*2], cur[N+M*2];
    int S, T;
    int dinic();
    void add_edge(int a, int b, int f);
}
using namespace netflow;

int n, m; int ans;

int main()
{
    cin >> n >> m;
    S = n+m*2+1, T = n+m*2+2;
    add_edge(S, 1, INF);
    add_edge(n, T, INF);
    for(int i = 2; i <= n-1; i++)
    {
        int va; cin >> va;
        add_edge(S, i, va);
        ans += va;
    }
    for(int i = 2; i <= n-1; i++)
    {
        int vb; cin >> vb;
        add_edge(i, T, vb);
        ans += vb;
    }
    for(int i = 1; i <= m; i++)
    {
        int a, b; int ea, eb, ec;
        cin >> a >> b >> ea >> eb >> ec;
        add_edge(S, n+i, ea);
        add_edge(n+i, a, INF);
        add_edge(n+i, b, INF);
        
        add_edge(a, n+m+i, INF);
        add_edge(b, n+m+i, INF);
        add_edge(n+m+i, T, eb);
        
        add_edge(a, b, ec);
        add_edge(b, a, ec);
        ans += ea+eb;
    }
    ans -= dinic();
    cout << ans << "\n";
}

namespace netflow {
    bool bfs(int S, int T)
    {
        memcpy(cur, head, sizeof(cur));
        memset(dis, 0, sizeof(dis));
        queue<int> q; int x;
        q.push(S); dis[S] = 1;
        while(!q.empty())
        {
            x = q.front(); q.pop();
            for(int i = head[x]; i; i = e[i].next)
            {
                if(e[i].flow and !dis[e[i].to])
                {
                    dis[e[i].to] = dis[x]+1;
                    q.push(e[i].to);
                }
            }
        }
        return dis[T];
    }
    int dfs(int x, int flow)
    {
        if(x == T) return flow;
        int rest = flow; int i;
        for(i = cur[x]; i; i = e[i].next)
        {
            if(e[i].flow and dis[e[i].to] == dis[x]+1)
            {
                int k = dfs(e[i].to, min(rest, e[i].flow));
                if(!k) dis[e[i].to] = 0;
                e[i].flow -= k, e[i^1].flow += k;
                if(!(rest -= k)) break;
            }
        }
        return cur[x] = i, flow-rest;
    }
    int dinic()
    {
        int maxflow = 0;
        while(bfs(S, T))
            maxflow += dfs(S, INF);
        return maxflow;
    }
    void add_edge(int a, int b, int f)
    {
        e[++ecnt] = {b, head[a], f}; head[a] = ecnt;
        e[++ecnt] = {a, head[b], 0}; head[b] = ecnt;
    }
}
```


---

## 作者：TYxxj (赞：1)

## 解题思路：
二者必取其一，这个很有最小割的意思，所以相当于将A国是源点，B国为汇点

对于一个点$P_i$，设其分到A国的价值为$V_{ai}$，分到B国的价值为$V_{bi}$。

取A则无法取B，这就是最小割模型了。

那么从源点连向$P_{i}$一条有向边，容量为$V_{ai}$，那么从$P_i$向汇点一条有向边，容量为$V_{bi}$，

这样点的二选一就实现了，只需要用$\sum{V_{ai}+V_{bi}}$减去最小割就可以啦。

下面是边的三选一：(设一条边连A国城市贡献为$C_{ai}$,连B国城市贡献为$C_{bi}$，连接两个国家点惩罚为$C_{ci}$）

两个点若都选A，那么就需要割去这条边连接B国两个城市点贡献。

选A相当于割去城市选B国点贡献，那么相当于在汇点端取消了流量。

那么现在限制一下，要求其取消汇点端流量则必须取消这条边流量。

那么就相当于在原来两个城市向汇点连边处向汇点重新连边。

由于两个点都必须限制，那么相当于在两个点都向汇点连$\frac{C_{bi}}{2}$的边。

同理从源点连向边的两端点$\frac{C_{ai}}{2}$的边。

所以在答案上加上$\sum{C_{ai}+C_{bi}}$最后减去最小割。

考虑惩罚条件。

此时为边的两端一个割源，一个割汇。

此时为了保证出现割，保留与汇点连边端必须断开所有与源点连边。

所以此时最小割中一定存在$\frac{C_{ai}}{2}$，也就是这条边存在时与源点的附加边。

同理，最小割中也存在$\frac{C_{bi}}{2}$，这样割下来的代价为$\frac{C_{bi}}{2}+\frac{C_{ai}}{2}$

但是我们期望其扣除的代价为$C_{ai}+C_{bi}+C_{ci}$，这就要求我们同时要割下一条代价为$\frac{C_{bi}}{2}+\frac{C_{ai}}{2}+C_{ci}$的边。

可是这条边应该加在哪里呢。

考虑什么样的边一定被割掉，一定是当前存在的与源点连边的点连向一个与汇点有流量的点。

那么就是在当前边两端对应的点间加一双向边，边权为$\frac{C_{bi}}{2}+\frac{C_{ai}}{2}+C_{ci}$。

证明这样做的可行性。

因为当两端选同一个国家时，中间的流量不会流向汇或不会与源有流量。

所以这条附加边在两端选同一国家时是不会存在流量的，更不会被割去。

所以建图就是这样了。

因为有系数$\frac{1}{2}$的存在，将所有边权\*2，最后/2，可以证明最后一定是整除的，没有必要担心。

全图最小割就好了。

代码：
```cpp
#include<queue>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int oo=0x3f3f3f3f;
struct pnt {
	int hd;
	int lyr;
	int now;
} p[100000];
struct ent {
	int twd;
	int lst;
	int vls;
} e[1000000];
int cnt,n,m,s,t;
queue<int>Q;
void ade(int f,int t,int v) {
	cnt++;
	e[cnt].twd=t;
	e[cnt].vls=v;
	e[cnt].lst=p[f].hd;
	p[f].hd=cnt;
	return ;
}
bool Bfs(void) {
	while(!Q.empty())Q.pop();
	for(int i=1; i<=t; i++)p[i].lyr=0;
	p[s].lyr=1;
	Q.push(s);
	while(!Q.empty()) {
		int x=Q.front();
		Q.pop();
		for(int i=p[x].hd; i; i=e[i].lst) {
			int to=e[i].twd;
			if(p[to].lyr==0&&e[i].vls>0) {
				p[to].lyr=p[x].lyr+1;
				if(to==t)return true;
				Q.push(to);
			}
		}
	}
	return false;
}
int Dfs(int x,int fll) {
	if(x==t)return fll;
	for(int& i=p[x].now; i; i=e[i].lst) {
		int to=e[i].twd;
		if(p[to].lyr==p[x].lyr+1&&e[i].vls>0) {
			int ans=Dfs(to,std::min(fll,e[i].vls));
			if(ans>0) {
				e[i].vls-=ans;
				e[((i-1)^1)+1].vls+=ans;
				return ans;
			}
		}
	}
	return 0;
}
int Dinic(void) {
	int ans=0;
	while(Bfs()) {
		for(int i=1; i<=t; i++)p[i].now=p[i].hd;
		int dlt;
		while(dlt=Dfs(s,oo))ans+=dlt;
	}
	return ans;
}
int main() {
	scanf("%d%d",&n,&m);
	s=n+1;
	t=s+1;
	int ans=0;
	ade(s,1,oo);
	ade(1,s,0);
	ade(n,t,oo);
	ade(t,n,0);
	for(int i=2; i<=n-1; i++) {
		int x;
		scanf("%d",&x);
		x<<=1;
		ade(s,i,x);
		ade(i,s,0);
		ans+=x;
	}
	for(int i=2; i<=n-1; i++) {
		int x;
		scanf("%d",&x);
		x<<=1;
		ade(i,t,x);
		ade(t,i,0);
		ans+=x;
	}
	for(int i=1; i<=m; i++) {
		int x,y,a,b,c;
		scanf("%d%d%d%d%d",&x,&y,&a,&b,&c);
		ans+=a+b+a+b;
		ade(s,x,a);
		ade(x,s,0);
		ade(s,y,a);
		ade(y,s,0);
		ade(x,t,b);
		ade(t,x,0);
		ade(y,t,b);
		ade(t,y,0);
		ade(x,y,a+b+c+c);
		ade(y,x,a+b+c+c);
	}
	ans=(ans-Dinic())>>1;
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：Silent1019 (赞：0)

## 题目大意
有 $n-2$ 个城市划分给 A 和 B 两个国家（$1$ 号城市属于 A 国，$n$ 号城市属于 B 国），有不同的得分，当其中某两个特定的城市划分给同一个国家，有额外得分，求得分的最大值。
## 思路
将所有得分相加，减去最小割就是答案。接下来就要考虑建图。

首先考虑将城市划分给两个国家，先将所有的城市看作 $n$ 个点，与超级源点 $s$ 和超级汇点 $t$ 相连，边权即为分给 A 国和 B 国的得分。  
**注意：$1$ 号城市与 A 国边权为无穷大，与 B 国边权为 $0$，$n$ 号城市与 B 国边权为无穷大，与 A 国边权为 $0$。**

在考虑两个城市属于同一个国家有额外得分的建边时，不能直接将两个城市连边。~~就是这样错了好几次~~。那么要怎样建边呢？我们可以新建两个节点 $e_1$ 和 $e_2$，将两个城市与$e_1$ 和 $e_2$ 连边，边权设为无穷大。从源点向 $e_1$ 连边，边权就是在 A 国额外得分值，从 $e_2$ 向汇点连边，边权就是在 B 国额外得分值。

还要考虑如果这条公路的两端城市在不同国家的情况，这时需要减去一定的得分 $E$。其实很容易考虑到，在建额外得分的边时，边权直接加上 $E$ 就行了。当两条边都被删的时候就相当于减去了得分 $E$。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define INF 2147483647
const int N=1e5+10;
struct Edge{
	int v,w,next;
}edge[N<<4];
int head[N<<3],tot=1;
void add(int u,int v,int w)
{
	tot++;
	edge[tot].v=v; edge[tot].w=w;
	edge[tot].next=head[u];
	head[u]=tot;
}
int n,m,s,t,w,res,ans;
int x,y,a,b,c,cnt;
int dis[N<<3],now[N<<3];
bool bfs()
{
	for(int i=0;i<=cnt;i++) dis[i]=INF;
	queue<int> que;
	que.push(s); dis[s]=0;
	now[s]=head[s];
	while(!que.empty())
	{
		int e=que.front(); que.pop();
		for(int i=head[e];i;i=edge[i].next)
		{
			int v=edge[i].v;
			if(edge[i].w>0&&dis[v]==INF)
			{
				que.push(v);
				dis[v]=dis[e]+1;
				now[v]=head[v];
				if(v==t) return true;
			}
		}
	}
	return false;
}
int dfs(int e,int sum)
{
	if(e==t) return sum;
	int k,res=0;
	for(int i=now[e];i&&sum;i=edge[i].next)
	{
		now[e]=i;
		int v=edge[i].v;
		if(edge[i].w>0&&dis[v]==dis[e]+1)
		{
			k=dfs(v,min(edge[i].w,sum));
			if(k==0) dis[v]=INF;
			edge[i].w-=k;
			edge[i^1].w+=k;
			res+=k;
			sum-=k;
		}
	}
	return res;
}
int main()
{
	scanf("%d%d",&n,&m);
	s=n+1; t=n+2; cnt=n+2;
	add(s,1,INF); add(1,s,0);
	add(n,t,INF); add(t,n,0);
	//处理1号城市和n号城市 
	
	for(int i=2;i<=n-1;i++)
	{
		scanf("%d",&w);
		ans+=w;
		add(s,i,w); add(i,s,0);
	}
	for(int i=2;i<=n-1;i++)
	{
		scanf("%d",&w);
		ans+=w;
		add(i,t,w); add(t,i,0);
	}
	for(int i=1;i<=m;i++)
	{
		scanf("%d%d%d%d%d",&x,&y,&a,&b,&c);
		a+=c; b+=c; res+=c;
		ans+=a+b;
		cnt++;
		add(s,cnt,a); add(cnt,s,a);
		add(cnt,x,INF); add(x,cnt,0);
		add(cnt,y,INF); add(y,cnt,0);
		cnt++;
		add(cnt,t,b); add(t,cnt,0);
		add(x,cnt,INF); add(cnt,x,0);
		add(y,cnt,INF); add(cnt,y,0);
	}
	//建边 
	
	while(bfs()) ans-=dfs(s,INF);
	//dinic 
	printf("%d\n",ans-res);
	return 0;
}
```

---

## 作者：⚡114514_zzm⚡ (赞：0)

#### 总体思路：
建立最小割模型，使 A 集合的点与S 连通， B 集合的点与T 连通。

#### 具体操作：
对于每个点 u，连边 (S->u)=VA_u，割掉这条边表示它不被放在 A 集合中；连边 (u->T)=VB_u ，割掉这条边表示它不被放在 B 集合中。       

对于已经确定的点 1 和点n ，连两条容量为正无穷的边 (S->1)=inf 和 (n->T)=inf ，这两条边都不会被割掉。

对于原图中的每条边，将其转化为容量为 EA_i/2+EB_i/2+EC_i的双向边，并对于两个端点，连接(S,u)=EA_i/2,(u,T)=EB_i/2 。     

如果两个端点都在 A 集合中，那么容量为 EB_i 的边会被割掉，如果两个端点都在 B 集合中，那么容量为EA_i 的边会被割掉，否则会割掉容量EA_i+EB_i+EC_i 的边。             

求出最小割即为损失， 减去损失即为答案。                  

输入的数字可能有奇数，可以把所有数字乘以二再进行处理。    
```
#include<bits/stdc++.h>
const int MAXN = 10000;
const int MAXM = 40000;
struct Node;
struct Edge;
struct Node {
	Edge *e, *c;
	int l;
} N[MAXN + 2];
struct Edge {
	Node *s, *t;
	int f, c;
	Edge *next, *r;
	Edge(Node *s, Node *t, const int c) : s(s), t(t), f(0), c(c), next(s->e) {}
};
template <typename T, size_t SIZE>
struct MemoryPool {
	char buf[SIZE * sizeof(T)], *cur;
	MemoryPool() : cur(buf) {}
	T *alloc() {
		if (cur == buf + SIZE * sizeof(T)) return (T *)malloc(sizeof(T));
		else {
			T *p = (T *)cur;
			cur += sizeof(T);
			return p;
		}
	}
};
int n, m;
MemoryPool<Edge, MAXM * 5 * 2 + MAXN * 2 * 2> pool;
struct Dinic {
	bool makeLevelGraph(Node *s, Node *t, const int n) {
		for (int i = 0; i < n; i++) N[i].l = 0, N[i].c = N[i].e;
		std::queue<Node *> q;
		q.push(s);
		s->l = 1;
		while (!q.empty()) {
			Node *v = q.front();
			q.pop();
			for (Edge *e = v->e; e; e = e->next) if (e->t->l == 0 && e->f < e->c) {
				e->t->l = v->l + 1;
				if (e->t == t) return true;
				else q.push(e->t);
			}
		}
		return false;
	}
	int findPath(Node *s, Node *t, int limit = INT_MAX) {
		if (s == t) return limit;
		for (Edge *&e = s->c; e; e = e->next) {
			if (e->t->l == s->l + 1 && e->f < e->c) {
				int f = findPath(e->t, t, std::min(limit, e->c - e->f));
				if (f > 0) {
					e->f += f, e->r->f -= f;
					return f;
				}
			}
		}
		return 0;
	}
	int operator()(const int s, const int t, const int n) {
		int ans = 0;
		while (makeLevelGraph(&N[s], &N[t], n)) {
			int f;
			while ((f = findPath(&N[s], &N[t])) > 0) ans += f;
		}
		return ans;
	}
} dinic;
inline void addEdge(const int s, const int t, const int c, const int rc = 0) {
	N[s].e = &(*(pool.alloc()) = Edge(&N[s], &N[t], c));
	N[t].e = &(*(pool.alloc()) = Edge(&N[t], &N[s], rc));
	N[s].e->r = N[t].e, N[t].e->r = N[s].e;
}
int main() {
	scanf("%d %d", &n, &m);
	int sum = 0;
	const int s = 0, t = n + 1;
	addEdge(s, 1, INT_MAX), addEdge(n, t, INT_MAX);
	for (int i = 2; i <= n - 1; i++) {
		int va;
		scanf("%d", &va), va *= 2;
		sum += va;
		addEdge(s, i, va);
	}
	for (int i = 2; i <= n - 1; i++) {
		int vb;
		scanf("%d", &vb), vb *= 2;
		sum += vb;
		addEdge(i, t, vb);
	}
	for (int i = 0; i < m; i++) {
		int u, v, ea, eb, ec;
		scanf("%d %d %d %d %d", &u, &v, &ea, &eb, &ec);
		ea *= 2, eb *= 2, ec *= 2;
		sum += ea, sum += eb;
		int c = (ea / 2 + eb / 2 + ec);
		addEdge(u, v, c, c);
		addEdge(s, u, ea / 2), addEdge(s, v, ea / 2);
		addEdge(u, t, eb / 2), addEdge(v, t, eb / 2);
	}
	int minCut = dinic(s, t, n + 2);
	printf("%d\n", (sum - minCut) / 2);
	return 0;
}

```


---


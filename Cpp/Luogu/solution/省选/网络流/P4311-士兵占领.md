# 士兵占领

## 题目描述

有一个 $M \times N$ 的棋盘，有的格子是障碍。现在你要选择一些格子来放置一些士兵，一个格子里最多可以放置一个士兵，障碍格里不能放置士兵。我们称这些士兵占领了整个棋盘当满足第 $i$ 行至少放置了 $L_i$ 个士兵，第 $j$ 列至少放置了 $C_j$ 个士兵。现在你的任务是要求使用最少个数的士兵来占领整个棋盘。

## 说明/提示

对于 $100 \%$ 的数据，$1 \le M, N \le 100$，$0 \le K \le M \times N$。

## 样例 #1

### 输入

```
4 4 4
1 1 1 1
0 1 0 3
1 4
2 2
3 3
4 3
```

### 输出

```
4```

# 题解

## 作者：GGN_2015 (赞：39)

这道题用上下界网络流可能有点大材小用了，其实一个普通的网络流就能解决问题。首先考虑逆向思维，求最少要使用的士兵个数，转化为，初始的时候所有能放士兵的地方都放了士兵的情况下，最多能删掉多少个士兵。

给每一行每一列分别建一个点，对于所有非障碍坐标(x,y)，从x行对应的点 向 y列对应的点连一条容量为1的边，表示这个位置的士兵最多可以删除一次。

源点向每一行对应的点连边，容量为这一行能删除的士兵个数的最大值（即 列数m - 这一行的障碍数 - 这一行需要的士兵数L\[i\]）。

每一列对应的点向汇点连边，容量为这一列能删除的士兵个数的最大值（即 行数n - 这一列的障碍数 - 这一列需要的士兵数C\[i\]）。

这样跑一个最大流，每一个单位的流量表示删除一个士兵，不难证明 任意一种流量状态都与一种合法的士兵删除方案相对应。

特判无解的情况，如果所有能放士兵的地方都放上了士兵，仍然存在行或列不满足限制条件，输出无解即可。

代码如下：

```cpp
#include <queue>
#include <cstdio>
#include <cctype>
#include <cstring>
#include <algorithm>
using namespace std;

const int maxn = 2*100 + 7, inf = 0x7f7f7f7f;

namespace dinic {
	struct Edge {
		int to, res;
	};
	vector<int> G[maxn];
	vector<Edge> edges;
	inline void addedge(int f, int t, int c) {
		edges.push_back((Edge){t, c});
		edges.push_back((Edge){f, 0});
		int m = edges.size();
		G[f].push_back(m - 2);
		G[t].push_back(m - 1);
	}
	int vis[maxn], d[maxn], cur[maxn], s, t;
	bool bfs() {
		memset(vis, 0x00, sizeof(vis));
		queue<int> q; q.push(s); vis[s] = 1; d[s] = 0;
		while(!q.empty()) {
			int x = q.front(); q.pop();
			for(int i = 0; i < G[x].size(); i ++) {
				Edge& e = edges[G[x][i]];
				if(e.res>0 && !vis[e.to]) {
					vis[e.to] = 1;
					d[e.to] = d[x] + 1;
					q.push(e.to);
				}
			}
		}
		return vis[t];
	}
	int dfs(int x, int a) {
		if(x==t || a==0) return a;
		int flow = 0, f;
		for(int& i = cur[x]; i < G[x].size(); i ++) {
			Edge& e = edges[G[x][i]];
			if(e.res>0 && d[e.to]==d[x]+1 && (f=dfs(e.to,min(a,e.res)))>0) {
				flow += f;
				a -= f;
				edges[G[x][i]^1].res += f;
				e.res -= f;
				if(a == 0) break;
			}
		}
		return flow;
	}
	int maxflow(int S, int T) {
		s=S;t=T; int flow = 0;
		while(bfs()) {
			memset(cur, 0x00, sizeof(cur));
			flow += dfs(s, inf);
		}
		return flow;
	}
}
using dinic::addedge;
using dinic::maxflow;

int m, n, k, L[maxn], C[maxn];
#define LX(x) (x)
#define LY(y) (m+(y))
#define ST    (n+m+1)
#define ED    (n+m+2)

int sol[maxn][maxn], iL[maxn], iC[maxn], acnt;

int main() {
	scanf("%d%d%d", &m, &n, &k); acnt = n*m;
	for(int i = 1; i <= m; i ++) scanf("%d", &L[i]);
	for(int i = 1; i <= n; i ++) scanf("%d", &C[i]);
	for(int i = 1; i <= k; i ++) {
		int x, y; scanf("%d%d", &x, &y);
		sol[x][y] = 1; iL[x] ++; iC[y] ++;
		acnt --;
	}
	for(int i = 1; i <= m; i ++) {
		for(int j = 1; j <= n; j ++)
			if(!sol[i][j]) addedge(LX(i), LY(j), 1);
	}
	for(int i = 1; i <= m; i ++) {
		int c = (n - iL[i]) - L[i];
		if(c < 0) {puts("JIONG!"); return 0;}
		addedge(ST, LX(i), c);
		//printf("[%3d] c = %3d iL = %3d L = %3d\n", i, c, iL[i], L[i]);
	}
	for(int i = 1; i <= n; i ++) {
		int c = (m - iC[i]) - C[i];
		if(c < 0) {puts("JIONG!"); return 0;}
		addedge(LY(i), ED, c);
		//printf("[%3d] c = %3d iC = %3d C = %3d\n", i, c, iC[i], C[i]);
	}
	int ans = acnt - maxflow(ST, ED);
	printf("%d\n", ans);
	return 0;
}
```


---

## 作者：CaptainSlow (赞：8)

因为看到之前的用上下界网络流的方法都是有错的，只是因为数据较弱得以通过了。因此在这里简要地写一写用上下界网络流的正确建图方法。

> 以下描述弧的属性均用数对 $(\text{lowerbound},\text{upperbound})$ 表示

## 错误的建图

我之前错误的建图是这样的：S向每个没有障碍的方格连边 (0,2)，方格向对应的行列连边 (0, 1)，行列向T连边 $(C_i/L_i,+\infty)$.

这样建后跑最小流。但是最后算答案的时候结果是不确定的，因为一个点对于行列的贡献可能会被算一次或者两次，这取决于对于行列的流量下限。而且我们不好去控制一个点被选了之后它就会自动向行和列都流1的流量。

## 正确的建图

每个行列都建一个点，S向每行连边 $(L_i, +\infty)$，每列向T连边 $(C_i,+\infty)$，对于没有障碍的点 $(x,y)$，由行 $x$ 向列 $y$ 连边 $(0,1)$.

这时候行和列的约束是完全可以得到满足的，并且也不会出现一个点被算两次或者一次的情况，最后跑最小流出来的结果就直接是答案了。

> 网络流建图真是奇妙～

---

## 作者：Infiltrator (赞：7)

[$\Large\color{#FFBBFF}\textit{Tian-Xing's blog}$](https://Tian-Xing.github.io)

------------

# Description

[传送门](https://www.luogu.com.cn/problem/P4311)

------------

# Solution

首先如果士兵只能给一行或一列造成贡献的答案是$\sum_{i = 1}^m l_i + \sum_{i = 1}^n c_i$。

但是发现有的士兵可以同时给一列和一行造成贡献。

那就算出这些士兵的个数就行了。

$S$向每一行连容量为$l_i$的有向边；每一列向$T$连容量为$c_i$的有向边。

如果坐标$(i,j)$不是障碍，那么第$i$行向第$j$列连容量为$1$的有向边。

跑出来的最大流就是贡献为$2$的士兵数量。

------------

# Code

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <queue>
using namespace std;

const int INF = 999999999;
const int N = 10050;
const int M = 200050;

int n, m, s, t, head[N], num = 1, dis[N], k, l[150], c[150], p[150][150], sum[500], ans;

struct Node
{
    int next, to, dis;
} edge[M * 2];

void Addedge(int u, int v, int w)
{
    edge[++num]= (Node){head[u], v, w};
    head[u] = num;
}

template <class T>
void Read(T &x)
{
    x = 0; int p = 0; char st = getchar();
    while (st < '0' || st > '9') p = (st == '-'), st = getchar();
    while (st >= '0' && st <= '9') x = (x << 1) + (x << 3) + st - '0', st = getchar();
    x = p ? -x : x;
    return;
}

template <class T>
void Put(T x)
{
    if (x < 0) putchar('-'), x = -x;
    if (x > 9) Put(x / 10);
    putchar(x % 10 + '0');
    return;
}

bool Bfs()
{
    queue<int> q;
    for (int i = 0; i <= t; i++) dis[i] = 0;
    dis[s] = 1; q.push(s);
    while (!q.empty())
    {
        int u = q.front(); q.pop();
        for (int i = head[u]; i; i = edge[i].next)
            if (!dis[edge[i].to] && edge[i].dis)
            {
                dis[edge[i].to] = dis[u] + 1;
                q.push(edge[i].to);
                if (edge[i].to == t) return 1;
            }
    }
    return 0;
}

int Dinic(int x, int flow)
{
    if (x == t || !flow) return flow;
    int rest = flow;
    for (int i = head[x]; i && rest; i = edge[i].next)
        if (edge[i].dis && dis[edge[i].to] == dis[x] + 1)
        {
            int v = edge[i].to;
            int tmp = Dinic(v, min(flow, edge[i].dis));
            rest -= tmp;
            edge[i].dis -= tmp;
            edge[i ^ 1].dis += tmp;
            if (!tmp) dis[v] = 0;
        }
    return flow - rest;
}

void Add(int u, int v, int w)
{
	Addedge(u, v, w);
	Addedge(v, u, 0);
	return;
}

int Maxflow()
{
	int maxflow = 0, tmp;
	while (Bfs())
	{
		tmp = Dinic(s, INF);
		if (tmp) maxflow += tmp;
	}
	return maxflow;
}

int main()
{
	Read(m); Read(n); Read(k);
	for (int i = 1; i <= m; i++) Read(l[i]), ans += l[i];
	for (int i = 1; i <= n; i++) Read(c[i]), ans += c[i];
	int x, y;
	for (int i = 1; i <= k; i++) Read(x), Read(y), p[x][y] = 1;
	s = 0, t = n + m + 1;
	for (int i = 1; i <= m; i++) Add(s, i, l[i]);
	for (int i = 1; i <= n; i++) Add(i + m, t, c[i]);
	for (int i = 1; i <= m; i++)
		for (int j = 1; j <= n; j++)
		{
			if (!p[i][j])
				Add(i, j + m, 1);
			sum[i] = sum[i] + !p[i][j];
			sum[j + m] = sum[j + m] + !p[i][j];
		}
	for (int i = 1; i <= m; i++) if (sum[i] < l[i]) { puts("JIONG!"); return 0; } 
	for (int j = 1; j <= n; j++) if (sum[j + m] < c[j]) { puts("JIONG!"); return 0; } 
	Put(ans - Maxflow());
    return 0;
}
```

---

## 作者：Great_Influence (赞：4)

有上下界最小费用流。

几乎就是模板了。

用$(u,v,b,c,w)$表示一条从$u$连向$v$，下界为$b$，上界为$c$，费用为$w$的边，则

对于每一行，连边$(s,i,l[i],m,0)$

对于每一列，连边$(i,t,c[i],n,0)$

对于每个点，连边$(i,j,0,1,1)$

然后改成无源汇网络流，跑一遍费用流即可。

代码(Dinic)：

```cpp
#include<bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp>
#define Rep(i,a,b) for(register int i=(a),i##end=(b);i<=i##end;++i)
#define Repe(i,a,b) for(register int i=(a),i##end=(b);i>=i##end;--i)
#define For(i,a,b) for(i=(a),i<=(b);++i)
#define Forward(i,a,b) for(i=(a),i>=(b);--i)
template<typename T>inline void read(T &x)
{
    T f=1;x=0;char c;
    for(c=getchar();!isdigit(c);c=getchar())if(c=='-')f=-1;
    for(;isdigit(c);c=getchar())x=x*10+(c^48);
    x*=f;
}
using namespace std;
void file()
{
#ifndef ONLINE_JUDGE
    freopen("water.in","r",stdin);
    freopen("water.out","w",stdout);
#endif
}
const int MAXN=811;
static int n,m,k;
static int l[MAXN],c[MAXN];
static int ans;
static struct edge
{
    int v,w,f,nxt;
}p[MAXN*MAXN<<2];
static int head[MAXN],e=1,s,t,ss,tt;
static bool a[MAXN][MAXN];
inline void add(int u,int v,int f,int w,bool laz=1)
{
    p[++e]=(edge){v,w,f,head[u]};head[u]=e;
    if(laz)add(v,u,0,-w,0);
}
inline void init()
{
    read(n);read(m);read(k);
    Rep(i,1,n)read(l[i]);
    Rep(i,1,m)read(c[i]);
    s=n+m+1;t=s+1;ss=t+1;tt=ss+1;
    static int x,y,cnt,cnss=0,cntt=0;
    Rep(i,1,k)read(x),read(y),a[x][y]=true;
    Rep(i,1,n)
    {
        cnt=0;
        Rep(j,1,m)if(!a[i][j])
        {
            ++cnt;
            add(i,n+j,1,1);
        }
        if(cnt<l[i]){cout<<"JIONG!"<<endl;exit(0);}
        add(s,i,cnt-l[i],0);if(l[i])add(ss,i,l[i],0);
		cnss+=l[i];
    }
    Rep(i,1,m)
    {
        cnt=0;
        Rep(j,1,n)if(!a[j][i])++cnt;
        if(cnt<c[i]){cout<<"JIONG!"<<endl;exit(0);}
        add(n+i,t,cnt-c[i],0);if(c[i])add(n+i,tt,c[i],0);
		cntt+=c[i];
    }
    add(ss,t,cntt,0);add(s,tt,cnss,0);
    add(t,s,0xFFFFFFF,0);
}
static int cur[MAXN],fee;
static int vis[MAXN],dis[MAXN];
static deque<int>G;
inline bool spfa(int s,int t)
{
    memset(dis,0x3f,sizeof dis);
    dis[s]=0;G.push_back(s);
    static int u;vis[s]=true;
    while(!G.empty())
    {
        u=G.front();G.pop_front();
        for(register int v=head[u];v;v=p[v].nxt)
            if(p[v].f&&dis[p[v].v]>dis[u]+p[v].w)
            {
                dis[p[v].v]=dis[u]+p[v].w;
                if(!vis[p[v].v])
                {
                    vis[p[v].v]=true;
                    if(G.empty()||dis[p[v].v]<dis[G.front()])
                        G.push_front(p[v].v);
                    else G.push_back(p[v].v);
                }
            }
        vis[u]=false;
    }
    return dis[t]^dis[0];
}
int dfs(int u,int t,int flow=0xFFFFFFF)
{
    if(!flow||u==t)return flow;
    vis[u]=true;int sum=0;
    for(register int &v=cur[u];v;v=p[v].nxt)
        if(!vis[p[v].v]&&p[v].f&&dis[p[v].v]==dis[u]+p[v].w)
        {
            int f=dfs(p[v].v,t,min(flow,p[v].f));
            p[v].f-=f;p[v^1].f+=f;
            fee+=p[v].w*f;sum+=f;flow-=f;
        }
    vis[u]=false;
    return sum;
}
inline void Dinic(int s,int t)
{while(spfa(s,t))memcpy(cur,head,sizeof head),dfs(s,t);}
inline void solve()
{
    Dinic(ss,tt);
    cout<<fee<<endl;
}
int main()
{
    file();
    init();
    solve();
    return 0;
}

```

### Upt:
啊呀被叉了。。。

其实推导没有写错，只是有几条边忘记建了。。。

---

## 作者：Tyher (赞：2)

### 最小费用最大流

方便表述， $(x,y)$表示流量为$x$，费用为$y$的边

$S$为源点，$T$为汇点

每个空地都是一个点，每一行和每一列额外建一个点

首先删去不合法的点

$S$与坐标为$(i,j)$的点连$(inf,0)$

坐标$(i,j)$的点与表示横坐标$i$的点连$(1,1)$

坐标$(i,j)$的点与表示纵坐标$j$的点连$(1,1)$

表示横坐标$i$的点与$T$连$(lin[i],0)$

表示横坐标$j$的点与$T$连$(col[j],0)$

这样的连边，表示如果决策$(i,j)$，会对横坐标$i$的点,横坐标$j$的点产生$1$的贡献，消耗$1$的代价

跑最小费用最大流就是答案$*2$

最后输出$ans/2$

---


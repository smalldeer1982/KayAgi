# [国家集训队] 航班安排

## 题目背景

1. wqs 爱好模拟飞行。
2. clj 开了一家神犇航空，由于 clj 还要玩游戏，所以公司的事务由你来打理。

注意：题目中只是用了这样一个背景，并不与真实 / 模拟飞行相符。

## 题目描述

神犇航空有 $K$ 架飞机，为了简化问题，我们认为每架飞机都是相同的。神犇航空的世界中有 $N$ 个机场，以 $0\cdots N-1$ 编号，其中 $0$ 号为基地机场，每天 $0$ 时刻起飞机才可以从该机场起飞，并不晚于 $T$ 时刻回到该机场。

一天，神犇航空接到了 $M$ 个包机请求，每个请求为在 $s$ 时刻从 $a$ 机场起飞，在恰好 $t$ 时刻到达 $b$ 机场，可以净获利 $c$。换言之，你只需要在 $s$ 时刻在 $a$ 机场选择提供一架飞机给请求方，那么这架飞机就会在 $t$ 时刻准时出现在 $b$ 机场，并且你将获得 $c$ 的净利润。

设计一种方案，使得总收益最大。

## 说明/提示

对于 $10\%$ 的测试数据，$K=1$；

另有 $20\%$ 的测试数据，$K=2$；

对于全部的测试数据，$1\le N,M\le 200$，$1\le K\le 10$，$1\le T\le 3000$，$1\le t_{i,j}\le 200$，$f_{i,j}\le 2\times 10^3$，$0\le a,b<N$，$0\le s\le t\le T$，$0\le c\le 10000$，$t_{i,i}=f_{i,i}=0$，$t_{ij}\le t_{i,k}+t_{k,j}$，$f_{i,j}\le f_{i,k}+f_{k,j}$。

## 样例 #1

### 输入

```
2 1 1 10
0 5
5 0
0 5
5 0
0 1 0 5 10```

### 输出

```
5```

# 题解

## 作者：ycyaw (赞：23)

好像这道题并没有其他两篇题解说的那么简单吧？？？~~或者是我太菜了~~

考虑以请求为点进行建图，对每个请求进行拆点，拆点后两个点之间连价值为$c$，流量为$1$的边，代表着一个请求只能执行一次。

然后我们考虑时间限制：

对于一个请求，如果$0$时刻可以从$0$机场飞到该请求的起点机场，那么源点向该请求连价值为($-$飞行费用)，流量为$INF$的边，同理，若一个请求的结束时间，加上它的结束机场飞回$0$的时间小于等于总的时间限制，该请求向汇点连边。

但是每次执行完一个请求并未规定一定要飞回$0$机场，也可以飞去其他请求的起点机场，所以两两枚举请求，如果满足时间条件也进行连边。

最后考虑有$k$架飞机，所以再建一个源点，向原来的源点连费用为$0$，流量为$k$的边即可。

最后跑最大费用最大流。

```cpp
#include<bits/stdc++.h>
#define ts cout<<"ok"<<endl
#define ll long long
#define hh puts("")
#define time TTTT
using namespace std;
int n,m,k,tim,t[205][205],w[205][205],head[100005];
int vis[100005],dis[100005],cnt=1,cost,ans,time,st,ed;
struct node{
    int a,b,s,t,c;
}q[1005];
struct Edge{
    int v,nx,s,val;
}e[1000005];
inline int read(){
    int ret=0,ff=1;char ch=getchar();
    while(!isdigit(ch)){if(ch=='-') ff=-ff;ch=getchar();}
    while(isdigit(ch)){ret=(ret<<3)+(ret<<1)+(ch^48);ch=getchar();}
    return ret*ff;
}
inline void add(int x,int y,int val,int s){
    e[++cnt].v=y;
    e[cnt].val=val;
    e[cnt].s=s;
    e[cnt].nx=head[x];
    head[x]=cnt;
}
inline bool spfa(){
    for(int i=0;i<=ed;i++) dis[i]=-1e9,vis[i]=0;
    queue<int> q;
    dis[st]=0;
    q.push(st);
    while(!q.empty()){
        int now=q.front();
        q.pop();
        vis[now]=0;
        for(int i=head[now];i;i=e[i].nx){
            int v=e[i].v;
            if(dis[v]<dis[now]+e[i].val&&e[i].s){
                dis[v]=dis[now]+e[i].val;
                if(!vis[v]){
                    vis[v]=1;
                    q.push(v);
                }
            }
        }
    }
    return dis[ed]!=-1e9;
}
int dfs(int now,int ma){
    if(now==ed){
        ans+=ma;
        return ma;
    }
    vis[now]=time;
    int used=0,t;
    for(int i=head[now];i;i=e[i].nx){
        int v=e[i].v;
        if((vis[v]!=time||v==ed)&&e[i].s&&dis[v]==dis[now]+e[i].val){
            if(t=dfs(v,min(ma-used,e[i].s))){
                e[i].s-=t;
                e[i^1].s+=t;
                cost+=t*e[i].val;
                used+=t;
                if(used==ma) break;
            }
        }
    }
    return used;
}
signed main(){
    n=read(),m=read(),k=read(),tim=read();
    for(int i=0;i<n;i++)
        for(int j=0;j<n;j++)
            t[i][j]=read();
    for(int i=0;i<n;i++)
        for(int j=0;j<n;j++)
            w[i][j]=read();
    st=m*2+5,ed=m*2+10;
    for(int i=1;i<=m;i++){
        q[i].a=read();
        q[i].b=read();
        q[i].s=read();
        q[i].t=read();
        q[i].c=read();
    }
    for(int i=1;i<=m;i++){
        add(i*2-1,i*2,q[i].c,1);
        add(i*2,i*2-1,-q[i].c,0);
        if(q[i].t+t[q[i].b][0]<=tim){
            add(i*2,ed,-w[q[i].b][0],1e9);
            add(ed,i*2,w[q[i].b][0],0);
        }
        else continue;
        if(t[0][q[i].a]<=q[i].s){
            add(st+1,i*2-1,-w[0][q[i].a],1e9);
            add(i*2-1,st+1,w[0][q[i].a],0);
        }
        for(int j=1;j<=m;j++){
            if(q[i].t+t[q[i].b][q[j].a]<=q[j].s){
                add(i*2,j*2-1,-w[q[i].b][q[j].a],1e9);
                add(j*2-1,i*2,w[q[i].b][q[j].a],0);
            }
        }
    }
    add(st,st+1,0,k);
    add(st+1,st,0,0);
    while(spfa()){
        do{
            time++;
            dfs(st,1e9);
        }while(vis[ed]==time);
    }
    printf("%d",cost);
    return 0;
}
```


---

## 作者：JohnJoeZhu (赞：14)

[题目传送门](https://www.luogu.com.cn/problem/P4452)

吐槽：为什么写题的人这么少呢？

### 1.算法
- 图论

飞机飞来飞去，又有边权（时间&费用），那就是图论了 ~~（雾）~~

- 网络流VS最长路

每个收益之间有限制，还有只收益1次的限制，以及时间的限制，还要收入支出，约束条件多，用网络流肯定是得心应手

- 最小费用最大流

看到最大收益就是费用流没跑了吧

补充：

在这里其实是求最大费用，但是SPFA可以处理负边权，所以就把花费变成其相反数，然后跑最短路，花费再取负；或者直接把SPFA改成最长路
### 2.建图
**毒瘤网络流，建模最毒瘤**

- 建模对象：点或请求

如果按照点来建边，需要按时间分层，然后一同乱搞，会显得比较复杂

选择请求来建边，则只需要关注请求与请求之间的关系，时间一维可以处理掉，显得更简单了，那对象就是它了

- 源点

先判断从0可不可以直达请求的起点，然后建边，流量$inf$，费用$f[0][a]$

但是我们又关注到$k$架飞机这个条件，不知道$k$会去那条路，所以就再建一个真正的源点，向先前的源点（表示基地）建一条流量$k$，费用0的边

- 汇点

判断请求结束后能不能在规定时间内到达基地点0，然后建边，流量$inf$，费用$f[b][0]$

- 请求之间的转移

根据贪心，能够不回基地，就不要回去，所以我们要考虑请求之间的转移

那么怎么转移呢？

其实只要$m^2$枚举每个请求之间能不能满足 前一个结束后有时间到达后一个的开始时间 即可

然后就连边 流量$inf$，边权$f[b_i][a_j]$

这里要注意的是，很多题解（目前为止）都没有说明的是：

$$
t_{ij} <=t_{ik} +t _ {kj} 
$$
$$
f_{ij} <=f_{ik} +f _ {kj}
$$

也就是说，数据范围里面保证了最短路

我觉得说还是提示一下比较好，~~主要是我太菜了~~

如果没有保证，那就要手动跑最短路了

- 控制请求的**净收益**

其实就是每个请求只有1次贡献

这个如果在座的大佬题目写多了，就会发现这是套路来着的

给个[套路题](https://www.luogu.com.cn/problem/P4013)

其实就是拆点，把一个请求拆成入点和出点，然后连一条  流量1，费用$c$ 的边，就可以解决问题

如果两个请求之间可转移，那么就从出点连向入点

**完结撒花**

### 3.代码
这里只给出建图代码，跑最小费用最大流模板就不要影响~~美观度~~了

一些不成大问题的就在注释里说了

```cpp
void add(int u,int v,int w,int f){add_edge(u,v,w,f),add_edge(v,u,0,-f);} \\懒人反向边建图，add_edge就是邻接表建边了，大家都懂吧

struct pp{
	int a,b,c,s,t;
}q[maxn];
int time[maxn][maxn],f[maxn][maxn];
int main()
{
   	scanf("%d%d%d%d",&n,&m,&k,&T);
   	s=0,t=2*m+2;\\s是真源点，假源点是t-1
   	for(int i=1;i<=n;i++)
   		for(int j=1;j<=n;j++)
   			scanf("%d",&time[i][j]);
   	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			scanf("%d",&f[i][j]);
	for(int i=1;i<=m;i++) scanf("%d%d%d%d%d",&q[i].a,&q[i].b,&q[i].s,&q[i].t,&q[i].c),q[i].a++,q[i].b++;\\读入点从1开始，所以++
	for(int i=1;i<=m;i++) 
	{
		add(i,i+m,1,-q[i].c);\\反向边代码在上面哦
		if(q[i].t+time[q[i].b][1]<=T) add(i+m,t,inf,f[q[i].b][1]);
		else continue;\\都不能回家怎么还能转移呢
		if(q[i].s>=time[1][q[i].a]) add(t-1,i,inf,f[1][q[i].a]);
		for(int j=1;j<=m;j++)
			if(q[i].t+time[q[i].b][q[j].a]<=q[j].s)
				add(i+m,j,inf,f[q[i].b][q[j].a]),add(i,j,inf,f[q[i].b][q[j].a]);\\这里多建了一条入点到入点的边，不加也没有问题的
	}
	add(s,t-1,k,0);\\控制k架飞机
	Dinic();\\跑最小费用最大流
	printf("%d",-cost);\\因为是边权全部取反，所以答案也要取反
    return 0;
 } 
```

---

## 作者：FreeTimeLove (赞：8)

## 一、题意

给定 $n$ 个点及飞机在每两点之间**空载**航行的时间 $t_{i,j}$ 及花费 $f_{i,j}$，有 $m$ 个订单，每个订单要求在 $sx_i$ 时刻有飞机到达 $sp_i$，并使此飞机在 $tx_i$ 时刻到达 $tp_i$，获利 $c_i$。有 $k$ 架飞机，每架飞机从 $0$ 时刻开始可以从 $1$ 号站点出发，并必须最晚在 $T$ 时刻回到 $1$ 号站点。求**最大获利**。

**注意**：要**尽可能多**地接订单（题干中未表达出）。

## 二、思路

我们观察一架飞机一天中的航程：

在 $0$ 时刻从 $1$ 号站点（个人习惯从 $1$ 开始标号）出发，在不晚于 $sx_{i}$ 时刻到达 $sp_i$ 号站点，在 $tx_i$ 时刻从 $tp_i$ 号站点出发，在不晚于 $sx_{j}$ 时刻到达 $sp_j$ 号站点……在 $tx_k$ 时刻从 $tp_k$ 号站点出发，在不晚于 $T$ 时刻回到 $1$ 号站点。

因为题目要求在尽可能多地接订单的情况下获利（收入减成本）最大,我们可以考虑构建**最大费用最大流**模型。

我们对于每一个订单设点。因为一个订单只能接一次，我们对它拆点，入点向出点连容量为 $1$、费用为 $c_i$ 的边。

建边：

+ 如果从 $1$ 号站点可以**及时**到达订单 $i$ 的起始站点 $sx_i$，由源点 $s$ 向订单 $i$ 的入点建容量为 $1$、费用为 $-f_{1,sx_i}$ 的边；

+ 如果从订单 $i$ 的终止站点 $tx_i$ 可以**及时**回到 $1$ 号站点，由订单 $i$ 的出点向汇点 $t$ 建容量为 $1$、费用为 $-f_{tx_i,1}$ 的边；

+ 对于两个订单 $i,j$，如果从 $tx_i$ 可以**及时**到达 $sx_j$，由订单 $i$ 的出点向订单 $j$ 的入点建容量为 $1$、费用为 $-f_{tx_i,sx_j}$ 的边。

还要注意一共有 $k$ 架飞机，即最大流上限为 $k$，因此我们还要创建**真正的**源点 $s'$，向“源点” $s$ 建容量为 $k$、费用为 $0$ 的边。

然后我们对边权取反跑**最小费用最大流**再对费用取反即为答案。

### AC code

```cpp
//written_by_FTL
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<queue>
#include<string>
#include<map>
#define ll long long
#define db double
using namespace std;
const int N=505;
int rd(){
	int ans=0,f=0;
	char ch=getchar();
	while(ch<'0'||ch>'9')f^=(ch=='-'),ch=getchar();
	while(ch>='0'&&ch<='9')ans=(ans<<3)+(ans<<1)+(ch^48),ch=getchar();
	if(f)ans=-ans;
	return ans;
}
int n,m,k,u,v,c,s,t,a[205][205],f[205][205],minc;
int T,sp[N],tp[N],sx[N],tx[N];
int nd[N],nds[N],tt=1,bk[N],cnt=1;
int h[N],dis[N],INF=0x3f3f3f3f;
struct edge{
	int v,w,x,nxt;
}e[200005];
void add(int u,int v,int w,int x){
	e[++tt]={v,w,x,nd[u]};
	nd[u]=tt;
}
void adds(int u,int v,int w,int x){//快捷建边
	add(u,v,w,-x),add(v,u,0,x);
}
void spfa(){
	queue<int>que;
	memset(h,0x3f,sizeof h);
	que.push(s);
	bk[s]=1,h[s]=0;
	while(!que.empty()){
		u=que.front();
		que.pop();
		bk[u]=0;
		for(int i=nd[u];i;i=e[i].nxt){
			v=e[i].v;
			if(e[i].w&&h[v]>h[u]+e[i].x){
				h[v]=h[u]+e[i].x;
				if(bk[v]==0)que.push(v),bk[v]=1;
			}
		}
	}
}
struct node{
	int dis,u;
	bool operator <(const node &x)const{
		return x.dis<dis;
	}	
};
bool dij(){
	priority_queue<node>que;
	memset(dis,0x3f,sizeof dis);
	dis[s]=0;
	que.push({0,s});
	while(!que.empty()){
		u=que.top().u;
		que.pop();
		if(bk[u]==cnt)continue;
		bk[u]=cnt,nds[u]=nd[u];
		for(int i=nd[u];i;i=e[i].nxt){
			v=e[i].v;
			if(e[i].w&&dis[v]>dis[u]+e[i].x+h[u]-h[v]){
				dis[v]=dis[u]+e[i].x+h[u]-h[v];
				if(bk[v]!=cnt)que.push({dis[v],v});
			}
		}
	}
	return dis[t]<INF;
}
int dfs(int u,int flw){
	if(u==t)return flw;
	int ret=0,x;
	bk[u]=cnt;
	for(int i=nds[u];i;i=nds[u]){
		nds[u]=e[i].nxt;
		int v=e[i].v;
		if(e[i].w==0||bk[v]==cnt||dis[v]!=dis[u]+e[i].x+h[u]-h[v])continue;
		x=dfs(v,min(flw,e[i].w));
		if(x){
			flw-=x,ret+=x;
			e[i].w-=x,e[i^1].w+=x;
			minc+=x*e[i].x;
			if(flw==0)break;
		} 
	}
	bk[u]=0;
	return ret;
}
int dinic(){//类 dinic 费用流
	int flw=0;
	spfa();
	while(dij()){
		++cnt,flw+=dfs(s,INF);
		for(int i=1;i<=t;i++)h[i]+=dis[i];
	}
	return flw;
}
int main(){
	n=rd(),m=rd(),k=rd(),T=rd();
	s=m+m+1,t=s+2;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)a[i][j]=rd();
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)f[i][j]=rd();
	adds(s,s+1,k,0);
	for(int i=1;i<=m;i++){
		sp[i]=rd(),tp[i]=rd(),sx[i]=rd(),tx[i]=rd(),c=rd();
		sp[i]++,tp[i]++;
		adds(i,i+m,1,c);//拆点
		if(a[1][sp[i]]<=sx[i])adds(s+1,i,1,-f[1][sp[i]]);
		if(tx[i]+a[tp[i]][1]<=T)adds(i+m,t,1,-f[tp[i]][1]);
		for(int j=1;j<i;j++){
			if(tx[i]+a[tp[i]][sp[j]]<=sx[j])adds(i+m,j,1,-f[tp[i]][sp[j]]);
			if(tx[j]+a[tp[j]][sp[i]]<=sx[i])adds(j+m,i,1,-f[tp[j]][sp[i]]);
		}
	}
	dinic();
	printf("%d\n",-minc);
	return 0;
}
```

## 三、后记

1. 注意飞机在**载客**的时候是不计成本的，也不用管空载在两点之间飞行的时间是否大于订单的实际时间。

2. 对于任意 $3$ 点 $i,j,k$，满足 $t_{i,j}\le t_{i,k}+t_{k,j},f_{i,j}\le f_{i,k}+f_{k,j}$。如果没有这个条件，此题就不能这样做了。

### $\text{The End.}$

---

## 作者：541forever (赞：2)

**题外话**

  由于本蒟蒻数据结构已经调吐了，只好写道网络瘤来练练手。

**观察**

  首先我们可以发现这题是要找到一种方案使得一堆飞机飞来飞去的总收益最大，那么要满足 $k$ 辆无差别飞机的约束，我们可以想到可以用最大流来满足这个约束，而又要使得总收益最大，自然地，我们便可以想到**最大费用最大流**。那么该如何建图呢？

**建模**

**错误**建模

  下面先给大家避个雷，初看这道题时，我们不难想到一个显然的但复杂度不太正确的解法，就是按时间拆点，将每个机场的每个时间都看作一个点，但这样的话点的个数就达到了 $200 \times 300 = 60000$，也就是 $10^4$ 级，这是一个不太容易接受的点数，应该也是无法通过这道题的（或许小常数选手可以？（bushi）），接下来我们考虑这些点是否都必要。

显然我们可以发现绝大多数的这些点都是不必要的，也就是在按时间分层时的
```cpp 
add_edge(i+(t-1)*n,i+t*n,1,0)
```
这一连边在大多数情况下都是不必要的，那么我们可以考虑哪些点时必要的。

下面是**正解**

  （下面的请求的左右端点表示该请求的飞机的起点机场和终点机场，$F$ 表示流量，$w$ 表示费用，$q$ 表示请求，$x$ 表示一个请求的左端点，$y$ 表示一个请求的右端点，$c$ 为一个请求的获利）

  我们发现只有在请求时的左右端点才时必要的，那么我们可以直接考虑以请求中的左右端点为结点建模，那么我们直接模拟题目中的要求，首先我们建立一个超级源和一个汇点，再将起点看作源点，将超级源向起点连一条 $F = k, w = 0$ 的边，表示起点拥有 $k$ 辆飞机，然后若起点能在当前请求 $i$ 中的起点时刻之前到达该请求左端点时，我们将起点向该左端点连一条 $F = 1, w = - f_{0,q_i.x}$ 的边，接着我们将一个请求的左右端点连一条 $F = 1, w = {q_i.c}$ 的边，然后若该请求的终点时刻加上该请求右端点到起点的时间小于等于结束时刻，我们将该请求的右端点向汇点连一条 $F = 1, w = - f_{q_i.y,0}$。难道这样就结束了吗？当然不是，飞机在完成请求后不仅可以飞回起点，也可以飞向别的机场，最后我们枚举判断一下在完成请求 $i$ 后是否能在请求 $j$ 的起始时刻之前到达请求 $j$，若可以到达，则将请求 $i$ 的左端点向 请求 $j$ 的右端点连一条 $F = 1, w = f_{q_i.y,q_j .x}$ 的边。
  
  这样的话我们就满足了题目中的每个约束，跑一遍最大费用最大流即可。

**Tip**

  在跑最大费用最大流中求最长路时，我们常常可以将边权的费用**取相反数**，跑最小费用最大流，最后答案再**取相反数**即可。

  接下来是本蒟蒻丑陋的大常数代码
  ~~（我知道你们只看这个）~~
  ```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int inf=0x3f3f3f3f3f;
inline int read(){
	int x=0,f=1;
	char ch;
	do{
		ch=getchar();
		if(ch=='-'){
			f=-1;
		}
	}while(!(ch>='0'&&ch<='9'));
	while(ch>='0'&&ch<='9'){
		x=(x<<1)+(x<<3)+ch-'0';
		ch=getchar();
	}
	return x*f;
}
int n,m,k,E,f[205][205],t[205][205],edgenum=1,head[405],S,SS=1,T,dist[405],now[405],vis[405],ans;//f,t为题目中所给，S是超级源，SS为起点，T是汇点
struct query{
    int a,b,s,t,c;
}q[205];
struct Edge{
    int from,to,next,w,f;
}edge[320005];
void add_edge(int from,int to,int f,int w){
    edge[++edgenum].from=from;
    edge[edgenum].next=head[from];
    edge[edgenum].to=to;
    edge[edgenum].w=w;
    edge[edgenum].f=f;
    head[from]=edgenum;
    edge[++edgenum].next=head[to];
    edge[edgenum].from=to;
    edge[edgenum].to=from;
    edge[edgenum].f=0;
    edge[edgenum].w=-w;
    head[to]=edgenum;
}//连边
bool spfa(){
    for(int i=1;i<=T;++i){
        vis[i]=0;
        dist[i]=inf;
    }
    queue<int> q;
    q.push(S);
    dist[S]=0;
    while(!q.empty()){
        int x=q.front();
        q.pop();
        vis[x]=0;
        now[x]=head[x];
        for(int i=head[x];i;i=edge[i].next){
            if(edge[i].f){
                int v=edge[i].to;
                if(dist[v]>dist[x]+edge[i].w){
                    dist[v]=dist[x]+edge[i].w;
                    if(vis[v]){
                        continue;
                    }
                    vis[v]=1;
                    q.push(v);
                }
          }
        }
    }
    return dist[T]<inf;
}
int dinic(int x,int flow){
    if(x==T){
        return flow;
    }
    int used=0,i;
    vis[x]=1;
    for(i=now[x];i;i=edge[i].next){
        if(edge[i].f){
            int v=edge[i].to;
            if(vis[v]){
                continue;
            }
            if(dist[v]==dist[x]+edge[i].w){
                int k=dinic(v,min(flow-used,edge[i].f));
                if(!k){
                    continue;
                }
                used+=k;
                edge[i].f-=k;
                edge[i^1].f+=k;
                ans+=k*edge[i].w;
                if(used==flow){
                    break;
                }
            }
        }
    }
    now[x]=i;
    return used;
}
//最小费用最大流
signed main(){
    n=read();
    m=read();
    k=read();
    E=read();
    for(int i=1;i<=n;++i){
        for(int j=1;j<=n;++j){
            t[i][j]=read();
        }
    }
    for(int i=1;i<=n;++i){
        for(int j=1;j<=n;++j){
            f[i][j]=read();
        }
    }
    for(int i=1;i<=m;++i){
        q[i].a=read()+1;
        q[i].b=read()+1;
        q[i].s=read();
        q[i].t=read();
        q[i].c=read();
    }
    T=(m+1)*2;
    //建模
    add_edge(S,SS,k,0);
    for(int i=1;i<=m;++i){
        int x=q[i].a,y=q[i].b,s=q[i].s,e=q[i].t,c=q[i].c;
        if(t[1][x]<=s){
            add_edge(SS,i*2,1,f[1][x]);
        }
        if(t[y][1]+e<=E){
            add_edge(i*2+1,T,1,f[y][1]);
        }
        add_edge(i*2,i*2+1,1,-c);
        for(int j=1;j<=m;++j){
            int xx=q[j].a,ss=q[j].s;
            if(i!=j){
                if(e+t[y][xx]<=ss){
                    add_edge(i*2+1,j*2,1,f[y][xx]);
                }
            }
        }
    }
    while(spfa()){
        dinic(S,inf);
    }
    printf("%lld\n",-ans);//答案要取相反数
    return 0;
}
```


---

## 作者：TonyYin (赞：2)

# P4452 [国家集训队]航班安排 

## 题意

有  $K$ 架飞机，$N$ 个机场，其中 $1$ 号为基地机场。

每天 $0$ 时刻，飞机才可以从基地机场起飞，并且不晚于 $T$ 时刻回到基地机场。

对于 $\forall i, j$，题目给定 $t_{i, j}$ 表示从 $i$ **空载**飞到 $j$ 需要的时间，$f_{i, j}$ 表示从 $i$ **空载**飞到 $j$ 需要的费用。

有 $M$ 个**包机请求**，给定 $(a, b, s, t, c)$，表示在 $s$ 时刻从 $a$ 机场起飞，可以恰好在 $t$ 时刻到达 $b$ 机场，净获利 $c$.

注意，包机请求的飞行时间为 $(t-s)\neq t_{a, b}$. 包机请求的费用为 $-c$，**与 $f$ 不同**。

求最大总收益。

## 分析

不难发现，可以使用费用流算法。

对请求进行拆点。**起点向终点连容量为 $1$，价值为 $c$ 的边。**

然后处理时间限制。对于每个请求，如果：

- **可以在请求开始之前，从基地飞到起点：**从源点向请求起点连边，容量为 $\inf$，价值为对应的 $-f$.

- **可以在 $T$ 之前，从终点飞到基地：**从终点向汇点连边，容量为 $\inf$，价值为对应的 $-f$.

又因为执行请求之后，可以飞到别的请求机场。所以**两两枚举请求**，如果从终点飞到另一个请求的起点**满足时间条件，就连边**。

处理 $k$ 架飞机。**再建立一个源点**，向原来的源点连容量为 $k$，费用为 $0$ 的边即可。

跑**最大费用最大流**。

## 代码

```c++
#include <bits/stdc++.h>

using namespace std;
const int MAXN = 408, MAXM = 1e6;
const int inf = 0x3f3f3f3f;
int n, m, k, ed;
int Tim[MAXN][MAXN], Cos[MAXN][MAXN];
int S, T;
struct Edge{
    int from, to, nxt, flow, val;
}edge[MAXM];
int head[MAXN], e_cnt = 1;
void add(int u, int v, int w, int c) {
    edge[++e_cnt].from = u;
    edge[e_cnt].to = v;
    edge[e_cnt].flow = w;
    edge[e_cnt].val = c;
    edge[e_cnt].nxt = head[u];
    head[u] = e_cnt;
}
void add_edge(int u, int v, int w, int c) {
    add(u, v, w, c);
    add(v, u, 0, -c);
}
struct In{int a, b, s, t, c;} in[MAXN];
int dis[MAXN], pre[MAXN];
bool vis[MAXN];
bool SPFA() {
    memset(dis, 0x3f, sizeof(dis)); dis[S] = 0;
    memset(vis, 0, sizeof(vis)); vis[S] = true;
    memset(pre, 0, sizeof(pre));
    queue<int> q; q.push(S);
    while(!q.empty()) {
        int x = q.front(); q.pop(); vis[x] = false;
        for(int i = head[x]; i; i = edge[i].nxt) {
            int v = edge[i].to, flow = edge[i].flow, val = edge[i].val;
            if(flow && dis[x] + val < dis[v]) {
                dis[v] = dis[x] + val;
                pre[v] = i;
                if(!vis[v]) {
                    q.push(v); vis[v] = true;
                }
            }
        }
    }
    return (pre[T] != 0);
}
pair<int, int> MCMF() {
    int flow = 0, cost = 0;
    while(SPFA()) {
        int minflow = inf;
        for(int i = T; i != S; i = edge[pre[i]].from) {
            minflow = min(minflow, edge[pre[i]].flow);
        }
        flow += minflow;
        for(int i = T; i != S; i = edge[pre[i]].from) {
            edge[pre[i]].flow -= minflow;
            edge[pre[i] ^ 1].flow += minflow;
            cost += edge[pre[i]].val * minflow;
        }
    }
    return make_pair(flow, cost);
}
int main() {
    scanf("%d%d%d%d", &n, &m, &k, &ed);
    S = 0; T = 2 * m + 2;
    for(int i = 1; i <= n; i++) {
        for(int j = 1; j <= n; j++) {
            scanf("%d", &Tim[i][j]);
        }
    }
    for(int i = 1; i <= n; i++) {
        for(int j = 1; j <= n; j++) {
            scanf("%d", &Cos[i][j]);
        }
    }
    add_edge(S, S + 1, k, 0);
    for(int i = 1; i <= m; i++) scanf("%d%d%d%d%d", &in[i].a, &in[i].b, &in[i].s, &in[i].t, &in[i].c);
    for(int i = 1; i <= m; i++) {
        add_edge(i + 1, i + m + 1, 1, -in[i].c);
        if(in[i].t + Tim[in[i].b + 1][1] <= ed) add_edge(i + m + 1, T, inf, Cos[in[i].b + 1][1]);
        if(in[i].s - Tim[1][in[i].a + 1] >= 0) add_edge(S + 1, i + 1, inf, Cos[1][in[i].a + 1]);
        for(int j = 1; j <= m; j++) {
            if(in[i].t + Tim[in[i].b + 1][in[j].a + 1] <= in[j].s) {
                add_edge(i + m + 1, j + 1, inf, Cos[in[i].b + 1][in[j].a + 1]);
            }
        }
    }
    cout << -MCMF().second << endl;
    return 0;
}
```



---

## 作者：Stinger (赞：2)

[传送门](https://www.luogu.com.cn/problem/P4452)

虽然这题是个套路的费用流，但是作为刚学网络流的蒟蒻还是想了挺久。

一开始我是想的将一个点按照时刻拆成 $T$ 个点，然而先不说能不能做，就这个点数也能直接爆炸。

但是注意到请求数很少，把请求看做边会发现做不出来而且也是不合理的，于是考虑把每个请求看作一个点，点权为  $c_i$。因为网络流只能在边上搞事情，所以拆一下点。

接下来就是连边操作。首先建立超级源 $s$ 和超级汇 $t$，如果能够在 $s_i$ 时刻前从起点到达 $a_i$ 就连一条从 $s$ 到这个请求的边，容量 $1\sim \infty$ 之间都可以，费用是 $f[1][a_i]$

同理，如果能在 $T$ 时刻前回到起点就从这个请求连一条到 $t$ 的，容量在 $1\sim \infty$ 之间随便取，费用为 $f[b_i][1]$ 的边。

对于两个请求之间的转移，如果能在处理完 $u$ 请求后紧接着处理 $v$ 请求，连一条 $u\rightarrow v$，流量 $1\sim \infty$ 中随便取，费用为 $f[b_u][a_v]$ 的边。

对这个图直接跑一边最小费用最大流，把最小费用取个相反数就是答案。

为什么一定要最大流才是最优解呢？在条件允许的情况下，正常人都会多派几架飞机出去，哪怕不会让答案更优对不对。。。

```cpp
#include <cstdio>
#include <queue>
#include <cstring>
#include <cstdlib>

inline int min(const int x, const int y) {return x < y ? x : y;}
const int INF = 1e9;
struct Node {int x, y;};
struct Edge {
	int to, nxt, cap, cost;
} e[100005];
int head[505], dis[505], cur[505], f[205][205], tme[205][205], tot = 1, s, t;
int a[205], b[205], S[205], T[205], c[205];
bool mark[505], vis[505];
std::queue<int> Q;
inline void AddEdge(const int u, const int v, const int cap, const int cost) {
	e[++ tot].to = v, e[tot].nxt = head[u], head[u] = tot;
	e[tot].cap = cap, e[tot].cost = cost;
	e[++ tot].to = u, e[tot].nxt = head[v], head[v] = tot;
	e[tot].cap = 0, e[tot].cost = -cost;
}

bool SPFA() {
	memset(vis, 0, sizeof vis);
	memset(dis, 0x3f, sizeof dis);
	memset(mark, 0, sizeof mark);
	memcpy(cur, head, sizeof cur);
	dis[s] = 0;
	Q.push(s);
	while (Q.size()) {
		int u(Q.front());
		Q.pop();
		mark[u] = false;
		for (int i(head[u]); i; i = e[i].nxt) {
			int v(e[i].to);
			if (e[i].cap && dis[u] + e[i].cost < dis[v]) {
				dis[v] = dis[u] + e[i].cost;
				if (!mark[v]) Q.push(v), mark[v] = true;
			}
		}
	}
	return dis[t] < INF;
}

int dfs(const int u, const int flow) {
	if (u == t) return flow;
	vis[u] = true;
	int tmp(0), used(0);
	for (int i(cur[u]); i; i = e[i].nxt) {
		cur[u] = i;
		if (e[i].cap && dis[u] + e[i].cost == dis[e[i].to] && !vis[e[i].to]) {
			int v(e[i].to);
			if (tmp = dfs(v, min(flow - used, e[i].cap))) {
				e[i].cap -= tmp, e[i ^ 1].cap += tmp, used += tmp;
				if (used == flow) return used;
			}
		}
	}
	if (!used) dis[u] = 0;
	return used;
}

int Dinic() {
	int Mincost(0);
	while (SPFA()) Mincost += dis[t] * dfs(s, INF);
	return Mincost;
}

int main() {
	int n, m, k, ed;
	scanf("%d%d%d%d", &n, &m, &k, &ed);
	for (int i(1); i <= n; ++ i)
	for (int j(1); j <= n; ++ j) scanf("%d", &tme[i][j]);
	for (int i(1); i <= n; ++ i)
	for (int j(1); j <= n; ++ j) scanf("%d", &f[i][j]);
	for (int i(1); i <= m; ++ i)
		scanf("%d%d%d%d%d", a + i, b + i, S + i, T + i, c + i), ++ a[i], ++ b[i];
	s = 0, t = 2 * m + 2;
	for (int i(1); i <= m; ++ i) {
		AddEdge(i + 1, i + m + 1, 1, -c[i]);
		if (tme[1][a[i]] <= S[i]) AddEdge(1, i + 1, 1, f[1][a[i]]);
		if (T[i] + tme[b[i]][1] <= ed) AddEdge(i + 1 + m, t, 1, f[b[i]][1]);
		for (int j(1); j <= m; ++ j)
			if (i != j && T[i] + tme[b[i]][a[j]] <= S[j])
				AddEdge(i + m + 1, j + 1, 1, f[b[i]][a[j]]);
	}
	AddEdge(0, 1, k, 0);
	printf("%d", -Dinic());
	return 0;
}
```

---

## 作者：RetrO (赞：2)

标准的费用流
建边要邻两个机场都要连费用为st[i].y的边，
在判断时间是否允许的情况下m^2建边，剩下的就是板子了
```cpp
#include<cstdio> 
#include<cstring>  
#include<algorithm> 
#include<iostream> 
#include<queue> 
using namespace std; 
#define inf 2<<16 
#define N 505 
int tot=2; 
int n,m,k,tim; 
struct edge{ 
    int next,to,cap,val; 
}G[N*N]; 
struct node{ 
    int q,w,e,r,y; 
} ST[N<<4]; 
int mcost; 
bool used[N]; 
int head[N],dist[N],prem[N],xb[N],flow[N]; 
void addedge(int a,int b,int c,int d) 
{ 
    G[tot].to=b; 
    G[tot].next=head[a]; 
    G[tot].val=d; 
    G[tot].cap=c; 
    head[a]=tot++; 
} 
bool spfa(int o,int t) 
{ 
    memset(used,0,sizeof(used)); 
    memset(xb,-1,sizeof(prem)); 
    memset(dist,0x3f,sizeof(dist)); 
    prem[o]=0,dist[o]=0,flow[o]=inf,used[o]=1; 
    queue<int> Q; 
    Q.push(o); 
    while(!Q.empty()) 
    { 
        int tmp=Q.front(); 
        used[tmp]=0; 
        Q.pop(); 
        for(int i=head[tmp];~i;i=G[i].next) 
        { 
            int tt=G[i].to; 
            if(dist[tt]>dist[tmp]+G[i].val&&G[i].cap) 
            { 
                dist[tt]=dist[tmp]+G[i].val; 
                prem[tt]=tmp; 
                xb[tt]=i; 
                flow[tt]=min(flow[tmp],G[i].cap); 
                if(!used[tt]) 
                used[tt]=1,Q.push(tt); 
            } 
        } 
    } 
     if(dist[t]>=0x3f3f3f3f) 
     return 0; 
     return 1;   
} 
void MCMF(int s,int t) 
{ 
    while(spfa(s,t)) 
    { 
        int k=t; 
        while(k!=s) 
        { 
            G[xb[k]].cap-=flow[t]; 
            G[xb[k]^1].cap+=flow[t]; 
            k=prem[k]; 
        } 
        mcost+=dist[t]*flow[t]; 
    }  
} 
int x; 
int t[N][N]; 
int c[N][N]; 
int main() 
{ 
    memset(head,-1,sizeof(head)); 
    scanf("%d %d %d %d",&n,&m,&k,&tim); 
   int S=0,T=m*2+2; 
       for(int i=0;i<n;i++) 
        for(int j=0;j<n;j++) 
     scanf("%d",&t[i][j]); 
      for(int i=0;i<n;i++) 
       for(int j=0;j<n;j++) 
       scanf("%d",&c[i][j]); 
     for(int i=1;i<=m;i++) 
  scanf("%d %d %d %d %d",&ST[i].q,&ST[i].w,&ST[i].e,&ST[i].r,&ST[i].y); 
        for(int i=1;i<=m;i++) 
        { 
            addedge(i*2,i*2+1,1,-ST[i].y); 
            addedge(i*2+1,i*2,0,ST[i].y);        
        for(int j=1;j<=m;j++) 
         if(ST[i].r+t[ST[i].w][ST[j].q]<=ST[j].e) 
    addedge(i*2+1,j*2,inf,c[ST[i].w][ST[j].q]),addedge(j*2,i*2+1,0,-c[ST[i].w][ST[j].q]); 
         if(t[0][ST[i].q]<=ST[i].e)  
             addedge(S+1,i*2,inf,c[0][ST[i].q]),addedge(i*2,S+1,0,-c[0][ST[i].q]); 
        if(ST[i].r+t[ST[i].w][0]<=tim)  
         addedge(i*2+1,T,inf,c[ST[i].w][0]),addedge(T,i*2+1,0,-c[ST[i].w][0]);  
             } 
         addedge(S,S+1,k,0); 
        addedge(S+1,S,0,0); 
       MCMF(S,T); 
    printf("%d",-mcost);              
}
```

---

## 作者：xuyuansu (赞：1)

## 简要题意
有 $ n $ 个机场，$ m $ 个订单，$ k $ 架飞机，每个订单要求在 $ s_i $ 时从 $ a_i $ 机场出发，$ t_i $ 时到达 $ b_i $ 机场，可以得到 $ c_i $ 的报酬，要求飞机在 $ 0 $ 时可以从基地 $ 0 $ 号机场出发，在 $ T $ 时回到 $ 0 $ 号机场，求最大收益。
## 解法
对于这个图如果只有一架飞机，可以想到分层图，但是如果简单地用分层图跑网络流，复杂度会吃不消（虽然跑不满，但是复杂度还是在那里的）。

我们可以发现，无论怎么样，有用的时间点是远少于总时间的，而且题目保证了两点之间之间走是最快的，所以把每个订单的开始和结束时间拿出来，用类似离散化的操作，在订单的时间节点中建点，一个任务起点和终点间建连容量 $ 1 $ ,费用 $ c_i $ 的边，起点和终点向源汇点和可到达的任务点连容量无限，无费用的边，跑最大费用最大流。

注意：只要时间允许，订单一定要接，哪怕亏本；如果执行订单是比空载飞得快也是允许的，期间的飞行费用不计，是纯利润。
``` c
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+5,M=1e6+5;
int n,m,k,T,tt[205][205],f[205][205];
int ver[M],ne[M],val[M],head[N],tot=1,dis[N],cost[M],incf[N],pre[N];
int s=0,t,ans;bool vis[N];
struct node
{
	int a,b,s,t,c;
}q[205];
void add(int x,int y,int z,int c)
{
	ver[++tot]=y;ne[tot]=head[x];head[x]=tot;val[tot]=z;cost[tot]=c;
	ver[++tot]=x;ne[tot]=head[y];head[y]=tot;val[tot]=0;cost[tot]=-c;
}
bool spfa()
{
	memset(dis,-0x3f,sizeof(dis));
	memset(vis,0,sizeof(vis));
	memset(incf,0,sizeof(incf));
	queue<int> q;q.push(t+1);dis[t+1]=0;incf[t+1]=0x3f3f3f3f;
	while(q.size())
	{
		int x=q.front();q.pop();vis[x]=0;
		for(int i=head[x];i;i=ne[i])
		{
			int y=ver[i];
			if(!val[i]) continue;
			if(dis[y]<dis[x]+cost[i])
			{
				dis[y]=dis[x]+cost[i];
				incf[y]=min(incf[x],val[i]);
				pre[y]=i;
				if(!vis[y]) vis[y]=1,q.push(y);
			}
		}
	}
	if(incf[t]) return 1;
	return 0;
}
void update()
{
	int x=t;
	while(x!=t+1)
	{
		int i=pre[x];
		val[i]-=incf[t];val[i^1]+=incf[t];
		x=ver[i^1];
	}
	ans+=dis[t]*incf[t];
}
int main()
{
	scanf("%d%d%d%d",&n,&m,&k,&T);
	for(int i=0;i<n;i++)
		for(int j=0;j<n;j++) scanf("%d",&tt[i][j]);
	for(int i=0;i<n;i++)
		for(int j=0;j<n;j++) scanf("%d",&f[i][j]);
	s=0;t=2*m+1;
	for(int i=1;i<=m;i++)
	{
		scanf("%d%d%d%d%d",&q[i].a,&q[i].b,&q[i].s,&q[i].t,&q[i].c);
		if(q[i].t+tt[q[i].b][0]<=T) add(i+m,t,1e9,-f[q[i].b][0]);
		else continue;
		if(tt[0][q[i].a]<=q[i].s) add(s,i,1e9,-f[0][q[i].a]);
	}
	for(int i=1;i<=m;i++)
	{
		add(i,i+m,1,q[i].c);
		for(int j=1;j<=m;j++)
		{
			if(i==j) continue;
			if(q[i].t+tt[q[i].b][q[j].a]<=q[j].s)
			{
				add(i+m,j,1e9,-f[q[i].b][q[j].a]);
				add(i,j,1e9,-f[q[i].b][q[j].a]);
			}
		}
	}
	add(t+1,s,k,0);
	while(spfa()) update();
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：miaokehao (赞：1)

裸的拆点与费用流

但我怀疑这道题恶意评分，怎么说也应该是提高+/省选-吧？
代码放送时刻：
```
#include <bits/stdc++.h>
#define res register int
#define N 1005 
#define inf 0x3f3f3f3f
using namespace std;
struct papa{
	int w,c,next,to;
}e[N*N*2]; 
bool vis[N];
int n,m,k,tim,tot=1,t[N][N],f[N][N],dis[N],d[N],a[N],b[N],st[N],ed[N],earn[N],per[N],maxflow,ans,flow[N];
queue<int> q;
inline int read()
{
    int X=0,w=0; char ch=0;
    while(!isdigit(ch)) {w|=ch=='-';ch=getchar();}
    while(isdigit(ch)) X=(X<<3)+(X<<1)+(ch^48),ch=getchar();
    return w?-X:X;
}
inline void add(int x,int y,int we,int cost){
	e[++tot].next=d[x];
	d[x]=tot;
	e[tot].to=y;
	e[tot].c=cost;
	e[tot].w=we;
}
inline bool spfa(int s,int t){
	while(!q.empty()) q.pop();
	memset(dis,inf,sizeof(dis));
	memset(vis,0,sizeof(vis));
	q.push(s);
	dis[s]=0;
	vis[s]=1;
	flow[s]=inf;
	while(!q.empty()){
		int now=q.front();
		vis[now]=0;
		q.pop();
		for(res i=d[now];i;i=e[i].next)
		  if(e[i].w&&dis[e[i].to]>dis[now]+e[i].c){
		  	dis[e[i].to]=dis[now]+e[i].c;
		  	flow[e[i].to]=min(flow[now],e[i].w);
		  	per[e[i].to]=i;
		  	if(!vis[e[i].to]){
		  		vis[e[i].to]=1;
		  		q.push(e[i].to);
			  }
		  }
	}
	return dis[t]!=inf;
}
inline void updata(int s,int t){
	int x=t;
	while(x!=s){
		int i=per[x];
		e[i].w-=flow[t];
		e[i^1].w+=flow[t];
		x=e[i^1].to;
	}
	maxflow+=flow[t];
	ans+=dis[t]*flow[t];
}
inline void EK(int s,int t){
	while(spfa(s,t))
	  updata(s,t);
}
int main(){
	n=read(),m=read(),k=read(),tim=read();
	for(res i=0;i<n;i++)
	  for(res j=0;j<n;j++)
	    t[i][j]=read();
	for(res i=0;i<n;i++)
	  for(res j=0;j<n;j++)
	    f[i][j]=read();
	for(res i=1;i<=m;i++){a[i]=read(),b[i]=read(),st[i]=read(),ed[i]=read(),earn[i]=read();}
	for(res i=1;i<=m;i++){
		add(i<<1,(i<<1)+1,1,-earn[i]);
		add((i<<1)+1,i<<1,0,earn[i]);
		for(res j=1;j<=m;j++)
		  if(ed[i]+t[b[i]][a[j]]<=st[j])
		    add((i<<1)+1,j<<1,inf,f[b[i]][a[j]]),add(j<<1,(i<<1)+1,0,-f[b[i]][a[j]]);
		if(t[0][a[i]]<=st[i])
		  add(0+1,i<<1,inf,f[0][a[i]]),add(i<<1,0+1,0,-f[0][a[i]]);
	    if(t[b[i]][0]+ed[i]<=tim)
	      add((i<<1)+1,(n<<1)+2,inf,f[b[i]][0]),add((n<<1)+2,(i<<1)+1,0,-f[b[i]][0]);
	}
	add(0,1,k,0);
	add(1,0,0,0);
	EK(0,(n<<1)+2);
	printf("%d",-ans);
}
```

---


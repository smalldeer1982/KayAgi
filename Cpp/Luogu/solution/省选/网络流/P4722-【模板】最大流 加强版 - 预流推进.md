# 【模板】最大流 加强版 / 预流推进

## 题目描述

给定 $n$ 个点，$m$ 条有向边，给定每条边的容量，求从点 $s$ 到点 $t$ 的最大流。

## 说明/提示

$1\leqslant n \leqslant 1200, 1\leqslant m \leqslant 120000, 1\leqslant c \leqslant 2^{31}-1$。

保证答案不超过 $2^{31}-1$。

常用网络流算法的复杂度为 $O(n^2 m)$，请尽量优化算法。

数据提供者：@negiizhao

（如果有人用 dinic 算法过掉了此题，请私信上传者）

## 样例 #1

### 输入

```
7 14 1 7
1 2 5
1 3 6
1 4 5
2 3 2
2 5 3
3 2 2
3 4 3
3 5 3
3 6 7
4 6 5
5 6 1
6 5 1
5 7 8
6 7 7
```

### 输出

```
14```

## 样例 #2

### 输入

```
10 16 1 2
1 3 2
1 4 2
5 2 2
6 2 2
3 5 1
3 6 1
4 5 1
4 6 1
1 7 2147483647
9 2 2147483647
7 8 2147483647
10 9 2147483647
8 5 2
8 6 2
3 10 2
4 10 2
```

### 输出

```
8```

# 题解

## 作者：EnofTaiPeople (赞：50)

## Part1-Improved Dinic

ID（Improved Dinic) 算法是一种求最大流的高效算法，在随机图上复杂度为 $O(km)$，其中 $k$ 是一个较小的常数，一般在 $10$ 左右。缺点也很明显，加边离线，复杂度上限未知（可以理解为上限是 $O(kn^2m)$，但卡到 $O(nm)$ 都不容易做到）。

ID 算法原理就是，对 Dinic 算法进行很多优化，最后不仅代码较短，效率也很高，值得一提的是，即使是小规模数据，他也能跑得比一般算法快。

具体优化如下：

1. 当前弧（允许弧）优化；
2. 分段加边优化；
3. 先正后反（贪心初始流）优化；
4. gap 优化。

当前弧（允许弧）优化大家都懂，分段加边优化是为了防止边权差异过大，因为 Dinic 算法只有在边权差异大时会跑得较慢。

贪心初始流是采用了二分图增广路算法的贪心初始匹配思想，先不连反边是为了不然反边影响初始效率，gap 优化可以参照 ISAP，[AC 记录](https://uoj.ac/submission/590295)。

## Part2-LCT-Dinic
这是一个最坏复杂度为 $O(nm\log n)$ 的最大流算法。

把 ID 卡慢很简单，$k$ 可以被卡到 $\frac n3$ 左右，虽然通过此题的数据范围绰绰有余。

我们需要对 Dinic 的增广过程进行研究，考虑其之所以单次增广最坏为 $O(nm)$ 是因为每一条增广路最多有 $n$ 个点，由于可能每一条路有且仅有一条边满流，所以最多会增广 $m$ 次。

发现一条边在一条增广路上如果没有满流，就还会继续扫到，这样对效率的影响极大，于是可以用数据结构来维护连边，断（零）边，链减（得到的流量），使用可爱的 LCT 十分合适，于是就这样愉快地决定啦！

由于单次增广每一条边最多只会加入一次，减少一次，每一次加入减少的复杂度都是平摊 $O(\log n)$ 的，于是总复杂度为 $O(nm\log n)$。

加上 ID 的优化三（贪心初始流）就可以通过 luogu 数据了，并且速度比 ID 快一倍。

但是，在 UOJ 上会 [TLE](https://uoj.ac/submission/585700)。

## Part3-总结
其实 HLPP 的优势局限于本题的数据范围，再稠密点常数没有 MPM 小，再稀疏点就不如 LCT-Dinic。

以上 ID 的代码能通过 Luogu、LOJ、UOJ 的数据，但 LCT-Dinic 即使分段连边也通不过 UOJ 的第三十个测试点，而该点 ID 却能在 $1ms$ 内通过，所以特殊构图能卡 LCT-Dinic，毕竟 LCT 常数大，且每次都有 $\log$，并且分段连边时答案变得飞快，根本没有一条一条 $\log$ 增广的时间。

事实上，我还没见过有人在建模题上卡 Dinic，这就当整活图一乐了。

---

## 作者：皎月半洒花 (赞：21)

其实类似的思路已经有大佬提过了，我在此再赘述一翻的原因是我主要想讲一些算法的理解向问题。

朴素的$HLPP$是基于$Gap + Heap$的，是一个复杂度较为优秀、但是有不够优秀的算法，详情可以见[$Link$](http://www.orchidany.cf/2019/01/11/HLPP)。

我们直接上优化

我们首先思考思考普通的HLPP到底会慢在哪里：

* $STL$支持的$heap$（比如优先队列）实在是太太太…太慢了！

* 每次$Gap$优化，我们的时间复杂度是**紧确**的$\Theta(n)$。的这显然不合算，因为假设我当前的$\bold{gap}$（断层）正好位于倒数第一高的点和倒数第二高的点，那么也就相当于我单次会**浪费$\bold{\Theta(n)}$的时间**。

事实上…普通的$HLPP$代码并不长，主要问题就是这两个。

我们考虑，如果不用堆的话怎么做呢？

呃…不用堆的意思并不是我们不从高度最大的点开始推送。这个地方需要一个$idea$——在$HLPP$中，**高度函数$\bold{H(x)}$和点数集大小$\bold{N(x)}$是广义同阶的。** 换句话说，我们可以考虑从高度入手。

换句话说，我们原来是通过节点编号访问节点以及其高度，现在我们如果从高度入手，再去访问节点，我们就可以做到$\bold{O(n)}$而不是$\bold{\rm{O(nlogn)}}$ 。 那么由于同一高度的节点或许有很多，直接开一个$vector$。在这个地方我们用$vector$而不用二维数组建立二维关系的原因，主要是我们初始化麻烦得很，如果套用$memset$或者$fill$的话，常数之大可想而知。

那么这两个问题就顺理成章地解决了。但这个地方还有一个优化，就是虽然$vector$和$list$都是线性容器，但是$list$的本质是双向链表，频繁处理插入删除操作时会具有更优秀的表现。

也就是说，原来的$Gap$数组我们可以直接用$list$做，以图更小的常数。那么这时存在一个问题，就是虽然本质上删除是容易的，但是你怎么知道要删同一高度下的哪个元素(=@__@=)？就算你知道，$list$也不知道啊2333

hhh不皮了，其实我们记录一下位置就好，即记录一下每个节点在$list$中的位置，单独开一个$Iterator$类型的$vector$记录即可。

好了，现在我们获得了$10$倍$+$的常数优势qwq，撒花花…

哦对，还有几点我debug的时候被坑死的点：

* 那个$Iterator$类型的$vector$对象是点的编号不是高度！
* 注意你的下标！下标！再说一遍，下标！因为STL自带左闭右开的性质~~wrnm~~，所以一定要注意，如果你是$[1,n]$选手，注意你的$assign$函数！

###  $\color{red}{C}\color{cyan}{o}\color{gold}{d}\color{green}{e}·2$  (我觉得写的很难看但是有注释qaq)：

```cpp
//writter:Orchidany(pks)
#include <bits/stdc++.h>
#pragma GCC target("avx")
#pragma GCC optimize(3)
#pragma GCC optimize("Ofast")//sb毒瘤优化

#define MAXN 10030
#define min my_min
#define BG begin()
#define gc getchar
#define rr register 
#define Iter iterator
#define INF 2147483647
#define rep(i, a, x) for(i = a ; i <= x ; ++ i)

using namespace std ;
typedef list<int> List ; int step;

struct Edge{
    int to, f, next ;
    Edge(int to,int f,int next):to(to),f(f),next(next){}//没有人发现正下方这句注释前半句和后半句都是三个音节的吗qaq
} ; vector <int> q, H, Extra, Set[MAXN], cnt ; List Gap[MAXN] ;//list，就是快（
//q:队列，H:高度，Extra：每个点的超额流，Set:…就是那个经典版HLPP里的堆，高度做第一维
int Ans, N, M, S, T, max_H, now_H ; vector <Edge> E[MAXN] ; /*vector存边（据说会快）*/vector<List::iterator> Era_pos ; //辅助定位+删除

inline void eggs() { ;}//for free~
inline int my_min(int a, int b){return a & ((a - b) >> 31) | b & ( ~ (a - b) >> 31) ;}//黑科技
inline void Add(int f, int v, int u){ E[u].push_back(Edge(v, f, E[v].size())), E[v].push_back(Edge(u, 0, E[u].size() - 1)) ; }
inline int qr(){ rr int k = 0 ; char c = gc() ; while (!isdigit(c)) c = gc() ;while (isdigit(c)) k = (k << 1) + (k << 3) + c - 48, c = gc() ; return k ; }

inline void Init_label(){//等价于一开始的那个BFS，只执行一次
    rr int i, h = 0, t = 0 ;q.clear(), q.resize(N) ; 
    H.assign(N + 1, N + 1) ; H[T] = 0 ; q[t ++] = T ;//从T（高度小的）向前标号
    while (h < t){//队列……BFS……真熟悉啊……嗝……
        rr int now = q[h] ; ++ h ;
        for (vector <Edge> :: Iter k = E[now].begin() ; k != E[now].end() ; ++ k)
            if (H[k->to] == N + 1 && E[k->to][k->next].f) H[k->to] = H[now] + 1, ++ cnt[H[k->to]], q[t ++] = k->to ;
    }
    rep(i, 0, N + 1) Set[i].clear(), Gap[i].clear() ;//还是清空一下比较好吧
    rep(i, 0, N) 
        if (H[i]  <N + 1)  
            Era_pos[i] = Gap[H[i]].insert(Gap[H[i]].BG, i), //疑似insert函数的返回值是一个指针qaq
            (Extra[i]>0) ? Set[H[i]].push_back(i) : eggs() ;//这个彩蛋（eggs）是因为，三目运算符":"两边类型需要形同…
    max_H = now_H = H[q[-- t]] ; //更新，BFS的性质，最后一个元素一定高度最大（除了源点）
}
inline void Push(int x, Edge &e){//单独写出来的push函数，好像很方便？
    rr int now_flow = min(Extra[x], e.f) ;
    Extra[x] -= now_flow, e.f -= now_flow, Extra[e.to] += now_flow, E[e.to][e.next].f += now_flow ;
    if (Extra[e.to] > 0 && Extra[e.to] <= now_flow) Set[H[e.to]].push_back(e.to) ;  // push it into "heap"
}
inline void _Push(int x){
    rr int i, x_h = N, t = H[x] ; 
    for (vector <Edge> :: Iter k = E[x].BG ; k != E[x].end() ; ++ k)
        if (k->f > 0)//如果可以流
            if (H[k->to] == H[x] - 1) { Push(x, *k) ; if (!Extra[x]) return ;} else x_h = min(x_h, H[k->to] + 1) ;
    if (cnt[H[x]] <= 1){//如果出现断层了
        for(i = t ; i <= max_H ; Gap[i].clear(), ++ i)//这个gap的for肯定比O(n)优秀
            for(List::Iter k = Gap[i].BG ; k != Gap[i].end() ; ++ k) cnt[H[*k]] --, H[*k] = N ; 
        max_H = t - 1 ; /*断层以上的高度都没用了*/return ;
    }
    -- cnt[t], Era_pos[x] = Gap[t].erase(Era_pos[x]) ; H[x] = x_h ; if (x_h == N) return ; //重贴标签操作，为当前点删除原来的高度
    ++ cnt[x_h], Era_pos[x] = Gap[x_h].insert(Gap[x_h].begin(), x), max_H = max(now_H = x_h, max_H), Set[x_h].push_back(x) ;//增添新的高度
}
inline int HLPP(){
    rr int i, now ; H.assign(N, 0) ; H[S] = N ; Era_pos.resize(N)  ;
    rep(i, 0, N - 1) if (i != S) Era_pos[i] = Gap[H[i]].insert(Gap[H[i]].BG, i) ; 
    cnt.assign(N, 0), cnt[0] = N - 1 ; Extra.assign(N, 0), Extra[S] = INF, Extra[T] =- INF ;
    rep(i, 0, E[S].size() - 1) Push(S, E[S][i]) ;  //下面源点要单独拿出来推送，因为源点推送时高度差不需要=1.
    Init_label() ; //初始化（BFS）
    while (now_H >= 0) //正式开始HLPP（泪目）
        if (Set[now_H].empty()) now_H -- ; //高度递减，实现一个堆的效果
        else now = Set[now_H].back(), Set[now_H].pop_back(), _Push(now) ;
    return Extra[T] + INF ;
}
int main(){
    N = qr(),; rr int i ;//下面的++N是为了日后好操作qaq
    rep(i, 1, M) Add(qr(), qr(), qr()) ; ++ N, Ans = HLPP() ; cout << Ans << endl ; return 0 ; 
}
```

下面是个$fread$卡常版本$qaq$

```cpp
#include <bits/stdc++.h>
#pragma GCC target("avx")
#pragma GCC optimize(3)
#pragma GCC optimize("Ofast")

#define MAXN 1202
#define min my_min
#define BG begin()
#define rr register
#define swap my_swap 
#define Iter iterator
#define INF 2147483647
#define rep(i, a, x) for(i = a ; i <= x ; ++ i)

using namespace std ;
typedef list<int> List ; int step;
const int ch_top=4e7+3;
char ch[ch_top],*now_r=ch-1,*now_w=ch-1;

inline int read(){
    while(*++now_r<'0');
    register int x=*now_r-'0';
    while(*++now_r>='0')x=x*10+*now_r-'0';
    return x;
}
inline void write(int x){
    static char st[20];static int top;
    while(st[++top]='0'+x%10,x/=10);
    while(*++now_w=st[top],--top);
    *++now_w='\n';
}

struct Edge{
    int to, f, next ;
    Edge(int to,int f,int next):to(to),f(f),next(next){}
} ; vector <int> q, H, Extra, Set[MAXN], cnt ; List Gap[MAXN] ;
int Ans, N, M, S, T, max_H, now_H ; vector <Edge> E[MAXN] ; vector<List::iterator> Era_pos ; 

inline void eggs() { ;}//for free~
inline int my_min(int a, int b){return a & ((a - b) >> 31) | b & ( ~ (a - b) >> 31) ;}
inline void Add(int f, int v, int u){ E[u].push_back(Edge(v, f, E[v].size())), E[v].push_back(Edge(u, 0, E[u].size() - 1)) ; }

inline void Init_label(){
    rr int i, h = 0, t = 0 ;q.clear(), q.resize(N) ; 
    rr int qaq = N + 1 ; H.assign(qaq, qaq) ; H[T] = 0 ; q[t ++] = T ;
    while (h < t){
        rr int now = q[h], qwq = H[now] + 1 ; ++ h ; 
        for (vector <Edge> :: Iter k = E[now].begin() ; k != E[now].end() ; ++ k)
            if (H[k->to] == qaq && E[k->to][k->next].f) H[k->to] = qwq, ++ cnt[H[k->to]], q[t ++] = k->to ;
    }
    rep(i, 0, N - 1) Set[i].clear(), Gap[i].clear() ;
    rep(i, 0, N - 1) if (H[i] < N)  Era_pos[i] = Gap[H[i]].insert(Gap[H[i]].BG, i), (Extra[i] > 0) ? Set[H[i]].push_back(i) : eggs() ;
    max_H = now_H = H[q[-- t]] ; 
}
inline void Push(int x, Edge &e){
    rr int now_flow = min(Extra[x], e.f) ;
    Extra[x] -= now_flow, e.f -= now_flow, Extra[e.to] += now_flow, E[e.to][e.next].f += now_flow ;
    if (Extra[e.to] > 0 && Extra[e.to] <= now_flow) Set[H[e.to]].push_back(e.to) ;  // push it into heap
}
inline void _Push(int x){
    rr int i, x_h = N, t = H[x] ; 
    for (vector <Edge> :: Iter k = E[x].BG ; k != E[x].end() ; ++ k)
        if (k->f > 0)
            if (H[k->to] == H[x] - 1) { Push(x, *k) ; if (!Extra[x]) return ;} else x_h = min(x_h, H[k->to] + 1) ;
    if (cnt[H[x]] <= 1){
        for(i = t ; i <= max_H ; Gap[i].clear(), ++ i)
            for(List::Iter k = Gap[i].BG ; k != Gap[i].end() ; ++ k) cnt[H[*k]] --, H[*k] = N ; max_H = t - 1 ; return ;
    }
    -- cnt[t], Era_pos[x] = Gap[t].erase(Era_pos[x]) ; H[x] = x_h ; if (x_h == N) return ; 
    ++ cnt[x_h], Era_pos[x] = Gap[x_h].insert(Gap[x_h].begin(), x), max_H = max(now_H = x_h, max_H), Set[x_h].push_back(x) ;
}
int HLPP(){
    rr int i, now ; H.assign(N, 0) ; H[S] = N ; cnt.assign(N, 0) ; Era_pos.resize(N) ;
    rep(i, 0, N - 1) if (i != S) Era_pos[i] = Gap[H[i]].insert(Gap[H[i]].BG, i) ; cnt[0] = N - 1 ;
    Extra.assign(N, 0), Extra[S] = INF, Extra[T] = -INF ; rep(i, 0, E[S].size() - 1) Push(S, E[S][i]) ;  Init_label() ; 
    while (now_H >= 0) if (Set[now_H].empty()) now_H -- ; else now = Set[now_H].back(), Set[now_H].pop_back(), _Push(now) ;return Extra[T] + INF ;
}
int main(){
    fread(ch,1,ch_top,stdin); N = read(), M = read(), S = read(), T = read() ; rr int i ;
    rep(i, 1, M) Add(read(), read(), read()) ; ++ N, Ans = HLPP() ; write(Ans) ; fwrite(ch,1,now_w-ch,stdout) ;
}

```


## $\bold{\mathfrak{writter:Orchidany(pks)}}$



---

## 作者：phigy (赞：18)

2023.7.14 upd : 修改错别字。

本题目前理论复杂度最快方法。

# 超额缩放预流推进 EXCESS SCALING

## [全文](https://www.luogu.com.cn/blog/pig/Max-Flow)

[[3]A FAST AND SIMPLE ALGORITHM FOR   THE MAXIMUM FLOW PROBLEM 1988](https://www.cs.princeton.edu/courses/archive/fall07/cos521/handouts/0.pdf)

### 方法

 Ahuja and Orlin 在 1988 年提出使用名为 Excess Scaling 的技巧把通用预流推进非饱和推流的次数从 $O(n^2m)$ 降至 $O(n^2\log U)$。
 
类似 Binary Blcking Flow 算法对值域的缩放，我们进行 $K=\lceil \log U\rceil +1$ 轮  Scaling，在每一轮中，我们定义 $\Delta$ 为比所有超额流都大的最小 $2$ 的幂，每一轮 Scaling 结束时 $\Delta$ 减半。
 
 在一次 Scaling 中，我们只考虑超额流大于 $\Delta/2$ 的节点进行推流，并选择其中标号最小的节点，确保推到一个拥有较小超额流的节点去。
 
在 $8n^2$ 次非饱和推流之后，不再有超额流大于  $\Delta/2$，一次 Scaling 结束。

在最多 $K$ 次 Scaling 操作后，所有的节点超额流都会降至 $0$，至此我们可以得到最大流。

具体的，我们使用链表对每个标号的超额流足够大的点进行存储，每次去有点的最小标号中任意点推**一次**流，并更新当前弧。

当一个点无法推流时重贴标签并重置当前弧。

本算法复杂度正确性基于无重边和自环，因此预处理合并重边，去掉自环。

### 伪代码

![](https://cdn.luogu.com.cn/upload/image_hosting/onp1s8un.png)

### 实现相关

该算法饱和推流一共 $O(nm)$ 次，非饱和推流一共 $O(n^2\log U)$ 次。

时间复杂度为 $O(nm+n^2\log U)$，并可以调整 $\Delta/ \beta$ 的 $\beta\ge 2$ 这个参数变为 $O(nm+\beta n^2\log_{\beta}U)$。

该算法按 OI 的简单化实现方式常数巨大无比，千万不要考场使用。

[[评测记录]](https://uoj.ac/submission/631812)

```cpp
#include <iostream>
#include <queue>
#include <cstring>
#include <cmath>
#include <cctype>
#include <cstdio>
#include <cstring>
#include <map>
#include <ctime>


#define int long long

using namespace std;

int res=0;

int K,level;
const int inf=(long long)1<<40;
int n,m,s,t;
struct edge
{
    int to,val,next;
}e[1200005];
int cnt=1,head[1200005],now[1200005];
void add(int x,int y,int z)
{
    cnt++;
    e[cnt].to=y;
    e[cnt].val=z;
    e[cnt].next=head[x];
    now[x]=head[x]=cnt;
}

int h[120005],w[120005],cnth[120005];
queue<int>list[120005];
queue<int>qq;
int book[120005];
void bfs()
{
    memset(h,0x3f,sizeof(h));
    h[t]=0;
    qq.push(t);
    while(!qq.empty())
    {
        int u=qq.front();
        qq.pop();
        for(int i=head[u];i;i=e[i].next)
        {
            int v=e[i].to;
            if(e[i^1].val&&h[u]+1<h[v])
            {
                h[v]=h[u]+1;
                if(book[v]==0)
                {
                    qq.push(v);
                    book[v]=1;
                }
            }
        }
    }
}


void push_relabel(int x,int Delta)
{
    int i;
    int found=0;
    for(i=now[x];i;i=e[i].next)
    {
        int v=e[i].to;
        if(h[x]==h[v]+1&&e[i].val)
        {
            found=1;
            break;
        }
        else
        {
            now[x]=e[i].next;
        }
    }
    if(found==1)
    {
        int v=e[i].to;
        int flow=min(e[i].val,w[x]);
        if(v!=t)flow=min(flow,Delta-w[v]);
        e[i].val-=flow;
        e[i^1].val+=flow;
        w[x]-=flow;
        w[v]+=flow;
        if(w[x]<=Delta/2)list[level].pop();
        if(w[v]>Delta/2&&v!=s&&v!=t)
        {
            list[h[v]].push(v);
            level--;
        }
    }
    else
    {
        res++;
        list[level].pop();
        cnth[level]--;
        if(cnth[level]==0)
        {
            for(int i=1;i<=n;i++)
            {
                if(h[i]>level&&i!=s&&i!=t&&h[i]<n+1)
                {
                    h[i]=n+1;
                }
            }
        }
        int minn=inf;
        for(int i=head[x];i;i=e[i].next)
        {
            int to=e[i].to;
            if(e[i].val)
            {
                minn=min(minn,h[to]);
            }
        }
        h[x]=minn+1;
        if(minn==inf)h[x]=n+1;
        if(h[x]<=1200000)cnth[h[x]]++;
        if(h[x]<=1200000)list[h[x]].push(x);
        now[x]=head[x];
    }
}

int Excess_Scaling()
{
    bfs();
    if(h[s]==0x3f3f3f)return 0;
    h[s]=n;
    for(int i=1;i<=n;i++)
    {
        if(h[i]<0x3f3f3f)
        {
            cnth[h[i]]++;
        }
    }
    for(int i=head[s];i;i=e[i].next)
    {
        int to=e[i].to,val=e[i].val;
        if(val)
        {
            e[i].val-=val;
            e[i^1].val+=val;
            w[s]-=val;
            w[to]+=val;
        }
    }
    for(int k=1;k<=K;k++)
    {
        int Delta=(long long)1<<(K-k);
        for(int i=1;i<=n;i++)
        {
            if(w[i]>Delta/2)
            {
                if(h[i]<=1200000)list[h[i]].push(i);
            }
        }
        level=1;
        while(level<=n)
        {
            if(list[level].empty())level++;
            else
            {
                int x=list[level].front();
                push_relabel(x,Delta);
            }
        }
        for(int i=1;i<=32;i++)
        {
            while(!list[i].empty())
            {
                list[i].pop();
            }
        }
    }
    return w[t];
}


signed main()
{
    int i,j,k;
    ios::sync_with_stdio(0);
    cin>>n>>m>>s>>t;
    for(i=1;i<=m;i++)
    {
        int x,y,z;
        cin>>x>>y>>z;
        if(x==y)continue;
        add(x,y,z);
        add(y,x,0);
    }
    K=31;
    cout<<Excess_Scaling();
    return 0;
}
```

---

## 作者：chenbs (赞：8)

# P4722 题解

**前言：本题解使用 Dinic 算法。** Dinic 算法的时间复杂度看似是 $O(n^2m)$ 没什么问题，但是只是最坏时间复杂度，事实上远远达不到上限。 

普通 Dinic 大家都熟悉，可以看[标准版](https://www.luogu.com.cn/problem/P3376)，所以我就来讲一下优化。

## 1. 分段加边

边权差小的时候，Dinic 跑得很快。如果边权都为 $1$，Dinic 甚至可以达到最慢 $O(n^{\frac23}m)$ 的复杂度，证明见 OI wiki。

所以考虑分段加边，先把边权大的塞进去，跑一边普通 Dinic，再把边权小的塞进去，重新跑一遍。

## 2. 重边自环的处理

重边合并到一起，这样遍历的时候也会稍微快一点。

自环直接忽略，因为自环只会循环浪费自己的流量，没什么用。

## 3. 其实不需要开 long long

题目说“保证答案不超过 $2^{31}-1$”，我们就可以认为：答案对 $2^{32}$ 取模。于是，只需要开 `int`，让它自然溢出，最终答案还是对的。

正式比赛时，不建议使用这种奇奇怪怪的优化，有风险。

## 4. 其他

使用前向星存边，避免了动态内存分配的常数，而且可以一对一对存（对于边 `e`，`e^1` 就是它的反向边）。bfs 时手写队列（虽然快不了多少）。

AC 代码如下，开 O2 后最慢的点跑了 1.21s，[记录](https://www.luogu.com.cn/record/177130778)：

```cpp
#include<bits/stdc++.h>
using namespace std;
int ans, n, m, s, t, now[1201], dis[1201], h[1201], idx, q[1201], qh, qt; // q 使用 (h,v] 部分
struct node {
	int nex, e, w;
} e[240001];
int mp[1201][1201];
inline void add(int u, int v, int w) {
	e[idx++]= {h[u], v, w}, h[u]=idx-1;
}
inline int bfs() {
	for(int i=1; i<=n; i++) dis[i]=1e9;
	q[0]=s, qh=-1, qt=0;
	dis[s]=0, now[s]=h[s];
	while(qh < qt) {
		int x=q[++qh];
		for(int i=h[x]; ~i; i=e[i].nex) {
			int v=e[i].e;
			if(e[i].w>0&&dis[v]==1e9) {
				q[++qt]=v, now[v]=h[v], dis[v]=dis[x]+1;
				if(v==t) return 1;
			}
		}
	}
	return 0;
}
inline int dfs(int x, int lim) {
	if(x==t) return lim;
	int flow, res=0;
	for(int i=now[x]; (~i) && lim>0; i=e[i].nex) {
		now[x]=i; // 当前弧优化
		int v=e[i].e;
		if(e[i].w>0 && (dis[v]==dis[x]+1)) {
			flow=dfs(v, min(lim, e[i].w));
			if(flow==0) dis[v]=1e9;
			e[i].w-=flow, e[i^1].w+=flow, res+=flow, lim-=flow;
		}
	}
	return res;
}
int main() {
	memset(h, -1, sizeof h);
	scanf("%d%d%d%d", &n, &m, &s, &t);
	for(int i=1, u, v, w; i<=m; i++) {
		scanf("%d%d%d", &u, &v, &w);
		mp[u][v] += w;
	}
	for(int b=28; b>=0; b-=4) {
		for(int u=1; u<=n; u++)
			for(int v=u+1; v<=n; v++)
				if((mp[u][v] > 0 || mp[v][u] > 0) && (mp[u][v] >= (1<<b) || mp[v][u] >= (1<<b)))
					add(u, v, mp[u][v]), add(v, u, mp[v][u]), mp[u][v]=0, mp[v][u]=0;
		while(bfs()) ans+=dfs(s, 1e9);
	}
	printf("%d", ans);
	return 0;
}
```

我认为在超小常数的 Dinic 面前，写高效的 HIPP 有点浪费。同时也希望出题人能够再接再厉加强数据。

---

## 作者：strcmp (赞：8)

当年还是蒟蒻的我（现在是奆蒻了）看到这道题的时候，反手一个 ISAP 就拍了上去，[结果](https://www.luogu.com.cn/record/69368987)

于是忍痛学了 HLPP......

## 先来看看朴素预流推进

在学习增广路算法的时候，我们都是在**残量网络中寻找一条或多条最短的增广路，然后沿着这些增广路增广**，当无法找到增广路的时候结束算法。如果使用增广路算法中效率较高的 Dinic 或 ISAP 算法，每次最坏找到一条增广路，最多找 $n$ 次，所以最坏时间复杂度是 $O(n^2m)$ 的，而且无论我们怎么改进算法，这个最坏时间复杂度上限都是无法避免的。对于本题 $n \le 1200,m \le 120000$ 的数据来看，$O(n^2m)$ 算法显然死得不能再死了。

于是这道题铁定不能用增广路算法了（如果使用 LCT 或伸缩操作优化当我没说）。

**想一想那个用下水管网络比喻网络流的例子？**

如果直接模拟“水”的流动会怎么样呢？

**我们先假设这样一个情景：**

源点有 $\infty$ 个单位的水，然后这些水从源点开始向外面蔓延，塞满了源点向外的所有通道，然后这些通道通向的节点也有了很多的水，这些水继续向外蔓延......一直到汇点，然后我们统计一下汇点有多少单位的水，最大流不就求出来了吗？

看起来很美好，可惜实践中会发生两个节点轮流相互推水，推到 TLE 的情况。

于是**我们对每个节点加上一个高度，每次都只向比该节点高度低的节点推水，刚开始源点的高度为 $n$，然后每次推流都维护这个高度。**

于是就能成功运行了！

可惜这样做时间复杂度还是不变的 $O(n^2m)$

难道就无法改进了吗？

先人的智慧又出现了，**每次从高度最高的节点推流，时间复杂度会成为 $O(n^2\sqrt m)$**

可还是 TLE 怎么办?

那就继续优化啊！

类似于 ISAP，我们可以从在**刚开始的时候从汇点开始 BFS，对途经节点全部重标号**，速度会快很多。

可是依然 TLE......

于是重头戏来了！

### gap优化

类似于 ISAP 的 gap 优化，HLPP也有一个 gap 优化，当 0 至 $n$ 之间有深度不存在时，将此深度以上的结点的深度全部设为 $n+1$，好让这些结点的流推回到源点去。

果然快了许多。

可是，[难受T^T](https://www.luogu.com.cn/record/72929590)

### 懒惰 gap 优化

我们发现不一定要让深度大于 $n$ 的结点的流退回来，于是我们把这些结点标记为不可到达，然后每次推流和更改高度都不考虑这些结点。

[懒惰 gap 优化](https://www.luogu.com.cn/record/72930689)

终于把这道毒瘤题 A 了！

### 接下来是代码实现部分
**基础部分：**
```cpp
#define inf 1000000000000000
#define V 200010
#define E 1000010
typedef long long int ll;
struct edge {
public:
    int to, next;
    ll capa;
};
int cnt = 0, head[V]; int n, m; edge node[E];
bool vis[V];
inline void add(int fir, int nxt, ll w) {
    node[cnt].to = nxt;
    node[cnt].capa = w;
    node[cnt].next = head[fir];
    head[fir] = cnt; ++cnt;
}
int s, t, dep[V], gap[V], cur2[V]; std::queue<int>que; ll sum = 0; ll cur[V];
bool inque[V];
```
$cur$ 代表结点的流量，$cur2$ 用于当前弧优化。

**BFS 重标号：**
```cpp
inline bool bfs() {
    int fro, ito;
    que.push(t); dep[t] = 0; ++gap[dep[t]];
    while (!que.empty()) {
        fro = que.front(); que.pop();
        for (register int i = head[fro]; i != -1; i = node[i].next) {
            ito = node[i].to;
            if (dep[ito] == -1) {
                dep[ito] = dep[fro] + 1;
                que.push(ito);
                ++gap[dep[ito]];
            }
        }
    }
    return (dep[s] != -1);
}
```
**推流：**

向周围结点拼命灌水。
```cpp
inline void push(int v) {
    for (int i = cur2[v]; i != -1; i = node[i].next) {
        cur2[i] = i;
        if (!cur[v])return;
        if (dep[v] == dep[node[i].to] + 1 && node[i].capa) {
            ll ls = std::min(cur[v], node[i].capa);
            cur[v] -= ls, cur[node[i].to] += ls;
            node[i].capa -= ls, node[i ^ 1].capa += ls;
            if (!inque[node[i].to] && node[i].to != s && node[i].to != t && !vis[node[i].to]) {
                hlpp.push(node[i].to);
                inque[node[i].to] = true;
            }
        }
    }
}
```
**重标号：**

其实就是把当前结点的高度改为附近高度最低的结点的高度 + 1。
```cpp
inline void relable(int v) {
    dep[v] = n + 5;
    for (register int i = head[v]; i != -1; i = node[i].next) {
        if (node[i].capa && dep[v] > dep[node[i].to])
            dep[v] = dep[node[i].to];
    }
    ++dep[v];
}
```
**主程序：**

有个问题：怎么才能取出高度最高的结点？

用 ```std::priority_queue``` 维护即可。

```cpp
inline ll HLPP() {
    cur[s] = inf; initing(); if (!bfs()) return 0;
    int np; int v; ll w; ll ans = 0; dep[s] = n;
    for (int i = head[s]; i != -1; i = node[i].next) {
        v = node[i].to; w = node[i].capa;
        cur[s] -= w; cur[v] += w;
        node[i].capa -= w;
        node[i ^ 1].capa += w;
        if (v != s && v != t && !vis[v]) { hlpp.push(v); inque[v] = true; }
    }
    while (!hlpp.empty()) {
        memcpy(cur2, head, (n + 1) * sizeof(int));
        np = hlpp.top(); hlpp.pop();
        inque[np] = false;
        push(np);
        if (cur[np]) {
            if (--gap[dep[np]] == 0) {
                for (int i = 1; i <= n; i++)
                    if (i != s && i != t && dep[i] > dep[np] && dep[i] < n + 1)
                        dep[i]=n+1, vis[i] = true;
            }
            relable(np);
            ++gap[dep[np]];
            hlpp.push(np);
            inque[np] = true;
        }
    }
    return cur[t];
}
```
**AC 代码：**

```cpp
#include <bits/stdc++.h>
#define inf 1000000000000000
#define V 200010
#define E 1000010
typedef long long int ll;
struct edge {
public:
    int to, next;
    ll capa;
};
int cnt = 0, head[V]; int n, m; edge node[E];
bool vis[V];
inline void add(int fir, int nxt, ll w) {
    node[cnt].to = nxt;
    node[cnt].capa = w;
    node[cnt].next = head[fir];
    head[fir] = cnt; ++cnt;
}
int s, t, dep[V], gap[V], cur2[V]; std::queue<int>que; ll sum = 0; ll cur[V];
bool inque[V];
inline void initing() { memset(dep, -1, V * sizeof(int)); }
inline bool bfs() {
    int fro, ito;
    que.push(t); dep[t] = 0; ++gap[dep[t]];
    while (!que.empty()) {
        fro = que.front(); que.pop();
        for (register int i = head[fro]; i != -1; i = node[i].next) {
            ito = node[i].to;
            if (dep[ito] == -1) {
                dep[ito] = dep[fro] + 1;
                que.push(ito);
                ++gap[dep[ito]];
            }
        }
    }
    return (dep[s] != -1);
}
struct cmp {
public:
    inline bool operator()(int a, int b) { return dep[a] < dep[b]; }
};
std::priority_queue<int, std::vector<int>, cmp>hlpp;
inline void push(int v) {
    for (int i = cur2[v]; i != -1; i = node[i].next) {
        cur2[i] = i;
        if (!cur[v])return;
        if (dep[v] == dep[node[i].to] + 1 && node[i].capa) {
            ll ls = std::min(cur[v], node[i].capa);
            cur[v] -= ls, cur[node[i].to] += ls;
            node[i].capa -= ls, node[i ^ 1].capa += ls;
            if (!inque[node[i].to] && node[i].to != s && node[i].to != t && !vis[node[i].to]) {
                hlpp.push(node[i].to);
                inque[node[i].to] = true;
            }
        }
    }
}
inline void relable(int v) {
    dep[v] = n + 5;
    for (register int i = head[v]; i != -1; i = node[i].next) {
        if (node[i].capa && dep[v] > dep[node[i].to])
            dep[v] = dep[node[i].to];
    }
    ++dep[v];
}
inline ll HLPP() {
    cur[s] = inf; initing(); if (!bfs()) return 0;
    int np; int v; ll w; ll ans = 0; dep[s] = n;
    for (int i = head[s]; i != -1; i = node[i].next) {
        v = node[i].to; w = node[i].capa;
        cur[s] -= w; cur[v] += w;
        node[i].capa -= w;
        node[i ^ 1].capa += w;
        if (v != s && v != t && !vis[v]) { hlpp.push(v); inque[v] = true; }
    }
    while (!hlpp.empty()) {
        memcpy(cur2, head, (n + 1) * sizeof(int));
        np = hlpp.top(); hlpp.pop();
        inque[np] = false;
        push(np);
        if (cur[np]) {
            if (--gap[dep[np]] == 0) {
                for (int i = 1; i <= n; i++)
                    if (i != s && i != t && dep[i] > dep[np] && dep[i] < n + 1)
                        dep[i]=n+1, vis[i] = true;
            }
            relable(np);
            ++gap[dep[np]];
            hlpp.push(np);
            inque[np] = true;
        }
    }
    return cur[t];
}
int main() {
    std::ios::sync_with_stdio(0);
    std::cin.tie(); std::cout.tie();
    memset(head, -1, V * sizeof(int));
    std::cin >> n >> m >> s >> t;
    int f, l; ll w;
    for (register int i = 0; i < m; i++) {
        std::cin >> f >> l >> w;
        add(f, l, w);
        add(l, f, 0);
    }
    std::cout << HLPP();
    return 0;
}
```



---

## 作者：pldzy (赞：8)

本题解侧重解释 $\text{HLPP}$ 细节部分，而对于 $\text{HLPP}$ 的详细思路等不会过多阐述。

## UPDATE

**2022.10.06**：感谢@[MiniLong](https://www.luogu.com.cn/user/573341)大佬的提点与学术支持（[hack 数据](https://www.luogu.com.cn/paste/3z20vpny)），对 `hlpp()` 函数进行了更改。

**2024.01.10**：开 `long long`。

## $\text{HLPP}$ 思路

按照众多大佬所说的那样，$\text{HLPP}$ 就是将水流自源点一步一步地推到其他中转点，最后推向汇点，汇点累计的流量就是该网络的最大流。

注意，在此算法中，我们的目标是图中所有中转点最后存储的流量为 0。

在此过程中，为了防止 $\text{TLE}$，也就是避免两个点互相不停地将水流推来推去的情况，我们给每一个节点一个高度，像我们在 $\text{dinic}$ 算法中所做的那样，每次保证是从当前层推向下一层。同时，也要保证每次从高度最高的节点向低处节点推流，节省时间（这也是使用优先队列的原因）。

那为什么它会比其他解决最大流问题的算法快呢？

首先，在这里我们只用运行一次 $\text{bfs}$，在给每一个节点初始了一个高度之后，后面如果它这个点储存的流传不出去了，也只需要针对它单独更改其高度即可。

其次，因为它是一步一步将流向下推，所以不用多次 $\text{dfs}$ 去寻找增广路径。

## 代码实现细节解释

### $\text{bfs}$ 初始高度

相比先给每一个节点初始高度为 0，用 $\text{dinic}$ 中的手段给每个节点的高度初始为它距离终点的最短距离，明显会大大地减少后期更新其高度的次数。

具体代码如下：

```cpp
inline bool bfs()
{
	rep(i, 1, n) h[i] = inf;
	h[t] = 0, q.push(t);
	while(!q.empty())
	{
		int u = q.front();
		q.pop();
		for(int i = hd[u], v; i; i = e[i].nxt)
			if(e[i ^ 1].f and h[v = e[i].to] > h[u] + 1)
				h[v] = h[u] + 1, q.push(v);
	}
	return h[s] == inf ? 0 : 1;
}
```

1. 为什么是 `if(e[i ^ 1].f)` 而不是 `if(e[i].f)` 呢？

	要注意因为我们是从终点**反向**去给每个点初始高度的，所以这时候我们走的边都是反向边。而这里是判断该两点之间正向边的流量是否为 0。
    
1. 为什么是 `if(h[v] > h[u] + 1)` 而不是 `if(h[v] > h[u] - 1)` 呢？

	原因同上，因为我们在走反向边，此时 $v$ 更靠近 $s$，高度更高。
    
### $\text{HLPP}$ 函数

```cpp
inline int hlpp()
{
	if(!bfs()) return 0;
	h[s] = n;
	for(int i = hd[s], v, d; i; i = e[i].nxt)
	{
		if(d = e[i].f)
		{
			p[v = e[i].to] += d, p[s] -= d;
			e[i].f -= d, e[i ^ 1].f += d;
			if(v != s and v != t and !inq[v]) pq.push(v), inq[v] = 1;
		}
	}
	rep(i, 1, n) if(h[i] != inf) gap[h[i]] += 1;
	while(!pq.empty())
	{
		int u = pq.top();
		pq.pop(), inq[u] = 0, push(u);
		if(!p[u]) continue;
		if(h[u] != inf and !--gap[h[u]])
		{
			rep(i, 1, n) 
				if(i != s and i != t and h[i] > h[u] and h[i] < n + 1) 
					h[i] = n + 1;
		}
		updt(u), gap[h[u]] += 1, pq.push(u), inq[u] = 1;
	}
	return p[t];
}
```

注：$\text{push}$ 函数的作用是将当前点存储的流尽可能地推到下一层的节点。

1. `if(!bfs()) return 0;` 原因？

	回看 $\text{bfs}$ 函数代码，若最后 $s$ 没有高度，就意味着无法从 $t$ 走到 $s$，那么自然也就不存在最大流一说了。也因此要把 `h[s] = n;` 放在判断的后面了。
    
2. `h[s] = n;`

	因为 $s$ 是源点，对于它来说有无尽的流，目前暂时不存在有流要回到 $s$，只有自 $s$ 将流往下推到其他点，所以目前它的高度要是最高的。
    
3. 为什么在 $\text{HLPP}$ 中还需要 $gap[]$ 数组？

	这个数组用来统计每一层当前节点数量。此时它的作用是判断当此层为空时的情况。若此层为空，意味着那些在这层以上的节点无法将流送到终点，所以要将这些流送回源点。
    
    因为流是自高往低才能流，所以要将这些点的高度设在源点高度之上。
    
    相对应的就是后面的这段代码了：
    
    ```cpp
		if(!--gap[h[u]])
		{
			rep(i, 1, n) 
				if(i != s and i != t and h[i] > h[u] and h[i] < n + 1) 
					h[i] = n + 1;
		}
	```

4. `updt(u), gap[h[u]] += 1, pq.push(u), inq[u] = 1;`

	当节点 $u$ 存储的流在尽可能推给下一层节点之后还有流剩时，要向将流送完，只有更改节点高度，才可能将所有流推出去。所以就有了以上的操作。
    
5. 为什么是 `if(h[u] != inf and !--gap[h[u]])` 而不是 `if(!--gap[h[u]])`？
	
    因为 $h_u$ 有可能没被更新到，还是 $inf$。

### $\text{push}$ 函数

```cpp
inline void push(int nw)
{
	for(int i = hd[nw], v; i; i = e[i].nxt)
	{
		if(!p[nw]) return;
		if(h[v = e[i].to] + 1 != h[nw] or !e[i].f) continue;
		int d = min(p[nw], e[i].f);
		p[nw] -= d, p[v] += d, e[i].f -= d, e[i ^ 1].f += d;
		if(v != s and v != t and !inq[v]) 
			pq.push(v), inq[v] = 1;
	}
}
```
它的作用就是将当前节点的流尽可能地推向下一层的节点。

1. `if(v != s and v != t and !inq[v]) pq.push(v), inq[v] = 1;`

	注意优先队列里，存放的是存储了若干流的**中转点**，所以每次推流之后都要让推向的那个节点在有限队列里。
    
### $\text{updt}$ 函数

```cpp
inline void updt(int u)
{
	h[u] = inf;
	for(int i = hd[u], v; i; i = e[i].nxt)
	{
		if(e[i].f and h[v = e[i].to] + 1 < h[u])
			h[u] = h[v] + 1;
	}
}
```
它的作用是更改当前节点的高度。

1. 为什么要取最小的高度？

	我们之所以会更改它的高度，是因为它有剩余的一些流无法推出去了。所以将它的高度设为最低可能的高度，以**保证**它还能将剩余流推出去。
    
## AC Code

整体代码：

```cpp
#include<bits/stdc++.h>
using std::min;
using std::vector;
using std::queue;
using std::priority_queue;

#define int long long 
#define maxn 2005
#define maxm 200005
#define inf 2147483647
#define rep(i, a, b) for(register int i = a; i <= b; ++i)
int n, m, s, t;
int cnt = 1, hd[maxn];
struct node{
    int to, nxt, f;
}e[maxm << 1];
int p[maxn], h[maxn], gap[maxm];
bool inq[maxn];
queue <int> q;
struct cmp{
    inline bool operator () (int a, int b) const//重写仿函数 
    {
        return h[a] < h[b];
    }
};
priority_queue <int, vector<int>, cmp> pq;
int u, v, w;

inline int read()
{
    int x = 1, s = 0;
    char ch = getchar();
    while(ch < '0' or ch > '9') {if(ch == '-') x = -1; ch = getchar();}
    while(ch >= '0' and ch <= '9') s = s * 10 + ch - '0', ch = getchar();
    return x * s;
}

inline void add(int u, int v, int w)
{
    e[++cnt] = (node){v, hd[u], w};
    hd[u] = cnt;
    e[++cnt] = (node){u, hd[v], 0};
    hd[v] = cnt;
}

inline bool bfs()
{
    rep(i, 1, n) h[i] = inf;
    h[t] = 0, q.push(t);
    while(!q.empty())
    {
        int u = q.front();
        q.pop();
        for(int i = hd[u], v; i; i = e[i].nxt)
            if(e[i ^ 1].f and h[v = e[i].to] > h[u] + 1)
                h[v] = h[u] + 1, q.push(v);
    }
    return h[s] == inf ? 0 : 1;
}

inline void push(int nw)
{
    for(int i = hd[nw], v; i; i = e[i].nxt)
    {
        if(!p[nw]) return;
        if(h[v = e[i].to] + 1 != h[nw] or !e[i].f) continue;
        int d = min(p[nw], e[i].f);
        p[nw] -= d, p[v] += d, e[i].f -= d, e[i ^ 1].f += d;
        if(v != s and v != t and !inq[v]) 
            pq.push(v), inq[v] = 1;
    }
}

inline void updt(int u)
{
    h[u] = inf;
    for(int i = hd[u], v; i; i = e[i].nxt)
    {
        if(e[i].f and h[v = e[i].to] + 1 < h[u])
            h[u] = h[v] + 1;
    }
}

inline int hlpp()
{
    if(!bfs()) return 0;
    h[s] = n;
    for(int i = hd[s], v, d; i; i = e[i].nxt)
    {
        if(d = e[i].f)
        {
            p[v = e[i].to] += d, p[s] -= d;
            e[i].f -= d, e[i ^ 1].f += d;
            if(v != s and v != t and !inq[v]) pq.push(v), inq[v] = 1;
        }
    }
    rep(i, 1, n) if(h[i] != inf) gap[h[i]] += 1;
    while(!pq.empty())
    {
        int u = pq.top();
        pq.pop(), inq[u] = 0, push(u);
        if(!p[u]) continue;
        if(h[u] != inf and !--gap[h[u]])
        {
            rep(i, 1, n) 
                if(i != s and i != t and h[i] > h[u] and h[i] < n + 1) 
                    h[i] = n + 1;
        }
        updt(u), gap[h[u]] += 1, pq.push(u), inq[u] = 1;
    }
    return p[t];
}

signed main()
{
    n = read(), m = read(), s = read(), t = read();
    rep(i, 1, m)
        u = read(), v = read(), w = read(), add(u, v, w);
    printf("%lld\n", hlpp());
    return 0;
}
```


------------
感谢阅读。

辛苦管理员审核，若有问题烦请指出。

---

## 作者：CQ_JiJi (赞：7)

# 前言
2024.1.11 update ：解决被 hack 的问题；增加了更多的补充说明；算法模拟样例过程的图；修改错别字。
# HLPP 求网络最大流
先简单说说 HLPP 这个神仙般的算法，时间复杂度达到了惊人的 $O(n^2\sqrt m)$。

HLPP 预流推进算法，我们将网络理解成纵横交织的河道，源点是水库，汇点是运输目标，其余的节点就是转折区，有向边是河流。

那么它是如何实现的呢？我们**允许**网络在非汇点、源点的节点停留（也就是说这是一个一步一步实现的过程，并非像 Dinic 那样一口气从源点走到汇点，而是一种整体最优观念），那么对于每一个节点会拥有一个**超额流**（也称余流），我们用 $ef_i$ 表示，那么我们的每个节点都要想办法将自己的超额流（如果你不是汇点那你肯定不需要留着，推送出去一定不劣），推送出去，这样才能使得我们的网络能够进入汇点 $t$。所以 $t$ 最后剩下的超额流（我们会用高度 $highh_t$ 来迫使汇点成为最低的点从而无法推送超额流），**就是 $s$ 到 $t$ 的网络最大流**（所有能够推送的已经推送了，不可能能够再推送超额流到 $t$ 了）。

需要注意的是，为了推送不陷入死循环，我们引入每个节点的高度 $highh_i$。“水往低处流”，所以我们只允许从高处的节点将超额流推送给较低的点（高度的初始值由从 $t$ 开始 bfs，被遍历到的次序决定）。高度是会改变的，如果一个节点因为**高度低**了而无法推送超额流那么我们就考虑提高他的高度，这个过程我们称为 **重贴标签**。

既然引入了 $heighh$，那就可以说说预流推进的本质了，预留推进实际上是在不断的改变 $heighh$ 的值，让所有的流量从源点出发，最终汇到源点（有些可能到不了汇点，让它回到源点）或汇点，最终汇点流量最大。

记住一句话，走到死路不要紧，只要每次走的都是最优的路。

还有一点想要提一下，反向连接的边可以起到反悔的作用（让流量流回去）。

接下来，我将重点讲一讲预流推进的具体实现。

定义一个优先队列，以高度为优先，因为我们的推送过程是需要从高到低的（这样才能保证你在处理当前节点的时候不会还有别的节点可以给你推送超额流）。原本每个节点高度为 $0$,但是 $s$ 的高度为 $n$，这样能保证源点能够将自己的余流推送给所有与他相接的节点。然后将所有的节点的余流设为 $0$，但是 $s$ 的无穷大（不用担心多出来流量，走不到 $t$ 的节点我们可以通过将高度设为 $n+1$ 从而直接流回源点）。

考虑如何处理优先队列中的节点，我们开始处理优先队列中的队首 $x$，对他进行推送，那么如果推送结束后，当前节点还有超额流，那么我们就**重贴标签**，让当前节点的高度比他能到的所有节点的最低节点高 $1$（原因前文有提到），保证下次一定能够推送又不至于导致有节点未能被推送（因为有 $highh_x+1=highh_{to}$ 一限制条件）。然后再次加入优先队列，等待下一次推送（这一系列的操作都是建立在还有余流的基础下的），因为已在队列中的节点不要重复入队，所以要使用一个 $vis$ 标记数组。

然后说一下如何推送，遍历 $x$ 的所有出边，若发现 $highh_x+1=highh_{to}$，那么这条边就可以进行推送(因为原定的顺序是 $bfs$ 制定的所以说一开始的所有与 $x$ 相邻的节点都会满足这个条件，而修改高度之后就不一定了，所以要求**重贴标签必须将需进行重贴的节点的高度恰好比它所能够到达的高度最低的节点大 $1$**)，每次的推送量显然不能超过允许通过的流量也不能多于当前节点超额流，所以有推送流量 $d=\min(ef_x,w_i)$，只要出现了流量的转移就必须要重新入队（如果已经在队列里就不用了），值得注意的就是**反向边的允许通过流量一定要加上 $d$**，不然就没法回头了。

补充一点，重贴标记如果失败就让他到源点上面去，由于重贴失败了，所以它一定能够流回源点。

最终 $ef_t$ 就是网络最大流。

![](https://cdn.luogu.com.cn/upload/image_hosting/zg151my6.png)

花了很长时间才将 luogu 样例的维护过程画了出来，但还是很丑，希望大家见谅，感性理解一下吧，特别是上面文字没完全明白的同学，重点注意薄荷绿五角星位置的流量出入与深紫色五角星节点的高度改变，搞清楚这个图那么这个算法就没什么太大问题。

优化：

可以使用 ISAP 的 $gap$ 数组进行优化，这里就简单一提了。

非源点高度设为 $0$ 会增加很多运行次数，把高度设为到 $t$ 的距离明显能少跑很多。bfs 反向遍历一遍就可以了。

然后就是我们的 $gap$ 数组优化了！我们发现如果一个节点，他它没有别的节点高，就一定无法使得流量到达 $t$。那把它提到 $s$ 上端不就好了？它将直接流向 $s$，不会浪费操作次数，那如何判断呢？用 $gap$ 存储每个高度的个数就可以了！

AC Code of [Luogu P4722 【模板】最大流 加强版 / 预流推进](https://www.luogu.com.cn/problem/P4722)

```cpp
/*
	Luogu name: Symbolize
	Luogu uid: 672793
*/
#include<bits/stdc++.h>
#define int long long
#define pii pair<int,int>
#define x first
#define y second
#define rep1(i,l,r) for(register int i=l;i<=r;++i)
#define rep2(i,l,r) for(register int i=l;i>=r;--i)
#define rep3(i,x,y,z) for(register int i=x[y];~i;i=z[i])
#define rep4(i,x) for(auto i:x)
#define debug() puts("----------")
const int N=1e6+10;
const int inf=0x3f3f3f3f3f3f3f3f;
using namespace std;
int n,m,s,t,e[N],h[N],ne[N],w[N],idx,highh[N],ef[N],gap[N],vis[N];
struct cmp{bool operator()(int a,int b)const{return highh[a]<highh[b];}};//手动定义排序规则 
priority_queue<int,vector<int>,cmp> q;
int read()
{
	int x=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9')
	{
		if(ch=='-') f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')
	{
		x=(x<<3)+(x<<1)+(ch^48);
		ch=getchar();
	}
	return x*f;
}
void add(int x,int y,int z)
{
	idx+=2;//建立双向边 
	e[idx]=y;
	ne[idx]=h[x];
	w[idx]=z;
	h[x]=idx;
	e[idx+1]=x;
	ne[idx+1]=h[y];
	w[idx+1]=0;//反相边的权值为0
	h[y]=idx+1;
	return;
}
bool bfs()//bfs把初始的高度定义为到t的距离，s则为n 
{
	queue<int> q;
	memset(highh,0x3f,sizeof highh);
	highh[t]=0;//t的高度为0，起点 
	q.push(t);//从t开始 
	while(!q.empty())
	{
		int x=q.front();
		q.pop();
		for(int i=h[x];~i;i=ne[i])
		{
			int to=e[i];
			if(w[i^1]/*剩余容量不为0*/&&highh[to]>highh[x]+1/*可以流向当前目标节点*/)
			{
				highh[to]=highh[x]+1;//更新高度 
				q.push(to);//进队 
			}
		}
	}
	//判断是否连通 
	if(highh[s]!=inf) return 1;
	return 0;
}
void push(int x)
{
	rep3(i,h,x,ne)
	{
		int to=e[i];
		if(w[i]/*剩余容量不为0*/&&highh[to]+1==highh[x]/*高度满足*/&&highh[to]<inf)
		{
			int d=min(ef[x],w[i]);//推送余留不得大于当前节点余流和剩余容量 
			w[i]-=d;//当前边的容量减掉 
			w[i^1]+=d;//方向边的流量加上 
			ef[x]-=d;//当前节点余留减少 
			ef[to]+=d;//增加目标余流 
			if(to!=s/*不为源点*/&&to!=t/*不为汇点*/&&!vis[to]/*不在优先队列中*/)
			{
				q.push(to);//加入优先队列等待推送
				vis[to]=1;//以加入优先队列 
			}
			if(!ef[x]) break;//没有余流了 
		}
	}
	return;
}
void relabel(int x)//重贴标签 
{
	highh[x]=inf;
	rep3(i,h,x,ne)
	{
		int to=e[i];
		if(w[i]/*剩余容量不为0*/&&highh[to]+1<highh[x]/*保证下一次可以推送即可，不要过高*/) highh[x]=highh[to]+1;
	}
	return;
}
int HLPP()//核心操作 
{
	if(!bfs()) return 0;
	highh[s]=n;//源点的高度为n 
	memset(gap,0,sizeof gap);
	rep1(i,1,n) if(highh[i]<inf/*没法到达的点就不用了*/) ++gap[highh[i]];//gap优化 
	//为了防止发生一些问题，单独跑一边源点 
	rep3(i,h,s,ne)
	{
		int to=e[i];
		int dist=w[i];
		if(dist&&highh[to]<inf)
		{
			w[i]-=dist;//当前边容量减少 
			w[i^1]+=dist;//反相边流量增加 
			ef[s]-=dist;//当前节点余流推送 
			ef[to]+=dist;//被推送节点余流增加 
			if(to!=s/*不为源点*/&&to!=t/*不为汇点*/&&!vis[to]/*不在优先队列中*/)
			{
				q.push(to);//等待推送 
				vis[to]=1;//已进入优先队列 
			}
		}
	}   
	while(!q.empty())
	{
		int x=q.top();//当前推送节点 
		vis[x]=0;//取消标记 
		q.pop();//出队 
		push(x);//推送 
		if(ef[x])//还有余流 
		{
			if(!--gap[highh[x]]/*如果本高度只有它一个*/) rep1(j,1,n) if(j!=s/*不为源点*/&&j!=t/*不为汇点*/&&highh[j]>highh[x]/*不可能被推送到汇点*/&&highh[j]<n+1/*高度不等于n+1*/) highh[j]=n+1;//把不可能到达汇点的所有点高度调为n+1，直接流向源点 
			relabel(x);//重贴标签，保证下次能够推送 
			++gap[highh[x]];//新的高度 
			q.push(x);//因为还有余流所以进队 
			vis[x]=1;//标记 
		}
	}
	return ef[t];//返回汇点的余流，这就是网络最大流 
}
signed main()
{
	memset(h,-1,sizeof h);
	n=read();
	m=read();
	s=read();
	t=read();
	rep1(i,1,m) 
	{
		int u=read();
		int v=read();
		int w=read();
		add(u,v,w);//连边 
	}
	cout<<HLPP()<<endl;
	return 0;
}
```

---

## 作者：bsdsdb (赞：5)

## Push-Relabel 预流推进算法

~~I have decided to write a tutorial on a topic not even [Um_nik](https://codeforces.com/profile/Um_nik) knows! ([source](https://codeforces.com/blog/entry/92248))~~

与增广算法不同，预流推进会暂时忽略流的守恒性，让节点暂时储存流。

对节点定义一个「高度」$h$，其中 $h(s)=n,h(t)=0$. 算法只会在满足 $h(u)=h(v)+1$ 的边 $(u,v)$ 上执行「推送」操作。同时对每个节点 $u$ 维护其「超额流」并记作 $e(u)$，表示这个点储存的流量，即 $e(u)=\sum_{x\in V}f(x,u)-\sum_{x\in V}f(u,x)$. 称节点 $u$ 溢出，当且仅当 $e(u)>0$. 特别的，$s,t$ 不溢出。在算法运行过程中，除 $s$ 外的所有节点 $u$ 应保持 $e(u)\ge 0$.

推送（Push）操作：对于边 $(u,v)$，如果 $u$ 溢出，则尽可能地将 $u$ 中的超额流推送到 $t$.

重贴标签（Relabel）操作：对于节点 $u$，如果 $u$ 溢出且没有可以执行推送的边，则将 $h(u)$ 设为 $\min_{(u,v)\in E}h(v)+1$，即最小的可以执行推送操作的高度。该操作一定会增大 $h(u)$，并且这是除初始化之外唯一可以改变节点高度的操作。

算法的流程就是先对 $s$ 的所有出边执行推送，然后不断寻找溢出节点，执行推送。如果推送完仍溢出，就重贴标签。

正确性证明：如果有点要将高度抬到 $n+1$ 才能推流，并且除了 $s$ 之外还能向外推流，那么离 $t$ 最近的节点高度最低也是 $4$，矛盾。

### HLPP (Highest Label Preflow Push) 算法

与上文所述的「不断寻找溢出节点」略有不同，HLPP 算法每次都会寻找溢出节点中高度最高的进行操作（详见代码），其复杂度为 $O(n^2\sqrt{m})$.

复杂度证明：

将算法分为 Push，Relabel，选择最高节点三部分进行复杂度分析。

每个节点最高的高度是 $2n-1$，Relabel 操作只对 $n-2$ 个节点生效，因此 Relabel 操作的总复杂度是 $O(n^2)$ 的。

对于 Push 操作，我们定义一个 Push f操作是「饱和的」当且仅当 Push 操作执行完后，这条边满流，否则就是「不饱和的」. 饱和的 Push 的数量是 $O(nm)$ 的（考虑两个有连边的节点 $u$ 和 $v$. 当在边 $(u,v)$ 上进行了一次饱和的Push之后，想要在 $(v,u)$ 上再进行一次，就至少要将 $v$ 的高度增加 $2$，而每个节点的高度只被增加 $O(n)$ 次）。

对于不饱和的 Push，我们定义一个溢出节点的「势能」是所有高度不超过自己（包括自己，包括非溢出节点）的节点个数，即 $pot_u=|\{v|v\in V,h(v)\le h(u)\}|$，「总势能」是所有溢出节点的势能之和，即 $P=\sum_{e(u)>0}pot_u$. 在一次对最高的节点的不饱和的 Push 之后，总势能会减小不比它高的节点的个数（在不饱和的 Push 之后，这个节点肯定不溢出）。在一次饱和的 Push 之后，总势能增加量一定小于 $n$（比他高的溢出节点个数加上不比他高的节点个数）。一次 Relabel 操作也会使总势能最多增加 $n$，因此总势能的总增加量是 $O(n^2m)$ 的。在算法还未运行以及算法结束时，总势能都为 $0$（都没有溢出节点），因此不饱和的Push提供的总势能减小量也应该是 $O(n^2m)$ 的。

定义一个「阶段」是指在最高的溢出节点不发生改变时进行的所有操作的集合。一个阶段中每个节点只会产生一次不饱和的 Push（如果多于一次，那么这个节点一定是推了又被推从而溢出，说明有比最高溢出节点高的溢出节点，矛盾），一次 HLPP 的阶段数量是 $O(n^2)$ 的（证明：定义 $h*$ 为最高溢出节点的高度，即 $h*=\max_{e(u)>0}h(u)$. $h*$ 增加一定是由于Relabel操作，且初始和结束时 $h*$ 都为 $0$. Relabel的次数是 $O(n^2)$ 的，因此 $h*$ 最多增加 $O(n^2)$，减少 $O(n^2)$，共改变 $O(n^2)$ 次）。定义一个阶段是「大」的，当且仅当它包含至少 $k$ 个不饱和的 Push，否则是「小」的。所有小阶段的不饱和的 Push 总次数是 $O(n^2k)$ 的。

在大阶段中高度为 $h*$ 的节点至少有 $k$ 个，因为所有的push都是选择高度最高的节点进行的。每当一个高度为 $h*$ 的节点从溢出变得不溢出时，它对总势能的贡献都减少了 $k$，因为它自己的势能至少有 $k$. 因此大阶段的不饱和的Push数量是 $O(n^2m/k)$ 的。取 $k=\sqrt{m}$，则所有不饱和的Push的数量是 $O(n^2\sqrt{m}+n^2m/\sqrt{m})=O(n^2\sqrt{m})$ 的。

对于寻找最高节点的操作，我们维护 $h_m$（初始为 $0$）和 $2n-1$ 个栈（其实也可以是其它的数据结构，如队列，但是要求 $O(1)$ 插入，删除，给出一个在这个数据结构里的数）$B_1,\cdots,B_{2n-1}$，其中 $B_i$ 存储高度为 $i$ 的所有节点，$h_m$ 代表「我们以为的」$h*$. 在 Relabel 和 Push 时可以进行 $h_m$ 的维护，即如果这个节点 Relabel 之后的高度或 Push 产生的新的溢出节点的高度超过 $h_m$，就更新 $h_m$（在Push时的更新仅在初始化时起作用）. 我们遗漏了 $h*$ 下降的情况，但 $h*$ 上升的情况全部考虑到了，因此 $h_m\ge h*$. 当 $B_{h_m}$ 不为空时，$B_{h_m}$ 中的一个点就是我们想要的「高度最高的溢出节点」。如果 $B_{h_m}$ 不为空，就将 $h_m$ 减 $1$，直到 $B_{h_m}$ 不为空。执行这一操作当且仅当 $h*$ 下降，因此这一操作的总复杂度是 $O(n^2)$ 的，所以寻找最高节点的复杂度是 $O(n^2)$ 的。

总复杂度即为 $O(n^2+n^2+nm+n^2\sqrt{m})=O(n^2\sqrt{m})$.

复杂度证明相关参考资料：

[Levent Tunqel, On the Complexity of Preflow-Push Algorithms for 
Maximum-Flow Problems](https://www.cs.princeton.edu/courses/archive/fall07/cos521/handouts/fulltext.pdf)（总述算法流程，复杂度证明篇幅较长）

[Tarjan, Analysis of the Highest-Label Push-Relabel Algorithm](https://www.cs.princeton.edu/courses/archive/spring13/cos528/PreflowPushBiggestLabelSelectionAnalysis.pdf)（简要证明复杂度，但不完整）

[Joseph Cheriyan and Kurt Mehlhorn, An Analysis of the Highest-Level Selection Rule in the
Preflow-Push Max-Flow Algorithm](https://www.math.uwaterloo.ca/~jcheriya/PDF_files/me3.0.pdf)（简要且完整地证明了不饱和的Push的数量是 $O(n^2\sqrt{m})$ 的）

[Andrew V. Goldberg and Robert E. Tarjan, A New Approach to the Maximum-Flow Problem](http://akira.ruc.dk/~keld/teaching/algoritmedesign_f07/Artikler/08/Goldberg88.pdf)（第 7-8 页证明饱和的Push的数量是 $O(nm)$ 的）

一些常数优化：

- BFS优化

即初始将所有点的高度都设为到 $t$ 的距离，以减少 Relabel 的次数。

```cpp
typedef long long ll;

ll s, t, ex[MAXN + 5] = {}, ht[MAXN + 5], hmx = 0; // 超额流，高度，处于该高度的节点的个数，最高高度 
vector<Edge> e[MAXN + 5];
stack<ll> B[MAXN * 2 + 5]; // 有哪些溢出节点处于该高度 

void addEdge(ll u, ll v, ll w) {
	e[u].push_back(Edge(v, w, e[v].size()));
	e[v].push_back(Edge(u, 0, e[u].size() - 1));
}
bool push(ll u, bool ini = 0) { // 如果处在初始化阶段，则忽略高度和超额流 返回推完之后是否仍然溢出 
	for (Edge& i : e[u]) {
		if (i.val == 0 || (!ini && ht[i.to] != ht[u] - 1) || ht[i.to] == inf) {
			continue;
		}
		ll ps = ini ? i.val : min(i.val, ex[u]); // 要推的流
		if (i.to != s && i.to != t && ex[i.to] == 0) {
			B[ht[i.to]].push(i.to);
			hmx = max(hmx, ht[i.to]);
		}
		ex[i.to] += ps;
		ex[u] -= ps;
		i.val -= ps;
		e[i.to][i.rev].val += ps;
		if (ex[u] == 0) {
			return 0;
		}
	}
	return 1;
}
void relabel(ll u) {
	ht[u] = inf;
	for (Edge i : e[u]) {
		if (i.val == 0) {
			continue;
		}
		ht[u] = min(ht[u], ht[i.to] + 1);
	}
	if (ht[u] != inf) {
		B[ht[u]].push(u);
		hmx = max(hmx, ht[u]);
	} 
}
bool bfs_init() {
	memset(ht, inf, sizeof ht);
	ht[t] = 0;
	queue<ll> q;
	q.push(t);
	while (!q.empty()) {
		ll h = q.front();
		q.pop();
		for (Edge i : e[h]) {
			if (ht[i.to] != inf || i.val != 0) { // 反向bfs，因此只走容量为0的边 
				continue;
			}
			q.push(i.to);
			ht[i.to] = ht[h] + 1;
		}
	}
	if (ht[s] == inf) {
		return 0;
	} else {
		ht[s] = n;
		return 1;
	}
}
ll select() {
	while (hmx >= 0 && B[hmx].empty()) {
		hmx--;
	}
	if (hmx >= 0) {
		ll ret = B[hmx].top();
		B[hmx].pop();
		return ret;
	} else {
		return -1;
	}
}
ll maxFlow() {
	if (!bfs_init()) { // s->t无路径，返回0 
		return 0;
	}
	push(s, 1); // 初始化
	ll u;
	while ((u = select()) != -1) {
		if (push(u)) { // 仍然溢出，则relabel 
			relabel(u);
		}
	} 
	return ex[t];
}
```

---

## 作者：little_grass_sage (赞：4)

~前言：HLPP 比 Dinic 好写多了。~

## HLPP 的思路
这部分别的大佬写得已经很详细了，蒟蒻大概描述一下。  
和 Dinic 等基于增广路的算法不同，HLPP 可以不保持流守恒性。  
所以我们定义一个点的超额流为流入的流量减去流出的流量。  
如果一个点它的超额流不为零，则称此节点溢出（注意提到溢出点时不包括 $s$ 和 $t$）。  
HLPP 就是通过将溢出点的溢出流推送出去来求最大流。  
为了不让两个点互相推流导致死循环，我们给每个点定义一个高度 $h$，并且只允许 $u$ 向高度为 $h_u-1$ 的点推流。  
### 算法过程
1. 从起始点向周围的点饱和推流。  
2. 将溢出的点加入一个按高度排序的大根堆。  
3. 拿出堆顶的点，并将它向周围点推流，若一个点被推流后变成溢出点则将那个点也加入堆。  
4. 若推流后该点仍然为溢出的点，则将它的高度设为周围有剩余流量的最低的点的高度加一并将它重新加入堆。
5. 若某时堆为空则结束算法。  
### 一些优化
#### 预处理高度
以 $t$ 为初始节点跑一次 bfs，将和 $t$ 的距离设为节点的初始高度。  
#### gap 优化
没用上，咕咕咕。  
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
long long ll[1209][1209],sl[1209],high[1209];
vector<long long>ve[1209];
priority_queue<pair<long long,long long> >cz;
int main(){
	ios::sync_with_stdio(0);
	long long a,b,c,d;
	cin>>a>>b>>c>>d;
	for(long long i=1,x,y,z;i<=b;i++){
		cin>>x>>y>>z;
		ve[x].push_back(y),ve[y].push_back(x);
		ll[x][y]+=z;
	}
	queue<int>q;//预处理高度
	q.push(d);
	while(q.size()){
		int x=q.front();
		q.pop();
		for(auto i:ve[x]){
			if(!high[i]){
				high[i]=high[x]+1;
				q.push(i);
			}
		}
	}
	high[c]=a;
	for(auto i:ve[c]){//从t点饱和推流
		if(ll[c][i]){
			sl[i]=ll[c][i];
			ll[i][c]+=ll[c][i],ll[c][i]=0;
			if(i!=d&&i!=c)cz.push({high[i],i});
		}
	}
	while(cz.size()){//HLPP主代码
		long long x=cz.top().second;
		cz.pop();
		long long mi=1e9;
		for(auto j:ve[x]){
			if(ll[x][j]){
				if(high[j]==high[x]-1){
					long long ts=min(ll[x][j],sl[x]);//推流
					ll[x][j]-=ts,ll[j][x]+=ts,sl[x]-=ts,sl[j]+=ts;
					if(sl[j]==ts&&j!=d&&j!=c)cz.push({high[j],j});
				}
				if(!sl[x])break;
				if(ll[x][j])mi=min(mi,high[j]);//预处理新的高度
			}
		}
		if(sl[x])high[x]=mi+1,cz.push({high[x],x});//重新入堆
	}
	cout<<sl[d];
	return 0;
}
```
## 后话
这个写法我自认为很简单，而且它的常数看起来很小，在未使用任何优化时就可以达到 $1.63$ 秒，加上预处理高度后能达到 $1.28$ 秒。

---

## 作者：lzj666_luogu (赞：1)

## 背景

[欢迎来到我的博客阅读](https://lzj-blog.top/2025/05/20/%E9%A2%98%E8%A7%A3%EF%BC%9A%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E9%A2%84%E6%B5%81%E6%8E%A8%E8%BF%9B/)

我们注意到其他的网络流算法都是 $O(n^2m)$，$(n^3)$ 或 $O(nm^2)$ 等的时间复杂度上界，太大了，有没有更加紧凑的时间复杂度上界呢？有的，兄弟有的，HLPP 时间复杂度为 $O(n^2m^{\frac{1}{2}})$，快多了，而且在随机图中也不会太劣于 Dinic 或者 ISAP。

## 算法介绍

我们现在允许流量在非源汇点的节点中暂时存储（我们将存储在非源汇点中的流称作这个点的**超额流**），同时定义以下操作：

设置一个高度函数 $h(x)$，初始值除了源点 $s$ 为 $n$ 以外，其余都通过 BFS 求解初始值：从 $t$ 到 $s$ 反向 BFS，使每个点有一个初始高度（它到汇点的距离）。

推流（Push）：如果结点 $u$ 溢出（超额流不为零），且存在结点 $v((u,v)\in E_f,c(u,v)-f(u,v)>0,h(u)=h(v)+1)$，那么我们尽可能将超额流从 $u$ 流向 $v$，如果 $(u,v)$ 在推送完之后满流，将其从残量网络中删除。

重标号（Relabel）：检查是否有结点 $u$ 溢出（超额流不为零），且 $\forall (u,v)\in E_f,h(u)\leq h(v)$，那么我们就要将 $h(u)$ 更新为 $\min_{(u,v)\in E_f}h(v)+1$。

主要流程：

1. 先从 $t$ 到 $s$ 反向 BFS，使每个点有一个初始高度（它到汇点的距离）。
2. 从 $s$ 开始向外推流，将有超额流的点放入优先队列。
3. 不断从优先队列里取出高度最高的点进行推流操作。
4. 若推完还有超额流，更新高度标号，重新放入优先队列。
5. 当优先队列为空时结束算法，最大流即为 $t$ 的超额流。

图解如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/9kvjillc.png)

gap 优化：如果某个高度不存在，为什么我们就不继续算了，直接将所有比该高度高的节点标记为不可到达（使它的高度为 $n+1$，这样就会直接向 $s$ 推流了）。

## 正确性证明

首先，因为求的是最大流，所以我们最直观的想法就是管它能不能塞那么多，源点直接全部流出去。预流推进算法的思想就是，允许流量在非源汇点的节点中暂时存储（我们将存储在非源汇点中的流称作这个点的**超额流**），同时伺机将自身的超额流通过管道**推送**出去。只要保证在算法结束后所有非源汇点的超额流都为 $0$，那么这种方案就是合法的。

考虑一个朴素的算法，我们设置一个高度函数 $h(x)$，初始值除了源点 $s$ 为 $n$ 以外，其余初始值都为 $0$。

推流：如果结点 $u$ 溢出，且存在结点 $v((u,v)\in E_f,c(u,v)-f(u,v)>0,h(u)=h(v)+1)$，那么我们尽可能将超额流从 $u$ 推送到 $v$，推送过程中我们**只关心超额流和 $c(u,v)-f(u,v)$ 的最小值，不关心 $v$ 是否溢出**，如果 $(u,v)$ 在推送完之后满流，将其从残量网络中删除。

具体的呢，就是如下操作：

1. 先从 $s$ 向周围点推流（把该点的**超额流**推给周围点，注意：**推的流量不能超过边的容量也不能超过该点超额流**），并让周围点入队。（**注意：$s$ 和 $t$ 不能入队**）

2. 不断地取队首元素，对队首元素推流。

3. 队列为空时结束算法，$t$ 点的超额流即为最大流。

同时，我们在过程中要检查是否有结点 $u$ 溢出，且 $\forall (u,v)\in E_f,h(u)\leq h(v)$，那么我们就要将 $h(u)$ 更新为 $\min_{(u,v)\in E_f}h(v)+1$。

为什么这样就不会出现来回推流的情况了呢？

当两个点开始来回推流时，它们的高度会不断上升，当它们的高度大于 $s$ 时，会把超额流还给 $s$。

**所以在开始预流推进前要先把 $s$ 的高度改为 $n$（点数），免得一开始 $s$ 周围那些点就急着把超额流还给 s。**

### 时间复杂度

对于暴力扫描策略按固定顺序遍历顶点，对每个顶点执行 Push 或 Relabel 操作的暴力算法。其时间复杂度主要由以下两部分决定：

#### **1. Relabel 操作的次数**

每个顶点 $u$ 的高度 $h(u)$ 初始为 $0$，每次 Relabel 操作后 $h(u)$ 严格递增（设为相邻顶点最小高度 + 1），且 $h(u)$ 的最大值不超过 $2n$（当顶点无法向汇点推送时，其高度最终会被抬高至 $n+1$，回流至源点）。因此，每个顶点最多被 Relabel $O(n)$ 次，总 Relabel 次数为 $O(n^2)$（$n$ 为顶点数）。

#### **2. Push 操作的次数**

对于每条边 $(u, v)$，每次 Push 操作会减少其残量容量。当边 $(u, v)$ 的残量容量为 $0$ 时，需等待 $u$ 或 $v$ 被 Relabel（$h(u)$ 或 $h(v)$ 改变）后才可能再次被推送。由于 $h(u)$ 和 $h(v)$ 的变化次数均为 $O(n)$，每条边最多被 Push $O(n)$ 次。总边数为 $m$，因此总 Push 次数为 $O(nm)$。

综上，暴力扫描策略的时间复杂度为 $O(n^2m)$（Relabel 的 $O(n^2)$ 次操作与 Push 的 $O(nm)$ 次操作的乘积，单次操作时间为 $O(1)$）

### HLPP 在此基础上的优化

HLPP 通过优先处理高度最高的活跃顶点（使用桶结构按高度分层管理），避免了暴力扫描中的无效推送，将时间复杂度优化至 $O(n^2\sqrt{m})$。其推导核心如下：

#### **1. 高度分层与桶结构的作用**

HLPP 维护一个桶数组，每个桶对应一个高度值，存储该高度下的所有活跃顶点（超额流非零的顶点）。每次选择当前最高高度的桶中的顶点进行处理，确保流量优先向低高度层传递，减少“乒乓推送”（两个顶点反复互相推送）的可能。

#### **2. 关键引理：边的推送次数限制**

通过分析高度函数的变化规律，可证明每条边 $(u,v)$ 最多被 Push $O(\sqrt{m})$ 次。假设顶点 $u$ 的高度为 $h$，顶点 $v$ 的高度为 $h-1$（满足推送条件），则当 $u$ 向 $v$ 推送后，$v$ 的高度可能因后续 Relabel 操作而增加，但 HLPP 优先处理高高度顶点，使得 $v$ 的高度不会频繁低于 $u$ 的高度，从而限制了同一条边的重复推送次数。

#### **3. 总操作次数的优化**

- **Relabel 操作次数**：每个顶点的高度最多增加 $O (n)$ 次，总次数仍为 $O (n^2)$。

- **Push 操作次数**：每条边最多被 Push $O (\sqrt{m})$ 次，总次数为 $O (m\sqrt{m})$。

总而言之，HLPP 的时间复杂度优化为 $O(n^2\sqrt{m})$，显著优于暴力扫描的 $O(n^2m)$。

### 时间复杂度（理论）对比

![](https://cdn.luogu.com.cn/upload/image_hosting/iw8vbd2v.png)

## 代码实现

```cpp
#include<bits/stdc++.h>
using namespace std;
struct Edge {
	int v, w, nxt;
}edge[2500000 + 10];
int head[12000 + 10], idx = 1;
void add(int u, int v, int w) {
	edge[++idx] = { v,w,head[u] };
	head[u] = idx;
}
void addedge(int u, int v, int w) {
	add(u, v, w); add(v, u, 0);
}
int h[12000 + 10], more[12000 + 10], g[12000 + 10];
struct _ { bool operator()(int a, int b) { return h[a] < h[b]; } };
priority_queue<int, vector<int>, _> pq;
bool vis[12000 + 10];
void bfs(int t) {
	memset(h, 0x3f, sizeof h);
	queue<int>q; h[t] = 0; q.push(t);
	while (!q.empty()) {
		int now = q.front(); q.pop();
		for (int i = head[now]; i; i = edge[i].nxt)
			if (edge[i ^ 1].w && h[edge[i].v] > h[now] + 1)
				h[edge[i].v] = h[now] + 1, q.push(edge[i].v);
	}
}
void push(int now, int s, int t) {
	for (int i = head[now]; i; i = edge[i].nxt) {
		if (edge[i].w && h[edge[i].v] + 1 == h[now]) {
			int flow = min(more[now], edge[i].w);
			more[edge[i].v] += flow; more[now] -= flow;
			edge[i].w -= flow; edge[i ^ 1].w += flow;
			if (edge[i].v != s && edge[i].v != t && !vis[edge[i].v])
				vis[edge[i].v] = 1, pq.push(edge[i].v);
			if (more[now] == 0) return;
		}
	}
}
void relabel(int now) {
	h[now] = INT_MAX;
	for (int i = head[now]; i; i = edge[i].nxt)
		if (edge[i].w && h[edge[i].v] + 1 < h[now])
			h[now] = h[edge[i].v] + 1;
}
int hlpp(int n, int s, int t) {
	bfs(t);
	if (h[s] == 0x3f3f3f3f) return 0;
	h[s] = n;
	for (int i = 1; i <= n; ++i) if (h[i] ^ 0x3f3f3f3f) g[h[i]]++;
	for (int i = head[s]; i; i = edge[i].nxt)
		if (int w = edge[i].w; w)
			edge[i].w -= w, edge[i ^ 1].w += w, more[s] -= w, more[edge[i].v] += w,
			edge[i].v != s && edge[i].v != t && !vis[edge[i].v] ? vis[edge[i].v] = 1, pq.push(edge[i].v) : void();
	while (!pq.empty()) {
		int now = pq.top(); pq.pop(); vis[now] = 0; push(now, s, t);
		if (more[now])
			if ((h[now] ^ 0x3f3f3f3f)) {
				if (!--g[h[now]])
					for (int i = 1; i <= n; i++)
						if (i != s && i != t && h[i] > h[now] && h[i] < n + 1)
							h[i] = n + 1;
				relabel(now); ++g[h[now]], pq.push(now), vis[now] = 1;
			}
	}
	return more[t];
}
int n, m, s, t;
signed main() {
	cin.tie(0)->sync_with_stdio(false);
	cin >> n >> m >> s >> t;
	for (int i = 1, u, v, w; i <= m; ++i) {
		cin >> u >> v >> w; addedge(u, v, w);
	}
	cout << hlpp(n, s, t) << endl;
	return 0;
}
```

---


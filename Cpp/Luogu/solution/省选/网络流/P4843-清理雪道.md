# 清理雪道

## 题目描述

滑雪场坐落在 FJ 省西北部的若干座山上。

从空中鸟瞰，滑雪场可以看作一个有向无环图，每条弧代表一个斜坡（即雪道），弧的方向代表斜坡下降的方向。

你的团队负责每周定时清理雪道。你们拥有一架直升飞机，每次飞行可以从总部带一个人降落到滑雪场的某个地点，然后再飞回总部。从降落的地点出发，这个人可以顺着斜坡向下滑行，并清理他所经过的雪道。

由于每次飞行的耗费是固定的，为了最小化耗费，你想知道如何用最少的飞行次数才能完成清理雪道的任务。

## 说明/提示

#### 数据规模与约定

对于 $100\%$ 的数据，$2 \le  n \le 100$，$1\le m_i < n$，且每个地点至少有一个斜坡与之相连。

## 样例 #1

### 输入

```
8
1 3
1 7
2 4 5
1 8
1 8
0
2 6 5
0```

### 输出

```
4```

# 题解

## 作者：ez_lcw (赞：15)

上下界网络流的做法大佬们都讲过了，我就来讲一个另类的解法。（不过也是网络流）

~~这个做法是考场上想了很久都不会后奇思妙想想出来的（不会上下界网络流），所以没多少思路引导。~~

首先原题明显可以转移成一个类似最小链覆盖的问题。

剩下的就是我的具体做法：

我们对原来的有向无环图进行改造：

![](https://cdn.luogu.com.cn/upload/image_hosting/0h7bd7gh.png)

上面的是原图，我们把图中的每一条边 $e_i$ 拆成两条边：一条流量为 $1$，费用为 $1$，不妨取名叫 $a_i$；一条流量为 $\infty$，费用为 $0$，取名叫 $b_i$。然后源点向每个入度为 $0$ 的点（也就是链覆盖的起点）连边，流量 $\infty$，费用 $0$；每个出度为 $0$ 的点（也就是链覆盖的终点）向汇点连边，流量 $\infty$，费用 $0$。

然后跑**最大**费用最大流。

意思就是说每次增广时，相当于我新覆盖一条链。在增广中：

如果某条原图中的边 $e_i$ 没有被走过，那么为了满足最大费用，程序肯定会选择流费用为 $1$ 的那条边 $a_i$，费用增加 $1$，代表我新清理了一条雪道，即新访问了一条原图中的边；

如果这条边 $e_i$ 被走过了，那么费用为 $1$ 的那条边肯定被流满了，只能流费用为 $0$ 的边，不贡献费用，意思就是我走过的这条边在我前几次覆盖时已经被覆盖了，也就是说我只是路过这，并不要清理这。

然后根据最大费用最大流的特性，每次增广完后，能保证所得的解是当前的最优解，也就是说它能保证用最优方法覆盖所有边。

那么当贡献的费用等于总边数时，整个图也就被我们覆盖完了，答案就是链的条数，也就是覆盖的次数，或者说增广的次数。

整道题也就结束了。

顺带说一下，其实这种**跑网络流却不跑完，把网络流当成一个类似贪心的工具来使用**的 trick 挺实用也挺常见的（类似数学中的设而不求），比如 BZOJ2893征服王 也可以用这个 trick 做，而且比这个麻烦一点，所以建议总结一下（

代码如下：

```cpp
#include<bits/stdc++.h>

#define N 110
#define M 10010
#define INF 0x7fffffff

using namespace std;

inline int read()
{
	int x=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9')
	{
		if(ch=='-') f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')
	{
		x=(x<<1)+(x<<3)+(ch^'0');
		ch=getchar();
	}
	return x*f;
}

int n,s,t,tot,ans;
int rudu[N],chudu[N];
int cnt=1,head[N],to[N*4+M*4],nxt[N*4+M*4],c[N*4+M*4],w[N*4+M*4];
int pre[N],dis[N];
bool inq[N];

queue<int>q;

void adde(int u,int v,int ci,int wi)
{
	to[++cnt]=v;
	c[cnt]=ci;
	w[cnt]=wi;
	nxt[cnt]=head[u];
	head[u]=cnt;
	
	to[++cnt]=u;
	c[cnt]=0;
	w[cnt]=-wi;
	nxt[cnt]=head[v];
	head[v]=cnt;
}

bool SPFA()
{
	memset(dis,128,sizeof(dis));
	q.push(s);
	dis[s]=0;
	inq[s]=1;
	while(!q.empty())
	{
		int u=q.front();
		q.pop();
		inq[u]=0;
		for(int i=head[u];i;i=nxt[i])
		{
			int v=to[i];
			if(c[i]&&dis[u]+w[i]>dis[v])
			{
				dis[v]=dis[u]+w[i];
				pre[v]=i;
				if(!inq[v])
				{
					inq[v]=1;
					q.push(v);
				}
			}
		}
	}
	return dis[t]!=dis[0];
}

void MCMF()
{
	int maxcost=0,maxflow=0;
	while(SPFA())
	{
		int minflow=INF;
		for(int u=t;u!=s;u=to[pre[u]^1]) 
			minflow=min(minflow,c[pre[u]]);
		for(int u=t;u!=s;u=to[pre[u]^1])
		{
			c[pre[u]]-=minflow;
			c[pre[u]^1]+=minflow;
			maxcost+=minflow*w[pre[u]];
		}
		maxflow+=minflow;
		ans++;//统计增广次数（链的条数）
		if(maxcost==tot) break;//如果最大费用达到总边数
	}
}

int main()
{
	n=read();
	s=1,t=1+n+1;
	for(int i=1;i<=n;i++)
	{
		int m=read();
		tot+=m;
		for(int j=1;j<=m;j++)
		{
			int v=read();
			adde(1+i,1+v,1,1);//ai
			adde(1+i,1+v,INF,0);//bi
			chudu[i]++,rudu[v]++;
		}
	}
	for(int i=1;i<=n;i++)
	{
		if(!rudu[i]) adde(s,1+i,INF,0);//源点连入度为0的点
		if(!chudu[i]) adde(1+i,t,INF,0);//出度为0的点连汇点
	}
	MCMF();//最大费用最大流
	printf("%d\n",ans);
	return 0;
}
/*
5
1 2
0
2 2 4
0
1 4
*/
```

---

## 作者：xht (赞：13)

题目地址：[P4843 清理雪道](https://www.luogu.org/problemnew/show/P4843)

### 上下界网络流

#### 无源汇上下界可行流

> 给定 $n$ 个点， $m$ 条边的网络，求一个可行解，使得边 $(u,v)$ 的流量介于 $[B(u,v),C(u,v)]$ 之间，并且整个网络满足流量守恒。

如果把 $C-B$ 作为容量上界， $0$ 作为容量下界，就是一般的网络流模型。

然而求出的实际流量为 $f(u,v)+B(u,v)$ ，不一定满足流量守恒，需要调整。

设 $inB[u]=\sum B(i,u)$ ， $outB[u]=\sum B(u,i)$ ， $d[u]=inB[u]-outB[u]$ 。

新建源汇， $S$ 向 $d>0$ 的点连边， $d<0$ 的点向 $T$ 连边，容量为相应的 $d$ 。

在该网络上求最大流，则每条边的流量 $+$ 下界就是原网络的一个可行流。

具体实现时，可省略 $inB,outB$ 数组，直接在 $d$ 数组上修改。

#### 有源汇上下界可行流

从 $T$ 到 $S$ 连一条下界为 $0$ ，上界为 $+inf$ 的边，把汇流入的流量转移给源流出的流量，转化为无源汇的网络，然后求解**无源汇上下界可行流**。

#### 有源汇上下界最小流

两个方法：

1. 二分答案 $ans$ ，从 $T$ 到 $S$ 连一条下界为 $0$ ，上界为 $ans$ 的边，转化为无源汇网络。找到最小的 $ans$ ，使得该无源汇上下界网络有可行流。
2. 类似**有源汇上下界可行流**的构图方法，但先不添加 $T$ 到 $S$ 的边，求一次超级源到超级汇的最大流。然后再添加一条从 $T$ 到 $S$ 下界为 $0$ ，上界为 $+inf$ 的边，在**残量网络**上再求一次超级源到超级汇的最大流。流经 $T$ 到 $S$ 的边的流量就是最小流的值。该算法的思想是在第一步中尽可能填充循环流，以减小最小流的代价。

连边：

1. $(s,i,0,+inf)$ ；
2. $(i,t,0,+inf)$ ；
3. 对每条雪道，连边 $(i,j,1,+inf)$ 。

对网络 $s-t$ 求**有源汇上下界最小流**。

这里使用方法二。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 106, M = 2e4 + 6, inf = 1e9;
int n, s, t, S, T, d[N], ans;
int Head[N], Edge[M], Leng[M], Next[M], tot = 1;

inline void add(int x, int y, int z) {
    Edge[++tot] = y;
    Leng[tot] = z;
    Next[tot] = Head[x];
    Head[x] = tot;
    Edge[++tot] = x;
    Leng[tot] = 0;
    Next[tot] = Head[y];
    Head[y] = tot;
}

inline void ins(int x, int y, int l, int r) {
    add(x, y, r - l);
    d[x] -= l;
    d[y] += l;
}

inline bool bfs() {
    memset(d, 0, sizeof(d));
    queue<int> q;
    q.push(S);
    d[S] = 1;
    while (q.size()) {
        int x = q.front();
        q.pop();
        for (int i = Head[x]; i; i = Next[i]) {
            int y = Edge[i], z = Leng[i];
            if (d[y] || !z) continue;
            q.push(y);
            d[y] = d[x] + 1;
            if (y == T) return 1;
        }
    }
    return 0;
}

int dinic(int x, int flow) {
    if (x == T) return flow;
    int rest = flow;
    for (int i = Head[x]; i && rest; i = Next[i]) {
        int y = Edge[i], z = Leng[i];
        if (d[y] != d[x] + 1 || !z) continue;
        int k = dinic(y, min(rest, z));
        if (!k) d[y] = 0;
        else {
            Leng[i] -= k;
            Leng[i^1] += k;
            rest -= k;
        }
    }
    return flow - rest;
}

int main() {
    cin >> n;
    s = n + 1, t = n + 2, S = n + 3, T = n + 4;
    for (int i = 1; i <= n; i++) {
        ins(s, i, 0, inf);
        ins(i, t, 0, inf);
        int k;
        scanf("%d", &k);
        while (k--) {
            int x;
            scanf("%d", &x);
            ins(i, x, 1, inf);
        }
    }
    for (int i = 1; i <= t; i++) {
        if (d[i] > 0) add(S, i, d[i]);
        else if (d[i] < 0) add(i, T, -d[i]);
    }
    while (bfs()) while (dinic(S, inf));
    ins(t, s, 0, inf);
    while (bfs()) while (dinic(S, inf));
    cout << Leng[tot] << endl;
    return 0;
}
```

---

## 作者：William_Wang_ (赞：7)

[题目](https://www.luogu.com.cn/problem/P4843)

题解都是使用最小流、费用流，本篇题解介绍**只跑一遍最大流**的解法。加上快读容易拿到最优解。

---

记虚拟源点为 $s$，虚拟汇点为 $t$，$f(u,v)$ 表示边 $(u,v)$ 的覆盖次数，将其视为流量。

其中 $f(s,u)$ 表示以 $u$ 为起点的路径数量；$f(u,t)$ 表示以 $u$ 为终点的路径数量。

要求所有斜坡 $(u,v)$ 满足 $f(u,v) \ge 1$，最小化 $\sum f(s,u)$。

接下来是很妙的处理。

为处理下界，设计 $f'(u,v)= f(u,v) - 1$。

为满足流量平衡并最小化答案，设计 $f'(s,u)=\text{outdeg}(u)-f(s,u)$，$f'(u,t)=\text{indeg}(u) - f(u,t)$。考虑到最优方案一定有 $f(s,u) \le \text{outdeg}(u),f(u,t) \le \text{indeg}(u)$，可以保证最优方案的 $f' \ge 0$。

根据 $f$ 的流量平衡式子推出 $f'$ 的式子并使 $f'$ 的系数为正，根据斜对称性，发现 $f'$ 要将斜坡边取反。


建 $s$ 到 $u$ 的容量为 $\text{outdeg}(u)$ 的边，建 $u$ 到 $t$ 容量为 $\text{indeg}(u)$ 的边，对于斜坡 $(u,v)$ 建 $v$ 到 $u$ 容量为 $\inf$ 的边。


最终的答案就是所有点的出度和减去 $f'$ 的最大流。



```cpp
#include<bits/stdc++.h>
using namespace std;
const int inf = 1e9;
int n, s, t, indeg[105], outdeg[105], d[105], cur[105], r[105][105];
queue <int> q;
bool bfs()
{
	memset(d, 0, sizeof(d));
	q.push(s), d[s] = 1;
	while(!q.empty())
	{
		int u = q.front(); q.pop();
		for(int v = 1; v <= n + 2; v ++ )
		{
			if(!d[v] and r[u][v] > 0)
				q.push(v), d[v] = d[u] + 1;
		}
	}
	return d[t] > 0; 
}

int dfs(int u, int sum)
{
	if(u == t or sum == 0) return sum;
	int flow = 0;
	for(int v = cur[u]; v <= n + 2; v ++ )
	{
		cur[u] = v;
		if(d[v] == d[u] + 1 and r[u][v] > 0)
		{
			int delta = dfs(v, min(r[u][v], sum));
			r[u][v] -= delta, r[v][u] += delta;
			flow += delta, sum -= delta;
		}
	}
	return flow;
}

int main()
{
	cin >> n;
	s = n + 1, t = n + 2;
	for(int u = 1; u <= n; u ++ )
	{
		int m; cin >> m;
		while(m -- )
		{
			int v; cin >> v;
			indeg[v] ++ , outdeg[u] ++ ;
			r[v][u] = inf;
		}
	}
	
	int ans = 0;
		
	for(int i = 1; i <= n; i ++ )
		r[s][i] = outdeg[i], r[i][t] = indeg[i], ans += outdeg[i];
		
	while(bfs())
	{
		for(int i = 1; i <= n + 2; i ++ ) cur[i] = 1;
		ans -= dfs(s, inf);
	}
	
	cout << ans;
	return 0;
}
```

---

## 作者：JohnJoeZhu (赞：3)

[题面传送门](https://www.luogu.com.cn/problem/P4843)

~~题解区好像对我这种蒟蒻不太友好啊，我来补一发~~

本篇文字比较多，建议细心读（蒟蒻会补图的）

### 1.算法
- 图论 

这个显然吧

- 网络流

为什么用到网络流呢？

因为每个斜坡都代表一条有向边，我们可以认为人滑雪相当于流流量

每个点都可以出发，所以源点S向每个点连边；每个点都可以结束，所以每个点向汇点T连边

可是流量呢？

每条边我们都没办法确定流过次数，但是如果全部设置为$inf$又显然不可行

- 有上下界网络流

对于每条边，都至少流过1次，但可以流无限次，可以想到有上下界网络流

- 有源汇上下界最小流

这个显然吧

### 2.实现

~~这是蒟蒻最艰难的部分，大佬们可略过~~

怎么来解决这个问题呢？

我们不从无源汇上下界可行流说起

- 有源汇上下界最小流

已知：如何求有源汇无下界最大流

实现最小流会满足什么呢？

**流量守恒**（除源汇点外的每个点的总流入量=总流出量）且**汇点流量最小**

对于已知，我们可以得到，每一条增广路，流过一次对于残量网络仍满足流量守恒，那么我们是不是可以找到可行流（仅满足流量守恒），然后减少T-S的最大流

为什么这样子可行呢？

因为反向边的流量增加等价于正向边的的流量减少。因此在残量网络上找出t到s的流就相当于减小了s到t的流。

- 有源汇上下界可行流

我们来看流量守恒的定义：

**除源汇点外**的每个点的总流入量=总流出量

我们发现，在这里只有源汇点在搞特殊，那么我们是不是可以连一条T-S的边，下界0，上界$inf$，表示我们把从S流到T的流量都流回去，那么这个源汇点就被解决了

等等，你还没有说上下界怎么弄呢！

不着急，我们不是已经找到我们的终极目标了吗？

- 无源汇上下界可行流

终于，我们来处理上下界了

首先，对于每一条流都要满足下界，所以我们可以得到一个新的残量网络，每条边流量为 上界-下界 ，表示对于原网络流下界流满，在 上界-下界 里做文章。

可以认为在残量网络中一条从u到v的边上的1个流量代表将原图中u到v的流量增大1

这个时候，每个点不一定会流量守恒啊，怎么办

那么我们就应该先统计每个点滞留的流量（建边时随便统计），会有一下几种情况

1. 如果点i在残量网络中流入量>流出量,那么我们需要给多的流入量找一个去处
2. 如果点i在残量网络中流入量<流出量,那么我们需要给多的流出量找一个来处
3. 如果点i在残量网络中流入量=流出量,那么满足流量守恒

我们所新建的从i出发的边也要有个去处,指向i的边也要有个来路,因此我们新建一个虚拟源点ss和一个虚拟汇点tt。新建的指向i的边都从ss出发,从i出发的边都指向tt。

然后可以证明，ss的流出量=tt的流入量（想想为什么/文章底部有参考资料有证明）

那么，到底在下界上加上多少会使得流量守恒呢

抓住已知，有源汇，那就是ss-tt的最大流实锤了（注意我们不在乎可行流是否最小或最大）

可是为什么呢？

因为根据我们的建边，要满足流量守恒，必须ss和tt相连的边都满流

可以发现假如存在这样的方案,这样的流一定是我们所建出的图的ss-tt最大流,所以跑ss到tt的最大流即可。（蒟蒻不知道为什么啊）

### 3.代码

终于是代码了

不过建议自己打，毕竟思路清晰了，不然可以从下往上再读一遍

```cpp
#include<cstring>
#include<cstdio>
#include<queue>
#include<cmath>
#define maxn 100010
#define inf 1e9
#define min(A,B) A<B?A:B
using namespace std;
struct edge{
    int nex,u,v,w;
}edge[maxn<<2];//maxn的数据范围是无脑开的
int head[maxn],top=1,cur[maxn],totflow[maxn];
int n,m,k,s,t,ss,tt,sum=0,maxflow=0;
int deep[maxn];
void add_edge(int u,int v,int w)
{
    edge[++top].v=v;
    edge[top].u=u; 
    edge[top].w=w;
    edge[top].nex=head[u];
    head[u]=top;
}
void add(int u,int v,int w){add_edge(u,v,w),add_edge(v,u,0);}//双向边
bool bfs()
{
    for(int i=0;i<=t;i++) cur[i]=head[i],deep[i]=0;
    deep[s]=1;
    queue<int>q;
    q.push(s);
    while(!q.empty())
    {
        int u=q.front();
        q.pop();
        for(int i=head[u];i;i=edge[i].nex)
        {
            int v=edge[i].v;
            if(!deep[v]&&edge[i].w)
            {
                deep[v]=deep[u]+1;
                q.push(v);
            }
        }
    }
    return deep[t];
}
int dfs(int u,int lowest)
{
    if(u==t) return lowest;
	int used=0,rlow;
    for(int i=cur[u];i&&used<lowest;i=edge[i].nex)
    {
    	cur[u]=i;
        int v=edge[i].v;
        if(edge[i].w&&deep[u]+1==deep[v])
        {
            if((rlow=dfs(v,min(lowest-used,edge[i].w))))
            {
            	used+=rlow;
                edge[i].w-=rlow;
                edge[i^1].w+=rlow;
                if(used==lowest) break;
            }   
        }
    }
    if(used<lowest) deep[u]=-1;
    return used;
 } //全部模板就不用说了
void Dinic(){maxflow=0;while(bfs()) maxflow+=dfs(s,inf);}
int main()
{
    scanf("%d",&n);
    s=0,t=n+1,ss=n+2,tt=n+3;
    for(int i=1,w,num;i<=n;i++)
    {
    	scanf("%d",&num);
    	for(int j=1;j<=num;j++)
    	{
    		scanf("%d",&w);
    		totflow[i]--,totflow[w]++;//边权1
    		add(i,w,inf);//inf-1=inf
		}
		add(s,i,inf); add(i,t,inf);//可以走无限次
        //注意s和t是没有必要统计totflow的
	}
	for(int i=1;i<=n;i++)
		if(totflow[i]<0) add(i,tt,-totflow[i]);
		else add(ss,i,totflow[i]);//虚拟节点的连边
	add(t,s,inf);//有源汇变成无源汇
	s=ss,t=tt;
	Dinic();
	int ans=edge[top].w;//这是最后一条边的反向边，含义是可行流的大小
	edge[top].w=edge[top-1].w=0;//最后一条边要删掉
	s=n+1,t=0;//把可行流减到最小流（把反向边都流回去且满足流量守恒）
	Dinic();
	printf("%d",ans-maxflow);
    return 0;
}
```

---

## 作者：Hadtsti (赞：2)

### 题意简述

给出一张 $n(1\le n\le 100)$ 个结点的 DAG，求最少能覆盖掉所有边的路径数量（路径之间**可重复点、边**）。

### 题目分析

**注：该做法仅能获得 $90$ 分，AC 做法请查看其它题解~~或者您是卡常大师把这种方法卡到 AC~~**。

如果把覆盖掉所有边换成覆盖掉所有点，则类似于经典的[最小路径覆盖问题](https://www.luogu.com.cn/problem/P2764)。因此可以通过简单的边转点将问题等效为一张新 DAG 中的可重复点最小路径覆盖问题。

点、边可重复也就代表着在拆点二分图中每个点可以与多个其它点形成“匹配”，但是需要额外控制的条件较多，仅通过改变最大流模型中边的容量可能较难实现。

考虑将原本经过重复点的路径转化为无重复点的等效路径。具体地，我们使用传递闭包，然后将可以到达的点对之间都连边，再跑最小路径覆盖问题板子就可以拿到 70pts 了。

我们发现上述算法的瓶颈在于传递闭包。由于维护连通性的数组为一 bool 数组，我们可以采用 bitset 优化~~和亿些卡常~~。这样就能够拿到 90pts。

### 代码实现

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,S,T,x,cnt,d[50010];
int tot=1,hd[50010],nt[2000010],v[2000010],now[50010];
int tmp,ans,w[2000010];
bitset<100010>mp[100010],b[50010];
vector<int>in[50010];
pair<int,int>val[50010];
inline void add(int x,int y,int z)
{
	v[++tot]=y;
	w[tot]=z;
	nt[tot]=hd[x];
	hd[x]=tot;
	v[++tot]=x;
	nt[tot]=hd[y];
	hd[y]=tot;
} 
inline bool bfs()
{
	register queue<int>q;
	q.push(S);
	memset(d,0,sizeof d);
	d[S]=1;
	now[S]=hd[S];
	while(!q.empty())
	{
		register int x=q.front();
		q.pop();
		for(register int i=hd[x];i;i=nt[i])
		{
			register int y=v[i];
			if(!d[y]&&w[i])
			{
				d[y]=d[x]+1;
				now[y]=hd[y];
				if(y==T)
					return 1;
				q.push(y);
			}
		}
	}
	return 0;
}
inline int dinic(int x,int fl)
{
	if(x==T)
		return fl;
	register int rs=fl;
	for(register int i=now[x];i&&rs;i=nt[i])
	{		now[x]=i;
		register int y=v[i];
		if(w[i]&&d[y]==d[x]+1)
		{
			int k=dinic(y,min(rs,w[i]));
			if(!k)
				d[y]=0;
			w[i]-=k;
			w[i^1]+=k;
			rs-=k;
		}
	}
	return fl-rs;
}
int main()
{
	scanf("%d",&n); 
	for(register int i=1;i<=n;i++)
	{
		scanf("%d",&m);
		for(register int j=1;j<=m;j++)
		{
			scanf("%d",&x);
			cnt++;
			val[cnt]={i,x};
			in[x].push_back(cnt);
			b[i][cnt]=1;
		}
	}
	S=2*cnt+1,T=2*cnt+2;
	for(register int i=1;i<=cnt;i++)
		add(S,i,1),add(i+cnt,T,1);
	for(register int i=1;i<=n;i++)
		for(register int j:in[i])//边转点 
			mp[j]|=b[i];
	for(register int k=1;k<=cnt;k++)
		for(register int i=1;i<=cnt;i++)
			if(mp[i][k])
				mp[i]|=mp[k];//传递闭包 
	for(register int i=1;i<=cnt;i++)
		for(register int j=1;j<=cnt;j++)
			if(mp[i][j])
				add(i,j+cnt,1);//建边 
	while(bfs())
		while(tmp=dinic(S,0x3f3f3f3f))
			ans+=tmp; 
	printf("%d\n",cnt-ans);//最小路径覆盖=点数-最大匹配 
	return 0;
}
```


---

## 作者：LEWISAK (赞：1)

给一个我认为比较显然的做法（

[广告](https://www.cnblogs.com/lewisak)

##### 题目大意

给定一张DAG，定义一次操作为从任意点出发，不断前进直到到达出度为 $0$ 的点，标记沿途经过的边，求标记所有边的最小操作次数。

##### 题解

注意到所有边都要至少经过一次，考虑上下界网络流。

对于所有点 $i$ 连 $s\to i$ 费用为 $1$（飞机的降落），流量无限制，$i\to t$ 费用为 $0$，流量无限制（停止滑雪），对于原图的边 $u\to v$ 连 $u\to v$ 下界为 $1$（雪道至少被经过一次），费用为 $0$，上界无限制。

跑有源汇上下界最小费用可行流即可。

##### 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
namespace kong{bool st;}
namespace zhu{
int tot=1,head[1001000],n,m,s,t,ys,yt,liu[1001000],all,nb,answ,ansc,vis[1001000],dis[1001000],h[1001000],ans=0;
queue<int> q;
struct node{
	int v,id;
	bool operator<(const node& a)const{
		return v>a.v;
	}
};
priority_queue<node> qq;
struct{
	int nxt,to,w,c;
}e[2002000],fr[2002000];
void add(int u,int v,int w,int c){
	e[++tot]={head[u],v,w,c};
	head[u]=tot;
	e[++tot]={head[v],u,0,-c};
	head[v]=tot;
	return;
}
void spfa(){
	while(!q.empty()) q.pop();
	memset(vis,0,sizeof vis);
	memset(h,0x3f,sizeof h);
	h[s]=0;vis[s]=1;
	q.push(s);
	while(!q.empty()){
		int x=q.front();
		q.pop();
		vis[x]=0;
		for(int i=head[x];i;i=e[i].nxt){
			int v=e[i].to,c=e[i].c;
			if(e[i].w&&h[v]>h[x]+c){
				h[v]=h[x]+c;
				if(vis[v]) continue;
				vis[v]=1;
				q.push(v);
			}
		}
	}
}
bool dij(){
	while(!qq.empty()) qq.pop();
	for(int i=1;i<=n+4;i++) vis[i]=0,dis[i]=1e18;
	dis[s]=0;
	qq.push({0,s});
	while(!qq.empty()){
		int x=qq.top().id;
		qq.pop();
		if(vis[x]) continue;
		vis[x]=1;
		for(int i=head[x];i;i=e[i].nxt){
			int v=e[i].to,w=e[i].c+h[x]-h[v];
			if(e[i].w&&dis[v]>dis[x]+w){
				dis[v]=dis[x]+w;
				fr[v].nxt=i;
				fr[v].to=x;
				if(!vis[v]) qq.push({dis[v],v});
			}
		}
	}
	return dis[t]!=1e18;
}
void PD(){
	answ=ansc=0;
	spfa();
	while(dij()){
		int minn=1e18;
		for(int i=1;i<=n+4;i++){
			h[i]+=dis[i];
		}
		for(int i=t;i!=s;i=fr[i].to){
			minn=min(minn,e[fr[i].nxt].w);
		}
		for(int i=t;i!=s;i=fr[i].to){
			e[fr[i].nxt].w-=minn;
			e[fr[i].nxt^1].w+=minn;
		}
		answ+=minn;
		ansc+=minn*h[t];
	}
}
string main(){
	cin>>n;
	ys=n+1,yt=ys+1,s=yt+1,t=s+1;
	for(int i=1;i<=n;i++){
		int t;
		cin>>t;
		while(t--){
			int x;
			cin>>x;
			liu[i]--;liu[x]++;
			add(i,x,1e18,0);
		}
		add(i,yt,1e18,0);
		add(ys,i,1e18,1);
	}
	add(yt,ys,1e18,0);
	for(int i=1;i<=yt;i++){
		if(liu[i]>0){
			add(s,i,liu[i],0);
			all+=liu[i];
		}
		else if(liu[i]<0){
			add(i,t,-liu[i],0);
		}
	}
	PD();
	cout<<ansc<<'\n';
	return "呜呜呜呜最小费用怎么你了";
}
}
namespace kong{bool ed;double MB(){return (&st-&ed)/1048576.0;}}
signed main(){
	cerr<<zhu::main()<<' '<<kong::MB();
	return 0;
}
```

---

## 作者：MoonCake2011 (赞：1)

因为每条雪道必须被清理一次，并且可以被清理无限次，所以考虑上下界网络流。

首先，建立超级源点，向每个点连一条下界为 $0$，上界为无限大的边。

对于每个斜坡，可以连一条下界为 $1$，上界为无限大的边。

建立超级汇点，每个点向汇点连一条下界为 $0$，上界为无限大的边。

然后求上下界最小流即可。

```cpp
//Dinic 算法  
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,m,s,t,S,T;
int head[10010],to[20010],nxt[20010],val[20010],tot=1;
void add(int u,int v,int w){
	to[++tot]=v,val[tot]=w;
	nxt[tot]=head[u];
	head[u]=tot;
}
int maxflow,dis[10010],now[10010];
bool vis[10010];
bool bfs(){
	queue<int>q;
	memset(vis,0,sizeof vis);
	vis[s]=1,dis[s]=0,now[s]=head[s];
	q.push(s);
	while(!q.empty()){
		int u=q.front();
		q.pop();
		for(int i=head[u];i;i=nxt[i]){
			if(vis[to[i]] || !val[i]) continue;
			now[to[i]]=head[to[i]];
			dis[to[i]]=dis[u]+1,vis[to[i]]=1;
			q.push(to[i]);
			if(to[i]==t) return 1;
		}
	}
	return 0;
}
int dinic(int x,int flow){
	if(x==t) return flow;
	int rest=flow;
	for(int i=now[x];i && rest;i=nxt[i]){
		now[x]=i;
		if(dis[to[i]]!=dis[x]+1 || !val[i]) continue;
		int v=dinic(to[i],min(rest,val[i]));
		if(!v) dis[to[i]]=0;
		val[i]-=v,val[i^1]+=v;
		rest-=v;
	}
	return flow-rest;
}
int V[100010];
signed main() {
	cin>>n;
	S=0,T=n+1;
	s=n+2,t=n+3;
	for(int i=1;i<=n;i++){
		add(S,i,1e15),add(i,S,0);
		add(i,T,1e15),add(T,i,0);
		int k;
		cin>>k;
		for(int j=1;j<=k;j++){
			int x;
			cin>>x;
			add(i,x,1e15-1),add(x,i,0);
			V[i]--,V[x]++;
		}
	}
	int sum=0;
	for(int i=1;i<=n;i++) if(V[i]>0) add(s,i,V[i]),add(i,s,0),sum+=V[i];else if(V[i]<0) add(i,t,-V[i]),add(t,i,0);
	add(T,S,1e15),add(S,T,0);
	int flow=0;
	while(bfs()) while(flow=dinic(s,1e18)) maxflow+=flow;
	if(maxflow<sum) cout<<"No solution.";
	else{
		s=T,t=S;
		int ans=val[tot];
		val[tot]=val[tot^1]=0;
		maxflow=0;
		while(bfs()) while(flow=dinic(s,1e18)) maxflow+=flow;
		cout<<ans-maxflow;
	}
	return 0;
}
```

---

## 作者：Chenyichen0420 (赞：1)

## 思路分析

一眼网络流，建模也容易：如果有一条 $(s,t)$ 的边，就在二者之间建一条下界为 $1$ 的边。

然后将所有入度为 $0$ 的边视为源点，各从超级源点 $s$ 那里牵一条无限流过来。

将所有出度为 $0$ 的边视为汇点，各向超级汇点 $t$ 那里连一条无限流过去。

最后跑一个上下界最小流就行了。代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
constexpr int inf = 1e12;
int n, m, s, t, rd[205], sm, ans, lv[205], ys, yt, tr[205], tc[205];
struct ULBNF {
	struct node { int p, f, v; }tmp; //强制兼容费用流了，先不管吧
	vector<node>e; vector<int>h[205];
	inline void ins(int l, int r, int f, int v) {
		h[l].emplace_back(e.size());
		tmp.p = r; tmp.f = f; tmp.v = v;
		e.emplace_back(tmp);
		h[r].emplace_back(e.size());
		tmp.p = l; tmp.f = 0; tmp.v = -v;
		e.emplace_back(tmp);
	}
	inline void dellast(int l, int r) {
		h[l].pop_back(); e.pop_back();
		h[r].pop_back(); e.pop_back();
	}
	inline void del(int p) { h[p].clear(); }
	int d[205]; bool vis[205];
	inline bool bfs() {
		memset(vis, 0, sizeof vis);
		vis[s] = d[s] = 1;
		queue<int>q; q.push(s);
		while (q.size()) {
			int tp = q.front();q.pop();
			for (int i = 0;i != h[tp].size();++i) {
				node& sp = e[h[tp][i]];
				if (!vis[sp.p] && sp.f)
					d[sp.p] = d[tp] + 1,
					vis[sp.p] = 1, q.push(sp.p);
			}
		}
		return vis[t];
	}
	int cur[205];
	inline int dfs(int p, int a) {
		if (p == t || a == 0)  return a; int ret = 0, f;
		for (int& i = cur[p]; i != h[p].size(); ++i) {
			node& sp = e[h[p][i]];
			if (d[sp.p] == d[p] + 1 && (f = dfs(sp.p, min(a, sp.f))) > 0) {
				sp.f -= f; e[h[p][i] ^ 1].f += f;
				ret += f; if ((a -= f) == 0) break;
			}
		}
		return ret;
	}
	inline bool dneflow(int sm) {
		ans = 0;
		while (bfs())
			fill(cur, cur + n + 4, 0),
			ans += dfs(s, 1e15);
		return ans != sm;
	}
	inline int maxflow() {
		while (bfs())
			fill(cur, cur + n + 4, 0),
			ans += dfs(s, 1e15);
		return ans;
	}
	inline int minflow() {
		while (bfs())
			fill(cur, cur + n + 4, 0),
			ans -= dfs(s, 1e15);
		return ans;
	}
}net; //upper-lower bound network flow
signed main() {
	ios::sync_with_stdio(0); cin >> n;
	ys = n + 1; yt = n + 2; s = n + 3; t = n + 4;
	for (int i = 1, c, p;i <= n;++i)
		for (cin >> c;c;c--)
			cin >> p, net.ins(i, p, inf, 0),
			rd[i]--, rd[p]++, tc[i]++, tr[p]++;
	for (int i = 1;i <= n;++i)
		if (!tr[i]) net.ins(ys, i, inf, 0);
	for (int i = 1;i <= n;++i)
		if (!tc[i]) net.ins(i, yt, inf, 0);
	for (int i = 1;i <= yt;++i)
		if (rd[i] > 0) sm += rd[i], net.ins(s, i, rd[i], 0);
		else if (rd[i]) net.ins(i, t, -rd[i], 0);
	net.ins(yt, ys, 1e15, 0); net.dneflow(sm);
	ans = net.e.back().f;
	net.dellast(yt, ys); t = ys, s = yt;
	cout << net.minflow() << endl;
}
```

---

## 作者：xxseven (赞：1)

上课的时候没学好上下界流，于是用费用流同样通过了这道题。

一般我们在使用费用流时，是**用流量来刻画限制，费用来求最优解**。本题中，限制为 $m$ 条边都至少经过一次，贡献的合并使用的是加法，无法使用流量刻画，反倒类似费用的运算。

既然如此，考虑使用费用刻画限制。第一次经过边的费用为 $1$，其余时候为 $0$，可以使用拆点实现。跑**最大费用流**，这样满足限制时费用必定为 $m$，且满足限制前每条增广路的流量都为 $1$。

增广路算法求费用流采用的是贪心思想，对于每个流量都会求出其最大的费用。因此取第一个费用为 $m$ 的流量即为所求答案。

核心代码如下：

```cpp
const int inf=1e9;
void add(int x,int y,int z,int c){
	path[++idx].val=z;
	path[idx].to=y;
	path[idx].cost=c;
	path[idx].nxt=head[x];
	head[x]=idx;
}
void _add(int x,int y,int z,int c){
	add(x,y,z,-c); add(y,x,0,c);//求最大费用，将边权取反
}
int EK(){
	int cost=0,num=0;
	while(cost!=m){ //不停增广直至所有边都被经过
		spfa();
		int mn=inf;
		for(int i=t;i!=s;i=pre[i].v){
			mn=min(mn,path[pre[i].id].val);
		}
		for(int i=t;i!=s;i=pre[i].v){
			path[pre[i].id].val-=mn;
			path[pre[i].id^1].val+=mn;
		}
		cost-=mn*dis[t]; num+=mn;
	}
	return num;
}
int main(){
	ios_base::sync_with_stdio(false);
	cin.tie(0); cout.tie(0);
	cin>>n; int cnt=n+2; s=n+1,t=n+2;
	for(int y,i=1;i<=n;++i){
		cin>>y; m+=y;
		if(y==0) _add(i,t,inf,0);
		for(int x,j=1;j<=y;++j){
			cin>>x; deg[x]++;
			_add(i,cnt+1,inf,0);
			_add(cnt+1,cnt+2,1,1);
			_add(cnt+1,cnt+2,inf,0); //拆点，区分首次经过和其余经过
			_add(cnt+2,x,inf,0);	
			cnt+=2;	
		}
	}
	for(int i=1;i<=n;++i) {
		if(deg[i]==0) _add(s,i,inf,0);
	}
	cout<<EK();
	return 0;
}

```

希望这篇题解能够帮到你！

---

## 作者：Chr0n1CleC (赞：1)

## 基础建图

题目描述 : 给出一个DAG，每次你要选择多条路径，使得每条边至少出现一次，求最少的路径数量。

看到至少，想到上下界网络流，于是建边就出来了：

- $(s,u,0,\infty)$ 代表的是 $u$ 是路径的起点。

- $(u,t,0, \infty)$ 代表的是 $u$ 是路径的终点。

- $(u,v,1, \infty)$ 代表的是每一条边只经过一次。

大部分人都是去套了一遍板子，但实际上不用，因为我们可以手动地找一组可行流。

## 手动可行流

首先先把上下界图改造为汇源网络流图：

- $(s,u,\infty)$

- $(u,t,\infty)$

- $(u,v,\infty - 1)$

- $(s',v,1)$

- $(u,t',1)$

- $(t,s,\infty)$

这时候发现我们能很容易手动流出一个最大流，因为有一个明显的增广路：$s',v,t,s,u,t'$ 。

然后我们手动地把这个图流一下，删去附加边，图就变成了：

- $(s,u,\infty - out_u)$

- $(u,s,out_u)$

- $(u,t,\infty - in_v)$

- $(t,u,in_u)$

- $(u,v,\infty)$

我们再根据这个图去跑一遍最大流。因为源汇上下界网络流的最小流等于可行流减去 $t-s$ 的最大流，所以我们就把边数减去这个图的最大流就是答案了。

code:

``` cpp

#include<cstdio>
#include<algorithm>
#include<queue>
using namespace std;

const int N = 1009, inf = 1e9;

struct node
{
	int v, w, nxt;
}e[N * 1000];

int head[N], cnt = 1, now[N], dep[N], ss, tt, s, t, n;

void add(int u, int v, int w)
{
	e[++ cnt] = {v, w, head[u]}, head[u] = cnt;
}

void ADD(int u, int v, int w, int p = 0)
{
	add(u, v, w), add(v, u, p); 
}

bool bfs()
{
	for (int i = 0;i <= 2 * n + 1;++ i)
		now[i] = head[i], dep[i] = 0;
	queue < int > q;
	q.push(t);
	dep[t] = 1;
	while (!q.empty())
	{
		int u = q.front();
		q.pop();
		for (int i = head[u], v;i;i = e[i].nxt)
		{
			v = e[i].v;
			if (e[i ^ 1].w && !dep[v])
				dep[v] = dep[u] + 1, q.push(v);
		}
	}
	return dep[s];
}

int dfs(int u, int flow)
{
	if (u == t)
		return flow;
	int lim = flow;
	for (int i = now[u], v, w, k;i && flow;i = e[i].nxt)
	{
		now[u] = i, v = e[i].v, w = e[i].w;
		if (w && dep[u] == dep[v] + 1)
			k = dfs(v, min(flow, w)), flow -= k, e[i].w -= k, e[i ^ 1].w += k;
	}
	return lim - flow;
}

int in[N];

int main()
{
	scanf("%d", &n);
	ss = 0, tt = n + 1;
	t = ss, s = tt;
	int ans = 0;
	for (int i = 1, l, x;i <= n;++ i)
	{
		scanf("%d", &l);
		ans += l;
		ADD(ss, i, inf - l, l);
		while (l --)
			scanf("%d", &x), ADD(i, x, inf - 1), ++ in[x];
	}
	for (int i = 1;i <= n;++ i)
		ADD(i, tt, inf - in[i], in[i]);
	while (bfs())
		ans -= dfs(s, 1e9);
	printf("%d\n", ans);
	
	return 0;
}

```

## 总结

这道题主要的精髓：

- 至少想到上下界，求最少想到上下界最小流

- 发现图比较特殊就手动找可行流

---

## 作者：mjsdnz (赞：1)

+ [原题连接](https://www.luogu.com.cn/problem/P4843)

## 基础

1. 网络流（不会的可以搜索，或者看看本蒟蒻的 [blog](https://mjsdnz.github.io/2023/05/05/%E7%BD%91%E7%BB%9C%E6%B5%81/)，这里略过）
2. 上下界网络流相关问题（这个不会没有关系，我下面讲）

## 建模

一到比较裸的有源汇上下界最小流。每条边必走一次，要求求出最小的流量。由于比较裸，这里当作上下界流的例题讲。

## 什么是有源汇上下界最小流

顾名思义，就是在最大流的基础上增加了边的最小经过流量，使得整个网络可行，并且找出最小流量的方案。为了简化问题，我们先从无源汇上下界可行流说起。

### 求解无源汇可行流

一个比较朴实的想法就是将一个边的最大限制减去最小限制，跑最大流即可。但是该方法并不满足流量守恒定律，因此做出一下调整。

我们在图中新建两个虚拟点，设置为新的虚拟源汇点 $S$、$T$。设 $d_u$ 为点 $u$ 所有入度边中的流量下限与所有出度中的流量下限之差。接下来我们对 $d_u$ 与 $0$ 的大小关系进行分类讨论。

+ 若 $d_u>0$ 则将该点与新源点 $S$ 连接，流量为 $d_u$。
+ 若 $d_u<0$ 则将该点与新汇点 $T$ 连接，流量为 $-d_u$。
+ 若 $d_u=0$，我们不需要考虑，反正不管怎么连流量都是 $0$。

为什么要这么连呢，我们可以分析一下网络流的过程，由于我们直接连接的是流量上限 $r$ 与 流量下限 $l$ 的差作为该边的流量的，这会导致本来可以在 $l$ 以内退流退掉的流量被清空了（可以回忆一下找增广路的退流过程）。我们对某一点 $u$ 的所有 $l$ 情况进行汇总，记录一个 $d_u$ 来表示所有入度边中的流量下限与所有出度中的流量下限之差，可以理解为判断该点在总体上是流入还是流出，以此来弥补未能正确退流的流量。

注意：在原图中的原来的源汇点也需要与新的源汇点进行连接。

### 有源汇上下界可行流

有无源汇的最大区别就是源汇点是否满足流量守恒，我们在处理无源汇问题的时候不需要考虑源汇点的流量是否守恒，默认源点能无限产生，汇点能无限吸收。但在有源汇问题中考虑了源汇点的流量守恒性，不过处理起来也非常简单，我们只要让源汇点并入网络，也就是让汇点向源点连一条流量为无穷的边即可。

### 有源汇上下界最大流

这个其实也很好处理，在跑完一边有源汇上下界可行流之后记录当前的最大流量（即汇点向源点的流量），判断一下当前网络流是否为满流，若不是，则无解，否这断开汇点向源点的边，跑一次无源汇上下界可行流，答案即为当前流加上之前记录的最大流。

### 有源汇上下界最小流

和最大流类似，只不过是先处理无源汇上下界可行流，此时就已经将该网络中的所以增广路全部跑满，然后再连接汇点向源点的边，此时的最大流便是满足上下界要求的最小流。

## Code

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 110;
const int M = 2e4 + 10;
const int inf = 0x3f3f3f3f;
int cnt = 1;
int head[N];
vector<int>g[N];
struct edge
{
    int u, v, c, val, nxt;
    edge(int u = 0, int v = 0, int c = 0, int val = 0, int nxt = 0) : u(u), v(v), c(c), val(val), nxt(nxt) {}
} e[M];
void ADD(int u, int v, int c, int val)
{
    cnt++;
    e[cnt] = edge(u, v, c, val, head[u]);
    head[u] = cnt;
}
void add_edge(int u, int v, int c, int val)
{
    ADD(u, v, c, val);
    ADD(v, u, 0, -val);
}
int d[N];
void add_limit(int u, int v, int l, int r)
{
    add_edge(u, v, r - l, 0);
    d[u] -= l;
    d[v] += l;
}
int n;
int dep[N];
int now[N];
bool vis[N];
int s, t;
bool bfs()
{
    memset(dep, 0, sizeof dep);
    dep[s] = 1;
    queue<int> q;
    q.push(s);
    while (!q.empty())
    {
        int u = q.front();
        now[u] = head[u];
        q.pop();
        for (int i = head[u]; i; i = e[i].nxt)
        {
            int v = e[i].v;
            int c = e[i].c;
            if (dep[v] || !c)
                continue;
            dep[v] = dep[u] + 1;
            q.push(v);
        }
    }
    return dep[t] != 0;
}
int dfs(int u, int flow)
{
    if (u == t)
        return flow;
    vis[u] = 1;
    int nowflow = 0;
    for (int i = now[u]; i && nowflow < flow; i = e[i].nxt)
    {
        now[u] = i;
        int v = e[i].v;
        int c = e[i].c;
        if (dep[v] != dep[u] + 1 || !c || vis[v])
            continue;
        int ff = dfs(v, min(flow - nowflow, c));
        if (ff)
            nowflow += ff, e[i].c -= ff, e[i ^ 1].c += ff;
        else
            dep[v] = inf;
    }
    vis[u] = 0;
    return nowflow;
}
int maxflow()
{
    int ans = 0;
    while (bfs())
    {
        int nowflow;
        while ((nowflow = dfs(s, inf)))
            ans += nowflow;
    }
    return ans;
}
int main()
{
    cin >> n;
    int ss = n + 1, tt = n + 2;
    s = n + 3, t = n + 4;
    for (int i = 1; i <= n; i++)
    {
        add_limit(ss, i, 0, inf);
        add_limit(i, tt, 0, inf);
        int k;
        cin >> k;
        for (int j = 1; j <= k; j++)
        {
            int v;
            cin >> v;
            add_limit(i, v, 1, inf);
        }
    }

    for (int i = 1; i <= tt; i++)
    {
        if (d[i] > 0)
            add_edge(s, i, d[i], 0);
        else if (d[i] < 0)
            add_edge(i, t, -d[i], 0);
    }
    maxflow();
    add_limit(tt, ss, 0, inf);
    maxflow();
    cout << e[cnt].c;
}
```

---

## 作者：ollo (赞：1)

# 题目大意

有一张有向图 $G(n, m)$，每次都可以从任意一个点出发沿一条路径行走。问要使每条边至少遍历一遍的最少出发次数。

# 思路

首先，对于从每个点出发的限制显然可以虚拟一个超级节点 $0$ 往每个点连边，此时问题变成了从零出发要使原图中每条边都被遍历一遍的的最小出发次数。考虑上下界网络流。令原图中每条边为 $(u, v, 1, \infty)$，虚拟边为 $(0, i, 0, \infty)$，此时问题就变成了板的上下界最小流。

然后怎么写上下界最小流？常规做法是二分答案然后跑可行流。但这里有更好的做法。参考有源汇上下界可行流的想法，在原有的 $s, t$ 外再建一对 $S, T$，先不连 $S, T$ 跑最大流，然后连边 $(S, T, 0, \infty)$，此时的**残量网络**的最大流中 $(S, T)$ 的流量就是最小流。

# 代码

```cpp
#include<bits/stdc++.h>
#define int long long

using namespace std;

const int inf = 1e9, N = 110, E = 2e5 + 10;

struct S{
	int to, nxt, edge;
}a[E];
int head[N], tot;
int d[N];

void add(int u, int v, int c){
	a[++tot].to = v;
	a[tot].edge = c;
	a[tot].nxt = head[u];
	head[u] = tot;
	a[++tot].to = u;
	a[tot].edge = 0;
	a[tot].nxt = head[v];
	head[v] = tot;
	return ;
}
void Add(int u, int v, int l, int r){
	add(u, v, r - l);d[u] -= l;d[v] += l;
}

int in[N], pre[N];
bool vis[N];
int level[N];
int n, m, t, s, S, T;

bool bfs(){
	memset(level, 0, sizeof(level));
	queue<int> q;
	q.push(S);
	level[S] = 1;
	while(!q.empty()){
		int x = q.front();
		q.pop();
		for(int i = head[x]; i; i = a[i].nxt){
			int c = a[i].edge, y = a[i].to;
			if(c && !level[y]){
				q.push(y);
				level[y] = level[x] + 1;
				if(y == T) return 1;
			}
		}
	}
	return 0;
}

int maxflow, flow;

int Dinic(int x, int flow){
	if(x == T) return flow;
	int rest = flow, in = 0;
	for(int i = head[x]; i && rest; i = a[i].nxt){
		int y = a[i].to;
		if(a[i].edge && level[y] == level[x] + 1){
			int in = Dinic(y, min(rest, a[i].edge));
			if(in == 0) level[y] = 0;
			else{
				a[i].edge -= in;
				a[i ^ 1].edge += in;
				rest -= in;
			}
		}
	}
	return flow - rest;
}
inline int read(){
    int s = 0, f = 0; char ch = getchar();
    while(!isdigit(ch)){if(ch == '-') f = 1; ch = getchar();}
    while(isdigit(ch)) s = s * 10 + ch - 48, ch = getchar();
    return f ? ~s + 1 : s;
}
signed main(){
	n = read();
	s = n + 1;t = n + 2;S = n + 3;T = n + 4;
	memset(head, 0, sizeof(head));
	tot = 1;
	maxflow = 0;
	for(int i = 1; i <= n; i++){
		m = read();
		Add(s, i, 0, inf);
		Add(i, t, 0, inf);
		for(int j = 1, to; j <= m; j++){
			to = read();
			Add(i, to, 1, inf);
		}
	}
	for(int i = 1; i <= t; i++){
		if(d[i] > 0) add(S, i, d[i]);
		else if(d[i] < 0) add(i, T, -d[i]);
	}
	while(bfs() == true) while(Dinic(S, inf));
	Add(t, s, 0, inf);
	while(bfs() == true) while(Dinic(S, inf));
	cout << a[tot].edge;
	return 0;
}
```

---

## 作者：7KByte (赞：1)

根据题意我们可以非常容易推出上下界最小流的模型。

即每条雪道流量下界为 $1$ ，其他边下界为 $0$ 。所有边上界为 $inf$ 。

然后跑最小流即可。

但是谁来教我最小流怎么跑 /kel 。

最小流不能直接跑，我们需要将问题转换一下。

比较套路的做法就是二分答案，这样问题转换为判定。判定直接有源汇上下界可行流即可。直接套模板。

```cpp
#include<bits/stdc++.h>
#define rep(i,a,b) for(int i=a;i<=b;i++)
#define pre(i,a,b) for(int i=a;i>=b;i--)
#define N 505
using namespace std;
int h[N],tot=1,in[N],s,t;
struct edge{
	int to,nxt,cap;
}e[N*N];
void add(int x,int y,int z){
	if(!z)return;
	e[++tot].nxt=h[x];h[x]=tot;e[tot].to=y;e[tot].cap=z;
	e[++tot].nxt=h[y];h[y]=tot;e[tot].to=x;e[tot].cap=0;
}
int sum;
void add(int x,int y,int l,int r){
	in[x]-=l;in[y]+=l;
	add(x,y,r-l);
}
int d[N],cur[N];queue<int>q;
bool bfs(){
	memset(d,0,sizeof(d));
	d[s]=1;q.push(s);
	while(!q.empty()){
		int x=q.front();q.pop();cur[x]=h[x];
		for(int i=h[x];i;i=e[i].nxt)if(e[i].cap&&!d[e[i].to]){
			d[e[i].to]=d[x]+1;q.push(e[i].to);
		}
	}
	return d[t]?true:false;
}
int dfs(int x,int flow){
	if(x==t)return flow;
	int res=flow;
	for(int &i=cur[x];i;i=e[i].nxt)if(e[i].cap&&d[e[i].to]==d[x]+1){
		int now=dfs(e[i].to,min(e[i].cap,res));
		if(!now)d[e[i].to]=0;
		e[i].cap-=now;e[i^1].cap+=now;res-=now;
		if(!res)return flow;
	}
	return flow-res;
}
int S,T,n;
vector<int>u[N];
const int inf = 1e9;
bool calc(){
	int hav=0;
	rep(i,1,T)if(in[i]>0)add(s,i,in[i]),hav+=in[i];else add(i,t,-in[i]);
	while(bfs())hav-=dfs(s,inf);
	if(hav)return false;return true;
}
bool check(int mid){
	memset(in,0,sizeof(in));
	memset(h,0,sizeof(h));tot=1;sum=0;
	S=n*2+1,T=S+1;s=T+1;t=s+1;
	rep(i,1,n)add(i,i+n,0,inf),add(S,i,0,inf),add(i+n,T,0,inf);
	rep(x,1,n){
		for(int i=0;i<(int)u[x].size();i++){
			int y=u[x][i];add(x+n,y,1,inf);
		}
	}
	add(T,S,0,mid);
	return calc();
}
int main(){
	scanf("%d",&n);
	int l=1,r=0,ans;
	rep(i,1,n){
		int cnt;scanf("%d",&cnt);
		r+=cnt;
		rep(j,1,cnt){
			int x;scanf("%d",&x);
			u[i].push_back(x);
		}
	}
	while(l<=r){
		int mid=(l+r)>>1;
		if(check(mid))r=mid-1,ans=mid;
		else l=mid+1;
	}
	printf("%d\n",ans);
	return 0;
} 
```

---

## 作者：liangzihao (赞：1)

题意是寻找一个DAG的最小边覆盖。

我们首先考虑把边看做点，跑最小路径覆盖。因为边很多（可能有$n^2$条），点可以重复走，即使网络流不T，跑传递闭包也会T。复杂度为$O(m^3)$。

所以我们考虑直接对原图跑网络流。

建立一个$S$向每个点连$inf$流量的边（表示可以从任意一点开始），每个点向$T$连$inf$流量的边（表示可以从任意一点结束）。原图的每条边要至少走一遍，也就是流量为$[1,inf)$。直接最小流即可（其实这是最小流的模板题）。

代码：

```
#include <iostream>
#include <cstdio>
#include <cmath>
#include <queue>
#include <cstring>

const int maxn=207;
const int maxe=maxn*maxn*5;
const int inf=0x3f3f3f3f;

using namespace std;

int n,tot,x,cnt,s,t,sum,ans;
int ls[maxn],deg[maxn],dis[maxn];

struct edge{
    int y,w,op,next;
}g[maxe];

queue <int> q;

void add(int x,int y,int w)
{
    g[++cnt]=(edge){y,w,cnt+1,ls[x]};
    ls[x]=cnt;
    g[++cnt]=(edge){x,0,cnt-1,ls[y]};
    ls[y]=cnt;
}

bool bfs()
{   
    memset(dis,inf,sizeof(dis));
    q.push(s);
    dis[s]=0;  
    while (!q.empty())
    {
        int x=q.front();
        q.pop();
        for (int i=ls[x];i>0;i=g[i].next)
        {
            int y=g[i].y;
            if ((g[i].w) && (dis[y]>dis[x]+1))
            {
                dis[y]=dis[x]+1;
                q.push(y);
            }
        }
    }
    return (dis[t]!=inf);
}

int dfs(int x,int maxf)
{
    if ((x==t) || (!maxf)) return maxf;
    int ret=0;
    for (int i=ls[x];i>0;i=g[i].next)
    {
        int y=g[i].y;
        if ((g[i].w) && (dis[y]==dis[x]+1))
        {
            int f=dfs(y,min(maxf-ret,g[i].w));
            if (!f) dis[y]=-1;
            ret+=f;
            g[i].w-=f;
            g[g[i].op].w+=f;
        }
    }
    return ret;
}

int dinic()
{
    int flow=0;
    while (bfs()) 
      flow+=dfs(s,inf);
    return flow;
}

int main()
{
    scanf("%d",&n);
    for (int i=1;i<=n;i++)
    {
        scanf("%d",&tot);
        for (int j=1;j<=tot;j++)
        {
            scanf("%d",&x);
            add(i,x,inf-1);
            deg[i]--;
            deg[x]++;
        }
    }	  
    int S=n+1,T=n+2,SS=n+3,TT=n+4;
    for (int i=1;i<=n;i++)
    {
        add(S,i,inf);
        add(i,T,inf);
    }    
    int nowcnt=cnt;
    add(T,S,inf);
    for (int i=1;i<=n;i++)
    {
        if (deg[i]>0) add(SS,i,deg[i]),sum+=deg[i];
        else if (deg[i]<0) add(i,TT,-deg[i]);
    }
    s=SS,t=TT;
    dinic();
    ans=g[nowcnt+2].w;
    for (int i=nowcnt+1;i<=cnt;i++) g[i].w=0;    
    s=T,t=S;
    ans-=dinic();
    printf("%d",ans);
}
```

---

## 作者：Aleph_Drawer (赞：0)

翻来覆去思考为什么这题能够有紫。一个大脑已经被文化课搞得呆滞的人多看几眼就会了，该好好反思一下。

给一个很一眼的做法，无需上下界。时间复杂度不保证最优。

---

优先考虑转化问题，考虑二分答案，问题变为

> 是否能用 $mid$ 条路径覆盖全部边。

由于可以重复经过边，一个**经典**的建模思路就是对于原图上的一条边 $(u, v)$ 连（四项参数分别为边的起点、终点、流量、费用）：

- $(u, v, 1, 1)$；
- $(u, v, +\inf, 0)$。

将源点和汇点用你喜欢的方法接入这个图（全部连接也可以），同时利用边限制图内的总流量为 $mid$，并跑**最大费用最大流**。每一次二分的检查就是检查跑出来的费用是否为边的数量的总和。

随便写写，跑几下，过了，很快啊！[提交记录](https://www.luogu.com.cn/record/166240428)。

时间复杂度分析，若将一次费用流的时间看为 $A$，则时间复杂度为 $\mathcal O(A \cdot \log n)$。

---


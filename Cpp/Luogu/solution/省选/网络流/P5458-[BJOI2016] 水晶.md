# [BJOI2016] 水晶

## 题目背景

不用惊慌，今天的题都不是小强出的。  

——融入了无数心血的作品，现在却不得不亲手毁掉，难以体会他的心情啊。

——那也是没有办法的事情，能量共振不消除的话…… 

望着已经被装上炸药的水晶，02放下了望远镜，看向了手中的共振分析报告。  

还是会有一些水晶，幸存下来的…… 也许吧。

## 题目描述

地图由密铺的六边形单元组成，每个单元与其他六个单元相邻。  

为了方便起见，我们用坐标 $(x,y,z)$ 描述一个单元的位置，表示从原点开始按如图所示的 $x,y,z$ 方向各走若干步之后到达的地方。  

有可能有两个坐标描述同一个单元，比如 $(1,1,1)$ 和 $(0,0,0)$ 描述的都是原点。

![](https://cdn.luogu.com.cn/upload/image_hosting/dd1hb5vv.png)

显然 $(x,y,z)$ 单元和 $(x+1,y,z)$，$(x-1,y,z)$ ，$(x,y+1,z)$，$(x,y-1,z)$，$(x,y,z+1)$，$(x,y,z-1)$ 相邻。  

有 $N$ 块水晶位于地图的单元内，第 $i$ 块水晶位于坐标 $(x_i, y_i, z_i)$ 所表示的单元中，并拥有 $c_i$ 的价值，每个单元内部可能会有多块水晶。  

地图中，有一些单元安装有能量源。如下图，任何满足 $x+y+z$ 是 $3$ 的整数倍的坐标所描述的单元内都安装有能量源。  

![](https://cdn.luogu.com.cn/upload/image_hosting/9x4o6dhs.png)

有能量源的单元中的水晶价值将会额外增加 $10\%$。如果三块水晶所在的单元满足特定排列，那么它们将会引发共振。 

共振分两种，$a$ 共振和 $b$ 共振。  

$a$ 共振：如果三块水晶所在的单元两两相邻地排成一个三角形，那么会引起 $a$ 共振。   

![](https://cdn.luogu.com.cn/upload/image_hosting/48uc3ey4.png)

图中每一个三角形表示这三个单元各有一块水晶将会发生一个 $a$ 共振。  

$b$ 共振：如果三块水晶所在的单元依次相邻地排成一条长度为 $2$ 的直线段，且正中间的单元恰好有能量源，那么会引起b共振。  

![](https://cdn.luogu.com.cn/upload/image_hosting/2b47zl09.png)

图中粉红色线段表示这三个单元各有一块水晶将会发生一个 $b$ 共振，黑色线段表示即使这三个单元有水晶也不会发生 $b$ 共振。  

现在你要炸掉一部分水晶，使得任何共振都不会发生的前提下，剩余水晶的价值总和最大。

## 说明/提示

【样例 $1$ 说明】   

四块水晶排成一个菱形，没有 $b$ 共振，有 $2$ 处 $a$ 共振，分别是 $1,2,4$ 号水晶和 $1,3,4$ 号水晶形成的三角形。 
因此，为了消除两处 $a$ 共振，有如下 $3$ 种方案：

1. 炸掉 $1$ 号水晶，留下 $2,3,4$ 号水晶，总剩余价值 $5+7+13=25$
2. 炸掉 $4$ 号水晶，留下 $1,2,3$ 号水晶，总剩余价值 $11 \times(1+10\%)+5+7=24.1$   
3. 炸掉 $2,3$ 号水晶，留下$1,4$ 号水晶，总剩余价值 $11 \times (1+10\%)+13=25.1$  

因此我们采用第三种方案，最大总剩余价值为$25.1$。    

【数据范围】  

$1\le N \le 50000$    
$1\le c_i \le 1000$   
$-1000 \le x_i,y_i,z_i \le 1000$   

## 样例 #1

### 输入

```
4
0 0 0 11
1 0 0 5
0 1 0 7
0 0 -1 13```

### 输出

```
25.1```

# 题解

## 作者：disangan233 (赞：9)

## 题意简述  
给你一个三维的坐标系，坐标系上 $(x_i+y_i+z_i)\bmod 3 = 0$ 的点内有能量源。给定 $n$ 个点含有能量值为 $c_i$ 的水晶，如果一个水晶位于能量源上，这个水晶的能量值将会提高 $10\%$。

水晶有两种共振情况，一是相邻的三个水晶共振，二是两个水晶在一条长度为 $2$ 的线段两端，且线段中点是能量源。

你可以炸掉一些水晶，请问没有共振之后剩余水晶的最大能量值。

## 做法 

对于 $(x_i+y_i+z_i)\bmod 3 \not = 0$ 的点黑白染色，如果一个能量源的周围同时存在黑白两种颜色的点，那么必定构成共振，如图所示

![1.png](https://i.loli.net/2019/07/05/5d1f276f6f7de40870.png) 

于是我们可以把 $\bmod 3$ 意义下的三种点分别拆点。考虑对于每个共振，要用最小代价破坏，显然是一个最小割的模型。把每个点拆点，边权为水晶的能量值 $c_i$ 。然后源点连 $1$ 的点，$1$ 连 $0$，$0$ 连 $2$，$2$ 连 汇点，答案为水晶的总能量 $\sum c_i$ 减最大流。这里给出代码实现：

```cpp
const int inf=1e9;
inline void link(int a,int b,int c)
{
	add_edge(S,a<<1,inf);add_edge(a<<1|1,b<<1,inf);
	add_edge(b<<1|1,c<<1,inf);add_edge(c<<1|1,T,inf);
}
```

然后我们用一个结构体来表示每一个点，将$(x_i,y_i,z_i)$转换为$(x_i-z_i,y_i-z_i)$，用一个向量的结构体来封存，重载`<`和`+`预算符，用一个`map`来对向量进行操作，本题就结束了。

## 代码实现

`map`常数大跑不快，但是很好写。

```cpp
#pragma GCC optimize(2,3,"Ofast","unroll-loops")
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define db double
#define in inline
#define re register
namespace fast_io
{
	char buf[1<<12],*p1=buf,*p2=buf,sr[1<<23],z[23],nc;int C=-1,Z=0,Bi=0,ny;
	in char gc() {return p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<12,stdin),p1==p2)?EOF:*p1++;}
	in ll read()
	{
		ll x=0;ny=1;while(nc=gc(),(nc<48||nc>57)&&nc!=EOF)if(nc==45)ny=-1;Bi=1;if(nc<0)return nc;
		x=nc-48;while(nc=gc(),47<nc&&nc<58&&nc!=EOF)x=(x<<3)+(x<<1)+(nc^48),Bi++;return x*ny;
	}
	in db gf() {int a=read(),y=ny,b=(nc!='.')?0:read();return (b?a+(db)b/pow(10,Bi)*y:a);}
	in int gs(char *s) {char c,*t=s;while(c=gc(),c<32);*s++=c;while(c=gc(),c>32)*s++=c;return s-t;}
	in void ot() {fwrite(sr,1,C+1,stdout);C=-1;}
	in void flush() {if(C>1<<22) ot();}
	template <typename T>
	in void write(T x,char t)
	{
		int y=0;if(x<0)y=1,x=-x;while(z[++Z]=x%10+48,x/=10);
		if(y)z[++Z]='-';while(sr[++C]=z[Z],--Z);sr[++C]=t;flush();
	}
	in void write(char *s) {int l=strlen(s);for(int i=0;i<l;i++)sr[++C]=*s++;sr[++C]='\n';flush();}
};
using namespace fast_io;
const int N=5e4+5,inf=1e9;
int n,m,h[N<<1],cnt=1,dis[N<<1],s,t,q[N<<1],l,r,cur[N<<1],tot,sum;
struct did{int next,to,f;}e[N*20];
in void add(re x,re y,re z)
{
	e[++cnt]=(did){h[x],y,z},h[x]=cnt;
	e[++cnt]=(did){h[y],x,0},h[y]=cnt;
}
const db eps=1e-9;
inline int bfs(re u)
{
	memset(dis,-1,sizeof(dis));dis[u]=0;
	l=r=0;q[++r]=u;
	while(l<r)
	{
		re i=q[++l]; if(i==t) return 1;
		for(re j=h[i],k;k=e[j].to,j;j=e[j].next)
		if(dis[k]<0&&e[j].f) dis[k]=dis[i]+1,q[++r]=k;
	}
	return 0;
}
in int dfs(re u,re maxf)
{
	re res=0;
	if(u==t||!maxf) return maxf;
	for(re &i=cur[u],v;v=e[i].to,i;i=e[i].next)
	if(e[i].f&&dis[v]==dis[u]+1)
	{
		re delta=dfs(v,min(maxf,e[i].f));
		e[i].f-=delta;e[i^1].f+=delta;
		res+=delta;maxf-=delta;
		if(!maxf) return res;
	}
	if (fabs(maxf-res)<eps) dis[u]=-2;
	return res;
}
inline int dinic()
{
	re ans=0;
	while(bfs(s)) memcpy(cur,h,sizeof(h)),ans+=dfs(s,inf);
	return ans;
}
struct poi //poipoi qwq~
{
	int x,y;
	poi (re a=0,re b=0) {x=a,y=b;}
	in bool operator < (poi a) const {return x==a.x?y<a.y:x<a.x;}
	in poi operator + (poi a) const {return poi(x+a.x,y+a.y);}
}p[N];
map<poi,int>mp,ext,f,book;
in void link(re a,re b,re c)
{
	if(!book[poi(s,a)]) add(s,a<<1,inf),book[poi(1,a)]=1;
	if(!book[poi(a,b)]) add(a<<1|1,b<<1,inf),book[poi(a,b)]=1;
	if(!book[poi(b,c)]) add(b<<1|1,c<<1,inf),book[poi(b,c)]=1;
	if(!book[poi(c,t)]) add(c<<1|1,t,inf),book[poi(c,a)]=1;
}
int main()
{
	n=read();
	for(re i=1;i<=n;i++)
	{
		re x=read(),y=read(),z=read(),c=read();
		p[i]=poi(x-z,y-z);if(!ext[p[i]]) ext[p[i]]=++tot;
		mp[p[i]]+=c;f[p[i]]=((x+y+z)%3==0);
	}
	s=1,t=tot+1<<1;
	for(re i=1;i<=n;i++) if(f[p[i]]<2)
	{
		re pt=ext[p[i]],ene=mp[p[i]]*(10+f[p[i]]);sum+=ene;
		add(2*pt,2*pt+1,ene);if(!f[p[i]]) {f[p[i]]=2;continue;}
		static int a[N],b[N];re na=0,nb=0;f[p[i]]=2;
		if(!(a[++na]=ext[p[i]+poi(0,1)])) na--;
		if(!(a[++na]=ext[p[i]+poi(1,0)])) na--;
		if(!(a[++na]=ext[p[i]+poi(-1,-1)])) na--;
		if(!(b[++nb]=ext[p[i]+poi(0,-1)])) nb--;
		if(!(b[++nb]=ext[p[i]+poi(-1,0)])) nb--;
		if(!(b[++nb]=ext[p[i]+poi(1,1)])) nb--;
		for(re x=1;x<=na;x++)
		for(re y=1;y<=nb;y++)
		link(a[x],pt,b[y]);
	}
	printf("%.1lf",(db)(sum-dinic())/10);
	return 0;
}
```

---

## 作者：CaoXian (赞：8)

最小割。

---

“有可能有两个坐标描述同一个单元”这一点很麻烦，注意到如果 $x$ 坐标、$y$ 坐标和 $z$ 坐标各增加 $1$ 那么它描述的单元不变，所以将三维转化为二维 $(x, y, z) \to (x - z, y - z)$，并且坐标也有唯一性了。

对于 a 共振，产生共振的三个单元中一定有一个是能量源单元，并且坐标数值之和在模 $3$ 的意义下 $0$，$1$，$2$ 正好各出现一次，这一点可以用鸽巢原理证明。

对于 b 共振，我们会发现它也有类似的情况。

于是直接将 a 共振和 b 共振一起考虑，所以产生共振的条件是：存在三个连通的单元，位于“中间”位置的单元的坐标数值之和模 $3$ 为 $0$，位于“两边”的单元的坐标数值之和模 $3$ 分别为 $1$ 和 $2$。

考虑如何消除共振。

按照上面描述的形式，将坐标数值之和模 $3$ 为 $2$ 的单元看作共振组合的第一个单元，模 $3$ 为 $0$ 的单元看作第二个单元，模 $3$ 为 $1$ 的单元看作第三个单元。

在它们之间依次连接有向边（$2 \to 0, 0 \to 1$），如果某个坐标数值之和模 $3$ 为 $2$ 的单元可以通过有向边走到模 $3$ 为 $1$ 的单元，那么肯定就会有一个共振组合。

而消除一个共振组合只需将其中一个单元删除即可，而题目要求剩下的单元价值总和最大，所以要贪心地删除其中价值最小的单元。

但是一个单元可能出现在多个共振组合中，简单的贪心就不起作用了。

而“贪心地删除三个单元中价值最小的单元”这样的描述很像最小割。如果把最小割当作一种反悔贪心来做的话就可以很好地处理共振组合“重叠”的情况了。

具体地，将每个单元拆点，分别为入点和出点，在其间连接一条容量为其价值的边。从坐标数值之和模 $3$ 为 $2$ 的单元向与其相邻的坐标数值之和模 $3$ 为 $0$ 的单元连接一条容量为 $\infty$ 的边，模 $3$ 为 $0$ 的点再向模 $3$ 为 $1$ 的点连边。

建立源点和汇点，源点向每个坐标数值之和模 $3$ 为 $2$ 的点连一条容量为 $\infty$ 的边，每个坐标数值之和模 $3$ 为 $1$ 的点向汇点连一条容量为 $\infty$ 的边。

跑最小割，此时被割掉的边只可能是每个点拆点过后在其间连的边（其余的边容量都为 $\infty$ 不可能被割），这就对应了删除单元格的情况。

跑完最小割后将满流的边删去，源点和汇点不连通，这也对应了不存在共振的情况。

对于存点，因为复杂度瓶颈在于 Dinic 的 $\mathcal{O}(n^{2}m)$，所以直接用 `map` 偷懒就行。

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
using flow_type = ll;
constexpr int inf = 1 << 30;
int St, Ed;
struct edge {
	int to;
	flow_type c;
	int pos;
	edge(int To = 0, flow_type C = 0, int Pos = 0): to(To), c(C), pos(Pos) {}
};
vector<edge> g[100005];
void add_edge(int from, int to, flow_type c, bool directed = true) {
	// cerr << "from " << from << " to " << to << " with " << c << '\n';
	if(!c) return;
	g[from].push_back(edge(to, c));
	g[to].push_back(edge(from, directed ? 0 : c));
	g[from].back().pos = g[to].size() - 1;
	g[to].back().pos = g[from].size() - 1;
}
namespace Dinic {
	int dep[100005], cur[100005];
	queue<int> q;
	bool bfs(int s, int t) {
		fill(dep + St, dep + 1 + Ed, 0);
		dep[s] = 1;
		q.push(s);
		int now;
		while(!q.empty()) {
			now = q.front();
			q.pop();
			for(const auto& i : g[now]) {
				if(!dep[i.to] && i.c) {
					dep[i.to] = dep[now] + 1;
					q.push(i.to);
				}
			}
		}
		return dep[t];
	}
	flow_type dfs(int now, flow_type flw, const int& t) {
		if(now == t) return flw;
		flow_type rest = flw, f;
		const int len = (int)g[now].size();
		while(cur[now] < len) {
			auto& i = g[now][cur[now]];
			if(dep[i.to] == dep[now] + 1 && i.c) {
				f = dfs(i.to, min(i.c, rest), t);
				if(!f) dep[i.to] = 0;
				i.c -= f;
				g[i.to][i.pos].c += f;
				rest -= f;
				if(!rest) break;
			}
			++cur[now];
		}
		return flw - rest;
	}
	flow_type Dinic(int s, int t) {
		flow_type flow = 0;
		while(bfs(s, t)) {
			fill(cur + St, cur + 1 + Ed, 0);
			flow += dfs(s, inf, t);
		}
		return flow;
	}
}
constexpr int dx[] = {-1, -1, 0, 1, 1, 0};
constexpr int dy[] = {-1, 0, 1, 1, 0, -1};
map<pair<int, int>, ll> mp;
map<pair<int, int>, int> id;
int n, s, t, cnt, x, y, z, c, _x, _y;
ll sum;
int main() {
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	cin >> n;
	while(n--) {
		cin >> x >> y >> z >> c;
		x -= z;
		y -= z;
		if(((x + y) % 3 + 3) % 3) c *= 10;
		else c *= 11;
		sum += c;
		mp[make_pair(x, y)] += c;
	}
	s = ++cnt, t = ++cnt;
	for(const auto& i : mp) {
		id[i.first] = ++cnt;
		++cnt;
		add_edge(cnt - 1, cnt, i.second);
	}
	for(const auto& i : mp) {
		x = i.first.first, y = i.first.second, c = i.second;
		if(((x + y) % 3 + 3) % 3 == 0 || ((x + y) % 3 + 3) % 3 == 2) {
			for(int j = 0; j < 6; ++j) {
				_x = x + dx[j], _y = y + dy[j];
				if(((x + y) % 3 + 3 + 1) % 3 == ((_x + _y) % 3 + 3) % 3) {
					add_edge(id[make_pair(x, y)] + 1, id[make_pair(_x, _y)], inf);
				}
			}
		}
		if(((x + y) % 3 + 3) % 3 == 2) {
			add_edge(s, id[make_pair(x, y)], inf);
		}
		if(((x + y) % 3 + 3) % 3 == 1) {
			add_edge(id[make_pair(x, y)] + 1, t, inf);
		}
	}
	St = 1, Ed = cnt;
	sum -= Dinic::Dinic(s, t);
	cout << fixed << setprecision(1) << sum / 10.0;
	return 0;
}
/*
反正也不差那个 log，直接用 map
*/
```

---

## 作者：zzw4257 (赞：6)

#### 简述
>六边形网格中有能量源($(x+y+z)\%3=0$时),$n$个水晶，炸一些水晶,使得

>- 没有水晶三元环![](http://darkbzoj.tk/JudgeOnline/upload/201606/3.png)
- 没有水晶串能源![](http://darkbzoj.tk/JudgeOnline/upload/201606/4.png)
求最大剩余权值和

#### Solution
首先六边形很讨厌，我们可以轻易的将其转为矩形$(x,y,z)\rightarrow (x-z,y-z)$

然后对除了能量源的点黑白(红绿)染色，那么构成共振当且仅当存在一个能量源六联通格子被选的有黑白两色

![六边形2.png](https://i.loli.net/2019/12/27/Hz9FC2GDrB5kIYy.png)![六边形1.png](https://i.loli.net/2019/12/27/ehAKCYDb4B9dX2Z.png)

因此这个里面的离散变量(仅对于能量源)为$\{$去黑,去白,去能量源$\}$

实际上这道题的离散变量并非一个具体点选择，而是一个决策

我们拆能量源入/出

$((x',y'),(x,y),INF)((x'+y')\%3=1\vee(x+y)\%3=0\vee(x,y)$相邻$(x',y'))$

$((x,y)',(x',y'),INF)((x'+y')\%3=2\vee(x+y)\%3=0\vee(x,y)$相邻$(x',y'))$

表示只要$(x,y)$和$(x',y')$同时选就始终存在$(S,T)$通路

其余就是黑白染色套路

$(S,(x,y),v_{x,y})((x+y)\%3=1)$
$((x,y),T,v_{x,y})((x+y)\%3=2)$
$((x,y),(x,y)',1.1v_{x,y})((x+y)\%3=0)$

#### Code

```cpp
inline void Read(void){
	re int i,z,v,tmp,dir,tx,ty;n=read(),S=0,T=n<<1|1,P=T+1;
	for(i=1;i<=n;++i){
		x[i]=read(),y[i]=read(),z=read(),v=read();x[i]-=z,y[i]-=z;
		ans+=(r[i]=((x[i]+y[i])%3)?v*10:v*11);
		if(!hash[res=Find(x[i],y[i])])hash[res]=i,val[res]=r[i];else val[res]+=r[i],again[i]=1;
	}
	for(i=1;i<=n;++i)if(!again[i]){
		tmp=((x[i]+y[i])%3+3)%3;
		if(!tmp)AddEdge(i,i+n,val[Find(x[i],y[i])]);
		if(tmp==1)AddEdge(S,i+n,val[Find(x[i],y[i])]);
		if(tmp==2)AddEdge(i,T,val[Find(x[i],y[i])]);
	}
	for(i=1;i<=n;++i)if(!again[i]){
		for(dir=0;dir<6;++dir){
			tx=x[i]+dx[dir],ty=y[i]+dy[dir];
			res=hash[Find(tx,ty)];if(!res)continue;
			if(((tx+ty)%3+3)%3==0&&((x[i]+y[i])%3+3)%3==1)AddEdge(i+n,res,INF);//1连 
			if(((tx+ty)%3+3)%3==2&&((x[i]+y[i])%3+3)%3==0)AddEdge(i+n,res,INF);
		}
	}
}
```

---

## 作者：kkksx (赞：4)

根据题意，对于一个能量源，如果它的上面有一块水晶，那么其左上右上和下面三个位置，都不能有水晶。以此类推，对于一个能量源，它的左上右上下面这三个位置是同一类的，而另外三个位置属于另一类，再加上中间的能量源属于第三类，所以这道题相当于一个换了个形状的[方格取数](https://www.luogu.org/problem/P2774)，将一个点拆成两个，中间一条边表示选或者不选，三类顺次连长度为INF的边，跑最小割即可

用$(x+y+z)\%3$来确定点的类型，用$(x-z,y-z)$来给点编号（显然$(x-z,y-z)$相同的点就是同一个点），这里的编号使用的$map$，方便快捷~~

~~又水一题~~

```cpp
#include<bits/stdc++.h>
#define N 100005
#define Max(x,y) ((x)>(y)?(x):(y))
#define Min(x,y) ((x)<(y)?(x):(y))
using namespace std;
typedef long long ll;
const ll INF = 1000000000;
int n,c,s,t,xx[N],yy[N],zz[N],d[N];
ll v[N],ans;
bool vis[N];
struct Edge
{
	int next,to;
	ll dis;
}edge[N<<3];int head[N],cnt=1;
void add_edge(int from,int to,ll dis)
{
	edge[++cnt].next=head[from];
	edge[cnt].to=to;
	edge[cnt].dis=dis;
	head[from]=cnt;
}
void add(int from,int to,ll dis)
{
	add_edge(from,to,dis);
	add_edge(to,from,0);
}
map <pair<int,int>,int> mp;//编号 

template <class T>
void read(T &x)
{
	char c;int sign=1;
	while((c=getchar())>'9'||c<'0') if(c=='-') sign=-1; x=c-48;
	while((c=getchar())>='0'&&c<='9') x=x*10+c-48; x*=sign;
}
bool bfs()
{
	memset(d,0,sizeof(d));
	queue<int> q;
	q.push(s); d[s]=1;
	while(!q.empty())
	{
		int u=q.front(); q.pop();
		for(int i=head[u];i;i=edge[i].next)
		{
			int v=edge[i].to; 
			if(!d[v]&&edge[i].dis)
			{
				q.push(v);
				d[v]=d[u]+1;
				if(v==t) return true;
			}
		}
	}
	return false;
}
ll dfs(int rt,ll rest)
{
	if(rt==t) return rest;
	ll used=0;
	for(int i=head[rt];i&&used<rest;i=edge[i].next)
	{
		int v=edge[i].to;
		if(d[v]==d[rt]+1&&edge[i].dis>0)
		{
			ll k=dfs(v,min(edge[i].dis,rest-used));
			if(!k) {d[v]=0;continue;}
			edge[i].dis-=k;
			edge[i^1].dis+=k;
			used+=k;
		}
	}
	return used;
}
ll dinic()
{
	ll ret=0;
	while(bfs()) ret+=dfs(s,INF);
	return ret; 
}
int md(int i) {return ((xx[i]+yy[i]+zz[i])%3+3)%3;}
int main()
{
	s=0; t=N-1;
	read(n);
	for(int i=1;i<=n;++i)
	{
		int x,y,z;ll val;
		read(x);read(y);read(z);
		xx[i]=x; yy[i]=y; zz[i]=z;
		read(val);
		if(((x+y+z)%3+3)%3==0) val=val*11;
		else val=val*10;
		ans+=val;
		 
		x-=z; y-=z;
		if(!mp[make_pair(x,y)]) mp[make_pair(x,y)]=++c;
		v[mp[make_pair(x,y)]]+=val;
	}
	for(int i=1;i<=n;++i)
	{
		int now=mp[make_pair(xx[i]-zz[i],yy[i]-zz[i])];
		if(vis[now]) continue;
		vis[now]=1;
		
		if(md(i)==1) add(s,now,INF);
		else if(md(i)==0)
		{
			int ss;
			ss=mp[make_pair(xx[i]-zz[i]-1,yy[i]-zz[i]-1)]; if(ss) add(ss+n,now,INF);
			ss=mp[make_pair(xx[i]-zz[i]+1,yy[i]-zz[i])]; if(ss) add(ss+n,now,INF);
			ss=mp[make_pair(xx[i]-zz[i],yy[i]-zz[i]+1)]; if(ss) add(ss+n,now,INF);
			ss=mp[make_pair(xx[i]-zz[i]+1,yy[i]-zz[i]+1)]; if(ss) add(now+n,ss,INF);
			ss=mp[make_pair(xx[i]-zz[i]-1,yy[i]-zz[i])]; if(ss) add(now+n,ss,INF);
			ss=mp[make_pair(xx[i]-zz[i],yy[i]-zz[i]-1)]; if(ss) add(now+n,ss,INF);
		}
		else add(now+n,t,INF);
		add(now,now+n,v[now]);
	}
	ans-=dinic();
	cout<<fixed<<setprecision(1)<<double(ans)/10<<endl;
	return 0;
}
```

---

## 作者：TYxxj (赞：3)

我们发现两种共振的情况都包含且仅包含了一个能量源，那么我们把能量源的六边形先盖住不看，剩下的六边形的相邻关系构成了一个二分图，我们对这个二分图进行黑白染色，发现这两种共振都包含了一黑一白。

于是得出结论：对于相邻的黑、白和能量源我们要么不选能量源，黑白任意；要么选能量源和同色的。

于是建出最小割模型：源点向白点连容量为权值的边；每个能量源拆成两个点 $A $和 $B$ ，相邻的白点向 $A$ ，$B$ 向相邻的黑点连无穷的边， $A$ 向 $B$ 连权值 * 1.1 的边；黑点向汇点连容量为权值的边。

代码：
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <vector>
using namespace std;
int read() {
	int x = 0, f = 1;
	char c = getchar();
	while(!isdigit(c)) {
		if(c == '-') f = -1;
		c = getchar();
	}
	while(isdigit(c)) {
		x = x * 10 + c - '0';
		c = getchar();
	}
	return x * f;
}
#define maxn 100001
#define maxm 500010
#define maxx 4001
#define oo 2147483647
#define pii pair <int, int>
struct Edge {
	int from, to, flow;
	Edge() {}
	Edge(int _1, int _2, int _3): from(_1), to(_2), flow(_3) {}
};
struct Dinic {
	int n, m, s, t, head[maxn], nxt[maxm];
	Edge es[maxm];
	int Q[maxn], hd, tl, vis[maxn];
	int cur[maxn];
	void init() {
		m = 0;
		memset(head, -1, sizeof(head));
		return ;
	}
	void setn(int _) {
		n = _;
		return ;
	}
	void AddEdge(int a, int b, int c) {
		es[m] = Edge(a, b, c);
		nxt[m] = head[a];
		head[a] = m++;
		es[m] = Edge(b, a, 0);
		nxt[m] = head[b];
		head[b] = m++;
		return ;
	}
	bool BFS() {
		memset(vis, 0, sizeof(vis));
		hd = tl = 0;
		Q[++tl] = s;
		vis[s] = 1;
		while(hd < tl) {
			int u = Q[++hd];
			for(int i = head[u]; i != -1; i = nxt[i]) {
				Edge& e = es[i];
				if(e.flow && !vis[e.to]) {
					vis[e.to] = vis[u] + 1;
					Q[++tl] = e.to;
				}
			}
		}
		return vis[t] > 0;
	}
	int DFS(int u, int a) {
		if(u == t || !a) return a;
		int f, flow = 0;
		for(int& i = cur[u]; i != -1; i = nxt[i]) {
			Edge& e = es[i];
			if(vis[e.to] == vis[u] + 1 && (f = DFS(e.to, min(a, e.flow)))) {
				flow += f;
				a -= f;
				e.flow -= f;
				es[i^1].flow += f;
				if(!a) return flow;
			}
		}
		return flow;
	}
	int MaxFlow(int _s, int _t) {
		s = _s;
		t = _t;
		int flow = 0;
		while(BFS()) {
			for(int i = 1; i <= n; i++) cur[i] = head[i];
			flow += DFS(s, oo);
		}
		return flow;
	}
} sol;
int Cnt;
struct Node {
	int id, x, y;
	int val;
	Node(): id(0) {}
	Node(int _1, int _2, int _3): id(0), x(_1), y(_2), val(_3) {}
	int p() {
		return id ? id : id = ++Cnt;
	}
} ns[maxn], n2[maxn], Source, Tank;
vector <int> white, black, middle;
int Map[maxx][maxx], Mid[maxx][maxx];
void add(vector <int>& A, int x, int y) {
	if(0 <= x && x < maxx && 0 <= y && y < maxx) ;
	else return ;
	if(Mid[x][y]) A.push_back(Mid[x][y]);
	return ;
}
void add_white(int x, int y) {
	if(0 <= x && x < maxx && 0 <= y && y < maxx) ;
	else return ;
	add(white, x - 1, y);
	add(white, x, y - 1);
	add(white, x + 1, y + 1);
	int u = Mid[x][y];
	if(Mid[x-1][y]) sol.AddEdge(ns[Mid[x-1][y]].p(), ns[u].p(), oo);
	if(Mid[x][y-1]) sol.AddEdge(ns[Mid[x][y-1]].p(), ns[u].p(), oo);
	if(Mid[x+1][y+1]) sol.AddEdge(ns[Mid[x+1][y+1]].p(), ns[u].p(), oo);
	return ;
}
void add_black(int x, int y) {
	if(0 <= x && x < maxx && 0 <= y && y < maxx) ;
	else return ;
	add(black, x + 1, y);
	add(black, x, y + 1);
	add(black, x - 1, y - 1);
	int u = Mid[x][y];
	if(Mid[x+1][y]) sol.AddEdge(n2[u].p(), ns[Mid[x+1][y]].p(), oo);
	if(Mid[x][y+1]) sol.AddEdge(n2[u].p(), ns[Mid[x][y+1]].p(), oo);
	if(Mid[x-1][y-1]) sol.AddEdge(n2[u].p(), ns[Mid[x-1][y-1]].p(), oo);
	return ;
}
#define vit vector <int> :: iterator
int main() {
	int n = read();
	sol.init();
	int sum = 0;
	for(int i = 1; i <= n; i++) {
		int x = read(), y = read(), z = read(), v = read();
		x -= z;
		y -= z;
		x += 2000;
		y += 2000;
		Map[x][y] += v;
	}
	for(int x = 0, i = 0; x < maxx; x++)
		for(int y = 0; y < maxx; y++) if(Map[x][y]) {
				int v = Map[x][y];
				Mid[x][y] = ++i;
				ns[i] = Node(x, y, (x + y - 4000) % 3 ? v * 10 : v * 11);
				sum += ns[i].val;
				if((x + y - 4000) % 3 == 0) middle.push_back(i);
			}
	for(vit i = middle.begin(); i != middle.end(); i++) {
		int x = ns[*i].x, y = ns[*i].y;
		sol.AddEdge(ns[*i].p(), n2[*i].p(), ns[*i].val);
		add_white(x, y);
		add_black(x, y);
	}
	sort(white.begin(), white.end());
	vit it = unique(white.begin(), white.end());
	for(vit i = white.begin(); i != it; i++) sol.AddEdge(Source.p(), ns[*i].p(), ns[*i].val);
	sort(black.begin(), black.end());
	it = unique(black.begin(), black.end());
	for(vit i = black.begin(); i != it; i++) sol.AddEdge(ns[*i].p(), Tank.p(), ns[*i].val);
	sol.setn(Cnt);
	printf("%.1lf\n", (sum - sol.MaxFlow(Source.p(), Tank.p())) / 10.0);
	return 0;
}
```

---

## 作者：o51gHaboTei1 (赞：1)

考虑本质是二维平面，所以三维一定是假的。

根据初高中基本的向量知识，$(x,y,z) \rightarrow (x - z,y - z)$。

先把点坐标相同的合并一下，然后观察限制，发现题目甚至在暗示你要思考 $(x + y) \mod 3$ 的特性！按照该值将所有点分为三类。

猜测可以转化为连通性问题，考虑扔掉总和最小的妨碍点，于是尝试跑最小割。

先点转边，把点权扔边权上；接着我们发现令余数为 $0$ 的点为中间的点，然后余数为 $1$ 的是 $S$ 连接的点，余数为 $2$ 的即 $T$ 连接的点。

你发现此时任意一个共振关系，必定从 $S$ 连接的点 $\rightarrow$ 能源点 $\rightarrow$ $T$ 连接的点，我们设 $id_{i,0/1}$ 表示编号为 $i$ 的点拆成边后的入度点/出度点。

对于一个共振关系 $\{x,y,z\}$，表示 $x$ 是余数为 $1$ 的点，$y$ 是余数为 $0$ 的点，$z$ 是余数为 $2$ 的点，进行 $(S,id_{x,0},+\infty),(id_{x,1},id_{y,0},+\infty),(id_{y,1},id_{z,0,+\infty}),(id_{z,1},T,+\infty)$ 的连边，这样就保证了如果不删掉 $\{x,y,z\}$ 中间的一个点（割掉入度点与出度点的边）就会导致 $S,T$ 联通，出现共振。

实现时我们将每个共振关系记在余数为 $1$ 的节点上，在碰到余数为 $1$ 的节点时枚举可行的 $12$ 种共振关系进行连边即可。

给出代码以供参考。一个更好的实现是刚开始将权值全部乘 $10$ 然后跑整数型网络流可能会快一点。

```cpp
/*
显然任意一个单元格上的水晶要么一起炸，要么一起留，考虑合并即可。
考虑边转点，用最小割做。发现类似双选模型，我们猜测这是拓展的三选模型。
挺难的。 
然后 a 限制显然是三者不共颜色，b 限制也是三者不共颜色
我们直接点转边，外层连边之间互相是 Inf 的关系，然后跑最小割。 
*/
#include "bits/stdc++.h"
using namespace std;
const int Len = 2e5 + 5 , M = 2e5 + 5;
const double eps = 1e-2 , Inf = 1e9;
int n,m,head[Len],cnt = 1,S,T,dep[Len],cur[Len],flag[Len];
struct Mode
{
	int next,to;
	double w;
}edge[M << 3];
inline void add(int from,int to,double w)
{
	edge[++ cnt].to = to;
	edge[cnt].next = head[from];
	edge[cnt].w = w;
	head[from] = cnt;
}
inline void adeg(int from,int to,double w){add(from , to , w) , add(to , from , 0);}
inline int BFS()
{
	queue<int> Q;
	for(int i = 1 ; i <= T ; i ++) dep[i] = cur[i] = flag[i] = 0;
	dep[S] = 1 , cur[S] = head[S];Q.push(S);
	while(!Q.empty())
	{
		int p = Q.front();Q.pop();
		for(int e = head[p] ; e ; e = edge[e].next)
		{
			int to = edge[e].to;
			if(!dep[to] && edge[e].w > eps)
			{
				dep[to] = dep[p] + 1;
				cur[to] = head[to];
				Q.push(to);
				if(to == T) return 1;
			}
		}
	}
	return 0;
}
double dfs(int u,double In)
{
	if(u == T) return In;
	flag[u] = 1;
	double Out = 0;
	for(int e = cur[u] ; e && In > eps ; e = edge[e].next)
	{
		cur[u] = e;
		int to = edge[e].to;
		if(dep[to] == dep[u] + 1 && edge[e].w > eps && !flag[to])
		{
			double res = dfs(to , min(edge[e].w , In));
			In -= res;
			Out += res;
			edge[e].w -= res;
			edge[e ^ 1].w += res;	
		}
	}
	flag[u] = 0;
	if(Out < eps) dep[u] = 0;
	return Out; 
}
#define mk(x,y) make_pair(x,y)
inline pair<int,int> mkk(int x,int y,int z){return mk(x - z , y - z);}
inline int jd(int x,int y,int z){return (x + y + z) % 3 == 0;}
pair<int,int> pr;int bh;
map<pair<int,int>,int> vis,id;
map<pair<int,int>,double> d;
map<pair<int,int>,int>::iterator it;
int x,y,z;double w;
pair<int,int> o[13],s[13];
inline void link(int a,int b,int c)
{
	adeg(S , a , Inf) , adeg(a + n , b , Inf);
	adeg(b + n , c , Inf) , adeg(c + n , T , Inf);
}
inline int md(int x,int y){return ((x + y) % 3 + 3) % 3;}
int main()
{
	o[1] = mk(-1 , -1) , o[2] = mk(0 , -1) , o[3] = mk(1 , 0) , o[4] = mk(1 , 1) , o[5] = mk(0 , 1) , o[6] = mk(-1 , 0);
	s[1] = mk(0 , -1) , s[2] = mk(1 , 0) , s[3] = mk(1 , 1) , s[4] = mk(0 , 1) , s[5] = mk(-1 , 0) , s[6] = mk(-1 , -1);
	o[7] = mk(-1 , 0) , o[8] = mk(1 , 1) , o[9] = mk(0 , -1);
	s[7] = mk(-2 , 0) , s[8] = mk(2 , 2) , s[9] = mk(0 , -2);
	scanf("%d",&n);double al = 0;
	for(int i = 1 ; i <= n ; i ++)
	{
		scanf("%d %d %d %lf",&x,&y,&z,&w);
		pr = mkk(x , y , z);
		if(!id[pr]) id[pr] = ++ bh;
		d[pr] += w;
	}
	S = (n << 1) + 1 , T = (n << 1) + 2;
	for(it = id.begin() ; it != id.end() ; it ++)
	{
		pr = (*it).first;
		x = pr.first , y = pr.second;int idd[3];
		if(md(x , y) == 0) d[pr] *= 1.1;
		al += d[pr];
		adeg(id[pr] , id[pr] + n , d[pr]);
		if(md(x , y) == 1)
		{
			for(int j = 1 ; j <= 9 ; j ++)
			{
				int tx = x + o[j].first , ty = y + o[j].second;
				int dx = x + s[j].first , dy = y + s[j].second;
				idd[md(x , y)] = id[mk(x , y)];
				idd[md(tx , ty)] = id[mk(tx , ty)];
				idd[md(dx , dy)] = id[mk(dx , dy)];
				if(!idd[0] || !idd[1] || !idd[2]) continue;
				link(idd[1] , idd[0] , idd[2]);
			}
		}
	}
	double as = 0;
	while(BFS()) as += dfs(S , Inf);
	printf("%.1lf\n",al - as);
	return 0;
}
```

---

## 作者：JPGOJCZX (赞：0)

节选自：[图论学习笔记（三）：二分图、网络流](https://www.luogu.com.cn/article/grmv2d6x)

[安利一下我的博客](https://www.cnblogs.com/JPGOJCZX/p/18946654)

每次听别人讲网络流，讲到这道题时都叫我们自行看题，看来这道题目确实是又臭又长。

首先，这道题目的多个坐标可能对应一个点，具体一点说，就是 $x, y, z$ 坐标同时加上或减去一个数，它表示的还是同一个格子，因此我们将 $x, y, z$ 坐标同时减去 $z$，那么所有格子的 $z$ 坐标就都是 $0$ 了，此时我们就将这个 $3$ 维坐标 $(x, y, z)$ 转化成了 $2$ 维坐标 $(x - z, y - z)$，且此时一个坐标就对应一个格子。

其次我们考虑 $3$ 个有水晶的格子，如果它们要形成共振，如果排列成三角形，那么这 $3$ 个格子一定是 $(x, y)$，$(x, y - 1)$（或 $(x - 1, y)$），$(x - 1, y - 1)$，那它们的横纵坐标之和就是 $x + y, x + y - 1, x + y - 2$，显而易见，它们构成了一个 $\bmod \, 3$ 的剩余系；如果排列成直线形，那么这 $3$ 个格子一定是 $(x, y)$，$(x, y - 1)$（或 $(x - 1, y)$），$(x, y + 1)$（或 $(x + 1, y)$），那它们的横纵坐标之和就是 $x + y, x + y + 1, x + y - 1$，显而易见，它们也构成了一个 $\bmod \, 3$ 的剩余系。这就说明，如果 $3$ 个水晶相邻且横纵坐标之和 $\bmod \, 3$ 分别是 $0, 1, 2$，那么它们就会产生共振。

现在题目信息转化得差不多了，考虑到题目要求剩余价值最大，这不难想到最小割模型，而且由于权值在点上，这启示我们要拆点。我们将每个水晶拆成入点和出点，中间连一条容量为价值的边。我们再建立出源点和汇点，从源点向每个横纵坐标之和 $\bmod \, 3 = 1$ 的水晶的入点连边，再从每个横纵坐标之和 $\bmod \, 3 = 1$ 的水晶的出点向每个横纵坐标之和 $\bmod \, 3 = 0$ 的水晶的入点连边，接着从每个横纵坐标之和 $\bmod \, 3 = 1$ 的水晶的出点向每个横纵坐标之和 $\bmod \, 3 = 2$ 的水晶的入点连边，最后再从每个横纵坐标之和 $\bmod \, 3 = 2$ 的水晶的出点向汇点连边，边全都是 $\infty$。此时 $3$ 个会产生共振的水晶就会构成一条路径，必须割掉一条边。此时跑一遍最大流就可以得出答案。

最后一点，就是一个点可能会有多个水晶，我们只需要从这些水晶中选一个出来，并从这个水晶的出点向其他水晶的出点连容量为 $\infty$ 边即可，这样就可以将这两个水晶合并在一起了。

完整代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define pii pair <int, int>
#define mk make_pair
const int N = 1e5 + 9, M = 1e6 + 9, K = 6e3 + 9, INF = 1e18 + 9;
struct Edge{
    int v, nex;
    double c;
} e[M << 1];
int head[N], ecnt = 1;
void addEdge(int u, int v, double c){
    e[++ecnt] = Edge{v, head[u], c};
    head[u] = ecnt;
}
int cur[N], dep[N], n, m, s, t;
bool bfs();
double dfs(int u, double flow);
int x[N], y[N], z[N], tmp[N], tot, d[6][2] = {{-1, -1}, {0, -1}, {1, 0}, {1, 1}, {0, 1}, {-1, 0}};
double c[N], sum, ans;
map <pii, int> id;
signed main(){
    scanf("%lld", &n);
    s = n * 2 + 1, t = n * 2 + 2;
    for(int i = 1; i <= n; i++){
        scanf("%lld%lld%lld%lf", &x[i], &y[i], &z[i], &c[i]);
        x[i] -= z[i], y[i] -= z[i];
        if(((x[i] + y[i]) % 3 + 3) % 3 == 0)
            c[i] += c[i] * 0.1;
        sum += c[i];
        if(id[mk(x[i], y[i])]){
            addEdge(id[mk(x[i], y[i])] + n, i + n, INF);
            addEdge(i + n, id[mk(x[i], y[i])] + n, 0);
        } else
            id[mk(x[i], y[i])] = i;
        addEdge(i + n, i, c[i]);
        addEdge(i, i + n, 0);
    }
    for(int i = 1; i <= n; i++){
        if(((x[i] + y[i]) % 3 + 3) % 3 == 1){
            addEdge(s, i + n, INF);
            addEdge(i + n, s, 0);
        } else if(((x[i] + y[i]) % 3 + 3) % 3 == 2){
            addEdge(i, t, INF);
            addEdge(t, i, 0);
        }
    }
    for(int i = 1; i <= n; i++){
        if(((x[i] + y[i]) % 3 + 3) % 3 == 1){
            for(int j = 0; j < 6; j++){
                int dx = x[i] + d[j][0];
                int dy = y[i] + d[j][1];
                if(id[mk(dx, dy)] && ((dx + dy) % 3 + 3) % 3 == 0){
                    addEdge(i, id[mk(dx, dy)] + n, INF);
                    addEdge(id[mk(dx, dy)] + n, i, 0);
                }
            }
        }
        if(((x[i] + y[i]) % 3 + 3) % 3 == 0){
            for(int j = 0; j < 6; j++){
                int dx = x[i] + d[j][0];
                int dy = y[i] + d[j][1];
                if(id[mk(dx, dy)] && ((dx + dy) % 3 + 3) % 3 == 2){
                    addEdge(i, id[mk(dx, dy)] + n, INF);
                    addEdge(id[mk(dx, dy)] + n, i, 0);
                }
            }
        }
    }
    while(bfs())
        ans += dfs(s, INF);
    printf("%.1lf", sum - ans);
    return 0;
}
```

---

## 作者：Kketchup (赞：0)

### [[BJOI2016] 水晶](https://www.luogu.com.cn/problem/P5458)

**Sol:** 首先发现，在二维中用三个参数表示点属实多此一举，想办法转化成二维的点。注意到，如果在三个方向上各走一步，就相当于原地不动，所以 $(x,y,z)=(x-z,y-z,z-z)$，那么所有点都可以表示为 $(x-z,y-z)$。

看到这样的删点使没有贡献，很像最小割的**删边使图不连通**形式，于是往这个方向上思考。根据题目的提示，能量源在 $x+y+z \equiv 0 \pmod 3$ 的位置，让我们想到根据坐标和对 $3$ 取模将点分类。我们把坐标和模 $3$ 是 $1$ 的点称为 $A$ 类点，把坐标和模 $3$ 是 $2$ 的点称为 $B$ 类点。那么发现整张图都被 $3$ 类点覆盖，且这三类点正好能组成一个紧靠着的三联通图形（即形成 $a$ 类共振）。

考虑建图，我们先钦定流量的方向：$B\rightarrow A$。超级源点 $S$ 向所有 $B$ 类点连边，容量为点权，表示割掉这个边的代价；所有 $A$ 类点向超级汇点连边，容量为点权。发现对于 $b$ 类共振，中间一定是能量源，而对于 $a$ 类共振，一定也会经过能量源，因为相邻的 $3$ 个中必有一个能量源。对于中间的能量源，先拆成入点和出点，入点连向出点，容量是点权，表示割能量源代价；相邻的 $B$ 类点向入点连边，出点向相邻的 $A$ 类点连边，容量都为 $inf$，这样保证只会割一次能量源。

这样建图就可以了，来看下正确性，对于一条直线上的 $B\rightarrow A$，相当于 $b$ 类共振；对于有相同相邻能量源的 $B\rightarrow A$，是 $a$ 类共振。这样图的最小割就是答案，使用了 $dinic$ 求最大流。

细节处理方面，尽量避免浮点数的精度问题，故先把点权扩大 $10$ 倍，最后除回来。对于对应点相同的点，用一个 map 存里面的边。

**Trick:** 低维里只用尽量少的信息表示点；根据题目给定条件想到依据坐标和取模分类点；看到答案形式想到最小割，钦定好流量方向确定连边方向；把一个点拆成出点与入点保证只会割一次。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define db long double
typedef vector<int> ve;
#define endl '\n'
#define F(i,x,y) for(int i=(x);i<=(y);++i)
#define Fo(i,x,y) for(int i=(x);i>=(y);--i)
const int N=1e6+10,INF=1e9;
int n,s,t;
struct edge{
    int v,next,w;
}e[N];
int head[N],tot=1;
void add(int u,int v,int w){
	e[++tot]=edge{v,head[u],w};
	head[u]=tot;
    e[++tot]=edge{u,head[v],0};
    head[v]=tot;
}
ll ans;
int dis[N],now[N];
bool bfs(){
	queue<int> q;
	memset(dis,0,sizeof(dis));
	q.push(s),dis[s]=1;
	now[s]=head[s];
	while(!q.empty()){
		int u=q.front();
		q.pop();
		for(int i=head[u];i;i=e[i].next){
			int v=e[i].v;
			if(!dis[v]&&e[i].w){
				dis[v]=dis[u]+1;
				q.push(v);
				now[v]=head[v];
				if(v==t) return 1;
			}
		}
	}
	return 0;
}
ll dfs(int u,int sum){
	if(u==t) return sum;
	ll res=0,tmp;
	for(int i=now[u];i&&sum;i=e[i].next){
		now[u]=i;
		int v=e[i].v;
		if((dis[v]==dis[u]+1)&&e[i].w){
			tmp=dfs(v,min(e[i].w,sum));
			if(!tmp) dis[v]=0;
			e[i].w-=tmp,e[i^1].w+=tmp;
			res+=tmp,sum-=tmp;
		}
	}
	return res;
}
struct node{
    int x,y,w;
    node(){}
    node(int u,int v,int val){
        x=u,y=v,w=val;
    }
}a[N];
map<int,map<int,ve>> ma;
signed main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin>>n;
    s=0,t=2*n+1;
    auto calc=[](int x,int y){return ((x+y)%3+3)%3;};
    for(int i=1,x,y,z,w;i<=n;++i){
        cin>>x>>y>>z>>w;
        x-=z,y-=z;
        if(calc(x,y)==0) w*=11;
        else w*=10;
        ans+=w;
        a[i]=node(x,y,w);
        ma[x][y].push_back(i);
    }
    for(int i=1,x,y,w;i<=n;++i){
        x=a[i].x,y=a[i].y,w=a[i].w;
        if(calc(x,y)==1) add(i,t,w);
        else if(calc(x,y)==2) add(s,i,w);
        else{
            add(i,i+n,w);
            for(int p:ma[x-1][y]) add(p,i,INF);
            for(int p:ma[x+1][y]) add(i+n,p,INF);
            for(int p:ma[x-1][y-1]) add(i+n,p,INF);
            for(int p:ma[x+1][y+1]) add(p,i,INF);
            for(int p:ma[x][y-1]) add(p,i,INF);
            for(int p:ma[x][y+1]) add(i+n,p,INF);
        }
    }
    while(bfs()) ans-=dfs(s,INF);
    cout<<fixed<<setprecision(1)<<ans/10.0<<endl;
    return 0;
}
```

---

## 作者：sangshang (赞：0)

# Description

有 $n$ 块水晶，按特定形式摆放的水晶会产生共振，必须摧毁。问，最多能留下价值和多少水晶？

# Solution

本题与[老 C 的方块](https://www.luogu.com.cn/problem/P3756)思路如出一辙。

- 看到炸点，想到最小割。

- 发现题目所给的两种共振都需要三块水晶，其中必有特殊用意。

- B 共振题目有要求：三块连续的，连成一条直线的水晶中间必须有一个能量源，才可组成 B 共振。而 A 共振虽题目没说需夹有能量源，但观察题目给的图可发现，图中任意一个可能组成 A 共振的三个水晶，其中必有一个在能量源上。因此想到，能量源不只是用于给水晶增值，还是最小割路径组成的关键点。

方格图，染色是求解的重要手段。据如上分析，将图染成如下形式：

![](https://cdn.luogu.com.cn/upload/image_hosting/wox55qyh.png)

黄代表共振中第一个水晶，红代表第二个，绿代表第三个。因为能量源是两种共振的关键路径，所以将其染成红色，表示共振组成的第二个水晶。其他的水晶看情况染色，就行了。

我们发现，任何一组可能的，合法的共振水晶，都一定可以表示为一条黄到红，红到绿的路径。因此，对于可能的路径，对应连边。最后不存在源点到汇点，就是不存在共振；最小割，就是最小炸掉水晶价值和。

发现题目所给的三位坐标很难计算，做如下处理：

>将一个点的坐标转化为二维坐标 $(x,y)$，每个点 $(x,y)$ 与如下点相邻：$(x+1,y+1),(x+2,y),(x+1,y-1),(x-1,y-1),(x-2,y),(x-1,y+1)$。三维坐标上向 $z$ 走一步，就是 $x+2$，向 $x$ 走一步，就是 $x-1,y+1$，向 $y$ 走一步，就是 $x-1,y-1$。

根据如上坐标，可以很方便算出点的颜色，用 $1$ 代表黄色，$2$ 代表红色，$3$ 代表绿色。得出函数：

$$\operatorname{color}(x,y)=\begin{cases}2\ \operatorname{abs}(x)\ \operatorname{mod}\ 3=0\\ 1\ \operatorname{abs}(x)\ \operatorname{mod}\ 3=1,x>0\\ 1\ \operatorname{abs}(x)\ \operatorname{mod}\ 3=2,x<0\\ 3\ \operatorname{abs}(x)\ \operatorname{mod}\ 3=1,x<0\\ 3\ \operatorname{abs}(x)\ \operatorname{mod}\ 3=2,x>0\end{cases}$$

还有就是为防止一个点被多次计算贡献，若是黄色，将权值赋在源点到它的边上，若是绿色，将权值赋在它到汇点的边上，若是红色，就只能拆点了。（没被赋上权值的边，容量是 $+\infty$）。

## Code

```cpp
#include <bits/stdc++.h>
using namespace std;

class Dinic {
	public:
		typedef unsigned int TYPE;
		static const int maxn = 50005 * 2, inf = 0x7f7f7f7f, maxm = inf;
		class edge {
			public:
				int to, rev;
				TYPE flow;
				edge(int to, TYPE flow, int rev): to(to), flow(flow), rev(rev) {}
				edge() {}
		};
		vector<edge>vec[maxn];
		int h[maxn], cur[maxn], n, m, s, t;
		Dinic(int n, int m, int s, int t): n(n), m(m), s(s), t(t) {}
		Dinic() {}
		inline void Add_Edge(int from, int to, TYPE flow) {
			vec[from].push_back(edge(to, flow, vec[to].size()));
			vec[to].push_back(edge(from, 0, vec[from].size() - 1));
		}
		inline bool bfs() {
			int que[maxn], front = 0, back = -1;
			memset(h, inf, sizeof(h)), h[t] = 0;
			memset(cur, 0, sizeof(cur));
			for (que[++back] = t; front <= back;) {
				int u = que[front++];
				for (edge &e : vec[u]) {
					int &v = e.to;
					if (vec[v][e.rev].flow && h[v] == inf) {
						h[v] = h[u] + 1;
						que[++back] = v;
					}
				}
			}
			return h[s] != inf;
		}
		inline TYPE dfs(int u, TYPE flow) {
			if (u == t || !flow) {
				return flow;
			}
			TYPE res = 0;
			int siz = vec[u].size();
			for (int i = cur[u]; i < siz && flow; ++i) {
				cur[u] = i;
				edge &e = vec[u][i];
				int v = e.to;
				if (e.flow && h[v] + 1 == h[u]) {
					TYPE tmp = dfs(v, min(flow, e.flow));
					flow -= tmp, res += tmp;
					e.flow -= tmp, vec[v][e.rev].flow += tmp;
				}
			}
			if (!res) {
				h[u] = inf;
			}
			return res;
		}
		inline TYPE GetMaxFlow() {
			TYPE res = 0;
			while (bfs()) {
				TYPE tmp = 0;
				while ((tmp = dfs(s, inf))) {
					res += tmp;
				}
			}
			return res;
		}
		class Node {
			public:
				int x, y;
				Node(int x, int y): x(x), y(y) {}
				Node() {}
				bool operator<(const Node a)const {
					if (this->x != a.x) {
						return this->x < a.x;
					} else {
						return this->y < a.y;
					}
				}
		};
		Node A[maxn];
		map<Node, int>Map;
		inline int color(Node a) {
			int tmp = (abs(a.x)) % 3;
			if (tmp == 0) {
				return 2;
			} else if (tmp == 2) {
				if (a.x > 0) {
					return 3;
				} else {
					return 1;
				}
			} else {
				if (a.x > 0) {
					return 1;
				} else {
					return 3;
				}
			}
		}
		inline void Solve() {
			int N, val[maxn];
			cin >> N;
			this[0] = Dinic(N * 2 + 3, inf, 0, N * 2 + 2);
			for (int i = 1; i <= N; ++i) {
				int tmp1, tmp2, tmp3;
				cin >> tmp1 >> tmp2 >> tmp3 >> val[i];
				A[i].x = 2 * tmp3 - tmp1 - tmp2;
				A[i].y = tmp1 - tmp2;
				if (Map.find(A[i]) != Map.end()) {
					val[(*Map.find(A[i])).second] += val[i];
					val[i] = -1;
				} else {
					Map[A[i]] = i;
				}
			}
			TYPE sum = 0;
			for (int i = 1; i <= N; ++i) {
				int tmp = color(A[i]);
				if (!(~val[i])) {
					continue;
				}
				if (tmp == 1) {
					Add_Edge(s, i, val[i] * 10);
					sum += val[i] * 10;
					map<Node, int>::iterator it;
					if ((it = Map.find(Node(A[i].x - 1, A[i].y - 1))) != Map.end()) {
						Add_Edge(i, (*it).second, 1e9);
					}
					if ((it = Map.find(Node(A[i].x - 1, A[i].y + 1))) != Map.end()) {
						Add_Edge(i, (*it).second, 1e9);
					}
					if ((it = Map.find(Node(A[i].x + 2, A[i].y))) != Map.end()) {
						Add_Edge(i, (*it).second, 1e9);
					}
				} else if (tmp == 2) {
					Add_Edge(i, i + N, val[i] * 11);
					sum += val[i] * 11;
					map<Node, int>::iterator it;
					if ((it = Map.find(Node(A[i].x + 2, A[i].y))) != Map.end()) {
						Add_Edge(i + N, (*it).second, 1e9);
					}
					if ((it = Map.find(Node(A[i].x - 1, A[i].y - 1))) != Map.end()) {
						Add_Edge(i + N, (*it).second, 1e9);
					}
					if ((it = Map.find(Node(A[i].x - 1, A[i].y + 1))) != Map.end()) {
						Add_Edge(i + N, (*it).second, 1e9);
					}
				} else {
					Add_Edge(i, t, val[i] * 10);
					sum += val[i] * 10;
				}
			}
			printf("%.1lf\n", (double)(sum - GetMaxFlow()) / 10);
		}
};
Dinic Main;

int main() {
	ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);
	Main.Solve();
	return 0;
}
```
别忘了可能有多块水晶在一个点，需特判一下，否则 $25\text{pts}$。

---


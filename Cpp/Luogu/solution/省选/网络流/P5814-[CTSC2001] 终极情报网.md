# [CTSC2001] 终极情报网

## 题目描述

在最后的诺曼底登陆战开始之前，盟军与德军的情报部门围绕着最终的登陆地点展开了一场规模空前的情报战。 这场情报战中，盟军的战术是利用那些潜伏在敌军内部的双重间谍，将假的登陆消息发布给敌军的情报机关的负责人。那些已经潜入敌后的间谍们都是盟军情报部的精英，忠实可靠；但是如何选择合适的人选，以及最佳的消息传递方法，才能保证假消息能够尽快而且安全准确地传递到德军指挥官们的耳朵里，成了困扰盟军情报部长的最大问题。他需要你的帮助。

以下是情报部长提供的作战资料：

在敌后一共潜伏着我方最优秀的 $N$ 名间谍，分别用数字 $1,2,\cdots,N$ 编号。在给定的作战时间内，任意两人之间至多只进行一次点对点的双人联系。 我将给你一份表格，表格中将提供任意两位间谍 $i$ 和 $j$ 之间进行联系的安全程度，用一个 $[0,1]$ 的实数 $S_{i,j}$ 表示；以及他们这次联系时，能够互相传递的消息的最大数目，用一个正整数表示 $M_{i,j}$（如果在表格中没有被提及，那么间谍 $i$ 和 $j$ 之间不进行直接联系）。 假消息从盟军总部传递到每个间谍手里的渠道也不是绝对安全，我们用 $[0,1]$ 的实数 $AS_j$ 表示总部与间谍 $j$ 之间进行联系的安全程度，$AM_j $  则表示总部和间谍 $j$ 之间进行联系时传递的消息的最大数目。对于不和总部直接联系的间谍，他的  $AM_j = 0$（而表格中给出的他的 $AS_j$ 是没有意义的）。 当然，假消息从间谍手中交到敌军的情报部官员的办公桌上的过程是绝对安全的，也即是说，间谍与敌军情报部门之间要么不进行直接联系，要么其联系的安全程度是 $1$（即完全可靠）。

现在情报部打算把 $K$ 条假消息“透露”到德军那里。消息先由总部一次性发给 $N$ 名间谍中的一些人，再通过他们之间的情报网传播，最终由这 $N$ 名间谍中的某些将情报送到德军手中。 对于一条消息，只有安全的通过了所有的中转过程到达敌军情报部，这个传递消息的过程才算是安全的；因此根据乘法原理，它的安全程度 $P$ 就是从总部出发，经多次传递直到到达德军那里，每一次传递该消息的安全程度的乘积。 而对于整个计划而言，只有当 $N$ 条消息都安全的通过情报网到达德军手中，没有一条引起怀疑时，才算是成功的。所以计划的可靠程度是所有消息的安全程度的乘积。 显然，计划的可靠性取决于这些消息在情报网中的传递方法。 我需要一个方案，确定消息应该从哪些人手中传递到哪些人手中，使得最终计划的可靠性最大。

你可以利用计算机，来求得这个最可靠的消息传递方案。

## 说明/提示

$1 \le N,K \le 300$。

## 样例 #1

### 输入

```
6 13
0.9 0.7 0.8 0 0 0 2 6 8 0 0 0
0 0 0 1 0 1
1 4 0.5 2
2 3 0.9 5
2 5 0.8 2
2 6 0.8 7
3 5 0.8 2
5 6 0.8 4
-1 -1
```

### 输出

```
0.00021184
```

# 题解

## 作者：lhm_ (赞：3)

读完题后不难看出本题是个网络流模型，源点流出的总流量为$k$，源点向每个和总部直接联系的间谍连边，每个间谍向其能传递的间谍连容量为$m$的边，能与德军情报部进行联系的间谍向汇点连容量为$inf$的边，若最大流为$k$，则存在可行的方案。

处理可靠程度最大时，考虑用费用流解决，将每条边的安全程度看作边的费用，进行最大费用最大流即可，注意反向边的费用应该为原边费用的倒数，实现时把平时的费用流的一些部分改为乘法即可。

一些细节看代码吧。

$code:$

```cpp
#include<bits/stdc++.h>
#define maxn 1000010
#define inf 1000000000
#define eps 1e-12
using namespace std;
typedef long double ld;
template<typename T> inline void read(T &x)
{
    x=0;char c=getchar();bool flag=false;
    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}
    while(isdigit(c)){x=(x<<1)+(x<<3)+(c^48);c=getchar();}
    if(flag)x=-x;
}
int n,k,S,s,t;
ld ans=1;
int am[maxn],d[maxn];
ld as[maxn],dis[maxn];
bool vis[maxn];
char str[30];
struct edge
{
    int to,nxt,v;
    ld c;
}e[maxn];
int head[maxn],edge_cnt=1;
void add(int from,int to,int val,ld cost)
{
    e[++edge_cnt]=(edge){to,head[from],val,cost};
	head[from]=edge_cnt;
    e[++edge_cnt]=(edge){from,head[to],0,1/cost};
	head[to]=edge_cnt;
}
bool spfa()
{
    queue<int> q;
    for(int i=s;i<=t;++i) dis[i]=0,vis[i]=d[i]=0;
    q.push(s),dis[s]=1,d[s]=1,vis[s]=true;
    while(!q.empty())
    {
        int x=q.front();
        q.pop(),vis[x]=false;
        for(int i=head[x];i;i=e[i].nxt)
        {
            int y=e[i].to,v=e[i].v;
            ld c=e[i].c;
            if(v&&dis[x]*c-dis[y]>eps)
            {
                dis[y]=dis[x]*c,d[y]=d[x]+1;
                if(!vis[y]) vis[y]=true,q.push(y);
            }
        }
    }
    return dis[t];
}
int dfs(int x,int lim)
{
    if(x==t) return lim;
    int res=lim,flow;
    for(int i=head[x];i;i=e[i].nxt)
    {
        int y=e[i].to,v=e[i].v;
        ld c=e[i].c;
        if(!v||dis[y]-dis[x]*c>eps||d[y]!=d[x]+1) continue;
        if(flow=dfs(y,min(res,v)))
        {
            res-=flow;
            e[i].v-=flow;
            e[i^1].v+=flow;
            if(!res) break;
        }
    }
    return lim-res;
}
ld qp(ld x,int y)
{
    ld v=1;
    while(y)
    {
        if(y&1) v*=x;
        x*=x,y>>=1;
    }
    return v;
}
void dinic()
{
    int flow,sum=0;
    while(spfa()>eps)
        while(flow=dfs(s,inf))
            sum+=flow,ans*=qp(dis[t],flow);
    if(sum!=k) ans=0;
}
void print()
{
    sprintf(str,"%.15Lf",ans);
    int pos=0,cnt=0;
    while(cnt<5)
    {
        char ch=str[pos++];
        if((ch!='0'&&ch!='.')||cnt) cnt++;
    }
    if(str[pos]>='5') str[pos-1]+=1;
    str[pos]=0;
    for(int i=pos;i>=0;--i)
    {
        if(str[i]=='.') break;
        if(str[i]>'9') str[i-1]++,str[i]='0';
    }
    printf("%s",str);
}
int main()
{
    read(n),read(k),S=n+1,t=S+1,add(s,S,k,1);
    for(int i=1;i<=n;++i) scanf("%Lf",&as[i]);
    for(int i=1;i<=n;++i) read(am[i]);
    for(int i=1;i<=n;++i)
        if(am[i]&&as[i]>eps)
            add(S,i,am[i],as[i]);
    for(int i=1;i<=n;++i)
    {
        int v;
        read(v);
        if(v) add(i,t,inf,1);
    }
    while(1)
    {
        int x,y,m;
        ld s;
        read(x),read(y);
        if(x==-1&&y==-1) break;
        scanf("%Lf",&s),read(m);
        add(x,y,m,s),add(y,x,m,s);
    }
    dinic();
    if(ans>eps) print();
    else puts("0");
    return 0;
}
```

---

## 作者：xtx1092515503 (赞：2)

因为实在太坑人了，就写一篇题解。

------

首先，本题费用流的模型是很明显的——我军总部连到每个人，两个人之间互相连边，然后每个人再连到敌军总部。

但是，这里的费用却比较非常规——它是路径上所有边的边权的**乘积**。

若仍然暴力跑费用流的话，可能会出现除零这种奇怪的东西，因此对所有边权取个 $\ln$ 即可化积为和，然后最后把跑出来的最小费用再给它 $\exp$ 回去就行了。

需要注意的是，因为这题的边权都是实数，就可能会把 SPFA 可以处理的零环给判成负环，于是在比较大小的时候得手动加一个 $\text{eps}$ 上去。

同时，注意输出——“保留 $5$ 位有效数字”的意思是，找到小数点后第一个非 $0$ 位，从该位往后再取 $5$ 位作四舍五入，并非保留 $5$ 位小数。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int inf=-0x3f3f3f3f;
const double eps=1e-8;
const double lim=-100;
int n,m,s;
namespace MCMF{
	const int N=310,M=2000000;
	int head[N],cnt,fr[N],S,T,flow;
	double cost,dis[N];
	struct node{
		int to,next,val;
		double cost;
	}edge[M];
	void ae(int u,int v,int w,double c){
//		printf("%d %d %d %lf\n",u,v,w,c);
		edge[cnt].cost=c,edge[cnt].next=head[u],edge[cnt].to=v,edge[cnt].val=w,head[u]=cnt++;
		edge[cnt].cost=-c,edge[cnt].next=head[v],edge[cnt].to=u,edge[cnt].val=0,head[v]=cnt++;
	}
	queue<int>q;
	bool in[N];
	bool SPFA(){
		for(int i=1;i<=T;i++)dis[i]=inf;dis[S]=0,q.push(S),in[S]=true;
		while(!q.empty()){
			int x=q.front();q.pop(),in[x]=false;
			for(int i=head[x];i!=-1;i=edge[i].next){
				if(!edge[i].val)continue;
				if(dis[edge[i].to]+eps<dis[x]+edge[i].cost){
					dis[edge[i].to]=dis[x]+edge[i].cost,fr[edge[i].to]=i;
					if(!in[edge[i].to])in[edge[i].to]=true,q.push(edge[i].to);
				}
			}
		}
		if(dis[T]<=inf+eps)return false;
		int x=T,mn=0x3f3f3f3f;
		while(x!=S)mn=min(mn,edge[fr[x]].val),x=edge[fr[x]^1].to;
		flow+=mn,cost+=dis[T]*mn,x=T;
		while(x!=S)edge[fr[x]].val-=mn,edge[fr[x]^1].val+=mn,x=edge[fr[x]^1].to;
		return true;
	}
}
using namespace MCMF;
double sft[310];
char str[310];
void roundprint(double x){
	sprintf(str,"%.10lf",x);
	int len=0,sml=-1;
	for(len=0;sml<4;len++)if(str[len]>'0'&&str[len]<='9'||sml!=-1)sml++;
	if(str[len]>='5')str[len-1]++;str[len]='\0';
	while(str[len-1]!='.'&&str[len-1]>'9')str[len-1]='0',str[len-2]++,len--;
	printf("%s\n",str);
}
int main(){
	scanf("%d%d",&n,&m),s=n+1,S=n+2,T=n+3,memset(head,-1,sizeof(head)),ae(S,s,m,0);
	for(int i=1;i<=n;i++)scanf("%lf",&sft[i]);
	for(int i=1,x;i<=n;i++){
		scanf("%d",&x);
		if(sft[i]>eps)ae(s,i,x,log(sft[i]));
		else ae(s,i,x,lim);
	}
	for(int i=1,x;i<=n;i++){
		scanf("%d",&x);
		if(x)ae(i,T,0x3f3f3f3f,0);
	}
	while(true){
		int x,y,z;double c;
		scanf("%d%d",&x,&y);
		if(x==-1&&y==-1)break;
		scanf("%lf%d",&c,&z);
		if(c>eps)ae(x,y,z,log(c)),ae(y,x,z,log(c));
		else ae(x,y,z,lim),ae(y,x,z,lim);
	}
	while(SPFA());
	if(flow!=m)puts("0");else roundprint(exp(cost));
	return 0;
}
```



---

## 作者：zyxjeek (赞：0)

> 推荐前往[博客](https://soth.netlify.app/2025/03/02/p5814-ctsc2001-%E7%BB%88%E6%9E%81%E6%83%85%E6%8A%A5%E7%BD%91/)观看
## 1.题目描述

有 $N$ 名间谍，分别用数字 $1,2,\cdots,N$ 编号。间谍可以双向联系。$[0,1]$ 的实数 $S_{i,j}$ 表示第 $i$ 和第 $j$ 名间谍联系的安全程度，正整数 $M_{i,j}$ 表示他们这次联系时能够互相传递的消息的最大数目。$[0,1]$ 的实数 $AS_j$ 表示总部与间谍 $j$ 之间进行联系的安全程度，正整数 $AM_j $ 表示总部和间谍 $j$ 之间传递的消息的最大数目。消息从间谍手中交到敌军的过程是绝对安全的。

现在总部有 $K$ 条假消息，求传递所有消息的最大安全程度。

## 2.思路

本题可以用费用流模型解决。每条边 $(i, j)$ 的流量上限为 $M_{i, j}$，费用为 $S_{i, j}$。建图时要加入三个点 $S, s, t$，其中 $S$ 向 $s$ 连一条费用是 $1$，流量上限是 $K$ 的边，保证最大流不超过 $K$。$s$ 和 $t$ 分别表示总部和敌军总部，$s$ 向所有点 $i$ 连流量上限为 $AM_i$，费用为 $AS_i$ 的边，所有点向 $t$ 连流量上限为 $\infty$，费用为 $1$ 的边。其余连双向边建图即可。

对与本题，费用流的`bfs`过程需要处理 $s$ 到每个点路径的最大安全度乘积。即 $dis_i = \max_{(j, i) \in E} \{dis_j * S_{j, i}\}, dis_s=1$。每次产生新的流 $f$ 时，将答案加上 $dis_t ^ f$。注意在各种比大小时加一个 $eps$。

## 3.注意事项

- 与常规费用流不同，本题的费用累计方式是乘而不是加。建图时一组反向边的费用应该互为**倒数**。
- 特别注意本题的输出，由于需要保留 $5$ 位有效数字，所以向 $0.01$ 这种答案要补足到 $0.010000$，不能直接使用`cout.precision(5)`，手写一个输出函数即可解决问题。

## 4.代码

```c++
#include <bits/stdc++.h>
using namespace std;

using ld = long double;
const int N = 310;
const ld eps = 1e-12;
struct Edge {
    int v, rev, c;
    ld w;
};
vector<Edge> gh[N];
int cur[N], M[N];
ld dis[N], Ans = 1, S[N], dep[N];
bitset<N> vis;
ld qpow(ld a, int b) {
    ld ans = 1;
    for (; b; b >>= 1) {
        if (b&1) ans *= a;
        a *= a;
    }
    return ans;
}
void add(int u, int v, int c, ld w) {
    // vector存图记录反向边编号。
    gh[u].push_back({v, (int)gh[v].size(), c, w});
    gh[v].push_back({u, (int)gh[u].size()-1, 0, 1.0/w});
}
ld bfs(int s, int t) {
    memset(dis, 0, sizeof(dis));
    memset(dep, 0, sizeof(dep));
    vis = 0;
    dis[s] = 1, dep[s] = 1;
    queue<int> q;
    q.push(s);
    vis[s] = true;
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        vis[u] = false;
        for (auto e : gh[u]) {
            if (e.c > 0 && dis[u] * e.w - dis[e.v] > eps) {
                dis[e.v] = dis[u] * e.w, dep[e.v] = dep[u] + 1;
                if (!vis[e.v]) q.push(e.v);
            }
        }
    }
    return dis[t];
}
int dfs(int u, int t, int fl) {
    if (u == t || !fl) return fl;
    int ret = 0;
    for (int& i = cur[u]; i < gh[u].size(); i++) {
        auto& e = gh[u][i];
        if (e.c > 0 && abs(dis[e.v] - dis[u] * e.w) <= eps && dep[e.v] == dep[u] + 1) {
            int f = dfs(e.v, t, min(fl, e.c));
            if (f > 0) {
                ret += f;
                fl -= f;
                e.c -= f;
                gh[e.v][e.rev].c += f;
                if (fl == 0) break;
            }
        }
    }
    return ret;
}
int dinic(int s, int t) {
    int ans = 0;
    while (bfs(s, t) > eps) {
        memset(cur, 0, sizeof(cur));
        int x;
        while ((x = dfs(s, t, INT_MAX)))
            ans += x, Ans *= qpow(dis[t], x);
    }
    return ans;
}
void deal() {
    char ch[40];
    double ans = Ans;
    sprintf(ch,"%.15lf\n",ans);
    int sum = 0,i;
    for (i = 0; sum < 5; i++)
        if ((ch[i]!='0' && ch[i]!='.') | (sum>0))
            sum++;
    if (ch[i] >= '5')
        ch[i-1]++;
    ch[i] = 0;
    for(; i >= 0; i--) {
        if (ch[i] == '.') break;
        else if (ch[i] > '9')
            ch[i-1]++, ch[i] = '0';
    }
    printf("%s\n",ch);
}

int main() {
    // freopen("agent.in", "r", stdin);
    // freopen("agent.out", "w", stdout);
    int n, k;
    cin >> n >> k;
    int s = n+1, t = n+2, s1 = n+3;
    for (int i = 1; i <= n; i++)
        cin >> S[i];
    for (int i = 1; i <= n; i++)
        cin >> M[i];
    for (int i = 1; i <= n; i++)
        add(s, i, M[i], S[i]);
    for (int i = 1; i <= n; i++) {
        int ok;
        cin >> ok;
        if (ok)
            add(i, t, INT_MAX, 1);
    }
    add(s1, s, k, 1);
    while (true) {
        int u, v, c;
        ld w;
        cin >> u >> v;
        if (u == -1 && v == -1) break;
        cin >> w >> c;
        add(u, v, c, w);
        add(v, u, c, w);
    }
    int fl = dinic(s1, t);
    if (fl != k) cout << "0.0000" << endl;
    else deal();
    return 0;
}
```


---

The End

---

## 作者：Dr_Glitch (赞：0)

# 最大费用最大流
[题目传送门](https://www.luogu.com.cn/problem/P5814)
## 分析
分析题目内容后，基本确定了费用流的做法，因为要方案的安全程度最高，所以是最大费用最大流，其中流量用于统计假消息是否可以完全传达，费用用于统计安全程度。

一眼看上去本题是很模板的费用流，但是在费用的计算方法上和常规的费用流有很大的区别。原始的费用计算方法是**流量乘以单位费用**，而本题中费用的计算方法则是**单位费用的流量次方**，退流时也**不是按负费用**计算，而是**原费用的倒数**计算，这里用快速幂进行费用的计算即可。
## 建图分析
设 $S$ 为源点，$s$ 为盟军总部，$t$ 为敌军情报部门（即汇点），$spy$ 表示可以和总部或其他间谍交流的间谍（即流量和费用不为 $0$）。

- $S \to s$ 连接一条流量为 $k$，费用为 $1$ 的单向边，表示总共有 $k$ 条假消息需要透露；
- $s \to spy_i$ 连接一条流量为 $AM_i$，费用为 $AS_i$ 的单向边，表示总部和间谍之间的交流；
- $spy_i \leftrightarrow spy_j$ 连接一条流量为 $M_{i,j}$，费用为 $S_{i,j}$ 的双向边，表示间谍之间的交流；
- $spy_i \to t$ 连接一条流量为 $inf$，费用为 $1$ 的单向边，表示间谍和敌军情报部门的交流。

## 细节提示

1. 有一些费用流的写法习惯在 dfs 过程中计算费用，这里可能会导致常数较大或较难实现推流操作的问题，所以建议在 dfs 结束以后再进行费用的计算；
2. 本题的要求是**保留 $5$ 位有效数字**，这里需要对结果进行处理，直接用 `setprecision(5)` 是会出问题的，原因是当小数位数较大时会自动输出**科学计数法**的结果，这和小数形式不同，会导致 WA 掉。具体转化方法详见代码，我的代码里用了一个叫 `stringstream` 的东西，可以很便捷地将 `int` 类型和 `string` 类型进行转换，用法和 `cin` 和 `cout` 类似，其余读者可以自行了解；
3. 其余细节详见代码部分。

## 代码
```cpp
#include<bits/stdc++.h>
#define init read()
using namespace std;
const int INF=0x7f7f7f7f;
const double eps=1e-12; //注意精度限制
const int N=305;
int n,k,s,t,S,tot=1,anss=0,cnt=0;
int am[N];
double as[N],ans=1;
bool vis[N];
int First[N*N],cur[N*N],Next[N*N],to[N*N],c[N*N];
double w[N*N],dis[N*N];
stringstream qwq; //用于 int 类型和 string 类型之间的转换
char opt[15];
inline int read()
{
	int mmm=0,ff=1;char xx=getchar();
	while((xx<'0'||xx>'9')&&xx!='-')xx=getchar();
	if(xx=='-')ff=-1,xx=getchar();
	while(xx>='0'&&xx<='9')
	mmm=mmm*10+xx-'0',xx=getchar();
	return mmm*ff;
}
inline void write(int x)
{
	if(x<0)
	{
		putchar('-');
		x=-x;
	}
	if(x>9)write(x/10);
	putchar('0'+x%10);
}
inline double quick_pow(double x,int y)
{
	double res=1;
	while(y)
	{
		if(y&1)res*=x;
		x*=x;
		y>>=1;
	}
	return res;
}
inline void Add(int u,int v,int flow,double cost)
{
	Next[++tot]=First[u];
	First[u]=tot;
	to[tot]=v;
	c[tot]=flow;
	w[tot]=cost;
	Next[++tot]=First[v];
	First[v]=tot;
	to[tot]=u;
	c[tot]=0;
	w[tot]=1.0/cost; //注意反向边的费用是原费用的倒数
}
inline bool spfa() //使用 deque 随机加入节点，防止 spfa 被卡
{
	memset(vis,false,sizeof(vis));
	for(int i=1;i<=n+2;i++)dis[i]=0; //s 点不用赋为 0
	deque<int>q;dis[s]=1;vis[s]=true;
	q.emplace_back(s);
	while(!q.empty())
	{
		int u=q.front();q.pop_front();
		vis[u]=false;
		for(int i=First[u];i;i=Next[i])
		{
			int v=to[i];
			if(c[i]>0&&w[i]!=0&&dis[u]*w[i]-dis[v]>eps)
			{
				dis[v]=dis[u]*w[i];
				if(!vis[v])
				{
					vis[v]=true;
					if(!q.empty()&&dis[v]<dis[q.front()])q.emplace_front(v);
					else q.emplace_back(v);
				}
			}
		}
	}
	return dis[t]!=0;
}
inline int dfs(int u,int f)
{
	if(u==t||f==0)
	{
		if(u==t)vis[t]=true;
		return f;
	}
	int used=0;vis[u]=true;
	for(int &i=cur[u];i;i=Next[i])
	{
		int v=to[i];
		if(c[i]>0&&w[i]!=0&&dis[v]-dis[u]*w[i]<=eps&&!vis[v])
		{
			int tmp=dfs(v,min(f,c[i]));
			if(!tmp)continue;
			c[i]-=tmp;c[i^1]+=tmp;
			used+=tmp;f-=tmp;
			if(f==0)break;
		}
	}
	if(used==0)dis[u]=0;
	return used;
}
inline int dinic()
{
	int mflow=0;
	while(spfa())
	{
		vis[t]=true;
		while(vis[t])
		{
			memset(vis,false,sizeof(vis));
			memcpy(cur,First,sizeof(First));
			int tmp=dfs(s,INF);
			mflow+=tmp;
			ans*=quick_pow(dis[t],tmp); //得到流量后再计算费用
		}
	}
	return mflow;
}
int main()
{
	n=init;k=init;S=n+1;t=n+2;s=n+3;Add(s,S,k,1);
	for(int i=1;i<=n;i++)scanf("%lf",&as[i]);
	for(int i=1;i<=n;i++)am[i]=init;
	for(int i=1;i<=n;i++)
	{
		if(am[i])Add(S,i,am[i],as[i]);
		int x=init;
		if(x)Add(i,t,INF,1.0);
	}
	while(true)
	{
		int x=init,y=init;
		if(x==-1&&y==-1)break;
		double ss;scanf("%lf",&ss);
		int m=init;if(ss==0)continue;
		Add(x,y,m,ss);Add(y,x,m,ss);
	}
	if(dinic()!=k)
	{
		puts("0");return 0;
	}
	while(ans<10000)
	{
		ans*=10;cnt++;
	}
	anss=round(ans);
	ans=anss;string opt1,opt2="lf\n";
	qwq<<cnt;qwq>>opt1; //int 和 string 的转换
	while(cnt--)
	{
		ans=ans/10;
	}
	opt[0]='%';opt[1]='0';opt[2]='.';int i=0;
	for(;(unsigned)i<opt1.size();i++)opt[i+3]=opt1[i];
	for(int j=0;(unsigned)j<opt2.size();j++)opt[i+3+j]=opt2[j];
	printf(opt,ans);
	return 0;
}
```

---


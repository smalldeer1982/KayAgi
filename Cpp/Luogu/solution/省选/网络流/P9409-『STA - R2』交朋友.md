# 『STA - R2』交朋友

## 题目背景

> 找呀找呀找朋友 找到一个好朋友 敬个礼呀握握手 你是我的好朋友

## 题目描述

幼儿园开学啦！  

在开学前，有的小朋友会准备一个毛绒玩具，可以分享给其他小朋友~  

具体的，一共有 $t$ 天，每天的座位表可以表示成一张无向图。每天**有毛绒玩具**的小朋友一定会选择一个在这一天和他坐在一起的小朋友，并把毛绒玩具送给他。 

但是老师规定，每个人只能有一个毛绒玩具。  

在这里，我们认为每天每个人会先送出玩具，再从别人那里接受。  

问初始时最多可以有多少小朋友有毛绒玩具。  

注意：这意味着一个合法的传递过程中不能出现存在小朋友送不出毛绒玩具或者存在小朋友拥有超过一个毛绒玩具的情况，一个初始局面是合法的当且仅当存在一种合法的传递过程。

## 说明/提示

**样例解释**

样例 1 解释：满足条件的唯一方案为初始毛绒玩具位于 $1$ 和 $2$。

样例 2 解释：满足条件的一组方案为初始毛绒玩具位于 $1$ 和 $3$。

***
**数据范围**

**本题采用捆绑测试。**

$$
\newcommand{\arraystretch}{1.5}
\begin{array}{c|c|c|c}\hline\hline
\textbf{Subtask} & \bm t\le & \bm{n,m}\le & \textbf{分值} \\\hline
\textsf{1} & 1 & 3\times 10^4 & 5 \\\hline
\textsf{2} & 10 & 2 & 5 \\\hline
\textsf{3} & 10 & 100 & 20 \\\hline
\textsf{4} & 10 & 3\times10^3& 70 \\\hline\hline
\end{array}
$$
对于 $100\%$ 的数据，$1\le t\le10$，$1\le n,m\le  3\times10^4$，但是注意 $t,n,m$ 的范围不会同时达到上界。

保证给出的每张图没有重边、自环。

## 样例 #1

### 输入

```
1 2
1
1 2```

### 输出

```
2```

## 样例 #2

### 输入

```
3 5
4
1 2
1 3
1 4
1 5
4
1 2
2 3
3 4
4 5
4
1 5
5 2
2 4
4 3```

### 输出

```
2```

# 题解

## 作者：xuan_gong_dong (赞：9)

~~刚学最大流，然后随机跳题就给我看这个题。~~
## 题面
[P9409 『STA - R2』交朋友](https://www.luogu.com.cn/problem/P9409)

## 分析
我们不妨假设**同一个人的每一天**不是**同一个点**。在求网络流中，我们一般会将图上的点进行分层，那对于这个题，容易发现某一天的流量一定是前一天传下来。那不就是**分层**吗。于是乎，我们可以将第 $t$ 天当作第 $t$ 层。

对于同一个点，它不能在同一天将自己的毛绒玩具交给不同的**两个人**，那这种情况该怎么处理呢，其实我们只需要将这个点进行**拆点**不就好了嘛，然后入点连接出点，流量最大为 $1$。

在对于编号本是**同一个点**，**层次不同**的点，我们其实可以去令第 $i$ 天的第 $j$ 个的入点定为 $2 \times (i-1) \times t+j$，出点定为 $2 \times (i-1) \times t+n+1$。

超级原点 $s$ 连接第一层的所有入点，超级汇点 $T$ 连最后一层的所有出，注意这里的**超级原点的出边**和**超级汇点的入边**流量都应该为 $1$。

## Code
```cpp
#include<bits/stdc++.h>
//#define int long long
const int inf=0x7f7f7f7f;
using namespace std;
struct node
{
	int nxt,to,w;
}edge[1200010];
int head[600010],tot=1;
int now[600010];
void add(int x,int y,int w)
{
	edge[++tot].nxt=head[x];
	edge[tot].to=y;
	edge[tot].w=w;
	head[x]=tot;
}
inline int read()
{
	int x=0;
	char c=getchar();
	while(!isdigit(c))
	{
		c=getchar();
	}
	while(isdigit(c))
	{
		x=(x<<3)+(x<<1)+(c^48);
		c=getchar();
	}
	return x;
}
int n,s,t,T;
int ans;
int dep[600010];
queue<int> q;
inline int bfs()
{

	while(!q.empty())q.pop();
	memset(dep,inf,sizeof(dep));
	dep[s]=0;
	q.push(s);
	now[s]=head[s];;
	while(!q.empty())
	{
		int x=q.front();
//		cout<<"x="<<x<<endl;
		q.pop();
		for(int i=head[x];i;i=edge[i].nxt)
		{
			int to=edge[i].to,w=edge[i].w;
			if(w>0&&dep[to]==inf)
			{
				dep[to]=dep[x]+1;
				q.push(to);
				now[to]=head[to];
				if(to==t)return 1;
			}
		}
		
	}
	return 0;
}
inline int dfs(int id,int sum)
{
	if(id==t)
	{
		return sum;
	}
	int k=0,cnt=0;
	for(int i=now[id];i&&sum>0;i=edge[i].nxt)
	{
		int to=edge[i].to,w=edge[i].w;
		if(dep[to]==dep[id]+1&&w>0)
		{
			k=dfs(to,min(sum,w));
			if(k==0)dep[to]=inf;
			edge[i].w-=k;
			edge[i^1].w+=k;
			cnt+=k;
			sum-=k;
		}
	}
//	cout<<cnt<<endl;
	return cnt;
}
int main()
{
	T=read(),n=read(),s=2*n*T+1,t=s+1;
	for(int i=1;i<=T;i++)
	{
		int m;
		m=read();
		for(int j=1;j<=m;j++)
		{
			int u,v;
			u=read(),v=read();
			add((i-1)*2*n+u,i*2*n-n+v,1);
			add(i*2*n-n+v,(i-1)*2*n+u,0);
			add((i-1)*2*n+v,i*2*n-n+u,1);
			add(i*2*n-n+u,(i-1)*2*n+v,0);	
		}
	}
	for(int i=1;i<T;i++)
	{
		for(int j=1;j<=n;j++)
		{
			add(i*2*n+j-n,i*2*n+j,1);	
			add(i*2*n+j,i*2*n+j-n,0);	
		}
	}
	for(int i=1;i<=n;i++)
	{
		add(s,i,1);
		add(i,s,0);
		add(i+2*T*n-n,t,1);
		add(t,i+2*T*n-n,0);
	}
	while(bfs())
	{
//		cout<<"QWQ";
		ans+=dfs(s,inf);
	}
	printf("%d",ans);
	return 0;
}
```


---

## 作者：___w (赞：8)

### [P9409 『STA - R2』交朋友](https://www.luogu.com.cn/problem/P9409)

#### 题意简述
有 $t$ 天，共 $n$ 个小朋友构成一张无向图，有的小朋友有毛绒玩具，有以下几个要求：

- 有毛绒玩具的小朋友会选择一个在这一天和他坐在一起的且没有毛绒玩具的小朋友。
- 每个人至多只有一个毛绒玩具。

求初始时最多可以有多少小朋友有毛绒玩具，使得不存在小朋友送不出毛绒玩具。

#### 题目分析
因为有毛绒玩具的小朋友要把毛绒玩具递给其他人，就像网络流中的每一个点能流则就流出去一般，所以考虑网络流。有 $t$ 天，每天的小朋友的状态各不相同，因为可能今天可以给这个人但每天就可能不可以给这个人，所以我们把所有的点分为 $t+1$ 层，每一层有 $n$ 个节点，表示哪一天的哪个小朋友。建立超级源点，连接第 $1$ 天的每个小朋友，容量为 $1$，表示每个小朋友可以拥有一个毛绒玩具。再建立超级汇点，从第 $t+1$ 天的小朋友连接到超级汇点，容量为 $1$，表示最后的毛绒玩具交上去，就可以得到最多可以有多少小朋友有毛绒玩具了。至于两个相邻的小朋友 $u,v$，只需要把今天的 $u$ 与明天的 $v$ 及今天的 $v$ 与明天的 $u$ 建条边，容量为 $1$。如下图所示，为样例 $2$ 的图。

![图](https://cdn.luogu.com.cn/upload/image_hosting/s7fnhyau.png)

但是呢，题目还说到每个人至多只有一个毛绒玩具，所以考虑把每个小朋友拆成两个点，分为入点和出点，从入点连接到出点，容量为 $1$。这样就可以保证每个小朋友的每一天就最多只有一只毛绒玩具了。建完模型以后得出来的最大流即为答案，就可以套用网络流模板了，代码如下。

#### 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 7e6, M = 2e6, inf = 1e9;
struct edge {
	int to, next, w;
} e[M];
int T, n, m, s, t, ans, tot = 1, d[N], cur[N], head[N];
void add(int x, int y, int z) {
	e[++tot] = (edge){y, head[x], z}, head[x] = tot;
	e[++tot] = (edge){x, head[y], 0}, head[y] = tot;
}
bool bfs() {
	memset(d, 0, sizeof(d)), d[s] = 1;
	queue <int> q; q.push(s);
	while (!q.empty()) {
		int x = q.front(); q.pop();
		for (int i = head[x]; i; i = e[i].next)
			if (e[i].w && !d[e[i].to]) {
				q.push(e[i].to); d[e[i].to] = d[x]+1;
				if (e[i].to == t) return 1;
			}
	}
	return 0;
}
int dfs(int x, int flow) {
	if (x == t) return flow;
	int k, res = 0;
	for (int i = cur[x]; i && flow; i = e[i].next) {
		cur[x] = i; int y = e[i].to;
		if (e[i].w && d[y] == d[x]+1) {
			k = dfs(y, min(flow, e[i].w));
			if (!k) d[y] = 0;
			e[i].w -= k, e[i^1].w += k;
			res += k, flow -= k;
		}
	}
	return res;
}
int id(int i, int x, int d) { return i*n*2+x*2+d; }
int main() {
	cin >> T >> n;
	s = (T+1)*n*2+2, t = s+1;
	for (int k = 0; k <= T; ++k)
		for (int i = 1; i <= n; ++i)
			add(id(k, i, 0), id(k, i, 1), 1);//入点和出点 
	for (int i = 1; i <= n; ++i) add(s, id(0, i, 0), 1), add(id(T, i, 1), t, 1);//超级源点和超级汇点 
	for (int k = 0, u, v; k < T; ++k) {
		cin >> m;
		while (m--) {
			cin >> u >> v;
			add(id(k, u, 1), id(k+1, v, 0), 1);
			add(id(k, v, 1), id(k+1, u, 0), 1);
			//由于是无向图，所以要建两条边 
		}
	}
	while (bfs()) {
		memcpy(cur, head, sizeof(head));
		ans += dfs(s, inf);
	}
	cout << ans;
	return 0;
}
```

---

## 作者：hrgd (赞：8)

此题有一定难度但又没那么有难度，看你是不是一开始就能往正解想了。

如果你一开始就在找图的性质你会发现你连第一档都不会做，于是我们来想想第一档。

你所选的每一个点都需要有一个相邻的不同的终点，很像匹配，于是拆点，发现它就是匹配。

那么多层也就是和一层几乎一模一样的了，分为 $t+1$ 层，$S$ 向第一层每个点连边，$t+1$ 层每个点向 $T$ 连边。对每个点拆点，入点向出点连边，对于每一层的每一条边 $(u,v)$，$u$ 的出点向下一层的 $v$ 的入点连边，$v$ 的出点向下一层的 $u$ 的入点连边。这样跑一个最大流，每一条流都代表一个点的运动轨迹，显然保证了每个点在每一层都不会相交。

时间复杂度 $O(F(n+m))=O(n^2t)$，我代码里特判了第一个包是因为一开始数组开小了。

```
int t,n,m,I[12][maxn],O[12][maxn],S,T,cnt,ans;
int beg[maxn],nex[maxn],to[maxn],w[maxn],e=1,dep[maxn];
inline void add(int x,int y,int z){
	++e;nex[e]=beg[x];beg[x]=e;to[e]=y;w[e]=z;
	++e;nex[e]=beg[y];beg[y]=e;to[e]=x;w[e]=0;
}
queue<int>Q;
inline int bfs(){
	for(int i=1;i<=cnt;i++)dep[i]=0;
	dep[S]=1;Q.push(S);
	while(!Q.empty()){
		int x=Q.front();Q.pop();
		for(int i=beg[x];i;i=nex[i]){
			int t=to[i];
			if(w[i]&&!dep[t]){
				dep[t]=dep[x]+1;
				Q.push(t);
			}
		}
	}return dep[T];
}
inline int dfs(int x,int lim){
	if(x==T||!lim)return lim;
	int res=0;
	for(int i=beg[x];i&&lim;i=nex[i]){
		int t=to[i];
		if(dep[t]==dep[x]+1&&w[i]){
			int f=dfs(t,min(lim,w[i]));
			w[i]-=f;w[i^1]+=f;
			res+=f;lim-=f;
		}
	}return res;
}
inline void solve1(){
	S=n+n+1,T=cnt=S+1;m=read();
	for(int i=1;i<=n;i++)add(S,i,1),add(i+n,T,1);
	for(int i=1,x,y;i<=m;i++)
		x=read(),y=read(),add(x,y+n,1),add(y,x+n,1);
	while(bfs())ans+=dfs(S,inf);
	printf("%d\n",ans);
}
int main(){
	t=read(),n=read();
	if(t==1)return solve1(),0;
	S=++cnt,T=++cnt;
	for(int i=1;i<=t+1;i++)
		for(int j=1;j<=n;j++)I[i][j]=++cnt,O[i][j]=++cnt;
	for(int i=1;i<=n;i++)
		add(S,I[1][i],1),add(O[t+1][i],T,1);
	for(int i=1;i<=t+1;i++)
		for(int j=1;j<=n;j++)add(I[i][j],O[i][j],1);
	for(int i=1;i<=t;i++){
		m=read();
		for(int j=1,x,y;j<=m;j++){
			x=read(),y=read();
			add(O[i][x],I[i+1][y],1);
			add(O[i][y],I[i+1][x],1);
		}
	}while(bfs())ans+=dfs(S,inf);
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：BitByBit (赞：4)

### 题意
有 $k$ 轮操作，每次给定一张无向图，拥有毛绒玩具的小朋友一定会向相邻的节点传递他的毛绒玩具，并且同一时刻一个人不能拥有超过 $1$ 个毛绒玩具，问初始时最多有多少人能拥有毛绒玩具。
### 分析
首先考虑只有一轮操作的情况。因为每个人只能拥有一个毛绒玩具，所以每个人只能接受一个毛绒玩具。把每个人拆成操作前的人和操作后的人，就形成一张二分图。题目求的就是二分图最大匹配。然后跑网络流就可以。  
当有 $k$ 轮时就建 $k$ 张二分图然后拼到一起，可以想象成昨天的人把一个毛绒玩具传给今天的同一个人。因此图看起来是这样的：
![](https://cdn.luogu.com.cn/upload/image_hosting/n1bu8919.png)
其中红色圈起来的是同一个人的两部分。因为每个人只能拥有一个毛绒玩具，所以昨天的人和今天的人之间建容量为 $1$ 的边，然后给定的无向图中相邻的两个点操作前和操作后的点之间建容量为 $1$ 的边。源点和第一次操作前的点连边，最后一次操作后的点和汇点连边，然后跑最大流就可以了。
### code
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define infll 0x3f3f3f3f3f3f3f3f
#define N 200010
#define M 1000010
int n,m,s,t,tot=1;
ll maxflow;
int Head[N],Son[M],Next[M];
ll Cap[M];
deque<int>Q;
int Cur[N];
ll Dis[N];
inline void add(int x,int y,ll z)
{
	Son[++tot]=y;
	Cap[tot]=z;
	Next[tot]=Head[x];
	Head[x]=tot;
}
bool bfs(void)
{
	memset(Dis,0x3f,sizeof(Dis));
	memcpy(Cur,Head,sizeof(Cur));
	Q.clear();
	Q.push_back(s);
	Dis[s]=0;
	while(!Q.empty())
	{
		int x=Q.front();
		Q.pop_front();
		for(int i=Head[x];i;i=Next[i])
		{
			int y=Son[i];
			if(Cap[i]>0&&Dis[y]==infll)
			{
				Q.push_back(y);
				Dis[y]=Dis[x]+1;
				if(y==t)return 1;
			}
		}
	}
	return 0;
}
ll dfs(int x,ll flow)
{
	if(x==t)return flow;
	ll res=0;
	for(int i=Cur[x];i&&flow;i=Next[i])
	{
		int y=Son[i];
		Cur[x]=i;
		if(Cap[i]>0&&Dis[y]==Dis[x]+1)
		{
			ll k=dfs(y,min(flow,Cap[i]));
			if(!k)Dis[y]=infll;
			Cap[i]-=k;
			Cap[i^1]+=k;
			res+=k;
			flow-=k;
		}
	}
	return res;
}
void Dinic(void)
{
	while(bfs())maxflow+=dfs(s,infll);
}
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	int k;
	cin>>k>>n;
	s=n*(k+1<<1)+1;
	t=n*(k+1<<1)+2;//建超级源点和汇点
	for(int i=1;i<=n;i++)
	{
		add(s,i,1);
		add(i,s,0);
	}
	for(int i=1;i<=k;i++)
	{
		int p=((i<<1)-1)*n,q=(i<<1)*n;
		cin>>m;
		for(int j=1;j<=m;j++)
		{
			int x,y;
			cin>>x>>y;
			add(x+p,y+q,1);
			add(y+q,x+p,0);
		 	add(y+p,x+q,1);
			add(x+q,y+p,0);
//操作前和操作后建边
		}
	}
	for(int i=1;i<=k+1;i++)
	{
		int p=((i<<1)-2)*n,q=((i<<1)-1)*n;
		for(int j=1;j<=n;j++)
		{
			add(j+p,j+q,1);
			add(j+q,j+p,0);
		}//昨天的自己和今天的自己建边
	}
	int p=n*((k<<1)+1);
	for(int i=1;i<=n;i++)
	{
		add(i+p,t,1);
		add(t,i+p,0);
	}
	Dinic();
//这里我用Dinic算法求最大流
	cout<<maxflow;
	return 0;
}
```

---

## 作者：jijidawang (赞：4)

考虑用最大流模型描述 .

考虑每个点拆成入点和出点，入点向出点连边，就限制好了每个点只能走一次 .

每个点分成 $t$ 层，如果第 $i$ 张图有边 $(a_i,a_{i+1})$ 就连第 $i$ 层的 $a_i$ 出点与第 $i+1$ 层的 $a_{i+1}$ 入点就行了 .

然后建个虚拟源汇 $S,T$，$S$ 连所有第一层的，所有 $t+1$ 层的连 $T$ .

以上所有边容量都为 $1$ .

然后答案就是 $S$ 到 $T$ 的最大流，这一点很显然，然后就做完了 .

对于容量只有 $1$ 的 Dinic 复杂度是 $\Theta(n\min\{n^{2/3},m^{1/2}\})$ 的，其中 $n$ 是点数 $m$ 是边数，大概就能过了，并且数据也没把 Dinic 卡的很满 .

（验题人的 HLPP 被 Subtask #1 整 TLE 了 233）

以下是一份实现：
```cpp
int T, n, m;
inline int id(int lev, int idx, bool io){return (lev * (n+1) << 1) + (idx << 1) + io;}
int main()
{
	scanf("%d%d", &T, &n);
	int s = 0, t = id(T+10, n, 0);
	for (int i=1; i<=n; i++) F.addedge(s, id(0, i, 0), 1), F.addedge(id(T, i, 1), t, 1);
	for (int _=0; _<=T; _++)
		for (int i=1; i<=n; i++) F.addedge(id(_, i, 0), id(_, i, 1), 1);
	for (int _=0; _<T; _++)
	{
		scanf("%d", &m);
		for (int i=0, u, v; i<m; i++)
		{
			scanf("%d%d", &u, &v);
			F.addedge(id(_, v, 1), id(_+1, u, 0), 1);
			F.addedge(id(_, u, 1), id(_+1, v, 0), 1);
		}
	}
	printf("%d\n", F.maxflow(s, t));
	return 0;
}
```

---

## 作者：bochibochi (赞：2)

考虑使用最大流解决。

先将每个点分成 $t+1$ 层，然后将每个点拆成入点和出点。考虑如何连边：

+ 如果原图中第 $i$ 天从 $u$ 到 $v$ 有边，那么就从第 $i$ 层的出点 $u$ 向第 $i+1$ 层的入点 $v$ 连边。
+ 建立超级源点和汇点，从源点向第一层每个入点连边，最后一层每个出点向汇点连边。
+ 由于每个小朋友手中最多只能有一个玩具，所以入点与其对应的出点之间连容量为 $1$ 的边。

最后跑一边最大流即可。

```cpp
#include<iostream>
#include<queue>
#include<cstring>
#include<vector>
using namespace std;
const int maxn = 600005;
int head[maxn], to[maxn], v[maxn], nxt[maxn], cnt = 1;
void add(int a, int b, int val)
{
    ++cnt;
    to[cnt] = b;
    v[cnt] = val;
    nxt[cnt] = head[a];
    head[a] = cnt;
}
int dep[maxn], cur[maxn];
queue<int> q;
bool bfs(int s, int t)
{
    memcpy(cur, head, sizeof(head));
    memset(dep, 0, sizeof(dep));
    dep[s] = 1;
    q.emplace(s);
    while(!q.empty())
    {
        int p = q.front(); q.pop();
        for(int i = head[p]; i; i = nxt[i])
        {
            if(v[i] && !dep[to[i]])
                q.emplace(to[i]), dep[to[i]] = dep[p]+1;
        }
    }
    return dep[t];
}
int flow(int p, int fl, int t)
{
    if(p == t) return fl;
    int &j = cur[p], ret = 0;
    for(; fl && j; j = nxt[j])
    {
        if(dep[to[j]] != dep[p]+1) continue;
        int tmp = flow(to[j], min(v[j], fl), t);
        fl -= tmp;
        ret += tmp;
        v[j] -= tmp;
        v[j^1] += tmp;
    }
    return ret;
}
int dinic(int s, int t)
{
    int ans = 0;
    while(bfs(s, t))
    {
        ans += flow(s, 1e9, t);
    }
    return ans;
}
int main()
{
    ios::sync_with_stdio(false);
    int t, n;
    cin >> t >> n;
    for(int i = 1; i < t; i++)
    {
        int st1 = 2*n*i-n, st2 = 2*n*i;
        for(int j = 1; j <= n; j++)
        {
            add(st1+j, st2+j, 1);
            add(st2+j, st1+j, 0);
        }
    }
    for(int i = 1; i <= t; i++)
    {
        int m;
        int st1 = 2*n*i-2*n, st2 = 2*n*i-n;
        cin >> m;
        for(int j = 1; j <= m; j++)
        {
            int a, b;
            cin >> a >> b;
            add(st1+a, st2+b, 1);
            add(st2+b, st1+a, 0);
            add(st1+b, st2+a, 1);
            add(st2+a, st1+b, 0);
        }
    }
    int ss = 2*n*t+1, tt = 2*n*t+2;
    for(int i = 1; i <= n; i++)
    {
        add(ss, i, 1);
        add(i, ss, 0);
        add(2*n*t-n+i, tt, 1);
        add(tt, 2*n*t-n+i, 0);
    }
    cout << dinic(ss, tt);
    return 0;
}
```

---

## 作者：船酱魔王 (赞：0)

## 题意回顾

$ n $ 个人，初始时有若干个人有玩偶，$ t $ 天中，每天每个人如果在这天开始之前有玩偶的话需要沿着座位图的一条边传递自己的玩偶，要求玩偶传递前后每个人玩偶不得多于 $ 1 $，也不能不传递。

求出初始时最多的玩偶总数。

$ 1 \le tn,tm \le 3 \times 10^4 $。

## 分析

可以理解为，这是一个分层图，有 $ t+1 $ 层，第 $ i $ 层的 $ u $ 和第 $ i+1 $ 层的 $ v $ 存在一条有向边当且仅当第 $ i $ 天的座位图 $ u,v $ 存在连边。这 $ t+1 $ 层中的每个结点**限流** $ 1 $ 个玩偶。

**限流**怎么实现：将这个点拆成 $ u_1,u_2 $，入边连向 $ u_1 $，$ u_2 $ 连出出边，$ u_1,u_2 $ 连一条有向边，边限流为 $ 1 $，这样就把点限流转化为边限流了。

考虑初始时，玩偶是由『老师』分发的，由『老师』结点 $ 0 $ 向所有 $ 1 $ 层结点连有向边；最后，统计玩偶的总数，可以由所有 $ t+1 $ 层结点向『统计』结点连有向边。

此时，转化为『老师』向『统计』通过图上的边**最多**能传输多少个玩偶，有些边有一些限流，这不就是一个**图的有源汇最大流问题**吗？使用 Dinic 算法解决。

## AC 代码

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <vector>
#include <cstring>
#include <queue>
using namespace std;
const int N = 5e5 + 5;
int t, n;
int m;
struct node {
    int v;
    int w;
};
int wei[N];
int cm = 0;
vector<node> g[N];
inline int Id(int x, int typ, int y) {
    return (x * 2 + typ - 3) * n + y;
}
void add(int u, int v, int zx, int fx) {
    g[u].push_back((node){v, cm});
    wei[cm++] = zx;
    g[v].push_back((node){u, cm});
    wei[cm++] = fx;
}
int dep[N];
int cur[N];
bool bfs(int from, int to) {
    memset(dep, 0, sizeof(dep));
    dep[from] = 1;
    queue<int> que;
    que.push(from);
    while(!que.empty()) {
        int u = que.front();
        que.pop();
        for(int i = 0; i < g[u].size(); i++) {
            int v = g[u][i].v;
            int w = g[u][i].w;
            if(dep[v] || !wei[w]) continue;
            dep[v] = dep[u] + 1, que.push(v);
        }
    }
    return dep[to];
}
int dfs(int u, int to, int lim) {
    int down = 0;
    if(u == to) return lim;
    for(int i = cur[u]; i < g[u].size(); i++) {
        cur[u] = i;
        int v = g[u][i].v;
        int w = g[u][i].w;
        if(dep[v] != dep[u] + 1 || !wei[w]) continue;
        int ls = dfs(v, to, min(wei[w], lim - down));
        if(!ls) dep[v] = 0;
        wei[w] -= ls, wei[w ^ 1] += ls, down += ls;
        if(down == lim) break;
    }
    return down;
}
int Dinic(int from, int to) {
    int res = 0;
    while(bfs(from, to)) {
        memset(cur, 0, sizeof(cur));
        res += dfs(from, to, 1e9 + 5);
    }
    return res;
}
int main() {
    cin >> t >> n;
    for(int i = 1; i <= n; i++) add(0, i, 1, 0);
    for(int dy = 1; dy <= t; dy++) {
        cin >> m;
        int u, v;
        for(int i = 1; i <= m; i++) {
            cin >> u >> v;
            add(Id(dy, 1, u), Id(dy, 2, v), 88, 0);
            add(Id(dy, 1, v), Id(dy, 2, u), 88, 0);
        }
        for(int i = 1; i <= n; i++) add(Id(dy, 2, i), Id(dy + 1, 1, i), 1, 0);
    }
    int gzh = Id(t + 1, 1, 1);
    for(int i = 1; i <= n; i++) add(Id(t, 2, i), gzh, 1, 0);
    cout << Dinic(0, gzh) << endl;
    return 0;
}

```

---


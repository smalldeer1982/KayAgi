# 星空

## 题目背景

pdf题面和大样例链接：http://pan.baidu.com/s/1cawM7c 密码：xgxv

```cpp
命运偷走如果只留下结果， 时间偷走初衷只留下了苦衷。
你来过，然后你走后，只留下星空。
```

## 题目描述

逃不掉的那一天还是来了，小 F 看着夜空发呆。

天上空荡荡的，没有一颗星星——大概是因为天上吹不散的乌云吧。

心里吹不散的乌云，就让它在那里吧，反正也没有机会去改变什么了。

小 C 拿来了一长串星型小灯泡，假装是星星，递给小 F，想让小 F 开心一点。不过，有着强迫症的小 F 发现，这串一共 $n$ 个灯泡的灯泡串上有 $k$ 个灯泡没有被点亮。小 F 决定和小 C 一起把这个灯泡串全部点亮。

不过，也许是因为过于笨拙，小 F 只能将其中连续一段的灯泡状态给翻转——点亮暗灯泡，熄灭亮灯泡。经过摸索，小 F 发现他一共能够翻转 $m$ 种长度的灯泡段中灯泡的状态。

小 C 和小 F 最终花了很长很长很长很长很长很长的时间把所有灯泡给全部点亮了。他们想知道他们是不是蠢了，因此他们找到了你，让你帮忙算算：在最优的情况下，至少需要几次操作才能把整个灯泡串给点亮？

## 说明/提示

【样例 1 解释】

 ![](https://cdn.luogu.com.cn/upload/pic/9814.png) 

【数据范围与约定】

子任务会给出部分测试数据的特点。如果你在解决题目中遇到了困难，可以尝试只解 决一部分测试数据。

每个测试点的数据规模及特点如下表

 ![](https://cdn.luogu.com.cn/upload/pic/9815.png) 

特殊性质：保证答案小于 4


## 样例 #1

### 输入

```
5 2 2 
1 5 
3 4```

### 输出

```
2   
```

# 题解

## 作者：shadow__ (赞：53)

这道题思维难度真的好大啊。。。写了两天，第二天看了好久才懂了我第一天的思路。。


#主体思路

首先我们发现对于连续的一段灯泡去按它的开关极其费时，因此我们需要一种O（1）复杂度的方法进行开关的操作。

想想看，对于区间的连续操作转为O（1）复杂度常用的方法是什么。


###差分！


其实具体把它想通是比较复杂的，而且乍一看感觉与差分没有任何关系。

但是根据亦或的性质，确实可以把对连续区间的0 1数列取反转化为对左端点与右端点取反。

```cpp
n++
for(int i=1;i<=n;i++)G2[i]=G1[i]^G1[i-1];
```
这么做的可行性在于对于区间内我们提前进行了类似取反的操作。

差分的思想是在修改的区间左端点+1，右端点的右边-1，同样的，取反差分也是左闭右开。

例如某段区间全是1；

1 1 1 1 1 1

这么操作之后变为 1 0 0 0 0 0 1

如果我们要对1~6进行取反操作，在差分数组中对1,7取反，数列最终变为了全0。

那么这么做是不是偶然呢。

我们再对于原数列试着把3~4进行取反，于是差分数组变为

1 0 1 0 1 0 1

乍一看貌似与本该存在的数列110011没有什么半毛钱关系（滑稽）

但是要知道差分是左闭右开的。

此数组的意思为

在[1,3)中有(2-1)个1；

把结论一般化

从左到右每次取两个1，记第一个1位置为l，第二个1位置为r

对于原数组的意义为

在[l,r)间有(r-1-l)个1；

（貌似是这样的吧。。如果有问题可以在讨论里指出，本人仅是一名蒟蒻）

道理之前说过了，我们在建G2时对于新数列进行了类似于提前取反的操作。

既然可行性被证明。。那么我们便完成了对该问题的。。


#第一步转化。


那么原问题被我们巧妙（巧妙？玄学！）的转化为了对于给定的0 1数列，每次对于按要求的某两个数进行取反，问最少次可以使数列全部变为1.

接下来大家可以参考出题人给出的题解。

（当然我还是会说一下的）

显然，我们每次的L，R必然包括0.

假如每次是对两个0取反，那么他们都变成了1。

假如是对一个1一个0进行取反，则可以看成把0和1换位，即：

###0走到了1的位置。

这里有必要提一下原问题麻烦的地方，即对于答案无用的灯泡（亮着的）太多，这样会导致进行大量的无效操作。

如果想进行状压复杂度则高到了恐怖的O（2^40000）。

然而最终有用的转化仅在对未亮灯泡进行操作。

那么此时则体现了刚刚那句话的重要性。

既然可以看成1走到了0的位置，那么我们完全可以不考虑1的存在嘛。

于是乎我们对于问题进行了


#第二次转化


给你几个点，每次将其中一个点移动特定的距离，如果两个点碰到了一起，则两个点一起消失。

问如何移动使得消去所有的点的步数最少。

我们再对这个问题进行小贪心。

消去同一对点，那么一定是取他们走到一起的最短步数最优（废话）

那么找最短路的方法可以用spfa进行（这里吐槽一下出题人给的题解啊，误导了我好久，发现根本不是bfs好伐，也可能是我蒟蒻的问题？）

没错，我们把问题进行了


#第三次转化


我保证这是最后一次了。（滑稽）

给你一堆物品，一次只能取出给定的一对物品，取出不同对的物品有不同的代价，问如何取出物品使得代价最小。

由于题目中的不亮灯泡极少，我们完全可以通过状压完成最后的操作。


然而我这个蒟蒻不会状压动规，这里我把状压转为SPFA。

每一种状态看作一个点，每次取出物品的代价可以看作给一种状态和另一种状态连一条权值为其代价的边。

问始态到终态的最短路。

（不是第四次转换！不是第四次转换！不是第四次转换！（滑稽））


#代码


```cpp
#include<bits/stdc++.h>
const int INF =2147483647;
using namespace std;
struct node{
    int v,w,next;
}cost[210];
int head[41000],e;
inline void insert(int u,int v,int w){
    cost[++e].next=head[u];
    cost[e].v=v;
    cost[e].w=w;
    head[u]=e;
}
int n,m,k;
int hash[41000],id[41000],Index;
bool G1[41000],G2[41000];
vector<int>stone;
queue<int>q;
bool vis[41000],inq[70000];
int dist[20][41000];
int step[65];
int f[70000];
inline void bfs(){//其实是SPFA 
    for(int i=0;i<stone.size();i++){
        memset(vis,0,sizeof(vis));
        int v=stone[i];
        dist[i+1][v]=0;
        q.push(v);
        inq[v] = true;
        while(!q.empty()){
            int x=q.front();q.pop();
            inq[x]=false;
            for(int j=1;j<=m;j++){
                int z=x+step[j];
                int y=x-step[j];
                if(z<=n){
                    if(dist[i+1][z]>dist[i+1][x]+1){
                        dist[i+1][z]=dist[i+1][x]+1;
                        if(!inq[z]){
                            q.push(z);
                            inq[z]=true;
                        }
                    }
                }
                if(y>=1){
                    if(dist[i+1][y]>dist[i+1][x]+1){
                        dist[i+1][y]=dist[i+1][x]+1;
                        if(!inq[y]){
                            inq[y]=true;
                            q.push(y);
                        }
                    }
                }
            }
        }
    }
}
inline void spfa(){
    int N=(1<<(Index))-1;
    f[N]=0;
    inq[N]=true;
    q.push(N);
    while(!q.empty()){
        int v=q.front();q.pop();
        inq[v]=false;
        for(int i=1;i<=Index;i++){
            int x=1<<(Index-i);
            for(int j=head[i];j;j=cost[j].next){
                int z=1<<(Index-cost[j].v);
                int w=cost[j].w;
                int u=(v^x)^z;
                if((v&x)&&(v&z)){
                    if(f[v]+w<f[u]){
                        f[u]=f[v]+w;
                        if(!inq[u]){
                            q.push(u);
                            inq[u]=true;
                        }
                    }
                }
            }
        }
    }
}
int main(){
    scanf("%d%d%d",&n,&k,&m);
    int a;
    n++;
    for(int i=1;i<=k;i++){
        scanf("%d",&a);
        G1[a]=1;
    }
    for(int i=1;i<=n;i++)G2[i]=G1[i]^G1[i-1];
    for(int i=1;i<=n;i++)if(G2[i]){
        ++Index;
        stone.push_back(i);
    }
    for(int i=1;i<=m;i++)scanf("%d",&step[i]);
    for(int i=1;i<=Index;i++)
    for(int j=1;j<=n;j++)dist[i][j]=INF;
    bfs();
    for(int i=1;i<=Index;i++)
    for(int j=i+1;j<=Index;j++){
        int minn = INF;
        for(int o=1;o<=n;o++)if(dist[i][o]!=INF&&dist[j][o]!=INF)minn=min(dist[i][o]+dist[j][o],minn);
        if(minn!=INF){
            insert(i,j,minn);
            insert(j,i,minn);
        }
    }
    memset(f,0x3f,sizeof(f));
    spfa();
    printf("%d\n",f[0]);
    return 0;
}
```
最后在这里给出让我DE出BUG的数据，比较小却也比较有代表性

6 4 2
1 3 4 5

3 1
-----------

9 4 4
4 7 8 9

5 4 3 2


---

## 作者：Epworth (赞：35)


一道隐藏得十分隐蔽的状压$DP$。

题意大致是给你一个01串，每次操作可以对规定区间长度的0，1进行交换。

问最少用多少次才能将串的每一位变为1。

> 妙处一

看到区间修改我们想到利用差分求解。

每一次操作都相当与对操作区间的每一位与一异或($1\hat{}1=0 \  \  \ 0\hat{}1=1$)

所以可以把原问题转变在差分数组$(dif)$上进行!

对$[L,R]$操作就等效于$dif[L]\hat{}1,dif[R+1]\hat{}1$

所以原问题转化为给你一个01串，每次操作可以将串中的两个$1$变为$0$，有一个与两个$1$距离相应的费用。

问最少花费多少才能将串的每一位变为$0$。

为什么要将差分数组全部变为$0$呢？ 

多举几个例子归纳一下可以发现全$0$的差分数组对应的原串全是$1$ORZ。

> 妙处二

上面说到消去差分数组中两个$1$所需要的费用与它们的距离$x$有关。

因为题目给我们限制了每次操作的区间长度，也就是$x-1$。

所以有些距离的两个$1$我们无法通过一次操作消去。

举个例子:

​	若操作的长度为$4$,$1$，原序列为$1000$：

| 原串 | 差分数组 |
| :--: | :------: |
| 1000 |  11000   |
| 0111 |  01001   |
| 1111 |  00000   |

距离为$3$的两个$1$需要由$4-1$转移得到。

所以我们要提前预处理出消去距离为$x$的两个$1$需要最少的操作次数。

不妨将k个可执行的区间长度抽象为$k$个体积为$len$的物品和$k$个体积为$-len$。

用最小的物品来填充背包，背包的大小就是消去距离为$x$的两个$1$需要最少的操作次数。

注意:不能将正负体积的物品放在一起DP,它们的转移顺序不同，要分两个写。

> 妙处三

利用背包处理完后，就可以愉快的状压$DP$了。

但是串的长度显然不符合状压的要求。

经过一番观察后我们发现最开始最多只有8个灯泡是熄灭的。

所以差分串中最多只有$16$个$1$。

好了，我们可以把所有的$1$单独提出来，记录它们在原串的位置(用于计算操作次数)。

对于一个状态，从左到右确定一个$1$的位置，再去枚举另一个$1$的位置。

最后输出$f[0]$即可。

注意:我们是将差分串中的$1$提出来状压，所以初状态全是$1$，末状态全是$0$。

## 代码

```cpp
#include<bits/stdc++.h>
#define maxn 40005
#define Epworth return 0 
using namespace std;
int n,m,k,xx; 
int dif[maxn];
int pos[maxn],tail;
int len[maxn],cost[maxn];
int f[1<<17];
int main(){
	cin>>n>>m>>k;
	for(int i=1;i<=m;i++) cin>>xx,dif[xx]^=1,dif[xx+1]^=1;
	for(int i=1;i<=k;i++) cin>>len[i];
	for(int i=1;i<=n+1;i++){
		if(dif[i]) pos[++tail]=i;
	}
	memset(cost,0x3f,sizeof(cost));
	cost[0]=0;
	for(int i=1;i<=k;i++){
		for(int j=len[i];j<=n;j++){
			cost[j]=min(cost[j],cost[j-len[i]]+1);
		}
	}
	for(int i=1;i<=k;i++){
		for(int j=n-len[i];j>=0;j--){
			cost[j]=min(cost[j],cost[j+len[i]]+1);
		}
	}
	int all=(1<<tail)-1;
	memset(f,0x3f,sizeof(f));
	f[all]=0;
	for(int i=all;i>=0;i--){
		for(int j=1;j<=tail;j++){
			if(!((1<<(j-1))&i)) continue;
			for(int k=j+1;k<=tail;k++){
				if(!((1<<(k-1))&i)) continue;
				int x=~((~i)|(1<<(j-1))|(1<<(k-1)));
				f[x]=min(f[x],f[i]+cost[pos[k]-pos[j]]);
			}
		}
	}
	cout<<f[0]<<endl;
	Epworth;
} 
```

### 等等还没完！！！

好了，上面这个漏洞百出的代码已经可以AC这道题了。

但是对于某些数据，它是错误的。

下面让我们来批判一下上面的代码。

看看下面这组数据：

```cpp
7 2 2
2 3
5 4
```

| 1001111 |
| :-----: |
| 1000000 |
| 1111110 |
| 1100000 |
| 1111111 |

不难发现它可以通过$4$次操作把整个灯泡串点亮。

但上面跑出来是$INF$,也就是无解。

为什么呢?

因为在上面跑完全背包正负价值是分开跑的，结果是不完整的。

$4,5$能凑出$1$，当然也能凑出$2$。

但$(5-4+5-4)$的决策是上面跑不出来的，$(5+5-4-4)$又超出了背包的范围。

代价计算的残缺就可能造成结果的错误。



但假定我们解决的上面的问题，仍然是错的QAQ。

再来看看下面这组数据：

```cpp
6 2 2
3 4
5 3
```

正确答案应该为$6$,但上面跑出来是$2$。

是的又错了(愈发怀疑$AC$的真实性)。

这又是为什么呢?

在完全背包中，我们只考虑了在序列长度的限制下能否凑出某个距离。

但没有考虑消去的两个$1$在序列中的实际位置。

在错误的代码中，我们计算出消除距离为$2$的两个$1$只需要操作两次$(5-3=2)$

但实际上$5$是执行不了的。

| 110011(0) |
| :-------: |
| 111100(1) |
| 111111(0) |

理想的状态下我们在最后一个灯泡后虚构了一个假灯泡协助操作，最后把它熄灭了。

但这明显是不被允许的。

但如果是这样却又可以了。

```cpp
6 2 2
2 3
5 3
```

在差分串中两个$1$的距离并没有改变。

所以在本题中$1$的实际位置也会影响结果，不只是相对位置。



.......

经过一番思索，我们还是好好的$BFS$吧。

$BFS$是从每个一的实际位置出发判断它能到达的地方，故不会存在上面的问题。

## 正确的代码

```cpp
#include<bits/stdc++.h>
#define inf 0x3f3f3f3f
#define maxn 40005
#define Epworth return 0 
using namespace std;
int n,m,k,xx; 
int dif[maxn];
int pos[maxn],tail;
int len[maxn];
int dist[maxn];
int cost[20][20];
int f[1<<17];
queue<int> q;
void bfs(int s){
	memset(dist,0x3f,sizeof(dist));
	q.push(pos[s]);
	dist[pos[s]]=0;
	while(!q.empty()){
		int x=q.front();
		q.pop();
		for(int i=1;i<=k;i++){
			int a=x-len[i];
			int b=x+len[i];
			if(a>=1&&dist[a]==inf){
				dist[a]=dist[x]+1;
				q.push(a);
			}
			if(b<=n+1&&dist[b]==inf){
				dist[b]=dist[x]+1;
				q.push(b);
			}
		}
	}
	for(int i=1;i<=tail;i++){
		if(dist[pos[i]]!=inf){
			cost[s][i]=dist[pos[i]];
		}
	}
}
int main(){
    cin>>n>>m>>k;
    for(int i=1;i<=m;i++) cin>>xx,dif[xx]^=1,dif[xx+1]^=1;
    for(int i=1;i<=k;i++) cin>>len[i];
    for(int i=1;i<=n+1;i++){
        if(dif[i]) pos[++tail]=i;
    }
    memset(cost,0x3f,sizeof(cost));
    for(int i=1;i<=tail;i++) bfs(i);
    int all=(1<<tail)-1;
    memset(f,0x3f,sizeof(f));
    f[all]=0;
    for(int i=all;i>=0;i--){
        for(int j=1;j<=tail;j++){
            if(!((1<<(j-1))&i)) continue;
            for(int k=j+1;k<=tail;k++){
                if(!((1<<(k-1))&i)) continue;
                int x=~((~i)|(1<<(j-1))|(1<<(k-1)));
                f[x]=min(f[x],f[i]+cost[j][k]);
            }
        }
    }
    cout<<f[0]<<endl;
    Epworth;
}  
```



---

## 作者：fstqwq (赞：10)

这里提供的是 std。

如果需要题解，请参考 [ppt](https://www.luogu.org/discuss/show?postid=26609)，或者其他同学的题解。


```cpp
#include <bits/stdc++.h>
using namespace std;

typedef pair<int, int> pii;
#define fir first
#define sec second
#define INF 0x3f3f3f3f
#define MAXN 40005
#define TOP 18

int n, K, m, cnt = 0;
bool a[MAXN];
int dis[18][MAXN], b[70];
pii p[18];

queue <int> q;

void bfs(pii st) {
    for (int i = 0; i < MAXN; i++) dis[st.fir][i] = INF;
    q.push(st.sec);
    dis[st.fir][st.sec] = 0;
    while (!q.empty()) {
        int x = q.front(); q.pop();
        for (int i = 1; i <= m; i++) {
            if (x - b[i] >= 0 && dis[st.fir][x - b[i]] > dis[st.fir][x] + 1) {
                dis[st.fir][x - b[i]] = dis[st.fir][x] + 1;
                q.push(x - b[i]);
            }
            if (x + b[i] <= n && dis[st.fir][x + b[i]] > dis[st.fir][x] + 1) {
                dis[st.fir][x + b[i]] = dis[st.fir][x] + 1;
                q.push(x + b[i]);
            }
        }
    }
}

int dp[1 << 18];

int solve(int mask) {
    if (dp[mask] != -1) return dp[mask];
    if (mask == 0) return 0;
    int &ret = dp[mask]; ret = INF;
    int x = 0; while (!(mask & (1 << x))) x++;
    for (int i = x + 1; i < 2 * K; i++)
        if (mask & (1 << i)) ret = min(ret, solve(mask ^ (1 << x) ^ (1 << i)) + dis[x][p[i].sec]);
    return ret;
}

int main() {
    scanf("%d%d%d", &n, &K, &m);
    for (int i = 1, x; i <= K; i++) scanf("%d", &x), a[x] = true;
    for (int i = 1; i <= m; i++) scanf("%d", &b[i]);
    for (int i = 0; i <= n; i++) if (a[i] != a[i + 1]) p[cnt] = pii(cnt, i), cnt++;
    for (int i = 0; i < cnt; i++) bfs(p[i]);
    memset(dp, -1, sizeof dp);
    int ans = solve((1 << cnt) - 1);
    assert(ans != INF);
    printf("%d\n", ans);
    return 0;
}
```

---

## 作者：decoqwq (赞：8)

解法0：
我会$rand$！小于四的答案随便猜

预计得分8

解法0.5：
我会输出$2$！

预计得分12（233......)

解法1：
看到有$m=1$的时候，直接从左到右扫一遍~~xjb~~贪心一波，其他还是$rand$

预计得分28

解法2：
我会状压!直接状压扫一遍

预计得分24~28

解法3：
考虑到$k$很小，就从这个方向来思考：

比如对于一串数列$1,0,1,0,1,1,0$（$1$表示亮着$0$表示不是亮的）

我们将其两边扩展各一个$0$ $->$ $0,1,0,1,0,1,1,0,0$

然后对其扫一遍，形成一个原数组的“异或数组”
即值分别为$1,1,1,1,1,0,1,0$

既然要将原数组全部都变为$0$，区间翻转也不会改变其相邻的异或值，则想到只需要将不同的异或值反转到一起消除即可

$Q$:为什么加$0$

$A$:$0$^$a=a$

则问题转化为了一个$01$数列，若两个$1$在一起即可消除，要翻转至少多少次

每次暴力去求

预计得分24（233...白考虑了）

解法4：
继续解法3，不要前功尽弃

可以非常非常容易的想到，这可以转化为图论来解，只要对两两点对之间跑$SPFA$即可

$Q$:不会超时吗

$A$:你是不是没看到$K \leqslant 8$...

于是问题解决完毕，接下来就是经典的状压dp可做的了

code：
```cpp
#include<bits/stdc++.h>
using namespace std;
int way[65],a[40010],b[40010],pos[18],dis[18][18],cnt;
int n,m,k;
int que[40005],vis[40005],tim[40005],dp[70005],ycl[70005];
queue<int> q;
void bfs(int x)
{
    int hd=0;
    memset(vis,0,sizeof(vis));
    memset(tim,0,sizeof(tim));
    q.push(x);
    vis[x]=1;
    tim[x]=0;
    while(!q.empty())
    {
        int u=q.front();
        q.pop();
        for(int i=1;i<=m;i++)
        {
            int v1=u+way[i],v2=u-way[i];
            if(v1<=n&&vis[v1]==0)
            {
                q.push(v1);
                tim[v1]=tim[u]+1;
                vis[v1]=1;
            }
            if(v2>=0&&vis[v2]==0)
            {
                q.push(v2);
                tim[v2]=tim[u]+1;
                vis[v2]=1;
            }
        }
    }
}
int main()
{
    scanf("%d%d%d",&n,&k,&m);
    for(int i=1;i<=k;i++)
    {
        int x;
        scanf("%d",&x);
        a[x]=1;
    }
    for(int i=1;i<=m;i++)
    {
        scanf("%d",&way[i]);
    }
    for(int i=0;i<=n;i++)
    {
        b[i]=a[i]^a[i+1];
        if(b[i]==1)
        {
            pos[++cnt]=i;
        }
    }
    for(int i=1;i<=cnt;i++)
    {
        bfs(pos[i]);
        for(int j=1;j<=cnt;j++)
        {
            dis[i][j]=tim[pos[j]];
        }
    }
    for(int zt=0;zt<(1<<cnt);zt++)
    {
        ycl[zt]=cnt;
        for(int k=1;k<=cnt;k++)
        {
            if(((zt>>(k-1))&1)==0)
            {
                ycl[zt]=k;
                break;
            }
        }
    }
    for(int zt=1;zt<(1<<cnt);zt++)
    {
        dp[zt]=1e8;
    }
    dp[0]=0;
    for(int zt=0;zt<(1<<cnt);zt++)
    {
        for(int i=ycl[zt]+1;i<=cnt;i++)
        {
            if(((zt>>(i-1))&1)==0&&dis[ycl[zt]][i]!=0)
            {
                dp[zt|(1<<(ycl[zt]-1))|(1<<(i-1))]=min(dp[zt|(1<<(ycl[zt]-1))|(1<<(i-1))],dp[zt]+dis[ycl[zt]][i]);
            }
        }
    }
    printf("%d",dp[(1<<cnt)-1]);
}
```



---

## 作者：devout (赞：6)

[题目链接](https://www.luogu.com.cn/problem/P3943)

因为区间取反不太好做，我们可以考虑把它差分一下，这样一次区间修改相当于转化成了两次单点修改。

因为原来的序列里最多只有 $k\leq 8$ 个 $0$，所以差分之后最多只会有 $16$ 个 $1$，而且显然有偶数个 $1$

所以可以考虑状压 $dp$，用 $f[S]$ 表示现在已经消除掉的 $1$ 的集合为 $S$ 的最少操作次数。

$$f[S]=\min\limits_{popcount(S\ xor\ S^\prime)=2}\{f[S^\prime]+calc(S^\prime,S)\}$$

考虑 $calc$ 的计算，我们可以以每一个差分后为 $1$ 的位置为起点做一次 spfa（其实是bfs），然后就可以快速得出 $calc$ 的值了


$\mathcal O(2^{2k}\times(2k)^2)$

```cpp
#include <bits/stdc++.h>
using namespace std;

# define Rep(i,a,b) for(int i=a;i<=b;i++)
# define _Rep(i,a,b) for(int i=a;i>=b;i--)
# define RepG(i,u) for(int i=head[u];~i;i=e[i].next)

typedef long long ll;

const int N=1e5+5;

template<typename T> void read(T &x){
   x=0;int f=1;
   char c=getchar();
   for(;!isdigit(c);c=getchar())if(c=='-')f=-1;
   for(;isdigit(c);c=getchar())x=(x<<1)+(x<<3)+c-'0';
    x*=f;
}

int n,k,m;
int a[N],b[N],p[N],tot;
int f[1<<20];
int dis[N][20]; 
bool inq[N];

void spfa(int s,int op){
	queue<int> q;
	dis[s][op]=0;
	q.push(s);
	inq[s]=true;
	while(!q.empty()){
		int u=q.front();q.pop();
		inq[u]=false;
		Rep(i,1,m){
			int v=u+b[i];
			if(v>n+1)continue;
			if(dis[v][op]>dis[u][op]+1){
				dis[v][op]=dis[u][op]+1;
				if(!inq[v])inq[v]=true,q.push(v);	
			}
		}
		Rep(i,1,m){
			int v=u-b[i];
			if(v<1)continue;
			if(dis[v][op]>dis[u][op]+1){
				dis[v][op]=dis[u][op]+1;
				if(!inq[v])inq[v]=true,q.push(v);
			}
		}
	}
}

int main()
{
	memset(f,0x3f,sizeof(f));
	memset(dis,0x3f,sizeof(dis)); 
	read(n),read(k),read(m);
	Rep(i,1,k){
		int x;
		read(x);
		a[x]=1;	
	}
	Rep(i,1,m)read(b[i]);
	Rep(i,1,n+1)if(a[i]^a[i-1])p[tot++]=i;
	for(int i=0;i<tot;i++)
		spfa(p[i],i);
	f[0]=0;
	for(int S=0;S<1<<tot;S++)
		for(int i=0;i<tot;i++)
			if(S>>i&1^1)
				for(int j=0;j<tot;j++)
					if(i!=j&&S>>j&1^1)
						f[S|(1<<i)|(1<<j)]=min(f[S|(1<<i)|(1<<j)],f[S]+dis[p[j]][i]);
	printf("%d\n",f[(1<<tot)-1]);
	return 0;
}
```


---

## 作者：kcn999 (赞：5)

题目可以看作有一个长度为 $n$ 的 $01$ 串，有 $k$ 位为 $1$，其余为 $0$。每次操作相当于区间 $\oplus 1$，求变成全 $0$ 串的最小操作次数。

操作为区间修改，那么考虑对原 $01$ 串进行差分。
例如样例，原串是 $\color{red}{0}\color{black}{10001}\color{red}{0}$，这里设第 $0$ 位和第 $n+1$ 位都为 $0$，用红色数字表示。      
则差分之后是 $\color{red}{0}\color{black}{11001}\color{red}{1}$，即设原串第 $i$ 位为 $a_i$，差分后新串第 $i$ 位为 $d_i$，则 $a_i=d_0\oplus d_1\oplus d_2\oplus \cdots \oplus d_i$。   
这个时候我们考虑，对原串 $[l,r]$  进行区间 $\oplus1$，其实就相当于令新串的 $d_l\gets d_l\oplus1,d_{r+1}\gets d_{r+1}\oplus 1$。

变化有 $4$ 种情况：
1. 若 $d_l=d_{r+1}=0$，则相当于把这两位变成 $1$，增加 $2$ 个 $1$。
2. 若 $d_l=d_{r+1}=1$，则相当于把这两位变成 $0$，减少 $2$ 个 $0$。
3. 若 $d_l=1,d_{r+1}=0$，则相当于把 $l$ 上的 $1$ 移到 $r+1$，$1$ 数量不变。
4. 若 $d_l=0,d_{r+1}=1$，则相当于把 $r+1$ 上的 $1$ 移到 $l$，$1$ 数量不变。

那我们可以对任意 $i$ 和 $i+b_j$ 连一条边权为 $1$ 的无向边，则新串中 $d_l\gets d_l\oplus 1,d_{r+1}\gets d_{r+1}\gets 1$ 的最小操作次数为 $l$ 到 $r+1$ 的最短路，记作 $\textit{dis}(l,r+1)$。则对原串 $[l,r]$ 进行区间 $\oplus1$ 的最小操作次数为 $\textit{dis}(l,r+1)$。因为边权为 $1$，所以求最短路跑 $n$ 次 BFS 即可。    
容易得到，新串变为全 $0$ 串是原串变为全 $0$ 串的充要条件。

考虑 $k$ 很小，实际上新串中初始最多只有 $2k$ 个 $1$，而其他的 $0$ 我们根本就不用管，也就是说只用计这 $2k$ 个 $1$。则新串只有 $2^{2k}$ 种状态，直接上状压 dp。    
设 $f(S)$ 为新串状态为 $S$ 时的最小操作次数，预处理出新串的初始状态 $\textit{st}$，则 $f(\textit{st})=0$。    
显然每次转移，进行上面的第 $1,3,4$ 种变化是没有意义的，所以只需要做第 $2$ 种变化（即转移中，只转移第 $2$ 种变化，实际上已经包括了其他 $3$ 种）。    
设 $T=S-2^{i-1}-2^{j-1}$，则 $f(T)=\min \{f(S)+\textit{dis}(i,j)\}$。答案即为 $f(0)$。   
同样的，我们在 BFS 的时候，只用从初始值为 $1$ 的位开始搜，那么最多跑 $2k$ 遍 BFS。   
时间复杂度为 $O(2knm+2^{2k}(2k)^2)$。   

实际上每次转移的时候，$i$ 可以只取 $S$ 中 $1$ 的最低位（无论如何都要转移这个最低位，那么可以先转移）。   
时间复杂度为 $O(2knm+2^{2k} (2k))$。

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
#define MAX_N (40000 + 5)
#define MAX_M (64 + 5)
#define MAX_K (8 + 5)
#define MAX_S ((1 << 16) + 5)
using std::min;

int n, m, k;
int a[MAX_K * 2], len;
int b[MAX_M];
int dis[MAX_N];
int g[MAX_K * 2][MAX_K * 2];
int q[MAX_N], l, r;
bool vis[MAX_N];
int f[MAX_S];

void BFS() {
	int u, v;
	for (int I = 1; I <= len; ++I) {
		memset(dis, 0x3f, sizeof dis);
		memset(vis, 0, sizeof vis);
		l = r = 1;
		dis[a[I]] = 0;
		vis[a[I]] = 1;
		q[1] = a[I];
		while (l <= r) {
			u = q[l++];
			for (int i = 1; i <= m; ++i) {
				v = u - b[i];
				if (v >= 1 && !vis[v]) {
					dis[v] = dis[u] + 1;
					vis[v] = 1;
					q[++r] = v;
				}
				v = u + b[i];
				if (v <= n + 1 && !vis[v]) {
					dis[v] = dis[u] + 1;
					vis[v] = 1;
					q[++r] = v;
				}
			}	
		}
		for (int i = 1; i <= len; ++i)
			g[I][i] = dis[a[i]];
	}
}

int main() {
	scanf("%d%d%d", &n, &k, &m);
	int pos;
	for (int i = 1; i <= k; ++i) {
		scanf("%d", &pos);
		vis[pos] ^= 1;
		vis[pos + 1] ^= 1;
	}
	for (int i = 1; i <= n + 1; ++i)
		if (vis[i]) a[++len] = i;
	for (int i = 1; i <= m; ++i)
		scanf("%d", &b[i]);
	BFS();
	const int lim = (1 << len) - 1;
	memset(f, 0x3f, sizeof f);
	f[lim] = 0;
	int tmp, T;
	for (int S = lim; S; --S) {
		tmp = S;
		pos = 1;
		while ((tmp & 1) == 0) {
			++pos;
			tmp >>= 1;
		}
		for (int i = pos + 1; i <= len; ++i) {
			if ((S & 1 << i - 1) == 0) continue;
			T = S ^ 1 << pos - 1 ^ 1 << i - 1;
			f[T] = min(f[T], f[S] + g[pos][i]);
		}
	}
	printf("%d", f[0]);
	return 0;
}
```

---

## 作者：柏木由纪AKB48 (赞：1)

好吧，我在这里要提出一个很少有人注意到的点

或许有同学也想到了，但是可能没有去注意这个细节或者仔细思考它的可行性

下面来举出一例实际的例子：

假如处理后的后的数组是这样

```
1 0 0 1 0 0 1
```
只给出一种跳动方法：一次性往前面跳三步

问题来了，一号灯泡到底能不能跳到七号灯泡去呢

那么按照某些题解的说法，当一号灯泡跳动三步到达四号灯泡时，两只灯泡会相互抵消

这样来看，一号灯泡就已经被抵消了，自然也就不能跳到７号灯泡

吗？

实则不然，我们可以利用等效法来解决这个问题

我们可以将其看成一号灯泡先跳到四号和四号抵消

然后七号灯泡向前跳，跳到四号灯泡

所以中间过程，那个位置上有没有灯泡其实是不重要的(无关的)

最后的结果就是：我还只是花了两步，但是依旧达到了从一号跳到七号的目的

上一个代码好了

```cpp
#include<cstdio>
#include<cstring>
#include<queue>
using namespace std;
inline int read(){int x=0,y=1;char k;while(k<'0'||k>'9'){if(k=='-')y=-1;k=getchar();}while(k>='0'&&k<='9'){x=(x<<3)+(x<<1)+k-'0';k=getchar();}return x*y;}
int dis[40005],t[22][22],n,k,m,a[40005],pos[22],cnt,c[40005],f[1048578],vis[40005];
queue<int>q;
inline void spfa(int from){
    for(int i=1;i<=n+2;i++) dis[i]=999999999;
    while(!q.empty())q.pop();memset(vis,0,sizeof(vis));
    dis[from]=0,vis[from]=1;q.push(from);
    while(!q.empty()){
        int t=q.front();q.pop(),vis[t]=0;
        for(int i=1;i<=m;i++){
            int p=t-c[i];if(p>=1){if(dis[p]>dis[t]+1){dis[p]=dis[t]+1;if(!vis[p]){vis[p]=1;q.push(p);}}}
            p=t+c[i];if(p<=n+1){if(dis[p]>dis[t]+1){dis[p]=dis[t]+1;if(!vis[p]){vis[p]=1;q.push(p);}}}
        }
    }
}
int main(){
    n=read(),k=read(),m=read();
    for(int i=1;i<=k;i++){int p=read();a[++p]=1;}
    for(int i=1;i<=n+1;i++){
        a[i]=a[i]^a[i+1];
        if(a[i]==1) pos[++cnt]=i;
    }for(int i=1;i<=m;i++) c[i]=read();
    for(int i=1;i<=cnt;i++){spfa(pos[i]);for(int u=1;u<=cnt;u++) t[i][u]=dis[pos[u]];}
    for(int i=0;i<=(1<<cnt)-1;i++) f[i]=999999999;f[0]=0;
    for(int i=0;i<=(1<<cnt)-1;i++){
        for(int a=1;a<=cnt;a++){
            for(int b=a+1;b<=cnt;b++){
                if((i&(1<<(a-1)))&&(i&(1<<(b-1)))&&t[a][b]<999999999){
                    int con=i^(1<<(a-1));con^=1<<(b-1);
                    f[i]=min(f[i],f[con]+t[a][b]);
                }
            }
        }
    }
    if(f[(1<<cnt)-1]<999999999)printf("%d",f[(1<<cnt)-1]);
    else printf("-1");
    return 0;
}
```

---

## 作者：轻尘 (赞：1)

## 题目讲解
--------------------
### 前言

首先，看到这道题，我就想到了一道状压题，如果你看过我的状压专题的话，就会发现这和 **[It’s not a Bug , it’s a Feature!] **很像。同属于开关灯问题。

可是仔细看来，这道题emmm好像数据有点。。。太大了，蒟蒻的我只好在考场上打了一个状压+隐式图spfa。结果只得了30分。

**此题正解：差分+bfs(完全背包)+状压DP(spfa)。**

真是一道优秀的题目啊。

----------------------------------

### 差分

**在题解的帮助下（没错，就是题解），了解了异或差分。**

**差分：一个可以把区间修改变为单点修改的操作。**

**只是这里的差分是异或差分（与普通差分不一样！！），是前后异或的结果。**

**而且区间的两端都要算上，然后O(n)->O(k)~~(胡乱分析，不要认真）~~**

**此时我们反转区间，就相当于将区间两端换位。由于k比较小，自然想到状压。**

-------------------
### bfs（1，1）点对处理距离

**接下来，我们处理一下每个 1 之间的距离（也就是花费），用每个小步（所给区间转换长度）组成这个距离，用bfs不就能解决吗（也可以完全背包）。**

**举个样栗：**

**有1，5两个位置为1，有3，4长度的区间反转。（样例解释）。**

**将10001差分后，变成110011。**

**将四个1两两消掉，明显是第1&第5，第2&第6，两步长度为4的操作。**

**而我们只需要bfs求出每个 1 之间的最短距离即可，选择该哪两个 1 消掉是DP的事情了。**

------------------------------------
### 状压DP处理最优决策

**最后，状压DP将 1 两两相消，相当于决策应该哪两个 1 相消。**

**设状态为每个1是否消掉了，初始为0，最后状态为(1<<1的数量)-1表示1全部消掉。**

**（集合不超过$2^{1的数量}$）。**

---------------------------
## code:


```cpp
#include<iostream>
#include<cstring>
#include<algorithm>
#include<cstdio>
#include<queue>
const int maxn=500005;
using namespace std;
int m,n,k;
int way[maxn],a[maxn],b[maxn],one[maxn];
int dis[20][20],f[1<<18];
queue<int>q;
int s[maxn];
bool vis[maxn];
void bfs(int a)
{
    memset(s,0,sizeof s);
    memset(vis,0,sizeof vis);
    vis[a]=1;
    s[a]=0;
    q.push(a);
    while(!q.empty())
    {
        int u=q.front();
        q.pop();
        for(int i=1;i<=m;i++)
        {
            int v1=u+way[i],v2=u-way[i];
            if(v1<=n&&vis[v1]==0)
            {
                q.push(v1);
                s[v1]=s[u]+1;
                vis[v1]=1;
            }
            if(v2>=0&&vis[v2]==0)
            {
                q.push(v2);
                s[v2]=s[u]+1;
                vis[v2]=1;
            }
        }
    }
}
int main()
{
    scanf("%d%d%d",&n,&k,&m);
    for(int i=1;i<=k;i++)
    {
        int x;
        scanf("%d",&x);
        a[x]=1;
    }
    for(int i=1;i<=m;i++)
        scanf("%d",&way[i]);
    int cnt=0;
    for(int i=0;i<=n;i++)
    {
        b[i]=a[i]^a[i+1];
        if(b[i]==1)
            one[++cnt]=i;
        //cout<<b[i];
    }
    for(int i=1;i<=cnt;i++)
    {
        bfs(one[i]);
        for(int j=1;j<=cnt;j++)
            dis[i][j]=s[one[j]];
    }
    int S=1<<cnt;
    for(int i=1;i<S;i++) f[i]=0x3f3f3f3f;
    for(int i=0;i<S;i++)
    {
        int j=0;
        while(i&(1<<j)) j++;
        for(int p=j+1;p<cnt;p++)
        {
            if(!(i&(1<<p))&&dis[p+1][j+1])
                f[i|(1<<p)|(1<<j)]=min(f[i|(1<<p)|(1<<j)],f[i]+dis[p+1][j+1]);
        }
    }
    printf("%d\n",f[S-1]);
    return 0;
}
```
---------------------------------------------
# : )       欢迎访问新开博客[传送门](http://tchoi.club)

---

## 作者：坑队友的小白 (赞：0)


[$\Longrightarrow$原题链接](https://www.luogu.com.cn/problem/P3943)

很妙的一道题，本 $\mathrm{juruo}$ 在考场上做不出来。思路错了，干瞪眼半天看不出做法。

因本人喜好，**将原题的 $0/1$ 调换了**。（雾）

对区间进行操作，（可以看成）最后才观察答案（如果是暴力），那么可以（比较难）想差分。对区间 $[l,r]$ 取反，就是在差分数组 $f_{1...n+1}$ 中 $f_l,f_{r+1}$ 分别取反，同时，当存在 $a_i=p$ ，那么 $f_p,f_{p+1}$ 分别取反。那么最终第$i$个位置的值就是 $\bigoplus_{j=1}^i f_j$。

接着可以想到，原数组每一个位置都变成零和$f$每一个位置都变成零是等价的。

现在问题转化成了：有 $m$ 种间隔，每次操作选取一个间隔 $b$ 和一个开始位置 $st$ ，然后 $f_{st}, f_{b+st}$ 分别取反，用最少的操作使 $f$ 变成零。(废话)

**先考虑 $n\leq 16$ 或者更小的情况。**

可以想到，用一次或多次操作可以做出多种间隔，那么我们设 $val(i,j)$ 表示同时将 $i,j$ 这两个位置取反需要的最小步数。为了求出这个数组，我们将问题转化为一个最短路问题，将每一个位置看成图上的一个点，而一个点 $p$ 有最多 $2m$ 条边（因为有边界），分别为 $p \pm b_1, p \pm b_2, p \pm b_3...$ 。但是因为这里的边权都是 $1$ ，所以直接使用 $\mathrm{BFS}$ 就好了（每次选择一个起始节点，然后暴力跑）。

设 $d(S)$ 表示 $f$ 的值的状态压缩，那么可以使用 $\mathrm{spfa}$ ，将一个状态看成一个点，一条边 $(S, S \oplus \{i\} \oplus \{j\})$ 的边权就是 $val(i,j)$ 。起始点就是 $f$ 还没有操作之前的状态，答案就是 $d(0)$ 。

但是对于这个部分分而言，直接使用 $\mathrm{spfa}$ 就好了，这样写反而还可能会超时，但是上述的做法才能逐步拓展到 $n \leq 4\times 10^4$ 。

**考虑 $n\leq 200$ 的情况。**

$val(i,j)$ 一样可以求出来，但是 $d$ 是求不了。（悲)

考虑每一次操作，对 $f$ 中 $1$ 的个数有三种变化：$+2$，不变，$-2$，显然 $+2$ 是不可能的，这辈子都不可能的。而对于不变的情况，是我可以看成是 $-2$ 操作中的其中几步，因为新增的那个 $1$ 一定是要在之后被删掉的。那么我们在做 $\mathrm{spfa}$ 的时候，每次转移都要保证 $i \in S, j \in S, i < j$ ，然后仔细想想，其实根本不需要 $\mathrm{spfa}$ ，只需要一个 $dp$ 就可以了，因为每个 $S$ 只会向自己的真子集连边。同时，我们已经不需要记住每一个位置的状态，只需要记住 $f$ 初始状态中，是 $1$ 的位置就好了。

**考虑 $n\leq 4\times 10^4$ 的情况。**

因为我们转移的时候只用到了 $f$ 初始状态是 $1$ 的位置，所以 $val(i,j)$ 更改为将 $pos_i,pos_j$ 取反所需要的最小步数，其中 $pos_i$ 表示 $f$ 的初始状态中第 $i$ 个为 $1$ 的位置。因为原数组只有 $k(k\leq 8)$ 个 $1$ ,那么 $pos$ 的大小至多为 $16$ 。但是我们在计算 $val(i,*)$ 的时候依然要遍历所有的点，所以计算 $val(i,j)$ 的时间复杂度是 $O(kn)$ 。

那么总的时间复杂度为 $O(kmn+2^{k}k^2)$ 。

**考虑$k\leq 11$的情况。**

对于一个 $dp$ 的状态 $S$ ，其第一个为 $1$ 的位置是一定要变成 $0$ 的（废话），那么我们在每一次转移的时候都强制选择第一个为 $1$ 的位置作为 $i$ ,然后再枚举配套的第二个位置。

那么最终的时间复杂度为 $O(nmk+2^k k)$ 。

```cpp
#include <bits/stdc++.h>

using namespace std;

const int maxn = 4e4 + 5, maxk = 15, maxm = 75;
int n, m, k, pos_sz, b[maxm], sta[maxn];
int pos[maxk << 1], val[maxk << 1][maxk << 1];

int dist[maxn], vis[maxn];
queue<int> q;
void calc_dfs() {
    for (int st = 1; st <= pos_sz; st++) {
        memset(dist, 0x3f, sizeof(dist)), memset(vis, 0, sizeof(vis));
        q.push(pos[st]), vis[pos[st]] = 1, dist[pos[st]] = 0;
        while (!q.empty()) {
            int u = q.front(); q.pop();
            for (int i = 1; i <= m; i++) {
                int v = u + b[i];
                if (v <= n + 1 && !vis[v]) {
                    dist[v] = dist[u] + 1, vis[v] = 1;
                    q.push(v);
                } 
                v = u - b[i];
                if (v >= 1 && !vis[v]) {
                    dist[v] = dist[u] + 1, vis[v] = 1;
                    q.push(v);
                } 
            }
        }
        for (int ed = 1; ed <= pos_sz; ed++)
            val[st][ed] = dist[pos[ed]];
    }
}

int f[1 << (11 << 1)];

int main() {
    scanf("%d%d%d", &n, &k, &m);
    for (int i = 1; i <= k; i++) {
        int p; scanf("%d", &p);
        sta[p] ^= 1, sta[p + 1] ^= 1;
    }
    for (int i = 1; i <= m; i++) scanf("%d", &b[i]);
    for (int i = 1; i <= n + 1; i++) if (sta[i]) 
        pos[++pos_sz] = i;
    calc_dfs();
    
    memset(f, 0x3f, sizeof(f));
    int maxS = (1 << pos_sz) - 1; f[maxS] = 0;
    for (int S = maxS; S >= 1; S--) {
        int p = 1;
        while (!(S & (1 << (p - 1)))) p++; 
        for (int p2 = p + 1; p2 <= pos_sz; p2++) {
            if (!(S & (1 << (p2 - 1)))) continue;
            int nexS = S ^ (1 << (p - 1)) ^ (1 << (p2 - 1));
            f[nexS] = min(f[nexS], f[S] + val[p][p2]);
        }
    }
    printf("%d\n", f[0]);
    return 0;
}
```

---

## 作者：Brioche (赞：0)


### 状压dp+差分

### [星空](https://www.luogu.org/problemnew/show/P3943)
这题思维难度还是很大的.
首先发现n特别的大,但是k特别小,显然是要在k上面做文章.

考虑对原序列进行异或差分,这样有什么好处呢?于是$010000110$就变成了$0110000101$

好处就是区间取反$[l,r]$的时候等价于在异或序列上取反$l-1$和$r$,于是现在我们的目标就变成把异或序列上的每一个元素通过每次取反两个间隔一定的点,变成0的最小次数.

由于我们一次在两个0上取反没有任何意义,每一次修改要么是把两个1变成0,要么是一个0变1,一个1变0.如果是后者的话,我们可以把它看做这个前面的1往后跳了一段,最后还是要通过和另外一个1同时消掉.

于是就变成了点与点之间两两配对求最小代价的问题.点与点之间匹配的最小代价可以通过bfs预处理.

注意这里不是二分图匹配,是随意匹配,所以不能用二分图匹配的算法.
一个状压dp轻松搞定.

注意这个dp看起来是$O(2^kk^2)$的,事实上是$O(2^kk)$的.

$k^2$进行了大量的重复运算,事实上我们只要按顺序找到一对没有匹配过的点直接转移就可以了.

这样显然是可以遍历转移到所有的状态的.

搬运zsy巨巨的代码.
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<cstdlib>
#include<ctime>
#include<queue>
#include<set>
#include<map>
#include<vector>
#include<bitset>
#define mid ((l+r)>>1)
#define rc ((rt<<1)|1)
#define lc (rt<<1)
#define ll long long
#define FILE(s) freopen(s".in","r",stdin),freopen(s".out","w",stdout)
using namespace std;
int gi()
{
	char c;int x,sign=1;
	while((c=getchar())>'9'||c<'0')if(c=='-')sign=-1;
	x=c-'0';while((c=getchar())>='0'&&c<='9')x=(x<<1)+(x<<3)+c-'0';
	return x*sign;
}
int n,m,k,vis[40005],cost[17][17],st[17];
int f[1<<17],b[100],dis[40005];queue<int> q;
void bfs(int s,int *f)
{
	memset(dis,0,sizeof(vis));dis[s]=1;q.push(s);
	while(!q.empty())
	{
		int u=q.front();q.pop();
		for(int i=1;i<=m;i++)
		{
			if(u+b[i]<=n&&!dis[u+b[i]])dis[u+b[i]]=dis[u]+1,q.push(u+b[i]);
			if(u-b[i]>=1&&!dis[u-b[i]])dis[u-b[i]]=dis[u]+1,q.push(u-b[i]);
		}
	}
	for(int i=1;i<=k;i++)f[i]=dis[st[i]]-1;
}
int main()
{
	FILE("starlit");
	cin>>n>>k>>m;n++;
	for(int i=1,x;i<=k;i++)x=gi(),vis[x]^=1,vis[x+1]^=1;//把初始序列异或差分
	k=0;
	for(int i=1;i<=n;i++)if(vis[i])st[++k]=i;//标记哪些点是1
	for(int i=1;i<=m;i++)b[i]=gi();//读入操作的类型
	for(int i=1;i<=k;i++)bfs(st[i],cost[i]);//预处理出所有点两两之间的最少到达次数
	memset(f,0x3f,sizeof(f));f[0]=0;
	for(int i=0;i<(1<<k)-1;i++)//状压dp
	{
		for(int j=1;j<=k;j++)//O((2^k)*k)的复杂度
		{
			if((1<<(j-1))&i)continue;
			for(int l=j+1;l<=k;l++)
			{
				if(((1<<(l-1))&i)||cost[j][l]==-1)continue;
				f[i|(1<<(j-1))|(1<<(l-1))]=
					min(f[i|(1<<(j-1))|(1<<(l-1))],f[i]+cost[j][l]);
			}
			break;//按顺序一对一对地加点
		}
	}
	cout<<f[(1<<k)-1]<<endl;
	return 0;
}

```





---


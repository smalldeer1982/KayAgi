# 采摘毒瘤

## 题目背景

Salamander见到路边有如此多的毒瘤，于是见猎心喜，从家里拿来了一个大袋子，准备将一些毒瘤带回家。


## 题目描述

路边共有$n$种不同的毒瘤，第$i$种毒瘤有$k_i$个，每个需要占据$d_i$的空间。Salamander的袋子能装下的最大体积为$m$。


Salamander是一个很贪心的人，不过他也**不要求**带尽可能多或是总体积尽可能大的毒瘤回家，他只要求袋子里**再也装不下剩余的任何一种毒瘤**。


Salamander想知道有多少种不同的装毒瘤的方案。两种方案不同当且仅当取的毒瘤种类不同或者至少有一种毒瘤取的数量不同。由于方案数可能太多，请输出答案对$19260817$取模后的结果。


## 说明/提示

###样例解释：

两种方案如下：

1.取1个第一种毒瘤和2个第二种毒瘤。

2.取3个第二种毒瘤。


$~$
$~$

对于10%的数据，$1\leq n,k_i,d_i\leq 10$，$1\leq m\leq 100$；

对于30%的数据，$1\leq n,k_i,d_i\leq 50$，$1\leq m\leq 5000$；

对于另外20%的数据，$k_i=1$；

对于100%的数据，$1\leq n,k_i,d_i\leq 500$，$1\leq m\leq 10^5$。


## 样例 #1

### 输入

```
2 5
2 3
3 1```

### 输出

```
2```

# 题解

## 作者：Salamander (赞：27)

大意：一些物品，每个有数量和大小，给你一个有总容量限制的背包，要求选一些物品使得剩余的物品都放不进去，求方案数。

我们先考虑如何暴力。如果没有限制条件，那么本题就是一个裸的多重背包计数。
	
所以我们可以枚举剩下的物品中最小的是哪一个，把比他小的先放进去，然后对它和比它大的做多重背包。
	
记当前枚举的最小物品为$i$，$V_i$为大小，$k_i$为数量，当前比$i$小的物品总大小为$sum$，背包容量为$m$，$dp[j]$表示物品总大小为$j$时的方案总数。
	
那么当前的方案总数为$\displaystyle\sum_{j=m-sum-V_i+1}^{m-sum}dp[j]$，因为当前留下的背包空间最大为$m-sum$，我们不能让$V_i$有能放进去的地方，所以空间最小为$m-sum-V_i+1$。同时，我们必须留下至少一个物品$i$不放进去，所以在做多重背包的时候$k_i$要减一。
	
$~$
	
$10pts$: 爆搜、乱搞。
	
$30pts$: 枚举剩下的最小物品，然后多重背包。
	
在我们的暴力中，每次都进行了一次$i$到$n$的多重背包，这样浪费了很多信息。
	
所以我们可以从大到小枚举所剩的物品中最小的是哪一个，这样就可以利用上上一轮的$dp$数组，只需要把当前物品加入到$dp$数组中即可，不需要重新$dp$。

$50pts$: 有20分的数据是01背包，所以利用上一次的信息可以将复杂度降至01背包复杂度$O(nm)$。
	
$100pts$: 可以在更新背包的时候按模$V_i$余数分组，用队列的思想优化多重背包至$O(nm)$即可通过此题(详见徐持衡的国家集训队论文，不过应该差不多已经烂大街了...)。

代码很短：
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;

#define For(i,_beg,_end) for(int i=(_beg),i##end=(_end);i<=i##end;++i)
#define Rep(i,_beg,_end) for(int i=(_beg),i##end=(_end);i>=i##end;--i)

template<typename T>T Max(const T &x,const T &y){return x<y?y:x;}
template<typename T>T Min(const T &x,const T &y){return x<y?x:y;}
template<typename T>int chkmax(T &x,const T &y){return x<y?(x=y,1):0;}
template<typename T>int chkmin(T &x,const T &y){return x>y?(x=y,1):0;}
template<typename T>void read(T &x){
    T f=1;char ch=getchar();
    for(;ch<'0'||ch>'9';ch=getchar())if(ch=='-')f=-1;
    for(x=0;ch>='0'&&ch<='9';ch=getchar())x=x*10+ch-'0';
    x*=f;
}

const int N=510,maxn=1000010,mod=19260817;
struct Thing{
    int k,d;
    bool operator<(const Thing &x)const{return d<x.d;}
}a[N];
int n,m,ans,tot,dp[2][maxn],cur;

inline int M(int x){return x>=mod?x-mod:x;}
void Insert(int k,int w){
    int sum,H;
    For(d,0,w-1){
        H=sum=0;
        For(j,0,(m-d)/w){
            sum=M(sum+dp[cur^1][j*w+d]);
            if(H<j-k)sum=M(sum-dp[cur^1][(H++)*w+d]+mod);
            dp[cur][j*w+d]=sum;
        }
    }
}

int main(){
    read(n);read(m);
    For(i,1,n) read(a[i].k),read(a[i].d),tot+=a[i].k*a[i].d;
    if(tot<=m)return puts("1"),0;
    sort(a+1,a+n+1);
    dp[0][0]=1;
    Rep(i,n,1){
        tot-=a[i].k*a[i].d;
        cur^=1;
        Insert(a[i].k-1,a[i].d);
        For(j,Max(m-tot-a[i].d+1,0),m-tot) ans=M(ans+dp[cur][j]);
        Insert(a[i].k,a[i].d);
    }
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：TEoS (赞：5)

本题同步发表在[我的blog](https://www.cnblogs.com/TEoS/p/13616349.html)

------------
**题意分析**

给出 $n$ 种物品，每种物品有数量和大小，要求放入一定大小的背包，求不能再放入任何物品的方案数。

**思路分析**

分析后可以发现这个问题就是在多重背包计数问题的基础上加上了放不进剩下的物品的条件，考虑对这个条件进行处理。

可以想到枚举剩下的物品中体积最小的物品，然后将比它小的物品先放进去，再对剩下的物品做多重背包。每次都重新计算显然复杂度太大，想到先将物品按照体积从大到小排序，然后一种种放入即可。

暴力多重背包显然是过不去的，想到用类似于单调队列优化多重背包的思想。但是这里是计数问题，直接用队列就可以了。发现求解时不需要知道队列内具体的元素，只需要知道队列内的元素和就可以，因此可以不进行队列实际操作。由于计算时需要用到上一次的状态，因此需要多开一维，可以使用滚动数组优化。答案就是 $\sum_{j=max(m-sum-d+1,0)}^{m-sum} f[j]$，$sum$ 是比当前枚举到的物品小的物品大小之和。

注意，因为当前枚举的物品一定要剩下，所以再计算的时候先将当前物品个数减 $1$ ，计算结束后再用原个数更新状态。

因为计算的情况一定有物品剩余，因此要特判所有物品都放得下的情况。

```c++
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<queue>
using namespace std;
const int N=600,M=1e5+100,P=19260817;
struct Node
{
	int k,d;
	#define k(i) a[i].k
	#define d(i) a[i].d
}a[N];
int n,m,sum,ans,q;
int f[2][M];
bool cmp(Node x,Node y)
{
	return x.d>y.d;
}//按大小从大到小排序
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
		scanf("%d%d",&k(i),&d(i)),sum+=k(i)*d(i);
	if(sum<=m)
	{
		puts("1");
		return 0;
	}//特判
	sort(a+1,a+n+1,cmp);f[0][0]=1;//初值
	for(int i=1;i<=n;i++)
	{
		sum-=k(i)*d(i);k(i)--;q^=1;//数量先减一
		for(int u=0;u<d(i);u++)
		{
			int maxp=(m-u)/d(i),now=0;
			for(int p=0;p<=maxp;p++)
			{
				if(p-k(i)-1>=0)
					now=(now+P-f[q^1][u+(p-k(i)-1)*d(i)])%P;//去掉末尾过时的部分
				f[q][u+p*d(i)]=now=(f[q^1][u+p*d(i)]+now)%P;//计算并更新状态
			}
		}
		for(int j=max(m-sum-d(i)+1,0);j<=m-sum;j++)
			ans=(ans+f[q][j])%P;k(i)++;//计算答案并加回来
		for(int u=0;u<d(i);u++)
		{
			int maxp=(m-u)/d(i),now=0;
			for(int p=0;p<=maxp;p++)
			{
				if(p-k(i)-1>=0)
					now=(now+P-f[q^1][u+(p-k(i)-1)*d(i)])%P;
				f[q][u+p*d(i)]=now=(f[q^1][u+p*d(i)]+now)%P;
			}
		}//更新状态
	}
	printf("%d",ans);
	return 0;
}
```



---

## 作者：nzcnnr (赞：3)

我的第一篇紫题题解

[在我的博客食用更佳](https://www.cnblogs.com/nxhx/articles/16862406.html)
# 思路
考虑到必须得要剩下一些毒瘤，且我们要考虑剩下毒瘤的最小值，我们就用 $i$ 来表示剩下毒瘤的最小值，而小于它的体积此时必定需要放进去，所以说我们就用 $sum$ 表示小于当前毒瘤价值的总体积数，而大于等于目前的剩下毒瘤体积最小值的毒瘤变需要进行一个分组背包统计答案，朴素的分组背包的复杂度是 $O{(nmk)}$ 的，所以说必须进行优化。
# 优化
~~其他题解似乎讲的不太详细，我就给那些没有学过单调队列优化多重背包的人做一个粗略的解释~~。

$dp[i][j]$ 表示装到第 $i$ 个物品，占了 $j$ 格空间的一个数，而我们注意到所有可以从 $dp[i-1][k]$ 转移过来的状态必定满足
$$j\equiv k\pmod{K}$$
在这里 $K$ 表示第 $i$ 个物品的价值。

所以我们可循环模拟 $j\bmod{K}$ 的值，然后再模拟出 $j$ 的值，此时的复杂度便减小到了 $O{(nm)}$，而同时对于第 $i$ 个物品，有数量的限制，一般情况下可以用单调队列作为滑动区间模拟数量的限制而统计最大值，而这道题统计方案数，所以说普通队列向右滑动，将队首依次踢掉即可。
# 实现
根据上文所述，我们可以表示出来递推公式：
$$ \sum\limits_{i=m-sum-d+1}^{m-sum}dp_i$$
依据题意，$d$ 表示第 $i$ 个物体的价值，$dp_i$ 表示方案数量，$m$ 表示背包空间，$sum$ 如上文所表示的意思相同。

同时，我们对于如上的分组背包，要保证至少留一个毒瘤在外，所以我们要先进行数量减一的操作，最后在把答案统计完后要把一个毒瘤加上再进行分组背包。

本题仍然需要备份一个 $dp$ 数组作为滚动数组的优化。
# CODE
```c
#include<stdio.h>
#include<algorithm>
#include<queue>
using namespace std;
const long long mod=19260817;
long long dp[2][100005];
long long ans;
struct node{
	int k,d;
	bool operator <(const node &p) const{//从大到小排列
		return d>p.d; 
	}
};
int main(){
	int n,m;
	scanf("%d%d",&n,&m);
	node input[605];
	long long sum=0;
	for(int i=1;i<=n;i++){
		scanf("%d%d",&input[i].k,&input[i].d);
		sum+=input[i].k*input[i].d;//求sum
	}
	if(sum<=m){//1种特判，如果所有毒瘤都可以被装下
		printf("1");
		return 0;
	} 
	sort(input+1,input+n+1);
	int q=0;
	dp[0][0]=1;
	for(int i=1;i<=n;i++){
		sum-=input[i].k*input[i].d;
		input[i].k --;//必须要剩下来一个，否则可能一个都不留
		q^=1;
		for(int j=0;j<input[i].d;j++){
			long long cnt=0;
			for(int k=0;k*input[i].d+j<=m;k++){//模拟队列求方案数
				if(k>input[i].k){
					cnt=(cnt+mod-dp[q^1][(k-input[i].k-1)*input[i].d+j])%mod;
				}
				dp[q][k*input[i].d+j]=(dp[q^1][k*input[i].d+j]+cnt)%mod;
				cnt=dp[q][k*input[i].d+j];
			}
		}
		for(int j=max(m-sum+1-input[i].d,(long long)0);j<=m-sum;j++){
			ans+=dp[q][j];
			ans%=mod;
			//printf("%d ",ans);//ans求值
		} 
		input[i].k++;
		for(int j=0;j<input[i].d;j++){//重新进行分组背包
			long long cnt=0;
			for(int k=0;k*input[i].d+j<=m;k++){
				if(k>input[i].k){
					cnt=(cnt+mod-dp[q^1][(k-input[i].k-1)*input[i].d+j])%mod;
				}
				dp[q][k*input[i].d+j]=(dp[q^1][k*input[i].d+j]+cnt)%mod;
				cnt=dp[q][k*input[i].d+j];
			}
		}
	}
	printf("%lld",ans);
	return 0; 
} 
```
当然，您也可以选择用 STL 使代码进一步直观化
```c
#include<stdio.h>
#include<algorithm>
#include<queue>
using namespace std;
const long long mod=19260817;
long long dp[2][100005];
long long ans;
struct node{
	int k,d;
	bool operator <(const node &p) const{
		return d>p.d; 
	}
};
int main(){
	int n,m;
	scanf("%d%d",&n,&m);
	node input[605];
	long long sum=0;
	for(int i=1;i<=n;i++){
		scanf("%d%d",&input[i].k,&input[i].d);
		sum+=input[i].k*input[i].d;
	}
	if(sum<=m){
		printf("1");
		return 0;
	} 
	sort(input+1,input+n+1);
	int q=0;
	dp[0][0]=1;
	for(int i=1;i<=n;i++){
		sum-=input[i].k*input[i].d;
		input[i].k --;
		q^=1;
		for(int j=0;j<input[i].d;j++){
			long long cnt=0;
			queue<int>f;
			for(int k=0;k*input[i].d+j<=m;k++){
				if(f.size()>input[i].k){
					cnt=(cnt+mod-f.front())%mod;
					f.pop();
				}
				dp[q][k*input[i].d+j]=(dp[q^1][k*input[i].d+j]+cnt)%mod;
				cnt=dp[q][k*input[i].d+j];
				f.push(dp[q^1][k*input[i].d+j]); 
			}
		}
		for(int j=max(m-sum+1-input[i].d,(long long)0);j<=m-sum;j++){
			ans+=dp[q][j];
			ans%=mod;
			//printf("%d ",ans);
		} 
		input[i].k++;
		for(int j=0;j<input[i].d;j++){
			long long cnt=0;
			queue<int>f;
			for(int k=0;k*input[i].d+j<=m;k++){
				if(f.size()>input[i].k){
					cnt=(cnt+mod-f.front())%mod;
					f.pop();
				}
				dp[q][k*input[i].d+j]=(dp[q^1][k*input[i].d+j]+cnt)%mod;
				cnt=dp[q][k*input[i].d+j];
				f.push(dp[q^1][k*input[i].d+j]); 
			}
		}
	}
	printf("%lld",ans);
	return 0; 
} 
```
时间对比（均开了 O2） [使用队列](https://www.luogu.com.cn/record/88644046)，[不使用队列](https://www.luogu.com.cn/record/88643728)。

不使用队列会更快（~~那不是废话~~）。


---

## 作者：Walrus (赞：2)

省流：复杂度是 $O(NM)$ 的。

![](https://cdn.luogu.com.cn/upload/image_hosting/jbi9kbey.png)

## 0

多重背包可以通过枚举选的个数做到 $O(N^2 M)$。

转移是 $f_j=\max(f_{j-k\times w_i}+v_i\times k)$。

## 1

注意到你每次转移好像只用到了一部分 $f_j$，并且 $j-k\times w_i$ 这个东西 $j\bmod w_i$ 都相同，考虑将 $j\bmod w_i$ 相同的 $f_j$ 归为一类。

观察转移式子，令 $j=k\times w_i+b$，转移变为 $f_{j}=\max(f_{k\times w_i+b-x\times w_i}+x\times v_i)$。

考虑外面的 $x\times v_i$ 怎么搞，显然是不能枚举 $x$ 的，可以将 $x\times v_i\leftarrow -(k-x)\times v_i+k\times v_i$，这样的话 $k\times w_i$ 就不受影响，可以直接拿到外面去，变为

$$f_j=\max(f_{j-(k-x)\times w_i+b}-(k-x)\times v_i)+k\times v_i$$

再令 $t=k-x$：

$$f_j=\max(f_{j-t\times w_i+b}-t\times v_i)+k\times v_i$$

注意 $k-x>0$，这个过程可以用滑动窗口最大值维护，用个单调队列搞一搞即可。

复杂度可以证明是 $O(NM)$ 的。


## Solution

多重背包极大方案数，考虑直接按物品大小倒序枚举一个 $i$，所有 $w_j<w_i$ 的必须全部加进去，然后再对 $w_j\geq w_i$ 的做多重背包计数。

设 $f_{i,j}$ 表示前 $i$ 种容量为 $j$ 极大方案数，转移很简单：

$$f_{i,j}=\sum\limits_{l=0} ^ {s_i} f_{i-1,j-l\times w_i}$$

观察到每一个 $i$ 只与前一个有关系可以滚掉第一维，剩下的多重背包可以通过上述方法优化。

代码参考[这个](https://www.luogu.com.cn/article/78cop08b)的写的比较好。

模板题是 P1776，远古时期代码写的很丑不放了。

---

## 作者：_Yoimiya_ (赞：1)

[题目传送门。](https://www.luogu.com.cn/problem/P4241)

解题思路：
- 看题知每种个毒瘤有数量和大小，一眼看出是多重背包。
- 题目并不是传统问法，题目问的是再也装不下剩余物品。那么就改一改原来的 DP 方法。  

- 先有一个暴力想法：先把物品从大到小排序，枚举每个物品，把它当成剩下物品中体积最小的物品，然后对剩下的物品跑一次多重背包。不加优化的时间复杂度是 $O(n^2mk)$。显然爆了。  

- 那只能对多重背包进行优化。这里使用的多重背包使用了单调队列优化的思想（楼上题解解释了：“但是这里是计数问题，直接用队列就可以了”。）。于是乎时间复杂度变成了优秀的 $O(n^2m)$，因为时间限制是 3 秒，所以可以过。  

- DP 的状态转移方程，和多重背包大同小异：定义  $sum$ 为比当前枚举到的物品小的物品大小和，则答案为：$\sum\limits_{i=max(m-sum-d+1,0)}^{(m-sum)}f_i$。

- 其中 $sum$ 的维护可以利用前缀和的思想。因为我们按物品大小排了序，枚举时从大到小枚举，所以没有枚举的物品都比当前枚举的物品要小，在枚举前减去当前大小即可得出当前所需的 $sum$。

 AC 代码
 ```cpp
 #include<bits/stdc++.h>
using namespace std;
const int Mod(19260817);
const int M(1e5+1);
const int N(501);
struct node{
	int k,d;
	bool operator<(const node &x)const{
		return d>x.d;
	}
};node a[N];
int n,m,sum,ans,t,f[M][2];
inline void solve(int i,int w){
	for(register int j(0);j<a[i].d;++j){
		int maxn((m-j)/a[i].d),pos(0);
		for(register int p(0),z(0-a[i].k-1);p<=maxn;++p,z=(p-a[i].k-1)){
			if(z>=0) pos=(pos+Mod-f[j+z*a[i].d][w^1])%Mod;
			f[j+p*a[i].d][w]=pos=(f[j+p*a[i].d][w^1]+pos)%Mod;
		}
	}return ;
}
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0); 
	cin>>n>>m;
	for(register int i(1);i<=n;++i){
		cin>>a[i].k>>a[i].d;sum+=a[i].d*a[i].k; 
	}
	if(sum<=m){cout<<"1";return 0;}
	sort(a+1,a+n+1); f[0][0]=1;
	for(register int i(1);i<=n;++i){
		sum-=a[i].k*a[i].d;--a[i].k;t^=1;
		solve(i,t);
		for(register int j(max(m-sum-a[i].d+1,0));j<=m-sum;++j)
		ans=(ans+f[j][t])%Mod; ++a[i].k;
		solve(i,t);
	} 
	cout<<ans;return 0;
}
 ```

---

## 作者：xxxxxzy (赞：0)

水题解。

先考虑多重背包计数怎么做，设当前加入一个重量为 $w$，有 $k$ 件的物品，记 $f_i$ 为选重量为 $i$ 的方案是。

每次转移按对 $w$ 取模的值分类，记 $g_{i,j}$ 为重量 $W$ 对 $w$ 取模为 $j$，且 $\left \lfloor \dfrac{W}{w}  \right \rfloor = i$ 的方案数。

这样 $g_{i,j} \to g_{i+x,j}(0 \le x \le k)$，这个显然是可以前缀和优化的，这就是多重背包计数的 $O(nm)$ 做法。

题目多了一个极大的限制，考虑按重量排序，然后强制选择所有 $< w_i$ 价值的物体，记为 $s$，那么相当于容量 $\le m-s-w_i+1$ 的多重背包计数。

值得注意的是，算答案的时候，要把 $k_i$ 先减一，因为必须钦定有一个 $i$ 没选。

时间 $O(nm)$。

---

## 作者：sosksyx_is_my_wife (赞：0)

### 题意

$n\leq 500$ 个物品的多重背包，背包容量为 $10^5$，求填满背包至无法放下任何物品的方案数。

### 题解

考虑朴素的多重背包计数怎么做，暴力枚举数量显然是 $O(n^2m)$ 的，而且不能用二进制分组优化。

但是类似于单调队列优化，我们把背包已用的体积按物品体积 $k_i$ 分组，具体的，对于 $k_i$ 模数相同的可以归在一起，且组间不会相互贡献，用前缀和优化即可跑到单次 $O(m)$ 插入新物品。

于是多重背包计数就做完了。

现在考虑题目中的限制。

首先容易想到的是，先把物品按照体积排序，枚举剩余没选的物品的最小值。

则，小于这个最小值的物品都要选出来，这些物品体积确定，个数确定，可以看作一个物品。

然后考虑大于这个最小值的物品，这些物品显然是任意选的，直接合并进来，这相当于是对这些物品跑一个后缀多重背包。

再考虑等于这个最小值的物品，我们要留一个最小值，保证最小值为我们枚举的数，相当于在所有体积为当前枚举的最小值的物品中删去一个，然后把余下的加入。

时间复杂度 $O(nm)$，不卡常。

### Code

```cpp
const int mod=19260817;
const int N=510;
const int M=1e5+10;
int n,a[N],c[N],m,ans;
void chk(int &x,int y){
	x=(x+y)%mod;
}

int g[M];
void calc(int i,int (&dp)[M]){
	memcpy(g,dp,sizeof g);//滚动数组
	for(int k=c[i];k<=m;k++){
		chk(g[k],g[k-c[i]]);//做前缀和
	}
	memset(dp,0,sizeof dp);

	for(int j=0;j<c[i];j++){
		for(int k=j;k<=m;k+=c[i]){
			if(k<c[i]) dp[k]=g[k];
			else if(k-c[i]*a[i]<c[i]) chk(dp[k],g[k]);
			else chk(dp[k],g[k]-g[k-c[i]*(a[i]+1)]);
		}
	}
}
int f[M],dp[M],sum[N];
signed main(){
	n=read();m=read();
	for(int i=1;i<=n;i++){
		a[i]=read();c[i]=read();
	}

	for(int i=1;i<=n;i++){
		for(int j=i;j<=n;j++){
			if(c[i]>c[j]) swap(c[i],c[j]),swap(a[i],a[j]);
		}
		sum[i]=sum[i-1]+c[i]*a[i];
	}//选择排序，当然你可以用 sort

	dp[0]=1;
	for(int i=n;i>=1;i--){
		memset(f,0,sizeof f);
		if(sum[i-1]<=m){
			for(int j=m;j>=sum[i-1];j--){
				chk(f[j],dp[j-sum[i-1]]);//相当于把前面的物品看成一个物品，插入到后缀背包中
			}

			a[i]--;calc(i,f);a[i]++;//删去一个，保证最小值，然后插入
			for(int j=m-c[i]+1;j<=m;j++) chk(ans,f[j]);
		}
		calc(i,dp);//后缀背包
	}
	if(sum[n]<m) ans=1;//特判掉背包装不满的情况
	cout<<(ans+mod)%mod;
	return 0;
}

```

---


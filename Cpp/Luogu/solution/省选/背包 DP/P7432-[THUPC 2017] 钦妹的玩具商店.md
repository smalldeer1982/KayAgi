# [THUPC 2017] 钦妹的玩具商店

## 题目描述

钦妹和弗雷兹在 C 市有一个玩具店，店里有 $n$ 种玩具，编号依次为 $1,2,...,n$，第 $i$ 件玩具的单价为 $c_i$ 元，一个该玩具提供的愉悦度为  $v_i$。

突然有一天，C 市来了 $m$ 个小朋友。据可靠消息，接下来 $Q$ 天，这些小朋友每天都会来店里买东西，其中第 $i$ 个小朋友每天都会带 $i$ 元  （$1\le i\le m$）。

由于某些玩具不是很优秀，所以每天都会有不同的玩具被禁止出售给小朋友。具体来说，在第 $i$ 天，编号在区间 $[l_i,r_i]$ 内的物品小朋友是不能购买的。

除此之外，为了防止小朋友们太愉悦，每件玩具都有一个限购件数  $t_i$。也就是说，对于第 $i$ 种玩具，每个小朋友在每一天的购买件数都必须为不超过 $t_i$ 的非负整数。

现在，对于每一天，你想知道：所有小朋友所能获得的最大愉悦度之和（对 $10^8+7$ 取模）；所有小朋友所能获得的最大愉悦度的异或和（异或运算是 $\operatorname{xor}$ 运算，即 C++/Java/Python 中的 `^` 运算）。

本题强制在线，具体规则在输入描述中体现。

## 说明/提示

对于所有的数据，$1\le n,m,Q,c_i,t_i\le 10^3$，$1\le v_i\le 2.5\times 10^5$，$\sum n,\sum m,\sum Q\le 10^4$。
#### 版权信息
来自 THUPC（THU Programming Contest，清华大学程序设计竞赛）2017。

## 样例 #1

### 输入

```
2
3 10 3
2 3 3
20 50 24
3 1 10
1 1
2 2
3 3
2 7 3
6 7
1 2
1 1
1 1
2 2
1 2```

### 输出

```
568 120
660 20
660 20
2 2
2 0
0 0```

# 题解

## 作者：a___ (赞：4)

分块。   

设每块大小为 $S$，将 $n$ 个玩具分成 $\dfrac nS$ 块。  
设 $f_{l,r,x}$ 表示仅所有在 $[1,l]\cup[r,\dfrac nS]$ 块内的玩具可售时编号为 $x$ 的小朋友愉悦度的最大值。   
我们从 $1$ 到 $n$ 顺次做背包，每做完一个块就用另一个指针从右向左扫一遍做背包，就可以容易地求出 $f$。   
查询 $l,r$ 时先拿来 $f_{belong[l]-1,belong[r]+1}$ 再把 $l$ 所在块内和 $r$ 所在块内暴力加入。   

时间复杂度：  
修改：$\Theta(\sum n\cdot\dfrac nS\cdot m)=\Theta(\sum\dfrac{n^2m}S)$  
查询：$\Theta(\sum q\cdot S\cdot m)=\Theta(\sum qmS)$   
总复杂度为 $\Theta(\sum m(\dfrac{n^2}S+qS))$，取 $S=\dfrac n{\sqrt q}$ 时最优为 $\Theta (\sum nm\sqrt q)$。 注意如果用的不是单调队列优化多重背包而是二进制分组的话还要多个 $\log$。  

空间复杂度：  
$\Theta(\dfrac nS\cdot\dfrac nSm)=\Theta(\frac{n^2m}{S^2})$。  

取 $S=\sqrt n$ 时，时间复杂度为 $\Theta(\sum m(n+q)\sqrt n)$，空间复杂度为 $\Theta(nm)$，注意到 $\sqrt n$ 最大只有 $\sqrt{1000}\approx30$，可以通过此题。

---

## 作者：Amadeus004 (赞：1)

### [传送门](https://luogu.com.cn/problem/P7432)

### 叠甲
这是本蒟蒻的第一篇题解，个人功力不是很深厚，写的不好请见谅，如有错误欢迎大家指出。

### 正文
看到区间操作，想到用数据结构维护。题目要求是在线的，故不可以像 P6240 一样离线下来分治求答案，需要预处理。奇奇怪怪的东西用分块处理最方便了。

对于多重背包，用二进制拆分或用单调队列优化即可。

如何预处理才能比较高效地实现预处理和查询呢？
### 想法1
取块长为 $\sqrt{n}$，整个序列将被分为 $\sqrt{n}$ 块。

记 $f_{i,j,x}$ 为花费 $x$ 的代价时，第 $i$ 块到第 $j$ 块的物品对答案的最大贡献。

从前往后求背包数组，每处理一个块就向前扫一次，即可求出所有的 $f_{i,j}$。预处理时间复杂度为 $\Theta(nm\sqrt{n})$。

对于每个询问 $[l,r]$，设 $l,r$ 所在块分别为 $P,Q$。我们已知整块 $f_{1,P-1}$ 和 $f_{Q+1,\sqrt n}$ 的答案。对于散块 $[L[P],l-1]$、$[r+1,R[Q]]$，将其暴力加入，最后用$\Theta(m)$ 时间合并 $f_{1,P-1}$ 和$f_{Q+1,\sqrt n}$，单次查询的时间复杂度 $\Theta(m^2+m\sqrt n)$，甚至不如暴力的 $\Theta(nm)$。交到 loj 上，开了-Ofast 一个点都要两秒，[记录](https://loj.ac/s/2076136)。

### 想法2
将整块分为两部分，这样做在合并的过程中做了许多无用功。

考虑在预处理的时候就求出 $f_{1,i}$ 加上 $f_{j,\sqrt n}$ 的答案。可以发现前者从前往后扫一次数据就可以求出；对于后者，每处理一个块就从后往前扫一次就可以求出。重新定义 $f$ 数组，记 $f_{i,j,x}$ 表示花费 $x$ 的代价时，在 $[1,i] \cup [j,\sqrt n]$ 块内的物品对答案的贡献。预处理时间复杂度为 $\Theta(nm\sqrt n)$。

预处理时间复杂度与先前的没有区别，那么查询呢？已知整块的答案，散块暴力加入即可。由于不需要合并 $f$ 数组，故单次查询的时间复杂度为 $\Theta(m\sqrt n)$，比先前好上不少。

本人用了二进制优化来处理多重背包。程序的总时间复杂度为 $\Theta(\sum m(n+q)\sqrt n)$，空间复杂度为 $\Theta(nm)$。此处 $n=\sum \log {c_i}$。

### 核心代码
```
inline void init() {
    //预处理
    memset(f,0,sizeof(f));
    memset(g,0,sizeof(g));
    len=sqrt(n),t=(cnt-1)/len+1;
    for(int i=1;i<=t;i++)L[i]=(i-1)*len+1,R[i]=min(i*len,cnt);
    //将物品分块 
    for(int i=0;i<=t;i++){
		for(int j=L[i];j<=R[i];j++)
            for(int p=1000;p>=a[j].w;p--)
                g[p]=max(g[p],a[j].v+g[p-a[j].w]);
            // 1~i 的背包数组 
        memcpy(f[i][t+1],g,sizeof(g));
		for(int o=t;o>=i;o--){
			memcpy(f[i][o],f[i][o+1],sizeof(f[i][o+1]));
    		for(int j=L[o];j<=R[o];j++)
    			for(int p=1000;p>=a[j].w;p--)
    				f[i][o][p]=max(f[i][o][p],a[j].v+f[i][o][p-a[j].w]);
    			// j~sqrt(n) 的背包数组 
		}
    }
}
inline void query(int l, int r) {
    int P=(l-1)/len+1,Q=(r-1)/len+1;
    memcpy(g,f[P-1][Q+1],sizeof(g));
    //获取整块 
    for(int i=L[P];i<l;i++)
        for(int j=m;j>=a[i].w;j--)
            g[j]=max(g[j], g[j-a[i].w]+a[i].v);
    for (int i=r+1;i<=R[Q];i++)
        for (int j=m;j>=a[i].w;j--)
            g[j]=max(g[j],g[j-a[i].w]+a[i].v);
    //加入散块 
    for (int i=1;i<=m;i++)ans=(ans+g[i])%mod,ans1^=g[i]; 
    return;
}
```

---

## 作者：zhangxy__hp (赞：0)

分块，设块长为 $B$，预处理 $f_{l,r,x}$ 表示仅考虑 $[1,l]\cup[r,\frac{n}{B}]$ 中的玩具，花 $x$ 元的最大愉悦度。询问时向 $f_{bel_l-1,bel_r+1}$ 中加入 $l$ 和 $r$ 所在块内的玩具即可。$bel_l$ 表示 $l$ 所在块。

使用二进制优化多重背包，分析时间复杂度：

- 预处理 $O(\frac{n^2m\log{n}}{B})$
- 询问 $O(qmB\log{n})$

令 $B=\sqrt{n}$，时间复杂度为 $O((n+q)m\sqrt{n}\log{n})$，空间复杂度 $O(nm)$。

```cpp
#include<bits/stdc++.h>
#define int long long
#define il inline

using namespace std;
namespace asbt{
namespace cplx{bool begin;}
const int maxn=1e3+5,maxm=40,mod=1e8+7;
int T,n,m,q,blen,bnum;
int a[maxn],b[maxn],c[maxn];
int bel[maxn],st[maxm],ed[maxm];
struct DP{
	int f[maxn];
	il void init(){
		for(int i=0;i<=m;i++){
			f[i]=0;
		}
	}
	il int operator[](int x){
		return f[x];
	}
	il void upd(int x){
		int a=asbt::a[x],b=asbt::b[x],c=asbt::c[x];
		for(int i=1;i<=c;i<<=1){
			for(int j=m;j>=i*a;j--){
				f[j]=max(f[j],f[j-i*a]+i*b);
			}
			c-=i;
		}
		for(int i=m;i>=c*a;i--){
			f[i]=max(f[i],f[i-c*a]+c*b);
		}
	}
}dp[maxm][maxm];
il void solve(){
	cin>>n>>m>>q;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	for(int i=1;i<=n;i++){
		cin>>b[i];
	}
	for(int i=1;i<=n;i++){
		cin>>c[i];
	}
	blen=sqrt(n);
	bnum=(n+blen-1)/blen;
	for(int i=1;i<=bnum;i++){
		st[i]=ed[i-1]+1;
		ed[i]=min(ed[i-1]+blen,n);
		for(int j=st[i];j<=ed[i];j++){
			bel[j]=i;
		}
	}
	for(int i=0;i<=bnum;i++){
		if(!i){
			dp[i][bnum+1].init();
		}
		else{
			dp[i][bnum+1]=dp[i-1][bnum+1];
			for(int j=st[i];j<=ed[i];j++){
				dp[i][bnum+1].upd(j);
			}
		}
		for(int j=bnum;j>i;j--){
			dp[i][j]=dp[i][j+1];
			for(int k=st[j];k<=ed[j];k++){
				dp[i][j].upd(k);
			}
		}
	}
	int ans1=0,ans2=0;
	while(q--){
		int l,r;
		cin>>l>>r;
		l=(l+ans1-1)%n+1;
		r=(r+ans1-1)%n+1;
		if(l>r){
			swap(l,r);
		}
		DP ans=dp[bel[l]-1][bel[r]+1];
		for(int i=st[bel[l]];i<l;i++){
			ans.upd(i);
		}
		for(int i=ed[bel[r]];i>r;i--){
			ans.upd(i);
		}
		ans1=ans2=0;
		for(int i=1;i<=m;i++){
			ans1+=ans[i];
			ans2^=ans[i];
		}
		ans1%=mod;
		cout<<ans1<<" "<<ans2<<"\n";
	}
}
namespace cplx{
	bool end;
	il double usdmem(){return (&begin-&end)/1048576.0;}
}
signed main(){
//	cout<<cplx::usdmem();
	ios::sync_with_stdio(0),cin.tie(0);
	cin>>T;
	while(T--){
		solve();
	}
	return 0;
}
}
signed main(){return asbt::main();}
```

---

## 作者：wangsiqi2010916 (赞：0)

因为是求每个小朋友的最大愉悦值，一定是要跑背包的。

暴力的一种思路是正着跑一遍，再逆着跑一遍，然后将 $l$ 之前的结果和 $r$ 之后的结果合并。

但是这样的合并是 $O(m^2)$ 的。

还有一种暴力的方法是对每一组 $[l,r]$ 重新计算，这样每一问的时间就是 $O(nm)$ 的。

因为合并的时间复杂度太大，必须舍弃，第二种方法每一问重新计算，重复的运算很多。

所以可以预处理出不包含一些 $[l,r]$ 的背包，然后暴力添加剩余块，一定不能计算所有，可以分块。

记 $f_{i,j,k}$ 表示前 $i$ 块和后 $n-j+1$ 块的花费为 $k$ 的最大愉悦值。

转移时，暴力添加多余部分即可，块长可以取 $\sqrt n$，预处理时间复杂度 $O(nm\sqrt n)$，询问时间复杂度是 $O(qm\sqrt n)$。

多重背包部分，可以使用单调优化，二进制优化会多个 $\log$。

注意，题目中愉悦度之和是取模后的！

代码：

```cpp
#include<cstdio>
#include<algorithm>
#include<cmath>
#define ll long long
using namespace std;
const int mod=1e8+7;
int T,n,m,Q,c[1005],lim[1005],blen,t;
int st[40],ed[40],pos[1005],cnt,id[1005];
int head,tail;
ll f[35][35][1005],d[1005],dp[1005],v[1005];
struct node{
	int x;
	ll v;
}q[1005];
void add(int ax,int ay,int bx,int by,int l,int r)
{
//	printf("%d %d %d %d\n",ax,ay,bx,by);
	for(int i=0;i<=m;i++)
	{
		f[ax][ay][i]=f[bx][by][i];
	}
	for(int i=l;i<=r;i++)
	{
		for(int j=0;j<c[i];j++)
		{
			head=1,tail=cnt=0;
			for(int k=j;k<=m;k+=c[i])
			{
				d[++cnt]=f[ax][ay][k];
				id[cnt]=k;
			}
			for(int k=1;k<=cnt;k++)
			{
				while(head<=tail&&q[head].x<k-lim[i]) head++;
				while(head<=tail&&q[tail].v<=d[k]-k*v[i]) tail--;
				q[++tail]=(node){k,d[k]-k*v[i]};
				f[ax][ay][id[k]]=max(f[ax][ay][id[k]],q[head].v+k*v[i]);
			}
		}
	}
}
void add1(int i)
{
	for(int j=0;j<c[i];j++)
	{
		head=1,tail=cnt=0;
		for(int k=j;k<=m;k+=c[i])
		{
			d[++cnt]=dp[k];
			id[cnt]=k;
		}
		for(int k=1;k<=cnt;k++)
		{
			while(head<=tail&&q[head].x<k-lim[i]) head++;
			while(head<=tail&&q[tail].v<=d[k]-k*v[i]) tail--;
			q[++tail]=(node){k,d[k]-k*v[i]};
			dp[id[k]]=max(dp[id[k]],q[head].v+k*v[i]);
		}
	}
}
int main()
{
//	freopen("1.txt","r",stdin);
	scanf("%d",&T);
	while(T--)
	{
		scanf("%d%d%d",&n,&m,&Q);
		for(int i=1;i<=n;i++) scanf("%d",&c[i]);
		for(int i=1;i<=n;i++) scanf("%lld",&v[i]);
		for(int i=1;i<=n;i++) scanf("%d",&lim[i]);
		blen=sqrt(n),t=(n+blen-1)/blen;
		for(int i=1;i<=t;i++)
		{
			st[i]=(i-1)*blen+1,ed[i]=blen*i;
		}
		ed[t]=n;
		for(int i=1;i<=t;i++)
		{
			for(int j=st[i];j<=ed[i];j++) pos[j]=i;
		}
		for(int i=0;i<=t+1;i++)
		{
			for(int j=0;j<=t+1;j++)
			{
				for(int k=0;k<=m;k++)
				{
					f[i][j][k]=0;
				}
			}
		}
		for(int i=t;i>0;i--)
		{
			add(0,i,0,i+1,st[i],ed[i]);
		}
		for(int len=t;len>0;len--)
		{
			for(int i=1;i+len<=t+1;i++)
			{
				int j=i+len;
				add(i,j,i-1,j,st[i],ed[i]);
			}
		}
		ll ans1=0,ans2=0;
		while(Q--)
		{
			ll l,r,fl=0;
			scanf("%lld%lld",&l,&r);
			l=(ans1+l-1)%n+1,r=(ans1+r-1)%n+1;
			if(l>r) swap(l,r);
 			int x=pos[l]-1,y=pos[r]+1;
//			printf("%d %d %d %d\n",l,r,x,y);
			for(int i=0;i<=m;i++)
			{
				dp[i]=f[x][y][i];
			}
			ans1=ans2=0;
			for(int i=st[pos[l]];i<l;i++)
			{
				add1(i);
			}
			for(int i=r+1;i<=ed[pos[r]];i++)
			{
				add1(i);
			}
			ans1=ans2=0;
			for(int i=1;i<=m;i++)
			{
				ans1+=dp[i];
				ans2^=dp[i];
			}
			ans1%=mod;
			printf("%lld %lld\n",ans1,ans2);
		}
	}
	return 0;
}
```

---

## 作者：Greenzhe (赞：0)

### 简要题意

现有 $n$ 种物品，对于第 $i$ 种物品最多买 $t_i$ 件，同时其价格为 $c_i$ 元/件、价值为 $v_i$ 每件。

设 $f(i)$ 表示带了 $i$ 元钱购买这 $n$ 种物品，能获得的最大价值。

回答 $Q$ 次询问，每次询问给出区间 $[l,r]$，求：假如区间 $[l,r]$ 内的物品不能买，$\sum_{i=1}^m f(i)$ 的值。

$n,m,Q \le 10^3$，$t_i,c_i \le 10^3$，$v_i \le 2.5 \times 10^5$，强制在线。

### 思路分析

很明显本题的物品是一个**多重背包模型**。

考虑此题不带修改的版本：按照多重背包的一般思路，设 $F_{i,j}$ 表示前 $i$ 个物品，带了 $j$ 元钱能获得的最大价值。注意到：**强制不买 $l \sim r$ 号物品，就相当于对前缀区间 $[1,l)$ 和后缀区间 $(r,n]$ 的物品做背包**。因此就得到了本题的暴力做法：对于每个询问直接暴力 DP，时间复杂度最好能做到 $\mathcal O(qnm)$。

考虑优化。如果对每个前缀和每个后缀暴力预处理，询问时再 $\mathcal O(m^2)$ 合并前、后缀，最好可以做到 $\mathcal O(nm+qm^2)$。这个算法另一篇题解已经讲得很详细了，这里不再赘述。

如何部分预处理？考虑**分块**。重新定义 $F_{i,j,k}$ 表示块编号在区间 $[1,i]$ 或 $[j,\text{tot}]$ 内，带了 $k$ 元钱能获得的最大价值。预处理 $F$ 时，类似于双指针，值从相邻的块添加当前块内的物品而来。具体操作见代码。这部分的时间复杂度最好能做到 $\mathcal O(nm \sqrt{n})$，视多重背包的优化程度而定。

询问时只要先把整块的答案拿过来，再合并散块上的物品即可。处理单次询问，时间复杂度 $\mathcal O(m\sqrt{n})$。

### 代码实现

以下代码片段实现的算法，时间复杂度 $\mathcal O((n+q)m \sqrt{n} \log n)$，带 log 的原因是使用了二进制优化。

```cpp
inline void add(ll dp[],int x){ // 将第 x 种物品添加到 dp 数组
	for(auto t:G[x]) // G[x]: 第 x 种物品，已经过二进制优化预处理的物品集合
		for(int k=m;k>=t.w;--k)
			max_eq(dp[k],dp[k-t.w]+t.v);
}

pair<ll,ll> query(int l,int r){
	int b1=bl(l), b2=bl(r); // bl(x)：x 所处的块
	cpy(dp,f[b1-1][b2+1]); // 整块复制预处理的答案
	for(int i=L(b1);i<l;++i) add(dp,i);
	for(int i=R(b2);i>r;--i) add(dp,i); // 散块直接添加
	ll sum=0, xsum=0;
	for(int i=1;i<=m;++i){
		sum=(sum+dp[i])%MOD;
		xsum^=dp[i];
	}
	return make_pair(sum,xsum);
}
```

以下是预处理部分的代码（片段）：

```cpp
for(int i=1;i<=n;++i){
	int c=cnt[i]; // cnt：物品个数
	for(int b=1;b<=c;b*=2) // 二进制优化
		G[i].emplace_back(b*w[i],b*v[i]), c-=b;
	if(c>0) G[i].emplace_back(c*w[i],c*v[i]); // w：代价，v：价值
}
for(int i=0;i<=num;++i){ // 预处理 F
	if(i>0){
		for(int j=L(i);j<=R(i);++j) add(dp,j);
		cpy(f[i][num+1],dp);
	}
	for(int j=num;j>i;--j){
		cpy(f[i][j],f[i][j+1]);
		for(int k=L(j);k<=R(j);++k) add(f[i][j],k);
	}
}
```

叠甲：本人水平有限，有锅请随时找我修。

---


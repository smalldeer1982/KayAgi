# [yLOI2020] 牵丝戏

## 题目背景

> 风雪依稀秋白发尾， 灯火葳蕤，揉皱你眼眉。  
> 假如你舍一滴泪，假如老去我能陪。  
> 烟波里成灰，也去得完美。 

——银临 & Aki阿杰《牵丝戏》

## 题目描述

扶苏和扶咕咕最近在玩一款叫做「ddt」的游戏，因为玩「ddt」时一直在循环《牵丝戏》，所以想到牵丝戏就想到了这个游戏。

为了简化问题，我们认为这是一款一对一回合制游戏。双方玩家各有一个属性，被称为 delay 值，简称 $d$ 值。$d$ 值会根据回合中玩家使用的道具类型和数量来进行相应的增加。我们定义玩家 $x$ 的回合为玩家 $x$ 从发动攻击到结束的整个过程。**在玩家 $x$ 的回合中，只有玩家 $x$ 可以使用道具和发动攻击，并且玩家 $x$ 一定会发动攻击**。当一个玩家的回合结束以后，下一回合将是两个玩家中 $d$ 值**较小**的玩家的回合。当两个玩家的 $d$ 值相同时，因为扶苏氪金很多，下一回合一定是**扶苏的回合**。

这款游戏共有 $m$ 种道具，第 $i$ 种道具会将本回合的伤害增加**不计算其他道具的原始伤害**的 $\frac{k_i}{10^5}$ 倍，同时会增加 $p_i$ 点 $d$ 值。每回合**每种道具只能使用一次，本回合的道具不会对下回合产生伤害增益效果**。同时，每回合结束以后，发动攻击的玩家一定会增加 $w$ 点 $d$ 值。

而使用道具是受到双方 $d$ 值差限制的。具体的，任何回合所使用的道具应该满足本回合结束以后双方 $d$ 值（包括发动攻击的玩家一定增加的 $w$ 点 $d$ 值）之差的绝对值**不超过** $100$。一个显然的事实是，只要保证了 $w \le 100$，玩家就一定存在一种选择道具的方法（包括不选择），来满足这个限制。

例如，在扶咕咕的回合中，若她的原始伤害 $t=10^5$，初始时 $d$ 值 $d_0=3$，规定 $w=2$，她使用了两个道具，$k_1=114$，$k_2=514$，$p_1=19$，$p_2=81$，那么本回合她造成的伤害为 

$$t + t \times k_1 + t \times k_2 = 10^5 + 114 + 514 =  100628$$

她回合结束后的 $d$ 值为

$$d_0 + w + p_1 + p_2 = 3 + 2 + 19 + 81 = 105$$

而假如下回合还是她的回合，并且她没有使用道具，那么她下回合造成的伤害为 

$$t =  100000$$

她下回合结束后的 $d$ 值为 

$$105 + w = 105 + 2 = 107$$

现在扶苏和扶咕咕正在对战。给定游戏的道具列表，和他们的原始伤害、 $d$ 值。游戏一共会进行 $n$ 回合，不妨认为无论造成多大的伤害，双方都不会死亡。请你最大化「扶苏对扶咕咕造成的伤害 - 扶咕咕对扶苏造成的伤害」这个差的值。

当然，扶咕咕也会尽可能最大化「她对扶苏造成伤害 - 扶苏对她造成伤害」的值。不妨认为扶苏是 yLOI 世界中最聪明的男孩子，扶咕咕是 yLOI 世界中最聪明的女孩子，也就是**他们都会选择最优的策略来使用道具而不会出错**，题目所求即为在这种情况下伤害差的最大值。

## 说明/提示

### 样例 1 解释

- 第一回合开始前，扶苏 $d$ 值为 $2$，扶咕咕 $d$ 值为 $3$，第一回合由扶苏出手。扶苏不使用道具，伤害为 $100000$，$d$ 值增加 $1$，总伤害差为 $100000$。
- 第一回合结束后，双方 $d$ 值均为 $3$，第二回合由扶苏出手。扶苏使用第一个道具，伤害为 $100050$，$d$ 值增加 $21$，总伤害差为 $200050$。
- 第二回合结束后，扶苏 $d$ 值为 $24$，扶咕咕 $d$ 值为 $3$，第三回合由扶咕咕出手。扶咕咕使用 $1$ 、 $2$ 两个道具，伤害为 $200102$，$d$ 值增加 $121$，总伤害差为 $-52$。这回合结束后，双方 $d$ 值差恰好为 $100$，符合要求。

### 数据规模与约定


**本题采用多测试点捆绑测试**。

- 子任务 $1$（$5$ 分）：保证 $n=0$。
- 子任务 $2$（$10$ 分）：保证 $m=0$。
- 子任务 $3$（$15$ 分）：保证 $n,m \le 5$。
- 子任务 $4$（$20$ 分）：保证 $n \le 3$。
- 子任务 $5$（$20$ 分）：保证 $m \le 10$。
- 子任务 $6$（$30$ 分）：无特殊约定。

对于全部的测试点，保证 $0 \le n \le 10^3$，$0 \le m \le 10^5$，$1 \le p_i,w \le 100$，$1 \le x_a,x_b,k_a,d_a,d_b \le 10^9$，$x_a$ 与 $x_b$ 是 $10^5$ 的倍数，$1 \le |d_a-d_b| \le 100$。

### 提示

共有 4 个样例文件，请见附加文件中的 opera.zip。  
对于样例 2，满足 $m = 0$。  
对于样例 3，满足 $n \leq 3$。

## 样例 #1

### 输入

```
0
3 2 1
50 1
20 100
100000 200000 2 3```

### 输出

```
-52```

# 题解

## 作者：一扶苏一 (赞：12)

### D

#### Description

本题的游戏规则与《弹弹堂》基本一致，回合制游戏，回合期间行动方可以释放技能增加伤害，但是会增加 delay 值。每回合的行动方是 delay 值较低的一方。使用道具的限制为，每种道具一回合只能使用一次，使用后双放 delay 值之差的绝对值不能超过 100。在双方均最优决策的情况下，求「己方造成的伤害-对方造成的伤害」的最大值。

游戏共进行 $n$ 回合，有 $m$ 种道具。每回合固定增加 $w$ 点 delay 值。第 $i$ 种道具会增加  $p_i$ 点 delay 值，伤害增益十万分之 $k_i$。

#### Subtasks

- Subtask 1（5 points）：$n = 0$。
- Subtask 2（10 points）：$m = 0$。
- Subtask 3（15 points）：$n, m \leq 5$。
- Subtask 4（20 points）：$n \leq 3$。
- Subtask 5（20 points）：$m \leq 10$。
- Subtask 6（30 points）：no extra restrictions。
- forall：$1 \leq n \leq 10^3$，$1 \leq m \leq 10^5$。

#### Algorithm 1

当没有道具时，不需要进行决策，只需要依题意模拟每回合出手即可通过前两个子任务，期望得分 15 分。

#### Algorithm 2

爆搜。对于每回合枚举放什么技能，每回合放技能有 $2^m$ 种可能，共有 $n$ 回合。总共有 $2^{nm}$ 种可能。时间复杂度 $O(2^{nm})$，可以通过前三个子任务，期望得分 30 分。

注意因为是博弈论，搜的时候必须倒着搜，也即从最后一回合搜到第一回合。

#### Algorithm 3

从 delay 值入手考虑。考虑如果确定了回合结束以后想要增加的 delay 值 $x$，对于每一回合，最优的使用道具的方案都是相同的。$x$ 不会超过 $t = 200$，因此可以进行 dp：设 $f_{i,j}$ 是考虑前 $i$ 个道具，增加 $j$ 的 delay 值时，最大的伤害增益是多少。转移显然：

$$f_{i, j} = \min(f_{i - 1, j}, f_{i - 1, j - p_i} + k_i)$$

这是一个标准的 01 背包问题。这部分 dp 的时间复杂度为 $O(mt)$，其中 $t = 200$。

回合结束后，双方的 delay 值之差也只有 $t$ 种情况。可以直接枚举每回合结束后双方的 delay 值之差。这样做的复杂度显然是 $O(t^n)$。回合内使用背包预处理出的给定 delay 增量后的最优方案（最大伤害增益）即可。

时间复杂度 $O(mt)-O(t^n)$，可以通过子任务 1,2,4，期望得分 35 分。结合算法 2 可以得到 50 分。

#### Algorithm 4

可以发现，如果确定了第 $i$ 回合前的 delay 值之差 $j$，那么双方第 $i \sim n$ 回合的最大伤害差 $g_{i, j}$ 也是可以 dp 的：

$$g_{i, j} = \max\limits_{k = w}^{t} \{g_{i + 1, j - k} + f_{m, k}\}$$

这是一个标准的博弈 dp。也即在转移过程中枚举当前回合增加的 delay 值。当然其中有一些细节，比如处理负数下标，或差值不能超过 200 等。

dp 的过程时间复杂度显然是 $O(nt^2)$。

如果爆搜求 $f$，那么预处理 $f$ 的复杂度是 $O(2^m)$，总复杂度为 $O(2^m) - O(nt^2)$。可以通过子任务 1,2,5，期望得分 35 分，结合算法 2 可以得到 50 分。

如果使用算法 3 的方式求 $f$，那么总时间复杂度为 $O(mt) - O(nt^2)$，可以通过全部的测试点，期望得分 100 分。

#### Summary

- 本题人口普查分 5 分，依题意模拟 15 分，暴力 30 分。
- 会用 01 背包预处理道具可以得到 50 分。
- 会用博弈 dp 求解可以得到 50 分。
- 上述两个 dp 结合可以得到 100 分。

本题模型简单，做法基础，码量友好，部分分充足合理。着重考查了选手对于问题的建模能力以及对于基础动态规划问题的掌握程度。可以较好的区分出理解转化能力强并且基本功扎实的选手。是一道优秀的基础题。

```cpp
#include <cstdio>
#include <algorithm>

typedef long long int ll;

const int maxt = 500;
const int maxn = 2005;
const int maxm = 200005;
const int INF = 0x3f3f3f3f;
const ll inf = 0x3f3f3f3f3f3f3f3fll;

int T, t = 200;
int n, m, w, da, db;
int k[maxm], p[maxm];
ll xa, xb;
ll f[maxt], g[maxn][maxt];

int main() {
  scanf("%d\n%d %d %d", &T, &n, &m, &w);
  for (int i = 1; i <= m; ++i) scanf("%d", k + i);
  for (int i = 1; i <= m; ++i) scanf("%d", p + i);
  scanf("%lld %lld %d %d", &xa, &xb, &da, &db);
  std::fill(f, f + maxt, -INF);
  f[w] = 100000;
  xa /= 100000; xb /= 100000;
  for (int i = 1; i <= m; ++i) {
    for (int j = t, lim = std::max(p[i], w); j >= lim; --j) if (f[j - p[i]] != -INF) {
      f[j] = std::max(f[j], f[j - p[i]] + k[i]);
    }
  }
  for (int i = 1; i <= n; ++i) {
    int di = i - 1;
    for (int j = 0; j <= 100; ++j) {
      g[i][j] = -inf;
      for (int h = j + w; h <= t; ++h) if (f[h - j] != -INF) {
        g[i][j] = std::max(g[i][j], g[di][h] + f[h - j] * xa);
      }
    }
    for (int j = 101; j <= t; ++j) {
      g[i][j] = inf;
      for (int h = j - w; ~h; --h) if (f[j - h] != -INF) {
        g[i][j] = std::min(g[i][j], g[di][h] - f[j - h] * xb);
      }
    }
  }
  printf("%lld\n", g[n][da - db + 100]);
  return 0;
}

```

### 

---

## 作者：烟灬 (赞：4)

# NOIP2021 RP++
## 博弈 dp 

博弈 dp 解决的是两人轮流操作，且没有平局的两人博弈游戏

写代码的话一般是用其他状态向自己转移

更一般的，博弈没有固定搜索顺序，习惯用记忆化搜索

让我们来看一道例题：

有一列数排列， 甲乙两个人每次可以从头或者从末尾取一个数， 问甲乙在采取最优策略的基础下分别分别得分是多少？

对于这道题目，我们定义 $dp[i][j]$ 为先取者所能取得的得分，然后我们思考对于当前的 $i-j$ 的序列甲先取的话有什么取法

取法一共分两种：从头取或从末尾取

第一种取法对应 $dp[i+1][j]$

如果 $dp[i][j]$ 是甲能取得的最大分数的话， 

那么甲取完一个数字之后转化到的子问题     $dp[i+1][j]$ 就是乙所能获得的最大分数， 

同理可得 $dp[i][j-1]$ 也为乙所能获得的最大分数，

如果我们预处理 $sum[i][j]$ 为序列 $i-j$ 的和

那么得到

 $dp[i][j]=sum[i][j]-\min(dp[i+1][j], dp[i][j-1])$ 

而初始条件为

 $dp[i][i]=num[i]$ 

## 本题题解

然后我们再回来看这道题


我们用 $f[i]$ 表示使用前 $i$ 个道具，增加 $\sum_ {j=1}^i a[j].k$ 点 $d$ 值时的最大伤害增益

然后我们可以利用背包预处理每种道具的使用导致的贡献即 

 $f[j]=\max(f[j],f[j-a[i].p]+a[i].k)$ 

背包部分结束，接下来进入博弈 $dp$ 环节

设 $dp[i][j]$ 表示第 $i$ 个回合 $d$ 值相差为 $j$ 时的最大伤害差，所以答案为

 $dp[n][da-db]$ 

对于扶苏，有

 $dp[i][j]=\max(dp[i][j],dp[dc][q]+f[q-j]*xa)$ 

对于扶咕咕，有

 $dp[i][j]=\min(dp[i][j],dp[dc][q]-f[j-q]*xb)$ 

特别注意：

- 上述两次 dp 应在同意次循环中完成，令 $i$ 表示回合数，即代表在同一回合内两人分别的最优策略。

-  $f$ 数组的边界值不能与 dp 数组相同

- 因为 $a[i].k$ 只能提供 $1/100000$   的倍率增幅，对 $k/100000$ 的操作会出现小数， 且有精度流失，所以将初始攻击力除以 $100000$ ，从而避免对 $k$ 进行操作 

- 博弈 dp 中双方条件和关系式一般不同，千万注意

## 代码如下
```c
#include<bits/stdc++.h>
#define inf 0x3f3f3f3f3f3f3f3f
using namespace std;
int T;
long long n,m,w,ans;//n:回合数   m:装备数   w:每回合固定增加d值 
long long xa,xb,da,db;//不开long long见祖宗 
int maxd=200;//每回合使用道具最大的d值和  100+100 
long long f[505];
long long dp[2005][505];
struct node{
	long long k,p;
}a[100005];
int main(){
	//freopen("opera4.in","r",stdin); 
	cin>>T;//T对于得部分分有帮助，但对正解毫无作用 
    cin>>n>>m>>w;
    for(int i=1;i<=m;i++)
    	cin>>a[i].k;
    for(int i=1;i<=m;i++)
    	cin>>a[i].p;
	cin>>xa>>xb>>da>>db;
	for(int i=0;i<=500;i++){//预处理f数组 
		f[i]=-inf/100;//f数组的边界值不能与dp数组相同 
	}
	f[w]=100000;
	xa/=100000;
	xb/=100000;
	//因为a[i].k只能提供1/100000的倍率增幅，对k/100000的操作会出现小数， 
	//且有精度流失，所以将初始攻击力/100000，避免对k进行操作 
	for(int i=1;i<=m;i++){
		for(int j=maxd,limt=max(a[i].p,w);j>=limt;j--){
			if(f[j-a[i].p]!=-inf/100)
				f[j]=max(f[j],f[j-a[i].p]+a[i].k);
		} 	
	} 
	//背包预处理最大伤害增益 
	for(int i=1;i<=n;i++){
		int dc=i-1;//当前的d值差
		for(int j=0;j<=100;j++){
			dp[i][j]=-inf;//初始化dp数组 
			for(int q=j+w;q<=maxd;q++)
				if(f[q-j]!=-inf/100)
					dp[i][j]=max(dp[i][j],dp[dc][q]+f[q-j]*xa);
		}//dp求扶苏最大伤害
		for(int j=101;j<=maxd;j++){
			dp[i][j]=inf;//一定注意！博弈dp特点就是双方条件相反 
			for(int q=j-w;q>=0;q--){
				if(f[j-q]!=-inf/100)
					dp[i][j]=min(dp[i][j],dp[dc][q]-f[j-q]*xb);
			} 
		}//dp求扶咕咕最大伤害
	}
	cout<<dp[n][da-db+100];						
    return 0;
}
```







---

## 作者：Cesare (赞：2)

非常有意思的一道题，主要的难点在于状态的选择。

## $Solution$
政治书告诉我们，要立足整体，统筹部分。

所以我们先把题意看个大概，然后把过程分成对单个回合统计和把各回合间答案进行统计两个部分。

首先考虑如何对每一轮的 $p_i$ 集合进行统计贡献。

这是个很明显的 $01$ 背包，注意到每一轮的答案对下一轮没有影响且倍数间是相加关系，所以直接独立背包即可。

然后考虑怎么对每个回合进行统计。

可以得出一种很显然的状态设计 $f_{i, j}$ 表示做到第 $i$ 回合 $da - db = j$ 的最大差值。

有转移方程

$$
f_{i, j} = \max_{j = -lim}^{0} {f_{i - 1, j + w + k} + (1 + \frac{g_{k}}{100000}) \times xa}
$$
$$
f_{i, j} = \min_{j = 1}^{lim}\ {f_{i - 1, j - w - k} - (1 + \frac{ g_{k}}{100000}) \times xb}
$$

然后设初始状态为 $f_{0, da - db} = 0$

然后发现初始状态错了。

为什么？因为有的状态其实是无法转移到下个状态的，这不是一个人的游戏，两个人都会选择对自己最有利的情况，所以有些状态虽然很优但是不会被选。简单来讲，让末尾的所有状态任意走，是不一定能走到所有初状态的。~~感觉非常玄学~~

这个时候，可以考虑逆向思维，从肯定存在合法转移的地方开始走，改变状态为从 $n$ 做到第 $i$ 回合的最大差值，答案为 $f_{1, da - db}$。

## $Code$
基本没啥细节，除了下标处理注意一下。
```cpp
#include <bits/stdc++.h>
#define debug(x) (cout << "#x = " << (x) << '\n')

using namespace std;
typedef long long ll;

inline char gc() {
	static char buf[100000], *p1 = buf, *p2 = buf;
	return (p1 == p2) && (p2 = (p1 = buf) +
		fread(buf, 1, 100000, stdin), p1 == p2)? EOF: *p1++;
}

#define dd ch = getchar()
inline ll read() {
	ll x = 0;
	int f = 0; char dd;
	for (; !isdigit(ch); dd) f ^= (ch == '-');
	for (; isdigit(ch); dd)  x = (x << 1) + (x << 3) + (ch ^ 48);
	return f? -x: x;
}
#undef dd

template <class T>
inline void write(T x) {
	if (x < 0) x = -x, putchar('-');
	if (x > 9) write(x / 10);
	putchar(x % 10 | 48);
}

template <class T>
inline void wrn(T x) {
	write(x), putchar(' ');
}

template <class T>
inline void wln(T x) {
	write(x), putchar('\n');
}

template <class T>
inline void wlnn(T x, T y) {
	wrn(x), wln(y);
}

const int N = 1e3 + 5;
const int M = 2e2 + 5;
const int MAXN = 1e5 + 5;

ll k[MAXN], F[M];
ll n, m, w, xa, xb, da, db, p[MAXN], f[N][M];

int main()
{
	int SomethingForNothing = read();
	++++++++++++++SomethingForNothing;
	n = read(), m = read(), w = read();
	for (int i = 1; i <= m; ++i) k[i] = read();
	for (int i = 1; i <= m; ++i) p[i] = read();
	xa = read(), xb = read(), da = read(), db = read();
	memset(F, -0x3f, sizeof F); F[0] = 0;
	for (int i = 1; i <= m; ++i) 
		for (int j = 200; j >= p[i]; --j) 
			if (F[j - p[i]] > -1e9) F[j] = max(F[j], F[j - p[i]] + k[i]);
	for (int i = n; i; --i) {
		for (int j = 0; j <= 200; ++j) {
			if (j <= 100) {
				f[i][j] = -1e18;
				for (int l = 0; l <= 200; ++l) 
					if (F[l] > -1e15 && j + w + l <= 200)
						f[i][j] = max(f[i][j], f[i + 1][j + w + l] + xa + xa / 100000 * F[l]);
			}
			else {
				f[i][j] = 1e18;
				for (int l = 0; l <= 200; ++l) 
					if (F[l] > -1e15 && j - w - l >= 0)
						f[i][j] = min(f[i][j], f[i + 1][j - w - l] - xb - xb / 100000 * F[l]);
			}
		}
	}
	return wln(f[1][da - db + 100]), 0;
}

/*

*/



```



---


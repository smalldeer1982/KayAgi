# 实力派

## 题目背景

![](https://cdn.luogu.com.cn/upload/image_hosting/z8ednvb2.png)

## 题目描述

来自全国各地的 $n$ 位 OIer 组成了一个名为“实力派”的团队，每个人有一个实力值 $a_i$。共有 $m$ 场比赛向他们发送了参赛邀请，其中第 $i$ 场比赛要求 $k_i$ 个人组成一个队伍参加。为了决定他们是否应该参加某场比赛，他们想出了如下两个衡量实力的数据：

- 定义 $x$ 阶最低实力表示从这 $n$ 个人中选出 $x$ 个人，使得这 $x$ 个人实力值的 $\gcd=1$ 的方案数；

- 定义 $x$ 阶最高实力表示从这 $n$ 个人中选出 $x$ 个人，所有方案的 $x$ 个人的 $\gcd$ 之和。

请你对于每场比赛，告诉他们他们在这场比赛中的 $k_i$ 阶最低实力和最高实力。对了，为了不让别人听懂，你需要将答案对一个秘密模数 $p$ 取模。

## 说明/提示

**样例** $\mathbf{1}$ **解释**

第一场比赛要求选出 $2$ 人参加，仅有 $(8,15)$ 一种方案的 $\gcd=1$，因此最低实力为 $1$；所有方案的 $\gcd$ 之和为 $19$，因此最高实力为 $19$；

第二场比赛要求选出 $3$ 人参加，有 $(8,15,12)$ 和 $(8,15,6)$ 两种 $\gcd=1$ 的方案，因此最低实力为 $2$；所有方案的 $\gcd$ 之和为 $7$，因此最高实力为 $7$。

**数据范围**

对于所有数据，$1\leq n,m,k_i\leq 2\times 10^5$，$1\leq a_i\leq 10^6$，$10^7\leq p\leq 10^9$，$p\in \mathbb{P}$。

本题共 $30$ 个测试点，**采用捆绑测试**，子任务及数据点分配如下：

| 子任务编号 | 数据点编号 | 特殊性质 | 分值 | 时限 |
| :-: | :-: | :-: | :-: | :-: |
| $0$ | $1\sim 4$ | $n\leq 20$ | $10$ | $1s$ |
| $1$ | $5\sim 8$ | $n,a_i\leq 300$ | $10$ | $1s$ | 
| $2$ | $9\sim 12$ | $k_i\leq 2$ | $20$ | $1.5s$ |
| $3$ | $13\sim 16$ | $a_i\leq 3$ | $10$ | $1s$ |
| $4$ | $17\sim 22$ | $a_i\leq 10^5$ | $20$ | $1s$ |
| $5$ | $23\sim 30$ | 无特殊性质 | $30$ | $1.5s$ |

**提示**

$\mathbb{P}$ 表示全体质数集合，$\gcd$ 表示最大公因数。

## 样例 #1

### 输入

```
4 4 998244353
8 15 12 6
2
3
4
5```

### 输出

```
1 19
2 7
1 1
0 0```

## 样例 #2

### 输入

```
6 4 19260817
11 45 14 19 19 810
2
1
2
2```

### 输出

```
12 78
0 918
12 78
12 78```

## 样例 #3

### 输入

```
8 3 19491001
3 2 2 3 1 2 1 2
5
3
4```

### 输出

```
56 56
52 60
69 71```

# 题解

## 作者：Undead2008 (赞：4)

对于第一问：设全集为 $U$，所要求的东西为
$$\begin{aligned}& \sum_{S\subseteq U,|S|=k}[\gcd\{S\}=1]\\=& \sum_{S\subseteq U,|S|=k}\sum_{d|\gcd\{S\}}\mu(d)\\=& \sum_{d}\mu(d)\dbinom{g_d}{k}\end{aligned}$$
其中 $g_d$ 为 $a$ 中能被 $d$ 整除的数字个数。使用 Dirichlet 后缀和即可求出 $g$ 数组。

观察到 $g$ 数组中元素和的上界不超过 $nw^{\frac{1}{3}}$，$w$ 为值域。这启发我们对于每个枚举到的 $d$，暴力对所有 $k\le g_d$ 计算贡献。至此我们做完了第一问。

对于第二问：所要求的东西为
$$\begin{aligned}
 & \sum_dd\sum_{S\subseteq U,|S|=k}[\gcd\{S\}=d]\\
=& \sum_dd\sum_{S\subseteq U,|S|=k}\sum_{bd|\gcd\{S\}}\mu(b)\\
=& \sum_dd\sum_{b}\mu(b)\dbinom{g_{bd}}{k}\\
=& \sum_dd\sum_{T}\mu(\dfrac{T}{d})\dbinom{g_{T}}{k}
\end{aligned}$$
对于某个特定的 $T$，枚举 $d$ 算前一半，枚举 $k$ 算后一半，拼起来就做完了第二问。

```cpp
#include"bits/stdc++.h"
using namespace std;
const int maxn = 1000100;
namespace fastio {
	const int MAXBUF = 1 << 23;
	char buf[MAXBUF], *p1 = buf, *p2 = buf;
	char pbuf[MAXBUF], *pp = pbuf;
	inline char getc() { return (p1 == p2) && (p2 = (p1 = buf) + fread(buf, 1, MAXBUF, stdin)), p1 == p2 ? EOF : *p1++; }
	inline void putc(char c) { (pp == pbuf + MAXBUF) && (fwrite(pbuf, 1, MAXBUF, stdout), pp = pbuf), *pp++ = c; }
	inline void print_final() { fwrite(pbuf, 1, pp - pbuf, stdout), pp = pbuf; }
}
#ifndef LocalTest
	using fastio::getc;
	using fastio::putc;
	using fastio::print_final;
#else
	#define getc getchar
	#define putc putchar
	void print_final(){}
#endif
template <class _Tp>inline _Tp& read(_Tp& x) {
    bool sign = 0;
    char ch = getc();
    for (; !isdigit(ch); ch = getc()) sign |= (ch == '-');
    for (x = 0; isdigit(ch); ch = getc()) x = x * 10 + (ch ^ 48);
    return sign ? (x = -x) : x;
}
template <class _Tp>inline void write(_Tp x) {
    if (x < 0) putc('-'), x = -x;
    if (x > 9) write(x / 10);
    putc((x % 10) ^ 48);
}
template <typename _Tp,typename ...Args>inline void write(_Tp x,Args ...args){
    write(x),putc(' '),write(args...);
}
template<typename _Tp,typename ...Args>inline bool read(_Tp& x,Args& ...args) {
    return read(x)&&read(args...);
}
int n,m,w,mo;
int a[maxn],g[maxn];
int pw[maxn],ip[maxn];
inline int ksm(int b,int t){
	int ret=1;
	while(t){
		if(t&1)ret=1ll*ret*b%mo;
		b=1ll*b*b%mo,t>>=1;
	}
	return ret;
}
inline int inv(int x){
	return ksm(x,mo-2);
}
inline int C(int u,int d){
	return (1ll*pw[u]*ip[d]%mo)*ip[u-d]%mo;
}
int v[maxn],mu[maxn],Bw[maxn],ans[maxn],ans2[maxn];
int p[maxn],Top;
int main(){
	read(n),read(m),read(mo);
	for(int i=1;i<=n;i++)
		read(a[i]),g[a[i]]++,w=max(w,a[i]+1);
	pw[0]=ip[0]=1;
	for(int i=1;i<=n;i++)
		pw[i]=1ll*i*pw[i-1]%mo;
	ip[n]=inv(pw[n]);
	for(int i=n;i>=2;i--)
		ip[i-1]=1ll*i*ip[i]%mo;
	mu[1]=1;
	for(int i=2;i<=w;i++){
		if(v[i]==0)mu[i]=-1,p[Top++]=i;
		for(int j=0;j<Top&&i*p[j]<=w;j++){
			v[i*p[j]]=1;
			if(i%p[j]==0)break;
	        mu[i*p[j]]=-mu[i];
		}
	}
	for(int i=0;i<Top;i++)
		for(int j=w/p[i];j>=1;j--)
			g[j]+=g[j*p[i]];
	for(int i=1;i<=w;i++)
		for(int j=i;j<=w;j+=i)
			Bw[j]=(Bw[j]+1ll*i*(mo+mu[j/i]))%mo;
	for(int i=1;i<=w;i++){
		for(int j=1;j<=g[i];j++){
			int o=C(g[i],j);
			ans[j]=(ans[j]+1ll*o*(mo+mu[i]))%mo;
			ans2[j]=(ans2[j]+1ll*o*Bw[i])%mo;
		}
	}
	for(int i=1,k;i<=m;i++){
		read(k);
		write(ans[k]),putc(' '),write(ans2[k]),putc('\n');
	}
	print_final();
}
```

---

## 作者：鲤鱼江 (赞：3)

本题解主要是对 @diqiuyi 的补充，所以很少出现对答案的直接推导，具体推导我不认为能超过其他大佬。~~比如朴素做法其实不会被卡常之类的~~。

首先对于 $cnt_i$ 的 $O(n\ln n)$ 的预处理是很慢的，我们有一个叫做 Dirichlet 后缀和的东西，能在 $O(n \ln \ln n)$ 内的时间内处理出来 $cnt_i$，具体代码实现参考第一篇题解。

其次对于 $ans2=\sum\limits_{i=1}^v{cnt_i\choose k}\sum\limits_{j|i}\mu(j)\frac{i}{j}$ 进行 $O(n \ln n)$ 的预处理是不必要的，因为后面是一个经典的狄利克雷卷积的形式，也是必须熟悉的一个公式 $\mu * Id=\phi$。

所以实际上是可以直接线筛的，时间复杂度只需要吃一个 $O(nd(n))$ 就行了。

上述的两个优化随便加一个就能通过此题。


```cpp
#include<bits/stdc++.h>

using namespace std;

namespace Fread {
	const int SIZE=1<<21;
	char buf[SIZE],*S,*T;
	inline char getchar() {
	    if(S==T){
	        T=(S=buf)+fread(buf,1,SIZE,stdin);
	        if(S==T)return '\n';
	    }
	    return *S++;
	}
}
namespace Fwrite {
	const int SIZE=1<<21;
	char buf[SIZE],*S=buf,*T=buf+SIZE;
	inline void flush(){
	    fwrite(buf,1,S-buf,stdout);
	    S=buf;
	}
	inline void putchar(char c){
	    *S++=c;
	    if(S==T)flush();
	}
	struct POPOSSIBLE{
	    ~POPOSSIBLE(){flush();}
	}ztr;
}
#define getchar Fread :: getchar
#define putchar Fwrite :: putchar
namespace Fastio{
	struct Reader{
	    template<typename T>
    	Reader& operator >> (T& x) {
        	char c=getchar();
        	T f=1;
        	while(c<'0'||c>'9'){
            	if(c=='-')f=-1;
            	c=getchar();
        	}
        	x=0;
        	while(c>='0'&&c<='9'){
	            x=x*10+(c-'0');
	            c=getchar();
	        }
	        x*=f;
	        return *this;
    	}
	}cin;
	struct Writer{
	    template<typename T>
	    Writer& operator << (T x) {
	        if(x==0){putchar('0');return *this;}
	        if(x<0){putchar('-');x=-x;}
	        static int sta[45];
	        int top=0;
	        while(x){sta[++top]=x%10;x/=10;}
	        while(top){putchar(sta[top]+'0');--top;}
	        return *this;
    	}
    	Writer& operator << (char c) {
        	putchar(c);
        	return *this;
	    }
	}cout;
}
#define cin Fastio :: cin
#define cout Fastio :: cout

int mod;
struct modint {
    int val;
    static int norm(const int& x) { return x < 0 ? x + mod : x; }
    inline int Mod(const int &x){return x>=mod?x-mod:x;}
    modint inv() const {
        int a = val, b = mod, u = 1, v = 0, t;
        while (b > 0) t = a / b, swap(a -= t * b, b), swap(u -= t * v, v);
        return modint(u);
    }
    modint() : val(0) {}
    modint(const int& m) : val(norm(m)) {}
    modint(const long long& m) : val(norm(m % mod)) {}
    modint operator-() const { return modint(norm(-val)); }
    bool operator==(const modint& o) { return val == o.val; }
    bool operator<(const modint& o) { return val < o.val; }
    modint& operator+=(const modint& o) { return val = Mod(val + o.val), *this; }
    modint& operator*=(const modint& o) { return val = static_cast<int>(1ll * val * o.val % mod), *this; }
    modint operator+(const modint& o) const { return modint(*this) += o; }
    modint operator*(const modint& o) const { return modint(*this) *= o; }
};

const int N=1e6+10;
int phi[N],prime[N],cnt,n,m,a[N],maxx,t[N],flag[N],mu[N];
modint ans1[N],ans2[N],frac[N],inv[N];

void init(const int len){
	frac[0]=frac[1]=1;mu[1]=phi[1]=1;
	for(int i=2;i<=len;++i){
		if(!flag[i]){
			prime[++cnt]=i;
			phi[i]=i-1;
			mu[i]=-1;
		}
		for(int j=1;j<=cnt&&i*prime[j]<=len;++j){
			int tmp=i*prime[j];flag[tmp]=1;
			if(i%prime[j]) {
				mu[tmp]=-mu[i];
				phi[tmp]=phi[i]*phi[prime[j]];
			}
			else {
				phi[tmp]=phi[i]*prime[j];
				break;
			}
		}
	}
}
inline modint C(const int n,const int m){return frac[n]*inv[m]*inv[n-m];}

int main(){
	cin>>n>>m>>mod;frac[0]=1;
	for(int i=1;i<=n;++i) {
		cin>>a[i];maxx=max(maxx,a[i]);++t[a[i]];
		frac[i]=frac[i-1]*i;
	}
	inv[n]=frac[n].inv();
	for(int i=n-1;~i;--i) inv[i]=inv[i+1]*(i+1);
	for(int i=1;i<=maxx;++i) for(int j=i+i;j<=maxx;j+=i) t[i]+=t[j];init(max(n,maxx));
	for(int i=1;i<=maxx;++i) 
		for(int k=1;k<=t[i];++k){
			ans2[k]+=C(t[i],k)*phi[i];
			ans1[k]+=C(t[i],k)*mu[i];
		}
	for(int i=1,x;i<=m;++i){cin>>x;cout<<ans1[x].val<<' '<<ans2[x].val<<'\n';}
	return 0;
}
```

---

## 作者：diqiuyi (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P10269)。

考虑第一问，发现对于固定的 $k$，答案为：

$$\begin{aligned}\sum_{T\subseteq S\land \left|T\right|=k}[\gcd_{x\in T} x=1] &=\sum_{T\subseteq S\land \left|T\right|=k}\sum_{i \mid \gcd_{x\in T} x}\mu(i) \\&=\sum_{i=1}^v \mu(i) C_{cnt_i}^k\end{aligned}$$

其中 $S$ 表示这个团队，$cnt_i$ 表示 $i$ 的倍数的出现次数，$v$ 表示值域。

对于第二问，我们考虑容斥。我们发现，一个数能作为选出的数的最大公约数当且仅当选出的数都是它的倍数且不全为大于他的倍数的倍数。所以它的贡献将是 $C_{cnt_x}^k-C_{cnt_{2x}}^k-C_{cnt_{3x}}^k-C_{cnt_{5x}}^k+C_{cnt_{6x}}^k\dots$ 我们发现一个数 $z$ 会产生 $\mu(z)C_{cnt_{zx}}^k$ 的贡献。

所以此时的答案为：

$$\begin{aligned}\sum_{i=1}^v i\sum_{j=1}^{\lfloor\frac{v}{i}\rfloor}\mu(j)C_{cnt_{ij}}^k &= \sum_{i=1}^v C_{cnt_i}^k\sum_{j\mid i}\mu(j)\frac{i}{j}\end{aligned}$$

显然后面那个东西可以 $O(v \ln v)$ 预处理。

现在两个式子的瓶颈都在于对多测的处理。不过我们知道 $\sum cnt_i=\sum_{i=1}^n d(a_i)$，其中 $d(x)$ 表示 $x$ 的约数个数。通过某张经典的表格，我们可以知道 $d(x)$ 最大为 $240$，所以对于每个 $i$，直接 $O(cnt_i)$ 枚举算贡献即可。

但是不知道为什么这个做法被卡常了。

所以考虑优化。我们发现两个式子前半部分的答案只和 $cnt_i$ 有关。我们知道本质不同的 $cnt_i$ 的数量是根号级别的，所以考虑把它们存起来，每次询问暴力查询即可。理论复杂度好像更劣，但是可以过。

**code**
```cpp
#include <bits/stdc++.h>
#define ull unsigned long long
#define int long long
#define uint unsigned int
#define pii pair<int,int>
using namespace std;
inline int read(){
	int x=0;bool f=1;char c=getchar();
	while(c>'9'||c<'0'){if(c=='-')f=0;c=getchar();}
	while(c>='0'&&c<='9'){x=(x<<3)+(x<<1)+(c^48);c=getchar();}
	return f?x:-x;
}
int n,m,p,v,x,mu[1000005],s[1000005],prime[1000005],cntt,fac[200005],val[1000005],
ans1,inv[200005],a[200005],cnt[1000005],ans2,s2[1000005];
bitset<1000005> vis;
inline int Pow(int x,int y){
	int res=1;
	for(;y;y>>=1,x=1ll*x*x%p)
		if(y&1)
			res=1ll*res*x%p;
	return res;
}
vector<int> vt;
signed main(){
	int c=clock();
	n=read(),m=read(),p=read();
	for(int i=1;i<=n;i++)
		a[i]=read(),v=max(v,a[i]),cnt[a[i]]++;
	mu[1]=1;
	for(int i=2;i<=v;i++){
		if(!vis[i]) prime[++cntt]=i,mu[i]=-1;
		for(int j=1;j<=cntt&&prime[j]*i<=v;j++){
			vis[i*prime[j]]=1;
			if(i%prime[j]) mu[i*prime[j]]=-mu[i];
			else break;
		}
	}
	fac[0]=inv[0]=1;
	for(int i=1;i<=n;i++)
		fac[i]=1ll*fac[i-1]*i%p;
	inv[n]=Pow(fac[n],p-2);
	for(int i=n-1;i;i--)
		inv[i]=1ll*inv[i+1]*(i+1)%p;
	for(int i=1;i<=v;i++)
		for(int j=i+i;j<=v;j+=i)
			cnt[i]+=cnt[j];
	for(int i=1;i<=v;i++)
		for(int j=1;i*j<=v;j++)
			val[i*j]+=i*mu[j];
//	assert(1.0*(clock()-c)/CLOCKS_PER_SEC>5);
	for(int i=1;i<=v;i++)
		s[cnt[i]]=(s[cnt[i]]+mu[i]+p)%p,s2[cnt[i]]=(s2[cnt[i]]+val[i]+p)%p;
	for(int i=1;i<=n;i++)
		if(s[i]||s2[i])
			vt.push_back(i);
	sort(vt.begin(),vt.end());
	reverse(vt.begin(),vt.end());
	while(m--){
		x=read(),ans1=ans2=0;
		if(x>n){
			puts("0 0");
			continue;
		}
		for(int i=0;i<vt.size();i++)
			if(vt[i]>=x){
				ans1=ans1+1ll*s[vt[i]]*fac[vt[i]]%p*inv[vt[i]-x]%p*inv[x]%p,
				ans2=ans2+1ll*s2[vt[i]]*fac[vt[i]]%p*inv[vt[i]-x]%p*inv[x]%p;
				if(ans1>=p) ans1-=p;
				if(ans2>=p) ans2-=p;
			}
			else break;
		printf("%d %d\n",ans1,ans2);
	}
    return 0;
}
```

---

## 作者：gcx114514 (赞：0)

第一个问题：
$$
\begin{aligned}
Ans_1&=\sum_{T\subseteq S\&\&|T|=k}[\gcd_{x\in T}x=1]\\
&=\sum_{T\subseteq S\&\&|T|=k}\sum_{i|\gcd_{x\in T}x}\mu(i)\\
&=\sum_{i=1}^n\mu(i)C_{cnt_i}^k\\
\end{aligned}
$$
$cnt_i$ 表示 $i$ 的倍数的出现次数，$n$ 为值域。

第二个问题：

考虑容斥，如果一个数作为 $\gcd$ 那么其他选出来的数必定是其倍数，并且不是其倍数的倍数例如：当 $i$ 作为 $\gcd$ 时，
$$
ans_i=i(C_{cnt_i}^k-C_{cnt_{2i}}^k-C_{cnt_{3i}}^k-C_{cnt_{5i}}^k+C_{cnt_{6i}}^k\dots)\\
$$
可以发现 
$$
\begin{aligned}
ans_i&=i\sum_{j=1}\mu(j)C_{cnt_j}^k\\
\therefore Ans_2&=\sum_{i=1}^nans_i=\sum_{i=1}^ni\sum_{j=1}^{\lfloor\frac{n}{i}\rfloor}\mu(j)C_{cnt_{ij}}^k\\
&=\sum_{i=1}^nC_{cnt_i}^k\sum_{j|i}\mu(j)\frac{i}{j}\\
&=\sum_{i=1}^nC_{cnt_i}^k\sum_{j|i}\mu(j)id(\frac ij)\\
\because \mu\ * id &=\varphi\\
\therefore Ans_2&=\sum_{i=1}^nC_{cnt_i}^k\varphi(i)\\\
\end{aligned}
$$
现在这样是 $O(nm)$ 的暴力，肯定过不去，考虑优化。可以发现这两个式子只与 $cnt_i$ 的值有关，那么我们可以将式子改写为：
$$
\begin{aligned}
Ans_1&=\sum_{i=1}^vC_{i}^k\sum_{j=1}^n\mu(j)[cnt_j==i]\\
Ans_2&=\sum_{i=1}^vC_{i}^k\sum_{j=1}^n\varphi(j)[cnt_j==i]\\
v&=\max_{i=1}^n\ cnt_i
\end{aligned}
$$
可以发现两个式子后面一个求和号中的值是不随 $k$ 变化而变化的，那么我们可以花费 $O(n)$ 的代价算出来其和为 $S1_i$,$S2_i$，故：
$$
Ans_1=\sum_{i=1}^vC_i^kS1_i\\
Ans_2=\sum_{i=1}^vC_i^kS2_i\\
$$
由于 $cnt_i$ 的种类不会过多，大约是 $O(\sqrt n)$ 种，可以暴力了。

```cpp
#include <bits/stdc++.h>
#define ll long long
#define mk make_pair
#define reaD read
#define raed read
#define haed head
#define cotu cout
#define se second
#define fi first
#define itn int
using namespace std;
const int Max=1e6+10;
int mod=998244353;
const int inf=1e9+10;

namespace fast_IO {
#define IOSIZE 1000000
	char ibuf[IOSIZE], obuf[IOSIZE], *p1 = ibuf, *p2 = ibuf, *p3 = obuf;
#define getchar() ((p1==p2)and(p2=(p1=ibuf)+fread(ibuf,1,IOSIZE,stdin),p1==p2)?(EOF):(*p1++))
#define putchar(x) ((p3==obuf+IOSIZE)&&(fwrite(obuf,p3-obuf,1,stdout),p3=obuf),*p3++=x)
#define isdigit(ch) (ch>47&&ch<58)
#define isspace(ch) (ch<33)
	template<typename T> inline T read() { T s = 0; int w = 1; char ch; while (ch = getchar(), !isdigit(ch) and (ch != EOF)) if (ch == '-') w = -1; if (ch == EOF) return false; while (isdigit(ch)) s = s * 10 + ch - 48, ch = getchar(); return s * w; }
	template<typename T> inline bool read(T &s) { s = 0; int w = 1; char ch; while (ch = getchar(), !isdigit(ch) and (ch != EOF)) if (ch == '-') w = -1; if (ch == EOF) return false; while (isdigit(ch)) s = s * 10 + ch - 48, ch = getchar(); return s *= w, true; }
	template<typename T> inline void print(T x) { if (x < 0) putchar('-'), x = -x; if (x > 9) print(x / 10); putchar(x % 10 + 48); }
	inline bool read(char &s) { while (s = getchar(), isspace(s)); return true; }
	inline bool read(char *s) { char ch; while (ch = getchar(), isspace(ch)); if (ch == EOF) return false; while (!isspace(ch)) *s++ = ch, ch = getchar(); *s = '\000'; return true; }
	inline void print(char x) { putchar(x); }
	inline void print(char *x) { while (*x) putchar(*x++); }
	inline void print(const char *x) { for (int i = 0; x[i]; i++) putchar(x[i]); }
	inline bool read(std::string& s) { s = ""; char ch; while (ch = getchar(), isspace(ch)); if (ch == EOF) return false; while (!isspace(ch)) s += ch, ch = getchar(); return true; }
	inline void print(std::string x) { for (int i = 0, n = x.size(); i < n; i++) putchar(x[i]); }
	inline bool read(bool &b) { char ch; while(ch=getchar(), isspace(ch)); b=ch^48; return true; }
	inline void print(bool b) { putchar(b+48); }
	template<typename T, typename... T1> inline int read(T& a, T1&... other) { return read(a) + read(other...); }
	template<typename T, typename... T1> inline void print(T a, T1... other) { print(a), print(other...); }
	struct Fast_IO { ~Fast_IO() { fwrite(obuf, p3 - obuf, 1, stdout); } } io;
	template<typename T> Fast_IO& operator >> (Fast_IO &io, T &b) { return read(b), io; }
	template<typename T> Fast_IO& operator << (Fast_IO &io, T b) { return print(b), io; }
#define cout io
#define cin io
#define endl '\n'
} using namespace fast_IO;


inline int read(){
	int x;
	cin>> x;
	return x;
}
int n,m;

ll ksm(ll a,int b){
	ll ans=1;
	for(;b;b>>=1){
		if(b&1)ans=ans*a%mod;
		a=a*a%mod;
	}
	return ans;
}


int pri[Max],phi[Max],flag[Max],pos,mu[Max];

void pre(int n){
	mu[1]=phi[1]=1;
	for(int i=2;i<=n;++i){
		if(!flag[i]){
			pri[++pos]=i;
			phi[i]=i-1;
			mu[i]=-1;
		}
		for(int j=1;j<=pos&&pri[j]*i<=n;++j){
			flag[i*pri[j]]=1;
			if(i%pri[j]==0){
				phi[i*pri[j]]=phi[i]*pri[j];
				break;
			}
			mu[i*pri[j]]-=mu[i];
			phi[i*pri[j]]=phi[i]*(pri[j]-1);
		}
	}
}

int a[Max];

ll p[Max];
ll inv[Max];
ll C(int n,int m){
	return p[n]*inv[m]%mod*inv[n-m]%mod;
}

ll val[Max];
ll ans1[Max],ans2[Max];

void add(ll &a,ll b){
	a=a+b;
	a+=(a<0?mod:0);
	a-=((a>=mod)?mod:0);
}

signed main(){
	n=read();
	m=read();
	mod=read();
	int v=0;
	p[0]=1;
	for(int i=1;i<=n;++i){
		a[i]=read();
		v=max(v,a[i]);
		p[i]=p[i-1]*i%mod;
		val[a[i]]++;
	}
	pre(max(n,v));
	for(int i=1;i<=v;++i){
		for(int j=2*i;j<=v;j+=i) {
			val[i]+=val[j];
		}
	}
	inv[n]=ksm(p[n],mod-2);
	for(int i=n-1;i>=0;--i){
		inv[i]=inv[i+1]*(i+1)%mod;
	}
	for(int i=1;i<=max(n,v);++i)mu[i]=mu[i]+(mu[i]<0?mod:0);
	for(int i=1;i<=v;++i){
		for(int k=1;k<=val[i];++k){
			add(ans2[k],C(val[i],k)*phi[i]%mod);
			add(ans1[k],C(val[i],k)*mu[i]%mod);
		}
	}
	for(int i=1;i<=m;++i){
		int x=read();
		cotu << ans1[x] << ' ' << ans2[x] << "\n";
	}

	return 0;
}
```

---

## 作者：dAniel_lele (赞：0)

设 $V$ 为 $a_i$ 的值域。

考虑容斥，对于每个 $i$ 计算出实力值 $j$ 满足 $i\mid j$ 的选出方案数。对于每个 $j$ 均有其对应的给答案的贡献，预处理一下。

考虑如何对于每个 $i$ 计算方案数，该条件等价于所有选出的 $a_x$ 都是 $i$ 的倍数。也就是说我们要计算有多少 $a_x$ 是 $i$ 的倍数，记为 $cnt_i$，于是可以 $O(V\ln V)$ 求出符合要求的人数。

注意到我们要多测，不可能对于每个 $k_i$ 都 $O(V)$ 统计答案。然而，注意到 $\sum cnt_i=nd(V)$ 级别的，其中 $d(V)$ 为小于等于 $V$ 的所有数因子个数的最大值。也就是说我们可以 $O(nd(V))$ 预处理出每个 $k_i$ 的答案。

总复杂度 $O(v\ln v+nd(V))$，轻微卡常。

```cpp
#include <bits/stdc++.h>
#define int long long
#define add(i,j) ((i+j>=mod)?i+j-mod:i+j)
using namespace std;
int mod;
int qp(int a,int b){
	int ans=1;
	while(b){
		if(b&1) (ans*=a)%=mod;
		(a*=a)%=mod;
		b>>=1;
	}
	return ans;
}
int fac[1000005],inv[1000005];
void init(){
	fac[0]=1; for(int i=1;i<=1000000;i++) fac[i]=fac[i-1]*i%mod;
	inv[1000000]=qp(fac[1000000],mod-2); for(int i=999999;i>=0;i--) inv[i]=inv[i+1]*(i+1)%mod;
}
int C(int i,int j){
	if(i<j||i<0||j<0) return 0;
	return inv[j]*inv[i-j];
}
int f[1000005],g[1000005],cnt[1000005],ans1[1000005],ans2[1000005];
int pf[1000005],pg[1000005],tag[1000005];
signed main(){
	ios::sync_with_stdio(false);
	int n,m; cin>>n>>m>>mod;
	const int p=mod;
	f[1]=1;
	for(int i=1;i<=1000000;i++) g[i]=i;
	for(int i=1;i<=1000000;i++) for(int j=i*2;j<=1000000;j+=i) f[j]=add(f[j],p-f[i]),g[j]=add(g[j],p-g[i]);
	init();
	for(int i=1;i<=n;i++){
		int a; cin>>a; cnt[a]++;
	}
	for(int i=1;i<=1000000;i++) for(int j=i*2;j<=1000000;j+=i) cnt[i]+=cnt[j]; 
	for(int i=1;i<=1000000;i++){
		(pf[cnt[i]]+=f[i])%=p;
		(pg[cnt[i]]+=g[i])%=p;
		tag[cnt[i]]=1;
	}
	for(int i=1;i<=1000000;i++){
		if(tag[i]){
			(pf[i]*=fac[i])%=p;
			(pg[i]*=fac[i])%=p;
			for(int j=1;j<=i;j++){
				(ans1[j]+=C(i,j)%p*pf[i])%=p;
				(ans2[j]+=C(i,j)%p*pg[i])%=p;
			}
		}
	}
	while(m--){
		int t; cin>>t;
		cout<<ans1[t]<<" "<<ans2[t]<<"\n";
	}
	return 0;
}
```

---


# BZOJ3518 点组计数

## 题目描述

平面上摆放着一个 $n\times m$ 的点阵，如下图是一个 $3\times 4$ 的点阵图：

![](https://cdn.luogu.com.cn/upload/image_hosting/6tq3jene.png)

现问，有多少个三元点对组 $(a,b,c)$ 满足 $a,b,c$ 三点共线，顺序无关紧要，例如 $(a,b,c)$ 与 $(b,c,a)$ 算一组。答案对 $10^9+7$ 取模。

## 说明/提示

数据保证，$1\leq n,m\leq 5\times 10^4$。

## 样例 #1

### 输入

```
3 4```

### 输出

```
20```

# 题解

## 作者：_maojun_ (赞：7)

看看怎么数数，推推式子。

首先同行同列的方案数是 $n{m\choose3}+m{n\choose3}$，这个是简单的。

不同行同列的话，斜率为负的线，贡献和斜率为正的线一样。这里统计斜率为正的线，最后答案 $\times2$ 即可。

考虑枚举最远的点对的横纵坐标差 $i,j$，满足这个条件的点对有 $(n-i)(m-j)$ 个。

做过 P1447 的话应该可以发现中间点有 $\gcd(i,j)-1$ 种方案。

于是有：

$$\mathrm{ans}=n{m\choose3}+m{n\choose3}+2(\sum\limits_{i=1}^n\sum\limits_{j=1}^m(n-i)(m-j)(\gcd(i,j)-1))$$

---

其实后面就是套路了，建议自己推一推，反正不难。

看看怎么快速计算：
$$
\begin{aligned}
&\sum\limits_{i=1}^n\sum\limits_{j=1}^m(n-i)(m-j)(\gcd(i,j)-1)\\=
&\sum\limits_{i=1}^n\sum\limits_{j=1}^m(n-i)(m-j)\gcd(i,j)-\sum\limits_{i=1}^n\sum\limits_{j=1}^m(n-i)(m-i)
\end{aligned}
$$
先看看后面的。

记 $\operatorname{sum}(n)=\sum\limits_{i=1}^ni=\dfrac{n(n+1)}2$，则：
$$
\begin{aligned}
&\sum\limits_{i=1}^n\sum\limits_{j=1}^m(n-i)(m-j)\\=
&\sum\limits_{i=0}^{n-1}\sum\limits_{j=0}^{m-1}ij\\=
&\operatorname{sum}(n-1)\operatorname{sum}(m-1)
\end{aligned}
$$
再看看前面的，不妨设 $n\le m$。则：
$$
\begin{aligned}
&\sum\limits_{i=1}^n\sum\limits_{j=1}^m(n-i)(m-j)\gcd(i,j)\\=
&\sum\limits_{i=1}^n\sum\limits_{j=1}^m(n-i)(m-j)\sum\limits_{d\mid i,d\mid j}\varphi(d)\\=
&\sum\limits_{d=1}^n\varphi(d)\sum\limits_{i=1}^{\left\lfloor\frac nd\right\rfloor}\sum\limits_{j=1}^{\left\lfloor\frac md\right\rfloor}(n-id)(m-jd)
\end{aligned}
$$
记 $f(n,d)=\sum\limits_{i=1}^{\left\lfloor\frac nd\right\rfloor}(n-id)=n\left\lfloor\frac nd\right\rfloor-d\operatorname{sum}(\left\lfloor\frac nd\right\rfloor)$。

则上式可继续简化：
$$
\begin{aligned}
=&\sum\limits_{d=1}^n\varphi(d)\sum\limits_{i=1}^{\left\lfloor\frac nd\right\rfloor}(n-id)\sum\limits_{j=1}^{\left\lfloor\frac md\right\rfloor}(m-jd)\\
=&\sum\limits_{d=1}^n\varphi(d)f(n,d)f(m,d)
\end{aligned}
$$
即可做到 $O(n)$。

```cpp
typedef long long ll;
const int N=5e4+5,MOD=1e9+7;
int n,m,phi[N];
int pc=0,p[N];bool vis[N];
inline void seive(){
	phi[1]=1;
	for(int i=2;i<=n;i++){
		if(!vis[i]){p[++pc]=i;phi[i]=i-1;}
		for(int j=1,k;j<=pc&&(k=i*p[j])<=n;j++){
			vis[k]=true;
			if(i%p[j]==0){phi[k]=phi[i]*p[j];break;}
			phi[k]=phi[i]*(p[j]-1);
		}
	}
}

inline ll C3(ll x){return x*(x-1)*(x-2)/6%MOD;}
inline ll sum(ll x){return x*(x+1)/2%MOD;}
inline ll f(ll n,int d){return(n/d*n-d*sum(n/d))%MOD;}
int main(){
	scanf("%d%d",&n,&m);if(n>m)swap(n,m);
	seive();
	ll res=0;
	for(int i=1;i<=n;i++)res=(res+phi[i]*f(n,i)%MOD*f(m,i))%MOD;
	res=(res-sum(n-1)*sum(m-1))*2+n*C3(m)+m*C3(n);
	printf("%lld\n",(res%MOD+MOD)%MOD);
	return 0;
}
```

---

复杂度更优的做法：

$$
\begin{aligned}
\mathrm{ans}&=\sum\limits_{d=1}^n\varphi(d)f(n,d)f(m,d)\\
&=\sum\limits_{d=1}^n\varphi(d)(n\left\lfloor\frac nd\right\rfloor-d\operatorname{sum}(\left\lfloor\frac nd\right\rfloor))(m\left\lfloor\frac md\right\rfloor-d\operatorname{sum}(\left\lfloor\frac md\right\rfloor))\\
&=\sum\limits_{d=1}^nn\left\lfloor\frac nd\right\rfloor m\left\lfloor\frac md\right\rfloor\varphi(d)\\
&-\sum\limits_{d=1}^n(n\left\lfloor\frac nd\right\rfloor\operatorname{sum}(\left\lfloor\frac md\right\rfloor)+m\left\lfloor\frac md\right\rfloor\operatorname{sum}(\left\lfloor\frac nd\right\rfloor))d\varphi(d)\\
&+\sum\limits_{d=1}^n\operatorname{sum}(\left\lfloor\frac nd\right\rfloor)\operatorname{sum}(\left\lfloor\frac md\right\rfloor)d^2\varphi(d)\\
\end{aligned}
$$

考虑整除分块，只需快速求 $\sum\limits_{i=1}^n\varphi(i),\sum\limits_{i=1}^ni\varphi(i),\sum\limits_{i=1}^ni^2\varphi(i)$。

**做法一**：线性筛预处理+整除分块，复杂度 $O(n+T\sqrt n)$。

记 $f_k(x)=x^k\varphi(x)$，具体地：

- $f_k(p)=p^k(p-1)$

- 对于 $\gcd(x,y)=1$，$f_k(xy)=f_k(x)f_k(y)$

- 对于 $p\mid x$，$f_k(xp)=f_k(x)p^{k+1}$

这样就可以线性筛出来。

**做法二**：杜教筛+整除分块，复杂度 $O(n^{\frac23})$。

因为有 $\left\lfloor\dfrac{\left\lfloor\dfrac na\right\rfloor}b\right\rfloor=\left\lfloor\dfrac n{ab}\right\rfloor$，所以复杂度是对的。

具体地，构造 $g_k(x)=x^k$，则有

$$
\begin{aligned}
(f_k*g_k)(n)&=\sum\limits_{d\mid n}f_k(d)g_k(\dfrac nd)\\
&=\sum\limits_{d\mid n}d^k\varphi(d)(\dfrac nd)^k\\
&=n^k\sum\limits_{d\mid n}\varphi(d)\\
&=n^{k+1}
\end{aligned}
$$

$g_k$ 和 $f_k*g_k$ 都可以快速求前缀和，这样就可以杜教筛了。

---

## 作者：luuia (赞：1)

### Solution

如果三个点在同一条横线上，那么问题就等价于在 $m$ 个点内取三个点的方案数，因为总共有 $n$ 条横线，所以 $\operatorname{ans} = n \times C_m^3$。同理，如果三个点在同一条竖线上，$\operatorname{ans} = m \times C_n^3$。

如果三个点位于一条斜线上，我们根据对称性，可以只考虑 $k > 0$ 的直线，$k < 0$ 的部分应该和前面 $k>0$ 部分的贡献相同，最后把答案乘 $2$ 即可。

不妨设 $k>0,x_a<x_b<x_c$，我们枚举 $A$ 和 $C$ 的横纵坐标差 $i,j$，参考 [P1447](https://www.luogu.com.cn/problem/P1447) 这道题，得到线段 $AC$ 的整点数除了 $A,C$ 以外有 $\gcd(i,j) - 1$ 个，而不同的 $A,C$ 总共有 $(n-i)(m-j)$ 个，根据乘法原理，我们得到这种情况下答案的式子：

$$\operatorname{ans} = \sum_{i=1}^n\sum_{j=1}^m(n-i)(m-j)(\gcd(i,j)-1)$$

开始推式子。

$$
\begin{aligned}
\operatorname{ans} &= \sum_{i=1}^n\sum_{j=1}^m(n-i)(m-j)(\gcd(i,j)-1) \\

&= \sum_{i=1}^n\sum_{j=1}^m(n-i)(m-j)\gcd(i,j) - \sum_{i=1}^n\sum_{j=1}^m(n-i)(m-j) \\

&= \sum_{i=1}^n\sum_{j=1}^m(n-i)(m-j)\gcd(i,j) - \sum_{i=0}^{n-1}\sum_{j=0}^{m-1}i \times j \\

&= \sum_{i=1}^n\sum_{j=1}^m(n-i)(m-j)\gcd(i,j) - \sum_{i=0}^{n-1}i \times \sum_{j=0}^{m-1} j \\

&= \sum_{i=1}^n\sum_{j=1}^m(n-i)(m-j)\gcd(i,j) - \frac{nm(n-1)(m-1)}{4}\\
\end{aligned}
$$

我们对于前面的式子，考虑莫比乌斯反演或者欧拉反演。

欧拉反演的核心式子是 $\sum_{d \mid n}\varphi(d) = n$，即 $\varphi * 1 = \operatorname{id}$。

不妨设 $n<m$：

$$
\begin{aligned}
\operatorname{ans'} &= \sum_{i=1}^n\sum_{j=1}^m(n-i)(m-j)\gcd(i,j) \\

&= \sum_{i=1}^n\sum_{j=1}^m(n-i)(m-j)\sum_{d \mid \gcd(i,j)}\varphi(d) \\

&=  \sum_{i=1}^n\sum_{j=1}^m(n-i)(m-j)\sum_{d =1}^n \varphi(d)[d \mid i][d \mid j] \\

&=  \sum_{id=1}^n\sum_{jd=1}^m(n-id)(m-jd)\sum_{d =1}^n \varphi(d) \\

&=  \sum_{d =1}^n \varphi(d)\sum_{i=1}^{\lfloor\frac{n}{d} \rfloor}\sum_{j=1}^{\lfloor\frac{m}{d} \rfloor}(n-id)(m-jd) \\

&=  \sum_{d =1}^n \varphi(d)(n\lfloor\frac{n}{d} \rfloor-d \times \frac{(\lfloor\frac{n}{d} \rfloor)(\lfloor\frac{n}{d} \rfloor+1)}{2})     (m\lfloor\frac{m}{d} \rfloor-d \times \frac{(\lfloor\frac{m}{d} \rfloor)(\lfloor\frac{m}{d} \rfloor+1)}{2}) \\
\end{aligned}
$$

现在可以线性筛出 $\varphi(i)$，然后 $O(n)$ 计算，已经可以通过本题。

复杂度更优的解法是把上面的括号拆开，然后用杜教筛筛出 $f(d) = d^{\,k}\varphi(d),k = 0,1,2$ 的前缀和再整除分块即可做到 $O(n^{\frac{2}{3}})$。

### Code

```cpp
#include<bits/stdc++.h>
using namespace std;

long long read()
{
    long long s = 0,w = 1;
    char ch = getchar();
    while(ch < '0' || ch > '9')
    {
        if(ch == '-') w = -1;
        ch = getchar();
    }
    while(ch >= '0' && ch <= '9')
    {
        s = (s << 1) + (s << 3) + (ch ^ 48);
        ch = getchar();
    }
    return s * w;
}

void write(long long a)
{
    if(a > 9) write(a / 10);
    putchar(a % 10 + '0');
}

const int N = 1e5 + 10,p = 1e9 + 7;
long long n,m,cnt,ans,prime[N],phi[N];

void euler() 
{
	phi[1] = 1;
	for(int i = 2;i <= n;i++) 
    {
		if(!phi[i]) prime[++cnt] = i,phi[i] = i - 1;
		for(int j = 1;j <= cnt && i * prime[j] <= n;j++) 
        {
			if (!(i % prime[j])) 
            {
				phi[i * prime[j]] = phi[i] * prime[j];
				break;
			}
			else phi[i * prime[j]] = phi[i] * phi[prime[j]];
		}
	}
}

long long S1(long long x){return x * (x + 1) / 2 % p;}

long long S2(long long x){return x * (x - 1) * (x - 2) / 6 % p;}

int main()
{
    // freopen("input.in","r",stdin);
    n = read(),m = read(),euler();
    if(n > m) swap(n,m);
    for(int i = 1;i <= n;i++)
    {
        ans += phi[i] * (n * (n / i) % p - i * S1(n / i) % p) * (m * (m / i) % p - i * S1(m / i) % p);
        ans = (ans % p + p) % p;
    }
    ans -= S1(n - 1) * S1(m - 1) % p,ans = (ans % p + p) % p;
    ans = ans * 2 % p,ans += (S2(n) * m + S2(m) * n),ans %= p;
    cout << (ans % p + p) % p << endl;
    return 0;
}
```

---

## 作者：封禁用户 (赞：1)

### 前置知识
莫比乌斯反演，欧拉函数，线性筛，狄利克雷卷积。

### 题意分析
求满足三点共线的三元点对组的数量。

### 思路讲解
考虑枚举三个点所构成的直线的斜率。\
这里只考虑斜率为正数的情况，最后结果乘 $2$。\
特别地，横着三点共线与竖着三点共线的方案数共为 $n{m \choose 3}+m{n \choose 3}$。

### 式子推导
首先，根据我们的思路，先枚举直线的斜率 $\frac{i}{j}$：
$$
\begin{aligned}
n{m \choose 3}+m{n \choose 3}+2\sum_{i=1}^{n}\sum_{j=1}^{m}(n-i)(m-j)(\gcd(i,j)-1)
\end{aligned}
$$

求出 $\sum_{i=1}^{n}\sum_{j=1}^{m}(n-i)(m-j)(\gcd(i,j)-1)$，即可知道原式的值。

$$
\begin{aligned}
&\sum_{i=1}^{n}\sum_{j=1}^{m}(n-i)(m-j)(\gcd(i,j)-1)&\\
=&\sum_{i=1}^{n}\sum_{j=1}^{m}(n-i)(m-j)\gcd(i,j)-\sum_{i=1}^{n}\sum_{j=1}^{m}(n-i)(m-j)\\
=&\sum_{i=1}^{n}\sum_{j=1}^{m}(n-i)(m-j)\gcd(i,j)-\sum_{i=0}^{n-1}i\sum_{j=0}^{m-1}j
\end{aligned}
$$

令 $S(n)=\sum_{i=1}^{n}i$。

$$
\text{原式}=\sum_{i=1}^{n}\sum_{j=1}^{m}(n-i)(m-j)\gcd(i,j)-S(n-1)S(m-1)
$$

计算 $\sum_{i=1}^{n}\sum_{j=1}^{m}(n-i)(m-j)\gcd(i,j)$ 即可。
$$
\begin{aligned}
&\sum_{i=1}^{n}\sum_{j=1}^{m}(n-i)(m-j)\gcd(i,j)&\\
\end{aligned}
$$

枚举 $\gcd(i,j)$ 并令 $n \le m$：

$$
\begin{aligned}
\text{原式}&=\sum_{d=1}^{n}\sum_{i=1}^{n}\sum_{j=1}^{m}(n-i)(m-j)d[\gcd(i,j)=d]&\\
&=\sum_{d=1}^{n}d\sum_{i=1}^{\lfloor \frac{n}{d} \rfloor}\sum_{j=1}^{\lfloor \frac{m}{d} \rfloor}(n-di)(m-dj)[\gcd(i,j)=1]&\\
\end{aligned}
$$

接下来就是莫反：

$$
\begin{aligned}
\text{原式}&=\sum_{d=1}^{n}d\sum_{i=1}^{\lfloor \frac{n}{d} \rfloor}\sum_{j=1}^{\lfloor \frac{m}{d} \rfloor}(n-di)(m-dj)\sum_{k\mid i,k\mid j}\mu(k)&\\
&=\sum_{d=1}^{n}d\sum_{k=1}^{\lfloor \frac{n}{d} \rfloor}\mu(k)\sum_{i=1}^{\lfloor \frac{n}{dk} \rfloor}\sum_{j=1}^{\lfloor \frac{m}{dk} \rfloor}(n-dki)(m-dkj)&\\
\end{aligned}
$$

令 $T=kd$。

$$
\begin{aligned}
\text{原式}=&\sum_{d=1}^{n}d\sum_{k=1}^{\lfloor \frac{n}{d} \rfloor}\mu(\frac{T}{d})\sum_{i=1}^{\lfloor \frac{n}{T} \rfloor}\sum_{j=1}^{\lfloor \frac{m}{T} \rfloor}(n-Ti)(m-Tj)&\\
=&\sum_{T=1}^{n}\sum_{i=1}^{\lfloor \frac{n}{T} \rfloor}\sum_{j=1}^{\lfloor \frac{m}{T} \rfloor}(n-Ti)(m-Tj)\sum_{d\mid T}d\mu(\frac{T}{d})&\\
\end{aligned}
$$

$$
\because \varphi=\mu \times id\\
$$

$$
\begin{aligned}
\therefore\text{原式}=&\sum_{T=1}^{n}\varphi(T)\sum_{i=1}^{\lfloor \frac{n}{T} \rfloor}\sum_{j=1}^{\lfloor \frac{m}{T} \rfloor}(n-Ti)(m-Tj)&\\
=&\sum_{T=1}^{n}\varphi(T)\sum_{i=1}^{\lfloor \frac{n}{T} \rfloor}(n-Ti)\sum_{j=1}^{\lfloor \frac{m}{T} \rfloor}(m-Tj)&\\
=&\sum_{T=1}^{n}\varphi(T)(n\lfloor \frac{n}{T} \rfloor-S(\lfloor \frac{n}{T} \rfloor)T)(m\lfloor \frac{m}{T} \rfloor-S(\lfloor \frac{m}{T} \rfloor)T)
\end{aligned}
$$

线性筛维护 $\varphi$ 即可。

---

## 作者：lalaouye (赞：1)

莫比乌斯反演做法。

将横线竖线斜线分开考虑。这题有个很好的特点，就是以四个角落为线段端点所涵盖的的线的种类是最多的。那么我们先将枚举的线的一个端点固定在左上角，其坐标为 $(0,0)$，然后再枚举另外一个端点 $(i,j)$，那么这种线在本题中的贡献为 $(\gcd(i,j)-1)\times(n-i+1)\times(m-j+1)$，为什么呢？因为这种线段在图像中有 $(n-i+1)(m-j+1)$ 个位置可以存放，并且中间的点有 $(\gcd(i,j)-1)$ 个位置可以选择，所以我们将本题转化为计算 $\sum_{i=1}^n\sum_{j=1}^m(\gcd(i,j)-1)(n-i+1)(m-j+1)$。

我们将式子拆开，分别计算出 

$$a=\sum_{i=1}^n\sum_{j=1}^m(\gcd(i,j)-1)(n+1)(m+1)$$

$$b=\sum_{i=1}^n\sum_{j=1}^mi(\gcd(i,j)-1)(m+1)$$

$$c=\sum_{i=1}^n\sum_{j=1}^mj(\gcd(i,j)-1)(n+1)$$

$$d=\sum_{i=1}^n\sum_{j=1}^mij(\gcd(i,j)-1)$$

$$ans=a-b-c+d$$

即可。

计算可以利用莫比乌斯反演，时间复杂度 $\mathcal{O}(n)$。

注意，因为我左上角坐标为 $(0,0)$，故开始 $n,m$ 都要减一。最后再加回去来计算横竖线产生的贡献。

代码：

```
#include <bits/stdc++.h>
#define rep(i, l, r) for (int i = l; i <= r; ++ i)
#define rrp(i, l, r) for (int i = r; i >= l; -- i)
#define eb emplace_back
#define int long long
using namespace std;
constexpr int N = 5e4 + 5, P = 1e9 + 7;
inline int rd ()
{
  int x = 0, f = 1;
  char ch = getchar ();
  while (! isdigit (ch))
  {
    if (ch == '-') f = - 1;
    ch = getchar ();
  }
  while (isdigit (ch))
  {
    x = (x << 1) + (x << 3) + (ch ^ 48);
    ch = getchar ();
  }
  return x * f;
}
int qpow (int x, int y)
{
  int ret = 1;
  for (; y; y >>= 1, x = x * x % P) if (y & 1) ret = ret * x % P;
  return ret;
}
int T;
int mu[N], pri[N], cnt;
int sum[N], s1[N], s2[N], s3[N], s4[N], s5[N];
bool ip[N];
int func (int a, int b, int t)
{
  int n = min (a, b);
  int ret = 0;
  int l1, l2, r1, r2;
  l1 = l2 = 1;
  while (l1 <= n && l2 <= n)
  {
    int k1 = a / l1;
    r1 = min (a / k1, n);
    int k2 = b / l2;
    r2 = min (b / k2, n);
    if (t == 1)
    (ret += (sum[min (r1, r2)] - sum[max (l1, l2) - 1]) * k1 * k2) %= P;
    if (t == 2)
    (ret += (s4[min (r1, r2)] - s4[max (l1, l2) - 1]) * (k1 * (k1 + 1) / 2 % P) % P * k2) %= P;
    if (t == 3)
    (ret += (s4[min (r1, r2)] - s4[max (l1, l2) - 1]) * (k2 * (k2 + 1) / 2 % P) % P * k1) %= P;
    if (t == 4)
    (ret += (s5[min (r1, r2)] - s5[max (l1, l2) - 1]) * (k1 * (k1 + 1) / 2 % P) % P * (k2 * (k2 + 1) / 2 % P)) %= P;
    if (r1 < r2) l1 = r1 + 1; else l2 = r2 + 1;
  }
  return ret;
}
signed main ()
{
  mu[1] = 1;
  rep (i, 2, N - 1)
  {
    if (! ip[i])
    {
      pri[++ cnt] = i;
      mu[i] = -1;
    }
    for (int j = 1; j <= cnt && i * pri[j] <= N - 1; ++ j)
    {
      ip[i * pri[j]] = 1;
      if (i % pri[j] == 0)
      {
        mu[i * pri[j]] = 0;
        break;
      }
      mu[i * pri[j]] = - mu[i];
    }
  }
  rep (i, 0, N - 1) sum[i] = sum[i - 1] + mu[i];
  rep (i, 1, N - 1)
  	s1[i] = (s1[i - 1] + max (0ll, i - 1)) % P,
  	s2[i] = (s2[i - 1] + i * max (0ll, i - 1)) % P,
	s3[i] = (s3[i - 1] + i * i * max (0ll, i - 1)) % P,
	s4[i] = (s4[i - 1] + mu[i] * i) % P,
	s5[i] = (s5[i - 1] + mu[i] * i * i) % P;
  int n = rd () - 1, m = rd () - 1;
  if (n > m) swap (n, m);
  int l1 = 1, l2 = 1, ret = 0;
  while (l1 <= n && l2 <= n)
  {
    int r1 = n / (n / l1);
    int r2 = m / (m / l2);
    int l = max (l1, l2), r = min (r1, r2);
    (ret +=
	func (n / l, m / r, 1) * (m + 1) % P * (n + 1) % P * (s1[r] - s1[l - 1]) -
	func (n / l, m / r, 2) * (m + 1) % P * (s2[r] - s2[l - 1]) - 
	func (n / l, m / r, 3) * (n + 1) % P * (s2[r] - s2[l - 1]) + 
	func (n / l, m / r, 4) * (s3[r] - s3[l - 1])
	);
    if (r1 < r2) l1 = r1 + 1; else l2 = r2 + 1;
  }
  ret <<= 1;
  ++ n, ++ m;
  rep (i, 3, n) (ret += (i - 2) * m * (n - i + 1)) %= P;
  rep (i, 3, m) (ret += (i - 2) * n * (m - i + 1)) %= P;
  printf ("%lld\n", (ret + P) % P);
}
 
```

---

## 作者：Kreado (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P10636)。

规定 $n\le m$。

考虑分别计算横着三点共线的，竖着三点共线的，和斜着三点共线的，容易发现，向右下的直线只需对称一下即可得到向左下的直线，于是我们只需计算向右下直线中有多少个三点共线。

横着三点共线的方案是 $n\binom{m}{3}$，竖着三点共线的方案是 $m\binom{n}{3}$。

对于斜着的三点共线，考虑枚举线段的两个端点，假设线段经过的整点有 $h$ 个，那么这条线段的贡献是 $h-2$，对于两个端点 $(x_1,y_1),(x_2,y_2)$，令 $a=|x_1-x_2|+1,b=|y_1-y_2|+1$，那么线段经过的整点数量为 $\gcd(a,b)+1$，贡献就是 $\gcd(a,b)-1$，也就是说，我们只需关心两个端点横纵坐标差，我们可以轻松写出答案式子：

$$\sum_{i=1}^{n-1} \sum_{j=1}^{m-1}(n-i)(m-j)(\gcd(i,j)-1)$$

考虑欧拉反演。

$$
\begin{aligned}
\sum_{i=1}^{n-1}\sum_{j=1}^{m-1}(n-i)(m-j)\sum_{d\mid \gcd(i,j)}\varphi(d)-\sum_{i=1}^{n-1}\sum_{j=1}^{m-1}(n-i)(m-j)
\end{aligned}
$$

后面的式子是 $\left(\dfrac{n(n-1)}{2}\right)\left(\dfrac{m(m-1)}{2}\right)$，前面的式子继续反演：

$$\sum_{d=1}^{n-1}\varphi(d)\sum_{i=1}^{(n-1)/d}\sum_{j=1}^{(m-1)/d}(n-id)(m-jd)$$

继续反演可以做到 $O(\sqrt n)$，但是 $O(n\ln n)$ 已经足够了。

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;

const int Mod=1e9+7,Maxn=1e5+7,N=1e5;
ll n,m;
ll ans;
int phi[Maxn];

inline ll binom(ll x){
    return x*(x-1)*(x-2)/6%Mod;
}

int main(){
    scanf("%lld%lld",&n,&m);
    if(n>m) swap(n,m);
    ans=(n*binom(m)+m*binom(n))%Mod;

    for(int i=1;i<=n;i++){
        phi[i]+=i;
        for(int j=i+i;j<=n;j+=i) phi[j]-=phi[i];
    }

    ll res=-(n*(n-1)/2)%Mod*(m*(m-1)/2)%Mod;
    for(int d=1;d<n;d++){
        ll res1=0,res2=0;
        for(int i=1;i<=(n-1)/d;i++) res1+=(n-i*d),res1%=Mod;
        for(int i=1;i<=(m-1)/d;i++) res2+=(m-i*d),res2%=Mod;
        res=(res+1ll*phi[d]*res1%Mod*res2%Mod)%Mod;
    }
    ans=(ans+res*2)%Mod;
    
    printf("%lld",ans);
    return 0;
}
```

---

## 作者：Starrykiller (赞：1)

> 选自 数学部分做题记录 **XCIII**。
> 
> [莫比乌斯反演学习记录](https://www.cnblogs.com/Starrykiller/p/18016231/mobius-inversion)。

其实就是 **XCII** 的加强版。

平凡的，略去斜率不存在或者为 $0$ 的情况。不妨只考虑斜率 $\gt 0$ 的情况，最终再乘以 $2$。

**由 [P1447 [NOI2010] 能量采集](https://www.luogu.com.cn/problem/P1447) 的套路可知**，设两点横纵坐标差值为 $\Delta x,\Delta y$，它们之间有 $\gcd(\Delta x,\Delta y)-1$ 个点。所以我们就要算

$$
\begin{aligned}
&\sum_{i=1}^n\sum_{j=1}^m (n-i)(m-j)(\gcd(i,j)-1)
\end{aligned}
$$

在 P3166 中我们可以暴力计算，但是本题中我们需要更优的做法。

首先将和式拆开，变成 

$$
\begin{aligned}
=\sum_{i=1}^n\sum_{j=1}^m (n-i)(m-j)\gcd(i,j)-\sum_{i=1}^n\sum_{j=1}^m (n-i)(m-j)
\end{aligned}
$$

对于右边，显然等于

$$
\begin{aligned}
&\sum_{i=0}^{n-1}\sum_{j=1}^{m-1}ij \\
=&\frac{n(n-1)}{2}\frac{m(m-1)}{2}
\end{aligned}
$$

对于左边，显然等于

$$
nm\boxed{\sum_{i=1}^n\sum_{j=1}^m \gcd(i,j)}-n\boxed{\sum_{i=1}^n\sum_{j=1}^m i \gcd(i,j)}-m\sum_{i=1}^n\sum_{j=1}^m j\gcd(i,j)+\boxed{\sum_{i=1}^n\sum_{j=1}^m ij\gcd(i,j)}
$$

然后你发现这三个都是典题。不过我们不妨推一下：（默认 $n\le m$）

$$
\begin{aligned}
&\sum_{i=1}^n\sum_{j=1}^m\gcd(i,j) \\
=&\sum_{i=1}^n\sum_{j=1}^m\sum_{d\mid i,d\mid j}\varphi(d)\\
=&\sum_{d=1}^{n}\varphi(d)\sum_{i=1}^n\sum_{j=1}^m[d\mid i][d\mid j]\\
=&\sum_{d=1}^{n}\varphi(d)\sum_{i=1}^{\lfloor \frac{n}{d}\rfloor}\sum_{j=1}^{\lfloor \frac{m}{d}\rfloor} 1\\
=&\sum_{d=1}^{n}\varphi(d) \left\lfloor \frac{n}{d}\right\rfloor\left\lfloor \frac{m}{d}\right\rfloor
\end{aligned}
$$

我们记 $s(n)=\sum_{i=1}^n i$。

$$
\begin{aligned}
&\sum_{i=1}^n\sum_{j=1}^m i\gcd(i,j) \\
=&\sum_{i=1}^n\sum_{j=1}^m i\sum_{d\mid i,d\mid j}\varphi(d)\\
=&\sum_{d=1}^{n}\varphi(d)\sum_{i=1}^n\sum_{j=1}^mi[d\mid i][d\mid j]\\
=&\sum_{d=1}^{n}\varphi(d)\sum_{i=1}^{\lfloor \frac{n}{d}\rfloor}\sum_{j=1}^{\lfloor \frac{m}{d}\rfloor} id\\
=&\sum_{d=1}^{n}d\cdot \varphi(d) s\left(\left\lfloor \frac{n}{d}\right\rfloor\right)\left\lfloor \frac{m}{d}\right\rfloor
\end{aligned}
$$

$$
\begin{aligned}
&\sum_{i=1}^n\sum_{j=1}^m ij\gcd(i,j) \\
=&\sum_{i=1}^n\sum_{j=1}^m ij\sum_{d\mid i,d\mid j}\varphi(d)\\
=&\sum_{d=1}^{n}\varphi(d)\sum_{i=1}^n\sum_{j=1}^mij[d\mid i][d\mid j]\\
=&\sum_{d=1}^{n}\varphi(d)\sum_{i=1}^{\lfloor \frac{n}{d}\rfloor}\sum_{j=1}^{\lfloor \frac{m}{d}\rfloor} id\cdot jd\\
=&\sum_{d=1}^{n}d^2\cdot \varphi(d) s\left(\left\lfloor \frac{n}{d}\right\rfloor\right)s\left(\left\lfloor \frac{m}{d}\right\rfloor\right)
\end{aligned}
$$

然后就做完了，利用线性筛，时间复杂度为 $\Theta(n)$。不理解为什么才开到 $5\times 10^4$。

Bonus：考虑 $n,m\le 10^{10}$ 的时候如何做。

---

## 作者：Purslane (赞：0)

# Solution

考虑枚举线段的两个端点，计算这条线段经过了多少个其他的点。

不妨设这条线段的位移是 $\vec v = (x,y)$，且 $xy \neq 0$，则中间有 $\gcd(x,y)-1$ 个点。

因此不考虑那些坐标轴的平行线，答案是：
$$
\begin{aligned}
 & 2 \sum_{x=1}^n \sum_{y=1}^m \gcd(x,y) (n-x)(m-y) \\
=& 2 \sum_{d=1}^{\min(n,m)} d\sum_{x=1}^n \sum_{y=1}^m [\gcd(x,y) = d] (n-x)(m-y) \\
=& 2 \sum_{d=1}^{\min(n,m)} d\sum_{t=1}^{\lfloor \frac{\min(n,m)}{d} \rfloor} \mu(t) (\sum_{j=1}^{\lfloor \frac{n}{dt} \rfloor} n-dtj)(\sum_{j=1}^{\lfloor \frac{m}{dt} \rfloor} m-dtj)
\end{aligned}
$$
对于本题而言，可以直接枚举 $T=dt$。发现你只需要求解 $f = \mathrm{Id} * \mu$（其中 `*`  是狄利克雷卷积），用类似狄利克雷前缀和的手段可以  $O(n \log \log n)$ 解决。

如果你乐意推复杂的式子，显然可以做到 $O(n \log \log n)$ 预处理，$O(\sqrt n)$ 查询（整除分块）。

但是愚蠢、懒惰而又摆烂的 Purslane 选择使用 $O(n \log n)$ 暴力预处理，$O(n)$ 查询。

```cpp
#include<bits/stdc++.h>
#define int long long
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=50000+10,MOD=1e9+7;
int n,m,mu[MAXN],f[MAXN],flg[MAXN],ans;
void init(int mx) {
	vector<int> pr;
	mu[1]=1;
	ffor(i,2,mx) {
		if(!flg[i]) mu[i]=-1,pr.push_back(i);
		for(auto v:pr) {
			if(i*v>mx) break ;
			flg[i*v]=1;
			if(i%v==0) break ;
			mu[i*v]=-mu[i];
		}
	}
	ffor(x,1,mx) ffor(d,1,mx/x) f[x*d]=(f[x*d]+mu[x]*(d-1))%MOD;
	return ;
}
int calc_seq(int f,int l,int n) {return (f+l)*n/2%MOD;}
signed main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>n>>m,init(min(n,m));
	ffor(T,1,min(n,m)) ans=(ans+f[T]*calc_seq(n%T,n-T,n/T)%MOD*calc_seq(m%T,m-T,m/T))%MOD;
	ans=(ans*2+n*(n-1)*(n-2)/6%MOD*m+m*(m-1)*(m-2)/6%MOD*n)%MOD;
	cout<<(ans%MOD+MOD)%MOD;
	return 0;
}
```

$\rm UPD$：哎，$\mathrm{Id} * \mu = \varphi$。因此不需要狄利克雷前缀和，直接线性筛就好了。。。

---

## 作者：dAniel_lele (赞：0)

考虑枚举首尾两个点之间的跨度，设为 $(i,j)$。不妨设第二个点在第一个点的右上方，第一个点移到 $(0,0)$ 位置。

不难发现 $(0,0)$ 到 $(i,j)$ 直线上的点均满足 $\frac{x}{y}=\frac{i}{j}$，即 $x=k\frac{i}{\gcd(i,j)},y=k\frac{j}{\gcd(i,j)}$。符合要求的 $k$ 取值共有 $\gcd(i,j)-1$ 个。

从原矩形中选出一个 $i\times j$ 的子矩阵共有 $(n-i)(m-j)$ 种方案。

即，原问题答案为 $\sum_{i=1}^n\sum_{j=1}^m(\gcd(i,j)-1)(n-i)(m-j)+(m+1)\binom{n}{3}+(n+1)\binom{m}{3}$。

考虑如何快速计算前面一个式子，可以将式子转化为 $\sum_{k=1}^{\min(n,m)}\varphi(k)\sum_{k|i}(n-i)\sum_{k|j}(m-j)$。可以 $O(n\ln n+m\ln m)$ 算出后两个 $\sum$ 在每个 $k$ 上的答案。总复杂度 $O(n\ln n+m\ln m)$，可以通过。

```cpp
#include <bits/stdc++.h>
#define int long long
#define mid ((l+r)>>1)
#define lowbit(i) (i&(-i))
using namespace std;
const int mod=1e9+7;
int phi[100005],isp[100005],prm[100005],cnt;
int f[100005],g[100005];
int C3(int x){
	return x*(x-1)%mod*(x-2)%mod*((mod+1)/6)%mod;
}
signed main(){
	for(int i=2;i<=100000;i++) isp[i]=1;
	phi[1]=1;
	for(int i=2;i<=100000;i++){
		if(isp[i]) phi[i]=i-1,prm[++cnt]=i;
		for(int j=1;prm[j]*i<=100000&&j<=cnt;j++){
			isp[prm[j]*i]=0;
			if(i%prm[j]==0){
				phi[prm[j]*i]=phi[i]*prm[j];
				break;
			}
			phi[prm[j]*i]=phi[i]*phi[prm[j]];
		}
	}
	int n,m; cin>>n>>m; n--,m--;
	int totf=0;
	for(int i=1;i<=n;i++) f[i]=n-i+1,(totf+=f[i])%=mod;
	for(int i=1;i<=n;i++) for(int j=i*2;j<=n;j+=i) (f[i]+=f[j])%=mod;
	int totg=0;
	for(int i=1;i<=m;i++) g[i]=m-i+1,(totg+=g[i])%=mod;
	for(int i=1;i<=m;i++) for(int j=i*2;j<=m;j+=i) (g[i]+=g[j])%=mod;
	int ans=0;
	for(int i=1;i<=min(n,m);i++) (ans+=f[i]*g[i]%mod*phi[i])%=mod;
	cout<<((ans-totf*totg%mod+mod)%mod*2%mod+C3(n+1)*(m+1)+C3(m+1)*(n+1))%mod;
	return 0;
}
```

---

## 作者：_7thRC_CB_CRP_ (赞：0)

首先考虑他同行同列的组合：

是 $n\binom{m}{3}+m\binom{n}{3}$ 是很显然的吧。

显然，斜率的正负得到的答案是大差不差的，直接乘二，记答案为 $ans$。

$$\therefore Ans=n\binom{m}{3}+m\binom{n}{3}+2ans$$

尝试求解 $ans$。

考虑一条直线上最远点，分别相差 $X,Y$。

那么做过 P1447 的朋友都知道中间点有 $\gcd(i,j)-1$ 种方案。

再加上两点的位置带来的方案数易得：

$$ans=\sum_{i=1}^{n-1}\sum_{j=1}^{m-1} (n-i)(m-i)(\gcd(i,j)-1)$$

套路一下：

$$
\begin{aligned}
ans&=\sum_{d=1}\sum_{i=1}^{\lfloor  \frac {n-1} i\rfloor}\sum_{j=1}^{\lfloor \frac {m-1} i\rfloor}(n-i)(m-j)(d-1)[\gcd(i,j)=1]
\\
&=\sum_{d=1}(d-1)\sum_{i=1}^{\lfloor  \frac {n-1} d\rfloor}\sum_{j=1}^{\lfloor \frac {m-1} d\rfloor}(n-id)(m-jd)\sum_{k \mid \gcd(i,j)} \mu(k)
\\
&=\sum_{d=1}(d-1)\sum_{k=1} \mu(k)\sum_{i=1}^{\lfloor  \frac {n-1} {dk}\rfloor}\sum_{j=1}^{\lfloor \frac {m-1} {dk}\rfloor}(n-idk)(m-jdk)
\\
&=\sum_{d=1}(d-1)\sum_{k=1} \mu(k)\sum_{i=1}^{\lfloor  \frac {n-1} {dk}\rfloor}\sum_{j=1}^{\lfloor \frac {m-1} {dk}\rfloor}(n-idk)(m-jdk)
\\
&=\sum_{d=1}(d-1)\sum_{k=1} \mu(k)\sum_{i=1}^{\lfloor  \frac {n-1} {dk}\rfloor}\sum_{j=1}^{\lfloor \frac {m-1} {dk}\rfloor}(n-idk)(m-jdk)\\
&=\sum_{T}\sum_{k\mid T}\mu(k)(\frac T k-1)\sum_{i=1}^{\lfloor  \frac {n-1} {T}\rfloor}\sum_{j=1}^{\lfloor \frac {m-1} {T}\rfloor}(n-iT)(m-jT)
\\
&=\sum_{T}\left(\sum_{k\mid T}\mu(k)\frac T k-\sum_{k\mid T}\mu(k)\right)\sum_{i=1}^{\lfloor  \frac {n-1} {T}\rfloor}\sum_{j=1}^{\lfloor \frac {m-1} {T}\rfloor}(n-iT)(m-jT)
\\
&=\sum_{T}\left(\varphi(T)-[T=1]\right)\sum_{i=1}^{\lfloor  \frac {n-1} {T}\rfloor}\sum_{j=1}^{\lfloor \frac {m-1} {T}\rfloor}(n-iT)(m-jT)
\end{aligned}
$$

疑似可以做了？对了， $T=1$ 不用枚举。

# Code

```cpp
#include<bits/stdc++.h>
using namespace std;
long long cnt,prim[100001],phi[100001];
bool v[100001]; 
void init(long long n) {
	phi[1]=1;
	for(int i=2;i<=n;i++) {
		if(v[i]==0) prim[++cnt]=i,phi[i]=i-1;
		for(int j=1;j<=cnt&&prim[j]*i<=n;j++) {
			v[prim[j]*i]=1;
			if(i%prim[j]==0) {
				phi[i*prim[j]]=phi[i]*prim[j];
				break;
			}
			phi[i*prim[j]]=phi[i]*phi[prim[j]];
		}	
	} 
}
int main() {
	init(100000);
	long long n,m;
	cin>>n>>m;
	if(n>m) swap(n,m);
	long long ans=0;
	for(int t=2;t<=n;t++) {
		long long tp;
		long long tp1=(n*((n-1)/t)-((n-1)/t)*((n-1)/t+1)/2*t)%1000000007,tp2=(m*((m-1)/t)-((m-1)/t)*((m-1)/t+1)/2*t)%1000000007;
		tp=tp1%1000000007*tp2%1000000007;
		ans+=tp*phi[t]%1000000007;
		ans%=1000000007;
	}
	cout<<((n*m*(m-1)*(m-2)/6)%1000000007+(m*n*(n-1)*(n-2)/6)%1000000007+2*ans%1000000007)%1000000007;
}
```

---


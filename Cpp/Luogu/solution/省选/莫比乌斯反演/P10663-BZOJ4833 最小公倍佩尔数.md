# BZOJ4833 最小公倍佩尔数

## 题目背景

题目来自 BZOJ 2017 年 4 月月赛。

## 题目描述

令 $(1+\sqrt{2})^n=e(n)+\sqrt{2}f(n)$，其中 $e(n),f(n)$ 都是整数，显然有 $(1-\sqrt{2})^n=e(n)-\sqrt{2}f(n)$。令 $g(n)=\operatorname{lcm}(f(1),f(2),\dots,f(n))$。

给定两个正整数 $n,p$，其中 $p$ 是质数，并且保证 $f(1),f(2),\dots,f(n)$ 在模 $p$ 意义下均不为 $0$，请计算 $\sum \limits_{i=1}^n i\times g(i)$ 模 $p$ 的值。

## 说明/提示

对于 $100\%$ 的数据，$1\leq T\leq 210$，$1\leq n\leq 10^6$，$2\leq p\leq 10^9+7$，$\sum n\leq 3\times 10^6$。

## 样例 #1

### 输入

```
5
1 233
2 233
3 233
4 233
5 233```

### 输出

```
1
5
35
42
121```

# 题解

## 作者：_maojun_ (赞：12)

upd 2024.7.24 有点详略不当，被骂了。

---

显然有 $f(0)=0,f(1)=1$。

把 $(1+\sqrt 2)^n$ 展开，可以得到 $f(n)=2f(n-1)+f(n-2)$

这样就可以 $O(n)$ 递推出 $f$。

---

看看怎么更好地表示 $g$。

记全集 $U=\{1,2,\dots,n\}$。

**引理：** 如果 $f(0)=0,f(1)=1,f(n)=af(n-1)+bf(n-2)$，且 $\gcd(a,b)=1$，则 $\gcd(f(x),f(y))=f(\gcd(x,y))$。

**证明：**

>**先证：**$f_{n+m}=f_{n+1}f_m+bf_nf_{m-1}$。
>
>考虑 $\begin{bmatrix}f_{n+1}&f_n\end{bmatrix}=\begin{bmatrix}a&1\\b&0\end{bmatrix}\begin{bmatrix}f_n&f_{n-1}\end{bmatrix}$，$\begin{bmatrix}f_1&f_0\end{bmatrix}=\begin{bmatrix}1&0\end{bmatrix}$。
>
>注意到 $\begin{bmatrix}a&1\\b&0\end{bmatrix}=\begin{bmatrix}f_2&f_1\\bf_1&bf_0\end{bmatrix}$，应当有 $\begin{bmatrix}a&1\\b&0\end{bmatrix}^n=\begin{bmatrix}f_{n+1}&f_n\\bf_n&bf_{n-1}\end{bmatrix}$，归纳一下可以发现是对的。
>
>则有：
>
>$$\begin{aligned}\begin{bmatrix}f_{n+m+1}&f_{n+m}\end{bmatrix}&=\begin{bmatrix}a&1\\b&0\end{bmatrix}^m\begin{bmatrix}f_{n+1}&f_n\end{bmatrix}\\&=\begin{bmatrix}f_{m+1}&f_m\\bf_m&bf_{m-1}\end{bmatrix}\begin{bmatrix}f_{n+1}&f_n\end{bmatrix}\\&=\begin{bmatrix}f_{n+1}f_{m+1}+bf_mf_n&f_{n+1}f_m+bf_nf_{m-1}\end{bmatrix}\end{aligned}$$
>
>回到原命题。
>
>考虑 $\gcd(f_{n+m},f_n)=\gcd(f_{n+1}f_m+bf_nf_{m-1},f_n)=\gcd(f_{n+1}f_m,f_n)$。
>
>显然有 $\gcd(f_1,f_2)=1$，结合 $\gcd(a,b)=1$ 可归纳得到 $\gcd(f_{n+1},f_n)=1$。
>
>于是有 $\gcd(f_{n+m},f_n)=\gcd(f_m,f_n)$，根据辗转相除有 $\gcd(f_{n+m},f_n)=\gcd(f_{\gcd(n+m,n)},f_0)=f_{\gcd(n+m,n)}$。
>
>即 $\gcd(f(x),f(y))=f(\gcd(x,y))$。

这样有 $\gcd\limits_{i\in T}f(i)=f(\gcd(T))$。看起来非常友好。

但是现在 $g$ 是 $\operatorname{lcm}$ 相关的东西，所以我们考虑用点什么东西把它和子集 $\gcd$ 建立联系。

**引理：$\operatorname{lcm}(S)=\prod\limits_{T\subseteq S}\gcd(T)^{(-1)^{|T|-1}}$**

**证明：**

>注意到 $\operatorname{lcm}$ 这个东西相当于对于每个质因数在次数上取 $\max$，$\gcd$ 相当于取 $\min$。
>
>根据 $\min-\max$ 容斥，有：$\max(S)=\sum\limits_{T\subseteq S}\min(T)(-1)^{|T|-1}$。
>
>记 $\operatorname{cnt}_{i,p}$ 为 $i$ 有多少个质因数 $p$。于是有：
>
>$$\begin{aligned}\operatorname{lcm}(S)&=\prod\limits_pp^{\max\limits_{i\in S}\operatorname{cnt}_{i,p}}\\&=\prod\limits_pp^{\sum\limits_{T\subseteq S}\min\limits_{i\in T}\operatorname{cnt}_{i,p}(-1)^{|T|-1}}\\&=\prod\limits_{T\subseteq S}(\prod\limits_pp^{\min\limits_{i\in T}\operatorname{cnt}_{i,p}})^{(-1)^{|T|-1}}\\&=\prod\limits_{T\subseteq S}\gcd(T)^{(-1)^{|T|-1}}\end{aligned}$$

所以：

$$
\begin{aligned}
g(n)&=\prod\limits_{T\subseteq U}(\gcd\limits_{i\in T}f(i))^{(-1)^{|T|-1}}\\
&=\prod\limits_{T\subseteq U}f(\gcd(T))^{(-1)^{|T|-1}}
\end{aligned}
$$

注意，这里的 $\gcd(T)$ 是定义在非空集合上的。所以以上的枚举有一个隐含的 $T$ 非空的条件。

---

考虑怎么快速求。

$$
\begin{aligned}
g(n)&=\prod\limits_{T\subseteq U}f(\gcd(T))^{(-1)^{|T|-1}}\\
&=\prod\limits_{i=1}^nf(i)^{\sum\limits_{T\subseteq U}[\gcd(T)=i](-1)^{|T|-1}}
\end{aligned}
$$

记 $a(i)=\sum\limits_{T\subseteq U}[\gcd(T)=i](-1)^{|T|-1},A(i)=\sum\limits_{i\mid d}a(d)$，定义域都是 $U$。

**引理：$A(i)=1$**

**证明：**

>记 $S_i=\{1,2,\dots,\left\lfloor\dfrac ni\right\rfloor\}$。
>
>则 $A(i)=\sum\limits_{T\subseteq U}[i\mid\gcd(T)](-1)^{|T|-1}=\sum\limits_{T\subseteq S_i,T\ne\varnothing}{(-1)^{|T|-1}}$。
>
>考虑 $\sum\limits_{T\subseteq S}(-1)^{|T|}=\sum\limits_{i=0}^{|S|}{|S|\choose i}(-1)^i=(1-1)^{|S|}=[|S|=0]$。
>
>由于 $i\le n$，有 $|S_i|\ne0$。
>
>于是：
>
>$$\begin{aligned}A(i)&=\sum\limits_{T\subseteq S_i,T\ne\varnothing}{(-1)^{|T|-1}}\\&=-\sum\limits_{T\subseteq S_i,T\ne\varnothing}{(-1)^{|T|}}\\&=-(\sum\limits_{T\subseteq S_i}{(-1)^{|T|}}-(-1)^{|\varnothing|})\\&=-(0-1)=1\end{aligned}$$

那么由莫比乌斯反演，有 $a(i)=\sum\limits_{i\mid d}\mu(\dfrac di)A(d)=\sum\limits_{i\mid d}\mu(\dfrac di)$。

直接暴力求每个 $g$ 还是不太好，可以再带回去推一推。

$$
\begin{aligned}
g(n)&=\prod\limits_{i=1}^nf(i)^{\sum\limits_{T\subseteq U}[\gcd(T)=i](-1)^{|T|-1}}\\
&=\prod\limits_{i=1}^nf(i)^{\sum\limits_{i\mid d}\mu(\frac di)}\\
&=\prod\limits_{d=1}^n\prod\limits_{i\mid d}f(i)^{\mu(\frac di)}
\end{aligned}
$$

最后的式子出奇的简单。$O(n\ln n)$ 求 $s(d)=\prod\limits_{i\mid d}f(i)^{\mu(\frac di)}$ 即可，$g$ 就是 $s$ 的前缀积。

总复杂度 $O(\sum n\ln n)$，可过。

```cpp
typedef long long ll;
const int N=1e6+5;
int mu[N];
inline ll inv(ll x,int p){ll r=1;for(int y=p-2;y;y>>=1,x=x*x%p)if(y&1)r=r*x%p;return r;}

ll f[N],s[N];
int main(){
	mu[1]=1;
	for(int i=1;i<N;i++)
		for(int j=i+i;j<N;j+=i)
			mu[j]-=mu[i];
	int T;scanf("%d",&T);
	for(int n,p;T--;){
		scanf("%d%d",&n,&p);
		f[1]=1;
		for(int i=2;i<=n;i++)f[i]=(2*f[i-1]+f[i-2])%p;
		fill(s+1,s+n+1,1);
		for(int i=1;i<=n;i++){
			ll x=f[i],y=inv(x,p);
			for(int j=i;j<=n;j+=i)
				if(mu[j/i]==1)s[j]=s[j]*x%p;
				else if(mu[j/i])s[j]=s[j]*y%p;
		}
		ll res=0,g=1;
		for(int i=1;i<=n;i++){
			g=g*s[i]%p;
			res=(res+g*i)%p;
		}
		printf("%lld\n",res);
	}
	return 0;
}
```

---

## 作者：WorldMachine (赞：6)

不要矩阵，朴素的小朋友推法。

先发掘 $f$ 的性质，有 $(e_n+\sqrt2f_n)(1+\sqrt2)=(e_n+2f_n)+(e_n+f_n)\sqrt2$，即 $e_{n+1}=e_n+2f_n,f_{n+1}=e_n+f_n$，作差得到 $e_{n+1}=f_{n+1}+f_n$，代入 $f$ 的递推式中可得 $f_{n+1}=2f_n+f_{n-1}$。

现在要求 $g_i=\mathop{\text{lcm}}\limits_{j=1}^i(f_j)$，直接做很烦，考虑使用 **gcd-lcm 反演**，设 $U=\{1,2,\dots,n\}$，那么有：
$$
g_i=\prod_{S\subseteq U\land S\neq\varnothing}\gcd_{j\in S}(f_j)^{(-1)^{|S|-1}}
$$
现在有两个任务：求出若干个 $f$ 的 $\gcd$，以及快速求解上式。

$f$ 是二阶常系数齐次线性递推，猜测其和斐波那契数列类似具有性质 $\gcd(f_n,f_m)=f_{\gcd(n,m)}$，考虑证明。

首先有 $\gcd(f_n,f_{n-1})=\gcd(2f_{n-1}+f_{n-2},f_{n-1})=\gcd(f_{n-1},f_{n-2})$，而 $\gcd(f_1,f_0)=\gcd(1,0)=1$，因此 $f_n\perp f_{n-1}$。

然后需要证明 $f_{n+m}=f_{n+1}f_m+f_nf_{m-1}$，考虑归纳法。对于 $m=1,2$ 显然成立，考虑由 $m-1$ 和 $m$ 推到 $m+1$：
$$
\begin{aligned}
f_{n+m+1}&=2f_{n+m}+f_{n+m-1}\\
&=2(f_{n+1}f_m+f_nf_{m-1})+(f_{n+1}f_{m-1}+f_nf_{m-2})\\
&=f_{n+1}(2f_m+f_{m-1})+f_n(2f_{m-1}+f_{m-2})\\
&=f_{n+1}f_{m+1}+f_nf_m\qquad\square
\end{aligned}
$$
现在来证明上面的性质。有 $\gcd(f_{n+m},f_n)=\gcd(f_{n+1}f_m+f_nf_{m-1},f_n)=\gcd(f_{n+1}f_m,f_n)$，由于 $f_{n+1}\perp f_n$，故原式等于 $\gcd(f_m,f_n)$，这和辗转相除法的形式相同，故可以递归下去直到 $\gcd(f_{\gcd(n,m)},f_0)=f_{\gcd(n,m)}$，得证。

因此有：
$$
g_i=\prod_{S\subseteq U\land S\neq\varnothing}f_{\gcd(S)}^{(-1)^{|S|-1}}
$$
转而枚举 $j=\gcd(S)$：
$$
g_i=\prod_{j=1}^nf_j^{\sum_{\gcd(S)=j}(-1)^{|S|-1}}
$$
考虑指数上那一坨玩意，设其为 $c_j$，套路地使用莫比乌斯反演，有 $\sum\limits_{i\mid j}c_i=\sum\limits_{i\mid\gcd(S)}(-1)^{|S|-1}=-\sum\limits_{i\mid\gcd(S)}(-1)^{|S|}$，而合法的 $S$ 是 $\left\{i,2i,\dots,\left\lfloor\dfrac ni\right\rfloor i\right\}$ 的**非空**子集，故原式即为 $-((1+(-1))^{\lfloor n/i\rfloor}-1)=1$，由反演得 $c_i=\sum\limits_{i\mid j}\mu\left(\dfrac ji\right)$。

代回原式：
$$
g_i=\prod_{j=1}^nf_j^{\sum_{j\mid k}\mu(\frac kj)}=\prod_{k=1}^n\prod_{j\mid k}f_j^{\mu(\frac kj)}
$$
设 $G_i=\prod\limits_{d\mid i}f_d^{\mu(\frac id)}$，这个可以 $\mathcal O(n\log n)$ 枚举倍数求出，也可以用 Dirichlet 差分的方式做到 $\mathcal O(n\log\log n)$，$g$ 就是 $G$ 的前缀积。

只写了 $\log$ 做法。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define il __always_inline
typedef long long ll;
const int N = 1e6 + 5;
int T, n, p, tot, pri[N], fac[N], mu[N], f[N], g[N];
struct { ll p, m; void init(int P) { p = P, m = ((__int128)1 << 64) / p; } il ll operator()(ll x) { return x - ((__int128)x * m >> 64) * p; } } mod;
il int qpow(int a, int b) { int c = 1; while (b) { if (b & 1) c = mod((ll)c * a); a = mod((ll)a * a), b >>= 1; } return c; }
void sieve(int n) {
	mu[1] = 1;
	for (int i = 2; i <= n; i++) {
		if (!fac[i]) pri[++tot] = fac[i] = i, mu[i] = -1;
		for (int j = 1, k; j <= tot && (k = i * pri[j]) <= n; j++) {
			fac[k] = pri[j]; if (fac[i] == pri[j]) { mu[k] = 0; break; } mu[k] = -mu[i];
		}
	}
}
void solve() {
	cin >> n >> p, mod.init(p), f[1] = 1;
	for (int i = 2; i <= n; i++) f[i] = mod(f[i - 1] * 2ll + f[i - 2]);
	for (int i = 0; i <= n; i++) g[i] = 1;
	for (int i = 1; i <= n; i++) {
		int iv = qpow(f[i], p - 2);
		for (int j = i, k = 1; j <= n; j += i, k++) {
			if (mu[k] == 1) g[j] = mod((ll)g[j] * f[i]);
			else if (mu[k] == -1) g[j] = mod((ll)g[j] * iv);
		}
	}
	int ans = 0;
	for (int i = 1; i <= n; i++) ans = mod(ans + (ll)i * (g[i] = mod((ll)g[i] * g[i - 1])));
	cout << ans % p << '\n';
}
int main() { sieve(1e6), ios::sync_with_stdio(0), cin.tie(0), cout.tie(0), cin >> T; while (T--) solve(); }
```

---

## 作者：white_tiger_yyyy (赞：3)

[博客食用更佳。](https://www.cnblogs.com/chang-an-22-lyh/p/18688574/bzoj4833-zui_xiao_gong_bei_pei_er_shu-tj)

在这篇题解中，我会将各个部分的证明分成不同的推导过程，以达到逐一击破的效果。
# 引理 1：$f(n)=2f(n-1)+f(n-2)$
我的证明挺繁琐的，过程如下：
$$(1+\sqrt 2)^{n-2}=e(n-2)+f(n-2)\sqrt 2$$
$$(1+\sqrt 2)^{n-1}=e(n-1)+f(n-1)\sqrt 2$$
$$(1+\sqrt 2)^{n-1}=(1+\sqrt 2)^{n-2}(1+\sqrt 2)$$
$$=(e(n-2)+2f(n-2))+(e(n-2)+f(n-2))\sqrt 2$$
$$e(n-1)=e(n-2)+2f(n-2),f(n-1)=e(n-2)+f(n-2)$$
$$f(n)=e(n-1)+f(n-1)=2(e(n-2)+f(n-2))+f(n-2)$$
$$f(n)=2f(n-1)+f(n-2)$$
那么递推式有了，如何和 $\operatorname{lcm}$ 扯上关系呢？
# 引理 2：$f(n+m)=f(n+1)f(m)+bf(n)f(m-1)$
这个引理的完整描述过程如下：
> 如果 $f(0)=0,f(1)=1,f(n)=af(n-1)+bf(n-2)$，且 $\gcd(a,b)=1$，则有 $\gcd(f(x),f(y))=f(\gcd(x,y))$。

考虑这个东西长得和个兔子数列似的，于是给他弄个转移矩阵。容易发现有：
$$\begin{bmatrix}f(n+1)\ \ f(n)\end{bmatrix}=\begin{bmatrix}a\ \ 1\\b\ \ 0\end{bmatrix}\begin{bmatrix}f(n)\ \ f(n-1)\end{bmatrix}$$
这个转移矩阵是不平凡的：
$$\begin{bmatrix}f(n+1)\ \ f(n)\\bf(n)\ \ bf(n-1)\end{bmatrix}\begin{bmatrix}a\ \ 1\\b\ \ 0\end{bmatrix}=\begin{bmatrix}af(n+1)+bf(n)\ \ f(n+1)\\bf(n+1)\ \ bf(n)\end{bmatrix}=\begin{bmatrix}f(n+2)\ \ f(n+1)\\bf(n+1)\ \ bf(n)\end{bmatrix}$$
$$\begin{bmatrix}a\ \ 1\\b\ \ 0\end{bmatrix}^1=\begin{bmatrix}f(2)\ \ f(1)\\bf(1)\ \ bf(0)\end{bmatrix},\begin{bmatrix}a\ \ 1\\b\ \ 0\end{bmatrix}^n=\begin{bmatrix}f(n+1)\ \ f(n)\\bf(n)\ \ bf(n-1)\end{bmatrix}$$
那么就有：
$$\begin{bmatrix}f(n+m+1)\ \ f(n+m)\end{bmatrix}=\begin{bmatrix}a\ \ 1\\b\ \ 0\end{bmatrix}^m\begin{bmatrix}f(n+1)\ \ f(n)\end{bmatrix}$$
$$=\begin{bmatrix}f(m+1)\ \ f(m)\\bf(m)\ \ bf(m-1)\end{bmatrix}\begin{bmatrix}f(n+1)\ \ f(n)\end{bmatrix}$$
$$=\begin{bmatrix}f(n+1)f(m+1)+bf(m)f(n)\ \ f(n+1)f(m)+bf(n)f(m-1)\end{bmatrix}$$
引理 1 得证。
# 引理 3：$\gcd(f(x),f(y))=f(\gcd(x,y))$
显然有：
$$\gcd(f(n+m),f(n))=\gcd(f(n+1)f(m)+bf(n)f(m-1),f(n))$$
$$\gcd(f(n+m),f(n))=\gcd(f(n+1)f(m),f(n))$$
若 $\gcd(f(n-1),f(n-2))=1$，则有：
$$\gcd(f(n),f(n-1))=\gcd(af(i-1)+bf(n-2),f(n-1))=1$$
由于 $\gcd(f(1),f(0))=1$，所以 $\gcd(f(n),f(n-1))=1$。

所以 $\gcd(f(n+m),f(n))=\gcd(f(m),f(n))$。

我们从辗转相除的角度化简，可以得到：

$$\gcd(f(n+m),f(n))=\gcd(f(\gcd(n+m,n)),f(0))$$
$$=f(\gcd(n+m,n))=f(\gcd(m,n))=\gcd(f(m),f(n))$$
# 引理 4：$\operatorname{lcm}(S)=\prod\limits_{T\subseteq S}\gcd(T)^{(-1)^{|T|-1}}$
特殊说明一下，$S,T$ 为非空集合。

注意力惊人的注意到：
$$\operatorname{lcm}(S)=\prod_{p\in prime}p^{\max\limits_{i\in S}cnt_{i,p}}$$
$$\gcd(S)=\prod_{p\in prime}p^{\min\limits_{i\in S}cnt_{i,p}}$$
其中 $cnt_{i,p}$ 表示 $i$ 中 $p$ 这个质因子的个数。

想到最值反演。那么有：
$$\operatorname{lcm}(S)=\prod_{p\in prime}p^{\max\limits_{i\in S}cnt_{i,p}}$$
$$\operatorname{lcm}(S)=\prod_{p\in prime}p^{\sum\limits_{T\subseteq S}\min\limits_{i\in T}cnt_{i,p}(-1)^{|T|-1}}$$
$$\operatorname{lcm}(S)=\prod_{T\subseteq S}(\prod_{p\in prime}p^{\min\limits_{i\in T}cnt_{i,p}})^{(-1)^{|T|-1}}$$
$$\operatorname{lcm}(S)=\prod_{T\subseteq S}\gcd(T)^{(-1)^{|T|-1}}$$
# $g(n)$ 的第一推导
设 $U=\{1,2,\dots,n\}$，则有：
$$g(n)=\prod_{T\subseteq U}(\gcd\limits_{i\in T}f(i))^{(-1)^{|T|-1}}$$
$$g(n)=\prod_{T\subseteq U}f(\gcd(T))^{(-1)^{|T|-1}}$$
看到 $\gcd$，想到莫比乌斯反演：
$$g(n)=\prod_{i=1}^nf(i)^{\sum\limits_{T\subseteq U}[\gcd(T)=i](-1)^{|T|-1}}$$
记 $h(i)=\sum\limits_{T\subseteq U}[\gcd(T)=i](-1)^{|T|-1},H(i)=\sum\limits_{i|d}h(d)$，我们就要开启下一部分了。
# 引理 5：$H(i)=1$
设 $S_i=\{1,2,\dots,\lfloor\dfrac ni\rfloor\}$（显然 $|S|>0$），$T$ 仍然是非空集合，则有：
$$H(i)=\sum_{i|d}\sum_{T\subseteq U}[\gcd(T)=d](-1)^{|T|-1}$$
$$=\sum_{T\subseteq U}[i|\gcd(T)](-1)^{|T|-1}$$
$$=\sum_{T\subseteq S_i}(-1)^{|T|-1}=-\sum_{T\subseteq S_i}(-1)^{|T|}$$
$$=-(\sum_{i=0}^{|S_i|}\binom{|S|}i(-1)^i-1)$$
$$=-(1-1)^{|S_i|}+1=1$$
# $g(n)$ 的最终推导
根据莫比乌斯反演，有：
$$h(i)=\sum_{i|d}\mu(\frac di)H(d)=\sum_{i|d}\mu(\frac di)$$
带回 $g(n)$ 中，得：
$$g(n)=\prod_{i=1}^nf(i)^{\sum\limits_{i|d}\mu(\frac di)}$$
$$g(n)=\prod_{d=1}^n\prod_{i|d}f(i)^{\mu(\frac di)}$$
很好算。时间复杂度 $O(\sum n\log n)$。
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e6+5;
int t,n,p,mu[N],f[N],s[N];
int qpow(int x,int y){
    int re=1;
    while(y){
        if(y&1) re=re*x%p;
        x=x*x%p,y>>=1;
    }return re;
}signed main(){
    ios::sync_with_stdio(0);
    cin.tie(0),cout.tie(0);
    cin>>t,mu[1]=1;
    for(int i=1;i<N;i++)
        for(int j=i*2;j<N;j+=i) mu[j]-=mu[i];
    while(t--){
        cin>>n>>p,f[1]=s[1]=1;
        for(int i=2;i<=n;i++)
            f[i]=(f[i-1]*2+f[i-2])%p,s[i]=1;
        for(int i=1;i<=n;i++){
            int x=f[i],y=qpow(x,p-2);
            for(int j=i,k=1;j<=n;j+=i,k++)
                s[j]=s[j]*(!mu[k]?1:mu[k]>0?x:y)%p;
        }int re=0,g=s[1];
        for(int i=1;i<=n;)
            re=(re+g*i)%p,g=g*s[++i]%p;
        cout<<re<<"\n";
    }return 0;
}
```

---

## 作者：keatsli (赞：2)

类似于其他的题解，可以推出：

$$ANS=\sum\limits_{k=1}^nk\prod\limits_{i=1}^k\prod\limits_{d\mid i}f_d^{\mu(\frac{i}{d})}$$

其中 $f_d$ 是已知的数列。

接下来考虑怎么快速求这个柿子：

令 $g_i=\prod\limits_{d\mid i}f_d^{\mu(\frac{i}{d})}$，则 $ANS=\sum\limits_{k=1}^nk\prod\limits_{i=1}^k g_i$，可以通过求 $g_i$ 的前缀积 $O(n)$ 求出。

接下来问题转化为如何求 $g_i$：

$$g_i=\prod\limits_{d\mid i}f_d^{\mu(\frac{i}{d})}$$

考虑一个 $f_i$ 是如何为 $g_j$ 贡献：

对任意 $\prod p_i$ 满足 $p_i$ 都是质数且互不相同，那么 $f_i$ 可以贡献到 $g_{(i\prod p_i)}$。

于是考虑高维前缀和：

最开始 $g_i=f_i$。

对每个质数 $p$ 考虑，倒着将 $g_i^{-1}$ 乘到 $g_{i\cdot p}$ 上。

这里逆元可以同时维护出来，最开始的逆元可以用离线 $O(n)$ 逆元预处理。

因为只对质数的倍数考虑，故单次查询总复杂度为 $O(n\log\log n)$。

code：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,pr[1000010],cnt,p,f[1000010],finv[1000010],qzinv[1000010];
bitset<1000010>vis;
#define ll long long
#define lll __int128
lll P;
int M(int x){return x>=p?x-p:x;}
ll D(ll x){return x*P>>62;}
int M1(ll x){return x-D(x)*p;}
ll qp(ll a,ll b,ll r=1){for(;b;a=M1(a*a),b>>=1)if(b&1)r=M1(r*a);return r;}
int main(){
	int T;cin>>T,f[1]=finv[1]=1;
	for(int i=2;i<=1e6;++i){
		if(!vis[i])pr[++cnt]=i;
		for(int j=1;j<=cnt&&i*pr[j]<=1e6;++j){
			vis[i*pr[j]]=1;
			if(!(i%pr[j]))break;
		}
	}
	while(T--){
		cin>>n>>p,P=(lll(1)<<62)/p+1;
		for(int i=2;i<=n;++i)f[i]=M(f[i-2]+M(f[i-1]<<1)),finv[i]=M1(1ll*finv[i-1]*f[i]);
		qzinv[n]=qp(finv[n],p-2);
		for(int i=n-1;i>=1;--i)qzinv[i]=M1(1ll*qzinv[i+1]*f[i+1]),finv[i+1]=M1(1ll*finv[i]*qzinv[i+1]);
		for(int i=1;i<=cnt&&pr[i]<=n;++i){
			const int P=pr[i];
			for(int j=n/P;j>=1;--j)f[j*P]=M1(1ll*f[j*P]*finv[j]),finv[j*P]=M1(1ll*finv[j*P]*f[j]);
		}
		ll r=0,p=1;
		for(int i=1;i<=n;++i)p=M1(p*f[i]),r=M(r+M1(1ll*i*p));
		cout<<r<<'\n';
	}
	return 0;
}
```

~~闲话：即使努力卡常还是被最优解匿名用户薄纱，强如怪物，不可战胜。~~

---

## 作者：TH911 (赞：1)

> [题目传送门](https://www.luogu.com.cn/problem/P10663)
>
> [广告](https://www.cnblogs.com/TH911/p/-/P10663)

# gcd-lcm 容斥

所谓 gcd-lcm 容斥，即对于集合 $T$，有：

$$
\operatorname*{lcm}_{i\in T}i=\prod_{S\subseteq T}\left(\gcd_{i\in S}i\right)^{(-1)^{\vert S\vert-1}}
$$

:::info[证明]
不妨考虑 $i$ 的质因子。发现对于质数 $p$，有：

$$
        \begin{aligned}
        \operatorname{lcm}\left(p^a,p^b\right)&=p^{\max(a,b)}\\
        \gcd\left(p^a,p^b\right)&=p^{\min(a,b)}\\
        \end{aligned}
        $$

类似的套用 Min-max 容斥可以得到指数间关系，化简即可得到上式。
:::

考虑 $g(n)=\operatorname{lcm}(f(1),f(2),\cdots,f(n))$ 并不好处理，因为 $\operatorname{lcm}$ **不可模**。

因此考虑转化，记 $T=\set{1,2,3,\cdots,n}$，有：

$$
\begin{aligned}
g(n)&=\operatorname{lcm}(f(1),f(2),\cdots,f(n-1),f(n))\\
&=\operatorname*{lcm}_{i\in T}f(i)\\
&=\prod_{S\subseteq T}\left(\gcd_{i\in S}f(i)\right)^{(-1)^{\vert S\vert-1}}\\
\end{aligned}
$$

# 递推数列性质

考虑 $f(i)$。显然，$f(0)=0,f(1)=1$。

因为 $\left(1+\sqrt2\right)^n=e(n)+f(n)$，通过~~打表观察~~数学分析可以得到：

$$
f(n)=2f(n-1)+f(n-2)\\
$$

扩域模拟计算，可得：

$$
\left(e(n)+f(n)\sqrt2\right)\left(1+\sqrt2\right)=(e(n)+2f(n))+(e(n)+f(n))\sqrt2
$$

进而可推出：

$$
e(n)=e(n-1)+2f(n-1)\\
f(n)=e(n-1)+f(n-1)
$$

递归代入，可得：

$$
\begin{aligned}
f(n)&=f(n-1)+2\sum_{i=1}^{n-2}f(i)\\
&=f(n-1)+2f(n-2)+\sum_{i=1}^{n-3}f(i)\\
&=2f(n-1)+(n-2)
\end{aligned}
$$

可以发现，这是一个类似于斐波那契数列的线性递推数列，同样具有一些广义斐波那契数列的美妙性质。

有：

$$
\gcd(f(i),f(j))=f(\gcd(i,j))
$$

[证明请参见我的 Blog](https://cnblogs.com/TH911/p/-/Combinatorics#性质)。因为本人认为 OI 范围内写数学相关题目，常用性质证明过程并不重要。

# 莫比乌斯反演

根据我们得到的 $f$ 的性质，有：

$$
\begin{aligned}
g(n)&=\prod_{S\subseteq T}\left(\gcd_{i\in S}f(i)\right)^{(-1)^{\vert S\vert-1}}\\
&=\prod_{S\subseteq T}\left(f\left(\gcd_{i\in S}i\right)\right)^{(-1)^{\vert S\vert-1}}
\end{aligned}
$$

$\gcd$ 相关信息，考虑**莫比乌斯反演**。

先套路地枚举 $\gcd\limits_{i\in S}i$ 算贡献：
$$
\begin{aligned}
g(n)&=\prod_{S\subseteq T}\left(f\left(\gcd_{i\in S}i\right)\right)^{(-1)^{\vert S\vert-1}}\\
&=\prod_{d=1}^nf(d)^{\sum\limits_{S\subseteq T}\left[\gcd\limits_{i\in S}i=d\right](-1)^{(\vert S\vert-1)}}\\
\end{aligned}
$$

记：

$$
\begin{aligned}
h(d)&=\sum\limits_{S\subseteq T}\left[\gcd\limits_{i\in S}i=d\right](-1)^{\vert S\vert-1}\\
H(i)&=\sum_{i\mid d}h(d)
\end{aligned}
$$

则根据莫比乌斯变换，有：

$$
h(i)=\sum_{i\mid d}\mu\left(\dfrac di\right)H(i)
$$

同理，通过~~打表观察~~数学分析，我们可以惊喜地发现 $H(i)=1$ **恒成立**。

取集合 $L=\left\lbrace1,2,3,\cdots,\left\lfloor\dfrac nd\right\rfloor\right\rbrace$。

考虑到：

$$
\begin{aligned}
H(i)&=\sum_{i\mid d}h(d)\\
&=\sum_{A\subseteq L,A\neq\varnothing}(-1)^{\vert A\vert-1}\\
&=-\left(\sum_{A\subseteq L}(-1)^{\vert A\vert}-1\right)\\
&=-(0-1)\\
&=1
\end{aligned}
$$

因此有：

$$
h(i)=\sum_{i\mid d}\mu\left(\dfrac di\right)
$$


# 最终推导

我们终于得到了 $g(n)$：

$$
\begin{aligned}
g(n)&=\prod_{d=1}^n\prod_{i\mid d}f^{\mu\left(\frac di\right)}(d)\\
&=g(n-1)\prod_{i\mid n}f^{\mu\left(\frac ni\right)}(n)
\end{aligned}
$$

预处理可以做到 $\mathcal O(n\log n)$。

# AC 代码

```cpp
//#include<bits/stdc++.h>
#include<algorithm>
#include<iostream>
#include<cstring>
#include<iomanip>
#include<cstdio>
#include<string>
#include<vector>
#include<cmath>
#include<ctime>
#include<deque>
#include<queue>
#include<stack>
#include<list>
using namespace std;
typedef __int128 lll;
typedef long long ll;
constexpr const int N=1e6;
int n,P;
int g[N+1],f[N+1],mu[N+1],s[N+1];
//a+b\sqrt2
struct special{
	lll a,b;
};
special operator *(const special &x,const special &y){
	return {(1ll*x.a*y.a+2ll*x.b*y.b)%P,(1ll*x.a*y.b+1ll*x.b*y.a)%P};
}
special& operator *=(special &x,const special &y){
	return x=x*y;
}
int qpow(int base,int n){
	int ans=1;
	while(n){
		if(n&1){
			ans=1ll*ans*base%P;
		}
		base=1ll*base*base%P;
		n>>=1;
	}
	return ans;
} 
void pre(){
	static int vis[N+1],prime[N+1],size;
	mu[1]=1;
	for(int i=2;i<=N;i++){
		if(!vis[i]){
			vis[i]=i;
			prime[++size]=i;
			mu[i]=-1;
		}
		for(int j=1;j<=size&&i*prime[j]<=N;j++){
			vis[i*prime[j]]=prime[j];
			if(i%prime[j]==0){
				break;
			}
			mu[i*prime[j]]=-mu[i];
		}
	}
}
int main(){
	/*freopen("test.in","r",stdin);
	freopen("test.out","w",stdout);*/
	
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	
	pre();
	int T;
	cin>>T;
	while(T--){
		cin>>n>>P;
		special x={1,0};
		for(int i=1;i<=n;i++){
			x*={1,1};
			f[i]=x.b;
		}
		int ans=0;
		g[0]=1;
		fill(s+1,s+n+1,1);
		for(int d=1;d<=n;d++){
			int inv=qpow(f[d],P-2);
			for(int t=1;d*t<=n;t++){
				switch(mu[t]){
					case 1:
						s[d*t]=1ll*s[d*t]*f[d]%P;
						break;
					case -1:
						s[d*t]=1ll*s[d*t]*inv%P;
				}
			}
		}
		for(int i=1;i<=n;i++){
			g[i]=1ll*g[i-1]*s[i]%P;
			ans=(ans+1ll*i*g[i])%P;
		}
		cout<<ans<<'\n';
	}
	
	cout.flush();
	
	/*fclose(stdin);
	fclose(stdout);*/
	return 0;
}
```

---

## 作者：_7thRC_CB_CRP_ (赞：1)

### $f$ 的性质

首先我们先用简单归纳法看一下 $f$ 有什么性质。

$$
\begin{aligned}
(1-\sqrt 2)^n&=(1-\sqrt 2)^{n-1}(1-\sqrt 2)
\\
e(n)+\sqrt 2f(n)&=(e(n-1)+\sqrt 2f(n-1))(1-\sqrt 2)
\\
e(n)+\sqrt 2 f(n)&=(e(n-1)-2f(n-1))+\sqrt 2(f(n-1)-e(n-1))
\end{aligned}
\\
\Rightarrow 
\begin{cases}
e(n)=e(n-1)-2f(n-1)\\
f(n)=f(n-1)-e(n-1)
\end{cases}
$$

我们所求的是 $f$ 所以尝试将带 $e$ 的式子代掉，发现有一点递归的样子。

$$
\begin{aligned}
f(n)&=f(n-1)+2\sum_{i=1}^{n-2}f(i)
\\
&=f(n-1)+f(n-2)+f(n-2)+2\sum_{i=1}
^{n-3} f(i)
\\
&=f(n-1)+f(n-2)+f(n-1)
\\
&=2f(n-1)+f(n-2)
\end{aligned}
$$

### $\min-\max$ 容斥改为 $\gcd$ 形式。

由于 $\text{lcm}$ 特别不顺眼，把它化成 $\gcd$ 的形式，并且注意到一件事：$\gcd$ 是 $\min$，而 $\text{lcm}$ 正是 $\max$，这其实我们可以进行 $\min-\max$ 容斥，此时一般令全集为 $T$，子集 $S$。

$$
\begin{aligned}
\text{lcm}(f(1),f(2),f(3),\cdots,f(n))&=\prod_{p}p^{max_{i=1}^{n}q_{f_i}}
\\
&=\prod_{p}p^{\sum_{S\subseteq T}(-1)^{\mid U\mid-1}\min(S)}(\because min-max)
\\
&=\prod_{S\subseteq T}(\prod_{p}p^{\min(S)})^{(-1)^{\mid U\mid-1}}
\\
&=\prod_{S\subseteq T} \gcd(S)^{(-1)^{\mid U\mid-1}}
\end{aligned}

$$

### 对于关于该数列的结论辅助计算

为了计算 $f$ 提出一个结论：

$$\gcd(f(a),f(b))=f(\gcd(a,b))$$

证明：

$$
\because f(m)=f(m-n-1)f(n)+f(m-n)f(n+1)\\
\therefore \gcd(f(n),f(m))=\gcd(f(n),f(m-n-1)f(n)+f(m-n)f(n+1))\\
$$

第一个式子对所以广义斐波拉契数列使用，可以通过归纳得，这里就不列举。

这个时候用欧几里得定理。

$$
\gcd(f(n),f(m-n-1)f(n)+f(m-n)f(n+1)=\gcd(f(n),f(m-n)f(n+1))
$$

（相当于减了若干个 $f(n)$）

先证一个引理：

$$
\gcd(f(n),f(n+1))=1\\
\begin{aligned}
\gcd(f(n),f(n+1))&=\gcd(f(n),f(n+1)-f(n))
\\
&=\cdots
\\
&=\gcd(f(1),f(2))
\\
&=1
\end{aligned}
$$

那么我们还可以借此消掉 $f(n+1)$，那么：

$$
\gcd(f(n),f(m))=\gcd(f(n),f(m-n))
$$

一眼望去，那就是在自变量上的 $\gcd$。太棒了！

我们就可证得 $\gcd(f(n),f(m))=f(\gcd(n,m))$

那么我们定义集合 $P=\{1,2,\cdots,n\}$

那么就有：

$$
\prod_{i=1} ^n f(i)^{\sum_{U\subseteq P}[\gcd(U)=i](-1)^{\mid U\mid-1}}
$$

那么我们很容易就可以归纳得：

$$
\prod_{d=1}^n f(d)^{\sum_{i\mid n}\mu(i)}
$$
然后代入要求的式子，就可以推得。

$$
\prod_{d=1}^n\prod_{i\mid d}f(i)^{\mu(\frac d i)}
$$

然后就可以暴力的跑起来了。

```cpp
#include<bits/stdc++.h>
using namespace std;
long long cnt,prim[1000001],mu[1000001],f[1000001];
long long g[1000001];
bool v[1000001];
void init(long long n) {
	mu[1]=1;
	for(int i=2;i<=n;i++) {
		if(!v[i]) prim[++cnt]=i,mu[i]=-1;
		for(int j=1;j<=cnt&&prim[j]*i<=n;j++) {
			v[i*prim[j]]=1;
			if(i%prim[j]==0) {
				mu[i*prim[j]]=0;
				break;
			}
			mu[i*prim[j]]=-mu[i];
		}
	}
}
long long qpow(long long a,long long b,long long p) {
	b=b+p-1;
	b%=(p-1);
	long long res=1;
	while(b) { 
		if(b&1) res*=a,res%=p;
		a=a*a%p;
		b>>=1;
	}
	return res;
}
int main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	init(1000000); 
	long long t;
	cin>>t;
	while(t--) {
		long long n,p;
		cin>>n>>p;
		f[0]=0,f[1]=1;
		for(int i=2;i<=n;i++)
			f[i]=f[i-1]*2+f[i-2],f[i]%=p;
		for(int i=1;i<=n;i++)
			g[i]=1;
		for(int i=1;i<=n;i++) {
			long long x=qpow(f[i],p-2,p);
			for(int j=i;j<=n;j+=i) {
				if(mu[j/i]==1) g[j]=g[j]*f[i]%p;
				else if(mu[j/i]==-1) g[j]=g[j]*x%p;
			}
		}
		long long ans=0;
		long long op=1;
		for(int i=1;i<=n;i++) {
			op=op*g[i]%p;
			ans+=op*i%p;
			ans%=p;
		}
		cout<<ans<<endl;
	}
	return 0;
}

```

---

## 作者：Purslane (赞：1)

# Solution

容易发现 $f(n) = \dfrac{(1+\sqrt 2)^n - (1 - \sqrt 2)^n}{2 \sqrt 2}$。

经常学数竞的同学容易发现，上面两个幂的底数都是代数整数，我们很容易整理出一个关于 $f$ 的二阶齐次线性递推：$f(n) = 2 f(n-1) + f(n-2)$，其中 $n \ge 3$。

-----

有一个常用的 $\rm GCD - LCM$ 反演（实际上就是 $\rm Min-Max$ 容斥）：

$$
\text{lcm}(a_1,a_2,\dots,a_n) = \prod_{S \subseteq \{1,2,\dots,n\}} (\gcd_{u \in S} a_u)^{(-1)^{|S|-1}} 
$$

对每个质数分开考虑就是 $\rm Min-Max$ 容斥。[这还有一道例题](https://www.luogu.com.cn/problem/P3598)。

考虑如何刻画 $\gcd_{u \in S} f(u)$？

-----

斐波那契数列的递推式和 $f$ 很像，而且有 $fib(\gcd(a,b)) = \gcd(fib(a),fib(b))$ 这一经典重要性质。我们推测 $f$ 也有这个性质。

考虑递推的转移矩阵有 $\left[\begin{matrix}2 &1 \\1 &0 \end{matrix} \right]^n = \left[\begin{matrix}f(n+1) & f(n) \\f(n) & f(n-1) \end{matrix} \right]$，那么应当有

$$\left[\begin{matrix} f(a) & f(a-1) \end{matrix}\right]\left[\begin{matrix}2 &1 \\1 &0 \end{matrix} \right]^{b-a} = \left[ \begin{matrix} f(b) & f(b-1)\end{matrix}\right] $$

即 

$$f(b) = f(a)f(b-a-1) + f(a-1) f(b-a)$$

则 

$$\gcd(f(a),f(b)) = \gcd(f(a),f(a-1)f(b-a))$$

根据归纳法易得 $\gcd(f(a),f(b))=1$，有 $\gcd(f(a),f(b)) = \gcd(f(a),f(b-a))$。

根据辗转相除法，即得。

> 一般的，形如 $f(n) = k f(n-1) + f(1)$，$k \in \mathbb Z$ 的递推，若 $f(1) = 1$，$f(2) = k$，则 $\gcd(f(a),f(b)) = f(\gcd(a,b))$ 就成立。

-----

下面开始劲爆莫比乌斯反演。

套用上述公式和莫比乌斯反演的公式易得

$$
g(n)=\prod_{d=1}^n f(d)^{\sum_{t=1}^{\lfloor\frac{n}{d}\rfloor} \mu(t)}
$$
考虑 $\dfrac{g(n)}{g(n-1)}$，显然就等于

$$
\prod_{d \mid n} f(d)^{\mu(\frac{n}{d})}
$$

枚举所有使得 $\mu(\dfrac{n}{d})$ 有值的 $d$ 即可（其实可以枚举 $n$ 的所有因子，但是这样做会使得常数更大）

复杂度 $O(n \ln n)$，常数略大。

```cpp
#include<bits/stdc++.h>
#define int long long
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=1e6+10;
int tc,n,p,pw[MAXN],f[MAXN],inv[MAXN],mu[MAXN],flg[MAXN],cnt[MAXN],g[MAXN];
vector<int> vc;
int qpow(int base,int p,int MOD) {
	int ans=1;
	while(p) {
		if(p&1) ans=ans*base%MOD;
		base=base*base%MOD,p>>=1;
	}
	return ans;
}
void init(int mx) {
	mu[1]=1;
	ffor(i,2,mx) {
		if(!flg[i]) vc.push_back(i),mu[i]=-1;
		for(auto v:vc) {
			if(i*v>mx) break ;
			flg[i*v]=1;
			if(i%v==0) break ;
			mu[i*v]=-mu[i];
		}
	}
	return ;
}
signed main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	init(1000000);
	vc.clear();
	ffor(i,1,1000000) if(mu[i]) vc.push_back(i);
	cin>>tc;
	while(tc--) {
		cin>>n>>p;
		f[1]=1,f[2]=2;
		ffor(i,3,n) f[i]=(2*f[i-1]+f[i-2])%p;
		ffor(i,1,n) inv[i]=qpow(f[i],p-2,p);
		ffor(i,0,n) g[i]=1;
		ffor(d,1,n) {
			int lim=n/d;
			for(auto id:vc) {
				if(id>lim) break ;
				int Id=id*d;
				if(mu[id]==1) g[Id]=g[Id]*f[d]%p;
				else g[Id]=g[Id]*inv[d]%p;	
			}
		}
		ffor(i,1,n) g[i]=g[i-1]*g[i]%p;
		int ans=0;
		ffor(i,1,n) ans=(ans+i*g[i])%p;
		cout<<ans<<'\n';
	}
	return 0;
}
```

本题完整的输入，可以用来调试：[Link](https://www.luogu.com.cn/paste/a0bnjwsk)

---


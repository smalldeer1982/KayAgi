# BZOJ4174 tty 的求助

## 题目描述

计算下式对 $998244353$ 取模的值，其中 $x$ 为实数，其余参与运算的变量均为整数：

$$\sum_{n=1}^N \sum_{m=1}^M \sum_{k=0}^{m-1} \lfloor \dfrac{nk+x}{m}\rfloor$$

## 说明/提示

数据保证，$1\leq N,M\leq 500000$，$0<x\leq 100000$，$x$ 精确到小数点后 $8$ 位小数。

## 样例 #1

### 输入

```
2 3 1 ```

### 输出

```
7```

# 题解

## 作者：Inui_Sana (赞：3)

感觉我的做法更魔怔一点。

下取整显然不好搞。于是考虑套路化地变成 $\sum\limits_{i=1}^n\sum\limits_{j=1}^m\sum\limits_{k=0}^{j-1}\frac{ik+x-(ik+x)\bmod j}{j}$。$\frac{ik+x}{j}$ 部分是好处理的，接下来就只考虑 $\frac{(ik+x)\bmod j}{j}$。

注意到 $k$ 取遍 $[0,j-1]$，所以根据 $\gcd(i,j)$ 相同的 $i$，$\sum\limits_{k=0}^{j-1}\frac{(ik+x)\bmod j}{j}$ 是一样的，而这部分可以 $O(1)$ 算。于是先枚举 $j,\gcd(i,j)$ 再推式子。

$$\sum\limits_{i=1}^n\sum\limits_{k=0}^{j-1}(ik+x)\bmod j$$

$$=\sum\limits_{l|j}\sum\limits_{i=1}^n[\gcd(i,j)=l]l\sum\limits_{k=0}^{\frac{j}{l}-1}(kl+x)\bmod j$$

然后套路莫反。

$$=\sum\limits_{l|j}\sum\limits_{i=1}^n\sum\limits_{dl|i,dl|j}\mu(d)l\sum\limits_{k=0}^{\frac{j}{l}-1}(kl+x)\bmod j$$

再把 $d$ 往前提。

$$=\sum\limits_{l|j}\sum\limits_{d|\frac{j}{l}}\mu(d)\frac{n}{dl}l\sum\limits_{k=0}^{\frac{j}{l}-1}(kl+x)\bmod j$$

此时就可以枚举 $l$ 再枚举 $d$ 解决了，这个复杂度并没有什么很美丽的表达方式，但是可以写个程序算出计算次数大概是 $5\times 10^7$ 的。稍微卡卡常，比如不用 vector，减少取模次数等，卡着时限过。

code：

```cpp
int n,m,k,s,mu[N],pm[N],a[N][207],c[N];
bool vis[N];
il int Mod(int x,int y){
	return x+y>=mod?x+y-mod:x+y;
}
il int qpow(int x,int y){
	int ret=1;
	while(y){
		if(y&1){
			ret=1ll*ret*x%mod;
		}
		x=1ll*x*x%mod,y>>=1;
	}
	return ret;
}
void Yorushika(){
	read(n,m);
	double x;scanf("%lf",&x),k=x;
	rep(i,1,m){
		for(int j=i;j<=m;j+=i){
			a[j][++c[j]]=i;
		}
	}
	int ans=0;
	rep(j,1,m){
		int sum=0;
		sum=Mod(sum,1ll*((1ll*(1+n)*n/2)%mod)*((1ll*(j-1)*j/2)%mod)%mod);
		sum=Mod(sum,1ll*n*j%mod*k%mod);
		rep(i,1,c[j]){
			int l=a[j][i];
			ll x=0;
			rep(p,1,c[j/l]){
				int d=a[j/l][p];
				x+=1ll*mu[d]*(n/(d*l))*l;
			}
			int y=k%l;
			y=(1ll*(y+y+(j-l))*(j/l)/2)%mod;
			sum=Mod(sum,mod-1ll*(x%mod+mod)%mod*y%mod);
		}
		ans=Mod(ans,1ll*sum*qpow(j,mod-2)%mod);
	}
	printf("%d\n",ans);
}
signed main(){
	const int mx=5e5;
	mu[1]=1;
	rep(i,2,mx){
		if(!vis[i]){
			pm[++s]=i,mu[i]=-1;
		}
		rep(j,1,s){
			if(pm[j]>mx/i){
				break;
			}
			vis[i*pm[j]]=1;
			if(i%pm[j]==0){
				break;
			}
			mu[i*pm[j]]=-mu[i];
		}
	}
	int t=1;
	//read(t);
	while(t--){
		Yorushika();
	}
}
```

---

## 作者：Purslane (赞：3)

# Solution

什么魔怔题 /oh

根据高斯函数的性质，你可以将 $x$ 下取整，不妨设 $x \in \mathbb N$。

----------

显然有 $\lfloor \dfrac{nk+x}{m} \rfloor = \dfrac{(nk+x) - (nk+x) \bmod m}{m}$，将两部分分开计算。

前一部分是容易的，枚举 $m$，则：
$$
\sum_{n=1}^N \sum_{k=0}^{m-1} nk+x = Nmx + (\sum_{n=1}^N n)(\sum_{k=0}^{m-1} k)
$$
两个等差数列求和即可。

----------

考虑 $(nk+x) \bmod m$ 有什么规律。发现 $n$ 也固定后，$k$ 构成了模 $m$ 的完系。

$nk$ 呢？设 $g = \gcd(n,m)$，那么 $nk \bmod m$ 完全遍历了 $0$，$g$，$2g$，$\cdots$，$m-g$ 恰好 $g$ 次。

让 $x$ 对 $g$ 取模，则 $(nk+x) \bmod m$ 完全遍历了 $x$，$g+x$，$2g+x$，$\cdots$，$m-g+x$ 恰好 $g$ 次。

$x$ 在里面的贡献是 $mx$，除掉 $m$ 后恰好为 $x$。

$g$ 在里面的贡献是 $g \times (0+m-g) \times \dfrac{m}{2g}$，除掉 $m$ 后为 $\dfrac{m-g}{2}$。

所以，我们愉快的求出 
$$
\sum_{k=0}^{m-1} \dfrac{(nk+x) \bmod m}{m} = x \bmod \gcd(n,m) + \dfrac{m - \gcd(n,m)}{2}
$$
问题变为求
$$
\sum_{n=1}^N \sum_{m=1}^M x \bmod \gcd(n,m) + \dfrac{m - \gcd(n,m)}{2}
$$
我们只需要对每个 $d$ 求出
$$
\sum_{n=1}^N \sum_{m=1}^M [\gcd(n,m) = d]
$$
也就是
$$
\sum_{n=1}^{\lfloor \frac{N}{d} \rfloor} \sum_{m=1}^{\lfloor \frac{M}{d} \rfloor} [\gcd(n,m) = 1]
$$
对 $d$ 用整除分块（其实不用整除分块，你可以写一个记忆化），再在这个经典问题里面用莫反即可。

```cpp
#include<bits/stdc++.h>
#define int long long
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=5e5+10,MOD=998244353,_2=(MOD+1)/2;
int N,M,x,ans,cnt[MAXN];
int sum(int l,int r) {return (r-l+1)*(l+r)/2%MOD;}
int qpow(int base,int p) {
	int ans=1;
	while(p) {
		if(p&1) ans=ans*base%MOD;
		base=base*base%MOD,p>>=1;
	}
	return ans;
}
int flg[MAXN],mu[MAXN];
void init(int mx) {
	vector<int> pr;
	mu[1]=1;
	ffor(i,2,mx) {
		if(!flg[i]) pr.push_back(i),mu[i]=-1;
		for(auto v:pr) {
			if(i*v>mx) break ;
			flg[i*v]=1;
			if(i%v==0) break ;
			mu[i*v]=-mu[i];	
		}
	}
	ffor(i,2,mx) mu[i]+=mu[i-1];
	return ;
}
map<pair<int,int>,int> sans;
int calc(int n,int m) {
	if(sans.count({n,m})) return sans[{n,m}];
	int tans=0;
	int l=1,r;
	while(l<=min(n,m)) {
		int r=min(n/(n/l),m/(m/l));
		tans+=(mu[r]-mu[l-1])*(n/l)%MOD*(m/l)%MOD;
		l=r+1;
	}
	int psl=0;
	ffor(i,1,n) ffor(j,1,m) psl+=(__gcd(i,j)==1);
	assert(psl==tans);
	return sans[{n,m}]=tans;
}
signed main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>N>>M>>x,init(500000);
	ffor(m,1,M) ans=(ans+N*x%MOD+qpow(m,MOD-2)*sum(1,N)%MOD*sum(0,m-1))%MOD;	
	ffor(d,1,min(N,M)) cnt[d]=calc(N/d,M/d),ans=(ans-(x%d)*cnt[d])%MOD;
	ffor(d,1,min(N,M)) ans=(ans+_2*d%MOD*cnt[d])%MOD;
	ffor(m,1,M) ans=(ans-_2*m%MOD*N)%MOD;
	cout<<(ans%MOD+MOD)%MOD;
	return 0;
}
```

---

## 作者：Genius_Star (赞：2)

### 思路：

注意到关于 $x$ 的式子是向下取整，故 $x$ 的小数部分没有任何影响。

先推式子：

$$\begin{aligned} LHS &= \sum_{n = 1}^N \sum_{m = 1}^M \sum_{k = 0}^{m - 1} \lfloor \frac{nk + x}{m} \rfloor \\ &= \sum_{m = 1}^M \sum_{n = 1}^N  \sum_{k = 0}^{m - 1} \lfloor \frac{nk + x}{m} \rfloor \\ &= \sum_{m = 1}^M \sum_{n = 1}^N  \sum_{k = 0}^{m - 1} \frac{nk + x -(nk + x) \bmod m}{m} \\ &= \sum_{m = 1}^M \frac{1}{m}\Big(\sum_{n = 1}^N \sum_{k = 0}^{m - 1} nk+ x - (nk + x) \bmod m \Big) \\&= \sum_{m = 1}^M \frac{1}{m}\Big(Nmx + \frac{Nm(N + 1)(m - 1)}{4} - \sum_{n = 1}^N \sum_{k = 0}^{m - 1} (nk+x) \bmod m\Big) \end{aligned}$$

现在我们主要的问题是如何解决：

$$\sum_{n = 1}^N \sum_{k = 0}^{m - 1} (nk+x) \bmod m$$

注意到 $k$ 取遍模 $m$ 下的完全剩余系，根据完全剩余系的性质，若 $(n, m) =1$，则 $nk$ 也取遍模 $m$ 下的完全剩余系，证明显然。

但是此时并不保证 $(n, m) = 1$，故设 $(n, m) = d$，故 $(\frac{n}{d}, m) = 1$，那么 $\frac{n}{d}k \bmod m$ 取遍了模 $m$ 的完全剩余系。

那么 $nk \bmod m$ 的取值范围应该是 $0, d, 2d, \cdots, (m - 1)d$ 模 $m$ 后的值；设 $m'd = m$，则应该构成了 $d$ 个 $0, d, 2d, \cdots, (m' - 1)d [= m - d$ 这样的循环。

还需要加上 $x$，令 $y = x \bmod d$，则应该构成 $d$ 个 $y, d + y, d + 2y, c\dots, m - d + y$ 这样的循环，给定一个证明：

> 令 $x' = x \bmod m$，则 $(kd + x) \bmod m = (kd + x') \bmod m$，注意到 $kd, x' < m$，那么 $kd + x' \in [0, 2m - 2]$，故若 $kd + x' \ge m$，则 $(kd + x') \bmod m = kd + x' - m$。
> 
> 考虑将 $kd + x' - m$ 映射到 $k'd + (x' \bmod d)$ 上，即 $kd + x' - m = k'd + (x' \bmod d)$，则解得 $k' = k - \frac{m}{d} + \lfloor \frac{x'}{d} \rfloor$。
>
> 对于 $kd + x'$ 映射到 $k'd + (x' \bmod d)$ 时，解得 $k' = k + \lfloor \frac{x'}{d} \rfloor$。
>
> 当 $kd + x' \ge m$ 时，$k \ge \lceil \frac{m - x'}{d} \rceil$，则有 $\lfloor \frac{m - x'}{d} \rfloor \le \lceil \frac{m - x'}{d} \rceil \le \lfloor \frac{m - x'}{d} \rfloor + 1$，得到 $k \ge \{\frac{m}{d} - \lfloor \frac{x'}{d} \rfloor - 1, \frac{m}{d} - \lfloor \frac{x'}{d} \rfloor\}$；当 $x' < d$ 时，$k'= k$ 即可，故 $k \ge \frac{m}{d} - \lfloor \frac{x'}{d} \rfloor$。
>
> 那么第一种情况 $k' = k - \frac{m}{d} + \lfloor \frac{x'}{d} \rfloor$ 的范围是 $[0, \lfloor \frac{x'}{d} \rfloor]$；第二种 $k' = k + \lfloor \frac{x'}{d} \rfloor$ 的范围是 $(\lfloor \frac{x'}{d} \rfloor, \frac{m}{d} - 1]$。
>
> 两个式子一一映射，故命题得证。

令 $x' = x \bmod b$，则有 $(nk + x) \bmod k$ 构成了 $d$ 个 $x', d + x', d + 2x', c\dots, m - d + x'$ 这样的循环。

其中 $x'$ 出现了 $d\frac{m}{d} = m$ 次，贡献是 $mx$；在一个循环中 $d$ 的贡献是 $d\frac{\frac{m}{d}(\frac{m}{d} - 1)}{2}$，总贡献是 $d^2 \frac{\frac{m}{d}(\frac{m}{d} - 1)}{2} = \frac{m(m - d)}{2}$。

注意到我们上面整体的式子要同除一个 $m$，故贡献是 $x + \frac{m - d}{2}$。

那么现在原式化为：

$$\sum_{m = 1}^M Nx + \frac{N(N + 1)(m - 1)}{4} - \sum_{n = 1}^N x \bmod \gcd(n, m) + \frac{m - \gcd(n, m)}{2}$$

现在只考虑后面这串式子：

$$\begin{aligned} LHS &= \sum_{m = 1}^M \sum_{n = 1}^N \frac{m - \gcd(n, m))}{2} \\ &= \frac{1}{2}\sum_{m = 1}^M \Big(Nm - \sum_{n = 1}^N \gcd(n, m) \Big) \\ &= \frac{NM(M + 1)}{4} - \frac{1}{2} \sum_{n = 1}^N \sum_{m =1}^M \gcd(n, m)\end{aligned}$$

现在也只用考虑后面这个式子：

$$\begin{aligned} LHS &= \sum_{n = 1}^N \sum_{m =1}^M \gcd(n, m) \\ &= \sum_{k = 1}^{\min(N, M)} k \sum_{n = 1}^N \sum_{m = 1}^M [\gcd(n, m) = k] \\ &= \sum_{k = 1}^{\min(N, M)} k \sum_{n = 1}^{\lfloor \frac{N}{k} \rfloor} \sum_{m = 1}^{\lfloor \frac{M}{k} \rfloor} [\gcd(n, m) = 1] \\ &= \sum_{k = 1}^{\min(N, M)} k \sum_{n = 1}^{\lfloor \frac{N}{k} \rfloor} \sum_{m = 1}^{\lfloor \frac{M}{k} \rfloor} \sum_{d | \gcd(n, m)} \mu(d) \\ &= \sum_{k = 1}^{\min(N, M)} k\sum_{d = 1}^{\min(\lfloor \frac{N}{k} \rfloor, \lfloor \frac{M}{k} \rfloor)} \mu(d) \sum_{n = 1}^{\lfloor \frac{N}{k} \rfloor} [d | n] \sum_{m = 1}^{\lfloor \frac{M}{k} \rfloor} [d | m] \\ &= \sum_{k = 1}^{\min(N, M)} k\sum_{d = 1}^{\min(\lfloor \frac{N}{k} \rfloor, \lfloor \frac{M}{k} \rfloor)} \mu(d) \lfloor \frac{N}{kd} \rfloor \lfloor \frac{M}{kd} \rfloor \\ &= \sum_{T = 1}^{\min(N, M)} \lfloor \frac{N}{T} \rfloor \lfloor \frac{M}{T} \rfloor \Big(\sum_{k | T} k \mu(\frac{T}{k})\Big) \\ &= \sum_{T = 1}^{\min(N, M)} \lfloor \frac{N}{T} \rfloor \lfloor \frac{M}{T} \rfloor \varphi(T) \end{aligned}$$

然后再来考虑：

$$\begin{aligned} LHS &= \sum_{n = 1}^N \sum_{m = 1}^M x \bmod \gcd(n, m) \\ &= \sum_{k = 1}^{\min(N, M)} x \bmod k \sum_{n =1}^N \sum_{m = 1}^M [\gcd(n, m) = k] \\ &= \sum_{k = 1}^{\min(N, M)} x \bmod k \sum_{d = 1}^{\min(\lfloor \frac{N}{k} \rfloor, \lfloor \frac{M}{k} \rfloor) } \mu(d) \lfloor \frac{n}{kd} \rfloor \lfloor \frac{m}{kd} \rfloor \\ &= \sum_{T = 1}^{\min(N, M)} \lfloor \frac{N}{T} \rfloor \lfloor \frac{M}{T} \rfloor \Big( \sum_{k | T} (x \bmod k) \mu(\frac{T}{k}) \Big) \\ &= \sum_{T = 1}^{\min(N, M)} \lfloor \frac{N}{T} \rfloor \lfloor \frac{M}{T} \rfloor F(T) \end{aligned}$$

其中：

$$F(T) = \sum_{k | T} (x \bmod k) \mu(\frac{T}{k})$$


枚举每个约数的倍数即可 $O(N \ln N)$ 预处理出 $F$。

故答案式子为：

$$NMX + \frac{NM(N + 1)(M - 1)}{8} - \frac{NM(M + 1)}{4} \\+ \sum_{T = 1}^{\min(N, M)} \lfloor \frac{N}{T} \rfloor \lfloor \frac{M}{T} \rfloor (\frac{1}{2} \varphi(T) -   F(T))$$

维护 $\frac{1}{2}\varphi(T) + F(T)$ 的前缀和然后数论分块即可。

时间复杂度为 $O(W \ln W + \sqrt{W})$。

### 完整代码：

```cpp
 #include<bits/stdc++.h>
#define ls(k) k << 1
#define rs(k) k << 1 | 1
#define fi first
#define se second
#define open(s1, s2) freopen(s1, "r", stdin), freopen(s2, "w", stdout);
using namespace std;
typedef __int128 __;
typedef long double lb;
typedef double db;
typedef unsigned long long ull;
typedef long long ll;
bool Begin;
const int N = 5e5 + 10, mod = 998244353;
inline ll read(){
    ll x = 0, f = 1;
    char c = getchar();
    while(c < '0' || c > '9'){
        if(c == '-')
          f = -1;
        c = getchar();
    }
    while(c >= '0' && c <= '9'){
        x = (x << 1) + (x << 3) + (c ^ 48);
        c = getchar();
    }
    return x * f;
}
inline void write(ll x){
	if(x < 0){
		putchar('-');
		x = -x;
	}
	if(x > 9)
	  write(x / 10);
	putchar(x % 10 + '0');
}
int Max, n, m, x, ans, inv2, cnt;
int P[N], F[N], phi[N], mu[N], s[N];
bool f[N];
inline int qpow(int a, int b){
	int ans = 1;
	while(b){
		if(b & 1)
		  ans = 1ll * ans * a % mod;
		a = 1ll * a * a % mod;
		b >>= 1;
	}
	return ans;
}
void init(){
	phi[1] = mu[1] = 1;
	for(int i = 2; i <= Max; ++i){
		if(!f[i]){
			P[++cnt] = i;
			mu[i] = -1;
			phi[i] = i - 1;
		}
		for(int j = 1; j <= cnt && 1ll * i * P[j] <= Max; ++j){
			f[i * P[j]] = 1;
			if(i % P[j]){
				phi[i * P[j]] = phi[i] * phi[P[j]];
				mu[i * P[j]] = -mu[i];
			}
			else{
				phi[i * P[j]] = phi[i] * P[j];
				break;
			}
		}
		mu[i] = (mu[i] + mod) % mod;
	}
	for(int d = 1; d <= Max; ++d)
	  for(int n = d; n <= Max; n += d)
	    F[n] = (F[n] + 1ll * (x % d) * mu[n / d] % mod) % mod;
	for(int i = 1; i <= Max; ++i)
	  s[i] = ((1ll * inv2 * phi[i] % mod - F[i] + mod) % mod + s[i - 1]) % mod;
}
bool End;
int main(){
	inv2 = qpow(2, mod - 2);
	n = read(), m = read(), x = read();
	Max = min(n, m);
	ans = (1ll * n * m % mod * x % mod + 1ll * n * m % mod * (n + 1) % mod * (m - 1) % mod * qpow(8, mod - 2) % mod - 1ll * n * m % mod * (m + 1) % mod * qpow(4, mod - 2) % mod + mod) % mod;
	init();
	for(int l = 1, r; l <= Max; l = r + 1){
		r = min(n / (n / l), m / (m / l));
		ans = (ans + 1ll * (n / l) * (m / l) % mod * ((s[r] - s[l - 1] + mod) % mod) % mod) % mod;
	}
	write(ans);
	cerr << '\n' << abs(&Begin - &End) / 1048576 << "MB";
	return 0;
}
```

---


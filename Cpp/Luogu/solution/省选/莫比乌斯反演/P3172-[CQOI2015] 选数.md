# [CQOI2015] 选数

## 题目描述

我们知道，从区间 $[L,H]$（$L$ 和 $H$ 为整数）中选取 $N$ 个整数，总共有 $(H-L+1)^N$ 种方案。小 z 很好奇这样选出的数的最大公约数的规律，他决定对每种方案选出的 $N$ 个整数都求一次最大公约数，以便进一步研究。然而他很快发现工作量太大了，于是向你寻求帮助。你的任务很简单，小 z 会告诉你一个整数 $K$，你需要回答他最大公约数刚好为 $K$ 的选取方案有多少个。

由于方案数较大，你只需要输出其除以 $10^9+7$ 的余数即可。

## 说明/提示

#### 样例 1 解释

所有可能的选择方案：$(2, 2), (2, 3), (2, 4), (3, 2), (3, 3), (3, 4), (4, 2), (4, 3), (4, 4)$。

其中最大公约数等于 $2$ 的只有 $3$ 组：$(2, 2), (2, 4), (4, 2)$。
#### 数据规模与约定
对于 $100\%$ 的数据，$1\le N,K\le 10^9$，$1\le L\le H\le 10^9$，$H-L\le 10^5$。

## 样例 #1

### 输入

```
2 2 2 4```

### 输出

```
3```

# 题解

## 作者：xyz32768 (赞：78)

首先，进行如下处理：

1、如果$L$是$K$的倍数，那么把$L$变为$\frac{L}{K}$，否则变为$\lfloor\frac{L}{K}\rfloor+1$。

2、把$H$变成$\lfloor\frac{H}{K}\rfloor$。

这样子容易得出，现在要求的就是在$[L,H]$之间，选数$N$次使选出的数最大公约数为$1$的方案数。

现在，用$f[i]$表示选出的数的最大公约数$i$且选出的数**不全相同**的方案数。此时先求出$[L,H]$之间$i$的倍数的个数$x$，暂时令$f[i]=x^N-x$。

但此时得到的$f[i]$实际上是**含有公约数**$i$的方案数，不是最大公约数为$i$的方案数。但是可以发现，此时的$f[i]$包含有最大公约数为$i,2i,3i,...$的方案数。这时候使用容斥原理：假设已经知道了$f[2i],f[3i],...$的**最终结果**，那么就把$f[i]$分别减去$f[2i],f[3i],...$，就可以得到$f[i]$的最终结果。倒着推一遍。

特殊情况：$L=1$时可以所有的数都选$1$。所以$L=1$时答案要加$1$。

代码：

```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
inline int read() {
    int res = 0; bool bo = 0; char c;
    while (((c = getchar()) < '0' || c > '9') && c != '-');
    if (c == '-') bo = 1; else res = c - 48;
    while ((c = getchar()) >= '0' && c <= '9')
        res = (res << 3) + (res << 1) + (c - 48);
    return bo ? ~res + 1 : res;
}
const int N = 1e5 + 5, PYZ = 1e9 + 7;
int n, K, L, H, f[N];
int qpow(int a, int b) {
    int res = 1;
    while (b) {
        if (b & 1) res = 1ll * res * a % PYZ;
        a = 1ll * a * a % PYZ;
        b >>= 1;
    }
    return res;
}
int main() {
    int i, j; n = read(); K = read(); L = read(); H = read();
    if (L % K) L = L / K + 1; else L /= K; H /= K;
    if (L > H) return puts("0"), 0;
    for (i = 1; i <= H - L; i++) {
        int l = L, r = H;
        if (l % i) l = l / i + 1; else l /= i; r /= i;
        if (l > r) continue;
        f[i] = (qpow(r - l + 1, n) - (r - l + 1) + PYZ) % PYZ;
    }
    for (i = H - L; i; i--) for (j = (i << 1); j <= H - L; j += i)
        f[i] = (f[i] - f[j] + PYZ) % PYZ;
    if (L == 1) (f[1] += 1) %= PYZ; cout << f[1] << endl;
    return 0;
}
```

---

## 作者：asuldb (赞：53)

这道题自然是可以反演的

按照反演的套路我们先设出两个函数

$F(n)$表示从$[L,H]$中任选$N$个数的最大公约数是$n$或者$n$的倍数的情况数

$f(n)$表示从$[L,H]$中任选$N$个数的最大公约数是$n$的情况数

非常显然的是

$$F(n)=\sum_{n|d}f(d)$$

$$f(n)=\sum_{n|d}\mu(\frac{d}{n})F(d)$$

开始反演了

首先我们发现我们求$f(k)$并不好求，因为没有办法整除分块

所一我们把$L/k,H/k$之后求$f(1)$就好了

吗？

显然并不行啊

我们考虑一下如果$L\%k!=0$，$\left \lfloor \frac{L}{k} \right \rfloor\times k<L$,就会使一些不在$[L,H]$内的数混进答案里了

所以如果$L\%k!=0$的话，除以$k$之后再将$L+1$

之后就是如何表示$F$了

非常显然就是

$$F(n)=(\left \lfloor  \frac{H}{n}\right \rfloor-\left \lfloor  \frac{L-1}{n}\right \rfloor)^N$$

了

$$f(1)=\sum_{i=1}\mu(i)F(i)$$

把$F(i)$相等的用整除分块处理

但是这道题的$H$非常大，甚至都不能线筛

不能线筛杜教筛总可以了吧，于是就可以用$O(H^{\frac{2}{3}})$的复杂度解决这道题

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<tr1/unordered_map>
#define re register
#define maxn 5000001
#define LL long long
#define max(a,b) ((a)>(b)?(a):(b))
#define min(a,b) ((a)<(b)?(a):(b))
const int mod=1000000007;
using namespace std::tr1;
unordered_map<int,int> ma;
int p[maxn>>1],f[maxn],mu[maxn];
inline LL quick(int a,int b)
{
    LL S=1;
    while(b) {if(b&1) S=S*a%mod;b>>=1;a=(LL)a*(LL)a%mod;}
    return S;
}
int N,K,L,H,M;
int solve(int x)
{
    if(x<=M) return mu[x];
    if(ma.find(x)!=ma.end()) return ma[x];
    int ans=1;
    for(re int l=2,r;l<=x;l=r+1)
    {
        r=x/(x/l);
        ans-=solve(x/l)*(r-l+1);
    }
    return ma[x]=ans;
}
int main()
{
    scanf("%d%d%d%d",&N,&K,&L,&H);
    H/=K;
    if(L%K==0) L=L/K;
        else L=L/K+1;
    M=min(H,5000000);
    mu[1]=f[1]=1;
    for(re int i=2;i<=M;i++)
    {
        if(!f[i]) p[++p[0]]=i,mu[i]=-1;
        for(re int j=1;j<=p[0]&&p[j]*i<=M;j++)
        {
            f[p[j]*i]=1;
            if(i%p[j]==0) break;
            mu[i*p[j]]=-1*mu[i];
        }
    }
    for(re int i=1;i<=M;i++) mu[i]+=mu[i-1];
    LL ans=0;L--;
    for(re int l=1,r;l<=H;l=r+1)
    {
        if(!(L/l)) r=H/(H/l);
            else r=min(H/(H/l),L/(L/l));
        ans=(ans+quick(H/l-L/l,N)*(LL)(solve(r)-solve(l-1))%mod)%mod;
    }
    printf("%lld\n",((ans%mod)+mod)%mod);
    return 0;
}

```

---

## 作者：caeious (赞：23)

记 $D = H - L$.

这题有两种常规做法：一种是 $\mathcal{O}(H^{\frac{2}{3}})$ 杜教筛，另一种是 $\mathcal{O}(D \log D + D \log n)$ 的容斥。然而杜教筛完全没有用到 $D$ 较小的条件，~~并且不适合该算法还没普及的 CQOI2015~~，容斥是组合而不是数论方法，~~不如推莫反式子来的优美~~。因此，本文给出一种纯数论的 $\mathcal{O}(D + \sqrt{D} \log n)$ 做法。

不失一般性（这一步怎么推导参见其他任何一篇题解），将原问题变为：

- 求从 $(l,r]$ 中选取 $N$ 个整数 $i_1, i_2, \dots, i_n$，它们的最大公约数等于 $1$ 的方案数。
- $l,r \in \mathbb{N}$, $N \in \mathbb{N}^*$.
- 重定义 $D = r - l$.

不难发现所求

$$
\begin{aligned}
&= \sum_{i_1 \in (l, r]} \sum_{i_2 \in (l, r]} \dots \sum_{i_n \in (l, r]}[(i_1, i_2, \dots, i_n) = 1] \\
&= \sum_{i_1 \in (l, r]} \sum_{i_2 \in (l, r]} \dots \sum_{i_n \in (l, r]}\sum_{d | (i_1, i_2, \dots, i_n)} \mu(d) && (\mu \ast 1 = \epsilon) \\
&= \sum_{d = 1}^r \mu(d) \sum_{\begin{aligned} i_1 \in &(l, r] \\ d &| i_1 \end{aligned}} \dots \sum_{\begin{aligned} i_n \in &(l, r] \\ d &| i_n \end{aligned}}1 && (\text{先枚举 $d$, 并将 $\mu(d)$ 提出}) \\
&= \sum_{d = 1}^r \mu(d)(\lfloor\dfrac{r}{d}\rfloor - \lfloor \dfrac{l}{d}\rfloor)^n && (\text{$(l, r]$ 中 $d$ 的倍数有 $\lfloor\dfrac{r}{d}\rfloor - \lfloor \dfrac{l}{d}\rfloor$ 个})
\end{aligned}
$$

当 $d > D$ 时，$\lfloor\dfrac{r}{d}\rfloor - \lfloor \dfrac{l}{d}\rfloor = 0$ 或 $1$，故 $(\lfloor\dfrac{r}{d}\rfloor - \lfloor \dfrac{l}{d}\rfloor) ^ n = \lfloor\dfrac{r}{d}\rfloor - \lfloor \dfrac{l}{d}\rfloor$.

将原式拆开

$$
\begin{aligned}
&= \sum_{d = 1}^D\mu(d)(\lfloor\dfrac{r}{d}\rfloor - \lfloor \dfrac{l}{d}\rfloor)^n + \sum_{d = D + 1}^r \mu(d)(\lfloor\dfrac{r}{d}\rfloor - \lfloor \dfrac{l}{d}\rfloor)
\end {aligned}
$$
右边这一项

$$
\begin{aligned}
&= \sum_{d = D + 1}^r \sum_{\begin{aligned} i \in &(l, r] \\ d &| i \end{aligned}} \mu(d) && (\text{$(l, r]$ 中 $d$ 的倍数有 $\lfloor\dfrac{r}{d}\rfloor - \lfloor \dfrac{l}{d}\rfloor$ 个, 并将 $\mu(d)$ 乘进去}) \\ 
&= \sum_{d = 1}^r \sum_{\begin{aligned} i \in &(l, r] \\ d &| i \end{aligned}} \mu(d) - \sum_{d = 1}^D \sum_{\begin{aligned} i \in &(l, r] \\ d &| i \end{aligned}} \mu(d) && (差分) \\
&= \sum_{i \in (l, r]} \sum_{d | i} \mu(d) - \sum_{d = 1}^D \mu(d) \sum_{\begin{aligned} i \in &(l, r] \\ d &| i \end{aligned}} 1 && (\text{左边一项先枚举 $i$, 右边一项提出 $\mu(d)$}) \\
&= \sum_{i = l + 1}^r \epsilon(i) - \sum_{d = 1}^D\mu(d)(\lfloor\dfrac{r}{d}\rfloor - \lfloor \dfrac{l}{d}\rfloor) &&(\mu \ast 1 = \epsilon \text{, $(l, r]$ 中 $d$ 的倍数有 $\lfloor\dfrac{r}{d}\rfloor - \lfloor \dfrac{l}{d}\rfloor$ 个}) \\
&= \epsilon(l + 1) - \sum_{d = 1}^D\mu(d)(\lfloor\dfrac{r}{d}\rfloor - \lfloor \dfrac{l}{d}\rfloor) && (l + 2 > 1)
\end {aligned}
$$
所以总的答案

$$
\begin{aligned}
&= \sum_{d = 1}^D\mu(d)(\lfloor\dfrac{r}{d}\rfloor - \lfloor \dfrac{l}{d}\rfloor)^n + \epsilon(l + 1) - \sum_{d = 1}^D\mu(d)(\lfloor\dfrac{r}{d}\rfloor - \lfloor \dfrac{l}{d}\rfloor) \\
&= \sum_{d = 1}^D\mu(d)[(\lfloor\dfrac{r}{d}\rfloor - \lfloor \dfrac{l}{d}\rfloor)^n - (\lfloor\dfrac{r}{d}\rfloor - \lfloor \dfrac{l}{d}\rfloor)] + \epsilon(l + 1)
\end{aligned}
$$
左边这个和式，$\mathcal{O}(D)$ 线性筛处理 $\mu$ 前缀和，再 $\mathcal{O}(\sqrt{D} \log n)$ 数论分块。
## Sample Code

**注：由于本题数据范围较小，该代码并没有使用线性筛和数论分块**

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <cmath>
#include <utility>
#include <queue>
using namespace std;
typedef long long ll;
typedef long double ldouble;
const int LEN = 100000;

struct fastio {
  int it, len;
  char s[LEN + 5];
  fastio() {
    it = len = 0;
  }
  char get() {
    if (it < len) return s[it++];
    it = 0, len = fread(s, 1, LEN, stdin);
    return len ? s[it++] : EOF;
  }
  bool notend() {
    char c;
    for (c = get(); c == ' ' || c == '\n' || c == '\r'; c = get());
    if (it) it--;
    return c != EOF;
  }
  void put(char c) {
    if (it == LEN) fwrite(s,1,LEN,stdout), it = 0;
    s[it++] = c;
  }
  void flush() {
    fwrite(s, 1, it, stdout);
  }
}buff, bufo;
inline int getint() {
  char c; int res = 0, sig = 1;
  for (c = buff.get(); c < '0' || c > '9'; c = buff.get()) if(c == '-') sig = -1;
  for (; c >= '0' && c <= '9'; c = buff.get()) res = res * 10 + (c - '0');
  return sig * res;
}
inline ll getll() {
  char c; ll res = 0, sig = 1;
  for (c = buff.get(); c < '0' || c > '9'; c = buff.get()) if (c == '-') sig = -1;
  for (; c >= '0' && c <= '9'; c = buff.get()) res = res * 10 + (c - '0');
  return sig * res;
}
inline void putint(int x, char suf) {
  if (!x) bufo.put('0');
  else {
    if (x < 0) bufo.put('-'), x = -x;
    int k = 0; char s[15];
    while (x) {
      s[++k] = x % 10 + '0';
      x /= 10;
    }
    for (; k; k--) bufo.put(s[k]);
  }
  bufo.put(suf);
}
inline void putll(ll x, char suf) {
  if (!x) bufo.put('0');
  else {
    if (x < 0) bufo.put('-'), x = -x;
    int k = 0; char s[25];
    while (x) {
      s[++k] = x % 10 + '0';
      x /= 10;
    }
    for (; k; k--) bufo.put(s[k]);
  }
  bufo.put(suf);
}
inline char get_char() {
  char c;
  for (c = buff.get(); c == ' ' || c == '\n' || c == '\r'; c = buff.get());
  return c;
}

#define mod 1000000007
ll modpow(ll x, ll y) {
  ll res = 1;
  while (y) {
    if (y & 1) res = res * x % mod;
    y >>= 1;
    x = x * x % mod;
  }
  return res;
}

int n, k, L, H, l, r, mu[100005], ans;

int main() {
  n = getint(), k = getint(), L = getint(), H = getint();
  l = (L - 1) / k, r = H / k;
  mu[1] = 1;
  for (int i = 1; i <= 100000; i++) {
    for (int j = i << 1; j <= 100000; j += i) {
      mu[j] -= mu[i];
    }
  }
  if (r <= 100000) {
    for (int d = 1; d <= r; d++)
      (ans += mu[d] * modpow(r / d - l / d, n)) %= mod;
    putll((ans + mod) % mod, '\n');
  } else {
    for (int d = 1; d <= 100000; d++)
      (ans += mu[d] * modpow(r / d - l / d, n)) %= mod;
    (ans += (l == 0)) %= mod;
    for (int d = 1; d <= 100000; d++)
      (ans -= (r / d - l / d) * mu[d]) %= mod;
    putll((ans + mod) % mod, '\n');
  }
  bufo.flush();
  return 0;
}
```
## Note

对于容斥的做法，核算容斥系数也可以得到相同的式子。

---

## 作者：Wolfycz (赞：23)

题目要求（令$H$变为$R$）

$$\sum\limits_{a_1=L}^R\sum\limits_{a_2=L}^R...\sum\limits_{a_n=L}^R[\gcd\limits_{i=1}^n(a_i)=K]$$

同样的，我们令所有数整除一个$K$，注意到$L\leqslant a_i\leqslant R$，那么再次枚举的$a_i'$要满足$L\leqslant a_i'×K\leqslant R$，所以有

$$\sum\limits_{a_1=\lfloor\frac{L-1}{d}\rfloor+1}^{\lfloor\frac{R}{d}\rfloor}...\sum\limits_{a_n=\lfloor\frac{L-1}{d}\rfloor+1}^{\lfloor\frac{R}{d}\rfloor}[\gcd\limits_{i=1}^n(a_i)=1]$$

对最后一部分反演，并且将枚举$x$提前，得到

$$\sum\limits_{x=1}^{\lfloor\frac{R}{d}\rfloor}\mu(x)\sum\limits_{a_1=\lfloor\frac{L-1}{d}\rfloor+1}^{\lfloor\frac{R}{d}\rfloor}...\sum\limits_{a_n=\lfloor\frac{L-1}{d}\rfloor+1}^{\lfloor\frac{R}{d}\rfloor}1$$

后面那一坨长的都一个样子，而且可以给他们容斥一下，得到

$$\sum\limits_{x=1}^{\lfloor\frac{R}{d}\rfloor}\mu(x)(\lfloor\dfrac{R}{d}\rfloor-\lfloor\dfrac{L-1}{d}\rfloor)^n$$

如果我们能够求出$\sum\limits_{i=1}^n\mu(i)$，那么我们就可以进行整除分块了

线筛？死了……$n\leqslant 10^9$；于是我们杜教筛一波，可以参考[浅谈算法——杜教筛](https://www.cnblogs.com/Wolfycz/p/10266081.html)

然后这题就做完了

```cpp
/*program from Wolfycz*/
#include<map>
#include<cmath>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#define Fi first
#define Se second
#define inf 0x7f7f7f7f
using namespace std;
typedef long long ll;
typedef unsigned int ui;
typedef unsigned long long ull;
inline char gc(){
	static char buf[1000000],*p1=buf,*p2=buf;
	return p1==p2&&(p2=(p1=buf)+fread(buf,1,1000000,stdin),p1==p2)?EOF:*p1++;
}
inline int frd(){
	int x=0,f=1; char ch=gc();
	for (;ch<'0'||ch>'9';ch=gc())	if (ch=='-')	f=-1;
	for (;ch>='0'&&ch<='9';ch=gc())	x=(x<<3)+(x<<1)+ch-'0';
	return x*f;
}
inline int read(){
	int x=0,f=1; char ch=getchar();
	for (;ch<'0'||ch>'9';ch=getchar())	if (ch=='-')	f=-1;
	for (;ch>='0'&&ch<='9';ch=getchar())	x=(x<<3)+(x<<1)+ch-'0';
	return x*f;
}
inline void print(int x){
	if (x<0)	putchar('-'),x=-x;
	if (x>9)	print(x/10);
	putchar(x%10+'0');
}
const int N=1e6,p=1e9+7;
map<int,int>Sum;
int prime[N+10],miu[N+10],sum[N+10];
bool inprime[N+10];
void prepare(){
	miu[1]=sum[1]=1; int tot=0;
	for (int i=2;i<=N;i++){
		if (!inprime[i])	miu[prime[++tot]=i]=-1;
		for (int j=1;j<=tot&&i*prime[j]<=N;j++){
			inprime[i*prime[j]]=1;
			if (i%prime[j]==0){
				miu[i*prime[j]]=0;
				break;
			}miu[i*prime[j]]=-miu[i];
		}
		sum[i]=sum[i-1]+miu[i];
	}
}
int S(int n){
	if (n<=N)	return sum[n];
	map<int,int>::iterator it=Sum.find(n);
	if (it!=Sum.end())	return it->Se;
	int res=1;
	for (int i=2,pos;i<=n;i=pos+1){
		pos=n/(n/i);
		res=(res-1ll*(pos-i+1)*S(n/i)%p)%p;
	}
	res=(res+p)%p;
	Sum.insert(map<int,int>::value_type(n,res));
	return res;
}
int mlt(int a,int b){
	int res=1;
	for (;b;b>>=1,a=1ll*a*a%p)	if (b&1)	res=1ll*res*a%p;
	return res;
}
int main(){
	prepare();
	int n=read(),k=read(),L=read(),R=read(),Ans=0;
	--L/=k,R/=k;
	for (int i=1,pos;i<=R;i=pos+1){
		pos=min(L/i?L/(L/i):inf,R/(R/i));
		Ans=(Ans+1ll*(S(pos)-S(i-1))*mlt(R/i-L/i,n)%p)%p;
	}
	printf("%d\n",(Ans+p)%p);
    return 0;
}
```

---

## 作者：litble (赞：22)

# 题目分析

递推+容斥。

我们注意到H-L<=10^5，也就是说H-L是很小的。那么对于任意正整数x,如果x>H-L,那么就在H到L的区间里不可能找到两个及以上的数，它们的gcd=x。

这样我们就可以大大缩小范围了！

**以下所有除法都是向下取整。。。**

我们用f[i]表示gcd为$i*k$的数对的个数，首先我们可以缩小H和L，即同时除以k，令l=(H-1)/k,r=L/k,结果不变（为什么是(H-1)/k?因为我们只要用到H-1），那么在H到L范围内$i*k$的倍数有$r/i-l/i$个，那么从其中选出n个数组成数对的个数有$(r/i-l/i)^n$个。

但是我们不能算所有数都一样的数对，因为我们把递推范围缩小到H-L（或者说r-l）的前提是找不到两个及以上的数满足gcd=x，如果是所有数都一样的数对，依然可能超出我们枚举的gcd的范围。所以要减去一个$r/i-l/i$

然后找范围以内所有i的倍数j，去除掉所有f[j]就可以得到f[i]。

最后注意，如果k在H到L的范围里，答案要+1

# 代码

```cpp
#include<iostream>
#include<cstdio>
#include<climits>
#include<cstring>
#include<algorithm>
using namespace std;
#define LL long long
LL mod=1000000007;
LL f[100005];
LL n,k,l,r;
LL ksm(LL x,LL y){//快速幂
    LL re=1;
    while(y){
        if(y&1)re=(re*x)%mod;
        x=(x*x)%mod,y>>=1;
    }
    return re;
}
int main()
{
    LL i,j,kl=0,x,y,len;
    scanf("%lld%lld%lld%lld",&n,&k,&l,&r);
    if(l<=k&&k<=r)kl=1;
    l--,l/=k,r/=k,len=r-l;//缩小范围
    for(i=len;i>=1;i--){
        x=l/i,y=r/i;
        f[i]=(ksm(y-x,n)-(y-x)+mod)%mod;//求gcd为i的倍数数对数
        for(j=i<<1;j<=len;j+=i)f[i]=(f[i]-f[j]+mod)%mod;//gcd为i的数对数
    }
    printf("%lld",f[1]+kl);
    return 0;
}
```

---

## 作者：丛雨 (赞：11)

### [传送门](https://www.luogu.com.cn/problem/P3172)

首先解读题意，我们得到下式：

$$
Ans=\sum_{i_1=L}^H\sum_{i_2=L}^H...\sum_{i_n=L}^H[\gcd(i_1,i_2,i_3...i_n)==K] 
$$
令$l=\lfloor\frac{H}{K}\rfloor,r=\lfloor\frac{L-1}{K}\rfloor$
$$
\Rightarrow Ans=\sum_{i_1=l+1}^r\sum_{i_2=l+1}^r...\sum_{i_n=l+1}^r\epsilon(\gcd(i_1,i_2,i_3...i_n))
$$
接着进行莫比乌斯反演

$$
\Leftrightarrow Ans=\sum_{i_1=l+1}^r\sum_{i_2=l+1}^r...\sum_{i_n=l+1}^r\sum_{d|\gcd(i_1,i_2,i_3...i_n)}\mu(d)
$$

把$d$放在外层枚举

$$
\Leftrightarrow \sum_{d=1}^r\mu(d)(\lfloor\frac{r}{d}\rfloor-\lfloor\frac{l-1}{d}\rfloor)^n
$$

然后我们会发现上式可以用整除分块

**但问题就来了，r(H)的范围是1e9**

有的题解中使用了杜教筛，但事实上完全不需要。

$$H-L\leq 10^5$$

注意到这个条件，同时我们又可以知道$\lim\limits_{d\rightarrow\infty}(\lfloor\frac{r}{d}\rfloor-\lfloor\frac{l-1}{d}\rfloor)=0$

所以当$d$足够大时可以不用计算$\sum\mu(d)$**(并非单调)**

于是我们设计出了以下算法：

先整除分块

- $\lfloor\frac{r}{d}\rfloor=\lfloor\frac{l-1}{d}\rfloor$时，忽略
- $\lfloor\frac{r}{d}\rfloor\not=\lfloor\frac{l-1}{d}\rfloor$

	- $d\leq X$($X$为我们设置的闸量)时，通过预处理的$\sum\mu$得到值,预处理时间复杂度为$O(X)$
   - $d > X$枚举$i\in[l,r]$,通过筛出的$prime$得到$\mu(i)$,单次时间复杂度为$O(\frac{\sqrt{i}}{\ln i})$,当$X=10^7$时,期望出现次数$=(H-L+1)\int_{L}^{H}\frac{1}{x}dx=2$
   
期望时间复杂度$O(X+\sqrt H\log_2N)$
    
```cpp
#include<bits/stdc++.h>
using namespace std;
# define ll long long
# define read read1<ll>()
# define Type template<typename T>
Type T read1(){
	T t=0;
	char k;
	bool vis=0;
	do (k=getchar())=='-'&&(vis=1);while('0'>k||k>'9');
	while('0'<=k&&k<='9')t=(t<<3)+(t<<1)+(k^'0'),k=getchar();
	return vis?-t:t;
}
# define fre(k) freopen(k".in","r",stdin);freopen(k".out","w",stdout)
# define N 10000000
bool vis[10000005];
int mu[10000005],prime[1000005],s;
void init(){
	mu[1]=1;
	for(int i=2;i<=N;++i){
		if(!vis[i]){
			mu[i]=-1;
			prime[++prime[0]]=i;
		}
		for(int j=1;j<=prime[0]&&prime[j]*i<=N;++j){
			vis[prime[j]*i]=1;
			if(!(i%prime[j])){
				mu[i*prime[j]]=0;
				break;
			}
			mu[i*prime[j]]=-mu[i];
		}
	}
	for(int i=2;i<=N;++i)mu[i]+=mu[i-1];
}
int Mu(int x){
	int t=1;
	for(int i=1;prime[i]*prime[i]<=x;++i)
		if(!(x%prime[i])){
			x/=prime[i];t=-t;
			if(!(x%prime[i]))return 0; 
		}
	if(x!=1)t=-t;
	return t;
}
# define mod 1000000007
ll qkpow(int n,int k){
	if(!k)return 1;
	ll t=qkpow(n,k>>1);
	t=t*t%mod;
	if(k&1)t=t*n%mod;
	return t;
}
int main(){
	init();
	int n=read,k=read,L=(read-1)/k,R=read/k;
	int ans=0;
	for(int l=1,r=0;l<=R;l=r+1){
		r=min(R/(R/l),l>L?1000000000:L/(L/l));
		if(R/l==L/l)continue;
		ll t=qkpow(R/l-L/l,n),v=0;
		if(r<=N)v=mu[r]-mu[l-1];
		else for(int i=l;i<=r;++i)v+=Mu(i);
		ans=(ans+t*v)%mod;
	}
	cout<<(ans+mod)%mod;
	return 0;
}
```
    
    
    


---

## 作者：Jμdge (赞：8)

最近做题越来越不走心了，每次都是想到第一步第二步就凉了...

首先我们一看到选出一些数使它们的 $gcd$ 为 K 就先把读进来的数据范围除去 K 再说。（当然 L 除的时候要向上取整）

为什么？套路，这样问题可以转化为从 $\lceil {\dfrac{L}{K}} \rceil $ ~ $ \lfloor \dfrac{H}{K} \rfloor$ 中选出 n 个数使其互质（那么下面内容中的 L 、 H 都是已经除过 K 的了）

然后我就想不下去了，一堆奇奇怪怪的想法冒上来但是都不对...

因为我在想的是两个数互质时候的套路啊！

这里是一堆数，于是要用容斥了

令 $f[i]$ 表示选 n 个数，gcd为 i 的倍数且 n 个数不全相同的方案数，那么 $f[i]$ 是好求的：

令 $l=\lceil \dfrac L i \rceil,r=\lfloor \dfrac H i  \rfloor$

则 $f[i]$ = $(r-l+1)^n-(r-l+1)$ 

那么最后的答案用一下容斥倒过来减减就好了


```
//by Judge
#include<cstdio>
#include<iostream>
#define ll long long
using namespace std;
const int mod=1e9+7;
const int M=1e5+3;
inline void ADD(int& a,int b){ a+=a+b>=mod?b-mod:b; }
int n,K,L,H,f[M];
inline int qpow(int x,int p){ int s=1;
	for(;p;p>>=1,x=1ll*x*x%mod)
		if(p&1) s=1ll*s*x%mod; return s;
}
int main(){ scanf("%d%d%d%d",&n,&K,&L,&H),L=L/K+(L%K>0),H/=K;
	if(L>H) return !puts("0");
	for(int i=1;i<=H-L;++i){
		int l=L/i+(L%i>0),r=H/i; if(l>r) continue;
		f[i]=(qpow(r-l+1,n)-(r-l+1)+mod)%mod;
	}
	for(int i=H-L;i;--i)
		for(int j=i<<1;j<=H-L;j+=i)
			ADD(f[i],mod-f[j]);
	if(L==1) ADD(f[1],1);
	return !printf("%d\n",f[1]);
}

```



---

## 作者：Shadows (赞：5)

这题还可以莫比乌斯反演做

![](https://images2015.cnblogs.com/blog/1078180/201706/1078180-20170613113740509-1376753866.png)

图摘自GXZlegend的blog

mu函数的前缀合使用杜教筛求，先预处理一部分，可以取阈值为2e6左右

```cpp
    #include<iostream>
    #include<cstdio>
    #include<cstring>
    #include<algorithm>
    #include<map>
    #define maxn 2000020
    #define mod 1000000007
    #define logn 11
    #define inf (1<<30)
    using namespace std;
    int n,k,l,h,prime[maxn/logn],sum[maxn],tot;
    bool vis[maxn];
    map<int,int>sum2;
    int power(int a,int kkk){
        int ans=1;
        for(;kkk;kkk>>=1,a=(1ll*a*a)%mod)
        if(kkk&1)ans=(1ll*ans*a)%mod;
        return ans;
    }
    void init(){
        memset(prime,0,sizeof(prime));
        memset(vis,0,sizeof(vis));
        memset(sum,0,sizeof(sum));
        sum[1]=1;
        tot=0;
        for(int i=2;i<maxn;++i){
            if(!vis[i])sum[i]=-1,prime[++tot]=i;
            for(int j=1;j<=tot&&(i*prime[j])<maxn;++j){
                vis[i*prime[j]]=1;
                if(!(i%prime[j])){
                    sum[i*prime[j]]=0;
                    break;
                }
                sum[i*prime[j]]=-sum[i];
            }
        }
        for(int i=1;i<maxn;++i)sum[i]+=sum[i-1];
        scanf("%d%d%d%d",&n,&k,&l,&h);
    }
    int Sum(int x){
        if(x<maxn)return sum[x];
        if(sum2.find(x)!=sum2.end())return sum2[x];
        long long s=1;
        int la;
        for(int i=1;i<=(x>>1);i=la+1){
            la=x/(x/i);
            s-=(Sum(la)-Sum(i-1))*(x/i-1ll);
        }
        return sum2[x]=s%mod;
    }
    void solve(){
        int ans=0,la;
        l=(l-1)/k,h/=k;
        for(int i=1;i<=h;i=la+1){
            la=min(h/(h/i),l/i?(l/(l/i)):inf);
            ans=(ans+(1ll*(Sum(la)-Sum(i-1))*power(h/i-l/i,n))%mod)%mod;
        }
        printf("%d\n",(ans+mod)%mod);
    }
    int main(){
        init();
        solve();
        return 0;
}
```

---

## 作者：jun头吉吉 (赞：5)

很显然，题目让我们求的是(以下R=H~~看得顺眼点~~)
$$ans=\sum_{a_1=L}^R...\sum_{a_n=L}^R[gcd(a_1,...,a_n)==k]$$

$$=\sum_{a_1=\lceil \frac L k \rceil}^{\lfloor \frac R k  \rfloor}...\sum_{a_n=\lceil \frac L k \rceil}^{\lfloor \frac R k  \rfloor}[gcd(a_1,...,a_n)==1]$$
接下来我们令$l=\lceil \frac L k \rceil$,$r=\lfloor \frac R k  \rfloor$
$$=\sum_{a_1=l}^r...\sum_{a_n=l}^r[gcd(a_1,...,a_n)==1]$$
把最后一项莫比乌斯反演一下
$$=\sum_{a_1=l}^r...\sum_{a_n=l}^r \sum_{d|gcd(a_1,...,a_n)}\mu(d)$$
把枚举d提到最前面
$$=\sum_{d=1}^r\mu(d)\sum_{a_1=l}^r[d|a_1]...\sum_{a_n=l}^r[d|a_n] $$
辣么很显然，$\sum_{a=l}^r[d|a]=$[l,r]里d的倍数的个数
$$=\sum_{d=1}^r\mu(d)(\lfloor \frac r x \rfloor-\lfloor\frac {l-1} x \rfloor)^n $$
在整除分块一波就OK了

~~**关于线性筛，它死了**~~

这里我们用杜教筛，先上公式：
$$g(1)S(n)=\sum_{i=1}^{n}h(i)-\sum_{d=2}^{n}g(d)\cdot S(\lfloor\frac{n}{d}\rfloor)$$
这里我们去$g=I,h=\mu *I=id$那么式子变成
$$\to S(n)=1-\sum_{d=2}^{n}S(\lfloor\frac{n}{d}\rfloor)$$
用整除分块就可以做了
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int maxn=5e6+10;
bool isprime[maxn];
int miu[maxn],prime[maxn],tot,Sum[maxn];
const long long mod=1e9+7;
void init(){
	memset(isprime,0xff,sizeof isprime);
	tot=0;miu[1]=1;
	for(int i=2;i<maxn;i++){
		if(isprime[i])
			prime[++tot]=i,miu[i]=-1;
		for(int j=1;j<=tot&&i*prime[j]<maxn;j++){
			isprime[i*prime[j]]=false;
			if(i%prime[j])
				miu[i*prime[j]]=-miu[i];
			else{
				miu[i*prime[j]]=0;
				break;
			}
		}
	}
	Sum[0]=0;
	for(int i=1;i<maxn;i++)
		Sum[i]=(Sum[i-1]+miu[i])%mod;
}
map<int,int>S;
inline int calc(int x){
	if(x<maxn)return Sum[x];
	if(S[x])return S[x];
	int ans=1;
	for(int l=2,r;l<=x;l=r+1){
		r=x/(x/l);
		ans-=calc(x/l)*(r-l+1)%mod;
		ans%=mod;
	}
	return S[x]=ans%mod;
}
template <class T>inline void read(T &x){
	x=0;char c=getchar();
	for(;!isdigit(c);c=getchar());
	for(;isdigit(c);c=getchar())x=x*10+c-'0';
	return;
}
template <class T>void write(T x){
	if(x<0)putchar('-'),x=-x;
	if(x>=10)write(x/10);
	putchar(x%10+'0');
}
long long qpow(long long a,long long b){
	long long ret=1;
	while(b){
		if(b&1)ret=(ret*a)%mod;
		a=(a*a)%mod,b>>=1;
	}
	return ret;
}
void solve(long long N,long long K,long long L,long long R){
	L=(L-1)/K,R=R/K;
	long long ans=0;
	for(int l=1,r;l<=R;l=r+1){
		r=min(R/(R/l),(L/l)?L/(L/l):0x3f3f3f3f3f3f3f3f);
		ans=(ans+1ll*(calc(r)-calc(l-1))*qpow((R/l)-(L/l),N))%mod;
		//printf("%lld %lld %lld\n",l,r,ans);
	}
	write((ans+mod)%mod);putchar('\n');
}

signed main(){
	init();
	long long N,K,L,R;
	read(N);read(K);read(L);read(R);
	solve(N,K,L,R);
}
```

---

## 作者：Freopen (赞：3)

这个做法是O(sqrt(n) * log(n) + n)的。
先将所有数除上k，不能整除的直接排除（即将l=l/k,h=h/k,具体看代码）。
那么我们的问题就是
求选数N次使选出的数最大公约数为1的方案数。
然后我们设f[a]= gcd=a的方案数。
如何求f[a]?
设F[a]= a|gcd的方案数。
网上的另一种做法就是f[a] = F[a] - sigma(a|d && a!=d,f[d])
但是d是1e9级别的，注意到H-L<=1e5
显然如果选的数不是完全相同，那么gcd<=1e5
所以改一改f和F的定义就行。
f[a]= gcd=a且数不全相同的方案数。
F[a]= a|gcd且数不全相同的方案数。
那么枚举1~H-L就行，最后特判一下全选1的情况。

可是这种做法好像浪费了a|d这个分块优化的好机会。
我的做法:
由： F[a] = sigma(a | d , f[d])
有:  f[a] = sigma(a | d, mu[d / a] * F[d])
= sigma(a | d,mu[d/a] * ((H / d - (L-1) / d)^n - (H / d - (L-1) / d) ) )
线性筛一下mu前缀和就行。
（如果不知道如何利用 H-L<=1e5 ，直接上杜教筛也就200ms）

0ms代码：
```cpp
/*

f[i] = ans for gcd = i
F[i] = ans for i | gcd
F[i] = Σ(i |d) f[d]
f[i] = Σ(i |d) mu[d] * F[d]
and we can prove that gcd is less than H-L(1e5)
f[1] = Σ(d<=H-L) mu[d] * F[d] = Σ(d<=H-L) mu[d] * (the number of d's mutiple) ^ n

*/
#include<cstdio>
#include<cstring>
#include<cctype>
#include<algorithm>
#define maxn 100005
#define inf 0x3f3f3f3f
#define mod 1000000007
using namespace std;

int n,k,l,h;
inline int Pow(int base ,int k,int P)
{
	int ret=1;
	for(;k;k>>=1,base=1ll*base*base % P) if(k&1) ret=1ll*ret*base % P;
	return ret;
}

int S[maxn],mu[maxn],pr[maxn/9],cnt_pr;
bool vis[maxn];
void Mobius(int lim)
{
	S[1]=mu[1]=1;
	for(int i=2;i<=lim;i++)
	{
		if(!vis[i]){ pr[cnt_pr++]=i,mu[i]=-1; }
		for(int j=0;j<cnt_pr && pr[j] * i<=lim;j++)
		{
			vis[i*pr[j]]=1;
			if(i%pr[j]==0){ mu[i*pr[j]]=0;break; }
			mu[i*pr[j]]=-mu[i];
		}
		S[i]=(S[i-1]+mu[i])%mod;
	}
}

int main()
{
	scanf("%d%d%d%d",&n,&k,&l,&h);
	int ans=0;
	l=(l-1)/k;
	h=h/k;
	
	int lim=h-l-1;
	Mobius(lim);	
	for(int now=1,nxt;now<=lim;now=nxt+1)
	{
		nxt=min(h/(h/now),(l/now) ? l/(l/now):inf);
		ans=(ans+1ll * (S[nxt]-S[now-1]) * ((Pow(h/now-l/now,n,mod)) - (h/now - l/now))%mod)%mod;
	}
	printf("%d\n",(ans+mod+(l==0))%mod);
}
```

---

## 作者：wsyhb (赞：2)

## 题意简述

给定 $N,K,L,H$，求下列表达式的值：

$$\sum_{a_1=L}^{H}\sum_{a_2=L}^{H}\cdots\sum_{a_N=L}^{H}[\gcd(a_1,a_2,\cdots,a_N)=K] \pmod{10^9+7}$$

**数据范围**：$1 \le N,K,L,H \le 10^9$，$0 \le H-L \le 10^5$。

## 法一

考虑 $\gcd$ 的性质：当 $a > b$ 时，$\gcd(a,b)=\gcd(a-b,b) \le a-b$。

那么，**当 $a_1,a_2,\cdots,a_N$ 不全相同时，必有 $\gcd(a_1,a_2,\cdots,a_N) \le H-L$**，其中 $a_i \; (1 \le i \le N)$ 的值域为 $[H,L]$。

当 $a_1=a_2=\cdots=a_N=v$ 时，$\gcd(a_1,a_2,\cdots,a_N)=v$，对答案的贡献为 $[H \le K \land K \le L]$（$\land$ 表示逻辑且）。

于是我们只需考虑 $a_1,a_2,\cdots,a_N$ 不全相同的情况。（**下文属于【法一】的部分默认 $a_1,a_2,\cdots,a_N$ 不全相同**）

------------

根据**莫比乌斯反演**的套路，设：

$$f(n)=\sum_{a_1=L}^{H}\sum_{a_2=L}^{H}\cdots\sum_{a_N=L}^{H}[\gcd(a_1,a_2,\cdots,a_N)=n]$$

$$g(n)=\sum_{a_1=L}^{H}\sum_{a_2=L}^{H}\cdots\sum_{a_N=L}^{H}[n \mid \gcd(a_1,a_2,\cdots,a_N)]$$

则 $g(n)=\sum_{n \mid d}f(d)$，反演得 $f(n)=\sum_{n \mid d}g(d)\mu(\dfrac{d}{n})$。

由于 $\gcd(a_1,a_2,\cdots,a_N) \le H-L$，因此 $f,g$ 至多只在 $1,2,\cdots,H-L$ 处不为 $0$。（**即枚举的倍数 $d$ 的上限为 $H-L$**）

由于区间 $[L,H]$ 中 $n$ 的倍数有 $\lfloor \dfrac{H}{n} \rfloor-\lceil \dfrac{L}{n} \rceil +1$ 个，则：

$$g(n)=(\lfloor \dfrac{H}{n} \rfloor-\lceil \dfrac{L}{n} \rceil +1)^N-(\lfloor \dfrac{H}{n} \rfloor-\lceil \dfrac{L}{n} \rceil +1)$$

（注意去除 $a_1=a_2=\cdots=a_N$ 的情况）

------------

**线性筛**预处理 $1,2,\cdots,H-L+1$ 的 $N$ 次方及其 $\mu$ 值，即可 $O(1)$ 求解单个 $g(n)$。

进一步，即可在 $O(\dfrac{H-L}{K})$ 的时间内求解 $f(K)$。

答案即为 $f(K)+[H \le K \land K \le L]$。

总时间复杂度为 $O(H-L)$。

## 法二

令 $X=\lceil \dfrac{L}{K} \rceil$，$Y=\lfloor \dfrac{H}{K} \rfloor$，则所求式子等价于：

$$\sum_{b_1=X}^{Y}\sum_{b_2=X}^{Y}\cdots\sum_{b_N=X}^{Y}[\gcd(b_1,b_2,\cdots,b_N)=1]$$

即枚举 $b_i=\dfrac{a_i}{K}$。（显然 $a_i$ 是 $K$ 的倍数）

将 $[x=1]=\sum_{d \mid x}\mu(d)$ 代入得：

$$\sum_{b_1=X}^{Y}\sum_{b_2=X}^{Y}\cdots\sum_{b_N=X}^{Y}\sum_{d \mid \gcd(b_1,b_2,\cdots,b_N)}\mu(d)$$

交换求和符号得：

$$\sum_{d=1}^{Y}\mu(d)\sum_{b_1=X}^{Y}\sum_{b_2=X}^{Y}\cdots\sum_{b_N=X}^{Y}[d \mid \gcd(b_1,b_2,\cdots,b_N)]$$

由于区间 $[X,Y]$ 中 $d$ 的倍数有 $\lfloor \dfrac{Y}{d} \rfloor-\lceil \dfrac{X}{d} \rceil +1$ 个（此处 $X \le Y$，因此**注意特判 $X>Y$ 的情况**），则式子化为：

$$\sum_{d=1}^{Y}\mu(d)(\lfloor \dfrac{Y}{d} \rfloor-\lceil \dfrac{X}{d} \rceil +1)^{N}$$

对于 $\lceil \dfrac{X}{d} \rceil$，有两种处理方式：

1. $\lceil \dfrac{X}{d} \rceil=\lfloor \dfrac{X}{d} \rfloor+1-[X \bmod d =0]$
	- 即把 $\lceil \dfrac{X}{d} \rceil$ 看成 $\lfloor \dfrac{X}{d} \rfloor$ 进行计算，最后再枚举 $X$ 的约数 $d$，把这些项重新算一遍。
1. $\lceil \dfrac{X}{d} \rceil=\lfloor \dfrac{X-1}{d} \rfloor+1$。
	- 证明的话可以分 $X-1$ 是否是 $d$ 的倍数两种情况进行讨论。
	- 当然更好的理解方式是使用前缀作差，即区间 $[X,Y]$ 中 $d$ 的倍数的个数为：区间 $[1,Y]$ 中 $d$ 的倍数的个数减去区间 $[1,X-1]$ 中 $d$ 的倍数的个数，即 $\lfloor \dfrac{Y}{d} \rfloor-\lfloor \dfrac{X-1}{d} \rfloor$。

**线性筛**预处理 $1$ 至 $Y-X+1$ 的 $N$ 次方，然后就可以使用**整除分块+杜教筛**了。（不会杜教筛的请移步至：[洛谷 P4213 【模板】杜教筛（Sum）](https://www.luogu.com.cn/problem/P4213)，模板就正好要求 $\sum_{i=1}^{N}\mu(i)$）

如果使用第一种处理方式，还需要 $O(\sqrt{X})$ 枚举约数，把这些项重新算一遍。而求这些项的 $\mu$ 就直接 $O(\sqrt{v})$ 分解质因数即可。（$v$ 指这些项的值）

## 代码

### 法一

``` cpp
#include<bits/stdc++.h>
using namespace std;
const int mod=1e9+7;
inline int qpow(int a,int n)
{
	int res=1;
	while(n)
	{
		if(n&1)
			res=1ll*res*a%mod;
		a=1ll*a*a%mod;
		n>>=1;
	}
	return res;
}
int N,K,L,H;
const int max_R=1e5+5;
bool mark_p[max_R];
int prime[max_R],cnt,mu[max_R],Pow[max_R];
inline void init()
{
	int R=H-L+1;
	for(int i=2;i<=R;++i)
		mark_p[i]=true;
	mu[1]=Pow[1]=1;
	for(int i=2;i<=R;++i)
	{
		if(mark_p[i])
		{
			prime[++cnt]=i;
			mu[i]=-1;
			Pow[i]=qpow(i,N);
		}
		for(int j=1;j<=cnt&&i*prime[j]<=R;++j)
		{
			mark_p[i*prime[j]]=false;
			Pow[i*prime[j]]=1ll*Pow[i]*Pow[prime[j]]%mod;
			if(i%prime[j]==0)
				break;
			mu[i*prime[j]]=-mu[i];
		}
	}
}
inline int g(int x)
{
	int cnt=H/x-(L+x-1)/x+1;
	return Pow[cnt]-cnt+mod;
}
int main()
{
	scanf("%d%d%d%d",&N,&K,&L,&H);
	init();
	int ans=0;
	for(int d=K,i=1;d<=H-L;d+=K,++i)
		ans=(ans+1ll*g(d)*(mu[i]+mod))%mod;
	if(K>=L&&K<=H)
	{
		++ans;
		ans-=ans>=mod?mod:0;
	}
	printf("%d\n",ans);
	return 0;
}
```

### 法二

下面贴的代码使用了第二种处理方式，使用了第一种处理方式的代码见[洛谷 P3172 [CQOI2015]选数 代码](https://www.luogu.com.cn/paste/b33f5geu)。

``` cpp
#include<bits/stdc++.h>
using namespace std;
const int mod=1e9+7;
inline int qpow(int a,int n)
{
	int res=1;
	while(n)
	{
		if(n&1)
			res=1ll*res*a%mod;
		a=1ll*a*a%mod;
		n>>=1;
	}
	return res;
}
const int R=1e6;
const int max_R=R+5;
bool mark_p[max_R];
int prime[max_R],cnt,mu[max_R],sum_mu[max_R];
const int max_B=1e5+5;
int Pow[max_B];
inline void init(int B,int N)
{
	for(int i=2;i<=R;++i)
		mark_p[i]=true;
	mu[1]=sum_mu[1]=1;
	for(int i=2;i<=R;++i)
	{
		if(mark_p[i])
		{
			prime[++cnt]=i;
			mu[i]=-1;
		}
		for(int j=1;j<=cnt&&i*prime[j]<=R;++j)
		{
			mark_p[i*prime[j]]=false;
			if(i%prime[j]==0)
				break;
			mu[i*prime[j]]=-mu[i];
		}
		sum_mu[i]=sum_mu[i-1]+mu[i];
	}
	Pow[1]=1;
	for(int i=2;i<=B;++i)
	{
		if(mark_p[i])
			Pow[i]=qpow(i,N);
		for(int j=1;j<=cnt&&i*prime[j]<=B;++j)
		{
			Pow[i*prime[j]]=1ll*Pow[i]*Pow[prime[j]]%mod;
			if(i%prime[j]==0)
				break;
		}
	}
}
map<int,bool> vis;
map<int,int> Sum_mu;
inline int calc_sum_mu(int n)
{
	if(n<=R)
		return sum_mu[n];
	if(vis[n])
		return Sum_mu[n];
	int res=1;
	for(int i=2,j;i<=n;i=j+1)
	{
		int v=n/i;
		j=n/v;
		res-=calc_sum_mu(v)*(j-i+1);
	}
	vis[n]=true;
	return Sum_mu[n]=res;
}
int main()
{
	int N,K,L,H;
	scanf("%d%d%d%d",&N,&K,&L,&H);
	int X=(L+K-1)/K,Y=H/K;
	if(X>Y)
	{
		puts("0");
		return 0;
	}
	init(Y-X+1,N);
	int ans=0,Last=0;
	for(int i=1,j;i<=X-1;i=j+1)
	{
		int v1=(X-1)/i,v2=Y/i;
		j=min((X-1)/v1,Y/v2);
		int now=calc_sum_mu(j);
		ans=(ans+1ll*(now-Last)*Pow[v2-v1])%mod;
		Last=now;
	}
	for(int i=X,j;i<=Y;i=j+1)
	{
		int v=Y/i;
		j=Y/v;
		int now=calc_sum_mu(j);
		ans=(ans+1ll*(now-Last)*Pow[v])%mod;
		Last=now;
	}
	ans+=ans<0?mod:0;
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：tzc_wk (赞：1)

一种用了反演，却没上杜筛的 solution（

首先由于 $\gcd$ 必须为 $k$ 这个限制的存在，我们所选出来的数必须都是 $k$ 的倍数，因此我们可以考虑将 $L,R$ 分别变为 $\lceil\dfrac{L}{k}\rceil,\lfloor\dfrac{R}{k}\rfloor$，这样限制即可转化为选出的数的 $\gcd$ 必须为 $1$。

还是考虑反演

$$
\begin{aligned}
ans&=\sum\limits_{i=1}^R\mu(i)\text{id}_n(\lfloor\dfrac{R}{i}\rfloor-\lfloor\dfrac{L-1}{i}\rfloor)
\end{aligned}
$$

到这里，大部分人都是对 $i$ 整除分块+杜筛求 $\mu$ 的前缀和，这里提供一个不太一样的解法，我们考虑对 $i\in[1,R-L+1]$ 暴力地求解上面式子，对于 $i>R-L+1$，如果 $\lfloor\dfrac{R}{i}\rfloor-\lfloor\dfrac{L-1}{i}\rfloor\ne 0$，必然有 $\lfloor\dfrac{R}{i}\rfloor-\lfloor\dfrac{L-1}{i}\rfloor=1$，也就是说 $i>R-L+1$ 的贡献就是所有 $[L,R]$ 中的数的因子的并与 $[R-L+2,\infty)$ 交中所有数的 $\mu$ 之和，那么怎么求这个值呢，考虑 $x\in[L,R]$，有 $\sum\limits_{d\mid x}\mu(d)=\epsilon(x)$，我们扣掉 $d\le R-L+1$ 的部分，可以得到 $\epsilon(x)-\sum\limits_{d\mid x,d\le R-L+1}\mu(d)=\sum\limits_{d>R-L+1,d\mid x}\mu(d)$，而根据“对于 $>R-L+1$ 的因子，每个因子最多是 $[L,R]$ 中一个数的约数”这个性质，$>R-L+1$ 的因子的贡献就是每个 $x$ 等式右边的值相加，因此我们可以拿 $\sum\limits_{i=L}^R\epsilon(i)$ 减去 $\sum\limits_{x=L}^R\sum\limits_{d\mid x,d\le R-L+1}\mu(d)$ 算出右式的值，前者简单特判即可，后者每枚举一个 $d\le R-L+1$ 都调和级数地累加下贡献即可，这样最后复杂度就是 $\mathcal O((R-L+1)\log(R-L+1))$

```cpp
const int MAXV=1e5;
const int MOD=1e9+7;
int qpow(int x,int e){
	int ret=1;
	for(;e;e>>=1,x=1ll*x*x%MOD) if(e&1) ret=1ll*ret*x%MOD;
	return ret;
}
int x,l,r,k,s[MAXV+5];
int mu[MAXV+5],pr[MAXV/6+5],prcnt=0,pw[MAXV+5];
bitset<MAXV+5> vis;
void sieve(int n){
	pw[1]=mu[1]=1;
	for(int i=2;i<=n;i++){
		if(!vis[i]) pr[++prcnt]=i,mu[i]=-1,pw[i]=qpow(i,x);
		for(int j=1;j<=prcnt&&pr[j]*i<=n;j++){
			vis[pr[j]*i]=1;pw[i*pr[j]]=1ll*pw[i]*pw[pr[j]]%MOD;
			if(i%pr[j]==0) break;mu[i*pr[j]]=-mu[i];
		}
	}
}
int main(){
	scanf("%d%d%d%d",&x,&k,&l,&r);l=(l-1)/k+1;r=r/k;
	sieve(MAXV);if(l>r) return puts("0"),0;int res=0;
	for(int i=1;i<=MAXV;i++){
		res=(res+1ll*mu[i]*pw[r/i-(l-1)/i]+MOD)%MOD;
		if(mu[i]){
			for(int j=(l+i-1)/i*i;j<=r;j+=i) s[j-l+1]=(s[j-l+1]-mu[i]+MOD)%MOD;
		}
	} for(int i=l;i<=r;i++) if(i^1) res=(res+s[i-l+1])%MOD;
	printf("%d\n",res);
	return 0;
}
/*
1000 1 1000000007 1000000009
*/
```

---

## 作者：ricky0916 (赞：1)

考虑容斥（的思想）

令$ f(n) $表示在$ [L,H] $中最大公约数为$ n $的种数

此时令$ x $为在$ [L,H] $区间内有多少数整除$ K $（即$ x=\sum_{i=L}^H[K|i] $）

再令$ g(n)=\sum_{n|i}f(i) $（表示在$ [L,H] $中取$ N $个数的最大公约数整除$ n $的种数）

~~易知~~ $ 1.g(n)=x^N-x $

$ 2.f(n)=g(n)-\sum_{n|i}f(i)+f(n) $~~（这不是废话）~~

所以只要倒着递推就行了~~（这真的是紫题吗）~~

但是

如果求$ x $直接抄式子并且$ TLE $ $90$分的话，那么就恭喜 ~~（终于有一个人跟我一样菜了哈哈哈）~~

显然可以将$ x $的式子改写成$ \lfloor \frac{H}{K} \rfloor-\lceil \frac{L}{K} \rceil $，那$ O(1) $不香吗 ~~（（（~~

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int mod=1e9+7;
int ksm(int n,int m,int p){
    if(!m) return 1;
    if(m&1) return 1ll*ksm(1ll*n*n%p,m/2,p)*n%p;
    return 1ll*ksm(1ll*n*n%p,m/2,p);
}
int n,k,l,h,f[100010];
int g(int x){
    return (ksm(x,n,mod)-x+mod)%mod;
}
void work(int k){
    int cnt=h/k-(l+k-1)/k+1;
    f[k]=g(cnt);
    for(int i=2*k;i<=h-l;i+=k){
        f[k]-=f[i];
        f[k]+=mod;
        f[k]%=mod;
    }
}
int main(){
    //if(n==2&&k==3&&l==100&&h==100000){
    	//printf("674124662");
    	//return 0;
	//}
    scanf("%d%d%d%d",&n,&k,&l,&h);
    l=(l+k-1)/k;
    h/=k;
    for(int i=h-l;i;i--) work(i);
    printf("%d",f[1]+(l==1));
    return 0;
}
```


---

## 作者：DrLin (赞：1)

# [推荐点这里观看](https://www.cnblogs.com/linzhuohang/p/13544978.html)

# 题目
我们知道，从区间[L,H]（L和H为整数）中选取N个整数，总共有(H-L+1)^N种方案。小z很好奇这样选出的数的最大公约数的规律，他决定对每种方案选出的N个整数都求一次最大公约数，以便进一步研究。然而他很快发现工作量太大了，于是向你寻求帮助。你的任务很简单，小z会告诉你一个整数K，你需要回答他最大公约数刚好为K的选取方案有多少个。由于方案数较大，你只需要输出其除以1000000007的余数即可。
# 题解
按照求区间gcd的套路，我们对所有数除以k.对应的将l和r也除以k

这样目标就是在$(l,r]$内找n个gcd恰好为1的数

我们设 $tot[i]$ 表示gcd恰好为i的方案数，$tot2[i]$ 表示gcd为i或i的倍数方案数。

仿照之前的套路，设$x=l/i,y=r/i$

则在$(x.y]$中任意取n个数都是满足要求的

则$tot2[i]=(y-x)^n$

则$tot[i]=tot2[i]-(y-x)-tot[i*2]-tot[i*3]...$

因为gcd最大只能到$r-l$（再大r就等于l了，这个区间就没东西了）

所以i只用枚举到$r-l$

减去$y-x$是因为如果选n个同样的数a,那么他们的gcd就是a

而a是1e9级别的，在上式中无法排除，所以我们在上式中减去。

但如果k在$(l,r]$内，则全部选k也是合法的答案，要加回一

最后是时间复杂度，设$n=r-l$

上述过程复杂度为 $n/1+n/2+n/3+n/4+..+n/n$

这是一个调和级数，复杂度是$O(nlogn)$

证明：

上式可以放大成 $n/1+n/2+n/2+n/4+n/4+n/4+n/4+..+n/n$

等于$n/1+n/2*2+n/4*4+n/8*8+n/4+...$

也就是 $nlogn$

上面用的都是前开区间，所以要将题目输入的l减一

# 代码
```cpp
#include <iostream>
#include <cstdio>
using namespace std;
#define N 100010
#define int long long 
#define mod 1000000007
int tot[N];//gcd刚好是i的情况数（在除了k的情况下） 
int qpow(int a,int b)
{
	int ans=1;
	while(b)
	{
		if(b&1) ans*=a,ans%=mod;
		a*=a;
		a%=mod;
		b>>=1;
	}
	return ans;
}
signed main()
{
	int n,k,l,r;
	cin>>n>>k>>l>>r;
	bool tag=(k>=l&&k<=r);//如果gcd在区间内，那么都选gcd这一位也是合法的 
	l--;
	l/=k,r/=k;
	int len=r-l;
	for(int i=len;i;i--)
	{
		int x=l/i,y=r/i;
		if(x>=y) continue;
		tot[i]=qpow(y-x,n)-(y-x);//减去都选同一位的情况 
		for(int j=2;i*j<=len;j++) tot[i]+=mod-tot[i*j],tot[i]%=mod; //减去选择的方案gcd为i的倍数的情况 ，使gcd恰好为i 
	}
	cout<<tot[1]+tag;
}
```


---

## 作者：china·xyc (赞：1)

#### 题面
$\sum_{L}^{H}\sum_{L}^{H}...\sum_{L}^{H}[gcd(a_1,a_2,...,a_n)=k]$（n个sigma）

#### 题解
这题比较创新的地方是选出n个数，但是由于之前做过选4个数的题，看到这道就直接秒了。

最后的式子是这个：
$$\sum_{d=1}^{H}(\lfloor\frac{r}{d}\rfloor-\lfloor\frac{l}{d}\rfloor)^n\mu(d)$$

看到这题的数据范围发现需要杜教筛，于是再套一个杜教筛。

放代码：
```cpp# include <bits/stdc++.h>
using namespace std;
namespace fastio{
	template<typename tn> void read(tn &a){
	    tn x=0,f=1;char c=' ';
	    for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
	    for(; isdigit(c);c=getchar() ) x=x*10+c-'0';
	    a=x*f;
	}
	template<typename tn> void print(tn a){
	    if(a<0) putchar('-'),a=-a;
	    if(a>9) print(a/10);
	    putchar(a%10+'0');
	}
};
using namespace fastio;
const int N=1e7+5;
const int mod=1e9+7;
const int inf=2e9;
int poww(int a,int b){
	int ans=1;
	while(b){
		if(b&1) ans=1ll*ans*a%mod;
		b>>=1;
		a=1ll*a*a%mod;
	}
   	return ans;
}
int n,k,x,y;
int mu[N],prime[N>>2],cnt;
bool is_prime[N];
map<int,int> ansmu; 
int Sum(int n){
	if(n<N) return mu[n];
	if(ansmu[n]) return ansmu[n];
	int ans=0;
	for(int l=2,r;l<=n;l=r+1){
		r=n/(n/l);
		ans=1ll*(ans+1ll*Sum(n/l)*(r-l+1)%mod)%mod;
	}
	return ansmu[n]=1ll-ans;
}
int ans;
int main(){
	read(n);
	read(k);
	read(x);
	read(y);
	--x/=k;
	y/=k;
	mu[1]=1;
	for(int i=2;i<N;i++){
		if(!is_prime[i]) prime[++cnt]=i,mu[i]=-1;
		for(int j=1;j<=cnt&&prime[j]*i<N;j++){
			is_prime[prime[j]*i]=1;
			if(i%prime[j]==0){
				mu[i*prime[j]]=0;
				break;
			}
			mu[i*prime[j]]=-mu[i];
		}
		mu[i]=(mu[i-1]+mu[i])%mod; 
	}
	for(int l=1,r;l<=y;l=r+1){
		r=min(x/l?x/(x/l):inf,y/(y/l));
		int a=x/l;
		int b=y/l;
		ans=1ll*(ans+1ll*poww(b-a,n)*(Sum(r)-Sum(l-1))%mod)%mod;
	}
	printf("%d\n",ans);
	return 0;
}
```
de出来的bug：

 - `x/l?x/(x/l):inf`这个特判
 - `--x/=k;`这个特判

总之这题也比较细节


---

## 作者：huangzirui (赞：1)

如果 $\LaTeX$ 崩了 请到[博客](https://www.luogu.com.cn/blog/My-luoguBuoke-HZR/solution-p3172)查看QAQ

题意：

求：

$$\sum_{a_1=L}^H\sum_{a_2=L}^H\dots\sum_{a_n=L}^H[(a_1,a_2\ ...\ a_n)=k]$$

$n,k,L,H \leq 10^9\ \ \ \ \ \ H-L\leq 10^5$

---
不管那么多，我们按照套路同时除以 $k$ ：

$$

\sum_{a_1=\left\lfloor{\frac{L-1}{k}}\right\rfloor+1}^{\left\lfloor{\frac{H}{k}}\right\rfloor}

\sum_{a_2=\left\lfloor{\frac{L-1}{k}}\right\rfloor+1}^{\left\lfloor{\frac{H}{k}}\right\rfloor}

\dots

\sum_{a_n=\left\lfloor{\frac{L-1}{k}}\right\rfloor+1}^{\left\lfloor{\frac{H}{k}}\right\rfloor}

[(a_1,a_2\ ...\ a_n)=1]

$$

(以下设 $l=\left\lfloor{\frac{L-1}{k}}\right\rfloor+1,r=\left\lfloor{\frac{H}{k}}\right\rfloor$)

$$
\sum_{a_1=l}^{r}
\sum_{a_2=l}^{r}
\dots
\sum_{a_n=l}^{r}
[(a_1,a_2\ ...\ a_n)=1]
$$

最后那个式子好熟悉！强行 Mobius 反演一波！

$$
\sum_{a_1=l}^{r}
\sum_{a_2=l}^{r}
\dots
\sum_{a_n=l}^{r}
\sum_{d|a_1...a_n}\mu(d)
$$

提到前面来：

$$
\sum_{d=1}^{r}
\mu(d)
\sum_{a_1=\left\lfloor{\frac{l-1}{d}}\right\rfloor+1}^{\left\lfloor{\frac{r}{d}}\right\rfloor}
\sum_{a_2=\left\lfloor{\frac{l-1}{d}}\right\rfloor+1}^{\left\lfloor{\frac{r}{d}}\right\rfloor}
\dots
\sum_{a_n=\left\lfloor{\frac{l-1}{d}}\right\rfloor+1}^{\left\lfloor{\frac{r}{d}}\right\rfloor}
$$

$$
\sum_{d=1}^{r}
\mu(d)
({\left\lfloor{\tfrac{r}{d}}\right\rfloor-\left\lfloor{\tfrac{l-1}{d}}\right\rfloor})^n
$$

这个式子真的是非常优美。。和一开始的式子比起来漂亮多了。

于是杜教筛即可。

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
inline ll read(){
	char c=getchar();ll x=0,f=1;
    while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
    while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}
    return x*f;
}
const ll N=5e6,mod=1000000007;
ll i,j,k,n,m,L,R,l,r;
ll is_prime[N],prime[N],num,mu[N],Mu[N];
void init(){
	mu[1]=1;
	for(ll i=2;i<N;i++)is_prime[i]=1;
	for(ll i=2;i<N;i++){
		if(is_prime[i])prime[++num]=i,mu[i]=-1;
		for(ll j=1;j<=num && prime[j]*i<N;j++){
			is_prime[prime[j]*i]=0;
			if(i%prime[j]==0)break;
			mu[i*prime[j]]=-mu[i];
		}
	}
	for(ll i=1;i<N;i++)Mu[i]=(Mu[i-1]+mu[i])%mod;
}
map<ll,ll>M;
ll get_mu(ll now){
	if(now<N)return Mu[now];
	if(M[now])return M[now];
	ll ans=1;
	for(ll l=2,r=0;l<=now;l=r+1){
		r=now/(now/l);
		ans-=(r-l+1)*get_mu(now/l)%mod;
		ans=(ans%mod+mod)%mod;
	}
	return M[now]=ans;
}
ll ksm(ll sum,ll num){
	ll ans=1;
	while(num){
		if(num&1)ans=ans*sum%mod;
		sum=sum*sum%mod;
		num>>=1;
	}return ans;
}
int main(){
	init();
	cin>>n>>k>>L>>R;
	L=(L-1)/k+1;R/=k;
	ll ans=0;
	for(ll l=1,r=0;l<=R;l=r+1){
		if((L-1)>=l)r=min((L-1)/((L-1)/l),R/(R/l));
		else r=R/(R/l);
		ans=(ans+ksm(R/l-(L-1)/l,n)*(get_mu(r)-get_mu(l-1))%mod)%mod;
	}cout<<(ans+mod)%mod<<endl;
	return 0;
}
```

---

## 作者：w36557658 (赞：1)

如果觉得题解写的不错的话欢迎访问我的原博客题解：http://www.cnblogs.com/luyouqi233/p/8625321.html

（洛谷神仙们的题解对于我这样的数论菜鸡好难懂啊，于是写的详细些，可能过于冗长请大佬不要鄙视。）


------------

首先想到莫比乌斯反演，~~各位大佬的dp都是怎么想到的啊喂。~~

先行特判掉$n=1$和$l>r$和$k>r$的情况。

那么开始推式子，注意为了本人的习惯把h改为了r：

$\sum_{i_1=l}^r\sum_{i_2=l}^r\cdots\sum_{i_n=l}^r[gcd(i_1,i_2,\cdots,i_n)=k]$

$=\sum_{i_1=\lceil\frac{l}{k}\rceil}^{\lfloor\frac{r}{k}\rfloor}\sum_{i_2=\lceil\frac{l}{k}\rceil}^{\lfloor\frac{r}{k}\rfloor}\cdots\sum_{i_n=\lceil\frac{l}{k}\rceil}^{\lfloor\frac{r}{k}\rfloor}[gcd(i_1,i_2,\cdots,i_n)=1]$

$=\sum_{i_1=\lceil\frac{l}{k}\rceil}^{\lfloor\frac{r}{k}\rfloor}\sum_{i_2=\lceil\frac{l}{k}\rceil}^{\lfloor\frac{r}{k}\rfloor}\cdots\sum_{i_n=\lceil\frac{l}{k}\rceil}^{\lfloor\frac{r}{k}\rfloor}\sum_{d|gcd(i_1,i_2,\cdots,i_n)}\mu(d)$

$=$拆$gcd$的套路(为了方便起见，下文开始$\lfloor\frac{r}{k}\rfloor=r,\lceil\frac{l}{k}\rceil=l$)

$=\sum_{d=1}^{r-l}(l$到$r$的$d$的倍数的个数$)^n\mu(d)$


------------

PS1：这里有一个奇妙的性质那就是在$[l,r]$区间中任取两个不相等的数，则他们的最大公约数不大于$r-l$。

问了数竞大佬，貌似给了一个靠谱的证明？

我们取$ij$两个互质的数，显然它们$gcd=1$，那么我们给他们同时乘数m，则它们的$gcd=m$，而$r-l$最小即为$(j-i)*m>=m$，问题得证。


------------

PS2：为什么括号内不是一个式子呢，因为注意对于有相同数的数对我们没法处理，所以要减去它们，于是边算边记录每个数的出现次数，最后的$cnt[i]$表示的就是有两个或以上$i$的数对的个数，答案减去它们即可。

同时注意如果$l=1$的话则$l$到$r$之间存在$k$所以$n$个$k$是成立的于是不能多减。

处理$cnt$用跳着枚举的方法，不过复杂度并没因此变高到哪里去。

本蒟蒻不太会算复杂度，大概是$O((r-l)*(1/1+1/2+...+1/(r-l))=$ $O((r-l)log(r-l))$，如果对$\mu=0$的情况特判掉的话复杂度会再次减少

```
#include<cstdio>
#include<queue>
#include<map>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
typedef long long ll;
const int N=1e5+5;
const ll p=1e9+7;
ll n,k,l,r,su[N],miu[N],cnt[N];
bool he[N];
ll pow(ll x,ll y){
    ll res=1;
    while(y){
        if(y&1)res=res*x%p;
        x=x*x%p;
        y>>=1;
    }
    return res;
}
void Euler(int n){
    int tot=0;
    miu[1]=1;    
    for(int i=2;i<=n;i++){    
        if(!he[i]){   
            su[++tot]=i;    
            miu[i]=-1;
        }    
        for(int j=1;j<=tot;j++){    
            if(i*su[j]>n)break;    
            he[i*su[j]]=1;   
            if(i%su[j]==0){    
                miu[i*su[j]]=0;break;    
            }    
            else miu[i*su[j]]=-miu[i];  
        }
    }
    return;
}
int main(){
    scanf("%lld%lld%lld%lld",&n,&k,&l,&r);
    if(l>r||k>r){
    	puts("0");
    	return 0;
    }
    if(n==1){
	    if(l<=k&&k<=r)puts("1");
	    else puts("0");
	    return 0;
	}
    Euler(1e5);
    l=(l%k!=0)+l/k;r/=k;
    ll ans=0;
    for(int i=r-l;i>=1;i--){
	    if(miu[i]){
	        int j=l,tot=0;
	        if(j%i!=0)j=j/i*i+i;
		    while(j<=r){
		       	cnt[j-l]+=miu[i];
		        j+=i;tot++;
	        }
	        ans=(ans+miu[i]*pow(tot,n)%p)%p;
	    }
    }
    for(int i=r-l;i>=1;i--){
   		ans=(ans-cnt[i])%p;
    }
    if(l==1)ans=(ans-(cnt[0]-1))%p;
    else ans=(ans-cnt[0])%p;
    printf("%lld\n",(ans+p)%p);
    return 0;
}
```

---

## 作者：Rubyonly (赞：0)

问题可以直接转化为一个式子，然后进行化简

$$
\begin{aligned}
\sum_{i=L}^H\sum_{j=L}^H[\gcd(i,j)=k]
&=\sum_{i=\lfloor \frac{L}{k} \rfloor}^{\lfloor \frac{H}{k} \rfloor}\sum_{j=\lfloor \frac{L}{k} \rfloor}^{\lfloor \frac{H}{k} \rfloor}[\gcd(i,j)=1]\\
&=\sum_{i=\lfloor \frac{L}{k} \rfloor}^{\lfloor \frac{H}{k} \rfloor}\sum_{j=\lfloor \frac{L}{k} \rfloor}^{\lfloor \frac{H}{k} \rfloor}\sum_{d|i,d|j}\mu(d)\\
&=\sum_{i=\lfloor \frac{L}{k} \rfloor}^{\lfloor \frac{H}{k} \rfloor}\sum_{j=\lfloor \frac{L}{k}\rfloor}^{\lfloor \frac{H}{k} \rfloor}\sum_{d|i,d|j}\mu(d)\\
&=\sum_{d=1}^{\lfloor \frac{H}{k} \rfloor}\mu(d)
\sum_{i=\lfloor \frac{L}{k} \rfloor}^{\lfloor \frac{H}{k} \rfloor}\sum_{j=\lfloor \frac{L}{k}\rfloor}^{\lfloor \frac{H}{k} \rfloor}[d\mid i][d\mid j]\\
&=\sum_{d=1}^{\lfloor \frac{H}{k} \rfloor}\mu(d)
(\left \lfloor \frac{\lfloor \frac{H}{k} \rfloor}{d} \right \rfloor - \left \lfloor \frac{\lfloor \frac{L-1}{k} \rfloor}{d} \right \rfloor)^2
\end{aligned}
$$

前面的 $\mu$ 杜教筛掉就行了，外层的循环整除分块去做，总复杂度是 $\mathcal{O}(n^{\frac{2}{3}})$ 的

```c++
#include <cstdio>
#include <iostream>
#include <unordered_map>

typedef long long ll;

using namespace std;

const int mod = 1e9 + 7;

inline int addmod (register int a, register int b) {
	return a += b, a >= mod ? a - mod : a;
}

inline int delmod (register int a, register int b) {
	return a -= b, a < 0 ? a + mod : a;
}

inline ll mulmod (register ll a, register int b) {
	return a *= b, a >= mod ? a % mod : a;
}

inline int qpow (register int a, register int b, register int ans = 1) {
	for (; b; b >>= 1, a = mulmod (a, a))
		if (b & 1) ans = mulmod (ans, a);
	return ans;
}

int n, m, L, R, cnt;
int prime[3000005], mul[3000005], sum[3000005];
bool vis[3000005];
unordered_map <int, int> f;
	
inline void xxs () {
	mul[1] = sum[1] = 1;
	for (register int i = 2; i <= 3e6; i ++) {
		if (! vis[i]) prime[++ cnt] = i, mul[i] = mod - 1;
		for (register int j = 1; j <= cnt && i * prime[j] <= 3e6; j ++) {
			vis[i * prime[j]] = 1;
			if (i % prime[j] == 0) break;
			mul[i * prime[j]] = mod - mul[i];
		}
		sum[i] = addmod (sum[i - 1], mul[i]);
	}
}

inline int F (register int n, register int ans = 1) {
	if (n <= 3e6) return sum[n];
	if (f[n]) return f[n];
	for (register int l = 2, r; l <= n; l = r + 1) 
		r = n / (n / l), ans = delmod (ans, mulmod (r - l + 1, F (n / l)));
	return f[n] = ans;
}

inline int Calc (register int n, register int m, register int k, register int ans = 0) {
	for (register int l = 1, r; l <= m; l = r + 1) 
		r = n < l ? m / (m / l) : min (n / (n / l), m / (m / l)), 
		ans = addmod (ans, mulmod (delmod (F (r), F (l - 1)), qpow (delmod (m / l, n / l), k)));
	return ans;
}

int main () {
	scanf ("%d%d%d%d", &n, &m, &L, &R), L = (L - 1) / m, R = R / m, xxs ();
	return printf ("%d\n", Calc (L, R, n)), 0;
}
```

---

## 作者：Taduro (赞：0)

求 $\sum_{i_1=l}^h...\sum_{i_n=l}^h\ [gcd(i_1...i_n)=k]$

为了看起来好看~~偷懒~~，下面把$\sum_{i_1=l}^{h}...\sum_{i_n=l}^{h}$这个东西写成n=2的情况：$\sum_{i=l}^h\sum_{j=l}^k$

先提出k，枚举k的倍数
$$
\sum_{i=(l-1)/k+1}^{h/k}\sum_{j=(l-1)/k}^{h/k}[gcd(i,j)=1]
$$
套路的反演一下
$$
\sum_{i=(l-1)/k}^{h/k}\sum_{j=(l-1)/k}^{h/k}\sum_{d|i,d|j}\mu(d)
$$
改为枚举d和他的倍数
$$
\sum_{d=1}^{h/k}\mu(d)\sum_{i=\frac{l-1}{kd}}^{h/kd}\sum_{j=\frac{l-1}{kd}}^{h/kd}
$$
这时候把后面的改成应有的形式：$(\frac{h}{kd}-\frac{l-1}{kd})^n$

这样只要求出$\mu$的前缀和就好了，杜教筛盘他。

```c++
#include<map>
#include<cstdio>
#include<iostream>
#define ll long long
#define mod 1000000007
using namespace std;
int o[2000001],prime[1000010],sum[2000001];
int p,k,n,m,blo,mu[2000001];
ll ans;
inline ll ksm(ll a,ll b){
	ll num=1;
	while (b){
		if (b&1) num=num*a%mod;
		a=a*a%mod; b>>=1;
	}
	return num;
}
inline void euler(){
	o[1]=mu[1]=1;
	for (int i=2; i<=blo; i++){
		if (!o[i]){
			o[i]=1; prime[++prime[0]]=i;
			mu[i]=-1;
		}
		for (int j=1; j<=prime[0]&&i*prime[j]<=blo; j++){
			o[i*prime[j]]=1;
			if (i%prime[j]==0) break;
			mu[i*prime[j]]=-mu[i];
		}
	}
	for (int i=1; i<=blo; i++) sum[i]=sum[i-1]+mu[i];
}
map<int,int> nub;
int get_mu(int x){
	if (x<=blo) return sum[x];
	if (nub[x]) return nub[x];
	int num=1;
	for (int l=2,r; l<=x; l=r+1){
		r=x/(x/l);
		num-=(r-l+1)*get_mu(x/l);
	}
	return nub[x]=num;
	// return num;
}
int main(){
	scanf("%d%d%d%d",&p,&k,&n,&m);
	n=(n-1)/k; m=m/k;// if (!n) n++;
	blo=2e6; euler(); //printf("%d\n",blo);
	// puts("ok");
	for (int l=1,r; l<=m; l=r+1){
		if (n/l==0) r=m/(m/l);
		else r=min(n/(n/l),m/(m/l));
		// r=min(n/l?n/(n/l):(int)2e9,m/(m/l));
		ans=(ans+1LL*(get_mu(r)-get_mu(l-1))*ksm(m/l-n/l,p)%mod)%mod;
	}
	printf("%lld\n",(ans+mod)%mod);
	return 0;
}
```



---


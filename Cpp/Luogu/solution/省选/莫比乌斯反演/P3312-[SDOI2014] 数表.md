# [SDOI2014] 数表

## 题目描述

有一张 $n\times m$ 的数表，其第 $i$ 行第 $j$ 列（$1\le i\le n$，$1\le j\le m$）的数值为能同时整除 $i$ 和 $j$ 的所有自然数之和。给定 $a$，计算数表中不大于 $a$ 的数之和。

## 说明/提示

### 数据范围及约定

对于全部数据，$1\le n,m\le 10^5$，$1\le Q\le 2\times 10^4$。


## 样例 #1

### 输入

```
2
4 4 3
10 10 5```

### 输出

```
20
148```

# 题解

## 作者：Wolfycz (赞：67)

首先我们不考虑$a$的限制，那么题目要求

$$\sum\limits_{i=1}^n\sum\limits_{j=1}^m\sigma_1(\gcd(i,j))$$

我们直接枚举约数有

$$\sum\limits_{d=1}^n\sum\limits_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum\limits_{j=1}^{\lfloor\frac{m}{d}\rfloor}\sigma_1(d)[\gcd(i,j)=1]$$

然后我们把$\sigma_1$挪到前面，对最后那个式子反演一下有

$$\sum\limits_{d=1}^n\sigma_1(d)\sum\limits_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum\limits_{j=1}^{\lfloor\frac{m}{d}\rfloor}\sum\limits_{x|i,x|j}\mu(x)$$

把$x$挪到前面

$$\sum\limits_{d=1}^n\sigma_1(d)\sum\limits_{x=1}^{\lfloor\frac{n}{d}\rfloor}\mu(x)\lfloor\dfrac{n}{dx}\rfloor\lfloor\dfrac{m}{dx}\rfloor$$

我们令$T=dx$，然后更改枚举顺序有

$$\sum\limits_{T=1}^n\lfloor\dfrac{n}{T}\rfloor\lfloor\dfrac{m}{T}\rfloor\sum\limits_{d|T}\sigma_1(d)\mu(\dfrac{T}{d})$$

没有$a$的限制这题就做完了……但是现实非常骨感

我们设$g(T)=\sum\limits_{d|T}\sigma_1(d)\mu(\dfrac{T}{d})$，可以发现当$\sigma_1(d)\leqslant a$时，才会对$g(T)$产生贡献

于是我们将询问按$a$从小到大排序，枚举询问的时候，$a$变大会使得一些$\sigma_1(d)$对$g(T)$产生贡献，我们就用枚举倍数的方法来找到所有的$T$，然后我们需要动态修改$g(T)$的值，而且还要支持区间询问，因此我们使用常数较小的树状数组实现

假定所有的$\sigma_1(d)$都能产生贡献，枚举所有倍数的复杂度为$\sum\limits_{i=1}^n\dfrac{n}{i}\thickapprox n\ln n$，每次更新$g(T)$复杂度为$\log n$，则修改复杂度为$O(n\log^2n)$，每次询问需要数论分块，查询区间和复杂度为$O(\log n)$，所以总复杂度为$O(q\sqrt n\log n+n\log^2n)$

```cpp
/*program from Wolfycz*/
#include<cmath>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#define Fi first
#define Se second
#define MK make_pair
#define inf 0x7f7f7f7f
#define lowbit(x) ((x)&-(x))
using namespace std;
typedef long long ll;
typedef unsigned int ui;
typedef pair<int,int> pii;
typedef unsigned long long ull;
inline char gc(){
	static char buf[1000000],*p1=buf,*p2=buf;
	return p1==p2&&(p2=(p1=buf)+fread(buf,1,1000000,stdin),p1==p2)?EOF:*p1++;
}
inline int frd(){
	int x=0,f=1; char ch=gc();
	for (;ch<'0'||ch>'9';ch=gc())	if (ch=='-')	f=-1;
	for (;ch>='0'&&ch<='9';ch=gc())	x=(x<<3)+(x<<1)+ch-'0';
	return x*f;
}
inline int read(){
	int x=0,f=1; char ch=getchar();
	for (;ch<'0'||ch>'9';ch=getchar())	if (ch=='-')	f=-1;
	for (;ch>='0'&&ch<='9';ch=getchar())	x=(x<<3)+(x<<1)+ch-'0';
	return x*f;
}
inline void print(int x){
	if (x<0)	putchar('-'),x=-x;
	if (x>9)	print(x/10);
	putchar(x%10+'0');
}
const int N=1e5;
int mu[N+10],prime[N+10],g[N+10];//$f(d)=\sum\limits_{x|d}x$
bool inprime[N+10];
pii f[N+10];
void prepare(){
	mu[1]=1; int tot=0;
	f[1]=MK(1,1);
	for (int i=2;i<=N;i++){
		if (!inprime[i])	prime[++tot]=i,mu[i]=-1,g[i]=i+1,f[i]=MK(i+1,i);
		for (int j=1;j<=tot&&i*prime[j]<=N;j++){
			inprime[i*prime[j]]=1;
			if (i%prime[j]==0){
				mu[i*prime[j]]=0;
				g[i*prime[j]]=g[i]*prime[j]+1;
				f[i*prime[j]]=MK(f[i].Fi/g[i]*g[i*prime[j]],i*prime[j]);
				break;
			}
			mu[i*prime[j]]=-mu[i];
			f[i*prime[j]]=MK(f[i].Fi*f[prime[j]].Fi,i*prime[j]);
			g[i*prime[j]]=prime[j]+1;
		}
	}
}
int tree[N+10];
void Modify(int x,int v){for (;x<=N;x+=lowbit(x))	tree[x]+=v;}
int Query(int x){
	int res=0;
	for (;x;x-=lowbit(x))	res+=tree[x];
	return res;
}
const int M=2e4;
struct S1{
	int n,m,a,ID;
	void rd(int i){n=read(),m=read(),a=read(),ID=i;}
	bool operator <(const S1 &tis)const{return a<tis.a;}
}A[M+10];
int solve(int n,int m){
	if (n>m)	swap(n,m);
	int res=0;
	for (int i=1,pos;i<=n;i=pos+1){
		pos=min(n/(n/i),m/(m/i));
		res=(res+(Query(pos)-Query(i-1))*(n/i)*(m/i));
	}
	return res;
}
int Ans[M+10];
int main(){
	prepare();
	sort(f+1,f+1+N);
	int Q=read();
	for (int i=1;i<=Q;i++)	A[i].rd(i);
	sort(A+1,A+1+Q);
	for (int i=1,j=1;i<=Q;i++){
		while (f[j].Fi<=A[i].a&&j<=N){
			for (int k=f[j].Se;k<=N;k+=f[j].Se)
				Modify(k,f[j].Fi*mu[k/f[j].Se]);
			j++;
		}
		Ans[A[i].ID]=solve(A[i].n,A[i].m);
	}
	for (int i=1;i<=Q;i++)	printf("%d\n",Ans[i]&(~(1<<31)));
	return 0;
}
```

---

## 作者：Soulist (赞：51)

设$d(x)$为$x$的因子之和。

题目所求即：

$$\sum_{i=1}^n\sum_{j=1}^md(gcd(i,j))*(d(gcd(i,j)<=A))$$

考虑化简。

$$\sum_{k=1}^nd(k)(d(k)<=A)\sum_{i=1}^{\frac{n}{k}}\sum_{j=1}^{\frac{m}{k}}gcd(i,j)==1$$

套路用莫比乌斯函数的性质。

$$\sum_{k=1}^nd(k)(d(k)<=A)\sum_{i=1}^{\frac{n}{k}}\sum_{j=1}^{\frac{m}{k}}\sum_{x|gcd(i,j)}\mu(x)$$

$$\sum_{k=1}^nd(k)(d(k)<=A)\sum_{x=1}^{\frac{n}{k}}\mu(x)*[\frac{n}{kd}][\frac{m}{kd}]$$

设 $T = kd$

$$\sum_{T=1}^n[\frac{n}{kd}][\frac{m}{kd}]\sum_{x|T}\mu(x)*d(\frac{T}{x})(d(\frac{T}{x})<=A)$$

我们发现后面那一坨貌似是之和$(T,A)$有关的函数，于是我们需要维护它。

考虑将询问按照$A$值排序。提前处理出$d(x)$函数，并按照函数值排序。

那么考虑到当前的$A$逐渐变大的时候，这个与$T$相关的函数值也在改变。

实际上就是一个**插入**过程

注意到整除分块的过程中对后面这一坨函数的查询存在一个求前缀和的过程，
其实也就是一种询问的概念。

所以我们肯定需要数据结构来维护这个会变得函数$T$值。树状数组就好了。

按照询问$A$的大小排序后，用所有$d(x)$比当前$A$函数值小的数去更新$T$值。比如一个$d(x)$，它会对$f(x),f(2x),f(3x)...$造成影响，给每个都加上一个$d(x)*\mu(\dfrac{T}{x})$就行了。

复杂度？

注意到每个数的插入次数：

总数是：$\dfrac{n}{1}+\dfrac{n}{2}+\dfrac{n}{3}+...= n\ln n+C$

可以近似看作$nlogn$。插入一次的复杂度是$O(\log n)$的，插入的总复杂度就是$O(n\log ^2n)$

询问的复杂度是$O(\sqrt n \log n)$

总复杂度：$O(Q\sqrt n \log n+n \log^2n)$

貌似可以过$...???$，虽然个人感觉怎么想这都不是一个能过$10W$的做法吧..

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int read() {
	char cc = getchar(); int cn = 0, flus = 1;
	while(cc < '0' || cc > '9') {  if( cc == '-' ) flus = -flus;  cc = getchar();  }
	while(cc >= '0' && cc <= '9')  cn = cn * 10 + cc - '0', cc = getchar();
	return cn * flus;
}
const int N = 1e5 + 5 ; 
#define rep( i, s, t ) for( register int i = s; i <= t; ++ i )
#define lowbit(x) ( x & ( -x ) )
struct Qu {
	int x, y, z, id ; 
} di[N], q[N];
int n, m, Q, Maxn, u[N], d[N], sum[N], ans[N], tree[N], p[N], top, mod ; 
bool isp[N] ; 
bool cmp( Qu x, Qu y ) {
	return x.z < y.z ; 
}
void add( int x, int k ) {
	for( register int i = x; i <= Maxn; i += lowbit(i) ) tree[i] += k ;  
}
int query( int x ) {
	int num = 0; 
	for( register int i = x; i; i -= lowbit(i) ) num += tree[i];
	return num ; 
}
void init() {
	u[1] = 1;
	rep( i, 2, Maxn ) {
		if( !isp[i] ) u[i] = -1, p[++ top] = i ;
		rep( j, 1, top ) {
			if( p[j] * i > Maxn ) break ;
			isp[p[j] * i] = 1 ;
			if( i % p[j] == 0 ) break ;
			u[p[j] * i] = - u[i];
		}
	}
	rep( i, 1, Maxn ) for( register int j = i; j <= Maxn; j += i ) d[j] += i ; 
	rep( i, 1, Maxn ) di[i].id = i, di[i].z = d[i] ;
	sort( di + 1, di + Maxn + 1, cmp ) ; 
}
void u_add( int x ) {
	for( int i = 1; i * x <= Maxn; ++ i ) add( i * x, u[i] * d[x] ) ;
}
int solve( int x, int y ) {
	int num = 0; if( x > y ) swap( x, y ) ;
	for( int l = 1, r; l <= x; l = r + 1 ) {
		r = min( ( x / ( x / l ) ), ( y / ( y / l ) ) ) ;
		num += ( x / l ) * ( y / l ) * ( query(r) - query(l - 1) ) ;
	}
	return num % mod ;
} 
signed main()
{
	Q = read() ; mod = 1ll << 31 ;
	rep( i, 1, Q ) q[i].x = read(), q[i].y = read(), q[i].z = read(), q[i].id = i ;
	Maxn = N - 5 ; 
	sort( q + 1, q + Q + 1, cmp ), init() ; 
	int pr = 0 ; 
	rep( i, 1, Q ) {
		while( di[pr + 1].z <= q[i].z && pr < Maxn ) ++ pr, u_add( di[pr].id ) ;
		ans[q[i].id] = solve( q[i].x, q[i].y ) ;
	}
	rep( i, 1, Q ) printf("%lld\n", ans[i] % mod ) ; 
	return 0;
}
```

---

## 作者：Kelin (赞：36)

我们定义$F(i)$为$i$的约数和,题目要求的是


$\sum_{i=1}^n\sum_{j=1}^ mF(gcd(i,j))\mod 2^{31},F(gcd(i,j))\le a$


我们先忽略$a$这个限制


令$g(i)=\sum_{x=1}^n\sum_{y=1}^ m[gcd(x,y)=i]$


$\Rightarrow g(i)=\sum_{i|d}\mu(\frac{d}{i})\lfloor\frac{n}{d}\rfloor\lfloor\frac{m}{d}\rfloor$


然后就有


$Ans=\sum_{i=1}^nF(i)g(i)$


$=\sum_{i=1}^nF(i)\sum_{i|d}\mu(\frac{d}{i})\lfloor\frac{n}{d}\rfloor\lfloor\frac{m}{d}\rfloor$


$=\sum_{d=1}^n\lfloor\frac{n}{d}\rfloor\lfloor\frac{m}{d}\rfloor\sum_{i|d}F(i)\mu(\frac{d}{i})$


我们令$f(i)=\sum_{i|d}F(i)\mu(\frac{d}{i})$


首先线性筛或者枚举倍数来预处理出$F(i)$


然后枚举每个数更新倍数,求出$f(i)$的前缀和,分块就好了


考虑有了$a$的限制,我们发现只有$F(i)\le a$的$i$才对答案有贡献


我们离线处理,按$a$排序每次把合法的加入树状数组


就可以维护出$f(i)$的前缀和了,最后分块就好了


因为模数是$2$的整数幂,自然溢出就好了,最后要与$2^{31}-1$取与


---

## 作者：qwaszx (赞：20)

先直接照着题目写写.

如果没有$a$就好了，那么所求即$\sum\limits_{i=1}^n\sum\limits_{j=1}^m\sum\limits_{d}d[d|i][d|j]=\sum\limits_{d=1}^nd\left\lfloor{\frac{n}{d}}\right\rfloor\left\lfloor{\frac{m}{d}}\right\rfloor$

有了$a$这样就行不通了，我们观察一下$d$后面那个式子发现它是$\sigma(\gcd(i,j)),$于是重写式子得到

$\sum\limits_{i=1}^n\sum\limits_{j=1}^m[\sigma(\gcd(i,j))\leq a]\sigma(\gcd(i,j))$，然后经过一波反演我们得到

$\sum\limits_{i=1}^n\left\lfloor{\frac{n}{i}}\right\rfloor\left\lfloor{\frac{m}{i}}\right\rfloor\sum\limits_{d|i}[\sigma(d)\leq a]\sigma(d)\mu(\frac{i}{d})$

设$f(i)=\sum\limits_{d|i}[\sigma(d)\leq a]\sigma(d)\mu(\frac{i}{d})$，重写原式为$\sum\limits_{i=1}^n\left\lfloor{\frac{n}{i}}\right\rfloor\left\lfloor{\frac{m}{i}}\right\rfloor f(i)$

$a$是动态变化的，所以$f$也是动态变化的，那怎么处理呢?

离线询问，按$a$从小到大排序，每次加入一些能对$f$产生贡献的$\sigma(d)$

查询还需要$f$的前缀和，所以我们使用树状数组维护$f$，每次暴力加入所有$\sigma(d)\leq a$的$d$(即对所有$kd\leq n,f(kd)+=\sigma(d)\mu(k)$)

修改复杂度$O(n\log n\sum\limits_{i=1}^n\frac{n}{i})=O(n\log^2n)$，查询数论分块复杂度$O(T\sqrt{n}\log n)$

数学和数据结构结合的题我还是第一次见...

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int N=5e5;
int d[N],mu[N],p[N],pw[N],prime[N],cnt,T,ans[N];
struct Q{int n,m,a,id;}q[N];
struct D{int d,id;}dd[N];
void make(int n)
{
    d[1]=mu[1]=p[1]=pw[1]=1;//筛出μ和d
    for(int i=2;i<=n;i++)
    {
        if(!p[i])prime[++cnt]=i,d[i]=i+1,mu[i]=-1,pw[i]=i*i;
        for(int j=1;j<=cnt&&i*prime[j]<=n;j++)
        {
            int x=i*prime[j];
            p[x]=1;
            if(i%prime[j])d[x]=d[i]*(prime[j]+1),mu[x]=-mu[i],pw[x]=prime[j]*prime[j];
            else{pw[x]=pw[i]*prime[j],d[x]=(long long)d[i]*(pw[x]-1)/(pw[i]-1),mu[x]=0;break;}
        }
    }
    for(int i=1;i<=n;i++)dd[i]=(D){d[i],i};
}
int cmp(const Q &a,const Q &b){return a.a<b.a;}
int cmp1(const D &a,const D &b){return a.d<b.d;}
struct BIT
{
    int a[1000000];
    void update(int x,int w){for(;x<=100000;x+=x&-x)a[x]+=w;}
    int query(int x){int ans=0;for(;x;x-=x&-x)ans+=a[x];return ans;}
    int query(int l,int r){return query(r)-query(l-1);}
}g;
int main()
{
    make(100000);
    scanf("%d",&T);
    for(int i=1;i<=T;i++)scanf("%d%d%d",&q[i].n,&q[i].m,&q[i].a),q[i].id=i;
    sort(q+1,q+T+1,cmp);sort(dd+1,dd+100000+1,cmp1);
    for(int i=1,j=0;i<=T;i++)
    {
        while(j<100000&&dd[j+1].d<=q[i].a)
        {
            int td=dd[++j].id;
            for(int k=1;td*k<=100000;k++)g.update(k*td,dd[j].d*mu[k]);
        }//暴力加入
        int n=q[i].n,m=q[i].m;if(n>m)swap(n,m);
        for(int j=1,lt;j<=n;j=lt+1)
        {
            int fn=n/j,fm=m/j;
            lt=min(n/fn,m/fm);
            ans[q[i].id]+=fn*fm*g.query(j,lt);
        }
    }
    for(int i=1;i<=T;i++)printf("%d\n",ans[i]&2147483647);
}
```

---

## 作者：一扶苏一 (赞：13)

## 【莫比乌斯反演 & BIT】【P3312】 [SDOI2014] 数表

### Analysis

首先不考虑 $a$ 的限制，则题目要求

$$\sum\limits_{i = 1}^n \sum\limits_{j = 1}^m \sum\limits_{d \mid i \land d \mid j} d$$

根据 $a \mid i \land a \mid j \Leftrightarrow a \mid \gcd(i, j)$，设 $f(x) = \sum\limits_{d \mid x} d$，则所求即为

$$\sum\limits_{i = 1}^n \sum\limits_{j = 1}^m f(\gcd(i, j))$$

然后就可以套路的的反演了。设 $f = g \circ 1$，等式两侧同乘 $1$ 的逆元 $\mu$，得到 $g = f \circ \mu$，也即 $g(x) = \sum\limits_{d \mid x} f(d) \mu(\frac{x}{d})$。

则所求为

$$\sum\limits_{i = 1}^n \sum\limits_{j = 1}^m \sum\limits_{d \mid i \land d \mid j} g(d)$$

整理得到

$$\sum\limits_{d = 1}^n g(d) \lceil\frac{n}{d}\rceil \lceil\frac{m}{d}\rceil$$

这样就可以用整除分块单次 $O(\sqrt n)$ 回答询问了。

考虑加入 $a$ 的限制，只有 $f(d) \leq a$ 的 $f$ 会对 $g$ 产生贡献，那么将询问离线，按照 $a$ 排序，在每次询问前把对应 $f$ 的贡献加入。注意到整除分块时需要的 $g$ 是一个区间和的形式，而加入 $f$ 的贡献相当于进行单点修改，用 bit 维护即可。

时间复杂度 $O(q \sqrt n \log n + n \log n)$。

### Code

```cpp
namespace Fusu {

const int maxn = 100005;

#define int unsigned

void Init();
void Sieve();
void Query();

void Main() {
  Sieve();
  Init();
  Query();
}

int pcnt;
int prm[maxn];
bool np[maxn];
int mu[maxn];
std::pair<ll, int> f[maxn];

void Sieve() {
  const int n = 100000;
  mu[1] = 1;
  f[1] = {1, 1};
  for (int i = 2; i <= n; ++i) {
    if (np[i] == false) {
      mu[prm[++pcnt] = i] = -1;
    }
    for (int j = 1, u = prm[j], v = i * u; j <= pcnt; v = i * (u = prm[++j])) if (v <= n) {
      np[v] = true;
      if ((i % u) == 0) {
        mu[v] = 0;
        break;
      } else {
        mu[v] = mu[u] * mu[i];
      }
    } else {
      break;
    }
    f[i].second = i;
    for (int j = 1; (j * j) <= i; ++j) if ((i % j) == 0) {
      f[i].first += j;
      if ((j * j) != i) {
        f[i].first += i / j;
      }
    }
  }
  std::sort(f + 1, f + 1 + n);
}

int t;
struct Qry {
  int n, m, a, id;

  void init(const int x) {
    id = x;
    qr(n); qr(m); qr(a);
    if (n > m) std::swap(n, m);
  }
};
Qry q[maxn];

void Init() {
  qr(t);
  for (int i = 1; i <= t; ++i) {
    q[i].init(i);
  }
}

const int N = 100000;

struct BIT {
  int a[maxn];

  inline int lowbit(const int x) { return x & -x; }
  inline void upd(int x, const int v) { do a[x] += v; while ((x += lowbit(x)) <= N); }
  inline int qry(int x) { int ret = 0; do ret += a[x]; while (x -= lowbit(x)); return ret; }
};
BIT bt;

void ins(const int x) {
  for (int i = f[x].second, j = 0; i <= N; i += f[x].second) {
    bt.upd(i, (unsigned)(f[x].first * mu[++j]));
  }
}

int ans[maxn];
void qry(const int p) {
  int n = q[p].n, m = q[p].m;
  for (int i = 1; i <= n; ++i) {
    int x = n / i, y = m / i, a = n / x, b = m / y;
    if (a > b) std::swap(a, b);
    ans[q[p].id] += (bt.qry(a) - bt.qry(i - 1)) * x * y;
    i = a;
  }
  ans[q[p].id] &= 2147483647;
}

void Query() {
  std::sort(q + 1, q + 1 + t, [](const Qry &x, const Qry &y) { return x.a < y.a; });
  for (int i = 1, pos = 0; i <= t; ++i) {
    while ((pos < N) && (f[pos + 1].first <= q[i].a)) ins(++pos);
    qry(i);
  }
  qwa(ans + 1, t, '\n', '\n');
}

} // namespace Fusu
```



---

## 作者：stealthassassin (赞：4)

$**本题解仅为楼上题解提供LaTaX公式显示，方便阅读，非本人所创，详情请见楼上**$

设F[i]=i的约数和


F是积性函数，所以可以线性筛。$x,y$互质时,$f[x\ast y]=f[x] \ast f[y]$。特例是f[$p^a$],就是等差数列求和。


则$ans=\sum\limits_{i=1}^{n}\sum\limits_{j=1}^{m} F[gcd(i,j)],且F[gcd(i,j)]\leq a$。


忽视$a$。


设$g[i]= \sum\limits_{x=1}^{n}\sum\limits_{y=1}^{m}[gcd(x,y)=i]$的个数


则$ans=\sum\limits_{i=1}^{n} (F[i]\ast g[i])$。


先来处理一下g。


$g[i]= \sum\limits_{x=1}^{n}\sum\limits_{y=1}^{m}[gcd(x,y)=i]$


$g[i]= \sum\limits_{x=1}^{\frac{n}{i}}\sum\limits_{y=1}^{\frac{m}{i}}[gcd(x,y)=i]$


$g[i]= \sum\limits_{x=1}^{\frac{n}{i}}\sum\limits_{y=1}^{\frac{m}{i}}\sum\limits_{d|gcd(x,y)}\mu(d)$


$g[i]= \sum\limits_{x=1}^{\frac{n}{i}}\sum\limits_{y=1}^{\frac{m}{i}}\sum\limits_{d|x且d|y}\mu(d)$

$g[i]= \sum\limits_{d=1}^{\frac{n}{i}}\mu(d)\ast\sum\limits_{x=1}^{\frac{n}{x\ast d}}\sum\limits_{y=1}^{\frac{m}{y\ast d}}[d|x且d|y]$

$g[i]= \sum\limits_{d=1}^{\frac{n}{i}}\mu(d) \ast \lfloor \frac{n}{i\ast d} \rfloor \ast \lfloor \frac{m}{i\ast d} \rfloor$


那么$ans=\sum\limits_{i=1}^{n}F[i]\ast\sum\limits_{d=1}^{\frac{n}{i}}\mu(d) \ast \lfloor \frac{n}{i\ast d} \rfloor \ast \lfloor \frac{m}{i\ast d} \rfloor$ 考虑把后面两项提出来。


设$k=i\ast d。则g[i]= \sum\limits_{i|k,k\leq n}\mu(\frac{k}{i})\ast\lfloor\frac{n}{k}\rfloor\ast\lfloor\frac{m}{k}\rfloor$


则$ans= \sum\limits_{k=1}{n}\lfloor\frac{n}{k}\rfloor\ast\lfloor\frac{m}{k}\rfloor\ast\sum\limits_{i|k}F[i]\ast\mu(\frac{k}{i})$


设$f[k]=\sum\limits_{i|k}F[i]\ast\mu(\frac{k}{i})$


如果处理出$f[i]$的前缀和，利用$\lfloor\frac{n}{k}\rfloor,\lfloor\frac{m}{k}\rfloor$只有根号种情况，就可以根号时间解决了。


然而这里F[i]要$\leq a$。


我们如果将询问按a排序，i按F[i]排序，就可以维护当前f[i]了。


但不能每次都O(n)更新f[i]的前缀和，所以要用树状数组。


---

## 作者：Star_Cried (赞：3)

## P3312 数表

### 题意

求出

$$
\sum_{i=1}^n\sum_{j=1}^m\sigma(\gcd(i,j))[\sigma(\gcd(i,j))\le a]
$$

其中 $\sigma$ 表示约数和。

### 思路/推导

考虑没有 $a$ 的限制的情况。
$$
\begin{aligned}
ans&=\sum_{d=1}^{\min(n,m)}\sigma(d)\sum_{i=1}^{\left\lfloor\frac{n}{d}\right\rfloor}\sum_{j=1}^{\left\lfloor\frac{m}{d}\right\rfloor}[\gcd(i,j)=1]\\
&=\sum_{d=1}^{\min(n,m)}\sigma(d)\sum_{i=1}^{\left\lfloor\frac{n}{d}\right\rfloor}\sum_{j=1}^{\left\lfloor\frac{m}{d}\right\rfloor}\sum_{p\mid i\land p\mid j}\mu(p)\\
&=\sum_{d=1}^{\min(n,m)}\sigma(d)\sum_{p=1}^{\left\lfloor\frac{\min(n,m)}{d}\right\rfloor}\mu(p)\left\lfloor\frac{n}{dp}\right\rfloor\left\lfloor\frac{m}{dp}\right\rfloor\\
&=\sum_{T=1}^{\min(n,m)}\sum_{d\mid T}\sigma(d)\mu(\frac Td)\left\lfloor\frac{n}{T}\right\rfloor\left\lfloor\frac{m}{T}\right\rfloor
\end{aligned}
$$

考虑加入 $a$ 的限制。将询问按照 $a$ 大小离线，然后用一个树状数组维护 $\sum_d\sigma(d)\mu(\frac Td)$ 的前缀和即可。

具体是将线性筛出的所有数的约数和从小到大进行排序，在从小到大查询的时候进行更新。

不会筛 $\sigma$ 的可以看[我的另一篇博客](https://www.cnblogs.com/BrotherHood/p/14360170.html)

时间复杂度瓶颈在于查询，需要用到数论分块，为 $O(q\sqrt n\log n)$。

### 代码

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cctype>
#include<cstring>
#include<cmath>
#include<utility>
using namespace std;
inline int read(){
	int w=0,x=0;char c=getchar();
	while(!isdigit(c))w|=c=='-',c=getchar();
	while(isdigit(c))x=x*10+(c^48),c=getchar();
	return w?-x:x;
}
namespace star
{
	const int maxn=1e5+10,maxm=2e4+10,N=1e5;
	int n,p[maxn/10],mu[maxn],tot,c[maxn],ans[maxm],g[maxn];
	pair<int,int> f[maxn];
	bool mark[maxn];
	inline void insert(int x,int k){for(;x<=N;x+=x&-x) c[x]+=k;}
	inline int query(int x){int ans=0;for(;x;x-=x&-x) ans+=c[x];return ans;}
	struct Query{
		int n,m,a,id;
		inline bool operator < (const Query& zp) const {return a<zp.a;}
		inline int solve(){
			if(n>m) swap(n,m);
			int ans=0;
			for(int l=1,r;l<=n;l=r+1)
				r=min(n/(n/l),m/(m/l)),ans+=((query(r)-query(l-1))*(n/l)*(m/l));
			return ans;
		}
	}q[maxm];
	inline void work(){
		mu[1]=1;
		f[1]=make_pair(1,1);
		for(int i=2;i<=N;i++){
			if(!mark[i]) p[++tot]=i,mu[i]=-1,g[i]=i+1,f[i]=make_pair(i+1,i);
			for(int j=1,tmp;j<=tot and (tmp=i*p[j])<=N;j++){
				mark[tmp]=true;
				if(i%p[j]==0){
					mu[tmp]=0;
					g[tmp]=g[i]*p[j]+1;
					f[tmp]=make_pair(f[i].first/g[i]*g[tmp],tmp);
					break;
				}
				mu[tmp]=-mu[i];
				g[tmp]=p[j]+1;
				f[tmp]=make_pair(f[i].first*f[p[j]].first,tmp);
			}
		}
		sort(f+1,f+1+N);
		n=read();
		for(int i=1;i<=n;i++) q[i].n=read(),q[i].m=read(),q[i].a=read(),q[i].id=i;
		sort(q+1,q+1+n);
		for(int i=1,j=1;i<=n;i++){
			while(f[j].first<=q[i].a and j<=N){
				for(int k=f[j].second;k<=N;k+=f[j].second) insert(k,f[j].first*mu[k/f[j].second]);
				j++;
			}
			ans[q[i].id]=q[i].solve();
		}
		for(int i=1;i<=n;i++) printf("%d\n",ans[i]&(~(1<<31)));
	}
}
signed main(){
	star::work();
	return 0;
}
```



---

## 作者：kczno1 (赞：3)

设F[i]=i的约数和

F是积性函数，所以可以线性筛。x,y互质时,f[x\*y]=f[x]\*f[y]。特例是f[p^a],就是等差数列求和。

则ans= i=[1,n],j=[1,m],sigma(F[gcd(i,j)]),且F[gcd(i,j)]<=a。

忽视a。

设g[i]= x=[1,n],y=[1,m],gcd(x,y)=i的个数

则ans= i=[1,n],sigma(F[i]\*g[i])。

先来处理一下g。

g[i]
```cpp
= x=[1,n],y=[1,m],sigma([gcd(x,y)=i]) 
= x=[1,n/i],y=[1,m/i],sigma([gcd(x,y)=1])
= x=[1,n/i],y=[1,m/i],d|gcd(x,y),sigma(miu(d))
= x=[1,n/i],y=[1,m/i],d|x且d|y,sigma(miu(d))
= d=[1,n/i],sigma:miu(d)*( x=[1,n/id]且d|x,y=[1,m/id]且d|y )的个数
= d=[1,n/i],sigma:miu(d)*[n/id]*[m/id]
```
那么ans= i=[1,n],sigma:F[i]\*(d=[1,n/i],sigma:miu(d)\*[n/id]\*[m/id])
考虑把后面两项提出来。

设k=id。则g[i]= i|k且k<=n,sigma:miu(k/i)\*[n/k]\*[m/k]

则ans= k=[1,n],sigma:[n/k]\*[m/k]\*(i|k,sigma:F[i]\*miu(k/i))

设f[k]=i|k,sigma:F[i]\*miu(k/i)

如果处理出f[i]的前缀和，利用[n/k],[m/k]只有根号种情况，就可以根号时间解决了。

然而这里F[i]要<=a。

我们如果将询问按a排序，i按F[i]排序，就可以维护当前f[i]了。

但不能每次都O(n)更新f[i]的前缀和，所以要用树状数组。

一开始写的t了一个点。。应该是常数问题吧。

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;

#define oo 2000000000
#define N 100000
int c[N+5];
void add(int i,int w)
{
    for (;i<=N;i+=i&-i) c[i]+=w;
}
int qiu(int i)
{
    int sum=0;
    for (;i;i-=i&-i) sum+=c[i];
    return sum;
}

int i,j,now;
int ans[20010];

int miu[N+5];
int f[N+5],ms[N+5];//约数和，最小质因数的乘积 
int p[N+5],top;
void get_f_miu()
{
    f[0]=oo;
    ms[1]=f[1]=miu[1]=1;
    for (i=2;i<=N;++i)
    {
        if (!f[i])
        {
            f[i]=i+1;miu[i]=-1;ms[i]=i;
            p[++top]=i;
        }
        
        for (j=1;(now=p[j])*i<=N;++j)
        {
            if (i%now)
            {
                ms[now*i]=now;
                f[now*i]=f[i]*f[now];
                miu[now*i]=-miu[i];
            }else
            {
                ms[now*i]=ms[i]*now;miu[now*i]=0;
                if (ms[i]==i) f[now*i]=(ms[now*i]*now-1)/(now-1);
                else f[now*i]=f[i/ms[i]]*f[now*ms[i]];
                break;
            }
        }
    }
}

struct query
{
    int n,m,a,id;
    void init()
    {
        scanf("%d%d%d",&n,&m,&a);
        id=i;
    }
    bool operator <(const query &i)const
    {
        return a<i.a;
    }
    void solve()
    {
        for (;f[p[now]]<=a;++now) 
        {
            i=p[now];
            for (j=1;i*j<=N;++j)
                add(i*j,f[i]*miu[j]);
        }
        
        if (n>m) swap(n,m);
        int tot=0,last=0,now_s;
        for (i=1;i<=n;i=j+1)
        {
            j=min(n/(n/i),m/(m/i));
            now_s=qiu(j);
            tot+=(now_s-last)*(n/i)*(m/i);
            last=now_s; 
        }
        if (tot<0) ans[id]=tot+(1<<31);
        else ans[id]=tot;
    }
}q[20010];

bool xiao_f(int x,int y)
{
    return f[x]<f[y];
}

int main()
{
    freopen("1.in","r",stdin);
    int tt;
    scanf("%d",&tt);
    for (i=1;i<=tt;++i) q[i].init(); 
    
    get_f_miu();
    for (i=1;i<=N;++i) p[i]=i;
    sort(p+1,p+N+1,xiao_f);
    
    sort(q+1,q+tt+1);
    
    int o;now=1;
    for (o=1;o<=tt;++o) q[o].solve();
    for (o=1;o<=tt;++o) printf("%lld\n",ans[o]);
}
```

---

## 作者：Vocalise (赞：3)

数据结构和数论结合。

考虑除了 $a$ 限制以外这个题目就是平凡的。

因此直接写出式子：

$$ \begin{aligned}
&\quad\sum_{i=1}^{\min}\sum_{j=1}^m\sigma(\gcd(i,j))[\sigma(\gcd(i,j))\le a] \\
&= \sum_{d=1}^{\min}\sigma(d)[\sigma(d)\le a]\sum_{i=1}^n\sum_{j=1}^m[\gcd(i,j) = d] \\
&= \sum_{d=1}^{\min}\sigma(d)[\sigma(d)\le a]\sum_{i=1}^{n/d}\sum_{j=1}^{m/d}[\gcd(i,j)=1] \\
&= \sum_{d=1}^{\min}\sigma(d)[\sigma(d)\le a]\sum_{t=1}^{\min/d}\mu(t)\lfloor\frac n{dt} \rfloor \lfloor\frac m{dt} \rfloor \\
\end{aligned} $$

考虑此时是一个 $\mathcal O(n)$ 双重分块的式子，可以 $\mathcal O(n)$ 回答一个询问。

但是对于本题来说是不够的。

$$ \begin{aligned}
&= \sum_{d=1}^{\min}\sigma(d)[\sigma(d)\le a]\sum_{d|t}^{\min}\mu(\frac td)\lfloor\frac nt \rfloor \lfloor\frac mt \rfloor \\
&= \sum_{t=1}^{\min}\lfloor\frac nt \rfloor \lfloor\frac mt \rfloor \sum_{d|t}\sigma(d)[\sigma(d)\le a]\mu(\frac td)
\end{aligned} $$

此时得到一个分块和卷积的式子。

发现卷积部分有和 $a$ 有关的因素。

如果考虑维护该卷积的前缀和的话，可以得到一个做法。

离线，对 $a$ 从小到大考虑所有询问，且对所有 $d$ 按 $\sigma (d)$ 排序。

在卷积中加入所有尚未加入的 $\sigma(d)\le a$，然后分块计算。

容易发现我们要支持单点修改，分块时区间求和。使用树状数组。

复杂度分析：树状数组部分需要加入 $\mathcal O(n\log n)$ 次，即 $\mathcal O(n\log^2n)$。

分块部分为 $\mathcal O(q\sqrt n\log n)$，因此总复杂度是 $\mathcal O(n\log^2n+q\sqrt n\log n)$。

---

一个看似前置的问题：如何求 $\sigma$，即因数和？

根据定义其显然是积性函数，我们可以欧拉筛。

对于质数  $p$，有基本的结论：

$$ \sigma(p) = 1 + p $$

$$ \sigma(p^k) = \sum_{i=0}^kp^i $$

因此考虑 $i$ 和质数 $p$，$p$ 是 $i\times p$ 的最小质因子。

1. $p \mid i$：

此时由 $i\times p^{k-1}$ 推知 $i\times p^k$。

引入新的函数 $pw$，表示最小质因子在该数中的幂。

因此有

$$ \sigma(i\times p) = \sigma(\frac i{pw(i)})\times\sigma(pw(i)\times p) $$

但是特别有 $i = p^k$，此时

$$ \sigma(i\times p) = \sigma(i)\times p + 1 $$

2. $\text{otherwise}$

此时加入新的素数，比较简单是

$$ \sigma(i\times p) = \sigma(i)\times(p + 1) $$

而又不得不提到 $pw$ 的筛法。

加入新素数时 $pw(i\times p)$ 为 $p$，否则为 $pw(i)\times p$。

至此本题已经得到充分解决。

```cpp
#include <cstdio>
#include <iostream>
#include <cstring>
#include <cmath>
#include <algorithm>

typedef long long ll;
const int Q = 20001;
const int N = 100001;
const ll P = 1ll << 31;

inline int read() {
	int x = 0, f = 1; char ch = getchar();
	while(ch > '9' || ch < '0') { if(ch == '-') f = -1; ch = getchar(); }
	do x = x * 10 + ch - 48, ch = getchar(); while(ch >= '0' && ch <= '9');
	return x * f;
}

int T;
struct Query {
	int n,m,a,id;
	friend bool operator <(const Query &x,const Query &y) {
		return x.a < y.a;
	}
} q[Q];

int mk[N],p[N],tot; ll sgm[N],pw[N],mu[N];
int number[N];
bool cmp(int x,int y) { return sgm[x] < sgm[y]; }

void Seive() {
	sgm[1] = pw[1] = mu[1] = 1;
	for(int i = 2;i < N;i++) {
		if(!mk[i]) {
			p[++tot] = i;
			sgm[i] = i + 1, pw[i] = i;
			mu[i] = P - 1;
		}
		for(int j = 1;j <= tot && p[j] * i < N;j++) {
			mk[i * p[j]] = true;
			if(i % p[j]) {
				pw[i * p[j]] = p[j];
				sgm[i * p[j]] = sgm[i] * (p[j] + 1);
				mu[i * p[j]] = P - mu[i];
			} else {
				pw[i * p[j]] = pw[i] * p[j];
				if(i == pw[i]) sgm[i * p[j]] = sgm[i] * p[j] + 1;
				else sgm[i * p[j]] = sgm[i / pw[i]] * sgm[pw[i] * p[j]];
				mu[i * p[j]] = 0;
				break;
			}
		}
	}
	return;
}

ll fen[N],Ans[N];
void Add(int x,ll v) {
	for(;x < N;x += x & (-x)) fen[x] = (fen[x] + v) % P;
}
ll Sum(int l,int r) {
	ll res = 0; l--;
	for(;r;r -= r & (-r)) res = (res + fen[r]) % P;
	for(;l;l -= l & (-l)) res = (res - fen[l] + P) % P;
	return res;
}

int main() {
	T = read();
	for(int i = 1;i <= T;i++) q[i].n = read(), q[i].m = read(), q[i].a = read();
	for(int i = 1;i <= T;i++) q[i].id = i;
	std::sort(q + 1,q + 1 + T);
	Seive();
	for(int i = 1;i < N;i++) number[i] = i;
	std::sort(number + 1,number + N,cmp);
	int rg = 1;
	for(int i = 1;i <= T;i++) {
		while(sgm[number[rg]] <= q[i].a && rg < N) {
			for(int j = 1;number[rg] * j < N;j++)
				Add(number[rg] * j,(1ll * sgm[number[rg]] * mu[j]) % P);
			rg++;
		}
		ll ans = 0;
		for(int l = 1;l <= q[i].n && l <= q[i].m;l++) {
			int r = std::min(q[i].n / (q[i].n / l),q[i].m / (q[i].m / l));
			ans = (ans + 1ll * Sum(l,r) * (q[i].n / l) % P * (q[i].m / l)) % P;
			l = r;
		}
		// std::printf("%lld\n",ans);
		Ans[q[i].id] = ans;
	}
	for(int i = 1;i <= T;i++) std::printf("%lld\n",Ans[i]);
	return 0;
}

```

---

## 作者：chihik (赞：3)

$$\sum_{i=1}^n\sum_{j=1}^m \sigma((i,j))$$

$$\sum_{d=1}^{\min(n,m)}\sigma(d)\sum_{i=1}^n\sum_{j=1}^m [gcd(i,j)=d] $$

$$\sum_{d=1}^{\min(n,m)}\sigma(d)\sum_{t=1}^{\frac{\min(n,m)}{d}}\mu(t) \lfloor \frac{n}{dt}\rfloor \lfloor \frac{m}{dt} \rfloor $$

$$\sum_{T=1}^{\min(n,m)}\lfloor  \frac{n}{T}\rfloor \lfloor \frac{m}{T}\rfloor \sum_{d|T}\sigma(d)\mu(\frac{T}{d}) $$

如果没有 $a$ 的限制 ，$\sigma$ 与 $\mu$ 的卷积为 $id$。

加入 $a$ 的限制后，只要满足 $\sigma (d) \le a$ 即可。

那么将询问对 $a$ 从小到大排序，通过枚举倍数加入 $\sigma(d)\mu(\frac{T}{d})$ 的贡献。

令 $f(n)=\sum_{d|n} \sigma(d)\mu(\frac{T}{d})$

我们需要单点修改 $f(n)$ , 以及在数论分块时区间查询，可以用树状数组维护。

时间复杂度 $\Theta(n \log^2 n+q\sqrt n \log n)$

```cpp
#include <cstdio> 
#include <iostream>
#include <algorithm>
using namespace std;
#define uint unsigned int
#define Pair pair< int , int > 
#define fir first
#define sec second

const int MAXN = 1e5 , MAXQ = 2e4;

struct BIT {
	#define Lowbit( x ) ( x & -x )
	
	uint Arr[ MAXN + 5 ];
	void Update( int x , int val ) { 
		for( ; x <= MAXN ; x += Lowbit( x ) ) Arr[ x ] += val; 
	}
	uint Sum( int l , int r ) { 
		uint Ans = 0; l --;
		for( ; l ; l -= Lowbit( l ) ) Ans -= Arr[ l ]; 
		for( ; r ; r -= Lowbit( r ) ) Ans += Arr[ r ]; 
		return Ans; 
	} 
}Tree;

int prn , prime[ MAXN + 5 ] , mu[ MAXN + 5 ] , sigma[ MAXN + 5 ];
Pair f[ MAXN + 5 ];
bool vis[ MAXN + 5 ];
void sieve( ) {
	mu[ 1 ] = 1; sigma[ 1 ] = 1;
	for( int i = 2 ; i <= MAXN ; i ++ ) {
		if( !vis[ i ] ) { 
			prime[ ++ prn ] = i; 
			mu[ i ] = -1 , sigma[ i ] = i + 1;
		}
		for( int j = 1 ; j <= prn && 1ll * i * prime[ j ] <= MAXN ; j ++ ) {
			vis[ i * prime[ j ] ] = 1;
			if( i % prime[ j ] == 0 ) {
				sigma[ i * prime[ j ] ] = ( prime[ j ] + 1 ) * sigma[ i ] - prime[ j ] * sigma[ i / prime[ j ] ];
				break;
			}
			mu[ i * prime[ j ] ] = -mu[ i ];
			sigma[ i * prime[ j ] ] = sigma[ i ] * sigma[ prime[ j ] ]; 
		}
	}
	for( int i = 1 ; i <= MAXN ; i ++ ) f[ i ] = make_pair( sigma[ i ] , i );
	sort( f + 1 , f + MAXN + 1 );
}

int t; uint Ans[ MAXN + 5 ];
struct Query {
	int n , m , a , id;
	bool operator < ( const Query &oth ) const {
		return a < oth.a;
	}	
}Q[ MAXQ + 5 ];

int main( ) {
	sieve( );
	scanf("%d",&t);
	for( int i = 1 ; i <= t ; i ++ )
		scanf("%d %d %d",&Q[ i ].n,&Q[ i ].m,&Q[ i ].a) , Q[ i ].id = i; 
	sort( Q + 1 , Q + t + 1 );
	
	for( int i = 1 , d = 0 ; i <= t ; i ++ ) {
		for( ; d + 1 <= MAXN && f[ d + 1 ].fir <= Q[ i ].a ; d ++ )
			for( int j = f[ d + 1 ].sec ; j <= MAXN ; j += f[ d + 1 ].sec )
				Tree.Update( j , f[ d + 1 ].fir * mu[ j / f[ d + 1 ].sec ] );
		
		int n = Q[ i ].n , m = Q[ i ].m;
		for( int l = 1 , r ; l <= min( n , m ) ; l = r + 1 ) {
			r = min( n / ( n / l ) , m / ( m / l ) );
			Ans[ Q[ i ].id ] += 1u * ( n / l ) * ( m / l ) * Tree.Sum( l , r );
		}
	}
	for( int i = 1 ; i <= t ; i ++ ) printf("%d\n", Ans[ i ] & 2147483647 );
	return 0;
}
```


---

## 作者：lcjqwq (赞：2)

### Description 

$T$ 组询问，定义 $F(n)=\sum\limits_{d|n}d$。每次给出 $n,m,a$ 求  

$$\sum\limits_{i=1,j=1,F(\gcd(i,j)) \leq a}^{i\leq n, j \leq m} F (\gcd(i,j))$$

$T \leq 20000;n,m,a\leq 10^5$

### Solution

首先 $F$ 可以直接暴力地 $O(n \log n)$ 筛出来。

考虑 $a$ 的限制不是很好处理，假设没有这个 $a$ 的限制，则所求为

$$\sum\limits_{i=1}^{n}\sum\limits_{j=1}^{m} F (\gcd(i,j))$$

令 $G(i)=\sum\limits_{x=1}^{n}\sum\limits_{y=1}^{m}[\gcd(x,y)=i]$。这个东西是什么呢？在 [这里](https://www.cnblogs.com/acfunction/p/10127599.html) 有它的推导过程。根据里面的过程，可以得到 $G(i) = \sum\limits_{d=1}^{\lfloor\frac{n}{i}\rfloor}\mu(d)\lfloor\frac{n}{id}\rfloor\lfloor\frac{m}{id}\rfloor$（默认 $n \leq m$）

令下面的过程中$t = id$，则所求的是 

$$\begin{aligned}&\sum\limits_{i=1}^{n}F(i)G(i) \\ &= \sum\limits_{i=1}^{n}F(i)\sum\limits_{d=1}^{\lfloor\frac{n}{i}\rfloor}\mu(d)\lfloor\frac{n}{id}\rfloor\lfloor\frac{m}{id}\rfloor \\ &=\sum\limits_{i=1}^{n}F(i)\sum\limits_{i | t}\mu(\frac{t}{i})\lfloor\frac{n}{t}\rfloor\lfloor\frac{m}{t}\rfloor \\ &= \sum\limits_{t=1}^{n}\lfloor\frac{n}{t}\rfloor\lfloor\frac{m}{t}\rfloor\sum\limits_{i | t}F(i)\mu(\frac{t}{i})\end{aligned}$$

观察后面的式子，正好是一个狄利克雷卷积的形式。这种样子的都可以类似于那种 $O(n \log n)$ 地质数筛法在调和级数内求出来，再结合分块就可以做完这个没有 $a$ 的题。

现在有了 $a$ 的限制之后，离线。把询问按照 $a$ 从小到大排序，然后按照 $F(i)$ 从小到大加入。每当有一个新的 $a$ ，就可以移动指针，将一些 $F$ 用处理 $\sum\limits_{i | t}F(i)\mu(\frac{t}{i})$ 的方式加入到这个里面。然后加入完之后用分块计算就行。

现在需要维护单点操作，查询前缀和，树状数组是不错的选择。

由于取模是 $2^{32} - 1$ ，可以直接 int 自然溢出最后和 $2147483647$ 取一个 & 就行了。

时间复杂度：$O(n + n \log n +  n \log ^ 2 (n) + T \log (n)\sqrt n)$

### Code

[看代码戳这里](https://www.cnblogs.com/acfunction/p/10133942.html)


---

## 作者：hongzy (赞：1)

**题意**

有一张 $n\times m$ 的数表，其第$i$行第$j$列的数值为能同时整除$i$和$j$的所有自然数之和。

$T$组数据，询问对于给定的 $n,m,a$ , 计算数表中$\leq a$ 的数之和。

$T \leq 2\times 10^4,1 \leq n,m\leq 10^5$.

**题解**

令$\sigma(x)$表示$x$的约数和，容易写出答案的式子：

$$\sum_{i=1}^n \sum_{j=1}^m\sigma(\gcd(i,j))[\sigma(\gcd(i,j))\leq a]$$

然后使用常见套路变换式子：（下面默认$n\leq m$）

$$=\sum_{d=1}^n \sigma(d)[\sigma(d)\leq a] \sum_{i=1}^n \sum_{j=1}^m[\gcd(i,j)=d]$$

$$=\sum_{d=1}^n \sigma(d)[\sigma(d)\leq a] \sum_{i=1}^{\lfloor\frac{n}{d}\rfloor} \sum_{j=1}^{\lfloor\frac{m}{d}\rfloor}[\gcd(i,j)=1]$$

$$=\sum_{d=1}^n \sigma(d)[\sigma(d)\leq a] \sum_{i=1}^{\lfloor\frac{n}{d}\rfloor} \sum_{j=1}^{\lfloor\frac{m}{d}\rfloor} \sum_{d'|i,d'j} \mu(d')$$

$$=\sum_{d=1}^n \sigma(d)[\sigma(d)\leq a]\sum_{d'=1}^{\lfloor\frac{n}{d} \rfloor}\mu(d') \lfloor\frac{n}{dd'}\rfloor \lfloor\frac{m}{dd'}\rfloor$$

我们记前面那部分$f(d)=\sigma(d)[\sigma(d)\leq a]$：

$$=\sum_{i=1}^n f(d)\sum_{d'=1}^{\lfloor\frac{n}{d} \rfloor}\mu(d') \lfloor\frac{n}{dd'}\rfloor \lfloor\frac{m}{dd'}\rfloor$$

枚举乘积$k=dd'$：

$$=\sum_{k=1}^n\lfloor\frac{n}{k}\rfloor \lfloor\frac{m}{k}\rfloor\sum_{d|k}f(d)\mu(\frac{k}{d})$$

可以发现后面变成了狄利克雷卷积的形式！

记$$g(k)=\sum_{d|k} f(d)\mu(\frac{k}{d})$$，即$g=f*\mu$：

$$=\sum_{i=1}^n \lfloor \frac{n}{k} \rfloor \lfloor \frac{m}{k}\rfloor g(k)$$

可以看出我们对于每个$n,m$，可以数论分块

但是$g(k)$会随着$a$的变化而变化，不能每次计算一遍$g$

但是注意到，$g$变化是因为$f$，$f$只有$10^5$种取值。

于是我们可以把询问离线后按$a$从小到大排序，每次加入一些满足$\sigma(d)\leq a$的$d$

然后考虑加入一个$d$有什么影响：使得所有$d|k$的$g(k)$加上$f(d)\mu(\frac{k}{d})$

就可以每次枚举$d$的倍数$k$，然后更新$g(k)$，最多更新$[1,n]$这些数，根据调和级数可得枚举的总复杂度为$O(n \log n)$

别忘了数论分块是需要前缀和的，

所以现在我们需要一种支持快速单点加、求前缀和的数据结构，树状数组就很合适

然后就做完了，复杂度$O(n \log^2 n+T\sqrt n \log n)$

一个小细节：$\sigma$函数怎么线性筛？

考虑质因数分解后$\sigma (x)=(1+p_1+p_1^2+..+p_1^{c_1})..(1+p_k+p_k^2+..+p_k^{c_k})$

因此线性筛的时候记录一个$tmp(x)$表示$1+p+p^2..+p^c$，其中$p$为$x$的最小质因子，$c$的$p$的指数；然后就可以做了

一个减小常数的小技巧：分块的时候记录一个变量，减少重复的询问，详见代码

```cpp
#include <algorithm>
#include <cstdio>
using namespace std;

typedef long long ll;

const int R = 1e5;
const int N = 1e5 + 10;
const int M = 2e4 + 10;
const ll mo = 1ll << 31;

struct qs {
    int n, m, a, id;
    bool operator < (const qs &b) const {
        return a < b.a;
    }
} q[M];
int t, tot, p[N], mu[N], sig[N], tmp[N], ans[M];
bool tag[N];

struct num {
    int x;
    bool operator < (const num &b) const {
        return sig[x] < sig[b.x];
    }
} a[N];

void sieve(int n) {
    sig[1] = mu[1] = 1;
    for(int i = 2; i <= n; i ++) {
        if(!tag[i]) {
            p[tot ++] = i; mu[i] = -1;
            sig[i] = tmp[i] = i + 1;
        }
        for(int j = 0; j < tot; j ++) {
            if(p[j] * i > n) break ;
            tag[i * p[j]] = 1;
            if(i % p[j] == 0) {
                mu[i * p[j]] = 0;
                tmp[i * p[j]] = tmp[i] * p[j] + 1;
                sig[i * p[j]] = sig[i] / tmp[i] * tmp[i * p[j]];
                break ;
            }
            mu[i * p[j]] = - mu[i];
            tmp[i * p[j]] = 1 + p[j];
            sig[i * p[j]] = sig[i] * (1 + p[j]);
        }
    }
    for(int i = 1; i <= n; i ++) a[i].x = i;
    sort(a + 1, a + n + 1);
}

int bit[N];

void add(int x, int y) {
    for(; x <= R; x += x & (-x))
        bit[x] = ((ll) bit[x] + y) % mo;
}

int qry(int x) {
    int ans = 0;
    for(; x >= 1; x &= x - 1)
        ans = ((ll) ans + bit[x]) % mo;
    return ans;
}

void ins(int x) {
    for(int k = 1; x * k <= R; k ++)
        add(x * k, (ll) mu[k] * sig[x] % mo);
}

int query(int n, int m) {
    int ans = 0, la = 0, nw;
    for(int i = 1, j; i <= n; i = j + 1, la = nw) {
        j = min(n / (n / i), m / (m / i)); nw = qry(j);
        ans = (ans + ((ll) nw - la) % mo * (n / i) % mo * (m / i) % mo) % mo;
    }
    return ((ll)ans + mo) % mo;
}

int main() {
    sieve(R); scanf("%d", &t);
    for(int i = 1; i <= t; i ++) {
        scanf("%d%d%d", &q[i].n, &q[i].m, &q[i].a);
        if(q[i].n > q[i].m) swap(q[i].n, q[i].m);
        q[i].id = i;
    }
    sort(q + 1, q + t + 1);
    int j = 1;
    for(int i = 1; i <= t; i ++) {
        for(; j <= R && sig[a[j].x] <= q[i].a; j ++) ins(a[j].x);
        ans[q[i].id] = query(q[i].n, q[i].m);
    }
    for(int i = 1; i <= t; i ++)
        printf("%d\n", ans[i]);
    return 0;
}

```



---

## 作者：Taduro (赞：1)


设$f(i)$为i的约数和，求$\sum_{i=1}^n\sum_{j=1}^m[f(gcd(i,j)<=a)]f(gcd(i,j))$（默认n<=m）

不考虑a
$$
\sum_{i=1}^n\sum_{j=1}^mf(gcd(i,j))=\sum_{i=1}^n\sum_{j=1}^m\sum_{d=1}^n[gcd(i,j)=d]f(d)
$$
把d放到前面，再枚举d的倍数
$$
\sum_{d=1}^nf(d)\sum_{i=1}^{n/d}\sum_{j=1}^{m/d}[gcd(i,j)==1]
$$
枚举i,j的因子k，反演，再把k提到前面，改成枚举k的倍数
$$
\sum_{d=1}^{n}f(d)\sum_{i=1}^{n/d}\sum_{j=1}^{m/d}\sum_{k|(i,j)}μ(k)
=\sum_{d=1}^{n}f(d)\sum_{k=1}^{n/d}μ(k)\sum_{i=1}^{n/dk}\sum_{j=1}^{m/dk}
$$
枚举$d\times k=T$
$$
\sum_{T=1}^{n}\sum_{d|T}f(d)\timesμ(\frac{T}{d})\times \frac{n}{T}\times \frac{m}{T}
$$
之后$\frac{n}{T} \times \frac{m}{T}$可以整除分块，$g(T)=\sum_{d|T}f(d)\timesμ(\frac{T}{d})$是个关于T的函数，线筛出f和μ，埃筛求g即可。

[线性筛约数和的方法](https://blog.csdn.net/controlbear/article/details/77527115)

那么到这里你已经解决了一个普通的反演题，我也把这篇题解最麻烦的部分写完了。

对于a的问题，其实是让大于a的f(x)不参与g(x)的更新即可，所以做法如下：

把询问离线，按a排序，每次把目前小于a的f(x)加到x的所有倍数的g函数中，用树状数组维护g的前缀和。

每个f(x)最多只会被加入一次，最坏复杂度是$O(n\ log^2n+q\sqrt n\ log\ n)$。

```c++
#include<cstdio>
#include<iostream>
#include<algorithm>
using namespace std;
struct node{
	int n,m,a,h;
}q[20001];
struct delta{
	int z,h;
}f[200001];
int o[100001],sum[1000001],low[100001];
int prime[100001],t,ans[20001],maxn,mu[100001];
inline bool cmp(node c,node d){return c.a<d.a;}
inline bool cmp2(delta c,delta d){return c.z<d.z;}
inline int lowbit(int x){return x&(-x);}
inline void add(int x,int y){while (x<=maxn) sum[x]+=y,x+=lowbit(x);}
inline int query(int x){int num=0; while (x) num+=sum[x],x-=lowbit(x); return num;}
inline void euler(){
	o[1]=f[1].z=mu[1]=low[1]=1;
	for (int i=2; i<=maxn; i++){
		if (!o[i]){
			prime[++prime[0]]=i;
			f[i].z=low[i]=i+1; ; mu[i]=-1;
		}
		for (int j=1; j<=prime[0]&&prime[j]*i<=maxn; j++){
			o[i*prime[j]]=1;
			if (i%prime[j]==0){
				f[i*prime[j]].z=f[i].z/low[i]*(low[i]*prime[j]+1);
				low[i*prime[j]]=low[i]*prime[j]+1;
				break;
			}
			f[i*prime[j]].z=f[i].z*f[prime[j]].z;
			low[i*prime[j]]=prime[j]+1;
			mu[i*prime[j]]=-mu[i];
		}
	}
	for (int i=1; i<=maxn; i++) f[i].h=i;
//	for (int i=1; i<=maxn; i++){
//		g[i].h=i;
//		for (int j=i; j<=maxn; j+=i)
//			g[j].z+=f[i].z*mu[j/i];
//	}
//	for (int i=1; i<=maxn; i++) printf("%d ",g[i].z);
//	puts("");
//	sort(g+1,g+maxn+1,cmp2);
	sort(f+1,f+maxn+1,cmp2);
}
int main(){
	scanf("%d",&t);
	for (int i=1; i<=t; i++){
		scanf("%d%d%d",&q[i].n,&q[i].m,&q[i].a);
		if (q[i].n>q[i].m) swap(q[i].n,q[i].m);
		q[i].h=i; maxn=max(maxn,q[i].m);
	}
	sort(q+1,q+t+1,cmp); euler(); int k=1,n,m,a;
	for (int i=1; i<=t; i++){
		n=q[i].n,m=q[i].m,a=q[i].a;
		while (f[k].z<=a&&k<=maxn){
			for (int j=f[k].h; j<=maxn; j+=f[k].h)
				add(j,f[k].z*mu[j/f[k].h]);
//				g[j]+=;
//			add(g[k].h,g[k].z);
			k++;
		}
		for (int l=1,r; l<=n; l=r+1){
			r=min(n/(n/l),m/(m/l));
			ans[q[i].h]+=(n/l)*(m/l)*(query(r)-query(l-1));
		}
	}
	for (int i=1; i<=t; i++) printf("%d\n",ans[i]&(~(1<<31)));
	return 0;
}
```

---

## 作者：Dirichlet (赞：1)


令$g(k)=\sum\limits_{i=1}^n \sum\limits_{j=1}^m gcd(i,j)==k$

$g(k)=\sum\limits_{i|d} \mu(\frac{d}{i})\cdot \lfloor \frac{n}{d} \rfloor   \lfloor \frac{m}{d} \rfloor$

那么 $\sum\limits_{i=1}^n \sum\limits_{j=1}^m F(gcd(i,j))$

$=\sum\limits_{i=1}^n F(i)g(i)$

$=\sum\limits_{i=1}^n F(i) \sum\limits_{i|d} \mu(\frac{d}{i})\cdot \lfloor \frac{n}{d} \rfloor   \lfloor \frac{m}{d} \rfloor$

$=\sum\limits_{e=1}^n \lfloor \frac{n}{e} \rfloor   \lfloor \frac{m}{e} \rfloor \sum\limits_{i|e} F(i)\cdot \mu (\frac{e}{i})$

如果我们预处理 $\xi (e) = \sum\limits_{i|e} F(i)\cdot \mu (\frac{e}{i})$

就可以在$O(q\sqrt{n})$时间内求出答案.

现在考虑a的限制.

注意到所有$F(i)<a$的$i$会对答案产生贡献.

故将操作离线,对询问按$a$升序排序,对$F(i)$按$i$排序.

每次将所有满足要求的函数值插入"某个数据结构"中,该数据结构需支持单点修改和区间求和.

那当然是常数小又好写的BIT啦.

模数的特殊性质:

可以直接爆int取模.

蒟蒻的代码:

```cpp

#include<algorithm>
#include<cctype>
#include<cmath>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<iostream>
#include<ctime>
#include<map>
#include<queue>
#include<stack>
#include<vector>
#define size 520010
#define debug(x) cerr<<#x<<"="<<x
#define gc getchar()
#define db double
#define ll long long
#define rep(i,s,n) for (register int i=s;i<=n;i++)
#define drep(i,n,s) for (register int i=n;i>=s;i--)
#define il inline
using namespace std;

il ll r()
{
	char c; ll x,f=1;
	for (c=gc;!isdigit(c);c=gc) if (c=='-') f=-1; x=c-'0';
	for (c=gc;isdigit(c);c=gc) x=(x<<1)+(x<<3)+c-'0';
	return f*x;
}

int pri[size],mu[size+10],pnt;
bool isp[size+10];

void euler()
{
	mu[1]=1; isp[1]=1;
	rep(i,2,size)
	{
		if (!isp[i]) pri[++pnt]=i,mu[i]=-1;
		rep(j,1,pnt)
		{
			if (i*pri[j]>size) break;
			isp[i*pri[j]]=1;
			if (i%pri[j])
				mu[i*pri[j]]=-mu[i];
					else
					{
						mu[i*pri[j]]=0; break;
					}
		}
	}
	
}

struct qwq
{
	int n,m,a,id;
}q[20010];

bool cmp(qwq A,qwq B)
{
	return (A.a<B.a);
}

struct sigma
{
	int id,dat;
}seq[size];

bool cmp1(sigma S,sigma T)
{
	return (S.dat<T.dat);
}

int c[size],ans[size],T;
#define lb(x) x&(-x)

void add(int i,int x)
{
	for (;i<=100000;i+=lb(i)) c[i]+=x;
}

int query(int x)
{
	int ans=0; for (int i=x;i;i-=lb(i)) ans+=c[i]; return ans;
}

int calc(int n,int m)
{
	int ans=0;
	if (n>m) swap(n,m);
	for (int now=1,nxt;now<=n;now=nxt+1)
	{
		nxt=min(n/(n/now),(m/(m/now)));
		ans+=(n/now)*(m/now)*(query(nxt)-query(now-1));
	}
	return ans;
}

int main()
{
	euler();
	T=r();
	for (int i=1;i<=100000;i++)
	{
		seq[i].id=i;
	    for (int j=1;j*i<=100000;j++) seq[i*j].dat+=i;
	}
	sort(seq+1,seq+100000+1,cmp1);
	for (int i=1;i<=T;i++) {scanf("%d%d%d",&q[i].n,&q[i].m,&q[i].a);q[i].id=i;}
	sort(q+1,q+T+1,cmp);
	memset(c,0,sizeof(c));
	int tmp=0;
	for (int i=1;i<=T;i++)
	{
		while (tmp<100000 && seq[tmp+1].dat<=q[i].a)
		{
			tmp++;
			for (int j=1;j*seq[tmp].id<=100000;j++) add(j*seq[tmp].id,mu[j]*seq[tmp].dat);
		}	
		ans[q[i].id]=calc(q[i].n,q[i].m);
	}
	for (int i=1;i<=T;i++) printf("%d\n",ans[i]&0x7fffffff);
	return 0;
}

```

---

## 作者：intel_core (赞：0)

以下为表述方便，设$w(x)=\sum_{k|x}k$    
设$x=p_1^{c_1}\times p_2^{c_2}\times ....... \times p_k^{c_k}$     
易知$w(x)=\sum_{i=0}^{c_1}p_1^i \times \sum_{i=0}^{c_2}p_2^i \times .......\times \sum_{i=0}^{c_k}p_k^i$   

### 正文开始

如果没有$a$的限制，那易知：   
$Ans=\sum_{i=1}^n \sum_{j=1}^m w(gcd(i,j))$     
对于每个$gcd$的值，单独考虑     
用式子表达就是：   
$\sum_{i=1}^n \sum_{j=1}^m w(k)[gcd(i,j)==k]$    
$=\sum_{i=1}^{[\frac{n}{k}]} \sum_{j=1}^{[\frac{m}{k}]}w(k)[gcd(i,j)==1]$      
然后$Mobius$反演得   
$=\sum_{d=1}^n w(d) \sum_{i=1}^{[\frac{n}{k}]} \sum_{j=1}^{[\frac{m}{k}]} \sum_{k|d,k|d} μ(k)$   
这样我们就成功的将$a$的限制干掉了     
只需要对每个输入将$a$排个序离线处理就好了   
那我们现在的问题就是如何处理$ \sum_{i=1}^{[\frac{n}{k}]} \sum_{j=1}^{[\frac{m}{k}]} \sum_{k|d,k|d} μ(k)$     
这.......会莫反的人应该都知道吧    
上代码：    

```cpp
#include <iostream>
#include <algorithm>
#include <cstdio>
#include <cmath>
#include <queue>
#include <cstring>
using namespace std;
const int NR=1e5+10;
#define int long long
int prime[NR];
int mu[NR];
bool panduan[NR];
int tot,k;
void get_mu(int n){
    mu[1]=1;
    for(int i=2;i<=n;i++){
        if(!panduan[i]){
			mu[i]=-1;
			prime[++tot]=i;
		}
        for(int j=1;j<=tot&&i*prime[j]<=n;j++){
            panduan[i*prime[j]]=1;
            if(i%prime[j]==0)break;
            else mu[i*prime[j]]=-mu[i];
        }
    }
}
struct lcy{
	int idx;
	int num;
	bool operator <(const lcy &T)const{
		return num<T.num;
	}
}f[NR];
void init(int n){
	for(int i=1;i<=n;i++)
		for(int j=i;j<=n;j+=i)
			f[j].num+=i;
	for(int i=1;i<=n;i++)f[i].idx=i;
	sort(f+1,f+1+n);
}
struct query{
	int x,y;
	int num;
	int id;
	bool operator <(const query &T)const{
		return num<T.num;
	}
}a[NR];
int read()
{
	int x = 0, f = 1;
	char c = getchar();
	while(c<'0' || c>'9'){if(c=='-')f=-1; c = getchar();}
	while(c>='0'&&c<='9'){x = x*10+c-'0'; c = getchar();}
	return x*f;
}
int lowbit(int x){
	return x&(-x);
}
struct BIT{
	int c[NR];
	void add(int x,int y){
		while(x<=1e5){
			c[x]+=y;
			x+=lowbit(x);
		}
	}
	int sum(int x){
		int res=0;
		while(x>0){
			res+=c[x];
			x-=lowbit(x);
		}
		return res;
	}
};
BIT wxb;
int ans[NR];
signed main(signed argc, char const *argv[])
{
	//freopen("1.in","r",stdin);
	//freopen("1.out","w",stdout);
	int q;
	cin>>q;
	get_mu(1e5);
	init(1e5);
	for(int i=1;i<=q;i++){
		scanf("%lld%lld%lld",&a[i].x,&a[i].y,&a[i].num);
		a[i].id=i;
		if(a[i].x<a[i].y)swap(a[i].x,a[i].y);
	}
	sort(a+1,a+1+q);
	int now=0;
	for(int i=1;i<=q;i++){
		int n=a[i].x;
		int m=a[i].y;
		while(f[now+1].num<=a[i].num&&now<1e5){
			now++;
			int x=f[now].idx;
			for(int j=1;j*x<=1e5;j++)wxb.add(j*x,mu[j]*f[now].num);
		}
		ans[a[i].id]=0;
		for(int l=1,r;l<=m;l=r+1){
			r=min(m/(m/l),n/(n/l));
			//printf("%lld %lld %lld\n",l,r,(m/l)*(n/l));
			ans[a[i].id]+=(m/l)*(n/l)*(wxb.sum(r)-wxb.sum(l-1));
		}
	}
	for(int i=1;i<=q;i++)printf("%lld\n",ans[i]%(1<<31));
	return 0;
}

```


---

## 作者：zzw4257 (赞：0)

>求$\displaystyle{\sum_{i=1}^n\sum_{j=1}^m\sigma_1(ij)[\sigma_1(ij)\le a]}$

首先不管$\sigma_1(ij)\le a$

$$
\begin{aligned}
\sum_{i=1}^n\sum_{j=1}^m\sigma_1((i,j))
&=\sum_{d}\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{d}\rfloor}[(i,j)=1]\sigma_1(d)
\\&=\sum_{d}\sigma_1(d)\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{d}\rfloor}\sum_{p|i,p|j}\mu(p)
\\&=\sum_{d}\sigma_1(d)\sum_{p}\mu(p)\lfloor\frac{n}{dp}\rfloor\lfloor\frac{m}{dp}\rfloor
\\&=\sum_{T}\lfloor\frac{n}{T}\rfloor\lfloor\frac{m}{T}\rfloor\sum_{d|T}\sigma_1(d)\mu(\frac{T}{d})
\end{aligned}
$$

考虑$g(T)=\sum_{d|T}\sigma_1(d)\mu(\frac{T}{d})$

考虑如何维护$g(T)$这个卷积

考虑把询问的$a$排序,我们只需要管$\sigma_1(x)\in[a_{pre},a_{now}]$的$x$考虑到$\sum_{d|T}\sigma_1(d)\mu(\frac{T}{d})$中这个$x$实际上是$d$,贡献的$g$就是他的倍数位置

用一个树状数组即可

---

## 作者：jun头吉吉 (赞：0)

# 一道数论+数据结构的DuLiu题

我们要求的就是
$$Ans=\sum_{i=1}^n\sum_{j=1}^m\sum_{d|i\wedge d|j}d[\sum_{d|i\wedge d|j}d\leq a]$$
考虑到$d|i \wedge d|j$等价于$ d|gcd(i,j)$
$$Ans=\sum_{i=1}^n\sum_{j=1}^m\sum_{d|gcd(i,j)}d[\sum_{d|gcd(i,j)}d\leq a]$$
令$f(x)=\sum_{i|x}i$,即因子和,
把$f(x)$带入
$$Ans=\sum_{i=1}^n\sum_{j=1}^m f(gcd(i,j))[f(gcd(i,j))\leq a]$$
$$枚举因数$$
$$Ans=\sum_{d=1}^n \sum_{i=1}^{\lfloor\frac n d\rfloor}\sum_{j=1}^{\lfloor\frac m d\rfloor} f(d)[f(d)\leq a][gcd(i,j)==1]$$
把$f(d)[f(d)\leq a]$提前并使用莫比乌斯反演
$$Ans=\sum_{d=1}^n f(d)[f(d)\leq a]\sum_{i=1}^{\lfloor\frac n d\rfloor}\sum_{j=1}^{\lfloor\frac m d\rfloor} \sum_{x|gcd(i,j)} \mu(x)$$
$$把枚举x提前$$
$$Ans=\sum_{d=1}^n f(d)[f(d)\leq a]\sum_{x=1}^{\lfloor \frac n d \rfloor} \mu(x)\sum_{i=1}^{\lfloor\frac n d\rfloor}[x|i]\sum_{j=1}^{\lfloor\frac m d\rfloor}[x|j] $$
$$稍稍化简$$
$$Ans=\sum_{d=1}^n f(d)[f(d)\leq a]\sum_{x=1}^{\lfloor \frac n d \rfloor} \mu(x)\lfloor \frac n {dx}\rfloor \lfloor \frac m {dx}\rfloor $$
$$令dx=T$$
$$Ans=\sum_{T=1}^n\sum_{d|T} f(d)[f(d)\leq a]\mu(\frac T d)\lfloor \frac n T\rfloor \lfloor \frac m T\rfloor $$
我们发现，只有$f(d)\leq a$的$d$,才能对$ans$有贡献
辣么如果从$a\to a'$,$A=\{x,a<f(x)\leq a'\}$,会对$A$中所有元素及其倍数造成贡献
因此我们可以用某种数据结构来维护$\sum_{d|T} f(d)[f(d)\leq a]\mu(\frac T d)$,很明显BIT是一种很好的选择
```
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e5+10;
template <class T>inline void read(T &x){
	x=0;char c=getchar();
	for(;!isdigit(c);c=getchar());
	for(;isdigit(c);c=getchar())x=x*10+c-'0';
	return;
}
template <class T>void write(T x){
	if(x<0)putchar('-'),x=-x;
	if(x>=10)write(x/10);
	putchar(x%10+'0');
}
bool isprime[maxn];
int miu[maxn],prime[maxn],tot;
int sigma[maxn];//因数和 
void init(){
	memset(isprime,0xff,sizeof isprime);
	tot=0;miu[1]=1;
	for(int i=2;i<maxn;i++){
		if(isprime[i])
			prime[++tot]=i,miu[i]=-1;
		for(int j=1;j<=tot&&i*prime[j]<maxn;j++){
			isprime[i*prime[j]]=false;
			if(i%prime[j])
				miu[i*prime[j]]=-miu[i];
			else{
				miu[i*prime[j]]=0;
				break;
			}
		}
	}
	for(int i=1;i<maxn;i++)
		for(int j=1;i*j<maxn;j++)
			sigma[i*j]+=i;
}
struct BIT{
	#define lowbit(x) x&(-x)
	signed tree[maxn];
	void add(int x,int val){
		//printf("A %d %d\n",x,val);
		while(x<maxn){
			tree[x]+=val;
			x+=lowbit(x);
		}
	}
	signed query(int x){
		//printf("Q %d\n",x);
		signed ret=0;
		while(x){
			ret+=tree[x];
			x-=lowbit(x);
		}
		return ret;
	}
}A;
struct Num{
	int id,val;
	bool operator<(const Num b)const{return val<b.val;}
}S[maxn];
struct Que{
	int id,n,m,a;
	bool operator<(const Que b)const{return a<b.a;}
}Q[maxn];
signed ans[maxn];
int t;
void solve(){
	int now=0;//已经用过的S 
	for(int i=1;i<=t;i++){
		while(S[now+1].val<=Q[i].a&&now+1<maxn){
			now++;
			for(int j=1;j*S[now].id<maxn;j++)
				A.add(j*S[now].id,miu[j]*S[now].val);
		}
		ans[Q[i].id]=0;
		int n=max(Q[i].m,Q[i].n),m=min(Q[i].m,Q[i].n);
		for(int l=1,r;l<=m;l=r+1){
			r=min(m/(m/l),n/(n/l));
			ans[Q[i].id]+=(m/l)*(n/l)*(A.query(r)-A.query(l-1));
		}
	}
} 
signed main(){
	init();
	read(t);
	for(int i=1;i<maxn;i++)
		S[i]={i,sigma[i]};
	for(int i=1;i<=t;i++){
		Q[i].id=i;
		read(Q[i].n);read(Q[i].m);read(Q[i].a);
	}
	sort(S+1,S+maxn);sort(Q+1,Q+t+1);
	solve();
	for(int i=1;i<=t;i++)
		write((1ll*ans[i]+(1ll<<31))%(1ll<<31)),putchar('\n');
}
```

---

## 作者：clockwhite (赞：0)

# [SDOI2014]数表

## 一.题意简述

​	题目要求的是
$\sum\limits_{i=1}^{n}\sum\limits_{j=1}^{m}\sigma(gcd(i,j))<a$
那个是除数函数啦。（不知道的自己百度）

## 二.解题思路

​	有什么思路，干就完了，奥利给！！这个$<a$很碍眼，反手扔了不虚他。于是要求解
$$
\sum\limits_{d=1}^{n}\sum\limits_{i=1}^{\lfloor\frac{n}{d}\rfloor}
\sum\limits_{j=1}^{\lfloor\frac{m}{d}\rfloor}\sigma(d)[gcd(i,j)=1]
$$
虽说这一步跨度有点大，但是是可以理解的，对于大多数gcd都会选择起手枚举gcd的值，而这里的$i,j$相当于是系数一样的东西叭。由于是枚举的最大公约数，所以$i,j$要互质才好,这是常规操作。

现在发现了一只野生的$\epsilon$，（如果读不懂这句话请先看[这篇文章](https://www.cnblogs.com/clockwhite/p/12251003.html))，那么就把他换成$\mu$.（基操）
$$
\sum\limits_{d=1}^{n}\sum\limits_{i=1}^{\lfloor\frac{n}{d}\rfloor}
\sum\limits_{j=1}^{\lfloor\frac{m}{d}\rfloor}\sigma(d)\sum\limits_{k|gcd(i,j)}^{}\mu(k)
$$
然后走一波换位+基操
$$
\sum\limits_{d=1}^{n}\sigma(d)\sum\limits_{k=1}^{\lfloor\frac{n}{d}\rfloor}\mu(k)
\lfloor\frac{n}{dk}\rfloor\lfloor\frac{m}{dk}\rfloor
$$
其实这里也是在枚举gcd，跟上面思路差不多，再不想让d干扰，换了个位置。
$$
(p=dk)\sum\limits_{p=1}^{n}\lfloor\frac{n}{p}\rfloor\lfloor\frac{m}{p}
\rfloor\sum\limits_{d|p}^{}\mu(d)\sigma(\frac{p}{d})
$$
乘积形式的分母不好看，换一手元，交换位置。

本来这样就好了，但是题目有个a。于是想着怎么把他找回来，加进去吧
$$
(p=dk)\sum\limits_{p=1}^{n}\lfloor\frac{n}{p}\rfloor\lfloor\frac{m}{p}
\rfloor\sum\limits_{d|p}^{}\mu(d)\sigma(\frac{p}{d})
\sum\limits_{d|p}^{}\mu(d)\sigma(\frac{p}{d})< a
$$
这个应该能看懂，首先以求和符号作为分界记后面的那一堆为$g(p)$好了，然后考虑一下$\mu$函数的性质，了解到$\sigma(\frac{p}{d})<=a$才对答案有贡献，然而又有多组数据，并且除数函数值的大小跟参数大小没有什么关系，是乱的。（开始暴躁）

不过不慌，我们把$\sigma$和a都拉来排个序，新的a出现时便用符合条件的$\sigma$去更新$g$，再用数论分块算一算。（还是看代码吧）

## 三.CODE

```c++
#define ll long long
#define m_for(i,a,b) for(int i=a;i<=b;++i)
#define lowbit(x) x&(-x)
inline int read() {
	int s=0,w=1;
	char ch=getchar();
	while(ch<'0'||ch>'9') {
		if(ch=='-')w=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
	return s*w;
}
const int MAXN=1e5+1,MAXQ=2*1e4+1;
ll mod=1LL<<31;
int prime[MAXN],tot,mu[MAXN];
ll g[MAXN];
pair<int,int> sigma[MAXN];
bool vis[MAXN];
void m_p(int x){
	sigma[1].first=sigma[1].second=1;
	mu[1]=1;
	m_for(i,2,x){
		sigma[i].first++;
		if(!vis[i])prime[++tot]=i,mu[i]=-1;
		for(int j=1;j<=tot&&i*prime[j]<=x;++j){
			vis[i*prime[j]]=1;
			if(i%prime[j]==0)break;
			mu[i*prime[j]]=-mu[i];
		}
		for(int j=i;j<=x;j+=i)sigma[j].first=(sigma[j].first+i)%mod;
		sigma[i].second=i;
	}
	sort(sigma+1,sigma+x+1);
}
struct alf{
	int n,m,a,id;
}que[MAXQ];
bool cmp(alf c,alf b){
	return c.a<b.a;
}
int tree_g[MAXN];
void change(int x,int y){
	for(;x<MAXN;x+=lowbit(x))tree_g[x]+=y;
}
ll sum(int x){
	ll res=0;
	for(;x>0;x-=lowbit(x))res+=tree_g[x];
	return res;
}
ll solve(int n,int m){
	if(n>m)swap(n,m);
	ll res=0;
	for(int l=1,r;l<=n;l=r+1){
		r=min(n/(n/l),m/(m/l));
		res+=1LL*(n/l)*(m/l)*(sum(r)-sum(l-1));
		res%=mod;
	}
	return (res%mod+mod)%mod;
}
int q,res=1;
int ans[MAXQ];
int main(){
m_p(MAXN);
q=read();
m_for(i,1,q)que[i].id=i,que[i].n=read(),que[i].m=read(),que[i].a=read();
sort(que+1,que+q+1,cmp);
m_for(i,1,q){
	while(sigma[res].first<=que[i].a&&res<=MAXN){
		for(int j=1;j*sigma[res].second<=MAXN;++j)
			change(j*sigma[res].second,mu[j]*sigma[res].first);
		res++;
	}
	ans[que[i].id]=solve(que[i].n,que[i].m)%mod;
}
m_for(i,1,q)cout<<ans[i]<<endl;
return 0;
}
```


---


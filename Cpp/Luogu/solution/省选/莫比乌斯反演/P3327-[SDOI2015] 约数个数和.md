# [SDOI2015] 约数个数和

## 题目描述

设 $d(x)$ 为 $x$ 的约数个数，给定 $n,m$，求    
$$\sum_{i=1}^n\sum_{j=1}^md(ij)$$


## 说明/提示

【数据范围】   
对于 $100\%$ 的数据，$1\le T,n,m \le 50000$。


## 样例 #1

### 输入

```
2
7 4
5 6```

### 输出

```
110
121```

# 题解

## 作者：Siyuan (赞：357)

[$$\Large\texttt{My Blog}$$](https://hydingsy.github.io/)

---
## 写在前面

> 貌似没有题解证明了如下公式：$$d(ij)=\sum\limits_{x\mid i}\sum\limits_{y\mid j} [\gcd(x,y)=1]$$
> 于是在此篇题解的 `Extended` 部分我会给出一种证明！

---

> 题目链接：https://www.lydsy.com/JudgeOnline/problem.php?id=3994

求解（多组数据）

$$\sum\limits_{i=1}^N\sum\limits_{j=1}^M d(ij)$$

数据范围：$1\leqslant N,M,T\leqslant 5\times 10^4$

---

## Solution

首先给出一个公式：

$$d(ij)=\sum\limits_{x\mid i}\sum\limits_{y\mid j} [\gcd(x,y)=1]$$

因此所求为

$$\sum\limits_{i=1}^n\sum\limits_{j=1}^m\sum\limits_{x\mid i}\sum\limits_{y\mid j} [\gcd(x,y)=1]$$

改变求和顺序，先枚举因数 $x$ 和 $y$

$$\sum\limits_{x=1}^n\sum\limits_{y=1}^m \left\lfloor\frac{n}{x}\right\rfloor \left\lfloor\frac{m}{y}\right\rfloor [\gcd(x,y)=1]$$

将 $x,y$ 换成 $i,j$ 吧 QAQ

$$\sum\limits_{i=1}^n\sum\limits_{j=1}^m \left\lfloor\frac{n}{i}\right\rfloor \left\lfloor\frac{m}{j}\right\rfloor[\gcd(i,j)=1]$$

开始莫比乌斯反演！设

$$f(x)=\sum\limits_{i=1}^n\sum\limits_{j=1}^m \left\lfloor\frac{n}{i}\right\rfloor \left\lfloor\frac{m}{j}\right\rfloor[\gcd(i,j)=x]$$

$$g(x)=\sum_{x\mid d} f(d)$$

则有

$$g(x)=\sum\limits_{i=1}^n\sum\limits_{j=1}^m \left\lfloor\frac{n}{i}\right\rfloor \left\lfloor\frac{m}{j}\right\rfloor[x\mid\gcd(i,j)]$$

我们把 $x$ 提出就可以消除 $\gcd$ 的影响

$$g(x)=\sum\limits_{i=1}^{\frac{n}{x}}\sum\limits_{j=1}^{\frac{m}{x}} \left\lfloor\frac{n}{ix}\right\rfloor \left\lfloor\frac{m}{jx}\right\rfloor$$

再根据 $f(x)$ 的定义，得到答案为 $f(1)$

又因为

$$f(n)=\sum\limits_{n\mid d}\mu(\frac{d}{n})g(d)$$

故

$$f(1)=\sum\limits_{1\mid d}\mu(\frac{d}{1})g(d)=\sum_{i=1}^n \mu(i)g(i)$$

接下来再考虑如何求 $g(x)$，我们可以先计算 $s(x)=\sum\limits_{i=1}^{x} \left\lfloor\frac{x}{i}\right\rfloor$，就可以 $\Theta(1)$ 计算 $g(x)$。

**时间复杂度**：$\Theta(T\sqrt{n})$

---

## Code

```cpp
#include <cstdio>
#include <algorithm>
const int N=5e4+5;
int tot,mu[N],p[N];
long long s[N];
bool flg[N];

void init() {
    mu[1]=1;
    for(int i=2;i<=5e4;++i) {
        if(!flg[i]) p[++tot]=i,mu[i]=-1;
        for(int j=1;j<=tot&&i*p[j]<=5e4;++j) {
            flg[i*p[j]]=1;
            if(i%p[j]==0) {
                mu[i*p[j]]=0;
                break;
            } else {
                mu[i*p[j]]=-mu[i];
            }
        }
    }
    for(int i=1;i<=5e4;++i) mu[i]+=mu[i-1];
    for(int x=1;x<=5e4;++x) {
        long long res=0;
        for(int i=1,j;i<=x;i=j+1) j=x/(x/i),res+=1LL*(j-i+1)*(x/i);
        s[x]=res;
    }
}
int main() {
    init();
    int T;
    for(scanf("%d",&T);T--;) {
        int n,m;
        scanf("%d%d",&n,&m);
        if(n>m) n^=m^=n^=m;
        long long ans=0;
        for(int i=1,j;i<=n;i=j+1) {
            j=std::min(n/(n/i),m/(m/i));
            ans+=1LL*(mu[j]-mu[i-1])*s[n/i]*s[m/i];
        }
        printf("%lld\n",ans);
    }
    return 0;
}
```

---

## Extended

如何证明 `Solution` 中的公式？

$$d(ij)=\sum\limits_{x\mid i}\sum\limits_{y\mid j} [\gcd(x,y)=1]$$

我们考虑把每个因子一一映射。

如果 $ij$ 的因子 $k$ 中有一个因子 $p^c$，$i$ 中有因子 $p^a$，$j$ 中有因子 $p^b$。我们规定：

- 如果 $c\leqslant a$，那么在 $i$ 中选择。
- 如果 $c>a$，那么我们把 $c$ 减去 $a$，在 $j$ 中选择 $p^{c-a}$（在 $j$ 中选择 $p^e$ 表示的是 $p^{a+e}$）

对于 $ij$ 的因子 $k$ 的其他因子同理。于是对于任何一个 $k$ 有一个唯一的映射，且每一个选择对应着唯一的 $k$。

通过如上过程，我们发现：对于 $ij$ 的因子 $k=\prod {p_i}^{c_i}$，我们不可能同时在 $i$ 和 $j$ 中选择 $p_i$（优先在 $i$ 中选择，如果不够就只在 $j$ 中选择不够的指数），故 $x$ 和 $y$ 必须互质。

等式得证。

---

## 作者：pengym (赞：74)

我顺便来安利一下自己的博客[peng-ym's blog](http://www.cnblogs.com/peng-ym/)里面也有[莫比乌斯反演](http://www.cnblogs.com/peng-ym/p/8647856.html)与[整除分块](http://www.cnblogs.com/peng-ym/p/8661118.html)的介绍，不知道的可以看一看哦！
### 题目描述
- 设$d(x)$为$x$的约数个数，给定$N、M$，求$\sum_{i=1}^{N}\sum_{j=1}^{m}d(ij)$

### 解题思路
- 这道题，如果是第一次做，或者是不了解$d(x)$这个约数个数函数的某些神奇性质，那么是很难往下面继续推的。~~（我也是最近才知道的2333）~~
- 很显然，这题的难点就是这个约数个数函数。因此，我先给出这个函数的一个重要性质：
$$d(ij)=\sum_{x|i}\sum_{y|j}[gcd(x,y)=1]$$
至于具体的证明，还是感性的理解一下吧。
- 知道这个式子后，我们就可以开始尝试去推了。
- 我们极其套路的去设几个函数(PS:如果不知道为什么要这样设，可以去看一看[YY的GCD](http://www.cnblogs.com/peng-ym/p/8652288.html)):
$$f(d)=\sum_{i=1}^{n}\sum_{j=1}^{m}[gcd(i,j)=d]$$
$$F(n)=\sum_{n|d}f(d)$$
由莫比乌斯反演可以得到：
$$f(n)=\sum_{n|d}\mu(\lfloor\frac{d}{n}\rfloor)F(d)$$
我们所求的为Ans：
$$Ans=\sum_{i=1}^{n}\sum_{j=1}^{m}d(ij)$$
$$Ans=\sum_{i=1}^{n}\sum_{j=1}^{m}\sum_{x|i}\sum_{y|j}[gcd(x,y)=1]$$
看到这个$[gcd(x,y)=1]$，我们就可以根据$\mu$的性质把它带进去,如果不知道的话可以去看看我写的[莫比乌斯反演](http://www.cnblogs.com/peng-ym/p/8647856.html)
$$Ans=\sum_{i=1}^{n}\sum_{j=1}^{m}\sum_{x|i}\sum_{y|j}\sum_{d|gcd(x,y)}\mu(d)$$
更换枚举项，由枚举$gcd(x,y)$的约数，改为直接枚举$d$
$$Ans=\sum_{i=1}^{n}\sum_{j=1}^{m}\sum_{x|i}\sum_{y|j}\sum_{d=1}^{min(n,m)}\mu(d)*[d|gcd(x,y)]$$
将$\mu(d)$可以提出来，因为它与$i,j$无关
$$Ans=\sum_{d=1}^{min(n,m)}\mu(d)\sum_{i=1}^{n}\sum_{j=1}^{m}\sum_{x|i}\sum_{y|j}[d|gcd(x,y)]$$
接着，由枚举$i,j$和它们的约数改变为，枚举它们的约数再直接乘上这些约数的倍数的个数。因为每一个约数都会对它的倍数产生贡献。
$$Ans=\sum_{d=1}^{min(n,m)}\mu(d)\sum_{x=1}^{n}\sum_{y=1}^{m}[d|gcd(x,y)]\lfloor\frac{n}{x}\rfloor\lfloor\frac{m}{y}\rfloor$$
我们再一次更换枚举项，将枚举$x,y$换为枚举$dx,dy$。这样$[d|gcd(x,y)]$这个条件就可以省去。
$$Ans=\sum_{d=1}^{min(n,m)}\mu(d)\sum_{x=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{y=1}^{{\lfloor\frac{m}{d}\rfloor}}\lfloor\frac{n}{dx}\rfloor\lfloor\frac{m}{dy}\rfloor$$
我们可以发现$\lfloor\frac{n}{dx}\rfloor$与$y$无关，所以可以提前。
$$Ans=\sum_{d=1}^{min(n,m)}\mu(d)(\sum_{x=1}^{\lfloor\frac{n}{d}\rfloor}\lfloor\frac{n}{dx}\rfloor)(\sum_{y=1}^{{\lfloor\frac{m}{d}\rfloor}}\lfloor\frac{m}{dy}\rfloor)$$
当我们将式子化简成这样的时候，我们已经可以看出，这个式子已经可以做到$O(n)$计算了。但是，由于存在多组数据，所以我们就可以运用整除分块，将这个式子优化成$O(\sqrt{n})$的时间复杂度。(如果不知道整除分块，可以去看看我写的[整除分块](http://www.cnblogs.com/peng-ym/p/8661118.html))
- 这样，这道题就可以A了。

### 还是贴一下我的代码吧

```cpp
#include<bits/stdc++.h>
#define N 50100
using namespace std;
inline void read(int &x)
{
    x=0;
    static int p;p=1;
    static char c;c=getchar();
    while(!isdigit(c)){if(c=='-')p=-1;c=getchar();}
    while(isdigit(c)) {x=(x<<1)+(x<<3)+(c-48);c=getchar();}
    x*=p;
}
bool vis[N];
int prim[N],cnt,mu[N],sum[N];
long long g[N];
void get_mu(int n)
{
    mu[1]=1;
    for(int i=2;i<=n;i++)
    {
        if(!vis[i]){prim[++cnt]=i;mu[i]=-1;}
        for(int j=1;j<=cnt&&prim[j]*i<=n;j++)
        {
            vis[prim[j]*i]=1;
            if(i%prim[j]==0)break;
            else mu[i*prim[j]]=-mu[i];
        }
    }
    for(int i=1;i<=n;i++)sum[i]=sum[i-1]+mu[i];
    for(int i=1;i<=n;i++)
    {
        long long ans=0;
        for(int l=1,r;l<=i;l=r+1)
        {
            r=(i/(i/l));
            ans+=1ll*(r-l+1)*1ll*(i/l);
        }
        g[i]=ans;
    }
}
int main()
{
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
    int t;
    read(t);
    get_mu(50000);
    while(t--)
    {
        static int n,m;
        read(n);read(m);
        static int max_rep;max_rep=min(n,m);
        static long long ans;ans=0;
        for(int l=1,r;l<=max_rep;l=r+1)
        {
            r=min(n/(n/l),m/(m/l));
            ans+=(sum[r]-sum[l-1])*1ll*g[n/l]*1ll*g[m/l];
        }
        printf("%lld\n",ans);
    }
    return 0;
}
```

---

## 作者：洛水·锦依卫 (赞：48)

[To My Blog](https://www.cnblogs.com/luoshuitianyi/p/10834153.html)

# Algorithm
莫比乌斯反演

# Mentality
显然是莫比乌斯反演啊！

不过做这题的话，我们不难发现：$d(ij)$ 非常的不好求！如果枚举因数的话，那肯定会出锅，因为 $ij$ 最高有 $10^{10}$ ，所以必定超时。那怎么办呢？

可以考虑从 $i$ 与 $j$ 的因数入手。

那么我们先考虑 $i$ ，对于任意一个数 $i$ ，它必定都能分解成 $i=\prod_{p\in prime}p^{x_p}$ 次方这样的形式，其中 $x$ 数列为 $i$ 的每个质因子的次数序列。

所以，我们先考虑怎么求 $d(i)$ ，我们可以枚举 $i$ 的每个质因子选多少个乘起来，由于每一个不同的数分解成的质因数乘法必定是唯一的，所以我们只需要枚举有多少个本质不同的质因数乘法序列即可。由于还要再加上不选这个因数的选择，所以 $d(i)$ 的计算方法即为：

$$
d(i)=\prod_{p\in prime}(x_p+1)
$$

从这个角度入手，我们就可以考虑如何计算 $d(ij)$ 了，设 $y$ 数列为 $j$ 的每个质因子次数序列，则也有：

$$
d(j)=\prod_{p\in prime}(y_p+1)
$$

那么如何计算 $d(ij)$ 呢？其实从枚举质因子的角度来看，就很简单了。我们可以枚举 $i$ 和 $j$ 的因数 $a|i$ 与 $b|j$ ，则 $ab$ 亦为 $ij$ 的因数之一。不难发现，我们的重点是在枚举两个因数的时候，避免两个因数的质因数分解序列的乘积与之前出现过的乘积有重合，那怎么办呢？

回忆一下：当我们思考怎么计算 $d(i)$ 的时候，我们的第一想法是可以枚举每个质因子选多少个，这种时候，对于一个质因子 $p$ 而言，它在枚举序列中会被枚举出 $x_p$ 种不同的大小，即：$p^1,p^2,\dots ,p^{x_p}$ 这几个不同的数。也即 $p$ 这一位总共会被枚举 $x_p$ 次。

那么我们发现，当在计算 $d(ij)$ 时，只需要保证每个质因子被枚举相应次数即可。

换句话说，对于 $p|ij$ ，它理应被枚举 $x_p+y_p$ 次！

那么当我们枚举 $a|i$ 和 $b|j$ 时，应该怎么处理呢？

其实这时，你会发现一个很简单的事情，那就是我们只需要确保 $gcd(a,b)=1$ ，那么 $a,b$ 中就不会含有相同的质因子。那么当我们枚举某个质因子 $p|a$ 的时候，它会被枚举 $x_p$ 次，而当我们枚举 $p|b$ 时，它会被枚举 $y_p$ 次！

换句话说，只需要确保 $gcd(a,b)=1$ ，就能使枚举过程中，不会出现重复的质因子序列了！

所以，我们可以得到 $d(ij)$ 的表达式了：

$$d(ij)=\sum_{x|i}\sum_{y|j}[gcd(x,y)=1]$$

接下来就是很简单的套路了！

先设 $n\le m$

$$\sum_{i=1}^n \sum_{j=1}^m d(ij)$$

$$\sum_{i=1}^n \sum_{j=1}^m \sum_{x|i}\sum_{y|j}[gcd(x,y)=1]$$

接着，根据常见套路，我们改为枚举 $x,y$ :

$$\sum_{x=1}^n \sum_{y=1}^m [gcd(x,y)=1]\sum_{i=1}^{n}\sum_{j=1}^m [x|n\&\&y|j]$$

$$\sum_{x=1}^n \sum_{y=1}^m [gcd(x,y)=1]\lfloor\frac{n}{x}\rfloor\lfloor\frac{m}{y}\rfloor$$

再把莫比乌斯函数套进去：

$$\sum_{x=1}^n \sum_{y=1}^m\sum_{d|gcd(x,y)}\mu(d)\lfloor\frac{n}{x}\rfloor\lfloor\frac{m}{y}\rfloor$$

再次根据常见套路，我们改为枚举 $d$ ：

$$\sum_{d=1}^n\mu(d)\sum_{x=1}^n\sum_{y=1}^m[d|x\&\&d|y]\lfloor\frac{n}{x}\rfloor\lfloor\frac{m}{y}\rfloor$$

那么又一次根据常见套路，继续减少枚举次数：

$$\sum_{d=1}^n\mu(d)\sum_{x=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{y=1}^{\lfloor\frac{m}{d}\rfloor}\lfloor\frac{n}{xd}\rfloor\lfloor\frac{m}{yd}\rfloor$$

为了更直观地体现，我们需要根据乘法分配率将式子分成两个部分分别计算，然后乘在一起：

$$\sum_{d=1}^n\mu(d)(\sum_{x=1}^{\lfloor\frac{n}{d}\rfloor}\lfloor\frac{n}{xd}\rfloor)(\sum_{y=1}^{\lfloor\frac{m}{d}\rfloor}\lfloor\frac{m}{yd}\rfloor)$$

那么我们就这样得到了最终的式子。

接下来，我们只需要正常整除分块就好了！因为对于式子中的 $\lfloor\frac{n}{xd}\rfloor$ 来讲呢，我们可以拆成 $(n/d)/x$ ，所以就可以预处理一个函数 $f(x)=\sum_{i=1}^x \lfloor\frac{x}{i}\rfloor$ ，则：

$$ans=\sum_{d=1}^n\mu(d)*f(\lfloor\frac{n}{d}\rfloor)*f(\lfloor\frac{m}{d}\rfloor)$$

再预处理一下 $\mu$ 函数的前缀和，那么一切都只是整除分块而已，分块后面两个函数的值即可，~~吸溜~~。

# Code
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int T,n,m;
int cntp,pri[50001];
long long ans,mu[50001],f[50001];
bool vis[50001];
void init()
{
    mu[1]=1;
    for(int i=2;i<=50000;i++)
    {
        if(!vis[i])pri[++cntp]=i,mu[i]=-1;
        for(int j=1;j<=cntp&&pri[j]*i<=50000;j++)
        {
            vis[pri[j]*i]=true;
            if(!(i%pri[j]))break;
            mu[pri[j]*i]=-mu[i];
        }
    }//求莫比乌斯函数
    for(int i=1;i<=50000;i++)mu[i]+=mu[i-1];//前缀和
    for(int i=1;i<=50000;i++)
        for(int l=1,r;l<=i;l=r+1)
        {
            r=i/(i/l);
            f[i]+=1ll*(r-l+1)*(i/l);
        }//求 f 函数
}
int main()
{
    cin>>T;
    init();
    while(T--)
    {
        scanf("%d%d",&n,&m);
        if(n>m)swap(n,m);
        ans=0;
        for(int l=1,r;l<=n;l=r+1)
        {
            r=min(n/(n/l),m/(m/l));
            ans+=1ll*(mu[r]-mu[l-1])*f[n/l]*f[m/l];//整除分块计算答案
        }
        printf("%lld\n",ans);
    }
}
```

---

## 作者：suncongbo (赞：46)

看了七八篇题解才懂公式$$d(xy)=\sum_{i|x} \sum_{j|y} [gcd(x,y)==1]$$的证明，在这里写一下我的个人看法——
我们不妨将每一个质因子分开考虑，设x,y分别含有a,b个质因子p (这说明$p^a|x, p^{a+1}$不整除x, b和y同理), 显然乘积xy会含有a+b个p质因子，在等式左边，我们选质因子p的不同选法有a+b+1种，就是选0次，1次，..., a+b次; 在等式右边，选质因子p的不同选法也有a+b+1种，即从x中选(1~a)个y中选0个、从x中选0个y中选(1~b)个、x和y中各选0个，共a+b+1种。

因此，对于x=p^a和y=p^b, 上式成立。

又因为质因子之间互相独立，所以对于x和y可以分拆成多个质因子的情况，上式依然成立。

后面的莫比乌斯反演部分参照楼下。

本人菜鸟，上述论证有不当之处敬请指教，谢谢。

---

## 作者：Soulist (赞：27)

首先是一个莫名奇妙的式子$QAQ$

$$d(ij) = \sum_{x|i}\sum_{y|j}gcd(x,y) == 1$$

然后有了这个式子，我们就可以套用莫比乌斯函数的性质了！（蒟蒻太弱不会反演）

$$\sum_{i=1}^n\sum_{j=1}^m\sum_{x/i}\sum_{y/i}gcd(x,y)==1$$
然后把那个丑陋的$gcd(x,y)==1$换成莫比乌斯函数

$$\sum_{i=1}^n\sum_{j=1}^m\sum_{x/i}\sum_{y/j}\sum_{d/gcd(x,y)}μ(d)$$

然后先枚举$d,$就变成了
$$\sum_{d=1}^n\sum_{x=1}^{n/d}\sum_{i=1}^{n/d/x}\sum_{y=1}^{m/d}\sum_{j=1}^{m/d/y}μ(d)$$
然后我们再消掉两个丑陋的$\sum$

就变成了

$$\sum_{d=1}^n\sum_{x=1}^{n/d}\left\lfloor\dfrac{n}{d*x}\right\rfloor\sum_{y=1}^{m/d}\left\lfloor\dfrac{m}{d*y}\right\rfloorμ(d)$$

然后把$μ(d)$提到前面去：再利用这个式子：$a/(b*c) = (a/b)/c$

就变成了：

$$\sum_{d=1}^nμ(d)\sum_{x=1}^{n/d}\left\lfloor\dfrac{\left\lfloor\dfrac{n}{d}\right\rfloor}{x}\right\rfloor\sum_{y=1}^{m/d}\left\lfloor\dfrac{\left\lfloor\dfrac{m}{d}\right\rfloor}{y}\right\rfloor$$



如果我们设$p\ = n/d,  q = m/d$

那么式子就变成了：

$$\sum_{d=1}^nμ(d)\sum_{x=1}^{p}\left\lfloor\dfrac{p}{x}\right\rfloor\sum_{y=1}^{q}\left\lfloor\dfrac{q}{y}\right\rfloor$$

然后我们可以惊喜的发现，后面那一坨东西居然是可以预处理的$QAQ$

然后我们如果设$f(x) = \sum_{i = 1}^x\left\lfloor\dfrac{x}{i}\right\rfloor$

那么原式就变成了：

$$\sum_{d=1}^nμ(d)*f(p)*f(q)$$

$$p=\left\lfloor\dfrac{n}{d}\right\rfloor,q=\left\lfloor\dfrac{m}{d}\right\rfloor$$

然后因为看到下取整，我们就知道喜闻乐见的整除分块来了。。。

然后这道题就做完了？

不，当然不，因为还有一个地方有那么一点点小问题。。。

关于函数$f(x) = \sum_{i = 1}^x\left\lfloor\dfrac{x}{i}\right\rfloor$，如果我们朴素地求，那么其实复杂度是$O(N^2)$的，**但是！**我们看到了这个东西！：

$$\left\lfloor\dfrac{x}{i}\right\rfloor$$

这不是告诉你可以整除分块吗？？？没错是的。。。然后我们就把这道题做完了....

复杂度$O(N\sqrt{N} + T\sqrt{N})$

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int read(){
	char cc = getchar(); int cn = 0, flus = 1;
	while(cc < '0' || cc > '9'){
    	if(cc == '-') flus = -flus;
		cc = getchar();
	}
	while(cc >= '0' && cc <= '9')
	    cn = cn * 10 + cc - '0', cc = getchar();
	return cn * flus;
}
const int N = 50000 + 5;
int u[N], sum[N], pm[N], n, f[N], top;
bool isp[N];
void init(){
	u[1] = 1;
	for(int i = 2; i <= n; i++){
		if(!isp[i]){
			pm[++top] = i;
			u[i] = -1;
		}
		for(int j = 1; j <= top; j++){
			int p = pm[j];
			if(p * i > n) break;
			if(i % p == 0){
				isp[p * i] = 1;
				break;
			}
			isp[p * i] = 1;
			u[p * i] = u[p] * u[i];
		}
	}
	int l, r;
	for(int i = 1; i <= n; i++){
		for(l = 1; l <= i; l = r + 1){
			r = i/(i/l);
			f[i] += (r - l + 1) * (i/l);
		}
		sum[i] = sum[i - 1] + u[i];
	}
}
int solve(int x, int y){
	if(x > y) swap(x, y);
	int ans = 0, l = 1, r;
	for(l = 1; l <= x; l = r + 1){
		r = min((x/(x/l)), (y/(y/l)));
		ans += (sum[r] - sum[l - 1]) * f[x/l] * f[y/l];
	}
	return ans;
}
signed main()
{
	n = 50000;
	init();
	int T = read(), a, b;
	while(T--){
		a = read(); b = read();
		printf("%lld\n", solve(a, b));
	}
	return 0;
}
```

---

## 作者：Lates (赞：19)

第一道自己推出来的莫比乌斯反演题。

下文默认 $n\le m$

下文 $\varepsilon(x)=[x=1]=\sum_{d|x}\mu(d)$

---
题意：求

$$\sum_{x=1}^{n}\sum_{y=1}^{m}d(xy)$$

可以在度娘上找到

$$d(xy)=\sum_{i=1}^{n}[i|x]\sum_{j=1}^{m}[j|y][\gcd(i,j)=1]$$

带入式子

$$= \sum_{x=1}^n\sum_{y=1}^m\sum_{i=1}^{n}[i|x]\sum_{j=1}^{m}[j|y][\gcd(i,j)=1]$$

更换枚举顺序，先枚举 $i,j$，则前面枚举的 $x,y$ 需满足 $i|x,j|y$

$$= \sum_{i=1}^{n}\sum_{j=1}^{m}\sum^n_{i|x}\sum^m_{j|y}[\gcd(i,j)=1]$$

可以发现 $\sum^n_{i|x}\sum^m_{j|y}$，这两个式子就是分别求 $1$ ~ $n$ 中 $i$ 的倍数的个数和 $1 $ ~ $m$ 中 $j$ 的倍数的个数，这两个和式等价于 $n/i,m/j$，所以

$$= \sum_{i=1}^{n}\sum_{j=1}^{m} \left \lfloor \frac{n}{i}\right \rfloor \left \lfloor \frac{m}{j}\right \rfloor [\gcd(i,j)=1]$$

套路的把 $[\gcd(i,j)=1]$ 换成 $\varepsilon(\gcd(i,j))$，再把它转成 $\sum_{d|\gcd(i,j)}\mu(d)$ 的形式

$$= \sum_{i=1}^{n}\sum_{j=1}^{m} \left \lfloor \frac{n}{i}\right \rfloor \left \lfloor \frac{m}{j}\right \rfloor \sum_{d|\gcd(i,j)}\mu(d)$$

改变枚举顺序，先枚举 $d$，并把 $\mu(d)$ 提到式子前面，因为 $d|\gcd(i,j)$，必有 $d|i ,d|j$

$$= \sum_{d=1}^{n}\mu(d)\sum_{i=1}^{n}\sum_{j=1}^{m} [d|i,d|j]\left \lfloor \frac{n}{i}\right \rfloor \left \lfloor \frac{m}{j}\right \rfloor $$

把后面两个和式改成枚举 $di,dj$ 的形式，则上标都除以 $d$，$di,dj$ 此时都是 $d$ 的倍数，后面含有 $i,j$ 的向下取整的都要变成 $di,dj$

$$= \sum_{d=1}^{n}\mu(d)\sum_{i=1}^{\left \lfloor \frac{n}{d}\right \rfloor}\sum^{\left \lfloor \frac{m}{d}\right \rfloor}_{j=1}\left \lfloor \frac{n}{di}\right \rfloor\left \lfloor \frac{m}{dj}\right \rfloor$$

把其中一个向下取整移出来

$$= \sum_{d=1}^{n}\mu(d)\sum_{i=1}^{\left \lfloor \frac{n}{d}\right \rfloor}\left \lfloor \frac{n}{di}\right \rfloor\sum^{\left \lfloor \frac{m}{d}\right \rfloor}_{j=1}\left \lfloor \frac{m}{dj}\right \rfloor$$

这下两边都是数论分块可以求出的了。

预处理出 $g(n)=\sum_{i=1}^{n} \left\lfloor \frac{n}{i}\right \rfloor$，则两个和式变成 $g(\left \lfloor \frac{n}{d}\right \rfloor),g(\left \lfloor \frac{m}{d}\right \rfloor)$，所以

$$ans=\sum_{d=1}^{n} \mu(d)g(\left \lfloor \frac{n}{d}\right \rfloor)g(\left \lfloor \frac{m}{d}\right \rfloor)$$

这个式子也用数论分块做即可，后面因为预处理了，可以 $O(1)$ 做。

总复杂度 $O(T\sqrt n)$

$Code$

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;
#define int long long 
inline int read(){
	register int x=0,f=0,ch=getchar();
	while('0'>ch||ch>'9')f^=ch=='-',ch=getchar();
	while('0'<=ch&&ch<='9')x=(x<<1)+(x<<3)+(ch^'0'),ch=getchar();
	return f?-x:x;
}
const int MAX=50005; 
int p[MAX],tot=0,f[MAX],mu[MAX];
inline void init(){
	mu[1]=1;
	for(register int i=2;i<=MAX;++i){
		if(!f[i])p[++tot]=i,mu[i]=-1;
		for(register int j=1;j<=tot&&i*p[j]<=MAX;++j){
			f[i*p[j]]=1;
			if(i%p[j]==0)break;
			mu[i*p[j]]=-mu[i];
		}
	}
	memset(f,0,sizeof(f));
	for(register int i=1;i<=MAX;++i){
		mu[i]+=mu[i-1];
		for(register int l=1,r;l<=i;l=r+1){
			r=i/(i/l);
			f[i]+=1LL*(r-l+1)*(i/l);
		}
	}
}
int ans,T;
inline int solve(int n,int m){
	ans=0;
	for(register int l=1,r;l<=n;l=r+1){
		r=min(n/(n/l),m/(m/l));
		ans+=1LL*(mu[r]-mu[l-1])*f[n/l]*f[m/l];
	}
	return ans;
}
int n,m;
signed main(){
	init();
	T=read();
	while(T--){
		n=read(),m=read();	
		if(n>m)n^=m^=n^=m;
		printf("%lld\n",solve(n,m));
	}
	return 0;
}


```






---

## 作者：WeLikeStudying (赞：11)

- 看错数据让我的程序第一次上最优解~~之一~~，必须发题解纪念~~铭记耻辱~~！

**题意**
- 求：
$$\sum_{i=1}^n\sum_{j=1}^m\sigma_0(i\cdot j)$$
- 其中 $\sigma_0(n)$ 表示 $n$ 的约数个数。

**思路**
- 内积必有拆解否则不好做。
$$\sigma_0(n\cdot m)=\sum_{i|n}\sum_{j|m}[i\bot j]$$
- 为什么？
- 考虑某个质数 $p$ 在 $n$ 中幂次为 $x$ ，在 $m$ 中幂次为 $y$ ，显然对 $\sigma_0(n\cdot m)$ 的贡献为 $x+y+1$ （注意结果是所用贡献相乘）。
- 如果 $i\bot j$ 则作为 $i$ 的约数被算入（不同幂次） $x$ 次，作为 $j$ 的约数被算入（不同幂次）$y$ 次，两边都没有计入有 1 次。
- 而这 $x+y+1$ 次的贡献相同（因为只是左边或右边乘个 $p$ 不影响 $i\bot j$ 的成立与否），相当于为原本不包含 $p$ 的结果乘 $x+y+1$ 。

**好用的式子**
$$\sum_{d|n}\mu(d)=[n=1]$$
- 证明：对于 $n=\prod_{i=1}^k{p_i^{e_i}}$ ，设 $m=\prod_{i=1}^k{p_i}$ ，则：
$$\sum_{d|n}\mu(d)=\sum_{d|m}\mu(d)=\mu(1)+\sum_{i=1}^k\mu(p_i)+\sum_{i=1}^k\sum_{j=i+1}^k\mu(p_ip_j)+\cdots+\mu(m)$$
$$=1-k+\frac{k(k-1)}2+\cdots+(-1)^k=\sum_{i=0}^k(-1)^iC(k,i)=(1-1)^k=[k=0]=[n=1]$$
- 经常用来代入 $[\gcd(i,j)=1]$ 。

**推导**
- [推式子放在云剪贴板](https://www.luogu.com.cn/paste/vx32c045)。
- 最终得到：
$$\sum_{i=1}^n\sum_{j=1}^m\sigma_0(i\cdot j)=\sum_{g=1}^{\min(n,m)}\mu(g)\cdot\bigg(\sum_{d=1}^{\lfloor\frac ng\rfloor}\bigg\lfloor\frac n{d\cdot g}\bigg\rfloor\bigg)\cdot\bigg(\sum_{k=1}^{\lfloor\frac mg\rfloor}\bigg\lfloor\frac m{k\cdot g}\bigg\rfloor\bigg)$$
- 设：
$$F(n)=\sum_{i=1}^n\bigg\lfloor\frac ni\bigg\rfloor$$
- 则原式可化简为：
$$\sum_{g=1}^{\min(n,m)}\mu(g)\cdot F\bigg(\bigg\lfloor\frac ng\bigg\rfloor\bigg)\cdot F\bigg(\bigg\lfloor\frac mg\bigg\rfloor\bigg)$$
- 于是我们就有了一种 $O(n\sqrt n)$ 预处理 $O(\sqrt n)$ 求解的做法，但这显然太慢了。
- 咱们先考虑一个有趣的小问题： $F(n)-F(n-1)$ 是多少？
- 咱们把每一项拆开考虑，会发现唯一有贡献的是 $i$ 恰好是 $n$ 的约数的那一项，满足 $\lfloor\frac ng\rfloor=\lfloor\frac {n-1}g\rfloor+1$ ，所以，实际上啊：
$$F(n)=\sum_{i=1}^n\sigma_0(i)$$
- 没想到吧，它藏得如此之深啊，$F$ 函数不讲武德！
- 所以我们就可以用线性筛筛出 $\sigma_0$ 。
- 时间复杂度降到了 $O(n+T\sqrt n)$ 。
- 虽然估计许多人已经用了这个优化吧。

**代码实现**
- [代码也放在云剪贴板](https://www.luogu.com.cn/paste/uqxhc5be)。

---

## 作者：Night_Aurora (赞：10)

写一个基于LS但是直白一点点的题解吧(没看懂楼下)

我们先倒叙提出一个结论

 ![](https://cdn.luogu.com.cn/upload/pic/5631.png) 

证明有些麻烦

 ![](https://cdn.luogu.com.cn/upload/pic/5630.png) 

先证明简化一点的

对于n=2时

d(ij)很明显=(a1+b1+1)\*(a2+b2+1)=a1a2+a1b2+b1a2+b1b2+a1+b1+a2+b2+1

那么对于最上面的式子,a,b组成的二元组

![](https://cdn.luogu.com.cn/upload/pic/5632.png)  恰好有a1\*a2组

同理  ![](https://cdn.luogu.com.cn/upload/pic/5633.png)  也有a1\*b1组

那么上面那些单项式都可以在最开始的公式里一一不漏的枚举到

最后的1也对应着(1,1)

以N≤M为前提，那么可得

 ![](https://cdn.luogu.com.cn/upload/pic/5634.png) 

设 ![](https://cdn.luogu.com.cn/upload/pic/5639.png)

 ![](https://cdn.luogu.com.cn/upload/pic/5640.png) 

那么可发现 ![](https://cdn.luogu.com.cn/upload/pic/5636.png)

所以下文对于FS函数若第三项省略则表示第三项为1

根据莫比乌斯反演

 ![](https://cdn.luogu.com.cn/upload/pic/5637.png) 

 ![](https://cdn.luogu.com.cn/upload/pic/5638.png) 

那么 ![](https://cdn.luogu.com.cn/upload/pic/5641.png)

那么答案就是F(N,M)了

最后只差O(1)处理S函数了

我们再设 ![](https://cdn.luogu.com.cn/upload/pic/5642.png)

我们发现S(n,m)=V(n)\*V(m)

那么我们只要开始用O(N)打一个μ的前缀和

再用O(N^1.5)试除法求出前50000个V函数的表

再对每组询问进行试除法

总复杂度是 ![](https://cdn.luogu.com.cn/upload/pic/5643.png)

很让人放心的复杂度(3e7)，但是事实上常数多的有点出乎意料

以下是代码










```cpp
#include <stdio.h>
#include <string.h>
#define MXN    50001
#define min(a,b) (a>b?b:a)
typedef long long _L;
int Ads[MXN];
char Mue[MXN];
int MSm[MXN];
bool Npr[MXN];
int Prm[MXN];
int Prt;
void LoadMue()
{
    Mue[1]=MSm[1]=1;
    int wi,wib;
    for(wi=2;wi<MXN;++wi)
    {
        if(!Npr[wi])
        {
            Mue[wi]=-1;
            Prm[++Prt]=wi;
        }
        for(wib=1;Prm[wib]*wi<MXN;++wib)
        {
            Npr[Prm[wib]*wi]=1;
            if(wi%Prm[wib]==0)
            {
                Mue[wi*Prm[wib]]=0;
                break;
            }
            Mue[wi*Prm[wib]]=-Mue[wi];
        }
        MSm[wi]=MSm[wi-1]+Mue[wi];
    }
}
void LoadAds()
{
    int wi,wia,last;
    for(wi=1;wi<MXN;++wi)
        for(wia=1;wia<=wi;wia=last+1)
        {
            last=wi/(wi/wia);
            Ads[wi]+=(wi/wia)*(last-wia+1);
        }
}
_L TryDiv(int N,int M)
{
    _L ret=0,buf;
    if(N>M)
        N^=M^=N^=M;
    int wi,last;
    for(wi=1;wi<=N;wi=last+1)
    {
        last=min(N/(N/wi),M/(M/wi));
        buf=Ads[N/wi];
        buf=buf*Ads[M/wi];
        ret+=buf*(MSm[last]-MSm[wi-1]);
    }
    return ret;
}
int T,N,M;
void IA()
{
    scanf("%d",&T);
    LoadMue();
    LoadAds();
    while(T--)
    {
        scanf("%d %d",&N,&M);
        printf("%lld\n",TryDiv(N,M));
    }
}
int main()
{
    IA();
    return 0;
}

```

---

## 作者：GoPoux4 (赞：7)

首先有个东西是这题解题的关键：
$$
{\rm{d}}(ij)=\sum_{x|i}\sum_{y|i}[{\rm{gcd}}(x,y)=1]
$$
[有位dalao的题解](https://siyuan.blog.luogu.org/solution-p3327)证明了这个式子，可以去看看。

---

然后就可以开始推式子了：
$$
\sum_{i=1}^n\sum_{j=1}^md(ij) =\sum_{i=1}^n\sum_{j=1}^m\sum_{x|i}\sum_{y|i}[{\rm{gcd}}(x,y)=1]=\sum_{x=1}^n\sum_{y=1}^m[{\rm{gcd}}(x,y)=1]\lfloor\frac{n}{x}\rfloor\lfloor\frac{m}{y}\rfloor
$$
接下来用莫比乌斯函数替换掉 $[{\rm{gcd}}(x,y)=1]$ ：
$$
\sum_{d|x,d|y}\mu(d)=[{\rm{gcd}}(x,y)=1]
$$
代入：
$$
\sum_{x=1}^n\sum_{y=1}^m[{\rm{gcd}}(x,y)=1]\lfloor\frac{n}{x}\rfloor\lfloor\frac{m}{y}\rfloor =\sum_{x=1}^n\sum_{y=1}^m \big(\sum_{d|x,d|y}\mu(d)\big)\lfloor\frac{n}{x}\rfloor\lfloor\frac{m}{y}\rfloor
$$
将这个式子由枚举 $x,y$ 的形式转变为枚举 $d$ ，即用 $xd,yd$ 代替 $x,y$ ：
$$
= \sum_{d=1}^{{\rm{min}}(n,m)}\mu(d)\sum_{x=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{y=1}^{\lfloor\frac{m}{d}\rfloor}\lfloor\frac{n}{xd}\rfloor\lfloor\frac{m}{yd}\rfloor
=  \sum_{d=1}^{{\rm{min}}(n,m)}\mu(d)\sum_{x=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{y=1}^{\lfloor\frac{m}{d}\rfloor}\lfloor\frac{\lfloor\frac{n}{d}\rfloor}{x}\rfloor\lfloor\frac{\lfloor\frac{m}{d}\rfloor}{y}\rfloor
$$
这里枚举的 $x,y$ 是上式中的 $\frac{x}{d},\frac{y}{d}$ 。

设 $f(n)=\sum_{i=1}^{n}\lfloor\frac{n}{i}\rfloor$ ，将其代入上式：
$$
\sum_{i=1}^n\sum_{j=1}^md(ij)=\sum_{d=1}^{{\rm{min}}(n,m)}\mu(d)f(\lfloor\frac{n}{d}\rfloor)f(\lfloor\frac{m}{d}\rfloor)
$$
到这里，很多题解就直接采用整除分块来计算 $f$ 了，复杂度 $O(n\sqrt{n})$ 。但是其实还有一种更快的做法能做到 $O(n)$ 预处理。

不难发现 $f(n)$ 其实是计算了 $1 \sim n$ 每个数小于等于 $n$ 的倍数个数之和，也就是说一个数对 $f(n)$ 做出的贡献就是它的约数个数。那么有：
$$
f(n)=\sum_{i=1}^{n}\lfloor\frac{n}{i}\rfloor=\sum_{i=1}^n{\rm{d}}(i)
$$
由于 ${\rm{d}}$ 是积性函数，可以使用线性筛做到 $O(n)$ 预处理。

关于线性筛 ${\rm{d}}$ ，可以看[这个](https://oi-wiki.org/math/sieve/#_5)。

---

${\rm{Code}}:$

```cpp
#include <iostream>
#include <cstring>
#include <cstdio>
#include <algorithm>
#include <cmath>
#define maxn 50005
#define Rint register int
#define INF 0x3f3f3f3f
using namespace std;
typedef long long lxl;

template <typename T>
inline T read()
{
	T x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9') {if(ch=='-') f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9') {x=(x<<1)+(x<<3)+ch-'0';ch=getchar();}
	return x*f;
}

int prime[maxn],cnt;
bool flag[maxn];
lxl d[maxn],f[maxn],mu[maxn],sum[maxn],num[maxn];

inline void sieve()
{
	d[1]=1;
	mu[1]=1;
	for(int i=2;i<maxn;++i)
	{
		if(!flag[i]) prime[++cnt]=i,d[i]=2,num[i]=1,mu[i]=-1;
		for(int j=1;j<=cnt&&i*prime[j]<maxn;++j)
		{
			flag[i*prime[j]]=true;
			if(i%prime[j])
			{
				num[i*prime[j]]=1;
				d[i*prime[j]]=d[i]*2;
			}
			else
			{
				num[i*prime[j]]=num[i]+1;
				d[i*prime[j]]=d[i]/num[i*prime[j]]*(num[i*prime[j]]+1);
				break;
			}
			mu[i*prime[j]]=-mu[i];
		}
	}
	for(int i=1;i<maxn;++i)
		f[i]=f[i-1]+d[i],sum[i]=sum[i-1]+mu[i];
}

inline lxl calcu(int n,int m)
{
	lxl res=0;
	if(n>m) swap(n,m);
	for(int l=1,r=0;l<=n;l=r+1)
	{
		r=min(n/(n/l),m/(m/l));
		res+=f[n/l]*f[m/l]*(sum[r]-sum[l-1]);
	}
	return res;
}

int main()
{
	// freopen("P3327.in","r",stdin);
	sieve();
	int T=read<int >();
	while(T--)
	{
		int n=read<int >(),m=read<int >();
		printf("%lld\n",calcu(n,m));
	}
	return 0;
}

```

---

## 作者：Jayun (赞：6)

# 链接：

[洛谷](https://www.luogu.com.cn/problem/P3327)

[更好的观看体验](https://www.cnblogs.com/GJY-JURUO/p/14009810.html)

# 正文：

本题最大的难点就是怎么处理 $d(ij)$。

假设在 $ij$ 的一个约数中有 $c$ 个 质因子 $p$ 相乘（即 $p^c$），我们总是先取 $i$ 中的 $p$，$i$ 中不够取再取 $j$ 中的。

如果 $i,j$ 互质，就是说质数 $p$ 不可能同时出现于 $i,j$，很明显，$d(ij)=\sum_{x\mid i}\sum_{y\mid j}[\gcd(x,y)==1]$（$xy$ 就是 $ij$ 因数之一）。

如果 $i,j$ 不互质呢？$d(ij)=\sum_{x\mid i}\sum_{y\mid j}[\gcd(x,y)==1]$ 好像就不成立了，像 $x=2,y=1$ 和 $x=1,y=2$ 好像重复了（这里 $i=4,j=8$）。对于这个问题，其实 $x=1,y=2$ 和 $x=2,y=1$ 是不等价的，因为我们总是先取 $i$，如果取了 $j$ 的话，$i$ 肯定已经取完了，所以 $x=1,y=2$ 它们代表的 $ij$ 因子其实是 $4\times 2=8$。

但是还有一个问题，如何保证 $x,y$ 互质时，它们所代表的数一定是 $ij$ 的因数呢？换言之，我们怎么才能证明 $ij$ 的因数一定能表示成互质的 $x,y$ 呢？这个问题很简单，通过上面的例子能得到，如果质因数 $p$ 已经在 $i$ 中取完了，$p$ 在 $x$ 中就只会表示为 $1$。所以不可能在 $x,y$ 中同时找到 $p$，所以 $x,y$ 必须互质。

$d(ij)=\sum_{x\mid i}\sum_{y\mid j}[\gcd(x,y)==1]$，关于这个性质的问题已经解决好了，接下来就是简单的推狮子????了：

$$\begin{aligned}\sum_{i=1}^{n}\sum_{j=1}^{m}d(ij)&=\sum_{i=1}^{n}\sum_{j=1}^{m}\sum_{x\mid i}\sum_{y\mid j}[\gcd(x,y)==1]\\
&=\sum_{i=1}^{n}\sum_{j=1}^{m}\sum_{x\mid i}\sum_{y\mid j}\sum_{k\mid\gcd(x,y)}\mu(k)\end{aligned}$$

将关于 $x,y$ 的所有和式提前：

$$\begin{aligned}\sum_{i=1}^{n}\sum_{j=1}^{m}\sum_{x\mid i}\sum_{y\mid j}\sum_{k\mid\gcd(x,y)}\mu(k)&=\sum_{x=1}^{n}\sum_{y=1}^{m}\sum_{k\mid\gcd(x,y)}\mu(k)\sum_{i=1}^{\lfloor\frac{n}{x}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{y}\rfloor}1\\
&=\sum_{x=1}^{n}\sum_{y=1}^{m}\sum_{k\mid\gcd(x,y)}\mu(k)\left\lfloor\frac{n}{x}\right\rfloor\left\lfloor\frac{m}{y}\right\rfloor\end{aligned}$$

再将 $\mu$ 提前：

$$\begin{aligned}\sum_{x=1}^{n}\sum_{y=1}^{m}\sum_{k\mid\gcd(x,y)}\mu(k)\left\lfloor\frac{n}{x}\right\rfloor\left\lfloor\frac{m}{y}\right\rfloor &= \sum_{k=1}^{n}\mu(k)\sum_{x=1}^{\lfloor\frac{n}{k}\rfloor}\sum_{y=1}^{\lfloor\frac{m}{k}\rfloor}\left\lfloor\frac{n}{xk}\right\rfloor\left\lfloor\frac{m}{yk}\right\rfloor\\
&=\sum_{k=1}^{n}\mu(k)\sum_{x=1}^{\lfloor\frac{n}{k}\rfloor}\left\lfloor\frac{n}{xk}\right\rfloor\sum_{y=1}^{\lfloor\frac{m}{k}\rfloor}\left\lfloor\frac{m}{yk}\right\rfloor\end{aligned}$$

到这一步，是的，先预处理整除分块 $\sum_{i=1}^{x}\left\lfloor\frac{x}{i}\right\rfloor$，再继续莫比乌斯的老套路。

# 代码：

```cpp
inline void prework()
{
	miu[1] = 1;
	for (int i = 2; i <= N - 10; i++)
	{
		if(!vis[i]) {pri[++cnt] = i, miu[i] = -1;}
		for (int j = 1; j <= cnt && pri[j] * i <= N - 10; j++)
		{
			vis[pri[j] * i] = 1;
			if (i % pri[j] == 0)
			{
				miu[i * pri[j]] = 0;
				break;
			}
			else
				miu[i * pri[j]] = -miu[i];
		}
	}
	for (int i = 1; i <= N - 10; i++)
		sum[i] = miu[i] + sum[i - 1];
	for (int n = 1; n <= N - 10; n++)
		for (register int l = 1, r; l <= n; l = r + 1)
		{
			r = n / (n / l);
			Ans[n] += (r - l + 1) * (n / l);
		}
}

int main()
{
	prework();
	for (read(t); t--; )
	{
		ll ans = 0LL;
		read(n);read(m);
		if(n > m)
		{
			ll c = n; n = m; m = c;
		}
		for (register int l = 1, r; l <= n; l = r + 1)
		{
			r = min (n / (n / l), m / (m / l));
			ans += (sum[r] - sum[l - 1]) * Ans[n / l] * Ans[m / l];
		}
		printf("%lld\n", ans);
	}
	return 0;
}
```

---

## 作者：juju527 (赞：3)

[juju的莫比乌斯反演学习笔记](https://juju527.github.io/post/mo-bi-wu-si-fan-yan/)

### 莫比乌斯反演

**小结论**

$d(x)$表示$x$的约数个数

$d(i*j)=\sum_{x|i}\sum_{y|j}[gcd(x,y)==1]$

简单证明:

对于一个质数$p$,$i$里有$p^a$,$j$里有$p^b$，我们要选出$p^k$,钦定做出如下选择

若$k<=a$,在$i$中选出$p^k$,若$k>a$,默认选满$i$的所有$p$，在$j$中选$p^{k-a}$

按照这样的选法能不重不漏的选出所有约数

---
**开始解题**

求$\sum_{i=1}^n\sum_{j=1}^m\sum_{x|i}\sum_{y|j}[gcd(x,y)==1]$

把x,y往前提$\sum_{x=1}^n\sum_{y=1}^m[\frac n x][\frac m y][gcd(x,y)==1]$

开始莫比乌斯反演套路

记$f(k)=\sum_{x=1}^n\sum_{y=1}^m[\frac n x][\frac m y][gcd(x,y)==k]$

$F(k)=\sum_{k|d}f(d)$

则$F(k)=\sum_{x=1}^n\sum_{y=1}^m[\frac n x][\frac m y][k|gcd(x,y)]$

将k提出来

$F(k)=\sum_{x=1}^{[\frac n k]}\sum_{y=1}^{[\frac m k]}[\frac n {kx}][\frac m {ky}][1|gcd(x,y)]$

即$F(k)=\sum_{x=1}^{[\frac n k]}\sum_{y=1}^{[\frac m k]}[\frac n {kx}][\frac m {ky}]$

由莫比乌斯反演

$f(x)=\sum_{x|d}\mu(\frac d x)F(x)$

故$f(1)=\sum_{d=1}\mu(d)F(d)=\sum_{d=1}\mu(d)\sum_{x=1}^{[\frac n d]}\sum_{y=1}^{[\frac m d]}[\frac n {dx}][\frac m {dy}]$

我们用数论分块预处理出$g(u,v)=\sum_{x=1}^u\sum_{y=1}^v[\frac u {x}][\frac v {y}]$

$f(1)=\sum_{d=1}\mu(d)g([\frac n d],[\frac m d])$

这个可以再一次数论分块

故复杂度$O(T\sqrt n)$

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=50005,maxm=50005;
int k=0;
int p[maxn],mu[maxn];
bool bj[maxn];
long long s[maxn];
int read(){
	int x=0,y=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')y=-1;ch=getchar();}
	while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+(ch^48),ch=getchar();
	return x*y;
}
void pre(){
	bj[1]=1;
	mu[1]=1;
	for(int i=2;i<=5e4;i++){
        if(bj[i]==0){p[++k]=i;mu[i]=-1;}
        for(int j=1;j<=k&&i*p[j]<=5e4;j++){
        	bj[i*p[j]]=1;
        	if(i%p[j]==0){
        		mu[i*p[j]]=0;
				break;
			}
			else
				mu[i*p[j]]=-mu[i];
       	}
	}
	for(int i=1;i<=5e4;i++)mu[i]+=mu[i-1];
	for(int x=1;x<=5e4;x++){
		long long res=0;
		for(long long l=1,r;l<=x;l=r+1){
			r=x/(x/l);
			res+=(r-l+1)*(x/l);
		}
		s[x]=res;
	}	
}
int main(){
	pre();
	int t;
	t=read();
	while(t--){
		int n,m;
		n=read();m=read();
		if(n>m)swap(n,m);
		long long ans=0;
		for(int l=1,r;l<=n;l=r+1){
			r=min(n/(n/l),m/(m/l));
			ans+=(mu[r]-mu[l-1])*s[n/l]*s[m/l];
		}
		printf("%lld\n",ans);
	}
	return 0;
}

```

---

## 作者：arfa (赞：3)

套进莫比乌斯函数随便弄一下就可以了 : 

$$\begin{aligned} & \sum\limits^{n}_{i=1}\sum\limits^{m}_{j=1}\sum\limits_{x|i}\sum\limits_{y|j} [\gcd(x,y)=1] \\ = & \sum\limits^{n}_{i=1}\sum\limits^{m}_{j=1}\sum\limits_{x|i}\sum\limits_{y|j}\sum\limits_{d| \gcd(x,y)} \mu(d) \\ = & \sum\limits^{\min\{n,m\}}_{d=1} \mu(d)\sum\limits^{n}_{i=1}\sum\limits^{m}_{j=1}\sum\limits_{x|i}\sum\limits_{y|j} [d|\gcd(x,y)] \\ = & \sum\limits^{\min\{n,m\}}_{d=1} \mu(d)\sum\limits^{n}_{i=1}\sum\limits^{m}_{j=1}[d|\gcd(i,j)] \sum\limits_{x|i}\sum\limits_{y|j}  1 \\ = & \sum\limits^{\min\{n,m\}}_{d=1} \mu(d)\sum\limits^{n}_{x=1}\sum\limits^{m}_{y=1} [d|x] [d|y] \left\lfloor \frac n x \right\rfloor \left\lfloor \frac m y \right\rfloor \\ = & \sum\limits^{\min\{n,m\}}_{d=1} \mu(d)\sum\limits^{\left\lfloor \frac n d \right\rfloor}_{x=1}\sum\limits^{\left\lfloor \frac m d \right\rfloor}_{y=1} [d|xd] [d|yd] \left\lfloor \frac n {xd} \right\rfloor \left\lfloor \frac m {yd} \right\rfloor \\ = & \sum\limits^{\min\{n,m\}}_{d=1} \mu(d) \left(\sum\limits^{ \left\lfloor \frac n d \right\rfloor }_{x=1} \left\lfloor \frac n {xd} \right\rfloor \right) \left(\sum\limits^{ \left\lfloor \frac m d \right\rfloor }_{y=1}   \left\lfloor \frac m {yd} \right\rfloor \right) \\ = & \sum\limits^{\min\{n,m\}}_{d=1} \mu(d) \left(\sum\limits^{ q }_{x=1} \left\lfloor \frac q x \right\rfloor \right) \left(\sum\limits^{p}_{y=1} \left\lfloor \frac p y \right\rfloor \right) [q=\left\lfloor \frac n d \right\rfloor][p=\left\lfloor \frac m d\right\rfloor ] \\\end{aligned}$$

所以说最后的公式我们可以对整除分块进行预处理 , 跑的时候再搞一次即可。预处理复杂度 $O(n \log \log n)$ , 查询复杂度 $O(Tn^{\frac{1}{2}})$。

手推 , 所以赘述了很多内容 , 代表个人的理解。如果全 $\text{WA}$ , 注意看一下自己的分块预处理的边界问题。

```pascal
Uses math;

Const
    total=50000+10;

var
    block,incea,mobius:array[-1..total] of int64;
    i,j,n,m,k,test:longint;
    ans:int64;

procedure Mobius_make;
var i,j:longint;
begin
    mobius[1]:=1;
    for i:=1 to total do for j:=2 to total div i+1 do begin if i*j>total then break; dec(mobius[i*j],mobius[i]); end;
    for i:=1 to total do incea[i]:=incea[i-1]+mobius[i];
end;

procedure Mathblock_make;
var i,j,k:longint;
begin
    for k:=1 to total do
    begin
        i:=1; j:=0;
        repeat j:=k div (k div i); inc(block[k],(j-i+1)*(k div i)); i:=j+1; until i>k;
    end;
end;

begin
    read(test); Mobius_make; Mathblock_make;
    for k:=1 to test do
    begin
        read(n,m); i:=1; j:=0; ans:=0;
        repeat
            j:=min(n div (n div i),m div (m div i));
            inc(ans,block[n div i]*block[m div i]*(incea[j]-incea[i-1])); i:=j+1;
        until i>min(n,m);
        writeln(ans);
    end;
end.
```





---

## 作者：kczno1 (赞：3)

如何计算d(n\*m)?

考虑一个质因数p

设n有a1个p,m有a2个p，那么p的选择方案数就是a1+a2+1。

相当于sigma:i=[0..a1],j=[0..a2] [gcd(p^i,p^j)=1]

质因数之间可以任意组合，

所以得到d(n\*m)=sigma:i|n,j|m [gcd(i,j)=1]
ans=sigma:i=1..n,j=1..m,d1|i,d2|j [gcd(d1,d2)=1]
把[gcd(d1,d2)=1]用sigma:d|d1,d|d2 miu(d)代掉
                         =d1|i,d2|j,d|d1,d|d2 miu(d)
考虑对每个d,d1的个数。

d1得是d的倍数，i的因数。

设d1=k\*d，那么有k\*d|i,k|i/d。
所以d1的个数就是i/d的因数个数，记作num。

ans=sigma:i=1..n,j=1..m,d|i,d|j miu(d)\*num(i/d)\*num(j/d)
考虑对每个d，i的贡献。

i得是d的倍数，每个i贡献为num(i/d)。

还是设i=k\*d。那么k\*d<=n,k<=n/d。

所以i的贡献就是num(1)+..num(n/d)，记作s(n/d)。


ans=sigma:d=1..min(n,m) miu(d)\*s(n/d)\*s(m/d)

线性筛预处理num,miu，处理前缀和，之后分块。

```cpp
#include<bits/stdc++.h>
using std::min;

typedef long long ll;
const int N=50000;
int miu[N+2],s[N+5];bool vis[N+5];
int big[N+2];//min_pirme(i)^big[i]|i
int p[N/9],top,i,j,x,y; 
void shai()
{
    miu[1]=s[1]=1;
    for(i=2;i<=N;++i)
    {
        if(!vis[i]) 
        { p[++top]=i;
          miu[i]=-1;
          s[i]=2;
          big[i]=i; 
        }
        for(j=1;(y=i*(x=p[j]))<=N;++j)
        {
            vis[y]=1;
            if(!(i%x)) 
            {
                big[y]=big[i]*x;
              if(i==big[i]) s[y]=s[i]+1;
              else s[y]=s[i/big[i]]*s[x*big[i]];
              break;
            }
            big[y]=x;
            s[y]=s[i]*s[x];
            miu[y]=miu[i]*miu[x];
        }
    }
    for(i=1;i<=N;++i) {s[i]+=s[i-1];miu[i]+=miu[i-1];}
}

int main()
{
    freopen("1.in","r",stdin);
    shai();
    int tt;scanf("%d",&tt);
    while(tt--)
    {
        int n,m;
        scanf("%d%d",&n,&m);
        i=1;
        int mi=min(n,m);
        ll ans=0;
        while(i<=mi)
        {
            int j=min(n/(n/i),m/(m/i));
            ans+=(ll)(miu[j]-miu[i-1])*s[n/i]*s[m/i];
            i=j+1;
        }
        printf("%lld\n",ans);
    }
} 
```

---

## 作者：Tenshi (赞：2)

莫比乌斯反演 + 整除分块

## 分析

首先，我们给出一个结论：
$$
d(ij) = \sum_{x|i} \sum_{y|j} [(x, y) = 1]
$$
证明：

设 $i$ 的分解式为 $i = \prod p_k^{\alpha_k}$ ，类似地，$j = \prod p_k^{\beta_k}$

对于质数 $p_k$ ，$ij$ 对应的因数个数为 $\alpha_k + \beta_k + 1$

而对于右式，$p_k$ 如果想要产生贡献，那么只可能是：$x, y$ 不同时存在因数 $p_k$，注意到对应的贡献数即为 $\alpha_k + \beta_k + 1$ 

因此，由乘法原理，所求证式成立。



> 为了防止混淆，我们将题面中的 $n, m$ 记为 $N, M$

由上述结论，题目的式子转化为：
$$
\sum_{i=1}^N \sum_{j=1}^M \sum_{x|i} \sum_{y|j} [(x, y) = 1]
$$


> 莫比乌斯反演：若 $F(n) = \sum_{n|d}f(d)$，则有 $f(n) = \sum_{n|d} \mu(\frac{d}{n})F(d)$

于是我们设 $f(n) = \sum_{i=1}^N \sum_{j=1}^M \sum_{x|i} \sum_{y|j} [(x, y) = n]$ ，对应的 $F(n) = \sum_{i=1}^N \sum_{j=1}^M \sum_{x|i} \sum_{y|j} [n | (x, y)]$

下面对 $F(n)$ 进行变换：

$F(n) = \sum_{i=1}^N \sum_{j=1}^M \sum_{x|i} \sum_{y|j} [n | (x, y)]$

$~~~~~~~~~ = \sum_{x=1}^N  \sum_{y=1}^M \lfloor \frac{N}{x} \rfloor \lfloor \frac{M}{y} \rfloor [n | (x, y)]$

设 $x' = \lfloor \frac{x}{n} \rfloor ~, y'=\lfloor \frac{y}{n} \rfloor ~ , N'=\lfloor \frac{N}{n} \rfloor ~ , M'=\lfloor \frac{M}{n} \rfloor$ ，进而有

$F(n) = \sum_{x=1}^{N'} \sum_{y=1}^{M'} \lfloor \frac{N'}{x'} \rfloor \lfloor \frac{M'}{y'} \rfloor$

$~~~~~~~= \sum_{x=1}^{N'} \lfloor \frac{N'}{x'} \rfloor \sum_{y=1}^{M'} \lfloor \frac{M'}{y'} \rfloor$



记 $h(x) = \sum_{i=1}^x \lfloor \frac{x}{i} \rfloor$ ，$h(x)$ 可用整除分块处理。

由莫比乌斯反演，$f(n) = \sum_{n|d} \mu(\frac{d}{n})F(d)$ ，我们只需求 $f(1)$

下面对 $f(1)$ 进行变换：
$$
f(1) = \sum_{d} \mu({d})F(d) = \sum_{d} \mu({d})h(\lfloor \frac{N}{d} \rfloor)h(\lfloor \frac{M}{d} \rfloor)
$$
由整除分块知，$h(\lfloor \frac{N}{d} \rfloor)h(\lfloor \frac{M}{d} \rfloor)$ 取值最多为 $\sqrt{N} + \sqrt{M}$ 块，而对于每一块，可以用前缀和 $O(1)$ 处理出对应的 $\mu$ 值，因此整体的复杂度为 $O(T(\sqrt{N} + \sqrt{M}))$



细节见代码：

```cpp
#include<bits/stdc++.h>
using namespace std;

const int S=50050;

int primes[S], cnt;
bool vis[S];
int mu[S], sum[S];
int h[S];

int g(int b, int l){
	return b/(b/l);
}

void init(){
	// init sum[]
	mu[1]=1;
	for(int i=2; i<S; i++){
		if(!vis[i]) primes[cnt++]=i, mu[i]=-1;
		for(int j=0; i*primes[j]<S; j++){
			vis[i*primes[j]]=true;
			if(i%primes[j]==0) break;
			mu[i*primes[j]]=-mu[i];
		}
	}
	for(int i=1; i<S; i++) sum[i]=sum[i-1]+mu[i];
	
	// init h[]
	for(int x=1; x<S; x++){
		int &v=h[x];
		for(int l=1, r; l<=x; l=r+1){
			r=min(x, g(x, l));
			v+=x/l*(r-l+1);
		}
	}
}

int solve(int N, int M){
	int res=0;
	
	int n=min(N, M);
	for(int l=1, r; l<=n; l=r+1){
		r=min(n, min(g(N, l), g(M, l)));
		res+=(sum[r]-sum[l-1])*h[N/l]*h[M/l];
	}
	return res;
}

int main(){
	int T; cin>>T;
	init();
	while(T--){
		int N, M; cin>>N>>M;
		cout<<solve(N, M)<<endl;
	}
	return 0;
}
```







---

## 作者：Mihari (赞：2)

# 题目

[传送门](https://www.luogu.com.cn/problem/P3327)

# 尝试与思考

求
$$
\sum_{i=1}^n\sum_{j=1}^md(ij)
$$

考虑设 $T=ij$，那么就有
$$
\text{ans}\;=\;\sum_{T=1}^{nm}d(T)\sum_{i=1}^{\frac{T}{m}\le i\le n}[i|T]
$$
然后，发现这个东西不可做了，这方法破产了...

考虑另外一种思路，由于我们有
$$
d(ij)=\sum_{x|i}\sum_{y|j}[\gcd(x,y)=1]
$$
那么这个式子就是
$$
\begin{aligned}
\text{ans}\;&=\;\sum_{i=1}^n\sum_{j=1}^m\sum_{x|i}\sum_{y|j}[\gcd(x,y)=1] \\
&=\;\sum_{x=1}^n\sum_{y=1}^m[\gcd(x,y)=1]\sum_{x|i}\sum_{y|j}1 \\
&=\;\sum_{x=1}^n\sum_{y=1}^m[\gcd(x,y)=1]\left\lfloor\frac{n}{x}\right\rfloor\left\lfloor\frac{m}{y}\right\rfloor \\
&=\;\sum_{i=1}^n\sum_{j=1}^m\left\lfloor\frac{n}{i}\right\rfloor\left\lfloor\frac{m}{j}\right\rfloor\sum_{x|i,x|j}\mu(x) \\
&=\;\sum_{x=1}^n\mu(x)\sum_{i=1}^{n/x}\sum_{j=1}^{m/x}\left\lfloor\frac{n}{ix}\right\rfloor\left\lfloor\frac{m}{jx}\right\rfloor
\end{aligned}
$$
我们令 $G(T)=\sum_{i=1}^{T}\left\lfloor\frac{T}{i}\right\rfloor$，首先这个函数可以分块算，同时有
$$
\begin{aligned}
\text{ans}\;=\;\sum_{x=1}^n\mu(x) G(\left\lfloor\frac{n}{x}\right\rfloor)G(\left\lfloor\frac{m}{x}\right\rfloor)
\end{aligned}
$$
考虑将 $G()$ 预处理出来，对于答案也分块算，那么总复杂度就是 $\mathcal O(n\sqrt n+T\sqrt n)$.

# 代码

```cpp
# include <cstdio>
# include <algorithm>
using namespace std;
namespace Elaina{
    # define rep(i,l,r) for(int i=l, i##_end_ = r; i <= i##_end_; ++ i)
    # define fep(i,l,r) for(int i=l, i##_end_ = r; i >= i##_end_; -- i)
    # define fi first
    # define se second
    # define Endl putchar('\n')
    # define writc(x, c) fwrit(x), putchar(c)
    // # define int long long
    typedef long long ll;
    typedef pair<int, int> pii;
    typedef unsigned long long ull;
    typedef unsigned int uint;
    template<class T>inline T Max(const T x, const T y){return x < y ? y : x;}
    template<class T>inline T Min(const T x, const T y){return x < y ? x : y;}
    template<class T>inline T fab(const T x){return x < 0 ? -x : x;}
    template<class T>inline void getMax(T& x, const T y){x = Max(x, y);}
    template<class T>inline void getMin(T& x, const T y){x = Min(x, y);}
    template<class T>T gcd(const T x, const T y){return y ? gcd(y, x % y) : x;}
    template<class T>inline T readin(T x){
        x=0; int f = 0; char c;
        while((c = getchar()) < '0' || '9' < c) if(c == '-') f = 1;
        for(x = (c ^ 48); '0' <= (c = getchar()) && c <= '9'; x = (x << 1) + (x << 3) + (c ^ 48));
        return f ? -x : x;
    }
    template<class T>void fwrit(const T x){
        if(x < 0)return putchar('-'), fwrit(-x);
        if(x > 9)fwrit(x / 10); putchar(x % 10 ^ 48);
    }
}
using namespace Elaina;

const int maxn = 50000;

int prime[maxn + 5], pcnt;
int sie[maxn + 5], mu[maxn + 5];
ll pre[maxn + 5];
inline void sieve(){
    mu[1] = pre[1] = 1;
    rep(i, 2, maxn){
        if(!sie[i]) prime[++ pcnt] = i, mu[i] = -1;
        for(int j = 1; j <= pcnt && i * prime[j] <= maxn; ++ j){
            sie[i * prime[j]] = 1;
            if(i % prime[j] == 0){
                mu[i * prime[j]] = 0; break;
            }
            mu[i * prime[j]] = -mu[i];
        }
        pre[i] = pre[i - 1] + mu[i];
    }
}

ll G[maxn + 5];

inline ll g(const int n){
    ll ret = 0;
    for(int l = 1, r; l <= n; l = r + 1){
        r = n / (n / l);
        ret += (r - l + 1) * (n / l);
    }
    return ret;
}

int n, m;

signed main(){
    sieve();
    rep(i, 1, maxn) G[i] = g(i);
    rep(cas, 1, readin(1)){
        n = readin(1), m = readin(1);
        if(n > m) swap(n, m);
        ll ans = 0;
        for(int l = 1, r; l <= n; l = r + 1){
            r = Min(n / (n / l), m / (m / l));
            ans += 1ll * (pre[r] - pre[l - 1]) * G[n / l] * G[m / l];
        }
        writc(ans, '\n');
    }
	return 0;
}
```

# 用到の一些trick

首当其冲的是这个结论
$$
d(ij)=\sum_{x|i}\sum_{y|j}[\gcd(x,y)=1]
$$
考虑怎么证明呢？我们设对于质数 $p$，$i$ 有 $a$ 个，$j$ 有 $b$ 个，那么显然的，$ij$ 就有 $a+b$ 个，同时，在因子的选择上，$ij$ 就有 $a+b+1$ 中选择方案，而如果我们要保证 $\gcd(x,y)=1$，那么对于 $x,y$ 来说，最多只有一边会有 $p$ 这个因子，那么对于只有 $x$ 有的情况来说，有 $a+1$ 种，对于只有 $y$ 有的情况，就是 $b+1$，同时还要减去重复算的两边都没有选择 $x$ 的一种，就是 $a+b+1+1-1=a+b+1$，所以这个可以等价.

-----

其次，是 $\gcd(x,y)=1\Leftrightarrow\sum_{i|x,i|y}\mu(i)=1$

其实就是
$$
\sum_{d|n}\mu(d)=
\begin{cases}
1,n=1 \\
0,n>1
\end{cases}
$$
如果 $n=1$，那么显然.

考虑对于其他情况，设 $n=p_1^{a_1}..p_k^{a_k}$，那么在 $n$ 的所有因子中，$\mu$ 值不为零的只有所有质因子次数都为 $1$ 的因子，其中质因数个数为 $r$ 个的因子有 ${k\choose r}$ 个，那么就有
$$
\begin{aligned}
\sum_{d|n}\mu(d)&={k\choose 0}-{k\choose 1}+{k\choose 2}+...+(-1)^k{k\choose k} \\
&=\sum_{i=0}^k(-1)^i{k\choose i} \\
&=(1-1)^k=0
\end{aligned}
$$
最后一步由二项式定理：
$$
(x+y)^z=\sum_{i=0}^n{z\choose i}x^iy^{z-i}
$$
给出.

---

## 作者：DQYdqy (赞：2)

cnblogs使用效果更佳：[Click here](https://www.cnblogs.com/NLDQY/p/11992891.html)

## Solution:

首先，我们转化式子

$$
\sum_{i=1}^n\sum_{j=1}^m d(ij)
$$

$$
\sum_{i=1}^n\sum_{j=1}^m \sum_{x|i} \sum_{y|j}[gcd(x,y)=1]
$$

我们把$x,y$给提前

$$
\sum_{x=1}^n\sum_{y=1}^m \lfloor \frac{n}{x} \rfloor \lfloor \frac{m}{y} \rfloor [gcd(x,y)=1]
$$

我们把$gcd(x,y)$提前，$x,y$不太好看，再给他换个名字$i,j$

$$
\sum_{i=1}^n \sum_{j=1}^m \lfloor \frac{n}{i} \rfloor \lfloor \frac{m}{j} \rfloor \sum_{d|i} \sum_{d|j} \mu(d)
$$
我们把$d$提前
$$
\sum_{d=1}^n \mu(d) \sum_{i=1}^{\lfloor \frac{n}{d} \rfloor} \sum_{j=1}^{\lfloor \frac{m}{d} \rfloor} \lfloor \frac{n}{di} \rfloor \lfloor \frac{m}{dj} \rfloor
$$
我们设一个函数$g(n)=\sum_{i=1}^n \lfloor \frac{n}{i} \rfloor$，则有
$$
\sum_{d=1}^n \mu(d) g(\lfloor \frac{n}{d} \rfloor) g(\lfloor \frac{m}{d} \rfloor)
$$
这个数论分块即可，考虑怎么筛$g(n)$，我们可以发现$g(n)=\sum_{i=1}^n d(i)$，则我们筛$d$后做前缀和即可

## Code:

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=5e4+11;
int n,m,u[N],p[N],vis[N];
int ans,cnt,g[N],num[N];
int read(){
	int x=0,f=1;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')f=-f;ch=getchar();}
	while(isdigit(ch)){x=x*10+ch-48;ch=getchar();}
	return x*f;
}
void prepare(){
    u[1]=1;g[1]=1;
    for(int i=2;i<N;i++){
        if(!vis[i]) p[++cnt]=i,u[i]=-1,g[i]=2,num[i]=1;
        for(int j=1;j<=cnt&&i*p[j]<N;j++){
            vis[i*p[j]]=1;
            if(i%p[j]==0){
                u[i*p[j]]=0;
                g[i*p[j]]=g[i]/(num[i]+1)*(num[i]+2);
                num[i*p[j]]=num[i]+1;
                break;
            }
            u[i*p[j]]=-u[i];
            g[i*p[j]]=g[i]*2;
            num[i*p[j]]=1;
        }
    }
    for(int i=1;i<N;i++)
        u[i]=u[i]+u[i-1],g[i]=g[i]+g[i-1]; 
}
void solve(){
    n=read(),m=read();
    ans=0;
    for(int i=1,j;i<=min(n,m);i=j+1){
        j=min(n/(n/i),m/(m/i));
        ans=ans+(u[j]-u[i-1])*g[n/i]*g[m/i];
    }
    printf("%lld\n",ans);
}
signed main(){
    prepare();
    int t=read();
    while(t--) solve();
    return 0;
}

```



---

## 作者：Durancer (赞：1)

### 题意

求：

$$\sum_{i=1}^n\sum_{j=1}^m d(ij),\text{其中d(n)为n的约数个数}$$

### 思路

因为是SDOI的省选题,那首先讲一下[部分分（50pts）][9]的做法：

可以考虑现行筛出每个数的约数个数，进行暴力求解，跑得还可，但是数组存不下qwq。

继续考虑如何化简式子求正解。

这里可以给出一个结论，对推式子很有帮助：

$$d(ij)=\sum_{x|i}\sum_{y|j}[\operatorname{gcd}(i,j)=1]$$

根据这个式子化简一下就是：

$$\sum_{i=1}^n\sum_{j=1}^m\sum_{x|i}\sum_{y|j}[\operatorname{gcd}(x,y)=1]$$

化到这个地方，不要着急把最后一项给化了，先留着，看看是否对化简有帮助。

在这个地方考虑一个经典的套路，转换枚举顺序首先分别枚举 $i,j$ 的因子 $x,y$。

$$\sum_{x=1}^n\sum_{y=1}^m\lfloor \frac{n}{x}\rfloor\lfloor \frac{m}{y}\rfloor[\operatorname{gcd}(x,y)=1]$$

在这个地方详细解释一下上式的由来，其实我们就是把 $x,y$ 的枚举顺序提前，然后直接计算出 $x,y$ 分别能起作用的个数，也就是两个 $\sum$ 后面的式子，就是可以算出使当前 $x,y$ 可以发挥作用的 $i,j$ 有多少个。顺序变换，但是最后结果依旧是不重不漏的，感性理解一下即可，接下来继续化式子，上面的式子看着太不舒服了qwq。

$$\sum_{i=1}^n\sum_{j=1}^m\lfloor \frac{n}{i}\rfloor\lfloor \frac{m}{j}\rfloor [\operatorname{gcd}(i,j)=1]$$

化到这一步表示基础已经讲完了，接下来就到了真正的反演环节了，首先上一个性质。

对于两个数论函数 $f(n),g(n)$ 来说，有以下的公式：

如果有 $f(n)=\sum_{d|n}g(d)$,则有 $g(n)=\sum_{d|n}\mu(d)f(\frac{n}{d})$。

如果有 $f(n)=\sum_{n|d}g(d)$,则有 $g(n)=\sum_{n|d}\mu(\frac{d}{n})f(d)$。

有了这两个性质就可以进行反演了(>w<)。

设 $g(x)=\sum_{i=1}^n\sum_{j=1}^m\lfloor \frac{n}{i}\rfloor\lfloor\frac{m}{j}\rfloor[\operatorname{gcd}(i,j)=x]$。

设 $f(x)=\sum_{x|d}g(d)$。

可以得到：

$$f(x)=\sum_{i=1}^n\sum_{j=1}^m\lfloor \frac{n}{i}\rfloor\lfloor \frac{m}{j}\rfloor[x|\operatorname{gcd}(i,j)] $$

根据设的函数中 $x|d$ 的条件可以转化为以下形态，也就是只有当 $[x|\operatorname{gcd}(i,j)]=1$ 时，式子才有贡献。

将 $x$ 除掉，就变成了

$$f(x)=\sum_{i=1}^{n/x}\sum_{j=1}^{m/x}\lfloor \frac{n}{ix}\rfloor\lfloor \frac{m}{jx}\rfloor[1|\operatorname{gcd}(i,j)] $$

很明显的，可以把后面那一坨去掉得到：

$$f(x)=\sum_{i=1}^{n/x}\sum_{j=1}^{m/x}\lfloor \frac{n}{ix}\rfloor\lfloor \frac{m}{jx}\rfloor $$

$$f(x)=\sum_{i=1}^{n/x}\lfloor \frac{n}{ix}\rfloor\sum_{j=1}^{m/x}\lfloor\frac{m}{jx}\rfloor$$

现在利用反演的性质，将柿子反演一波(根据我们的定义，在题目中我们最后需要求的是 $g(1)$）。

$$g(1)=\sum_{1|d}\mu(\frac{d}{1})f(d)$$

最后的出来的式子即为：

$$g(1)=\sum_{d=1}^n\mu(d)f(d)$$

看一眼 $f(x)$ 的式子，可以整除分块来预处理$\sum_{i=1}^n\frac{n}{i}$，然后筛出 $\mu$ 函数，前缀和预处理，整除分块求解，时间复杂度可以通过此题。

### 代码实现

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
#define int long long 
using namespace std;
const int N=5e4+9;
const int M=5e4;
int sum[N];
int prime[N];
int mu[N];
bool vis[N];
int T,cnt;
int read()
{
	int f=1,x=0;
	char s=getchar();
	while(s<'0'||s>'9'){if(s=='-')f=-1;s=getchar();}
	while(s>='0'&&s<='9'){x=(x<<1)+(x<<3)+(s^'0');s=getchar();}
	return f*x;
}
void get_mu()
{
	mu[1]=1;
	for(int i=2;i<=M;i++)
	{
		if(!vis[i])
		{
			prime[++cnt]=i;
			mu[i]=-1;	
		}
		for(int j=1;j<=cnt&&prime[j]<=M/i;j++)
		{
			vis[i*prime[j]]=true;
			if(i%prime[j]==0) 
				break;
			mu[i*prime[j]]=-mu[i];
		}
	} 
	for(int i=1;i<=M;i++)
		mu[i]+=mu[i-1];
	for(int i=1;i<=M;i++)
	{
		int num=0;
		for(int l=1,r=1;l<=i;l=r+1)
		{
			r=(i/(i/l));
			num+=(r-l+1)*(i/l);
		}
		sum[i]=num;
	}
}
int calc(int n,int m)
{
	if(n>m) swap(n,m);
	int ret=0;
	for(int l=1,r=1;l<=n;l=r+1)
	{
		r=min((n/(n/l)),(m/(m/l)));
		ret+=(mu[r]-mu[l-1])*sum[n/l]*sum[m/l]; 
	}
	return ret;	
} 
signed main()
{
	T=read();
	get_mu();
	while(T--)
	{
		int n=read();
		int m=read();
		int ans=0;
		ans=calc(n,m);
		printf("%lld\n",ans); 
	}
	return 0;
}
```
[9]: https://www.luogu.com.cn/paste/zxss6903

---

## 作者：Aliemo (赞：1)

### 题目大意

求约数个数和

### solution

我们知道有这么一个公式: $d(nm) = \sum\limits_{i | n}\sum\limits_{j | m}[gcd(i, j) == 1]$

证明: 对于 $nm$ 的每个质因数 $p$, 设 $n = n_1 * p^a, m = m_1 * p^b$, 那么 $nm = n_1 * m_1 * p^{a + b}$, p 对 d(nm) 的贡献是 $a+b+1$.在等式的右边里,$(i_1 * p^a, j_1), (i _ 1 * p^{a - 1}, j_1), ..., (i_1, j_1), ..., (i_1, j_1 * p^b)$ 都是可行的数对, 共 $a + b + 1$ 个, 证毕.

那么:

$\sum\limits_{i = 1}^N\sum\limits_{j = 1}^M d(i, j)$

标准的展开:

$=\sum\limits_{i = 1}^N\sum\limits_{j = 1}^{M}\sum\limits_{k | i}\sum\limits_{l | j}[gcd(k, l) == 1] $

$=\sum\limits_{i = 1}^N\sum\limits_{j = 1}^M\sum\limits_{d = 1}^{min(N, M)}\mu(d)\sum\limits_{k|i}\sum\limits_{l|j}[gcd(k, l)|d] $

交换枚举顺序:

$=\sum\limits_{d = 1}^{min(N, M)}\mu(d)\sum\limits_{k|i}\sum\limits_{l|j}[gcd(k, l)|d] \left\lfloor\frac{N}{k}\right\rfloor\left\lfloor\frac{M}{l}\right\rfloor$

$=\sum\limits_{d = 1}^{min(N, M)}\mu(d)\sum\limits_{k}^{\left\lfloor\frac{N}{k}\right\rfloor}\sum\limits_{l}^{\left\lfloor\frac{M}{l}\right\rfloor}\left\lfloor\frac{N}{dk}\right\rfloor\left\lfloor\frac{M}{dl}\right\rfloor $

交换枚举顺序:

$=\sum\limits_{d = 1}^{min(N, M)}\mu(d)\sum\limits_{k}^{\left\lfloor\frac{N}{k}\right\rfloor}\left\lfloor\frac{N}{dk}\right\rfloor\sum\limits_{l}^{\left\lfloor\frac{M}{l}\right\rfloor}\left\lfloor\frac{M}{dl}\right\rfloor $

记 $f(i) = \sum\limits_{j = 1}^i \left\lfloor\frac{i}{j}\right\rfloor$, 则我们要求 $=\sum\limits_{i = 1}^{min(N, M)}\mu(i) * f(\left\lfloor\frac{N}{i}\right\rfloor) * f(\left\lfloor\frac{M}{i}\right\rfloor) $

然后用一下数论分块我们这道题就做完了

### Code:

```cpp
/**
*    Author: Alieme
*    Data: 
*    Problem: 
*    Time: O()
*/
#include <cstdio>
#include <iostream>
#include <string>
#include <cstring>
#include <cmath>
#include <algorithm>

#define int long long
#define rr register

#define inf 1e9
#define MAXN 100010

using namespace std;

inline int read() {
	int s = 0, f = 0;
	char ch = getchar();
	while (!isdigit(ch)) f |= ch == '-', ch = getchar();
	while (isdigit(ch)) s = s * 10 + (ch ^ 48), ch = getchar();
	return f ? -s : s;
}

void print(int x) {
	if (x < 0) putchar('-'), x = -x;
	if (x > 9) print(x / 10);
	putchar(x % 10 + 48);
}

int T, n, m, ans, tot;

int mu[MAXN], d[MAXN], c[MAXN], prime[MAXN];

bool vis[MAXN];

inline void init() {
	mu[1] = d[1] = c[1] = 1;
	for (rr int i = 2; i <= 50000; i++) {
		if (!vis[i]) prime[++tot] = i, mu[i] = -1, c[i] = 1, d[i] = 2;
		for (int j = 1; j <= tot; j++) {
			if (i * prime[j] > 50000) break;
			vis[i * prime[j]] =  1;
			mu[i * prime[j]] = -mu[i];
			d[i * prime[j]] = d[i] * d[prime[j]];
			c[i * prime[j]] = 1;
			if (i % prime[j] == 0) {
				mu[i * prime[j]] = 0;
				d[i * prime[j]] = d[i] / (c[i] + 1) * (c[i] + 2);
				c[i * prime[j]] = c[i] + 1;
				break;
			}
		}
	}
	for (rr int i = 1; i <= 50000; i++) mu[i] += mu[i - 1];
	for (rr int i = 1; i <= 50000; i++) d[i] += d[i - 1];		
}

signed main() {
	init();
	T = read();
	while (T--) {
		n = read();
		m = read();
		ans = 0;
		for (rr int l = 1, r; l <= min(n, m); l = r + 1) {
			r = min(n / (n / l), m / (m / l));
			ans += (mu[r] - mu[l - 1]) * d[n / l] * d[m / l];
		}
		print(ans);
		puts("");
	}
}
```

---

## 作者：Spasmodic (赞：1)

论文例题，写一个题解水一下。

首先我们需要一个引理：
$$d(ij)=\sum_{x|i}\sum_{y|j}[\gcd(x,y)=1]$$
证明应该很显然。

于是
$$\sum_{i=1}^{n}\sum_{j=1}^{n}d(ij)$$
$$=\sum_{i=1}^{n}\sum_{j=1}^{n}\sum_{x|i}\sum_{y|j}[\gcd(x,y)=1]$$
$x,y$扔出来
$$=\sum_{x=1}^{n}\sum_{y=1}^{m}[\frac{n}{x}][\frac{m}{y}][\gcd(x,y)=1]$$
套路反演，参见[这篇](https://www.luogu.com.cn/blog/happydef-blog/solution-p2522)，此略
$$=\sum_{d=1}^{n}\mu(d)\sum_{i=1}^{[\frac{n}{d}]}[\frac{n}{id}]\sum_{j=1}^{[\frac{m}{d}]}[\frac{m}{jd}](*)$$
然后再$O(n\log n)$预计算一下
$$S(n)=\sum_{d=1}^n[\frac{n}{d}]$$
就可以得到
$$(*)=\sum_{d=1}^{n}\mu(d)S([\frac{n}{d}])S([\frac{m}{d}])$$
整数分块，复杂度$O(n+(n+T)\sqrt n)$
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=50005;
int T,n,m,pr[N],tot,smu[N];
ll s[N],ans;
bool vst[N];
int main(){
	smu[1]=1;
	for(int i=2;i<=50000;i++){
		if(!vst[i])smu[i]=-1,pr[++tot]=i;
		for(int j=1;i*pr[j]<=50000;j++){
			vst[i*pr[j]]=1;
			if(i%pr[j])smu[i*pr[j]]=-smu[i];
			else break;
		}
	}
	for(int i=1;i<=50000;i++)smu[i]+=smu[i-1];
	for(int i=1;i<=50000;i++)
		for(int l=1,r;l<=i;l=r+1)
			r=i/(i/l),s[i]+=(ll)(r-l+1)*(i/l);
	for(scanf("%d",&T);T--;){
		scanf("%d%d",&n,&m);
		ans=0;
		for(int i=1,j;i<=min(n,m);i=j+1){
			j=min(n/(n/i),m/(m/i));
			ans+=(ll)s[n/i]*s[m/i]*(smu[j]-smu[i-1]);
		}
		printf("%lld\n",ans);
	}
	return 0;
}

```

---

## 作者：chihik (赞：1)

首先有一个公式：

$$d(ij)=\sum_{x|i}\sum_{y|j}[(i,j)=1]$$

感性理解一下，可以看看这位大佬的[博客](https://23613.blog.luogu.org/solution-p3327)。

那么:

$$\sum_{i=1}^n\sum_{j=1}^md(ij)$$

$$\sum_{i=1}^n\sum_{j=1}^m\sum_{x|i}\sum_{y|j}[(x,y)=1]$$

改为枚举约数，得：

$$\sum_{x=1}^n\sum_{y=1}^m \lfloor \frac{n}{x}  \rfloor \lfloor \frac{m}{y} \rfloor [(x,y)=1]$$

$$\sum_{x=1}^n\sum_{y=1}^m \lfloor \frac{n}{x}  \rfloor \lfloor \frac{m}{y} \rfloor \sum_{d|(x,y)} \mu(d)$$

$$\sum_{d=1}^{\min(n,m)} \mu(d) \sum_{x=1}^{\lfloor \frac{n}{d}  \rfloor}\sum_{y=1}^{\lfloor \frac{m}{d}  \rfloor} \lfloor \frac{n}{dx}  \rfloor \lfloor \frac{m}{dy} \rfloor$$

$$\sum_{d=1}^{\min(n,m)} \mu(d) \sum_{x=1}^{\lfloor \frac{n}{d}  \rfloor} \lfloor \frac{n}{dx}  \rfloor \sum_{y=1}^{\lfloor \frac{m}{d}  \rfloor } \lfloor \frac{m}{dy} \rfloor$$

令 $f(x)=\sum_{i=1}^x \lfloor \frac{x}{i} \rfloor$ ，则原式为

$$\sum_{d=1}^{\min(n,m)} \mu(d) f( \lfloor \frac{n}{d} \rfloor ) f( \lfloor \frac{m}{d} \rfloor )$$

再看看 $f(x)$ ，其实就是约数个数的前缀和，原因很简单：

$f(x)$ 表示不大于 $x$ 的数的倍数不大于 $x$ 的数的个数。

$d(x)$ 表示不大于 $x$ 的数的倍数为 $x$ 的数的个数。

可以欧拉筛[约数个数](https://www.luogu.com.cn/blog/chihik/ou-la-shai-fa-shai-ji-xing-han-shuo)再前缀和得到，那么此题就解决了。

时间复杂度 $\Theta(n+t\sqrt n)$。

```cpp
#include <cstdio>
#include <iostream>
using namespace std;

const int MAXN = 50000;
int t , n , m , k , prime[ MAXN + 5 ];
int mu[ MAXN + 5 ] , d[ MAXN + 5 ] , f[ MAXN + 5 ] , pre_mu[ MAXN + 5 ];
bool vis[ MAXN + 5 ];

void sieve( ) {
	mu[ 1 ] = 1 , d[ 1 ] = 1;
	for( int i = 2 ; i <= MAXN ; i ++ ) {
		if( !vis[ i ] ) {
			prime[ ++ k ] = i;
			mu[ i ] = -1;
			d[ i ] = 2;
		}
		for( int j = 1 ; j <= k && 1ll * i * prime[ j ] <= MAXN ; j ++ ) {
			vis[ i * prime[ j ] ] = 1;
			if( i % prime[ j ] == 0 ) {
				d[ i * prime[ j ] ] = 2 * d[ i ] - d[ i / prime[ j ] ];
				break;
			}
			mu[ i * prime[ j ] ] = -mu[ i ];
			d[ i * prime[ j ] ] = d[ i ] * d[ prime[ j ] ];
		}
	}
	for( int i = 1 ; i <= MAXN ; i ++ ) {
		f[ i ] = f[ i - 1 ] + d[ i ];
		pre_mu[ i ] = pre_mu[ i - 1 ] + mu[ i ];
	}
}

long long solve( int n , int m ) {
	int d = min( n , m );
	long long Ans = 0;
	for( int l = 1 , r ; l <= d ; l = r + 1 ) {
		r = min( n / ( n / l ) , m / ( m / l ) );
		Ans += 1ll * ( pre_mu[ r ] - pre_mu[ l - 1 ] ) * f[ n / l ] * f[ m / l ];
	}
	return Ans;
}
int main( ) {
	sieve( );
	scanf("%d",&t);
	while( t -- ) {
		scanf("%d %d",&n,&m);
		printf("%lld\n", solve( n , m ) );
	}
	return 0;
}
```


---

## 作者：Smallbasic (赞：1)

首先要把它转化成容易推导的式子。

先给出结论:

$$\sigma_0(ij)=\sum_{k|i}\sum_{l|j}[gcd(k, l)=1]$$

证明：

设一个数$k|ij$,$p\in Prime$，且$p^a|i,p^b|j,p^c|k$，可以分类讨论一下：

若$c\le a$,则在$i$中选择因子$k$,否则在$j$中选择因子$p^{c-a}$

所以每一个选择都对应着唯一的因子$k$,对$k$的其他的所有因子同理。

所以每个因子的因子不可能同时在$i$和$j$中选择，所以一定有$k\perp l$，等同于$gcd(k,l)=1$

之后就是反演乱推了:

$$\sum_{i=1}^n\sum_{j=1}^m\sigma_0(ij)$$
$$=\sum_{i=1}^n\sum_{j=1}^m\sum_{k|i}\sum_{l|j}[gcd(k, l)=1]$$
$$=\sum_{i=1}^n\sum_{j=1}^m\sum_{d=1}^{\min(n,m)}\mu(d)\sum_{k|i}\sum_{l|j}[gcd(k, l)|d]$$
$$=\sum_{d=1}^{\min(n,m)}\mu(d)\sum_{k=1}^n\sum_{l=1}^m[gcd(k,l)|d]\lfloor{n\over k}\rfloor\lfloor{m\over l}\rfloor$$
$$=\sum_{d=1}^{\min(n,m)}\mu(d)\sum_{k=1}^{\lfloor{n\over d}\rfloor}\sum_{l=1}^{\lfloor{m\over d}\rfloor}\lfloor{n\over dk}\rfloor\cdot\lfloor{m\over dl}\rfloor$$
$$=\sum_{d=1}^{\min(n,m)}\mu(d)(\sum_{k=1}^{\lfloor{n\over d}\rfloor}\lfloor{n\over dk}\rfloor)(\sum_{l=1}^{\lfloor{m\over d}\rfloor}\lfloor{m\over dl}\rfloor)$$

设$f(i)=\sum_{j=1}^n \lfloor{i\over j}\rfloor$，原式等于：

$$\sum_{i=1}^{\min(n,m)}\mu(i)f(\lfloor{n\over i}\rfloor)f(\lfloor{m\over i}\rfloor)$$

然后就好办了：

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>

using namespace std;

typedef long long ll;

bool notprime[50001];
int t, n, m, prime[50001], top = 0;
ll mu[50001], f[50001];

inline int read() {
    register int s = 0;
    register char ch = getchar();
    while (!isdigit(ch)) ch = getchar();
    while (isdigit(ch)) s = (s << 1) + (s << 3) + (ch & 15), ch = getchar();
    return s;
}

inline void pre() {
    mu[1] = 1;
    for (register int i = 2; i <= 50000; ++i) {  
        if (!notprime[i]) prime[++top] = i, mu[i] = -1;
        for (register int j = 1; j <= top; ++j) {  
            if (i * prime[j] > 50000) break;  
            notprime[i * prime[j]] = 1;
            if (!(i % prime[j])) {  
                mu[i * prime[j]] = 0;
                break;  
            } else mu[i * prime[j]] = -1 * mu[i];
        } 
    } mu[0] = 0;
    for (int i = 1; i <= 50000; ++i) {
    	for (int l = 1, r; l <= i; l = r + 1) {
        	r = i / (i / l);
        	f[i] += 1LL * 1LL * (r - l + 1) * 1LL * (i / l);
		} mu[i] += mu[i - 1];
	}
}

inline int min_(int a, int b) {
	return a < b ? a : b;
}

int main() {
    t = read(); pre();
    while (t--) {
        n = read(); m = read(); ll ans = 0;
        for (int l = 1, r; l <= min_(n, m); l = r + 1) {
			r = min_(n / (n / l), m / (m /l));
        	ans += 1LL * (mu[r] - mu[l - 1]) * 1LL * f[n / l] * 1LL * f[m / l];
		} printf("%lld\n", ans);
    }
    return 0;
}
```


---

## 作者：zhylj (赞：1)

为了更好的阅读体验，你可以前往[我的博客](http://zhylj.cc/2019/07/27/201907273/)

## 前言

结论好难证啊，推了一个多小时(我还是太菜了)，不过貌似我也没有在网上找到什么形式化的证明？~~你有找吗？~~

**本文提供该公式的另一种构造性的证明方式。**

（还没学集合映射的初中生证这玩意要死了qwq，前面证明双射的方法错了，后面对了只搞了半小时就出来了）

## 题目

求
$$\sum_{i=1}^n \sum_{j=1}^m d(ij)$$
$1\le n,m\le 5 \times 10^4$，数据组数 $\le 5\times 10^4$.

## 分析

### 一个结论

注意到：
$$d(xy) = \sum_{i|x}\sum_{j|y} [i\perp j]$$
（注意我用的字母和题目的意义不一样）

**证明**：考虑证明如下映射关系可以使得满足条件的二元组 $(i, j)$，与 $xy$ 的约数有一一对应关系。
$$\quad f(i,j) = \frac{j\cdot x}i$$
理由如下：

1. $(i,j)$ 对约数：令 $a = \frac{j\cdot x}i$，$b = \frac {i \cdot y}j$，则有 $ab = xy$。即 $ab$ 为 $xy$ 的约数。

   对于任意 $i \neq i', j \neq j'$，$i \perp j, i' \perp j'$，由于互质的条件，则显然 $\frac ij \neq \frac {i'}{j'}$ （若相等则显然必然有一组可以约分，与互质相悖）则 $a=\frac {j \cdot x}i \neq \frac {j' \cdot x}{i'} = a'$。

   这样证明了二元组 $(i, j)$ 对 $xy$ 约数的单射。

2. 约数对 $(i,j)$：若有 $ab = xy$，即约数 $a$，设 $\gcd(a,x) = g$，则令 $i = \frac xg,j = \frac ag$，显然 $i \perp j$，且 $\frac{j\cdot x}i = a$. 这样证明了满射。

综上，有映射 $f(i,j) = \frac{j\cdot x}i$，使得满足条件的二元组 $(i, j)$ 和 $xy$ 的约数一一对应。

### 解题

暴力带入结论：

$$\sum_{i=1}^n \sum_{j=1}^m d(ij) = \sum_{i=1}^n \sum_{j=1}^m \sum_{p|i} \sum_{q|j} [p\perp q]$$
$$= \sum_{p = 1}^n\sum_{q=1}^m \sum_{p|i, i\le n} \sum_{q|i, i\le m} [p\perp q]$$
$$= \sum_{p = 1}^n\sum_{q=1}^m \left\lfloor\frac np \right\rfloor\left\lfloor\frac mq \right\rfloor [p\perp q]$$

令：

$$f(x) = \sum_{p = 1}^n\sum_{q=1}^m \left\lfloor\frac np \right\rfloor\left\lfloor\frac mq \right\rfloor [\gcd(p, q) = x]$$

$$g(x) = \sum_{x|d} f(d)  = \sum_{p = 1}^n\sum_{q=1}^m \left\lfloor\frac np \right\rfloor\left\lfloor\frac mq \right\rfloor [x|\gcd(p, q)]$$

$$ = \sum_{p = 1}^n\sum_{q=1}^m \left\lfloor\frac np \right\rfloor\left\lfloor\frac mq \right\rfloor [x|p][x|q]$$

$$ = \sum_{i = 1}^{\left\lfloor\frac nx\right\rfloor}\sum_{j = 1}^{\left\lfloor\frac mx\right\rfloor} \left\lfloor\frac n{ix} \right\rfloor\left\lfloor\frac m{jx} \right\rfloor$$

$$ = \left(\sum_{i = 1}^{\left\lfloor\frac nx\right\rfloor}\left\lfloor\frac n{ix} \right\rfloor\right)\left(\sum_{j = 1}^{\left\lfloor\frac mx\right\rfloor} \left\lfloor\frac m{jx} \right\rfloor\right)$$

$$ = \left(\sum_{i = 1}^{\left\lfloor\frac nx\right\rfloor}\left\lfloor\frac {\left\lfloor\frac nx \right\rfloor} i\right\rfloor\right)\left(\sum_{j = 1}^{\left\lfloor\frac mx\right\rfloor} \left\lfloor\frac{\left\lfloor\frac mx \right\rfloor}j\right\rfloor\right) $$

设 $s(x) = \sum_{i=1}^x \left\lfloor \frac xi \right\rfloor$，则有：$g(x) = s(\left\lfloor\frac nx\right\rfloor)s(\left\lfloor\frac mx\right\rfloor)$。

预处理 $s$，$g$ 就可以 $\Theta(1)$ 求了。

根据莫比乌斯反演定理，得：
$$f(1) = \sum_{1|d} \mu(d)g\left(\frac d1\right) = \sum_{d} \mu(d)g(d)$$
再考虑 $s(\left\lfloor\frac nx\right\rfloor)s(\left\lfloor\frac mx\right\rfloor)$ 的取值只有 $\Theta(\sqrt n + \sqrt m)$ 个，搞搞 $\mu$ 前缀和，大胆数论分块。

## 代码

[~/Luogu/P3327/std.cpp](https://github.com/zhylj/OICodeRepository/blob/master/Luogu/P3327/std.cpp)

---

## 作者：XY_cpp (赞：1)

定理:

$$d(ij)=\sum_{k|i}\sum_{l|j}[gcd(k,l)==1]$$

原式可变形为:

$$\sum_{i=1}^n\sum_{j=1}^m\sum_{k|i}\sum_{l|j}[gcd(k,l)==1]$$

设$x=gcd(k,l)$

则$[gcd(k,l)==1]$ 可以表示为 $f(x)=[x=1]$

若我们找到一个函数$g$，使得$f(x)=\sum_{d|x}g(d)$

则有$f(x)=f(gcd(k,l))=\sum_{d|k,d|l}g(d)$

根据莫比乌斯反演~~大眼观察~~可求得$g=\mu$

所以原式化成：

$$\sum_{i=1}^n\sum_{j=1}^m\sum_{k|i}\sum_{l|j}\sum_{d|k,d|l} \mu(d)$$

交换求和顺序整理可得

$$\sum_{d=1}^{min(n,m)}\mu(d)(\sum_{k=1}^{\lfloor{\frac{n}{d}}\rfloor}\lfloor{\frac{n}{dk}}\rfloor)(\sum_{l=1}^{\lfloor{\frac{m}{d}}\rfloor}\lfloor{\frac{m}{dl}}\rfloor )$$

``本篇题解的重点来了`` ~~貌似和其它题解都不一样~~

这个式子强行求肯定会TLE

不如考虑设

$$f(i)=\sum_{j=1}^i\lfloor{\frac{i}{j}}\rfloor$$

于是乎，便得之，原式为

$$\sum_{d=1}^{min(n,m)}\mu(d) * f(\lfloor{\frac{n}{d}}\rfloor) * f(\lfloor{\frac{m}{d}}\rfloor)$$

算法过程(假设$n,m$相等，~~我懒~~):


1. 分块预处理出 对于$i\in[1,n]$的$f(i)$函数的值，复杂度$O(n\sqrt{n})$
2. 线性筛筛出对于$i\in[1,n]$的$\mu(i)$函数的值并求得其前缀和，复杂度$O(n)$
3. 对原式进行数论分块，复杂度~~是假的~~$O(\sqrt{n})$

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=5e4+5;
bool v[maxn];
int p[maxn],cnt,mu[maxn],sum[maxn];
long long g[maxn];
void init(int n)
{
    mu[1]=1;
    for(int i=2;i<=n;i++)
    {
        if(!v[i]){p[++cnt]=i;mu[i]=-1;}
        for(int j=1;j<=cnt&&p[j]*i<=n;j++)
        {
            v[p[j]*i]=1;
            if(i%p[j]==0)break;
            else mu[i*p[j]]=-mu[i];
        }
    }
    for(int i=1;i<=n;i++)
        sum[i]=sum[i-1]+mu[i];
    for(int i=1;i<=n;i++)
    {
        long long res=0;
        for(int l=1,r;l<=i;l=r+1)
        {
            r=(i/(i/l));
            res+=1ll*(r-l+1)*1ll*(i/l);
        }
        g[i]=res;
    }
}
int main()
{
    int t;
    scanf("%d",&t);
    init(50000);
    while(t--)
    {
        int n,m;
        scanf("%d%d",&n,&m);
        long long res=0;
        for(int l=1,r;l<=min(n,m);l=r+1)
        {
            r=min(n/(n/l),m/(m/l));
            res+=(sum[r]-sum[l-1])*1ll*g[n/l]*1ll*g[m/l];
        }
        printf("%lld\n",res);
    }
    return 0;
}
```

---

## 作者：yijan (赞：1)

求 $ \sum_{i=1}^n\sum_j^n d(ij) $ $ n , m \leq 10^5 $

由公式

$ d(ij) = \displaystyle\sum_{x|i,y|j} [gcd(x,y) = 1] $

可以得到

$\sum_{i=1}^n \sum_{j=1}^m \sum_{x|i} \sum_{y|j} \sum_{d|gcd(x,y)} \mu(d) $ _(1)_

按照莫比乌斯反演的套路，把求和$ d $提到最前面，在$i$内被$d$整除的数字个数自然就是$\lfloor\frac{i}{d}\rfloor$

$\sum_{d=1}^{n} \mu(d)\sum_{i=1}^n\sum_{j=1}^m \lfloor\frac{i}{d}\rfloor\lfloor\frac{j}{d}\rfloor$

由于$ d $在分母上，这么化没有办法数论分块，所以考虑换一种化法

这里有点绕，首先看到_(1)_式，对于每一组$(d,i,j)$，其贡献就是

($i$中有多少个因子是$d$的倍数 )$\times$($j$中有多少个因子是$d$的倍数)。

直接考虑把$n$中$d$、$2d$、$3d$、$4d$...的倍数的个数加起来就是最后的贡献总数。

$ \sum_{d=1}^n \mu(d) \displaystyle\sum_{s=1}^{\lfloor\frac{n}{d}\rfloor}  \lfloor\frac{n}{sd}\rfloor\displaystyle\sum_{t=1}^{\lfloor\frac{m}{d}\rfloor}\lfloor\frac{m}{td}\rfloor $

然后考虑令

$f(x) = \displaystyle\sum_{i=1}^x \lfloor\frac{x}{i}\rfloor$

对于每一个$f(x)$可以在$O(\sqrt{n})$时间求出，则$f(x)$可以用$O(n\sqrt n)$时间打表

当然分块打表是$O(n)$

当然如果发现$f(x)  = \displaystyle\sum_{i=1}^x \lfloor\frac{x}{i}\rfloor = \sum_{i=1}^x d(x)$做前缀和也是$O(n)$

原式则可化为

$ \sum_{d=1}^n  \mu(d) f(\lfloor\frac{n}{d}\rfloor) f(\lfloor\frac{m}{d}\rfloor) $

$\mu$函数打表，再来一发数论分块，就解决了

------
```cpp
#include<iostream>
#include<algorithm>
#include<cstring>
#include<cstdio>
using namespace std;
#define MAXN 50006
typedef long long ll;
//#define int long long
int pri[MAXN] , mu[MAXN] , c[MAXN] , en;
ll d[MAXN];
void init() {
	for( int i = 1 ; i < MAXN ; ++ i ) 
	mu[i] = 1 , d[i] = 1;
	for( int i = 2 ; i < MAXN ; ++ i ) if( !pri[i] ) {
		pri[++en] = i;
		for( int j = 1 ; j * i < MAXN ; ++ j ) {
			int p = j * i;
			pri[p] = i;
			mu[p] = -mu[p];
			int cnt = 0 , c = p;
			while( c % i == 0 ) c /= i , ++ cnt;
			d[ p ] *= cnt + 1;
			if( cnt != 1 ) mu[p] = 0;
		}
	}
	for( int i = 1 ; i < MAXN ; ++ i ) d[i] += d[i-1] , mu[i] += mu[i-1];
}
int n , m;
main() {
	init();
	int t; cin >> t;
	while( t-- ) {
		scanf("%d%d",&n,&m);
		if( n > m ) swap( n , m );
		long long ans = 0;
		for( int l = 1 , r ; l <= n ; l = r + 1 ) {
			r = 0x3f3f3f3f;
			if( n / l ) r = min( r , n / ( n / l ) );
			if( m / l ) r = min( r , m / ( m / l ) );
			ans += 1LL*( mu[r] - mu[l-1] ) * d[ n / l ] * d[ m / l ];
		}
		printf("%lld\n",ans);
	}
}
```



---

## 作者：hl666 (赞：1)

又是恶心的**莫比乌斯反演**，蒟蒻我又是一脸懵逼的被**CXR dalao**狂虐。

题目要求$ans=\sum_{i=1}^n \sum_{j=1}^m d(ij)$，其中$d(ij)$表示数$x$的约数个数

这道题的一大**难点**就在于$d(ij)$这个函数，它有一个重要的性质：

$$d(ij)=\sum_{x|i}\sum_{y|i}[\gcd(i,j)=1]$$

大致的证明思路就是对于$i,j$的所有约数，为了避免**重复计算**，我们只取**互质**的一对。

知道了这个就是反演的套路了（如果不知道为什么要设去看[Luogu P2257 YY的GCD's Sol](https://www.cnblogs.com/cjjsb/p/9852268.html)）：

$$f(d)=\sum_{i=1}^n\sum_{j=1}^m[gcd(i,j)=d]$$

$$F(n)=\sum_{n|d} f(d)$$

还是由**莫比乌斯反演定理**得到：

$$f(n)=\sum_{n|d}\mu(\lfloor\frac{d}{n}\rfloor)F(d)$$

然后对于原式$ans=\sum_{i=1}^n \sum_{j=1}^m d(ij)$有：

$$ans=\sum_{i=1}^n \sum_{j=1}^m\sum_{x|i}\sum_{y|i}[\gcd(i,j)=1]$$

然后根据莫比乌斯函数的性质：$\sum_{d|n} \mu(d)=[n=1]$，我们可以把这个性质带进去：

$$ans=\sum_{i=1}^n \sum_{j=1}^m\sum_{x|i}\sum_{y|i}\sum_{d|\gcd(x,y)}\mu(d)$$

~~我去，**5个Sigma**~~，我们更换一下枚举项，由枚举$d|\gcd(x,y)$变为直接枚举$d$

$$ans=\sum_{i=1}^n \sum_{j=1}^m\sum_{x|i}\sum_{y|i}\sum_{d=1}^{\min(n,m)}\mu(d)\cdot[d|\gcd(x,y)]$$

把$\mu(d)$提到前面来：

$$ans=\sum_{d=1}^{\min(n,m)}\mu(d)\sum_{i=1}^n \sum_{j=1}^m\sum_{x|i}\sum_{y|i}\cdot[d|\gcd(x,y)]$$

重点来了，我们原来是在**枚举$i,j$和他们的约数**。这样对计算很不利。

我们现在直接枚举**它们的约数再乘上这些约数的倍数的个数**。

为什么？因为每一个约数都只会对**它的倍数**产生贡献，所以有：

$$ans=\sum_{d=1}^{\min(n,m)}\mu(d)\sum_{x=1}^n \sum_{y=1}^m[d|\gcd(x,y)]\lfloor\frac{n}{x}\rfloor\lfloor\frac{m}{y}\rfloor$$

这时候干扰计算的只剩下$[d|\gcd(x,y)]$这个条件了，我们考虑如何消去。

注意到当$[d|\gcd(x,y)]$时意味着$d|x$且$d|y$，所以我们直接枚举$x,y$关于$d$的**倍数关系**，则有：

$$ans=\sum_{d=1}^{\min(n,m)}\mu(d)\sum_{x=1}^{\lfloor\frac{n}{d}\rfloor} \sum_{y=1}^{\lfloor\frac{m}{d}\rfloor}\lfloor\frac{n}{dx}\rfloor\lfloor\frac{m}{dy}\rfloor$$

由于$\lfloor\frac{n}{dx}\rfloor$和$\lfloor\frac{m}{dy}\rfloor$互不干扰，我们拆开考虑：

$$ans=\sum_{d=1}^{\min(n,m)}\mu(d)(\sum_{x=1}^{\lfloor\frac{n}{d}\rfloor}\lfloor\frac{n}{dx}\rfloor) (\sum_{y=1}^{\lfloor\frac{m}{d}\rfloor}\lfloor\frac{m}{dy}\rfloor)$$

这时候我们惊喜的发现$\sum_{x=1}^{\lfloor\frac{n}{d}\rfloor}\lfloor\frac{n}{dx}\rfloor$就是一裸的**除法分块**式子，我们可以直接预处理出$g(x)=\sum_{i=1}^x\lfloor\frac{x}{i}\rfloor$，这样显然是$O(n\sqrt n)$的。

然后再回头看一眼式子，把$\sum_{x=1}^{\lfloor\frac{n}{d}\rfloor}\lfloor\frac{n}{dx}\rfloor$用$g(\lfloor\frac{n}{d}\rfloor)$代进去（另一边同理）得：

$$ans=\sum_{d=1}^{\min(n,m)}\mu(d)\cdot g(\lfloor\frac{n}{d}\rfloor)\cdot g(\lfloor\frac{m}{d}\rfloor)$$

再看上去就很舒服了，我们发现这个式子可以再来一遍**除法分块**，就可以做到单次询问$O(\sqrt n)$了。

CODE

```cpp
#include<cstdio>
#include<cctype>
#define RI register int
using namespace std;
const int P=50000;
int t,n,m,prime[P+5],cnt,mu[P+5],sum[P+5],lim; long long g[P+5],ans; bool vis[P+5];
class FileInputOutput
{
    private:
        #define tc() (A==B&&(B=(A=Fin)+fread(Fin,1,S,stdin),A==B)?EOF:*A++)
        #define pc(ch) (Ftop<S?Fout[Ftop++]=ch:(fwrite(Fout,1,S,stdout),Fout[(Ftop=0)++]=ch))
        #define S 1<<21
        char Fin[S],Fout[S],*A,*B; int Ftop,pt[25];
    public:
        FileInputOutput() { A=B=Fin; Ftop=0; } 
        inline void read(int &x)
        {
            x=0; char ch; while (!isdigit(ch=tc()));
            while (x=(x<<3)+(x<<1)+(ch&15),isdigit(ch=tc()));
        }
        inline void write(long long x)
        {
            if (!x) return (void)(pc(48),pc('\n')); RI ptop=0;
            while (x) pt[++ptop]=x%10,x/=10; while (ptop) pc(pt[ptop--]+48); pc('\n');
        }
        inline void Fend(void)
        {
            fwrite(Fout,1,Ftop,stdout);
        }
        #undef tc
        #undef pc
        #undef S
}F;
#define Pi prime[j]
inline void Euler(void)
{
    vis[1]=mu[1]=1; RI i,j; for (i=2;i<=P;++i)
    {
        if (!vis[i]) prime[++cnt]=i,mu[i]=-1;
        for (j=1;j<=cnt&&i*Pi<=P;++j)
        {
            vis[i*Pi]=1; if (i%Pi) mu[i*Pi]=-mu[i]; else break;
        }
    }
    for (i=1;i<=P;++i) sum[i]=sum[i-1]+mu[i];
    for (i=1;i<=P;++i) for (RI l=1,r;l<=i;l=r+1) r=i/(i/l),g[i]+=1LL*(r-l+1)*(i/l);
}
inline int min(int a,int b)
{
    return a<b?a:b;
}
int main()
{
    //freopen("CODE.in","r",stdin); freopen("CODE.out","w",stdout);
    for (Euler(),F.read(t);t;--t)
    {
        F.read(n); F.read(m); ans=0; lim=min(n,m);
        for (RI l=1,r;l<=lim;l=r+1)
        {
            r=min(n/(n/l),m/(m/l)); ans+=1LL*(sum[r]-sum[l-1])*g[n/l]*g[m/l];
        }
        F.write(ans);
    }
    return F.Fend(),0;
};
```

---

## 作者：huangzirui (赞：0)

题意：

设 $d(x)$ 为 $x$ 的约数个数，求

$$\sum\limits^n_{i=1}\sum\limits^m_{j=1} d(ij)$$

数据组数 $T \leq 5*10^4$ ， $n,m \leq 5*10^4$

( 做此题后，建议练习 [P2257](https://www.luogu.com.cn/problem/P2257) ~~并宣传[题解](https://www.luogu.com.cn/blog/My-luoguBuoke-HZR/solution-p2257)~~)

---

### 本文中要用到的记号

$p_i$ 质数 $\ \ \mu$ 莫比乌斯函数 $\ \ \epsilon$ 单位根 $\ \ \ *$ Dirichlet 卷积

---

引理：

若 $x = {p_1}^{s_1} \cdot{p_2}^{s_2} \cdots {p_k}^{s_k}$

有 $d(x) = (s_1+1)(s_2+1)...(s_k+1)$

证明略。

---

回到原题。

对于这个式子，我们第一时间想到能否将 $d(ij)$ 拆分成 $d(i)\cdot d(j)$ 。

然后发现它是不行的。经过几次手算， $d(ij) = d(i) \cdot d(j)$ 当且仅当 $i$ 和 $j$ 互质。

于是我们仔细考虑一下 $d(ij)$ 值的组成。
\
\
\
\
考虑对 $i$ 的每个因数与 $j$ 的每个因数做乘积。这会多算一部分。

假如一个因数 $p$ 在 $i$ 中出现 $x$ 次，在 $j$ 中出现 $y$ 次。那对于一种不包含因数 $p$ 的组合，她原本应该被计算 $n+m+1$ 次 ($p^0 , p^1 ...\ p^{n+m}$)，但是会被计算 $nm$ 次。

于是我们想找一个改进的方案。因为满足其中一边取 $1$ 的情况刚好有 $n+m+1$ 种（也恰好是两者互质的方案数），我们尝试用这个方案代替原来的方案。

即：

$$\sum\limits^n_{i=1}\sum\limits^m_{j=1}\sum_{x|i}\sum_{y|i}[\text{ x 和 y 互质}]$$

$$\sum\limits^n_{i=1}\sum\limits^m_{j=1}\sum_{x|i}\sum_{y|i}[gcd(x,y)=1]$$

转化成 $\epsilon$ 的形式：

$$\sum\limits_{x|i}\sum\limits_{y|j}\sum_{x|i}\sum_{y|i}\epsilon(gcd(x,y))$$

由 $\mu * 1 = \epsilon$ ，有：

$$\sum\limits^n_{i=1}\sum\limits^m_{j=1}\sum_{x|i}\sum_{y|i}\sum\limits_{d|gcd(x,y)}\mu(d)$$

由最大公约数的性质，转化为：

$$\sum\limits^n_{i=1}\sum\limits^m_{j=1}\sum_{x|i}\sum_{y|i}\sum\limits_{d|x,y}\mu(d)$$

改变枚举顺序，先枚举 $d$ ：

$$\sum\limits_{d=1}^{min(n,m)}\sum_{i=1}^n\sum_{j=1}^m\sum_{x|i}\sum_{y|j}\mu(d)[d\ |\ x,y]$$

这时候发现优化不动了，尝试改变枚举顺序。

不妨先枚举 $x,y$ ：

$$\sum\limits_{d=1}^{min(n,m)}\sum_{x=1}^n\sum_{y=1}^m\sum_{x|i}\sum_{y|j}\mu(d)[d\ |\ x,y]$$

然后发现 $i,j$ 的取值与 $\mu(d)[d | x,y]$ 无关，然后可以就顺利的优化了。

$$\sum\limits_{d=1}^{min(n,m)}\sum_{x=1}^n\sum_{y=1}^m\sum_{i=1}^{\left\lfloor {\frac{n}{x}}\right\rfloor}\sum_{j=1}^{\left\lfloor {\frac{m}{y}}\right\rfloor}\mu(d)[d\ |\ x,y]$$

$$\sum\limits_{d=1}^{min(n,m)}\mu(d)\sum_{x=1}^n\sum_{y=1}^m\left\lfloor {\frac{n}{x}}\right\rfloor\left\lfloor {\frac{m}{y}}\right\rfloor[d\ |\ x,y]$$

然后又可以优化两个 $\sum$

$$\sum\limits_{d=1}^{min(n,m)}\mu(d)\sum_{x=1}^{\left\lfloor {\frac{n}{d}}\right\rfloor}\sum_{y=1}^{\left\lfloor {\frac{m}{d}}\right\rfloor}\left\lfloor {\frac{n}{dx}}\right\rfloor\left\lfloor {\frac{m}{dy}}\right\rfloor$$

改一下式子让它更优美（

$$\sum\limits_{d=1}^{min(n,m)}\mu(d)\sum_{x=1}^{\left\lfloor {\frac{n}{d}}\right\rfloor}\sum_{y=1}^{\left\lfloor {\frac{m}{d}}\right\rfloor}\left\lfloor {\frac{\left\lfloor {\frac{n}{d}}\right\rfloor}{x}}\right\rfloor\left\lfloor {\frac{\left\lfloor {\frac{m}{d}}\right\rfloor}{y}}\right\rfloor$$

设 $N = \left\lfloor {\frac{n}{d}}\right\rfloor , M = \left\lfloor {\frac{m}{d}}\right\rfloor$

原式等于：

$$\sum\limits_{d=1}^{min(n,m)}\mu(d)\sum_{x=1}^{N}\sum_{y=1}^{M}\left\lfloor {\frac{N}{x}}\right\rfloor\left\lfloor {\frac{M}{y}}\right\rfloor$$

然后对于每个 $d$ 分别计算 $\sum\limits_{x=1}^N \left\lfloor {\frac{N}{x}}\right\rfloor , \sum\limits_{y=1}^M \left\lfloor {\frac{M}{y}}\right\rfloor$ 即可。

后两个式子预处理。而对于每个 $d$ 由于后面两个式子的特殊性，数论分块即可。

前面的 $\sum$ 可以预处理前缀和优化

于是总复杂度 $O(T\sqrt n)$ ，可以通过此题。

```
#include<bits/stdc++.h>
#define ll long long
using namespace std;
inline int read(){
	char c=getchar();int x=0,f=1;
    while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
    while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}
    return x*f;
}
const int maxn=50010;
int i,j,k,n,m;
int prime[maxn],is_prime[maxn],mu[maxn],Mu[maxn],num;
ll Ans[maxn];
void init(){
	for(int i=2;i<maxn;i++)is_prime[i]=1;
	mu[1]=1;
	for(int i=2;i<maxn;i++){
		if(is_prime[i])prime[++num]=i,mu[i]=-1;
		for(int j=1;j<=num && prime[j]*i<maxn;j++){
			is_prime[i*prime[j]]=0;
			if(i%prime[j]==0)break;
			mu[i*prime[j]]=-mu[i];
		}
	}
	for(int i=1;i<maxn;i++)
		Mu[i]=Mu[i-1]+mu[i];
	for(int i=1;i<maxn;i++){
		for(int l=1,r=0;l<=i;l=r+1){
			r=i/(i/l);
			Ans[i]+=1ll*(r-l+1)*(i/l);
		}
	}
}
int t;
ll work(){
	ll ans=0;
	for(int l=1,r=0;l<=n;l=r+1){
		r=min(n/(n/l),m/(m/l));
		ans+=(Mu[r]-Mu[l-1])*Ans[n/l]*Ans[m/l];
	}
	return ans;
}
int main(){
	init();t=read();
	while(t--){
		n=read();m=read();
		if(n>m)swap(n,m);
		printf("%lld\n",work());
	}
	return 0;
}
```

---

## 作者：localhost (赞：0)



看了大多数题解都是莫比乌斯反演

其实只需要莫比乌斯函数的一个性质就可以了

$$
\sum_{x|n}\mu(n) = [n =1]
$$

具体怎么推就不介绍了

这题还要用到一个定理：

$
d(ij) = \sum_{x|i} \sum_{y|j}[gcd(x,y) = 1]
$

证明的话看楼下大佬的，我就不证了

于是

设$n<m$.

$ans = \sum_{i=1}^n \sum_{j=1}^m d(ij)$

$=\sum_{i=1}^n \sum_{j=1}^m \sum_{x|i} \sum_{y|j}[gcd(x,y) = 1]$

$=\sum_{x=1}^n\sum\limits_{y=1}^m \left\lfloor\frac{n}{x}\right\rfloor \left\lfloor\frac{m}{y}\right\rfloor [\gcd(x,y)=1]$

$x,y$换成$i,j$

$ans = \sum\limits_{i=1}^n\sum\limits_{j=1}^m \left\lfloor\frac{n}{i}\right\rfloor \left\lfloor\frac{m}{j}\right\rfloor[\gcd(i,j)=1]$

$=\sum\limits_{i=1}^n\sum\limits_{j=1}^m \left\lfloor\frac{n}{i}\right\rfloor \left\lfloor\frac{m}{j}\right\rfloor \sum_{k|gcd(i,j)}\mu(k)$

设$g(i)=\sum_{i=1}^n \left \lfloor \frac ni \right \rfloor$

$ans=\sum_{k=1}^n\mu(k) g(\left \lfloor \frac nk \right \rfloor) g(\left \lfloor \frac mk \right \rfloor)
$

于是就可以通过莫比乌斯函数和数论分块~~愉快~~地解决这题了

```cpp
#include<bits/stdc++.h>
namespace ZDY{
	#pragma GCC optimize(3)
	#define il __inline__ __attribute__ ((always_inline))
	#define rg register
	#define ll long long
	#define ull unsigned long long
	#define db double
	#define sht short
	#define MB template <class T>il
	#define Fur(i,x,y) for(int i=x;i<=y;i++)
	#define Fdr(i,x,y) for(int i=x;i>=y;i--)
	#define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)
	#define clr(x,y) memset(x,y,sizeof(x))
	#define cpy(x,y) memcpy(x,y,sizeof(x))
	#define fin(s) freopen(s".in","r",stdin)
	#define fout(s) freopen(s".out","w",stdout)
	#define fcin ios::sync_with_stdio(false)
	#define l2(n) (int(log2(n)))
	#define inf 0x3f3f3f3f
	MB T ABS(T x){return x>0?x:-x;}
	MB T MAX(T x,T y){return x>y?x:y;}
	MB T MIN(T x,T y){return x<y?x:y;}
	MB T GCD(T x,T y){return y?GCD(y,x%y):x;}
	MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}
}using namespace ZDY;using namespace std;
namespace IO{const char* ln="\n";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;
#define N 50000
int pri[N+11],mu[N+11],tot=0;
ll g[N+11];
bool f[N+11];
void sm(int n){
	mu[1]=f[1]=1;
	Fur(i,2,n){
		if(!f[i])pri[++tot]=i,mu[i]=-1;
		Fur(j,1,tot){
			if(pri[j]*i>n)break;
			f[i*pri[j]]=1;
			if(i%pri[j])mu[i*pri[j]]=-mu[i];
			else break;
		}
	}
	Fur(i,2,n)mu[i]+=mu[i-1];
	Fur(i,1,n)
		for(int l=1,r=0;l<=i;l=r+1){
			r=i/(i/l);
			g[i]+=(r-l+1)*(i/l);
		}
}  
int main(){
	sm(N);
	int T,n,m;
	in>>T;
	while(T--){
		in>>n>>m;
		if(n>m)SWAP(n,m);
		ll ans=0;
		for(int l=1,r=0;l<=n;l=r+1){
			r=MIN(n/(n/l),m/(m/l));
			ans+=1ll*(mu[r]-mu[l-1])*g[n/l]*g[m/l];
		}
		out<<ans<<ln;
	}
}
```


---

## 作者：_ctz (赞：0)

[$\tt\text{My\ blog}$](https://ctz45562.github.io/2019/07/10/洛谷-P3327-SDOI2015-约数个数和/)

[传送门](https://www.luogu.org/problemnew/show/P3327)

首先有一个玄学的式子：$d(ij)=\sum\limits_{a|i}\sum\limits_{b|i}[gcd(a,b)=1]$

然后就可以推了：（以下默认$n<m$）

$\sum\limits_{i=1}^n\sum\limits_{j=1}^md(ij)$

$=\sum\limits_{i=1}^n\sum\limits_{j=1}^m\sum\limits_{d|i}\sum\limits_{e|j}[gcd(d,e)=1]$

$=\sum\limits_{i=1}^n\sum\limits_{j=1}^m\sum\limits_{d|i}\sum\limits_{e|j}\sum\limits_{a|gcd(d,e)}\mu(a)$

$=\sum\limits_{i=1}^n\sum\limits_{j=1}^m\sum\limits_{d|i}\sum\limits_{e|j}\sum\limits_{a|d,a|e}\mu(a)$

枚举$a,d,e$：

$=\sum\limits_{i=1}^n\sum\limits_{j=1}^m\sum\limits_{d=1}^n\sum\limits_{e=1}^m\sum\limits_{a=1}^n[d|i][e|j][a|d][a|e]\mu(a)$

$=\sum\limits_{a=1}^n\sum\limits_{d=1}^n\sum\limits_{i=1}^n[d|i]\sum\limits_{e=1}^m\sum\limits_{j=1}^m[e|j][a|d][a|e]\mu(a)$

$=\sum\limits_{a=1}^n\sum\limits_{d=1}^n\left\lfloor\dfrac{n}{d}\right\rfloor[a|d]\sum\limits_{e=1}^m\left\lfloor\dfrac{m}{e}\right\rfloor[a|e]\mu(a)$

$=\sum\limits_{a=1}^n\sum\limits_{d=1}^{\lfloor\frac{n}{a}\rfloor}\left\lfloor\dfrac{n}{ad}\right\rfloor\sum\limits_{e=1}^{\lfloor\frac{m}{a}\rfloor}\left\lfloor\dfrac{m}{ae}\right\rfloor\mu(a)$

设$f(n)=\sum\limits_{i=1}^n\left\lfloor\dfrac{n}{i}\right\rfloor$

现在我们求的就是$\sum\limits_{a=1}^nf(\left\lfloor\dfrac{n}{a}\right\rfloor)f(\left\lfloor\dfrac{m}{a}\right\rfloor)\mu(a)$

显然预处理出$f$就可以整除分块了。

$n$只有$50000$珂以暴力继续整除分块$O(n\sqrt{n})$预处理。

不过考虑这玩意的含义，就是约数个数前缀和。$O(n\log n)$筛出$d$就行了（懒得线筛了）

答案要开$long\ long$。

代码：

``` cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <cstring>

#define maxn 50005
#define inf 0x3f3f3f3f

using namespace std;

inline int read(){
	int x=0,y=0;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')y=1;ch=getchar();}
	while(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
	return y?-x:x;
}
int mu[maxn],prime[maxn>>2],sum[maxn],cnt;
bool is[maxn];
int main(){
	int t=read();
	mu[1]=is[1]=1;
	for(register int i=2;i<=50000;++i){
		if(!is[i])prime[++cnt]=i,mu[i]=-1;
		for(register int j=1;j<=cnt&&i*prime[j]<=50000;++j){
			is[i*prime[j]]=1;
			if(i%prime[j]==0){mu[i*prime[j]]=0;break;}
			mu[i*prime[j]]=-mu[i];
		}
	}
	for(register int i=1;i<=50000;++i)
		for(register int j=i;j<=50000;j+=i)
			++sum[j];
	for(register int i=2;i<=50000;++i)mu[i]+=mu[i-1],sum[i]+=sum[i-1];
	while(t--){
		int n=read(),m=read();
		long long ans=0;
		if(n>m)swap(n,m);
		for(register int l=1,r;l<=n;l=r+1){
			r=min(n,min(n/(n/l),m/(m/l)));
			ans+=1ll*sum[n/l]*sum[m/l]*(mu[r]-mu[l-1]);
		}
		printf("%lld\n",ans);
	}
}
```



---

## 作者：子衿君 (赞：0)

###### SDOI2015 约数个数和

$$\large \sum_{i=1}^n\sum_{j=1}^m  d(ij) $$

$$\large \because d(ij)=\sum_{x|i} \sum_{y|j} [gcd(x,y)==1]$$

$$\large \sum_{i=1}^n \sum_{j=1}^m \sum_{x|i} \sum_{y|j} [gcd(x,y)==1]$$

$$\large \sum_{x=1}^n \sum_{y=1}^m \Big\lfloor\frac{n}{x}\Big\rfloor \Big\lfloor\frac{m}{y}\Big\rfloor [gcd(x,y)==1]$$

$$\large \sum_{i=1}^n \sum_{j=1}^m \Big\lfloor\frac{n}{i}\Big\rfloor \Big\lfloor\frac{m}{j}\Big\rfloor [gcd(i,j)==1]$$

接下来使用莫比乌反演的常见套路

$$\large  f(x)=\large \sum_{i=1}^n \sum_{j=1}^m \Big\lfloor\frac{n}{i}\Big\rfloor \Big\lfloor\frac{m}{j}\Big\rfloor [gcd(i,j)==x]$$

$$\large g(x)=\sum_{x|d}f(d)=\large \sum_{i=1}^n \sum_{j=1}^m \Big\lfloor\frac{n}{i}\Big\rfloor \Big\lfloor\frac{m}{j}\Big\rfloor [gcd(i,j)|x]$$

$$\large =\sum_{i=1}^{{\lfloor\frac{n}{x}\rfloor}}\sum_{j=1}^{\lfloor\frac{m}{x}\rfloor}[1|gcd(i,j)]\Big\lfloor\frac{\lfloor\frac{n}{x}\rfloor}{i}\Big\rfloor \Big\lfloor\frac{\lfloor\frac{m}{x}\rfloor}{j}\Big\rfloor$$

$$\large =\sum_{i=1}^{{\lfloor\frac{n}{x}\rfloor}}\sum_{j=1}^{\lfloor\frac{m}{x}\rfloor}\Big\lfloor\frac{n}{xi}\Big\rfloor\Big\lfloor\frac{m}{xj}\Big\rfloor$$

$$\large f(1)=\sum_{1|d}g(d)\mu\Big(\frac{d}{n} \Big)=\large =\sum_{d=1}^n g(d)\mu(d)$$

$$\large =\sum_{d=1}^n \mu(d)\sum_{i=1}^{{\lfloor\frac{n}{d}\rfloor}}\sum_{j=1}^{\lfloor\frac{m}{d}\rfloor}\Big\lfloor\frac{n}{di}\Big\rfloor\Big\lfloor\frac{m}{dj}\Big\rfloor$$

$$\large =\sum_{d=1}^n \mu(d)\sum_{i=1}^{{\lfloor\frac{n}{d}\rfloor}}\Big\lfloor\frac{n}{di}\Big\rfloor\sum_{j=1}^{\lfloor\frac{m}{d}\rfloor}\Big\lfloor\frac{m}{dj}\Big\rfloor$$



---

## 作者：大略 (赞：0)

若$i,j$有质因数分解：

$\begin{cases}i=p_1^{\alpha_1}* p_2^{\alpha_2}*\cdots*p_k^{\alpha_k} \\ j=p_1^{\beta_1}* p_2^{\beta_2}*\cdots*p_k^{\beta_k} \end{cases}$ 

$\begin{aligned}\text{则} d(i,j)&=(1+\alpha_1+\beta_1)(1+\alpha_2+\beta_2)\cdots(1+\alpha_n+\beta_n) \\ &=\sum\limits_{\begin{aligned} S,T&\subsetneqq \{ 1,2,\cdots,n\} \\ &S\bigcap T= \varnothing  \end{aligned}} \prod \limits _{t \in T} \alpha_t \prod\limits_{s\in S} \beta_s \\ &=\sum \limits_{x|i} \sum \limits_{y|j} I[gcd(x,y)=1] \end{aligned}$ 

所以$Ans=\sum\limits_{x=1}^N \sum\limits_{y=1}^M [\frac{N}{x}] \cdot [\frac{M}{y}]\cdot I[gcd(x,y)=1]$ 

记$f(d)=\sum\limits_{x=1}^N \sum\limits_{y=1}^M [\frac{N}{x}] \cdot [\frac{M}{y}]\cdot I[gcd(x,y)=d]$ 

$\begin{aligned} \text{则} F(d)=&\sum\limits_{x=1}^N \sum\limits_{y=1}^M [\frac{N}{x}] \cdot [\frac{M}{y}]\cdot I[d|gcd(x,y)] \\ =&\sum\limits_{x=1}^{[\frac{N}{d}]} \sum\limits_{y=1}^{[\frac{M}{d}]} [\frac{[\frac{N}{d}]}{x}] \cdot [\frac{[\frac{M}{d}]}{y}] \\ =& \sum\limits_{x=1}^{[\frac{N}{d}]} [\frac{[\frac{N}{d}]}{x}] \cdot \sum\limits_{y=1}^{[\frac{M}{d}]} [\frac{[\frac{M}{d}]}{y}] \end{aligned}$ 

记$G(n)=\sum \limits_{i=1}^n [\frac{n}{x}]$ 

由莫比乌斯反演得:

$\begin{aligned} f(1)=&\sum \limits_{i=1}^{min(N,M)} \! \! \! \! \mu(i) \sum\limits_{x=1}^{[\frac{N}{i}]} \sum\limits_{y=1}^{[\frac{M}{i}]} [\frac{N}{ix}][\frac{M}{iy}] \\ =&\sum\limits_{i=1}^{min(N,M)} \! \! \! \! \mu(i) G([\frac{N}{i}]) G([\frac{M}{i}]) \end{aligned}$ 

此时就可以分块做了

上代码：

```cpp
#include<bits/stdc++.h>
#define N 50010
#define ll long long
using namespace std;
ll t,n,m,p[N+1],s[N+1],mo[N+1],g[N+1];
bool used[N+1];
ll gg(ll x)
{
    ll ans=0;
    for(ll i=1,j;i<=x;i=j+1)
    {
        j=x/(x/i);
        ans+=(j-i+1)*(x/i);
    }
    return ans;
}
void euler()
{
    mo[1]=1;
    for(ll i=2;i<N;i++)
    {
        if(used[i]==0)
        {
            p[++p[0]]=i;
            mo[i]=-1;
            used[i]=1;
        }
        for(int j=1;j<=p[0];j++)
        {
            if(i*p[j]>=N)
                break;
            used[i*p[j]]=1;
            if(i%p[j]==0)
            {
                mo[i*p[j]]=0;
                break;
            }
            mo[i*p[j]]=-mo[i];
        }
    }
    for(ll i=1;i<N;i++)
        s[i]=s[i-1]+mo[i];
}
int main()
{
    scanf("%lld",&t);
    euler();
    for(int i=1;i<=N;i++)
        g[i]=gg(i);
    while(t--)
    {
        scanf("%lld%lld",&n,&m);
        ll ans=0;
        for(ll i=1,j;i<=min(n,m);i=j+1)
        {
            j=min(n/(n/i),m/(m/i));
            ans+=g[n/i]*g[m/i]*(s[j]-s[i-1]);
        }
        printf("%lld\n",ans);
    }
    return 0;
}
```



---

## 作者：GoldenPotato137 (赞：0)

蒟蒻博客传送门：[戳我获得更好的阅读体验w](https://www.cnblogs.com/GoldenPotato/p/10307066.html)

---
# Solution
首先，我们需要一个结论：
$\large d(i,j)=\sum_{x|i}\sum_{y|j}[gcd(x,y)=1]$
> 
理性证明请看[这篇博客](https://www.luogu.org/blog/An-Amazing-Blog/mu-bi-wu-si-fan-yan-ji-ge-ji-miao-di-dong-xi)的例五;
本蒟蒻提供一个感性证明的方法：如果$x*y$是$i*j$的因数，我们必须有$x|i,y|j$，而后面那个$gcd(x,y)$是用来去重的


有了这个柿子之后，我们之后的推导就比较套路了：

**为了方便讨论，之后的柿子均默认$m>n$**

**为了方便书写，之后的除法默认向下取整**

原式：

$\large \sum_{i=1}^n\sum_{j=1}^md(i*j)$

把我们上面的结论代进去

$\large \sum_{i=1}^n\sum_{j=1}^m\sum_{x|i}\sum_{y|j}[gcd(x,y)=1]$

~~根据套路~~，这里的$x|i$与$y|j$应该写成枚举的形式：

$\large \sum_{i=1}^n\sum_{j=1}^m\sum_{x=1}^{n}[x|i]\sum_{y=1}^{m}[y|j][gcd(x,y)=1]$

这里显然可以把$x,y$的和式写到最前面去：

$\large \sum_{x=1}^{n}[x|i]\sum_{y=1}^{m}[y|j]\sum_{i=1}^n\sum_{j=1}^m[gcd(x,y)=1]$

然后就可以去掉$x,y$后面的那两个判断式啦

$\large \sum_{x=1}^{n}\sum_{y=1}^{m}\sum_{i=1}^{n/x}\sum_{j=1}^{m/y}[gcd(x,y)=1]$

然后我们再去套路后面那个$gcd$，根据莫比乌斯函数的性质$[x=1]=\sum_{d|x}\mu(d)$，我们就把$gcd$带入得

$\large \sum_{x=1}^{n}\sum_{y=1}^{m}\sum_{i=1}^{n/x}\sum_{j=1}^{m/y}\sum_{d|gcd(x,y)}\mu(d)$

然后去枚举$d$

$\large \sum_{x=1}^{n}\sum_{y=1}^{m}\sum_{i=1}^{n/x}\sum_{j=1}^{m/y}\sum_{d=1}^{n}\mu(d)[d|gcd(x,y)]$

套路地把$\mu$的和式丢到最前面，化简一下就有：

$\large \sum_{d=1}^{n}\mu(d)\sum_{x=1}^{n/d}\sum_{y=1}^{m/d}\sum_{i=1}^{n/(x*d)}\sum_{j=1}^{m/(y*d)}1$

然后有

$\large \sum_{d=1}^{n}\mu(d)\sum_{x=1}^{n/d}\sum_{y=1}^{m/d}\frac{n}{x*d}\frac{m}{y*d}$

移项整理一下：

$\large \sum_{d=1}^{n}\mu(d)\sum_{x=1}^{n/d}\frac{n}{x*d}\sum_{y=1}^{m/d}\frac{m}{y*d}$

~~好了，到这里我就不会推了~~

之后的内容感谢stO @Maxwei_wzj Orz的教学

事实上，这个柿子我们已经可以算了。

$\large \sum_{d=1}^{n}\mu(d)\sum_{x=1}^{n/d}\frac{n}{x*d}\sum_{y=1}^{m/d}\frac{m}{y*d}$

首先，我们有一个结论~~(我不会证)~~

$\large x/(y*z)=(x/y)/z$ (这里的除法**向下取整**)

我们的柿子就可以变为

$\large \sum_{d=1}^{n}\mu(d)\sum_{x=1}^{n/d}\frac{\frac{n}{d}}{x}\sum_{y=1}^{m/d}\frac{\frac{m}{d}}{y}$

然后我们再设一个方程:

$f(x)=\sum_{i=1}^x\frac{x}{i}$

我们柿子就可以写为：

$\large \sum_{d=1}^{n}\mu(d)f(\frac{n}{d})f(\frac{m}{d})$

诶？我们好像又能整除分块了。

没错，我们只需要先用$O(n*\sqrt n)$的整除分块预处理出$f$

然后再每次$O(\sqrt n)$整除分块算出那个柿子就好。

时间复杂度$O(n*\sqrt n)$

完结撒花✿✿ヽ(°▽°)ノ✿

---
# Code
```cpp
//Luogu  P3327 [SDOI2015]约数个数和
//Jan,22ed,2019
//莫比乌斯反演
#include<iostream>
#include<cstdio>
using namespace std;
long long read()
{
	long long x=0,f=1; char c=getchar();
	while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
	while(isdigit(c)){x=x*10+c-'0';c=getchar();}
	return x*f;
}
const int N=50000+1000;
const int M=50000;
int prime[N],p_cnt,mu[N];
bool noPrime[N];
void GetPrime(int n)
{
	noPrime[1]=true,mu[1]=1;
	for(int i=2;i<=n;i++)
	{
		if(noPrime[i]==false)
			prime[++p_cnt]=i,mu[i]=-1;
		for(int j=1;j<=p_cnt and i*prime[j]<=n;j++)
		{
			noPrime[i*prime[j]]=true;
			if(i%prime[j]==0)
			{
				mu[i*prime[j]]=0;
				break;
			}
			mu[i*prime[j]]=mu[i]*mu[prime[j]];
		}
	}
}
long long f[N],pre_mu[N];
int main()
{
	GetPrime(M);
	for(int i=1;i<=M;i++)
		for(int l=1,r;l<=i;l=r+1)
		{
			r=i/(i/l);
			f[i]+=(r-l+1)*(i/l);
		}
	for(int i=1;i<=M;i++)
		pre_mu[i]=pre_mu[i-1]+mu[i];
	
	int T=read();
	for(;T>0;T--)
	{
		long long n=read(),m=read();
		if(n>m) swap(n,m);
		
		long long ans=0;
		for(int l=1,r;l<=n;l=r+1)
		{
			r=min(n/(n/l),m/(m/l));
			ans+=(pre_mu[r]-pre_mu[l-1])*f[n/l]*f[m/l];
		}
		
		printf("%lld\n",ans);
	}
	return 0;
}

```

---

## 作者：Wolfycz (赞：0)

$d$太丑了，我之后都写成$\sigma_0$了

------

首先你需要知道$\sigma_0(nm)=\sum\limits_{i|n}\sum\limits_{j|m}[\gcd(i,j)=1]$

~~（我就是不知道这个推了1h无果）~~

然后我们证明一下这个东西（我只能证明等式左右两边相等）

令$n=\prod\limits_{i=1}^kp_i^{a_i},m=\prod\limits_{i=1}^kp_i^{b_i}$，$a_i,b_i$可以为0

然后有$\sigma_0(nm)=\prod\limits_{i=1}^k(a_i+b_i+1)$，我们考虑某个质因子$p_i$对答案的贡献， $p_i$要么在$n$中有$a_i$中取法，要么在$m$中有$b_i$种取法，要么不取有一种方法，所以共计$a_i+b_i+1$中取法，再乘法原理累乘一下即为$\sigma_0(n,m)$

然后我们来推式子

$$\sum\limits_{i=1}^n\sum\limits_{j=1}^m\sum\limits_{u|i}\sum\limits_{v|j}[\gcd(u,v)=1]$$

我们调整一下枚举顺序

$$\sum\limits_{u=1}^n\sum\limits_{v=1}^m\lfloor\dfrac{n}{u}\rfloor\lfloor\dfrac{m}{v}\rfloor[\gcd(u,v)=1]$$

$u,v$太丑啦，我们改一下变量名，并且对最后用面的式子反演一下

$$\sum\limits_{i=1}^n\sum\limits_{j=1}^m\lfloor\dfrac{n}{i}\rfloor\lfloor\dfrac{m}{j}\rfloor\sum\limits_{x|i,x|j}\mu(x)$$

我们把枚举$x$提到前面，并且进行分组，得到

$$\sum\limits_{x=1}^n\mu(x)\sum\limits_{i=1}^{\lfloor\frac{n}{x}\rfloor}\lfloor\dfrac{n}{ix}\rfloor\sum\limits_{j=1}^{\lfloor\frac{m}{x}\rfloor}\lfloor\dfrac{m}{jx}\rfloor$$

如果我们能够求出$\sum\limits_{i=1}^n\lfloor\dfrac{n}{i}\rfloor$，我们就可以对原式进行数论分块了

然后我们参考一下[[AHOI2005]约数研究](https://www.luogu.org/problemnew/show/P1403)这题，可以发现$\sum\limits_{i=1}^n\lfloor\dfrac{n}{i}\rfloor=\sum\limits_{i=1}^n\sigma_0(i)$，因为$\lfloor\dfrac{n}{i}\rfloor$相当于统计$1\sim n$中有多少个数的因数有$i$

$\sigma_0(n)$显然是个积性函数，因此我们可以线筛求出前缀和，然后对原式进行数论分块即可

```cpp
/*program from Wolfycz*/
#include<cmath>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#define inf 0x7f7f7f7f
using namespace std;
typedef long long ll;
typedef unsigned int ui;
typedef unsigned long long ull;
inline char gc(){
	static char buf[1000000],*p1=buf,*p2=buf;
	return p1==p2&&(p2=(p1=buf)+fread(buf,1,1000000,stdin),p1==p2)?EOF:*p1++;
}
inline int frd(){
	int x=0,f=1; char ch=gc();
	for (;ch<'0'||ch>'9';ch=gc())	if (ch=='-')	f=-1;
	for (;ch>='0'&&ch<='9';ch=gc())	x=(x<<3)+(x<<1)+ch-'0';
	return x*f;
}
inline int read(){
	int x=0,f=1; char ch=getchar();
	for (;ch<'0'||ch>'9';ch=getchar())	if (ch=='-')	f=-1;
	for (;ch>='0'&&ch<='9';ch=getchar())	x=(x<<3)+(x<<1)+ch-'0';
	return x*f;
}
inline void print(int x){
	if (x<0)	putchar('-'),x=-x;
	if (x>9)	print(x/10);
	putchar(x%10+'0');
}
const int N=5e4;
int prime[N+10],mu[N+10],smu[N+10],f[N+10],Frm[N+10];
ll sf[N+10];
bool inprime[N+10];
void prepare(){
	int tot=0;
	mu[1]=f[1]=smu[1]=sf[1]=1;
	for (int i=2;i<=N;i++){
		if (!inprime[i])	prime[++tot]=i,mu[i]=-1,f[i]=Frm[i]=2;
		for (int j=1;j<=tot&&i*prime[j]<=N;j++){
			inprime[i*prime[j]]=1;
			if (i%prime[j]==0){
				mu[i*prime[j]]=0;
				Frm[i*prime[j]]=Frm[i]+1;
				f[i*prime[j]]=f[i]/Frm[i]*Frm[i*prime[j]];
				break;
			}
			mu[i*prime[j]]=-mu[i];
			Frm[i*prime[j]]=2;
			f[i*prime[j]]=f[i]<<1;
		}
		sf[i]=sf[i-1]+f[i];
		smu[i]=smu[i-1]+mu[i];
	}
}
int main(){
	prepare();
	for (int T=read();T;T--){
		int n=read(),m=read(); ll Ans=0;
		if (n>m)	swap(n,m);
		for (int i=1,pos;i<=n;i=pos+1){
			pos=min(n/(n/i),m/(m/i));
			Ans+=(smu[pos]-smu[i-1])*sf[n/i]*sf[m/i];
		}
		printf("%lld\n",Ans);
	}
	return 0;
}
```



---

## 作者：xryjr233 (赞：0)

求

$\sum_{i=1}^{N}\sum_{j=1}^{M}d(ij)$

有一个定理，

$d(ij)=\sum_{x|i}\sum_{y|j}[gcd(i,j)=1]$

又因为$\sum_{d|n}\mu(d)=[n=1]$

可得$\sum_{d|gcd(i,j)}\mu(d)=[gcd(i,j)=1]$

则

$d(ij)=\sum_{x|i}\sum_{y|j}\sum_{d|gcd(x,y)}\mu(d)$

则答案为

$\sum_{i=1}^{N}\sum_{j=1}^{M}\sum_{x|i}\sum_{y|j}\sum_{d|gcd(x,y)}\mu(d)$

我们改枚举$d$

$\sum_{i=1}^N\sum_{j=1}^M\sum_{x|i}\sum_{y|j}\sum_{d=1}^{min(N,M)}\mu(d)[d|gcd(x,y)]$

变换枚举顺序,提前$\mu(d)$项

$\sum_{d=1}^{min(N,M)}\mu(d)\sum_{i=1}^{N}\sum_{j=1}^{M}\sum_{x|i}\sum_{y|j}[d|gcd(x,y)]$

由于$i$是$x$的倍数，$j$是$y$的倍数，$1$到$n$内$m$的倍数有$\lfloor\frac{n}{m}\rfloor$个

所以原式$=$

$\sum_{d=1}^{min(N,M)}\mu(d)\sum_{x=1}^N\sum_{y=1}^M\lfloor\frac{N}{x}\rfloor\lfloor\frac{M}{y}\rfloor[d|gcd(x,y)]$

由于要求$d|gcd(x,y)$所以$x,y$是$d$的倍数，我们将枚举$x,y$改为枚举$k,l$,使$kd=x,ld=y$

$\sum_{d=1}^{min(N,M)}\mu(d)\sum_{k=1}^{\lfloor\frac{N}{d}\rfloor}\sum_{l=1}^{\lfloor\frac{M}{d}\rfloor}\lfloor\frac{N}{kd}\rfloor\lfloor\frac{M}{ld}\rfloor$

提前$\lfloor\frac{N}{kd}\rfloor$项得

$\sum_{d=1}^{min(N,M)}\mu(d)\sum_{k=1}^{\lfloor\frac{N}{d}\rfloor}\lfloor\frac{N}{kd}\rfloor\sum_{l=1}^{\lfloor\frac{M}{d}\rfloor}\lfloor\frac{M}{ld}\rfloor$

我们记

$g(x)=\sum_{i=1}^x \lfloor\frac{x}{i}\rfloor$

显然可以整除分块。

式子可以变成

$\sum_{d=1}^{min(n,m)}\mu(d)g(\lfloor\frac{N}{d}\rfloor)g(\lfloor\frac{M}{d}\rfloor)$

可以整除分块。

我们$O(n\sqrt{n})$预处理$g$，$O(n)$预处理$\mu$的前缀和，即可在单次$O(\sqrt{n}+\sqrt{m})$的时间内求得答案。

code:
```cpp
#include<bits/stdc++.h>
using namespace std;
const int fr=50010;
int t,n,m,ip[50010],p[50010],sz,mu[50010],sum[50010],l,r;
long long ans,g[50010];
void getmu(){
	mu[1]=1;
	sum[1]=1;
	for(int i=2;i<=fr;i++){
		if(!ip[i]){
			p[++sz]=i;
			mu[i]=-1;
		}
		for(int j=1;j<=sz;j++){
			if(i*p[j]>fr){
				break;
			}
			ip[i*p[j]]=1;
			if(i%p[j]==0){
				break;
			}
			mu[i*p[j]]=-mu[i];
		}
		sum[i]=sum[i-1]+mu[i];
	}
}
long long Query(int x){
	long long tot=0;
	int L=1,R;
	while(L<=x){
		R=x/(x/L);
		tot+=(R-L+1)*(x/L);
		L=R+1;
	}
	return tot;
}
void print(long long x){
	if(x>9){
		print(x/10);
	}
	putchar(x%10+'0');
}
int main(){
	scanf("%d",&t);
	getmu();
	for(int i=1;i<=50000;i++){
		g[i]=Query(i);
	}
	while(t--){
		scanf("%d%d",&n,&m);
		if(n>m){
			swap(n,m);
		}
		ans=0;
		l=1;
		while(l<=n){
			r=min(n/(n/l),m/(m/l));
			ans+=(sum[r]-sum[l-1])*g[n/l]*g[m/l];
			l=r+1;
		}
		print(ans);
		putchar('\n');
	}
	return 0;
}
```

---

## 作者：RemiliaScar1et (赞：0)

# P3327 [SDOI2015]约数个数和

求 $\sum\limits_{i=1}^n\sum\limits_{j=1}^md(ij)$

其中 $1\le n,m \le 5\times 10^4$。

乍一看我们是找不到任何思路的，所以我们要想一想函数有些什么性质。

约数个数和乘法有关，而题目中的 $d$ 的自变量又是乘积形式，所以我们从定义出发考虑，得到下面这个性质：

$$d(ij)=\sum\limits_{x|i}\sum\limits_{y|j}[gcd(x,y)=1]$$

文字叙述上就是说，$i\times j$ 的约数个数和就是 $i,j$ 各因子中两两互质的因子对个数和。

于是我们把它套进原式子：

$$
\begin{aligned}
\sum\limits_{i=1}^n\sum\limits_{j=1}^md(ij)
&= \sum\limits_{i=1}^n\sum\limits_{j=1}^m\sum_{x|i}\sum_{y|j}[gcd(x,y)=1]\\
&= \sum_{x=1}^n\sum_{y=1}^m\lfloor\frac{n}{x}\rfloor\lfloor\frac{m}{y}\rfloor[gcd(x,y)=1]
\end{aligned}
$$

熟悉多了。

我们设 $f(x)=\sum\limits_{i=1}^n\sum\limits_{j=1}^m\lfloor\frac{n}{i}\rfloor\lfloor\frac{m}{j}\rfloor[gcd(i,j)=x]$

$F(x)=\sum\limits_{x|d}f(d)$。

代入莫反公式：

$$f(x)=\sum_{x|d}\mu(\frac{d}{x})F(d)$$

由 $f(x)$ 的定义可以知道我们要求的是 $f(1)$

$$f(1)=\sum_{i=1}^n\mu(i)F(i)$$

现在我们要想办法求 $F(i)$

从定义出发可以知道：
$$
\begin{aligned}
F(x)
&=\sum_{i=1}^n\sum_{j=1}^m\lfloor\frac{n}{i}\rfloor\lfloor\frac{m}{j}\rfloor[x|gcd(i,j)]\\
&=\sum_{i=1}^{n/x}\sum_{j=1}^{m/x}\lfloor\frac{n}{ix}\rfloor\lfloor\frac{m}{jx}\rfloor\\
&=\sum_{i=1}^{n/x}\lfloor\frac{n}{ix}\rfloor\sum_{j=1}^{m/x}\lfloor\frac{m}{jx}\rfloor
\end{aligned}
$$

下面我们单独提出一个函数 $h(x)=\sum\limits_{i=1}^{x}\lfloor\frac{x}{i}\rfloor$，发现这个东西能够数论分块 $O(\sqrt{n})$。

$$\therefore F(x)=h(\frac{n}{x})\cdot h(\frac{m}{x})$$

结合求解式子 $ans=\sum\limits_{i=1}^n\mu(i)F(i)$

总复杂度 $O(T\sqrt n)$

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

const int N=5e4+10;
int pr[N],tot=0,mu[N],sum[N];
bool mp[N];
ll h[N];

int get(int k,int x)//整除分块结论
{
	return k/(k/x);
}

void init(int n)
{
	mu[1]=1;
	for(int i=2;i<=n;i++)
	{
		if(!mp[i]) mu[i]=-1,pr[++tot]=i;
		for(int j=1;pr[j]*i<=n;j++)
		{
			int tmp=pr[j]*i;
			mp[tmp]=1;
			if(i%pr[j]==0) break;
			mu[tmp]=-mu[i];

		}
	}
	for(int i=1;i<=n;i++)
		sum[i]=sum[i-1]+mu[i];

	for(int i=1;i<=n;i++)//预处理h(x)
	{
		for(int l=1,r;l<=i;l=r+1)
		{
			r=min(i,get(i,l));
			h[i]+=(r-l+1)*(i/l);
		}
	}
}

int main()
{
	init(N-10);//预处理h(x),mu(x)
	int t;
	scanf("%d",&t);
	while(t--)
	{
		int n,m;
		scanf("%d%d",&n,&m);
		ll res=0;
		int nn=min(n,m);
		for(int l=1,r;l<=nn;l=r+1)
		{
			r=min(nn,min(get(n,l),get(m,l)));
			res+=(ll)(sum[r]-sum[l-1])*h[n/l]*h[m/l];
		}
		printf("%lld\n",res);
	}
	return 0;
}
```


---

## 作者：Vidoliga (赞：0)

## 本题求 $\sum\limits_{i=1}^n$ $\sum\limits_{i=1}^md(ij)$


------------

这里涉及到一个公式：

### $d(ij)=$ $\sum\limits_{x|i}$ $\sum\limits_{y|j}$ [$gcd(x,y)=1$]

于是便可以转化为求

### $\sum\limits_{i=1}^n$ $\sum\limits_{j=1}^m$ $\sum\limits_{x|i}$ $\sum\limits_{y|j}$ [$gcd(x,y)=1$]

交换和符$QwQ$

### $\sum\limits_{i=1}^n$ $\sum\limits_{j=1}^m$ [$\frac{n}{i}$] [$\frac{m}{j}$] [$gcd(i,j)=1$]

### 这时就要为莫比乌斯反演做铺垫！

设 
 $f(x)=$ $\sum\limits_{i=1}^n$ $\sum\limits_{j=1}^m$ [$\frac{n}{i}$] [$\frac{m}{j}$] [$gcd(i,j)=x$]

设
$F(x)=$ $\sum\limits_{x|d}f(d)$

这时就有

#### $F(x)$ $=$ $\sum\limits_{i=1}^n$ $\sum\limits_{j=1}^m$ [$\frac{n}{i}$] [$\frac{m}{j}$] [$x|gcd(i,j)$]

#### $\Rightarrow$ $F(x)$ $=$ $\sum\limits_{i=1}^\frac{n}{x}$ $\sum\limits_{j=1}^\frac{m}{x}$ [$\frac{n}{ix}$] [$\frac{m}{jx}$]

#### $\Rightarrow$ $F(x)$ $=$ $\sum\limits_{i=1}^\frac{n}{x}$ [$\frac{n}{ix}$] $ \sum\limits_{j=1}^\frac{m}{x}$ [$\frac{m}{jx}$]

## 接下来就可以套公式愉快的反演了

由公式
## 当$f(x)=$ $\sum\limits_{d|x}g(d)$
必有
## $g(x)=$ $\sum\limits_{d|x}\mu$ $(\frac{x}{d})$ $f(d)$

回到前面的式子 $,$
我们有

#### $f(n)=$ $\sum\limits_{d|n}\mu$ $(\frac{d}{n})$ $F(d)$

回到$f(x)$的定义$,$
题目要求的是
$f(1)$

### 而
$f(1)=$ $\sum\limits_{d|1}\mu$ $(\frac{d}{1})$ $F(d)$

$\Rightarrow$ $f(1)=$ $\sum\limits_{i=1}^n\mu$ $(i)$ $F(i)$

这下就做完了 $QwQ$

本蒟蒻代码 $QwQ$


```cpp

#include<iostream>
#include<cstring>
#include<cmath>
#include<cstdio>
using namespace std;
const int N = 5e4+5;
int coot=0,prime[N],mu[N];
long long die[N];
inline int read(){
	int d=0,f=1;
	char x=getchar();
	while(x<'0'||x>'9'){
		if(x=='-'){
			f=-1;
		}x=getchar();
	}
	while(x>='0'&&x<='9'){
		d=(d<<1)+(d<<3)+(x-48);
		x=getchar();
	}
	return d*f; 
}
bool fi[N];
void init(){
	mu[1]=1;
	for(int i = 2;i <= 50000;i++){
		if(!fi[i])
			prime[++coot]=i,mu[i]=-1;
		for(int j = 1;j <= coot&&(long long)i*prime[j]<N;j++){
			int k= i*prime[j];
			fi[k]=true;
			if(i%prime[j]==0){
				mu[k]=0;
				break;	
			}else{
				mu[k]=-mu[i];
			} 
		}
	}
	for(int m = 2;m <= 50000;m++)
		mu[m] += mu[m-1];
	for(int i =1;i<N;i++){
		long long ans=0;
		for(int left = 1;left<=i;){
			int right=i/(i/left);
			ans+=(long long)(right-left+1)*(i/left); 
			die[i]=ans;
			left=right+1;
		}
	}
} 
void qwq(int t){
	init();
	while(t){
		int n=read(),m=read();
		if(n>m)swap(n,m);
		long long ans=0;
		for(int left = 1;left<=n;){
			int right = min((n/(n/left)),(m/(m/left)));
			ans+=(long long)(mu[right]-mu[left-1])*(die[n/left]*die[m/left]);
			left=right+1; 
		} printf("%lld\n",ans);
		t--;
	}
}
int main(){
	int t;
	scanf("%d",&t);
	qwq(t);
	return 0;
}
```
# 本题解摘自本人的另一个号的$blog$的题解

$from:$[$blog$](https://www.luogu.com.cn/blog/gf2020daihengfei/solution-p3327)

---

## 作者：Dorbmon (赞：0)

这里的题解好像都没解释为啥会出现能够分块的情况2333.把我看懵逼了好久。
因为我们有这个公式

![floor函数的性质](https://www.zhihu.com/equation?tex=%5Cforall+n%5Cin%5Cmathbb+Z%2C%5Cforall+x%5Cin%5Cmathbb+R%5E%2B%2C%5Clfloor+%5Cfrac%7B%5Clfloor+x%5Crfloor%7Dn%5Crfloor%3D%5Clfloor%5Cfrac+xn%5Crfloor)

所以可以转换成普通的整数分块，下面是我的代码

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
#define re register
const ll MAXN = 50005;
ll phi [MAXN+10],mu [MAXN+10];
ll prime [MAXN+10],cnt;
bool vis [MAXN+10];
ll fuck [MAXN];
ll f [MAXN];
inline void prepare (ll n) {
	mu [1] = 1;
	for (re ll i = 2;i <= n;++ i) {
		if (!vis [i]) {
			prime [++ cnt] = i;
			mu [i] = -1;
		}
		for (re ll j = 1;j <= cnt && i * prime [j] <= n;++ j) {
			vis [i * prime [j]] = 1;
			if (i%prime[j]==0) {
				break;
          	} else  {
				mu [i * prime [j]] = -mu [i];
			}
		}
	}
	for (int i = 1;i <= n;++ i) {
		mu [i] += mu [i - 1];
	}
	for (int i = 1;i <= n;++ i) {
		for (int j = 1,k;j <= i;j = k + 1) {
			k = i / (i / j);
			fuck [i] += (k - j + 1) * (i / j);
		}
	}
}

int main () {
#ifndef ONLINE_JUDGE
	freopen ("shit.txt","r",stdin);
#endif
	ios::sync_with_stdio (false);
	prepare (MAXN);
	int T;cin >> T;
	while (T -- ) {
		ll n,m;cin >> n >> m;
		ll ans = 0;
		for (int i = 1,j;i <= min (n,m);i = j + 1) {
			j = min (n / (n / i),m / (m / i));
			ans += (mu [j] - mu [i - 1]) * fuck [n/i] * fuck [m/i];
		}
		cout << ans << endl;
	}
	return 0;
}
```


---

## 作者：Ken_He (赞：0)

**Description**:


共$T \le 5 \times 10^4$组询问, 每组询问给定$n$和$m$, 请你求出

$$
\sum\_{i = 1}^n \sum\_{j = 1}^m \sigma\_0 (ij)

$$
**Solution**:


先给出一个结论:

$$
\sigma\_0(ij) = \sum\_{a | i} \sum\_{b | j} [\gcd(a, b) = 1]
$$
证明: 我们令$i = p_1^{a_1} p_2^{a_2} \cdots$, $j = p_1^{b_1} p_2^{b_2} \cdots$, $d | ij$且$d = p_1^{c_1} p_2^{c_2} \cdots$, 则$c_n \le a_n + b_n$.


考虑如何不重复地统计每一个$d$: 令$c_n = A_n + B_n$, 其中$A_n$和$B_n$分别为$i$和$j$对$c_n$的贡献, 则我们要求

$$
```cpp
\begin{cases} 
B_n = 0 & A_n < a_n \\
B_n \ge 0 & A_n = a_n
\end{cases}
```
$$
这样一来, $c_n$的表示形式就变成唯一的了, 因而不会被重复统计. 我们再考虑如何统计这样的$A_n$和$B_n$: 我们令$A_n' = a_n - A_n$, 则约束条件变为

$$
```cpp
\begin{cases}
B_n = 0 & A_n' \ne 0 \\
B_n \ge 0 & A_n' = 0
\end{cases}
```
$$
等价于$\gcd(A_n', B_n) = 1$.


因此得证.


好吧, 假如看不懂上面的这一些证明, 就这么想吧: $i$表示$a$中不取多少, $j$表示$b$中取多少, 只要保证$\gce(a, b) = 1$, 即不会重复统计.


因此我们考虑原题的式子

$$
```cpp
\begin{aligned}
\sum_{i = 1}^n \sum_{j = 1}^m \sigma_0(ij) &= \sum_{i = 1}^n \sum_{j = 1}^m \sum_{a | i} \sum_{b | j} [\gcd(a, b) = 1] \\
&= \sum_{i = 1}^n \sum_{j = 1}^m \sum_{a | i} \sum_{b | j} \sum_{d | \gcd(a, b)} \mu(d) \\
&= \sum_{i = 1}^n \sum_{j = 1}^m \sum_{d | \gcd(i, j)} \mu(d) \sigma_0(\frac i d) \sigma_0(\frac j d) \\
&= \sum_{d = 1}^n \sum_{i = 1}^{\lfloor \frac n d \rfloor} \sum_{j = 1}^{\lfloor \frac m d \rfloor} \mu(d) \sigma_0(i) \sigma_1(j) \\
&= \sum_{d = 1}^n \mu(d) \sum_{i = 1}^{\lfloor \frac n d \rfloor} \sigma_0(i) \sum_{j = 1}^{\lfloor \frac m d \rfloor} \sigma_0(j)
\end{aligned}
```
$$
分块处理后半部分即可.


时间复杂度: 预处理$O(n)$, 单次询问$O(n^\frac 1 2)$


```cpp
#include <cstdio>
#include <cctype>
#include <cstring>
#include <algorithm>

using namespace std;
namespace Zeonfai
{
    inline int getInt()
    {
        int a = 0, sgn = 1; char c;
        while (! isdigit(c = getchar())) if (c == '-') sgn *= -1;
        while (isdigit(c)) a = a * 10 + c - '0', c = getchar();
        return a * sgn;
    }
}
const int N = (int)5e4, MOD = (int)1e9;
typedef int arr[N + 7];
typedef long long Larr[N + 7];
int tot;
arr isNotPrime, prm, mu, minDivisor, minDivisorDegree, sgm;
Larr a, b, c;
inline void initialize()
{
    memset(isNotPrime, 0, sizeof(isNotPrime));
    tot = 0;
    sgm[1] = mu[1] = 1;
    for (int i = 2; i <= N; ++ i)
    {
        if (! isNotPrime[i])
        {
            prm[tot ++] = i;
            mu[i] = -1;
            minDivisor[i] = i;
            minDivisorDegree[i] = 1;
            sgm[i] = 2;
        }
        for (int j = 0; j < tot && i * prm[j] <= N; ++ j)
        {
            int x = i * prm[j]; isNotPrime[x] = 1;
            if (i % prm[j])
            {
                mu[x] = - mu[i];
                minDivisor[x] = prm[j];
                minDivisorDegree[x] = 1;
                sgm[x] = sgm[i] * 2;
            }
            else
            {
                mu[x] = 0;
                minDivisor[x] = minDivisor[i] * prm[j];
                minDivisorDegree[x] = minDivisorDegree[i] + 1;
                sgm[x] = sgm[i / minDivisor[i]] * (minDivisorDegree[x] + 1);
            }
        }
    }
    a[0] = b[0] = c[0] = 0;
    for (int i = 1; i <= N; ++ i) a[i] = a[i - 1] + sgm[i], b[i] = a[i] * a[i], c[i] = c[i - 1] + mu[i];
}
int main()
{
    using namespace Zeonfai;
    initialize();
    int T = getInt();
    for (int cs = 0; cs < T; ++ cs)
    {
        int n = getInt(), m = getInt();
        long long ans = 0;
        int L = 1;
        while (L <= min(n, m))
        {
            int R = min(n / (n / L), m / (m / L));
            ans = ans + a[n / L] * a[m / L] * (c[R] - c[L - 1]);
            L = R + 1;
        }
        printf("%lld\n", ans);
    }
}
```


---


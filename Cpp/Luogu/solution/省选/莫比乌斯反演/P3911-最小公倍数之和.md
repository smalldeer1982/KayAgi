# 最小公倍数之和

## 题目描述

对于$A_1,A_2,\cdots,A_N$，求

$\sum_{i=1}^N\sum_{j=1}^N \mathrm{lcm}(A_i,A_j)$

的值。

$\mathrm{lcm}(a,b)$ 表示 $a$ 和 $b$ 的最小公倍数。


## 说明/提示

对于 $30\%$ 的数据，$1 \le N \le 1000$，$1 \le A_i \le 5\times 10^4$。

对于另外 $30\%$ 的数据，$1 \le N \le 5\times 10^4$，$1 \le A_i \le 1000$。

对于 $100\%$ 的数据，$1 \le N \le 5\times 10^4$，$1 \le A_i \le 5\times 10^4$。


## 样例 #1

### 输入

```
2
2 3```

### 输出

```
17```

# 题解

## 作者：chihik (赞：21)

~~简单问题复杂化是解决问题的一个好方法。~~

令 $c_i$ 表示 $i$ 出现的次数，$n$ 为最大数字。

$$\sum_{i=1}^n \sum_{j=1}^nc_i  \times c_j \times lcm(i,j)$$

$$\sum_{i=1}^n \sum_{j=1}^nc_i  \times c_j \times \frac{i \times j}{gcd(i,j)}$$

$$\sum_{k=1}^n\sum_{i=1}^n \sum_{j=1}^n [gcd(i,j)=k] c_i  \times c_j \times \frac{i \times j}{k}$$

$$\sum_{k=1}^n\sum_{i=1}^{\lfloor \frac{n}{k} \rfloor } \sum_{j=1}^{\lfloor \frac{n}{k} \rfloor} [gcd(i,j)=1] c_{ik}  \times c_{jk} \times i \times j \times k$$

$$\sum_{k=1}^n\sum_{i=1}^{\lfloor \frac{n}{k} \rfloor } \sum_{j=1}^{\lfloor \frac{n}{k} \rfloor} \sum_{d|gcd(i,j)}\mu(d) \times c_{ik}  \times c_{jk} \times i \times j \times k$$

$$\sum_{k=1}^n\sum_{d=1}^{\lfloor \frac{n}{k} \rfloor} \mu(d) \times d^2 \sum_{i=1}^{\lfloor \frac{n}{kd} \rfloor } \sum_{j=1}^{\lfloor \frac{n}{kd} \rfloor}  c_{ikd}  \times c_{jkd} \times i \times j \times k$$

$$\sum_{k=1}^n\sum_{kd=1}^{n}\mu(d) \times d^2\sum_{i=1}^{\lfloor \frac{n}{kd} \rfloor } \sum_{j=1}^{\lfloor \frac{n}{kd} \rfloor} c_{ikd}  \times c_{jkd} \times i \times j \times k$$

$$\sum_{T=1}^n T(\sum_{d|T}\mu(d) \times d )\sum_{i=1}^{\lfloor \frac{n}{T} \rfloor } \sum_{j=1}^{\lfloor \frac{n}{T} \rfloor} c_{iT}  \times c_{jT} \times i \times j$$

$$\sum_{T=1}^n T(\sum_{d|T}\mu(d) \times d ) (\sum_{i=1}^{\lfloor \frac{n}{T} \rfloor } c_{iT} \times i)^2$$

第一个括号预处理，第二个括号直接暴力算。

预处理和查询复杂度均为 $\Theta(n \ln n)$。

```cpp
#include <cstdio>
#include <iostream>
using namespace std;

const int MAXN = 5e4;
int n , m , k , cnt[ MAXN + 5 ] , prime[ MAXN + 5 ] , mu[ MAXN + 5 ];
long long Ans , f[ MAXN + 5 ];
bool vis[ MAXN + 5 ];

void sieve( ) {
	mu[ 1 ] = 1;
	for( int i = 2 ; i <= MAXN ; i ++ ) {
		if( !vis[ i ] ) {
			prime[ ++ k ] = i;
			mu[ i ] = -1;
		}
		for( int j = 1 ; j <= k && i * prime[ j ] <= MAXN ; j ++ ) {
			vis[ i * prime[ j ] ] = 1;
			if( i % prime[ j ] == 0 ) break;
			mu[ i * prime[ j ] ] = -mu[ i ];
		}
	}
    for( int i = 1 ; i <= MAXN ; i ++ )
        for( int j = i ; j <= MAXN ; j += i )
            f[ j ] += i * mu[ i ];
}

int main( ) {
	sieve( );
	scanf("%d",&n);
	for( int i = 1 , x ; i <= n ; i ++ )
		scanf("%d",&x) , cnt[ x ] ++ , m = max( m , x );
	n = m;

    for( int i = 1 ; i <= n ; i ++ ) {
        long long tmp = 0;
        for( int j = 1 ; j <= n / i ; j ++ )
            tmp += 1ll * cnt[ i * j ] * j;
        Ans += i * f[ i ] * tmp * tmp;
    }
    printf("%lld", Ans );
	return 0;
}
```


---

## 作者：_louhc (赞：14)

我们先用c数组预处理出每个数出现的次数,那么原问题变为求解
$$\sum_{i=1}^n\sum_{j=1}^n lcm(i,j)\times c_i \times c_j$$
其中n表示最大的数。

然后？莫比乌斯反演来一发

为了避免麻烦,这里先使$T=kd$



LaTeX炸了？备份一份源码。先用图片代替。
![](https://cdn.luogu.com.cn/upload/pic/56545.png)
```latex
\begin{aligned}
& \sum_{i=1}^n\sum_{j=1}^n lcm(i,j)\times c_i \times c_j\\
=& \sum_{i=1}^n\sum_{j=1}^n \frac{i \times j\times c_i \times c_j}{\gcd(i,j)} \\ 
=& \sum_{d=1}^n\sum_{i=1}^{\lfloor n/d \rfloor}\sum_{j=1}^{\lfloor n/d \rfloor}[\gcd(i,j)=1]d\times i \times j \times c_{id} \times c_{jd} \\
=& \sum_{d=1}^n\sum_{i=1}^{\lfloor n/d \rfloor}\sum_{j=1}^{\lfloor n/d \rfloor}\sum_{k|\gcd(i,j)}\mu(k) \times d\times i \times j \times c_{id} \times c_{jd} \\
=& \sum_{d=1}^n\sum_{k=1}^{\lfloor n/d\rfloor}\sum_{i=1}^{\lfloor n/kd\rfloor}\sum_{j=1}^{\lfloor n/kd\rfloor}\mu(k)\times d \times i \times j \times k^2 \times c_{idk} \times c_{jdk} \\
=& \sum_{T=1}^{n}T\times(\sum_{i=1}^{\lfloor n/T \rfloor}i\times c_{iT})^2\sum_{k|T}\mu(k)\times k
\end{aligned}
```
看起来十分可怕,其实都是莫比乌斯反演题的基本操作。

然后就可以开心地预处理出$\sum_{k|T}\mu(k)\times k$,暴力求解啦！

这样的复杂度为$O(\sum^n_{i=1}\frac ni)$,即$O(n \ln n)$,可以轻松过此题。

# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define LL long long
#define MAXN 50005
#define rgt register

int N, M, cnt[MAXN], mu[MAXN], p[MAXN], tot, v[MAXN];
LL s[MAXN];
LL ans(0);

int main(){
	scanf( "%d", &N ); for ( rgt int i = 1, x; i <= N; ++i ) scanf( "%d", &x ), ++cnt[x], M = max( M, x );
	N = M, mu[1] = 1;
	for ( rgt int i = 2; i <= N; ++i ){//线性筛出mu
		if ( !v[i] ) p[++tot] = i, mu[i] = -1;
		for ( rgt int j = 1; j <= tot && i * p[j] <= N; ++j ){
			v[i * p[j]] = 1;
			if ( i % p[j] == 0 ){ mu[i * p[j]] = 0; break; }
			else mu[i * p[j]] = -mu[i];
		}
	}
	
	for ( rgt int i = 1; i <= N; ++i )
		for ( rgt int j = i; j <= N; j += i )
			s[j] += 1ll * mu[i] * i;//预处理提到过的那玩意
	
	for ( rgt int T = 1; T <= N; ++T ){
		rgt LL cur(0);
		for ( rgt int i = 1, I = N / T; i <= I; ++i ) cur += 1ll * cnt[i * T] * i;//暴力求解
		ans += T * cur * cur * s[T];
	} printf( "%lld\n", ans );
	return 0;
}
```



---

## 作者：HoshizoraZ (赞：10)

### 提供一种不需要求莫比乌斯**函数**的算法。

----

首先 $A_i,A_j$ 的最小公倍数可以化为 $\frac{A_i \cdot A_j}{\gcd(A_i,A_j)}$。

接下来就是较常见的推导过程，**以下过程整个序列 $A$ 最大值记为 $N$**。

我们发现 $A_i,A_j$ 的最大公约数会随着 $A_i,A_j$ 的变化而变化，不好求出。

所以可以**提前枚举**最大公约数 $d$，在两两枚举的时候只找 $\gcd(A_i,A_j)=d$ 的数对并进行计算，式子写作

$$\sum_{d=1}^N\sum_{i=1}^n\sum_{j=1}^n[\gcd(A_i,A_j)=d]\frac{A_i \cdot A_j}{d}$$

然后 $\frac{1}{d}$ 可以提到前面去。

但是 $A_i$ 是输入得到的，因此 $[\gcd(A_i,A_j)=d]$ 这个条件不好使用，所以需要换一种方式记录。

我们令数字 $i$ 在原序列的出现次数为 $s_i$，那么所求为

$$\sum_{d=1}^N\frac{1}{d}\sum_{i=1}^N\sum_{j=1}^N[\gcd(i,j)=d]\cdot s_i \cdot s_j \cdot i \cdot j$$

这一步推导使得 $i,j$ 变成枚举值域，因为相同的数对显然最大公约数一样，所以一起处理不会有所影响。

然后发现式子里的 $s_i$ 都伴随 $i$ 出现，因此可以令 $c_i=s_i \cdot i$，式子写成

$$\sum_{d=1}^N\frac{1}{d}\sum_{i=1}^N\sum_{j=1}^N[\gcd(i,j)=d]\cdot c_i \cdot c_j$$

---------

把式子的后半部分单独拿出来看，令

$$f(d)=\sum_{i=1}^N\sum_{j=1}^N[\gcd(i,j)=d]\cdot c_i \cdot c_j$$

那么所求就变成 $\sum\limits_{d=1}^Nf(d)$ 了。

现在最难处理的，无非是 $\gcd(i,j)=d$ 这个条件。

但是我们先降低点难度。**如果条件变成 $d \mid \gcd(i,j)$，答案怎么求？**

显然，若 $\gcd(i,j)$ 为 $d$ 的倍数，那么 $i,j$ 都要是 $d$ 的倍数。

那么我们在枚举 $i,j$ 的时候就强制它只能取 $d$ 的倍数，$d \mid \gcd(i,j)$ 的条件就能消除了。

然后再返回来，如何求 $\gcd(i,j)=d$ 条件的情况？

可以发现，如果 $d \mid \gcd(i,j)$，那么 $i,j$ 可以取到 $d,2d,3d,...$

相当于 $d \mid \gcd(i,j)$ 是所有满足 $\gcd(i,j)=kd$（$k$ 取任意正整数）条件的 $i,j$ 的答案。

为了描述方便，我们设

$$g(d)=\sum_{i=1}^N\sum_{j=1}^N[d \mid \gcd(i,j)]\cdot c_i \cdot c_j$$

那么有 $g(d)=\sum\limits_{k \mid x}f(x)$，即 $g(d)=
\sum\limits_{k=1}^{\lfloor\frac{N}{d}\rfloor}f(kd)$。

到这里很多人就直接上**莫比乌斯反演**了，其实有更简单的办法。

将右式拆成 $g(d)=
f(d)+\sum\limits_{k=2}^{\lfloor\frac{N}{d}\rfloor}f(kd)$。

移项一下，就可以得到

$$f(d)=g(d)-\sum_{k=2}^{\lfloor\frac{N}{d}\rfloor}f(kd)$$

---------------

由于对于每个 $d$，除了 $g$ 函数我们只需要计算 $\lfloor\frac{N}{d}\rfloor$ 次就可以求出 $f(d)$。

而 $\sum\limits_{k=1}^N\lfloor\frac{N}{k}\rfloor$ 的规模是在 $\mathcal{O}(N \ln N)$ 级别的，因此我们只需要尽可能在优秀的时间复杂度**求出所有 $g$ 函数**，问题就解决了。

根据上文得到的结果：

$$g(d)=\sum_{i=1}^N\sum_{j=1}^N[d \mid \gcd(i,j)]\cdot c_i \cdot c_j$$

我们将函数 $g(d)$ 重新写成原来以 $A_i,A_j$ 表示的形式。观察一下：

$$g(d)=\sum_{j=1}^n \sum_{j=1}^n[d \mid \gcd(A_i,A_j)] \cdot A_i \cdot A_j$$

同样的，根据上文，如果枚举的 $A_i,A_j$ 都是 $d$ 的倍数，那么条件就可以消除。

然后你就可以发现 $g(d)$ 就是序列 $A$ 中任意两个为 $d$ 倍数的数，其**两两乘积之和**。

因此，可以根据每个不同的 $d$，**预处理**序列 $A$ 中所有 $d$ 的倍数之和 $S_d$，就有 $g(d)=S_d^2$。 

至于序列 $A$ 中所有 $d$ 的倍数之和，我们可以先枚举 $d$，再枚举 $d$ 的倍数 $k$，累加所有 $k$ 的答案。这样算时间复杂度同样是 $\mathcal{O}(N \ln N)$ 的。

-------

最终带回原式

$$\sum_{d=1}^N\frac{1}{d} \cdot \left(g(d)-\sum_{k=2}^{\lfloor\frac{N}{d}\rfloor}f(kd)\right)$$

先预处理 $g$ 函数，再**倒序枚举** $d$，因为你需要调用 $f(kd)$。

之后算一下上面这个式子，这题就做完了，总时间复杂度 $\mathcal{O}(N \ln N)$。

贴上代码：

```cpp
#include <bits/stdc++.h>
#define INF 1e9
#define eps 1e-6
#define N 50000
typedef long long ll;
using namespace std;

int n;
ll s[100010], f[100010], d[100010], ans;
// d[i] 记录序列 A 中 i 的倍数之和，s[i] 记录序列 A 中等于 i 的数之和

int main(){

	scanf("%d", &n);
	for(int i = 1, a; i <= n; i++)
		scanf("%d", &a), s[a]++;
	for(int i = 1; i <= N; i++)
		s[i] *= i;
	for(int i = 1; i <= N; i++)
		for(int j = i; j <= N; j += i)
			d[i] += s[j];
	for(int i = N; i >= 1; i--){
		f[i] = d[i] * d[i];
		for(int j = i + i; j <= N; j += i)
			f[i] -= f[j];
		ans += f[i] / i;
	}
	printf("%lld\n", ans);

	return 0;
}
```

---

## 作者：湛卢 (赞：9)

然而本蒟蒻并不会dp莫反就只能莽了QAQ……
每次加进新数字时统计该数字与前面所有数的lcm,
又因为lcm(a,b)=a*b/gcd(a,b),
并且gcd是新加数字的因数,
所以我们枚举因数作为gcd,
再统计已加入数字与新数gcd等于该因数的数的和,
用和乘以新数字除以该因数来统计lcm。
因数可以枚举(要先处理50000内每个数的最小质因数)，
用容斥原理求和。
```cpp
#include<bits/stdc++.h>
#define ll long long
#define N 50000
#define Re register
inline ll readln() 
{
    char cc=getchar();
    ll f=1,num=0;
    while (cc<'0'||cc>'9') {if(cc=='-') f=-1; cc = getchar();}
    while (cc>='0'&&cc<='9') num=(num<<1)+(num<<3)+(cc^48),cc=getchar();
    return num*f;
}
int Min[N*2],ys[N*2],gs[N*2],vis[N*2],num,n,tot; ll tot_ans,anser,f[N*2],sum;
inline void ready()//可以打线性筛，但根号效率可过 
{
	for (Re int i=2;i<=N;i++)
	{
		int k=sqrt(i);
		for (int j=2;j<=k;j++) if (i%j==0) {Min[i]=j; break;}
		if (!Min[i]) Min[i]=i;
	}
}
inline void pre(ll x)//质因数拆分 gs=个数，ys=因数 对应 
{
	ll tmp=x; tot=0;
	while (tmp>1)
	{
		ys[++tot]=Min[tmp]; gs[tot]=0;
		while (tmp>1&&tmp%ys[tot]==0) 
			tmp/=ys[tot],gs[tot]++;
	}
}
inline ll ask(ll x,int fh,int plc)//容斥原理求和 
{
	ll ans=1ll*fh*f[x];
	for (Re int i=plc;i<=tot;i++)
		if (gs[i]&&!vis[i]) vis[i]=1,ans+=ask(x*ys[i],fh*(-1),i),vis[i]=0;//注意容斥时单个因数只用一次 
	return ans;
}
inline ll done(ll x,int plc,ll aim) //枚举因数x 
{
	ll ans=ask(x,1,1)*aim/x;//求gcd等于x的数的和 
	for (Re int i=plc;i<=tot;i++)
		if (gs[i]) gs[i]--,ans+=done(x*ys[i],i,aim),gs[i]++;
	return ans;
}
inline void add(ll x,int plc,ll aim)
{
	f[x]+=aim;
	for (Re int i=plc;i<=tot;i++)
		if (gs[i]) gs[i]--,add(x*ys[i],i,aim),gs[i]++;
}
int main()
{
	scanf("%d",&n); ready();
	for (Re int i=1;i<=n;i++)
	{
		ll a=readln(); pre(a); sum+=a;
		anser+=done(1,1,a); add(1,1,a);
	}
	printf("%lld\n",anser*2+sum); //因为以上求得每个数与前数字lcm还要*2+sum 
}
```


---

## 作者：zjjws (赞：7)

给定长度为 $N$ 的序列 $A$，求：

$$\sum_{i=1}^N\sum_{j=1}^N\operatorname {lcm}(A_i,A_j)$$

利用小学知识可以化成：

$$\sum_{i=1}^N\sum_{j=1}^N\frac{A_i\times A_j}{\gcd(A_i,A_j)}$$

考虑到 $A_i\le5\times 10^4$。

开一个桶 $a$，$a_i=\sum_{j=1}^N[A_j=i]$。

设 $n$ 为 $\max_{A_i},i\in[1,N]$。

原式子就可以化成：

$$\sum_{i=1}^n\sum_{j=1}^n a_i\times a_j\times \frac{i\times j}{\gcd(i,j)}$$

$$=\sum_{d=1}^n d\times \sum_{i=1}^{\left\lfloor \frac{n}{d} \right\rfloor}\sum_{j=1}^{\left\lfloor \frac{n}{d} \right\rfloor} a_{i\times d}\times a_{j\times d}\times i\times j\times [\gcd(i,j)=1]$$

$$=\sum_{d=1}^n d\times \sum_{i=1}^{\left\lfloor \frac{n}{d} \right\rfloor}\sum_{j=1}^{\left\lfloor \frac{n}{d} \right\rfloor} a_{i\times d}\times a_{j\times d}\times i\times j\times \sum_{p|\gcd(i,j)}\mu(p)$$

$$=\sum_{d=1}^n d\times \sum_{p=1}^{\left\lfloor \frac{n}{d} \right\rfloor}\mu(p)\times p^2 \times \sum_{i=1}^{\left\lfloor \frac{n}{dp} \right\rfloor} \sum_{j=1}^{\left\lfloor \frac{n}{dp} \right\rfloor}a_{i\times d\times p}\times a_{j\times d\times p}\times i\times j$$

在去掉 $a_{i\times d\times p}\times a_{j\times d\times p}$ 的时候， $\sum_{i=1}^{\left\lfloor \frac{n}{dp} \right\rfloor} \sum_{j=1}^{\left\lfloor \frac{n}{dp} \right\rfloor}i\times j$ 是可以 $\operatorname O(1)$ 运算出来的，可以实现 $\operatorname O(n\sqrt n)$，即 $d$ 这一层直接枚举，然后 $p$ 这一层用整除分块优化。

那么这个 $a$ 该怎么考虑呢？

提取 $d\times p$，化为：

$$\sum_{T=1}^nT\times \sum_{p|T}\mu(p)\times p\times \sum_{i=1}^{\left\lfloor \frac{n}{T} \right\rfloor} \sum_{j=1}^{\left\lfloor \frac{n}{T} \right\rfloor}a_{i\times T}\times a_{j\times T}\times i\times j$$

设 

$$s_i=i\times \sum_{p|i}\mu(p)\times p$$

这个 $s$ 是可以预处理的东西。

原式可化为：

$$\sum_{T=1}^ns_T\times \sum_{i=1}^{\left\lfloor \frac{n}{T} \right\rfloor} \sum_{j=1}^{\left\lfloor \frac{n}{T} \right\rfloor}a_{i\times T}\times a_{j\times T}\times i\times j$$

把 $i$ 提到自己那一层：

$$\sum_{T=1}^n s_T\times \sum_{i=1}^{\left\lfloor \frac{n}{T} \right\rfloor}a_{i\times T}\times i\times \sum_{j=1}^{\left\lfloor \frac{n}{T} \right\rfloor}a_{j\times T}\times j$$

这里后面两个 $\sum$ 之间并没有联系，实际上可以看成：

$$\sum_{T=1}^n s_T\times (\sum_{i=1}^{\left\lfloor \frac{n}{T} \right\rfloor}a_{i\times T}\times i)\times (\sum_{j=1}^{\left\lfloor \frac{n}{T} \right\rfloor}a_{j\times T}\times j)$$

后面两项是相同的，所以提取公因式，得到：

$$\sum_{T=1}^n s_T\times (\sum_{i=1}^{\left\lfloor \frac{n}{T} \right\rfloor}a_{i\times T}\times i)^2$$

惊喜的发现后面这个也是可以预处理的，两个预处理之后就可以直接枚举 $T$ 求答案了。

虽然看着后面这个东西很像整除分块的式子，但因为内部有一个 $a_{i\times T}$，这个东西下标中含有 $T$，所以并不能整除分块。

实际上从另一个角度理解，就跟 $\left\lfloor \frac{n}{T} \right\rfloor$ 这一项没有关系了。具体的操作，设函数 $g$，满足：

$$g_T=(\sum_{i=1}^{\left\lfloor \frac{n}{T} \right\rfloor}a_{i\times T}\times i)^2$$

$g_T$ 是**所有满足是**  $T$ **的倍数**的数能对它产生贡献。

本身这个复杂度也是能够接受的范围，也不需要去整除分块优化。

~~虽然我算不来这个理论复杂度~~

```cpp
#include <bits/stdc++.h>
#define LL long long
#define max(a,b) a>b?a:b
using namespace std;
const int MAN=5e4;
bool bj[MAN+3];
int mu[MAN+3];
int d[MAN+3];
LL a[MAN+3];
LL s[MAN+3];
LL g[MAN+3];
int tail;
int n,N;
LL rin()
{
    LL s=0;
    char c=getchar();
    bool bj=false;
    for(;(c>'9'||c<'0')&&c!='-';c=getchar());
    if(c=='-')c=getchar(),bj=true;
    for(;c>='0'&&c<='9';c=getchar())s=(s<<1)+(s<<3)+(c^'0');
    if(bj)return -s;
    return s;
}
int main()
{
    N=rin();
    int x;
    for(int i=1;i<=N;i++)
    {
        x=rin();
        a[x]++;
        n=max(n,x);
    }
    
    //第二个东西的预处理
    for(int i=1;i<=n;i++)
    {
        for(int j=1;true;j++)
        {
            int now=i*j;
            if(now>n)break;
            g[i]+=a[now]*j;
        }
        g[i]=g[i]*g[i];
    }
    
    mu[1]=1;
    tail=0;
    for(int i=2;i<=n;i++)
    {
        if(!bj[i])mu[i]=-1,d[++tail]=i;
        for(int j=1;j<=tail;j++)
        {
            int now=i*d[j];
            if(now>n)break;
            bj[now]=true;
            if(i%d[j]==0)break;
            mu[now]=-mu[i];
        }
    }
    //s的预处理
    for(int i=1;i<=n;i++)
    for(int j=1;true;j++)
    {
        int now=i*j;
        if(now>n)break;
        s[now]+=mu[i]*i;
    }
    LL ans=0;
    for(int i=1;i<=n;i++)ans+=s[i]*g[i]*i;
    printf("%lld",ans);
    return 0;
}
```


---

## 作者：金爷爷哈哈 (赞：7)

又是我最喜欢的数论题！！


发现100%的数据中A在50000之内，我们就可以用a[i]来记录A==i的数A有多少个。


然后我们就可以推式子了（我的方法有点鬼畜，接下来写一下我刚刚想起的一个简单的方法。）


首先我们设h[i]为是i倍数的A的两两之积，那么我们可以把是i的倍数的A先加到h[i]中最后让h[i]\*=h[i]就好了。

然后再设g[i]为gcd==i的两两数之积，那么我们可得：


     h[i]=∑g[j]    (i|j)

所以我们可以反演得：


   g[i]=∑μ[j/i]\*h[j]  (i|j)

我们反演得到g之和，最后的答案就是∑g[i]/i  (1<=i<=N),N是所有A中最大的一个。

(我一开始的方式是用所有两数之积再减去gcd不为1的。。。。其实原理都一样)


    
    
    

    
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
#define maxn 50005
ll us[maxn],zs[maxn],t;
bool v[maxn];
ll h[maxn],g[maxn],a[maxn],x,n,N,tot=0;
inline void read(ll&x){
    x=0; char ch=getchar();
    while(!isdigit(ch)) ch=getchar();
    for(;isdigit(ch);ch=getchar())  x=x*10+ch-'0';
}
inline void init(){
    us[1]=1;
    for(int i=2;i<=maxn;i++){
        if(!v[i]) zs[++t]=i,us[i]=-1;
        for(int j=1,u;j<=t&&(u=zs[j]*i)<=maxn;j++){
            v[u]=1;
            if(!(i%zs[j])) break;
            us[u]=-us[i];
        }
    }
}
int main(){
    init();
    read(n);
    for(int i=1;i<=n;i++) read(x),a[x]++,N=max(N,x),tot+=x;
    tot*=tot;
    for(int i=1;i<=N;i++){
      for(int j=i;j<=N;j+=i) if(a[j]) h[i]+=j*a[j];
      h[i]*=h[i];
    }
    for(int i=1;i<=N;i++){
        for(int j=i;j<=N;j+=i) g[i]+=us[j/i]*h[j];
        tot-=g[i]-g[i]/i;
    }
    cout<<tot<<endl;
    return 0;
}
```

---

## 作者：1saunoya (赞：6)

设 $cnt_i$ 为 $i$ 的出现次数。

则这题要求的是 $\sum_{i=1}^{N} \sum_{j=1}^{N} lcm(i, j) \times cnt_i \times cnt_j$

$\left( lcm (i,j) = \frac{ij}{\gcd(i,j)}\right)$

$\sum_{i=1}^{N} \sum_{j=1}^{N} \frac{ij}{\gcd(i,j)} \times cnt_i \times cnt_j$


枚举 $\gcd$。

$\sum_{d=1}^{N} \sum_{i=1}^{N/d} \sum_{j=1}^{N/d} [\gcd(i,j) =1]d\times ij\times cnt_{id} \times cnt_{jd}$

$\sum_{k|n} \mu_k = [n==1]$

$\sum_{d=1}^{N} \sum_{i=1}^{N/d} \sum_{j=1}^{N/d} \sum_{k|\gcd(i,j)}\mu_k \times d\times ij\times cnt_{id} \times cnt_{jd}$

枚举 $k$。

$\sum_{d=1}^{N} \sum_{k=1}^{N/d}\sum_{i=1}^{n/kd}\sum_{j=1}^{n/kd}\mu_k \times d \times k^2 \times i \times j \times cnt_{idk} \times cnt_{jdk}$

$T = dk$。

$\sum_{T=1}^{N} T \times \left(\sum_{i=1}^{N/T} i \times cnt_{iT}\right)^2 \sum_{k|T} \mu_k \times k$

然后就做完了。

---

## 作者：hsfzLZH1 (赞：3)

## 题目大意

给定一个长度为 $n$ 的数列 $A_i$ ，求

$Ans=\sum_{i=1}^n \sum_{j=1}^n lcm(A_i,A_j)$

的值。

$1\le n,A_i\le 50000$

## 解题思路

观察到 $A_i$ 的值特别小。定义 $a_i=\sum_{j=1}^n [a_j=i],m=\max\{a_i\}$ ，$a_i$ 为 $i$ 在 $A$ 中出现的次数， $m$ 为一个值最多出现的次数。

$Ans=\sum_{i=1}^m \sum_{j=1}^m a_ia_j\times lcm(i,j)$

枚举 $gcd$ 的值，由 $gcd(a,b)\times lcm(a,b)=a\times b$ ，得

$Ans=\sum_{d=1}^m \sum_{i=1}^m \sum_{j=1}^m \frac {ija_ia_j}{d} [gcd(i,j)=d]$

提出公约数，得

$Ans=\sum_{d=1}^m \frac 1 d\sum_{i=1}^m\sum_{j=1}^m ija_ia_j[gcd(i,j)=d]$

考虑求后面一部分的式子，令

$f(x)=\sum_{i=1}^m\sum_{j=1}^m ija_ia_j[gcd(i,j)=x]$

构造 $F(x)=\sum_{x|d} f(d)$ ，发现

$F(x)=\sum_{i=1}^m\sum_{j=1}^m ija_ia_j[x|gcd(i,j)]$

$=\sum_{x|i}\sum_{x|j}ija_ia_j$

$=\sum_{x|i}ia_i\times \sum_{x|j} ja_j$

$=(\sum_{x|i}ia_i)^2$

$F(x)$ 可以在 $O(n\ln n)$ 的时间复杂度内预处理。

由反演得，

$f(d)=\sum_{x=1}^{\lfloor \frac m d\rfloor} \mu(x)F(dx)$

带入 $Ans$ ，

$Ans=\sum_{d=1}^m \frac 1 d f(d)$

$=\sum_{d=1}^m \frac 1 d \sum_{g=1}^{\lfloor \frac m d\rfloor} \mu(g)F(gd)$

在预处理出 $F$ 后，我们同样可以在 $O(n\ln n)$ 的时间复杂度内求解这一式子。

总的时间复杂度为 $O(n\ln n)$ 。

## 代码展示

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#define int long long
using namespace std;
const int maxn=50010;
int n,A[maxn],m,a[maxn],f[maxn],ans,tot;
int cur,pri[maxn],mu[maxn];
bool tf[maxn];
main()
{
    scanf("%lld",&n);
    for(int i=1;i<=n;i++)scanf("%lld",A+i),a[A[i]]++,m=50000;
    for(int i=1;i<=m;i++)for(int j=i;j<=m;j+=i)f[i]+=a[j]*j;
    for(int i=1;i<=m;i++)f[i]=f[i]*f[i];
    mu[1]=1;
    for(int i=2;i<=m;i++)
    {
        if(!tf[i]){pri[++cur]=i;mu[i]=-1;}
        for(int j=1;j<=cur&&pri[j]<=m/i;j++)
        {
            tf[i*pri[j]]=true;
            if(i%pri[j]==0){mu[i*pri[j]]=0;break;}
            else mu[i*pri[j]]=-mu[i];
        }
    }
    for(int d=1;d<=m;d++)
    {
        tot=0;
        for(int g=1;g<=m/d;g++)tot+=mu[g]*f[g*d];
        ans+=tot/d;
    }
    printf("%lld\n",ans);
    return 0;
}
```

---

## 作者：bifanwen (赞：2)

[CSDN同步](https://blog.csdn.net/bifanwen/article/details/105935861)

[博客园同步](https://www.cnblogs.com/bifanwen/p/12831569.html)

[洛谷博客同步](https://www.luogu.com.cn/blog/bfw/solution-p3911)

[原题链接](https://www.luogu.com.cn/problem/P3911)

前置知识：

[本题的弱化版](https://www.luogu.com.cn/problem/P3911)

不难发现，原来的：

$$\sum_{i=1}^n \sum_{j=1}^n \operatorname{lcm}(i,j)$$

变成了：

$$\sum_{i=1}^n \sum_{j=1}^n \operatorname{lcm}(a_i , a_j)$$

一言不合就开始推式子。

考虑用 $c_i$ 表示 $i$ 出现的次数，然后：

$$\begin{aligned}
& \sum_{i=1}^n \sum_{j=1}^n \operatorname{lcm}(a_i , a_j) \\
=& \sum_{i=1}^n\sum_{j=1}^n \operatorname{lcm}(i,j)\times c_i \times c_j\\
=& \sum_{i=1}^n\sum_{j=1}^n \frac{i \times j\times c_i \times c_j}{\gcd(i,j)} \\ 
=& \sum_{d=1}^n\sum_{i=1}^{\lfloor  \frac{n}{d} \rfloor}\sum_{j=1}^{\lfloor \frac{n}{d}\rfloor}[\gcd(i,j)=1]d\times i \times j \times c_{id} \times c_{jd} \\
=& \sum_{d=1}^n\sum_{i=1}^{\lfloor \frac{n}{d} \rfloor}\sum_{j=1}^{\lfloor \frac{n}{d}\rfloor}\sum_{k|\gcd(i,j)}\mu(k) \times d\times i \times j \times c_{id} \times c_{jd} \\
=& \sum_{d=1}^n\sum_{k=1}^{\lfloor \frac{n}{d} \rfloor}\sum_{i=1}^{\lfloor \frac{n}{kd} \rfloor}\sum_{j=1}^{\lfloor \frac{n}{kd}\rfloor}\mu(k)\times d \times i \times j \times k^2 \times c_{idk} \times c_{jdk} \\
=& \sum_{T=1}^{n}T\times(\sum_{i=1}^{\lfloor \frac{n}{T} \rfloor}i\times c_{iT})^2\sum_{k|T}\mu(k)\times k
\end{aligned}
$$

对于后面的：

$$\sum_{k|T} \mu_k \times k$$

可以用 $O(n \ln n)$ 的时间完成预处理。

$$n \ln n =\sum_{i=1}^n \lfloor \frac{n}{i} \rfloor$$

然后，对中间那块暴力计算即可。

时间复杂度：$O(n \ln n)$.

实际得分：$100pts$.

```cpp
#pragma GCC optimize(2)
#include<bits/stdc++.h>
using namespace std;

const int N=5e4+1;
typedef long long ll;

inline int read(){char ch=getchar(); int f=1; while(ch<'0' || ch>'9') {if(ch=='-') f=-f; ch=getchar();}
	int x=0; while(ch>='0' && ch<='9') x=(x<<3)+(x<<1)+ch-'0',ch=getchar(); return x*f;}

inline void write(ll x) {
	if(x<0) {putchar('-');write(-x);return;}
	if(x<10) {putchar(char(x%10+'0'));return;}
	write(x/10);putchar(char(x%10+'0'));
}

int n,c[N],mu[N],prime[N];
int cnt=0; bool h[N];
ll s[N],ans=0;

inline void Euler(int n) {
	mu[1]=1; for(register int i=2;i<=n;i++) {
		if(!h[i]) mu[i]=-1,prime[++cnt]=i;
		for(register int j=1;j<=cnt && i*prime[j]<=n;j++) {
			h[i*prime[j]]=1;
			if(i%prime[j]==0) {mu[i*prime[j]]=0;break;}
			mu[i*prime[j]]-=mu[i];
		}
	} 
} 

int main() {
	n=read(); int maxi=0;
	for(register int i=1,t;i<=n;i++) {t=read(); c[t]++; maxi=max(maxi,t);}
	Euler(maxi); for(register int i=1;i<=maxi;i++)
	for(register int j=i;j<=maxi;j+=i) s[j]+=1ll*mu[i]*i; //预处理
	for(register int T=1;T<=maxi;T++) {
		ll sum=0;
		for(register int i=1;i<=maxi/T;i++) sum+=1ll*c[i*T]*i;
		ans+=T*sum*sum*s[T]; //暴力计算
	} write(ans);
	return 0;
}


```

---

## 作者：ArrogHie (赞：1)

## 题意
~~应该没人不识字~~
## 思路
先考虑把解决如何把数列去掉，可以发现一个数 $x$ 出现 $k$ 次，就会对答案产生 $k$ 次贡献，所以我们将题目的式子化成常见的式子 $\sum_{i=1}^{n}\sum_{j=1}^{n}\textit{lcm}(i,j)$ 因为一个数出现 $k$ 次就会对答案产生 $k$ 次贡献，所以我们记录每个数出现的次数 $num_i$ ，再在式子里将其加上得到

$\sum_{i=1}^{n}\sum_{j=1}^{n}\textit{lcm}(i,j)\cdot num_i\cdot num_j$ 

因为 $A_i$ 的最大值只有 $5 \cdot 10^4$ 所以记录下来是可行的

## 开始愉快的化简

根据~~多年的~~做题经验，$\textit{gcd}$ 一般都比 $\textit{lcm}$ 好化简，所以我们先将 $\textit{lcm}$ 化掉， $\textit{lcm}(i,j)=\frac{ij}{\textit{gcd}(i,j)}$ ,于是式子变成了 

$\sum_{i=1}^{n}\sum_{j=1}^{n}\frac{ij}{\textit{gcd}(i,j)}\cdot num_i\cdot num_j$ 

考虑将 $\textit{gcd}$ 化掉，我们设它为 $d$ ，则式子变成 

$\sum_{i=1}^{n}\sum_{j=1}^{n}\frac{ij}{d}\cdot num_i\cdot num_j $

$=\sum_{d=1}^{n} \frac{1}{d} \sum_{i=1}^{n/d}\sum_{j=1}^{n/d}[\textit{gcd}(i,j)=1]id\cdot jd\cdot num_{id}\cdot num_{jd} $

$=\sum_{d=1}^{n} d \sum_{i=1}^{n/d}\sum_{j=1}^{n/d}[\textit{gcd}(i,j)=1]ij\cdot num_{id}\cdot num_{jd}$

接下来考虑化掉 $[\textit{gcd}(i,j)=1]$ ，我们设一个函数 $f$ ，使得

$f(x)=\left\{\begin{matrix}1 &x=1 \\ 0 & x!=1 \end{matrix}\right.$

再设一个函数使得 $f=g\ast 1$ 根据莫比乌斯反演我们得知 $g(n)=\sum_{d|n}\mu (d)f(\frac{n}{d})$ 因为只有 $n=1$ 的时候 $f(n)$ 才等于 $1$ ，所以 $g(n)=\mu (n)$ 所以 $f(n)=\sum_{d|n}\mu (d)$ 于是我们将原式化为

$\sum_{d=1}^{n} d \sum_{i=1}^{n/d}\sum_{j=1}^{n/d}\sum_{k|i,k|j}\mu (k)ij\cdot num_{id}\cdot num_{jd}$

$=\sum_{d=1}^{n} d \sum_{k=1}^{n/d}\mu(k) k^2\sum_{i=1}^{n/kd}\sum_{j=1}^{n/kd}ij\cdot num_{ikd}\cdot num_{jkd}$

$=\sum_{d=1}^{n} d \sum_{k=1}^{n/d}\mu(k) k^2 (\sum_{i=1}^{n/kd}i\cdot num_{ikd})^2$


考虑将 $k,d$ 化为一个数，于是我们设 $T=kd$ 因为 $k\leq n/d$ 所以 $kd\leq n$ 于是将原式化为

$\sum_{T=1}^{n}\sum_{d|T} d\cdot \mu(\frac{T}{d})\cdot  (\frac{T}{d})^2 \cdot (\sum_{i=1}^{n/T}i\cdot num_{iT})^2$ 

$=\sum_{T=1}^{n}\sum_{d|T} T\cdot \mu(\frac{T}{d})\cdot  (\frac{T}{d}) \cdot (\sum_{i=1}^{n/T}i\cdot num_{iT})^2$ 

$=\sum_{T=1}^{n}T\sum_{d|T} \cdot \mu(\frac{T}{d})\cdot  (\frac{T}{d}) \cdot (\sum_{i=1}^{n/T}i\cdot num_{iT})^2$ 


我们把枚举的对象从 $d$ 变成 $x=\frac{T}{d}$ 则原式变成

 $\sum_{T=1}^{n}T \cdot (\sum_{x|T} \cdot \mu(x)\cdot  x) \cdot (\sum_{i=1}^{n/T}i\cdot num_{iT})^2$

于是我们就可以通过预处理出 $\sum_{x|T} \cdot \mu(x)\cdot  x$ 之后暴力求解 $(\sum_{i=1}^{n/T}i\cdot num_{iT})^2$ 得出答案

## Code
```cpp
#include<cstdio>
#include<cstring>
#include<vector>
#include<iostream>
#include<algorithm>
using namespace std;

#define pb push_back

typedef long long  LL;

const int N = 1000010;

LL n;
LL mu[N], mu_sum[N], num[N];
vector<LL> prime;
bool st[N];

inline void init()
{
	mu[1] = 1;
	for (int i = 2; i <= n; i++)
	{
		if (!st[i]) st[i] = true, prime.pb(i), mu[i] = -1;
		for (int j = 0; j < prime.size() && i * prime[j] <= n; j++)
		{
			st[i * prime[j]] = true;
			if (i % prime[j] == 0)
			{
				mu[i * prime[j]] = 0;
				break;
			}
			mu[i * prime[j]] = -mu[i];
		}
	}

	for (int i = 1; i <= n; i++)
	{
		for (int j = i; j <= n; j += i)
		{
			mu_sum[j] += mu[i] * i;
		}
	}
}

int main()
{
	scanf("%lld", &n);

	LL mx = 0;
	for (int i = 1; i <= n; i++)
	{
		LL x;
		scanf("%lld", &x);
		num[x]++;
		mx = max(mx, x);
	}
	n = mx;

	init();

	LL ans = 0;
	for (int T = 1; T <= n; T++)
	{
		LL res = 0;
		for (int i = 1; i <= n / T; i++)
		{
			res += i * num[i * T];
		}
		ans += T * res * res * mu_sum[T];
	}
	printf("%lld", ans);
}
```
END

---

## 作者：aleph_blanc (赞：1)

~~修复了一些小bug，(。・＿・。)ﾉI’m sorry~~~

给出集合 $A$，设 $n=\mid A\mid$，求 $\sum_{i=1}^n\sum_{j=1}^n\text{lcm}(A_i,A_j)$。

摸到这道题，我们马上就可以发现 $A$ 中的元素是无序的，题目中给出的式子没法化简，所以我们不得不考虑转化式子。

数据范围 $1\le A_i\le5e4$，这就很好办了……

开一个桶（这里用数组 $t$ 表示），$t[i]$ 表示数 $i$ 在集合中出现的次数。

这样原式就转化为了:
$$
\sum_{i=1}^n\sum_{j=1}^n\text{lcm}(i,j)\times t[i]\times t[j]
$$
**注意此后 $n$ 指集合 $A$ 中元素的最大值。**

这样好像就可以转化 $\text{gcd}$ 求解了。

（为了此篇题解更通俗易懂，接下来的推导会有些冗余部分，见谅~）

愉快的推式子时间~：
$$
\large
\begin{aligned}
&\sum_{i=1}^n\sum_{j=1}^n\text{lcm}(i,j)\times t[i]\times t[j]\\

&\Rightarrow\sum_{i=1}^n\sum_{j=1}^n\frac{i\times j}{\text{gcd}(i,j)}\times t[i]\times t[j]\\

&\Rightarrow\sum_{d=1}^n\sum_{i=1}^n\sum_{j=1}^n\frac{i\times j}{[\text{gcd}(i, j)=d]\times d}\times t[i]\times t[j]\\

&\Rightarrow\sum_{d=1}^n\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{n}{d}\rfloor}\frac{i d\times jd}{[\text{gcd}(i, j)=1]\times d}\times t[id]\times t[jd]\\

&\Rightarrow\sum_{d=1}^n\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{n}{d}\rfloor}d\times i\times j\times[\text{gcd}(i, j)=1]\times t[id]\times t[jd]\\

&\Rightarrow\sum_{d=1}^n\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{n}{d}\rfloor}d\times i\times j\times\sum_{k\mid i,k\mid j}\mu(k)\times t[id]\times t[jd]\\

&\Rightarrow\sum_{d=1}^n\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{k\mid i,k\mid j}\mu(k)\times d\times i\times j\times t[id]\times t[jd]\\

&\Rightarrow\sum_{d=1}^n\sum_{k=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{i=1}^{\lfloor\frac{n}{kd}\rfloor}\sum_{j=1}^{\lfloor\frac{n}{kd}\rfloor}\mu(k)\times d\times ik\times jk\times t[ikd]\times t[jkd]\\

&\Rightarrow\sum_{s=1}^ns\times\sum_{k\mid s}\mu(k)\times k\ (\sum_{i=1}^{\lfloor\frac{n}{s}\rfloor}i\times t[is])^2
\end{aligned}
$$
一些解释（大佬可直接跳过）：

1. $s=kd$。
2. 结果中的平方为上面的式子中的 $i$ 和 $j$，他俩其实是一样的。

最后，我们使用线性筛预处理 $\sum_{k\mid s}\mu(k)\times k$，输入时直接处理 $t$，然后暴力就完了。

代码按照上面的暴力即可，就不给了 QVQ。

---

## 作者：Saber_Master (赞：0)

[P3911 最小公倍数之和](https://www.luogu.com.cn/problem/P3911)

$$\begin{aligned}
\sum_{i=1}^{n} \sum_{j=1}^{n} lcm(A_i, A_j)&=\sum_{i=1}^n \sum_{j=1}^n lcm(i, j)\cdot cnt_i\cdot cnt_j \\
&=\sum_{i=1}^n  \sum_{j=1}^n\frac{i\cdot j}{gcd(i,j)}\cdot cnt_i \cdot cnt_j\\
&=\sum_{d=1}^n \sum_{i=1}^n \sum_{j=1}^n[gcd(i, j)==d]\frac{i\cdot j}{d}\cdot cnt_i \cdot cnt_j \\
&=\sum_{d=1}^n \sum_{i=1}^{\lfloor \frac{n}{d}\rfloor} \sum_{j=1}^{\lfloor \frac{n}{d}\rfloor}[gcd(i, j)==1]\frac{id\cdot jd}{d}\cdot cnt_{id} \cdot cnt_{jd}\\
&=\sum_{d=1}^n \sum_{i=1}^{\lfloor \frac{n}{d}\rfloor} \sum_{j=1}^{\lfloor \frac{n}{d}\rfloor}[gcd(i, j)==1] i\cdot j\cdot d\cdot cnt_{id} \cdot cnt_{jd}\\

&=\sum_{d=1}^n \sum_{i=1}^{\lfloor \frac{n}{d}\rfloor} \sum_{j=1}^{\lfloor \frac{n}{d}\rfloor}\sum_{s|gcd(i, j)}\mu(s)\cdot i\cdot j\cdot d\cdot cnt_{id} \cdot cnt_{jd}\\
&=\sum_{d=1}^n d\sum_{i=1}^{\lfloor \frac{n}{d}\rfloor} \sum_{j=1}^{\lfloor \frac{n}{d}\rfloor}\sum_{s|gcd(i, j)}\mu(s)\cdot i\cdot j\cdot cnt_{id} \cdot cnt_{jd}\\
&=\sum_{d=1}^nd\sum_{s=1}^{\lfloor \frac{n}{d}\rfloor}\mu(s)\sum_{i=1}^{\lfloor \frac{n}{ds} \rfloor}\sum_{j=1}^{\lfloor \frac{n}{ds} \rfloor}s^2\cdot i\cdot j\cdot cnt_{ids}\cdot cnt_{jds}\\

&=\sum_{d=1}^nd\sum_{s=1}^{\lfloor \frac{n}{d}\rfloor}\mu(s)s^2(\sum_{i=1}^{\lfloor \frac{n}{ds} \rfloor}i\cdot cnt_{ids})^2\\

&=\sum_{ds=1}^n ds \sum_{s|ds}\mu(s)\cdot s\cdot (\sum_{i=1}^{\lfloor \frac{n}{ds} \rfloor}i\cdot cnt_{ids})^2
\end{aligned}
$$

令$T=ds$,则有
$$\begin{aligned}
\sum_{i=1}^{n} \sum_{j=1}^{n} lcm(A_i, A_j)&=\sum_{T=1}^{n}T\sum_{s|T}(\mu(s)\cdot s)\cdot (\sum_{i=1}^{\lfloor \frac{n}{T} \rfloor}i\cdot cnt_{iT})^2
\end{aligned}
$$

中间括号可以爆算，后面括号也可以爆算，具体做法是枚举倍数刷表，复杂度为调和级数，上界$O(n\log n)$.

记得开$long \ long$
```cpp
const ll N=5e4+4;

ll prime[N], tot, mu[N];
bool book[N];

inline void euler_solve(ll lim){
	mu[1]=1;
	for (R ll i=2; i<=lim; i++){
		if (!book[i]) prime[++tot]=i, mu[i]=-1;
		for (R ll j=1; j<=tot && 1ll*prime[j]*i<=lim; j++){
			book[i*prime[j]]=true;
			if (i%prime[j]==0){
				mu[i*prime[j]]=0;
				break;
			}
			mu[i*prime[j]]=-mu[i];
		}
	}
} 

ll n, cnt[N];

ll sum1[N], sum2[N];
ll res;
int main(){
	read(n);
	for (R ll i=1, x; i<=n; i++){
		read(x); ++cnt[x];
	}
	euler_solve(50000);
	for (R ll i=1; i<=50000; i++)
		for (R ll j=i; j<=50000; j+=i)
			sum1[j]+=mu[i]*i;
	for (R ll i=1; i<=50000; i++){
		for (R ll j=1; j<=50000/i; j++) sum2[i]+=j*cnt[j*i];
	}
	for (R ll i=1; i<=50000; i++) res+=i*sum2[i]*sum2[i]*sum1[i];
	writeln(res);
}

```


---

## 作者：ricky0916 (赞：0)

引理：$ \sum_{i|n} \mu(i) =[n=1] $

证 ~~（不知道这个结论的是不是点错题或者随机跳题的……）~~

当$ n=1 $时显然成立

否则设$ n=p_1^{x_1}*p_2^{x_2}*p_3^{x_3}*......*p_k^{x_k},n'=p_1*p_2*p_3*......*p_k,k>=1 $

则有$ \sum_{i|n}\mu(i)=\sum_{i|n'}\mu(i)=(1+(-1))^k=0 $

所以引理成立

~~说了一大堆废话现在~~进入正题
# P3911 题解

令$ a_x $表示$ x $在$ A_x $中出现的次数，$ T $为$ A_x $中出现的最大的正整数

则有$ \sum_{i=1}^n \sum_{j=1}^n lcm(i,j)=\sum_{i=1}^T \sum_{j=1}^T lcm(i,j)*a_i*a_j $

那怎么求$ \sum_{i=1}^T \sum_{j=1}^T lcm(i,j)*a_i*a_j $呢？首先，因为$ lcm(i,j)=\frac{i*j}{gcd(i,j)} $

所以原式可以写成$\sum_{i=1}^T \sum_{j=1}^T \frac{i*j*a_i*a_j}{gcd(i,j)} $

换一下顺序，先枚举$ gcd(i,j) $

$\sum_{i=1}^T \sum_{j=1}^T \frac{i*j*a_i*a_j}{gcd(i,j)} $
$ =\sum_{d=1}^T\sum_{i=1}^{\lfloor T/d \rfloor}\sum_{j=1}^{\lfloor T/d \rfloor} [gcd(i,j)=1]*d*i*j*a_{id}*a_{jd}$

根据引理

$\sum_{d=1}^T\sum_{i=1}^{\lfloor T/d \rfloor}\sum_{j=1}^{\lfloor T/d \rfloor} [gcd(i,j)=1]*d*i*j*a_{id}*a_{jd}$
$ =\sum_{d=1}^T\sum_{i=1}^{\lfloor T/d \rfloor}\sum_{j=1}^{\lfloor T/d \rfloor} \sum_{k|gcd(i,j)} \mu(k)*d*i*j*a_{id}*a_{jd} $

再把$ k $往前放

$\sum_{d=1}^T\sum_{i=1}^{\lfloor T/d \rfloor}\sum_{j=1}^{\lfloor T/d \rfloor} \sum_{k|gcd(i,j)} \mu(k)*d*i*j*a_{id}*a_{jd}$
$=\sum_{d=1}^T\sum_{k=1}^{\lfloor T/d \rfloor}\sum_{i=1}^{\lfloor T/kd \rfloor}\sum_{j=1}^{\lfloor T/kd \rfloor}\mu(k)*d*i*j*k^2*a_{idk}*a_{jdk}$

~~（怎么越变越复杂了啊QAQ）~~

最后一步，将前两个$ \sum $合并起来，并合并$i,j$

$\sum_{d=1}^T\sum_{k=1}^{\lfloor T/d \rfloor}\sum_{i=1}^{\lfloor T/kd \rfloor}\sum_{j=1}^{\lfloor T/kd \rfloor}\mu(k)*d*i*j*k^2*a_{idk}*a_{jdk}$
$=\sum_{d=1}^T(\sum_{i=1}^{\lfloor T/d \rfloor}i*a_{id})^2\sum_{k|n}\mu(k)*k$

$ \sum_{k|n}\mu(k)*k $可以用$ O(T*\sum_{i=1}^T\frac1{i}) $的时间(约为$ O(n logn) $)筛

所以这题就结束了 ~~（这个式子竟然是暴力求的）~~

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[50010],prime[50010],check[50010],miu[50010],tot,maxx;
long long sum[50010];
void init(){
    miu[1]=1;
    for(int i=2;i<=50000;i++){
        if(!check[i]){
            prime[tot++]=i;
            miu[i]=-1;
        }
        for(int j=0;j<tot&&i*prime[j]<=50000;j++){
            check[i*prime[j]]=1;
            if(i%prime[j]==0){
                miu[i*prime[j]]=0;
                break;
            }
            miu[i*prime[j]]=-miu[i];
        }
    }
    for(int i=1;i<=50000;i++){
        for(int j=i;j<=50000;j+=i) sum[j]+=1ll*i*miu[i];
    }
}
long long work(){
    long long ans=0;
    for(int i=1;i<=maxx;i++){
        long long temp=0;
        for(int j=1;j<=maxx/i;j++){
            temp+=1ll*a[i*j]*j;
        }
        ans+=1ll*temp*temp*sum[i]*i;
    }
    return ans;
}
int main(){
    init();
    scanf("%d",&n);
    for(int i=1;i<=n;i++){
    	int temp;
        scanf("%d",&temp);
        a[temp]++;
        maxx=max(maxx,temp);
    }
    long long ans=work();
    printf("%lld",ans);
    return 0;
}
```


---

## 作者：Aliemo (赞：0)

题目链接:[P3911 最小公倍数之和](https://www.luogu.com.cn/problem/P3911)

### 题目大意

简洁易懂,我就不说了

### solution

我们来观察这个式子, $lcm$怎么操作啊? 那我们就转化成$gcd$

$\sum\limits_{i = 1}^n\sum\limits_{j = 1}^n lcm(A_i, A_j) \iff \sum\limits_{i = 1}^n\sum\limits_{j = 1}^n \dfrac{A_iA_j}{gcd(A_i, A_j)}$

那还是很难处理啊, 那我们怎么办呢, 我们是不是可以转化成值域来做啊,记录一下每个数的个数.

我们发现这样是可行的, 毕竟 $A_i \in [1, 50000]$

我们设 $N$ 为值域的最大值, $C_i$ 是每个元素的个数, 那我们要求的就变成了:

$\sum\limits_{i = 1}^N\sum\limits_{j = 1}^N \dfrac{i \times j \times C_i \times C_j}{gcd(A_i, A_j)}$ 

这不就是莫比乌斯反演的板子题么, 那我们来推一下反演过程:

枚举公约数:

$\sum\limits_{d = 1}^N\sum\limits_{i = 1}^N\sum\limits_{j = 1}^N \dfrac{ij}{d}[gcd(A_i, A_j) == d] \times C_i \times C_j$

将后两重循环除以 $d$ , $i$ 和 $j$ 变成 $id$ 和 $jd$ :

$\sum\limits_{d = 1}^N\sum\limits_{i = 1}^{\left\lfloor\frac{N}{d}\right\rfloor}\sum\limits_{j = 1}^{\left\lfloor\frac{N}{d}\right\rfloor} ijd[gcd(A_i, A_j) == 1] \times C_{id} \times C_{jd}$

我们伟大的莫比乌斯函数来了:

$\sum\limits_{d = 1}^N\sum\limits_{i = 1}^{\left\lfloor\frac{N}{d}\right\rfloor}\sum\limits_{j = 1}^{\left\lfloor\frac{N}{d}\right\rfloor}\sum\limits_{k|gcd(i, j)} \mu(k)ijd \times C_{id} \times C_{jd}$

我们发现 $gcd(i,j) == 1$, 共有 $\left\lfloor\frac{N}{d}\right\rfloor$ 个, 然后改变一下 $k$ 的枚举方式:

$\sum\limits_{d = 1}^N\sum\limits_{i = 1}^{\left\lfloor\frac{N}{d}\right\rfloor}\sum\limits_{j = 1}^{\left\lfloor\frac{N}{d}\right\rfloor}\sum\limits_{k}^{\left\lfloor\frac{N}{d}\right\rfloor} \mu(k)ijd\times C_{id} \times C_{jd}$

交换一下枚举顺序:

$\sum\limits_{d = 1}^N\sum\limits_{k}^{\left\lfloor\frac{N}{d}\right\rfloor}\sum\limits_{i = 1}^{\left\lfloor\frac{N}{d}\right\rfloor}\sum\limits_{j = 1}^{\left\lfloor\frac{N}{d}\right\rfloor} \mu(k)ijd\times C_{id} \times C_{jd}$

然后将最后两重循环除以 $k$, $id, jd$ 就变成了 $idk, jdk$ :

$\sum\limits_{d = 1}^N\sum\limits_{k}^{\left\lfloor\frac{N}{d}\right\rfloor}\sum\limits_{i = 1}^{\left\lfloor\frac{N}{dk}\right\rfloor}\sum\limits_{j = }^{\left\lfloor\frac{N}{dk}\right\rfloor} \mu(k)ijdk^2 \times C_{idk} \times C_{jdk}$

我们令 $T = dk$ :

$\sum\limits_{T = 1}^N\sum\limits_{k | T}\sum\limits_{i = 1}^{\left\lfloor\frac{N}{T}\right\rfloor}\sum\limits_{j = 1}^{\left\lfloor\frac{N}{T}\right\rfloor} \mu(k)k T ij\times C_{iT} \times C_{jT}$

然后交换一下枚举顺序:

$\sum\limits_{T = 1}^N T \sum\limits_{i = 1}^{\left\lfloor\frac{N}{T}\right\rfloor}\sum\limits_{j = 1}^{\left\lfloor\frac{N}{T}\right\rfloor} ij\times C_{iT} \times C_{jT}\sum\limits_{k | T}\mu(k)k$

把 $ij$ 的两维合并:

$\sum\limits_{T = 1}^N T \sum\limits_{i = 1}^{\left\lfloor\frac{N}{T}\right\rfloor} (i\times C_{iT})^2\sum\limits_{k | T}\mu(k)k$

最后我们预处理出 $\mu(k)k$ 就做完了.

### Code:

```cpp
/**
*    Author: Alieme
*    Data: 2020.9.8
*    Problem: P3911
*    Time: O()
*/
#include <cstdio>
#include <iostream>
#include <string>
#include <cstring>
#include <cmath>
#include <algorithm>

#define int long long
#define rr register

#define inf 1e9
#define MAXN 100010

using namespace std;

inline int read() {
	int s = 0, f = 0;
	char ch = getchar();
	while (!isdigit(ch)) f |= ch == '-', ch = getchar();
	while (isdigit(ch)) s = s * 10 + (ch ^ 48), ch = getchar();
	return f ? -s : s;
}

void print(int x) {
	if (x < 0) putchar('-'), x = -x;
	if (x > 9) print(x / 10);
	putchar(x % 10 + 48);
}

int tot, n, ans;

int c[MAXN], mu[MAXN], prime[MAXN], sum[MAXN];

bool vis[MAXN];

inline void init() {  // 预处理mu和公式
	mu[1] = 1;
	for (rr int i = 2; i <= 50000; i++) {   // 线性筛预处理mu
		if (!vis[i]) prime[++tot] = i, mu[i] = -1;
		for (rr int j = 1; j <= tot; j++) {
			if (i * prime[j] > 50000) break;
			vis[i * prime[j]] = 1;
			mu[i * prime[j]] = -mu[i];
			if (i % prime[j] == 0) {
				mu[i * prime[j]] = 0;
				break;
			}
		}
	}
	for (rr int i = 1; i <= 50000; i++)  // 预处理 mu(k)*k
		for (rr int j = i; j <= 50000; j += i) 
			sum[j] += mu[i] * i;
}

signed main() {
	init();
	n = read();
	for (rr int i = 1; i <= n; i++) c[read()]++;
	for (rr int i = 1; i <= 50000; i++) {          // 暴力求解
		int s = 0;	
		for (rr int j = 1; j <= 50000 / i; j++) s += c[i * j] * j;
		ans += i * s * s * sum[i];
	}
	print(ans);
}
```

---


# LJJ爱数数

## 题目背景

题解请查看 <https://www.cnblogs.com/Blog-of-Eden/p/9367521.html>。

## 题目描述

PJY 某次翻阅杂志时，看到一道题：

求出所有的 **正整数** 三元组 $(a,b,c)$，满足 $a,b,c \leq n$，**$\bold{a,b,c}$ 三个数的最大公约数为 $\bold{1}$**，且 **$\bold{\frac{1}{a}+\frac{1}{b}=\frac{1}{c}}$**。

PJY 嫌这道题太水，于是把它甩给了爱数数的 LJJ，并加上了数据范围 $\bold{n \leq 10^{12}}$，让 LJJ 数出 **有多少组满足条件的三元组 $\bold{(a,b,c)}$**
（注意当 $a \not= b$ 时，$(a,b,c)$ 和 $(b,a,c)$ 是不同的三元组，要算两次）

LJJ 数到一半，发现这个数量太大了，于是他把问题抛给了你。请你输出这个数量。

## 说明/提示

对于 $20\%$ 的数据，$n \leq 2 \times 10^{3}$。

对于 $40\%$ 的数据，$n \leq 10^{5}$。

对于 $60\%$ 的数据，$n \leq 10^{7}$。

对于 $80\%$ 的数据，$n \leq 10^{9}$。

对于 $100\%$ 的数据，$n \leq 10^{12}$。

## 样例 #1

### 输入

```
10```

### 输出

```
3```

## 样例 #2

### 输入

```
100```

### 输出

```
43```

## 样例 #3

### 输入

```
100000```

### 输出

```
42139
```

# 题解

## 作者：Ynoi (赞：16)

## 这里详细解说一下出题人说的pjy的方法

> 可以化简得到：(a+b)c=ab，于是ab-bc-ac+$c^2$=$c^2$，所以(a-c)(b-c)=$c^2$

> 设a-c=k$m^2$，b-c=k$n^2$，则c=kmn。

> 若k>1，(a,b,c)=(k$m^2$+kmn, k$n^2$+kmn, kmn)≠1(有个公约数k)，矛盾。故k=1

> 由此我们知道a-c=$m^2$，b-c=$n^2$是完全平方数。

> 因为(a,b,c)=(m(m+n)，n(m+n)，mn)=（(m+n)*(m，n)，mn）=1，所以(m,n)=1

> 故充要条件为1<=a,b,c<=n，a-c, b-c是完全平方数，$c^2$=(a-c)(b-c)，(a-c，b-c)=1


### 上面这段应该好理解

> 枚举(a-c)，用莫比乌斯反演求出一定范围内与sqrt(a-c)互质的数的个数即可。

为了防止题目输入的n和上面的n混淆，我们在下面定义定义 x = m，y = n

### 枚举(a-c)

其实是枚举 sqrt(a-c) 即 x

### 一定范围：

就是求出y的范围

因为 a,b,c <= n

c = xy

所以 y = $\frac{c}{x}$ <= $\frac{n}{x}$

因为 a-c = $x^2$

所以 a = c + $x^2$ <= n

c = xy

所以  $x^2 + xy <= n$

$y <= \frac{n-x^2}{x}$

$b-c = y^2$ 

$y^2 + xy = b <= n$

利用初三的数学可以知道

$-\frac{x}{2} - \sqrt{n + \frac{x^2}{4}} < 0 < y <= -\frac{x}{2} + \sqrt{n + \frac{x^2}{4}}$

所以 $y <= min(-\frac{x}{2} + \sqrt{n + \frac{x^2}{4}},\frac{n-x^2}{x})$

### 然后是莫比乌斯

答案是 $\sum_{x=1}^{\sqrt n} \sum_{y=1}^{s[x]} [gcd(x,y) = 1]$ //s[x] 是此时x,y的上限

可以将每个
$\sum_{y=1}^{s[x]}[gcd(x,y)=1] $单独取出（x暴力枚举)

$\sum_{y=1}^{s[x]}[gcd(x,y)=1] $ =
$\sum_{y=1}^{s[x]}\sum_{d|x,d|y}u(d) $ //u就当莫比乌斯函数 = $\sum_{d=1,d|x}^{s[x]}u(d)[\frac{m}{d}]$

然后暴力枚举 s[x] 约数即可 

但是,求出一个数的约数要 $\sqrt n$ 的时间

没关系，预处理出 1～$\sqrt n$每个数约数 枚举倍数







---

## 作者：lnzwz (赞：12)

题意：

给定$n$，求满足$\frac{1}{a}+\frac{1}{b}=\frac{1}{c}$，且$a,b,c$互质的三元组$(a,b,c)$数目。$(a,b,c\leq n)$

$n\leq10^{12}$

首先，使用类似[P5253 丢番图 ](https://www.luogu.com.cn/problem/P5253)的方法，两边乘以$abc$。

$ac+bc=ab$

$ab-ac-bc+c^2=c^2$

$(a-c)(b-c)=c^2$

设$a-c=x$，$b-c=y$，则$xy=c^2$

若$a,b,c$不互质，则存在$g,(g>1)$满足$g|(x+c)$且$g|(y+c)$且$g|c$。

那么$g|x$且$g|y$且$g|c$。即满足$x,y,c$互质即可

若$x,y,c$不互质，则存在$g,(g>1)$满足$x=gx'$且$y=gy'$且$g|c$。

即$x'y'g^2=c^2$，$g^2 | c^2$，$g|c$。

就是说，只要满足$g|x$且$g|y$，就能满足$g|c$。

所以，只要$gcd(x,y)=1$即可。

此外，还要满足$max(x,y)+c\leq n$。

不妨设$y<x$，那么$x+c\leq n$。

因为$gcd(x,y)=1$，所以$c^2$的每种质因子，要么都给x，要么都给y。

因此，$x,y$都是完全平方数。

设$i^2=x$，$j^2=y（j<i）$，那么$c=ij$。

因为$i^2+ij\leq n$，所以$i(i+j)\leq n$，即$j\leq \frac{n}{i}-i$。

设$R_i=min(i-1,\frac{n}{i}-i)$，则答案为

$\sum_{i=1}^n {\sum_{j=1}^{R_i} [gcd(i,j)=1]}$

直接莫比乌斯反演：

$\sum_{d=1}^n u(d){\sum_{d|i}^{} {\left \lfloor \frac{R_i}{d} \right \rfloor}}$

当$i>\sqrt{n}$时，显然$R_i=0$，忽略即可。

时间复杂度$O(\sqrt{n}log\sqrt{n})$。

最后别忘乘2。

代码：
```cpp
#include <stdio.h>
#define ll long long
ll R[1000010];
int sa[1000010],ss[1000010],u[1000010],sl=0;
void getu(int n)
{
	u[1]=1;
	for(int i=2;i<=n;i++)
	{
		if(!sa[i])
		{
			ss[sl++]=i;
			u[i]=-1;
		}
		for(int j=0;j<sl&&i*ss[j]<=n;j++)
		{
			sa[i*ss[j]]=true;
			if(i%ss[j]==0)
			{
				u[i*ss[j]]=0;
				break;
			}
			u[i*ss[j]]=-u[i];
		}
	}
}
int main()
{
	ll n,ans=0;int m=0;
	scanf("%lld",&n);
	if(n==1)
	{
		printf("0");
		return 0;
	}
	for(int i=2;i<=n;i++)
	{
		R[i]=n/i-i;
		if(i-1<R[i])
			R[i]=i-1;
		if(R[i]<=0)
			break;
		m=i;
	}
	getu(m);
	for(int i=1;i<=m;i++)
	{
		if(u[i])
		{
			for(int j=i;j<=m;j+=i)
				ans+=u[i]*(R[j]/i);
		}
	}
	printf("%lld",ans*2+1);
	return 0;
}
```

---

## 作者：HSY666 (赞：7)


根据题意可知，我们要求的是:
$$
\sum\limits_{i=1}^n \sum\limits_{j=1}^n \sum\limits_{k=1}^n [\dfrac{1}{i}+\dfrac{1}{j}=\dfrac{1}{k}] \left[\gcd(i,j,k)=1\right]
$$
化简式子，我们用 $i,j$ 来表示 $k$：
$$
\sum\limits_{i=1}^n \sum\limits_{j=1}^n [\gcd(i,j,\dfrac{ij}{i+j})=1] \qquad (\dfrac{ij}{i+j}\in[1,n] ,\mathbf{N_+})
$$
观察这个式子，可以发现：
$$
\gcd(i,j,\dfrac{ij}{i+j}) = \gcd(\gcd(i,j),\dfrac{ij}{i+j})
$$
$$
\gcd(i,j,\dfrac{ij}{i+j})=1
$$
$$
\Longrightarrow i+j=\gcd(i,j)^2
$$
回到原式：
$$
\sum\limits_{i=1}^n \sum\limits_{j=1}^n [i+j=\gcd(i,j)^2]
$$
枚举 $\gcd(i,j)$：
$$
\sum\limits_{d=1}^n \sum\limits_{i=1}^n \sum\limits_{j=1}^n [i+j=d^2][\gcd(i,j)=d]
$$
$$
\sum\limits_{d=1}^n \sum\limits_{i=1}^{\lfloor \frac{n}{d} \rfloor} \sum\limits_{j=1}^{\lfloor \frac{n}{d} \rfloor} [i+j=d][\gcd(i,j)=1]
$$
我们发现可以用 $i,d$ 来表示 $j$:
$$
\sum\limits_{d=1}^n \sum\limits_{i=1}^{\lfloor \frac{n}{d} \rfloor} [\gcd(i,d-i)=1] \qquad 1 \leqslant d-i \leqslant \lfloor \dfrac{n}{d} \rfloor
$$
要满足
$$
1 \leqslant d-i \leqslant \lfloor \dfrac{n}{d} \rfloor
$$
$$
\Longrightarrow d-\lfloor \dfrac{n}{d} \rfloor \leqslant i \leqslant d-1
$$
因此，设
$$
L(d)=\max(1,d-\lfloor \dfrac{n}{d} \rfloor)
$$
$$
R(d)=\min(\lfloor \dfrac{n}{d} \rfloor,d-1)
$$
则
$$
\sum\limits_{d=1}^n \sum\limits_{i=L(d)}^{R(d)} [\gcd(i,d-i)=1]
$$
$$
\sum\limits_{d=1}^n \sum\limits_{i=L(d)}^{R(d)} [\gcd(d,i)=1]
$$
观察函数 $L,R$，发现当 $d-\lfloor \tfrac{n}{d} \rfloor > \lfloor \tfrac{n}{d} \rfloor$ 时，$L(d)>R(d)$，此时有 $d \leqslant \sqrt{2n}$，所以 $d$ 只用枚举到 $\sqrt{2n}$：
$$
\sum\limits_{d=1}^{\sqrt{2n}} \sum\limits_{i=L(d)}^{R(d)} [\gcd(d,i)=1]
$$
考虑莫比乌斯反演：
$$
\sum\limits_{d=1}^{\sqrt{2n}} \sum\limits_{i=L(d)}^{R(d)} \sum\limits_{k\mid\gcd(d,i)} \mu(k)
$$
枚举 $k$：
$$
\sum\limits_{k=1}^{\sqrt{2n}} \mu(k) 
\sum\limits_{d=1}^{\lfloor\frac{\sqrt{2n}}{k}\rfloor} (\lfloor \frac {R(dk)}{k} \rfloor-\lceil \frac {L(dk)}{k} \rceil+1)
$$
后面那坨可以 $O(1)$ 求。用线性筛筛出 $\mu$，然后枚举 $k$，再枚举 $k$ 的倍数即可，复杂度 $O(\sqrt n\log{\sqrt n})$。

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>

using namespace std;

const int N=2e6+5;
int cnt,Max,p[N],mu[N];
bool isp[N];
long long n,ans;

void get_mu ()
{
	mu[1]=1;
	for (int i=2;i<=Max;++i)
	{
		if (!isp[i])
		{
			p[++cnt]=i;
			mu[i]=-1;
		}
		for (int j=1;j<=cnt&&i*p[j]<=Max;++j)
		{
			isp[i*p[j]]=1;
			if (!(i%p[j]))  break;
			mu[i*p[j]]=-mu[i];
		}
	}
}

int L (int x,int y)
{
	int z=max(1LL,1LL*x-n/x);
	return z%y ? z/y+1 : z/y;
}

int R (int x,int y)
{
	return min(n/x,1LL*x-1)/y;
}

int main ()
{
	scanf ("%lld",&n);
	Max=(int)sqrt(n<<1);
	get_mu();
	for (int i=1;i<=Max;++i)
	{
		long long ret=0;
		for (int j=i;j<=Max;j+=i)
		{
			ret+=R(j,i)-L(j,i)+1;
		}
		ans+=ret*mu[i];
	}
	printf ("%lld\n",ans);
	return 0;
}
```


---

## 作者：yqaty (赞：5)

[题目链接~](https://www.luogu.com.cn/problem/P4844)

大佬们为什么要用莫比乌斯反演呀。。。蒟蒻看不懂嘤嘤嘤。。。只好用暴力容斥惹。。。

---

显然，我们要找到 $i$，$j$，使 $gcd(i,j)=1$，构造出的方案为 $(i^2+ij,j^2+ij,ij)$ 和 $(j^2+ij,i^2+ij,ij)$。

这里我们令 $i \geq j$，则方案个数为 

$\sum\limits_{i=1}^n{\sum\limits_{j=1}^i{[gcd(i,j)=1]  [i^2+ij \leq n]}}$

对于 $i^2+ij \leq n$，我们求出 $j \leq \frac{n}{i}-i$，再解 $\frac{n}{2}-i \geq 0$，得 $i \leq \sqrt{n}$，把式子改一下:

$\sum\limits_{i=1}^{\sqrt{n}}{\sum\limits_{j=1}^{\min (\frac{n}{i}-i,i)}{[gcd(i,j)=1]}}$

好哒，我们再看一看 $\frac{n}{i}-i=i$，解得 $i=\sqrt{\frac{n}{2}}$，分情况讨论：

当 $i \leq \sqrt{\frac{n}{2}}$ 时，就等价于统计 $\sum\limits_{j=1}^{i}{[gcd(i,j)=1]}$，线性筛 $\phi$ 即可。

当 $\sqrt{\frac{n}{2}} < i \leq \sqrt{n}$ 时，$j \leq i$，这个时候怎么办呢？

我们暴力容斥就好啦，线性筛时顺便筛出每个数的最小质因子，分解，设有 $K$ 个不同的质因子，则 $j$ 内与 $i$ 互质的数有：

$j-\sum\limits_{k=1}^{K}{(-1)^k*f(k)}$，$f(k)=\sum\limits_{a_1<a_2< \cdots <a_k \leq K}{\frac{j}{\prod\limits_{i=1}^{k}{p_{a_i}}}}$

最后把输出 $2ans-1$，再加上两个剪枝，就可以轻松跑过啦~

$\frak{code:}$

```cpp
#include<bits/stdc++.h>
#define IL inline
#define LL long long
using namespace std;
const int N=1e6+3;
int vis[N],pri[N],mu[N],a[N],now,num;
LL n,m,res,Max,ans,phi[N];
void init(int n){  //线性筛~ 
	phi[1]=mu[1]=1;
	for(int i=2;i<=n;++i){
		if(!vis[i]) vis[i]=i,pri[++pri[0]]=i,phi[i]=i-1,mu[i]=-1;
	  for(int j=1,k;(k=i*pri[j])<=n;++j){
	    vis[k]=pri[j];
	    if(i%pri[j]) mu[k]=-mu[i],phi[k]=phi[i]*phi[pri[j]];
	    else{phi[k]=phi[i]*pri[j];break;}
		}
	}
}
void calc(int n){ //分解质因数~ 
	a[0]=0;
	while(n^1){
		if(vis[n]^a[a[0]]) a[++a[0]]=vis[n];
		n/=vis[n];
	}
}
void dfs(int k,int kk,int val,int op){ //搜索组合方案~ 
	if(kk==num){ans+=op*(now/val);return;}
	if(a[0]-k+1<num-kk) return; //显而易见的剪枝1~ 
	dfs(k+1,kk+1,val*a[k],op);
	dfs(k+1,kk,val,op); 
}
int main()
{
	scanf("%lld",&n);init(1e6);
	m=sqrt(1.0*n/2),Max=sqrt(n);
	for(int i=1;i<=m;++i) ans+=phi[i];
	for(int i=m+1,k;i<=Max;++i){
	  now=n/i-i;int res=ans;
	  calc(i),ans+=now;
	  for(num=1,k=a[num];num<=a[0];++num,k*=a[num]){
	  	if(k>now) break; //显而易见的剪枝2，如果最小的num个质因子相乘大于now，则之后的贡献都为0~ 
	  	dfs(1,0,1,num&1?-1:1);
		}
	}
	cout<<ans*2-1<<endl; //(2,2,1)会被算2次，所以减1~ 
	return 0;
}
```


---

## 作者：滑大稽 (赞：4)

### 题外话：
仿佛众多题解都没太详细地讲推导过程，让我等蒟蒻怎么过题。

所以，我钻研一下午后搞出了这篇题解。

有兴趣可以看看我的[草稿](https://www.luogu.com.cn/paste/c6dw5b4q)。

### 进入正题

首先根据题目，我们知道我们要求这个式子：
$$
\sum_{a=1}^n\sum_{b=1}^n\sum_{c=1}^n[\gcd(a,b,c)=1 \& \frac 1a+\frac 1b=\frac 1c]
$$
发现其他地方都不好下手，就最后那个 ~~长得像并联电阻规律~~ 的式子好下手。
所以我们开始推式子：

$$
\frac 1a+\frac 1b=\frac 1c \Rightarrow bc+ac=ab 
$$
发现有点像因式分解，所以我们按因式分解继续：
$$
bc+ac=ab \Rightarrow  ab-bc-ac+c^2=c^2\Rightarrow (a-c)(b-c)=c^2
$$
然后就只能推成这样了。我们设：
$$
a-c=kx^2,b-c=ky^2(x,y\ge 1)
$$
所以
$$
c=kxy,a=k(x^2+xy),b=k(y^2+xy)
$$
把 $\gcd(a,b,c)=1$ 也带进来：
$$
\gcd(a,b,c)=1 \Rightarrow  \gcd(k(x^2+xy),k(y^2+xy),kxy)=1\Rightarrow k=1 \& \gcd(x(x+y),y(x+y),xy)=1
$$
后面 $\gcd(x(x+y),y(x+y),xy)=1$ 中可以抽取一部分，就有 $\gcd(x,y,xy)=1$ (可以左推右，但不等价)。所以：
$$
\gcd(x,y)=1
$$
然后根据 $k=1$ 可以得到
$$
a=x^2+xy,b=y^2+xy,c=xy
$$
又有
$$
a,b,c\le n
$$
代值：
$$
x^2+xy\le n,y^2+xy \le n,xy \le n
$$
发现当前面2个式子成立时， $xy \le n$ 恒成立，所以可以不管。

尝试把 $x,n$ 都当成定值，求 $y$ 的取值范围。

第一个式子运用初中的不等式知识就可以化成这个样子：
$$
y\le \frac{n-x^2}{x}
$$

第二个式子有点难， ~~要用到数形结合思想~~

首先移项得:
$$
y^2+xy-n \le 0
$$

因为我们设 $x,n$ 都为定值，所以前面就是关于 $y$ 的一个二次函数。

又因为 $x,n\ge 1$

所以该函数的图像大概长这个样：

![](https://cdn.luogu.com.cn/upload/image_hosting/9avx6u7n.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

（偷懒用函数软件搞的，可以无视坐标轴上面的单位距离）

然后设该函数与 $x$轴交点的横坐标为 $x_1,x_2(x_1>x_2)$

则那个函数表达式成立的时候就是 $x_2\le y \le x_1$

又易知 $x_2 < 0 < x_1$ ，所以 $y$ 的取值范围是 $1\le y\le x_1$

由公式易知 $x_1=\frac{-x+\sqrt {x^2+4n}}{2}$ 。

综上， $y$ 的取值范围为：
$$
1\le y\le \min(\frac{n-x^2}{x},\frac{-x+\sqrt {x^2+4n}}{2})
$$
发现取值只和 $x$ 有关系，为方便，单独设一个函数:
$$
r(x)=\min(\frac{n-x^2}{x},\frac{-x+\sqrt {x^2+4n}}{2})
$$

然后又因为
$$
x^2+xy\le n,y^2+xy\le n
$$
所以
$$
x,y\le \sqrt n
$$
这就算是把条件挖掘的差不多了。

接着来推答案式子。

根据上面的转换，我们已经可以把答案写成这个形式：
$$
ans=\sum_{x=1}^{\sqrt n}\sum_{y=1}^{r(x)}[\gcd(x,y)=1]
$$
这形式很像莫反，于是按照套路，设:
$$
f(x,d)=\sum_{y=1}^{r(x)}[\gcd(x,y)=d]
$$
$$
F(x,d)=\sum_{y=1}^{r(x)}[d|\gcd(x,y)]
$$
根据定义易知：
$$
F(x,d)=\sum_{d|k}f(x,k)
$$
所以根据莫反：
$$
f(x,d)=\sum_{d|k}\mu(\frac kd)* F(x,k)
$$
其中
$$
F(x,d)=\sum_{y=1}^{r(x)}[d|x\&d|y]
$$
展开式子
$$
f(x,1)=\sum_{k=1}^{r(x)}\mu(k)* F(x,k)=\sum_{k=1}^{r(x)}\mu(k)* \sum_{y=1}^{r(x)}[k|x \&k|y]=\sum_{k=1}^{r(x)}\mu(k)[k|x]* \lfloor\frac{r(x)}k\rfloor
$$
然后带回答案式：
$$
ans=\sum_{x=1}^{\sqrt n}f(x,1)=\sum_{x=1}^{\sqrt n}\sum_{k=1}^{r(x)}\mu(k)[k|x]* \lfloor\frac{r(x)}k\rfloor
$$
最后交换一下和号顺序
$$
ans=\sum_{k=1}^{\max(r(x))}\mu(k)\sum_{x=1}^{\sqrt n}[k|x][k\le r(x)]* \lfloor\frac{r(x)}k\rfloor
$$
然后这题就做完了。预处理出 $\mu,r$ 函数，然后后面 $O(\sqrt n \log\sqrt n)$就可以了。

至于 $\mu$ 函数要预处理到多大（这个取决于 $\max(r(x))$ ）,笔者太菜不会证明，但你 ~~通过打表~~ 可以发现它是小于 $\sqrt n$ 的。所以就处理到根号n就行了。

最丑的代码：
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#define int long long
const int N=1e6+5;
using namespace std;
int r[N],mu[N],pri[N];
int n,mar;
bool v[N];
inline int read()
{
	char h=getchar();
	int y=0;
	while(h<'0'||h>'9')h=getchar();
	while(h>='0'&&h<='9'){y=y*10+h-'0';h=getchar();}
	return y;
}
inline void init(int N)
{
	int s=0;
	for(int i=2;i<=N;i++)
	{
		r[i]=min((double)(n-i*i)/i,(-i+sqrt(i*i+4*n))/2.0);
		mar=max(mar,r[i]);
		if(!v[i])pri[++s]=i,mu[i]=-1;
		for(int j=1;j<=s&&pri[j]*i<=N;j++)
		{
			v[pri[j]*i]=1;
			if(i%pri[j]==0)break;
			mu[pri[j]*i]=mu[i]*-1;
		}
//		if(i<100)cout<<i<<" "<<mu[i]<<"!!\n"; 
	}
	int i=1;r[i]=min((double)(n-i*i)/i,(-i+sqrt(i*i+4*n))/2.0);mar=max(mar,r[i]);//手动偷懒 
	mu[1]=1;
}
signed main()
{
	n=read();
	int m=sqrt(n);
	init(m);
	int ans=0;
//	cout<<mar<<"!!\n";
	for(int i=1;i<=mar;i++)
	if(mu[i])//没什么用的剪枝 
	for(int j=i;j<=m;j+=i)ans+=mu[i]*(r[j]/i);
	printf("%lld\n",ans);
}
```

---
### update on 2021.3.12

在 @cqbzljsqwq 巨佬的帮助下，证出了 $r(x)$ 的取值范围。

为了方便，把 $r(x)$ 再复制一次。
$$
r(x)=\min(\frac{n-x^2}{x},\frac{-x+\sqrt {x^2+4n}}{2})
$$

这里我们分两种情况讨论：

1.  $x\ge \sqrt n$ 

此时 $\frac{n-x^2}{x} \le 0$ ，所以 $r(x)\le 0$

2. $x< \sqrt n$

发现 $\sqrt {x^2+4n}<\sqrt 5\sqrt n$

就算忽略 $-x$ 这一项，$\frac {\sqrt 5} 2\sqrt n$ 也是接近 $\sqrt n$ 级别的。

综上， $r(x)$ 为 $\sqrt n$ 级别

（~~我才不会告诉你那天我没证明出来是忙着去看电影了~~）

---

## 作者：Jμdge (赞：3)

根本不懂前面一大串化简... ~~总感觉是黑题难度~~

# noteskey

总之我们化式子后发现要求的就是：

$$\sum_{i=1}^{\sqrt{2·n}} \sum_{x=L}^{R} [(i,x)=1]  $$

$$L=Max(1,i-\lfloor {n\over i}\rfloor),R=Min(i-1,\lfloor {n\over i }\rfloor)$$

然后我们莫比乌斯反演一下：



$$\sum_{i=1}^{\sqrt{2·n}}  \sum_{k=1}^{\sqrt{2·n}} μ(k) \sum_{k|x,k∈[L,R]} $$

然后我们建边枚举 i 差分跑答案就好了


# code

```
//by Judge
#pragma GCC optimize("Ofast")
#include<bits/stdc++.h>
#define Rg register
#define fp(i,a,b) for(Rg int i=(a),I=(b)+1;i<I;++i)
#define go(G,u) for(Rg int i=G.head[u],v=G.e[i].to;i;v=G.e[i=G.e[i].nxt].to)
#define ll long long
using namespace std;
const int M=2e6+3;
typedef int arr[M];
ll n,m,cnt,ans; arr p,mu; bool v[M];
inline ll Min(ll a,ll b){return a<b?a:b;}
inline ll Max(ll a,ll b){return a>b?a:b;}
struct Gr{ int pat,head[M];
	struct Edge{int to,nxt;}e[M<<4];
	inline void add(int u,int v){
		e[++pat]={v,head[u]},head[u]=pat;
	}
}G;
inline void prep(int n){ mu[1]=1;
	fp(i,2,n){ if(!v[i]) p[++cnt]=i,mu[i]=-1;
		for(int j=1;j<=cnt&&i*p[j]<=n;++j){ v[i*p[j]]=1;
			if(!(i%p[j])) break; mu[i*p[j]]=-mu[i];
		}
	}
}
inline ll calc(ll u,ll k){ ll ans=0;
	go(G,u){ if(abs(v)>k) break; ans+=k/v; } return ans;
}
int main(){ scanf("%lld",&n),m=sqrt(n<<1),prep(m);
	for(int i=1;i<=m;++i) for(int j=1;1ll*i*j<=m;++j)
		if(mu[j]) G.add(i*j,mu[j]*j);
	for(int i=1;i<=m;++i) ans+=calc(i,Min(n/i,i-1))-calc(i,Max(1,i-n/i)-1);
	return !printf("%lld\n",ans);
}
```


---

## 作者：chenxia25 (赞：1)

$$
\dfrac{a+b}{ab}=\dfrac1c
$$

考虑数 $(a,b)$ 二元组的数量，使得 $a+b\mid ab$，且 $\gcd\!\left(a,b,\dfrac{ab}{a+b}\right)=1$。容易发现，这里两个条件综合一下，相当于 $\gcd(a^2+ab,b^2+ab,ab)=a+b$。跟据 gcd 的倍加变换，可以消掉前两个 $ab$ 项，得到 $\gcd(a^2,b^2,ab)=a+b$ 这样一个比较简洁的形式。
$$
\begin{aligned}
\gcd(a^2,b^2,ab)&=\gcd(\gcd(a^2,ab),\gcd(b^2,ab))\\
&=\gcd(a\gcd(a,b),b\gcd(a,b))\\
&=\gcd(a,b)\gcd(a,b)\\
&=\gcd(a,b)^2
\end{aligned}
$$
所以这就等价于 $\gcd(a,b)^2=a+b$。$n$ 是不超过 $10^{12}$ 的变量，枚举 $s=\gcd(a,b)\leq\sqrt{2n}$，那么 $\gcd(a,s^2-a)=s$，即 $\gcd(a,s^2)=s$。所以 $a$ 要是 $s$ 的倍数，设 $a=cs$，则 $\gcd(c,s)=1$。跟据 $a,b\in[1,n]$（当 $a,b\in[1,n]$ 时，容易证明 $c\in[1,n]$）容易整出一个 $c$ 的上下界 $l_s,r_s$，这里并无 $l_s=1,r_s=s$，所以不能莽 $\varphi$，还是要老老实实莫反。
$$
\begin{aligned}
\sum_s\sum_{c=l_s}^{r_s}[\gcd(c,s)=1]&=\sum_s\sum_{c=l_s}^{r_s}\sum_{d\mid s,c}\mu(d)\\
&=\sum_d\mu(d)\sum_{d\mid s}\max\!\left(0,\left\lfloor\dfrac{r_s}{d}\right\rfloor-\left\lfloor\dfrac{l_s-1}{d}\right\rfloor\right)
\end{aligned}
$$
枚举量是 $\mathrm O(\sqrt n\log\sqrt n)$。

---

## 作者：D2T1 (赞：0)

由题意得 $ab-ac-bc=0$。

两边同时加 $c^2$ 得 $(a-c)(b-c)=c^2$。很难不证明此时 $(a-c, b-c)=1$，设 $a-c = p^2,b-c = q^2$，则一对 $(p,q)$ 能对答案产生贡献当且仅当 $(p,q)=1,pq+\max^2(p,q)\leq n$。很难不观察到 $p=q$ 的答案仅有 $(2,2,1)$ 一组，所以很难求不出 $p>q$ 的答案再 $\times 2+1$。

$\sum_{p=1}^n\sum_{q=1}^{\min(p-1,n\div p-p)}[(p,q)=1]$。

考虑莫反，很难不求出答案为 $\sum_{d=1}^n\mu(d)\sum_{i=1}^{n\div d}\max(0,\min(di-1,\dfrac n{di}-di))$。

很难不发现后面式子中含有 $d$ 不能数论分块，但很难不发现对于答案有贡献的 $i,d\leq \sqrt n$。所以枚举 $\sqrt n$ 内的 $i,d$ 即可做到复杂度 $O(\sqrt n\log\sqrt n)$。

```cpp
// Problem: P4844 LJJ爱数数
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P4844
// Memory Limit: 250 MB
// Time Limit: 1000 ms
// 
// Powered by CP Editor (https://cpeditor.org)

#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

const int N = 1e6 + 10;
ll n;
int mu[N], p[N], c, v[N];

int main(){
	n = 1e6;
	mu[1] = 1;
	for(int i = 2; i <= n; ++ i){
		if(!v[i]){
			p[++c] = i;
			mu[i] = -1;
		}
		for(int j = 1; j <= c && i * p[j] <= n; ++ j){
			v[i*p[j]] = 1;
			if(i % p[j]){
				mu[i*p[j]] = -mu[i];
			} else {
				mu[i*p[j]] = 0;
				break;
			}
		}
	}
	cin >> n;
	ll m = sqrt(n);
	ll ans = 0;
	for(ll d = 1; d <= m; ++ d){
		ll tmp = 0;
		for(ll i = 1; i <= m/d; ++ i){
			tmp += min(i-1, n/i/d/d-i);
		}
		ans += tmp * mu[d];
	}
	cout << ans * 2 + 1;
	return 0;
}
```

---

## 作者：EthanOI (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P4844)

过程比较长，但其实一步步推下来也还好。

首先是一个~~做小奥~~常见的技巧，关于处理 $1/a+1/b=1/c$。进行通分得到 $ab-ac-bc=0$，就会想到因式分解（实际上是套路了），即 $(a-c)(n-c)=c^2$。

熟知存在无平方因子的正整数 $k$ 以及整数 $x$，$y$ 满足 $a-c=kx^2$，$b-c=ky^2$，此时 $c=kxy$。但注意到 $k\mid a,b,c$，从而只能 $k=1$，即得
$$\begin{cases}a=x^2+xy\\b=y^2+xy\\c=xy\end{cases}\quad\gcd (x,y)=1$$

易知 $a,b>c$，所以只需要 $x^2+xy,y^2+xy\le n$，即要计算 
$$N:=\#\left\{(x,y)\in [n]^2:x^2+xy,y^2+xy\le n,\gcd (x,y)=1\right\}$$
对两个不等关系我们不难求出 $y$ 的取值范围，用 $x$ 表示为
$$y\le\min\left\{\frac{n-x^2}x,\frac{-x+\sqrt{x^2+4n}}{2}\right\}:=M(x)$$
一个显然的上界是 $x\le\sqrt n$，我们直接进行枚举，有
$$N=\sum_{x=1}^{\lfloor\sqrt n\rfloor}\sum_{y=1}^{M(x)}\left\lfloor\frac 1{\gcd(x,y)}\right\rfloor$$
然后就是比较有技巧性的一步，对每个固定的 $x$ 进行 Mobius 反演：
$$\begin{aligned}\sum_{x=1}^{\lfloor\sqrt n\rfloor}\sum_{y=1}^{M(x)}\left\lfloor\frac 1{\gcd(x,y)}\right\rfloor&=\sum_{x=1}^{\lfloor\sqrt n\rfloor}\sum_{y=1}^{M(x)}\sum_{d\mid x,y}\mu(d)\\&=\sum_{x=1}^{\lfloor\sqrt n\rfloor}\sum_{d\mid x}\left\lfloor\frac {M(x)}{d}\right\rfloor\mu(d)\\&=\sum_{d\le\sqrt n}\left(\sum_{d\mid x}\left\lfloor\frac {M(x)}{d}\right\rfloor\right)\mu(d)\end{aligned}$$
然后对每个 $d$ 求和计算即可，时间复杂度 $\mathcal O(\sqrt n\log\sqrt n)=\mathcal O(\sqrt n\log n)$，能过。

---


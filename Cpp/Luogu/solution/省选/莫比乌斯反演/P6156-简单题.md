# 简单题

## 题目背景

zbw 遇上了一道题，由于他急着去找 qby，所以他想让你来帮他做。

## 题目描述

给你 $n,k$ 求下式的值：

$\sum\limits_{i=1}^n\sum\limits_{j=1}^n(i+j)^kf(\gcd(i,j))\gcd(i,j)$

其中 $\gcd(i,j)$ 表示 $i,j$ 的最大公约数。

$f$ 函数定义如下：

如果 $k$ 有平方因子 $f(k)=0$，否则 $f(k)=1$。

**Update:平方因子定义 如果存在一个整数 $k(k>1),k^2|n$ 则 $k$ 是 $n$ 的一个平方因子** 

**请输出答案对 $998244353$ 取模的值。**

## 说明/提示

|  测试点|$n$  |$k$  |
| :----------: | :----------: | :----------: |
| $1,2$ |$\leq10^3$  |$\leq10^3$  |
| $3,4$ |$\leq2 \times 10^3$  |$\leq10^{18}$  |
| $5 \sim8$ | $\leq5 \times 10^4$ |$\leq10^{18}$  |
| $9$ |$\leq 5\times10^6$  |$=1$  |
| $10,11$ |$\leq 5\times10^6$  | $=2$ |
| $12,13$ | $\leq 5\times10^6$ | $\leq10^3$ |
| $14 \sim20$ | $\leq 5\times10^6$ | $\leq10^{18}$ |

对于 $100\%$ 的数据，$1 \leq n \leq 5 \times 10^6$，$1 \leq k \leq 10^{18}$。

**Update on 2020/3/16:**

时间调至 $1$s,卡掉了 $O(n\log k)$,$O(n\log mod)$ 的做法。

## 样例 #1

### 输入

```
3 3```

### 输出

```
1216```

## 样例 #2

### 输入

```
2 6```

### 输出

```
9714```

## 样例 #3

### 输入

```
18 2```

### 输出

```
260108```

## 样例 #4

### 输入

```
143 1```

### 输出

```
7648044```

# 题解

## 作者：CYJian (赞：34)

yysy，这个题出的不太到位。

存在 $O(n)$ 预处理 $O(\sqrt n)$ 单次询问的做法，多测不香么...反倒放了暴力 $O(n^{3/4})$ 过...

---

这个题推柿子的部分较为简单，就简单写写吧。

$$\sum_{i=1}^{n}\sum_{j=1}^{n} (i+j)^k \mu^2((i,j))(i,j)$$

$$\sum_{d=1}^{n}\mu^2(d)d^{k+1}\sum_{i=1}^{n/d}\sum_{j=1}^{n/d}(i+j)^k[(i,j)=1]$$

$$\sum_{d=1}^{n}\mu^2(d)d^{k+1}\sum_{t=1}^{n/d}\mu(t)t^k\sum_{i=1}^{n/td}\sum_{j=1}^{n/td} (i+j)^k$$

令 $S(x)=\sum_{i=1}^{x}\sum_{j=1}^{x} (i+j)^k$。

$$ \sum_{d=1}^{n}\sum_{t=1}^{n/d}t^kd^{k+1}\mu(t)\mu^2(d)S(\frac{n}{td}) $$

令 $T = td$：

$$ \sum_{T=1}^{n}T^kS(\frac{n}T)\sum_{d|T}d\mu^2(d)\mu(\frac{T}{d}) $$

---

然后考虑快速预处理需要的东西：

先考虑快速求 $S(x)$：

令 $F(n) = \sum_{i=1}^{n} i^k$，$G(n) = \sum_{i=1}^{n}F(i)$。

则有：$S(n) = \sum_{i=n+1}^{2n}F(i)-\sum_{i=1}^{n}F(i)=G(2n)-2G(n)$。

自然数 $k$ 次幂可以 $O(n)$ 用欧拉筛筛出来。

然后一次前缀和求 $F(x)$ 之后，再做前缀和就能求 $S(x)$ 了。

再考虑 $f(n) = \sum_{d|n}d \mu^2(d)\mu(\frac{n}{d})$：由于是一堆积性函数的狄利克雷卷积的形式，则 $f(n)$ 也一定是积性函数。

考虑欧拉筛筛中 $x$ 时，枚举到的质因数是 $p$。从 $\mu$ 函数着手考虑，则讨论 $p$ 在 $x$ 中的最高次幂因子：假设 $p^k \mid x$ 且有 $p^{k+1} \nmid x$：

根据积性函数性质，则有：$f(x) = f(p^k) \times f(\frac{x}{p^k})$。

讨论一下 $f(p^k)$ 的取值：

- $k=0$，即 $f(1)$ 的取值一定为 $1$。
- $k=1$，则 $f(p) = 1 \mu^2(1) \mu(p) + p \mu^2(p) \mu(1) = p-1$。
- $k=2$，则 $f(p^2) = 1 \mu^2(1) \mu(p^2) + p \mu^2(p) \mu(p) + p^2 \mu^2(p^2) \mu(1)=-p$。
- $k \ge 3$，由于鸽笼原理，此时 $d$ 和 $\frac{x}{d}$ 中至少有一个能被 $p^2$ 整除，则那一个的 $\mu$ 的值为 $0$。所以此时 $f(p^k)=0$。

然后就可以通过判断 $k$ 的数值来计算 $f(x)$ 了。

$\rm Code$：

```cpp
const int MAXN = 10000010;
const int mod = 998244353;

inline int Mod(int x) { return x >= mod ? x - mod : x; }
inline void Add(int&x, int y) { x += y, x -= x >= mod ? mod : 0; }
inline int fsp(int x, int k) {
	int s = 1;
	while(k) {
		if(k & 1) s = 1LL * s * x % mod;
		x = 1LL * x * x % mod, k >>= 1;
	} return s;
}

int tot;
int pri[MAXN / 10];
bitset<MAXN>chk;
int f[MAXN];
int F[MAXN];

inline void Sieve(int n, int k) {
	f[1] = F[1] = 1;
	for(int i = 2; i <= n; i++) {
		if(!chk[i]) pri[++tot] = i, f[i] = i - 1, F[i] = fsp(i, k);
		for(int j = 1; j <= tot; j++) {
			if(i * pri[j] > n) break;
			int p = i * pri[j];
			chk[p] = 1;
			F[p] = 1LL * F[i] * F[pri[j]] % mod;
			if(i % pri[j] == 0) {
				int q = i / pri[j];
				if(q % pri[j])
					f[p] = 1LL * (mod - pri[j]) * f[q] % mod;
				break;
			} f[p] = 1LL * f[i] * (pri[j] - 1) % mod;
		}
	}
	for(int i = 2; i <= n; i++) f[i] = (f[i - 1] + 1LL * f[i] * F[i]) % mod, Add(F[i], F[i - 1]);
	for(int i = 2; i <= n; i++) Add(F[i], F[i - 1]);
}

inline int Calc(int n) {
	return Mod(F[n << 1] + mod - Mod(F[n] << 1));
}

int main() {
	int n = ri, k = rl % (mod - 1), res = 0;
	Sieve(n << 1, k);
	for(int l = 1, r; l <= n; l = r + 1) {
		r = n / (n / l);
		res = (res + 1LL * (f[r] - f[l - 1] + mod) * Calc(n / l)) % mod;
	} cout << res << endl;
	return 0;
}
```

---

## 作者：GoPoux4 (赞：14)

安利一下博客：[题解 P6156 【简单题】](https://www.cnblogs.com/syc233/p/13574165.html)

---

updated in 2020.8.31 ：新增一种 $S(n)=G(2n)-2\times G(n)$ 的证明方法。

---

简单题（确信）

---

不难发现：
$$
f(n)=\mu^2(n)
$$
把这个代进原式，然后开始推式子：
$$
\begin{aligned}
\text{Ans}&=\sum_{i=1}^n\sum_{j=1}^n(i+j)^k\mu^2({\rm{gcd}}(i,j)){\rm{gcd}}(i,j)\\
&=\sum_{d=1}^n\sum_{i=1}^n\sum_{j=1}^n(i+j)^k\mu^2(d)d[{\rm{gcd}}(i,j)=d]\\
&=\sum_{d=1}^nd^{k+1}\mu^2(d)\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{n}{d}\rfloor}(i+j)^k\sum_{x|i,x|j}\mu(x)\\
&=\sum_{d=1}^nd^{k+1}\mu^2(d)\sum_{x=1}^{\lfloor\frac{n}{d}\rfloor}\mu(x)x^k\sum_{i=1}^{\lfloor\frac{n}{dx}\rfloor}\sum_{j=1}^{\lfloor\frac{n}{dx}\rfloor}(i+j)^k
\end{aligned}
$$
令 $S(n)=\sum_{i=1}^n\sum_{j=1}^n(i+j)^k$ ，代入：
$$
\begin{aligned}
\text{Ans}&=\sum_{d=1}^nd^{k+1}\mu^2(d)\sum_{x=1}^{\lfloor\frac{n}{d}\rfloor}\mu(x)x^kS(\lfloor\frac{n}{dx}\rfloor)\\
&=\sum_{T=1}^nS(\lfloor\frac{n}{T}\rfloor)\sum_{d|T}d^{k+1}\mu^2(d)\mu(\frac{T}{d})(\frac{T}{d})^k\\
&=\sum_{T=1}^nS(\lfloor\frac{n}{T}\rfloor)\sum_{d|T}d\mu^2(d)\mu(\frac{T}{d})T^k
\end{aligned}
$$
~~都是套路~~。

令 $f(n)=\sum_{d|n}d\mu^2(d)\mu(\frac{n}{d})$ 。

如果我们能求得 $S(n)$ 和 $\sum_{i=1}^nf(i)$ ，再用一下数论分块就做完了。

---

先考虑如何求 $S(n)$ 。

令 $F(n)=\sum_{i=1}^ni^k,G(n)=\sum_{i=1}^nF(i)$ ，则有：
$$
S(n)=\sum_{i=n+1}^{2n}F(i)-\sum_{i=1}^nF(i)=G(2n)-2\times G(n)
$$
证明：

考虑枚举 $x=i+j$  。将 $S(n)=\sum_{i=1}^n\sum_{j=1}^n(i+j)^k$ 和式展开，找找规律，发现：

* 若 $x \leq n+1$ ，则有 $x-1$ 个数对 $(i,j)(1 \leq i,j \leq n)$ 能表示出 $x$ ，则此时 $x$ 对 $S(n)$ 的贡献是 $x-1$ 。
* 若 $n+1 <x \leq 2n$ ，设 $x=n+i \ (2 \leq i \leq n)$ 则有 $n-i+1$ 个数对 $(i,j)(1 \leq i,j \leq n)$ 能表示出 $x$ ，则此时 $x$ 对 $S(n)$ 的贡献是 $n-i+1$ 。

则有：
$$
\begin{aligned}
S(n)&=\sum_{i=2}^{n+1}(i-1)*i^k+\sum_{i=2}^{n}(n-i+1)(n+i)^k\\
&=2^k+2\times 3^k+\cdots+n\times (n+1)^k+(n-1)\times(n+2)^k+(n-2)\times(n+3)^k+\cdots+(2n)^k
\end{aligned}
$$
我们再把要证明的式子展开：
$$
\begin{aligned}
S(n)&=\sum_{i=n+1}^{2n}\sum_{j=1}^ij^k-\sum_{i=1}^n\sum_{j=1}^ij^k\\
&=n\times1^k+n\times 2^k+n\times3^k+\cdots+n\times(n+1)^k+(n-1)\times(n+2)^k+\cdots+(2n)^k-\\
&(n\times 1^k+(n-1)\times 2^k+(n-2)\times 3^k+\cdots+n^k)\\
&=2^k+2\times 3^k+\cdots+n\times (n+1)^k+(n-1)\times(n+2)^k+(n-2)\times(n+3)^k+\cdots+(2n)^k
\end{aligned}
$$
所以 $S(n)=\sum_{i=n+1}^{2n}F(i)-\sum_{i=1}^nF(i)$ 。

然后发现这东西能用**数学归纳法**证明，上面这东西太暴力了。

当 $n=1$ 时， $S(1)=G(2)-2G(1)$ 显然成立。

假设 $S(n)=G(2n)-2\times G(n)$ 成立，证明 $S(n+1)=G(2n+2)-2\times G(n+1)$ 成立：
$$
\begin{aligned}
S(n+1)&=S(n)+2\times\sum_{i=1}^n(i+n+1)^k+(2n+2)^k\\
&=S(n)+2\times F(2n+1)-2\times F(n+1)+F(2n+2)-F(2n+1)\\
&=S(n)+F(2n+2)+F(2n+1)-2\times F(n+1)\\
&=G(2n)-2\times G(n)+F(2n+2)+F(2n+1)-2\times F(n+1)\\
&=G(2n)+F(2n+1)+F(2n+2)-2\times G(n)-2\times F(n+1)\\
&=G(2n+2)-2\times G(n+1)
\end{aligned}
$$
证毕。

线性筛出 ${\rm{id}}_k$ 再做两次前缀和，就能做到 $O(1)$ 询问 $S(n)$ 。

---

$$
f(n)=\sum_{d|n}d\mu^2(d)\mu(\frac{n}{d})
$$

这东西就是几个积性函数卷起来，所以 $f$ 也是积性函数，可以线性筛。

对于质数 $p$ ，有 $f(p)=\mu(p)+p\mu^2(p)=p-1$ 。

对于 $p^k$ ，对 $k$ 进行分类讨论：

*  若 $k=2$ ，有 $f(p^2)=\mu(p^2)+p\mu^2(p)\mu(p)+p^2\mu^2(p^2)=-p$ 。
* 若 $k>2$ ，对于任意 $d$ ，都有 $d$ 或 $\frac{n}{d}$ 有平方因子，所以 $f(p^k)=0$ 。

然后就可以线性筛筛 $f$ 了：

```cpp
inline void sieve()
{
	f[1]=1;
	for(int i=2;i<maxn;++i)
	{
		if(!flag[i]) prime[++cnt]=i,f[i]=i-1;
		for(int j=1;j<=cnt&&i*prime[j]<maxn;++j)
		{
			flag[i*prime[j]]=true;
			if(i%prime[j]) f[i*prime[j]]=f[i]*f[prime[j]]%mod;// 积性函数
			else
			{
				if((i/prime[j])%prime[j])// 互质则用积性函数的性质
                    f[i*prime[j]]=(mod-prime[j])*f[i/prime[j]]%mod;
                // 不互质则说明prime[j]的次数大于2
				break;
			}
		}
	}
}
```

---

$\text{Code}:$

```cpp
#include <iostream>
#include <cstring>
#include <cstdio>
#include <algorithm>
#include <cmath>
#define maxn 10000005
#define Rint register int
#define INF 0x3f3f3f3f
using namespace std;
typedef long long lxl;
const lxl mod=998244353;

template <typename T>
inline T read()
{
	T x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9') {if(ch=='-') f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9') {x=(x<<1)+(x<<3)+ch-'0';ch=getchar();}
	return x*f;
}

inline lxl fmi(lxl a,lxl b)
{
	lxl ans=1;
	a%=mod;
	while(b>0)
	{
		if(b&1) ans=(ans*a)%mod;
		a=(a*a)%mod;
		b>>=1;
	}
	return ans;
}

int n;
lxl k;

int prime[maxn],cnt;
bool flag[maxn];
lxl f[maxn],F[maxn];

inline void sieve()
{
	f[1]=F[1]=1;
	for(int i=2;i<maxn;++i)
	{
		if(!flag[i]) prime[++cnt]=i,f[i]=i-1,F[i]=fmi(i,k);
		for(int j=1;j<=cnt&&i*prime[j]<maxn;++j)
		{
			flag[i*prime[j]]=true;
			F[i*prime[j]]=F[i]*F[prime[j]]%mod;
			if(i%prime[j]) f[i*prime[j]]=f[i]*f[prime[j]]%mod;
			else
			{
				if((i/prime[j])%prime[j])
                    f[i*prime[j]]=(mod-prime[j])*f[i/prime[j]]%mod;
				break;
			}
		}
	}
	for(int i=1;i<maxn;++i) f[i]=(f[i-1]+f[i]*F[i]%mod)%mod,F[i]=(F[i]+F[i-1])%mod;
	for(int i=1;i<maxn;++i) F[i]=(F[i]+F[i-1])%mod;
}

inline lxl S(int n)
{
	return (F[n<<1]-2*F[n]%mod+mod)%mod;
}

inline lxl calcu(lxl n)
{
	lxl res=0;
	for(lxl l=1,r=0;l<=n;l=r+1)
	{
		r=n/(n/l);
		res=(res+S(n/l)*(f[r]-f[l-1]+mod)%mod)%mod;
	}
	return res;
}

int main()
{
	// freopen("P6156.in","r",stdin);
	n=read<int >(),k=read<lxl >();
	sieve();
	printf("%lld\n",calcu(n));
	return 0;
}

```



---

## 作者：Aleph1022 (赞：9)

同步发表于我的博客：<https://www.alpha1022.me/articles/lg-6156.htm>

yysy，确实是个简单题，而且很套路（

首先显然 $f = \mu^2$。  
那么
$$\begin{aligned}\sum\limits_{i=1}^n \sum\limits_{j=1}^n (i+j)^k \mu^2(\gcd(i,j))\gcd(i,j)&= \sum\limits_{d=1}^n \mu^2(d) d \sum\limits_{i=1}^n \sum\limits_{j=1}^n [\gcd(i,j)=d] (i+j)^k \\ &= \sum\limits_{d=1}^n \mu^2(d) d^{k+1} \sum\limits_{i=1}^{\left\lfloor\frac nd\right\rfloor} \sum\limits_{j=1}^{\left\lfloor\frac nd\right\rfloor} [\gcd(i,j)=1] (i+j)^k \\ &= \sum\limits_{d=1}^n \mu^2(d) d^{k+1} \sum\limits_{i=1}^{\left\lfloor\frac nd\right\rfloor} \sum\limits_{j=1}^{\left\lfloor\frac nd\right\rfloor} (i+j)^k \sum\limits_{u|\gcd(i,j)} \mu(u) \\ &= \sum\limits_{d=1}^n \mu^2(d) d^{k+1} \sum\limits_{u=1}^{\left\lfloor\frac nd\right\rfloor} \mu(u)u^k \sum\limits_{i=1}^{\left\lfloor\frac n{du}\right\rfloor} \sum\limits_{j=1}^{\left\lfloor\frac n{du}\right\rfloor} (i+j)^k \end{aligned}$$

注意到可以数论分块套数论分块，则这一部分的复杂度为 $O(n^{3/4})$。  
则我们需要求得 $\mu^2(i)i^{k+1},\mu(i)i^k$ 的前缀和，并对于所有 $n'$ 求出 $\sum\limits_{i=1}^{n'} \sum\limits_{j=1}^{n'} (i+j)^k$。  
前两个线性筛出所有的 $\mu(i),i^k$ 即可计算，最后一个考虑观察其关于 $n'$ 差分后的结果：
$$\begin{aligned}\sum\limits_{i=1}^{n+1} \sum\limits_{j=1}^{n+1} (i+j)^k - \sum\limits_{i=1}^n \sum\limits_{j=1}^n (i+j)^k&= \sum\limits_{i=1}^n \sum\limits_{j=1}^{n+1} (i+j)^k + \sum\limits_{j=1}^{n+1} (n+1+j)^k - \sum\limits_{i=1}^n \sum\limits_{j=1}^n (i+j)^k \\&= \sum\limits_{i=1}^n \left(\sum\limits_{j=1}^{n+1} (i+j)^k - \sum\limits_{j=1}^n (i+j)^k\right) + \sum\limits_{j=1}^{n+1} (n+1+j)^k \\&= \sum\limits_{i=1}^n (i+n+1)^k + \sum\limits_{j=1}^{n+1} (n+1+j)^k\end{aligned}$$

于是这个也可以 $O(n)$ 递推求得。  
总时间复杂度 $O(n)$。

代码：
```cpp
#include <cstdio>
#define add(x,y) (x + y >= mod ? x + y - mod : x + y)
#define dec(x,y) (x < y ? x - y + mod : x - y)
using namespace std;
const int N = 1e7;
const int mod = 998244353;
inline int fpow(int a,int b)
{
    int ret = 1;
    for(;b;b >>= 1)
        (b & 1) && (ret = (long long)ret * a % mod),a = (long long)a * a % mod;
    return ret;
}
int n,k;
int vis[N + 5],cnt,prime[N + 5],mu[N + 5],pw[N + 5];
int sum[3][N + 5],ans;
int main()
{
    long long x;
    scanf("%d%lld",&n,&x),k = x % (mod - 1),n <<= 1,mu[1] = pw[1] = 1;
    for(register int i = 2;i <= n;++i)
    {
        if(!vis[i])
            mu[prime[++cnt] = i] = mod - 1,pw[i] = fpow(i,k);
        for(register int j = 1;j <= cnt && i * prime[j] <= n;++j)
        {
            vis[i * prime[j]] = 1,pw[i * prime[j]] = (long long)pw[i] * pw[prime[j]] % mod;
            if(!(i % prime[j]))
                break;
            mu[i * prime[j]] = dec(0,mu[i]);
        }
    }
    n >>= 1;
    for(register int i = 1;i <= n;++i)
        sum[0][i] = (sum[0][i - 1] + (long long)mu[i] * mu[i] % mod * pw[i] % mod * i % mod) % mod,
        sum[1][i] = (sum[1][i - 1] + (long long)mu[i] * pw[i] % mod) % mod;
    n <<= 1;
    for(register int i = 1;i <= n;++i)
        pw[i] = (pw[i - 1] + pw[i]) % mod;
    n >>= 1;
    for(register int i = 1;i <= n;++i)
        sum[2][i] = add(sum[2][i - 1],dec(pw[i << 1],pw[i])),
        sum[2][i] = add(sum[2][i],dec(pw[(i << 1) - 1],pw[i]));
    for(register int L = 1,R,s;L <= n;L = R + 1)
    {
        R = n / (n / L),s = 0;
        for(register int l = 1,r,m = n / L;l <= m;l = r + 1)
        {
            r = m / (m / l);
            s = (s + (long long)(sum[1][r] - sum[1][l - 1] + mod) * sum[2][m / l] % mod) % mod;
        }
        ans = (ans + (long long)(sum[0][R] - sum[0][L - 1] + mod) * s % mod) % mod;
    }
    printf("%d\n",ans);
}
```

---

## 作者：wsyhb (赞：5)

## 题解

枚举 $\gcd=d$，则答案为：

$$\sum_{d=1}^{n}d\mu^2(d)\sum_{i=1}^{\lfloor \frac{n}{d} \rfloor}\sum_{j=1}^{\lfloor \frac{n}{d} \rfloor}(di+dj)^{k}[\gcd(i,j)=1]$$

将 $[m=1]=\sum_{x \mid m} \mu(x)$ 代入，并将 $d^k$ 提到前面来：

$$\sum_{d=1}^{n}d^{k+1}\mu^2(d)\sum_{i=1}^{\lfloor \frac{n}{d} \rfloor}\sum_{j=1}^{\lfloor \frac{n}{d} \rfloor}(i+j)^{k}\sum_{x \mid i,x \mid j}\mu(x)$$

交换求和符号：

$$\sum_{d=1}^{n}d^{k+1}\mu^2(d)\sum_{x=1}^{\lfloor \frac{n}{d} \rfloor}\mu(x)\sum_{i=1}^{\lfloor \frac{n}{dx} \rfloor}\sum_{j=1}^{\lfloor \frac{n}{dx} \rfloor}(xi+xj)^{k}$$

把 $x^{k}$ 提到前面来：

$$\sum_{d=1}^{n}d^{k+1}\mu^2(d)\sum_{x=1}^{\lfloor \frac{n}{d} \rfloor}x^{k}\mu(x)\sum_{i=1}^{\lfloor \frac{n}{dx} \rfloor}\sum_{j=1}^{\lfloor \frac{n}{dx} \rfloor}(i+j)^{k}$$

令 $T=dx$，并改为枚举 $T$ 和 $d$：

$$\sum_{T=1}^{n}(\sum_{i=1}^{\lfloor \frac{n}{T} \rfloor}\sum_{i=1}^{\lfloor \frac{n}{T} \rfloor}(i+j)^{k})(\sum_{d \mid T}d^{k+1}\mu^2(d)(\frac{T}{d})^k\mu(\frac{T}{d}))$$

P.S. 这一个式子中 $i,j$ 的上界是 $\lfloor \dfrac{n}{T} \rfloor$。（下同）

用 $dT^k$ 替换 $d^{k+1}(\dfrac{T}{d})^k$，并将 $T^k$ 提到外面来：

$$\sum_{T=1}^{n}(\sum_{i=1}^{\lfloor \frac{n}{T} \rfloor}\sum_{i=1}^{\lfloor \frac{n}{T} \rfloor}(i+j)^{k})(\sum_{d \mid T}d\mu^2(d)\mu(\frac{T}{d}))T^{k}$$

令：

$$F(t)=\sum_{i=1}^{t}\sum_{j=1}^{t}(i+j)^{k}$$

$$G(t)=\sum_{d \mid t}d\mu^2(d)\mu(\frac{t}{d})$$

则答案为：

$$\sum_{T=1}^{n}F(\lfloor \frac{n}{T} \rfloor )G(T)T^{k}$$

------------

先考虑 $F$ 怎么求。

我们将 $F$ 相邻两项作差：

$$F(t)-F(t-1)=\sum_{i=1}^{t}(i+t)^k+\sum_{j=1}^{t-1}(t+j)^{k}=\sum_{i=t+1}^{2t}i^k+\sum_{i=t+1}^{2t-1}i^k$$

**线性筛**预处理 $k$ 次方幂并求前缀和，那么 $F$ 就可以 $O(n)$ 递推。

------------

再考虑 $G$ 怎么求。

设 $x=p_1^{\alpha_1}p_2^{\alpha_2}\cdots p_k^{\alpha_k}$，其中 $p_i \; (1 \le i \le k)$ 为互不相同的质数且 $\alpha_i>0 \; (1 \le i \le k)$。

令 $g(x)=x \cdot \mu^2(x)$，则 $G=g * \mu$。（$*$ 表示**狄利克雷卷积**，其定义及性质可参考：[OI Wiki - Dirichlet 卷积](https://oi-wiki.org//math/number-theory/mobius/#dirichlet)）

考虑 $k=1$ 的情况：

1. 若 $\alpha_1=1$，则 $G(x)=g(1)\mu(p_1)+g(p_1)\mu(1)=p_1-1$。
1. 若 $\alpha_1=2$，则 $G(x)=g(p_1)\mu(p_1)=-p_1$。（当 $g$ 或 $\mu$ 的自变量含有平方因子时，其对应的因变量值为 $0$，因此 $g$ 和 $\mu$ 的因变量必须各含一个 $p_1$）
1. 若 $\alpha_1>2$，则 $G(x)=0$。（根据抽屉原理，$g$ 或 $\mu$ 中至少有一个含有平方因子）

由于 $\mu(x)$ 是积性的，$g(x)=x \cdot \mu^2(x)$ 也是积性的，所以 $G=g * \mu$ 也是积性的。

于是我们得出了一般化的 $G$ 的表达式：

$$G(x)=\prod_{i=1}^{k}([\alpha_i=1](p_i-1)+[\alpha_i=2](-p_i))$$

其中 $x=p_1^{\alpha_1}p_2^{\alpha_2}\cdots p_k^{\alpha_k}$。

由于 $G$ 是积性函数，我们可以使用**线性筛**求 $G$。（当然也可以用**埃氏筛**）

具体而言：**记录每个数的最小质因子的指数**，用于更新 $i \bmod \mathit{prime}(j)=0$ 时的 `G[i*prime[j]]`：

``` cpp
G[1]=1;
for(int i=2;i<=n;++i)
{
	if(mark_p[i])
	{
		prime[++cnt]=i;
		G[i]=i-1;
		expo[i]=1;
	}
	for(int j=1;j<=cnt&&i*prime[j]<=n;++j)
	{
		mark_p[i*prime[j]]=false;
		if(i%prime[j]==0)
		{
			if(expo[i]==1)
				G[i*prime[j]]=1ll*G[i/prime[j]]*(mod-prime[j])%mod;
			else
				G[i*prime[j]]=0;
			expo[i*prime[j]]=expo[i]+1;
			break;
		}
		G[i*prime[j]]=1ll*G[i]*G[prime[j]]%mod;
		expo[i*prime[j]]=1;
	}
}
```

（此处数组 `mark_p` 为 `bool` 类型，且初值为 `true`）

------------

在花 $O(n)$ 的时间预处理好 $F$ 和 $G$ 之后，对 $G$ 求前缀和，即可使用整除分块，在 $O(\sqrt{n})$ 时间内回答单个询问。

由于本题只有一个询问，因此总时间复杂度为 $O(n+\sqrt{n})$。

## 代码

``` cpp
#include<bits/stdc++.h>
using namespace std;
const int mod=998244353;
inline int qpow(int a,int n)
{
	int res=1;
	while(n)
	{
		if(n&1)
			res=1ll*res*a%mod;
		a=1ll*a*a%mod;
		n>>=1;
	}
	return res;
}
int n;
long long k;
const int max_n=5e6+5;
bool mark_p[max_n<<1];
const int max_cnt=664579+5;
int prime[max_cnt],cnt,Pow[max_n<<1],sum_Pow[max_n<<1],F[max_n],G[max_n],sum[max_n],expo[max_n];
inline void init()
{
	int m=n<<1;
	for(int i=2;i<=m;++i)
		mark_p[i]=true;
	Pow[1]=sum_Pow[1]=1;
	for(int i=2;i<=m;++i)
	{
		if(mark_p[i])
		{
			prime[++cnt]=i;
			Pow[i]=qpow(i,k);
		}
		for(int j=1;j<=cnt&&i*prime[j]<=m;++j)
		{
			mark_p[i*prime[j]]=false;
			Pow[i*prime[j]]=1ll*Pow[i]*Pow[prime[j]]%mod;
			if(i%prime[j]==0)
				break;
		}
		sum_Pow[i]=sum_Pow[i-1]+Pow[i];
		sum_Pow[i]-=sum_Pow[i]>=mod?mod:0;
	}
	cnt=0;
	G[1]=1;
	for(int i=2;i<=n;++i)
	{
		if(mark_p[i])
		{
			prime[++cnt]=i;
			G[i]=i-1;
			expo[i]=1;
		}
		for(int j=1;j<=cnt&&i*prime[j]<=n;++j)
		{
			mark_p[i*prime[j]]=false;
			if(i%prime[j]==0)
			{
				if(expo[i]==1)
					G[i*prime[j]]=1ll*G[i/prime[j]]*(mod-prime[j])%mod;
				else
					G[i*prime[j]]=0;
				expo[i*prime[j]]=expo[i]+1;
				break;
			}
			G[i*prime[j]]=1ll*G[i]*G[prime[j]]%mod;
			expo[i*prime[j]]=1;
		}
	}
	for(int i=1;i<=n;++i)
	{
		F[i]=(1ll*F[i-1]+sum_Pow[i<<1]+sum_Pow[(i<<1)-1]-(sum_Pow[i]<<1)+(mod<<1))%mod;
		sum[i]=(sum[i-1]+1ll*G[i]*Pow[i])%mod;
	}
}
int main()
{
	scanf("%d%lld",&n,&k);
	k%=mod-1;
	init();
	int ans=0;
	for(int i=1,j;i<=n;i=j+1)
	{
		int v=n/i;
		j=n/v;
		ans=(ans+1ll*F[v]*(sum[j]-sum[i-1]+mod))%mod;
	}
	printf("%d\n",ans); 
	return 0;
}
```

---

## 作者：chihik (赞：4)

$$\sum_{i=1}^n \sum_{j=1}^n (i+j)^k f(\gcd(i,j)) \gcd(i,j)$$

显然 $f(i)=\mu^2(i)$

$$\sum_{i=1}^n \sum_{j=1}^n (i+j)^k \mu^2(\gcd(i,j)) \gcd(i,j)$$

$$\sum_{d=1}^n\sum_{i=1}^n \sum_{j=1}^n [\gcd(i,j)=d](i+j)^k \mu^2(d) d$$

$$\sum_{d=1}^n d^{k+1}\mu^2(d)\sum_{i=1}^{\lfloor \frac{n}{d} \rfloor} \sum_{j=1}^{\lfloor \frac{n}{d} \rfloor} [\gcd(i,j)=1](i+j)^k $$

$$\sum_{d=1}^n d^{k+1}\mu^2(d)\sum_{t=1}^{\lfloor \frac{n}{d} \rfloor}\mu(t)t^k\sum_{i=1}^{\lfloor \frac{n}{td} \rfloor} \sum_{j=1}^{\lfloor \frac{n}{td} \rfloor}(i+j)^k $$

$$\sum_{d=1}^n \sum_{t=1}^{\lfloor \frac{n}{d} \rfloor}(dt)^{k}\mu^2(d)\mu(t)d\sum_{i=1}^{\lfloor \frac{n}{td} \rfloor} \sum_{j=1}^{\lfloor \frac{n}{td} \rfloor}(i+j)^k $$

令 $T=td  ~,~ S(n)=\sum_{i=1}^n\sum_{j=1}^n(i+j)^k$

$$\sum_{T=1}^n S( \lfloor \frac{n}{T} \rfloor) T^k\sum_{d|T} d\mu^2(d)\mu(\frac{T}{d})$$

令 $f(n)=\sum_{d|n} d\mu^2(d)\mu(\frac{n}{d})$

$$\sum_{T=1}^n S( \lfloor \frac{n}{T} \rfloor) T^kf(T)$$

推导的部分就结束了。

***

将$S(n)$换一种写法：

$$S(n)=\sum_{i=1}^{2n} a_ii^k$$

其中 $a_i$ 为 $i^k$ 出现的次数。可以发现：

$$a_i=\begin{cases}
i-1 & i\le n \\
2n-i+1 & i>n
\end{cases}$$

再令 $t(n)=\sum_{i=1}^n\sum_{j=1}^i j^k=\sum_{i=1}^n (n-i+1)i^k$

对比系数发现: $S(n)=t(2n)-2t(n)$

另外一个 $f$ 是一个积性函数，可以线筛。

```cpp
#include <cstdio>
#define Mod 998244353

const int MAXN = 1e7;
int n , k , cnt , prime[ MAXN + 5 ] , f[ MAXN + 5 ] , s[ MAXN + 5 ];
bool vis[ MAXN + 5 ];

int Quick_pow( int x , int po ) {
    int Ans = 1;
    for( ; po ; po >>= 1 , x = 1ll * x * x % Mod )
        if( po & 1 ) Ans = 1ll * Ans * x % Mod;
    return Ans;
}

void sieve( ) {
    f[ 1 ] = s[ 1 ] = 1;
    for( int i = 2 ; i <= MAXN ; i ++ ) {
        if( !vis[ i ] ) {
            prime[ ++ cnt ] = i;
            s[ i ] = Quick_pow( i , k );
            f[ i ] = i - 1;
        }
        for( int j = 1 ; j <= cnt && 1ll * i * prime[ j ] <= MAXN ; j ++ ) {
            vis[ i * prime[ j ] ] = 1;
            s[ i * prime[ j ] ] = 1ll * s[ i ] * s[ prime[ j ] ] % Mod;
            if( i % prime[ j ] == 0 ) {
                if( i / prime[ j ] % prime[ j ] != 0 )
                    f[ i * prime[ j ] ] = ( 1ll * -prime[ j ] * f[ i / prime[ j ] ] % Mod + Mod ) % Mod;
                break;
            } 
            f[ i * prime[ j ] ] =  1ll * f[ i ] * f[ prime[ j ] ] % Mod;
        }
    } 
    for( int i = 2 ; i <= MAXN ; i ++ ) {
        f[ i ] = ( 1ll * f[ i ] * s[ i ] % Mod + f[ i - 1 ] ) % Mod;
        s[ i ] = ( s[ i ] + s[ i - 1 ] ) % Mod;
    }
    for( int i = 2 ; i <= MAXN ; i ++ )
        s[ i ] = ( s[ i ] + s[ i - 1 ] ) % Mod;
}

int Sum( int n ) {
    return ( ( s[ 2 * n ] - 2ll * s[ n ] ) % Mod + Mod ) % Mod;
}

int Solve( int n ) {
    int Ans = 0;
    for( int l = 1 , r ; l <= n ; l = r + 1 ) {
        r = n / ( n / l );
        Ans = ( Ans + 1ll * ( f[ r ] - f[ l - 1 ] + Mod ) % Mod * Sum( n / l ) % Mod ) % Mod;
    }
    return Ans;
}

int main( ) {
    long long t;
    scanf("%d %lld",&n,&t); k = t % ( Mod - 1 );
    sieve( );
    printf("%d\n", Solve( n ) );
    return 0;
}
```


---

## 作者：gyh20 (赞：4)

算法 $1$：

枚举并求出值即可。时间复杂度 $O(n^2logk+n^2\sqrt n)$。

期望得分:$10$。

算法 $2$:

在算法 $1$ 的基础上预处理函数的值 $O(n^2)$。

期望得分:$20$。

算法 $3$:

开始反演了。

可以轻易得知，$f(i)= \mu^2(i)$。

于是原式可变为：

$\sum\limits_{i=1}^n\sum\limits_{j=1}^m(i+j)^k\mu^2(\gcd(i,j))\gcd(i,j)$

=$\sum\limits_{d}d^k\sum\limits_{i=1}^{n/d}\sum\limits_{j=1}^{n/d}(i+j)^k\mu^2(d)d[\gcd(i,j)==1]$

=$\sum\limits_{d}d^{k+1}\mu^2(d)\sum\limits_{i=1}^{n/d}\sum\limits_{j=1}^{n/d}(i+j)^k \sum\limits_{p|i,p|j}\mu(p)$

=$\sum\limits_p\mu(p)p^k\sum\limits_{d}d^{k+1}\mu^2(d)\sum\limits_{i=1}^{n/dp}\sum\limits_{j=1}^{n/dp}(i+j)^k $

=$\sum\limits_TT^k\sum\limits_{d|T}d\mu^2(d)\mu(T/d)g(n/dp)$

其中 $g(x)=\sum\limits_{i=1}^x\sum\limits_{j=1}^x(i+j)^k$。

前面这一块又是一个积性函数，可以线性筛。

构造 $h(T)=\sum\limits_TT^k\sum\limits_{d|T}d\mu^2(d)\mu(T/d)$。

再求前缀和，之后用整除分块。

注意，本题的 $n$ 很大，$i^k$ 也要线性筛，由于质数不多，可以近似于 $O(n)$。

解决完 $h$，再来看看 $g$。

直接求值是 $n^2$ 的，我们可以改为枚举 $(i+j)$ 的值，之前线性筛可以求出 $k$ 次方的值，单次询问为 $O(n)$。

使用整除分块，需要求 $g(n/1),g(n/2),g(n/3)...$，总和为 $n \ln n$。

所以总复杂度为$O(n+\sqrt n+n\ln n)$(预处理 $+$ 整除分块 $+$ 求 $g$)。

如果上述三个任有一个没做到就只能得到部分分。

**注意，因为算 $i+j$ 时答案可能会达到 $2n$，线性筛需要筛到 $2n。$**

```cpp
#pragma GCC optimize(2,3,4,5)
#include<bits/stdc++.h>
#define N 10000010
#define M 998244353
#define re register
using namespace std;
inline long long read()
{
    re long long x=0;
    re char c=getchar();
    while(c<'0'){c=getchar();}
    while(c>='0') {x=(x<<1)+(x<<3)+(c-48);c=getchar();} 
    return x;
}
bool vis[N];
int prim[N],sum[N],cnt,tot,f[N];
int kp[N];
inline int g(re int x){
	re int ans=0;
	for(re int i=1;i<=x;++i)ans=(long long)(ans+1ll*(i-1)*kp[i])%M;
	for(re int i=x+1;i<=2*x;++i)ans=(long long)(ans+1ll*(2*x+1-i)*kp[i])%M;
	return ans;
}
inline int ksm(re int p,re int b){
	re int ans=1;
	while(b){
		if(b&1)ans=1ll*ans*p%M;
		p=1ll*p*p%M;
		b>>=1;
	}
	return ans;
}
inline int solve(re int a){ 
		re int ans;
    	ans=0;
        for(re int l=1,r;l<=a;l=r+1)
        {
            r=a/(a/l);
            ans=(long long)(ans+1ll*g(a/l)*(sum[r]-sum[l-1]))%M;
        }
        if(ans<0)ans%=M,ans+=M;
        return ans;
}
inline void write(re int x){
	if(x>9)write(x/10);
	putchar((x%10)+'0');
}
signed main()
{
//	freopen("test1.in.txt","r",stdin);
//	freopen("test1.out","w",stdout);
    re int n;
	re long long k;
    f[1]=1;
    sum[1]=1;kp[1]=1;n=read();k=read()%(M-1);
    for(re int i=2;i<=n*2;++i){
    	if(!vis[i])kp[i]=ksm(i,k),f[i]=1ll*(i-1)*kp[i]%M,prim[++cnt]=i;
    	for(re int j=1;j<=cnt&&i*prim[j]<=n*2;++j)
        {
            vis[i*prim[j]]=1;
            kp[i*prim[j]]=1ll*kp[i]*kp[prim[j]]%M;
            if(i%prim[j]==0){
            	if((i/prim[j])%prim[j]){
            	f[i*prim[j]]=1ll*(-prim[j])*f[i/prim[j]]%M*kp[prim[j]*prim[j]]%M;}
            	
            	break;
			}
            else f[i*prim[j]]=1ll*f[i]*f[prim[j]]%M;
        }
        sum[i]=f[i]+sum[i-1];
        sum[i]%=M;
	}
	write(solve(n));
	putchar('\n');
}
```


---

## 作者：Prean (赞：3)

真·简单题
# 题目大意
给定 $ n $ 和 $ k $，求出这个柿子的值：
$$ \sum_{i=1}^n\sum_{j=1}^n(i+j)^k\mu^2(\gcd(i,j)gcd(i,j) $$
按照莫反的套路，我们枚举 $ \rm gcd $：
$$ \sum_{d=1}^n d \sum_{i=1}^n\sum_{j=1}^n[\gcd(i,j)=d]\mu^2(d)(i+j)^k $$
$$ \sum_{d=1}^n \mu^2(d)d \sum_{i=1}^{\lfloor \frac n d \rfloor}\sum_{j=1}^{\lfloor \frac n d \rfloor}[\gcd(i,j)=1]d^k(i+j)^k $$
来一发反演：
$$ \sum_{d=1}^n\mu^2(d)d^{k+1}\sum_{i=1}^{\lfloor \frac n d \rfloor}\sum_{j=1}^{\lfloor \frac n d \rfloor}(i+j)^k\sum_{x|i \And x|j}\mu(x) $$
$$ \sum_{d=1}^n\mu^2(d)d^{k+1}\sum_{x=1}^{\lfloor \frac n d \rfloor}\mu(x)\sum_{i=1}^{\lfloor \frac n d \rfloor}\sum_{j=1}^{\lfloor \frac n d \rfloor}x^k(i+j)^k $$
$$ \sum_{d=1}^n \mu^2(d)d^{k+1}\sum_{x=1}^{\lfloor \frac n d \rfloor}\mu(x)x^k\sum_{i=1}^{\lfloor \frac n {dx} \rfloor}\sum_{j=1}^{\lfloor \frac n {dx} \rfloor}(i+j)^k $$
设 $ f(n) = \sum_{i=1}^n\sum_{j=1}^n(i+j)^k $
$$ \sum_{d=1}^n\mu^2(d)d^{k+1}\sum_{x=1}^{\lfloor \frac n d \rfloor}\mu(x)x^kf(\frac n {dx}) $$
再考虑套路，令 $ T = dx $：
$$ \sum_{T=1}^n \sum_{x|T}\mu(x)x^k\mu^2(\frac T x)(\frac T x)^{k+1}f(\frac n T) $$
$$ \sum_{T=1}^nT^kf(\frac n T)\sum_{x|T}\mu(x)\mu^2(\frac T x)id(\frac T x) $$
后面的部分明显是狄利克雷卷积的形式
$$ \sum_{T=1}^nT^kf(\frac n T)((id·\mu^2) * \mu)(T) $$
然后我们来考虑 $ f $：
$$ \sum_{i=1}^n\sum_{j=1}^n(i+j)^k $$
经过 ~~简单~~ 复杂的推导后，发现它等于：
$$ \sum_{i=1}^{2n}\min(i,2n-i) \times i^k $$
我们再设：
$$ S(n)=\sum_{i=1}^n i^k $$
$$ sum(n)=\sum_{i=1}^nS(i) $$
就会发现：
$$ f(n) = sum(2n)-2 \times sum(n) $$
然后我们来考虑这个毒瘤的积性函数：
$$ F=((id · \mu^2) * \mu) $$
虽然可以 $ O(nlogn) $ 暴力预处理，但是显然会 $ \rm TLE $，由于这是一个积性函数，考虑对其线性筛。

$ F(p) = ((id(p) \times \mu^2(p)) * \mu(1) ) + ((id(1) \times \mu^2(1)) * \mu(p) = p - 1 $

$ F(p^2) = ((id(p^2) \times \mu^2(p^2)) * \mu(1) ) + ((id(p) \times \mu^2(p)) * \mu(p) + ((id(1) \times \mu^2(1)) * \mu(p^2) = 0 - p + 0 = -p $

因为鸽笼原理，$ F(p^e) (3 \leq e ) $ 中，要么 $ \mu^2(p^k) $ 是 $ 0 $（即 $ id(p^k) \times \mu^2(p^k) $ 是 $ 0 $），要么 $ \mu(p^{e-k}) $ 是 $ 0 $，即 $ F(p^e) = 0 (3 \leq e) $
那么我们就可以线性筛 $ F $ 了。

然后来考虑 $ S $ 和 $ sum $，容易发现 $ S $ 其实就是 $ id^k $ 的前缀和，所以能够线性筛，那么 $ sum $ 也可以在线性时间内预处理。

复杂度：预处理 $ O(n) $，询问 $ O(\sqrt n) $。

code:
```cpp
#include<cstdio>
const int M=1e7+5,mod=998244353;
int n,k,top,f[M],sum[M],pri[M],zhi[M];
inline int Add(const int&a,const int&b){
    return a+b>=mod?a+b-mod:a+b;
}
inline int pow(int a,int b){
    int ans=1;
    for(;b;b>>=1,a=1ll*a*a%mod)if(b&1)ans=1ll*a*ans%mod;
    return ans;
}
void sieve(){
    int i,j,x;
    f[1]=sum[1]=zhi[1]=1;
    for(i=2;i<=(n<<1);++i){
        if(!zhi[i])pri[++top]=i,f[i]=i-1,sum[i]=pow(i,k);
        for(j=1;j<=top&&(x=i*pri[j])<=(n<<1);++j){
            zhi[x]=1;
            sum[x]=1ll*sum[i]*sum[pri[j]]%mod;
            if(i%pri[j]){
                f[x]=1ll*f[i]*(pri[j]-1)%mod;
            }
            else{
                if(i/pri[j]%pri[j])f[x]=1ll*f[i/pri[j]]*(mod-pri[j])%mod;
                break;
            }
        }
    }
    for(i=1;i<=(n<<1);++i){
        f[i]=Add(f[i-1],1ll*f[i]*sum[i]%mod);
        sum[i]=Add(sum[i],sum[i-1]);
    }
    for(i=1;i<=(n<<1);++i)sum[i]=Add(sum[i-1],sum[i]);
}
inline int S(const int&n){
    return (sum[n<<1]-(sum[n]<<1)%mod+mod)%mod;
}
signed main(){
    int i,ans=0;
    long long tmp;
    scanf("%d%lld",&n,&tmp);
    k=tmp%(mod-1);
    sieve();
    for(int L=1,R;L<=n;L=R+1){
        R=n/(n/L);
        ans=Add(ans,1ll*(f[R]-f[L-1]+mod)%mod*S(n/L)%mod);
    }
    printf("%d",ans);
}
```

---

## 作者：bigmurmur (赞：2)

一道莫比乌斯反演套路题目，你只需要基本的反演套路。

### 一

发现 $gcd(i,j)$ 这样神奇的式子，于是考虑莫比乌斯反演。

做过几道反演的同志们可以自己先推一推，这里给出详细的过程。

这里用 $m$ 代替题面中的 $k$

$$\sum_{i=1}^n\sum_{j=1}^n(i+j)^m\ f(gcd(i,j))\ gcd(i,j)$$

$$\sum_{d=1}^n\sum_{i=1}^{\left\lfloor \frac{n}{d} \right\rfloor}\sum_{j=1}^{\left\lfloor\frac{n}{d}\right\rfloor}[gcd(i,j)=1](i+j)^md^m\ f(d)\times d$$

$$\sum_{d=1}^nf(d)\times d
^{m+1}\sum_{i=1}^{\left\lfloor\frac{n}{d}\right\rfloor}\sum_{j=1}^{\left\lfloor\frac{n}{d}\right\rfloor}\sum_{k|i}\sum_{k|j}\mu(k)\ (i+j)^m$$

$$\sum_{d=1}^nf(d)\times d
^{m+1}\sum_{k=1}^{\left\lfloor\frac{n}{d}\right\rfloor}\ \mu(k)\ \times \ k^m\sum_{i=1}^{\left\lfloor\frac{n}{dk}\right\rfloor}\sum_{j=1}^{\left\lfloor\frac{n}{dk}\right\rfloor}\ (i+j)^m$$

### 二

然后你会发现式子中有两处能用整除分块处理的式子，因此复杂度应是 $O(n)$ 的级别。

因此瓶颈在于如何正确地预处理。

发现 $f(d)=\mu(d)^2$ ，这个 $\mu(d)$ 自然可以用线性筛筛出来。

但是 $\sum_{i=1}^n d^m$ 怎么求呢？

也用线性筛，因为这也是个积性函数。

考虑式子中第三种元素： $\sum_{i=1}^k\sum_{j=1}^k(i+j)^m$

这怎么求呢？？？考虑看看能不能线性递推。

令 $H(k)=\sum_{i=1}^k\sum_{j=1}^k(i+j)^m$

那么发现 $H(k-1)$ 中是没有 $(k+?)^m$ 这个元素的，因此考虑把 $i=k$ 和  $j=k$ 的答案补上，这部分贡献也就是 $\sum_{i=1}^{k-1}(k+i)^m\times 2$

但是发现 $(k+k)^m$ 我们加了两次，再吧这部分多出来的贡献减掉。

$H(k)=H(k-1)+(\sum_{i=1}^k(k+i)^m\times 2-(k+k)^m)$

因此所有的复杂度都可以控制在线性以内计算。

Code:
```cpp
#include<cstdio>
#include<iostream>
using namespace std;
typedef long long LL;
const LL mod=998244353;
const int N=1e7+10,maxn=1e7+5;
int n;
int m;
int prime[N],mu[N],pw[N],F[N],H[N];
int tot;
bool flag[N];
int pc[N];

inline int power(int a,int p)
{
	int ans=1,base=a%mod;
	while(p){
		if(p&1ll) ans=1ll*ans*base%mod;
		base=1ll*base*base%mod;
		p>>=1ll;
	}
	return ans;
}
inline void pre()
{
	mu[1]=1;
	pw[1]=1;pw[0]=0;
	for(register int i=2;i<=maxn;++i){
		if(!flag[i]){
			prime[++tot]=i;
			mu[i]=-1;
			pw[i]=power(i,m);
		}
		for(register int j=1;j<=tot;++j){
			int k=i*prime[j];
			if(k>maxn) break;
			flag[k]=1;
			pw[k]=1ll*pw[i]*pw[prime[j]]%mod;
			if(i%prime[j]) mu[k]=-mu[i];
			else {
				mu[k]=0;
				break;
			}
		}
	}
	for(register int i=0;i<=5000000;++i) if(mu[i]<0) mu[i]+=mod;
	for(register int i=0;i<=5000000;++i) F[i]=1ll*mu[i]*mu[i]%mod*pw[i]%mod*i%mod;
	for(register int i=0;i<=5000000;++i) mu[i]=1ll*mu[i]*pw[i]%mod;
	for(register int i=1;i<=5000000;++i){
		F[i]=(F[i]+F[i-1])%mod;
		mu[i]=(mu[i]+mu[i-1])%mod;
	}
	for(register int i=1;i<=maxn;++i) pw[i]=(pw[i]+pw[i-1])%mod;
	for(register int i=1;i<=5000000;++i) H[i]=(H[i-1]+2ll*(pw[i+i-1]-pw[i]+mod)%mod+(pw[i+i]-pw[i+i-1]+mod)%mod)%mod;
}
inline int calc(int n)
{
	int ans=0;
	for(register int l=1,r;l<=n;l=r+1){
		r=n/(n/l);
		ans=(ans+1ll*(mu[r]-mu[l-1]+mod)%mod*H[n/l]%mod)%mod;
	}
	return ans;
}
signed main()
{
	LL tp;
	scanf("%d%lld",&n,&tp);
	if(tp>mod-1) tp%=(mod-1);
	m=tp;
	pre();
	int ans=0;
	for(register int l=1,r;l<=n;l=r+1){
		r=n/(n/l);
		ans=(ans+1ll*(F[r]-F[l-1]+mod)%mod*calc(n/l)%mod)%mod;
	}
	printf("%d\n",ans);
	return 0;
}

```

---

## 作者：1saunoya (赞：2)

喜闻乐见的推柿子。

$\sum_i \sum_j (i+j)^k f(\gcd(i,j))\gcd(i,j)$

根据 $f$ 的定义我们发现 $f = \mu^2$。

然后随便推。

$\sum_i \sum_j (i+j)^K \mu^2(\gcd(i,j))\gcd(i,j)$

$\sum_d \mu^2(d) d\sum_i \sum_j (id+jd)^K [\gcd =1]$

$\sum_d \mu^2(d) d^{K+1}\sum_i \sum_j (i+j)^K[\gcd=1]$

$\sum_d \mu^2(d) d^{K+1}\sum_i \sum_j (i+j)^K\sum_{k|\gcd(i,j)}\mu_k$

$\sum_d \mu^2(d) d^{K+1} \sum_k \mu(k) k^{K}\sum_i \sum_j (i+j)^k$

$F(n) = \sum_i \sum_j (i+j)^k$。

$T=dk$。

$\sum_{T} T^K\times  F(\frac{n}{T})\sum_{d|T} \mu^2(d)d \mu(\frac{T}{d})$。

$f(n) = \sum_{i}^{n} i^k$。
$g(n) = \sum_{i}^{n} f(i)$。

显然 $F(n) = g(2n) - 2g(n)$。

$\sum_{T} T^K\times  (g(\frac{2n}{T}) - 2g(\frac{n}{T}))\sum_{d|T} \mu^2(d)d \mu(\frac{T}{d})$。

所以做完了？

---

## 作者：RemiliaScar1et (赞：0)

## P6156 简单题

2021.4.18 update：修改了变量混乱及表述错误地方

如果还有错误还请指出。

---

简单题(大嘘

首先，由肉眼观察可以得到： $f(x)=\mu^2(x)$

即题目求
$$\sum_{i=1}^n\sum_{j=1}^n (i+j)^k\mu^2(gcd(i,j))gcd(i,j)$$

开始推式子部分：令 $gcd(i,j)=d$，

$$
\begin{aligned}
\text{原式}&=\sum_{d=1}^nd\sum_{i=1}^n\sum_{j=1}^n(i+j)^k\mu^2(d)[gcd(i,j)=d]\\
&=\sum_{d=1}^{n}d^{k+1}\sum_{i=1}^{n/d}\sum_{j=1}^{n/d}(i+j)^k[gcd(i,j)=1]
\end{aligned}
$$

套路地设以下函数：

$$f(x)=\sum_{i=1}^{n/d}\sum_{j=1}^{n/d}(i+j)^k[gcd(i,j)=x]$$

$$F(x)=\sum_{x|i}f(i)$$

则

$$f(x)=\sum_{x|i}\mu(\frac{i}{x})F(i)$$
$$\Rightarrow f(1)=\sum_{i=1}^{n/d}\mu(i)F(i)$$

下面化简 $F(x)$

$$
\begin{aligned}
F(x)&=\sum_{x|i}\sum_{j=1}^{n/d}\sum_{r=1}^{n/d}(j+r)^k[gcd(j,r)=x]\\
&=\sum_{j=1}^{n/d}\sum_{r=1}^{n/d}(j+r)^k[x|gcd(i,j)]\\
&=x^k\sum_{j=1}^{n/xd}\sum_{r=1}^{n/xd}(j+r)^k
\end{aligned}
$$

那么：

$$Ans=\sum_{d=1}^n d^{k+1}\mu(d)\sum_{i=1}^{n/d}\mu(i)i^k\sum_{j=1}^{n/id}\sum_{r=1}^{n/id}(j+r)^k$$

令 $T=id\ ,\ Sum(x)=\sum\limits_{i=1}^{x}\sum\limits_{j=1}^{x}(i+j)^k$，则:

$$
Ans=\sum_{T=1}^nT^kSum(\frac{n}{T})\sum_{d|T}d\mu^2(d)\mu{\frac{T}{d}}
$$

式子主要分为两部分需要我们集中精力处理 $Sum(\frac{n}{T})$ 和 $\sum\limits_{d|T}d\mu^2(d)\mu(d)$。

1. **$Sum(x)$**

    以 $x=2,3$ 为例，我们将这个东西写开，试图找寻规律：

    $$
    \begin{array}{cl}
    x=2 & , &Sum(x)=2^k+2\times 3^k+4^k\\
    x=3 & , &Sum(x)=2^k+2\times 3^k+3\times 4^k+2\times 5^k+6^k\\
    \end{array}
    $$

    观察得到，它的系数是一个形似 $\{1,2,3,2,1\}$ 的从 $1$ 开始的连续回文数列。

    我们试图将 $Sum(n)$ 展开，穷举第一个求和积分的变量 $i$ 并将各项列在下面，寻找这个规律的一般性：

    $$
    \begin{array}{cc}
    &j=1&j=2&j=3& &j=n-1&j=n\\
    i=1  & 2^k, & 3^k, & 4^k,& \cdots &  n^k, &(n+1)^k\\
    i=2  & 3^k, & 4^k, & 5^k,& \cdots & (n+1)^k, &(n+2)^k\\
    i=3  & 4^k, & 5^k ,& 6^k,& \cdots & (n+2)^k, &(n+3)^k\\
    \vdots \\
    i=n  & (n+1)^k, & (n+2)^k & (n+3)^k, & \cdots  & (n+n-1)^k, & (n+n)^k\\
    \end{array}
    $$

    加法合并同类项时刚好就是在合并上表对角线以及对角线的平行线上的项。由于这个矩阵长宽相等，所以是系数一个从 $1$ 开始的回文数列，这个规律具有普遍性。

    那么这个东西怎么求呢？画一个图或许就能明白：

    ![](https://img.imgdb.cn/item/6061533b8322e6675c87b897.png)

    红色就是我们要求的部分，黄色是将图形补齐后多出的部分。

    那么 $Sum(n)=\sum\limits_{i=n+1}^{2n}\sum\limits_{j=1}^{i}j^k-\sum\limits_{i=1}^n\sum\limits_{j=1}^{i}j^k=\sum\limits_{i=1}^{2n}\sum\limits_{j=1}^{i}j^k-2\sum\limits_{i=1}^n\sum\limits_{j=1}^{i}j^k$。

    令 $S(x)=\sum\limits_{i=1}^{x}i^k$，则 $Sum(x)=\sum\limits_{i=1}^{2x}S(i)-2\sum\limits_{i=1}^xS(i)$

    对于 $i^k,S(x),\sum S(x)$ ，由于 $i^k$ 是积性函数，可以 $O(n)$ 时间预处理出来，前缀和也可以 $O(n)$ 一起做掉。

2. **$f(T)=\sum_{d|T}d\mu^2(d)\mu(\frac{T}{d})$**

    观察形式可知：这是一堆积性函数卷在一起得到的式子，所以这个东西也一定是积性函数。

    但是这个函数的形式太怪，我们不好配函数使用杜教筛。

    所以我们直接考虑线性筛。

    假设我们线筛枚举到了一个质数 $p$，我们要知晓 $f(q)=f(i\times p^k),\quad (gcd(i,p^k)=1)$ 的值的情况。由于 $f$ 是积性函数，我们可以着重讨论 $f(p^k)$ 的值。

    当 $k=1$ 时，$f(p)=1\mu^2(1)\mu(p)+p\mu^2(p)\mu(1)=p-1$.

    当 $k=2$ 时，$f(p^2)=1\mu^2(1)\mu(p^2)+p\mu^2(p)\mu(p)+p^2\mu^2(p^2)\mu(1)=-p$

    当 $k>2$ 时，我们发现，对于每一项形如 $x\mu^2(x)\mu(\frac{p^k}{x})$ ，$x$ 与 $\frac{p^k}{x}$ 中必有一项是 $p^2$ 的倍数。也就是说，$f(p^k)=0$。

    于是根据这个巧妙的性质，我们只需要线筛中对枚举到的数 $i$ 判断有几个 $p$ 做为质因子即可。

综上，经过上面的 $O(n)$ 预处理后，对于答案式子：

$$Ans=\sum_{T=1}^nSum(\frac{n}{T})T^k\sum_{d|T}d\mu^2(d)\mu{\frac{T}{d}}$$

我们只需要整除分块即可，解决询问的时间复杂度 $O(\sqrt n)$。

code：(代码实现中我把 $T^k$ 和 $\sum\limits_{d|T}d\mu^2(d)\mu{\frac{T}{d}}$ 的前缀和合并到了一起)。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

const int N=1e7+10;
const ll mod=998244353;

ll n,k;
ll pr[N],tot=0;
bool mp[N];
ll powk[N<<1],F[N<<1],f[N<<1],S[N<<1];

ll fpow(ll a,ll k)
{
	ll res=1; a%=mod;
	while(k) {if(k&1) res=res*a%mod; a=a*a%mod; k>>=1; }
	return res;
}

void init(ll n,ll k)
{
	f[1]=powk[1]=mp[1]=1;
	for(ll i=2;i<=n;++i)
	{
		if(!mp[i]) pr[++tot]=(ll)i,f[i]=i-1,powk[i]=fpow(i,k);
		for(int j=1;(ll)pr[j]*i<=n;++j)
		{
			powk[pr[j]*i]=powk[pr[j]]*powk[i]%mod;
			mp[pr[j]*i]=1;
			if(i%pr[j]==0)
			{
				int tmp=i/pr[j];
				if(tmp%pr[j]) f[pr[j]*i]=(ll)f[tmp]*(mod-pr[j])%mod;
				break;
			}
			f[pr[j]*i]=(ll)f[i]*(pr[j]-1)%mod;
		}
	}
	for(int i=1;i<=n;i++)
	{
		f[i]=((ll)f[i]*powk[i]%mod+f[i-1])%mod;
		F[i]=(F[i-1]+powk[i])%mod;
	}
	for(int i=1;i<=n;i++)
		F[i]=(F[i-1]+F[i])%mod;
}

inline ll Sum(ll x) {return (F[2*x]-2*F[x])%mod;}

int main()
{
	scanf("%lld%lld",&n,&k);
	init(2*n+10,k);
	ll ans=0;
	for(int l=1,r;l<=n;l=r+1)
	{
		r=(n/(n/l));
		ans+=Sum(n/l)*(f[r]-f[l-1])%mod;
		ans%=mod;
	}
	printf("%lld",(ans%mod+mod)%mod);
	return 0;
}
```


---

## 作者：Mr_Li (赞：0)

首先看到gcd第一步自然想到莫比乌斯函数

按照套路，原式先通过枚举gcd的可能值化为

$\sum_{d=1}^n\sum_{i=1}^n\sum_{j=1}^ndf(d)(i+j)^k[gcd(i,j)=d]$

要想gcd(i,j)=d，d必须是i和j的因数，所以我们可以用id,jd代替i,j,将原式化为

$\sum_{d=1}^n\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{n}{d}\rfloor}df(d)(id+jd)^k[gcd(i,j)=1]$

所以根据莫比乌斯函数的性质

$\sum_{d=1}^n\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{n}{d}\rfloor}df(d)(id+jd)^k\sum_{d'|gcd(i,j)}μ(d')$

改写为先枚举d,再枚举d',最后枚举i和j的形式

$\sum_{d=1}^n\sum_{d'=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{i=1}^{\lfloor\frac{\lfloor\frac{n}{d}\rfloor}{d'}\rfloor}\sum_{j=1}^{\lfloor\frac{\lfloor\frac{n}{d}\rfloor}{d'}\rfloor}df(d)(idd'+jdd')^kμ(d')$

我们设n=pd+s(s<d),p=qd'+t(t<d'),则n=qdd'+td+s,且td+s<d,即

$\lfloor\frac{\lfloor\frac{n}{d}\rfloor}{d'}\rfloor=q=\lfloor\frac{n}{dd'}\rfloor$

所以原式可化为

$\sum_{d=1}^n\sum_{d'=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{i=1}^{\lfloor\frac{n}{dd'}\rfloor}\sum_{j=1}^{\lfloor\frac{n}{dd'}\rfloor}df(d)(idd'+jdd')^kμ(d')$

发现有一些公因式可以提出来，一般来说我们可以借此降低f函数和μ函数的运算次数，并且降低指数运算中的底数，以便预处理指数运算的结果，我通过提取公因式把上式化简成如下：

$\sum_{d=1}^ndf(d)\sum_{d'=1}^{\lfloor\frac{n}{d}\rfloor}μ(d')(dd')^k\sum_{i=1}^{\lfloor\frac{n}{dd'}\rfloor}\sum_{j=1}^{\lfloor\frac{n}{dd'}\rfloor}(i+j)^k$

枚举i,j的时间复杂度显然过大，由于枚举i和j后需要i或j的计算只有i+j,所以我们不难想到将

$\sum_{i=1}^{\lfloor\frac{n}{dd'}\rfloor}\sum_{j=1}^{\lfloor\frac{n}{dd'}\rfloor}(i+j)^k$

中，(i+j)相同的项合并，不难求得原式等于

$\sum_{d=1}^ndf(d)\sum_{d'=1}^{\lfloor\frac{n}{d}\rfloor}μ(d')(dd')^k\sum_{i=1}^{2\lfloor\frac{n}{dd'}\rfloor}i^kmin(i-1,2\lfloor\frac{n}{dd'}\rfloor-i+1)$

其中

$(dd')^k\sum_{i=1}^{2\lfloor\frac{n}{dd'}\rfloor}i^kmin(i-1,2\lfloor\frac{n}{dd'}\rfloor-i+1)$

只随dd'的变化而变化，于是我们设

$g(x)=x^k\sum_{i=1}^{2\lfloor\frac{n}{x}\rfloor}i^kmin(i-1,2\lfloor\frac{n}{x}\rfloor-i+1)$

于是原式可化为

$\sum_{d=1}^ndf(d)\sum_{d'=1}^{\lfloor\frac{n}{d}\rfloor}μ(d')g(dd')$

按照前面的思路，我们可以先用筛法预处理f(x)(0<x≤n)和μ(x)(0<x≤n)，的值(f函数与μ函数接近，可以用相同的方法预处理)再预处理

$i^n(0<i≤2n)$

的值(**注意i的范围要取到2n**)，接着预处理g(x)(0<x≤n)的值，最后求解答案，时间复杂度为O(nlogn+nlogk),可得到部分代码如下：

```cpp
int main ()
{
	scanf("%d %lld",&n,&k);
	Euler(2*n,k); 
	for (i=1;i<=n<<1;i++)
	list[i]=pow(i,k);
	for (i=1;i<=n;i++)
	{
		temp=n/i*2;
		for (j=i,l=1;j<=n<<1;j+=i,++l)
		list2[i]+=list1[l]*min(l-1,temp-l+1)%998244353;
		list2[i]=list2[i]%998244353*list1[i]%998244353;
	}
	for (i=1;i<=n;i++)
	{
		temp=0;
		for (j=i,l=1;j<=n;j+=i,++l)
		temp+=miu[l]*list2[j]%998244353;
		temp%=998244353;
		answer=(i*f[i]*temp%998244353+answer)%998244353;
	}
	printf("%lld",answer);
	return 0;
}
```

其中Euler()函数表示用线性筛法预处理f函数和μ函数。当然，这道题时限只有1s,卡O(nlogk)，只能得40分。于是我们想到筛法每次筛出的合数a总是用上它最小的质数b,由于我们有

$a^k=(b^k)(\frac{a}{b})^k$

而b和a除以b的值总是在a之前被筛出，所以我们每筛到一个质数，就用快速幂算出它的k次方，每筛到一个合数，就用上式计算它的k次方,求

$i^n(0<i≤2n)$

的复杂度被降为O(logklogn+n),得到代码如下：

```cpp
#include<iostream>
#include<stdio.h>
#include<algorithm>
#include<stdlib.h>
#include<map>
bool composite[10000001];
int PN,prime[10000001],miu[10000001],f[10000001];
long long list1[10000001];
long long pow (long long a,long long b)
{
	if (b==0)
	return 1;
	long long c=pow(a,b>>1);
	if (b&1)
	return a*c%998244353*c%998244353;
	return c*c%998244353;
}
void Euler (long long n,long long k)
{
	miu[1]=1;
	f[1]=1;
	list1[1]=1;
	int i,j;
	for (i=2;i<=n;i++)
	{
		if (!composite[i])
		{
			PN++;
			prime[PN]=i;
			miu[i]=-1;
			f[i]=1;
			list1[i]=pow(i,k);
		}
		for (j=1;i*prime[j]<=n&&i%prime[j]>0;j++)
		{
			composite[i*prime[j]]=1;
			if (i%prime[j])
			{
				miu[i*prime[j]]=-miu[i];
				f[i*prime[j]]=f[i];
			}
			else
			{
				miu[i*prime[j]]=0;
				f[i*prime[j]]=0;
			}
			list1[i*prime[j]]=list1[i]*list1[prime[j]]%998244353;
		}
		if (i*prime[j]<=n)
		{
			composite[i*prime[j]]=1;
			if (i%prime[j])
			{
				miu[i*prime[j]]=-miu[i];
				f[i*prime[j]]=f[i];
			}
			else
			{
				miu[i*prime[j]]=0;
				f[i*prime[j]]=0;
			}
			list1[i*prime[j]]=list1[i]*list1[prime[j]]%998244353;
		}
	}
}
int min (int a,int b)
{
	return a<b?a:b;
}
long long n,i,j,l;
long long k,list2[5000001],temp,answer;
int main ()
{
	scanf("%d %lld",&n,&k);
	Euler(2*n,k);
	for (i=1;i<=n;i++)
	{
		temp=n/i*2;
		for (j=i,l=1;j<=n<<1;j+=i,++l)
		list2[i]+=list1[l]*min(l-1,temp-l+1)%998244353;
		list2[i]=list2[i]%998244353*list1[i]%998244353;
	}
	for (i=1;i<=n;i++)
	{
		temp=0;
		for (j=i,l=1;j<=n;j+=i,++l)
		temp+=miu[l]*list2[j]%998244353;
		temp%=998244353;
		answer=(i*f[i]*temp%998244353+answer)%998244353;
	}
	printf("%lld",answer);
	return 0;
}
```
可是这在开启O2优化后仍只有65分。其他题解似乎想到了O(n)的做法，但是本蒟蒻并不是很懂，然而在这道题里也没必要（更优秀的做法可以在[P6222 「P6156 简单题」加强版](https://www.luogu.com.cn/problem/P6222)评测），因为我们可以试图优化一下常数。首先不难想到我们可以将第70行的"long long n,i,j,l"改成"int n,i,j,l"，观察代码发现这个代码时间复杂度的瓶颈在于嵌套for循环上，于是我们可以使用循环展开进行底层优化，代码如下：

```cpp
#include<iostream>
#include<stdio.h>
#include<algorithm>
#include<stdlib.h>
#include<map>
bool composite[10000001];
int PN,prime[10000001],miu[10000001],f[10000001];
long long list1[10000001];
long long pow (long long a,long long b)
{
	if (b==0)
	return 1;
	long long c=pow(a,b>>1);
	if (b&1)
	return a*c%998244353*c%998244353;
	return c*c%998244353;
}
void Euler (long long n,long long k)
{
	miu[1]=1;
	f[1]=1;
	list1[1]=1;
	int i,j;
	for (i=2;i<=n;i++)
	{
		if (!composite[i])
		{
			PN++;
			prime[PN]=i;
			miu[i]=-1;
			f[i]=1;
			list1[i]=pow(i,k);
		}
		for (j=1;i*prime[j]<=n&&i%prime[j]>0;j++)
		{
			composite[i*prime[j]]=1;
			if (i%prime[j])
			{
				miu[i*prime[j]]=-miu[i];
				f[i*prime[j]]=f[i];
			}
			else
			{
				miu[i*prime[j]]=0;
				f[i*prime[j]]=0;
			}
			list1[i*prime[j]]=list1[i]*list1[prime[j]]%998244353;
		}
		if (i*prime[j]<=n)
		{
			composite[i*prime[j]]=1;
			if (i%prime[j])
			{
				miu[i*prime[j]]=-miu[i];
				f[i*prime[j]]=f[i];
			}
			else
			{
				miu[i*prime[j]]=0;
				f[i*prime[j]]=0;
			}
			list1[i*prime[j]]=list1[i]*list1[prime[j]]%998244353;
		}
	}
}
int min (int a,int b)
{
	return a<b?a:b;
}
int n,i,j,l;
long long k,list2[5000001],temp,answer;
int main ()
{
	scanf("%d %lld",&n,&k);
	Euler(2*n,k);
	for (i=1;i<=n;i++)
	{
		temp=n/i*2;
		for (j=i,l=1;3*i+j<=n<<1;j+=i<<2,l+=4)
		list2[i]+=(list1[l]*min(l-1,temp-l+1)+list1[l+1]*min(l,temp-l)+list1[l+2]*min(l+1,temp-l-1)+list1[l+3]*min(l+2,temp-l-2))%998244353;
		for (;j<=n<<1;j+=i,++l)
		list2[i]+=list1[l]*min(l-1,temp-l+1)%998244353;
		list2[i]=list2[i]%998244353*list1[i]%998244353;
	}
	for (i=1;i<=n;i++)
	{
		temp=0;
		for (j=i,l=1;3*i+j<=n;j+=i<<2,l+=4)
		temp+=(miu[l]*list2[j]+miu[l+1]*list2[i+j]+miu[l+2]*list2[2*i+j]+miu[l+3]*list2[3*i+j])%998244353;
		for (;j<=n;j+=i,++l)
		temp+=miu[l]*list2[j]%998244353;
		temp%=998244353;
		answer=(i*f[i]*temp%998244353+answer)%998244353;
	}
	printf("%lld",answer);
	return 0;
}
```
此代码在开启O2优化后可过，注意一定要将第70行的"long long n,i,j,l"改成"int n,i,j,l"，否则只有90分。时间复杂度保持O(logklogn+nlogn)不变。

---

## 作者：FjswYuzu (赞：0)

写了篇也许能看懂的思路。

题目大意：计算：
$$
\sum_{i=1}^n \sum_{j=1}^n (i+j)^k \gcd(i,j) \mu(\gcd(i,j))^2
$$
套路地枚举公因数。
$$
\sum_{d=1}^n \sum_{i=1}^n \sum_{j=1}^n [\gcd(i,j)=d] (i+j)^k \times d \times \mu(d)^2
$$
将与 $i,j$ 无关的东西提出来。
$$
\sum_{d=1}^n d \times \mu(d)^2 \sum_{i=1}^n \sum_{j=1}^n [\gcd(i,j)=d](i+j)^k
$$
修改上界，然后把新多出的 $d^k$ 拿出来。
$$
\sum_{d=1}^n d^{k+1} \mu(d)^2 \sum_{i=1}^{\lfloor \frac{n}{d} \rfloor} \sum_{j=1}^{\lfloor \frac{n}{d} \rfloor} [\gcd(i,j)=1] (i+j)^k
$$
可以发现已经是莫比乌斯反演的基本形式了。
$$
\sum_{d=1}^n d^{k+1} \times \mu(d)^2 \sum_{i=1}^{\lfloor \frac{n}{d} \rfloor} \sum_{j=1}^{\lfloor \frac{n}{d} \rfloor} (i+j)^k \sum_{D|i,D|j} \mu(D)
$$

$$
\sum_{d=1}^n d^{k+1} \times \mu(d)^2 \sum_{D=1}^{\lfloor \frac{n}{d} \rfloor} \mu(D) d^k \sum_{i=1}^{\lfloor \frac{n}{dD} \rfloor} \sum_{j=1}^{\lfloor \frac{n}{dD} \rfloor} (i+j)^k
$$

为了写起来没那么麻烦，令 $\displaystyle P(x)=\sum_{i=1}^x \sum_{j=1}^x (i+j)^k$。
$$
\sum_{d=1}^n d^{k+1} \times \mu(d)^2 \sum_{D=1}^{\lfloor \frac{n}{d} \rfloor} \mu(D) D^k P(\lfloor \dfrac{n}{dD} \rfloor)
$$
枚举 $T$ 去代替 $d,D$。
$$
\sum_{T=1}^n P(\lfloor \dfrac{n}{T} \rfloor) \sum_{d|T} d^{k+1} \mu(d)^2 \mu(\dfrac{T}{d}) (\dfrac{T}{d})^k
$$
将可以放一起的东西拿出来。
$$
\sum_{T=1}^n T^k P(\lfloor \dfrac{n}{T} \rfloor) \sum_{d|T} d \mu(d)^2 \mu(\dfrac{T}{d})
$$
又令 $\displaystyle f(x) = \sum_{d|x} d\mu(d)^2 \mu(\dfrac{x}{d})$。显然可以发现 $f(x)$ 是一个积性函数，线性筛预处理滚个前缀和即可。考虑处理这个 $P(x)$。定义数列 $s$，第 $p$ 个数 $s_{p}$ 表示 $p^k$ 会被统计多少次，原函数可以写成：
$$
P(x)=\sum_{i=1}^{2x} s_i i^k
$$
将其拆开实际上就是滚了几个 $\displaystyle \sum_{i=1}^n i^k$，应该比较好处理。

接下来要处理 $f(x)$ 函数。设 $p$ 为某质数，要处理 $f(p^s)$ 不难发现：

- 当 $s \geq 3$ ，要么 $d | p^2$，要么 $\dfrac{x}{d}|p^2$，所以 $f(x)=0$；   
- 当 $s=2$ 时，能使其有值的时候一定是 $d|p$，此时 $f(x)=-p$；   
- 当 $s=1$ 时，可以得到 $f(x)=x-1$；
- 否则 $f(x)=f(1)=1$。

然后就能愉快地做这道题了。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
const LL MOD=998244353;
LL n,k,s[10000005],kcm[10000005],f[10000005],prime[1000005],cnt;
bool vis[10000005];
LL QuickPow(LL x,LL p)
{
	LL ans=1,base=x;
	while(p)
	{
		if(p&1)	ans*=base,ans%=MOD;
		base*=base;
		base%=MOD;
		p>>=1;
	}
	return ans;
}
void shai(LL up)
{
	f[1]=kcm[1]=1;
	for(LL i=2;i<=up;++i)
	{
		if(!vis[i])	prime[++cnt]=i,f[i]=i-1,kcm[i]=QuickPow(i,k);
		for(LL j=1;j<=cnt && i*prime[j]<=up;++j)
		{
			vis[i*prime[j]]=true;
			kcm[i*prime[j]]=kcm[i]*kcm[prime[j]]%MOD;
			if(i%prime[j])	f[i*prime[j]]=f[i]*f[prime[j]]%MOD;
			else
			{
				LL modify=i/prime[j];
				if(modify%prime[j]==0)	f[i*prime[j]]=0;
				else	f[i*prime[j]]=(MOD-prime[j])*f[modify]%MOD;
				break;
			}
		}
	}
	for(LL i=2;i<=up;++i)	f[i]=f[i-1]+f[i]*kcm[i]%MOD,f[i]%=MOD,kcm[i]+=kcm[i-1],kcm[i]%=MOD;
	for(LL i=2;i<=up;++i)	kcm[i]+=kcm[i-1],kcm[i]%=MOD;
}
LL sum(LL x){return ((kcm[x*2]-kcm[x]*2%MOD)%MOD+MOD)%MOD;}
int main(){
	scanf("%lld %lld",&n,&k);
	k%=(MOD-1);
	shai(2*n);
	LL ans=0;
	for(LL l=1,r;l<=n;l=r+1)
	{
		r=n/(n/l);
		ans+=((f[r]-f[l-1])%MOD+MOD)%MOD*sum(n/l)%MOD;
		ans%=MOD;
	}
	printf("%lld",ans);
	return 0;
}
```



---

## 作者：MCAdam (赞：0)

[P6156 简单题](https://www.luogu.com.cn/problem/P6156)

做了这题才发现之前做莫反的思路有漏洞QWQ

如果$\exists k^2\mid x$，则$f(x)=0$，反之则为$1$

这不就相当于$f(x)=\mu^2(x)$

$\displaystyle \sum_{i=1}^{n}\sum_{j=1}^{n}(i+j)^k\times f(gcd(i,j))\times gcd(i,j)$

$\displaystyle=\sum_{g=1}^{n}\sum_{i=1}^{n}\sum_{j=1}^{n}(i+j)^k\times \mu^2(g)\times g[gcd(i,j)=g]$

$\displaystyle=\sum_{g=1}^{n}g^{k+1} \mu^2(g)\sum_{i=1}^{n/g}\sum_{j=1}^{n/g}(i+j)^k\times [gcd(i,j)=1]$

$\displaystyle=\sum_{g=1}^{n}g^{k+1}\mu^2(g)\sum_{d=1}^{n}\mu(d)\times d^k\sum_{i=1}^{n/gd}\sum_{j=1}^{n/gd}(i+j)^k$

$\displaystyle=\sum_{T=1}^{n}\sum_{d\mid T}\mu(d)d^k\times (\frac{T}{d})^{k+1}\mu^2(g)\sum_{i=1}^{n/gd}\sum_{j=1}^{n/gd}(i+j)^k$

$\displaystyle=\sum_{T=1}^{n}T^k\sum_{d\mid T}\frac{T}{d}\mu(d)\mu^2(\frac{T}{d})\sum_{i=1}^{n/T}\sum_{j=1}^{n/T}(i+j)^k$

设$\displaystyle f(n)=\sum_{d\mid n}d\mu^2(d)\mu(\frac{n}{d}),g(n)=\sum_{i=1}^{n}\sum_{j=1}^{n}(i+j)^k$

考虑怎么快速计算这两个函数？

- 计算$f$

$f$是一堆积性函数乘在一起，它应该也是积性函数，所以可以线性筛

    线性筛要考虑的：f(n)推到f(n*p)
    
    1、当n为质数时的取值
    
    直接把质数代入求出答案
    
    2、当前枚举的p不是n的因子时
    
    此时gcd(p,n)=1
    
    根据积性函数的定义，有f(n*p)=f(n)*f(p)
    
    3、当前枚举的p是n的因子时
    
    设此时n=p^k*x，根据积性函数的定义：
    
    f(n*p)=f(p^(k+1))*f(x)
    
    然后就要根据k来判断f的f(p^(k+1))的取值
    
    对于一些特别的函数，通过计算可以发现一些值恒定之类的，但通法是要把每个数的最小质因数的次幂记下来的
    
1、当$n$为质数时：

$f(n)=1\times \mu^{2}(1)\times \mu(n)+n\times \mu^{2}(n)\times \mu(1)=n-1$

2、当前枚举的$p$为$n$的因子：

现在就是要讨论$f(p^{k+1})$的取值$k\geq 1$

当$k=1$时：$f(p^2)=p\times \mu^2(p)\times \mu(p)=-p$

当$k\geq 2$时，不管因子取到多少，$d,\frac{n}{d}$至少会存在一个次数大于$1$的，所以此时$f(p^{k+1})=0$

- 计算$g$

设$\displaystyle F(n)=\sum_{i=1}^{n}i^k\quad S(n)=\sum_{i=1}^{n}F(i)$

$g(n)=[2^k+3^k+...+(m+1)^k]+...+[(m+1)^k+(m+2)^k+...+(2m)^k]$

则$\displaystyle g(n)=\sum_{i=n+1}^{2n}F(i)-\sum_{i=1}^{n}F(i)=S(2n)-2\times S(n)$

然后注意这题，$O(n\log_2 k)$是会被卡的，有一个$Tip$

计算$i^k$可以只计算它的质因数然后合成

所以预处理的时间复杂度就为$O(\frac{n}{\ln n}\log_2k)=O(n)$

最后要求的就是$\displaystyle \sum_{T=1}^{n}T^k f(T)g(n/T)$，整除分块算一哈就好了

```cpp
#include <iostream>
#include <cstdio>
#define ll long long
using namespace std;
const int N=1e7;
const int mod=998244353;
int k;
int vis[N+10],prim[N+10],f[N+10],g[N+10],F[N+10],S[N+10];
inline int power(int a,int b)
{
	int res=1;
	while(b)
	{
		if(b&1) res=1ll*res*a%mod;
		b>>=1;
		a=1ll*a*a%mod;
	}
	return res;
}
inline void pre()
{
	f[1]=F[1]=1;
	int cnt=0;
	for(register int i=2;i<=N;i++)
	{
		if(!vis[i]) 
		{
			vis[i]=1,prim[++cnt]=i;
			f[i]=(i-1+mod)%mod,F[i]=power(i,k);
		}
		for(register int j=1;j<=cnt&&i*prim[j]<=N;j++)
		{
			vis[i*prim[j]]=1;
			F[i*prim[j]]=1ll*F[i]*F[prim[j]]%mod;
			if(i%prim[j]) f[i*prim[j]]=1ll*f[i]*f[prim[j]]%mod;
			else
			{
				if((i/prim[j])%prim[j]==0) f[i*prim[j]]=0;
				else f[i*prim[j]]=1ll*(mod-prim[j])%mod*f[i/prim[j]]%mod;
				break;
			}
		}
	}
	for(register int i=1;i<=N;i++)
	{
		f[i]=(f[i-1]+1ll*F[i]*f[i]%mod)%mod;
		F[i]=(F[i]+F[i-1])%mod;
		S[i]=(S[i-1]+F[i])%mod;
	}
	for(register int i=1;i<=N/2;i++)
		g[i]=(S[2*i]-2*S[i]%mod+mod)%mod;
}
int main()
{
	int n,ans=0; ll m;
	scanf("%d%lld",&n,&m);
	k=m%(mod-1);
	pre();
	for(register int l=1,r;l<=n;l=r+1)
	{
		r=n/(n/l);
		ans=(ans+1ll*(f[r]-f[l-1]+mod)%mod*g[n/l]%mod)%mod;
	}
	printf("%d\n",ans);
	return 0;
}
```


---

## 作者：Alear (赞：0)

渴望更无脑地推柿子？

记  $ h(n) =
\begin{cases}
n,n\text{无平方因子}\\
0,n\text{有平方因子}
\end{cases}
$，$\large h=g \cdot 1$，$\large g = \mu \cdot h$那么要求的柿子就变成了：
$$
\large
\begin{aligned}
&\sum\limits_{i=1}^n \sum\limits_{j=1}^n (i+j)^k h(\gcd(i,j))\\
=&\sum\limits_{i=1}^n \sum\limits_{j=1}^n (i+j)^k \sum\limits_{d|i,d|j}g(d)\\
=&\sum\limits_{d=1}^n g(d)d^k\sum\limits_{i=1}^{\lfloor \frac{n}{d} \rfloor} \sum\limits_{j=1}^{\lfloor \frac{n}{d} \rfloor} (i+j)^k \\
=&\sum\limits_{d=1}^n g(d)d^k S(\lfloor \frac{n}{d} \rfloor)
\end{aligned}
$$
其中$\large S(n)=\sum\limits_{i=1}^{\lfloor \frac{n}{d} \rfloor} \sum\limits_{j=1}^{\lfloor \frac{n}{d} \rfloor} (i+j)^k$

这个东西还是很好求的，
$$
\large
\begin{aligned}
&S(n)-S(n-1)\\
=&2\sum\limits_{i=1}^n (i+n)^k - (2n)^k\\
=&2\sum\limits_{i=n+1}^{2n} (i)^k - 4n^k 
\end{aligned}
$$
使用线性筛预预处理处 $i^k$ 就可以做到 $O(n)$ 预处理所有的 $S(n)$ 。

接下来的问题就是如何求$g$，接下来的内容可以参考[这篇博客](https://www.luogu.com.cn/blog/lx-2003/mobius-inversion)，我也是在这里学的，里面讲了三种直接通过 $h$ 求 $g$ 的方法，这里讲一下 $n\log  \log n$ 的做法

记 $\large g_{i,n}$ 表示
$$
\large 
\sum\limits_{d|n,d\text{只含前$i$个质因子}} \mu(d)\ h(n/d)
$$
然后按照是否含第 $i$ 个质因子考虑，转移方程是：
$$
\large 
g_{i,n}=
\begin{cases}
g_{i-1,n} & p_i \nmid n\\
g_{i-1,n} - g_{i-1,n / p_i} & p_i \mid n
\end{cases}
$$


对于第二种转移，相当于加入了含有第 $i$ 个质因子的 $d$ 且只加一个，因为加两个或以上会是 $\mu$ 变成 $0$ ，就没有考虑的必要了。因为是 $\mu$ 所有加入的一个新的质因子的时候需要乘上 $-1$ 。

复杂度$\large O(\sum_p n / p) = O(n\log\log n)$ 。

搞完这一堆预处理，我们再回去看式子，这时候已经可以通过前缀和和整除分块做到 $O(\sqrt n)$ 查询了，复杂度为 $O(n\log\log n + q\sqrt n)$ 。~~当然查询只有一次，瓶颈在预处理部分，我这样是强行突出$O(\sqrt n)$的查询复杂度，而且万一它多测呢。~~

---

## 作者：Polaris_Dane (赞：0)

$f(x)=\mu(x)^2$应该比较明显

$\sum_{i=1}^n\sum_{j=1}^n(i+j)^k\mu(gcd(i,j))^2gcd(i,j)$

该换枚举顺序

$=\sum_{d=1}^n\mu(d)^2d\sum_{i=1}^n\sum_{j=1}^n[gcd(i,j)=d](i+j)^k$

$=\sum_{d=1}^n\mu(d)^2d\sum_{i=1}^{\left\lfloor\frac {n} {d}\right\rfloor}\sum_{j=1}^{\left\lfloor\frac {n} {d}\right\rfloor}[gcd(i,j)=1](id+jd)^k$

$=\sum_{d=1}^n\mu(d)^2d^{k+1}\sum_{i=1}^{\left\lfloor\frac {n} {d}\right\rfloor}\sum_{j=1}^{\left\lfloor\frac {n} {d}\right\rfloor}[gcd(i,j)=1](i+j)^k$

前面$\mu(d)^2d^{k+1}$是个积性函数，可以线性筛前缀和

$=\sum_{d=1}^n\mu(d)^2d^{k+1}\sum_{i=1}^{\left\lfloor\frac {n} {d}\right\rfloor}\sum_{j=1}^{\left\lfloor\frac {n} {d}\right\rfloor}\sum\limits_{t|gcd(i,j)}\mu(t)(i+j)^k$

$=\sum_{d=1}^n\mu(d)^2d^{k+1}\sum_{t=1}^{\left\lfloor\frac {n} {d}\right\rfloor}\mu(t)\sum_{i=1}^{\left\lfloor\frac {n} {dt}\right\rfloor}\sum_{j=1}^{\left\lfloor\frac {n} {dt}\right\rfloor}(it+jt)^k$

$=\sum_{d=1}^n\mu(d)^2d^{k+1}\sum_{t=1}^{\left\lfloor\frac {n} {d}\right\rfloor}\mu(t)t^k\sum_{i=1}^{\left\lfloor\frac {n} {dt}\right\rfloor}\sum_{j=1}^{\left\lfloor\frac {n} {dt}\right\rfloor}(i+j)^k$

令$S(n)=\sum_{i=1}^n\sum_{j=1}^n(i+j)^k$

$=\sum_{d=1}^n\mu(d)^2d^{k+1}\sum_{t=1}^{\left\lfloor\frac {n} {d}\right\rfloor}\mu(t)t^kS(\left\lfloor\dfrac {n} {dt}\right\rfloor)$

只要能求出来$S(1)$到$S(n)$就可以两次数论分块解决

$S(n)=\sum_{i=1}^n\sum_{j=1}^n(i+j)^k=\sum_{i=1}^{n-1}\sum_{j=1}^{n-1}(i+j)^k+\sum_{i=1}^{n-1}(i+n)^k+\sum_{i=1}^{n}(i+n)^k$

$=S(n-1)+\sum_{i=1}^{n-1}(i+n)^k+\sum_{i=1}^{n}(i+n)^k$

然后我们要求$\sum_{i=1}^ni^k$即可，可以直接暴力筛

然后就没了，蛮套路的...没有套上推导积性函数的线性筛

注意了，我是暴力得到的$k$次方，一定要筛到$2n$

因为求$S(n)$时会用到

---


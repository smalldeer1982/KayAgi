# 「P6156 简单题」加强版

## 题目背景

[原题链接](https://www.luogu.com.cn/problem/P6156)

此题在原题基础上，加上了多测，更改了模数，同时为了彻底卡掉非线性预处理，开大了数据范围。

可能有点卡常。

## 题目描述

$T$ 组询问。一开始给定一个常数 $K$。每次询问单独给定 $n$。请你求出：

$$\sum_{i=1}^{n}\sum_{j=1}^{n} (i+j)^K \gcd(i,j) \mu^2(\gcd(i,j)) \pmod {2^{32}}$$

## 说明/提示

一共有 $5$ 组测试点。第 $i$ 组测试点满足：$N=10^{i+2}$。

对于所有测试点，满足：$T = 10^4$，$1 \leq K < 2^{31}$。

## 样例 #1

### 输入

```
4 1919 5
1
14
51
4
```

### 输出

```
32
1012884514
62017882
105160
```

# 题解

## 作者：CYJian (赞：14)

~~搬运~~

如果这个加强版有什么问题请私信戳我。

---

这个题推柿子的部分较为简单，就简单写写吧。

$$\sum_{i=1}^{n}\sum_{j=1}^{n} (i+j)^k \mu^2((i,j))(i,j)$$

$$\sum_{d=1}^{n}\mu^2(d)d^{k+1}\sum_{i=1}^{n/d}\sum_{j=1}^{n/d}(i+j)^k[(i,j)=1]$$

$$\sum_{d=1}^{n}\mu^2(d)d^{k+1}\sum_{t=1}^{n/d}\mu(t)t^k\sum_{i=1}^{n/td}\sum_{j=1}^{n/td} (i+j)^k$$

令 $S(x)=\sum_{i=1}^{x}\sum_{j=1}^{x} (i+j)^k$。

$$ \sum_{d=1}^{n}\sum_{t=1}^{n/d}t^kd^{k+1}\mu(t)\mu^2(d)S(\frac{n}{td}) $$

令 $T = td$：

$$ \sum_{T=1}^{n}T^kS(\frac{n}T)\sum_{d|T}d\mu^2(d)\mu(\frac{T}{d}) $$

---

然后考虑快速预处理需要的东西：

先考虑快速求 $S(x)$：

令 $F(n) = \sum_{i=1}^{n} i^k$，$G(n) = \sum_{i=1}^{n}F(i)$。

则有：$S(n) = \sum_{i=n+1}^{2n}F(i)-\sum_{i=1}^{n}F(i)=G(2n)-2G(n)$。

自然数 $k$ 次幂可以 $O(n)$ 用欧拉筛筛出来。

然后一次前缀和求 $F(x)$ 之后，再做前缀和就能求 $S(x)$ 了。

再考虑 $f(n) = \sum_{d|n}d \mu^2(d)\mu(\frac{n}{d})$：由于是一堆积性函数的狄利克雷卷积的形式，则 $f(n)$ 也一定是积性函数。

考虑欧拉筛筛中 $x$ 时，枚举到的质因数是 $p$。从 $\mu$ 函数着手考虑，则讨论 $p$ 在 $x$ 中的最高次幂因子：假设 $p^k \mid x$ 且有 $p^{k+1} \nmid x$：

根据积性函数性质，则有：$f(x) = f(p^k) \times f(\frac{x}{p^k})$。

讨论一下 $f(p^k)$ 的取值：

- $k=0$，即 $f(1)$ 的取值一定为 $1$。
- $k=1$，则 $f(p) = 1 \mu^2(1) \mu(p) + p \mu^2(p) \mu(1) = p-1$。
- $k=2$，则 $f(p^2) = 1 \mu^2(1) \mu(p^2) + p \mu^2(p) \mu(p) + p^2 \mu^2(p^2) \mu(1)=-p$。
- $k \ge 3$，由于鸽笼原理，此时 $d$ 和 $\frac{x}{d}$ 中至少有一个能被 $p^2$ 整除，则那一个的 $\mu$ 的值为 $0$。所以此时 $f(p^k)=0$。

然后就可以通过判断 $k$ 的数值来计算 $f(x)$ 了。

$\rm Code$：

```cpp
const int MAXN = 20000010;

inline uit fsp(uit x, int k) {
	uit s = 1;
	while(k) {
		if(k & 1) s *= x;
		x *= x, k >>= 1;
	} return s;
}

int tot;
int pri[MAXN / 10];
bitset<MAXN>chk;
uit f[MAXN];
uit F[MAXN];

inline void Sieve(int n, int k) {
	f[1] = F[1] = 1;
	for(int i = 2; i <= n; i++) {
		if(!chk[i]) pri[++tot] = i, f[i] = i - 1;
		for(int j = 1; j <= tot; j++) {
			if(i * pri[j] > n) break;
			int p = i * pri[j];
			chk[p] = 1;
			F[p] = F[i] * F[pri[j]];
			if(i % pri[j] == 0) {
				int q = i / pri[j];
				if(q % pri[j]) f[p] = -pri[j] * f[q];
				break;
			} f[p] = f[i] * (pri[j] - 1);
		}
	}
	for(int i = 2; i <= n; i++) f[i] = f[i - 1] + f[i] * F[i], F[i] += F[i - 1];
	for(int i = 2; i <= n; i++) F[i] += F[i - 1];
}

inline uit Calc(int n) { return F[n << 1] - (F[n] << 1); }

int main() {
#ifdef LOCAL
	FILE("");
#endif
	int Case = ri, N = ri, k = ri;
	Sieve(N << 1, k);
	while(Case--) {
		uit res = 0;
		int n = ri;
		for(int l = 1, r; l <= n; l = r + 1) {
			r = n / (n / l);
			res += (f[r] - f[l - 1]) * Calc(n / l);
		} cout << res << "\n";
	}
	return 0;
}
```

---

## 作者：qwaszx (赞：9)

拿这题总结一下基础科技好了(

令

$$
f(n)=n\mu^2(n),\sum_{d\mid n}g(d)=f(n)
$$

则有

$$
\begin{aligned}\text{原式}=&\sum_{i=1}^n\sum_{j=1}^n(i+j)^{K}\sum_{d\mid i,d\mid j}g(d)\\=&\sum_{d=1}^ng(d)d^{K}\sum_{i=1}^{n/d}\sum_{j=1}^{n/d}(i+j)^K\end{aligned}
$$

令

$$
S(n)=\sum_{i=1}^n\sum_{j=1}^n(i+j)^{K},s(n)=S(n)-S(n-1)
$$

则可以继续化为

$$
\begin{aligned}&\sum_{d=1}^ng(d)d^KS(\left\lfloor\frac{n}{d}\right\rfloor)\\=&\sum_{i=1}^ng(i)i^K\sum_{ij\leq n}s(j)\\=&\sum_{T=1}^n\sum_{d\mid T}g(d)d^Ks(\frac{T}{d})\end{aligned}
$$

令

$$
h(n)=\sum_{d\mid n}g(d)d^Ks(\frac{n}{d})
$$

只需要求出 $h$ 的前缀和即可.这是一个积性函数和一个非积性函数的狄利克雷卷积，我们可以把积性函数拆成若干个只在某个素数 $p$ 上有值的部分的卷积，然后分别卷上去.即定义

$$
f_p(x)=\begin{cases}f(n)&n=p^k\\0&otherwise\end{cases}
$$

那么有

$$
f=f_2\ast f_3\ast f_5\ast f_7\cdots
$$

或者直接使用狄利克雷生成函数解释

$$
F(x)=\sum_{n\geq 1}\frac{f(n)}{n^x}=\prod_{p\text{是素数}}\sum_{i\geq 0}\frac{f(p^i)}{(p^i)^x}
$$

先求出 $s$ ，显然有

$$
s(n)=2\sum_{i=1}^n(n+i)^K-(2n)^K
$$

于是只要求出 $id^K$ 的前缀和，由于 $id^K$ 是完全积性函数所以可以在 $O(\pi(n)\log K)$ 时间内筛出.

然后求出 $g\cdot id^K$ 的表达式，我们知道 $g=f\ast \mu$，使用贝尔级数，即对某个素数$p$把素数幂的狄利克雷卷积变成OGF的卷积.容易知道$f$和$\mu$模$p$的贝尔级数分别是 $1+px$ 和 $1-x$，于是$g$模$p$的贝尔级数是 $1+(p-1)x-px^2$,那么就得到了$g\cdot id^K$ 在素数幂处的值.这样就可以 $O(n\ln\ln n+T)$ 完成本题.

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<bitset>
using namespace std;
const int N=10000005;
unsigned s[N<<1],pw[N<<1];
bitset<N<<1>p;
int prime[3000000];
int cnt,n;unsigned K;
unsigned qpower(unsigned a,unsigned b){unsigned ans=1;for(;b;b>>=1,a*=a)if(b&1)ans*=a;return ans;}
void make(int n)
{
	s[1]=1;
	for(int i=2;i<=n;i++)
	{
		if(!p[i])prime[++cnt]=i,pw[i]=s[i]=qpower(i,K);
		for(int j=1;j<=cnt&&i*prime[j]<=(n<<1);j++)
		{
			int x=i*prime[j];p[x]=1;pw[x]=s[x]=s[i]*s[prime[j]];
			if(i%prime[j]==0)break;
		}
	}
	for(int i=n+1;i<=(n<<1);i++)
		if(!p[i])prime[++cnt]=i,s[i]=qpower(i,K);
	for(int i=2;i<=2*n;i++)s[i]+=s[i-1];
	for(int i=1;i<=n;i++)s[i]=s[(i<<1)-1]+s[i<<1]-(s[i]<<1);
	for(int i=1;i<=cnt&&prime[i]<=n;i++)
		for(int pm=prime[i],j=n/pm;j>=1;j--)
		{
			s[j*pm]+=s[j]*(pm-1)*pw[pm];
			if(j%pm==0)s[j*pm]-=s[j/pm]*pm*pw[pm]*pw[pm];
		}
	for(int i=2;i<=n;i++)s[i]+=s[i-1];
}
int main()
{
	int T,N;
	scanf("%d%d%u",&T,&N,&K);
	make(N);
	for(int i=1;i<=T;i++)
	{
		scanf("%d",&n);printf("%u\n",s[n]);
	}
}
```

---

## 作者：Diwanul (赞：5)

# 题解[LuoguP6222]「P6156简单题」加强版

建议博客中食用。

加强版很好地体现了这个题的真正价值。~~（当然是指卡常~~

本题解给出了本题更详尽的推~~倒~~导和思考过程，思路与 CYJian 的类似，具体式子的个别地方换用了更易于理解的式子，可以看作是给数论新手的对莫反套路和欧拉筛套路的补充解释和技巧指导。

## Problem

最多 $10^4$ 组询问，每次询问给定 $n$ ，求
$$
\begin{aligned}
\sum_{i=1}^n\sum_{j=1}^n(i+j)^K\gcd(i,j)\mu^2(\gcd(i,j))
\end{aligned}
$$
对 $2^{32}$ 取模。其中各个询问的 $K$ 相等。$n\le10^7$

## Solution

对 $2^{32}$ 取模直接 `unsigned int` 自然溢出即可。

### 整体

考虑~~颓~~推式子：可以看到多次出现了 $\gcd$ ，尝试莫反套路，先枚举 $\gcd(i,j)=d$ ，然后将 $d$ 提出到外层，最后对内层 $[gcd(i,j)=1]$ 莫反 。
$$
\begin{aligned}
ans&=\sum_{i=1}^n\sum_{j=1}^n(i+j)^K\gcd(i,j)\mu^2(\gcd(i,j))\\
&=\sum_{i=1}^n\sum_{j=1}^n(i+j)^K\sum_{d\mid i,d\mid j}d\mu^2(d)[\gcd(i,j)=d]\\
&=\sum_{d=1}^nd\mu^2(d)\sum_{i=1}^{\lfloor\frac nd\rfloor}\sum_{j=1}^{\lfloor\frac nd\rfloor}(id+jd)^K[\gcd(id,jd)=d]\\
&=\sum_{d=1}^nd^{K+1}\mu^2(d)\sum_{i=1}^{\lfloor\frac nd\rfloor}\sum_{j=1}^{\lfloor\frac nd\rfloor}(i+j)^K[\gcd(i,j)=1]\\
&=\sum_{d=1}^nd^{K+1}\mu^2(d)\sum_{i=1}^{\lfloor\frac nd\rfloor}\sum_{j=1}^{\lfloor\frac nd\rfloor}(i+j)^K\sum_{t|i,t|j}\mu(t)
\end{aligned}
$$
按照我们的经验，可以想到将 $t$ 也提出到外层并枚举 $T=td$  从而使得式子变成 $n$ 个只关于 $T$ 的函数的和（这种思想是很多数论题降低复杂度的关键，后面还会用）。
$$
\begin{aligned}
ans&=\sum_{d=1}^nd^{K+1}\mu^2(d)\sum_{i=1}^{\lfloor\frac nd\rfloor}\sum_{j=1}^{\lfloor\frac nd\rfloor}(i+j)^K\sum_{t|i,t|j}\mu(t)\\
&=\sum_{d=1}^nd^{K+1}\mu^2(d)\sum_t^{\lfloor\frac nd\rfloor}\mu(t)\sum_{i=1}^{\lfloor\frac n{dt}\rfloor}\sum_{j=1}^{\lfloor\frac n{dt}\rfloor}(it+jt)^K\\
&=\sum_{d=1}^nd\mu^2(d)\sum_t^{\lfloor\frac nd\rfloor}(dt)^K\mu(t)\sum_{i=1}^{\lfloor\frac n{dt}\rfloor}\sum_{j=1}^{\lfloor\frac n{dt}\rfloor}(i+j)^K\\
&=\sum_{T=1}^nT^K\sum_{d|T} d\mu^2(d)\mu(\frac Td)\sum_{i=1}^{\lfloor\frac n{T}\rfloor}\sum_{j=1}^{\lfloor\frac n{T}\rfloor}(i+j)^K
\end{aligned}
$$

### 分离

#### $f(x)$

这时候感觉已经很难再整体推了，那么我们来观察一下式子。

令 $f(T)=\sum_{d|T}d\mu^2(d)\mu(\frac Td)$ ，可以看出这是一堆积性函数做乘法和狄利克雷卷积，得到的结果依然是积性函数，可以考虑用欧拉筛预处理出来。

按照一般欧拉筛预处理积性函数的套路，先考虑在素数次幂上取值，再用积性函数的性质找到最小质因子转移。

那我们来讨论一下这个函数的取值（$p$ 表示质数）：

1.   $f(p^0)$：即 $f(1)=1$ ，这个直接赋值就好，因为欧拉筛不考虑 $1$。

2.   $f(p)$：$p$ 只有两个因子：$p$ 和 $1$ ，其中 $\mu(p)=-1$，$\mu(1)=1$。$f(p)=\mu^2(p)\mu(1)p+\mu^2(1)\mu(p)=p-1$ 。

3.   $f(p^2)$：$p^2$ 有三个因子：$p^2$ ， $p$ 和 $1$ ，其中 $\mu(p^2)=0$，$\mu(p)=-1$，$\mu(1)=1$，所以带 $\mu(p^2)$ 的项都不会造成贡献。$f(p^2)=\mu^3(p)p=-p$

4.   $f(p^k)(k>2)$：考虑某一项 $\mu^2(p^l)\mu(p^{k-l})p^l$：当 $l\geq 2$ 时，$\mu^2(p^l)=0$，该项无贡献；当 $l<2$ 时，$k-l\geq 2$，$\mu(p^{k-l})=0$ 该项无贡献。$f(p^k)=0(k>2)$

所以我们可以在筛的时候判一下最小质因子的指数转移，并乘上 $T^k$（这个也可以筛出来），具体实现见代码。

#### $g(x)$

那我们看看剩下的这一部分：令 $g(n)=\sum_{i=1}^n\sum_{j=1}^n(i+j)^K$。这里我们又可以考虑枚举 $s=i+j$ 来使得内层是只有一个参数的函数。
$$
\begin{aligned}
g(n)&=\sum_{i=1}^n\sum_{j=1}^n(i+j)^K\\
&=\sum_{s=2}^{2n}\sum_{i=\max(s-n,1)}^{\min(n,s-1)}s^K\\
&=\sum_{s=2}^{2n}(\min(n,s-1)-\max(s-n,1)+1)s^K
\end{aligned}
$$
我们发现出现了非常难处理的 $\max$ 和 $\min$ 。考虑通过钦定判断的结果来消去这种难处理的基于判断的函数。
$$
\begin{aligned}
g(n)&=\sum_{s=2}^{2n}(\min(n,s-1)-\max(s-n,1)+1)s^K\\
&=\sum_{s=n+1}^{2n}(n-(s-n)+1)s^K+\sum_{s=2}^n((s-1)-1+1)s^K\\
&=\sum_{s=n+1}^{2n}(2n-s+1)s^K+\sum_{s=2}^n(s-1)s^K
\end{aligned}
$$
仔细观察，我们发现系数中同时包含了常数 $n$ 和 $1$，以及变量 $s$ 。考虑把所有的常数系数都提出来。
$$
\begin{aligned}
g(n)&=\sum_{s=n+1}^{2n}(2n-s+1)s^K+\sum_{s=2}^n(s-1)s^K\\
&=(2n+1)\sum_{s=n+1}^{2n}s^K-\sum_{s=n+1}^{2n}s^{K+1}+\sum_{s=2}^ns^{K+1}-\sum_{s=2}^ns^K
\end{aligned}
$$
此时已经将 $g(n)$ 转化为几个 $s^K$ 和 $s^{K+1}$ 的前缀和了，这个可以用欧拉筛筛出来再做前缀和。

### 合并

目前我们已经得到 $f(x)$ 和 $g(x)$ 的 $O(1)$ 查询方法，所以可以将整个函数作为一个整体来代入回原式寻找下一步的方向（这里看作 $T^K$ 已经并入到 $f(x)$ 中了）。
$$
\begin{aligned}
ans&=\sum_{T=1}^nf(T)g(\lfloor\frac nT\rfloor)
\end{aligned}
$$
$\sum$ 里套 $\lfloor\frac nT\rfloor$ ，想到了什么？数论分块！不同的 $g(\lfloor\frac nT\rfloor)$ 只会有 $\sqrt n$ 种不同的取值，我们可以考虑预处理出 $f(T)$ 的前缀和进行计算，具体实现见代码。

## Core Code

附有详细注释，可放心食用！

```cpp
typedef unsigned int UI;//自然溢出

const UI N=20000000,K=(1<<31);//这里 N 开双倍是因为 g(x) 中有 2n 的项。

UI n,d,nn;
UI p[N+10],tp,pk[N+10],pk1[N+10],f[N/2+10];//这里开一半是因为这题卡空间。
bool b[N+10];

inline void MakePrime(){
	pk[1]=f[1]=1;
	for(UI i=2;i<=nn;++i){
		if(!b[i]){
			p[++tp]=i,pk[i]=Pow(i,d);
			if(i<=nn/2)
				f[i]=i-1;//f 不需要开到 2n
		}
		for(UI j=1;j<=tp&&p[j]*i<=nn;++j){
			UI t=p[j]*i;
			b[t]=1;
			pk[t]=pk[p[j]]*pk[i];//i^k 是完全积性函数
			if(i%p[j])
				f[t]=f[i]*f[p[j]];//如果互质就直接积性函数相乘
			else{
				UI tt=i/p[j];
				if(tt%p[j])
					f[t]=-p[j]*f[tt];//如果 i 中只有 1 个 p[j] 那么 p[j]*p[j] 和 i/p[j] 互质。
				else
					f[t]=0;//k>2 的情况
				break;
			}
		}
	}
	for(UI i=1;i<=nn/2;++i)
		f[i]=f[i-1]+f[i]*pk[i];//将 T^K 并入 f 中
	for(UI i=1;i<=nn;++i)
		pk1[i]=pk1[i-1]+pk[i]*i,pk[i]+=pk[i-1];//pk[i] 为 i^k 的前缀和，pk1[i] 为 i^(k+1) 的前缀和。
}

inline UI A(UI x){
	return (2*x+1)*(pk[x<<1]-pk[x])+pk1[x]-(pk1[x<<1]-pk1[x])-pk[x];//g(x)
}

inline void Solve(){
	UI ans=0;
	n=read();
	for(UI l=1,r;l<=n;l=r+1){
		r=n/(n/l);
		ans+=A(n/l)*(f[r]-f[l-1]);//数论分块
	}
	printf("%u\n",ans);
}

int main(){
	UI T=read();
	nn=read()*2,d=read();//nn 表示最大的 n ，而筛法要求筛到 2n，所以将 nn*=2
	MakePrime();
	while(T--)
		Solve();
	return 0;
}
```

感谢观赏。

---

## 作者：ZillionX (赞：5)

# Description

多组数据，给定常数 $K$，每次询问给出不同的 $n$，求

$$\sum_{i=1}^n \sum_{j=1}^n (i+j)^K \gcd(i,j) \mu^2(\gcd(i,j)) \bmod 2^{32}$$

$T = 10^4, K < 2^{31}, n \le 10^7$，时限 1.5s。

# Solution

不妨设 $f(i) = i \mu^2(i), g*I=f$，由反演套路有

$$\begin{aligned}\text{原式}&= \sum_{i=1}^n \sum_{j=1}^n(i+j)^K\sum_{d|i, d|j} g(d)\\&=\sum_{d=1}^n g(d) \sum_{d|i}\sum_{d|j}(i+j)^K\\&=\sum_{d=1}^ng(d)d^K \sum_{i=1}^{\left\lfloor\frac{n}{d}\right\rfloor}\sum_{j=1}^{\left\lfloor\frac{n}{d}\right\rfloor}(i+j)^K\\&=\sum_{d=1}^ng(d)d^KS(\left\lfloor\frac{n}{d}\right\rfloor) &(1)\end{aligned}$$

这里的 $S(n)= \sum\limits_{i=1}^n\sum\limits_{j=1}^n(i+j)^K$。

考虑快速预处理出 $S(n)$，直接拆开显然不是很好求，我们对其进行差分，有

$$\begin{aligned}\Delta S(n)&= S(n)-S(n-1)\\&=2 \sum_{i=1}^{n-1}(i+n)^K+(2n)^K\end{aligned}$$

上面的过程是讨论两个 $\sum$ 加入 $i=n$ 后增加的贡献推导出来的。

由该式可以观察出 $S(n)$ 并非积性函数，但是可以线性筛 $id_k$ 后快速算出。

现在我们回到式 $(1)$，对整个式子同时进行差分。

$$\Delta {\rm Ans}(n)=\sum_{d=1}^ng(d)d^KS(\left\lfloor\frac{n}{d}\right\rfloor) - \sum_{d=1}^{n-1}g(d)d^KS(\left\lfloor\frac{n-1}{d}\right\rfloor) $$

众所周知，观察相邻被除数在差分时的表现，有

$$\left\lfloor\frac{n}{d}\right\rfloor \neq \left\lfloor\frac{n-1}{d}\right\rfloor \Longleftrightarrow d | n$$

且此时 $\left\lfloor\dfrac{n-1}{d}\right\rfloor = \left\lfloor\dfrac{n}{d}\right\rfloor-1$。

因此我们可以继续推出

$$\Delta {\rm Ans}(n)=\sum_{d|n}g(d)d^K\Delta S(\dfrac{n}{d})$$

接下来考虑算出 $g$。

$f$ 是 $id$ 和 $\mu^2$ 点积出来的结果，因此 $f$ 的贝尔级数应当是 $1+px$（把 $1$ 和 $p^k$ 处的函数值乘一下就不难导出来了）。 

又由 $g*I=f$ 得到 $g=f*\mu$，因此 $g$ 的贝尔级数应当是 $(1+px)(1-x)=1+(p-1)x-px^2$，这样我们就得到了 $g$ 在质数幂处的值，不难线性筛预处理出 $g \cdot id_k$ 了。

接下来，我们使用快速卷积性函数的套路，将积性函数 $g \cdot id_k$ 分解为若干个只与质数 $p$ 有关的函数的卷积，再将这些函数分别卷到 $\Delta S$ 上去，就可以得到 $\mathcal O(\sum\limits_p\sum\limits_{k=1}^{p^k\le n} \dfrac{n}{p^k})=\mathcal O(n \log \log n)$ 的复杂度。

至此我们就在 $\mathcal O(n \log \log n + T)$ 的时间复杂度下完成了本题。

# Code

对 $2^{32}$ 取模直接 ```unsigned int``` 自然溢出就好了。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef unsigned int ui;
const ui N=2e7+1,P=1270608,O=1e7+2;
ui T,n,k,tot,p[P],id[N],s[O];
bitset<N> vs;
ui Qpow(ui x,ui y) {
	ui Mul=1;
	while (y) {
		if (y&1) Mul*=x;
		x*=x,y>>=1;
	}
	return Mul;
}
void Init(ui n) {
	vs[1]=1,id[1]=1;
	for (ui i=2;i<=n*2;i++) {
		if (vs[i]==0) {
			p[++tot]=i;
			id[i]=Qpow(i,k);
		}
		for (ui j=1;j<=tot && 1ll*i*p[j]<=n*2;j++) {
			id[i*p[j]]=id[i]*id[p[j]];
			vs[i*p[j]]=1;
		}
	}
	for (ui i=1;i<=n*2;i++) id[i]+=id[i-1];
	for (ui i=1;i<=n;i++) s[i]=id[i*2-1]-id[i]*2+id[i*2];
	for (ui i=n;i>=1;i--) id[i]-=id[i-1];
	for (ui i=1;i<=tot && p[i]<=n;i++)
		for (ui j=n/p[i];j>=1;j--) {
			s[j*p[i]]+=s[j]*(p[i]-1)*id[p[i]];
			if (!(j%p[i])) s[j*p[i]]-=s[j/p[i]]*p[i]*id[p[i]*p[i]];
		}
	for (ui i=1;i<=n;i++) s[i]+=s[i-1];
}
int main() {
	scanf("%u%u%u",&T,&n,&k);
	Init(n);
	while (T--) {
		ui x;
		scanf("%u",&x);
		printf("%u\n",s[x]);
	}
	return 0;
}
```

---

## 作者：xixike (赞：3)

[更好的阅读体验](https://www.cnblogs.com/xixike/p/15699767.html)

## Description

[Luogu传送门](https://www.luogu.com.cn/problem/P6222)

## Solution

加强版就只是纯粹的加强版，取模可以省掉，直接自然溢出即可，还是简单讲一讲吧。

首先，我们不难发现，$f(x) = \mu^2(x)$。

然后就是一波基础而不失难度的推式子。
$$
\begin{aligned}
& \sum\limits_{i = 1}^n\sum_{j = 1}^n(i + j)^k\mu^2(\gcd(i, j))\gcd(i, j) \\
=& \sum_{i = 1}^n\sum_{j = 1}^n(i + j)^k\sum_{d = 1}^n\mu^2(d)d[\gcd(i, j) = d] \\ 
=& \sum_{d = 1}^nd\mu^2(d)\sum_{i = 1}^{\lfloor \frac{n}{d} \rfloor}\sum_{j = 1}^{\lfloor \frac{n}{d} \rfloor}(id + jd)^k[\gcd(i, j) = 1] \\
=& \sum_{d = 1}^nd^{k + 1}\mu^2(d)\sum_{i = 1}^{\lfloor \frac{n}{d} \rfloor}\sum_{j = 1}^{\lfloor \frac{n}{d} \rfloor}(i + j)^k[\gcd(i, j) = 1] \\
=& \sum_{d = 1}^nd^{k + 1}\mu^2(d)\sum_{i = 1}^{\lfloor \frac{n}{d} \rfloor}\sum_{j = 1}^{\lfloor \frac{n}{d} \rfloor}\sum_{p \mid (i, j)}\mu(p)(i + j)^k \\
=& \sum_{d = 1}^nd^{k + 1}\mu^2(d)\sum_{p = 1}^{\lfloor \frac nd \rfloor}\mu(p) \sum_{i = 1}^{\lfloor \frac{n}{dp} \rfloor}\sum_{j = 1}^{\lfloor \frac{n}{dp} \rfloor}\sum_{p \mid (i, j)}(ip + jp)^k \\
=& \sum_{d = 1}^nd^{k + 1}\mu^2(d)\sum_{p = 1}^{\lfloor \frac nd \rfloor}\mu(p)p^k \sum_{i = 1}^{\lfloor \frac{n}{dp} \rfloor}\sum_{j = 1}^{\lfloor \frac{n}{dp} \rfloor}\sum_{p \mid (i, j)}(i + j)^k \\
\end{aligned}
$$
经典令 $T = dp$，则：
$$
\begin{aligned}
& \sum_{T = 1}^n\sum_{i = 1}^{\lfloor \frac{n}{T} \rfloor}\sum_{j = 1}^{\lfloor \frac{n}{T} \rfloor}(i + j)^k\sum_{d | T}d^{k + 1}\mu^2(d)\mu(\frac Td)(\frac Td) ^k  \\
=& \sum_{T = 1}^nT^k\sum_{i = 1}^{\lfloor \frac{n}{T} \rfloor}\sum_{j = 1}^{\lfloor \frac{n}{T} \rfloor}(i + j)^k\sum_{d \mid T}d\mu^2(d)\mu(\frac Td)  \\
\end{aligned}
$$
我们再令 
$$
S(n) = \sum\limits_{i = 1}^n\sum\limits_{j = 1}^n(i + j)^k \\
f(n) = \sum\limits_{d \mid n}d\mu^2(d)\mu(\frac nd)
$$
那么原式为：
$$
\sum_{T = 1}^nT^kS(\frac nT)f(T)
$$
我们只要能够快速求出 $S(n)$ 和 $f(n)$ 即可。

----------------------

先来看 $S(n)$。

设 $F(n) = \sum\limits_{i = 1}^ni^k$，$G(n) = \sum\limits_{i = 1}^nF(i)$。

结论：
$$
S(n) = G(2n) - 2G(n)
$$
证明：

> 考虑使用数学归纳法。
>
> $S(n) = G(2n) - 2G(n)$，那么有 $S(n + 1) = G(2n + 2) - 2G(n + 1)$。
> $$
> \begin{aligned}
> S(n + 1) = & \sum_{i = 1}^{n + 1}\sum_{j = 1}^{n + 1}(i + j)^k\\
> =& S(n) + 2\sum_{i = 1}^n(i + n + 1)^k + (2n + 2)^k \\
> =& S(n) + 2F(2n + 1) - 2F(n + 1) + F(2n + 2) - F(2n + 1) \\
> =& G(2n) - 2G(n) + F(2n + 1) + F(2n + 2)  - 2F(n + 1) \\
> =& \sum_{i = 1}^{2n}F(i) - 2\sum_{i = 1}^nF(i) + F(2n + 1) + F(2n + 2) - 2F(n + 1) \\
> =& G(2n + 2) - 2G(n + 1)
> \end{aligned}
> $$
> 

证毕.

所以线性筛时筛出 $i^k$ 求两遍前缀和得到 $G(n)$，就可以 $O(1)$ 求出 $S(n)$ 了。

-----------------

接下来看 $f(n)$ 怎么求，$f(n) = \sum\limits_{d \mid n}d\mu^2(d)\mu(\frac nd)$。

我们发现 $f(n)$ 是由好几个积性函数乘起来的，所以它也是积性函数。

对于质数 $p$ ：$f(p) = \mu^2(1)\mu(p) \times p\mu^2(p)\mu(1) = p - 1$

回忆一下线性筛的过程，我们对一个数 $i$ 配上一个质数 $p$。

下面我们进行分类讨论：

- $p \nmid i$ ：$f(ip) = f(i) \times f(p)$

- $p \mid i$ ：

  - $p^2 \mid i$ 且 $p^3 \nmid i$ ：

    $f(p^2) = \mu^2(1)\mu(p^2) \times p\mu^2(p)\mu(p) \times p^2\mu^2(p^2)\mu(1) = -p$

    那么 $f(ip) = f(p^2) \times f(i) = (-p)f(i)$。

  - $p^k \mid i \ \ (k \geq 3)$ ：

    此时，每一项中的 $d$ 和 $\frac nd$ 中必有一个有二次项，使得 $\mu^2(d)$ 和 $\mu(\frac nd)$ 中必有一个为 0，所以 $f(p) = 0$。

附上线性筛的代码：

$Code$

```cpp
inline void euler(){
    f[1] = 1;
    for(int i = 2; i < N; ++i){
        if(!vis[i]) p[++tot] = i, f[i] = i - 1;
        for(int j = 1; j <= tot && i * p[j] < N; ++j){
            vis[i * p[j]] = 1;
            if(i % p[j]) f[i * p[j]] = f[i] * f[p[j]] % mod;
            else{
                if((i / p[j]) % p[j]) f[i * p[j]] = f[i / p[j]] * (mod - p[j]) % mod;
                break;
            }
        }
    }
}
```



-----------------

至此，这道题就可以愉快的解决啦，计算答案的时候整除分块走一个即可。

我在预处理时把 $T^k$ 和 $f(T)$ 乘到了一起，具体为线性筛后面的第一个前缀和。

## Code

```cpp
#include <bits/stdc++.h>
#define uint unsigned int

using namespace std;

namespace IO{
    inline int read(){
        int x = 0;
        char ch = getchar();
        while(!isdigit(ch)) ch = getchar();
        while(isdigit(ch)) x = (x << 3) + (x << 1) + ch - '0', ch = getchar();
        return x;
    }

    template <typename T> inline void write(T x){
        if(x > 9) write(x / 10);
        putchar(x % 10 + '0');
    }
}
using namespace IO;

const int N = 2e7 + 10;
int T, Max, n, k, tot;
uint p[N], f[N], F[N];
bool vis[N];

inline uint qpow(uint a, uint b){
    uint res = 1;
    while(b){
        if(b & 1) res = res * a;
        a = a * a, b >>= 1;
    }
    return res;
}

inline void euler(int n){
    f[1] = F[1] = 1;
    for(int i = 2; i <= n; ++i){
        if(!vis[i]) p[++tot] = i, f[i] = i - 1, F[i] = qpow(i, k);
        for(int j = 1; j <= tot && i * p[j] <= n; ++j){
            vis[i * p[j]] = 1;
            F[i * p[j]] = F[i] * F[p[j]];
            if(i % p[j]) f[i * p[j]] = f[i] * f[p[j]];
            else{
                if((i / p[j]) % p[j]) f[i * p[j]] = -p[j] * f[i / p[j]];
                break;
            }
        }
    }
    for(int i = 1; i <= n; ++i) f[i] = (f[i - 1] + f[i] * F[i]), F[i] = (F[i] + F[i - 1]);
    for(int i = 1; i <= n; ++i) F[i] = (F[i] + F[i - 1]);
}

inline uint S(int n){
    return F[n << 1] - (F[n] << 1);
}

inline uint solve(int n){
    uint res = 0;
    for(int l = 1, r; l <= n; l = r + 1){
        r = n / (n / l);
        res += S(n / l) * (f[r] - f[l - 1]);
    }
    return res;
}

signed main(){
    T = read(), Max = read(), k = read();
    euler(Max << 1);
    while(T--) write(solve(read())), puts("");
    return 0;
}
```

$$\_EOF\_$$



---

## 作者：keatsli (赞：2)

$$\sum\limits_{i=1}^n\sum\limits_{j=1}^n(i+j)^k\gcd(i,j)\mu^2(\gcd(i,j))$$

$$=\sum\limits_{i=1}^n\sum\limits_{j=1}^n(i+j)^k\gcd(i,j)\sum\limits_{d^2\mid i,d^2\mid j}\mu(d)$$


$$=\sum\limits_{d=1}^n\mu(d)d^{2k+2}\sum\limits_{i=1}^{\lfloor\frac{n}{d^2}\rfloor}\sum\limits_{j=1}^{\lfloor\frac{n}{d^2}\rfloor}(i+j)^k\gcd(i,j)$$

$$=\sum\limits_{d=1}^n\mu(d)d^{2k+2}\sum\limits_{i=1}^{\lfloor\frac{n}{d^2}\rfloor}\sum\limits_{j=1}^{\lfloor\frac{n}{d^2}\rfloor}(i+j)^k\sum\limits_{g\mid i,g\mid j}\varphi(g)$$

$$=\sum\limits_{d^2g\leq n}\mu(d)d^{2k+2}\varphi(g)g^k\sum\limits_{i=1}^{\lfloor\frac{n}{d^2g}\rfloor}\sum\limits_{j=1}^{\lfloor\frac{n}{d^2g}\rfloor}(i+j)^k$$

记 $f(x)=x^k\sum\limits_{d^2g=x}\mu(d)d^2\varphi(g)$，$g(x)=\sum\limits_{i=1}^x\sum\limits_{j=1}^x(i+j)^k$。

则 $ANS=\sum\limits_{k=1}^nf(k)g(\frac{n}{k})$，是标准的整除分块形式。

则只需要预处理出 $f$，$g$ 即可 $O(\sqrt n)$ 回答单次询问。

先线性筛出 $\mu(x)$，$\varphi(x)$，$x^k$。

注意到先暴力枚举 $d$，然后枚举 $g$ 来贡献 $f$ 的复杂度为 $O(\int_1^n\frac{n}{x^2}\ dx)=O(n)$，而 $g(x)=g(x-1)+2\sum\limits_{i=x+1}^{2x}i^k-(2x)^k$，故可以递推处理。

则总复杂度 $O(n+T\sqrt n)$。

另外地，注意到 $f$ 是积性函数，而所求即是 $\sum\limits_{ij\leq n}f(i)\Delta_g(j)$，其中 $\Delta_g(x)$ 是 $g(x)$ 的差分，应用积性函数狄利克雷卷积一般函数的技巧可以做到 $O(n\log\log n+T)$ 的复杂度。

---

## 作者：wsyhb (赞：2)

## 前言

1. 说好的“彻底卡掉非线性预处理”，结果我用了埃氏筛的代码还是过了……（当然我也写了一份纯线性筛的代码）
1. 这道题数据范围在原题基础上翻倍，那空间为什么不翻倍呀……害得我不得不重复利用数组，导致代码可读性大大降低……

## 题解

枚举 $\gcd=d$，则答案为：

$$\sum_{d=1}^{n}d\mu^2(d)\sum_{i=1}^{\lfloor \frac{n}{d} \rfloor}\sum_{j=1}^{\lfloor \frac{n}{d} \rfloor}(di+dj)^{K}[\gcd(i,j)=1]$$

将 $[m=1]=\sum_{x \mid m} \mu(x)$ 代入，并将 $d^K$ 提到前面来：

$$\sum_{d=1}^{n}d^{K+1}\mu^2(d)\sum_{i=1}^{\lfloor \frac{n}{d} \rfloor}\sum_{j=1}^{\lfloor \frac{n}{d} \rfloor}(i+j)^{K}\sum_{x \mid i,x \mid j}\mu(x)$$

交换求和符号：

$$\sum_{d=1}^{n}d^{K+1}\mu^2(d)\sum_{x=1}^{\lfloor \frac{n}{d} \rfloor}\mu(x)\sum_{i=1}^{\lfloor \frac{n}{dx} \rfloor}\sum_{j=1}^{\lfloor \frac{n}{dx} \rfloor}(xi+xj)^{K}$$

把 $x^{K}$ 提到前面来：

$$\sum_{d=1}^{n}d^{K+1}\mu^2(d)\sum_{x=1}^{\lfloor \frac{n}{d} \rfloor}x^{K}\mu(x)\sum_{i=1}^{\lfloor \frac{n}{dx} \rfloor}\sum_{j=1}^{\lfloor \frac{n}{dx} \rfloor}(i+j)^{K}$$

令 $T=dx$，并改为枚举 $T$ 和 $d$：

$$\sum_{T=1}^{n}(\sum_{i=1}^{\lfloor \frac{n}{T} \rfloor}\sum_{i=1}^{\lfloor \frac{n}{T} \rfloor}(i+j)^{K})(\sum_{d \mid T}d^{K+1}\mu^2(d)(\frac{T}{d})^K\mu(\frac{T}{d}))$$

P.S. 这一个式子中 $i,j$ 的上界是 $\lfloor \dfrac{n}{T} \rfloor$。（下同）

用 $dT^K$ 替换 $d^{K+1}(\dfrac{T}{d})^K$，并将 $T^K$ 提到外面来：

$$\sum_{T=1}^{n}(\sum_{i=1}^{\lfloor \frac{n}{T} \rfloor}\sum_{i=1}^{\lfloor \frac{n}{T} \rfloor}(i+j)^{K})(\sum_{d \mid T}d\mu^2(d)\mu(\frac{T}{d}))T^{K}$$

令：

$$F(t)=\sum_{i=1}^{t}\sum_{j=1}^{t}(i+j)^{K}$$

$$G(t)=\sum_{d \mid t}d\mu^2(d)\mu(\frac{t}{d})$$

则答案为：

$$\sum_{T=1}^{n}F(\lfloor \frac{n}{T} \rfloor )G(T)T^{K}$$

------------

先考虑 $F$ 怎么求。

我们将 $F$ 相邻两项作差：

$$F(t)-F(t-1)=\sum_{i=1}^{t}(i+t)^K+\sum_{j=1}^{t-1}(t+j)^{K}=\sum_{i=t+1}^{2t}i^k+\sum_{i=t+1}^{2t-1}i^k$$

**线性筛**预处理 $K$ 次方幂并求前缀和，那么 $F$ 就可以 $O(N)$ 递推。

------------

再考虑 $G$ 怎么求。

设 $x=p_1^{\alpha_1}p_2^{\alpha_2}\cdots p_k^{\alpha_k}$，其中 $p_i \; (1 \le i \le k)$ 为互不相同的质数且 $\alpha_i>0 \; (1 \le i \le k)$。

令 $g(x)=x \cdot \mu^2(x)$，则 $G=g * \mu$。（$*$ 表示**狄利克雷卷积**，其定义及性质可参考：[OI Wiki - Dirichlet 卷积](https://oi-wiki.org//math/number-theory/mobius/#dirichlet)）

考虑 $k=1$ 的情况：

1. 若 $\alpha_1=1$，则 $G(x)=g(1)\mu(p_1)+g(p_1)\mu(1)=p_1-1$。
1. 若 $\alpha_1=2$，则 $G(x)=g(p_1)\mu(p_1)=-p_1$。（当 $g$ 或 $\mu$ 的自变量含有平方因子时，其对应的因变量值为 $0$，因此 $g$ 和 $\mu$ 的因变量必须各含一个 $p_1$）
1. 若 $\alpha_1>2$，则 $G(x)=0$。（根据抽屉原理，$g$ 或 $\mu$ 中至少有一个含有平方因子）

由于 $\mu(x)$ 是积性的，$g(x)=x \cdot \mu^2(x)$ 也是积性的，所以 $G=g * \mu$ 也是积性的。

于是我们得出了一般化的 $G$ 的表达式：

$$G(x)=\prod_{i=1}^{k}([\alpha_i=1](p_i-1)+[\alpha_i=2](-p_i))$$

其中 $x=p_1^{\alpha_1}p_2^{\alpha_2}\cdots p_k^{\alpha_k}$。

我们可以花 $O(N\log{\log{N}})$ 的时间使用**埃氏筛**预处理 $G$：

``` cpp
for(int i=1;i<=cnt&&prime[i]<=N;++i)
{
	int p=prime[i];
	for(int j=p;j<=N;j+=p)
	{
		if(G[j])
		{
			int t=j/p,expo=1;
			if(t%p==0)
			{
				t/=p,++expo;
				if(t%p==0)
					++expo;
			}
			if(expo==3)
				G[j]=0;
			else if(expo==1)
				G[j]*=(p-1);
			else
				G[j]*=-p; 
		}
	}
}
```

（此处质数数组 `prime` 已提前求好，且数组 `G` 为 `unsigned int` 类型）

当然更高效的办法是使用**线性筛**，并**记录每个数的最小质因子的指数**，用于更新 $i \bmod \mathit{prime}(j)=0$ 时的 `G[i*prime[j]]`：

``` cpp
G[1]=1;
for(int i=2;i<=N;++i)
{
	if(mark_p[i])
	{
		prime[++cnt]=i;
		G[i]=i-1;
		expo[i]=1;
	}
	for(int j=1;j<=cnt&&i*prime[j]<=N;++j)
	{
		mark_p[i*prime[j]]=false;
		if(i%prime[j]==0)
		{
			if(expo[i]==1)
				G[i*prime[j]]=G[i/prime[j]]*(-prime[j]);
			else
				G[i*prime[j]]=0;
			expo[i*prime[j]]=expo[i]+1;
			break;
		}
		G[i*prime[j]]=G[i]*G[prime[j]];
		expo[i*prime[j]]=1;
	}
}
```

（此处数组 `mark_p` 为 `bool` 类型，且初值为 `true`）

------------

在花 $O(N)$（或 $O(N\log{\log{N}})$）的时间预处理好 $F$ 和 $G$ 之后，对 $G$ 求前缀和，即可使用整除分块，在 $O(\sqrt{N})$ 时间内回答单个询问。

因此，总时间复杂度为 $O(N+T\sqrt{N})$（或 $O(N\log{\log{N}}+T\sqrt{N})$）。

## 代码

P.S. 

为了保证代码的可读性（尤指数组变量名），**此处贴的代码是纯线性筛 & MLE 80 分的代码**。

若需了解如何压缩空间（对数组进行重复利用），请移步至剪贴板：[洛谷 P6222 纯线性筛（AC 代码）](https://www.luogu.com.cn/paste/z9aqytw8)。

若想查看埃氏筛做法完整 AC 代码，请移步至剪贴板：[洛谷 P6222 线性筛+埃氏筛（AC 代码）](https://www.luogu.com.cn/paste/vm9rilat)。（这份压缩了空间的埃氏筛代码，与前一份同样压缩了空间的纯线性筛代码相比，可读性要高一些）

``` cpp
#include<bits/stdc++.h>
using namespace std;
inline unsigned int qpow(unsigned int a,int n)
{
	unsigned int res=1;
	while(n)
	{
		if(n&1)
			res*=a;
		a*=a;
		n>>=1;
	}
	return res;
}
int T,N,K;
const int max_N=1e7+5;
bool mark_p[max_N<<1];
const int max_cnt=2e7+5;
int prime[max_cnt],cnt;
unsigned int Pow[max_N<<1],sum_Pow[max_N<<1],F[max_N],G[max_N],sum[max_N],expo[max_N];
inline void init()
{
	int M=N<<1;
	for(int i=2;i<=M;++i)
		mark_p[i]=true;
	Pow[1]=sum_Pow[1]=1;
	for(int i=2;i<=M;++i)
	{
		if(mark_p[i])
		{
			prime[++cnt]=i;
			Pow[i]=qpow(i,K);
		}
		for(int j=1;j<=cnt&&i*prime[j]<=M;++j)
		{
			mark_p[i*prime[j]]=false;
			Pow[i*prime[j]]=Pow[i]*Pow[prime[j]];
			if(i%prime[j]==0)
				break;
		}
		sum_Pow[i]=sum_Pow[i-1]+Pow[i];
	}
	cnt=0;
	G[1]=1;
	for(int i=2;i<=N;++i)
	{
		if(mark_p[i])
		{
			prime[++cnt]=i;
			G[i]=i-1;
			expo[i]=1;
		}
		for(int j=1;j<=cnt&&i*prime[j]<=N;++j)
		{
			mark_p[i*prime[j]]=false;
			if(i%prime[j]==0)
			{
				if(expo[i]==1)
					G[i*prime[j]]=G[i/prime[j]]*(-prime[j]);
				else
					G[i*prime[j]]=0;
				expo[i*prime[j]]=expo[i]+1;
				break;
			}
			G[i*prime[j]]=G[i]*G[prime[j]];
			expo[i*prime[j]]=1;
		}
	}
	for(int i=1;i<=N;++i)
	{
		F[i]=F[i-1]+sum_Pow[i<<1]+sum_Pow[(i<<1)-1]-(sum_Pow[i]<<1);
		sum[i]=sum[i-1]+G[i]*Pow[i];
	}
}
int main()
{
	scanf("%d%d%d",&T,&N,&K);
	init();
	while(T--)
	{
		int n;
		scanf("%d",&n);
		unsigned int ans=0;
		for(int i=1,j;i<=n;i=j+1)
		{
			int v=n/i;
			j=n/v;
			ans+=(sum[j]-sum[i-1])*F[v];
		}
		printf("%u\n",ans);
	}
	return 0;
}
```

---

## 作者：mango09 (赞：1)

[P6156 简单题](https://www.luogu.com.cn/problem/P6156) 和 [P6222 「P6156 简单题」加强版](https://www.luogu.com.cn/problem/P6222)

加强版卡空间。

## Description

- 给定整数 $n, k$，请求出
  $$
  \left[\sum_{i = 1}^n \sum_{j = 1}^n (i + j)^k f(\gcd(i, j)) \gcd(i, j) \right] \bmod 998244353
  $$
  $$
  f(n) =
  \begin{cases}
  0 & \exists d > 1, d^2\mid n \\
  1 & \text{othervise}
  \end{cases}
  $$

- $1\le n\le 5\times 10^6, 1\le k\le 10^{18}$。

## Solution

一个重要的性质：$f(n) = \mu^2(n)$。
$$
\begin{aligned}
ans
& = \sum_{i = 1}^n \sum_{j = 1}^n (i + j)^k \mu^2(\gcd(i, j)) \gcd(i, j) \\
& = \sum_{d = 1}^n \sum_{i = 1}^n \sum_{j = 1}^n (i +j)^k \mu^2(d) d [\gcd(i, j) = d] \\
& = \sum_{d = 1}^n \sum_{i = 1}^{\left\lfloor\frac{n}{d}\right\rfloor} \sum_{j = 1}^{\left\lfloor\frac{n}{d}\right\rfloor} (id + jd)^k \mu^2(d) d [\gcd(i, j) = 1] \\
& = \sum_{d = 1}^n d^{k + 1} \mu^2(d) \sum_{i = 1}^{\left\lfloor\frac{n}{d}\right\rfloor} \sum_{j = 1}^{\left\lfloor\frac{n}{d}\right\rfloor} (i + j)^k [\gcd(i, j) = 1]
\end{aligned}
$$
把后面那一项拎出来看
$$
\begin{aligned}
\sum_{i = 1}^{\left\lfloor\frac{n}{d}\right\rfloor} \sum_{j = 1}^{\left\lfloor\frac{n}{d}\right\rfloor} (i + j)^k [\gcd(i, j) = 1]
& = \sum_{p = 1}^{\left\lfloor\frac{n}{d}\right\rfloor} \mu(p) \sum_{i = 1}^{\left\lfloor\frac{n}{d}\right\rfloor} [p\mid i] \sum_{j = 1}^{\left\lfloor\frac{n}{d}\right\rfloor} [p\mid j] (i + j)^k \\
& = \sum_{p = 1}^{\left\lfloor\frac{n}{d}\right\rfloor} \mu(p) \sum_{i = 1}^{\left\lfloor\frac{n}{dp}\right\rfloor} \sum_{j = 1}^{\left\lfloor\frac{n}{dp}\right\rfloor} (ip + jp)^k \\
& = \sum_{p = 1}^{\left\lfloor\frac{n}{d}\right\rfloor} \mu(p) p^k \sum_{i = 1}^{\left\lfloor\frac{n}{dp}\right\rfloor} \sum_{j = 1}^{\left\lfloor\frac{n}{dp}\right\rfloor} (i + j)^k
\end{aligned}
$$
设
$$
f(n) = \sum_{i = 1}^n \sum_{j = 1}^n (i + j)^k
$$
则
$$
\begin{aligned}
ans
& = \sum_{d = 1}^n d^{k +1} \mu^2(d) \sum_{p = 1}^{\left\lfloor\frac{n}{d}\right\rfloor} \mu(p) p^k f\left(\left\lfloor\dfrac{n}{dp}\right\rfloor \right) \\
& = \sum_{T = 1}^n f\left(\left\lfloor\dfrac{n}{T}\right\rfloor \right) \sum_{d\mid T} d^{k + 1} \mu^2(d) \left(\dfrac{T}{d}\right)^k \mu\left(\dfrac{T}{d}\right) \\
& = \sum_{T = 1}^n f\left(\left\lfloor\dfrac{n}{T}\right\rfloor \right) T^k \sum_{d\mid T} d\, \mu^2(d) \mu\left(\dfrac{T}{d}\right)
\end{aligned}
$$
整除分块即可。

观察到题目中

> 时间调至 $1s$，卡掉了 $\Omicron(n\log k), \Omicron(n\log p)$ 的做法。

乱杀 /fad

于是预处理要做到 $\Omicron(n)$。

首先是 $n^k$，其实就是 $\operatorname{Id}_k(n)$，这是一个完全积性函数，可以线性筛；对于质数暴力计算是 $\Omicron(\log p\cdot \pi(n)) \simeq \Omicron(n)$，是线性的；我们顺便求出它的前缀和，记作 $g(n) = \sum_{i = 1}^n i^k$。

然后是 $f(n)$，令 $h(n) = \sum_{i = 1}^n g(i)$。

> 结论：
 $$
 f(n) = h(2n) - 2h(n)
 $$

> 证明：
>
> 数学归纳法。
>
> $f(1) = \sum_{i = 1}^n\sum_{j = 1}^n (i + j)^k = 1$
>
> 当 $f(n) = h(2n) + 2h(n)$ 成立时，有
 $$
 \begin{aligned}
 f(n + 1)
 & = \sum_{i = 1}^n \sum_{j = 1}^n (i + j)^k \\
 & = f(n) + 2 \sum_{i = 1}^n (i + n + 1)^k + (2n + 2)^k \\
 & = f(n) + 2 \sum_{i = n + 2}^{2n +1} i^k + \sum_{i = 2n + 2}^{2n + 2} i^k \\
 & = h(2n) - 2h(n) + 2[g(2n +1) - g(n + 1)] + [g(2n + 2) - g(2n + 1)] \\
 & = \sum_{i = 1}^{2n} g(i) - 2 \sum_{i = 1}^n g(i) + 2 g(2n + 1) - 2 g(n + 1) + g(2n + 2) - g(2n + 1) \\
 & = \left(\sum_{i = 1}^{2n} g(i) + g(2n + 1) + g(2n + 2) \right) - 2 \left(\sum_{i = 1}^n g(i) + g(n + 1) \right) \\
 & = h(2n + 2) - 2h(n + 1)
 \end{aligned}
 $$
> 证毕。

所以 $f(n)$ 可以 $\Theta(1)$ 求。

最后是
$$
\begin{aligned}
\alpha(n)
& = \sum_{d\mid n} d\, \mu^2(d) \mu\left(\dfrac{n}{d}\right) \\
& = [(\operatorname{Id} \cdot \mu^2) * \mu](n)
\end{aligned}
$$
所以这玩意也是个积性函数，考虑线性筛。

- $i\in \mathbb{P}$：$\alpha(i) = 1\cdot \mu^2(1) \cdot \mu(i) + i\cdot \mu^2(i) \cdot \mu(1) = i- 1$；

- $p_j\nmid i$：$\alpha(i\cdot p_j) = \alpha(i) \cdot \alpha(p_j)$；

- $p_j\mid i$：设 $i$ 含 $k$ 个质因数 $p_j$，有 $\alpha(i\cdot p_j) = \alpha\left(\dfrac{i}{p_j^k} \cdot (p_j\cdot p_j^k) \right) = \alpha\left(\dfrac{i}{p_j^k} \right) \cdot \alpha(p_j^{k +1})$ 。

  ​			 现在考虑 $\alpha(p^k)(k\ge 2)$ 的取值：

  - 若 $k = 2$，则 $\alpha(p^2) = 1\cdot \mu^2(1) \cdot \mu(p^2) + p\cdot \mu^2(p) \cdot \mu(p) + p^2\cdot \mu^2(p^2) \cdot \mu(1) =  -p$；
  - 若 $k\ge 3$，则根据抽屉原理，$d$ 和 $\dfrac{n}{d}$ 中必有一个含有至少 $2$ 个质因数 $p$，$\mu$ 值为 $0$，此时 $\alpha(p^k) = 0$。

## Code

```cpp
// 18 = 9 + 9 = 18.
#include <iostream>
#include <cstdio>
#define Debug(x) cout << #x << "=" << x << endl;
typedef long long ll;
using namespace std;

const int MAXN = 1e7 + 5;
const int MOD = 998244353;

int qpow(int a, int b)
{
	int base = a, ans = 1;
	while (b)
	{
		if (b & 1)
		{
			ans = (ll)ans * base % MOD;
		}
		base = (ll)base * base % MOD;
		b >>= 1;
	}
	return ans;
}

int p[MAXN], id[MAXN], alpha[MAXN], sum[MAXN];
bool vis[MAXN];

int g[MAXN], h[MAXN];

void pre(int n, int k)
{
	id[1] = alpha[1] = 1;
	for (int i = 2; i <= n; i++)
	{
		if (!vis[i])
		{
			p[++p[0]] = i;
			id[i] = qpow(i, k);
			alpha[i] = i - 1;
		}
		for (int j = 1; j <= p[0] && i * p[j] <= n; j++)
		{
			vis[i * p[j]] = true;
			id[i * p[j]] = (ll)id[i] * id[p[j]] % MOD;
			if (i % p[j] == 0)
			{
				int k = i / p[j];
				if (k % p[j] == 0)
				{
					alpha[i * p[j]] = 0;
				}
				else
				{
					alpha[i * p[j]] = (ll)alpha[k] * (MOD - p[j]) % MOD;
				}
				break;
			}
			alpha[i * p[j]] = (ll)alpha[i] * alpha[p[j]] % MOD;
		}
	}
	
	for (int i = 1; i <= n; i++)
	{
		sum[i] = (sum[i - 1] + (ll)id[i] * alpha[i] % MOD) % MOD;
		g[i] = (g[i - 1] + id[i]) % MOD;
		h[i] = (h[i - 1] + g[i]) % MOD;
	}
}

int f(int n)
{
	return (h[2 * n] - (ll)2 * h[n] % MOD + MOD) % MOD;
}

int GetSum(int l, int r)
{
	return (sum[r] - sum[l - 1] + MOD) % MOD;
}

int block(int n)
{
	int res = 0;
	for (int l = 1, r; l <= n; l = r + 1)
	{
		int k = n / l;
		r = n / k;
		res = (res + (ll)f(k) * GetSum(l, r) % MOD) % MOD;
	}
	return res;
}

int main()
{
	int n;
	ll k;
	scanf("%d%lld", &n, &k);
	pre(n * 2, k % (MOD - 1));
	printf("%d\n", block(n));
	return 0;
}
```


---

## 作者：CmsMartin (赞：1)

## 题目描述

[题目传送门](https://www.luogu.com.cn/problem/P6222)

## 思路


$$\sum\limits_{i = 1}^n\sum\limits_{j = 1}^m(i+j) ^k gcd(i,j) \mu^2(gcd(i , j))$$

套路枚举 $d$

$$= \sum_{d = 1} ^n\mu^2(d)d\sum_{i=1}^n\sum\limits_{j = 1}^m [gcd(i,j) = d](i+j)^k$$

换元

$$= \sum_{d = 1} ^n\mu^2(d)d\sum_{i=1}^{\lfloor \frac{n}{d} \rfloor}\sum\limits_{j = 1}^{\lfloor \frac{m}{d} \rfloor} [gcd(i,j) = 1](id+jd)^k$$

利用 $[n=1]=\sum_{d \mid n} \mu(d)$ 化简

$$= \sum_{d = 1} ^n\mu^2(d)d^{k+1}\sum_{i=1}^{\lfloor \frac{n}{d} \rfloor}\sum\limits_{j = 1}^{\lfloor \frac{m}{d} \rfloor} [gcd(i,j) = 1](i+j)^k$$

$$= \sum_{d = 1} ^n\mu^2(d)d^{k+1}\sum_{i=1}^{\lfloor \frac{n}{d} \rfloor}\sum\limits_{j = 1}^{\lfloor \frac{m}{d} \rfloor} \sum_{x \mid i,x \mid j}\mu(x)(i+j)^k$$

$$= \sum_{d = 1} ^n\mu^2(d)d^{k+1}\sum_{x=1}^{\lfloor \frac{n}{d} \rfloor}\sum_{x \mid i}^{\lfloor \frac{n}{dx} \rfloor}\sum\limits_{x \mid j}^{\lfloor \frac{m}{dx} \rfloor}(i+j)^k$$

设 $F(x) = \sum_{i=1}^{x} \sum_{j = 1}^x (i+j)^k$

$$\sum_{d=1}^n \mu^2(d)d^{k+1} \sum_{x=1}^{\lfloor \frac{n}{d} \rfloor} 

F(\lfloor \frac{n}{dx} \rfloor)$$

令 $T = dx$

$$\sum_{T=1}^n T^k F(\lfloor \frac{n}{d} \rfloor)\sum_{d \mid T}\mu^2(d)\mu(\frac{T}{d})$$

观察这个柿子，那么有两个函数可以线性筛 $i^k$ 与 $\sum_{d \mid T}\mu^2(d)\mu(\frac{T}{d})$，那么线性筛即可（没学过线性筛的可以看[
P4449 于神之怒加强版 ](https://www.luogu.com.cn/problem/P4449))

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 2e7 + 10;
const long long Mod = 2147483658;

long long N , K , T , n;

int Prime[MAXN / 10] , Cnt;
unsigned int F[MAXN] , S[MAXN];
bitset<MAXN> Vis;

unsigned int Quick_Power(int x , int mi) {
    unsigned int Ans = 1;
    for(; mi ; mi >>= 1, x = 1ll * x * x)
        if(mi & 1) Ans = 1ll * Ans * x;
    return Ans;
}

void Get_Function(int N) {
    F[1] = S[1] = 1;
    for(int i = 2; i <= N; i++) {
        if(!Vis[i]) {
            Prime[++Cnt] = i;
            S[i] = Quick_Power(i , K);
            F[i] = i - 1;
        }
        for(int j = 1; j <= Cnt && Prime[j] * i <= N; j++) {
            Vis[i * Prime[j]] = 1;
            S[i * Prime[j]] = 1ll * S[i] * S[Prime[j]];
            if(i % Prime[j] == 0) {
                 if(i / Prime[j] % Prime[j] != 0)
                    F[i * Prime[j]] = -Prime[ j ] * F[i / Prime[j]];
                break;
            }
            F[i * Prime[j]] = F[i] * F[Prime[j]];
        }
    }
    for(int i = 2; i <= N; i++) {
        F[i] = (F[i] * S[i] + F[i - 1]);
        S[i] = (S[i] + S[i - 1]);
    }
    for(int i = 2; i <= N; i++) {
        S[i] = (S[i] + S[i - 1]);
    }
}

int Sum(int n) {
    return S[n << 1] - (S[n] << 1);
}

unsigned int AC(int n) {
    unsigned int Ans = 0;
    for(int l = 1 , r; l <= n; l = r + 1) {
        r = n / (n / l);
        Ans += (F[r] - F[l - 1]) * Sum(n / l);
    }
    return Ans;
}

int main() {
   	scanf("%u%u%u" ,&T ,&N ,&K);
    Get_Function(N << 1);
    while(T--) {
    	scanf("%u" ,&n);
    	printf("%u\n" ,AC(n));
	}
    return 0;
}
```



---

## 作者：RemiliaScar1et (赞：1)

## P6156 简单题

~~被卡空间卡了10min~~

首先，由肉眼观察可以得到： $f(x)=\mu^2(x)$

即题目求
$$\sum_{i=1}^n\sum_{j=1}^n (i+j)^k\mu^2(gcd(i,j))gcd(i,j)$$

开始推式子部分：令 $gcd(i,j)=d$，

$$
\begin{aligned}
\text{原式}&=\sum_{d=1}^nd\sum_{i=1}^n\sum_{j=1}^n(i+j)^k\mu^2(d)[gcd(i,j)=d]\\
&=\sum_{d=1}^{n}d^{k+1}\sum_{i=1}^{n/d}\sum_{j=1}^{n/d}(i+j)^k[gcd(i,j)=1]
\end{aligned}
$$

套路地设以下函数：

$$f(x)=\sum_{i=1}^{n/d}\sum_{j=1}^{n/d}(i+j)^k[gcd(i,j)=x]$$

$$F(x)=\sum_{x|i}f(i)$$

则

$$f(x)=\sum_{x|i}\mu(\frac{i}{x})F(i)$$
$$\Rightarrow f(1)=\sum_{i=1}^{n/d}\mu(i)F(i)$$

下面化简 $F(x)$

$$
\begin{aligned}
F(x)&=\sum_{x|i}\sum_{j=1}^{n/d}\sum_{r=1}^{n/d}(j+r)^k[gcd(j,r)=x]\\
&=\sum_{j=1}^{n/d}\sum_{r=1}^{n/d}(j+r)^k[x|gcd(i,j)]\\
&=x^k\sum_{j=1}^{n/xd}\sum_{r=1}^{n/xd}(j+r)^k
\end{aligned}
$$

那么：

$$Ans=\sum_{d=1}^n d^{k+1}\mu(d)\sum_{i=1}^{n/d}\mu(i)i^k\sum_{j=1}^{n/id}\sum_{r=1}^{n/id}(j+r)^k$$

令 $T=id\ ,\ Sum(x)=\sum\limits_{i=1}^{x}\sum\limits_{j=1}^{x}(i+j)^k$，则:

$$
Ans=\sum_{T=1}^nT^kSum(\frac{n}{T})\sum_{d|T}d\mu^2(d)\mu{\frac{T}{d}}
$$

式子主要分为两部分需要我们集中精力处理 $Sum(\frac{n}{T})$ 和 $\sum\limits_{d|T}d\mu^2(d)\mu(d)$。

1. **$Sum(x)$**

    以 $x=2,3$ 为例，我们将这个东西写开，试图找寻规律：

    $$
    \begin{array}{cl}
    x=2 & , &Sum(x)=2^k+2\times 3^k+4^k\\
    x=3 & , &Sum(x)=2^k+2\times 3^k+3\times 4^k+2\times 5^k+6^k\\
    \end{array}
    $$

    观察得到，它的系数是一个形似 $\{1,2,3,2,1\}$ 的从 $1$ 开始的连续回文数列。

    我们试图将 $Sum(n)$ 展开，穷举第一个求和积分的变量 $i$ 并将各项列在下面，寻找这个规律的一般性：

    $$
    \begin{array}{cc}
    &j=1&j=2&j=3& &j=n-1&j=n\\
    i=1  & 2^k, & 3^k, & 4^k,& \cdots &  n^k, &(n+1)^k\\
    i=2  & 3^k, & 4^k, & 5^k,& \cdots & (n+1)^k, &(n+2)^k\\
    i=3  & 4^k, & 5^k ,& 6^k,& \cdots & (n+2)^k, &(n+3)^k\\
    \vdots \\
    i=n  & (n+1)^k, & (n+2)^k & (n+3)^k, & \cdots  & (n+n-1)^k, & (n+n)^k\\
    \end{array}
    $$

    加法合并同类项时刚好就是在合并上表对角线以及对角线的平行线上的项。由于这个矩阵长宽相等，所以是系数一个从 $1$ 开始的回文数列，这个规律具有普遍性。

    那么这个东西怎么求呢？画一个图或许就能明白：

    横坐标表示第几项，图形在某一横坐标上的最大纵坐标减最小纵坐标是系数。

    ![](https://img.imgdb.cn/item/6061533b8322e6675c87b897.png)

    红色就是我们要求的部分，黄色是将图形补齐后多出的部分。

    那么 $Sum(n)=\sum\limits_{i=n+1}^{2n}\sum\limits_{j=1}^{i}j^k-\sum\limits_{i=1}^n\sum\limits_{j=1}^{i}j^k=\sum\limits_{i=1}^{2n}\sum\limits_{j=1}^{i}j^k-2\sum\limits_{i=1}^n\sum\limits_{j=1}^{i}j^k$。

    令 $S(x)=\sum\limits_{i=1}^{x}i^k$，则 $Sum(x)=\sum\limits_{i=1}^{2x}F(i)-2\sum\limits_{i=1}^xF(i)$

    对于 $i^k,F(x),\sum F(x)$ ，由于 $i^k$ 是积性函数，可以 $O(n)$ 时间预处理出来，前缀和也可以 $O(n)$ 一起做掉。

2. **$f(T)=\sum_{d|T}d\mu^2(d)\mu(\frac{T}{d})$**

    观察形式可知：这是一堆积性函数卷在一起得到的式子，所以这个东西也一定是积性函数。

    但是这个函数的形式太怪，我们不好配函数使用杜教筛。

    所以我们直接考虑线性筛。

    假设我们线筛枚举到了一个质数 $p$，我们要知晓 $f(q)=f(i\times p^k),\quad (gcd(i,p^k)=1)$ 的值的情况。由于 $f$ 是积性函数，我们可以着重讨论 $f(p^k)$ 的值。

    当 $k=1$ 时，$f(p)=1\mu^2(1)\mu(p)+p\mu^2(p)\mu(1)=p-1$.

    当 $k=2$ 时，$f(p^2)=1\mu^2(1)\mu(p^2)+p\mu^2(p)\mu(p)+p^2\mu^2(p^2)\mu(1)=-p$

    当 $k>2$ 时，我们发现，对于每一项形如 $x\mu^2(x)\mu(\frac{p^k}{x})$ ，$x$ 与 $\frac{p^k}{x}$ 中必有一项是 $p^2$ 的倍数。也就是说，$f(p^k)=0$。

    于是根据这个巧妙的性质，我们只需要线筛中对枚举到的数 $i$ 判断有几个 $p$ 做为质因子即可。

综上，经过上面的 $O(n)$ 预处理后，对于答案式子：

$$Ans=\sum_{T=1}^nSum(\frac{n}{T})T^k\sum_{d|T}d\mu^2(d)\mu{\frac{T}{d}}$$

我们只需要整除分块即可，解决询问的时间复杂度 $O(\sqrt n)$。

由于模数特殊，我们可以直接使用 `unsigned int` 类型自然溢出，省空间同时也不需要手动取模。

code：

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef unsigned int ui;

const int N=2e7+10;

ll T,n,k;
ui pr[N/10],tot=0;
bitset<N> mp;
ui powk[N],F[N],f[N];

ui fpow(ui a,ll k)
{
	ui res=1;
	while(k) {if(k&1) res=res*a; a=a*a; k>>=1; }
	return res;
}

void init(ll n,ll k)
{
	f[1]=powk[1]=mp[1]=1;
	for(ll i=2;i<=n;++i)
	{
		if(!mp[i]) pr[++tot]=i,f[i]=i-1,powk[i]=fpow(i,k);
		for(ui j=1;(ll)pr[j]*i<=n;++j)
		{
			powk[(ui)pr[j]*i]=(ui)powk[pr[j]]*powk[i];
			mp[pr[j]*i]=1;
			if(i%pr[j]==0)
			{
				ui tmp=i/pr[j];
				if(tmp%pr[j]) f[pr[j]*i]=(ui)f[tmp]*(mod-pr[j]);
				break;
			}
			f[pr[j]*i]=(ui)f[i]*(pr[j]-1);
		}
	}
	for(int i=1;i<=n;i++)
	{
		f[i]=((ll)f[i]*powk[i]+f[i-1]);
		F[i]=(F[i-1]+powk[i]);
	}
	for(int i=1;i<=n;i++)
		F[i]=(F[i-1]+F[i]);
}

inline ui Sum(ll x) {return (F[2*x]-2*F[x]);}

int main()
{
	scanf("%lld%lld%lld",&T,&n,&k);
	init(2*n,k);
	while(T--)
	{
		scanf("%lld",&n);
		ui ans=0;
		for(ui l=1,r;l<=n;l=r+1)
		{
			r=(n/(n/l));
			ans+=Sum(n/l)*(f[r]-f[l-1]);
		}
		printf("%u\n",ans);
	}
	return 0;
}

```


---

## 作者：FjswYuzu (赞：1)

双倍题解。$\  $

写了篇也许能看懂的思路。

题目大意：计算：
$$
\sum_{i=1}^n \sum_{j=1}^n (i+j)^k \gcd(i,j) \mu(\gcd(i,j))^2
$$
套路地枚举公约数。
$$
\sum_{d=1}^n \sum_{i=1}^n \sum_{j=1}^n [\gcd(i,j)=d] (i+j)^k \times d \times \mu(d)^2
$$
将与 $i,j$ 无关的东西提出来。
$$
\sum_{d=1}^n d \times \mu(d)^2 \sum_{i=1}^n \sum_{j=1}^n [\gcd(i,j)=d](i+j)^k
$$
修改上界，然后把新多出的 $d^k$ 拿出来。
$$
\sum_{d=1}^n d^{k+1} \mu(d)^2 \sum_{i=1}^{\lfloor \frac{n}{d} \rfloor} \sum_{j=1}^{\lfloor \frac{n}{d} \rfloor} [\gcd(i,j)=1] (i+j)^k
$$
可以发现已经是莫比乌斯反演的基本形式了。
$$
\sum_{d=1}^n d^{k+1} \times \mu(d)^2 \sum_{i=1}^{\lfloor \frac{n}{d} \rfloor} \sum_{j=1}^{\lfloor \frac{n}{d} \rfloor} (i+j)^k \sum_{D|i,D|j} \mu(D)
$$

$$
\sum_{d=1}^n d^{k+1} \times \mu(d)^2 \sum_{D=1}^{\lfloor \frac{n}{d} \rfloor} \mu(D) d^k \sum_{i=1}^{\lfloor \frac{n}{dD} \rfloor} \sum_{j=1}^{\lfloor \frac{n}{dD} \rfloor} (i+j)^k
$$

为了写起来没那么麻烦，令 $\displaystyle P(x)=\sum_{i=1}^x \sum_{j=1}^x (i+j)^k$。
$$
\sum_{d=1}^n d^{k+1} \times \mu(d)^2 \sum_{D=1}^{\lfloor \frac{n}{d} \rfloor} \mu(D) D^k P(\lfloor \dfrac{n}{dD} \rfloor)
$$
枚举 $T$ 去代替 $d,D$。
$$
\sum_{T=1}^n P(\lfloor \dfrac{n}{T} \rfloor) \sum_{d|T} d^{k+1} \mu(d)^2 \mu(\dfrac{T}{d}) (\dfrac{T}{d})^k
$$
将可以放一起的东西拿出来。
$$
\sum_{T=1}^n T^k P(\lfloor \dfrac{n}{T} \rfloor) \sum_{d|T} d \mu(d)^2 \mu(\dfrac{T}{d})
$$
又令 $\displaystyle f(x) = \sum_{d|x} d\mu(d)^2 \mu(\dfrac{x}{d})$。显然可以发现 $f(x)$ 是一个积性函数，线性筛预处理滚个前缀和即可。考虑处理这个 $P(x)$。定义数列 $s$，第 $p$ 个数 $s_{p}$ 表示 $p^k$ 会被统计多少次，原函数可以写成：
$$
P(x)=\sum_{i=1}^{2x} s_i i^k
$$
将其拆开实际上就是滚了几个 $\displaystyle \sum_{i=1}^n i^k$，应该比较好处理。

接下来要处理 $f(x)$ 函数。设 $p$ 为某质数，要处理 $f(p^s)$ 不难发现：

- 当 $s \geq 3$ ，要么 $d | p^2$，要么 $\dfrac{x}{d}|p^2$，所以 $f(x)=0$；   
- 当 $s=2$ 时，能使其有值的时候一定是 $d|p$，此时 $f(x)=-p$；   
- 当 $s=1$ 时，可以得到 $f(x)=x-1$；
- 否则 $f(x)=f(1)=1$。

然后就能愉快地做这道题了。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef unsigned int LL;
int prime[2000005],cnt;
LL k,s[20000005],kcm[20000005],f[20000005];
bitset<20000005> vis;
LL QuickPow(LL x,LL p)
{
	LL ans=1,base=x;
	while(p)
	{
		if(p&1)	ans*=base;
		base*=base;
		p>>=1;
	}
	return ans;
}
void shai(int up)
{
	f[1]=kcm[1]=1;
	for(int i=2;i<=up;++i)
	{
		if(!vis[i])	prime[++cnt]=i,f[i]=i-1,kcm[i]=QuickPow(i,k);
		for(int j=1;j<=cnt && i*prime[j]<=up;++j)
		{
			vis[i*prime[j]]=true;
			kcm[i*prime[j]]=kcm[i]*kcm[prime[j]];
			if(i%prime[j])	f[i*prime[j]]=f[i]*f[prime[j]];
			else
			{
				LL modify=i/prime[j];
				if(modify%prime[j])	f[i*prime[j]]=-prime[j]*f[modify];
				break;
			}
		}
	}
	for(int i=2;i<=up;++i)	f[i]=f[i-1]+f[i]*kcm[i],kcm[i]+=kcm[i-1];
	for(int i=2;i<=up;++i)	kcm[i]+=kcm[i-1];
}
LL sum(LL x){return (kcm[x*2]-kcm[x]*2);}
int main(){
	int T;
	cin>>T;
	int N;
	cin>>N>>k;
	shai(2*N);
	while(T-->0)
	{
		int n;
		cin>>n;
		LL ans=0;
		for(int l=1,r;l<=n;l=r+1)
		{
			r=n/(n/l);
			ans+=(f[r]-f[l-1])*sum(n/l);
		}
		cout<<ans<<endl;
	}
	return 0;
}
```



---

## 作者：crashed (赞：1)

# 题目
[点这里](https://www.luogu.com.cn/problem/P6156)看原版题目。   
[点这里](https://www.luogu.com.cn/problem/P6222)看加强题目。
# 分析
## 简单版
**请注意，该部分仅有部分内容（推式子）与本题相关，如果想了解本题的处理方法请直接浏览*加强版*内容**
  
不难发现 $f(n)=\mu^2(n)$ 。
  
（这里定义 $f^k(n)=(f(n))^k$ ）   
   
然后开始娴熟地推式子：   
   
$$
\begin{aligned}
  &\sum_{i=1}^n\sum_{j=1}^n \mu^2(\gcd(i,j))\gcd(i,j)(i+j)^k\\
= &\sum_{d=1}^n \mu^2(d)d\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{j=1}^{\lfloor\frac n d\rfloor} (id+jd)^k[\gcd(i,j)=1]\\
= &\sum_{d=1}^n \mu^2(d)d^{k+1}\sum_{t=1}^{\lfloor\frac n d\rfloor}\mu(t)t^k\sum_{i=1}^{\lfloor\frac{n}{dt}\rfloor}\sum_{j=1}^{\lfloor\frac{n}{dt}\rfloor} (i+j)^k\\
\end{aligned}
$$
   
为了方便简洁，我们定义 $S(n)=\sum_{i=1}^n\sum_{j=1}^n(i+j)^k$ ，然后就有：   
   
$$
\begin{aligned}
  &\sum_{d=1}^n \mu^2(d)d^{k+1}\sum_{t=1}^{\lfloor\frac n d\rfloor}\mu(t)t^k\sum_{i=1}^{\lfloor\frac{n}{dt}\rfloor}\sum_{j=1}^{\lfloor\frac{n}{dt}\rfloor} (i+j)^k\\
= &\sum_{d=1}^n \mu^2(d)d^{k+1}\sum_{t=1}^{\lfloor\frac n d\rfloor}\mu(t)t^kS(\lfloor\frac n {dt}\rfloor)\\
\end{aligned}
$$  
  
现在，只要我们可以快速地求出 $S(n)$ ，我们就可以两次整除分块来解决这个问题。   
  
首先不难发现 $S(n)$ 有一个相似的定义：   
   
$$
S(n)=\sum_{i=1}^{2n} i^k\times \min\{i-1,2n-i+1\}
$$
  
注意到 $S(n)$ 取值只有 $O(\sqrt{n})$ 种，因此我们可以对于它的每一种取值 $m$ ，用 $O(m)$ 的时间算出 $S(n)$ 。于是我们就可以用 $o(n\ln n)$ 的时间求出所有需要的 $S$ 。   
   
然后我们就可以愉快地计算了。   

## 加强版
为了更方便地计算，我们需要继续推式子。下面令 $T=dt$ 。
  
$$
\begin{aligned}
  &\sum_{d=1}^n \mu^2(d)d^{k+1}\sum_{t=1}^{\lfloor\frac n d\rfloor}\mu(t)S(\lfloor\frac n {dt}\rfloor)\\
= &\sum_{T=1}^n S(\lfloor\frac n T\rfloor) \sum_{d|T} \mu^2(d)d^{k+1}\mu(\frac T d)\left(\frac{T}{d}\right)^k\\
= &\sum_{T=1}^n S(\lfloor\frac n T\rfloor) T^k \sum_{d|T} \mu^2(d)\mu(\frac T d)d
\end{aligned}
$$
   
式子已经化到底了。现在，如果我们可以快速地求出来 $f(n)=\sum_{d|n} \mu^2(d)\mu(\frac n d)d$ 和 $S(n)$ ，我们就可以运用整除分块，用 $O(\sqrt n)$ 的时间回答一次查询。   
   
首先考虑 $S$ 。不难发现 $S$ 实际上是一个三角形系数乘上自然数幂的和（类似于前三角加后三角）。     
简单推一推就可以发现，如果令 $g(n)=\sum_{i=1}^n (n-i+1)\times i^{k+1}$ ，那么 $S(n)=g(2n)-2g(n)$  
   
现在我们只需要考虑求 $f(n)$ 了。注意到 $f(n)$ 实际上是 $\mu^2(n)n$ 和 $\mu(n)$ 的狄利克雷卷积，所以**它是积性函数**。   
   
积性函数，我们就可以使用欧拉筛来求值。考虑新加入一个质因子 $p$ ，我们只需要考虑 $f(p^k)$ ：   
1. $f(p^0)=1$
2. $f(p^1)=\mu^2(1)\mu(p)+p\mu^2(p)\mu(1)=p-1$
3. $f(p^2)=\mu^2(1)\mu(p^2)+p\mu^2(p)\mu(p)+p^2\mu^2(p^2)\mu(1)=p$
4. $f(p^k)(k>2)=0$ ，因为无论怎么分， $\mu^2(d)$ 和 $\mu(\frac n d)$ 中都会有一个的幂次大于 2 。   
   
于是我们就可以在欧拉筛中，加上判断幂次的过程，并求得 $f$ 的值。   
   
**注意，本题有那么一点点地卡空间**。      
   
一些有价值的点：   
1. 求出 $f(n)$ 的方法比较通用。 $n$ 比较小的时候，我们通常可以使用**欧拉筛**来计算各处的值。（欧拉筛可以被分为**增加幂次**和**增加新质因子**两个部分，并且进行分类讨论）
   
# 代码
## 简单版：
```cpp
#include <cstdio>

typedef long long LL;

const int mod = 998244353;
const int MAXN = 1e7 + 5;

template<typename _T>
void read( _T &x )
{
	x = 0;char s = getchar();int f = 1;
	while( s > '9' || s < '0' ){if( s == '-' ) f = -1; s = getchar();}
	while( s >= '0' && s <= '9' ){x = ( x << 3 ) + ( x << 1 ) + ( s - '0' ), s = getchar();}
	x *= f;
}

template<typename _T>
void write( _T x )
{
	if( x < 0 ){ putchar( '-' ); x = ( ~ x ) + 1; }
	if( 9 < x ){ write( x / 10 ); }
	putchar( x % 10 + '0' );
}

template<typename _T>
_T MIN( const _T a, const _T b )
{
	return a < b ? a : b;
}

int su1[MAXN], su2[MAXN];
int pw[MAXN], mu[MAXN];
int prime[MAXN], pn;
bool isPrime[MAXN];

int S[MAXN];
int N; LL K;

int Sub( int x, int v ) { return x < v ? x + mod - v : x - v; }
int Mul( LL x, int v ) { x *= v; if( x >= mod ) x %= mod; return x; }
int Add( int x, int v ) { return x + v >= mod ? x + v - mod : x + v; }

int Qkpow( int base, LL indx )
{
	int ret = 1;
	while( indx )
	{
		if( indx & 1 ) ret = Mul( ret, base );
		base = Mul( base, base ), indx >>= 1;
	}
	return ret;
}

void EulerSieve( const int siz )
{
	su1[1] = su2[1] = pw[1] = 1;
	for( int i = 2 ; i <= siz ; i ++ )
	{
		if( ! isPrime[i] ) mu[prime[++ pn] = i] = mod - 1, pw[i] = Qkpow( i, K );
		for( int j = 1 ; j <= pn && 1ll * i * prime[j] <= siz ; j ++ )
		{
			isPrime[i * prime[j]] = true, pw[i * prime[j]] = Mul( pw[i], pw[prime[j]] );
			if( ! ( i % prime[j] ) ) break; mu[i * prime[j]] = mod - mu[i];
		}
		su1[i] = Add( su1[i - 1], Mul( Mul( mu[i], mu[i] ), Mul( pw[i], i ) ) );
		su2[i] = Add( su2[i - 1], Mul( mu[i], pw[i] ) );
	}
}

int GetSum( const int lim )
{
	int ret = 0;
	for( int k = 1 ; k <= 2 * lim ; k ++ )
		ret = Add( ret, Mul( pw[k], MIN( k - 1, 2 * lim - k + 1 ) ) );
	return ret;
}

void Init()
{
	EulerSieve( N << 1 );
	for( int l = 1, r ; l <= N ; l = r + 1 )
	{
		r = N / ( N / l );
		S[N / l] = GetSum( N / l );
	}
}

int f( const int n )
{
	int ret = 0;
	for( int l = 1, r ; l <= n ; l = r + 1 )
	{
		r = n / ( n / l );
		ret = Add( ret, Mul( Sub( su2[r], su2[l - 1] ), S[n / l] ) );
	}
	return ret;
}

int main()
{
	read( N ), read( K ); 
	Init(); int ans = 0;
 	for( int l = 1, r ; l <= N ; l = r + 1 )
	{
		r = N / ( N / l );
		ans = Add( ans, Mul( Sub( su1[r], su1[l - 1] ), f( N / l ) ) );
	}
	write( ans ), putchar( '\n' );
	return 0;
}
```
## 加强版：
```cpp
#include <cstdio>
#include <bitset>
using namespace std;

typedef long long LL;
typedef unsigned int ui;

const int MAXN = 2e7 + 5;

template<typename _T>
void read( _T &x )
{
	x = 0;char s = getchar();int f = 1;
	while( s > '9' || s < '0' ){if( s == '-' ) f = -1; s = getchar();}
	while( s >= '0' && s <= '9' ){x = ( x << 3 ) + ( x << 1 ) + ( s - '0' ), s = getchar();}
	x *= f;
}

template<typename _T>
void write( _T x )
{
	if( x < 0 ){ putchar( '-' ); x = ( ~ x ) + 1; }
	if( 9 < x ){ write( x / 10 ); }
	putchar( x % 10 + '0' );
}

template<typename _T>
_T MIN( const _T a, const _T b )
{
	return a < b ? a : b;
}

ui pw[MAXN], f[MAXN];
int prime[MAXN / 10], pn;
bitset<MAXN> isPrime;

int N; LL K;

ui Qkpow( ui base, int indx )
{
	ui ret = 1;
	while( indx )
	{
		if( indx & 1 ) ret *= base;
		base *= base, indx >>= 1;
	}
	return ret;
}

void EulerSieve( const int siz )
{
	f[1] = pw[1] = 1;
	for( int i = 2 ; i <= siz ; i ++ )
	{
		if( ! isPrime[i] ) pw[prime[++ pn] = i] = Qkpow( i, K ), f[i] = i - 1;
		for( int j = 1 ; j <= pn && 1ll * i * prime[j] <= siz ; j ++ )
		{
			isPrime[i * prime[j]] = true, pw[i * prime[j]] = pw[i] * pw[prime[j]];
			if( ! ( i % prime[j] ) ) 
			{
				int q = i / prime[j];
				if( q % prime[j] ) f[i * prime[j]] = - prime[j] * f[q];
				break; 
			}
			f[i * prime[j]] = f[i] * f[prime[j]];
		}
	}
}

void Init()
{
	EulerSieve( N << 1 );
	for( int i = 1 ; i <= N << 1 ; i ++ ) 
		f[i] = f[i - 1] + pw[i] * f[i], pw[i] = pw[i - 1] + pw[i];
	for( int i = 1 ; i <= N << 1 ; i ++ ) pw[i] = pw[i - 1] + pw[i];
}

int S( const int n ) { return pw[n << 1] - ( pw[n] << 1 ); }

int main()
{
	int T, n;
	read( T ), read( N ), read( K );
	Init();
	while( T -- )
	{
		read( n ); ui ans = 0;
		for( int l = 1, r ; l <= n ; l = r + 1 )
		{
			r = n / ( n / l );
			ans += ( f[r] - f[l - 1] ) * S( n / l );
		}
		write( ans ), putchar( '\n' );
	}
	return 0;
}
```

---

## 作者：diandian2020 (赞：0)

我的[博客](https://www.luogu.com.cn/blog/diandian2020/)里面有详细的莫反知识和题目的讲解

开始给定 $k$（即对所有询问 $k$ 是一样的），求 $\sum_{i=1}^n\sum_{j=1}^n(i+j)^k\gcd(i,j)f(\gcd(i,j)) \bmod 2^{32}$。其中，$f(k)=0$ 若 $k$ 有平方因子，否则 $f(k)=1$。

$T=10000$，$1 \leq n \leq 10^7$，$1 \leq k < 2^{31}$。

题是神仙题，但是相对来说，推式子的部分总还是很简单的。

首先是一个结论：$f(k)=\mu^2(k)$（根据定义就能证明）。所以答案就是 $\sum_{i=1}^n\sum_{j=1}^n(i+j)^k\gcd(i,j)\mu^2(\gcd(i,j))$。

下面正式推式子：

带入上面结论并枚举 $\gcd$：$\sum_d\mu^2(d)d\sum_{i=1}^n\sum_{j=1}^n(i+j)^k[\gcd(i,j)=d]$。

将枚举 $\gcd(i,j)=d$ 变成 $\gcd(\frac{i}{d},\frac{j}{d})=1$：$\sum_d\mu^2(d)d\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{n}{d}\rfloor}(id+jd)^k\sum_{t|i,t|j}\mu(t)$。

$=\sum_d\mu^2(d)d^{k+1}\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{n}{d}\rfloor}(i+j)^k\sum_{t|i,t|j}\mu(t)$。

把枚举 $i,j$ 的因数 $t$ 变成枚举 $t$ 的倍数 $i,j$（枚举的时候枚举 $i,j$ 是 $t$ 的多少倍，而并不应该枚举 $i,j$ 本身）：

$=\sum_d\mu^2(d)d^{k+1}\sum_t\mu(t)\sum_{i=1}^{\lfloor\frac{n}{dt}\rfloor}\sum_{j=1}^{\lfloor\frac{n}{dt}\rfloor}(it+jt)^k$。

$=\sum_d\mu^2(d)d^{k+1}\sum_t\mu(t)t^k\sum_{i=1}^{\lfloor\frac{n}{dt}\rfloor}\sum_{j=1}^{\lfloor\frac{n}{dt}\rfloor}(i+j)^k$。

令 $S(n)=\sum_{i=1}^n\sum_{j=1}^n(i+j)^k$，则：

$=\sum_d\mu^2(d)d^{k+1}\sum_t\mu(t)t^kS(\lfloor\frac{n}{dt}\rfloor)$。

该来的总是来了，令 $T=dt$：

$=\sum_TS(\lfloor\frac{n}{T}\rfloor)\sum_{d|T}\mu^2(d)d^{k+1}\mu(\frac{T}{d})(\frac{T}{d})^k$。

$=\sum_TS(\lfloor\frac{n}{T}\rfloor)T^k\sum_{d|T}d\mu^2(d)\mu(\frac{T}{d})$。

愉快的推式子部分就结束了，下面恶心的地方正式开始：如何求 $S$ 和 $n^k\sum_{d|n}d\mu^2(d)\mu(\frac{T}{d})$？

~~这两个东东我做的时候都没想出来，所以就看看题解，感受一下出题人的伟大吧！~~

先看 $S$ 吧。

令 $F(n)=\sum_{i=1}^ni^k,G(n)=\sum_{i=1}^nF(i)$，则有结论 $S(n)=\sum_{i=n+1}^{2n}F(i)-\sum_{i=1}^nF(i)=G(2n)-2G(n)$。（归纳可以证明）

只要线性筛下正整数的 $k$ 次方，然后前缀和一下就能求 $F$，再前缀和一下就能求 $G$，$S$ 也就迎刃而解了。

接下来是 $n^k\sum_{d|n}d\mu^2(d)\mu(\frac{T}{d})$，$n^k$ 平凡，所以我们只看$f(n)=\sum_{d|n}d\mu^2(d)\mu(\frac{T}{d})$。

因为 $f=ID\mu^2 * \mu$ 是积性函数的狄利克雷卷积，所以其也是积性函数，考虑线性筛其。

只要看 $f(p^c)$（$p$ 为质数，$c$ 为正整数），下面对 $c$ 分讨：

$c=1$：$f(p)=\mu(p)+p\mu^2(p)=-1+p\times1=p-1$。

$c=2$：$f(p^2)=\mu(p^2)+p\mu^2(p)\mu(p)+p^2\mu^2(p^2)=1+p\times1\times(-1)+p^2\times0=-p$。

$c>2$：对于所有 $p^k(k \leq c)$，$\mu(p^k)$ 和 $\mu(p^{c-k})$ 总有一个是零，所以此时 $f(p^c)=0$。

搞定，看代码（这里就加强版的了）：

P.S. 注意加强版的出题人为了卡暴力增大了数据范围，所以请不要挥霍时间和空间。
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
typedef unsigned int UI;
const int N=2e7+9;
UI qmi(UI a,UI b){
	UI res=1;
	while(b){
		if(b&1) res*=a;
		a*=a;
		b>>=1;
	}
	return res;
}
int T,n,k;
int primes[N],cnt; bool st[N];
UI f[N],G[N];
void init(int n){
	f[1]=G[1]=1;
	for(int i=2;i<=n;i++){
		if(!st[i]) primes[++cnt]=i,G[i]=qmi(i,k),f[i]=i-1;
		for(int j=1;primes[j]<=n/i;j++){
			int t=primes[j]*i;
			st[t]=1;
			G[t]=G[i]*G[primes[j]];
			if(i%primes[j]==0){
				int q=i/primes[j];
				if(q%primes[j]) f[t]=f[q]*(-primes[j]);
				else f[t]=0;
				break;
			}
			f[t]=f[i]*(primes[j]-1);
		}
	}
	for(int i=1;i<=n;i++) f[i]=f[i-1]+f[i]*G[i];
	for(int i=1;i<=n;i++) G[i]=G[i-1]+G[i];
	for(int i=1;i<=n;i++) G[i]=G[i-1]+G[i];
}
UI S(int n){
	return G[2*n]-2*G[n]; 
}
int main(){
	scanf("%d%d%d",&T,&n,&k);
	init(2*n);
	while(T--){
		scanf("%d",&n);
		UI res=0;
		for(int l=1,r;l<=n;l=r+1){
			r=n/(n/l);
			res+=S(n/l)*(f[r]-f[l-1]);
		}
		printf("%u\n",res);
	}
	return 0;
} 
```

---

## 作者：Phartial (赞：0)

## 题意

求

$$
\sum_{i=1}^n\sum_{j=1}^n(i+j)^k\mu^2(\gcd(i,j))\gcd(i,j)
$$

对 $998244353$ 取模的值。

## 思路

$$
\begin{aligned}
  &\sum_{i=1}^n\sum_{j=1}^n(i+j)^k\mu^2(\gcd(i,j))\gcd(i,j)\\
  =&\sum_{d=1}^n\sum_{i=1}^n\sum_{j=1}^n(i+j)^k\mu^2(d)d[\gcd(i,j)=d]\\
  =&\sum_{d=1}^n\mu^2(d)d\sum_{i=1}^n\sum_{j=1}^n(i+j)^k[\gcd(i,j)=d]\\
  =&\sum_{d=1}^n\mu^2(d)d\sum_{i=1}^{\lfloor n/d\rfloor}\sum_{j=1}^{\lfloor n/d\rfloor}(di+dj)^k[\gcd(i,j)=1]\\
  =&\sum_{d=1}^n\mu^2(d)d^{k+1}\sum_{i=1}^{\lfloor n/d\rfloor}\sum_{j=1}^{\lfloor n/d\rfloor}(i+j)^k\sum_{p\mid i,p\mid j}\mu(p)\\
  =&\sum_{d=1}^n\mu^2(d)d^{k+1}\sum_{p=1}^{\lfloor n/d\rfloor}\mu(p)p^k\sum_{i=1}^{\lfloor n/dp\rfloor}\sum_{j=1}^{\lfloor n/dp\rfloor}(i+j)^k\\
\end{aligned}
$$

设 $f$ 为 $\operatorname{id}^k$ 的前缀和，$g$ 为 $f$ 的前缀和，$S(n)=\displaystyle\sum_{i=1}^n\sum_{j=1}^n(i+j)^k$，有

$$
\begin{aligned}
  S(n)
  &=\sum_{i=1}^nf(n+i)-f(i)\\
  &=g(2n)-g(n)-g(n)\\
  &=g(2n)-2g(n)\\
\end{aligned}
$$

于是有

$$
\begin{aligned}
  &\sum_{d=1}^n\mu^2(d)d^{k+1}\sum_{p=1}^{\lfloor n/d\rfloor}\mu(p)p^k\sum_{i=1}^{\lfloor n/dp\rfloor}\sum_{j=1}^{\lfloor n/dp\rfloor}(i+j)^k\\
  =&\sum_{d=1}^n\mu^2(d)d^{k+1}\sum_{p=1}^{\lfloor n/d\rfloor}\mu(p)p^kS(\lfloor n/dp\rfloor)\\
\end{aligned}
$$

设 $t=dp$，有

$$
\begin{aligned}
  &\sum_{d=1}^n\mu^2(d)d^{k+1}\sum_{p=1}^{\lfloor n/d\rfloor}\mu(p)p^kS(\lfloor n/t\rfloor)\\
  =&\sum_{t=1}^nS(\lfloor n/t\rfloor)\sum_{d\mid t}\mu^2(d)d^{k+1}\mu(t/d)(t/d)^k\\
  =&\sum_{t=1}^nS(\lfloor n/t\rfloor)t^k\sum_{d\mid t}d\mu^2(d)\mu(t/d)\\
\end{aligned}
$$

设 $h(n)=\displaystyle\sum_{d\mid n}d\mu^2(d)\mu(n/d)$，由于它是若干个积性函数卷起来，所以也是积性函数，因此我们分类讨论 $h(p^k)$ 即可。

1. $k=1$：此时，$h(p)=\mu(p)+p\mu^2(p)=p-1$。
2. $k=2$：此时，$h(p^2)=\mu(p^2)+p\mu^2(p)\mu(p)+p^2\mu^2(p^2)=-p$。
3. $k>2$：此时，对于 $h(p^k)$ 中的任意一项 $p^i\mu^2(p^i)\mu(p^{k-i})$，都有 $i\ge 2$ 或 $k-i\ge 2$，故 $f(p^k)=0$。

这时，我们就能用线性筛预处理 $h$ 和 $\operatorname{id}^k$。然后数论分块即可。

```cpp
#include <iostream>
#include <vector>
#include <bitset>

using namespace std;
using LL = unsigned int;

const int kN = 1e7 + 1;

int t, n;
LL k, id[kN * 2], h[kN];
bitset<kN * 2> v;
vector<int> p;

LL P(LL b, LL e) {
  LL s = 1;
  for (; e; e >>= 1, b = b * b) {
    (e & 1) && (s = s * b);
  }
  return s;
}
LL S(int n) { return id[n + n] - 2 * id[n]; }

int main() {
  ios_base::sync_with_stdio(0), cin.tie(0);
  cin >> t >> n >> k;
  id[1] = h[1] = 1;
  for (int i = 2; i <= n; ++i) {
    if (!v[i]) {
      p.push_back(i), id[i] = P(i, k), h[i] = i - 1;
    }
    for (int j : p) {
      int k = i * j;
      if (k > n) {
        break;
      }
      v[k] = 1, id[k] = id[i] * id[j];
      if (i % j) {
        h[k] = h[i] * h[j];
      } else {
        int _i = i / j;
        if (_i % j) {
          h[k] = -j * h[_i];
        }
        break;
      }
    }
  }
  for (int i = n + 1; i <= n + n; ++i) {
    if (!v[i]) {
      p.push_back(i), id[i] = P(i, k);
    }
    for (int j : p) {
      int k = i * j;
      if (k > n) {
        break;
      }
      v[k] = 1, id[k] = id[i] * id[j];
      if (i % j == 0) {
        break;
      }
    }
  }
  for (int i = 2; i <= n; ++i) {
    h[i] = h[i - 1] + h[i] * id[i];
  }
  for (int i = 2; i <= n + n; ++i) {
    id[i] += id[i - 1];
  }
  for (int i = 2; i <= n + n; ++i) {
    id[i] += id[i - 1];
  }
  for (; t--;) {
    cin >> n;
    LL s = 0;
    for (int l = 1, r; l <= n; l = r + 1) {
      r = n / (n / l);
      s += S(n / l) * (h[r] - h[l - 1]);
    }
    cout << s << '\n';
  }
  return 0;
}
```



---

## 作者：aleph_blanc (赞：0)

比起加强版，原题面的式子要更绕一些，毕竟这个直接给了你 $\mu$。


我们一如往常的推式子。

$$
\large\sum_{i=1}^n\sum_{j=1}^n(i+j)^k\text{gcd}(i,j)\mu^2(\text{gcd}(i,j))
$$

先处理一下 $\text{gcd}$。

$$
\large\sum_{d=1}^n\sum_{i=1}^n\sum_{j=1}^n[\text{gcd}(i,j)=d](i+j)^kd\mu^2(d)
$$

顺便还能把 $d$ 提出来。

$$
\large{
\begin{aligned}
&\sum_{d=1}^nd\mu^2(d)\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{n}{d}\rfloor}(id+jd)^k[\text{gcd}(i,j)=1]\\
&\sum_{d=1}^nd^{k+1}\mu^2(d)\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{n}{d}\rfloor}(i+j)^k[\text{gcd}(i,j)=1]
\end{aligned}
}
$$

式子太长，中间那一坨很明显可以简写一下，可以方便之后代码的处理。

$$
\large F(n)=\sum_{i=1}^n\sum_{j=1}^n(i+j)^k
$$

我们继续推，接下来按套路来就好。

$$
\large{
\begin{aligned}
&\sum_{d=1}^nd^{k+1}\mu^2(d)F(\lfloor\frac{n}{d}\rfloor)[\text{gcd}(i,j)=1]\\
&\sum_{d=1}^nd^{k+1}\mu^2(d)F(\lfloor\frac{n}{d}\rfloor)\sum_{p\mid i,p\mid j}\mu(p)
\end{aligned}
}
$$

从枚举 $d$ 中得到启发，枚举 $p$（这是废话）。在枚举时，原来的 $i$ 和 $j$ 一样会被提出个 $p^k$。

$$
\large \sum_{d=1}^nd^{k+1}\mu^2(d)\sum_{p=1}^{\lfloor\frac{n}{d}\rfloor}\mu(p)p^kF(\frac{n}{dp})
$$

套路地设 $T=dp$。

$$
\large {
\begin{aligned}
&\sum_{T=1}^n\sum_{d\mid T}d^{k+1}\mu^2(d)\mu(\frac{T}{d})(\frac{T}{d})^kF(\frac{n}{T})\\
&\sum_{T=1}^n\sum_{d\mid T}d\mu^2(d)\mu(\frac{T}{d})(\frac{T}{d})^kd^kF(\frac{n}{T})\\
&\sum_{T=1}^nT^kF(\frac{n}{T})\sum_{d\mid T}d\mu^2(d)\mu(\frac{T}{d})
\end{aligned}
}
$$

后面一坨全是积性函数的狄利克雷卷积式的组合,撮合到一起也是个积性函数，那么我们设 ：

$$
\large G(n)=\sum_{d\mid n}d\mu^2(d)\mu(\frac{n}{d})
$$

就有：

$$
\large\sum_{T=1}^nT^kF(\frac{n}{T})G(T)
$$


---

接下来的难点就在于处理那两个函数了。

我们设 $t[i]$ 为一个数 $i$ 在函数 $F$ 中产生贡献的次数，则有：

$$
\large F(n)=\sum_{i=1}^n\sum_{j=1}^n(i+j)^k=\sum_{i=2}^{2n}t[i]i^k
$$

不难发现，$t[i]$ 的值是有规律的，你可以画个表格模拟这两个 $\sum$。

发现 $t[i]=\text{min}(i-1,2n-i+1)$。

如果设 $V(n)=\sum_{i=1}^n(n-i+1)i^k$，

那么 $F(n)=V(2n)-2V(n)$。

递推处理即可。

对于函数 $G$，已知它是积性函数，那我们先考虑 $G(p^c)$ 的简单情况，其中 $p$ 是一个素数。

我们结合莫比乌斯函数的定义式并稍加运算，得出：

>$c=1$，$G(p)=p-1$。
>
>$c=2$，$\mu$ 函数出现了 $0$，故产生贡献时， $d\mid p$，此时 $G(p^2)=-p$。
>
>$c=3$，$\mu(d)$ 和 $\mu(\frac{T}{d})$ 同时存在，一定有一个值为 $0$，所以此时 $G(p^c)=0$。
>
>$c=0$ 不用说。。。

---

$\text{CODE}$ 

```cpp
#include <bits/stdc++.h>

#define N 20000010
#define ll unsigned int
// 内存给得太小，小心点用~ 模数自然溢出就行

using namespace std;

template <typename T>
inline void read (T &a) {
	T x = 0, f = 1;
	char ch = getchar ();
	while (! isdigit (ch)) {
		(ch == '-') and (f = 0);
		ch = getchar ();
	}
	while (isdigit (ch)) {
		x = (x << 1) + (x << 3) + (ch ^ '0');
		ch = getchar ();
	}
	a = f ? x : -x;
}
template <typename T, typename ...A>
inline void read (T &t, A &...a) {
	read (t), read (a...);
}
template <typename T>
inline void print (T x) {
	if (x < 0) putchar ('-'), x = -x;
	if (x > 9) print (x / 10);
	putchar (x % 10 + '0');
}

inline ll qpow (ll a, ll b) {
	ll ret = 1;
	while (b) {
		(b & 1) and (ret = ret * a);
		a = a * a;
		b >>= 1;
	}
	return ret;
}

int pri[N], cnt, k;
ll ans, f[N], g[N]; // 对应上文函数
bool is[N];
inline void phigros (int n) { //线筛
	f[1] = g[1] = 1;
	for (int i = 2; i <= n; i++) {
		(! is[i]) and (g[i] = i - 1, f[i] = qpow (i, k), pri[++cnt] = i); 
        // g[i] 正常赋值，猜猜这里的 f 是啥QWQ。
		for (int j = 1; j <= cnt and i * pri[j] <= n; j++) {
			is[i * pri[j]] = 1;
			f[i * pri[j]] = f[i] * f[pri[j]];
			if (i % pri[j] == 0) { // 这里是之前 g 的部分情况
				int res = i / pri[j];
				if (res % pri[j]) g[i * pri[j]] = g[res] * (-pri[j]);
				break;
			}
			g[i * pri[j]] = g[i] * g[pri[j]];
		}
	}
	for (int i = 2; i <= n; i++) {
		g[i] = g[i - 1] + g[i] * f[i];
		f[i] += f[i - 1];
	}
	for (int i = 2; i <= n; i++) {
		f[i] += f[i - 1];
	} // 如前文所述
}

int t, n;

signed main () {
	read (t, n, k);
	phigros (n << 1);
	while (t--) {
		read (n);
		ans = 0;
		for (int l = 1, r; l <= n; l = r + 1) {
			r = n / (n / l);
			ans += (g[r] - g[l - 1]) * (f[(n / l) << 1] - (f[n / l] << 1));
		}
		print (ans);
		printf ("\n");
	}
}
```




---

## 作者：tzc_wk (赞：0)

按照套路颓式子：

$$
\begin{aligned}
ans&=\sum\limits_{d=1}^n\sum\limits_{i=1}^n\sum\limits_{j=1}^n(i+j)^kd\mu^2(d)[\gcd(i,j)=d]\\
&=\sum\limits_{d=1}^n\sum\limits_{i=1}^{n/d}\sum\limits_{j=1}^{n/d}(i+j)^kd^{k+1}\mu^2(d)[i\perp j]\\
&=\sum\limits_{d=1}^n\sum\limits_{t=1}^{n/d}\mu(t)\mu^2(d)d^{k+1}\sum\limits_{t\mid i}\sum\limits_{t\mid j}(i+j)^k\\
&=\sum\limits_{d=1}^n\sum\limits_{t=1}^{n/d}\mu(t)\mu^2(d)d^{k+1}t^k\sum\limits_{i=1}^{n/td}\sum\limits_{j=1}^{n/td}(i+j)^k
\end{aligned}
$$

不难发现后两个 $\sum$ 中的内容可以写为关于 $\lfloor\dfrac{n}{td}\rfloor$ 的函数 $f(\lfloor\dfrac{n}{td}\rfloor)$，那么我们可以把它预处理出来（具体预处理方法就是观察每个 $i+j$ 被累加入贡献了多少次，然后维护 $\text{id}_k$ 的前缀和转移），那么式子可以化为

$$
ans=\sum\limits_{d=1}^n\sum\limits_{t=1}^{n/d}\mu(t)\mu^2(d)d^{k+1}t^kf(\lfloor\dfrac{n}{td}\rfloor)
$$
老套路，枚举 $T=td$，那么

$$
ans=\sum\limits_{T=1}^nf(\lfloor\dfrac{n}{T}\rfloor)g(T)
$$

其中 $g(T)=\sum\limits_{td=T}\mu(t)t^k\mu^2(d)d^{k+1}$，显然 $g=(\mu·\text{id}_k)*(\mu^2·\text{id}_{k+1})$ 是积性函数，可以线筛。

这题好卡空间……卡空间的方法就是不要预处理 $\mu$ 直接处理 $g$，不难发现如果 $x$ 存在一个质因子次数 $\ge 3$ 那么 $g(x)=0$，对于 $x$ 中某个次数为 $2$ 的质因子 $p$，贡献为 $-p^{2k+1}$，对于某个次数为 $1$ 的质因子 $p$，贡献为 $p^{k+1}-p^k$，那么在我们线筛过程中，如果 $i\bmod p_j\ne 0$，那么 $i\times p_j$ 中 $p_j$ 的次数显然为 $1$，否则我们可以根据 $\dfrac{i}{p_j}\bmod p_j$ 是否为 $0$ 来判断 $i\times p_j$ 中 $p_j$ 的次数是否 $\ge 3$。还有就是标记数组开成 `bitset`，质数数组缩小 $10$（$\ln n$）倍等。

```cpp
const int MAXV=2e7;
u32 qpow(u32 x,int e){
	u32 ret=1;
	for(;e;e>>=1,x=x*x) if(e&1) ret=ret*x;
	return ret;
}
int k,N,pr[MAXV/10+5],prcnt=0;
bitset<MAXV+5> vis;
u32 f[MAXV+5],pwk[MAXV+5],sm[MAXV+5];
void sieve(int n){
	f[1]=1;
	for(int i=2;i<=n;i++){
		if(!vis[i]) pwk[i]=qpow(i,k),f[i]=pwk[i]*i-pwk[i],pr[++prcnt]=i;
		for(int j=1;j<=prcnt&&pr[j]*i<=n;j++){
			vis.set(pr[j]*i);pwk[i*pr[j]]=pwk[i]*pwk[pr[j]];
			if(i%pr[j]==0){
				int dv=i/pr[j];
				if(dv%pr[j]!=0) f[i*pr[j]]=-f[dv]*pwk[pr[j]]*pwk[pr[j]]*pr[j];
				break;
			} f[i*pr[j]]=f[i]*f[pr[j]];
		}
	}
	for(int i=1;i<=n;i++) pwk[i]+=pwk[i-1],f[i]+=f[i-1];
	for(int i=1;i<=n;i++) sm[i]=sm[i-1]+(pwk[i<<1]-pwk[i]<<1)-pwk[i<<1]+pwk[i-1<<1|1];
}
int main(){
	int qu;scanf("%d%d%d",&qu,&N,&k);sieve(N<<1);
	while(qu--){
		int n;scanf("%d",&n);u32 res=0;
		for(int l=1,r;l<=n;l=r+1){
			r=n/(n/l);res+=(f[r]-f[l-1])*sm[n/l];
		} printf("%u\n",res);
	}
	return 0;
}
```

---


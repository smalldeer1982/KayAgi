# [湖北省队互测2014] 一个人的数论

## 题目背景

题目来源：$2014$ 年湖北省队互测Week1

资源来源：[链接](https://tieba.baidu.com/p/3050650090?red_tag=3002680446)

## 题目描述

有一天 hjy96 想到了一个数论问题:

对于一个非负整数 $d$ 和一个正整数 $n$，定义 $f_d(n)$ 为所有小于 $n$ 且与 $n$ 互质的正整数的 $d$ 次方之和。如 $f_3(10) = 1^3 +3^3 +7^3 +9^3$。

现给定 $d, n$，求 $f_d(n)$ 的值。输出答案对 $10^9 + 7$ 取模后的结果。 

hjy96 当然知道怎么做啦! 但是他想考考你......

## 说明/提示

#### 数据规模与约定

各测试点信息如下表

| 编号 | $d$ | 特殊限制 |
| :---: | :---: | :---------: |
| 1 | $\leq 100$ | $n \leq 10^5$ |
| 2 | $=0$ | 无 |
| 3 | $=1$ | 无 |
| 4 | $=2$ | 无 |
| 5 | $\leq 100$ | $w = 1$，$ \alpha_1 = 1$ |
| 6 | $\leq 100$ | $w = 1$，$ \alpha_1 = 1$ |
| 7 | $\leq 100$ | $ \prod_{i = 1}^w (\alpha_i + 1) \leq 10^5$ |
| 8 | $\leq 100$ | $w \leq 16$ |
| 9 | $\leq 100$ | 无 |
| 10 | $\leq 100$ | 无 |

对于全部的测试点，保证 $1 \leq w \leq 10^3$，$2 \leq p_i \leq 10^9$，$1 \leq \alpha_i \leq 10^9$。

## 样例 #1

### 输入

```
3 2 
2 1 
5 1```

### 输出

```
1100```

# 题解

## 作者：CYJian (赞：46)

一道经典的莫比乌斯反演练习题。

---

这里规定一下变量名：

题目中的 $d \rightarrow k$。

题目中的 $w \rightarrow n$。

题目中的 $n \rightarrow N$。

---

考虑构造：

$$ F(n)=\sum_{i=1}^{n} i^k $$

$$ G(n)=\sum_{i=1}^{n} i^k[\gcd(i, n)=1] $$

则我们最后想要的答案为 $G(N)$。

不难发现有：

$$ F(n)=\sum_{d|n} d^k G\left(\frac{n}{d}\right) $$

那么我们考虑对其做莫比乌斯反演，则有：

$$ G(n)=\sum_{d|n} \mu(d)d^k F\left(\frac{n}{d}\right) $$

注意到 $F(n)$ 事实上是关于 $n$ 的 $k+1$ 次多项式，所以可以将其表示为 $F(n)=\sum_{i=0}^{k+1}f_i n^i$ 的形式。

那么对上面的式子展开即得：

$$ G(n)=\sum_{d|n} \mu(d)d^k \sum_{i=0}^{k+1} f_i\left(\frac{n}{d}\right)^i $$

$$ G(n)= \sum_{i=0}^{k+1} f_i n^i \sum_{d|n} \mu(d)d^{k-i} $$

若 $n$ 能够分解为 $\prod p_i^{a_i}$ 的形式，由于 $\mu(d)d^{k-i}$ 必然是一个积性函数，所以后面的一个 $\sum$ 可以写成：

$$ G(n)= \sum_{i=0}^{k+1} f_i n^i \prod_{p_j|n} \sum_{t=0}^{a_j}\mu(p_j^t)p_j^{t(k-i)} $$

注意到 $\mu$ 在质数幂次上次取值有：

$$
\mu(p^k)=
\begin{cases}
1 \qquad & k=0\\
-1 \qquad & k=1\\
0 \qquad & k>1
\end{cases}
$$

所以最后一个 $\sum$ 中的 $t$ 至多枚举到 $1$。即原式可化为：

$$ G(n)= \sum_{i=0}^{k+1} f_i n^i \prod_{p_j|n} \left(1-p_j^{k-i}\right) $$

而我们想要的就是 $G(N)$，而 $N$ 也是以其质因数分解的形式给出，则剩下的问题是插值出我们要的自然数幂和的多项式。

这个东西的一般暴力方法可以用拉格朗日插值做到 $O(n^3)$ 或者 $O(n^2)$。主要原理就是这个式子：

对于一个 $k$ 次多项式，在给定其 $k+1$ 个点值 $(x_i,y_i=F(x_i))$ 的情况下，我们可以插出其多项式为：

$$ F(x)=\sum_{i=1}^{k+1} y_i \prod_{j \ne i} \frac{x-x_j}{x_i-x_j}$$

然后纯粹模拟多项式乘法和多项式加法，就可以做到 $O(k^3)$。但是如果我们预处理出 $\prod_{i=1}^{k+1}(x-x_j)$ 这个多项式，每次加的时候先除掉一个单项式再乘常数，最后做加法，这样就可以做到 $O(k^2)$ 插出这个多项式。由于此题中 $k \leq 100$，所以使用最暴力朴素的算法即可。

至此，整个问题就可以在 $O(k^3+kn)$ 或者 $O(k^2+kn)$ 的时间复杂度内解决。

部分代码如下：

```cpp
const int mod = 1e9 + 7;

inline int Mod(int x) { return x >= mod ? x - mod : x; }
inline void Add(int &x, int y) { x += y, x -= x >= mod ? mod : 0; }
inline int fsp(int x, int k = mod - 2) {
	int s = 1;
	while(k) {
		if(k & 1) s = 1LL * s * x % mod;
		x = 1LL * x * x % mod, k >>= 1;
	} return s;
}

int f[110];
int p[1010];

// {{{ Lagrange
int A[110];
int len;

inline void Poly_Mul(int a, int b) {
	++len;
	for(int i = len; i >= 1; i--)
		A[i] = (1LL * A[i] * b + 1LL * A[i - 1] * a) % mod;
	A[0] = 1LL * A[0] * b % mod;
}

inline void Num_Mul(int v) {
	for(int i = 0; i <= len; i++)
		A[i] = 1LL * A[i] * v % mod;
}

inline void Poly_Add() {
	for(int i = 0; i <= len; i++)
		Add(f[i], A[i]), A[i] = 0;
	len = 0, A[0] = 1;
}

inline void init(int k) {
	A[0] = 1, len = 0;
	int S = 0;
	for(int i = 1; i <= k + 3; i++) {
		Add(S, fsp(i, k));
		int mul = fsp(S);
		for(int j = 1; j <= k + 3; j++) {
			if(i == j) continue;
			Poly_Mul(1, mod - j);
			mul = 1LL * mul * (i + mod - j) % mod;
		} Num_Mul(fsp(mul)), Poly_Add();
	}
}
// }}}

int main() {
	int k = ri, n = ri, N = 1;
	for(int i = 1; i <= n; i++) p[i] = ri, N = 1LL * N * fsp(p[i], ri) % mod;

	init(k);

	int res = 0, pw = N;
	for(int i = 1; i <= k + 3; i++) {
		int ans = 1LL * pw * f[i] % mod;
		pw = 1LL * pw * N % mod;
		for(int j = 1; j <= n; j++)
			ans = 1LL * ans * (1 + mod - fsp(p[j], k - i + mod - 1)) % mod;
		Add(res, ans);
	} cout << res << endl;
	return 0;
}
```

---

## 作者：皎月半洒花 (赞：18)

upd: typo了一个地方，感谢NaCly_Fish的指正。
____

首先写出式子来

![](https://cdn.luogu.com.cn/upload/image_hosting/6577i0r6.png)

然后发现这东西好像不是容易提前预处理。根据伯努利数的推论，可以知道 $\sum i^m$ 这东西是一个关于上界 $n$ 的 $m+1$ 次多项式。发现 $m$ 并不大于是可以 $O(m^2)$ 插出来。 若记这个多项式是 $f$ ，那么原式就等价于

$$\sum_{d|n}d^m\mu(d)\sum_{i=1}^{m+1} f_i\left(\lfloor\frac{n}{d}\rfloor\right) ^ i$$

稍微化一下就是

$$=\sum_{i=0}^{m+1} f_{i} \sum_{d | n} d^{m} \mu(d)\left(\frac{n}{d}\right)^{i}$$

发现对于后面的 $\sum $ 只需要求出每个 $p_i^{a_i}$ 处的值，然后每次 $O(k)$ 暴力合并，似乎也没啥问题。考虑对于每个 $p_i^{a_{i}}$ 怎么求。

这个地方大概需要涨个经验，就是要考虑 $\mu(d)$ 这东西的容斥意义，只有当 $d=1$ 和 $d=p_i$ 的时候才有值(无平方因子,剩下的因子都是 $p_i$ 的某个次数 $>2$ 的幂)，所以每个只需要算两次，是 $O(1)$ 的。于是最后的复杂度 $O(m(m+k))$ 。

并且……这个题居然允许用高斯消元来代替插值。毕竟 $m$ 只有 $100$ 。

```cpp
#include <bits/stdc++.h>

using namespace std ;

typedef long long ll ; 

const int N = 1000010 ; 
const int P = 1000000007 ;

int n, k ; 

void debug(int *tp, int minn, int maxn, char c){
    for (int i = minn ; i <= maxn ; ++ i)
        cout << tp[i] << " " ;  cout << c ;
}

namespace Interpolation{
	int ans ; 
	int now ; 
	int x[N] ;
	int y[N] ;
	int fac[N] ; 
	int inv[N] ; 
	int pres[N] ; 
	int sufs[N] ; 
	int expow(int a, int b){
		int res = 1 ;
		a = (a % P + P) % P ;
		while (b){
			if (b & 1)
				res = (ll)res * a % P ; 
			a = (ll)a * a % P ; b >>= 1 ; 
		}
		return res ;
	}
	int fz[N] ;
	int fm[N] ; 
	int tmp[N] ;
	int res[N] ;
	void add(int &a, int b){
		a += b ;
		if (a > P) a -= P ; 
	}
	void dec(int &a, int b){
		(a -= b) %= P ;
		if (a < 0) a += P ; 
	}
	void fmul(int *t, int deg, int opt){
		for (int i = deg + 1 ; i >= 1 ; -- i)
			tmp[i] = t[i], t[i] = t[i - 1] ;
		for (int i = 1 ; i <= deg + 1 ; ++ i)
			add(t[i], (ll)opt * tmp[i] % P) ;   
	}
	void fdiv(int *t, int *ret, int deg, int opt){
		for (int i = 1 ; i <= deg ; ++ i) tmp[i] = t[i] ; 
		for (int i = deg - 1 ; i >= 1 ; -- i)
			ret[i] = tmp[i + 1], dec(tmp[i], (ll)tmp[i + 1] * opt % P) ;
	}
	void get_xs(int n){
		fz[1] = 1 ;
		for (int i = 1 ; i <= n ; ++ i)
			fmul(fz, i, (-x[i] + P) % P) ;
		//debug(fz, 1, n + 1, '\n') ;
		for (int i = 1 ; i <= n ; ++ i){
			int fenmu = 1 ; 
			for (int j = 1 ; j <= n ; ++ j)
				if (i != j) fenmu = (ll)fenmu * (x[i] - x[j] + P) % P ;
			fdiv(fz, fm, n + 1, -x[i]) ; 
			fenmu = (ll)y[i] * expow(fenmu, P - 2) % P ;
		//	cout << fenmu << endl ; 
			for (int j = 1 ; j <= n ; ++ j)
				add(res[j], (ll)fenmu * fm[j] % P) ;
		//	debug(res, 1, n, '\n') ;
		}
	}
	void pre_do(int U){
		fac[0] = 1 ;
		for (int i = 1 ; i <= U ; ++ i)
			fac[i] = (ll)fac[i - 1] * i % P ;
		inv[U] = expow(fac[U], P - 2) ; 
		for (int i = U ; i >= 1 ; -- i)
			inv[i - 1] = (ll)inv[i] * i % P ;
		//debug(fac, 1, U, '\n') ;
		//debug(inv, 1, U, '\n') ;
	}
	int evenmark(int x){
		return (x & 1) ? -1 : 1 ; 
	}
	void get_dnx(int n, int k, bool m){
		if (m){
			pre_do(n) ;
			pres[0] = 1, sufs[n + 1] = 1 ;
			for (int i = 1 ; i <= n ; ++ i)
				pres[i] = ((ll)pres[i - 1] * (k - x[i]) % P + P) % P ;
			for (int i = n ; i >= 1 ; -- i)
				sufs[i] = ((ll)sufs[i + 1] * (k - x[i]) % P + P) % P ; 
			for (int i = 1 ; i <= n ; ++ i){
				now = (ll)pres[i - 1] * sufs[i + 1] % P ;
				now = (ll)now * expow((ll)fac[i - 1] * fac[n - i] % P, P - 2) % P ;
				now = (ll)evenmark(n - i) * y[i] % P * now % P ; ans = (ll)(ans + now) % P ; 
			}
		}
		else {
			int inow = 1 ;
			pres[0] = 1, sufs[n + 1] = 1 ;
			for (int i = 1 ; i <= n ; ++ i)
				pres[i] = ((ll)pres[i - 1] * (k - x[i]) % P + P) % P ;
			for (int i = n ; i >= 1 ; -- i)
				sufs[i] = ((ll)sufs[i + 1] * (k - x[i]) % P + P) % P ; 
			for (int i = 1 ; i <= n ; ++ i){
				inow = 1, now = (ll)pres[i - 1] * sufs[i + 1] % P ;
				for (int j = 1 ; j <= n ; ++ j)
					if (i != j) inow = (ll)inow * ((x[i] - x[j]) % P + P) % P ; 
				ans = (ans + (ll)now * expow(inow, P - 2) % P * y[i] % P) % P ; 
			}
		}
	}
}/*
namespace Linear_sieve{
	int cnt ;
	int pr[N] ; 
	int mu[N] ;
	int vis[N] ;
	void sieve(int U){
		mu[1] = 1 ;
		for (int i = 2 ; i <= U ; ++ i){
			if (!vis[i]) mu[i] = -1, pr[++ cnt] = i ; 
			for (int j = 1 ; j <= cnt ; ++ j){
				if (i * pr[j] > U) break ; 
				vis[i * pr[j]] = 1 ; 
				if (i % pr[j] == 0) break ; 
				mu[i * pr[j]] = -mu[i] ; 
			}
		}
	}
}*/
int d, w, num ;
int base[N], cs[N] ;
int main(){
	cin >> d >> w ; n = d + 2 ; 
//	using namespace Linear_sieve ; 
	using namespace Interpolation ;
	for (int i = 1 ; i <= n ; ++ i) 
		x[i] = i, y[i] = (y[i - 1] + expow(x[i], d)) % P ; 
	for (int i = 1 ; i <= w ; ++ i)
		cin >> base[i] >> cs[i] ; get_xs(n) ; 
//	debug(y, 1, n + 1, '\n') ;
//	debug(res, 1, n + 1, '\n') ;
	for (int i = 1 ; i <= n + 1 ; ++ i){
		now = 0, num = 1 ;   
		for (int j = 1 ; j <= w ; ++ j){
			now = expow(expow(base[j], cs[j] - 1), i - 1) ;
			now = ((-1ll * now * expow(base[j], d) % P) + P) % P ; 
			now = (now + expow(expow(base[j], cs[j]), i - 1)) % P ; 
			num = 1ll * num * now % P ; 
		}
		ans = (ans + (ll)num * res[i] % P) % P ;
	}
	cout << ans << '\n' ; return 0 ;
}
```

---

## 作者：楠枫 (赞：9)

通过这道题学了**伯努利数**，写篇题解推一下

[题目](https://www.luogu.com.cn/problem/P6271)

先推一下式子
$$
\sum_{i=1}^ni^d[gcd(i,n)=1]
$$
$$
\sum_{i=1}^{n}i^d\sum_{k|i}\sum_{k|n}\mu(k)
$$
$$
\sum_{k|n}\mu(k)\sum_{i=1}^{\frac{n}{k}}(ik)^d
$$
$$
\sum_{k|n}\mu(k)k^d\sum_{i=1}^{\frac{n}{k}}i^d
$$
我们发现这个东西不好预处理，那么我们再简化一下。

设 $S_k(n)=\sum_{i=1}^{n-1}i^k$

则原式等于
$$
\sum_{k|n}\mu(k)k^d(S_d(\frac{n}{k})+(\frac{n}{k})^d)
$$
$$
\sum_{k|n}\mu(k)k^dS_d(\frac{n}{k})+\sum_{k|n}\mu(k)n^d
$$
$\sum_{k|n}\mu(k)$ 等价与 $[n=1]$，而本题中 $n$ 不可能为 $1$，所以原式为
$$
\sum_{k|n}\mu(k)k^dS_d(\frac{n}{k})
$$
设 $f_i$ 为在伯努利公式中 $i$ 次幂的系数
$$
\sum_{k|n}\mu(k)k^d\sum_{i=1}^{d+1}f_i(\frac{n}{k})^i
$$
$$
\sum_{k|n}\mu(k)\sum_{i=1}^{d+1}f_in^ik^{d-i}
$$
$$
\sum_{i=1}^{d+1}f_in^i\sum_{k|n}\mu(k)k^{d-i}
$$
我们会发现式子后半部分就是 $(\mu×id_{d-i})*I$，所以肯定是一个积性函数。

设 $F(n)=\sum_{k|n}\mu(k)k^{d-i},G(p)=\mu(p)p^{d-i},F(n)=\sum_{p|n}G(p)$

考虑质数取值：
$$
G(p)=\left\{
\begin{array}{lcl}
1\kern 2.2em(p=1)\\
-p^{d-i}\kern 1.0em(p\in prime)\\
\end{array}
\right.
$$
由 $\mu$ 的性质，可以得出上式当 $n\in prime$ 时，$F(n)=1-n^{d-i}$

所以总的复杂度即为 $O(d^2+dw)$，$d^2$ 为预处理 $f_i$ 。

$AC \kern 0.4emCODE:$
```cpp
#include<bits/stdc++.h>
#define ri register int
#define p(i) ++i
using namespace std;
const int MOD=1e9+7,W=1010,D=107;
inline int read() {
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}
	return x*f;
}
inline int fpow(int x,int y) {
	int res=1;
	while(y) {
		if (y&1) res=1ll*res*x%MOD;
		x=1ll*x*x%MOD;y>>=1;
	}
	return res;
}
inline int inv(int x) {return fpow(x,MOD-2);} 
int frac[D],invf[D];
void init(int k) {
	frac[0]=1;
	for (ri i(1);i<=k;p(i)) frac[i]=1ll*frac[i-1]*i%MOD;
	invf[k]=inv(frac[k]);
	for (ri i(k);i;--i) invf[i-1]=1ll*invf[i]*i%MOD;
}
inline int C(int n,int m) {return 1ll*frac[n]*invf[m]%MOD*invf[n-m]%MOD;}
struct Bernou{
	int B[D],f[D];
	inline void Bernoulli(int k) {
		B[0]=1;
		for (ri i(1);i<=k;p(i)) {
			int sum=0;
			for (ri j(0);j<i;p(j)) sum=(sum+1ll*C(i+1,j)*B[j]%MOD)%MOD;
			B[i]=(0-1ll*sum*inv(i+1)%MOD+MOD)%MOD; 	
		}
		int INV=inv(k+1);
		for (ri i(0);i<=k;p(i)) f[k+1-i]=1ll*C(k+1,i)*B[i]%MOD*INV%MOD;
	}
}B;
int d,w,p[W],a[W];
inline int Sum(int cm) {
	if (cm<0) cm=MOD-2;
	int res=1;
	for (ri i(1);i<=w;p(i)) res=1ll*res*(1-fpow(p[i],cm)+MOD)%MOD;
	return res;
}
int main() {
	d=read(),w=read();
	init(d+3);B.Bernoulli(d);
	for (ri i(1);i<=w;p(i)) p[i]=read(),a[i]=read();
	int ans=0,n=1;
	for (ri i(1);i<=w;p(i)) n=1ll*n*fpow(p[i],a[i])%MOD;
	for (ri i(1),cm(1);i<=d+1;p(i)) {
		cm=1ll*cm*n%MOD;
		ans=(ans+1ll*B.f[i]*cm%MOD*Sum(d-i)%MOD)%MOD;
	} 
	printf("%d\n",ans);
	return 0;
}

```

---

## 作者：chihik (赞：6)

注意本篇题解的 $k$ 是题目中的 $d$。

$$\sum_{i=1}^n[\gcd(i,n)=1]i^k$$

$$\sum_{i=1}^ni^k\sum_{d|\gcd(i,n)}\mu(d)$$

$$\sum_{d|n}\mu(d)d^k\sum_{i=1}^{\lfloor \frac{n}{d} \rfloor}i^k$$

$$\sum_{d|n}\mu(d)d^k(S_k(\frac{n}{d})+(\frac{n}{d})^k)$$

$$\sum_{d|n}\mu(d)d^kS_k(\frac{n}{d})+\sum_{d|n} \mu(d)d^k(\frac{n}{d})^k$$

$$\sum_{d|n}\mu(d)d^kS_k(\frac{n}{d})+n^k\sum_{d|n} \mu(d)$$

$$\sum_{d|n}\mu(d)d^kS_k(\frac{n}{d})+n^k[n=1]$$

这道题 $n$ 肯定不为 $1$ , 后面的值为 $0$，只需考虑前一个和式。

自然数幂和是一个 $k+1$ 次多项式，可以用[伯努利数](https://www.luogu.com.cn/blog/chihik/bo-nu-li-shu)算出系数，不妨记为 $f_i$。

由伯努利公式得：$f_{k+1-i}=\frac{\binom{k+1}{i}B_i}{k+1}$

$$\sum_{d|n}\mu(d)d^k \sum_{i=1}^{k+1} f_i \left ( \frac{n}{d} \right)^{i}$$

$$\sum_{i=1}^{k+1} f_i\sum_{d|n}\mu(d)d^k \left( \frac{n}{d} \right)^{i}$$

$$\sum_{i=1}^{k+1} f_i n^i\sum_{d|n}\mu(d) d^{k-i}$$

后面的和式是一个积性函数，考虑质数取值

$$\sum_{d|p^w}\mu(d)d^{k-i}$$

$$\sum_{i=0}^w \mu(p^i)p^{i(k-i)}$$

由 $\mu$ 的性质，只有 $i=0$ 或 $1$ 时不为 $0$，所以上式等于 $1-p^{k-i}$。

所以我们能 $\mathcal O(w)$ 计算出这个式子。

那么预处理出伯努利数和 $f$ ，原题便能 $\mathcal O(d^2+dw)$ 解决了。

```cpp
#include <cstdio>

const int MAXK = 105 , Mod = 1e9 + 7;

int Add( int x , int y ) { x += y; return x >= Mod ? x - Mod : x; }
int Sub( int x , int y ) { x -= y; return x < 0 ? x + Mod : x; }
int Mul( int x , int y ) { return 1ll * x * y % Mod; }
int Quick_pow( int x , int po ) { int Ans = 1; for( ; po ; po >>= 1 , x = Mul( x , x ) ) if( po & 1 ) Ans = Mul( Ans , x ); return Ans; }
int Inv( int x ) { return Quick_pow( x , Mod - 2 ); }
int Div( int x , int y ) { return Mul( x , Inv( y ) ); }

int fac[ MAXK + 10 ] , ivf[ MAXK + 10 ];
void Init( ) {
    fac[ 0 ] = 1;
    for( int i = 1 ; i <= MAXK + 5 ; i ++ ) fac[ i ] = Mul( fac[ i - 1 ] , i );
    ivf[ MAXK + 5 ] = Inv( fac[ MAXK + 5 ] );
    for( int i = MAXK + 5 ; i >= 1 ; i -- ) ivf[ i - 1 ] = Mul( ivf[ i ] , i );
}
int C( int n , int m ) { return Mul( fac[ n ] , Mul( ivf[ m ] , ivf[ n - m ] ) ); }

int w , k , p[ 1005 ] , a[ 1005 ];

int B[ MAXK + 5 ] , f[ MAXK + 5 ];
void Init_Bernoulli( ) {
    B[ 0 ] = 1;
    for( int i = 1 ; i <= MAXK ; i ++ ) {
        int Sum = 0;
        for( int j = 0 ; j < i ; j ++ ) Sum = Add( Sum , Mul( C( i + 1 , j ) , B[ j ] ) );
        B[ i ] = Sub( 0 , Mul( Sum , Inv( C( i + 1 , i ) ) ) );
    }
    for( int i = 0 ; i <= k ; i ++ ) f[ k + 1 - i ] = Div( Mul( C( k + 1 , i ) , B[ i ] ) , k + 1 );
}

int Sum( int pw ) {
    if( pw < 0 ) pw += Mod - 1;
    int Ans = 1;
    for( int i = 1 ; i <= w ; i ++ ) Ans = Mul( Ans , Sub( 1 , Quick_pow( p[ i ] , pw ) ) );
    return Ans;
}

int main( ) {
    scanf("%d %d",&k,&w);
    Init(); Init_Bernoulli();
    for( int i = 1 ; i <= w ; i ++ ) scanf("%d %d",&p[ i ],&a[ i ]);

    int Ans = 0 , n = 1;
    for( int i = 1 ; i <= w ; i ++ ) n = Mul( n , Quick_pow( p[ i ] , a[ i ] ) );
    for( int i = 1 , nk = 1 ; i <= k + 1 ; i ++ ) {
        nk = Mul( nk , n );
        Ans = Add( Ans , Mul( Mul( f[ i ] , nk ) , Sum( k - i ) ) );
    }
    printf("%d\n", Ans );
    return 0;
}
```

---

## 作者：jun头吉吉 (赞：5)

## 题意
$\sum_{i=1}^n[\gcd(i,n)=1]i^d$

由于 $n$ 可能很大，给出$n$的质因数分解式。

$n=\prod_{i=1}^{w} p_{i}^{\alpha_{i}}$

$1≤w≤10^3,2\leq p_i \leq 10^9,1 \leq a_i \leq 10^9$
## 题解

定位：~~莫反板子题~~莫反神仙题

$\sum_{i=1}^n[\gcd(i,n)=1]i^d$

$\sum_{i=1}i^d\sum_{x|\gcd(i,n)}\mu(x)$

$\sum_{x|n}\mu(x)\sum_{i=1}^{\frac n x}(ix)^d$

$\sum_{x|n}\mu(x)x^d\sum_{i=1}^{\frac n x}i^d$

根据经验我们得到，$f(x)=\sum_{i=1}^xi^d$是一个关于$x$的$d+1$次的多项式。

因此，设，$f(x)=a_0+a_1x+a_2x^2+a_3x^3+\ldots+a_{d+1}x^{d+1}$

$\sum_{x|n}\mu(x)x^d f(\frac n x)$

$\sum_{x|n}\mu(x)x^d \sum_{i=0}^{d+1}a_i(\frac n x)^i$

$\sum_{i=0}^{d+1}a_i\sum_{x|n}\mu(x)x^d (\frac n x)^i$

设$g(n)=\sum_{x|n}\mu(x)x^d (\frac n x)^i$，为$\mu\times Id_d$与$Id_i$卷起来得到的，前者与后者显然都为积性函数，那么$g$也必为积性函数。

$\sum_{i=0}^{m+1}a_ig(n)$

那么根据积性函数的性质，我们知道：

$g(n)=\prod_{j} g(p_j^{\alpha_j})$

再考虑当$n=p^{\alpha}$时，$\mu$当且仅当$x=1\ \text{or}\ p$时值不为零，因此：

$g(p^{\alpha})=\mu(1)1^d (\frac {p^\alpha} 1)^i+\mu(p)p^d (\frac {p^\alpha} p)^i=p^{i\alpha}-p^{d+(\alpha-1)\times i}$

再带回去，$g(n)=\prod_{j} (p_j^{i\alpha_j}-p_j^{d+(\alpha_j-1)\times i})$

再带回去，$\sum_{i=0}^{d+1}a_i\prod_{j} (p_j^{i\alpha_j}-p_j^{d+(\alpha_j-1)\times i})$

于是我们通过莫比乌斯函数，得出了一个与它无关的柿子。

$a_i$可以用高斯消元求出。

复杂度：$\mathcal{O}(d^3+d\times w)$~~可能还有快速幂的$\log mod$~~
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
template<class T,const int M>
struct Gauss{
	//解n元方程组
	int n;
	T B[M][M+1];
	T ans[M];
	bool run(){
		for(int i=0;i<n;i++){
			int pivot=i;
			for(int j=i;j<n;j++)
				if(B[j][i]==B[pivot][i])
					pivot=j;
			for(int j=0;j<=n;j++)swap(B[i][j],B[pivot][j]);
			if(B[i][i]==0)return false;
			for(int j=i+1;j<=n;j++)B[i][j]/=B[i][i];
			for(int j=0;j<n;j++)
				if(i!=j)
					for(int k=i+1;k<=n;k++)
						B[j][k]-=B[j][i]*B[i][k];
		}
		for(int i=0;i<n;i++)ans[i]=B[i][n];
		return true;
	}
};
typedef long long ll;
const ll mod=1e9+7;
ll ksm(ll a,ll b){
    ll res=1;
    while(b){
        if(b&1)res=res*a%mod;
        a=a*a%mod;b>>=1;
    }return res;
}
struct node{
	ll x;
	node(ll _=0){x=_;}
	bool operator==(node b){return x==b.x;}
	bool operator==(ll b){return x==b;}
	node operator*(node b){return node(x*b.x%mod);}
	node *operator/=(node b){x*=ksm(b.x,mod-2),x%=mod;return this;}
	node *operator-=(node b){x-=b.x,x%=mod,x+=mod,x%=mod;;return this;}
	node *operator+=(node b){x+=b.x,x%=mod,x+=mod,x%=mod;;return this;}
};
Gauss<node,200>G;
int d,w,p[1200],a[1200];
ll n=1;
signed main(){
	cin>>d>>w;
	G.n=d+2;
	for(int i=0;i<G.n;i++){
		for(int j=0;j<G.n;j++)
			G.B[i][j].x=ksm(i+1,j);
		for(int j=1;j<=i+1;j++)
			(G.B[i][G.n].x+=ksm(j,d))%=mod;
	}
	G.run();
	for(int i=1;i<=w;i++)
		cin>>p[i]>>a[i],(n*=ksm(p[i],a[i]))%=mod; 
	ll ans=0,res;
	for(int i=0;i<G.n;i++){
		res=G.ans[i].x;
		for(int j=1;j<=w;j++)
			res*=ksm(p[j],1ll*i*a[j])-ksm(p[j],d+1ll*(a[j]-1)*i),res%=mod; 
		ans+=res;ans%=mod;
	}
	cout<<(ans+mod)%mod;
}
```

---

## 作者：Terac (赞：2)

[$\texttt{link}$](https://www.luogu.com.cn/problem/P6271)  

## 题意

定义 $f_d(n)=\sum\limits_{i=1}^ni^d\left[\gcd(i,n)=1\right]$，给定 $n=\prod\limits_{i=1}^wp_i^{\alpha_i}$，求 $f_d(n)$，答案对 $10^9+7$ 取模。  

数据范围：$1\le d \le 10^2,1\le w\le10^3,1\le p_i,\alpha_i\le10^9,p_i\in\mathbf{Prime}$

## 题解 


$$\begin{aligned}\sum_{i=1}^n i^d\left[\gcd(i,n)=1\right]&=\sum_{i=1}^n i^d\sum_{x|\gcd(i,n)}\mu(x)\\&=\sum_{i=1}^ni^d\sum_{x|i,x|n}\mu(x)\end{aligned}$$
更换枚举顺序  

$$\begin{aligned}\sum_{i=1}^n i^d\left[\gcd(i,n)=1\right]&=\sum\limits_{x|n}\mu(x)\sum\limits_{i=1}^{\left\lfloor{\frac{n}{x}}\right\rfloor}(ix)^d\\&=\sum\limits_{x|n}x^d\mu(x)\sum_{i=1}^{\left\lfloor{\frac{n}{x}}\right\rfloor}i^d\end{aligned}$$  

看右半部分这个式子，令 $f(k)=\sum\limits_{i=1}^ki^d$，显然可以用系数表示成一个关于 $k$ 的 $d+1$ 次多项式，设 $f(k)=\sum\limits_{i=0}^{d+1}c_ik^i$，这个多项式的系数可以用高斯消元，lagrange 插值或伯努利数求出，时间复杂度为 $O(d^2)$ 或 $O(d^3)$。  

带进去  

$$\begin{aligned}\sum_{i=1}^n i^d\left[\gcd(i,n)=1\right]&=\sum\limits_{x|n}x^d\mu(x)f(\left\lfloor{\frac{n}{x}}\right\rfloor)\\&=\sum\limits_{x|n}x^d\mu(x)\sum\limits_{i=0}^{d+1}c_i\left\lfloor{\frac{n}{x}}\right\rfloor^i\\&=\sum\limits_{i=0}^{d+1}c_in^i \sum\limits_{x|n}x^{d-i}\mu(x)\end{aligned}$$  

设 $g(n)=\sum\limits_{x|n}x^{d-i}\mu(x)$，这个函数显然是积性的，所以有 $g(n)=\prod\limits_{j=1}^wg(p_j^{\alpha_j})$。

在求 $g(p_j^{\alpha_j})$ 时，根据 $\mu$ 函数的定义，含有完全平方因子时其值为 $0$，所以当且仅当 $x=1$ 或 $x=p_j$ 时，$x^{d-i}\mu(x)$ 对 $g(p_j^{\alpha_j})$ 是有贡献的，即 $g(p_j^{\alpha_j})=1^{d-i}\mu(1)+{p_j}^{d-i}\mu(p_j)=1-p_j^{d-i}$。  

所以
$$\begin{aligned}\sum_{i=1}^n i^d\left[\gcd(i,n)=1\right]&=\sum\limits_{i=0}^{d+1}c_in^ig(n)\\&=\sum\limits_{i=0}^{d+1}c_in^i\prod\limits_{j=1}^wg(p_j^{\alpha_j})\\&=\sum\limits_{i=0}^{d+1}c_in^i\prod\limits_{j=1}^w(1-p_j^{d-i})\end{aligned}$$  

于是可以 $O(d^2+dw\log\text{mod})$ 或 $O(d^3+dw\log\text{mod})$ 求出答案。

```cpp
#include <bits/stdc++.h>
using namespace std;
namespace IO {
	//read and write
} using namespace IO;
const int N = 1e3 + 10, P = 1e9 + 7;
int qpow(int a, int k) {
	int res = 1;
	while(k) {
		if(k & 1) res = 1ll * res * a % P;
		a = 1ll * a * a % P;
		k >>= 1; 
	}
	return res;
}
int d, w, n, a[N][N], p[N], q[N], c[N], ans;
void build() {
	for(int i = 0; i <= d + 1; i++) {
		for(int j = 0; j <= d + 1; j++) a[i][j] = qpow(i + 1, j);
		for(int j = 1; j <= i + 1; j++)
			a[i][d + 2] = (a[i][d + 2] + qpow(j, d)) % P;
	}
}
void gauss(int n) {
	for(int i = 0, mx, inv; i <= n; i++) {
		mx = i;
		for(int j = i + 1; j <= n; j++)
			if(a[mx][i] < a[j][i]) mx = j;
		swap(a[i], a[mx]);
		inv = qpow(a[i][i], P - 2) % P;
		for(int j = i + 1; j <= n + 1; j++)
			a[i][j] = 1ll * a[i][j] * qpow(a[i][i], P - 2) % P;
		for(int j = 0; j <= n; j++)
			if(i != j)
				for(int k = i + 1; k <= n + 1; k++)
					a[j][k] = (a[j][k] - 1ll * a[i][k] * a[j][i] % P + P) % P;
	}
	for(int i = 0; i <= n; i++) c[i] = a[i][n + 1]; 
}
int main() {
	d = read(), w = read();
	build(); gauss(d + 1);
	for(int i = 1; i <= w; i++)
		p[i] = read(), q[i] = read(), n = 1ll * n * qpow(p[i], q[i]) % P;
	for(int i = 0, res, t = 1; i <= d + 1; t = 1ll * t * n % P, i++) {
		res = 1ll * c[i] * t % P;
		for(int j = 1; j <= w; j++)
			res = 1ll * res * (1 - qpow(p[j], d - i + P - 1) + P) % P;
		ans = (ans + res) % P;
	}
	printf("%d\n", ans);
	return 0;
}
```


---

## 作者：Gauss0320 (赞：2)

今天心情不好，来写一道简单数论题调节一下~

---

## 题目描述

给出$n$的质因数分解和$m$，求
$$\sum_{i=1}^n[i\perp n]i^m$$
## 题解
$$\begin{aligned}\sum_{i=1}^n[i\perp n]i^m &=\sum_{i=1}^mi^m\sum_{k|\gcd(i,n)}\mu(k)\\&=\sum_{k|n}\mu(k)\sum_{i=1}^{n/k}(ik)^m\\&=\sum_{k|n}\mu(k)k^m\sum_{i=1}^{n/k}i^m\end{aligned}$$
看到后面那个自然数幂和，直接拿伯努利数淦它就好了.

现在令
$$S_m(n)=\sum_{i=1}^ni^m=\sum_{i=1}^{m+1}a_in^i$$
带入得
$$\begin{aligned}\sum_{i=1}^{n}[i\perp n]i^m&=\sum_{k|n}\mu(k)k^m\sum_{i=1}^{m+1}a_i\left(\frac{n}{k}\right)^i\\&=\sum_{i=1}^{m+1}a_i\sum_{k|n}\mu(k)k^m\left(\frac{n}{k}\right)^i\\&=\sum_{i=1}^{m+1}a_ig_i(n)\end{aligned}$$
显然，$\mu(n)n^m$与$n^i$均为积性函数，而积性函数的狄利克雷卷积也为积性函数，所以$g_i(n)$为积性函数.

所以有
$$g_i(n)=\prod_{j=1}^{\omega(n)}g(p_j^{c_j})$$
考虑到$\mu$只在free square number处有值，所以
$$g_i(n)=\prod_{j=1}^{\omega(n)}(p_j^{ic_j}-p^{m+i(c_j-1)})$$
时间复杂度$O(m\omega(n))$.

## 代码

考虑了下要不要写多项式求逆

发现模数不对（懒得写MTT了），于是没写

$m$太小了怎么搞都行.

```cpp
#include <cstdio>
#include <iostream>

using namespace std;
const int M = 100 + 1;
const int mod = 1e9 + 7;
int B[M + 1], inv[M + 2], fac[M + 1], facinv[M + 1];

int pow(int a, int b)
{
	int ans = 1;
	for(; b; b >>= 1, a = 1ll * a * 1ll * a % mod)
		if(b & 1) ans = 1ll * ans * 1ll * a % mod;
	return ans;
}
int Comb(int n, int m)
{
	return 1ll * fac[n] * 1ll * facinv[m] % mod * 1ll * facinv[n - m] % mod;
}
void init()
{
	fac[0] = 1;
	for(int i = 1; i <= M; i++)
		fac[i] = 1ll * fac[i - 1] * 1ll * i % mod;
	facinv[M] = pow(fac[M], mod - 2);
	for(int i = M; i >= 1; i--)
		facinv[i - 1] = 1ll * facinv[i] * 1ll * i % mod;
	inv[1] = 1;
	for(int i = 2; i <= M + 1; i++)
		inv[i] = 1ll * inv[mod % i] * 1ll * (mod - mod / i) % mod;
	B[0] = 1;
	for(int i = 1; i <= M; i++)
	{
		for(int j = 0; j < i; j++)
			B[i] = (1ll * B[i] - 1ll * Comb(i + 1, j) * 1ll * B[j] % mod + 1ll * mod) % mod;
		B[i] = 1ll * B[i] * 1ll * inv[i + 1] % mod;
	}
}
const int W = 1e3;
int w, m, ans, a[M + 1], p[W + 1], c[W + 1];
int read()
{
	int ans = 0; char ch;
	for(; !isdigit(ch = getchar()); );
	for(; isdigit(ch); ans = (ans << 1) + (ans << 3) + (ch ^ 48), ch = getchar());
	return ans;
}
int g(int i)
{
	int ans = 1;
	for(int j = 1; j <= w; j++)
		ans = 1ll * ans * (1ll * pow(p[j], 1ll * c[j] * 1ll * i % (mod - 1)) - 1ll * pow(p[j], (1ll * m + 1ll * i * 1ll * (c[j] - 1)) % (mod - 1)) + 1ll * mod) % mod;
	return ans;
}
int main()
{
	init();
	m = read(), w = read();
	for(int i = 1; i <= w; i++)
		p[i] = read(), c[i] = read();
	for(int i = 1; i <= m + 1; i++)
	{
		for(int j = 0; j <= i; j++)
			a[j] = (1ll * a[j] + 1ll * Comb(m + 1, i) * 1ll * B[m + 1 - i] % mod * 1ll * Comb(i, j)) % mod;
	}
	for(int i = 1; i <= m + 1; i++)
		a[i] = 1ll * a[i] * 1ll * pow(m + 1, mod - 2) % mod;
	for(int i = 1; i <= m + 1; i++)
		ans = (1ll * ans + 1ll * a[i] * 1ll * g(i)) % mod;
	printf("%d\n", ans);
	return 0;
}
```


---

## 作者：Spasmodic (赞：2)

方便起见，令题中的 $d\to m$。

$$
\begin{aligned}
f_m(n)&=\sum_{i=1}^{n}[\gcd(i,n)=1]i^m\\
&=\sum_{i=1}^{n}i^m\sum_{d|i,d|n}\mu(d)\\
&=\sum_{d|n}\mu(d)\sum_{d|i}i^m\\
&=\sum_{d|n}\mu(d)d^m\sum_{i=1}^{n/d}i^m\\
\end{aligned}
$$
设
$$
\sum_{i=1}^{n}i^m=\sum_{i=0}^{m+1}f_in^i
$$
可以插值或高斯消元进行计算，复杂度是 $O(m^3)$ 或 $O(m^2)$ 或 $O(m\log^2 m)$，采用第一种即可。

则
$$
\begin{aligned}
f_m(n)&=\sum_{d|n}\mu(d)d^m\sum_{i=0}^{m+1}f_i(n/d)^i\\
&=\sum_{i=0}^{m+1}f_i\sum_{d|n}\mu(d)d^m(n/d)^i
\end{aligned}
$$
注意到
$$
F_i(n)=\sum_{d|n}\mu(d)d^m(n/d)^i
$$
是积性函数，所以我们只需要考虑计算 $F_i(p^k)$ 即可，显然可以 $O(1)$ 算。

复杂度 $O(m^3+mw)$

---

## 作者：orz_z (赞：1)

### [P6271 [湖北省队互测2014]一个人的数论](https://www.luogu.com.cn/problem/P6271)

给你 $n=\prod\limits_{i=1}^{w}p_i^{a_i}$，求：
$$
\sum_{i=1}^{n}i^d[\gcd(i,n)=1]
$$
$1 \leq w \leq 10^3.2 \leq p_i \leq 10^9,1 \leq a_i \leq 10^9$。

先化简原式，有：
$$
\begin{aligned}
\sum_{i=1}^{n}i^d[\gcd(i,n)=1]&=\sum_{i=1}^{n}i^d\sum_{p|\gcd(i,n)}\mu(p)\\
&=\sum_{i=1}^{n}i^k\sum_{p=1}^{n}\mu(p)[p|i][p|n]\\
&=\sum_{p|n}\mu(p)\sum_{i=1}^{n}i^k[p|i]\\
&=\sum_{p|n}\mu(p)\sum_{i=1}^{\frac{n}{p}}(ip)^d\\
&=\sum_{p|n}\mu(p)k^d\sum_{i=1}^{\frac{n}{p}}i^d
\end{aligned}
$$
对于 $\sum\limits_{i=1}^{x}i^d$，我们知道它可以表示为一个关于 $x$ 的 $d+1$ 次多项式，设其为：
$$
\sum_{i=1}^{d+1}f_ix^i
$$
我们可以用高斯消元在 $\mathcal O(d^3)$ 内算出系数 $f_i$ 的值，再算出原式的值。

搞定上面那个后，原式可化为：
$$
\begin{aligned}
&\sum_{p|n}\mu(p)p^d\sum_{i=0}^{d+1}f_i(\frac{n}{p})^i\\
&=\sum_{i=0}^{d+1}f_i\sum_{p|n}\mu(p)p^d(\frac{n}{p})^i
\end{aligned}
$$
后面那部分筛一下即可。

```cpp
#include <bits/stdc++.h>

#define int long long
int read()
{
    int x = 0, f = 1;
    char c = getchar();
    while (c < '0' || c > '9')
    {
        if (c == '-')
            f = -1;
        c = getchar();
    }
    while (c >= '0' && c <= '9')
    {
        x = x * 10 + c - '0';
        c = getchar();
    }
    return x * f;
}

const int mod = 1e9 + 7;

int qpow(int a, int b)
{
    if (b < 0)
        b += mod - 1;
    int ret = 1;
    for (; b; b >>= 1, a = 1ll * a * a % mod)
        if (b & 1)
            ret = 1ll * ret * a % mod;
    return ret;
}

int inv(int a)
{
    return qpow(a, mod - 2);
}

int m, w;

int p[1007], a[1007];

int mat[105][105], f[105], sum[105];

void init()
{
    for (int i = 1; i <= m + 2; ++i)
    {
        sum[i] = (qpow(i, m) + sum[i - 1]) % mod;
        mat[i - 1][0] = 1, mat[i - 1][m + 2] = sum[i];
        for (int j = 1; j <= m + 1; ++j)
            mat[i - 1][j] = mat[i - 1][j - 1] * i % mod;
    }
}

//行：[0, m + 1]，列：[0, m + 2]

void gauss()
{
    for (int i = 0; i <= m + 1; ++i)
    {
        int r = i;
        for (int j = i + 1; j <= m + 1; ++j)
            if (mat[j][i] > mat[r][i])
                r = j;
        std::swap(mat[r], mat[i]);
        int div = inv(mat[i][i]);
        for (int j = i; j <= m + 2; ++j)
            mat[i][j] = mat[i][j] * div % mod;
        for (int j = i + 1; j <= m + 1; ++j)
        {
            div = mat[j][i];
            for (int k = i; k <= m + 2; ++k)
                mat[j][k] = ((mat[j][k] - mat[i][k] * div % mod) % mod + mod) % mod;
        }
    }
    f[m + 1] = mat[m + 1][m + 2];
    for (int i = m; i >= 0; --i)
    {
        f[i] = mat[i][m + 2];
        for (int j = i + 1; j <= m + 1; ++j)
            f[i] = ((f[i] - mat[i][j] * f[j] % mod) % mod + mod) % mod;
    }
    return;
}

signed main()
{
    m = read(), w = read();
    for (int i = 1; i <= w; ++i)
        p[i] = read(), a[i] = read();
    init();
    gauss();
    int ans = 0;
    for (int i = 0; i <= m + 1; ++i)
    {
        int tmp = 1;
        for (int j = 1; j <= w; ++j)
            tmp = qpow(p[j], a[j] * i % (mod - 1)) * (1ll - qpow(p[j], m - i) + mod) % mod * tmp % mod;
        ans = (ans + tmp * f[i] % mod) % mod;
    }
    printf("%lld\n", ans);
    return 0;
}
```





---

## 作者：QQ82272760 (赞：1)

由于 $d$ 有别的用途，所以用 $m$ 来表示原来的 $d$

题目要求
$$
ans=\sum_{i=1}^n[i\bot n]i^m
$$
然后根据莫比乌斯反演，很明显 $[i\bot n]=\sum_{d|i,d|n}\mu(d)$，再更换枚举顺序，就有
$$
ans=\sum_{d=1}^n\mu(d)\sum_{i=1}^{\frac nd}(id)^m
$$

把 $\sum_{i}$ 里的 $d$ 提出来，然后就要求 $\sum_{i=1}^ni^n$。它是个 $m+1$ 次多项式，所以可以先用 $O(m^3)$ 高斯消元求出每一项的系数 $f_i$ ，然后
$$
ans=\sum_{d=1}^n\mu(d)d^m\sum_{i=0}^{m+1}f_i\left(\frac nd\right)^m
$$
最后再更换一下枚举顺序稍加整理得到
$$
ans=\sum_{i=0}^{m+1}f_in^i\sum_{d|n}\mu(d)d^{m-i}
$$
题目说 $n=\prod_{i=1}^wp_i^{\alpha_i}$，这样每项要乘起来的就互质了，然后根据积性函数的性质，有
$$
ans=\sum_{i=0}^{m+1}f_in^i\prod_{j=1}^w\sum_{k_j=0}^{\alpha_j}\mu(p_j^{k_j})p_j^{k_j(m-i)}
$$
虽然说 $\alpha_i\le 10^9$，但不为零的只有 $p_i^0$ 和 $p_i^1$ 两项啊，所以就可以做到 $O(mw\log(m\alpha))$ 了

```cpp
#include<iostream>
#include<cstdio>
#define mod 1000000007
using namespace std;
int m,w,ans;
int p[1005],a[1005];
int g[105][105],h[105],f[105];
int qp(int x,int y=mod-2){
	if(y==-1) y=mod-2;
	if(y==0) return 1;
	if(y==1) return x;
	int res=qp(x,y>>1);
	res=1ll*res*res%mod;
	if(y&1) res=1ll*res*x%mod;
	return res;
}
int add(int x,int y){
	if((x+=y)>=mod) x-=mod;
	return x;
}
int sub(int x,int y){
	if((x-=y)<0) x+=mod;
	return x;
}
void init(){
	int n=m+1,x;
	for(int i=0;i<=n;i+=1){
		g[i][0]=1; if(i) h[i]=add(h[i-1],qp(i,m));
		for(int j=1;j<=n;j+=1) g[i][j]=1ll*g[i][j-1]*i%mod;
	}
	for(int i=0;i<=n;i+=1){
		for(int j=i;j<=n;j+=1){
			if(g[i][j]){
				swap(g[i],g[j]);
				break;
			}
		}
		for(int j=0;j<=n;j+=1){
			if(i==j) continue;
			x=1ll*g[j][i]*qp(g[i][i])%mod;
			for(int k=i;k<=n;k+=1){
				g[j][k]=sub(g[j][k],1ll*g[i][k]*x%mod);
			}
			h[j]=sub(h[j],1ll*h[i]*x%mod);
		}
	}
	for(int i=0;i<=n;i+=1) f[i]=1ll*h[i]*qp(g[i][i])%mod;
	return;
}
int solve(int n){
	int res=1,now;
	for(int i=1;i<=w;i+=1){
		now=1;
		if(a[i]>=1) now=sub(now,qp(p[i],m-n));
		res=1ll*res*now%mod;
	}
	return res;
}
int main(){
	int n=1;
	scanf("%d%d",&m,&w); init();
	for(int i=1;i<=w;i+=1){
		scanf("%d%d",&p[i],&a[i]);
		n=1ll*n*qp(p[i],a[i])%mod;
	}
	for(int i=0;i<=m+1;i+=1){
		ans=add(ans,1ll*f[i]*solve(i)%mod*qp(n,i)%mod);
	}
	printf("%d\n",ans);
	return 0;
}
```
Thanks~

---

## 作者：木xx木大 (赞：1)

[P6271 [湖北省队互测2014]一个人的数论](https://www.luogu.com.cn/problem/P6271) 

$$
\begin{aligned}
&\sum_{i=1}^n[\gcd(i,n)==1]i^k\\
=&\sum_{i=1}^n\sum_{d|i,d|n}\mu(d)i^k\\
=&\sum_{d|n}\mu(d)d^k\sum_{i=1}^{\frac{n}{d}}i^k
\end{aligned}
$$

设 $F(n)=\sum_{i=1}^ni^k$ ，$F(n)$ 为一个 $k+1$ 次多项式，即 $F(n)=\sum_{i=0}^{k+1}f_in^i$，代入上式得

$$
\begin{aligned}
&\sum_{d|n}\mu(d)d^k\sum_{i=1}^{\frac{n}{d}}i^k\\
=&\sum_{d|n}\mu(d)d^k\sum_{i=0}^{k+1}f_i\left(\frac{n}{d}\right)^i\\
=&\sum_{i=0}^{k+1}f_in^i\sum_{d|n}\mu(d)d^{k-i}
\end{aligned}
$$

$k$ 很小，于是枚举 $i$。$\mu$ 和 $id_k$ 都是积性函数，因此 $\mu(d)d^k$ 为积性函数，后面的和式相当于这个积性函数 $*1$，也是积性函数。那么考虑素数幂处的取值

$$
\begin{aligned}
&\sum_{i=0}^{k+1}f_in^i\sum_{d|n}\mu(d)d^{k-i}\\
=&\sum_{i=0}^{k+1}f_in^i\prod_{p|n}\sum_{j=0}^{p^j|n}\mu(p^j)p^{j(k-i)}\\
=&\sum_{i=0}^{k+1}f_in^i\prod_{p|n}(1-p^{k-i})
\end{aligned}
$$

拉格朗日插值求 $f$，复杂度 $O(d^2+dw)$

```cpp
#include<bits/stdc++.h>
using namespace std;
namespace FGF
{
	int K,m,n=1;
	const int N=1010,mo=1e9+7;
	int p[N],ans,f[N],a[N],inv[N],g[N];
	int qpow(int x,int y)
	{
		int s=1;
		while(y)
		{
			if(y&1)s=1ll*s*x%mo;
			x=1ll*x*x%mo;
			y>>=1;
		}
		return s;
	}
	void Lagrange()
	{
		inv[1]=f[0]=1;
		for(int i=2;i<=K+2;i++)
			inv[i]=1ll*inv[mo%i]*(mo-mo/i)%mo;
		for(int i=1;i<=K+2;i++)
			for(int j=K+2;j>=0;j--)
				f[j]=((j?f[j-1]:0)+1ll*(mo-i)*f[j]%mo)%mo;
		for(int y=1,i=1;i<=K+2;i++,y=(y+qpow(i,K))%mo)
		{
			g[0]=1ll*f[0]*(mo-inv[i])%mo;
			for(int j=1;j<=K+2;j++)
				g[j]=1ll*(f[j]-g[j-1]+mo)%mo*(mo-inv[i])%mo;
			int tmp=y;
			for(int j=1;j<=K+2;j++)
			{
				if(i>j)tmp=1ll*tmp*inv[i-j]%mo;
				if(i<j)tmp=1ll*tmp*(mo-inv[j-i])%mo;
			}
			for(int j=0;j<=K+1;j++)
				a[j]=(a[j]+1ll*tmp*g[j]%mo)%mo;
		}
	}
	void work()
	{
		scanf("%d%d",&K,&m);
		for(int i=1,x;i<=m;i++)
			scanf("%d%d",&p[i],&x),n=1ll*n*qpow(p[i],x)%mo;
		Lagrange();
		for(int i=0,x=1;i<=K+1;i++,x=1ll*x*n%mo)
		{
			int s=1ll*a[i]*x%mo;
			for(int j=1;j<=m;j++)
				s=1ll*s*(mo+1-qpow(p[j],K-i+mo-1))%mo;
			ans=(ans+s)%mo;
		}
		printf("%d\n",ans);
	}
}
int main()
{
	FGF::work();
	return 0;
}




---

## 作者：清烛 (赞：0)

[宣传博客](https://blog.imyangty.com/sol-bzoj3601/)

## Description

定义 $f_m(n)$ 为所有小于 $n$ 且与 $n$ 互素的正整数的 $m$ 次方之和。给定 $m$ 的值和 $n$ 的质因数分解式，求 $f_m(n)\bmod 10^9 + 7$ 的值。

若
$$
n = \prod_{i = 1}^{w}p_i^{\alpha_i}
$$
有 $1\le w \le 1000$，$2\le p_i\le 10^9$，$1\le \alpha_i\le 10^9$，$0\le m \le 100$。

## Solution

### Part. 1

首先明确一下求的东西是什么：
$$
\sum_{i = 1}^{n - 1}i^m[\gcd(i, n) = 1]
$$
然后发现貌似把上界改成 $n$ 也不会有事，反正 $n > 1$。

然后就可以从 $[\gcd(i, n) = 1]$ 入手开始化简式子了。
$$
\begin{aligned}
&\sum_{i = 1}^ni^m\sum_{d\mid i, n}\mu(d)\\
=&\sum_{d \mid n}\mu(d)\sum_{i = 1}^{\frac nd}(id)^m\\
=&\sum_{d \mid n}\mu(d)d^m\sum_{i = 1}^{\frac nd}i^m\\
\end{aligned}
$$
第一行是反演变换将 $[(i, n) = 1]$ 换掉。

第二行是更换枚举顺序，令 $i = i'd$，则我们枚举 $i'$ 即可。

第三行就是把能提出来的给提出来。

### Part. 2

观察到式子里面有一项形如
$$
f(n) = \sum_{i = 1}^ni^m
$$
的东西，根据经验可得 $f(n)$ 为关于 $n$ 的 $m + 1$ 次多项式。令这个多项式为 $\sum_{i = 0}^{m + 1}f_in^i$。这些系数是可以直接暴力高斯消元求出来的，再回过头看看我们的式子：
$$
\begin{aligned}
&\sum_{d \mid n}\mu(d)d^m\sum_{i = 1}^{\frac nd}i^m\\
=&\sum_{d \mid n}\mu(d)d^m\sum_{i = 0}^{m + 1}f_i\left(\frac nd\right)^i\\
=&\sum_{i = 0}^{m + 1}f_i\sum_{d \mid n}\mu(d)d^m\left(\frac nd\right)^i
\end{aligned}
$$
后面的那个东西是积性函数的卷积，所以他们本身也满足积性，可以把所有的 $p_i^{\alpha_i}$ 的函数值算出来之后乘在一起得到结果。问题就是怎么快速求这个长得怪怪的东西。

### Part. 3

注意到我们要求的是形如 $p_i^{\alpha_i}$ 这样的东西的函数值。那么当 $\alpha_i\ge 2$ 的时候是肯定会出现平方因子的，这部分 $d$ 是不用计算的因为 $\mu(d) = 0$。所以实际上要算的就只有 $d = 1$ 和 $d = p_i$ 的情况。即我们需要算 $p_i^{\alpha_ii} - p_i^mp_i^{\alpha_ii-i}$。

算法就是枚举 $i$，然后对每个质因子算一遍那个积性函数的值然后乘起来，再乘上 $f_i$ 累加进答案中。

所以，总的时间复杂度就是 $O(m^3 + m(m + w))$。

## Implementation

首先是初始化矩阵的时候，千万注意是否有非法访问，否则 WA 70。

其次是注意该开 `long long` 的地方一定不能漏掉，否则 WA 50。

```cpp
#include <cstdio>
#include <cctype>
#include <algorithm>
#define il inline
#define FOR(i, a, b) for (int i = a; i <= b; ++i)
#define DEC(i, a, b) for (int i = a; i >= b; --i)

namespace fastIO {
    const int maxc = 1 << 21;
    char ibuf[maxc], *__p1 = ibuf, *__p2 = ibuf;
    il char getchar() {return __p1 == __p2 && (__p2 = (__p1 = ibuf) + fread(ibuf, 1, maxc, stdin), __p1 == __p2) ? EOF : *__p1++;}
    template<typename T> void read(T &n) {
        int x = 0; n = 0;
        char c = getchar();
        while (!isdigit(c))
            x |= (c == '-'), c = getchar();
        while (isdigit(c))
            n = n * 10 + c - '0', c = getchar();
        n = x ? -n : n;
    }
}

using namespace fastIO;

typedef long long ll;
const int mod = 1e9 + 7;

ll qPow(ll a, ll b, ll p = mod) {
    if (b < 0) b += mod - 1;
    ll ret = 1;
    for (; b; b >>= 1, a = 1ll * a * a % p)
        if (b & 1) ret = 1ll * ret * a % mod;
    return ret;
}

il int inv(int a, int m = mod) {return qPow(a, m - 2, m);}

const int maxw = 1005;
int m, w;
ll p[maxw], a[maxw];
ll mat[105][105], f[105], sum[105];

void initMat() {
    FOR(i, 1, m + 2) {
        sum[i] = (qPow(i, m) + sum[i - 1]) % mod;
        mat[i - 1][0] = 1, mat[i - 1][m + 2] = sum[i];
        FOR(j, 1, m + 1)
            mat[i - 1][j] = mat[i - 1][j - 1] * i % mod;
    }
    return;
}

//行：[0, m + 1]，列：[0, m + 2]

void gauss() {
    FOR(i, 0, m + 1) {
        int r = i;
        FOR(j, i + 1, m + 1)
            if (mat[j][i] > mat[r][i])
                r = j;
        std::swap(mat[r], mat[i]);
        ll div = inv(mat[i][i]);
        FOR(j, i, m + 2) mat[i][j] = mat[i][j] * div % mod;
        FOR(j, i + 1, m + 1) {
            div = mat[j][i];
            FOR(k, i, m + 2)
                mat[j][k] = ((mat[j][k] - mat[i][k] * div % mod) % mod + mod) % mod;
        }
    }
    f[m + 1] = mat[m + 1][m + 2];
    DEC(i, m, 0) {
        f[i] = mat[i][m + 2];
        FOR(j, i + 1, m + 1)
            f[i] = ((f[i] - mat[i][j] * f[j] % mod) % mod + mod) % mod;
    }
    return;
}

int main() {
    read(m), read(w);
    FOR(i, 1, w) read(p[i]), read(a[i]);
    initMat();
    gauss();
    ll ans = 0;
    FOR(i, 0, m + 1) {
        ll tmp = 1;
        FOR(j, 1, w)
            tmp = qPow(p[j], a[j] * i % (mod - 1)) * (1ll - qPow(p[j], m - i) + mod) % mod * tmp % mod;
        ans = (ans + tmp * f[i] % mod) % mod;
    }
    printf("%lld\n", ans);
    return 0;
}
```


---


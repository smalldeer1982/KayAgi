# 「JZOI-1」红包

## 题目背景

新年到了，小僖收到了叔叔寄给他的红包，这个红包里面有很多很多的钱。

## 题目描述

小僖收到的红包总额是这样的：

所有 $K$ 元组满足每个元素都是正整数且 $\le N$，总额就是这些 $K$ 元组的最小公倍数的乘积。

但由于叔叔并没有那么多的钱，所以结果还要对 $998244353$ 取模。

小僖花了 $10^{-16}$ 秒就算了出来，但他想验证一下是否正确，于是找上了你（别问我为什么他不直接拆开红包看）。

换句话讲，题目只需要你求：
$$\prod_{i_1=1}^N\prod_{i_2=1}^N...\prod_{i_K=1}^N{\rm lcm}(i_1,i_2...i_K)\mod 998244353$$
保证 $K>1$，其中，${\rm lcm}(i_1,i_2...i_K)$，表示 $i_1,i_2...i_K$ 的最小公倍数。

## 说明/提示

对于样例的第一组数据，题目要求求出 ${\rm lcm}(1,1)\times {\rm lcm}(1,2)\times {\rm lcm}(2,1)\times {\rm lcm}(2,2)$。

显然，除了 ${\rm lcm}(1,1)=1$ 以外其它的结果都为 $2$，所以答案为 $1\times2\times2\times2=8$。

| 数据编号 | $N\le$ | $K\leq$ | $T=$ |
| :-----------: | ----------- | ----------- | ----------- |
| **0** |$10$|$5$|$10$|
| **1** | $10^6$ |$2$|$10^3$|
| **2** | $10^6$ |$3$|$10^3$|
| **3** | $100$ |$10^{18}$|$100$|
| **4** | $10^5$ |$100$|$10^3$|
| **5** | $10^5$ |$3\times10^8$|$1$|
| **6** | $10^5$ |$10^{100}$| $10$ |
| **7** |$10^6$|$10^{18}$|$10^3$|
| **8** |$10^6$|$10^{100}$|$10^3$|
| **9** |$10^6$|$10^{100}$|$10^3$|

**出题人：你真以为有这么多钱，哈哈，里面装的全是津巴布韦币哦！**

## 样例 #1

### 输入

```
2
2 2
3 2```

### 输出

```
8
7776```

# 题解

## 作者：_LHF_ (赞：16)

看到很多人都用了计算每个质数的贡献来做出这道题的……
# 先讲一下出题人原来的做法
前置知识：莫比乌斯反演，min-max容斥，二项式定理。
## Step1.
好了，我们设集合$T$(与上文无关)的大小为$n$，即$n=|T|$，并且$lcm(T)=lcm(T_1,T_2...T_n),gcd(T)=gcd(T_1,T_2...T_n)$

则有$\displaystyle lcm(T)=\prod_{S\subsetneq T}gcd(S)^{(-1)^{|S|}}$

证明：考虑min-max容斥。

我们可以把每一个质数分开考虑，显然，$lcm(p^a,p^b)=p^{\max(a,b)},gcd(p^a,p^b)=p^{\min(a,b)}$（$p$是个质数），多个数同理。然后直接套用min_max容斥的结论即可，记得把加法改成乘法，减法变成的除法。

Q：为什么可以这么做呢？

A：这显然，因为同底数幂相乘，底数不变，指数相加。
## Step2.
设
$$F(n,K)=\prod_{i_1=1}^n\prod_{i_2=1}^n...\prod_{i_k=1}^n\gcd(i_1,i_2...i_k)$$
$$=\prod_{k=1}^nk^{\sum_{i_1=1}^{n}\sum_{i_2=1}^{n}...\sum_{i_K=1}^{n}[\gcd(i_1,i_2...i_K)=k]}$$
（注意：区分大小写）

考虑指数上面那一坨东西

$$\sum_{i_1=1}^{n}\sum_{i_2=1}^{n}...\sum_{i_K=1}^{n}[\gcd(i_1,i_2...i_K)=k]=\sum_{d=1}^{\lfloor\frac{n}{k}\rfloor}\lfloor\frac{n}{kd}\rfloor^K\mu(d)$$
再带回去得到
$$F(n,k)=\prod_{k=1}^n\prod_{d=1}^{\lfloor\frac{n}{k}\rfloor}k^{\lfloor\frac{n}{kd}\rfloor^K\mu(d)}$$
设$T=kd$，枚举$T$得到：
$$F(n,k)=\prod_{T=1}^n(\prod_{d|T}d^{\mu(\frac{T}{d})})^{\lfloor\frac{n}{T}\rfloor^K}$$
## Step3.
现在看到题目要求求的这个东西，带入Step1、Step2求出的公式，我们发现题目就是求：
$$\prod_{i=1}^K F(n,i)^{(-1)^{i+1}\times C_K^i\times n^{K-i}}$$
顺便说一句，$\displaystyle F(n,1)=\prod_{i=1}^ni$

我们分析一下
$$F(n,k)=\prod_{T=1}^n(\prod_{d|T}d^{\mu(\frac{T}{d})})^{\lfloor\frac{n}{T}\rfloor^K}$$

那么$F(n,K)^a=\prod_{T=1}^n(\prod_{d|T}d^{\mu(\frac{T}{d})})^{a\times\lfloor\frac{n}{T}\rfloor^K}$

其实我们可以发现$F(n,a)$和$F(n,b)$只有后面那一坨的指数不同，考虑幂的乘方，底数不变，指数相乘。

把题目中的那一坨式子带入得到：
$$ans=\prod_{T=1}^n(\prod_{d|T}d^{\mu(\frac{T}{d})})^?$$
好了，我们现在想一想式子中的$?$是什么。

显然，$?=C_K^1\times n^{K-1}\times\lfloor\frac{n}{T}\rfloor-C_K^2\times n^{K-2}\lfloor\frac{n}{T}\rfloor^2+...=\sum_{i=1}^K(-1)^{i+1}C_{K}^i\times n^{K-i}\times\lfloor\frac{n}{T}\rfloor^i$

运用二项式定理，可得$?=n^K-(n-\lfloor\frac{n}{T}\rfloor)^K$

好了，终于搞好了……好累啊。

带入即可。
$$ans=\prod_{T=1}^n(\prod_{d|T}d^{\mu(\frac{T}{d})})^{n^K-(n-\frac{n}{T})^K}$$

然后预处理一下$\displaystyle\prod_{d|T}d^{\mu(\frac{T}{d})}$就可以啦！

哦，对了，指数上的$n^K$和另一个东西在$K$很大的时候记得优化哦，根据费马小定理，我们要求求出$n^K\mod998244352$，然后根据拓展欧拉定理搞一搞就可以把时间复杂度降下来了。

时间复杂度：$O(T\sqrt n\log k+n\log n)$

啥？你还不会做？赶紧去重新学习莫比乌斯反演吧。

其实题目还可以出得更难一点的，但是良心的出题人认为算了，就这样吧……
## 下面给出出题人设置每个数据点的意图
| 数据点 | 设置意图 |
| :----------: | :----------: |
| **0** | 会暴力 |
| **1** | 会普通的莫比乌斯反演，但不会容斥 |
| **2** | 同上，不过容斥学得稍微好点 |
| **3** | 我也不知道，不过也许…… |
| **4** | 想到了容斥但是不会快速处理$F(n,k)$的 |
| **5** | 能快速计算但是时间复杂度依赖$K$的 |
| **6** | 单次询问时间复杂度为$O(n\log k)$的 |
| **7** | 单词询问时间复杂度为$O(\sqrt n\log k)$的 |
| **8** | 能运用拓展欧拉定理优化$K$的 |
| **9** | 恭喜，您已做出此题。 |
# 彩蛋
为了防止被吊打，出题人特意准备了一个彩蛋。

这是蔡鸟Bird提出的做法，也就是考虑每一个质因数的贡献，同样也是大多数人选择的做法。

跟上面的做法差不多。

其实考虑$F(T)=\prod_{d|T}d^{\mu(T/d)}$，若T是某一个质数$p$的若干次方，那么$F(T)=p$，否则$F(T)=1$，其实也是在计算质数的贡献。

这样子可以做到$O(n+T\sqrt n\log k)$

啥？你还能够吊打标算？那我认输了……

---

## 作者：VinstaG173 (赞：5)

有趣的数论题。讲讲赛时心路历程。

首先 $n$ 的范围不大，考虑枚举质数求其在答案中的幂次。显然题目所求可以转化为求

$$\prod_{p \in prime,1 \le p \le n}p^{\sum_{i_1=1}^{n}\sum_{i_2=1}^{n}\cdots\sum_{i_k=1}^{n}\max\{V_p(i_1),V_p(i_2),\dots,V_p(i_k)\}}$$

考虑求 $\sum_{i_1=1}^{n}\sum_{i_2=1}^{n}\cdots\sum_{i_k=1}^{n}\max\{V_p(i_1),V_p(i_2),\dots,V_p(i_k)\}$。枚举 $t$，考虑计算 $\max\{V_p(i_1),V_p(i_2),\dots,V_p(i_k)\}=t$ 的 $k$ 元组数。显然有 $\left(n-\left\lfloor\dfrac{n}{p^t}\right\rfloor\right)^k$ 个 $k$ 元组满足 $\max\{V_p(i_1),V_p(i_2),\dots,V_p(i_k)\}<t$，因此我们直接差分就好了。由于两重指数的存在，我们要用扩展欧拉定理处理 $k$。

但是这样做单次询问是 $O(n\log{mod})$ 的，会 T，只有 $40$ 分。因此我们想到对于 $>\sqrt{n}$ 的质数 $p$，答案只和 $\left\lfloor\dfrac{n}{p}\right\rfloor$ 有关，所以我们可以分段，对于 $\le \sqrt{n}$ 的质数暴力，对于 $>\sqrt{n}$ 的质数整除分块。在整除分块过程中，由于质数分布不会太稀疏，所以可以直接暴力跳质数（其实好像对非质数也求出前缀积也行）。

时间复杂度 $O(n+T\sqrt{n}\log{mod})$。

~~连莫比乌斯反常都不用的小清新数论题，为凉心出题人点赞！!1~~

Code:
```cpp
#include<cstdio>
#include<cstring>
#define ll long long
const int ntf=998244353;
const int NtF=ntf-1;
const int NTF=3<<27;
inline ll qpw(ll x,ll v,int Ntf)
{
    ll r=1;
    while(v)
    {
        (v&1)&&(r=r*x%Ntf);
        x=x*x%Ntf,v>>=1;
    }
    return r;
}
int lk;
ll vlk;
char k[103];
ll ps[1000003];
int mp[1000003];
int pr[1000003],cnt;
inline void init()
{
    ps[0]=1;
    for(int i=2;i<=1e6;++i)
    {
        if(!mp[i])pr[mp[i]=++cnt]=i,ps[cnt]=ps[cnt-1]*i%ntf;
        for(int j=1;j<=mp[i]&&i*pr[j]<=1e6;++j)mp[i*pr[j]]=j;
    }
}
inline ll solve(ll n)
{
    ll ans=1;int i;
    for(i=1;i<=cnt&&pr[i]*pr[i]<=n;++i)
    {
        ll t,vt=pr[i],p=pr[i],ts=0,pe=0,ps=0;
        for(t=0;vt<=n;++t,vt*=p)
        {
            pe=ps,ps=qpw(n-n/vt,vlk,NtF);
            ts=(ts+(ps-pe)*t%NtF+NtF)%NtF;
        }
        pe=ps,ps=qpw(n,vlk,NtF);
        ts=(ts+(ps-pe)*t%NtF+NtF)%NtF;
        ans=(ans*qpw(p,ts,ntf))%ntf;
    }
    for(int j;i<=cnt&&pr[i]<=n;i=j+1)
    {
        j=n/(n/pr[i]);
        while(pr[mp[j]]!=j)--j;
        j=mp[j];
        ll ts=((qpw(n,vlk,NtF)-qpw(n-n/pr[i],vlk,NtF))+NtF)%NtF;
        ans=ans*qpw(ps[j]*qpw(ps[i-1],NtF-1,ntf)%ntf,ts,ntf)%ntf;
    }
    return ans;
}
int t,n;
int main()
{
    scanf(" %d",&t);init();
    while(t--)
    {
        scanf(" %d %s",&n,k);
        lk=strlen(k);vlk=0;
        for(int i=0;i<lk;++i)vlk=(vlk*10+k[i]-'0')%NTF;
        if(lk>8)vlk+=NTF;
        printf("%lld\n",solve(n));
    }
    return 0;
}
```

---

## 作者：Corzica (赞：2)

枚举每一个形如 $p^q$ 的数，如果一个 lcm 里面没有这个数的话，说明这 $k$ 个数内没有一个是 $p^q$ 的倍数，方案数就是 $(n-n/p^q)^k$，对答案的贡献就是反过来的，$(n^k-(n-n/p^q)^k)\times p$。

这个时候我们可以枚举每一个数然后计算快速幂求解了，用扩展欧拉定理降一下幂，时间复杂度是 $O(Tn\log mod)$。虽然远远跑不到就是了。

事实上，这个形式看着就非常的整除分块，直接上一个整除分块上去就好了。复杂度就是 $O(t\sqrt{n}\log mod)$。

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int t, n, m, b[1000006], prime[1000006], f[1000006], cnt;
string s;
const int mod = 998244353;
inline int ksm(int p, int q, int mod = 998244353) {
	int base = 1;
	while (q) {
		if (q & 1) base = base * p % mod;
		q >>= 1;
		p = p * p % mod;
	}
	return base;
}
signed main() {
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	for (int i = 2; i <= 1000000; i++) {
		if (!b[i]) {
			prime[++cnt] = i;
			f[i] = i;
		}
		for (int j = 1; j <= cnt && i * prime[j] <= 1000000; j++) {
			b[i * prime[j]] = 1;
			if (!(i % prime[j])) {
				f[i * prime[j]] = f[i];
				break;
			}
		}
	}
	f[0] = 1;
	for (int i = 1; i <= 1000000; i++) {
		if (!f[i]) f[i] = 1;
	}
	for (int i = 2; i <= 1000000; i++) {
		f[i] = (f[i] * f[i - 1]) % mod;
	}
	cin >> t;
	while (t--) {
		cin >> n >> s;
		m = 0;
		for (int i = 0; i < s.size(); i++) {
			m = m * 10 + s[i] - '0';
			if (m >= 402653184) m = m % 402653184 + 402653184;
		}
		int ans = 1, all = ksm(n, m, mod - 1 );
		for (int l = 1, r; l <= n; l = r + 1) {
			r = (n / (n / l));
			if (f[r] != f[l - 1]) {
				ans *= ksm((f[r] * ksm( f[l - 1], mod - 2)) % mod, (all - ksm(n - n / l, m, mod - 1) + (mod - 1)) % (mod - 1));
				ans %= mod;
			}
		}
		cout << ans << "\n";
	}
}
```

---

## 作者：tzc_wk (赞：2)

[洛谷题面传送门](https://www.luogu.com.cn/problem/P7360)

hot tea.

首先注意到这个 $\text{lcm}$ 特别棘手，并且这里的 $k$ 大得离谱，我们也没办法直接枚举每个质因子的贡献来计算答案。不过考虑到如果我们把这里的 $\text{lcm}$ 改为 $\gcd$ 那么一遍莫比乌斯反演即可搞定，因此考虑将这里的 $\text{lcm}$ 与 $\gcd$ 联系在一起。那么什么能将这两个东西联系在一起呢？Min-Max 容斥，具体来说，考虑式子
$$
\text{lcm}(S)=\prod\limits_{\varnothing\ne T\subseteq S}\gcd(T)^{(-1)^{|T|-1}}
$$
因此我们考虑开始推式子：
$$
\begin{aligned}
res&=\prod\limits_{i_1,i_2,\cdots,i_k}\text{lcm}(i_1,i_2,\cdots,i_k)\\
&=\prod\limits_{i_1,i_2,\cdots,i_k}\prod\limits_{S\subseteq\{1,2,3,\cdots,k\}}\gcd(\{i_x|x\in S\})^{(-1)^{|S|-1}}\\
&=\prod\limits_{j=1}^k\prod\limits_{|S|=j,S\subseteq\{1,2,3,\cdots,k\}}\prod\limits_{i_1,i_2,\cdots,i_k}\gcd(\{i_x|x\in S\})^{(-1)^{j-1}}\\
&=\prod\limits_{j=1}^k\prod\limits_{i_1,i_2,\cdots,i_j}\gcd(i_1,i_2,\cdots,i_j)^{(-1)^{j-1}·\dbinom{k}{j}·n^{k-j}}\\
&=\prod\limits_{j=1}^k\prod\limits_{d=1}^nd^{(-1)^{j-1}·\dbinom{k}{j}·n^{k-j}·\sum\limits_{i_1,i_2,\cdots,i_j}[\gcd(i_1,i_2,\cdots,i_j)=d]}\\
&=\prod\limits_{j=1}^k\prod\limits_{d=1}^nd^{(-1)^{j-1}·\dbinom{k}{j}·n^{k-j}·\sum\limits_{p=1}^{n/d}\mu(p)\lfloor\dfrac{n}{dp}\rfloor^j}\\
&=\prod\limits_{d=1}^n\prod\limits_{p=1}^n(d^{\mu(p)})^{\sum\limits_{j=1}^k(-1)^{j-1}·n^{k-j}·\lfloor\dfrac{n}{dp}\rfloor^j}\\
&=\dfrac{1}{\prod\limits_{d=1}^n\prod\limits_{p=1}^n(d^{\mu(p)})^{\sum\limits_{j=1}^k(-1)^{j}·n^{k-j}·\lfloor\dfrac{n}{dp}\rfloor^j}}\\
&=\dfrac{1}{\prod\limits_{d=1}^n\prod\limits_{p=1}^n(d^{\mu(p)})^{\sum\limits_{j=0}^k(-1)^{j}·n^{k-j}·\lfloor\dfrac{n}{dp}\rfloor^j-n^k}}\\
&=\dfrac{1}{\prod\limits_{d=1}^n\prod\limits_{p=1}^n(d^{\mu(p)})^{(n-\lfloor\dfrac{n}{dp}\rfloor)^k-n^k}}\\
&=\dfrac{1}{\prod\limits_{T=dp}f(T)^{(n-\lfloor\dfrac{n}{T}\rfloor)^k-n^k}}
\end{aligned}
$$
其中 $f(T)=\prod\limits_{dp=T}d^{\mu(p)}$。

整除分块求解即可，注意，根据费马小定理，指数上那托东西要 $\bmod 998244352$，而由于指数上面还套了一个快速幂，且这里的 $k$ 很大，因此需要欧拉降幂，具体来说如果 $k\le\varphi(998244352)$ 那么直接算即可，否则需令 $k\leftarrow k\bmod\varphi(998244352)+\varphi(998244352)$

时间复杂度 $T\sqrt{n}\log n$

```cpp
const int MAXN=1e6;
const int MAXLEN=100;
const int MOD=998244353;
const int PHI=MOD-1;
const int PPHI=402653184;
int getmod(ll x){return (x>PPHI)?(x%PPHI+PPHI):x;}
int pr[MAXN+5],prcnt=0,mu[MAXN+5],prd[MAXN+5];
bool vis[MAXN+5];
int qpow(int x,int e){
	if(e<0) e+=PHI;int ret=1;
	for(;e;e>>=1,x=1ll*x*x%MOD) if(e&1) ret=1ll*ret*x%MOD;
	return ret;
}
int _qpow(int x,int e){
	int ret=1;
	for(;e;e>>=1,x=1ll*x*x%PHI) if(e&1) ret=1ll*ret*x%PHI;
	return ret;
}
void sieve(int n){
	mu[1]=1;
	for(int i=2;i<=n;i++){
		if(!vis[i]) mu[i]=-1,pr[++prcnt]=i;
		for(int j=1;j<=prcnt&&pr[j]*i<=n;j++){
			vis[pr[j]*i]=1;if(i%pr[j]==0) break;
			mu[pr[j]*i]=-mu[i];
		}
	}
	for(int i=1;i<=n;i++) prd[i]=1;
	for(int i=1;i<=n;i++) for(int j=1;j*i<=n;j++)
		prd[i*j]=1ll*prd[i*j]*qpow(i,mu[j])%MOD;
//	for(int i=1;i<=n;i++) printf("%d\n",prd[i]);
	prd[0]=1;
	for(int i=1;i<=n;i++) prd[i]=1ll*prd[i-1]*prd[i]%MOD;
}
int n;ll k;
char buf[MAXLEN+5];
void solve(){
	scanf("%d%s",&n,buf+1);k=0;int len=strlen(buf+1);
	for(int i=1;i<=len;i++) k=getmod(10ll*k+buf[i]-'0');
	int res=1;
	for(int l=1,r;l<=n;l=r+1){
		r=(n/(n/l));
		res=1ll*res*qpow(1ll*prd[r]*qpow(prd[l-1],MOD-2)%MOD,(_qpow(-n/l+n,k)-_qpow(n,k)+PHI)%PHI)%MOD;
	} printf("%d\n",qpow(res,MOD-2));
}
int main(){
	int qu;scanf("%d",&qu);sieve(MAXN);
	while(qu--) solve();
	return 0;
}
```



---

## 作者：derta (赞：0)

可以得到答案即为

$$\prod_{p \in \mathbf{Prime}}^{N}p^{f_1(p)+f_2(p)+\cdots+f_{\lfloor \log_pN\rfloor}(p)}$$

其中 $f_i(p)$ 表示满足 $p^i\mid\operatorname{lcm}(i_1,i_2,\cdots,i_K)$ 的 $K$ 元组个数

原因是若 $p^i\parallel\operatorname{lcm}(i_1,i_2,\cdots,i_K)$，那么其贡献为 $p^i$，而 $f_1(p),f_2(p),\cdots,f_i(p)$ 各贡献了 $1$ 个 $p$，恰好相同

考虑计算 $f_i(p)$，反选即可。发现满足 $p^i\nmid \operatorname{lcm}(i_1,i_2,\cdots,i_K)$ 的 $K$ 元组个数为 $(N-\lfloor\dfrac{N}{p^i}\rfloor)^K$ 个，故

$$f_i(p)=N^K-(N-\lfloor\dfrac{N}{p^i}\rfloor)^K$$

所以原式等于

$$\prod_{i=1}^{\lfloor\log_2N\rfloor}\prod_{p \in \mathbf{Prime}}^{\lfloor\sqrt[i]N\rfloor}p^{N^K-(N-\lfloor\frac{N}{p^i}\rfloor)^K}$$

后面的 $\Pi$ 是可以整除分块的，$K$ 使用扩展欧拉降幂定理来处理即可

整除分块只需预处理 $\textit{pre}_i$ 为小于等于 $i$ 的所有质数的乘积即可

注意，在整除分块底数为 $1$ 时直接跳过，否则会 TLE

另外在使用扩展欧拉降幂定理时需注意是否会溢出

代码挺好写的，不放了

---


# 「Stoi2031」彩虹

## 题目背景

> 你要离开 我知道很简单 你说依赖 是我们的阻碍 就算放开 但能不能别没收我的爱 就当我最后才明白 ——《彩虹》

## 题目描述

虹是一个喜欢幻想的女孩子。她认为两个正整数 $i,j$ 的 **依赖值** 为 $\operatorname{lcm}(i,j)^{\operatorname{lcm}(i,j)}$。她定义所有满足 $l \le i \le r,l \le j \le r$ 的 $i,j$ 的 **依赖值** 之积为两个正整数 $l,r$ 的 **阻碍值**。现在她给了你一个正整数 $n$，并 $t$ 次询问你两个满足 $1 \le l \le r \le n$ 的正整数 $l,r$ 的 **阻碍值** $ans\bmod{32465177}$。

## 说明/提示

#### 简述版题意：

给定 $l,r$，求 $\prod\limits_{i=l}^{r}\prod\limits_{j=l}^{r}\operatorname{lcm}(i,j)^{\operatorname{lcm}(i,j)} \bmod{32465177}$。多次询问。

#### 样例解释：

对于第 $1$ 次询问，$ans=1^1 \times (2^2)^3 \times (3^3)^3 \times (6^6)^2$，$ans \bmod{32465177}=21072733$；

对于第 $2$ 次询问，$ans=2^2 \times 3^3 \times (6^6)^2$，$ans \bmod{32465177}=12145631$；

对于第 $3$ 次询问，$ans=7^7=823543$。

#### 数据范围：

对于 $30\%$ 的数据，$1 \le n \le 10^3,t=1$；

对于 $60\%$ 的数据，$1 \le n \le 10^5,t=1$；

对于 $100\%$ 的数据，$1 \le n \le 10^6,1 \le t \le 10,1 \le l_i \le r_i \le n$。

## 样例 #1

### 输入

```
3 7
1 3
2 3
7 7
```

### 输出

```
21072733
12145631
823543
```

# 题解

## 作者：orz_z (赞：12)

### [P7486 「Stoi2031」彩虹](https://www.luogu.com.cn/problem/P7486)

令 $S(a,b)=\prod\limits_{i=1}^{a}\prod\limits_{j=1}^{b}\operatorname{lcm}(a,b)^{\operatorname{lcm}(a,b)}$。

求：
$$
\frac{S(r,r)\times S(l-1,l-1)}{S(r,l-1)\times S(l-1,r)}
$$
不妨设 $a \leq b$。

令 $dp=t$，则有：
$$
\begin{aligned}
S(a,b)&=\prod\limits_{i=1}^{a}\prod\limits_{j=1}^{b}\operatorname{lcm}(a,b)^{\operatorname{lcm}(a,b)}\\
&=\prod_{i=1}^{a}\prod_{j=1}^{b}\frac{ij}{\gcd(a,b)}^{(\frac{ij}{\gcd(a,b)})}\\
&=\prod_{d=1}^{a}\prod_{i=1}^{a}\prod_{j=1}^{b}\frac{ij}{d}^{(\frac{ij}{d})[\gcd(i,j)=d]}\\
&=\prod_{d=1}^{a}\prod_{i=1}^{\lfloor\frac{a}{d}\rfloor}\prod_{j=1}^{\lfloor\frac{b}{d}\rfloor}(ijd)^{ijd[\gcd(i,j)=1]}\\
&=\prod_{d=1}^{a}\prod_{i=1}^{\lfloor\frac{a}{d}\rfloor}\prod_{j=1}^{\lfloor\frac{b}{d}\rfloor}(ijd)^{ijd\sum\limits_{p=1}^{\lfloor\frac{a}{d}\rfloor}\mu(p)[p|i][p|j]}\\
&=\prod_{d=1}^{a}\prod_{p=1}^{\lfloor\frac{a}{d}\rfloor}\prod_{i=1}^{\lfloor\frac{a}{d}\rfloor}[p|i]\prod_{j=1}^{\lfloor\frac{b}{d}\rfloor}[p|j](ijd)^{ijd\mu(p)}\\
&=\prod_{d=1}^{a}\prod_{p=1}^{\lfloor\frac{a}{d}\rfloor}\prod_{i=1}^{\lfloor\frac{a}{dp}\rfloor}\prod_{j=1}^{\lfloor\frac{b}{dp}\rfloor}(ijdp^2)^{ijdp^2\mu(p)}\\
&=\prod_{t=1}^{a}\prod_{p|t}\prod_{i=1}^{\lfloor\frac{a}{t}\rfloor}\prod_{j=1}^{\lfloor\frac{b}{t}\rfloor}(ijtp)^{ijtp\mu(p)}\\
\end{aligned}
$$
令 $s(x)=\sum\limits_{i=1}^{x}i=\frac{x(x+1)}{2}$，$f(x)=\prod\limits_{i=1}^{x}i^i$，则有：
$$
\prod_{i=1}^{n}\prod_{j=1}^{m}(ij)^{ij}=f(n)^{s(m)}\times f(m)^{s(n)}
$$
令其为 $G(n,m)$。

另有：
$$
\prod_{i=1}^{n}\prod_{j=1}^{m}(tp)^{ij}=(tp)^{s(n)\times S(m)}
$$
带回原式有：
$$
\prod_{t=1}^{a}\left( \prod_{p|t}\left( G(\lfloor\frac{a}{t}\rfloor,\lfloor\frac{b}{t}\rfloor) \times (tp)^{s(\lfloor\frac{a}{t}\rfloor)\times s(\lfloor\frac{b}{t}\rfloor)} \right)^{p\mu(p)} \right)^{t}
$$


另 $h(x)=\sum\limits_{d|x}d\mu(d),y(x)=\prod\limits_{d|x}d^{d\mu(d)}$，则有：
$$
\prod_{t=1}^{a}G(\lfloor\frac{a}{t}\rfloor,\lfloor\frac{b}{t}\rfloor)^{t \cdot h(t)}\times (t^{h(t)}\times y(t))^{t\times s(\lfloor\frac{a}{t}\rfloor)\times s(\lfloor\frac{b}{t}\rfloor)}
$$
再令 $hh(x)=x\times h(x),yy(x)=(x^{h(x)}\times y(x))^{x}$，可得：
$$
\prod_{t=1}^{a}G(\lfloor\frac{a}{t}\rfloor,\lfloor\frac{b}{t}\rfloor)^{hh(t)}\times yy(t)^{s(\lfloor\frac{a}{t}\rfloor)\times s(\lfloor\frac{b}{t}\rfloor)}
$$
最后前缀和 $\text{+}$ 前缀积 $\text{+}$ 数论分块即可。

再加一个小优化，设一个阈值 $S$，对于 $1 \leq t < S$ 的直接暴力算，因为这部分 $l,r$ 相差较小。

对于 $S \leq t \leq n$ 的，再数论分块算。

```cpp
#include <bits/stdc++.h>

using namespace std;

inline int read()
{
	int x = 0, f = 1;
	char c = getchar();
	while(c < '0' || c > '9')
	{
		if(c == '-') f = -1;
		c = getchar();
	}
	while(c >= '0' && c <= '9')
	{
		x = x * 10 + c - '0';
		c = getchar();
	}
	return x * f;
}

inline void write(int x)
{
	if(x < 0)
	{
		putchar('-');
		x = -x;
	}
	if(x > 9)
		write(x / 10);
	putchar(x % 10 + '0');
}

const int _ = 1e6 + 7, mod = 32465177;

bool vis[_];

int cnt, pr[_], mu[_], f[_], h[_], y[_];

int ksm(int x, int y)
{
	int res = 1;
	while(y)
	{
		if(y & 1) res = 1ll * res * x % mod;
		x = 1ll * x * x % mod;
		y >>= 1;
	}
	return res;
}

void init()
{
	mu[1] = 1;
	f[1] = 1;
	y[1] = 1;
	for(int i = 2; i <= _ - 7; ++i)
	{
		f[i] = 1ll * f[i - 1] * ksm(i, i) % mod;
		y[i] = 1;
		if(!vis[i])
		{
			pr[++cnt] = i;
			mu[i] = -1;
		}
		for(int j = 1; j <= cnt && i * pr[j] <= _ - 7; ++j)
		{
			int p = i * pr[j];
			vis[p] = 1;
			if(i % pr[j] == 0)
			{
				mu[p] = 0;
				break;
			}
			mu[p] = -mu[i];
		}
	}
	for(int i = 1; i <= _ - 7; ++i)
		for(int j = 1; i * j <= _ - 7; ++j)
		{
			h[i * j] = ((h[i * j] + mu[i] * i) % (mod - 1) + (mod - 1)) % (mod - 1);
			y[i * j] = 1ll * y[i * j] * ksm(i, i * mu[i] + mod - 1) % mod;
		}
	for(int i = 1; i <= _ - 7; ++i)
	{
		y[i] = ksm(1ll * ksm(i, h[i]) * y[i] % mod, i);
		h[i] = 1ll * h[i] * i % (mod - 1);
	}
	y[0] = 1;
	for(int i = 2; i <= _ - 7; ++i)
	{
		y[i] = 1ll * y[i - 1] * y[i] % mod;
		h[i] = (h[i] + h[i - 1]) % (mod - 1);
	}
}

int s(int x)
{
	return 1ll * x * (x + 1) / 2 % (mod - 1);
}

int g(int x, int y)
{
	return 1ll * ksm(f[x], s(y)) * ksm(f[y], s(x)) % mod;
}

int hh(int l, int r)
{
	return ((h[r] - h[l - 1]) % (mod - 1) + (mod - 1)) % (mod - 1);
}

int yy(int l, int r)
{
	return 1ll * y[r] * ksm(y[l - 1], mod - 2) % mod;
}

int S(int a, int b)
{
	if(a > b) swap(a, b);
	int res = 1;
	for(int i = 1, j; i <= a; i = j + 1)
	{
		j = min(a / (a / i), b / (b / i));
		res = 1ll * res * ksm(g(a / i, b / i), hh(i, j)) % mod * ksm(yy(i, j), 1ll * s(a / i) * s(b / i) % (mod - 1)) % mod; 
	}
	return res;
}

int solve(int l, int r)
{
	swap(l, r);
	int ans1 = 1ll * S(r, r) * S(l - 1, l - 1) % mod, ans2 = 1ll * S(r, l - 1) * S(l - 1, r) % mod;
	return 1ll * ans1 * ksm(ans2, mod - 2) % mod;
}

signed main()
{
	init();
	int t = read(), n = read();
	while(t--)
	{
		write(solve(read(), read()));
		putchar('\n');
	}
}
```



---

## 作者：_fairytale_ (赞：10)

题解区查询怎么都是根号 $\log$ 的？？？？

考虑取离散对数，求出模 $32465177$ 意义下的原根 $g=3$，同时把询问差分成四个前缀，问题变成求：

$$A=\sum_{i}\sum_{j}\text{lcm}(i,j)\log \text{lcm}(i,j)$$

然后 $g^A$ 即为答案。

随便推点式子（下取整省略不写）：

$$
\begin{aligned}
&\sum_i\sum_j\text{lcm}(i,j)\log \text{lcm}(i,j)\\
=&\sum_i\sum_j\dfrac{ij}{\gcd(i,j)}(\log i+\log j-\log \gcd(i,j))\\
=&\sum_d\sum_i\sum_j[d=\gcd(i,j)]\dfrac{ij}{d}(\log i+\log j-\log d)\\
=&\sum_d\sum_{i=1}^{\frac{l}{d}}\sum_{j=1}^{\frac{r}{d}}[\gcd(i,j)=1]ijd(\log id+\log jd-\log d)\\
=&\sum_d\sum_{i=1}^{\frac{l}{d}}\sum_{j=1}^{\frac{r}{d}}\sum_{e\mid \gcd(i,j)}\mu(e)ijd(\log id+\log jd-\log d)\\
=&\sum_dd\sum_e\mu(e)e^2\sum_{i=1}^{\frac{l}{de}}\sum_{j=1}^{\frac{r}{de}}ij(\log ide+\log jde-\log d)\\
=&\sum_{T=de}T\sum_{e\mid T}\mu(e)e\sum_i\sum_jij(\log iT+\log jT-\log d)
\end{aligned}
$$

只拿 $\log iT$ 一项的求和出来说，剩下同理。

跟 $e$ 有关的一项可以 $\mathcal O(n\ln n)$ 预处理成为 $F(T)$：

$$
\begin{aligned}
&\sum_TTF(T)\sum_i\sum_jij\log iT\\
=&\sum_TTF(T)\sum_i\sum_jij(\log i+\log T)\\
=&\sum_TTF(T)\sum_ii(\sum_jj\log i+\sum_j j\log T)\\
=&\sum_TTF(T)(\sum_j j)(\sum_ii\log i+\log T\sum_ii)\\
\end{aligned}
$$

然后这个式子就可以整除分块了，预处理 $TF(T),i\log i,\log T$ 的前缀和即可。

时间复杂度 $\mathcal O(mod+n\ln n+t\sqrt n)$。

第二项可以 dirichlet 前缀和做到 $\mathcal O(n\log\log n)$，懒得写了。

```cpp
#define mod 32465177
using mint = modint<mod-1>;
#define g 3
#define maxn 1001000
mint w[maxn];
int mu[maxn];
bool notprime[maxn];
int prime[maxn],cnt;
mint F[maxn],G[maxn],H[maxn],I[maxn],J[maxn];
void getprime(int n) {
	mu[1]=notprime[1]=1;
	for(int i=2; i<=n; ++i) {
		if(not notprime[i]) {
			prime[++cnt]=i;
			mu[i]=-1;
		}
		for(int j=1; j<=cnt&&prime[j]*i<=n; ++j) {
			notprime[i*prime[j]]=1;
			if(i%prime[j]==0) {
				mu[i*prime[j]]=0;
				break;
			}
			mu[i*prime[j]]=-mu[i];
		}
	}
	rep(i,1,n)mu[i]*=i;
	rep(i,1,n)for(int j=i; j<=n; j+=i)F[j]+=mu[i],G[j]+=w[j/i]*mu[i];
	rep(i,1,n)F[i]*=i; 
	rep(i,1,n)H[i]=H[i-1]+G[i]*i,I[i]=I[i-1]+F[i],J[i]=J[i-1]+F[i]*w[i];
}
int n;
int arr[maxn<<1],m;
int gt(int n) {
	int l=1,r;
	while(l<=n) {
		r=n/(n/l);
		arr[m++]=l;
		arr[m++]=r+1;
		l=r+1;
	}
	return m;
}
mint W[maxn],Pre[maxn];
mint calc(int l,int r) {
	mint res=0;
	m=0;
	int p=gt(l),q=gt(r);
	inplace_merge(arr,arr+p,arr+q);
	m=unique(arr,arr+m)-arr;
	rep(i,0,m-2) {
		int p=arr[i],q=arr[i+1]-1;
		int L=l/p,R=r/q;
		res-=(H[q]-H[p-1])*(1ll*L*(L+1)/2)*(1ll*R*(R+1)/2);
	}
	auto wrk=[&](int l,int r)->mint {
		mint res=0;
		m=0;
		int p=gt(l),q=gt(r);
		inplace_merge(arr,arr+p,arr+q);
		m=unique(arr,arr+m)-arr;
		rep(i,0,m-2) {
			int p=arr[i],q=arr[i+1]-1;
			int L=l/p,R=r/q;
			res+=(mint)(1ll*R*(R+1)/2)*(Pre[L]*(I[q]-I[p-1])+(J[q]-J[p-1])*(1ll*L*(L+1)/2));
		}
		return res;
	};
	if(l!=r)res+=wrk(l,r)+wrk(r,l);
	else res+=wrk(l,r)*2;
	return res;
}
void solve() {
	int l,r;
	cin>>l>>r;
	cout<<qp(g,(calc(r,r)-calc(l-1,r)-calc(r,l-1)+calc(l-1,l-1)).val)<<'\n';
}
bool Med;
signed main() {
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	int t;
	cin>>t>>n;
	for(int i=0,nw=1; i<mod-1; ++i,nw=1ll*nw*g%mod)if(nw<=n)w[nw]=i;
	rep(i,1,n)W[i]=W[i-1]+w[i];
	rep(i,1,n)Pre[i]=Pre[i-1]+w[i]*i; 
	getprime(n);
	while(t--)solve();
	return 0;
}
```

---

## 作者：hzlqwq (赞：9)

推式子毕业题，所有过程已经尽可能详细列出，萌新也能看懂！

---

首先，根据二维前缀积，我们有：

$$
\large ans=\frac{cal(r,r)cal(l-1,l-1)}{cal(l-1,r)^2}
$$

现在，我们来化简 $cal$：

$$
\large \begin{array}{l}
cal(n,m)&=& \displaystyle \prod_{i=1}^n \prod_{j=1}^m \mathrm{lcm}(i,j)^{\mathrm{lcm}(i,j)}\\
&=&\displaystyle \prod_{i=1}^n \prod_{j=1}^m \left(\frac{ij}{\gcd(i,j)}\right)^{\frac{ij}{\gcd(i,j)}}\\
&=&\displaystyle \prod_{d=1}^n \prod_{i=1}^n \prod_{j=1}^m \left(\frac{ij}{d}\right)^{\frac{ij}{d}[\gcd(i,j)=d]}\\
\end{array}
$$

根据经典套路，将 $\gcd=d$ 化为 $\gcd =1$，此时 $i,j$ 的含义发生改变，由原数变为倍数：

$$
\large =\displaystyle \prod_{d=1}^n \prod_{i=1}^{\frac{n}{d}} \prod_{j=1}^{\frac{m}{d}} (ijd)^{ijd[\gcd(i,j)=1]}
$$

注意到经典形式，套用[莫比乌斯反演](https://oi-wiki.org/math/number-theory/mobius/)：

$$
\large \begin{array}{l}
&=&\displaystyle \prod_{d=1}^n \prod_{i=1}^{\frac{n}{d}} \prod_{j=1}^{\frac{m}{d}} \prod_{x\mid i,j} (ijd)^{ijd\mu(x)}\\
&=&\displaystyle \prod_{d=1}^n \prod_{x=1}^{\frac{n}{d}}\prod_{i=1}^{\frac{n}{d}} \prod_{j=1}^{\frac{m}{d}} (ijd)^{ijd\mu(x)[x\mid i][x\mid j]}\\
\end{array}
$$

枚举 $i,j$ 是 $x$ 的几倍，此时 $i,j$ 的含义再次发生变化，注意不要混淆：

$$
\large =\displaystyle \prod_{d=1}^n \prod_{x=1}^{\frac{n}{d}}\prod_{i=1}^{\frac{n}{dx}} \prod_{j=1}^{\frac{m}{dx}} (ijdx^2)^{ijdx^2\mu(x)}
$$

现在已经难以对后面的那一坨东西进行化简；注意到出现 $\frac{n}{dx},\frac{m}{dx}$，我们有经典套路：令 $T=dx$，然后枚举 $T$ 的因数 $x$：

$$
\large \begin{array}{l}
&=&\displaystyle \prod_{T=1}^n \prod_{x\mid T} \prod_{i=1}^{\frac{n}{T}} \prod_{j=1}^{\frac{m}{T}} (ijTx)^{ijTx\mu(x)}\\
&=&\displaystyle \prod_{T=1}^n \prod_{x\mid T} \left(\prod_{i=1}^{\frac{n}{T}} \prod_{j=1}^{\frac{m}{T}} (ij)^{ij}(Tx)^{ij}\right)^{Tx\mu(x)}\\
\end{array}
$$

此时，出现了一个子问题：$\prod_{i=1}^{n} \prod_{j=1}^{m} (ij)^{ij}$，我们先来解决它：

$$
\large \begin{array}{l}
a(n,m) &=& \displaystyle \prod_{i=1}^n\prod_{j=1}^m (ij)^{ij}\\
&=& \displaystyle \prod_{i=1}^n\prod_{j=1}^m i^{ij} \prod_{i=1}^n\prod_{j=1}^m j^{ij}\\
&=& \displaystyle \prod_{i=1}^n i^{i\sum_{j=1}^m j} \prod_{j=1}^m j^{j\sum_{i=1}^n i}\\
&=& \displaystyle \left(\prod_{i=1}^n i^i\right)^{\frac{m(m+1)}{2}} \left(\prod_{j=1}^m j^j\right)^{\frac{n(n+1)}{2}} 
\end{array}
$$

若令：

$$
\large b(n)=\prod_{i=1}^n i^i,\ c(n)=\frac{n(n+1)}{2}
$$

则：

$$
\large a(n,m)=b(n)^{c(m)}b(m)^{c(n)}
$$

因为 $b,c$ 都可以在线性（乘对数）时间内预处理出来，所以 $a$ 的询问是对数时间的。接下来，利用 $a,b,c$ 化简原式：

$$
\large cal(n,m) =\displaystyle \prod_{T=1}^n \prod_{x\mid T} \left(a\left(\frac{n}{T},\frac{m}{T}\right)(Tx)^{c(\frac{n}{T})c(\frac{m}{T})}\right)^{Tx\mu(x)}
$$

把 $a(\frac{n}{T},\frac{m}{T})$ 与 $Tx$ 分离开来，注意整体的乘相当于指数的加：

$$
\large =\displaystyle \prod_{T=1}^n a\left(\frac{n}{T},\frac{m}{T}\right)^{T\sum_{x\mid T} x\mu(x)} \left(\prod_{x\mid T}(Tx)^{x\mu(x)}\right)^{c(\frac{n}{T})c(\frac{m}{T})T}
$$

再用类似的方法，把 $T$ 和 $x$ 分离开来：

$$
\large =\displaystyle \prod_{T=1}^n a\left(\frac{n}{T},\frac{m}{T}\right)^{T\sum_{x\mid T} x\mu(x)} \left(T^{\sum_{x\mid T}x\mu(x)}\prod_{x\mid T}x^{x\mu(x)}\right)^{c(\frac{n}{T})c(\frac{m}{T})T}
$$

此时，注意到式子中有一些经典的、重复的东西出现，我们定义函数以化简：

$$
\large d(n)=\sum_{x\mid n} x\mu(x),\ e(n)=\prod_{x\mid n}x^{x\mu(x)}
$$

（$d,e$ 均可在线性乘对数时间内预处理出来，枚举 $x$ 的倍数即可，具体见代码）

带入原式得：

$$
\large cal(n,m) =\displaystyle \prod_{T=1}^n a\left(\frac{n}{T},\frac{m}{T}\right)^{Td(T)}\left(T^{d(T)}e(T)\right)^{c(\frac{n}{T})c(\frac{m}{T})T}
$$

看起来有点乱，定义函数，合并一些东西，整理一下：

$$
\large f(n)=nd(n),\ g(n)=\left(n^{d(n)}e(n)\right)^n
$$

则：

$$
\large cal(n,m)=\prod_{T=1}^n a\left(\frac{n}{T},\frac{m}{T}\right)^{f(T)}g(T)^{c(\frac{n}{T})c(\frac{m}{T})}
$$

由于 $d,e$ 都能预处理，所以 $f,g$ 也能很快地处理出来，再加上上式可以[整除分块](https://oi-wiki.org/math/number-theory/sqrt-decomposition/)，这题就做完咯！！

实现时，我们需要原数组 $b,c,d,e$，函数 $a$，前缀和数组 $f$，前缀积数组 $g$，前缀逆元积数组 $gg$（便于整除分块）；

其中 $c,d,f$ 保留真值（因为位于指数），其他可取模，即可 $O(n\log nP)$ 预处理，$O(\sqrt{n}\log n)$ 查询。

记得在必要的地方开 __int128！

```cpp
#define int long long

using namespace std;

const int N = 1e6 + 5, mod = 32465177;

int t, n, l, r;
int p[N], mob[N], tmp1[N], tmp2[N], b[N], c[N], d[N], e[N], f[N], g[N], gg[N];
bool st[N];

inline int qpow(int x, __int128 k)
{
    if (k < 0)
        k *= 2 - mod; // 注意负指数数的处理
    int res = 1;
    while (k)
    {
        if (k & 1)
            (res *= x) %= mod;
        (x *= x) %= mod, k >>= 1;
    }
    return res;
}

inline void init()
{
	// 线性筛预处理莫比乌斯函数
    mob[1] = 1;
    for (int i = 2; i <= n; i++)
    {
        if (!st[i])
            p[++p[0]] = i, mob[i] = -1;
        for (int j = 1; i * p[j] <= n; j++)
        {
            st[i * p[j]] = 1;
            if (i % p[j])
                mob[i * p[j]] = -mob[i];
            else
            {
                mob[i * p[j]] = 0;
                break;
            }
        }
    }
    b[0] = g[0] = gg[0] = 1;
    // 暴力预处理 b,c，同时存下 tmp1,tmp2 为后面的预处理做准备
    for (int i = 1; i <= n; i++)
        tmp1[i] = qpow(i, i), tmp2[i] = qpow(tmp1[i], -1), b[i] = b[i - 1] * tmp1[i] % mod, c[i] = i * (i + 1) / 2,
        e[i] = 1;
    // 预处理 d,e，e 可以分讨
    for (int i = 1; i <= n; i++)
        for (int j = 1; i * j <= n; j++)
        {
            d[i * j] += i * mob[i];
            if (mob[i] > 0)
                (e[i * j] *= tmp1[i]) %= mod;
            else if (mob[i] < 0)
                (e[i * j] *= tmp2[i]) %= mod;
        }
    // 预处理 f,g
    for (int i = 1; i <= n; i++)
        f[i] = f[i - 1] + i * d[i], g[i] = g[i - 1] * qpow(qpow(i, d[i]) * e[i] % mod, i) % mod, gg[i] = qpow(g[i], -1);
}

inline int a(int n, int m)
{
    return qpow(b[n], c[m]) * qpow(b[m], c[n]) % mod;
}

inline int cal(int n, int m)
{
    int res = 1;
    // 整除分块
    for (int l = 1, r; l <= n; l = r + 1)
        r = min(n / (n / l), m / (m / l)),
        (res *= qpow(a(n / l, m / l), f[r] - f[l - 1]) * qpow(g[r] * gg[l - 1] % mod, (__int128)c[n / l] * c[m / l]) %
                mod) %= mod;
    return res;
}

signed main()
{
    ios::sync_with_stdio(0), cin.tie(0);
    cin >> t >> n, init();
    while (t--)
        cin >> l >> r, cout << cal(r, r) * cal(l - 1, l - 1) % mod * qpow(cal(l - 1, r), -2) % mod << "\n";
    return 0;
}
```

~~所以其实这题的 $t$ 是可以开到 $1000$ 的，时限也可以开小一点~~

---

## 作者：Cute_Fish (赞：7)

自己推出来的莫反神题，写个题解记录一下。

## 题意

$T$ 组数据

对于每组数据求

$$\prod_{i=l}^r \prod_{j=l}^r \operatorname{lcm}(i,j)^{ \operatorname{lcm}(i,j)}$$

对 $32465177$ 后的值。


## 思路&代码

以下 $x/y$ 表示 $\lfloor \frac{x}{y}\rfloor$

首先写成二维前缀积的形式。

$$B(n,m)=\prod_{i=1}^n \prod_{j=1}^m  \operatorname{lcm}(i,j)^{ \operatorname{lcm}(i,j)}$$

答案可以写成 $\frac{B(r,r)B(l-1,l-1)}{B(l-1,r)B(r-1,l)}$。

拆成 $\gcd$ 式。

$$\prod_{i=1}^n \prod_{j=1}^m \frac{ij}{\gcd(i,j)}^{\frac{ij}{\gcd(i,j)}}$$

枚举 $\gcd$ 然后枚举 $d$ 的倍数，最后莫反可以得到。

$$\prod_{d=1}^{min(n,m)} \prod_{i=1}^{n/d} \prod_{j=1}^{m/d} {ijd}^{ijd\sum_{g|i,g|j}\mu(g)}$$


$$\prod_{d=1}^{min(n,m)} \prod_{g=1}^{min(n/d,m/d)} \prod_{i=1}^{n/dg} \prod_{j=1}^{m/dg} {ijdg^2}^{ijdg^2\mu(g)}$$

小技巧：

令 $T=dg$。

$$\prod_{T=1}^{min(n,m)} \prod_{g|T} \prod_{i=1}^{n/T} \prod_{j=1}^{m/T} ({ijTg}^{ij})^{Tg\mu(g)}$$

拆开计算。

$$\prod_{T=1}^{min(n,m)} \prod_{g|T} (\prod_{i=1}^{n/T} \prod_{j=1}^{m/T} {ij}^{ij} \prod_{i=1}^{n/T} \prod_{j=1}^{m/T} Tg^{ij})^{Tg\mu(g)}$$


令 

$$\operatorname{S}(x,y)=\prod_{i=1}^{x} \prod_{j=1}^{y} {ij}^{ij}$$


又令 

$$\operatorname{T}(x,y,T,g)=\prod_{i=1}^{x} \prod_{j=1}^{y} (Tg)^{ij}$$

$$\operatorname{S}(x,y)=\prod_{i=1}^{x} \prod_{j=1}^{y} {i}^{ij} \prod_{j=1}^{y} \prod_{i=1}^{x} j^{ij}$$



又又令 

$$\operatorname{f}(x)=\prod_{i=1}^x i^i,\operatorname{G}(x)= \sum_{i=1}^xi$$


则 

$$\operatorname{S}(x,y)=\operatorname{f}(x)^{ \operatorname{G}(y)} \operatorname{f}(y)^{ \operatorname{G}(x)}$$

又有 

$$\operatorname{T}(x,y,T,g)=(Tg)^{\operatorname{G}(x)\operatorname{G}(y)}$$

则原式又等于

$$\prod_{T=1}^{min(n,m)} \prod_{g|T} (\operatorname{S}(n/T,m/T)\operatorname{T}(n/T,m/T,T,g))^{Tg\mu(g)}$$

$$\prod_{T=1}^{min(n,m)} (\prod_{g|T} \operatorname{S}(n/T,m/T)^{g \mu(g)}\operatorname{T}(n/T,m/T,T,g)^{g \mu(g)})^T$$


$$\prod_{T=1}^{min(n,m)}  (\operatorname{S}(n/T,m/T)^{\sum_{g|T} g\mu(g)})^T( \prod_{g|T}\operatorname{T}(n/T,m/T,T,g)^{g \mu(g)})^T$$

$$\prod_{T=1}^{min(n,m)}  (\operatorname{S}(n/T,m/T)^{\sum_{g|T} g\mu(g)})^T T^{T\operatorname{G}(n/T)\operatorname{G}(m/T) \sum_{g|T} g\mu(g)}
(\prod_{g|T} g^{\operatorname{G}(n/T)\operatorname{G}(m/T)g \mu(g)})^T$$

令 $\operatorname{f_2}(T)=\sum_{d|T} d\mu(d)$

$$\prod_{T=1}^{min(n,m)}  (\operatorname{S}(n/T,m/T)^{ \operatorname{f_2}(T)})^T T^{T\operatorname{G}(n/T)\operatorname{G}(m/T) \operatorname{f_2}(T)}
(\prod_{g|T} g^{g \mu(g)})^{T\operatorname{G}(n/T)\operatorname{G}(m/T)}$$

又双叒叕令 $\operatorname{F}(T)=\prod_{g|T} g^{g\mu(g)}$

则原式最终简化为

$$\prod_{T=1}^{min(n,m)}  \operatorname{S}(n/T,m/T)^{\operatorname{f_2}(T)T} T^{T\operatorname{G}(n/T)\operatorname{G}(m/T) \operatorname{f_2}(T)}
\operatorname{F}(T)^{T\operatorname{G}(n/T)\operatorname{G}(m/T)}$$

令 $\operatorname{P}(T)=(T^{\operatorname{f_2}(T)} \operatorname{F}(T))^T,\operatorname{F_2}(T)=\operatorname{f_2}(T)T$。

则原式最终最终简化为：

$$\prod_{T=1}^{min(n,m)}  \operatorname{S}(n/T,m/T)^{\operatorname{F_2}(T)} \operatorname{P}(T)^{\operatorname{G}(n/T)\operatorname{G}(m/T)}$$



整理一下我们要预处理的函数。

$$\operatorname{f}(x)=\prod_{i=1}^x i^i,\operatorname{G}(x)= \sum_{i=1}^xi$$

$$\operatorname{f_2}(T)=\sum_{d|T} d\mu(d)$$

$$\operatorname{F}(T)=\prod_{g|T} g^{g\mu(g)}$$

$$\operatorname{P}(T)=(T^{ \operatorname{f_2}(T) } \operatorname{F}(T))^T$$

$$\operatorname{F_2}(T)=\operatorname{f_2}(T)T$$

然后就做完了，$\operatorname{f_2},\operatorname{F}$ 都可以直接 $O(n\log n)$ 预处理。

时间复杂度 $O(n\log n+T\sqrt n)$。

[代码](https://loj.ac/s/2169661)

---

## 作者：Iniaugoty (赞：6)

Upd on 2025/7/24：发现本题存在一个预处理**严格线性**、查询根号的做法。这篇题解原本的做法是一年半前写的，比较差，就丢[剪贴板](/paste/lm9u78ra)了。

爆标了但是不能够跑到最优解，怎么会是呢？

是基于[这个](/article/qb2rd5bi)或[这个](/article/d40l8t75)的进一步优化，看过的可以跳过前半部分。

注意到 $P = 32465177$ 是质数，存在原根 $g = 3$，因此我们将原式对 $g$ 取离散对数，并且做一个差分，于是只需求出

$$F(x, y) = \sum _ {i = 1} ^ x \sum _ {j = 1} ^ y \operatorname{lcm}(i, j) \ln (\operatorname{lcm}(i, j))$$

则 $g ^ {F(r, r) - 2F(l - 1, r) + F(l - 1, l - 1)} \bmod P$ 即为答案。

进行一些套路性的转化和莫比乌斯反演，钦定 $x \le y$，

$$\begin {aligned}
F(x, y) & = \sum _ {i = 1} ^ x \sum _ {j = 1} ^ y \frac {ij} {\gcd (i, j)} \ln \left( \frac {ij} {\gcd (i, j)} \right) \\
& = \sum _ {d = 1} ^ {x} \sum _ {i = 1} ^ {\lfloor \frac x d \rfloor} \sum _ {j = 1} ^ {\lfloor \frac y d \rfloor} ijd \cdot \ln (ijd) [\gcd(i, j) = 1] \\
& = \sum _ {d = 1} ^ {x} \sum _ {e = 1} ^ {\lfloor \frac x d \rfloor} \sum _ {i = 1} ^ {\lfloor \frac x {de} \rfloor} \sum _ {j = 1} ^ {\lfloor \frac y {de} \rfloor} ijde^2 \cdot \ln (ijde^2) \mu(e) \\
\end {aligned}$$

设 $T = de$ 并枚举之，

$$F(x, y) = \sum _ {T = 1} ^ x T \sum _ {e \mid T} e \mu(e) \sum _ {i = 1} ^ {\lfloor \frac x T \rfloor} \sum _ {j = 1} ^ {\lfloor \frac y T \rfloor} ij \cdot \ln (ijeT)$$

$\ln (ijeT) = \ln i + \ln j + \ln e + \ln T$，我们将和式拆为四部分，前两部分本质相同。

设 $f(n) = \sum _ {d \mid n} d \mu(d)$，$g(n) = \sum _ {d \mid n} d \mu(d) \ln d$，

设 $S(n) = \sum _ {i = 1} ^ n i \ln i$，$T(n) = \sum _ {i = 1} ^ n = \frac {n(n + 1)} 2$，

$$\sum _ {T = 1} ^ x T \sum _ {e \mid T} e\mu(e) \sum _ {i = 1} ^ {\lfloor \frac x T \rfloor} \sum _ {j = 1} ^ {\lfloor \frac y T \rfloor} ij \ln i
= \sum _ {T = 1} ^ x T \cdot f(T) S(\lfloor \frac x T \rfloor) 
T(\lfloor \frac y T \rfloor)$$

$$\sum _ {T = 1} ^ x T \sum _ {e \mid T} e\mu(e) \sum _ {i = 1} ^ {\lfloor \frac x T \rfloor} \sum _ {j = 1} ^ {\lfloor \frac y T \rfloor} ij \ln T
= \sum _ {T = 1} ^ x T \cdot \ln T \cdot  f(T) T(\lfloor \frac x T \rfloor) T(\lfloor \frac y T \rfloor)$$

$$\sum _ {T = 1} ^ x T \sum _ {e \mid T} e\mu(e) \sum _ {i = 1} ^ {\lfloor \frac x T \rfloor} \sum _ {j = 1} ^ {\lfloor \frac y T \rfloor} ij \ln e
= \sum _ {T = 1} ^ x T \cdot g(T) T(\lfloor \frac x T \rfloor) T(\lfloor \frac y T \rfloor)$$

不难发现，只需预处理出 $n \cdot f(n), n \cdot \ln n \cdot f(n), n \cdot g(n)$ 的前缀和及 $S(n), T(n)$，每次询问便容易利用整除分块做到 $\mathcal O(\sqrt n)$。

而本质上要求的只是 $\ln n, f(n), g(n)$。

$\mathcal O(P)$ 求出 $\ln n$ 是简单的，$g ^ 0, g ^ 1, g ^ 2, \dots, g ^ {P - 2}$ 恰好取遍 $1, 2, 3, \dots, P - 1$。

问题是 $f(n)$ 和 $g(n)$，类似做法的题解瓶颈亦在于此。

首先求 $f(n) = \sum _ {d \mid n} d \mu(d)$ 不难。其形如一个积性函数的 Dirichlet 前缀和，显然也是一个积性函数，因此我们考虑其在质数幂处的取值。

设 $p$ 为质数，$\alpha > 0$，则 $f(p ^ \alpha) = \sum _ {i = 0} ^ \alpha p ^ i \mu (p ^ i)$，由于有个 $\mu$，当仅 $i < 2$ 时才有非 $0$ 取值，故 $f(p ^ \alpha) = 1 - p$。

考虑 $n$ 被其最小质因子 $p$ 筛到，若 $p \mid \frac n p $，则 $f(n) = f(\frac n p)$，否则 $f(n) = (1 - p) f(\frac n p)$。

这样便做到了线性筛 $f(n)$。

但是 $g(n) = \sum _ {d \mid n} d \mu(d) \ln d$ 并不具有积性，只能高维前缀和做到 $\mathcal O(n \log \log n)$，对吗对吗？

不对不对不对！

**仅有无平方因子的 $d$ 才会产生贡献**。设 $n$ 的质因数分解为 $p_1 ^ {\alpha_1} p_2 ^ {\alpha_2} \dots p_k ^ {\alpha_k}$，则这意味着 $d \mid p_1 p_2 \dots p_k$，也就是说 $f(n) = f(p_1 p_2 \dots p_k)$。

考虑将 $n$ 的某个质因子 $p$ 拆掉，讨论 $p \mid d$ 和 $p \nmid d$ 两种情况并求和，

$$\begin {aligned}
g(n) & = \sum _ {d \mid n} d \mu (d) \ln d \\
& = \sum _ {d \mid \frac n p} d \mu (d) \ln d + (d \cdot p) \mu (d \cdot p) \ln (d \cdot p) \\
& = \sum _ {d \mid \frac n p} d \mu (d) \ln d - (d \cdot p) \mu (d) \ln d - (d \cdot p) \mu(d) \ln p \\
& = \sum _ {d \mid \frac n p} (1 - p) \cdot d \mu (d) \ln d - p \ln p \cdot d \mu (d) \\
& = \left( (1 - p) \sum _ {d \mid \frac n p} d \mu (d) \ln d \right) - \left( p \ln p \sum _ {d \mid \frac n p} d \mu (d) \right) \\
& = (1 - p) g(\frac n p) - p \ln p \cdot f(\frac n p)
\end {aligned}$$

这显然可以愉快地线性筛！考虑 $n$ 被其最小质因子 $p$ 筛到，若 $p \mid \frac n p$，则 $g(n) = g(\frac n p)$，否则利用上式。

**综上，我们使用 $\mathcal O(P + n + T \sqrt n)$ 的时间复杂度解决了本题**。

实现的时候，注意求的其实是指数上的值，对 $P - 1$ 取模，其他没什么要注意的。

```cpp
#include <bits/stdc++.h>
typedef long long LL;
using namespace std;
const int N = 1e6 + 5;
const int P = 32465177;
const int M = P - 1, G = 3;

int qPow(int x, int y) {
  int res = 1;
  for (; y; x = 1ll * x * x % P, y >>= 1)
    if (y & 1) res = 1ll * res * x % P;
  return res;
}
int Add(int x, int y) { return x + y >= M ? x + y - M : x + y; }
int Sub(int x, int y) { return x - y < 0 ? x - y + M : x - y; }

int T, n;

int ln[N], f[N], g[N], pr[N], tot; bool vis[N];
int s[N], t[N], s1[N], s2[N], s3[N], s0[N];
void Init() {
  for (int i = 0, j = 1; i <= P - 2; ++i) {
    if (j <= n) ln[j] = i;
    j = 1ll * j * G % P;
  }
  f[1] = 1, g[1] = 0;
  for (int i = 2; i <= n; ++i) {
    if (!vis[i])
      pr[++tot] = i, f[i] = M + 1 - i,
      g[i] = 1ll * (M - i) * ln[i] % M;
    for (int j = 1; j <= tot && i * pr[j] <= n; ++j) {
      int u = i * pr[j]; vis[u] = 1;
      if (i % pr[j] == 0) { f[u] = f[i], g[u] = g[i]; break; }
      else
        f[u] = 1ll * (M + 1 - pr[j]) * f[i] % M,
        g[u] = Sub(1ll * (M + 1 - pr[j]) * g[i] % M,
                   1ll * pr[j] * ln[pr[j]] % M * f[i] % M);
    }
  }
  for (int i = 1; i <= n; ++i)
    s[i] = Add(s[i - 1], 1ll * i * ln[i] % M),
    t[i] = Add(t[i - 1], i),
    s1[i] = Add(s1[i - 1], 1ll * i * f[i] % M),
    s2[i] = Add(s2[i - 1], 1ll * i * ln[i] % M * f[i] % M),
    s3[i] = Add(s3[i - 1], 1ll * i * g[i] % M);
  for (int i = 1; i <= n; ++i)
    s0[i] = Add(s2[i], s3[i]);
}

int F(int x, int y) {
  if (!x || !y) return 0;
  int res = 0;
  for (int l = 1, r; l <= x; l = r + 1) {
    r = min(x / (x / l), y / (y / l));
    int u = 1ll * s[x / l] * t[y / l] % M;
    int v = 1ll * t[x / l] * s[y / l] % M;
    res = Add(res, 1ll * Sub(s1[r], s1[l - 1]) * Add(u, v) % M);
  }
  for (int l = 1, r; l <= x; l = r + 1) {
    r = min(x / (x / l), y / (y / l));
    int u = Sub(s0[r], s0[l - 1]);
    int v = 1ll * t[x / l] * t[y / l] % M;
    res = Add(res, 1ll * u * v % M);
  }
  return res;
}

int main() {
  ios::sync_with_stdio(0);
  cin.tie(0), cout.tie(0);
  cin >> T >> n, Init();
  while (T--) {
    int l, r; cin >> l >> r;
    int tmp = Add(F(r, r), F(l - 1, l - 1));
    tmp = Sub(tmp, 2ll * F(l - 1, r) % M);
    cout << qPow(G, tmp) << "\n";
  }
  return 0;
}
```

---

## 作者：CNS_5t0_0r2 (赞：4)

第一次写莫反黑题题解，还是很激动的 qwq。

读之前可以看一下我~~一直在拖更~~的[莫反学习笔记](https://www.luogu.com.cn/article/pd9101de)，其中有一些常用技巧。

第一步：看到求和/积的题目，既有上界又有下界想什么？

当然是想前缀和相减/前缀积相除啊！

（下文忽略取模的影响）

设 $S(n,m) = \prod \limits_{i = 1} ^ {n} \prod \limits_{j = 1} ^ {m} \operatorname{lcm}(i,j) ^ {\operatorname{lcm}(i,j)}$，则 $ans = \frac{S(r,r) \times S(l - 1,l - 1)}{S(r,l - 1) \times S(l - 1,r)} = \frac{S(r,r) \times S(l - 1,l - 1)}{S(r,l - 1) ^ 2}$。

所以接下来就是怎么求 $S(n,m)$ 的问题了（不妨设 $n \leq m$）。

看到 $\operatorname{lcm}$，想到什么？

当然是转成 $\gcd$ 啊！

于是式子变成了：

$$\prod \limits_{i = 1} ^ {n} \prod \limits_{j = 1} ^ {m} \left(\frac{ij}{\gcd(i,j)} \right) ^ {\frac{ij}{\gcd(i,j)}}$$

既然都转成 $\gcd$ 了，接下来的几步也是常规操作。

首先是枚举 $\gcd$ 的值（这里和加法不一样，$[]$ 要放在指数的位置）。

$$\prod \limits_{g = 1} ^ {n} \prod \limits_{i = 1} ^ {n} \prod \limits_{j = 1} ^ {m} \left(\frac{ij}{g} \right) ^ {\frac{ij}{g}[\gcd(i,j) = g]}$$

然后再把 $[\gcd(i,j) = g]$ 变成 $[\gcd(i,j) = 1]$。

$$\prod \limits_{g = 1} ^ {n} \prod \limits_{i = 1} ^ {\lfloor \frac{n}{g} \rfloor} \prod \limits_{j = 1} ^ {\lfloor \frac{m}{g} \rfloor} \left(gij \right) ^ {gij [\gcd(i,j) = 1]}$$

$[]$ 替换成 $\sum \mu()$ 也是常规操作。

$$\prod \limits_{g = 1} ^ {n} \prod \limits_{i = 1} ^ {\lfloor \frac{n}{g} \rfloor} \prod \limits_{j = 1} ^ {\lfloor \frac{m}{g} \rfloor} \left(gij \right) ^ {gij \sum \limits_{d | \gcd(i,j)} \mu(d)}$$

$d$ 在指数上不好处理，把它拿下来。

$$\prod \limits_{g = 1} ^ {n} \prod \limits_{i = 1} ^ {\lfloor \frac{n}{g} \rfloor} \prod \limits_{j = 1} ^ {\lfloor \frac{m}{g} \rfloor} \prod \limits_{d | \gcd(i,j)} \left(gij \right) ^ {gij \mu(d)}$$

再把 $d$ 提到 $i,j$ 的前面。

$$\prod \limits_{g = 1} ^ {n} \prod \limits_{d = 1} ^ {\lfloor \frac{n}{g} \rfloor} \prod \limits_{i = 1} ^ {\lfloor \frac{n}{dg} \rfloor} \prod \limits_{j = 1} ^ {\lfloor \frac{m}{dg} \rfloor} \left(d ^ 2 gij \right) ^ {d ^ 2gij  \mu(d)}$$

枚举两个因数太麻烦了，改成枚举两个因数的乘积 $T = dg$（注意这里不要像之前的我一样傻傻地以为第二层就应该枚举 $g$，因为把式子中的 $dg$ 替换掉后发现式子中只剩 $d$ 了）。

$$\prod \limits_{T = 1} ^ {n} \prod \limits_{d | T} \prod \limits_{i = 1} ^ {\lfloor \frac{n}{T} \rfloor} \prod \limits_{j = 1} ^ {\lfloor \frac{m}{T} \rfloor} \left(Tdij \right) ^ {Tdij  \mu(d)}$$

接下来的操作需要仔细理清指数的运算法则。

我们显然不能把 $T,d$ 和 $i,j$ 放在一起计算，先从指数入手把 $Td$ 和 $ij$ 拆开。

这步就不解释了。

$$\prod \limits_{T = 1} ^ {n} \prod \limits_{d | T} \left( \prod \limits_{i = 1} ^ {\lfloor \frac{n}{T} \rfloor} \prod \limits_{j = 1} ^ {\lfloor \frac{m}{T} \rfloor} \left(ij \right) ^ {ij} \prod \limits_{i = 1} ^ {\lfloor \frac{n}{T} \rfloor} \prod \limits_{j = 1} ^ {\lfloor \frac{m}{T} \rfloor} \left(Td \right) ^ {ij} \right) ^ {Td \mu(d)}$$

分别计算。

对于 $\prod \limits_{i = 1} ^ {\lfloor \frac{n}{T} \rfloor} \prod \limits_{j = 1} ^ {\lfloor \frac{m}{T} \rfloor} \left(ij \right) ^ {ij}$，我们记为 $h(\lfloor \frac{n}{T} \rfloor,\lfloor \frac{m}{T} \rfloor)$。

计算 $h(n,m)$ 的方法就是拆，以下是一种拆法。

先把 $h(n,m)$ 拆成 $\left( \prod \limits_{i = 1} ^ {n} \prod \limits_{j = 1} ^ {m} i ^ {ij} \right) \left( \prod \limits_{i = 1} ^ {n} \prod \limits_{j = 1} ^ {m} j ^ {ij} \right)$。

我们发现左半部分其实就是 $\left( \prod \limits_{i = 1} ^ {n}  i ^ {i \sum \limits_{j = 1} ^ m j} \right)$，即 $\left( \prod \limits_{i = 1} ^ {n}  i ^ {i} \right) ^ {\sum \limits_{j = 1} ^ m j}$；右半部分同理为 $\left( \prod \limits_{j = 1} ^ {m} j ^ {j} \right) ^ {\sum \limits_{i = 1} ^ n i}$。

因为两部分结构相似，所以我们设 $f(n) = \prod \limits_{i = 1} ^n i ^ i,g(n) = \sum \limits_{i = 1} ^ n i$，则 $h(n,m) = f(n) ^ {g(m)} f(m) ^ {g(n)}$。

$O(n \log n)$ 预处理 $f$，即可在单次对数的时间复杂度内求出 $h(n,m)$。

$\prod \limits_{i = 1} ^ {\lfloor \frac{n}{T} \rfloor} \prod \limits_{j = 1} ^ {\lfloor \frac{m}{T} \rfloor} \left(Td \right) ^ {ij}$ 相对好解决，其就为 $(Td) ^ {g(\lfloor \frac{n}{T} \rfloor) g(\lfloor \frac{m}{T} \rfloor)}$。记 $w(n,m) = g(n)g(m)$，其就等于 $(Td) ^ {w(n,m)}$。

此时的原式如下：

$$\prod \limits_{T = 1} ^ {n} \prod \limits_{d | T} \left( h(\lfloor \frac{n}{T} \rfloor,\lfloor \frac{m}{T} \rfloor)  \left(Td \right) ^ {w(\lfloor \frac{n}{T} \rfloor,\lfloor \frac{m}{T} \rfloor)} \right) ^ {Td \mu(d)}$$

$i,j$ 的问题解决了，接下来就要拆 $T$ 和 $d$ 了。

先拆指数。

$$\prod \limits_{T = 1} ^ {n} \left( \prod \limits_{d | T} \left( h(\lfloor \frac{n}{T} \rfloor,\lfloor \frac{m}{T} \rfloor)  \left(Td \right) ^ {w(\lfloor \frac{n}{T} \rfloor,\lfloor \frac{m}{T} \rfloor)} \right) ^ {d \mu(d)} \right) ^ {T}$$

把 $d \mu(d)$ 拿下来。

$$\prod \limits_{T = 1} ^ {n} \left( \prod \limits_{d | T} \left( h(\lfloor \frac{n}{T} \rfloor,\lfloor \frac{m}{T} \rfloor) ^ {d \mu(d)} \left((Td) ^ {d \mu(d)} \right) ^ {w(\lfloor \frac{n}{T} \rfloor,\lfloor \frac{m}{T} \rfloor)} \right)  \right) ^ {T}$$

分开处理。

$$\prod \limits_{T = 1} ^ {n} \left( \prod \limits_{d | T} ( h(\lfloor \frac{n}{T} \rfloor,\lfloor \frac{m}{T} \rfloor) ^ {d \mu(d)} \prod \limits_{d | T} \left((Td) ^ {d \mu(d)} \right) ^ {w(\lfloor \frac{n}{T} \rfloor,\lfloor \frac{m}{T} \rfloor)}  \right) ^ {T}$$

它等价于：

$$\prod \limits_{T = 1} ^ {n} \left(( h(\lfloor \frac{n}{T} \rfloor,\lfloor \frac{m}{T} \rfloor) ^ {\sum \limits_{d | T}d \mu(d)}  \left(T ^ {\sum \limits_{d | T} d \mu(d)} \prod \limits_{d | T} d ^ {d \mu(d)} \right) ^ {w(\lfloor \frac{n}{T} \rfloor,\lfloor \frac{m}{T} \rfloor)}  \right) ^ {T}$$

这样看起来很恶心，所以我们设 $x(n) = \sum \limits_{d | T}d \mu(d),y(n) = \prod \limits_{d | T} d ^ {d \mu(d)}$，原式就变成：

$$\prod \limits_{T = 1} ^ {n} \left(( h(\lfloor \frac{n}{T} \rfloor,\lfloor \frac{m}{T} \rfloor) ^ {x(T)}  \left(T ^ {x(T)} y(T) \right) ^ {w(\lfloor \frac{n}{T} \rfloor,\lfloor \frac{m}{T} \rfloor)}  \right) ^ {T}$$

其中 $x,y$ 都可以在 $O(n \log n)$ 的时间复杂度内预处理。

如果你推到这里停下，然后线性计算，可以获得 $60$ 分。以下是 $60$ 分的代码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N = 1e6 + 9,MOD = 32465177,phi_MOD = MOD - 1;
int quick_pow(int x,int y){
	x %= MOD;
	int ret = 1;
	while(y){
		if(y & 1)
			ret = ret * x % MOD;
		x = x * x % MOD;
		y >>= 1;
	}
	return ret;
}
int qpow(int x,int y){
	if(y >= 0)
		return quick_pow(x,y);
	return quick_pow(quick_pow(x,-y),MOD - 2);
}
int n;
bool is_not_prime[N] = {1,1};
int prime[N],top;
int mu[N]; 
void sieve(){
	mu[1] = 1;
	for(int i = 2;i <= n;i++){
		if(!is_not_prime[i]){
			prime[++top] = i;
			mu[i] = -1;
		}
		for(int j = 1;j <= top && i * prime[j] <= n;j++){
			is_not_prime[i * prime[j]] = 1;
			if(i % prime[j] == 0)
				break;
			mu[i * prime[j]] = -mu[i];
		}
	}
}
int f[N],g[N];
int x[N];int power[N],y[N];
int p[N],q[N];
void init(){
	f[0] = 1;g[0] = 0;
	for(int i = 1;i <= n;i++){
		f[i] = f[i - 1] * qpow(i,i) % MOD;
		g[i] = (g[i - 1] + i) % phi_MOD;
	}

	for(int i = 1;i <= n;i++)
		for(int j = i;j <= n;j += i)
			(x[j] += i * mu[i]) %= phi_MOD;

	for(int i = 1;i <= n;i++)
		y[i] = 1;
	for(int i = 1;i <= n;i++)
		power[i] = qpow(i,i * mu[i]);
	for(int i = 1;i <= n;i++)
		for(int j = i;j <= n;j += i)
			(y[j] *= power[i]) %= MOD;
}
int h(int n,int m){
	return qpow(f[n],g[m]) * qpow(f[m],g[n]) % MOD;
}
int w(int n,int m){
	return g[n] * g[m] % phi_MOD;
}
int S(int n,int m){
	if(n > m)
		swap(n,m);
	int ret = 1;
	for(int T = 1;T <= n;T++)
		(ret *= qpow(qpow(h(n / T,m / T),x[T]) * qpow(qpow(T,x[T]) * y[T] % MOD,w(n / T,m / T)) % MOD,T)) %= MOD;
	return ret;
}
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	int T;
	cin >> T >> n;
	sieve();
	init();
	while(T--){
		int l,r;
		cin >> l >> r;
		int ans = S(r,r) * S(l - 1,l - 1) % MOD * qpow(S(l - 1,r),-2) % MOD;
		cout << (ans + MOD) % MOD << '\n';
	}
	return 0;
}
```

优化的方法就是数论分块。

但是现在的式子无法直接数论分块，所以还需要变形。

$$\prod \limits_{T = 1} ^ {n} ( h(\lfloor \frac{n}{T} \rfloor,\lfloor \frac{m}{T} \rfloor) ^ {Tx(T)}  \left((T ^ {x(T)} y(T)) ^ T \right) ^ {w(\lfloor \frac{n}{T} \rfloor,\lfloor \frac{m}{T} \rfloor)} $$

令 $p(n) = n x(n),q(n) = (n ^ {x(n)} y(n)) ^n$，得到原式最终结果。

$$\prod \limits_{T = 1} ^ {n} ( h(\lfloor \frac{n}{T} \rfloor,\lfloor \frac{m}{T} \rfloor) ^ {p(T)}  \left(q(T) \right) ^ {w(\lfloor \frac{n}{T} \rfloor,\lfloor \frac{m}{T} \rfloor)} $$

然后就可以数论分块了。

注意 $p,q$ 分别在指数和底数，所以要分别预处理 $p$ 的前缀和及 $q$ 的前缀积。

以下是一些注意事项（持续更新）：

- 快速幂指数可能为负数，需要转成逆元。

- 指数要多对 $\varphi(32465177)$ 即 $32465176$ 取模，防止溢出。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N = 1e6 + 9,MOD = 32465177,phi_MOD = MOD - 1;
int quick_pow(int x,int y){
	x %= MOD;
	int ret = 1;
	while(y){
		if(y & 1)
			ret = ret * x % MOD;
		x = x * x % MOD;
		y >>= 1;
	}
	return ret;
}
int qpow(int x,int y){
	if(y >= 0)
		return quick_pow(x,y);
	return quick_pow(quick_pow(x,-y),MOD - 2);
}
int n;
bool is_not_prime[N] = {1,1};
int prime[N],top;
int mu[N]; 
void sieve(){
	mu[1] = 1;
	for(int i = 2;i <= n;i++){
		if(!is_not_prime[i]){
			prime[++top] = i;
			mu[i] = -1;
		}
		for(int j = 1;j <= top && i * prime[j] <= n;j++){
			is_not_prime[i * prime[j]] = 1;
			if(i % prime[j] == 0)
				break;
			mu[i * prime[j]] = -mu[i];
		}
	}
}
int f[N],g[N];
int x[N];int power[N],y[N];
int p[N],q[N];
int sum_p[N],sum_q[N];
void init(){
	f[0] = 1;g[0] = 0;
	for(int i = 1;i <= n;i++){
		f[i] = f[i - 1] * qpow(i,i) % MOD;
		g[i] = (g[i - 1] + i) % phi_MOD;
	}

	for(int i = 1;i <= n;i++)
		for(int j = i;j <= n;j += i)
			(x[j] += i * mu[i]) %= phi_MOD;

	for(int i = 1;i <= n;i++)
		y[i] = 1;
	for(int i = 1;i <= n;i++)
		power[i] = qpow(i,i * mu[i]);
	for(int i = 1;i <= n;i++)
		for(int j = i;j <= n;j += i)
			(y[j] *= power[i]) %= MOD;
	
	sum_q[0] = 1;
	for(int i = 1;i <= n;i++){
		p[i] = i * x[i] % phi_MOD;
		sum_p[i] = (sum_p[i - 1] + p[i]) % phi_MOD;
		q[i] = qpow(i,p[i]) * qpow(y[i],i) % MOD;
		sum_q[i] = sum_q[i - 1] * q[i] % MOD;
	}
}
int h(int n,int m){
	return qpow(f[n],g[m]) * qpow(f[m],g[n]) % MOD;
}
int w(int n,int m){
	return g[n] * g[m] % phi_MOD;
}
int S(int n,int m){
	if(n > m)
		swap(n,m);
	int ret = 1;
	for(int l = 1,r;l <= n;l = r + 1){
		r = min(n / (n / l),m / (m / l));
		(ret *= qpow(h(n / l,m / l),(sum_p[r] - sum_p[l - 1]) % phi_MOD) * qpow(sum_q[r] * qpow(sum_q[l - 1],MOD - 2) % MOD,w(n / l,m / l)) % MOD) %= MOD;
	}
	return ret;
}
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	int T;
	cin >> T >> n;
	sieve();
	init();
	while(T--){
		int l,r;
		cin >> l >> r;
		int ans = S(r,r) * S(l - 1,l - 1) % MOD * qpow(S(l - 1,r),-2) % MOD;
		cout << (ans + MOD) % MOD << '\n';
	}
	return 0;
}
```

[参考来源](https://www.bilibili.com/video/BV14L411f7gq/?spm_id_from=333.999.0.0&vd_source=fe2f7bcc3c2bac0cce470e6eb461d3e7)

---

## 作者：Bear203 (赞：3)

提供一种与大多数题解不同的做法。

记 $\begin{aligned}S(n)=\frac{n(n+1)}{2}\end{aligned}$，$\begin{aligned}f(n)=\prod_{i=1}^{n}{i}^{i}\end{aligned}$，$\begin{aligned}g(n)=\sum_{t|n}t\mu(t)\end{aligned}$。

记 $\begin{aligned}ans=\prod_{i=1}^n\prod_{j=1}^m(\frac{ij}{gcd(i,j)})^\frac{ij}{gcd(i,j)}\end{aligned}$

记 $\begin{aligned}ans1(n,m)=\prod_{i=1}^n\prod_{j=1}^mi^\frac{ij}{gcd(i,j)}\end{aligned}$，$\begin{aligned}ans2(n,m)=\prod_{i=1}^n\prod_{j=1}^mgcd(i,j)^\frac{ij}{gcd(i,j)}\end{aligned}$，则有 $ans=\frac{ans1(n,m)ans1(m,n)}{ans2(n,m)}$。

下面分开推导，首先是 $ans1$：

$$
\begin{aligned}
ans1(n,m)=\prod_{i=1}^ni^{i\sum_{j=1}^m\frac{j}{gcd(i,j)}}
\end{aligned}
$$
$$
\begin{aligned}
=\prod_{d=1}^n\prod_{i=1}^{n/d}{(di)}^{di\sum_{j=1}^{m/d}\epsilon(gcd(i,j))j}
\end{aligned}
$$
$$
\begin{aligned}
=\prod_{d=1}^n\prod_{t=1}^{n/d}\prod_{i=1}^{n/dt}{(dti)}^{dt^2\mu(t)i\sum_{j=1}^{m/dt}j}
\end{aligned}
$$
$$
\begin{aligned}
=\prod_{d=1}^n\prod_{t=1}^{n/d}\prod_{i=1}^{n/dt}{(dti)}^{dt^2\mu(t)iS(m/dt)}
\end{aligned}
$$
$$
\begin{aligned}
=\prod_{T=1}^n\prod_{i=1}^{n/T}{(Ti)}^{iTS(m/T)\sum_{t|T}t\mu(t)}
\end{aligned}
$$
$$
\begin{aligned}
=\prod_{T=1}^n(\prod_{i=1}^{n/T}{(Ti)}^{i})^{Tg(T)S(m/T)}
\end{aligned}
$$
$$
\begin{aligned}
=\prod_{T=1}^n({T}^{S(n/T)}(\prod_{i=1}^{n/T}{i}^{i}))^{Tg(T)S(m/T)}
\end{aligned}
$$
$$
\begin{aligned}
=\prod_{T=1}^n({T}^{Tg(T)})^{S(n/T)S(m/T)}(f(n/T)^{S(m/T)})^{Tg(T)}
\end{aligned}
$$

然后 $ans2$：

$$
\begin{aligned}
ans2(n,m)=\prod_{d=1}^nd^{d\sum_{i=1}^{n/d}\sum_{j=1}^{m/d}\epsilon(gcd(i,j))ij}
\end{aligned}
$$
$$
\begin{aligned}
=\prod_{d=1}^nd^{d\sum_{t=1}^{n/d}t^2\mu(t)\sum_{i=1}^{n/dt}i\sum_{j=1}^{m/dt}j}
\end{aligned}
$$
$$
\begin{aligned}
=\prod_{d=1}^nd^{d\sum_{t=1}^{n/d}t^2\mu(t)S(n/dt)S(m/dt)}
\end{aligned}
$$
$$
\begin{aligned}
=\prod_{T=1}^n(\prod_{t|T}(\frac{T}{t})^{Tt\mu(t)})^{S(n/T)S(m/T)}
\end{aligned}
$$
$$
\begin{aligned}
=\prod_{T=1}^n(\frac{T^{Tg(T)}}{(\prod_{t|T}t^{t\mu(t)})^T})^{S(n/T)S(m/T)}
\end{aligned}
$$

---
预处理 $\begin{aligned}\sum_{T=1}^iTg(T)\end{aligned}$、$\begin{aligned}\prod_{T=1}^i{T}^{Tg(T)}\end{aligned}$、$\begin{aligned}\prod_{T=1}^i\frac{T^{Tg(T)}}{(\prod_{t|T}t^{t\mu(t)})^T}\end{aligned}$，整除分块，时间复杂度 $O(n\log mod+T\sqrt{n}\log mod)$。
```cpp
#include<bits/stdc++.h>
#define LL long long
#define Un unsigned
#define For1(i,a,b) for(i=(a);i<=(b);++i)
#define For2(i,a,b) for(i=(a);i<(b);++i)
#define FoR1(i,a,b) for(i=(a);i>=(b);--i)
#define FoR2(i,a,b) for(i=(a);i>(b);--i)
#define For_L(i,x) for(i=ft[x];i;i=nt[i])
#define pii std::pair<int,int>
#define mkp std::make_pair
#define fir first
#define sec second
#define pb emplace_back
#define il inline
#define dbg(x...) fprintf(stderr,x),fflush(stderr)
#define FI using std::cin;std::ios::sync_with_stdio(0),cin.tie(0)
template<class T1>
il void cmin(T1 &x,T1 y){if(x>y)x=y;}
template<class T1>
il void cmax(T1 &x,T1 y){if(x<y)x=y;}
const int N=1000111,mod=32465177,mod_=mod-1;
il int add(int x,int y){return (x+=y)<mod?x:x-mod;}
il int add_(int x,int y){return (x+=y)<mod_?x:x-mod_;}
il void addd(int &x,int y){if((x+=y)>=mod)x-=mod;}
il void addd_(int &x,int y){if((x+=y)>=mod_)x-=mod_;}
il int sub(int x,int y){return (x-=y)<0?x+mod:x;}
il int sub_(int x,int y){return (x-=y)<0?x+mod_:x;}
il void subb(int &x,int y){if((x-=y)<0)x+=mod;}
il int mul(int x,int y){return 1ll*x*y%mod;}
il int mul_(int x,int y){return 1ll*x*y%mod_;}
il void mull(int &x,int y){x=1ll*x*y%mod;}
il void mull_(int &x,int y){x=1ll*x*y%mod_;}
il int pow(int x,LL y){int res=1;
	y%=mod-1;
	if(y<0)y+=mod-1;
	while(y){
		if(y&1)mull(res,x);
		mull(x,x);
		y>>=1;
	}
	return res;
}
il int inv(int x){return pow(x,mod-2);}
il int S(int x){return (1ll*x*(x+1)>>1)%mod;}
il int S_(int x){return (1ll*x*(x+1)>>1)%mod_;}
bool bk[N];
int mu[N],pr[N>>1],tlp,sum1[N],sum2[N],sum3[N],fct[N],n,T;
il void inic(int n){int i,j,t1;
	mu[1]=1;
	For1(i,2,n){
		if(!bk[i]){pr[++tlp]=i;mu[i]=-1;}
		for(j=1;j<=tlp&&(t1=i*pr[j])<=n;++j){
			bk[t1]=1;
			if(i%pr[j])mu[t1]=-mu[i];
			else{
				mu[t1]=0;
				break;
			}
		}
	}
	fct[0]=1;
	For1(i,1,n)fct[i]=mul(fct[i-1],pow(i,i));
	sum2[0]=1;
	sum3[0]=1;
	For1(i,1,n)sum3[i]=1;
	For1(i,1,n){
		int t2=pow(i,mul_(i,mu[i]));
		for(j=1,t1=i;t1<=n;++j,t1+=i)if(mu[i])addd_(sum1[t1],mul_(i,sub_(mu[i],0))),mull(sum3[t1],t2);
		mull_(sum1[i],i);
		sum2[i]=pow(i,sum1[i]);
		sum3[i]=mul(sum2[i],inv(pow(sum3[i],i)));
		addd_(sum1[i],sum1[i-1]);
		mull(sum2[i],sum2[i-1]);
		mull(sum3[i],sum3[i-1]);
	}
}
il int slv1(int n,int m){int res=1;
	for(int l,r=0;(l=r+1)<=n&&l<=m;){
		int t1=n/l,t2=m/l;
		r=std::min(n/t1,m/t2);
		mull(res,mul(pow(mul(sum2[r],inv(sum2[l-1])),mul_(S_(t1),S_(t2))),pow(fct[t1],mul_(S_(t2),sub_(sum1[r],sum1[l-1])))));
	}
	return res;
}
il int slv2(int n,int m){int res=1;
	for(int l,r=0;(l=r+1)<=n;){
		int t1=n/l,t2=m/l;
		r=std::min(n/t1,m/t2);
		mull(res,pow(mul(sum3[r],inv(sum3[l-1])),mul_(S_(t1),S_(t2))));
	}
	return res;
}
il int slv(int n,int m){return mul(mul(slv1(n,m),slv1(m,n)),inv(slv2(n,m)));}
int main(){FI;int t1,t2,t3;
	cin>>T>>n;
	inic(n);
	while(T--){
		cin>>t1>>t2;--t1;
		t3=inv(slv(t1,t2));
		printf("%d\n",mul(mul(slv(t2,t2),slv(t1,t1)),mul(t3,t3)));
	}
	return 0;
}
```

---

## 作者：InQueue (赞：2)

题意：求 

$$\left(\prod_{i=l}^r\prod_{j=l}^r\operatorname{lcm}(i, j)^{\operatorname{lcm}(i, j)}\right)\bmod 32465177$$

---

**以下运算中不考虑取模。**

对于 $n\le m$，设

$$cal(n, m) = \prod_{i=1}^n\prod_{j=1}^m\operatorname{lcm}(i, j)^{\operatorname{lcm}(i, j)}$$

则

$$Ans = \dfrac{cal(r, r)\times cal(l - 1, l - 1)}{cal(l - 1, r)^2}$$

化简 $cal$ 即可：

$$\begin{aligned}

cal(n, m) &= \prod_{i=1}^n\prod_{j=1}^m\operatorname{lcm}(i, j)^{\operatorname{lcm}(i, j)}

\\ &= \prod_{i=1}^n\prod_{j=1}^m\left(\dfrac{ij}{\gcd(i, j)}\right)^{\frac{ij}{\gcd(i, j)}}

\end{aligned}$$

枚举 $\gcd(i, j)$：

$$\begin{aligned}

cal(n, m) &= \prod_{d=1}^n\prod_{i=1}^{\left \lfloor \frac nd\right \rfloor }\prod_{j=1}^{\left \lfloor \frac md\right \rfloor }(ijd)^{ijd\epsilon(\gcd(i, j))}

\\ &= \prod_{d=1}^n\prod_{i=1}^{\left \lfloor \frac nd\right \rfloor }\prod_{j=1}^{\left \lfloor \frac md\right \rfloor }(ijd)^{ijd\sum_{D|\gcd(i, j)}\mu(D)}

\\ &= \prod_{d=1}^n\prod_{i=1}^{\left \lfloor \frac nd\right \rfloor }\prod_{j=1}^{\left \lfloor \frac md\right \rfloor }\prod_{D|\gcd(i, j)}(ijd)^{ijd\mu(D)}

\\ &= \prod_{d=1}^n\prod_{D = 1}^{\left \lfloor \frac nd\right \rfloor }\prod_{i=1}^{\left \lfloor \frac n{Dd}\right \rfloor }\prod_{j=1}^{\left \lfloor \frac m{Dd}\right \rfloor }(ijdD^2)^{ijdD^2\mu(D)}

\end{aligned}$$

用类似 [P2257](https://www.luogu.com.cn/problem/P2257) 的套路，枚举 $x = Dd$：

$$\begin{aligned}

cal(n, m) &= \prod_{x=1}^n\prod_{d|x}\prod_{i=1}^{\left \lfloor \frac nx\right \rfloor }\prod_{j=1}^{\left \lfloor \frac mx\right \rfloor }(ijxd)^{ijxd\mu(d)}

\\ &= \prod_{x=1}^n\prod_{d|x}\prod_{i=1}^{\left \lfloor \frac nx\right \rfloor }\prod_{j=1}^{\left \lfloor \frac mx\right \rfloor }(ij)^{ijxd\mu(d)}\times \prod_{x=1}^n\prod_{d|x}\prod_{i=1}^{\left \lfloor \frac nx\right \rfloor }\prod_{j=1}^{\left \lfloor \frac mx \right \rfloor }(xd)^{ijxd\mu(d)}

\end{aligned}$$

此时整个式子分为两个独立的部分，分别设为 $cal1(n, m), cal2(n, m)$：

$$\begin{aligned}

cal1(n, m) &= \prod_{x=1}^n\left(\prod_{d|x}\left(\prod_{i=1}^{\left \lfloor \frac nx\right \rfloor }\prod_{j=1}^{\left \lfloor \frac mx\right \rfloor }(ij)^{ij}\right)^{d\mu(d)}\right)^x

\\ &= \prod_{x=1}^n\left(\prod_{i=1}^{\left \lfloor \frac nx\right \rfloor }\prod_{j=1}^{\left \lfloor \frac mx\right \rfloor }(ij)^{ij}\right)^{x\sum_{d|x}d\mu(d)}

\\ &= \prod_{x=1}^n\left(\prod_{i=1}^{\left \lfloor \frac nx\right \rfloor }\prod_{j=1}^{\left \lfloor \frac mx\right \rfloor }i^{ij}j^{ij}\right)^{x\sum_{d|x}d\mu(d)}

\\ &= \prod_{x=1}^n\left(\left(\prod_{i=1}^{\left \lfloor \frac nx\right \rfloor }i^{i\sum_{j=1}^{\left \lfloor \frac mx\right \rfloor }j}\right)\left(\prod_{i=1}^{\left \lfloor \frac mx\right \rfloor }i^{i\sum_{j=1}^{\left \lfloor \frac nx\right \rfloor }j}\right)\right)^{x\sum_{d|x}d\mu(d)}

\\ &= \prod_{x=1}^n\left(\left(\prod_{i=1}^{\left \lfloor \frac nx\right \rfloor }i^i\right)^{\sum_{j=1}^{\left \lfloor \frac mx\right \rfloor }j}\left(\prod_{i=1}^{\left \lfloor \frac mx\right \rfloor }i^i\right)^{\sum_{j=1}^{\left \lfloor \frac nx\right \rfloor }j}\right)^{x\sum_{d|x}d\mu(d)}

\end{aligned}$$

观察到有相同结构或需要预处理的部分，定义：

$$A(x) = \prod_{i=1}^xi^i$$

$$sum(x) = \sum_{i=1}^xi$$

$$B(x) = x\sum_{d|x}d\mu(d)$$

则

$$\begin{aligned}

cal1(n, m) &= \prod_{x=1}^n\left(A\left(\left \lfloor \frac nx\right \rfloor\right)^{sum\left(\left \lfloor \frac mx\right \rfloor\right)}A\left(\left \lfloor \frac mx\right \rfloor\right)^{sum\left(\left \lfloor \frac nx\right \rfloor\right)}\right)^{B(x)}

\end{aligned}$$

快速幂预处理 $A(1\sim m)$，$O(m\log m)$。

$O(n)$ 预处理 $sum$ 或者不开数组直接算都行。

先筛 $\mu$，再枚举倍数求 $B$。

此时直接整除分块，即可算出 $cal1(n, m)$。时间复杂度 $O(\sqrt n\log n)$。

再来看第二部分：

$$\begin{aligned}

cal2(n, m) &= \prod_{x=1}^nx^{\sum_{d|x}\sum_{i=1}^{\left \lfloor \frac nx\right \rfloor }\sum_{j=1}^{\left \lfloor \frac mx\right \rfloor }ijxd\mu(d)}\prod_{d|x}d^{\sum_{i=1}^{\left \lfloor \frac nx\right \rfloor }\sum_{j=1}^{\left \lfloor \frac mx\right \rfloor }ijxd\mu(d)}

\\ &= \prod_{x=1}^nx^{x\sum_{d|x}d\mu(d)\sum_{i=1}^{\left \lfloor \frac nx\right \rfloor }\sum_{j=1}^{\left \lfloor \frac mx\right \rfloor }ij}\prod_{d|x}d^{xd\mu(d)\sum_{i=1}^{\left \lfloor \frac nx\right \rfloor }\sum_{j=1}^{\left \lfloor \frac mx\right \rfloor }ij}

\\ &= \prod_{x=1}^nx^{B(x)sum\left(\left \lfloor \frac nx\right \rfloor\right)sum\left(\left \lfloor \frac mx\right \rfloor\right)}\left(\prod_{d|x}d^{d\mu(d)}\right)^{xsum\left(\left \lfloor \frac nx\right \rfloor\right)sum\left(\left \lfloor \frac mx\right \rfloor\right)}

\end{aligned}$$

设

$$C(x) = \left(\prod_{d|x}d^{d\mu(d)}\right)^x$$

枚举倍数，$O(n\log n)$ 算出每个 $\prod_{d|x}d^{d\mu(d)}$，再求 $C$。

则

$$cal2(n, m) = \prod_{x=1}^nx^{B(x)sum\left(\left \lfloor \frac nx\right \rfloor\right)sum\left(\left \lfloor \frac mx\right \rfloor\right)}C(x)^{sum\left(\left \lfloor \frac nx\right \rfloor\right)sum\left(\left \lfloor \frac mx\right \rfloor\right)}$$

整除分块，$O(\sqrt n\log n)$ 算出 $cal2(n, m)$。

$cal(n, m) = cal1(n, m)\times cal2(n, m)$，再代回原式中即可得到答案。总时间复杂度 $O(n\log n + T\sqrt n\log n)$。

注意：

- 此题中指数可能为负，需要特判。

- 处于指数位置上的数不能取模。

- 指数上不取模，所以会爆 long long，需开 __int128。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
constexpr ll mo = 32465177;
ll qpw(ll x, __int128 y)//quick power
{
	if(y < 0)//特判负指数
	{
		y = y % (mo - 1) + mo - 1;
	}
	if(!y)
	{
		return 1;
	}
	ll tmp = qpw(x, y / 2);
	return tmp * tmp % mo * (y % 2 ? x : 1) % mo;
}
ll A[1000005];//定义同上
__int128 sum[1000005];//定义同上
__int128 B[1000005];//B[x] = \sum_{i=1}^x B(i)
ll C[1000005];//C[x] = \prod_{i=1}^x C(i)
ll D[1000005];//D[x] = \prod_{i=1}^x i^{B(i)}
ll pri[1000005], pcnt, mu[1000005];
bool np[1000005];//线性筛的数组
ll cal1(ll n, ll m)
{
	ll l = 1, r, ret = 1;
	while(l <= n)
	{
		r = min(n / (n / l), m / (m / l));
		ret *= qpw(qpw(A[n / l], sum[m / l]) * qpw(A[m / l], sum[n / l]) % mo, B[r] - B[l - 1]), ret %= mo;
		l = r + 1;
	}
	return ret;
}
ll cal2(ll n, ll m)
{
	ll l = 1, r, ret = 1;
	while(l <= n)
	{
		r = min(n / (n / l), m / (m / l));
		ret *= qpw(D[r] * qpw(D[l - 1], -1) % mo, sum[n / l] * sum[m / l]) * qpw(C[r] * qpw(C[l - 1], -1) % mo, sum[n / l] * sum[m / l]) % mo, ret %= mo;
		l = r + 1;
	}
	return ret;
}
ll cal(ll n, ll m)
{
	return cal1(n, m) * cal2(n, m) % mo;
}
int main()
{
	ll T, n;
	cin >> T >> n;
	A[0] = 1;
	for(ll i = 1; i <= n; i++)//算A和sum，顺便赋C的初值
	{
		A[i] = A[i - 1] * qpw(i, i) % mo;
		sum[i] = sum[i - 1] + i;
		C[i] = 1;
	}
	mu[1] = 1;
	for(ll i = 2; i <= n; i++)//筛\mu
	{
		if(!np[i])
		{
			pri[++pcnt] = i;
			mu[i] = -1;
		}
		for(ll j = 1; j <= pcnt && pri[j] * i <= n; j++)
		{
			np[pri[j] * i] = 1;
			if(i % pri[j] == 0)
			{
				break;
			}
			mu[pri[j] * i] = -mu[i];
		}
	}
	for(ll i = 1; i <= n; i++)//枚举倍数，同时算B(),C()
	{
		ll tmp = qpw(i, i * mu[i]);//防止重复计算
		for(ll j = 1; j * i <= n; j++)
		{
			B[j * i] += j * i * i * mu[i];
			C[j * i] *= tmp, C[j * i] %= mo;
		}
	}
	D[0] = 1, C[0] = 1;
	for(ll i = 1; i <= n; i++)//算B[],C[],D[]
	{
		D[i] = D[i - 1] * qpw(i, B[i]) % mo;
		B[i] += B[i - 1];
		C[i] = C[i - 1] * qpw(C[i], i) % mo;
	}
	while(T--)
	{
		ll ql, qr;
		cin >> ql >> qr;
		cout << cal(qr, qr) * cal(ql - 1, ql - 1) % mo * qpw(cal(ql - 1, qr), -2) % mo << endl;
		//容斥
	}
	return 0;
}
```

---

## 作者：Deuteron (赞：2)

### Preface

截止文章发布之前的最优解。

### Solution

考虑使用离散对数把乘法变为加法。

令 

$$s=\ln(\prod \limits_{i=l}^r \prod \limits_{j=l}^r \operatorname{lcm}(i,j)^{\operatorname{lcm(i,j})})$$

$$=\sum \limits_{i=l}^r \sum \limits_{j=l}^r \operatorname{lcm}(i,j)\ln (\operatorname{lcm}(i,j))$$ 

则答案为 $g^{s}$ ，其中 $g$ 为 mod 的原根，题中为 $3$ 。

进行莫反，

$$\sum \limits_{i=l}^r \sum \limits_{j=l}^r \operatorname{lcm}(i,j)\ln (\operatorname{lcm}(i,j))$$


$$=\sum \limits_{i=l}^r \sum \limits_{j=l}^r \sum \limits_{g|i,g|j} {\dfrac{ij}{g}}\ln (\dfrac{ij}{g}) [\gcd(i,j)=g]$$


$$=\sum \limits_{i=l}^r \sum \limits_{j=l}^r \sum \limits_{g|i,g|j} {\dfrac{ij}{g}}\log (\dfrac{ij}{g}) \sum \limits_{dg|i,dg|j} \mu(g)$$

$$=\sum \limits_{d=1}^r \mu(d) \sum \limits_{g=1}^{\frac{r}{d}} \sum \limits_{i=L}^R \sum \limits_{j=L}^R  (ijd^2g)\ln(ijd^2g)$$ 

其中 $L=\lceil \dfrac{l}{gd} \rceil,R=\lfloor \dfrac{r}{gd} \rfloor$ 。

$$=\sum \limits_{d=1}^r \mu(d) \sum \limits_{g=1}^{\frac{r}{d}} d^2g\sum \limits_{i=L}^R \sum \limits_{j=L}^R  ij (\ln i+\ln j+2\ln d+\ln g)$$

令 $T=gd$ ，则有

$$=\sum \limits_{T=1}^R T \sum \limits_{d|T} d\mu(d) \sum\limits_{i=L}^R \sum \limits_{j=L}^R ij(2\ln(i)+ln(T)+ln(d))$$



$$=\sum \limits_{T=1}^R T \sum \limits_{d|T} d\mu(d) \sum\limits_{i=L}^R \sum \limits_{j=L}^R ij(2\ln(i)+\ln(T)+\ln(d))$$



令 $F(l,r)=\sum \limits_{i=l}^r i$ ，$G(l,r)=\sum \limits_{i=l}^r i \ln(i)$ ，则 

$$=\sum \limits_{T=1}^R T (\sum \limits_{d|T} d\mu(d)) (2F(L,R)G(L,R)+\ln(T) F(L,R)^2)+(\sum \limits_{d|T} d\mu(d)\ln(d)) (F(L,R)^2)$$ 。

分别令 $f_i=\sum \limits_{d|i} d\mu(d),g_i=\sum \limits_{d|T} d\mu(d)\ln(d)$ ，均可以用狄利克雷前缀和在 $O(n \log \log n)$ 时间内预处理。

此时可以直接枚举 $T$ 做到单次询问 $O(n)$，可以通过。

也可以整除分块，维护 $f_i,g_i$ 一类的前缀和，总复杂度为 $O(mod+n \log \log n+T \sqrt n)$ 。

注意 $\ln$ 维护前 $n$ 个数即可，否则会 MLE 。

code


```cpp
#include<iostream>
#include<algorithm>
#define int long long
using namespace std;
const int N=1e6+5,mod=32465177,md=mod-1;
int t,n,l,r;
int d[N],dd[N],p[N],ip[N],mu[N],f[N],g[N],cnt,ln[N];
int A[N],B[N],C[N]; 
int ksm(int a,int b){
	if(b==0) return 1;
	int ans=ksm(a,b/2);
	ans=ans*ans%mod;
	if(b&1) ans=ans*a%mod;
	return ans;
}
void work(int n){
	mu[1]=1;
	for(int i=2;i<=n;i++){
		if(!ip[i]){
			p[++cnt]=i;
			mu[i]=-1;
		}
		for(int j=1;j<=cnt&&i*p[j]<=n;j++){
			mu[i*p[j]]=-mu[i];
			ip[i*p[j]]=1;
			if(i%p[j]==0){
				mu[i*p[j]]=0;
				break;
			}
		}
	}
	int s=1;
	for(int i=1;i<=mod;i++){
		s=s*3%mod;
		if(s<=n) ln[s]=i;
	}
	for(int i=1;i<=n;i++){
		f[i]=(f[i-1]+i)%md;
		g[i]=(g[i-1]+i*ln[i])%md;
        d[i]=i*mu[i]+md;
        dd[i]=i*ln[i]%md*mu[i]+md;
	}
    for(int i=1;i<=cnt;i++){
        for(int j=1;j*p[i]<=n;j++){
            d[j*p[i]]+=d[j];
            dd[j*p[i]]+=dd[j];
        }
    }
	for(int i=1;i<=n;i++){
		A[i]=(A[i-1]+i*d[i])%md;
		B[i]=(B[i-1]+i*dd[i])%md;
		C[i]=(C[i-1]+i*d[i]%md*ln[i])%md;
	}
}
signed main(){
	cin>>t>>n;
    work(n);
	while(t--){
		cin>>l>>r;
		int ans=0,k=0;
		for(int i=1;i<=r;i=k+1){
			k=r/(r/i);
			if(i<l) k=min(k,(l-1)/((l-1)/i));
			int L=(l+i-1)/i,R=r/i;
			if(L>R) continue;
			int F=(f[R]-f[L-1]+md)*(f[R]-f[L-1]+md)%md,G=(g[R]-g[L-1]+md)*(f[R]-f[L-1]+md)%md;
			ans=(ans+(C[k]-C[i-1]+B[k]-B[i-1]+md*2)*F+2*(A[k]-A[i-1]+md)*G)%md;
		}
		cout<<ksm(3,ans)<<"\n";
	}
	return 0;
}
```

---

## 作者：Benzaiten (赞：2)

考虑简化问题，有：

 $$
 \begin{aligned}
 &\Rightarrow\prod\limits_{i=l}^r\prod\limits_{j=l}^rf(i,j)
  \\&=\prod\limits_{i=l}^r\frac{\prod\limits_{j=1}^rf(i,j)}{\prod\limits_{j'=1}^{l-1}f(i,j')}
   \\&=\prod\limits_{i=1}^r\frac{\prod\limits_{j=1}^rf(i,j)}{\prod\limits_{j'=1}^{l-1}f(i,j')}\prod\limits_{i'=1}^{l-1}\frac{\prod\limits_{k=1}^{l-1}f(i',k)}{\prod\limits_{k=1}^{r}f(i',k')}
   \\&=\frac{solve(r,r)*solve(l-1,l-1)}{solve(r,l-1)*solve(l-1,r)}
 \end{aligned}
 $$

这里的 $solve(n,m)=\prod\limits_{i=1}^n\prod\limits_{j=1}^mlcm(i,j)^{lcm(i,j)}$ 。那么我们考虑求出 $solve(n,m)$ 的值即可。下作 $solve(n,m)$ 的化简。

 $$
 \begin{aligned}
 &\Rightarrow\prod\limits_{i=1}^n\prod\limits_{j=1}^m\frac{ij}{\gcd(i,j)}^{\frac{ij}{\gcd(i,j)}}
 \\&=\prod\limits_{i=1}^n\prod\limits_{j=1}^m\prod\limits_{d=1}^n\frac{ij}{d}^{\frac{ij}{d}[d=\gcd(i,j)]}
  \\&=\prod\limits_{d=1}^n\prod\limits_{i=1}^{\lfloor\frac{n}{d}\rfloor}\prod\limits_{j=1}^{\lfloor\frac{m}{d}\rfloor}(ijd)^{ijd[1=\gcd(i,j)]}
  \\&=\prod\limits_{d=1}^n\prod\limits_{i=1}^{\lfloor\frac{n}{d}\rfloor}\prod\limits_{j=1}^{\lfloor\frac{m}{d}\rfloor}\prod\limits_{t\mid i,t\mid j}(ijd)^{ijd\mu(t)}
  \\&=\prod\limits_{d=1}^n\prod\limits_{t=1}^{\lfloor\frac{n}{d}\rfloor}\prod\limits_{i=1}^{\lfloor\frac{n}{dt}\rfloor}\prod\limits_{j=1}^{\lfloor\frac{m}{dt}\rfloor}(ijdt^2)^{ijdt^2\mu(t)}
   \\&=\prod\limits_{T=1}^n\prod\limits_{d\mid T}(\prod\limits_{i=1}^{\lfloor\frac{n}{T}\rfloor}\prod\limits_{j=1}^{\lfloor\frac{m}{T}\rfloor}(ijdT)^{ij})^{dT\mu(d)}
 \end{aligned}
 $$

考虑 $\prod\limits_{i=1}^{x}\prod\limits_{j=1}^{y}(ij)^{ij}$ ，有：
 
 $$
 \begin{aligned}
 &\Rightarrow\prod\limits_{i=1}^{x}(\prod\limits_{j=1}^{y}(ij)^j)^i
 \\&=\prod\limits_{i=1}^{x}i^{s(y)i}(\prod\limits_{j=1}^{y}j^j)^i
  \\&=\prod\limits_{i=1}^{x}i^{s(y)i}g(y)^i
  \\&=g(y)^{s(x)}(\prod\limits_{i=1}^{x}i^{i})^{s(y)}
 \\&=g(y)^{s(x)}g(x)^{s(y)} 
 \end{aligned}
 $$
 
 其中 $s(x)=\frac{x(x+1)}{2},g(x)=\prod\limits_{i=1}^xi^i$ 。
 再考虑 $\prod\limits_{i=1}^{x}\prod\limits_{j=1}^{y}(dT)^{ij}$ ，有：
  
  $$
 \begin{aligned}
 \prod\limits_{i=1}^{x}\prod\limits_{j=1}^{y}(dT)^{ij}=(dT)^{s(x)s(y)}
 \end{aligned}
 $$

令 $u(x,y)=g(y)^{s(x)}g(x)^{s(y)}$ ，原式化为：

$$
 \begin{aligned}
 &\Rightarrow\prod\limits_{T=1}^n(\prod\limits_{d\mid T}(u(\lfloor\frac{n}{T}\rfloor,\lfloor\frac{m}{T}\rfloor)(dT)^{s(\lfloor\frac{n}{T}\rfloor)s(\lfloor\frac{m}{T}\rfloor)})^{d\mu(d)})^T
 \\&=\prod\limits_{T=1}^n(u(\lfloor\frac{n}{T}\rfloor,\lfloor\frac{m}{T}\rfloor)^{\sum\limits_{d\mid T}d\mu(d)}(T^{\sum\limits_{d'\mid T}d'\mu(d')}\prod\limits_{t\mid T}t^{t\mu(t)})^{s(\lfloor\frac{n}{T}\rfloor)s(\lfloor\frac{m}{T}\rfloor)})^T
 \end{aligned}
 $$

令 $h(x)=\sum\limits_{d\mid x}d\mu(d),v(x)=\prod\limits_{d\mid x}d^{d\mu(d)}$ ，原式化为：

$$
 \begin{aligned}
 &\Rightarrow\prod\limits_{T=1}^n(u(\lfloor\frac{n}{T}\rfloor,\lfloor\frac{m}{T}\rfloor)^{h(T)}(T^{h(T)}v(T))^{s(\lfloor\frac{n}{T}\rfloor)s(\lfloor\frac{m}{T}\rfloor)})^T
 \\&=\prod\limits_{T=1}^nu(\lfloor\frac{n}{T}\rfloor,\lfloor\frac{m}{T}\rfloor)^{Th(T)}((T^{h(T)}v(T))^T)^{s(\lfloor\frac{n}{T}\rfloor)s(\lfloor\frac{m}{T}\rfloor)}
 \end{aligned}
 $$

再令 $H(x)=xh(x),V(x)=(x^{h(x)}v(x))^x$ ，原式最后变为: 

$$
 \begin{aligned}
\prod\limits_{T=1}^nu(\lfloor\frac{n}{T}\rfloor,\lfloor\frac{m}{T}\rfloor)^{H(T)}V(T)^{s(\lfloor\frac{n}{T}\rfloor)s(\lfloor\frac{m}{T}\rfloor)}
 \end{aligned}
 $$

此时便可以作前缀和与前缀积处理，然后就能愉快地进行数论分块了～ 
代码总的复杂度应该为 $O(n\log n+T\sqrt{n}(\log n+\log M))$ ？

```cpp
#include<iostream>
#include<bitset>
#include<cmath>
using namespace std;
typedef long long ll;
#define debug(x) cerr<<#x<<":"<<x<<endl
#define debug2(x,y) cerr<<#x<<":"<<x<<"  "<<#y<<":"<<y<<endl
#define debug3(x,y,z) cerr<<#x<<":"<<x<<"  "<<#y<<":"<<y<<"  "<<#z<<":"<<z<<endl
const ll N=1e7+5,M=32465177,_N=666666;
ll cnt=0;
int prime[_N],g[N],h[N],v[N];
bitset<N> vis;
inline ll mabs(ll x){
    if(abs(x)>=M) x%=M;
    if(x<0) x+=M;
    return x;
}
ll qpow(ll a,ll b){
    ll res=1;
    a%=M;
    b%=M-1;
    if(b<0) b+=M-1;
    while(b){
        if(b&1) res=mabs(a*res);
        b>>=1;
        a=mabs(a*a);
    }
    return res;
}
inline ll inv(ll x){return qpow(x,M-2);}
void pre(ll n){
    g[0]=v[0]=g[1]=h[1]=v[1]=1;
    h[0]=0;
    for(int i=2;i<=n;++i){
        g[i]=mabs((ll)g[i-1]*qpow(i,i));
        if(!vis[i]){
            prime[cnt++]=i;
            h[i]=-i;
            v[i]=qpow(i,h[i]);
        }
        for(int j=0;i*prime[j]<=n;++j){
            int t=i*prime[j];
            vis[t]=1;
            if(i%prime[j]){
                if(!h[i]) h[t]=0;
                else if(h[i]>0) h[t]=-t;
                else h[t]=t;
                v[t]=qpow(t,h[t]);
            }
            else{
                h[t]=0;
                v[t]=1;
                break;
            }
        }
    }
    for(int i=0;i<cnt;++i){
        for(int j=1;j*prime[i]<=n;++j){
            h[j*prime[i]]=(((ll)h[j*prime[i]]+(ll)h[j])%(M-1)+(M-1))%(M-1);
            v[j*prime[i]]=mabs((ll)v[j*prime[i]]*(ll)v[j]);
        }
    }
    for(ll i=2;i<=n;++i){
        ll t=mabs((ll)v[i]*qpow(i,h[i]));
        v[i]=qpow(t,i);
        v[i]=mabs((ll)v[i]*(ll)v[i-1]);
        h[i]=(((ll)h[i-1]+(ll)i*(ll)h[i])%(M-1)+(M-1))%(M-1);
    }
}
inline ll s(ll x){return ((x*(x+1))>>1)%(M-1);}
inline ll u(ll x,ll y){return mabs(qpow(g[x],s(y))*qpow(g[y],s(x)));}
ll solve(ll n,ll m){
    ll res=1;
    for(ll l=1,r;l<=min(n,m);l=r+1){
        r=min(n/(n/l),m/(m/l));
        ll t1=mabs((ll)v[r]*inv(v[l-1])),t2=qpow(u(n/l,m/l),h[r]-h[l-1]);
        t1=qpow(t1,s(n/l)*s(m/l));
        res=mabs(mabs(t1*t2)*res);
    }
    return res;
}
int main(){
    ll t,n,l,r;
    cin>>t>>n;
    pre(n);
    while(t--){
        cin>>l>>r;
        ll t1=mabs(solve(r,r)*solve(l-1,l-1)),t2=mabs(inv(solve(r,l-1))*inv(solve(l-1,r)));
        ll res=mabs(t1*t2);
        cout<<res<<endl;
    }
}
```

---

## 作者：封禁用户 (赞：1)

### 题目
给出 $l,r$，求：
$$
\prod_{i=l}^{r}\prod_{j=l}^{r}{\operatorname{lcm}(i,j)}^{\operatorname{lcm}(i,j)}
$$

### 分析
考虑容斥，即求：
$$
\prod_{i=1}^{n}\prod_{j=1}^{m}{\operatorname{lcm}(i,j)}^{\operatorname{lcm}(i,j)}
$$

把 $\operatorname{lcm}$ 转化为 $\gcd$：
$$
\begin{aligned}
\text{原式}
=&\prod_{i=1}^{n}\prod_{j=1}^{m}({\frac{ij}{\gcd(i,j)}})^{(\frac{ij}{\gcd(i,j)})}&\\
\end{aligned}
$$

枚举 $\gcd(i,j)$，并令 $n\le m$：
$$
\begin{aligned}
\text{原式}
=&\prod_{d=1}^{n}\prod_{i=1}^{n}\prod_{j=1}^{m}({\frac{ij}{d}})^{(\frac{ij}{d}[\gcd(i,j)=d])}&\\
=&\prod_{d=1}^{n}\prod_{i=1}^{\lfloor\frac{n}{d}\rfloor}\prod_{j=1}^{\lfloor\frac{m}{d}\rfloor}({ijd})^{({ijd}[\gcd(i,j)=1])}&\\
\end{aligned}
$$

莫反：
$$
\begin{aligned}
\text{原式}
=&\prod_{d=1}^{n}\prod_{i=1}^{\lfloor\frac{n}{d}\rfloor}\prod_{j=1}^{\lfloor\frac{m}{d}\rfloor}({ijd})^{({ijd}\sum_{k \mid i,k \mid j}\mu(k))}&\\
=&\prod_{d=1}^{n}\prod_{k=1}^{\lfloor\frac{n}{d}\rfloor}\prod_{i=1}^{\lfloor\frac{n}{dk}\rfloor}\prod_{j=1}^{\lfloor\frac{m}{dk}\rfloor}({ijdk^2})^{({ijdk^2}\mu(k))}&\\
\end{aligned}
$$

令 $x=dk$：
$$
\begin{aligned}
\text{原式}
=&\prod_{d=1}^{n}\prod_{k=1}^{\lfloor\frac{n}{d}\rfloor}\prod_{i=1}^{\lfloor\frac{n}{x}\rfloor}\prod_{j=1}^{\lfloor\frac{m}{x}\rfloor}({ijxk})^{({ijxk}\mu(k))}&\\
=&\prod_{x=1}^{n}\prod_{k\mid x}\prod_{i=1}^{\lfloor\frac{n}{x}\rfloor}\prod_{j=1}^{\lfloor\frac{m}{x}\rfloor}({ijxk})^{({ijxk}\mu(k))}&\\
=&\prod_{x=1}^{n}\prod_{k\mid x}{(\prod_{i=1}^{\lfloor\frac{n}{x}\rfloor}\prod_{j=1}^{\lfloor\frac{m}{x}\rfloor}({ijxk})^{(ij)})}^{xk\mu(k)}&\\
\end{aligned}
$$

令 $f(n)=\sum_{i=1}^{n}i,g(n)=\prod_{i=1}^{n}i^i$。

令：
$$
\begin{aligned}
P(n,m)
=&\prod_{i=1}^{n}\prod_{j=1}^{m}{ij}^{ij}&\\
=&\prod_{i=1}^{n}\prod_{j=1}^{m}{(i^i)}^j{(j^j)}^i&\\
=&g(n)^{f(m)}f(m)^{g(n)}
\end{aligned}
$$

所以：
$$
\begin{aligned}
\text{原式}=&\prod_{x=1}^{n}\prod_{k\mid x}
(P(\lfloor\frac{n}{x}\rfloor,\lfloor\frac{m}{x}\rfloor)xk^{f(\lfloor\frac{n}{x}\rfloor)f(\lfloor\frac{m}{x}\rfloor)})^{xk\mu(k)}
\end{aligned}
$$

令 $s(n)=\sum_{d\mid n}d\mu(d),t(n)=\prod_{d\mid n}d^{d\mu(d)}$。

知：
$$
\begin{aligned}
\text{原式}=\prod_{x=1}^{n}P(\lfloor\frac{n}{x}\rfloor,\lfloor\frac{m}{x}\rfloor)^{s(x)x}
(x^{s(x)}t(x))^{f(\lfloor\frac{n}{x}\rfloor)f(\lfloor\frac{m}{x}\rfloor)x}
\end{aligned}
$$

令 $h(x)=s(x)x,p(x)={x^{s(x)}t(x)}^x$。

$$
\text{原式}=\prod_{x=1}^{n}P(\lfloor\frac{n}{x}\rfloor,\lfloor\frac{m}{x}\rfloor)^{h(x)}
p(x)^{f(\lfloor\frac{n}{x}\rfloor)f(\lfloor\frac{m}{x}\rfloor)}
$$

预处理前缀和，前缀积，前缀积逆元。\
数论分块即可。

---

## 作者：Warriors_Cat (赞：1)

[洛谷题面传送门](https://www.luogu.com.cn/problem/P7486)。

题意：

* $T$ 次询问 $\prod\limits_{i=l}^r\prod\limits_{j=l}^r \operatorname{lcm}(i, j)^{\operatorname{lcm}(i,j)} \bmod 32465177$。

* $1 \le l \le r \le n \le 10^6$，$T \le 10$。

来道莫比乌斯反演题练练推式子手感。

---

Solution：

可以容斥转化为算 

$$\begin{aligned}
\prod\limits_{i=1}^n\prod\limits_{j=1}^m \operatorname{lcm}(i, j)^{\operatorname{lcm}(i,j)}
\end{aligned}$$

不妨设 $n \le m$。

$$\begin{aligned}
&=\prod_{d=1}^n\prod_{i=1}^n\prod_{j=1}^m\left(\dfrac{ij}{d}\right)^{\frac{ij}{d}[\gcd(i, j)=d]}
\\&=\prod_{d=1}^n\prod_{i=1}^{\left\lfloor\frac{n}{d}\right\rfloor}\prod_{j=1}^{\left\lfloor\frac{m}{d}\right\rfloor}(ijd)^{ijd[\gcd(i, j)=1]}
\\&=\prod_{d=1}^n\prod_{i=1}^{\left\lfloor\frac{n}{d}\right\rfloor}\prod_{j=1}^{\left\lfloor\frac{m}{d}\right\rfloor}(ijd)^{ijd\sum\limits_{k\mid \gcd(i, j)}\mu(k)}
\\&=\prod_{d=1}^n\prod_{k=1}^{\left\lfloor\frac{n}{d}\right\rfloor}\prod_{i=1}^{\left\lfloor\frac{n}{kd}\right\rfloor}\prod_{j=1}^{\left\lfloor\frac{m}{kd}\right\rfloor}(ijk^2d)^{ijk^2d\mu(k)}
\\&=\prod_{T=1}^n\prod_{k\mid T}\prod_{i=1}^{\left\lfloor\frac{n}{T}\right\rfloor}\prod_{j=1}^{\left\lfloor\frac{m}{T}\right\rfloor}(ijkT)^{ijkT\mu(k)}
\end{aligned}$$

到这里我们已经发现有很多量可以直接计算了。

具体地，设：

$$S(n) = \sum_{i=1}^ni= \dfrac{n(n+1)}{2}$$

$$f(n) = \prod_{i=1}^n i^i$$

$$F(n, m)=\prod_{i=1}^n\prod_{j=1}^m (ij)^{ij} = f(n)^{S(m)}\cdot f(m)^{S(n)}$$

$$g(n) = \sum_{k\mid n} k\mu(k)$$

$$h(n) = n^{g(n)}\cdot\prod_{k\mid n}k^{k\mu(k)}$$

于是上式就被我们化简为：

$$\prod_{T=1}^n \left(F(\left\lfloor\frac{n}{T}\right\rfloor, \left\lfloor\frac{m}{T}\right\rfloor)^{Tg(T)}\cdot h(T)^{T\cdot S(\left\lfloor\frac{n}{T}\right\rfloor)S(\left\lfloor\frac{m}{T}\right\rfloor)}\right)$$

这些函数及其前缀和/积都可以预处理，然后直接上数论分块。

over，时间复杂度为 $\mathcal{O}(n(\log n + \log p) + t\sqrt n (\log n + \log p))$。

---

Code：

```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
#define rep(i, x, y) for(int i = x; i <= y; ++i)
inline int read(){
    int x = 0, f = 1; char ch = getchar();
    while(ch < '0' || ch > '9'){ if(ch == '-') f = -1; ch = getchar(); }
    while(ch >= '0' && ch <= '9'){ x = x * 10 + (ch ^ 48); ch = getchar(); }
    return x * f;
}
const int N = 1000010, mod = 32465177;
int T, n, L, R, pri[N], len, mu[N], f[N], g[N], h[N], G[N], H[N]; bool vis[N];
inline int fpow (int x, int p){
	int ans = 1;
	for(; p; p >>= 1, x = 1ll * x * x % mod) if(p & 1) ans = 1ll * ans * x % mod;
	return ans;
}
inline void sieve(int n){
	mu[1] = f[1] = g[1] = h[1] = H[0] = 1; G[0] = 0;
	rep(i, 2, n){
		if(!vis[i]) pri[++len] = i, mu[i] = -1, g[i] = mod - i;
		for(int j = 1; j <= len && i * pri[j] <= n; ++j){
			vis[i * pri[j]] = 1;
			if(i % pri[j] == 0){
				mu[i * pri[j]] = 0;
				g[i * pri[j]] = g[i];
				break;
			}
			mu[i * pri[j]] = -mu[i];
			g[i * pri[j]] = 1ll * g[i] * g[pri[j]] % (mod - 1);
		}
	}
	f[0] = 1; h[0] = 1; rep(i, 1, n) f[i] = 1ll * f[i - 1] * fpow(i, i) % mod, h[i] = 1;
	rep(i, 1, n) rep(j, 1, n / i) h[i * j] = 1ll * h[i * j] * fpow(i, i * mu[i] + mod - 1) % mod;
	rep(i, 1, n) G[i] = 1ll * i * g[i] % (mod - 1), H[i] = fpow(1ll * fpow(i, g[i]) * h[i] % mod, i);
	rep(i, 2, n) G[i] = (G[i] + G[i - 1]) % (mod - 1), H[i] = 1ll * H[i] * H[i - 1] % mod;
}
inline int S(int n){ return 1ll * n * (n + 1) / 2 % (mod - 1); }
inline int F(int n, int m){ return 1ll * fpow(f[n], S(m)) * fpow(f[m], S(n)) % mod; }
inline int calc(int n, int m){
	int ans = 1;
	for(int i = 1, j; i <= n; i = j + 1){
		j = min(n / (n / i), m / (m / i));
		int A = fpow(F(n / i, m / i), (G[j] - G[i - 1] + mod - 1) % (mod - 1));
		int B = fpow(1ll * H[j] * fpow(H[i - 1], mod - 2) % mod, 1ll * S(n / i) * S(m / i) % (mod - 1));
		ans = 1ll * ans * A % mod * B % mod;
	}
	return ans;
}
inline int solve(int n, int m){
	int A = calc(n - 1, n - 1), B = calc(m, m), C = calc(n - 1, m);
	return 1ll * A * B % mod * fpow(1ll * C * C % mod, mod - 2) % mod;
}
inline void mian(){
	T = read(); n = read(); sieve(n);
	rep(i, 1, T){
		L = read(); R = read();
		printf("%d\n", solve(L, R));
	}
	return;
}
int main(){ int qwq = 1; while(qwq--) mian(); return 0; }
```


---

## 作者：_Fontainebleau_ (赞：1)

~~我是看题目名才做的~~

### 题意

- 给定正整数 $n$，$T$ 次询问。每次询问给定 $l,r$，求
- $$\prod_{i=l}^r\prod_{j=l}^r\operatorname{lcm}(i,j)^{\operatorname{lcm}(i,j)}$$
- $1\le{n}\le{10^6},1\le T\le10,1\le{l_i}\le{r_i}\le{n}$。答案对 $32465177$ 取模。

### 做法

我们考虑用 **容斥** 来做。令 $S(x,y)$ 表示 $\displaystyle\prod_{i=1}^x\prod_{j=1}^y\operatorname{lcm}(i,j)^{\operatorname{lcm}(i,j)}$。

![](https://cdn.luogu.com.cn/upload/image_hosting/g6l4sz58.png)

画类似上面的图（紫色表示要的，其他两种颜色表示多算的，要除掉），稍微推一下式子，就有：

$$\begin{aligned}\prod_{i=l}^r\prod_{j=l}^r\operatorname{lcm}(i,j)^{\operatorname{lcm}(i,j)}&=\frac{S(r,r)}{\displaystyle\prod_{i=1}^r\prod_{j=1}^{l-1}\operatorname{lcm}(i,j)^{\operatorname{lcm}(i,j)}\prod_{i=1}^{l-1}\prod_{j=l}^r\operatorname{lcm}(i,j)^{\operatorname{lcm}(i,j)}}\\&=\frac{\displaystyle S(r,r)\times{\prod_{i=1}^{l-1}\prod_{j=1}^{l-1}\operatorname{lcm}(i,j)^{\operatorname{lcm}(i,j)}}}{\displaystyle S(r,l-1)\prod_{i=1}^{l-1}\prod_{j=1}^r\operatorname{lcm}(i,j)^{\operatorname{lcm}(i,j)}}\\&=\frac{S(r,r)S(l-1,l-1)}{S\left(r,l-1\right){S(l-1,r)}}\end{aligned}$$

显然 $S(x,y)=S(y,x)$，所以不妨令 $x\le{y}$。然后就是很~~没~~有灵魂的推式子：

$$\begin{aligned}S(x,y)&=\prod_{i=1}^x\prod_{j=1}^y\operatorname{lcm}(i,j)^{\operatorname{lcm}(i,j)}\\&=\prod_{i=1}^x\prod_{j=1}^y\left(\frac{ij}{\gcd(i,j)}\right)^{\frac{ij}{\gcd{i,j}}}\\&=\prod_{d}\prod_{i=1}^x\prod_{j=1}^y\left(\frac{ij}d\right)^{\frac{ij\left[\gcd(i,j)=d\right]}{d}}&\color{pink}\text{枚举 }\gcd\\&=\prod_{d}\prod_{i=1}^{\left\lfloor\frac{x}d\right\rfloor}\prod_{j=1}^{\left\lfloor\frac{y}{d}\right\rfloor}\left(ijd\right)^{ijd\left[\gcd(i,j)=1\right]}&\color{pink}\text{枚举 }\frac{i}d,\frac{j}d\\&=\prod_{d}\prod_{i=1}^{\left\lfloor\frac{x}d\right\rfloor}\prod_{j=1}^{\left\lfloor\frac{y}d\right\rfloor}(ijd)^{ijd\sum_{k\mid{\gcd(i,j)}}\mu(k)}&\color{pink}\text{莫比乌斯反演}\\&=\prod_{d}\prod_{i=1}^{\left\lfloor\frac{x}d\right\rfloor}\prod_{j=1}^{\left\lfloor\frac{y}d\right\rfloor}\prod_{k\mid{\gcd(i,j)}}(ijd)^{ijd\mu(k)}\\&=\prod_{d}\prod_{k=1}^{\left\lfloor\frac{x}d\right\rfloor}\prod_{i=1}^{\left\lfloor\frac{x}{dk}\right\rfloor}\prod_{j=1}^{\left\lfloor\frac{y}{dk}\right\rfloor}{ijdk^2}^{ijdk^2\mu(k)}\\&=\prod_{t}\prod_{k\mid{t}}\prod_{i=1}^{\left\lfloor\frac{x}t\right\rfloor}\prod_{j=1}^{\left\lfloor\frac{y}t\right\rfloor}(ijkt)^{ijkt\mu(k)}\\&=\prod_{t}\prod_{k\mid{t}}\left[{\left(\prod_{i=1}^{\left\lfloor\frac{x}t\right\rfloor}\prod_{j=1}^{\left\lfloor\frac{y}t\right\rfloor}(ijkt)^{ij}\right)^{k\mu(k)}}\right]^t\end{aligned}$$

化简后面 $\left[\quad\right]$ 中的。令 $f(n)=\sum_{i=1}^n i,g(n)=\prod_{i=1}^n i^i,h(n,m)=\prod_{i=1}^n\prod_{j=1}^m(ij)^{ij}$，$f(n)$ 直接 $O(1)$ 计算；$g(n)$ 可以 $O(n\log{n})$ 预处理；$h(n)$ 可以 $O(\log{p})$ 快速幂计算。则：

$$\begin{aligned}h(n,m)&=\prod_{i=1}^n\prod_{j=1}^m(ij)^{ij}\\&=\prod_{i=1}^n\prod_{j=1}^mi^{ij}\cdot\prod_{i=1}^n\prod_{j=1}^mj^{ij}\\&=\prod_{i=1}^ni^{i\sum_{k=1}^mk}\cdot\prod_{i=1}^mi^{i\sum_{k=1}^nk}\\&=\left(\prod_{i=1}^ni^i\right)^{\sum_{k=1}^mk}\left(\prod_{i=1}^mi^i\right)^{\sum_{k=1}^nk}\\&=g(n)^{f(m)}\cdot g(m)^{f(n)} \end{aligned}$$

再看 $\prod_{i=1}^n\prod_{j=1}^m(kt)^{ij}=kt^{f(n)f(m)}$。代回原式：

$$\begin{aligned}&=\prod_{t}\prod_{k\mid{t}}\left[\left(h\left(\left\lfloor\frac{x}t\right\rfloor,\left\lfloor\frac{y}t\right\rfloor\right)(kt)^{f\left(\left\lfloor\frac{x}t\right\rfloor\right)f\left(\left\lfloor\frac{y}t\right\rfloor\right)}\right)^{k\mu(k)}\right]^t\\&=\prod_{t}\prod_{k\mid{t}}\left[h\left(\left\lfloor\frac{x}t\right\rfloor,\left\lfloor\frac{y}t\right\rfloor\right)^{k\mu(k)}k^{f\left(\left\lfloor\frac{x}t\right\rfloor\right)f\left(\left\lfloor\frac{y}t\right\rfloor\right)k{\mu(k)}}t^{f\left(\left\lfloor\frac{x}t\right\rfloor\right)f\left(\left\lfloor\frac{y}t\right\rfloor\right)k{\mu(k)}}\right]^t\end{aligned}$$

令 $\lambda(n)=\sum_{d\mid{n}}d\mu(d),\eta(n)=\prod_{d\mid{n}}d^{d\mu(d)},\beta(n)=\left(\eta(n)\cdot{n^{\lambda(n)}}\right)^n$，其中 $d\mu(d),d^{d\mu(d)}$ 在线性筛中求出，不过这样线性筛会变成 $O(n\log{p})$ 的，然后 $O(n\log{n})$ 枚举因子，求出 $\lambda,\eta$，之后 $O(n\log{p})$ 求出 $\beta$。则：

$$=\prod_{t}h\left(\left\lfloor\frac{x}t\right\rfloor,\left\lfloor\frac{y}t\right\rfloor\right)^{\lambda(t)t}\cdot\beta(t)^{f\left(\left\lfloor\frac{x}t\right\rfloor\right)f\left(\left\lfloor\frac{y}t\right\rfloor\right)}$$

然后数论分块就可以了。注意前面一部分在一块中的底数是相同的，我们预处理 $\lambda(t)t$ 的前缀和就好了；后面一部分在一块中质数是相同的，我们预处理 $\beta(t)$ 的前缀积就好了。

我们的数论分块是 $O(\sqrt{n}\log{p})$ 的。最后的总时间复杂度是 $O\left(n\log{p}+n\log{n}+t\sqrt{n}\log{p}+t\log{p}\right)$。

### 代码

```cpp
#include<bits/stdc++.h>
#define FOR(i,j,k)  for(int i=(j);i<=(k);i++)
using namespace std;
#define mod 32465177
int n,tc;
int g[1000006],k1[1000006],k2[1000006],lamb[1000006],eta[1000006],beta[1000006],mu[1000006],slmb[1000006],sbta[1000006];
int prime[1000006],cnt,invs[1000006];
bitset<1000006>used;
inline int read()
{
	int x=0,f=1;char c=getchar();
	while(c<'0'||c>'9'){if(c=='-')f=-f;c=getchar();}
	while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}
	return x*f;
}
inline int qp(int x,int y)
{
	int res=1,p=x;
	while(y)
	{
		if(y&1)	res=1ll*res*p%mod;
		p=1ll*p*p%mod;y>>=1;
	}
	return res;
}
inline int inv(int x){return qp(x,mod-2);}
inline void sieve(int n)
{
	g[1]=mu[1]=k1[1]=k2[1]=eta[1]=beta[1]=1;
	for(int i=2;i<=n;i++)
	{
		eta[i]=1,g[i]=1ll*g[i-1]*qp(i,i%(mod-1))%mod;
		if(!used[i])	prime[++cnt]=i,mu[i]=-1;
		k1[i]=(i*mu[i]%(mod-1)+mod-1)%(mod-1);k2[i]=qp(i,k1[i]);
		for(int j=1;j<=cnt&&1ll*i*prime[j]<=n;j++)
		{
			used[i*prime[j]]=true;
			if(i%prime[j])	mu[i*prime[j]]=-mu[i];
			else	break;
		}
	}
	for(int i=1;i<=n;i++)
		for(int j=i;j<=n;j+=i)
			lamb[j]=(lamb[j]+k1[i])%(mod-1),eta[j]=1ll*eta[j]*k2[i]%mod;
	invs[0]=sbta[0]=1;
	for(int i=1;i<=n;i++)
	{
		slmb[i]=(slmb[i-1]+1ll*lamb[i]*i%(mod-1))%(mod-1);
		beta[i]=qp(1ll*eta[i]*qp(i,lamb[i])%mod,i%(mod-1));
		sbta[i]=1ll*beta[i]*sbta[i-1]%mod;
		invs[i]=inv(sbta[i]);
	}
}

inline int gets(int x){return 1ll*x*(x+1)/2%(mod-1);}
inline int getb(int l,int r){return 1ll*sbta[r]*invs[l-1]%mod;}
inline int getl(int l,int r){return (slmb[r]-slmb[l-1]+mod-1)%(mod-1);}
inline int geth(int l,int r){return 1ll*qp(g[l],gets(r))*qp(g[r],gets(l))%mod;}
inline int S(int n,int m)
{
	if(n>m)	swap(n,m);
	int res=1;
	for(int l=1,r;l<=n;l=r+1)
	{
		r=min(n/(n/l),m/(m/l));
		res=1ll*res*qp(geth(n/l,m/l),getl(l,r))%mod*qp(getb(l,r),1ll*gets(n/l)*gets(m/l)%(mod-1))%mod;
	}
	return res;
}
int main()
{
	tc=read(),n=read();
	sieve(n);
	while(tc--)
	{
		int l=read(),r=read();
		int a=1ll*S(r,r)*S(l-1,l-1)%mod,b=S(l-1,r);b=1ll*b*b%mod;
		printf("%d\n",1ll*a*inv(b)%mod);
	}
	return 0;
}
```

---

## 作者：User_Unauthorized (赞：1)

**[更好的阅读体验](https://www.cnblogs.com/User-Unauthorized/p/solution-P7486.html)**

## 题意
给定 $l, r$，求

$$\prod\limits_{i = l}^{r} \prod\limits_{j = l}^{r} \operatorname{lcm}\left(i, j\right)^{\operatorname{lcm}\left(i, j\right)} \bmod 32465177$$

（$1 \le l \le r \le 10^6, 1 \le T \le 10$）。

## 题解

设 $\operatorname{F}(n, m) = \prod\limits_{i = 1}^{n} \prod\limits_{j = 1}^{m} \operatorname{lcm}\left(i, j\right)^{\operatorname{lcm}\left(i, j\right)}$，那么容斥可得

$$\text{Ans} = \dfrac{\operatorname{F}(r, r) \times \operatorname{F}(l - 1, l - 1)}{\operatorname{F}(l - 1, r) \times \operatorname{F}(r, l - 1)}$$

下面考虑如何计算 $\operatorname{F}(n, m)$，注意，在下文的推导中，假定 $n \le m$。

$$\begin{aligned}
\operatorname{F}(n, m) &= \prod\limits_{i = 1}^{n} \prod\limits_{j = 1}^{m} \operatorname{lcm}\left(i, j\right)^{\operatorname{lcm}\left(i, j\right)} \\

&= \prod\limits_{i = 1}^{n} \prod\limits_{j = 1}^{m}
\left(\dfrac{i \cdot j}{\gcd\left(i, j\right)}\right)
^{\frac{i \cdot j}{\gcd\left(i, j\right)}} \\

&= \prod\limits_{d = 1}^{n}\prod\limits_{i = 1}^{n} \prod\limits_{j = 1}^{m}
\left(\dfrac{i \cdot j}{d}\right)
^{\left[\gcd\left(i, j\right) = d\right]\frac{i \cdot j}{d}} \\

&= \prod\limits_{d = 1}^{n}\prod\limits_{i = 1}^{n} \prod\limits_{j = 1}^{m}
\left(d \dfrac{i}{d} \dfrac{j}{d}\right)
^{\left[\gcd\left(i, j\right) = d\right]d \frac{i}{d} \frac{j}{d}} \\

&= \prod\limits_{d = 1}^{n}\prod\limits_{i = 1}^{\left\lfloor\frac{n}{d}\right\rfloor} 
\prod\limits_{j = 1}^{\left\lfloor\frac{m}{d}\right\rfloor}
\left(ijd\right)^{\left[\gcd\left(i, j\right) = 1\right]ijd} \\

&= \prod\limits_{d = 1}^{n}\prod\limits_{i = 1}^{\left\lfloor\frac{n}{d}\right\rfloor} 
\prod\limits_{j = 1}^{\left\lfloor\frac{m}{d}\right\rfloor} 
\left(ijd\right)
^{\sum\limits_{t \mid \gcd\left(i, j\right)} \mu\left(t\right)ijd} \\

&= \prod\limits_{d = 1}^{n}
\prod\limits_{t = 1}^{\left\lfloor\frac{n}{d}\right\rfloor} 
\prod\limits_{i = 1}^{\left\lfloor\frac{n}{d}\right\rfloor} 
\prod\limits_{j = 1}^{\left\lfloor\frac{m}{d}\right\rfloor}
\left(ijd\right)
^{\left[t \mid i \land t \mid j\right] \mu\left(t\right)ijd} \\

&= \prod\limits_{d = 1}^{n}
\prod\limits_{t = 1}^{\left\lfloor\frac{n}{d}\right\rfloor} 
\prod\limits_{i = 1}^{\left\lfloor\frac{n}{dt}\right\rfloor} 
\prod\limits_{j = 1}^{\left\lfloor\frac{m}{dt}\right\rfloor}
\left(ijdt^2\right)
^{\mu\left(t\right)ijdt^2} \\

&= \prod\limits_{T = 1}^{n}
\prod\limits_{p \mid T}
\prod\limits_{i = 1}^{\left\lfloor\frac{n}{T}\right\rfloor} 
\prod\limits_{j = 1}^{\left\lfloor\frac{m}{T}\right\rfloor}
\left(ijTp\right)
^{ijTp\mu\left(p\right)} \\
\end{aligned}$$

下面考虑计算该式。

设 $\operatorname{w}(n) = \prod\limits_{i = 1}^{n} i^i, \operatorname{S}(n) = \sum\limits_{i = 1}^{n} i = \dfrac{i \left(i + 1\right)}{2}, \operatorname{G}(n, m) = \prod\limits_{i = 1}^{n}\prod\limits_{j = 1}^{m} \left(ij\right)^{ij}$，那么可得

$$\begin{aligned}
\operatorname{G}(n, m) &= \prod\limits_{i = 1}^{n}
\prod\limits_{j = 1}^{m}
\left(ij\right)^{ij} \\

&= \prod\limits_{i = 1}^{n}
\prod\limits_{j = 1}^{m}
i^{ij} 
\times
\prod\limits_{i = 1}^{n}
\prod\limits_{j = 1}^{m}
j^{ij} \\

&= \prod\limits_{i = 1}^{n}
\prod\limits_{j = 1}^{m}
\left(i^i\right)^j
\times
\prod\limits_{i = 1}^{n}
\prod\limits_{j = 1}^{m}
\left(j^j\right)^i \\

&= \operatorname{w}(n)^{\operatorname{S}(m)}
\times
\operatorname{w}(m)^{\operatorname{S}(n)}
\end{aligned}$$

代入原式可得

$$\begin{aligned}
\operatorname{F}\left(n, m\right) &= 
\prod\limits_{T = 1}^{n}
\prod\limits_{p \mid T}
\prod\limits_{i = 1}^{\left\lfloor\frac{n}{T}\right\rfloor} 
\prod\limits_{j = 1}^{\left\lfloor\frac{m}{T}\right\rfloor}
\left(ijTp\right)
^{ijTp\mu\left(p\right)} \\

&= \prod\limits_{T = 1}^{n}
\prod\limits_{p \mid T}
\left(\operatorname{G}\left(\dfrac{n}{d}, \dfrac{m}{d}\right) \times 
\prod\limits_{i = 1}^{\left\lfloor\frac{n}{T}\right\rfloor} 
\prod\limits_{j = 1}^{\left\lfloor\frac{m}{T}\right\rfloor}
\left(Tp\right)^{ij}\right)
^{Tp\mu\left(p\right)} \\

&= \prod\limits_{T = 1}^{n}
\prod\limits_{p \mid T}
\operatorname{G}\left(\dfrac{n}{d}, \dfrac{m}{d}\right)^{Tp\mu\left(p\right)} \times
\prod\limits_{i = 1}^{\left\lfloor\frac{n}{T}\right\rfloor} 
\prod\limits_{j = 1}^{\left\lfloor\frac{m}{T}\right\rfloor}
\left(Tp\right)^{ijTp\mu\left(p\right)} \\

&= \prod\limits_{T = 1}^{n}
\prod\limits_{p \mid T}
\operatorname{G}\left(\dfrac{n}{d}, \dfrac{m}{d}\right)^{Tp\mu\left(p\right)} \times 
\prod\limits_{i = 1}^{\left\lfloor\frac{n}{T}\right\rfloor} 
\prod\limits_{j = 1}^{\left\lfloor\frac{m}{T}\right\rfloor}
\left(\left(Tp\right)^{Tp\mu\left(p\right)}\right)^{ij} \\

&= \prod\limits_{T = 1}^{n}
\prod\limits_{p \mid T}
\operatorname{G}\left(\dfrac{n}{d}, \dfrac{m}{d}\right)^{Tp\mu\left(p\right)} \times \left(\left(Tp\right)^{Tp\mu\left(p\right)}\right)^{\operatorname{S}\left(n\right) \operatorname{S}\left(m\right)} \\
\end{aligned}$$

记 $\displaystyle \operatorname{g}(n) = n \sum\limits_{p \mid n} p\mu\left(p\right), \operatorname{h}(n) = \prod\limits_{p \mid n} \left(np\right)^{n p \mu\left(p\right)} = \left(\prod\limits_{p \mid n} \left(np\right)^{p \mu\left(p\right)} \right)^n$，那么可得

$$\operatorname{F}\left(n, m\right) = 
\prod\limits_{T = 1}^{n}
\operatorname{G}\left(\dfrac{n}{d}, \dfrac{m}{d}\right)^{g(T)} \times \operatorname{h}(T)^{\operatorname{S}\left(n\right) \operatorname{S}\left(m\right)}$$

预处理出 $g$ 的前缀和，$h$ 的前缀积再利用整除分块即可通过本题。

直接枚举倍数预处理两个函数，时间复杂度 $\mathcal{O}(n \ln n \log n + T\sqrt{n}\log n)$，可以通过本题。

## Code
```cpp
//Luogu - P7486
#include <bits/stdc++.h>

typedef long long valueType;
typedef std::vector<valueType> ValueVector;

constexpr valueType MOD = 32465177;

template<typename T1, typename T2, typename T3 = valueType>
void Inc(T1 &a, T2 b, const T3 &mod = MOD) {
    a = a + b;

    if (a >= mod)
        a -= mod;
}

template<typename T1, typename T2, typename T3 = valueType>
void Dec(T1 &a, T2 b, const T3 &mod = MOD) {
    a = a - b;

    if (a < 0)
        a += mod;
}

template<typename T1, typename T2, typename T3 = valueType>
T1 sum(T1 a, T2 b, const T3 &mod = MOD) {
    return a + b >= mod ? a + b - mod : a + b;
}

template<typename T1, typename T2, typename T3 = valueType>
T1 sub(T1 a, T2 b, const T3 &mod = MOD) {
    return a - b < 0 ? a - b + mod : a - b;
}

template<typename T1, typename T2, typename T3 = valueType>
T1 mul(T1 a, T2 b, const T3 &mod = MOD) {
    return (long long) a * b % mod;
}

template<typename T1, typename T2, typename T3 = valueType>
void Mul(T1 &a, T2 b, const T3 &mod = MOD) {
    a = (long long) a * b % mod;
}

template<typename T1, typename T2, typename T3 = valueType>
T1 pow(T1 a, T2 b, const T3 &mod = MOD) {
    T1 result = 1;

    while (b > 0) {
        if (b & 1)
            Mul(result, a, mod);

        Mul(a, a, mod);
        b = b >> 1;
    }

    return result;
}

class LineSieve {
public:
    typedef std::vector<valueType> container;
    typedef std::vector<bool> bitset;

private:
    valueType N;
    bitset isPrime;
    container primeList;
    container mobius, g, h, w;

public:
    explicit LineSieve(valueType _size_) : N(_size_), isPrime(N + 1, true), mobius(N + 1), g(N + 1, 0), h(N + 1, 1),
                                           w(N + 1, 1) {
        primeList.reserve((size_t) std::ceil(std::log((long double) (_size_ + 1))));
        mobius[1] = 1;
        for (valueType i = 2; i <= N; ++i) {
            if (isPrime[i]) {
                primeList.push_back(i);
                mobius[i] = -1;
            }

            for (auto const &iter: primeList) {
                valueType const t = i * iter;

                if (t > N)
                    break;

                isPrime[t] = false;

                if (i % iter == 0) {
                    mobius[t] = 0;

                    break;
                } else {
                    mobius[t] = -mobius[i];
                }
            }
        }

        for (valueType i = 1; i <= N; ++i) {
            for (valueType j = i; j <= N; j += i) {
                Inc(g[j], mul(i, mobius[i] + (MOD - 1), MOD - 1), MOD - 1);
                Mul(h[j], pow(mul(i, j), mul(mobius[i] + (MOD - 1), i, MOD - 1), MOD));
            }

            Mul(g[i], i, MOD - 1);

            h[i] = pow(h[i], i);

            Mul(h[i], h[i - 1]);
            Inc(g[i], g[i - 1], MOD - 1);

            w[i] = pow(i, i);
            Mul(w[i], w[i - 1]);
        }
    }

    valueType G(valueType n) const {
        return g[n];
    }

    valueType H(valueType n) const {
        return h[n];
    }

    valueType W(valueType n) const {
        return w[n];
    }
};

class Inverse {
private:
    valueType size, mod;

    ValueVector data;

public:
    explicit Inverse(valueType N, valueType mod = MOD) : size(N), mod(mod), data(N + 1, 0) {
        data[1] = 1;

        for (valueType i = 2; i <= N; ++i)
            data[i] = mul((mod - mod / i), data[mod % i], mod);
    }

    valueType operator()(valueType i) const {
        i %= mod;

        if (i <= size)
            return data[i];

        return mul((mod - mod / i), operator()(mod % i), mod);
    }
};

constexpr valueType V = 1e6 + 5;

LineSieve sieve(V);
Inverse Inv(V, MOD);


valueType S(valueType n, valueType mod = MOD) {
    return (long long) n * (n + 1) / 2 % mod;
}

valueType G(valueType n, valueType m) {
    return mul(pow(sieve.W(n), S(m, MOD - 1)), pow(sieve.W(m), S(n, MOD - 1)));
}

valueType F(valueType n, valueType m) {
    if (n > m)
        std::swap(n, m);

    valueType result = 1;

    valueType l = 1, r;

    while (l <= n) {
        r = std::min(n / (n / l), m / (m / l));

        Mul(result, pow(G(n / l, m / l), sub(sieve.G(r), sieve.G(l - 1), MOD - 1)));

        Mul(result, pow(mul(sieve.H(r), Inv(sieve.H(l - 1))), mul(S(n / l, MOD - 1), S(m / l, MOD - 1), MOD - 1)));

        l = r + 1;
    }

    return result;
}

int main() {
    valueType T, N;

    std::cin >> T >> N;

    for (valueType i = 0; i < T; ++i) {
        valueType l, r;

        std::cin >> l >> r;

        valueType const result = mul(mul(F(l - 1, l - 1), F(r, r)), Inv(mul(F(l - 1, r), F(r, l - 1))));

        std::cout << result << std::endl;
    }

    return 0;
}
```

---

## 作者：VinstaG173 (赞：1)

基础莫反推式子题。

显然题目要求的式子

$$\begin{aligned}
\prod_{i=1}^n \prod_{j=1}^m \operatorname{lcm}(i,j)^{\operatorname{lcm}(i,j)}&=\prod_d \prod_{i=1}^n \prod_{j=1}^m \left( \dfrac{ij}{d} \right)^{\frac{ij\left[ \gcd(i,j)=d \right]}{d}}\\
&=\prod_d \prod_{i=1}^{\left\lfloor \frac{n}{d} \right\rfloor} \prod_{j=1}^{\left\lfloor \frac{m}{d} \right\rfloor} \left( ijd \right)^{ijd\left[ \gcd(i,j)=1 \right]}\\
&=\prod_d \left( d^d \right)^{\sum_{i=1}^{\left\lfloor \frac{n}{d} \right\rfloor} \sum_{j=1}^{\left\lfloor \frac{m}{d} \right\rfloor}ij\left[ \gcd(i,j)=1 \right]} \left( \prod_{i=1}^{\left\lfloor \frac{n}{d} \right\rfloor} \prod_{j=1}^{\left\lfloor \frac{m}{d} \right\rfloor} (ij)^{ij\left[ \gcd(i,j)=1 \right]} \right)^{d},
\end{aligned}$$

设为

$$\prod_d \left( d^d \right)^{Sum \left( \left\lfloor \frac{n}{d} \right\rfloor,\left\lfloor \frac{m}{d} \right\rfloor \right)} \left( Pro \left( \left\lfloor \frac{n}{d} \right\rfloor,\left\lfloor \frac{m}{d} \right\rfloor \right) \right)^{d}$$

其中

$$\begin{aligned}
Sum \left( n,m \right)&=\sum_{i=1}^n \sum_{j=1}^m ij\left[ \gcd(i,j)=1 \right]\\
&=\sum_d d^2 \mu \left( d \right) \sum_{i=1}^{\left\lfloor \frac{n}{d} \right\rfloor} \sum_{j=1}^{\left\lfloor \frac{m}{d} \right\rfloor}ij
\end{aligned}$$

可以通过 P1829 里一样的方式解决，$O \left( \sqrt{n} \right)$。

$$\begin{aligned}
Pro \left( n,m \right)&=\prod_{i=1}^n \prod_{j=1}^m (ij)^{ij\left[ \gcd(i,j)=1 \right]}\\
&=\prod_{i=1}^n \prod_{j=1}^m (ij)^{ij\sum_{d\mid\gcd(i,j)}\mu(d)}\\
&=\prod_d \left( \prod_{i=1}^n \prod_{j=1}^m (ij)^{ij[d\mid\gcd(i,j)]} \right)^{\mu(d)}\\
&=\prod_d \left( \prod_{i=1}^{\left\lfloor \frac{n}{d} \right\rfloor} \prod_{j=1}^{\left\lfloor \frac{m}{d} \right\rfloor} (d^2ij)^{d^2ij} \right)^{\mu(d)}\\
&=\prod_d \left[ \left( d^2 \right)^{\sum_{i=1}^{\left\lfloor \frac{n}{d} \right\rfloor} \sum_{j=1}^{\left\lfloor \frac{m}{d} \right\rfloor}ij} \right]^{d^2\mu(d)} \left[ \prod_{i=1}^{\left\lfloor \frac{n}{d} \right\rfloor} \prod_{j=1}^{\left\lfloor \frac{m}{d} \right\rfloor} (ij)^{ij} \right]^{d^2\mu(d)}.
\end{aligned}$$

定义

$$f(x)=\prod_{i=1}^xi^i$$

则显然可以 $O \left( n\log{n} \right)$ 预处理。

此时

$$Pro(n,m)=\prod_d \left[ \left( d^2 \right)^{\sum_{i=1}^{\left\lfloor \frac{n}{d} \right\rfloor} \sum_{j=1}^{\left\lfloor \frac{m}{d} \right\rfloor}ij} \right]^{d^2\mu(d)} \left[ f\left( \left\lfloor \frac{n}{d} \right\rfloor \right)^{\frac{\left\lfloor \frac{m}{d} \right\rfloor \times \left( \left\lfloor \frac{m}{d} \right\rfloor +1 \right)}{2}} f\left( \left\lfloor \frac{m}{d} \right\rfloor \right)^{\frac{\left\lfloor \frac{n}{d} \right\rfloor \times \left( \left\lfloor \frac{n}{d} \right\rfloor +1 \right)}{2}} \right]^{d^2\mu(d)}$$

可以在 $O \left( \sqrt{n}\log n \right)$ 时间内计算。

再套回去

$$\prod_d \left( d^d \right)^{Sum \left( \left\lfloor \frac{n}{d} \right\rfloor,\left\lfloor \frac{m}{d} \right\rfloor \right)} \left( Pro \left( \left\lfloor \frac{n}{d} \right\rfloor,\left\lfloor \frac{m}{d} \right\rfloor \right) \right)^{d}$$

就可以在算出 $Sum$ 和 $Pro$ 后计算答案了，总时间复杂度 $O \left(n\log n+tn^{\frac{3}{4}} \log n \right)$。还可以使用 `map` 存储已经计算的答案以避免重复计算 $l,r$ 很大的询问，或暴力处理 $r-l$ 较小但 $l,r$ 很大的询问，但没有必要，因为 std 懒得这么干（

Code:
```cpp
#include<cstdio>
#define rg register
#define ll long long
#define min(a,b) ((a<b)?a:b)
const int ntf=32465177;
const int NtF=32465176;
ll pd[1000003];
ll pm[1000003];
ll mu[1000003];
int mp[1000003];
int pr[1000003],cnt;
inline ll qpw(ll x,int v)
{
	ll r=1;
	while(v)
	{
		(v&1)&&(r=r*x%ntf);
		x=x*x%ntf,v>>=1;
	}
	return r;
}
inline void prework(int n)
{
	mu[1]=1;pd[0]=pd[1]=1,pm[0]=pm[1]=1;
	for(rg int i=2;i<=n;++i)
	{
		if(!mp[i])
		{
			mp[i]=i,mu[i]=-1,pr[++cnt]=i;
		}
		for(rg int j=1;j<=cnt&&(i*pr[j])<=n;++j)
		{
			mp[i*pr[j]]=pr[j];
			if(mp[i]==pr[j])
			{
				mu[i*pr[j]]=0;break;
			}
			mu[i*pr[j]]=-mu[i];
		}
		mu[i]=(mu[i]*i*i%NtF+NtF)%NtF;
	}
	for(rg int i=2;i<=n;++i)
	{
		pd[i]=pd[i-1]*qpw(i,i)%ntf;
		pm[i]=pm[i-1]*qpw((ll)i*i%ntf,mu[i])%ntf;
		mu[i]=(mu[i-1]+mu[i])%NtF;
	}
}
inline ll pt(ll n)
{
	return (n*(n+1)>>1)%NtF;
}
inline ll ps(ll n,ll m)
{
	return pt(n)*pt(m)%NtF;
}
inline ll sum(int n,int m)
{
	ll res=0;
	for(rg int i=1,j;i<=n;i=j+1)
	{
		j=min(n/(n/i),m/(m/i));
		res=(res+(mu[j]-mu[i-1])*ps(n/i,m/i)%NtF+NtF)%NtF;
	}
	return res;
}
inline ll pro(int n,int m)
{
	ll res=1;
	for(rg int i=1,j;i<=n;i=j+1)
	{
		j=min(n/(n/i),m/(m/i));
		res=res*qpw(pm[j]*qpw(pm[i-1],ntf-2)%ntf,ps(n/i,m/i))%ntf;
		res=res*qpw(qpw(pd[n/i],pt(m/i))*qpw(pd[m/i],pt(n/i))%ntf,(mu[j]-mu[i-1])%NtF+NtF)%ntf;
	}
	return res;
}
inline ll solve(int n,int m)
{
	ll res=1;
	for(rg int i=1,j;i<=n;i=j+1)
	{
		j=min(n/(n/i),m/(m/i));
		res=res*qpw(pd[j]*qpw(pd[i-1],ntf-2)%ntf,sum(n/i,m/i))%ntf;
		res=res*qpw(pro(n/i,m/i),(pt(j)-pt(i-1))%NtF+NtF)%ntf;
	}
	return res;
}
int t,n,l,r;
int main()
{
	scanf(" %d %d",&t,&n);
	prework(n);
	while(t--)
	{
		scanf(" %d %d",&l,&r);
		printf("%lld\n",solve(r,r)*solve(l-1,l-1)%ntf*qpw(solve(l-1,r),ntf-3)%ntf);
	}
	return 0;
}
```

---

## 作者：Special_Judge (赞：0)

# P7486 「Stoi2031」彩虹 题解

非常好的一道题，推式子的过程有那种一步步抽丝剥茧的感觉。

## 题意

求：
$$
\prod_{i=l}^r \prod_{j=l}^r \operatorname{lcm}(i,j)^{\operatorname{lcm}(i,j)}
$$
对 $32465177$ 取模。

## 解法

看到这种式子当然是先容斥一波啦。求和求积什么的如果下界不是 $1$ 还是很难受的。

令：
$$
f(n,m)=\prod_{i=1}^n \prod_{j=1}^m \operatorname{lcm}(i,j)^{\operatorname{lcm}(i,j)}
$$
则：
$$
ans=\frac{f(r,r) \cdot f(l-1,l-1)}{f^2(l-1,r)}
$$
于是我们的任务就转化为求 $f(n,m)$。
$$
\begin{aligned}

&\quad \space \space f(n,m) \\

&=
\prod_{i=1}^n 
\prod_{j=1}^m 
\frac{i \cdot j}{\gcd(i,j)}^{\frac{i \cdot j}{\gcd(i,j)}} \\

&=\prod_{d=1}^{\min(n,m)}
\prod_{i=1}^n 
\prod_{j=1}^m 
\frac{i \cdot j}{d}^{\frac{i \cdot j}{d}[\gcd(i,j)=d]} \\

&=\prod_{d=1}^{\min(n,m)}
\prod_{i=1}^{\left \lfloor \frac n d \right \rfloor}
\prod_{j=1}^{\left \lfloor \frac m d \right \rfloor} 
(i \cdot j \cdot d)^{i \cdot j \cdot d[\gcd(i,j)=1]} \\

&=\prod_{d=1}^{\min(n,m)}
\prod_{i=1}^{\left \lfloor \frac n d \right \rfloor}
\prod_{j=1}^{\left \lfloor \frac m d \right \rfloor} 
(i \cdot j \cdot d)^{i \cdot j \cdot d\sum_{k \mid \gcd(i,j)}\mu(k)} \\

&=\prod_{d=1}^{\min(n,m)}
\prod_{i=1}^{\left \lfloor \frac n d \right \rfloor}
\prod_{j=1}^{\left \lfloor \frac m d \right \rfloor} 
\prod_{k \mid \gcd(i,j)}
(i \cdot j \cdot d)^{i \cdot j \cdot d \cdot \mu(k)} \\

&=\prod_{d=1}^{\min(n,m)}
\prod_{k=1}^{\min({\left \lfloor \frac n d \right \rfloor},{\left \lfloor \frac m d \right \rfloor})}
\prod_{i=1}^{\left \lfloor \frac{n}{dk} \right \rfloor}
\prod_{j=1}^{\left \lfloor \frac{m}{dk} \right \rfloor}
(i \cdot j \cdot d \cdot k^2)^{i \cdot j \cdot d \cdot k^2 \cdot \mu(k)} \\

&=\prod_{d=1}^{\min(n,m)}
\prod_{k=1}^{\min({\left \lfloor \frac n d \right \rfloor},{\left \lfloor \frac m d \right \rfloor})}
\left(
\prod_{i=1}^{\left \lfloor \frac{n}{dk} \right \rfloor}
\prod_{j=1}^{\left \lfloor \frac{m}{dk} \right \rfloor}
(i \cdot j)^{i \cdot j}

\space \cdot \space

\prod_{i=1}^{\left \lfloor \frac{n}{dk} \right \rfloor}
\prod_{j=1}^{\left \lfloor \frac{m}{dk} \right \rfloor}
(d \cdot k^2)^{i \cdot j}

\right)^{d \cdot k^2 \cdot \mu(k)}

\end{aligned}
$$
这个式子里面出现了一些可以化简的东西，让我们先对这些东西化简，然后再代回原式。

为了简便，下面我设 $s(x)=\dfrac{x \cdot (x+1)}{2}$。

---

$$
\begin{aligned}

\prod_{i=1}^{\left \lfloor \frac{n}{dk} \right \rfloor}
\prod_{j=1}^{\left \lfloor \frac{m}{dk} \right \rfloor}
(d \cdot k^2)^{i \cdot j}

&=(d \cdot k^2)^
{
\sum_{i=1}^{\left \lfloor \frac{n}{dk} \right \rfloor}
\sum_{j=1}^{\left \lfloor \frac{m}{dk} \right \rfloor}
(i \cdot j)
}

\end{aligned}
$$

下面我们对 $\sum_{i=1}^{\left \lfloor \frac{n}{dk} \right \rfloor}
\sum_{j=1}^{\left \lfloor \frac{m}{dk} \right \rfloor}
(i \cdot j)$ 进行化简。
$$
\begin{aligned}

\sum_{i=1}^{\left \lfloor \frac{n}{dk} \right \rfloor}
\sum_{j=1}^{\left \lfloor \frac{m}{dk} \right \rfloor}
(i \cdot j)

&=\sum_{i=1}^{\left \lfloor \frac{n}{dk} \right \rfloor} i
\sum_{j=1}^{\left \lfloor \frac{m}{dk} \right \rfloor} j \\

&=s(\left \lfloor \frac{n}{dk} \right \rfloor) \cdot s(\left \lfloor \frac{m}{dk} \right \rfloor)

\end{aligned}
$$
于是我们就有：
$$
\prod_{i=1}^{\left \lfloor \frac{n}{dk} \right \rfloor}
\prod_{j=1}^{\left \lfloor \frac{m}{dk} \right \rfloor}
(d \cdot k^2)^{i \cdot j}

=

(d \cdot k^2)^{s(\left \lfloor \frac{n}{dk} \right \rfloor) \cdot s(\left \lfloor \frac{m}{dk} \right \rfloor)}
$$

---

$\prod_{i=1}^{\left \lfloor \frac{n}{dk} \right \rfloor}
\prod_{j=1}^{\left \lfloor \frac{m}{dk} \right \rfloor}
(i \cdot j)^{i \cdot j}$ 这个式子同样可以化简。由于这个式子后面需要使用，令：
$$
h(n,m)=\prod_{i=1}^{n}
\prod_{j=1}^{m}
(i \cdot j)^{i \cdot j}
$$
于是原式就是 $h(\left \lfloor \frac{n}{dk} \right \rfloor,\left \lfloor \frac{m}{dk} \right \rfloor)$，接下来我们尝试化简 $h$。
$$
\begin{aligned}

h(n,m)&=\prod_{i=1}^{n}
\prod_{j=1}^{m}
(i \cdot j)^{i \cdot j} \\

&=\prod_{i=1}^{n}
\prod_{j=1}^{m}
i^{i \cdot j}

\space \cdot \space 

\prod_{i=1}^{n}
\prod_{j=1}^{m}
j^{i \cdot j} \\

&=\prod_{i=1}^{n}
\prod_{j=1}^{m}
i^{i^j}

\space \cdot \space 

\prod_{j=1}^{m}
\prod_{i=1}^{n}
j^{j^i} \\

&=\left (\prod_{i=1}^{n}i^i \right )^{s(m)} \space \cdot \space \left (\prod_{j=1}^{m}j^j \right )^{s(n)}

\end{aligned}
$$
设：
$$
g(x)=\prod_{i=1}^xi^i
$$
那么我们可以用 $O(n \log n)$ 的时间复杂度预处理出 $g$。

于是：
$$
h(n,m)=g(n)^{s(m)} \cdot g(m)^{s(n)}
$$
所以我们可以用 $\Theta(\log(n^2))=\Theta(2\log n )=O(\log n)$ 的时间复杂度计算 $h$。

---

让我们回到原式：
$$
=\prod_{d=1}^{\min(n,m)}
\prod_{k=1}^{\min({\left \lfloor \frac n d \right \rfloor},{\left \lfloor \frac m d \right \rfloor})}
\left(
h(\left \lfloor \frac{n}{dk} \right \rfloor,\left \lfloor \frac{m}{dk} \right \rfloor)

\space \cdot \space

(d \cdot k^2)^{s(\left \lfloor \frac{n}{dk} \right \rfloor) \cdot s(\left \lfloor \frac{m}{dk} \right \rfloor)}
\right)^{d \cdot k^2 \cdot \mu(k)} \\
$$
可以发现，式子中 $dk$ 频繁出现，考虑经典优化：令 $T=dk$，同时改为枚举 $T$，则：
$$
\begin{aligned}

&=\prod_{T=1}^{\min(n,m)}
\prod_{k \mid T}
\left(
h(\left \lfloor \frac n T \right \rfloor,\left \lfloor \frac m T \right \rfloor)

\space \cdot \space

(T \cdot k)^{s(\left \lfloor \frac n T \right \rfloor) \cdot s(\left \lfloor \frac m T \right \rfloor)}
\right)^{T \cdot k \cdot \mu(k)} \\

&=
\prod_{T=1}^{\min(n,m)}
\prod_{k \mid T}
\left(h(\left \lfloor \frac n T \right \rfloor,\left \lfloor \frac m T \right \rfloor)\right)^{T\cdot k \cdot \mu(k)}

\space \cdot \space

\prod_{T=1}^{\min(n,m)}
\prod_{k \mid T}
\left((T \cdot k)^{T \cdot k \cdot \mu(k)} \right )^{s(\left \lfloor \frac n T \right \rfloor) \cdot s(\left \lfloor \frac m T \right \rfloor)} \\

&=
\prod_{T=1}^{\min(n,m)}
\prod_{k \mid T}
\left(h(\left \lfloor \frac n T \right \rfloor,\left \lfloor \frac m T \right \rfloor)\right)^{T\cdot k \cdot \mu(k)}

\space \cdot \space

\prod_{T=1}^{\min(n,m)}
\left(\prod_{k \mid T}
(T \cdot k)^{T \cdot k \cdot \mu(k)}\right)^{s(\left \lfloor \frac n T \right \rfloor) \cdot s(\left \lfloor \frac m T \right \rfloor)} \\

\end{aligned}
$$
让我们先来看前半部分：
$$
\prod_{T=1}^{\min(n,m)}
\prod_{k \mid T}
\left(h(\left \lfloor \frac n T \right \rfloor,\left \lfloor \frac m T \right \rfloor)\right)^{T\cdot k \cdot \mu(k)}

=

\prod_{T=1}^{\min(n,m)}
\left(h(\left \lfloor \frac n T \right \rfloor,\left \lfloor \frac m T \right \rfloor)\right)
^{T\sum_{k \mid T}k \cdot \mu(k)}
$$
这个 $T\sum_{k \mid T}k \cdot \mu(k)$ 看起来就很好欺负，不妨设 $r(T)=T\sum_{k \mid T}k \cdot \mu(k)$，那么我们可以通过枚举倍数预处理出 $r$，并且处理出 $r$ 的前缀和，预处理的总复杂度是 $O(n \log n)$。

于是：
$$
\prod_{T=1}^{\min(n,m)}
\left(h(\left \lfloor \frac n T \right \rfloor,\left \lfloor \frac m T \right \rfloor)\right)
^{T\sum_{k \mid T}k \cdot \mu(k)}

=

\prod_{T=1}^{\min(n,m)}
\left(h(\left \lfloor \frac n T \right \rfloor,\left \lfloor \frac m T \right \rfloor)\right)
^{r(T)}
$$
我们就可以愉快地用数论分块求值了。

接下来让我们看看后半部分：

虽然 $T$ 和 $k$ 全部都混在了一起，但是很容易看出来 $\prod_{k \mid T}(T \cdot k)^{T \cdot k \cdot \mu(k)}$ 是一个枚举倍数可以预处理的东西，我们令：
$$
q(T)=\prod_{k \mid T}(T \cdot k)^{T \cdot k \cdot \mu(k)}
$$
但是此时预处理的复杂度较高，由于带有指数，需要使用快速幂来计算，所以预处理的复杂度是 $O(n \log^2n)$ 的。

尝试化简一下 $q$。
$$
\begin{aligned}

q(T)&=\prod_{k \mid T}(T \cdot k)^{T \cdot k \cdot \mu(k)} \\

&=(\prod_{k \mid T}(T \cdot k)^{k \cdot \mu(k)})^T \\

&=(\prod_{k \mid T}k^{k \cdot \mu(k)} \cdot \prod_{k \mid T}T^{k \cdot \mu(k)})^T \\

&=(\prod_{k \mid T}k^{k \cdot \mu(k)})^T \cdot (T^{\sum_{k \mid T}k \cdot \mu(k)})^T \\

&=(\prod_{k \mid T}k^{k \cdot \mu(k)})^T \cdot T^{r(T)}

\end{aligned}
$$
我们可以先用 $O(n \log n)$ 处理出 $k^{k \cdot \mu(k)}$ 的值并存储下来，然后 $O(n \log n)$ 处理出 $\prod_{k \mid T}k^{k \cdot \mu(k)}$ 的值，在此基础上 $O(n \log n)$ 处理出 $(\prod_{k \mid T}k^{k \cdot \mu(k)})^T$，最后乘上一个 $T^{r(T)}$，这一步仍然是 $O(n \log n)$ 的。所以预处理 $q$ 的总复杂度是 $O(n \log n)$ 的，可以接受。

所以后半部分就等于：
$$
\prod_{T=1}^{\min(n,m)}
(q(T))^{s(\left \lfloor \frac n T \right \rfloor) \cdot s(\left \lfloor \frac m T \right \rfloor)}
$$
我们只需要处理 $q$ 的前缀积，这个式子就可以数论分块计算了。

综合起来，原式就等于：
$$
\prod_{T=1}^{\min(n,m)}
\left(h(\left \lfloor \frac n T \right \rfloor,\left \lfloor \frac m T \right \rfloor)\right)^{r(T)}

\space \cdot \space

q(T)^{s(\left \lfloor \frac n T \right \rfloor) \cdot s(\left \lfloor \frac m T \right \rfloor)}
$$
数论分块求解即可，回答单个询问的复杂度是 $O(\sqrt{n} \log n)$，算上预处理和多测，总复杂度是 $O(n \log n+T\sqrt{n} \log n)$。

做完了。

## Code

请注意全程开 `__int128`，并且快速幂注意处理指数是负数的情况，还有在指数上面的值别取模。

```cpp
#include<bits/stdc++.h>

#define here(x) cout<<"here "<<x<<endl;
#define putlist(x,st,ed) {for(int ind=st;ind<=ed;ind++)cout<<x[ind]<<' ';cout<<endl;}
#define putstl(x) {for(auto TeMp:x)cout<<TeMp<<' ';cout<<endl;}
#define putsize(x) cout<<sizeof(x)*1.0/1024/1024<<" MB"<<endl;

#define MAXN_INT 2147483647
#define MAXN_LL 9223372036854775807

#define MOD 32465177
#define N 1000100
#define eps 1e-6

#define mp make_pair
#define pb push_back

#define int __int128

using namespace std;

int qpow(int x,int y)
{
	int res=1;
	bool f=0;
	if(y<0)f=1,y=-y; //注意处理指数是负数的情况
	while(y)
	{
		if(y&1)res=res*x%MOD;
		x=x*x%MOD;
		y>>=1;
	}
	return f?qpow(res,MOD-2):res; //注意处理指数是负数的情况
}

namespace IO
{
	int read()
	{
		int x=0,f=1;
		char ch=0;
		while(!isdigit(ch))
		{
			ch=getchar();
			if(ch=='-')f=-f;
		}
		while(isdigit(ch))
		{
			x=x*10+(ch^48);
			ch=getchar();
		}
		return x*f;
	}
	void print(int x)
	{
		if(x<0)
		{
			putchar('-');
			x=-x;
		}
		if(x>9)print(x/10);
		putchar(x%10^48);
	}
}
using namespace IO;

namespace Setup
{
	int s(int x)
	{
		return x*(x+1)/2;
	}
	
	vector<int>p;
	bitset<N>vis;
	int mu[N];
	void sieve(int lim) //线性筛预处理莫比乌斯函数
	{
		mu[1]=1;
		for(int i=2;i<=lim;i++)
		{
			if(!vis[i])
			{
				p.pb(i);
				mu[i]=-1;
			}
			for(int j:p)
			{
				if(i*j>lim)break;
				vis[i*j]=1;
				if(i%j!=0)mu[i*j]=mu[i]*mu[j];
				else
				{
					mu[i*j]=0;
					break;
				}
			}
		}
	}

	int q[N],g[N],r[N];
	int pro_q[N],sum_r[N];
	int t[N];

	void setup_qr(int lim) //处理 q 和 r，同时处理 q 的前缀积， r 的前缀和
	{
		for(int i=1;i<=lim;i++)
		{
			q[i]=1;
			t[i]=qpow(i,i*mu[i]);
		}
		for(int k=1;k<=lim;k++)
		{
			for(int T=k;T<=lim;T+=k)
			{
				q[T]=q[T]*t[k]%MOD;
				
				r[T]=r[T]+k*mu[k]; //r 是在指数上面的，不可取模
			}
		}
		
		for(int T=1;T<=lim;T++)
		{
			q[T]=qpow(q[T],T);
			r[T]*=T; //r 是在指数上面的，不可取模
			q[T]=q[T]*qpow(T,r[T])%MOD;
		}
		
		pro_q[0]=1;
		for(int i=1;i<=lim;i++)
			pro_q[i]=pro_q[i-1]*q[i]%MOD;
			
		for(int i=1;i<=lim;i++)
			sum_r[i]=sum_r[i-1]+r[i]; //r 是在指数上面的，不可取模
	}

	
	void setup_g(int lim) //处理 g 用来求 h
	{
		g[1]=1;
		for(int i=2;i<=lim;i++)
			g[i]=g[i-1]*qpow(i,i)%MOD;
	}
	int h(int n,int m)
	{
		return qpow(g[n],s(m))*qpow(g[m],s(n))%MOD;
	}
	void setup(int lim)
	{
		sieve(lim);
		setup_g(lim);
		setup_qr(lim);
	}
}
using namespace Setup;

int f(int n,int m)
{
	int l=1,r=0;
	int ans=1;
	while(l<=min(n,m))
	{
		r=min(n/(n/l),m/(m/l));
		ans=ans*qpow(h(n/l,m/l),sum_r[r]-sum_r[l-1])%MOD;
		ans=ans*qpow(pro_q[r]*qpow(pro_q[l-1],MOD-2),s(n/l)*s(m/l))%MOD;
		l=r+1;
	}
	return ans;
}
void work()
{
	int l,r;
	l=read();
	r=read();
	int ans=f(r,r)*f(l-1,l-1)%MOD*qpow(f(l-1,r)*f(l-1,r),MOD-2)%MOD;
	print(ans);
	cout<<endl;
}

signed main()
{	
	// double st=clock();
	
	int __,lim;
	__=read();
	lim=read();
	setup(lim+50);
	
	// double ed=clock();
	// cout<<(ed-st)/1000<<endl;
	
	while(__--)work();
	return 0;
} 
/*

*/
```





---

## 作者：qczrz6v4nhp6u (赞：0)

## 题意
$t$ 组询问，每组给定 $l,r$，求 $\prod\limits_{i=l}^r\prod\limits_{j=l}^r\text{lcm}(i,j)^{\text{lcm}(i,j)}\bmod {32465177}$。
## Solution
显然容斥拆询问：

记 $s(n,m)=\prod\limits_{i=1}^n\prod\limits_{j=1}^m\text{lcm}(i,j)^{\text{lcm}(i,j)}$，则原式转化为 $\dfrac{s(r,r)\times s(l-1,l-1)}{s(r,l-1)\times s(l-1,r)}$。

接下来就是大力推式子了。

$$
\begin{aligned}
s(n,m)=&\prod_{i=1}^n\prod_{j=1}^m\text{lcm}(i,j)^{\text{lcm}(i,j)}\\
=&\prod_{i=1}^n\prod_{j=1}^m\Big(\frac{i\times j}{\gcd(i,j)}\Big)^{\frac{i\times j}{\gcd(i,j)}}\\
=&\prod_{d\ge1}\prod_{i=1}^{\lfloor\frac nd\rfloor}\prod_{j=1}^{\lfloor\frac md\rfloor}(ijd)^{ijd[\gcd(i,j)=1]}\\
=&\prod_{d\ge1}\prod_{i=1}^{\lfloor\frac nd\rfloor}\prod_{j=1}^{\lfloor\frac md\rfloor}(ijd)^{ijd\sum_{t|\gcd(i,j)}\mu(t)}\\
=&\prod_{d\ge1}\prod_{t\ge1}\prod_{i=1}^{\lfloor\frac n{dt}\rfloor}\prod_{j=1}^{\lfloor\frac m{dt}\rfloor}(ijdt^2)^{ijdt^2\mu(t)}\\
=&\prod_{T\ge1}\prod_{t|T}\prod_{i=1}^{\lfloor\frac nT\rfloor}\prod_{j=1}^{\lfloor\frac mT\rfloor}(ijTt)^{ijTt\mu(t)}\\
=&\prod_{T\ge1}\prod_{t|T}\Big(\big(\prod_{i=1}^{\lfloor\frac nT\rfloor}\prod_{j=1}^{\lfloor\frac mT\rfloor}(ij)^{ij}\big)\times \big(\prod_{i=1}^{\lfloor\frac nT\rfloor}\prod_{j=1}^{\lfloor\frac mT\rfloor}(Tt)^{ij}\big)\Big)^{Tt\mu(t)}\\
\end{aligned}
$$

约定几个函数：

- $f(n)=\dfrac12n(n+1)$。
- $g(n)=\prod_{i=1}^ni^i$。
- $h(n,m)=g(n)^{f(m)}g(m)^{f(n)}$。
- $r(n)=n\mu(n)$。
- $u(n)=n\sum_{d|n}r(d)$。
- $v(n)=n^{u(n)}$。
- $w(n)=(\prod_{d|n}d^{r(d)})^n$。

我们继续。
$$
\begin{aligned}
&\prod_{T\ge1}\prod_{t|T}\Big(\big(\prod_{i=1}^{\lfloor\frac nT\rfloor}\prod_{j=1}^{\lfloor\frac mT\rfloor}(ij)^{ij}\big)\times \big(\prod_{i=1}^{\lfloor\frac nT\rfloor}\prod_{j=1}^{\lfloor\frac mT\rfloor}(Tt)^{ij}\big)\Big)^{Tt\mu(t)}\\
=&\prod_{T\ge1}\prod_{t|T}\Big(h(\lfloor\frac nT\rfloor,\lfloor\frac mT\rfloor)\times(Tt)^{f(\lfloor\frac nT\rfloor)f(\lfloor\frac mT\rfloor)}\Big)^{Tr(t)}\\
\end{aligned}
$$

把括号里面拆开，稍微化一下两部分的柿子：

$$
\begin{aligned}
&\prod_{T\ge1}\prod_{t|T}h(\lfloor\frac nT\rfloor,\lfloor\frac mT\rfloor)^{Tr(t)}\\
=&\prod_{T\ge1}h(\lfloor\frac nT\rfloor,\lfloor\frac mT\rfloor)^{u(T)}\\
\\
&\prod_{T\ge1}\prod_{t|T}\Big((Tt)^{f(\lfloor\frac nT\rfloor)f(\lfloor\frac mT\rfloor)}\Big)^{Tr(t)}\\
=&\prod_{T\ge1}\Big(\prod_{t|T}(Tt)^{Tr(t)}\Big)^{f(\lfloor\frac nT\rfloor)f(\lfloor\frac mT\rfloor)}\\
=&\prod_{T\ge1}\Big(T^{T\sum_{t|T}r(t)}(\prod_{t|T}t^{r(t)})^T\Big)^{f(\lfloor\frac nT\rfloor)f(\lfloor\frac mT\rfloor)}\\
=&\prod_{T\ge1}\Big(T^{u(T)}w(T)\Big)^{f(\lfloor\frac nT\rfloor)f(\lfloor\frac mT\rfloor)}\\
=&\prod_{T\ge1}\Big(v(T)w(T)\Big)^{f(\lfloor\frac nT\rfloor)f(\lfloor\frac mT\rfloor)}
\end{aligned}
$$

代回原式得：

$$
\begin{aligned}
s(n,m)=\prod_{t\ge1}h(\lfloor\frac nT\rfloor,\lfloor\frac mT\rfloor)^{u(T)}\Big(v(T)w(T)\Big)^{f(\lfloor\frac nT\rfloor)f(\lfloor\frac mT\rfloor)}
\end{aligned}
$$

预处理 $g(n),u(n),v(n),w(n)$，搭配数论分块，即可在 $O(n\log n+t\sqrt n\log n)$ 时间内解决本题。

~~比幽什么团短。~~

## Code

封装比较多，代码略显抽象。

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll=long long;
#define Tp template<typename T>
#define Ts template<typename T,typename... _T>
char buf[1<<20],*p1=buf,*p2=buf;
#define getchar() (p1==p2&&(p2=buf+fread(p1=buf,1,1<<20,stdin),p1==p2)?EOF:*p1++)
Tp inline void read(T& x){
    x=0;char c=getchar();bool f=0;
    for(;!isdigit(c);c=getchar())if(c=='-')f=1;
    for(;isdigit(c);c=getchar())x=(x<<1)+(x<<3)+(c^48);
    f&&(x=-x);
}
Ts inline void read(T& x,_T&... y){read(x),read(y...);}
Tp inline void copy(T* a,T* b,int len){for(int i=0;i<len;i++)b[i]=a[i];}
Tp inline void assign(T* a,int len,T b=0){for(int i=0;i<len;i++)a[i]=b;}
Tp inline void plus(T* a,int len,T b=0){for(int i=0;i<len;i++)a[i]+=b;}
Tp inline void ckmin(T& x,T y){x=min(x,y);}
Tp inline void ckmax(T& x,T y){x=max(x,y);}
const int N=1e6+5,M=1e6+5,INF=1e9,mod=32465177,mmod=mod-1,imod=mod-2;
inline ll qpow(const ll& _a,const ll& _b){
	ll a=_a,b=_b,res=1;
	for(;b;b>>=1,a=a*a%mod)
		if(b&1)res=res*a%mod;
	return res;
}
struct mint{
	ll v;
	inline mint(const ll& _v=0){v=_v;}
	inline mint operator +(const mint& _){return (v+_.v)%mod;}
	inline mint operator +=(const mint& _){return v=(v+_.v)%mod;}
	inline mint operator -(const mint& _){return (v-_.v+mod)%mod;}
	inline mint operator -=(const mint& _){return v=(v-_.v+mod)%mod;}
	inline mint operator *(const mint& _){return v*_.v%mod;}
	inline mint operator *=(const mint& _){return v=v*_.v%mod;}
	inline mint operator /(const mint& _){return v*qpow(_.v,imod)%mod;}
	inline mint operator /=(const mint& _){return v=v*qpow(_.v,imod)%mod;}
	inline mint operator ^(const ll& _){return qpow(v,_);}
	inline mint operator ^=(const ll& _){return v=qpow(v,_);}
};
inline void ps(int N,ll* f,ll* sf){//prework_summary
	for(int i=1;i<=N;i++)sf[i]=(sf[i-1]+f[i])%mmod;
}
inline ll gs(ll* sf,int l,int r){return (sf[r]-sf[l-1]+mmod)%mmod;}//get_summary
inline void pp(int N,mint* f,mint* pf,mint* ipf){//prework_product
	pf[0]=1;for(int i=1;i<=N;i++)pf[i]=pf[i-1]*f[i];
	ipf[N]=(mint)1/pf[N];for(int i=N;i>=1;i--)ipf[i-1]=ipf[i]*f[i];
}
inline mint gp(mint* pf,mint* ipf,int l,int r){return pf[r]*ipf[l-1];}//get_product
//=================================================================================
int plen,p[N],mu[N];
bool vis[N];
inline void sieve(int N=1e6){
	mu[1]=1;
	for(int i=2;i<=N;i++){
		if(!vis[i])p[++plen]=i,mu[i]=mmod-1;
		for(int j=1;i*p[j]<=N;j++){
			vis[i*p[j]]=1;
			if(i%p[j]==0){
				mu[i*p[j]]=0;
				break;
			}
			mu[i*p[j]]=mmod-mu[i];
		}
	}
}
mint g[N],pg[N],ipg[N];
ll u[N],su[N];
mint v[N],pv[N],ipv[N];
mint w[N],pw[N],ipw[N];
inline ll f(ll n){return n*(n+1)/2%mmod;}
inline mint h(ll n,ll m){return (gp(pg,ipg,1,n)^f(m))*(gp(pg,ipg,1,m)^f(n));}
inline ll r(ll n){return n*mu[n]%mmod;}
inline void init(int N=1e6){
	sieve(N);
	for(int i=1;i<=N;i++)g[i]=(mint)i^i;
	pp(N,g,pg,ipg);
	for(int i=1;i<=N;i++){
		ll now=r(i);
		for(int j=1;i*j<=N;j++)
			u[i*j]=(u[i*j]+now)%mmod;
		u[i]=u[i]%mmod*i%mmod;
	}
	ps(N,u,su);
	for(int i=1;i<=N;i++)v[i]=(mint)i^u[i];
	pp(N,v,pv,ipv);
	assign(w+1,N,(mint)1);
	for(int i=1;i<=N;i++){
		mint now=(mint)i^r(i);
		for(int j=1;i*j<=N;j++)
			w[i*j]*=now;
		w[i]^=i;
	}
	pp(N,w,pw,ipw);
}
inline mint s(ll n,ll m){
	mint res=1;
	for(ll l=1,r;l<=n&&l<=m;l=r+1){
		r=min(n/(n/l),m/(m/l));
		res*=(h(n/l,m/l)^gs(su,l,r))*((gp(pv,ipv,l,r)*gp(pw,ipw,l,r))^(f(n/l)*f(m/l)%mmod));
	}
	return res;
}
inline mint ask(ll l,ll r){return (s(r,r)*s(l-1,l-1))/(s(r,l-1)*s(l-1,r));}
int t,n;
int main(){
	read(t,n);
	init(n);
	while(t--){
		int l,r;
		read(l,r);
		printf("%lld\n",ask(l,r).v);
	}
	return 0;
}
```

---

## 作者：Phartial (赞：0)

## 题意

求

$$
\prod_{i=l}^r\prod_{j=l}^r\operatorname{lcm}(i,j)^{\operatorname{lcm}(i,j)}
$$

对 $32465177$ 取模的值。

## 思路

设 $\displaystyle f(n,m)=\prod_{i=1}^n\prod_{j=1}^m\operatorname{lcm}(i,j)^{\operatorname{lcm}(i,j)}$，答案显然为 $\dfrac{f(r,r)f(l-1,l-1)}{f(r,l-1)f(l-1,r)}$，由于 $f(n,m)=f(m,n)$，以下不妨设 $n\le m$。

$$
\begin{aligned}
  f(n,m)
  &=\prod_{i=1}^n\prod_{j=1}^m\operatorname{lcm}(i,j)^{\operatorname{lcm}(i,j)}\\
  &=\prod_{i=1}^n\prod_{j=1}^m\frac{ij}{\gcd(i,j)}^{\frac{ij}{\gcd(i,j)}}\\
  &=\prod_{d=1}^n\prod_{i=1}^n\prod_{j=1}^m\frac{ij}{d}^{\frac{ij}{d}[\gcd(i,j)=d]}\\
  &=\prod_{d=1}^n\prod_{i=1}^{\lfloor n/d\rfloor}\prod_{j=1}^{\lfloor m/d\rfloor}ijd^{ijd[\gcd(i,j)=1]}\\
  &=\prod_{d=1}^n\prod_{i=1}^{\lfloor n/d\rfloor}\prod_{j=1}^{\lfloor m/d\rfloor}ijd^{ijd\sum_{p\mid i,p\mid j}\mu(p)}\\
  &=\prod_{d=1}^n\prod_{i=1}^{\lfloor n/d\rfloor}\prod_{j=1}^{\lfloor m/d\rfloor}\prod_{p\mid i,p\mid j}ijd^{ijd\mu(p)}\\
  &=\prod_{d=1}^n\prod_{p=1}^{\lfloor n/d\rfloor}\prod_{i=1}^{\lfloor n/dp\rfloor}\prod_{j=1}^{\lfloor m/dp\rfloor}(ijdp^2)^{ijdp^2\mu(p)}\\
\end{aligned}
$$

设 $t=dp$，有

$$
\begin{aligned}
  &\prod_{d=1}^n\prod_{p=1}^{\lfloor n/d\rfloor}\prod_{i=1}^{\lfloor n/dp\rfloor}\prod_{j=1}^{\lfloor m/dp\rfloor}(ijdp^2)^{ijdp^2\mu(p)}\\
  =&\prod_{d=1}^n\prod_{p=1}^{\lfloor n/d\rfloor}\prod_{i=1}^{\lfloor n/t\rfloor}\prod_{j=1}^{\lfloor m/t\rfloor}(ijtp)^{ijtp\mu(p)}\\
  =&\prod_{t=1}^n\prod_{p\mid t}\prod_{i=1}^{\lfloor n/t\rfloor}\prod_{j=1}^{\lfloor m/t\rfloor}(ijtp)^{ijtp\mu(p)}\\
  =&\prod_{t=1}^n\left(\prod_{p\mid t}\left(\prod_{i=1}^{\lfloor n/t\rfloor}\prod_{j=1}^{\lfloor m/t\rfloor}(ijtp)^{ij}\right)^{p\mu(p)}\right)^t\\
  =&\prod_{t=1}^n\left(\prod_{p\mid t}\left(\prod_{i=1}^{\lfloor n/t\rfloor}\prod_{j=1}^{\lfloor m/t\rfloor}(ij)^{ij}\cdot\prod_{i=1}^{\lfloor n/t\rfloor}\prod_{j=1}^{\lfloor m/t\rfloor}(tp)^{ij}\right)^{p\mu(p)}\right)^t\\
\end{aligned}
$$

设 $S(n,m)=\displaystyle\prod_{i=1}^n\prod_{j=1}^m(ij)^{ij}$，$s(n)=\displaystyle\sum_{i=1}^ni=\dfrac{n(n+1)}{2}$，$g(n)=\displaystyle\prod_{i=1}^ni^i$，有

$$
\begin{aligned}
  S(n,m)
  &=\prod_{i=1}^n\prod_{j=1}^m(ij)^{ij}\\
  &=\prod_{i=1}^n\prod_{j=1}^mi^{ij}\cdot j^{ij}\\
  &=\prod_{i=1}^n\prod_{j=1}^m(i^i)^j\cdot \prod_{i=1}^n\prod_{j=1}^m(j^j)^i\\
  &=\prod_{i=1}^n(i^i)^{s(m)}\cdot \prod_{i=1}^ng(m)^i\\
  &=g(n)^{s(m)}\cdot g(m)^{s(n)}\\
\end{aligned}
$$

另一边，我们有：

$$
\begin{aligned}
  \prod_{i=1}^{n}\prod_{j=1}^{m}x^{ij}
  &=x^{\sum_{i=1}^n\sum_{j=1}^mij}\\
  &=x^{s(n)s(m)}
\end{aligned}
$$

代入原式，得：

$$
\begin{aligned}
  &\prod_{t=1}^n\left(\prod_{p\mid t}\left(\prod_{i=1}^{\lfloor n/t\rfloor}\prod_{j=1}^{\lfloor m/t\rfloor}(ij)^{ij}\cdot\prod_{i=1}^{\lfloor n/t\rfloor}\prod_{j=1}^{\lfloor m/t\rfloor}(tp)^{ij}\right)^{p\mu(p)}\right)^t\\
  =&\prod_{t=1}^n\left(\prod_{p\mid t}\left(S(\lfloor n/t\rfloor,\lfloor m/t\rfloor)\cdot(tp)^{s(\lfloor n/t\rfloor)s(\lfloor m/t\rfloor)}\right)^{p\mu(p)}\right)^t\\
  =&\prod_{t=1}^n\left(\prod_{p\mid t}S(\lfloor n/t\rfloor,\lfloor m/t\rfloor)^{p\mu(p)}\cdot p^{s(\lfloor n/t\rfloor)s(\lfloor m/t\rfloor)p\mu(p)}\cdot t^{s(\lfloor n/t\rfloor)s(\lfloor m/t\rfloor)p\mu(p)}\right)^t\\
\end{aligned}
$$

设 $h(n)=\displaystyle\sum_{p\mid n}p\mu(p)$，$w(n)=\displaystyle\prod_{d\mid n}d^{d\mu(d)}$，有：

$$
\begin{aligned}
  &\prod_{t=1}^n\left(\prod_{p\mid t}S(\lfloor n/t\rfloor,\lfloor m/t\rfloor)^{p\mu(p)}\cdot p^{s(\lfloor n/t\rfloor)s(\lfloor m/t\rfloor)p\mu(p)}\cdot t^{s(\lfloor n/t\rfloor)s(\lfloor m/t\rfloor)p\mu(p)}\right)^t\\
  =&\prod_{t=1}^n\left(S(\lfloor n/t\rfloor,\lfloor m/t\rfloor)^{h(t)}\cdot w(t)^{s(\lfloor n/t\rfloor)s(\lfloor m/t\rfloor)}\cdot t^{s(\lfloor n/t\rfloor)s(\lfloor m/t\rfloor)h(t)}\right)^t\\
\end{aligned}
$$

再设 $r(n)=\displaystyle(w(n)\cdot n^{h(n)})^n$，有

$$
\begin{aligned}
  &\prod_{t=1}^n\left(S(\lfloor n/t\rfloor,\lfloor m/t\rfloor)^{h(t)}\cdot w(t)^{s(\lfloor n/t\rfloor)s(\lfloor m/t\rfloor)}\cdot t^{s(\lfloor n/t\rfloor)s(\lfloor m/t\rfloor)h(t)}\right)^t\\
  =&\prod_{t=1}^nS(\lfloor n/t\rfloor,\lfloor m/t\rfloor)^{h(t)t}\cdot r(t)^{s(\lfloor n/t\rfloor)s(\lfloor m/t\rfloor)}\\
\end{aligned}
$$

至此，我们可以通过数论分块解决问题。

整理一下要用的函数：

- $s(n)=\displaystyle\sum_{i=1}^ni=\dfrac{n(n+1)}{2}$：位于指数上，可 $O(1)$ 计算，模 $p-1$。
- $g(n)=\displaystyle\prod_{i=1}^ni^i$：位于底数上，可 $O(n\log n)$ 预处理，模 $p$。
- $S(n,m)=g(n)^{s(m)}\cdot g(m)^{s(n)}$：位于底数上，可 $O(\log p)$ 计算，模 $p$。
- $h(n)=\displaystyle\sum_{p\mid n}p\mu(p)$：积性函数，位于指数上，可 $O(n)$ 预处理（线性筛），模 $p-1$。
- $w(n)=\displaystyle\prod_{d\mid n}d^{d\mu(d)}$：位于底数上，可以 $O(n\log n)$ 预处理，模 $p$。
- $r(n)=\displaystyle(w(n)\cdot n^{h(n)})^n$：位于底数上，可以 $O(\log p)$ 直接计算，模 $p$。

再整理一下要预处理的东西：

- $g(n)=\displaystyle\prod_{i=1}^ni^i$：直接预处理 $i^i$ 后前缀积。
- $h(n)=\displaystyle\sum_{p\mid n}p\mu(p)$：使用线性筛预处理，$h(p^k)=1-p$。
- $w(n)=\displaystyle\prod_{d\mid n}d^{d\mu(d)}$：枚举 $d$ 对倍数贡献即可。
- $h(t)t$ 的前缀和，对 $p-1$ 取模。
- $r(t)$ 的前缀积和逆元，对 $p$ 取模。

```cpp
#include <iostream>
#include <vector>

using namespace std;
using LL = long long;

const int kN = 1e6 + 1;
const LL kM = 32465177;

int t, n, ql, qr, bp[kN], kp[kN], sp[kN], mu[kN];
LL g[kN], h[kN], w[kN], ht[kN], _r[kN], r[kN], ir[kN];
bool v[kN];
vector<int> p;

LL P(LL b, LL e) {
  LL s = 1;
  for (; e; e >>= 1, b = b * b % kM) {
    (e & 1) && (s = s * b % kM);
  }
  return s;
}
LL S(int n) { return 1LL * n * (n + 1) / 2 % (kM - 1); }
LL S(int n, int m) { return P(g[n], S(m)) * P(g[m], S(n)) % kM; }
LL F(int n, int m) {
  LL s = 1;
  for (int l = 1, r; l <= n; l = r + 1) {
    r = min(n / (n / l), m / (m / l));
    s = s
      * P(S(n / l, m / l), (ht[r] - ht[l - 1] + kM - 1) % (kM - 1)) % kM
      * P(::r[r] * ir[l - 1] % kM, S(n / l) * S(m / l) % (kM - 1)) % kM;
  }
  return s;
}

int main() {
  ios_base::sync_with_stdio(0), cin.tie(0);
  cin >> t >> n;
  g[0] = 1;
  for (int i = 1; i <= n; ++i) {
    g[i] = g[i - 1] * P(i, i) % kM;
  }
  h[1] = mu[1] = 1;
  for (int i = 2; i <= n; ++i) {
    if (!v[i]) {
      p.push_back(i), h[i] = (kM - i) % (kM - 1), mu[i] = -1;
      bp[i] = sp[i] = i, kp[i] = 1;
    }
    for (int j : p) {
      int k = i * j;
      if (k > n) {
        break;
      }
      v[k] = 1;
      if (i % j) {
        h[k] = h[i] * h[j] % (kM - 1);
        mu[k] = -mu[i];
        bp[k] = sp[k] = j, kp[k] = 1;
      } else {
        mu[k] = 0;
        if (i == sp[i]) {
          h[k] = h[bp[i]];
        } else {
          h[k] = h[i / sp[i]] * h[j * sp[i]] % (kM - 1);
        }
        bp[k] = bp[i], sp[k] = sp[i] * j, kp[k] = kp[i] + 1;
        break;
      }
    }
  }
  for (int i = 1; i <= n; ++i) {
    ht[i] = (ht[i - 1] + h[i] * i % (kM - 1)) % (kM - 1);
  }
  for (int i = 1; i <= n; ++i) {
    w[i] = 1;
  }
  for (int d = 1; d <= n; ++d) {
    LL v = P(d, (kM - 1 + d * mu[d]) % (kM - 1));
    for (int i = d; i <= n; i += d) {
      w[i] = w[i] * v % kM;
    }
  }
  for (int i = 1; i <= n; ++i) {
    _r[i] = P(w[i] * P(i, h[i]) % kM, i);
  }
  r[0] = 1;
  for (int i = 1; i <= n; ++i) {
    r[i] = r[i - 1] * _r[i] % kM;
  }
  ir[n] = P(r[n], kM - 2);
  for (int i = n; i >= 1; --i) {
    ir[i - 1] = ir[i] * _r[i] % kM;
  }
  for (; t--; ) {
    cin >> ql >> qr;
    LL f = F(ql - 1, qr);
    cout << F(qr, qr) * F(ql - 1, ql - 1) % kM * P(f * f % kM, kM - 2) % kM << '\n';
  }
  return 0;
}
```


---

## 作者：mango09 (赞：0)

[P7486 「Stoi2031」彩虹](https://www.luogu.com.cn/problem/P7486)

请确保宁已经熟练掌握：

- 莫比乌斯反演
- 形如 $\sum_{d\mid n} f(d)$，其中 $f$ 为积性函数的 $\Theta(n\ln n)$ 的筛法。

## Description

- 多测，数据组数为 $t$。

- 给定一个正整数 $n$，然后 $t$ 组询问，每组给出两个满足 $1\le l\le r\le n$ 的正整数 $l, r$，请求出
  $$
  \left[\prod_{i = l}^r \prod_{j = l}^r \operatorname{lcm}(i, j)^{\operatorname{lcm}(i, j)} \right] \bmod 32465177
  $$
  
- 对于 $100\%$ 的数据，$1 \le n \le 10^6, 1 \le t \le 10, 1 \le l_i \le r_i \le n$。

## Solution

考虑用前缀积 + 容斥。

为方便表示，设 $f(n, m) = \prod_{i = 1}^n \prod_{i = 1}^m \operatorname{lcm}(i, j)^{\operatorname{lcm}(i, j)}$。

则
$$
\begin{aligned}
\prod_{i = l}^r \prod_{j = l}^r \operatorname{lcm}(i, j)^{\operatorname{lcm}(i, j)}
& = \prod_{i = l}^r \dfrac{\prod\limits_{j = 1}^r \operatorname{lcm}(i, j)^{\operatorname{lcm}(i, j)}}{\prod\limits_{j = 1}^{l - 1} \operatorname{lcm}(i, j)^{\operatorname{lcm}(i, j)}} \\
& = \dfrac{\prod\limits_{i = 1}^r \dfrac{\prod\limits_{j = 1}^r \operatorname{lcm}(i, j)^{\operatorname{lcm}(i, j)}}{\prod\limits_{j = 1}^{l - 1} \operatorname{lcm}(i, j)^{\operatorname{lcm}(i, j)}}}{\prod\limits_{i = 1}^{l - 1} \dfrac{\prod\limits_{j = 1}^r \operatorname{lcm}(i, j)^{\operatorname{lcm}(i, j)}}{\prod\limits_{j = 1}^{l - 1} \operatorname{lcm}(i, j)^{\operatorname{lcm}(i, j)}}} \\
& = \dfrac{\dfrac{\prod\limits_{i = 1}^r \prod\limits_{j = 1}^r \operatorname{lcm}(i, j)^{\operatorname{lcm}(i, j)}}{\prod\limits_{i = 1}^r \prod\limits_{j = 1}^{l - 1} \operatorname{lcm}(i, j)^{\operatorname{lcm}(i, j)}}}{\dfrac{\prod\limits_{i = 1}^{l - 1} \prod\limits_{j = 1}^r \operatorname{lcm}(i, j)^{\operatorname{lcm}(i, j)}}{\prod\limits_{i = 1}^{l - 1} \prod\limits_{j = 1}^{l - 1} \operatorname{lcm}(i, j)^{\operatorname{lcm}(i, j)}}} \\
& = \dfrac{f(r, r) f(l - 1, l - 1)}{f(r, l - 1) f(l - 1, r)}
\end{aligned}
$$
观察到 $f(n, m) = f(m, n)$，不妨设 $n\le m$。
$$
\begin{aligned}
f(n, m)
& = \prod_{i = 1}^n \prod_{j = 1}^m \operatorname{lcm}(i, j)^{\operatorname{lcm}(i, j)} \\
& = \prod_{i = 1}^n \prod_{j = 1}^m \left[\dfrac{ij}{\gcd(i, j)} \right]^{\frac{ij}{\gcd(i, j)}} \\
\end{aligned}
$$
发现若 $\gcd(i, j)\ne d$，则 $\dfrac{ij}{\gcd(i, j)} [\gcd(i, j) = d] = 0$，那么如果它作为指数，有 $\left[\dfrac{ij}{\gcd(i, j)} \right]^{\frac{ij}{\gcd(i, j)} [\gcd(i, j) = d]} = 1$，刚好满足这一项不符合要求。

所以变成
$$
\begin{aligned}
& = \prod_{d = 1}^n \prod_{i = 1}^n \prod_{j = 1}^m \left(\dfrac{ij}{d}\right)^{\frac{ij}{d} [\gcd(i, j) = d]} \\
& = \prod_{d = 1}^n \prod_{i = 1}^{\left\lfloor\frac{n}{d}\right\rfloor} \prod_{j = 1}^{\left\lfloor\frac{m}{d}\right\rfloor} (ijd)^{ijd [\gcd(i, j) = 1]} \\
& = \prod_{d = 1}^n \prod_{i = 1}^{\left\lfloor\frac{n}{d}\right\rfloor} \prod_{j = 1}^{\left\lfloor\frac{m}{d}\right\rfloor} (ijd)^{ijd \sum_{k\mid \gcd(i, j)} \mu(k)}
\end{aligned}
$$

将指数的加改为底数的乘
$$
\begin{aligned}
& = \prod_{d = 1}^n \prod_{i = 1}^{\left\lfloor\frac{n}{d}\right\rfloor} \prod_{j = 1}^{\left\lfloor\frac{m}{d}\right\rfloor} \prod_{k\mid \gcd(i, j)} (ijd)^{ijd\, \mu(k)} \\
& = \prod_{d = 1}^n \prod_{k = 1}^{\left\lfloor\frac{n}{d}\right\rfloor} \prod_{i = 1}^{\left\lfloor\frac{n}{d}\right\rfloor} [k\mid i] \prod_{j = 1}^{\left\lfloor\frac{m}{d}\right\rfloor} [k\mid j] (ijd)^{ijd\, \mu(k)} \\
& = \prod_{d = 1}^n \prod_{k = 1}^{\left\lfloor\frac{n}{d}\right\rfloor} \prod_{i = 1}^{\left\lfloor\frac{n}{dk}\right\rfloor} \prod_{j = 1}^{\left\lfloor\frac{m}{dk}\right\rfloor} (ijdk^2)^{ijdk^2\mu(k)} \\
& = \prod_{d = 1}^n \prod_{k = 1}^{\left\lfloor\frac{n}{d}\right\rfloor} \prod_{i = 1}^{\left\lfloor\frac{n}{T}\right\rfloor} \prod_{j = 1}^{\left\lfloor\frac{m}{T}\right\rfloor} (ijkT)^{ijkT\, \mu(k)} \\
& = \prod_{T = 1}^n \prod_{k\mid T} \prod_{i = 1}^{\left\lfloor\frac{n}{T}\right\rfloor} \prod_{j = 1}^{\left\lfloor\frac{m}{T}\right\rfloor} (ijkT)^{ijkT\, \mu(k)} \\
& = \prod_{T = 1}^n \prod_{k\mid T} \left[\prod_{i = 1}^{\left\lfloor\frac{n}{T}\right\rfloor} \prod_{j = 1}^{\left\lfloor\frac{m}{T}\right\rfloor} (ijkT)^{ij} \right]^{kT\, \mu(k)} \\
& = \prod_{T = 1}^n \prod_{k\mid T} \left\{ \left[\prod_{i = 1}^{\left\lfloor\frac{n}{T}\right\rfloor} \prod_{j = 1}^{\left\lfloor\frac{m}{T}\right\rfloor} (ij)^{ij} \cdot \prod_{i = 1}^{\left\lfloor\frac{n}{T}\right\rfloor} \prod_{j = 1}^{\left\lfloor\frac{m}{T}\right\rfloor} (kT)^{ij} \right]^{k\, \mu(k)} \right\}^T
\end{aligned}
$$
化简后面两项。设一个函数 $S(n) = \sum_{i = 1}^n i$，再设 $g(n) = \prod_{i = 1}^n i^i$。

则
$$
\begin{aligned}
\prod_{i = 1}^n \prod_{j = 1}^m (ij)^{ij}
& = \prod_{i = 1}^n \prod_{j = 1}^m i^{ij} \cdot j^{ij} \\
& = \prod_{i = 1}^n \prod_{j = 1}^m i^{ij} \cdot \prod_{j = 1}^m \prod_{i = 1}^n j^{ji} \\
& = \prod_{i = 1}^n i^{i\sum_{x = 1}^m x} \cdot \prod_{j = 1}^m j^{j\sum_{y = 1}^n y} \\
& = \left(\prod_{i = 1}^n i^i\right)^{\sum_{x = 1}^m x} \cdot \left(\prod_{j = 1}^m j^j\right)^{\sum_{y = 1}^n y} \\
& = g(n)^{S(m)} \cdot g(m)^{S(n)}
\end{aligned}
$$
设它为 $h(n, m)$ 吧。

然后
$$
\begin{aligned}
\prod_{i = 1}^n \prod_{j = 1}^m (kT)^{ij}
& = (kT)^{\sum_{i = 1}^n \sum_{j = 1}^m ij} \\
& = (kT)^{\sum_{i = 1}^n i \sum_{j = 1}^m j} \\
& = (kT)^{S(n) S(m)}
\end{aligned}
$$
回代
$$
\begin{aligned}
& = \prod_{T = 1}^n \prod_{k\mid T} \left\{ \left[h\left(\left\lfloor\dfrac{n}{T}\right\rfloor, \left\lfloor\dfrac{m}{T}\right\rfloor \right) (kT)^{S\left(\left\lfloor\frac{n}{T}\right\rfloor \right) S\left(\left\lfloor\frac{m}{T}\right\rfloor \right)} \right]^{k\, \mu(k)} \right\}^T \\
& = \prod_{T = 1}^n \prod_{k\mid T} \left[h\left(\left\lfloor\dfrac{n}{T}\right\rfloor, \left\lfloor\dfrac{m}{T}\right\rfloor \right)^{k\, \mu(k)}\cdot k^{S\left(\left\lfloor\frac{n}{T}\right\rfloor \right) S\left(\left\lfloor\frac{m}{T}\right\rfloor \right) k\, \mu(k)} \cdot T^{S\left(\left\lfloor\frac{n}{T}\right\rfloor \right) S\left(\left\lfloor\frac{m}{T}\right\rfloor \right) k\, \mu(k)} \right]^T
\end{aligned}
$$
设 $\alpha(n) = \sum_{d\mid n} d\, \mu(d)$，另设 $\beta(n) = \prod_{d\mid n} d^{d\, \mu(d)}$。

则
$$
= \prod_{T = 1}^n \left[h\left(\left\lfloor\dfrac{n}{T}\right\rfloor, \left\lfloor\dfrac{m}{T}\right\rfloor \right)^{\alpha(T)} \cdot \beta(T)^{S\left(\left\lfloor\frac{n}{T}\right\rfloor \right) S\left(\left\lfloor\frac{m}{T}\right\rfloor \right)} \cdot T^{S\left(\left\lfloor\frac{n}{T}\right\rfloor \right) S\left(\left\lfloor\frac{m}{T}\right\rfloor \right) \alpha(T)} \right]^T
$$
~~为简洁表示~~，再设 $\delta(n) = \left[\beta(n) \cdot n^{\alpha(n)} \right]^n$。
$$
= \prod_{T = 1}^n h\left(\left\lfloor\dfrac{n}{T}\right\rfloor, \left\lfloor\dfrac{m}{T}\right\rfloor \right)^{\alpha(T) T} \cdot \delta(T)^{S\left(\left\lfloor\frac{n}{T}\right\rfloor \right) S\left(\left\lfloor\frac{m}{T}\right\rfloor \right)}
$$
数论分块：

- 第一项底数相同，预处理指数的前缀和即可；
- 第二项指数相同，预处理底数的前缀积即可。

模数 $p = 32465177$ 是质数，根据欧拉定理可以将指数 $\bmod (p - 1)$ 降到 $\Omicron(p)$ 级别。

以上所有需要用到的东西：

- $S(n) = \sum_{i = 1}^n i$：$\Theta(1)$ 计算，$S(n)$ 都作为指数出现，所以 $\bmod (p - 1)$。
- $g(n) = \prod_{i = 1}^n i^i$：预处理 $\Omicron(n\log n)$，查询 $\Theta(1)$。
- $h(n, m) = g(n)^{S(m)} \cdot g(m)^{S(n)}$：在可以 $\Theta(1)$ 得到 $S,g$ 的值的情况下是 $\Omicron(\log p)$ 计算的。
- $d\, \mu(d)$：令其为 $\gamma(d)$。把这个在线性筛时顺便算出来，$\Theta(n)$。观察到 $\gamma(d)$ 都作为指数出现，所以可以将其 $\bmod (p - 1)$ 并转成正数。
- $\alpha(n) = \sum_{d\mid n} \gamma(d)$：预处理 $\Theta(n\ln n)$，查询 $\Theta(1)$。作为指数出现，$\bmod (p - 1)$。
- $\alpha(n) n$：令其为 $\zeta(n)$。预处理 $\Theta(n)$，查询 $\Theta(1)$。作为指数出现，$\bmod (p - 1)$。
- $d^{d\, \mu(d)}$：令其为 $\lambda(d)$。也是在线性筛中做，但它使线性筛多了个 $\log p$。
- $\beta(n) = \prod_{d\mid n} \lambda(d)$：预处理 $\Theta(n\ln n)$，查询 $\Theta(1)$。
- $\delta(n) = \left[\beta(n) \cdot n^{\alpha(n)} \right]^n$：预处理 $\Omicron(n\log p)$，查询 $\Theta(1)$。

数论分块是 $\Omicron\left(\sqrt{n}\log p\right)$ 的，即计算 $f(n, m) = \prod_{i = 1}^n \prod_{i = 1}^m \operatorname{lcm}(i, j)^{\operatorname{lcm}(i, j)}$ 是 $\Omicron\left(\sqrt{n}\log p\right)$ 的。

$t$ 次询问，时间是 $\Omicron(t\sqrt{n}\log p)$ 的。

加上预处理，总时间复杂度为 $\Omicron(n\log p + n\ln n + t\sqrt{n}\log p)$ 的，由于 $t\le 10$ 过小，所以真正在 $\Omicron(n\log p)$ 级别内。

## Code

```cpp
// 18 = 9 + 9 = 18.
#include <iostream>
#include <cstdio>
#define Debug(x) cout << #x << "=" << x << endl
typedef long long ll;
using namespace std;

const int MAXN = 1e6 + 5;
const int MOD = 32465177;

int qpow(int a, int b)
{
	int base = a, ans = 1;
	while (b)
	{
		if (b & 1)
		{
			ans = (ll)ans * base % MOD;
		}
		base = (ll)base * base % MOD;
		b >>= 1;
	}
	return ans;
}

int inv(int a)
{
	return qpow(a, MOD - 2);
}

int p[MAXN], g[MAXN], mu[MAXN], gamma[MAXN], alpha[MAXN], zeta[MAXN], zeta_sum[MAXN], lambda[MAXN], beta[MAXN], delta[MAXN], delta_pro[MAXN], delta_pro_inv[MAXN], delta_pro_pro[MAXN], delta_pro_pro_inv[MAXN];
bool vis[MAXN];

void pre(int n)
{
	g[1] = mu[1] = gamma[1] = lambda[1] = beta[1] = delta[1] = 1;
	for (int i = 2; i <= n; i++)
	{
		beta[i] = 1;
		g[i] = (ll)g[i - 1] * qpow(i, i % (MOD - 1)) % MOD;
		if (!vis[i])
		{
			p[++p[0]] = i;
			mu[i] = -1;
		}
		gamma[i] = (i * mu[i] % (MOD - 1) + MOD - 1) % (MOD - 1);
		lambda[i] = qpow(i, gamma[i]);
		for (int j = 1; j <= p[0] && i * p[j] <= n; j++)
		{
			vis[i * p[j]] = true;
			if (i % p[j] == 0)
			{
				mu[i * p[j]] = 0;
				break;
			}
			mu[i * p[j]] = mu[i] * mu[p[j]];
		}
	}
	
	for (int i = 1; i <= n; i++)
	{
		for (int j = 1; i * j <= n; j++)
		{
			alpha[i * j] = (alpha[i * j] + gamma[i]) % (MOD - 1);
			beta[i * j] = (ll)beta[i * j] * lambda[i] % MOD;
		}
	}
	
	delta_pro[0] = delta_pro_pro[0] = delta_pro_inv[0] = delta_pro_inv[1] = 1;
	for (int i = 1; i <= n; i++)
	{
		zeta[i] = (ll)alpha[i] * i % (MOD - 1);
		zeta_sum[i] = (zeta_sum[i - 1] + zeta[i]) % (MOD - 1);
		delta[i] = qpow((ll)beta[i] * qpow(i, alpha[i]) % MOD, i % (MOD - 1));
		delta_pro[i] = (ll)delta_pro[i - 1] * delta[i] % MOD;
		delta_pro_pro[i] = (ll)delta_pro_pro[i - 1] * delta_pro[i] % MOD;
	}
	
	delta_pro_pro_inv[n] = inv(delta_pro_pro[n]);
	for (int i = n - 1; i >= 1; i--)
	{
		delta_pro_pro_inv[i] = (ll)delta_pro_pro_inv[i + 1] * delta_pro[i + 1] % MOD;
		delta_pro_inv[i + 1] = (ll)delta_pro_pro_inv[i + 1] * delta_pro_pro[i] % MOD;
	}
}

int S(int n)
{
	return (ll)n * (n + 1) / 2 % (MOD - 1);
}

int h(int n, int m)
{
	return (ll)qpow(g[n], S(m)) * qpow(g[m], S(n)) % MOD;
}

int GetZetaSum(int l, int r)
{
	return (zeta_sum[r] - zeta_sum[l - 1] + MOD - 1) % (MOD - 1);
}

int GetDeltaPro(int l, int r)
{
	return (ll)delta_pro[r] * delta_pro_inv[l - 1] % MOD;
}

int f(int n, int m)
{
	if (n > m)
	{
		swap(n, m);
	}
	int res = 1;
	for (int l = 1, r; l <= n; l = r + 1)
	{
		int k1 = n / l, k2 = m / l;
		r = min(n / k1, m / k2);
		res = (ll)res * qpow(h(k1, k2), GetZetaSum(l, r)) % MOD * qpow(GetDeltaPro(l, r), (ll)S(k1) * S(k2) % (MOD - 1)) % MOD;
	}
	return res;
}

int main()
{
	int t, n;
	scanf("%d%d", &t, &n);
	pre(n);
	while (t--)
	{
		int l, r;
		scanf("%d%d", &l, &r);
		int a = (ll)f(r, r) * f(l - 1, l - 1) % MOD, b = (ll)f(r, l - 1) * f(l - 1, r) % MOD;
		printf("%d\n", (ll)a * inv(b) % MOD);
	}
	return 0;
}
```



---

## 作者：ricky0916 (赞：0)

~~啊这，这道题哪里基础了~~

首先我们令 $ Solve(a,b)=\prod\limits_{i=1}^a\prod\limits_{j=1}^b \operatorname{lcm}(a,b)^{\operatorname{lcm}(a,b)} $

那么易得答案为
$$ \dfrac{Solve(r,r)\times Solve(l-1,l-1)}{Solve(r,l-1)\times Solve(l-1,r)} $$
所以只需要求出 $ Solve(a,b) $ 即可

令 $td=T$，不妨设 $a\leq b$

$$
\begin{aligned}
&\prod_{i=1}^a\prod_{j=1}^b \operatorname{lcm}(i,j)^{\operatorname{lcm}(i,j)}\\
=&\prod_{d=1}^a\prod_{i=1}^{\lfloor \frac{a}{d}\rfloor}\prod_{j=1}^{\lfloor \frac{b}{d}\rfloor}(dij)^{dij[\gcd(i,j)=1]}\\
=&\prod_{d=1}^a\prod_{i=1}^{\lfloor \frac{a}{d}\rfloor}\prod_{j=1}^{\lfloor \frac{b}{d}\rfloor}(dij)^{dij\sum_{t|\gcd(i,j)}\mu(t)}\\
=&\prod_{d=1}^a\prod_{t=1}^{\lfloor \frac{a}{d}\rfloor}\prod_{i=1}^{\lfloor \frac{a}{td}\rfloor}\prod_{j=1}^{\lfloor \frac{b}{td}\rfloor}(dij\times t^2)^{dij\times t^2\times\mu(t)}\\
=&\prod_{T=1}^a\prod_{t|T}\prod_{i=1}^{\lfloor \frac{a}{T}\rfloor}\prod_{j=1}^{\lfloor \frac{b}{T}\rfloor}(ijTt)^{ijTt\times\mu(t)}
\end{aligned}
$$
令 $ S(x)=1+2+......+x=\dfrac{x(x+1)}{2},F(x)=\prod\limits_{i=1}^x i^i $

则有
$$
\prod_{i=1}^n\prod_{j=1}^m (ij)^{ij}=F(n)^{S(m)}\times F(m)^{S(n)}
$$
（令其为 $G(n,m)$）
$$
\prod_{i=1}^n\prod_{j=1}^m {Tt}^{ij}=Tt^{S(n)\times S(m)}
$$

带回原式可以得到
$$
\begin{aligned}
&\prod_{T=1}^a(\prod_{t|T}(G({\lfloor \frac{a}{T}\rfloor},{\lfloor \frac{b}{T}\rfloor})\times Tt^{S(\lfloor \frac{a}{T}\rfloor)\times S(\lfloor \frac{b}{T}\rfloor)})^{t\mu(t)})^T\\
\end{aligned}
$$
令 $ h(x)=\sum\limits_{d|x}d\mu(d),v(x)=\prod\limits_{d|x}d^{d\mu(d)} $，则可得
$$
\prod_{T=1}^aG({\lfloor \frac{a}{T}\rfloor},{\lfloor \frac{b}{T}\rfloor})^{Th(T)}\times(T^{h(T)}\times v(T))^{T\times S(\lfloor \frac{a}{T}\rfloor)\times S(\lfloor \frac{b}{T}\rfloor)}
$$

最后再令 $ hh(x)=x\times h(x),vv(x)=(x^{h(x)}\times v(x))^x $  可以得到
$$
\prod_{T=1}^aG({\lfloor \frac{a}{T}\rfloor},{\lfloor \frac{b}{T}\rfloor})^{hh(T)}\times vv(T)^{S(\lfloor \frac{a}{T}\rfloor)\times S(\lfloor \frac{b}{T}\rfloor)}
$$

前缀和+前缀积+整除分块即可 ~~（啥前缀和前缀积的）~~

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
inline int mn(int x,int y){
	return x<y?x:y;
}
inline int read(){
	int x=0;
	bool f=0;
	char ch=getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-') f^=1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9'){
		x=(x<<3)+(x<<1)+ch-'0';
		ch=getchar();
	}
	if(f) return -x;
	return x;
}
void write(int x){
	if(x<0){
		putchar('-');
		write(-x);
		return;
	}
	if(x/10) write(x/10);
	putchar(x%10+'0');
}
void we(int x){
	write(x);
	putchar('\n');
}
const int mod=32465177;
int l,r,t,n,f[1000010],mu[1000010],h[1000010],prime[1000010],tot,v[1000010];
bool check[1000010];
inline int ksm(int x,int y){
	int ret=1;
	while(y){
		if(y&1) ret=1ll*ret*x%mod;
		y>>=1;
		x=1ll*x*x%mod;
	}
	return ret;
}
inline int qumo(int x,int mo){
	return (x%mo+mo)%mo;
}
void init(){
	mu[1]=1;
	f[1]=1;
	v[1]=1;
	for(int i=2;i<=n;i++){
		f[i]=1ll*f[i-1]*ksm(i,i)%mod;
		v[i]=1;
		if(!check[i]){
			prime[tot++]=i;
			mu[i]=-1;
		}
		for(int j=0;j<tot&&i*prime[j]<=n;j++){
			int tmp=i*prime[j];
			check[tmp]=1;
			if(i%prime[j]==0){
				mu[tmp]=0;
				break;
			}
			mu[tmp]=mu[i]*mu[prime[j]];
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;i*j<=n;j++){
			h[i*j]=qumo(h[i*j]+mu[i]*i,mod-1);
			v[i*j]=1ll*v[i*j]*ksm(i,i*mu[i]+mod-1)%mod;
		}
	}
	v[0]=1;
	for(int i=1;i<=n;i++){
		v[i]=ksm(1ll*ksm(i,h[i])*v[i]%mod,i);
		h[i]=1ll*h[i]*i%(mod-1);
	}
	for(int i=2;i<=n;i++){
		v[i]=1ll*v[i-1]*v[i]%mod;
		h[i]=(h[i]+h[i-1])%(mod-1);
	}
}

inline int s(int x){
	return 1ll*x*(x+1)/2%(mod-1);
}
inline int g(int x,int y){
	return 1ll*ksm(f[x],s(y))*ksm(f[y],s(x))%mod;
}
inline int qzh(int l,int r){
	return qumo(h[r]-h[l-1],mod-1);
}
inline int qzj(int l,int r){
	return 1ll*v[r]*ksm(v[l-1],mod-2)%mod;
}
int work(int a,int b){
	if(a>b) swap(a,b);
	int ret=1;
	for(int i=1,j;i<=a;i=j+1){
		j=mn(a/(a/i),b/(b/i));
		ret=1ll*ret*ksm(g(a/i,b/i),qzh(i,j))%mod*ksm(qzj(i,j),1ll*s(a/i)*s(b/i)%(mod-1))%mod;
	}
	return ret;
}
int wor(int l,int r){
	swap(l,r);
	int ans1=1ll*work(r,r)*work(l-1,l-1)%mod,ans2=1ll*work(r,l-1)*work(l-1,r)%mod;
	return 1ll*ans1*ksm(ans2,mod-2)%mod;
}
int main(){
	t=read();
	n=read();
	init();
	while(t--){
		we(wor(read(),read()));
	}
	return 0;
}
```


---


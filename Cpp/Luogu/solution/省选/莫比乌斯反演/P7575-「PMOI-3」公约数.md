# 「PMOI-3」公约数

## 题目描述

给出 $n,m$ 和一个长度为 $n-1$ 的序列 $x$，保证 $x_i$ 互不相同。

求
$$
\sum_{i_1=1}^m\sum_{i_2=1}^m\cdots\sum_{i_n=1}^m[\gcd(i_1,i_2)=x_1][\gcd(i_2,i_3)=x_2]\cdots[\gcd(i_{n-1},i_n)=x_{n-1}]$$

答案对 $998244353$ 取模。

## 说明/提示

【样例解释】

对于第一组样例，只有当 $i_1=1,i_2=2,i_3=2$ 时才满足要求。

【数据范围】

**本题采用捆绑测试。**

- Subtask1（10pts）：$n,m\le 5$；
- Subtask2（15pts）：$n,m\le500$；
- Subtask3（15pts）：$n,m\le 5\times 10^3$；
- Subtask4（15pts）：$n,m\le 5\times 10^4$。
- Subtask5（20pts）：$n,m\le 3\times 10^5$。
- Subtask6（25pts）：无特殊限制。

对于 $100\%$ 的数据满足，$n-1\le m$，$1\le n,m\le 10^6$，$1\le x_i\le m$，保证 $x_i$ 互不相同。

## 样例 #1

### 输入

```
3 2
1 2```

### 输出

```
1```

## 样例 #2

### 输入

```
5 20
1 2 4 6```

### 输出

```
312```

## 样例 #3

### 输入

```
5 20
2 3 1 4```

### 输出

```
592```

## 样例 #4

### 输入

```
10 1000
1 2 4 8 16 32 64 128 256 ```

### 输出

```
207388829```

# 题解

## 作者：whiteqwq (赞：4)

[P7575 「PMOI-3」公约数](https://www.luogu.com.cn/problem/P7575)解题报告：

[更好的阅读体验](https://zybuluo.com/xiaoziyao/note/1795574)

## 题意

给定$n,m$以及一个长度为$n-1$的序列$x$（保证$x_i$互不相同），求：

$$\sum_{i_1=1}^m\sum_{i_2=1}^m\cdots\sum_{i_n=1}^m[\gcd(i_1,i_2)=x_1][\gcd(i_2,i_3)=x_2]\cdots[\gcd(i_{n-1},i_n)=x_{n-1}]$$

## 分析

好久没有反演了，反演一波。

这个式子看上去要硬上莫反，但由于$x_i$互不相同，因此不好直接反演。

考虑dp，设$f_{i,j}$表示考虑前$i$个数，且第$i$个数强制设为$j$的方案数，那么最后的答案为$\sum_{i=1}^m f_{n,i}$，且很容易列出转移方程：

$$f_{i,j}=\sum_{k=1}^m[\gcd(j,k)=x_i]f_{i-1,k}$$

这个式子可以上莫反了，化一化就可以得到：

$$f_{i,j\times x_i}=\sum_{k=1}^{\lfloor\frac{m}{x_i}\rfloor}f_{i-1,k\times x_i}\sum_{r\mid\gcd(j,k)}\mu(r)=\sum_{r\mid j}\mu(r)\sum_{k=1}^{\lfloor\frac{m}{x_i\times r}\rfloor}f_{i-1,k\times x_i\times r}$$

设$g_{i,j}=\sum_{k=1}^{\lfloor\frac{m}{j}\rfloor}f_{i,k\times j}$，那么上式可化简：

$$f_{i,j\times x_i}=\sum_{r\mid j}\mu(r)\times g_{i-1,x_i\times r}$$

式子仍然棘手，再次设$f'_{i,j}=f_{i,j\times x_i},g'_{i,j}=g_{i,j\times x_i}$，那么会有两个式子成立（分别从上面定义式与原式的化简式得来）：

$$g'_{i,j}=\sum_{j\mid k}^{\lfloor\frac{m}{x_i}\rfloor}f'_{k}\\f'_{i,j}=\sum_{r\mid j}\mu(r)\times g'_{i-1,r}$$

设$h_{i,j}=\mu(j)\times g_{i,j}$，那么我们惊奇地发现$g'$是$f'$的狄利克雷后缀和，$f'$是$h$的狄利克雷前缀和。

我们知道最开始的$f_1$，可以直接推出$f'_1$，然后可以通过狄利克雷后缀和推出$g'_1$，然后用$h$的定义推出$h_1$，再次用狄利克雷前缀和推出$f'$，然后推出$f_2$……

分析一下时间复杂度，由于狄利克雷前/后缀和的复杂度是$O(n\log \log n)$的，而我们进行狄利克雷前/后缀和的总数组大小为$\sum_{i=1}^n \frac{m}{x_i}\leqslant \sum_{i=1}^m\frac{m}{i}=m\ln m$（由于$x_i$互不相同），所以复杂度应该为$O(m\log m\log \log m)$。（$n$与$m$同阶）

## 代码

代码具体内容不需要定义这么多数组，两个就够用了。

目前最优解，欢迎吊打。
```
#include<stdio.h>
const int maxn=1000005,mod=998244353;
int n,m,cnt,ans;
int p[maxn],c[maxn],miu[maxn],x[maxn],f[maxn],g[maxn];
inline int add(int x,int y){
	return x+y>=mod? x+y-mod:x+y;
}
void sieve(int n){
	c[1]=miu[1]=1;
	for(int i=2;i<=n;i++){
		if(c[i]==0)
			p[++cnt]=i,miu[i]=mod-1;
		for(int j=1;j<=cnt;j++){
			if(i*p[j]>n)
				break;
			c[i*p[j]]=1;
			if(i%p[j]==0){
				miu[i*p[j]]=0;
				break;
			}
			miu[i*p[j]]=miu[i]==0? 0:(mod-miu[i]);
		}
	}
}
int main(){
	scanf("%d%d",&n,&m),sieve(m);
	x[0]=1;
	for(int i=1;i<n;i++)
		scanf("%d",&x[i]);
	for(int i=1;i<=m;i++)
		f[i]=1;
	for(int i=1;i<n;i++){
		for(int j=1;j*x[i]<=m;j++)
			g[j]=f[j*x[i]];
		for(int j=1;j*x[i-1]<=m;j++)
			f[j*x[i-1]]=0;
		for(int j=1;j<=cnt&&p[j]<=m/x[i];j++)
			for(int k=(m/x[i])/p[j];k>=1;k--)
				g[k]=add(g[k],g[k*p[j]]);
		for(int j=1;j*x[i]<=m;j++)
			g[j]=1ll*miu[j]*g[j]%mod;
		for(int j=1;j<=cnt&&p[j]<=m/x[i];j++)
			for(int k=1;k*p[j]<=m/x[i];k++)
				g[k*p[j]]=add(g[k*p[j]],g[k]);
		for(int j=1;j*x[i]<=m;j++)
			f[j*x[i]]=g[j];
	}
	for(int i=1;i<=m;i++)
		ans=add(ans,f[i]);
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：zhouyuhang (赞：2)

很无聊的题。以下的 $a$ 指题目中的 $i$。

考虑 dp，令 $f_{i,j}$ 表示前 $i$ 个数满足要求，且 $a_i=j$ 的方案数。显然可以列出转移 $f_{i+1,j}=\sum_{k=1}^m[\gcd(k,j)=x_i]f_{i,k}$。

注意到 $\gcd(k,j)=x_i\to x_i\mid j,x_i\mid k$，故可能对转移过程造成贡献的 $j,k$ 总和只有 $\frac{m}{x_i}$ 个。我们不妨在每一次转移都把这些 $j,k$ 拎出来。于是我们只需解决以下这个问题：给定长为 $N$ 的序列 $g$，对所有 $1\le i\le N$ 求 $f_i=\sum_{j=1}^N[i\perp j]g_j$。首先莫反一手，有 $f_i=\sum_{d\mid i}\mu(d)\sum_{d\mid j}g_j$，然后你发现做完了。。。

具体而言，你发现 $g'_d=\sum_{d\mid j}g_j$ 是 $g$ 的狄利克雷后缀和，而 $f_i=\sum_{d\mid i}\mu(d)g'_d$ 则是序列 $\{\mu(d)g'_d\}$ 的狄利克雷前缀和。由于两者都可以在 $O(N\log \log N)$ 的时间内求出，因此总的复杂度即为 $\sum_iO(\frac{m}{x_i}\log \log \frac{m}{x_i})=O(m\log m\log \log m)$。看上去有些极限，不过跑得飞快就是了。

代码：

```cpp
	for (int i = 1; i <= m; ++i) f[i] = 1;

	for (int i = 1; i < n; ++i) {
		int tm = m / x[i];
		for (int j = 1, t = x[i]; j <= tm; ++j, t += x[i]) f[j] = (t % x[i - 1]) ? 0 : f[t];
		sum1(f, tm); // 后缀和
		for (int j = 1; j <= tm; ++j) f[j] = 1LL * f[j] * (mod + mu[j]) % mod;
		sum0(f, tm); // 前缀和
		for (int j = tm; j; --j) f[j * x[i]] = f[j];
	}
    
	int ans = 0;
	for (int i = 1; i <= m; ++i) if (i % x[n - 1] == 0) inc(ans, f[i]);
	
	cout << ans << '\n';
```

---

## 作者：a___ (赞：2)

有意思的莫反题。

题意：  
求
$$\sum_{i_1=1}^m\sum_{i_2=1}^m\cdots\sum_{i_n=1}^m[\gcd(i_1,i_2)=x_1]\cdots[\gcd(i_{n-1},i_n)=x_{n-1}]$$

观察这个式子，发现相当于求长度为 $n$ 的 $\forall a_i\leq m$ 且 $\forall \gcd(a_i,a_{i+1})=x_i$ 的序列的数量。

我们容易想到一个 $\mathbf O(nm^2)$ 的 dp。设 $f_{i,j}$ 表示序列中第 $i$ 个位置的数是 $j$ 的方案数，显然有
$$f_{i,j}=\sum_{k=1}^mf_{i-1,k}[\gcd(j,k)=x_i]$$

按照套路除掉一个 $x_i$，
$$f_{i,jx_i}=\sum_{k=1}^{\lfloor\frac m{x_i}\rfloor}f_{i-1,kx_i}[\gcd(j,k)=1]$$

演出 $\mu$，
$$f_{i,jx_i}=\sum_{k=1}^{\lfloor\frac m{x_i}\rfloor}f_{i-1,kx_i}\sum_{d|j,d|k}\mu(d)$$

提到前面，
$$f_{i,jx_i}=\sum_{d|j}\mu(d)\sum_{k=1}^{\lfloor\frac m{x_id}\rfloor}f_{i-1,kx_id}$$

设
$$s_{i,x_id}=\sum_{k=1}^{\lfloor\frac m{x_id}\rfloor}f_{i,kx_id}$$

则原式变为
$$f_{i,jx_i}=\sum_{d|j}\mu(d)s_{i-1,x_id}$$

发现所有式子都有 $x_i$，而 $x_i$ 是常量，所以我们可以设 $f'_ {i,j}=f_{i,jx_i},s'_ {i,j}=s_{i,jx_i}$ 。

于是
$$s'_ {i,d}=\sum_{k=1}^{\left\lfloor\frac {\lfloor\frac m{x_i}\rfloor}d\right\rfloor}f'_ {i,kd}$$
$$f'_ {i,j}=\sum_{d|j}^{\left\lfloor\frac {\lfloor\frac m{x_i}\rfloor}d\right\rfloor}\mu(d)s'_ {i-1,d}$$

发现这两个式子正是 Dirichlet 前缀和/后缀和 的形式。$s'_ i$ 是 $f'_ i$ 的 Dirichlet 后缀和，$f'_ i$ 是 $\mu\cdot s'_ {i-1}$ 的 Dirichlet 前缀和。

由于我们有 $\mathbf O(n\log\log n)$ 求 Dirichlet 前缀和/后缀和 的算法，而 $x_i$ 互不相同，所以我们有了一个 $\mathbf O(m\log m\log\log m)$ 的算法。

代码
```cpp
#include<cstdio>
const int N=1e6+10,mod=998244353;
int n,m,f[N],g[N],p[N],mu[N],a[N],sum;
bool bo[N];
void pre(int n)
{
	for(int i=1;i<=p[0]&&p[i]<=n;i++)
	for(int j=1;j*p[i]<=n;j++)
	g[p[i]*j]=(g[p[i]*j]+g[j])%mod;
}
void suf(int n)
{
	for(int i=1;i<=p[0]&&p[i]<=n;i++)
	for(int j=n/p[i];j>=1;j--)
	g[j]=(g[j]+g[p[i]*j])%mod;
}
int main()
{
	int i,j;scanf("%d%d",&n,&m);
	mu[1]=1;
	for(i=2;i<=m;i++)
	{
		if(!bo[i])mu[p[++p[0]]=i]=-1;
		for(j=1;j<=p[0]&&i*p[j]<=m;j++)
		if(i%p[j])bo[i*p[j]]=1,mu[i*p[j]]=-mu[i];
		else {bo[i*p[j]]=true;break;}
	}
	for(i=1;i<n;i++)scanf("%d",&a[i]);a[0]=1;
	for(i=1;i<=m;i++)f[i]=1;
	for(i=1;i<n;i++)
	{
		for(j=1;j<=m/a[i];j++)g[j]=f[j*a[i]];
		for(j=1;j<=m/a[i-1];j++)f[j*a[i-1]]=0;
		suf(m/a[i]);
		for(j=1;j<=m/a[i];j++)g[j]=(g[j]*mu[j]+mod)%mod;
		pre(m/a[i]);
		for(j=1;j<=m/a[i];j++)f[j*a[i]]=g[j];
	}
	for(i=1;i<=m;i++)sum=(sum+f[i])%mod;
	printf("%d\n",sum);
	return 0;
}
```

---

## 作者：zifanwang (赞：0)

考虑 dp，记 $dp_{i,j}$ 表示确定前 $i$ 个数最后一个数为 $j$ 的方案数，则：

$$
dp_{1,i}=[x_1\mid i]\\

dp_{i,j}=[x_{i-1}\mid j]\sum_{k=1}^m dp_{i-1,k}[\gcd(k,j)=x_{i-1}][x_{i-1}\mid k]\\

dp_{i,j}=[x_{i-1}\mid j]\sum_{k=1}^m\sum_{d\mid (j/x_{i-1}),d\mid (k/x_{i-1})}\mu(d)\cdot dp_{i-1,k}
$$
$$
\mathbf{Answer}=\sum_{x_{n-1}|i}dp_{n,i}
$$

套个莫比乌斯反演：

$$
dp_{i,j\cdot x_{i-1}}=\sum_{d|j}\mu(d)\sum_{k=1}^{m/x_{i-1}/d}dp_{i-1,kd\cdot x_{i-1}}\\
$$

发现 $x_i$ 互不相同，于是 $\sum \frac m {x_i}$ 是可以接受的，先对 $
\sum_k$ 的部分做一遍狄利克雷后缀和，再对 $\sum_d$ 的部分做一遍狄利克雷前缀和即可，时间复杂度 $\mathcal O(m\log m\log\log m)$。

参考代码：
```cpp
#include<bits/stdc++.h>
#define ll long long
#define mxn 1000003
#define md 998244353
#define rep(i,a,b) for(int i=(a);i<=(b);++i)
#define rept(i,a,b) for(int i=(a);i<(b);++i)
#define drep(i,a,b) for(int i=(a);i>=(b);--i)
using namespace std;
int n,m,t,ans,f[mxn],s[mxn],a[mxn],d[mxn],p[mxn>>1],mu[mxn];
inline int read(){
	int x=0;char ch=getchar();
	while(!isdigit(ch))ch=getchar();
	while(isdigit(ch))x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
	return x;
}
inline void add(int &x,int y){
	x+=y;if(x>=md)x-=md;
} 
signed main(){
	n=read(),m=read();
	mu[1]=1;
	rep(i,2,m){
		if(!d[i])d[i]=p[++t]=i,mu[i]=md-1;
		rep(j,1,t){
			if(p[j]>d[i]||p[j]>m/i)break;
			d[p[j]*i]=p[j];
			if(i%p[j])mu[p[j]*i]=md-mu[i];
		}
	}
	rept(i,1,n)a[i]=read();
	for(int i=a[1];i<=m;i+=a[1])f[i]=1;
	a[0]=a[1];
	rept(i,1,n){
		int c=m/a[i];
		rep(j,1,c)s[j]=f[j*a[i]];
		rep(j,1,t){
			if(p[j]>c)break;
			drep(k,c/p[j],1)add(s[k],s[k*p[j]]);
		}
		rep(j,1,c)s[j]=(ll)s[j]*mu[j]%md;
		for(int j=a[i-1];j<=m;j+=a[i-1])f[j]=0;
		rep(j,1,c)f[j*a[i]]=s[j];
		rep(j,1,t){
			if(p[j]>c)break;
			for(int k=1,k1=p[j];k1<=c;++k,k1+=p[j])add(f[k1*a[i]],f[k*a[i]]);
		}
	}
	for(int i=a[n-1];i<=m;i+=a[n-1])add(ans,f[i]);
	cout<<ans;
	return 0;
}
```

---

## 作者：Leasier (赞：0)

前置芝士：[莫比乌斯反演](https://oi-wiki.org/math/number-theory/mobius/)

这个形式看上去不太好直接上反演，考虑计数 dp。

设 $dp_{i, j}$ 表示第 $i$ 个数为 $j$ 时前 $i$ 个数的方案数。

初值：$dp_{1, i} = [x_1 \mid i]$。

转移：$dp_{i, j} = [x_{i - 1} \mid j] \displaystyle\sum_{x_{i - 1} \mid k}^m [\gcd(j, k) = x_{i - 1}] dp_{i - 1, j}$。

答案：$\displaystyle\sum_{x_{n - 1} \mid i}^m dp_{n, i}$。

于是可以开始反演了，设 $x_{i - 1} \mid j$，则：

$dp_{i, j} = \displaystyle\sum_{x_{i - 1} \mid k}^m [\gcd(j, k) = x_{i - 1}] dp_{i - 1, j}$

$ = \displaystyle\sum_{k = 1}^{\lfloor \frac{m}{x_{i - 1}} \rfloor} [\gcd(\frac{j}{x_{i - 1}}, k) = 1] dp_{i - 1, j x_{i - 1}}$

$ = \displaystyle\sum_{k = 1}^{\lfloor \frac{m}{x_{i - 1}} \rfloor} dp_{i - 1, j x_{i - 1}} \sum_{d \mid \gcd(\frac{j}{x_{i - 1}}, k)} \mu(d)$

$ = \displaystyle\sum_{d \mid \frac{j}{x_{i - 1}}} \mu(d) \sum_{d x_{i - 1} \mid k}^m dp_{i - 1, k}$

于是在转移时维护 $dp_{i - 1}$ 的狄利克雷后缀和和 $\mu(d) \displaystyle\sum_{d x_{i - 1} \mid k}^m dp_{i - 1, k}$ 的狄利克雷前缀和即可。理论上应该写埃氏筛时间复杂度的东西才能 AC，但我比较懒于是直接暴力卷积。但本地测试极限数据只需要 $0.9 \operatorname{s}$ 左右，交上去也能 AC（

时间复杂度为 $O(n \ln n \ln m)$。

代码：
```cpp
#include <stdio.h>

const int N = 1e6 + 7, mod = 998244353;
int prime[N], mu[N], x[N], dp[N], sum[N];
bool p[N];

inline int init(int n){
	int cnt = 0;
	p[0] = p[1] = true;
	mu[1] = 1;
	for (register int i = 2; i <= n; i++){
		if (!p[i]){
			prime[++cnt] = i;
			mu[i] = -1;
		}
		for (register int j = 1; j <= cnt && i * prime[j] <= n; j++){
			int t = i * prime[j];
			p[t] = true;
			if (i % prime[j] == 0){
				mu[t] = 0;
				break;
			}
			mu[t] = -mu[i];
		}
	}
	return cnt;
}

inline int read(){
	int ans = 0;
	char ch = getchar();
	while (ch < '0' || ch > '9'){
		ch = getchar();
	}
	while (ch >= '0' && ch <= '9'){
		ans = ans * 10 + (ch ^ 48);
		ch = getchar();
	}
	return ans;
}

int main(){
	int n = read(), m = read(), nd = n - 1, cnt = init(m), ans = 0;
	x[0] = 1;
	for (register int i = 1; i < n; i++){
		x[i] = read();
	}
	for (register int i = x[1]; i <= m; i += x[1]){
		dp[i] = 1;
	}
	for (register int i = 1; i < n; i++){
		int t1 = m / x[i];
		for (register int j = 1; j <= t1; j++){
			sum[j] = 0;
		}
		for (register int j = 1; j <= t1; j++){
			for (register int k = j; k <= t1; k += j){
				if (k * x[i] % x[i - 1] == 0) sum[j] = (sum[j] + dp[k * x[i]]) % mod;
			}
		}
		for (register int j = x[i]; j <= m; j += x[i]){
			dp[j] = 0;
		}
		for (register int j = 1; j <= t1; j++){
			for (register int k = j; k <= t1; k += j){
				int t2 = k * x[i];
				dp[t2] = ((dp[t2] + mu[j] * sum[j] % mod) % mod + mod) % mod;
			}
		}
	}
	for (register int i = x[nd]; i <= m; i += x[nd]){
		ans = (ans + dp[i]) % mod;
	}
	printf("%d", ans);
	return 0;
}
```

---


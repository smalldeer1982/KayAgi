# 符卡对决

## 题目背景

灵梦正在和魔理沙进行符卡对决。

![Card](https://cdn.luogu.com.cn/upload/image_hosting/xu68nj8k.png)

> 永夜の报い，Pixiv76062895，作者是 minusT，侵删。

## 题目描述

灵梦一共有 $n$ 张符卡，每张卡都有一个能力值，对于第 $i$ 张卡，它的能力值为 $a_i$，现在她想从中选出两张符卡并使用它们，灵梦发现，如果她同时打出了两张符卡 $i, j$，这两张符卡造成的伤害将会是 $a_i\times a_j$。

这些符卡之间有能力的冲突，灵梦会告诉你这些符卡的兼容性，具体而言这些符卡之间有 $m$ 条关系，这些关系表明某两张符卡之间是兼容的，**注意**，如果符卡 $i, j$ 兼容且符卡 $j, k$ 兼容，那么符卡 $i, k$ 也是兼容的，如果打出的两张符卡之间不是兼容的，那么它们造成的伤害为 $0$。

她很好奇符卡之间的兼容性会造成什么样的影响，所以她会询问你 $q$ 次，每次告诉你一对正整数 $l, r$，意味着只有编号在区间 $[l, r]$ 内的关系才会生效。

灵梦不想把魔理沙虐得太惨，所以她会随机从所有符卡中选出两张**不同**的符卡来打出，她想知道每次询问造成的伤害的期望值对 $10^9 + 7$ 取模后是多少。

## 说明/提示

#### 样例 1 解释

对于第三组询问，只有 $(1, 4), (2, 3)$ 两对符卡之间是兼容的。

如果选择的符卡是 $(1, 2)$，那么它们不兼容，伤害值为 $0$，这种情况的概率是 $\dfrac16$。

如果选择的符卡是 $(1, 3)$，那么它们不兼容，伤害值为 $0$，这种情况的概率是 $\dfrac16$。

如果选择的符卡是 $(1, 4)$，它们兼容，伤害值为 $a_1\times a_4 = 35$，这种情况的概率是 $\dfrac16$。

如果选择的符卡是 $(2, 3)$，它们兼容，伤害值为 $a_2\times a_3 = 16$，这种情况的概率是 $\dfrac16$。

如果选择的符卡是 $(2, 4)$，那么它们不兼容，伤害值为 $0$，这种情况的概率是 $\dfrac16$。

以此类推，最终的期望值是 $\dfrac{17}{2}$，其在模 $10^9 + 7$ 意义下等于 $500000012$。

#### 数据范围

**本题采用捆绑测试。**

对于所有数据，$1\le n, q\le 10^5, 1\le m\le 2n, 1\le a_i\le 10^9, 1\le l_i\le r_i\le m, 1\le u_i, v_i\le n$。

对于不同的子任务，我们如下约定：

| 子任务编号 | $n$         | $q$         | 特殊性质 | 子任务分值 |
| ---------- | ----------- | ----------- | -------- | ---------- |
| $0$        | $\le300$    | $\le300$    | 无       | $5$        |
| $1$        | $\le 2000$  | $\le 2000$  | A        | $10$       |
| $2$        | $\le 2000$  | $\le 2000$  | B        | $5$       |
| $3$        | $\le 2000$  | $\le 2000$  | 无       | $10$       |
| $4$        | $\le 30000$ | $\le 30000$ | 无       | $10$       |
| $5$        | $\le 50000$ | $\le 50000$ | A        | $10$       |
| $6$        | $\le 50000$ | $\le 50000$ | B        | $10$       |
| $7$        | $\le 50000$ | $\le 50000$ | 无       | $15$       |
| $8$        | $\le 10^5$  | $\le 10^5$  | 无       | $25$       |

- **特殊性质 A**：保证 $u_i = 1, v_i = i + 1, m = n - 1$。
- **特殊性质 B**：保证 $l_i = 1$。


## 样例 #1

### 输入

```
4 4 4
5 8 2 7 
3 1
1 4
3 2
1 4
2 4
1 2
2 3
3 3```

### 输出

```
500000012
833333349
500000012
666666674```

## 样例 #2

### 输入

```
14 16 15
1 2 7 3 2 4 6 2 5 7 2 4 3 3 
5 12
2 9
2 10
7 10
6 12
12 3
11 1
4 8
1 13
6 8
6 10
4 1
1 10
12 11
3 5
9 7
14 14
2 16
5 6
2 3
5 10
1 6
5 16
13 15
1 2
3 7
3 4
14 14
3 7
6 7
11 14```

### 输出

```
318681321
263736277
868131875
725274731
32967035
384615390
637362648
780219786
967032974
406593411
208791211
318681321
406593411
945054952
681318687```

# 题解

## 作者：Undead2008 (赞：4)

将兼容关系视为边，答案为所有连通块权值的和的平方和减去所有点的权值的平方和。

考虑对 $m$ 分块，对于左右端点在同一个块中的询问直接暴力，对于端点在不同块中的询问按照左端点所在的块为第一关键字，右端点为第二关键字排序。

维护 $L$ 和 $R$ 两个指针表示当前连了下标 $\in (L,R)$ 的边，一并处理左端点在同一个块中的询问：

- 首先先将 $R$ 向右移动，直到大于当前询问的右端点；
- 然后记录当前状态；
- 再将 $L$ 向左移动，直到小于当前询问的左端点；
- 当前的 $(L,R)$ 刚好是所询问的区间；
- 然后还原当前状态为记录的状态。

可以用可撤销并查集来维护这些操作。若块长取 $\sqrt{n}$，时间复杂度 $O(n\sqrt{n}\log n)$。

```cpp
#include"bits/stdc++.h"
using namespace std;
#define int long long
const int maxn = 200010;
const int mo = 1e9+7;
int ksm(int b,int t){
	int ret=1;
	while(t){
		if(t&1)ret=1ll*ret*b%mo;
		b=1ll*b*b%mo,t>>=1;
	}
	return ret;
}
int inv(int x){
	return ksm(x,mo-2);
}
int n,m,q,b,bc,a[maxn],ans,alpha;
int f[maxn],sz[maxn],dep[maxn],Ans[maxn];
struct edge{int u,v;}e[maxn];
stack<pair<pair<int,int>,int> >st;
int ff(int x){return f[x]==x?x:ff(f[x]);}
void merge(int u,int v,int o){
	if((u=ff(u))==(v=ff(v)))return;
	if(dep[u]>dep[v])swap(u,v);
	ans=(ans-sz[u]*sz[u]%mo+mo-sz[v]*sz[v]%mo+mo)%mo;
	int O=(dep[u]==dep[v]);
	f[u]=v,dep[v]+=O,sz[v]=(sz[v]+sz[u])%mo;
	ans=(ans+sz[v]*sz[v]%mo)%mo;
	if(o)st.push({{u,v},O});
}
void cancel(int u,int v,int o){
	ans=(ans-sz[v]*sz[v]%mo+mo)%mo;
	f[u]=u,dep[v]-=o,sz[v]=(sz[v]-sz[u]+mo)%mo;
	ans=(ans+sz[u]*sz[u]%mo+sz[v]*sz[v]%mo)%mo;
}
void Clear(){while(st.size())cancel(st.top().first.first,st.top().first.second,st.top().second),st.pop();}
struct Node{int l,r,Id;};
bool cmp(Node u,Node v){return u.r<v.r;}
vector<Node>vec[maxn];
signed main(){
    ios::sync_with_stdio(0);
    cin.tie(0),cout.tie(0);
	cin>>n>>m>>q;
	for(int i=1;i<=n;i++)
		cin>>a[i],f[i]=i,sz[i]=a[i],dep[i]=1,
		ans=(ans+sz[i]*sz[i]%mo)%mo;
	alpha=ans;
	for(int i=1;i<=m;i++)
		cin>>e[i].u>>e[i].v;
	b=sqrt(m),bc=m/b;
	for(int i=1,l,r;i<=q;i++){
		cin>>l>>r;
		if(l/b==r/b){
			for(int j=l;j<=r;j++)
				merge(e[j].u,e[j].v,1);
			Ans[i]=(ans-alpha+mo)%mo;
			Clear();
		}else vec[l/b].push_back({l,r,i});
	}
	for(int Id=0;Id<=bc;Id++){
		ans=alpha;
		for(int i=1;i<=n;i++)
			f[i]=i,sz[i]=a[i],dep[i]=1;
		int L=b*(Id+1)-1,R=L+1;
		sort(vec[Id].begin(),vec[Id].end(),cmp);
		for(int j=0;j<vec[Id].size();j++){
			while(R<=vec[Id][j].r)merge(e[R].u,e[R].v,0),R++;
			while(L>=vec[Id][j].l)merge(e[L].u,e[L].v,1),L--;
			Ans[vec[Id][j].Id]=(ans-alpha+mo)%mo;
			Clear();
			L=b*(Id+1)-1;
		}
	}
	for(int i=1;i<=q;i++)
		cout<<1ll*Ans[i]*inv((1ll*n*(n-1))%mo)%mo<<'\n';
}
```

---

## 作者：xtzqhy (赞：3)

感觉和[[Cnoi2019] 须臾幻境](https://www.luogu.com.cn/problem/P5385)的离线版很像啊。

首先可以把期望拆掉，答案为 $\frac {\text{所有连通块的权值和的平方和-所有点的权值的平方和}}{n(n-1)}$。

考虑莫队。加边是容易的，可以并查集维护。但删边是困难的，所以考虑回滚莫队，用可撤销并查集实现回滚。

然后剩下的就是基础的回滚莫队了。

复杂度 $O(n\sqrt n \log n)$。
```cpp
#include"bits/stdc++.h"
#define re register
#define int long long
#define pii pair<int,int>
#define fi first
#define se second
using namespace std;
const int maxn=1e5+10,maxm=500,mod=1e9+7;
int n,m,Q,siz,tot,bs;
int a[maxn],ans[maxn];
int st[maxm],ed[maxm],bel[maxn<<1];
struct edge{
    int u,v;
}e[maxn<<1];
struct query{
    int l,r,id;
}q[maxn];
struct dsu{
    int fa[maxn],siz[maxn],w[maxn];
    stack<pii> stk;
    inline int find(int x){if(x!=fa[x]) return find(fa[x]);return fa[x];}
    inline void merge(int u,int v,int &now,bool type){
        int x=find(u),y=find(v);
        if(x==y){if(type) stk.push({0,0});return;}
        if(siz[x]<siz[y]) swap(x,y);
        if(type) stk.push({x,y});
        now=((now-w[x]*w[x]%mod-w[y]*w[y]%mod)%mod+mod)%mod;
        siz[x]+=siz[y],fa[y]=x,w[x]=(w[x]+w[y])%mod;
        now=(now+w[x]*w[x]%mod)%mod;
    }
    inline void undo(){
        int x=stk.top().fi,fi,y=stk.top().se;stk.pop();
        fa[y]=y,siz[x]-=siz[y],w[x]=((w[x]-w[y])%mod+mod)%mod;
    }
}t1,t2;
inline bool cmp(query a,query b){
    if(bel[a.l]==bel[b.l]) return a.r<b.r;
    return bel[a.l]<bel[b.l];
}
inline int qpow(int a,int b){
    int res=1;
    while(b){
        if(b&1) res=res*a%mod;
        b>>=1;
        a=a*a%mod; 
    }
    return res;
}
inline int Inv(int x){return qpow(x,mod-2);}
inline void init(){
    siz=sqrt(m);
    tot=m/siz;
    for(re int i=1;i<=tot;++i) st[i]=(i-1)*siz+1,ed[i]=i*siz;
    if(ed[tot]<m) ++tot,st[tot]=ed[tot-1]+1,ed[tot]=m;
    for(re int i=1;i<=tot;++i) for(re int j=st[i];j<=ed[i];++j) bel[j]=i;
}
inline void solve(int l,int r,int id){
    int res=bs;
    for(re int i=l;i<=r;++i) t2.merge(e[i].u,e[i].v,res,1);
    ans[id]=((res-bs)%mod+mod)%mod;
    for(re int i=l;i<=r;++i) t2.undo();
}
inline void add(int id,int &res,bool type){t1.merge(e[id].u,e[id].v,res,type);}
signed main(){
#ifndef ONLINE_JUDGE
    freopen("1.in","r",stdin);
    freopen("1.out","w",stdout);
#endif
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    cin>>n>>m>>Q;
    for(re int i=1;i<=n;++i) cin>>a[i],bs=(bs+a[i]*a[i])%mod;
    for(re int i=1;i<=n;++i) t1.fa[i]=i,t1.siz[i]=1,t1.w[i]=a[i];
    for(re int i=1;i<=n;++i) t2.fa[i]=i,t2.siz[i]=1,t2.w[i]=a[i];
    for(re int i=1;i<=m;++i) cin>>e[i].u>>e[i].v;
    for(re int i=1;i<=Q;++i) cin>>q[i].l>>q[i].r,q[i].id=i;
    init();
    sort(q+1,q+Q+1,cmp);
    int l=1,r=0,lst=0,now=bs;
    for(re int i=1;i<=Q;++i){
        if(bel[q[i].l]==bel[q[i].r]) solve(q[i].l,q[i].r,q[i].id);
        else{
            if(lst^bel[q[i].l]){
                for(re int i=1;i<=n;++i) t1.fa[i]=i,t1.siz[i]=1,t1.w[i]=a[i];
                l=ed[bel[q[i].l]]+1,r=ed[bel[q[i].l]];
                now=bs,lst=bel[q[i].l];
            }
            while(r<q[i].r) add(++r,now,0);
            int tmp=now,l1=l;
            while(l1>q[i].l) add(--l1,tmp,1);
            ans[q[i].id]=((tmp-bs)%mod+mod)%mod;
            while(l1<l) l1++,t1.undo();
        }
    }
    for(re int i=1;i<=Q;++i) cout<<ans[i]*Inv(n*(n-1)%mod)%mod<<'\n';
    return 0;
}
```

---

## 作者：Moyou (赞：3)

# 符卡对决 题解

> 官方题解

原题等价于：
$$
\dfrac{2}{n(n - 1)}\sum_{i = 1}^n\sum_{j = i + 1}^n a_ia_j[i, j 在同一个连通块内]
$$

## Subtask 0

并查集维护连通块，暴力枚举两个符卡即可，期望 5 pts。

## 特殊性质 A

菊花图，注意到此时一条边对应了一张符卡，所以对于询问区间 $[l, r]$，相当于求解：
$$
\dfrac{2}{n(n - 1)}(\sum_{i = l + 1}^{r + 1}\sum_{j = i + 1}^{r + 1} a_ia_j + \sum_{i = l + 1}^{r + 1}a_1 a_i)
$$
所以对 $a$ 进行前缀和预处理再枚举 $i$ 可以通过 Subtask 1，结合 Subtask 0 期望 15 pts。

注意到：
$$
(\sum_{i = l + 1}^{r + 1} a_i) ^ 2 = \sum_{i = l + 1}^{r + 1}\sum_{j = l + 1}^{r + 1} a_ia_j 
$$
所以减去
$$
\sum_{i = l + 1}^{r + 1}a_i^2
$$
再除以 $2$，就可以得到
$$
\sum_{i = l + 1}^{r + 1}\sum_{j = i + 1}^{r + 1} a_ia_j
$$
可以通过 特殊性质 A，期望 25 pts，时间复杂度：$O(mq)$。

## Subtask 3

考虑加入一条关系之后对答案的贡献。

不难发现，如果加入了关系 $i$，那么新加入的贡献来源于 $u_i$ 的连通块与 $v_i$ 的连通块内的点对。

贡献等于：
$$
\sum_{x\in S_{u_i}}\sum_{y\in S_{v_i}} a_xa_y\\
=\sum_{x\in S_{u_i}} a_x\sum_{y\in S_{v_i}}a_y
$$
所以并查集维护连通块的权值和即可，因此每次暴力初始化并查集，添加区间内的边，时间复杂度 $O(m(q + \alpha (n))$，期望 30 pts。

## 特殊性质 B

如果将所有询问离线，并对 $r_i$ 排序，那么我们只需要沿用 Subtask 3 的做法就可以一次性回答所有询问了，时间复杂度：$O(m\alpha (n) + q)$，结合 Subtask 3 和 特殊性质 A 可以获得 50 pts。

## Subtask 8

考虑莫队，因为没有办法方便的删除一条边对答案的贡献，使用回滚莫队。

在回滚莫队的过程中，需要撤销左端点到左端点所在块的右端点这部分的贡献，所以使用可撤销并查集即可撤回这部分的贡献，因为可撤销并查集不能路径压缩，所以一次操作的复杂度变成了 $O(\log n)$。

时间复杂度：$O(n\sqrt q \log n)$，并查集的常数很小所以可以通过，期望 100 pts。

PS：验题人 hzlqwq 给出了一种看起来是 $O(n\sqrt q \alpha (n))$ 的算法，主要思想是在左部分并查集某个点需要使用的时候再继承回滚莫队右部分的并查集的信息，同时加以修改。

---

## 作者：TBSF_0207 (赞：1)

这里主要是对**可撤销并查集**和**回滚莫队**一些细节的详细解析。

注意到加入关系相当于记录在无向图图中的联通块，容易用并查集维护，而删除关系难以直接维护。这时我们可以使用**只增不减**莫队，令块长为 $b$，对于左端点在同一块内的询问，我们先推右端点，保存，再推左端点，记录答案，然后回退到存档点，准备下一次操作。对于不同块内的询问，每次到该块时全体初始化即可。如果左右端点在同一块内，直接暴力做即可。

这里我们的答案是联通块内所有有序数对 $(i,j)$ 的 $a_i\times a_j$ 的和再 $\times \frac{1}{n(n-1)}$，所以对于并查集的一个节点需要维护 $\sum a_i$。因为要撤销，使用按秩合并需要记录 $siz_i$ 作为子树大小，用一个栈来记录修改节点，方便撤销。

对于 $\frac{m}{b}$ 个块，每个块右端点右推 $O(m)$，每次并查集操作 $O(\log n)$。对于 $q$ 个询问，每次左端点左推和撤销 $O(b)$，并查集操作 $O(\log n)$，总的时间复杂度为 $O(\log n(\frac{m^2}{b}+qb))$。根据基本不等式知识，块长设为 $\sqrt{\frac{m^2}{q}}$ 取到最小，在 $q,m$ 同阶时，取到 $\sqrt{m}$ 即可。

具体实现细节参见代码。


```cpp
#include<bits/stdc++.h>
using namespace std;
typedef pair<int,int> PII;
typedef long long LL;
const int N=2e5+5;
const LL MOD=1e9+7;
int n,m,rq,a[N];
int U[N],V[N];
struct uni{
	PII stk[N];
	int tp,fa[N],siz[N]; 
	LL sum[N];
	bool rcd;
	void init(){for(int i=1;i<=n;i++)fa[i]=i,sum[i]=a[i],siz[i]=1;}
	void sinit(int x){fa[x]=x,sum[x]=a[x],siz[x]=1;}
	void op(){rcd=1;tp=0;}
	inline int fr(int x){
		if(fa[x]==x)return x;
		return fr(fa[x]);
	}
	void undo(){
		while(tp){
			PII a=stk[tp--];
			int x=a.first,y=a.second;
			fa[x]=x;sum[y]-=sum[x];
			siz[y]-=siz[x];
		}
		rcd=0;
	}
	LL ins(int x,int y){
		int frx=fr(x),fry=fr(y);
		if(frx==fry)return 0;
		if(siz[frx]>siz[fry])swap(frx,fry);
		if(rcd)stk[++tp]=make_pair(frx,fry);
		fa[frx]=fry;
		sum[fry]+=sum[frx];
		siz[fry]+=siz[frx];
		return 1ll*((sum[fry]-sum[frx])%MOD)*(sum[frx]%MOD)%MOD;
	}
}un;
LL temp,ans[N];
int bs,b[N];
struct Q{int l,r,id;}q[N];
bool cmp(Q x,Q y){
	return (b[x.l]!=b[y.l]?b[x.l]<b[y.l]:x.r<y.r);
}
inline void add(int x){
	LL p=un.ins(U[x],V[x]);
	temp=(temp+p)%MOD;
}
LL qkpow(LL x,LL y){
	LL res=1;
	while(y){
		if(y&1)res=res*x%MOD;
		x=x*x%MOD;
		y>>=1;
	}
	return res;
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>n>>m>>rq;bs=sqrt(m);
	LL aps=qkpow(1ll*n*(n-1)%MOD,MOD-2);
	for(int i=1;i<=n;i++)
		cin>>a[i];
	for(int i=1;i<=m;i++)
		cin>>U[i]>>V[i],
		b[i]=(i-1)/bs+1;
	for(int i=1;i<=rq;i++){
		cin>>q[i].l>>q[i].r;
		q[i].id=i;
	}
	sort(q+1,q+1+rq,cmp);
	int l=-1,r=-2;
	for(int i=1;i<=rq;i++){
		if(l<q[i].l){
			un.init();
			temp=0;
			l=min(b[q[i].l]*bs,m);
			r=l-1;
		}
		if(q[i].r<r){
			un.op();
			for(int j=q[i].l;j<=q[i].r;j++)
				add(j);
			ans[q[i].id]=temp*2%MOD;
			un.undo();
			temp=0;
			continue;
		}
		while(r<q[i].r)add(++r);
		LL dt=temp;
		int orl=l;
		un.op();
		while(l>q[i].l)add(--l);
		ans[q[i].id]=temp*2%MOD;//*2因为是有序数对
		un.undo();
		temp=dt;
		l=orl;
	}
	for(int i=1;i<=rq;i++)
		cout<<ans[i]*aps%MOD<<'\n';
	return 0;
}
```

---

## 作者：zzzyyyyhhhhh (赞：0)

想了很久只会 $O(n\sqrt n\log n)$，没想到~~真是这个~~这个能过。

期望计算直接选择结果除概率。选择并查集维护连通性，否则连通性维护十分困难，合并两个并查集时对结果产生的新贡献为两集合权值之积。设当前结果为 $now$，答案为 $\frac{now}{\frac{n\times(n-1)}{2}}=\frac{now\times 2}{n\times (n-1)}$。


发现并没有强制在线，而可撤销并查集常数极小，考虑莫队。但是需要栈序撤销，因此使用回滚莫队维护。不太需要注意常数，但注意块长是 $\frac{\sqrt m}{\sqrt {\log m}}$，不是 $\frac{\sqrt n}{\sqrt {\log n}}$。

代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N = 2e5+100,mod=1e9+7;
int blo;
int n,m,qq;
int f[N],siz[N],w[N];
inline int qpow(int x,int y)
{
	int res=1;
	while(y)
	{
		if(y&1)res=res*x%mod;
		x=x*x%mod;
		y>>=1;
	}
	return res;
}
int now;
namespace dsu
{
	int find(int x){return f[x]!=x?find(f[x]):f[x];}
	vector<pair<int,int> > vv;
	bool un(int x,int y)
	{
		x=find(x),y=find(y);
		if(x==y){vv.push_back({0,0});return 0;}
		if(siz[x]<siz[y])swap(x,y);
		vv.push_back({y,x});
		f[y]=x,siz[x]+=siz[y],now=(now+w[x]*w[y]%mod)%mod,w[x]+=w[y],w[x]%=mod;
		return 1;
	}
	void roll()
	{
		int x=vv.back().first,y=vv.back().second;
		vv.pop_back();
		f[x]=x;
		siz[y]-=siz[x];
		w[y]-=w[x];
		w[y]=(w[y]+mod)%mod;
		now=(now-w[x]*w[y]%mod+mod)%mod;
	}
}
using namespace dsu;
int lll[N],rrr[N];
struct qes
{
	int l,r,pos;
	inline bool operator<(const qes q)const
	{
		if(q.l/blo==l/blo)return r<q.r;
		return l<q.l;
	}
}q[N];
inline void add(const int x)
{
	un(lll[x],rrr[x]);
}
vector<qes> qw[N];
int blocnt;
int ans[N];
signed main()
{
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>n>>m>>qq;
	blo=sqrt(m)+1;
	for(int i=1;i<=n;i++)cin>>w[i],f[i]=i,siz[i]=1;
	for(int i=1;i<=m;i++)cin>>lll[i]>>rrr[i];
	int l,r;
	for(int i=1;i<=qq;i++)
	{
		cin>>l>>r;
		q[i]={l,r,i};
	}
	sort(q+1,q+1+qq);
	int tmp=qpow(n*(n-1)%mod,mod-2)*2%mod;
	for(int i=1;i<=qq;i++)qw[q[i].l/blo+1].push_back(q[i]);
	blocnt=q[qq].l/blo+1;
	for(int i=1;i<=blocnt;i++)
	{
		int l=i*blo,r=i*blo;
		while(!vv.empty())roll();
		for(auto j:qw[i])
		{
			while(r<j.r)add(++r);
			if(l<=j.r)for(int p=l;p>=j.l;p--)add(p);
			else for(int p=j.l;p<=j.r;p++)add(p);
			ans[j.pos]=now*tmp%mod;
			if(l<=j.r)for(int p=l;p>=j.l;p--)roll();
			else for(int p=j.l;p<=j.r;p++)roll();
		}
	}
	for(int i=1;i<=qq;i++)cout<<ans[i]<<'\n';
}
```

---


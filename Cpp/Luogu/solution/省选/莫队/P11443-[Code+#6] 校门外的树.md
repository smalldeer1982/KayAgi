# [Code+#6] 校门外的树

## 题目背景

搬运自 [Code+ 第 6 次网络赛](https://gitlink.org.cn/thusaa/codeplus6/)。

## 题目描述

L 校门外有一条大马路，路边种了许多的树。L 校的新校长 Lsy 认为学校应该在校门内的马路边种许多的树来绿化环境。在他的植树计划中，共需种植 $n$ 棵树，每棵树都有一个高度 $h_{i}$。然而他是一个很信风水的人，为了保证校园的风水，他请来了作为风水大师的你来为他计算这个植树方案的幸运值。


对于 $n$ 棵树组成的序列，定义其中一个区间 $[u ,v]$ 的幸运值为：

$$\prod\limits_{i=u}^{v-1}\prod\limits_{j=i+1}^{v}\operatorname{gcd}(h_i,h_j)$$

如果 $u = v$ 则幸运值为 $1$。

现在你需要回答 L 校长对于 $q$ 个区间的询问，对于每个询问回答该区间幸运值 $\bmod 998244353$ 的值。

## 说明/提示

### 数据范围

任何时候，保证 $1 \leq n,q, h_{i}\leq 10^5$。

每个子任务的额外约定：

- Subtask1（$10$ 分）：$n,q \leq 100$。
- Subtask2（$10$ 分）：$h_{i}$ 全部相等。
- Subtask3（$15$ 分）：$h_{i} \leq 10^3$。
- Subtask4（$10$ 分）：$q = 1$。
- Subtask5（$25$ 分）：$n, q \leq3\times10^4$。
- Subtask6（$30$ 分）：无额外约束。

## 样例 #1

### 输入

```
6 2
7 9 10 6 2 5
1 4
2 5```

### 输出

```
6
24```

# 题解

## 作者：Monomial (赞：3)

显然有一个莫队的思路，我们维护 $cnt_{i,j}$ 表示所有有 $i^{k}$ 作为因子的 $i^{j}$ 贡献的次数，这个很显然可以 $\mathcal{O}(\log V)$ 维护，每次莫队更新时加上或除掉就行，那么我们有了一个 $\mathcal{O}(n \sqrt{n} d \log V)$ 的做法，其中 $d$ 表示最大不同质因子数。

这个莫队做法很不优，因为更新复杂度达到了 $\log$ 级别。我们去考虑一次更新操作的本质，以右移右端点为例，其实就是计算 $[l,r]$ 对 $r+1$ 位置的贡献，我们设这个为 $f(r+1,[l,r])$，它显然可以拆分为 $f(r+1,[1,r])-f(r+1,[1,l-1])$ 的形式。依照前面的方法枚举前缀，维护 $cnt$，每次去计算 $f$ 的贡献，时间复杂度 $\mathcal{O}(nd\log V+n\sqrt{n}d)$，空间复杂度 $\mathcal{O}(n \sqrt{n})$，足以通过。

接下来可以进一步优化这个做法，我们发现一次连续的更新其一部分前缀的端点是固定的，那么直接记下位置的区间即可，对于另一种情况很容易发现是 $f(x,[1,x-1])$ 的形式，预处理即可，空间复杂度 $\mathcal{O}(n)$，其实也就是莫队二次离线的基本思路。

注意，本做法需要卡常，比如使用光速幂。

---

## 作者：WorldMachine (赞：1)

~~来发最劣解题解！~~

看到 $\gcd$ 考虑对每个素因子分别统计答案。直接莫队是 $\mathcal O(n\sqrt q\log V)$ 的，不太能过。

遂考虑根号分治。对于 $\le\sqrt V$ 的素数，一共有 $\mathcal O\left(\dfrac{\sqrt V}{\log V}\right)$ 个。对于每个素数 $p$，首先以 $\mathcal O(n\log V)$ 的代价预处理出 $\text{sum}_{i,j}$ 表示有多少个 $1\leq k\leq i$ 满足 $p^j\mid a_k$ 且 $p^{j+1}\nmid a_k$。每次询问可以通过后缀和 $\mathcal O(\log V)$ 求出 $p$ 对这次询问的贡献，然后快速幂即可，这一部分复杂度是 $\mathcal O((n+q)\sqrt V)$ 的。

对于 $>\sqrt V$ 的素数，每个 $a_i$ 最多只会有一个这样的因子，直接莫队即可。

$n,q,V$ 同级，总复杂度为 $\mathcal O(n\sqrt n)$。
```cpp
#include <bits/stdc++.h>
using namespace std;
#define il inline
typedef long long ll;
const int N = 100005, mod = 998244353, B = 320, len = 317;
int n, m, a[N], blk[N], tot, pri[N], fac[N], inv[N], ans[N], sum[N][17], son[N], tmp[N], itmp[N], now = 1;
struct query { int id, l, r; } q[N];
il bool cmp(const query &a, const query &b) { return blk[a.l] == blk[b.l] ? ((blk[a.l] & 1) ? a.r < b.r : a.r > b.r) : a.l < b.l; }
il int qpow(int a, ll b) {
	int c = 1;
	while (b) {
		if (b & 1) c = (ll)c * a % mod;
		a = (ll)a * a % mod, b >>= 1;
	}
	return c;
}
il void sieve(int n) {
	fac[1] = 1;
	for (int i = 2; i <= n; i++) {
		if (!fac[i]) pri[++tot] = i, fac[i] = i, inv[i] = qpow(i, mod - 2);
		for (int j = 1; j <= tot && i * pri[j] <= n; j++) {
			fac[i * pri[j]] = pri[j];
			if (!(i % pri[j])) break;
		}
	}
}
il void add(int x) { if (x) now = (ll)now * tmp[x] % mod, tmp[x] = (ll)tmp[x] * x % mod, itmp[x] = (ll)itmp[x] * inv[x] % mod; }
il void del(int x) { if (x) tmp[x] = (ll)tmp[x] * inv[x] % mod, itmp[x] = (ll)itmp[x] * x % mod, now = (ll)now * itmp[x] % mod; }
int main() {
//	freopen("qwq.in", "r", stdin);
//	freopen("qwq.out", "w", stdout);
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	cin >> n >> m;
	for (int i = 1; i <= n; i++) cin >> a[i];
	for (int i = 1; i <= m; i++) cin >> q[i].l >> q[i].r, q[i].id = i, ans[i] = 1;
	sieve(1e5);
	ll ps;
	for (int i = 1, x, t, l, r, s; pri[i] <= B; i++) {
		const int p = pri[i];
		for (int j = 1; j <= n; j++) {
			memcpy(sum[j], sum[j - 1], sizeof(sum[j]));
			x = a[j], t = 0;
			while (!(x % p)) x /= p, t++;
			sum[j][t]++;
		}
		for (int j = 1; j <= m; j++) {
			l = q[j].l, r = q[j].r, ps = s = 0;
			for (int t = 16; t; t--) x = sum[r][t] - sum[l - 1][t], ps += ((ll)s * x + ((ll)x * (x - 1) >> 1)) * t, s += x;
			ans[j] = (ll)ans[j] * qpow(p, ps % (mod - 1)) % mod;
		}
	}
	for (int i = 1, x; i <= n; i++) {
		x = a[i];
		while (x != fac[x]) x /= fac[x];
		if (x > B) son[i] = x;
	}
	for (int i = 1; i <= tot; i++) tmp[pri[i]] = itmp[pri[i]] = 1;
	for (int i = 1; i <= n; i++) blk[i] = (i - 1) / len + 1;
	sort(q + 1, q + 1 + m, cmp);
	for (int i = 1, l = 1, r = 0; i <= m; i++) {
		while (l > q[i].l) add(son[--l]);
		while (r < q[i].r) add(son[++r]);
		while (l < q[i].l) del(son[l++]);
		while (r > q[i].r) del(son[r--]);
		ans[q[i].id] = (ll)ans[q[i].id] * now % mod;
	}
	for (int i = 1; i <= m; i++) cout << ans[i] << '\n';
}
```

---

## 作者：Aegleseeker_ (赞：1)

## 题意

给定长度为 $n$ 的序列 $a_i$，$q$ 次询问，每次给定 $l,r$，求出 $\prod\limits_{i=l}^r\prod\limits_{j=i+1}^{r} \gcd(a_i,a_j)$。

$n,q,a_i\le 10^5$。

## 题解

本题考察对 $\gcd$，质数，莫队等基础算法更本质的理解。

我们先考虑两个数 $a,b$，要求 $\gcd(a,b)$，假如我们不考虑辗转相除，该怎么做？

显然应该从值域中的所有质数入手。我们发现 **每个质数之间都是独立的，可以分开考虑贡献**。

具体来说，我们枚举值域内的质数 $p$ 并枚举其乘方 $p^k$，则 $p^k$ 能对答案造成贡献当且仅当 $p^k|a,p^k|b$ 且不满足 $p^{k+1}|a,p^{k+1}|b$（不然就会重复贡献），然后把所有这样的 $p^k$ 乘进答案里即可，既 $\gcd(a,b)$ 其实是 $\prod p^k$ 的形式。

结合本题，我们来推下式子。不难发现答案实际上是 $\prod\limits_{p\in \operatorname{Prime},k} (p^k)^{\sum\limits_{i=l}^r\sum\limits_{j=i+1}^{r}f(i,j,p,k)}$，其中 $f(i,j,p,k)$ 代表满足 $p^k|a_i,p^k|a_j$ 且不满足 $p^{k+1}|a_i,p^{k+1}|a_j$。这个时候已经可以直接暴力套莫队了，但是显然多个 $\log$，大概率卡不过去。

接下来考察更本质的一些东西：**根号分治**。

当 $p>\sqrt {a_i}$：此时 $p$ 最多在 $a_i$ 中出现一次，直接莫队即可，转移是 $O(1)$ 的，这部分复杂度 $O(n\sqrt n)$。

当 $p\le \sqrt {a_i}$：我们将上面的那个公式中指数部分用前缀和的形式预处理出来，既令 $sum_{i,j}$ 代表 $[1,i]$ 中有多少个 $a_i$ 满足 $p^j$ 能对起造成贡献（还是同样的式子）。查询的时候本质上等价于一段前缀和乘以第二维上的一段后缀和，直接计数即可。最后可能需要光速幂。

这个复杂度凭什么是对的？我们对于 $\le\sqrt {a_i}$ 的每个质数都要用 $O(n\log a_i)$ 的时间求出，而根据广为人知的结论，质数个数是 $\frac{\sqrt {a_i}}{\log a_i}$ 量级的，所以总复杂度还是 $O(n\sqrt {a_i})$ 级别的，可以通过本题。

---


# 参数要吉祥

## 题目描述


扶苏是一个大型语言模型。她共有 $n$ 个参数，依次为 $a_1, a_2, \dots a_n$。现在，你要和她进行 $q$ 次交互。扶苏有先进的混合专家模型（MoE）技术，每轮交互你都会给定一个区间 $[l, r]$，扶苏只有 $a_l, a_{l + 1}, \dots a_r$ 这些参数会被激活。

对于整数 $x$，我们定义其吉祥程度为在一组激活的参数里出现次数为 $x$ 的数的种类数，记为 $c(x)$。对于每次交互，你要找到一个 $x$ 使 $x \times c(x)$ 最大，输出 $x \times c(x)$。

例如，对于一组参数 $[1,1,2,2,33,33,444,444,444]$，则有 $1,2,33$ 这三种数出现了 $2$ 次，取 $x = 2$，得到 $x \times c(x) = 6$。


## 说明/提示

### 数据规模与约定

|测试点编号| $n,q\leq$|特殊约定|
|:-: | :-: | :-: | 
| $1 \sim 4$ | $100$ | 无  |
| $5 \sim 9$ | $10^3$ | 无 |
| $10 \sim 15$ | $3 \times 10^4$ | 无|
| $16 \sim 21$ | $2 \times 10^5$ | 每个数出现次数均不超过 $100$|
| $22 \sim 25$ | $2 \times 10^5$ | 无 |

对全部的测试数据，保证 $1 \leq n,a_i, q \leq 2 \times 10^5$，$1 \leq l \leq r \leq n$。

## 样例 #1

### 输入

```
9 2
1 1 2 2 3 3 4 4 4
1 9
5 9```

### 输出

```
6
3```

# 题解

## 作者：wukaichen888 (赞：25)

建议降蓝。

考虑莫队。

$cnt_i$ 表示 $a$ 中 $i$ 的出现次数。

每次询问 $cnt_i$ 的种数只有 $O(\sqrt n)$。

考虑每次询问怎么快速把 $cnt_i$ 构成的集合找出来。

维护一个队列，每次加删数，如果出现了队列中没有的 $cnt_i$，就加进去，$vis$ 数组记录。

询问时将队列暴力遍历一遍，扔掉实际不存在的 $cnt_i$。

复杂度显然对的。

```cpp
// Problem I
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int N=4e5+5;
int n,K,q,a[N],bl,br;
int vis[N],q1[N],l1,q2[N],l2;
int cnt[N],cnt2[N],res,ans[N];
struct node{int l,r,id;}b[N];
#define c(x) ((x-1)/K+1)
bool cmp(node x,node y){
	if(c(x.r)!=c(y.r)) return x.r<y.r;
	if(c(x.r)&1) return x.l<y.l;
	return x.l>y.l;
}
inline void add(int x,int y){
	x=a[x];
	int cx=cnt[x];
	cnt2[cx]--;
	cnt[x]+=y,cx+=y;
	cnt2[cx]++;
	if(!vis[cx]) q1[++l1]=cx,vis[cx]=1;
}
int main(){
	scanf("%d%d",&n,&q),K=sqrt(n);
	for(int i=1;i<=n;i++) scanf("%d",&a[i]);
	for(int i=1;i<=q;i++) scanf("%d%d",&b[i].l,&b[i].r),b[i].id=i;
	sort(b+1,b+q+1,cmp);
	bl=1;
	for(int i=1;i<=q;i++){
		while(bl>b[i].l) add(--bl,1);
		while(br<b[i].r) add(++br,1);
		while(bl<b[i].l) add(bl++,-1);
		while(br>b[i].r) add(br--,-1);
		l2=res=0;
		for(int j=1;j<=l1;j++){
			vis[q1[j]]=0;
			if(cnt2[q1[j]]) q2[++l2]=q1[j];
		}
		l1=l2;
		for(int j=1;j<=l2;j++){
			vis[q2[j]]=1;
			q1[j]=q2[j],res=max(res,cnt2[q2[j]]*q2[j]);
		}
		ans[b[i].id]=res;
	}
	for(int i=1;i<=q;i++) printf("%d\n",ans[i]);
	return 0;
}
```

---

## 作者：Polarisx (赞：9)

[题目传送门](https://www.luogu.com.cn/problem/P12598)。


## 思路

考虑离线用莫队维护区间每个数 $x$ 的出现次数 $cnt_x$ 和出现次数为 $i$ 的数有 $typ_i$ 种。

- 对于出现次数 $\ge \sqrt n$ 的数，其种类数不会超过 $\sqrt n$，不妨记录这些数，查询时直接查询这些数的贡献即可。

- 对于出现次数 $\le \sqrt n$ 的数，询问时直接枚举出现次数 $i$，然后记录最大的 $i\times typ_i$。

时间复杂度 $\mathcal O(n\sqrt q+q\sqrt n)$。事实上就是根号分治和莫队的融合。



```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;

const int Maxn=3e5+6,N=2e5;
struct ques{
    int l,r,id;
}q[Maxn];

int n,Q,sq;
int a[Maxn];
int ans[Maxn];

int cnt[Maxn],typ[Maxn];
vector<int>lst;

inline void add(int x){
    typ[cnt[a[x]]]--;
    cnt[a[x]]++;
    typ[cnt[a[x]]]++;
}
inline void del(int x){
    typ[cnt[a[x]]]--;
    cnt[a[x]]--;
    typ[cnt[a[x]]]++;
}

int main(){
    scanf("%d%d",&n,&Q); sq=sqrt(n);
    for(int i=1;i<=n;i++) scanf("%d",&a[i]),cnt[a[i]]++;
    for(int i=1;i<=N;i++) if(cnt[i]>sq) lst.emplace_back(i);

    for(int i=1;i<=n;i++) cnt[a[i]]=0;

    for(int i=1;i<=Q;i++){
        scanf("%d%d",&q[i].l,&q[i].r);
        q[i].id=i;
    }
    sort(q+1,q+Q+1,[](ques x,ques y){
        return x.l/sq==y.l/sq?x.r<y.r:x.l<y.l;
    });

    int l=1,r=0;
    for(int i=1;i<=Q;i++){
        while(r<q[i].r) add(++r);
        while(r>q[i].r) del(r--);
        while(l>q[i].l) add(--l);
        while(l<q[i].l) del(l++);

        ll ret=0;
        for(int i=1;i<=sq;i++) ret=max(ret,1ll*i*typ[i]);
        for(auto i:lst) ret=max(ret,1ll*cnt[i]*typ[cnt[i]]);
        ans[q[i].id]=ret;
    }
    for(int i=1;i<=Q;i++) printf("%d\n",ans[i]);

    return 0;
}
```

---

## 作者：shinzanmono (赞：8)

首先考虑莫队，用 multiset 维护区间内的答案，这样做是 $O(n\sqrt{q}\log n)$ 的，显然无法通过，考虑优化。

考虑答案的性质，发现 $x\times c(x)\leq n$。则我们可以使用 $O(1)$ 加入删除，$O(\sqrt{n})$ 查询的值域分块，块长为 $O(\sqrt{n})$，复杂度为 $O(n\sqrt{q}+q\sqrt{n})$。

```cpp
#include<iostream>
#include<algorithm>
#include<unordered_set>
#include<vector>
const int sz=2.5e5+10;
int a[sz],cnt[sz],ccnt[sz];
std::unordered_set<int>s;
struct Block{
  int V,lim,cnt[sz],bcnt[sz];
  Block(int N=1){V=N,lim=__builtin_sqrt(V);}
  int bel(int x){return (x-1)/lim+1;}
  void add(int k,int val){
    if(k==0)return;
    cnt[k]+=val,bcnt[bel(k)]+=val;
  }
  int query(){
    for(int k=bel(V);k>=1;k--){
      if(bcnt[k]==0)continue;
      for(int i=std::min(V,k*lim);bel(i)==k;i--)if(cnt[i]!=0)return i;
    }
    return -1;
  }
}bcnt;
void add(int p){
  bcnt.add(ccnt[cnt[a[p]]]*cnt[a[p]],-1);
  ccnt[cnt[a[p]]]--,cnt[a[p]]++,ccnt[cnt[a[p]]]++;
  bcnt.add(ccnt[cnt[a[p]]]*cnt[a[p]],1);
}
void del(int p){
  bcnt.add(ccnt[cnt[a[p]]]*cnt[a[p]],-1);
  ccnt[cnt[a[p]]]--,cnt[a[p]]--,ccnt[cnt[a[p]]]++;
  bcnt.add(ccnt[cnt[a[p]]]*cnt[a[p]],1);
}
struct Query{
  int l,r,id;
  Query(){}
  Query(int l,int r,int id):l(l),r(r),id(id){}
  bool operator<(const Query &a)const{return r<a.r;}
};
std::vector<Query>qq[sz];
int ans[sz];
int main(){
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  int n,q;
  std::cin>>n>>q;
  for(int i=1;i<=n;i++)std::cin>>a[i];
  int lim=n/__builtin_sqrt(q)+1;
  auto bel=[&](int x){return (x-1)/lim+1;};
  for(int i=1,l,r;i<=q;i++)std::cin>>l>>r,qq[bel(l)].emplace_back(l,r,i);
  for(int i=1;i<=bel(n);i++){
    std::sort(qq[i].begin(),qq[i].end());
    if(i%2==0)std::reverse(qq[i].begin(),qq[i].end());
  }
  ccnt[0]=0x3fffffff,bcnt=Block(n);
  int l=1,r=0;
  for(int b=1;b<=bel(n);b++){
    for(auto [le,re,id]:qq[b]){
      while(l>le)add(--l);
      while(r<re)add(++r);
      while(l<le)del(l++);
      while(r>re)del(r--);
      ans[id]=bcnt.query();
    }
  }
  for(int i=1;i<=q;i++)std::cout<<ans[i]<<"\n";
  return 0;
}
```

---

## 作者：SegmentTree_ (赞：4)

发现题目要维护的信息比较神秘，考虑莫队。  
设 $c1_i$ 表示 $i$ 的出现次数，$c2_i$ 表示有多少个数出现了 $i$ 次，题目要求的就是 $c1_{a_i}\times c2_{c1_{a_i}}$ 的最大值。  
在莫队移动的时候维护这三个东西，前两个是简单的，第三个在 $c1$ 和 $c2$ 有修改时都修改一下，转化成维护一个集合，支持插入或删除一个数，查询最大值。如果用权值线段树的话复杂度是根号带个 $\log$，应该过不了（吧）。因为答案小于等于 $n$，所以可以用值域分块。  
具体的，把答案的值域分成根号个块，维护每个块内的数出现了多少次和每个数出现了多少次，修改时显然是 $O(1)$ 的。查询时，先从后往前枚举答案在哪个块，再枚举答案是块里的哪个数，一次查询是 $O(\sqrt{n})$ 的。  
我写代码的时候为了方便把 $c2$ 初始化了一下。  
```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
const int N = 2e5+5;
namespace tianyu{
	const int B = 450, TB = (N - 1) / B + 3;
	int n, m, bt;
	int a[N], bel[N], br[TB], bl[TB];
	bool vis[N];
	struct que{
		int l, r, id;
	}q[N];
	int ans[N];
	int c1[N], c2[N];
	int cnt1[TB], cnt2[N];
	void add(int x){
		++cnt1[bel[x]];
		++cnt2[x];
	}
	void del(int x){
		--cnt1[bel[x]];
		--cnt2[x];
	}
	void add1(int x){
		del(c1[x] * c2[c1[x]]);
		--c2[c1[x]];
		add(c1[x] * c2[c1[x]]);
		++c1[x];
		del(c1[x] * c2[c1[x]]);
		++c2[c1[x]];
		add(c1[x] * c2[c1[x]]);
	}
	void del1(int x){
		del(c1[x] * c2[c1[x]]);
		--c2[c1[x]];
		add(c1[x] * c2[c1[x]]);
		--c1[x];
		del(c1[x] * c2[c1[x]]);
		++c2[c1[x]];
		add(c1[x] * c2[c1[x]]);
	}
	int query(){
		for (int i = bt;i >= 1;i--){
			if (cnt1[i]){
				for (int j = br[i];j >= bl[i];j--){
					if (cnt2[j]){
						return j;
					}
				}
			}
		}
		return -1;
	}
	void awa(){
		cin >> n >> m;
		for (int i = 1;i <= n;i++){
			cin >> a[i];
			bel[i] = (i - 1) / B + 1;
			if (!vis[a[i]]){
				vis[a[i]] = 1;
				++c2[0];
				add(0);
			}
		}
		bt = bel[n];
		for (int i = 1;i <= bt;i++) bl[i] = (i - 1) * B + 1, br[i] = i * B;
		br[bt] = n;
		for (int i = 1;i <= m;i++){
			cin >> q[i].l >> q[i].r;
			q[i].id = i;
		}
		sort(q + 1, q + 1 + m, [](que a, que b){
			return bel[a.l] != bel[b.l] ? a.l < b.l : (bel[a.l] & 1 ? a.r < b.r : a.r > b.r);
		});
		for (int i = 1, l = 1, r = 0;i <= m;i++){
			int ql = q[i].l, qr = q[i].r;
			while (l > ql) add1(a[--l]);
			while (r < qr) add1(a[++r]);
			while (l < ql) del1(a[l++]);
			while (r > qr) del1(a[r--]);
			ans[q[i].id] = query();
		}
		for (int i = 1;i <= m;i++) cout << ans[i] << '\n';
	}
}
signed main(){
	int T = 1;
	while (T--) tianyu::awa();
	return 0;
}
```

---

## 作者：SukiYuri (赞：3)

### 鲜花

这是一个在线做法。


~~这大概是我中考之前最后一篇题解了，虽然比较内容比较 trivial，但还是希望能够通过。~~

## 分析

[NicoDafaGood](https://www.luogu.com.cn/user/22129) 大神曾经说过，莫队是可以做到在线的，将询问看作二维平面上的点，我们可以在平面上取 $O(n)$ 个关键点，通常我们会取这些关键点为 $O(\sqrt{n})$ 个块的左右端点，这样使得每个询问道这些点的最短距离不超过 $O(\sqrt{n})$。但是这样通常需要花费 $O(n^2)$ 的空间，是无法接受的。

但是对于这一题，我们可以发现任意时刻满足 $c(x)\ne 0$ 的 $x$ 只有 $O(\sqrt{n})$ 个，因此我们只需要存下每个关键点出现的 $x$ 分别是多少以及对应 $c(x)$ 的数值即可。 

对于查询，我们可以暴力统计散块中元素出现的个数，设 $a_i$ 在散块中出现次数为 $f_{a_i}$，在整块中出现的次数为 $g_{a_i}$，那么 $a_i$ 就会令 $c(g_{a_i})\leftarrow c(g_{a_i})-1,c(f_{a_i}+g_{a_i})\leftarrow c(f_{a_i}+g_{a_i})+1$ 因此我们还要为每个 $a_i$ 做一个整块的前缀和以快速计算 $a_i$ 在整块中出现次数。空间 $O(n\sqrt{n})$。

实现比较卡常，注意维护不为 $0$ 的 $x$ 不要用 `bitset`，要用链表维护，对于询问可以开一个栈记录所有出现过的 $x$。当然如果你对于你的常数比较自信，可以随便写。可能是我常数太大了。

参数要吉祥，块长设为 `388` 时的效率较高。

## 代码

```cpp
#include "cstdio"
#include "iostream"
#include "vector"
#include "algorithm"
#include "cstring"
#include "utility"
#define pc putchar_unlocked
#define gc getchar_unlocked
static inline int rd() {
	int num=0;
    bool fg=true;
	char c=gc();
	for (;c<'0'||c>'9';c=gc())
        if (c=='-')fg=false;
	for ( ;c>='0'&&c<='9';c=gc())
        num=(num<<3)+(num<<1)+(c&15);
	if(fg)return num;
    return ~(num-1);
}
void wt(const int &x) {
    if(x>9) wt(x/10);
    pc(x%10|48);
}
using namespace std;
const int maxn=2e5+5,len=388;
vector<pair<int,int> > st[maxn/len+2][maxn/len+2];
int a[maxn],c[maxn],rk[maxn],num[maxn],bel[maxn],sum[maxn][maxn/len+2],pre[maxn],nxt[maxn],stk[maxn],top;
bool vis[maxn];
int main() {
    int n=rd(),m=rd(); nxt[0]=n+1;
    auto lik=[&](int u,int v)->void{
        pre[v]=u; nxt[v]=nxt[u];
        pre[nxt[u]]=v; nxt[u]=v;
    };
    auto cut=[&](int u)->void{
        pre[nxt[u]]=pre[u];
        nxt[pre[u]]=nxt[u];
    };
    auto add=[&](int x)->void{
        if(!c[++num[x]]++) lik(num[x]-1,num[x]);
        if(!--c[num[x]-1]) cut(num[x]-1);
    };
    for(int i=1;i<=n;++i) a[i]=rd(),rk[i]=a[i],bel[i]=i/len;
    sort(rk+1,rk+n+1); int cnt=unique(rk+1,rk+n+1)-rk-1;
    for(int i=1;i<=n;++i) {
        a[i]=lower_bound(rk+1,rk+cnt+1,a[i])-rk;
        for(int j=bel[i];j<=bel[n];++j) ++sum[a[i]][j+1];
    }
    for(int i=0;i<=bel[n];++i) {
        int pos=max(1,i*len); c[0]=n+1;
        for(int j=i;j<=bel[n];++j) {
            int r=min((j+1)*len-1,n);
            while(pos<=r) add(a[pos++]);
            for(int u=nxt[0];u<=n;u=nxt[u]) st[i][j].push_back({u,c[u]});
        }
        nxt[0]=n+1; memset(c,0,sizeof c); memset(num,0,sizeof num);
    }
    while(m--) {
        int l=rd(),r=rd();
        int _l=(bel[l]+1)*len,_r=(bel[r])*len-1;
        if(_l>_r) {
            for(int i=l;i<=r;++i) add(a[i]);
            int ans=0;
            for(int u=nxt[0];u<n;u=nxt[u]) ans=max(ans,u*c[u]),c[u]=0;
            for(int i=l;i<=r;++i) num[a[i]]=0; nxt[0]=n+1;
            cout<<ans<<'\n'; continue;
        }
        // cout<<l<<" "<<r<<" "<<_l<<" "<<_r<<'\n';
        for(auto [u,w]:st[_l/len][_r/len]) c[stk[++top]=u]=w,vis[u]=1;
        for(int i=l;i<_l;++i) ++num[a[i]];
        for(int i=_r+1;i<=r;++i) ++num[a[i]];
        auto mod=[&](int x)->void {
            int cur=sum[x][bel[_r]+1]-sum[x][bel[_l]];
            --c[cur]; cur+=num[x]; num[x]=0;
            if(!c[cur]++) if(!vis[cur]) stk[++top]=cur,vis[cur]=1;
        };
        for(int i=l;i<_l;++i) if(num[a[i]]) mod(a[i]);
        for(int i=_r+1;i<=r;++i) if(num[a[i]]) mod(a[i]);
        int ans=0;
        while(top) {
            ans=max(ans,c[stk[top]]*stk[top]);
            c[stk[top]]=vis[stk[top]]=0; --top;
        }
        wt(ans); pc('\n');
    }
    return 0;
}
```

顺带一提，这题有个 `bitset` 的简单做法，就是用 `bitset` 存下所有不为 $0$ 的 $x$，查询用 `_Find_next()` 函数暴力跳就行了，代码 1 k 多一点。

中考 RP ++ 。

---

## 作者：meyi (赞：3)

莫队是容易看出来的，但值域分块太难了，有没有用更简单的数据结构的做法？

有的兄弟，令 $cnt_i$ 表示 $i$ 这个数在 $a$ 中的出现次数，容易发现 $cnt$ 中最多只有 $O(\sqrt n)$ 种不同的值。于是用链表维护这些值，$O(1)$ 加入删除，$O(\sqrt n)$ 遍历整个链表查询即可。

总时间复杂度 $O(n\sqrt n)$，常数很小，最慢点 0.4s。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
//#pragma GCC optimize("Ofast,no-stack-protector,unroll-loops")
#define ALL(v) v.begin(),v.end()
#define For(i,_) for(int i=0,i##end=_;i<i##end;++i) // [0,_)
#define FOR(i,_,__) for(int i=_,i##end=__;i<i##end;++i) // [_,__)
#define Rep(i,_) for(int i=(_)-1;i>=0;--i) // [0,_)
#define REP(i,_,__) for(int i=(__)-1,i##end=_;i>=i##end;--i) // [_,__)
typedef long long ll;
typedef unsigned long long ull;
#define V vector
#define pb push_back
#define pf push_front
#define qb pop_back
#define qf pop_front
#define eb emplace_back
typedef pair<int,int> pii;
typedef pair<ll,int> pli;
#define fi first
#define se second
const int dir[4][2]={{-1,0},{0,1},{1,0},{0,-1}},inf=0x3f3f3f3f,mod=1e9+7;
const ll infl=0x3f3f3f3f3f3f3f3fll;
template<class T>inline bool ckmin(T &x,const T &y){return x>y?x=y,1:0;}
template<class T>inline bool ckmax(T &x,const T &y){return x<y?x=y,1:0;}
int init=[](){return cin.tie(nullptr)->sync_with_stdio(false),0;}();
int main(){
    int t_case=1;
    //scanf("%d",&t_case);
    while(t_case--){
        int n,q;
        scanf("%d%d",&n,&q);
        V<int>a(n);
        for(int &i:a)scanf("%d",&i);
        V<int>l(q),r(q);
        For(i,q)scanf("%d%d",&l[i],&r[i]),--l[i],--r[i];
        int m=*max_element(ALL(a))+1;
        V<int>c(m),cnt(n+1),nxt(n+1),pre(n+1);
        auto link=[&](int x){
            int y=nxt[0];
            pre[x]=0,nxt[x]=y;
            pre[y]=x,nxt[0]=x;
        };
        auto cut=[&](int x){
            int y=pre[x],z=nxt[x];
            pre[z]=y,nxt[y]=z;
        };
        auto add=[&](int k){
            if(c[k]){
                if(!--cnt[c[k]])cut(c[k]);
            }
            if(!cnt[++c[k]]++)link(c[k]);
        };
        auto del=[&](int k){
            if(!--cnt[c[k]])cut(c[k]);
            if(--c[k]){
                if(!cnt[c[k]]++)link(c[k]);
            }
        };
        const int B=ceil(n/sqrt(q));
        V<int>bel(n);
        FOR(i,B,n)bel[i]=bel[i-B]+1;
        V<int>id(q);
        iota(ALL(id),0);
        sort(ALL(id),[&](int x,int y){return bel[l[x]]!=bel[l[y]]?l[x]<l[y]:(bel[l[x]]&1)?r[x]>r[y]:r[x]<r[y];});
        V<int>ans(q);
        int pl=0,pr=-1;
        for(int i:id){
            while(pl>l[i])add(a[--pl]);
            while(pr<r[i])add(a[++pr]);
            while(pl<l[i])del(a[pl++]);
            while(pr>r[i])del(a[pr--]);
            for(int j=nxt[0];j;j=nxt[j])ckmax(ans[i],j*cnt[j]);
        }
        For(i,q)printf("%d\n",ans[i]);
    }
    return 0;
}
```

---

## 作者：Lucyna_Kushinada (赞：2)

# P12598 参数要吉祥

## 题意

给定长度为 $n$ 的序列，$m$ 次询问区间 $[l,r]$，记 $c(x)$ 为在该区间中**出现次数**为 $x$ 的数的**种类数**，求出最大的 $x\times c(x)$。

## 题解

知识点：莫队，值域分块。

启发：

- 利用值域分块单点修改来实现莫队 $O(1)$ 移动指针。

- 利用莫队指针移动的性质来将值域分块更新复杂度均摊正确。

下文令 $n,m$ 以及值域同阶，都用 $n$ 表示。

小清新莫队。

进行莫队算法的过程中，修改的次数是 $O(n\sqrt{n})$ 的，查询的次数是 $O(n)$ 的。

首先有一个非常显然的 $O(n\sqrt{n} \log_2 n)$ 做法，每次移动指针的时候拿 `multiset` 或者线段树修改，然后查询最值，但这显然不是复杂度最优的做法，他们单次询问可以做到 $O(\log_2 n)$，但修改也同样是 $O(\log_2 n)$ 的，和莫队结合没能均摊好时间复杂度。

考虑值域分块，每个块维护块内的最值。

对于每个询问，在指针移动的过程中，如果修改了一个块内的某个值，显然是不能立即更新的，先它所在的块编号扔到一个栈里，等指针完全移动到该询问后统一处理。

这样做时间复杂度是对的，下面进行证明：

首先，有 $n$ 次询问，莫队算法将这 $n$ 次询问按左端点分到了 $\sqrt{n}$ 个长度为 $\sqrt{n}$ 的块中。

对于一个块内的询问，左端点的活动范围始终在 $\sqrt{n}$ 内，右端点单调递增，极端情况下活动范围为 $n$。

所以一个块内的所有询问总共至多造成 $\sqrt{n}$ 个值域块的更新，$\sqrt{n}$ 个值域块更新的总复杂度是 $O(\sqrt{n}\times \sqrt{n})=O(n)$ 的。

而询问总共分了 $\sqrt{n}$ 个块，所以最坏复杂度也是 $O(n\sqrt{n})$ 的。

对于其他操作，值域分块的单点修改是 $O(1)$ 的，查询是 $O(\sqrt{n})$ 的，综上，用它可以和莫队结合做到 $O(n\sqrt{n})$ 的复杂度。

```cpp
#include<bits/stdc++.h>
using namespace std;

#define rep(i,l,r) for(int i=(l);i<=(r);++i)
#define per(i,l,r) for(int i=(r);i>=(l);--i)
#define pr pair<int,int>
#define fi first
#define se second
#define pb push_back
#define all(x) (x).begin(),(x).end()
#define sz(x) (int)(x).size()
#define bg(x) (x).begin()
#define ed(x) (x).end()

#define N 202505
#define C 450

const int lim=2e5;
int n,m,len,bl[N],a[N],ans[N],cnt[N];

namespace ds{
    int len,c,bl[N],cc[N];
    int st[C],ed[C],mx[C];

    inline void init(){
        len=sqrt(lim);
        c=(lim-1)/len+1;

        rep(i,1,c){
            st[i]=ed[i-1]+1;
            ed[i]=i*len;
        }
        ed[c]=lim;

        rep(i,1,c){
            rep(j,st[i],ed[i]){
                bl[j]=i;
            }
        }
    }

    inline void ref(int k){
        mx[k]=*max_element(cc+st[k],cc+ed[k]+1);
    }

    inline int ask(int l,int r){
        int p=bl[l],q=bl[r],ans=0;

        if(p==q){
            rep(i,l,r){
                ans=max(ans,cc[i]);
            }
        }
        else{
            rep(i,l,ed[p]){
                ans=max(ans,cc[i]);
            }

            rep(i,st[q],r){
                ans=max(ans,cc[i]);
            }

            rep(i,p+1,q-1){
                ans=max(ans,mx[i]);
            }
        }

        return ans;
    }
}

using ds::cc;
using ds::ref;
using ds::ask;

struct node{
    int l,r,i;
}b[N];

bitset<C>upd;
vector<int>tmp;

inline void add(int k){
    int &num=cnt[a[k]];

    if(!upd[ds::bl[num]]){
        tmp.pb(ds::bl[num]);
        upd[ds::bl[num]]=1;
    }

    cc[num]-=num;

    num++;

    cc[num]+=num;

    if(!upd[ds::bl[num]]){
        tmp.pb(ds::bl[num]);
        upd[ds::bl[num]]=1;
    }
}

inline void del(int k){
    int &num=cnt[a[k]];

    if(!upd[ds::bl[num]]){
        tmp.pb(ds::bl[num]);
        upd[ds::bl[num]]=1;
    }

    cc[num]-=num;

    num--;

    cc[num]+=num;

    if(!upd[ds::bl[num]]){
        tmp.pb(ds::bl[num]);
        upd[ds::bl[num]]=1;
    }
}

signed main(){
    // freopen(".in","r",stdin);
    // freopen(".out","w",stdout);
    ios::sync_with_stdio(0);
    cin.tie(0);cout.tie(0);

    cin>>n>>m;

    len=sqrt(n);
    ds::init();

    int V=0;

    rep(i,1,n){
        cin>>a[i];
        V=max(V,a[i]);
        bl[i]=(i-1)/len+1;
    }

    rep(i,1,m){
        b[i].i=i;
        cin>>b[i].l>>b[i].r;
    }

    sort(b+1,b+1+m,[](node x,node y){
        if(bl[x.l]!=bl[y.l]){
            return x.l<y.l;
        }

        return x.r<y.r;
    });

    int l=1,r=0;
    rep(i,1,m){
        while(l<b[i].l){
            del(l++);
        }
        while(l>b[i].l){
            add(--l);
        }
        while(r<b[i].r){
            add(++r);
        }
        while(r>b[i].r){
            del(r--);
        }

        for(int x:tmp){
            ref(x);
            upd[x]=0;
        }
        tmp.clear();

        ans[b[i].i]=ask(1,V);
    }

    rep(i,1,m){
        cout<<ans[i]<<"\n";
    }

    return 0;
}
```

---

## 作者：I_will_AKIOI (赞：2)

上课时偷偷摸鱼来打的，一不小心通过了。

考虑莫队，因为他能很好的维护区间数字出现次数和 $c(x)$。注意到满足 $c(x)>0$ 的 $x$ 的取值只有 $\sqrt{n}$ 个，因此想到在莫队指针移动过程中，使用一个 set 暴力维护每个满足 $c(x)>0$ 的 $x$ 的取值。时间复杂度 $O(q\sqrt n\log n)$，难以通过。

### 优化 1

我们可以在此基础上考虑类似根号分治做法。

+ 对于 $x\le \sqrt n$ 的部分，我们可以直接枚举 $x$ 取最大值，时间复杂度 $O(q\sqrt n)$；

+ 对于 $x>\sqrt n$ 的部分，出现次数 $>\sqrt n$ 的数 $<\sqrt n$ 个，因此开 set 暴力维护就行。注意 set 里面元素也不超过 $\sqrt n$ 个，因此时间复杂度是 $O(q\sqrt n \log \sqrt n)$。最后遍历 set 取最大值。

也就是说，我们把 $x\le \sqrt n$ 的部分从用 set 维护变成了枚举 $x$，优化了时间复杂度，已经足以通过。

```cpp
#include<bits/stdc++.h>
#define N 200005
using namespace std;
struct Data{int l,r,num;}w[N];
int n,m,l,r,block,maxx,a[N],res[N],vis[N],cnt[N];
set<int>s;
bool cmp(Data x,Data y)
{
	if(x.l/block!=y.l/block) return x.l<y.l;
	if((x.l/block)&1) return x.r<y.r;
	return x.r>y.r;
}
void add(int x)
{
	if(vis[x]>block&&cnt[vis[x]]==1) s.erase(vis[x]);
	cnt[vis[x]]--;
	vis[x]++;
	if(vis[x]>block&&cnt[vis[x]]==0) s.insert(vis[x]);
	cnt[vis[x]]++;
	return;
}
void del(int x)
{
	if(vis[x]>block&&cnt[vis[x]]==1) s.erase(vis[x]);
	cnt[vis[x]]--;
	vis[x]--;
	if(vis[x]>block&&cnt[vis[x]]==0) s.insert(vis[x]);
	cnt[vis[x]]++;
	return;
}
int main()
{
	ios::sync_with_stdio(0);
	cin>>n>>m;
	block=sqrt(n);
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=1;i<=m;i++) cin>>w[i].l>>w[i].r,w[i].num=i;
	cnt[0]=n;
	sort(w+1,w+m+1,cmp);
	for(int i=1;i<=m;i++)
	{
		while(w[i].l<l) add(a[--l]);
		while(w[i].r>r) add(a[++r]);
		while(w[i].l>l) del(a[l++]);
		while(w[i].r<r) del(a[r--]);
		maxx=0;
		for(int j=0;j<=block;j++) maxx=max(maxx,j*cnt[j]);
		for(int now:s) maxx=max(maxx,now*cnt[now]);
		res[w[i].num]=maxx;
	}
	for(int i=1;i<=m;i++) cout<<res[i]<<"\n";
	return 0;
}
```

### 优化 2

在优化 1 的基础上，我们发现 set 需要进行 $q\sqrt n$ 次加入和删除，但是只需要遍历 $q$ 次。因此我们可以把 set 换成 vector，再开一个数组维护每个数字被删的次数，最后遍历时统一删除。可以把时间复杂度优化到 $O(q\sqrt n)$。

```cpp
#include<bits/stdc++.h>
#define N 200005
using namespace std;
struct Data{int l,r,num;}w[N];
int n,m,l,r,block,maxx,a[N],res[N],vis[N],cnt[N],out[N];
vector<int>in;
bool cmp(Data x,Data y)
{
	if(x.l/block!=y.l/block) return x.l<y.l;
	if((x.l/block)&1) return x.r<y.r;
	return x.r>y.r;
}
void add(int x)
{
	if(vis[x]>block&&cnt[vis[x]]==1) out[vis[x]]++;
	cnt[vis[x]]--;
	vis[x]++;
	if(vis[x]>block&&cnt[vis[x]]==0) in.push_back(vis[x]);
	cnt[vis[x]]++;
	return;
}
void del(int x)
{
	if(vis[x]>block&&cnt[vis[x]]==1) out[vis[x]]++;
	cnt[vis[x]]--;
	vis[x]--;
	if(vis[x]>block&&cnt[vis[x]]==0) in.push_back(vis[x]);
	cnt[vis[x]]++;
	return;
}
int main()
{
	cin>>n>>m;
	block=sqrt(n);
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=1;i<=m;i++) cin>>w[i].l>>w[i].r,w[i].num=i;
	cnt[0]=n;
	sort(w+1,w+m+1,cmp);
	for(int i=1;i<=m;i++)
	{
		while(w[i].l<l) add(a[--l]);
		while(w[i].r>r) add(a[++r]);
		while(w[i].l>l) del(a[l++]);
		while(w[i].r<r) del(a[r--]);
		maxx=0;
		for(int j=0;j<=block;j++) maxx=max(maxx,j*cnt[j]);
		vector<int>tmp;
		for(int now:in)
		{
			if(!out[now]) maxx=max(maxx,now*cnt[now]),tmp.push_back(now);
			else out[now]--;
		}
		in=tmp;
		res[w[i].num]=maxx;
	}
	for(int i=1;i<=m;i++) cout<<res[i]<<"\n";
	return 0;
}
```

---

## 作者：wmrqwq (赞：2)

# 题目链接

首先考虑莫队。

发现这东西显然可以开两个桶来维护。

具体的，设 $b_i$ 表示这个区间有几个数字值为 $i$，$c_i$ 表示 $b$ 序列有几个数字值为 $i$。

那么答案即为 $\max_{i=1}^{n} (c_i \times i)$。

考虑咋维护这个东西。

注意到 $\displaystyle\sum_{i=1}^{n} [i \ge B][c_i > 0]$ 的值 $\le B$，于是我们开一个 vector 维护 $i \ge B$ 且 $c_i > 0$ 的所有 $i$ 即可。

$B$ 取 $450$ 即可通过。

# 参考代码

```cpp
ll n,m;
ll L,R;
ll ans[1000010];
ll B[1000010];
ll a[1000010];
ll b[1000010];
ll c[1000010];
ll d[1000010];
ll l[1000010],r[1000010];
ll pos[1000010];
ll ss;
ll sq;
struct node{
    ll l,r,id;
}q[1000010];
bool cmp(node x,node y)
{
    if((x.l-1)/sq!=(y.l-1)/sq)
        return x.l<y.l;
    if(((x.l-1)/sq)&1)
        return x.r<y.r;
    return x.r>y.r;
}
vector<ll>v;
ll vis[1000010];
ll sz;
void clear()
{
	sz=0;
    v.clear();
    forl(i,0,n+2)
        vis[i]=0,
		pos[i]=-1;
    forl(i,1,n)
        if(i<=sq || d[i]>0)
            vis[i]=1,
            v.pb(i),
			pos[i]=sz++;
}
void Add(ll x)
{
    ss++;
    // if(ss%n==0)
    //     clear();
    ll num=b[a[x]];
    c[num]--;
    d[num]=c[num]*num;

    b[a[x]]++;
    if(!vis[b[a[x]]])
    {
    	if(pos[num]!=-1 && !c[num])
    	{
    		v[pos[num]]=b[a[x]];
    		pos[num+1]=pos[num];
    		pos[num]=-1;
    		
    		vis[num+1]=1,
    		vis[num]=0;
		}
    	else
		    vis[num+1]=1,
		    pos[num+1]=sz++,
    	    v.pb(num+1);
	}
    c[num+1]++;
    d[num+1]=c[num+1]*(num+1);
}
void Del(ll x)
{
    ss++;
    // if(ss%n==0)
    //     clear();
    c[b[a[x]]]--;
    d[b[a[x]]]=c[b[a[x]]]*b[a[x]];

    b[a[x]]--;
    if(!vis[b[a[x]]])
    {
    	if(pos[b[a[x]]+1]!=-1 && !c[b[a[x]]+1])
    	{
    		v[pos[b[a[x]]+1]]=b[a[x]];
    		pos[b[a[x]]]=pos[b[a[x]]+1];
    		pos[b[a[x]]+1]=-1;
    		
    		vis[b[a[x]]+1]=0,
    		vis[b[a[x]]]=1;
		}
    	else
		    vis[b[a[x]]]=1,
		    pos[b[a[x]]]=sz++,
    	    v.pb(b[a[x]]);
	}
        
    c[b[a[x]]]++;
    d[b[a[x]]]=c[b[a[x]]]*b[a[x]];
}
/*
注意到 x>sq 时，

d[x]>0 的 x 个数只有 sq 个，维护 d[x]>0 的 pos。

每 n 次操作重构一次。

对完了。
*/
ll Query()
{
    ll A=0;
    for(auto i:v)
        Max(A,d[i]);
    return A;
}
void _clear(){}
void solve()
{
    _clear();
    sq=450;
    cin>>n>>m;
    forl(i,1,n)
    {
        l[i]=r[i-1]+1;
        r[i]=min(sq,n);
        forl(j,l[i],r[i])
            B[j]=i;
    }
    forl(i,1,n)
        cin>>a[i];
    forl(i,1,m)
        cin>>q[i].l>>q[i].r,
        q[i].id=i;
    sort(q+1,q+1+m,cmp);
    L=1,R=0;
    forl(i,1,m)
    {
        while(L>q[i].l)
            Add(--L);
        while(R<q[i].r)
            Add(++R);
        while(L<q[i].l)
            Del(L++);
        while(R>q[i].r)
            Del(R--);
        ans[q[i].id]=Query();
    }
    forl(i,1,m)
        cout<<ans[i]<<endl;
}
```

---

## 作者：MoonCake2011 (赞：2)

可以直接莫队 + 值域分块统计。

每次加数删数时可以用桶直接统计，每次统计答案时可以在值域上分块获得一个 $O(n\sqrt{n})$ 的算法，也是个经典做法。

代码太简单，不给了。

---

## 作者：_biLang_ (赞：1)

# 思路
一眼莫队。$$$ \text{cnt}_x $$$ 记录 $$$ a_{l \dots r} $$$ 中 $$$ x $$$ 的出现次数，$$$ \text{freq}_x $$$ 记录 $$$ \text{cnt} $$$ 中 $$$ x $$$ 的出现次数，再实现一个桶记录所有使得 $$$ \text{freq}_x \neq 0 $$$ 的 $$$ x $$$。易证这种 $$$ x $$$ 的数量是 $$$ \mathcal{O}(\sqrt n) $$$ 的。莫队进出 $$$ \Theta(1) $$$，计算答案时直接遍历一遍桶 $$$ \mathcal{O}(\sqrt n) $$$，$$$ n $$$ 和 $$$ q $$$ 同阶，总时复 $$$ \mathcal{O}(n \sqrt n) $$$。\
强推一下一个值域较小时可用的常数极小的桶。``` bkt[], tot, pos[] ``` 中 ```tot``` 为桶中存了几个数，``` bkt[1...tot]``` 记录桶中所有的值，```x``` 在桶内时 ```pos[x]``` 满足 ``` bkt[pos[x]] = x ```，否则 ``` pos[x] = 0 ```，插入时直接 ``` bkt[++tot] = x, pos[x] = tot ```，删除时将 ```bkt[tot]``` 换至 ```pos[x]```。
# code
```cpp
#include <bits/stdc++.h>
#include <bits/extc++.h>

namespace io
{
  char buf[1 << 20], *p1(buf), *p2(buf), c;
#define gc() ((p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1 << 20, stdin), p1 == p2)) ? EOF : *p1++)
  
  template <typename _Tp> inline void read(_Tp& x) { while (!isdigit(c = gc())); while (x = (x << 1) + (x << 3) + (c ^ 48), isdigit(c = gc())); }
  template <typename _Tp, typename... Args> inline void read(_Tp& x, Args&... args) { read(x), read(args...); }
  
  char pbuf[1 << 20], *pp(pbuf), sta[100], *p(sta);
#define flush() (fwrite(pbuf, 1, pp - pbuf, stdout), pp = pbuf)
#define pc(c) ((pp - pbuf == 1 << 20) && flush(), *pp++ = (c))
  
  template <typename _Tp> inline void write(_Tp x) { while (*p++ = x % 10 ^ 48, x /= 10); while (pc(*--p), p != sta); pc('\n'); }
  
  struct flusher { inline ~flusher(void) { flush(); } } ioflusher;
} // namespace io

using u32 = unsigned;

constexpr u32 N(2e5+1);

u32 n, q, sz, a[N], blk[N], ans[N], cnt[N], freq[N], bkt[N], tot, pos[N]; struct query { u32 L, R, id; } qr[N];

inline bool operator < (const query& a, const query& b) { return (blk[a.L] == blk[b.L]) ? ((a.R > b.R) ^ (blk[a.L] & 1)) : (a.L < b.L); }

#define push(x) (bkt[pos[x] = tot++] = x)
#define pop(x) (bkt[pos[x]] = bkt[--tot], pos[bkt[tot]] = pos[x], pos[x] = 0)
inline void add(const u32& a) { !(--freq[cnt[a]]) && pop(cnt[a]), !(freq[++cnt[a]]++) && push(cnt[a]); }
inline void del(const u32& a) { !(--freq[cnt[a]]) && pop(cnt[a]), !(freq[--cnt[a]]++) && push(cnt[a]); }

signed main(void)
{
  u32 i, j, L, R; io::read(n, q), sz = sqrt(n); for (i = j = 1; i <= n; i++) io::read(a[i]), blk[i] = j, !(i & sz) && (j++);
  for (i = 0; i < q; i++) io::read(qr[i].L, qr[i].R), qr[i].id = i; std::sort(qr, qr + q);
  for (i = 0, L = 1, R = 0, freq[0] = n, bkt[pos[0] = tot++] = 0; i < q; i++)
  {
    while (L > qr[i].L) add(a[--L]); while (R < qr[i].R) add(a[++R]); while (L < qr[i].L) del(a[L++]); while (R > qr[i].R) del(a[R--]);
    for (j = 0; j < tot; j++) (ans[qr[i].id] < bkt[j] * freq[bkt[j]]) && (ans[qr[i].id] = bkt[j] * freq[bkt[j]]);
  }
  for (i = 0; i < q; i++) io::write(ans[i]); return 0;
}

```

---

## 作者：Genius_Star (赞：0)

### 思路：

首先注意到答案的值域在 $[1, n]$  之间。

考虑莫队，故需要支持 $N \sqrt{N}$ 次单点修改，$Q$ 次全局最大值的查询；直接使用堆或平衡树维护可以做到 $O(N \sqrt{N \log N})$，应该过不去。

因为是全局查询，故考虑套上一个值域分块，维护每个值域块内是否有数即可做到单点修改 $O(1)$，全局查询 $O(\sqrt{N})$。

总时间复杂度为 $O(N \sqrt{N})$。

### 完整代码：

```cpp
#include<bits/stdc++.h>
#define lowbit(x) x & (-x)
#define ls(k) k << 1
#define rs(k) k << 1 | 1
#define fi first
#define se second
#define mkp(x, y) make_pair(x, y)
#define open(s1, s2) freopen(s1, "r", stdin), freopen(s2, "w", stdout);
using namespace std;
typedef __int128 __;
typedef long double lb;
typedef double db;
typedef unsigned long long ull;
typedef long long ll;
typedef unsigned int uint;
bool Begin;
const int N = 2e5 + 10;
inline ll read(){
    ll x = 0, f = 1;
    char c = getchar();
    while(c < '0' || c > '9'){
        if(c == '-')
          f = -1;
        c = getchar();
    }
    while(c >= '0' && c <= '9'){
        x = (x << 1) + (x << 3) + (c ^ 48);
        c = getchar();
    }
    return x * f;
}
inline void write(ll x){
	if(x < 0){
		putchar('-');
		x = -x;
	}
	if(x > 9)
	  write(x / 10);
	putchar(x % 10 + '0');
}
int n, q, t, k;
int a[N], id[N], ans[N], cnt[N], num[N], L[N], R[N];
struct Ques{
	int l, r, x;
	inline bool operator<(const Ques&rhs)const{
		if(id[l] ^ id[rhs.l])
		  return id[l] < id[rhs.l];
		return r < rhs.r;
	}
}Q[N];
namespace Block{
	int a[N], h[N];
	inline void add(int x, int v){
		if(!x)
		  return ;
		//cerr << x << ' ' << v << '\n';
		a[x] += v;
		h[id[x]] += v;
	}
	inline int ask(){
		for(int i = k; i >= 1; --i)
		  if(h[i])
			for(int j = R[i]; j >= L[i]; --j)
			  if(a[j])
			    return j;
		return 0;
	}
}
inline void add(int x, int v){
	//cerr << x << ' ';
	x = a[x];
	//cerr << a[x] << ' ' << cnt[x] << '\n';
	Block::add(cnt[x] * num[cnt[x]], -1);
	--num[cnt[x]];
	Block::add(cnt[x] * num[cnt[x]], 1);
	cnt[x] += v;
	Block::add(cnt[x] * num[cnt[x]], -1);
	++num[cnt[x]];
	Block::add(cnt[x] * num[cnt[x]], 1);
}
bool End;
int main(){
	num[0] = 1e9;
	n = read(), q = read();
	for(int i = 1; i <= n; ++i)
	  a[i] = read();
	for(int i = 1; i <= q; ++i)
	  Q[i] = {(int)read(), (int)read(), i};
	t = sqrt(n), k = (n + t - 1) / t;
	for(int i = 1; i <= n; ++i)
	  id[i] = (i - 1) / t + 1;
	for(int i = 1; i <= k; ++i){
		L[i] = R[i - 1] + 1;
		R[i] = i * t;
	}
	R[k] = n;
	sort(Q + 1, Q + q + 1);
	int l = 1, r = 0;
	for(int i = 1; i <= q; ++i){
		while(l > Q[i].l)
		  add(--l, 1);
		while(r < Q[i].r)
		  add(++r, 1);
		while(l < Q[i].l)
		  add(l++, -1);
		while(r > Q[i].r)
		  add(r--, -1);
		ans[Q[i].x] = Block::ask();
	}
	for(int i = 1; i <= q; ++i){
		write(ans[i]);
		putchar('\n');
	}
	cerr << '\n' << abs(&Begin - &End) / 1048576 << "MB";
	return 0;
}
```

---

## 作者：ax_by_c (赞：0)

考虑莫队，注意到 $xc(x)\le n$，使用 $O(1)$ 修改 $O(\sqrt n)$ 查询的值域分块即可做到 $O(n\sqrt n)$。

```cpp
#include<bits/stdc++.h>
#define rep(i,l,r) for(int i=(l);i<=(r);i++)
#define per(i,r,l) for(int i=(r);i>=(l);i--)
#define repll(i,l,r) for(ll i=(l);i<=(r);i++)
#define perll(i,r,l) for(ll i=(r);i>=(l);i--)
#define pb push_back
#define ins insert
#define clr clear
using namespace std;
namespace ax_by_c{
typedef long long ll;
const int N=2e5+5;
const int B=450;
int n,q,a[N];
int len,blk,bl[B],br[B],col[N];
struct Q{
	int l,r,id;
}qs[N];
int ans[N];
bool cmp(Q x,Q y){
	if(col[x.l]==col[y.l])return (col[x.l]&1)^(x.r<y.r);
	return x.l<y.l;
}
int cl,cr,cnt[N],cc[N];
int sc[N],bsc[B];
void _add(int x){
	if(!x)return ;
	sc[x]++;
	bsc[col[x]]++;
}
void _rem(int x){
	if(!x)return ;
	sc[x]--;
	bsc[col[x]]--;
}
void add_(int x){
	_rem(x*cc[x]);
	cc[x]++;
	_add(x*cc[x]);
}
void rem_(int x){
	_rem(x*cc[x]);
	cc[x]--;
	_add(x*cc[x]);
}
void add(int pos){
	rem_(cnt[a[pos]]);
	cnt[a[pos]]++;
	add_(cnt[a[pos]]);
}
void rem(int pos){
	rem_(cnt[a[pos]]);
	cnt[a[pos]]--;
	add_(cnt[a[pos]]);
}
int Q(){
	int p=0;
	rep(i,1,blk)if(bsc[i])p=i;
	if(!p)return 0;
	int res=0;
	rep(i,bl[p],br[p])if(sc[i])res=i;
	return res;
}
void slv(){
	scanf("%d %d",&n,&q);
	rep(i,1,n)scanf("%d",&a[i]);
	len=sqrt(n);
	while(br[blk]!=n){
		blk++;
		bl[blk]=br[blk-1]+1;
		br[blk]=min(bl[blk]+len-1,n);
		rep(i,bl[blk],br[blk])col[i]=blk;
	}
	rep(i,1,q)scanf("%d %d",&qs[i].l,&qs[i].r),qs[i].id=i;
	sort(qs+1,qs+1+q,cmp);
	cl=1,cr=0;
	rep(i,1,q){
		while(cr<qs[i].r)cr++,add(cr);
		while(qs[i].l<cl)cl--,add(cl);
		while(qs[i].r<cr)rem(cr),cr--;
		while(cl<qs[i].l)rem(cl),cl++;
		ans[qs[i].id]=Q();
	}
	rep(i,1,q)printf("%d\n",ans[i]);
}
void main(){
	int T=1;
	// int csid=0;scanf("%d",&csid);
    // scanf("%d",&T);
    while(T--)slv();
}
}
int main(){
	string __name="";
	if(__name!=""){
		freopen((__name+".in").c_str(),"r",stdin);
		freopen((__name+".out").c_str(),"w",stdout);
	}
	ax_by_c::main();
	return 0;
}
```

---


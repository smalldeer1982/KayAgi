# 小清新人渣的本愿

## 题目背景

**本题时限3s，空间128MB**

我感觉我要挂省选

人渣的本愿是一个有趣的番

可爱的花火喜欢从小和她谈♂笑♂风♂生的欧♂尼♂酱鸣海，欧尼酱特别想当老师，然后剧本安排当了花火的班主任。

然而有个叫做皆川茜的奇怪的人抢走了欧尼酱！

花火就很失落呀，然后看到一个叫做麦的人也很失落，原来麦喜欢茜老师。。。

花火和麦从此天天谈笑风生，然后决定在一起，把对方当做自己喜欢的人的替代品

因为花火很可爱，所以有许多奇怪的人喜欢花火，比如一个叫做绘鸠早苗的妹子

因为麦长的也不错，所以有许多奇怪的人喜欢麦，比如一个叫做最可的妹子

然后就开始愉快的生♂活了~

以上内容如果你没有看过这个番可以无视掉


按照套路，现在欧尼酱会问花火一个OI问题（一般是数据结构），然后花火肯定不会OI，所以会来请教您这位IOI Au选手，然后您肯定会帮助她

但是
这个套路太无聊了，我们来换一个（但是不会改变您是IOI Au选手的事实）

花火有一天看了几个有趣的番，叫做“在W??身上寻找女装是否搞错了什么”，“从女装开始的?X?”，“我家大佬不可能那么可爱”，然后发现??H太厉害了，然后就穿越到了异世界，和???谈笑风生

花火就和???做了一个交♂易，花火帮???做一道题，然后???帮花火改写地球online的程序，让花火和欧尼酱在♂一♂起

???虽然非常厉害，但是不会数据结构题，他最近刚刚遇到一道有趣的数据结构题，于是他接受了交易

但是花火也不会数据结构题呀

所以又回到了这个老套路，就靠您这个IOI Au选手来帮她了！

以上内容如果你没有看过这个番还是可以无视掉

这里用一个经典的图来解释这个关系（其实没那么蛋疼的）

![](https://cdn.luogu.com.cn/upload/pic/4628.png)

## 题目描述

这个题是这样的：

给你一个序列 $a$，长度为 $n$，有 $m$ 次操作，每次询问一个区间是否可以选出两个数它们的差为 $x$，或者询问一个区间是否可以选出两个数它们的和为 $x$，或者询问一个区间是否可以选出两个数它们的乘积为 $x$ ，这三个操作分别为操作 $1,2,3$。

选出的这两个数可以是同一个位置的数。

![](https://cdn.luogu.com.cn/upload/pic/4629.png)

## 说明/提示

定义 $c$ 为每次的 $x$ 和 $a_i$ 中的最大值，$a_i \geq 0$，每次的 $x\geq 0$。

对于 $10\%$ 的数据，$n,m,c \leq 100$。

对于另外 $10\%$ 的数据，$n,m,c \leq 3\times 10^3$。

对于另外 $10\%$ 的数据，只有 $1$ 操作。

对于另外 $10\%$ 的数据，只有 $2$ 操作。
 
对于另外 $10\%$ 的数据，只有 $3$ 操作。

对于 $100\%$ 的数据，$n,m,c \leq 10^5$。

![](https://cdn.luogu.com.cn/upload/pic/4630.png)

## 样例 #1

### 输入

```
10 10
1 1 8 9 9 1 1 1 1 9 
3 5 9 42
2 1 3 14
2 3 5 2
2 3 3 6
1 6 10 18
3 4 9 14
2 1 4 22
3 1 3 32
2 5 6 32
3 1 9 17```

### 输出

```
bi
bi
bi
bi
bi
bi
bi
bi
bi
bi
```

## 样例 #2

### 输入

```
5 5
1 1 2 3 4
2 1 1 2
1 1 2 2
3 1 1 1
3 5 5 16
1 2 3 4```

### 输出

```
hana
bi
hana
hana
bi```

# 题解

## 作者：noip (赞：82)

 ![](https://cdn.luogu.com.cn/upload/pic/4666.png) 

考虑对于减操作，用bitset来维护每个数是否出现过

这样就可以O( c / 64 )的查询区间是否有两个数差为x了，即得到区间的bitset a，( a & ( a << x ) ).count()

加操作同理，维护一个反的bitset即可

乘操作直接暴力枚举小的因数，是O( sqrt( n ) )的

用膜队维护区间的bitset，总复杂度为O( m( sqrt( n ) + c / 64 ) )

其实除也可以做的。。。只是似乎有点麻烦


---

## 作者：bztMinamoto (赞：41)

话说为啥楼下两位大佬就不能说的清楚点么……蒟蒻理解的很辛苦……我果然还是太菜了……

由乃tql……zcytql……

我们考虑把询问给离线，用莫队做

然后用bitset维护，每一位代表每一个数字是否存在，记为$now1$

然后再记录一个$now1$的反串$now2$（就是每一位代表的是$N-x$），干吗用等下说

1操作的话，因为每一个位置代表一个数字，如果存在$z-y=x$，可以转化为同时存在$z$和$z-x$，那么把$now1$左移$x$位并与$now1$做$\&$运算，看看是否等于$0$，如果不是说明不存在

2操作的话，$now2$中的$y'$代表数字$N-y$，然后求是否存在$z+y=x$，也就是求是否同时满足$now1$中有$z$和$now2$中有$y'$，带进前面的式子里，$N-y'+z=x,z-y'=x-N$，然后就转化成和上面一样了，那么只要把$now2$右移$N-x$位并与$now1$做$\&$运算就行了

3操作的话，我们可以考虑枚举约数（总共是$\sqrt {n}$个，时间足够），然后在$now1$里每一次查询即可

顺带一提，代码里bitset中的any返回是否有1

```
//minamoto
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<bitset>
using namespace std;
#define getc() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
char buf[1<<21],*p1=buf,*p2=buf;
inline int read(){
    #define num ch-'0'
    char ch;bool flag=0;int res;
    while(!isdigit(ch=getc()))
    (ch=='-')&&(flag=true);
    for(res=num;isdigit(ch=getc());res=res*10+num);
    (flag)&&(res=-res);
    #undef num
    return res;
}
const int N=100000;
struct node{
	int k,l,r,x,id;
}q[N+5];
int m,n,l,r,s;
int a[N+5],c[N+5],ans[N+5],rt[N+5];
bitset<N+5> now1,now2;
inline int operator <(node x,node y){
	return rt[x.l]==rt[y.l]?rt[x.l]&1?x.r<y.r:x.r>y.r:rt[x.l]<rt[y.l];
}
inline void init(){
	n=read(),m=read(),s=sqrt(n);
	for(int i=1;i<=n;++i) a[i]=read(),rt[i]=(i-1)/s+1;
	for(int i=1;i<=m;++i){
		q[i].k=read(),q[i].l=read(),q[i].r=read();
		q[i].x=read(),q[i].id=i;
	}
	sort(q+1,q+1+m);l=1,r=0;
}
inline void add(int x){if(c[x]++==0)now1[x]=1,now2[N-x]=1;}
inline void del(int x){if(--c[x]==0)now1[x]=0,now2[N-x]=0;}
int main(){
	init();
	for(int i=1;i<=m;++i){
		while(l<q[i].l) del(a[l++]);
		while(l>q[i].l) add(a[--l]);
		while(r>q[i].r) del(a[r--]);
		while(r<q[i].r) add(a[++r]);
		int k=q[i].k,x=q[i].x;
		switch(k){
			case 1:{
				if((now1&(now1<<x)).any())
				ans[q[i].id]=1;
				break;
			}
			case 2:{
				if((now1&(now2>>(N-x))).any())
				ans[q[i].id]=1;
				break;
			}
			case 3:{
				for(int j=1;j*j<=x;++j)
				if(!(x%j))
				if(now1[j]&&now1[x/j]){
					ans[q[i].id]=1;break;
				}
				break;
			}
		}
	}
	for(int i=1;i<=m;++i)
	puts(ans[i]?"hana":"bi");
	return 0;
}
```

---

## 作者：zcysky (赞：34)

加减维护一个bitset就好了

这个套路很简单，百度下bitset你就会了

实在不行你就简单理解为状压

但是乘可能不好bitset

所以直接大力枚举约数

反正是O(sqrt(n))个

不会出事的

```cpp
#include<bits/stdc++.h>
#define N 100000
#define M 20000005
using namespace std;
struct Query{int k,l,r,x,id;}q[N+5];
int m,n,l,r,s;
int a[N+5],c[N+5],ans[N+5],rt[N+5];
bitset<N+5> now1,now2;
char DR[M+10],*P=DR;
inline bool operator<(Query x,Query y){
    return rt[x.l]==rt[y.l]?rt[x.l]&1?x.r<y.r:x.r>y.r:rt[x.l]<rt[y.l];
}
struct FastIO{
    static const int S=1310720;
    int wpos;char wbuf[S];
    FastIO():wpos(0) {}
    inline int xchar(){
        static char buf[S];
        static int len=0,pos=0;
        if(pos==len)pos=0,len=fread(buf,1,S,stdin);
        if(pos==len)return -1;
        return buf[pos++];
    }
    inline int read(){
        int c=xchar(),x=0;
        while(c<=32&&~c)c=xchar();
        if(c==-1)return -1;
        for(;'0'<=c&&c<='9';c=xchar())x=x*10+c-'0';
        return x;
    }
}io;
inline void init(){
    n=io.read();m=io.read();s=(int)sqrt(n);
    for(register int i=1;i<=n;++i)a[i]=io.read();
    for(register int i=1;i<=n;++i)rt[i]=(i-1)/s+1;
    for(register int i=1;i<=m;++i){
        q[i].k=io.read();q[i].l=io.read();q[i].r=io.read();
        q[i].x=io.read();q[i].id=i;
    }
    sort(q+1,q+m+1);l=1;r=0;
}
inline void add(int x){if(c[x]++==0)now1[x]=1,now2[N-x]=1;}
inline void del(int x){if(--c[x]==0)now1[x]=0,now2[N-x]=0;}
int main(){
    init();
    for(int i=1;i<=m;i++){
        for(;q[i].l<l;)add(a[--l]);
        for(;q[i].l>l;)del(a[l++]);
        for(;q[i].r<r;)del(a[r--]);
        for(;q[i].r>r;)add(a[++r]);int k=q[i].k,x=q[i].x;
        if(k==1){if((now1&(now1<<x)).any())ans[q[i].id]=1;}
        else if(k==2){if((now1&(now2>>(N-x))).any())ans[q[i].id]=1;}
        else{
            for(int j=1;j*j<=x;j++)
                if(!(x%j))if(now1[j]&&now1[x/j]){ans[q[i].id]=1;break;}
        }
    }
    for (int i=1;i<=m;i++)if(ans[i])puts("hana");else puts("bi");
    return 0;
}
```

---

## 作者：NaCly_Fish (赞：25)

$\text{Updated on 12.20:}$ 描述的地方有一些锅，已修复  


这是个很不错的题啊，巧用了 bitset。  
本人做完这道题，也是更深地了解了 bitset 的各种妙用。  

不过在说正解之前，我们先来看一个比较有启发意义的暴力：  

对于暴力算法，可以搞三个数组，分别记录当前区间可以搞出的和、差、积，第 $i$ 项都表示是否能搞出 $i$ 来。  
在移动当前区间端点时，线性的扫一遍区间，然后更新这三个数组。 

然而，这样做的时间复杂度达到了 $\text O (n^\frac52)$。   
***
那我们可以不记录能搞出来的数，而是记录当前区间内出现的数，又会怎样呢？  

这里，我们记录 $f_i$ 表示当前区间内是否出现过 $i$。  
那对于操作 $1$，可以这么处理：  

假设可以找到两个数 $a,b$，满足 $a-b=x$；实际上是要找 $a$ 和 $a-x$ 两个数，就满足条件了。  
在每次询问的时候，要 $\text O (n)$ 扫一遍来检查。  
  
不过我们可以刚才小小的转化，巧妙的用  bitset 来得出答案：    


只需要将 $f$ 左移 $x$ 位，原本在第 $i$ 项的数移到了第 $i-x$ 项（若 $x>i$，这一项就被挤出 bitset 了）。  

现在再把左移后的 $f$ 和原本的做一个 $\text{and}$ 运算，如果运算结果中包含 $1$，显然就说明了区间中存在 $a-b=x$，这样做的时间复杂度只有$\Theta(n/w)$。这里 $w$ 取决于电脑配置，一般是 $64$。  

顺带说一下，bitset 自带一个成员函数 `any()`，可以查询 bitset 中是否含有 $1$。

***
对于操作 $2$，我们发现只有一个 $f$ 数组已经不够用了 —— 再引入一个 $g$ 数组就好啦！  
这里 $g_i$ 记录的是 $f_{c-i}$ 的值 $(c=10^5)$。  

我们类比操作 $1$ 的做法，设存在两个数 $a,b$，满足 $a+b=x$，得到 $b=x-a$。   

将 $g$ 右移 $c-x$ 位，和 $f$ 做一下 $\text{and}$ 运算。类比上面就知道如果存在 $1$，就说明答案存在。

***
   
对于操作$3$就相对简单了，暴力枚举 $x$ 的因数 $a$，若 $f$ 中同时存在 $a$ 和 $\dfrac xa$，那肯定就有 $a,b$ 满足 $a \times b=x$ 了。
  
这部分的时间复杂度是 $\text O(\sqrt n)$ 的。

总时间复杂度 $\text O \left( \dfrac{n^2}{w}+n\sqrt n\right)$。

上代码：   
```cpp
#include<cstdio>
#include<cmath>
#include<iostream>
#include<algorithm>
#include<cstring>
#include<bitset>
#define N 100003
#define C 100000
using namespace std;

struct query{
    int l,r,id,k,x;
};

inline void read(int &x);
bool cmp(query a,query b);
inline void update(int i,int t);

int n,m,block,lim;
int be[N],a[N],s[N];
query q[N];
bitset<N> f,g,ans; //为了节省空间，ans也可以用bitset来存

int main(){
    int k,l,r,x;
    read(n),read(m);
    block = sqrt(n);
    for(int i=1;i<=n;++i){
        read(a[i]);
        be[i] = i/block+1;
    }
    for(int i=1;i<=m;++i){
        read(q[i].k),read(q[i].l),read(q[i].r),read(q[i].x);
        q[i].id = i;
    }
    sort(q+1,q+1+m,cmp);
    l = 1,r = 0;
    for(int i=1;i<=m;++i){
        while(l<q[i].l) update(a[l],-1),++l;
        while(l>q[i].l) update(a[l-1],1),--l;
        while(r<q[i].r) update(a[r+1],1),++r;
        while(r>q[i].r) update(a[r],-1),--r;
        k = q[i].k;
        x = q[i].x;
        if(k==1){
            if((f&(f<<x)).any()) 
                ans[q[i].id] = 1;
        }else if(k==2){
            if((f&(g>>(C-x))).any()) 
                ans[q[i].id] = 1;
        }else{
            for(int j=1;j*j<=x;++j){
                if(x%j!=0) continue;
                if(f[j]&&f[x/j]){
                    ans[q[i].id] = 1;
                    break;
                }
            }
        }
    }
    for(int i=1;i<=m;++i){
        if(ans[i]) printf("hana");
        else printf("bi");
        putchar('\n');
    }
    return 0;
}

inline void read(int &x){
    x = 0;
    char c = getchar();
    while(c<'0'||c>'9') c = getchar();
    while(c>='0'&&c<='9'){
        x = (x<<3)+(x<<1)+(c^48);
        c = getchar();
    }
}

bool cmp(query a,query b){
    if(be[a.l]==be[b.l]) return a.r<b.r;
    return a.l<b.l;
}

inline void update(int i,int t){
    s[i] += t;
    if(s[i]==1&&t==1)
        f[i] = g[C-i] = 1;
    else if(s[i]==0&&t==-1)
        f[i] = g[C-i] = 0;
}
```

---

## 作者：Ynoi (赞：16)

很久之前过了这题

然后有天晚上我在想，这题能不能出成强制在线呢？

然后我就想出了这个做法

这个做法和莫队做法一样，都是提取区间的bitset然后处理

我们对序列分块，然后在块上处理块里的bitset，表示块里有哪些数

之后我们在块间建ST表。这样就可以处理块间出现了哪些数。

然后对于每次区间，我们把区间内的块bitset求出来，然后在把边上的散块加入进去就行了

对于反过来的`n-a[i]`也一样的方法维护

时间复杂度

假如块大小是$S$

那么预处理时空复杂度是$\frac{n^2logn}{Sw}$

单次询问$S+\frac{n}{w}$

我的代码没多想，$S$直接取$\sqrt{n}$

这样复杂度和莫队就是一样的，但是常数大了一些
(我的莫队总共5.83s，这个做法总共 9.68s )

题外话，这题如果真强制在线估计不只是要通过lastans算了，估计要前多个询问的答案一起算出


update0：原来的代码有点锅，现在修复一下。
```
#include<bits/stdc++.h>
using namespace std;

#define MAXN 100005
#define mk 350

const int N = 100000;
int n,m,nn,mm;
int a[MAXN],c[MAXN];
bitset<MAXN>w[mk],fw[mk];
bitset<MAXN>f[mk][10],g[mk][10];

inline int read()
{
    register int x = 0 , ch = getchar();
    while( !isdigit( ch ) ) ch = getchar();
    while( isdigit( ch ) ) x = x * 10 + ch - '0' , ch = getchar();
    return x;
}

void jianbiao()
{
	for(int i = 1; i <= n; i ++) {
		if(i%nn == 1) c[i] = c[i-1]+1;
		else c[i] = c[i-1];
		w[c[i]][a[i]] = 1;
		fw[c[i]][N-a[i]] = 1;
	}
	mm = c[n];
	for(int i = 1; i <= mm; i ++) {
		f[i][0] = w[i];
		g[i][0] = fw[i];
	}
	for(int j = 1; j <= 9; j ++)
		for(int i = 1; i <= mm-(1<<j)+1; i ++) {
			f[i][j] = f[i][j-1]|f[i+(1<<(j-1))][j-1];
			g[i][j] = g[i][j-1]|g[i+(1<<(j-1))][j-1];
		}
}
bitset<MAXN>o,fo,ans;

void rd()
{
	n = read(); m = read();
	nn = sqrt(n);
	for(int i = 1; i <= n; i ++)
		a[i] = read();
	jianbiao();
}

signed main()
{
	rd();
	int cnt = 0;
	for(int i = 1; i <= m; i ++)
	{
		int opt = read();
		int l,r,x;
		l = read(); r = read(); x = read();
		o.reset();
		if(opt == 2) fo.reset();
		if(c[l]+1 >= c[r]) {
			for(int i = l; i <= r; i ++) { 
				o[a[i]] = 1; 
				fo[N-a[i]] = 1;
			}
		} else {
			int _l = c[l]+1,_r = c[r]-1;
			int u = log2(_r-_l+1);
			 o =  f[_l][u]| f[_r-(1<<u)+1][u];
			if(opt == 2) fo = g[_l][u]|g[_r-(1<<u)+1][u];
			for(int i = l; c[i] == c[l]; i ++) {
				o[a[i]] = 1;
				fo[N-a[i]] = 1; cnt ++;
			}
			for(int i = r; c[i] == c[r]; i --) {
				o[a[i]] = 1;
				fo[N-a[i]] = 1; cnt ++;
			}
		}
		
		if(opt == 2) {
			ans = o&(fo>>(N-x));
			if(ans.count() > 0) {
				cout<<"hana\n";
			} else {
				cout<<"bi\n";
			}
		} 
		
		if(opt == 1) {
			ans = o&(o>>x);
			if(ans.count() > 0) {
				cout<<"hana\n";
			} else {
				cout<<"bi\n";
			}
		} 
		if(opt == 3) {
			bool fl = 0;
			for(int i = 1; i*i <= x; i ++)
			if(x%i == 0) {
				if(o[i] && o[x/i])  {
					fl = 1;
					break;
				}
			} 
			if(fl) cout<<"hana\n";
			else cout<<"bi\n";
		}
		
	}
	return 0;
 } 
```

---

## 作者：Thomasguo666 (赞：8)

# 莫队+bitset
lxl的题+不强制在线+序列。。。显然是莫队

然后我们考虑怎么莫队：

发现数的最大值不超过100000：可能是根据值域来做

然后我们看：
如果区间中存在两个数$(x,y)$差为$k$，相当于区间中存在两个数$(x-k,x)$，然后我们可以用一个```bitset s1```，第$i$位表示当前区间中是否存在$i$，如果```s1&s1<<k```中有任意一位为1，假设是第$i$位，那么就是说i和i-k都在这个区间里。

如果区间中存在两个数$(x,y)$和为$k$，相当于区间中存在两个数$(x,k-x)$，
但是我们发现，$bitset$没有任何一种运算可以把一个存储是否存在$i$的$bitset$，改成一个存储是否存在$k-i$的$bitset$。怎么办呢？

我们可以考虑再维护一个存储是否存在$maxn-i$的```bitset s2```，这里$maxn$是一个比所有数都大的值，比如说$100005$，那么```s2>>(maxn-k)```维护的就是是否存在$(maxn-i)-(maxn-k)=(k-i)$了

至于乘积。。。反正约数也不多，枚举就好了。

莫队的两个指针$l,r$移动时，维护当前是否存在i，如果存在，就```s1[i]=s2[maxn-i]=1```，如果不存在，就```s1[i]=s2[maxn-i]=0```

代码：
```
#include <bits/stdc++.h>
using namespace std;
bitset<100005> s1,s2;
int maxn=100000;
int len;
int ans[100005],cnt[100005],a[100005];
struct query
{
	int opt,l,r,v,id;
	query (int opt=0,int l=0,int r=0,int v=0,int id=0):opt(opt),l(l),r(r),v(v),id(id) {}
    bool operator < (const query &rhs)
    {
    	return l/len==rhs.l/len?r<rhs.r:l<rhs.l;
	}
} q[100005];
void add(int x)
{
	s1[a[x]]=s2[maxn-a[x]]=++cnt[a[x]];//维护区间中是否存在a[x]
}
void del(int x)
{
	s1[a[x]]=s2[maxn-a[x]]=--cnt[a[x]]!=0;//维护区间中是否存在a[x]
}
int main()
{
	int n,m;
	cin>>n>>m;
	len=int(sqrt(n)+0.5);
	for (int i=1;i<=n;i++) cin>>a[i];
	for (int i=1,opt,l,r,v;i<=m;i++) cin>>opt>>l>>r>>v,q[i]=query(opt,l,r,v,i);
	sort(q+1,q+m+1);
	int l=1,r=0;
	for (int i=1;i<=m;i++)
	{
		while (l<q[i].l) del(l++);
		while (l>q[i].l) add(--l);
		while (r<q[i].r) add(++r);
		while (r>q[i].r) del(r--);
		switch(q[i].opt)
		{
			case 1:{
				ans[q[i].id]=(s1&(s1<<q[i].v)).any();
				break;
			}
			case 2:{
				ans[q[i].id]=(s1&(s2>>(maxn-q[i].v))).any();
				break;
			}
			case 3:{
				for (int j=1;j*j<=q[i].v;j++) if (q[i].v%j==0)
				{
					if (s1[j]&&s1[q[i].v/j]) ans[q[i].id]=1;
				}
				break;
			}
		}
	}
	for (int i=1;i<=m;i++) cout<<(ans[i]?"hana":"bi")<<endl;
	return 0;
}

```


---

## 作者：Trimsteanima (赞：2)

## 小清新人渣的本愿

[题目](https://www.luogu.org/problem/P3674)

### $\mathcal{Description}$

给出一个长度为 $n$ 的数列，有 $q$ 个询问，每次询问给出 $opt$、$l$、$r$、$x$。

1、若 $opt$ 为 $1$, 询问一个区间是否可以选出两个数差为 $x$。

2、若 $opt$ 为 $2$, 询问一个区间是否可以选出两个数和为 $x$。

1、若 $opt$ 为 $3$, 询问一个区间是否可以选出两个数乘积为 $x$。

对于每个询问，如果可以，输出`hana`，如果不可以，输出`bi`。

### $\mathcal{Solution}$

如果想学 $bitset$ 可以进这个[链接](https://www.cnblogs.com/yifusuyi/p/10072729.html)。

当然本题只需要知道一些很基础的。

用 $bitset$ 维护，每一位表示每个数字是否存在，记为$now1$。

若 $opt == 1$，如果存在 $z - y = x$, 则必存在 $z$ 和 $z - x$。

若 $opt == 2$，就是求 $z + y = x$，所以除 $now1$ 外，我们还需用 $bitset$ 记录一个 $now1$ 的反串，就是每一位 $i$ 都表示 $N - i$。问题就转化成满足 $now1$ 中有 $z$ 和 $now2$ 中有 $y^{'}$。代入 $z + y = x$ 中，得到 $z + N - y ^ {'} = x$，$z - y ^ {'} = x - N$。

若 $opt == 3$，直接枚举约数。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 1e5 + 10, M = 2e6 + 10;
int n, m, now, be[M], a[M], cnt[M], ans[M];
bitset <N + 10> now1, now2;
struct Node {
	int l, r, id, k, x;
} q[M];
inline int read() {
	int x = 0, k = 1; char c = getchar();
	for (; c < 48 || c > 57; c = getchar()) k ^= (c == '-');
	for (; c >= 48 && c <= 57; c = getchar()) x = x * 10 + (c ^ 48);
	return k ? x : -x;
}
inline bool cmp(Node a, Node b) {
	return (be[a.l] ^ be[b.l]) ? be[a.l] < be[b.l] : ((be[a.l] & 1) ? a.r < b.r : a.r > b.r);
} 
inline void del(int x) {
	if (--cnt[x] == 0)
		now1[x] = now2[N - x] = 0;
}
inline void add(int x) {
	if (cnt[x]++ == 0)
		now1[x] = now2[N - x] = 1;
}
int main() {
	n = read(), m = read();
	int sz = sqrt(n), n1 = ceil((double)n / sz);
	for (int i = 1; i <= n1; i++)
		for (int j = (i - 1) * sz + 1; j <= i * sz; j++)
			be[j] = i;
	for (int i = 1; i <= n; i++)
		a[i] = read();
	for (int i = 1; i <= m; i++)
		q[i].k = read(), q[i].l = read(), q[i].r = read(), q[i].x = read(), q[i].id = i;
	std::sort(q + 1, q + 1 + m, cmp);
	int L = 1, R = 0;
	for (int i = 1; i <= m; i++) {
		int l = q[i].l, r = q[i].r, k = q[i].k, x = q[i].x;
		while (L < l)
			del(a[L++]);
		while (L > l)
			add(a[--L]);
		while (R < r)
			add(a[++R]);
		while (R > r)
			del(a[R--]);
		if (k == 1) {
			if ((now1 & (now1 << x)).any()) {
				ans[q[i].id] = 1;
				continue;
			}
		}
		if (k == 2) {
			if ((now1 & (now2 >> (N - x))).any()) {
				ans[q[i].id] = 1;
				continue;
			}
		}
		if (k == 3) {
			for (int j = 1; j * j <= x; j++)
				if ((!(x % j)) && (now1[j] && now1[x / j])) {
					ans[q[i].id] = 1;
					continue;
				}
		}
		// ans[q[i].id] = now;
	}
	for (int i = 1; i <= m; i++)
		if (!ans[i])
			puts("bi");
		else 
			puts("hana");
	return 0;
}
```

---

## 作者：SamariumPhosphide (赞：1)

神仙题目。首先，这题是离线的，容易想到使用莫队进行维护。

莫队转移的过程中，显然需要维护值域，维护每个值是否出现。因为这里涉及到整个数组平移的运算，因此使用 bitset 可以大大优化常数。

对于操作1：将正向的 bitset 左移 $x$ 位，并与原 bitset 进行与运算。  
对于操作2：稍微有一点难想，由于 bitset 支持左移、右移运算，因此加法是不方便的，不妨尝试改成减法。$x_1+x_2=x$ 就等同于 $(\text{MAX} - x_2) - x_1 = \text{MAX} - x$。所以考虑使用一个反向的 bitset 维护 $\text{MAX} - x$。  
对于操作3：直接暴力 $\mathcal O(\sqrt n)$ 即可。

竟然不卡常！赞美lxl！

[Code Here](https://www.luogu.com.cn/paste/v29pz3pz)

---

## 作者：Ajsoabk (赞：1)

# [P3674 小清新人渣的本愿](https://www.luogu.org/problemnew/show/P3674)

(这篇题解主要解释其他题解所没提到的和问题的形象化解释)

初看这道题没什么头绪

发现给出了最大值的范围

这不就明示要存数组!

然后就想到了当一个数进来的时候

会在之前的数上新产生一些差和和

然后思路就歪了,想着储存差和和的存在性,不好删除

一筹莫展

于是就偷偷瞥了一眼题解,开始还是以为大家存的都是差和和,什么都看不懂

没几个讲清楚了的,还是问了机房大佬@[March_H](https://www.luogu.org/space/show?uid=92770)才知道存的是区间内数的存在性

这里我就形象描述一下和的处理方式

## 先讲讲差

我们要求差为x的两个数是否存在,

设为a,b(a<b),再设储存存在性的bitset为fla

则b=a+x

而用fla存了存在性后,就可以转化为某个位置a与对应位置a+x是否同时存在的问题

那就直接将fla左/右移x位再与原fla做与运算,查看结果是否有1(可用bitset自带any函数)即可

## 如何表示和

若问和是否有x,会发现简单的位运算无法体现和

分析分析这个问题,还是假设a,b为这两个数

a+b=x

我们可以画一画,用集合表示看看(我也不知道应该说是什么,就说是集合吧)

![](https://cdn.luogu.com.cn/upload/pic/50802.png)

这里用S表示N,以显示它是全集

我们最好的当然是将和问题转换成差问题

显然难以表现a与一个与b有关的数差为x

换一个思路,看是否存在差为N-x

设为y

![](https://cdn.luogu.com.cn/upload/pic/50803.png)

而与a差为y的显然是N-b,

即左右两边减去左边就是右边

这就变成差问题了

即:
** 是否存在a与相应的N-b,使得其差为N-x**

若存在,则a,b就满足a+b=x

故再存一个N-a的存在性的数组

正是因为两个问题都是差问题

故和与差的代码都比较类似

一个是ans=fla&(fla>>x)

另一个是ans=fla&(refla>>(N-x))

左移右移都一样,毕竟**相对运动**是一样的,233333

```cpp

#include<algorithm>
#include<iostream>
#include<cstdio>
#include<bitset>
#include<cmath>
using namespace std;
const int N=100000;
template<class T>inline void read(T &num){
	char ch;
	while(!isdigit(ch=getchar()));
	num=ch-'0';
	while(isdigit(ch=getchar()))num=num*10+ch-'0';
}
bitset<N+5> fla;
bitset<N+5> refla;

struct Infor{
	int l,r,typ,ran,blo,x;
}a[N+5];
int cnt[N+5],n,m,val[N+5],ans[N+5];
bool cmp(const Infor a,const Infor b){
	return a.blo==b.blo?((a.blo&1)?a.r<b.r:a.r>=b.r):a.blo<b.blo;
}

int main(){
//	freopen("xiaoqingxing.out","w",stdout);
	read(n),read(m);
	for(int i=1;i<=n;++i)read(val[i]);
	double sqrn=sqrt(n);
	for(int i=1;i<=m;++i){
		read(a[i].typ),read(a[i].l),read(a[i].r),read(a[i].x);
		a[i].ran=i;
		a[i].blo=a[i].l/sqrn;
	}
	sort(a+1,a+1+m,cmp);
	int tem=0,l=1,r=0;
	for(int i=1;i<=m;++i){
		while(l<a[i].l){
			if((--cnt[val[l]])==0){
				fla[val[l]]=0;
				refla[N-val[l]]=0;
			}
			l++;
		}
		while(r>a[i].r){
			if((--cnt[val[r]])==0){
				fla[val[r]]=0;
				refla[N-val[r]]=0;
			}
			r--;
		}
		while(l>a[i].l){
			l--;
			if((++cnt[val[l]])==1){
				fla[val[l]]=1;
				refla[N-val[l]]=1;
			}
		}
		while(r<a[i].r){
			r++;
			if((++cnt[val[r]])==1){
				fla[val[r]]=1;
				refla[N-val[r]]=1;
			}
		}
		int x=a[i].x;
		switch(a[i].typ){
			case 1:ans[a[i].ran]=(fla&(fla<<x)).any();break;
			case 2:ans[a[i].ran]=(fla&(refla>>(N-x))).any();break;
			case 3:
				int j,k;
				for(j=1,k=sqrt(x);j<=k&&!(x%j==0&&fla[j]&&fla[x/j]);++j);
				ans[a[i].ran]=(j<=k);
		}
	}
	for(int i=1;i<=m;++i)printf("%s\n",ans[i]?"hana":"bi");
	return 0;
}

```


---

## 作者：cirnovsky (赞：0)

## 题意简述

~~尽管题意已经够简洁了但是我还是要坚持我的题解风格~~

## 题解

dllxl难的的一个比较水的题。

我们初一看这道题目。没修改，不强制在线，基本上大思路就往莫队走了。

考虑一种暴力做法，对三个操作分别开桶算贡献，加法减法的计算方法比较简单，加法就是减法的逆运算，反着开就行了。乘法直接枚举约数，毕竟这道题的值域和数列长度及询问是一样的。

发现容易炸，又因为我们的桶是根据存在性开的，所以我们可以用bitset来优化。

记录两个bitset为classic和inverse。

如果为操作一的话就是：

$$
\operatorname{ANS_{Q_{i}->id}}=(\operatorname{classic\ bitand\ (classic\ shl\ Q_{i}->x)}).\operatorname{any()}
$$

操作二类似：

$$
\operatorname{ANS_{Q_{i}->id}}=(\operatorname{classic\ bitand\ (inverse\ shr\ (100000-Q_{i}->x))}).\operatorname{any()}
$$

操作三则直接枚举。

```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cstring>
#include <cmath>
#include <bitset>

using namespace std;

char buf[1 << 21], *p1 = buf, *p2 = buf;
#ifndef ONLINE_JUDGE
#define gc() getchar()
#else
#define gc() (p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1 << 21, stdin), p1 == p2) ? EOF : *p1++)
#endif
#define is() (ch >= '0' && ch <= '9')

template < typename Type >
void read(Type& a) {
	a = 0; char ch; bool f = 0;
	while (!(ch = gc(), is())) if (ch == '-') f = 1;
	while (is()) a = (a << 3) + (a << 1) + (ch ^ '0'), ch = gc();
	a = (f ? -a : a);
}

template < typename Type, typename... Args >
void read(Type& t, Args&... args) {
	read(t), read(args...);
}

const int N = 1e5 + 5, R = 100000;
struct Query_Node {
	int id, pos;
	int tp, l, r, x;
	bool operator < (const Query_Node& rhs) const {
		if (pos != rhs.pos)		return pos < rhs.pos;
		else	return r < rhs.r;
	}
} e[N];
int n, m, Size, a[N], cnt[N], ans[N];
bitset < N > classic, inverse;

void Add(int x) {
	++cnt[a[x]];
	if (cnt[a[x]] == 1) {
		classic[a[x]] = 1;
		inverse[R - a[x]] = 1;
	}
}

void Del(int x) {
	--cnt[a[x]];
	if (cnt[a[x]] == 0) {
		classic[a[x]] = 0;
		inverse[R - a[x]] = 0;
	}
}

void Contribute() {
	int l = 1, r = 0;
	for (int i = 1; i <= m; ++i) {
		while (l < e[i].l) Del(l++);
		while (l > e[i].l) Add(--l);
		while (r > e[i].r) Del(r--);
		while (r < e[i].r) Add(++r);
		if (e[i].tp == 1) {
			ans[e[i].id] = (classic & (classic << e[i].x)).any();
		} else if (e[i].tp == 2) {
			ans[e[i].id] = (classic & (inverse >> (R - e[i].x))).any();
		} else {
			for (int j = 1; j * j <= e[i].x; ++j) {
				if (e[i].x % j == 0 && classic[j] && classic[e[i].x / j])
					ans[e[i].id] = 1;
			}
		}
	}
}

signed main() {
	read(n, m), Size = sqrt(n);
	for (int i = 1; i <= n; ++i) 	read(a[i]);
	for (int i = 1; i <= m; ++i) {
		read(e[i].tp, e[i].l, e[i].r, e[i].x);
		e[i].id = i, e[i].pos = (e[i].l - 1) / Size + 1;
	}
	sort(e + 1, e + 1 + m);
	Contribute();
	for (int i = 1; i <= m; ++i) 	puts(ans[i] ? "hana" : "bi");
	return 0;
}
```

---


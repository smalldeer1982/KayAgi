# 大爷的字符串题

## 题目背景

在那遥远的西南有一所学校，

/\*被和谐部分\*/

然后去参加该省省选虐场，

然后某蒟蒻不会做，所以也出了一个字符串题：

## 题目描述

给你一个字符串 $a$，每次询问一段区间的贡献。

贡献定义：

每次从这个区间中拿出一个字符 $x$ ，然后把 $x$ 从这个区间中删除，直到区间为空。你要维护一个集合 $S$。

- 如果 $S$ 为空，你 rp 减 $1$。 
- 如果 $S$ 中有一个元素不小于 $x$，则你 rp 减 $1$，清空 $S$。
- 之后将 $x$ 插入 $S$。

由于你是大爷，平时做过的题考试都会考到，所以每次询问你搞完这段区间的字符之后最多还有多少 rp？rp 初始为 $0$。

询问之间不互相影响~

## 说明/提示

#### 数据规模与约定

- 对于 $10\%$ 的数据，是样例。
- 对于另外 $10\%$ 的数据，保证 $n,m \le 100$；
- 对于另外 $10\%$ 的数据，保证 $n,m \le 10^3$；
- 对于另外 $10\%$ 的数据，保证 $n,m \le 10^4$；
- 对于另外 $10\%$ 的数据，保证 $n,m \le 10^5$；
- 对于 $100\%$ 的数据，$1 \leq n,m \le 2 \times10^5$，$1 \leq a_i \leq 10^9$，$1 \leq l, r \leq n$。

保证数据像某省省选 day1T2 一样 sb，大家尽情用暴力水过题吧！

没事，你只要在一个好学校，就算这题只能拿到 10 分，也可以进队了。

## 样例 #1

### 输入

```
3 3
3 3 3
3 3
3 3
3 3```

### 输出

```
-1
-1
-1```

# 题解

## 作者：noip (赞：338)

大爷的字符串题：

大爷们太厉害了，甘拜下风

这个题充分考察了大家的语文水平

可以发现这个乱七八糟的题面，本质是每次从区间中取出一个严格上升的序列，然后问最少取几次

由于是严格上升，所以只和相同的数个数有关，即要用区间出现次数最大的那个数出现次数那么多次

从上句话可以看出这出题人语文没救

即要求区间众数

用膜队+值域分块的方法可以O( msqrt( n ) )解决这个问题

什么？你不会值域分块？

没事，你可以用个堆，O( msqrt( n )logn )，因为有人这样写过掉了。。。具体怎么回事我也不知道

可以参考某省省选有道数据结构题也出了同样的事情

-----------------------------

UPDATE:似乎不用值域分块。。。

我可能白学了数据结构


---

## 作者：lxd150039 (赞：35)

莫队。

很明显，此题的询问就是某区间内出现次数最多的数出现了多少次。由于可以离线，很容易想到用莫队的。维护一个计数的数组num[i]，表示数字i出现了几次，再搞个数组cnt[i]，表示出现i次的有几个数。。。。就可以了。。。

```cpp
#include<iostream>
#include<cstring>
#include<cstdlib>
#include<cmath>
#include<algorithm>
#define N 400005
#define F 10
using namespace std;
//ifstream cin("a.txt");
//ofstream cout("b1.txt");
struct tzy{long a,p;};
struct Q{long l,r,p;};
struct seg{long l,r,m;};

long n,m,i,j,k,x,y,nowm,rk[N],cnt[N],ans[N],num[N]; //cnt[i+F]:共出现i次的有几个数；num[i]:第i个数一共出现了几次 
long sqt,pos[N];
bool cmp(tzy a,tzy b){return a.a<b.a||(a.a==b.a&&a.p<b.p);}
bool cmp2(Q a,Q b){return pos[a.l]<pos[b.l]||(pos[a.l]==pos[b.l]&&a.r<b.r);}

tzy a[N];
Q q[N];
void ch(long x,long t)//修改
{
    long d=num[x];
    if (t==1)
    {
        if (nowm==d) nowm++;
        cnt[d+F]--; cnt[d+F+1]++;
        num[x]++;
    }
    else{
        if (nowm==d&&cnt[d+F]==1) nowm--;
        cnt[d+F]--; cnt[d+F-1]++;
        num[x]--;
    }
}
int main()
{
    cin>>n>>m;
    for (i=1; i<=n; i++) {cin>>a[i].a; a[i].p=i;}
    sort(a+1,a+n+1,cmp);
    for (i=1,j=0; i<=n; i++)
    {
        if (i==1||a[i].a!=a[i-1].a) j++;
        rk[a[i].p]=j;
    }//离散化
    
    for (sqt=1; sqt\*sqt<=n; sqt++);
    for (i=1; i<=n; i++) pos[i]=i/sqt;
    for (i=1; i<=m; i++) {cin>>q[i].l>>q[i].r; q[i].p=i;}
    sort(q+1,q+m+1,cmp2);//莫队
    
    x=1,y=0; cnt[0]=j; nowm=0;
    for (i=1; i<=m; i++)
        while (y<q[i].r) {y++; ch(rk[y],1);}
        while (y>q[i].r) {ch(rk[y],-1); y--;}
        while (x<q[i].l) {ch(rk[x],-1); x++;}
        while (x>q[i].l) {x--; ch(rk[x],1);}
        ans[q[i].p]=-nowm;
    }
    
    for (i=1; i<=m; i++) cout<<ans[i]<<endl;
}

---

## 作者：中国飞鱼 (赞：25)

题意:@#%^%@#%#$^

这个题目我们不看它

看下面这个:

>给你$n$个数,$m$次询问区间$[l,r]$中众数的出现次数


它萌为什么是一样的呢?

就比如说这个数列$1,1,1,2,2,4,5,6,6,7$

我们把它排成一段一段的递增序列可以使$rp$掉的最少

就变成了$1,2,4,5,6,7,1,2,6,1$共掉3点$rp$

然后发现递增序列的个数就等于区间众数的出现次数

于是莫队解决它

$cnt[i]$表示数$i$出现的次数,$t[i]$表示出现$i$次的数有多少个

加入一个数时,把$Ans$和$cnt$取个$Max$

删除一个数时,如果有$t[cnt]==1$&&$cnt==Ans$那么$Ans--$
```
#include<cstdio>
#include<cmath>
#include<algorithm>
using namespace std;
const int N=2e5+5;
int re(){
    int x=0,w=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
    while(ch>='0'&&ch<='9')x=x*10+ch-'0',ch=getchar();
    return x*w;
}
int n,m,B,len,Ans,a[N],d[N],b[N],t[N],cnt[N],ans[N];
struct Q{int l,r,id;}q[N];
bool cmp(Q x,Q y){
	if(b[x.l]==b[y.l])
		if(b[x.l]&1)return x.r<y.r;
		else return x.r>y.r;
	return b[x.l]<b[y.l];
}
void add(int i){
	t[cnt[a[i]]]--;
	t[++cnt[a[i]]]++;
	Ans=max(Ans,cnt[a[i]]);
}
void del(int i){
	t[cnt[a[i]]]--;
	if(cnt[a[i]]==Ans&&!t[cnt[a[i]]])Ans--;
	t[--cnt[a[i]]]++;
}
int main(){
	n=re(),m=re();B=sqrt(n);
	for(int i=1;i<=n;i++){
		d[i]=a[i]=re();
		b[i]=(i-1)/B+1;
	}
	sort(d+1,d+n+1);len=unique(d+1,d+n+1)-d-1;
	for(int i=1;i<=n;i++)
		a[i]=lower_bound(d+1,d+len+1,a[i])-d;
	for(int i=1;i<=m;i++)
		q[i]=(Q){re(),re(),i};
	sort(q+1,q+m+1,cmp);
	for(int i=1,l=1,r=0;i<=m;i++){
		while(r<q[i].r)add(++r);
		while(r>q[i].r)del(r--);
		while(l<q[i].l)del(l++);
		while(l>q[i].l)add(--l);
		ans[q[i].id]=Ans;
	}
	for(int i=1;i<=m;i++)printf("%d\n",-ans[i]);
	return 0;
}
```

---

## 作者：MY（一名蒟蒻） (赞：15)

[P3709 大爷的字符串题](https://www.luogu.com.cn/problem/P3709)

### 题意分析

我们希望放进去的顺序是多个尽量长的严格上升序列。

显然有多少个严格上升序列答案就是多少，最后将它变成它的相反数即可。

设最后剩下来一些同样的数，那么**答案就是这个剩下来的数的总个数**。因为**这些剩下的每一个放进去人品都会减少，而之前的序列中每一个都包含这个数**。

这个数就是众数。于是问题转化成求区间众数出现的个数。

---
### 做法
考虑莫队。

加入操作非常好写，如果 $\text{x}$ 的出现个数大于当前答案，直接更新即可。

删除操作要考虑删掉的 $\text{x}$ 出现次数是不是会影响答案。

分类讨论
1. 当出现次数小于当前 $\text{ans}$ ，对答案没有影响；
2. 当出现次数等于当前 $\text{ans}$ ，且只有这个数出现了 $\text{ans}$ 次， $\text{ans}$ 减一；
3. 当出现次数等于当前 $\text{ans}$ ，且不止一个数出现了 $\text{ans}$ 次，对答案没有影响。

综上所述，我们需要开一个**辅助数组记录出现了 $i$ 次的数的个数。**（可能有点拗口，没明白建议多读几遍）如果只有一个数 $\text{ans}$ 就需要减一。

需要离散化 。

一个小优化：没有必要在一个数字出现次数增加时改变之前的辅助数组记录的数值，因为求的是 $\max$ ，之前的不会对答案造成影响，在删除的时候也会被删掉。

还没明白就看看代码吧。
```cpp
#include <cstdio>
#include <iostream>
#include <cmath>
#include <algorithm>
#include <vector>

using namespace std;

const int N=2e5+10;

int n,m,a[N],cnt[N],len,bl[N],ans[N],maxn,sum[N];//cnt[i]:数字i出现的个数；sum[i]:出现次数为i的数字个数
vector <int> v; 
struct query
{
	int l,r,id;
	bool operator <(const query x) const {return bl[l]^bl[x.l]? l<x.l:bl[l]&1? r<x.r:r>x.r;}
} q[N];

inline void add(int x)
{
	sum[++cnt[a[x]]]++;
	if(cnt[a[x]]>maxn) maxn=cnt[a[x]];
	return ;
}
inline void del(int x)
{
	if(sum[cnt[a[x]]] == 1 && maxn == cnt[a[x]]) maxn--;
	sum[cnt[a[x]]--]--;
	return ;
}

int main()
{
// 	freopen("work.in","r",stdin); freopen("work.out","w",stdout);
	scanf("%d%d",&n,&m);
	len=sqrt(n);
	for(int i=1;i<=n;i++) {scanf("%d",&a[i]); v.push_back(a[i]); bl[i]=(i-1)/len+1;}
	sort(v.begin(),v.end());
	v.erase(unique(v.begin(),v.end()),v.end());//离散化
	for(int i=1;i<=n;i++) a[i]=lower_bound(v.begin(),v.end(),a[i])-v.begin()+1;
	for(int i=1;i<=m;i++) {scanf("%d%d",&q[i].l,&q[i].r); q[i].id=i;}
	sort(q+1,q+1+m);
	int l=1,r=0;
	for(int i=1;i<=m;i++)
	{
		while(l > q[i].l) add(--l);
		while(r < q[i].r) add(++r);
		while(r > q[i].r) del(r--);
		while(l < q[i].l) del(l++);
		ans[q[i].id]=-maxn;
	}
	for(int i=1;i<=m;i++) printf("%d\n",ans[i]);
// 	fclose(stdin); fclose(stdout);
	return 0;
}
```
弱化版[P1997 faebdc 的烦恼](https://www.luogu.com.cn/problem/P1997)，不需要离散化，在此安利一下本人关于这题的[题解](https://www.luogu.com.cn/blog/nizhuan/solution-p1997)。

## Thank you for your reading!
您的点赞和评论是对作者最好的支持！

---

## 作者：ISYRHH (赞：8)


[P3709 大爷的字符串题](https://www.luogu.com.cn/problem/P3709)

------------


帮同学学习莫队时看到的，一看（~~过了一年终于读懂题目后~~）就觉得，这不就拿回滚莫队乱跑吗，手残白给几遍切掉后，突然发现题解竟然没有人写回滚莫队，于是为了推广这个快乐的算法，就有了这篇题解。

------------


### 题意分析

这也是这道题最难的地方（~~当然不是因为出题人语文的问题~~）我们先反复阅读一下:

**贡献定义：**

**每次从这个区间中拿出一个字符 x ，然后把 x 从这个区间中删除，直到区间为空。你要维护一个集合 S。**

- **如果 S 为空，你 rp 减 1。**
- **如果 S 中有一个元素不小于 x，则你 rp 减 1，清空 S。**
- **之后将 x 插入 S。**

**每次询问你搞完这段区间的字符之后最多还有多少 rp？**

我们逐字逐句地多读几遍就会理解，题意其实是在选中的一段区间内，按一定顺序将每个元素插入一遍，使清空序列的次数最少

对于第一个操作只会在第一次插入进行，因为我们以后的插入至少会有前一次插入的数在序列中

这里我们贪心的想一想，从小到大插入一个序列是不消耗rp的，而我们对于同样的数，至少是需要多消耗一点rp去插入的，再感性理解一下，就会发现这道题实际上要求的是询问的序列中出现最多的数（即众数）出现的次数是多少。

这样我们已经把这道题解决掉一半了（这里真的没有夸张）

------------


### 解法

然后我们就可以考虑一下这道题用什么办法维护了。

我们要维护的是一个序列上的查询，而且没办法通过简单的方法合并答案（即得知\[l,mid\]和\[mid+1,r\]的答案不能通过简单的方式求出\[l,r\] 的答案，依照惯例（~~偷懒~~），我们采用朴素的莫队算法来维护。（这里我们假设你已经学会了基础的莫队算法，不会的请左转找篇博客）

首先我们需要先对字符进行一个离散化，这样1e9的值域就可以转化为1e6，于是我们就可以建个数组统计个数了。

众所周知。莫队最需要解决的问题是l，r指针的移动。

对于在区间中添加一个数，我们可以直接将这个数的数量加1，然后和当前的ans比较，如果数量比ans多，就把ans加1。

对于在区间删除一个数呢……貌似不是很好维护，我们删除一个数ans可能会减1，也可能会不变……我们也不能通过直接的比较确定是否需要减1……

（这里其实可以再建一个数组维护个数为a的数的个数，但是我不想建，于是我们换一种思想）

我们可能会想，要不干脆我们只往区间内加数，不在区间删数，这样就可以用一个最朴素的莫队实现这个操作了，于是回滚莫队就出现了。

------------
### 回滚莫队

对于一些普通莫队不好维护的问题，或者在区间中删掉一个数不好维护，或者在区间中加上一个数不好维护，我们可以通过回滚莫队维护

回滚莫队主要的思想有3个（这里以不能删数的莫队为例）

1. 以左端点所在的块递增为第一关键字，右端点的位置递增为第二关键字,对询问进行排序。

2. 从左到右逐块遍历左端点在此块内的询问，开始时清空上一个块的记录，然后将右指针设在前一块的末尾。

3. 由于之前排序的第二关键字，现在右端点的大小都是单调递增的，我们对于这个块内的询问O(n)可以处理出右端点移动的贡献，对于左端点，对于每个询问，我们O($\sqrt n$)处理出对答案的贡献，同时把答案记录在另外一个变量中，然后再倒着跑一遍去除左端点的的贡献。处理出的第二个答案就是本次询问的答案。

通过这样的方法就可以实现只有添数没有删数的莫队算法。

------------
### 代码

```cpp
#include<cstdio>
#include<map>
#include<cstring>
#include<vector>
#include<cmath>
#include<algorithm>
using namespace std;
int n,m,nn,nq,in,in2,cn,col[200001],loc[200001],num[200001],num1[200001];
map<int,int>mp;
vector<int>dd[200001];
struct query
{
    int l,r,id,ans;
}que[200001];
//第一次排序，以左端点所在的块递增为第一关键字，右端点的位置递增为第二关键字;
bool comp(query x,query y)
{
    if(loc[x.l]!=loc[y.l])return loc[x.l]<loc[y.l];
    return x.r<y.r;
}
bool comp2(query x,query y)
{
    return x.id<y.id;
}
int maxx(int x,int y)
{
    return x>=y?x:y;
}
int minn(int x,int y)
{
    return x<=y?x:y;
}
int main()
{
    scanf("%d%d",&n,&m);
    nn=sqrt((double)n);
    nq=(n+nn-1)/nn;
    for(int i=0;i<nq;i++)
    {
        for(int j=1;j<=nn&&i*nn+j<=n;j++)
        {
            loc[i*nn+j]=i;
        }
    }
//离散化，因为太懒直接拿map套vector跑的;
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&in);
        map<int,int>::iterator ite=mp.find(in);
        if(ite==mp.end())
        {
            mp.insert(pair<int,int>(in,++cn));
            dd[cn].push_back(i);
        }
        else
        {
            dd[ite->second].push_back(i);
        }
    }
    cn=0;
    for(map<int,int>::iterator ite=mp.begin();ite!=mp.end();ite++)
    {
        cn++;
        for(vector<int>::iterator it=dd[ite->second].begin();it!=dd[ite->second].end();it++)
        {
            col[*it]=cn;
        }
        dd[ite->second].clear();
    }
    mp.clear();
    for(int i=1;i<=m;i++)
    {
        scanf("%d%d",&in,&in2);
        que[i].l=in,que[i].r=in2,que[i].id=i;
    }
    sort(que+1,que+1+m,comp);
    int j=1;
//按块遍历询问;
    for(int i=0;i<nq;i++)
    {
        if(loc[que[j].l]!=i)continue;
        memset(num,0,sizeof(num));
        int nnn=minn((i+1)*nn,n),ans=0,nr=nnn;
        for(;j<=m;j++)
        {
            if(loc[que[j].l]!=i)break;
            int ll=que[j].l,rr=que[j].r,ans1=0;
            if(loc[ll]==loc[rr])
            {
                memset(num1,0,sizeof(num1));
                for(int k=ll;k<=rr;k++)
                {
                    num1[col[k]]++;
                    ans1=maxx(ans1,num1[col[k]]);
                }
                que[j].ans=ans1;
                continue;
            }
            while(nr<rr)
            {
                num[col[++nr]]++;
                ans=maxx(ans,num[col[nr]]);
            }
            ans1=ans;
            int nnn=minn((i+1)*nn,n);
            for(int k=ll;k<=nnn;k++)
            {
                num[col[k]]++;
                ans1=maxx(ans1,num[col[k]]);
            }
            for(int k=ll;k<=nnn;k++)
            {
                num[col[k]]--;
            }
            que[j].ans=ans1;
        }
    }
    sort(que+1,que+1+m,comp2);
    for(int i=1;i<=m;i++)
    {
        printf("%d\n",-que[i].ans);
    }
    return 0;
}
```

（码风偏臭，~~自认为还可以接受~~）

### **end**

---

## 作者：Tyher (赞：6)

算法是莫队 最重要的是怎么算移动产生的贡献

```
//考虑怎么算贡献
//cnt 出现次数为x的数有多少个
//bit 数x出现了多少次
//res 当前的答案
//v 已经离散化好了的值
void del(rg int v){
	if(res==bit[v]&&cnt[bit[v]]==1)res--;
	//如果当前答案正好是我们要修改的值 并且我们修改后他就并不是我们当前答案了
	//那么当前的答案是不是就会-1？
	//假设出现次数最多为5 只有一个数 如果我们减去单个他的贡献
	//那么他出现次数就是4了 就不是答案了
	//但是出现次数为4的数就一定会存在
	//因为他就是出现次数为4的数嘛
	//所以res--就可以了
	cnt[bit[v]]--;//出现次数为bit[v]的数--
	bit[v]--;//v出现次数--
	cnt[bit[v]]++;//出现次数为bit[v]++
}
void add(rg int v){
	if(res==bit[v])res++;
	//如果当前答案是我们要修改的值呢？
	//v的出现次数已经是当前最大的次数了
	//如果他再增大一个 是不是一定会更新答案
	//同样的 res++就可以了
	cnt[bit[v]]--;
	bit[v]++;
	cnt[bit[v]]++;
	
}

```

---

## 作者：Prean (赞：5)

# 题目大意
简化后为区间众数出现次数，简化前为【数据删除】
### 吐槽
为什么题解只有一篇分块，剩下的全是莫队？

这题不是蒲公英？这和算导例题有何区别？？？

为什么现在的人都喜欢去看题解而不注重思维？？？

莫队之前也胡过区间众数莫队，由于太菜胡出来了一个回滚莫队。（毕竟暴力思路这题很难删）
# 题解
因为某些原因代码是从 P5048 搬过来然后把强制在线去掉后加了个负号（

首先我们对序列分块，然后求出左右端点同时也是某个块的左右端点的区间的众数出现次数。（语文差轻喷）

然后对于一个询问，把询问区间分为整块和边角块后，我们很容易能够知道答案一定在 O(整块答案) 级别。所以我们枚举边角块的 $ O(\sqrt n) $ 个数，看它在区间中出现了多少次就行了。

但是数出现次数的方法有点儿妙。

我们开 $ n $ 个 vector 记录每一种数出现的下标。

假如一个边角块的数可能成为答案（设其为 $ k $），那么这个数后面的第整块答案个 $ k $ 一定也在区间内。

而很容易知道更新答案的复杂度是 $ O(\sqrt n) $ 的。

code:
```cpp
#include<algorithm>
#include<cstdio>
#include<vector>
#include<cmath>
const int N=805,M=5e5+5;
int n,m,p,ans,siz,len,a[M],t[M],pre[M],cnt[M],lsh[M],ANS[N][N];
int L[N],R[N],pos[M];
bool vis[M];
std::vector<int>id[M];
inline int min(const int&a,const int&b){
	return a>b?b:a;
}
inline int Query(int l,int r){
	int i,j,q=pos[l],p=pos[r];
	if(q+1>=p||q==p){
		for(i=l;i<=r;++i){
			if(++cnt[a[i]]>ans)ans=cnt[a[i]];
		}
		for(i=l;i<=r;++i)--cnt[a[i]];
		return ans;
	}
	ans=ANS[q+1][p-1];
	for(i=l;i<=R[q];++i){
		for(j=pre[i]+ans;j<id[a[i]].size()&&id[a[i]][j]<=r;++j)++ans;
	}
	for(i=L[p];i<=r;++i){
		for(j=pre[i]-ans;j>=0&&id[a[i]][j]>=l;--j)++ans;
	}
	return ans;
}
signed main(){
	register int i,j,k,x=0,ql,qr;
	scanf("%d%d",&n,&m);p=ceil(n/sqrt(m));
	for(i=1;i<=n;++i){
		scanf("%d",a+i);lsh[i]=a[i];
		pos[i]=(i-1)/p+1;
	}
	siz=pos[n];
	for(i=1;i<=siz;++i)L[i]=R[i-1]+1,R[i]=i*p;
	R[siz]=n;
	std::sort(lsh+1,lsh+n+1);len=std::unique(lsh+1,lsh+n+1)-lsh-1;
	for(i=1;i<=n;++i){
		a[i]=std::lower_bound(lsh+1,lsh+len+1,a[i])-lsh;
		id[a[i]].push_back(i);pre[i]=id[a[i]].size()-1;
	}
	for(i=1;i<=siz;++i){
		for(j=i;j<=siz;++j){
			for(k=L[j];k<=R[j];++k){
				if(++cnt[a[k]]>ans)ans=cnt[a[k]];
			}
			ANS[i][j]=ans;
		}
		for(j=L[i];j<=n;++j)--cnt[a[j]];ans=0;
	}
	for(i=1;i<=m;++i){
		scanf("%d%d",&ql,&qr);ans=len=0;
		printf("%d\n",-Query(ql,qr));
	}
}
```

---

## 作者：SIXIANG32 (赞：3)

[双倍经验](https://www.luogu.com.cn/problem/P1997)[题解](https://www.luogu.com.cn/blog/SX66666/solution-p1997)。  
这道题其实就是上面这道题离散化一下再加个语文阅读理解十级就好了。  
闲话少说，切入正题——  

---
第一眼看到题面：F\*\*\* 这什么鬼啊。  
我们来理一下神奇的题面：  
插入 $x$ 至集合 $S$，显然 **如果 $S$ 里有元素大于等于 $x$ 的话 $rp-1$ 并且 $S$ 清空**  
我们来分析这段话：  
很显然的，我们将 $[l,r]$ 内的元素排列成一个个递增序列依次插入能使 $S$ 清空的次数最小。因为只有到了递增序列末尾才会清空。  

那么问题转化成：$[l,r]$ 的元素可以最少可以表示为多少个递增序列。  
毕竟是递增序列，每一段序列中不可能出现相同的数字。  
我们就会发现，**区间众数的出现次数就是递增序列的个数**！  

为啥呢？很简单，因为序列中每个数字都肯定要包含在一个递增序列里，递增序列**没有重复元素**，所以区间内每个是众数的元素都要单独在一个序列里。  

最终，题意简化为：**区间众数的出现次数**。  

---
然后就和 P1997 一毛一样了。  
因为可离线，$n$ 是 $\le 2 \times 10 ^ 5$，所以我们用莫队。  
然后就设 $awa_i$ 是有多少个出现了 $i$ 次的数，$qwq_{a_i}$ 表示 $a_i$出现了多少次。  
莫队嘛，考虑加入位置为 $x$ 的贡献和删除位置为 $x$ 的贡献。  
当加入 $x$ 的贡献的时候，首先我们的 $qwq_{a_{x}}$ 要加一，然后 $awa_{qwq_{a_{x}}}$ 也要加一。在这个时候我们顺便可以更新我们的答案 $ans$，也就是 $ans = \max(ans, qwq_{a_{x}})$。  
删除的时候，首先 $awa_{qwq_{a_{x}}}$ 要减一，然后 $qwq_{a_{x}}$ 也要减一。如果 $ans$ 是从这个状态转移而来，$ans$ 也要减一。  

由于 $a_i \le 10 ^ 9$，所以我们要离散化。  
离散化会把~~都来做这题了怎么会不会离散化呢~~，就是排序去重二分。

---
代码：  
```cpp
#include <cstdio> 
#include <algorithm>
#include <cmath>
#define MAXN 200000
#define QWQ printf("qwq\n");
using namespace std;
int a[MAXN + 10], b[MAXN + 10], Len, ans = 0, Ans[MAXN + 10], awa[MAXN + 10], qwq[MAXN + 10];
struct node {
	int l, r, ind, cl;
}in[MAXN + 10];
bool cmp(node &x, node &y) {//莫队的奇偶块排序
	return ((x.cl != y.cl) ? (x.l < y.l) : ((x.cl & 1) ? (x.r < y.r) : (x.r > y.r)));
}
int G(int x) {return lower_bound(b + 1, b + Len + 1, x) - b - 1; }//离散化位置
int max(int x, int y) {return ((x > y) ? (x) : (y));}
void add(int x) {//添加贡献
    awa[++qwq[a[x]]]++;
    ans = max(ans, qwq[a[x]]);
}
void del(int x) {//删除贡献
    if(awa[qwq[a[x]]] == 1 && qwq[a[x]] == ans)
        ans--;
    awa[qwq[a[x]]--]--;
}
int main() {
	int n, m, len;
	scanf("%d%d", &n, &m), len = sqrt(n);
	for(int p = 1; p <= n; p++) {
		scanf("%d", &a[p]);
		b[p] = a[p];
	}
	sort(b + 1, b + n + 1); Len = unique(b + 1, b + n + 1) - b - 1;
	for(int p = 1; p <= n; p++) a[p] = G(a[p]);//离散化
	for(int p = 1; p <= m; p++) {
		in[p].ind = p;
		scanf("%d%d", &in[p].l, &in[p].r);
		in[p].cl = (in[p].l - 1) / len;
	}
	sort(in + 1, in + m + 1, cmp);
	int l = 1, r = 0;
	for(int p = 1; p <= m; p++) {//莫队板子
        while(l < in[p].l) del(l++);
        while(l > in[p].l) add(--l);
        while(r < in[p].r) add(++r);
        while(r > in[p].r) del(r--);
        Ans[in[p].ind] = ans;
    } 
	for(int p = 1; p <= m; p++)
		printf("-%d\n", Ans[p]);
}
```

---
总的来说这是一道语文 + 莫队题。  
感觉这道题莫队的成分还是比较少的，考的主要是语文（  
如果题意懂了这道题就是个莫队裸题。  
这是我第一道递交一次就 A 的紫题呢 qwq，留个纪念。  
完结撒花~qwq~！

---

## 作者：flora715 (赞：3)

看到没有人分析题目为什么是“区间众数的出现次数”，本蒟蒻就过来说一说2333

可以知道一些信息：

1. rp一定为负值。

2. ‘如果S为空，你rp减1’这一条一定不可能成立，因为每次操作过后都会‘之后将x插入S’，所以完全可以忽略...

3. 要求rp最大，即‘rp减1，清空S’的次数min。读题可知：按从小到大的顺序放入即可。


------------


但第三条中的‘按从小到大的顺序放入’并不能完全实现清空次数min。

因为可以在区间众数出现时，用比它小的‘最小重复数’清空，

之后再加入‘按大小顺序排列的重复数’和‘继续放置从小到大的数’。

------------

举例，如果区间的序列是：
      
      1 2 2 3 4 4 4 5 ;


那么顺序可以是：

      1 2 3 4(到达区间众数) 2(清空后放入2) 4 4(清空后放入4) 5 .


所以题意就变成了dalao们说的：

      求某区间内出现次数最多的数出现了多少次（区间众数的出现次数）。


------------


```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<string>
#include<queue>
#include<vector>
#include<cmath>
#include<map>
using namespace std;
typedef long long ll;

// 【p3709】大爷的字符串题
// 给你一个字符串a，每次询问一段区间的贡献。贡献定义为：
// 每次从这个区间中随机拿出一个字符x，然后把x从这个区间中删除，你要维护一个集合S
// 如果S为空，你rp减1 ； 如果S中有一个元素不小于x，则你rp减1，清空S ； 之后将x插入S
// 每次询问你搞完这段区间的字符之后最多还有多少rp？rp初始为0。

void reads(int &x){ //读入优化（正负整数）
    int fx=1;x=0;char s=getchar();
    while(s<'0'||s>'9'){if(s=='-')fx=-1;s=getchar();}
    while(s>='0'&&s<='9'){x=(x<<3)+(x<<1)+s-'0';s=getchar();}
    x*=fx; //正负号
}

const int N=500019;

int n,m,pos[N],a[N],b[N],cnt[N],tim[N],max_cnt=0;

struct node{int l,r,id,ans;}q[N];

bool cmp(node a,node b) //同块中按r排序，不同块时按l排序
 { if(pos[a.l]==pos[b.l]) return a.r<b.r; return a.l<b.l; }

bool cmp_id(node a,node b){return a.id<b.id;}

void add(int i) //tim[i]:出现次数为i的数的个数
 { tim[cnt[a[i]]]--; tim[++cnt[a[i]]]++; max_cnt=max(max_cnt,cnt[a[i]]); }

void del(int i)
 { tim[cnt[a[i]]]--; if(cnt[a[i]]==max_cnt&&!tim[cnt[a[i]]]) max_cnt--; 
   tim[--cnt[a[i]]]++; /* 每次删除只减小1个，在这里可以直接将max_cnt-1 ↑↑  */ }

void solve(){
    for(int i=1,l=1,r=0;i<=m;i++){
        while(r<q[i].r) add(++r);
        while(r>q[i].r) del(r--);
        while(l<q[i].l) del(l++);
        while(l>q[i].l) add(--l); q[i].ans=max_cnt;  
    }
}

int main(){
    reads(n),reads(m); for(int i=1;i<=n;i++) reads(a[i]),b[i]=a[i];
    int block=(int)sqrt(n); for(int i=1;i<=n;i++) pos[i]=(i-1)/block+1;
    sort(b+1,b+n+1); int bn_=unique(b+1,b+n+1)-b-1;
    for(int i=1;i<=n;i++) a[i]=lower_bound(b+1,b+bn_+1,a[i])-b;
    for(int i=1;i<=m;i++) reads(q[i].l),reads(q[i].r),q[i].id=i;
    sort(q+1,q+m+1,cmp); solve(); //离线排序询问，进行莫队算法
    sort(q+1,q+m+1,cmp_id); for(int i=1;i<=m;i++) printf("%d\n",-q[i].ans);
}
```


---

## 作者：Gypsophila (赞：3)

### Description

~~个人觉得这是这道题最难的一步...出题人的语文...~~

每次给出一个区间，求这个区间最少能被多少个单调上升的序列覆盖。

### Solution 

这个东西可以转化为这个区间中出现次数最多的数的出现次数（很好理解吧）
然后用莫队维护两个东西
1. $cnt_x$  表示 $x$ 的出现次数
2. $num_x$  表示有多少个数出现次数是 $x$

用这两个东西可以方便地维护答案 ans。

加入 $x$ 就是 `num[cnt[x]]--; cnt[x]++; num[cnt[x]]++`

删除 $x$ 麻烦一些。

若 $cnt_x = ans$ 并且 $num_{cnt_x}=1$ ，那么 ans 要减 $1$ (为什么 ans - 1 合法呢？因为删除之后这个数的出现次数就是 ans - 1)
如果不满足上面的这个条件，那么 ans 就不会有变化。最后记得 `num[cnt[x]]--; cnt[x]--; num[cnt[x]]++`


### Code

[看代码戳这里](https://www.cnblogs.com/acfunction/p/10161607.html)

---

## 作者：cirnovsky (赞：2)

## 题意简述

~~出题人语文……唉……~~

大意：给定几个询问，问一个区间最少被几个严格上升的序列覆盖。

可以转化为区间众数的出现次数。

## 题解

题面就不吐槽了。

不带修，可离线，考虑莫队。

我们可以维护两个东西。

一个是 $CNT_{x}$ 表示 $x$ 出现的次数。

还有一个就是 $APPEAR_{x}$ 表示出现次数为 $x$ 的数的数量。

$APPEAR_{x}$ 的定义有点绕，好好读一下。

莫队加贡献的时候就 `appear[cnt[a[x]]]--,appear[++cnt[a[x]]]++` 即可。

意思就是出现次数为 `cnt[a[x]]` 的没了，减一个，后面的同理。

减贡献大体没什么区别，用一个全局变量 `flags` 记录答案的相反数。需要注意的是如果满足 `cnt[a[x]]==flags && appear[cnt[a[x]]]==1` 那么我们需要将 `flags-1`。后面的就和加贡献反着来即可。

局部代码：

```cpp
const int N = 2e5 + 5;
int n, m, flags, Size, a[N], cnt[N], appear[N], ans[N];
vector < int > disc;
struct Query_Node {
	int l, r, id, pos;
	bool operator < (const Query_Node& rhs) const {
		if (pos == rhs.pos)
			return r < rhs.r;
		else return pos < rhs.pos;
	}
} e[N];

int Get_ID(int x) {
	return lower_bound(disc.begin(), disc.end(), x) - disc.begin() + 1;
}

void Add(int x) {
	appear[cnt[x]]--;
	appear[++cnt[x]]++;
	flags = max(flags, cnt[x]);
}

void Del(int x) {
	if (cnt[x] == flags && appear[cnt[x]] == 1) --flags;
	appear[cnt[x]]--;
	appear[--cnt[x]]++;
}

void Contribute() {
	int l = 1, r = 0;
	for (int i = 1; i <= m; ++i) {
		while (l < e[i].l) Del(a[l++]);
		while (l > e[i].l) Add(a[--l]);
		while (r > e[i].r) Del(a[r--]);
		while (r < e[i].r) Add(a[++r]);
		ans[e[i].id] = -flags;
	}
}

signed main() {
	read(n, m), Size = sqrt(m);
	for (int i = 1; i <= n; ++i) {
		read(a[i]);
		disc.push_back(a[i]);
	}
	sort(disc.begin(), disc.end());
	disc.erase(unique(disc.begin(), disc.end()), disc.end());
	for (int i = 1; i <= n; ++i)	a[i] = Get_ID(a[i]);
	for (int i = 1; i <= m; ++i) {
		read(e[i].l, e[i].r);
		e[i].id = i;
		e[i].pos = (e[i].l - 1) / Size;
	}
	sort(e + 1, e + 1 + m);
	Contribute();
	for (int i = 1; i <= m; ++i)	printf("%d\n", ans[i]);
	return 0;
}
```

---

## 作者：Others (赞：2)

这题应该加一个“语文”标签，第一遍读题，以为是暴力加优化，后来想到了严格的上升子序列的个数，自己搞了几组数据，发现是他们的众数的出现次数，至于为什么，下面再说。这题的题面真狠...
# 分析
这题的精髓是题面，认真读完题，一番认真思考，发现是求众数的出现的次数，这里解释一下，在上面已经说了，这是求最长上升子序列的个数（这应该很好理解），为什么是众数呢？ 因为我们假设有 $n$ 个最长上升子序列，编号为 $1-n$，我们让编号大的子序列尽可能长，这样若有两个子序列 $a$ 和 $b(a>b)$,$b$ 中有一个元素是 $a$ 没有的，那么将这个与元素插入 $a$ 中，则此时的 $a$ 序列的长度就不符合假设，则可得结论 $Sub_1\subseteq Sub2\subseteq Sub_3...\subseteq Sub_n$，即 $n=$ 众数的出现次数，众数为 $Sub_1$ 中的所有元素。

如果看不懂，可以自己手打几组数据看看。

既然知道是求众数了，又是区间，又可以离线，众数还是关于统计的，那么这题基本就可以断定为莫队了，而且还是普通莫队......

这道水题就这样被切掉了...
```cpp
#include <bits/stdc++.h>
using namespace std;
struct node{
	int l,r,id;
}p[200005];
int n,m,s,l=1,r,L,R,tot,a[200005],flag[200005],cnt[200005],ccnt[200005],ans[200005],idx[200005];
bool cmp(node x,node y){
	return idx[x.l]==idx[y.l]?(idx[x.l]&1?x.r<y.r:x.r>y.r):x.l<y.l;//养成习惯，奇偶排序 
}
void add(int i){
	--ccnt[cnt[a[i]]];  //统计数出现的次数出现的次数
	++ccnt[++cnt[a[i]]];//看不懂中文可以参考代码理解
	tot=max(tot,cnt[a[i]]);
}
void del(int i){
	--ccnt[cnt[a[i]]];
	if(tot==cnt[a[i]]&&ccnt[cnt[a[i]]]==0) --tot;//这里如果删掉的是众数而且是唯一的，那么将答案减一 
	++ccnt[--cnt[a[i]]]; 
}
int main() {
	scanf("%d%d",&n,&m);
	s=sqrt(n);
	for(int i=1;i<=n;++i){
		scanf("%d",&a[i]);
		idx[i]=(i+s-1)/s;//分块 
		flag[i]=a[i];//离散化1：记录 
	}
	sort(flag+1,flag+n+1);//离散化2：排序 
	int lenlen=unique(flag+1,flag+n+1)-flag-1;//离散化3：去重 
	for(int i=1;i<=n;++i) a[i]=lower_bound(flag+1,flag+lenlen+1,a[i])-flag;//离散化4：赋值
	for(int i=1;i<=m;++i){
		scanf("%d%d",&p[i].l,&p[i].r);
		p[i].id=i;
	}
	sort(p+1,p+m+1,cmp);
	for(int i=1;i<=m;++i){
		L=p[i].l,R=p[i].r;
		while(l>L) add(--l);
		while(r<R) add(++r);
		while(l<L) del(l++);
		while(r>R) del(r--);
		ans[p[i].id]=-tot;//记得这里是负的！！！ 
	}
	for(int i=1;i<=m;++i) printf("%d\n",ans[i]);
	return 0;
}
```

---

## 作者：Fido_Puppy (赞：2)

## Solution

首先，这道题让我们求的其实是区间众数的出现次数。

然而，我们会发现这题的加入元素很简单，但删除元素很困难（听说好像有一种用栈删除的）。

所以，我们就可以用只加不减的回滚莫队。

接着都是常规套路。

回滚莫队不会的戳这儿 -> [传送门](https://www.cnblogs.com/Parsnip/p/10969989.html)

## Code

```cpp
%:include"bits/stdc++.h"
using namespace std;
%:define N (int)(2e5+10)
int n,m;
int a[N],d[N],M,belong[N],cnt[N],l,r,ans[N],siz;
int Cnt[N];
struct query {
	int l,r,id;
}q[N];
inline bool cmp(query a,query b) {
	if (belong[a.l]!=belong[b.l]) return belong[a.l]<belong[b.l];
	else return a.r<b.r;
}
inline int query(int x,int y) {
	int Ans=0;
	for(int i=x;i<=y;i++) {
		Cnt[a[i]]++;
		Ans=max(Ans,Cnt[a[i]]);
	}
	for(int i=x;i<=y;i++) Cnt[a[i]]--;
	return Ans;
}
inline int doit(int qnum,int x) {
	for(int i=1;i<=M;i++) cnt[i]=0;
	int L=min(x*siz,n);
	int i=qnum,l=L+1,r=L;
	int anss=0;
	for(;belong[q[i].l]==x;i++) { // 千万不要写成 for(;belong[i]==x;i++)
		if (belong[q[i].l]==belong[q[i].r]) {
			ans[q[i].id]=query(q[i].l,q[i].r);
			continue;
		}
		while (r<q[i].r) {
			r++; cnt[a[r]]++;
			anss=max(anss,cnt[a[r]]);
		}
		int qwq=anss;
		while (l>q[i].l) {
			l--; cnt[a[l]]++;
			anss=max(anss,cnt[a[l]]);
		}
		ans[q[i].id]=anss;
		for(int j=l;j<=L;j++) cnt[a[j]]--;
		anss=qwq;
		l=L+1;
	}
	return i;
}
signed main() {
	ios::sync_with_stdio(false);
	cin.tie(0); cout.tie(0);
	cin>>n>>m; siz=sqrt(n);
	for(int i=1;i<=n;i++) cin>>a[i],d[i]=a[i];
	sort(d+1,d+n+1);
	M=unique(d+1,d+n+1)-d-1;
	for(int i=1;i<=n;i++) a[i]=lower_bound(d+1,d+M+1,a[i])-d; // 离散化
	for(int i=1;i<=m;i++) cin>>q[i].l>>q[i].r,q[i].id=i;
	for(int i=1;i<=n;i++) belong[i]=(i-1)/siz+1;
	sort(q+1,q+m+1,cmp);
	int qnum=1;
	for(int i=1;i<=belong[n];i++) {
		qnum=doit(qnum,i);
	}
	for(int i=1;i<=m;i++) cout<<-ans[i]<<endl; // 最后输出是 -ans[i]
	return 0;
}
```
完结撒花！ ^.^

---

## 作者：诗乃 (赞：2)

题意：求区间众数出现次数。

%%%莫队的神仙

写一发分块瞎搞的题解

先随便离散化一下，然后随便分个块。分块后，预处理出第$i$~$j$块之间的众数出现次数，记为$MAX[i][j]$

搞一个$vector$按顺序记录存每个元素的出现位置，然后再记录一下每个元素在$vector$中的位置，记为$pos[i]$。

查询的时候，整块的整个统计。对于散块中的数，考虑一下它的出现次数有没有可能超过众数。

对于左边角的数，设当前数为$x$，我们在$vector$里面找到下标为$pos[x]+ans$的元素$y$，若$y≤r$，那么元素$y$的出现次数一定超过了$ans$，我们把$ans+1$。对于右边角的数，同理瞎搞一下。

总复杂度$O((n+m)\sqrt n)$。

代码：

```cpp
// luogu-judger-enable-o2
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 500050, BLNM = 5050;
void read(int &x) {
	char ch; while(ch = getchar(), ch < '!'); x = ch - 48;
	while(ch = getchar(), ch > '!') x = (x << 3) + (x << 1) + ch - 48;
}
int belong[MAXN], L[MAXN], R[MAXN], a[MAXN], MAX[BLNM][BLNM], blsz, n, q, w[MAXN], siz[MAXN], blnm, cnt[MAXN], lastans;
vector <int> lis[MAXN];
int main() {
	read(n); read(q); blsz = sqrt(n);
	for(int i = 1; i <= n; ++i) read(a[i]), w[i] = a[i], belong[i] = (i-1) / blsz + 1;
	sort(a+1, a+n+1); int _n = unique(a+1, a+n+1) - a - 1;
	for(int i = 1; i <= n; ++i) {
		w[i] = lower_bound(a+1, a+_n+1, w[i]) - a;
		siz[i] = lis[w[i]].size();
		lis[w[i]].push_back(i);
	} blnm = belong[n];
	for(int i = 1; i <= blnm; ++i) L[i] = (i-1) * blsz, R[i] = L[i] + blsz - 1;
	L[1] = 1; R[blnm] = n;
	for(int i = 1; i <= blnm; ++i) {
		memset(cnt, 0, sizeof cnt);
		int mx = 0, ima = i;
		for(int j = L[i]; j <= n; ++j) {
			++cnt[w[j]];
			mx = max(cnt[w[j]], mx);
			if(j == R[ima]) {MAX[i][ima] = mx; ++ima;}
		}
	}
	while(q--) {
		int l, r; read(l); read(r);
		int lblock = belong[l], rblock = belong[r]; lastans = 0;
		if(lblock == rblock) {
			for(int i = l; i <= r; ++i) while(siz[i] + lastans < lis[w[i]].size() && lis[w[i]][siz[i] + lastans] <= r) ++lastans;
		} else {
			if(lblock + 1 < rblock) lastans = MAX[lblock+1][rblock-1];
			for(int i = l; i <= R[lblock]; ++i) while(siz[i] + lastans < lis[w[i]].size() && lis[w[i]][siz[i] + lastans] <= r) ++lastans;
			for(int i = L[rblock]; i <= r; ++i) while(siz[i] >= lastans && lis[w[i]][siz[i] - lastans] >= l) ++lastans;
		}
		printf("%d\n", -lastans);
	}
}

```

---

## 作者：Rye_Catcher (赞：2)

- 题目链接：

   https://www.luogu.org/problemnew/show/P3709
   
- 思路：

   首先我是没读懂题目的，浏览了讨论区的dalao发现才知道就是求区间众数的出现次数。
   
   然后肯定是用莫队，具体怎么写莫队其他题解都写得很详细，这里不赘述.然后观察数据范围1e9肯定要离散化。
   
   但是题解里讲离散化的不多，我就讲一讲我自己瞎搞的一个离散化方法
   
   看到题解里其他dalao都是什么lower_bound或我看不懂的神仙操作。而蒟蒻我就瞎搞出了一个比较暴力的,也通俗易懂方法---开了两个map.
   
   第一个map al用来离散化，记录元素是否出现过.
   
   第二个map getrk顾名思义，用来离散化获取每个数的排名.
   
   dat[]用来记录**原字符串**,num[]用来记录**去重**后的数，即**所有出现的元素**
   
   读入字符串后将num[]从大到小排序，记录每一个出现元素的排名，当然就是用getrk
   
   接着就不管num[]，我们遍历一遍获取**原字符串中每个数的排名**完成离散化.
   
   由于开了map,常数比较大，开了O2跑了2000多ms，但是能过就行了
   
- 代码：

```
// luogu-judger-enable-o2
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <cctype>
#include <map>
#include <cmath>
using namespace std;
const int maxn=200005;
map <int,bool>al;
map <int,int>getrk;
struct Ask{
	int l,r,id,x;
}ask[maxn];
int num[maxn],dat[maxn],rk[maxn];
int belong[maxn],block;
int N,n=0,m;
int a[maxn],cnt[maxn];
int ans[maxn],anss=0;
template<class T>inline void read(T &x){
	x=0;int ne=0;char c;
	while(!isdigit(c=getchar()))ne=c=='-';
	x=c-48;
	while(isdigit(c=getchar()))x=(x<<3)+(x<<1)+c-48;
	x=ne?-x:x;
	return ;
}
inline bool cmp0(const int&x,const int&y){
	return x>y;
}
inline bool cmp2(const Ask &x,const Ask &y){
	return belong[x.l]^belong[y.l]?belong[x.l]<belong[y.l]:belong[x.l]&1?x.r<y.r:x.r>y.r;
}
inline void init()
{
	int x;
	read(N),read(m);
	block=N/sqrt(m*2/3);
    n=0;
	for(register int i=1;i<=N;i++){//N是原字符串长度
		read(x);
		dat[i]=x;
		if(al[x]==0){//去重
	      num[++n]=x;//n是去重后num[]数组长度
		  al[x]=1;
		 } 
	    belong[i]=(i-1)/block+1;
	}
	sort(num+1,num+1+n,cmp0);
	for(register int i=1;i<=n;i++){
		getrk[num[i]]=i;
  //      belong[i]=(i-1)/block+1;
	}
	for(register int i=1;i<=N;i++){
		rk[i]=getrk[dat[i]];
	}
	//sort(num+1,num+1+n,cmp1);
	for(register int i=1;i<=m;i++){
		read(ask[i].l),read(ask[i].r);
		ask[i].id=i;
	}
	sort(ask+1,ask+1+m,cmp2);
	return;
}
inline void add(int x){
	int now=rk[x];
	if(anss==a[now])anss++;
	cnt[a[now]]--;
	a[now]++;
	cnt[a[now]]++;
	return;
} 
inline void sub(int x){
	int now=rk[x];
	if(anss==a[now]&&cnt[a[now]]==1)anss--;
	cnt[a[now]]--;
	a[now]--;
	cnt[a[now]]++;
	return;
}
inline void solve()
{
	int l=1,r=0,ll,rr;
	cnt[0]=n;
	for(register int i=1;i<=m;i++){
		ll=ask[i].l,rr=ask[i].r;
		while(r<rr)add(++r);
		while(r>rr)sub(r),r--;
		while(l<ll)sub(l),l++;
		while(l>ll)add(--l); 
		ans[ask[i].id]=anss;
	}
	for(register int i=1;i<=m;i++){
		printf("-%d\n",ans[i]);
	}
	return ;
}
int main()
{
    init();
    solve();
	return 0;
 } 
```

---

## 作者：KEBrantily (赞：1)

看起来知识点 + 思维难度大概蓝题，读题难度大概紫题？

因为说实话我现在还是很难独立描述清楚题面的意思

## Description

要求从区间每次取一个数与给定的 $x$ 作比较，若取出的数小于 $x$ 则分数减一，求最大分数

因为没有加分操作只有扣分操作，所以也可以看成要求扣分最小化

因此本质是每次从区间中取出一个严格上升的序列，然后问最少取几次（还是引用了楼叉楼的话，因为个人能力无法做成更言简意赅的描述了）

## Solution

那就是找出现次数最多的数的出现次数咯

这么一说就简单多了，莫队搞一下就可以了

先给数据离散化，然后通过维护每个数的出现次数和出现这么多次的数的个数来转移区间更新答案即可

注意收缩区间时要确定删去的这个数是否有唯一性，或者说是否对答案有影响，具体内容看代码

看起来这么做不加任何优化依然跑得飞快（？）

最后的答案就是出现最多的数的出现次数的相反数

## Code

```cpp
#include<queue>
#include<cmath>
#include<vector>
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<climits>
#include<iostream>
#include<algorithm>
#define maxn 1000010
#define INF 0x3f3f3f3f
//#define int long long

using namespace std;

int n,m,Ans,len,L=1,R=0,tot;
int sum[maxn],num[maxn],cnt[maxn];
int ans[maxn],b[maxn],a[maxn],siz[maxn];
struct question{int now,l,r;}q[maxn];
 
int read(){
    int s=0,w=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-') w=-1;ch=getchar();}
    while(ch>='0'&&ch<='9') s=(s<<1)+(s<<3)+ch-'0',ch=getchar();
    return s*w;
}

bool cmp(question x,question y){
    return (x.l/len)^(y.l/len)?x.l<y.l:x.r<y.r;
}

void build(){
    n=read();m=read();len=sqrt(n+0.5);
    for(int i=1;i<=n;i++)a[i]=read(),b[i]=a[i];
    sort(b+1,b+n+1);tot=unique(b+1,b+n+1)-b-1;
    for(int i=1;i<=n;i++)a[i]=lower_bound(b+1,b+tot+1,a[i])-b;
    for(int i=1;i<=m;i++)q[i].l=read(),q[i].r=read(),q[i].now=i;    
    sort(q+1,q+m+1,cmp);
}

void Add(int x){
    num[cnt[a[x]]]--;num[++cnt[a[x]]]++;
    Ans=max(Ans,cnt[a[x]]);
}

void Del(int x){    
    num[cnt[a[x]]]--;num[--cnt[a[x]]]++;
    if(Ans==cnt[a[x]]+1&&!num[cnt[a[x]]+1]) Ans--;
    //若删除的那个数的出现次数就是答案并且出现这么多次的数只有那一个时，删去它会使得答案变劣
}

int main(){
    build();
    for(int i=1;i<=m;i++){
        while(L>q[i].l) Add(--L);
        while(R<q[i].r) Add(++R);
        while(L<q[i].l) Del(L++);
        while(R>q[i].r) Del(R--);
        ans[q[i].now]=Ans;
    }
    for(int i=1;i<=m;i++) printf("%d\n",ans[i]);
    return 0;
}
```
```

---

## 作者：天南星魔芋 (赞：1)

~~此蒟蒻太弱了，检查了一天后发现原来分块写错了。~~

------------

[不会 莫队 的点这里。](https://www.cnblogs.com/WAMonster/p/10118934.html)

我们先看题：

你要维护一个集合 $S$。

* 给你一段数字构成的区间。
* 每次从这个区间中拿出一个数字 $x$。
* 如果 $S$ 为空，你 $rp$ 减 $1$。
* 如果 $S$ 中有一个元素不小于 $x$，则你 $rp$ 减 $1$，清空 $S$。
* 之后将 $x$ 插入 $S$。


经整理，我们发现：

* 若想要 $rp$ 尽量大，我们每次取最小的能不减 $rp$ 的数字。
* 当然，若无数字可不减 $rp$ 那么要取最小的数字。

所以，这道题的答案不就是区间中数出现的次数的最大值 $×-1$ 吗？

再看范围 对于 $100%$ 的数据，$1≤n,m≤2×10^5$ ，$1≤ai≤10^9$，$1≤l,r≤n$。

呃... 这个 $a$ 值有点大，能不能优化？

可以，因为我们只要 $a$ 的种类。故只将 $a$ 分类 $1$ 到 $K$ 就行了。（ $K$ 为 $a$ 的种类）

如代码：



```cpp
int n,m;
int a[5000005][2];//原 a ———  a[][0] 表示数值   a[][1] 表示位置 
int sum=0;
int aa[5000005];
......
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++){
	scanf("%d",&a[i][0]);a[i][1]=i;
	}
//	for(int i=1;i<=m;i++){
//		scanf("%d%d",&px[i].l,&px[i].r);
//		px[i].wz=i;
//	}不用管，区间查询储存部分 
......
	kp(1,n);//排序，使原数组有序 方便赋值  
    //（其实就是我太懒  直接赋值+用一个数组记录 也行 
	for(int i=1;i<=n;i++){
		if(a[i][0]!=a[i-1][0])
		sum++;//因为相同的都在一起，故若  a[i][0]!=a[i-1][0]  就找到一个新的数值 
		aa[a[i][1]]=sum;//将数值赋值给 aa[]  
	}
......
```


接下来我们要解决最大值问题。

通过莫队是一个一个移动 $l , r$ 指针实现的，

我们有以下结论：

* 每次将有一个数个数 加减 $1$ 。

所以：

* 增加时，最大值由原来最大值 $+1$ 得到。
* 减少时，最大值是原来最大值 $-1$ 或 $-0$ (有多个最大值) 得到。

所以增加时,我们看看增加后这个数的数量是否超过 $ans$ 就行了。

减少时，我们用一个数组维护其他值就行了。

看一下代码吧：

```cpp
struct PX{
	int l;
	int r;
	int wz;
}px[5000005];
int n,m;
int sum=0;
int aa[5000005];
int ans[5000005];
int jl[5000005];
int cnt[5000005];
int fk[5000005];
int tot=0;
int l=0,r=0;

	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++){
	scanf("%d",&a[i][0]);a[i][1]=i;
	}
	for(int i=1;i<=m;i++){
		scanf("%d%d",&px[i].l,&px[i].r);
		px[i].wz=i;
	}
	for(register int i=1;i<=m;i++){
		//进入区间时先动指针  出区间时则反之 
		// jl[]  记录  编号为 aa[指针] 的数 出现的个数 
		// cnt[]  记录  编号为 jl[aa[指针]] 的数 出现的个数
		//例子：
		/*
			jl[](下标)  1    2    3    4    5    6    7    8    9    10 
			
			  数值      1    5    2    1    2    0    0    0    3    5
			  
			  
			  
			cnt[](下标) 0    1    2    3    4    5    6    7    9    10
			
			  数值      3    2    2    1    0    2    0    0    0    0
			  
			  来源     789  14   35    9        2 10 
		*/ 
		while(r<px[i].r){r++;cnt[jl[aa[r]]]--;jl[aa[r]]++;cnt[jl[aa[r]]]++;tot=jl[aa[r]]>tot?jl[aa[r]]:tot;}
						//加一个数 cnt中原数个数 个数--   原数个数++    cnt中原数个数+1 个数++   
		while(l>px[i].l){l--;cnt[jl[aa[l]]]--;jl[aa[l]]++;cnt[jl[aa[l]]]++;tot=jl[aa[l]]>tot?jl[aa[l]]:tot;}
		
		while(l<px[i].l){cnt[jl[aa[l]]]--;jl[aa[l]]--;cnt[jl[aa[l]]]++;l++;tot=cnt[tot]? tot:tot-1;}
					  //减一个数 cnt中原数个数 个数--   原数个数--    cnt中原数个数-1 个数++ 
		while(r>px[i].r){cnt[jl[aa[r]]]--;jl[aa[r]]--;cnt[jl[aa[r]]]++;r--;tot=cnt[tot]? tot:tot-1;}
		
		ans[px[i].wz]=-tot;
	}




```

于是直接把莫队套上就完事啦：


```cpp
#include<bits/stdc++.h>
using namespace std;
struct PX{
	int l;
	int r;
	int wz;
}px[5000005];
int n,m;
int a[5000005][2];
int sum=0;
int aa[5000005];
int ans[5000005];
int jl[5000005];
int cnt[5000005];
int fk[5000005];
int gs,sq;
int tot=0;
int l=0,r=0;
int cmp(PX a,PX b){
	return (fk[a.l]^fk[b.l])? fk[a.l]>fk[b.l]:((fk[a.l]&1)? a.r<b.r:a.r>b.r);
//----------------------------//奇偶排序  可快一倍  证明见上面 链接 
}
void kp(int l,int r){
	int i=l,j=r;
	int mid=a[(l+r)/2][0];
	while(i<=j){
		while(a[i][0]<mid)i++;
		while(a[j][0]>mid)j--;
		if(i<=j){
			swap(a[i][0],a[j][0]);
			swap(a[i][1],a[j][1]);
			i++;j--;
		}
	}
	if(l<j)kp(l,j);
	if(i<r)kp(i,r);
}
//---------------------------//一个普通的快排  :) 
signed main(){

	scanf("%d%d",&n,&m);
	sq=sqrt(n);//--------------------------// 
	gs=ceil((double)n/sq);				  // 
//---------------------------------------// 分块 
	for(int i=1;i<=gs;i++)              // 我就是在这里挂了 
	for(int j=(i-1)*gs+1;j<=i*gs;j++)  // 
	fk[j]=i;						  // 
	for(int i=1;i<=n;i++){			 // 
	scanf("%d",&a[i][0]);			// 
	a[i][1]=i;					   // 
	} 							  // 
//-------------------------------// 
	for(int i=1;i<=m;i++){
		scanf("%d%d",&px[i].l,&px[i].r);
		px[i].wz=i;
	}
//-----------------------------// 
	sort(px+1,px+m+1,cmp);    // 我还不太会用 sort 
	kp(1,n);				 // 不过相对于 快排 kp  sort好香 
//--------------------------// 
	for(int i=1;i<=n;i++){
		if(a[i][0]!=a[i-1][0])sum++;
		aa[a[i][1]]=sum;
	}
	cnt[0]=500055;
//-----------------------------------------//莫队 
	for(register int i=1;i<=m;i++){
		while(r<px[i].r){r++;cnt[jl[aa[r]]]--;jl[aa[r]]++;cnt[jl[aa[r]]]++;tot=jl[aa[r]]>tot?jl[aa[r]]:tot;}
		while(l>px[i].l){l--;cnt[jl[aa[l]]]--;jl[aa[l]]++;cnt[jl[aa[l]]]++;tot=jl[aa[l]]>tot?jl[aa[l]]:tot;}
		while(l<px[i].l){cnt[jl[aa[l]]]--;jl[aa[l]]--;cnt[jl[aa[l]]]++;l++;tot=cnt[tot]? tot:tot-1;}
		while(r>px[i].r){cnt[jl[aa[r]]]--;jl[aa[r]]--;cnt[jl[aa[r]]]++;r--;tot=cnt[tot]? tot:tot-1;}
		ans[px[i].wz]=tot;
	}
//-------------------------------------// 输出 
	for(int i=1;i<=m;i++){
		printf("%d\n",-ans[i]);
	}
}

```

但这个代码可以更快：

* $while$ 移动指针时 可以缩短代码。

* 因为 $jl[aa[指针]]$ 在 $jl[aa[指针+1]]$ 不为 $0$ 时 用不到
， 所以 $cnt$ 只用执行一个操作就行了。

* $sort$ 排序中 $cmp$ 的策略加上 若 a.r==b.r  a.l<b.l 。


优化代码：



```cpp
#include<bits/stdc++.h>
using namespace std;
struct PX{
	int l;
	int r;
	int wz;
}px[5000005];
int n,m;
int a[5000005][2];
int sum=0;
int aa[5000005];
int ans[5000005];
int jl[5000005];
int cnt[5000005];
int fk[5000005];
int gs,sq;
long long aass=0;
int tot=0;
int l=0,r=0;
//-----------------------------------------------------//策略更新 
int cmp(PX a,PX b){
	return (fk[a.l]^fk[b.l])? fk[a.l]>fk[b.l]:((a.r^b.r)?(((fk[a.l]&1)? a.r<b.r:a.r>b.r)):a.l<b.l);
}
void kp(int l,int r){
	int i=l,j=r;
	int mid=a[(l+r)/2][0];
	while(i<=j){
		while(a[i][0]<mid)i++;
		while(a[j][0]>mid)j--;
		if(i<=j){
			swap(a[i][0],a[j][0]);
			swap(a[i][1],a[j][1]);
			i++;j--;
		}
	}
	if(l<j)kp(l,j);
	if(i<r)kp(i,r);
}
signed main(){
	scanf("%d%d",&n,&m);
	sq=sqrt(n);
	gs=ceil((double)n/sq);
	for(int i=1;i<=gs;i++)
	for(int j=(i-1)*gs+1;j<=i*gs;j++)
	fk[j]=i;
	for(int i=1;i<=n;i++){
	scanf("%d",&a[i][0]);a[i][1]=i;
	}

	for(int i=1;i<=m;i++){
		scanf("%d%d",&px[i].l,&px[i].r);
		px[i].wz=i;
	}
	sort(px+1,px+m+1,cmp);
	kp(1,n);
	for(int i=1;i<=n;i++){
		if(a[i][0]!=a[i-1][0])sum++;
		aa[a[i][1]]=sum;
	}
	cnt[0]=500055;
	for(register int i=1;i<=m;i++){
		//极限缩短 ：) 
		while(r<px[i].r){cnt[++jl[aa[++r]]]++;tot+=cnt[tot+1]? 1:0;}
		while(r>px[i].r){cnt[jl[aa[r--]]--]--;tot+=cnt[tot]? 0:-1;}
		while(l>px[i].l){cnt[++jl[aa[--l]]]++;tot+=cnt[tot+1]? 1:0;}
		while(l<px[i].l){cnt[jl[aa[l++]]--]--;tot+=cnt[tot]? 0:-1;}
		ans[px[i].wz]=tot;
	}
	for(int i=1;i<=m;i++){
		printf("%d\n",-ans[i]);
	}
}
```




这篇题解就到这里了，

如有不到之处请多多指教。





---

## 作者：小闸蟹 (赞：1)

```cpp
// 思路：
// 由于数据有些大，所以先对该“字符串”进行离散化
// 然后套用莫队，求出区间众数即可
#include <iostream>
#include <array>
#include <cmath>
#include <algorithm>

constexpr int MaxN = 400000 + 5;
std::array<int, MaxN> s{ 0 }, q{ 0 }, d{ 0 }, Ans{ 0 }, Sum{ 0 }, cnt{ 0 };
// Sum[t]表示t这个数出现的次数
// cnt[i]表示出现了i次的数有几个
// Ans[i]表示第i次的询问的答案

int Read()
{
    int n = 0, k = 1;
    char ch = std::getchar();
    while ((ch > '9' || ch < '0') && ch != '-')
    {
        ch = std::getchar();
    }

    if (ch == '-')
    {
        k = -1;
        ch = std::getchar();
    }

    while (ch <= '9' && ch >= '0')
    {
        n = n * 10 + ch - '0';
        ch = std::getchar();
    }

    return n * k;
}

class Query
{
public:
    int x, y, id;

    Query() = default;
    Query(int x, int y, int id) :
        x(x), y(y), id(id)
    {
    }

    bool operator<(const Query &rhs) const noexcept
    {
        if (s[x] != s[rhs.x])   // 如果处于不同的分块，那就按分块的次序来排列
        {
            return s[x] < s[rhs.x];
        }
        else // 如果处于相同的分块，那就按照右端点的次序来排列
        {
            return y < rhs.y;
        }
    }
};

std::array<Query, MaxN> Que;

int main()
{
    int n, m;
    n = Read();
    m = Read();

    int sqt = static_cast<int>(std::sqrt(n));
    for (int i = 1; i <= n; ++i)
    {
        int t;
        t = Read();
        q[i] = t;   // 将要被排序去重的数组
        d[i] = t;   // 原数组，记录下原封不动的数字序列，就是题目中的“字符串”
        s[i] = i / sqt;   // 分块
    }

    // 先给q数组排序，然后求出不相同的元素的个数（Size），为后面离散化做准备
    std::sort(q.begin() + 1, q.begin() + n + 1);
    auto Size = std::unique(q.begin() + 1, q.begin() + n + 1) - (q.begin() + 1);
    for (int i = 1; i <= n; ++i)
    {
        // 记录下原数组中每个数是第几大的，也就是离散化了
        d[i] = std::lower_bound(q.begin() + 1, q.begin() + Size + 1, d[i]) - q.begin();
    }
    for (int i = 1; i <= m; ++i)
    {
        int l, r;
        l = Read();
        r = Read();
        Que[i] = std::move(Query(l, r, i));
    }
    std::sort(Que.begin() + 1, Que.begin() + m + 1);    // 用莫队前要先排序

    // 注意l一定要从1开始，我在这里WA了四次!
    int l = 1, r = 0, Now = 1;
    cnt[0] = 1;
    for (int i = 1; i <= m; ++i)
    {
        auto x = Que[i].x, y = Que[i].y;

        while (l > x)   // 当前l在询问的左端点的右侧
        {
            --l;    // l退一步
            auto &t = Sum[d[l]];    // t：数字d[l]出现的个数
            --cnt[t];   // 数字d[l]的个数发生了变化，这一句有点绕
            if (Now == t)   // 如果遇到了原来的众数，就把计数器加一
            {
                ++Now;
            }

            ++t;    // 这时候才可以更新数字d[l]的个数
            ++cnt[t];
        }

        // 后面的也还是莫队的套路，同理了
        while (r < y)
        {
            ++r;
            auto &t = Sum[d[r]];
            if (Now == t)
            {
                ++Now;
            }

            --cnt[t];
            ++t;
            ++cnt[t];
        }

        while (l < x)
        {
            auto &t = Sum[d[l]];
            --cnt[t];
            if (Now == t && cnt[t] == 0)    // 如果没有别的数也能有那么多个，那计数器就得减一了
            {
                --Now;
            }

            --t;
            ++cnt[t];
            ++l;
        }

        while (r > y)
        {
            auto &t = Sum[d[r]];
            --cnt[t];
            if (Now == t && cnt[t] == 0)
            {
                --Now;
            }

            --t;
            ++cnt[t];
            --r;
        }

        Ans[Que[i].id] = Now;
    }

    for (int i = 1; i <= m; ++i)
    {
        std::cout << -Ans[i] << std::endl;  // 题目要求输出的是相反数，别被坑到了
    }

    return 0;
}
```

---

## 作者：Stinger (赞：0)

# $\texttt{Description}$

> 给你一个序列，多次询问区间众数出现次数，可以离线。

# $\texttt{Solution}$

~~你没看错，正解写在了description里。~~

根据贪心原则，题目其实就是问你有多少个严格递增的子序列，而这个就是区间众数出现次数。因为众数每出现一次，都需要单独占用一个子序列。

为啥题面写得这么非人类啊/dk/dk/dk

求区间众数出现次数可以用膜队解决。~~啊这是我刚刚学完膜队板子找到的题。~~

$cnt_x$ 表示值为 $x$ 的数出现了多少次，$a_x$ 表示有多少个数出现了 $x$ 次。转移代码写得很清楚（（（

别忘了离散化/kk

# $\texttt{Code}$

```cpp
#include <cstdio>
#include <cmath>
#include <algorithm>

inline int max(const int x, const int y) {return x > y ? x : y;}

int a[200005], c[200005], cnt[200005], ans[200005], b[200005], S, n, m, k;

struct Question {
	int l, r, id;
	inline bool operator < (const Question x) const {
		bool t((l - 1) / S + 1 == (x.l - 1) / S + 1);
		return t ? (r - 1) / S + 1 < (x.r - 1) / S + 1 : (l - 1) / S + 1 < (x.l - 1) / S + 1;
	}
} q[200005];
inline void add(const int x) {
	-- a[cnt[x]], ++ a[++ cnt[x]];
	k = max(k, cnt[x]);
}
inline void del(const int x) {
	-- a[cnt[x]], ++ a[-- cnt[x]];
	if (!a[k]) -- k;
}

int main() {
	int l(1), r(0);
	scanf("%d%d", &n, &m);
	S = max(1, n / sqrt(m));
	for (int i(1); i <= n; ++ i) scanf("%d", c + i), b[i] = c[i];
	std::sort(b + 1, b + n + 1);
	for (int i(1); i <= n; ++ i) c[i] = std::lower_bound(b + 1, b + n + 1, c[i]) - b;
	for (int i(1); i <= m; ++ i) scanf("%d%d", &q[i].l, &q[i].r), q[i].id = i;
	std::sort(q + 1, q + m + 1);
	for (int i(1); i <= m; ++ i) {
		while (l < q[i].l) del(c[l ++]);
		while (l > q[i].l) add(c[-- l]);
		while (r > q[i].r) del(c[r --]);
		while (r < q[i].r) add(c[++ r]);
		ans[q[i].id] = k;
	}
	for (int i(1); i <= m; ++ i) printf("%d\n", -ans[i]);
	return 0;
}
```

---

## 作者：傅天宇 (赞：0)

[luogu's link](https://www.luogu.com.cn/problem/P3709)

#### 题意：

这题...题意是重点！！！作为一道**语文题**，这道题的题意使难度上升了很多（其实重点是因为我语文差/kk  

给你一个字符串 $a$ （其实不是字符串，就是一个数组），每次询问一段区间的贡献。

区间的贡献定义：

初始 $rp=0$。

每次从这个区间中拿出一个字符 $x$ （数），然后把 $x$ 从这个区间中删除，直到区间为空。你要维护一个集合 $S$。

- 如果 $S$ 为空，你 $rp-1$。

- 如果 $S$ 中有一个元素大于等于 $x$，则你 $rp-1$，清空 $S$。

- 之后将 $x$ 插入 $S$。

要求使得 $rp$ 最大。

数据范围：$1 \leq n,m \le 2 \times10^5$。

#### Solution：

由这个数据范围及只需查询很容易想到 莫队。

题意看起来比较麻烦，~~我一开始也被搞蒙了~~，后经过大佬@[快乐的疯烁](https://www.luogu.com.cn/user/281497)及神仙同桌@[子落楸枰](https://www.luogu.com.cn/user/91381)指点，才懂。

举个栗子：

比如题目编号 1 2 3 4 5 6 7

难度分别为 1 2 2 3 3 3 3

要查询 1-4，2-5，3-6

手摸得知，答案为 -2，-2，-3

插入顺序：

查询点1：以编号为 1,2,4,3 顺序插入最优。

查询点2：以编号为 2,4,3,5 顺序插入最优。

查询点3：以编号为 3,4,5,6 顺序插入最优。

由此，我们可以发现两个结论：

1. 答案正是查询区间众数（与[P1997 faebdc 的烦恼](https://www.luogu.com.cn/problem/P1997)一样，是双倍经验）

2. 插入时我们并不是从左到右插的，而是先全部是不同大小的插入，所以后面查询的时候是要先改 $r$，再改 $l$ 的！！！（不然你会得到 $80$ 的高分，我就是因为这个调了两个晚自修 /fad）。

#### Code：

代码就很简单了。


```cpp

/*
 * @Author: FuTianyu 
 * @Date: 2020-11-05 18:07:14 
 * @Last Modified by: FuTianyu
 * @Last Modified time: 2020-11-05 20:06:21
 */
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define debug() puts("fty")
#define FOR(i,a,b) for(int i=a;i<=b;i++)
#define REP(i,a,b) for(int i=a;i>=b;i--)
/*
快读快输
*/
const int N=2e5+5;
int n,m,a[N],b[N],kc,kuai[N],tong[N],sum[N],ans,Ans[N];
/*
a_i表示原始数组,由于很大,需要离散化,b_i即为离散化后的数组.
tong_i表示第i个数在区间内出现的个数,sum_i表示区间内出现个数为i的个数.
*/
struct node{
    int l,r,id;
}cun[N];
bool cmp(node x,node y){
    return kuai[x.l]==kuai[y.l]?x.r<y.r:kuai[x.l]<kuai[y.l];
}
void del(int x){
    sum[tong[b[x]]]--;
    if(ans==tong[b[x]]&&sum[tong[b[x]]]==0) ans--;
    sum[--tong[b[x]]]++;
}
void add(int x){
    sum[tong[b[x]]]--;
    if(ans==tong[b[x]]) ans++;
    sum[++tong[b[x]]]++;
}
signed main(){
    n=read();
    m=read();
    kc=sqrt(n);
    FOR(i,1,n){
        a[i]=read();
        b[i]=a[i];
        kuai[i]=(i-1)/kc+1;
    }
    sort(a+1,a+1+n);
    int len=unique(a+1,a+1+n)-a-1;
    FOR(i,1,n) b[i]=lower_bound(a+1,a+1+len,b[i])-a;
    FOR(i,1,m){
        cun[i].l=read();
        cun[i].r=read();
        cun[i].id=i;
    }
    sort(cun+1,cun+1+m,cmp);
    int l=1,r=0;
    FOR(i,1,m){
        int L=cun[i].l;
        int R=cun[i].r;
        while(r>R) del(r--);
        while(r<R) add(++r);
        while(l<L) del(l++);          
        while(l>L) add(--l);              
        Ans[cun[i].id]=-ans;
    }
    FOR(i,1,m){
        write(Ans[i]);
        puts("");
    }
    return 0;
}
```

---

## 作者：_Anchor (赞：0)

# 1.题意

~~因为出题人语死早~~，原题意比较毒瘤，所以这里整个舒服点的题意：

```cpp
静态询问区间众数对应的该众数个数
```
（至于为什么已经有daolao给出证明了）

（注意答案要取负）

# 2.思路

由于是静态问题，且询问的是区间众数，所以很容易我们可以想到用莫队来解决这个问题

[不知道什么是莫队康这个](https://oi-wiki.org/misc/mo-algo/)

在本题中，莫队对应的基础操作很容易可以想到：

1.维护当前序列中每个数a[i]的出现次数cnt[a[i]]

2.维护当前的众数有多少个

所以移动区间的时候判断讨论一下就可以了

(注意要离散化 （因为a[i]为1e9） )

# 3.代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=10000005,M=10000005;
inline int read(){
    int x=0,f=1;char ch=getchar();
    while(ch>'9'||ch<'0'){if(ch=='-'){f=-1;}ch=getchar();}
    while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+ch-'0';ch=getchar();}
    return x*f;
}
int a[N],pos[N],n,m,ANS[N],ans=1,cnt[N],num[N],A[N];
struct node{
    int l,r,id;
}q[N];
inline bool cmp(node x,node y){
    if(pos[x.l]==pos[y.l]) return x.r<y.r;
    return pos[x.l]<pos[y.l];
}
inline void update(int id,int f){
    if(f==1){
        num[cnt[a[id]]]--;
        num[cnt[a[id]]+1]++;
        cnt[a[id]]++;
        if(cnt[a[id]]>ans) ans=cnt[a[id]];
    }
    else{
        num[cnt[a[id]]]--;
        if(num[ans]==0) ans--;
        num[cnt[a[id]]-1]++;
        cnt[a[id]]--;
    }
    return ;
}
int main(){
    n=read(),m=read();
    int op=sqrt(n);
    for(int i=1;i<=n;i++){
        A[i]=read();
        a[i]=A[i];
        pos[i]=i/op;
    }
    sort(A+1,A+n+1);
    int nn=unique(A+1,A+n+1)-A-1;
    for(int i=1;i<=n;i++) a[i]=lower_bound(A+1,A+nn+1,a[i])-A;
    for(int i=1;i<=m;i++){
        q[i].l=read(),q[i].r=read(),q[i].id=i;
    }
    sort(q+1,q+m+1,cmp);
    for(int i=1,l=1,r=0;i<=m;i++){
        while(l<q[i].l) update(l++,-1);
        while(l>q[i].l) update(--l,1);
        while(r<q[i].r) update(++r,1);
        while(r>q[i].r) update(r--,-1);

        ANS[q[i].id]=ans;
    }
    for(int i=1;i<=m;i++) printf("%d\n",(-1)*ANS[i]);
    return 0;
}
```









---

## 作者：chdy (赞：0)

又复习了一发回滚莫队...~~这题好无聊~~

题目的中一句最多的rp意味着这个随机具有贪心性而不是期望。

可以发现 重复数字最多的次数为答案的下界.此时其他数字也重复的话可以一起带出来...那么问题的本质就是询问区间之中数字出现最多的次数.

显然是莫队，当然分块也是可以的像蒲公英那道题目。

统计答案的方式:

1.外面套两个数组$c[i],s[i]$分别表示第i个数字出现多少次 出现次数为i的数字个数有多少个 这样来更新就可以保证每次指针移动的复杂度为$O(1)$了。

2.显然我们莫队之外再对值域进行分块，即对出现次数进行分块，维护$sum[i]$表示第i块中的数字出现了多少次 也是$O(1)$进行修改，当一个询问结束后暴力扫每一个块然后当一个块中有值再暴力扫某个块。

3.回滚莫队我们发现在左指针移动的时候答案可能会消失，此时我们只让左指针向左移动即可不使答案丢失。

下面给出回滚莫队的代码：

```
const int MAXN=200010;
int n,m,cnt,S,B,L,R,las;
int a[MAXN],s[MAXN],b[MAXN];
int ans[MAXN],c[MAXN],l[MAXN],r[MAXN];
struct wy
{
	int l,r;
	int id;
}t[MAXN];
inline int cmp(wy a,wy c){return (b[a.l]^b[c.l])?a.l<c.l:a.r<c.r;}
inline void discrete()
{
	sort(a+1,a+1+n);
	for(int i=1;i<=n;++i)if(i==1||a[i]!=a[i-1])a[++cnt]=a[i];
	for(int i=1;i<=n;++i)s[i]=lower_bound(a+1,a+1+cnt,s[i])-a;
}
inline void calc(wy a)
{
	int maxx=0;
	if(b[a.l]==b[a.r])
	{
		for(int i=a.l;i<=a.r;++i)maxx=max(maxx,++c[s[i]]);
		for(int i=a.l;i<=a.r;++i)--c[s[i]];
		ans[a.id]=maxx;
		return;
	}
	else
	{
		for(int i=R+1;i<=a.r;++i)las=max(las,++c[s[i]]);
		for(int i=L-1;i>=a.l;--i)maxx=max(maxx,++c[s[i]]);
		for(int i=L-1;i>=a.l;--i)--c[s[i]];
		ans[a.id]=max(las,maxx);R=a.r;
	}
}
int main()
{
	freopen("1.in","r",stdin);
	n=read();m=read();
	S=(int)sqrt(n*1.0);B=n%S==0?n/S:n/S+1;
	for(int i=1;i<=B;++i)
	{
		l[i]=S*(i-1)+1;r[i]=min(n,i*S);
		for(int j=l[i];j<=r[i];++j)b[j]=i,s[j]=a[j]=read();
	}
	discrete();
	for(int i=1;i<=m;++i)
	{
		int l,r;
		l=read();r=read();
		t[i]=(wy){l,r,i};
	}
	sort(t+1,t+1+m,cmp);
	int st=0;
	for(int i=1;i<=m;++i)
	{
		int w=b[t[i].l];
		if(b[t[i].l]!=b[t[i-1].l])
		{
			L=r[w]+1;
			for(int j=st+1;j<=R;++j)--c[s[j]];//注意这个地方st不能换成r[w-1]！
			st=R=r[w];las=0;
		}
		calc(t[i]);
	}
	for(int i=1;i<=m;++i)printf("%d\n",-ans[i]);
	return 0;
}

```

---

## 作者：Orina_zju (赞：0)

（首先吐槽一下，题面绕了半天实际上就是一个区间众数，绕一下也就算了题目描述还写得这么潦草……）

平方分割类问题的一个基本套路：寻找一个“**满足XX条件的值只有$\text{O}(\sqrt{N})$个**”的性质。

对于本题，这个性质则是“出现次数为$\Omega(\sqrt{N})$的数只会有$\text{O}(\sqrt{N})$个”。

程序主体还是离散化+莫队离线处理询问。我们可以设立一个阈值$T \approx \sqrt{N}$，每次移动当前区间两端的时候更新如下内容：

- `count[v]`表示（离散化后的）数值v出现的次数；
- `count_count[c]`表示有多少个数v满足`count[v] == c`，也就是对上述的`count`数组再做一遍按值计数；
- `large_count_set`存储所有满足`count[v] >= T`的数值v。根据上文提到的性质，这个集合的元素个数只有$\text{O}(\sqrt{N})$个。

获取当前询问的答案，若`large_count_set`不为空，则直接遍历整个集合，取`count`的最大值；否则，在`count_count`数组中找最大的`v`使得`count_count[v] > 0`（此时必有`0 < v < T`）。

分析时间复杂度：

- 莫队算法共执行$\text{O}(N \sqrt{N})$次移动区间端点的操作。假定`large_count_set`基于`std::set`实现，则单次操作的复杂度为$\text{O}(\log N)$。当然大多数时候都不会对`large_count_set`造成修改，此时的单次复杂度只有$\text{O}(1)$。而且这个log事实上也是可以改进数据结构从而砍掉的，但是我懒๑乛◡乛๑

- 单次获取答案的复杂度为$\text{O}(\sqrt{N})$，共计执行$\text{O}(N)$次

综上，时间复杂度为$\text{O}(N \sqrt{N} \log N)$，其中的log影响极其有限，并且可以通过改进算法优化掉。

代码如下：
```cpp
#include <cstdio> 
#include <cstring> 
#include <algorithm> 
#include <set> 

constexpr int maxN = (int)2e5 + 10; 
constexpr int block_size = 450;

int N, Q, A[maxN]; 

void discretize(int n, int* a)
{
    static int a_copy[maxN];
    std::copy(a, a + n, a_copy); 
    std::sort(a_copy, a_copy + n); 
    for (int i = 0; i < n; i++)
        a[i] = std::lower_bound(a_copy, a_copy + n, a[i]) - a_copy; 
}

struct Query 
{
    int id;
    int block_id; 
    int left, right; 
};
Query query[maxN]; 
int ans[maxN]; 
int count[maxN]; 
int count_count[maxN]; 
std::set<int> large_count_set; 

void add_count(int v)
{
    count_count[count[v]] -= 1; 
    count[v] += 1; 
    if (count[v] == block_size) //Transfer to large_count_set
        large_count_set.insert(v); 
    
    count_count[count[v]] += 1; 
}
void sub_count(int v)
{
    if (count[v] == block_size) //Remove from large_count_set
        large_count_set.erase(v); 
    
    count_count[count[v]] -= 1;
    count[v] -= 1;
    count_count[count[v]] += 1; 
}

int get_ans() 
{
    if (large_count_set.empty()) 
    {
        for (int i = block_size - 1; i > 0; i--)
            if (count_count[i] > 0)
                return i;
        return -1; 
    }
    else 
    {
        int res = 0;
        for (int v: large_count_set)
            res = std::max(res, count[v]); 
        return res; 
    }
}

int main()
{
    scanf("%d%d", &N, &Q);
    for (int i = 0; i < N; i++)
        scanf("%d", A + i); 
    discretize(N, A); 
    for (int l, r, i = 0; i < Q; i++)
    {
        scanf("%d%d", &l, &r);
        l -= 1; //[l, r), 0-based
        query[i] = {.id = i, .block_id = l / block_size, .left = l, .right = r}; 
    }
    std::sort(query, query + Q, [] (const Query& A, const Query& B) {
        if (A.block_id != B.block_id)
            return A.block_id < B.block_id;
        return A.right < B.right;
    });

    int cur_l = 0, cur_r = 0;

    for (int i = 0; i < Q; i++)
    {
        const auto& q = query[i]; 
        while (cur_r < q.right)
            add_count(A[cur_r++]); 
        while (cur_r > q.right)
            sub_count(A[--cur_r]); 
        while (cur_l > q.left)
            add_count(A[--cur_l]);
        while (cur_l < q.left)
            sub_count(A[cur_l++]); 
        ans[q.id] = get_ans(); 
    }
    for (int i = 0; i < Q; i++)
        printf("%d\n", -ans[i]);
    return 0; 
}
```


---


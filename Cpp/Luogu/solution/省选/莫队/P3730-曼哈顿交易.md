# 曼哈顿交易

## 题目背景

will 在曼哈顿开了一家交易所，每天，前来买卖股票的人络绎不绝。


现在，will 想要了解持股的情况。由于来交♂易的人实在是太多了，需要你写一个程序来帮他完成这个任务。


## 题目描述

- 前来交易的 $N$ 个人排成了一行，为了简便起见，每个人都只持有一种股票。
- 不同的的人可能会持有相同的股票。
- 定义一种股票的热度为持有该股票的人数。
- 每次，will 会给出这样的询问：在一段连续区间的人之中，热度第 $k$ 小的股票的热度是多少？


## 说明/提示

对于 $20\%$ 的数据，$N,M\leq 1000$。

对于另外 $10\%$ 的数据，所有的 $l=1, r=N$。

对于 $100\%$ 的数据，$1\leq N, M\leq 10^5$，$1\leq a_i\leq 10^9$。


## 样例 #1

### 输入

```
4 4  
2 3 3 3  
1 4 1  
1 4 2  
1 3 2
1 3 3```

### 输出

```
1  
3  
2  
-1```

# 题解

## 作者：RuntimeErr (赞：14)

# 蒟蒻的莫队+值域分块题解

### 保证简单易懂！

**题意简化**

令 $cnt_i$ 表示第 $i$ 种股票的持有人数，求 $cnt_i$的第 $k$ 小。

**思路**

考虑值域分块，注意值域是持有某种股票的人数（热度），所以范围是不超过 $n$ 的，我们令 $cnt1_i$ 表示第 $i$ 种股票的**持有人数（热度）**（用于整块查询），$cnt2_i$ 表示持有人数（热度）为 $i$ 的**股票个数**（用于块内查询），再开一个块数组 $tot$ 表示每个值域块的**股票数量**（跟 $cnt1$ 配合使用）。

考虑 $add$ 和 $del$ 函数，我们肯定是要先把当前股票原来的持有人数的贡献去掉，再加上新的贡献，这个很好理解吧。

```cpp
//be是对应的块
//两个函数前半段都是去掉原来的贡献，后半段都是加上新的贡献
inline void add(int x){
    --cnt2[cnt1[x]];
    --tot[be[cnt1[x]]];
    ++cnt2[++cnt1[x]];//唯一的区别就是这一句了
    ++tot[be[cnt1[x]]];  
}
inline void del(int x){
    --cnt2[cnt1[x]];
    --tot[be[cnt1[x]]];
    ++cnt2[--cnt1[x]];
    ++tot[be[cnt1[x]]];
}

```

再来看查询部分，我们先按块查，把查询的 $k$ 每次都减去当前块的股票个数，若 $k$ 减去之后会小于等于 $0$ 那要找的块就是它了（若所有块都查完了 $k$ 还是大于 $0$ 那直接返回 $-1$），接着在块内按同样的方式，把 $k$ 每次都减去该热度的持股数量，直到 $k$ 小于等于 $0$ 就返回该热度。

```cpp
inline int get(int k){
    int i;
    for(i=1;i<=num;++i){//num是块数
        if(k-tot[i]<=0)break;//找到了就退出
        k-=tot[i];
    }
    if(i==num+1)return -1;//所有块都查完了还没找到就返回-1
    for(int j=L[i];j<=R[i];++j){
        if(k-cnt2[j]<=0)return j;//找到了就返回
        k-=cnt2[j];
    }
}
```

### ！！！值域甚大，须离散化

# $Code:$

```cpp
#include<cstdio>
#include<algorithm>
#include<cmath>

using namespace std;

const int N=1e5+10;

int n,m,a[N],b[N],ans[N];
int bl,L[N],R[N],be[N],num,tot[N],cnt1[N],cnt2[N];
struct query{int l,r,k,id;}q[N];

inline bool cmp(query a,query b){
    return be[a.l]^be[b.l]?a.l<b.l:be[a.l]&1?a.r<b.r:a.r>b.r;
}

inline void add(int x){
    --cnt2[cnt1[x]];
    --tot[be[cnt1[x]]];
    ++cnt2[++cnt1[x]];
    ++tot[be[cnt1[x]]];  
}
inline void del(int x){
    --cnt2[cnt1[x]];
    --tot[be[cnt1[x]]];
    ++cnt2[--cnt1[x]];
    ++tot[be[cnt1[x]]];
}
inline int get(int k){
    int i;
    for(i=1;i<=num;++i){
        if(k-tot[i]<=0)break;
        k-=tot[i];
    }
    if(i==num+1)return -1;
    for(int j=L[i];j<=R[i];++j){
        if(k-cnt2[j]<=0)return j;
        k-=cnt2[j];
    }
}

int main(){
    scanf("%d%d",&n,&m);bl=pow(n,0.455);
    
    for(int i=1;i<=n;++i){
        scanf("%d",&a[i]);
        b[i]=a[i];
    }
    sort(b+1,b+n+1);
    int tot=unique(b+1,b+n+1)-b-1;
    for(int i=1;i<=n;++i)a[i]=lower_bound(b+1,b+tot+1,a[i])-b;
    
    for(int i=1,tmp=-1;i<=n;++i){
        be[i]=(i-1)/bl+1;
        if(tmp^be[i])L[++num]=i,tmp=be[i];
        R[num]=i;
    }
    
    for(int i=1;i<=m;++i){
        scanf("%d%d%d",&q[i].l,&q[i].r,&q[i].k);
        q[i].id=i;
    }
    sort(q+1,q+m+1,cmp);
    
    for(int i=1,l=q[1].l,r=l-1;i<=m;++i){
        while(l>q[i].l)add(a[--l]);
        while(r<q[i].r)add(a[++r]);
        while(l<q[i].l)del(a[l++]);
        while(r>q[i].r)del(a[r--]);
        ans[q[i].id]=get(q[i].k);
    }
    for(int i=1;i<=m;++i)printf("%d\n",ans[i]);
    return 0;
}
```

---

## 作者：Yuki_Ever (赞：8)

本题解思路来源：[AiRC0S](https://www.luogu.com.cn/user/390770)（提交此题解已经过本人允许）



------------
#### 前置知识：莫队

其实本题无需使用值域分块，思路也并不复杂。（感谢 AiRC0S 大佬思路）

------------
## 莫队算法

首先，由于本题系不带修查询，直接考虑先使用莫队算法对询问进行分块。

```cpp
struct query{
    int l, r, k, id;
} q[N]; //询问结构体 

bool cmp(query a, query b){
    return a.l/L == b.l/L? a.r<b.r : a.l<b.l;
    //排序 ，L为块长
}
```




------------

## Solution
然后，很多人在这里使用了值域分块，来维护区间第 k 小。实际上，我们考虑这个算法的本质。定义一个数组 $cnt$ 表示股票的热度，所谓的值域分块，不过是结合莫队的询问分块，每次在这个数组中进行一次单点修改（参见其他题解）。我们仔细考虑在这里单点修改的重要性质：只会对其中的一个值进行一次差为 $1$ 的更改。于是考虑对此数组进行排序（不妨由大到小）。排序后，如何保证始终使此序列有序？

解法应当相当明显了：如果要增加，就将该数字的序列中（必定连在一起）最左侧的数字增加 $1$，否则将最右侧的减少 $1$，这样序列始终保持有序。

这样一来，时间复杂度 $O(1)$ 修改，$O(\sqrt{n})$ 查询的值域分块，就可以完全被时间复杂度均 $O(1)$ 的数组单修代替，至此算法结束，代码完成。

```cpp
//lf表示每段连续数字的左端点，rf为右端点
//f为排序数组（由大到小） 
//cnt即热度数组 
void add(int x){
    f[lf[cnt[x]]] = cnt[x]+1;
    lf[cnt[x]]++;
    cnt[x]++;
    rf[cnt[x]]++;
}
void del(int x){
    f[rf[cnt[x]]] = cnt[x]-1;
    rf[cnt[x]]--;
    cnt[x]--;
    lf[cnt[x]]--;
}
//理论上，lf与rf可以通过+1-1的操作得到
//可以略去一个节省空间，但没有必要 
```
在一切之前，注意到值域大小，直接先离散化。

核心代码已给出，其余部分与其他题解中值域分块算法大致相同，不再给出。


------------
## Final
此题给予了我们很好的启示。这样的思路明显各方面优于值域分块，但明显这样的思路建立在值域分块上，又对其进行了大幅的优化。在做题时，先写基础代码是很好的习惯，但在算法完成后需要优化时，可以考虑从性质上分析，在思路上基于基础算法，但在实现上完全重做，而不局限于常数优化和数据结构优化。

最后再次鸣谢 [AiRC0S](https://www.luogu.com.cn/user/390770) 的思路以及给我在 OI 学习上的帮助。












---

## 作者：daniel14311531 (赞：8)

## 众所周知，这是一道莫队题（虽然可以用主席树）。
   1e5的区间且不易用线段树维护的题可以用莫队，已经有了O（n√n）的复杂度，这时再写各种树维护会达到O（n√n • log n）的复杂度，~~毕竟不是所有人都是wys~~。  
   
   事实上多加入/删除一个点，就是单点修改，区间查询的问题，单点分块即可做到O（1）修改，O（√n）查询。   
   
最终时间复杂度O（n√n）。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[100010],pos[100010],len,p;
int sz[410],L[410],R[410],bl[100010],sum=0,num[100010];
struct P { int x,y,k,id; };P ask[100010];
int cnt[100010],l=1,r=0,ans[100010];

inline int read() {
	register int tmp=0;register char c=getchar();
	while(c<'0'||c>'9')	c=getchar();
	while(c>='0'&&c<='9')	tmp=(tmp<<1)+(tmp<<3)+(c^48),c=getchar();
	return tmp;
}
inline bool cmp(const P &x,const P &y) { return x.x/p!=y.x/p?	x.x/p<y.x/p:x.y<y.y; }
inline void build() {
	for(int i=1;i<=n;i++)	bl[i]=(i-1)/p+1;
	for(int i=1;i<=bl[n];i++)	L[i]=(i-1)*p+1,R[i]=i*p;
	R[bl[n]]=n;
}
inline void modify(int x,int w) { num[x]+=w,sz[bl[x]]+=w,sum+=w; }
inline void add(int x) { if(cnt[x])	modify(cnt[x],-1); ++cnt[x],modify(cnt[x],1); }
inline void del(int x) { modify(cnt[x],-1),--cnt[x]; if(cnt[x])	modify(cnt[x],1); }
inline int query(int x) {
	if(sum<x)	return -1;
	int b=1;
	while(sz[b]<x)	x-=sz[b],++b;
	for(int i=L[b];i<=R[b];i++) {
		x-=num[i];
		if(x<=0)	return i;
	}
}
int main() {
	n=read(),m=read(),p=sqrt(n);
	for(int i=1;i<=n;i++)	pos[i]=a[i]=read();
	sort(pos+1,pos+n+1),len=unique(pos+1,pos+n+1)-pos-1;
	for(int i=1;i<=n;i++)	a[i]=lower_bound(pos+1,pos+n+1,a[i])-pos;
	build();
	for(int i=1;i<=m;i++)	ask[i].x=read(),ask[i].y=read(),ask[i].k=read(),ask[i].id=i;
	sort(ask+1,ask+m+1,cmp);
	for(int i=1;i<=m;i++) {
		while(r<ask[i].y)	add(a[++r]); while(r>ask[i].y)	del(a[r--]);
		while(l>ask[i].x)	add(a[--l]); while(l<ask[i].x)	del(a[l++]);
		ans[ask[i].id]=query(ask[i].k);
	}
	for(int i=1;i<=m;i++)	printf("%d\n",ans[i]);
	return 0;
}
```
  
码风不好，请见谅。

---

## 作者：Muel_imj (赞：6)

## [P3730 曼哈顿交易](https://www.luogu.com.cn/problem/P3730)

**提供一种 $O(1)$ 查询的莫队做法。**

分析题意：多次询问一个静态序列的第 $k$ 小出现次数。

说到第 $k$ 小，自然会想到主席树之类的数据结构，但是这题似乎不太好搞。

可以使用莫队，而且复杂度多个 $\log$ 大概就过不去。

回归最原始的第 $k$ 小求法：`sort`，答案直接访问下标。

放在这题，要维护一个关于权值出现次数的有序序列。顺便维护每个位置对应权值。

显然，每次移动指针的操作只变化一个权值的出现次数，所以可以尝试 $O(1)$。

容易想到的是每次变化一个权值然后暴力 `swap`，不过如果相同出现次数占了很多位置的话复杂度就假了。

然后又可以想到二分它最终到达的位置，但复杂度带个 $\log$。

实际上，可以发现每次 `swap` 到的位置都是**此出现次数在序列中的左右端点**，所以在操作时就动态维护这个端点。

初始当然序列上就是每个权值出现 $0$ 次，操作时找端点 `swap`，判一下新出现或消失的出现次数，随便维护一下即可。

查询就直接查询次数 $0$ 的右端点加上 $k$ 的下标位置。

这样修改和查询都是 $O(1)$ 的。总复杂度 $O(n\sqrt{n})$。

（不过修改操作常数大一点···）   

码 $\operatorname{qwq}$：

```cpp
#include<bits/stdc++.h>
#define EL puts("Elaina")
#define reg register int
typedef long long ll;
using namespace std;
inline char gc(){
	static char buf[1<<19],*p1,*p2;
	if(p1==p2){p1=buf,p2=buf+fread(buf,1,1<<19,stdin);if(p1==p2)return EOF;}
	return *p1++;
}
inline int read(){
	int x=0;char ch=gc();
	while(!isdigit(ch))ch=gc();
	while(isdigit(ch))x=(x<<1)+(x<<3)+(ch^48),ch=gc();
	return x;
}
inline void swap(int &x,int &y){int z=y;y=x,x=z;}
const int maxn=1e5+3;
struct node{
	int g,val;
}d[maxn];
int n,m,len,a[maxn],b[maxn],pos[maxn],block,inb[maxn],L[maxn],R[maxn],ans[maxn];
struct ask{
	int l,r,k,id;
	inline bool operator <(const ask &a)const{
		return inb[l]^inb[a.l]?inb[l]<inb[a.l]:inb[l]&1?r<a.r:r>a.r;
	}
}q[maxn];
inline void add(int g){
	int i=pos[g],j=R[d[i].val]--;
	swap(pos[g],pos[d[j].g]),swap(d[i],d[j]),d[j].val++;
	if(L[d[j].val]>R[d[j].val])L[d[j].val]=R[d[j].val]=j;
	else L[d[j].val]--;
}
inline void del(int g){
	int i=pos[g],j=L[d[i].val]++;
	swap(pos[g],pos[d[j].g]),swap(d[i],d[j]),d[j].val--;
	if(L[d[j].val]>R[d[j].val])L[d[j].val]=R[d[j].val]=j;
	else R[d[j].val]++;
}
inline void MyDearMomonts(){
	n=read(),m=read(),block=sqrt(n-1)+1,L[0]=1,R[0]=n;
	for(reg i=1;i<=n;++i)
		a[i]=b[i]=read(),inb[i]=(i-1)/block+1,d[i].g=i,pos[i]=i,L[i]=1;
	sort(b+1,b+n+1),len=unique(b+1,b+n+1)-b-1;
	for(reg i=1;i<=n;++i)a[i]=lower_bound(b+1,b+len+1,a[i])-b-1;
	for(reg i=1;i<=m;++i)q[i].l=read(),q[i].r=read(),q[i].k=read(),q[i].id=i;
	sort(q+1,q+m+1);int l=1,r=0;
	for(reg i=1;i<=m;++i){
		while(r<q[i].r)add(a[++r]);
		while(r>q[i].r)del(a[r--]);
		while(l<q[i].l)del(a[l++]);
		while(l>q[i].l)add(a[--l]);
		if(R[0]+q[i].k>n)ans[q[i].id]=-1;
		else ans[q[i].id]=d[R[0]+q[i].k].val;
	}
	for(reg i=1;i<=m;++i)printf("%d\n",ans[i]);
}
int main(){
	MyDearMomonts();
	return (0^0);
}
```

---

## 作者：dingwenzheng (赞：4)

补充一种其他题解很少提到的做法。

## 题目分析

设 $cnt_i$ 为持有 $i$ 股票的人数，本题要在区间内查询 $cnt_i$ 的第 $k$ 小，这个信息很难直接用线段树等其他数据结构维护，于是考虑莫队。

我们将 $cnt_i$ 再放入一个桶中，记 $cnt2_j$ 为 $cnt_i=j$ 的个数，想要在这个桶中找到第 $k$ 小的，自然而然就可以想到对这个桶求前缀和，然后就可以通过二分快速地找到第 $k$ 小的数了。

接下来我们考虑莫队在区间扩展中对这个前缀和数组的影响。首先考虑向区间内加入一个数，设这个数为 $v$，则 $cnt_v$ 会加一，对应到 $cnt2$ 上就是 $cnt2_{cnt_v}-1,cnt2_{cnt_v+1}+1$，再看前缀和数组，$cnt_v$ 之后的位置 $-1$ 和 $+1$ 都会抵消掉，所以只需在 $cnt_v$ 的位置上减一。从区间中去除一个数也是同理。

总的时间复杂度为 $O(n\sqrt n+m\log n)$

## AC代码
```cpp
#include<bits/stdc++.h>
#define FOR(i, l, r) for(int (i)=(l); (i)<=(r); (i)++)
#define ROF(i, r, l) for(int (i)=(r); (i)>=(l); (i)--)
#define deb(x) cerr << "debug " << #x << ": " << x << endl;
using namespace std;
inline int read(){
	int x = 0, f = 1;
	char c = getchar();
	while(c>'9' || c<'0'){
		if(c=='-')f=-1;
		c=getchar();
	}
	while(c>='0' && c<='9'){
		x = (x<<1)+(x<<3)+c-48;
		c = getchar();
	}
	return x*f;
}
inline void write(int x){
	if(x<0){
		putchar('-');
		x = -x;
	}
	if(x>=10) write(x/10);
	putchar(x%10+48);
}
const int N = 1e5+10;
int cnt[N], sum[N], a[N], ls[N], ans[N];
struct ask{
	int l, r, k, id;
}q[N]; 
inline void add(int v){
	sum[cnt[v]++]--;
}
inline void del(int v){
	sum[--cnt[v]]++;
}
int main(){
	int n = read(),m = read(); 
	FOR(i,1,n)ls[i] = a[i] = read();
	sort(ls+1, ls+n+1);
	FOR(i,1,n)a[i] = lower_bound(ls+1, ls+n+1, a[i])-ls;
	FOR(i,1,m){
		q[i].id = i;
		q[i].l=read(),q[i].r=read(),q[i].k=read();
	}
	int t = sqrt(n);
	sort(q+1, q+m+1, [&](ask a, ask b){
		return a.l/t!=b.l/t?a.l/t<b.l/t:a.r<b.r;
	});
	int l = 0, r = 0;
	FOR(i,1,m){
		while(r>q[i].r)del(a[r--]);
		while(r<q[i].r)add(a[++r]);
		while(l<q[i].l)del(a[l++]);
		while(l>q[i].l)add(a[--l]);
		if(sum[n]-sum[0]<q[i].k)ans[q[i].id]=-1;
		else ans[q[i].id] = lower_bound(sum+1, sum+n+1, sum[0]+q[i].k)-sum; 
	} 
	FOR(i,1,m){
		printf("%d\n", ans[i]);
	}
	return 0;
}
```


[AC记录](https://www.luogu.com.cn/record/213791329)

---

## 作者：critnos (赞：4)

用权值树状数组卡了半天没卡过/kk

然后用分块随便过了。。。

这道题很明显的莫队套一个求第 $k$ 小的数据结构

但是如果用权值树状数组/线段树是 $O(n^{1.5}\log n)$ 的

那么考虑一种增加/减少均是 $O(1)$ 的数据结构就很容易想到分块了。

然后每次查询时 $O(\sqrt n)$ 的可以接受。

所以用分块的复杂度是 $O(n^{1.5}+m\sqrt n)$。

因为这道题的分块很特殊所以可以用一个珂技。

```cpp
int t[10005];
int t2[100005];
int len;
void insert(int w,int v)
{
	if(w==0) return;
	t[w/len]+=v;
	t2[w]+=v;
}
int que(int k)
{
	int i;
    for(i=0;k>t[i];i++)
    	k-=t[i];
    for(i=i*len;k>t2[i];i++)
    	k-=t2[i];
    return i;
}
```
常数巨小。

---

## 作者：Fido_Puppy (赞：3)

$$\texttt{Description}$$

[P3730 曼哈顿交易](https://www.luogu.com.cn/problem/P3730)

$$\texttt{Solution}$$

一种股票的热度定义为持有这种股票的人数，我们看到要求一个数在区间内的出现次数，所以可以想到莫队。

既然最后要我们求热度第 $k$ 小的热度值，因为莫队的复杂度为 $\mathcal{O(n \sqrt n)}$，所以我们用 $\mathcal{O(\log n)}$ 的平衡树或者其他的数据结构就会导致时间复杂度变成 $\mathcal{O(n \sqrt n \log n)}$，无法通过此题。

所以我们可以想到插入 $\mathcal{O(} 1 \mathcal{)}$，查询第 $k$ 大 $\mathcal{O(\sqrt n)}$ 的值域分块，恰好可以平衡时间复杂度。

所以总的时间复杂度就是 $\mathcal{O(n \sqrt n)}$。

具体实现就可以对于每一种热度值的出现次数都记录下来，由于热度值不需要去重，所以在值域分块上直接加减即可。

可以参考这个讨论 $\texttt{->}$ [关于热度值](https://www.luogu.com.cn/discuss/416927)。

$$\texttt{Code}$$

```cpp
#include <bits/stdc++.h>

const int MAXN = (1 << 20);

namespace io {
	const int __SIZE = (1 << 21) + 1;
	char ibuf[__SIZE], *iS, *iT, obuf[__SIZE], *oS = obuf, *oT = oS + __SIZE - 1, __c, qu[55]; int __f, qr, _eof;
	#define Gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, __SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)
	inline void flush () { fwrite (obuf, 1, oS - obuf, stdout), oS = obuf; }
	inline void gc (char &x) { x = Gc(); }
	inline void pc (char x) { *oS ++ = x; if (oS == oT) flush (); }
	inline void pstr (const char *s) { int __len = strlen(s); for (__f = 0; __f < __len; ++__f) pc (s[__f]); }
	inline void gstr (char *s) { for(__c = Gc(); __c < 32 || __c > 126 || __c == ' ';)  __c = Gc();
		for(; __c > 31 && __c < 127 && __c != ' ' && __c != '\n' && __c != '\r'; ++s, __c = Gc()) *s = __c; *s = 0; }
	template <class I> inline bool gi (I &x) { _eof = 0;
		for (__f = 1, __c = Gc(); (__c < '0' || __c > '9') && !_eof; __c = Gc()) { if (__c == '-') __f = -1; _eof |= __c == EOF; }
		for (x = 0; __c <= '9' && __c >= '0' && !_eof; __c = Gc()) x = x * 10 + (__c & 15), _eof |= __c == EOF; x *= __f; return !_eof; }
	template <class I> inline void print (I x) { if (!x) pc ('0'); if (x < 0) pc ('-'), x = -x;
		while (x) qu[++ qr] = x % 10 + '0',  x /= 10; while (qr) pc (qu[qr --]); }
	struct Flusher_ {~Flusher_(){flush();}}io_flusher_;
} using io::pc; using io::gc; using io::pstr; using io::gstr; using io::gi; using io::print;

int n, m, a[MAXN], d[MAXN], M, siz, belong[MAXN], L = 1, R = 0;
struct Query {
	int l, r, k, id;
}q[MAXN];
int sum[1010], cnt[MAXN], ans[MAXN], num[MAXN], counter[MAXN];
int Left[1010], Right[1010];

inline bool cmp(Query a, Query b) {
	return (belong[ a.l ] ^ belong[ b.l ] ? belong[ a.l ] < belong[ b.l ] : (belong[ a.l ] & 1 ? a.r < b.r : a.r > b.r));
}

inline void add(int pos) {
	cnt[ num[ a[pos] ] ]--;
	sum[ belong[ num[ a[pos] ] ] ]--;
	
	num[ a[pos] ]++;
	cnt[ num[ a[pos] ] ]++;
	sum[ belong[ num[ a[pos] ] ] ]++;
}

inline void del(int pos) {
	cnt[ num[ a[pos] ] ]--;
	sum[ belong[ num[ a[pos] ] ] ]--;
	
	num[ a[pos] ]--;
	cnt[ num[ a[pos] ] ]++;
	sum[ belong[ num[ a[pos] ] ] ]++;
}

inline int query(int k) {
	int now = 0;
	for (register int i = 1; i <= belong[n]; i++) {
		if (now + sum[i] < k) {
			now += sum[i];
			continue;
		}
		for (register int j = Left[i]; j <= Right[i]; j++)
			if (now + cnt[j] < k) now += cnt[j];
			else return j;
	}
	return -1;
}

int main() {
	gi(n); gi(m); for (register int i = 1; i <= n; i++) gi(a[i]), d[i] = a[i];
	std::sort(d + 1, d + n + 1); M = std::unique(d + 1, d + n + 1) - d - 1;
	siz = 1000; for (register int i = 1; i <= n; i++) belong[i] = (i - 1) / siz + 1;
	for (register int i = 1; i <= belong[n]; i++)
		Left[i] = (i - 1) * siz + 1, Right[i] = std::min(n, i * siz);
	for (register int i = 1; i <= n; i++) a[i] = std::lower_bound(d + 1, d + M + 1, a[i]) - d;
	for (register int i = 1; i <= m; i++) gi(q[i].l), gi(q[i].r), gi(q[i].k), q[i].id = i;
	std::sort(q + 1, q + m + 1, cmp);
	for (register int i = 1; i <= m; i++) {
		while (R < q[i].r) add(++R);
		while (R > q[i].r) del(R--);
		while (L < q[i].l) del(L++);
		while (L > q[i].l) add(--L);
		ans[ q[i].id ] = query(q[i].k);
	}
	for (register int i = 1; i <= m; i++) print(ans[i]), pc('\n');
	return 0;
}
```


$$\texttt{Thanks for watching!}$$

---

## 作者：chenzida (赞：3)

u1s1 这题还挺难想的

看到这题你肯定能想到一个大暴力：直接莫队+值域线段树（平衡树）

但是你会发现它可能过不去 $10^5$，我们考虑一些优化方法。

注意到我们的一次修改是 $\log n$ 的，所以一次位移区间其实是 $\sqrt n\log n$ 的，而一次询问却是 $\log n$ 的，所以时间复杂度出现不平衡，所以我们考虑降低修改时间复杂度，代价是提高询问复杂度，所以这个题我们考虑分块做。

也就是用莫队维护分块，而分块我们可以看做是只有三层的线段树（虽然已经不能叫线段树了），这个东西我们查询一下 $kth$ 是 $\sqrt n$ 的，而插入删除则是 $O(1)$ 的。

所以我们位移一次区间均摊下来成了 $\sqrt n$，同时询问一次也变成了 $\sqrt n$，能够轻松通过此题。

代码如下：

```
#include<bits/stdc++.h>
using namespace std;
const int NR=1e5+10;
void Min(int& x,int y){x=min(x,y);}
void Max(int& x,int y){x=max(x,y);}
int n,m;
int a[NR];
int kc;
int getk(int x){return (x-1)/kc+1;}
struct Query
{
	int id,l,r,k;
	bool operator <(const Query& A)const
	{
		if(getk(l)!=getk(A.l))return getk(l)<getk(A.l);
		return r<A.r;
	}
}q[NR];
struct Fk
{
	int kc;
	int L[NR],R[NR];
	int cnt[NR],num[NR];
	int getid(int x){return (x-1)/kc+1;}
	void Init()
	{
		memset(cnt,0,sizeof(cnt)),memset(num,0,sizeof(num));
		int now=1;for(int i=1;i<=n;i+=kc)L[now]=i,R[now]=min(i+kc-1,n),now++;
	}
	void ins(int x){int p=getid(x);num[x]++;cnt[p]++;}
	void del(int x){int p=getid(x);num[x]--;cnt[p]--;}
	int query(int x)
	{
		int all=n/kc+1,t=0,now=-1;
		for(int i=1;i<=all;i++){t+=cnt[i];if(t>=x){t-=cnt[i];now=i;break;}}
		if(now==-1)return -1;x-=t;t=0;
		for(int i=L[now];i<=R[now];i++){t+=num[i];if(t>=x)return i;}
		return -1;
	}
}S;
int tot;
map<int,int>mp;
int Cnt[NR],Ans[NR];
void Ins(int x){if(Cnt[x])S.del(Cnt[x]);Cnt[x]++;if(Cnt[x])S.ins(Cnt[x]);}
void Del(int x){if(Cnt[x])S.del(Cnt[x]);Cnt[x]--;if(Cnt[x])S.ins(Cnt[x]);}
void move(int idx)
{
	int l1=q[idx-1].l,l2=q[idx].l;
	int r1=q[idx-1].r,r2=q[idx].r;
	while(l2<l1)Ins(a[l2++]);while(r2>r1)Ins(a[r2--]);
	while(l2>l1)Del(a[l1++]);while(r2<r1)Del(a[r1--]);
}
int read()
{
	int x=0,f=1;char ch=getchar();
	while(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}
	while(ch<='9'&&ch>='0'){x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}
	return x*f;
}
int main()
{
//	freopen("1.in","r",stdin);
//	freopen("1.out","w",stdout);
	n=read(),m=read();for(int i=1;i<=n;i++)a[i]=read();
	for(int i=1;i<=n;i++)if(!mp[a[i]])mp[a[i]]=++tot;
	for(int i=1;i<=n;i++)a[i]=mp[a[i]];
	for(int i=1;i<=m;i++)q[i].id=i,q[i].l=read(),q[i].r=read(),q[i].k=read();
	kc=S.kc=sqrt(n);S.Init();sort(q+1,q+m+1);q[0].l=1,q[0].r=0;
	for(int i=1;i<=m;i++)move(i),Ans[q[i].id]=S.query(q[i].k);
	for(int i=1;i<=m;i++)printf("%d\n",Ans[i]);
	return 0;
}

---

## 作者：Strelitzia (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P3730)

---

第一眼要用莫队，这是没问题的。

一开始是没有想法的，但曾听到巨佬说主席树可以找区间第 $k$ 小，

然后就去学了学主席树，感觉好像不行，而且看起来不像是套树形结构，因为好像会超时吧。

然后考虑值域分亏暴力，因为分块可以支持 $\Theta$($\text{1}$) 修改，$\Theta$($\sqrt{n}$) 查询。

看 $a_i$ 的范围，看出这道题要离散化，反正 $a_i$ 和答案没关系。

$vis_i$ 维护 $\text{i}$ 股票出现的次数，$cnt_i$ 维护热度为 $\text{i}$ 的数量，$res$ 是当前出现股票的种数，$num$ 值域分块。

```cpp
#include <cmath>
#include <queue>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;

template<typename T>void read(T &x) {
    T f = 1;x = 0;char s = getchar();
    while(s < '0' || s > '9') {if(s == '-')f = -1;s = getchar();}
    while(s >= '0' && s <= '9') {x = x * 10 + s - '0';s = getchar();}
    x *= f;
}
template<typename T>void print(T x) {
    if(x < 0) putchar('-'),x = -x;
    if(x > 9) print(x / 10);
    putchar(x % 10 + '0');
}

const int maxn = 100005;

struct node {
	int k,l,r,id;
}ask[maxn];

int n,m,t,b[maxn],a[maxn],L[maxn],R[maxn],pos[maxn],vis[maxn],num[maxn],ans[maxn],res,cnt[maxn];

bool cmp(node x,node y) {
	return pos[x.l] ^ pos[y.l] ? x.l < y.l : (pos[x.l] & 1 ? x.r < y.r : x.r > y.r);
}

void Add(int x) {
	if (vis[x]) {
		-- num[pos[vis[x]]];
		-- cnt[vis[x]];
	}
	else ++ res;
	++ num[pos[++ vis[x]]];
	++ cnt[vis[x]];
}

void Sub(int x) {
	-- num[pos[vis[x]]];
	-- cnt[vis[x]];
	if (-- vis[x]) {
		++ num[pos[vis[x]]];
		++ cnt[vis[x]];
	}
	else -- res;
}

int query(int x) {
	int k = ask[x].k;
	if (k > res) return -1;
	for (int i = 1 ; i <= t ; ++ i) {
		if (k <= num[i]) {
			for (int j = L[i] ; j <= R[i] ; ++ j) {
				if (k > cnt[j]) k -= cnt[j];
				else return j;
			}
		}
		else k -= num[i];
	}
}

int main () {
	read(n);read(m);
	
	t = sqrt(n);
	for (int i = 1 ; i <= t ; ++ i) L[i] = R[i - 1] + 1,R[i] = i * t;
	if (R[t] < n) ++ t,L[t] = R[t - 1] + 1,R[t] = n;
	for (int i = 1 ; i <= t ; ++ i) for (int j = L[i] ; j <= R[i] ; ++ j) pos[j] = i;
	
	for (int i = 1 ; i <= n ; ++ i) read(a[i]),b[i] = a[i];
	int tot = n;
	sort(b + 1,b + 1 + tot);
	tot = unique(b + 1,b + 1 + tot) - b - 1;
	for (int i = 1 ; i <= n ; ++ i) a[i] = lower_bound(b + 1,b + 1 + tot,a[i]) - b;
	
	for (int i = 1 ; i <= m ; ++ i) read(ask[i].l),read(ask[i].r),read(ask[i].k),ask[i].id = i;
	sort(ask + 1,ask + 1 + m,cmp);
	int l = 1,r = 0;
	for (int i = 1 ; i <= m ; ++ i) {
		while (l > ask[i].l) Add(a[-- l]);
		while (r < ask[i].r) Add(a[++ r]);
		while (l < ask[i].l) Sub(a[l ++]);
		while (r > ask[i].r) Sub(a[r --]);
		ans[ask[i].id] = query(i);
	}
	
	for (int i = 1 ; i <= m ; ++ i) print(ans[i]),putchar('\n');
	return 0;
}
```

---

## 作者：luyan (赞：2)

# 题目

[题目链接](https://www.luogu.com.cn/problem/P3730)

题目大意：一个区间内有n个数字，有m个询问，每次询问一个区间。回答这个区间的第k大的热度值。

​					热度值定义：数字i的热度值为：这个区间内i的出现次数。

# 分析

## 正解前置知识

权值分块；莫队算法

首先暴力做法：对于每一个区间，暴力搜索出每个数字的出现次数，把出现次数push到一个数组里面，寻找到出现次数的第k大的数字。

## 优化一：权值分块

优化寻找第k大数字，可以采用权值分块的方法。

一共n个数字，因此热度值的取值范围是$[0,n]$，所以把这个区间进行分块，维护每个块中热度值分布情况以及总的热度值个数。这样可以在$\sqrt{n}$的复杂度内求出第k大热度值。

具体做法：（qu函数）

1.从前往后遍历每个块，统计当前热度值个数。

2.如果加上当前块之后热度值个数大于k，就开始遍历块中的热度值

## 优化二：莫队算法离线处理

由于这道题目没有强制在线，因此可考虑莫队算法。

具体的add、remove操作见代码

# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int read(){
	char s;
	int x=0,f=1;
	s=getchar();
	while(s<'0'||s>'9'){
		if(s=='-')f=-1;
		s=getchar();
	}
	while(s>='0'&&s<='9'){
		x*=10;
		x+=s-'0';
		s=getchar();
	} 
	return x*f;
}
const int N=1e5+5;
int n,m;
struct query{
	int l,r,k;
	int id;
}q[N];
int a[N];
int block,num;
int belong[N];
int ls[N],rs[N];
void build(){
	block=sqrt(n);
	num=n/block;
	if(n%block)num++;
	for(int i=1;i<=n;i++)belong[i]=(i-1)/block+1;
	for(int i=1;i<=num;i++){
		ls[i]=(i-1)*block+1;
		rs[i]=i*block;
	}
	rs[num]=n;	
}
int pos[N];//离散化 
int cnt[N];//记录数字i出现了几次 
int tot[N];//值域分块-单点  tot[i]表示出现过i次的数字有几个(热度值为i的有几个) 
int sum[N];//值域分块-分块 
int all;//有几个热度值 
void modify(int x,int c){//x位置 +c
	tot[x]+=c;
	sum[belong[x]]+=c;
	all+=c;
}
int qu(int k){
	if(all<k)return -1;
	int id=1;
	for(int i=1;i<=num;i++){
		if(k>sum[i])k-=sum[i];
		else{
			for(int j=ls[i];j<=rs[i];j++){
				if(k>tot[j])k-=tot[j];
				else return j;
			}
		}
	}
	return k;
}
void add(int x){
	if(cnt[a[x]])modify(cnt[a[x]],-1);//出现了这种次数的数字-1 
	cnt[a[x]]++;
	modify(cnt[a[x]],1);
}
void remove(int x){
	modify(cnt[a[x]],-1);
	cnt[a[x]]--;
	if(cnt[a[x]])modify(cnt[a[x]],1);
}
bool operator<(query a,query b){
	if(belong[a.l]!=belong[b.l])return belong[a.l]<belong[b.l];
	return a.r<b.r;
}
int ans[N];
int main(){
	n=read(),m=read();
	for(int i=1;i<=n;i++){
		a[i]=read();
		pos[i]=a[i];
	}
	sort(pos+1,pos+1+n);
	int len=unique(pos+1,pos+1+n)-1-pos;
	for(int i=1;i<=n;i++)a[i]=lower_bound(pos+1,pos+1+n,a[i])-pos;//离散化 
	for(int i=1;i<=m;i++){
		q[i].l=read(),q[i].r=read(),q[i].k=read();
		q[i].id=i;
	}
	build();
	sort(q+1,q+1+m);
	int l=1,r=0;
	for(int i=1;i<=m;i++){
		while(l<q[i].l)remove(l++);
		while(l>q[i].l)add(--l);
		while(r<q[i].r)add(++r);
		while(r>q[i].r)remove(r--);
		ans[q[i].id]=qu(q[i].k);
	}
	for(int i=1;i<=m;i++)printf("%d\n",ans[i]);
}
```


---

## 作者：VTloBong (赞：1)

# 题意
给出一个有 n 个数的序列，对该序列有 m 个询问，对于每次询问，输出区间 $[l,r]$ 内，出现次数第 k 小的数的出现次数。    
# 思路
一个区间内某个数的出现次数难以用树型数据结构来维护，~~题目中又有“曼哈顿”三字~~，所以考虑离线算法——莫队。  
由于 $a_i≤10^9$ ,所以需要离散化。   
如果平衡树或权值线段数来维护出现次数的排名，那么每进行一次 区间调整（一次 add 或 一次 del），都需要 $O(\log n)$的复杂度来进行插入或删除操作，总的时间复杂度会达到 $O(n \sqrt{n}\log n)$ ,由于 $N,M≤100000$ ，所以无法AC此题。   
观察莫队算法和数据范围，会发现插入或删除操作次数即区间调整次数,为 $O(n \sqrt{n})$ 级别，查询第 k 小操作的次数为 n ，所以我们需要一个 $O(1)$ 插入/删除, $O(\sqrt{n})$ 或低于 $O(\sqrt{n})$ 的复杂度查询第 k 小的数据结构/算法。   
值域分块便可以 $O(1)$ 插入/删除, $O(\sqrt{n})$ 查询第 k 小，若用莫队+值域分块，总的时间复杂度为 $O(n \sqrt{n})$ ,由于 $N,M≤100000$ ，所以可以AC此题。   
由于我人傻自带大常数，所以加了奇偶化排序才 AC ,不加就TLE。  
# 代码
码风丑陋，请见谅。   
```cpp
#include<cstdio>
#include <algorithm>
using namespace std;
const int maxn=100005,sqrn=320;
struct number{
	int data,id;
}lsh[maxn];
struct query{
	int l,r,k,id;
}q[maxn];
int a[maxn],cnt[maxn],num[maxn],b[maxn],bl[sqrn],br[sqrn],s[sqrn],ls=1,rs,size,all,f[maxn],ans,n,m;
bool cmp1(number x,number y){
	return x.data <y.data ;
}
bool cmp2(query x,query y){
    return (x.l-1)/size==(y.l-1)/size?(((x.l-1)/size)&1?x.r<y.r:x.r>y.r ):(x.l-1)/size<(y.l-1)/size; //奇偶化排序
}
inline void modify(int x,int d){
	num[x]+=d,s[b[x]]+=d,all+=d;
}
inline void add(int k){
	if(cnt[a[k]])modify(cnt[a[k]],-1);
	cnt[a[k]]++,modify(cnt[a[k]],1);
}
inline void del(int k){
	modify(cnt[a[k]],-1),cnt[a[k]]--;
	if(cnt[a[k]])modify(cnt[a[k]],1);
	
}
inline int query(int x){
	if(all<x)return -1;
	for(int i=1;i<=b[n];i++){
		if(x>s[i])x-=s[i];
		else {
			for(int j=bl[i];j<=br[i];j++)
				if(x>num[j])x-=num[j];
				else return j;
		}
	}
}
int main(){
	scanf("%d%d",&n,&m);
	for(register int i=1;i<=n;++i)
		lsh[i].id=i,scanf("%d",&lsh[i].data);
	sort(lsh+1,lsh+n+1,cmp1);
	for(int i=1;i<=n;i++){
		if(lsh[i].data!=lsh[i-1].data||i==1)num[0]++;
		a[lsh[i].id]=num[0];
	}//奇怪的离散化
    for(size=1;size*size<n;size++);
	for(register int i=1;i<=m;++i)
		q[i].id=i,scanf("%d%d%d",&q[i].l,&q[i].r,&q[i].k);
	sort(q+1,q+m+1,cmp2),num[0]=0;
	for(int i=1;i<=n;i++)b[i]=(i-1)/size+1;
    for(int i=1;i<=b[n];i++)bl[i]=(i-1)*size+1,br[i]=i*size;
    br[b[n]]=n;//值域分块
	for(register int i=1;i<=m;++i){
		int nl=q[i].l ,nr=q[i].r ;
		while(rs<nr)rs++,add(rs);
		while(ls>nl)ls--,add(ls);
		while(ls<nl)ls++,del(ls-1);
		while(rs>nr)rs--,del(rs+1);
		f[q[i].id]=query(q[i].k);
	}//莫队
    for(register int i=1;i<=m;++i)
         printf("%d\n",f[i]);
	return 0;
}
```

---

## 作者：BigJoker (赞：0)

# 前置

2021 最后一篇题解，祝各位新年快乐，万事如意，心想事成！！！

莫队套值域分块，复杂度 $O(n\sqrt{n})$。

# 思路

对于每次的询问，明显可以普通莫队。

由于题目问的是热度值，跟其 $a_i$ 的取值没有关系，但是跟 $a_i$ 的出现次数有关系，那么明显可以搞一个统计热度值的桶。因为我们关心的是热度值，**热度值出现了几次才是我们在后面查询需要用的**。

既然都想到这里了，便不难想到可以打一个热度值的值域分块，即一个块内的热度值出现的数量。（这里一定要弄懂啊）

这样，每次指针移完之后，由于求热度值第 $k$ 小。

便直接从小到大枚举块。

如果块内的总值小于剩余 $k$，那么剩余 $k$ 减去块内的总值，得到新的剩余 $k$，然后接着看下一块。

否则，直接暴力从小到大枚举块内热度值。找到为止，**这时候答案必然在块内**。



# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+5;
const int M=1e5+5;
const int K=1e5+5;
int n,m;
int a[N],b[N];
int ans[M];
int lenn,lenk;
int cnt[K],id[K],t[1005],t2[1005];
int L[1005],R[1005];
struct Q{
	int L,R,Rank,ID;
}q[M];
int get(int x){
	return (x+lenn-1)/lenn;
}
bool cmp(Q x,Q y){
	return get(x.L)==get(y.L)?x.R<y.R:get(x.L)<get(y.L); 
}
void add(int x){
	t[id[cnt[x]]]--;
	t2[cnt[x]]--;
	cnt[x]++;
	t[id[cnt[x]]]++;
	t2[cnt[x]]++;
}
void sub(int x){
	t[id[cnt[x]]]--;
	t2[cnt[x]]--;
	cnt[x]--;
	t[id[cnt[x]]]++;
	t2[cnt[x]]++;
}
int Ask(int k){
	for(int i=1;i<=id[100000];i++){
		if(k<=t[i]){
			for(int j=L[i];j<=R[i];j++){
				if(k>t2[j]) k-=t2[j];
				else if(t2[j]) return j;
			}
		} 
		k-=t[i];
	}
	return -1;
}
int main(){
	scanf("%d %d",&n,&m);
	lenn=sqrt(n);
	lenk=sqrt(100000);
	for(int i=1;i<=100000;i++) id[i]=(i+lenk-1)/lenk;
	for(int i=1;i<=100000;i++) if(!L[id[i]]) L[id[i]]=i;
	for(int i=100000;i>=1;i--) if(!R[id[i]]) R[id[i]]=i; 
	for(int i=1;i<=n;i++) scanf("%d",&a[i]),b[i]=a[i];
	sort(b+1,b+1+n);
	for(int i=1;i<=n;i++) a[i]=lower_bound(b+1,b+1+n,a[i])-b;
	for(int i=1;i<=m;i++) scanf("%d %d %d",&q[i].L,&q[i].R,&q[i].Rank),q[i].ID=i;
	sort(q+1,q+1+m,cmp);
	int l=1,r=0;
	for(int i=1;i<=m;i++){
		while(q[i].L>l) sub(a[l++]);
		while(q[i].L<l) add(a[--l]);
		while(q[i].R<r) sub(a[r--]);
		while(q[i].R>r) add(a[++r]);
		ans[q[i].ID]=Ask(q[i].Rank);
	}
	for(int i=1;i<=m;i++) printf("%d\n",ans[i]);
	return 0;
} 
```

# 后记

这种思想其实是很重要的，也是莫队入门的一个难坎，多见了，就不见怪了。

---

## 作者：FutaRimeWoawaSete (赞：0)

莫队加值域分块的一道比较简单的应用。    

首先要很清楚地知道我们要查询的是股票第 $k$ 小的热度是多少，不然别到时候想了半天发现自己萎掉了……     

首先考虑简单点，假如此时我们知道了最后的所有热度情况，那么我们就直接扫一遍，找到第 $k$ 大即可。     

现在我们是查询区间，像这种可以离线的东西先果断离线看一下有没有什么用，感觉可以莫队？     

思考一番，感觉直接莫队记录一下每个元素出现了多少次也有点难做，况且我们现在只是处理出来了每种股票出现了多少次，对于排名查询我们甚至连一点操作都没有，所以考虑再套个数据结构，而很显然，要想保持莫队的时间复杂度，我们需要一个修改 $O(1)$ ， 修改 $O(\log n \sim \sqrt n)$ 的数据结构，考虑分块。     

这时候我们的思路就很清晰了：值域分块，第 $x$ 个地方需要保存当前出现了热度为 $x$ 的股票多少种，然后大块记录一下总和，查询就首先暴力扫大块，把我们查询的范围收缩到一块里，然后暴力查这个块就行了。     

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;
const int Len = 1e5 + 5;
int n,m,lsh[Len],pos[Len],L[Len],R[Len],val[Len],add[Len],size,where[Len],t,Cnt,Print[Len],a[Len],cnt[Len];
struct node
{
	int l,r,k,idx;
}Sec[Len];
bool cmp(node x,node y)
{
	if(where[x.l] ^ where[y.l]) return where[x.l] < where[y.l];
	return x.r < y.r;
}
void Add(int x){add[x] ++ , val[pos[x]] ++;}
void Sub(int x){add[x] -- , val[pos[x]] --;}
void ADD(int x)
{
	Sub(cnt[a[x]]);
	cnt[a[x]] ++;
	Add(cnt[a[x]]);
}
void SUB(int x)
{
	Sub(cnt[a[x]]);
	cnt[a[x]] --;
	Add(cnt[a[x]]);
}
int query(int k)
{
	int res = 0;
	for(int i = 1 ; i <= t ; i ++) 
	{
		if(res + val[i] >= k)
		{
			int num = 0;
			for(int j = L[i] ; j <= R[i] ; j ++)
			{
				if(res + num + add[j] >= k) return j;
				else num += add[j];
			}
		} 
		else res += val[i];
	}
	return -1;
}
int main()
{
	scanf("%d %d",&n,&m);
	size = sqrt(n);
	for(int i = 1 ; i <= n ; i ++) where[i] = (i - 1) / size + 1;
	for(int i = 1 ; i <= n ; i ++) 
	{
		scanf("%d",&a[i]);
		lsh[i] = a[i];
	}
	sort(lsh + 1 , lsh + 1 + n);
	Cnt = unique(lsh + 1 , lsh + 1 + n) - lsh - 1;
	for(int i = 1 ; i <= n ; i ++) a[i] = lower_bound(lsh + 1 , lsh + 1 + Cnt , a[i]) - lsh;
	t = sqrt(n);
	for(int i = 1 ; i <= t ; i ++) L[i] = (i - 1) * t + 1 , R[i] = i * t;
	if(R[t] < n) L[t] = R[t - 1] + 1 , R[t] = n;
	for(int i = 1 ; i <= t ; i ++)
		for(int j = L[i] ; j <= R[i] ; j ++) pos[j] = i;
	for(int i = 1 ; i <= m ; i ++)
	{
		scanf("%d %d %d",&Sec[i].l,&Sec[i].r,&Sec[i].k);
		Sec[i].idx = i;
	}
	sort(Sec + 1 , Sec + 1 + m , cmp);
	for(int i = 1 , l = 1 , r = 0 ; i <= m ; i ++)
	{
		while(l > Sec[i].l) ADD(-- l);
		while(r < Sec[i].r) ADD(++ r);
		while(l < Sec[i].l) SUB(l ++);
		while(r > Sec[i].r) SUB(r --);
		Print[Sec[i].idx] = query(Sec[i].k);
	}
	for(int i = 1 ; i <= m ; i ++) printf("%d\n",Print[i]);
	
	return 0;
}
```

---

## 作者：XenonKnight (赞：0)

> ## 洛谷 P3730

> 题意：给出一个数组 $a$。有 $m$ 次询问，每次给出一个区间 $[l,r]$。记 $cnt_i$ 为 $i$ 在这个区间中出现的次数。求 $cnt$ 数组所有非零值当中，第 $k$ 小的值。如果不存在输出 $-1$。

> $1 \leq n,m \leq 10^5$，$1 \leq a_i \leq 10^9$

很容易可以想到莫队。

由于 $a_i$ 高达 $10^9$，需要离散化。

我原先的思路是建一棵平衡树把所有 $cnt_i$ 插入进去。不过这样插入删除是 $\mathcal O(logn)$ 的。再加上总共插入 $n \sqrt n$ 次，复杂度会高达 $\mathcal O(n \sqrt n \log n)$，除非像 [$\color{black}\texttt{A}\color{red}\texttt{lex\_Wei}$](https://www.luogu.com.cn/user/123294) 神犇一样有高超的卡常本领，不然是无法过去的。

不难发现虽然插入高达 $n \sqrt n$ 次，但是查询答案只有 $m$ 次，我们可不可以分担一些复杂度在查询上呢？

我们假设 $cnt'_i$ 表示 $cnt_j=i$ 的 $j$ 的个数。

每次扩大或者缩小一个区间可以 $\mathcal O(1)$ 修改 $cnt$ 和 $cnt'$。

但是如果暴力查询的话还是 $\mathcal O(n)$ 的。配合上 $m$ 次询问还是会 $\texttt{TLE}$。

考虑朴素的查询：如果 $k \leq cnt'_1$，就返回 $1$，否则，将 $k$ 减去 $cnt'_1$，继续看 $cnt'_2$：如果 $k \leq cnt'_2$，就返回 $2$，否则将 $k$ 减去 $cnt'_2$，继续看 $cnt'_3$，以此类推。

在上面的步骤中，我们是一个一个往右跳的，显然会超时。但是我们可以考虑分成若干个块，记录每个块中 $cnt'_i$ 的和，这个修改的时候也是 $\mathcal O(1)$ 的然后按照上面的步骤一块一块地找出答案所在的块，再在对应的块中寻找。假设块的大小为 $X$，那么这一部分复杂度是 $X+\frac{n}{X}$，当 $X=\sqrt n$ 的时候最优。这样就可以过了。

时间复杂度 $\mathcal O(n \sqrt n+m \sqrt n)$

代码（常数有点大，因此开了 O2 优化）：

```cpp
//Coded by tzc_wk
/*
数据不清空，爆零两行泪。
多测不读完，爆零两行泪。
边界不特判，爆零两行泪。
贪心不证明，爆零两行泪。
D P 顺序错，爆零两行泪。
大小少等号，爆零两行泪。
变量不统一，爆零两行泪。
越界不判断，爆零两行泪。
调试不注释，爆零两行泪。
溢出不 l l，爆零两行泪。
*/
#include <bits/stdc++.h>
using namespace std;
#define fi			first
#define se			second
#define fz(i,a,b)	for(int i=a;i<=b;i++)
#define fd(i,a,b)	for(int i=a;i>=b;i--)
#define foreach(it,v) for(__typeof(v.begin()) it=v.begin();it!=v.end();it++)
#define all(a)		a.begin(),a.end()
#define giveup(...) return printf(__VA_ARGS__),0;
#define fill0(a)	memset(a,0,sizeof(a))
#define fill1(a)	memset(a,-1,sizeof(a))
#define fillbig(a)	memset(a,0x3f,sizeof(a))
#define fillsmall(a) memset(a,0xcf,sizeof(a))
#define mask(a)		(1ll<<(a))
#define maskx(a,x)	((a)<<(x))
#define _bit(a,x)	(((a)>>(x))&1)
#define _sz(a)		((int)(a).size())
#define filei(a)	freopen(a,"r",stdin);
#define fileo(a)	freopen(a,"w",stdout);
#define fileio(a) 	freopen(a".in","r",stdin);freopen(a".out","w",stdout)
#define eprintf(...) fprintf(stderr,__VA_ARGS__)
#define put(x)		putchar(x)
#define eoln        put('\n')
#define space		put(' ')
#define y1			y_chenxiaoyan_1
#define y0			y_chenxiaoyan_0
typedef pair<int,int> pii;
inline int read(){
	int x=0,neg=1;char c=getchar();
	while(!isdigit(c)){
		if(c=='-')	neg=-1;
		c=getchar();
	}
	while(isdigit(c))	x=x*10+c-'0',c=getchar();
	return x*neg;
}
inline void print(int x){
	if(x<0){
		putchar('-');
		print(abs(x));
		return;
	}
	if(x<=9)	putchar(x+'0');
	else{
		print(x/10);
		putchar(x%10+'0');
	}
}
inline int qpow(int x,int e,int _MOD){
	int ans=1;
	while(e){
		if(e&1)	ans=ans*x%_MOD;
		x=x*x%_MOD;
		e>>=1;
	}
	return ans;
}
int n=read(),m=read(),a[100005];
const int BLOCK_SZ=320;
int blk,L[100005],R[100005],bel[100005];
int cnt[100005],cnt_cnt[100005],cnt_cnt_blk[100005],ans[100005],key[100005],hs[100005],cntt=0;
struct query{
	int l,r,k,id;
	friend bool operator <(query a,query b){
		if(bel[a.l]!=bel[b.l])	return bel[a.l]<bel[b.l];
		else if(bel[a.l]^1)		return a.r<b.r;
		else					return a.r>b.r;
	}
} q[100005];
inline void push(int x){
	if(cnt[a[x]]){
		cnt_cnt[cnt[a[x]]]--;
		cnt_cnt_blk[bel[cnt[a[x]]]]--;
	}
	cnt[a[x]]++;
	cnt_cnt[cnt[a[x]]]++;
	cnt_cnt_blk[bel[cnt[a[x]]]]++;
}
inline void pop(int x){
	cnt_cnt[cnt[a[x]]]--;
	cnt_cnt_blk[bel[cnt[a[x]]]]--;
	cnt[a[x]]--;
	if(cnt[a[x]]){
		cnt_cnt[cnt[a[x]]]++;
		cnt_cnt_blk[bel[cnt[a[x]]]]++;
	}
}
inline int deal(int k){
	int i=1;
	for(;i<=blk;i++){
		if(k<=cnt_cnt_blk[i])	break;
		k-=cnt_cnt_blk[i];
	}
//	cout<<"k="<<k<<endl;
	for(int j=L[i];j<=R[i];j++){
		if(k<=cnt_cnt[j])	return j;
		k-=cnt_cnt[j];
	}
	return -1;
}
signed main(){
	blk=(n-1)/BLOCK_SZ+1;
	fz(i,1,n)	a[i]=read(),key[i]=a[i];
	sort(key+1,key+n+1);
	fz(i,1,n)	if(key[i]!=key[i-1])	hs[++cntt]=key[i];
	fz(i,1,n)	a[i]=lower_bound(hs+1,hs+cntt+1,a[i])-hs;
	fz(i,1,blk){
		L[i]=(i-1)*BLOCK_SZ+1;
		R[i]=min(i*BLOCK_SZ,n);
		fz(j,L[i],R[i])	bel[j]=i;
	}
	fz(i,1,m)	q[i].l=read(),q[i].r=read(),q[i].k=read(),q[i].id=i;
	sort(q+1,q+m+1);
	int l=1,r=0;
	fz(i,1,m){
//		cout<<q[i].l<<" "<<q[i].r<<" "<<q[i].k<<" "<<q[i].id<<endl;
		while(r<q[i].r)	push(++r);
		while(l>q[i].l)	push(--l);
		while(l<q[i].l)	pop(l++);
		while(r>q[i].r)	pop(r--);
//		fz(j,1,n)	cout<<cnt_cnt[j]<<" ";puts("");
//		cout<<cnt_cnt_blk[1]<<endl;
		ans[q[i].id]=deal(q[i].k);
	}
	fz(i,1,m)	cout<<ans[i]<<endl;
	return 0;
}
```

---

## 作者：happybob (赞：0)

## 题意

给定一个 $n$ 个数的序列 $a$，定义对于区间 $[l,r]$ 的 $c_i$ 表示 $a_l, a_{l+1}, \cdots, a_r$ 中 $i$ 的出现次数。多组询问，每组询问指定 $l, r, k$，求区间 $[l,r]$ 中 $c$ 序列中第 $k$ 小的值，区间中没有出现过的值不算入 $c$ 数组。数组 $c$ 不需要去重。

## 解法

区间第 $k$ 小第一想到的是主席树，然后出现次数套个莫队，但是这样并不好写，并且貌似过不去。

所以考虑莫队加值域分块，莫队需要记录信息如下：

- 某个数的出现次数

- 某个数的出现次数的出现次数

- 某个值域中 某个数的出现次数 有多少

- 区间不同数的个数

然后 $O(1)$ 加入删除，$O(\sqrt{n})$ 询问，总共复杂度 $O(n \times \sqrt{n})$，足以通过。

注意要离散化。

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <vector>
#include <set>
using namespace std;

const int N = 1e5 + 5;

int a[N], n, m, len, ans[N], cnt[N], cc[N], res = 0, cca[N];
vector<int> b;

inline int get(int x)
{
	if (x == 0) return 0;
	return (x - 1) / len + 1;
}

inline int lplace(int x)
{
	return (x - 1) * len + 1;
}

inline int rplace(int x)
{
	return lplace(x + 1) - 1;
}

struct Node
{
	int id, l, r, k;
	bool operator<(const Node& g) const
	{
		int i(get(l)), j(get(g.l));
		return (i ^ j ? i < j : (i & 1 ? r < g.r : r > g.r));
	}
}q[N];

inline void add(int x)
{
	cca[cnt[a[x]]]--;
	cc[get(cnt[a[x]])]--;
	if (++cnt[a[x]] == 1) res++;
	cc[get(cnt[a[x]])]++;
	cca[cnt[a[x]]]++;
}

inline void del(int x)
{
	cca[cnt[a[x]]]--;
	cc[get(cnt[a[x]])]--;
	if (--cnt[a[x]] == 0) res--;
	cc[get(cnt[a[x]])]++;
	cca[cnt[a[x]]]++;
}

inline int query(int p)
{
	if (res < p) return -1;
	int now = 0;
	for (int i = 1; i <= len; i++)
	{
		if (now + cc[i] < p)
		{
			now += cc[i];
			continue;
		}
		int r(rplace(i));
		for (int j = lplace(i); j <= r; j++)
		{
			now += cca[j];
			if (now >= p) return j;
		}
	}
}

int main()
{
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= n; i++)
	{
		scanf("%d", &a[i]);
		b.push_back(a[i]);
	}
	len = sqrt(n);
	sort(b.begin(), b.end());
	b.erase(unique(b.begin(), b.end()), b.end());
	for (int i = 1; i <= n; i++) a[i] = lower_bound(b.begin(), b.end(), a[i]) - b.begin() + 1;
	for (int i = 1; i <= m; i++)
	{
		scanf("%d%d%d", &q[i].l, &q[i].r, &q[i].k);
		q[i].id = i;
	}
	sort(q + 1, q + m + 1);
	int nl(1), nr(0);
	for (int i = 1; i <= m; i++)
	{
		int l(q[i].l), r(q[i].r);
		while (nl < l) del(nl++);
		while (nl > l) add(--nl);
		while (nr < r) add(++nr);
		while (nr > r) del(nr--);
		ans[q[i].id] = query(q[i].k);
	}
	for (int i = 1; i <= m; i++) printf("%d\n", ans[i]);
	return 0;
}
```


---


# [WC2013] 糖果公园

## 题目描述

Candyland 有一座糖果公园，公园里不仅有美丽的风景、好玩的游乐项目，还有许多免费糖果的发放点，这引来了许多贪吃的小朋友来糖果公园游玩。

糖果公园的结构十分奇特，它由 $n$ 个游览点构成，每个游览点都有一个糖果发放处，我们可以依次将游览点编号为 $1$ 至 $n$。有 $n - 1$ 条双向道路连接着这些游览点，并且整个糖果公园都是连通的，即从任何一个游览点出发都可以通过这些道路到达公园里的所有其它游览点。

糖果公园所发放的糖果种类非常丰富，总共有 $m$ 种，它们的编号依次为 $1$ 至 $m$。每一个糖果发放处都只发放某种特定的糖果，我们用 $C_i$ 来表示 $i$ 号游览点的糖果。

来到公园里游玩的游客都不喜欢走回头路，他们总是从某个特定的游览点出发前往另一个特定的游览点，并游览途中的景点，这条路线一定是唯一的。他们经过每个游览点，都可以品尝到一颗对应种类的糖果。

大家对不同类型糖果的喜爱程度都不尽相同。 根据游客们的反馈打分，我们得到了糖果的美味指数， 第 $i$ 种糖果的美味指数为 $V_i$。另外，如果一位游客反复地品尝同一种类的糖果，他肯定会觉得有一些腻。根据量化统计，我们得到了游客第 $i$ 次品尝某类糖果的新奇指数 $W_i$。如果一位游客第 $i$ 次品尝第 $j$ 种糖果，那么他的愉悦指数 $H$ 将会增加对应的美味指数与新奇指数的乘积，即 $V_j \times W_i$。这位游客游览公园的愉悦指数最终将是这些乘积的和。

当然，公园中每个糖果发放点所发放的糖果种类不一定是一成不变的。有时，一些糖果点所发放的糖果种类可能会更改（也只会是 $m$ 种中的一种），这样的目的是能够让游客们总是感受到惊喜。

糖果公园的工作人员小 A 接到了一个任务，那就是根据公园最近的数据统计出每位游客游玩公园的愉悦指数。但数学不好的小 A 一看到密密麻麻的数字就觉得头晕，作为小 A 最好的朋友，你决定帮他一把。


## 说明/提示

【样例解释】

我们分别用

![](https://cdn.luogu.com.cn/upload/image_hosting/isw3ib3u.png)

代表 $C_i$ 为 $1$、 $2$、 $3$ 的节点，在修改之前：

![](https://cdn.luogu.com.cn/upload/image_hosting/ttkzii1u.png)

在将 $C_2$ 修改为 $1$ 之后：

![](https://cdn.luogu.com.cn/upload/image_hosting/izro364w.png)

【数据规模与约定】

对于所有的数据： $1 \leq V_i, W_i \leq 10^6$，$1 \leq A_i, B_i \leq n$， $1 \leq C_i \leq m$， $W_1, W_2, \ldots, W_n$ 是非递增序列，即对任意 $1 < i \leq n$， 满足 $W_i \le W_{i-1}$。

其它的限制条件如下表所示：

![QQ20180113072014.png](https://cdn.luogu.com.cn/upload/image_hosting/g6884nx1.png)


## 样例 #1

### 输入

```
4 3 5
1 9 2
7 6 5 1
2 3
3 1
3 4
1 2 3 2
1 1 2
1 4 2
0 2 1
1 1 2
1 4 2```

### 输出

```
84
131
27
84```

# 题解

## 作者：Kelin (赞：38)

## [题意](https://blog.csdn.net/BeNoble_/article/details/79770456)

给你一棵树,每个点有个颜色

每次询问你一条路径求$\sum_{c}val_c\sum_{i=1}^{cnt_c}worth_i$

>$val$表示该颜色的价值,$cnt$表示其出现的次数,$woeth_i$表示第$i$次出现的价值

带修改

---

## 题解

先求出$dfs$序把树变成序列

考虑向右扩展一个点,这个贡献我们是可以$O(1)$算出来的

>假设扩展出的点是的颜色是$c,$那么$\Delta=val_c\times worth_{cnt_{c+1}}$

所以可以考虑用带修改~~树上~~莫队来求

但是直接用$dfs$序去扩展的话显然会出问题

因为他会先去扫完起点的子树,产生多余的贡献

考虑怎么去掉多余的贡献,把树变成一个长$2n$括号序列

这样的话扫的过程中起点的子树里的点肯定会被扫两次(一进一出)

连续做两次之后贡献为$0$,我们可以想到异或

>即开一个$vis$数组,每次访问就一个点$u$,就$vis_u$^$=1$

但是注意到几个问题

$1.$如果$lca$不是路径端点是不会被计算的

>考虑样例的括号序列$12443321$

>询问$4\to3$,那么我们得到的区间是$[3,5]$

>发现$2$没有被算进来,这个要特判

>当然如果起点就是$lca$就不需要管了

$2.$如果起点不是$lca$,那么他的贡献是不会被计算的

>同样是上面那个例子

>我们可以看到$4$的贡献被算两次抵消掉了

>所以这种情况也要特判

修改和普通带修改莫队一样,只要加一维时间即可

```
#include<bits/stdc++.h>
#define fp(i,a,b) for(register int i=a,I=b+1;i<I;++i)
#define fd(i,a,b) for(register int i=a,I=b-1;i>I;--i)
#define go(u) for(register int i=fi[u],v=e[i].to;i;v=e[i=e[i].nx].to)
#define file(s) freopen(s".in","r",stdin),freopen(s".out","w",stdout)
template<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}
template<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}
using namespace std;
char ss[1<<17],*A=ss,*B=ss;
inline char gc(){return A==B&&(B=(A=ss)+fread(ss,1,1<<17,stdin),A==B)?-1:*A++;}
template<class T>inline void sd(T&x){
    char c;T y=1;while(c=gc(),(c<48||57<c)&&c!=-1)if(c==45)y=-1;x=c-48;
    while(c=gc(),47<c&&c<58)x=x*10+c-48;x*=y;
}
char sr[1<<21],z[20];int C=-1,Z;
inline void Ot(){fwrite(sr,1,C+1,stdout),C=-1;}
template<class T>inline void we(T x){
    if(C>1<<20)Ot();if(x<0)sr[++C]=45,x=-x;
    while(z[++Z]=x%10+48,x/=10);
    while(sr[++C]=z[Z],--Z);sr[++C]='\n';
}
const int N=2e5+5;
typedef int arr[N];
typedef long long ll;
struct Q{
    int l,r,x,y,z,id;
    inline bool operator<(const Q b)const{
        if(x^b.x)return x<b.x;
        if(y^b.y)return x&1?y<b.y:y>b.y;
        return (x^y)&1?z<b.z:z>b.z;
    }
}q[N];
struct T{int x,c;}t[N];
struct eg{int nx,to;}e[N];
int n,m,ce,dft,Sz,Sq,St,L,R,G;arr fa,fi,sz,val,wor,pos,lis,dep,son,top,col,vis,cnt;ll Now,ans[N];
void dfs(int u){
    dep[u]=dep[fa[u]]+(sz[u]=1);
    go(u)if(v^fa[u]){
        fa[v]=u;dfs(v),sz[u]+=sz[v];
        if(sz[v]>sz[son[u]])son[u]=v;
    }
}
void dfs(int u,int t){
    top[u]=t;lis[pos[u]=++dft]=u;
    if(son[u])dfs(son[u],t);
    go(u)if(v^fa[u]&&v^son[u])dfs(v,v);
    lis[++dft]=u;
}
inline int lca(int u,int v){
    for(;top[u]^top[v];dep[top[u]]>dep[top[v]]?u=fa[top[u]]:v=fa[top[v]]);
    return dep[u]<dep[v]?u:v;
}
inline void add(int u,int v){e[++ce]={fi[u],v},fi[u]=ce;}
inline void sol(int x){int c=col[x];
    (vis[x]^=1)?Now+=(ll)wor[++cnt[c]]*val[c]:Now-=(ll)wor[cnt[c]--]*val[c];
}
inline void mdy(int i){
    int u=t[i].x,x=t[i].c,y=col[u];
    vis[u]?Now+=(ll)wor[++cnt[x]]*val[x]-(ll)wor[cnt[y]--]*val[y]:0;
    t[i].c=y,col[u]=x;
}
int main(){
    #ifndef ONLINE_JUDGE
        file("s");
    #endif
    sd(n),sd(m);int x,y,u,v,g=0;sd(x);
    fp(i,1,m)sd(val[i]);
    fp(i,1,n)sd(wor[i]);m=x;
    fp(i,2,n)sd(u),sd(v),add(u,v),add(v,u);
    fp(i,1,n)sd(col[i]);
    dfs(1),dfs(1,1);
    while(m--){
        sd(x);
        if(x){
            sd(x),sd(y);if(pos[x]>pos[y])swap(x,y);
            q[++Sq]={x,y,pos[x],pos[y],St,Sq};
        }else sd(x),sd(y),t[++St]={x,y};
    }Sz=pow(n,St?2.0/3:1.0/2);
    fp(i,1,Sq)q[i].x/=Sz,q[i].y/=Sz;
    sort(q+1,q+Sq+1);L=pos[q[1].l],R=L-1;
    fp(i,1,Sq){
        x=pos[u=q[i].l],y=pos[v=q[i].r],g=q[i].z;
        while(L>x)sol(lis[--L]);
        while(R<y)sol(lis[++R]);
        while(L<x)sol(lis[L++]);
        while(R>y)sol(lis[R--]);
        while(G<g)mdy(++G);
        while(G>g)mdy(G--);
        int p=lca(u,v);
        if(u^p){sol(u);if(v^p)sol(p);}
        ans[q[i].id]=Now;
        if(u^p){sol(u);if(v^p)sol(p);}
    }
    fp(i,1,Sq)we(ans[i]);
return Ot(),0;
}
```

---

## 作者：森森 (赞：35)

# 题解

------------
先捋一下[题意](https://www.luogu.com.cn/problem/P4074)。

给定一棵树，每次询问任意两点间的一条链上的相关信息，或修改任意一个点。

------------

没错，这道题可以用树上莫队（带修改）来做。

如果你还不了解莫队算法，请看下列例题。

 [P3901 数列找不同](https://www.luogu.com.cn/problem/P3901)

 [P1903 数颜色](https://www.luogu.com.cn/problem/P1903)

第二题的莫队带修改，就是本题的核心。

------------
莫队维护区间，所以先用欧拉序将树转化为序列。

你会发现两点间的路径便是此序列的这两点在欧拉序对应位置的区间。

但此区间有些节点可能会出现两次，这样的点不算在区间内。

以上情况是其中一点是另一点的父亲或父亲的父亲或父亲的父亲的父亲...（其实就是祖先）。

而如果他们有公共祖先，那么这个公共祖先需要额外计算，所以要用到 lca 来求。

 [P3379 最近公共祖先（LCA）](https://www.luogu.com.cn/problem/P3379)

其他的就是正常的莫队和修改啦。

 以下就是本  蒟蒻  的代码。

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int maxn=1e5+5;
int n,m,q,uu,vv,c[maxn],opt,l=0,r=0,tt=0;
ll v[maxn],w[maxn],ans[maxn],sum;
struct node{
	int to,next;
}e[maxn*2];
int tot,head[maxn*2];
void add(int u,int v)
{
	e[++tot].to=v;
	e[tot].next=head[u];
	head[u]=tot;
}
int in[maxn],out[maxn],kk;
int back[maxn*2],deep[maxn],f[maxn];
int fa[maxn][21],vis[maxn];
void dfs(int u,int ff)
{
	f[u]=ff;
	in[u]=++kk;back[kk]=u;
	for(int i=head[u];i;i=e[i].next)
	{
		int v=e[i].to;
		if(v==ff) continue;
		dfs(v,u);
	}
	out[u]=++kk;back[kk]=u;
}
void dfslca(int u)
{
	vis[u]=1;
	for(int i=1;(1<<i)<=deep[u];i++)
	{
		fa[u][i]=fa[fa[u][i-1]][i-1];
	}
	for(int i=head[u];i;i=e[i].next)
	{
		int v=e[i].to;
		if(vis[v]) continue;
		deep[v]=deep[u]+1;
		dfslca(v);
	}
}
int bl,t[maxn],flag[maxn],qq,rr;
struct ques{
	int u,v,lca,l,r,id,t;
}qu[maxn];
struct point{
	int pos,candy;
}re[maxn];
bool cmp(ques a,ques b)
{
	if(a.l/bl==b.l/bl)
	{
		if(a.r/bl==b.r/bl) return a.t<b.t;
		return a.r<b.r;
	}
	return a.l/bl<b.l/bl;
}
int LCA(int x,int y)
{
	if(deep[x]<deep[y])
	swap(x,y);
	int h=deep[x]-deep[y];
	for(int i=0;(1<<i)<=h;i++)
	{
		if((1<<i)&h) x=fa[x][i];
	}
	if(x==y) return x;
	for(int i=20;i>=0;i--)
	{
		if(fa[x][i]!=fa[y][i])
		{
			x=fa[x][i];
			y=fa[y][i];
		}
	}
	return fa[x][0];
}
void change(int x)
{
	if(flag[re[x].pos]==1)
	{
		t[c[re[x].pos]]--;
		sum-=w[t[c[re[x].pos]]+1]*v[c[re[x].pos]];
		t[re[x].candy]++;
		sum+=w[t[re[x].candy]]*v[re[x].candy];
	}
	swap(re[x].candy,c[re[x].pos]);
}

int main()
{
	scanf("%d%d%d",&n,&m,&q);
	for(int i=1;i<=m;i++) scanf("%lld",&v[i]);
	for(int i=1;i<=n;i++) scanf("%lld",&w[i]);
	for(int i=1;i<=n-1;i++)
	{
		scanf("%d%d",&uu,&vv);
		add(uu,vv);
		add(vv,uu);
	}
	for(int i=1;i<=n;i++) scanf("%d",&c[i]);
	dfs(1,1);//欧拉序
	for(int i=1;i<=n;i++) fa[i][0]=f[i];
	dfslca(1);
	bl=sqrt(2*n);
	for(int i=1;i<=q;i++)
	{
		scanf("%d",&opt);
		scanf("%d%d",&uu,&vv);
		if(opt==0)//单点修改 
		{
			re[++rr].pos=uu;
			re[rr].candy=vv;
		}
		if(opt==1)//链查询 
		{
			qu[++qq].lca=LCA(uu,vv);
			qu[qq].id=qq;
			qu[qq].t=rr;
			qu[qq].u=uu;qu[qq].v=vv;
			if(in[qu[qq].u]>in[qu[qq].v])
			swap(qu[qq].u,qu[qq].v);//欧拉序u在前
			if(qu[qq].lca==qu[qq].u)
			{
				qu[qq].l=in[qu[qq].u];
				qu[qq].r=in[qu[qq].v];
				qu[qq].lca=0;
			}
			else
			{
				qu[qq].l=out[qu[qq].u];
				qu[qq].r=in[qu[qq].v];
			}
		}
	}
	sort(qu+1,qu+qq+1,cmp);
	for(int i=1;i<=qq;i++)
	{
		while(l<qu[i].l)
		{
			flag[back[l]]--;
			if(flag[back[l]]==1) t[c[back[l]]]++;
			if(flag[back[l]]==0) t[c[back[l]]]--;
			if(flag[back[l]]==0)
			sum-=w[t[c[back[l]]]+1]*v[c[back[l]]];
			if(flag[back[l]]==1)
			sum+=w[t[c[back[l]]]]*v[c[back[l]]];
			l++;
		}
		while(l>qu[i].l)
		{
			flag[back[--l]]++;
			if(flag[back[l]]==1) t[c[back[l]]]++;
			if(flag[back[l]]==2) t[c[back[l]]]--;
			if(flag[back[l]]==2)
			sum-=w[t[c[back[l]]]+1]*v[c[back[l]]];
			if(flag[back[l]]==1)
			sum+=w[t[c[back[l]]]]*v[c[back[l]]];
		}
		while(r<qu[i].r)
		{
			flag[back[++r]]++;
			if(flag[back[r]]==1) t[c[back[r]]]++;
			if(flag[back[r]]==2) t[c[back[r]]]--;
			if(flag[back[r]]==2)
			sum-=w[t[c[back[r]]]+1]*v[c[back[r]]];
			if(flag[back[r]]==1)
			sum+=w[t[c[back[r]]]]*v[c[back[r]]];
		}
		while(r>qu[i].r)
		{
			flag[back[r]]--;
			if(flag[back[r]]==1) t[c[back[r]]]++;
			if(flag[back[r]]==0) t[c[back[r]]]--;
			if(flag[back[r]]==0)
			sum-=w[t[c[back[r]]]+1]*v[c[back[r]]];
			if(flag[back[r]]==1)
			sum+=w[t[c[back[r]]]]*v[c[back[r]]];
			r--;
		}
		while(tt<qu[i].t) change(++tt);
		while(tt>qu[i].t) change(tt--);
		if(qu[i].lca)
		{
			t[c[qu[i].lca]]++;
			sum+=w[t[c[qu[i].lca]]]*v[c[qu[i].lca]];
		}
		ans[qu[i].id]=sum;
		if(qu[i].lca)
		{
			t[c[qu[i].lca]]--;
			sum-=w[t[c[qu[i].lca]]+1]*v[c[qu[i].lca]];
		}
	}
	for(int i=1;i<=qq;i++)
	printf("%lld\n",ans[i]);
	return 0;
}
```
都看到这里了，能点个赞吗？谢谢资瓷。

---

## 作者：A1443356159 (赞：19)

# 树上带修莫队

## 树上莫队

以下都是针对一条链上的询问。

利用括号序或者欧拉序把树上莫队转化为普通莫队。

只呈现了转化询问的部分，省略了莫队的部分。

### 欧拉序实现

什么是欧拉序，就是这样。

``` cpp
void dfs(int u,int fa) {
	dfn[++lead]=u;
	++all[u];
    for(int i=head[u];i;i=e[i].nxt){
		int v=e[i].v;
        if(v==fa)continue;
    	dfs(v,u);
    	dfn[++lead]=u;
    	++all[u];
    }
    if(all[u]==1)dfn[++lead]=u,++all[u];
}
```

注意到 $lead$ 最终大小为点数+边数+叶子节点数，所以 $lead<3n$ 。

它的意义相当于绕着树的轮廓走了一圈。

![](https://cdn.luogu.com.cn/upload/image_hosting/fynvmwr0.png)

我们把 $u$ 最靠前的欧拉序记作 $in_u$ ，最靠后的记作 $out_u$ ，$in_u$~$out_u$ 这段区间称作 $u$ 的有关区间 $rang_u$。 

对于 $x$ 到 $y$ （$in_x<in_y$）的询问我们分三种情况讨论，

+ $rang_x$ 与 $rang_y$ 相离，询问区间为 $out_x$~$in_y$ 。
+ 相交，询问区间为 [$in_y$，$out_x$] 。
+ 包含，询问区间为 [$in_x$，$in_y$] 或者 [$out_y$，$out_x$] 。

如果一个点 $u$ 被区间包含了 $all_u$ 次，那就把它的贡献删除。

具体原因考虑观察欧拉序图（？），一次 $u$ 到 $v$ 的询问相当于沿着上图黄色的边从 $u$ 走到 $v$ ，其中被黄边完全包含的点（等价于被询问区间包含了 $all_u$ 次）没有贡献答案，贡献答案的是被半包含的点。

## 括号序实现

什么是括号序，就是这样。

```cpp
void dfs(int u,int fa) {
    dfn[++lead]=u;
	for(int head[u];i;i=e[i].nxt) {
		int v=e[i].v;
        if(v==fa)continue;
		dfs(v,u);
    }
    dfn[++lead]=u;
}
```

$lead$ 最终大小为 $2n$，这种做法比欧拉序做法的常数小一点。

我们把 $u$ 靠前的括号序记作 $in_u$ ，靠后的记作 $out_u$ 。

对于询问 $x$ 到 $y$（$in_x<in_y$），分两种情况考虑，

+ $lca=x$，询问转化为 [$in_x$，$in_y$]。
+ $lca\ne x$，询问转化为[$out_x$，$in_y$]加上 $lca$ 。

如果一个点被区间被包含的两次，就删除它的贡献。

证明如下，

对于第一种情况

![](https://cdn.luogu.com.cn/upload/image_hosting/743it6s1.png)

若我们询问绿色的那条链，绿色的那坨每个点只被算了一次（只算了in的），黄色的那坨被算了两次，红色的那坨被算了零次。所以只有绿色的对答案有贡献。

第二种情况，

![](https://cdn.luogu.com.cn/upload/image_hosting/rt0so7y3.png)

我们询问5到7（粉色），若我们的询问为[$out_x$，$in_y$]，那么绿色的被算了一次（只算了out），蓝色部分也被算了一次（只算了in），红色的没算，黄色的算了两次。因为$lca$(点1) 的贡献没算，所以再加上他的贡献就行了。

## 带修莫队​

普通莫队是两个关键字，带修莫队再加一时间关键字，跑普通莫队即可。

要求单次修改可以快速执行。

复杂度分析（可能不严谨），设块的大小为 $S$ ，序列长度为 $n$ ，询问为 $q$ ， 修改次数为 $c$ ，观察一下cmp函数（排序的那个函数），

```cpp
bool cmp(Query p,Query q){	
	if(bel[p.l]==bel[q.l]) {
		if(bel[p.r]==bel[q.r])return p.t<q.t;
		else return p.r<q.r;
	}
	else return p.l<q.l;
}
```

对于 $t$（时间）指针，考虑  $l$  在同一个块里移动 $r$ 也在同一个块里移动时移动的次数，每个块（$l$，$r$ 都不换块）最坏移动 $c$ 次（在同一个块时单调移动的），共 $\frac{n^2}{S^2}$ 个块，总计移动  $\frac{n^2c}{S^2}$ 次。

对于 $l$ 指针，换块时单调移动，在同一个块里时单次最快 $S$ 次移动，共 $q$ 次，总计 $qS$。

对于 $r$ 指针，$l$ 在同一个块时单调移动，每个块最坏移动 $n$ 次，共 $\frac{n}{S}$ 个块，总计$\frac{n^2}{S}$ 次。

如果 $c,n$ 同阶，$S=n^{\frac{2}{3}}$ 时复杂度较好，为 $O(n^{\frac{5}{3}})$ 。

## 树上带修莫队

> I have a pen. I have an apple. Apple-pen!

**例题：P4074 [WC2013] 糖果公园**

信息用莫队很好维护，主要是要会树上莫队和带修莫队。

``` cpp
//括号序实现的
#include<stdio.h>
#include<algorithm>
#include<cmath>
#define LL long long
using namespace std;
const int N=2e5+5;
int read() {
	int x=0,f=1;char c=getchar();
	while(c>'9'||c<'0'){if(c=='-')f=-1;c=getchar();}
	while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}
	return x*f;
}
void swap(int &x,int &y){int t=x;x=y;y=t;}
struct Edge {
	int v,nxt;
}e[N];
int head[N],size;
void link(int u,int v) {
	e[++size].v=v;
	e[size].nxt=head[u];
	head[u]=size;
}
int n,m,q,V[N],col[N],W[N];

int lead,in[N],out[N],ref[N<<1],sze[N],son[N],top[N],dep[N],fa[N];
void dfs1(int u,int fa) {
	sze[u]=1;
	dep[u]=dep[fa]+1;
	for(int i=head[u];i;i=e[i].nxt) {
		int v=e[i].v;
		if(v==fa)continue;
		dfs1(v,u);
		sze[u]+=sze[v];
		if(sze[v]>sze[son[u]])son[u]=v;
	}
}
void dfs2(int u) {
	in[u]=++lead;
	ref[lead]=u;
	if(son[u]) {
		int v=son[u];
		fa[v]=u;
		top[v]=top[u];
		dfs2(v);
	}
	for(int i=head[u];i;i=e[i].nxt) {
		int v=e[i].v;
		if(!top[v]) {
			fa[v]=u;
			top[v]=v;
			dfs2(v);
		}
	}
	out[u]=++lead;
	ref[lead]=u;
}
int _lca(int x,int y) {
	int fx=top[x],fy=top[y];
	while(fx!=fy) {
		if(dep[fx]<dep[fy])swap(x,y),swap(fx,fy);
		x=fa[fx];fx=top[x];
	}
	return dep[x]<dep[y]?x:y;
}

struct Query{
	int l,r,t,lca,i;
}Q[N];
int bel[N],block=3000;
LL ans[N],now;
bool cmp(Query p,Query q){
	if(bel[p.l]==bel[q.l]) {
		if(bel[p.r]==bel[q.r])return p.t<q.t;
		else return p.r<q.r;
	}
	else return p.l<q.l;
}
int pos[N],pre[N],then[N],cc[N],tot,ci[N],cnt[N];
void add(int x){
	if(ci[x]==1) {
		now-=1ll*W[cnt[col[x]]]*V[col[x]];
		--cnt[col[x]];
	}
	else {
		++cnt[col[x]];
		now+=1ll*W[cnt[col[x]]]*V[col[x]];
	}
	++ci[x];
}
void del(int x) {
	if(ci[x]==2) {
		++cnt[col[x]];
		now+=1ll*W[cnt[col[x]]]*V[col[x]];
	}
	else {
		now-=1ll*W[cnt[col[x]]]*V[col[x]];
		--cnt[col[x]];
	}
	--ci[x];
}
int main() {
	n=read();m=read();q=read();
	for(int i=1;i<=m;++i)V[i]=read();//每种颜色的价值 
	for(int i=1;i<=n;++i)W[i]=read();//腻值 
	for(int i=1;i<n;++i) {
		int u=read(),v=read();
		link(u,v);
		link(v,u);
	}
	dfs1(1,0);
	top[1]=1;dfs2(1);
	for(int i=1;i<=n;++i)cc[i]=col[i]=read();
	int T=0;
	for(int i=1;i<=q;++i) {
		int Type=read(),x=read(),y=read();
		if(Type==1) {
			int lca=_lca(x,y);
			Q[++tot].t=T;
			Q[tot].i=tot; 
			if(in[x]>in[y])swap(x,y);//x在上 
			if(lca==x) {
				Q[tot].l=in[x];
				Q[tot].r=in[y];
			}
			else {
				Q[tot].l=out[x];
				Q[tot].r=in[y];
				Q[tot].lca=lca;
			}
		}
		else {
			++T;
			pos[T]=x;
			pre[T]=cc[x];
			cc[x]=then[T]=y;
		}
	}
	for(int i=1;i<=2*n;++i)bel[i]=(i-1)/block+1;
	sort(Q+1,Q+tot+1,cmp);
	int l=1,r=0,t=0;
	for(int i=1;i<=tot;++i){
		int ql=Q[i].l,qr=Q[i].r,qt=Q[i].t;
		while(t>qt) {
			if(ci[pos[t]]&1) {//要修改的位置只被计算了一次，修改才会对答案产生影响。
				del(pos[t]);
				col[pos[t]]=pre[t];
				add(pos[t]);
			}
			else col[pos[t]]=pre[t];
			--t;
		}
		while(t<qt) {
			++t;
			if(ci[pos[t]]&1){
				del(pos[t]);
				col[pos[t]]=then[t];
				add(pos[t]);
			}
			else col[pos[t]]=then[t];
		}		
		while(l>ql)add(ref[--l]);
		while(r<qr)add(ref[++r]);
		while(l<ql)del(ref[l++]);
		while(r>qr)del(ref[r--]);
		ans[Q[i].i]=now;
		if(Q[i].lca)//把lca的贡献加进去 
			ans[Q[i].i]+=1ll*W[cnt[col[Q[i].lca]]+1]*V[col[Q[i].lca]];
	}
	for(int i=1;i<=tot;++i)printf("%lld\n",ans[i]);
	return 0;
}
```



---

## 作者：NaCly_Fish (赞：19)

来一发直接在树上暴力分块的题解！  


看到题解里各位大佬写的什么括号序列，可是蒟蒻表示根本不会啊 QAQ  
于是我写了一篇在树上分块的题解

还记得当时是怎么让莫队优化区间修改+查询问题的吗？就是分块+排序。现在问题跑到了树上，怎么分块呢？  

我们可以考虑这样来分块：  
从任意节点作为根，开始 $\text{dfs}$，每经过一个点就把它压进栈里。  

当一个节点到栈顶的长度大于分块大小时，就把的这部分的点全部弹出，并分为一块。  
对于最后剩下来的点，单独再分一块。  

具体是什么样的呢？这里借用了一张图来解释：    
![](https://cdn.luogu.com.cn/upload/pic/47657.png)  

此处块的大小为$3$，按照我们刚才说的方法，以顶端那个节点为根，就分成了这样。  

具体代码实现如下：  
```cpp
void dfs(int u,int fa){
    int bottom = top; //top是一个全局变量,初始为0
    stack[++top] = u; //当前节点入栈
    int v,l = adj[u].size();
    for(int i=0;i<l;++i){
        v = adj[u][i];
        if(v==fa) continue;
        dfs(v,u);
        if(top-bottom>block){//栈顶到当前节点的长度大于分块大小
            ++idx;
            while(top!=bottom) be[stack[top--]] = idx; //弹出这部分元素,分为一块(be[i]表示i节点属于哪一块)
        }
    }
}
```  
分块的问题解决了，排序又该怎么办？ 

跟普通序列上的莫队方法差不多：  
以两端节点 **所属的块** 为第一、二关键字，以时间为第三关键字排序。  
```cpp
bool cmp(query a,query b){
	//u,v是询问路径的两端节点
    if(be[a.u]==be[b.u]){
        if(be[a.v]==be[b.v]) return a.t<b.t;
        return be[a.v]<be[b.v];
    }
    return be[a.u]<be[b.u];
}
```  
最后，也是最难搞的问题：区间移动。   
乍一看好像没什么难的，~~实际上也没什么难的。~~  

一个节点要从 $u$ 移到 $v$ 的话，让它们不断地向上跳，直到跳到一起。这样做等价于一个点移到另一个点。  

跳的过程中，用一个数组 $\text{vis}$ 表示该节点在不在查询的路径上。    
每到一个点，如果以前在路径上，那现在肯定就不在了；反之亦然。  
随着这样不断地更新经过的节点就完成了区间移动。  

结果你发现，如果移动节点时，要跨过 $\text{lca}(u,v)$ 的话，还是会有问题，如下图：  

![](https://cdn.luogu.com.cn/upload/pic/47666.png)

当我们按上述步骤把 $u$ 移到 $u'$，$v$ 移到 $v'$时，我们发现：  
$\text{lca}(u,v)$ 和 $\text{lca}(u',v')$，也就是被圈红的那两个点都被标记了两次，也就是说标记状态没有改变。  

那这好办，最后再更新一下这两个节点，轻松解决问题。 

对于更新操作，可以维护一个数组 $\text{num}$，记录路径上各种糖果有多少个。当路径上增/减第 $i$
种糖果时，对结果的贡献是 $\text{w}[\text{num}[i]]\times\text{v}[i]$，随便推一下就出来了。

最后，确定分块的 $\text{dfs}$ 可以和求 $\text{lca}$ 的预处理写在一起，减少码量。

时间复杂度 $\text O (n^\frac53)$

代码如下：  
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
#include<cmath>
#include<queue>
#include<vector>
#define N 100003
#define reg register
#define ll long long
using namespace std;

struct query{
    int u,v,t,id;
    query(int u=0,int v=0,int t=0,int id=0):u(u),v(v),t(t),id(id){}
};

struct change{
    int u,last,next;
    change(int u=0,int last=0,int next=0):u(u),last(last),next(next){}
};

query q[N];
change c[N];
int val[N],w[N],fa[N],depth[N],son[N],stack[N];
int sub[N],top[N],be[N],clr[N],sum[N];
bool vis[N];
int n,m,T,tp,block,idx;
ll res;
ll ans[N];
vector<int> adj[N];

inline void swap(int &aa,int &bb){
	aa ^= bb;
	bb ^= aa;
	aa ^= bb;
}

inline void read(int &x){
    x = 0;
    char c = getchar();
    while(c<'0'||c>'9') c = getchar();
    while(c>='0'&&c<='9'){
        x = (x<<3)+(x<<1)+(c^48);
        c = getchar();
    }
}

void print(ll x){
    if(x>9) print(x/10);
    putchar(x%10+'0');
}

void dfs1(int u,int f){
    int bt = tp;
    stack[++tp] = u;
    fa[u] = f;
    depth[u] = depth[f]+1;
    sub[u] = 1;
    int v,t = -1,l = adj[u].size();
    for(int i=0;i<l;++i){
        v = adj[u][i];
        if(v==f) continue;
        dfs1(v,u);
        if(tp-bt>block){
            ++idx;
            while(tp!=bt) be[stack[tp--]] = idx;
        }
        sub[u] += sub[v];
        if(sub[v]>t){
            t = sub[v];
            son[u] = v;
        }
    }
}

void dfs2(int u,int f){
    top[u] = f;
    if(son[u]==0) return;
    dfs2(son[u],f);
    int v,l = adj[u].size();
    for(int i=0;i<l;++i){
        v = adj[u][i];
        if(v==fa[u]||v==son[u]) continue;
        dfs2(v,v);
    }
}

inline int lca(int u,int v){
    while(top[u]!=top[v]){
        if(depth[top[u]]<depth[top[v]])
            swap(u,v);
        u = fa[top[u]];    
    }
    if(depth[u]<depth[v]) return u;
    return v;
}

inline bool cmp(query a,query b){
    if(be[a.u]==be[b.u]){
        if(be[a.v]==be[b.v]) return a.t<b.t;
        return be[a.v]<be[b.v];
    }
    return be[a.u]<be[b.u];
}

inline void add(int u){
    ++sum[u];
    res += (ll)w[sum[u]]*val[u];
}

inline void del(int u){
    res -= (ll)w[sum[u]]*val[u];
    --sum[u];
}

inline void update(int u){
    if(vis[u]) del(clr[u]),vis[u] = false;
    else add(clr[u]),vis[u] = true;
}

inline void modify(int u,int t){
    if(vis[u]){
        del(clr[u]);
        add(t);
    }
    clr[u] = t;
}

void move(int u,int v){
    if(depth[u]<depth[v]) swap(u,v);
    while(depth[u]>depth[v]){
        update(u);
        u = fa[u];
    }
    while(u!=v){
        update(u),update(v);
        u = fa[u],v = fa[v];
    }
}

int main(){
    int op,t,qc,u,v;
    read(n),read(m),read(T);
    block = pow(n,2.0/3);
    for(reg int i=1;i<=m;++i) read(val[i]);
    for(reg int i=1;i<=n;++i) read(w[i]);
    for(reg int i=1;i<n;++i){
        read(u),read(v);
        adj[u].push_back(v);
        adj[v].push_back(u);
    }
    for(reg int i=1;i<=n;++i){
        read(clr[i]);
        stack[i] = clr[i];
    }
    t = qc = 0;
    for(reg int i=1;i<=T;++i){
        read(op),read(u),read(v);
        if(op==0){
            c[++t] = change(u,stack[u],v);
            stack[u] = v;
        }else{
            ++qc;
            q[qc] = query(u,v,t,qc);
        }
    }
    memset(stack,0,sizeof(stack));
    dfs1(1,0);
    dfs2(1,1);
    while(tp>0) be[stack[tp--]] = idx;
    sort(q+1,q+1+qc,cmp);
    t = 0; 
    u = v = 1;
    update(1);
    for(int i=1;i<=qc;++i){
        while(t<q[i].t) modify(c[t+1].u,c[t+1].next),++t;
        while(t>q[i].t) modify(c[t].u,c[t].last),--t;
        update(lca(u,v));
        if(u!=q[i].u) move(u,q[i].u),u = q[i].u;
        if(v!=q[i].v) move(v,q[i].v),v = q[i].v;
        update(lca(u,v));
        ans[q[i].id] = res;
    }
    for(int i=1;i<=qc;++i){
        print(ans[i]);
        putchar('\n');
    }
    return 0;
}
```

---

## 作者：Great_Influence (赞：11)

## [WC2013]糖果公园(树上待修莫队)

可谓莫队题之集大成者。基本上所有的难点都囊括了。

莫队和带修莫队都没什么意思，重点讲一下树上莫队。

### 引入:[SCOI2005]王室联邦

这道题目没什么意思，一顿乱搜都可以过去。重点是按这道题目的方法，可以将树分得十分均匀。这样就可以引入分块了。如果$B=\sqrt n$，那么块的分布将会十分均匀。下面给出一种分块方法。

```cpp
static int sta[MAXN],tp,blk_cnt,bel[MAXN],pr[MAXN];
//辅助用的栈,栈元素个数，分块数，每个点所属块编号，每个块的省会(仅本题有用)
void dfs(int u,int fa=0)
{
    int sz=tp;
    for(auto v:p[u])if(v^fa)
    {
        dfs(v,u);
        if(tp-sz>=B)//一般=sqrt(n)
        {
            pr[++blk_cnt]=u;
            while(tp>sz)bel[sta[tp--]]=blk_cnt;
        }
    }
    sta[++tp]=u;
}
```

### 正文

利用引入中的分块方法，可以将点均匀分成$\sqrt n$块。之后就和正常莫队区别不大了。第一维按照所属块排序，第二维按照dfn排序。然后就暴力修改即可。
记得带修莫队为了将时间复杂度摊匀分的块大小变为$n^\frac{2}{3}$，这样才能保证复杂度正确。总时间复杂度$O(n^\frac{5}{3})$。

代码:

```cpp
#include<bits/stdc++.h>
#define For(i,a,b) for(i=(a);i<=(b);++i)
#define Forward(i,a,b) for(i=(a);i>=(b);--i)
#define Rep(i,a,b) for(register int i=(a);i<=(b);++i)
#define Repe(i,a,b) for(register int i=(a);i>=(b);--i)
using namespace std;
template<typename T>inline void read(T &x)
{
    T s=0,f=1;char k=getchar();
    while(!isdigit(k)&&(k^'-'))k=getchar();
    if(!isdigit(k)){f=-1;k=getchar();}
    while(isdigit(k)){s=s*10+(k^48);k=getchar();}
    x=s*f;
}

const int MAXN=1e5+7;

static int n,m,Q,B,V[MAXN],W[MAXN],C[MAXN],fa[MAXN],dep[MAXN];

static vector<int>p[MAXN];

static int sta[MAXN],tp,blk_cnt,bel[MAXN],dfn[MAXN],e;
void dfs(int u)
{
	int sz=tp;
	dep[u]=dep[fa[u]]+1;dfn[u]=++e;
	for(auto v:p[u])if(v^fa[u])
	{
		fa[v]=u;dfs(v);
		if(tp-sz>=B)
		{
			++blk_cnt;
			while(tp>sz)bel[sta[tp--]]=blk_cnt;
		}
	}
	sta[++tp]=u;
}

static struct quer
{
	int u,v,tm,id;
	friend bool operator<(quer a,quer b)
	{return bel[a.u]^bel[b.u]?bel[a.u]<bel[b.u]:dfn[a.v]<dfn[b.v];}
}q[MAXN];

static int t;

static int modi[MAXN][3];

inline void init()
{
	read(n);read(m);read(Q);B=pow(n,0.666666);
	Rep(i,1,m)read(V[i]);
	Rep(i,1,n)read(W[i]);
	static int u,v;
	Rep(i,1,n-1)read(u),read(v),p[u].push_back(v),p[v].push_back(u);
	dfs(1);e=0;
	while(tp)bel[sta[tp--]]=blk_cnt;
	
	Rep(i,1,n)read(C[i]);
	
	static int opt;
	Rep(i,1,Q)
	{
		read(opt);read(u);read(v);
		if(!opt)modi[++e][0]=u,modi[e][1]=v,modi[e][2]=C[u],C[u]=v;
		else
		{
			if(dfn[u]<dfn[v])swap(u,v);
			q[++t].u=u;q[t].v=v;q[t].tm=e,q[t].id=t;
		}
	}
	sort(q+1,q+t+1);
}

static int cnt;

static int bar[MAXN],st[MAXN];

static long long ans[MAXN],as;

inline void insert(int pos)
{
	st[pos]^=1;
	if(st[pos])as+=(long long)W[++bar[C[pos]]]*V[C[pos]];
	else as-=(long long)W[bar[C[pos]]--]*V[C[pos]];
}

static int cross;

inline void goup(int&u)
{
	if(!cross)
	{
		if(st[u]&&!st[fa[u]])cross=u;
		else if(!st[u]&&st[fa[u]])cross=fa[u];
	}
	insert(u);u=fa[u];
}

inline void modiroad(int u,int v)
{
	if(u==v)return;
	cross=0;
	if(st[v])cross=v;
	if(dep[u]<dep[v])swap(u,v);
	while(dep[u]>dep[v])goup(u);
	while(u^v)goup(u),goup(v);
	insert(u);if(cross)insert(cross);
}

inline void solve()
{
	static int u,v;
	u=q[1].u;v=q[1].v;cnt=e;
	while(cnt>q[1].tm)C[modi[cnt][0]]=modi[cnt][2],--cnt;
	modiroad(u,v);ans[q[1].id]=as;
	Rep(i,2,t)
	{
		bool flag;
		while(cnt>q[i].tm)
		{
			flag=false;
			if(st[modi[cnt][0]])insert(modi[cnt][0]),flag=true;
			C[modi[cnt][0]]=modi[cnt][2];
			if(flag)insert(modi[cnt][0]);
			--cnt;
		}
		while(cnt<q[i].tm)
		{
			++cnt;
			flag=false;
			if(st[modi[cnt][0]])insert(modi[cnt][0]),flag=true;
			C[modi[cnt][0]]=modi[cnt][1];
			if(flag)insert(modi[cnt][0]);
		}
		modiroad(u,q[i].u);modiroad(v,q[i].v);u=q[i].u,v=q[i].v;
		ans[q[i].id]=as;
	}
	Rep(i,1,t)printf("%lld\n",ans[i]);
}

int main()
{
	init();
	solve();
	return 0;
}
```

代码量相对较大，推荐个个部分写成函数型，方便调用和$debug$。最好写几个$namespace$区分一下(偷懒没写结果调试半天)。

---

## 作者：Fido_Puppy (赞：10)

## Question

[P4074 [WC2013] 糖果公园](https://www.luogu.com.cn/problem/P4074)

## Solution

树上带修莫队。

[莫队算法——从入门到黑题](https://www.cnblogs.com/WAMonster/p/10118934.html)

这篇博客里写的还是很清楚的。

LCA 不会的看这里：

- [倍增求 LCA](https://www.cnblogs.com/lbssxz/p/11114819.html)

- [树剖求 LCA](https://www.cnblogs.com/cangT-Tlan/p/8846408.html)

## Notice

我们先来观察一下数据范围。

就会发现一个真谛：**十年 OI 一场空，不开 long long 见祖宗。**

接着，我们再计算一下。

时间复杂度：$O(N^{\frac{5}{3}})$。

${10^5}^{\frac{5}{3}}=10^{\frac{25}{3}}=10^{\frac{1}{3}}\times10^8\approx2\times10^8$

而时限是 6 秒，看起来这不会 TLE。

但是很多 OIer 却在第 7 个点 TLE 了。

**???**

这是一个细节性的问题。

设求出来的欧拉序的长度为 ncnt，块的大小为 siz。

则 ```siz=sqrt(ncnt);```

而不是 ```siz=sqrt(n);```

```for(int i=1;i<=ncnt;i++) belong[i]=(i-1)/siz+1;```

而不是 ```for(int i=1;i<=n;i++) belong[i]=(i-1)/siz+1;```

我大概在这里卡了 2 个多小时（呜呜）。

## Code

```cpp
#pragma GCC target("sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native")
#include"cstdio"
#include"algorithm"
#include"cmath"
using namespace std;
#define N (int)(1e5+10)
#define isdigit(x) ((x)>='0'&&(x)<='9')

struct Q {
	int l,r,id,lca,time;
}q[N];
struct C {
	int x,y;
}c[N];
int dep[N],first[N],last[N],ord[N<<1];
int v[N],w[N],cnt[N],belong[N<<1],a[N],vis[N];
int n,t,m,Qnum=0,Cnum=0,siz,L=1,R=0,ncnt=0,nowtime=0,tot=0;
int father[N],top[N],Siz[N],hson[N];
long long now,ans[N];
int head[N];
struct node {
	int to,next;
}edge[N<<1];

inline void add(int x,int y) {
	edge[++tot].to=y;
	edge[tot].next=head[x];
	head[x]=tot;
}

static char buf[100000],*p1=buf,*p2=buf;
#define gc p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;
inline int read() {
	int res=0;
	char c=gc;
	while (!isdigit(c)) c=gc;
	while (isdigit(c)) res=(res<<1)+(res<<3)+(c^48),c=gc;
	return res;
}
void write(long long x) {
	static int sta[50],top=0;
	if (x<0) putchar('-'),x=-x;
	do {
		sta[top++]=x%10,x/=10;
	}while (x);
	while (top) putchar(sta[--top]+48);
	putchar('\n');
}

inline void dfs1(int u,int fa) {
	dep[u]=dep[fa]+1; ord[++ncnt]=u; first[u]=ncnt; father[u]=fa; Siz[u]=1;
	for(int i=head[u];i;i=edge[i].next) {
		int v=edge[i].to;
		if (v!=fa) {
			dfs1(v,u);
			Siz[u]+=Siz[v];
			if (Siz[v]>Siz[hson[u]]) hson[u]=v;
		}
	}
	ord[++ncnt]=u; last[u]=ncnt;
}

inline void dfs2(int u,int fa) {
	if (hson[u]) {
		top[hson[u]]=top[u];
		dfs2(hson[u],u);
		for(int i=head[u];i;i=edge[i].next) {
			int v=edge[i].to;
			if (v!=fa&&v!=hson[u]) {
				top[v]=v;
				dfs2(v,u);
			}
		}
	}
}

inline int LCA(int x,int y) {
	while (top[x]^top[y]) dep[top[x]]>dep[top[y]]? x=father[top[x]]:y=father[top[y]];
	return (dep[x]<dep[y]? x:y);
}

inline bool cmp(Q a,Q b) {
	return (belong[a.l]^belong[b.l])? belong[a.l]<belong[b.l]:((belong[a.r]^belong[b.r])? belong[a.r]<belong[b.r]:a.time<b.time);
}

inline void work(int pos) {
	if (vis[pos]) now-=1ll*v[a[pos]]*w[cnt[a[pos]]--];else now+=1ll*v[a[pos]]*w[++cnt[a[pos]]];
	vis[pos]^=1;
}

inline void modify(int pos) {
	if (vis[c[pos].x]) {
		work(c[pos].x);
		swap(c[pos].y,a[c[pos].x]);
		work(c[pos].x);
	}
	else swap(c[pos].y,a[c[pos].x]);
}

signed main() {
	n=read(); t=read(); m=read();
	for(int i=1;i<=t;i++) v[i]=read();
	for(int i=1;i<=n;i++) w[i]=read();
	for(int i=1;i<n;i++) {
		int x,y;
		x=read(); y=read();
		add(x,y); add(y,x);
	}
	dep[0]=0; dfs1(1,0); top[1]=1; dfs2(1,0);
	for(int i=1;i<=n;i++) a[i]=read();
	for(int i=1;i<=m;i++) {
		int x,y,type;
		type=read(); x=read(); y=read();
		if (type==1) {
			if (first[x]>first[y]) swap(x,y);
			int lca=LCA(x,y);
			if (x==lca) {
				q[++Qnum].l=first[x]; q[Qnum].r=first[y];
			}
			else {
				q[++Qnum].l=last[x]; q[Qnum].r=first[y]; q[Qnum].lca=lca;
			}
			q[Qnum].time=Cnum; q[Qnum].id=Qnum;
		}
		else {
			c[++Cnum].x=x; c[Cnum].y=y;
		}
	}
	siz=pow(ncnt,2.0/3.0); for(int i=1;i<=ncnt;i++) belong[i]=(i-1)/siz+1;
	sort(q+1,q+Qnum+1,cmp);
	for(int i=1;i<=Qnum;i++) {
		while (L<q[i].l) work(ord[L++]);
		while (L>q[i].l) work(ord[--L]);
		while (R<q[i].r) work(ord[++R]);
		while (R>q[i].r) work(ord[R--]);
		while (nowtime<q[i].time) modify(++nowtime);
		while (nowtime>q[i].time) modify(nowtime--);
		if (q[i].lca) work(q[i].lca);
		ans[q[i].id]=now;
		if (q[i].lca) work(q[i].lca);
	}
	for(int i=1;i<=Qnum;i++) write(ans[i]);
	return 0;
}
```

完结撒花！ **^.^**

---

## 作者：老K (赞：8)

[各类莫队的讲解](https://cnyali-lk.com/Mo-s-Algorithm/)

``` C++
/*
Author: CNYALI_LK
LANG: C++
PROG: luogu4074.cpp
Mail: cnyalilk@vip.qq.com
*/
#include<bits/stdc++.h>
#define debug(...) fprintf(stderr,__VA_ARGS__)
#define DEBUG printf("Passing [%s] in LINE %lld\n",__FUNCTION__,__LINE__)
#define Debug debug("Passing [%s] in LINE %lld\n",__FUNCTION__,__LINE__)
#define all(x) x.begin(),x.end()
using namespace std;
const double eps=1e-8;
const double pi=acos(-1.0);
typedef long long ll;
typedef pair<ll,ll> pii;
template<class T>ll chkmin(T &a,T b){return a>b?a=b,1:0;}
template<class T>ll chkmax(T &a,T b){return a<b?a=b,1:0;}
template<class T>T sqr(T a){return a*a;}
template<class T>T mmin(T a,T b){return a<b?a:b;}
template<class T>T mmax(T a,T b){return a>b?a:b;}
template<class T>T aabs(T a){return a<0?-a:a;}
#define min mmin
#define max mmax
#define abs aabs
ll read(){
    ll s=0,base=1;
    char c;
    while(!isdigit(c=getchar()))if(c=='-')base=-base;
    while(isdigit(c)){s=s*10+(c^48);c=getchar();}
    return s*base;
}
char WritellBuffer[1024];
template<class T>void write(T a,char end){
    ll cnt=0,fu=1;
    if(a<0){putchar('-');fu=-1;}
    do{WritellBuffer[++cnt]=fu*(a%10)+'0';a/=10;}while(a);
    while(cnt){putchar(WritellBuffer[cnt]);--cnt;}
    putchar(end);
}
ll in[102424],out[102424],is[204848],t,dep[102424];
ll to[233333],lst[204847],beg[102423],e;
ll fa[102424][20];
void dfs(ll x,ll f){
    fa[x][0]=f;
    dep[x]=dep[f]+1;
    for(ll i=1;i<20;++i)fa[x][i]=fa[fa[x][i-1]][i-1];
    is[in[x]=++t]=x;
    for(ll i=beg[x];i;i=lst[i])if(to[i]!=f){
        dfs(to[i],x);        
    }
    is[out[x]=++t]=x;
}
void add(ll u,ll v){
    to[++e]=v;
    lst[e]=beg[u];
    beg[u]=e;
/*------------------------*/
    to[++e]=u;
    lst[e]=beg[v];
    beg[v]=e;
}
ll block;
struct _ask{
    ll l,r,id,lb,_add,T,rb;
};
_ask ask[102424];
ll lca(ll u,ll v){
    if(dep[u]<dep[v])swap(u,v);
    for(ll i=19;~i;--i)if(dep[u]-(1<<i)>=dep[v]){
        u=fa[u][i];
    }
    for(ll i=19;~i;--i)if(fa[u][i]!=fa[v][i]){u=fa[u][i];v=fa[v][i];}
    if(u!=v){
        u=fa[u][0];v=fa[v][0];
    }
    return u;
}
ll cmp(_ask a,_ask b){return a.lb<b.lb||a.lb==b.lb&&a.rb<b.rb||a.lb==b.lb&&a.rb==b.rb&&a.T<b.T;}
ll _is[102424],cnt[102424],tot,ans[102424];
ll V[102424],w[102424],c[102424];
void ds(ll x){
    if(_is[x]){
        tot-=w[cnt[c[x]]]*V[c[x]];
        --cnt[c[x]];
    }
    else{
        tot+=w[++cnt[c[x]]]*V[c[x]];
    }
    _is[x]^=1;
}
ll cTo[102424],cFr[102424],pt[102424];
void rem(ll x){
    if(_is[pt[x]]){
        ds(pt[x]);
        c[pt[x]]=cFr[x];
        ds(pt[x]);
    }
    else
    c[pt[x]]=cFr[x];
}
void add(ll x){
    if(_is[pt[x]]){
        ds(pt[x]);
        c[pt[x]]=cTo[x];
        ds(pt[x]);
    }
    else
    c[pt[x]]=cTo[x];
}
int main(){
#ifdef cnyali_lk
    freopen("luogu4074.in","r",stdin);
    freopen("luogu4074.out","w",stdout);
#endif
    ll n=read(),m=read(),q=0,u,v,_q=read();
    for(ll i=1;i<=m;++i)V[i]=read();
    for(ll i=1;i<=n;++i)w[i]=read();
    for(ll i=1;i<n;++i){
        add(read(),read());
    }
    dfs(1,0);
// 	for(ll i=1;i<=t;++i)printf("%lld%c",is[i],i==t?'\n':',');
    block=(ll)ceil(pow(t,2./3));
    for(ll i=1;i<=n;++i)c[i]=read();
    ll T=0;
    for(ll i=1;i<=_q;++i){
        if(!read()){
            pt[++T]=read();
            cFr[T]=c[pt[T]];
            cTo[T]=read();
            c[pt[T]]=cTo[T];
        }
        else{
            ask[++q].id=q;
            ask[q].T=T;
            u=read();v=read();
            if(u==v){
                ask[q].lb=ask[q].rb=(ask[q].l=ask[q].r=in[u])/block;
                ask[q]._add=0;
            }
            else
            if(in[u]<in[v]&&out[v]<out[u]){
                ask[q].lb=(ask[q].l=in[u])/block;
                ask[q].rb=(ask[q].r=in[v])/block;
                ask[q]._add=0;
            }
            else if(in[u]>in[v]&&out[v]>out[u]){
                ask[q].lb=(ask[q].l=in[v])/block;
                ask[q].rb=(ask[q].r=in[u])/block;
                ask[q]._add=0;
            }
            else{
                if(out[u]>in[v]){
                    swap(u,v);
                }
                ask[q].lb=(ask[q].l=out[u])/block;
                ask[q].rb=(ask[q].r=in[v])/block;
                ask[q]._add=lca(u,v);
            }
        }
    }
//	for(ll i=1;i<=q;++i)printf("%lld %lld %lld %lld\n",ask[i].l,ask[i].r,ask[i].T,ask[i]._add);
    sort(ask+1,ask+q+1,cmp);
    ll l=1,r=t;
    for(ll i=1;i<=q;++i){
        while(T>ask[i].T){	rem(T);--T;	}
        while(T<ask[i].T){	add(++T);	}
        while(l<ask[i].l){
            ds(is[l]);
            ++l;
        }
        while(l>ask[i].l){
            ds(is[--l]);
        }
        while(r>ask[i].r){
            ds(is[r]);
            --r;
        }
        while(r<ask[i].r){
            ds(is[++r]);
        }
        if(ask[i]._add)ds(ask[i]._add);
        ans[ask[i].id]=tot;
        if(ask[i]._add)ds(ask[i]._add);
    }
    for(ll i=1;i<=q;++i)printf("%lld\n",ans[i]);
    return 0;
}
```



---

## 作者：Orion545 (赞：8)

### 广告

[蒟蒻的博客-莫队算法](http://www.cnblogs.com/dedicatus545/p/8503863.html)

涵盖各种莫队～欢迎各位菊苣前来批判一番

### 备注

这篇题解提供了一种比较直观的莫队转移，不需要新建树之类的～

### 正文

树上？？？？？

别扯了，树又不是序列.....

这是我看到树上莫队的第一想法

 

但是，我们考虑在树上询问不同颜色的个数的问题，发现这么多询问下来，重复的依然很多，莫队的“消除重复”思想依然可以实现

而且谁说树上不能序列化了？dfs序听了这话想打人......

 

先考虑对子树的询问：一棵树， 每个节点都有颜色， 每次问你一个子树中有多少不同的颜色

我们发现一棵子树在dfs序上一定是连续的

那我们把dfs序求出来，再做标准莫队的过程就没问题了 ，甚至可以带上修改

 

但是，树上提问可不止子树询问，我们遇到的更多是树上两点之间的路径的询问

但是这种时候一条路径在dfs序上可就不是连续的了

难道我们树剖？常数卡死人......

不急，我们来推导一下怎么转移吧

我们考虑这样一个树，图示是树的一部分（也就是这两个询问涉及的部分）

![奇怪的树的一部分](https://cdn.luogu.com.cn/upload/pic/15786.png )

我们当前处理出来的是询问(1,6)的答案，也就是这条黄色路径

我们下一个要求的是蓝色路径(2,4)的答案

这种情况下我们发现，其实每次增加的就是lca(1,2)到2，以及lca(4,6)到4的那些节点

同时lca(1,2)到1，以及lca(4,6)到6的路径上的节点要去掉

诶？

那岂不是可以求出两个lca，然后把这两对点路径上除了lca的点的状态都反过来就可以了？

 

别急这只是一种情况，但是这个结论，实际上是对的

我们说的多种情况，无非就是两个lca在树上的位置关系

而这一位置关系，实际上取决于两个询问的两端节点的lca的位置关系（有点绕，一定要看清楚）

而这个关系要么就是父亲-儿子，要么就是毫不相干

上面那种情况就是父亲-儿子，此时lca(1,2) and lca(4,6)中间的那些节点不会受到影响

而两个原lca如果相离的话，我们可以发现中间的那段节点被处理了两次，也就是反转再反转，实际上没有动

因此这个转移方式是合法的

 

还有一个问题：两条路径上的lca是否收到影响呢？

关于这一点，我们发现，lca(1,2)与lca(4.6)，在任何情况下都不应该被碰到，因此我们不能改变它们的状态

但是有一个点是需要注意的：就是新的询问两端的lca

这个点在前面的转移中会被反转掉，因此我们需要把它反转，统计答案，再转回去以免影响下一个询问

 

同样，这样做的时间效率，在每一块分sqrt(n)时，是在O(nsqrt(n))左右，带了修改也是O(n^(5/3))

这道题就是一个带修改的树上莫队模板咯

放一下代码：
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
#define ll long long
using namespace std;
inline ll read(){
    ll re=0,flag=1;char ch=getchar();
    while(ch>'9'||ch<'0'){
        if(ch=='-') flag=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9') re=(re<<1)+(re<<3)+ch-'0',ch=getchar();
    return re*flag;
}
struct edge{
    ll to,next;
}a[200010];
ll n,m,Q,first[100010],cntt,clk,block;
ll fa[100010],dep[100010],st[100010][20],dfn[100010];
ll v[100010],w[100010],x[100010];
inline void add(ll u,ll v){
    a[++cntt]=(edge){v,first[u]};first[u]=cntt;
    a[++cntt]=(edge){u,first[v]};first[v]=cntt;
}
void dfs(ll u,ll f){//dfs预处理dfn序
    ll i,v;
    fa[u]=st[u][0]=f;dep[u]=dep[f]+1;dfn[u]=++clk;
    for(i=first[u];~i;i=a[i].next){
        v=a[i].to;
        if(v==f) continue;
        dfs(v,u);
    }
}
void init(){
    for(ll i=1;i<=18;i++){
        for(ll j=1;j<=n;j++){
            st[j][i]=st[st[j][i-1]][i-1];
        }
    }
}
void _swap(ll &l,ll &r){l^=r;r^=l;l^=r;}
ll LCA(ll l,ll r){
    if(dep[l]>dep[r]) _swap(l,r);
    ll i;
    for(i=18;i>=0;i--) if(dep[st[r][i]]>=dep[l]) r=st[r][i];
    if(l==r) return l;
    for(i=18;i>=0;i--){
        if(st[l][i]!=st[r][i]){
            l=st[l][i];r=st[r][i];
        }
    }
    return fa[l];
}
ll curl,curr,curc,cntq,cntc,cnt[1000010];bool vis[100010];
ll ans[100010],tot;
struct query{//l,r就是询问的左右端点，c就是在第几次修改之后，i是它本来是第几个询问（输出用的）
    ll l,r,c,i;
}q[100010];
bool cmp(query l,query r){//自定义的排序
    if(dfn[l.l]/block!=dfn[r.l]/block) return dfn[l.l]/block<dfn[r.l]/block;
    else{
        if(dfn[l.r]/block!=dfn[r.r]/block) 
            return dfn[l.r]/block<dfn[r.r]/block;
        else return l.c<r.c;
    }
}
struct change{
    ll pos,to;
}c[100010];
void rev(ll i){//反转节点状态
    if(vis[i]) vis[i]=0,tot-=v[x[i]]*w[cnt[x[i]]],cnt[x[i]]--;
    else vis[i]=1,cnt[x[i]]++,tot+=v[x[i]]*w[cnt[x[i]]];
}
void change(ll i){
    if(!vis[c[i].pos]) _swap(c[i].to,x[c[i].pos]);
    else{
        rev(c[i].pos);
        _swap(c[i].to,x[c[i].pos]);
        rev(c[i].pos);
    }
}
int main(){
    memset(first,-1,sizeof(first));
    ll i,t1,t2,t3;
    n=read();m=read();Q=read();block=(ll)pow(n,0.60);
    for(i=1;i<=m;i++) v[i]=read(); 
    for(i=1;i<=n;i++) w[i]=read();
    for(i=1;i<n;i++){
        t1=read();t2=read();add(t1,t2);
    }
    for(i=1;i<=n;i++) x[i]=read();
    dfs(1,0);init();
    for(i=1;i<=Q;i++){
        t1=read();t2=read();t3=read();
        if(t1) q[++cntq].l=t2,q[cntq].r=t3,q[cntq].c=cntc,q[cntq].i=cntq;
        else c[++cntc].pos=t2,c[cntc].to=t3;
    }
    sort(q+1,q+cntq+1,cmp);
    
    //像常规莫队一样先把第一个节点处理了
    if(dfn[q[1].l]>dfn[q[1].r]) _swap(q[1].l,q[1].r);
    ll lca=LCA(q[1].l,q[1].r),l,r;curl=q[1].l;curr=q[1].r;
    l=curl;r=curr;
    while(l!=lca) rev(l),l=fa[l];
    while(r!=lca) rev(r),r=fa[r];
    while(curc<q[1].c) change(++curc);
    rev(lca);ans[q[1].i]=tot;rev(lca);
    
    for(i=2;i<=cntq;i++){
        if(dfn[q[i].l]>dfn[q[i].r]) _swap(q[i].l,q[i].r);
        lca=LCA(curr,q[i].r);l=curr;r=q[i].r;
        while(l!=lca) rev(l),l=fa[l];
        while(r!=lca) rev(r),r=fa[r];
        lca=LCA(curl,q[i].l);l=curl;r=q[i].l;
        while(l!=lca) rev(l),l=fa[l];
        while(r!=lca) rev(r),r=fa[r];
        while(curc>q[i].c) change(curc--);
        while(curc<q[i].c) change(++curc);
        lca=LCA(q[i].l,q[i].r);
        rev(lca);ans[q[i].i]=tot;rev(lca);//特殊处理lca
        curl=q[i].l;curr=q[i].r;
    }
    for(i=1;i<=cntq;i++) printf("%lld\n",ans[i]);
}
```

---

## 作者：澪lane (赞：4)

读完题面 就发现是一道莫队题

### 要上树 带修改

 那么这就是一道树上待修莫队的~~模板~~题了。可以说这是莫队的一道毕业题，揉和了几乎莫队的所有扩展算法
 
 
   
   ~~回滚莫队：我不配拥有名字~~
   
   ~~lxl 的各类毒瘤莫队除外~~
   
 
 为了在树上能够O(1)转移状态（使用莫队，我们需要一个方法把树上节点转移成一个序列
 
 树转序列，第一时间我们就想到了dfs序,我们记录下Dfs遍历到的点第一次和第二次的位置和时间，因为记录方式跟括号序列有着相似的地方，这样有两次出现的点会抵消掉。这样的使得区间遍历变得可行。
 
 在最初Dfs时就可以处理掉了
 
 ```cpp
inline void Dfs(Rint x){
    order[++cnt] = x; //dfs序 
    first[x] = cnt;	//第一次出现的时间 
    for(Rint i = head[x]; i + 1; i = nex[i]){  //邻接表遍历子树
        Rint y = to[i];
        if(y == fath[x][0])
            continue;
        fath[y][0] = x; // 记录父亲节点 
        dep[y] = dep[x]	+ 1; // 更新子节点深度 
        for(Rint j = 1; (1 << j) <= dep[y]; j++) // 倍增预处理 
            fath[y][j] = fath[fath[y][j-1]][j-1];
        Dfs(y);	
    }
    order[++cnt] = x;  
    last[x] = cnt;	//第二次出现的时间 
}
```

根据括号序列序的性质，对于u和v两个点，我们需要考虑两种情况，其中当lca(u,v)!=u且lca(u,v)!=v时，这时其实在序列中我们是找不到lca的，所以我们就需要特别的将lca进行加入处理，左边的访问边界也应该是点第二次出现的位置(实在无法理见下)，不然会抵消掉；而另一种情况则是u,v两点中有一点为另一点的祖先时，直接处理即可。

![](https://i.loli.net/2019/07/17/5d2f0df54da1127718.png)

我们要求的区间为[2,3]但实际上在dfs序中2~3中并不包括它们的lca节点1

另外，因为题目是带修的，所以要加上时间这一维度，其余的套模板就行啦！

细节见全代码：

```cpp
#include <bits/stdc++.h>

#define scf scanf
#define ptf printf

#define ll long long 
#define ull unsigned long long
#define Rint register int 

#define max(a,b) ((a) > (b) ? (a) : (b))
#define min(a,b) ((a) > (b) ? (b) : (a))

using namespace std;
const int N = 1e6+101;
int w_[N], v_[N];
int vis[N], pla[N], chg[N], cdy[N], num[N];
int cnt = 0, tot = 0, len;
int now_0 = 0, now_1 = 0;
ll ans[N], ans_ = 0;
int belong[N];
int fath[N][30], dep[N], first[N], last[N], order[N];
int head[N], to[N], nex[N];
struct Q{
    int l,r;
    int id;
    int lca,t;
}qt[N];
inline int read(){
    int x=0,f = 1;
    char ch = getchar();
    while(!isdigit(ch)){
        if(ch == '-')
            f = -1;
        ch = getchar();	
    }
    while(isdigit(ch)){
        x = (x << 1) + (x << 3) + (ch ^ 48);
        ch = getchar();
    }
    return x*f;
}
inline int cmp(Q x, Q y){ // 排序 
    return (belong[x.l] ^ belong[y.l]) ? belong[x.l] < belong[y.l] :((belong[x.r] ^ belong[y.r]) ? belong[x.r] < belong[y.r] : x.t < y.t);
}
inline void add_e(Rint u, Rint v){ //建边 
    to[++tot] = v;
    nex[tot] = head[u];
    head[u] = tot;
}
inline void Dfs(Rint x){ // dfs处理dfs序等 
    order[++cnt] = x; 
    first[x] = cnt;	
    for(Rint i = head[x]; i + 1; i = nex[i]){  
        Rint y = to[i];
        if(y == fath[x][0])
            continue;
        fath[y][0] = x; 
        dep[y] = dep[x]	+ 1;
        for(Rint j = 1; (1 << j) <= dep[y]; j++)
            fath[y][j] = fath[fath[y][j-1]][j-1];
        Dfs(y);	
    }
    order[++cnt] = x;  
    last[x] = cnt;	 
}
inline int Lca(Rint x, Rint y){ // 倍增求lca 
    if(dep[x] < dep[y])
        swap(x,y);
    for(Rint i = 20; i >= 0; i--){
    	if(dep[x] - (1 << i) >= dep[y])
            x = fath[x][i];
    	if(x == y)
        	return x;
    }   
    for(Rint i = 20; i >= 0; i--)
        if(fath[x][i] != fath[y][i])
            x = fath[x][i], y = fath[y][i];
    return fath[x][0];						
}
inline void add(Rint x){
    ans_ += (ll)v_[cdy[x]] * w_[++num[cdy[x]]];
}
inline void del(Rint x){
    ans_ -= (ll)v_[cdy[x]] * w_[num[cdy[x]]--];
}
inline void move(Rint x){ //	进行加/删点操作 
    vis[x] ? del(x) : add(x);
    vis[x] ^= 1; //标记是否来到过当前点 如果来过，那么这次访问操作一定是离开， 反之亦然 
}
inline void change(Rint x){ //带修 回到时间为tim这个状态 
    if(vis[pla[x]]){
        move(pla[x]);
        swap(cdy[pla[x]], chg[x]);
        move(pla[x]);
    }
    else
        swap(cdy[pla[x]], chg[x]); 
}
int main(){
    memset(head, -1, sizeof head);
    memset(dep, 0, sizeof dep);
    memset(vis, 0, sizeof vis);
    int n = read(), m = read(), q_num = read();
    for(Rint i = 1; i <= m; i++)
        v_[i] = read();
    for(Rint i = 1; i <= n; i++)
        w_[i] = read();
    for(Rint i = 1; i < n; i++){
        int u = read(), v = read();
        add_e(u, v), add_e(v, u);
    }
    for(Rint i = 1; i <= n ; i++)
        cdy[i] = read();
    dep[1] = 1;
    Dfs(1);	
    len = pow(cnt, 2.0 / 3.0); // 带修莫队分块大小 
    int part = ceil((double) cnt / len);
    for(Rint i = 1; i <= part; i++)
        for(Rint j = len * (i - 1) + 1; j <= i * len; j++) //处理区间查询的左右边界在块的位置 
            belong[j] = i;
    for(Rint i = 1; i <= q_num; i++){
        int type = read();
        if(type == 0){
            ++now_1;
            pla[now_1] = read();
            chg[now_1] = read(); 	
        }
        else if(type == 1){
            int l = read(), r = read(), lca = Lca(l, r);
            ++now_0;
            qt[now_0].id = now_0,qt[now_0].t = now_1;
            if(dep[l] > dep[r]) //保证 l的深度更浅 
                swap(l, r);
            if(l == lca)
                qt[now_0].l = first[l], qt[now_0].r = first[r]; // 情况 2 
            else
                qt[now_0].l = last[l], qt[now_0].r = first[r], qt[now_0].lca = lca; //情况 1 
        }
    }	
    sort(qt + 1,qt + now_0 + 1,cmp);
    int l = 1, r = 0, momt = 0;
    for(Rint i = 1; i <= now_0; i++){ // 莫队正常 
        int L = qt[i].l, R = qt[i].r, tim = qt[i].t, lca = qt[i].lca;
        while(l < L)
            move(order[l++]);
        while(l > L) 
            move(order[--l]);
        while(r < R)
            move(order[++r]);
        while(r > R)
            move(order[r--]);
        while(momt < tim) //带修 
            change(++momt);
        while(momt > tim) //同上 
            change(momt--);
        if(lca)		
            move(lca);
        ans[qt[i].id] = ans_; //记录答案 
        if(lca)
            move(lca);
    }
    for(Rint i = 1; i <= now_0; i++)
        ptf("%lld\n", ans[i]);
    return 0;    
}
```



---

## 作者：亚由亚由 (赞：3)

## 树上带修莫队
~~听着就很高大上对不对~~

首先 树上带修莫队=树上莫队+带修莫队 ~~废话~~

#### 树上分块详见 [SCOI2005]王室联邦
#### 带修莫队见 P1903 [国家集训队]数颜色 / 维护队列
so 当你AC了这两道题,就可以比较轻松地做这道了

### 简单讲一下树上莫队思想
假设要从v1v2转换到u1u2,则lca(v1,u1)到lca(v2,u2)这一段是不用改的 ~~应该很好想吧~~

所以把v1,u1到lca(v1,u1)和v2,u2到lca(v2,u2)修改就好了

然后是代码的实现:
```cpp

    void qxg(long long x,long long y)//如上文
    {
        if(d[x]<d[y])
        swap(x,y);
        while(d[x]>d[y])
        {
            qf(x);
            x=f[0][x];
        }
        while(x!=y)
        {
            qf(x);
            qf(y);
            x=f[0][x];
            y=f[0][y];
        }
    }


    for(i=0;i<cq;i++)
    {
        qxg(u,mq[i].u);
        qxg(v1,mq[i].v);
        u=mq[i].u;
        v1=mq[i].v;
        while(now<mq[i].t)//带修莫队的模版
        xg(++now);
        while(now>mq[i].t)
        xg(now--);
        l=lca(u,v1);
        qf(l);
        ans[mq[i].id]=an;
        qf(l);
    }
```

然后现在以取到的点用一个v数组记录然后每次取反就可以了
```cpp

    void qf(long long x)
    {
        if(bj[x])
        an-=v[g[x]]*w[num[g[x]]--];//用num记录已吃到该糖果几次
        else 
        an+=v[g[x]]*w[++num[g[x]]];
        bj[x]^=1;
    }
```


### code:
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
using namespace std;
long long n,m,z[100005],k,b[100005],s,c[100005],h[100005],cnt,B,q,v[100005],w[100005],d[100005],f[25][100005],cc,cq,now,an,ans[100005],bj[100005],num[100005],g[100005];
struct ll
{
    long long nx;
    long long to;
}a[200005];
struct mdc
{
    long long p;
    long long x;
}mc[100005];
struct mdq
{
    long long u;
    long long v;
    long long t;
    long long id;
    bool operator<(mdq& y)
    {
    return b[u]==b[y.u]?(b[v]==b[y.v]?t<y.t:b[v]<b[y.v]):b[u]<b[y.u];
    }
}mq[100005];
void ad(long long x,long long y)
{
    a[++cnt].to=y;
    a[cnt].nx=h[x];
    h[x]=cnt;
}
void dfs(int u)
{
    int t=k;
    for (int i=h[u];i;i=a[i].nx)
    {
        int v=a[i].to;
        if (v!=f[0][u])
        {
            f[0][v]=u;
            d[v]=d[u]+1;
            dfs(v);
            if (k-t>=B)
            {
                ++s;
                while (k>t)
                b[z[k--]]=s;
            }
        }
    }
    z[++k]=u;
}
void qf(long long x)
{
    if(bj[x])
    an-=v[g[x]]*w[num[g[x]]--];
    else 
    an+=v[g[x]]*w[++num[g[x]]];
    bj[x]^=1;
}
void xg(long long x)
{
    if(bj[mc[x].p])
    {
        qf(mc[x].p);
        swap(g[mc[x].p],mc[x].x);
        qf(mc[x].p);
    }
    else swap(g[mc[x].p],mc[x].x);
}
long long lca(long long x,long long y)//lca就不多说了
{
    long long i;
    if(d[x]<d[y])
    swap(x,y);
    for(i=0;i<=16;++i)
    if((d[x]-d[y])&(1<<i))
    x=f[i][x];
    if(x==y)
    return x;
    for(i=16;i>=0;--i)
    if(f[i][x]!=f[i][y])
    {
        x=f[i][x];
        y=f[i][y];
    }
    return f[0][x];
}
void qxg(long long x,long long y)
{
    if(d[x]<d[y])
    swap(x,y);
    while(d[x]>d[y])
    {
        qf(x);
        x=f[0][x];
    }
    while(x!=y)
    {
        qf(x);
        qf(y);
        x=f[0][x];
        y=f[0][y];
    }
}
int main()
{
    long long i,j,x,y,o,u=1,v1=1,l;
    scanf("%lld%lld%lld",&n,&m,&q);
    B=pow(n,0.666);
    for(i=1;i<=m;i++)
    scanf("%lld",&v[i]);
    for(i=1;i<=n;i++)
    scanf("%lld",&w[i]);
    for(i=1;i<n;i++)
    {
        scanf("%lld%lld",&x,&y);
        ad(x,y);
        ad(y,x);
    }
    dfs(1);
    while(k)
    b[z[k--]]=s;
    for(i=1;i<=16;i++)
    for(j=1;j<=n;j++)
    f[i][j]=f[i-1][f[i-1][j]];
    for(i=1;i<=n;i++)
    scanf("%lld",&g[i]);
    for(i=1;i<=q;i++)//带修莫队模版
    {
        scanf("%lld",&o);
        if(!o)
        {
            cc++;
            scanf("%lld%lld",&mc[cc].p,&mc[cc].x);
        }
        else 
        {
            scanf("%lld%lld",&mq[cq].u,&mq[cq].v);
            mq[cq].t=cc;
            mq[cq].id=cq;
            cq++;
        }
    }
    sort(mq,mq+cq);
    for(i=0;i<cq;i++)
    {
        qxg(u,mq[i].u);
        qxg(v1,mq[i].v);
        u=mq[i].u;
        v1=mq[i].v;
        while(now<mq[i].t)
        xg(++now);
        while(now>mq[i].t)
        xg(now--);
        l=lca(u,v1);
        qf(l);
        ans[mq[i].id]=an;
        qf(l);
    }
    for(i=0;i<cq;i++)
    printf("%lld\n",ans[i]);
    return 0;
}
```
~~码风很丑还请见谅~~


---

## 作者：大奕哥 (赞：3)

树上莫队和普通的序列莫队很像，我们把树进行dfs，然后存一个长度为2n的括号序列，就是一个点进去当作左括号，出来当作右括号，然后如果访问从u到v路径，我们可以转化成括号序列的区间，记录x进去的时候编号为f[x],出来时为g[x]，然后分类讨论一下(f[u]<f[v])，如果u和v的lca不是u，那么就是从g[u]到f[v]，否则就是lca的f到另一个点的f，（可以自己试一下，中间过程没有用的点正好就抵消掉了）这里要注意一下，从g[u]到f[v]的时候我们会少掉lca这个点，特殊处理一下即可，然后按照普通莫队排一下序，暴力就行了。

安利blog：http://www.cnblogs.com/nbwzyzngyl/p/8343541.html

```cpp
#include<bits/stdc++.h>
using namespace std;
const int M=1e5+5;
typedef long long ll;
ll ans[M],sum,W[M],N[M],V[M];
int fa[M][19],pre[M],d[M],bel[M],col[M],s[M],head[M],dfn[M],size[M];
int cnt,num,B,idx,top,n,m,q;
bool v[M];
struct node{
    int to,nex;
}e[M<<1];
void add(int x,int y)
{
    e[++cnt].nex=head[x];e[cnt].to=y;head[x]=cnt;
}
struct quer{
    int x,y,id,t;
    bool operator<(const quer &b)const{
        if(bel[x]==bel[b.x]&&bel[y]==bel[b.y])return t<b.t;
        if(bel[x]==bel[b.x])return bel[y]<bel[b.y];
        return bel[x]<bel[b.x];
    }
}b[M],c[M];
void dfs(int x)
{
    dfn[x]=++idx;s[++top]=x;
    for(int i=1;i<=16;++i)
    fa[x][i]=fa[fa[x][i-1]][i-1];
    for(int i=head[x];i;i=e[i].nex)
    {
        int y=e[i].to;
        if(y==fa[x][0])continue;
        fa[y][0]=x;d[y]=d[x]+1;
        dfs(y);
        size[x]+=size[y];
        if(size[x]>=B)
        {
            num++;
            for(int k=1;k<=size[x];++k)
            bel[s[top--]]=num;
            size[x]=0;
        }
    }
    size[x]++;
}
int lca(int x,int y)
{
    if(d[x]<d[y])swap(x,y);
    int tmp=d[x]-d[y];
    for(int i=0;i<=16;++i)
    if(tmp&(1<<i))x=fa[x][i];
    for(int i=16;i>=0;--i)
    {
        if(fa[x][i]!=fa[y][i])
        {
            x=fa[x][i];
            y=fa[y][i];
        }
    }
    return x==y?x:fa[x][0];
}
void reverse(int x)
{
    if(!v[x]){v[x]=1;N[col[x]]++;sum+=W[N[col[x]]]*V[col[x]];}
    else {v[x]=0;sum-=W[N[col[x]]]*V[col[x]];N[col[x]]--;}
    return;
}
void change(int x,int y)
{
    if(v[x])
    {
        reverse(x);col[x]=y;reverse(x);
    }
    else col[x]=y;
}
void solve(int x,int y)
{
    while(x!=y)
    {    
        if(d[x]<d[y])swap(x,y);
        reverse(x);x=fa[x][0];
    }
    return;
}
int main()
{
    scanf("%d%d%d",&n,&m,&q);
    B=pow(n,2.0/3)*0.5;int x,y,f;
    for(int i=1;i<=m;++i)scanf("%lld",&V[i]);
    for(int i=1;i<=n;++i)scanf("%lld",&W[i]);
    for(int i=1;i<n;++i)
    {
        scanf("%d%d",&x,&y);
        add(x,y),add(y,x);
    }
    for(int i=1;i<=n;++i)scanf("%d",&col[i]),pre[i]=col[i];
    dfs(1);num++;int c1=0,c2=0;
    while(top)bel[s[top--]]=num;
    for(int i=1;i<=q;++i)
    {
        scanf("%d%d%d",&f,&x,&y);
        if(f)
        {
            if(dfn[x]>dfn[y])swap(x,y);
            b[++c2].x=x;b[c2].t=c1;b[c2].y=y;b[c2].id=c2;
        }
        else
        {
            c[++c1].x=x;c[c1].y=y;c[c1].t=pre[x];pre[x]=y;
        }
    }
    sort(b+1,b+1+c2);
    for(int i=1;i<=b[1].t;++i)
    change(c[i].x,c[i].y); 
    int z=lca(b[1].x,b[1].y);
    solve(b[1].x,b[1].y);
    reverse(z);
    ans[b[1].id]=sum;
    reverse(z);
    for(int i=2;i<=c2;++i)
    {
        for(int j=b[i-1].t+1;j<=b[i].t;++j)
        change(c[j].x,c[j].y);
        for(int j=b[i-1].t;j>b[i].t;--j)
        change(c[j].x,c[j].t);
        int z=lca(b[i].x,b[i].y);
        solve(b[i-1].x,b[i].x);
        solve(b[i-1].y,b[i].y);
        reverse(z);
        ans[b[i].id]=sum;
        reverse(z);
    }
    for(int i=1;i<=c2;++i)
    printf("%lld\n",ans[i]);
    return 0;
}
```

---

## 作者：Star_Cried (赞：2)

## P4074 [WC2013]糖果公园

*Tag：树上带修莫队*

题意：树上每个点有一种糖果，求$\sum_c\sum_{i=1}^{cnt_c}v_c*w_i$

其中c为糖果种类，$cnt_c$其为出现次数。

### 思路

离线树上带修莫队。

先进行树上分块。分块内的询问按照出发点、终止点、询问id优先级依次递减排序。

对于树上莫队，其实就是在欧拉序上莫队。因为欧拉序的性质，即每个节点子树内的节点一定会经过两次，我们就可以用一个括号序列的方式在莫队时消除子树内无用节点的影响。

具体来说，序列长度为2*n，每一个节点出入队时我们异或它是否在队中即可。也就是记录每个点出队和入队的时间戳，然后在序列上修改。

注意，对于LCA其实在欧拉序时是没有包括的，所以我们需要单独求一下LCA的影响。但是如果一个端点本身就是LCA就不用啦。

但是！用指针实现也太low了，我们直接利用它的树形结构莫队就行（实际上就是我看错了题解）

### 代码

#### 分块和排序

```cpp
	int dfs(int x,int f){//毒瘤的树分块而非序列分块
		int siz=0;
		fa[x][0]=f;dep[x]=dep[f]+1;
		dfn[x]=++tim;
		for(int i=0;i<=20;i++)fa[x][i+1]=fa[fa[x][i]][i];
		for(int i=head[x];i;i=nxt[i]){
			int u=to[i];
			if(u==f)continue;
			siz+=dfs(u,x);
			if(siz>=_nsiz){
				_n++;
				while(siz)belong[st[top--]]=_n,siz--;
			}
		}
		st[++top]=x;
		return siz+1;
	}
//----------------
	++_n;
	while(top)belong[st[top--]]=_n;
```

```cpp
inline bool operator < (const query&zp)const {return belong[u]<belong[zp.u] or (belong[u]==belong[zp.u] and (belong[v]<belong[zp.v] or (belong[v]==belong[zp.v] and id<zp.id)));}//运算符版
```

#### 莫队

```cpp
	inline void reverse(const int& x,ll &ans){//将进队的出队，出队的进队。
		if(vis[x])ans-=1ll*w[num[color[x]]]*v[color[x]],num[color[x]]--;
		else num[color[x]]++,ans+=1ll*w[num[color[x]]]*v[color[x]];
		vis[x]^=1;
	}
	inline void solve(int x,int y,ll &ans){//直接利用树形结构跳father，更新答案，反正括号序列也就是翻转。
		while(x!=y){
			if(dep[x]>dep[y])reverse(x,ans),x=fa[x][0];
			else reverse(y,ans),y=fa[y][0];
		}
	}
```

```cpp
		for(int i=1;i<=cntq;i++){
			while(now<cntm and mo[now+1].id<=q[i].id){//处理时间问题，只能暴力消除影响。
				now++;
				if(vis[mo[now].pos])ans-=w[num[color[mo[now].pos]]]*v[color[mo[now].pos]],num[color[mo[now].pos]]--;
				color[mo[now].pos]=mo[now].aft;
				if(vis[mo[now].pos])num[color[mo[now].pos]]++,ans+=1LL*w[num[color[mo[now].pos]]]*v[color[mo[now].pos]];
			}
			while(now>=1 and mo[now].id>=q[i].id){
				if(vis[mo[now].pos])ans-=w[num[color[mo[now].pos]]]*v[color[mo[now].pos]],num[color[mo[now].pos]]--;
				color[mo[now].pos]=mo[now].bef;//注意变成了什么（我就是傻
				if(vis[mo[now].pos])num[color[mo[now].pos]]++,ans+=1LL*w[num[color[mo[now].pos]]]*v[color[mo[now].pos]];
				now--;
			}
			if(i==1)solve(q[i].u,q[i].v,ans);
			else solve(q[i].u,q[i-1].u,ans),solve(q[i].v,q[i-1].v,ans);//保证继承答案连续
			int lca=LCA(q[i].u,q[i].v);
			reverse(lca,ans);
			q[i].ans=ans;
			reverse(lca,ans);//单独计算，最后要消除影响。不要被继承。
		}
```

事实证明，这种写法是真~~毒瘤~~，开了O2才勉强能过。

#### 全代码

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cctype>
#include<cmath>
using namespace std;
inline int read(){
	int w=0,x=0;char c=getchar();
	while(!isdigit(c))w|=c=='-',c=getchar();
	while(isdigit(c))x=(x<<3)+(x<<1)+(c^48),c=getchar();
	return w?-x:x;
}
namespace star
{
	const int maxn=1e5+10;
	typedef long long ll;
	int n,m,Q,_n,fa[maxn][23],_nsiz,dfn[maxn],dep[maxn],c[maxn],color[maxn];
	ll v[maxn],w[maxn];
	int ecnt,tim,st[maxn<<1],belong[maxn],top,head[maxn],to[maxn<<1],nxt[maxn<<1];
	struct query{
		int u,v,id;
		ll ans;
		inline bool operator < (const query&zp)const {return belong[u]<belong[zp.u] or (belong[u]==belong[zp.u] and (belong[v]<belong[zp.v] or (belong[v]==belong[zp.v] and id<zp.id)));}
	}q[maxn];
	inline bool cmp(query a,query b){return a.id<b.id;}
	struct modify{
		int pos,bef,aft,id;
	}mo[maxn<<1];
	inline void addedge(int a,int b){
		to[++ecnt]=b,nxt[ecnt]=head[a],head[a]=ecnt;
		to[++ecnt]=a,nxt[ecnt]=head[b],head[b]=ecnt;
	}
	int dfs(int x,int f){
		int siz=0;
		fa[x][0]=f;dep[x]=dep[f]+1;
		dfn[x]=++tim;
		for(int i=0;i<=20;i++)fa[x][i+1]=fa[fa[x][i]][i];
		for(int i=head[x];i;i=nxt[i]){
			int u=to[i];
			if(u==f)continue;
			siz+=dfs(u,x);
			if(siz>=_nsiz){
				_n++;
				while(siz)belong[st[top--]]=_n,siz--;
			}
		}
		st[++top]=x;
		return siz+1;
	}
	inline int LCA(int x,int y){
		if(dep[x]<dep[y])swap(x,y);
		for(int i=20;i+1;i--)if(dep[fa[x][i]]>=dep[y])x=fa[x][i];
		if(x==y)return x;
		for(int i=20;i+1;i--)if(fa[x][i]!=fa[y][i])x=fa[x][i],y=fa[y][i];
		return fa[x][0];
	}
	bool vis[maxn];
	int num[maxn];
	inline void reverse(const int& x,ll &ans){
		if(vis[x])ans-=1ll*w[num[color[x]]]*v[color[x]],num[color[x]]--;
		else num[color[x]]++,ans+=1ll*w[num[color[x]]]*v[color[x]];
		vis[x]^=1;
	}
	inline void solve(int x,int y,ll &ans){
		while(x!=y){
			if(dep[x]>dep[y])reverse(x,ans),x=fa[x][0];
			else reverse(y,ans),y=fa[y][0];
		}
	}
	inline void work(){
		n=read(),m=read(),Q=read();
		_nsiz=pow(n,0.666666666);
		for(int i=1;i<=m;i++)v[i]=read();
		for(int i=1;i<=n;i++)w[i]=read();
		for(int i=1;i<n;i++)addedge(read(),read());
		for(int i=1;i<=n;i++)c[i]=color[i]=read();
		int cntq=0,cntm=0,x;
		for(int i=1;i<=Q;i++){
			if(read())q[++cntq].id=i,q[cntq].u=read(),q[cntq].v=read();
			else mo[++cntm].id=i,mo[cntm].bef=c[(x=read())],mo[cntm].pos=x,mo[cntm].aft=c[x]=read();
		}
		dfs(1,0);
		for(int i=1;i<=cntq;i++)if(dfn[q[i].v]<dfn[q[i].u])swap(q[i].u,q[i].v);//对于这种写法这句其实可有也可无了。这种写法的一个好处就是不交换不影响正确性。
		++_n;
		while(top)belong[st[top--]]=_n;
		sort(q+1,q+1+cntq);
		int now=0;
		long long ans=0;
		for(int i=1;i<=cntq;i++){
			while(now<cntm and mo[now+1].id<=q[i].id){
				now++;
				if(vis[mo[now].pos])ans-=w[num[color[mo[now].pos]]]*v[color[mo[now].pos]],num[color[mo[now].pos]]--;
				color[mo[now].pos]=mo[now].aft;
				if(vis[mo[now].pos])num[color[mo[now].pos]]++,ans+=1LL*w[num[color[mo[now].pos]]]*v[color[mo[now].pos]];
			}
			while(now>=1 and mo[now].id>=q[i].id){
				if(vis[mo[now].pos])ans-=w[num[color[mo[now].pos]]]*v[color[mo[now].pos]],num[color[mo[now].pos]]--;
				color[mo[now].pos]=mo[now].bef;
				if(vis[mo[now].pos])num[color[mo[now].pos]]++,ans+=1LL*w[num[color[mo[now].pos]]]*v[color[mo[now].pos]];
				now--;
			}
			if(i==1)solve(q[i].u,q[i].v,ans);
			else solve(q[i].u,q[i-1].u,ans),solve(q[i].v,q[i-1].v,ans);
			int lca=LCA(q[i].u,q[i].v);
			reverse(lca,ans);
			q[i].ans=ans;
			reverse(lca,ans);
		}
		sort(q+1,q+1+cntq,cmp);
		for(int i=1;i<=cntq;i++)printf("%lld\n",q[i].ans);
	}
}
signed main(){
	star::work();
	return 0;
}
```

### 总结

写了个假的（gxy称之为非主流）树上莫队。准备再写一道免得脑子里装着奇怪的东西。

因为写法毒瘤所以#define int long long会T飞。

~~大家千万不要学非主流~~

~~所以这个题解如果能通过的话大家当着非主流看看就好了。请随便骂我~~

---

## 作者：Others (赞：1)

这题蒟蒻调了整整一天半，实在是恶心，但是做完感觉自己对树上莫队的理解加深了许多（我是用手重新打的）。
# 题目大意
这题给的是一颗挺明显的树（$n$ 个节点，$n-1$ 条边），然后要求路径上的一些数据（路径上的糖果类型的出现次数对应的 $w$ 值 $*$ 糖果对应的快乐值的和），还带修改。

# 思路
这题是棵树，要求路径，支持修改，可以离线，答案是可以在统计过程中计算的（也只有在统计过程中计算），这不明显的莫队吗？还是带修的树上莫队，板板在手，天下我有，这里讲解一下怎么实现。

因为是路径，所以 dfs 序显然没用了，这里需要用到欧拉序和 LCA。欧拉序就是在 dfs 中每次进入和离开 dfs 时都加入序列，这序列的方便之处就在于将两个点之间重复的节点抹去，剩下的就是路径了，当然，如果要绕过他们的 LCA，的话就需要单独处理一下（也只需要单独处理 LCA）。求 LCA 时就可以初始化欧拉序。最后就是莫队了，记得要处理重复的节点（开一个数组，每次异或 1）。

带修莫队加进去其实影响不大，甚至都不需要你去改树上莫队的板子（但我还是重新打了一遍...），就是这里的对应关系十分复杂，推荐画一下图然后进行记录，不然就会~~像我一样~~傻看着代码搞一天不晓得那里错了...

讲完了，上代码
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int MAXN=100005;
inline void qr(register int &ret){//手打快读 
	register int x=0,f=0;
	register char ch=getchar();
	while(ch<'0'||ch>'9') f|=ch=='-',ch=getchar();
	while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+(ch^48),ch=getchar();
	ret=f?-x:x;
} 
int n,m,q,w[MAXN],v[MAXN],c[MAXN],ttt,fr,op,x,y,LCA;//单纯的杂项（啥都有） 
int fa[MAXN],ord[MAXN<<1],fir[MAXN],las[MAXN],son[MAXN],sze[MAXN],head[MAXN],nxt[MAXN<<1],to[MAXN<<1],dep[MAXN],top[MAXN],ccnt,nord;//LCA 相关 
int cntr,cntp,idx[MAXN<<1],s,l,r,t,tot,cnt[MAXN],vis[MAXN],L,R,T,ans[MAXN];//莫队相关 
struct node1{//查询 
	int l,r,id,ti,lca;
	bool operator<(const node1 x)const{//奇怪的双重奇偶排序 
		return idx[l]==idx[x.l]?(idx[l]&1?(idx[r]==idx[x.r]?(idx[r]&1?ti<x.ti:ti>x.ti):idx[r]<idx[x.r]):(idx[r]==idx[x.r]?(idx[r]&1?ti<x.ti:ti>x.ti):r>x.r)):l<x.l;
	}
}p[MAXN];
struct node2{//修改 
	int i,from,to;
}ch[MAXN];
void add(int x){
	++cnt[x];
	tot+=v[x]*w[cnt[x]];
}
void del(int x){//这里的对应关系用人脑压不下！！ 
	tot-=v[x]*w[cnt[x]];
	--cnt[x];
}
void work(int x){//这里是树上莫队的处理（没学过的理解一下） 
	vis[x]?del(c[x]):add(c[x]);
	vis[x]^=1;
}
void dealadd(int x){//时间的修改 1 
	if(vis[ch[x].i]) add(ch[x].to),del(ch[x].from);//如果修改的节点对答案有影响，就顺手处理一手影响 
	c[ch[x].i]=ch[x].to;                           
}
void dealdel(int x){//时间的修改 2
	if(vis[ch[x].i]) del(ch[x].to),add(ch[x].from);//同上 
	c[ch[x].i]=ch[x].from;//修改原数组 
}
void adde(int fr,int To){//加边 
	nxt[++ccnt]=head[fr],head[fr]=ccnt,to[ccnt]=To;
}
void dfs1(int i){//这里我用的是树剖求 LCA 看不懂的同学可以去康康其他的 
				 //树剖的初始化 1 
	dep[i]=dep[fa[i]]+1;
	sze[i]=1;
	ord[++nord]=i;
	fir[i]=nord;
	for(int j=head[i];j;j=nxt[j]){
		if(to[j]==fa[i]) continue;
		fa[to[j]]=i;
		dfs1(to[j]);
		sze[i]+=sze[to[j]];
		if(son[i]==1||sze[to[j]]>sze[son[i]]) son[i]=to[j];
	}
	ord[++nord]=i;
	las[i]=nord;
	return;
}
void dfs2(int i,int Top){//树剖的初始化 2
	top[i]=Top;
	if(son[i]) dfs2(son[i],Top);
	for(int j=head[i];j;j=nxt[j]){
		if(to[j]==fa[i]||to[j]==son[i]) continue;
		dfs2(to[j],to[j]);
	}
	return;
}
int getlca(int x,int y){//跳祖先 
	while(top[x]^top[y]){
		if(dep[top[x]]>=dep[top[y]]) x=fa[top[x]];
		else y=fa[top[y]];
	}
	return dep[x]>dep[y]?y:x;
}
signed main() {
	qr(n),qr(m),qr(q);
	for(int i=1;i<=m;++i) qr(v[i]);
	for(int i=1;i<=n;++i) qr(w[i]);
	for(int i=1;i<n;++i){
		qr(fr),qr(ttt);
		adde(fr,ttt),adde(ttt,fr);
	}
	fa[1]=1;
	dfs1(1),dfs2(1,1);//初始化 
	for(int i=1;i<=n;++i) qr(c[i]);
	s=pow(nord,2.0/3);//处理分块 1（这里是 2/3 次方！！！） 
	for(int i=1;i<=nord;++i) idx[i]=(i+s-1)/s;//处理分块 2
	for(int i=1;i<=q;++i){
		qr(op),qr(x),qr(y);
		if(op){
			++cntp;
			if(fir[x]>fir[y]) swap(x,y);
			LCA=getlca(x,y);
			if(LCA==x){//如果两点在一条链上 
				p[cntp].l=fir[x],p[cntp].r=fir[y];
				p[cntp].id=cntp,p[cntp].ti=cntr;
			}else{//不在一条链上 
				p[cntp].l=las[x],p[cntp].r=fir[y];
				p[cntp].id=cntp,p[cntp].ti=cntr;
				p[cntp].lca=LCA;
			}
		}else{
			++cntr;
			ch[cntr].i=x,ch[cntr].from=c[x],ch[cntr].to=c[x]=y;//记得修改原数组 
		}
	}
	for(int i=cntr;i>=1;--i) c[ch[i].i]=ch[i].from;//记得还原 
	sort(p+1,p+cntp+1);//排序 
	l=1,r=t=0;
	for(int i=1;i<=cntp;++i){//莫队板板(如果这都不会，你还来做这题？) 
		L=p[i].l,R=p[i].r,T=p[i].ti;
		while(t>T) dealdel(t--);
		while(t<T) dealadd(++t);
		while(l>L) work(ord[--l]);//这里是 ord[(l 或 r)]！！！调了半天的我就是因为这里...
		while(r<R) work(ord[++r]);
		while(l<L) work(ord[l++]);
		while(r>R) work(ord[r--]);
		if(p[i].lca) work(p[i].lca);//如果不在一条链上，就处理一下 LCA 
		ans[p[i].id]=tot;
		if(p[i].lca) work(p[i].lca);
	}
	for(int i=1;i<=cntp;++i) printf("%lld\n",ans[i]);
	return 0;
}
```

---

## 作者：RuntimeErr (赞：1)

# 树上莫队+带修莫队的好题！

蒟蒻过的第二道黑题/kel

树上莫队部分跟普通树上莫队一样，括号序和 `lca` 蒟蒻我是用树剖求的，这里不细讲。

## 我们重点来讲一下带修部分

对于修改时间轴部分，我们该怎样改呢？我们来看图

![](https://cdn.luogu.com.cn/upload/image_hosting/d9bzd7y0.png)

其中的括号序应该是 `1 3 8 8 7 7 3 5 5 2 4 6 6 4 2 1`

假设我们要查询 $2$ 到 $8$ 的路径（记一个结点 $i$ 第一次被遍历到时的序号是 $st_i$ ，回溯时的序号是 $ed_i$ ），那我们要遍历的括号序是 $(ed_2,st_8)$ 再加上它们的 `lca` 。

- 如果我们要修改的是 $7$ 号结点的位置，不难发现它已经被记录两次——贡献被抵消（由树上莫队操作可知），那我们即使修改了，修改后的贡献也是被抵消掉，因此只需交换即可。

- 如果我们要修改的是 $3$ 号结点的位置，不难发现它只被记录了一次——贡献还在，那我们把它的贡献去掉，加上修改后的贡献再交换即可。

## $like \ this:$

```cpp
inline void change(int now){
	if(used[c[now].pos]){//要修改的位置只被记录一次
		del(a[c[now].pos]);//去掉原来的贡献
		add(c[now].to);//加上修改后的贡献
	}
	swap(a[c[now].pos],c[now].to);
}
```

对于取块长，有修改操作则按带修莫队的块长 $n^{\frac{2}{3}}$，反之用普通莫队的块长 $\sqrt{n}$ 即可。

# $Code:$

```cpp
#include<cstdio>
#include<algorithm>
#include<vector>
#include<cmath>
using namespace std;
#define int long long
#define N (int)(2e5+10)
#define swap(a,b) a^=b^=a^=b
#define getchar()(p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
char buf[1<<21],*p1=buf,*p2=buf;
template <typename T>
inline void read(T& r) {
	r=0;bool w=0; char ch=getchar();
	while(ch<'0'||ch>'9') w=ch=='-'?1:0,ch=getchar();
	while(ch>='0'&&ch<='9') r=(r<<3)+(r<<1)+(ch^48), ch=getchar();
	r=w?-r:r;
}
void write(int x){
	if(x<0)putchar('-'),write(-x);
	else {
		if(x>9)write(x/10);
		putchar(x%10+'0');
	}
}

int n,m,k,bl,be[N],v[N],w[N],a[N],cs=0,qs=0,cnt[N],ans[N],sum;
int fa[N],son[N],dep[N],size[N],top[N],st[N],ed[N],rnk[N],tot;
bool used[N];
vector<int>e[N];
struct query{int l,r,t,id,lca;}q[N];
struct candy{int to,pos;}c[N];
inline bool cmp(query a,query b) {
    return be[a.l]^be[b.l]?a.l<b.l:(be[a.r]^be[b.r]?a.r<b.r:a.t<b.t);
}

void dfs1(int u){
	size[u]=1;
	st[u]=++tot;rnk[tot]=u;
	for(int i=0;i<e[u].size();++i){
		int v=e[u][i];
		if(v^fa[u]){
			fa[v]=u;dep[v]=dep[u]+1;
			dfs1(v);
			size[u]+=size[v];
			if(size[son[u]]<size[v])son[u]=v;
		}	
	}
	ed[u]=++tot;rnk[tot]=u;
}
void dfs2(int u,int t){
	top[u]=t;
	if(!son[u])return;
	dfs2(son[u],t);
	for(int i=0;i<e[u].size();++i){
		int v=e[u][i];
		if(v^son[u]&&v^fa[u])dfs2(v,v);
	}
}
int LCA(int u,int v){
	while(top[u]^top[v]){
		if(dep[top[u]]<dep[top[v]])swap(u,v);
		u=fa[top[u]];
	}
	return dep[u]<dep[v]?u:v;
}

inline void add(int x){
	++cnt[x];
	sum+=v[x]*w[cnt[x]];
}
inline void del(int x){
	sum-=v[x]*w[cnt[x]];
	--cnt[x];
}
inline void get(int x){
	if(!used[x])add(a[x]);
	else del(a[x]);
	used[x]^=1;
}
inline void change(int now){
	if(used[c[now].pos]){
		del(a[c[now].pos]);
		add(c[now].to);
	}
	swap(a[c[now].pos],c[now].to);
}

signed main(){
	read(n);read(m);read(k);
	for(int i=1;i<=m;++i)read(v[i]);
	for(int i=1;i<=n;++i)read(w[i]);
	for(int i=1,x,y;i<n;++i){
		read(x);read(y);
		e[x].push_back(y);
		e[y].push_back(x);
	}
	dep[1]=1;dfs1(1);dfs2(1,1);
	for(int i=1;i<=n;++i)read(a[i]);
	for(int i=1;i<=k;++i){
		int type,x,y;
		read(type);read(x);read(y);
		if(!type){
			++cs;
			c[cs].pos=x;c[cs].to=y;
		}else {
			++qs;
			if(st[x]>st[y])swap(x,y);
			q[qs].id=qs;q[qs].t=cs;
			q[qs].lca=LCA(x,y);
			if(q[qs].lca==x){
				q[qs].l=st[x];q[qs].r=st[y];
				q[qs].lca=0;
			}else q[qs].l=ed[x],q[qs].r=st[y];	
		}
	}
	bl=pow(n<<1,cs?2.0/3.0:1.0/2.0);//注意括号序长度为双倍 
	for(int i=1;i<=n<<1;++i)be[i]=(i-1)/bl+1;
	sort(q+1,q+qs+1,cmp);
	for(int i=1,l=q[1].l,r=q[1].l-1,now=0;i<=qs;++i){
		while(l>q[i].l)get(rnk[--l]);
        	while(r<q[i].r)get(rnk[++r]);
        	while(l<q[i].l)get(rnk[l++]);
        	while(r>q[i].r)get(rnk[r--]);
        	while(now<q[i].t)change(++now);
        	while(now>q[i].t)change(now--);
        	if(q[i].lca)get(q[i].lca);
        	ans[q[i].id]=sum;
        	if(q[i].lca)get(q[i].lca);
	}
	for(int i=1;i<=qs;++i)write(ans[i]),puts("");
	return 0;
}
```


---

## 作者：Plozia (赞：1)

宣传博客->[link](https://blog.csdn.net/BWzhuzehao/article/details/110880390)

这道题可以说是一道树上带修莫队的板子题。虽然评级是黑的，但是树上带修莫队本身还是比较好想的。~~就是代码很难调。~~

### 树上莫队：

树上莫队的本质就是利用欧拉序将树上莫队问题变成序列莫队问题。

我们设 $\{eular\}$ 表示欧拉序序列， $fir_i,las_i$ 表示节点 $i$ 在欧拉序中第一次出现与第二次出现的位置。那么当询问为 $x,y$ 时（此处我们规定 $x$ 的深度小于 $y$），如果 $lca(x,y)=x$ ，那么用 $fir_x,fir_y$ 的区间，否则用 $las_x,fir_y$ 的区间同时带上 $lca(x,y)$ 的贡献。为什么不是 $fir_x$ ？因为中间出现二次的节点我们是不考虑的，因此用 $fir_x$ 相当于浪费时间 ~~（用时间换空间的当我没说）~~ 。这里千万注意：序列长度是 $2n$ 而不是 $n$ ，千万不要在这里 TLE 了！

### 带修莫队：

带修莫队的本质就是加一个时间轴，让指针除了在 $l,r$ 上动还可以在 $time$ 上动，将询问与修改分开储存，就可以完成了。

### 树上带修莫队：

实际上就是前面两个的结合体，先跑一遍欧拉序，然后再跑一遍带修莫队即可。

三个注意点：

1. 在跑莫队的时候，如果要计算 $lca(x,y)$ 的贡献（这里我们规定 $lca(x,y)$ 不在询问的区间内，如果在可以前面直接先特判一下），**算完之后一定不要忘记还原**！
2. **再次提醒：数列长度是 $2n$ ，千万不能在这里 TLE 了！**
3. 这里块长取 $eular^{\frac{2}{3}}$ ，比 $\sqrt{eular}$ 要好一点，其中 $eular$ 表示欧拉序的长度

几个小优化：

1. 如果可以，使用树链剖分求 $lca$。
2. ~~吸氧~~。（经过实测，我一开始调的块长是 $n^{\frac{2}{3}}$，调错了，但是吸氧之后 $30pts$ $->$ $70pts$）

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;

const int MAXN=1e6+5;
int n,m,que,v[MAXN],w[MAXN],c[MAXN],fir[MAXN],las[MAXN],ys[MAXN],block,fa[MAXN][21],eular[MAXN<<1],dep[MAXN],cntq,cntc,vis[MAXN];
typedef long long LL;
LL ans[MAXN],total,cnt[MAXN];
vector<int>Next[MAXN];
struct query
{
	int l,r,id,lca,Time;
}q[MAXN];
struct change
{
	int pos,val;
}cha[MAXN];

int read()
{
	int sum=0;char ch=getchar();
	while(ch<'0'||ch>'9') ch=getchar();
	while(ch>='0'&&ch<='9') {sum=(sum<<3)+(sum<<1)+(ch^48);ch=getchar();}
	return sum;
}

void dfs(int x)
{
	eular[++eular[0]]=x;
	fir[x]=eular[0];
	for(int i=0;i<Next[x].size();i++)
	{
		int u=Next[x][i];
		if(dep[u]) continue;
		dep[u]=dep[x]+1;
		fa[u][0]=x;
		dfs(u);
	}
	eular[++eular[0]]=x;
	las[x]=eular[0];
}

void st()
{
	for(int i=1;i<=20;i++)
		for(int j=1;j<=n;j++)
			fa[j][i]=fa[fa[j][i-1]][i-1];
}

int getlca(int x,int y)
{
	if(dep[x]<dep[y]) swap(x,y);
	int d=dep[x]-dep[y],tmp=-1;
	while(d)
	{
		tmp++;int p=d&1;d>>=1;
		if(p) x=fa[x][tmp];
	}
	if(x==y) return x;
	for(int i=20;i>=0;i--)
		if(fa[x][i]!=fa[y][i]) x=fa[x][i],y=fa[y][i];
	return fa[x][0];
}

bool cmp(const query &fir,const query &sec)
{
	if(ys[fir.l]^ys[sec.l]) return ys[fir.l]<ys[sec.l];
	if(ys[fir.r]^ys[sec.r]) return ys[fir.r]<ys[sec.r];
	return fir.Time<sec.Time;
}

void add(int x)
{
	total+=1ll*v[c[x]]*w[++cnt[c[x]]];
}
void del(int x)
{
	total-=1ll*v[c[x]]*w[cnt[c[x]]--];
}

void work(int x)
{
	vis[x]?del(x):add(x);
	vis[x]^=1;
}

void deal(int t)
{
	if(vis[cha[t].pos])
	{
		work(cha[t].pos);
		swap(c[cha[t].pos],cha[t].val);
		work(cha[t].pos);
	}
	else swap(c[cha[t].pos],cha[t].val);
}

int main()
{
	n=read();m=read();que=read();
	for(int i=1;i<=m;i++) v[i]=read();
	for(int i=1;i<=n;i++) w[i]=read();
	for(int i=1;i<n;i++)
	{
		int x=read(),y=read();
		Next[x].push_back(y);
		Next[y].push_back(x);
	}
	for(int i=1;i<=n;i++) c[i]=read();
	fa[1][0]=1;dep[1]=1;dfs(1);st();block=ceil(pow(eular[0],2.0/3.0));
	for(int i=1;i<=(n<<1);i++) ys[i]=(i-1)/block+1;
	for(int i=1;i<=que;i++)
	{
		int opt=read(),zzh1=read(),zzh2=read();
		if(opt)
		{
			q[++cntq].id=cntq;
			q[cntq].Time=cntc;
			if(fir[zzh1]>fir[zzh2]) swap(zzh1,zzh2);
			int qlca=getlca(zzh1,zzh2);
			if(zzh1==qlca) q[cntq].l=fir[zzh1],q[cntq].r=fir[zzh2];
			else q[cntq].l=las[zzh1],q[cntq].r=fir[zzh2],q[cntq].lca=qlca;
		}
		else
		{
			cha[++cntc].pos=zzh1;
			cha[cntc].val=zzh2;
		}
	}
	sort(q+1,q+cntq+1,cmp);
	int l=1,r=0,t=0;
	for(int i=1;i<=cntq;i++)
	{
		while(l<q[i].l) work(eular[l++]);
		while(l>q[i].l) work(eular[--l]);
		while(r<q[i].r) work(eular[++r]);
		while(r>q[i].r) work(eular[r--]);
		while(t<q[i].Time) deal(++t);
		while(t>q[i].Time) deal(t--);
		if(q[i].lca) work(q[i].lca);
		ans[q[i].id]=total;
		if(q[i].lca) work(q[i].lca);
	}
	for(int i=1;i<=cntq;i++) printf("%lld\n",ans[i]);
	return 0;
}
```

---

## 作者：小木虫 (赞：0)

### Preface  
这题是树上转序列的经典莫队例题，需要大家多加理解。  
（本文题目简述和部分代码借鉴了 OI Wiki。）
### Problem  
给你一棵树，树上第 $i$ 个点颜色是 $c_i$，每次询问一条路径 $u_i,v_i$，求这条路径上的：  

$\sum_c val_c \sum _{i=1}^{cntc}w_i$  

其中：$val$ 表示该颜色的价值，$cnt$ 表示颜色出现的次数，$w$ 表示该颜色出现 $i$ 次后的价值。  

### Solution  
这题说是树上莫队，但其实不算严格的树上莫队，因为要先把树给转为序列再在序列上进行莫队。  
怎么转序列呢？这里要用到一个小 trick，把树按 dfs 序转为括号序列，即：  
在递归到 $x$ 点时，往序列里加入 $x$ 代表左括号，在递归完其所有子节点时，再次将其加入，代表右括号，不难发现一对括号代表一棵子树。    

然后，在进行莫队的时候，如果找到一个序列上的点要加入，其代表的树上点在之前已经计算过了，那么这次要将其减掉。要弹出的时候则反之。  
这样，任何一条从上到下的路径都可以被这个序列的一个子段表示了，各位理解一下。    

在上方的那个点所在序列中的左括号开始到其右括号都是这个子树内，从上方点的左括号直到下方那个点的左括号所形成的子段就是我们要的子段，所有与这条路径无关的点应该被包含在与这条链相邻的子树内，会在莫队时被刷新为 0 贡献。换个角度说，与这个路径有关的点因为不会回溯，所以只有左括号：  
![](https://cdn.luogu.com.cn/upload/image_hosting/8ihxik5j.png)  

现在问题来了：从上到下的链我们会做了，但是...  
**不是这样的链怎么做啊？**  
更标准的说法：两个点的 LCA 不是任何一个点的链怎么做啊。  
拆成两个链？很抱歉，这玩意不具备可加性。  
仔细一看，好像还是有办法的。  
如果从第一个节点的右括号开始，到第二个节点的左括号。  
这样，从第一个节点到 LCA 有用的玩意都利用回溯被转化为右括号了，第二个反之，按照从上到下的原理，是左括号。  
但是这样的话 LCA 本身没有被加入，因为它子树代表的括号包含了两个节点。  
这个简单，记录答案的时候加入一下 LCA 就行了。     
注意到有一个修改操作，于是我们排序加一个时间维度，$l,r$ 按块排序，$t$ 从小到大排序，变为带修莫队，块长为 $n^\frac{2}{3}$，总复杂度为 $O(n^\frac{5}{3})$。  
证明：  
1.首先对于 $l$ 指针：  
若在同一块内，$l$ 的移动是 $O(n^\frac{2}{3})$ 的，乘上 $m$ 个询问总复杂度是 $O(m n^\frac{2}{3})$ 的，由于 $m$ 与 $n$ 同阶，所以这部分的复杂度为 $O(n^\frac{5}{3})$。  
不在同一块内，$l$ 移到下一块的移动复杂度为 $O(n^\frac{2}{3})$，块数为$n^\frac{1}{3}$，总复杂度为 $O(n)$。  
2.对于 $r$ 指针：  
若 $l$ 与 $r$ 此时都在同一个块内移动，那么单次移动的复杂度 $O(n^\frac{2}{3})$，一共有 $(n^\frac{1}{3})^2$ 次机会，总复杂度为 $O(n^\frac{4}{3})$ 的。  
若 $l$ 块不变，$r$ 块移动，那么移到下一个块的复杂度为 $O(n^\frac{2}{3})$，$r$ 一共有 $n^\frac{1}{3}$ 个这样的块，$l$ 相同，全部相乘后这部分复杂度为 $O(n^\frac{4}{3})$ 的。  
若 $l$ 块变化了，那么单次复杂度为 $O(n)$ 的，$l$ 一共有 $n^\frac{1}{3}$ 个这样的块，总复杂度为 $O(n^\frac{4}{3})$ 的。  
3,对于 $t$ 指针：  
若 $l,r$ 都在块内移动，那么其单调不减，单次复杂度 $O(n)$ ，$r$ 一共有 $n^\frac{1}{3}$ 个这样的块，$l$ 相同，乘起来复杂度为 $O(n^\frac{5}{3})$ 的。  
若 $l$ 块相同，$r$ 块移动，复杂度同上。  
若 $l$ 块移动，总复杂度为 $O(n^\frac{4}{3})$ 的。  
所以算法总复杂度为 $O(n^\frac{5}{3})$。
  
带修莫队具体的介绍在[这里](https://www.luogu.com.cn/problem/P1903)。  
code：  
```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int N=2e5+10;
int n,m,q,x,y;
vector <int> edge[N];
int v[N];int w[N];int c[N];
int opt;int cnt;int seq[N];ll ans[N];
int bucket[N];ll res;int a[N],b[N];
int st[N][21];int deep[N];
void build(int u,int fa){
	st[u][0]=fa;deep[u]=deep[fa]+1;
	for(int i=1;i<=20;i++)st[u][i]=st[st[u][i-1]][i-1];
	seq[a[u]=++cnt]=u;
	for(int i=0;i<edge[u].size();i++){
		int to=edge[u][i];
		if(to==fa)continue;
		build(to,u);
	}
	seq[b[u]=++cnt]=u;
}
int LCA(int x,int y){
	if(deep[x]<deep[y])swap(x,y);
	for(int i=20;i>=0;i--){
		if(deep[st[x][i]]>=deep[y])x=st[x][i];
	}
	if(x==y)return x;
	for(int i=20;i>=0;i--){
		if(st[x][i]!=st[y][i])
			x=st[x][i],y=st[y][i];
	}
	return st[x][0];
}
int l,r,block,tot1,tot2,p[N],last[N];bool vis[N];
struct Qry{int l,r,t,id;}Q[N];Qry up[N];
bool cmp(Qry a,Qry b){
	if(p[a.l]!=p[b.l])return a.l<b.l;
	else{
		if(p[a.r]!=p[b.r])return a.r<b.r;
		else return a.t<b.t;
	}
}
void add(int x){
	if(!vis[x])res+=(ll)w[++bucket[c[x]]]*v[c[x]];
	else res-=(ll)w[bucket[c[x]]--]*v[c[x]];
	vis[x]^=1;
}
void modify(int x,int y){
	if(vis[x]){add(x);c[x]=y;add(x);}
	else c[x]=y;
}
int main(){
	scanf("%d%d%d",&n,&m,&q);
	for(int i=1;i<=m;i++)scanf("%d",&v[i]);
	for(int i=1;i<=n;i++)scanf("%d",&w[i]);
	for(int i=1;i<n;i++){
		scanf("%d%d",&x,&y);
		edge[x].push_back(y);
		edge[y].push_back(x);
	}
	for(int i=1;i<=n;i++)
		scanf("%d",&c[i]),last[i]=c[i];
	build(1,0);block=pow(2*n,2.0/3.0);
	for(int i=1;i<=2*n;i++){
		if(i%block!=0)p[i]=(i/block)+1;
		else p[i]=i/block;
	}
	for(int i=1;i<=q;i++){
		scanf("%d%d%d",&opt,&x,&y);
		if(opt==0){
			up[++tot2].l=x;
			up[tot2].r=last[x];
			last[x]=up[tot2].t=y;
		}else{
			if(a[x]>a[y])swap(x,y);
			Q[++tot1]=(Qry){LCA(x,y)==x?a[x]:b[x],a[y],tot2,tot1};
		}
	}
	sort(Q+1,Q+1+tot1,cmp);
	int l=1;int r=0;int T=1;
	for(int i=1;i<=tot1;i++){
		while(T<=Q[i].t){modify(up[T].l,up[T].t);T++;}
		while(T>Q[i].t){modify(up[T].l,up[T].r);T--;}
		while(l>Q[i].l){l--;add(seq[l]);}
		while(l<Q[i].l){add(seq[l]);l++;}
		while(r>Q[i].r){add(seq[r]);r--;}
		while(r<Q[i].r){r++;add(seq[r]);}
		int x=seq[l];int y=seq[r];int lca=LCA(x,y);
		if(x!=lca&&y!=lca){add(lca);ans[Q[i].id]=res;add(lca);}
		else ans[Q[i].id]=res;
	}
	for(int i=1;i<=tot1;i++)printf("%lld\n",ans[i]);
	return 0;
}
```


---

## 作者：年华天地 (赞：0)

树上带修莫队的模板题
先安利一个将莫队比较好的博客  [戳我](https://www.cnblogs.com/WAMonster/p/10118934.html)

首先看这题，几个操作

1. 查询一条链的愉悦指数

2. 修改一个点的值

一般遇到这种单点修改区间查询的题莫队都可以做，首先考虑怎么处理这一条链，我们可以用[欧拉序](https://blog.csdn.net/m0_37809890/article/details/82856158?utm_source=blogxgwz6)把这一棵树转换为一个序列，这样，我们就可以在这个序列上进行愉快的莫队了。

我们把一点链转换成了一个区间以后修改呢？对于每一次查询，我们记录它的时间戳，也就是它是在第几次修改之后查询的，我们在记录当前的时间，然后暴力的去修改。

代码

```
#include<cstdio>
#include<cmath>
#include<algorithm>
#define ll long long
using namespace std;
struct llk
{
	int id,l,r,z,t1;
}q[200100];
struct llk2
{
	int to,next;
}e[200100];
struct llk3
{
	int p,c;
}cg[200100];
int lxwy=0,head[100010];
void adde(int u,int v)
{
	e[++lxwy].to=v;
	e[lxwy].next=head[u];
	head[u]=lxwy;
}
const int maxn=200010;
int n,m,a[200010],k,t[200010],qu;
int in[200010],st[200010],en[200010],cnt,w[200010];
int deep[200010],bo[200010];
int t1,t2,v[200010];
long long sum,ans[200010];
int f[maxn],size[maxn],son[maxn],d[maxn],top[maxn];
bool cmp(llk x,llk y)
{
	if(x.l/k!=y.l/k) return x.l/k<y.l/k; 
	return x.r<y.r; 
}
void dfs(int u,int fa)
{
	in[++cnt]=u; 
	st[u]=cnt; 
	for(int i=head[u];i;i=e[i].next)
	{
		int v=e[i].to;
		if(v==fa) continue; 
		dfs(v,u);
	}
	in[++cnt]=u;
	en[u]=cnt;
}
void dfs1(int x,int fa)
{
	f[x]=fa;
	size[x]=1;
	for (int i=head[x];i;i=e[i].next)
	{
		int y=e[i].to;
		if (y==fa)continue;
		d[y]=d[x]+1;
		dfs1(y,x);
		size[x]+=size[y];
		if (size[y]>size[son[x]])son[x]=y;
	}
}
void dfs2(int x,int tp)
{
	top[x]=tp;
	if (son[x])dfs2(son[x],tp);
	for (int i=head[x];i;i=e[i].next)
	{
		int y=e[i].to;
		if (y==f[x]||y==son[x])continue;
		dfs2(y,y);
	}
}
int lca(int x,int y)
{
	while (top[x]!=top[y])
	{
		if (d[top[x]]<d[top[y]])swap(x,y);
		x=f[top[x]];
	}
	return d[x]<d[y]?x:y;
}
void change(int x)
{
	if(bo[cg[x].p]==1)
	{
		t[cg[x].c]++;
		sum+=(long long)v[cg[x].c]*w[t[cg[x].c]];
		t[a[cg[x].p]]--;
		sum-=(long long)v[a[cg[x].p]]*w[t[a[cg[x].p]]+1];
	}
	swap(a[cg[x].p],cg[x].c);
}
void update(int x)
{
	if (x==0)return ;
	if (bo[x]==0)
	{
		t[a[x]]++;
		sum+=(ll)w[t[a[x]]]*v[a[x]];
	}
	else
	{
		sum-=(ll)w[t[a[x]]]*v[a[x]];
		t[a[x]]--;
	}
	bo[x]^=1;
}
int main()
{
	scanf("%d%d%d",&n,&m,&qu);
	k=pow(n,2.0/3); 
	for(int i=1;i<=m;i++) scanf("%d",&v[i]);
	for(int i=1;i<=n;i++) scanf("%d",&w[i]);
	for(int i=1;i<n;i++)
	{
		int x,y;
		scanf("%d%d",&x,&y);
		adde(x,y); adde(y,x);
	}
	for(int i=1;i<=n;i++)scanf("%d",&a[i]);
	dfs(1,1);
	dfs1(1,1);
	dfs2(1,1);
	for(int i=1;i<=qu;i++)
	{
		int op,x,y;
		scanf("%d%d%d",&op,&x,&y);
		if(op==0)
		{
			t1++;
			cg[t1].p=x;
			cg[t1].c=y;
		}
		else
		{
			t2++;
			q[t2].id=t2;
			q[t2].t1=t1;
			int p=lca(x,y);
			if(x==p||y==p)
			{
				if(st[x]>st[y]) swap(x,y); 
				q[t2].l=st[x],q[t2].r=st[y]; 
			} 
			else
			{
				if(en[y]<st[x]) swap(x,y); 
				q[t2].l=en[x],q[t2].r=st[y];
				q[t2].z=p;
			}
		}
	}
	sort(q+1,q+t2+1,cmp);
	int l=1,r=0,now=0;
	for(int i=1;i<=t2;i++)
	{
		llk s=q[i];
		while(l<s.l)update(in[l++]);
		while(l>s.l)update(in[--l]);
		while(r<s.r)update(in[++r]);
		while(r>s.r)update(in[r--]);
		while(now<s.t1)change(++now);
		while(now>s.t1)change(now--);
		if (s.z)update(s.z);
		ans[s.id]=sum;
		if (s.z)update(s.z);
	}
	for(int i=1;i<=t2;i++) printf("%lld\n",ans[i]);
}
```





---

## 作者：YinyuDream (赞：0)

# 题意
给定一棵树，树上有$m$种糖果,美味指数为$V_i$，共有$q$次操作，每次询问树上的一条路径$u->v$，第$i$次品尝$j$种糖果的新奇指数为$W_i$，并且愉悦指数$H$增加$V_j \times W_i$，求最终的愉悦指数或把点$x$的糖果类型改为$y$。
# 题解
树上带修改莫队。
- 考虑把树用欧拉序变成序列,对于每一条询问的路径，可以转化为在序列上的询问。如果两个点的LCA不等于其中之一，序列上的区间应该为两个点在欧拉序上第一次的位置之间的区间∪LCA，否则，序列上的区间应为第一个点后出现的位置到第二个点第一次出现的位置。在区间内，只有出现一次的点才会被记入答案。

- 维护当前区间内各种颜色出现的次数。当区间内的某个点的个数变为1时，愉悦指数增加(该点的颜色出现次数+1)$\times$该点颜色的美味指数，同时，该颜色出现次数+1.

- 对于修改操作，可以仿照普通带修改莫队，增加一维时间戳，记录每次查询操作在第几次修改操作之后以及当前序列是第几次修改操作之后的。当序列的时间戳i小于询问的时间戳j时，执行j到i的修改操作，反之，还原i到j的修改操作。如果修改的节点在询问的节点之中，维护相应的信息。

# 代码
```cpp
#include<cmath>
#include<cstdio>
#include<algorithm>
using namespace std;
const int maxn=1e6+10;
int n,m,q,k,cnt,t1,t2,l=1,r,now,block;
int v[maxn],w[maxn],a[maxn];
long long num,ans[maxn];
struct node{
    int to,next;
}edge[maxn];
struct query{
    int l,r,lca,id,t;
}que[maxn];
struct Change{
    int pos,color;
}c[maxn];
int head[maxn];
int first[maxn],last[maxn],euler[maxn];
int fa[maxn],son[maxn],top[maxn],size[maxn],deep[maxn];
int book[maxn],flag[maxn];
int read()
{
    int x=0;
    char ch=getchar();
    while(ch<'0'||ch>'9')
    ch=getchar();
    while(ch<='9'&&ch>='0')
    x=x*10+ch-48,
    ch=getchar();
    return x;
}
bool cmp(query a,query b)
{
    if(a.l/block==b.l/block)
    return a.r<b.r;
    else 
    return a.l/block<b.l/block;
}
void add(int u,int v)
{
    edge[++k].to=v;
    edge[k].next=head[u];
    head[u]=k;
}
void dfs1(int u,int f)
{
    first[u]=++cnt;
    euler[cnt]=u;
    size[u]=1;
    for(int i=head[u];i;i=edge[i].next)
    {
        int v=edge[i].to;
        if(v!=f)
        {
            deep[v]=deep[u]+1;
            dfs1(v,u);
            fa[v]=u;
            size[u]+=size[v];
            if(size[son[u]]<size[v])
            son[u]=v; 
        }
    }
    last[u]=++cnt;
    euler[cnt]=u;
}
void dfs2(int u,int tp)
{
    top[u]=tp;
    if(son[u])
    dfs2(son[u],tp);
    for(int i=head[u];i;i=edge[i].next)
    {
        int v=edge[i].to;
        if(v!=fa[u]&&v!=son[u])
        dfs2(v,v);
    }
}
int lca(int u,int v)
{
    while(top[u]!=top[v])
    {
        if(deep[top[u]]<deep[top[v]])
        swap(u,v);
        u=fa[top[u]];
    }
    return deep[u]<deep[v]?u:v;
}
void update(int pos)
{
    if(flag[pos]==0){
        book[a[pos]]++;
        num+=(long long)v[a[pos]]*w[book[a[pos]]];
    }else{
        book[a[pos]]--;
        num-=(long long)v[a[pos]]*w[book[a[pos]]+1];
    }
    flag[pos]^=1;
}
void change(int tme)
{
    if(flag[c[tme].pos]==1)
    {
        book[c[tme].color]++;
        num+=(long long)v[c[tme].color]*w[book[c[tme].color]];
        book[a[c[tme].pos]]--;
        num-=(long long)v[a[c[tme].pos]]*w[book[a[c[tme].pos]]+1];
    }
    swap(c[tme].color,a[c[tme].pos]);
}
int main(){
    n=read();m=read();q=read();
    for(int i=1;i<=m;i++)
    v[i]=read();
    for(int i=1;i<=n;i++)
    w[i]=read();
    for(int i=1;i<n;i++)
    {
        int u=read(),v=read();
        add(u,v);
        add(v,u);
    }
    for(int i=1;i<=n;i++)
    a[i]=read();
    dfs1(1,1);
    dfs2(1,1);
    for(int i=1;i<=q;i++)
    {
        int opt=read(),x=read(),y=read();
        if(opt==0){
            t1++;
            c[t1].pos=x;
            c[t1].color=y;
        }else{
            t2++;
            que[t2].t=t1;
            que[t2].id=t2;
            que[t2].lca=lca(x,y);
            if(first[x]>first[y])
            swap(x,y);
            if(que[t2].lca==x){
                que[t2].l=first[x];
                que[t2].r=first[y];
                que[t2].lca=0;
            }else{
                que[t2].l=last[x];
                que[t2].r=first[y];
            }
        }
    }
    block=pow(n,2.0/3);
    sort(que+1,que+t2+1,cmp);
    for(int i=1;i<=t2;i++)
    {
        while(l<que[i].l)update(euler[l++]);
        while(l>que[i].l)update(euler[--l]);
        while(r<que[i].r)update(euler[++r]);
        while(r>que[i].r)update(euler[r--]);
        while(now<que[i].t)change(++now);
        while(now>que[i].t)change(now--);
        if(que[i].lca)update(que[i].lca);
        ans[que[i].id]=num;
        if(que[i].lca)update(que[i].lca);
    }
    for(int i=1;i<=t2;i++)
    printf("%lld\n",ans[i]);
    return 0;
}
```


---


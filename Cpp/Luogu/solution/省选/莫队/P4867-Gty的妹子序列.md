# Gty的妹子序列

## 题目描述

Autumn 和 Bakser 又在研究 Gty 的妹子序列了！但他们遇到了一个难题。

对于一段妹子们，他们想让你帮忙求出这之内美丽度 $\in[a,b]$ 的妹子的美丽度的种类数。

为了方便，我们规定妹子们的美丽度全都在 $[1,n]$ 中。

给定一个长度为 $n(1\le n\leq 10^5)$ 的正整数序列 $s(1\le s_i\le n)$，对于 $m(1\le m\le 10^6)$ 次询问 $l,r,a,b$，每次输出 $s_l\cdots s_r$ 中，权值 $\in[a,b]$ 的权值的种类数。

## 说明/提示

【样例的部分解释】
 
`5 9 1 2 `
子序列为`4 1 5 1 2`  
在[1,2]里的权值有1,1,2，有2种，因此答案为2。  

`3 4 7 9`  
子序列为`5 1 ` 
在[7,9]里的权值有5，有1种，因此答案为1。  

`4 4 2 5`  
子序列为`1`  
没有权值在[2,5]中的，因此答案为0。  

`2 3 4 7`  
子序列为`4 5`  
权值在[4,7]中的有4,5，因此答案为2。  

建议使用输入/输出优化。  

## 样例 #1

### 输入

```
10 10
4 4 5 1 4 1 5 1 2 1
5 9 1 2
3 4 7 9
4 4 2 5
2 3 4 7
5 10 4 4
3 9 1 1
1 4 5 9
8 9 3 3
2 2 1 6
8 9 1 4```

### 输出

```
2
0
0
2
1
1
1
0
1
2```

# 题解

## 作者：囧仙 (赞：15)

截至目前（2020.7.21）本题所有题解都是莫队 + 值域分块 / 值域树状数组，但是这道题实际上是有 poly log 解法的

- **分析**

  注意到这题是一个带有值域限制的区间数颜色，而区间数颜色是有 poly log 解法的，可以看 [这道题](https://www.luogu.com.cn/problem/P1972) 的题解，不过这里还是稍微介绍一下
  
  那题常数较小 ~~也是唯一能过的~~ 的做法是这样的：
  
  对于所有询问按右端点 $r$ 排序，然后将 $i$ 从 $1$ 到 $n$ 扫一遍，每次在一个以原数组下标为编号的树状数组上，在 $i$ 的位置加 $1$，在 $[1,i - 1]$ 中最后一个与 $i$ 同色的位置减 $1$，$i$ 移动到 $r$ 时，查 $[l,r]$ 的和就是颜色数
  
  这实际上是一种 “同色点只数最右边一个” 的思想，每次当 $i$ 出现时，$[1,i - 1]$ 中与 $i$ 同色的点必定不是最右边一个了
  
  接下来考虑把这个做法搬到这道题上
  
  实际上并不需要做太大的改动，我们还是可以使用 “同色点只数最右边一个” 的思想，每次在遇到一个新的 $a_i$ 时加入 $a_i$，删去与 $a_i$ 值相同的上一个点
  
  原来的做法是维护一个只有 (下标) 一维信息的树状数组，改为维护两个信息 (下标,值)，然后每次查询下标在 $[l,r]$ 内，且值在 $[a,b]$ 内有多少个点就可以了
  
  注意到这题要求线性空间，可以使用 cdq分治 来解决这个问题
  
  时间复杂度：$O((n + m) \log ^ 2 n)$，空间复杂度：$O(n + m)$
  
  代码：莫得
  
  因为这题实在是太卡空间了…… 连空间消耗较小的莫队都是贴着边过的，这个做法的空间消耗肯定更大，八成过不了……

---

## 作者：VTloBong (赞：8)

# 题意
给出一个有 n 个数的序列，对该序列有 m 个询问，对于每次询问，输出区间 $[l,r]$ 内,权值在区间 $[a,b]$ 中的权值的种类数。    
# 思路
一个区间内某个数的出现次数难以用树型数据结构来维护，但离线算法——莫队可以轻松维护。    
如果平衡树或权值线段树来维护权值，那么每进行一次 区间调整（一次 add 或 一次 del），都需要 $O(\log n)$的复杂度来进行插入或删除操作，总的时间复杂度会达到 $O(n \sqrt{n}\log n)$ ,由于 $N,M≤1000000$ ，所以无法AC此题。   
观察莫队算法和数据范围，会发现插入或删除操作次数即区间调整次数,为 $O(n \sqrt{n})$ 级别，查询操作的次数为 n ，所以我们需要一个 $O(1)$ 插入/删除, $O(\sqrt{n})$ 或低于 $O(\sqrt{n})$ 的复杂度查询在区间 $[a,b]$ 中的权值的数据结构/算法。   
值域分块便可以 $O(1)$ 插入/删除, $O(\sqrt{n})$ 查询，若用莫队+值域分块，总的时间复杂度为 $O(n \sqrt{n})$ ,由于 $N,M≤1000000$ ，所以可以AC此题。   
**血的教训：**  
**1. 本题 $1≤s_i≤n$ ,可以不离散化；但如果离散化了，要记得把询问里的 a 和 b 转化为离散化后的数。**    
**2. 如果TLE，那就卡卡常。**
# 代码
码风丑陋，请见谅。   
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
const int maxn=1000005,sqrn=1005;
struct query{
	int l,r,A,B,id;
}q[maxn];
int a[maxn],cnt[maxn],num[sqrn],b[maxn],bl[sqrn],br[sqrn],ls=1,rs,size,f[maxn],n,m;
bool cmp(query x,query y){
    return (x.l-1)/size==(y.l-1)/size?(((x.l-1)/size)&1?x.r<y.r:x.r>y.r ):(x.l-1)/size<(y.l-1)/size; 
}
inline void add(int k){
	cnt[a[k]]++;
	if(cnt[a[k]]==1)num[b[a[k]]]++;
}
inline void del(int k){
	cnt[a[k]]--;
	if(!cnt[a[k]])num[b[a[k]]]--;
}
inline void query(int d){
	int x=q[d].A,y=q[d].B,k=q[d].id;
	for(int i=x;i<=y&&i<=br[b[x]];i++)
		if(cnt[i])f[k]++;
	if(b[x]!=b[y])
		for(int i=bl[b[y]];i<=y;i++)
		 	if(cnt[i])f[k]++;
	for(int i=b[x]+1;i<b[y];i++)
		f[k]+=num[i];
}
int main(){
	scanf("%d%d",&n,&m);
	for(register int i=1;i<=n;++i)
		scanf("%d",a+i);//lsh[i].id=i,scanf("%d",&lsh[i].data);
	//sort(lsh+1,lsh+n+1,cmp1);
//	for(int i=1;i<=n;i++){
	//	if(lsh[i].data!=lsh[i-1].data||i==1)num[0]++;
//		a[lsh[i].id]=num[0];
//	}//惨痛的教训
	for(size=1;size*size<n;size++);
	for(register int i=1;i<=m;++i)
		q[i].id=i,scanf("%d%d%d%d",&q[i].l,&q[i].r,&q[i].A,&q[i].B );
	sort(q+1,q+m+1,cmp),num[0]=0;
	for(register int i=1;i<=n;i++)b[i]=(i-1)/size+1;
    for(register int i=1;i<=b[n];i++)bl[i]=(i-1)*size+1,br[i]=i*size;
    br[b[n]]=n;
	for(register int i=1;i<=m;++i){
		int nl=q[i].l ,nr=q[i].r ;
		while(rs<nr)rs++,add(rs);
		while(ls>nl)ls--,add(ls);
		while(ls<nl)ls++,del(ls-1);
		while(rs>nr)rs--,del(rs+1);
		query(i);
	}for(register int i=1;i<=m;++i)printf("%d\n",f[i]);
	return 0;
}
```
# 举一反三
几道其他的莫队+值域分块的题
1. [P4396 [AHOI2013]作业](https://www.luogu.com.cn/problem/P4396) 
1. [	
P3730 曼哈顿交易](https://www.luogu.com.cn/problem/P3730)   
1. 咕咕咕



---

## 作者：FjswYuzu (赞：7)

我们要维护区间内元素种数。

先考虑一般情况，问题变为区间内元素种数。这是一个经典的莫队问题，可以用 $O(n\sqrt n)$ 的时间复杂度解决问题。

但是对于这道题，元素有一定限制：我们要求 $val \in [a,b]$ 的种数。首先容斥一下，我们要求出 $val \in [1,b]$ 的种数 $p$，再求出 $val \in [1,a-1]$ 的种数 $q$，这个询问的答案即为 $p-q$。

再回去看值域，只有 $10^5$，所以我们可以直接用树状数组维护。时间复杂度 $O(n\sqrt n \log n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
int pos[1000005],n,p,m,a[100005],gr,cnt[100005],ans[1000005];
struct queries{
    int l,r,a,b,id;
    queries(){l=r=a=b=id=0;}
    queries(int L,int R,int A,int B,int ID){l=L,r=R,a=A,b=B,id=ID;}
    bool operator < (queries another) const {
        if(pos[l]==pos[another.l])  return r<another.r;
        return l<another.l;
    }
}que[1000005];
struct BinaryIndexedTree{
    int a[100005];
    int lowbit(int x){return x&(-x);}
    void modify(int x,int val){for(int i=x;i<=n;i+=lowbit(i))   a[i]+=val;}
    int query(int x)
    {
        int ans=0;
        while(x)    ans+=a[x],x-=lowbit(x);
        return ans;
    }
}bit;
void add(int x)
{
	x=a[x];
	if(!cnt[x])	bit.modify(x,1);
	++cnt[x];
}
void sub(int x)
{
	x=a[x];
	--cnt[x];
	if(!cnt[x])	bit.modify(x,-1);
}
int main(){
	scanf("%d %d",&n,&m);
	p=sqrt(n);
	for(int i=1;i<=n;++i)	scanf("%d",&a[i]),pos[i]=(i-1)/p+1;
	for(int i=1;i<=m;++i)
	{
		int l,r,a,b;
		scanf("%d %d %d %d",&l,&r,&a,&b);
		que[i]=queries(l,r,a,b,i);
	}
	sort(que+1,que+1+m);
	for(int i=1,l=1,r=0;i<=m;++i)
	{
		while(l>que[i].l)	add(--l);
		while(l<que[i].l)	sub(l++);
		while(r<que[i].r)	add(++r);
		while(r>que[i].r)	sub(r--);
		ans[que[i].id]=bit.query(que[i].b)-bit.query(que[i].a-1);
	}
	for(int i=1;i<=m;++i)	printf("%d\n",ans[i]);
	return 0;
}
```

---

## 作者：Treaker (赞：7)

## 一眼莫队
等等，好像不太对劲，还让我们维护$~[a,b]~$的种类数，肿么办呢?

发现$~a,b~\in[1,n]$，这好像是个很好的东西。

再想想怎么维护呢？

发现存在一个叫值域分块的东西~~分块大法吼啊~~。

哈哈哈，这不就是个裸题了嘛。  切掉

完整代码如下：
```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <queue>
#include <cmath>
using namespace std;
const int N = 1000010;
inline int read()
{
	int x = 0 , f = 1;	char ch = getchar();
	while(ch < '0' || ch > '9')	{if(ch == '-')	f = -1; ch = getchar();}
	while(ch >= '0' && ch <= '9') {x = (x << 3) + (x << 1) + (ch ^ 48); ch = getchar();}
	return x * f;
}
int n , m , len;
int a[N] , L[1010] , R[1010] , pos[N] , sum[1010] , c[N] , ans[N];
struct node
{
	int l , r , x , y , id;
	friend bool operator < (const node & a,const node & b) {return pos[a.l] == pos[b.l] ? a.r < b.r : pos[a.l] < pos[b.l];}
}e[N];
inline void add(int x) {if(++ c[x] == 1) sum[pos[x]] ++;}
inline void del(int x) {if(-- c[x] == 0) sum[pos[x]] --;}
inline int query(int l,int r)
{
	int res = 0;
	if(pos[l] == pos[r]) 
	{
		for(int i = l;i <= r;i ++)	res += (c[i] > 0);
		return res;
	}
	for(int i = l;i <= R[pos[l]];i ++)	res += (c[i] > 0);
	for(int i = L[pos[r]];i <= r;i ++)	res += (c[i] > 0);
	for(int i = pos[l] + 1;i < pos[r];i ++)	res += sum[i];
	return res;
}
int main()
{
	n = read(); m = read(); len = sqrt(n);
	memset(L,127,sizeof L);
	for(int i = 1;i <= n;i ++)	
	{
		a[i] = read();
		pos[i] = (i - 1) / len + 1;
		L[pos[i]] = min(L[pos[i]],i);
		R[pos[i]] = max(R[pos[i]],i);
	}
	for(int i = 1;i <= m;i ++)
	{
		e[i].l = read(); e[i].r = read();
		e[i].x = read(); e[i].y = read(); e[i].id = i;
	}
	sort(e+1,e+1+m);
	int l = 1 , r = 0;
	for(int i = 1;i <= m;i ++)
	{
		while(r < e[i].r) add(a[++r]);
		while(r > e[i].r) del(a[r--]);
		while(l < e[i].l) del(a[l++]);
		while(l > e[i].l) add(a[--l]);
		ans[e[i].id] = query(e[i].x,e[i].y);
	}
	for(int i = 1;i <= m;i ++)	printf("%d\n",ans[i]);
	return 0;
}

```


---

## 作者：day_dream (赞：4)

这题很容易想到莫队，但是我们发现对于这题，插入和删除都是$O(n\sqrt{m})$的，而询问只有$O(m)$，所以像第一篇题解那样用树状数组是非常浪费的，我们考虑平衡一下插入删除和询问的时间。

我们可以考虑对权值分块，这样插入删除的复杂度就是$O(1)$的，而询问的复杂度变成了$O(\sqrt{n})$的，这样总的复杂度就是$O(n\sqrt{m}+m\sqrt{n})$的了。

有人觉得这个复杂度不对，但算一下，其实这个复杂度非常对。

```
#include<algorithm>
#include<cstdio>
#include<cmath>
#define mxn 100010
#define mxm 1000010
using namespace std;
int n,m,Q,sl,fh,s[mxn],pos[mxn],sum[320],num[mxn],ans[mxm];
struct ask
{
    int l,r,a,b,id;
    bool operator <(const ask &x)const {return pos[l]<pos[x.l]||(pos[l]==pos[x.l]&&r<x.r);}
}q[mxm];
int rd()
{
    sl=0;fh=1;
    char ch=getchar();
    while(ch<'0'||'9'<ch) {if(ch=='-') fh=-1; ch=getchar();}
    while('0'<=ch&&ch<='9') sl=sl*10+ch-'0',ch=getchar();
    return sl*fh;
}
void add(int i)
{
    num[s[i]]++;
    sum[pos[s[i]]]+=num[s[i]]==1;
}
void del(int i)
{
    num[s[i]]--;
    sum[pos[s[i]]]-=num[s[i]]==0;
}
int query(int l,int r)
{
    int cnt=0,L=pos[l],R=pos[r];
    if(L==R)
    {
        for(int i=l;i<=r;++i) cnt+=num[i]>0;
        return cnt;
    }
    for(int i=L+1;i<R;++i) cnt+=sum[i];
    for(int i=l;i<=(L+1)*m;++i) cnt+=num[i]>0;
    for(int i=R*m+1;i<=r;++i) cnt+=num[i]>0;
    return cnt;
}
int main()
{
    n=rd();Q=rd();m=sqrt(n);
    for(int i=1;i<=n;++i) s[i]=rd(),pos[i]=(i-1)/m;
    for(int i=1;i<=Q;++i)
    {
        q[i].l=rd();q[i].r=rd();
        q[i].a=rd();q[i].b=rd();
        q[i].id=i;
    }
    sort(q+1,q+Q+1);int l=1,r=0;
    for(int i=1;i<=Q;++i)
    {
        while(l>q[i].l) add(--l);
        while(l<q[i].l) del(l++);
        while(r<q[i].r) add(++r);
        while(r>q[i].r) del(r--);
        ans[q[i].id]=query(q[i].a,q[i].b);
    }
    for(int i=1;i<=Q;++i) printf("%d\n",ans[i]);
    return 0;
}
```

---

## 作者：little_sun (赞：3)

这种题一看直接莫队啊

但是我们要想想怎么修改

一开始我想树状数组，但是我不会写o((⊙﹏⊙))o

后来看了一下题解，发现可以将值域分块，这样就可以做到查询$O(\sqrt n)$，修改$O(1)$了

总复杂度$O(m \sqrt n)$

（代码的$ask$部分参考了一下标程，思路参考了第一篇题解，请见谅）
```cpp
#include <bits/stdc++.h>
#define getindex(x) ((x - 1) * block + 1)
#define getpos(x) ((x - 1) / block + 1)
const int MaxN = 1e5 + 10, MaxM = 1e6 + 10;
struct query
{
    int id, pos;
    int l, r, a, b;
};
query q[MaxM];
int n, m, size, block;
int a[MaxN], ans[MaxM], cnt[MaxN], sum[MaxN];
inline int cmp(query a, query b)
{
    if (a.pos != b.pos)
        return a.pos < b.pos;
    return a.r < b.r;
}
inline int read()
{
    int x = 0;
    char ch = getchar();
    while (ch > '9' || ch < '0')
        ch = getchar();
    while (ch <= '9' && ch >= '0')
        x = (x << 1) + (x << 3) + (ch ^ 48), ch = getchar();
    return x;
}
inline void ins(int x)
{
    ++cnt[a[x]];
    if (cnt[a[x]] == 1)
        ++sum[getpos(a[x])];
}
inline void del(int x)
{
    --cnt[a[x]];
    if (cnt[a[x]] == 0)
        --sum[getpos(a[x])];
}
inline int ask(int a, int b, int l, int r)
{
    int ans = 0, Posl = getpos(l), Posr = getpos(r);
    for (int i = Posl + 1; i < Posr; i++)
        ans += sum[i];
    if (Posl == Posr)
    {
        for (int i = l; i <= r; i++)
            if (cnt[i])
                ++ans;
    }
    else
    {
        int L = getindex(Posr), R = getindex(Posl + 1) - 1;
        for (int i = l; i <= R; i++)
            if (cnt[i])
                ++ans;
        for (int i = L; i <= r; i++)
            if (cnt[i])
                ++ans;
    }
    return ans;
}
inline void solve()
{
    int l = 1, r = 0;
    for (int i = 1; i <= m; i++)
    {
        while (l > q[i].l)
            l--, ins(l);
        while (r < q[i].r)
            r++, ins(r);
        while (l < q[i].l)
            del(l), l++;
        while (r > q[i].r)
            del(r), r--;
        ans[q[i].id] = ask(q[i].l, q[i].r, q[i].a, q[i].b);
    }
}
int main()
{
    n = read(), m = read();
    size = pow(n, 0.55), block = sqrt(n);
    for (int i = 1; i <= n; ++i)
        a[i] = read();
    for (int i = 1; i <= m; ++i)
    {
        q[i].l = read(), q[i].r = read();
        q[i].a = read(), q[i].b = read();
        q[i].id = i, q[i].pos = (q[i].l - 1) / size + 1;
    }
    std::sort(q + 1, q + m + 1, cmp);
    solve();
    for (int i = 1; i <= m; i++)
        printf("%d\n", ans[i]);
    return 0;
}
```

---

## 作者：Ireliaღ (赞：3)

看见这题内存只开了`30MiB`，我们只能考虑使用莫队。

由于需要在值域区间查询，我们需要一种能$O(1)$修改，$O(\sqrt n)$以内查询的数据结构，我们可以使用值域分块。

值域分块的块大小开$\sqrt n$最优毋庸置疑，但是看很多题解莫队的块开的$\sqrt m$，个人感觉有点草率。

考虑$n$和$m$的数量级略有差异，我们可以自己解均值不等式。

我们设块的大小为$l$，数组长度为$n$，询问个数为$m$

莫队的左端点每次询问都在一个块内来回溜达，每次最坏移动长度为$l$，那么左端点移动总复杂度为$ml$

对于左端点在同一个块的询问，右端点会单调朝一个方向走，最坏移动$n$，我们有$\frac{n}{l}$块，所以右端点移动总复杂度为$\frac{n^2}{l}$

那么莫队的总复杂度为$O(ml + \frac{n^2}{l})$，由于$m$和$n$在输入时就确定了，那么$mn^2$就确定了。根据均值不等式，上面的式子在$ml = \frac{n^2}{l}$时最小，解得$l=\sqrt {\frac{n^2}{m}}$。也就是说块开到这么大时复杂度最优。

代码如下

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <algorithm>

using namespace std;
const int MAXN = 2e5 + 5;
const int MAXM = 2e6 + 5;

int n, m;
int a[MAXN];
int blo[MAXM], block;
int ans[MAXM];

struct Query{
	int l, r, mn, mx, id;
}qs[MAXM];

int Comp(const Query &a, const Query &b) {
	if (blo[a.l] == blo[b.l]) {
		if (blo[a.l] & 1) return a.r < b.r;
		else return a.r > b.r;
	}
	return a.l < b.l;
}

namespace Blocks{
	int num[MAXN], vis[MAXN];
	int block, blo[MAXN];
	int sum[1000];
	
	void Init() {
		block = sqrt(n);
		for (int i = 1; i <= n; i++) blo[i] = (i - 1) / block + 1;
	}
	
	void Add(int x) {
		if (!num[x]) {
			sum[blo[x]]++;
			vis[x] = 1;
		}	
		num[x]++;
	}
	
	void Del(int x) {
		num[x]--;
		if (!num[x]) {
			sum[blo[x]]--;
			vis[x] = 0;
		}
	}
	
	int Query(int l, int r) {
		int res = 0;
		while (l % block != 1 && l <= r) res += vis[l++];
		while (r % block != 0 && l <= r) res += vis[r--];
		while (l <= r) {
			res += sum[blo[l]];
			l += block;
		}
		return res;
	}
}

void Prework() {
	block = sqrt(1.0 * n * n / m);
	for (int i = 1; i <= m; i++) blo[i] = (i - 1) / block + 1;
	Blocks::Init();
}

void CaptainMo() {
	int nl = 1, nr = 0;
	using Blocks::Add;
	using Blocks::Del;
	for (int i = 1; i <= m; i++) {
		int l = qs[i].l, r = qs[i].r, mn = qs[i].mn, mx = qs[i].mx, id = qs[i].id;
		while (nr < r) Add(a[++nr]);
		while (nr > r) Del(a[nr--]);
		while (nl < l) Del(a[nl++]);
		while (nl > l) Add(a[--nl]);
		ans[id] = Blocks::Query(mn, mx);
	}
}

int main() {
	ios::sync_with_stdio(false); cin.tie(NULL);
	cin >> n >> m;
	for (int i = 1; i <= n; i++) cin >> a[i];
	Prework();
//	cerr << "*";
	for (int i = 1; i <= m; i++) {
		cin >> qs[i].l >> qs[i].r >> qs[i].mn >> qs[i].mx;
		qs[i].id = i;
	}
	sort(qs + 1, qs + m + 1, Comp);
	CaptainMo();
	for (int i = 1; i <= m; i++) cout << ans[i] << '\n';
	return 0;
}
```

你交上去不会AC，好好看看应该改哪

---

## 作者：ww3113306 (赞：3)

莫队暴力过百万系列233333

这题和AHOI2013作业第二问一模一样，但数据范围大10倍。

但是空间居然只有30M，，，，
```cpp
#include<bits/stdc++.h>
using namespace std;
#define R register int
#define AC 100100
#define ac 1000010

int n, m, cnt, block;
int ans[ac], s[AC], tot[AC];

struct node{
    int l, r, a, b, id;
}q[ac];

inline int lowbit(int x)
{
    return x & (-x);
}

struct kkk{
    int a[AC];
    
    void add(int x, int y)
    {
        for(R i = x; i <= n; i += lowbit(i)) a[i] += y;
    }
    
    int find(int x)
    {
        int rnt = 0;
        for(R i = x; i; i -= lowbit(i)) rnt += a[i];
        return rnt;
    }
}c2;

inline int read()
{
    int x = 0;char c = getchar();
    while(c > '9' || c < '0') c = getchar();
    while(c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();
    return x;
}

inline bool cmp(node a, node b)
{
    if(a.l / block != b.l / block) return a.l < b.l;
    else return a.r < b.r;//分块排序
}

void pre()
{
    n = read(), m = read(), block = sqrt(n);
    for(R i = 1; i <= n; i ++) s[i] = read();
    for(R i = 1; i <= m; i ++)
    {
        q[i].l = read(), q[i].r = read(), q[i].id = i;
		q[i].a = read(), q[i].b = read();
    }
    sort(q + 1, q + m + 1, cmp);
}

void add(int x)
{
    if(!tot[x]) c2.add(x, 1);
    ++ tot[x];
}

void del(int x)
{
    -- tot[x];
    if(!tot[x]) c2.add(x, -1);
}

void work()//这里每个点的贡献与区间无关，相对独立，所以不用考虑顺序问题
{
    int l, r;
    for(R i = q[1].l; i <= q[1].r; i ++) add(s[i]);
    ans[q[1].id] = c2.find(q[1].b) - c2.find(q[1].a - 1);
    l = q[1].l, r = q[1].r;
    for(R i = 2; i <= m; i ++)
    {
        int ll = q[i].l, rr = q[i].r;
        while(ll < l) -- l, add(s[l]);
        while(ll > l) del(s[l]), ++ l;
        while(rr > r) ++ r, add(s[r]);
        while(rr < r) del(s[r]), -- r;
        ans[q[i].id] = c2.find(q[i].b) - c2.find(q[i].a - 1);
    }
    for(R i = 1; i <= m; i ++) printf("%d\n", ans[i]);
}

int main()
{
	freopen("in.in", "r", stdin);
    pre();
    work();
	fclose(stdin);
    return 0;
}

```

---

## 作者：wlj_55 (赞：1)

看到这道题，首先可以想到用莫队处理区间上的问题，那么对于从区间$[L,R]$扩至区间$[L,R+1]$时增加的贡献的处理有两种思路：
### 法1$(O(n\sqrt n\log n))$：
我们用~~常数小的~~线段树或树状数组记录一个$f$数组，$f[i]$表示美丽度在$[1,i]$中的美丽度的种类数。

查询时将区间$[a,b]$拆为$[1,a-1]$与$[1,b]$，新加入一个数$x$时用线段树等数据结构将$f[x]$到$f[b]$的值全部$+1$，查询时统计即可。
### 法2:$(O(n\sqrt n))$：
用值域分块，写法还是记录每个数的出现次数，思想同[HH的项链](https://www.lydsy.com/JudgeOnline/problem.php?id=1878)，如果新出现了一个数就$O(1)$修改这个数所在的块出现的总种类数，最后再$O(\sqrt n)$统计即可。

区间收缩时减去贡献即可。
## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
int Read(){
	int x=0,f=1;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')  f=-1;ch=getchar();}
	while(isdigit(ch)){x=(x<<3)+(x<<1)+ch-'0';ch=getchar();}
	return x*f;
}
int n,m,a[100005],base,L[1005],R[1005],belong[100005],cnt=0,ans[1000005];
int sum[100005],s[100005],ss[100005];
struct que{
	int l,r,a,b,id;
}q[1000005];
bool operator < (que x,que y){
	if(belong[x.l]!=belong[y.l])  return belong[x.l]<belong[y.l];
	return x.r<y.r;
}
void Del(int pos){
	s[a[pos]]--;
	if(s[a[pos]]==0)  sum[belong[a[pos]]]--,ss[a[pos]]=0;
}
void Ins(int pos){
	s[a[pos]]++;
	if(s[a[pos]]==1)  sum[belong[a[pos]]]++,ss[a[pos]]=1;
}
int calc(int l,int r){
	int l1=belong[l],r1=belong[r],res=0;
	for(int i=l1+1;i<=r1-1;i++){
		res+=sum[i];
	}
	for(int i=l;i<=min(R[l1],r);i++){
		res+=ss[i];
	}
	if(r<=R[l1])  return res;
	for(int i=L[r1];i<=r;i++)  res+=ss[i];
	return res;
}
void solve(){
	int l=1,r=0;
	for(int i=1;i<=m;i++){
		while(q[i].l>l)  Del(l++);
		while(q[i].l<l)  Ins(--l);
		while(q[i].r<r)  Del(r--);
		while(q[i].r>r)  Ins(++r);
		ans[q[i].id]=calc(q[i].a,q[i].b);
	}
	for(int i=1;i<=m;i++){
		cout<<ans[i]<<endl;
	}
}
int main(){
	n=Read(),m=Read();
	for(int i=1;i<=n;i++)  a[i]=Read();
	for(int i=1;i<=m;i++){
		q[i].l=Read(),q[i].r=Read();
		q[i].a=Read(),q[i].b=Read();
		q[i].id=i;
	}
	base=sqrt(n);
	for(int i=1;i<=n;i+=base){
		L[++cnt]=i,R[cnt]=i+base-1;
	}
	R[cnt]=n;
	for(int i=1;i<=cnt;i++){
		for(int j=L[i];j<=R[i];j++){
			belong[j]=i;
		}
	}
	sort(q+1,q+m+1);
	solve();
	return 0;
}
```


---

## 作者：ViXbob (赞：1)

[博客推广](https://www.vixbob-lwc.pw)

鉴于这道题的唯一一篇题解的复杂度都有问题

所以我来发一篇复杂度比较正确的题解吧

首先莫队肯定是可以搞的， 而且毒瘤的出题人只给了 $30MB$ 空间， 莫队的空间复杂度是 $O(n)$ 的， 也比较符合这一点

与以往不一样的是， 我们在移动莫队的指针时要支持维护一个区间和， 考虑到修改的次数和移动的次数不在一个数量级上， 修改的次数要比查询的次数要多得多， 所以我们考虑一个可以支持 $O(1)$ 修改， 但查询复杂度没那么优秀的数据结构

我们考虑分块！

这样就可以让修改的复杂度降到 $O(1)$ 了, 但查询是 $O(\sqrt{n})$

总复杂度为 $O(m\sqrt{n})$ 的， 相比用树状数组的复杂度 $O(m \sqrt{n} \cdot logn)$ 还是要优秀很多的

---

## 作者：critnos (赞：0)

这道题显然是弄个莫队然后套个可以维护域值上的区间加的数据结构。

一般来说我们会想到树状数组。

但是这道题的 $m$ 过大，以至于树状数组的 $O(n\sqrt m \log n)$ 很难过。

当然用奇偶排序+块长取 $\sqrt n$ 是珂以过的。

然后另一个做法是用分块做。

因为添加点的复杂度是 $O(1)$ 然后求区间加是 $O(\sqrt n)$。

所以时间复杂度是 $O(n\sqrt m+m\sqrt n)$。

然后介绍一下分块的简单做法。

因为这个有区间可减性所以弄个求 $sum$ 的函数直接求 $sum(r)-sum(l-1)$ 就好。

也不用维护什么块边的，直接随便搞，长度和树状数组差不多。

因为树状数组比较简单就不放了。

放一下这个分块科技。

```cpp
int len;
int t1[10005];
int t2[100005];
void insert(int w,int v)
{
	t1[w/len]+=v;
	t2[w]+=v;
}
int sum(int k)
{
	int i,sum=0;
    for(i=0;(i+1)*len<k;i++)
    	sum+=t1[i];
    for(i=i*len;i<=k;i++)
    	sum+=t2[i];
    return sum;
}
```


---


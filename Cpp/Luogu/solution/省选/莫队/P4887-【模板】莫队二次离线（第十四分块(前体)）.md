# 【模板】莫队二次离线（第十四分块(前体)）

## 题目描述

珂朵莉给了你一个序列 $a$，每次查询给一个区间 $[l,r]$，查询 $l \leq i< j \leq r$，且 $a_i \oplus a_j$ 的二进制表示下有 $k$ 个 $1$ 的二元组 $(i,j)$ 的个数。$\oplus$ 是指按位异或。

## 说明/提示

对于5%的数据，为样例。

对于30%的数据，$1 \leq n , m \leq 5000$。

对于50%的数据，空间限制为 512 MiB。

对于100%的数据，$1 \leq n, m \leq 100000$，$0 \leq a_i, k < 16384$。

## 样例 #1

### 输入

```
5 5 2
3 4 8 0 2
4 5
3 5
1 4
2 5
1 5```

### 输出

```
0
1
2
3
4```

# 题解

## 作者：_WA自动机 (赞：135)

## 二次离线莫队
适用范围：
* 可以莫队
* 更新答案的时间不是O(1)（一个数对答案的贡献与区间中别的数有关，例如比一个数小的数有多少）

二次离线莫队，通过扫描线，再次将更新答案的过程离线处理，降低时间复杂度。假设更新答案的复杂度为$O(k)$，它将莫队的复杂度从$O(nk\sqrt n)$降到了$O(nk + n\sqrt n)$，大大简化了计算。
设x对区间[l..r]的贡献为$\mathrm f(x,[l,r])$  
我们考虑区间端点变化对答案的影响：
以$[l..r]$ 变成 $[l..(r+k)]$为例
$$\forall x \in [r+1,r+k]$$
求
$$\mathrm f(x,[l,x-1])$$
我们可以进行差分：
$$\mathrm f(x,[l,x-1])=f(x,[1,x-1])-f(x,[1,l-1])$$

这样转化为了一个数对一个前缀的贡献。保存下来所有这样的询问，从左到右扫描数组计算就可以了。  
但是这样做，空间是$O(n\sqrt n)$的，不太优秀，而且时间常数巨大。。  
这样的贡献分为两类：

1. 减号左边的贡献永远是一个前缀 和它后面一个数的贡献。这可以预处理出来。
2. 减号右边的贡献对于一次移动中所有的x来说，都是不变的。我们打标记的时候，可以只标记左右端点。  
这样，减小时间常数的同时，空间降为了$O(n)$级别。是一个很优秀的算法了。

例题：[第十四分块（前体）](https://www.luogu.org/problemnew/show/P4887)

处理前缀询问的时候，我们利用异或运算的交换律，即$a\  \mathrm{xor} \ b=c \Longleftrightarrow a\  \mathrm{xor}\  c=b$
开一个桶t,t[i]表示当前前缀中与i异或有k个数位为1的数有多少个。
则每加入一个数a[i]，对于所有$\mathrm{popcount}(x)==k$的x，$++t[a[i]\  \mathrm{xor}\ x]$即可。

代码：  
~~求评价码风qwq~~
```cpp
#include <cstdio>
#include <cmath>
#include <cstdint>
#include <vector>
#include <cstring>
#include <cassert>
#include <algorithm>
#include <utility>
#include <tuple>

using std::tuple;
using std::make_pair;
using std::vector;
using std::sort;
using std::sort;
using std::pair;
using std::get;

const int maxn=1e5+100;

int blo[maxn],a[maxn];

struct Qry
{
    int l,r,id;
    int64_t ans;
    inline bool operator< (const Qry& q){return blo[l]==blo[q.l]?r<q.r:l<q.l;}
}Q[maxn];

vector<tuple<int,int,int>> v[maxn];

int main()
{
    // freopen("data.in","r",stdin);
    // freopen("my.out","w",stdout);
    int n,m,k;
    scanf("%d%d%d",&n,&m,&k);
    if (k>14)
    {
        for (int i=1;i<=m;++i) puts("0");
        return 0;
    }
    for (int i=1;i<=n;++i)
        scanf("%d",a+i);
    for (int i=1;i<=m;++i)
        scanf("%d%d",&Q[i].l,&Q[i].r),Q[i].id=i;
    vector<int> buc;
    for (int i=0;i<16384;++i)
        if (__builtin_popcount(i)==k) buc.push_back(i);
    // for (auto x:buc)
    //     fprintf(stderr,"%d ",x);
    int T=sqrt(n);
    for (int i=1;i<=n;++i) blo[i]=(i-1)/T+1;
    sort(Q+1,Q+m+1);

     /***************/
     /*  L右移：l正r负 *\
     /*  l左移：l负r正 *\
     /*  r右移：r正l负 *\
     /*  r左移：r负l正 *\
     /***************/
    static int t[maxn];
    static int pref[maxn];
    for (int i=1;i<=n;++i)
    {
        for (auto x:buc) ++t[a[i]^x];
        pref[i]=t[a[i+1]];
    }
    memset(t,0,sizeof(t));
   	// 预处理前缀贡献
    for (int i=1,L=1,R=0;i<=m;++i)
    {
        int l=Q[i].l,r=Q[i].r;
        if (L<l) v[R].emplace_back(L,l-1,-i);
        while (L<l) {Q[i].ans+=pref[L-1];++L;} 
        if (L>l) v[R].emplace_back(l,L-1,i);
        while (L>l) {Q[i].ans-=pref[L-2];--L;}
        if (R<r) v[L-1].emplace_back(R+1,r,-i);
        while (R<r) {Q[i].ans+=pref[R];++R;}
        if (R>r) v[L-1].emplace_back(r+1,R,i);
        while (R>r) {Q[i].ans-=pref[R-1];--R;}
    }
    //模拟莫队，算出来第一类贡献，对第二类贡献打上标记
    static int64_t ans[maxn];
    for (int i=1,id,l,r;i<=n;++i)
    {
        for (auto x:buc) ++t[a[i]^x];
        for (const auto& x:v[i])
        {
            std::tie(l,r,id)=x;
            // if (i>=l) fprintf(stderr,"%d %d\n",i,l);
            for (int j=l,tmp=0;j<=r;++j)
            {
                tmp=t[a[j]];
                if (j<=i && k==0) --tmp;// 这里（按我的蒟蒻写法）k==0的时候需要特判，因为x^x永远是0，但自己对自己不能产生贡献。
                if (id<0) Q[-id].ans-=tmp;
                else Q[id].ans+=tmp;
            }
        }
    }
    for (int i=1;i<=m;++i) Q[i].ans+=Q[i-1].ans;
    for (int i=1;i<=m;++i) ans[Q[i].id]=Q[i].ans;
    for (int i=1;i<=m;++i) printf("%lld\n",ans[i]);
}
```


---

## 作者：shadowice1984 (赞：59)

其实是lxl题里良心的题了……毕竟就几十行(当然细节比较恶心就是了)

更加良心的是这!题!不!卡!常!

~~管他什么题总之lxl数据结构天下第一~~
_______________

## 本题题解:莫队+扫描线(二次离线莫队)

首先这是一道**无修改的区间数点对**问题

那么解决这类问题我们可以使用莫队算法来在$O(N\sqrt{m})$的时间内处理这些东西

但是前提是我们需要在$O(1)$(有些时候$O(logn)$可以忍受)实现三个操作

1.已知$(l,r)$递推到$(l,r+1)$

2.已知$(l,r)$递推到$(l+1,r)$

3.已知$(l,r)$递推到$(l-1,r)$

(之所以没有右端点右移的操作是因为我们可以直接规避掉这个没卵用的操作(当然你奇偶性排序莫队卡常数这个写法当我没说,不过对应到这道题上就是你多讨论一种情况))

那么对于这道题来讲我们似乎直接插入是$O(C(k,14))$的这个复杂度绝对无法接受的

但是我们看一下我们是如何插入一个值的呢？假设我们让右端点+1的话,我们实际上是求$(l,r)$这段区间里有多少个数和$a_{r+1}$异或起来恰好有k个1

那么这个问题其实是可以转化为求出$(1,l-1)$这段区间里有多少个数和$a_{r+1}$异或起来恰好有k个1,求出$(1,r)$这段区间里有多少个数和$a_{r+1}$异或起来恰好有k个1,然后二者相减一下就可以了

那么我们发现这是一堆针对于前缀的询问了此时我们可以将这些询问全部离线下来然后跑一边扫描线似乎就可以求出答案了？

然后你发现你这样写甚至连样例都过不去

为什么呢？

因为我们在写莫队的时候会发现一个重要的事实就是我们插入一个点和删除一个点的时候本质上是在求**答案的变化量**也就是这个答案和上一个问题的答案差了多少

因此如果我们刚才离线之后跑扫描线我们只能知道每个答案和上一个问题的答案差了多少

所以我们最后需要做一次前缀和将问题的答案还原

好了那么我们现在已经有了一个比较trival的算法了很遗憾的是这个算法需要$O(N\sqrt{M})$的空间复杂度并且常数相当的大……

那么我们考虑卡卡空间并且卡卡常数

让我们来煮个栗子

假设我们现在需要从区间$(233,666)$转移到区间$(262,700)$

那么首先我们先让右端点不停的+1直到这个右端点变成了$700$为止

那么我们的询问就会被拆成这样的一堆询问

询问 $(1,666)$这个区间中有几个数字和$a_{667}$异或起来有k个1

询问 $(1,667)$这个区间中有几个数字和$a_{668}$异或起来有k个1

询问 $(1,668)$这个区间中有几个数字和$a_{669}$异或起来有k个1

......

询问 $(1,669)$这个区间中有几个数字和$a_{700}$异或起来有k个1

以上的询问全部是需要加上的值(权值为+1)

还有需要减去的值

询问 $(1,232)$这个区间中有几个数字和$a_{667}$异或起来有k个1

询问 $(1,232)$这个区间中有几个数字和$a_{668}$异或起来有k个1

询问 $(1,232)$这个区间中有几个数字和$a_{669}$异或起来有k个1

......

询问 $(1,232)$这个区间中有几个数字和$a_{700}$异或起来有k个1

这些询问的权值全部是-1

### Case1:求+1部分的和

那么我们可以跑一边扫描线，对于每一个位置$i$求出$(1,i-1)$这个前缀有多少个数字和$a_{i}$异或起来有k个1

具体点来讲我们实现一个$O(C(7,14))$插入$O(1)$询问的数组$res$

假设我们跑扫描线的时候跑到了第$i$个点那么$res(j)$就表示$(1,i)$这个区间中有多少个数字和$a_{j}$异或起来有k个1

那么我们插入一个$a$值的时候就直接大力的枚举所有有$k$个1的数字$val$然后令$res(a \oplus val)++$就行了

接下来我们维护一个变量$K$表示“对于$(1~i)$中的每一个位置i,满足$(1,i-1)$这个前缀$a_{i}$异或起来有k个1的数字的数目的和”

那么以刚才的例子为例,我们只需要用扫到$700$这个位置的$K$减去扫到$666$这个位置的$K$就行了

### Case2:求-1部分的和

我们发现这个部分是对着$(1,232)$这个前缀询问了$(667,700)$这个区间里有多少个数字异或起来有k个1

那么我们可以在$232$这个位置开一个vector然后push一个区间$(667,700)$
就可以了,我们扫描线跑到$232$这个位置的时候就暴力询问一遍$(667,700)$这个区间里的所有值挨个询问一下就可以了

_________________

然后我们发现我们就如此这般的将询问的空间复杂度压到了$O(m)$的级别

接下来我我们唯一需要做的事情就是正着跑一遍扫描线处理所有的右端点变动情况接下来跑一遍扫描线处理所有左端点的变动情况了

复杂度$O(C(k,17)n+n\sqrt{m})$

上代码~

```C

#include<cstdio>
#include<algorithm>
#include<vector>
#include<cmath>
using namespace std;const int N=1e5+10;const int M=16384+10;typedef long long ll;
int res[M];int siz[M];int val[M];int tp;ll ans[N];int a[N];int n;int m;int k;int B;
struct nod{int p;int tim;};vector <nod> mrk1[N],mrk2[N];
struct data{int l;int r;int tim;};vector <data> sp[N],spa[N],spm[N];
struct qry{int l;int r;int tim;}qr[N];ll trs;
inline bool cmp1(const qry& a,const qry& b){return a.l<b.l;}
inline bool cmp2(const qry& a,const qry& b){return (a.r==b.r)?a.l<b.l:a.r<b.r;}
inline void subsolve(int dl,int dr)//二次离线 
{
	if(dl==dr)return;sort(qr+dl,qr+dr,cmp2);
	int l=qr[dl].l;int r=qr[dl].r;int t=qr[dl].tim;int nl=l;int nr=r;
	mrk1[l-1].push_back((nod){-1,t});mrk1[r].push_back((nod){1,t});sp[l-1].push_back((data){l,r,t});
	for(int i=dl+1;i!=dr;i++)
	{
		l=qr[i].l;r=qr[i].r;t=qr[i].tim;
		if(nr!=r)
		{
			mrk1[nr].push_back((nod){-1,t}),mrk1[r].push_back((nod){1,t});
			sp[nl-1].push_back((data){nr+1,r,t});
		}
		if(nl!=l){mrk2[nl].push_back((nod){-1,t}),mrk2[l].push_back((nod){1,t});}
		if(nl<l){spa[r+1].push_back((data){nl,l-1,t});}
		if(l<nl){spm[r+1].push_back((data){l,nl-1,t});}nl=l;nr=r;
	}
}
inline void subsolve2(int dl,int dr)//前缀和 
{for(int i=dl+1;i<dr;i++)ans[qr[i].tim]+=ans[qr[i-1].tim];}
inline void ins(int a){for(int i=1;i<=tp;i++)res[val[i]^a]++;}//插入 
int main()
{
	for(int i=1;i<16384;i++)siz[i]=siz[i>>1]+(i&1);
	scanf("%d%d%d",&n,&m,&k);
	for(int i=1;i<=n;i++)scanf("%d",&a[i]);
	for(int i=0;i<16384;i++)if(siz[i]==k)val[++tp]=i;
	for(int i=1;i<=m;i++)scanf("%d%d",&qr[i].l,&qr[i].r),qr[i].tim=i;
	sort(qr+1,qr+m+1,cmp1);B=n/sqrt(m)+1;
	for(int i=B,dl=1,dr=1;;i=min(i+B,n),dl=dr)
		{while(qr[dr].l<=i&&dr<=m)dr++;subsolve(dl,dr);if(i==n)break;}
	for(int i=1;i<=n;i++)//正着扫描线一遍 
	{
		trs+=res[a[i]];ins(a[i]);
		vector <nod> :: iterator it;vector <data> :: iterator it1;
		for(it=mrk1[i].begin();it!=mrk1[i].end();++it){ans[it->tim]+=trs*it->p;}
		for(it1=sp[i].begin();it1!=sp[i].end();++it1)
			for(int j=it1->l;j<=it1->r;j++){ans[it1->tim]-=res[a[j]];}
	}for(int i=0;i<16384;i++)res[i]=0;trs=0;
	for(int i=n;i>=1;i--)//倒着扫描线一遍 
	{
		trs+=res[a[i]];ins(a[i]);
		vector <nod> :: iterator it;vector <data> :: iterator it1;
		for(it=mrk2[i].begin();it!=mrk2[i].end();++it){ans[it->tim]+=trs*it->p;}
		for(it1=spa[i].begin();it1!=spa[i].end();++it1)
			for(int j=it1->l;j<=it1->r;j++)ans[it1->tim]+=res[a[j]];
		for(it1=spm[i].begin();it1!=spm[i].end();++it1)
			for(int j=it1->l;j<=it1->r;j++)ans[it1->tim]-=res[a[j]];
	}
	for(int i=B,dl=1,dr=1;;i=min(i+B,n),dl=dr)
		{while(qr[dr].l<=i&&dr<=m)dr++;subsolve2(dl,dr);if(i==n)break;}
	for(int i=1;i<=m;i++)printf("%lld\n",ans[i]);return 0;//拜拜程序~ 
}

```













---

## 作者：gxy001 (赞：49)

### 前言

众所周知，莫队是一种可爱的离线算法，它的时间复杂度为 $O(n\sqrt m\,f(x))$，$f(x)$ 为挪指针时更新答案复杂度，当 $f(x)=O(1)$ 时，我们可以接受，但 $f(x)=O(\log n)$ 甚至更大时，我们可能就无法接受了，而__莫队二次离线__可以让复杂度降到我们能接受的范围内——$O(n\sqrt m+n\,f(x))$。

**适用范围**：

- 一个数对区间的贡献与区间内的数有关；
- 设 $F(x,[l,r])$ 为 $x$ 对区间 $[l,r]$ 的贡献，其满足性质 $F(x,[l,r])=F(x,[1,r])-F(x,[1,l-1])$。

### 实现

考虑在挪指针时对答案产生了哪些贡献，下文的 $f(x,l,r)$ 表示 $a_x$ 对 $[l,r]$ 的贡献，$F(x,l)=f(x,1,l)$。

在右指针移动到 $x$ 时，会产生的答案变动为 $f(x,l,x-1)=F(x,x-1)-F(x,l-1)$ ；

在左指针移动到 $x$ 时，会产生的答案变动为 $f(x,x+1,r)=F(x,r)-F(x,x)$。

我们注意到，$F(x,x-1)$，$-F(x,x)$ 是可以预处理的，莫队时直接 $O(1)$ 修改答案即可，而且一般情况下 $F(x,x-1)=F(x,x)$，毕竟一个数一般不会对自己有贡献，可以偷个懒。

莫队的指针移动是连续的，也就是说，在上面式子中的 $-F(x,l-1)$ 和 $F(x,r)$ 部分单独计算实际上是形如 $-F(a,l-1)-F(a+1,l-1)-F(a+2,l-1)-\cdots-F(k,l-1)$ 和 $F(a,r)+F(a-1,r)+F(a-2,r)+\cdots+F(k,r)$ 的，那么我们可以使用五元组 $(a,k,l-1,-1,i)$ 和 $(a,k,r,1,i)$ 将这些移动产生的贡献存下来，$i$ 表示该移动在哪个询问期间发生，在莫队结束后使用扫描线处理，不懂没关系，看下代码（养成好习惯，两个指针的移动顺序不要写错）：

```cpp
for(int i=1,l=1,r=0;i<=m;i++){
    if(l>q[i].l) v[r].emplace_back(q[i].l,l-1,i,1);
    while(l>q[i].l) --l,q[i].ans-=p[l];
    if(r<q[i].r) v[l-1].emplace_back(r+1,q[i].r,i,-1);
    while(r<q[i].r) ++r,q[i].ans+=p[r];
    if(l<q[i].l) v[r].emplace_back(l,q[i].l-1,i,-1);
    while(l<q[i].l) q[i].ans+=p[l],++l;
    if(r>q[i].r) v[l-1].emplace_back(q[i].r+1,r,i,1);
    while(r>q[i].r) q[i].ans-=p[r],--r;
}
```

这样还有最后一个问题，我们会发现一个指针在询问 $i$ 处的移动会对询问 $[i,m]$ 产生贡献，也就是说，我们得到的答案其实是差分的形式，需要求前缀和才能得到真正的答案。

UPD: 这里给出一个常数优化，p 数组可以用前缀和优化

```
for(int i=1,l=1,r=0;i<=m;i++)
		if(l>q[i].l) v[r].emplace_back(q[i].l,l-1,q[i].id,1),ans[q[i].id]-=p[l-1]-p[q[i].l-1],l=q[i].l;
		if(r<q[i].r) v[l-1].emplace_back(r+1,q[i].r,q[i].id,-1),ans[q[i].id]+=p[q[i].r]-p[r],r=q[i].r;
		if(l<q[i].l) v[r].emplace_back(l,q[i].l-1,q[i].id,-1),ans[q[i].id]+=p[q[i].l-1]-p[l-1],l=q[i].l;
		if(r>q[i].r) v[l-1].emplace_back(q[i].r+1,r,q[i].id,1),ans[q[i].id]-=p[r]-p[q[i].r],r=q[i].r;
	}
```
### 关于本题

我们预处理出所有有 $k$ 个 $1$ 的数，利用异或的性质 $a\oplus b=c\leftrightarrow b=a\oplus c$ 即可得到答案。

### 代码

这里给出 [P4887](https://www.luogu.com.cn/problem/P4887) 的代码：

```cpp
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<vector>
#include<cstring>
#include<tuple>
int n,m,k,bel[100010],sz,a[100010],t[100010],p[100010];
struct query{
	int l,r,id;
	long long ans;
	bool operator <(query const &x)const{
		return bel[l]==bel[x.l]?r<x.r:l<x.l;
	}
}q[100010];
std::vector<int> b;
std::vector<std::tuple<int,int,int,int>>v[100010];
long long ans[100010];
int bitcount(unsigned x){
	int ans(0);
	while(x)x-=x&-x,++ans;
	return ans;
}
int main(){
	scanf("%d%d%d",&n,&m,&k);
	if(k>14){
		for(int i=1;i<=m;i++)puts("0");
		return 0;
	}
	sz=n/sqrt(m);//莫队的正确块长，比sqrt(n)要快很多
	for(int i=1;i<=n;i++)scanf("%d",a+i),bel[i]=(i-1)/sz+1;
	for(int i=1;i<=m;i++)scanf("%d%d",&q[i].l,&q[i].r),q[i].id=i;
	for(int i=0;i<16384;i++)
		if(bitcount(i)==k)
			b.push_back(i);
	std::sort(q+1,q+m+1);
	for(int i=1;i<=n;i++){//预处理
		p[i]=t[a[i]];
		for(const auto& x:b)++t[a[i]^x];
	}
	memset(t,0,sizeof(t));
	for(int i=1,l=1,r=0;i<=m;i++){//莫队
		if(l>q[i].l) v[r].emplace_back(q[i].l,l-1,i,1);
		while(l>q[i].l) --l,q[i].ans-=p[l];
		if(r<q[i].r) v[l-1].emplace_back(r+1,q[i].r,i,-1);
		while(r<q[i].r) ++r,q[i].ans+=p[r];
		if(l<q[i].l) v[r].emplace_back(l,q[i].l-1,i,-1);
		while(l<q[i].l) q[i].ans+=p[l],++l;
		if(r>q[i].r) v[l-1].emplace_back(q[i].r+1,r,i,1);
		while(r>q[i].r) q[i].ans-=p[r],--r;
	}
	for(int i=1;i<=n;i++){//扫描线
		for(const auto& x:b)++t[a[i]^x];
		for(const auto& x:v[i]){
			for(int j=std::get<0>(x);j<=std::get<1>(x);j++){
				if(j<=i&&k==0) q[std::get<2>(x)].ans+=std::get<3>(x)*(t[a[j]]-1);
				else q[std::get<2>(x)].ans+=std::get<3>(x)*t[a[j]];
			}
		}
	}
	for(int i=1;i<=m;i++)q[i].ans+=q[i-1].ans;//前缀和
	for(int i=1;i<=m;i++)ans[q[i].id]=q[i].ans;
	for(int i=1;i<=m;i++)printf("%lld\n",ans[i]);
	return 0;
}
```

### 习题

[P4887](https://www.luogu.com.cn/problem/P4887)

[P5047](https://www.luogu.com.cn/problem/P5047)

[P5501](https://www.luogu.com.cn/problem/P5501)

---

## 作者：FZzzz (赞：38)

昨天因为一些契机开始思考莫队二离和序列分块的联系，晚上躺床上思考了好久整出来这玩意，先发出来水篇博客。
## 问题归纳
一般来讲，目前莫队二离可以解决的问题是静态的区间询问，区间中每一对数计算一次贡献。

可能可以具有更广泛的形式，但我所知的二离题包括第十四分块都是这个形式。这篇博客也只讨论这个形式，如果用二离解决其他的问题可能需要根据情况做一些调整。
## 莫队二次离线
为了避免把复杂度写得非常奇怪（比如普通莫队其实是移动 $O(n\sqrt m)$ 次指针，二离我已经不会算各种地方是 $n$ 还是 $m$ 或者 $n+m$ 了），这里直接假定序列长度与询问次数同级。

我们用莫队二次离线解决这个问题。先考虑用普通的莫队，我们试图用一个数据结构支持插入删除和查询某个数对已经插入的所有数的贡献，那么我们需要 $O(n\sqrt n)$ 次修改和 $O(n\sqrt n)$ 次查询。

莫队二次离线可以将其优化到 $O(n)$ 次修改和 $O(n\sqrt n)$ 次查询，同时把这个数据结构以外的空间开销保持在 $O(n)$。更具体地说，是对总长为 $O(n\sqrt n)$ 的 $O(n)$ 个区间内的所有数的查询——所以其实很多题解说“把 $O(n\sqrt nf(n))$ 优化到 $O(n\sqrt n+nf(n))$”是非常不严谨甚至可以说错误的。莫队二离的具体做法并不是这篇文章的重点，与接下来要介绍的做法关系也不大，这里直接略过不讲。
## 一种基于序列分块的新算法
考虑对序列进行分块。设块长为 $S$ 这种起手式我就直接略过了，这里直接设块长为 $O(\sqrt n)$。规定一些记号：$pos_x$ 表示 $x$ 所在的块，$L_x$ 和 $R_x$ 表示 $x$ 这个块的左右端点，我们处理的询问区间为 $[l,r]$。

先考虑左右端点不同块的情况，考虑计算左散块自身的贡献，这显然可以在 $O(n)$ 次修改 $O(n)$ 次查询内计算。

左散块对整块的贡献。把其差分为对两个前缀块的贡献，那么假设我们要计算 $l$ 到 $R_{pos_l}$ 对前 $x$ 个块的贡献。把这个询问挂在第 $x$ 个块上，对块做扫描线，每次加入一个块，处理到第 $x$ 这个块时把 $[l,R_{pos_l}]$ 内的数全部查询一遍。这部分是 $O(n)$ 次插入 $O(n\sqrt n)$ 次查询。

左散块对右散块的贡献。在一些题目中（比如区间逆序对）可以用更简单的方法计算，但是这里介绍一种通用的方法。我们需要计算 $[l,R_{pos_l}]$ 对 $[L_{pos_r},r]$ 的贡献。把这个询问挂在 $l$ 上，依次考虑每个块，从右往左做扫描线，考虑到第 $pos_l$ 个块扫到 $l$ 时查询 $[L_{pos_r},r]$ 内的数。这部分也是 $O(n)$ 次插入 $O(n\sqrt n)$ 次查询。

**upd**：写这玩意的时候脑子有点抽，上面两类贡献是可以直接一起算的。代码懒得 upd 了（

那么我们已经计算完了所有跟左散块相关的贡献，可以直接丢掉左散块了，现在我们需要考虑整块和右散块。进行差分，区间答案即为 $[1,r]$ 的答案减去 $[1,R_{pos_l}]$ 的答案，再减去前 $pos_l$ 个块对 $[L_{pos_l+1},r]$ 的贡献。前缀答案显然可以用 $O(n)$ 次修改 $O(n)$ 次查询计算，考虑如何计算前缀块对一个其后一个区间的贡献。

还是考虑扫描线，每次加入一个块，扫到每个块时再做一遍扫描线，把这个块后面的点全部询问一遍。那么我们把这个询问挂在 $(pos_l,r)$ 上，扫到第 $pos_l$ 块，第 $r$ 个数时，一个前缀和就是这个询问的答案。$O(n\sqrt n)$ 个 `vector` 肯定是开不下的，所以第二维需要使用传统的排序的扫描线，当然你也可以不使用扫描线而是直接处理出所有前缀和。容易发现，这部分还是 $O(n)$ 次插入 $O(n\sqrt n)$ 次查询。

那么考虑 $pos_l=pos_r$ 的情况。容易发现还是可以通过前缀相减再减去前缀区间对其后一个区间的贡献来做。扫描线，每次加入一个数，扫到 $l-1$ 时询问 $[l,r]$ 即可。以上所有部分空间复杂度均为 $O(n)$。

给出洛谷模板 LG4887 的代码，把重复的扫描线放在一起减小了插入次数才因为时限宽松卡过，目前排在最优解倒数第二页。
```cpp
#include<bits/stdc++.h>
using namespace std;
inline int readint(){
	int x=0;
	bool f=0;
	char c=getchar();
	while(!isdigit(c)&&c!='-') c=getchar();
	if(c=='-'){
		f=1;
		c=getchar();
	}
	while(isdigit(c)){
		x=x*10+c-'0';
		c=getchar();
	}
	return f?-x:x;
}
const int maxn=1e5+5,maxb=350;
int n,m,k,a[maxn],l[maxn],r[maxn];
int S,B,pos[maxn],L[maxb],R[maxb];
vector<int> v;
int cnt[(1<<14)+5];
void modify(int x,int k){
	for(int i:v) cnt[x^i]+=k;
}
typedef long long ll;
ll f[maxn],g[maxn],ans[maxn];
struct qr{
	int x,id;
	bool flag;
};
vector<qr> q1[maxn],q2[maxb],q3[maxb],q4[maxn],q5[maxn];
int main(){
	#ifdef LOCAL
	freopen("in.txt","r",stdin);
	freopen("out.txt","w",stdout);
	#endif
	n=readint();
	m=readint();
	k=readint();
	if(k>14){
		for(int i=0;i<m;i++) printf("0\n");
		return 0;
	}
	for(int i=1;i<=n;i++) a[i]=readint();
	S=sqrt(n);
	B=(n-1)/S+1;
	for(int i=1;i<=B;i++){
		L[i]=S*(i-1)+1;
		R[i]=min(S*i,n);
		for(int j=L[i];j<=R[i];j++) pos[j]=i;
	}
	for(int i=0;i<(1<<14);i++){
		int cnt=0;
		for(int j=0;j<14;j++) if(i>>j&1) cnt++;
		if(cnt==k) v.push_back(i);
	}
	for(int i=1;i<=m;i++){
		l[i]=readint();
		r[i]=readint();
		if(pos[l[i]]==pos[r[i]]){
			q4[l[i]-1].push_back({r[i],i,0});
			continue;
		}
		q1[l[i]].push_back({r[i],i,1});
		q2[pos[l[i]]].push_back({l[i],i,0});
		q2[pos[r[i]]-1].push_back({l[i],i,1});
		q3[pos[l[i]]].push_back({r[i],i,0});
	}
	for(int i=1;i<=B;i++){
		for(int j=R[i];j>=L[i];j--){
			g[j]=j==R[i]?0:g[j+1]+cnt[a[j]];
			modify(a[j],1);
			for(qr x:q1[j])
				for(int k=L[pos[x.x]];k<=x.x;k++) ans[x.id]+=cnt[a[k]];
		}
		for(int j=L[i];j<=R[i];j++) modify(a[j],-1);
	}
	for(int i=1;i<=B;i++){
		for(int j=L[i];j<=R[i];j++) modify(a[j],1);
		for(qr x:q2[i])
			for(int j=x.x;j<=R[pos[x.x]];j++)
				if(x.flag) ans[x.id]+=cnt[a[j]];
				else ans[x.id]-=cnt[a[j]];
		sort(q3[i].begin(),q3[i].end(),[](qr a,qr b){
			return a.x<b.x;
		});
		int cur=0;
		ll s=0;
		for(int j=R[i]+1;j<=n;j++){
			s+=cnt[a[j]];
			while(cur<(int)q3[i].size()&&q3[i][cur].x==j) ans[q3[i][cur++].id]-=s;
		}
	}
	memset(cnt,0,sizeof(cnt));
	for(int i=1;i<=n;i++){
		f[i]=f[i-1]+cnt[a[i]];
		modify(a[i],1);
		for(qr x:q4[i]) for(int j=i+1;j<=x.x;j++) ans[x.id]-=cnt[a[j]];
	}
	for(int i=1;i<=m;i++)
		if(pos[l[i]]==pos[r[i]]) printf("%lld\n",ans[i]+f[r[i]]-f[l[i]-1]);
		else printf("%lld\n",ans[i]+f[r[i]]-f[R[pos[l[i]]]]+g[l[i]]);
	#ifdef LOCAL
	fprintf(stderr,"%d\n",(int)clock());
	#endif
	return 0;
}
```
## 这有啥用
这没啥用……

目前看起来这玩意不弱于莫队二离，理论连第十四分块都能用这玩意做 ~~被卡常卡到怀疑人生就不是我的问题了~~。不过分块可能总归比莫队灵活，所以有可以用类似这玩意不能二离的东西也说不定？

如果把二离题强制在线，那在散块对散块贡献容易计算时这玩意可以很容易地以空间多个根号的代价改成在线算法。事实上这个做法就是我在思考“$f_{l,r}$ 表示第 $l$ 到第 $r$ 个块的贡献”这种分块时想出的。

然后就……真不知道有啥用了（ 反正我也就因为好玩搞出来的这玩意没啥用也正常（（
## 与莫队二离的关系
如果从上面说的那种分块拓展到这个做法，那么你可以感受到把空间从 $O(n\sqrt n)$ 优化到线性所用的方法与二离是如出一辙的。但我并没有发现这个做法与莫队二离的一些本质上的联系。
## 遗留问题
如上所说，我目前并没有发现这个做法与莫队二离的一些本质上的联系。如果有对此有见解的还请在评论区不吝赐教。

x6 给出了在这类问题的贡献是由偏序关系计算时（如 LG5501）的一个基于值域分块的在线根号空间做法，我正是因此而开始思考莫队二离与序列分块和值域分块的联系，但误打误撞发现了这个算法。但我依然没有发现这类问题序列分块与值域分块做法的关系，如果有想法也欢迎来交流。

---

## 作者：Cyhlnj (赞：23)

sto [$lxl$](https://www.luogu.org/blog/user829/lgr-051-luo-gu-9-yue-yue-sai-jiang-ping) orz

考虑莫队，每次移动端点，我们都要询问区间内和当前数字异或有 $k$ 个 $1$ 的数字个数

询问 $[l,r]$ 可以再次离线，拆成询问 $[1,l-1]$ 和 $[l,r]$

然后考虑莫队要移动 $[l,r]$ 的 $l$ 到 $p$

假设 $p>l$

那么相当于每次询问 $a[l]$ 和 $[l+1,r]$，然后 $++l$ 直到 $l=p$

即每次询问 $a[l]$ 和 $[1,l]$ ，$a[l]$ 和 $[1,r]$
对于前面的部分，它每次都是前缀区间的最后一个数字询问前缀区间，可以预处理

对于后面的部分，它每次都是一个数字询问一个固定的区间，直接在 $r$ 处打上一个询问 $l,p$ 的标记，之后离线暴力询问 $l,p$，这一部分复杂度和莫队一样

然后其它移动端点的方法类似

大力讨论一下即可

```cpp
# include <bits/stdc++.h>
using namespace std;
typedef long long ll;

namespace IO {
	const int maxn(1 << 21 | 1);

	char ibuf[maxn], *iS, *iT, c;
	int f;

	inline char Getc() {
		return iS == iT ? (iT = (iS = ibuf) + fread(ibuf, 1, maxn, stdin), (iS == iT ? EOF : *iS++)) : *iS++;
	}
	
	template <class Int> inline void In(Int &x) {
		for (f = 1, c = Getc(); c < '0' || c > '9'; c = Getc()) f = c == '-' ? -1 : 1;
		for (x = 0; c >= '0' && c <= '9'; c = Getc()) x = x * 10 + (c ^ 48);
		x *= f;
	}
}

using IO :: In;

const int maxn(2e5 + 5);

int cnt, v[maxn], n, m, k, a[maxn], sum[maxn], blo;
ll cur, ret[maxn], ans[maxn], pre1[maxn], pre2[maxn];

struct Qry {
	int l, r, id;

	inline bool operator < (Qry b) const {
		return l / blo != b.l / blo ? l < b.l : r < b.r;
	}
} qry[maxn];

vector <Qry> q[maxn];

# define pk push_back

int main() {
	In(n), In(m), In(k), blo = sqrt(n);
	for (int i = 0; i < 16384; ++i) {
		int x = i, c = 0;
		for (; x; x ^= x & -x) ++c;
		if (c == k) v[++cnt] = i;
	}
	for (int i = 1; i <= n; ++i) In(a[i]);
	for (int i = 1; i <= m; ++i) In(qry[i].l), In(qry[i].r), qry[i].id = i;
	sort(qry + 1, qry + m + 1);
	for (int i = 1, l = qry[1].r + 1, r = qry[1].r; i <= m; ++i) {
		if (l < qry[i].l) q[r].pk((Qry){l, qry[i].l - 1, qry[i].id << 1});
		else if (l > qry[i].l) q[r].pk((Qry){qry[i].l, l - 1, qry[i].id << 1});
		l = qry[i].l;
		if (r < qry[i].r) q[l - 1].pk((Qry){r + 1, qry[i].r, qry[i].id << 1 | 1});
		else if (r > qry[i].r) q[l - 1].pk((Qry){qry[i].r + 1, r, qry[i].id << 1 | 1});
		r = qry[i].r;
	}
	for (int i = 1; i <= n; ++i) {
		pre1[i] = pre1[i - 1] + sum[a[i]];
		for (int j = 1; j <= cnt; ++j) ++sum[a[i] ^ v[j]];
		pre2[i] = pre2[i - 1] + sum[a[i]];
		for (auto t : q[i]) for (int j = t.l; j <= t.r; ++j) ret[t.id] += sum[a[j]];
	}
	for (int i = 1, l = qry[1].r + 1, r = qry[1].r; i <= m; ++i) {
		if (l < qry[i].l) cur += pre2[qry[i].l - 1] - pre2[l - 1] - ret[qry[i].id << 1];
		else if (l > qry[i].l) cur += ret[qry[i].id << 1] - pre2[l - 1] + pre2[qry[i].l - 1];
		l = qry[i].l;
		if (r < qry[i].r) cur += pre1[qry[i].r] - pre1[r] - ret[qry[i].id << 1 | 1];
		else if (r > qry[i].r) cur += ret[qry[i].id << 1 | 1] - pre1[r] + pre1[qry[i].r];
		ans[qry[i].id] = cur, r = qry[i].r;
	}
	for (int i = 1; i <= m; ++i) printf("%lld\n", ans[i]);
	return 0;
}

```

---

## 作者：Fido_Puppy (赞：21)

这道题就是一个经（du）典（liu）的莫队二次离线。

不卡常，不需要其他的数据结构。

我们先来讲一下莫队二次离线是什么~~神仙~~。

## Solution

首先，我们会发现某些莫队在转移的过程中时间复杂度比较大。

我们先把问题给差分化。

设 $(l, r)$ 区间内的数异或 $k$ 的满足条件的数的个数为 $f(l, r, k)$。

比如说在这道题里，$r$ 指针每向右移动一位，对答案的贡献为：

$$f(l, r-1, a[r])$$

我们把它用前缀和的形式表示：

$$f(1, r-1, a[r]) - f(1, l, a[r])$$

很显然，前面的那个 $f(1, r-1, a[r])$ 是可以预处理出来的。

考虑后面的 $f(1, l, a[r])$ 怎么算。

我们可以用一个 vector 数组。

对于每一个 $f(1, l, a[r])$，把 ```vec[l].push_back(a[r])```。

然后跑一篇 ```for(int i=1;i<=n;i++)``` 即可。

但是，我们会神奇的发现这样由于有 $N \sqrt N$ 次移动。

空间复杂度是 $O(N \sqrt N)$，原地爆炸。

所以我们能想到每次的移动是连续的。

普通的莫队是这样移动的：

```cpp
while (r<q[i].r) r++;
```

所以我们只需要把移动的区间 $(r+1, q[i].r)$ 存下来就行了。

这样空间复杂度便降到了 $O(N + M)$。

想练练手的，左转 [P5047 [Ynoi2019 模拟赛] Yuno loves sqrt technology II](https://www.luogu.com.cn/problem/P5047)

这道题加了一个数据结构叫值域分块，其实就是把分块当一个桶来使。

## Code

看一下代码，感性理解一下，应该是能懂的。

#### 温馨提示

+ 不开 long long 见祖宗。

+ $k$ 可能为 0。

```cpp
%:include"bits/stdc++.h"
using namespace std;
#define N (int)(1e5+10)
int n,m,a[N],c[N],tot=0,siz,belong[N],l=1,r=0,K;
int t[N];
long long ans[N],b[N],d[N]; //不开 long long 见祖宗
struct query {
	int l,r,id;
}q[N];
struct node {
	int l,r,p,id;
};
vector<node>vec1[N],vec2[N];
static char buf[100000],*p1=buf,*p2=buf;
#define gc p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;
int read() {
	int res=0;
	char c=gc;
	while (!isdigit(c)) c=gc;
	while (isdigit(c)) res=(res<<1)+(res<<3)+(c^48),c=gc;
	return res;
}
void write(long long x) {
	static int sta[50],top=0;
	do {
		sta[top++]=x%10,x/=10;
	}while (x);
	while (top) putchar(sta[--top]+48);
	putchar('\n');
}
inline bool cmp(query a,query b) {
	return (belong[a.l]^belong[b.l]? belong[a.l]<belong[b.l]:(belong[a.l]&1? a.r<b.r:a.r>b.r));
}
inline int lowbit(int x) {
	return x&(-x);
}
inline int one(int x) {
	int ans=0;
	while (x>0) {
		ans++; x-=lowbit(x);
	}
	return ans;
}
signed main() {
	cin>>n>>m>>K;
	for(int i=1;i<=n;i++) cin>>a[i];
	if (K>14) {
		for(int i=1;i<=m;i++) cout<<0<<endl;
		return 0;
	}
	for(int i=0;i<=16384;i++) if (one(i)==K) c[++tot]=i; //k 可能为 0
	siz=sqrt(n); for(int i=1;i<=n;i++) belong[i]=(i-1)/siz+1;
	for(int i=1;i<=m;i++) {
		cin>>q[i].l>>q[i].r;
		q[i].id=i;
	}
	sort(q+1,q+m+1,cmp);
	for(int i=1;i<=m;i++) {
		if (r<q[i].r) vec1[l].push_back((node){r+1,q[i].r,1,q[i].id});
		if (r>q[i].r) vec1[l].push_back((node){q[i].r+1,r,-1,q[i].id});
		r=q[i].r;
		if (l<q[i].l) vec2[r].push_back((node){l,q[i].l-1,-1,q[i].id});
		if (l>q[i].l) vec2[r].push_back((node){q[i].l,l-1,1,q[i].id});
		l=q[i].l;
	}
	for(int i=1;i<=n;i++) {
		b[i]=1ll*t[a[i]]; // 异或具有交换性，a[i]^a[j]=c[k]，则 a[i]^c[j]=a[j]
		for(int j=1;j<=tot;j++) t[a[i]^c[j]]++;
	}
	memset(t,0,sizeof(t));
	for(int i=n;i>=1;i--) {
		d[i]=1ll*t[a[i]];
		for(int j=1;j<=tot;j++) t[a[i]^c[j]]++;
	}
	memset(t,0,sizeof(t));
	for(int i=1;i<=n;i++) {
		for(int j=0;j<vec1[i].size();j++) {
			for(int k=vec1[i][j].l;k<=vec1[i][j].r;k++) {
				ans[vec1[i][j].id]+=1ll*vec1[i][j].p*(b[k]-1ll*t[a[k]]);
			}
		}
		for(int j=1;j<=tot;j++) t[a[i]^c[j]]++;
	}
	memset(t,0,sizeof(t));
	for(int i=n;i>=1;i--) {
		for(int j=0;j<vec2[i].size();j++) {
			for(int k=vec2[i][j].l;k<=vec2[i][j].r;k++) {
				ans[vec2[i][j].id]+=1ll*vec2[i][j].p*(d[k]-1ll*t[a[k]]);
			}
		}
		for(int j=1;j<=tot;j++) t[a[i]^c[j]]++;
	}
	for(int i=2;i<=m;i++) ans[q[i].id]+=ans[q[i-1].id]; //记得把差分还原
	for(int i=1;i<=m;i++) write(ans[i]);
	return 0;
}
```
完结撒花！ ^.^

---

## 作者：Plozia (赞：14)

宣传博客->[link](https://blog.csdn.net/BWzhuzehao/article/details/115003628)

## 详解

首先考虑莫队 ~~废话~~

一种思路就是直接利用普通莫队，每一次移动指针的时候 $O(C_{14}^k)$ 的复杂度来转移，但是这显然会超时。

那么考虑如何优化复杂度。

接下来设 $f(x,[l,r])$ 表示 $x$ 对区间 $[l,r]$ 的贡献，$g([l_1,r_1],[l_2,r_2])$ 表示 $[l_1,r_1]$ 中的每一个数对 $[l_2,r_2]$ 的贡献，也就是 $\sum_{i=l_1}^{r_1}f(a_i,[l_2,r_2])$。

那么在转移的时候，我们对式子做一个变形：

$$f(x,[l,r])=f(x,[1,r]) - f(x,[1,l-1])$$

也就是可以差分。

那么如果记 $h([l,r])$ 表示区间 $[l,r]$ 的答案，那么仿照上面做一遍差分：

$$h([l,r])=h([1,r])-h([1,l-1])-g([1,l-1],[l,r])$$

于是我们发现此时的结果分为两部分：形如 $h([1,k])$ 的和形如 $g([l_1,r_1],[l_2,r_2])$ 的。

那么形如 $h([1,k])$ 的可以采用一遍预处理与一遍莫队求出来，这样就解决了第一部分。

但是 $g([l_1,r_1],[l_2,r_2])$ 要怎么办啊？

看一下前面给出的式子：$g([l_1,r_1],[l_2,r_2])=\sum_{i=l_1}^{r_1}f(a_i,[l_2,r_2])$。

这与莫队指针移动的连续性恰好吻合。

然后如果您学过扫描线，您还可以发现所有形如 $g([l_1,r_1],[l_2,r_2])$ 可以利用扫描线解决。

那么于是我们先用一次莫队算出形如 $h([1,k])$ 的答案以及处理出所有形如 $g([l_1,r_1],[l_2,r_2])$ 的询问，然后一遍扫描线解决答案。

然后最后的答案统计在 $ans$ 数组内。

于是您连样例都过不去。

为什么？上面的过程有问题吗？

其实上面的过程没问题，关键的一点就是在执行上述过程的时候实际上 $ans$ 记录的是答案的变化量，最后还要做一遍前缀和才能通过。

友情提醒：考虑到代码里面使用了先进的 STL：tuple，因此请采用 C++17 及以上编译。

~~当然可以写个结构体~~


代码：

```cpp
/*
========= Plozia =========
	Author:Plozia
	Problem:P4887 【模板】莫队二次离线（第十四分块(前体)）
	Date:本代码书写于 2020/12/16
========= Plozia =========
*/

#include <bits/stdc++.h>
using namespace std;

typedef long long LL;
const int MAXN = 1e5 + 10;
int n, m, k, a[MAXN], t[MAXN], p[MAXN], block, ys[MAXN];
LL ans[MAXN];
struct node
{
	int l, r, id;
	LL ans;
}q[MAXN];
vector <int> b;
vector < tuple <int, int, int, int> > v[MAXN];

int read()
{
	int sum = 0; char ch = getchar();
	while (ch < '0' || ch > '9') ch = getchar();
	while (ch >= '0' && ch <= '9') {sum = (sum << 3) + (sum << 1) + (ch ^ 48); ch = getchar();}
	return sum;
}

bool cmp(const node &fir, const node &sec)
{
	if (ys[fir.l] ^ ys[sec.l]) return ys[fir.l] < ys[sec.l];
	return fir.r < sec.r;
}

int Count(int x)
{
	int sum = 0;
	for (; x; x >>= 1)
		if (x & 1) sum++;
	return sum;
}//统计位数

int main()
{
	n = read(); m = read(); k = read(); block = ceil(n / sqrt(m));
	if (k > 14)
	{
		for (int i = 1; i <= m; ++i) printf("0\n");
		return 0;
	}//坑
	for (int i = 1; i <= n; ++i) {a[i] = read(); ys[i] = (i - 1) / block + 1;}
	for (int i = 1; i <= m; ++i) {q[i].l = read(); q[i].r = read(); q[i].id = i;}
	sort(q + 1, q + m + 1, cmp);
	for (int i = 0; i < 16384; ++i)
		if (Count(i) == k) b.push_back(i);
	for (int i = 1; i <= n; ++i)
	{
		p[i] = t[a[i]];
		for (int j = 0; j < b.size(); ++j) t[a[i] ^ b[j]]++;
	}//预处理
	memset(t, 0, sizeof(t));
	int l = 1, r = 0;
	for (int i = 1; i <= m; ++i)
	{
		if (l > q[i].l) v[r].emplace_back(q[i].l, l - 1, i, 1);
		while (l > q[i].l) q[i].ans -= p[--l];
		if (r < q[i].r) v[l - 1].emplace_back(r + 1, q[i].r, i, -1);
		while (r < q[i].r) q[i].ans += p[++r];
		if (l < q[i].l) v[r].emplace_back(l, q[i].l - 1, i, -1);
		while (l < q[i].l) q[i].ans += p[l++];
		if (r > q[i].r) v[l - 1].emplace_back(q[i].r + 1, r, i, 1);
		while (r > q[i].r) q[i].ans -= p[r--];
	}//莫队，处理 h([1,k]) 答案以及 g([l1,r1],[l2,r2]) 的询问
	for (int i = 1; i <= n; ++i)
	{
		for (int j = 0; j < b.size(); ++j) ++t[a[i] ^ b[j]];
		for (int j = 0; j < v[i].size(); ++j)
		{
            tuple x = v[i][j];
			for (int zzh = get<0>(x); zzh <= get<1>(x); ++zzh)
			{
				if (zzh <= i && k == 0) q[get<2>(x)].ans += get<3>(x) * (t[a[zzh]] - 1);
				else q[get<2>(x)].ans += get<3>(x) * t[a[zzh]];
			}
		}
	}//扫描线
	for (int i = 1; i <= m; ++i) q[i].ans += q[i-1].ans;//注意答案要差分
	for (int i = 1; i <= m; ++i) ans[q[i].id] = q[i].ans;//重新还原答案
	for (int i = 1; i <= m; ++i) printf("%lld\n", ans[i]);
	return 0;
}
```

## 总结

莫队二次离线的式子：$h([l,r])=h([1,r])-h([1,l-1])-g([1,l-1],[l,r])$。

---

## 作者：juju527 (赞：12)

### 二次离线莫队

lxl大佬提出的用于**解决莫队转移复杂度较高问题**的神奇操作

[【模板】莫队二次离线（第十四分块(前体)）](https://www.luogu.com.cn/problem/P4887)

例如此题

我们很容易得出n根号带个组合数的复杂度

这是爆炸的

设一次转移复杂度为k

我们考虑莫队转移时有4种情况

[l,r]变成[l,r+1]时的情况分析如下

记f(x,[l,r])表示a[x]与[l,r]所构成的答案

进行容斥
$$
\Delta ans=f(r+1,[l,r])=f(r+1,[1,r])-f(r+1,[1,l-1])
$$
$\Delta ans$是答案的变化量，这里参考普通莫队的实现
我们发现f(i,[1,i-1])可以对于每一个i预处理出来

预处理的复杂度O(nk)

而对于减去的f我们考虑把r+1这个点**挂在l-1上**

而对于普遍的莫队转移应是[l,r]变为[l,r+p]

那么任意i属于[r+1,r+p]都应挂在l-1上去求f(i,[1,l-1])这个值

我们用一个vector来解决**挂**这个事情

接下来从1到n去枚举挂了区间的点i

由于普通莫队复杂度为n带个根号

也就是说左右指针移动次数是n带个根号级别

那么我们去扫每一个挂在某一个点上的区间最终的复杂度将也是n带个根号

对于把[1,i]这个区间处理好是O(k)的(我们已处理好[1,i-1])

故此操作复杂度O(nk)

而去扫每一个区间总复杂度是$O(n\sqrt n)$的

故总复杂度$O(n\sqrt n+nk)$

我们刚刚只考虑了从[l,r]变到[l,r+p]这样转移的情况

初学的我见到大佬的blog基本都只讨论了此一种情况让天真的我以为只有这一种情况

~~我就是菜~~

我们可以尝试再讨论一种~~因为我懒得讨论完~~

从[l,r]变为[l+p,r]

考虑任意i属于[l+1,l+p]
$$
\Delta ans=f(i,[i+1,r])=f(i,[1,r])-f(i,[1,i])
$$
我们发现f(i,[1,i])可以预处理搞定

我们可以把[l+1,l+p]这个区间挂到r上进行一样操作就行了

接下来还有两种情况基本相同

---

不同的题的分类和需要预处理的东西可能有所不同

但核心思想就是通过容斥把答案分成两部分算

一部分直接预处理得到

另一部分通过二次离线的处理得到

使原本的$O(n\sqrt n k)$降至$O(n\sqrt n+nk)$

这里放一下代码

一些需要注意的地方在代码里均有标注

```cpp
#pragma GCC diagnostic error "-std=c++14"
#pragma GCC target("avx")
#pragma GCC optimize(3)
#pragma GCC optimize("Ofast")
#include<bits/stdc++.h>
using namespace std;
const int maxn=100005,maxm=100005;
int block;
struct Query{
	int id,x,y;
	bool operator <(Query i)const{
		return ((x-1)/block==(i.x-1)/block)?y<i.y:x<i.x;
	}
}q[maxm];
struct seq{
	int l,r,id,op;
};
short a[maxn];
int tot;
int c[1<<14];
int t[1<<14];//t[i]的定义为值为i在当前区间中的答案
long long pre1[maxn],pre2[maxn];
long long ans[maxm],out[maxm];
vector<seq>v[maxn];
inline int read(){
	register int x=0,y=1;
	register char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')y=-1;ch=getchar();}
	while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+(ch^48),ch=getchar();
	return x*y;
}
inline void write(register long long x){
	if(!x)return ;
	write(x/10);
	putchar(x%10+'0');
	return ;
}
inline int lowbit(register int x){
	return x&-x;
}
inline int one(register int x){
	register int ans=0;
	while(x){
		x-=lowbit(x);
		ans++;
	}
	return ans;
}
int main(){
	register int n,m,k;
	register short maxa=0;
	n=read();m=read();k=read();
	if(k>14){
		for(register int i=1;i<=m;i++){putchar('0');putchar('\n');}
		return 0;
	}
	block=sqrt(n);
	for(register int i=1;i<=n;i++){
		a[i]=read();
		maxa=max(maxa,a[i]);
	}
	for(int i=13;i>=0;i--)
		if((1<<i)<=maxa){maxa=i;break;}
	for(register int i=0;i<(1<<maxa+1);i++)
		if(one(i)==k)c[++tot]=i;
	for(register int i=1;i<=n;i++){
		pre1[i]=pre1[i-1]+t[a[i]];
		for(register int j=1;j<=tot;j++)t[a[i]^c[j]]++;
		pre2[i]=pre2[i-1]+t[a[i]];//注意上面讨论的有f(i,[1,i])即i也要算进去
	}
	for(register int i=1;i<=m;i++){
		q[i].id=i;
		q[i].x=read();q[i].y=read();
	}
	sort(q+1,q+m+1);
	q[0].x=1;q[0].y=0;
	for(register int i=1;i<=m;i++){
		register int l=q[i-1].x,r=q[i-1].y;
		register int x=q[i].x,y=q[i].y;
		ans[i]=pre1[y]-pre1[r]+pre2[x-1]-pre2[l-1];
		if(y<r)
			v[l-1].push_back((seq){y+1,r,i,1});
		else if(y>r)
			v[l-1].push_back((seq){r+1,y,i,-1});
		if(x<l)
			v[y].push_back((seq){x,l-1,i,1});
		else if(x>l)
			v[y].push_back((seq){l,x-1,i,-1});
        //这里是默认先把r移到了y在去移动l，故挂在y点上
	}
	memset(t,0,sizeof(t));
	for(register int i=1;i<=n;i++){
		for(register int j=1;j<=tot;j++)t[a[i]^c[j]]++;
		for(register int j=0;j<v[i].size();j++){
			seq o=v[i][j];
			register int l=o.l,r=o.r,id=o.id,op=o.op;
			register long long tmp=0;
			for(register int p=l;p<=r;p++)tmp+=t[a[p]];
			ans[id]+=op*tmp;
		}
	}
	for(register int i=1;i<=m;i++){ans[i]+=ans[i-1];out[q[i].id]=ans[i];}
    //我们在上面考虑的都是ans的变化量，故应该再求前缀和
	for(register int i=1;i<=m;i++){
		if(!out[i])putchar('0');
		else write(out[i]);
		putchar('\n');
	}
	return 0;
}

```

---

## 作者：试试事实上吗 (赞：10)

## 莫队二次离线

最近学了这个黑科技，来写篇题解分享一下。

顺便$orz\;lxl$

#### Part.1 问题引入

有一个序列，每次查询一个区间中有几个二元组的的异或值在二进制下有$k$个$1$。

考虑莫队。

先用莫队转化问题，先考虑我们已经求出$[l,r]$的答案，要将$r+1$加入答案，其他的转移类似，现在问题转化为求$r+1$与$[l,r]$中有几个数的异或值有$k$个$1$。

#### Part.2 暴力

考虑暴力怎么做，由于值域很小$(a_i\leq 16384)$，我们可以先预处理出一个数组$x$中存储有哪些数在二进制数下有$k$个1，每一次插入一个数$a_i$，就把它与$x$数组中所有的数异或起来的值放进一个桶里，然后查询就直接查当前数在桶中出现了几次。为什么呢？

比如我们有$a_i\;xor\;a_j=x$，就有$a_i\;xor\;x=a_j$，我们已经将$a_i\;xor\;x$放入桶里，直接查就可以了。

但这样有个问题，莫队有$n\sqrt n$次转移，每次修改时如果真的暴力插入桶的话，复杂度就是$O(n\sqrt n\times x)$（设$x$为数组中的元素个数），显然是不对的，考虑进一步优化。

#### Part.3 解决

我们进一步挖掘性质，发现我们要求的是$r+1$对$[l,r]$的贡献，实际上我们可以先求它对$[1,r]$的贡献，再减去$[1,l-1]$的贡献，为什么要这么做呢？我们可以发现$r+1$对前者的贡献是可以$O(n\times x)$是可以预处理的，就只用考虑后者的贡献了。

如下图，我们考虑我们已经算出了红色部分的贡献了。

![image.png](https://i.loli.net/2020/08/23/EGqKh8U4bDNysWp.png)

然后我们需要转移绿色部分的贡献。

![image.png](https://i.loli.net/2020/08/23/8V2rwYMEXdHNeQs.png)

这个过程中我们可以发现，左端点是不变，即我们的$[1,l-1]$的答案是不变的，即不用修改，也就是说，我们只有查询操作，而查询操作时$O(1)$的！

所以我们二次离线，先跑一次莫队，将如上的绿色区间保存下来，再统一处理。

具体实现可以每个点开一个$vector$，然后移动右端点的时，我们将如上的绿色区间保存在左端点，移动左端点时，将绿色区间保存在右端点。

然后我们把这些$vector$扫一遍，修改就只有在从$i$到$i+1$时才有，查询还是$O(n\sqrt n)$次，但单次是$O(1)$的。

所以我们的总复杂的就变成了$O(n\sqrt n+n\times x)$！

总结一下，对于那种查询复杂度很高的东西，并且同时询问信息还可以差分的问题，我们就可以用莫队二次离线解决。

做完这题可以去做一下[这个]( https://www.luogu.com.cn/problem/P5047 )，稍微要复杂一点，需要一些其他的数据结构辅助。

这个算法理解其实并不难，主要是代码细节比较多，建议尽量先自己实现，遇到问题再看题解的代码。

```cpp
struct Query_Node
{
    int l,r,id,kl;
    ll ans;
    bool operator < (const Query_Node &u) const{
        return kl!=u.kl?kl<u.kl:(kl&1?r<u.r:r>u.r);
    }
}q[maxn];

struct Node
{
    int l,r,id;
    Node(int l=0,int r=0,int id=0) : l(l),r(r),id(id) {}
};
ll ans[maxn];
vector<Node> two[maxn];
int n,m,k,a[maxn],tax[maxn],klen,pre[maxn];
int isu[maxn],ist;

inline int calc(int x)
{
    int ans=0;
    while(x) ++ans,x-=(x&(-x));
    return ans;
}

template<typename T>
inline void read(T &x)
{
    char c;int f=1;
    while(!isdigit(c=getchar())) (c=='-')&&(f=-1);
    x=c^48;
    while(isdigit(c=getchar())) x=x*10+(c^48);
    x*=f;
}

int main()
{
    read(n);read(m);read(k);
    for(int i=1;i<=n;++i)
        read(a[i]);
    klen=n/sqrt(m*2/3);
    for(int i=1;i<=m;++i)
    {
        read(q[i].l);read(q[i].r);q[i].id=i;
        q[i].kl=(q[i].l-1)/klen+1;
    }
    sort(q+1,q+m+1);
    for(int i=0;i<=maxa;++i) if(calc(i)==k) isu[++ist]=i;
    for(int i=1;i<=n;++i)
    {
        for(int j=1;j<=ist;++j) ++tax[isu[j]^a[i]];
        pre[i]=tax[a[i+1]];
    }
    for(int i=1,l=1,r=0;i<=m;++i)//先空跑莫队，找出绿色区间，同时处理前者的贡献
    {
        if(l<q[i].l) two[r].push_back(Node(l,q[i].l-1,-i));
        while(l<q[i].l) q[i].ans+=pre[l-1],++l;
        if(l>q[i].l) two[r].push_back(Node(q[i].l,l-1,i));
        while(l>q[i].l) q[i].ans-=pre[l-2],--l;
        if(r<q[i].r) two[l-1].push_back(Node(r+1,q[i].r,-i));
        while(r<q[i].r) q[i].ans+=pre[r],++r;
        if(r>q[i].r) two[l-1].push_back(Node(q[i].r+1,r,i));
        while(r>q[i].r) q[i].ans-=pre[r-1],--r;
    }
    memset(tax,0,sizeof(tax));
    //二次离线，处理后者的贡献
    for(int i=1;i<=n;++i)
    {
        for(int j=1;j<=ist;++j) ++tax[isu[j]^a[i]];
        for(vector<Node>::iterator it=two[i].begin();it!=two[i].end();++it)
            for(int j=it->l;j<=it->r;++j)
            {
                int tmp=tax[a[j]];
                if(j<=i&&k==0) tmp--;
                if(it->id<0) q[-it->id].ans-=tmp;
                else q[it->id].ans+=tmp;
            }
    }
    for(int i=1;i<=m;++i) q[i].ans+=q[i-1].ans,ans[q[i].id]=q[i].ans;
    for(int i=1;i<=m;++i)
        printf("%lld\n",ans[i]);
    return 0;
}
```





---

## 作者：zythonc (赞：9)

### 前言

写的比较仓促，所以难免会出错，欢迎指正！

### 核心部分

依然是按正常的莫队思想，首先考虑一种情况，即：考虑区间从 $[l,r]$ 变为了 $[l,r+1]$

设 $f(v,S)$ 表示位置 $v$ 对区间 $S$ 的贡献

那么新增加的贡献就是
$$
f(r+1,[l,r])
$$

直接计算是不行的，我们需要挖掘更多的性质

异或是可以前缀和的，所以我们将上面的式子拆开
$$
f(r+1,[l,r])=f(r+1,[1,r])-f(r+1,[1,l-1])
$$
不难发现左边的式子是一个数对其前面的所有数的贡献

根据 $a\oplus b=c\Rightarrow a\oplus c=b$ 我们第一次离线时即可很容易的计算

重点是我们如何计算后面的式子

后面的式子也不是没有特点，我们发现这都是求一个数对一个固定区间的贡献

于是我们在一次离线时保存一下，第二次离线时计算即可

综上，我们来讨论一下莫队的四种情况

以下设 $l,r$ 表示询问的区间，$L,R$ 表示上一次更新完毕后的左右指针的位置

- $L>l$：也就是说 $L$ 在 $l$ 的右面，向左移动

每次增加的贡献是：
$$
f(L-1,[L,R])=f(L-1,[1,R])-f(L-1,[1,L-1])
$$
后面的式子我们偷个懒，将其化为 $f(L-1,[1,L-2])$

然后我们第一次离线能计算的是后面那一堆，所以是不断进行减法操作

最后我们在 $R$ 的位置保存第二次离线要进行计算的东西，即 $[l,L-1]$ 对 $[1,R]$ 的贡献

根据上式，贡献为正

```
if(l>q[i].l) de[r].push_back((deal){q[i].l,l-1,i,1});
while(l>q[i].l) q[i].cnt-=pref[--l];
```

- $L<l$：也就是说 $L$ 在 $l$ 的左面，向右移动

每次减少的贡献是：
$$
f(L,[L+1,R])=f(L,[1,R])-f(L,[1,L])
$$
依然偷懒，右面化为 $f(L,[1,L-1])$

然后第一次离线计算右面的一堆

因为向右移动是删除，所以两个负号在一起抵消，不断进行加法操作

然后我们在 $R$ 处保存信息，因为要减，贡献为负，设值 $-1$

```
if(l<q[i].l) de[r].push_back((deal){l,q[i].l-1,i,-1});
while(l<q[i].l) q[i].cnt+=pref[l++];
```

- $R<r$：上文已讨论过

```
if(r<q[i].r) de[l-1].push_back((deal){r+1,q[i].r,i,-1});
while(r<q[i].r) q[i].cnt+=pref[++r];
```

- $R>r$：$R$ 在 $r$ 的右面，向左移动

贡献是：
$$
f(R,[l,R-1])=f(R,[1,R-1])-f(R,[1,L-1])
$$
计算上式，然后保存信息即可

```
if(r>q[i].r) de[l-1].push_back((deal){q[i].r+1,r,i,1});
while(r>q[i].r) q[i].cnt-=pref[r--];
```

然后我们根据保存的信息进行第二次离线

这就完了么？

**没有**

上文说到我们偷懒省略了几步计算

但是这是OI不是MO，~~MO的证明少写几步老师**可能**看不出来（暴论~~

于是我们要将没算的算上

首先有保存信息格式：`de[a].push_back((deal){b,c,d,e})`

其次一个位置对自己有贡献当且仅当 $k=0$

经过上文的讨论，我们发现只有左指针移动时会出现偷懒的情况（自己对自己做贡献的情况）

所以根据左指针保存信息的特点，对于一个位置 $i$，有且仅有 $[b,c]$ 中小于等于 $i$ 的位置会减去自己对自己作出的贡献，也就是会 $-1$

因此判两个条件，然后进行二次离线即可

```
for(R int i=1,o,p;i<=n;i++){
	for(o=0;o<saf.size();o++) stk[d[i]^saf[o]]+=1;
	for(o=0;o<de[i].size();o++){
		for(p=de[i][o].l;p<=de[i][o].r;p++)
			q[de[i][o].pl].cnt+=de[i][o].op*(stk[d[p]]-(p<=i&&k==0))
}
for(R int i=1;i<=m;i++) q[i].cnt+=q[i-1].cnt,out[q[i].num]=q[i].cnt;
for(R int i=1;i<=m;i++) printf("%lld\n",out[i]);
```

### 次要内容

1. 我们肯定是要进行预处理的

```
for(R int i=1;i<=n;i++) d[i]=gi(),pl[i]=(i-1)/len+1;	//所属块的位置
for(R int i=1;i<16384;i++) popcnt[i]=popcnt[i>>1]+(i&1);
for(R int i=0;i<16384;i++) if(popcnt[i]==k) saf.push_back(i);
for(R int i=1;i<=m;i++){
	q[i].l=gi(),q[i].r=gi();
	q[i].num=i;
}
sort(q+1,q+m+1);
for(R int i=1;i<=n;i++){
	pref[i]=stk[d[i]];
	for(R int o=0;o<saf.size();o++) stk[d[i]^saf[o]]+=1;
}
```

2. 对于代码中莫队的转移（while部分）其实是可以直接前缀和计算的，之所以写成while是因为笔者认为4个while是莫队的灵魂（雾

---

## 作者：ISYRHH (赞：4)

## P4887 【模板】莫队二次离线（第十四分块(前体)）

------

大概学了个思想就爪巴去自己码代码了，然后不出意料的写假了……

因为觉得删除麻烦就写成回滚莫队了。

实现过程中觉得复杂度不太对，就把一个跑不满的 $n\sqrt{n}C_{14}^{7}$ 的过程改成了跑不满的 $m\sqrt{n}C_{14}^{7}$……写成了一个莫队 1.5 次离线，T 到飞起……

通过后发现好像并没有用回滚莫队写二次离线的题解，写一篇来供大家参考。

（其实因为没有将指针所有的移动全部离线还是应该叫 1.5 次离线？）

![](https://啧.tk/jk)


------

## 题意分析

题意为查询区间中 $\operatorname{xor}$ 和在二进制下有 $k$ 个 1 的二元组的对数。（貌似是 lxl 少有的一眼能读懂题意的题目？）

------

## 解法

### 首先先考虑一个转化：

统计二元组时，最简单的思路是暴力两两判断，但这很明显是不行的……

考虑一个转化：

由于 $\operatorname{xor}$ 的逆运算还是 $\operatorname{xor}$ ，所以考虑满足 $a\operatorname{xor}b=c\left[\operatorname{popcount}(c)=k\right]$ 的 $a$ 的贡献可以转化为统计 $a\operatorname{xor}c\left[\operatorname{popcount}(c)=k\right]$ 的出现次数，这东西很明显可以开桶来维护。

而满足 $\operatorname{popcount}(x)=k$ 的数的个数最多为 $C_{14}^{7}$ ，这样复杂度就降下来一点了。

具体实现可以有两种：

1.在桶中记录数的出现次数，$O(1)$ 修改，$O(C_{14}^{7})$ 查询。

2.在桶中记录 $a\operatorname{xor}c\left[\operatorname{popcount}(c)=k\right]$ 能得到的数的个数，即记录 $b\operatorname{xor}c\left[\operatorname{popcount}(c)=k\right]$ 能得到 $a$ 的 $b$ 的个数，$O(C_{14}^{7})$ 修改，$O(1)$ 查询。

这两种实现各有利弊，结合程序需要决策使用。

### 然后考虑回滚莫队的过程：

回滚莫队避免了删除操作，但还需要实现右指针的右移和处理左指针所在块内的贡献。

对于这两个操作，如果直接按照普通的回滚莫队实现，复杂度是 $n\sqrt{n}C_{14}^{7}$ 的，无法保证复杂度。

所以我们分别考虑一种更高效的实现。

#### 右指针的右移

这部分我们还要按照回滚莫队的基本顺序，以左端点所在块为第一关键字，右端点为第二关键字升序排序。

把 $nl$ 定为当前处理左端点所在块的下一块的开头。

考虑右指针右移的过程需要计算的是 $r$ 对 $\left[nl,r-1\right]$ 的贡献。

这个东西可以差分为 $r$ 对 $\left[1,r-1\right]$ 的贡献减去 $r$ 对 $\left[1,nl-1\right]$的贡献。

对于前一部分，它对每个右指针的位置是固定的，或者说是一个只有 $n$ 个取值的量，可以通过提前预处理求出。

对于后一部分，它的贡献只与左端点所在块有关，可以在进行回滚莫队的过程中，每枚举到一个块，就把这个块的所有数塞进桶里，桶里维护的就是 $\left[1,nl-1\right]$ 的所有数，直接计算桶里的数对于 $r$ 的贡献就是第二部分的结果。

前一部分的预处理需要插入 $n$ 次，查询 $n$ 次，无论是实现 1 还是实现 2 复杂度都是 $O(nC_{14}^{7}+n)$的。

后一部分需要插入 $n$ 次，查询 $n\sqrt{n}$ 次，应选择实现 2,这样复杂度能保证为 $O(nC_{14}^{7}+n\sqrt{n})$。

这部分总的复杂度为$O(2nC_{14}^{7}+n\sqrt{n}+n)$。

#### 处理左端点所在块

还是考虑某个数对答案的贡献，对于一个 $l$ 需要考虑它对 $\left[l+1,r\right]$ 的贡献。

将这个贡献差分成 $l$ 对 $\left[1,r\right]$ 的贡献减去 $l$ 对 $\left[1,l-1\right]$ 的贡献和 $l$ 对 $l$ 自己的贡献。

第二部分直接利用预处理的内容即可，第三部分可以特判 $k=0$。

需要处理的只剩下第一部分。

可以发现这部分的贡献只与 r 有关，可以通过维护 $\left[1,r\right]$ 的桶求出贡献。

但是如果保持回滚莫队的顺序，需要涉及到 r 的回滚，r 要回滚 $\sqrt{n}$ 次，修改就要进行 $n\sqrt{n}$ 次，而查询要进行 $m\sqrt{n}$ 次。

采用实现 1 的复杂度是 $O(n\sqrt{n}+m\sqrt{n}C_{14}^{7})$，采用实现 2 的复杂度是 $O(n\sqrt{n}C_{14}^{7}+m\sqrt{n})$。

无论哪种都是我们不能接受的。

于是我们考虑左端点所在块的处理实际上是与回滚的过程无关的，可以单独拿出来处理。

我们先对询问以右端点的位置升序排序，然后扫一遍序列对每个询问处理出左端点所在块的贡献的第一部分，这样的修改只进行了 $n$ 次，而查询进行了 $m\sqrt{n}$ 次，采用实现 2 的复杂度是 $O(nC_{14}^{7}+m\sqrt{n})$。

这个复杂度是可以接受的。

### 复杂度

由前面的过程可以得知，总的复杂度是 $O(3nC_{14}^{7}+n\sqrt{n}+m\sqrt{n}+n)$。

可以通过该题。

## 代码

```cpp
#include<algorithm>
#include<cstring>
#include<cstdio>
#include<vector>
#include<cmath>
using namespace std;
int n,m,k,in1,in2,dat[100001],loc[100001],num[16384],nm[16384];
long long val[100001],res[100001];//val存预处理的结果，res统计答案 
struct P
{
	int first,second,id;
	P(int fi,int se,int id):first(fi),second(se),id(id){}
};
vector<int>kk;//二进制下有k个1的数 
vector<P>qu;//询问 
//O(1)统计二进制下1的个数 
int cont(int x)
{
	x=(x&0x55555555)+((x>>1)&0x55555555);
	x=(x&0x33333333)+((x>>2)&0x33333333);
	x=(x&0x0F0F0F0F)+((x>>4)&0x0F0F0F0F);
	x=(x&0x00FF00FF)+((x>>8)&0x00FF00FF);
	x=(x&0x0000FFFF)+((x>>16)&0x0000FFFF);
	return x;
}
//预处理二进制下有k个1的数 
void init()
{
	for(int i=0;i<16384;i++)
	{
		if(cont(i)==k)
		{
			kk.push_back(i);
		}
	}
}
//回滚莫队的排序：以左端点所在块递增为第一关键字，右端点递增为第二关键字 
bool cmp(const P &x,const P &y)
{
	return loc[x.first]!=loc[y.first]?loc[x.first]<loc[y.first]:x.second<y.second;
}
//处理左端点所在块的排序：以右端点递增为关键字 
bool ccmp(const P &x,const P &y)
{
	return x.second<y.second;
}
int main()
{
	scanf("%d%d%d",&n,&m,&k);
	int sq=sqrt(n),qn=n/sq;
	for(int i=0;i<=qn;i++)
	{
		for(int j=1;j<=sq&&i*sq+j<=n;j++)
		{
			loc[i*sq+j]=i;
		}
	}
	//特判k大于14（无解）
	//lxl:这个是拿来坑人的 
	if(k>14){for(int i=1;i<=m;i++)printf("0\n");return 0;}
	init();
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&dat[i]);
	}
	//预处理x对[1,x-1]的贡献 
	for(int i=1;i<=n;i++)
	{
		for(vector<int>::iterator ite=kk.begin();ite!=kk.end();ite++)
		{
			val[i]=val[i]+num[(*ite)^dat[i]];
		}
		num[dat[i]]++;
	}
	memset(num,0,sizeof(num));
	for(int i=1;i<=m;i++)
	{
		scanf("%d%d",&in1,&in2);
		qu.push_back(P(in1,in2,i));
	}
	sort(qu.begin(),qu.end(),ccmp);
	int nrr=0;
	//处理左端点所在块对答案的贡献 
	for(vector<P>::iterator ite=qu.begin();ite!=qu.end();ite++)
	{
		if(loc[ite->first]==loc[ite->second])continue;
		while(nrr<ite->second)
		{
			nrr++;
			for(vector<int>::iterator it=kk.begin();it!=kk.end();it++)
			{
				num[(*it)^dat[nrr]]++;
			}
		}
		long long anss=0;
		for(int j=loc[ite->first]*sq+sq;j>=ite->first;j--)
		{
			anss=anss+num[dat[j]]-val[j]-(k==0);
		}
		res[ite->id]=anss;
	}
	memset(num,0,sizeof(num));
	sort(qu.begin(),qu.end(),cmp);
	vector<P>::iterator ite=qu.begin();
	//回滚莫队的过程 
	for(int i=0;i<=qn;i++)
	{
		for(int j=1;j<=sq&&i*sq+j<=n;j++)
		{
			for(vector<int>::iterator it=kk.begin();it!=kk.end();it++)
			{
				num[(*it)^dat[i*sq+j]]++;
			}
		}
		if(loc[ite->first]!=i)continue;
		int nl=i*sq+sq+1,nr=i*sq+sq;long long ans=0;
		while(loc[ite->first]==i)
		{
			if(loc[ite->first]==loc[ite->second])
			{
				long long anss=0;
				for(int j=ite->first;j<=ite->second;j++)
				{
					for(vector<int>::iterator it=kk.begin();it!=kk.end();it++)
					{
						anss=anss+nm[(*it)^dat[j]];
					}
					nm[dat[j]]++;
				}
				for(int j=ite->first;j<=ite->second;j++)
				{
					nm[dat[j]]--;
				}
				res[ite->id]=anss;ite++;if(ite==qu.end())goto hh;
				continue;
			}
			while(nr<ite->second)
			{
				ans=ans+val[++nr]-num[dat[nr]];
			}
			res[ite->id]=res[ite->id]+ans;ite++;if(ite==qu.end())goto hh;
		}
	}
	hh:
	for(int i=1;i<=m;i++)
	{
		printf("%lld\n",res[i]);
	}
	return 0;
}

```


------------

## **end**


---

## 作者：FutaRimeWoawaSete (赞：4)

二次离线莫队，听着好像很难的样子而且也是个黑模板，其实如果你学的快真的看代码都能看懂。     

适用范围在第一篇题解的基础上完善了一下：     

- 首先可以滚莫队，这是废话；    
- 接着就是我们很难在比较快的时间里完成区间递推；这里其实可以类比回滚莫队，只不过回滚莫队可能是一种操作很简单另一种操作无法实现或者很慢，而我们二次离线莫队是两种操作都很慢……     
- 在第二种的基础上，我们设 $f(x , [l,r])$ 表示序列中第 x 个元素对区间 $[l,r]$ 的贡献，满足两个性质：$f(x , [l,r]) = f(x , [1 , r]) - f(x , [1 , l - 1])$ 且 我们可以在很快的时间里计算出 $f(i , [1 , i])$ 。     

其实二次离线莫队的要求还是很多的，而它的例题也是少的可怜……    

那么首先来说一下二次离线莫队是个怎么大致操作的：     

- 预处理出所有的 $f(i  , [1 , i])$ 。     
- 运用莫队滚动的特性：固定一个端点不动，另一个端点自由伸缩，将询问转化成前缀和的形式分成两部分计算：一部分用我们处理出的 $f(i , [1 , i])$ 计算 ， 还有一部分通过某种形式单独拿出来计算；   

大家不要想为什么，先记一下大致的过程即可。      

接着我们以此题举例，首先我们生搬硬套一个莫队上去,接着我们发现我们进行区间递推的时候发现，一次区间递推的时间复杂度是个组合数级别的时间复杂度……     

现在我们肯定得想办法优化每次区间递推，我们想，莫队的 $4$ 个 $while$ 循环都是固定一个端点，另一个端点进行了左右伸缩，我们可不可以从这上面下手？     

我们首先就思考一次区间递推，假设现在从 $[l , r] -> [l , r + 1]$ 。     

那么我们现在的答案肯定会有变动，也就是多了一个 $f(r + 1 , [l , r])$ 贡献。    

那么我们拆拆拆，$f(r + 1 , [l , r]) = f(r + 1 , [1 , r]) - f(r + 1 , [1 , l - 1])$ ， 诶我们发现前面这个东西有点特殊，后面的造成影响的区间是 $[1 , r]$ ，询问的是第 $r + 1$ 个元素，在此题中，这个玩意儿可以直接算啊！！！     

现在我们在仔细想，现在不是在把右端点右移吗？假如区间 $[l , r] -> [l , R]$ 的话呢？      

我们记 $r + 1 \leq x \leq R$ ，那么我们现在就需要计算所有的：    

$f(x , [l , x - 1]) = f(x , [1 , x - 1]) - f(x , [1 , l - 1])$ 。   

那么现在，我们假设只管当前的答案变化了多少，最后对于所有的询问推一个前缀和，就可以获得所有询问的答案。首先我们在莫队中，肯定可以把我们前面这一坨东西给直接算出来，现在就想怎么搞后面的东西，我们又惊奇地发现我们后面的询问， $x$ 都是对 $[1 , l - 1]$ 这个区间造成影响，这个区间左端点是 $1$ ，右端点是 $l - 1$，那么我们只需要把这些询问又都再存一下，然后再跑一个前缀，在得到 $[1 , l - 1]$ 这个区间的信息时就可以查询了吗？     

其他三种情况也同理，我们都可以进行这么转换，论实现的话，你对序列中的每个元素开个 $vector$ ，存到它下面就可以了，不过这样的空间是 $O(m \sqrt n)$ 的，我们还可以直接用个多元祖(可以见@gxy001的题解里面)存下来，就把空间复杂度压到了 $O(2m)$ 了。    

以上就是二次离线莫队的步骤，对于此题，我们发现伟大的毒瘤 $lxl$ 又压了值域，所有我们可以直接预处理 $0 \sim 16384$ 里面的所有有 $k$ 个 $1$ 的数字存入 $b$ 数组，然后做前缀时，我们开个桶 $t$ 表示此时 $t_i$ 在对应的当前这个前缀区间中与多少个数按位异或起来的值有 $k$ 个 $1$ ，每次更新时枚举一边 $b$ 数组里面的所有数，使 $t_{a_i \operatorname{xor} b_j} ＋ 1$ 即可。     
对于这道题，我们还要特判一下 $k = 0$，具体见代码。    
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<vector>
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int Len = 4e5 + 5;
struct node
{
	int l,r,idx;
	int ans;
}Sec[Len];

struct Node
{
	int l,r,idx,op;
};
vector<Node> q[Len];
vector<int> b;
int n,m,k,siz,a[Len],t[Len],p1[Len],block[Len];//p1:[1,{1 , l - 1}] , p2:[1,{1,l}] 
int Print[Len];
bool cmp(const node &x,const node &y)
{
	if(block[x.l] ^ block[y.l]) return block[x.l] < block[y.l];
	return x.r < y.r;
}
int Count(int x)
{
	int res = 0;
	for( ; x ; x >>= 1) if(x & 1) res ++;
	return res;
}
signed main()
{
	scanf("%lld %lld %lld",&n,&m,&k);
	if(k > 14)
	{
		for(int i = 1 ; i <= m ; i ++) puts("0");
		return 0;	
	}
	siz = sqrt(n);
	for(int i = 0 ; i < 16384 ; i ++) if(Count(i) == k) b.push_back(i);
	for(int i = 1 ; i <= n ; i ++) 
	{
		scanf("%lld",&a[i]);
		block[i] = (i - 1) / siz + 1;
	}
	for(int i = 1 ; i <= m ; i ++) 
	{
		scanf("%lld %lld",&Sec[i].l,&Sec[i].r);
		Sec[i].idx = i;
	}
	sort(Sec + 1 , Sec + 1 + m , cmp);
	for(int i = 1 ; i <= n ; i ++)
	{
		p1[i] = t[a[i]];
		for(int j = 0 ; j < b.size() ; j ++) t[a[i] ^ b[j]] ++;
	}
	memset(t , 0 , sizeof t);
	int l = 1 , r = 0;
	for(int i = 1 ; i <= m ; i ++)
	{
		if(l > Sec[i].l) q[r].push_back((Node){Sec[i].l , l - 1 , i , 1});
		while(l > Sec[i].l) Sec[i].ans -= p1[-- l];
		if(r < Sec[i].r) q[l - 1].push_back((Node){r + 1 , Sec[i].r , i , -1});
		while(r < Sec[i].r) Sec[i].ans += p1[++ r];
		if(l < Sec[i].l) q[r].push_back((Node){l , Sec[i].l - 1 , i , -1});//因为对于原来的答案而言，现在是要减去这些值，所以把原式取了个-1 
		while(l < Sec[i].l) Sec[i].ans += p1[l ++];
		if(r > Sec[i].r) q[l - 1].push_back((Node){Sec[i].r + 1 , r , i , 1});//与上同 
		while(r > Sec[i].r) Sec[i].ans -= p1[r --];
	}
	for(int i = 1 ; i <= n ; i ++)
	{
		for(int j = 0 ; j < b.size() ; j ++) t[a[i] ^ b[j]] ++;
		for(int j = 0 ; j < q[i].size() ; j ++)
		{
			Node Calc = q[i][j];
			for(int z = Calc.l ; z <= Calc.r ; z ++)
			{
				if(z <= i && k == 0) Sec[Calc.idx].ans += Calc.op * (t[a[z]] - 1);
				else Sec[Calc.idx].ans += Calc.op * t[a[z]];
			}
		}
	}
	for(int i = 1 ; i <= m ; i ++) Sec[i].ans += Sec[i - 1].ans;
	for(int i = 1 ; i <= m ; i ++) Print[Sec[i].idx] = Sec[i].ans;
	for(int i = 1 ; i <= m ; i ++) printf("%lld\n",Print[i]);
	return 0;
}
```

---

## 作者：KiDDOwithTopTree (赞：3)

题目在这：[传送门](https://www.luogu.com.cn/problem/P4887)。

感觉学完这个算法之后脑细胞急剧减少…

我们可以先考虑进行普通莫队。

然后发现更新答案极其之慢…

这就需要莫队二次离线了。

我们可以设一个点 $x$ 在区间 $[1,y]$ 所做的贡献为 $f_{x,y}$，那么点 $x$ 在区间 $[l,r]$ 所做的贡献则为 $f_{x,r}-f_{x,l-1}$。

~~那么把所有的 $x$ 为所有的前缀所做的贡献算出来不就行了？~~

空间爆炸…

既然是莫队嘛，那么就肯定要有莫队的一些精髓才行啊。

```cpp
for(int i=1;i<=m;i++){
	while(l<q[i].l)
		del_ans(l++);
	while(r<q[i].r)
		add_ans(++r);
	while(l>q[i].l)
		add_ans(--l);
	while(r>q[i].r)
		del_ans(r--);
}
```

好的这一段是必备的。

```add_ans``` 和 ```del_ans``` 把一个点的贡献给增加或删除。但是我们也可以发现，直接操作是极其低效的。那么我们应该做出改变。

我们可以先把一部分求出来，再求另一部分。

我们可以设点 $x$ 在区间 $[1,x]$ 所做的贡献为 $f_x$，那么这样在 ```while``` 把一部分贡献处理出来，然后再次离线算剩下的贡献。

那么怎么处理 ```while``` 中的贡献和二次离线的贡献呢？

我们是设点 $x$ 在区间 $[l,r]$ 中的贡献为 $g_{x,l,r}$，然后万恶分类讨论开始：

#### 1. 当前左端点在询问左端点的左边（$l<ql$）：

这个部分就是让在区间 $[l,ql-1]$ 中的所有点 $x$ 对区间 $[x+1,r]$ 的贡献删去。那么我要得到 $g_{x,x+1,r}$，很明显可以用 $g_{x,1,r}-g_{x,1,x}$ 来得到。

#### 2. 当前右端点在询问右端点的左边（$r<qr$）：

这个部分就是让在区间 $[r+1,qr]$ 中的所有点 $x$ 对区间 $[l,x]$ 的贡献加上。那么我要得到 $g_{x,l,x}$，很明显可以用 $g_{x,1,x}-g_{x,1,l-1}$ 来得到。

#### 3. 当前左端点在询问左端点的右边（$l>ql$）：

同 $1$ 可得。

#### 4. 当前右端点在询问右端点的右边（$r>qr$）：

同 $2$ 可得。

具体的内容可以结合代码进行理解。

最后要提醒一件事：我们求出来的 $ans$ 其实并不是这个问题的真正 $ans$，而是对于上一个询问所增加的部分。于是最后输出之前要进行累加。

```cpp
#include<algorithm>
#include<iostream>
#include<cstring>
#include<vector>
#include<cmath>
using namespace std;
const int N=1e5+10;
struct quest{
	long long ans;
	int l,r;
	int pos;
};
struct node{
	int l,r;
	int opt;
	int pos;
};
quest q[N];
vector<node> v[N];//用vector来进行记录二次离线的信息
int a[N],num[N],blo[N],lm[N],rm[N],f[N],cnt[N];
long long res[N];
int tot;
bool cmp(quest x,quest y){
	return blo[x.l]!=blo[y.l]?blo[x.l]<blo[y.l]:x.r<y.r;
}
int count(int val){
	int ans=0;
	for(int i=val;i;i>>=1)
		ans+=i&1;
	return ans;
}
int main(){
	int n,m,t;
	cin>>n>>m>>t;
	for(int i=1;i<=n;i++)
		cin>>a[i];
	int block=sqrt(n);
	for(int i=1;i<=block;i++){
		lm[i]=(i-1)*block+1;
		rm[i]=i*block;
	}
	rm[block]=n;
	for(int i=1;i<=block;i++)
		for(int j=lm[i];j<=rm[i];j++)
			blo[j]=i;
	for(int i=1;i<=m;i++){
		cin>>q[i].l>>q[i].r;
		q[i].pos=i;
	}
	sort(q+1,q+m+1,cmp);
	for(int i=0;i<16384;i++)
		if(count(i)==t)
			num[++tot]=i;
	for(int i=1;i<=n;i++){
		f[i]=cnt[a[i]];
		for(int j=1;j<=tot;j++)
			cnt[a[i]^num[j]]++;
	}
	int l=1,r=0;
	node tmp;
	for(int i=1;i<=m;i++){
		if(l<q[i].l){
			tmp.pos=i;
			tmp.l=l;
			tmp.r=q[i].l-1;
			tmp.opt=-1;
			v[r].push_back(tmp);
		}
		while(l<q[i].l)
			q[i].ans+=f[l++];
		if(r<q[i].r){
			tmp.pos=i;
			tmp.l=r+1;
			tmp.r=q[i].r;
			tmp.opt=-1;
			v[l-1].push_back(tmp);
		}
		while(r<q[i].r)
			q[i].ans+=f[++r];
		if(l>q[i].l){
			tmp.pos=i;
			tmp.l=q[i].l;
			tmp.r=l-1;
			tmp.opt=1;
			v[r].push_back(tmp);
		}
		while(l>q[i].l)
			q[i].ans-=f[--l];
		if(r>q[i].r){
			tmp.pos=i;
			tmp.l=q[i].r+1;
			tmp.r=r;
			tmp.opt=1;
			v[l-1].push_back(tmp);
		}
		while(r>q[i].r)
			q[i].ans-=f[r--];
	}//易错，要仔细思考
	memset(cnt,0,sizeof cnt);
	int len,opt,pos;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=tot;j++)
			cnt[a[i]^num[j]]++;
		len=v[i].size();
		for(int j=0;j<len;j++){
			l=v[i][j].l;
			r=v[i][j].r;
			opt=v[i][j].opt;
			pos=v[i][j].pos;
			for(int k=l;k<=r;k++)
				q[pos].ans+=opt*(cnt[a[k]]-(k<=i&&!t));
		}
	}
	for(int i=1;i<=m;i++)
		q[i].ans+=q[i-1].ans;
	for(int i=1;i<=m;i++)
		res[q[i].pos]=q[i].ans;
	for(int i=1;i<=m;i++)
		cout<<res[i]<<'\n';
}
```

时间复杂度分析：

前面都好想，主要是第二次离线的复杂度有点难想。

设更新答案的时复为 $O(k)$

首先第一部分是来更新答案，时复为 $O(nk)$。

第二部分则是计算答案。由前面的普通莫队证明方法可以证得时复为 $O(n \sqrt n)$

所以总时复为 $O(nk)+O(n \sqrt n)+O(nk+n \sqrt n)=O(nk+n \sqrt n)$

如果您不喜欢用 $\text{STL}$ 的话，您可以试试使用类似链式前向星的方法代替 $\text{vector}$，不过码量可能会有亿点点长。

---

## 作者：_LHF_ (赞：3)

### 不会莫队的请先学会普通莫队再来做。

对于本题，可以选择用普通莫队来做，当然……

每次更新时间：$o(C_{14}^k)$。~~你看我还有机会吗？~~

所以就要请出我们的高科技：
# 二次离线莫队
优点：可以实现$O(1)$更新答案。

此题用二次离线莫队可以达到$O(n\sqrt n+nC_{14}^k)$的复杂度。

首先，我们设$f(x,[l,r])$，表示数x对区间$[l,r]$的贡献

那么当r指针右移的时候，我们发现它新增的贡献是$f(r+1,[l,r])$

然后我们又发现：$f(r+1,[l,r])=f(r+1,[1,r])-f(r+1,[1,l-1])$

呃呃，设$s[r+1]=f(r+1,[1,r])$，那么$s$数组可以用$O(nC_{14}^k)$预处理出来，这里用到了一个东西：$a\space xor\space b=c\space=>\space a^\space xor\space c=b$(如果你不会……那没希望了）

给一下代码：
```cpp
#define K 16384

for(int i=0;i<K;i++)
{
	int w=0;
	for(int j=0;j<14;j++)
		if((1<<j)&i) w++;
	if(w==k)
	{
		d[++len]=i;
	}
}
for(int i=1;i<=n;i++)
{
	scanf("%d",&a[i]);
	for(int j=1;j<=len;j++)
	{
		s[i]+=t[d[j]^a[i]];
	}
	t[a[i]]++;
}
```


对于后面的$f(r+1,[1,l-1])$，好像不大好处理……

没关系，我们可以把它们列出来集体搞一下。

因为最多会移动$n\sqrt n$次，所以我们可以寻找一个方法，使得可以快速查询。

然后由于插入最多只有$n$次，所以插入的时候随便。

然后我们惊奇的发现，我们可以达到$O(n\sqrt n+nC_{14}^k)$的时间复杂度。

细心的小朋友可能会发现，对于本题前$50%$空间限制和后面的不一样。

因为逐个存储的话空间复杂度是$O(n\sqrt n)$，但这个问题很好解决，因为每一次挪动的都是连续的一段，我们只要把连续这一段存储下来就可以了。

存储连续段建议使用vector。

莫队常规操作，代码：
```cpp
struct node{
	int l,r,id,k;
	void read()
	{
		scanf("%d%d",&l,&r);
		k=l/block;
	}
}q[N];//q[i]表示第i个询问
vector<node> A[N];

int l=1,r=0;
for(int i=1;i<=m;i++)
{
	if(r<q[i].r)
	{
		for(int j=r+1;j<=q[i].r;j++) ans[q[i].id]+=s[j];
		A[l-1].push_back((node){r+1,q[i].r,q[i].id,-1});
		r=q[i].r;
	}
	if(l>q[i].l)
	{
		for(int j=q[i].l;j<l;j++) ans[q[i].id]-=s[j];
		A[r].push_back((node){q[i].l,l-1,q[i].id,+1});
		l=q[i].l;
	}
	if(l<q[i].l)
	{
		for(int j=l;j<q[i].l;j++) ans[q[i].id]+=s[j];
		A[r].push_back((node){l,q[i].l-1,q[i].id,-1});
		l=q[i].l;
	}
	if(r>q[i].r)
	{
		for(int j=q[i].r+1;j<=r;j++) ans[q[i].id]-=s[j];
		A[l-1].push_back((node){q[i].r+1,r,q[i].id,+1});
		r=q[i].r;
	}
}
```
这里要提醒一点：一定要弄清楚所给的区间是否包含左右端点，如果弄不懂可以画图理解一下。

聪明的小朋友可能会发现这里有一点点问题，本题解会讲到。

然后是批量处理区间的代码，如下：
```cpp
for(int i=1;i<=n;i++)
{
	for(int j=1;j<=len;j++) t[a[i]^d[j]]++;
	l=A[i].size();
	for(int j=0;j<l;j++)
	{
		for(int x=A[i][j].l;x<=A[i][j].r;x++)
		{
			if(x<=i&&k==0) ans[A[i][j].id]--;
			ans[A[i][j].id]+=t[a[x]]*A[i][j].k;
		}
	}
}
```
但还有一点非常的坑：
### 当$k=0$时……
如果你不注意，本题你就只有30分了

呃呃，如果你不介意的话，你可以特判一下。

因为$k=0$的时候只有自己异或自己才能保证在二进制下有$k$个1，所以本题约等于是[1494小Z的袜子](https://www.luogu.com.cn/problem/P1494)

我太弱了，因为区间关系太复杂，弄得我不知道如何搞k=0的情况，所以我就复制了一下我P1494那一题的部分代码，然后封装了一下。
## 然后就愉快的AC了。
具体代码就不给了，~~留给读者独立思考的空间~~（逃

---

## 作者：Others (赞：2)

此题解适用于还不晓得什么是二次离线莫队的朋友，dalao 可选择性阅读（就是很废话那种）。

这题还是很良（du）心（liu），也就不到 100 行，但细节丰富（根本扛不住）。
# 二次离线莫队
首先看题，题目要求的是异或值在二进制下有 $k$ 个 1 的数对个数，先不管什么是二次离线莫队，我们用普通莫队的思路思考。

考虑插入一个数，在插入时要看当前区间里的所有数（关键是这题还不好搞 Bit，Segment_Tree 等数据结构），只好硬着头皮上，直接一个 $O(n^2\sqrt n)$ 带走，这就要用到二次离线莫队了。

首先这题考虑插入一个数对区间的贡献，即 $i\in[l,r-1]$ 中有多少数异或 $a_r$ 后的值符合要求，首先直接暴力找肯定是不行的，这里似乎也不好用什么数据结构，于是我就注意到了 $a_i\in [0,16383]$。这能说明什么？可以直接（暴力）统计呀！！（注：这里不是把 $[0,16383]$ 的数全部统计完。）为了方便统计，这里先引进一个东西：异或运算的交换律（和加法交换律不一样）：$a⊕b=c$，即 $a⊕c=b$。

有了这个，我们能方便些什么呢？我们可以先预处理出在区间 $[0,16383]$ 里有哪些数在二进制下有 $k$ 个 1（下面统一称为 $b$）。然后把 $i,j\in[l,r],a_i⊕a_j=b$，转化成：$i,j\in[l,r],a_i⊕b=a_j$ 这样就直接统计有多少个 $a_i$ 就行了，虽然 $n\sqrt n$ 个查询 ok 了，但还有 $n\sqrt n$ 个插入，在搞个常系数（最坏为 $C^7_{14}$）上去，T 飞...

这里再引进一个新技术：差分，将 $a_r$ 对 $a_i,i\in[l,r-1]$ 的贡献差分为 $a_r$ 对 $a_i,i\in[1,r-1]$ 的贡献减去 $a_r$ 对 $a_i,i\in[1,l-1]$ 的贡献，这里注意不能乱差分，因为这题的贡献是“1 对 1”（就是把贡献的区间割一下不影响答案之和），所以可以差分。这样就可以预处理前缀了，但是我们还是逃不掉 $a_r$ 对 $a_i,i\in[1,l-1]$ 的贡献······意思是在更新答案时还是不能做到 $O(1)$ 的复杂度。

补充一下，这里其实还要预处理后缀，因为在移动左端点时要用到。这里好像还体现不出差分的优势（耐心一点嘛 qwq）。

这就要一个黑科技：二次离线莫队。

首先我们将查询的移动过程离线下来，存在一个容器里，注意在存储过程中要配合好我们预处理的前（后）缀，要辨识出要用的是前缀还是后缀，要减去的区间是哪段，这里用前缀还是后缀可以开两个容器，减去的区间就用数组下标就行了。

按这样发展，那岂不是要开 $O(n^2)$ 的二维数组？但是思考一下，我们这样做会浪费很多空间，所以只好开 ```vector```，但这还是不行，会卡 cache（$O(n\sqrt n)$ 的空间复杂度），那为何不存移动的区间呢？这样既可以不被卡 cache 也可以完美的存下二次离线莫队需要的东西。

接下来就是二次离线莫队最精髓的部分了——处理离线下来的查询。这里我们就是要直面差分后无法逃脱的那个东西：$a_r$ 对 $a_i,i\in[1,l-1]$ 的贡献，这里就是要正确处理 $a_i,i\in[1,l-1]$，前面会 T 飞的原因其实就是这一段数据会被重复计算好多好多遍，所以我们离线下来就是为了避免重复计算，具体方法就是从 1 到 $n$ 走一遍，遇到要用的 $a_i,i\in[1,l-1]$ 就拿出来用，然后配合前缀一波带走（后缀也是一样的）。

这样的时间复杂度就是 $O(n\sqrt n)$ 加上那个常系数（就是 $C^7_{14}$ 那个）乘上 $O(n)$。所以说这是个“黑科技”。

在开头提出的细节丰富，这里提几点：
- 对询问排序。
- 初始化统计数组。
- 最后要还原答案所在的数组（因为在处理时时处理的局部）。
- 记得给合适的元素开 ```long long```，不然你猜是 TLE 还是 MLE。

最后给出处理那一步的参考代码。
```cpp
for(int i=1;i<=n;i++){//i:要割去的区间为[1,i) 
    for(int j=0;j<QZ[i].size();j++){//对于这个i要处理的所有询问 
        for(int k=QZ[i][j].l;k<=QZ[i][j].r;k++){//[QZ[i][j].l,QZ[i][j].r]:需要前缀且的移动区间 
            ans[QZ[i][j].id]+=QZ[i][j].op*(qz[k]-t[a[k]]);//QZ[i][j].id:对应的询问的下标 
        }                                                 //QZ[i][j].op:这个贡献是正的还是负的 
    }                                                     //qz[k]:[k,k]对[1,k)的贡献(即前缀),t[a[k]]:对于a[k],在[1,i)中有多少数与它异或后符合要求 
    for(int j=1;j<=top;++j) t[(a[i]^cnt[j])]++; //cnt[1~top]在[0,16384)中符合要求的数 
}
```

---

## 作者：Demoe (赞：2)

### [题目传送门](https://www.luogu.com.cn/problem/P4887)

~~lxl 大爷的题 DS 才是正道~~

~~[P3246 [HNOI2016]序列](https://www.luogu.com.cn/problem/P3246)这道题更模板（确信）~~

## 题意

- 给定序列，每次询问区间内满足异或后二进制下有 $k$ 位 $1$ 的二元组数。

## Sol

考虑莫队。

如果增量时暴力扫一遍的话，复杂度会成 $O(n^2\sqrt n \log a_i)$。

开桶增量的话是 $O(n\sqrt n \times \dbinom{14}{k})$。

十 分 恐 怖

这里仅考虑 $r$ 向右增量，以此类推即可qaq。

可得增量答案即为 $\Delta ans=ans(1,r-1,r)-ans(1,l-1,r)$ 其中 $ans(i,j,k)$ 表示 $[i,j]$ 中与 $r$ 满足题目要求的二元组。

我们发现 $ans(1,r-1,r)$ 可以预处理。开桶复杂度 $O(\dbinom{14}{k}n)$。

考虑处理 $ans(1,l-1,r)$。

先把它扔掉。（

我们考虑莫队结束后，暴力搜。

记录对于**每个询问**的**总**增量。

然后暴力在最后跑那一段。

为什么这个能保证复杂度呢？

我们考虑总段长不超过 $n\sqrt n$。

在暴力更新段的时候同时也更新桶。

那么对于段上每个点可用 $O(1)$ 更新。

即暴力复杂度为 $O(n\sqrt n+\dbinom{14}{k}n)$。

总复杂度即为 $O(n\sqrt n+\dbinom{14}{k}n)$。

哦 对了，不开 $\text{long long}$ 会挂/youl。

```cpp
/*
***
还要继续努力
成为一名烤咕学家哦
***
*/
#include<bits/stdc++.h>
#define re register int
using namespace std;
typedef long long ll;
const ll N=1e5+5;
ll n,m,k,a[N],len,cnt[N],s[N],l=1,r=0;ll ans[N];
struct Question{ll l,r,id,pos;ll ans;}q[N];
struct Left{ll l,r,id;};
vector<Left> v[N];vector<int> av;
template <typename T> inline void rd(T &x){
	re fl=1;x=0;char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') fl=-fl;
	for(;isdigit(c);c=getchar()) x=(x<<3)+(x<<1)+c-'0';
	x*=fl;
}
void wr(ll x){
	if(x<0) x=-x,putchar('-');
	if(x<10) putchar(x+'0');
	if(x>9) wr(x/10),putchar(x%10+'0');
}
bool cmp(Question x,Question y){
	if(x.pos^y.pos) return x.pos<y.pos;
	return x.r<y.r;
}
int main(){
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	rd(n);rd(m);rd(k);len=(int)sqrt(n);
	if(k>14){for(ll i=1;i<=m;i++) puts("0");return 0;}
	for(re i=1;i<=n;i++) rd(a[i]);
	for(re i=1;i<=m;i++) rd(q[i].l),rd(q[i].r),q[i].id=i,q[i].pos=(q[i].l-1)/len+1;
	sort(q+1,q+m+1,cmp);
	for(re i=0;i<16384;i++) if(__builtin_popcount(i)==k) av.push_back(i);
	for(re i=1;i<=n;i++){
		for(re j=0;j<av.size();j++) cnt[a[i]^av[j]]++;s[i]=cnt[a[i+1]];
	}
	for(re i=1;i<=m;i++){
		if(l>q[i].l) v[r].push_back((Left){q[i].l,l-1,i});
		while(l>q[i].l) --l,q[i].ans-=s[l-1];
		if(r<q[i].r) v[l-1].push_back((Left){r+1,q[i].r,-i});
		while(r<q[i].r) ++r,q[i].ans+=s[r-1];
		if(l<q[i].l) v[r].push_back((Left){l,q[i].l-1,-i});
		while(l<q[i].l) q[i].ans+=s[l-1],l++;
		if(r>q[i].r) v[l-1].push_back((Left){q[i].r+1,r,i});
		while(r>q[i].r) q[i].ans-=s[r-1],r--;
	}
	memset(cnt,0,sizeof(cnt));
	for(re i=1;i<=n;i++){
		for(re j=0;j<av.size();j++) cnt[a[i]^av[j]]++;
		for(re j=0;j<v[i].size();j++){
			for(re u=v[i][j].l;u<=v[i][j].r;u++){
				ll sum=cnt[a[u]];
				if(u<=i&&!k) sum--;
				if(v[i][j].id<0) q[-v[i][j].id].ans-=sum;
				else q[v[i][j].id].ans+=sum;
			}
		}
	}
	for(re i=1;i<=m;i++) q[i].ans+=q[i-1].ans;for(re i=1;i<=m;i++) ans[q[i].id]=q[i].ans;
	for(re i=1;i<=m;i++) wr(ans[i]),puts("");
	return 0;
}
```

---

## 作者：Duramente (赞：0)

我们考虑区间 $[l,r]$ 变成区间 $[l,r+1]$ 对答案的贡献。   


显然，答案加上了 $[l,r]$ 中与 $a_{r+1}$ 的配对数。  
计 $h(j)$ 为 $[1,j]$ 中与 $a_{r+1}$ 的配对数，那么答案的增量为 $h(r)-h(l-1)$ 。

我们再计 $f(i)$ 为 $[1,i]$ 中与 $a_{i+1}$ 的配对数  。
计 $g(x)$ 为 $[1,i]$ 中与 $x$ 的配对数  。  
容易得到 $f(i)=g(a_{i+1})$   。

考虑该怎么求 $f$ 和 $g$   。  
 $f$ 最大为 $C_{14}^{k}$ ，最大为 $3432$ 个二进制中有 $k$ 个 $1$ 的数，再乘上一个 $n$ 可以跑过去，于是就考虑用桶的思路**暴力**求。  

先统计出来所有二进制中有 $k$ 个 $1$ 的数，设为$num$  。  
 ${a_{i}}⊕x=num$ 根据异或的性质  ，
$a_{i}⊕num=x$  。  
遍历所有 $a_i$ 。对每一个$num$，
```cpp
g[num^a[i]]++;
```

 
意思是目前 $x$ 与 $a_i$ 配对， $x$ 与 $[1,i]$ 中的数配对数 $+1$ 。

然后 $f$ 和 $g$ 就在 $O(3432\times n) $ 的时间内被求了出来。

$h(r)-h(l-1)$ 中， $h(r)=f(r)$ 。   
然后从 $[l,r]$ 移动到 $[l,R]$ 的过程中 $(R>r)$ ， $h(l)$ 的总和为 $[1,l-1]$ 中的数与 $[r+1,R]$ 的配对数。    


感觉和求 $f$ 的时候很像，于是记录下这个区间等会离线跑。  

怎么跑？对于所有这些区间，按照这个 $l-1$ 排序，然后 $g$ 就顺着 $l-1$ 求了出来,恰恰好是当前 $[r+1,R]$ 区间需要用的 $g$（因为是和 $[1,l-1]$ 中的数配对），此时用 $x$ 从 $r+1$ 遍历到 $R$ ,每次对贡献加上 $g(a_x)$ 。

复杂度和普通莫队证法一样。是 $O(n\sqrt n)$ 。

这只是其中一种情况。总的将4中情况重新讨论一遍。  

1.右端点加  $[l,r]->[l,R]$  
答案每次贡献为 $h(r)-h(l-1)$  。   
在莫队移动区间时求 $h(r)$( $\space=f(r)\space$) 。  
另一部分将 $[r+1,R]$ 记录下来，存在以 $l-1$ 为下标的vector中，离线遍历。

2.右端点减  $[l,r]->[l,R]$  
答案每次贡献为 $h(l-1)-h(r-1)$  。
$h(r-1)=f(r-1)$  。  
另一部分将 $[R,r-1]$ 记录下来，如法炮制求与$[1,l-1]$ 的配对数 。

3.左端点减(增加数） $[l,r]->[L,r]$  
答案每次贡献为 $h(r)-h(l-1)$ 。  
$h(l-1)=f(l-2)+!k$ 。（因为只有当$k=0$时，自己会和自己配对  。  
另一部分将 $[L,l-1]$ 记录下来，求与 $[1,r]$ 配对数 。

4.左端点加(删除数) $[l,r]->[L,r]$  
答案每次贡献为 $h(l)-h(r)$  。
$h(l)=f(l-1)+!k$  。  
另一部分将 $[l+1,L]$ 记录下来，求与 $[1,r]$ 配对数  。

然后按照莫队的思路统计答案，注意这里处理出来的是对答案贡献的增量，前缀和统计。


$Code$

```cpp
#include<bits/stdc++.h>
#define forn(i,a,b)for(int i=(a),_b=(b);i<=_b;i++)
#define fore(i,b,a)for(int i=(b),_a=(a);i>=_a;i--)
#define rep(i,n)for(int i=0,_n=n;i<n;i++)
#define ll long long
#define pii pair<int,int>
#define m_p make_pair
#define pb push_back
#define fi first
#define se second
#define foreach(i,c) for(__typeof(c.begin())i=(c.begin());i!=(c).end();i++)
#define int ll
using namespace std;
const int N=100010;
int B;
int n,m,k;
struct Mo{
	int l,r;
	int id;
	int res;
}qu[N];
int a[N]; 
int g[N],f[N];
vector<int>v;
vector<Mo>mo_a[N];//加 
vector<Mo>mo_b[N];//减 
int ans[N];  
bool cmp(Mo a,Mo b){
	if(a.l/B!=b.l/B)return a.l/B<b.l/B;
	return a.r<b.r;
}
signed main(){
	ios::sync_with_stdio(0);
	cin>>n>>m>>k;
	forn(i,1,n){
		cin>>a[i];
	}
	rep(i,m){
		cin>>qu[i].l>>qu[i].r;
		qu[i].id=i;
	}
	B=sqrt(n);
	sort(qu,qu+m,cmp);
	rep(i,1<<14){
		if(__builtin_popcount(i)==k){
			v.pb(i);
		}
	}
	forn(i,1,n){
		rep(j,v.size()){
			g[a[i]^v[j]]++;
		}
		f[i]=g[a[i+1]];
	}
	int l=1,r=0;
	rep(i,m){
		int L=qu[i].l,R=qu[i].r;
		if(r<R){
			Mo q;
			q.l=r+1;q.r=R;q.id=i;
			mo_b[l-1].pb(q);
			while(r<R){
				qu[i].res+=f[r];
				r++;
			}
		}
		if(l>L){
			Mo q;
			q.l=L;q.r=l-1;q.id=i;
			mo_a[r].pb(q);
			while(l>L){
				qu[i].res-=f[l-2]+!k; 
				l--;
			}
		}
		if(r>R){
			Mo q;
			q.l=R+1;q.r=r;q.id=i;
			mo_a[l-1].pb(q);
			while(r>R){
				qu[i].res-=f[r-1];
				r--;
			}
		}
		if(l<L){
			Mo q;
			q.l=l;q.r=L-1;q.id=i;
			mo_b[r].pb(q);
			while(l<L){
				qu[i].res+=f[l-1]+!k;
				l++;
			}
		}
	}
	memset(g,0,sizeof(g));
	forn(i,1,n){
		rep(j,v.size()){
			g[a[i]^v[j]]++;
		}
		rep(j,mo_a[i].size()){
			Mo q=mo_a[i][j];
			int l=q.l,r=q.r,id=q.id;
			forn(x,l,r){
				qu[id].res+=g[a[x]];
			}
		}
		rep(j,mo_b[i].size()){
			Mo q=mo_b[i][j];
			int l=q.l,r=q.r,id=q.id;
			forn(x,l,r){
				qu[id].res-=g[a[x]];
			}
		}
	}
	rep(i,m){
		ans[qu[i].id]=qu[i].res;
		qu[i+1].res+=qu[i].res;
	}
	rep(i,m)cout<<ans[i]<<"\n";
	return 0;
}

```


---

## 作者：tzc_wk (赞：0)

[题面传送门](https://www.luogu.com.cn/problem/P4887)

莫队二次离线 mol ban tea，大概是[这道题](https://www.luogu.com.cn/problem/P5501)让我第一次听说有这东西？

首先看到这类数数对的问题可以考虑莫队，记 $S$ 为二进制下有 $k$ 个 $1$ 的数集，我们实时维护一个桶 $cnt_i$ 表示当前区间中值为 $i$ 的数有多少个，那么加入一个数 $v$ 的时候，答案会增加 $\sum\limits_{y\in S}cnt_{y\oplus v}$，这样暴力莫队复杂度是 $n\sqrt{n}\dbinom{14}{k}$，~~如果你过了我请你吃糖~~

考虑优化，我们记 $f(x,l,r)$ 表示当前区间为 $[l,r]$，加入 $a_x$ 后答案的增量，记 $\sum\limits_{y\in S}cnt_{y\oplus a_x}$。考虑莫队中每个端点的移动对答案的贡献，我们以右端点为例，设右端点由 $r$ 移动到了 $r'$，这里我们不妨设 $r'>r$，$r'<r$ 的情况也同理，那么答案显然会增加 $\sum\limits_{i=r+1}^{r'}f(i,l,i-1)$，这东西不太好直接求，考虑用**差分**的思想，将这东西拆成 $f(i,1,i-1)-f(i,1,l-1)$，那么 $\Delta=\sum\limits_{i=r+1}^{r'}f(i,1,i-1)-\sum\limits_{i=r+1}^{r'}f(i,1,l-1)$，不难发现第一个 $\sum$ 里的东西只与 $i$ 有关，我们可以预处理 $f(i,1,i-1)$ 的前缀和即可 $\mathcal O(1)$ 求出，至于怎么求 $f(i,1,i-1)$……这个看不出来就有点【数据删除】了罢，就从左往右扫一遍并实时维护一个桶 $cnt$，扫到 $a_i$ 的时候 $f(i,1,i-1)$ 的值就是当时 $\sum\limits_{x\in S}cnt_{x\oplus a_i}$。后面那坨东西在线求出不太容易，不过既然叫“莫队二次离线”那就离线一下呗，不难发现所有这样的东西都可以用一个三元组 $(x,l,r)$ 表示 $\sum\limits_{i=l}^rf(i,1,x)$，我们将这样的询问都挂在 $x$ 上然后从左往右扫描一遍，还是实时维护一个桶 $cnt$，不过这时候 $cnt_v$ 的含义为 $[1,i]$ 中有多少个数 $j$ 满足 $v\oplus a_j\in S$，这显然可以在 $\mathcal O(n\dbinom{14}{k})$ 的时间内求出，然后每遇到一个询问 $(i,l,r)$，就暴力枚举 $t\in[l,r]$ 并令贡献加上/减去 $cnt_{a_t}$，由于莫队指针移动的总距离为 $n\sqrt{n}$ 级别的，因此这里的 $\sum r-l+1$ 也是 $n\sqrt{n}$ 级别的，可以通过。

上文所叙述的都是右端点移动的情况，左端点移动的情况大体上也差不多，还是设左端点由 $l$ 移动到了 $l'$，$l'<l$那么答案的增量就是 $\sum\limits_{i=l'}^{l-1}f(i,i+1,r)$，这里有一个小小的区别就是不能差分前缀和，而要差分后缀和，即 $f(i,i+1,r)=f(i,i+1,n)-f(i,r+1,n)$，这两项都可以用类似的方式维护。

最后，由于我们求出的是每次莫队后答案的增量，还需对每次询问的结果求一遍前缀和即可得到每次询问真正的答案。

时间复杂度 $n\sqrt{n}+n\dbinom{14}{k}$

```cpp
const int MAXN=1e5;
const int MAXV=1<<14;
int n,qu,k,a[MAXN+5],blk_sz,blk_cnt;
int bel[MAXN+5],L[MAXN+5],R[MAXN+5];
ll pre[MAXN+5],suf[MAXN+5],anss[MAXN+5];
int buc[MAXV+5];
struct query{
	int l,r,id;ll ans;
	bool operator <(const query &rhs) const{
		if(bel[l]^bel[rhs.l]) return bel[l]<bel[rhs.l];
		else if(bel[l]&1) return r<rhs.r;
		else return r>rhs.r;
	}
} q[MAXN+5];
struct qwq{int l,r,id,op;};
vector<qwq> vl[MAXN+5],vr[MAXN+5];
int main(){
	scanf("%d%d%d",&n,&qu,&k);vector<int> v;
	for(int i=1;i<=n;i++) scanf("%d",&a[i]);
	for(int i=0;i<MAXV;i++) if(__builtin_popcount(i)==k) v.pb(i);
	blk_sz=(int)pow(n,0.5);blk_cnt=(n-1)/blk_sz+1;
	for(int i=1;i<=blk_cnt;i++){
		L[i]=(i-1)*blk_sz+1;R[i]=min(i*blk_sz,n);
		for(int j=L[i];j<=R[i];j++) bel[j]=i;
	}
	for(int i=1;i<=qu;i++) scanf("%d%d",&q[i].l,&q[i].r),q[i].id=i;
	sort(q+1,q+qu+1);int cl=1,cr=0;
	for(int i=1;i<=n;i++){
		pre[i]=pre[i-1];
		for(int j:v) pre[i]+=buc[j^a[i]];
		buc[a[i]]++;
	} memset(buc,0,sizeof(buc));
	for(int i=n;i;i--){
		suf[i]=suf[i+1];
		for(int j:v) suf[i]+=buc[j^a[i]];
		buc[a[i]]++;
	}
	for(int i=1;i<=qu;i++){
		q[i].ans=pre[q[i].r]-pre[cr]+suf[q[i].l]-suf[cl];
		if(cl<q[i].l) vr[cr+1].pb({cl,q[i].l-1,i,1});
		if(cl>q[i].l) vr[cr+1].pb({q[i].l,cl-1,i,-1});
		if(cr<q[i].r) vl[q[i].l-1].pb({cr+1,q[i].r,i,-1});
		if(cr>q[i].r) vl[q[i].l-1].pb({q[i].r+1,cr,i,1});
		cl=q[i].l;cr=q[i].r;
	} memset(buc,0,sizeof(buc));
	for(int i=1;i<=n;i++){
		for(int j:v) buc[a[i]^j]++;
		for(int j=0;j<vl[i].size();j++){
			int l=vl[i][j].l,r=vl[i][j].r,id=vl[i][j].id;
			ll sum=0;for(int t=l;t<=r;t++) sum+=buc[a[t]];
			q[id].ans+=sum*vl[i][j].op;
		}
	} memset(buc,0,sizeof(buc));
	for(int i=n;i;i--){
		for(int j:v) buc[a[i]^j]++;
		for(int j=0;j<vr[i].size();j++){
			int l=vr[i][j].l,r=vr[i][j].r,id=vr[i][j].id;
			ll sum=0;for(int t=l;t<=r;t++) sum+=buc[a[t]];
			q[id].ans+=sum*vr[i][j].op;
		}
	}
	for(int i=2;i<=qu;i++) q[i].ans+=q[i-1].ans;
	for(int i=1;i<=qu;i++) anss[q[i].id]=q[i].ans;
	for(int i=1;i<=qu;i++) printf("%lld\n",anss[i]);
	return 0;
}
/*
6 1 0
1 2 3 1 2 3
1 6

6 5 1
1 2 3 4 5 6
1 5
1 6
2 5
2 6
3 6

14 5 1
1 2 3 4 5 6 7 1 2 3 4 5 6 7
1 14
2 13
3 9
1 12
4 11
*/
```



---


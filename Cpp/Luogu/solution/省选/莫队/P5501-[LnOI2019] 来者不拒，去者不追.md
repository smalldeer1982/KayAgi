# [LnOI2019] 来者不拒，去者不追

## 题目背景

题目提供者：朝田诗乃

![avartar](https://cdn.luogu.com.cn/upload/pic/66100.png)

## 题目描述

给定一个长度为 $n$ 的序列 $a$。给定 $m$ 个询问，每次询问一个区间中 $[l,r]$ 中所有数的“Abbi 值”之和。

Abbi 值定义为：若 $a_i$ 在询问区间 $[l,r]$ 中是第 $k$ 小，那么它的“Abbi 值”等于 $k \times a_i$。

为了消除歧义举个例子：

有序列 $\{1,2,2,3\}$，那么 $1$ 是第 $1$ 小，$2$ 是第 $2$ 小，$3$ 是第 $4$ 小，序列 Abbi 值和为：

$$1 \times 1+2 \times 2+2 \times 2+3 \times 4=21.$$

## 说明/提示

前 2 个数据点，$1≤n,m≤1000$，时限 1s。

接下来 14 个数据点，$1≤n,a_i,m≤100000$，$1≤l≤r≤n$，时限 1s。

最后两个数据点，$1≤a_i≤100000$，$1≤l≤r≤n$，$1≤n,m≤500000$，时限 3s。

建议使用读入优化。建议开启 O2 优化。

数据已经过加强。

## 样例 #1

### 输入

```
4 2
1 2 2 3
1 4
1 2```

### 输出

```
21
5```

## 样例 #2

### 输入

```
10 5
8 6 9 8 1 1 3 10 7 9
5 8
1 3
5 7
9 9
5 6
```

### 输出

```
51
49
11
7
2
```

# 题解

## 作者：诗乃 (赞：15)

考虑莫队。当区间$[l,r]$已经被处理好时，向区间内加入一个数$x$ ，分析答案的变化。不难发现，区间内比$x$大的数的排名全部提升了一位。所以答案的变化为：

$ans+=$区间内所有比$x$大的数的和$+x*($区间内比$x$小的数的个数$+1)$
删除同理。

可以发现，区间内所有比$x$大的数的和与区间内比$x$小的数的个数比较难在$O(1)$的时间内统计出来。因此我们使用$lxl$巨巨发明的莫队二次离线算法，将这两个值离线出来处理。

为了方便表述，我们将区间$[l,r]$内所有比$x$大的数的和记为$sum(x, [l,r])$，将区间内比$x$小的数的个数记为 $cnt(x, [l,r])$。

以将左端点左移为例，需要询问$sum(a[l-1],[l,r])$的值，相当于询问$sum(a[l-1],[l,n])-sum(a[l-1],[r,n])$。

对于前半部分，我们可以使用树状数组在$O(nlogn)$的时间内求出所有$sum(a[i],[i+1,n])$。对于后半部分，我们可以把所有需要处理的位置 ii 全部记录下来，在模拟莫队完成后处理。

对于后半部分，我们需要一个查询$O(1)$，插入复杂度小于等于$O(\sqrt{n})$的东西来维护，不难想到权值分块。

对于莫队中其他所有端点移动情况可以做类似处理，对于所有的$cnt(x,[l,r])$进行相同处理，随便写一写就切掉啦！

总空间复杂度$O(n)$，时间复杂度$O(nlogn+n\sqrt{n})$。

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long lint;
const int V = 100000;
const int MAXN = 500050;
const int MAXB = 4050;
void read(int &x) {
	char ch; while(ch = getchar(), ch < '!'); x = ch - 48;
	while(ch = getchar(), ch > '!') x = (x << 3) + (x << 1) + ch - 48;
}
struct Qry {int l, r, id; lint ans;} q[MAXN];
struct T {int l, r, id, op;};
int siz, Vsiz, n, m, a[MAXN], cl[MAXN], cr[MAXN], bl[MAXN];
lint ans[MAXN], t1[MAXN], t2[MAXN], pre1[MAXN], pre2[MAXN], pref1[MAXN], pref2[MAXN], c1[MAXN], s1[MAXB], c2[MAXN], s2[MAXB];
void up1(int x, int val) {for( ; x > 0; t1[x] += val, x -= x&(-x));}
lint qr1(int x) {lint res = 0; for(; x <= V; res += t1[x], x += x&(-x)); return res;}
void up2(int x, int val) {for(; x <= V; t2[x] += val, x += x&(-x));} 
lint qr2(int x) {lint res = 0; for( ; x > 0; res += t2[x], x -= x&(-x)); return res;}
int cmp(Qry a, Qry b) {return a.l/siz == b.l/siz ? a.r < b.r : a.l < b.l;}
vector <T> vl[MAXN], vr[MAXN];
int main() {
	read(n); read(m); siz = sqrt(n); Vsiz = 400;
	for(int i = 1; i <= n; ++i) read(a[i]);
	for(int i = 1; i <= m; ++i) {read(q[q[i].id = i].l), read(q[i].r); if(q[i].l>q[i].r||q[i].l<1||q[i].r>n) puts("nmd");}
	sort(q+1, q+m+1, cmp);
	for(int i = 1; i <= n; ++i) {
		pre1[i] = qr1(a[i]+1);
		pre2[i] = qr2(a[i]-1);
		up1(a[i], a[i]); up2(a[i], 1);
		pref1[i] = pref1[i-1] + pre1[i] + 1ll * a[i] * (pre2[i] + 1);
	}
	memset(t1, 0, sizeof t1); memset(t2, 0, sizeof t2);
	for(int i = n; i >= 1; --i) {
		pre1[i] = qr1(a[i]+1);
		pre2[i] = qr2(a[i]-1);
		up1(a[i], a[i]); up2(a[i], 1);
		pref2[i] = pref2[i+1] + pre1[i] + 1ll * a[i] * (pre2[i] + 1);
	}
	for(int L = 1, R = 0, i = 1; i <= m; ++i) {
		int l = q[i].l, r = q[i].r;
		q[i].ans = pref1[r]-pref1[R]+pref2[l]-pref2[L];
		if(L < l) vl[r+1].push_back((T) {L, l-1, i, 1});
		if(L > l) vl[r+1].push_back((T) {l, L-1, i, -1});
		if(R < r) vr[L-1].push_back((T) {R+1, r, i, -1});
		if(R > r) vr[L-1].push_back((T) {r+1, R, i, 1});
		L = l; R = r;
	}
	for(int i = 1; i <= Vsiz; ++i) {
		cl[i] = cr[i-1] + 1; cr[i] = i*Vsiz;
		for(int j = cl[i]; j <= cr[i]; ++j) bl[j] = i;
	}
	for(int i = 1; i <= n; ++i) {
		for(int j = 1; j < bl[a[i]]; ++j) s2[j] += a[i];
		for(int j = cl[bl[a[i]]]; j <= a[i]; ++j) c2[j] += a[i];
		for(int j = bl[a[i]]+1; j <= Vsiz; ++j) ++s1[j];
		for(int j = a[i]; j <= cr[bl[a[i]]]; ++j) ++c1[j];
		for(int j = 0; j < vr[i].size(); ++j) {
			int l = vr[i][j].l, r = vr[i][j].r, id = vr[i][j].id;
			lint tmp = 0;
			for(int k = l; k <= r; ++k)
				tmp += 1ll*a[k]*(s1[bl[a[k]-1]]+c1[a[k]-1]) + (s2[bl[a[k]+1]]+c2[a[k]+1]);
			q[id].ans += vr[i][j].op * tmp;
		}
	}
	memset(s1, 0, sizeof s1); memset(c1, 0, sizeof c1); memset(s2, 0, sizeof s2); memset(c2, 0, sizeof c2);
	for(int i = n; i >= 1; --i) {
		for(int j = 1; j < bl[a[i]]; ++j) s2[j] += a[i];
		for(int j = cl[bl[a[i]]]; j <= a[i]; ++j) c2[j] += a[i];
		for(int j = bl[a[i]]+1; j <= Vsiz; ++j) ++s1[j];
		for(int j = a[i]; j <= cr[bl[a[i]]]; ++j) ++c1[j];
		for(int j = 0; j < vl[i].size(); ++j) {
			int l = vl[i][j].l, r = vl[i][j].r, id = vl[i][j].id;
			lint tmp = 0;
			for(int k = l; k <= r; ++k)
				tmp += 1ll*a[k]*(s1[bl[a[k]-1]]+c1[a[k]-1]) + (s2[bl[a[k]+1]]+c2[a[k]+1]);
			q[id].ans += vl[i][j].op * tmp;
		}
	}
	for(int i = 1; i <= m; ++i) q[i].ans += q[i-1].ans, ans[q[i].id] = q[i].ans;
	for(int i = 1; i <= m; ++i) printf("%lld\n", ans[i]);
}


```

---

## 作者：Others (赞：10)

做完一百年之后才发现没写题解（汗）。

首先这题是静态的区间查询，常规思路：莫队，但是这个“Abbi”值无论是加还是删都不能做到 $O(1)$，所以考虑二次离线莫队。

考虑加入一个数的贡献：加上大于它的数的和，这东西用 $O(\sqrt n)$ 修改 $O(1)$ 查询的分块就行了（因为有 $n\sqrt n$ 次查询），很基础。

讲讲怎么实现二次离线莫队，我们将每次询问左右端点移动的方向，距离再离线下来，总移动距离应该是 $n\sqrt n$，然后就沉思：

假设将 $[l,r]$ 转移至 $[l,r+1]$，就是加上 $[r+1,r+1]$ 对 $[l,r]$ 的贡献，为了方便，我们将所有的都转换成 $[r+1,r+1]$ 对 $[1,r]$ 的贡献减去 $[r+1,r+1]$ 对 $[1,l-1]$ 的贡献，而前者可以预处理，所以这里就是将每个转移的下标离线到上面的 $l-1$，这样就可以重复利用 $[1,l-1]$ 的数据了，总时间复杂度保持在 $O(n\sqrt n)$。

**Code**

```cpp
#include <bits/stdc++.h>
#define lowbit(x) (x&-x)
#define ll long long
using namespace std;
const int maxn=500005,maxa=100005,maxsa=325;
int n,m,a[maxn],s,ss,idx[maxn],Maxa,idxn,l=1,r,ccnt,idxx[maxa];
ll qz[maxn],ans[maxn],aans[maxn],sum1[maxa],sum2[maxsa],sum3[maxa],sum4[maxsa],qqz[maxn];
struct query{//询问 
	int l,r,id;
}p[maxn];
struct node{//二离 
	int l,r,op,id,x;
}que[maxn<<1];
int qr(){
	int x=0,f=0;
	char c=getchar();
	while(c>'9'||c<'0') f|=(c=='-'),c=getchar();
	while(c>='0'&&c<='9') x=(x<<3)+(x<<1)+(c^48),c=getchar();
	return f?-x:x;
}
void add(int x){//O(sqrt(n))的修改 
	for(int i=x;idxx[i]==idxx[x];++i) ++sum1[i],sum3[i]+=x;
	for(int i=idxx[x];i<=idxx[Maxa];++i) ++sum2[i],sum4[i]+=x;
}
inline bool cmp(query x,query y){//奇偶排序 
	return idx[x.l]==idx[y.l]?(idx[x.l]&1?x.r<y.r:x.r>y.r):x.l<y.l;
}
inline bool cmp2(node x,node y){
	return x.x<y.x;
}
inline ll getsum(int x){
	return sum4[idxx[Maxa]]-sum4[idxx[x]-1]-sum3[x]+1ll*x*(sum2[idxx[x]-1]+(idxx[x-1]==idxx[x]?sum1[x-1]:0));//O(1) 查询 
}
int main() {
	n=qr(),m=qr();
	s=sqrt(n);
	for(int i=1;i<=n;++i){
		a[i]=qr();
		idx[i]=(i+s-1)/s;
		qqz[i]=qqz[i-1]+a[i];//最后要用 
		Maxa=max(Maxa,a[i]);//值域大小 
	}
	ss=sqrt(Maxa);
	for(int i=1;i<=Maxa;++i){//初始化值域块 
		idxx[i]=(i+ss-1)/ss;
	}
	for(int i=1;i<=n;++i){//求前缀贡献 
		qz[i]=qz[i-1]+getsum(a[i]);
		add(a[i]);
	}
	for(int i=1;i<=m;++i){
		p[i].l=qr(),p[i].r=qr(),p[i].id=i;
	}
	sort(p+1,p+m+1,cmp);//奇偶排序 
	for(int i=1;i<=m;++i){//二次离线转移部分，记得离线整体(打的 if) 
		if(l>p[i].l){
			que[++ccnt]=(node){p[i].l,l-1,1,i,r};
			ans[i]-=qz[l-1]-qz[p[i].l-1];
			l=p[i].l;
		}
		if(r<p[i].r){
			que[++ccnt]=(node){r+1,p[i].r,-1,i,l-1};
			ans[i]+=qz[p[i].r]-qz[r];
			r=p[i].r;
		}
		if(l<p[i].l){
			que[++ccnt]=(node){l,p[i].l-1,-1,i,r};
			ans[i]+=qz[p[i].l-1]-qz[l-1];
			l=p[i].l;
		}
		if(r>p[i].r){
			que[++ccnt]=(node){p[i].r+1,r,1,i,l-1};
			ans[i]-=qz[r]-qz[p[i].r];
			r=p[i].r;
		}
	}
	sort(que+1,que+ccnt+1,cmp2);//按那个端点排序 
	memset(sum1,0,sizeof(sum1));
	memset(sum2,0,sizeof(sum2));
	memset(sum3,0,sizeof(sum3));
	memset(sum4,0,sizeof(sum4));
	for(int i=1;i<=ccnt;++i){
		if(que[i].x==0) continue;//不用减没有贡献的 
		while(idxn<que[i].x) add(a[++idxn]);//转移 [1,l-1] 的 l-1 
		for(int j=que[i].l;j<=que[i].r;++j) ans[que[i].id]+=1ll*que[i].op*getsum(a[j]);//枚举，前缀和在前面。 
	}
	for(int i=2;i<=m;++i) ans[i]+=ans[i-1];//因为处理的只有转移的部分，所以要前缀和。 
	for(int i=1;i<=m;++i) aans[p[i].id]=ans[i]+qqz[p[i].r]-qqz[p[i].l-1];//先要全部加一遍，前面也可以处理。 
	for(int i=1;i<=m;++i) printf("%lld\n",aans[i]);
	return 0;
}                  
```

---

## 作者：dead_X (赞：7)

## Section 0
~~看到讨论贴里有人说 $O(n\sqrt n\log n)$ 过去然后数据加强了，考虑二次离线莫队。~~

好吧，我们还是来瞎分析一下
## Section 1
考虑 $x$ 这个数的贡献，即 $x\times t$，$t$ 为 $[l,r]$ 中比 $x$ 小的数加 $1$。

考虑加入 $x$ 这个数的贡献。

* 对于所有大于 $x$ 的数 $y$，贡献全部增加了 $y$。
* 对于 $x$，贡献就是 $x\times t$。

所以考虑一下我们要求什么：大于 $x$ 的数的总和，和小于 $x$ 的数的数量。

这个东西显然可以二次离线莫队随便搞，因此这道题就可以在 $O(n\sqrt n)$ 的时间内解决了。

如果您不会二次离线莫队可以去模板题学习一下。
## 代码
```
#include<bits/stdc++.h>
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
char buf[1<<21],*p1=buf,*p2=buf,obuf[1<<24],*O=obuf;
using namespace std;
inline int read(){
   int s=0;
   char ch=getchar();
   while(ch<'0'||ch>'9') ch=getchar();
   while(ch>='0'&&ch<='9') s=s*10+(ch^48),ch=getchar();
   return s;
}
void print(long long x) {
    //printf("%lld\n",x);
    if(x>9) print(x/10);
    *O++=x%10+'0';
}
struct query
{
    int l,r,bl,id;
    bool operator<(const query& zhouAKngyangAKNOI){return (bl<zhouAKngyangAKNOI.bl)||(bl==zhouAKngyangAKNOI.bl&&((r<zhouAKngyangAKNOI.r)^(bl&1)));}
}q[500003];
struct Query
{
    int k,l,r,op,id;
    bool operator<(const Query& zhouAKngyangAKNOI){return k<zhouAKngyangAKNOI.k;}
}v[1000003];
int n,m,vcnt,a[500003],cnt[500003],cntb[787];
long long SUM,sum[500003],sumb[787],pre[500003],ans[500003],lxl[500003],qwq[500003];
void update(int x)
{
    SUM+=x;
    for(int i=x,r=(x/710+1)*710; i<r; ++i) sum[i]+=x,++cnt[i];
    for(int i=x/710; i<=710; ++i) sumb[i]+=x,++cntb[i];
    return ;  
}
#define getsum(x) SUM-(x<710?0:sumb[x/710-1])-sum[x]+1ll*x*((x<711?0:cntb[(x-1)/710-1])+cnt[x-1])
signed main()
{
    n=read(),m=read();
    for(int i=1; i<=n; ++i) a[i]=read(),qwq[i]=qwq[i-1]+a[i];
    for(int i=1; i<=m; ++i) q[i].l=read(),q[i].r=read(),q[i].bl=q[i].l/1000,q[i].id=i;
    sort(q+1,q+m+1);
    for(int i=1; i<=n; ++i) pre[i]=pre[i-1]+getsum(a[i]),update(a[i]);
    for(int i=1,l=1,r=0; i<=m; ++i)
    {
        if(q[i].l<l) v[++vcnt]=(Query){r,q[i].l,l-1,1,i},ans[i]-=pre[l-1]-pre[q[i].l-1],l=q[i].l;
        if(q[i].r>r) v[++vcnt]=(Query){l-1,r+1,q[i].r,-1,i},ans[i]+=pre[q[i].r]-pre[r],r=q[i].r;
        if(q[i].l>l) v[++vcnt]=(Query){r,l,q[i].l-1,-1,i},ans[i]+=pre[q[i].l-1]-pre[l-1],l=q[i].l;
        if(q[i].r<r) v[++vcnt]=(Query){l-1,q[i].r+1,r,1,i},ans[i]-=pre[r]-pre[q[i].r],r=q[i].r;
    }
    sort(v+1,v+vcnt+1),SUM=0,memset(cnt,0,sizeof(cnt)),memset(cntb,0,sizeof(cntb)),memset(sum,0,sizeof(sum)),memset(sumb,0,sizeof(sumb));
    for(int i=1,k=0; i<=vcnt; ++i)
    {
        if(v[i].k==0) continue;
        while(k<v[i].k) update(a[++k]);
        for(int j=v[i].l; j<=v[i].r; ++j) ans[v[i].id]+=1ll*(getsum(a[j]))*v[i].op;
    }
    for(int i=2; i<=m; ++i) ans[i]+=ans[i-1];
    for(int i=1; i<=m; ++i) lxl[q[i].id]=ans[i]+qwq[q[i].r]-qwq[q[i].l-1];
	for(int i=1; i<=m; ++i) print(lxl[i]),*O++='\n';
    fwrite(obuf,O-obuf,1,stdout);
    return 0;
}
//x 对 [1,r] 的贡献：
//比 x 大的数的总和 + x * 比 x 小的数的数量
```

---

## 作者：orz_z (赞：5)

### 二次离线莫队

### 算法提出

二次离线莫队是一个由 `lxl` 大佬提出的新科技，其基于莫队 $+$ 扫描线的思想，通过扫描线，再次将更新答案的过程离线处理，降低时间复杂度。

具体地，设更新答案的复杂度为 $\mathcal O(k)$，那么它可以将莫队的复杂度从 $\mathcal O(nk\sqrt n)$ 降到了 $\mathcal O(nk+n\sqrt n)$， 大大简化了计算。

再补充一点，二次离线莫队通常适用于满足以下条件的题目：

* 可用莫队做。
*  莫队扩展或者删除一个点对答案的影响取决于当前区间的长度。
* 扩展或者删除一个点对答案的影响可用前缀写成差分的形式。

### 算法解决

以 [模板题](https://www.luogu.com.cn/problem/P4887) 为例。

>  给了你一个序列 $a$，每次查询给一个区间 $[l,r]$，查询 $l \leq i< j \leq r$，且 $a_i \oplus a_j$ 的二进制表示下有 $k$ 个 $1$ 的二元组 $(i,j)$ 的个数。
>
> $1 \leq n,m\leq10^5,0 \leq a_i,k < 16384$，时限 $1 \text{s}$，空限 $500\text{MB}$。 

首先明确，这题如果用普通莫队的话，每一次移动指针的时候需要用 $\mathcal O(C_{14}^k)$ 的复杂度来转移，显然过不去，于是考虑二次离线莫队。

设 $a_x$ 对区间 $[l,r]$ 的贡献为 $f(x,[l,r])$。

我们考虑区间端点变化对答案的影响，以 $[l,r]$ 变成 $[l,r+k]$ 为例，答案增加了 $\sum\limits_{i=r+1}^{r+k}f(i,[l,i-1])$。

我们发现，$f(i,[l,i-1])$ 可以差分成 $f(i,[1,i-1])-f(i,[1,l-1])$。

这样转移区间的贡献就分为两类：

1. 一个前缀和它后面一个数的贡献，这可以预处理出来。
2. 区间 $[r+1,r+k]$ 对前缀 $[1,l-1]$ 的贡献，保存下来用扫描线做即可。

对于其他情况，大力讨论即可，下面给出结论：

* 右端点右移，$[l,r]$ 变成 $[l,r+k]$，答案增加了$\sum\limits_{i=r+1}^{r+k}f(i,[1,i-1])-f(i,[1,l-1])$。
* 右端点左移，$[l,r]$ 变成 $[l,r-k]$，答案减少了 $\sum\limits_{i=r-k+1}^{r}f(i,[1,i-1])-f(i,[1,l-1])$。
* 左端点右移，$[l,r]$ 变成 $[l+k,r]$，答案减少了 $\sum\limits_{i=l}^{l+k-1}f(i,[1,r])-f(i,[1,i])$。
* 左端点左移，$[l,r]$ 变成 $[l-k,r]$，答案增加了 $\sum\limits_{i=l-k}^{l-1}f(i,[1,r])-f(i,[1,i])$。

再看扫描线部分。

我们对于每个前缀 $[1,i]$ 开一个 `vector`，其中装二元组 $(l_0,r_0)$（对应上面的 $[r+1,r+k]$）（另外还要装一个 $id$，如果 $id<0$，代表减法，否则代表加法，贡献加到 $\mid i \mid$ 这里去）。

假设当前前缀为 $[1,i]$，二元组为 $(l_0,r_0)$，设 $t[z]$ 表示当前前缀中的数异或 $z$ 后得到的数恰好有 $k$ 个 $1$ 的数的个数。

再根据异或的一个性质：若 $a\oplus b=c$，则有 $b \oplus c=a,a \oplus c=b$。

所以插入一个 $p$ 值时，就 $\mathcal O(C_{14}^{k})$ 枚举所有二进制表示下有 $k$ 个 $1$ 的数 $val$，然后令 $t[p \oplus val]++$ 即可（第一类贡献的预处理也用这种方法）。

询问时答案即为 $\sum\limits_{i=l_0}^{r_o}t[i]$。

对于 $f(i,[1,i])$，由于 $i \oplus i=0$ 且 $i=j$ 这个贡献不算，这可以转为 $f(i,[1,i-1])$，再加个特判即可。

由于第二类贡献需要先跑一次莫队记录 $l_0,r_0$（顺便加上第一类贡献），然后再跑一次扫描线计算，相当于再次离线，所以我们通常称以上算法为二次离线莫队。

可以发现，莫队部分时间复杂度为 $\mathcal O(n\sqrt n)$，当然也可以前缀和优化成 $\mathcal O(n)$，扫描线部分时间复杂度为 $\mathcal O(n\sqrt n+n C_{14}^k)$，所以总时间复杂度为 $\mathcal O(n\sqrt n+n C_{14}^k)$，可过。

$\text{659ms / 15.43MB / 3.20KB C++20 O2}$。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define re register

namespace Fread
{
    const int SIZE = 1 << 23;
    char buf[SIZE], *S, *T;
    inline char getchar()
    {
        if (S == T)
        {
            T = (S = buf) + fread(buf, 1, SIZE, stdin);
            if (S == T)
                return '\n';
        }
        return *S++;
    }
}
namespace Fwrite
{
    const int SIZE = 1 << 23;
    char buf[SIZE], *S = buf, *T = buf + SIZE;
    inline void flush()
    {
        fwrite(buf, 1, S - buf, stdout);
        S = buf;
    }
    inline void putchar(char c)
    {
        *S++ = c;
        if (S == T)
            flush();
    }
    struct NTR
    {
        ~NTR()
        {
            flush();
        }
    } ztr;
}

#ifdef ONLINE_JUDGE
#define getchar Fread::getchar
#define putchar Fwrite::putchar
#endif

typedef long long ll;

inline int read()
{
	re int x = 0, f = 1;
	re char c = getchar();
	while (c < '0' || c > '9')
	{
		if (c == '-')
			f = -1;
		c = getchar();
	}
	while (c >= '0' && c <= '9')
	{
		x = x * 10 + c - '0';
		c = getchar();
	}
	return x * f;
}

inline void write(re ll x)
{
	if (x < 0)
	{
		putchar('-');
		x = -x;
	}
	if (x > 9)
		write(x / 10);
	putchar(x % 10 + '0');
}

const int _ = 1e5 + 7;

int n, m, k, a[_], S, bel[_], t[_], pre[_];

ll Ans[_];

struct Query
{
	int l, r, id;
	ll ans;
	inline bool operator < (const Query& tmp)
	{
		return bel[l] == bel[tmp.l] ? r < tmp.r : l < tmp.l;
	}
} q[_];

vector<tuple<int, int, int>> v[_];

signed main()
{
	n = read(), m = read(), k = read();
	S = sqrt(n);
	if(k > 14)
	{
		for(re int i = 1; i <= m; ++i) putchar('0'), putchar('\n');
		return 0;
	}
	for(re int i = 1; i <= n; ++i) a[i] = read();
	for(re int i = 1; i <= m; ++i)
	{
		q[i].l = read();
		q[i].r = read();
		q[i].id = i;
	}
	vector<int> b;
	for(re int i = 0; i < 16384; ++i)
		if(__builtin_popcount(i) == k) b.push_back(i);
	for(re int i = 1; i <= n; ++i) bel[i] = (i - 1) / S + 1;
	sort(q + 1, q + m + 1);
	for(re int i = 1; i <= n; ++i)
	{
		for(re auto x : b) ++t[a[i] ^ x];
		pre[i] = t[a[i + 1]];
	}
	memset(t, 0, sizeof t);
	for(re int i = 1, l = 1, r = 0; i <= m; ++i)
	{
		if(l < q[i].l) v[r].emplace_back(l, q[i].l - 1, -i);
		while(l < q[i].l)
		{
			q[i].ans += pre[l - 1];
			++l; 
		}
		if(l > q[i].l) v[r].emplace_back(q[i].l, l - 1, i);
		while(l > q[i].l)
		{
			q[i].ans -= pre[l - 2];
			--l;
		}
		if(r < q[i].r) v[l - 1].emplace_back(r + 1, q[i].r, -i);
		while(r < q[i].r)
		{
			q[i].ans += pre[r];
			++r;
		}
		if(r > q[i].r) v[l - 1].emplace_back(q[i].r + 1, r, i);
		while(r > q[i].r)
		{
			q[i].ans -= pre[r - 1];
			--r;
		}
	}
	for(re int i = 1, id, l, r; i <= n; ++i)
	{
		for(re auto x : b) ++t[a[i] ^ x];
		for(re const auto& x : v[i])
		{
			tie(l, r, id) = x;
			for(re int j = l, tmp = 0; j <= r; ++j)
			{
				tmp = t[a[j]];
				if(j <= i && k == 0) --tmp;
				if(id < 0) q[-id].ans -= tmp;
				else q[id].ans += tmp;
			}
		}
	}
	for(re int i = 1; i <= m; ++i) q[i].ans += q[i - 1].ans;
	for(re int i = 1; i <= m; ++i) Ans[q[i].id] = q[i].ans;
	for(re int i = 1; i <= m; ++i) write(Ans[i]), putchar('\n');
}
```

### 例题选讲

#### P5047

> 给你一个长为 $n$ 的序列 $a$，$m$ 次询问，每次查询一个区间的逆序对数，不强制在线。
>
> $1 \leq n,m\leq 10^5,0 \leq a_i \leq 10^9$，时限 $250\text{ms}$，空限 $31.25\text{MB}$。

首先明确，空限要求 $\mathcal O(n)$。

$\mathcal O(n \sqrt n \log n)$  应该谁都会做，而且谁都知道被卡了。

考虑二次离线莫队。

前面的差分都不讲了。

对于第一类贡献，预处理即可。

对于第二类贡献，这里跟上面那题稍微有些不同，就是左端点移动的话答案变化量就是比这个数小的数的个数，右端点移动的话答案变化量就是比这个数大的数的个数。

由于第二类贡献如果用树状数组 $\mathcal O(\log n)$ 修改，$\mathcal O(\log n)$ 查询的话，时间复杂度是 $\mathcal O(n\log n+n \sqrt n \log n)$ 的，过不去。

由于瓶颈在于查询，考虑值域分块维护前缀和，$\mathcal O(\sqrt n)$ 修改，$\mathcal O(1)$ 查询，这样时间复杂度是 $\mathcal O(n \sqrt n+n\sqrt n)$，可过。

再加上莫队$\mathcal O(n \sqrt n)$ 的复杂度。

总时间复杂度为 $\mathcal O(n \sqrt n)$，可过。

$\text{ 956ms / 19.04MB / 3.56KB C++11 O2}$。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define re register

namespace Fread
{
    const int SIZE = 1 << 23;
    char buf[SIZE], *S, *T;
    inline char getchar()
    {
        if (S == T)
        {
            T = (S = buf) + fread(buf, 1, SIZE, stdin);
            if (S == T)
                return '\n';
        }
        return *S++;
    }
}
namespace Fwrite
{
    const int SIZE = 1 << 23;
    char buf[SIZE], *S = buf, *T = buf + SIZE;
    inline void flush()
    {
        fwrite(buf, 1, S - buf, stdout);
        S = buf;
    }
    inline void putchar(char c)
    {
        *S++ = c;
        if (S == T)
            flush();
    }
    struct NTR
    {
        ~NTR()
        {
            flush();
        }
    } ztr;
}

#ifdef ONLINE_JUDGE
#define getchar Fread::getchar
#define putchar Fwrite::putchar
#endif

typedef long long ll;

inline int read()
{
	re int x = 0, f = 1;
	re char c = getchar();
	while (c < '0' || c > '9')
	{
		if (c == '-')
			f = -1;
		c = getchar();
	}
	while (c >= '0' && c <= '9')
	{
		x = x * 10 + c - '0';
		c = getchar();
	}
	return x * f;
}

inline void write(re ll x)
{
	if (x < 0)
	{
		putchar('-');
		x = -x;
	}
	if (x > 9)
		write(x / 10);
	putchar(x % 10 + '0');
}

const int _ = 1e5 + 7;

int n, m, k, a[_], c[_], S, bel[_], t[_], pre[_], pree[_], f1[_], f2[_], L[_], R[_], V;

ll Ans[_];

struct Query
{
	int l, r, id;
	ll ans;
	inline bool operator < (const Query& tmp)
	{
		return bel[l] == bel[tmp.l] ? r < tmp.r : l < tmp.l;
	}
} q[_];

vector<tuple<int, int, int, int>> v[_];

void init()
{
	memset(pre, 0, sizeof pre);
	memset(pree, 0, sizeof pree);
}

void update(int x)
{
	for(re int i = bel[x] + 1; i <= bel[V]; ++i) pre[i]++;
	for(re int i = x + 1; i <= R[bel[x]]; ++i) pree[i]++;
}

int query(int x)
{
	return pre[bel[x]] + pree[x];
}

signed main()
{
	n = read(), m = read();
	for(re int i = 1; i <= n; ++i) c[i] = a[i] = read();
	sort(c + 1, c + n + 1);
	re int un = unique(c + 1, c + n + 1) - c - 1;
	for(int i = 1; i <= n; ++i)
	{
		a[i] = lower_bound(c + 1, c + un + 1, a[i]) - c;
		V = max(V, a[i]);
	}
	S = sqrt(V); 
	for(re int i = 1; i <= m; ++i)
	{
		q[i].l = read();
		q[i].r = read();
		q[i].id = i;
	}
	for(re int i = 1; i <= V + 1; ++i) bel[i] = (i - 1) / S + 1;
	for(re int i = 1; i <= bel[V + 1]; ++i) L[i] = R[i - 1] + 1, R[i] = i * S;
	R[bel[V + 1]] = V + 1;
	sort(q + 1, q + m + 1);
	for(re int i = 1; i <= n; ++i)
	{
		f2[i] = i - query(a[i] + 1) - 1;
		f1[i] = query(a[i]);
		update(a[i]);
	}
	init();
	for(re int i = 1, l = 1, r = 0; i <= m; ++i)
	{
		if(l < q[i].l) v[r].emplace_back(l, q[i].l - 1, -i, 0);
		while(l < q[i].l)
			q[i].ans += f1[l++];
		if(l > q[i].l) v[r].emplace_back(q[i].l, l - 1, i, 0);
		while(l > q[i].l)
			q[i].ans -= f1[--l];
		if(r < q[i].r) v[l - 1].emplace_back(r + 1, q[i].r, -i, 1);
		while(r < q[i].r)
			q[i].ans += f2[++r];
		if(r > q[i].r) v[l - 1].emplace_back(q[i].r + 1, r, i, 1);
		while(r > q[i].r)
			q[i].ans -= f2[r--];
	}
	for(re int i = 1, id, l, r, flg; i <= n; ++i)
	{
		update(a[i]);
		for(re const auto& x : v[i])
		{
			tie(l, r, id, flg) = x;
			re ll tmp = 0;
			for(re int j = l; j <= r; ++j)
			{
				if(!flg)
					tmp = query(a[j]);
				else
					tmp = i - query(a[j] + 1);
				if(id < 0) q[-id].ans -= tmp;
				else q[id].ans += tmp;
			}
		}
	}
	for(re int i = 1; i <= m; ++i) q[i].ans += q[i - 1].ans;
	for(re int i = 1; i <= m; ++i) Ans[q[i].id] = q[i].ans;
	for(re int i = 1; i <= m; ++i) write(Ans[i]), putchar('\n');
}
```

### P5501

> 给定一个长度为 $n$ 的序列 $a$。给定 $m$ 个询问，每次询问一个区间中 $[l,r]$ 中所有数的`Abbi` 值之和。
>
> `Abbi`值定义为：若 $a_i$ 在询问区间 $[l,r]$ 中是第 $k$ 小，那么它的 `Abbi` 值等于 $k \times a_i$。
>
> $1 \leq n,m\leq 5\times 10^5,1 \leq a_i \leq 10^5$，时限 $1\text{s}$，空限 $250\text{MB}$。

跟上面那题相似。

考虑 $[l,r]$ 转移到 $[l,r+1]$，即加入一个数的贡献，不难想，即为 $\sum\limits_{i=l}^{r}[a_i<a_{r+1}]\times a_{r+1}+\sum\limits_{i=1}^{r}[a_i>a_{r+1}]a_i+a_{r+1}$。

向上面那题那样搞个值域分块维护一下即可。

细节：上面式子中最后加的那个 $a_{r+1}$ 并不可以差分（手玩一下可以得知），需要最后加上。

具体参考代码。

$\text{7.87s / 88.66MB / 3.85KB C++17 O2}$。

```cpp
#include <bits/stdc++.h>

using namespace std;

#define re register

typedef long long ll;

namespace Fread
{
    const int SIZE = 1 << 24;
    char buf[SIZE], *S, *T;
    inline char getchar()
    {
        if (S == T)
        {
            T = (S = buf) + fread(buf, 1, SIZE, stdin);
            if (S == T)
                return '\n';
        }
        return *S++;
    }
}
namespace Fwrite
{
    const int SIZE = 1 << 24;
    char buf[SIZE], *S = buf, *T = buf + SIZE;
    inline void flush()
    {
        fwrite(buf, 1, S - buf, stdout);
        S = buf;
    }
    inline void putchar(char c)
    {
        *S++ = c;
        if (S == T)
            flush();
    }
    struct NTR
    {
        ~NTR()
        {
            flush();
        }
    } ztr;
}

#ifdef ONLINE_JUDGE
#define getchar Fread::getchar
#define putchar Fwrite::putchar
#endif

inline int read()
{
	re int x = 0, f = 1;
	re char c = getchar();
	while (c < '0' || c > '9')
	{
		if (c == '-')
			f = -1;
		c = getchar();
	}
	while (c >= '0' && c <= '9')
	{
		x = x * 10 + c - '0';
		c = getchar();
	}
	return x * f;
}

inline void write(re ll x)
{
	if (x < 0)
	{
		putchar('-');
		x = -x;
	}
	if (x > 9)
		write(x / 10);
	putchar(x % 10 + '0');
}

const int _ = 5e5 + 7;

int n, m, S, a[_], bel[_], pre1[_], pree1[_], L[_], R[_], V = 100000;

ll pre[_], pree[_], s[_], F[_], Ans[_];

struct Query
{
	int l, r, id;
	ll ans;
	inline bool operator < (re const Query& tmp)
	{
		return bel[l] == bel[tmp.l] ? r < tmp.r : l < tmp.l;
	}
} q[_];

vector<tuple<int, int, int>> v[_];

struct tr
{
	ll c[_];
	void update(re int x, re int val)
	{
		for(int i = x; i <= V; i += i & -i) c[i] += val;
	}
	ll query(re int x)
	{
		ll res = 0;
		for(int i = x; i; i -= i & -i) res += c[i];
		return res;
	}
} t, t1;

void init()
{
	memset(pre, 0, sizeof pre);
	memset(pree, 0, sizeof pree);
	memset(pre1, 0, sizeof pre1);
	memset(pree1, 0, sizeof pree1);
}

void update(re int x)
{
	for(re int i = bel[x]; i <= bel[V]; ++i) pre[i] += x, pre1[i]++;
	for(re int i = x; i <= R[bel[x]]; ++i) pree[i] += x, pree1[i]++;
}

ll query(re int x)
{
	return pre[bel[x] - 1] + pree[x];
}

int query1(re int x)
{
	return pre1[bel[x] - 1] + pree1[x];
}

signed main()
{
	n = read(), m = read();
	for(re int i = 1; i <= n; ++i) a[i] = read(), s[i] = s[i - 1] + a[i];
	S = 317; 
	for(re int i = 1; i <= m; ++i)
	{
		q[i].l = read();
		q[i].r = read();
		q[i].id = i;
	}
	for(re int i = 1; i <= V; ++i) bel[i] = (i - 1) / S + 1;
	for(re int i = 1; i <= bel[V]; ++i) L[i] = R[i - 1] + 1, R[i] = i * S;
	R[bel[V]] = V;
	sort(q + 1, q + m + 1);
	for(re int i = 1; i <= n; ++i)
	{
		F[i] = F[i - 1] + 1ll * t1.query(a[i] - 1) * a[i] + t.query(V) - t.query(a[i]);
		t.update(a[i], a[i]);
		t1.update(a[i], 1);
	}
	for(re int i = 1, l = 1, r = 0; i <= m; ++i)
	{
		if(l > q[i].l) v[r].emplace_back(q[i].l, l - 1, i), q[i].ans -= F[l - 1] - F[q[i].l - 1], l = q[i].l;
		if(r < q[i].r) v[l - 1].emplace_back(r + 1, q[i].r, -i), q[i].ans += F[q[i].r] - F[r], r = q[i].r;
		if(l < q[i].l) v[r].emplace_back(l, q[i].l - 1, -i), q[i].ans += F[q[i].l - 1] - F[l - 1], l = q[i].l;
		if(r > q[i].r) v[l - 1].emplace_back(q[i].r + 1, r, i), q[i].ans -= F[r] - F[q[i].r], r = q[i].r;
	}
	re ll sum = 0;
	for(re int i = 1, id, l, r; i <= n; ++i)
	{
		update(a[i]);
		sum += a[i];
		for(re const auto& x : v[i])
		{
			tie(l, r, id) = x;
			re ll tmp = 0;
			for(re int j = l; j <= r; ++j)
			{
				tmp = 1ll * query1(a[j] - 1) * a[j] + sum - query(a[j]);
				if(id < 0) q[-id].ans -= tmp;
				else q[id].ans += tmp;
			}
		}
	}
	for(re int i = 1; i <= m; ++i) q[i].ans += q[i - 1].ans;
	for(re int i = 1; i <= m; ++i) Ans[q[i].id] = q[i].ans + s[q[i].r] - s[q[i].l - 1];
	for(re int i = 1; i <= m; ++i) write(Ans[i]), putchar('\n');
}
```

### P5398

给你一个序列 $a$，每次询问给一个区间 $[l,r]$。

查询 $l \leq i,j \leq r$ 且 $a_i$ 是 $a_j$ 倍数的二元组 $(i,j)$ 的个数。

$1 \leq n,m,a_i\leq 5\times 10^5$，时限 $3\text{s}$，空限 $128\text{MB}$。

#### sol

「点缀光辉的第十四分块」。

考虑二次离线莫队。

设 $a_i$ 在区间 $[l,r]$ 的因数个数为 $f_1(i,[l,r])$，倍数个数为 $f_2(i,[l,r])$。

则右端点向右移动加入一个数的贡献为 $f_1(r,[l,r])+f_2(r,[l,r])$。

差分一下即为 $f_1(r,[1,r])-f_1(r,[1,l-1])+f_2(r,[1,r])-f_2(r,[1,l-1])$。

$f_1(r,[1,r])$ 可以在遍历时 $\mathcal O(\sqrt n)$ 枚举因数，累加所有因数之前的出现次数，定义一个桶即可实现。

$f_2(r,[1,r])$ 可以在上一个操作枚举因数时对该数的每个因数标记一下，即开一个桶记录该数作为因数的出现次数。

以上两部分可提前预处理，计算前缀和，然后跑一边莫队计算贡献，时间复杂度为 $\mathcal O(n\sqrt n)$。

对于 $f_1(r,[1,l-1])$ 和 $f_2{r,[1,l-1]}$ 可在上面跑莫队时顺便存下来，进行二次离线，要求 $\mathcal O(1)$ 查询 $f_1$ 和 $f_2$。

考虑二次离线时的修改，这部分要求是 $\mathcal O(\sqrt n)$ 级别的。

对于 $f_1$，枚举因数，加上贡献即可。

对于 $f_2$，考虑根号分治，设阈值 $S$：

* 若当前加入的数 $\geq S$，暴力跳表，加上贡献。
* 若当前加入的数 $< S$，则将这个提出二次离线这部分，后面处理。

二次离线部分时间复杂度为 $\mathcal O(n \sqrt n)$。

再考虑刚刚遗留下来的一点东西。

记 $p[i][j]$ 表示区间 $[1,j]$ 中含有因数 $i$ 的数的个数，$c[i][j]$ 表示区间 $[1,j]$ 中 $i$ 的出现次数。

则区间 $[l,r]$ 中含有因数 $i$ 的数的个数就是 $p[i][r] - p[i][l-1]$。

所以 $[1,z]$ 中的数 $i$ 作为因数出现在 $[l,r]$ 的总次数为 $c[i][z]\times (p[i][r] - p[i][l-1])$。

那么枚举 $i \in [1,S)$，$\mathcal O(n)$ 求出 $p$ 和 $c$（压掉一维），然后 $\mathcal O(m)$ 计算贡献即可。

所以总时间复杂度为 $\mathcal O(n \sqrt n)$，总空间复杂度为 $\mathcal O(n)$。

$\text{32.39s /  75.05MB /  3.92KB C++11 O2}$。

```cpp
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <cstring>
#include <vector>

namespace Fread
{
    const int SIZE = 1 << 23;
    char buf[SIZE], *S, *T;
    inline char getchar()
    {
        if (S == T)
        {
            T = (S = buf) + fread(buf, 1, SIZE, stdin);
            if (S == T)
                return '\n';
        }
        return *S++;
    }
}
namespace Fwrite
{
    const int SIZE = 1 << 23;
    char buf[SIZE], *S = buf, *T = buf + SIZE;
    inline void flush()
    {
        fwrite(buf, 1, S - buf, stdout);
        S = buf;
    }
    inline void putchar(char c)
    {
        *S++ = c;
        if (S == T)
            flush();
    }
    struct NTR
    {
        ~NTR()
        {
            flush();
        }
    } ztr;
}

#ifdef ONLINE_JUDGE
#define getchar Fread::getchar
#define putchar Fwrite::putchar
#endif

typedef long long ll;

inline int read()
{
	int x = 0, f = 1;
	char c = getchar();
	while(c < '0' || c > '9')
	{
		if(c == '-') f = -1;
		c = getchar();
	}
	while(c >= '0' && c <= '9')
	{
		x = x * 10 + c - '0';
		c = getchar();
	}
	return x * f;
}

inline void write(ll x)
{
	if(x < 0)
	{
		putchar('-');
		x = -x;
	}
	if(x > 9)
		write(x / 10);
	putchar(x % 10 + '0');
}

const int _ = 5e5 + 7, S = 100;

int n, m, k, a[_], bel[_], siz, mx, cnt[_], flg[_], pre[_];

ll f[_], Ans[_];

struct Query
{
	int l, r, id;
	ll ans;
	inline bool operator < (const Query &t) const
	{
		return bel[l] == bel[t.l] ? (bel[l] & 1 ? r < t.r : r > t.r) : bel[l] < bel[t.l];
	}
} q[_];

struct Node
{
	int l, r, id, x;
	bool operator < (const Node &t) const
	{
		return x < t.x;
	}
} t[_ << 1];

std::vector<int> fac[_];

signed main()
{
	n = read(), m = read();
	siz = sqrt(n);
	for(int i = 1; i <= n; ++i)
	{
		a[i] = read();
		bel[i] = (i - 1) / siz + 1;
		mx = std::max(mx, a[i]);
		if(fac[a[i]].empty())
		{
			for(int j = 1; j * j <= a[i]; ++j)
				if(a[i] % j == 0)
				{
					f[i] += cnt[j];
					flg[j]++;
					if(j * j != a[i])
					{
						f[i] += cnt[a[i] / j];
						flg[a[i] / j]++;
					}
					fac[a[i]].emplace_back(j);
				}
		}
		else
		{
			for(int x : fac[a[i]])
			{
				f[i] += cnt[x];
				flg[x]++;
				if(x * x != a[i])
				{
					f[i] += cnt[a[i] / x];
					flg[a[i] / x]++;
				}
			}
		}
		f[i] += f[i - 1] + flg[a[i]];
		cnt[a[i]]++;
	}
	for(int i = 1; i <= m; ++i)
		q[i] = {read(), read(), i, 0};
	std::sort(q + 1, q + m + 1);
	for(int i = 1, l = 1, r = 0; i <= m; ++i)
	{
		if(r < q[i].r) t[++k] = {r + 1, q[i].r, -i, l - 1}, q[i].ans += f[q[i].r] - f[r], r = q[i].r;
		if(l > q[i].l) t[++k] = {q[i].l, l - 1, i, r}, q[i].ans -= f[l - 1] - f[q[i].l - 1], l = q[i].l;
		if(r > q[i].r) t[++k] = {q[i].r + 1, r, i, l - 1}, q[i].ans -= f[r] - f[q[i].r], r = q[i].r;
		if(l < q[i].l) t[++k] = {l, q[i].l - 1, -i, r}, q[i].ans += f[q[i].l - 1] - f[l - 1], l = q[i].l;
	}
	std::sort(t + 1, t + k + 1);
	memset(f, 0, sizeof f);
	for(int i = 1, x = 0; i <= k; ++i)
	{
		while(x < t[i].x)
		{
			x++;
			for(int v : fac[a[x]])
			{
				f[v]++;
				if(v * v != a[x])
					f[a[x] / v]++;
			}
			if(a[x] > S)
				for(int j = 1; j * a[x] <= mx; ++j)
					f[j * a[x]]++;
		}
		for(int k = t[i].l; k <= t[i].r; ++k)
			if(t[i].id < 0)
				q[-t[i].id].ans -= f[a[k]];
			else
				q[t[i].id].ans += f[a[k]];
	}
	for(int i = 1; i <= S; ++i)
	{
		cnt[0] = pre[0] = 0;
		for(int j = 1; j <= n; ++j)
		{
			cnt[j] = cnt[j - 1] + (a[j] == i);
			pre[j] = pre[j - 1] + (a[j] % i == 0);
		}
		for(int j = 1; j <= k; ++j)
			if(t[j].id < 0)
		 		q[-t[j].id].ans -= (ll)cnt[t[j].x] * (ll)(pre[t[j].r] - pre[t[j].l - 1]);
		 	else
		 		q[t[j].id].ans += (ll)cnt[t[j].x] * (ll)(pre[t[j].r] - pre[t[j].l - 1]);
	}
	for(int i = 1; i <= m; ++i)
	{
		q[i].ans += q[i - 1].ans;
		Ans[q[i].id] = q[i].ans;
	}
	for(int i = 1; i <= m; ++i)
		write(Ans[i]), putchar('\n');
}
```






---

## 作者：gxy001 (赞：5)

考虑莫队二次离线：

设 $F(i,k)$ 为 $[1,k]$ 中大于 $a_i$ 的数的和，$G(i,k)$ 为 $[1,k]$ 中小于 $a_i$ 的数的数量。

左指针移动到 $x$ 造成的答案变化：$F(x,r)-F(x,x)+(G(x,r)-G(x,x)+1)\times a_x$

右指针移动到 $x$ 造成的答案变化：$F(x,x-1)-F(x,l-1)+(G(x,x-1)-G(x,l-1)+1)\times a_x$ 

按照套路，我们将 $F(x,x-1)=F(x,x)$ 和 $G(x,x-1)=G(x,x)$ 的值都通过树状数组预处理出来，莫队的时候直接处理；剩余部分二次离线后使用扫描线处理，由于莫队的指针移动连续，我们对于一次连续的移动只需要记录一次，一次询问最多发生两次连续的指针挪动，所以这部分空间复杂度 $O(m)$。

扫描线时需要注意，莫队指针移动路径的总长度为 $O(n\sqrt m)$，所以我们需要 $O(1)$ 查询的数据结构，由于只有 $O(n)$ 次插入，所以插入复杂度不能超过 $O(\sqrt n)$，使用分块即可。

最后记得将答案求前缀和，具体的原因是询问 $i$ 处的指针移动对询问 $[i,m]$ 会产生影响。

空间复杂度：$O(a_i+n+m)$ 时间复杂度：$O(n\sqrt m+n\sqrt {a_i})$ 

---

下面给出代码，不懂得可以照着代码理解一下。温馨提示：记得开 `long long`。

```cpp
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<vector>
#include<tuple>
namespace IO{
	#define BUFSIZE 10000000
	struct read{
		char buf[BUFSIZE],*p1,*p2,c,f;
		read():p1(buf),p2(buf){}
		char gc(void){
			if(p1==p2)p2=buf+fread(p1=buf,1,BUFSIZE,stdin);
			if(p1==p2)return EOF;
			else return *p1++;
		}
		read& operator >>(int& x){
			c=gc(),f=1,x=0;
			for(;c<'0'||c>'9';c=gc())if(c=='-')f=-1;
			for(;c>='0'&&c<='9';c=gc())x=x*10+c-'0';
			x*=f;
			return *this;
		}
	};
	struct write{
		char buf[BUFSIZE],*p1,*p2,s[50];
		int tp;
		write():p1(buf),p2(buf+BUFSIZE){}
		~write(){flush();}
		void flush(void){
			fwrite(buf,1,p1-buf,stdout);
			p1=buf;
		}
		void pc(char c){
			if(p1==p2)flush();
			*p1++=c;
		}
		write& operator <<(long long x){
			if(x<0)x=-x,pc('-');
			do{s[tp++]=x%10+'0',x/=10;}while(x);
			while(tp)pc(s[--tp]);
			return *this;
		}
		write& operator <<(char x){
			pc(x);
			return *this;
		}
	};
	read in;
	write out;
}
using IO::in;
using IO::out;
int n,m,a[500010],bel[500010],sz,belv[100010],rv[320];
long long c[100010],f[500010],g[500010],ans[500010],t[100010];
inline void updated(int i,long long const &x,long long *c){//树状数组
	for(;i<=100000;i+=i&-i)c[i]+=x;
}
inline long long queryd(int i,long long *c){
	long long res(0);
	for(;i;i-=i&-i)res+=c[i];
	return res;
}
struct node{
	int l,r,id;
	inline bool operator <(node const &x)const{
		return bel[l]==bel[x.l]?r<x.r:l<x.l;
	}
}q[500010];
std::vector<std::tuple<int,int,int,int> > v[500010];
long long fs[350],fv[100010],gs[350],gv[100010];
inline void update(int const &p,int const &k,long long *s,long long *sv){//分块
	for(int i=belv[p],j=belv[100000];i<=j;i++) s[i]+=k;
	for(int i=p,j=rv[belv[p]];i<=j;i++) sv[i]+=k;
}
inline long long query(int const &p,long long *s,long long *sv){
	return s[belv[p]-1]+sv[p];
}
int main(){
	in>>n>>m;
	::sz=317;
	for(int i=1;i<=100000;i++)belv[i]=(i-1)/::sz+1;
	for(int i=0,j=1;i<=100000;i+=::sz,j++)rv[j-1]=i;//分块
	rv[belv[100000]]=100000;
	int sz=n/sqrt(m+1)+1;
	for(int i=1;i<=n;i++)in>>a[i],bel[i]=(i-1)/sz+1;//莫队分块
	for(int i=1;i<=m;i++)in>>q[i].l>>q[i].r,q[i].id=i;
	std::sort(q+1,q+m+1);
	for(int i=1;i<=n;i++){//预处理
		updated(a[i],a[i],c);
		f[i]=queryd(100000,c)-queryd(a[i],c);
		g[i]=queryd(a[i]-1,t);
		updated(a[i],1,t);
	}
	for(int i=1,l=1,r=0;i<=m;i++){//莫队
		if(l>q[i].l) v[r].emplace_back(q[i].l,l-1,1,q[i].id);
		while(l>q[i].l) --l,ans[q[i].id]-=f[l]+(g[l]-1)*a[l];
		if(r<q[i].r) v[l-1].emplace_back(r+1,q[i].r,-1,q[i].id);
		while(r<q[i].r)	++r,ans[q[i].id]+=f[r]+(g[r]+1)*a[r];
		if(l<q[i].l) v[r].emplace_back(l,q[i].l-1,-1,q[i].id);
		while(l<q[i].l) ans[q[i].id]+=f[l]+(g[l]-1)*a[l],++l;
		if(r>q[i].r) v[l-1].emplace_back(q[i].r+1,r,1,q[i].id);
		while(r>q[i].r) ans[q[i].id]-=f[r]+(g[r]+1)*a[r],--r;
	}
	for(int p=1;p<=n;p++){//扫描线
		int l,r,kt,id;
		update(a[p],a[p],fs,fv),update(a[p],1,gs,gv);
		for(auto&& x:v[p]){
			std::tie(l,r,kt,id)=x;
			for(int i=l;i<=r;i++)
				ans[id]+=kt*(query(100000,fs,fv)-query(a[i],fs,fv)+query(a[i]-1,gs,gv)*a[i]);
		}
	}
	for(int i=2;i<=m;i++)ans[q[i].id]+=ans[q[i-1].id];//前缀和
	for(int i=1;i<=m;i++)out<<ans[i]<<'\n';
	return 0;
}
```



---

## 作者：EnofTaiPeople (赞：4)

二次离线莫队，是一种可以做到 $O(n\sqrt m+nk)$ 时间，$O(n)$ 空间的莫队算法。

一般需要一个数字对于一个区间的贡献具有结合律且问题不强制在线。

设 $ans(x,[l,r])$ 表示第 $x$ 个数字对区间 $[l,r]$ 的贡献，则 $ans(x,[l,r])=a_x\times(1+\sum_{l\le i\le r}[a_i<a_x])+\sum_{l\le i\le r}[a_i>a_x]\times a_x$ 发现两部分都具有结合律，均可以简化为单点修改，区间查询的问题，用树状数组维护莫队可以做到 $O(n\sqrt m\log_2n)$，显然过不去。

我们只需要计算 $ans(l,[l,r])$ 与 $ans(r,[l,r])$（自己对自己不会产生贡献，所以 $ans(l,[l,r])=ans(l,[l+1,r])$）。

差分一下：$ans(l,[l,r])=ans(l,[1,r])-ans(l,[1,l-1])=ans(l,[1,r])-ans(l,[1,l])$，$ans(r,[l,r])=ans(r,[1,r])-ans(r,[1,l-1])$，其中 $ans(l,[1,l])$ 可以预处理另一部分可以在第二遍扫描时统一计算。

发现另一部分的查询次数是 $O(n\sqrt m)$ 的，所以需要采用 $O(1)$ 查询的数据结构，可以使用值域分块，可以做到 $O(\sqrt C)$ 修改，$O(1)$ 查询。

总时间复杂度：$O(n(\sqrt m+\sqrt C))$，空间复杂度：$O(n+m+C)$。

开 O2 只需 1.65s，真的不卡常！
```cpp
#include<bits/stdc++.h>
using namespace std;
using ll=long long;
const int N=5e5+5,C=2e5+5,K=305;
inline void File(){
#ifndef ONLINE_JUDGE
	freopen("a.in","r",stdin);
	freopen("a.out","w",stdout);
#endif
}
namespace fast_io{
	char ib[N+5],ob[N+85],stk[85];
	int it,ed,c,ot,t;
#define _gc (it==ed&&(ed=(it=0)+fread(ib,1,N,stdin),it==ed))?EOF:ib[it++]
	inline void read(int &x){
		for(c=_gc;c<48;c=_gc);
		for(x=0;c>47;c=_gc)x=x*10+(48^c);
	}
	inline void flush(){
		fwrite(ob,1,ot,stdout),ot=0;
	}
	inline void write(ll x,char c='\n'){
		t=0;while(x)stk[++t]=48^(x%10),x/=10;
		while(t)ob[ot++]=stk[t--];
		ob[ot++]=c;if(ot>N)flush();
	}
};using fast_io::read;
using fast_io::write;
int n,m,ql[N],qr[N],qt;
int a[N],ct[C],Ct[K],mp[C],mt,p[N];
ll ans[N],fc[N],sm[C],Sm[C];
struct adt{int l,r,id,tp;};
vector<adt>G[N];
inline void add(int x){
	int i,d=a[x]+1;
	for(i=d;(i>>9)==(d>>9);++i)++ct[i];
	for(i=(d>>9)+1;i<=256;++i)++Ct[i];d-=2;
	for(i=d;(i>>9)==(d>>9);--i)sm[i]+=a[x];
	for(i=(d>>9)-1;i>=0;--i)Sm[i]+=a[x];
}
inline ll get(int d){
	return Sm[d>>9]+sm[d]+ll(Ct[d>>9]+ct[d])*d;
}
signed main(){
	File();
	read(n),read(m),qt=1+n/(1+sqrt(m));
	int i,j,L,l,R,r;
	for(i=1;i<=n;++i)
		read(a[i]),fc[i]=get(a[i]),add(i);
	memset(Sm,0,sizeof(Sm));
	memset(Ct,0,sizeof(Ct));
	memset(sm,0,sizeof(sm));
	memset(ct,0,sizeof(ct));
	for(i=1;i<=m;++i)
		read(ql[i]),read(qr[i]),p[i]=i;
	stable_sort(p+1,p+m+1,[&](int x,int y){
		return (ql[x]/qt==ql[y]/qt)?((ql[x]/qt)&1)?
		qr[x]<qr[y]:qr[x]>qr[y]:ql[x]<ql[y];
	});
	l=1,r=0;
	for(i=1;i<=m;++i){
		L=ql[p[i]],R=qr[p[i]];
		if(l>L){
			if(r)G[r].push_back({L,l-1,p[i],1});
			while(l>L)--l,ans[p[i]]-=fc[l]-a[l];
		}if(r<R){
			if(l>1)G[l-1].push_back({r+1,R,p[i],-1});
			while(r<R)++r,ans[p[i]]+=fc[r]+a[r];
		}
//		printf("l:%d r:%d ans[i]:%d\n",l,r,ans[i]);
		if(l<L){
			if(r)G[r].push_back({l,L-1,p[i],-1});
			while(l<L)ans[p[i]]+=fc[l]-a[l],++l;
		}if(r>R){
			if(l>1)G[l-1].push_back({R+1,r,p[i],1});
			while(r>R)ans[p[i]]-=fc[r]+a[r],--r;
		}
//		printf("l:%d r:%d ans[i]:%d\n",l,r,ans[i]);
//		puts("");
	}
	for(i=1;i<=n;++i){
		add(i);
//		printf("get2:%d\n",get(2));
		for(adt at:G[i])
			for(j=at.l;j<=at.r;++j)
				ans[at.id]+=get(a[j])*at.tp;
	}
//	for(i=1;i<=m;++i)printf("%d ",ans[i]);puts("");
	for(i=1;i<=m;++i)ans[p[i]]+=ans[p[i-1]];
	for(i=1;i<=m;++i)printf("%lld\n",ans[i]);
//		write(ans[i]);
	fast_io::flush();return 0;
}
```

---

## 作者：Gmt丶FFF (赞：3)

明显是数据结构问题，如果用主席树会很难满足条件，所以考虑用莫队。

对于加入一个数 $x$，若区间小于 $x$ 的数个数为 $y$，大于 $x$ 的数的和为 $z$，那么贡献即为 $x\times(y+1)+z$。

$y,z$ 都可以用树状数组维护，那么在跑莫队的过程用树状数组即可。

但是很明显复杂度为 $O(n\sqrt n\log n)$，会炸，考虑二次离线消掉 $\log n$。

对于 $f(i,\left [  1,i\right ] )$，可以直接从 $1$ 枚举到 $i$，枚举的过程中维护树状数组处理贡献，找到小于 $x$ 的数的个数与大于 $x$ 的数的和，然后维护前缀和即可。

对于 $f(k,\left[1,i\right])$，进行二次离线，要使查询为 $O(1)$，只能利用值域分块，维护块的前缀和与块内前缀和，查询即为块内前缀和与块的前缀和的和（后缀和同理），维护为 $O(sqrt(n))$，扫描线扫一遍即可。

注意一个细节：

每个点入队与出队有一个基础值，即为 $x\times(y+1)+z$ 中的 $+1$，然而在增加前缀贡献与删除前缀贡献的抵消下会将这个基础值，所以要在第一次离线跑莫队时维护一遍区间和（也可以最后前缀和）。

扫描线查询答案与维护答案复杂度都为 $O(\sqrt n)$，树状数组维护前缀和的复杂度为 $O(n\log n)$，总复杂度为 $O(n\sqrt n)$。

```cpp
#include<iostream>
#include<cstdio>
#include<vector>
#include<algorithm> 
#define int long long
using namespace std;
const int N=5e5+5;
const int K=707;
const int M=500000;
int B=707;
int wr[25],cnwr;
inline int read()
{
	char ch=getchar();
	int sum=0;
	while(ch<'0'||ch>'9')ch=getchar();
	while(ch>='0'&&ch<='9')sum=(sum<<1)+(sum<<3)+(ch^48),ch=getchar();
	return sum;
}
inline void write(int x)
{
	if(x==0)putchar('0');
	while(x)wr[++cnwr]=x%10,x/=10;
	while(cnwr)putchar(wr[cnwr--]^48);
}
int a[N],n,m,k,p[N],cnt,sum[N],ans[N],res[N],f1[N],f2[N];
namespace fk
{
	int pre1[N],pre2[N],suf1[N],suf2[N],L[N],R[N],b[N];
	void init()
	{
		for(int i=1;i<=M;i++)b[i]=i/B+1;
		for(int i=1;i<=b[M];i++)L[i]=max(1ll,(i-1)*B),R[i]=min(M,i*B-1);
	}
	void add(int x)
	{
		for(int i=b[x];i<=b[n];i++)pre1[i]++;
		for(int i=x;i<=R[b[x]];i++)pre2[i]++;
		for(int i=b[x];i>=1;i--)suf1[i]+=x;
		for(int i=x;i>=L[b[x]];i--)suf2[i]+=x;
	}
	inline int search(int x)
	{
		int sum=0;
		if(b[x+1]==b[x])sum+=suf2[x+1];
		sum+=suf1[b[x]+1];
		if(b[x-1]==b[x])sum+=pre2[x-1]*x;
		sum+=(pre1[b[x]-1]+1)*x;
//		cout<<x<<" "<<b[x]<<" "<<suf1[b[x]+1]<<" ??? "<<pre1[b[x]-1]<<endl;
		return sum;
	}
}
struct node2
{
	int opt,name,l,r;
};
vector<node2>v[N];
struct node
{
	int name,l,r;
}q[N];
bool cmp(node x,node y)
{
	if(p[x.l]==p[y.l])
	{
		if(p[x.l]&1)return x.r<y.r;
		else return x.r>y.r;
	}
	return p[x.l]<p[y.l];
}
inline int lowbit(int x)
{
	return x&(-x);
}
void update1(int x,int k)
{
	while(x<=M)
	{
		f1[x]+=k;
		x+=lowbit(x);
	}
}
void update2(int x,int k)
{
	while(x)
	{
		f2[x]+=k;
		x-=lowbit(x);
	}
}
int search1(int x)
{
	int sum=0;
	while(x)
	{
		sum+=f1[x];
		x-=lowbit(x);
	}
	return sum;
}
int search2(int x)
{
	int sum=0;
	while(x<=M)
	{
		sum+=f2[x];
		x+=lowbit(x);
	}
	return sum;
}
signed main()
{
//	freopen("data.in","r",stdin);
	n=read(),m=read();
	for(int i=1;i<=n;i++)a[i]=read(),p[i]=i/K+1;
	for(int i=1;i<=m;i++)q[i]={i,read(),read()};
	if(n<=1000)B=M; 
	for(int i=1;i<=n;i++)
	{
		sum[i]=sum[i-1]+search2(a[i]+1)+(search1(a[i]-1)+1)*a[i];
		update1(a[i],1);
		update2(a[i],a[i]);
	}
	sort(q+1,q+1+m,cmp);
	q[0]={0,1,0};
	for(int i=1;i<=m;i++)
	{
		int l=q[i-1].l,r=q[i-1].r;
		int x=q[i].l,y=q[i].r;
		ans[i]=sum[y]-sum[r]+sum[x-1]-sum[l-1];
		if(l<x)v[y].push_back({-1,i,l,x-1});
		else if(l>x)v[y].push_back({1,i,x,l-1});
		if(r<y)v[l-1].push_back({-1,i,r+1,y});
		else if(r>y)v[l-1].push_back({1,i,y+1,r});
		while(l<x)ans[i]-=a[l++];
		while(l>x)ans[i]+=a[--l];
		while(r<y)ans[i]+=a[++r];
		while(r>y)ans[i]-=a[r--];
//		cout<<l<<" "<<r<<" "<<x<<" "<<y<<" "<<i<<" "<<ans[i]<<endl;
	}
	fk::init();
	for(int i=0;i<=n;i++)
	{
		if(i)fk::add(a[i]);
		int len=v[i].size();
		for(int j=0;j<len;j++)
		{
			int opt=v[i][j].opt,name=v[i][j].name,l=v[i][j].l,r=v[i][j].r;
			int num=0;
			for(int s=l;s<=r;s++)num+=fk::search(a[s]);
//			cout<<i<<" "<<l<<" "<<r<<" "<<num<<endl;
			ans[name]+=opt*num;
		}
	}
	for(int i=1;i<=m;i++)ans[i]+=ans[i-1],res[q[i].name]=ans[i];
	for(int i=1;i<=m;i++)write(res[i]),putchar('\n');
	return 0;
}
/*
2 3
1 2
1 1
2 2
1 2
*/
```


---

## 作者：Fido_Puppy (赞：3)

## 1 $\text{Question}$

[P5501 [LnOI2019]来者不拒，去者不追](https://www.luogu.com.cn/problem/P5501)

## 2 $\text{Solution}$

很容易就能想到莫队的做法，用莫队套一个平衡树或者线段树。

时间复杂度 $\Theta(n^{1.5}\log n)$。

但是这样的时间复杂度明显是不能过的。

我们就可以考虑莫队二次离线。

考虑每一次转移时加入一个数答案的变化量（减去一个数就是相反数）。

我们设 $f(x,y,k)$ 为区间 $x\sim y$ 中比 $k$ 小的数的个数。

设 $Gsum(x,y,k)$ 为区间 $x\sim y$ 中比 $k$ 大的数的和。

假设在莫队中，我们已经遍历了区间 $l\sim r-1$，现在要插入 $a_r$。

$$\Delta Ans = f(l,r-1,a_r)\times a_r+a_r+Gsum(l,r-1,a_r)$$

解释一下，$f(l,r-1,a_r)\times a_r + a_r$ 就是 $a_r$ 的“Abbi”值。

而 $a_r$ 的插入会导致区间内比它大的数的排名加 $1$。

所以每个比它大的数的“Abbi”值都会增加，总共增加 $Gsum(l,r-1,a_r)$。

接着我们将这个式子差分：

$$\Delta Ans = f(1,r-1,a_r)\times a_r-f(1,l-1,a_r)\times a_r+a_r+Gsum(1,r-1,a_r)-Gsum(1,l-1,a_r)$$

我们会发现 $f(1,r-1,a_r)$ 和 $Gsum(1,r-1,a_r)$ 都是可以预处理的。

具体就是将每一个 $f(1,i-1,a_i)$ 和 $Gsum(1,i-1,a_i)$ 算出来，时间复杂度 $\Theta(n\log n)$。

接着我们考虑 $f(1,l-1,a_r)$ 和 $Gsum(1,l-1,a_r)$。

我们可以发现如果把我们所有要求的这样的询问加起来，可以理解为对于每一个区间 $1\sim i-1$，我们需要求出 $f(1,i-1,k)$ 和 $Gsum(1,i-1,k)$，一共询问 $n^{1.5}$ 次。

并且假如我们用一个数组结构，由于我们需要将区间 $1\sim i$ 存入数据结构中，所以我们可以从 $1\sim n$ 循环，每次加入一个数，这样总共的加入次数为 $n$ 次。

首先我们可以用 vector。

具体可以这样定义：

```vector <int> vec[500010];```

假设我们有一个询问 $f(1,l-1,a_r)$，我们就可以将 $a_r$ 插入到 $vec_l$ 中。

于是我们就可以方便的找到对于每个区间 $1\sim i-1$ 的所有的询问。

接着我们考虑这个数据结构。

应该需要能够单点修改和区间求和。

假设这个数据结构的单点修改的时间复杂度为 $\Theta(\alpha)$，区间求和的时间复杂度为 $\Theta(\beta)$。

则总时间复杂度为 $\Theta(n^{1.5}\beta+n\alpha)$。

明显我们看到这个 $n^{1.5}\beta$ 就可以知道区间求和只能是 $\Theta(1)$ 的（否则承受不了啊）。

于是我们能够想到值域分块，加上每个块内数总和的前缀和，区间求和可以做到 $\Theta(1)$。

它的单点修改的时间复杂度为 $\Theta(n^{0.5})$，也能够承受。

所以总时间复杂度为 $\Theta(n^{1.5})$。

我们再考虑已经遍历了区间 $l+1\sim r$，要插入 $a_l$。

和上面的情况差不多，只需要把所有都到过来就行了。

可是我们如果一个点一个点的插入到 vector 里面，会发现空间复杂度为 $\Theta(n^{1.5})$。

我们会发现每一次莫队插入的点都是连续的，例如 $r$ 指针从 $1$ 移动到 $3$，插入的数就是 $a_1,a_2,a_3$。

所以我们可以将这一段区间存入 vector 中，找的时候循环一下就行了。

像上述的例子，我们就可以把 $1,3$ 存入 vector 中，表示区间 $1\sim 3$。

最后别忘记开 long long。

## 3 $\text{Code}$

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
int n, m, a[500010];
int belong[500010], L[710], R[710], siz, bnum, l = 1, r = 0;
LL f[500010], g[500010], Ans[500010];
struct Query {
	int l, r, id;
}q[500010];
struct node {
	int l, r, p, id;
};
vector <node> vec1[500010], vec2[500010];
inline bool cmp(Query a, Query b) {
	return ((belong[ a.l ] ^ belong[ b.l ])? belong[ a.l ] < belong[ b.l ]:
			(belong[ a.l ] & 1)? a.r < b.r: a.r > b.r);
}
struct Fenwick {
	LL t[100010];
	inline void clear() {
		memset(t, 0, sizeof(t));
	}
	inline int lowbit(int x) {
		return x & (-x);
	}
	inline void update(int x, int v) {
		while (x <= 1e5) {
			t[x] += 1ll * v;
			x += lowbit(x);
		}
	}
	inline LL query(int x) {
		LL ans = 0;
		while (x > 0) {
			ans += t[x];
			x -= lowbit(x);
		}
		return ans;
	}
}T1, T2;
struct Block_Array {
	LL sum1[710], sum2[710][710];
	inline void clear() {
		for (int i = 0; i < 710; i++) {
			sum1[i] = 0;
			for (int j = 0; j < 710; j++)
				sum2[i][j] = 0;
		}
	}
	inline void insert(int x, int v) {
		for (int i = belong[x]; i < 710; i++)
			sum1[i] += 1ll * v;
		for (int i = x; i <= R[ belong[x] ]; i++)
			sum2[ belong[x] ][ i - L[ belong[x] ] + 1 ] += 1ll * v;
	}
	inline LL query(int x) {
		return sum1[ belong[x] - 1 ] + sum2[ belong[x] ][ x - L[ belong[x] ] + 1 ];
	}
}Sum1, Sum2;
signed main() {
	ios::sync_with_stdio(false);
	cin.tie(0); cout.tie(0);
	cin >> n >> m;
	for (int i = 1; i <= n; i++) cin >> a[i];
	siz = 710; bnum = (500000 - 1) / siz + 1;
	for (int i = 1; i <= bnum; i++) {
		L[i] = (i - 1) * siz + 1;
		R[i] = min(i * siz, 500000);
		for (int j = L[i]; j <= R[i]; j++)
			belong[j] = i;
	}
	for (int i = 1; i <= m; i++) {
		cin >> q[i].l >> q[i].r;
		q[i].id = i;
	}
	sort(q + 1, q + m + 1, cmp);
	for (int i = 1; i <= m; i++) {
		if (r < q[i].r) vec1[l].push_back((node){r + 1, q[i].r, 1, q[i].id});
		if (r > q[i].r) vec1[l].push_back((node){q[i].r + 1, r, -1, q[i].id});
		r = q[i].r;
		if (l < q[i].l) vec2[r].push_back((node){l, q[i].l - 1, -1, q[i].id});
		if (l > q[i].l) vec2[r].push_back((node){q[i].l, l - 1, 1, q[i].id});
		l = q[i].l;
	}
	T1.clear(); T2.clear();
	for (int i = 1; i <= n; i++) {
		f[i] = T1.query(a[i] - 1) * 1ll * a[i];
		g[i] = T2.query(100000) - T2.query(a[i]);
		T1.update(a[i], 1);
		T2.update(a[i], a[i]);
	}
	Sum1.clear(); Sum2.clear();
	for (int i = 1; i <= n; i++) {
		for (auto v: vec1[i]) {
			for (int j = v.l; j <= v.r; j++) {
				Ans[ v.id ] += (f[j] - Sum1.query(a[j] - 1) * 1ll * a[j]) * 1ll * v.p;
				Ans[ v.id ] += (g[j] - Sum2.query(100000) + Sum2.query(a[j])) * 1ll * v.p;
				Ans[ v.id ] += 1ll * a[j] * v.p;
			}
		}
		Sum1.insert(a[i], 1);
		Sum2.insert(a[i], a[i]);
	}
	T1.clear(); T2.clear();
	for (int i = n; i >= 1; i--) {
		f[i] = T1.query(a[i] - 1) * 1ll * a[i];
		g[i] = T2.query(100000) - T2.query(a[i]);
		T1.update(a[i], 1);
		T2.update(a[i], a[i]);
	}
	Sum1.clear(); Sum2.clear();
	for (int i = n; i >= 1; i--) {
		for (auto v: vec2[i]) {
			for (int j = v.l; j <= v.r; j++) {
				Ans[ v.id ] += (f[j] - Sum1.query(a[j] - 1) * 1ll * a[j]) * 1ll * v.p;
				Ans[ v.id ] += (g[j] - Sum2.query(100000) + Sum2.query(a[j])) * 1ll * v.p;
				Ans[ v.id ] += 1ll * a[j] * v.p;
			}
		}
		Sum1.insert(a[i], 1);
		Sum2.insert(a[i], a[i]);
	}
	for (int i = 1; i <= m; i++)
		Ans[ q[i].id ] += Ans[ q[ i - 1 ].id ];
	for (int i = 1; i <= m; i++)
		cout << Ans[i] << endl;
	return 0;
}
```
完结撒花 ^_の

---

## 作者：Soulist (赞：3)

 (~~毒瘤出题人考$lxl$聚聚发明的二次离线莫队$...$~~)

首先我们发现定义：$[l,r]$中的排名实际上为严格小于其的数量$+1$

那么如果我们使用莫队，那么显然每次移动加入一个数时，它不会影响小于等于它的数对答案造成的影响。（以右端点的移动为例）

而那些比他大的数对答案的影响都$+1$，此时应该$+=\sum[a_i>x]*a_i$

然后它本身对答案的贡献为$x$*(小于它的数的个数$+1$)

朴素的想法是采用点名被卡的做法，建一颗权值树状数组，每次移动查询一下贡献并做一下插入/删除

复杂度$O(n\sqrt m*\log V)$

不过有趣的是显然每次移动的贡献是满足可差分性的。

下面以$r$端点的移动为例，每次移动对答案的变化看作两个：

$1.$为$[l,r]$内大于$a_r$的数的和，可以看作：

$$\sum_{i=1}^r[a_i>a_r]*a_i-\sum_{i=1}^{l-1}[a_i>a_r]*a_i$$

$2.$为$[l,r]$小于他的数的个数$+1*a_r$，可以看作：

$$(1+\sum_{i=1}^r[a_i<a_r]-\sum_{i=1}^{l-1}[a_i<a_r])*a_r$$

然后你惊人的发现，两个部分的前面那一坨居然都可以直接写个树状数组预处理出来复杂度$O(n\log n)$

所以我们需要处理的实际上只有后面那一坨，而他们则可以将每次移动存在对应的$l$端点处，当作一个询问，然后做一遍扫描线，扫到一个点就把存在其位置处的所有询问都处理掉。

我们扫的过程是从$1-n$扫过去，询问的总数则是$r$移动的次数。

每次询问是问$1-x$中比$y$大的数的和。

不难发现询问的总数是$O(n\sqrt m)$的而插入的总数是$O(n)$

于是可以上一个值域分块来平衡复杂度（那种$\sqrt n$插入，$O(1)$查询的），最后的复杂度就是$O(n\sqrt n)$了（好像此题$n,m$平级）

当然你$l$端点的移动也要反向做一遍。

$but$二次离线莫队直接写空间复杂度是$O(n\sqrt m)$的，你可以写个优化空间的版本，把每次的移动当作一个区间存起来，就是$O(m)$了。

否则毒瘤出题人的$50W$数据你空间十有八九是不能过的

不过这道题有点良心就是没有离散化$qwq$

一点细节：我们做二次离线莫队的第二部分（扫描线）处的复杂度是$O(n\sqrt n)$的，然而有趣的是我们做朴素莫队离线移动的复杂度也是$O(n\sqrt n)$的，或许会存在常数上的问题，所以我们可以考虑记一个前缀和，这样每次移动就可以直接跳过去了，莫队的复杂度就降为了$O(m)$地说。否则我这个大常数做法应该就卡不过去了。

然后因为我太弱了不知道怎么写只要跑一遍的二次离线莫队(我看别人的代码都是一个$for$)，所以我的要跑两遍。

~~貌似最后两个点卡着上界过的，不过没关系过了就好~~

如果你看了这篇题解还是不知道怎么写可以看看[这篇](https://www.luogu.org/blog/Soulist/solution-p5047)

下面是喜闻乐见的代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define rep( i, s, t ) for( register int i = s; i <= t; ++ i )
#define drep( i, s, t ) for( register int i = t; i >= s; -- i )
#define re register
#define lowbit(x) ( x & ( -x ) )
#define LL long long
int read() {
	char cc = getchar(); int cn = 0, flus = 1;
	while(cc < '0' || cc > '9') {  if( cc == '-' ) flus = -flus;  cc = getchar();  }
	while(cc >= '0' && cc <= '9')  cn = cn * 10 + cc - '0', cc = getchar();
	return cn * flus;
}
const int N = 500000 + 5 ; 
const int M = 500 + 5 ; 
int n, m, tot, cnt, Maxa, c[N], Id[N], L[N], R[N];
int tree1[N], w1[N], ad[M] ; 
LL Ans, ans[N], tree2[N], num1[N], num2[N], w2[N], mk[M] ; 
struct Q { int l, r, id; } q[N];
struct node { int p, l, r, id; };
vector<node> vc1[N], vc2[N] ; 
bool cmp( Q x, Q y ) { return ( x.l / tot == y.l / tot ) ? x.r < y.r : x.l < y.l ; }//莫队分块
//树状数组 
void tr_add1( int x, int k ) { for( int i = x; i <= Maxa; i += lowbit(i) ) tree1[i] += k ; }
void tr_add2( int x, int k ) { for( int i = x; i <= Maxa; i += lowbit(i) ) tree2[i] += 1ll * k ; }
LL tr_sum( int x ) { LL res = 0 ; for( ; x; x -= lowbit(x) ) res += tree1[x]; return res ; }
LL tr_sum2( int x ) { LL res = 0 ; for( ; x; x -= lowbit(x) ) res += 1ll * tree2[x]; return res ; }
//end 
void pushup( int x ) { //值域分块 
	int fr = x + 1, ed = x - 1 ;
	if( ad[Id[x]] ) rep( i, L[Id[x]], R[Id[x]] ) w1[i] += ad[Id[x]] ; ad[Id[x]] = 0 ;
	rep( i, fr, R[Id[x]] ) ++ w1[i] ; fr = Id[x] + 1 ; 
	rep( i, fr, tot ) ++ ad[i] ; 
	if( mk[Id[x]] ) rep( i, L[Id[x]], R[Id[x]] ) w2[i] += mk[Id[x]] ; mk[Id[x]] = 0 ;
	rep( i, L[Id[x]], ed ) w2[i] += x ; ed = Id[x] - 1 ;
	rep( i, 1, ed ) mk[i] += x ; 
}
void solve() {
	cnt = sqrt(Maxa), tot = 1, L[1] = 1 ; 
	if( cnt * cnt < Maxa ) ++ cnt ;
	rep( i, 1, Maxa ) { Id[i] = tot; if( i % cnt == 0 ) { R[tot] = i, L[++ tot] = i + 1 ; } }
	R[tot] = Maxa ; int id, p, fr, ed ; 
	rep( i, 1, n ) {
		int sz = vc1[i].size() - 1 ; 
		rep( j, 0, sz ) {
			id = vc1[i][j].id, p = vc1[i][j].p, fr = vc1[i][j].l, ed = vc1[i][j].r ;
			rep( k, fr, ed ) ans[id] += 1ll * p * ( w2[c[k]] + mk[Id[c[k]]] + 1ll * c[k] * ( w1[c[k]] + ad[Id[c[k]]] ) ) ;
		} pushup( c[i] ) ;  
	}
	memset( w1, 0, sizeof(w1) ), memset( w2, 0, sizeof(w2) ) ;
	memset( ad, 0, sizeof(ad) ), memset( mk, 0, sizeof(mk) ) ;
	drep( i, 1, n ) {
		int sz = vc2[i].size() - 1 ; 
		rep( j, 0, sz ) {
			id = vc2[i][j].id, p = vc2[i][j].p, fr = vc2[i][j].l, ed = vc2[i][j].r ;
			rep( k, fr, ed ) ans[id] += 1ll * p * ( w2[c[k]] + mk[Id[c[k]]] + 1ll * c[k] * ( w1[c[k]] + ad[Id[c[k]]] ) ) ;
		} pushup( c[i] ) ;
	}
	rep( i, 1, m ) ans[q[i].id] += ans[q[i - 1].id] ; 
}
 signed main()
{
	n = read(), m = read(), tot = n / sqrt(1.5 * m) ; 
	rep( i, 1, n ) num2[i] = num1[i] = c[i] = read(), Maxa = max( Maxa, c[i] ) ; 
	rep( i, 1, m ) q[i].l = read(), q[i].r = read(), q[i].id = i ; sort( q + 1, q + m + 1, cmp ) ; //排序，读入询问 
	rep( i, 1, n ) num1[i] += ( tr_sum2(Maxa) - tr_sum2(c[i]) + 1ll * c[i] * tr_sum(c[i] - 1) ), 
	num1[i] += num1[i - 1], tr_add1( c[i], 1 ), tr_add2( c[i], c[i] ) ; 
	memset( tree1, 0, sizeof(tree1) ), memset( tree2, 0, sizeof(tree2) ) ;
	drep( i, 1, n ) num2[i] += ( tr_sum2(Maxa) - tr_sum2(c[i]) + 1ll * c[i] * tr_sum(c[i] - 1) ), 
	num2[i] += num2[i + 1], tr_add1( c[i], 1 ), tr_add2( c[i], c[i] ) ;
	int l = 1, r = 0 ; 
	//莫队处理 
	rep( i, 1, m ) {
		while( r < q[i].r ) ans[q[i].id] += ( num1[q[i].r] - num1[r] ), 
		vc1[l].push_back((node){ -1, r + 1, q[i].r, q[i].id }), r = q[i].r ;
		while( r > q[i].r ) ans[q[i].id] -= ( num1[r] - num1[q[i].r] ), 
		vc1[l].push_back((node){ 1, q[i].r + 1, r, q[i].id }), r = q[i].r ;
		while( l < q[i].l ) ans[q[i].id] -= ( num2[l] - num2[q[i].l] ),
		vc2[r].push_back((node){ 1, l, q[i].l - 1, q[i].id }), l = q[i].l ;
		while( l > q[i].l ) ans[q[i].id] += ( num2[q[i].l] - num2[l] ), 
		vc2[r].push_back((node){ -1, q[i].l, l - 1, q[i].id }), l = q[i].l ;
	}
	solve() ; 
	rep( i, 1, m ) printf("%lld\n", ans[i] ) ;
	return 0;
}
```

---

## 作者：Lyccrius (赞：1)

首先，这是一道莫队二次离线。

我们知道，在普通莫队中，假设 $n$ 与 $m$ 同阶，那么对于序列上的区间询问问题，如果从 $[l, r]$ 的答案能够 $\mathcal O(1)$ 扩展到 $[l - 1, r], [l + 1, r], [l, r + 1], [l, r - 1]$（即与 $[l, r]$ 相邻的区间）的答案，那么可以在 $O(\mathcal n \sqrt{n})$ 的复杂度内求出所有询问的答案。

将普通莫队应用于此题，由于需要使用数据结构维护权值，故单次端点移动为 $\mathcal O(\log n)$ 而非 $\mathcal O(1)$，总时间复杂度 $\mathcal O(n \sqrt n \log n)$，会[被卡](https://www.luogu.com.cn/discuss/133459)。

众所周知莫队是一种离线算法，而将莫队算法中端点移动对答案产生的贡献离线下来统一处理，可以看作在离线算法上又一次离线，故称为莫队二次离线。

由于端点移动次数为 $\mathcal O(n \sqrt m)$，也就是说二次离线会产生 $\mathcal O(n \sqrt m)$ 次二次查询，于是我们需要一种支持 $\mathcal O(1)$ 查询的数据维护方式。

由于元素只有 $\mathcal O(n)$ 个，插入次数为 $\mathcal O(n)$，我们可以在二次查询时使用权值前缀分块来维护。

个人认为代码不够精简，但思路非常明晰。

```cpp
#include <iostream>
#include <algorithm>
#include <vector>

typedef long long lxl;

const int maxN = 5e5;
const int maxM = 5e5;
const int maxA = 1e5;
const int sqrN = 708;
const int sqrA = 317;

int n, m;
int a[maxN + 10];
int b[maxN + 10];
int l, r;
lxl f[maxN + 10];
lxl g[maxN + 10];
lxl ans[maxM + 10];

typedef struct SegmentTree {
    struct Node {
        lxl val;
        lxl tag;
    } node[4 * maxA + 10];

    void MakeTag(int u, int l, int r, lxl val) {
        node[u].val += val * (r - l + 1);
        node[u].tag += val;
        return;
    }

    void PushDown(int u, int l, int r) {
        if (!node[u].tag) return;
        int mid = (l + r) / 2;
        MakeTag(2 * u, l, mid, node[u].tag);
        MakeTag(2 * u + 1, mid + 1, r, node[u].tag);
        node[u].tag = 0;
        return;
    }

    void PushUp(int u) {
        node[u].val = node[2 * u].val + node[2 * u + 1].val;
        return;
    }

    void Add(int u, int l, int r, int s, int t, lxl val) {
        if (s > t) return;
        if (s <= l && r <= t) {
            MakeTag(u, l, r, val);
            return;
        }
        PushDown(u, l, r);
        int mid = (l + r) / 2;
        if (s <= mid) Add(2 * u, l, mid, s, t, val);
        if (t >= mid + 1) Add(2 * u + 1, mid + 1, r, s, t, val);
        PushUp(u);
        return;
    }

    void Add(int u, int l, int r, int pos, lxl val) {
        Add(u, l, r, pos, pos, val);
        return;
    }

    lxl Ask(int u, int l, int r, int s, int t) {
        if (s > t) return 0;
        if (s <= l && r <= t) {
            return node[u].val;
        }
        PushDown(u, l, r);
        int mid = (l + r) / 2;
        if (t <= mid) return Ask(2 * u, l, mid, s, t);
        if (s >= mid + 1) return Ask(2 * u + 1, mid + 1, r, s, t);
        return Ask(2 * u, l, mid, s, t) + Ask(2 * u + 1, mid + 1, r, s, t);
    }
} sgt;

typedef struct BlockArray {
    struct Block {
        int l, r;
        lxl tag;
    } block[sqrA + 10];

    struct Array {
        int bel;
        lxl val;
    } array[maxA + 10];

    void Build() {
        for (int i = 1; i <= maxA; i++) array[i].bel = (i - 1) / sqrA + 1;
        for (int i = 1; i <= maxA; i++) block[array[i].bel].r = i;
        for (int i = maxA; i >= 1; i--) block[array[i].bel].l = i;
        return;
    }

    void Add(int pos, lxl val) {
        for (int i = array[pos].bel + 1; i <= array[maxA].bel; i++) block[i].tag += val;
        for (int i = pos; i <= block[array[pos].bel].r; i++) array[i].val += val;
        return;
    }

    lxl Ask(int pos) {
        return array[pos].val + block[array[pos].bel].tag;
    }

    lxl Ask(int l, int r) {
        if (l > r) return 0;
        return Ask(r) - Ask(l - 1);
    }
} dba;

namespace captainMoSecondaryOffline {
    namespace offline2 {
        struct Query {
            int i;
            int l, r;
            int k;
        };

        std::vector<Query> query[maxN + 10];

        dba sum, cnt;

        void solve() {
            sum.Build();
            cnt.Build();
            for (int i = 1; i <= n; i++) {
                sum.Add(a[i], a[i]);
                cnt.Add(a[i], 1);
                for (int j = 0; j < query[i].size(); j++) {
                    for (int k = query[i][j].l; k <= query[i][j].r; k++) {
                        ans[query[i][j].i] += 1ll * query[i][j].k * (sum.Ask(a[k] + 1, maxA) + cnt.Ask(1, a[k] - 1) * a[k]);
                    }
                }
            }
            return;
        }
    }

    namespace offline1 {
        struct Query {
            int i;
            int l, r;

            bool operator<(const Query &other) const {
                if (b[l] != b[other.l]) return l < other.l;
                return r < other.r;
            }
        };

        std::vector<Query> query;

        sgt sum, cnt;

        void solve() {
            std::sort(query.begin(), query.end());
            for (int i = 1; i <= n; i++) {
                f[i] = sum.Ask(1, 1, maxA, a[i] + 1, maxA);
                g[i] = cnt.Ask(1, 1, maxA, 1, a[i] - 1);
                sum.Add(1, 1, maxA, a[i], a[i]);
                cnt.Add(1, 1, maxA, a[i], 1);
            }
            for (int i = 0, l = 1, r = 0; i < query.size(); i++) {
                if (l > query[i].l) {
                    offline2::query[r].push_back((offline2::Query) {query[i].i, query[i].l, l - 1, 1});
                    while (l > query[i].l) {
                        l--;
                        ans[query[i].i] -= f[l] + (g[l] - 1) * a[l];
                    }
                }
                if (r < query[i].r) {
                    offline2::query[l - 1].push_back((offline2::Query) {query[i].i, r + 1, query[i].r, -1});
                    while (r < query[i].r) {
                        r++;
                        ans[query[i].i] += f[r] + (g[r] + 1) * a[r];
                    }
                }
                if (l < query[i].l) {
                    offline2::query[r].push_back((offline2::Query) {query[i].i, l, query[i].l - 1, -1});
                    while (l < query[i].l) {
                        ans[query[i].i] += f[l] + (g[l] - 1) * a[l];
                        l++;
                    }
                }
                if (r > query[i].r) {
                    offline2::query[l - 1].push_back((offline2::Query) {query[i].i, query[i].r + 1, r, 1});
                    while (r > query[i].r) {
                        ans[query[i].i] -= f[r] + (g[r] + 1) * a[r];
                        r--;
                    }
                }
            }
            return;
        }
    }

    void solve() {
        offline1::solve();
        offline2::solve();
        for (int i = 0; i < m; i++) ans[offline1::query[i].i] += ans[offline1::query[i - 1].i];
        return;
    }
}

int main() {
    std::cin >> n >> m;
    for (int i = 1; i <= n; i++) std::cin >> a[i];
    for (int i = 1; i <= n; i++) b[i] = (i - 1) / sqrN + 1;
    for (int i = 1; i <= m; i++) std::cin >> l >> r, captainMoSecondaryOffline::offline1::query.push_back((captainMoSecondaryOffline::offline1::Query) {i, l, r});
    captainMoSecondaryOffline::solve();
    for (int i = 1; i <= m; i++) std::cout << ans[i] << '\n';
    return 0;
}
```

---

## 作者：x7103 (赞：1)

[**不知道更好还是更差的阅读体验**](https://www.cnblogs.com/VCLS01/p/14766001.html)
## 题目描述
给定长度为 $n$ 的序列 $a$，给出 $m$ 个询问。

对于每个询问，给出一个区间 $[l,r]$，求
$$\sum_{i=l}^{r}{\left(1+\sum_{j=l}^{r}{[a_j<a_i]}\right)a_i}$$
**数据范围：**$1\le n,m\le 5\times 10^5$，$a_i\le 10^5$，$1\le l \le r \le n$。

**时间范围：**$3000\operatorname{ms}$。
## Solution 1
看题目可以发现是求区间排名，求区间和显然不好在线维护，考虑莫队。

对于已有的区间 $[l,r]$，若向右插入一个元素，贡献为
$$\sum_{i=l}^{r}{[a_i>a_{r+1}]a_i}+a_{r+1}\left(1+\sum_{i=l}^{r}{[a_i<a_{r+1}]}\right)$$

直接维护的复杂度为 $\Theta(n\sqrt n\log a_{\max})$，信仰得分 $100\operatorname{pts}$，实际得分 $10\operatorname{pts}$。
## Solution 2
上边的带 $\log$ 莫队是没有前途的，考虑二次离线。

考虑前缀和，向右插入一个元素，贡献为
$$\sum_{i=1}^{r}{[a_i>a_{r+1}]a_i}+a_{r+1}\left(1+\sum_{i=1}^{r}{[a_i<a_{r+1}]}\right)-\sum_{i=1}^{l-1}{[a_i>a_{r+1}]a_i}-a_{r+1}\left(\sum_{i=1}^{l-1}{[a_i<a_{r+1}]}\right)$$

定义 $f_{r}=\sum_{i=1}^{r-1}{[a_i>a_{r}]a_i}+a_{r}\left(1+\sum_{i=1}^{r-1}{[a_i<a_{r}]}\right)$，则贡献变为
$$f_{r+1}-\sum_{i=1}^{l-1}{[a_i>a_{r+1}]a_i}-a_{r+1}\left(\sum_{i=1}^{l-1}{[a_i<a_{r+1}]}\right)$$

将 $f$ 数组预处理出来前缀和，后边的贡献离线下来维护，套上值域分块即可处理。

向左插入同理。

由于 $n,m$ 同阶，时间复杂度为 $\Theta(n\sqrt n+n\sqrt{a_{\max}})$，期望得分 $100\operatorname{pts}$。
## Code
```cpp
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<cstring>
#include<vector>
using namespace std;
const int maxn=500010;
typedef long long LL;
int K[maxn],L[maxn],R[maxn],T;
template<class T>inline void read(T &x){
	x=0;char c;
	do c=getchar();while(c<'0'||c>'9');
	while(c>='0'&&c<='9')x=(x<<3)+(x<<1)+(c^48),c=getchar();
}
template<class T>inline void write(T x){
	static char stk[22];int top=0;
	while(x)stk[++top]=x-x/10*10+48,x/=10;
	while(top)putchar(stk[top--]);
	putchar('\n');
}
struct query{
	int l,r,id;
	inline bool operator<(const query &qu)const{
		return K[l]!=K[qu.l]?l<qu.l:((K[l]&1)?r<qu.r:r>qu.r);
	}
}q[maxn];
struct Range{
	int l,r,id,d;
	inline Range(int _l=0,int _r=0,int _id=0,int _d=0){
		l=_l;r=_r;id=_id;d=_d;
	}
};
vector<Range> range[maxn];
struct TreeArray{
	#define lowbit(x) (x&-x)
	LL tr[maxn];
	inline void add(int x,int d){while(x<=100000)tr[x]+=d,x+=lowbit(x);}
	inline LL ask(int x){LL ans=0;while(x)ans+=tr[x],x-=lowbit(x);return ans;}
	inline void clear(){memset(tr,0,sizeof(tr));}
	#undef lowbit
}BIT;
LL f[maxn],pre[maxn];
struct BlockOfRange{
	int bl[maxn],br[maxn],bk[maxn],kt;
	LL v[maxn],tag[maxn],sum;
	inline void Init(){
		kt=sqrt(100010);
		for(int i=1;i<=kt;++i)bl[i]=br[i-1]+1,br[i]=br[i-1]+kt;
		if(R[kt]<100010)bl[kt+1]=br[kt]+1,br[++kt]=100010;
		for(int i=1;i<=kt;++i)for(int j=bl[i];j<=br[i];++j)bk[j]=i;
	}
	inline void add(int x,int d){
		int k=bk[x];sum+=d;
		for(int i=x;i<=br[k];++i)v[i]+=d;
		for(int i=k+1;i<=kt;++i)tag[i]+=d;
	}
	inline LL ask(int x){return tag[bk[x]]+v[x];}
	inline void clear(){
		memset(v,0,sizeof(v));
		memset(tag,0,sizeof(tag));
		sum=0;
	}
}BOR1,BOR2;
LL ans[maxn],res[maxn];
int n,m,a[maxn];
int main(){
	BOR1.Init();BOR2.Init();
	read(n);read(m);
	T=sqrt(n);
	for(int i=1;i<=T;++i)L[i]=R[i-1]+1,R[i]=R[i-1]+T;
	if(R[T]<n)L[T+1]=R[T]+1,R[T]=n;
	for(int i=1;i<=T;++i)for(int j=L[i];j<=R[i];++j)K[j]=i;
	for(int i=1;i<=n;++i)read(a[i]);
	for(int i=1;i<=m;++i){read(q[i].l),read(q[i].r);q[i].id=i;}
	sort(q+1,q+m+1);
	for(int i=1;i<=n;++i){
		f[i]=BIT.ask(a[i]);
		BIT.add(1,a[i]);BIT.add(a[i],-a[i]);
	}
	BIT.clear();
	for(int i=1;i<=n;++i){
		f[i]+=(BIT.ask(a[i]-1)+1)*a[i];
		BIT.add(a[i],1);
	}
	for(int i=1;i<=n;++i)pre[i]=pre[i-1]+f[i];
	int curl=1,curr=0;
	for(int i=1;i<=m;++i){
		int l=q[i].l,r=q[i].r;
		if(curr<r)range[curl-1].push_back(Range(curr+1,r,i,-1)),ans[i]+=pre[r]-pre[curr];
		if(curr>r)range[curl-1].push_back(Range(r+1,curr,i,1)),ans[i]-=pre[curr]-pre[r];
		curr=r;curl=l;
	}
	for(int i=1;i<=n;++i){
		BOR1.add(a[i],a[i]);BOR2.add(a[i],1);
		for(auto qry:range[i]){
			int l=qry.l,r=qry.r,id=qry.id,d=qry.d;
			for(int j=l;j<=r;++j)ans[id]+=(BOR1.sum-BOR1.ask(a[j])+a[j]*BOR2.ask(a[j]-1))*d;
		}
	}
	for(int i=1;i<=n;++i)range[i].clear();BOR1.clear();BOR2.clear();BIT.clear();
	for(int i=n;i;--i){
		f[i]=BIT.ask(a[i]);
		BIT.add(1,a[i]);BIT.add(a[i],-a[i]);
	}
	BIT.clear();
	for(int i=n;i;--i){
		f[i]+=(BIT.ask(a[i]-1)+1)*a[i];
		BIT.add(a[i],1);
	}
	for(int i=n;i;--i)pre[i]=pre[i+1]+f[i];
	curl=1;
	for(int i=1;i<=m;++i){
		int l=q[i].l,r=q[i].r;
		if(curl<l)range[r+1].push_back(Range(curl,l-1,i,1)),ans[i]-=pre[curl]-pre[l];
		if(curl>l)range[r+1].push_back(Range(l,curl-1,i,-1)),ans[i]+=pre[l]-pre[curl];
		curl=l;
	}
	for(int i=n;i;--i){
		BOR1.add(a[i],a[i]);BOR2.add(a[i],1);
		for(auto qry:range[i]){
			int l=qry.l,r=qry.r,id=qry.id,d=qry.d;
			for(int j=l;j<=r;++j)ans[id]+=(BOR1.sum-BOR1.ask(a[j])+a[j]*BOR2.ask(a[j]-1))*d;
		}
	}
	for(int i=2;i<=m;++i)ans[i]+=ans[i-1];
	for(int i=1;i<=m;++i)res[q[i].id]=ans[i];
	for(int i=1;i<=m;++i)write(res[i]);
	return 0;
}
```

---

## 作者：__Cby___ (赞：0)

## 思路
区间静态查询，考虑莫队。  
我们考虑当区间 $[l,r]$ 向左或向右扩展时加入数的贡献。我们设这个数为 $a$，区间内数的大小大于 $a$ 的数的和为  $rgw$，区间内比 $a$ 小的数的个数为 $xlw$，则 $a$ 产生的贡献为 $rgw+(xlw+1) \times a$。$xlw$ 和 $rgw$ 显然可以树状数组预处理加莫队二次离线来计算。不会莫队二次离线的可以去做一下[这道模板题](https://www.luogu.com.cn/problem/P4887)。  
同时本题中的莫队需要一个能够 $O(\sqrt{n})$ 修改，$O(1)$ 查询的数据结构来维护，可以考虑经典的值域分块。
## 代码
这里给出一个码风良好的代码。  
```cpp
#include <iostream>
#include <algorithm>
#include <cmath>
#include <cstring>
#include <vector>
#define ll long long 
#define pb push_back
#define len2 325
using namespace std;
ll n, m, len;

struct node { ll l, r, id, ans; };
struct node2 { ll l, r, id, op; };
bool operator <(node a, node b) {
	if (a.l / len != b.l / len)return a.l < b.l;
	if ((a.l / len) & 1)return a.r < b.r;
	return a.r > b.r;
}
node g[1000025];
vector<node2> ql[1000025];
vector<node2> qr[1000025];

ll ca[1000025];
ll cb[1000025];
ll ins1(ll x, ll y) {
	while (x >= 1) { ca[x] += y; x -= x & -x; }
	return 0;
}
ll gs1(ll x) {
	ll s = 0, i = x;
	while (i <= 1000025) { s += ca[i]; i += i & -i; }
	return s;
}
ll ins2(ll x, ll y) {
	ll i = x;
	while (i <= 1000025) { cb[i] += y; i += i & -i; }
	return 0;
}
ll gs2(ll x) {
	ll s = 0;
	while (x >= 1) { s += cb[x]; x -= x & -x; }
	return s;
}

ll a[500025], ans[500025];
ll sma[500025], smb[500025], smc[500025], smd[500025];
ll L[500025], R[500025], B[500025];
ll s1[500025], s2[500025], bs1[500025], bs2[500025];

int f1(ll i) {
	sma[i] = gs1(a[i] + 1);
	smb[i] = gs2(a[i] - 1);
	ins1(a[i], a[i]);
	ins2(a[i], 1);
	return 0;

}
int f2(ll i) {
	for (ll j = B[a[i]] + 1; j <= len2; j++)s1[j]++;
	for (ll j = 1; j <= B[a[i]] - 1; j++)s2[j] += a[i];
	for (ll j = a[i]; j <= R[B[a[i]]]; j++) bs1[j]++;
	for (ll j = L[B[a[i]]]; j <= a[i]; j++)bs2[j] += a[i];
	return 0;
}

int main() {
	cin >> n >> m;
	len = n / sqrt(m);
	if (!len)len++;
	for (ll i = 1; i <= n; i++)cin >> a[i];
	for (ll i = 1; i <= m; i++) {
		cin >> g[i].l >> g[i].r;
		g[i].id = i;
	}
	sort(g + 1, g + 1 + m);
	for (ll i = 1; i <= n; i++) {
		f1(i);
		smc[i] = smc[i - 1] + sma[i] + a[i] * (smb[i] + 1);
	}
	memset(ca, 0, sizeof(ca));
	memset(cb, 0, sizeof(cb));
	for (ll i = n; i >= 1; i--) {
		f1(i);
		smd[i] = smd[i + 1] + sma[i] + a[i] * (smb[i] + 1);
	} 
	ll nl = 1, nr = 0;
	for (ll i = 1; i <= m; i++) {
		ll l = g[i].l, r = g[i].r;
		if (nr < r) qr[nl - 1].pb({ nr + 1, r, i, -1 });
		if (nl > l) ql[r + 1].pb({ l, nl - 1, i, -1 });
		if (nr > r) qr[nl - 1].pb({ r + 1, nr, i, 1 });
		if (nl < l) ql[r + 1].pb({ nl, l - 1, i, 1 });
		g[i].ans = smc[r] - smc[nr] + smd[l] - smd[nl];
		nl = l; nr = r;
	}
	for (int i = 1; i <= len2; i++) {
		L[i] = R[i - 1] + 1;
		R[i] = L[i] + len2 - 1;
		for (ll j = L[i]; j <= R[i]; j++) B[j] = i;
	}
	for (ll i = 1; i <= n; i++) {
		f2(i);
		for (auto v : qr[i]) {
			ll l = v.l, r = v.r, id = v.id, op = v.op, sum = 0;
			for (int j = l; j <= r; j++) {
				ll t = a[j];
				sum += t * (s1[B[t - 1]] + bs1[t - 1]) + (s2[B[t + 1]] + bs2[t + 1]);
			}
			g[id].ans += op * sum;
			//cout << id << " " << op * sum << endl;
		}
	}
	memset(s1, 0, sizeof(s1));
	memset(s2, 0, sizeof(s2));
	memset(bs1, 0, sizeof(bs1));
	memset(bs2, 0, sizeof(bs2));
	for (ll i = n; i >= 1; i--) {
		f2(i);
		for (auto v : ql[i]) {
			ll l = v.l, r = v.r, id = v.id, op = v.op, sum = 0;
			for (ll j = l; j <= r; j++) {
				ll t = a[j];
				sum += t * (s1[B[t - 1]] + bs1[t - 1]) + (s2[B[t + 1]] + bs2[t + 1]);
			}
			g[id].ans += op * sum;
		}
	}
	for (ll i = 1; i <= m; i++) {
		g[i].ans += g[i - 1].ans;
		ans[g[i].id] = g[i].ans;
	}
	for (ll i = 1; i <= m; i++) {
		cout << ans[i] << '\n';
	}
	return 0;
}
```

---

## 作者：cunzai_zsy0531 (赞：0)

[题面](https://www.luogu.com.cn/problem/P5501)

首先进行一个转化：每个询问区间 $[l,r]$ 中一对 $(i,j)$，如果 $a_i< a_j$ 会造成 $a_i$ 的贡献。最后再加一个区间和就是答案。

考虑这是一个区间每对数的贡献，并且具有可减性，上莫队二次离线那一套。考虑一个位置 $x$ 对一个区间 $[l,r]$ 的贡献 $f(x,[l,r])$，拆成两部分：

- $[l,r]$ 中 $< a_x$ 的数的个数为 $c$，贡献 $c\times a_x$

- $[l,r]$ 中 $> a_x$ 的数的和 $s$

两部分都是可减信息，由于莫队二次离线是 $O(n)$ 次单点修改，$O(n\sqrt m)$ 次单点查询，所以需要平衡一下复杂度，在值域上分块可以做到 $O(\sqrt V)$ 修改，$O(1)$ 查询（其中 $V$ 是值域）。总复杂度 $O(n\sqrt V+n\sqrt m+m)$。

my code~~（被机房小学弟吐槽的马蜂）~~：

```cpp
#include<cstdio>
#include<iostream>
#include<vector>
#include<cstring>
#include<algorithm>
#define memset __builtin_memset
#define pb push_back
typedef long long ll;
inline void chkmax(int &a,const int &b){if(b>a)a=b;}
const int N=5e5+13,M=5e5+13,B=1000+13,BN=400,BM=350;
int n,m,lim,tot,a[N],fromq[N],from[M],L[B],R[B],c1[M],tag1[B];
ll pre[N],c2[M],tag2[B],f[N];
struct Ques{
	int l,r,id;ll sum;
	inline bool operator <(const Ques &a)const{return fromq[l]!=fromq[a.l]?fromq[l]<fromq[a.l]:(fromq[l]&1?r<a.r:r>a.r);}
}q[N];
struct Node{int l,r,id,op;};
std::vector<Node> b[N];
ll ans[N];
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;++i) scanf("%d",&a[i]),pre[i]=pre[i-1]+a[i],chkmax(lim,a[i]);
	for(int i=1;i<=lim;++i){
		from[i]=i/BM+1;
		if(from[i]!=from[i-1]) R[tot]=i-1,L[++tot]=i;
	}
	R[tot]=lim;//注意！这个地方上限是值域！！
   //下面是预处理前缀贡献
	for(int i=1;i<=n;++i){
		f[i]=(ll)(c1[a[i]]+tag1[from[a[i]]])*a[i]+c2[a[i]]+tag2[from[a[i]]];
		for(int j=a[i]+1;j<=R[from[a[i]]];++j) ++c1[j];
		for(int j=from[a[i]]+1;j<=tot;++j) ++tag1[j];
		for(int j=a[i]-1;j>=L[from[a[i]]];--j) c2[j]+=a[i];
		for(int j=from[a[i]]-1;j>=1;--j) tag2[j]+=a[i];
	}
	for(int i=1;i<=m;++i) scanf("%d%d",&q[i].l,&q[i].r),q[i].id=i;
	for(int i=1;i<=n;++i) fromq[i]=i/BN+1;
	std::sort(q+1,q+m+1);
   //莫队，把贡献区间离线
	for(int i=1,l=1,r=0;i<=m;++i){
		if(l>q[i].l) b[r].pb((Node){q[i].l,l-1,i,1});
		while(l>q[i].l) --l,q[i].sum-=f[l];
		if(r<q[i].r) b[l-1].pb((Node){r+1,q[i].r,i,-1});
		while(r<q[i].r) ++r,q[i].sum+=f[r];
		if(l<q[i].l) b[r].pb((Node){l,q[i].l-1,i,-1});
		while(l<q[i].l) q[i].sum+=f[l],++l;
		if(r>q[i].r) b[l-1].pb((Node){q[i].r+1,r,i,1});
		while(r>q[i].r) q[i].sum-=f[r],--r;
	}
	memset(c1,0,sizeof c1);memset(c2,0,sizeof c2);memset(tag1,0,sizeof tag1);memset(tag2,0,sizeof tag2);
   //扫描线算答案，分块
	for(int i=1;i<=n;++i){
		for(int j=a[i]+1;j<=R[from[a[i]]];++j) ++c1[j];
		for(int j=from[a[i]]+1;j<=tot;++j) ++tag1[j];
		for(int j=a[i]-1;j>=L[from[a[i]]];--j) c2[j]+=a[i];
		for(int j=from[a[i]]-1;j>=1;--j) tag2[j]+=a[i];
		for(auto x:b[i])
			for(int j=x.l;j<=x.r;++j) q[x.id].sum+=x.op*((ll)(c1[a[j]]+tag1[from[a[j]]])*a[j]+c2[a[j]]+tag2[from[a[j]]]);
	}
	for(int i=1;i<=m;++i) ans[q[i].id]=(q[i].sum+=q[i-1].sum)+pre[q[i].r]-pre[q[i].l-1];
	for(int i=1;i<=m;++i) printf("%lld\n",ans[i]);
	return 0;
}
```

---

## 作者：Illusory_dimes (赞：0)

[不知道更好还是更坏的阅读体验](https://www.cnblogs.com/Illusory-dimes/p/15716972.html)

## Description

给定 n 个数和 m 次询问，每次询问给定 l ， r ，要求区间内从小到大排序后对 排名 * 数值 求和。

避免歧义，举个例子：数列 $1\ 2\ 2\ 3$ 的答案为 $1 \cdot 1 + 2 \cdot 2 + 2 \cdot 2 + 4 \cdot 3 = 21$ （前者为排名，后者为数值）

$1 \leq n,\ m \leq 5 \cdot 10 ^ 5\ \ \ 1 \leq a_i \leq 10 ^ 5$

## Analysis

因为添加一个数或删去一个数影响贡献的是一整个后缀，所以 $\log$ 的算法显得不太现实，考虑莫队。

从普通莫队开始思考，由于每次更改一个数影响的式后缀，所以树状数组是比较好的解决方式。

因为相同的数排名是一样的，所以直接维护两个东西，一个是后缀和，因为比它大的数排名全部加一了，所以新贡献就是后缀和；另一个是排名，用来找当前数的位置，也就是这个数的贡献了。整体做下来就可以完成此题了。

时间复杂度 $O(n\cdot\sqrt{m}\cdot\log a_{max})$

## Solution

很显然上述方式不能通过本题（听说原来可以但是现在加强数据了）

树状数组复杂度已经到头了，所以要从莫队方式上进行变更，考虑二次离线：

写法参照的是 [Yuno loves sqrt technology II](https://www.luogu.com.cn/problem/P5047 "Yuno loves sqrt technology II") ，维护的东西和本题树状数组的是一致的。

然后还是要预处理 $[1, l]$ 的答案和 $[r, n]$ 的答案前缀和，就可以先把更改的区间 $[r1, r2]$ 的内部的答案先算好。

但是同样要注意的是即使我们把所有操作保存下来，也还是不能直接做，我们需要进行值域分块，然后前后各扫一遍就行了。

时间复杂度 $O(n\log n + n\sqrt{n})$

### 另一个想法

其实 Solution 里面提到的那道二次离线求逆序对，每次更改一个数是对区间内所有数有影响，还不能一个一个去比较，因为它同时和位置和大小同时相关。

但是这道题不太一样的就是每个数对区间内数的贡献仅限于大小的影响，所以条件本质上是变宽松了。

甚至可以考虑只用普通莫队做这题，但是我不太会，有会的大佬求教教 qwq 。

## Code

```cpp
/*

*/
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 1e6 + 10;
ll lim, a[N], par1[N], poi1[N], par2[N], poi2[N];
int n, m, id[N], boc, blo[N], lt[N], rt[N];
int lr[N], rl[N], bel[N], lth;
ll arr1[N], arr2[N], pre[N], suf[N], ans[N];
struct mdzz {
	int op, l, r, id;
};
vector<mdzz> lp[N], rs[N];
inline int read() {
	char ch = getchar();
	int s = 0, w = 1;
	while (ch < '0' || ch > '9') {if (ch == '-') w = -1; ch = getchar();}
	while (ch >= '0' && ch <= '9') {s = (s << 3) + (s << 1) + ch - '0'; ch = getchar();}
	return s * w;
}
inline bool cmp(int x, int y) {
	return blo[x] ^ blo[y] ? lt[x] < lt[y] : rt[x] < rt[y];
}
inline int lowbit(int x) {return x & (-x);}
inline void add1(int x, int k) {
	for (; x <= lim; x += lowbit(x)) arr1[x] += k;
}
inline ll query1(int x) {
	ll tmp = 0;
	for (; x >= 1; x -= lowbit(x)) tmp += arr1[x];
	return tmp;
}
inline void add2(int x, int k) {
	for (; x <= lim; x += lowbit(x)) arr2[x] += k;
}
inline ll query2(int x) {
	ll tmp = 0;
	for (; x >= 1; x -= lowbit(x)) tmp += arr2[x];
	return tmp;
}
inline void pushup(int x) {
	if (par1[bel[x]]) {
		for (int i = lr[bel[x]]; i <= rl[bel[x]]; ++i) poi1[i] += par1[bel[x]];
		par1[bel[x]] = 0;
	}
	for (int i = x + 1; i <= rl[bel[x]]; ++i) ++poi1[i];
	for (int i = bel[x] + 1; i <= lth; ++i) ++par1[i];
	
	if (par2[bel[x]]) {
		for (int i = lr[bel[x]]; i <= rl[bel[x]]; ++i) poi2[i] += par2[bel[x]];
		par2[bel[x]] = 0;
	}
	for (int i = lr[bel[x]]; i <= x - 1; ++i) poi2[i] += x;
	for (int i = 1; i <= bel[x] - 1; ++i) par2[i] += x;
}
int main() {
	n = read(); m = read();
	boc = 316;
	for (int i = 1; i <= n; ++i) a[i] = read(), lim = max(lim, a[i]);
	for (int i = 1; i <= lim; ++i) bel[i] = (i - 1) / boc + 1;
	bel[0] = 1; bel[lim + 1] = lim / boc + 1;
	lth = bel[lim + 1];
	for (int i = 1; i <= lth; ++i) lr[i] = rl[i - 1] + 1, rl[i] = i * boc;
	lr[1] = 0; rl[lth] = lim + 1;
	for (int i = 1; i <= m; ++i) {
		lt[i] = read(); rt[i] = read(); id[i] = i; blo[i] = lt[i] / boc;
	}
	sort(id + 1, id + 1 + m, cmp);
	for (int i = 1; i <= n; ++i) {
		pre[i] = pre[i - 1] + query2(lim) - query2(a[i]); add2(a[i], a[i]);
		pre[i] += (query1(a[i] - 1) + 1) * a[i]; add1(a[i], 1);
	}
	memset(arr1, 0, sizeof(arr1)); memset(arr2, 0, sizeof(arr2));
	for (int i = n; i >= 1; --i) {
		suf[i] = suf[i + 1] + query2(lim) - query2(a[i]); add2(a[i], a[i]);
		suf[i] += (query1(a[i] - 1) + 1) * a[i]; add1(a[i], 1);
	}
	int l = 1, r = 0;
	for (int i = 1; i <= m; ++i) {
		int ql = lt[id[i]], qr = rt[id[i]];
		if (r < qr) {
			lp[l].push_back((mdzz) {-1, r + 1, qr, id[i]});
			ans[id[i]] += (pre[qr] - pre[r]); r = qr;
		}
		if (r > qr) {
			lp[l].push_back((mdzz) {1, qr + 1, r, id[i]});
			ans[id[i]] += (pre[qr] - pre[r]); r = qr;
		}
		if (l < ql) {
			rs[r].push_back((mdzz) {1, l, ql - 1, id[i]});
			ans[id[i]] += (suf[ql] - suf[l]); l = ql;
		}
		if (l > ql) {
			rs[r].push_back((mdzz) {-1, ql, l - 1, id[i]});
			ans[id[i]] += (suf[ql] - suf[l]); l = ql;
		}
	}
	int siz, lq, rq, idt; ll op;
	for (int i = 1; i <= n; ++i) { siz = lp[i].size();
		for (int j = 0; j < siz; ++j) {
			op = lp[i][j].op; idt = lp[i][j].id;
			lq = lp[i][j].l; rq = lp[i][j].r;
			for (int k = lq; k <= rq; ++k)
				ans[idt] += op * (par2[bel[a[k]]] + poi2[a[k]] + a[k] * (par1[bel[a[k]]] + poi1[a[k]]));
		}
		pushup(a[i]);
	}
	memset(par1, 0, sizeof(par1)); memset(poi1, 0, sizeof(poi1));
	memset(par2, 0, sizeof(par2)); memset(poi2, 0, sizeof(poi2));
	for (int i = n; i >= 1; --i) { siz = rs[i].size();
		for (int j = 0; j < siz; ++j) {
			op = rs[i][j].op; idt = rs[i][j].id;
			lq = rs[i][j].l; rq = rs[i][j].r;
			for (int k = lq; k <= rq; ++k)
				ans[idt] += op * (par2[bel[a[k]]] + poi2[a[k]] + a[k] * (par1[bel[a[k]]] + poi1[a[k]]));
		}
		pushup(a[i]);
	}
	for (int i = 1; i <= m; ++i) ans[id[i]] += ans[id[i - 1]];
	for (int i = 1; i <= m; ++i) printf("%lld\n", ans[i]);
	return 0;
}
```

---

## 作者：Mooncrying (赞：0)

为数不多的莫队二次离线模版题之一。

题意不再赘述，出题人讲的很清楚。

### 解题思路

- 区间无修查询问题， 考虑莫队。

- 莫队最重要的是左右指针单次移动的答案转移问题，这里我们以右指针右移为例。

	不难发现转移时我们需要求出当前区间有多少数比一个数大（小）。
    
   为了方便叙述，我们设 $C(x, [l, r])$ 表示区间 $[l, r]$ 中比 $a_x$ **小**的数的**个数**，$S(x, [l, r])$ 表示区间 $[l, r]$ 中比 $a_x$ **大**的数的**和**。
   
   转移式很好写：
   右指针右移（正贡献）：
   
   > $ans += [C(r + 1, [l, r]) + 1] \times a_{r + 1} + S(r + 1, [l, r])$
   
   还不太懂的同学可以手玩一下。
   
   这样转移的话用树状数组单次转移的时间复杂度是 $O(\log n)$ 的，总复杂度为 $O(n \sqrt{n} \log n)$，不能接受。
   
- 我们注意到 $C$ 和 $S$ 都是**可减**的，可以写成差分的形式，于是上面的式子就可以展开写成以下形式：
   
   > $ans = [C(r + 1, [1, r]) - C(r + 1, [1, l - 1]) + 1] \times a_{r + 1} + S(r + 1, [1, r]) - S(r + 1, [1, l - 1])$
   
   按照类似的方法，我们也不难得到其他三种转移的转移式：
   
   右指针左移（负贡献）：
   
   > $ans = [C(r, [1, r - 1]) - C(r, [1, l - 1]) + 1] \times a_{r} + S(r, [1, r - 1]) - S(r, [1, l - 1])$
   
   左指针左移（正贡献）：
   
   > $ans = [C(l - 1, [1, r]) - C(l - 1, [1, l - 1]) + 1] \times a_{l - 1} + S(l - 1, [1, r]) - S(l - 1, [1, l - 1])$
   
   左指针右移（负贡献）：
   
   > $ans = [C(l, [1, r]) - C(l, [1, l]) + 1] \times a_{l} + S(l, [1, r]) - S(l, [1, l - 1])$
   
   上面的式子中，形如 $C(r + 1, [1, r])$ 之类，不难得到 $C(r + 1, [1, r]) = C(r + 1, [1, r + 1])$，因为一个数不可能比它本身小嘛。$S$ 同理。这一类可以用前缀和和树状数组解决，时间复杂度为 $O(n \log n)$ 。
   
   那么剩下的形如 $C(x, [1, y])$ 的怎么办？
   
   把它们二次离线处理就好啦。直接开一个 vector 然后在对应位置 $pos$ 存下哪些数会对区间 $[1, pos]$ 产生贡献。二次离线的时候从 $1$ 到 $n$ 暴力扫一遍，把对应数的贡献加入对应的答案即可。
   
   这里我们需要一种修改 $O(\log n)$ 至 $O(\sqrt{n})$，单点询问 $O(1)$ 的数据结构，无疑值域分块时一个不错的选择，直接套上即可。
   
   注意转移式中有一个 $1 \times a_{x}$ 是消不掉的，别忘了加上。
   
   然后就做完啦。
   
 - 时间复杂度 $O(n \sqrt{n} + m \sqrt{n})$，空间复杂度 $O(n)$。
 
 - 注意开 long long。
 
 ### AC 代码
 
 ```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int N = 5e5 + 20;
int n, m, belong[N], M, cnt[N / 5], c[N / 5], a[N], block;
ll sum[N / 5], s[N / 5], S[N], Ans[N], C[N], Sum;
struct Node {
		int l, r, w, id;
}; vector <Node> Ask[N];
struct Q {
		int l, r, id; ll ans;
}q[N];
struct BIT {
		int cnt; ll sum;
}t[N / 5];
bool cmp(Q a, Q b)
{
		if(belong[a.l] != belong[b.l]) return a.l < b.l;
		return belong[a.l] & 1 ? a.r < b.r : a.r > b.r;
}
void read(int &x)
{
		int f = 1; x = 0; char ch = getchar();
		while(ch < '0' || ch > '9') { if(ch == '-') f = -1; ch = getchar(); }
		while(ch >= '0' && ch <= '9') { x = (x << 3) + (x << 1) + (ch ^ 48); ch = getchar(); }
		x *= f;
}
void write(ll x, char ch)
{
		if(x < 0) putchar('-'), x = -x;
		if(x > 9) write(x / 10, 0);
		putchar(x % 10 + '0');
		if(ch == '\n') putchar('\n');
}
void Add(int x, int k, int f)
{
		if(f == 0)
			while(x <= M) t[x].cnt += k, x += x & (-x);
		else while(x <= M) t[x].sum += (ll)k, x += x & (-x);
}
ll Query(int x, int f)
{
		ll res = 0;
		if(f == 0)
			while(x) res += t[x].cnt, x -= x & (-x);
		else while(x) res += t[x].sum, x -= x & (-x);
		return res;
}
void Insert(int l, int r, int k, int f)
{
		if(l > r) return;
		if(f == 0)
		{
			if(belong[l] == belong[r])
				for(int i = l; i <= r; ++i) cnt[i]++;
			else 
			{
				while(belong[l] == belong[l - 1]) cnt[l++]++;
				while(belong[r] == belong[r + 1]) cnt[r--]++;
				for(int i = belong[l]; i <= belong[r]; ++i) c[i]++;
			}
		}
		else
		{
			if(belong[l] == belong[r]) 
				for(int i = l; i <= r; ++i) sum[i] += k;
			else 
			{
				while(belong[l] == belong[l - 1]) sum[l++] += k;
				while(belong[r] == belong[r + 1]) sum[r--] += k;
				for(int i = belong[l]; i <= belong[r]; ++i) s[i] += k;
			}
		}
}
int main()
{
		read(n); read(m);  block = n / sqrt(m) + 1;
		for(int i = 1; i <= n; ++i) 
			read(a[i]), M = max(M, a[i]), belong[i] = (i - 1) / block + 1;
		for(int i = 1; i <= n; ++i)
		{
			Sum += a[i];
			Add(a[i], 1, 0); Add(a[i], a[i], 1);
			C[i] = Query(a[i] - 1, 0);
			S[i] = Sum - Query(a[i], 1);
		}
		for(int i = 1; i <= m; ++i)
			read(q[i].l), read(q[i].r), q[i].id = i;
		sort(q + 1, q + 1 + m, cmp);
		for(int i = 1, L = 1, R = 0; i <= m; ++i)
		{
			if(L > q[i].l) 
				Ask[R].push_back((Node){q[i].l, L - 1, 1, i});
			while(L > q[i].l) 
				q[i].ans += -S[--L] - C[L] * a[L] + a[L];
			if(R < q[i].r) 
				Ask[L - 1].push_back((Node){R + 1, q[i].r, -1, i});
			while(R < q[i].r) 
				q[i].ans += S[++R] + C[R] * a[R] + a[R];
			if(L < q[i].l) 
				Ask[R].push_back((Node){L, q[i].l - 1, -1, i});
			while(L < q[i].l) 
				q[i].ans += S[L] + C[L] * a[L] - a[L++];
			if(R > q[i].r) 
				Ask[L - 1].push_back((Node){q[i].r + 1, R, 1, i});
			while(R > q[i].r) 
				q[i].ans += -S[R] - C[R] * a[R] - a[R--];
		}
		block = sqrt(M); belong[M + 1] = 0;
		for(int i = 1; i <= M; ++i) belong[i] = (i - 1) / block + 1;
		for(int i = 1; i <= n; ++i)
		{
			Insert(a[i] + 1, M, 1, 0);
			Insert(1, a[i] - 1, a[i], 1);
			for(int p = 0; p < Ask[i].size(); ++p)
			{
				Node ask = Ask[i][p];
				for(int j = ask.l; j <= ask.r; ++j)
				{
					q[ask.id].ans += 1ll * ask.w * a[j] * (cnt[a[j]] + c[belong[a[j]]]);
					q[ask.id].ans += 1ll * ask.w * (sum[a[j]] + s[belong[a[j]]]);
				}
			}
		}
		for(int i = 1; i <= m; ++i) q[i].ans += q[i - 1].ans;
		for(int i = 1; i <= m; ++i) Ans[q[i].id] = q[i].ans;
		for(int i = 1; i <= m; ++i) write(Ans[i], '\n'); 
}
```
完结撒花~

---


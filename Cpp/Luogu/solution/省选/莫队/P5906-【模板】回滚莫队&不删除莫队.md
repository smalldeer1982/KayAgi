# 【模板】回滚莫队&不删除莫队

## 题目背景

这是一道模板题。

## 题目描述

给定一个序列，多次询问一段区间 $[l,r]$，求区间中**相同的数的最远间隔距离**。

序列中两个元素的**间隔距离**指的是**两个元素下标差的绝对值**。

## 说明/提示

记 $a_i$ 表示序列元素。

对于 $40\%$ 的数据，满足 $1\leq a_i \leq 400$，$1\leq n,m\leq 60000$。

对于 $100\%$ 的数据，满足 $1\leq n,m\leq 2\cdot 10^5$，$1\leq a_i\leq 2\cdot 10^9$。



## 样例 #1

### 输入

```
8
1 6 2 2 3 3 1 6
5
1 4
2 5
2 8
5 6
1 7```

### 输出

```
1
1
6
1
6
```

# 题解

## 作者：阔睡王子 (赞：124)

## 回滚莫队
谢邀，人在机房，刚被机惨。

你是否在处理莫队删除操作的时候经常头疼，因为有的删除操作删掉之后就更新答案，如果你把它改成次大，那么你会发现改成次大之后再删除又需要次次大......

假使如果你吃了雄心豹子胆开满空间来存，不说这样看着很鸭儿蠢，空间直接变成平方级别，时间更不说了。根据莫队的排序特性，不知道是谁反正是个人搞了这个会滚的不删除莫队。

假如你也跟我一样不会让莫队滚，那么就让我跟你一起来学习如何让这个莫队~~滚起来~~。

我不会叫它“不删除莫队”,而是会叫它“能少删点就删点莫队”。因为这个算法名字涉嫌欺骗，很多时候我们都是尽可能减少删除操作,以更多的清空，增加操作，让连续工作的莫队有了喘气的机会，能重新处理一组一组的询问而不是一直删删删来处理所有的询问。~~喂莫队你要不要这么不持久~~。这样下来删除操作会变得没那么复杂，能让你更方便的实现。

那么是怎么实现的呢？

![](https://cdn.luogu.com.cn/upload/image_hosting/2ymq1itl.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

看一看这个不知道为什么这么小的图来想一想你之前写过的莫队，对于莫队一个一个的询问，我们会让 ```L R``` 指针不断地移动，在每个询问之间反复横跳，加以不断的删除，添加操作来得出答案。

然后为了避免删除操作，我们可以想一想能不能找到几个为一组的询问中的一个公共的线段，每次就让这个公共线段的 ```L R``` 分别向左右移动来和询问的左右端点重合来得出答案，而不是删过来删过去。

这个思路就是回滚莫队的核心思路。

可能你没有很好地理解，再给你一组有序的数据的几张图来演示这个处理过程：

![](https://cdn.luogu.com.cn/upload/image_hosting/ubxn8tkr.png?x-oss-process=image/resize,m_lfit,h_170,w_225)
![](https://cdn.luogu.com.cn/upload/image_hosting/zhul5rx0.png?x-oss-process=image/resize,m_lfit,h_170,w_225)
![](https://cdn.luogu.com.cn/upload/image_hosting/au01t7u8.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

你就会发现，哇哦，居然是这么清晰。

于是我们继续想，怎么处理几个交叉，并不那么有序的询问呢？

设左端点在一个块以内的所有询问构成一组询问。

根据莫队排序后的一组询问的右端点是有序的，就先不管右端点了。

然后可知对于这一组询问，它们的左端点无序，但是都在同一个块以内。

我们可以像这样来做：

![](https://cdn.luogu.com.cn/upload/image_hosting/lak8gebm.png?x-oss-process=image/resize,m_lfit,h_170,w_225)
![](https://cdn.luogu.com.cn/upload/image_hosting/dv0csqst.png?x-oss-process=image/resize,m_lfit,h_170,w_225)
![](https://cdn.luogu.com.cn/upload/image_hosting/iwu10m78.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

我们可以让 ```L``` 停留在这组询问左端点所在块的最右方， ```R``` 不断的向右移动处理询问。对于每个询问的左端点就定义一个新的临时指针 ```p``` 和一套新的临时数组从L开始向左移动处理询问，```L``` 不变， ```p``` 处理完事后就回来，回来的路上顺手把来时存的临时数组清空。

图中黄色区间就是 ```p``` 处理的区域，剩余有色区域的都是 ```R``` 处理的(注意上图中R并非每次都回到 ```L``` 这里，而是从上一次 ```R``` 的位置开始移动，这里可能让您产生理解误差)。

而每换成另外一组询问的时候请空数组，重新设定 ```L,R``` 就行了，这就是回滚莫队了。

代码的注释也写了很多:

```
#include<cstdio>
#include<algorithm>
#include<cmath>
using namespace std;
const int maxn=2e5+10;
//以下是变量表 
int n,m,len;
//len是块的大小 
int a[maxn],b[maxn];
//a:离散化后的数组
//b:block简写,表示给定下标对应的块 
int R[maxn]; 
//每个块的右端 
int ans[maxn];
//离线操作用来存储答案 
int st[maxn],ed[maxn],ed2[maxn];
//得出答案时需要用到的桶
//代表意义分别为在给定范围内: 
//元素出现的第一个位置
//元素出现的最后一个位置
//在每组询问的公共起点(某个块的右端)前的一段中,元素出现的最后一个位置 
inline int read()
{
	int num=0;
	char ch=getchar();
	while(ch>57||ch<48)ch=getchar();
	do num=(num<<1)+(num<<3)+(ch^48),ch=getchar(); while(ch>47&&ch<58);
	return num;
}
struct lsh
{int id,x;}tmp[maxn];
bool lsh_cmp(lsh x,lsh y)
{return x.x<y.x;}
//离散化 
struct query
{int l,r,id;}q[maxn];
bool query_cmp(query x,query y)
{return (b[x.l]==b[y.l])?x.r<y.r:b[x.l]<b[y.l];}
//存储询问以及把询问排序 
void datain()//读入并处理一部分数据 
{
	n=read();
	len=sqrt(n); 
	for(int i=1;i<=n;i++)
	{
		tmp[i].x=read();
		tmp[i].id=i;
		b[i]=(i-1)/len+1;
	}
	for(int i=1;i<=b[n];i++)//处理出每个块的右端 
	R[i]=(i==b[n])?n:len*i;//记录下这个右端！ 
	m=read();
	for(int i=1;i<=m;i++)
	{
		q[i].l=read();q[i].r=read();
		q[i].id=i;
	}
	sort(q+1,q+m+1,query_cmp);
}
void lsh() 
{
	sort(tmp+1,tmp+n+1,lsh_cmp);//排序然后离散化啦 
	int pre=-1,cnt=0;//喜欢的离散化写法 
	for(int i=1;i<=n;i++)
	{
		if(tmp[i].x!=pre)cnt++;
		a[tmp[i].id]=cnt;//投射回去,让a[1]~a[n]变成离散化数组 
		pre=tmp[i].x;
	}
}
void work()//开始处理询问 
{
	int block=0,tmp1=0,l=0,r=0;
	//block:块,代表上次询问左端点在哪个块
	//如果块一样我们就可以直接使用上次留下来的进程 
	//不一样就舍弃上次的进程,全部推翻
	//tmp1:在公共L到上一次询问R时得出的答案
	//l:公共L
	//r:上一次询问的R 
	for(int i=1;i<=m;i++)
	{
		if(b[q[i].l]==b[q[i].r])
		//如果是同一个块就没有什么好说的了 
		//你的莫队技巧全部木大,还不如暴力求解，时间复杂度不会退化 
		{
			tmp1=0;
			for(int j=q[i].l;j<=q[i].r;j++)st[a[j]]=0;
			//你只需要用到st，就只清空st
			//诶你可能会想:st清空了,l,r没动,那后面求解不就乱套了？ 会不会调用到错误的st 
			//不会的
			//你想一想，询问左右端点变成在一个块时,是什么时候
			//是左端点所在块已经不同于之前的块的时候啊! 
			//是你前面求出的tmp1,st,ed已经失去利用价值的时候啊! 
			//肯定后面需要清空(摈弃)之前的数组，开始解新一组的询问
			//那么之后的l,r,st,肯定会清空掉 
			//总而言之：我这里清空st,根本就不影响之后啊哈哈哈哈哈反正都会清空 
			//听不懂就算了... 
			for(int j=q[i].l;j<=q[i].r;j++)
			{		
				if(!st[a[j]])st[a[j]]=j;
				tmp1=max(tmp1,j-st[a[j]]);
			}
			for(int j=q[i].l;j<=q[i].r;j++)st[a[j]]=0;
			ans[q[i].id]=tmp1;
			continue ;
		}
		//要开始正常求解了 
		int now=b[q[i].l];//先记录下左端点所在的块，偷懒嗷 
		if(block!=now)//左端点所在块发生变化了 
		{
			tmp1=0;
			for(int j=l;j<=r;j++)st[a[j]]=ed[a[j]]=0;//之前求解的玩意儿都不要了,这里没用 
			//从头开始算 
			l=R[now];
			r=l-1;//莫队细节：记得r=l-1； 
			block=now;//更新所在块 
		}
		while(r<q[i].r)
		{
			r++;
			if(!st[a[r]])st[a[r]]=r;//st(start:元素第一次出现的位置)只需要更新一次 
			ed[a[r]]=r;//从前移向后,ed(end:元素最后出现的位置)要一直更新 
			tmp1=max(tmp1,r-st[a[r]]);//更新答案 
		}
		//公共左端点到r的答案处理出来了,你还记得前面的有一小端还没有算吗 
		int p=l,tmp2=0;
		while(q[i].l<p)
		{
			p--;
			if(!ed2[a[p]])ed2[a[p]]=p;//从后向前移动,ed更新一次就够了嗷 
			//防止想怎么撤回想出脑膜炎,直接开个临时数组记录一下新的ed就行 
			tmp2=max(tmp2,max(ed[a[p]],ed2[a[p]])-p);//细节:记得取个max,你公共左端点右边也可能出现这个元素 
		}
		while(p<l)//算完了就撤回 
		{
			ed2[a[p]]=0;
			p++;
		}
		ans[q[i].id]=max(tmp2,tmp1);//在公共左端点左右答案中取个max 
	}
}
int main()
{
	datain(); 
	lsh();
	work();
	for(int i=1;i<=m;i++)printf("%d\n",ans[i]);
}
```


---

## 作者：yuzhechuan (赞：110)

感觉并不用特意去卡常啊，只要不滥用memset就能轻松地跑很快了

还有话说虽然这是道模板题，但我觉得[AT1219 歴史の研究](https://www.luogu.com.cn/problem/AT1219)可能才是更多人的回滚莫队模板题

---

### 题解：

传统莫队众所周知有两个操作：增和减

增的操作一般情况下都是好做的，但减就不一定了

例如本题，想要删最左边界的话，就要知道次左边界，然后又依次类推，这就不是“优雅的暴力”了

而回滚莫队就是解决这种问题的利器，大致思想是利用更多的增操作代替减操作

也就是我们现在要构造出一种方案，复杂度有保障的情况下，使得l指针和r指针都能（尽量）一直往自己的正方向走

r指针很好解决，排序时将询问的r边界按从小到大排就好了

l指针呢，运用分块的思想我们可以将l边界在同一块中的询问排序排在一起以便一起处理，具体的处理方法就是不断地将l指针拉回块的右边界，拉到询问的位置，拉回块的右边界，拉到询问的位置。。。

稍微总结一下：分块莫队就是将左边界在同一块中的询问放在一起处理，r指针可以通过排序实现单调移动，而l指针可以不断地拉回当前块的右边，再对于每个询问单调地向左移动（脑补反复横跳），由于块的大小是根号的，因此对于一次询问，l指针的移动始终不会超过根号次。另外有些询问可能左右边界是在同一块中的，这时我们就可以暴力遍历一遍，反正长度不会超过根号嘛

---

让我们来看下这道题的具体情况：

我们记左指针为$l$，右指针为$r$，当前块的右边界（分界线）为$mid$，$[l,mid]$为左区间，$[mid,r]$为右区间

然后答案会有三种情况出现：

1. 答案完全在左区间中

1. 答案完全在右区间中

1. 答案一部分在左区间中，一部分在右区间中

注意到答案的右端点是单调的，因此取个max即可，与当前扫到的下标减一减就解决了情况1和3

对于情况2，我们要额外记录一个值，记录一个数在右区间中第一次出现的位置

假如max也在右区间中，减一减，就得到了情况2的答案

---

然后简单讲一下清空桶的方法

用暴力的memset肯定是不优秀的，因为有许多冗余操作（他都没赋过值，你为啥要清空？），为了避免这些冗余，我们可以开个数组记录下我们曾经对哪些桶做过修改，最后在遍历下这个数组将那些曾经被修改过的桶赋回0就好了，而记录数组的清空只要$O(1)$就好了

---

### 代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
template<class t> inline t read(t &x){
	char c=getchar();bool f=0;x=0;
	while(!isdigit(c)) f|=c=='-',c=getchar();
	while(isdigit(c)) x=(x<<1)+(x<<3)+(c^48),c=getchar();
	if(f) x=-x;return x;
}
template<class t> inline void write(t x){
	if(x<0) putchar('-'),write(-x);
	else{if(x>9) write(x/10);putchar('0'+x%10);}
}

const int N=2e5+5;
int un,n,m,a[N],ANS[N],ma[N],b[N],bn,num[N],st[N],cn,clear[N];
//变量的解释下面的代码中都有哦！！！
struct que{
	int l,r,i;
	inline bool operator < (const que &nt) const {
		return (b[l]^b[nt.l])?b[l]<b[nt.l]:r<nt.r; //先按左边界所在块排，相同时再按右边界排
	}
}q[N];

inline int max(const int &x,const int &y){
	return x>y?x:y;
}

int calc(int l,int r){ //暴力扫一遍
	int last[N],res=0;
	for(int i=l;i<=r;i++) last[a[i]]=0; //记录每个数最早出现的位置
	for(int i=l;i<=r;i++) if(!last[a[i]]) last[a[i]]=i; else res=max(res,i-last[a[i]]);
	return res;
}

signed main(){
	read(n);
	int len=sqrt(n); //块长
	for(int i=1;i<=n;i++) num[i]=read(a[i]),b[i]=(i-1)/len+1; //b记录每个下标是在哪个块中的
	bn=b[n]; //块数
	sort(num+1,num+1+n);
	un=unique(num+1,num+1+n)-num-1;
	for(int i=1;i<=n;i++) a[i]=lower_bound(num+1,num+1+un,a[i])-num; //正常的离散操作
	read(m);
	for(int i=1;i<=m;i++){
		read(q[i].l);read(q[i].r);
		q[i].i=i;
	}
	sort(q+1,q+1+m); //询问排序
	for(int i=1,j=1;j<=bn;j++){ //i枚举询问,j枚举询问的左边界所在块
		int br=min(n,j*len),l=br+1,r=l-1,ans=0; //br是当前块的右边界
		cn=0; //清空记录数组的指针
		for(;b[q[i].l]==j;i++){ //枚举当前块内的询问
			if(b[q[i].r]==j){ //如果左右边界都在同一块内内就暴力做
				ANS[q[i].i]=calc(q[i].l,q[i].r);
				continue;
			}
			while(r<q[i].r){
				r++;
				ma[a[r]]=r; //最后出现的位置
				if(!st[a[r]]) st[a[r]]=r,clear[++cn]=a[r]; //st是最早出现的位置，clear是出现过的数字，用来清空数字最后出现的位置
				ans=max(ans,r-st[a[r]]); //情况2
			}
			int tp=ans; //先保存一下，因为右区间的贡献不会被刷新，但左区间的会
			while(l>q[i].l){
				l--;
				if(ma[a[l]]) ans=max(ans,ma[a[l]]-l);
				else ma[a[l]]=l; //最后出现的位置可能在左区间中
			}
			ANS[q[i].i]=ans;
			while(l<=br){
				if(ma[a[l]]==l) ma[a[l]]=0; //去掉左区间的贡献
				l++;
			}
			ans=tp; //去掉当前左区间的贡献
		}
		for(int i=1;i<=cn;i++) ma[clear[i]]=st[clear[i]]=0; //根据记录数组清空每个数出现位置的各种信息
	}
	for(int i=1;i<=m;i++) write(ANS[i]),puts("");
}
```

---

## 作者：qwaszx (赞：60)

讲道理这题其实不用回滚莫队(

使用普通莫队维护每种颜色的左端点和右端点，预处理出每一个位置的同颜色前驱后继，这样就可以方便地莫队转移.

然后考虑查询，有$O(m\sqrt{n})$次插入删除和$O(m)$次询问最大值，值域分块即可.

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<vector>
using namespace std;
const int N=6e5;
int n,m,s[N],ss[N],bl[N],blo,a[N],cur[N],tmp[N],ans[N],pre[N],nxt[N];
pair<int,int>w[N];
struct Q{int l,r,id;}q[N];
int cmp(const Q &a,const Q &b){return bl[a.l]==bl[b.l]?((bl[a.l]&1)?a.r<b.r:a.r>b.r):a.l<b.l;}
void upd(int x,int w){s[x]+=w,ss[bl[x]]+=w;}
int query()//值域分块
{
	for(int i=bl[n];i>=1;i--)
		if(ss[i])
		{
			int L=(i-1)*blo,R=min(n,i*blo);
			for(int j=R;j>L;j--)if(s[j])return j;
		}
	return 0;
}
void addr(int i)
{
	int x=a[i];
	if(!w[x].first){w[x].first=w[x].second=i;return;}
	upd(w[x].second-w[x].first,-1);
	w[x].second=i;
	upd(w[x].second-w[x].first,1);
}
void addl(int i)
{
	int x=a[i];
	if(!w[x].first){w[x].first=w[x].second=i;return;}
	upd(w[x].second-w[x].first,-1);
	w[x].first=i;
	upd(w[x].second-w[x].first,1);
}
void dell(int i)
{
	int x=a[i];
	if(w[x].first==w[x].second){w[x].first=w[x].second=0;return;}
	upd(w[x].second-w[x].first,-1);
	w[x].first=nxt[w[x].first];
	upd(w[x].second-w[x].first,1);
}
void delr(int i)
{
	int x=a[i];
	if(w[x].first==w[x].second){w[x].first=w[x].second=0;return;}
	upd(w[x].second-w[x].first,-1);
	w[x].second=pre[w[x].second];
	upd(w[x].second-w[x].first,1);
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)scanf("%d",a+i),tmp[i]=a[i];
	sort(tmp+1,tmp+n+1);for(int i=1;i<=n;i++)a[i]=lower_bound(tmp+1,tmp+n+1,a[i])-tmp;
	for(int i=1;i<=n;i++)pre[i]=cur[a[i]],cur[a[i]]=i;
	for(int i=1;i<=n;i++)cur[i]=n+1;
	for(int i=n;i>=1;i--)nxt[i]=cur[a[i]],cur[a[i]]=i;
	blo=sqrt(n);for(int i=1;i<=n;i++)bl[i]=(i-1)/blo+1;
	scanf("%d",&m);
	for(int i=1;i<=m;i++)scanf("%d%d",&q[i].l,&q[i].r),q[i].id=i;
	sort(q+1,q+m+1,cmp);
	int l=1,r=0;
	for(int i=1;i<=m;i++)
	{
		while(r<q[i].r)addr(++r);
		while(l>q[i].l)addl(--l);
		while(r>q[i].r)delr(r--);
		while(l<q[i].l)dell(l++);
		ans[q[i].id]=query();
	}
	for(int i=1;i<=m;i++)printf("%d\n",ans[i]);
	return 0;
}
```

不过跑得没有回滚莫队快(

---

## 作者：Treaker (赞：24)

- ## 吐槽

  之前只是知道回滚莫队，无意间发现有这么一道模板题，就来做一做。~~由于思想不够成熟，并且没有码过类似的代码，提交差点就刷屏了。~~

  感觉这道题有点卡常，~~可能是本人常数太大了。~~

- ## 前置知识

  莫队。

- ## 题解

  我们考虑普通莫队修改的时候，会存在一些操作时间复杂度爆炸的情况。而这些操作往往只存在一种，即添加容易删除难，或者删除容易添加难。~~添加容易删除容易的情况，直接莫队不就好了么（光速逃）~~。

  在这里，我们只考虑添加容易删除难的情况。（因为本题就是这种情况）。

  那么我们只让他添加。就是，只让左端点往左扫，右端点往右扫。

  还是跟普通莫队一样，把询问离线，然后还是按照左端点所在的块排序，左端点所在的块相同的，按照右端点从小到大排序。这样可以保证时间复杂度为$n\sqrt n$。

  那么具体的情况我们可以分成两种：

  1. 如果这个询问的左右端点在同一个块，那么我们可以直接暴力扫，时间复杂度不会退化。
  2. 不在同一个块的，根据之前的排序，保证了左端点为同一个块时右端点的单调递增，这时我们只需要让左端点可以一直往左扫。怎么做呢？暴力一点，每次把左端点赋成所在块的右端点+1，然后一直往左扫，单次扫的时间复杂度为$\sqrt n$，时间复杂度仍然可以保证，~~可能常数会变大~~。

- ## 代码

那么这道题就这样做就可以了。贴上丑陋的代码（第一次写，显得代码有些青涩，为了卡常还写了fread和fwrite）：

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <queue>
#include <cmath>
typedef long long ll;
namespace IO
{
	char buf[1 << 20 |1] , *f1 = buf , *f2 = buf , pbuf[1 << 24 | 1] , *f3 = pbuf , sta[1 << 10 | 1];
	#define gc() ((f1 == f2) && (f2 = (f1 = buf) + fread(buf,1,sizeof buf,stdin),f1 == f2) ? EOF : *f1 ++)
	#define gt() getchar()
	inline int read()
	{
		int x = 0 , f = 1;	char ch = gc();
		while(ch < '0' || ch > '9')	{if(ch == '-')	f = -1; ch = gc();}
		while(ch >= '0' && ch <= '9') {x = (x << 3) + (x << 1) + (ch ^ 48); ch = gc();}
		return x * f;
	}
	inline void write(int x)
	{
		if(!x) return (void)(*f3 ++ = 48 , *f3 ++ = '\n');
		if(x < 0) *f3 ++ = '-' , x = ~x + 1;
		char *top = sta;
		while(x) *top ++ = x % 10 + 48 , x /= 10;
		while(top != sta) *f3 ++ = *-- top;
		*f3 ++ = '\n';
	}
	#define flush() fwrite(pbuf,1,f3 - pbuf,stdout)
	template <class T> inline T max(T a,T b) { return a > b ? a : b;}
	template <class T> inline T min(T a,T b) { return a < b ? a : b;}
	template <class T> inline void swap(T &a,T &b) { T t = a; a = b; b = t;}
	template <class T> inline T abs(T a) { return a < 0 ? -a : a;}
}
using namespace IO;
const int N = 2e5 + 5 , inf = 2e9;
int n , m , cnt , len , res , ansl , ansr , ans;
int a[N] , b[N] , pos[N] , pre[N] , nxt[N] , Ans[N] , L[N] , R[N] , Pre[N] , Nxt[N];
struct Query 
{ 
	int l , r , id;
	friend bool operator < (const Query &a,const Query &b) { return pos[a.l] < pos[b.l] || (pos[a.l] == pos[b.l] && a.r < b.r);}
} e[N];
inline void clear(int l,int r) 
{
	for(int i = l;i <= r;i ++) Pre[a[i]] = inf , Nxt[a[i]] = 0; res = 0;
}
inline void The_Same(int l,int r)
{
	for(int i = l;i <= r;i ++)
	{
		Pre[a[i]] = min(Pre[a[i]],i);
		Nxt[a[i]] = max(Nxt[a[i]],i);
		res = max(res,Nxt[a[i]] - Pre[a[i]]);
	}
}
inline void add(int x,int &res)
{
	pre[a[x]] = min(pre[a[x]],x);
	nxt[a[x]] = max(nxt[a[x]],x);
	res = max(res,nxt[a[x]] - pre[a[x]]);
}
inline void clearl(int l,int r)
{
	for(int i = l;i <= r;i ++) pre[a[i]] = Pre[a[i]] , nxt[a[i]] = Nxt[a[i]];
	ansl = 0;
}
inline void clearr(int l,int r)
{
	for(int i = l;i <= r;i ++) pre[a[i]] = inf , nxt[a[i]] = 0; 
	ansr = 0;
}
inline void Give(int l,int r)
{
	for(int i = l;i <= r;i ++) Pre[a[i]] = pre[a[i]] , Nxt[a[i]] = nxt[a[i]]; 
	ansl = 0;
}
int main()
{
	n = read(); len = sqrt(n);
	for(int i = 1 ; i <= n ; i ++) b[i] = a[i] = read() , pos[i] = (i - 1) / len + 1 , L[i] = inf;
	std::sort(b + 1,b + 1 + n);
	cnt = std::unique(b + 1,b + 1 + n) - b - 1;
	for(int i = 1 ; i <= n ; i ++) a[i] = std::lower_bound(b + 1,b + 1 + cnt,a[i]) - b , L[pos[i]] = min(L[pos[i]],i) , R[pos[i]] = max(R[pos[i]],i) , Pre[i] = pre[i] = inf;
	m = read();
	for(int i = 1 ; i <= m ; i ++) e[i].l = read() , e[i].r = read() , e[i].id = i;
	std::sort(e + 1,e + 1 + m); e[0].l = 0; R[0] = inf;
	for(int i = 1 , l , r = 0; i <= m ; i ++)
	{
		if(pos[e[i].l] != pos[e[i - 1].l]) clearr(R[pos[e[i - 1].l]] + 1,r) , l = R[pos[e[i].l]] + 1 , r = R[pos[e[i].l]];
		if(pos[e[i].l] == pos[e[i].r]) clear(e[i].l,e[i].r) , The_Same(e[i].l,e[i].r) , Ans[e[i].id] = res;
		else
		{
			l = R[pos[e[i].l]] + 1;
			while(r < e[i].r) add(++ r,ansr);
			Give(e[i].l,R[pos[e[i].l]]);
			while(l > e[i].l) add(-- l,ansl);
			Ans[e[i].id] = max(ansl,ansr);
			clearl(e[i].l,R[pos[e[i].l]]);
		}
	}
	for(int i = 1;i <= m;i ++) write(Ans[i]);
	flush();
	return 0;
}
```



---

## 作者：Ireliaღ (赞：22)

## 前言

之前研究怎么用莫队搞区间众数，也就是区间缩小难以更新的问题时自己发明了出来，也就是无删除莫队。今天才知道这东西的学名叫做回滚莫队，看来我还是读书少……

## 前置知识

莫队算法

既然是个模板题那我还是讲一下普通的莫队。

莫队解决的是**需要记录每一个数在区间内的信息**的问题，也就是**需要“开桶”**的一类问题。

比如一个简单的问题：区间内出现了多少种数字。

我们开一个数组`cnt[i]`，记录$i$出现的次数。显然，我们如果已经得到了$[l, r]$的`cnt`数组，我们可以$O(1)$得到$[l, r + 1]$、$[l, r - 1]$、$[l + 1, r]$、$[l - 1, r]$的`cnt`数组，只需要将变化的数`++`或`--`就可以了。

那么我们如果这样的话，两次询问之间，端点移动的复杂度最坏$O(n)$。所以我们需要合理安排询问的顺序，优化复杂度。

我们把长度为$n$的这个序列平均分为$\sqrt n$块，然后根据这些块对询问排序。具体操作是这样的：

1. 如果两个询问的左端点$l$不在同一个块内，那么让左端点的块编号小的在前面。

2. 如果两个询问的左端点$l$在同一个块内，那么如果这个块的编号为奇数，让右端点降序，否则让右端点升序。

这样，它的总复杂度是$n \sqrt n$的，证明很显然，直接理解一下。

1. 左端点要么在同一个块左右溜达，要么就会串到相邻的块，每次复杂度$O(\sqrt n)$

2. 对于左端点在同一个块内的询问，右端点的移动是单向的。由于我们只有$\sqrt n$块，所以右端点只会遍历$\sqrt n$次整个序列，总复杂度$O(n \sqrt n)$

## 本题解法

这道题我们沿用刚才的莫队思路，开桶存储当前区间每一个数最大的下标和最小的下标。

当我们`l--`或者`r++`的时候，我们可以很容易更新这个数组，取`min`/`max`就可以了

但是当我们`l++`或者`r--`的时候，我们难以去掉它的贡献，因为我们并不知道次大的贡献是谁，或者是这个贡献出现了几次。

这样我们就需要用一些技巧，让这个区间只会扩大，不会缩小。

首先我们先把普通莫队的第二条改一下：左端点在同一个块内，右端点升序。这样可以保证在同一个块内右端点只会造成区间扩大。虽然在左端点来到新的块时需要一路跑回来（其实无删除莫队并不会），常数$\times 2$，但是并不会影响复杂度。

我们考虑记录$nowr = r$，$nowl = \text{块的右端点}$的答案，临时存储下来。每次左端点只往左挪，更新桶，回答完问题再挪回来，删除桶中贡献，再把答案替换回刚刚临时存储的答案。虽然常数$\times 2$，但是并不会影响复杂度。

具体怎么做可以看代码实现。

## 代码

这题比较卡常，所以用了`umap`和快读……

需要离散化。

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <map>
#include <tr1/unordered_map>
#include <cmath>

using namespace std;
const int INF = 0x3f3f3f3f;
const int MAXN = 4e5 + 5;

int gc() {
	static char buf[100000], *p1 = buf, *p2 = buf;
	return (p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 100000, stdin), p1 == p2)) ? EOF : *p1++;
	//return getchar();
}

int geti() {
    char ch = gc();
    int f = 1, x = 0;
	while (ch < '0' || ch > '9') f = (ch == '-' ? -1 : 1), ch = gc();
	while (ch >= '0' && ch <= '9') x = x * 10 + ch - '0', ch = gc();
	return f * x;
}

void wri(int x) {
	if (x > 9) wri(x / 10);
    putchar(x % 10 + '0');
}

int n, m, N;
int a[MAXN];
int b[MAXN];
tr1::unordered_map<int, int> ref;

struct Query{
	int l, r, id;
};

Query qs[MAXN];
int ans[MAXN];
int min1[MAXN], min2[MAXN], max1[MAXN], max2[MAXN], min3[MAXN], max3[MAXN];
int res1, res2, res3;
int block, blo[MAXN];

int Comp(Query a, Query b) {
	if (blo[a.l] != blo[b.l]) return a.l < b.l;
    return a.r < b.r;
}

void Prework() {
	for (int i = 1; i <= n; i++) b[i] = a[i];
	sort(b + 1, b + n + 1);
	for (int i = 1; i <= n; i++) {
		if (!ref[b[i]]) ref[b[i]] = ++N;
	}
	for (int i = 1; i <= n; i++) b[i] = ref[a[i]];
	//------
	block = sqrt(n);
	for (int i = 1; i <= n; i++) blo[i] = (i - 1) / block + 1;
}

void AddR(int i) {
	min2[b[i]] = min1[b[i]] = min(min1[b[i]], i);
	max2[b[i]] = max1[b[i]] = max(max1[b[i]], i);
	res2 = res1 = max(res1, max1[b[i]] - min1[b[i]]);
}

void AddL(int i) {
	min2[b[i]] = min(min2[b[i]], i);
	max2[b[i]] = max(max2[b[i]], i);
	res2 = max(res2, max2[b[i]] - min2[b[i]]);
}

void Del(int i) {
	min2[b[i]] = min1[b[i]];
	max2[b[i]] = max1[b[i]];
	res2 = res1;
}

void CaptainMo() {
	int nl = 1, nr = 0, nb = 0, nbr = 0;
	memset(min1, 0x3f, sizeof(min1));
	memset(min2, 0x3f, sizeof(min2));
	memset(min3, 0x3f, sizeof(min3));
	sort(qs + 1, qs + m + 1, Comp);
	for (int i = 1; i <= m; i++) {
		int l = qs[i].l, r = qs[i].r, id = qs[i].id;
		if (blo[r] - blo[l] < 2) {
			for (int j = l; j <= r; j++) {
				min3[b[j]] = min(min3[b[j]], j);
				max3[b[j]] = max(max3[b[j]], j);
				res3 = max(res3, max3[b[j]] - min3[b[j]]);
			}
			ans[id] = res3;
			for (int j = l; j <= r; j++) min3[b[j]] = INF, max3[b[j]] = 0;
			res3 = 0;
			continue;
		}
		if (blo[l] != nb) {
			for (int j = 1; j <= N; j++) {
				min1[j] = INF;
				min2[j] = INF;
				max1[j] = 0;
				max2[j] = 0;
			}
			res1 = res2 = 0;
			nb = blo[l];
			nbr = min(nb * block, n);
			nr = nbr;
			nl = nr + 1;
		}
		while (nr < r) AddR(++nr);
		while (nl > l) AddL(--nl);
		ans[id] = res2;
		while (nl <= nbr) Del(nl++);
		res2 = res1;
	}
}

int main() {
    n = geti();
	for (int i = 1; i <= n; i++) a[i] = geti();
	m = geti();
	for (int i = 1; i <= m; i++) {
		qs[i].id = i;
		qs[i].l = geti(); qs[i].r = geti();
	}
	Prework();
	CaptainMo();
	for (int i = 1; i <= m; i++) {
		printf("%d\n", ans[i]);
		//wri(ans[i]);
		//putchar('\n');
	}
	return 0;
}
```

---

## 作者：KazamiHina (赞：14)

回滚莫队。。其实不算啥很牛逼的黑科技吧。   

本文的宗旨是用简洁的语言将回滚莫队讲的透彻，希望大家看完这篇题解能搞明白回滚莫队。   

和普通的莫队一样，回滚莫队的第一步自然就是排序。  

我们对所有询问按照一下规则排序：    

- 若左端点所属块的编号不相同，则按左端点所属块的编号较小的排在前面。   

- 若左端点所属块的编号相通，则让右端点小的排在前面。 

接着就是回滚莫队算法的核心：  

我们枚举当前处理的询问的左端点的块的编号，

如果现在的询问的右端点也在这个块内，直接暴力做就好了。 

否则我们设当前询问是 $[l1,r1]$，下一个询问是$[l2,r2]$，当前块的左端点是 $bl$，右端点是 $br$。 

因为经过了排序，所以就是这样的情况。  

```
|..|..|....bl l1, l2（l2 不一定在 l1 后面） br ...  r1 ... r2 |...|...... 
```
我们设一个莫队指针 $p$，$p$ 的初始值是 $br$，因为保证了右端点升序，所以到第二个询问的时候一定包含了 $[br,r1]$ 这段信息，$p$ 指针直接往右移直到 $r2$ 就好了。   

同时还有前半段信息就是 $[l,br]$ 这一段，我们每次设一个指针 $p1$，初始值为 $br$，一直移动到 $l$，接着把这段贡献加上，再重新移动回 $br$ 把这段贡献撤销掉就好了。  

如果块长是 $\sqrt{n}$ 的话整个算法的复杂的是 $O(n\sqrt{n})$，这里简要证明一下：  

因为有 $\sqrt{n}$ 个块，所以枚举左端点是 $O\sqrt{n}$ 的。    

然后一直走相当于 $O(n)$, 从 $br$ 走回询问左端点在一个块内，是 $O(\sqrt{n})$ 的。  

综合一下就是 $O(n \sqrt{n})$。 

另外此题轻微卡常，有一个小技巧就是把所有出现过的数单独用一个数组存下来，清空的时候清空这个数组里的数就行了，实测飞快。  



---

## 作者：wxqwq (赞：6)

这是一个根号分治的题解。以下把相同数值称为同一个颜色。

首先考虑暴力。

暴力一：对于每询问暴力枚举每种颜色，计算这个颜色在区间内最左边和最右边出现的位置，然后贡献答案。

暴力二：把询问离线，扫描右端点 $r$，对于新加入的数值 $a_r$，我们暴力枚举在这之前和他相同的位置 $p$，那么对于所有 $R\ge r，L\le p$ 的询问 $[L,R]$，我们都可以用 $r-p$ 对答案产生贡献。记 $val_p = r-p$，询问就是查询当前一个后缀区间内 $val$ 的最大值。可以使用某种数据结构支持单点修改以及区间查询。

注意到暴力一的复杂度跟颜色数量有关，而暴力二的复杂度跟每种颜色出现次数的平方有关，这启发我们对颜色进行根号分治。

对于出现次数大于等于 $\sqrt n$ 次的颜色使用暴力一，对于出现次数小于 $\sqrt n$ 次的颜色使用暴力二。

那么算法一的总复杂度为 $O(n\sqrt n + m\sqrt n)$。实现的时候可以把询问离线，然后对于每个颜色从 $1$ 到 $n$ 扫一遍处理询问。

算法二最多会有 $O(n\sqrt n)$ 次修改，查询次数为 $O(m)$。于是使用 $O(1)-O(\sqrt n)$ 的分块把复杂度摊掉，修改 $p$ 位置的时候仅仅修改 $val_p$ 和他所在块内的最大值，查询的时候枚举之后的每个整块和当前块内的值。那么复杂度为 $O(n\sqrt n + m\sqrt n)$。

最后时间为 $O(n\sqrt n + m\sqrt n)$，空间复杂度为 $O(n+m)$。

Code:
```cpp

#define pb push_back
#define rep(i,a,b) for(int i=(a);i<=(b);i++)
#define per(i,a,b) for(int i=(a);i>=(b);i--)

const int N=2e5+10,LEN=500;

int n,m,B;
int a[N],nums[N],ncnt[N],cnt;
int nxt[N];
int bl[LEN],id[N],val[N];
vector<int> pos[N];
vector<PII> q[N];
int ans[N];

// 分块修改&查询
void mdf(int pos,int v) {val[pos]=v; bl[id[pos]]=max(bl[id[pos]],v);}
int qry(int l,int r) {
	int res=0;
	for(int i=id[l]+1;i<=id[r];i++) res=max(res,bl[i]);
	for(int i=l;id[i]==id[l];i++) res=max(res,val[i]);
	return res;
}

int main()
{
	n=read();
	rep(i,1,n) a[i]=read(),nums[++cnt]=a[i];
	sort(nums+1,nums+1+cnt),cnt=unique(nums+1,nums+1+cnt)-nums-1;
	rep(i,1,n) a[i]=lower_bound(nums+1,nums+1+cnt,a[i])-nums,ncnt[a[i]]++;
	
	m=read(),B=sqrt(n);
	for(int i=1,l,r;i<=m;i++) l=read(),r=read(),q[r].pb({l,i});
	// 处理出现次数多的数
	for(int x=1;x<=n;x++) if(ncnt[x]>=B) {
		int pre=0;
		for(int i=1;i<=n;i++) nxt[i]=n+1;
		for(int i=1;i<=n;i++) {
			if(a[i]==x) {
				for(int j=i;j>pre;j--) nxt[j]=i;
				pre=i;
			}
			for(PII t:q[i]) ans[t.y]=max(ans[t.y],pre-nxt[t.x]);
		}
	}
	
	// 处理出现次数少的数
	for(int i=1;i<=n;i++) id[i]=(i-1)/B+1;
	for(int i=1;i<=n;i++) {
		if(ncnt[a[i]]<B) {
			for(int t:pos[a[i]]) mdf(t,i-t);
			pos[a[i]].pb(i);
		}
		for(PII t:q[i]) ans[t.y]=max(ans[t.y],qry(t.x,i));
	}
	rep(i,1,m) printf("%d\n",ans[i]);
	
	return 0;
}

```

---

## 作者：Caicz (赞：6)

### [题目链接](https://www.luogu.com.cn/problem/P5906)

------------
#### 关于回滚莫队
~~你需要先学会莫队~~,我们做**静态区间问题**时有时候会遇到这种情况
> 给你一个序列，你需要维护序列的某个东西，但是对于这个东西，每次加入很好维护，但删除很难维护

那么我们就需要用到回滚莫队了

#### 具体实现
>> 1. 将序列以左端点的块的下标为第一关键词，右端点的下标为第二关键词排序（注意不要用莫队的奇偶排序优化）
>> 2. 排序后，对于询问 $[ql,qr]$ 如果 $block[ql]=block[qr] $ 那么我们直接暴力枚举从 $l$ 到 $r$,时间复杂度为$O(\sqrt n)$
>> 3. 如果 $l$ 移动到了下一个块，我们对 $l,r$ 进行初始化，将 $l$ 转移为 $R[block[l]]+1$ ,将 $r$ 转移为 $R[block[r]]$ 
>> 4. 我们先将 $r$ 右移至 $qr$ 并加入期间每一个数，再将 $l$ 左移至 $ql$ 并加入
>> 5. 最后再将 $l$ 回滚回初始化时的位置
>> 6. 显而易见，复杂度为$O(m\sqrt n)$

#### 关于本题

在本题中，我们需要记录的是两个值相同的点的最远距离，那么这个答案区间总共有三种情况:
>> 1. 全在右区间
>> 2. 全在左区间
>> 3. 横跨中点(初始化时的 $l$ )

对于 2,3 两种情况，我们只需要对于每个值记录一个最大下标，再每次相减即可；而对于第 1 种情况，我们则单独记录一个右区间最小下标即可

#### 一些细节

对于每次回滚/初始化，我们不用memset清空数组(事实上这样会超时)，而是直接在移动时判断当前点是否为最大/最小下标来进行清空
$$
\large\text{Talk is cheap , show you the code}
$$
```cpp
#include<touwenjian.h>
using namespace std;
typedef long long ll;
const int maxn=200005;
const int inf=0x3f3f3f3f;
int n,m,a[maxn],b[maxn];
int block[maxn],R[maxn];
int ans[maxn],ma[maxn],mi[maxn];
struct question
{
	int l,r,id;
}q[maxn];

inline void read(int &num)
{
	int sign=1;
	char c;
	while((c=getchar())<'0'||c>'9')
		if(c=='-')sign=-1;
	num=c-'0';
	while((c=getchar())>='0'&&c<='9')
		num=(num<<1)+(num<<3)+c-'0';
	num*=sign;
}

bool cmp(const question &x,const question &y)
{
	return block[x.l]^block[y.l]?block[x.l]<block[y.l]:x.r<y.r;
}

signed main(void)
{
	freopen("text.in","r",stdin);
	read(n);
	for(register int i=1;i<=n;++i)read(a[i]),b[i]=a[i];
	sort(b+1,b+1+n);
	int M=unique(b+1,b+1+n)-b-1;
	for(register int i=1;i<=n;++i)a[i]=lower_bound(b+1,b+1+M,a[i])-b;
	int len=sqrt(n);
	for(register int i=1;i<=n;++i)block[i]=(i-1)/len+1;
	for(register int i=1;i<=len+1;++i)R[i]=min(i*len,n);
	read(m);
	for(register int i=1;i<=m;++i)read(q[i].l),read(q[i].r),q[i].id=i;
	sort(q+1,q+1+m,cmp);
	int l=0,r=0,lastblock=0;
	int temp;
	for(register int i=1;i<=m;++i)
	{
		if(block[q[i].l]==block[q[i].r])
		{
			temp=0;
			for(register int j=q[i].r;j>=q[i].l;--j)ma[a[j]]=0;
			for(register int j=q[i].r;j>=q[i].l;--j)
				if(!ma[a[j]])ma[a[j]]=j;
				else temp=max(temp,ma[a[j]]-j);
			for(register int j=q[i].r;j>=q[i].l;--j)ma[a[j]]=0;
			ans[q[i].id]=temp;
			continue;
		}
		if(lastblock^block[q[i].l])
		{
			while(r>R[block[q[i].l]])
			{
				ma[a[r]]=0,mi[a[r]]=0;
				--r;
			}
			while(l<R[block[q[i].l]]+1)
			{
				ma[a[l]]=0,mi[a[l]]=0;
				++l;
			}
			r=l-1;
			lastblock=block[q[i].l];
			temp=0;
		}
		while(r<q[i].r)
		{
			++r;
			if(!mi[a[r]])mi[a[r]]=r,ma[a[r]]=r;
			else ma[a[r]]=r,temp=max(temp,r-mi[a[r]]);
		}
		int _l=l,res=temp;
		while(_l>q[i].l)
		{
			--_l;
			if(!ma[a[_l]])ma[a[_l]]=_l;
			else res=max(res,ma[a[_l]]-_l);
		}
		ans[q[i].id]=res;
		while(_l<l)
		{
			if(ma[a[_l]]==_l)ma[a[_l]]=0;
			++_l;
		}
	}
	for(register int i=1;i<=m;++i)printf("%d\n",ans[i]);
	return 0;
}

```


---

## 作者：whiteqwq (赞：6)

[P5906 【模板】回滚莫队&不删除莫队](https://www.luogu.com.cn/problem/P5906)解题报告：

[更好的阅读体验](https://zybuluo.com/xiaoziyao/note/1717187)

## 题意
题意：给定一个长为$n$的序列$a$，$m$次询问，求区间$[l,r]$内相同的数的最远间隔距离，注意这里的距离指下标差的绝对值。

数据范围：$1\leqslant n,m\leqslant 2\cdot 10^5$。

## 分析
这是一道回滚莫队的细节题（大部分OIer的回滚莫队入门题为[AT1219 歴史の研究](https://www.luogu.com.cn/problem/AT1219)，所以在这里我就没有对回滚莫队的讲解了），肝了很久，如果不会回滚莫队的人可以跳过这篇题解。

在回滚莫队之前，我们可以看一下两个预处理
分块：
```
t=sqrt(n);
for(i=1;i<=t;i++)
	l[i]=r[i-1]+1,r[i]=i*t;
if(r[t]<n)
	t++,l[t]=r[t-1]+1,r[t]=n;
for(i=1;i<=t;i++)
	for(j=l[i];j<=r[i];j++)
		pos[j]=i;
```
注：这里$t$指块数，$l$指块的左边界，$r$指块的右边界，$pos$指当前位置所在的块。

离散化：
```
struct number{
	int pos,val;
}num[maxn];
inline int cmp1(number a,number b){
	return a.val<b.val;
}
for(i=1;i<=n;i++)
	scanf("%d",&num[i].val),num[i].pos=i;
sort(num+1,num+1+n,cmp1);
tot=0;
for(i=1;i<=n;i++){
	if(i==1||num[i-1].val!=num[i].val)
		tot++;
	a[num[i].pos]=tot;
}
```
这里的离散化我写的方法有点不一样，但意思很容易懂，就不赘述了（$num$是离散化的数组，$a$是离散化后的数组，$tot$是帮助离散化的计数器）。

然后是$\text{add}$函数，即暴力在区间中加入这个数，更新答案：
```
inline void add(int x){
	st[a[x]]=min(st[a[x]],x),ed[a[x]]=max(ed[a[x]],x);
	now=max(now,ed[a[x]]-st[a[x]]);
}
```

我们按照回滚莫队的板子，可以把莫队拆成四个部分：
1.在同一个块中的暴力：这个很容易写：
```
if(pos[qx]==pos[qy]){
    for(j=qx;j<=qy;j++)
		tmpst[a[j]]=inf,tmped[a[j]]=-inf;
	for(j=qx;j<=qy;j++){
		tmpst[a[j]]=min(tmpst[a[j]],j),tmped[a[j]]=max(tmped[a[j]],j);
		tmpn=max(tmpn,tmped[a[j]]-tmpst[a[j]]);
	}
	ans[qi]=tmpn;
	continue;
}
```
2.换块：这里的换块可以直接将空区间放在$r_{pos[x]}$的位置，即当前询问的左边界所在块的右边界，记得要把$st$数组置极大值，$ed$数组置极小值，因为换块操作只有$\sqrt{n}$次，因此暴力清零总体是$O(n\sqrt{n})$的（$st$记录每个数字在区间中开始的位置，$ed$记录结束的位置）。
```
if(pos[qx]!=lst){
	x=r[pos[qx]]+1,y=r[pos[qx]];
	now=0,lst=pos[qx];
	for(j=1;j<=tot;j++)
		st[j]=inf,ed[j]=-inf;
}
```
3.右区间扩张，很容易写出代码：
```
while(y<qy)
	y++,add(y);
```
4.记录当前的答案，更新当前区间答案，再用之前的答案覆盖当前的答案（$tmpst$和$tmped$是记录左右区间的数组，$tmpn$记录答案，$tmpx$记录之前的左区间），但是这个时间复杂度有点高，因为清零操作最劣$O(n)$，因此复杂度会高达$O(nm)$。
```
tmpn=now,tmpx=x;
for(j=qx;j<=qy;j++)
	tmpst[a[j]]=st[a[j]],tmped[a[j]]=ed[a[j]];
while(x>qx)
	x--,add(x);
ans[qi]=now,now=tmpn,x=tmpx;
for(j=qx;j<=qy;j++)
	st[a[j]]=tmpst[a[j]],ed[a[j]]=tmped[a[j]];
```
然后你就可以获得$15pts$的高分！

考虑优化，发现覆盖数组太麻烦了，直接在$tmpst$与$tmped$上修改可以省去一个循环（但只能优化一些常数）。

我们将上面的代码改为：
```
while(y<qy)
	y++,add(y);
tmpn=now,tmpx=x;
for(j=qx;j<=qy;j++)
	tmpst[a[j]]=st[a[j]],tmped[a[j]]=ed[a[j]];
while(x>qx)
	x--,tmpadd(x);
ans[qi]=now,now=tmpn,x=tmpx;
```
然后增加一个$\text{tmpadd}$函数：
```
inline void tmpadd(int x){
	tmpst[a[x]]=min(tmpst[a[x]],x),tmped[a[x]]=max(tmped[a[x]],x);
	now=max(now,tmped[a[x]]-tmpst[a[x]]);
}
```
分数：$65pts$。

我们发现时间复杂度的瓶颈还是在记录$tmpst$与$tmped$上，我们会记录很多不会修改到的信息，因此可以考虑一个小$trick$：时间戳+$vis$数组优化，这个优化可以适用于很多重置数组为时间复杂度瓶颈的题目。

具体操作：每次循环开始时$stp$加一（$stp$指时间戳），然后直接删去上面代码的循环置$tmpst$和$tmped$部分，继续修改$\text{tmpadd}$函数：
```
inline void tmpadd(int x){
	if(vis[a[x]]!=stp)
		vis[a[x]]=stp,tmpst[a[x]]=st[a[x]],tmped[a[x]]=ed[a[x]];
	tmpst[a[x]]=min(tmpst[a[x]],x),tmped[a[x]]=max(tmped[a[x]],x);
	now=max(now,tmped[a[x]]-tmpst[a[x]]);
}
```
大意就是如果这个点在当前时间戳还没有访问过，就给$tmpst$和$tmped$赋值，并记录$vis$数组，由于$x$每次回滚都会到当前块的右边界加一位置，因此$x$到$qx$的距离最多是$\sqrt{n}$，因此每次询问最多进行$\sqrt{n}$次$\text{tmpadd}$操作，这样$tmpst$和$tmped$的赋值就变为了$O(\sqrt{n})$，即整体赋值的复杂度降到了$O(m\sqrt{n})$。

总体复杂度$O(n\sqrt{n})$（这里默认$n,m$同阶，事实也如此），可以通过本题。


## 代码
```
#include<stdio.h>
#include<math.h>
#include<algorithm>
#define inf 1000000000
using namespace std;
const int maxn=200005,maxm=200005;
int i,j,k,m,n,t,tot,x,y,now,lst,stp;
int a[maxn],ans[maxm],l[maxn],r[maxn],pos[maxn],st[maxn],ed[maxn],tmpst[maxn],tmped[maxn],vis[maxn];
struct number{
	int pos,val;
}num[maxn];
struct question{
	int x,y,id;
}q[maxm];
inline int cmp1(number a,number b){
	return a.val<b.val;
}
inline int cmp2(question a,question b){
	return pos[a.x]^pos[b.x]? a.x<b.x:a.y<b.y; 
}
inline void add(int x){
	st[a[x]]=min(st[a[x]],x),ed[a[x]]=max(ed[a[x]],x);
	now=max(now,ed[a[x]]-st[a[x]]);
}
inline void tmpadd(int x){
	if(vis[a[x]]!=stp)
		vis[a[x]]=stp,tmpst[a[x]]=st[a[x]],tmped[a[x]]=ed[a[x]];
	tmpst[a[x]]=min(tmpst[a[x]],x),tmped[a[x]]=max(tmped[a[x]],x);
	now=max(now,tmped[a[x]]-tmpst[a[x]]);
}
int main(){
	scanf("%d",&n);
	t=sqrt(n);
	for(i=1;i<=t;i++)
		l[i]=r[i-1]+1,r[i]=i*t;
	if(r[t]<n)
		t++,l[t]=r[t-1]+1,r[t]=n;
	for(i=1;i<=t;i++)
		for(j=l[i];j<=r[i];j++)
			pos[j]=i;
	for(i=1;i<=n;i++)
		scanf("%d",&num[i].val),num[i].pos=i;
	sort(num+1,num+1+n,cmp1);
	tot=0;
	for(i=1;i<=n;i++){
		if(i==1||num[i-1].val!=num[i].val)
			tot++;
		a[num[i].pos]=tot;
	}
	scanf("%d",&m);
	for(i=1;i<=m;i++)
		scanf("%d%d",&q[i].x,&q[i].y),q[i].id=i;
	sort(q+1,q+1+m,cmp2);
	x=1,y=0,now=0,lst=0;
	for(i=1;i<=m;i++){
		stp++;
		int qx=q[i].x,qy=q[i].y,qi=q[i].id,tmpn=0,tmpx;
		if(pos[qx]==pos[qy]){
			for(j=qx;j<=qy;j++)
				tmpst[a[j]]=inf,tmped[a[j]]=-inf;
			for(j=qx;j<=qy;j++){
				tmpst[a[j]]=min(tmpst[a[j]],j),tmped[a[j]]=max(tmped[a[j]],j);
				tmpn=max(tmpn,tmped[a[j]]-tmpst[a[j]]);
			}
			ans[qi]=tmpn;
			continue;
		}
		if(pos[qx]!=lst){
			x=r[pos[qx]]+1,y=r[pos[qx]];
			now=0,lst=pos[qx];
			for(j=1;j<=tot;j++)
				st[j]=inf,ed[j]=-inf;
		}
		while(y<qy)
			y++,add(y);
		tmpn=now,tmpx=x;
		while(x>qx)
			x--,tmpadd(x);
		ans[qi]=now,now=tmpn,x=tmpx;
	}
	for(i=1;i<=m;i++)
		printf("%d\n",ans[i]);
	return 0;
}
```

---

## 作者：CherryPockyOvO (赞：5)

先推荐一个学习莫队的博客

没学回滚莫队可以看看思想，放链接： [莫队算法——从入门到黑题](https://www.cnblogs.com/WAMonster/p/10118934.html)

本人就是在那里学的QAQ，觉得讲的挺好的。


#### 本弱弱开了4个数组维护区间信息

now记录当前的答案

先对原数组离散化，typ[i]

mil[typ[i]]-> 左端点扫到的typ[i]这个数的最小坐标

mal[typ[i]]-> 左端点扫到的typ[i]这个数的最大坐标

mir[typ[i]]-> 右端点扫到的typ[i]这个数的最小坐标

mar[typ[i]]-> 右端点扫到的typ[i]这个数的最大坐标

先对这四个数组初始化

可以发现

### 右端点每次扫到一个数，

用当前点的坐标 i 更新mir[typ[i]]和 mar[typ[i]],

再用(mar[typ[i]]-mir[typ[i]])更新now。

### 左端点每次扫到一个数，

用当前点的坐标 i 更新mil[typ[i]]和 mal[typ[i]],

再用(mar[typ[i]]-mil[typ[i]])和(mal[typ[i]]-mil[typ[i]])取较大值更新now。

### Tip:

因为可能右端点没有扫到当前typ[i]这个数即右边没有这个数，

所以还要用(mal[typ[i]]-mil[typ[i]])来更新。

#### 最后
因为回滚莫队每次左端点做完后要还原，

因此更新的mil[typ[i]]和mal[typ[i]]是要初始化的，

同理，在做完每一块的操作时，因为右端点也要还原，

所以在外面的循环里要把mar[typ[i]]和mir[typ[i]]也要初始化。

### 注意！！：
循环中千万不要用memset初始化，常数爆炸！

不用memset的操作很好实现，

左端点边还原边初始化，

右端点在内部循环结束后，从初始位置一直循环到刚做完的最后一个询问的右端点.

然后就完美AC了……

```cpp
//P5906 【模板】回滚莫队
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<cstring>
using namespace std;
const int maxn=200040;
int L[maxn],R[maxn],pos[maxn],t,inp[maxn],n,m,len,typ[maxn],ans[maxn];
int mil[maxn],mal[maxn],mir[maxn],mar[maxn];
struct query{
    int l,r,id;
}ask[maxn];
bool cmp(query a,query b){
    return (pos[a.l]^pos[b.l])?pos[a.l]<pos[b.l]:a.r<b.r;
} //对询问的排序 
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++) scanf("%d",&typ[i]),inp[i]=typ[i];
//                          离散化 
    sort(inp+1,inp+n+1);
    len=unique(inp+1,inp+1+n)-inp-1;
    for(int i=1;i<=n;i++) typ[i]=lower_bound(inp+1,inp+1+len,typ[i])-inp;
//                          分块
    t=sqrt(n);
    for(int i=1;i<=t;i++) L[i]=(i-1)*t+1,R[i]=i*t;
    if(R[t]<n) t++,L[t]=R[t-1]+1,R[t]=n;
    for(int i=1;i<=t;i++) 
        for(int j=L[i];j<=R[i];j++)
            pos[j]=i;
//                          处理询问信息 
    scanf("%d",&m);
    for(int i=1;i<=m;i++)
        scanf("%d%d",&ask[i].l,&ask[i].r),ask[i].id=i;
    sort(ask+1,ask+m+1,cmp);
    int p=1;
//                          初始化 
    memset(mil,0x3f3f3f,sizeof mil);
    memset(mal,0,sizeof mal);
    memset(mar,0,sizeof mar);
    memset(mir,0x3f3f3f,sizeof mir);
//                          处理询问 
    for(int k=1;k<=t;k++){
        int l=R[k]+1,r=R[k]; //左右端点起始位置 
        int now=0;
        for(;pos[ask[p].l]==k;p++){
            int ql=ask[p].l,qr=ask[p].r;
            int tmp;
            if(pos[ql]==pos[qr]){ //当左右端点在同一个块内，暴力处理Orz 
                tmp=0;
                for(int i=ql;i<=qr;i++){
                    mil[typ[i]]=min(mil[typ[i]],i);
                    mal[typ[i]]=max(mal[typ[i]],i);
                    tmp=max(tmp,mal[typ[i]]-mil[typ[i]]);
                }
                ans[ask[p].id]=tmp;
                for(int i=ql;i<=qr;i++) mil[typ[i]]=0x3f3f3f,mal[typ[i]]=0;
                continue;
            }
            while(r<qr){ //移动右端点 
                r++;
                mir[typ[r]]=min(mir[typ[r]],r);
                mar[typ[r]]=max(mar[typ[r]],r);
                now=max(now,mar[typ[r]]-mir[typ[r]]);
            }
            tmp=now; //为后面的左端点初始化用 
            while(l>ql){ //移动左端点 
                --l; 
                mil[typ[l]]=min(mil[typ[l]],l);
                mal[typ[l]]=max(mal[typ[l]],l);
                now=max(now,max(mal[typ[l]]-mil[typ[l]],mar[typ[l]]-mil[typ[l]])); //注意比较两个！ 
            }
            ans[ask[p].id]=now; //记录答案 
            while(l<R[k]+1){ //左端点还原 
                mil[typ[l]]=0x3f3f3f;
                mal[typ[l]]=0;
                l++;
            }
            now=tmp; //还原到只移动右端点的答案，即处理左端点还原后的后效性 
        }
        for(int i=R[k]+1;i<=ask[p-1].r;i++) mir[typ[i]]=0x3f3f3f,mar[typ[i]]=0;
        //右端点还原 ask[p-1].r就是刚刚右端点扫到的最终位置。 
    }
    for(int i=1;i<=m;i++) printf("%d\n",ans[i]);  
    return 0; //完结撒花！QwQ 
}
```

最后还是推荐对莫队不熟悉的Older看看上面分享的链接，真心挺好的（不是我的博客）.

---

## 作者：1saunoya (赞：5)

我菜的可怜，回滚莫队这玩意还会WA很多次。


[~~再推销一道题目~~](https://www.cnblogs.com/Isaunoya/p/11751147.html)

定义 $q_i$ 是询问

回滚莫队的做法大概就是:

按左端点所在的块排序 如果相同 按右端点排序
然后对于每个块求解。弄个右指针在块的最右边。
分类讨论一下 如果左右指针共处一个块内 直接暴力 就是根号级别的
如果不在一个块内 由于右端点是递增的 考虑移动右端点
左边的贡献直接从 $q[i].l$ ~ 块的最右边 暴力就行了
由于不能删除，每次记录之前的状态，然后复制一遍，再操作，最后回归状态，没了。


易证复杂度：
对于整块的询问 一共有 $\sqrt n$ 个块 右端点每次都是当前块的右端点 所以最多移动 $n$的长度
对于每个询问 考虑左边的端点 由于按左端点排序 左端点和右端点最多相差 $\sqrt n$ 的长度
这样就可以做到 $O(n\sqrt n + q\sqrt n)$ 了

对于每个块随便搞就可以了。
~~还有，40pts的能不能加强数据啊（~~

$\texttt{code}$:

```cpp
// by Isaunoya
#include <bits/stdc++.h>
using namespace std;
#define rep(i, x, y) for (register int i = (x); i <= (y); ++i)
#define Rep(i, x, y) for (register int i = (x); i >= (y); --i)
const int _ = 1 << 21;
struct I {
  char fin[_], *p1 = fin, *p2 = fin;
  inline char gc() {
    return (p1 == p2) && (p2 = (p1 = fin) + fread(fin, 1, _, stdin), p1 == p2) ? EOF : *p1++;
  }
  inline I& operator>>(int& x) {
    bool sign = 1;
    char c = 0;
    while (c < 48) ((c = gc()) == 45) && (sign = 0);
    x = (c & 15);
    while ((c = gc()) > 47) x = (x << 1) + (x << 3) + (c & 15);
    x = sign ? x : -x;
    return *this;
  }
  inline I& operator>>(double& x) {
    bool sign = 1;
    char c = 0;
    while (c < 48) ((c = gc()) == 45) && (sign = 0);
    x = (c - 48);
    while ((c = gc()) > 47) x = x * 10 + (c - 48);
    if (c == '.') {
      double d = 1.0;
      while ((c = gc()) > 47) d = d * 0.1, x = x + (d * (c - 48));
    }
    x = sign ? x : -x;
    return *this;
  }
  inline I& operator>>(char& x) {
    do
      x = gc();
    while (isspace(x));
    return *this;
  }
  inline I& operator>>(string& s) {
    s = "";
    char c = gc();
    while (isspace(c)) c = gc();
    while (!isspace(c) && c != EOF) s += c, c = gc();
    return *this;
  }
} in;
struct O {
  char st[100], fout[_];
  signed stk = 0, top = 0;
  inline void flush() { fwrite(fout, 1, top, stdout), fflush(stdout), top = 0; }
  inline O& operator<<(int x) {
    if (top > (1 << 20)) flush();
    if (x < 0) fout[top++] = 45, x = -x;
    do
      st[++stk] = x % 10 ^ 48, x /= 10;
    while (x);
    while (stk) fout[top++] = st[stk--];
    return *this;
  }
  inline O& operator<<(char x) {
    fout[top++] = x;
    return *this;
  }
  inline O& operator<<(string s) {
    if (top > (1 << 20)) flush();
    for (char x : s) fout[top++] = x;
    return *this;
  }
} out;
#define pb emplace_back
#define fir first
#define sec second
template <class T>
inline void cmax(T& x, const T& y) {
  (x < y) && (x = y);
}
template <class T>
inline void cmin(T& x, const T& y) {
  (x > y) && (x = y);
}
const int maxn = 2e5 + 10;
int S, n, m;
struct Que {
  int l, r, id;
} q[maxn];
int a[maxn], b[maxn], bl[maxn], Ans[maxn], fir[maxn], las[maxn], Fir[maxn], Las[maxn];
inline int calc(int l, int r) {
  rep(i, l, r) Fir[a[i]] = 1e9, Las[a[i]] = 0;
  int ans = 0;
  rep(i, l, r) {
    cmin(Fir[a[i]], i), cmax(Las[a[i]], i);
    cmax(ans, Las[a[i]] - Fir[a[i]]);
  }
  return ans;
}
int now = 1, ansl = 0, ansr = 0;
inline void add(const int& x, int& ans) {
  cmin(fir[a[x]], x), cmax(las[a[x]], x), cmax(ans, las[a[x]] - fir[a[x]]);
}
inline int max(const int& x, const int& y) { return x > y ? x : y; }
inline void solve(const int& id) {
  int qr = id * S;
  cmin(qr, n), ansr = 0;
  rep(i, (id - 1) * S + 1, n) fir[a[i]] = 1e9, las[a[i]] = 0;
  register int pr = qr;
  for (; bl[q[now].l] == id; ++now) {
    if (bl[q[now].l] == bl[q[now].r]) {
      Ans[q[now].id] = calc(q[now].l, q[now].r);
      continue;
    }
    while (pr < q[now].r) add(++pr, ansr);
    rep(i, q[now].l, qr) Fir[a[i]] = fir[a[i]], Las[a[i]] = las[a[i]];
    ansl = 0;
    Rep(i, qr, q[now].l) add(i, ansl);
    Ans[q[now].id] = max(ansl, ansr), ansl = 0;
    rep(i, q[now].l, qr) fir[a[i]] = Fir[a[i]], las[a[i]] = Las[a[i]];
  }
}
signed main() {
#ifdef _WIN64
  freopen("testdata.in", "r", stdin);
#endif
  in >> n, S = sqrt(n * 0.9);
  rep(i, 1, n) in >> a[i];
  rep(i, 1, n) b[i] = a[i], bl[i] = (i - 1) / S + 1;
  sort(b + 1, b + n + 1, [](const int& x, const int& y) { return x < y; });
  int len = unique(b + 1, b + n + 1) - b - 1;
  rep(i, 1, n) a[i] = lower_bound(b + 1, b + len + 1, a[i]) - b;
  rep(i, 1, n) Fir[i] = fir[i] = 1e9;
  in >> m;
  rep(i, 1, m) { in >> q[i].l >> q[i].r, q[i].id = i; }
  sort(q + 1, q + m + 1, [](const Que& x, const Que& y) {
    if (bl[x.l] ^ bl[y.l]) return bl[x.l] < bl[y.l];
    return x.r < y.r;
  });
  rep(i, 1, bl[n]) solve(i);
  rep(i, 1, m) out << Ans[i] << '\n';
  return out.flush(), 0;
}
```

---

## 作者：寒冰大大 (赞：4)

呜呼呼这个回滚莫队大概是一种正难则反的思路，如果遇到比较毒瘤的删除的话，要不就减少删除的次数，要不就把删除改成插入

恰好这道题都用了，虽然套一个数据结构的莫队比较好做（可惜有个$log$），可是这道题已经写了【模板】回滚莫队&不删除莫队，所以我们至少得用莫队

首先一看就知道用$st,ed$两个桶，每次都记录这个点在$[l,r]$(表示当前问题的左端点和右端点的位置)。

但是如果套普通的套一个莫队，你会发现这东西可以做到$O(1)$修改，但是似做不到O(1)撤销（除非开大空间存下来）

原来的莫队是左端点在每$\sqrt{m}$区间内的问题排序,所以这些询问的左端点都在一个块内部，右端点则是按$r$升序排序（不管奇偶性优化），可见对右端点可以做到没有删除操作，但是左端点则不然，况且左端点只有$\sqrt{m}$个操作，我们对左端点也可以做到没有插入操作，那就是每次从这个块的最右边往左移，每次向左之后要还原就行了。

可以看见每个块内的询问最多向右$\sqrt{m}$次

每个询问最多向左走$\sqrt{m}$次

复杂度还是$O(n\sqrt{m})$

除此之外本题还有一些细节要注意，写在代码注释上了

```cpp
#include<touwenjian.h>

using namespace std;

const int maxn=502000;//用不到这么多的空间

int n,m;
int st[maxn],ed[maxn],looker[maxn],lok[maxn],a[maxn],b[maxn];
int ans;
int bj[maxn];
int len,cnt;
int aans[maxn];

struct que{
	int l,r,bh;
}q[maxn];

int cmp(que aa,que bb)
{
	if((aa.l-1)/len==(bb.l-1)/len) return aa.r<bb.r;
	return aa.l<bb.l;
}

int tst[maxn],ted[maxn],tlooker[maxn],tcnt;

int bl(int l,int r) //这东西得单独开一套变量来
{
	int i,ans=0;
	for(i=l;i<=r;i++)
	{
		if(!tst[a[i]]) tst[a[i]]=i;
		ted[a[i]]=max(ted[a[i]],i); ans=max(ted[a[i]]-tst[a[i]],ans); tlooker[++tcnt]=a[i]; 
	}
	for(i=1;i<=tcnt;i++) tst[tlooker[i]]=ted[tlooker[i]]=0,tlooker[i]=0;
	tcnt=0;
	return ans;
}

inline void addr(int x)  //右端点只有插入，因此可以保留
{
	if(!st[a[x]]) st[a[x]]=x; 
	ed[a[x]]=max(ed[a[x]],x); ans=max(ed[a[x]]-st[a[x]],ans); looker[++cnt]=a[x];
}

inline void addl(int x) //左端点每次都要清空，除了判断答案在左边这个块的情况暂时用一用ed数组（之后也要清空），其他都不能动。
{
	if(!ed[a[x]]) ed[a[x]]=x;
	else ans=max(ans,ed[a[x]]-x);
}

int main()
{
	ios::sync_with_stdio(false);
	register int i,j;
	cin>>n;
	len=sqrt(n);
	for(i=1;i<=n;i++) cin>>a[i],b[i]=a[i];
	sort(b+1,b+n+1); int tot=unique(b+1,b+n+1)-b-1;
	for(i=1;i<=n;i++) a[i]=lower_bound(b+1,b+tot+1,a[i])-b;
	cin>>m;
	for(i=1;i<=m;i++) cin>>q[i].l>>q[i].r,q[i].bh=i;
	sort(q+1,q+m+1,cmp);
	i=1;
	for(j=1;j<=(n-1)/len+1;j++)
	{
		ans=0;
		int baspla=min(len*j,n);
		int l=baspla+1,r=baspla;
		for(;(q[i].l-1)/len+1==j&&i<=m;i++) //一定要加上i<=m的判断
		{
			if((q[i].l-1)/len==(q[i].r-1)/len) aans[q[i].bh]=bl(q[i].l,q[i].r);
			else
			{
				while(q[i].r>r) addr(++r); //莫队基本操作
				int rigans=ans;
				while(q[i].l<l) addl(--l);
				while(l<=baspla) { if(ed[a[l]]<=baspla) ed[a[l]]=0; l++;}
				aans[q[i].bh]=ans; 
				ans=rigans;
			}
		}
		for(int k=1;k<=cnt;k++) st[looker[k]]=ed[looker[k]]=0,looker[k]=0;
        //记得清空
		cnt=0;
	}
	for(i=1;i<=m;i++) cout<<aans[i]<<endl;
	return 0;
}
```


---

## 作者：xixiup (赞：4)

首先，对于不知道回滚莫队的童鞋们，这篇题解对你们并没有帮助，请翻阅别的题解。

然后，这道题可以确定，我们需要维护一个数最先出现的位置与最后出现的位置，处理答案就可以直接两个数相减了。

于是我们就可以很快乐地加入一个值：

```cpp
fir[num[x]]=min(fir[num[x]],x);
las[num[x]]=max(las[num[x]],x);
// fir表示最先出现的位置，las表示最后出现的位置，num是离散化的值
```

但是删除会很不好操作，应为假设你删除了一个最小值，你需要找到一个次小值，但如果你又把它删除了，那就要一个次次小值，所以我们不能删除操作，所以我们就要请出我们今天的主角：回滚莫队（不删除莫队）。

这时候我们需要想到一个问题：回滚莫队也的左指针需要往回滚，这时候我们的值就很不好维护。所以我们需要把它记下来，但问题又双叒叕来了：怎么记下来？

然而我并不会记，于是我就想出来了一个法子：我们干脆不更新。

我们右指针往右移动的时候，我们还是更新最左值与最右值，而左指针往左移时，就不更新最左值了，而是只更新最右值。而最左值我们直接用当前这数，应为当前这个数已经是我们处理的区间的最左边了。于是就可以得到：

```cpp
void JR(int x,int &Max,bool pd){
	cnt[num[x]]++;
	if(pd==1){
		fir[num[x]]=min(fir[num[x]],x);
		las[num[x]]=max(las[num[x]],x);
		Max=max(Max,las[num[x]]-fir[num[x]]);
	}
	else{
		las[num[x]]=max(las[num[x]],x);
		Max=max(Max,las[num[x]]-x);
	}
}
// pd为1表示右指针右移，为0表示左指针左移。
```

那么问题来了：回滚最大值怎么办？所以我们需要记一个cnt数组，表示普通莫队的cnt：一个数出现的次数。所以当回滚的时候，如果我们把一个数删完了，就可以直接把这个数的最右值置为0，不然我们就不用管他，应为他右边还有相同值，这些相同值的位置肯定比他靠右。

然后我们就可以快乐地AC了。

最后看代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,pos[200100],num[200100],cnt[200100];
int fir[200100],las[200100],fir1[200100],las1[200100];
int L[200100],R[200100],ans[200100];
map<int,int>ma;
struct node{
	int l,r,id;
	bool operator <(node qwq)const{//据说这个比cmp函数要快
		return (pos[l]==pos[qwq.l]?r<qwq.r:pos[l]<pos[qwq.l]);
	}
}que[200100];
void LSH(){//离散化
	int sum=0;
	for(int i=1;i<=n;i++){
		if(ma[num[i]]==0){
			sum++;
			ma[num[i]]=sum;
		}
		num[i]=ma[num[i]];
	}
}
void FK(){//分块
	int B=sqrt(n),T=n/B;
	for(int i=1;i<=T;i++){
		L[i]=R[i-1]+1;
		R[i]=min(i*B,n);
	}
	for(int i=1;i<=T;i++){
		for(int j=L[i];j<=R[i];j++){
			pos[j]=i;
		}
	}
}
void HG(int x){//回滚
	cnt[num[x]]--;
	if(cnt[num[x]]==0){
		las[num[x]]=0;
	}
}
void JR(int x,int &Max,bool pd){//加入
	cnt[num[x]]++;
	if(pd==1){
		fir[num[x]]=min(fir[num[x]],x);
		las[num[x]]=max(las[num[x]],x);
		Max=max(Max,las[num[x]]-fir[num[x]]);
	}
	else{
		las[num[x]]=max(las[num[x]],x);
		Max=max(Max,las[num[x]]-x);
	}
}
signed main(){
	memset(fir,0x3f,sizeof(fir));
	memset(fir1,0x3f,sizeof(fir1));
	cin>>n;
	for(int i=1;i<=n;i++){
		scanf("%lld",&num[i]);
	}
	cin>>m;
	for(int i=1;i<=m;i++){
		scanf("%lld%lld",&que[i].l,&que[i].r);
		que[i].id=i;
	}
	LSH();
	FK();
	sort(que+1,que+1+m);
	int maxi=0,r=0,l=1,last=0;
	for(int i=1;i<=m;i++){
		int ql=que[i].l,qr=que[i].r;
		if(pos[ql]==pos[qr]){//当左右值在同一块中时，暴力处理即可
			int tmp=0;
			for(int j=ql;j<=qr;j++){
				fir1[num[j]]=min(fir1[num[j]],j);
				las1[num[j]]=max(las1[num[j]],j);
			}
			for(int j=ql;j<=qr;j++){
				tmp=max(tmp,las1[num[j]]-fir1[num[j]]);
			}
			for(int j=ql;j<=qr;j++){
				fir1[num[j]]=0x3f3f3f3f;
				las1[num[j]]=0;
			}
			ans[que[i].id]=tmp;
		}
		else{
			if(pos[ql]!=last){
				memset(las,0,sizeof(las));//暴力memset
				memset(fir,0x3f,sizeof(fir));
				memset(cnt,0,sizeof(cnt));
				l=R[pos[ql]]+1;
				r=R[pos[ql]];
				maxi=0;
				last=pos[ql];
			}
			while(r<qr){
				r++;
				JR(r,maxi,1);
			}
			int tmp=maxi,mark=l;
			while(mark>ql){
				mark--;
				JR(mark,tmp,0);
			}
			while(mark<l){
				HG(mark);
				mark++;
			}
			ans[que[i].id]=tmp;
		}
	}
	for(int i=1;i<=m;i++){
		printf("%lld\n",ans[i]);
	}
	return 0;//欢乐地return 0;
}
```

---

## 作者：LordLeft (赞：3)

~~肝了一天终于卡过去了~~

首先，遇到这种要你维护很诡异的东西的题目，实在想不到用什么数据结构，一般就想到莫队。

众所周知，直接$O(nm)$的扫一遍肯定是可以得到答案的，但是这样时间复杂度不好。仔细思索一番，发现这类题目区间扩大一个数/缩小一个数的复杂度一般是$O(1)$的，所以我们可以搞两个指针反复横跳，去“锁定”查询区间。

但是这样其实也并没有什么卵用，所以我们可以对原序列分块，再把所有询问排个序，左端点在一个块就右端点升序，否则左端点升序。这样的话，对于右端点，他们的左端点都在一个块内，而他们又是递增的，所以对于每一个块最多遍历整个序列，这就是$O(\frac{n^2}{S})$，而对于左端点，他最多在块内左右横跳，或者进入下一个块，所以每次最多移动一个块长，这样就是$O(mS)$，令块长为$\sqrt n$，我们就有了一个$O(n\sqrt n)$的优秀离线算法。

这时回到这个题目，发现一个很严肃的问题：把一个数加入序列很容易修改，但是删除出去就不是很好办了。类似的，还有一些关于众数、最大值的问题。于是我们在莫队的基础上稍加修改，让他“只加不减”。

这时候，在莫队的基础上，我们分别处理每一个块里的询问。对于询问区间小于块长的询问，我们直接暴力计算。每进入一个新的块，先把莫队的左指针和右指针都移到当前块的右端点。我们先将右指针移动，再记录下当前的信息，继而移动左指针，得到此询问的答案后把左指针移回去，把刚刚记录的信息复原，~~大　家　就　当　无　事　发　生~~。这就是回滚莫队。

这样的话，你会发现左端点只会向左移动，而右端点只会向右移动，这就保证了询问区间“只加不减”。类似于上面的分析，易知回滚莫队的复杂度也是$O(n\sqrt n)$，只不过常数略大。

再回到这个题目，我兴高采烈的交了一发，然后就$T$成$65Pts$了。。。

于是我们进行一系列的卡常，比如玄学调块长啦，手打$min$ $
max$啦，减少重置数组次数啦什么的，然后经过艰苦卓绝的奋斗就过了。

code:

```cpp
#include<iostream>
#include<cstdio>
#include<cctype>
#include<cstring>
#include<algorithm>
#include<cmath>
#define il inline
using namespace std;
il int read(){
	int w=0;
	bool s=0;
	char c=getchar();
	while(!isdigit(c)){
		s=(c=='-');
		c=getchar();
	}
	while(isdigit(c)){
		w=w*10+c-'0';
		c=getchar();
	}
	return s?-w:w;
}
const int N=200005,inf=1<<30;
int n,m,k,a[N],A[N];
int size,blk,bel[N],L[N],R[N],ans[N];
struct Query{
	int l,r,id;
	il friend bool operator < (Query a,Query b){
		if(bel[a.l]==bel[b.l]){
			return a.r<b.r;
		}
		else{
			return a.l<b.l;
		}
	}
};
Query q[N];
int al[N],ar[N],Al[N],Ar[N],aL[N],aR[N],tmp,rev;
il int min(int a,int b){
	return a<b?a:b;
}
il int max(int a,int b){
	return a>b?a:b;
}
il int BF(int le,int ri){
	for(int i=le;i<=ri;i++){
		aL[a[i]]=inf;
		aR[a[i]]=0;
	}
	int res=0;
	for(int i=le;i<=ri;i++){
		aL[a[i]]=min(aL[a[i]],i);
		aR[a[i]]=i;
		res=max(res,aR[a[i]]-aL[a[i]]);
	}
	return res;
}
void radd(int x){
	al[a[x]]=min(al[a[x]],x);
	ar[a[x]]=x;
	tmp=max(tmp,ar[a[x]]-al[a[x]]);
}
void ladd(int x){
	al[a[x]]=x;
	ar[a[x]]=max(ar[a[x]],x);
	tmp=max(tmp,ar[a[x]]-al[a[x]]);
}
int main(){
	n=read();
	for(int i=1;i<=n;i++){
		a[i]=read();
		A[i]=a[i];
	}
	sort(A+1,A+1+n);
	k=unique(A+1,A+1+n)-A-1;
	for(int i=1;i<=n;i++){
		a[i]=lower_bound(A+1,A+1+k,a[i])-A;
	}
	size=3*(int)sqrt(n)/4;
	blk=n/size;
	for(int i=1;i<=blk;i++){
		L[i]=R[i-1]+1;
		R[i]=L[i]+size-1;
	}
	if(R[blk]<n){
		blk++;
		L[blk]=L[blk-1]+1;
		R[blk]=n;
	}
	for(int i=1;i<=n;i++){
		bel[i]=(i-1)/size+1;
	}
	m=read();
	for(int i=1;i<=m;i++){
		q[i].l=read(),q[i].r=read();
		q[i].id=i;
	}
	sort(q+1,q+1+m);
	int w=1,le=0,ri=0;
	for(int t=1;t<=blk;t++){
		ri=R[t];
		tmp=0;
		for(int i=1;i<=k;i++){
			al[i]=inf;
			ar[i]=0;
		}
		while(bel[q[w].l]==t){
			le=R[t]+1;
			if(q[w].r-q[w].l<=size){
				ans[q[w].id]=BF(q[w].l,q[w].r);
				w++;
				continue;
			}
			while(ri<q[w].r){
				radd(++ri);
			}
			rev=tmp;
			for(int i=q[w].l;i<=R[t];i++){
				Al[a[i]]=al[a[i]];
				Ar[a[i]]=ar[a[i]];
			}
			while(le>q[w].l){
				ladd(--le);
			}
			ans[q[w].id]=tmp;
			tmp=rev;
			w++;
			for(int i=le;i<=R[t];i++){
				al[a[i]]=Al[a[i]];
				ar[a[i]]=Ar[a[i]];
			}
		}
	}
	for(int i=1;i<=m;i++){
		printf("%d\n",ans[i]);
	}
	return 0;
}
```
GL~

---

## 作者：GoPoux4 (赞：2)

刚学回滚莫队，来篇题解。

---

这题和另一道回滚莫队板子题 [AT1219 歴史の研究](https://atcoder.jp/contests/joisc2014/tasks/joisc2014_c) 相比，插入删除操作要更复杂一点，因为一个数第一次和最后一次出现的位置不可差分，而那道题只需要记录数出现的次数，在左右端点插入删除的操作没有区别，而且细节要少，打起来更简单一些。

---

### 题解

由于删除不好更新答案，所以我们尽量让左右端点只增不减。

将询问进行排序：如果 $l$ 在同一个块中，则按照 $r$ 从小到大排序，否则按照 $l$ 从小到大排序。

这样就保证了在 $l$ 在同一个块时， $r$ 指针只向右扩展。

记录上一个询问左端点所在的块为 $lasB$ ，块 $lasB$ 的右边界为 $R$，正在处理的询问的左右端点分别为 $l,r$，则处理询问时有几种不同的情况：

1. $l,r$ 均在 $lasB$ 中。

2. $l,r$ 均大于 $R$。

3. $l$ 小于 $R$ ， $r$ 大于 $R$。

对于第1种情况，暴力求解。

对于第2种情况，将 $lasB$ 赋值为 $l$ 所在块的编号，并且将左右指针分别移动到 $R+1,R$ 上，则此时变为第3种情况。

对于第3种情况，将右指针移动到 $r$ 处，设一个临时指针处理区间 $[R+1,r] \bigcup [l,R]$的数据（实现见代码）。

这样搞一搞就过了这道题。

---

Code：

```cpp
#include <iostream>
#include <cstring>
#include <cstdio>
#include <algorithm>
#define maxn 200005
#define BN 400//块长
#define Rint register int
using namespace std;
typedef long long lxl;
const int INF=1<<30;

inline lxl read()
{
	lxl x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9') {if(ch=='-') f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9') {x=(x<<1)+(x<<3)+ch-'0';ch=getchar();}
	return x*f;
}

int n,m,a[maxn],b[maxn],ans[maxn];
int fir[maxn],las[maxn];//存放[R+1,r]内的数据
int _fir[maxn],_las[maxn];//存放[l,R]内的数据
int L[maxn],R[maxn],pos[maxn];

struct ques
{
	int l,r,id;
	bool operator <(const ques &x)const
	{
		if(pos[l]!=pos[x.l]) return pos[l]<pos[x.l];
		return r<x.r;
	}
}querys[maxn];

inline void init()
{
	int tot=n/BN;
	for(Rint i=1;i<=tot;++i)
	{
		L[i]=(i-1)*BN+1;
		R[i]=i*BN;
	}
	if(R[tot]<n)
	{
		++tot;
		L[tot]=R[tot-1]+1;
		R[tot]=n;
	}
	for(Rint i=1;i<=tot;++i)
		for(Rint j=L[i];j<=R[i];++j) pos[j]=i;
}

inline void Add_R(int i,int &Ans)
{
	fir[a[i]]=min(fir[a[i]],i);
	las[a[i]]=max(las[a[i]],i);
	Ans=max(Ans,las[a[i]]-fir[a[i]]);
}

inline void Add_L(int i,int &Ans)
{
	_fir[a[i]]=min(fir[a[i]],min(_fir[a[i]],i));
	_las[a[i]]=max(las[a[i]],max(_las[a[i]],i));//这里要从[R+1,r]中继承数据
	Ans=max(Ans,_las[a[i]]-_fir[a[i]]);
}
//插入

inline void Del_R(int i)
{
	fir[a[i]]=INF;
	las[a[i]]=-INF;
}

inline void Del_L(int i)
{
	_fir[a[i]]=INF;
	_las[a[i]]=-INF;
}
//删除

int main()
{
	//freopen("P5906.in","r",stdin);
	n=read();
	for(Rint i=1;i<=n;++i)
		a[i]=b[i]=read();
	init();
	sort(b+1,b+n+1);
	int t=unique(b+1,b+n+1)-b-1;
	for(Rint i=1;i<=n;++i)
		a[i]=lower_bound(b+1,b+t+1,a[i])-b;
	for(Rint i=1;i<=t;++i)
		fir[i]=_fir[i]=INF,las[i]=_las[i]=-INF;
	m=read();
	for(Rint i=1;i<=m;++i)
		querys[i].l=read(),querys[i].r=read(),querys[i].id=i;
	sort(querys+1,querys+m+1);
	for(int i=1,las_B=0,Ans=0,Tmp,l=1,r=0,_l;i<=m;++i)
	{
		ques &q=querys[i];
		if(pos[q.l]!=las_B)
		{
			las_B=pos[q.l];
			while(r>R[las_B]) Del_R(r--);
			while(l<R[las_B]+1) Del_R(l++);
			l=(r=R[las_B])+1;
			Ans=0;
		}
		if(pos[q.l]==pos[q.r])
		{
			for(Rint j=q.l;j<=q.r;++j) Add_L(j,ans[q.id]);
			for(Rint j=q.l;j<=q.r;++j) Del_L(j);
			continue;
		}
		while(r<q.r) Add_R(++r,Ans);
		_l=l;
		Tmp=Ans;
		while(_l>q.l) Add_L(--_l,Tmp);//处理[l,R]内的数据
		ans[q.id]=Tmp;
		while(_l<l) Del_L(_l++);//回滚
	}
	for(Rint i=1;i<=m;++i)
		printf("%d\n",ans[i]);
	return 0;
}

```


---

## 作者：Demoe (赞：2)

### [题目传送门](https://www.luogu.com.cn/problem/P5906)

## 题意

- 给定一个序列，每次询问区间 $[l,r]$ 中相同的数的最远间隔距离。

## Sol

### 回滚莫队

显然，由名字得，回滚莫队还是要用莫队的基本思想。

这里不再赘述普通莫队的解决方案。

这种方式主要用于可离线查询，其中插入删除操作中一种方便一种复杂甚至不可做的情况。

既然一种简单一种麻烦，我们肯定选用简单的好qwq。

那么我们尽量全用简单的。

#### 以下内容默认插入操作简单，反之类似。

排序方式与原先类似。

第一关键字 左端点所在块，第二关键字 右端点递增。

这样当左端点在同一块中，我们已经保证了右端点只有插入操作。

那么对于左端点，我们可以采取一个很暴力的操作——每次操作完回滚至当前块右端点，即从块右端点扩展到询问左端点，再将左端点**还原回块右端点**。

这是回滚莫队的核心操作。

当然我们还要考虑询问右端点在左端点同一块内的情况。

这种情况直接暴力跑即可，复杂度与拓展相同。

这样一次暴力时间复杂度是 $O(\sqrt n \times k)$ （$k$ 是一次增量所需时间）

同样对于莫队拓展我们知道是 $O(n\sqrt n \times k)$

若 $n$ 次暴力也相等。

所以回滚莫队复杂度即 $O(n\sqrt n\times k)$

---

对于本题，每次跑完一组块时，你还要清除痕迹。

建议拿一个东西记录已使用的位置，每次只需清理这些即可。

可以减小常数。

---

代码。

```cpp
/*
***
还要继续努力
成为一名烤咕学家哦
***
*/
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=2e5+5;
int n,m,a[N],len,l,r,sum,vst[N],cnt,ans[N],lst[N],nxt[N],lsh[N],qaq,qwq;
struct Question{int l,r,id,pos;}q[N];
template <typename T> void rd(T &x){
	int fl=1;x=0;char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') fl=-fl;
	for(;isdigit(c);c=getchar()) x=(x<<3)+(x<<1)+c-'0';
	x*=fl;
}
void wr(int x){
	if(x<0) x=-x,putchar('-');
	if(x<10) putchar(x+'0');
	if(x>9) wr(x/10),putchar(x%10+'0');
}
bool cmp(Question x,Question y){
	if(x.pos!=y.pos) return x.pos<y.pos;
	return x.r<y.r;
}
int solve(int l,int r){
	int up[N]={0},tot=0;
	for(int i=l;i<=r;++i){if(!up[a[i]]) up[a[i]]=i;tot=max(tot,i-up[a[i]]);}
	return tot;
}
void update(int x,int op){
	if(op==1){
		nxt[a[x]]=x;
		if(!lst[a[x]]) lst[a[x]]=x,vst[++cnt]=x;
		sum=max(sum,x-lst[a[x]]);
	}
	else{if(!nxt[a[x]]) nxt[a[x]]=x;sum=max(sum,nxt[a[x]]-x);}
}
void erase(int x){if(nxt[a[x]]==x) nxt[a[x]]=0;}
int main(){
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	rd(n);len=(int)sqrt(n);
	for(int i=1;i<=n;++i) rd(a[i]),lsh[i]=a[i];
	rd(m);
	for(int i=1;i<=m;++i) rd(q[i].l),rd(q[i].r),q[i].id=i,q[i].pos=(q[i].l-1)/len+1;
	sort(lsh+1,lsh+n+1);
	qaq=unique(lsh+1,lsh+n+1)-lsh-1;
	for(int i=1;i<=n;++i) a[i]=lower_bound(lsh+1,lsh+qaq+1,a[i])-lsh;
	sort(q+1,q+m+1,cmp);
	for(int i=1,j=1;j<=(n-1)/len+1;++j){
		for(int k=1;k<=cnt;++k) lst[a[vst[k]]]=nxt[a[vst[k]]]=0;
		int br=min(j*len,n);l=br+1,r=br,sum=cnt=0;
		while(q[i].pos==j){
			if(q[i].r<=br){
				ans[q[i].id]=solve(q[i].l,q[i].r);++i;
				continue;
			}
			while(r<q[i].r) ++r,update(r,1);
			qwq=sum;
			while(l>q[i].l) --l,update(l,-1);
			ans[q[i].id]=sum;
			while(l<=br) erase(l),l++;
			sum=qwq;++i;
		}
	}
	for(int i=1;i<=m;++i) wr(ans[i]),puts("");
	return 0;
}
```

---

## 作者：Immortal_Bird (赞：2)

基建第十四篇

回滚莫队的主要思想是利用更多的增加操作(r++和l--)代替减少操作(r--和l++)。

具体步骤就是
- 第一关键字按左端点的块排序，第二按右端点排序

- 枚举每一个块，当某个查询左端点在这块时
1. 如果右端点也在此块中，暴力修改
2. 如果右端点不在此块，不断对$r$向右做增操作，直到碰到右端点。此时是很容易更新的
3. 先把$l$调到这个块的最右边，然后对$l$往左做增操作，直到碰到左端点。

复杂度的话

1. 暴力修改是$O(logN)$，考虑$M$个询问与$O(logN)$个块，由于只跟$M$有关的，所以总复杂度是$O(MlogN)$
2. 向右做增操作是$O(N)$，考虑$M$个询问与$O(logN)$个块，由于向右操作可以解决所有当前左端点在一个块中情况，显然左端点尽量分散复杂度更大，而最多有$O(logN)$个块。所以复杂度与块数有关，$O(NlogN)$
3. 向左是$O(logN)$，由于它与向右是各自独立的，所以复杂度显然比向右更低。

代码参考[yuzhechuan神仙](https://www.luogu.com.cn/user/65735)

但是我并不知道为什么

for(;b[q[i].l]==j;i++)

这句改成while后就不行了。。

[P5906](https://www.luogu.com.cn/problem/P5906)

$$Code$$

```cpp
#include<bits/stdc++.h>
using namespace std;

int read(){
	int x=0;bool f=0;char ch=getchar();
	while(!isdigit(ch))f|=ch=='-',ch=getchar();
	while(isdigit(ch))x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
	return f?-x:x;
}

void write(int x){
	if(x<0)putchar('-'),x=-x;
	if(x>9)write(x/10);
	putchar(48+x%10);
}

void writeln(int x){write(x);putchar('\n');}
void writebl(int x){write(x);putchar(' ');}

#define I inline
#define R register

const int maxn = 2e5+5;

int b[maxn],a[maxn],Ans[maxn],num[maxn],st[maxn],clear[maxn],la[maxn],n,m,un,cn,bn;

struct que{int l,r,id;}q[maxn];
I bool cmp(que x,que y){return (b[x.l]^b[y.l])?b[x.l]<b[y.l]:x.r<y.r;}

int calc(int l,int r){
	int last[maxn],res=0;
	for(R int i=l;i<=r;++i)last[a[i]]=0;
	for(R int i=l;i<=r;++i)
		if(!last[a[i]])last[a[i]]=i;
		else res=max(res,i-last[a[i]]);
	return res;
} 

int main(){
	n=read();int len=sqrt(n);
	
	for(R int i=1;i<=n;++i)
		num[i]=a[i]=read(),b[i]=(i-1)/len+1;bn=b[n];
		
	sort(num+1,num+n+1);un=unique(num+1,num+n+1)-num-1;	
	for(R int i=1;i<=n;++i)
		a[i]=lower_bound(num+1,num+un+1,a[i])-num;
		
	m=read();
	for(R int i=1;i<=m;++i)
		q[i].l=read(),q[i].r=read(),q[i].id=i;
	sort(q+1,q+m+1,cmp);
	
	R int i,j;
	for(i=1,j=1;j<=bn;++j){
		int br=min(n,j*len),l=br+1,r=l-1,ans=0;
		cn=0;
		for(;b[q[i].l]==j;i++){
			if(b[q[i].r]==j){Ans[q[i].id]=calc(q[i].l,q[i].r);continue;}
			while(r<q[i].r){
				r++;la[a[r]]=r;
				if(!st[a[r]])st[a[r]]=r,clear[++cn]=a[r];
				ans=max(ans,r-st[a[r]]);
			}
			int res=ans;
			while(l>q[i].l){
				l--;if(la[a[l]])ans=max(ans,la[a[l]]-l);
				else la[a[l]]=l;
			}
			Ans[q[i].id]=ans;
			while(l<=br){if(la[a[l]]==l)la[a[l]]=0;l++;}
			ans=res;
		}
		for(R int k=1;k<=cn;++k)la[clear[k]]=st[clear[k]]=0;
	}
	
	for(R int i=1;i<=m;++i)writeln(Ans[i]);
}






```





---


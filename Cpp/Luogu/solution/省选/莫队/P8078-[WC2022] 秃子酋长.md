# [WC2022] 秃子酋长

## 题目背景

5s 512M -O2

## 题目描述

传说在明斯克航空航天局中，有一名强大的秃子酋长。

秃子酋长法力无边，他的头上没有头发，而且头特别硬，跑得还不慢。

这一天，豌豆射手来到了明斯克航空航天局。

秃子酋长为了考验这一位新人，给他出了这样一道题：

给一个长为 $n$ 的排列 $a_1,\dots, a_n$，有 $m$ 次询问，每次询问区间 $[l, r]$ 内，排序后相邻的数在原序列中的位置的差的绝对值之和。

## 说明/提示

**【样例解释】**

第一个询问，$2,3$ 排序后为 $2,3$，在原序列中的位置为 $3,4$，相邻元素在原序列中位置差的绝对值之和为 $|3 - 4| = 1$。

第二个询问，$4, 2, 3, 1$ 排序后为 $1, 2, 3, 4$，在原序列中的位置为 $5, 3, 4, 2$，相邻元素在原序列中位置差的绝对值之和为 $|5 - 3| + |3 - 4| + |4 - 2| = 5$。

**【数据范围】**

对 $10\%$ 的数据，$n, m \leq 10^3$；  
对另外 $10\%$ 的数据，$n, m \leq 5 \times 10^4$；  
对另外 $10\%$ 的数据，$n, m \leq 10^5$；  
对另外 $10\%$ 的数据，$n, m \leq 2 \times 10^5$；  
对另外 $20\%$ 的数据，$|a_i - i| \leq 10$；  
对另外 $20\%$ 的数据，$m=\dfrac{n(n-1)}{2}$；  
对其余数据，无特殊限制。

对于 $100\%$ 的数据，满足 $1 \leq n, m \leq 5\times 10^5$，$1 \leq a_i \leq n$，$a_i$ 互不相同，$1 \leq l \leq r \leq n$，所有数值为整数。


## 样例 #1

### 输入

```
5 2
5 4 2 3 1
3 4
2 5```

### 输出

```
1
5```

# 题解

## 作者：FZzzz (赞：49)

怎么题解区全是莫队，来发 2log 的正解。

考虑分治，每次处理跨过中间点的询问。把两边的部分拉出来排序，考虑若右边有两个位置 $i$ 和 $j$（$a_i<a_j$）在排序后是相邻的，它们会产生怎样的贡献。
- 若左边有 $a_i$ 和 $a_j$ 之间的数，那么一定是从 $i$ 走到左边，走走走再走回 $j$，这样贡献是 $i+j$；
- 否则，就是从 $i$ 直接走到 $j$，这样贡献是 $|i-j|$。

对于最大值和最小值也是类似，考虑左边有没有比它大或者小的。

考虑改写第一种贡献成立的条件。找到分治中点左边最靠右的 $a_i$ 和 $a_j$ 之间的数，那么第一种贡献的条件就是询问左端点在这个位置左边，这是一个一维数点。

对询问的右端点做扫描线，每次插入或删除一个数会插入和删除 $O(1)$ 对这样的 $(i,j)$，相当于我们做动态一维数点，树状数组维护。对于左边的对的贡献也类似维护即可。

更新这样的 $(i,j)$ 需要支持找到当前插入或删除的数的前驱和后继，并支持在另一边找到第一个在某个区间内的数。前者可以 `set` 维护，后者可以线段树。

但是这样常数很大，也可以右端点从右往左，左端点从左往右，这样只需要删数，可以归并排序和链表维护。

时间复杂度 $O(n\log^2n+m\log n)$，如果你用链表的话瓶颈就是动态一维数点，$n$ 和 $m$ 同阶时可以平衡到 $O\left(\dfrac{n\log^2n}{\log\log n}\right)$。

下面的代码是 2log，提交时和题解提交时可以排到最优解第一并且碾压大部分莫队做法。
```cpp
#include<bits/stdc++.h>
using namespace std;
using ll=long long;
inline ll read(){
	ll x=0;
	bool f=0;
	char c=getchar();
	while(!isdigit(c)){
		if(c=='-') f=1;
		c=getchar();
	}
	while(isdigit(c)){
		x=x*10+c-'0';
		c=getchar();
	}
	return f?-x:x;
}
const int maxn=5e5+5;
int n,m,a[maxn],p[maxn],ql[maxn],qr[maxn];
ll c[maxn];
void modify(int x,ll k){
	while(x){
		c[x]+=k;
		x-=x&-x;
	}
}
ll query(int x){
	ll s=0;
	while(x<=n){
		s+=c[x];
		x+=x&-x;
	}
	return s;
}
ll ans[maxn];
vector<int> q[maxn];
int ord[maxn],pre[maxn],suc[maxn],mx[maxn];
void solve(int l,int r,vector<int> vec){
	if(l==r){
		ord[r]=a[r];
		return;
	}
	int mid=l+(r-l)/2;
	vector<int> vec1,vec2,vec3;
	for(int i:vec)
		if(qr[i]<=mid) vec1.push_back(i);
		else if(ql[i]>mid) vec2.push_back(i);
		else vec3.push_back(i);
	solve(l,mid,vec1);
	solve(mid+1,r,vec2);
	int c=l;
	suc[0]=ord[mid+1];
	mx[0]=0;
	while(c<=mid&&ord[c]<ord[mid+1])
		mx[0]=max(mx[0],p[ord[c++]]);
	for(int i=mid+1;i<=r;i++){
		pre[ord[i]]=i==mid+1?0:ord[i-1];
		suc[ord[i]]=i==r?n+1:ord[i+1];
		mx[ord[i]]=0;
		while(c<=mid&&ord[c]<suc[ord[i]])
			mx[ord[i]]=max(mx[ord[i]],p[ord[c++]]);
	}
	pre[n+1]=ord[r];
	for(int i:vec3) q[qr[i]].push_back(i);
	ll res=0;
	auto upd1=[&res](int x,int f){
		int y=suc[x];
		if(x&&y<=n){
			res+=abs(p[x]-p[y])*f;
			modify(mx[x],(p[x]+p[y]-abs(p[x]-p[y]))*f);
		}
		else modify(mx[x],(x?p[x]:p[y])*f);
	};
	upd1(0,1);
	for(int i=mid+1;i<=r;i++) upd1(ord[i],1);
	for(int i=r;i>mid;i--){
		for(int j:q[i]) ans[j]=res+query(ql[j]);
		upd1(pre[a[i]],-1);
		upd1(a[i],-1);
		pre[suc[a[i]]]=pre[a[i]];
		suc[pre[a[i]]]=suc[a[i]];
		mx[pre[a[i]]]=max(mx[pre[a[i]]],mx[a[i]]);
		if(i>mid+1) upd1(pre[a[i]],1);
	}
	for(int i=mid+1;i<=r;i++) vector<int>().swap(q[i]);
	c=mid+1;
	suc[0]=ord[l];
	mx[0]=0;
	while(c<=r&&ord[c]<ord[l]) mx[0]=max(mx[0],n+1-p[ord[c++]]);
	for(int i=l;i<=mid;i++){
		pre[ord[i]]=i==l?0:ord[i-1];
		suc[ord[i]]=i==mid?n+1:ord[i+1];
		mx[ord[i]]=0;
		while(c<=r&&ord[c]<suc[ord[i]])
			mx[ord[i]]=max(mx[ord[i]],n+1-p[ord[c++]]);
	}
	pre[n+1]=ord[mid];
	for(int i:vec3) q[ql[i]].push_back(i);
	auto upd2=[&res](int x,int f){
		int y=suc[x];
		if(x&&y<=n){
			res+=abs(p[x]-p[y])*f;
			modify(mx[x],(-p[x]-p[y]-abs(p[x]-p[y]))*f);
		}
		else modify(mx[x],(x?-p[x]:-p[y])*f);
	};
	upd2(0,1);
	for(int i=l;i<=mid;i++) upd2(ord[i],1);
	for(int i=l;i<=mid;i++){
		for(int j:q[i]) ans[j]+=res+query(n+1-qr[j]);
		upd2(pre[a[i]],-1);
		upd2(a[i],-1);
		pre[suc[a[i]]]=pre[a[i]];
		suc[pre[a[i]]]=suc[a[i]];
		mx[pre[a[i]]]=max(mx[pre[a[i]]],mx[a[i]]);
		if(i<mid) upd2(pre[a[i]],1);
	}
	for(int i=l;i<=mid;i++) vector<int>().swap(q[i]);
	vector<int> tmp;
	c=l;
	for(int i=mid+1;i<=r;i++){
		while(c<=mid&&ord[c]<ord[i]) tmp.push_back(ord[c++]);
		tmp.push_back(ord[i]);
	}
	while(c<=mid) tmp.push_back(ord[c++]);
	for(int i=l;i<=r;i++) ord[i]=tmp[i-l];
}
int main(){
#ifdef LOCAL
	freopen("in.txt","r",stdin);
	freopen("out.txt","w",stdout);
#endif
	n=read();
	m=read();
	for(int i=1;i<=n;i++) p[a[i]=read()]=i;
	for(int i=1;i<=m;i++){
		ql[i]=read();
		qr[i]=read();
	}
	vector<int> vec;
	for(int i=1;i<=m;i++) vec.push_back(i);
	solve(1,n,vec);
	for(int i=1;i<=m;i++) printf("%lld\n",ans[i]);
#ifdef LOCAL
	fprintf(stderr,"%f\n",1.0*clock()/CLOCKS_PER_SEC);
#endif
	return 0;
}
```
~~不过我不会告诉你我最开始写了个 `set` 和线段树的卡了一万年常还 90。~~

---

## 作者：Presentation_Emitter (赞：37)

良心出题人 lxl。

首先不难想到 $\Theta(n \sqrt{n \log n})$ 做法（莫队，用 `set` 维护前驱后继）。

观察到原排列的一段区间排序后相邻的数在原序列中的位置就是逆排列对应位置的值。链表的删除操作能做到 $\Theta(1)$，于是考虑使用不插入的回滚莫队。

不插入莫队流程（因为没找到例题所以在这题贴出来了，会的可以跳过）：

0. 将莫队左端点 $l$ 初始化为 $1$，右端点 $r$ 初始化为 $n$，并维护全局答案；
1. 对原序列分块，然后对询问按照如下方式排序：以左端点所在块升序，左端点同个块的以右端点**降序**；
2. 对于所有左端点在第 $b$ 块内的询问，$l$ 初始化为 $L_b$（块的左端点），$r$ 初始化为 $n$；
3. 对于同个块内的所有询问，每次先移动右端点（至多移动 $\Theta(n)$ 次），对于每一个询问，使左端点从 $L_b$ 出发到指定位置，存完答案后**撤销移动端点的改动**，使左端点回到 $L_b$；
4. 按照相同的方式处理下一块。

时间复杂度 $\Theta(n \sqrt n)$。

Code:

```cpp
int n,m,p[500005],v[500005],bl[500005],lb[500005],rb[500005],lxl;ll ans[500005];
struct query{int l,r,id;il bool opr<(cst query&_)cst{ret (bl[l]^bl[_.l])?bl[l]<bl[_.l]:r>_.r;}}q[500005];
cst int siz=800;
struct chain
{
	int pre[500005],nxt[500005],s[500005],t;
	il int del(int p)
	{
		int p1=pre[p],p2=nxt[p],res=0;s[++t]=p;
		if(p1&&p2)res+=uabs(v[p1]-v[p2]);
		if(p1)res-=uabs(v[p1]-v[p]);
		if(p2)res-=uabs(v[p2]-v[p]);
		nxt[p1]=p2;pre[p2]=p1;ret res;
	}
	il void init(int n)
	{
		for(int i=1;i<=n;++i)nxt[i]=i+1,pre[i]=i-1;
		nxt[n]=0;
	}
	il void copy(int n,chain&a){cpy(pre,a.pre,n+1);cpy(nxt,a.nxt,n+1);}
	il int undo(){int p=s[t--];nxt[pre[p]]=pre[nxt[p]]=p;ret p;}
}a;
int main()
{
	file(rrads);
	n=rd();m=rd();a.init(n);
	for(int i=1;i<=n;++i)v[p[i]=rd()]=i,bl[i]=(i-1)/siz+1,(!lb[bl[i]])&&(lb[bl[i]]=i),rb[bl[i]]=i;
	for(int i=1;i<=m;++i)q[i].l=rd(),q[i].r=rd(),q[i].id=i;
	sort(q+1,q+1+m);
	int l=1,r=n,lst=1;ll cur=0,curr;
	for(int i=2;i<=n;++i)cur+=uabs(v[i]-v[i-1]);
	curr=cur;
	for(int i=1;i<=m;++i)
	{
		int lq=q[i].l,rq=q[i].r;
		if(bl[lq]^lst)
		{
			while(a.t)a.undo();
			while(l<lb[bl[lq]])curr+=a.del(p[l++]);
			cur=curr;r=n;lst=bl[lq];a.t=0;
		}
		while(r>rq)cur+=a.del(p[r--]);
		ll tmp=cur,tl=l;
		while(tl<lq)tmp+=a.del(p[tl++]);
		while(tl>l)a.undo(),--tl;
		ans[q[i].id]=tmp;
	}
	for(int i=1;i<=m;++i)prt(ans[i]);
	ret 0;
}
```

---

## 作者：WeLikeStudying (赞：23)

- 以前作者的措辞可能不太恰当，但是我觉得这是能够理解的，毕竟你如果生病了就希望世间无病，你退役了就希望大家能够实现自己的梦想，但是这终究只是愿望而已。
- 作者早已退役，但是，如果各位不嫌弃我的祝福的话，我希望大家不要留下遗憾。

**题意**
- [链接](https://www.luogu.com.cn/problem/P8078)。
- 给定一个 $1$ 到 $n$ 的排列，$m$ 次查询一个区间内的所有（区间内）排名相邻的数（对）位置的差（的绝对值）之和。
- $n,m\le 5\times 10^5$。

**分析**
- 容易得到 $O(mn\log n)$ 的做法，即对于每个询问暴力排序。
- 对于 $m=O(n^2)$ 的部分我们可以想到 $O(n^2\log n)$ 的做法：即用 $\text{set}$ 动态更新。
- 如果你学过莫队，只要你学过莫队，你就可以想到 $O(n\sqrt m\log n)$ 的做法，后面的基于删除操作可以用链表 $O(1)$ 维护的回滚莫队优化我都不讲，~~因为我也不会~~因为这不是本文的重点。
- 还有一种值域分块的做法，基于区间询问导致的块内本质不同的方案数在平方级别，好处是容易消耗空间做到在线，这里也略去~~因为我还是不会~~。
- 某位大佬曾经说过：“所以如果在分治结构上很难快速合并某些信息，我们就可以利用分块来做。”
- 反过来，我们如果想要用任何的分治结构做这道题，我们都需要发现一个性质，支持某种程度上比暴力更快地合并区间信息的性质。
- 如何找到支持合并的性质呢？在这之前我们先介绍一个简单的算法。

**猫树分治**
- [有关博客](https://www.luogu.com.cn/blog/command-block/yi-suo-chang-yong-di-shuo-ju-jie-gou-wei-hu-shou-fa)。

```cpp
- 选取所有询问都包含的某个位置,分别向左向右预处理某些东西。
- 对于询问的回答,只需要在左端点取信息,在右端点取信息,再组合即可。这要求(答案/状态)能够合并。
- 然后我们套用猫树分治,就能够处理更一般的情况了。
```

![](https://cdn.luogu.com.cn/upload/image_hosting/4n1p4sv5.png)
- 上图文来自大佬的博客，大佬高产似那啥。
- 这是我在刷大佬的博客中看到的最有希望的篇目（这是因为它只需要**一次**合并），但是它有一个要求：那就是信息能够支持某种意义上的快速合并（即使只需要一次，即使只需要前缀上均值能过），那这道题目是否满足这样的要求？

**性质**
- 我们同样通过 $O(n^2\log n)$ 的做法（或莫队做法），从单点信息的更新推出区间信息的合并。
- 为了方便，我把答案表示成一个链表的形式，横坐标（相对位置）代表其位置，纵坐标（相对位置）代表其大小，连线代表有贡献的相邻字符，答案就是每条连线在横坐标上的投影的和。
- 暴力（或莫队）的增删操作的形式是这样的，找到前驱和后继，然后更新距离的差值。
![](https://cdn.luogu.com.cn/upload/image_hosting/2ngp4o85.png)
- 让我们看看它对两个区间的情况吧。
![](https://cdn.luogu.com.cn/upload/image_hosting/cagvb83v.png)
- 所以我们至少可以看到：如果要快速合并两个区间的话，首先我们关心的是这样的一些数对，它跨过了左右两个区间，如果得到了这样的数对，我们即可支持合并。
- 接下来，我们发现：其实甚至数对我们都不需要，我们对原图劈一刀，我们很快发现我们只需要判断某个点**是否存在**比原序列更前的前驱和后继。
![](https://cdn.luogu.com.cn/upload/image_hosting/z849km1e.png)
- 等等，回忆猫树的过程（从分治中心向左向右预处理某些信息），而这个判断是满足单调性的，所以我实际上只需要在当前处理出让左/右端点存在更前的前驱/后继所需要的左/右区间所需要延长的长度，使用 $\text{set}$ 处理这个问题的复杂度是 $O(n\log n)$ 的，后面的操作相对常规~~对于作者除外~~：
- 对于具体的猫树分治（实现细节），先计算目标区间左边部分的贡献和右边部分的贡献，这里只考虑左边的贡献：
- 首先对目标询问排序。我们从分治中心暴力向左扫，用 $\text{set}$ 维护前驱后继形成的一个有序链表，然后我们考虑链表之间相邻元素对答案的贡献：
- 也就是考虑一条边的贡献，容易发现它分成两个部分：在这两个之间没有一个元素时候的贡献，在这两个之间至少有一个元素时候的贡献，涉及的区间加我们可以用树状数组维护，而查询本质上是一个区间查询操作，我们可以使用线段树。
- 接下来的操作就显得相当无脑，删边相当于删贡献，加边相当于加贡献，还有啥能比这个更简单呢？
![](https://cdn.luogu.com.cn/upload/image_hosting/vnjnk5ab.png)
- 以上操作的时间复杂度是 $O(n\log n)$，这意味着这个做法的时间复杂度是 $O(n\log^2n+m\log n)$。
- 若使用主席树代替那个维护区间加的树状数组则容易做到在线，只不过空间需求略大。

**代码实现**
- 为了表达作者对自己思维实现和代码能力的深刻反省~~同时照顾作者的码力~~，作者决定写多种复杂度的做法。

![](https://cdn.luogu.com.cn/upload/image_hosting/1nym1h20.png)
- 各位同志可以想象一下当时我看到这段文字的心情，来自[这篇](https://www.cnblogs.com/rainybunny/p/15851882.html)，那时我完全看不懂大佬在写啥。
- $O(nm\log n)$ 暴力做法：[代码实现](https://www.luogu.com.cn/paste/ja9updwx)。
- $O(n\sqrt m\log n)$ 普通莫队做法：[代码实现](https://www.luogu.com.cn/paste/rl59v6pi)。
- $O(n\sqrt m\log n/\log w)$ 压 $w=64$ 位 $\text{Trie}$ 维护普通莫队做法：[代码实现](https://www.luogu.com.cn/paste/1869nobo)。
- ~~数据是否太水~~，我觉得出题的时候把 $m$ 开大一点可以卡啊，不卡莫队它和莫队模板有啥区别。
- $O(n\sqrt m)$ 回滚莫队做法（_不加莫队_）：[代码实现](https://www.luogu.com.cn/paste/q333yn25)。
- $O(n\sqrt m)$ 值域分块做法（_Ynoi 风格的纯纯分块预处理_）：[代码实现](https://www.luogu.com.cn/paste/bdztwffm)（被卡常）。
- $O(n\log^2n+m\log n)$ 猫树分治（_polylog 的正解_）做法：[代码实现](https://www.luogu.com.cn/paste/amrdsmkz)（被卡常）。
- 综上，我认为回滚莫队才是此题正解，因为回滚莫队代码极短，而且过这题根本不需要卡常（或许是我的实现太菜了）。

---

## 作者：JiaY19 (赞：22)

[可能更好的阅读体验](https://www.cnblogs.com/mfeitveer/p/16055590.html)

考场上只写了一个 $O(n\sqrt n \log n)$ 的暴力。

然后以为是什么二次离线之类的黑科技，压根没往回滚想。

赛后一提醒立马想到了。

个人觉得想到了还是比较好写的。

### 思路

考虑离线莫队。

暴力做法是用莫队维护左右端点，加入和删除都用一个 $\text{set}$ 或者平衡树去维护，对于答案的修改直接在平衡树中查询。

时间复杂度：$O(n\sqrt n \log n)$

期望：$\text{40pts}$

我们发现这个东西可以用回滚来优化。

由于在暴力做法中平衡树的作用仅仅只是查询前驱和后继，我们知道，对于一个有序的链表，它可以 $O(1)$ 实现这个操作。

所以考虑不增加莫队。

维护一个链表，一个链头，一个链尾。

首先预处理出左右端点为 $\text{1}$ 和 $\text{n}$ 的有序链表，并且计算答案。

接着将询问按左端点所在的块为第一关键字排序。

对于每一个块中的询问。

1. 将左端点删除至此时块的左端点，保存此时的链表。

2. 将由于在同一块内的询问，右端点是递减的，所以可以直接删除。

3. 将此时的链头，链尾，答案保存，方便等一下恢复左端点。

4. 将左端点删除至询问的左端点，统计答案。

5. 由于在挪动完左端点后没有进行其他的操作，所以可以直接恢复，并用之前保存的链头，链尾，答案更新。

6. 循环处理询问，当此时的块内询问处理完之后，将保存的链表复制到此时的链表上，左端点再次回到此时块内的左端点，右端点变为 $\text{n}$。

时间复杂度 $O(n\sqrt n)$。

期望：$\text{100pts}$

这个做法虽然跑的不怎么快，但好像不怎么卡常。

我只是 $\text{cout}$ 被卡 $\text{TLE}$ 了个点，换成 $\text{printf}$ 就可以了。

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

const int N = 500010;

int n , m , t1 , w1 , ans , num , len , tou , wei , pos[N] , sum[N];
pair<int , int> a[N];

struct List
{
    int hou , qian , val;
}q[N] , h[N];

struct Modui
{
    int l , r , id;
    inline bool operator<(const Modui &tmp) const
    {
        return pos[l] == pos[tmp.l] ? r > tmp.r : pos[l] < pos[tmp.l];
    }
}que[N];

#define l(x) (x - 1) * len + 1
#define r(x) min(x * len , n)

inline int read()
{
    int asd = 0 , qwe = 1; char zxc;
    while(!isdigit(zxc = getchar())) if(zxc == '-') qwe = -1;
    while(isdigit(zxc)) asd = asd * 10 + zxc - '0' , zxc = getchar();
    return asd * qwe;
}

inline void del(int x)
{
    if(x != tou) ans -= abs(x - q[x].qian);
    if(x != wei) ans -= abs(x - q[x].hou);
    if(x != tou && x != wei) ans += abs(q[x].qian - q[x].hou);
    if(x == tou) tou = q[x].hou;
    if(x == wei) wei = q[x].qian;
    q[q[x].qian].hou = q[x].hou;
    q[q[x].hou].qian = q[x].qian;
}

inline void add(int x)
{
    q[q[x].qian].hou = x;
    q[q[x].hou].qian = x;
}

inline void cp(List *x , List *y)
{
    for(int i = 1;i <= n;i++)
        x[i] = y[i];
}

signed main()
{
    n = read() , m = read() , len = sqrt(n);
    for(int i = 1;i <= n;i++)
        a[i].first = read() , a[i].second = i;
    sort(a + 1 , a + n + 1) , tou = a[1].second , wei = a[n].second;
    for(int i = 1;i <= n;i++)
        q[a[i].second].qian = a[i - 1].second,
        q[a[i].second].hou = a[i + 1].second;
    for(int i = 1;i <= n;i++) 
        pos[i] = (i - 1) / len + 1;
    for(int i = 1;i <= n;i++)
        if(i != tou) ans += abs(i - q[i].qian);
    for(int i = 1;i <= m;i++)
        que[i].l = read() , que[i].r = read() , que[i].id = i;
    sort(que + 1 , que + m + 1);
    for(int j = 1 , k = 1 , l = 1 , r = n;j <= pos[n] && k <= m;j++)
    {
        if(pos[que[k].l] == j)
        {
            while(l < l(j)) del(l++); 
            cp(h , q) , num = ans;
            t1 = tou , w1 = wei;
            while(pos[que[k].l] == j)
            {
                while(r > que[k].r) del(r--);
                int su = ans , tt = tou , ww = wei;
                while(l < que[k].l) del(l++);
                sum[que[k].id] = ans;
                while(l > l(j)) add(--l);
                k++ , ans = su , tou = tt , wei = ww;
            }
            cp(q , h) , ans = num;
            tou = t1 , wei = w1 , r = n;
        }
    }
    for(int i = 1;i <= m;i++) printf("%lld\n" , sum[i]);
    return 0;
}

```

---

## 作者：myee (赞：15)

### 前言

快写害死人！（场上我快写写挂，痛失 $100pts$）

没想到回滚莫队 + 链表等神仙做法，于是憨憨地打了一个压位 Trie+ 普通莫队。

### 前置芝士
* 普通莫队算法
* [压位 Trie](https://www.luogu.com.cn/blog/DPair2005/ya-wei-trie-xue-xi-bi-ji)

### 解法

你发现暴力莫队 $O(n\sqrt n\log n)$ 很悬。

你考虑优化它。

你发现它要支持插入、删除、前驱、后继操作，即 [Dynamic Predecessor Problem](https://www.luogu.com.cn/problem/U156719)。

平衡树于是可以换成压位 Trie。

然后跑得还蛮快？

复杂度 $O(n\sqrt n\log_wn)$，实测可以通过。

### Code

实现了一个压位 Trie。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ONLINE_JUDGE
/* --------------- fast io --------------- */ // begin
namespace Fread{
const int SIZE= 1 << 16;
	char buf[SIZE],*S,*T;
	inline char getchar(){if(S==T){T=(S=buf)+
	fread(buf,1,SIZE,stdin);if(S==T)return'\n';}return *S++;}
} // namespace Fread
namespace Fwrite {
const int SIZE= 1 << 16;
	char buf[SIZE],*S=buf,*T=buf+SIZE;
	inline void flush(){fwrite(buf,1,S-buf,stdout);S=buf;}
	inline void putchar(char c){*S++=c;if(S==T)flush();}
	struct NTR{~NTR(){flush();}}ztr;
} // namespace Fwrite
#ifdef ONLINE_JUDGE
	#define getchar Fread::getchar
	#define putchar Fwrite::putchar
#endif
#include <algorithm>
#include <math.h>
#include <stdio.h>
#include <vector>
typedef long long llt;
typedef unsigned uint;typedef unsigned long long ullt;
typedef bool bol;typedef char chr;typedef void voi;
typedef double dbl;
template<typename T>bol _max(T&a,T b){return(a<b)?a=b,true:false;}
template<typename T>bol _min(T&a,T b){return(b<a)?a=b,true:false;}
template<typename T>T power(T base,T index,T mod){return((index<=1)?(index?base:1):(power(base*base%mod,index>>1,mod)*power(base,index&1,mod)))%mod;}
template<typename T>T lowbit(T n){return n&-n;}
template<typename T>T gcd(T a,T b){return b?gcd(b,a%b):a;}
template<typename T>T lcm(T a,T b){return(a!=0||b!=0)?a/gcd(a,b)*b:(T)0;}
template<typename T>T exgcd(T a,T b,T&x,T&y){if(!b)return y=0,x=1,a;T ans=exgcd(b,a%b,y,x);y-=a/b*x;return ans;}
const uint Dep=5,W=64,LogW=6,And=W-1,Val=16777216;
ullt BUFF[Val>>LogW<<1|1];
ullt*BT=BUFF+sizeof(BUFF)/sizeof(ullt);
ullt*NewMemory(uint siz){return BT-=siz;}
inline uint hp(ullt v){return W-__builtin_clzll(v)-1;}
inline uint lp(ullt v){return __builtin_ctzll(v);}
struct Trie // 压位 Trie
{
	ullt*Node[Dep-1];
	Trie(){for(uint i=0;i+1<Dep;i++)Node[i]=NewMemory(1llu<<(LogW*i));}
	inline voi insert(uint v)
	{
		for(uint i=Dep-2;~i;i--)
		{
			if(Node[i][v>>LogW]>>(v&And)&1)return;
			Node[i][v>>LogW]|=1llu<<(v&And),v>>=LogW;
		}
	}
	inline voi erase(uint v)
	{
		if(!(Node[Dep-2][v>>LogW]>>(v&And)&1))return;
		for(uint i=Dep-2;~i;i--)
		{
			Node[i][v>>LogW]&=~(1llu<<(v&And)),v>>=LogW;
			if(Node[i][v])return;
		}
	}
	inline uint pre(uint v)
	{
		for(uint i=Dep-2;~i;i--,v>>=LogW)
			if(Node[i][v>>LogW]&~((-1llu)<<(v&And)))
			{
				uint p=hp(Node[i][v>>LogW]&~((-1llu)<<(v&And)))|(v>>LogW<<LogW);
				while(++i<=Dep-2)p=(p<<LogW)|hp(Node[i][p]);
				return p;
			}
        return 0;

	}
	inline uint suf(uint v)
	{
		for(uint i=Dep-2;~i;i--,v>>=LogW)
			if(Node[i][v>>LogW]&((-1llu)<<(v&And)<<1))
			{
				uint p=lp(Node[i][v>>LogW]&((-1llu)<<(v&And)<<1))|(v>>LogW<<LogW);
				while(++i<=Dep-2)p=(p<<LogW)|lp(Node[i][p]);
				return p;
			}
        return 0;
	}
}T;
struct ques{uint l,r,t;}Q[500005];
uint A[500005],Back[500005];
ullt Ans[500005];
ullt ans=0;
#define dist(a,b) Back[a]>Back[b]?Back[a]-Back[b]:Back[b]-Back[a]
inline voi insert(uint v)
{
	uint p=T.pre(v),s=T.suf(v);
	T.insert(v);
	if(p)ans+=dist(p,v);
	if(s)ans+=dist(v,s);
	if(p&&s)ans-=dist(p,s);
}
inline voi erase(uint v)
{
	T.erase(v);
	uint p=T.pre(v),s=T.suf(v);
	if(p)ans-=dist(p,v);
	if(s)ans-=dist(v,s);
	if(p&&s)ans+=dist(p,s);
}
inline uint read()
{
	uint ans=0;chr c;do c=getchar();while(c>'9'||c<'0');
	do ans=ans*10+(c^'0'),c=getchar();while(c<='9'&&c>='0');return ans;
}
inline voi write(ullt v)
{
	static chr c[18];uint cnt=0;do c[cnt++]=v%10+'0',v/=10;while(v);
	while(cnt--)putchar(c[cnt]);
	putchar('\n');
}
int main()
{
	 // freopen("rrad_s_500000.in","r",stdin);
	 // freopen("rrads.out","w",stdout);
	uint n,m;n=read(),m=read();
	uint Siz=n/(sqrt(m)+1.2)*sqrt(1.5)+5;
	// 莫队 O(n\sqrt m\log_w n)
	for(uint i=0;i<n;i++)Back[A[i]=read()]=i;
	for(uint i=0;i<m;i++)Q[i].l=read()-1,Q[i].r=read(),Q[i].t=i;
	std::sort(Q,Q+m,[Siz](const ques&a,const ques&b){return a.l/Siz==b.l/Siz?((a.l/Siz)&1)?a.r>b.r:a.r<b.r:a.l<b.l;});
	uint l=0,r=0;
	for(uint i=0;i<m;i++)
	{
		ques&qs=Q[i];
		while(l>qs.l)insert(A[--l]);
		while(r<qs.r)insert(A[r++]);
		while(r>qs.r)erase(A[--r]);
		while(l<qs.l)erase(A[l++]);
		Ans[qs.t]=ans;
	}
	for(uint i=0;i<m;i++)write(Ans[i]);
    return 0;
}
```



---

## 作者：Miko35 (赞：11)

回顾一下这道我翻车的 DS... 越来越菜了

### 其他做法

两种根号做法大家应该都会，就不讲了。

算了还是提一下：分块就是考虑值域块知道前驱后继是可以合并的，变成了 Set Merging；莫队就是需要维护前驱后继，带删除容易用链表维护就回滚一下。

### 正解

说点前置转化，把这个过程想象为：我一开始身处 $[l,r]$ 中最小值的位置，需要在序列上走路去按权值顺序遍历 $[l,r]$ 这个区间，答案是我走的步数。

离线分治，$\operatorname{Solve}(l,r)$ 时解决跨越 $mid = \dfrac{l+r}{2}$ 的询问，也就是说如果这个询问是 $[L,R]$ 的话我把它劈两半，分别计算出在 $[L,mid]$ 与 $[mid+1,R]$ 中走的步数。

以 $[L,mid]$ 为例来说明，令 $N$ 为区间长度。假设我已经知道了区间中权值的大小顺序 $p_1,p_2, \ldots, p_{N}$ ($a_{p_1}<a_{p_2}<\ldots<a_{p_{N}}$)，那么我考虑相邻两个数 $p_i$ 与 $p_{i+1}$ 的贡献 $f(p_i,p_{i+1})$：

- 若 $a_{p_i}$ 与 $a_{p_{i+1}}$ 在询问区间 $[L,R]$ 中是相邻的两个权，则贡献为 $|p_i - p_{i+1}|$；
- 否则贡献为 $(mid-p_i)+(mid-p_{i+1})$。

我们把 $i$ 从 $mid \to l$ 扫，每次解决左端点为 $i$ 的询问。此时相当于添加一个元素 $a_i$ 同时维护贡献的增量，也就是 $f(P,S)-f(P,a_i)-f(S,a_i)$，其中 $P,S$ 分别表示 $a_i$ 在 $(i,mid]$ 中的前驱后继。

添数查前驱后继可以时间倒流 $O(N)$ 维护。那么我现在手上有 $O(N)$ 组 $f(x,y)$，需要对于左端点在 $i$ 的每个右端点 $R$ 求出这些 $f$ 的和。

现在需要找出合理的方式刻画「在 $[L,R]$ 中相邻」这个条件，不难发现可以使用「从左往右第一个值域在 $[p_i,p_{i+1}]$ 的位置 $>R$」来做，把它记为 $\operatorname{find}(p_i,p_{i+1})$。回到原问题，我们得到了 $f(x,y)$ 的取值：

$$
f(x,y)=\begin{cases}
2mid-x-y &\operatorname{find}(x,y)\leq R\\
|x-y| &\rm{otherwise}
\end{cases}
$$

统计在扫到 $L$ 之前加入、且 $\operatorname{find}(x,y)\leq R$ ($>R$) 的 $\sum f(x,y)$，明示离线二维数点。

可以使用树状数组维护，时间复杂度 $O(n \log^2 n+m \log n)$，也可以使用多叉线段树平衡复杂度至 $O\left(\dfrac{(n+m) \log^2 n}{\log\log n}\right)$。


---

## 作者：Fido_Puppy (赞：7)

## $\mathcal{Question}$

[P8078 [WC2022] 秃子酋长](https://www.luogu.com.cn/problem/P8078)

题目意思比较清晰，这里就不解释了。

## $\mathcal{Solution}$

我们考虑莫队。

首先 $\Theta (n\sqrt{n}\ log\ n)$ 的莫队是挺好想的。

我们可以用一个数据结构来维护每次我们两个指针枚举到的序列，答案暴力修改即可。

如果是平衡树之类的，那么插入的时间复杂度为 $\Theta(log\ n)$，如果是 vector，那么插入的时间复杂度为 $\Theta(\text{玄学})$，二分查找的时间复杂度为 $\Theta(log\ n)$。

无论怎么样，这个时间复杂度是不能通过此题的。

由于加入的时候时间复杂度总是 $\Theta(log\ n)$。~~（也许是我太菜了想不出来）~~

所以我们可以考虑只删不加回滚莫队。

对于每个数的删除，我们可以考虑用链表。

但是 C++ 自带的链表无法快速的找到一个数的位置。~~（也许又是我逊了）~~

我们就考虑双向链表。

双向链表就是将链表用数组的形式储存下来。

我们定义两个数组 $L$ 和 $R$。

$L_i$ 表示 $i$ 节点左边的节点编号。

$R_i$ 表示 $i$ 节点右边的节点编号。

我们可以以权值作为关键字来建立双向链表。

意思就是 $L_{a_i}$ 表示 $i$ 节点左边的节点的权值，$R_{a_i}$ 表示 $i$ 节点右边的节点的权值。

于是我们就可以快速的找到一个数的位置。（也就是它左右两边的数）

双向链表的插入和删除也都是 $\Theta(1)$ 的。

在 $a$ 和 $b$ 节点之间插入 $x$ 节点。

```cpp
L[x] = a; R[x] = b;
R[a] = x; L[b] = x;
```

把 $a$ 和 $b$ 节点之间的 $x$ 节点删除。

```cpp
L[a] = b;
R[b] = a;
```
然后我们暴力更新答案即可。

时间复杂度 $\Theta(n\sqrt{n})$。

但是这道题的第 $17$ 个测试点并不是很友好。

我们加上快读，并且将块长设成 $1000$ 就能卡过去了。

## $\mathcal{Code}$

十年 OI 一场空，不开 long long 见祖宗。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
static char buf[100010], *p1 = buf, *p2 = buf;
#define gc p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 100010, stdin), p1 == p2)? EOF: *p1++
inline int read() {
	int res = 0, w = 0;
	char c = gc;
	while (!isdigit(c))
		w ^= c == '-', c = gc;
	while (isdigit(c))
		res = (res << 1) + (res << 3) + (c ^ 48), c = gc;
	return (w? -res: res);
}
inline void write(LL x) {
	static int sta[50], top = 0;
	if (x < 0) putchar('-'), x = -x;
	do {
		sta[ top++ ] = x % 10;
		x /= 10;
	} while (x);
	while (top) putchar(sta[ --top ] + 48);
	putchar('\n');
}
const int MAXN = 5e5 + 10;
int n, m, a[MAXN], siz, bnum, belong[MAXN];
LL ans[MAXN];
struct query {
	int l, r, id;
}q[MAXN];
int L[MAXN], R[MAXN], cnt[MAXN];
inline bool cmp(query a, query b) {
	if (belong[ a.l ] ^ belong[ b.l ]) return belong[ a.l ] < belong[ b.l ];
	return a.r > b.r;
}
inline int doit(int Qnum, int x) {
	memset(L, 0, sizeof(L));
	memset(R, 0, sizeof(R));
	memset(cnt, 0, sizeof(cnt));
	int left = (x - 1) * siz + 1;
	int l = left, r = q[Qnum].r, i = Qnum, last = 0;
	LL now = 0;
	for (int i = l; i <= r; i++)
		cnt[ a[i] ] = i;
	for (int i = 1; i <= n; i++)
		if (cnt[i]) {
			if (last) now += 1ll * abs(cnt[i] - cnt[last]);
			R[last] = i;
			L[i] = last;
			last = i;
		}
	for (; belong[ q[i].l ] == x; i++) {
		while (r > q[i].r) {
			int Left = L[ a[r] ], Right = R[ a[r] ];
			if (Left) now -= 1ll * abs(cnt[ a[r] ] - cnt[Left]);
			if (Right) now -= 1ll * abs(cnt[Right] - cnt[ a[r] ]);
			if (Left && Right) now += 1ll * abs(cnt[Right] - cnt[Left]);
			R[Left] = Right;
			L[Right] = Left;
			cnt[ a[r] ] = 0;
			r--;
		}
		LL temp = now;
		while (l < q[i].l) {
			int Left = L[ a[l] ], Right = R[ a[l] ];
			if (Left) now -= 1ll * abs(cnt[ a[l] ] - cnt[Left]);
			if (Right) now -= 1ll * abs(cnt[Right] - cnt[ a[l] ]);
			if (Left && Right) now += 1ll * abs(cnt[Right] - cnt[Left]);
			R[Left] = Right;
			L[Right] = Left;
			cnt[ a[l] ] = 0;
			l++;
		}
		ans[ q[i].id ] = now;
		now = temp;
		for (int j = left; j < l; j++) {
			int Left = L[ a[j] ], Right = R[ a[j] ];
			R[Left] = a[j];
			L[Right] = a[j];
			cnt[ a[j] ] = j;
		}
		l = left;
	}
	return i;
}
int main() {
	n = read(); m = read(); siz = 1000; bnum = (n - 1) / siz + 1;
	for (int i = 1; i <= bnum; i++)
		for (int j = (i - 1) * siz + 1; j <= min(n, i * siz); j++)
			belong[j] = i;
	for (int i = 1; i <= n; i++) a[i] = read();
	for (int i = 1; i <= m; i++) {
		q[i].l = read(); q[i].r = read();
		q[i].id = i;
	}
	sort(q + 1, q + m + 1, cmp);
	int Qnum = 1;
	for (int i = 1; i <= bnum; i++) {
		Qnum = doit(Qnum, i);
	}
	for (int i = 1; i <= m; i++)
		write(ans[i]);
	return 0;
}
```
完结撒花 ^_の

---

## 作者：Exber (赞：7)

## 做法

莫队。

这道题显然要维护一个有序的序列，支持插入、删除和求前驱后继。

发现可以离线，数据范围也允许根号算法，所以考虑莫队。

容易发现，如果**没有插入操作的话，前驱后继只要仿照双向链表删除的方法来维护就行了**。所以考虑不插入的回滚莫队。

仿照不删除的回滚莫队：

首先**把莫队区间设置为 $[1,n]$**。

排序时先按左端点块编号升序排序，对于块编号一样的情况，按右端点**降序**排序。这样就能保证左端点块编号相同的询问右端点**只需要收缩而不需要扩展了**。需要注意的是，**对于左端点和右端点在同一块内的情况，不需要暴力处理**。

考虑处理连续的一段左端点块编号相同的询问。可以**先把莫队区间右端点移到 $n$，左端点为当前块的左端点**，每次缩区间的时候右端点就可以保持只往左缩了。由于左端点不一定只往右边缩，所以我们需要**先把右端点缩完，再把左端点缩到适当的位置，求出当前的答案**。

和不删除的回滚莫队不一样的是，**缩左端点和右端点时要把一路上更改的前驱后继用栈记录下来，这样执行“回滚”操作时就能成功恢复了，处理下一个块时右端点也能顺利恢复到 $n$**。

求出当前答案后就需要进行“回滚”操作了，具体就是**按照栈中的值来更新答案并且扩展左端点**。

注意**要特判没有前驱或者后继的节点**，然后就是**要开 `long long`**。

## AC 代码

```cpp
#include <iostream>
#include <algorithm>
#include <cstdio>
#include <cmath>

using namespace std;

const long long MS=500005;

struct pr
{
	int x,y;
}b[MS];

struct tr
{
	int x,y,z;
}sta[MS];

struct node
{
	int l,r,id;
}que[MS];

int n,m,blo;
int L[MS],a[MS];
int fir[MS],nxt[MS];
long long preans,ans[MS];
int top;

inline bool cmp(node x,node y)
{
	int xid=(x.l-1)/blo+1,yid=(y.l-1)/blo+1;
	return xid!=yid?x.l<y.l:x.r>y.r;
}

inline bool cmp2(pr x,pr y)
{
	return x.x<y.x;
}

inline void del(int x)
{
	int lb=fir[x],rb=nxt[x];
	sta[++top]=(tr){lb,x,rb};
	nxt[lb]=rb;
	if(rb==x)
	{
		nxt[lb]=lb;
	}
	fir[rb]=lb;
	if(lb==x)
	{
		fir[rb]=rb;
	}
	preans-=abs(x-lb)+abs(x-rb);
	if(lb!=x&&rb!=x)
	{
		preans+=abs(lb-rb);
	}
}

inline void bak()
{
	int lb=sta[top].x,x=sta[top].y,rb=sta[top].z;
	top--;
	fir[x]=lb;
	if(lb!=x)
	{
		nxt[lb]=x;
	}
	nxt[x]=rb;
	if(rb!=x)
	{
		fir[rb]=x;
	}
	if(lb!=x&&rb!=x)
	{
		preans-=abs(lb-rb);
	}
	preans+=abs(x-lb)+abs(x-rb);
}

int main()
{
	scanf("%d%d",&n,&m);
	blo=sqrt(n);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&a[i]);
		b[i].x=a[i];
		b[i].y=i;
		L[i]=(i-1)/blo!=(i-2)/blo||i==1?i:L[i-1];
	}
	for(int i=1;i<=m;i++)
	{
		scanf("%d%d",&que[i].l,&que[i].r);
		que[i].id=i;
	}
	sort(que+1,que+m+1,cmp);
	int lpos=1,rpos=n;
	sort(b+1,b+n+1,cmp2);
	fir[b[1].y]=b[1].y;
	nxt[b[n].y]=b[n].y;
	for(int i=2;i<=n-1;i++)
	{
		fir[b[i].y]=b[i-1].y;
		nxt[b[i-1].y]=b[i].y;
		nxt[b[i].y]=b[i+1].y;
		fir[b[i+1].y]=b[i].y;
		preans+=abs(b[i].y-b[i-1].y);
	}
	preans+=abs(b[n].y-b[n-1].y);
	for(int i=1;i<=m;i++)
	{
		int l=que[i].l,r=que[i].r,id=que[i].id;
		int LL=L[l],lstL=L[que[i-1].l];
		if(LL!=lstL)
		{
			while(top>0) bak();
			lpos=max(1,lstL);
			rpos=n;
			while(lpos<LL) del(lpos++);
			top=0;
		}
		while(rpos>r) del(rpos--);
		while(lpos<l) del(lpos++);
		ans[id]=preans;
		while(lpos>LL) bak(),lpos--;
	}
	for(int i=1;i<=m;i++)
	{
		printf("%lld\n",ans[i]);
	}
	return 0;
}
```

---

## 作者：LinkyChristian (赞：3)

泪洒考场的一道题...

首先是莫队的 $O(n \sqrt n logn)$ 做法。具体实现就是在做普通莫队的过程中用一个set来实时维护排序后的序列。在插入一个数时加上它与其前驱和后继的贡献，在删除一个数时去掉它的贡献并把原前驱后缀的贡献补上。通过此法可以拿到 $50pt$ （我考场上以为能拿60）。

然后我在考场上也想过优化，我想到了只加版本的回滚莫队，但是觉得只加的复杂度与普通莫队差不多，就把回滚莫队pass了。结果考后听同学说可以用只删回滚莫队![/dk](https://cdn.luogu.com.cn/upload/pic/62228.png)，就可以把 $log$ 去掉。

考虑一下只加[回滚莫队](https://lookcatbox.blog.luogu.org/hui-gun-mu-dui-chu-bu-zong-jie)和普通莫队的复杂度瓶颈。没错，就是查找前驱后继。在一般的情况下，查找前驱后继的复杂度是一个不可省略的 $log$ 。但是我们可以预先把前驱后继维护好。具体而言，我们将只加回滚莫队的 $l$ 指针从当前块右端点向左扫到当前询问左端点，改为从当前块左端点向右扫到当前询问左端点。在将指针复位到当前块左端点时直接将整个块的元素加入链表，并在扫到当前询问左端点的过程中将元素从链表中一一删除。对于右端点同理，排序询问时我们将左端点在同一个块内的询问按右端点降序排序，将当前块右端点到 $n$ 的元素加入链表，之后 $r$ 指针从 $n$ 往当前询问右端点扫，并执行删除操作。由于我们一开始就将所有元素加入了链表，因此在删除一个元素时查询元素的前驱后继的复杂度是 $O(1)$ 的。总复杂度 $O(n \sqrt n)$，可以通过本题。

![](https://cdn.luogu.com.cn/upload/image_hosting/ccfkmcd3.png)

总结一下流程：

- 将 $1 \sim n$ 的元素加入链表

- 处理当前块的询问

----

**对一个块内的所有询问而言**

- 将 $l$ 指针恢复到当前块左端点，并消除上一个询问 $l$ 指针造成的贡献。

- $l$ 指针从当前块左端点扫到当前询问左端点，$r$ 指针从上一个询问右端点扫到这一个询问右端点，并把两个指针扫到的区域删除。

----

- 将当前块的贡献消除，处理下一个块的贡献。

本题到此完全解决~~其实这个做法不是lxl的正解~~代码咕咕了。


---

## 作者：jia_shengyuan (赞：2)

考场上写的代码挂了 $30$ 分（

首先考虑纯暴力，每一次遍历 $[l,r]$ 将值插入 `set` 中，同时根据前驱后继更新答案，时间复杂度 $O(nm\log n)$。

不难发现可以基于刚才的暴力写莫队，将时间复杂度优化至 $O(n\sqrt m \log n)$，能过 $40$ 分。

考虑怎么甩掉 $\log$。因为莫队是“优雅的暴力”，暴力能优化的，莫队基本就能优化，因此不妨从最初的暴力着手。不难发现用 `set` 维护前驱后继导致我们额外“排序”了很多次，而实际上我们只要排序一次其实就够了：预处理时将 $a$ 排序，对于一个询问，我们扫一遍排序后的 $a$（这时我们知道每个数在原序列中对应的位置），于是就能 $O(n)$ 处理出 $[l,r]$ 排序后的序列求得答案。

考虑使用莫队进行这一过程，用链表维护在当前区间内的数排序后的序列，则可以 $O(1)$ 查询某数的前驱后继、删除某元素，但插入需要 $O(n)$ 的时间。于是使用不插入莫队（每一块内按 `R` 降序排列，每次先将 `L` 拉回块的左端点，之后移动 `R`，再移动 `L`，完成后回退 `L` 进行的所有操作）即可 $O(n\sqrt m)$。

代码中使用了自己的快读库。**一定要自己写绝对值函数。**

```cpp
#include <algorithm>
#include <cmath>
#define ll long long

const int maxn = 5e5+9;

struct Query {
    int l,r,ind,bid;
    inline bool operator < (const Query& o) const {
        if(bid == o.bid) return r > o.r;
        return l < o.l;
    }
}qs[maxn];
struct pr {
    int *p,v;
};

int a[maxn],bid[maxn],bl[maxn],br[maxn],pre[maxn],nxt[maxn],pos[maxn],top,n,q,head,tail,L,R;
pr sta[maxn];
ll ans[maxn],curans;
double lxl;

inline int Abs(int x) noexcept { return x>0?x:-x; }

void Init(){
    read(n,q);
    lxl = (double)n/sqrt(q);
    for(int i=1; i<=n; ++i) {
        read(a[i]);
        pos[a[i]]=i;
        bid[i] = round(i/lxl);
        if(!bl[bid[i]]) bl[bid[i]] = i;
        br[bid[i]] = i;
    }
    for(int i=1; i<=q; ++i){
        read(qs[i].l,qs[i].r);
        qs[i].ind=i;
        qs[i].bid=bid[qs[i].l];
    }
    std::sort(qs+1,qs+q+1);
}

inline void InitBid(int p) noexcept {
    curans=0; head=tail=0;
    for(int i=1; i<=n; ++i){
        if(pos[i] >= bl[p]) {
            if(tail) {
                nxt[tail] = i;
                pre[i] = tail;
                curans += Abs(pos[i]-pos[tail]);
            } else head=i;
            tail=i;
        }
    }
    nxt[tail]=pre[head]=0;
}

inline void ShrinkR() noexcept {
    int now = a[R--];
    if(nxt[now]){
        pre[nxt[now]] = pre[now];
        curans -= Abs(pos[now]-pos[nxt[now]]);
    }
    if(pre[now]) {
        nxt[pre[now]]=nxt[now];
        curans -= Abs(pos[now]-pos[pre[now]]);
    }
    if(nxt[now] && pre[now]) curans += Abs(pos[pre[now]]-pos[nxt[now]]);
}
inline void ShrinkL() noexcept {
    int now = a[L++];
    if(nxt[now]){
        sta[++top] = {&pre[nxt[now]],pre[nxt[now]]};
        pre[nxt[now]] = pre[now];
        curans -= Abs(pos[now]-pos[nxt[now]]);
    }
    if(pre[now]) {
        sta[++top] = {&nxt[pre[now]],nxt[pre[now]]};
        nxt[pre[now]] = nxt[now];
        curans -= Abs(pos[now]-pos[pre[now]]);
        if(nxt[now]) curans += Abs(pos[pre[now]]-pos[nxt[now]]);
    }
}

void Solve() noexcept {
    ll tmpans;
    for(int i=1,p=-1; i<=q; ++i){
        Query &now = qs[i];
        if(now.bid != p){
            InitBid(p = now.bid);
            L=bl[p];
            R=n;
        }
        while(R > now.r) ShrinkR();
        top=0; tmpans = curans;
        while(L < now.l) ShrinkL();
        ans[now.ind] = curans;
        curans = tmpans;
        while(top){
            *sta[top].p = sta[top].v;
            --top;
        }
        L = bl[p];
    }
}

int main(){
    Init();
    Solve();
    for(int i=1; i<=q; i++) writeln(ans[i]);
    fastio_flush();
    return 0;
}
```


---


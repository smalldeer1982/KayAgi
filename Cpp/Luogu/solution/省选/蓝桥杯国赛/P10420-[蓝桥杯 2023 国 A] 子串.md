# [蓝桥杯 2023 国 A] 子串

## 题目描述

给定一个仅含小写英文字母组成的字符串 $S$，问有多少个不同的字符串在 $S$ 中出现 $1\sim |S|$ 次。当两个字符串的长度或任意位置的字符不同时，我们认为这两个字符串是不同的。

## 说明/提示

**【样例解释 1】**

`a`，`ab`，`bb`，`abb` 出现了一次，`b` 出现了两次。

**【评测用例规模与约定】**

对于 $20\%$ 的评测用例，$|S|\le 300$；  
对于 $40\%$ 的评测用例，$|S|\le 5000$；  
对于所有评测用例，$1\le |S|\le 10^6$。

## 样例 #1

### 输入

```
abb
```

### 输出

```
4
1
0```

# 题解

## 作者：Yukii_P (赞：2)

## 题意简述
计算字符串 $S$ 总共出现过 $k$ 次的子串的个数，其中 $k \in \left[1,\lvert S \rvert\right]$ 。
## 题目分析
询问所有子串的出现次数，容易想到使用后缀自动机来解决。建好后缀自动机后再建立后缀链接树，可以计算每个 endpos 状态对应子字符串的出现次数；记后缀自动机上某个点为 $i$，其后缀链接为 $fa[i]$，这个节点对应的最长子字符串长度为 $len[i]$，由于后缀自动机上对应子串长度是连续递增的，这个节点对应的子字符串集合的大小就是 $len[i]-len[fa[i]]$，我们统计所有的节点信息即可。

时间复杂度 $O(n)$，可以通过本题。 
## 参考代码

```cpp
#include <bits/stdc++.h>
#define FIO cin.tie(0); ios::sync_with_stdio(false)
#define all(x) (x).begin(), (x).end()
#define fi first
#define se second
#define TEST
#define TESTS int t = 1; cin >> t; while (t--)

using namespace std;
using i64 = long long;

constexpr int N = 2e5 + 10;
constexpr int MOD = 998244353;

void solve() {
    string s;
    cin >> s;
    int n = s.size();
    vector<array<int, 26>> ch(n * 2);
    vector<int> fa(n * 2), len(n * 2);
    vector<i64> cnt(n * 2);
    int np = 1, tot = 1;
    auto extend = [&](int c) {
        int p = np;
        np = ++tot;
        len[np] = len[p] + 1; cnt[np] = 1;
        for ( ; p && !ch[p][c]; p = fa[p]) ch[p][c] = np;
        if (p == 0) fa[np] = 1;
        else {
            int q = ch[p][c];
            if (len[p] + 1 == len[q]) fa[np] = q;
            else {
                int nq = ++tot;
                len[nq] = len[p] + 1;
                fa[nq] = fa[q], fa[q] = fa[np] = nq;
                for ( ; p && ch[p][c] == q; p = fa[p]) ch[p][c] = nq;
                ch[nq] = ch[q];
            }
        }
    };
    for (char c : s) extend(c - 'a');
    vector<i64> ans(n + 1);
    vector<vector<int>> e(n * 2);
    for (int i = 2; i <= tot; ++i) e[fa[i]].push_back(i);
    auto dfs = [&](auto&& dfs, int u) -> void {
        for (int v : e[u]) {
            dfs(dfs, v);
            cnt[u] += cnt[v];
        }
    };
    dfs(dfs, 1);
    for (int i = 2; i <= tot; ++i) {
        ans[cnt[i]] += len[i] - len[fa[i]];
    }
    for (int i = 1; i <= n; ++i) cout << ans[i] << "\n";
}

signed main() {
    
    FIO;
    solve();

    return 0;
}
```

---

## 作者：Mirasycle (赞：1)

后缀自动机模板题。

建立 SAM 之后，我们可以通过在 parent tree 上递推求出每个状态的出现次数。具体来说，增量法构建 SAM 的时候，我们会构建一些实点，也会为了 endpos 集合分裂而开一些辅助点，只有对于那些实点我们才会为其赋值为 $1$。然后最后顺着 parent tree 上的 link 递推一遍即可求出每个 endpos 等价类在字符串中的出现次数。

每个 endpos 等价类中的字符串长度连续，所以对于每个状态的字符串数目可以通过 $len(u)-len(fa_u)$ 得到。

时间复杂度 $O(n)$。


```cpp
#include<bits/stdc++.h>
#define pb emplace_back
#define fi first
#define se second
#define mp make_pair
using namespace std;
typedef long long ll;
const int maxn=2e6+10;
struct edge{
	int to,Next;
}edges[maxn];
char s[maxn]; int cnt=0,tot=1;
int ch[maxn][27],len[maxn],fa[maxn]; 
ll ans[maxn],sum[maxn]; int head[maxn],last=1;
void Add(int u,int v){
	edges[++cnt]=(edge){v,head[u]};
	head[u]=cnt;
}
void add(int c){
	int p=last; int np=last=++tot;
	len[np]=len[p]+1; sum[np]=1;
	for(;p&&!ch[p][c];p=fa[p]) ch[p][c]=np;
	if(!p) fa[np]=1;
	else{
		int q=ch[p][c];
		if(len[q]==len[p]+1) fa[np]=q;
		else{
			int nq=++tot;  memcpy(ch[nq],ch[q],sizeof(ch[q]));
			fa[nq]=fa[q]; len[nq]=len[p]+1;
			fa[q]=fa[np]=nq;
			for(;p&&ch[p][c]==q;p=fa[p]) ch[p][c]=nq;
		}
	}
}
void dfs(int u){
	for(int i=head[u];i;i=edges[i].Next){
		int v=edges[i].to;
		dfs(v); sum[u]+=sum[v];
	}
	ans[sum[u]]+=len[u]-len[fa[u]];
}
int main(){
	ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);
	cin>>(s+1); int n=strlen(s+1);
	for(int i=1;i<=n;i++) add(s[i]-'a');
	for(int i=2;i<=tot;i++) Add(fa[i],i);
	dfs(1);
	for(int i=1;i<=n;i++) cout<<ans[i]<<"\n"; 
	return 0;
}
```

---


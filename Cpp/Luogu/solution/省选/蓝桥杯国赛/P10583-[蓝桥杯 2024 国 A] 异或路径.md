# [蓝桥杯 2024 国 A] 异或路径

## 题目描述

给定一棵有 $n$ 个结点的树，结点 $1$ 至 $n$ 编号。编号为 $x > 1$ 的结点与编号为 $\lfloor \sqrt x \rfloor$
 的结点有一条权值为 $x-\lfloor \sqrt x \rfloor ^ 2$ 的边。
 
定义一条路径的价值为这条路径上的所有边的权值的异或和。如果两条路径包含不同的边，则认为这两条路径不同。求这棵树的所有本质不同的简单路的价值的乘积（价值为 $0$ 的除外），答案对 $998\ 244\ 353$ 取模。

## 说明/提示

对于 $40\%$ 的评测用例，$n\le 10^3$；  
对于 $70\%$ 的评测用例，$n\le 10^6$；  
对于所有评测用例，$1\le n\le 10^9$。

## 样例 #1

### 输入

```
5```

### 输出

```
36```

# 题解

## 作者：Amidst (赞：14)

~~调了一晚上看了半天没看出来结果今天早上发现 FWT 挂了。~~

## 思路

本题解思路基于现有题解，但会讲得详细些，也会谈到一些可能存在的坑点。

首先考虑 $n\le 10^6$ 的做法。显然我们可以直接建出这棵树，再对其求出贡献。我们发现问题变成了 [UVA13277](https://www.luogu.com.cn/problem/UVA13277)，预处理每个节点 $i$ 到 $1$ 的路径上的权值异或和 $d_i$，再开个桶，记录每个值出现的次数，将这个桶 FWT 自卷积即可，最后将答案除以 $2$，统计答案时将每一位的下标和值分别作为底数和指数进行快速幂，最后相乘。

注意到原题中的连边方式是 $x$ 向 $\lfloor \sqrt x \rfloor$ 连边，于是非叶子节点数量必然小于等于 $\sqrt n$。

考虑根号分治，即设立阈值 $B$，将小于等于 $B$ 的部分和大于 $B$ 的部分分别讨论。

对于前半部分显然可以依照 $n\le 10^6$ 的做法处理。

对于后半部分，考虑连续的 $x$ 与 $\lfloor \sqrt x\rfloor$ 的边权值变化规律，可以先按照 $\lfloor\sqrt x\rfloor$ 的值分成 $\left(\lfloor\sqrt n\rfloor - \lfloor n^{1/4}\rfloor\right)$ 段，显然每一段的每条边权都可以表示为 $d_k \oplus w$，其中 $w$ 是连续自然数。

考虑每个 $x$ 的贡献来源，有 $d_k \oplus l = x$，则 $d_k \oplus x = l$，我们只需确定 $l$ 的极值，然后就可以在 01trie 上乱搞。

不妨在走边的过程中统计答案，计算每个点的子树内的贡献，将其加到对应的桶中，与小于等于 $B$ 的部分得到的桶中的值按位相加，最后 FWT 自卷积即可。

注意阈值 $B$ 不要太小，至少要大于 $\sqrt n$，否则会造成部分非叶子节点被当成叶子节点计算。FWT 时注意异或卷积时使用除以 $2$ 而不是乘 $0.5$。同时由于是快速幂，根据费马小定理，

$$a^{p-1}\equiv 1 \pmod p$$

可以将 FWT 得到的指数模 $p-1$ 以后再快速幂，注意指数仍要像 $n\le 10^6$ 时一样除以 $2$。

时间复杂度 $O(\sqrt n \log n)$。

---

## 作者：Reunite (赞：3)

先考虑 $n\le 10^6$ 怎么做，显然可以直接求出 $d_i$ 表示 $i$ 到根链上边权异或和，那么把 $d_i$ 全部丢到桶里，FWT 一下，取指数的一半用快速幂算一下即可做到 $O(n\log n)$。

考虑非叶节点很少，只有 $\sqrt n$ 个，先暴力预处理这些点的 $d_i$，考虑剩下的所有点一定是叶节点，且父亲一定在 $\sqrt n$ 个点内。注意到此时对于一个点，它连向所有叶节点的权值变化连续，如果我们取一个较好的阈值，比如 $39999$，那么所有边权都是形如 $d_i\oplus_{j\le r_i}j$ 的形式的，我们希望把这些统一在桶上修改。

直接暴力可以通过，常数极小，但是非常不优美，考虑一个 $x$ 可以被哪些 $(d_i,r_i)$ 贡献到，有 $d_i\oplus y=x$，$y=x\oplus d_i \le r_i$，这个是经典问题，丢到 trie 树上每次走限制最严的边给令一边合法时打标记即可。

复杂度 $O(\sqrt n\log n)$。

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <cmath>
#include <vector>
using namespace std;

#define int long long
#define mod 998244353
#define B 39999ll
#define V 65536ll

int n,tot=1;
int d[B+5];
int f[2*V+5];
int tg[4*V+5];
int ed[2*V+5];
int ch[4*V+5][2];
vector <pair <int,int>> g[B+5];

inline void dfs(int u){
	for(auto tmp:g[u]){
		int v=tmp.first,w=tmp.second;
		d[v]=d[u]^w;
		dfs(v);
	}
	return ;
}

inline void FWT(int op){
	for(int o=2,k=1;o<=V;o<<=1,k<<=1){
		for(int i=0;i<=V;i+=o){
			for(int j=0;j<k;j++){
				int x=f[i+j],y=f[i+j+k];
				if(op==1){
					f[i+j]=(x+y)*op;
					f[i+j+k]=(x-y)*op;
				}
				else{
					f[i+j]=(x+y)/2;
					f[i+j+k]=(x-y)/2;
				}
			}
		}
	}
	return ;
}

inline int calc(int x,int k){
	int tmp=1;
	while(k){
		if(k&1) tmp=tmp*x%mod;
		x=x*x%mod;
		k>>=1;
	}
	return tmp;
}

inline int ins(int x){
	int u=1;
	for(int i=16;i>=0;i--){
		int k=(x>>i)&1;
		if(!ch[u][k]) ch[u][k]=++tot;
		u=ch[u][k];
	}
	return u;
}

inline void ins(int u,int x,int y,int d){
	if(!u) return ;
	if(d<0){tg[u]++; return ;}
	int k=(x>>d)&1;
	if((y>>d)&1){
		tg[ch[u][k]]++;
		ins(ch[u][k^1],x,y,d-1);
	}
	else ins(ch[u][k],x,y,d-1);
	return ;
}

inline void down(int u){
	if(!u) return ;
	tg[ch[u][0]]+=tg[u];
	tg[ch[u][1]]+=tg[u];
	down(ch[u][0]),down(ch[u][1]);
	return ;
}

signed main(){
	scanf("%lld",&n);
	for(int i=2;i<=min(n,B);i++){
		int fa=(int)sqrt(i);
		g[fa].push_back({i,i-fa*fa});
	}
	dfs(1);
	for(int i=1;i<=min(n,B);i++) f[d[i]]++;
	if(n>B){
		for(int i=0;i<=V;i++) ed[i]=ins(i);
		for(int i=(int)sqrt(B+1);i<=B;i++){
			int r=min(n,(i+1)*(i+1)-1)-i*i;
			if(r<0) break;
			ins(1,d[i],r,16);
		}
		down(1);
		for(int i=0;i<=V;i++) f[i]+=tg[ed[i]];
	}
	FWT(1);
	for(int i=0;i<=V;i++) f[i]=f[i]*f[i];
	FWT(2);
	int ans=1;
	for(int i=1;i<=V;i++) ans=ans*calc(i,f[i]/2%(mod-1))%mod;
	printf("%lld\n",ans);

	return 0;
}
```

---

## 作者：zhouyuhang (赞：2)

摘自本题讨论区我的回复。

> 以下给出一种比较合理的做法：
>
> 熟知的，记 $d_u$ 为根到 $u$ 路径上的异或和，则 $u$ 到 $v$ 路径的异或和即为 $d_u \oplus d_v$。同时注意到 $x - \lfloor \sqrt x \rfloor ^ 2 \le 2 \sqrt x = O(\sqrt n)$，因此 $d_u$ 的范围同样是 $O(\sqrt n)$，从而我们只需对范围内的每个 $x$ 求出有多少个 $d_u = x$（以下记其为 $c_x$），随后执行一遍异或卷积即可。这一部分的复杂度是 $O(\sqrt n \log n)$。
> 
> 接下来考虑如何对每个 $x$ 求出 $c_x$。观察到树中的非叶子节点只有 $O(\sqrt n)$，这一部分的贡献显然可以暴力结算；而对于那些叶子节点，我们在它们的父亲处统一计算贡献。对于非叶子节点，且有儿子是叶子的节点 $u$，其每个叶子儿子 $v$ 与其连边的边权 $w$ 必然构成一个区间 $[l, r]$。而 $d_v = d_u \oplus w$，换言之，我们要对每一个 $w \in [l, r]$，将 $c_{d_u \oplus w} \gets c_{d_u \oplus w} + 1$。
>
> 对于这个问题，我们首先将 $[l, r]$ 差分为 $[1, l - 1]$ 和 $[1, r]$ 两个问题。然后我们考虑对于任意的 $[1, p]$ 怎么做：建立一颗满的 Trie 树，按照 $p$ 的二进制表示将其拆分成 $O(\log p)$ 个区间。这样，每个区间都对应 Trie 树上的一个节点，而这些节点又恰好在 Trie 树上某一条从根开始的链上，于是我们只需沿着这条链，给 Trie 树上每个对应节点打上标记。在处理完所有这些 $[l, r]$ 以后，再在 Trie 上做一遍 dfs 下传标记，即可得到每个叶子节点被贡献的值，也就是 $c_x$。由于对单个 $[l, r]$ 做的复杂度是 $O(\log n)$ 的，而一共有 $O(\sqrt n)$ 个这样的区间，因此这一部分复杂度也为 $O(\sqrt n \log n)$。
> 
> 综上，本题在 $O(\sqrt n \log n)$ 的复杂度内得到解决。

---

## 作者：FutureSnow (赞：0)

**前言**

时间复杂度不是最优，但个人感觉更容易想的做法。

**思路**

首先不难看出题目生成的图是一个树形结构。设树有 $k$ 层，则前 $k - 1$ 层的点数是 $O(\sqrt{n})$ 量级的。另外，树上边权的异或和同样为 $O(\sqrt{n})$ 量级。

考虑根号分治，设立阈值 $B (B \ge \sqrt{n})$，先对于编号 $x \le B$ 的点，暴力算出从根到该点的异或值，然后开一个数组 $val$ 统计每个值出现的次数。

然后处理编号 $x > B$ 的点，不难发现其父亲到根路径上的异或和为已知。于是直接 $O(n)$ 枚举第 $k$ 层（也就是最后一层）节点对应边权然后统计异或值，然后再 $O(\sqrt{n} \log n)$ 异或卷积即可。总时间复杂度 $O(n)$。也许可以通过，但不够优秀。

**优化**

上述做法的瓶颈在于需要 $O(n)$ 枚举最后一层的边权。进一步观察发现，编号为 $x$ 的点与其子节点间存在以下简单规律：

+ 其子节点是且仅是编号在 $[x^2, x^2 + 2x]$ 区间内的所有点。
+ 对于任意一个编号 $i \in [x^2, x^2 + 2x]$ 的节点，其与节点 $x$ 间的边权为 $i - x^2$。也就是说，编号为 $x$ 的点与其子节点间的边权为值域在 $[0, 2x]$ 间且公差为 $1$ 的等差数列。

对于第 $k - 1$ 层和第 $k$ 层间的边，$2x$ 的最小值为 $O(\sqrt[4]{n})$ 量级，最大值为 $O(\sqrt{n})$ 量级。

考虑分块，设块长为 $b(b \le \sqrt{B})$。对于一个块 $[p, p + b - 1]$，可以将所有满足 $2x > p + b - 1$ 的节点 $x$ 对应的异或值与 $[p, p + b - 1]$ 内的边权做异或卷积。这个操作每个块的复杂度为 $O(\sqrt{n} \log n)$，总复杂度为 $O(\frac{n}{b} \log n)$。而对于 $2x \in (p, p + b - 1]$ 的节点 $x$，则可以暴力处理。这部分复杂度为 $O(b \sqrt{n})$。

不难发现取 $B = \sqrt{n}, b = \sqrt[4]{n}$ 时复杂度最优。总复杂度 $O(n^{\frac{3}{4}} \log n)$。

```cpp


#include <bits/stdc++.h>
#define int long long

using namespace std;

const int N = 1000000, mod = 998244353, L = (1 << 16);
int n, S, val[N + 10], sq[N + 10], f[4 * N + 10], A[4 * N + 10], B[4 * N + 10], C[4 * N + 10], d[N + 10];
inline int x2(int x){
	return x * x;
}

inline int ksm(int u, int v){
	int mul = 1;
	while(v){
		if(v & 1) mul = mul * u % mod;
		u = u * u % mod, v >>= 1;
	}
	return mul;
}

inline void fwt(int *f, int len, int opt){
	for(int i = 1; i < len; i <<= 1)
		for(int j = 0; j < len; j += (i << 1))
			for(int k = 0; k < i; k++){
				int x = f[j + k], y = f[i + j + k];
				f[j + k] = x + y, f[i + j + k] = x - y;
				if(!opt) f[j + k] >>= 1, f[i + j + k] >>= 1;
	}
}

int dfs(int x){
	if(x == 1 || val[x]) return val[x];
	return val[x] = (dfs(sq[x]) ^ (x - x2(sq[x])));
}

signed main (){
	ios::sync_with_stdio(0);
	cin.tie(0); cout.tie(0);
	cin >> n;
	S = sqrt(n);
	for(int i = 1; x2(i) <= N; i++)	sq[x2(i)] = i;
	for(int i = 1; i <= N; i++){
		if(!sq[i])
			sq[i] = sq[i - 1];
		val[i] = dfs(i);
	}
	if(n <= N) for(int i = 1; i <= n; i++) f[val[i]]++;
	else{
		for(int i = 1; i <= N; i++)	f[val[i]]++;
		int sq = 1000, pos = sq, len = 2000, ls = 1, lst = sq, Max = 0;
		for(int i = sq; x2(i) <= n; i++){
			d[i] = x2(i + 1) - x2(i);
			A[val[i]]++;
			pos = i;
		}
		A[val[pos]]--;
		Max = d[pos - 1];
		for(int i = len; i < Max; i += len, ls += len){
			for(int j = ls; j <= i; j++) B[j] = 1;
			fwt(A, L, 1);
			fwt(B, L, 1);
			for(int j = 0; j < (L); j++) C[j] = A[j] * B[j];
			fwt(A, L, 0);
			fwt(B, L, 0);
			fwt(C, L, 0);
			for(int j = 0; j < (L); j++) f[j] += C[j];
			for(int j = ls; j <= i; j++) B[j] = 0;
			for(int j = lst; j < pos; j++)
				if(d[j] <= i + len){
					A[val[j]]--;
					lst = j + 1;
				}
			if(i + len >= Max) break; 
		}
		int sum = N - 1;
		for(int i = sq; i < pos; i++){
			int P = d[i] / len;
			sum += d[i];
			for(int j = P * len + 1; j < d[i]; j++)
				f[val[i] ^ j]++;
		}
		for(int i = sq + 1; i < pos; i++) f[val[i] ^ 0]++;
		for(int i = 0; i <= d[pos] && sum < n; i++, sum++) f[val[pos] ^ i]++; 
	}
	fwt(f, L, 1);
	for(int i = 0; i < L; i++) f[i] = x2(f[i]);
	fwt(f, L, 0);
	int ans = 1;
	for(int i = 1; i < L; i++) ans = ans * ksm(i, f[i] >> 1) % mod;
	cout << ans << '\n';
	return 0;
}
```

---


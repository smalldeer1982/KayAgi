# [蓝桥杯 2024 国 Java B] 房屋建造

## 题目描述

有一个由 $N$ 行 $N$ 列方格组成的建筑用地，每个方格，我们用 `#` 表示这是一堵墙，`.` 表示是一片空地，其中只有在空地上才可以进行房屋建造。小蓝想要在这片区域上建造两个房屋：通过水平/垂直方向可以连通在一起的区域属于同一个房屋。由于建筑物料有限，小蓝最多只能在 $K$ 个空地上进行房屋建造，同时他希望自己的房屋面积尽可能的大，所以他必须用光所有的 $K$ 块空地来建造房屋。

请问一共有多少种不同的建造方案。

## 说明/提示

### 样例说明

- 对于样例 $1$：$K = 3$，但只有两个空地，所以没有符合题意的解，答案为 $0$。
- 对于样例 $2$，答案如下所示，我们用 `@` 表示建筑物：

```
@#. @#@ @#. .#@ .#@
.## @## @## @## .##
@@# ..# .@# @.# @@#
```

### 评测用例规模与约定

- 对于 $50\%$ 的评测用例：$1 \leq N \leq 5$，$1 \leq K \leq 5$。
- 对于 $100\%$ 的评测用例：$1 \leq N \leq 8$，$1 \leq K \leq 8$。

## 样例 #1

### 输入

```
3 3
###
.##
##.```

### 输出

```
0```

## 样例 #2

### 输入

```
3 3
.#.
.##
..#```

### 输出

```
5```

# 题解

## 作者：Seaproyje (赞：4)

前情：打了三天， A 掉心情激昂，遂写题解。

# P12260 题解

很好的题，~~使我大脑成为根节点~~。

## 题意

要你在一个 $n$ 行 $n$ 列的方格中放 $k$ 个格子（有的能放有的不能），使其恰好形成两个连通块，求方案数。

## 解题

发现 $n$ 和 $k$ 都很小，猜测是状压。

想先要维护什么：

一行一行来看，可以分成不能拓展的连通块和还能再拓展的，要考虑当前放了几个，还要考虑当前行的状态。

考虑怎么转移到下一行时，发现有点难，因为只看当前行状态的话，有可能看上去是分开的，实际上在同一连通块内。

怎么办呢，你考虑抛弃传统的二进制状态，把每一位处于哪一个连通块压进去，这样子就好办了，枚举完下一行的状态时，就可以建图得出联通状态，计算一下不能再往下拓展的，就好办了。

但是有一个很大的雷需要避开，就是不要以为当前可以拓展的连通块最多只有 $2$ 个，他们后面可能会合并起来（我就因为这个想了很久）。

## 代码

本人实现冗长，马蜂丑陋，客观地喷。

```cpp
#include <bits/stdc++.h>
#define infile(s) freopen(#s".in","r",stdin)
#define outfile(s) freopen(#s".out","w",stdout)
#define fre(s) freopen(#s".in","r",stdin);freopen(#s".out","w",stdout)
#define ll long long
using namespace std;
template<typename T> bool read (T& x)
{
	x=0;
	T w=1;
	char ch=getchar();
	if(ch==EOF)return 0;
	while(ch<'0'||ch>'9')
	{
		if(ch=='-')w=-w;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')
	{
		x=x*10+ch-'0';
		ch=getchar();
	}
	if(w==-1)x=-x;
	return 1;
}
template<typename T, typename... Args> void read(T& x,Args& ...args)
{
	read(x);
	read(args...);
}
const int N=9;
const int M=400000;
int n,k;
char s[N][N];
int f[2][N][3][M];
int tot[1<<N];
int has[M];
int fa[3*N];
int p[N]{1};
int find(int x)
{
	return fa[x]==x?x:fa[x]=find(fa[x]);
}
bitset<M>vis[N][N][3];
vector<int>v[N][N][3];
int main()
{
	read(n,k);
	for(int i=1;i<=n;i++)
	{
		p[i]=p[i-1]*5;
	}
	int zt=pow(5,n)-1;
	for(int i=1;i<=n;i++)
	{
		scanf("%s",s[i]+1);
	}
	for(int i=0;i<=(1<<n)-1;i++)
	{
		if(i)tot[i]=tot[i^(i&-i)]+1;
	}
	f[0][0][0][0]=1;
	v[0][0][0].push_back(0);
	for(int i=1;i<=n;i++)
	{
		for(int use=0;use<=k;use++)
		{
			for(int sum=0;sum<=2;sum++)
			{
				for(auto lst:v[i-1][use][sum])
				{
					for(int j=0;j<=(1<<n)-1;j++)
					{
						if(use+tot[j]>k)continue;
						int bj=0;
						for(int ii=1;ii<=n;ii++)
						{
							if((j&(1<<(ii-1)))&&s[i][ii]=='#'){bj=1;break;}
						}
						if(bj)continue;
						for(int ii=1;ii<=2*n+4;ii++)
						{
							fa[ii]=ii;
						}
						int now[9];
						now[0]=0;
						for(int ii=1;ii<=n;ii++)
						{
							now[ii]=(lst%p[ii])/p[ii-1];
							if(now[ii])fa[ii]=2*n+now[ii];
						}
						for(int ii=1;ii<=n;ii++)
						{
							if(j&(1<<ii-1)&&now[ii])
							{
								int fx=find(ii),fy=find(ii+n);
								if(fx!=fy)fa[fy]=fx;
							}
							if(j&(1<<ii-1)&&(ii!=1&&j&(1<<ii-2)))
							{
								int fx=find(ii+n),fy=find(ii+n-1);
								if(fx!=fy)fa[fy]=fx;
							}
							if(now[ii]&&now[ii-1])
							{
								int fx=find(ii),fy=find(ii-1);
								if(fx!=fy)fa[fy]=fx;
							}
						}
						vector<int>of[2*n+5];
						for(int ii=1;ii<=2*n;ii++)
						{
							if(ii<=n&&now[ii]==0)continue;
							if(ii>n&&!(j&(1<<(ii-n-1))))continue;
							of[find(ii)].emplace_back(ii);
						}
						int d=0;
						int fin=0,old=0;
						for(int ii=1;ii<=2*n+4;ii++)
						{
							if(of[ii].empty())continue;
							int bj=0;
							for(auto x:of[ii])
							{
								if(x>n&&x<=2*n)
								{
									bj=1;
									break;
								}
							}
							if(!bj)
							{
								for(auto x:of[ii])
									if(x<=n){old++;break;}
								continue;
							}
							d++;
							for(auto x:of[ii])
							{
								if(x>n&&x<=2*n)
								{
									fin+=p[(x-n-1)]*d;
								}
							}
						}
						if(sum+old<=2)
						{
							f[i%2][use+tot[j]][sum+old][fin]+=f[(i-1)%2][use][sum][lst];
							if(!vis[i][use+tot[j]][sum+old][fin])
							{
								v[i][use+tot[j]][sum+old].push_back(fin);
								vis[i][use+tot[j]][sum+old][fin]=1;
							}
						}
					}
				}
				for(auto lst:v[i-1][use][sum])
				{
					f[(i-1)%2][use][sum][lst]=0;
				}
			}
		}
	}
	ll ans=0;
	for(int i=0;i<=zt;i++)
	{
		int mx=0;
		for(int ii=1;ii<=n;ii++)
		{
			mx=max(mx,(i%p[ii])/p[ii-1]);
		}
		if(mx<=2&&f[n%2][k][2-mx][i])
		{
			ans+=f[n%2][k][2-mx][i];
		}
	}
	printf("%lld\n",ans);
}
```

---

## 作者：Acerkaio (赞：3)

我们先写一个 $O(2^{n^2})$ 的顺序填写的暴力搜索，发现跑的非常慢。

然后我们考虑使用可撤销并查集快速维护联通块数量，我们按秩合并将并查集复杂度看成 $O(1)$，这样判断合法就是 $O(1)$ 的。

然后我们剪枝，考虑发现你每填一个点那么联通块的数量至多减少一，这启发我们判断若联通块的数量大于剩下未填的点的数量加二就可以直接退出了（因为最后要求剩下两个连通块）。

实测最大点 `2.83s`。

```cpp
#include<bits/stdc++.h>
#define ll long long
#define reg register
#define rep(i,a,b) for(reg int i=a;i<=b;++i)
#define drep(i,a,b) for(reg int i=a;i>=b;--i)
#define pb push_back
#define ins insert
#define il inline
#define rint reg int
using namespace std;
int n,k,res,sum,tot;
int fa[65],sz[65];
bitset<10>a[10],b[10],vis[10];
int dir[4][2]{{1,0},{-1,0},{0,1},{0,-1}};
int ltk=0;
il int find(rint x){
    if(fa[x]==x)return x;
    return find(fa[x]);
}
stack<tuple<int,int,int>>stk;
il bool merge(rint x,rint y){
    rint X=find(x),Y=find(y);
    if(X==Y)return 0;
    ltk--;
    if(sz[X]>sz[Y])swap(X,Y);
    fa[X]=Y;
    stk.push({X,Y,sz[Y]});
    sz[Y]+=sz[X];
    return 1;
}
il void poop(){
    // cerr<<stk.size()<<'\n';
    auto &[X,Y,SZ]=stk.top();
    stk.pop();++ltk;
    fa[X]=X,sz[Y]=SZ;
}
il int val(rint x,rint y){
    return (x-1)*n+y;
}
il bool check(){
    return (sum+ltk)==2;
}
il void dfs(rint x,rint y){
    if((sum+ltk)>(k-sum)+2)return ;
    if(sum==k){res+=check();return;}
    if(y>n)return;
    if(x>n){dfs(1,y+1);return;}
    if(a[x][y]){
        b[x][y]=1;
        rint cnt=0;
        if(y!=1&&a[x][y-1]&&b[x][y-1]){
            cnt+=merge(val(x,y),val(x,y-1));
        }
        if(x!=1&&a[x-1][y]&&b[x-1][y]){
            cnt+=merge(val(x,y),val(x-1,y));
        }
        sum++;
        dfs(x+1,y);
        rep(i,1,cnt)poop();
        sum--;
        b[x][y]=0;
    }
    dfs(x+1,y);
}
signed main(){
    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
    cin>>n>>k;
    rep(i,1,64)fa[i]=i,sz[i]=1;
    rint sudssm=0;
    rep(i,1,n)rep(j,1,n){char c;cin>>c;a[i][j]=(c=='.');sudssm+=a[i][j];}
    
    dfs(1,1);cout<<res<<'\n';
    return 0;
}
```

---

## 作者：aaron0919 (赞：3)

# [P12260 の题解](https://www.luogu.com.cn/problem/P12260)

~~在大佬 @[$\text{\color{red}Y\color{black}ANJINe}$](https://www.luogu.com.cn/user/1035730) 的嘲讽下，我打了 2 个多小时才打出来。~~

~~写法过烂，复杂度 $O(2^N5^NN^4)=O(10^NN^4)$，同样的代码交了 $3$ 次才过。~~

![评测姬还是太强了](https://cdn.luogu.com.cn/upload/image_hosting/xx61z8r7.png)

## 正文

考虑状压递推（简单易想）。

我们考虑要如何描述一行的状态。

注意到要处理的是连通块，而 $N\leq 8$，故一行最多只有 $4$ 个连通块。

所以我们用 $5$ 进制的一个数去描述这一行长什么样，$0$ 表示不放，$1,2,3,4$ 表示分别处于哪个连通块。

> 注：其实一行内不会有 $4$ 个连通块，这样至少要建造 $10$ 个点才能连成两个连通块，而 $K\leq 8$，所以一行内最多只会有 $3$ 个连通块。

这样一来，就很好实现了。

## 实现

我们需要实现一个最重要的函数 `getstate`。

就是给定上一行长啥样（$5$ 进制），这一行哪些位置建造（$2$ 进制），返回这一行长啥样（$5$ 进制）和共几个连通块。

```cpp
//                   上一行长啥样, 当前放啥,本来几个块
// 返回 长啥样,几个块
pair<int, int> getstate(int lst, int cur, int sum)
```

我们用并查集维护每个点处于哪个连通块，并用一个数组 `cnt` 记录出现过的连通块的数量。

如果上一行有**连通块被这一行连在一起了**，一定要统计好连通块数量。也正因如此，每一行可能**不止两个**连通块（**最大的坑**）（其实 @[$\text{\color{red}Y\color{black}ANJINe}$](https://www.luogu.com.cn/user/1035730) 告诉我了，我没踩）。

接下来考虑怎么设状态，我用了一个奇丑无比的 `map` 来存。

```cpp
map<it3, int> f[N];
//  f[行][长啥样,放了几个了,共几个连通块] = 方案数
```

这样我们直接调用 `getstate` 预处理第一行的情况，然后按行递推。

每次递推枚举这一行的长啥样（$5$ 进制）和下一行哪些建造（$2$ 进制），然后用 `getstate` 得到下一行的长啥样（$5$ 进制）和共几个连通块，然后累加进下一行即可。

大致长这样：

```cpp
for (int i = 1; i < n; ++i)
    for (auto [key, val] : f[i])
        auto [s, used, old] = key;
        for (int t = 0; t < (1 << n); ++t)
            if (check(i + 1, t))
                auto [tt, sum] = getstate(s, t, old);
                if (popcnt[t] + used <= k)
                    f[i + 1][it3{tt, popcnt[t] + used, sum}] += val;
```

至于 `check` 就是直接判断建造的地方是否和障碍物重叠。

### 优化

`getstate` 我写的是 $O(N^3)$ 的，所以加了个记忆化。

至于复杂度就是枚举行乘上枚举长啥样（$5$ 进制）乘上枚举下一行建造（$2$ 进制）乘上 `getstate` 的复杂度，也就是 $O(N\times 5^N\times 2^N\times N^3)=O(10^NN^4)$。

因为用了 `map` 存状态，不用跑满 $O(5^N)$，所以还是 $3s$ 内其实刚好跑的过的。

#### 额外的优化

其实 $2^N$ 可以预处理，也跑不满，但我太懒了，主要还是记忆化。

`map` 存状态，其实可以用 `vector/hashmap` 存状态，但我懒得改了。

## code

我的代码保留了调试输出，有兴趣可以看一看到底是怎么实现的。

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
#define int ll

const int N = 9;
const int W = 5;

int n;

template <typename T, size_t N>
std::ostream &operator<<(std::ostream &os, const std::array<T, N> &arr)
{
    os << "{ ";
    for (int i = 0; i < n; ++i)
    {
        os << arr[i] << ", "[i == n - 1];
    }
    os << "}";
    return os;
}

#ifndef ONLINE_JUDGE
template <typename T>
inline void _debug(const T &t) { cerr << t << '\n'; }
template <typename T, typename... Args>
inline void _debug(const T &t, const Args &...rest)
{
    cerr << t << ' ';
    _debug(rest...);
}
#define debug(...) _debug(#__VA_ARGS__ " =", __VA_ARGS__)
#else
#define debug(...) 0
#endif

using it3 = array<int, 3>;

constexpr auto get_power()
{
    array<int, N> res = {1};
    for (int i = 1; i < N; ++i)
    {
        res[i] = res[i - 1] * W;
    }
    return res;
}
constexpr auto pw = get_power();
#define get(x, i) (((x) / pw[i]) % W)

constexpr auto get_popcnt()
{
    array<int, 1 << N> res = {0};
    for (int i = 1; i < (1 << N); ++i)
    {
        res[i] = res[i ^ (i & -i)] + 1;
    }
    return res;
}
constexpr auto popcnt = get_popcnt();

array<int, N> div(int x) // 分解 5 进制
{
    array<int, N> res;
    for (int i = 0; i < N; ++i)
    {
        res[i] = get(x, i);
    }
    return res;
}

// 长啥样 5 进制
// 放啥 2 进制

int k;
int a[N];
map<it3, int> f[N];
//  f[行][长啥样,放了几个了,共几个连通块] = 方案数

// 判断能否放  第几行, 放啥
int check(int i, int cur)
{
    return (a[i] & cur) == 0;
}

int fat[N + N];
int getfat(int x)
{
    return x == fat[x] ? x : (fat[x] = getfat(fat[x]));
}

struct Hash
{
    size_t operator()(pair<int, int> const &x) const
    {
        return (x.first << (N + N)) + x.second;
    }
};

unordered_map<pair<int, int>, pair<int, int>, Hash()> ok;

//                   上一行长啥样, 当前放啥,本来几个块
// 返回 长啥样,几个块
pair<int, int> getstate(int lst, int cur, int sum)
{
    if (cur == 0)
    {
        return {0, sum};
    }
    if (ok.count({lst, cur}))
    {
        auto ggg = ok[{lst, cur}];
        ggg.second += sum;
        return ggg;
    }
    int _l = lst, _c = cur, _s = sum;
    int res = 0, cnt[W];
    memset(cnt, 0, sizeof cnt);
    for (int i = 1; i < N + N; ++i)
    {
        fat[i] = i;
    }
    for (int i = 1; i <= n; ++i)
    {
        if ((cur >> (i - 1)) & 1)
        {
            if (get(lst, i - 1))
            {
                fat[getfat(i)] = getfat(i + N); // +N 表示上一行
            }
            if (i > 1 && (cur >> (i - 2)) & 1)
            {
                fat[getfat(i)] = getfat(i - 1);
            }
        }
    }
    for (int i = 1; i < N + N; ++i)
    {
        getfat(i);
    }
    for (int i = 1; i <= n; ++i)
    {
        for (int j = 1; j <= n; ++j)
        {
            if (fat[i + N] == fat[j] && ((cur >> (j - 1)) & 1))
            {
                res += pw[j - 1] * get(lst, i - 1);
                cnt[get(lst, i - 1)] = 1;
                cur ^= (1 << (j - 1));
            }
        }
    }
    int lllst = lst;
    for (int i = 1; i <= n; ++i)
    {
        for (int j = i + 1; j <= n; ++j)
        {
            if (fat[i + N] == fat[j + N] && get(lllst, i - 1) != get(lllst, j - 1))
            {
                --sum;
                for (int o = j; o <= n; ++o)
                {
                    if (fat[o + N] == fat[i + N])
                    {
                        fat[o + N] = 0;
                    }
                }
            }
        }
    }
    for (int i = 1, ccnt = 1; i <= n; ++i)
    {
        if ((cur >> (i - 1)) & 1)
        {
            while (cnt[ccnt])
            {
                ++ccnt;
            }
            cnt[ccnt] = 1;
            ++sum;
            for (int j = 1; j <= n; ++j)
            {
                if (fat[j] == fat[i])
                {
                    res += pw[j - 1] * ccnt;
                    cur ^= (1 << (j - 1));
                }
            }
        }
    }
    ok[{_l, _c}] = {res, _s - sum};
    return {res, sum};
}

signed main()
{
    cin.tie(0)->sync_with_stdio(false), cout.setf(ios::fixed), cout.precision(10);

    cin >> n >> k;
    for (int i = 1; i <= n; ++i)
    {
        for (int j = 1; j <= n; ++j)
        {
            char ch;
            cin >> ch;
            a[i] |= (ch == '#') << (j - 1);
        }
    }
    for (int s = 0; s < (1 << n); ++s) // 预处理第 1 行
    {
        if (check(1, s))
        {
            auto [ss, sum] = getstate(0, s, 0);
            debug(div(ss), popcnt[s], sum);
            f[1][it3{ss, popcnt[s], sum}] = 1;
        }
    }
    for (int i = 1; i < n; ++i)
    {
        debug(i, "---------------------------");
        for (auto [key, val] : f[i])
        {
            auto [s, used, old] = key;
            if (s == 0 && old > 2)
            {
                continue;
            }
            debug(i, div(s));
            debug(used, old, val);
            for (int t = 0; t < (1 << n); ++t)
            {
                if (check(i + 1, t))
                {
                    auto [tt, sum] = getstate(s, t, old);
                    debug(div(s), used, old);
                    debug(div(tt), sum, " ");
                    if (popcnt[t] + used <= k)
                    {
                        f[i + 1][it3{tt, popcnt[t] + used, sum}] += val;
                    }
                }
            }
        }
    }
    int ans = 0;
    for (auto [key, val] : f[n])
    {
        auto [s, used, sum] = key;
        debug(div(s), used, val, sum);
        if (sum == 2 && used == k)
        {
            ans += val;
        }
    }
    cout << ans << '\n';

    return 0;
}
```

---


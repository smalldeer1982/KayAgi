# [蓝桥杯 2024 国 Java A] 合并小球

## 题目描述

给定 $n$ 个小球，其中第 $i$ 个小球位于数轴的 $x_i$ 处，小球上有数字 $y_i$。

每经过一秒，每个小球都有 $\frac{1}{2}$ 的概率向右移动一步。当任意小球到达位置 $T$ 时，小球会被立刻取走。

如果某一秒，有两个相邻的小球，左边的向右移动且右边的不动，那么两个小球会合并成一个，且合并后小球的数字为合并前的小球数字的乘积。

求所有小球都被取走时的数字之和的期望值，答案对 $998244353$ 取模。

## 说明/提示

### 样例说明

$\frac{59}{27} \equiv 406692146 \pmod{998244353}$，其中 $\frac{1}{27} \equiv 480636170 \pmod{998244353}$。

### 评测用例规模与约定

- 对于 $20\%$ 的评测用例，$n \leq 5$，$T \leq 10$；
- 对于 $40\%$ 的评测用例，$n \leq 10$，$T \leq 20$；
- 对于所有评测用例，$1 \leq n < T \leq 100$，$1 \leq x_{i-1} < x_i < T$，$1 \leq y_i \leq 10^9$。

## 样例 #1

### 输入

```
3 5
2 1
3 1
4 1```

### 输出

```
406692146```

# 题解

## 作者：Coffee_zzz (赞：6)

定义 $p_{i,j}$ 表示位置 $i$ 和位置 $j$ 的两个小球合并在一起的概率，则转移方程为：

$$
p_{i,j}=\dfrac 1 4 (p_{i,j+1}+p_{i+1,j}+p_{i+1,j+1}+p_{i,j})
$$

化简得：

$$
p_{i,j}=\dfrac 1 3 (p_{i,j+1}+p_{i+1,j}+p_{i+1,j+1})
$$

其中 $p_{i,i}=1$。

定义 $f_{i,j}$ 表示第 $i$ 个小球和第 $j$ 个小球合并在一起的概率，则容易得到：

$$
f_{i,j}=p_{x_i,x_j}
$$

定义 $g_{i,j}$ 表示第 $i$ 个小球和第 $j$ 个小球合并在一起，且**不**和第 $i-1$ 个小球与第 $j+1$ 个小球合并在一起的概率，则可以得到：

$$
g_{i,j}=f_{i,j}-f_{i-1,j}-f_{i,j+1}+f_{i-1,j+1}
$$

定义 $s_{i,j}$ 表示第 $i$ 个小球至第 $j$ 个小球上所有数字的乘积，则答案为：

$$
\sum_{i=1}^n \sum_{j=i}^n s_{i,j} \cdot g_{i,j}
$$

处理出上述数组后直接计算即可。时间复杂度 $\mathcal O(n^2)$。

---

## 作者：biyi_mouse (赞：2)

考虑答案可以看作若干段小球的合并，即 $ans = \sum{w_{i, j} \times f_{i, j}}$，其中 $s_{i, j}$ 表示球 $i$ 到球 $j$ 的乘积，$f_{i, j}$ 表示球 $i$ 到球 $j$ 合并并且不与其它球合并的概率。

$w_{i, j}$ 好求，主要看 $f_{i, j}$。直接做是困难的，因为限制太多了，我们不妨先求出 $g_{i, j}$ 表示球 $i$ 到球 $j$ 合并的概率。然后会发现这个东西也不好求，但我们转而发现数轴长度很短，所以直接求出 $p_{i, j}$ 表示位置 $i$ 的球合并到 $j$ 的概率。

有 $p_{i, j} = \frac{1}{4}(p_{i, j} + p_{i + 1, j} + p_{i, j + 1} + p_{i + 1, j + 1})$，移项一下可以得到 $p_{i, j} = \frac{1}{3}(p_{i + 1, j} + p_{i, j + 1} + p_{i + 1, j + 1})$。从而 $g_{i, j} = p_{x_i, x_j}$。

然后对于 $f_{i, j}$ 我们发现可以做个容斥，有 $f_{i, j} = g_{i, j} - g_{i - 1, j} - g_{i, j + 1} + g_{i - 1, j + 1}$。这个东西可以理解为类似 $j$ 先合并到 $j + 1$，$i - 1$ 先合并到 $i$ 然后再一路合并的方案被算重了，所以要加回来。

于是做完了，代码实现时为了避免过多的倒序枚举我们把操作变成终点为 $0$ 然后向左走。

---

## 作者：Purslane (赞：2)

# Solution

upd：添加了复杂度为 $O(T^2)$ 的做法。

有趣的题目。我做了一个多小时，感觉被狠狠地诈骗了。

根据期望的线性性，我们考虑对于每个 $(i,j)$ 计算出**最终连续段 $(i,j)$ 恰好合并成一个小球**。

为了方便起见，后文将整个数轴颠倒。即，所有小球向左移动，到了 $0$ 就被拿走。小球按照横坐标从小到大排序。

我们先考虑这样一个问题：请你求出最终第 $i$ 个小球和第 $i+1$ 个小球并不被合并起来的概率。这个事情是这样的：我们只需要关注 $i$ 和 $i+1$ 的移动即可。因为如果有球撞到了 $i+1$ 上，我们默认他和 $i+1$ 合并，这样决策的主动权仍然在 $i+1$ 上，对 $i$ 同理。很容易设计出 $dp_{i,j}$ 表示一个球在 $i$，另一个球在 $j$，最终能合并到一起去的概率，转移为：

$$
dp_{i,j} = \frac{1}{3}(dp_{i,j-1} + dp_{i-1,j} + dp_{i-1,j-1})
$$

需要满足 $i<j$。有一些很丑陋的边界情况。

那么考虑 $(i,j)$ 最后恰好合成一段的概率。

相当于：$i-1$ 和 $i$ 最后遇不上，$j$ 和 $j+1$ 最后遇不上，$i$ 和 $j$ 最后遇上了。因为 $(i,j)$ 中的元素的状态不需要考虑，顺其自然——最后 $i$ 和 $j$ 重叠，中间的部分自然会被叠到一起去。而你想想为什么题目给你的数据范围只有 $100$，说明它希望你对这个东西直接暴力算，也就是记录 $p_{i,j,k,w}$ 表示四个球的位置。转移是类似的（可以参考我的代码，因为有很多 corner case 我设了好几个数组，具体含义注释里都有的。）

复杂度 $O(T^4)$。由于 $(i,j,k,w)$ 有序，所以常数不大。

我的代码写得很丑啊，不想写记忆化搜索是这样的。 /cf

```cpp
#include<bits/stdc++.h>
#define ll long long
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=100+5,MOD=998244353;
int n,t=100,x[MAXN],y[MAXN];
ll f[MAXN][MAXN],ff[MAXN][MAXN],g[MAXN][MAXN][MAXN],h[MAXN][MAXN][MAXN],q[MAXN][MAXN][MAXN],z[MAXN][MAXN][MAXN][MAXN];
ll qpow(ll base,int p) {
	ll ans=1;
	while(p) {
		if(p&1) ans=ans*base%MOD;
		base=base*base%MOD,p>>=1;
	}
	return ans;
}
/*
f_{i,j} 一个人在 i，另一个人在 j，要求他们合并起来
ff_{i,j} 一个人在 i，另一个人在 j，要求他们不合并起来
g_{i,j,k} (i,j,k)，要求 (j,k) 最终合并起来，且不能遇到 i。 
h_{i,j,k} (i,j,k)，要求 (i,j) 最终合并起来，且不能被 k 追上。
q_{i,j,k} (i,j,k)，要求最终遇不上。 
z_{i,j,k,w} (i,j,k,w)，要求 (j,k) 最终合并起来，不能遇上 
*/
int main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>n>>t;
	ffor(i,1,t) ff[0][i]=1;
	ll _3=qpow(3,MOD-2),_7=qpow(7,MOD-2),_15=qpow(15,MOD-2);
	ffor(i,1,t) {
		f[i][i]=1;
		ffor(j,i+1,t) {
			f[i][j]=(f[i-1][j]+f[i-1][j-1]+f[i][j-1])%MOD*_3%MOD;
			ff[i][j]=(ff[i-1][j]+ff[i-1][j-1]+ff[i][j-1])%MOD*_3%MOD;
		}
	}
	ffor(i,1,t) ffor(j,i,t) g[0][i][j]=f[i][j];
	ffor(i,1,t) ffor(j,i+1,t) {
		g[i][j][j]=ff[i][j];
		ffor(k,j+1,t) g[i][j][k]=(g[i-1][j][k]+g[i-1][j-1][k]+g[i-1][j][k-1]+g[i-1][j-1][k-1]+g[i][j-1][k]+g[i][j-1][k-1]+g[i][j][k-1])%MOD*_7%MOD;
	}
	ffor(k,1,t) h[0][0][k]=1;
	ffor(i,1,t) {
		ffor(k,i+1,t) h[i][i][k]=ff[i][k];
		ffor(j,i+1,t) ffor(k,j+1,t) h[i][j][k]=(h[i-1][j][k]+h[i-1][j-1][k]+h[i-1][j][k-1]+h[i-1][j-1][k-1]+h[i][j-1][k]+h[i][j][k-1]+h[i][j-1][k-1])%MOD*_7%MOD;
	}
	ffor(i,1,t) q[0][0][i]=1;
	ffor(i,1,t) ffor(j,i+1,t) q[0][i][j]=ff[i][j];
	ffor(i,1,t) ffor(j,i+1,t) ffor(k,j+1,t) q[i][j][k]=(q[i-1][j][k]+q[i-1][j-1][k]+q[i-1][j][k-1]+q[i-1][j-1][k-1]+q[i][j-1][k]+q[i][j][k-1]+q[i][j-1][k-1])%MOD*_7%MOD;
	ffor(w,1,t) z[0][0][0][w]=1;
	ffor(j,1,t) ffor(k,j,t) ffor(w,k+1,t) z[0][j][k][w]=h[j][k][w];
	ffor(i,1,t) {
		ffor(j,i+1,t) ffor(w,j+1,t) z[i][j][j][w]=q[i][j][w];
		ffor(j,i+1,t) ffor(k,j+1,t) ffor(w,k+1,t) {
			ll sum=0;
			ffor(o,0,1) ffor(p,0,1) ffor(q,0,1) ffor(r,0,1)	sum=(sum+z[i-o][j-p][k-q][w-r])%MOD;
			z[i][j][k][w]=sum*_15%MOD;
		}
	}
	ll ans=0;
	ffor(i,1,n) cin>>x[i]>>y[i],x[i]=t-x[i];
	reverse(x+1,x+n+1),reverse(y+1,y+n+1);
	ffor(i,2,n) ffor(j,i,n-1) {
		ll mul=1;
		ffor(x,i,j) mul=mul*y[x]%MOD;
		ans=(ans+mul*z[x[i-1]][x[i]][x[j]][x[j+1]])%MOD;
	}
	ffor(i,1,1) ffor(j,1,n-1) {
		ll mul=1;
		ffor(x,i,j) mul=mul*y[x]%MOD;
		ans=(ans+mul*h[x[i]][x[j]][x[j+1]])%MOD;
	}
	ffor(i,2,n) ffor(j,n,n) {
		ll mul=1;
		ffor(x,i,j) mul=mul*y[x]%MOD;
		ans=(ans+mul*g[x[i-1]][x[i]][x[j]])%MOD;
	}
	ffor(i,1,1) ffor(j,n,n)	{
		ll mul=1;
		ffor(x,i,j) mul=mul*y[x]%MOD;
		ans=(ans+mul*f[x[i]][x[j]])%MOD;
	}
	cout<<ans;
	return 0;
}
```

-----

被其他题解批斗了。。因为我直接看到了 $T = 100$ 的数据范围就直接去暴力做了。

考虑我们直接钦定 $i$ 和 $j$ 最后合并在一起，会把所有 $i' \le i , j' \ge j$ 的情况全部计算进去。所以设 $f_{i,j}$ 表示钦定 $i$ 和 $j$ 合并的概率，$prob_{i,j}$ 表示最终 $i$ 和 $j$ 合并的概率，有

$$
f_{i,j} = \sum_{i'=1}^i \sum_{j'=j}^n prob_{i,j}
$$

做一遍二维差分即可，复杂度 $O(T^2)$。

```cpp
#include<bits/stdc++.h>
#define ll long long
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=100+5,MOD=998244353;
int n,t=100,x[MAXN],y[MAXN];
ll f[MAXN][MAXN],prob[MAXN][MAXN];
ll qpow(ll base,int p) {
	ll ans=1;
	while(p) {
		if(p&1) ans=ans*base%MOD;
		base=base*base%MOD,p>>=1;
	}
	return ans;
}
int main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>n>>t;
	ll _3=qpow(3,MOD-2);
	ffor(i,1,t) {
		f[i][i]=1;
		ffor(j,i+1,t) f[i][j]=(f[i-1][j]+f[i-1][j-1]+f[i][j-1])%MOD*_3%MOD;
	}
	ffor(i,1,n) cin>>x[i]>>y[i],x[i]=t-x[i];
	reverse(x+1,x+n+1),reverse(y+1,y+n+1);
	ffor(i,1,n) ffor(j,i,n) prob[i][j]=f[x[i]][x[j]];
	roff(i,n,1) ffor(j,i,n) prob[i][j]=(prob[i][j]-prob[i-1][j]-prob[i][j+1]+prob[i-1][j+1])%MOD;
	int ans=0;
	ffor(i,1,n) {
		ll mul=1;
		ffor(j,i,n) {
			mul=mul*y[j]%MOD;
			ans=(ans+mul*prob[i][j])%MOD;
		}
	}
	cout<<(ans%MOD+MOD)%MOD;
	return 0;
}
```

---

## 作者：minstdfx (赞：1)

不知道写四次方的人在干什么。

>根据期望的线性性，我们考虑对于每个 $(i,j)$ 计算出**最终连续段 $(i,j)$ 恰好合并成一个小球**。
>
>为了方便起见，后文将整个数轴颠倒。即，所有小球向左移动，到了 $0$ 就被拿走。小球按照横坐标从小到大排序。
>
>我们先考虑这样一个问题：请你求出最终第 $i$ 个小球和第 $i+1$ 个小球并不被合并起来的概率。这个事情是这样的：我们只需要关注 $i$ 和 $i+1$ 的移动即可。因为如果有球撞到了 $i+1$ 上，我们默认他和 $i+1$ 合并，这样决策的主动权仍然在 $i+1$ 上，对 $i$ 同理。很容易设计出 $dp_{i,j}$ 表示一个球在 $i$，另一个球在 $j$，最终能合并到一起去的概率，转移为：
>
>$$
>dp_{i,j} = \frac{1}{3}(dp_{i,j-1} + dp_{i-1,j} +dp_{i-1,j-1})
>$$
>
>需要满足 $i<j$。有一些很丑陋的边界情况。
>
>那么考虑 $(i,j)$ 最后恰好合成一段的概率。
>
（引用自 [这里](https://www.luogu.com.cn/article/e7m1h8u2)）

那么如何快速计算这个恰好合成一段的概率呢？我们可以发现，我们只要容斥一下就好了。

具体而言，扣掉 $(l,r+1)$ 和 $(l-1,r)$，然后加上扣重的 $(l-1,r+1)$，然后注意一下枚举的顺序就好了。

```cpp
const Z inv3=Z(3).inv();
Z s[109][109],p[109][109],sum[109][109],v[109],ans=0;
int pos[109],n,T;
void solve()
{
    cin>>n>>T;
    for(int i=1;i<=T;++i)
        for(int j=1;j<=i;++j)
        {
            p[i][j]=(p[i][j-1]+p[i-1][j]+p[i-1][j-1])*inv3;
            if(j==i) p[i][j]=1;
        }
    for(int i=1;i<=n;++i)
    {
        cin>>pos[i]>>v[i];
        pos[i]=T-pos[i];
    }
    for(int i=1;i<=n;++i)
    {
        sum[i][i]=v[i];
        for(int j=i+1;j<=n;++j)
            sum[i][j]=sum[i][j-1]*v[j];
    }
    for(int i=1;i<=n;++i)
        for(int j=i;j<=n;++j)
            s[i][j]=p[pos[i]][pos[j]];
    for(int i=n;i;--i)
        for(int j=i;j<=n;++j) {
            s[i][j]+=s[i-1][j+1]-s[i][j+1]-s[i-1][j],
            ans+=s[i][j]*sum[i][j];
        }
    cout<<ans.raw()<<endl;
}
```

---

## 作者：R_shuffle (赞：0)

先考虑一步转化，显然我们可以认为每个位置都有球，没有输入的位置就认为是有权值为 $1$ 的球即可。

显然，我们会合并的数都是一个连续段，那么我们不妨考虑一个连续段的贡献。假设这个连续段是 $[l,r]$，那么显然我们要求不能和 $l-1$ 或 $r+1$ 合并。不妨考虑设 $f_{b,c}$ 表示 $[b,c]$ 的小球合并，且不和 $b-1$ 或 $c+1$ 合并的概率。那么转移是不好转移的，因为我们并不知道其他状态对这种状态的贡献。但是我们发现 $T$ 和 $n$ 的范围一样，这就启发我们考虑直接把坐标带进去。这样我们不妨设 $f_{l,r}$ 表示四个小球分别在 $l-1,l,r,r+1$ ，$l,r$ 最终合并且不和 $l-1,r+1$ 合并的概率。但是我们发现不合并的问题比较难处理，所以只考虑合并。模拟一下小球的移动，我们有：
$$
f_{l,r}=\frac{1}{4}(f_{l+1,r}+f_{l+1,r+1}+f_{l,r+1}+f_{l,r})
$$
显然，移项后能得到：
$$
f_{l,r}=\frac{1}{3}(f_{l+1,r}+f_{l,r+1}+f_{l+1,r+1})
$$
考虑处理一下不合并的情况，不妨设 $g_{l,r}$ 表示有两个小球分别在 $l,r$，最后没有合并的概率，同样还是模拟小球的移动，可以得到与上面的式子类似的式子。

那么有了 $f,g$ ，我们显然就可以考虑同时能保证中间合并且两边不合并的答案了。同时更进一步，我们可以得到 $tot_{i,j,k,l}$，表示满足 $j$ 和 $k$ 最终合并，且 $i,l$ 最终不会合并到 $j,k$ 上的概率。这样就没问题了。注意一些细节即可。

实际上，真正实现的时候可以把向右走改成向左走，这样就可以写递增的循环，不会那么难受。同时，由于一些边界情况以及处理更加方便，实际上我们求了 $6$ 个数组，分别表示两个合并，两个不合并，三个后两个合并且不与前一个合并，三个前两个合并并且不与后一个合并，四个合并中间两个且不和两端合并。实际上求的时候也是按照上述顺序求的。


```cpp
/*胡金梁*/
#include<bits/stdc++.h>
using namespace std;
#define __MY_TEST__ 0
#define int long long
inline int read()
{
	int f=1,re=0;
	char ch=getchar();
	while(!isdigit(ch)){ if(ch=='-') f=-1; ch=getchar();}
	while( isdigit(ch)) re=(re<<3)+(re<<1)+(ch^'0'),ch=getchar();
	return re*f;
}
const int mod=998244353;
int ksm(int a,int b)
{
	int k=1;
	while(b)
	{
		if(b&1) k*=a,k%=mod;
		a*=a,a%=mod;
		b/=2;
	}
	return k;
}
int i3=ksm(3,mod-2),i7=ksm(7,mod-2),i15=ksm(15,mod-2);
int x[105],y[105],cfd[105][105],ufd[105][105],pre[105][105][105],mid[105][105][105],suf[105][105][105],tot[105][105][105][105];
signed main()
{
#if __MY_TEST__
	freopen(".in","r",stdin);
	freopen(".out","w",stdout);
#endif
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	int n=read(),T=read();
	for(int i=n;i;i--) x[i]=T-read(),y[i]=read();
	for(int i=1;i<=T;i++) ufd[0][i]=1,cfd[i][i]=1;
	for(int i=1;i<=T;i++)
	{
		for(int j=i+1;j<=T;j++)
		{
			cfd[i][j]=(cfd[i-1][j]+cfd[i-1][j-1]+cfd[i][j-1])*i3%mod;
			ufd[i][j]=(ufd[i-1][j]+ufd[i-1][j-1]+ufd[i][j-1])*i3%mod;
		}
	}
	for(int i=1;i<=T;i++) for(int j=i;j<=T;j++) pre[0][i][j]=cfd[i][j],pre[i][j][j]=ufd[i][j];
	for(int i=1;i<=T;i++) for(int j=i+1;j<=T;j++) for(int k=j+1;k<=T;k++) pre[i][j][k]=(pre[i-1][j][k]+pre[i-1][j][k-1]+pre[i-1][j-1][k]+pre[i-1][j-1][k-1]+pre[i][j][k-1]+pre[i][j-1][k]+pre[i][j-1][k-1])*i7%mod;
	for(int i=0;i<=T;i++) for(int j=i+1;j<=T;j++) suf[i][i][j]=ufd[i][j];
	for(int i=1;i<=T;i++) for(int j=i+1;j<=T;j++) for(int k=j+1;k<=T;k++) suf[i][j][k]=(suf[i-1][j][k]+suf[i-1][j][k-1]+suf[i-1][j-1][k]+suf[i-1][j-1][k-1]+suf[i][j][k-1]+suf[i][j-1][k]+suf[i][j-1][k-1])*i7%mod;
	for(int i=0;i<=T;i++) for(int j=i+1;j<=T;j++) mid[0][i][j]=ufd[i][j];
	for(int i=1;i<=T;i++) for(int j=i+1;j<=T;j++) for(int k=j+1;k<=T;k++) mid[i][j][k]=(mid[i-1][j][k]+mid[i-1][j][k-1]+mid[i-1][j-1][k]+mid[i-1][j-1][k-1]+mid[i][j][k-1]+mid[i][j-1][k]+mid[i][j-1][k-1])*i7%mod;
	for(int i=0;i<=T;i++) for(int j=i;j<=T;j++) for(int k=j+1;k<=T;k++) tot[0][i][j][k]=suf[i][j][k],tot[i][j][j][k]=mid[i][j][k];
	for(int i=1;i<=T;i++) for(int j=i+1;j<=T;j++) for(int k=j+1;k<=T;k++) for(int l=k+1;l<=T;l++) tot[i][j][k][l]=(tot[i][j][k][l-1]+tot[i][j][k-1][l]+tot[i][j][k-1][l-1]+tot[i][j-1][k][l]+tot[i][j-1][k][l-1]+tot[i][j-1][k-1][l]+tot[i][j-1][k-1][l-1]+tot[i-1][j][k][l]+tot[i-1][j][k][l-1]+tot[i-1][j][k-1][l]+tot[i-1][j][k-1][l-1]+tot[i-1][j-1][k][l]+tot[i-1][j-1][k][l-1]+tot[i-1][j-1][k-1][l]+tot[i-1][j-1][k-1][l-1])%mod*i15%mod;
	int ans=0;
	for(int i=2;i<=n;i++) for(int j=i;j<n;j++)
	{
		int as=1;
		for(int k=i;k<=j;k++) as=as*y[k]%mod;
		ans=(ans+as*tot[x[i-1]][x[i]][x[j]][x[j+1]])%mod;
	}
	for(int j=1;j<n;j++)
	{
		int as=1;
		for(int k=1;k<=j;k++) as=as*y[k]%mod;
		ans=(ans+as*suf[x[1]][x[j]][x[j+1]])%mod;
	}
	for(int i=2;i<=n;i++)
	{
		int as=1;
		for(int k=i;k<=n;k++) as=as*y[k]%mod;
		ans=(ans+as*pre[x[i-1]][x[i]][x[n]])%mod;
	}
	int as=1;
	for(int k=1;k<=n;k++) as=as*y[k]%mod;
	ans=(ans+as*cfd[x[1]][x[n]])%mod;
	cout<<ans<<endl;
}
```

---


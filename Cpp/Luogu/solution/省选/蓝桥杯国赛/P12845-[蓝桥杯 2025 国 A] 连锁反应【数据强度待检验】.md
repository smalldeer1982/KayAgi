# [蓝桥杯 2025 国 A] 连锁反应【数据强度待检验】

## 题目背景

数据强度可能较弱，可能会不定期更新。

## 题目描述

小蓝在数轴上放置了 $n$ 枚炸弹，第 $i$ 枚炸弹的位置为 $p_i$，其爆炸范围为 $[p_i - l_i, p_i + r_i]$。当一枚炸弹爆炸时，其范围内的所有其他未爆炸的炸弹均会被引爆。小蓝希望知道至少需要主动引爆多少枚炸弹，才能使得所有炸弹都爆炸。


## 说明/提示

**【样例说明】**

主动引爆炸弹 $2, 4$，即可引爆所有炸弹。

**【评测用例规模与约定】**

对于 20% 的评测用例，$1 \leq n \leq 2000$；

对于另外 20% 的评测用例，$l_i = 0$；

对于所有评测用例，$1 \leq n \leq 200000$，$0 \leq p_i, l_i, r_i \leq 10^5$。

## 样例 #1

### 输入

```
5
3 1 1
1 0 2
6 2 1
9 4 2
10 1 1
```

### 输出

```
2```

# 题解

## 作者：xh39 (赞：9)

## 一些说明

本题解是纯思维解法。只需要用到**排序**算法。（也用到了**枚举**和**贪心**，但我认为这是一种思路而非算法。也用到了**类似双指针**的思路）但可能有些难理解，我还是尽量讲详细些。有些啰嗦，概要已加粗，可以先阅读。

遇到不理解的可以往后看，有些正确性和解释会放在结论后面。

为了方便，本题解中 $l_i$ 表示原题目中的 $p_i-l_i$，$r_i$ 表示原题目中的 $p_i+r_i$。

暴力可以不看，但对正解的思路有帮助，还是建议阅读。如果没学过搜索就跳过那一段就好。

“直接引爆”指不考虑其它炸弹的再次爆炸，爆炸的炸弹一次即可炸到的区域或炸弹。“最终能引爆”指其它炸弹也可以爆炸的情况下能炸到的区域或炸弹。
## $O(n^2)$ 暴力

显然的做法是建图、缩点、拓扑排序，然后树形 dp。但是~~太难打了~~与本题正解无关，故不多言。

### 贪心+搜索做法
首先先按 $p_i$ 从小到大把所有炸弹排序。接着，考虑炸弹 $0$。炸弹 $0$ 最终肯定是要被引爆的。然则可否顺便多带几个炸弹呢？这里的多带几个炸弹的方法是，不直接引爆炸弹 $0$，而是**用其它的炸弹间接使炸弹 $0$ 爆炸**。显然间接爆炸一定不劣于直接爆炸，因为原本能引爆的其他炸弹一定还能引爆。

那么就**去找，引爆哪些炸弹可以最终引爆 $0$ 呢**？

这时可以**搜索**。如果 $l_i>p_j$ 说明 $i$ 可以直接引爆 $j$。于是可以找到那些直接引爆炸弹 $0$ 的炸弹，再进一步搜索能直接引爆这些炸弹的炸弹，以此类推，最终找到所有能直接引爆 $0$ 的炸弹。

那有这么多炸弹，到底要选哪一个呢？这时候就要用到贪心。**选择右端点最远的。** 设这个炸弹为 $i$。

### 正确性解释

为什么这样是对的呢？这个炸弹引爆了 $[p_0,r_i]$ 中所有的炸弹（原因见下行）。因此选择这个区间的炸弹一定不优，反正炸弹 $i$ 可以引爆它们。所以**选取 $r_i$ 尽可能大，最终爆炸范围就向右延拓得最远。**

**这个正确性是建立在保证 $l_i\leq p_i\leq r_i$ 的基础上的。**（即原题目中说的 $l_i,r_i\geq 0$。）这样才能保证爆炸范围是连通的。（注：连通指范围是一个闭区间，比如 $[0,5]$，而若该条件不满足，有可能会出现多个闭区间的情况，比如 $[0,3] \cup [7,11]$。）

（连通性的证明：两个有交的闭区间的并一定是一个闭区间，如 $[1,6]\cup[5,8]=[1,8]$，而若 $a$ 炸弹引爆了 $b$ 炸弹，即 $l_a\leq p_b\leq r_a$，则据 $l_b\leq p_b\leq r_b$，易得这两个区间肯定有公共元素 $p_b$。证明了两个的情况，则可以数学归纳法证明任意个数的情况。）

而向左延拓再多也没有意义，因为炸弹 $0$ 左边已经没有炸弹了。这就是要选择最左边的炸弹 $0$ 而不能随便选一个炸弹的原因。

然后**再找到最左没爆的炸弹，重复上述操作**。

算法不稳定，最坏会是 $O(n^2)$。（考虑如果所有炸弹互不引爆对方（即答案为 $n$ 的情况），每次都会把剩余没引爆的炸弹检验一遍。）

## $O(n+\max\{p_i\})$ 正解

### 优化的方向

前面暴力的时间浪费在搜索时，每个炸弹无论是否可以引爆都要被枚举一遍。现在看能不能尽量只枚举可以引爆炸弹 $0$ 的炸弹。（以炸弹 $0$ 为例，实际上是当前没引爆的最左边的炸弹。）这样保证每个炸弹只被检验一次，复杂度就降到 $O(n)$ 了。于是想到利用**单调性**。

当然还要用到前文讲到的**连通性**，很重要的结论（下文称为**范围不跨越**）是：**若炸弹 $i$ 不能被右边的炸弹 $j\;(j>i)$ 直接引爆，那它左边的炸弹 $k\;(k<i)$ 肯定也不行。** 因为引爆若能炸到 $p_k$，则说明 $l_j\leq p_k\leq p_i\leq r_j$。所以也能炸到 $p_i$。

### 做法

于是又是贪心，**先找到所有能直接引爆 $0$ 的最右边的炸弹。（注意是**位置 $p$ 最大**不是右端点最大）然后再找 能直接引爆这枚炸弹的 最右边的 炸弹，以此类推，直到没有右边的炸弹能直接引爆它。这枚炸弹就是能直接引爆炸弹 $0$ 的最右炸弹。然后引爆它。**

正确性：因为范围不跨越，如果右边的炸弹都不能直接引爆炸弹 $i$，那么最终也不能引爆炸弹 $0$。因为它们都不可能直接引爆在炸弹 $i$ 左边的炸弹。所以只能在 炸弹 $(i+1)$ 到 $(n-1)$ 内部互相引爆了。

### 具体实现


可以**对于每个 $i$，设 $b_i$ 表示最右边能直接炸到它的炸弹。把 $b_i$ 预处理出来**。（如果右边没有炸弹能炸到它，$b_i=i$。）这就直接倒序枚举。先枚举炸弹 $n-1$，它能炸到哪些炸弹，由于 $n-1$ 是最右边的炸弹了，所以它能炸到 $i$，则 $b_i$ 一定为 $n-1$。然后 $n-1$ 炸不到的，就看 $n-2$ 能不能炸到。一直枚举到 $0$。

不能每枚举一个炸弹都把 $n$ 个炸弹全枚举一遍。这时用 **单调性**，如果一个炸弹 $i$ 不能被它右边的某个炸弹炸到，那它左边的炸弹肯定更不行了。于是**枚举炸弹 $i$ 能炸到的范围时，弄一个指针 $j$，每次从右往左枚举到 $p_j<l_i$（炸不到）则停止**。在枚举 $i-1$ 时接着上次的 $j$ 枚举。这样每枚炸弹都只会被枚举一次。代码如下：
```cpp
j=n-1;
for(i=n-1;i&&j>=0;i--){ //如果 i=0 就不用再循环了，因为数组初始值本来就是 0。
	for(;j>=0&&_[j].a>=_[i].l;j--){ //如果 i 号炸弹直接炸到 j 号炸弹。
		b[j]=i;
	}
}
```

接下来就是引爆的过程。**枚举每枚炸弹，找到 $r$ 最大的炸弹。然后继续枚举在 $r$ 左边的炸弹，接着引爆，一直到所有能被引爆的炸弹都引爆完。** 注意新引爆的炸弹也得更新 $r$ 的最大值。说不清楚，那就看代码吧：

```cpp
maxr=0;
for(i=0;i<n;sum++){ //每次循环时，炸弹 i 都是没被引燃的最左炸弹。sum++ 表示主动引燃了一枚炸弹。
	for(j=i;b[j]>j;j=b[j]); //不断向右炸找最远能炸到 i 的。
	maxr=max(maxr,_[j].r); //_[j].r 没有被枚举。故预判之。
	for(;i<j;i++){ //这是之前引爆的炸弹。
		maxr=max(maxr,_[i].r);
	}
	for(;i<n&&_[i].a<=maxr;i++){ //枚举能被引燃的炸弹，maxr 表示最右炸到的范围。
		maxr=max(maxr,_[i].r); //新引爆的炸弹，也要更新最右能炸到的范围。
	}
}
cout<<sum;
```
由于每枚炸弹只会被引爆一次，所以就算把所有炸弹枚举了总复杂度也是 $O(n)$。

时间复杂度：后面利用单调性，每枚炸弹最多被访问 $2$ 次，复杂度为 $O(n)$，所以整体取决于排序算法的选择。桶排为 $O(n+\max\{p_i\})$。但我懒，STL中的sort或归并、堆排等方式就是 $O(n\times \log_2(n))$。

还是放一下完整的代码吧。我用这个代码弄到了截至目前的[最优解](https://www.luogu.com.cn/record/220919184)。（为了最优解还得手写桶排。。。）
```cpp
#include<iostream>
#include<algorithm>
using namespace std;
void read(int &a){
	a=0;
	char c=getchar();
	for(;c<48&&c;c=getchar()){}
	for(;c>47&&c<58;c=getchar()){
		a=(a<<3)+(a<<1)+c-48;
	}
} 
struct xyq{
	int l,a,r;
}t[200005],_[200005];
struct rule{
	bool operator()(const xyq &s1,const xyq &s2){
		return s1.a<s2.a;
	}
};
int zyl[200005],b[200005]; //zyl：最右直接向左炸到 i 号炸弹的。也就是题解中的 b[i]。
int main(){
	int n,i,j,sum=0,maxr=0,maxa=0,ykb;
	cin>>n;
	for(i=0;i<n;i++){
		read(t[i].a);
		read(t[i].l);
		read(t[i].r);
		b[t[i].a+1]++;
		maxa=max(maxa,t[i].a);
		t[i].l=t[i].a-t[i].l; 
		t[i].r=t[i].a+t[i].r; 
	}
	if(maxa>(n<<4)){ //这是排序过程，大概判断一下用 sort 还是桶排快。
		for(i=0;i<n;i++){
			_[i]=t[i];
		}
		sort(_,_+n,rule());
	}else{
		for(i=2;i<=maxa+1;i++){
			b[i]+=b[i-1];
		}
		for(i=0;i<n;i++){
			_[b[t[i].a]++]=t[i];
		}
	}
	j=n-1;
	for(i=n-1;i&&j>=0;i--){ //如果 i=0 就不用再循环了，因为初始值本来就是 0。
		for(;j>=0&&_[j].a>=_[i].l;j--){ //如果 i 号炸弹直接炸到 j 号炸弹。
			zyl[j]=i;
		}
	}
	for(i=0;i<n;sum++){ //枚举第 sum 次引爆。此时 i 为最左边的炸弹。
		for(j=i;zyl[j]>j;j=zyl[j]); //不断向右炸找最远能炸到 i 的。
		maxr=max(maxr,_[j].r); //_[j].r 没有被枚举。故预判之。
		for(;i<j;i++){
			maxr=max(maxr,_[i].r);
		}
		for(;i<n&&_[i].a<=maxr;i++){ //枚举能被引燃的炸弹，maxr 表示最右炸到的范围。
			maxr=max(maxr,_[i].r); //更新最右能炸到的范围。
		}
	}
	cout<<sum;
	return 0;
}
```
## 题外话
唉，AFO 已经快四年了。高考完了来回忆一下 OI 时光，真是感慨万千。题解都是线段树，我肯定不会了，没想到还另辟蹊径，想到了纯结论的线性解法。~~（所以难度是不是可以降蓝了。）~~

这是我做这题时的一些心路历程。也提醒大家一个错解。

### 一个错解
一开始我想到的思路是排序后对每个炸弹先分别求出向左和右能炸到的最远炸弹编号 $zl_i$ 和 $zr_i$。然后从左往右，贪心选取 $r$ 最大的最终能引爆当前最左炸弹的炸弹。

对于这个最远距离，我是用递推的方法求解的：以向左为例，从左往右依次确定。每枚炸弹能向左炸到的最左炸弹 $zl_i$ 就是在 $[l_i,p_i]$（直接炸到的所有炸弹）的 $zl$ 最小值。倍增查询最小值即可。

这个漏考虑了一个问题：可以先引爆右边的某个范围更大的炸弹。一开始我以为这样的方式肯定不优，所以可以不考虑。但是对于这组数据：

```cpp
4
0 0 0
1 0 2
2 2 0
3 0 0
```
处理出来的数据：
|$i$|$zl_i$|$zr_i$|
| -----------: | -----------: | -----------: |
|$0$|$0$|$0$|
|$1$|$1$（实际为 $0$）|$3$|
|$2$|$0$|$2$（实际为 $3$）|
|$3$|$3$|$3$|

于是输出了错误答案 $2$。因为计算 $zl_1$ 时认为引爆 $1$ 不优于引爆 $2$。所以没考虑向右引爆 $2$。而计算 $zr_2$ 时也如此。出现了两个最优解互不优于对方而都被排除的情况。

不知道这个问题可不可以被修复。但我目前没想到可以证明正确的方法。

其实我的思路和[这篇题解](https://www.luogu.com.cn/article/6idozzlq)有相似之处。这篇也错误输出了 $2$，验证了这个做法的错误。但这篇题解能过，我的只有 [95 分](https://www.luogu.com.cn/record/220872630)。还好被卡了，不然我还以为这个做法是对的。

### 逐渐想到的正解

几乎做了一个下午，居然是错的。我当然不甘心，看能不能弥补这个漏洞。于是就想到了能不能不求 $zl$ 和 $zr$，直接开始贪心。


于是我就想，哪些炸弹能最终引爆炸弹 $0$ 呢？最终的不好求，先求直接引爆 $0$ 的，然后再向右？这样不就结束了吗？

但是正要写代码时，又发现了严重的问题。在引爆关系是一条链时，这样的复杂度会降到 $O(n^2)$。

怎么找 $r$ 最大的呢？要是是按 $r$ 来排序的就好了，这样就可以用单调指针的方式找到。但是贪心又得按 $p$ 排序。

冥思无果，我都关了电脑，打算改日再想了。但就在我躺在飘窗上时不断想，之所以会 $O(n^2)$，是因为找了很多根本不需要找（不优）的炸弹，能不能避免呢？突然灵机一动，想到可不可以先找 $a$ 最大的。于是赶紧起来在草稿纸上画了一番，一下就解决了。

$a$ 越大更容易被更右边的引爆，而且 $[p_0,a_i]$ 的区域肯定全部直接引爆。

但是如果右边有能引爆它的好说，直接顺序推过去就好了，反正这堆虽然是多枚举的，但也只枚举了一次。不影响复杂度。但如果右边没有，那复杂度可能又降到了 $O(n^2)$。

看能不能知道右边还有没有。一番尝试后想到的一个很简单的方法，预处理出来最右边的。

而预处理如果是从左往右，要区间赋值，那又要线段树。于是就从右往左就好了。

开始又错了一次，因为只找了一次 $a$ 最大的，忘记了还可以继续往右搜索最终能引爆炸弹 $0$ 的。

接着修改了一些代码细节错误，终于 AC 了。比之前的错解反而更好写。独立做出了紫题，还是挺开心的，虽然只是偶尔重拾旧好。

证明了一下正确性，就有了这篇题解。如果有疏漏也欢迎指出。

---

## 作者：naroanah (赞：4)

没有思维含量的做法。

首先有暴力做法，对于每一枚炸弹，向它可以引爆的炸弹连边。然后缩点，每一个强联通分量中的点都可以互相引爆。

缩点后，显然入度为 $0$ 的点必须引爆，且只需引爆这些点，所有的炸弹都会被引爆。那么缩点后入度为 $0$ 的点的个数就是答案。

暴力连边边数过多，线段树优化建图即可。

优化建图后，只有包含实际点的强联通分量才是有用的，其他的只是起到维持联通的作用，不能算进入度。拓扑排序得到实际入度即可。

```cpp
#include<bits/stdc++.h>
#define rep(i, l, r) for(int i = (l); i <= (r); i++)
#define req(i, r, l) for(int i = (r); i >= (l); i--)
#define testcase int T; cin >> T; while(T--) solve();
#define ll long long
#define ull unsigned long long
#define pii pair<int, int>
#define vi vector<int>
#define vii vector<pii>
#define fi first
#define se second
#define all(x) begin(x), end(x)
using namespace std;
constexpr int N = 2e5 + 10, M = 2e6 + 10, inf = 0x3f3f3f3f, INF = 0x7f7f7f7f, mod = 998244353;
constexpr double eps = 1e-9;
template<typename T> void chkmin(T& x, T y) {if(x > y) x = y;}
template<typename T> void chkmax(T& x, T y) {if(x < y) x = y;}
int n, tot, rt1, rt2, m;
struct B {int p, l, r;}c[N];
vector<int> e[M];
void add(int u, int v) {e[u].push_back(v);}
struct SEGT {
    int ls[M], rs[M];
    int nw() {++tot; ls[tot] = rs[tot] = 0; return tot;}
    void build(int &id, int l, int r, int op) {
        if(!id) id = nw();
        if(l == r) return;
        int mid = (l + r) / 2; build(ls[id], l, mid, op); build(rs[id], mid + 1, r, op);
        if(op == 0) add(id, ls[id]), add(id, rs[id]);
        else add(ls[id], id), add(rs[id], id);
    }
    void add0(int id, int l, int r, int x, int y, int u, int op) { 
        if(x <= l && r <= y) {
            if(op == 0) add(u, id);
            else add(id, u);
            return;
        }
        int mid = (l + r) / 2;
        if(x <= mid) add0(ls[id], l, mid, x, y, u, op);
        if(y > mid) add0(rs[id], mid + 1, r, x, y, u, op);
    }
}tt;
void init() {
    tot = n;
    tt.build(rt1, 1, m, 0); tt.build(rt2, 1, m, 1);
    rep(i, 1, n) {
        auto [p, l, r] = c[i];
        assert(p);
        tt.add0(rt1, 1, m, p, p, i, 1);
        tt.add0(rt2, 1, m, p, p, i, 0);
        tt.add0(rt1, 1, m, max(1, p - l), min(m, p + r), i, 0);
    }
}

struct Tarjan {
    int dfn[M], low[M], dfc, cnt, bel[M], in[M];
    vi stk;
    bool ok[M], cov[M], instk[M];
    vector<int> g[M];
    void tarjan(int x) {
        low[x] = dfn[x] = ++dfc, instk[x] = 1;
        stk.push_back(x);
        for(int ed : e[x]) {
            if(!dfn[ed]) tarjan(ed), low[x] = min(low[x], low[ed]);
            else if(instk[ed]) low[x] = min(low[x], dfn[ed]);
        }
        if(low[x] == dfn[x]) {
            ++cnt;
            int v; 
            do {
                v = stk.back(); stk.pop_back();
                instk[v] = 0, bel[v] = cnt;
                if(v <= n) ok[cnt] = 1;
            }while(v != x);
        }
    }
    int calc() {
        rep(i, 1, tot) if(!dfn[i]) tarjan(i);
        rep(i, 1, tot) for(int ed : e[i]) if(bel[i] != bel[ed]) g[bel[i]].push_back(bel[ed]), in[bel[ed]]++;
        queue<int> q;
        rep(i, 1, cnt) if(!in[i]) q.push(i);
        int ans = 0;
        while(q.size()) {
            int x = q.front(); q.pop();
            if(!cov[x] && ok[x]) ans++, cov[x] = 1;
            for(int ed : g[x]) {
                cov[ed] |= cov[x];
                if(!--in[ed]) q.push(ed);
            }    
        }
        return ans;
    }
}T;
signed main() {
    ios :: sync_with_stdio(0); cin.tie(0); cout.tie(0); 
    cin >> n;
    rep(i, 1, n) {cin >> c[i].p >> c[i].l >> c[i].r; c[i].p++; chkmax(m, c[i].p);}
    init(); 
    cout << T.calc() << "\n";
    return 0;
}
```

---

## 作者：TJUHuangTao (赞：4)

# 前言
正解感觉可以用贪心加区间和并之类的维护，但是赛场上想到了一种大力出奇迹的乱搞不需要动脑做法，特此记录。代码赛时是过了随机的对拍，本贴里的代码是赛后按照回忆重新打的，不保证正确，仅供参考。目前是只有 85 分，不知道哪里写挂了，希望大家一起帮忙看看。

更新:感谢[@ran_qwq](https://www.luogu.com.cn/user/743048) 的补充，之前错误的原因是只考虑了有意义的点的直接出点，而忽略了可能有意义点的直接出点是无意义，而无意义的出点又是有意义，这种间接到达的情况，hack数据如下:

```cpp
input:
4
1 0 3
2 0 0
3 0 0
4 0 0
output:
1
```

现已能够通过所有数据。

# 题意
有 $n$ 个炸弹，每个炸弹位置在 $p[i]$, 爆炸后能连锁引爆范围在 $p[i] - l[i]$ 到 $p[i] + r[i]$ 范围内的其他炸弹。问至少有手动引爆多少个炸弹能使得所有炸弹都爆炸。 $n \leq 2\times 10^5$


## $O(n^2)$ 做法
首先考虑一下 $O(n^2)$ 的做法怎么做。可以枚举每一对炸弹，预处理一下炸弹的连锁关系，如果 $A$ 引爆，能导致 $B$ 引爆，那么建一条 $A$ 到 $B$ 的有向边，就可以得到一张有向可能有环的图。对于这种有向有环图，思路都是先考虑假如没有环，对于一张有向无环图，答案是多少。模拟一下发现，对于所有入度为 0 的顶点，肯定都需要手动引爆一次，那么对于有入度的顶点，肯定都可以被入度那个顶点连锁引爆。答案就出来了，可以参照着下图理解一下这个过程，需要手动引爆的是编号为 $1$ 和 $4$ 的两个节点。
![](https://cdn.luogu.com.cn/upload/image_hosting/ibuij12k.png)

那么考虑有环的情况，自然想到了 tarjan 缩点，并且上面的结论对缩完点的图依然成立，只考虑一个环，都有入度，但是还需要手动引爆一次整个环都炸了。所以答案就是对图缩点后统计入度为 0 的顶点数， $O(n^2)$ 的做法就出来了。

## $O(nlogn)$ 优化
那么很明显，上面做法的复杂度是卡在了建图的地方，需要 $O(n^2)$ 的枚举点对。不过我们可以发现，一个点影响到的其他点显然是一段连续的按照 $p[i]$ 排序的区间，启发我们使用线段树优化建图，实现点向区间连线。

需要注意的是，发现我们只会关注叶子节点能够到达的那部分线段树节点，而对再往上的部分不关心，直接用原始的线段树优化建图，也就是每个结点都往儿子节点建边，后续不方便统计出度之类的。因此，正确的统计方法(@ran_qwq指正)应该是，首先对于每个叶子，将它连向的线段树节点的整个子树标记(实现上可以先标记单个节点再遍历一次线段树下推这个标记)，然后将未标记的节点删去，有标记的那些节点进行缩点。之后对这个有标记的缩完点后的图直接统计入度为 0 的点数量即可。

这里拿样例为例，画一个图方便大家理解，首先对样例的点排序后重新编号，可以发现下面的覆盖关系:

- 1 -> [1 , 2]
- 2 -> [2 , 2]
- 3 -> [3 , 3]
- 4 -> [3 , 5]
- 5 -> [4 , 5]

用绿色的边表示线段树点向区间连边，红色的圈表示有标记的节点且缩点后的 SCC。对于红圈这个缩点后的标记子图，显然有2个入度为0的 SCC 即蓝星标记的那两个SCC，故答案为 2。得到下图所示：
![](https://cdn.luogu.com.cn/upload/image_hosting/mjbj7wzt.png)
可以这样具体实现：首先调用线段树的 get_leaf() 函数遍历一次，得到每个叶子节点的编号。之后叶子向线段树连边时，对应节点的 tag 数组置为1，之后再次遍历线段树调用 build() 函数，每个节点将 tag 标记下放到儿子，并且自身如果有标记的话才会向儿子连边。最后判断一下对于有标记的点再进行 tarjan 缩点，此时得到的 SCC 子图都是有标记的了，对这个子图统计入度为 0 的点数量即可。

# 代码
代码如下

```c++
#include <bits/stdc++.h>
#define int long long
#define inf 0x3f3f3f3f
#define ll long long
#define pii pair<int, int>
#define db double
#define all(a) a.begin(), a.end()
using namespace std;
const int maxn = 8e5 + 10;
const int mod = 998244353;
struct tii {
    int a, b, c;
} arr[maxn];
bool cmp(tii x, tii y) {return x.a < y.a;}
int p[maxn], l[maxn], r[maxn];
vector<int> G[maxn];
int dfn[maxn], low[maxn], Cnt, instk[maxn], scc[maxn], cscc;
stack<int> stk;
void tarjan(int u) { //缩点板子
    low[u] = dfn[u] = ++Cnt;
    instk[u] = 1;
    stk.push(u);
    for (auto v : G[u]) {
        if (!dfn[v]) tarjan(v), low[u] = min(low[u], low[v]);
        else if (instk[v]) low[u] = min(low[u], dfn[v]);
    }
    if (low[u] == dfn[u]) {
        int top;
        cscc++;
        do {
            top = stk.top();
            stk.pop();
            instk[top] = 0;
            scc[top] = cscc;
        } while(top != u);
    }
}
int leaf[maxn], up, tag[maxn], ans, in[maxn];
struct SEG {
#define ls rt << 1
#define rs rt << 1 | 1
#define mid ((l + r) >> 1)
    int t[maxn];
    void get_leaf(int rt, int l, int r) {
        if (l == r) {
            leaf[l] = rt;
            up = max(up, rt);
            return;
        }
        get_leaf(ls, l, mid), get_leaf(rs, mid + 1, r);
    }
    void build(int rt, int l, int r) {
        if (l == r) {
            return;
        }
        if (tag[rt])
            G[rt].push_back(ls), G[rt].push_back(rs);
        tag[ls] |= tag[rt], tag[rs] |= tag[rt];
        build(ls, l, mid), build(rs, mid + 1, r);
    }
    void Union(int rt, int l, int r, int p, int q, int id) {
        if (p > r || q < l) return;
        if (p <= l && r <= q) {
            G[leaf[id]].push_back(rt); //连边
            tag[rt] = 1;
            return;
        }
        Union(ls, l, mid, p, q, id), Union(rs, mid + 1, r, p, q, id);
    }
} seg;
void solve() {
    int n; cin >> n;
    seg.get_leaf(1, 1, n);
    for (int i = 1; i <= n; i++)
        cin >> arr[i].a >> arr[i].b >> arr[i].c;
    sort(arr + 1, arr + 1 + n, cmp);
    for (int i = 1; i <= n; i++)
        p[i] = arr[i].a, l[i] = arr[i].b, r[i] = arr[i].c;
    for (int i = 1; i <= n; i++) {
        int lo = p[i] - l[i], hi = p[i] + r[i];//寻找爆炸影响的 区间
        int lopos = lower_bound(p + 1, p + 1 + n, lo) - p;
        int hipos = upper_bound(p + 1, p + 1 + n, hi) - p - 1;
        if (lopos <= hipos) 
            seg.Union(1, 1, n, lopos, hipos, i); //建边
    }
    seg.build(1, 1, n);
    for (int i = 1; i <= up; i++)
        if (tag[i] && !dfn[i]) tarjan(i); //缩点
	for (int i = 1; i <= up; i++)
		for (auto v : G[i])
            if (!tag[i] || !tag[v]) continue; //跳过没有意义的点
			else if (scc[i] != scc[v]) {
                in[scc[v]]++; //统计入度
			}
    for (int i = 1; i <= cscc; i++)
        ans += in[i] == 0; //此时的所有 SCC 都已经是有意义的点浓缩后的，直接统计入度为 0 的即可
	cout << ans << "\n";
}
signed main() {
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    int t = 1;
    // cin >> t;
    while (t--) solve();
    return 0;
}

}
signed main() {
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    int t = 1;
    // cin >> t;
    while (t--) solve();
    return 0;
}
```

---

## 作者：SafariMo (赞：2)

考虑构建一张图，图上 $i \leftarrow j$ 仅当 $j$ 的爆炸能打到 $p_i$。

缩点后变成一个 DAG，显然强连通分量内的点只需要选一个。

用线段树优化建图维护即可，跑一遍 topsort 即可出答案（答案为缩点后的图的入度为 $0$ 的点的个数）。

当然，考虑到偏序关系，我们可以跑出图的类 dfs 序（每个点仅经过一次后便删除）。

最后按 dfs 序倒序维护即可。

这样就解决了该问题。

[Submission](https://www.luogu.com.cn/record/220720230)

考虑进一步优化到 $\mathcal O(n)$：

维护一个候选栈，栈顶为 $[x , y , z]$，每次加入一个元素 $[p , l , r]$ 时：

- 不断执行：若 $x \ge l$，则 $r \leftarrow \max(r , z)$，出栈（被偏序）。 
- 如果 $z \ge p$，则 $z \leftarrow \max(r , z)$（被偏序）。
- 否则将 $[p , l, r]$ 入栈。

可以证明这是最优的。

补一个很牛的均摊做法：

考虑暴力，我们可以得出一个 $\mathcal O(n^2)$ 的做法，但是可以被[卡掉](https://www.luogu.com.cn/ticket/GYKC540640)。

但是我们发现，这份代码向后拓展的复杂度是有保证的，因为拓展一次后就会少遍历一次。

向前的复杂度虽然无法保证，但是可以用如下方法均摊做到 $\mathcal O(n)$。

- 维护栈 $S$ 表示要选择的集合。
- 如果现在栈顶的元素被访问到（被偏序），那么我们跳到上一个没有被栈顶的元素偏序的点，不断重复即可。

---

## 作者：lyhr31415926 (赞：2)

将炸弹按位置排序。先预处理出每个炸弹引爆后能影响到的最 左/右 侧的炸弹。以左侧为例：

设 $g_i$ 表示第 $i$ 个炸弹引爆后能同时引爆 $i-g_i+1\sim i-1$ 个炸弹。转移分两种情况，如果 $p_i-l_i>p_{i-1}$，则 $g_i=1$；否则找到一个最小的 $k$ 满足 $k \ge p_i-l_i$，则 $g_i=\max_{k\le j\le i-1}(i-j+g_j)$。

相同的，设 $h_i$ 表示能引爆多少个右边的炸弹。

处理完左右两侧后，再做一个 DP。设 $f_i$ 表示引爆 $1\sim i$ 的所有炸弹的最少代价，转移时找到一个 $j$ 满足 $j+h_j-1 \ge i - g_i$，则可以让 $f_j+1 \to f_i$。答案是 $\min_{1\le i\le n,i+h_i-1=n}f_i$。

所有的区间查询、单点修改都用线段树维护。


```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
inline int read() {
	int x = 0, f = 1;
	char ch = getchar();
	while(ch < '0' || ch > '9') {
		if(ch == '-')	f = -1;
		ch = getchar();
	}
	while(ch >= '0' && ch <= '9') {
		x = (x << 3) + (x << 1) + ch - '0';
		ch = getchar();
	}
	return x * f;
}
struct SegmentTree {
	int mn[800005], mx[800005];
	void pushup(int p) {
		mn[p] = min(mn[p << 1], mn[p << 1 | 1]);
		mx[p] = max(mx[p << 1], mx[p << 1 | 1]);
		return;
	}
	void build(int p, int l, int r) {
		mn[p] = 1e15;
		mx[p] = -1e15;
		if(l == r) {
			return;
		}
		int mid = l + r >> 1;
		build(p << 1, l, mid);
		build(p << 1 | 1, mid + 1, r);
		return;
	}
	void upd(int p, int l, int r, int k, int x) {
		if(l == r) {
			mn[p] = min(mn[p], x);
			mx[p] = max(mx[p], x);
			return;
		}
		int mid = l + r >> 1;
		if(k <= mid)	upd(p << 1, l, mid, k, x);
		else	upd(p << 1 | 1, mid + 1, r, k, x);
		pushup(p);
		return;
	}
	int querymn(int p, int l, int r, int L, int R) {
		if(R < L)	return 1e15;
		if(L <= l && r <= R) {
			return mn[p];
		}
		int mid = l + r >> 1;
		if(L > mid)	return querymn(p << 1 | 1, mid + 1, r, L, R);
		if(R <= mid)	return querymn(p << 1, l, mid, L, R);
		return min(querymn(p << 1, l, mid, L, R), querymn(p << 1 | 1, mid + 1, r, L, R));
	}
	int querymx(int p, int l, int r, int L, int R) {
		if(R < L)	return 1e15;
		if(L <= l && r <= R) {
			return mx[p];
		}
		int mid = l + r >> 1;
		if(L > mid)	return querymx(p << 1 | 1, mid + 1, r, L, R);
		if(R <= mid)	return querymx(p << 1, l, mid, L, R);
		return max(querymx(p << 1, l, mid, L, R), querymx(p << 1 | 1, mid + 1, r, L, R));
	}
}G, H, F;
struct node {
	int p, l, r;
}a[200005];
int n, g[200005], h[200005], f[200005], ans = 1e15;
inline int queryup(int x) {
	int l = 1, r = n, res = -1;
	while(l <= r) {
		int mid = l + r >> 1;
		if(a[mid].p >= x) {
			res = mid;
			r = mid - 1;
		}
		else	l = mid + 1;
	}
	return res;
}
inline int querydn(int x) {
	int l = 1, r = n, res = -1;
	while(l <= r) {
		int mid = l + r >> 1;
		if(a[mid].p <= x) {
			res = mid;
			l = mid + 1;
		}
		else	r = mid - 1;
	}
	return res;
}
bool cmp(node x, node y) {
	return x.p < y.p;
}
signed main() {
	n = read();
	for(int i = 1; i <= n; ++i) {
		a[i].p = read(); a[i].l = read(); a[i].r = read();
	}
	G.build(1, 1, n); H.build(1, 1, n); F.build(1, 0, n);
	g[0] = 0, h[0] = 0;
	sort(a + 1, a + n + 1, cmp);
	for(int i = 1; i <= n; ++i) {
		int id = queryup(a[i].p - a[i].l);
		if(id == -1 || id >= i)	g[i] = 1;
		else {
			g[i] = max(1ll, i - G.querymn(1, 1, n, id, i - 1));
		}
		G.upd(1, 1, n, i, i - g[i]);
	}
	for(int i = n; i >= 1; --i) {
		int id = querydn(a[i].p + a[i].r);
		if(id == -1 || id <= i)	h[i] = 1;
		else {
			h[i] = max(1ll, H.querymx(1, 1, n, i + 1, id) - i);
		}
		H.upd(1, 1, n, i, h[i] + i);
	}
	f[0] = 0;
	F.upd(1, 0, n, 0, 0);
	for(int i = 1; i <= n; ++i) {
		f[i] = F.querymn(1, 0, n, i - g[i], n) + 1;
		F.upd(1, 0, n, i + h[i] - 1, f[i]);
	}
	for(int i = 1; i <= n; ++i) {
		if(i + h[i] - 1 == n) {
			ans = min(ans, f[i]);
		}
	}
	cout<<ans;
	return 0;
}
```

---


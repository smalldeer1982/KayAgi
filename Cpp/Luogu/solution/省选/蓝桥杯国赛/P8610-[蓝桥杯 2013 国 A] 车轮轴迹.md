# [蓝桥杯 2013 国 A] 车轮轴迹

## 题目描述

栋栋每天骑自行车回家需要经过一条狭长的林荫道。道路由于年久失修，变得非常不平整。虽然栋栋每次都很颠簸，但他仍把骑车经过林荫道当成一种乐趣。

由于颠簸，栋栋骑车回家的路径是一条上下起伏的曲线，栋栋想知道，他回家的这条曲线的长度究竟是多长呢？更准确的，栋栋想知道从林荫道的起点到林荫道的终点，他的车前轮的轴（圆心）经过的路径的长度。

栋栋对路面进行了测量。他把道路简化成一条条长短不等的直线段，这些直线段首尾相连，且位于同一平面内。并在该平面内建立了一个直角坐标系，把所有线段的端点坐标都计算好。

假设栋栋的自行车在行进的过程中前轮一直是贴着路面前进的。

![](https://cdn.luogu.com.cn/upload/image_hosting/1vb89irr.png)

图 $1$ 给出了一个简单的路面的例子，其中蓝色实线为路面，红色虚线为车轮轴经过的路径。在这个例子中，栋栋的前轮轴从 $A$ 点出发，水平走到 $B$ 点，然后绕着地面的 $F$ 点到 $C$ 点（绕出一个圆弧），再沿直线下坡到 $D$ 点，最后水平走到 $E$ 点，在这个图中地面的坐标依次为：$(0,0),(2,0),(4,-1),(6,-1)$，前轮半径为 $1.50$，前轮轴前进的距离依次为：

$AB=2.0000$；弧长 $BC=0.6955$；$CD=1.8820$；$DE=1.6459$。

总长度为 $6.2233$。

![](https://cdn.luogu.com.cn/upload/image_hosting/z166vjw7.png)

图 $2$ 给出了一个较为复杂的路面的例子，在这个例子中，车轮在第一个下坡还没下完时（$D$ 点）就开始上坡了，之后在坡的顶点要从 $E$ 绕一个较大的圆弧到 $F$ 点。这个图中前轮的半径为 $1$，每一段的长度依次为：

$AB=3.0000$；弧长 $BC=0.9828$；$CD=1.1913$；$DE=2.6848$；弧长 $EF=2.6224$；$FG=2.4415$；$GH=2.2792$。

总长度为 $15.2021$。

现在给出了车轮的半径和路面的描述，请求出车轮轴轨迹的总长度。

## 说明/提示

对于 $20\%$ 的数据，$n=4$；

对于 $40\%$ 的数据，$n \le 10$；

对于 $100\%$ 的数据，$4 \le n \le 100$，$0.5 \le r \le 20.0$，$x_i \le 2000.0$，$-2000.0 \le y_i \le 2000.0$。

时限 1 秒, 64M。蓝桥杯 2013 年第四届国赛

## 样例 #1

### 输入

```
4 1.50
0.00 0.00
2.00 0.00
4.00 -1.00
6.00 -1.00```

### 输出

```
6.22```

## 样例 #2

### 输入

```
6 1.00
0.00 0.00
3.00 0.00
5.00 -3.00
6.00 2.00
7.00 -1.00
10.00 -1.00```

### 输出

```
15.20```

# 题解

## 作者：iuyi (赞：4)

样例 \#2
![图1](https://cdn.luogu.com.cn/upload/image_hosting/6ijfaajc.png)

观察样例发现要求的曲线长度就是上图的上边界长度。具体来说图形包括每一段路沿法线方向平移 $r$ 后得到的线段和所有以端点为圆心半径为 $r$ 的圆。

首先想到的是沿着路径模拟。注意到并不是每一段路都有机会和车轮相切（比如说有一个宽度比车轮小很多的深坑），也就是说我们不能仅仅处理相邻两段的交点。我们还会发现路径上的圆弧不仅可以和相邻的线段相接，还可以和不相邻的线段（比如下面这组数据）或其他圆相接。

```text
5 1.00
0.00 0.00
3.00 0.00
4.00 -3.00
5.00 2.00
7.00 2.00
```

![图2](https://cdn.luogu.com.cn/upload/image_hosting/zbqavt4m.png)

直接模拟需要处理几种不同类型的交点，看起来有点复杂，于是我们考虑一种类似于辛普森积分的做法。对于一个区间，如果当前区间的估计值和左右子区间的估计值之和误差很小就直接返回，否则就递归下去。

计算一个区间的曲线长度时取左右端点和中间点，将过这三点的圆弧（或线段）的长度作为近似值。由于上边界是由圆弧和线段构成的，所以这样算出的近似值在大部分的位置都是准确值。

```python
import sys
from cmath import phase, pi
from math import sqrt
import matplotlib.pyplot as plt
import numpy as np

eps = 1e-8
# sys.stdin = open('1.in', 'r')
n, r = input().split()
n, r = int(n), float(r)
road = [complex(*map(float, input().split())) for _ in range(n)]
vec = [b - a for a, b in zip(road[:-1], road[1:])]
norm = [v / abs(v) * 1j * r for v in vec]
seg = [(a + n, b + n) for a, b, n in zip(road[:-1], road[1:], norm)]

fig, ax = plt.subplots()
ax.set_aspect(1)
plt.plot([x.real for x in road], [x.imag for x in road])
for o in road:
    args = np.linspace(0, 2 * np.pi)
    plt.plot(o.real + r * np.cos(args), o.imag + r * np.sin(args))
for a, b in seg:
    plt.plot([a.real, b.real], [a.imag, b.imag])
plt.show()

def fun(p: float) -> float:
    h = -2000.0
    for a, b in seg:
        if a.real <= p <= b.real:
            a += a - b
            h = max(h, (b.imag - a.imag) * (p - a.real) / (b.real - a.real) + a.imag)
    for o in road:
        d = abs(o.real - p)
        if d < r:
            h = max(h, o.imag + sqrt(r ** 2 - d ** 2))
    return h

def cross(a: complex, b: complex, c: complex, d: complex) -> complex:
    '''Find the intersection of two lines.'''
    c -= a
    s1, s2 = ((c + d) * b.conjugate()).imag, (b * c.conjugate()).imag
    return a + c + d * s2 / (s1 + s2)

def simp(l: float, r: float) -> float:
    '''Calculate the length of an arc that goes through three points.'''
    mid = (l + r) / 2
    a, b, c = map(lambda p: complex(p, fun(p)), [l, mid, r])
    v1, v2 = b - a, c - b
    if abs((v1 * v2.conjugate()).imag) < eps:
        return abs(v1 + v2)
    o = cross(a + v1 / 2, v1 * 1j, b + v2 / 2, v2 * 1j)
    a1, a2 = phase((a - o) * (b - o).conjugate()), phase((b - o) * (c - o).conjugate())
    a1, a2 = map(lambda p: p if p >= 0 else p + 2 * pi, [a1, a2])
    if a1 + a2 > 2 * pi:
        a1, a2 = 2 * pi - a1, 2 * pi - a2
    return abs(a - o) * (a1 + a2)

def inte(l: float, r: float, f: float, step: int) -> float:
    '''Calculate curve length integral.'''
    mid = (l + r) / 2
    lf, rf = simp(l, mid), simp(mid, r)
    if step <= 0 and abs(lf + rf - f) < eps:
        return lf + rf
    return inte(l, mid, lf, step - 1) + inte(mid, r, rf, step - 1)

lp, rp = road[0].real, road[-1].real
print(f'{inte(lp, rp, simp(lp, rp), 5):.2f}')
```

---

## 作者：sz_yangwangbo (赞：1)

# 思路
轮子与地面永远是保持垂直的，在每段地面上画一个平行四边形，轮子总是沿着平行四边形的上面的边行走的。计算路面上方轴心位置时，可以根据线段与水平线的夹角与轮子半径以及对应地面点的坐标求得。首先可以将这个轮子轴心前进分为几种情况。

平路、上坡、下坡：从起点上方，一直前进到轮子接触到上升坡或者拐点上方结束，判断轮子轴心结束该端的位置可以在当前地面画一个平行四边形，再在下一个地面画一个平行四边形，轮子总是沿着平行四边形的上面的边行走的，所以求两个平行四边形上面线的交点便是向上转折点，也是轮子前沿刚好接触到上升坡的位置，求两直线交点在后面补充。

向下的转折点：当下个平面与水平线的角度比当前平面低时，会产生向下的转折点，轮子与地面的接触点不变，轴绕接触点旋转，由于轮子始终与地面垂直，所以从一个平面的垂直点旋转到另一平面的旋转点，旋转角度为 $180\degree$ 两平面下面的夹角，根据半径和角度，计算出弧长，如果夹角大于 $180\degree$，那么轮子是可以不用旋转的。
# 代码
```cpp
#include <iostream>
#include <cstdlib>
#include <cstdio>
#include <cstring>
#include <vector>
#include <cmath>
#include <algorithm>
using namespace std;
const int MAXN = 10000;
const double PI = atan(1.0) * 4;
const double EPS = 1e-10;
class Point {
public:
    double x, y;
    Point() {}
    Point(double x, double y) : x(x), y(y) {}
    Point operator - (const Point &r) const { return Point(x-r.x, y-r.y); }
    Point operator + (const Point &r) const { return Point(x+r.x, y+r.y); }
    Point &operator += (const Point &r) { x += r.x; y += r.y; return *this; }
    Point &operator *= (double m) { x *= m; y *= m; return *this; }
    Point pOfRotate(double angle) const {
        double cosA = cos(angle);
        double sinA = sin(angle);
        return Point(cosA*x-sinA*y, sinA*x+cosA*y);
    }
    Point pOfRotate90() const { return Point(-y, x); }
    double length() const { return sqrt(x*x+y*y); }
    Point pOfNormal() const {
        double len = length();
        return Point(x/len, y/len);
    }
    double angle() const { return atan2(y, x); }
};
ostream & operator <<(ostream &os, const Point &v)
{
    os << "(" << v.x << "," << v.y << ")";
    return os;
}
class Segment;
class Circle;
class Seg {
public:
    virtual double getLeft() const = 0;
    virtual double getRight() const = 0;
    virtual double getY(double x) const = 0;
    virtual double getLength(double x1, double x2) const = 0;
    virtual void intersect(Seg *r) const = 0;
    virtual void intersect(const Segment &v) const = 0;
    virtual void intersect(const Circle &v) const = 0;
    bool contains(double x) const { return x>=getLeft() && x<=getRight(); }
    virtual void acceptPrint(ostream &os) const = 0;
};
ostream & operator <<(ostream &os, const Seg &v)
{
    v.acceptPrint(os);
    return os;
}
Point intersectRet[4];
int tIntersectRet;
class Segment : public Seg {
public:
    Point a, b;
    Segment &moveLeft(double dis)
    {
        Point tmp = ((b-a).pOfRotate90().pOfNormal() *= dis);
        a += tmp;
        b += tmp;
        return *this;
    }
    virtual double getLeft() const { return a.x; }
    virtual double getRight() const { return b.x; }
    virtual double getY(double x) const {
        return (x-a.x)*(b.y-a.y)/(b.x-a.x)+a.y;
    }
    virtual double getLength(double x1, double x2) const {
        return (x2-x1) * (b-a).length() / (b.x-a.x);
    }
    virtual void intersect(Seg *r) const {
        r->intersect(*this);
    }
    virtual void intersect(const Segment &v) const {
        tIntersectRet = 0;
        double ang = (b-a).angle();
        Point c = (v.a-a).pOfRotate(-ang);
        Point d = (v.b-a).pOfRotate(-ang);
        // Bug
        //double di = b.length();
        double di = (b-a).length();
        if (!((c.y>0&&d.y<0) || (c.y<0&&d.y>0)))
            return ;
        double x = (d.x-c.x) * (-c.y) / (d.y-c.y) + c.x;
        if (x<0 || x>di)
            return ;
        Point ret = Point(x,0).pOfRotate(ang)+a;
        intersectRet[tIntersectRet++] = ret;
    }
    virtual void intersect(const Circle &v) const;
    virtual void acceptPrint(ostream &os) const {
        os << a << "-" << b;
    }
};
class Circle : public Seg {
public:
    Point c;
    double r;
    virtual double getLeft() const { return c.x - r; }
    virtual double getRight() const { return c.x + r; }
    virtual double getY(double x) const {
        double y2 = r * r - (c.x - x) * (c.x - x);
        if (y2<0) y2 = 0;
        return c.y + sqrt(y2);
    }
    virtual double getLength(double x1, double x2) const {
        x1 -= c.x; x2 -= c.x;
        double a1 = Point(x1, sqrt(abs(r*r-x1*x1))).angle(), a2 = Point(x2, sqrt(abs(r*r-x2*x2))).angle();
        return (a1-a2) * r;
    }
    virtual void intersect(Seg *r) const {
        r->intersect(*this);
    }
    virtual void intersect(const Segment &v) const {
        tIntersectRet = 0;
        Point a = v.a - c;
        Point b = v.b - c;
        double ang = (b-a).angle();
        Point nA = a.pOfRotate(-ang);
        Point nB = b.pOfRotate(-ang);
        double y = nA.y;
        if (y>r || y<-r)
            return ;
        double x = sqrt(r*r - y*y);
        if (x>=nA.x && x<=nB.x)
            intersectRet[tIntersectRet++] = Point(x, y).pOfRotate(ang) + c;
        if (-x>=nA.x && -x<=nB.x)
            intersectRet[tIntersectRet++] = Point(-x, y).pOfRotate(ang) + c;
    }
    virtual void intersect(const Circle &v) const {
        tIntersectRet = 0;
        Point p = v.c - c;
        double d = p.length();
        if (d > r + v.r || d==0)
            return ;
        double x = (r*r - v.r*v.r + d*d) / (2*d);
        if (x <= r)
        {
            double y = sqrt(abs(r*r - x*x));
            double ang = p.angle();
            intersectRet[tIntersectRet++] = Point(x,y).pOfRotate(ang) + c;
            intersectRet[tIntersectRet++] = Point(x,-y).pOfRotate(ang) + c;
        }
    }
    virtual void acceptPrint(ostream &os) const {
        os << c << "," << r;
    }
};
void Segment::intersect(const Circle &v) const {
    v.intersect(*this);
}
int n;
Point inps[MAXN];
vector<Seg *> segs;
vector<double> spes;
double radius = 1;
void input()
{
    scanf("%d%lf", &n, &radius);
    for (int i = 0; i < n; ++i)
    {
        double x, y;
        scanf("%lf%lf", &x, &y);
        inps[i] = Point(x, y);
    }
}
void process()
{
    segs.clear();
    spes.clear();
    for (int i = 1; i + 1 < n; ++i)
    {
        Circle *tmp = new Circle;
        tmp->c = inps[i];
        tmp->r = radius;
        segs.push_back(tmp);
    }
    for (int i = 0; i + 1 < n; ++i)
    {
        Segment *tmp = new Segment;
        tmp->a = inps[i];
        tmp->b = inps[i+1];
        tmp->moveLeft(radius);
        segs.push_back(tmp);
    }
    for (int i = 0; i < (int)segs.size(); ++i)
    {
        spes.push_back(segs[i]->getLeft());
        spes.push_back(segs[i]->getRight());
    }
    for (int i = 0; i < (int)segs.size(); ++i)
    {
        for (int j = i+1; j < (int)segs.size(); ++j)
        {
            segs[i]->intersect(segs[j]);
            if (tIntersectRet > 0)
            {
                for (int id = 0; id < tIntersectRet; ++id)
                {
                    //cout << *segs[i] << " " << *segs[j] << " : " << intersectRet[id] << endl;
                    spes.push_back(intersectRet[id].x);
                }
            }
        }
    }
    sort(spes.begin(), spes.end());
    double pre = spes[0];
    const double NONE = 1e30;
    double preEnd = NONE;
    double totalLen = 0;
    for (int i = 1; i < (int)spes.size(); ++i)
    {
        if (spes[i]-pre < EPS)
            continue;
        double cur = (pre+spes[i]) / 2;
        //cout << "Processing " << cur << "  from " << pre << " to " << spes[i] << endl;
        if (cur>=inps[0].x && cur<=inps[n-1].x)
        {
            double MY = -NONE;
            int who;
            for (int j = 0; j < (int)segs.size(); ++j)
            {
                if (!segs[j]->contains(cur))
                    continue;
                double y = segs[j]->getY(cur);
                if (y > MY)
                {
                    MY = y;
                    who = j;
                }
            }
            if (preEnd != NONE)
            {
                double LY = segs[who]->getY(pre);
                //cout << "Drop info " << *segs[who] << " " << "[" << pre << "]" << endl;
                totalLen += abs(preEnd-LY);
                //cout << "Pre drop = " << abs(preEnd-LY) << "  from " << preEnd << " to " << LY << endl;
            }
            double len = segs[who]->getLength(pre, spes[i]);
            if (len < 0)
                printf("Error!\n");
            //cout << "Curlen = " << len << " from " << pre << " to " << spes[i] << endl;
            totalLen += len;
            preEnd = segs[who]->getY(spes[i]);
        }
        pre = spes[i];
    }
    printf("%0.2lf\n", totalLen);
    for (int i = 0; i < (int)segs.size(); ++i)
        delete segs[i];
    segs.clear();
}
int main()
{
    input();
    process();
    return 0;
}
```

---


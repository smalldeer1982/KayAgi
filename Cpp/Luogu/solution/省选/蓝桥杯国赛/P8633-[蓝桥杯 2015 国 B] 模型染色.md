# [蓝桥杯 2015 国 B] 模型染色

## 题目描述

在电影《超能陆战队》中，小宏可以使用他的微型机器人组合成各种各样的形状。

现在他用他的微型机器人拼成了一个大玩具给小朋友们玩。为了更加美观，他决定给玩具染色。

小宏的玩具由 $n$ 个球型的端点和 $m$ 段连接这些端点之间的边组成。下图给出了一个由 $5$ 个球型端点和 $4$ 条边组成的玩具，看上去很像一个分子的球棍模型。

![](https://cdn.luogu.com.cn/upload/image_hosting/sefn3dug.png)

由于小宏的微型机器人很灵活，这些球型端点可以在空间中任意移动，同时连接相邻两个球型端点的边可以任意的伸缩，这样一个玩具可以变换出不同的形状。在变换的过程中，边不会增加，也不会减少。

小宏想给他的玩具染上不超过 $k$ 种颜色，这样玩具看上去会不一样。如果通过变换可以使得玩具变成完全相同的颜色模式，则认为是本质相同的染色。现在小宏想知道，可能有多少种本质不同的染色。

## 说明/提示

**【样例说明】**

令 $(a,b,c)$ 表示第一个端点染成 $a$，第二个端点染成 $b$，第三个端点染成 $c$，则下面 $6$ 种本质不同的染色：$(1,1,1),(1,1,2),(1,2,1),(1,2,2),(2,1,2),(2,2,2)$。

而 $(2,1,1)$ 与 $(1,1,2)$ 是本质相同的，$(2,2,1)$ 与 $(2,1,2)$ 是本质相同的。

**【数据规模与约定】**

对于 $20\%$ 的评测数据，$1 \le n \le 5$，$1 \le k \le 2$。

对于 $50\%$ 的评测数据，$1 \le n \le 10,1 \le k \le 8$。

对于 $100\%$ 的评测数据，$1 \le n \le 10,1 \le m \le 45,1 \le k \le 30$。

## 样例 #1

### 输入

```
3 2 2
1 2
3 2```

### 输出

```
6```

# 题解

## 作者：寻逍遥2006 (赞：6)

题意：就对于一个有 $n$ 个节点的图进行 $k$ 染色，本质不同的染色方式有多少种。

其中，两种染色方式相同称为对其中一个图的所有点重编号之后，两个图**同构且对应点颜色相同**。 

考虑使用 Polya 定理，那么我们就需要找到所有置换，满足对点进行置换之后图仍然同构。

比如说，对于样例来说，所有满足条件的置换为 $(1,2,3)$ 和 $(3,2,1)$。

由于 $n\leqslant 10$，所以可以考虑暴力枚举每一种置换是否满足上述条件既可。单次判断可以直接使用 $O(m)$ 或者 $O(n^2)$ 的暴力判断。

找到置换群 $G$ 之后，根据 Polya 定理，答案即为 $\dfrac{1}{|G|}\sum\limits_{g\in G}m^{\sigma(g)}$，其中 $\sigma(g)$ 表示每一个置换 $g$ 的环的个数，这个部分可以 $O(n)$ 求出。

总体复杂度为 $O(m\times n!+|G|\times n)$ 或者 $O(n^2\times n!+|G|\times n)$。

由于时限宽松，这里给出一个较劣的 $O(n^2\times n!+|G|\times n)$ 算法。

```cpp
#include <bits/stdc++.h>
#define Mod 10007
using namespace std;
int Qread()
{
	int x=0;char ch=getchar();
	while(ch<'0'||ch>'9') ch=getchar();
	while(ch>='0'&&ch<='9') x=x*10+(ch^48),ch=getchar();
	return x;
}
long long qpow(long long a,long long p)
{
	long long ret=1;
	for(;p;p>>=1,a=a*a%Mod)
		if(p&1) ret=ret*a%Mod;
	return ret;
}
int n,m,k,u,v;
long long ans,cnt;
bool ed[20][20];
int p[20];bool vis[20];
bool chk()
{
	for(int i=1;i<=n;i++)
	for(int j=1;j<=n;j++)
		if(ed[i][j]^ed[p[i]][p[j]])
			return false;
	return true;
}
int get_cir()
{
	int ret=0,nw;
	for(int i=1;i<=n;i++) vis[i]=false;
	for(int i=1;i<=n;i++)
	{
		if(vis[i]) continue;
		nw=i;
		do vis[nw]=true,nw=p[nw];
		while(nw!=i);
		ret++;
	}
	return ret;
}
int main()
{
	n=Qread(),m=Qread(),k=Qread();
	for(int i=1;i<=n;i++)
		p[i]=i;
	for(int i=1;i<=m;i++)
	{
		u=Qread(),v=Qread();
		ed[u][v]=ed[v][u]=true;
	}
	do
	{
		if(!chk()) continue;
		cnt++;
		ans=(ans+qpow(k,get_cir()))%Mod;
	}while(next_permutation(p+1,p+n+1));
	printf("%d\n",ans*qpow(cnt,Mod-2)%Mod);
	return 0;
}
```

---

## 作者：littlez_meow (赞：4)

一道 Pólya 定理入门级应用题。

[题目指路](https://www.luogu.com.cn/problem/P8633)。

如果你还不会 Pólya 定理，请看[这里](https://www.luogu.com.cn/blog/littleZ-meow-0v0/p4980-mu-ban-polya-ding-li-ti-xie)。

## 建模

首先，看到题面里有什么“变换”“本质不同”“染色”，就可以想到 Pólya 定理。而使用 Pólya 定理，最关键的一步是群论建模。

根据题目中的输入形式，我们可以把玩具看成一个图，然后对其节点染色。

把 Pólya 定理拿出来，我们一个一个找变量的意义：

$$|X/G|=\dfrac 1{|G|}\sum\limits_{g\in G}|D|^{c(g)}$$

$D$ 非常清晰，就是颜色集合，$|D|=k$。

$X$ 也不难想，为给出的图在染色后的所有情况的集合，而等价类个数 $X/G$ 就是题目要的本质不同方案数。

关键在于这个置换群 $G$。它肯定是作用在节点上所有置换组成的群的子群。但是不是任意一种置换都可以呢？显然不是。对于某些置换，在节点上作用后，会导致本来有的边在不应出现的地方出现。因此，我们要的置换 $P=(p_1,p_2,\cdots,p_n)$ 应该满足若原图中存在边 $(u,v)$，则也应存在边 $(p_u,p_v)$。这样，变换前后的两张图就是同构的，没有边处于不该在的位置。我们只要枚举全部置换，然后对每两个点判断边的存在性是否改变就可以了。

举个例子，样例中的 $(1,1,2)$ 与 $(2,1,1)$ 本质相同就是作用了置换 $(3,2,1)$。图中原本有的边 $(1,2)$ 和 $(2,3)$ 在置换后仍然存在。

最后是拆成循环置换个数 $c(g)$ 的求法。回忆我们的证明过程，对于一个置换 $P=(p_1,p_2,\cdots,p_n)$，我们连 $n$ 条边 $(i,p_i)$，组成的环循环置换。因此，循环置换的个数就是环的个数。遍历一次图就可以了。

枚举所有置换 $O(n!)$，判断置换是否合法 $O(n^2)$；每次求循环置换 $O(n)$，一共求 $|G|$ 次。总的时间复杂度是 $O(n!\cdot n^2+n|G|)$。

## 附上代码

因为实现奇特导致常数巨大，不得不开 O2，接近最劣解。

```cpp
#include<bits/stdc++.h>
#define F(i,a,b) for(int i(a),i##i##end(b);i<=i##i##end;++i)
#define R(i,a,b) for(int i(a),i##i##end(b);i>=i##i##end;--i)
#define ll long long
#define _ 0
using namespace std;
const int MOD=1e4+7;
inline ll qpow(ll base,int expo){
	ll res(1);
	while(expo){
		if(expo&1) res=res*base%MOD;
		base=base*base%MOD;
		expo>>=1;
	}
	return res;
}
int n,m,k;
bitset<11>edge[11];
bitset<11>book;
int permutation[11],sizeG,ans;
inline void bfs(int bg){
	queue<int>q;
	q.push(bg);
	book[bg]=1;
	while(!q.empty()){
		int now=q.front();
		q.pop();
		int i=permutation[now];
		if(book[i]) continue;
		book[i]=1;
		q.push(i);
	}
	return;
}
inline int calc(){
	int cnt(0);
	book.reset();
	F(i,1,n) if(!book[i]) ++cnt,bfs(i);
	return cnt;
}
void dfs(int step){
	if(step==n+1){
		F(i,1,n) F(j,i+1,n) if(edge[i][j]!=edge[permutation[i]][permutation[j]]) return;
		++sizeG;
		ans=(ans+qpow(k,calc()))%MOD;
		return;
	}
	F(i,1,n){
		if(book[i]) continue;
		book[i]=1,permutation[step]=i;
		dfs(step+1);
		book[i]=0;
	}
	return;
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>n>>m>>k;
	F(i,1,m){
		int a,b;
		cin>>a>>b;
		edge[a][b]=edge[b][a]=1;
	}
	dfs(1);
	cout<<ans*qpow(sizeG,MOD-2)%MOD;
	return ~~(0^_^0);
} 
```
不喜勿喷 awa~

顺带一提，样例解释中的 $(2,2,1)$ 似乎是与 $(1,2,2)$ 本质相同，而不是 $(2,1,2)$。

---

## 作者：Lyrella (赞：2)

# 简要题意

对一张 $n$ 个点 $m$ 条边的图进行 $k$ 染色，求本质不同方案数。

# 题解

看到求本质不同的方案数我们考虑用 polya 定理解决。这里直接放出式子：

$$
|S/T|={1\over|T|}\sum_{g\in T}|N|^{c(g)}
$$

我们现在来分析一下用 polya 定理需要什么东西？首先我们要找出合法的置换群 $T$，以及每个置换的轮换个数 $c(g)$。

翻译一下：首先何为合法的 $T$？考虑 $T$ 作用在 $S$ 上之后得到的 $S'$ 应该与 $S$ 同构，因为若原图存在 $(u,v)$ 那么置换后就会有 $(p_u,p_v)$，所以满足同构。然后你发现 $n$ 很小于是我们暴力枚举全排列看哪些是合法的，如果合法就计算答案即可。而 $c(g)$ 就是考虑置换的轮换数，这个每次直接扫一遍即可。

时间复杂度考虑全排列有一个 $O(n!)$，然后判断合法可以接受 $O(n^2)$，计算答案还有一个 $O(n|T|)$，最后一共就是 $O(n^2\times n!+n|T|)$。

---

## 作者：IC0CI (赞：1)

## 题面分析

给 $n$ 个点，用 $k$ 个颜色进行染色，有 $m$ 条边，求非等价着色数。

### 关于主要内容

对于这样一道考 Pólya 定理的题目，我考虑直接套用式子

$$
N(G,\mathcal{C}) = \frac{1}{|G|} \sum_{f \in G}{\#(f)}
$$

其中 $N(G,\mathcal{C})$ 为非等价着色数，$G$ 为置换群，$f$ 为一个置换，$\#(f)$ 表示置换的循环因子分解中循环的个数。

设 $f$ 是 $X$ 的一个置换，$D_f = (X,A_f)$ 是顶点集为 $X$ 且弧集为 $A_f=\{(i,f(i)):i \in X\}$ 的有向图。$A_f$ 可以划分成若干有向圈，且每个顶点恰好只属于一个有向圈。

如果在一个置换中某些元素以循环的方式置换且余下的元素保持不变，则称其为**循环置换**，简称**循环**。我们称有 $k$ 个元素的循环为 $k$ 循环。

于是对应于合成运算，$f$ 有唯一的循环因子分解。

$$
f = [i_1,i_2, \cdots,i_p] \circ [j_1,j_2, \cdots,j_p] \circ \cdots \circ [l_1,l_2, \cdots,l_p]
$$

记置换 $f$ 的循环分解中的循环个数为 $\#(f)$。

举个例子，

置换

$$
f =
\begin{pmatrix}
 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8\\
 4 & 3 & 2 & 6 & 1 & 5 & 7 & 8\\
\end{pmatrix}\\
=
[1,4,5,6] \circ [2,3] \circ [7] \circ [8]
$$

其中 $\#(f)=4$。

### 关于限制

对于每条边 $(u,v)$ 我们要保证在置换

$$
f =
\begin{pmatrix}
 1 & 2 & \cdots & n\\
 i_1 & i_2 & \cdots & i_n\\
\end{pmatrix}
$$

作用后仍存在边 $(i_u,i_v)$。

### 关于数据范围

注意到 $n$ 很小，所以我们可以直接枚举 $n^2$ 种置换，再判断每种置换是否符合限制条件，而且可以用领接矩阵存边。

# Code

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long

int rd()//快读
{
    int x = 0,w = 1;
    char ch = 0;
    while(ch < '0' || ch > '9')
    {
        if(ch == '-') w = -1;
        ch = getchar();
    }
    while(ch >= '0' && ch <= '9')
    {
        x = x * 10 + (ch - '0');
        ch = getchar();
    }
    return x * w;
}

const int N = 15;
const int mod = 10007;

int Pow(int n,int k)//快速幂
{
    int ans = 1;
    while(k)
    {
        if(k & 1)
        {
            ans *= n;
            ans %= mod;
        }
        n *= n;
        n %= mod;
        k >>= 1;
    }
    return ans;
}

int n,m,k;
bool mp[N][N],vis[N];
int a[N],sz[N],tot;

bool check()
{
    for(int i = 1;i <= n;i++)
        for(int j = i;j <= n;j++)
            if(mp[i][j] && !mp[a[i]][a[j]]) return 0;
    return 1;
}

void get()//记录循环因子个数
{
    memset(vis,0,sizeof(vis));
    tot = 0;
    for(int i = 1;i <= n;i++)
    {
        if(!vis[i])
        {
            int pos = i;
            while(!vis[pos])
            {
                vis[pos] = 1;
                pos = a[pos];
            }
            tot++;
        }
    }
}

signed main()
{
    n = rd(),m = rd(),k = rd();
    while(m--)
    {
        int u = rd(),v = rd();
        mp[u][v] = mp[v][u] = 1;
    }
    for(int i = 1;i <= n;i++) a[i] = i;
    int ans = 0,sum = 0;
    while(1)
    {
        if(check())
        {
            sum++;
            get();
            ans = (ans + Pow(k,tot)) % mod;
        }
        if(!next_permutation(a + 1,a + n + 1)) break;//全排列函数
    }
    cout << ans * Pow(sum,mod - 2) % mod;
    return 0;
}
```
*样例解释似乎错了*

---

## 作者：xiezheyuan (赞：1)

## 简要题意

有一个 $n$ 个点 $m$ 条边的无向图，有 $k$ 种颜色，你可以对每个点染成 $k$ 种颜色中的任意一种，输出本质不同的染色方案个数。两个方案本质相同，当且仅当存在一个对图重新标号的方案，使得重新标号后这两张图染色方案相同。

答案对 $10007$ 取模。

$1\leq n\leq 10,1\leq m \leq 45,1\leq k\leq 30$

## 思路

看到要对本质不同的染色方案计数，自然想到 Burnside 引理。

考察 Burnside 引理，则本题中的群 $G$ 表示合法的重标号方案，一个重标号方案显然是可以用 $n$ 次置换描述的。所以这里的 $G$ 是 $n$ 次置换群的一个子群。考察怎样的置换存在于这个子群中，记这个置换为 $p$，则在子群中的充要条件应该是对于原图中的每一条边 $(i,j)$，$(p_i,p_j)$ 是原图中的边。

但是这样子让人不太放心，你怎么可以确定这个子群真的是一个群（换句话说，每个置换存在逆元且运算封闭）呢？

- 运算封闭性证明：假设是 $p\times q$，则 $(p_i,p_j)$ 变成了 $(p_{q_i},p_{q_j})$，这条边仍然存在，因为 $(p_i,p_j)$ 边存在，所以满足进入子群的充要条件，所以运算封闭。
- 存在逆元证明：发现置换的逆元需要将 $(p_i,p_j)$ 变成 $(i,j)$，这也是边到边的关系，同样符合进入子群的充要条件，所以存在逆元。

然后考察 $|X^g|$ 如何计算，也就是在重标号后本质不变的方案数，我们考虑令置换环的个数为 $c$，则同一个置换环内必须染成同一个颜色，不同的置换环内的点染色互相不影响，所以 $|X^g|$ 就是 $k^c$。数置换环最好的方法是直接 dfs，但是我图省事写的是并查集。

然后你就做完了。这道题 $n$ 太小了，不需要考虑减少置换数量，直接枚举全排列一个一个判断就好了。

时间复杂度期望 $O((m+n)\cdot n!)$ 可以通过本题。

## 代码

为什么大家都跑得这么快啊，我不理解。在这里放一个写得比较丑的代码。

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 15, M = 45, mod = 10007;

bool g[N][N];
int n, m, k, p[N], fa[N], g2[M][2], kpow[N];
int ans, cnt, gcnt;

int find(int x){ return fa[x] == x ? x : fa[x] = find(fa[x]); }
int fastpow(int a, int b){
	int res=1;
	for(;b;a=1ll*a*a%mod,b>>=1) if(b&1) res=1ll*a*res%mod;
	return res;
}
int Add(int x, int y){return (x + y > mod ? x + y - mod : x + y);}

signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0); cout.tie(0);
	cin >> n >> m >> k;
	for(int i=1,u,v;i<=m;i++){
		cin >> u >> v;
		g[u][v] = g[v][u] = 1;
		g2[i][0] = u;g2[i][1] = v;
	}
	kpow[0] = 1;
	for(int i=1;i<=n;i++) kpow[i] = kpow[i - 1] * k % mod;
	for(int i=1;i<=n;i++) p[i] = i;
	do{
		bool flag = 0;
		for(int i=1;i<=m;i++){
			if(!g[p[g2[i][0]]][p[g2[i][1]]]){
				flag = 1;
				break;
			}
		}
		if(flag) continue;
		for(int i=1;i<=n;i++) fa[i] = i;
		for(int i=1;i<=n;i++) fa[find(i)] = find(p[i]);
		cnt = 0;gcnt++;
		for(int i=1;i<=n;i++){
			if(find(i) == i) cnt++;
		}
		ans = Add(kpow[cnt], ans);
	} while(next_permutation(p + 1, p + n + 1));
	cout << ((1ll * ans * fastpow(gcnt, mod - 2)) % mod);
	return 0;
}
```

---

## 作者：Somusomunia (赞：1)

## 题目大意
对于一张有 $n$ 个节点的图，用 $k$ 种颜色进行染色，求有多少种本质上不同的图。

其中，定义本质相同的图为在重新对节点进行标号后，与原图的染色方式相同。
## 思路
观察这道题的数据范围，$n$ 和 $m$ 较小，考虑直接带入 polya 计算。

$ANS=\frac{1}{n}\sum_{g\in G} {k^{c(g)}}$

首先用 next_permutation 函数遍历所有的置换，再判断置换是否合法，并统计合法置换的数量（即群 $G$ 的大小）。

再遍历统计 $c(g)$，统计置换中的环。

答案就出来了。

复杂度为 $O(m\times n!+|G|\times n)$（虽然也没有快多少，有可能是我不会卡常）。
## code
```cpp
#include<bits/stdc++.h>
using namespace std;
#define f(i) ed[i].first
#define s(i) ed[i].second
const int mod=10007;
int cur=0;
int e[20][20],p[50];
pair<int,int> ed[50];
int n,m,k,u,v,g;
int vis[20];
long long ans=0;
inline int read () {
	int f = 1,num=0;
	char ch = getchar ();
	while (!isdigit (ch)) {if (ch == '-') f *= -1; ch = getchar ();}
	while (isdigit (ch)) num = num * 10 + ch - '0', ch = getchar ();
	return num * f;
}
long long fp(long long bas,long long ind){
	long long ans=1,tmp=bas;
	while(ind){
		if(ind&1) ans=(ans%mod*tmp%mod)%mod;
		tmp=tmp%mod*tmp%mod,ind=ind>>1;
	}
	return ans;
}
inline int ccnt(){
	int cnt=0,nx;
	memset(vis,0,sizeof(vis));
	for(int i=1;i<=n;i++){
		if(vis[i]) continue;
		nx=i;
		do vis[nx]=1,nx=p[nx];
		while(nx!=i);
		cnt++;
	}
	return cnt;
}
bool check(){
	for(int i=1;i<=m;i++) if(!e[p[f(i)]][p[s(i)]]) return true;
	return false;
} 
int main(){
	n=read(),m=read(),k=read();
	for(int i=1;i<=n;i++) p[i]=i;
	for(int i=1;i<=m;i++) u=read(),v=read(),e[u][v]=e[v][u]=1,ed[i]=make_pair(u,v);
	do{
		if(check())continue;
		g++;
		ans=(ans+fp(k,ccnt()))%mod;
	}while(next_permutation(p+1,p+n+1));
	cout<<ans*fp(g,mod-2)%mod;
	return 0;
}
```

---


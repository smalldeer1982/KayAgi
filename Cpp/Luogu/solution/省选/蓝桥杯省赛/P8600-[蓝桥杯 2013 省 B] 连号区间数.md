# [蓝桥杯 2013 省 B] 连号区间数

## 题目描述

小明这些天一直在思考这样一个奇怪而有趣的问题：

在 $1$ ~ $N$ 的某个全排列中有多少个连号区间呢？这里所说的连号区间的定义是：

如果区间 $[L, R]$ 里的所有元素（即此排列的第 $L$个到第 $R$ 个元素）递增排序后能得到一个长度为 $R-L+1$ 的“连续”数列，则称这个区间连号区间。

其中对“连续”数列的定义：

记长度为 $m$ 的数列 $A$ 第 $i$ 个元素为 $A_i$，当 $\forall i \in [2,m]，a_i=a_{i-1}+1$ 时认为该数列为“连续”数列。

当 $N$ 很小的时候，小明可以很快地算出答案，但是当 $N$ 变大的时候，问题就不是那么简单了，现在小明需要你的帮助。

## 说明/提示

第一个用例中，有 $7$ 个连号区间分别是：$[1,1]$, $[1,2]$, $[1,3]$, $[1,4]$, $[2,2]$, $[3,3]$, $[4,4]$。

第二个用例中，有 $9$ 个连号区间分别是：$[1,1]$, $[1,2]$, $[1,3]$, $[1,4]$, $[1,5]$, $[2,2]$, $[3,3]$, $[4,4]$, $[5,5]$。

原题时限 5 秒, 64M。蓝桥杯 2013 年第四届省赛

## 样例 #1

### 输入

```
4
3 2 4 1```

### 输出

```
7```

## 样例 #2

### 输入

```
5
3 4 2 5 1```

### 输出

```
9```

# 题解

## 作者：chen_zhe (赞：20)

题解怎么都是 $O(n^2)$ 的……？其实这个题可以 $O(n \log n)$ 的时间复杂度内完成。一个类似的题目是 [CF526F](https://www.luogu.com.cn/problem/CF526F)。

本题的题意是：统计有多少个区间 $[l,r]$，计区间最大值为 $\max$，区间最小值为 $\min$，区间长度为 $\mathrm{len}=r-l$，满足关系式 $\mathrm{max}-\mathrm{min}=\mathrm{len}$。

进行对原关系式的移项，有 $\mathrm{max}-\mathrm{min}+l=r$。具体而言，考虑套路地枚举区间右端点 $r$ 进行扫描线，求出以 $r$ 为结尾的符合要求的区间个数，然后再求和。而为了满足这一要求，我们需要使用单调栈+线段树维护。考虑到  $\mathrm{max}-\mathrm{min} \geq r-l$，可以使用单调栈维护每个后缀的 $\mathrm{max}$ 和 $\mathrm{min}$，再用线段树维护 $\mathrm{max}-\mathrm{min}-len$ 的最小值以及其出现次数，这个维护就比较简单。时间复杂度 $O(n \log n)$。

本题也可以使用析合树完成。析合树的学习资料请参考 [OI-wiki](https://oi-wiki.org//ds/divide-combine/)。

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <cmath>
#include <cctype>
#include <queue>
#include <vector>

using namespace std;

inline int read()
{
	int x=0,f=1;char ch=getchar();
	while (!isdigit(ch)){if (ch=='-') f=-1;ch=getchar();}
	while (isdigit(ch)){x=x*10+ch-48;ch=getchar();}
	return x*f;
}

int n,a[300050];

struct Seg_Tree
{
	int l,r;
	int tag,val,minv;
}t[1200050];

inline void Push_Up(int id)
{
	t[id].minv=min(t[id<<1].minv,t[id<<1|1].minv);
	t[id].val=(t[id].minv==t[id<<1].minv?t[id<<1].val:0)+(t[id].minv==t[id<<1|1].minv?t[id<<1|1].val:0);
}

inline void Build(int id,int l,int r)
{
	t[id].l=l;
	t[id].r=r;
	if (l==r)
	{
		t[id].minv=l;
		t[id].val=1;
		return;
	}
	int mid=(l+r)>>1;
	Build(id<<1,l,mid);
	Build(id<<1|1,mid+1,r);
	Push_Up(id);
}

inline void Push_Down(int id)
{
	if (t[id].tag)
	{
		t[id<<1].tag+=t[id].tag;
		t[id<<1|1].tag+=t[id].tag;
		t[id<<1].minv+=t[id].tag;
		t[id<<1|1].minv+=t[id].tag;
		t[id].tag=0;
	}
}

inline void Change(int id,int l,int r,int val)
{
	if (l<=t[id].l && t[id].r<=r)
	{
		t[id].tag+=val;
		t[id].minv+=val;
		return;
	}
	Push_Down(id);
	int mid=(t[id].l+t[id].r)>>1;
	if (r<=mid)
		Change(id<<1,l,r,val);
	else if (l>mid)
		Change(id<<1|1,l,r,val);
	else
	{
		Change(id<<1,l,mid,val);
		Change(id<<1|1,mid+1,r,val);
	}
	Push_Up(id);
}

int st1[300050],st2[300050],top1,top2;

long long ans;

int main()
{
	n=read();
	for (int i=1;i<=n;i++)
		a[i]=read();
	Build(1,1,n);
	for (int i=1;i<=n;i++)
	{
		int p=i;
		while (top1 && a[i]<a[st1[top1]])
		{
			Change(1,st1[top1-1]+1,p-1,a[st1[top1]]-a[i]);
			p=st1[top1];
			top1--;
		}
		p=i;
		while (top2 && a[i]>a[st2[top2]])
		{
			Change(1,st2[top2-1]+1,p-1,-a[st2[top2]]+a[i]);
			p=st2[top2];
			top2--;
		}
		st1[++top1]=st2[++top2]=i;
		ans+=t[1].val;
	}
	cout << ans << endl;
	return 0;
}
```

---

## 作者：Jr_Zlw (赞：13)

## 分治

新版题中还没有分治题解，而且旧版题里面分治也貌似是小众做法，那我来水一发吧。

不需要复杂的数据结构，你只需要会一个桶和基本分治套路。

因为  $P$  是一个排列，所以连号区间等价于  $\max_{i=l}^rP_i-\min_{i=l}^{r}P_i=r-l$。

在解决这种限制条件中含有区间极值的全局区间计数问题时，分治非常有用。

考虑当前分治区间  $[L,R]$,设  $mid$  为区间中点，把完全包含在  $[L,mid]$,和  $(mid,R]$  的区间扔到下一层分治去计算。此时就只需要考虑左端点在  $[L,mid]$,右端点在  $(mid,R]$  的区间了。

设一个需要考虑的区间为  $[l,r]$，设  $m=\max_{i=l}^r P_i$。

### 第一种情况：

$l,m\in[L,mid];r\in(mid,R]$。

转化等式，有  $\max_{i=l}^{r}P_i+l=\min_{i=l}^rP_i+r$。

考虑对每一个  $l$  找出一个最大的  $r$  满足  $\max_{i=mid+1}^r P_i < \max_{i=l}^{mid} P_i$。

这个时候就只需要考虑有多少个  $r'\in(mid,r]$   满足$\min_{i=mid+1}^{r'}P_i+r=m+l$，开个桶记录一下就行，同时要注意去掉  $\{r''|\min_{i=l}^{mid}P_i<\min_{i=mid+1}^{r''}P_i\}$  的贡献并判一下对应的  $r'''=\max_{i=l}^{mid}P_i+l-\min_{i=l}^{mid}P_i$  是否在范围内。

### 第二种情况：

$l\in[L,mid];r,m\in(mid,R]$。

可以发现这两种情况加上分治下去处理的区间覆盖了所有区间。

转化等式，有  $\max_{i=l}^{r}P_i-r=\min_{i=l}^rP_i-l$。

处理方法跟上面类似，这里不再赘述。

code:

```
#include<bits/stdc++.h>
#define rep(a,b,c) for(int c(a);c<=(b);++c)
#define drep(a,b,c) for(int c(a);c>=(b);--c)
using namespace std;
inline int read()
{
	int res=0;char ch=getchar();while(ch<'0'||ch>'9')ch=getchar();
	while(ch<='9'&&ch>='0')res=res*10+(ch^48),ch=getchar();return res;
}
typedef long long ll;
const int N=5e4+10,M=1e5+5;
int a[N],n,mn[N],mx[N],cnt[N<<2];ll ans;
inline void Solve(int l,int r)
{
	if(l==r){++ans;return;} int mid=(l+r)>>1;
	mn[mid+1]=a[mid+1];mx[mid+1]=a[mid+1];
	rep(mid+2,r,i)mn[i]=min(mn[i-1],a[i]),mx[i]=max(mx[i-1],a[i]);
	mn[mid]=a[mid];mx[mid]=a[mid];
	drep(mid-1,l,i)mn[i]=min(mn[i+1],a[i]),mx[i]=max(mx[i+1],a[i]);
	int pr=mid+1,ppr=mid+1;drep(mid,l,pl)
	{
		while(pr<=r&&mx[pr]<mx[pl]){++cnt[mn[pr]+pr+M];++pr;}
		while(ppr<pr&&mn[ppr]>mn[pl]){--cnt[mn[ppr]+ppr+M];++ppr;}
		ans+=cnt[mx[pl]+pl+M];int tr=mx[pl]+pl-mn[pl];
		if(mid<tr&&tr<ppr)++ans;
	}
	for(int i=ppr;i<pr;++i)cnt[mn[i]+i+M]=0;
	int pl=mid,ppl=mid;rep(mid+1,r,pr)
	{
		while(pl>=l&&mx[pl]<mx[pr]){++cnt[mn[pl]-pl+M];--pl;}
		while(ppl>pl&&mn[ppl]>mn[pr]){--cnt[mn[ppl]-ppl+M];--ppl;}
		ans+=cnt[mx[pr]-pr+M];int tl=mn[pr]-mx[pr]+pr;
		if(ppl<tl&&tl<=mid)++ans;
	}
	for(int i=ppl;i>pl;--i)cnt[mn[i]-i+M]=0;
	Solve(l,mid);Solve(mid+1,r);
}
int main()
{
	n=read();rep(1,n,i)a[i]=read();
	Solve(1,n);printf("%lld\n",ans);
}
```

时间复杂度  $O(n\log n)$。

---

## 作者：Otomachi_Una_ (赞：13)

## 问题简述

> - 给定排列 $p$。求有多少 $[l,r]$ 使得 $p[l,r]$ 排序后连续。
> - $n\leq 5\times 10^4$。

## 解题思路

我们把“$p[l,r]$ 排序后连续”改写为：
$$
\max_{l\leq i\leq r} p_i-\min_{l\leq i\leq r} p_i=r-l
$$
枚举 $r$ 我们只需要
$$
\max_{l\leq i\leq r} p_i-\min_{l\leq i\leq r} p_i+l=r
$$
并且不难发现有不等式：
$$
\max_{l\leq i\leq r} p_i-\min_{l\leq i\leq r} p_i+l\geq r
$$
于是我们只需要记录最小值的个数即可。

我们会发现当 $r$ 右移的时候，对于 $l$ 的 $\max p,\min p$ 都会有变化，不难发现每次加入 $p_r$ 都是把 $\max p,\min p$ 的一次区间推平操作。推平+最小值个数显然难搞，但是不难发现推平必然是一段一段的，以 $\min$ 数组为例，如下图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/bf6pno3c.png)

其实原来的 $\min$ 数组已经是一段一段的了，于是我们可以把推平转为每段区间加。不难发现这样的区间加并不多，本质上就是单调栈，不会超过 $n$ 次调用。$\max$ 同理。

于是我们使用了维护区间加，全域最小值个数的线段树完成了本题。

## 参考代码

```cpp
#include<iostream>
using namespace std;
const int MAXN=5e4+5;
int n;
int p[MAXN];
struct sug{
	int laz,minn,cnt; 
}a[MAXN<<2];
int st1[MAXN],cnt1;// 大根堆 
int st2[MAXN],cnt2;
void pushup(int id){
	a[id].minn=min(a[id<<1].minn,a[id<<1|1].minn);
	a[id].cnt=(a[id].minn==a[id<<1].minn?a[id<<1].cnt:0)+
		(a[id].minn==a[id<<1|1].minn?a[id<<1|1].cnt:0);
}
void pushdown(int id){
	a[id<<1].minn+=a[id].laz,a[id<<1].laz+=a[id].laz;
	a[id<<1|1].minn+=a[id].laz,a[id<<1|1].laz+=a[id].laz;
	a[id].laz=0;
}
void build(int id,int l,int r){
	if(l==r){a[id].minn=l,a[id].cnt=1;return;}
	int mid=l+r>>1;
	build(id<<1,l,mid);
	build(id<<1|1,mid+1,r);
	pushup(id);
}
void add(int id,int l,int r,int L,int R,int x){
	if(L<=l&&r<=R){a[id].minn+=x,a[id].laz+=x;return;}
	int mid=l+r>>1;
	pushdown(id);
	if(L<=mid) add(id<<1,l,mid,L,R,x);
	if(mid<R) add(id<<1|1,mid+1,r,L,R,x);
	pushup(id);
	return;
}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++)
		cin>>p[i];
	build(1,1,n);
	long long ans=0;
	for(int i=1;i<=n;i++){
		int q=i;
		while(cnt1&&p[i]>p[st1[cnt1]]){
			add(1,1,n,st1[cnt1-1]+1,q-1,p[i]-p[st1[cnt1]]);
			q=st1[cnt1--];
		}
		q=i;
		while(cnt2&&p[i]<p[st2[cnt2]]){
			add(1,1,n,st2[cnt2-1]+1,q-1,-p[i]+p[st2[cnt2]]);
			q=st2[cnt2--];
		}
		st1[++cnt1]=st2[++cnt2]=i;
		ans+=a[1].cnt;
	} 
	cout<<ans;
	return 0;
}
```


---

## 作者：5k_sync_closer (赞：9)

**析合树**是一种**连续段**数据结构。

引入：
>给定**排列** $\{P_n\}$，求值域连续的段的个数。

# 概念
**排列** 是排列。

**连续段** 是值域连续的段，满足集合运算。

**值域区间** 是连续段值域的区间。

**本原段** 是不与其他连续段**部分相交**的连续段。

**连续段集** $I_p$，**本原段集** $M_p$。

形式化的，

定义序列 $P$ 是 $n$ 阶**排列** $\Leftrightarrow|P|=n$ 且 $\forall i\in[1,n],i\in P$。

定义 $(P,[l,r])$ 是**连续段** $\Leftrightarrow\nexists x,z\in[l,r],y\notin[l,r],P_x<P_y<P_z$。

连续段 $(P,[l,r])$ 满足 $[l,r]$ 上的集合运算。

定义 $(P,[l,r])$ 的**值域区间**为 $[\min\limits_{i=l}^rP_i,\max\limits_{i=l}^rP_i]$。

定义**连续段集** $I_p=\{A|A\ \text{是连续段}\}$。

定义连续段 $X$ 是**本原段** $\Leftrightarrow\forall A\in I_p,X\cap A=(P,\varnothing)$ 或 $X\subseteq A$ 或 $A\subseteq X$。

定义**本原段集** $M_p=\{A|A\ \text{是本原段}\}$。

# 析点与合点
析合树的点集是 $M_p$。

### 概念
节点 $u$ 的 **值域区间** 为 $[u_l,u_r]$。

节点 $u$ 的 **子节点序列** $S_u$ 是 $u$ 的**极长**真子连续段序列。

节点 $u$ 的 **子节点排列** $P_u$ 是 $S_u$ **按值域区间左端点**离散化的结果。

节点 $u$ 是 **合点** 当且仅当 $P_u$ 有序。

节点 $u$ 是 **析点** 当且仅当 $u$ 不是合点。

形式化的，

定义节点 $u$ 的**值域区间**为 $[u_l,u_r]$。

定义节点 $u$ 的**子节点序列** $S_u=\{v|v\subsetneqq u,\nexists 
w\subsetneqq u,v\subsetneqq w\}$，且按 $v$ 的**左端点**排序。

注意，$v$ 的**左端点**不是 $v$ 的**值域区间左端点**。

定义节点 $u$ 的**子节点排列** $P_{u,i}=|\{v_l\le{S_{u,i}}_l|v\in S_u\}|$。

定义节点 $u$ 是**合点** $\Leftrightarrow\forall i\in[1,|S_u|],P_{u,i}=i$ 或 $\forall i\in[1,|S_u|],P_{u,i}=|S_u|-i+1$。

定义节点 $u$ 是**析点** $\Leftrightarrow u$ 不是合点。

### 性质
$u$ 的子节点的并是 $u$。显然。

$u$ 是合点当且仅当 $S_u$ 的子段构成连续段。显然。

$u$ 是析点当且仅当 $S_u$ 的多元素**真**子段不构成连续段。

证明：若命题不成立，则 $S_u$ 上构成连续段的极长**真**子段构成本原段，而此本原段未在析合树中出现。

形式化的，

$\bigcup\limits_{v\in S_u}v=u$。

$u$ 是合点 $\Leftrightarrow\forall [l,r]\subseteq[1,|S_u|],\bigcup\limits_{i=l}^rS_{u,i}\in I_p$。

$u$ 是析点 $\Leftrightarrow\forall [l,r]\subseteq[1,|S_u|],l<r,\bigcup\limits_{i=l}^rS_{u,i}\notin I_p$。

# 建树
可以用 **增量法** $O(n\log n)$ 建析合树。

将 $P_i$ 依次加入析合树，用一个栈维护 $P_j|j\in[1,i)$ 形成的析合森林。
### 策略
维护当前节点 $u$（初值为 $(P,[i,i])$），考虑 $u$ 与栈内节点的合并情况。

1. $u$ 能成为栈顶节点的子节点 $\Leftrightarrow$ 栈顶节点是合点且 $u$ 与栈顶节点的**最右**子节点能合并成连续段，令 $u$ 成为栈顶节点的子节点，然后令 $u\gets$ 栈顶节点。
2. $u$ 不能成为栈顶节点的子节点，令 $u$ 与栈顶若干节点合并成连续段 $v$ 且 $|S_v|$ 最小。考虑 $v$ 的类型，容易发现此时 $v$ 是合点 $\Leftrightarrow |S_v|=2$。令 $u\gets v$。
3. 重复上述方案直到不能进行（即找不到 2. 中合法的 $v$），将 $u$ 入栈。

![](https://codeforces.com/predownloaded/95/91/9591a2bbbeec8cc63ceb752d1cb5f111339e9385.png)

（来自 CF，对 $\{9,1,10,3,2,5,7,6,8,4\}$ 建析合树）

根据上述策略，我们需要快速判断 $u$ 与一些点能否合并成连续段，即判断任意后缀 $[j,i]|j\in[1,i)$ 是否连续段。
### 子问题
考虑如何快速判断 $[j,i]|j\in[1,i)$ 是否连续段。

$P$ 是排列，所以 $[j,i]$ 是连续段当且仅当 $\max\limits_{j\le k\le i}-\min\limits_{j\le k\le i}=i-j$。

维护 $Q_j=\max\limits_{j\le k\le i}-\min\limits_{j\le k\le i}-i+j|j\in[1,i)$，则 $[j,i]$ 是连续段当且仅当 $Q_j=0$。

考虑更新 $i$ 时如何快速更新 $Q$。

在 $\max\limits_{j\le k\le i}-\min\limits_{j\le k\le i}-i+j$ 中，$j$ 是不变的，每次更新 $i$ 对 $Q_j$ 的贡献减一，最值的贡献不好维护。

设 $P_i$ 更新了 $B_i$ 个后缀最值的**位置**，注意到 $\sum\limits_{i=1}^nB_i=O(n)$（单调栈结论）。

用单调栈维护后缀最值的位置，以后缀最小值为例。

维护单调递增的栈 $x$。不难发现 $P_{x_i}$ 是后缀 $[j,i]|j\in(x_{i-1},x_i]$ 的最小值。

$x_i$ 出栈时失去对 $Q_j|j\in(x_{i-1},x_i]$ 的贡献，所以 $Q_j|j\in(x_{i-1},x_i]\gets Q_j+P_{x_i}$。

$i$ 入栈时获得对 $Q_j|j\in(x_{top},i]$ 的贡献，所以 $Q_j|j\in(x_{top},i]\gets Q_j-P_i$。

后缀最大值同理。

# 关于本题
考虑析合树内每个点的贡献。

由合点的性质，若 $u$ 是合点，则 $S_u$ 的任意子段构成连续段，即 $u$ 的贡献为 $|S_u|\choose2$。

由析点的性质，若 $u$ 是析点，则 $S_u$ 的任意多元素子段不构成连续段，即 $u$ 的贡献为 $1$。

注意到 $|M_p|=O(n)$，所以时间复杂度 $O(n\log n)$。

```cpp
#include <cstdio>
#include <vector>
#define A(u, v) u->c.push_back(v)
using namespace std;
int n, L, X, Y, a[50050], x[50050], y[50050];
long long q;
struct S
{
	int l, r;
	bool b;
	vector<S *> c;
} * u, *f, *s[50050];
struct T
{
	T *l, *r;
	int s, t, v, x;
	T(int p, int q) : s(p), t(q), v(0), x(0) {}
	void f(int p)
	{
		v += p;
		x += p;
	}
	void u() { v = min(l->v, r->v); }
	void d()
	{
		l->f(x);
		r->f(x);
		x = 0;
	}
} * r;
void D(S *p)
{
	q += p->b ? 1ll * p->c.size() * (p->c.size() - 1) >> 1 : 1;
	for (auto c : p->c)
		D(c);
}
void B(int s, int t, T *&p)
{
	p = new T(s, t);
	if (s != t)
	{
		int m = p->s + p->t >> 1;
		B(s, m, p->l);
		B(m + 1, t, p->r);
		p->u();
	}
}
void M(int l, int r, int x, T *p)
{
	if (l <= p->s && p->t <= r)
		return p->f(x);
	p->d();
	int m = p->s + p->t >> 1;
	if (l <= m)
		M(l, r, x, p->l);
	if (r > m)
		M(l, r, x, p->r);
	p->u();
}
bool Q(int l, T *p)
{
	if (p->s == p->t)
		return !p->v;
	p->d();
	int m = p->s + p->t >> 1;
	return l <= m ? Q(l, p->l) : Q(l, p->r);
}
int Z(T *p)
{
	if (p->s == p->t)
		return p->s;
	p->d();
	int m = p->s + p->t >> 1;
	return p->l->v ? Z(p->r) : Z(p->l);
}
int main()
{
	scanf("%d", &n);
	B(1, n, r);
	for (int i = 1; i <= n; ++i)
		scanf("%d", a + i);
	for (int i = 1, p, o; i <= n; ++i)
	{
		while (X && a[i] <= a[x[X]])
			M(x[X - 1] + 1, x[X], a[x[X]], r), --X;
		while (Y && a[i] >= a[y[Y]])
			M(y[Y - 1] + 1, y[Y], -a[y[Y]], r), --Y;
		M(x[X] + 1, i, -a[i], r);
		M(y[Y] + 1, i, a[i], r);
		x[++X] = y[++Y] = i;
		u = new S{i, i, 0};
		p = Z(r);
		while (L && s[L]->l >= p)
			if (s[L]->b && Q(s[L]->c.back()->l, r))
				s[L]->r = i, A(s[L], u), u = s[L--];
			else
			{
				f = new S{0, i, Q(s[o = L]->l, r)};
				while (!Q(s[L]->l, r))
					--L;
				for (int j = L; j <= o; ++j)
					A(f, s[j]);
				f->l = s[L--]->l;
				A(f, u);
				u = f;
			}
		s[++L] = u;
		M(1, i, -1, r);
	}
	return D(s[1]), printf("%lld", q), 0;
}
```


---

## 作者：Transfixion_ (赞：8)

题目链接：[$\texttt{Link}$](http://www.luogu.com.cn/problem/P8600)

## $\textbf{Description}$

给定一个长为 $n$ 的排列，求有多少子序列满足其值域是连续的一段正整数。

$n\le 5\times 10^4$。

## $\textbf{Solution}$

**注：此篇题解是乱搞做法，仅供娱乐。以及卡常毁了我的一生。**

首先对题意做一个转化：子区间 $[l,r]$ 是连号区间当且仅当 $\max_{i\in[l,r]}-\min_{i\in[l,r]}=r-l$。

考虑固定左端点，然后移动右端点并更新当前区间的 $\max$ 和 $\min$ 即可做到 $\mathcal O(n^2)$。

交上去会发现 T 了前四个点，而且是 T 飞了。

$4\times 10^5,\mathcal O(n^2),750\text{ ms}$，还是有点希望的。于是我们开始卡常。

- 循环展开，优化效果明显。
- 将 `if` 换成三目运算符，优化效果明显。
- C++20，O2，优化效果明显。
- 将 `for` 换成 `while`，优化效果不知道因为我一直用的 `while`。
- 快读，优化效果基本没有。

结合以上可以通过测试点 #3 #4，#1 #2 也可以优化到几毫秒的差距（说的很轻松，其实提交记录多达三四面）。

然而这几毫秒就像博尔特的 9"58 一般难以打破，这里放一个[我的提交记录](https://www.luogu.com.cn/record/133946672)，到这里为止说不定选个评测机心情好的时候交就过了，不过我反正没过。

来点奇技淫巧。事实上，在我的卡常过程中，曾经有两份代码分别通过了 [#1](https://www.luogu.com.cn/record/133932831) 和 [#2](https://www.luogu.com.cn/record/133943496) **且在其他点上跑的更慢了**。

这两份代码是出于什么契机呢？在枚举右端点的过程中，$a_r$ 只会对当前区间的 $\max$ 和 $\min$ 中的至多一个产生贡献，而我的代码要调用一次 `std::max` 和一次 `std::min`，为了让赋值语句的执行次数尽量少，我选择用 `if ... else if` （另一份代码是两个三目运算符的嵌套）来代替取这两个赋值操作。从而写出了可以通过前两个点其一的代码。

然后对程序内容与评测结果进行分析。例如前 4 个点只通过了 #1 的代码：

```cpp
if(a[r] > max) max = a[r];
else if(a[r] < min) min = a[r];
```

首先有一个事实要知道：`std::max/min` 比自己写的三目运算符要快。

这份代码通过了 #1 但是**没有通过之前的代码能通过的 #3 #4**，说明 #1 的很大一部分 $r$ 只进入了第一层分支，即 $a_r$ 只对 $\max$ 有贡献而非 $\min$，翻译一下就是近似单增。

从而我们大胆猜测 #1 就是单调递增的排列。同理 #2 则是单调递减的排列。

对于一个单调的排列，显然它的任意子区间都是连号区间。卡时并输出子区间个数 $\frac12n(n+1)$ 就过了。

因为这实在是太离谱了，我在卡常过程中根本不敢去想：它甚至没有随机扰动，就是纯纯的单增单减。

放一个比较容易阅读的 AC 代码。事实上我在卡常过程中做出的各种尝试远比这篇题解所说的多，写的代码也远比以下代码长的多。

## $\textbf{AC Code}$

```cpp
#include <bits/stdc++.h>
#define gc() (iS == iT && (iT = (iS = buf) + fread(buf, 1, 1 << 20, stdin), iS == iT) ? EOF : *iS++)
char buf[1 << 20], *iS = buf, *iT = buf;
static inline void read(int& x) {
    char c = gc(); x = 0; bool f = 0;
    for(; !std::isdigit(c); c = gc()) f |= c == '-';
    for(; std::isdigit(c); c = gc()) x = (x << 1) + (x << 3) + (c ^ 48);
    f ? x = ~x + 1 : 1;
}

typedef long long i64;
constexpr int N = 5e4 + 5;
static int n, a[N], ans;

signed main() {
	int st = clock();
	read(n), ans = n;
	for(int i = 1; i <= n; i++) read(a[i]);
	int max, min, l = 1, r, d;
	while(l <= n) {
		max = a[l], min = a[l], r = l + 1, d = r - l;
		while(r + 16 <= n) {
			min = std::min(min, a[r]); max = std::max(max, a[r]); (d == max - min) ? ++ans : 1;
			min = std::min(min, a[r + 1]); max = std::max(max, a[r + 1]); (d + 1 == max - min) ? ++ans : 1;
			min = std::min(min, a[r + 2]); max = std::max(max, a[r + 2]); (d + 2 == max - min) ? ++ans : 1;
			min = std::min(min, a[r + 3]); max = std::max(max, a[r + 3]); (d + 3 == max - min) ? ++ans : 1;
			min = std::min(min, a[r + 4]); max = std::max(max, a[r + 4]); (d + 4 == max - min) ? ++ans : 1;
			min = std::min(min, a[r + 5]); max = std::max(max, a[r + 5]); (d + 5 == max - min) ? ++ans : 1;
			min = std::min(min, a[r + 6]); max = std::max(max, a[r + 6]); (d + 6 == max - min) ? ++ans : 1;
			min = std::min(min, a[r + 7]); max = std::max(max, a[r + 7]); (d + 7 == max - min) ? ++ans : 1;
			min = std::min(min, a[r + 8]); max = std::max(max, a[r + 8]); (d + 8 == max - min) ? ++ans : 1;
			min = std::min(min, a[r + 9]); max = std::max(max, a[r + 9]); (d + 9 == max - min) ? ++ans : 1;
			min = std::min(min, a[r + 10]); max = std::max(max, a[r + 10]); (d + 10 == max - min) ? ++ans : 1;
			min = std::min(min, a[r + 11]); max = std::max(max, a[r + 11]); (d + 11 == max - min) ? ++ans : 1;
			min = std::min(min, a[r + 12]); max = std::max(max, a[r + 12]); (d + 12 == max - min) ? ++ans : 1;
			min = std::min(min, a[r + 13]); max = std::max(max, a[r + 13]); (d + 13 == max - min) ? ++ans : 1;
			min = std::min(min, a[r + 14]); max = std::max(max, a[r + 14]); (d + 14 == max - min) ? ++ans : 1;
			min = std::min(min, a[r + 15]); max = std::max(max, a[r + 15]); (d + 15 == max - min) ? ++ans : 1;
			r += 16, d += 16;
		}
		while(r <= n) {
			min = std::min(min, a[r]); max = std::max(max, a[r]); (r - l == max - min) ? ++ans : 1;
			++r;
		}
		++l;
		if(clock() - st > .74 * CLOCKS_PER_SEC) {
			printf("%lld\n", 1ll * n * (n + 1) >> 1);
			return 0;
		}
	}
	printf("%d\n", ans);
	return 0;
}
```

---

## 作者：harmis_yz (赞：3)

题解摘自 [CSP2024 前做题情况](https://www.luogu.com.cn/article/3yyu431w)。

## 分析

首先这道题可以转化成求有多少个区间 $[l,r]$，使得 $r-l=\max(a_l,a_{l+1},\dots,a_r)-\min(a_l,a_{l+1},\dots,a_r)$。然后这种问区间数量，且存在区间最大、最小值的题。有一种套路，详见 [AT_abc248_h](https://www.luogu.com.cn/article/mrksztx2) 的题解。第一次遇到这种套路是在做 Norma 的时候。感觉很强啊。

考虑分治。我们枚举左端点 $l$，那么现在已知 $\max(a_l,a_{l+1},\dots,a_{mid})=mx,\min(a_l,a_{l+1},\dots,a_{mid})=mi$。令 $Max_i=\max\limits_{j=mid+1}^{i}a_j,Min_i=\min\limits_{j=mid+1}^{i} a_j$。我们能够通过指针找到最远的一个 $j$，使得 $Max_j \le mx$。也能找到一个最远的 $k$，使得 $Min_k \ge mi$。现在进行分类讨论：

1. $r \le \min(j,k)$。此时区间最小、最大值固定。那么有：$r=mx-mi+l \land mid+1 \le r \le \min(j,k)$。
2. $\min(j,k) < r \le \max(j,k)$。这时有两种情况，以 $j <k$ 为例。此时区间最小值固定，区间最大值与 $Max_r$ 相等。那么有：$l-mi=r-Max_r\land \min(j,k) < r \le \max(j,k)$。
3. $\max(j,k)<r \le R$。此时区间最小值与 $Min_r$ 相等，区间最大值与 $Max_r$ 相等。那么有：$l=r+Min_r-Max_r \land \max(j,k) < r \le R$。

上面的所有满足条件的 $r$ 都可以分别用桶存起来，所以访问是能够做到 $O(1)$ 的。故时间复杂度为 $O(n\log n)$。

## 代码

```cpp
il void work(int l,int r){
	if(l==r) return ++ans,void(0);
	int mid=l+r>>1;
	work(l,mid),work(mid+1,r);
	Max[mid]=-inf,Min[mid]=+inf;
	for(re int i=mid+1;i<=r;++i){
		Max[i]=max(Max[i-1],a[i]);
		Min[i]=min(Min[i-1],a[i]);
		++vis3[i+Min[i]-Max[i]+n];
	}
	int mx=-inf,mi=inf;
	int i=mid,j=mid,k=mid,w=mid+1,s=mid+1;
	for(;i>=l;--i){
		mx=max(mx,a[i]),
		mi=min(mi,a[i]);
		while(j+1<=r&&Max[j+1]<=mx) ++j;
		while(k+1<=r&&Min[k+1]>=mi) ++k;
		while(w<=min(j,k)){
			--vis1[w-Max[w]+n];
			--vis2[w+Min[w]+n];
			++w;
		}
		while(s<=max(j,k)){
			if(s>=w){
				++vis1[s-Max[s]+n];
				++vis2[s+Min[s]+n];
			}
			--vis3[s+Min[s]-Max[s]+n];
			++s;
		}
		int R=mx-mi+i;
		if(mid<R&&R<=min(j,k)) ++ans;//1
		if(j<k) ans+=vis1[i-mi+n];
		if(k<j) ans+=vis2[i+mx+n];//2
		ans+=vis3[i+n];//3
	}
	while(w<=r){
		vis1[w-Max[w]+n]=0;
		vis2[w+Min[w]+n]=0;
		++w;
	}
	while(s<=r){
		vis3[s+Min[s]-Max[s]+n]=0;
		++s;
	}	
	return ;
}
```

---

## 作者：WaterSun (赞：2)

[更好的阅读体验](https://www.cnblogs.com/WaterSun/p/18344474)

# 思路

首先明确，一个区间 $[l,r]$ 是一个连号，当且仅当该区间 $\max - \min = r - l$。

考虑套路地枚举右端点 $r$。问题转化为求满足 $\max - \min + l = r$ 的区间数量。

对于一个右端点 $r$，我们可以使用单调栈维护每一个后缀的 $\max,\min$。现在问题就是如何快速维护这个数量。

注意到 $\max - \min \geq r - l$，因此，用线段树维护区间最值的数量即可。

# Code

```cpp
#include <bits/stdc++.h>
#define re register
#define int long long

using namespace std;

const int N = 5e4 + 10;
int n,ans;
int arr[N];
int tp1,tp2,st1[N],st2[N];

inline int read(){
    int r = 0,w = 1;
    char c = getchar();
    while (c < '0' || c > '9'){
        if (c == '-') w = -1;
        c = getchar();
    }
    while (c >= '0' && c <= '9'){
        r = (r << 3) + (r << 1) + (c ^ 48);
        c = getchar();
    }
    return r * w;
}

struct seg{
    #define ls(u) (u << 1)
    #define rs(u) (u << 1 | 1)

    struct node{
        int l,r;
        int Min,cnt;
        int tag;
    }tr[N << 2];

    inline void calc(int u,int k){
        tr[u].Min += k; tr[u].tag += k;
    }

    inline void pushup(int u){
        tr[u].Min = min(tr[ls(u)].Min,tr[rs(u)].Min);
        int tmp = 0;
        if (tr[u].Min == tr[ls(u)].Min) tmp += tr[ls(u)].cnt;
        if (tr[u].Min == tr[rs(u)].Min) tmp += tr[rs(u)].cnt;
        tr[u].cnt = tmp;
    }

    inline void pushdown(int u){
        if (tr[u].tag){
            calc(ls(u),tr[u].tag); calc(rs(u),tr[u].tag);
            tr[u].tag = 0;
        }
    }

    inline void build(int u,int l,int r){
        tr[u] = {l,r};
        if (l == r){
            tr[u].Min = l; tr[u].cnt = 1;
            return;
        }
        int mid = l + r >> 1;
        build(ls(u),l,mid); build(rs(u),mid + 1,r);
        pushup(u);
    }

    inline void modify(int u,int l,int r,int k){
        if (l <= tr[u].l && tr[u].r <= r) return calc(u,k);
        pushdown(u);
        int mid = tr[u].l + tr[u].r >> 1;
        if (l <= mid) modify(ls(u),l,r,k);
        if (r > mid) modify(rs(u),l,r,k);
        pushup(u);
    }

    inline int query(int u,int l,int r){
        if (l <= tr[u].l && tr[u].r <= r){
            if (tr[u].Min == tr[1].Min) return tr[u].cnt;
            else return 0;
        }
        pushdown(u);
        int mid = tr[u].l + tr[u].r >> 1;
        if (l <= mid && r > mid) return query(ls(u),l,r) + query(rs(u),l,r);
        else if (l <= mid) return query(ls(u),l,r);
        else return query(rs(u),l,r);
    }

    #undef ls
    #undef rs
}T;

signed main(){
    n = read(); T.build(1,1,n);
    for (re int i = 1;i <= n;i++) arr[i] = read();
    for (re int i = 1;i <= n;i++){
        while (tp1 && arr[st1[tp1]] > arr[i]){
            T.modify(1,st1[tp1 - 1] + 1,st1[tp1],arr[st1[tp1]] - arr[i]);
            tp1--;
        }
        while (tp2 && arr[st2[tp2]] < arr[i]){
            T.modify(1,st2[tp2 - 1] + 1,st2[tp2],arr[i] - arr[st2[tp2]]);
            tp2--;
        }
        st1[++tp1] = st2[++tp2] = i;
        ans += T.query(1,1,n);
    }
    printf("%lld",ans);
    return 0;
}
```

---

## 作者：Unnamed114514 (赞：2)

问题等价于 $\max-\min=r-l$。

考虑扫描线维护。

定 $r$。

定义 $t=\max-\min+l-r$。

初始 $t$ 全部都是 $0$。

显然 $t=0$ 时才会对答案造成贡献。

注意到序列是排列，原序列中的数互不相同，故 $t\ge0$。

那么就转化成了最小值计数问题，用线段树维护即可。

还剩下一个问题：怎么维护 $t$。

考虑 $r\gets r+1$ 会带来什么影响。

首先 $[1,r-1]$ 的 $t$ 因为 $r+1$ 都会 $-1$。

然后看这个 $\max$ 和 $\min$。

首先如果 $\max,\min$ 不是 $P_r$，就没影响。

否则以最小值为例，令 $pos_r$ 表示 $P_r$ 作为最小值覆盖到的左端点，找到 $POS$ 为 $[pos_r,r-1]$ 最小值对应的位置。

然后更新 $[pos_r,POS]$，再找 $[POS+1,r-1]$，以此类推，直到 $POS=r-1$ 结束。

注意每个值只会加入一次，删除一次，所以总时间复杂度为 $O(n\log n)$。

最大最小随便搞个 ST 表就是了。

扫描线也是 $O(n\log n)$。

综上，时间 $O(n\log n)$，空间 $O(n\log n)$。

```cpp
#include<bits/stdc++.h>
#define ls p<<1
#define rs p<<1|1
using namespace std;
const int N=5e4+5;
int n,a[N],t[N<<2],cnt[N<<2],tag[N<<2],pos_max[N],pos_min[N],st_min[N][20],st_max[N][20],Log[N],ans;
stack<int> s;
inline int mymax(int p,int q){ return a[p]>a[q]?p:q; }
inline int mymin(int p,int q){ return a[p]<a[q]?p:q; }
inline int qmax(int l,int r){
	int k=Log[r-l+1];
	return mymax(st_max[l][k],st_max[r-(1<<k)+1][k]);
}
inline int qmin(int l,int r){
	int k=Log[r-l+1];
	return mymin(st_min[l][k],st_min[r-(1<<k)+1][k]);
}
void build(int p,int l,int r){
	tag[p]=0,t[p]=0,cnt[p]=r-l+1;
	if(l==r) return;
	int mid=l+r>>1;
	build(ls,l,mid),build(rs,mid+1,r);
}
inline void pushup(int p){
	t[p]=min(t[ls],t[rs]);
	cnt[p]=(t[ls]==t[p])*cnt[ls]+(t[rs]==t[p])*cnt[rs];
}
inline void pushdown(int p){
	t[ls]+=tag[p],tag[ls]+=tag[p];
	t[rs]+=tag[p],tag[rs]+=tag[p];
	tag[p]=0;
}
void update(int p,int l,int r,int ql,int qr,int v){
	if(ql<=l&&r<=qr){
		t[p]+=v,tag[p]+=v;
		return;
	}
	pushdown(p);
	int mid=l+r>>1;
	if(ql<=mid) update(ls,l,mid,ql,qr,v);
	if(mid<qr) update(rs,mid+1,r,ql,qr,v);
	pushup(p);
}
int query(int p,int l,int r,int ql,int qr){
	if(ql<=l&&r<=qr) return (t[p]==0)*cnt[p];
	pushdown(p);
	int mid=l+r>>1,res=0;
	if(ql<=mid) res+=query(ls,l,mid,ql,qr);
	if(mid<qr) res+=query(rs,mid+1,r,ql,qr);
	return res;
}
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin>>n;
	for(int i=1,x,y;i<=n;++i) cin>>a[i];
	build(1,1,n);
	for(int i=n;i;--i){
		while(s.size()&&a[s.top()]>a[i]) pos_min[s.top()]=i+1,s.pop();
		s.push(i);
	}
	while(s.size()) pos_min[s.top()]=1,s.pop();
	for(int i=n;i;--i){
		while(s.size()&&a[s.top()]<a[i]) pos_max[s.top()]=i+1,s.pop();
		s.push(i);
	}
	while(s.size()) pos_max[s.top()]=1,s.pop();
	for(int i=1;i<=n;++i) st_max[i][0]=st_min[i][0]=i;
	for(int i=2;i<=n;++i) Log[i]=Log[i>>1]+1;
	for(int j=1;j<=Log[n];++j) for(int i=1;i+(1<<j)-1<=n;++i){
		st_max[i][j]=mymax(st_max[i][j-1],st_max[i+(1<<j-1)][j-1]);
		st_min[i][j]=mymin(st_min[i][j-1],st_min[i+(1<<j-1)][j-1]);
	}
	for(int r=1;r<=n;++r){
		if(r!=1) update(1,1,n,1,r-1,-1);		
		int pos=pos_max[r];
		while(pos<r){
			int p=qmax(pos,r-1);
			update(1,1,n,pos,p,a[r]-a[p]);
			pos=p+1;
		}
		pos=pos_min[r];
		while(pos<r){
			int p=qmin(pos,r-1);
			update(1,1,n,pos,p,a[p]-a[r]);
			pos=p+1;
		}
		ans+=query(1,1,n,1,r);
	}
	cout<<ans<<endl;
	return 0;
} 
```

---

## 作者：toolazy (赞：1)

> 【蓝桥杯 2013 省级 B 组】连号区间数 / 【CF526F】Pudding Monsters / 【CF997E】Good Subsegment
>
> 给你一个 $n$ 阶排列 $P$，计数子区间 $[l,r]$ 的数量，满足 $[l,r]$ 内所有数排列连续。
>
> 比如 $P=\{5,3,4,1,2\}$，$[1,3]$ 是连续的（$\{3,4,5\}$），$[4,5]$ 是连续的（$\{1,2\}$），$[2,5]$ 也是连续的（$\{1,2,3,4\}$）。
>
> 时间复杂度要求 $O(n\lg n)$。

这题正解是析合树，但我们不学，我们来聊聊其他做法，~~甚至你可以 $O(n^2)$ 卡常碾过去~~

（其实就是给两个主流解法更加细致的说明，其他题解说得还是有点模糊，~~其实就是蹭社贡~~

> 首先我们来想一个 $O(n^2)$ 的暴力。
>
> 我们不妨直接枚举区间，做 $O(1)$ 判断。
>
> 问题来了——怎么判断呢？
>
> 接下来就引出一个性质：$[l,r]$ 连续，势必有 $r-l=\max-\min$，易证。
>
> 接下来就可以考虑 ST 表处理。

---

这个性质很重要。接下来我们可以考虑扫描线：

> 对于这种区间 $\min/\max$ 统计的，可以考虑扫描线上的单调栈搭配线段树。
>
> 具体的，我们从左往右枚举右端点 $r$，然后维护单调栈。
>
> 接下来我们把 $\min/\max$ 的信息糊到线段树上面去。
>
> 具体的，对于当前的 $r$，线段树中的下标 $l$ 记录 $[l,r]$ 的 $\min/\max$ 即可。
>
> 维护这个是简单的：单调栈出栈时直接 overwrite 即可。
>
> 有了这个，我们就可以简单地维护每一个左端点上的 $l+\max-\min$，然后统计 $=r$ 的数量。

那么怎么统计呢？这里我们就又要牵扯到另一个性质了：

> $\textbf{Lemma}: l+\max-\min\ge r$
>
> $\textbf{Proof}: \max-\min\ge r-l,\blacksquare$

所以我们只需要在线段树上额外记一个最小值的出现次数，这是简单的。

---

接下来还有一个 CDQ 的解法，通过递归来烧掉一个线段树，不过还是要单 $\lg$：

> 处理到子区间 $[L,R]$ 时直接中间劈两半，$[L,M]$ 和 $[M+1,R]$ 递归，接下来只要统计跨过 $M$ 的区间即可。
>
> 我们记 $\max[l,r]$ 表示 $[l,r]$ 中的 $\max$，$\min[l,r]$ 同理。
>
> 接下来我们分讨：
>
> - $\max[l,r]$ 在左半（其下标 $\in[L,M]$）。
>
>   从中间向左边，逐步枚举 $l$。$l$ 不动时，$r$ 越大，$\max[l,r]$ 越大（具有单调性）。
>
>   为满足要求，势必会有 $\max[l,M]\ge\max[M+1,r]$。$\max[l,M]$ 是定值，故我们可以确定 $r$ 的界限 $R'$，有 $r$ 必须 $\le R'$。进一步的，$l$ 往左靠，$\max[l,M]$ 增大，$R'$ 只增不减，所以我们可以暴力右移 $R'$ 指针，而这是 $O(n)$ 的。
>
>   确定完这些之后，我们化一下式子：$\max[l,r]+l=\min[l,r]+r$。注意到 $\max[l,r]+l$ 其实就是定值，但是 $\min[l,r]+r$ 比较棘手。
>
>   那我们继续拆分一下：
>
>   - $\min[l,r]$ 在右半（其下标 $\in[M+1,R']$）
>
>     有 $\max[l,r]+l=\min[M+1,r]+r$。变量与 $l$ 无关，提前预处理塞桶里就好。
>
>   - $\min[l,r]$ 在左半（其下标 $\in[L,M]$）
>
>     有 $\max[l,r]-\min[l,r]+l=r$，左边都是常量提前算。
>
>   问题在于区分这两部分处理。实际上 $\min$ 也有类似性质：$M+1$ 不动，$r$ 越靠右，$\min[M+1,r]$ 越小。
>
>   我们可以用一样的方法界定一个 $M+1\le R''\le R'$，使得有 $\Big(\forall r\in[M+1,R'']\Big)\big(\min[l,M]\le\min[M+1,r]\big)$（后者），而 $\Big(\forall r\in[R''+1,R']\Big)\big(\min[l,M]>\min[M+1,r]\big)$（前者）。
>
>   所以是 $O(n)$ 的。
>
> 然后对称性，另一半也处理一下，这题就做完了。

---

## 作者：TTpandaS (赞：1)

析合树板子题。

$$\large\texttt{前置定义}$$

> **连续段**： 对于一个排列 $P$，定义连续段 $(P,[l,r])$ 表示 $[l,r]$ 满足 $\nexists $ $ l \leq x,z  \leq r, y < l  \vee y>r, P_x < P_y < P_z$。

> **本原连续段**： 记排列 $P$ 的所有连续段集合为 $I_P$，定义本原连续段 $M$ 表示连续段 $M$ 满足 $ \forall A \in I_P, M \cap A = \emptyset \vee M \subseteq A \vee A \subseteq M$。

$$\large\texttt{析合树}$$

考虑一个排列 $\{7,6,5,9,1,3,2,4,10,8\}$，建成这样一棵树：

![](https://cdn.luogu.com.cn/upload/image_hosting/h5j7rln1.png)

（图好像画错了，把 $8$ 和 $10$ 的位置换一下）

每个节点代表一个本原连续段。例如，区间 $[5,7]$ 的值域为 $[1,3]$，区间 $[6,8]$ 的值域为 $[2,4]$，这两个值域存在交集 $[2,3]$，故不为本原连续段。如图中所示，我们将 $[1,4]$ 拆成了 $[1],[2,3],[4]$ 三个区间。同样，$[5,7]$ 被拆成了 $[7],[6],[5]$。

现在，我们将每个节点的所有儿子节点按照其值域大小标号，得到的就是儿子排列：

![](https://cdn.luogu.com.cn/upload/image_hosting/aw2lgm9p.png)

（图好像画错了，把 $8$ 和 $10$ 的位置换一下）

由此得到析合树中析点和合点的定义。

> **合点**： 儿子排列为顺序或逆序的点。

> **析点**： 不是合点的点。

在本图中，析点只有 $[1,10]$，其余都是合点。

$$\large\texttt{性质}$$

> **合点**： 一个合点的任意一段按照顺序排列的儿子的值域的并集为连续段。

> **析点**： 一个合点的任意一段长度大于 $1$ 的按照顺序排列的儿子的值域的并集都不为连续段。

证明显然。用王金山的话来讲，用定义证明即可。

$$\large\texttt{运用}$$

在 [连号区间数](https://www.luogu.com.cn/problem/P8600) 这道题中，让我们求值域连续的区间的个数。

运用合点和析点的性质，因此，析点对答案的贡献只有自己，合点对答案的贡献为 $\dfrac{m(m-1)}{2}$，$m$ 为其儿子结点个数。

对于该题，建出析合树问题就解决了。

---


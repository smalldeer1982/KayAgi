# [蓝桥杯 2021 省 B] 双向排序

## 题目描述

给定序列 $\left(a_{1}, a_{2}, \cdots, a_{n}\right)=(1,2, \cdots, n)$，即 $a_{i}=i$ 。

小蓝将对这个序列进行 $m$ 次操作，每次可能是将 $a_{1}, a_{2}, \cdots, a_{q_{i}}$ 降序排列，或者将 $a_{q_{i}}, a_{q_{i}+1}, \cdots, a_{n}$ 升序排列。

请求出操作完成后的序列。

## 说明/提示

**【样例说明】**

原数列为 $(1,2,3)$。

第 1 步后为 $(3,2,1)$。

第 2 步后为 $(3,1,2)$。

第 3 步后为 $(3,1,2)$。与第 2 步操作后相同, 因为前两个数已经是降序了。

**【评测用例规模与约定】**

对于 $30 \%$ 的评测用例, $n, m \leq 1000$;

对于 $60 \%$ 的评测用例, $n, m \leq 5000$;

对于所有评测用例, $1 \leq n, m \leq 10^5,0 \leq p_{i} \leq 1,1 \leq q_{i} \leq n$ 。 

蓝桥杯 2021 第一轮省赛 B 组 I 题。

## 样例 #1

### 输入

```
3 3
0 3
1 2
0 2```

### 输出

```
3 1 2```

# 题解

## 作者：SakurajiamaMai (赞：13)

# **思路**:
根据数据范围，可猜得每次操作只能是 $\log$ 级别的复杂度。

本题有两种解题方法，个人认为用栈的思维度较高，这里用线段树的方法，简单易懂。利用线段树维护每一个需要降序或者升序的区间，然后利用数组从小到大储存每个数的状态。

**这里难点在于如何维护区间内的升降序**，重点说下。我们设升序为状态 $1$，降序为状态 $0$，再设一个中间分界点 point，那么如果此时我们要修改一个区间为升序，如果起点在 point 之后，我们就不需要修改了，降序也是同理。如果当前的升序区间不满足，需要从降序区间里改变，这里注意我们只需要修改较小数的状态即可。

$1$.如果降序操作把一部分升序的数变到了降序区，其实就是把为 $1$ 的数中较小的那几个数变为 $0$ 。

$2$.如果升序操作把一部分降序的数变到了升序区，其实就是把为 $0$ 的数中较小的那几个数变为 $1$。
```cpp
#include<iostream>
#include<cstdio>
#include<vector>
//using namespace std;
const int N=1e5+10;
int n,m,point,op,x;
std::vector<int>a[2];// 用于存储结果的数组，下标0表示sum为0，下标1表示sum为1
struct node
{
    int l,r,sum,lazy;// l表示左端点，r表示右端点，sum表示[l, r]区间内sum的个数，add表示懒惰标记
}tr[N*3];
void pushup(int u)
{
    tr[u].sum=tr[2*u].sum+tr[2*u+1].sum;
}
void pushdown(int u)
{
    if(tr[u].lazy==-1) return;// 如果没有懒惰标记，直接返回
    auto &root=tr[u],&left=tr[2*u],&right=tr[2*u+1];
    left.lazy=root.lazy,left.sum=(left.r-left.l+1)*root.lazy;
    right.lazy=root.lazy,right.sum=(right.r-right.l+1)*root.lazy;
    root.lazy=-1;
}
void build(int u,int l,int r)
{
    if(l==r) tr[u]={l,r,1,-1};
    else{
        tr[u]={l,r,0,-1};
        int mid=l+r>>1;
        build(2*u,l,mid),build(2*u+1,mid+1,r);
        pushup(u);
    }
}
void modify_1(int u,int val)
{
    int num=tr[u].r-tr[u].l+1-tr[u].sum;// 如果没有懒惰标记，直接返回
    if(num<=val){
        tr[u].sum=tr[u].r-tr[u].l+1;
        tr[u].lazy=1;// 更新懒惰标记为1，表示当前区间内的sum全部变为1
        return;
    }
    pushdown(u);
    int l_num=tr[2*u].r-tr[2*u].l+1-tr[2*u].sum;
    if(l_num>=val) modify_1(2*u,val);// 如果左子节点区间内的0个数足够，递归更新左子节点
    else modify_1(2*u,l_num),modify_1(2*u+1,val-l_num);
    pushup(u);
}
void modify_0(int u,int val) //同理
{
    int num=tr[u].sum;
    if(num<=val){
        tr[u].sum=0;
        tr[u].lazy=0;
        return;
    }
    pushdown(u);
    int l_num=tr[2*u].sum;
    if(l_num>=val) modify_0(2*u,val);
    else modify_0(2*u,l_num),modify_0(2*u+1,val-l_num);
    pushup(u);
}
int query(int u,int pos)
{
    if(tr[u].l==tr[u].r) return tr[u].sum;
    pushdown(u);
    int mid=tr[u].l+tr[u].r>>1;
    if(pos<=mid) return query(2*u,pos);// 根据位置递归查询左子树或右子树
    else return query(2*u+1,pos);
}
int main()
{
    scanf("%d%d",&n,&m);
    build(1,1,n);
    point=1;
    while(m--){
        scanf("%d%d",&op,&x);
        if(op==1){
            if(point<=x) continue;
            modify_1(1,point-x);// 将前面的0变为1
            point=x;
        }
        else{
            if(point>x) continue;
            modify_0(1,x-point+1);// 将前面的0变为1
            point=x+1;
        }
    }
    for(int i=1;i<=n;i++){
        if(query(1,i)!=0) a[1].push_back(i); // 根据sum值判断属于哪个分组
        else a[0].push_back(i); 
    }
    for(int i=a[0].size()-1;i>=0;i--) printf("%d ",a[0][i]);
    for(auto i:a[1]) printf("%d ",i);
    return 0;
}
```


---

## 作者：d807063513 (赞：10)

线段树做法，这里主要说明为何能用线段树以及本题线段树维护的是什么东西。

给出数列  $123456789$  进行操作。
对应升序则记为 1，降序记为 0。初始数列升序全为 1。
每次操作对应的讲解，先给出变化然后补充。我们用 pos 记录**连续上升序列**的首位置。

注意！**下面所给升降序状态的下标是原数组的元素**！即  $010$  表示元素 1 处于降序，元素 2 处于升序，元素 3 处于降序。

0 6 原数列变为： $654321789$ 。升降序状态： $000000111$ 。
下标 1—6 变为降序。
pos 从 1 变成 7。数列中共  $7-1=6$  个元素发生变化。

1 3 原数列变为： $651234789$ 。升降序状态： $111100111$ 。
下标 3—9 变为升序，实际只改变降序状态的  $4321$ 。
pos 从 7 变为 3。数列中共  $7-3=4$  个元素发生变化。

0 4 原数列变为： $652134789$ 。升降序状态： $001100111$ 。
下标 1—4 变为降序，实际只改变升序状态的  $12$ 。
pos 从 3 变为 5。数列中共  $5-3=2$  个元素发生变化。

0 3 原数列无变化，因为对应的区间已经处于降序。
pos 无变化。数列中元素也无变化。

0 7 原数列变为： $765432189$ 。升降序状态： $000000011$ 。
下标 1—7 变为降序，实际只改变升序状态的  $347$ 。
pos 从 5 变为 8。数列中共  $8-5=3$  个元素发生变化。

1 5 原数列变为： $765412389$ 。升降序状态： $111000011$ 。
下标 1—3 变为升序，实际只改变降序状态的  $321$ 。
pos 从 8 变为 5。数列中共  $8-5=3$  个元素发生变化。

发现规律了吗？**pos 的偏移与实际改变元素的个数相等，且发生改变时优先改变较小的元素**！
就是说在一次由降序变升序的操作中，若 pos 偏移量为 3，那么将表示升降状态的 01 串从左至右把 3 个 0 变成 1。

相对的在一次由升序变降序的操作中，若 pos 偏移量为 4，那么将表示升降状态的 01 串从左至右把 4 个 1 变成 0。

由此转化为区间修改问题，**优先修改**线段树**左子树**能修改的元素数量，若小于 pos 偏移量再转而修改右子树。
最后再把对应升序和对应降序的元素各自拼接成串，输出。

上面所给数列最终变为  $765412389$ ，与  $4567$  的**倒序**和  $12389$  的**正序**拼接完全相等，单点查询升降状态后存入数组输出即可。

代码注释有对应功能的讲解。（十分钟写的暴力能拿 60 分，正解硬是想了一整天）~~知道蓝桥杯该怎么打了罢？~~

```c
#include<stdio.h>
int n,m,k,p;		//几个变量均用于输入 
int tag[2][100010],cnt_0,cnt_1;//存储答案 

struct Tree{
	int l,r,sum,lazy;//sum表示区间中1的数量 
}tree[400010];

void push(int i){
	tree[i*2].lazy=tree[i].lazy;
	tree[i*2+1].lazy=tree[i].lazy;
	tree[i*2].sum=(tree[i*2].r-tree[i*2].l+1)*tree[i].lazy; 
	tree[i*2+1].sum=(tree[i*2+1].r-tree[i*2+1].l+1)*tree[i].lazy;
	tree[i].lazy=-1;//无lazy则设为-1 
}

void build(int i,int l,int r){
	tree[i].l=l,tree[i].r=r,tree[i].lazy=-1;
	if(l==r){
		tree[i].sum=1;return;
	}
	int mid=(l+r)>>1;
	build(i*2,l,mid);
	build(i*2+1,mid+1,r);
	tree[i].sum=tree[i*2].sum+tree[i*2+1].sum;
}

void up(int i,int val){//将降序改升序 
	int num=tree[i].r-tree[i].l+1-tree[i].sum;//num表示区间里0的数量 
	if(num<=val){//为0的点满足val需求 或 尚未被标记 
		tree[i].lazy=1;tree[i].sum=tree[i].r-tree[i].l+1;return;
	}
	if(tree[i].lazy!=-1)push(i);
	int lsum_0=tree[i*2].r-tree[i*2].l+1-tree[i*2].sum;//左儿子所含0的数量 
	if(lsum_0>=val) 	up(i*2,val);
	else				up(i*2,lsum_0) , up(i*2+1,val-lsum_0);
	tree[i].sum=tree[i*2].sum+tree[i*2+1].sum;
}

void down(int i,int val){//将升序改降序 
	int num=tree[i].sum;//表示区间里1的数量 
	if(num<=val){//若 为1的点满足val需求 或 尚未被标记 
		tree[i].lazy=tree[i].sum=0;return;
	}
	if(tree[i].lazy!=-1)push(i);
	int lsum_1=tree[i*2].sum;//注意不能直接用tree[i*2].sum来传递，该值在下面的else里随着左儿子的传递会变化 
	if(lsum_1>=val) 	down(i*2,val);//左儿子所含1的数量 
	else				down(i*2,lsum_1) , down(i*2+1,val-lsum_1);
	tree[i].sum=tree[i*2].sum+tree[i*2+1].sum;
}

int search(int i,int p){//单点查询 返回被更改的状态 
	if(tree[i].l==tree[i].r)return tree[i].sum;
	if(tree[i].lazy!=-1)push(i);
	if(tree[i*2].r>=p)return search(i*2,p);
	if(tree[i*2+1].l<=p)return search(i*2+1,p);
}

int main(){
	scanf("%d%d",&n,&m);
	int first_1=1;//用于记录第一个升序即1出现的位置 
	build(1,1,n); 
	
	while(m--){
		scanf("%d%d",&k,&p);
		if(k==0 && p>=first_1){
			down(1,p-first_1+1);//升序变降序 
			first_1=p+1;
		}
		else if(k==1 && p<first_1){
			up(1,first_1-p);
			first_1=p;
		}
	}
	for(int i=1;i<=n;i++){
		if(search(1,i)==1)tag[1][++cnt_1]=i;
		else		tag[0][++cnt_0]=i;
	}
	for(int i=cnt_0;i;i--) printf("%d ",tag[0][i]);
	for(int i=1;i<=cnt_1;i++)	printf("%d ",tag[1][i]);
	return 0;
}
```

---

## 作者：DengDuck (赞：8)

来看看又好写又好想又好调的 Bitset + 值域分块 做法。只有 800 B!

不难想到这题应该有个分界点 $M$，使得 $[1,M-1]$ 降序，$[M,n]$ 升序，那么我们只需要知道两边各有哪些数字还有分界点的位置就能确定当前的形态。

那么对于操作，如果没碰到分界点我们都不用管。

如果碰到了，我们可以考虑把一边的靠近分界点的一段给到另外一边。

如果我们计算出要给 $k$ 个数字，那么显然就是将最小的 $k$ 个数字给过去（因为两边都是越靠近分界点越小）。

考虑用 Bitset 维护值域分块，如果一整个块都要给过去就用位运算整个拷过去，如果只需要给一部分就一位一位查询。

然后我们直接查询即可，时间复杂度应该是 $\mathcal O(\dfrac{n^2}w+n\sqrt n)$ 的，时间也不劣，调了一下块长可以做到 140 ms。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int M=200;
const int N=505;
bitset<M>A[N],B[N];
int n,m,Mid;
inline void To(bitset<M>*B,bitset<M>*A,int t)
{
	for(int j=0;j<N&&t;j++)
	{
		int k=A[j].count();
		if(k<=t)B[j]|=A[j],t-=k,A[j].reset();
		else
		{
			for(int x=0;x<M&&t;x++)
				if(A[j][x])B[j][x]=1,A[j][x]=0,t--;
		}
	}	
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)B[i/M][i%M]=1;
	Mid=1;
	while(m--)
	{
		int o,x;
		scanf("%d%d",&o,&x);
		if(o==1)
		{
			if(x>=Mid)continue;
			int t=Mid-x;
			To(B,A,t),Mid=x;
		}
		else
		{
			if(x<Mid)continue;
			int t=x-Mid+1;
			To(A,B,t),Mid=x+1;
		}
	}
	for(int i=N-1;i>=0;i--)
		for(int j=M-1;j>=0;j--)if(A[i][j])printf("%d ",i*M+j);
	for(int i=0;i<N;i++)
		for(int j=0;j<M;j++)if(B[i][j])printf("%d ",i*M+j);
}
```

---

## 作者：ZH_qaq (赞：5)

## P8747 [蓝桥杯 2021 省 B] 双向排序 的题解
#### [传送门](https://www.luogu.com.cn/problem/P8747)
### 思路
这道题的意思就是有 $n$ 个数，是从 $1$ 到 $n$，和 $m$ 次操作，每次操作输入一个 $p$ 和 $q$，$p$ 是 $0$ 的时候把 $1$ 到 $q$ 降序排，$p$ 是 $1$ 的时候把 $q$ 到 $n$ 升序排。

根据数据范围你会发现，$n$ 和 $m$ 最大可以达到 $10^5$，如果每次操作我们都排序一下的话，时间复杂度是 $O(mn \log n)$，会达到 $10^{11}$ 以上，这样做肯定是不行的。

其实我们会发现，每次排序都会浪费掉很多时间来处理一些不必要的东西，或者说有很多操作是重复的。所以，我们先将 $[1,x]$ 降序排，再将 $[1,y]$ 降序排，其实我们可以直接把 $[1,x]$ 降序排这个操作去掉，这是因为 $[1,x]$ 只是 $[1,y]$ 的一部分。从 $[x,n]$ 升序排也是一样的道理，我们先将 $[x,n]$ 升序排，再将 $[y,n]$ 升序排，其实我们可以直接把 $[x,n]$ 升序排这个操作去掉。

这样子我们可以发现每次降序排和升序排我们只取范围最大的那个，范围比它小或者等于它的操作其实都是不必要的，我们可以统统去掉。因此呢，我们最后真正需要的操作是升序排降序排依次交替的。我们可以发现，如果第一次操作是 $[x,n]$ 升序排，那么我们也可以忽略掉，因为刚开始的时候我们的数据本来就是升序的，我们把部分升序排之后也是不会引起任何变化的。所以第一次操作必定是 $[0,x]$ 降序排。

这样的话我们就可以找规律啦，例如：`1 2 3 4 5 6 7 8 9`

1. 第一次我们将 $[1,3]$ 降序排，变成：`3 2 1 4 5 6 7 8 9`

2. 第二次我们将 $[7,9]$ 升序排，还是：`3 2 1 4 5 6 7 8 9`

3. 第三次我们将 $[1,6]$ 降序排，变成：`6 5 4 3 2 1 7 8 9`

4. 第四次我们将 $[4,9]$ 升序排，变成：`6 5 4 1 2 3 7 8 9`

5. 第五次我们将 $[1,5]$ 降序排，变成：`6 5 4 2 1 3 7 8 9`

相信你们发现了一个规律，就是排序的时候，我们会有一些数字被固定，这里我来证明一下。刚开始我们在 $[1,n]$ 的时候，我们将 $[1,x]$ 降序排列，由于最初我们的数据都是升序的，所以 $\forall b \in [x+1,n]> \forall a\in[0,x]$。那么之后我们对 $[y,n]$ 升序排列的话其实 $[x,n]$ 这部分是不变的，注意看上面的 $3$ 和 $4$，这是因为 $[y,x]\in[0,x]<[x+1,n]$，所以 $[x+1,n]$ 这部分的任意值是始终大于 $[y,x]$ 中的任意值。因此我们对 $[y,n]$ 升序排序的话，其实 $[x,n]$ 这部分不会挪动位置。换句话说，$[x,n]$ 已经被固定下来了。

我们观察一下上面的 $1$ 和 $2$，它们没有任何交集，所以不会固定任何点，不过到了 $3$ 和 $4$ 的时候，他们就有交集了。并且发现，$1$ 和 $2$ 这两次操作其实也是没有必要的，这是因为 $[1,6]$ 中的 $6$ 是大于 $[1,3]$ 中的 $3$ 的，还是上面的道理，这是因为 $[1,x]$ 只是 $[1,y]$ 的一部分。

那么还有一个地方，就是为啥接下来的 $[z,n]$ 升序排也可以去掉？ 我们可以这样想，后半段本身里面有一部分是升序排的，如果我们 $z$ 在升序排那一部分后面，那这个操作本身就没有意义，比如：`3 2 1 4 5 6 7 8 9`；$[3,9]$ 本身已经升序了，我们让 $[4,9]$ 再升序排，也没有意义。那如果我们在 $3$ 的前面升序排，比如 $[2,9]$，就会变成 `3 1 2 4 5 6 7 8 9`，之后我们对一个大于等于 $3$ 的降序排，例如 $[1,6]$ 就会变成 `6 5 4 3 2 1 7 8 9`，你会发现我们直接对 `3 1 2 4 5 6 7 8 9` 的 $[1,6]$ 降序排结果也是这样。

### 代码
```cpp
#include <bits/stdc++.h>
#define endl "\n"
using namespace std;
typedef long long ll;
typedef pair<int, int> PII;
int n, m, ans[100005];
PII stk[100005];
int main() {
	//freopen(".in","r",stdin);
    //freopen(".out","w",stdout);
	ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
	cin >> n >> m;
    int top = 0;
    while(m --) {
        int p, q;
        cin >> p >> q;
        if (!p) {
            while(top && stk[top].first == 0) q = max(q, stk[top --].second);
            while(top >= 2 && stk[top - 1].second <= q) top -= 2;
            stk[++ top] = {0, q};
        }
        else if (top) {
            while (top && stk[top].first == 1) q = min(q, stk[top -- ].second);
            while (top >= 2 && stk[top - 1].second >= q) top -= 2;
            stk[++ top] = {1, q};
        }
    }
    int k = n, l = 1, r = n;
    for (int i = 1; i <= top; i ++) {
        if (stk[i].first == 0) 
            while (r > stk[i].second && l <= r) ans[r --] = k --;
        else 
            while (l < stk[i].second && l <= r) ans[l ++] = k --;
        if (l > r) break;
    }
    if (top % 2) 
        while (l <= r) ans[l ++] = k --;
    else 
        while (l <= r) ans[r --] = k --;
    for (int i = 1; i <= n; i ++)
        cout << ans[i] << " ";
    return 0;
}
```

---

## 作者：Wf_yjqd (赞：5)

非常好线性做法。

---

显然可以分成左边降序，右边升序两部分。

考虑维护左部分的值，则右部分的值只需要将剩余的从小到大排列即可。

左部分的大小很好维护，每次变化的大小即为 $q_i$ 与左部分右端点之间的距离。

$p_i$ 决定了是加元素还是删元素。显然加元素一定是右部分中最小的若干个，减元素也一定是左部分中最小的若干个。

考虑具体维护左部分中的元素，显然是一些区间组成的。

加元素时，用新增的元素填补原来的区间之间的空隙，并合并相邻的区间。

减元素时，从小到大枚举区间删去。

合并区间也可视为删除后新增一个。那么每个区间只会被删除一次，每次加减元素最多新增一个区间。

复杂度为 $\operatorname{O}(n+m)$。

---


```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e5+26;
int n,m,cnt,p,q,pq,stl[maxn],str[maxn],top;
int main(){
	scanf("%d%d",&n,&m);
	while(m--){
		scanf("%d%d",&p,&q);
		pq=q-cnt-p;
		if(p&&pq<0){
			cnt+=pq;
			while(top&&str[top]+pq<stl[top]){
				pq+=str[top]-stl[top]+1;
				top--;
			}
			stl[top]-=pq;
		}
		else if(!p&&pq>0){
			cnt+=pq;
			str[top+1]=0;
			while(top&&stl[top]-1-str[top+1]<=pq){
				pq-=stl[top]-1-str[top+1];
				top--;
			}
			stl[++top]=1;
			str[top]+=pq;
		}
	}
	for(int i=1;i<=top;i++)
		for(int j=str[i];j>=stl[i];j--)
			printf("%d ",j);
	str[top+1]=0;
	for(int i=top;i;i--)
		for(int j=str[i+1]+1;j<stl[i];j++)
			printf("%d ",j);
	for(int i=str[1]+1;i<=n;i++)
		printf("%d ",i);
	return 0;
}
```

---

## 作者：Milthm (赞：3)

~~大家好，我非常喜欢暴力数据结构，所以说我用珂朵莉树套线段树解决了这个问题。~~

考虑用珂朵莉树维护很多段有序的区间，那么每次对 $[l,r]$ 进行排序，相当于先把 $l,r$ 所在的区间裂开，然后再将中间的所有区间合并成一个有序区间。

观察整个过程，发现如果直接维护区间里的数肯定是维护不了的。但是区间已经有序了，那我们就不需要再维护具体的顺序了，所以我们相当于维护很多集合的分裂和合并，采用线段树就可以解决了。

不同于珂朵莉树板子的是，这题的复杂度是有保障的。因为每次操作都只会进行两次 `split` 操作，所以这部分时间复杂度是 $O(q \log n)$ 的，又因为每次合并操作会使得线段树的节点对应减少，所以均摊还是 $O(n\log n)$ 量级的。所以我们就以单 $\log$ 的做法过掉了这道题目。


```cpp
#include<bits/stdc++.h>
#define lc(x) son[x][0]
#define rc(x) son[x][1]
#define N 100005
using namespace std;
int n,m,a[N*64],son[N*64][2],idx,rt[N];
void update(int &x,int l,int r,int k){
	if(!x)x=++idx;a[x]++;
	if(l==r)return;
	int mid=(l+r)>>1;
	if(k<=mid)update(lc(x),l,mid,k);
	else update(rc(x),mid+1,r,k);
}
int query(int x,int l,int r){
	if(l==r)return l;
	int mid=(l+r)>>1;
	if(lc(x))return query(lc(x),l,mid);
	else return query(rc(x),mid+1,r);
}
int merge(int x,int y){
	if(!x||!y)return x+y;
	lc(x)=merge(lc(x),lc(y));rc(x)=merge(rc(x),rc(y));
	return a[x]+=a[y],x;
}
void split(int &x,int y,int k,int p){
	if(a[y]==k)return;x=++idx;
	a[x]=a[y]-k;a[y]=k;
	if(k<=a[son[y][p]])split(son[x][p],son[y][p],k,p),son[x][!p]=son[y][!p],son[y][!p]=0;
	else split(son[x][!p],son[y][!p],k-a[son[y][p]],p);
}
struct node{
	int l,r;mutable int v;
	friend bool operator<(const node& a,const node &b){
		return a.l<b.l;
	}
};
set<node>s;
auto split(int p){
	auto it=s.lower_bound({p,0,0});
	if(it!=s.end()&&it->l==p)return it;it--;
	int l=it->l,r=it->r,v=it->v;s.erase(it);split(rt[p],rt[l],p-l,v);
	s.insert({l,p-1,v});return s.insert({p,r,v}).first;
}
void solve(int op,int l,int r){
	auto R=split(r+1),L=split(l);L->v=op;
	for(auto i=++L;i!=R;++i)merge(rt[l],rt[i->l]);
	s.erase(L,R);
}
int ask(int x){
	split(x+1);split(x);
	return query(rt[x],1,n);
}
signed main(){
	ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
	cin>>n>>m;s.insert({n+1,n+1,0});
	for(int i=1;i<=n;++i)update(rt[i],1,n,i),s.insert({i,i,0});
	while(m--){
		int op,x;cin>>op>>x;
		if(op==0)solve(1,1,x);
		else solve(0,x,n);
	}
	for(int i=1;i<=n;++i)cout<<ask(i)<<" ";
	return 0;
}
```

---

## 作者：robinyqc (赞：3)

这个题是[这个题](https://judge.yosupo.jp/problem/point_set_range_sort_range_composite)的超超级弱化版，那自然可以用 range sort range composite 的做法做（~~杀鸡用牛刀~~）。

先从本题的加强版讲起，也就是，若只有在线区间排序（不是前后缀排序），在线单点查询，怎么做？会做这个自然本题就会了。前置知识：[odt](https://www.luogu.com.cn/problem/CF896C)（颜色段均摊），[线段树合并](https://www.luogu.com.cn/problem/P4556)，[线段树分裂](https://www.luogu.com.cn/problem/P5494)。

首先有一个较为清新的想法：用 odt 维护值域单调段。也就是说，odt 上的一段区间 $[l, r)$ 表示此时，$a_l, a_{l + 1}, \dots, a_{r - 1}$ 是单调递增/递减的，具体是递增还是递减可以再开一个大小为 $n$ 的数组 $dec$，存储以 $l$ 开头的那个连续段是递增还是递减（如果连续段不以 $l$ 开头，则 $dec_l$ 的值不重要，可以随便赋一个值）。

这样，一个区间排序，在 odt 上的表现就是先分裂两个区间，然后把 $[l, r)$ 包含的区间合并成一个大区间。于是问题就转化成，如何用一个数据结构维护 odt 上一个区间内具体的值，支持分裂与合并。更具体地，由于一个区间内的值是单调的，只需要支持，将数据结构按照第 $k$ 大分裂成两个数据结构，一个维护前 $k$ 大的数，另一个维护剩下的数。

我们发现动态开点线段树正好符合这个功能。线段树的分裂和合并正好可以维护刚才所说的问题。于是问题便解决了！

再来看复杂度，不妨记 $w = \log V$（$V$ 是数列 $a$ 的值域）。一次线段树分裂花费 $\Theta(w)$ 的时间，增加了不超过 $w$ 个节点。一次区间排序，odt 上只耗费两次分裂，因此每次区间排序只增加 $O(w)$ 个节点，对于整个算法流程，就是增加了 $O(qw)$ 个节点。对于线段树合并，其复杂度是均摊的，具体来说，若某次合并花费 $\Theta(x)$ 的时间，那么线段树会减少 $\Theta(x)$ 个节点。因此若整个算法流程中，线段树出现了 $\Theta(m)$ 个节点，则线段树合并的复杂度为 $O(m)$。初始所有线段树共有 $\Theta(nw)$ 个节点，分裂增加 $O(qw)$ 个节点，因此线段树合并部分的总复杂度为 $O[(n+q)w]$。

总的来看，就是 odt 花费 $O(q\log n)$ 的时间，线段树部分花费 $O[(n+q)\log V]$ 的时间。总复杂度为为线性对数，完全可以接受。实际上常数有点大，所以本题跑得比较慢。

***

现在来讲讲加加强版，range sort range composite 怎么做。其实会了上面的思路剩下的不难。

首先还是用动态开点线段树加 odt 维护序列，不过此时动态开点线段树显然要多维护一下这整个区间的元素的乘积，这个是容易做到的。

再开一棵普通线段树 $t$！这棵线段树和之前所说的 $dec$ 数组很像啊。就是，$t_l$ 表示 odt 上以 $l$ 开始的区间的元素的乘积（也就是这个区间对应动态开点线段树维护的乘积）。如果没有以 $l$ 开始的区间，就把 $t_l$ **设置为单位元**。

对于区间查询 $[l, r)$，就先在 odt 上分裂出需要查询的区间（但是不要合并），然后在 $t$ 上查询 $[l, r)$ 的乘积就行了，这么做的正确性显然。

单点修改是容易做到的，这里就不说了。

复杂度的话，由于只是加了个线段树，所以复杂度没有变化，仍然是单 $\log$，很好。

不过需要注意的是，由于维护的元素乘法不一定有交换律，所以动态开点线段树应当拥有一个整体翻转功能，也就是将线段树由升序变为降序，用来应对合并两个单调性不一样的区间的情况。这样才能保证合并的时候元素顺序正确。

加加强版参考代码：

+ https://judge.yosupo.jp/submission/217046

+ 这个链接可以查看仍在维护更新的版本：https://github.com/robinyqc/yosupo-sol/blob/main/solutions/datastructure/point_set_range_sort_range_composite/sol0.cpp

---

## 作者：xxr___ (赞：2)

不用线段树，不用栈，只需要我们喜闻乐见的暴力数据结构 `bitset` 和值域分块。

首先判断最后答案的形态，一定是存在某个点 $x$ 满足 $[1,x]$ 降序，而 $(x+1,n]$ 升序。
- 这里使用反证法来证明这个结论。
- 首先存在前后缀肯定分别是降序升序的，这点毋庸置疑。
- 那么假设存在一个位置 $y$ 和另一个位置 $z$ 满足 $[1,y]$ 降序，同时 $(y,z]$ 升序，同时 $(z,n]$ 升序，那么后两者不可以合并的条件就是 $A_z > A_{z+1}$ 我们只需要证明这样的情况是不存在的即可。
- 对于原序列，均满足 $A_i < A_{i+1}$ 而我们需要找到一个位置 $z$ 满足 $A_z > A_{z+1}$ 肯定需要之前进行过一次操作 `0` 且操作区间满足 $[1,z+1]\in [1,x]$ 也就是需要满足 $x > z$。那么此时我们发现区间 $(y,z]$ 并不满足升序条件，为了让它满足升序条件，我们肯定会进行操作 `1` 并且操作区间 $(y,n]\in [x,n]$ 的，也就是需要满足此时的 $x$ 是满足 $x\le y + 1$。
- 这个情况下的 `1` 操作也会使得区间 $(y,n]$ 升序，自然并不满足 $A_z > A_{z+1}$ 的情况。故假设是不成立的。

得证后该如何实现这个过程呢？

考虑维护一个上述的分界点 $y$ 对于操作，如果操作的区间是分界点已经包含了的，不用管，否则我们需要把某一部分放到分界点的另一部分。

由于我们维护的过程中，无一不是上述情况，此时均满足分界点两侧距离分界点越远值越大，反之值越小，所以我们只需要维护某一部分前 $k$ 小的部分放到另一部分就行了，可以使用值域分块加 `bitset` 优化这个过程。

代码中的 $A$ 指分界点左边的点，降序，代码中 $B$ 指的是分界点右侧的点，升序。

时间复杂度是 $O(\frac {n^2}{w})$ 的，空间是 $\frac{n}{w}$ 的。

代码：
```cpp
#include<iostream>
#include<bitset>
const int N = 1e5 + 5;
const int K = 500;
std::bitset<505> A[220],B[220];
int n,q,cnt = 1;
int main(){
	std::ios::sync_with_stdio(false);
	std::cin.tie(nullptr);
	std::cin >> n >> q;
	for(int i = 1;i <= n; ++i){
		B[i/K][i%K] = 1;
	}
	for(int i = 1;i <= q; ++i){
		int op,x,res = 0;
		std::cin >> op >> x;
		if(op){
			if(cnt <= x) continue;
			res = cnt - x;
			for(int j = 0;j <= 200 && res; ++j){
				if((int)A[j].count() <= res){
					res -= A[j].count();
					B[j] |= A[j];
					A[j].reset();
				}else{
					for(int k = 0;k < K && res; ++k){
						if(A[j][k]){
							A[j][k] = 0;
							B[j][k] = 1;
							-- res;
						}
					}
				}
			}
			cnt = x;
		}else{
			if(cnt - 1 >= x) continue;
			res = x - (cnt - 1);
			for(int j = 0;j <= 200 && res; ++j){
				if((int)B[j].count() <= res){
					A[j] |= B[j];
					res -= B[j].count();
					B[j].reset(); 
				}else{
					for(int k = 0;k < K && res; ++k){
						if(B[j][k]){
							A[j][k] = 1;
							B[j][k] = 0;
							-- res;
						}
					}
				}
			}
			cnt = x + 1;
		}
	}
	for(int i = 200; ~i ; --i){
		for(int j = K - 1; ~j ; --j){
			if(A[i][j]){
				std::cout << i * K + j <<' ';
			}
		}
	}
	for(int i = 0;i <= 200; ++i){
		for(int j = 0;j < K; ++j){
			if(B[i][j]){
				std::cout << i * K + j <<' ';
			}
		}
	}
	return 0;
}
```

---

## 作者：I_AM_CIMOTA (赞：1)

经过若干次操作后的序列长啥样？

显然，序列一定能找到一个断点 $pos$，使得断点左侧的元素单调递减，右侧单调递增。

那么，一次前缀降序排序就是把一个前缀的所有元素移到断点的左侧，后缀升序排序就是把一个后缀的所有元素移到断点的右侧。我们把在断点左侧的元素赋一个 $0$ 的权值，在断点右侧的元素赋一个 $1$ 的权值，那么根据一个 $0/1$ 序列就能唯一确定一个经过若干操作的序列。

具体地，就拿降序排序操作举例，如果操作区间不超过断点，那么此操作就是没用的。否则，操作等价于对 $[1..k]$ 权值全赋成 $0$，因为 $[1..k]$ 中原本为 $0$ 的数不受影响，而断点右侧改变的元素一定可以被 $[1..k]$ 包含。于是，我们可以在线段树上维护区间权值和，并二分出这个 $k$，然后做区间赋值。

升序排序可以类似地推出来，此处不再细讲。

二分直接在线段树上进行，所以总时间是 $O(n\log n)$。
```cpp
#include <bits/stdc++.h>
using namespace std;

const int N=1e5+5;
struct SGT{
    int sum0,sum1,tag;
}t[N<<2];
int n,m,pos,colpos,tp1,tp2,lef[N],rig[N];

void upd(int u,int l,int r,int v){
    if(v==0)t[u].sum1=0,t[u].tag=0;
    else t[u].sum1=r-l+1,t[u].tag=1;
    t[u].sum0=r-l+1-t[u].sum1;
}

void up(int u){
    t[u].sum0=t[u<<1].sum0+t[u<<1|1].sum0;
    t[u].sum1=t[u<<1].sum1+t[u<<1|1].sum1;
}

void down(int u,int l,int r){
    if(t[u].tag!=-1){
        int mid=(l+r)>>1;
        upd(u<<1,l,mid,t[u].tag),upd(u<<1|1,mid+1,r,t[u].tag);
        t[u].tag=-1;
    }
}

void build(int u,int l,int r){
    t[u].tag=-1;
    if(l==r){t[u].sum0=0,t[u].sum1=1;return;}
    int mid=(l+r)>>1;
    build(u<<1,l,mid),build(u<<1|1,mid+1,r);
    up(u);
}

void mdf(int u,int l,int r,int L,int R,int v){
    if(L<=l&&r<=R){upd(u,l,r,v);return;}
    down(u,l,r);
    int mid=(l+r)>>1;
    if(L<=mid)mdf(u<<1,l,mid,L,R,v);
    if(R>mid)mdf(u<<1|1,mid+1,r,L,R,v);
    up(u);
}

int find0(int u,int l,int r,int k){
    if(l==r)return l;
    down(u,l,r);
    int mid=(l+r)>>1;
    if(t[u<<1|1].sum0>=k)return find0(u<<1|1,mid+1,r,k);
    else return find0(u<<1,l,mid,k-t[u<<1|1].sum0);
}

int find1(int u,int l,int r,int k){
    if(l==r)return l;
    down(u,l,r);
    int mid=(l+r)>>1;
    if(t[u<<1].sum1>=k)return find1(u<<1,l,mid,k);
    else return find1(u<<1|1,mid+1,r,k-t[u<<1].sum1);
}

int qry(int u,int l,int r,int X){
    if(l==r)return t[u].sum1;
    down(u,l,r);
    int mid=(l+r)>>1;
    if(X<=mid)return qry(u<<1,l,mid,X);
    else return qry(u<<1|1,mid+1,r,X);
}

// void debug(int npos){
//     printf("%d -> %d: ",pos,npos);
//     for(int i=1;i<=n;i++){
//         int col=qry(1,1,n,i);
//         if(col==0)lef[++tp1]=i;
//         else rig[++tp2]=i;
//     }
//     for(int i=tp1;i>=1;i--)printf("%d ",lef[i]);
//     for(int i=1;i<=tp2;i++)printf("%d ",rig[i]);
//     puts("");
//     tp1=tp2=0;
// }

int main(){
    scanf("%d%d",&n,&m);
    pos=colpos=1;
    build(1,1,n);
    while(m--){
        int opt,npos;
        bool flag=0;
        scanf("%d%d",&opt,&npos);
        if(opt==0){
            if((colpos==0&&npos>pos)||(colpos==1&&npos>=pos)){
                flag=1;
                int nw=find1(1,1,n,npos-t[1].sum0);
                mdf(1,1,n,1,nw,0);
            }
        }
        else{
            if((colpos==0&&npos<=pos)||(colpos==1&&npos<pos)){
                flag=1;
                int nw=find0(1,1,n,npos);
                mdf(1,1,n,1,nw,1);
            }
        }
        // debug(npos);
        if(flag)pos=npos,colpos=qry(1,1,n,1);
    }
    for(int i=1;i<=n;i++){
        int col=qry(1,1,n,i);
        if(col==0)lef[++tp1]=i;
        else rig[++tp2]=i;
    }
    for(int i=tp1;i>=1;i--)printf("%d ",lef[i]);
    for(int i=1;i<=tp2;i++)printf("%d ",rig[i]);
    return 0;
}
```

---


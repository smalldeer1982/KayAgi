# [蓝桥杯 2023 省 A] 像素放置

## 题目描述

小蓝最近迷上了一款名为《像素放置》的游戏，游戏在一个 $n \times m$ 的网格棋盘上进行，棋盘含有 $n$ 行，每行包含 $m$ 个方格。玩家的任务就是需要对这 $n \times m$ 个方格进行像素填充，填充颜色只有黑色或白色两种。有些方格中会出现一个整数数字 $x(0 \leq x \leq 9)$，这表示当前方格加上周围八个方向上相邻的方格（分别是上方、下方、左方、右方、左上方、右上方、左下方、右下方）共九个方格内有且仅有 $x$ 个方格需要用黑色填充。

玩家需要在满足所有数字约束下对网格进行像素填充，请你帮助小蓝来完成。题目保证所有数据都有解并且解是唯一的。

## 说明/提示

#### 【样例说明】

![image](https://cdn.luogu.com.cn/upload/image_hosting/v8u2zzne.png)

上图左是样例数据对应的棋盘布局，上图右是此局游戏的解。例如第 $3$ 行第 $1$ 列处的方格中有一个数字 $3$，它周围有且仅有 $3$ 个格子被黑色填充，分别是第 $3$ 行第 $2$ 列、第 $4$ 行第 $1$ 列和第 $4$ 行第 $2$ 列的方格。

#### 【评测用例规模与约定】

对于 $50 \%$ 的评测用例，$1 \leq n,m \leq 5$；

对于所有评测用例，$1 \leq n,m \leq 10$。

## 样例 #1

### 输入

```
6 8
_1__5_1_
1_4__42_
3__6__5_
___56___
_688___4
_____6__```

### 输出

```
00011000
00111100
01000010
11111111
01011110
01111110```

# 题解

## 作者：_•́へ•́╬_ (赞：10)

## 题意

搜雷，方案唯一。

## 思路

~~直接记搜即可。~~

把当前搜到的坐标 $(i,j)$ 和其上方的两行加两个格子的状态状压起来。

![图炸了](https://cdn.luogu.com.cn/upload/image_hosting/9llzz6tt.png)

枚举决策 $(i,j)$ 位置填 $0$ 还是 $1$，然后判断是否满足 $(i-1,j-1)$ 处的限制，就是把周围九个格子 `popcount` 加一下。

特别地，对于最后一行和最后一列，还要跑 $(i-1,j),(i,j-1),(i,j)$ 的限制，周围六个或四个格子 `popcount` 加一下。

复杂度 $\mathcal O(n^2\times 4^n)$。

## code

```cpp
#include<stdio.h>
#include<bitset>
#define ppc __builtin_popcount
using namespace std;
inline char nc()
{
	static char buf[99999],*l,*r;
	return l==r&&(r=(l=buf)+fread(buf,1,99999,stdin),l==r)?EOF:*l++;
}
inline void read(int&x)
{
	char c=nc();for(;c<'0'||'9'<c;c=nc());
	for(x=0;'0'<=c&&c<='9';x=(x<<3)+(x<<1)+(c^48),c=nc());
}
int n,m,ans[11][11];bitset<1024>v[10][10][4][1024];char s[11][11];
inline void dfs(int i,int j,int s1,const int&s2,
	const int&s3)
{
	if(j==m)++i,j=0,s1=0;
	if(i==n)
	{
		for(int i=0;i<n;++i,putchar('\n'))
			for(int j=0;j<m;printf("%d",ans[i][j++]));
		exit(0);
	}
	if(v[i][j][s1][s2][s3])return;
	v[i][j][s1][s2][s3]=1;
	ans[i][j]=1;//(i,j)填1
	if(i&&j&&(s[i-1][j-1]^'_'))if(s[i-1][j-1]^'0'^ppc(s1)+
		ppc(s2>>m-j-1&7)+ppc(s3>>m-j-1&7)+1)goto qwq;
	if(i&&j==m-1&&(s[i-1][j]^'_'))if(s[i-1][j]^'0'^(s1&1)+ppc(s2&3)+
		ppc(s3&3)+1)goto qwq;
	if(i==n-1&&j&&(s[i][j-1]^'_'))if(s[i][j-1]^'0'^ppc(s2>>m-j&3)+
		ppc(s3>>m-j-1&7)+1)goto qwq;
	if(i==n-1&&j==m-1&&(s[i][j]^'_'))if(s[i][j]^'0'^(s2>>1&1)+(s3>>1&1)
		+(s3&1)+1)goto qwq;
	dfs(i,j+1,(s1&1)<<1|(s2>>m-j-1&1),(s2&~(1<<m-j-1))|(s3>>m-j-1&1)<<m-j-1,
		(s3&~(1<<m-j-1))|1<<m-j-1);
	qwq:ans[i][j]=0;//(i,j)填0
	if(i&&j&&(s[i-1][j-1]^'_'))if(s[i-1][j-1]^'0'^ppc(s1)+ppc(s2>>m-j-1&7)+
		ppc(s3>>m-j-1&7))goto pwp;
	if(i&&j==m-1&&(s[i-1][j]^'_'))if(s[i-1][j]^'0'^(s1&1)+ppc(s2&3)+ppc(s3&3))
		goto pwp;
	if(i==n-1&&j&&(s[i][j-1]^'_'))if(s[i][j-1]^'0'^ppc(s2>>m-j&3)+
		ppc(s3>>m-j-1&7))goto pwp;
	if(i==n-1&&j==m-1&&(s[i][j]^'_'))if(s[i][j]^'0'^(s2>>1&1)+(s3>>1&1)
		+(s3&1))goto pwp;
	dfs(i,j+1,(s1&1)<<1|(s2>>m-j-1&1),(s2&~(1<<m-j-1))|(s3>>m-j-1&1)<<m-j-1,
		s3&~(1<<m-j-1));
	pwp:;
}
main()
{
	read(n);read(m);
	for(int i=0;i<n;++i)for(int j=0;j<m;++j)
		for(;s[i][j]=nc(),(s[i][j]<'0'||'9'<s[i][j])&&(s[i][j]^'_'););
	dfs(0,0,0,0,0);
}
```



---

## 作者：Imakf (赞：10)

棋盘很小，所以可以想到要状压 dp。我们先考虑本题的可行解版本，即判断是否有解。只要我们记录了中间的 dp 数组，那么我们可以通过一般的方法（下不赘述）还原出整个方案。

最基础地，我们设 $dp_{i,s_1,s_2}$ 表示当前考虑到第 $i$ 行，前两行的状态分别为 $s_1$，$s_2$ 是否可行。然后只要枚举了第三行的状态，已知这三行的状态，我们就可以判断中间这一行的数字是否正好满足了条件。特别地，第一行和最后一行需要特殊判断。如此，复杂度为 $O(n2^{3m})$，无法通过。

借鉴插头 dp 的思路，发现我们一次不必转移一行，而是可以只转移一个。并且我们只需要记录前 $2m+2$ 个位置的值即可判断某个位置的数字是否满足条件。如下图所示。

```
  ######
###X####
####!
```

我们枚举 `!` 处为 0 或 1 进行转移，由于我们记录了前 $2m+2$ 个位置（图中的 `#` 和 `X`），那就可通过判断 `X` 位置上的数字是否正确来判断是否可以转移。特别地，位于最后一列和最后一行的 `X` 要特殊判断。

这样做复杂度优化到 $O(nm2^{2m+3})$，有些悬。不妨使用记忆化搜索实现 dp。好处有二。

1. 可以剪枝降低常数；
2. 方便输出方案。

以下是代码实现：

```cpp
#include <bits/stdc++.h>

using namespace std;

int n, m;
char s[15][15];
int mp[15][15];

const int U = (1 << 22) - 1;
bitset<1 << 22> dp[10][10]; 
namespace FFF {
  bool check(int x, int y) {
    if (s[x][y] == '_') return true;
    int count = s[x][y] - '0';
    for (int dx = -1; dx <= 1; ++dx) {
      for (int dy = -1; dy <= 1; ++dy) {
        int tx = dx + x;
        int ty = dy + y;
        if (tx < 0 || tx >= n || ty < 0 || ty >= m)
          continue;
        count -= mp[tx][ty];
      }
    }
    return count == 0;
  }
  
  void dfs(int x, int y, int v) {
    if (y == m) return dfs(x + 1, 0, v);
    if (x == n) {
      if (check(n - 1, m - 1)) {
        for (int i = 0; i < n; ++i) {
          for (int j = 0; j < m; ++j) {
            printf("%d", mp[i][j]);
          }
          puts("");
        }
        exit(0);
      }
      return ;
    }

    if (dp[x][y].test(v)) return;
    dp[x][y].set(v);

      for (int _v = 0; _v < 2; ++_v){
        mp[x][y] = _v ^ type[x][y];
        int ok = 1;
        if (x >= 1 && y >= 1) {
          ok &= check(x - 1, y - 1);
        }
        if (x >= 1 && y == m - 1) {
          ok &= check(x - 1, y);
        }
        if (x == n - 1 && y >= 1) {
          ok &= check(x, y - 1);
        }
        if (ok) {
          dfs(x, y + 1, ((v << 1) | mp[x][y]) & U);
        }
    }
  }
  int main() {
    dfs(0, 0, 0);
    return 0;
  }
}

int main() {
  scanf("%d%d", &n, &m);
  for (int i = 0; i < n; ++i) {
    scanf("%s", s[i]);
  }
  return FFF::main();
}
```

---


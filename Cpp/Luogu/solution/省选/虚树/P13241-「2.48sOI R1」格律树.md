# 「2.48sOI R1」格律树

## 题目背景

平平仄仄平平仄，仄仄平平仄仄平。

## 题目描述

来自 CodeForces 的 Che960 想学习如何作近体诗。为此，他咨询了来自洛谷的 lizihan250。lizihan250 告诉他，诗句中的每个字都可以根据发音分为“平声”或“仄声”。除首句外，每一联的上句必须以“平声”收尾，下句必须以“仄声”收尾。每一句内应避免“孤平”。本题中，我们认为，若一句诗句中存在连续的三个字依次为“仄声”、“平声”、“仄声”，我们就认为，这句诗句出现了“孤平”。本题不考虑对仗、押韵等其他要求。

Che960 为了练习平仄的运用，构造了一棵以 $1$ 号节点为根的格律树，树上的每个节点都代表“平声”或“仄声”中的一种。Che960 会进行多次练习，每次练习时，Che960 会在树上选出一些“关键点”，并指定了这些“关键点”代表的是“平声”还是“仄声”。Che960 的任务就是给定一种方案，给树上所有非关键节点指定其代表的是“平声”还是“仄声”，使得从根节点到任意一个“关键点”的简单路径上的所有节点依次排列成的诗句不出现“孤平”。

lizihan250 看到了这个练习之后，想到了这样一个问题：对于 Che960 的每次练习，他最多能给出多少种不同的方案？两种方案不同，当且仅当存在至少一个节点，在两种方案中分别被指定为“平声”与“仄声”。答案对 $10^9+7$ 取模。

### 形式化题意

我们用 $0$ 指代上文的“平声”，用 $1$ 指代上文的“仄声”。

给定一棵树，每个节点有 $01$ 点权。进行多次询问，每次询问选择若干个节点，指定它们的点权。求：若剩下的点的点权可以任意指定，则有多少种指定点权的方法，使得任意一个指定点到根节点的路径上，不存在连续的三个节点的点权依次为 $1$，$0$ 和 $1$。

## 说明/提示

### 样例解释

对于样例一，样例中呈现的树的形态如下图所示：

![样例一图](https://cdn.luogu.com.cn/upload/image_hosting/vqvdk2aw.png)

第一次练习选取 $3$ 号节点、$6$ 号节点作为“关键点”，分别指定为“仄声”，“平声”。共 $12$ 种方案，如下表所示（标红的为“关键点”的声调）：

| 方案编号 | $1$ 号节点 | $2$ 号节点 | $3$ 号节点 | $4$ 号节点 | $5$ 号节点 | $6$ 号节点 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| $1$ | 平 | 平 | $\color{red}\text{仄}$ | 平 | 平 | $\color{red}\text{平}$ |
| $2$ | 平 | 平 | $\color{red}\text{仄}$ | 平 | 仄 | $\color{red}\text{平}$ |
| $3$ | 平 | 平 | $\color{red}\text{仄}$ | 仄 | 平 | $\color{red}\text{平}$ |
| $4$ | 平 | 平 | $\color{red}\text{仄}$ | 仄 | 仄 | $\color{red}\text{平}$ |
| $5$ | 平 | 仄 | $\color{red}\text{仄}$ | 平 | 平 | $\color{red}\text{平}$ |
| $6$ | 平 | 仄 | $\color{red}\text{仄}$ | 平 | 仄 | $\color{red}\text{平}$ |
| $7$ | 平 | 仄 | $\color{red}\text{仄}$ | 仄 | 平 | $\color{red}\text{平}$ |
| $8$ | 平 | 仄 | $\color{red}\text{仄}$ | 仄 | 仄 | $\color{red}\text{平}$ |
| $9$ | 仄 | 仄 | $\color{red}\text{仄}$ | 平 | 平 | $\color{red}\text{平}$ |
| $10$ | 仄 | 仄 | $\color{red}\text{仄}$ | 平 | 仄 | $\color{red}\text{平}$ |
| $11$ | 仄 | 仄 | $\color{red}\text{仄}$ | 仄 | 平 | $\color{red}\text{平}$ |
| $12$ | 仄 | 仄 | $\color{red}\text{仄}$ | 仄 | 仄 | $\color{red}\text{平}$ |

所有指定节点 $1$ 为“仄声”，指定节点 $2$ 为“平声”的方案均不符合题意，因为这会使从根节点到节点 $3$ 的简单路径上依次经过的节点 $1$、节点 $2$、节点 $3$ 构成“孤平”。

需要注意的是，本题中，我们不关心不在根节点到“关键点”路径上的点的平仄使用情况是否符合题意。例如，方案 $6$ 的节点 $2$、节点 $4$、节点 $5$ 依次被指定为“仄声”、“平声”、“仄声”，会构成“孤平”，但由于不存在一条从根节点到一“关键点”的简单路径同时包含这三个节点，因此，这个方案也符合题意。

第二次练习只选取节点 $1$ 为“关键点”，指定为“平声”。此时，剩余五个节点的平仄都可以任意指定。故此次练习共有 $2^5 = 32$ 种方案。

第三次练习选取节点 $2$、节点 $4$、节点 $5$ 为“关键点”，分别指定为“仄声”、“平声”、“仄声”。此时，无论如何指定剩余节点的平仄，在根节点到节点 $5$ 的路径上总会依次经过节点 $2$、节点 $4$、节点 $5$ 构成“孤平”。故此次练习不存在任何方案。

对于样例二，除输出参数外与样例一没有任何区别。此时应输出 $\left\lfloor\dfrac{3}{2}\right\rfloor = 1$ 行，这一行应输出第一次与第二次练习的方案数的异或和，故输出 $12 \otimes 32 = 44$。
### 数据规模与约束

**本题采用捆绑测试**

对于 $100\%$ 的数据，有 $1 \le n \le 5 \times 10^5$，$1 \le t,q \le 5 \times 10^5$，$\left\lfloor\dfrac{t}{q}\right\rfloor \le 5 \times 10^4$。对于 $\forall 1 \le i \le t$，有 $1 \le k_i \le n$，且 $\sum\limits_{i=1}^t k_i \le 5 \times 10^5$。对于 $\forall 1\le j \le k_i$，有 $1 \le p_{i,j} \le n$，$s_{i,j} \in \{0,1\}$，同一次练习中所有的 $p_{i,j}$ 互不相同。保证给出的是一棵树。

| Subtask 编号 | 分值 | $t$ | $n$ | $\sum k$ |特殊性质 |
| :----------: | :--: | :-: | :-: | :-: |:------: |
| $0$ | $8$ | $\le 20$ | $\le 20$ | $\le 200$ | 不符合 |
| $1$ | $16$ | $\le 200$ | $\le 10^5$ | $\le 200$ | 符合 |
| $2$ | $16$ | $\le 10^5$ | $\le 5 \times 10^5$ | $\le 10^5$ | 符合 |
| $3$ | $8$ | $\le 5 \times 10^5$ | $\le 5 \times 10^5$ | $\le 5 \times 10^5$ | 符合 |
| $4$ | $20$ | $\le 200$ | $\le 10^5$ | $\le 10^5$ | 不符合 |
| $5$ | $24$ | $\le 10^5$ | $\le 5 \times 10^5$ | $\le 10^5$ | 不符合 |
| $6$ | $8$ | $\le 5 \times 10^5$ | $\le 5 \times 10^5$ | $\le 5 \times 10^5$ | 不符合 |

对于符合特殊性质的测试点，保证 $\forall 1 \le i \le t$，有 $k_i = 1$。

## 样例 #1

### 输入

```
6
1 2
2 3
2 4
4 5
1 6
3 1
2
3 1
6 0
1
1 0
3
2 1
4 0
5 1```

### 输出

```
12
32
0```

## 样例 #2

### 输入

```
6
1 2
2 3
2 4
4 5
1 6
3 2
2
3 1
6 0
1
1 0
3
2 1
4 0
5 1```

### 输出

```
44```

## 样例 #3

### 输入

```
7
1 2
1 3
3 4
4 5
5 6
5 7
4 1
1
4 0
1
4 1
1
6 0
1
6 1```

### 输出

```
64
48
48
36```

# 题解

## 作者：wangyizhi (赞：8)

虚树 + dp。

## 题目分析

先考虑特殊性质，有一条长为 $d$ 的链不能出现 $101$，其它节点乱填。这时应该怎么办呢？

显然可以预处理一个状压 dp，$f_{i,st}$ 表示此时长为 $i$，第 $i-1$ 个为 $st$ 的第一位，第 $i$ 个为 $st$ 的第二位。初始状态 $f_{0,0}=1$。转移只需枚举下一位为 $x$，当 $2st+x=5$ 时禁止转移，否则加上去。

再考虑原问题。注意到 $k$ 的总和是保证的，而且答案与非关键点几乎无关，因此考虑建出虚树，在虚树上 dp。记 $dp_{u,st}$ 表示 $u$ 为 $st$ 第一位，$u$ 的 **父亲** 为 $st$ 第二位的方案数。用父亲是因为只有父亲是唯一的，孩子可能有很多个。转移也比较显然，就是枚举虚树上的叶子节点 $v$ 与状态 $st'$，则根据加法原理和乘法原理，我们先统计此子树内到 $u$ 状态 $st$ 的方案数之和，再乘到 $dp_{u,st}$ 上。但还有一个转移系数没有考虑。不妨改一下上面的状压 dp，$f_{s,i,st}$ 表示此时长为 $i$，第 $0$ 个为 $s$ 的第一位，第 $1$ 个为 $s$ 的第二位，第 $i-1$ 个为 $st$ 的第一位，第 $i$ 个为 $st$ 的第二位。初始状态 $f_{s,0,s}=1$，转移类似。那么就可以把虚树拆成链用上边的方式求解。若一个节点已经的权值被钦定，那么就要把另一种选法的方案数设为 $0$，否则为 $1$。最终答案为 $dp_{1,s}$ 之和，但注意不能让“$1$ 的父亲”的值为 $1$。别忘了再乘上其它节点任意填的方案数。

于是就做完了。记 $K=\sum k$，时间复杂度 $O(K \log K)$，瓶颈在建虚树。

## AC Code

带快读板子，所以有点长。

```cpp
#include<bits/stdc++.h>
//#include<bits/extc++.h>
//bool Mst;
using namespace std;
namespace wyzfastio
{
//#define usefio
#ifdef usefio
	namespace __getchar{const int bufsize=1<<20;char buf[bufsize<<1],*p1=buf,*p2=buf;inline char getchar(){return (p1==p2&&(p2=(p1=buf)+fread(buf,1,bufsize,stdin),p1==p2))?EOF:(*p1++);}}using __getchar::getchar;
	namespace __putchar{const int bufsize=1<<20;char buf[bufsize<<1],*p=buf;inline void putchar(const char ch){if(p-buf==bufsize) fwrite(buf,1,bufsize,stdout),p=buf;*p++=ch;}inline void flush(){fwrite(buf,1,p-buf,stdout);}}using __putchar::putchar;using __putchar::flush;
#endif
	/*---input---*/
	inline void read(unsigned long long &x){char ch=getchar();unsigned long long res=0;while(ch<'0'||ch>'9')ch=getchar();while(ch>='0'&&ch<='9')res=(res<<3)+(res<<1)+ch-'0',ch=getchar();x=res;}
	inline void read(unsigned int &x){char ch=getchar();unsigned int res=0;while(ch<'0'||ch>'9')ch=getchar();while(ch>='0'&&ch<='9')res=(res<<3)+(res<<1)+ch-'0',ch=getchar();x=res;}
	inline void read(long long &x){char ch=getchar();long long f=1;unsigned long long res=0;while(ch<'0'||ch>'9'){if(ch=='-')f=-f;ch=getchar();}while(ch>='0'&&ch<='9')res=(res<<3)+(res<<1)+ch-'0',ch=getchar();x=res*f;}
	inline void read(int &x){char ch=getchar();int f=1;unsigned res=0;while(ch<'0'||ch>'9'){if(ch=='-')f=-f;;ch=getchar();}while(ch>='0'&&ch<='9')res=(res<<3)+(res<<1)+ch-'0',ch=getchar();x=res*f;}
	inline void read(char &s){s=getchar();while(s==' '||s=='\n'||s=='\r') s=getchar();}
	inline int read(char *s){int i=0;char ch=getchar();while(ch==' '||ch=='\n'||ch=='\r') ch=getchar();while(!(ch==' '||ch=='\n'||ch=='\r'||ch==EOF)) s[++i]=ch,ch=getchar();s[i+1]='\0';return i;}
	inline void read(std::string &s){char ch=getchar();s.clear();while(ch==' '||ch=='\n'||ch=='\r') ch=getchar();while(!(ch==' '||ch=='\n'||ch=='\r'||ch==EOF)) s.push_back(ch),ch=getchar();}
	template<typename _Tp,typename ...Args>inline void read(_Tp &x,Args &...args){read(x),read(args...);}
	/*---output---*/
	inline void write(const unsigned long long x){if(x<10) putchar(x+'0');else write(x/10),putchar(x%10+'0');}
	inline void write(const long long x){unsigned long long t=x;if(x<0)putchar('-'),t=-x;write(t);}
	inline void write(const unsigned int x){if(x<10) putchar(x+'0');else write(x/10),putchar(x%10+'0');}
	inline void write(const int x){unsigned int t=x;if(x<0)putchar('-'),t=-x;write(t);}
	inline void write(const char x){putchar(x);}
	inline void write(const char *s){while(*s!='\0'&&*s!=EOF)putchar(*s),s++;}
	template<typename _Tp,typename ...Args>inline void write(_Tp x,Args ...args){write(x),write(args...);}
}
using namespace wyzfastio;
using ll=long long;
using ld=long double;
//#define int ll
using pii=pair<int,int>;
const int N=2e6+5,mod=1e9+7;
inline ll qpow(ll a,ll b,ll M=mod){ll res=1;while(b){if(b&1)res=1ll*res*a%M;b>>=1,a=1ll*a*a%M;}return res;}
inline ll rd(ll x,ll M=mod){return x>=M?x-M:x;}
inline ll pr(ll x,ll M=mod){return x<0?x+M:x;}
vector<int> g[N],t[N];
int siz[N],son[N],fa[N],dep[N],dfn[N],top[N],dcnt;
void dfs1(int u)
{
	siz[u]=1;
	for(int v:g[u]) if(v!=fa[u])
	{
		fa[v]=u,dep[v]=dep[u]+1,dfs1(v),siz[u]+=siz[v];
		if(!son[u]||siz[son[u]]<siz[v]) son[u]=v;
	}
}
void dfs2(int u,int tp)
{
	dfn[u]=++dcnt;
	top[u]=tp;
	if(!son[u]) return;
	dfs2(son[u],tp);
	for(int v:g[u]) if(v!=fa[u]&&v!=son[u]) dfs2(v,v);
}
int lca(int u,int v)
{
	while(top[u]!=top[v])
	{
		if(dep[top[u]]<dep[top[v]]) swap(u,v);
		u=fa[top[u]];
	}
	if(dep[u]>dep[v]) swap(u,v);
	return u;
}
int n,f[4][N][4],s[N],p[N],dp[N][4],tmp[4];
void dpdfs(int u)
{
	for(int k=0;k<4;k++) dp[u][k]=1;
	if(p[u]) for(int k=0;k<4;k++) if((k>>1)!=s[u]) dp[u][k]=0;
	for(int v:t[u])
	{
		dpdfs(v);
		for(int st=0;st<4;st++)
			for(int sst=0;sst<4;sst++)
			{
				if(p[u]&&(sst>>1)!=s[u]) continue;
				tmp[sst]=(tmp[sst]+1ll*dp[v][st]*f[st][dep[v]-dep[u]][sst])%mod;
			}
		for(int k=0;k<4;k++) dp[u][k]=1ll*dp[u][k]*tmp[k]%mod,tmp[k]=0;
	}
}
int solve(vector<pii> &v)
{
	ll res=n-1,ans=0;
	vector<int> vv;
	vv.push_back(1);
	for(auto e:v) p[e.first]=1,s[e.first]=e.second,vv.push_back(e.first);
	sort(vv.begin(),vv.end(),[&](int x,int y){return dfn[x]<dfn[y];});
	for(int i=1,l=(int)vv.size();i<l;i++) vv.push_back(lca(vv[i-1],vv[i]));
	sort(vv.begin(),vv.end(),[&](int x,int y){return dfn[x]<dfn[y];});
	vv.erase(unique(vv.begin(),vv.end()),vv.end());
	for(int i=1,l=(int)vv.size();i<l;i++) t[lca(vv[i],vv[i-1])].push_back(vv[i]);
	for(int u:vv) for(int v:t[u]) res-=dep[v]-dep[u];
	dpdfs(1);
	for(int k=0;k<4;k++) if(!(k&1)) ans=(ans+dp[1][k])%mod;
	for(int i:vv)
	{
		t[i].clear(),s[i]=0,p[i]=0;
		for(int k=0;k<4;k++) dp[i][k]=0;
	}
	return 1ll*ans*qpow(2,res)%mod;
}
//bool Med;
signed main()
{
//	cerr<<"Memory Size: "<<abs((&Med)-(&Mst))/1024.0/1024<<" MB\n";
//	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
//	freopen("in.in","r",stdin);
//	freopen("out.out","w",stdout);
	read(n);
	for(int i=1,u,v;i<n;i++) read(u,v),g[u].push_back(v),g[v].push_back(u);
	for(int st=0;st<4;st++)
	{
		f[st][0][st]=1;
		for(int i=0;i<n;i++)
			for(int s=0;s<4;s++)
				for(int j=0;j<2;j++) if((s<<1)+j!=5)
				{
					int t=((s<<1)|j)&3;
					f[st][i+1][t]=rd(f[st][i+1][t]+f[st][i][s]);
				}
	}
	dfs1(1),dfs2(1,1);
	int t,q;ll sum=0;
	read(t,q);
	vector<pii> vec;
	for(int i=1;i<=t;i++)
	{
		int k;read(k);vec.clear();
		for(int i=1,x,y;i<=k;i++) read(x,y),vec.push_back({x,y});
		ll ans=solve(vec);sum^=ans;
		if(i%q==0) write(sum,'\n'),sum=0;
	}
#ifdef usefio
	flush();
#endif
	return 0;
}
```

---

## 作者：lizihan250 (赞：5)

出题人题解。接下来我将对每个 Subtask 的解法做出解释。

## 概念说明

本文中，对于“格律树”上的节点，我们为每个节点赋一个在 $0,1$ 间取值的权值：若权值为 $0$，则这个节点代表“平声”，否则该节点代表“仄声”。

本文中，树上一个点的深度为其到根节点的简单路径上的经过的边的个数。按此定义，根节点的深度为 $0$。

## Subtask 0

直接从树根向下搜索，枚举每个点为“平声”还是“仄声”。使用可行性剪枝，可以使总时间复杂度达到 $O(t \times 2^n)$。

## Subtask 1

注意到每次询问只有一个“关键点”。这也就意味着，“孤平”的限制只会在根节点到“关键点”的链上。我们不妨称这条链为“关键链”。

我们先统计出不在这条“关键链”上的点的数量，记为 $x$。显然，这 $x$ 个点的权值可以任意指定。故这部分对答案的贡献为 $2^x$。

再看“关键链”上的点。我们尝试从“关键点”开始，向根节点方向，逐步确定各个点的权值。从第 $3$ 个点开始，会受到“孤平”条件的限制。显然，当前这个点的“孤平”限制仅与前两个点的权值有关。

我们考虑使用递推的方式进行计数（也就是所谓的“计数 DP”）。定义 $f(u,i)$ 为已确定点 $u$ 以前的点的点权，满足以下条件：

- 若点 $u$ 前第 $1$ 个点的权值为 $1$，点 $u$ 的权值为 $0$，则 $i = 0$。这意味着给下一个点赋值时会受到“孤平”的影响。
- 若点 $u$ 前第 $1$ 个点的权值为 $0$，点 $u$ 的权值为 $0$，则 $i = 1$。这意味着给下一个点赋值时不会受到“孤平”的影响。
- 若点 $u$ 的权值为 $1$，则 $i = 2$。

若从 $v$ 转移到 $u$，则各种状态的转移方式如下：

- $f(u,0)$ 可以从 $f(v,2)$ 状态的基础上给 $u$ 赋值为 $0$ 得到，故 $f(u,0) = f(v,2)$。
- $f(u,1)$ 可以从 $f(v,0)$ 或 $f(v,1)$ 状态的基础上给 $u$ 赋值为 $0$ 得到，故 $f(u,1) = f(v,0) + f(v,1)$。
- $f(u,2)$ 可以从 $f(v,1)$ 或 $f(v,2)$ 状态的基础上给 $u$ 赋值为 $1$ 得到，故 $f(u,2) = f(v,1) + f(v,2)$。需要注意，如果在 $f(v,0)$ 状态的基础上给 $u$ 赋值为 $1$，会导致出现“孤平”，因此， $f(u,2)$ 不能从 $f(v,0)$ 转移得到。

对于初始点 $s$ 的状态，若其权值被指定为 $1$，则 $f(s,0) = f(s,1) = 0, f(s,2) =1$。否则，由于下一个点无论赋值为 $1$ 还是 $0$ 都不会产生“孤平”，本质上对应 $i = 1$ 的情况，故  $f(s,0) = f(s,2) = 0, f(s,1) =0$。

最终，“关键链”上点对于答案的贡献为 $f(1,0) + f(1,1) + f(1,2)$。由于“关键链”上点对于答案的贡献与非“关键链”上点对于答案的贡献相互独立，因此最终答案就等于这两部分贡献的乘积。时间复杂度 $O(tn)$。

## Subtask 2 & Subtask 3

考虑分别优化非“关键链”上点对于答案的贡献的计算与“关键链”上点对于答案的贡献。

首先优化非“关键链”上点对于答案的贡献的计算。我们需要知道有多少个点不在“关键链”上。为完成这一点，我们可以先预处理出树上每个点的深度。每次询问中，若关键点的深度为 $dep$，则共有 $n-dep-1$ 个点不在“关键链”上。故非“关键链”上点对于答案的贡献为 $2^{n-dep-1}$。

这个式子当然可以用快速幂计算。但没有必要。我们注意到不在“关键链”上的点一定是一个不超过 $n$ 的自然数，因此，我们可以预处理 $2^p, p\in [0,n] \cup N$，每次询问就可以 $O(1)$ 的计算 $2^{n-dep}$。

（注：其实因为题目保证了每次询问都有至少一个“关键点”，所以预处理到 $2^{n-1}$ 即可。）

接着考虑优化在“关键链”上点对答案的贡献的计算。我们不妨把用一个 $1 \times 3$ 的矩阵来表示各个点的状态，即，将点 $u$ 的状态 $F_u$ 写作 $\begin{bmatrix} f(u,0) & f(u,1) & f(u,2)\end{bmatrix}$。若点 $u$ 的状态是从点 $v$ 转移得到的，我们根据 Subtask 1 中推导出的结论，可以得到，$F_u = \begin{bmatrix} f(u,0) & f(u,1) & f(u,2)\end{bmatrix} = \begin{bmatrix} f(v,2) & f(v,0) + f(v,1) & f(v,1) + f(v,2)\end{bmatrix}$。

我们发现，从整条“关键链”上看，这是一个线性递推式。因此，我们可以使用矩阵乘法来表达它，得到如下式子：

$$$
F_u = F_v \times \begin{bmatrix} 0 & 1 & 0 \\ 0 & 1 & 1 \\ 1 & 0 &1\end{bmatrix}
$$$

又因为我们可以快速的得知“关键点”的深度 $dep$，因此，从深度为 $dep$ 的“关键点”$s$ 转移到深度为 $0$ 的根节点需要经过 $n$ 次递推。由于矩阵乘法具有结合律，我们又可以得到以下式子：

$$$
F_1 = F_s \times \begin{bmatrix} 0 & 1 & 0 \\ 0 & 1 & 1 \\ 1 & 0 &1\end{bmatrix}^{dep}
$$$

其中，若 $s$ 的权值为 $0$，则 $F_s = \begin{bmatrix} 0 & 1 & 0\end{bmatrix}$，否则，$F_s = \begin{bmatrix} 0 & 0 & 1\end{bmatrix}$。后文中，为方便表述，我们及矩阵 $B$ 为转移矩阵，有如下约定：

$$$
B = \begin{bmatrix} 0 & 1 & 0 \\ 0 & 1 & 1 \\ 1 & 0 &1\end{bmatrix}
$$$

$B^{dep}$ 当然可以用矩阵快速幂计算，但没必要，而且矩阵乘法常数太大。注意到 $dep \le n$，我们也可以预处理出 $B^p, p\in [0,n) \cup N$，从而避免每次计算时进行的矩阵快速幂。

综上，我们可以在 $O(n + t)$ 的时间复杂度内完成该子任务。

## Subtask 4

从现在开始，“关键点”的数量不止一个，这也意味着，“孤平”的限制从一条“关键链”变成了一棵“关键树”。

首先考虑非“关键树”上点对答案的贡献。这部分与 Subtask 1 的内容并无较大区别，这里不再赘述。

考虑“关键树”上的点对答案的贡献。我们仍然使用 $F_u = \begin{bmatrix} f(u,0) & f(u,1) & f(u,2)\end{bmatrix}$ 表示点 $u$ 的状态，其中：

- $f(u,0)$ 表示点 $u$ 被赋值为 $0$，且其至少一个儿子节点被赋值为 $1$。这意味着给点 $u$ 的父亲赋值时会受到“孤平”的影响。
- $f(u,1)$ 表示点 $u$ 被赋值为 $0$，且其所有儿子节点被赋值为 $0$。这意味着给点 $u$ 的父亲赋值时不会受到“孤平”的影响。
- $f(u,2)$ 表示点 $u$ 被赋值为 $1$。

考虑 $F_u$ 如何从它的儿子节点们转移过来。转移方程如下：

- $f(u,0)$ 可以从它所有儿子节点 $v$ 的 $f(v,0), f(v,1)$ 以及 $f(v,2)$ 的基础上将 $u$ 赋值为 $0$ 转移而来，不过要除去其所有子节点全部赋值为 $0$ 的情况。故 $f(u,0) = \prod \limits_{\text{v is u's son}} \left[ f(v,0)+f(v,1)+f(v,2) \right] - f(u,1)$。
- $f(u,1)$ 可以从它所有儿子节点 $v$ 的 $f(v,0)$ 以及 $f(v,1)$ 的基础上将 $u$ 赋值为 $0$ 转移而来，故 $f(u,1) = \prod \limits_{\text{v is u's son}} \left[ f(v,0)+f(v,1) \right]$。
- $f(u,2)$ 可以从它所有儿子节点 $v$ 的 $f(v,1)$ 以及 $f(v,2)$ 的基础上将 $u$ 赋值为 $1$ 转移而来，故 $f(u,2) = \prod \limits_{\text{v is u's son}} \left[ f(v,1)+f(v,2) \right]$。

然而，需要注意的是，非叶子节点可能也会有平仄限制。若 $u$ 被赋值为 $0$，则 $f(u,2)$ 需要被强制设为 $0$；若 $u$ 被赋值为 $1$，则 $f(u,0)$ 以及 $f(u,1)$ 需要被强制设为 $0$。

对于叶子结点的初始化，与 Subtask 1,2,3 无异。

最终，“关键树”上的点答案的贡献是 $f(1,0) + f(1,1) + f(1,2)$。将“关键树”上的点对答案的贡献与非“关键树”上的点对答案的贡献相乘，即可得到最终答案。时间复杂度 $O(tn)$。

## Subtask 5 & Subtask 6

还是考虑分别优化非“关键树”上点对于答案的贡献的计算与“关键链”上点对于答案的贡献。

首先优化非“关键树”上点对于答案的贡献的计算。我们需要知道有多少个点不在“关键树”上。由于总共点的数目是已知的，因此，我们只要算出在“关键树”上的点的数量即可。

如何统计在“关键树”上点的数量？我们注意到，“关键点”的数量是很有限的。然而，夹杂在“关键点”之间的节点很多。因此，我们浓缩信息，建一棵包含所有“关键点”的虚树。对于除了根节点以外的点，它到它父亲节点的边上（包含它自己，不包含它的父亲）实际的节点数等于它的深度减去它父亲的深度。对虚树上所有的点统计出它到它父亲节点的边上实际的节点数，求和，再加上 $1$，就求出了“关键树”上点的数量。

接着考虑优化在“关键树”上点对答案的贡献的计算。仍然在虚树上考虑。我们考虑如何将一个节点的信息传给它的父亲。假设节点 $v$ 是节点 $u$ 在虚树上的父亲，它们的深度分别为 $dep_v,dep_u$。节点 $v$ 的状态为 $F_v$。

先前的式子讨论的是实树上一个点的状态与子节点的状态的关系。因此，我们要先通过 $F_v$ 求出实树上既是 $v$ 的祖先，又是 $u$ 的儿子的节点 $w$ 的状态 $F_w$。我们发现，从 $v$ 到 $w$ 是一条链，$w$ 与 $v$ 的深度差为 $dep_v-dep_u-1$。因此，套用 Subtask 2,3 的结论，$F_w = F_v \times B^{dep_v-dep_u-1}$。接着，根据 Subtask 4 的结论，我们令 $f(u,0) \gets f(u,0) \times \left[ f(v,0) + f(v,1) + f(v,2) \right], f(u,1) \gets f(u,1) \times \left[ f(v,0) + f(v,1) \right], f(u,2) \gets f(u,2) \times \left[ f(v,1) + f(v,2) \right]$。当然了，把节点 $u$ 的所有儿子都处理完以后，不要忘记 $f(u,0) \gets f(u,0) - f(u,1)$ 。

预处理复杂度 $O(n)$，建虚树复杂度 $O( \sum k \log n)$，计算非“关键树”上点对于答案的贡献复杂度 $O( \sum k)$，计算“关键树”上点对于答案的贡献复杂度 $O( \sum k)$，故总时间复杂度为 $O(n + \sum k \log n)$。

---

## 作者：CJZJC (赞：1)

喜报：离 AC 差一个 `+mod`。

好我们回到题目。首先这题是给出了一棵树和多组询问，每组询问给出了一些**关键点**和**关键点**的**颜色**，**颜色**只有两种 0 或 1。其他的点可以**任意染色**，求使得**每个关键点**（注意不是所有节点）到根路径上的颜色序列不出现 `101` 这种情况的方案数。

我们先考虑没有询问怎么做。设计状态 $dp_{i,0/1/2}$ 表示以 $i$ 号节点为根的子树内颜色序列以 `0`、`1`、`10` 结尾的方案总数。其中 $dp_{i,2}$ 这个状态需要**注意**一下，就是我的节点 $i$ 可能会有多个子节点，如果它的**任意**一个子节点到根的路径**出现了** `10` 结尾，就需要把它统计进 $dp_{i,2}$ 里去。

考虑怎么转移。先看 $dp_{i,0}$。因为我把 `0` 填到序列最后，是**肯定不会**产生非法情况的。所以它可以从前面的任意状态继承过来。于是 $dp_{i,0}= \prod_{j\in son_i} (dp_{j,0}+dp_{j,1})$。

接着看 $dp_{i,1}$。如果我把 `1` 填到序列最后，就**有可能会**产生非法情况了。所以要把这种情况减去，相当于就是减去儿子节点以 `10` 结尾的情况，所以 $dp_{i,1}=\prod_{j\in son_i} (dp_{j,0}+dp_{j,1}-dp_{j,2})$。

最后来看 $dp_{i,2}$。可以发现因为刚才讲的 $dp_{i,2}$ 的统计对象，那么相当于 $dp_{i,0}$ 减去所有**不含** `10` 的情况，那么 $dp_{i,2}=dp_{i,0}-\prod_{j\in son_i} dp_{j,0}$。

现在对于每个节点 $i$，如果它的颜色是 `0` 就转移 $dp_{i,0}$ 和 $dp_{i,2}$，如果它的颜色是 `1` 就转移 $dp_{i,1}$，否则如果它没有颜色，就两个都转移。

最后整颗树的答案就是 $dp_{1,0}+dp_{1,1}$。

好，现在我们已经知道了没有询问怎么做，现在考虑有多组询问该怎么做。

首先可以看见题目中询问的总点数是 $O(n)$ 级别的，这引导我们往**虚树**上想，不会建虚树的可以上网搜一下，这题不卡常，二次排序可以过。

现在假设我们已经把虚树给建出来了，那么我们的转移可以和之前一样的做法，但是这时候会出现一个问题：我们从虚树上的一个点跳到他的父节点时会经过很多其他的点，要转移多次。但是这些点没有其他的儿子，因此转移是相同的，这引导我们往**矩阵乘法**上去想。

那么因为我们刚才提及了 3 种状态转移，是不是就要设计 3 种矩阵呢？其实并不需要，因为我们经过的这些节点肯定都是**没有颜色**的点，因此只要设计一种矩阵就行。

假设现在我们知道 $dp_{x,0/1/2}$，要往 $x$ 的父亲 $fa$ 转移，那么可以按照上面的文字设计出以下的矩阵转移：

$$

\begin{bmatrix}
dp_{x,0} & dp_{x,1} & dp_{x,2} \\
\end{bmatrix}

\times

\begin{bmatrix}
1 & 1 & 0 \\
1 & 1 & 1 \\
0 & -1 & 0
\end{bmatrix}

=

\begin{bmatrix}
dp_{fa,0} & dp_{fa,1} & dp_{fa,2} \\
\end{bmatrix}

$$

然后我们对于 $i=1,2,\dots,n$ 预处理出 $\begin{bmatrix}1 & 1 & 0 \\1 & 1 & 1 \\0 & -1 & 0\end{bmatrix}^i$。

那么每次处理出 $dp_{x,0/1/2}$ 后把它乘上一个 $\begin{bmatrix}1 & 1 & 0 \\1 & 1 & 1 \\0 & -1 & 0\end{bmatrix}^{depth_x-depth_fa-1}$ 就可以正常转移了。

最后的答案为 $(dp_{1,0}+dp_{1,1})\times 2^{不在关键点到根路径上的节点个数}$。

给出代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define N 1000010
const int mod=1e9+7;
int n,q,k,dep[N],dfn[N],idx,f[N][21],rt,col[N],m,sum[N][21],ans[N],bas2[N],tpp;
vector<int>to[N],v;
vector<int>too[N];
struct matrix{
	int a[3][3]={};
	friend matrix operator+(matrix a,matrix b){
		matrix c;
		for(int i=0;i<3;i++){
			for(int j=0;j<3;j++){
                c.a[i][j]=(a.a[i][j]+b.a[i][j])%mod;
			}
		}
		return c;
	}
	friend matrix operator*(matrix a,matrix b){
		matrix c;
		for(int i=0;i<3;i++){
			for(int j=0;j<3;j++){
				for(int k=0;k<3;k++){
					c.a[i][j]=(c.a[i][j]+a.a[i][k]*b.a[k][j]%mod+mod)%mod;
				}
			}
		}
		return c;
	}
    void print(){
        for(int i=0;i<3;i++){
            for(int j=0;j<3;j++){
                cout<<a[i][j]<<" ";
            }
            cout<<'\n';
        }
    }
}dp[N],bas[N],base[3];
void ini(){
    bas[1].a[0][0]=1;
    bas[1].a[0][1]=1;
    bas[1].a[1][0]=1;
    bas[1].a[1][1]=1;
    bas[1].a[1][2]=1;
    bas[1].a[2][1]=-1;
    // bas[1].a[2][0]=1;
    
    base[2]=bas[1];

    base[0].a[0][0]=1;
    base[0].a[1][0]=1;
    base[0].a[1][2]=1;
    
    base[1].a[0][1]=1;
    base[1].a[1][1]=1;
    base[1].a[2][1]=-1;
}
bool comp(int x,int y){
    return dfn[x]<dfn[y];
}
void clr(){
    for(auto x:v){
        too[x].clear();
        col[x]=2;
    }
}
void init(int x,int fa){
    dfn[x]=++idx;
    dep[x]=dep[fa]+1;
    f[x][0]=fa;
    for(int i=1;i<=20;i++){
        f[x][i]=f[f[x][i-1]][i-1];
    }
    for(auto y:to[x]){
        if(y==fa){
            continue;
        }
        init(y,x);
    }
}
int lca(int x,int y){
    if(x==y){
        return x;
    }
    if(dep[x]<dep[y]){
        swap(x,y);
    }
    for(int i=19;i>=0;i--){
        if(dep[f[x][i]]>=dep[y]){
            x=f[x][i];
        }
    }
    if(x==y){
        return x;
    }
    for(int i=19;i>=0;i--){
        if(f[x][i]!=f[y][i]){
            x=f[x][i];
            y=f[y][i];
        }
    }
    return f[x][0];
}
int build(){
    sort(v.begin(),v.end(),comp);
    vector<int>vv;
    vv=v;
    for(int i=0;i<v.size()-1;i++){
        vv.push_back(lca(v[i],v[i+1]));
    }
    sort(vv.begin(),vv.end(),comp);
    v.clear();
    v.push_back(vv[0]);
    for(int i=1;i<vv.size();i++){
        if(vv[i]!=vv[i-1]){
            v.push_back(vv[i]);
        }
    }
    for(int i=0;i<v.size()-1;i++){
        int tmp=lca(v[i],v[i+1]);
        if(tmp!=v[i+1]){
            too[tmp].push_back(v[i+1]);
            too[v[i+1]].push_back(tmp);
        }
    }
    return v[0];
}
void dfs(int x,int fa){
    if(x!=rt){
        tpp+=dep[x]-dep[fa];
    }
    for(int i=0;i<3;i++){
        for(int j=0;j<3;j++){
            dp[x].a[i][j]=0;
        }
    }
    if(too[x].size()+(x==rt)<=1){
        dp[x].a[0][col[x]]=1;
        // cout<<x<<'\n';
        // dp[x].print();
        if(dep[fa]!=dep[x]-1){
            dp[x]=dp[x]*bas[dep[x]-dep[fa]-1];
        }
        // dp[x].print();
        return;
    }
    if(col[x]<2){
        dp[x].a[0][col[x]]=1;
        int tmp=1;
        for(auto y:too[x]){
            if(y==fa){
                continue;
            }
            dfs(y,x);
            matrix f=dp[y]/**base[col[x]]*/;
            tmp=tmp*f.a[0][0]%mod;
            // cout<<x<<" "<<y<<'\n';
            // base[col[x]].print();
            // f.print();
            dp[x].a[0][col[x]]=dp[x].a[0][col[x]]*((f.a[0][0]+f.a[0][1]-col[x]*f.a[0][2]+mod)%mod)%mod;
        }
        if(col[x]==0){
            dp[x].a[0][2]=(dp[x].a[0][0]-tmp+mod)%mod;
        }
    }
    else{
        dp[x].a[0][0]=dp[x].a[0][1]=1;
        int tmp=1;
        for(auto y:too[x]){
            if(y==fa){
                continue;
            }
            dfs(y,x);
            matrix f=dp[y]/**base[col[x]]*/;
            tmp=tmp*f.a[0][0]%mod;
            // cout<<x<<" "<<y<<'\n';
            // base[col[x]].print();
            // f.print();
            dp[x].a[0][0]=dp[x].a[0][0]*(f.a[0][0]+f.a[0][1])%mod;
            dp[x].a[0][1]=dp[x].a[0][1]*((f.a[0][0]+f.a[0][1]-f.a[0][2]+mod)%mod)%mod;
            // dp[x].print();
        }
        dp[x].a[0][2]=(dp[x].a[0][0]-tmp+mod)%mod;
    }
    // cout<<x<<'\n';
    // dp[x].print();
    if(dep[fa]!=dep[x]-1){
        dp[x]=dp[x]*bas[dep[x]-dep[fa]-1];
    }
    // dp[x].print();
}
signed main(){
    ini();
    cin>>n;
    for(int i=1;i<n;i++){
        int u,v;
        cin>>u>>v;
        to[u].push_back(v);
        to[v].push_back(u);
    }
    bas2[0]=1;
    cin>>m>>q;
    init(1,0);
    int maxn=0;
    for(int i=1;i<=n;i++){
        maxn=max(maxn,dep[i]);
        col[i]=2;
        bas2[i]=bas2[i-1]*2%mod;
    }
    for(int i=2;i<=maxn;i++){
        bas[i]=bas[i-1]*bas[1];
    }
    for(int TEST=1;TEST<=m;TEST++){
        tpp=0;
        clr();
        v.clear();
        bool fl=0;
        cin>>k;
        for(int i=1;i<=k;i++){
            int x;
            cin>>x;
            cin>>col[x];
            v.push_back(x);
            if(x==1){
                fl=1;
            }
        }
        rt=build();
        dfs(rt,f[rt][0]);
        if(dep[rt]!=dep[1]){
            dp[rt]=dp[rt]*bas[dep[rt]-dep[1]];
        }
        tpp+=dep[rt];
        ans[TEST]=(dp[rt].a[0][0]+dp[rt].a[0][1])%mod*bas2[n-tpp]%mod;
    }
    int ANS=0;
    for(int i=1;i<=m;i++){
        ANS^=ans[i];
        if(i%q==0){
            cout<<ANS<<'\n';
            ANS=0;
        }
    }
}
```

---

## 作者：xhabc66 (赞：1)

简述一下思考过程
## Step 1
假如关键点不会变动，该如何处理呢？

考虑题目是神秘计数，考虑 dp。

显然只以当前节点为状态是不行的，没法处理“仄平仄”，于是考虑加入“从当前节点开始的‘连续平’的个数”。由于所有 $\ge 2$ 的连续段在转移上都没有区别，故这一维只用计 $0,1,2$ 即可。

但是如果有多个孩子怎么办呢？由于题目中要求的是**所有路径均不出现**，故只要存在一条路径上的孩子只有一个“平”，父亲就应该记为一个“平”。

于是不难得出一个转移：
$$dp_{i,0}=\prod_{v\in child_i}(dp_{v,0}+dp_{v,2})$$
$$dp_{i,1}=\prod_{v\in child_i}(dp_{v,0}+dp_{v,1}+dp_{v,2})-dp_{i,2}$$
$$dp_{i,2}=\prod_{v\in child_i}(dp_{v,1}+dp_{v,2})$$

初始值为 $dp_{i,0}=dp_{i,2}=1,dp_{i,1}=0$。虽然此时“平”只有一个，但“平”后面没有“仄”，即使再加一个“仄”也是合法的，故应该将其按照两个“平”计算答案。

另外，如果 $i$ 点有关键点的限制，那么应该除去部分 $dp$ 值。
- 若 $i$ 点为 $0$，显然 $dp_{i,0}=0$
- 若 $i$ 点为 $1$，显然 $dp_{i,1}=dp_{i,2}=0$

注意，**所有 $i,v$ 均不应该包含不在路径上的点**，不在路径上的点由于可以任意取值，故设其有 $tot$ 个，它们的答案为 $2^{tot}$。

故最终答案为 $(dp_{i,0}+dp_{i,2}+dp_{i,2})2^{tot}$。

由于每次关键点更改都需要重新扫一遍树，故时间复杂度 $O(tn)$，期望得分 $44$。
## Step 2
注意到特殊性质 $k_i=1$，故此时所有路径上的点构成一条链，即可用数列的做法做。其中数列的长度为 $dep_{p_{i,j}}$，$tot=n-dep_{p_{i,j}}$，然后预处理出链的答案（因为链的答案只和长度有关）套上述结论即可。

对于满足性质的点，时间复杂度 $O(n+t)$，与上一步解法数据点分治后期望得分 $68$。
## Step 3
**重头戏来了！**

由上一步可知，链的答案只和长度有关。由此引发出，如果 $dp_{0,0},dp_{0,1},dp_{0,2}$ 的值是固定的，**那么 $dp_n$ 仍然只和长度有关**！并且，$dp_n$ 的每个值都能由包含 $dp_{0,0},dp_{0,1},dp_{0,2}$ 的**一次多项式**表示。

于是考虑用矩阵存储。矩阵显然如下：

$$\begin{bmatrix} dp_{i,0}  \\ dp_{i,1} \\dp_{i,2} \end{bmatrix}=\begin{bmatrix} 1 & 0 & 1 \\ 0 & 1 & 0 \\ 0 & 1 & 1 \end{bmatrix}\begin{bmatrix} dp_{i-1,0}  \\ dp_{i-1,1} \\dp_{i-1,2} \end{bmatrix}$$

同理可得

$$\begin{bmatrix} dp_{i,0}  \\ dp_{i,1} \\dp_{i,2} \end{bmatrix}=\begin{bmatrix} 1 & 0 & 1 \\ 0 & 1 & 0 \\ 0 & 1 & 1 \end{bmatrix}^i\begin{bmatrix} dp_{0,0}  \\ dp_{0,1} \\dp_{0,2} \end{bmatrix}$$

每次将 $dp_0$ 设为链底的 $dp$ 值，在开始时预处理矩阵，即可快速转移树中的一条链。

注意到题目中的 $\sum k_i \le 10^5$，这说明做法可能和 $k$ 有关。考虑 $k$ 个节点构成的路径中，将**树中的链缩成点后**，树的大小不超过 $2k$，此时使用最开始的暴力转移即可通过。该部分时间复杂度 $O(\sum k)$。

但是这个方法还有一个致命的缺陷：**此时仅有叶子是已知的，树上其它部分是未知的！**

将关键点按 dfn 排序，容易发现任何一个新树上的非叶子节点都是两个关键点的 lca。于是只需求出每个排序后 dfn 大小相邻的节点的 lca 即可。

但现在，各个节点之间的父子关系仍然是不可知的。

考虑在一个节点一个节点添加的过程。

在一个新节点被添加时，它与上一个节点的 lca 会有一条边，而如果这个新的 lca 与老的 lca 不重复的话，新 lca 将会把上一个节点和根节点中路径给分割。在这个过程中，**最多只有三个点（算上新节点是四个）的父子关系发生改变**。

可以记录最新节点至根节点的路径上所有的 lca，然后二分出新 lca 位于哪两个 lca 之间，修改这两个 lca 的父亲节点即可。然后用新路径的节点替换老路径。

由于**每个节点只会被加入进最新路径一次，也只会离开一次**，故更新路径的复杂度为 $O(\sum k)$，找 lca 的复杂度为 $O(\sum k\log \sum k)$，故总复杂度 $O(\sum k\log \sum k)$，期望得分 $100$。

### other
看官方题解我建的这个“新树”就是虚树。也就是说，我独立发明了虚树？？？？？？？？？？？？？

---


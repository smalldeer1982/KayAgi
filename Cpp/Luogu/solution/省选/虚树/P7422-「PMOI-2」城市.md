# 「PMOI-2」城市

## 题目描述

P 国有 $N$ 座城市和 $M$ 条无向道路，其中 $1$ 号城市是首都，且任意两座城市都能通过道路互相到达。

现在 P 国要在首都召开 ION。为了建设比赛场地，每个城市都要向首都提供原材料，其中第 $i$ 座城市可以提供类型为 $c_i$ 的原材料。每座城市都会有货车从该城市出发，**沿简单路径**前往首都。如果从城市 $A$ 出发的货车必须经过城市 $B$ ，那么我们称城市 $B$ 在城市 $A$ 到首都的必经之路上。如果对于城市 $A,B,C$，从 $B$ 到 $A$ 的**任意简单路径**与 $C$ 到 $A$ 的**任意简单路径**没有公共边，那么我们称城市 $B$ 和城市 $C$ 关于城市 $A$ 互不影响。

记 $f(A,k)$ 为满足下列所有条件的 $k$ 元集合 $\{B_1,B_2,\cdots B_k\}$ 的个数：

1. 对于任意 $1\leq i \leq k$ 满足 $A\neq B_i$，**城市 $A$ 在城市 $B_i$ 到首都的必经之路上**且城市 $B_i$ 供应的材料与城市 $A$ **不同**。

2. 对于任意 $1\leq i < j \leq k$ 满足 **$B_i$ 与 $B_j$ 关于 $A$ 互不影响**，且 $B_i$ 和 $B_j$ 供应的原材料**相同**。

定义举办 ION 的吸引力为$\sum_{i=1}^N\sum_{k=1}^Kf(i,k)$，其中 $K$ 是给定的常数。

现在，你作为 P 国的首脑，你想要知道这次 ION 的吸引力。

**由于答案可能很大，所以请将答案对 $998244353$ 取模**。

## 说明/提示

【样例解释】

样例中 P 国的地图如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/vte597p4.png)

下表中，第 $i$ 行第 $j$ 列表示 $f(i,j)$。

| $4$ | $0$ | $0$ | $0$ |
| -----------: | -----------: | -----------: | -----------:
| $4$ | $0$ | $0$ | $0$ |
| $2$ | $1$ | $0$ | $0$ |
| $1$ | $0$ | $0$ | $0$ |

所以吸引力为 $4+4+2+1+1=12$。

【数据范围】

**本题采用捆绑测试**。

- Subtask1（10pts）：$N,K \le 8$；
- Subtask2（10pts）：$K=1$；
- Subtask3（15pts）：$K=2$；
- Subtask4（15pts）：保证图的形态为一棵树；
- Subtask5（15pts）：$N \le 2000$；
- Subtask6（15pts）：$N \le 4\times 10^4$；
- Subtask7（20pts）：无特殊限制。

对于 $100\%$ 的数据满足，$1\leq N\leq 5\times 10^5$， $1\leq M \leq \min(10^6,\frac{N\times(N-1)}{2})$，$1 \le K \le 20$，$1 \le c_i \le 10^9$。

**温馨提示**：输入量较大，请使用较快的读入方式。


## 样例 #1

### 输入

```
7 7 2
1 2 3 3 1 1 2
1 2
2 3
2 4
3 4
3 5
3 6
4 7```

### 输出

```
12```

# 题解

## 作者：关怀他人 (赞：8)

### Solution

考虑以首都 $1$ 为根建立一颗广义圆方树，那么不难发现第一个条件 $\lceil$ 城市 $A$ 在城市 $B$ 到首都的必经之路上 $\rfloor$ 当且仅当**在广义圆方树上 $A$ 对应的节点是 $B$ 对应的节点的祖先**。而第二个条件 $\lceil$  $B_i$ 与 $B_j$ 关于 $A$ 互不影响 $\rfloor$ 等价于**广义圆方树中 $B_1,B_2,\cdots B_k$ 在 $A$ 的不同儿子的子树内**。 

将每种材料看做一种颜色，现在我们需要对于每个点求出每种颜色在它的子树中出现的次数，不难想到用**线段树合并**来维护。具体地，将颜色离散化后开一颗以颜色编号为下标的线段树维护每种颜色出现的次数，然后线段树合并即可。

下面考虑如何计算答案，假设当前节点是 $u$ ，现在需要把 $v$ 对应的线段树合并到 $u$ 上。由于 $K$ 很小，考虑维护一个和 $K$ 有关的 dp ，即 $f_c[i]$ **表示在 $u$ 的不同儿子的子树内一共选择 $i$ 个颜色均为 $c$ 的点的方案数**，转移很简单，类似$0/1$背包从大到小枚举$i$，则 $f_c[i]=f_c[i-1]\times cnt_{v,c}$ 其中  $cnt_{v,c}$ 表示 $c$ 这种颜色在 $v$ 的子树中出现的次数，直接在线段树合并的过程中维护 dp 即可，注意当合并到颜色为 $col_u$ 的点是不需要更新 dp 值，因为要求 $A$ 的颜色和 $B$ 不相同。

但是这样做会有一个问题，在计算 $f_c[2]$ 的时候是需要用到 $f_c[1]$ 的值的，而我们显然不能遍历整颗线段树预处理出所有的 $f_c[1]$ ，因为这样就不能保证线段树合并的复杂度了。观察可得，需要更新 $f_c[2]$ 时一定是两个线段树合并到叶子的时候，将 $f_c[1]$ 的转移和其他 $f_c[i](i\geq 2)$的转移分开。考虑打一个 tag 表示**这个叶子节点之前是否被合并过**，在第一次被合并到时令 $f_c[0]=1,f_c[1]=cnt_{u,c}+cnt_{v,c},f_c[2]=cnt_{u,c}*cnt_{v,c}$ （注意这里的 $f_c[1]$ 并没有实际含义，只是为了后面便于计算），然后后面再合并到这个点时直接使用上面的 dp 转移即可。在每次将 $v$ 合并到 $u$ 之前将 $v$ 中所有叶子节点标记为未合并过即可（这个可以通过 lazy tag 实现）。 对于 $f_c[1]$ ，我们并不关心 $f_c[1]$ 具体是多少，我们只需要求得所有 $f_*[1]$ 的和，这个显然等于线段树中所有节点 $cnt$ 之和。

最后在合并到圆方树中的圆点时将 $f$ 数组累加进答案即可。由于一开始所有线段树叶子节点个数总和是 $\mathcal O(n)$，合并两个节点时总结点数就会减 $1$ ，所以在线段树合并时合并到叶子的总次数也是 $\mathcal O(n)$，所以总时间复杂度为 $\mathcal O(n\log n + nK)$。

### Code

```cpp
#include<bits/stdc++.h>
#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>
#include<cstdlib>
#define DEBUG cerr << "Passing Line " << __LINE__<< " in Function [" << __FUNCTION__ << "].\n";
using namespace std;
typedef long long ll;
typedef pair<int,int> pii;
template<class T> inline bool checkMax(T &a,const T &b) {return a < b ? a = b,1 : 0;}
template<typename T, typename...Args> inline void checkMax(T &a,const Args...arg) {checkMax(a,max(arg...));}
template<class T> inline bool checkMin(T &a,const T &b) {return a > b ? a = b,1 : 0;}
template<typename T, typename...Args> inline void checkMin(T &a,const Args...arg) {checkMin(a,min(arg...));}

const int INF = 0x3f3f3f3f;
const ll llINF = 1e18;
const int MAXN = 5e5 + 5;
const int MAXK = 21;
const int MOD = 998244353;

namespace FastIO{
    const int SIZE = 1 << 21;
    char ch;
    char in[SIZE],*inS = in,*inT = in + SIZE;
    char out[SIZE],*outS = out,*outT = out + SIZE;

    #define flush() fwrite(out,1,outS - out,stdout), outS = out
    #define getchar() (inS == inT && (inT = (inS = in) + fread(in,1,SIZE,stdin),inS == inT) ? EOF : *inS++)
    void putchar(char c) {*outS++ = c; if(outS == outT) flush();}

    struct Flusher {~Flusher() {flush();}} flusher;

    template<typename T> inline void read(T &x){
        static int f; x = 0; f = 1; ch = getchar();
        while(!isdigit(ch)) {if(ch == '-') f = -1; ch = getchar();}
        while(isdigit(ch)) {x = (x << 1) + (x << 3) + (ch ^ 48); ch = getchar();} x *= f;
    }

    inline void read(char* s){
        static int len; len = 0; ch = getchar();
        while(ch == '\n' || ch == ' ' || ch == '\0') ch = getchar();
        while(ch != '\n' && ch != ' ' && ch != EOF) s[len++] = ch, ch = getchar(); s[len] = '\0';
    }    

    template<typename T> inline void write(T x){
        if(!x) putchar('0');
        if(x < 0) {x = -x; putchar('-');}
        static int sta[20]; int tot = 0;
        while(x) {sta[tot++] = x % 10; x /= 10;}
        while(tot) putchar(sta[--tot] + 48);
    }

    inline void write(char c) {putchar(c);}
    template<typename T> inline void writeln(T c) {write(c); putchar('\n');}

    template<typename T,typename... Args> inline void read(T &t, Args &...args) {read(t); read(args...);}
}

using FastIO::read;
using FastIO::write;
using FastIO::writeln;

void addmod(int &x,int y) {x += y; if(x >= MOD) x -= MOD;}
void submod(int &x,int y) {x -= y; if(x < 0) x += MOD;}
int add(int x,int y) {x += y; if(x >= MOD) x -= MOD; return x;}
int sub(int x,int y) {x -= y; if(x < 0) x += MOD; return x;}

int n,m,K,ans,cnt,len,sz;
int dfn[MAXN],st[MAXN],low[MAXN],col[MAXN],a[MAXN],dp[MAXN][MAXK],tmp[MAXN];
vector<int> G[MAXN];

void add_edge(int u,int v){
	G[u].push_back(v);
}

struct SegmentTree{
    static constexpr int MAXM = MAXN * 40;
    int tot;
    int ls[MAXM],rs[MAXM],sum[MAXM],tag[MAXM];

    void pushdown(int k){
        if(tag[k] == 0) tag[ls[k]] = tag[rs[k]] = 0, tag[k] = 1;
    }

    void modify(int &k,int l,int r,int x){
        if(!k) k = ++tot; sum[k] += 1; tag[k] = 1;
        if(l == r) return; int mid = (l + r) >> 1;
        if(x <= mid) modify(ls[k],l,mid,x);
        else modify(rs[k],mid + 1,r,x);
    }

    int merge1(int x,int y,int l,int r,int c){
        if(!x || !y) return x | y;
        if(l == r){
            if(l == c) {sum[x] += sum[y]; return x;}
            if(tag[x] == 0){
                dp[l][0] = 1; dp[l][1] = add(sum[x],sum[y]); 
                dp[l][2] = (ll)sum[x] * sum[y] % MOD; tag[x] = 1;
            }else{
                for(int i = K;i >= 1;i--)
                    addmod(dp[l][i],(ll)dp[l][i - 1] * sum[y] % MOD);
            }
            tmp[++sz] = l; sum[x] += sum[y]; return x;
        }
        int mid = (l + r) >> 1; pushdown(x); pushdown(y);
        ls[x] = merge1(ls[x],ls[y],l,mid,c);
        rs[x] = merge1(rs[x],rs[y],mid + 1,r,c);
        sum[x] = sum[ls[x]] + sum[rs[x]]; return x;
    }
    
    int merge2(int x,int y,int l,int r){
        if(!x || !y) return x | y;
        if(l == r) {sum[x] += sum[y]; return x;}
        int mid = (l + r) >> 1;
        ls[x] = merge2(ls[x],ls[y],l,mid);
        rs[x] = merge2(rs[x],rs[y],mid + 1,r);
        sum[x] = sum[ls[x]] + sum[rs[x]]; return x;
    }

    int query(int k,int l,int r,int x){
        if(!k) return 0;
        if(l == r) return sum[k];
        int mid = (l + r) >> 1;
        if(x <= mid) return query(ls[k],l,mid,x);
        else return query(rs[k],mid + 1,r,x);
    }
} sgt;

struct RST{
    static constexpr int MAXM = MAXN << 1;
    int tot; int rt[MAXM];
    vector<int> G[MAXM];

    void add_edge(int u,int v) {G[u].push_back(v); G[v].push_back(u);}

    void dfs(int u,int fa){
		for(int v : G[u]){
            if(v == fa) continue;
            dfs(v,u);
        }
        sz = 0;
		for(int v : G[u]){
            if(v == fa) continue;
            if(u <= n) rt[u] = sgt.merge1(rt[u],rt[v],1,cnt,col[u]);
            else rt[u] = sgt.merge2(rt[u],rt[v],1,cnt);
        }
		sgt.tag[rt[u]] = 0; if(u > n) return;
        sgt.modify(rt[u],1,cnt,col[u]);
		addmod(ans,sub(sgt.sum[rt[u]],sgt.query(rt[u],1,cnt,col[u])));
		sort(tmp + 1,tmp + 1 + sz); sz = unique(tmp + 1,tmp + 1 + sz) - tmp - 1;
		for(int i = 1;i <= sz;i++){
            for(int j = 2;j <= K;j++) addmod(ans,dp[tmp[i]][j]);
            for(int j = 0;j <= K;j++) dp[tmp[i]][j] = 0;
        }
    }
} rst;

void tarjan(int u){
    static int top = 0, idx = 0, x;
    dfn[u] = low[u] = ++idx; st[++top] = u;
    for(int v : G[u]){
        if(!dfn[v]){
            tarjan(v); checkMin(low[u],low[v]);
            if(low[v] >= dfn[u]){
                rst.tot += 1; rst.add_edge(rst.tot,u);
                do {x = st[top--], rst.add_edge(rst.tot,x);} while(x != v);
            }
        }else checkMin(low[u],dfn[v]);
    }
}

int main(){
    read(n); read(m); read(K); rst.tot = n;
    for(int i = 1;i <= n;i++) read(col[i]), a[++cnt] = col[i];
    sort(a + 1,a + 1 + cnt); cnt = unique(a + 1,a + 1 + cnt) - a - 1;
    for(int i = 1;i <= n;i++) col[i] = lower_bound(a + 1,a + 1 + cnt,col[i]) - a;
    for(int i = 1,u,v;i <= m;i++){
        read(u); read(v);
        add_edge(u,v); add_edge(v,u);
    }
    tarjan(1); rst.dfs(1,0); printf("%d\n",ans);
    return 0;
}
```

---

## 作者：Su_Zipei (赞：6)

## P7422 题解

首先观察题目中的限制，不难发现 $k$ 只有 $20$ ，于是可以对于每个节点枚举 $k$ 计算，考虑如何计算每个节点的答案。

观察两个要求，对于第一个，供应材料不同的限制比较好满足，城市 $A$ 在城市 $B_i$ 到首都的必经之路上，这个可以转化为， $A$ 是割点并且 $A$ 将首都和 $B_i$ 分在了两个联通块中。

第二个要求， $B$ 之间的材料相同比较好满足，对于 $B$ 之间互不影响，不难发现是在去掉 $A$ 后在不同的联通块中，两条限制都与割点有关系，于是建出圆方树。

显然只需要对于圆点统计答案，设点 $u$ 的材料种类为 $c_u$ ，那么在当前点 $u$ ，需要枚举所有与 $c_u$ 不同的颜色计算贡献，枚举完颜色后，可以用 $map$ 启发式合并统计答案，除了枚举颜色之外的所有操作时间复杂度问题都不是很大，瓶颈在于枚举颜色，考虑优化这一点，因为要合并子树信息，使用线段树合并，~~不难~~发现只有在合并到叶子节点的时候才会要用 $dp$ 修正该种材料的贡献，考场上想到这里开了一下数组，由于并没有仔细计算所以开的很大，~~然后就开了两个G的数组~~，事实上 std 最开始公开时的版本也 MLE 了。

当然把数组开小一点就可以解决了，不过貌似需要精打细算一下，而且赛时由于我开炸的太多了所以没有想优化，因此我使用了一个空间更加安全的做法。

由于对于每个点进行 $dp$ 的时间复杂度正确，所以这一点保持不变，因为每种材料的数量加起来是 $n$ ，考虑对于每种材料单独计算贡献，建出虚树，在每个与该材料种类不同的圆点处直接  $dp$ ，对于虚树上一条边实际上对应原树上的一条链，这一条链上每个圆点的贡献都是该虚树的子树中的这种材料的个数，直接乘上去就行。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+10;
const int p=998244353;
#define rint register int
#define ll long long
#define rll register long long
template<typename T> void read(T &x){
	x=0;rint f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch<='9'&&ch>='0'){x=x*10+ch-'0';ch=getchar();}
	x*=f;
}
vector<int> g[N];
struct Edge{
	int to,nxt;
}e[N<<1];
int h[N],idx;
void Ins(rint a,rint b){
	e[++idx].to=b;e[idx].nxt=h[a];h[a]=idx;
}
int n,m,k,fang,c[N];
map<int,int> mp;
int low[N],dfn[N],stk[N],tp,Time;
void tarjan(rint u,rint fa){
	dfn[u]=low[u]=++Time;
	stk[++tp]=u;
	for(rint v:g[u]){
		if(v==fa)continue;
		if(!dfn[v]){
			tarjan(v,u);
			low[u]=min(low[u],low[v]);
			if(low[v]>=dfn[u]){
				++fang;
				while(1){
					rint x=stk[tp--];
					Ins(fang,x);Ins(x,fang);
					if(x==v)break;
				}
				Ins(fang,u);Ins(u,fang);
			}
		}else low[u]=min(low[u],dfn[v]);
	}
}
int dp[30];
ll res;
int top[N],siz[N],fa[N],son[N],d[N],dis[N];
void dfs1(rint u){
	dfn[u]=++Time;siz[u]=1;dis[u]+=u<=n;
	for(rint i=h[u];i;i=e[i].nxt){
		rint v=e[i].to;
		if(v==fa[u])continue;
		d[v]=d[u]+1;
		fa[v]=u;dis[v]=dis[u];
		dfs1(v);
		siz[u]+=siz[v];
		if(siz[v]>siz[son[u]])son[u]=v;
	}
}
void dfs2(rint u,rint t){
	top[u]=t;
	if(son[u])dfs2(son[u],t);
	for(rint i=h[u];i;i=e[i].nxt){
		rint v=e[i].to;
		if(v==fa[u]||v==son[u])continue;
		dfs2(v,v);
	}
	h[u]=0;
}
int lca(rint x,rint y){
	while(top[x]^top[y]){
		if(d[top[x]]<d[top[y]])y=fa[top[y]];
		else x=fa[top[x]];
	}
	return d[x]>d[y]?y:x;
}
int colcnt,col;
bool cmp(rint a,rint b){
	return dfn[a]<dfn[b];
}
void insert(rint x){
	if(!tp){
		stk[++tp]=x;
		return ;
	}
	rint lc=lca(stk[tp],x);
	while(tp>1&&d[stk[tp-1]]>=d[lc])
		Ins(stk[tp-1],stk[tp]),tp--;
	if(stk[tp]!=lc)
		Ins(lc,stk[tp]),stk[tp]=lc;
	stk[++tp]=x;
}
void dfs3(rint u){
	siz[u]=0;
	for(rint i=h[u];i;i=e[i].nxt){
		rint v=e[i].to;
		dfs3(v);
		siz[u]+=siz[v];
		res+=1ll*siz[v]*(dis[v]-dis[u]-(v<=n))%p;
	}
	if(c[u]==col)siz[u]++;
	else if(u<=n){
		dp[0]=1;
		for(rint i=1;i<=k;i++)
			dp[i]=0;
		for(rint i=h[u];i;i=e[i].nxt){
			rint v=e[i].to;
			for(rint j=k;j;j--)
				dp[j]=(dp[j]+1ll*dp[j-1]*siz[v])%p;
		}
		for(rint i=1;i<=k;i++)
			res+=dp[i];
	}
	h[u]=0;
}
void solve(){
	tp=idx=0;
	sort(g[col].begin(),g[col].end(),cmp);
	if(g[col][0]!=1)stk[++tp]=1;
	for(rint x:g[col])
		insert(x);
	while(tp>1)
		Ins(stk[tp-1],stk[tp]),tp--;
	dfs3(1);
}
int main(){
	read(n);read(m);read(k);
	for(rint i=1;i<=n;i++){
		read(c[i]);
		if(!mp[c[i]])mp[c[i]]=++colcnt;
		c[i]=mp[c[i]];
	}
	while(m--){
		rint a,b;
		read(a);read(b);
		g[a].push_back(b);g[b].push_back(a);
	}
	fang=n;
	tarjan(1,0);
	Time=0;
	for(rint i=1;i<=n;i++)g[i].clear();
	for(rint i=1;i<=n;i++)g[c[i]].push_back(i);
	dfs1(1);
	dfs2(1,1);
	for(col=1;col<=colcnt;col++)
		solve();
	printf("%lld\n",res%p);
	return 0;
}


```

---

## 作者：LYinMX (赞：6)

## Dsu on tree  

题意大致是先建出**圆方树**。  
求圆点的子树下有多少个来自不同子树的和它颜色不一样的颜色相同的点的集合数。  
$k \leq 20 $ 可以直接 $dp$，单次复杂度 $O(k)$。  
需要**子树信息的合并**，考虑线段树合并，出题人已经说过了，时间复杂度 $O(n \log n+nk)$，空间复杂度 $O(n \log n+nk)$。  
需要**分颜色处理**，考虑虚树，$\red{S}u\_Zipei$ 讲过了，时间复杂度 $O(n \log n+nk)$，空间复杂度 $O(n)$。  
但我们也可以用 $Dsu \; on \; tree$ 解决。  
对于轻儿子之前的记录，我们可以暴力清除。  
同样与线段树合并相同的是，我们在继承重儿子的时候，只需要知道和它颜色不一样的点的个数即可，然后加入答案。  
在暴扫轻儿子加进dp数组时，需要判断。  
  
> 当前节点是否是圆点，该颜色是否与当前颜色不同  
> 之前是否出现过该节点  
> 之前是否进行过初始化  

这样看来时间复杂度貌似是 $O(kn \log n)$ 的，其实是也是 $O(n \log n+nk)$ 的。  
我们发现只有两个儿子中相同颜色集合合并时，才可能做 $dp$。  
考虑在脑中对相同颜色节点建虚树，发现所有点的 $lca$ 都在虚树上，只有那些 $lca$ 才可能做$dp$。  
我们又知道虚树的节点个数是 $O(n)$ 的，所以$dp$的复杂度为 $O(nk)$。  
常数较小，但细节较多，考场上不推荐，推荐用虚树。  
在$2022年7月29日$是最优解，[代码](https://www.luogu.com.cn/record/81600947)。


---

## 作者：accgj_ (赞：0)

[题目链接](https://www.luogu.com.cn/problem/P7422)

-------


题目大意：给出一张无向连通图，点有点权（颜色），要求选择一个点 $x$ 与一个大小小于等于 $k$ 的点集，要求点集中的点颜色一样，且与 $x$ 的颜色不同，要满足点集中的任意一点到点 $1$ 的所有简单路径都经过点 $x$，且点集中的任意两个点，二者分别到点 $x$ 的简单路径不存在公共边，求方案数。

-------

无向连通图，必定经过与路径必不交，就能马上想到点双与圆方树。

在圆方树上就变成了在一个子树内选择一些点，使得这些点颜色相同且与子树的根的颜色不同。

发现颜色太多，然后注意到不同颜色间没有贡献，便考虑虚树，当然，也可以直接用线段树合并维护各个颜色的出现次数。

因为最多只选 20 个点，所以可以直接存下方案数。

之后就是比较常规的东西了。

总得来说比较简单，~~就是一开始读错了题~~。

代码（一开始读错了题，写了点分讨，没删干净）：

``````cpp
#include<bits/stdc++.h>
using namespace std;

char *p1,*p2,buf[1000000];
#define nc() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1000000,stdin),p1==p2)?EOF:*p1++)
inline int read()
{
	int x=0;char ch=nc();
	while(ch<'0' or ch>'9')ch=nc();
	while(ch>='0' and ch<='9')x=(x<<3)+(x<<1)+ch-'0',ch=nc();
	return x;
}


const long long mod=998244353;

int n,m,k;

struct graph
{
	struct edg
	{
		int nxt,to;
	}e[2000001];
	int head[1000001],cnt;
	inline void add(int u,int v){e[++cnt].nxt=head[u];head[u]=cnt;e[cnt].to=v;}
	struct asd
	{
		int dfn,low,scc;bool x;
	}a[1000001];
	int dfn=0,scc=0;
	stack<int> s;
	
}g1;
int col[1000001];
struct graph2
{
	struct edg
	{
		int nxt,to;
	}e[2000001];
	int head[1000001],cnt;
	inline void add(int u,int v){e[++cnt].nxt=head[u];head[u]=cnt;e[cnt].to=v;}
	struct asd
	{
		int dfn,dep,son,size,fa,adsize,top;
		int dep2;
		multiset<pair<int,int> > adv;
	}a[1000001];
	int dfn=0;
	inline void dfs(int u,int fa)
	{
		a[u].fa=fa;a[u].size=1;a[u].son=0;a[u].dep=a[fa].dep+1;
		a[u].dep2=a[fa].dep2;
		if(u<=n)a[u].dep2++;
		if(u<=n)a[u].adsize=1;
		for(int i=head[u];i;i=e[i].nxt)
		{
			if(e[i].to==fa)continue;
			dfs(e[i].to,u);a[u].size+=a[e[i].to].size;
			a[u].adsize+=a[e[i].to].adsize;
			if(a[e[i].to].size>a[a[u].son].size)a[u].son=e[i].to;
		}
	}
	int adm[1000001];
	inline void dfs2(int u,int top)
	{
		a[u].top=top;a[u].dfn=++dfn;adm[dfn]=u;
		if(!a[u].son)return;
		dfs2(a[u].son,top);
		a[u].adv.insert({a[a[u].son].dfn+a[a[u].son].size-1,a[u].son});
		for(int i=head[u];i;i=e[i].nxt)
		{
			if(e[i].to==a[u].fa or e[i].to==a[u].son)continue;
			dfs2(e[i].to,e[i].to);
			a[u].adv.insert({a[e[i].to].dfn+a[e[i].to].size-1,e[i].to});
		}
	}
	inline int lca(int u,int v)
	{
		while(a[u].top!=a[v].top)
		{
			if(a[a[u].top].dep>a[a[v].top].dep)u=a[a[u].top].fa;
			else v=a[a[v].top].fa;
		}
		if(a[u].dep>a[v].dep)swap(u,v);
		return u;
	}
	inline int getlca(int u,int v){return a[u].dep+a[v].dep-2*a[lca(u,v)].dep;}
	inline int getlca2(int u,int v){return a[u].dep2+a[v].dep2-2*a[lca(u,v)].dep2;}
	inline int getl(int u,int v)
	{
		pair<int,int> add={a[v].dfn,-1};
		pair<int,int> adx=*a[u].adv.lower_bound(add);
		return adx.second;
	}
}g2;




int adcol[1000001];
map<int,int> admc;

vector<int> adc[500002];

long long ans;

bool cmp(int a,int b)
{
	return g2.a[a].dfn<g2.a[b].dfn;
}
long long tot1,tot2,tot3;
struct graph3
{
	struct edg
	{
		int nxt,to;
	}e[2000001];
	int head[1000001],cnt;
	inline void add(int u,int v){e[++cnt].nxt=head[u];head[u]=cnt;e[cnt].to=v;}
	struct asd
	{
		int size;
		bool mark;
	}a[1000001];
	int dfn=0;
	int adx[1000001];
	stack<int> s;
	int totnum;
	
	inline void dfs(int u,int fa,int c)
	{
		if(col[u]==c)a[u].size=1;
		else a[u].size=0;
		long long *tot=new long long [21];
		for(int i=0;i<=20;i++)tot[i]=0;
		tot[0]=1;
		
		
		for(int i=head[u];i;i=e[i].nxt)
		{
			int v=e[i].to;
			
			dfs(e[i].to,u,c);a[u].size+=a[e[i].to].size;
			
			tot1-=ans;
			((ans+=1ll*(g2.a[v].dep2-g2.a[u].dep2-(v<=n))*a[v].size%mod)>=mod)&&(ans-=mod);
			//((ans+=1ll*(g2.getlca2(xv,v)-1)*a[v].size%mod*(a[1].size-a[v].size)%mod)>=mod)&&(ans-=mod);
			tot1+=ans;
			tot1=(tot1%mod+mod)%mod;
			
			
		}
		if(col[u]!=0 and col[u]!=c)
		{
			for(int i=head[u];i;i=e[i].nxt)
			{
				int v=e[i].to;
				for(int i=k-1;i>=0;i--)((tot[i+1]+=tot[i]*a[v].size%mod)>=mod)&&(tot[i+1]-=mod);
			}
			
			for(int i=1;i<=k;i++)
			{
				((ans+=tot[i])>=mod)&&(ans-=mod);
				((tot3+=tot[i])>=mod)&&(tot3-=mod);
			}
		}
	}
	
	inline void solve(int c)
	{
		cnt=0;totnum=0;
		for(int i=1;i<=adx[0];i++)
		{
			head[adx[i]]=0;
			a[adx[i]].size=a[adx[i]].mark=0;
		}
		adx[0]=0;
		
		for(int i=0;i<adc[c].size();i++)adx[++adx[0]]=adc[c][i];
		nth_element(adx+1,adx+1,adx+1+adx[0],cmp);
		totnum=adx[0];
		if(adx[1]!=1)adx[++adx[0]]=1;
		sort(adx+1,adx+1+adx[0],cmp);
		while(!s.empty())s.pop();
		int adn=adx[0];
		for(int i=1;i<=adn;i++)
		{
			if(s.empty())
			{
				s.push(adx[i]);
				continue;
			}
			int lc=g2.lca(adx[i],s.top());
			if(lc==s.top())
			{
				if(adx[i]!=s.top())s.push(adx[i]);continue;
			}
			
			int ax=s.top();
			while(g2.a[s.top()].dfn>g2.a[lc].dfn)
			{
				ax=s.top();
				s.pop();
				if(g2.a[s.top()].dfn>g2.a[lc].dfn)
				{
					add(s.top(),ax);
				}
			}
			add(lc,ax);
			if(s.top()==lc)
			{
				if(adx[i]!=s.top())s.push(adx[i]);
			}
			else 
			{
				s.push(lc);
				if(lc!=adx[i])s.push(adx[i]);
				adx[++adx[0]]=lc;
			}
		}
		while(!s.empty())
		{
			int x=s.top();s.pop();
			if(s.empty())break;
			add(s.top(),x);
		}
		dfs(1,0,c);
	}
}g3;
inline void tarjan(int u);
int main()
{
	n=read();m=read();k=read();
	for(int i=1;i<=n;i++)col[i]=read(),adcol[i]=col[i];
	sort(adcol+1,adcol+n+1);
	int adx=unique(adcol+1,adcol+n+1)-(adcol+1);
	for(int i=1;i<=adx;i++)admc[adcol[i]]=i;
	for(int i=1;i<=n;i++)col[i]=admc[col[i]],adc[col[i]].push_back(i);
	for(int i=1;i<=m;i++)
	{
		int u=read(),v=read();g1.add(u,v);g1.add(v,u);
	}
	tarjan(1);
	g2.dfs(1,0);g2.dfs2(1,1);
	for(int i=1;i<=adx;i++)g3.solve(i);
	
	printf("%lld\n",ans);
	return 0;
}
inline void tarjan(int u)
{
	g1.a[u].dfn=g1.a[u].low=++g1.dfn;g1.s.push(u);
	for(int i=g1.head[u];i;i=g1.e[i].nxt)
	{
		if(!g1.a[g1.e[i].to].dfn)
		{
			tarjan(g1.e[i].to);
			g1.a[u].low=min(g1.a[u].low,g1.a[g1.e[i].to].low);
			if(g1.a[g1.e[i].to].low>=g1.a[u].dfn)
			{
				++g1.scc;
				while(1)
				{
					g2.add(g1.s.top(),g1.scc+n);
					g2.add(g1.scc+n,g1.s.top());
					g1.a[g1.s.top()].scc=g1.scc;
					g1.a[g1.s.top()].x=0;
					if(g1.s.top()==g1.e[i].to)
					{
						g1.s.pop();
						break;
					}
					g1.s.pop();
				}
				g2.add(u,g1.scc+n);
				g2.add(g1.scc+n,u);
			}
		}
		else
		{
			g1.a[u].low=min(g1.a[u].low,g1.a[g1.e[i].to].dfn);
		}
	}
}


``````

---

## 作者：hlsnqdmz (赞：0)

一道将圆方树和虚树揉在一起的题，做起来也蛮有意思。（虽然由于树剖写错导致我 WA 了好几发）

看到题干，要求统计方案数，要作为一个方案要满足两个要求，我们发现如果这是在一棵树上，条件一就很好判断，只要 $A$ 是 $B_i$ 的祖先就行了，但是这是在一个图上，我们想到用圆方树将图转化成树。但是我们看到第二个条件，如果没有仔细看的话会以为两点只要都各自有一条路径到 $A$ 使这两条路径不相交就算答案，那么用圆方树就会导致错误。但实际上是**任意**路径，就像样例里的 3 和 4，它们对于 2 并不是互不影响的，所以在环上的两点是会互相影响的，所以可以放心用圆方树。

接着考虑将图化成树后怎么去完成，条件一已经说明 $B$ 肯定在 $A$ 的子树中，条件二说明每个 $B$ 必须出自 $A$ 的不同子树。我们发现两个不同颜色的点是一定不会出现在同一个集合的，我们可以尝试对于每个颜色分别处理，考虑到对于每个颜色建虚树，这样所有虚树上的点一共就是 $n$ 个。

接着我们考虑在虚树上进行统计，我们发现，在虚树上的点要么是我们当前枚举的颜色的点，要么拥有至少两棵包含有当前枚举的颜色的点的子树。而一个不是当前枚举颜色的**圆点**，它到每个儿子节点的边其实在原树上相当于一条链，这条链上面的除了当前点和儿子节点以外的**圆点**只有一个包含当前枚举颜色的点的子树，即儿子节点所在的那个。也就是说它们只能拥有 $k=1$ 的集合，不过也是有的，所以要把它统计上。我们提前预处理从 1 号点到每个点的圆点个数。这样拿儿子节点的和当前点的一减就能求出它们之间的链上的圆点个数，如果儿子节点也是圆点还要减一。得出来的圆点个数乘上儿子节点子树上的当前枚举颜色的点的个数就是这些点提供的方案数。

然后考虑虚树上的非当前枚举颜色的圆点，我们发现，对于每棵虚树上的子树，我们都可以选择将其包含的**一个**当前枚举的颜色的点加入集合或者都不加入，这让我们想到动态规划。而 $k$ 最大只有 20，所以我们可以直接枚举。于是我们设 $dp[u][i]$ 为第 $u$ 个点 $i$ 元集合的个数，初始 0 元点集有 1 个，其他全部为 0。设 $size[u]$ 为点 $u$ 子树上的当前枚举颜色的点的个数。那么每枚举到一个子树，我们有 $size[v]$ 种可能，即将其中一个点加入集合，不加入不需要讨论。也就是说 $dp[u][i]+=dp[u][i-1]\times size[v]$。解决完这个我们发现，这样的数组占用空间太大了，每个点的值也不会影响其他点，况且最后我们都要将它们统计到方案数里，所以我们去掉第一维，每次 dp 时先清空数组就行。

最后我们想用 `vector` 保存每个颜色点的个数，但是颜色值实在太大，但是最多只有 $5\times 10^5$ 个，我们可以使用 `unordered_map` 离散化，这里用的是手写哈希表。

最后给出马蜂丑陋的代码：
```
//Just Sayori
#pragma GCC diagnostic ignored "-Wnarrowing"
#pragma GCC diagnostic ignored "-Wsign-compare"
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <vector>
#define ll long long
#define rnt register int
#define gr getchar
#define pr putchar
#define N 1000005
#define M 998244353
using namespace std;
inline ll read()
{
	ll x = 0, f = 1;
	char ch = gr();
	while (ch < '0' || ch > '9') ch == '-' ? f = -1, ch = gr() : ch = gr();
	while (ch >= '0' && ch <= '9') x = (x << 3) + (x << 1) + (ch ^ 48), ch = gr();
	return x * f;
}
inline void write(ll x)
{
	static int top = 0, sta[39];
	if (x < 0) pr('-'), x = -x;
	do sta[++top] = x % 10, x /= 10;
	while (x);
	while (top) pr(sta[top--] ^ 48);
}
struct HASH
{
#define HM 500000
	struct edge
	{
		int x, y;
		int next;
	} e[N];
	int head[HM], cnt;
	inline int get_num(int x)
	{
		return (x + HM) % HM;
	}
	int query(int x)
	{
		int g = get_num(x);
		for (rnt i = head[g]; i; i = e[i].next)
			if (e[i].x == x)
				return e[i].y;
		e[++cnt] = {x, cnt, head[g]}, head[g] = cnt;
		return cnt;
	}
} h;
struct EDGE
{
	struct edge
	{
		int v, next;
	} e[N << 2];
	int head[N << 1], cnt;
	inline void tdd(int u, int v)
	{
		e[++cnt] = {v, head[u]}, head[u] = cnt;
		e[++cnt] = {u, head[v]}, head[v] = cnt;
	}
} g, t, vt;
int n, m, k, bcc, cnt, lca, top, color;
ll ans;
int c[N << 1], d[N << 1], fa[N << 1], sz[N << 1], tp[N << 1], dfn[N << 1], low[N], bson[N << 1], deep[N << 1], stack[N];
ll dp[21];
vector<int> p[N];
void tarjan(int u)
{
	dfn[u] = low[u] = ++cnt;
	stack[++top] = u;
	for (rnt i = g.head[u]; i; i = g.e[i].next)
	{
		int v = g.e[i].v;
		if (!dfn[v])
		{
			tarjan(v), low[u] = min(low[u], low[v]);
			if (low[v] == dfn[u])
			{
				bcc++;
				while (stack[top + 1] != v)
					t.tdd(bcc, stack[top--]);
				t.tdd(bcc, u);
			}
		}
		else
			low[u] = min(low[u], dfn[v]);
	}
}
void dfs1(int u, int f)
{
	fa[u] = f, sz[u] = 1;
	deep[u] = deep[f] + 1;
	d[u] = d[f] + (u <= n);
	for (rnt i = t.head[u]; i; i = t.e[i].next)
	{
		int v = t.e[i].v;
		if (v == f) continue;
		dfs1(v, u);
		sz[u] += sz[v];
		if (sz[v] > sz[bson[u]]) bson[u] = v;
	}
}
void dfs2(int u, int p)
{
	tp[u] = p;
	dfn[u] = ++cnt;
	if (!bson[u]) return;
	dfs2(bson[u], p);
	for (rnt i = t.head[u]; i; i = t.e[i].next)
	{
		int v = t.e[i].v;
		if (v == fa[u] || v == bson[u]) continue;
		dfs2(v, v);
	}
}
int get_lca(int a, int b)
{
	while (tp[a] != tp[b])
	{
		if (deep[tp[a]] < deep[tp[b]]) swap(a, b);
		a = fa[tp[a]];
	}
	if (deep[a] > deep[b]) swap(a, b);
	return a;
}
void dfs3(int u, int f)
{
	sz[u] = c[u] == color;
	for (rnt i = vt.head[u]; i; i = vt.e[i].next)
	{
		int v = vt.e[i].v;
		if (v == f) continue;
		dfs3(v, u);
		sz[u] += sz[v];
		(ans += 1ll * sz[v] * (d[v] - d[u] - (v <= n)) % M) %= M; //求出两点路径上的不在虚树上的圆点个数，这些都是满足 k=1 的
	}
	if (c[u] == color || u > n) return;
	dp[0] = 1;
	for (rnt i = 1; i <= k; i++) dp[i] = 0;
	for (rnt i = vt.head[u]; i; i = vt.e[i].next)
	{
		int v = vt.e[i].v;
		if (v == f) continue;
		for (rnt j = k; j; j--)
			(dp[j] += 1ll * dp[j - 1] * sz[v] % M) %= M;//求出当前点 k 等于各个值的答案
	}
	for (rnt i = 1; i <= k; i++)
		ans += dp[i];
}
inline bool cmp(int a, int b)
{
	return dfn[a] < dfn[b];
}
void build()
{
	sort(p[color].begin(), p[color].end(), cmp);
	stack[top = 1] = 1, vt.cnt = vt.head[1] = 0;
	for (rnt i = 0; i < p[color].size(); i++)
		if (p[color][i] != 1)
		{
			lca = get_lca(p[color][i], stack[top]);
			if (lca != stack[top])
			{
				while (dfn[lca] < dfn[stack[top - 1]])
					vt.tdd(stack[top - 1], stack[top]), top--;
				if (dfn[lca] != dfn[stack[top - 1]])
					vt.head[lca] = 0, vt.tdd(lca, stack[top]), stack[top] = lca;
				else
					vt.tdd(lca, stack[top--]);
			}
			vt.head[p[color][i]] = 0, stack[++top] = p[color][i];
		}
	for (rnt i = 1; i < top; i++)
		vt.tdd(stack[i], stack[i + 1]);
}
int main()
{
	n = read(), m = read(), k = read(), bcc = n;
	for (rnt i = 1; i <= n; i++) c[i] = read(), c[i] = h.query(c[i]), p[c[i]].push_back(i);
	for (rnt i = 1; i <= m; i++)
		g.tdd(read(), read());
	tarjan(1), cnt = 0, dfs1(1, 0), dfs2(1, 1);
	for (color = 1; color <= h.cnt; color++)
		build(), dfs3(1, 0);
	write(ans % M);
	return 0;
}
```
### 感谢您的观看！

---


# 三角形

## 题目描述

给出平面上的 $n$ 个等腰直角三角形。每个三角形用三个整数 $x,y,m$ 描述。一个三角形的三个顶点分别是 $(x,y),(x+m,y),(x,y+m)$。

你的任务是计算这些三角形覆盖的总面积。

## 说明/提示

样例解释：

![](https://cdn.luogu.com.cn/upload/image_hosting/5ti25vl7.png)

数据范围：$1\le n \le 2000$，$1 \le i \le n$，$-10^7 \le x_i,y_i \le 10^7$，$1\leq m_i \le 1000$。

## 样例 #1

### 输入

```
5
-5 -3 6
-1 -2 3
0 0 2
-2 2 1
-4 -1 2
```

### 输出

```
24.5```

# 题解

## 作者：ZhYic (赞：43)

# [P1222三角形](https://www.luogu.org/problemnew/show/P1222)
---
这道题已经有一位巨神发了汤普森积分的解法了，而且我的解法并不是最优的，仅供参考。

首先，计算几何中一种非常常用的算法是[扫描线算法（这是一篇比较全面的博文）](https://www.cnblogs.com/dongzhiwu/p/8349954.html)，但是与[矩形中的扫描线算法](http://acm.hdu.edu.cn/showproblem.php?pid=1542)不同，三角形因为边不是都与坐标轴平行，故不能采用矩形面积计算中常用的[差分+线段树维护](https://blog.csdn.net/tomorrowtodie/article/details/52048323)。  
回顾一下扫描线算法的思想
> 对于一个给定的多边形，用一组水平(垂直)的扫描线进行扫描，对每一条扫描线均可求出与多边形边的交点，这些交点将扫描线分割成落在多边形内部的线段和落在多边形外部的线段；并且二者相间排列。于是，将落在多边形内部的线段上的所有象素点赋以给定的色彩值。
       算法中不需要检验每一个象素点，而只考虑与多边形边相交的交点分割后的扫描线段。  
       
于是我们可以想到，仿照类似于矩形面积计算中的操作，当出现一条底边时将这条底边对应的三角形加入统计范围，计算出扫描线总长度，到达顶点时将这个三角形删去。又因为斜边的存在，每次扫描线和每个三角形的交线长度发生改变，因此需要每次重新统计长度。  
这就是大体思路，但还有很多细节需要处理。  
- 如何计算覆盖的面积？
- 如何获得三角形和扫描线的交线长度，即如何避免重复计算？
- 如何处理较大的坐标范围？
对于第一点，我们可以从样例入手：
![](https://cdn.luogu.com.cn/upload/pic/22941.png )
如图，直线$PQ$与$\triangle CAB$，$\triangle DEF$交于$RDSE$四点，并且交线与下方$\triangle ABC$底边$AB$形成了梯形$RSBA$，此区域的面积为$$\frac{(RS+AB)\cdot AR}{2}$$  
而若有多个梯形，由公式变形得$$\sum\frac{(a+b)\cdot h}{2} = \sum(a+b)\cdot\frac{h}{2}$$
所以只需要算出上底和和下底和就可以计算面积了。

对于问题二，我们同样采用类差分思路，即若扫到三角形左端的交点记录一个差分值为+1的节点，扫到三角形右端交点就记录一个差分值为-1的节点。  
同时对于第三点，我们不能采用值域大小的差分数组一一维护扫描线，需要先记下节点的x值，排序后进行处理：  
从左向右累加差分值，若当前sum=0就记为起点，若sum>0，就继续向后，若加上当前差分值后sum=0，就用当前的x值减去起点的x值。  
对于扫描线我们需要进行离散化处理，即三角形底边、顶点处添加扫描线。  
~~AC~~代码如下：
```
#include <bits/stdc++.h>
#define eps 1e-4
#define N 2008
using namespace std;
int n,xi,yi,mi,lennow,lenbef,cnt,cnt1,cnt2=1,ori[N*2];
double ans;
struct node
{
    int x,f;
}line[N*2];
struct tri
{
    int x,y,m;
    bool operator < (const tri& a) const
    {
        return y<a.y;
    }
}shape[N];
vector<tri>q;
int sum_up(int x)
{
    int len=0;
    for(int j=1,last=0,s=0;j<=cnt;j++)
    {
        if(s==0)last=j;
        if(s+line[j].f==0)len+=(line[j].x-line[last].x);
        s+=line[j].f;
    }
    return len;
}
void put(int x)
{
    cnt=0;
    for(vector<tri>::iterator iter=q.begin();iter!=q.end();)
    {
        tri now=*iter;
        int x1=now.x,x2=now.x+(now.m-(ori[x]-ori[now.y]));
        line[++cnt]={x1,1},line[++cnt]={x2,-1};
        if(x1==x2)iter=q.erase(iter);
        else iter++;
    }
}
void add(int y)
{
    while(shape[cnt2].y==y)
    {
        q.push_back(shape[cnt2]);
        int x1=shape[cnt2].x,x2=shape[cnt2].x+shape[cnt2].m;
        line[++cnt]={x1,1},line[++cnt]={x2,-1};
        cnt2++;
    }
}
bool cmp(node a,node b)
{
    return a.x<b.x;
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        scanf("%d%d%d",&xi,&yi,&mi);
        ori[++cnt]=yi,ori[++cnt]=yi+mi;//离散化纵坐标
        shape[i]={xi,yi,mi};
    }
    sort(ori+1,ori+1+cnt);//离散化
    for(register int i=1;i<=cnt;i++)
        if(ori[i]!=ori[i-1])ori[++cnt1]=ori[i];
    sort(shape+1,shape+1+n);
    for(register int i=1;i<=n;i++)
        shape[i].y=lower_bound(ori+1,ori+1+cnt1,shape[i].y)-ori;
    for(int i=1;i<=cnt1;i++)//枚举扫描线
    {
        put(i);
        sort(line+1,line+1+cnt,cmp);
        lennow=sum_up(i);//上底
        ans+=(double)(lennow+lenbef)*(ori[i]-ori[i-1])/2.00;//面积
        add(i);
        sort(line+1,line+1+cnt,cmp);
        lenbef=sum_up(i);//下底
    }
    printf("%.1lf\n",ans);
}
```
先不看代码，如果你照着这个思路打过不了样例，就是因为梯形的上底和下底要分别计算。  
我们还是看样例
![](https://cdn.luogu.com.cn/upload/pic/22941.png )当扫描线到$AB$时，没有上底，下底为$AB$；接着扫描，到$R-D-S-E$时，上底为$RS$，此时应先计算下方梯形面积，再更新应计算的三角形$\triangle DEF$，更新上底为$RS+SE$。即用上一条扫描线上的全部覆盖值作为下底，该扫描线上的覆盖值作为上底，最后再向三角形表中加入新的三角形。

---
好了，如果你真这么打了，也许只有60分
### 一个漏洞
我们很容易知道在扫描线遇到三角形底边或者顶端时会产生/消失新的梯形，但在中间，是否存在其他交点导致扫描线之间不是一个梯形？答案是肯定的，一开始我就是这么错的。
我们来看以下一组数据：![测试数据改](https://cdn.luogu.com.cn/upload/pic/23161.png)
其中红色为上一条扫描线，橙色为当前扫描线，不难发现，由上述逻辑计算出的梯形总上底长为$ZA_1+C_1E_1$，总下底为$QU$，算得的扫描线间总面积实为$S_{ZA_1TQ}+S_{C_1E_1TU}$，而实际面积中并无$S_{ZA_1TQ}$一项。可以看到，在两条扫描线之间还有一处斜边与直角边的交点，而之前并未考虑。所以，需要改进的地方就是在斜边与纵向直角边的交点处添加扫描线。
具体说，可以枚举斜边与直角边的交点，复杂度为$O(n^2)$，也可以二分后枚举，复杂度大致为$O(n~logn)$。
改进部分如下：
`bool cmp1(tri a,tri b){return a.y<b.y;}`
以及
```
//读入
	sort(shape+1,shape+1+n);//shape{int x,y,m}存储三角形，重载运算符按x排序
    for(int i=1;i<=n;i++)
    {
        tri now={shape[i].x+shape[i].m,0,0};
        int k1=lower_bound(shape+1,shape+1+n,shape[i])-shape,//在此三角形左端以右的
            k2=lower_bound(shape+1,shape+1+n,now)-shape;//在此三角形右端以左的
        for(int j=k1;j<=k2;j++)
        {
            int crossy=shape[i].y+(shape[i].x+shape[i].m-shape[j].x);//交点的纵坐标
            if(shape[j].x>shape[i].x&&shape[j].x<shape[i].x+shape[i].m&&shape[j].y<crossy&&shape[j].y+shape[j].m>crossy)ori[++cnt]=crossy;
        }
    }
    sort(shape+1,shape+1+n,cmp1);//按y排序
    //ori（扫描线纵坐标数组）排序去重并离散化
    //枚举扫描线，计算面积

```

这样就可以AC了。  
本蒟蒻的代码比较丑，然后跑得也很慢，反正也就提供一下大概思路了。  
### *end*

---

## 作者：Edgration (赞：22)

本题的一种非正解：$Simpson$积分

用时: 280ms / 内存: 2359KB

在时间上劣于正解，但是对于这题绰绰有余

显然，根据$Simpson$积分公式，

![img](http://upload.wikimedia.org/math/8/0/c/80ca47af148fedc25f9b42d84725c0b2.png)

直接用的话误差会超大，于是用自适应$Simpson$就行了，记得调好$eps$的值，太精确了会$TLE$，太大了会$WA$

温馨提示：不是正解，所以需要$O2$

代码:

```
#include <iostream>
#include <cstdio>
#include <limits.h>
#include <cstdlib>
#include <algorithm>
#include <iostream>
#include <queue>
#include <vector>
#include <cmath>
#include <ctime>
using namespace std;
const int maxn = 5500;
class Tri{
public:
    int x, y, r;
    Tri(int x = 0, int y = 0, int z = 0): x(x), y(y), r(z){}
}T[maxn];
const double eps = 1e-9;
inline int read(){
    char ch = getchar(); int u = 0, f = 1;
    while (!isdigit(ch)) { if (ch == '-') f = -1; ch = getchar();}
    while (isdigit(ch)) { u = (u << 1) + (u << 3) + ch - 48; ch = getchar();}
    return u * f;
}
int a[maxn], n;
vector<pair<double, double> >seg;
bool equal(double a, double b){
    return fabs(a - b) <= eps;
}
double f(double X){
    seg.clear();
    for (int i = 1; i <= n; ++i){
        if (T[i].x < X && T[i].x + T[i].r > X){
            double tmp = T[i].r - (X - T[i].x);
            seg.push_back(make_pair(T[i].y, T[i].y + tmp));
        }
    }
    if (!seg.size()) return 0.0;
    sort(seg.begin(), seg.end());
    double len = 0, last = seg[0].first;
    for (int i = 0; i < seg.size(); ++i)
        if (seg[i].second - last > 0)
        {
            len += seg[i].second - max(seg[i].first, last);
            last = seg[i].second;
        }
    return len;
}
int x_pos[maxn];
double calc(double l, double r, double lv, double rv){
    double mid = (l + r) / 2.0;
    return (lv + 4.0 * f(mid) + rv) * (r - l) / 6.0;
}
double simpson(double l, double r, double now, double lv, double rv){
    double mid = (l + r) / 2.0, mv = f(mid);
    double L = calc(l, mid, lv, mv); double R = calc(mid, r, mv, rv);
    if (equal(L + R, now)) return now;
    return simpson(l, mid, L, lv, mv) + simpson(mid, r, R, mv, rv);
}
int main()
{
    //freopen("data.txt","r",stdin);
    scanf("%d", &n);
    int ct = 0;
    for (int i = 1; i <= n; ++i){
        int a = read(), b = read(), c = read();
        T[i] = Tri(a, b, c);
        x_pos[++x_pos[0]] = a; x_pos[++x_pos[0]] = a + c;
    }
    sort(x_pos + 1, x_pos + 1 + x_pos[0]);
    for (int i = 1; i <= x_pos[0]; ++i)
        if (i == 1 || x_pos[i] != x_pos[i - 1]) x_pos[++ct] = x_pos[i];
    //printf("ct = %d\n", ct);
    //for (int i = 1; i <= ct; ++i) printf("%d ", x_pos[i]);
    double ans = 0;
    for (int i = 2; i <= ct; ++i){
        double l = x_pos[i - 1] + 2 * eps, r = x_pos[i] - 2 * eps, Left = f(l), Right = f(r);
        ans += simpson(l, r, calc(l, r, Left, Right), Left, Right);
        //printf("%lf ", ans);
    }
    printf("%.1lf", ans);
    return 0;
}


```


---

## 作者：FlierKing (赞：19)

这道题的解法和平面矩形面积并相似，采用离散+扫描线的做法。不同的是三角形面积并需要更多的细节处理。

以下对坐标方位进行的描述使用的是平面直角坐标系，即x轴正方向往右，y轴正方向往上。

首先将每个三角形以底边的x坐标的左端点和右端点，以及y坐标记下。因为是不旋转的等腰直角三角形，所以只需要这三个值就可以确定一个三角形。并按底边的y坐标排序三角形。

然后就可以从下往上扫描三角形。在扫描时，我们需要维护一个数组记下这些三角形，并且使这些三角形两两之间不存在包含关系且按照左端点排序好。因为这道题$O(n^2)$的复杂度可以通过，所以可以使用插入排序直接维护这个数组。这样在扫描每一行时就不需要进行复杂的判断了。进行每一行的面积累加时，当前离散化的格子很可能是个长方形而不是个正方形，所以格子的覆盖有以下三种情况：

1. 整个格子被覆盖

2. 格子的右上的三角形区域未被覆盖

3. 格子仅覆盖了左下的三角形区域

分别写出这三种情况的面积公式即可。

接下来还需要考虑继续从下往上扫描时如何继续维护数组。只需要将该三角形的底边的右端点的x坐标减去本次向上扫描的高度差即可（$tan\frac{\pi}{4}=1$）。另外对于已经超过其顶端的三角形需要及时删除，这个直接将暴力维护数组即可。

总复杂度$O(n^2)$


---

## 作者：黑影洞人 (赞：13)

我提供一种新做法

# 时间复杂度 $ O( n^2*log_ n  ) $

我看到这道题,思路是不停地判断任意两个三角形是否重合，然后减掉重叠面积。

很显然，这样的做法无法判断多次重叠的面积交。

期望的分 $ 35pts $，实际得分 $ 80pts $ 。

```cpp
#include<cstdio>
#include<algorithm>
#define double long double
#define N 114514
using namespace std;
struct tri{
    double x,y,h,s;
    void init(){s=(h*h)*0.5;}
}t[N];
int n;
double ans=0,k=0;
bool isin(tri a,tri b){
    if(b.x>=a.x&&b.x<=a.x+a.h&&b.y>=a.y&&b.y<=a.y+a.h)return 1;
    return 0;
}
bool cm(double x,double y){
    if(x-y>=0.000000001)return 1;
    return 0;
}
bool isin2(tri a,double x,double y){
    if(cm(x,a.x)&&cm(a.x+a.h,x)&&cm(y,a.y)&&cm(a.y+a.h,y)&&cm(a.h,x-a.x+y-a.y))return 1;
    return 0;
}
signed main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++){
        double a,b,c;
        scanf("%llf%llf%llf",&a,&b,&c);
        t[i]=(tri){a,b,c};
        t[i].init();
        k+=t[i].s;
    }
    for(int i=1;i<=n;i++){
        for(int j=1;j<=n;j++){
            if(i==j)continue;
            bool flg=0;
            if(isin2(t[i],t[j].x,t[j].y)){
                flg=1;
                ans+=min(t[j].s,(t[i].y+t[i].h-t[j].x+t[i].x-t[j].y)*(t[i].y+t[i].h-t[j].x+t[i].x-t[j].y)*0.5);
            }
            if(isin2(t[i],t[j].x,t[j].y+t[j].h)&&!flg){
                flg=1;
                ans+=min(t[j].s,(t[j].y+t[j].h-t[i].y)*(t[j].y+t[j].h-t[i].y)*0.5);
            }
            if(isin2(t[i],t[j].x+t[j].h,t[j].y)&&!flg){
                ans+=min(t[j].s,(t[j].x+t[j].h-t[i].x)*(t[j].x+t[j].h-t[i].x)*0.5);
            }
        }
    }
    printf("%.1llf",k-ans);
    return 0;
}
```
然后我加上了图论知识。

判断任意三角形之间是否连通，联通则不再加面积交。

```cpp
#include<cstdio>
#include<algorithm>
#define N 1919810
using namespace std;
struct tri{
	double x,y,h,s;
	void init(){s=(h*h)*0.5;}
	bool operator <(const tri &r)const{
		return h>r.h;
	}
}t[N];
int n,tot,head[N],to[N],nxt[N],f[N];
bool vis[N];
void add(int u,int v){
	to[++tot]=v;
	nxt[tot]=head[u];
	head[u]=tot;
}
int find(int x){
	return (x==f[x])?x:f[x]=find(f[x]);
} 
bool cmp(int u,int v){
	vis[u]=1;
	for(int i=head[u];i;i=nxt[i]){
		int y=to[i];
		if(y==v){
			vis[u]=0;
			return 0;
		}
		if(vis[y])continue;
		bool flg=cmp(y,v);
		if(flg==0){
			vis[u]=0;
			return 0;
		}
	}
	vis[u]=0;
	return 1;
}
double ans=0,k=0;
bool isin2(tri a,double x,double y){
	if(x>=a.x&&x<=a.x+a.h&&y>=a.y&&y<=a.y+a.h&&x-a.x+y-a.y<=a.h)return 1;
	return 0;
}
signed main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		double a,b,c;
		scanf("%lf%lf%lf",&a,&b,&c);
		t[i]=(tri){a,b,c};
		t[i].init();
		k+=t[i].s;
	}
	sort(t+1,t+n+1);
	for(int i=1;i<=n;i++)f[i]=i;
	for(int i=1;i<=n;i++){
		for(int j=i;j<=n;j++){
			if(i==j)continue;
			bool flg=0;
			if(isin2(t[i],t[j].x,t[j].y)){
				flg=1;
				if(cmp(i,j)){
					add(i,j);
					ans+=min(t[j].s,(t[i].y+t[i].h-t[j].x+t[i].x-t[j].y)*(t[i].y+t[i].h-t[j].x+t[i].x-t[j].y)*0.5);
				}
			}
			if(isin2(t[i],t[j].x,t[j].y+t[j].h)&&!flg){
				flg=1;
				if(cmp(i,j)){
					add(i,j);
					ans+=min(t[j].s,(t[j].y+t[j].h-t[i].y)*(t[j].y+t[j].h-t[i].y)*0.5);
				}
			}
			if(isin2(t[i],t[j].x+t[j].h,t[j].y)&&!flg){
				if(cmp(i,j)){
					add(i,j);
					ans+=min(t[j].s,(t[j].x+t[j].h-t[i].x)*(t[j].x+t[j].h-t[i].x)*0.5);
				}	
			}
		}
	}
	printf("%.1lf",k-ans);
	return 0;
}

```

期望得分 $ 60pts $ ,实际得分 $ 70pts $ 。

我们思考可以过的做法：

先作 $ (y_{max}+x_{max}) $ 条线垂直于$ x ，y $ 轴，

这样就构造了网格图，

```cpp
  scanf("%d",&n);
  for(int i=1;i<=n;i++){
      scanf("%d%d%d",&x[i],&y[i],&h[i]);
      for(int j=0;j<h[i];j++){
          px[++a]=x[i]+j;//垂直于y轴
          py[++b]=y[i]+j;//垂直于x轴
      }
  } 
```

然后对 $ px , py $ 数组进行离散化，并且把每个垂直于 $ x $ 轴线对应的两个 $ y $ 值记录下来，用一个 $ vector $ 数组来维护。

```cpp
  sort(px+1,px+a+1);
  sort(py+1,py+b+1);
  a=unique(px+1,px+a+1)-px-1;
  b=unique(py+1,py+b+1)-py-1;
  for(int i=1;i<=n;i++){
      for(int j=0;j<h[i];j++){
          int pos=lower_bound(px+1,px+a+1,x[i]+j)-px;
          int l=lower_bound(py+1,py+b+1,y[i])-py;
          int r=lower_bound(py+1,py+b+1,y[i]-j-1+h[i])-py;
          v[pos].push_back({l,r});
      }
  }
```

然后一行一行的扫，每次移动单位 $ 1 $ ，然后记录梯形面积。

```cpp
	for(int p=1;p<=a;p++){
		if(v[p].empty())continue;
		sort(v[p].begin(),v[p].end());
		int l=v[p][0].first,r=v[p][0].second;
		for(int i=1;i<v[p].size();i++){
			if(r<v[p][i].first){
				ans+=(py[r]-py[l])*2+1;
				l=v[p][i].first,r=v[p][i].second;
			}else r=max(r,v[p][i].second);
		}
		ans+=(py[r]-py[l])*2+1;
	}
```
由小学公式：梯形的面积 $ S = [(a+b)*h]/2 $ 。

但是我们上面的操作为了不被卡精度，没有除以 $ 2 $ 。

最后我们格式化输出 $ ans*0.5 $ 即可。

完结撒花！



---

## 作者：辰星凌 (赞：9)

# **【题解】三角形 [P1222] / 三角形覆盖问题 [HNOI2012] [P3219]**

[$\mathcal{My}\ \mathcal{Blog}$](https://www.cnblogs.com/Xing-Ling/p/12109838.html)

传送门：

- [三角形 $\text{[P1222]}$](https://www.luogu.com.cn/problem/P1222)  

- [三角形覆盖问题 $\text{[HNOI2012] [P3219]}$](https://www.luogu.com.cn/problem/P3219)  

## **【题目描述】**

给出 $n$ 个等腰直角三角的顶点和直角边长，求覆盖总面积。

## **【分析】**

[【计算几何全家桶】](https://www.luogu.com.cn/blog/ChenXingLing/post-xue-xi-bi-ji-ji-suan-ji-he-quan-jia-tong)

求三角形面积并的板题。

自适应辛普森法乱搞（什么？你说 [三角形覆盖问题](https://www.luogu.com.cn/problem/P3219) 用辛普森过不了？~~啪~~）。

代码大致和 [圆的面积并](https://www.luogu.com.cn/blog/ChenXingLing/solution-sp8073) 相同，只需要改几个关键点即可：

$F$ 函数中求交线（相较于圆变简单了）：

```cpp
#define LD double
#define Re register int
#define Rd register LD
Re t=0;
for(Re i=1;i<=n;++i)
    if(dcmp(Y-C[i].D)>=0&&dcmp(Y-C[i].U)<0){//如果直线Y与三角形相交
        Rd tmp=C[i].U-Y;//交线长度
        if(dcmp(tmp)>0)Seg[++t]=Segment(C[i].x,C[i].x+tmp);//储存交线
    }
```

判断小三角形是否被大三角形所包含：

```cpp
inline int TIT(Triangle A,Triangle B){//判断三角形A是否在三角形B以内
    return A.L>=B.L&&A.R<=B.R&&A.D>=B.D&&A.U<=B.U&&dcmp(A.R-(B.x+B.U-A.y))<=0;
}
```

完了？

...

$\text{WA}$ 了！

为什么？

在用辛普森求平面图形面积时，如果对象是圆，那么一定不可能一次性满足精度要求（误差极大），但如果是三角形的话很可能**一次计算就结束了递归**。

看下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/7ww1ev0o.png)

对于第一次递归求解 $(l,r)$，用公式计算 $now=Simpson(l,r),FL=Simpson(l,mid),FR=Simpson(mid,r)$ 时使用了上图中的 $5$ 条横线，发现它们都没有经过左边的小三角形，而此时 $now,FL,FR$ 都是算的大三角形的**准确面积**，所以**递归会直接终止**，最终只返回了大三角形的面积，小三角形被忽略。

为什么算 圆面积并 时没有出现这种问题呢？前面说了 计算对象为圆时不可能一次性满足精度要求，也就是说必定会递归扫描到各个位置，不会存在漏掉某一小块的情况。

解决方案（该思路来自 [$\text{Edgration}$ 巨佬](https://www.luogu.com.cn/blog/Edgration/solution-p1222) ）：

记录所有的 $y,y+m$ 并排序去重，对于所有相邻两端点所围住的范围单独处理。如下图，分别递归计算 $(Y_1,Y_2),(Y_2,Y_3),(Y_3,Y_4)$ 三块并求和。

![](https://cdn.luogu.com.cn/upload/image_hosting/di5coqte.png)

精度！精度！！！

[三角形](https://www.luogu.com.cn/problem/P1222) 开 $1e\!-\!9$，[三角形覆盖问题](https://www.luogu.com.cn/problem/P3219) 开 $1e\!-\!10$ 。

~~调参调出了写模拟退火的感觉~~

## **【Code】**

```cpp
#pragma GCC optimize(3,"Ofast","inline")
#include<algorithm>
#include<cstdio>
#include<cmath>
#include<map>
#define LD double
#define LL long long
#define Re register int
#define Rd register LD
#define Vector Point
using namespace std;
const int N=2003;
const LD eps=1e-9;
int n,m;map<LD,LD>vis;
inline int dcmp(Rd a){return a<-eps?-1:(a>eps?1:0);}
struct Point{
    LD x,y;Point(LD X=0,LD Y=0){x=X,y=Y;}
    inline void in(){scanf("%lf%lf",&x,&y);}
};
struct Segment{
    LD L,R;Segment(LD l=0,LD r=0){L=l,R=r;}
    inline bool operator<(Segment O)const{return L!=O.L?L<O.L:R<O.R;}
}Seg[N];
struct Triangle{
	LD x,y,m,L,R,D,U;
	inline void in(){scanf("%lf%lf%lf",&x,&y,&m),L=x,R=x+m,D=y,U=y+m;}
}C[N],C_[N];
inline bool cmp(Triangle A,Triangle B){return A.m<B.m;}//按直角边长排序
inline LD F(Rd Y){
    if(vis[Y])return vis[Y];
    Re t=0;Rd ans=0;
    for(Re i=1;i<=n;++i)
        if(dcmp(Y-C[i].D)>=0&&dcmp(Y-C[i].U)<0){//如果直线Y与三角形相交
            Rd tmp=C[i].U-Y;//交线长度
            if(dcmp(tmp)>0)Seg[++t]=Segment(C[i].x,C[i].x+tmp);//储存交线
        }
    if(!t)return 0.0;
    sort(Seg+1,Seg+t+1);
    for(Re i=1,j;i<=t;i=j+1){
        Rd L=Seg[i].L,R=Seg[i].R;j=i;
        while(j<t&&Seg[j+1].L<=R)++j,R=max(R,Seg[j].R);
        ans+=R-L;
    }
    return vis[Y]=ans;
}
inline LD Simpson(Rd L,Rd R){return (R-L)*(F(L)+4.0*F((L+R)*0.5)+F(R))/6.0;}
inline LD sakura(Rd L,Rd R,Rd now){
    Rd mid=(L+R)*0.5,FL=Simpson(L,mid),FR=Simpson(mid,R);
    if(!dcmp(now-FL-FR))return now;
    return sakura(L,mid,FL)+sakura(mid,R,FR);
}
inline int TIT(Triangle A,Triangle B){//判断三角形A是否在三角形B以内
    return A.L>=B.L&&A.R<=B.R&&A.D>=B.D&&A.U<=B.U&&dcmp(A.R-(B.x+B.U-A.y))<=0;
}
LD ans,YY[N<<1];
int main(){
//  freopen("456.txt","r",stdin);
    scanf("%d",&m);Re t=0;
    for(Re i=1;i<=m;++i)C_[i].in();
    sort(C_+1,C_+m+1,cmp),C[++n]=C_[m];//按半径大小排序
    for(Re i=m-1;i>=1;--i){
        Re flag=1;
        for(Re j=1;j<=n&&flag;++j)if(TIT(C_[i],C[j]))flag=0;
        if(flag)C[++n]=C_[i];
    }
    for(Re i=1;i<=n;++i)YY[++t]=C[i].D,YY[++t]=C[i].U;
    sort(YY+1,YY+t+1);
    for(Re i=2;i<=t;++i)//若干个小块分别处理
        if(dcmp(YY[i]-YY[i-1])>0){
            Rd D=YY[i-1],U=YY[i]-2*eps;//这里必须要偏移边界，否则会死得非常难看
            ans+=sakura(D,U,Simpson(D,U));
        }
    printf("%.1lf",ans);
}
```


---

## 作者：123456zmy (赞：6)

这里给一种不是正解的解法：~~万能的线段树~~

二维平面+区间修改，于是可以想到（~~我就敲了一棵~~）二维线段树。由于空间占用过大，于是需要动态开点。

代码如下（四叉树）：
```cpp
#include<bits/stdc++.h>
using namespace std;
struct node{long long x,y,w,c;node *luc,*ldc,*ruc,*rdc;bool vlu,vld,vru,vrd;}a;
struct abcd{int x,y,m;}b[2001];
bool cmp(abcd i,abcd j){return i.x==j.x?(i.y==j.y?i.m>j.m:i.y<j.y):i.x<j.x;}
long long n,ans;
bool ok;
long long add(long long i,long long j,long long k,node *l)
{
	long long ans1=0,ans2=0,i1,j1,k1;
	if(l->c==((l->w+1)*(l->w+1)<<1))return 0;
	if(i==l->x&&j==l->y&&k>=((l->w+1)<<1))
	{
		long long c1=l->c;
		l->c=((l->w+1)*(l->w+1)<<1);
		return l->c-c1;
	}
	if(l->w==0)return l->c==1?0:l->c=1;
	if(i<=l->x+(l->w>>1)&&j<=l->y+(l->w>>1))
	{
		if(l->vld==0)
		{
			l->ldc=new node;
			l->ldc->x=l->x;
			l->ldc->y=l->y;
			l->ldc->w=(l->w>>1);
			l->vld=1;
		}
		l->c+=ans2=add(i,j,k,l->ldc);
		ans1+=ans2;
	}
	if(i<=l->x+(l->w>>1)&&j+k>l->y+(l->w>>1)+1)
	{
		if(l->luc==0)
		{
			l->luc=new node;
			l->luc->x=l->x;
			l->luc->y=l->y+(l->w>>1)+1;
			l->luc->w=(l->w>>1);
			l->vlu=1;
		}
		i1=i,j1=j,k1=k;
		if(j<=l->y+(l->w>>1))
		{
			k1-=l->y+(l->w>>1)+1-j1;
			j1=l->y+(l->w>>1)+1;
		}
		l->c+=ans2=add(i1,j1,k1,l->luc);
		ans1+=ans2;
	}
	if(i+k>l->x+(l->w>>1)+1&&j<=l->y+(l->w>>1))
	{
		if(l->rdc==0)
		{
			l->rdc=new node;
			l->rdc->x=l->x+(l->w>>1)+1;
			l->rdc->y=l->y;
			l->rdc->w=(l->w>>1);
			l->vrd=1;
		}
		i1=i,j1=j,k1=k;
		if(i<=l->x+(l->w>>1))
		{
			k1-=l->x+(l->w>>1)+1-i1;
			i1=l->x+(l->w>>1)+1;
		}
		l->c+=ans2=add(i1,j1,k1,l->rdc);
		ans1+=ans2;
	}
	if(i+j+k>l->x+l->y+l->w+1&&i+k>l->x+(l->w>>1)+1&&j+k>l->y+(l->w>>1)+1)
	{
		if(l->ruc==0)
		{
			l->ruc=new node;
			l->ruc->x=l->x+(l->w>>1)+1;
			l->ruc->y=l->y+(l->w>>1)+1;
			l->ruc->w=(l->w>>1);
			l->vru=1;
		}
		i1=i,j1=j,k1=k;
		if(i<=l->x+(l->w>>1))
		{
			k1-=l->x+(l->w>>1)+1-i1;
			i1=l->x+(l->w>>1)+1;
		}
		if(j<=l->y+(l->w>>1))
		{
			k1-=l->y+(l->w>>1)+1-j1;
			j1=l->y+(l->w>>1)+1;
		}
		l->c+=ans2=add(i1,j1,k1,l->ruc);
		ans1+=ans2;
	}
	return ans1;
}
int main()
{
	a.x=-(1<<24);
	a.y=-(1<<24);
	a.w=(1<<25)-1;
	scanf("%lld",&n);
	for(int i=1;i<=n;i++)scanf("%lld%lld%lld",&b[i].x,&b[i].y,&b[i].m);
	sort(b+1,b+n+1,cmp);
	int n1=1;
	for(int i=2;i<=n;i++)if(b[i].x!=b[i-1].x||b[i].y!=b[i-1].y)b[++n1]=b[i];
	for(int i=1;i<=n1;i++)
	{
		ok=0;
		for(int j=1;j<=n1;j++)if(i!=j&&b[i].x<b[j].x+b[j].m&&b[i].x+b[i].m>b[j].x&&b[i].y<b[j].y+b[j].m&&b[i].y+b[i].m>b[j].y)
		{
			ans+=add(b[i].x,b[i].y,b[i].m,&a);
			ok=1;
            break;
		}
		if(ok==0)ans+=b[i].m*b[i].m;
	}
	cout<<(ans>>1);
    if(ans&1)printf(".5");
    else printf(".0");
	return 0;
}
```
然后获得了 $90$ 分（$MLE$！！！），~~肯定继续卡空间啊~~，于是 $long$ $long$改 $int$ 还加了离散化、动态删点、各种特判……

代码：

[戳这里](https://www.luogu.com.cn/record/list?pid=P1222&user=44840&page=1)

或者[这里](https://www.luogu.com.cn/paste/w9cld3jd)

于是~~AC了~~还是 $MLE$！！！~~还是扫描线要好一些，~~ 可能是我不会卡空间~~如果卡过了可以私信我~~。

---

## 作者：Foxtr0t (赞：5)

## 原题目

[[P1222] 三角形](https://www.luogu.com.cn/problem/P1222)

## 解析

很多人可能第一次就想到了水平/竖直扫描

于是给三角形排序，然后依次判断步长和上下底长

$ΔS = (ha + hb) * step$ 均为 ```int```，$* 0.5$ 在输出时应用来避免精度起飞

但是，原题给出的样例很有误导性，如果照着那个debug，那么。。。

![翻车现场](https://cdn.luogu.com.cn/upload/image_hosting/2jiouhg4.png)

我当时用了 3 小时找错误原因，测试了不同样例

自己测试永远都是 AC ，上传编译永远有 WA

废话好多呜呜，实现在最后

### 醒悟

最终我回看实现参考的原理：扫描端点判断步长，而不是每个重叠层数变化点

所以两种扫描方向都会出问题。。。

![水平扫描](https://cdn.luogu.com.cn/upload/image_hosting/5b7jeu0t.png)
![竖直扫描](https://cdn.luogu.com.cn/upload/image_hosting/cyymfeed.png)

不止需要判断『端点』，还需要判断『「斜边」与「平行于扫描方向的腰」的交点』

属实离谱，有点难受，因为这样要改的太多了，还可能 TLE

为了挽救我的脑细胞，我做了一个违背初心的决定。。。

### 重启

对题目进行二次分析，发现：

主要矛盾是「对交点判定的需要」和「交点判定方法实现的困难」之间的矛盾

于是进行一个矛盾的转化：

```constexpr int step = 1;```

现在不会漏掉任何一点了，不管什么点都不会漏了！！！

但是会TLE，因为没有三角形的地方浪费了太多时间。。。

### 进化

主要矛盾转变为「三角形间隔之远」和「在间隔处走得太慢」之间的矛盾

虽然修 $bug * 1$ 获得 $bug * 99$ 但是现在的 $bug$ 很容易解决了

如果当前位置没有有效三角形就直接跳到下一个三角形

然后就可以美滋滋 AC 100

![AC](https://cdn.luogu.com.cn/upload/image_hosting/cygjk66u.png)

## 可能遇到的 issue

不开 O2 总会倒数第二 TLE —— 不要用 ```float``` ```double```，看上方『解析』 $ΔS$ 公式

和第一张图错误一样 —— 从头仔细看一下我的『解析』吧，这个问题是重点讲的

## 实现

按照这个思路的实现方法有很多种，太多种

下面提供一种我的 C++ 14 无 O2 代码

用了很多 ```std``` 的轮子，代码比较阴间，我尽力注释了

有意见或疑问欢迎评论区提 issue

```cpp
#include <algorithm>
#include <iostream>
#include <vector>
struct Triangle {
	int x, y, m, x1, y1;
	constexpr Triangle(int x_, int y_, int m_) : x(x_), y(y_), m(m_), x1(x_ + m_), y1(y_ + m_) {}
	constexpr bool operator<(const Triangle& e) const { return (x < e.x) || (x == e.x) && (y < e.y); }
	constexpr int height(int x_) const { return (x_ < x) ? 0 : x_ >= x1 ? 0 : (m + x - x_); }
	constexpr int height1(int x_) const { return (x_ <= x) ? 0 : x_ >= x1 ? 0 : (m + x - x_); }
};
struct Section {
	int a, b;
	constexpr Section(int a_, int b_) : a(a_), b(b_) {}
	constexpr bool operator<(const Section& e) const { return (a < e.a) || (a == e.a) && (b > e.b); }
	constexpr operator int() const { return b - a; }
};
std::vector<Triangle> tri;
std::vector<Triangle> ctx;
int main() {
	int n, x, _x, _y, _m, S = 0, loop = 1;
	std::cin >> n;
	while (n-- && ((std::cin >> _x >> _y >> _m), 1)) tri.emplace_back(_x, _y, _m); // read 三角形
	std::sort(tri.begin(), tri.end()); // sort 三角形
	x = tri[0].x; // first 三角形
	for (size_t i = 0; i < tri.size(); i++)
	{
		ctx.emplace_back(tri[i]);
		while (!(ctx.end()[-1].x == x && i + 1 < tri.size()))
		{
			int x1 = x + 1, h1 = 0;
			std::vector<Section> section;
			for (const auto& e : ctx)
				if (Section tmp = { e.y, e.y + e.height(x) })
					section.emplace_back(tmp); // push 有效区间
			std::sort(section.begin(), section.end());
			for (size_t i = 0; i + 1 < section.size(); i++)
				while (loop++) // 区间合并 ++ 是在复位之前 判断是否继续循环
				{
					loop = 0;
					while (i + 1 < section.size() && section[i].a == section[i + 1].a) section.erase(section.begin() + i + 1), loop = 1;
					while (i + 1 < section.size() && section[i].b > section[i + 1].a) section[i].b = std::max(section[i].b, section[i + 1].b), section.erase(section.begin() + i + 1), loop = 1;
				}
			for (const auto& e : section)
			{
				S += 2ull * e - x1 + x; // S += (左底 + 右底) * 1 //* 0.5
				h1 = h1 + e - x1 + x; // 右底
			}
			x = x1; // x++
			if (!h1)
			{
				for (size_t i = 0; i < ctx.size(); i++)
					if (ctx[i].x1 <= x)
						ctx.erase(ctx.begin() + i--); // TODO(可优化，内存复制浪费时间) // 移除失活三角形 
				if (!ctx.size())
					break;
				x = ctx[0].x; // 跳到下一个三角形
			}
		}
	}
	return printf("%d.%01d", S / 2, 5 * (S % 2)), 0; // S *= 0.5
}
```


---

## 作者：tobie (赞：1)

讲一个比较好理解和实现的做法。

对纵坐标扫描线。假设我们目前扫描到的纵坐标为 $y_0$。

三角形在扫描线上可以看做若干段线段 $[l_i,r_i]$。我们发现一个特点：如果存在 $i,j$ 两条线段满足 $[l_i,r_i]\subseteq [l_j,r_j]$，那么线段 $i$ 所对应的三角形一定会被 $j$ 覆盖住，所以我们可以忽略线段 $i$。

可以证明，舍弃无关线段并排序后的 $l_i$ 和 $r_i$ 分别单调递增。

有了这个性质之后便可以直接求出 $y_0$ 上的线段长度，对于每个 $y_0$ 时间复杂度为 $O(n\log n)$。

考虑哪些位置是重要的：如果两条线段相交，那么它们总会存在一个时刻被分开，如下图：

![image.png](https://s2.loli.net/2024/04/03/cmCzgaZuQXoRWI7.png)


所以我们可以将排序后的 $n$ 对相邻线段的分离时刻存下来。

事实上，每加入一个三角形，对分离时刻的贡献个数是 $O(1)$ 的，所以我们用 `std::set` 去重之后的关键点只有 $O(n)$ 个。

所以总时间为 $O(n)\times O(n\log n)=O(n^2\log n)$。

```cpp
#include<iostream>
#include<cstdio>
#include<set>
#include<algorithm>
using namespace std;
#define int long long
const int N=2009,inf=998244353;
struct sjx{
	int x,y,d;
	sjx(){} sjx(int x_,int y_,int d_){x=x_,y=y_,d=d_;}
}a[N];
bool operator< (sjx x,sjx y){return x.y<y.y;}
set<int> s;
struct xd{
	int l,r;
	xd(){} xd(int l_,int r_){l=l_,r=r_;}
}b[N],bb[N];
bool operator< (xd x,xd y){return x.l==y.l?x.r>y.r:x.l<y.l;}
int n,ans=0;
signed main()
{
	scanf("%lld",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%lld%lld%lld",&a[i].x,&a[i].y,&a[i].d);
		s.insert(a[i].y);
		s.insert(a[i].y+a[i].d);
	}
	int lsty0=(*s.begin()),lstlen=0;
	while(!s.empty())
	{
		set<int>::iterator it=s.begin();
		int y0=(*it);
		s.erase(s.begin());
		//求出上底边长度
		int cnt=0,cnt2=0;
		for(int i=1;i<=n;i++)
		if(a[i].y<y0&&y0<=a[i].y+a[i].d)
		b[++cnt]=xd(a[i].x,a[i].x+a[i].d+a[i].y-y0);
		sort(b+1,b+cnt+1);
		for(int i=1,lst=-inf;i<=cnt;i++)
		if(b[i].r>lst) lst=b[i].r,bb[++cnt2]=b[i];
		int sum=0,r0=-inf;
		for(int i=1;i<=cnt2;i++)
		{
			if(bb[i].l<r0)
			{
				sum+=bb[i].r-r0;
				s.insert(y0+(r0-bb[i].l));
			}
			else sum+=bb[i].r-bb[i].l;
			r0=bb[i].r;
		}
		ans+=(y0-lsty0)*(lstlen+sum);
		//以下需要考虑新加入的线段，更新下底边长度
		cnt=0,cnt2=0;
		for(int i=1;i<=n;i++)
		if(a[i].y<=y0&&y0<=a[i].y+a[i].d)
		b[++cnt]=xd(a[i].x,a[i].x+a[i].d+a[i].y-y0);
		sort(b+1,b+cnt+1);
		for(int i=1,lst=-inf;i<=cnt;i++)
		if(b[i].r>lst) lst=b[i].r,bb[++cnt2]=b[i];
		sum=0,r0=-inf;
		for(int i=1;i<=cnt2;i++)
		{
			if(bb[i].l<r0)
			{
				sum+=bb[i].r-r0;
				s.insert(y0+(r0-bb[i].l));
			}
			else sum+=bb[i].r-bb[i].l;
			r0=bb[i].r;
		}
		lstlen=sum;
		lsty0=y0;
	}
	printf("%lld",ans/2);
	puts((ans&1)?".5":".0");
}
```

---

## 作者：Eltaos_xingyu (赞：1)

[题目传送门 P1222](https://www.luogu.com.cn/problem/P1222)

[题目传送门 P3219](https://www.luogu.com.cn/problem/P3219)

### 算法

这是一篇用自适应 Simpson 写的题解，主要是因为这个蒟蒻作者只会用扫描线写矩形面积并......

那么，自适应 Simpson 是什么？

**前置芝士**：Simpson 公式

![](https://cdn.luogu.com.cn/upload/image_hosting/j6x9k3qs.png)

（图片来源于[P4525](https://www.luogu.com.cn/problem/P4525)的第二篇题解）

不难发现这个公式的误差巨大：

![](https://cdn.luogu.com.cn/upload/image_hosting/o8sk17ek.png)

（图片来源于百度百科）

蓝色部分是公式求的，黄线是原函数......这误差的确肉眼可见的大。

于是自适应 Simpson 就出现了！！！

**自适应 Simpson** 是什么？

简单讲，就是二分区间，用 Simpson 公式计算二分的区间，如果左右区间结果的和加起来与原来的区间的结果在精度控制范围内，那就行，直接返回答案即可，如果超出了精度控制范围，那就继续二分直到结果在精度范围内。

```cpp
ld simpson(ld l,ld r){
	ld mid=(l+r)/2.0;
	return (4*f(mid)+f(r)+f(l))*(r-l)/6.0;
}

ld ASR(ld l,ld r,ld EPS,ld ans,int dep=4){
	ld mid=(l+r)/2.0;
	ld l_=simpson(l,mid),r_=simpson(mid,r);
	if(fabs(l_+r_-ans)<=EPS&&dep<=0)return ans;
	return ASR(l,mid,EPS,l_,dep-1)+ASR(mid,r,EPS,r_,dep-1);
}
```

也就差不多这样......

注意一点，`ASR` 函数中的 `dep` 参数是强制限定了最少递归次数，以防精度爆炸。

相信大家也关注到了代码中的 `f` 函数，那怎么写 `f` 函数呢？

类似于扫描线，我们固定一个平行于 x/y 轴的线，枚举各个三角形覆盖这条线的区间，最后区间并就行了。

那么这道题就做完了（上代码，有些未使用的函数，代码奇丑，所以就尽量不要抄哦 qwq）：

```cpp
#include<bits/stdc++.h>
using namespace std;
const double Pi=acos(-1);
int n;

struct po{
	long double x,y;
}; 
struct vec{
	long double A,B,C;//Ax+By+C=0;
	double dis;
};
vector<po> a[10001];
int y[10001];
bool cmp(vec a,vec b){
	if(a.dis<b.dis)return 1;
	else if(a.dis>b.dis)return 0;
	else if(a.B==0&&b.B==0){
		return a.dis*(-a.C/a.A)<b.dis*(-b.C/b.A);
	}
	else if(a.dis==0&&b.dis==0)return -a.C/a.B>-b.C/b.B;
	else return a.dis*(-a.C/a.B)>b.dis*(-b.C/b.B);
}
vec get_vec_from_po(po p,po q){
	vec v;
	v.A=p.y-q.y;
	v.B=q.x-p.x;
	v.C=p.x*q.y-q.x*p.y;
	v.dis=atan2(q.y-p.y,q.x-p.x);
	return v;
}
double cross3(po s,po d,po f){
	return ((d.x-s.x)*(d.y-f.y)-(d.x-f.x)*(d.y-s.y));
}
po get_po_from_vec(vec c,vec d){
	po pp;
	pp.x=((long double)(-d.B*c.C+c.B*d.C)/(long double)(-c.B*d.A+c.A*d.B));
	pp.y=((long double)(-d.A*c.C+c.A*d.C)/(long double)(c.B*d.A-c.A*d.B));
	return pp;
}
bool compare_po_and_vec(po f,vec g){
	if(g.B==0){
		return (double)((f.x+g.C/g.A)*g.dis)>0;
	}
	if(g.A==0){
		if(g.dis==0)return (double)((f.y+g.C/g.B))<0;
		else return (double)((f.y+g.C/g.B))>0;
	}
	long double yy=-f.x*(g.A/g.B)-(g.C/g.B);
	return (double)((yy-f.y)*(-g.A/g.B)*g.dis)>0;
}
struct cmp_x{
	bool operator()(const po &c ,const po &d)const{
		return (c.x==d.x)? c.y<d.y:c.x<d.x;
	}
};
#define ld long double
const ld eps=1e-9;
struct cmp_x_pair{
	bool operator()(const pair<ld,ld> &e ,const pair<ld,ld> &g)const{
		return (fabs(e.first-g.first)<=eps)? e.second<g.second:e.first<g.first;
	}
};
struct cmp_y{
	bool operator()(const po &e ,const po &f)const{
		return (fabs(e.y-f.y)<=eps)? e.x<f.x:e.y<f.y;
	}
};



vector<pair<ld,ld> > ss;
vector<po> temp;
ld f(ld yy){
	ss.clear();
	vec buff;
	buff.A=0;
	buff.B=1;
	buff.C=-yy;
	for(int k=1;k<=n;k++){
	    temp.clear();
		temp=a[k];
		if(yy>temp[2].y||yy<temp[0].y)continue;
		vec b1=get_vec_from_po(temp[0],temp[2]);
		vec b2=get_vec_from_po(temp[1],temp[2]);
		vec b3=get_vec_from_po(temp[0],temp[1]);
		if(temp[1].y==temp[2].y&&temp[2].y==yy){
			po test1=temp[1];
			po test2=temp[2];
			ss.push_back(make_pair((test1.x>test2.x)?test2.x:test1.x,(test1.x<test2.x)?test2.x:test1.x));
		}
		else if(temp[0].y==temp[1].y&&temp[1].y==yy){
			po test1=temp[0];
			po test2=temp[1];
			ss.push_back(make_pair((test1.x>test2.x)?test2.x:test1.x,(test1.x<test2.x)?test2.x:test1.x));
		}
		else if(yy>=temp[1].y-eps){
			po test1=get_po_from_vec(b1,buff);
			po test2=get_po_from_vec(b2,buff);
			ss.push_back(make_pair((test1.x>test2.x)?test2.x:test1.x,(test1.x<test2.x)?test2.x:test1.x));
		}
		else{
			po test1=get_po_from_vec(b1,buff);
			po test2=get_po_from_vec(b3,buff);
			ss.push_back(make_pair((test1.x>test2.x)?test2.x:test1.x,(test1.x<test2.x)?test2.x:test1.x));
		}
	}
	if(ss.empty())return 0;
	sort(ss.begin(),ss.end(),cmp_x_pair());
	long double last=ss.begin()->first,an=0;
	for(vector<pair<ld,ld> >::iterator itt=ss.begin();itt!=ss.end();itt++){
		if(last<=itt->second){
			an+=itt->second-max(itt->first,last);
			last=itt->second;
		}
	}
//	cout<<yy<<" "<<an<<endl;
	return an;
}

ld simpson(ld l,ld r){
	ld mid=(l+r)/2.0;
	return (4*f(mid)+f(r)+f(l))*(r-l)/6.0;
}

ld ASR(ld l,ld r,ld EPS,ld ans,int dep=2){
	ld mid=(l+r)/2.0;
	ld l_=simpson(l,mid),r_=simpson(mid,r);
	if(fabs(l_+r_-ans)<EPS&&dep<0)return (l_+r_+ans)/2;
	return ASR(l,mid,EPS,l_,dep-1)+ASR(mid,r,EPS,r_,dep-1);
}
int main(){
	
	cin>>n;
	int cnt=0;
	for(int i=1;i<=n;i++){
		po buf;
		int tempx,tempy,tempm;
		cin>>tempx>>tempy>>tempm;
		buf.x=tempx;
		buf.y=tempy;
		a[i].push_back(buf);
		y[++cnt]=buf.y;
		buf.x=tempx+tempm;
		buf.y=tempy;
		a[i].push_back(buf);
		y[++cnt]=buf.y;
		buf.x=tempx;
		buf.y=tempy+tempm;
		a[i].push_back(buf);
		y[++cnt]=buf.y;
		sort(a[i].begin(),a[i].end(),cmp_y());
	}
	sort(y+1,y+cnt+1);
	cnt=unique(y+1,y+cnt+1)-y-1;
	ld anss=0;
	for(int i=1;i<cnt;i++){
		anss+=ASR(y[i],y[i+1],eps,simpson(y[i],y[i+1]));
	}
	cout<<fixed<<setprecision(1)<<anss;
    return 0;
}
```

但，你以为这真就完了？

### 一些注意事项/优化

上面那份代码吸氧都会 TLE，怎么办？

- 判断一个三角形是否完全包含于另一个三角形

- 不要在 `f` 函数内部排序，尽量调到外面先按类似于 `f` 函数的方式排序。

- 尽量卡精度

- 一些玄学优化，比如 `inline` 和 `register`，要选合适的编译语言等

这样就能 AC 了。

代码就不贴了。qwq

---


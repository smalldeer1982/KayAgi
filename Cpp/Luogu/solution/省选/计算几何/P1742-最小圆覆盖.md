# 最小圆覆盖

## 题目描述

给出 $N$ 个点，让你画一个最小的包含所有点的圆。

## 说明/提示

对于 $100\%$ 的数据，$1\leq N\leq 10^5$，$|x_i|,|y_i|\leq 10^4$。

2022.2.26 添加 spj

## 样例 #1

### 输入

```
6
8.0 9.0
4.0 7.5
1.0 2.0
5.1 8.7
9.0 2.0
4.5 1.0```

### 输出

```
5.0000000000
5.0000000000 5.0000000000```

# 题解

## 作者：Nemlit (赞：30)

## [原文地址](https://www.cnblogs.com/bcoier/p/10515731.html)

~~体验过$O(n^3)$过$10^5$吗？快来体验一波当$wys$的快感吧$QAQ$~~

## 前置芝士1：二元一次方程组求解

设
$$\begin{cases}a1 * x + b1*y=c1\\a2 * x + b2*y=c2\end{cases}$$
（其中$a1,a2,b1,b2,c1,c2$为已知量） 

由$②$式得：
$$x=\frac{c2-b2*y}{a2}$$

带入$①$式并化简得：
$$y=\frac{c1-\frac{a1*c2}{a2}}{b1-\frac{a1*b2}{a2}}$$

分子分母同时乘以$a2$得：
$$y=\frac{a2*c1-a1*c2}{a2*b1-a1*b2}$$

同理可得（把$a,b$互换即可）：
$$x=\frac{b2*c1-b1*c2}{b2*a1-b1*a2}$$

## 前置芝士2：三点定圆

给出三个点，求出圆心&半径


$$\begin{cases}x1^2-2x1*x0+x0^2+y1^2-2y1*y0+y0^2=r^2\\x2^2-2x2*x0+x0^2+y2^2-2y2*y0+y0^2=r^2\\x3^2-2x3*x0+x0^2+y3^2-2y3*y0+y0^2=r^2\end{cases}$$

$②-①$和$③-①$，并化简得：

$$\begin{cases}2*(x2-x1)x+2*(y2-y1)y=x2^2-x1^2+y2^2-y1^2\\2*(x3-x1)x+2*(y3-y1)y=x3^2-x1^2+y3^2-y1^2\end{cases}$$

我们将三点定圆的柿子对应二元一次方程组中，可知：

$$a1=x2-x1,\quad a2=x3-x1$$
$$b1=y2-y1,\quad b2=y3-y1$$
$$c1=\frac{x2^2-x1^2+y2^2-y1^2}{2},\quad c2=\frac{x3^2-x1^2+y3^2-y1^2}{2}$$

然后就可以根据三个点求出圆心和半径了

## 正文

跟据前置芝士，我们知道对于任意三个不共线的点，我们可以求出三点定的圆，所以一个明显的想法就是枚举三个点

我们先枚举第一个点，有两种情况

①：当前点在当前外面，即$dis($圆心,该点$)>r$那么我们不管这个点

②：不是情况①的情况，那么我们就需要重新构造这个圆来包含所有的点了

怎么构造呢？我们重新枚举两外两个已经遍历过的点，组成三个点。同理，若重新构造的圆包括了三个点，那么就不管，若有任意一个在圆外，那么我们根据前置芝士重新确定圆心和半径即可

PS：本题出题人过于~~duliu~~，故意构造数据卡掉了上述解法，所以我们需要一个神奇的东西：随$(da)$机$(luan)$增$(shu)$量$(ju)$法，来防止掉精度

代码如下：

```
#include<bits/stdc++.h>
using namespace std;
#define il inline
#define re register
#define D double
il int read()
{
    re int x = 0, f = 1; re char c = getchar();
    while(c < '0' || c > '9') { if(c == '-') f = -1; c = getchar();}
    while(c >= '0' && c <= '9') x = x * 10 + c - 48, c = getchar();
    return x * f;
}
#define rep(i, s, t) for(re int i = s; i <= t; ++ i)
#define eps 1e-12
#define maxn 100005
#define ff(x) (x) * (x)
int n, m;
D r;
struct node
{
	D x, y;
}o, e[maxn];
il D dis(node a, node b){return sqrt(ff(a.x - b.x) + ff(a.y - b.y));}
il void get(node a, node b, node c)
{
	D a1 = b.x - a.x, a2 = c.x - a.x, b1 = b.y - a.y, b2 = c.y - a.y;
	D c1 = (ff(b.x) - ff(a.x) + ff(b.y) - ff(a.y));
	D c2 = (ff(c.x) - ff(a.x) + ff(c.y) - ff(a.y));
	o = (node){(b2 * c1 - b1 * c2) / (b2 * a1 * 2 - b1 * a2 * 2), 
			   (a2 * c1 - a1 * c2) / (a2 * b1 * 2 - a1 * b2 * 2)};
	r = dis(a, o);
}
il void work()
{
	o = e[1], r = 0;
	rep(i, 2, n)
	{
		if(dis(o, e[i]) > r + eps)
		{
			o = e[i], r = 0;
			rep(j, 1, i - 1)
			{
				if(dis(o, e[j]) > r + eps)
				{
					o.x = (e[i].x + e[j].x) / 2, o.y = (e[i].y + e[j].y) / 2;
					r = dis(o, e[j]);
					rep(k, 1, j - 1) if(dis(o, e[k]) > r + eps) get(e[i], e[j], e[k]);
 				}
			}
		}
	//	printf("%.10lf\n%.10lf %.10lf\n", r, o.x, o.y);
	}
}
int main()
	n = read();
	rep(i, 1, n) scanf("%lf%lf", &e[i].x, &e[i].y);
    random_shuffle(e + 1, e + n + 1);
	work();
	printf("%.10lf\n%.10lf %.10lf", r, o.x, o.y);
	return 0;
}
```

---

## 作者：Ukraine (赞：22)

**这篇题解参考了[讨论](https://www.luogu.com.cn/discuss/436141)，并提供了较为详细的正确的证明。**

记 $\operatorname{circle}(S)$ 为点集 $S$ 的最小圆覆盖，$\operatorname{circum}(A,B,C)$ 为点 $A,B,C$ 的外接圆。

### 引理 1

> 在二维平面上有 $I,J,K,P$ 四个不同的点，那么以下两条互为充要条件：
> - $P$ 在 $\triangle IJK$ 外；
> - 存在 $N,M\in \{I,J,K\}$ 且 $N\neq M$，使得 $\operatorname{circle}(\{N,M,P\})$ 包含这四个点。

### 引理 2

> 对于点集 $S$，如果 $P\notin \operatorname{circle}(S)$，那么 $P$ 在 $\operatorname{circle}(S\cup \{P\})$ 上。

### 做法

我们考虑**随机增量法**：将点集随机打乱，从小到大枚举 $i$，如果 $p_i\in\operatorname{circle}(\{p_1,p_2,\dots,p_{i-1}\})$，那么前 $i$ 个点的最小圆覆盖仍然是 $\operatorname{circle}(\{p_1,p_2,\dots,p_{i-1}\})$。否则，根据引理，$p_i$ 一定在前 $i$ 个点的最小圆上。所以，我们需要找到 $j,k\in [1,i-1]$，使得 $\operatorname{circum}(p_k,p_j,p_i)$ 是前 $i$ 个点的最小圆覆盖。

再从小到大枚举 $1\le j<i$，如果 $j$ 不在当前的最小圆覆盖内，就先令当前最小圆为以 $p_ip_j$ 为直径的圆，并枚举 $1\le k<j$，并查看 $k$ 是否在当前的最小圆内，若不在则用 $\operatorname{circum}(p_k,p_j,p_i)$ 作为当前的最小圆。

但如何保证更新一个最小圆后，这个圆仍然能够覆盖所有 $1\dots i$ 的点？

假如原来的最小圆是 $\operatorname{circum}(p_k,p_j,p_i)(k<j<i)$，当最内层枚举了一个 $k<k'<j$，且 $k'$ 不在当前最小圆上时，我们可以保证：

- $i\notin \operatorname{circum}(p_k,p_{k'},p_j)$；
- $j\notin \operatorname{circum}(p_k,p_{k'},p_i)$；
- $k'\notin \operatorname{circum}(p_k,p_j,p_i)$。

根据引理，可以得到：

$$
k\in \operatorname{circum}(p_{k'},p_j,p_i).
$$

归纳后得证。复杂度证明可以参考其他题解。

[代码](https://www.luogu.com.cn/paste/k9so7hjs)。

### 求两直线交点

记两条直线的方向向量分别是 $\bm{d_1},\bm{d_2}$，直线上一点的向量分别是 $\overrightarrow{OP_1}=\bm{p_1},\overrightarrow{OP_2}=\bm{p_2}$。

设交点的向量 $\overrightarrow{OX}=\bm{p_1}+k\bm{d_1}$，那么 $(\overrightarrow{OX}-\bm{p_2})\times \bm{d_2}=0$。

拆开得：

$$k=\frac{(\bm{p_2}-\bm{p_1})\times \bm{d_2}}{\bm{d_1}\times \bm{d_2}}.$$

---

## 作者：neal9999 (赞：10)

这里给一个三角形求外心的矩阵方法

假设我们有三个点 $(x_1, y_1), (x_2, y_2), (x_3, y_3)$

和外接圆上的任意一个点 $(x, y)$

假设圆的方程是 $a(x^2+y^2)+bx+cy+d=0$

我们有

$$
\begin{aligned}
a(x^2+y^2)+bx+cy+d=0 \\
a(x_1^2+y_1^2)+bx_1+cy_1+d=0 \\
a(x_2^2+y_2^2)+bx_2+cy_2+d=0 \\
a(x_3^2+y_3^2)+bx_3+cy_3+d=0 \\
\end{aligned}
$$

写成矩阵

$$
\begin{bmatrix}
x^2+y^2 & x & y & 1 \\
x_1^2+y_1^2 & x_1 & y_1 & 1 \\
x_2^2+y_2^2 & x_2 & y_2 & 1 \\
x_3^2+y_3^2 & x_3 & y_3 & 1 \\
\end{bmatrix}
\begin{bmatrix}
a\\
b\\
c\\
d\\
\end{bmatrix}=0
$$

把他看成是关于 $(a,b,c,d)$ 的四元方程组。

显然，$(a,b,c,d)$ 的解不唯一（可以任乘一个常数），于是左边系数矩阵行列式为0。

$$
\begin{vmatrix}
x^2+y^2 & x & y & 1 \\
x_1^2+y_1^2 & x_1 & y_1 & 1 \\
x_2^2+y_2^2 & x_2 & y_2 & 1 \\
x_3^2+y_3^2 & x_3 & y_3 & 1 \\
\end{vmatrix}=0
$$

这就是外接圆的方程。下面求圆心坐标

按第一行展开，有

$$
(x^2+y^2)\begin{vmatrix}
x_1 & y_1 & 1 \\
x_2 & y_2 & 1 \\
x_3 & y_3 & 1 \\
\end{vmatrix} - x\begin{vmatrix}
x_1^2+y_1^2 & y_1 & 1 \\
x_2^2+y_2^2 & y_2 & 1 \\
x_3^2+y_3^2 & y_3 & 1 \\
\end{vmatrix} + y\begin{vmatrix}
x_1^2+y_1^2 & x_1 & 1 \\
x_2^2+y_2^2 & x_2 & 1 \\
x_3^2+y_3^2 & x_3 & 1 \\
\end{vmatrix} - \begin{vmatrix}
x_1^2+y_1^2 & x_1 & y_1 \\
x_2^2+y_2^2 & x_2 & y_2 \\
x_3^2+y_3^2 & x_3 & y_3 \\
\end{vmatrix}=0
$$

配方一下就有
$$
O_x = \frac{\begin{vmatrix}
x_1^2+y_1^2 & y_1 & 1 \\
x_2^2+y_2^2 & y_2 & 1 \\
x_3^2+y_3^2 & y_3 & 1 \\
\end{vmatrix}}{2\begin{vmatrix}
x_1 & y_1 & 1 \\
x_2 & y_2 & 1 \\
x_3 & y_3 & 1 \\
\end{vmatrix}}
$$
$$
O_y = - \frac{\begin{vmatrix}
x_1^2+y_1^2 & x_1 & 1 \\
x_2^2+y_2^2 & x_2 & 1 \\
x_3^2+y_3^2 & x_3 & 1 \\
\end{vmatrix}}{2\begin{vmatrix}
x_1 & y_1 & 1 \\
x_2 & y_2 & 1 \\
x_3 & y_3 & 1 \\
\end{vmatrix}}
$$

至此我们得到了外心的坐标

---

## 作者：TimeTraveller (赞：9)

一道模板题吧，~~WA了好久~~  

开始以为是 **凸包+旋转卡壳+等等** 结果才发现有错。
~~果然模板不可以乱yy~~

正解:
### 随机增量法
一看名字就知道，先要把输入的点打乱，使其随机化，作用就是降低复杂度，后面讲。


然后就是从第一个点开始枚举点$i$，如果当前的枚举的点在圆内部，就继续不用管，否者就以该点为圆心半径为0开始枚举$i$前面的点$j$，如果前面的点在当前圆的外面就取点$i$和点$j$的中点为圆心，距离的一半为半径，以这个圆再枚举$j$前面的点$k$，然后如果点$k$在圆外就以$i,j,k$三点组成的三角形的外切圆来更新当前的圆。

通过以上操作，因为每次都更新较大的圆，而且答案必定有两个或以上的点在圆上(只有一个点除外)，所以保证了正确性，看似$O(n^3)$其实只有仅仅$O(n)$的复杂度，因为打乱后复杂度平摊下来只有$O(n)，证明的具体过程去百度搜吧，~~应该都比我讲的清楚~~。

其实还有一道几乎~~应该就是~~一样的题，P2533 [AHOI2012]信号塔，这里面的题解有证明。

下面直接上代码

~~~cpp

#include<cmath>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define db double
const int M=1e5+1;
using namespace std;
const db eps=1e-10;
db dcmp(db x){if(fabs(x)<eps) return 0;return x;}
int n;
struct point{
	db x,y;
	point(db a=0,db b=0):x(a),y(b){}
	void in(){scanf("%lf%lf",&x,&y);}
}pp[M];

point operator +(point a,point b){return point(a.x+b.x,a.y+b.y);}
point operator -(point a,point b){return point(a.x-b.x,a.y-b.y);}
point operator *(point a,db    b){return point(a.x*b  ,a.y*b  );}
point operator /(point a,db    b){return point(a.x/b  ,a.y/b  );}

db cross(point a,point b){return a.x*b.y-a.y*b.x;}
db dot  (point a,point b){return a.x*b.x+a.y*b.y;}

double dis(point a,point b)
{return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));}

point getmid(point a,point b){return point((a.x+b.x)/2,(a.y+b.y)/2);}
point rotate(point a){return point(-a.y,a.x);}


struct circle{
	point o;db r;
	circle(){}
	circle(point a,db r):o(a),r(r){}
};
struct triangle{
	point t1,t2,t3;
	circle cir2(){
		db Bx = t2.x-t1.x, By = t2.y-t1.y;
  		db Cx = t3.x-t1.x, Cy = t3.y-t1.y;
  		db D = 2*(Bx*Cy-By*Cx);
  		db cx = (Cy*(Bx*Bx+By*By) - By*(Cx*Cx+Cy*Cy))/D + t1.x;
  		db cy = (Bx*(Cx*Cx+Cy*Cy) - Cx*(Bx*Bx+By*By))/D + t1.y;
  		point p = point(cx, cy);
  		return circle(p, dis(t1,p));
	}//数学方法求外心
	triangle(){}
	triangle(point a,point b,point c):t1(a),t2(b),t3(c){}
};
circle circlein(point t1,point t2,point t3){
		point v1=t2-t1,v2=t1-t3;v1=rotate(v1),v2=rotate(v2);
		point p1=getmid(t1,t2),p2=getmid(t1,t3);point u=p1-p2;
		db t=cross(v2,u)/cross(v1,v2);
		point oo=p1+v1*t;
		return circle(oo,dcmp(dis(oo,t1)));
}几何方法求外心，三角形两边中垂线交点
void work(){
	circle ans;
	ans.o=pp[1];ans.r=0;
	for(int i=2;i<=n;i++){
		if(dis(pp[i],ans.o)>ans.r+eps){
			ans=circle(pp[i],0);
			for(int j=1;j<i;j++){
				if(dis(pp[j],ans.o)>ans.r+eps){
					ans.o=getmid(pp[i],pp[j]);
					ans.r=dis(pp[j],pp[i])/2;
					for(int k=1;k<j;k++){
						if(dis(pp[k],ans.o)>ans.r+eps){
							ans=circlein(pp[i],pp[j],pp[k]);
						}
					}
				}
			}
		}
	}
	printf("%.10lf\n%.10lf %.10lf\n",ans.r,ans.o.x,ans.o.y);
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)pp[i].in();
	random_shuffle(pp+1,pp+n+1);//记得打乱
    //不打乱的话会被卡复杂度和精度，蒟蒻我被卡了十几次90分。
	work();
	return 0;
}
~~~

Fighting Everyday！

---

## 作者：Mr_Skirt (赞：8)

给你平面上$n(n\leq 10^5)$个点，求覆盖所有点的最小圆。

# 解题思路
最小圆覆盖：Welzl's 算法。

在介绍这个算法之前，我们先考虑最暴力的算法，就是枚举三个点，然后计算其外接圆，判断能否覆盖所有点取最小半径的那个即可，此外我们还要枚举两点围成的圆，他们也有可能是答案，时间复杂度 $O(n^4)$。因为我们枚举了组成圆的所有可能性，所以这个算法是正确的。

显然这个方法时间复杂度太高了，我们通过观察可以发现，假设我们知道前 $i$ 个点的最小覆盖圆，那么如果第 $i+1$ 个点不在之前的最小覆盖圆上，那么覆盖前 $i+1$ 个点的圆的边界必定包含第 $i+1$ 个点。

根据这个结论可以推出，假如我们能够根据之前的点计算出3个必在边界上的点，那么覆盖这三个点的最小圆必然是覆盖之前所有点集的最小覆盖圆。

Welzl's 算法就是根据这个结论实现的，我们考虑递归的进行这个过程：
1. 假设我们已经得到前$i$个点的最小覆盖圆 $C$，对于点 $i+1$ 来说，如果它在 $C$ 内部，那么我们就忽略这个点。
2. 否则，我们知道点 $i+1$ 必在边界上，把点 $i+1$ 加入边界列表，然后重新求出带有边界列表的最小覆盖圆。

伪代码如下
```cpp
// x 代表前面的点集数量，R是边界列表
Circle solve(int x, vector<int> R){
    // 如果前面没有点了，或者边界点的数量等于3了，就直接暴力求边界点的最小覆盖圆
    if(R.size() == 3 || x == 0){
        return minCircle(R);
    }

    // 求出前面点的最小覆盖圆
    Circle c = solve(x - 1, R);
    // 如果点不在之前的最小覆盖圆上
    if(!c.test(x)){
        R.push_back(x);
        // 求出带有 x 的最小覆盖圆
        solve(x + 1, R);
    }
}
```

那么它的复杂度如何呢？我们知道，如果 $R$ 的数量为3，或者已经用完所有点集，我们就可以立即得出最小覆盖圆，否则我们有可能需要重新计算最小覆盖圆，那么在最坏情况下我们对于每个点要重复计算3轮，状态空间为 $(x, 3)$，复杂度为 $O(n^3)$。

但是，如果我们主动打乱点集的顺序，就可以做到期望$O(n)$的时间复杂度。
这个结论如何推出来的呢？设 $f(n, i)$ 为调用这个函数在$n$个点上，且边界点数量为 $i$ 的期望步数，假设随机打乱输入点，那么显然有
$$
\begin{aligned}
f(n, i) &= 1 + f(n - 1, i) + P(p_n \notin C_{n-1}) \times f(n - 1, i + 1)\\\\
f(n, 3) &= O(1) 
\end{aligned}
$$
问题的关键在于如何求出 $P(p_n \notin C_{n-1})$，也就是新的点不在之前点集的最小覆盖圆内的概率。假设我们已经知道$n$个点的最小覆盖圆$C_n$，那么如果前 $n-1$ 个点的最小覆盖圆 $C_{n-1}$ 和 $C_n$ 不同，那么第 $n$ 个点必须是 $C_n$ 的边界，这样的点最多有3个，所以随机选一个点能选到边界的概率只有 $\frac{3}{n}$。所以 $P(p_n \notin C_{n-1}) = \frac{3}{n}$，然后就有
$$
\begin{aligned}
f(n, 0) &= 1 + f(n - 1, 0) + \frac{3f(n - 1, 1)}{n}\\\\
f(n, 1) &= 1 + f(n - 1, 1) + \frac{3f(n - 1, 2)}{n}\\\\
f(n, 2) &= 1 + f(n - 1, 2) + \frac{3f(n - 1, 3)}{n}\\\\
f(n, 3) &= O(1)
\end{aligned}
$$
逆序解出
$$
\begin{aligned}
f(n, 2) &= 1 + f(n - 1, 2) + \frac{3}{n}\\\\
f(n, 2) &= O(n)\\\\
f(n, 1) &= 1 + f(n - 1, 1) + \frac{3n}{n}\\\\
f(n, 1) &= O(n)\\\\
f(n, 0) &= 1 + f(n - 1, 0) + \frac{3n}{n}\\\\
f(n, 0) &= O(n)\\\\
\end{aligned}
$$

Welzl 算法的原论文出自[Smallest enclosing disks (balls and ellipsoids)](https://www.stsci.edu/~RAB/Backup%20Oct%2022%202011/f_3_CalculationForWFIRSTML/Bob1.pdf)。

参考代码
```cpp
Circle MCC(int x, std::vector<int> R) {
    // 这部分是终止条件，暴力求出边界点的最小覆盖圆
    if (R.size() == 3 || !x) {
        if (R.empty())
            return Circle(Vector2(0, 0), 0);
        else if (R.size() == 1) {
            return Circle(P[R[0]], 0);
        } else if (R.size() == 2) {
            return Circle((P[R[0]] + P[R[1]]) * 0.5,
                          (P[R[0]] - P[R[1]]).lengthSq() * 0.25);
        } else {
            for (int i = 0; i < 3; i++) {
                for (int j = i + 1; j < 3; j++) {
                    auto c = Circle((P[R[i]] + P[R[j]]) * 0.5,
                                    (P[R[i]] - P[R[j]]).lengthSq() * 0.25);
                    bool can = true;
                    for (int k = 0; k < 3; k++) {
                        if (!c.test(P[R[k]])) {
                            can = false;
                            break;
                        }
                    }
                    if (can) return c;
                }
            }
            return getCircumscribedCircle(P[R[0]], P[R[1]], P[R[2]]);
        }
    }
    Circle c = MCC(x - 1, R);
    if (!c.test(P[x - 1])) {
        R.push_back(x - 1);
        c = MCC(x - 1, R);
    }
    return c;
}

void solve() {
    scanf("%d", &n);
    for (int i = 0; i < n; i++) {
        double x, y;
        scanf("%lf%lf", &x, &y);
        P.push_back(Vector2(x, y));
    }
    // 随机打乱输入点
    std::random_shuffle(P.begin(), P.end(), [](int x) { return mt() % x; });
    std::vector<int> R;
    Circle c = MCC(n, R);
    printf("%.10lf\n", std::sqrt(c.r2));
    printf("%.10lf %.10lf\n", c.center.x, c.center.y);
}

```

---

## 作者：hl666 (赞：6)

看到楼下大佬写的都是**计算几何**的玄学操作，那我来讲一下**解析几何**的方法好了。

首先算法大体就是一般的**随机增量法**，我们先把点全部打乱然后用同样的方法添加即可。

但是在求三点确定圆的圆心时，很多人都是做三角形的外心来搞的（但是我对计算几何~~一无所知~~）然后只好用最一般的**列方程求解**来搞。

我们知道圆的公式：

>$x^2+y^2=r^2$

所以我们可以列三元二次方程直接暴力求解~~虽然有精度误差但是你要坚信你是欧皇~~

具体的解方程的过程可以看[这里超详细的解法](https://blog.csdn.net/liyuanbhu/article/details/52891868)

然后就可以轻松水过了。

CODE

```
#include<cstdio>
#include<algorithm>
#include<cmath>
using namespace std;
typedef double DB;
const int N=100005;
struct node
{
    DB x,y;
}a[N],O;
int n;
DB r;
inline DB power(DB x)
{
    return x*x;
}
inline DB dis(node a,node b)
{
    return sqrt(power(a.x-b.x)+power(a.y-b.y));
}
inline bool in_circle(node a)
{
    return dis(a,O)<=r?1:0;
}
inline int calc(DB a,DB b,DB c,DB d,DB e,DB f)
{
    O.x=(b*f-d*e)/(b*c-a*d);
    O.y=(c*e-a*f)/(b*c-a*d);
}
inline void min_cover_circle(void)
{
    register int i,j,k;
    random_shuffle(a+1,a+n+1);
    for (i=1;i<=n;++i)
    if (!in_circle(a[i]))
    {
        O=a[i]; r=0;
        for (j=1;j<i;++j)
        if (!in_circle(a[j]))
        {
            O.x=(a[i].x+a[j].x)/2.0; O.y=(a[i].y+a[j].y)/2.0; r=dis(a[i],O);
            for (k=1;k<j;++k)
            if (!in_circle(a[k])) calc(a[i].x-a[j].x,a[i].y-a[j].y,a[i].x-a[k].x,a[i].y-a[k].y,
            ((power(a[i].x)-power(a[j].x))-(power(a[j].y)-power(a[i].y)))/2.0,
            ((power(a[i].x)-power(a[k].x))-(power(a[k].y)-power(a[i].y)))/2.0),r=dis(a[i],O);
        }
    }
    printf("%.10lf\n%.10lf %.10lf",r,O.x,O.y);
}
int main()
{
    register int i; scanf("%d",&n);
    for (i=1;i<=n;++i)
    scanf("%lf%lf",&a[i].x,&a[i].y);
    min_cover_circle();
    return 0;
}
```

---

## 作者：juju527 (赞：5)

### 计算几何

#### 前置知识：外接圆的求法

在初中我们就学过三点确定一个圆

这里我们首先考虑一下怎么求三角形的外接圆

我们考虑暴力解方程即可

利用圆的方程$(x_1-x)^2+(y_2-y)^2=r^2$

我们将三个点分别代进去可以得到三个方程

然后乱搞一下就能把x，y解出来了

这里给个式子

$x=\frac{(x_2^2+y_2^2-x_1^2-y_1^2)(y_3-y_1)-(x_3^2+y_3^2-x_1^2-y_1^2)(y_2-y_1)}{2(x_2-x_1)(y_3-y_1)-2(x_3-x_1)(y_2-y_1)}$

$y=\frac{(x_2^2+y_2^2-x_1^2-y_1^2)(x_3-x_1)-(x_3^2+y_3^2-x_1^2-y_1^2)(x_2-x_1)}{2(y_2-y_1)(x_3-x_1)-2(y_3-y_1)(x_2-x_1)}$

我们就把外心坐标求出来了

---
#### 具体做法
我们考虑暴力来解决这个问题

我们考虑假如我们已经有了i个点的最小圆覆盖

加入第i+1个点有两种情况

在圆内自然不要管

不在圆内，则该点一定在这i+1个点组成的最小圆覆盖上

因为前i个的最小圆覆盖并不包括第i+1个点

想要最小，圆一定过第i+1个点

接下来我们去枚举1~i-1的点j看点j是否能在目前构造出的1~i的最小圆覆盖内

不在，那么同上，点j一定在最小圆覆盖上

i与j构成一个新圆

接着枚举1~j-1的点k看点k是否在目前的1~i的最小圆覆盖内

不在，那么点k一定在最小圆覆盖上

三点确定一个圆，i，j，k的外接圆就是新的最小圆覆盖

为什么是正确的，由于三个点确定一个圆

而目前我们i，j，k都确定在目前1~i的最小圆覆盖上

那么这个圆就是最小圆覆盖

当k继续变大成l再一次不在这个圆内时

此时i，j，l三点一定在最小圆覆盖中，且小于l的点一定也在圆中

j的变大同理

---
#### 时间复杂度证明
迷惑了！

$n^3$过100000吗

当然不是

由于三点确定一个圆

**对于一个随机的序列，i个点每一个点有$\frac{3}{i}$的概率成为更新这些点的最小圆覆盖的点**

注意，这里并不是$\frac{3}{i}$的概率在圆上

因为影响我们复杂度的是它需要更新最小圆覆盖

那么对于进入第二重循环的if的概率应该是$\frac{3}{j}$

那么第三重循环执行次数的期望应该是$\frac{3}{j}*j=3$

这是一个常数

那么第二重循环的总复杂度即为$O(i)$

对于进入第一重循环的if的概率同理，是$\frac{3}{i}$

那么进入if后的复杂度是$O(\frac{3}{i}*i)=O(1)$

故总期望复杂度为$O(n)$

**注意上面的分析均为期望复杂度，故我们需要把点的顺序自己打乱，以免被卡**

random_shuffle一下即可

---

#### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=100005;
const double eps=1e-12;
struct point{
	double x,y;
}a[maxn];
int read(){
	int x=0,y=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')y=-1;ch=getchar();}
	while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+(ch^48),ch=getchar();
	return x*y;
}
double dis(point p,point q){
	double x=p.x-q.x,y=p.y-q.y;
	return sqrt(x*x+y*y);
}
point circle_center(point a,point b,point c){
	double x1=a.x,x2=b.x,x3=c.x;
	double y1=a.y,y2=b.y,y3=c.y;
	double A=x1*x1+y1*y1,B=x2*x2+y2*y2,C=x3*x3+y3*y3;
	double u1=x1-x2,u2=x1-x3,u3=x2-x3;
	double v1=y1-y2,v2=y1-y3,v3=y2-y3;
	point o;
	o.y=((C-A)*u1-(B-A)*u2)/(2*v1*u2-2*v2*u1);
	o.x=((C-A)*v1-(B-A)*v2)/(2*u1*v2-2*u2*v1);
	return o;
}
int main(){
	int n;
	n=read();
	for(int i=1;i<=n;i++)
		scanf("%lf%lf",&a[i].x,&a[i].y);
	random_shuffle(a+1,a+n+1);
	point o=a[1];
	double r=0;
	for(int i=2;i<=n;i++){
		if(dis(o,a[i])-r>eps){
			o=a[i];r=0;
			for(int j=1;j<i;j++){
				if(dis(o,a[j])-r>eps){
					o.x=(a[i].x+a[j].x)/2;
					o.y=(a[i].y+a[j].y)/2;
					r=dis(o,a[j]);
					for(int k=1;k<j;k++){
						if(dis(o,a[k])-r>eps){
							o=circle_center(a[i],a[j],a[k]);
							r=dis(o,a[k]);
						}
					}
				}
			}
		}
	}
	printf("%.10lf\n%.10lf %.10lf",r,o.x,o.y);
	return 0;
}

```

---

## 作者：muller (赞：4)

给出平面上 N 个点,N<=10^6，请求出一个半径最小的圆覆盖住所有的点，并求出该点的坐标与半径。

即经典的最小圆覆盖问题，在此我们介绍随机增量法：

随机增量法是一个可以在 期望O(n) 时间内求出最小圆覆盖的算法，首先它的算法流程是这样的

枚举第一个点 ii，若不在目前圆内，设它为圆心

枚举第二个点 jj，若不在当前圆内，设当前圆为以 i,ji,j 为直径的圆

枚举第三个点 kk，若不在当前圆内，设当前圆为 i,j,ki,j,k 的外接圆

正确性

显然最优解一定是两个点为直径的圆或者一个三角形的外接圆，否则肯定能缩的更小。那么这么枚举的正确性是比较显然的了

时间复杂度
这是一个重点，这么做看似是O(n^3)的，不过对于随机顺序的点，是可以期望 O(n)的。

但我可能不会证明！qwq

代码：

```cpp
// luogu-judger-enable-o2
#include <bits/stdc++.h>
using namespace std;
const int N = 100005;
const double eps = 1e-8;
struct Point {
	double x, y;
} a[N], O;
double R;
double sqr(double x) {return x * x;}
double dis(Point a, Point b) {return sqrt(sqr(a.x - b.x) + sqr(a.y - b.y));}
void work(Point p1, Point p2, Point p3) {
	double a, b, c, d, e, f;
	a = p2.y - p1.y; b = p3.y - p1.y; c = p2.x - p1.x; d = p3.x - p1.x;
	f = p3.x * p3.x + p3.y * p3.y - p1.x * p1.x - p1.y * p1.y;
    e = p2.x * p2.x + p2.y * p2.y - p1.x * p1.x - p1.y * p1.y;
    O.x = (a * f - b * e) / (2 * a * d - 2 * b * c); O.y = (d * e - c * f) / (2 * a * d - 2 * b * c);
    R = dis(O, p1);
}
int main() {
	int n, i, j, k;
	scanf("%d", &n);
	for (i = 1; i <= n; ++i) scanf("%lf%lf", &a[i].x, &a[i].y);
	random_shuffle(a + 1, a + n + 1);
	O = a[1]; R = 0;
	for (i = 2; i <= n; ++i)
		if (dis(a[i], O) > R + eps) {
			O = a[i]; R = 0;
			for (j = 1; j < i; ++j)
				if (dis(a[j], O) > R + eps) {
					O.x = (a[i].x + a[j].x) / 2; O.y = (a[i].y + a[j].y) / 2; R = dis(a[j], O);
					for (k = 1; k < j; ++k) if (dis(a[k], O) > R + eps) work(a[i], a[j], a[k]);
				}
		}
	printf("%.10lf\n%.10lf %.10lf\n", R, O.x, O.y);
	return 0;
}

```


---

## 作者：zlb1999 (赞：2)

花了接近半天时间终于弄懂了最小圆覆盖的原理，分享一下。

题解主要基于以下三条原理。

P1至Pn为题中的点序列。
1.设Ci-1为前i-1个点的最小覆盖圆，若Pi在Ci-1内，则Ci=Ci-1，否则，Pi在Ci上。

2.设C'(j-1,i)为过Pi的前j-1个点的最小覆盖圆，若Pj在C'(j-1,i)内，则C'(j,i)=C'(j-1,i),否则，Pj在C'(j,i)上；

3..设C''(k-1,i,j)为过Pi,Pj的前k-1个点的最小覆盖圆，若Pk在C''(k-1,i,j)内，则C''(k,i,j)=C'(k-1,i,j),否则，Pk在C''(k,i,j)上；

反证法易证上述三条是正确的。

又，圆上三个不同的点足以确定这个圆。容易得出如下算法。

设get1（ i）求前i个点的最小覆盖圆，

get2（i，tag1），求过tag1的前i个点的最小覆盖圆。

get3（i,tag1,tag2）,求过tag1，tag2的前i个点的最小覆盖圆。

```cpp
cir get3(ll q,ll tag1,ll tag2)
{
    point tmp; cir tmpc;
    if(q==1)
    {
        tmp={(p[tag1].x+p[tag2].x)/2,(p[tag1].y+p[tag2].y)/2};
        tmpc={tmp,dis(p[tag1],p[tag2])/2};
        if(dis(tmpc.po,p[1])<tmpc.r||cmp(dis(tmpc.po,p[1]),tmpc.r))
        return tmpc;

        tmp=geto(p[1],p[tag1],p[tag2]);
        tmpc={tmp,dis(p[1],tmp)};
        return tmpc;
    }
    cir pre=get3(q-1,tag1,tag2);
    if(dis(pre.po,p[q])<pre.r||cmp(dis(pre.po,p[q]),pre.r))
        return pre;
    tmp=geto(p[q],p[tag1],p[tag2]);
    tmpc={tmp,dis(p[q],tmp)};
    return tmpc;
}

cir get2(ll q,ll tag1)
{
    point tmp; cir tmpc;
    if(q==1)
    {
        tmp={(p[1].x+p[tag1].x)/2,(p[1].y+p[tag1].y)/2};
        tmpc=(cir){tmp,dis(p[1],p[tag1])/2};
        return tmpc;
    }
    cir pre=get2(q-1,tag1);
    if(dis(pre.po,p[q])<pre.r||cmp(dis(pre.po,p[q]),pre.r))
        return pre;
    return get3(q-1,q,tag1);
}

cir get1(ll q)
{
    if(q==1)
    return (cir){p[1],0};

    cir pre=get1(q-1);
    if(dis(pre.po,p[q])<pre.r||cmp(dis(pre.po,p[q]),pre.r))
        return pre;
    return get2(q-1,q);
}
```
递归改递推就是常见的三重循环形式


---


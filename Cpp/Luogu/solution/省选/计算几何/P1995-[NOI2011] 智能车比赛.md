# [NOI2011] 智能车比赛

## 题目描述

新一届智能车大赛在 JL 大学开始啦！比赛赛道可以看作是由 $n$ 个矩形区域拼接而成（如下图所示），每个矩形的边都平行于坐标轴，第 $i$ 个矩形区域的左下角和右上角坐标分别为 $(x_{i,1},y_{i,1})$ 和 $(x_{i,2},y_{i,2})$。

题目保证：$x_{i,1}<x_{i,2}=x_{i+1,1}$，且 $y_{i,1}< y_{i,2}$，相邻两个矩形一定有重叠在一起的边（如图中虚线所示），智能车可以通过这部分穿梭于矩形区域之间。

![](https://cdn.luogu.com.cn/upload/image_hosting/hu6cu53o.png)

选手们需要在最快的时间内让自己设计的智能车从一个给定的起点 $S$ 点到达一个给定的终点 $T$ 点，且智能车不能跑出赛道。假定智能车的速度恒为 $v$ 且转向不消耗任何时间，你能算出最快需要多少时间完成比赛么？


## 说明/提示

![](https://cdn.luogu.com.cn/upload/image_hosting/m6t1j6pf.png)

## 样例 #1

### 输入

```
2  
1 1 2 2  
2 0 3 4  
1 1  
3 0  
1.0 ```

### 输出

```
2.41421356```

# 题解

## 作者：Infinite_Eternity (赞：11)

# Description

[P1995 [NOI2011] 智能车比赛](https://www.luogu.com.cn/problem/P1995)

给定 $n$ 个矩形区域，每个矩形的边都平行于坐标轴，第 $i$ 个矩形区域的左下角和右上角坐标分别为 $(x_{i,1},y_{i,1})$ 和 $(x_{i,2},y_{i,2})$。给定起点 $S$，终点 $T$，速度 $v$，求：从起点 $S$ 到终点 $T$ 的最短时间为多少。

数据范围：$n \leq 2 \times 10^3$，$|x_{i,1}|,| y_{i,1}|, |x_{i,2}|,|y_{i,2}| \leq 4 \times 10^4$

# Analysis

~~看很多大佬的解法都是 dp，但好像都被 Hack 了（？~~

- ~~[Hack 第一篇题解](https://www.luogu.com.cn/discuss/544413)~~
- ~~[Hack 第二篇题解](https://www.luogu.com.cn/discuss/544421)~~
- ~~[Hack 第三篇题解](https://www.luogu.com.cn/discuss/544423)~~
- ~~[Hack 第四篇题解](https://www.luogu.com.cn/discuss/544430)~~
- ~~[Hack 第五篇题解](https://www.luogu.com.cn/discuss/544436)~~

------------

我的做法是：构图 $+$ SPFA。

首先，我们要找到**关键点**。**关键点**包括起点，终点，和相邻矩形接触线段的上端点和下端点（如下图，有红色圈住的点即为**关键点**）。

![](https://cdn.luogu.com.cn/upload/image_hosting/ufe91jtd.png)

接下来，我们要做的就是在这些关键点之间连边。

我们把这些关键的点拿出来：

![](https://cdn.luogu.com.cn/upload/image_hosting/co6g8qf5.png)

不难发现，其实就是一些竖直的线段。

除了起点 $S$ 和终点 $T$ 外，从左到右或者从右到左穿过线段所在的直线，必须在线段中穿过去，也就是说有个上边界和下边界。

下图是起点 $S$ 到第 $4$ 条竖直的线段的上边界 $l_1$ 和下边界 $l_2$。

![](https://cdn.luogu.com.cn/upload/image_hosting/jr6ixlpf.png)

然后，我们先按 $x$ 坐标**从小到大**排序，枚举边的起点，向左或者向右连边，如果遇到竖直的线段，用叉积更改上下边界即可。

最后，构好图就直接 SPFA 即可。


# Code

> 码风不怎么好看，不喜勿喷。

```cpp
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<cstring>

using namespace std;

const int maxN=2000;
const double INF=1e15;
const double EPS=1e-9;

inline int dblcmp(double x)
{
    if (abs(x)<EPS)return 0;
    return x>0?1:-1;
}
inline double sqr(double x)
{
    return x*x;
}

struct Tpoint
{
    double x,y;
    inline Tpoint() {}
    inline Tpoint(double _x,double _y)
    {
        x=_x;
        y=_y;
    }
};

inline double dis(Tpoint a,Tpoint b)
{
    return sqrt(sqr(a.x-b.x)+sqr(a.y-b.y));
}
inline double det(Tpoint p0,Tpoint p1,Tpoint p2)
{
    return (p1.x-p0.x)*(p2.y-p0.y)-(p1.y-p0.y)*(p2.x-p0.x);
}

int N;
Tpoint square[maxN+100][2];
Tpoint a[maxN+100][2];
int id[maxN+100][2],cnt;
int now,info[2*maxN+100];
struct Tedge
{
    int v,next;
    double dis;
} edge[2*maxN*2*maxN+1000];
double ans,v;
Tpoint S,T;
int eS,eT,idS,idT;

inline void addedge(int u,int v,double dis)
{
    now++;
    edge[now].v=v;
    edge[now].dis=abs(dis);
    edge[now].next=info[u];
    info[u]=now;
}

inline void solve(Tpoint s,int num,int l)
{
    if (num!=idS && num!=idT && num%2==0)
    {
        addedge(num,num+1,dis(a[l][0],a[l][1]));
        addedge(num+1,num,dis(a[l][0],a[l][1]));
    }
    Tpoint low,high,t1,t2;
    bool flag=0;
    for(int i=l-1; i>=1; --i)
    {
        if (!flag && (id[i][0]==idS || id[i][0]==idT))
        {
            addedge(num,id[i][0],dis(s,a[i][0]));
            addedge(id[i][0],num,dis(s,a[i][0]));
            continue;
        }
        if (!flag)
        {
            addedge(num,id[i][0],dis(s,a[i][0]));
            addedge(id[i][0],num,dis(s,a[i][0]));
            addedge(num,id[i][1],dis(s,a[i][1]));
            addedge(id[i][1],num,dis(s,a[i][1]));
            low=a[i][0];
            high=a[i][1];
            flag=1;
            continue;
        }
        t1=a[i][0];
        t2=a[i][1];
        if ( dblcmp(det(s,low,t1))<=0 && dblcmp(det(s,high,t1))>=0 )
        {
            addedge(num,id[i][0],dis(s,a[i][0]));
            addedge(id[i][0],num,dis(s,a[i][0]));
        }
        if ( dblcmp(det(s,low,t2))<=0 && dblcmp(det(s,high,t2))>=0 )
        {
            addedge(num,id[i][1],dis(s,a[i][1]));
            addedge(id[i][1],num,dis(s,a[i][1]));
        }
        if (id[i][0]!=idS && id[i][0]!=idT)
        {
            if ( dblcmp( det(s,low,t2) ) == 1 ) break;
            if ( dblcmp( det(s,high,t1)) == -1 ) break;
            if ( dblcmp( det(s,low,t1) ) == -1 ) low=t1;
            if ( dblcmp( det(s,high,t2))== 1 ) high=t2;
        }
    }
}

int head,tail,queue[7*2*maxN+100];
bool vis[2*maxN+100];
double f[2*maxN+100];
inline double SPFA()
{
    int S=idS,T=idT;
    for(int i=1; i<=cnt; ++i) f[i]=INF;
    queue[head=tail=0]=S;
    f[S]=0.0;
    vis[S]=1;
    while(head<=tail)
    {
        int u=queue[(head++)%(7*2*maxN+100)],v,i;
        double dis;
        vis[u]=0;
        for(i=info[u],v=edge[i].v,dis=edge[i].dis; i!=-1; i=edge[i].next,v=edge[i].v,dis=edge[i].dis)
            if ( dblcmp(dis+f[u]-f[v])==-1 )
            {
                f[v]=dis+f[u];
                if (!vis[v])
                {
                    vis[v]=1;
                    queue[(++tail)%(7*2*maxN+100)]=v;
                    if ( dblcmp(f[queue[head%(7*2*maxN+100)]]-f[queue[tail%(7*2*maxN+100)]])==1 ) swap(queue[tail%(7*2*maxN+100)],queue[head%(7*2*maxN+100)]);
                }
            }
    }
    return abs(f[T]);
}

int main()
{
    //freopen("car.in","r",stdin);
    //freopen("car.out","w",stdout);
    scanf("%d\n",&N);
    for(int i=1; i<=N; ++i)scanf("%lf%lf%lf%lf\n",&square[i][0].x,&square[i][0].y,&square[i][1].x,&square[i][1].y);
    scanf("%lf%lf\n",&S.x,&S.y);
    for(int i=1; i<=N; ++i)
        if (dblcmp(square[i][0].x-S.x)<=0 && dblcmp(S.x-square[i][1].x)<=0 && dblcmp(square[i][0].y-S.y)<=0 && dblcmp(S.y-square[i][1].y)<=0)
        {
            eS=i;
            break;
        }
    scanf("%lf%lf\n",&T.x,&T.y);
    for(int i=1; i<=N; ++i)
        if (dblcmp(square[i][0].x-T.x)<=0 && dblcmp(T.x-square[i][1].x)<=0 && dblcmp(square[i][0].y-T.y)<=0 && dblcmp(T.y-square[i][1].y)<=0)
        {
            eT=i;
            break;
        }
    int g=N;
    N=0;
    for(int i=1; i<=g; ++i)
    {
        if (i==eS)
        {
            N++;
            a[N][0].x=S.x;
            a[N][0].y=S.y;
            a[N][1].x=S.x;
            a[N][1].y=S.y;
            idS=id[N][0]=id[N][1]=++cnt;
        }
        if (i==eT)
        {
            N++;
            a[N][0].x=T.x;
            a[N][0].y=T.y;
            a[N][1].x=T.x;
            a[N][1].y=T.y;
            idT=id[N][0]=id[N][1]=++cnt;
        }
        if (i==g) continue;
        N++;
        a[N][0].x=square[i][1].x;
        a[N][0].y=max(square[i][0].y,square[i+1][0].y);
        a[N][1].x=square[i][1].x;
        a[N][1].y=min(square[i][1].y,square[i+1][1].y);
        id[N][0]=++cnt;
        id[N][1]=++cnt;
    }
    memset(info,-1,sizeof(info));
    now=-1;
    for(int i=2; i<=N; ++i)
        for(int j=0; j<2; j++)
            solve(a[i][j],id[i][j],i);
    ans=SPFA();
    scanf("%lf\n",&v);
    ans=ans/v;
    printf("%0.10lf\n",ans);
    return 0;
}
```
 

---

## 作者：ganpig (赞：8)

> 这题最好想到、最好理解、最好写的做法当然是 $O(n^2)$ 的 dp 啦
>
> 然而前人的 dp 题解似乎都被两位用图论最短路算法的神犇 hack 了
>
> 于是我写了个能过 hack 数据的 dp（

首先，最短路径显然是一条折线，拐点只能是**相邻矩形重叠边的端点**（下称*关键点*）。

为方便起见，我们令起点在左、终点在右（如果数据不满足，直接交换起点和终点即可，因为最短路径是可逆的），那么智能车一定不能向左行驶，起点左侧与终点右侧的关键点可以忽略。

考虑从左到右依次算出起点到每个关键点的最短路径长度。我们需要用某一个关键点之前的每一个能**直接到达**（二者连线段完全在赛道区域内）的关键点来更新这一个关键点的答案，只要能做到平均 $O(1)$ 地判断能否直接到达，这个过程就是 $O(n^2)$ 的，能通过本题。

于是问题就转化为了如何在 dp 的过程中判断两个关键点之间能否直接到达。

画图可知，两个关键点的连线段完全在赛道区域内等价于其穿过它们之间的所有**相邻矩形重叠边**。这样一看，只要维护连线斜率的合法范围即可。固定右端点，从右到左枚举左端点，如果连线斜率介于之前斜率的最值之间，就可以用左端点来更新右端点的答案，接着更新合法范围的上下界。从左到右枚举完右端点后，我们就得到了终点处的答案。

然而遇到一些~~良心~~数据时还需要在起点或终点处上下移动，这时上面的方法就无法处理了（毕竟竖直方向的直线不存在斜率，$\Delta x=0$ 作除数会出问题），需要进行一定的特殊处理（起点与终点横坐标相同时，直接输出纵坐标差值；否则需要记录上下移动的距离并更改起点或终点的位置，详见代码）。

## $\text{Code}$
```cpp
#include <bits/stdc++.h>
int main() {
    int n;
    std::cin >> n;
    std::vector<std::array<int, 4>> rects(n); // {left, bottom, right, top}
    for (auto &v : rects)
        for (int &x : v)
            std::cin >> x;

    int xs, ys, xt, yt, ex = 0;
    double v;
    std::cin >> xs >> ys >> xt >> yt >> v;
    if (xs == xt)
        return printf("%.8lf\n", std::abs(ys - yt) / v), 0;
    if (xs > xt)
        std::swap(xs, xt), std::swap(ys, yt);

    std::vector<int> x, y, tp;
    auto add = [&](int _x, int _y, int _tp) { x.emplace_back(_x), y.emplace_back(_y), tp.emplace_back(_tp); };
    add(xs, ys, 0);
    for (int i = 1; i < n; i++) {
        if (rects[i][0] <= xs) {
            if (rects[i][0] == xs) { // 起点处可能需要上下移动
                if (ys > rects[i][3])
                    ex += ys - rects[i][3], y[0] = rects[i][3];
                if (ys < rects[i][1])
                    ex += rects[i][1] - ys, y[0] = rects[i][1];
            }
            continue;
        }
        if (rects[i][0] >= xt) {
            if (rects[i][0] == xt) { // 终点处可能需要上下移动
                if (yt > rects[i - 1][3])
                    ex += yt - rects[i - 1][3], yt = rects[i - 1][3];
                if (yt < rects[i - 1][1])
                    ex += rects[i - 1][1] - yt, yt = rects[i - 1][1];
            }
            break;
        }
        add(rects[i][0], std::min(rects[i - 1][3], rects[i][3]), 1);
        add(rects[i][0], std::max(rects[i - 1][1], rects[i][1]), 2);
    }
    add(xt, yt, 1);

    int m = x.size();
    std::vector<double> f(m, 1e9);
    f[0] = 0;
    for (int i = 1; i < m; i++) {
        double lower = -1e9, upper = 1e9;
        for (int j = i - tp[i]; j >= 0; j--) {
            double k = (double)(y[i] - y[j]) / (x[i] - x[j]);
            if (lower <= k && k <= upper)
                f[i] = std::min(f[i], f[j] + hypot(x[i] - x[j], y[i] - y[j]));
            if (tp[j] == 1 && k > lower)
                lower = k; // 更新斜率下界
            if (tp[j] == 2 && k < upper)
                upper = k; // 更新斜率上界
            if (lower > upper)
                break; // 效率优化
        }
    }

    printf("%.8lf\n", (f.back() + ex) / v);
    return 0;
}
```

---

## 作者：Transparent (赞：7)

## 题意

给定 $n$ 个左右相连的矩形和两个点，求在不走出矩形区域的情况下两点间路径长度最小值。

## 题解

显然，答案路径是一条折线。

容易发现，折线方向发生改变的点一定是矩形的顶点。矩形的顶点不超过 $8000$ 个，所以可以考虑以起点、终点和所有矩形的顶点为顶点建图，枚举所有点对，对可以相互到达的点连边。

要判断两点间是否可达，即是判断两点间连线是否经过合法区域外。

考虑将相邻矩形的边公共部分取出，得到 $n-1$ 条平行于 $y$ 轴的线段，那么分居于其中任一线段所在直线两端的点要可达，必须满足两点间连线经过该线段。这个条件可以通过对过当前点的斜率的限制来达成。

![](https://cdn.luogu.com.cn/upload/image_hosting/flksfwex.png)

如图，按照以上规则，$S$ 点出发向右越过第一个矩形区域，只有蓝色区域中的点可以到达 $S$ 点。


越过一个矩形的原因就是第一个矩形会出问题，枚举到的点可能不在我们选出的线段上，这时，当前点的右侧可能在边界外。

只考虑当前点右侧，如果当前点右侧在边界外，则当前点右侧没有可以到达的点（如图）。

![](https://cdn.luogu.com.cn/upload/image_hosting/vbwo691e.png)

如果当前点右侧在边界内，则右侧整个矩形中的所有点都可以到达（如图）。

![](https://cdn.luogu.com.cn/upload/image_hosting/jngeydfm.png)

在将点按 $x$ 从小到大排序后，即可 $O(n^2)$ 完成这一过程。

按照这一规则建图后，计算 $S$ 到 $T$ 的最短路即可，时间复杂度 $O(n^2 \log_2(n^2))$，~~有点慢~~。

## Code

```cpp
#include<bits/stdc++.h>
using namespace std;
template<typename T>
void read(T &res) {
	res=0;bool f=false;char ch=getchar();
	while(ch<'0'||ch>'9') {if(ch=='-') f=true; ch=getchar();}
	while(ch>='0'&&ch<='9') res=(res<<3)+(res<<1)+(ch^48),ch=getchar();
	res=f?-res:res;
}
template<typename T,typename ...Args>
void read(T &res,Args &...args) {read(res); read(args...);}
template<typename T>
void write(T x) {if(x<0) putchar('-'),x=-x; if(x>9) write(x/10); putchar(x%10+'0');}
template<typename T>
inline void writeln(T x) {write(x);putchar('\n');}
template<typename T,typename ...Args>
void write(T x,Args ...args) {write(x); putchar(' '); write(args...);}
template<typename T,typename ...Args>
void writeln(T x,Args ...args) {writeln(x); writeln(args...);}
#define MAXN 2001
const double eps=1e-10;
const double inf=1.0/0.0;
class Point {
public:
	Point() {x=y=type=0;}
	Point(double _x,double _y) {x=_x,y=_y,type=0;}
	double x,y;
	int type;
}p[MAXN<<3];
class Seg {
public:
	Seg() {x=y1=y2=0;}
	Seg(double _x,double _y1,double _y2) {x=_x,y1=_y1,y2=_y2;}
	double x,y1,y2;
}seg[MAXN],rs[MAXN];
class Line {
public:
	Line() {p=Point(),d=Point();}
	Line(Point _p,Point _d) {p=_p,d=_d;}
	Point p,d;
	inline double y(double x) {
		double mul=(x-p.x)/d.x;
		return p.y+mul*d.y;
	}
};
class Edge {
public:
	Edge() {to=next=len=0;}
	int to,next;
	double len;
};
class Graph {
public:
	Graph() {
		memset(g,0,sizeof(g));
		memset(head,0,sizeof(head));
		tot=0;
	}
	inline void addEdge(int from,int to,double len) {
		g[++tot].to=to;g[tot].next=head[from];head[from]=tot;g[tot].len=len;
		g[++tot].to=from;g[tot].next=head[to];head[to]=tot;g[tot].len=len;
	}
	Edge g[MAXN*MAXN<<1];
	int head[MAXN<<3],tot;
}g;
inline int dcmp(double x) {
	if(x>eps) return 1;
	if(x<-eps) return -1;
	return 0;
}
inline double sq(double x) {
	return x*x;
}
inline double calcDis(Point a,Point b) {
	return __builtin_sqrt(sq(a.x-b.x)+sq(a.y-b.y));
}
inline bool operator<(const Point a,const Point b) {
	return a.x<b.x;
}
inline double getK(Point a,Point b) {
	return (b.y-a.y)/(b.x-a.x);
}
int sid,tid;
inline void buildGraph(int pcnt,int scnt,Point s,Point t) {
	s.type=t.type=1;
	p[++pcnt]=s;p[++pcnt]=t;
	sort(p+1,p+pcnt+1);
	for(int i=1;i<=pcnt;i++) {
		if(p[i].type) {
			if(p[i].x==s.x&&p[i].y==s.y) sid=i;
			else tid=i;
		}
		int cur=p[i].x,j=i+1,k=1;
		while(j<=pcnt&&p[j].x==cur) {
			g.addEdge(i,j,calcDis(p[i],p[j]));
			fprintf(stderr,"(%.0lf,%.0lf)<->(%.0lf,%.0lf) %.3lf\n",p[i].x,p[i].y,p[j].x,p[j].y,calcDis(p[i],p[j]));
			++j;
		}
		if(j>pcnt) continue;
		cur=p[j].x;
		for(;k<=scnt;k++) {
			if(dcmp(seg[k].x-p[i].x)>=0) break;
		}
		double k1=inf,k2=-inf;
		if(dcmp(seg[k].x-p[i].x)==0) {
			if(k<scnt&&(dcmp(rs[k+1].y1-p[i].y)>0||dcmp(rs[k+1].y2-p[i].y)<0)) continue;
			++k;
		} 
		for(;k<=scnt;k++) {
			while(dcmp(seg[k].x-cur)>0) {
				while(j<=pcnt&&p[j].x==cur) {
					if(dcmp(getK(p[i],p[j])-k2)>=0&&dcmp(getK(p[i],p[j])-k1)<=0) {
						g.addEdge(i,j,calcDis(p[i],p[j]));
						fprintf(stderr,"(%.0lf,%.0lf)<->(%.0lf,%.0lf) %.3lf\n",p[i].x,p[i].y,p[j].x,p[j].y,calcDis(p[i],p[j]));
					}
					++j;
				}
				if(j>pcnt) break;
				cur=p[j].x;
			}
			while(j<=pcnt&&p[j].x==cur) {
				if(dcmp(getK(p[i],p[j])-k2)>=0&&dcmp(getK(p[i],p[j])-k1)<=0&&dcmp(p[j].y-rs[k].y1)>=0&&dcmp(p[j].y-rs[k].y2)<=0) {
					g.addEdge(i,j,calcDis(p[i],p[j]));
					fprintf(stderr,"(%.0lf,%.0lf)<->(%.0lf,%.0lf) %.3lf\n",p[i].x,p[i].y,p[j].x,p[j].y,calcDis(p[i],p[j]));
				}
				++j;
			}
			if(j>pcnt) break;
			cur=p[j].x;
			k1=min(k1,getK(p[i],Point(seg[k].x,seg[k].y2)));
			k2=max(k2,getK(p[i],Point(seg[k].x,seg[k].y1)));
			if(dcmp(k1-k2)<0) break;
		}
	}
}
priority_queue<pair<double,int>,vector<pair<double,int> >,greater<pair<double,int> > >q;
double dis[MAXN<<3];
bool vis[MAXN<<3];
inline double dijkstra(int o,int e,int pcnt) {
	for(int i=1;i<=pcnt;i++) {
		dis[i]=inf;vis[i]=false;
	}
	dis[o]=0;q.push(make_pair(dis[o],o));
	while(!q.empty()) {
		int u=q.top().second;q.pop();
		if(vis[u]) continue;
		vis[u]=true;
		for(int i=g.head[u];i;i=g.g[i].next) {
			int v=g.g[i].to;
			if(dis[v]>dis[u]+g.g[i].len) {
				dis[v]=dis[u]+g.g[i].len;
				if(!vis[v]) q.push(make_pair(dis[v],v));
			}
		}
	}
	return dis[e];
}
int n,pcnt,scnt;
Point s,t;
int main() {
	read(n);
	double ly1=-inf,ly2=inf;
	for(int i=1;i<=n;i++) {
		double x1=0,y1=0,x2=0,y2=0;
		scanf("%lf%lf%lf%lf",&x1,&y1,&x2,&y2);
		p[++pcnt]=Point(x1,y1);p[++pcnt]=Point(x1,y2);
		p[++pcnt]=Point(x2,y1);p[++pcnt]=Point(x2,y2);
		rs[i].x=x1;rs[i].y1=y1,rs[i].y2=y2;
		if(i!=1) seg[++scnt]=Seg(x1,max(ly1,y1),min(ly2,y2));
		if(i==n) seg[++scnt]=Seg(x2,y1,y2);
		ly1=y1,ly2=y2;
	}
	rs[0].x=0;rs[0].y1=-inf,rs[0].y2=inf;
	scanf("%lf%lf%lf%lf",&s.x,&s.y,&t.x,&t.y);
	buildGraph(pcnt,scnt,s,t);	
	double v=0;scanf("%lf",&v);
	printf("%.8lf\n",dijkstra(sid,tid,pcnt+2)/v);
	return 0;
}
```

## 最后

~~由于和题解对拍发现全是题解错了~~，这里有对题解的hack和~~弱~~数据生成器，方便大家调试自己的代码。

数据生成器：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxgap=5; //矩形宽度限制 
const int maxh=20; //最高点y坐标限制（最终高度至多比maxh大1） 
const int maxn=5; //n的最大值 
class Point {
public:
	Point() {x=y=0;}
	Point(int _x,int _y) {x=_x,y=_y;}
	int x,y;
};
class Rect {
public:
	Rect() {a=Point(),b=Point();}
	Rect(Point x,Point y) {a=x,b=y;}
	Point a,b; 
}rec[maxn+1]; 
inline void genFirst(Point &a,Point &b) {
	a.x=0;a.y=rand()%maxh+1;
	b.x=a.x+rand()%maxgap+1;
	b.y=rand()%maxh+1;
	if(a.y==b.y) {
		++b.y;
		if(b.y>maxh) b.y=maxh;
		--a.y;
	}
	if(a.y>b.y) swap(a.y,b.y);
}
inline void genNext(int lx,int ly1,int ly2,Point &a,Point &b) {
	a.x=lx;a.y=rand()%ly2+1;
	b.x=a.x+rand()%maxgap+1;
	if(maxh-a.y-ly1<=0) b.y=maxh+1;
	else b.y=a.y+rand()%(maxh-a.y-ly1)+ly1+1;
}
int main() {
	freopen("car.in","w",stdout);
	srand(time(NULL));
	int n=rand()%maxn+1;
	printf("%d\n",n);
	Point a,b,c,d;
	genFirst(a,b);
	printf("%d %d %d %d\n",a.x,a.y,b.x,b.y);
	rec[1]=Rect(a,b);
	for(int i=2;i<=n;i++) {
		c=a,d=b;
		genNext(d.x,c.y,d.y,a,b);
		printf("%d %d %d %d\n",a.x,a.y,b.x,b.y);
		rec[i]=Rect(a,b); 
	}
	Point s,t;
	s.x=rand()%(b.x+1);
	t.x=rand()%b.x;
	if(t.x>=s.x) ++t.x;
	int tminy=0x7fffffff,tmaxy=0;
	int sminy=0x7fffffff,smaxy=0;
	for(int i=1;i<=n;i++) {
		if(rec[i].a.x<=t.x&&rec[i].b.x>=t.x) {
			tminy=min(tminy,rec[i].a.y);
			tmaxy=max(tmaxy,rec[i].b.y);
		}
		if(rec[i].a.x<=s.x&&rec[i].b.x>=s.x) {
			sminy=min(sminy,rec[i].a.y);
			smaxy=max(smaxy,rec[i].b.y);
		}
	}
	t.y=rand()%(tmaxy-tminy+1)+tminy;
	s.y=rand()%(smaxy-sminy+1)+sminy;
	printf("%d %d\n%d %d\n",s.x,s.y,t.x,t.y);
	int v1=rand()%100+1,v2=rand()%100+1;
	printf("%.6lf\n",(double)v1/(double)v2);
	return 0;
}
```

- Hack1 (@litble):

```
5
0 4 2 18
2 7 6 14
6 6 7 18
7 5 12 13
12 11 17 18
0 17
9 8
1.0

```

ans:

```
12.8250957328

```

如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/hskdzpjl.png)

准确值为 $\sqrt{13}+\sqrt{85}$。

------

- Hack2 (@乌合之众):

```
5
0 10 3 15
3 6 4 20
4 11 5 18
5 12 9 21
9 2 10 18
5 18
9 21
1.0
```

ans:

```
5.0000000000
```

如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/fql3s6ef.png)

准确值为 $5$。

------

- Hack3 (@qianpinyi):

```
4
0 5 5 15
5 2 9 19
9 16 14 20
14 12 19 21
14 14
16 21
1.00
```

ans:

```
7.2801098893
```

如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/jd8dkooi.png)

准确值为 $\sqrt{53}$。

------

- Hack4 (@Infinite_Eternity):

```
9
0 31 3 45
3 41 8 51
8 12 11 51
11 42 12 51
12 24 14 51
14 45 18 51
18 17 19 51
19 50 21 51
21 11 24 51
10 24
15 50
1.0
```

ans:
```
26.9720282873
```

如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/35ov6zog.png)

准确值为 $5\sqrt{13}+4\sqrt{5}$。

------

- Hack5 (@Vectorique):

```
3
0 1 3 17
3 15 4 18
4 4 6 20
2 14
3 1
1.0
```

ans:

```
13.0384048104
```

如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/ncv1mgrt.png)

准确值为 $\sqrt{170}$。

问题大多是路径穿出矩形边界（答案偏小）和漏掉了起点和终点可以直接到达的情况（答案偏大）。

---

## 作者：封禁用户 (赞：2)

## P1995 题解
因为矩形已经给出并且根据常识，走直线一定比走曲线短，因此，路线要么是直线，要么是折线且如果是折线的话，折点一定在矩形的顶点处，这样的话，我们可以将整个赛道抽象成有若干个点的连通图，联通图上每个点一定为赛道的拐点或起始点或终点，这样的话，一个点与通过直线可到达的其他点的　距离就可以 $O ( n )$ 的处理出来，一共有 $ n $ 个矩形，每相邻两个矩形产生 $ 2 $ 个点，算上起点和终点，总共大概有 $ ( 2 \times n )$ 个点，因此最坏复杂度大概为 $ 4000 ^ { 2 }$，不会超时。

## 代码
```cpp
#include<iostream>
#include<algorithm>
#include<stdio.h>
#include<math.h>
#include<cmath>
using namespace std;
int a[10],n,stx,sty,edx,edy,num;
int x1[2010],ydown[2010],x2[2010],y2[2010];
double v,dis[4010];
struct node{
    int x;int y;
}p[5005];
void pre()
{
    num=1;p[1].x=stx;p[1].y=sty;
    for (int i=1;i<n;i++)
    {
        if (stx>x2[i]) continue;    
        if (x2[i]>edx) break;
        a[1]=ydown[i],a[2]=y2[i],a[3]=ydown[i+1],a[4]=y2[i+1];
        sort(a+1,a+1+4);
        //取相邻矩形可以构成赛道拐点的两个点加入抽象出来的点集中
        num++;
        p[num].x=x2[i];
        p[num].y=a[2];
        num++;
        p[num].x=x2[i];
        p[num].y=a[3];
    }
    num++;
    p[num].x=edx;
    p[num].y=edy;
}
int main()
{
    scanf("%d",&n);
    for (int i=1;i<=n;i++) 
    scanf("%d%d%d%d",&x1[i],&ydown[i],&x2[i],&y2[i]);
    scanf("%d%d%d%d",&stx,&sty,&edx,&edy);
    if (stx>edx) 
    {
        swap(stx,edx);
        swap(sty,edy);
    }
    scanf("%lf",&v);    
    pre();
    for (int i=2;i<=num;i++) dis[i]=1e99;
    for (int i=1;i<num;i++)
    {
        double nox=(double)p[i].x*1.0;
        double noy=(double)p[i].y*1.0;
        double mmax=1e99;
        double mmin=-1e99;
        for (int j=i+1;j<=num;j++)
        {
            double len;
            double nex=(double)p[j].x*1.0;
            double ney=(double)p[j].y*1.0;

            if (nex==nox)
            {
                len=abs(ney-noy);
                dis[j]=min(dis[j],len+dis[i]);
                continue;
            }//如果下一个点与这个点的横坐标相同，直接算的话会除０出错
            double tmp=(ney-noy)/(nex-nox);
            if ((tmp<=mmax)&&(tmp>=mmin))//如果斜率在能够通过的范围内
            {
                double hh=(ney-noy)*(ney-noy)+(nex-nox)*(nex-nox);
                len=sqrt(hh);
                dis[j]=min(dis[j],len+dis[i]);
            }
            //根据加点集时的规律ｊ%2==0时肯定是同一横坐标的偏下的点，用它来维护斜率范围中的最小值，j%2==1时维护最大值即可
            if ((j%2)==0)   mmin=max(mmin,tmp);
            else    mmax=min(mmax,tmp);
        }
    }
    double ans=dis[num]/v;
    printf("%.10lf\n",ans);
}
```

---


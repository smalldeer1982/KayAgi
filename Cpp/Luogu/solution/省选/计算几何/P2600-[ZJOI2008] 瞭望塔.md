# [ZJOI2008] 瞭望塔

## 题目描述

致力于建设全国示范和谐小村庄的 H 村村长 dadzhi，决定在村中建立一个瞭望塔，以此加强村中的治安。

我们将 H 村抽象为一维的轮廓，如下图所示。

![](https://cdn.luogu.com.cn/upload/pic/1710.png)

我们可以用一条山的上方轮廓折线 $(x_1, y_1),(x_2, y_2),\cdots,(x_n, y_n)$ 来描述 H 村的形状，这里 $x_1 < x_2 < \cdots < x_n$。瞭望塔可以建造在 $[x_1, x_n]$ 间的任意位置，但必须满足从瞭望塔的顶端可以看到 H 村的任意位置。显然在不同的位置建造瞭望塔，所需要建造的高度是不同的。为了节省开支，dadzhi 村长希望建造的塔高度尽可能小。

请你写一个程序，帮助 dadzhi 村长计算塔的最小高度。

## 说明/提示

对于 $60\%$ 的数据，$n \le 60$；

对于 $100\%$ 的数据，$n \le 300$，输入坐标绝对值不超过 $10^6$。

**请注意实数误差带来的问题。**

## 样例 #1

### 输入

```
6
1 2 4 5 6 7
1 2 2 4 2 1
```

### 输出

```
1.000```

# 题解

## 作者：韵城小管家 (赞：17)

我不会什么半平面交，也不想写队列，我只用最暴力的方法AC此题

首先通过手动模拟可以得到一个结论：

瞭望塔的横坐标一定在两条直线的交点处

所以我们先利用开始的n个点求出n-1条直线

然后两两枚举求交点的横坐标。

对于每一个横坐标再通过枚举n-1条直线求最高点

然后答案取一个最小值即可

复杂度$O(n^3)$

AC代码：
```cpp
#include<iostream>
#include<algorithm>
#include<cstring>
#include<cstdio>
using namespace std;
typedef double db;
const int N=305;
const db inf=99999999999.0;
int n;
db ax[N],ay[N];
struct LINE{
    db k,b; //y=kx+b
}ln[N];
db ans=inf;
db sol(db x){ //计算特定横坐标的最小瞭望塔高度
    db res=0;
    for(int i=1;i<n;i++)
        res=max(res,ln[i].k*x+ln[i].b);
    return res;
}
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
        scanf("%lf",&ax[i]);
    for(int i=1;i<=n;i++)
        scanf("%lf",&ay[i]);
    for(int i=1;i<n;i++){
        ln[i].k=(ay[i]-ay[i+1])/(ax[i]-ax[i+1]);
        ln[i].b=ay[i]-ln[i].k*ax[i];
    }
    for(int i=1;i<=n;i++)
        ans=min(ans,sol(ax[i])-ay[i]); //先枚举每个端点
    for(int i=1;i<n;i++)
        for(int j=i+1;j<n;j++){
            db x=(ln[i].b-ln[j].b)/(ln[j].k-ln[i].k); //求两直线的交点
            for(int k=1;k<n;k++)
                if(ax[k]<=x&&x<=ax[k+1])
                    ans=min(ans,sol(x)-ln[k].k*x-ln[k].b); //最小化答案
        }
    printf("%.3lf\n",ans);
    return 0;
}
```

---

## 作者：Yaha (赞：9)

### 半平面交

我们把每条线看成一个指向右的向量，它所在直线可以把这个平面分成左右两部分。要想让一条线上每处都被瞭望台看到，把瞭望台建在其左半平面就行了。

这样， $n$ 条直线就有 $n$ 个需求，要想全部满足，瞭望台顶端就必须建到这些半平面的交处。

已经求完半平面交，再来考虑如何求最优方案。我们已经得到了两个轮廓，一个是上面的半平面交，是瞭望台顶端必须所在的区域，一个是下面的原村地形图，是瞭望台底部必须所在的位置。我们要求一条垂直于 $x$ 轴的线，使得与两轮廓的交点距离最近。最优的方案一定经过半平面交的顶点或原村的拐点，因为两段线段斜率一定，中间的点一定没有两端距离近，可以画图看看。

最后就把半平面交和原地形图的拐点枚举一遍，过该点作一条垂直于 $x$ 轴的直线，求它和另一个轮廓的交点与该点距离，取最小就可以了。

见代码

```cpp
#include<bits/stdc++.h>
#define x first
#define y second
#define D double

using namespace std;

typedef pair<D,D> PDD;//点
const int amou=340;
const D eps=1e-8;

int cnt,n,m;
D final=1e15;
struct Line{
	PDD st,ed;//起点和终点
}line[amou];
PDD p[amou],ans[amou];
int q[amou];

PDD operator-(PDD a,PDD b){
	return {a.x-b.x,a.y-b.y};
}

D get_angle(Line a){//求角度
	return atan2(a.ed.y-a.st.y,a.ed.x-a.st.x);
}

int dcmp(D a,D b){//比较大小
	if(fabs(a-b)<eps) return 0;
	if(a<b) return -1;
	return 1;
}

D cross(PDD a,PDD b){//叉乘
	return a.x*b.y-a.y*b.x;
}

D area(PDD a,PDD b,PDD c){//求面积
	return cross(b-a,c-a);
}

bool cmp(Line a,Line b){//排序函数，按角度
	D A=get_angle(a),B=get_angle(b);
	if(!dcmp(A,B)) return area(a.st,a.ed,b.st)<0;//角度一样，保留左边那条，因为后面的函数中如果和前一条角度一样就不再重复处理，相当于跳过，所以把最左边的排到最前边，才能处理正确
	return A<B;
}

PDD get_line_intersection_point(PDD s1,PDD t1,PDD s2,PDD t2){//求交点
	PDD u=s1-s2;
	D t=cross(t2,u)/cross(t1,t2);
	return {s1.x+t1.x*t,s1.y+t1.y*t};
}

PDD get_line_intersection_line(Line a,Line b){//线线求交点
	return get_line_intersection_point(a.st,a.ed-a.st,b.st,b.ed-b.st);
}

bool on_right(Line a,Line b,Line c){//bc交点是否在a右边
	PDD p=get_line_intersection_line(b,c);
	return area(a.st,a.ed,p)<=0;
}

bool ccmp(PDD a,PDD b){//把半平面交的点从左至右排
	return a.x<b.x;
}

void half_plane_intersection(){
	sort(line+1,line+cnt+1,cmp);
	int head=0,tail=-1;
	for(int i=1;i<=cnt;i++)
	{
		if(i>1&&!dcmp(get_angle(line[i]),get_angle(line[i-1]))) continue;
		while(head+1<=tail&&on_right(line[i],line[q[tail]],line[q[tail-1]])) tail--;
		while(head+1<=tail&&on_right(line[i],line[q[head]],line[q[head+1]])) head++;
		q[++tail]=i;
	}
	while(head+1<=tail&&on_right(line[q[head]],line[q[tail]],line[q[tail-1]])) tail--;
	while(head+1<=tail&&on_right(line[q[tail]],line[q[head]],line[q[head+1]])) head++;

	for(int i=head;i<tail;i++) ans[++m]=get_line_intersection_line(line[q[i]],line[q[i+1]]);
	sort(ans+1,ans+m+1,ccmp);
	int posans=1,posp=1;
	while(posans<=m&&posp<=n)//同时枚举，一个个地处理，就不用二分了
	{
		PDD temp;
		if(ans[posans].x>p[posp].x)//上边的点在右边
		{
			temp=get_line_intersection_line({ans[posans],ans[posans-1]},{p[posp],{p[posp].x,p[posp].y+100}});//上边的点和它上一个点构成的直线，和过下边的点垂直于x轴的直线，的交点
			final=min(final,temp.y-p[posp].y);//纵坐标之差就是距离
			posp++;//落后的往前挪一格
		}
		else
		{
			temp=get_line_intersection_line({p[posp-1],p[posp]},{ans[posans],{ans[posans].x,ans[posans].y+100}});//同上，品吧
			final=min(final,ans[posans].y-temp.y);
			posans++;
		}
	}
    //这时有可能其中一个还没处理完就退出了，那就继续处理
	while(posans<=m) final=min(final,ans[posans].y-get_line_intersection_line({p[posp-1],p[posp]},{ans[posans],{ans[posans].x,ans[posans].y+100}}).y),posans++;
	while(posp<=n) final=min(final,get_line_intersection_line({ans[posans],ans[posans-1]},{p[posp],{p[posp].x,p[posp].y+100}}).y-p[posp].y),posp++;
	
	printf("%.3lf",final);
}

int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++) scanf("%lf",&p[i].x);
	for(int i=1;i<=n;i++) scanf("%lf",&p[i].y);
	line[++cnt]={{-110,110},{-110,0}};//边界一定要注意，不然后面半平面交就会求得不完整。就这个东西我调了一整天
	for(int i=1;i<n;i++) line[++cnt]={p[i],p[i+1]};
	
	half_plane_intersection();
	
	return 0;
}
```


---

## 作者：xuxinyu (赞：8)

本题可以使用三分法

将点按横坐标排好序后

对于任意相意两个点连成的线段，瞭望塔的高度 是单峰函数，而且是下凸函数

感性理解单峰就是

瞭望塔建的靠左，为了能看到右边的，要高一点

瞭望塔建的靠右，为了能看到左边的，要高一点

所以
枚举所有线段，三分线段上建造瞭望塔的位置，所有线段上的瞭望塔高度取最小










```cpp
#include<cmath>
#include<cstdio>
#include<algorithm>
using namespace std;
#define N 301
const double eps=1e-7;
int n;
struct POINT
{
    double x,y;
}e[N];
struct LINE
{
    double k,b;
    bool exit;
}l[N];
bool cmp(POINT p,POINT q)
{
    return p.x<q.x;
}
double cal(double x,double y)
{
    double tmp=0;
    for(int i=1;i<n;++i)
    {
        if(!l[i].exit) continue;
        tmp=fmax(tmp,l[i].k*x+l[i].b-y);
    }
    return tmp;
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;++i) scanf("%lf",&e[i].x);
    for(int i=1;i<=n;++i) scanf("%lf",&e[i].y);
    sort(e+1,e+n+1,cmp);
    for(int i=1;i<n;++i)
    {
        if(fabs(e[i].x-e[i+1].x)<eps) continue;
        l[i].k=(e[i].y-e[i+1].y)/(e[i].x-e[i+1].x);
        l[i].b=e[i].y-e[i].x*l[i].k;
        l[i].exit=true;
    }
    double L,R,mid1,mid2;
    int T;
    double ans=1e20;
    for(int i=1;i<n;++i)
    {
        if(!l[i].exit) continue;
        T=100; L=e[i].x; R=e[i+1].x;
        while(T--)
        {
            mid1=L+(R-L)/3; mid2=R-(R-L)/3;
            if(cal(mid1,l[i].k*mid1+l[i].b)<cal(mid2,l[i].k*mid2+l[i].b)) R=mid2;
            else L=mid1;
        }
        ans=fmin(ans,cal(mid1,l[i].k*mid1+l[i].b));
    }
    printf("%.3lf",ans);
}
```

---

## 作者：HECZ (赞：6)

一道数论+数据结构好题，三分即可。

`calc(x, y)` 函数表示求在点 $\left(x,y\right)$ 建造灯塔的最低高度。

```cpp
#include <bits/stdc++.h>
typedef long long ll;

using namespace std;

int read() {
    int x = 0; bool m = 0; char c = getchar();
    while (!isdigit(c) && c != '-') c = getchar();
    if (c == '-') m = 1, c = getchar();
    while (isdigit(c)) x = x * 10 + c - '0', c = getchar();
    if (m) return -x; else return x;
}

const int maxn = 305;
int n;
double mid, ans = 1e200, lbound, rbound, lmid, rmid;
double x[maxn], y[maxn], k[maxn], b[maxn];

double calc(double x, double y) {
    double ans = 0;
    for (int i = 1; i < n; i++)
        ans = max(ans, x * k[i] + b[i] - y);
    return ans;
}

int main() {

    scanf("%d", &n);
    for (int i = 1; i <= n; i++)
        scanf("%lf", &x[i]);
    for (int i = 1; i <= n; i++)
        scanf("%lf", &y[i]);

    for (int i = 1; i < n; i++) {
        k[i] = (y[i + 1] - y[i]) / (x[i + 1] - x[i]);
        b[i] = y[i] - x[i] * k[i];
    }

    for (int i = 1; i < n; i++) {
        lbound = x[i];
        rbound = x[i + 1];
        for (int t = 100; t; t--) {
            lmid = lbound + (rbound - lbound) / 3;
            rmid = rbound - (rbound - lbound) / 3;
            if (calc(lmid, lmid * k[i] + b[i]) < calc(rmid, rmid * k[i] + b[i]))
                rbound = rmid;
            else
                lbound = lmid;
        }
        mid = (lbound + rbound) / 2;
        ans = min(ans, calc(mid, mid * k[i] + b[i]));
    }
    printf("%.3lf\n", ans);

    return 0;
}
```

---

## 作者：Piwry (赞：4)

前面先提醒下：虽然数据范围是 1e6 内，但程序中的最大值应该至少开到 5e11（左右）。

考虑一个由三条线组成的梯形山坡，左右直线斜率的绝对值均为 1e6；即这样一个图形：

![瞭望塔](https://cdn.luogu.com.cn/upload/image_hosting/qfray194.png)

可以发现一个符合条件的瞭望塔至少要在**左右直线的交点处**，而这个交点的 $y$ 坐标是 $10^6\cdot(\frac 1 2\cdot10^6)=5\cdot10^{11}$。

![瞭望塔2](https://cdn.luogu.com.cn/upload/image_hosting/8qa4az2j.png)

（实际位置太难翻了（GeoGebra坐标到 1e10 就不能再缩放了）我就只放个坐标了qaq）

## 解析

读完题我立刻就想到了一道 [求多边形核的题目](https://www.luogu.com.cn/problem/UVA1571)。

这题求的也大概是同一个东西：我们将地面拆成一条条线段，可以发现对于一条线段一定要求瞭望塔在它的 “上面”，于是就可以用半平面交跑一跑。

我们在左侧和右侧紧贴着地面加两条边界（就像题目示例图的左右边框），并在上面也加一条边界（要求比可能最高的瞭望塔坐标高），这样最后求出的交就一定是个凸包（有限的面积），这个凸包的含义就是**瞭望塔所有可能的位置**。

由单调性可以想到凸包及地面顶点一定比边上（或凸包内部的点）更优。

用半平面交求出的凸包应该是按顺时针或逆时针排列的边，直接遍历求出的点也是顺时针或逆时针的，但这些点 $x$ 坐标不一定单调，这导致我们**对每个凸包点找到相应那段地面线段求塔高**时，可能需要数据结构维护或 $O(n)$ 暴力。

---

我们把凸包拆成上凸壳或下凸壳，显然上凸壳的点没有下凸壳的点优，是可以舍去的。

因此考虑在对直线排序时做些修改：我们按 tan2 函数返回的极角从小到大排序（可以给这些极角加上一个常数，就像为了取正加上 $\pi$ 一样，是不影响的），那么最后求出的凸包边的顺序就像这样：

![凸包](https://cdn.luogu.com.cn/upload/image_hosting/j67rj9am.png)

（从大到小排也行，求下凸壳做法 “对称” 下就可以了）

那么在顺序遍历求出顶点后（那么顶点排序和边是一样的），我们从头部向右移动指针直到**指针下一个位置**的（可见代码） $x$ 坐标**不再减小**，从尾部向左移动指针直到指针下一个位置的 $x$ 坐标**不再增大**，这中间的区间（包含左右指针边界）里就是下凸包顶点。

```cpp
/*这里也给出求凸包顶点的代码*/
/*hull 存凸包边，toth 是边数量*/
/*getIntersection(f, g) 返回 f, g 的交点*/
inline int getPoint(line hull[], int toth, vect point[]){
	int totp =0;
	hull[toth++] =hull[0];
	for(int i =0; i < toth-1; ++i) point[totp++] =getIntersection(hull[i], hull[i+1]);
	return totp;
}
```

```cpp
/*指针左闭右开*/
/*totph 是凸包顶点数，pointh 存凸包顶点*/
/*gtr(a, b) -> (a > b)*/
int l =0, r =totph;
while(gtr(pointh[l].x, pointh[l+1].x)) ++l;
while(gtr(pointh[r-2].x, pointh[r-1].x)) --r;
```

求出下凸壳后，两个数组内点的坐标就都是**单调递增**的了，那么我们再枚举其中一个数组的点时，想要找出另一个数组中对应的边的端点，只需用一个**单调移动**的指针找就可以了：

```cpp
/*totph 是凸包顶点数，pointh 存凸包顶点*/
/*point 存地面顶点（输入直接给出的），totp 是地面顶点数*/
inline double get(vect pointh[], int totph, vect point[], int totp){
	int l =0, r =totph;
	while(gtr(pointh[l].x, pointh[l+1].x)) ++l;
	while(gtr(pointh[r-2].x, pointh[r-1].x)) --r;
	/*上面这段就是求下凸壳*/
	double ans =MAX;
	/*下面对于凸包顶点和地面顶点都做一次*/
	for(int ph =l, pp =0; ph < r; ++ph){
		/*找到两个点 point[pp], point[pp-1] 使得 pointh[ph]（的 x 坐标）夹在这两个点之间*/
		while(pp < totp && gtr(pointh[ph].x, point[pp].x)) ++pp;
		if(pp == 0 || pp == totp-1) continue;
		/*gethigh(p, a, b) 求过 p 的且平行 y 轴的直线与直线 (a, b) 的交点到 p 的距离*/
		double res =gethigh(pointh[ph], point[pp-1], point[pp]);
		if(gtr(ans, res)) ans =res;
	}
	for(int ph =l, pp =0; pp < totp; ++pp){
		while(ph < r && gtr(point[pp].x, pointh[ph].x)) ++ph;
		if(ph == 0 || ph == r-1) continue;
		double res =gethigh(point[pp], pointh[ph-1], pointh[ph]);
		if(gtr(ans, res)) ans =res;
	}
	return ans;
}
```

## CODE

```cpp
#include <cstdio>
#include <cmath>
#include <algorithm>
using std::sort;
using std::pair;
typedef pair<int, int> pad;

/*------------------------------Computational geometry------------------------------*/

const double pi =acos(-1), eps =1e-6;

struct vect{
	double x, y;
	vect(){}
	vect(double xx, double yy):x(xx), y(yy){}
	vect operator + (vect v){ return vect(x+v.x, y+v.y); }
	vect operator - (vect v){ return vect(x-v.x, y-v.y); }
	vect operator * (double mu){ return vect(mu*x, mu*y); }
	double operator / (vect v){ return x*v.y-y*v.x; }/*叉积*/
};

struct line{
	vect u, v;
	double angle;
	line(){}
	line(vect uu, vect vv):u(uu), v(vv){ angle =atan2(vv.y-uu.y, vv.x-uu.x); }
};

inline short gtr(double a, double b){ return (a-b > eps); }

inline bool eq(double a, double b){ return (a-b < eps && a-b > -eps); }

inline bool onright(line f, vect w){ return (gtr((w-f.u)/(f.v-f.u), 0)); }

vect getIntersection(line f, line g){
	double w =((g.u-f.u)/(f.u-f.v))/((f.u-f.v)/(g.u-g.v));
	return g.u+(g.u-g.v)*w;
}

int cmp(line A, line B){
	if(eq(A.angle, B.angle)) return onright(B, A.u);/*有向直线最左的在最后面，会被保留*/
	else return (gtr(B.angle, A.angle));
}

/*求左侧半平面交*/
inline pad getHPI(line ls[], int totl, line hull[]){
	sort(ls, ls+totl, cmp);
	int l =0, r =0;
	for(int i =0; i < totl; ++i){
		while(i < totl-1 && eq(ls[i].angle, ls[i+1].angle)) ++i;
		while(r-l > 1 && onright(ls[i], getIntersection(hull[r-1], hull[r-2]))) --r;
		if(eq(ls[i].angle-hull[r-1].angle, pi)) return pad(0, 0);/*判方向相反的平行*/
		hull[r++] =ls[i];
	}
	while(r-l > 1){
        if(onright(hull[r-1], getIntersection(hull[l], hull[l+1]))) ++l;
        else if(onright(hull[l], getIntersection(hull[r-1], hull[r-2]))) --r;
        else break;/*已经没有更新了*/
    }
	if(r-l < 3) return pad(0, 0);/*话说这题应该没有无解...*/
	else return pad(l, r);
}

inline double dist(vect x, vect y){ return sqrt((y.x-x.x)*(y.x-x.x)+(y.y-x.y)*(y.y-x.y)); }

/*------------------------------Main------------------------------*/

const int MAXN =400;
const long long MAX =6e11;

/*因为排序，这里求出的凸包点是有一定顺序的*/
inline int getPoint(line hull[], int toth, vect point[]){
	int totp =0;
	hull[toth++] =hull[0];
	for(int i =0; i < toth-1; ++i) point[totp++] =getIntersection(hull[i], hull[i+1]);
	return totp;
}

inline double gethigh(vect p, vect a, vect b){
	line f =line(p, p+vect(0, -1)), g =line(a, b);
	if(eq(f.angle, g.angle) || eq(f.angle+pi, g.angle) || eq(f.angle, g.angle+pi)) return MAX;
	return dist(p, getIntersection(f, g));
}

inline double get(vect pointh[], int totph, vect point[], int totp){
	int l =0, r =totph;
	while(gtr(pointh[l].x, pointh[l+1].x)) ++l;
	while(gtr(pointh[r-2].x, pointh[r-1].x)) --r;
	double ans =MAX;
	for(int ph =l, pp =0; ph < r; ++ph){
		while(pp < totp && gtr(pointh[ph].x, point[pp].x)) ++pp;
		if(pp == 0 || pp == totp-1) continue;
		double res =gethigh(pointh[ph], point[pp-1], point[pp]);
		if(gtr(ans, res)) ans =res;
	}
	for(int ph =l, pp =0; pp < totp; ++pp){
		while(ph < r && gtr(point[pp].x, pointh[ph].x)) ++ph;
		if(ph == 0 || ph == r-1) continue;
		double res =gethigh(point[pp], pointh[ph-1], pointh[ph]);
		if(gtr(ans, res)) ans =res;
	}
	return ans;
}

line ls[MAXN], hull[MAXN];
vect point[MAXN], pointh[MAXN];

inline int read(){
	int x =0; bool f =0; char c =getchar();
	while(c < '0' || c > '9') (c == '-') ? f =1, c =getchar() : c =getchar();
	while(c >= '0' && c <= '9') x = (x<<3) + (x<<1) + (48^c), c =getchar();
	return (f) ? -x : x;
}

int main(){
	int n =read();
	for(int i =0; i < n; ++i) point[i].x =read();
	for(int i =0; i < n; ++i) point[i].y =read();
	int totl =0;
	for(int i =0; i < n-1; ++i) ls[totl++] =line(point[i], point[i+1]);
	/*加入边界*/
	ls[totl++] =line(vect(point[0].x, MAX), vect(point[0].x, point[0].y));
	ls[totl++] =line(vect(point[n-1].x, point[n-1].y), vect(point[n-1].x, MAX));
	ls[totl++] =line(vect(point[n-1].x, MAX), vect(point[0].x, MAX));
	pad h =getHPI(ls, totl, hull);
	int totph =getPoint(hull, h.second-h.first, pointh);
	printf("%.3lf", get(pointh, totph, point, n));
}
```


---

## 作者：xzyxzy (赞：3)

### Po姐写了退火
### TA博客访问量太高，然后又有布布扣这些东西
### 于是这道题搜出来一版的退火
### 我竟然信了

为了不辜负我四个小时的调参，我写份题解：

如果我们确定了横坐标，那么纵坐标可以二分出来

要求所有的折点与（xx，yy）的连线要是顺时针的，所以就是xx左边的点连向他左边斜率递增，右边也递增

然后高度与关于x是一个有峰的函数（~~为什么我不觉得是单峰~~）

所以可以退火来找横坐标！

### 最最重要的Tip：
这种计算几何用退火做而且精度要求不低的，退完火之后要在答案附近Rand上个千把次才是对的（~~之前没有加只有10分~~）

类似的这种题还有[JSOI2004]平衡点 / 吊打XXX、[POJ]Run Away，都是要在退火之后的答案附近找更优解的

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cmath>
#define double long double
using namespace std;
const int N=400;
int n,x[N],y[N];
double ans=1e15,lst,pos;
int Check(double xx,double yy)
{
	double lst=-1e15;
	int i;
	for(i=1;i<=n&&x[i]<xx;i++)
	{
		double a=1.0*(yy-y[i])/(xx-x[i]);
		if(a<lst) return 0; lst=a;
	}
	if(x[i]==xx) i++;
	lst=-1e15;
	for(;i<=n;i++)
	{
		double a=1.0*(yy-y[i])/(xx-x[i]);
		if(a<lst) return 0; lst=a;
	}
	return 1;
}
double Calc(double xx)
{
	double l=0,r=1e11,res=1e12;
	while(r-l>1e-4)
	{
		double mid=(l+r)/2;
		if(Check(xx,mid)) r=mid,res=mid;
		else l=mid;
	}
	return res;
}
double Find(double xx)
{
	for(int i=1;i<=n;i++)
		if(x[i]<xx&&x[i+1]>xx&&i!=n)
			return 1.0*(y[i+1]-y[i])/(x[i+1]-x[i])*(xx-x[i])+y[i];
		else if(x[i]==xx) return y[i];
	return 0;
}
double Rand(double l,double r)
{
	double d=rand()%1000/1000.0;
	return d*(r-l)+l;
}
void SA(double T)
{
	double y;
	for(;T>1e-5;T*=0.99)
	{
		double d=Rand(-1,1)*T;
		if(pos+d>x[n]||pos+d<x[1]) continue;
		y=Find(pos+d);
		double h=Calc(pos+d)-y;
		if(h<lst||exp((lst-h)/T)>Rand(0,1))
		{
			ans=fmin(ans,h);
			pos=pos+d;lst=h;
		}
	}
	for(int i=1;i<=1000;i++)
	{	
		double d=T*Rand(-1,1);
		if(pos+d>x[n]||pos+d<x[1]) continue;
		y=Find(pos+d);
		double h=Calc(pos+d)-y;
		lst=h;ans=fmin(ans,lst);
	}
}
int main()
{
	srand(170530233);
	scanf("%d",&n);
	for(int i=1;i<=n;i++) scanf("%d",&x[i]);
	for(int i=1;i<=n;i++) scanf("%d",&y[i]);
	for(int t=1;t<=5;t++)
	{
		int p=rand()%n+1;
		pos=x[p]; lst=Calc(pos)-y[p];
		ans=fmin(ans,lst);
		SA(x[n]-x[1]);
	}
	if(ans<0) ans=0;
	printf("%.3Lf\n",ans);
}

```
~~轻轻松松倒数Rk1~~

![啊啊啊]( https://cdn.luogu.com.cn/upload/pic/23112.png )

---

## 作者：支羽 (赞：3)

并不需要打什么双端队列，一个很简单的单调队列即可，操作和凸包是差不多的。

这题分两步。第一步就是求出满足条件的半平面，这半部分就是"水平可见直线"那题。

第二部就是计算答案。可以证明瞭望塔的横坐标一定在半平面或地面的拐点处，因为中间部分一定没有其中一端优秀。

所以对半平面和地面的拐点分别拎出来讨论一下就好了。





```cpp
#include    <iostream>
#include    <cstdio>
#include    <cstdlib>
#include    <algorithm>
#include    <vector>
#include    <cstring>
#include    <queue>
#include    <complex>
#include    <stack>
#define dob double
using namespace std;
const int N = 310;
const double eps = 0.00000001;
struct Data{
  double k,b;int bel;
  bool operator <(const Data &l)const{
    if(k!=l.k)return k<l.k;
    return b>l.b;
  }
}Line[N];
int n,que[N],st,ed,tot,x[N],y[N];
double Ans=19260817*666.2333;
inline int gi()
{
  int x=0,res=1;char ch=getchar();
  while(ch>'9'||ch<'0'){if(ch=='-')res*=-1;ch=getchar();}
  while(ch<='9'&&ch>='0')x=x*10+ch-48,ch=getchar();
  return x*res;
}
inline bool check(double a,double b){return a-b<eps && b-a<eps;}
int main()
{
  n=gi();
  for(int i=1;i<=n;++i)x[i]=gi();
  for(int i=1;i<=n;++i)y[i]=gi();
  for(int i=2;i<=n;++i){
    double dtx=x[i]-x[i-1];
    double dty=y[i]-y[i-1];
    double k=dty/dtx,b=double(y[i])-x[i]*k;
    Line[++tot]=(Data){k,b,tot};
  }
  sort(Line+1,Line+tot+1);
  st=1;ed=0;
  que[++ed]=1;que[++ed]=2;
  for(int i=3;i<=tot;){
    if(check(Line[i].k,Line[que[ed]].k)){++i;continue;}
    if(ed==1){que[++ed]=i++;continue;}
    dob dtk1=(Line[i].k-Line[que[ed]].k);
    dob dtb1=(Line[que[ed]].b-Line[i].b);
    dob dtk2=(Line[que[ed]].k-Line[que[ed-1]].k);
    dob dtb2=(Line[que[ed-1]].b-Line[que[ed]].b);
    if(dtk1*dtb2>=dtk2*dtb1-eps)--ed;
    else que[++ed]=i++;
  }
  for(int i=1,nl=1;i<=n;++i){
    while(nl<ed){
      dob dtk=Line[que[nl]].k-Line[que[nl+1]].k;
      dob dtb=Line[que[nl+1]].b-Line[que[nl]].b;
      if(dtk*x[i]<=dtb)++nl;
      else break;
    }
    dob ny=Line[que[nl]].k*dob(x[i])+Line[que[nl]].b;
    Ans=min(Ans,ny-dob(y[i]));
  }
  for(int i=st,nx=1;i<ed;++i){
    dob dtk=Line[que[i]].k-Line[que[i+1]].k;
    dob dtb=Line[que[i+1]].b-Line[que[i]].b;
    dob xn=dtb/dtk;
    while(nx<n){
      if(x[nx+1]<=xn)++nx;
      else break;
    }
    dob dtx=x[nx+1]-x[nx],dty=y[nx+1]-y[nx];
    dob ny=y[nx]+dty*(xn-x[nx])/dtx;
    Ans=min(Ans,Line[que[i]].k*xn+Line[que[i]].b-ny);
  }
  printf("%.3lf\n",Ans);
  return 0;
}

```

---

## 作者：kkxhh (赞：2)

首先求出半平面交，可以发现答案一定在特殊点（地上的点以及半平面交点）处产生

这个结论的证明可以根据上下线段的斜率来考虑，在两个特殊点间上下的线段斜率一定是不变的，于是它们的差也是定值，则最优解只会在端点处

代码如下：

```cpp
#include <cstdio>
#include <algorithm>
#include <cmath>
using namespace std;

typedef struct vec{
    double x,y;
    vec() {}
    vec(double _x,double _y):x(_x),y(_y) {}
    vec operator + (vec a) {return vec(x+a.x,y+a.y);}
    vec operator - (vec a) {return vec(x-a.x,y-a.y);}
    vec operator * (double a) {return vec(x*a,y*a);}
    double operator * (vec a) {return x*a.y-y*a.x;}
    double operator ^ (vec a) {return x*a.x+y*a.y;}
}vec;

typedef struct line{
    vec s,t;
    double theta;
}line;

const double eps=1e-8,Pi=acos(-1);
vec p[310],w[310];
line r[310],l[310];
double ans=1e20;
int n,m,cnt,q[310],head=1,tail=0;

bool cmp(line a,line b){
    if(fabs(a.theta-b.theta)>eps) return a.theta<b.theta;
    return (a.s-b.s)*(b.t-b.s)<0;
}

int dcmp(double a) {return ((fabs(a)<=eps)?0:((a>eps)?1:-1));}

vec intersection(line a,line b){
    double s1=(b.s-a.s)*(a.t-a.s),s2=(b.t-a.s)*(a.t-a.s);
    return b.s+(b.t-b.s)*(s1/(s1-s2));
}

double length(vec a) {return sqrt(a.x*a.x+a.y*a.y);}

int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++) scanf("%lf",&p[i].x);
    for(int i=1;i<=n;i++) scanf("%lf",&p[i].y);
    for(int i=1;i<n;i++) r[i].s=p[i],r[i].t=p[i+1],r[i].theta=atan2(p[i+1].y-p[i].y,p[i+1].x-p[i].x);
    sort(r+1,r+n,cmp);
    l[++cnt]=r[1];
    for(int i=2;i<n;i++) if(dcmp(r[i].theta-r[i-1].theta)!=0) l[++cnt]=r[i];
    for(int i=1;i<=cnt;i++){
        while(head<tail && dcmp((l[i].t-l[i].s)*(intersection(l[q[tail]],l[q[tail-1]])-l[i].s))==-1) tail--;
        while(head<tail && dcmp((l[i].t-l[i].s)*(intersection(l[q[head]],l[q[head+1]])-l[i].s))==-1) head++;
        q[++tail]=i;
    }
    while(head<tail && dcmp((l[q[head]].t-l[q[head]].s)*(intersection(l[q[tail]],l[q[tail-1]])-l[q[head]].s))==-1) tail--;
    while(head<tail && dcmp((l[q[tail]].t-l[q[tail]].s)*(intersection(l[q[head]],l[q[head+1]])-l[q[tail]].s))==-1) head++;
    for(int i=head;i<tail;i++) w[++m]=intersection(l[q[i]],l[q[i+1]]);
    int p1=1,p2=1;
    while(p1<=n && p2<=m){
        if(p[p1].x<w[p2].x){
            ans=min(ans,length((l[q[head+p2-1]].s+(l[q[head+p2-1]].t-l[q[head+p2-1]].s)*((p[p1].x-l[q[head+p2-1]].s.x)/(l[q[head+p2-1]].t.x-l[q[head+p2-1]].s.x)))-p[p1]));
            p1++;
        }
        else{
            ans=min(ans,length((p[p1-1]+(p[p1]-p[p1-1])*((w[p2].x-p[p1-1].x)/(p[p1].x-p[p1-1].x)))-w[p2]));
            p2++;
        }
    }
    while(p1<=n) ans=min(ans,length((l[q[head+p2-1]].s+(l[q[head+p2-1]].t-l[q[head+p2-1]].s)*((p[p1].x-l[q[head+p2-1]].s.x)/(l[q[head+p2-1]].t.x-l[q[head+p2-1]].s.x)))-p[p1])),p1++;
    while(p2<=m) ans=min(ans,length((p[p1-1]+(p[p1]-p[p1-1])*((w[p2].x-p[p1-1].x)/(p[p1].x-p[p1-1].x)))-w[p2])),p2++;
    if(n<=2) ans=0.000;
    printf("%.3f",ans);
    return 0;
}
```

---

## 作者：code_hunter (赞：1)

Update 2020/12/27 修复了一点锅。
Update 2020/12/28 删除了不必要的预编译指令。
## 题目大意
- 给定一条折线
- 求折线正上方一个点，使：
	1. 点到折线的竖直距离最小；
   1. 点与任一折点的连线不与折线相交。


## 前置知识
1. 半平面交

## 解法
1. 对于折线上任一一段，该点能看到其端点仅当该点在该线段所在直线的上方。
1. 求出所有满足（1）的半平面的交集，显然，这是一个下凸壳。
1. 假设存在一个下凸壳上的点 A 与一个折点 B ，使得其连线与折线相交。分情况讨论。
    1. 交于折点 C （显然 B C 不相邻），
        易知 B C 中折线中必有不满足假设者。
    1. 交于折线 CD , 易知 B C 中折线中必有不满足假设者。
1. 如下图（画技不好，请见谅）,灰色部分为下凸壳，枚举下凸壳与原折线的折点，可求此时两者间的距离。取min即可。
![图](https://cdn.luogu.com.cn/upload/image_hosting/atl3eeis.png)

## 代码
```cpp
#include <bits/stdc++.h>
#define For(i, a, b) for (int i = a; i <= b; i++)
#define pss pair<string, string>
typedef long long ll;
typedef long double ldb;
ldb ASDF , FGHJ;
#define MAX(a, b) (ASDF = (a)) < (FGHJ = (b)) ? FGHJ : ASDF
#define MIN(a, b) (ASDF = (a)) > (FGHJ = (b)) ? FGHJ : ASDF
const ldb eps = 1e-9;
const int MAXN = 307;
using namespace std;

int N;
struct Node {
    ldb x, y;
    bool operator<(Node b) { return x < b.x; }
} a[MAXN], c[MAXN];
struct line {
    ldb k, b;
    bool operator<(line g) { return k < g.k || (k == g.k && b > g.b); }
} e[MAXN];
int now;
int stk[MAXN], tp;
inline line make_line(Node a, Node b) {  // a.x != b.x
    register line res;
    res.k = (b.y - a.y) / (b.x - a.x);
    res.b = a.y - res.k * a.x;
    return res;
}
inline Node intersect(line a, line b) {
    register Node res;
    res.x = (a.b - b.b) / (b.k - a.k);
    res.y = a.k * res.x + a.b;
    return res;
}
ldb ans = 1e50;

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cin >> N;
    For(i, 1, N) cin >> a[i].x;
    For(i, 1, N) cin >> a[i].y;
    For(i, 1, N - 1) e[i] = make_line(a[i], a[i + 1]);
    sort(e + 1, e + N);
    now = 1;
    For(i, 2, N - 1) if (e[i].k > e[now].k) e[++now] = e[i];
    For(i, 1, now) {
        while (tp > 1 && (e[i].b - e[stk[tp - 1]].b) * (-e[stk[tp]].k + e[stk[tp - 1]].k) <
                             (e[stk[tp]].b - e[stk[tp - 1]].b) * (-e[i].k + e[stk[tp - 1]].k))
            tp--;
        stk[++tp] = i;
    }
    For(i, 1, tp - 1) {
        c[i] = intersect(e[stk[i]], e[stk[i + 1]]);
        if (c[i].x > a[N].x || c[i].x < a[1].x)
            continue;
        register int w = lower_bound(a + 1, a + N + 1, c[i]) - a;
        register line m = make_line(a[w], a[w - 1]);
        ans = MIN(ans, c[i].y - m.k * c[i].x - m.b);
    }
    For(i, 1, N) {
        register int w = lower_bound(c + 1, c + tp, a[i]) - c;
        ans = MIN(ans, e[stk[w]].k * a[i].x + e[stk[w]].b - a[i].y);
    }
    cout << fixed << setprecision(3) << ans + eps << endl;//注意精度！
    return 0;
}
```


---

## 作者：EricWan (赞：0)

很奇妙的题，我想对 $\color{black}{韵}\color{red}{城小管家}$ 大佬的暴力思路进行一定的补充。

想象这样一个画面：假设我们已经确定了塔的地基位置，我们升高这个塔，这个塔最后看见了一个点，那么上一个时刻挡住这个点的一定是一个拐点（反证法证明即可），这个最后被看见的点一定是一个拐点（反证法证明即可）。

然后根据上面的两个结论，我们还可以证明最后一个被看见的点和挡住最后一个被看到的点的点，是相邻的拐点。

然后，我们可以推出：瞭望塔的横坐标一定在两条直线的交点处。这是因为，如果不在交点处，向其中一遍调整肯定不会更劣，所以交点处肯定不会劣于飞交点处。

几个结论都讲完了，我们开始写代码。

先计算出所以给定的直线，枚举交点，对于每一个交点的横坐标，我们再次枚举直线，找到在这个位置建塔的最小绝对海拔，然后求相对海拔的最小值即可。

时间复杂度 $O(n^3)$，常数微大，轻松通过。

---

## 作者：Lofty (赞：0)

### 前言：

头皮发麻。

### 正题：

由于半平面交的任何一个元素都可以完全看到这条直线的任何位置，而题目要求一个点能看到所有直线的位置，显然是半平面交。

所以，我紧急学了半天计算几何入门和半平面交，总算把这道题过了。

这道题，我们可以把折线上的点按从左到右两两相连，构成 $n-1$ 条有向直线。显然瞭望塔的最顶端在所有直线的左半平面交，否则将无法看到其中部分直线的部分位置。

那我们求完半平面交，就该考虑什么时候可能成为最优方案。先把问题简化，给出两条直线 $y_1$ 和 $y_2$，求 $x$ 等于几时，有 $\min\{\left|y_1-y_2\right|\}$。如果两条线不平行，显然时交点处最小。那如果是不相交的线段呢？就看看两条线段的端点位置，比较一下即可。

回到这道题，最优的高度显然在半平面交的下突壳上，也就转化为两条折线的 $\min\{\left|y_1-y_2\right|\}$。再之后，可以进一步把折线转化为许多线段的端点首尾相接，就简化为上面简单版的问题了，取所有答案的 $min$ 即可。

**注意细节！**

### 代码：
```
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
using namespace std;
#define TP template<typename T>
#define TP_ template<typename T,typename ... T_>
TP void read(T &x)
{
	x=0;int f=0;char ch=getchar();
	for(;ch<'0'||ch>'9';ch=getchar())ch=='-'&&(f=1);
	for(;ch>='0'&&ch<='9';ch=getchar())x=(x*10)+(ch^48);
	double l=0.1;
	if(ch=='.')
		for(ch=getchar();ch>='0'&&ch<='9';ch=getchar())x=x+l*(ch^48),l/=10;
	f&&(x=-x);
}
TP_ void read(T &x,T_&...y){read(x);read(y...);}
TP void write(T x){x<0&&(putchar('-'),x=-x);static int sta[35];int top=0;do{sta[++top]=x%10,x/=10;}while(x);while(top)putchar(sta[top--]^48);}
TP void writeln(const T x){write(x);puts("");}
TP void writesp(const T x){write(x);putchar(32);}
TP_ void writeln(const T x,T_ ...y){writesp(x);writeln(y...);}
using LL=long long;
constexpr double eps=1e-6;
constexpr double inf=1e18;
struct Point{double x,y;};
struct Line{Point s,e;};
Point operator +(const Point &a,const Point &b)
{
	return {a.x+b.x,a.y+b.y};
}
Point operator -(const Point &a,const Point &b)
{
	return {a.x-b.x,a.y-b.y};
}
Point operator *(const Point &a,const double &t)
{
	return {a.x*t,a.y*t};
}
double operator *(const Point &a,const Point &b)
{
	return a.x*b.y-a.y*b.x;
}
double angle(const Line &a)//arctan
{
	return atan2(a.e.y-a.s.y,a.e.x-a.s.x);
}
bool cmp(const Line &a,const Line &b)//极角+左侧排序，后面若有平行直线可以直接排除
{
	double A=angle(a),B=angle(b);
	return fabs(A-B)>eps?A<B:(a.e-a.s)*(b.e-b.s)<0;
}
Point cross(const Line &a,const Line &b)//交点
{
	Point u=a.s-b.s,v=a.e-a.s,w=b.e-b.s;
	double t=u*w/(w*v);
	return a.s+v*t;
}
bool right(const Line &a,const Line &b,const Line &c)
{
	Point p=cross(b,c);
	return (a.e-a.s)*(p-a.s)<0;//叉积
}
double get_y(const Line &a,const double &x)
{
	double k=(a.e.y-a.s.y)/(a.e.x-a.s.x);
	double b=a.s.y-a.s.x*k;
	return k*x+b;
}
constexpr int N=3e2+5;
Point p[N];
Line a[N],b[N],q[N];
int cnt,n;
int find_line(const double &x,const int &l,const int &r,const Line c[])//找到对应x的线段
{
	int L=l,R=r;
	while(L<R)
	{
		int mid=(L+R+1)>>1;
		if(cross(c[mid-1],c[mid]).x>=x)
			R=mid-1;
		else
			L=mid;
	}
	return L;
}
double half_plane()
{
	double ans=inf;//取最大值，double范围比long long还大，取大点没问题，最大值不需要精度
	sort(a+1,a+cnt+1,cmp);
	int l,r;
	l=r=1;q[1]=a[1];
	for(int i=2;i<=cnt;i++)
	{
		if(angle(a[i])-angle(a[i-1])<eps)continue;
		while(l<r&&right(a[i],q[r],q[r-1]))r--;
		while(l<r&&right(a[i],q[l],q[l+1]))l++;
		q[++r]=a[i];
	}
	while(l<r-1&&right(q[l],q[r],q[r-1]))r--;//求半平面交
	//这里要写为l<r-1，因为上面我把重交点的也弹出了，而这里又是无限半平面交，可能最后只剩两条直线了，最后就被弹了
	for(int i=1;i<=n;i++)//枚举折线上的拐点
	{
		int num=find_line(p[i].x,l,r,q);
		ans=min(ans,get_y(q[num],p[i].x)-p[i].y);
	}
	for(int i=l;i<r;i++)//枚举半平面交的下突壳的拐点
	{
		Point a=cross(q[i],q[i+1]);
		int num=find_line(a.x,1,n,b);
		ans=min(ans,a.y-get_y(b[num],a.x));
	}
	return ans>-eps?fabs(ans):ans;//防-0
}
int main()
{
	read(n);
	for(int i=1;i<=n;i++)
		read(p[i].x);
	for(int i=1;i<=n;i++)
		read(p[i].y);
	for(int i=1;i<n;i++)
		a[++cnt]={p[i],p[i+1]},b[cnt]=a[cnt];
	printf("%.3lf\n",half_plane());
	return 0;
}
```

---


# [HNOI2011] 数矩形

## 题目描述

最近某歌手在研究自己的全球巡回演出计划，他将所有心仪的城市都用平面上的一个点来表示，并打算从中挑选出 4 个城市作为这次巡回演出的地点。

为了显示自己与众不同，他要求存在一个矩形使得挑选出的 4 个点恰好是这个矩形的 4 个顶点，并且希望这个矩形的面积最大。

这可急坏了其经纪人，于是他向全球歌迷征集方案，当然你这位歌迷一定不会错过这个机会。


## 样例 #1

### 输入

```
8
-2 3
-2 -1
0 3
0 -1
1 -1
2 1 
-3 1 
-2 1
```

### 输出

```
10```

# 题解

## 作者：Gmt丶FFF (赞：21)

可以知道，矩形的对角线长度相等，且中点重合。

那么我们枚举每两点，然后对所有线段以长度为第一关键字，以中点的横坐标为第二关键字，纵坐标为第三关键字排序，对于每一条线段，前后暴力枚举出长度相等且中点相等的另一条条线段，求出面积即可。

由于矩形上的点四点共圆，由于三不共线点确定一圆，在去除相等点的情况下，圆最多有 $O(n^3)$，现想让四点共圆的点数尽量多，那么对于共圆的四点，最多只有两个点可以继承到下一个四点共圆里，且需消耗两点。可以感性理解发现网格图时取得最大值，那么此时圆的数量为 $O(n^2)$，所以暴力枚举不会炸。

时间复杂度瓶颈在于排序，复杂度：$O(n^2\times \log_2^2(n^2))$。

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
#define int long long
using namespace std;
const int N=1505;
int n,cnt;
struct node
{
	int x,y;
}a[N];
inline bool cmp2(node x,node y)
{
	if(x.x==y.x)return x.y<y.y;
	return x.x<y.x;
}
inline bool cmp3(node x,node y)
{
	if(x.x==y.x&&x.y==y.y)return 1;
	return 0;
}
struct node2
{
	int x,y,len,px,py;
}p[N*N];
inline bool cmp(node2 x,node2 y)
{
	if(x.len==y.len)
	{
		if(x.px==y.px)return x.py<y.py;
		return x.px<y.px;
	}
	return x.len<y.len;
}
inline int P(int x)
{
	return x*x;
}
inline int calc(__int128 x)
{
	__int128 l=0,r=1e18;
	while(l<r)
	{
		__int128 mid=(l+r)>>1;
		if(mid*mid<x)l=mid+1;
		else r=mid;
	}
	return (int)l;
}
signed main()
{
	freopen("num.in","r",stdin);
	freopen("num.out","w",stdout);
	scanf("%lld",&n);
	for(int i=1;i<=n;i=-~i)scanf("%lld%lld",&a[i].x,&a[i].y);
	sort(a+1,a+1+n,cmp2);
	n=unique(a+1,a+1+n,cmp3)-a-1;
	for(int i=1;i<=n;i=-~i)
	{
		for(int j=i+1;j<=n;j=-~j)
		{
			p[++cnt]={i,j,P(a[i].x-a[j].x)+P(a[i].y-a[j].y),a[i].x+a[j].x,a[i].y+a[j].y};
		}
	}
	sort(p+1,p+1+cnt,cmp);
	__int128 ans=0;
	for(int i=1;i<=cnt;i++)
	{
		for(int j=i+1;j<=cnt;j++)
		{
			if(p[i].len==p[j].len&&p[i].px==p[j].px&&p[i].py==p[j].py)
			{
				int num1=P(a[p[i].x].x-a[p[j].x].x)+P(a[p[i].x].y-a[p[j].x].y);
				int num2=P(a[p[i].x].x-a[p[j].y].x)+P(a[p[i].x].y-a[p[j].y].y);
				__int128 num=(__int128)num1*num2;
				ans=max(ans,num);
			}
			else break;
		}
	}
	int res=calc(ans);
	printf("%lld",res); 
	return 0;
}
```


---

## 作者：Cells (赞：21)

蒟蒻的第一篇紫题题解，望大家多多包涵不足。

感谢 [lht](https://www.luogu.com.cn/user/858094) 大佬提供帮助。

[原题传送门](https://www.luogu.com.cn/problem/P3217)

#### 前置知识

1. 矩形性质。
2. 两点距离公式：对于 $P_1(x_1 , y_1)$，$P_2(x_2 , y_2)$，有 $d = \sqrt{(x_1-x_2)\times(x_1-x_2)+(y_1-y_2)\times(y_1-y_2)}$。
3. 中点坐标公式：对于 $P_1(x_1 , y_1)$，$P_2(x_2 , y_2)$，有 $P_{mid}(\frac{x_1+x_2}{2},\frac{y_1+y_1}{2})$。

把这道题想简单一点，暴力枚举矩形的每一个点，判断这四个点能不能满足矩形的性质。

$O(n^4)$ 的暴力，很简单也会 ~~TLE~~，这里不贴代码了。

#### 优化思路

矩形的性质有：

1. 矩形对角线相等。
2. 矩形对角线互相平分。

发现点与点之间的匹配实际上是线段与线段之间的匹配，所以根据矩形有关对角线的性质，可以两层循环枚举矩形对角线，进行线段匹配。

另外，对线段排序。因为排完序以后，关键字具有单调性，可以记录上一次失配的位置，从失配处开始重新匹配，就能避免不必要的匹配。

时间复杂度就成了排序的复杂度：$O(n^2 \log^2n)$。

#### 代码实现

1. 预处理 $n^2$ 条线段，同时记录线段的线段两端点坐标，线段中点坐标，线段的长度。

2. 线段排序。

3. 线段匹配。

#### 注意事项

1. 开 `long long`。
2. 使用 `sqrtl` 好像会错，只能使用 `sqrt`。
3. 我在计算线段长度时没有开根，储存长度平方，最后开根，防止精度丢失。

**Code**

```c++
# include <bits/stdc++.h>
using namespace std;

typedef long long LL;
typedef long double LDB;

const int N = 1510;

int n, cnt, fail;
LL ans;

LL s(LL x){
	return x * x;
}

LL dis(LL x1, LL y1, LL x2, LL y2){ // 两点距离 
	return s(x1 - x2) + s(y1 - y2);
}

struct point{ // 点的信息 
	LL x, y;
}p[N];

struct line{ // 线段信息 
	LL x1, y1, x2, y2, midx, midy, len; //midx，midy是中点坐标，len是线段长度 
}l[N * N];

bool cmp(line a, line b){
	if(a.midx == b.midx){
		if(a.midy == b.midy) return a.len < b.len;
		return a.midy < b.midy;
	}
	
	return a.midx < b.midx;
}

int main(){
	ios::sync_with_stdio(0); 
	cin.tie(0), cout.tie(0);
	
	cin >> n;
	
	for(int i = 1; i <= n; i ++) cin >> p[i].x >> p[i].y;
	
	for(int i = 1; i <= n; i ++){
		for(int j = i + 1; j <= n; j ++){ // 预处理线段 
			cnt ++;
			l[cnt].x1 = p[i].x, l[cnt].x2 = p[j].x;
			l[cnt].y1 = p[i].y, l[cnt].y2 = p[j].y;	
			l[cnt].midx = p[i].x + p[j].x;
			l[cnt].midy = p[i].y + p[j].y;
			l[cnt].len = dis(p[i].x, p[i].y, p[j].x, p[j].y);
		}
	}
	
	sort(l + 1, l + 1 + cnt, cmp);
	
	fail = 0; // 失配点 
	for(int i = 1; i <= cnt; i ++){
		if(l[fail].midx != l[i].midx || l[fail].midy != l[i].midy){
			fail = i; // 更新失配点 
			continue; 
		}
		 
		for(int j = fail; j < i; j ++){ // 注意从失配处开始循环，对角线已经平分 
			if(l[i].len != l[j].len) continue; // 对角线相等 
			ans = max(ans, (LL)(sqrt(s(l[i].x1 - l[j].x1) + s(l[i].y1 - l[j].y1)) * sqrt(s(l[i].x1 - l[j].x2) + s(l[i].y1 - l[j].y2)))); //更新答案
		}
	}
	
	cout << ans;
	
	return 0;
}
```

**温馨提示：别抄题解。**

大家的支持就是本蒟蒻坚持最大的动力。

完结撒花！

---

## 作者：Rich1 (赞：13)

#### ~~非正解~~
本来我想找个 vector 存每条线段的中点，找个 map 建立中点到以该点为中点的点对集合，遍历就完事。好吧，妥妥的近乎 $O(n^4)$ 的~~暴力~~。
### 正解
根据两条对角线**长度相等且互相平分**的四边形是矩形这个定理，刚才用中点为分类依据有问题，那就选择以**点与点连线的长度**为分类依据。

实际上，构造中点聚集在几个点的数据很容易（大家看中点坐标公式，分析一下其本质），但长度都相等的数据很难，所以除非人为，随机数据不可能卡掉。

#### 实现正解
首先枚举所有的连线，此时通过两个端点，可以算出我们需要的长度，中点坐标这些信息。

现在我们想让长度相同的连线靠在一起，中点相同的也靠在一起。考虑排序，控制小于号的返回值即可。

即第一关键字是**连线长度**，第二关键字是**中点横坐标**，第三关键字是**中点纵坐标**。

那么遍历所有边，每条边向后所有**长度相等且中点坐标相同**的连线均有可能更新答案。

#### 几点注意事项

1. 十年 OI 一场空，不开 long long 见祖宗（对应代码 flag1）。
2. 最好中点不除以 2，连线长度不开根号，避免浮点数带来的精度丢失（对应代码 flag2）。
3. 注意输出**非负整数**（对应代码 flag3）。
#### 疑问解答
Q：倒数第六行为什么是`ans = max(ans, (int)sqrt(t1 * t2));`？

A：$\sqrt{a} \times \sqrt{b} = \sqrt{a \times b}$ ，我在最后开根号的。

```cpp
//P3217 [HNOI2011] 数矩形
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef long double ldb;
#define int ll//flag1
#define double ldb
const int N = 1510;
int n;
struct point {
	int x, y;
} p[N];
struct line {
	point start, end, mid;//首，尾，中点
	int len;//长度的平方  flag2
	//第一关键字是长度，第二关键字是中点横坐标，第三关键字是中点纵坐标
	bool operator < (const line &b) const {//排序的小于号
		if(len != b.len) return len < b.len;
		if(mid.x != b.mid.x) return mid.x < b.mid.x;
		return mid.y < b.mid.y;
	}
} l[N * N >> 1];
int num;
int dis(point a, point b) {//算距离的平方  flag2
	return (a.x - b.x) * (a.x - b.x) + 
		   (a.y - b.y) * (a.y - b.y);
}
int ans;
signed main() {
	ios::sync_with_stdio(false);
	cin.tie(0), cout.tie(0);
	cin >> n;
	for(int i = 1; i <= n; ++i)
		cin >> p[i].x >> p[i].y;
	for(int i = 1; i <= n; ++i)//枚举每一条连线
	{
		for(int j = i + 1; j <= n; ++j)
		{
			l[++num].start = p[i];
			l[num].end = p[j];
			l[num].mid = {p[i].x + p[j].x, p[i].y + p[j].y};//flag2
			l[num].len = dis(p[i], p[j]);
		}
	}
	sort(l + 1, l + num + 1);//排序
	for(int i = 1; i <= num; ++i)
	{
		for(int j = i + 1; true; ++j)
		{
			//排过序保证单调了，直接break就好
			if(l[j].len != l[i].len) break;//长度不等不行
			if(l[j].mid.x != l[i].mid.x) break;//中点横坐标不等不行
			if(l[j].mid.y != l[i].mid.y) break;//中点纵坐标不等也不行
			double t1 = dis(l[i].start, l[j].start);//大家画图理解
			double t2 = dis(l[i].start, l[j].end);
			ans = max(ans, (int)sqrt(t1 * t2));//flag3
		}
	}
	cout << ans;
	return 0;
}
```
部分神犇嫌弃速度慢，可以采用 fread 快读（优化一半的时间），将不等号改写成异或等卡常措施。为了可读性，本蒟蒻就不再演示和带坏众人了。

放在最后的是，这是本蒟蒻的第**一**篇题解，缺点望众人海涵并指出。有疑问请在评论区提出。

---

## 作者：lost_forst (赞：8)

## 亿内内数学知识

先来复习一下有关矩形的知识：

~~初中数学都会吧~~

> 1. 两条对角线相等；
> 
> 2. 两条对角线互相平分；
> 
> 3. 两组对边分别平行；
> 
> 4. 两组对边分别相等；
> 
> 5. 四个角都是直角；

考虑我们能通过一个直观的数据——长度反映的性质：

> 1. 两条对角线相等；
> 
> 2. 两条对角线互相平分（中点一致）；
> 
> 3. 两组对边分别相等；

提取出其中有共性的部分：

> 1. **两条对角线**相等；
> 
> 2. **两条对角线**互相平分（中点一致）；

我们突然发现对角线是很容易求的，而整道题最多有 $(n \times (n-1))\div 2\ (n\leq1500)$ 条边，事情似乎变得简单起来……

我们判断所有两两一组的边是否满足上述两个条件，若满足，则它们就是一个矩形的两根对角线，至于剩下的求矩形面积……

$$S=\mid(x1 \times y2+x2 \times y3+x3 \times y1-x2 \times y1-x3 \times y2-x1 \times y3)  \div 2\mid$$

这是一个求坐标轴内任意三角形的公式，然后就……你懂的

~~你以为这就结束了？~~

> "我们判断**所有**两两一组的边是否满足上述两个条件"

兄啊，这不 TLE 啊（恼）：最坏情况一共有 $(1500 \times (1500-1)) \div 2=1124250$ 条边，而你要两两枚举他们……

考虑一些怪异的优化：

 我们的复杂度很大部分来源于是否为矩形那一长串的判断，那么我们最好让这个判断少进行几次；
 
 
 考虑匹配过程：我们的边是零散的，所以对一条边需要枚举所有其他边；
 
 
 那么有没有什么办法让它们不零散呢……
 
 
 答曰：排序；
 
 
 让中点一样，长度一样的边放在一起，当有边失配时，其后所有的边都不可能匹配，直接跳出即可；
 
 
 ~~啊？你问菊花图怎么办？~~
 
 
 ~~你在网格图上画几个圆逝逝？有几个边与格点的重合部分……~~
 
 

至于精度问题，你为啥要去开方或者做除法呢？对于作比较来说，运算前和运算后不是一样的吗……

AC code：

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef double db;
const int N=1501;
int n,cnt;
ll ans,tmp;
ll loc[N][2];
struct node{
	ll sum,xx,yy;
	ll xf,yf,xs,ys;
}lin[N*N];
inline bool cmp(node a,node b){
	if(a.sum<b.sum) return 1;
	if(a.sum==b.sum){
		if(a.xx<b.xx) return 1;
		else if(a.xx==b.xx&&a.yy<b.yy) return 1;
	}
	return 0;
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;++i) scanf("%lld%lld",&loc[i][0],&loc[i][1]);
	for(int i=1;i<n;++i){
		for(int j=i+1;j<=n;++j){
			lin[++cnt].sum=(loc[i][0]-loc[j][0])*(loc[i][0]-loc[j][0])+(loc[i][1]-loc[j][1])*(loc[i][1]-loc[j][1]);
			lin[cnt].xx=loc[i][0]+loc[j][0];
			lin[cnt].yy=loc[i][1]+loc[j][1];
			lin[cnt].xf=loc[i][0];lin[cnt].xs=loc[j][0];
			lin[cnt].yf=loc[i][1];lin[cnt].ys=loc[j][1];
		}
	}
	sort(lin+1,lin+cnt+1,cmp);
	for(int i=1;i<cnt;++i){
		for(int j=i+1;j<=cnt;++j){
			if(lin[i].sum==lin[j].sum&&lin[i].xx==lin[j].xx&&lin[i].yy==lin[j].yy){
					tmp=lin[i].xf*lin[i].ys+lin[i].xs*lin[j].yf+lin[j].xf*lin[i].yf-lin[i].xs*lin[i].yf-lin[j].xf*lin[i].ys-lin[i].xf*lin[j].yf;
					tmp=tmp>0?tmp:-tmp;
					ans=max(ans,tmp);
			}else break;
		}
	}
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：xtx1092515503 (赞：7)

严格 $O(n^2\log n)$ 的做法。

------------

现行的大多数题解都是枚举两条对角线进行处理的——这就导致必须 $O(n^{2.5})$ 地枚举完全部的合法矩形进行判断。但如果我们转换思路，不枚举对角线，而枚举矩形的一对平行的边呢？

考虑两条线段如何才是一对合法的矩形边。它们必须满足如下三点：

1. 斜率相等。这个可以通过叉积简单计算（线段所代表的向量叉积为 $0$ 则斜率相等）。

2. 长度相等。这个也可以简单计算。

3. 构成直角。这个可以通过计算夹角加以比较（直角则有点积为 $0$）。

任意两条满足上述三个条件的线段，均可构成一个合法的矩形。然而，对于一组斜率相等、长度相等、两两构成直角的线段，只有最边缘的两条所形成的矩形具有最大的面积。

于是我们内部再按照夹角是否 $\leq180^\circ$ 加以排序，具体可以通过叉积大小加以比较。

然后就排序后使用双针找到一段合法段中最左方和最右方的两条线段，并更新答案即可。

瓶颈在于排序。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
int n,m;
ll res;
struct Vector{
	int x,y;
	Vector(){}
	Vector(int X,int Y){x=X,y=Y;}
	friend Vector operator +(const Vector &u,const Vector &v){return Vector(u.x+v.x,u.y+v.y);}
	friend Vector operator -(const Vector &u,const Vector &v){return Vector(u.x-v.x,u.y-v.y);}
	friend ll operator &(const Vector &u,const Vector &v){return 1ll*u.x*v.y-1ll*u.y*v.x;}//cross times
	friend ll operator |(const Vector &u,const Vector &v){return 1ll*u.x*v.x+1ll*u.y*v.y;}//point times
	ll operator ~()const{return 1ll*x*x+1ll*y*y;}//the modulo of a vector
	void read(){scanf("%d%d",&x,&y);}
	void print(){printf("(%d,%d)",x,y);}
}p[1510];
typedef Vector Point;
struct Line{
	Point x,y;
	Vector z;
	Line(){}
	Line(Point X,Point Y){x=X,y=Y,z=Y-X;}
	friend bool operator <(const Line &u,const Line &v){
		if(u.z&v.z)return (u.z&v.z)<0;
		if(~u.z!=~v.z)return ~u.z<~v.z;
		if((u.x-v.x)|v.z)return ((u.x-v.x)|v.z)<0;
		return ((u.x-v.x)&v.z)<0;
	}
	friend bool operator ==(const Line &u,const Line &v){
		if(u.z&v.z)return false;
		if(~u.z!=~v.z)return false;
		if((u.x-v.x)|v.z)return false;
		return true;
	}
}l[2250100];
typedef Line Segment;
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++)p[i].read();
	for(int i=1;i<=n;i++)for(int j=1;j<=n;j++)if(p[i].y<p[j].y||(p[i].y==p[j].y&&p[i].x<p[j].x))l[++m]=Segment(p[i],p[j]);
	sort(l+1,l+m+1);
	for(int i=1,j=1;i<=m;i=j){
		while(j<=m&&l[i]==l[j])j++;
		res=max(res,abs(l[i].z&(l[i].x-l[j-1].x)));
	}
	printf("%lld\n",res);
	return 0;
}
```

---

## 作者：lava__44 (赞：6)

# P3217 [HNOI2011] 数矩形

### 前言

[提交记录](https://www.luogu.com.cn/record/list?pid=P3217)

本题其实并不是非常难想，那么为什么本蒟蒻还交了那么多发呢？

`cal` 函数求平方的时候传值未开 `long long `，我谔谔。

### 正文

题面省流：给定 $n$ 个点求最大举行的面积，矩形的边可以**不与坐标系垂直**。

如果每次枚举矩形的四个点的话，$O\left(n^4\right)$ 可以得到 $20\%$ 的美妙暴力分。

*看看正解？*

要求矩形我们可以利用一些优美的数学性质：

> 矩形的对角线相等且互相平分。

也就是说我们可以枚举对角线，判断它们的中点是否重合，长度是否相等。

在 $n\leqslant 1500$ 的情况下可 $O\left(n^2\right)$ 枚举所有对角线，然后排序，排序主要关键字为坐标，次要关键字为权值。

对角线数量有 $\dfrac{n\left(n-1\right)}{2}$ 条，相当于 $O\left(n^2\right)$ 遍历对角线，任意两条中点相同并且长度相同的对角线均计算其组成矩形面积并更新最大值。

一张图解决如何求面积：

![](https://cdn.luogu.com.cn/upload/image_hosting/g734wapy.png)

井中掘兰：

Think twice,Code once.

***

### 贴码

```c++
#include<bits/stdc++.h>
#define MAXN 1510
using namespace std;
//ifstream is("num.in",ios::in);
//ofstream os("num.out",ios::out);
//#define cin is
//#define cout os
long long n,x[MAXN],y[MAXN],tote;
long long ans=0;
struct Edge{
	long long onex,oney,twox,twoy;
	long long midx,midy;
	long long dist;
}e[MAXN*MAXN];
bool cmp(Edge x,Edge y){
	if(x.midx==y.midx){
		if(x.midy==y.midy) return x.dist<y.dist;
		return x.midy<y.midy;
	}
	return x.midx<y.midx;
}
inline long long cal(long long x){
	return x*x;
}
int main(){
	ios::sync_with_stdio(0);
	cin>>n;
	for(int i=1;i<=n;i++) cin>>x[i]>>y[i];
	for(int i=1;i<=n;i++){
		for(int j=1+i;j<=n;j++){
			e[++tote].onex=x[i]; e[tote].oney=y[i];
			e[tote].twox=x[j]; e[tote].twoy=y[j];
			e[tote].midx=x[i]+x[j];
			e[tote].midy=y[i]+y[j];
			e[tote].dist=cal(x[i]-x[j])+cal(y[i]-y[j]);
		}
	}
	sort(e+1,e+tote+1,cmp);
	int st=0;
	for(int i=1;i<=tote;i++){
		if(e[i].midx==e[st].midx&&e[i].midy==e[st].midy){
			for(int j=st;j<=i;j++){
				if(e[i].dist==e[j].dist)
				ans=max(ans,(long long)(sqrt( cal(abs(e[i].onex-e[j].onex))+cal(abs(e[i].oney-e[j].oney)) )*sqrt( cal(abs(e[i].onex-e[j].twox) ) + cal(abs(e[i].oney-e[j].twoy) ) )));
			}
		}
		else if(e[i].midx!=e[st].midx||e[i].midy!=e[st].midy)st=i;
	} 
	cout<<ans;
	return 0;
}
/*
8
-2 3
-2 -1
0 3
0 -1
1 -1
2 1 
-3 1 
-2 1
*/
```

---

## 作者：wwwwwza (赞：5)

由于其他 dalao 的题解本蒟蒻看不懂，所以写了这篇比较好理解的题解。
## 前置知识 
1. 只有当两条线段的中点重合，线段长度相同，才会构成矩形。  
2. 勾股定理求线段 $AB$ 的长度：$\sqrt{\left|X_A-X_B\right|^2+\left|Y_A-Y_B\right|^2}$。  
3. 此代码要开吸氧优化，时间能下降到原时间的 $\frac{1}{3}$，还是比较可观的。

## 步骤   
### 一、储存每条线段的信息
1. 在这 $n$ 个点中，一共有 $\frac{n(n-1)}{2}$ 条线段，以它们的长度为分类的标准，储存该线段的两个节点的 $x,y$ 坐标和中点的坐标。  
2. 线段长度的计算：线段长度可用勾股定理求，但求出的可能是无理数，所以不开根号存储更好。 

### 二、计算矩形面积
1. 对于线段长度相同的线段，以中点坐标为根据排序，找到中点坐标相同的几条线段，计算其中任意两条线段组成的矩形的面积。   
2. 既然找到了两条线段共四个点，也可用勾股定理求出矩形的长和宽，这样可求出此矩形的面积。  

### 三、输出
选出矩形面积中最大的即可。

## 代码
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N=1.5e3+10;
const int M=1e6+10;
int n,x[N],y[N],cnt=0,ans=0;
struct node{//存储线段两个端点和中点的坐标 
	int x1,y1,x2,y2;
	long double mid_x,mid_y;
};
map<int,int>mp;
vector<node>g[M];
int rec(int p){//辅助勾股定理的计算 
	return abs(p)*abs(p);
}
bool cmp(node p,node q){//按中点排序 
	if(p.mid_x==q.mid_x)return p.mid_y<q.mid_y;
	return p.mid_x<q.mid_x;
}
signed main(){
	cin >>n;//输入 
	for(int i=1;i<=n;i++){
		cin >>x[i]>>y[i];
	}
	for(int i=1;i<=n-1;i++){//存储线段 
		for(int j=i+1;j<=n;j++){
			int len=rec(x[i]-x[j])+rec(y[i]-y[j]);//勾股定理 
			if(!mp[len])mp[len]=++cnt;
			g[mp[len]].push_back({x[i],y[i],x[j],y[j],(x[i]+x[j])/2.0,(y[i]+y[j])/2.0});
		}
	}
	for(int i=1;i<=cnt;i++){//计算矩形面积 
		sort(g[i].begin(),g[i].end(),cmp);
		for(int j=0;j<g[i].size();j++){
			//判断两条线段的中点是否相同
			int id=j;
			while(g[i][id].mid_x==g[i][j].mid_x&&g[i][id].mid_y==g[i][j].mid_y&&id<g[i].size()){
				id++;
			}
			for(int k=j;k<id-1;k++){//计算矩形面积 
				for(int l=k+1;l<=id-1;l++){
					node p=g[i][k],q=g[i][l];
					int a=rec(p.x1-q.x1)+rec(p.y1-q.y1);
					int b=rec(p.x1-q.x2)+rec(p.y1-q.y2);
					ans=max(ans,(int)(sqrt(a)*sqrt(b)));//求最大值 
					//这里直接求长的平方乘宽的平方会炸 
				}
			}
		}
	}
	cout <<ans;//输出 
	return 0;
}
```

---

## 作者：xxbbkk (赞：5)

# 题目

[Luogu](https://www.luogu.com.cn/problem/P3217)

[darkbzoj](https://darkbzoj.tk/problem/2338)

# Sol

提供一个不用高级计算几何技巧的写法。

感觉和[$Atcoder\ ABC220G$](https://atcoder.jp/contests/abc220/tasks/abc220_g)比较相似。

把全部的直线求出来。

考虑两条直线满足什么条件才会构成一个矩形的对边：

- 两条直线的中垂线完全相同
- 原本的两条直线不重合
- 两条直线长度相同

那就好办了：把所有的$\dfrac{n\cdot(n-1)}{2}$条直线根据中垂线排序，同时设直线的中点为这条直线的**标志点**，两条中垂线相同且长度相同的直线若中点不同则可以构成矩形。

在所有中垂线相同的直线中，找到标志点横坐标的差最大的两条直线，算出面积，最后取最大值。

复杂度$O(n^2log_2n)$。

如何求点$(x_i,y_i)$和点$(x_j,y_j)$所成的直线的中垂线？

点$(x_i,y_i)$和点$(x_j,y_j)$所成的直线的斜率：$k_1=\dfrac{y_j-y_i}{x_j-x_i}$

所以中垂线的斜率为$k_2=\dfrac{-1}{k_1}$

再根据中垂线经过中点$(\dfrac{x_i+x_j}{2},\dfrac{y_i+y_j}{2})$即可求出截距$b$。

还有一个细节：若中垂线平行于$y$轴，就把$k$设为无穷大，$b$设为$\dfrac{x_i+y_j}{2}$。

# Code

在[这里](https://www.cnblogs.com/xxbbkk/p/15425202.html)

# 完结撒花❀

---

## 作者：pinewood (赞：3)

这是一道对本蒟蒻来说比较难的题，经过了好几次改错才做出来，关键其实在于你到底敢不敢打，因为复杂度需要你的勇气。

#### $20$ 分思路

这也是像我一样的普通选手在测试的时候的思路，我们发现四层枚举 for 循环是会被卡死的，甚至 $20$ 分暴力分数都拿不到。但是大家还记得初中时做过的那种矩形存在性的题吗，其实可以只枚举三个点，另外的一个点其实也就确定了，那么考虑用哈希表存储点的信息，然后就可以用你 $n^{3}$ 的复杂度拿到暴力分数了。

#### 优化思路

其实还是考察数学知识的问题。我们来观察矩形的特点。
矩形具有对角线等长，且对角线互相平分的特点。所以，我们处理出 $n ^{2}$ 条线段，记录每条线段两个端点的信息，以及线段长度和线段中点，对于每两条线段，如果长度相等，中点相等，则更新答案。但我们发现，其实还有诸多问题。

#### 通往正解之路

其实上述思路就是正解，只不过只像优化的思路那样想，还会有问题。

##### 复杂度

我们可以计算这样的复杂度仍然很高，考虑优化。可以对线段的长度先排序，就会得到有序的以长度为关键字排序的线段序列（不保险的话可以以中点坐标为第 2 关键字进行排序，实测没有第二关键字容易被卡常），然后不符合匹配情况时直接跳出就行了。这样能节省不少时间。但还是有问题：万一长度相同的线段有很多条呢？三点可以确定一个圆（不共线），而这样算的话，圆的数量其实最多也就 $n^{3}$，而要在圆上的点尽量的多，不得不让圆上继承更多公共的点，而每个圆最多能提供两个公共点，也就是说圆的数量不超过 $n^{2}$ 了（有点口糊但是感谢 @Gmt丶FFF 给我讲解的证明，大家可以看他的博客也可以。
这样一来，复杂度的问题就解决了。

##### 如何拒绝精度问题

我在平时打代码的时候十分讨厌这种数学问题带来的精度问题，所以我在不断探索和请教中得出了两个方法。其一是在求中点和线段长度时不必开方或者除以 $2$ 了，直接保留，可以避免精度问题。第二个就是求矩形面积的问题了。在求矩形面积时，我们不可避免要面临精度问题，但我有妙计！上过高中的各位应该都知道由平面向量推导的三角形坐标面积公式：

$$S=\frac{1}{2}\times \left|x1\times y2+x2\times y3+x3\times y1-x1\times y3-x2\times y1-x3\times y2\right|$$

那么自然而然矩形的便是：

$$S=\left|x1\times y2+x2\times y3+x3\times y1-x1\times y3-x2\times y1-x3\times y2\right|$$ 

其中三个点的坐标可以随便取。这样一来就完美解决了精度问题。

##### 最后的挣扎

在 debug 过程中，我的最后一步错在了没有 ```define int long long```。我想提醒的是，如果真的脑子糊了想不清楚或者还怕出问题，先放上 ```define int long long``` 再说吧。（如果你在卡常当我没说）最后是代码：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
template< typename T > inline void read(T &x){
	char c=getchar();x=0;int f=0;
	for(;!isdigit(c);c=getchar()) f|=(c=='-');
	for(;isdigit(c);c=getchar()) x=((x<<3)+(x<<1)+(c^48));
	x=f?-x:x;
}
int n;
struct node{
	int ax,ay;
	int bx,by;
	long long d;
	long long cx,cy;
};
node l[2250010];
int tot;
struct Node{
	int x,y;
};
Node wsl[1510];
bool cmp(node a,node b){
	if(a.d==b.d)
	{
		if(a.cx==b.cx)return a.cy>b.cy;
		return a.cx>b.cx;
	}
	return a.d>b.d;
}
long long ans=0;
signed main(){
	scanf("%lld",&n);
	for(int i=1;i<=n;i++){
		read(wsl[i].x);
		read(wsl[i].y);
	}
	for(int i=1;i<=n;i++){
		for(int j=i+1;j<=n;j++){
			l[++tot].cx=wsl[i].x+wsl[j].x;
			l[tot].cy=wsl[i].y+wsl[j].y;
			l[tot].ax=wsl[i].x,l[tot].ay=wsl[i].y;
			l[tot].bx=wsl[j].x,l[tot].by=wsl[j].y;
			l[tot].d=1ll*(wsl[i].x-wsl[j].x)*(wsl[i].x-wsl[j].x)+(wsl[i].y-wsl[j].y)*(wsl[i].y-wsl[j].y);
		}
	}//处理每条线段信息 
	sort(l+1,l+1+tot,cmp);
	for(int i=1;i<tot;i++){
		for(int j=i+1;j<=tot;j++){
			if(l[i].d!=l[j].d||l[i].cx!=l[j].cx||l[i].cy!=l[j].cy)break;//不符合直接跳出 
			if(l[i].cx==l[j].cx&&l[i].cy==l[j].cy){
				int wx=l[i].ax,wy=l[i].ay;
				int sx=l[i].bx,sy=l[i].by;
				int lx=l[j].ax,ly=l[j].ay;
				ans=max(ans,1ll*(abs(wx*sy+sx*ly+lx*wy-wy*sx-sy*lx-ly*wx)));//三角形坐标面积公式 
			}
		}
	}
	printf("%lld",ans);
	return 0;
}
```
在考试以及下来 debug 的过程中有诸多收获，所以分享给诸君了！


---

## 作者：MloVtry (赞：3)

emmm.....凸包？旋转卡壳？不行啊是矩形...

n<=1500?不管了暴力一发....

WC过了....

大概就这样，$n^2$处理两两之间的线段。矩形的对角线一定是中心相同并且长度相同的两条线段，那么把$n^2$条线段按照长度与中心排序。

对于长度相同且中心相同的，再来一发枚举，统计答案即可。

代码
```cpp
#include<bits/stdc++.h>
#define ll long long
#define N 1500
using namespace std;
struct node
{
	ll x,y;
	ll operator ^ (const node& rhs) const
    {
        return x*rhs.y-y*rhs.x;
    }
    node operator - (const node& rhs) const
    {
        return (node){x-rhs.x,y-rhs.y};
    }
	node operator + (const node& rhs) const
    {
        return (node){x+rhs.x,y+rhs.y};
    }
}a[N+5];
struct line
{
	node li,mi;
	ll l;
}p[N*N+5];
bool comp(line aa,line bb)
{
	return aa.l==bb.l? aa.mi.x==bb.mi.x?aa.mi.y<bb.mi.y:aa.mi.x<bb.mi.x :aa.l>bb.l;
}
int n,m;
ll dis(int i,int j)
{
    return (a[i].x-a[j].x)*(a[i].x-a[j].x)+(a[i].y-a[j].y)*(a[i].y-a[j].y);
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;++i)
	{
		scanf("%lld%lld",&a[i].x,&a[i].y);
		for(int j=1;j<i;++j)
		{
			p[++m].li=a[i]-a[j];
			p[m].mi=a[i]+a[j];
			p[m].l=dis(i,j);
		}
	}
	sort(p+1,p+m+1,comp);
	
	ll ans=0;
	
	for(int i=1,j=1;i<=m;i=j)
	{
		while(p[j].l==p[i].l&&p[j].mi.x==p[i].mi.x&&p[j].mi.y==p[i].mi.y) j++;
		for(int k=i;k<j;++k)
		for(int l=k+1;l<j;++l) ans=max(ans,(abs(p[k].li^p[l].li))>>1);
	}
    printf("%lld\n" , ans);
	return 0;
}
```

---

## 作者：ztrztr (赞：1)

## 前置知识
确定两点后，如果另外两点的连线和这两点的连线的长度和中心点都相等。那么这四个点可以组成一个矩形，且前两点连的线段和后两点连的线段是矩形的对角线。

##  思路

### $O(n ^ 4)$ 复杂度的暴力
最暴力的暴力，直接枚举四个点，然后看这四个点可以不可以组成矩形，如果可以就计算一下，最后统计最大值。

### $O(n^4)$ 复杂度的暴力
这个方法虽然复杂度基本上没变化，但是有优化的余地。

枚举任意两点组成对角线，然后枚举任意两条对角线，如果这两个对角线的长度相等，而且线段的中心重合，那么就可以组成一个矩形。具体计算方法和之前相同。

### $O(n^2\log(n^2))$ 复杂度的正解
我们发现，枚举出一条对角线后，不一定要枚举第二条对角线。因为第二条符合要求的对角线一定和第一条对角线的长度相同，而且中心点的横纵坐标相同。由此，我们可以想到通过排序来解决。

先枚举任意两点找到所有对角线，然后以对角线长度为的第一关键字，对角线的中心的横纵坐标为第二第三关键字。排完序后的对角线数组满足一个规律，就是每次遍历到一个对角线，然后往后遍历的时候，如果有一个对角线的长度或者中心点都不匹配，那么后面绝对不会再遇到匹配的，而且遍历开始的那一条对角线到临界的对角线中间的这一部分都是可以互相匹配的。

由此，我们就可以先枚举对角线，然后排序，然后再遍历这个对角线。虽然上面的文字看起来需要双重循环，但是有一个小小的优化。就是每次遍历到一个临界值后，通过上面的性质，在这一个集合的点两两配对计算后第一轮循环就可以直接跳过这个集合。

而且我们还可以证明，如果 $n$ 个点共圆，那么对角线只有 $\frac{n}{2}$ 条，不会超时。

## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define ldo long double 
int n;
int x[1000005], y[1000005], cnt;
struct Edge {
	int x, y, i, j;
	ldo len;
} a[3000005];
bool cmp(Edge x, Edge y) {
	if (x.len != y.len) return x.len > y.len;
	if (x.x != y.x) return x.x < y.x;
	return x.y < y.y;
}
ldo leng(int i, int j) {
	return ((x[j] - x[i]) * (x[j] - x[i]) + (y[j] - y[i]) * (y[j] - y[i]));
}
void add(int i, int j) {
	a[++cnt].len = leng(i, j);
	a[cnt].x = (x[i] + x[j]);
	a[cnt].y = (y[i] + y[j]);
	a[cnt].i = i; a[cnt].j = j;
}
signed main() {
	ios::sync_with_stdio(0); cout.tie(0);
	cin >> n;
	for (int i = 1; i <= n; i ++) cin >> x[i] >> y[i];
	for (int i = 1; i <= n; i ++) {
		for (int j = i + 1; j <= n; j ++) {
			add(i, j);
		}
	}
	sort(a + 1, a + cnt + 1, cmp);
	int maxn = 0;
//	for (int i = 1; i <= cnt; i ++) {
//		cout << a[i].len << " " << a[i].x << " " << a[i].y << " " << a[i].i << " " << a[i].j << "\n";
//	}
	for (int i = 1; i <= cnt; i ++) {
		int last = i;
		while (abs(a[i + 1].len - a[i].len) == 0 && a[i + 1].x == a[i].x && a[i + 1].y == a[i].y) {
			for (int j = last; j <= i; j ++) {
				int S = 0;
				ldo Sa = sqrt(leng(a[j].i, a[i + 1].i));
				ldo Sb = sqrt(leng(a[j].j, a[i + 1].i));
				S = round(Sa * Sb);
				maxn = max(maxn, S);
			}
			i ++;
		}
	}
	cout << (int)maxn;
}
/*
8
-2 3
-2 -1
0 3
0 -1
1 -1
2 1 
-3 1 
-2 1

*/
```

---

## 作者：zyn_ (赞：1)

求由给定的 $n$ 个点中的 $4$ 个为顶点组成的矩形的面积的最大值。$n\le 1500$。

只允许 $O(n^2\operatorname{polylog}n)$ 的做法。考虑枚举矩形的中心，熟知矩形的两条对角线长度相等，且它们的中点均为矩形的中心。

直接求出所有 $\dfrac{n(n-1)}{2}$ 条线段的中点，将它们按照中点坐标与长度分组。于是有且仅有在同一组内的两条线段可能成为同一个矩形的两条对角线。

假设正在考虑的一组线段，它们的长度均为 $l$。设组成的矩形 $ABCD$ 的对角线 $AC,BD$ 交于 $O$，则 $AC=BD=l$，$AO=BO=CO=DO=\dfrac{l}{2}$。

由正弦定理，$S_{ABCD}=4S_{\triangle AOB}=4(\dfrac{1}{2}\times AO\times BO\times \sin\theta)=\dfrac{l^2}{2}\sin\theta$，其中 $\theta$ 为 $AC$ 与 $BD$ 之间的夹角。希望这个值尽可能大，因此要 $\theta$ 尽量接近直角。双指针即可。

以下代码的时间复杂度为 $O(n^2\log n)$，瓶颈是排序。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define db double
#define eps 1e-8
#define N 1504
int n,m,c,l,r;ll x[N],y[N],ans;db a[N*N];
struct segment{ll l2,x,y;db a;}s[N*N];
inline bool sp(const segment&a,const segment&b){
    return a.x==b.x?(a.y==b.y?a.l2<b.l2:a.y<b.y):a.x<b.x;
}
inline bool eq(const segment&a,const segment&b){
    return a.x==b.x&&a.y==b.y&&a.l2==b.l2;
}
const db pi=acos(-1);
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;++i)scanf("%lld%lld",&x[i],&y[i]);
    for(int i=1;i<=n;++i)for(int j=1;j<i;++j){
        ++m;
        s[m].x=x[i]+x[j];s[m].y=y[i]+y[j];
        s[m].l2=(x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]);
        s[m].a=(x[i]==x[j]?0:pi/2-atan(1.*(y[j]-y[i])/(x[j]-x[i])));
    }
    sort(s+1,s+m+1,sp);
    for(int i=1,j=1;j<=m;++j,i=j){
        ++j;
        while(eq(s[j-1],s[j]))++j;
        --j;
        c=j-i+1;
        if(c==1)continue;
        for(int k=i;k<=j;++k)a[k-i+1]=s[k].a;
        sort(a+1,a+c+1);
        l=1,r=2;
        while(r<=c){
            ans=max(ans,(ll)(s[i].l2*sin(a[r]-a[l])/2.+0.5));
            if(a[r]-a[l]<pi/2-eps)++r;
            else ++l;
        }
    }
    printf("%lld\n",ans);
    return 0;
}
```

---

## 作者：Gyc_Fisher (赞：1)

# P3217 [HNOI2011] 数矩形 题解

题目传送门：[P3217 数矩形](https://www.luogu.com.cn/problem/P3217)

读完题就要意识到一个事情：

![](https://cdn.luogu.com.cn/upload/image_hosting/5tjnxn8n.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

在坐标轴上，上图的两个矩形均是合法的（不然样例都过不了）。

再看数据范围：

1、$N≤500$

2、$N≤1500$

两个数据范围分别对应了 $O(n^3)$ 和 $O(n^2)$ 的解法。$O(n^3)$ 的算法这里我就不多赘述（~~因为我打挂了~~），这里主要讲解 $O(n^2)$ 的解法

首先，回顾一下初中的数学知识：[矩形的性质以及判定](https://zhuanlan.zhihu.com/p/33201561)

从中我们发现一些比较好想的判定方法：

1、确定三个角是直角

2、首先让两条边中点重合（构成平行四边行），再让这两条边长度相等，此时两条边的所有端点连线就是一个矩形。

先来看判定 $1$：很明显要求斜率，不仅难求（如果你是 dalao 当我没说），还有精度上的损失，不是很优。

再来看判定 $2$：只需要求两点间的距离，外加求个中点，比较好求，而且只要全程不开根号，不除 $2$，就不会存在精度上的损失，具体说明一下：

这是两点距离公式：
$$
dis=\sqrt{(x_1-x_2)^2+(y_1-y_2)^2}
$$
我们将两边同时平方就有：
$$
dis^2=(x_1-x_2)^2+(y_1-y_2)^2
$$
此时整个式子不存在开根号的操作，所以不存在精度上的损失。但在最后求矩形的面积时，

再来看一下求线段中点，我们发现所有求中点的过程中，都会有除 $2$ 的操作，然后会去判断两个坐标是否相等，如果不去除 $2$ 其实也就是相当于在等式两边同时乘上 $2$，并不影响最后比较的结果。不涉及到除法，也就没有了精度上的损失。

综上，我们选择了第二种判定方法。

接下来，我们可以枚举每两个点，求出他们的距离，和他们之间的中点坐标，这里是个 $O(n^2)$ 的枚举。

那这个时候，就可以开始枚举两条边，然后进行匹配，看是否存在两条边长度相同，中点重合（一定是存在的，因为题目保证了有解）。

好，直接码出来，然后直接 TLE。

怎么回事呢？

我们发现最坏有 $1 \times 10^6$ 数量级的边，然后直接两两枚举，如果神姬按桶打了肾上腺素兴许可以过，但一般情况是过不了的。

OK 啊，考虑一手小小的优化。

发现主要的复杂度来自两两枚举的过程，由于边的分布是混乱的，导致两条长度相同的边之间隔得很远，所以复杂度上来了，那么我们考虑将边长度相同尽可能放在一起，这样可以减少两条长度相同的边之间的在数组中的最远距离，从而有效降低复杂度。

也就是说，我们可以把下图的情况：



![](https://cdn.luogu.com.cn/upload/image_hosting/xx4sideo.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

转化为：

![](https://cdn.luogu.com.cn/upload/image_hosting/vj5faxbz.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

这样，在枚举 $5$ 的时候，只要枚举 $1$ 个数，而不这么操作的话就需要枚举 $n-2$ 个数。

怎么实现？排序呗。

排完之后，就可以和原来一样跑。

**但是注意**，并不是对角线越长的构成的矩形面积一定最大（~~你猜猜我最开始怎么写的~~），很容易就举出反例。

精度上就只有最后需要求矩形面积时开根，其他情况都没有必要，这在上文也稍微讲了一下。

附上代码：

```cpp
#include <bits/stdc++.h>
#define MAXN 3005
#define int long long
using namespace std;
int n;
int city[MAXN][2],ans;
struct Node{
	long double len;
	int ax,bx,ay,by;
	long double x,y;
}li[MAXN*MAXN];
int team[MAXN*MAXN];
int tot;
bool operator <(Node a,Node b){
	if(a.len==b.len){
		if(a.x==b.x) return a.y<b.y;
		return a.x<b.x;
	}
	return a.len>b.len;
}
signed main(){
	scanf("%lld",&n);
	for(int i=1;i<=n;i++){
		scanf("%lld%lld",&city[i][0],&city[i][1]);
	}
	for(int i=1;i<=n;i++){
		for(int j=i+1;j<=n;j++){
			long double x=((city[i][0]-city[j][0])*(city[i][0]-city[j][0])+(city[i][1]-city[j][1])*(city[i][1]-city[j][1]));
			long double xx=(city[i][0]+city[j][0]);
			long double yy=(city[i][1]+city[j][1]);
			Node a;
			a.ax=city[i][0];
			a.ay=city[i][1];
			a.bx=city[j][0];
			a.by=city[j][1];
			a.x=xx;
			a.y=yy;
			a.len=x;
			li[++tot]=a;
		}
	}
	sort(li+1,li+1+tot);
	int cnt=0;
	int i=1;
	while(i<=tot){
		while(li[i].len==li[i+1].len&&li[i].x==li[i+1].x&&li[i].y==li[i+1].y){
			team[++cnt]=i;
			i++;
		}
		team[++cnt]=i;
		for(int j=1;j<=cnt;j++){
			for(int h=j+1;h<=cnt;h++){
				int xa=li[team[j]].ax;
				int xb=li[team[j]].bx;
				int ya=li[team[j]].ay;
				int yb=li[team[j]].by;
				int xm=li[team[h]].ax;
				int ym=li[team[h]].ay;
				long double x=((xm-xa)*(xm-xa)+(ym-ya)*(ym-ya));
				long double y=((xm-xb)*(xm-xb)+(ym-yb)*(ym-yb));
				int s=sqrt(x*y)+0.5;//四舍五入
				ans=max(ans,s);
			}
		}
		cnt=0;
		i++;
	}
	printf("%lld",ans);
	return 0;
}
```

代码写的比较丑，见谅。

---

## 作者：tommymio (赞：1)

对于这种题目，拿到题目首先想一想什么情况下能够构成一个矩形。

自然可以根据矩形判定来解决。但是这样需要枚举四个点，时间复杂度是 $O(n^4)$ 的。不妨想想需要枚举更少信息的做法。

我们发现，两条长度相等，中点相等的线段能够唯一确定一个矩形。这是由矩形的判定定理决定的。我们在 $O(n^2)$ 处理出两两点之间的连线，对于那些长度相等，中点相等的线段直接两两枚举。

由于 $n$ 个点构成的矩形数不会超过 $n^2\sqrt n$，所以我们在最劣情况下会将这所有矩形全部枚举一遍，上界也就是 $O(n^2\sqrt n+n^2 \log n)$。

值得注意的是，矩形面积必须使用叉积求，不能使用欧氏距离。否则要么掉精度要么爆 $\text{long long}$。

```cpp
#include<cstdio>
#include<cmath>
#include<algorithm>
typedef long long ll;
int num=0;
struct Segment {ll len; int posX,posY,st,ed;} s[2250005>>1];
int x[1505],y[1505];
inline int read() {
    register int x=0,f=1;register char s=getchar();
    while(s>'9'||s<'0') {if(s=='-') f=-1;s=getchar();}
    while(s>='0'&&s<='9') {x=x*10+s-'0';s=getchar();}
    return x*f;
}
inline bool cmp(const Segment &x,const Segment &y) {
    if(x.len<y.len) return 1;
    if(x.len==y.len&&x.posX<y.posX) return 1;
    if(x.len==y.len&&x.posX==y.posX&&x.posY<y.posY) return 1;
    return 0;
}
inline ll max(const ll &x,const ll &y) {return x>y? x:y;}
inline ll abs(ll x) {return x<0? -x:x;}
int main() {
    int n=read();
    for(register int i=1;i<=n;++i) {x[i]=read();y[i]=read();}
    for(register int i=1;i<=n;++i) {
        for(register int j=i+1;j<=n;++j) {
            s[++num].len=(ll)(x[i]-x[j])*(x[i]-x[j])+(ll)(y[i]-y[j])*(y[i]-y[j]);
            s[num].posX=x[i]+x[j]; s[num].posY=y[i]+y[j];
            s[num].st=i; s[num].ed=j;
        }
    }
    std::sort(s+1,s+1+num,cmp);
    ll ans=0;
    for(register int cur=1;cur<=num;) {
        int nxt=cur;
        while(nxt<=num&&s[nxt].len==s[cur].len&&s[nxt].posX==s[cur].posX&&s[nxt].posY==s[cur].posY) ++nxt;
        for(register int i=cur;i<nxt;++i) {
            for(register int j=cur+1;j<nxt;++j) {
                int u=s[i].st,v=s[j].st,w=s[j].ed;
                int X_1=x[v]-x[u],Y_1=y[v]-y[u];
                int X_2=x[w]-x[u],Y_2=y[w]-y[u];
                ans=max(ans,abs((ll)X_1*Y_2-(ll)X_2*Y_1));
            }
        } 
        cur=nxt;
    }
    printf("%lld\n",ans);
    return 0;
}
```

---

## 作者：shanjb0221 (赞：1)

已经有大佬[证明](https://blog.csdn.net/wang3312362136/article/details/83003126)了平面上 $n$ 个整点能构成矩形个数上界是 $\text{O}\left(n^{2.5}\right)$，因此只需要**没有冗余地**枚举所有矩形，复杂度就能得到保证。

### 一种可行的做法

我们知道：一个矩形的两条对角线长度、中点相同。

考虑用（长度，中点坐标）双关键字把 $n^2$ 条边排序。

排序后每组（长度，中点坐标）都相同的边都在连续的一段中。

在一段中任选两条边，显然存在一个以这两条边为对角线的矩形。

图中的任何一个矩形都只会被恰好枚举到一次，因此枚举复杂度与矩形个数相等。

时间复杂度：$\text{O}\left(n^{2.5}\right)$。

### 另一种复杂度更优的做法

我们知道：矩形的对边平行且相等。

即：矩形 $ABCD$ 中 $\overrightarrow{AB} = \overrightarrow{DC}$

如果用一个出发点 $p$（对应矩形中的 $A,D$）和一个向量 $\overrightarrow{v}$ （对应矩形中的 $\overrightarrow{AB}, \overrightarrow{DC}$）描述一条边，那么两条边 平行且相等 等价于它们的 $\overrightarrow{v}$ 相等。

考虑用 $\overrightarrow{v}$ 为关键字把所有边排序、分组。

如果这时直接枚举一组内的两条边，实际上枚举的是图中的所有平行四边形，复杂度上界没有保证。

只用对边平行且相等不能完全描述一个矩形的性质，我们还需要考虑矩形的其他性质，我们还知道：矩形的邻边互相垂直。

即：矩形 $ABCD$ 中 $\overrightarrow{AB} \cdot \overrightarrow{BC} = 0$

继续整理： $\overrightarrow{AB} \cdot \left( \overrightarrow{OC} - \overrightarrow{OB} \right) = 0$

$\overrightarrow{AB} \cdot \overrightarrow{OB} = \overrightarrow{AB} \cdot \overrightarrow{OC} = \overrightarrow{DC} \cdot \overrightarrow{OC}$

对应到我们对边的表示上就是：$\overrightarrow{v_1} \cdot \overrightarrow{Op_1} = \overrightarrow{v_2} \cdot \overrightarrow{Op_2}$

我们可以把一组内的所有边按照 $\overrightarrow{v} \cdot \overrightarrow{Op}$ 继续排序、分组，这样一组内的任意两条边就都能够构成一个矩形了。

此时我们可以直接枚举所有可行的矩形，复杂度$\text{O}\left(n^{2.5}\right)$。

我们也可以继续优化：

我们知道矩形的面积可以表示为 $S=\left| \overrightarrow{AB} \times \overrightarrow{BC}\right|$

整理得到 $S = \left|\overrightarrow{AB} \times \left( \overrightarrow{OC} - \overrightarrow{OB} \right)\right| = \left| \overrightarrow{AB} \times \overrightarrow{OB} - \overrightarrow{DC} \times \overrightarrow{OC}\right|$

对应到我们对边的表示上就是：$S=\left| \overrightarrow{v_1} \times \overrightarrow{Op_1} - \overrightarrow{v_2} \times \overrightarrow{Op_2} \right|$

我们要求 $S$ 的最大值，这相当于求同一组中所有边的 $\overrightarrow{v} \times \overrightarrow{Op}$ 的极差，可以维护最大值、最小值快速求出。

至此，时间复杂度已经被优化成 $\text{O}\left(n^2 \log n\right)$。

~~我们发现，复杂度的瓶颈在排序上，可以考虑用基数排序或`unordered_map` 继续优化。~~

~~理论上时间复杂度可以达到 $\text{O}\left(n^2\right)$。~~

### $\text{O}\left(n^2 \log n\right)$ 代码
```cpp 
#include <cmath>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
typedef long long ll;
struct pt{
    ll x,y,k;
    inline pt(){};
    inline pt(ll X,ll Y):x(X),y(Y){};
    inline bool operator<(const pt& p){return k<p.k;}
    inline void init(){scanf("%lld%lld",&x,&y);}
    inline pt operator-(const pt& p)const {return pt(x-p.x,y-p.y);}
    inline pt operator+(const pt& p)const {return pt(x+p.x,y+p.y);}
    inline ll operator*(const pt& p)const {return x*p.x+y*p.y;}
    inline ll operator/(const pt& p)const {return x*p.y-y*p.x;}
    inline pt r90(int t=1){return pt(-t*y,t*x);}
};
const ll L=5e8,R=1e9;
inline ll Hash(const pt& p){return (p.x+L)*R+p.y+L;}
inline pt iHash(ll h){return pt(h/R-L,h%R-L);}
const int N=2e3+10;
pt P[N],V[N*N];
int n,t;
ll ans,upp,low;
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;++i)P[i].init(),P[i].k=Hash(P[i]);
    sort(P+1,P+n+1);
    for(int i=1;i<=n;++i)
        for(int j=1;j<i;++j)
            V[++t]=P[j],V[t].k=Hash(P[i]-P[j]);
    sort(V+1,V+t+1);
    for(int i=1,j=1;i<=t;i=j){
        while(j<=t&&V[j].k==V[i].k)++j;
        pt v=iHash(V[i].k);
        for(int it=i;it<j;++it)V[it].k=V[it]*v;
        sort(V+i,V+j);
        for(int l=i,r=i;l<j;l=r++){
            upp=low=V[l]/v;
            while(r<j&&V[r].k==V[l].k)
                low=min(low,V[r]/v),upp=max(upp,V[r]/v),++r;
            ans=max(ans,upp-low);
        }
    }
    printf("%lld\n",ans);
}
```

---

## 作者：tcswuzb (赞：0)

# 主题思路

一开始的思路是对于每一条线段按照斜率和长度排序分段

然后在每一个段内暴力枚举矩形

很显然容易TLE

尝试转换思路

如何通过两条线段简易的确定一个矩形

矩形的一个重要性质：**一个矩形的对角线相等且互相平分**

也就是说 **如果两条线段的中心重合并且长度相等**

我们就可以用这两条线段确定一个矩形

所以我们先$n^2$枚举全部的线段

然后对于每一条线段提取中点以及长度

然后对此进行排序分段

每一个段内的话 我们在按照极角进行排序

用于一个段内 线段的长度全部相等

那么 **两条线段越趋近于垂直 越趋近于面积最大**

这样的话 我们就可以在段内用指针线性扫描 找到最合适的位置

然后进行求最大值

# 一些细节

1.为了防止精度误差 我们尽量使用整数计算

比如 利用叉积实现内部极角排序

利用叉积计算面积

2.用于点值的范围是在$10^{-8}-10^8$

并且涉及到了乘法运算 所以一些变量我们需要使用 long long

# CODE:

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cstdlib>
#include<cmath>
#define N 1510
using namespace std;
int n,tot;
long long ans;
struct Node
{
	int xx,yy;
}e[N];
struct Line
{
	int sx,sy,tx,ty,tox,toy;long long len;
	double mx,my;
	friend bool operator <(const Line &A,const Line &B)
	{
		if(A.mx==B.mx)
		{
			if(A.my==B.my)
			{//内部使用叉积进行极角排序
				if(A.len==B.len) return (A.tox*B.toy-A.toy*B.tox)>0;
				else return A.len<B.len;
			} 
			else return A.my<B.my; 
		}
		else return A.mx<B.mx;
	}
	friend long long operator *(const Line &A,const Line &B)
	{//计算点积
		long long ax=(long long)(A.tx-A.sx);long long ay=(long long)(A.ty-A.sy);
		long long bx=(long long)(B.tx-B.sx);long long by=(long long)(B.ty-B.sy);
		return ax*bx+ay*by;
	}
	friend long long operator ^(const Line &A,const Line &B)
	{//计算叉积
		long long ax=(long long)(A.tx-A.sx);long long ay=(long long)(A.ty-A.sy);
		long long bx=(long long)(B.tx-B.sx);long long by=(long long)(B.ty-B.sy);
		return ax*by-ay*bx;
	}
}lin[N*N];
//为了防止开方造成的精度损失 同时长度只涉及比较
//我们就不开方了
long long getlen(Node A,Node B)
{return (long long)(A.xx-B.xx)*(long long)(A.xx-B.xx)+(long long)(A.yy-B.yy)*(long long)(A.yy-B.yy);}
void solve(int le,int ri)
{
	if(le==ri) return;
//	puts("access to answer!");	
	int tail=le+1;
    //使用指针扫描
	for(int i=le;i<ri;++i)
	{
		while(tail<ri&&(lin[i]*lin[tail])>0) ++tail;
		//寻找最趋近于垂直的
     //为了防止意外 前后的位置我都比较了一下  
        if(tail>le) ans=max(ans,(abs(lin[i]^lin[tail]))/2);
		if(tail-1>le) ans=max(ans,(abs(lin[i]^lin[tail-1]))/2);
		if(tail+1<=ri) ans=max(ans,(abs(lin[i]^lin[tail+1]))/2);
		
	}
	return;
}
int main()
{
	cin>>n;
	for(int i=1;i<=n;++i)
	cin>>e[i].xx>>e[i].yy;
	for(int i=1;i<=n;++i)
	 for(int j=i+1;j<=n;++j)
	  {
	  	++tot;
        //为了尽量防止麻烦 我在读入线段的时候做了一些微调
	  	if(e[i].yy<e[j].yy)
	  	{
			lin[tot].sx=e[i].xx;lin[tot].sy=e[i].yy;
		  	lin[tot].tx=e[j].xx;lin[tot].ty=e[j].yy;
		  	lin[tot].mx=(double)(e[i].xx+e[j].xx)/2.0;
		  	lin[tot].my=(double)(e[i].yy+e[j].yy)/2.0;
		  	lin[tot].tox=e[j].xx-e[i].xx;
		  	lin[tot].toy=e[j].yy-e[i].yy;
		  	lin[tot].len=getlen(e[i],e[j]);
		}
		else
		{
			lin[tot].tx=e[i].xx;lin[tot].ty=e[i].yy;
		  	lin[tot].sx=e[j].xx;lin[tot].sy=e[j].yy;
		  	lin[tot].mx=(double)(e[i].xx+e[j].xx)/2.0;
		  	lin[tot].my=(double)(e[i].yy+e[j].yy)/2.0;
		  	lin[tot].tox=e[i].xx-e[j].xx;
		  	lin[tot].toy=e[i].yy-e[j].yy;
		  	lin[tot].len=getlen(e[i],e[j]);
		}
	  }
	sort(lin+1,lin+tot+1);  
	int pos=1;
	for(int i=1;i<=tot;++i)
	{
		if(!(lin[i].mx==lin[i+1].mx&&lin[i].my==lin[i+1].my&&lin[i].len==lin[i+1].len))//分段
		{solve(pos,i);pos=i+1;}
	}
	printf("%lld\n",ans);
	return 0; 
}

```




---


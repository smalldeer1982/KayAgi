# [COCI 2009/2010 #6] XOR

## 题目描述

坐标系下有若干个等腰直角三角形，且每个等腰直角三角形的直角顶点都在左下方，两腰与坐标轴平行。被奇数个三角形覆盖的面积部分为灰色，被偶数个三角形覆盖的面积部分为白色，如下图所示。
![](https://cdn.luogu.com.cn/upload/pic/18669.png)
已知 $N$个等腰直角三角形的顶点坐标及腰长，求灰色部分面积。

Mirko and Slavko have built their own LED display. The display is initially
white. During each of the $N$ parts of the testing phase, Mirko attached three
electrodes to the display in such way that they formed a right isosceles
triangle. He noticed that, after attaching the electrodes, all pixels in the
enclosing triangle are inverted (white pixels become black, and black pixels
become white).

Watching Mirko play with the electrodes, Slavko observed interesting shapes
emerging on the screen. Mathematically inclined as he is, first thing that
crossed his mind was how to calculate total area covered by black pixels. Help
him by writing a program to do just that!

## 说明/提示

$1 \leq N \leq 10, 1 \leq X, Y, R \leq 10^6$

## 样例 #1

### 输入

```
3
1 1 2
7 1 6
5 3 4```

### 输出

```
24.0```

## 样例 #2

### 输入

```
5
5 5 99
5 5 99
5 5 99
5 5 99
5 5 99```

### 输出

```
4900.5```

## 样例 #3

### 输入

```
4
5 5 99
5 5 99
5 5 99
5 5 99```

### 输出

```
0.0```

# 题解

## 作者：nekko (赞：24)

同步于：[我的博客](https://www.cnblogs.com/KingSann/articles/9606618.html)

------------

首先要解决一个问题，如何求一堆三角形的面积交？

首先$S=R^2$，求最终交出来的三角形的直角边长也行

设第$i$个三角形的左下角顶点坐标为$(x_i,y_i)$，边长为$r_i$，记$c_i=x_i+y_i+r_i$

则$R_{\cap}=\max(0,\min(c_i)-\max(x_i)-\max(y_i))$

既$S_{\cap}=R_{\cap}^2$

证明：

> 如果最终可以交出来三角形，那么无非也就如下几种情况（黑色为$c_i$最小的三角形，红色为交出的三角形）：
>
> ![iPPszQ.png](https://s1.ax1x.com/2018/09/07/iPPszQ.png)
>
> 将变量设出来后显然得证

------

设$f(S)$表示选用集合$S$的三角形所交出来的三角形的面积

现在的目标是求$ans=\sum_{\emptyset \subsetneq S \subseteq U} f(S)g(| S |)$

~~也就是凑容斥系数~~

实际上$g(|S|)=(-1)^{|S|+1}2^{|S|-1}=(-2)^{|S|-1}$

证明：

> 对于一个交出来的三角形，设一共有$k$个三角形中包含这个三角形
>
> 即证：
> $$\sum_{i=1}^{k}{k \choose i}(-1)^{i+1}2^{i-1}=[2 \nmid k]$$
> 也就是
> 
> $$\begin{aligned}\sum_{i=1}^{k}{k \choose i}(-1)^{i+1}2^{i-1}&=\sum_{i=1}^{k}{k \choose i}(-2)^{i-1} \\&=\frac{1}{-2}\sum_{i=1}^{k}{k \choose i}(-2)^{i} \\&=\frac{-{k \choose 0}(-2)^0+\sum_{i=0}^{k}{k \choose i}(-2)^{i}}{-2} \\&=\frac{-1+(-2+1)^{k}}{-2} \\&=\frac{1-(-1)^{k}}{2} \\ &=[2 \nmid k]\end{aligned}$$
> 

~~于是就做完了~~

------

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
struct TRI { ll x, y, r, c; } tri[12];
ll ans; int n;
void dfs(int i, ll x, ll y, ll c, int sz, int sig) {
	if(x + y >= c) return ;
	if(i == n + 1) sz ? (ans += sig * (1ll << (sz - 1)) * (c - x - y) * (c - x - y)) : 0;
	else dfs(i + 1, x, y, c, sz, sig), dfs(i + 1, max(x, tri[i].x), max(y, tri[i].y), min(c, tri[i].c), sz + 1, -sig);
}
int main() {
	cin >> n;
	for(int i = 1 ; i <= n ; ++ i) cin >> tri[i].x >> tri[i].y >> tri[i].r, tri[i].c = tri[i].x + tri[i].y + tri[i].r;
	dfs(1, 0, 0, 1e18, 0, -1);
	printf("%.1lf\n", ans / 2.0);
}
```



---

## 作者：ix35 (赞：11)

本题的若干篇洛谷题解中大部分用到了容斥原理，不过遗憾的是，所有容斥原理的题解的复杂度都止步于 $O(2^n\times n)$ 的指数级别。

但我们有一种简单的方法，可以将容斥原理的复杂度优化到 $O(n^3)$。

这是一个变形的容斥原理，我们可以知道答案一定可以写成每个子集的交乘上一个系数求和。

事实上稍加推导可以发现，大小为 $m$ 的子集的容斥系数为 $(-2)^{m-1}$，提供一个归纳性证明：
$$
\dfrac{(-1)^{m-1}+1}{2}-\sum\limits_{i=1}^{m-1}\binom m i\times (-2)^{i-1}=\dfrac{(-1)^{m-1}+1+(-1)^m-1-(-2)^{m}}{2}=(-2)^{m-1}
$$
我们可以考虑枚举一个三角形 $Tri$，求交集为 $Tri$ 的子集的容斥系数和。

而这可以再套一层三维差分的容斥，转化为计算八个形如“包含 $Tri$ 的所有三角形集合的所有子集的容斥系数和”的东西。

这一点是容易的，设包含 $Tri$ 的三角形有 $m$ 个，则系数和为：
$$
\sum\limits_{i=1}^m\binom m i\times (-2)^{i-1}=\dfrac{(-1)^{m}-1}{-2}
$$
也即当 $m$ 为偶数时系数为 $0$，否则系数为 $1$。

枚举三角形的三条边并通过三维差分计算即可，时间复杂度 $O(n^3)$。

---

## 作者：0x3F (赞：10)

人生第一道黑题，写一篇题解纪念一下。

首先发现 $n$ 很小，于是猜测可能是指数或阶乘级别的算法。

先考虑 $n = 2$ 时的情况。

（注：下文中的三角形均指等腰 $\operatorname{Rt}$ 三角形）

当 $n = 2$ 时，两个三角形的 $\operatorname{XOR}$ 的面积为两三角形面积和减去两三角形面积的交的两倍。

为什么是两倍呢？因为我们算面积和时这一部分算了两次，而我们一次也不要，所以应该减两次。

问题来了：如何求两个三角形的交？

~~显然~~一个三角形由三条直线围成，它们分别是：

- 直线 $x = X$
- 直线 $y = Y$
- 直线 $x + y = X + Y + R$

（注意大小写字母的区别）

于是两个三角形相交了，它们的交要么为空，如果存在，必定是三角形，而且它的三边必定是由两个原三角形的三边组成的。

先考虑不为空的情况。

原三角形分别为 $(X_1, Y_1, R_1)$ 和 $(X_2, Y_2, R_2)$，则它们的竖线分别是 $x = X_1$ 和 $x = X_2$，则新三角形的竖线必定为两者之一，那是哪一条呢？

画图可知，必定是右边一条，即 $x = \max(X_1, X_2)$。

同理另两条直线分别为 $y = \max(Y_1, Y_2)$ 和 $x + y = \min(X_1 + Y_1 + R_1, X_2 + Y_2 + R_2)$

于是解一下方程得：新三角形为 $(\max(X_1, X_2), \max(Y_1, Y_2),  \min(X_1 + Y_1 + R_1, X_2 + Y_2 + R_2) - \max(X_1, X_2) - \max(Y_1, Y_2))$

那么什么时候它为空呢？

当且仅当新的 $R \le 0$ 时为空。

好了，两个三角形搞定了，那么 $n$ 个三角形呢？

开始动用容斥原理。

下面 $T_i$ 表示第 $i$ 个三角形，$T_i\&T_j$ 表示两个三角形的交。

（以下画一画韦恩图就可以得出）

当 $n = 2$ 时：$S = S_{T_1} + S_{T_2} - 2S_{T_1 \& T_2}$

当 $n = 3$ 时：$S = S_{T_1} + S_{T_2} + S_{T_3} - 2S_{T_1 \& T_2} - 2S_{T_1 \& T_3} - 2S_{T_2 \& T_3} + 4S_{T_1 \& T_2 \& T_3}$

当 $n = 4$ 时：

$$S = S_{T_1} + S_{T_2} + S_{T_3} + S_{T_4}$$

$$- 2S_{T_1 \& T_2} - 2S_{T_1 \& T_3} - 2S_{T_1 \& T_4} - 2S_{T_2 \& T_3} - 2S_{T_2 \& T_4} - 2S_{T_3 \& T_4}$$

$$+ 4S_{T_1 \& T_2 \& T_3} + 4S_{T_1 \& T_2 \& T_4} + 4S_{T_1 \& T_3 \& T_4} + 4S_{T_2 \& T_3 \& T_4}$$

$$- 8S_{T_1 \& T_2 \& T_3 \& T_4}$$

（由于太壮观了于是分了行）

规律不就呼之欲出了吗？

$$S = \sum_{i = 1}^{n}\Big[\sum_{x_1=1}^{n-i+1}\sum_{x_2=x_1+1}^{n-i+2}\cdots\sum_{x_j=x_{j-1}+1}^{n-i+j}\cdots\sum_{x_i=x_{i-1}+1}^{n}(-2)^{i-1}S_{T_{x_1} \& T_{x_2} \& \cdots \& T_{x_n}}\Big]$$

柿子比较奇怪，~~大概就是说~~所有非空三角形集合中的所有三角形的交的面积乘以 $(-2)^{\texttt{集合大小}-1}$ 的乘积之和。

于是 $\Theta(2^n)$ 枚举三角形集合，$\Theta(n)$ 计算即可。

总时间复杂度 $\Theta(n2^n)$ 即 $\Theta(\texttt{能过})$。

代码如下。

```cpp
#include <bits/stdc++.h>
#define NIL (tri){0, 0, 0}
//不存在的三角形
using namespace std;
int n;
long long ans, siz;
struct tri {
	int x;
	int y;
	int r;
}arr[12], tmp;

long long size(tri t) {
	//求三角形面积
	return (long long)t.r * t.r;
}
tri intersect(tri a, tri b) {
	//求两个三角形的并
	tri c;
	c.x = max(a.x, b.x);
	c.y = max(a.y, b.y);
	c.r = min(a.x + a.y + a.r, b.x + b.y + b.r) - c.x - c.y;
	if (c.r <= 0) return NIL;
	else return c;
}
int main() {
	cin >> n;
	for (int i = 0; i < n; i++) {
		cin >> arr[i].x >> arr[i].y >> arr[i].r;
	}
	for (int t = 1; t < (1<<n); t++) {
		//枚举三角形集合
		int cnt = 0;
		for (int i = 0; i < n; i++) {
			//计算三角形的面积的交
			if (t & (1<<i)) {
				if (cnt) tmp = intersect(tmp, arr[i]);
				else tmp = arr[i];
				cnt++;
			}
		}
		//计算对答案的贡献（可能为负）
		siz = size(tmp);
		cnt--;
		siz <<= cnt;
		if (cnt & 1) siz = -siz;
		ans += siz;
	}
	printf("%lld.%lld\n", ans>>1, (ans&1)*5);
	return 0;
}
```

$$\color{white}{\huge{\texttt{求过，求赞}}}$$

---

## 作者：T_Q_X (赞：7)

这里给出的是一种复杂度为 $\mathcal O(nS)$ 的做法，其中 $S$ 为值域。

[可能更好的阅读体验](https://www.cnblogs.com/tqxboomzero/p/14843016.html)

## Description

坐标系下有若干个等腰直角三角形，且每个等腰直角三角形的直角顶点都在左下方，两腰与坐标轴平行。被奇数个三角形覆盖的面积部分为灰色，被偶数个三角形覆盖的面积部分为白色，如下图所示:

 ![img](https://cdn.luogu.com.cn/upload/pic/18669.png) 

已知 $n$ 个等腰直角三角形的顶点坐标及腰长，求灰色部分面积。

$n\le 10$，等腰直角三角形的横纵坐标及腰长 $\le 10^6$.

### Solution

考虑分别考虑坐标系中每一行哪些格子为灰色部分，然后将所有行的答案加起来。

容易发现每个格子要么被完全覆盖，要么左下部分被覆盖，因此可以将每个格子拆成左下与右上两部分作为新的格子，那么三角形就只能覆盖整数个格子了。

考虑从第 $x$ 行移动到 $x-1$ 行的过程中每个三角形覆盖格子的变化：

- 这两行都不在三角形的覆盖范围中：没有变化。

- 都在覆盖范围中，则只会在最右侧多覆盖两个格子，例如下图中的情况。

![](https://cdn.luogu.com.cn/upload/image_hosting/gh96ynga.png)

- 若第 $x$ 行在覆盖范围内而第 $x-1$ 行不在，那么需要将原本被覆盖的位置的覆盖状态均会被修改。

- 第 $x$ 行不在覆盖范围内，而第 $x-1$ 行在，那么只会多覆盖一个格子。

第三种情况每个三角形最多出现一次，设 $S$ 为值域，那么这部分最多修改 $\mathcal O(nS)$ 个格子。

第二、四种情况中，每次移动只会影响 $1$ 个 或 $2$ 个格子的变化情况，因此总共也只会造成 $\mathcal O(nS)$ 次修改。

于是，我们可以直接暴力用 $bool$ 数组维护每个格子的状态，总修改次数只有 $\mathcal O(nS)$ 个，完全足以通过此题，甚至可以将 $n$ 加强到 $100$。

### Code

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef pair<int,int> pii;
#define mp make_pair
const int N=110;
const int MX=4e6+10;
typedef long long ll;
int n,top,tot;
ll cnt,ans;
bool b[MX];
struct triangle{
	int x,y,l,up;
}a[N];
inline void change(int x){b[x]?cnt--:cnt++;b[x]^=1;}
int main(){
	scanf("%d",&n);
	int mx=1;
	for(int i=1;i<=n;++i){
		scanf("%d%d%d",&a[i].x,&a[i].y,&a[i].l),mx=max(mx,a[i].y+a[i].l);
		a[i].up=a[i].y+a[i].l;
	}
	for(int i=mx-1;i>=1;--i){
		for(int j=1;j<=n;++j){
			if(i>=a[j].y&&i<a[j].up){
				int tmp=a[j].up-i+a[j].x;
				change(tmp<<1);
				if(i!=a[j].up-1) change((tmp<<1)-1);
			}
			if(i==a[j].y-1){
				int tmp=a[j].up-(i+1)+a[j].x;
				for(int k=(a[j].x+1)<<1;k<=(tmp<<1);++k) change(k);
			}
		}
		ans+=cnt;
	}
	printf("%.1lf\n",ans*1.0/2.0);
	return 0;
}
```



---

## 作者：xtx1092515503 (赞：6)

这里介绍一种复杂度更优（理论复杂度 $O(n^3\log n)$）的方法。

不知道大家有没有做过[这道题](https://www.luogu.com.cn/problem/P3219)，它的做法就是在等腰直角三角形的场景下应用**扫描线**。我们在 $x$ 轴上做一条扫描线，并只求如下场景上的值：

1. 有一个三角形撞上了扫描线

2. 扫描线中某两个三角形不再相交

3. 有一个三角形离开了扫描线

其中(1)是很好处理的；(2)(3)可以合并处理，如下代码给出了求下一个特殊时刻的算法：

```cpp
int nex(){
	int mn=0x3f3f3f3f;
	for(int i=1;i<=m;i++)for(int j=1;j<=m;j++)if(p[j].second>p[i].first)mn=min(mn,p[j].second-p[i].first);
	return mn;
}
```

求特殊时刻扫描线上的有效长度，可以通过 $O(n\log n)$ 将扫描线上东西离散化后，$O(n^2)$ 地暴力异或更新或者 $O(n)$ 地差分更新求得。这里为了方便直接暴力更新了。

此部分代码：

```cpp
int calc(){
	v.clear();
	for(int i=1;i<=m;i++)v.push_back(p[i].first),v.push_back(p[i].second);
	sort(v.begin(),v.end()),v.resize(unique(v.begin(),v.end())-v.begin());
	for(int i=0;i+1<v.size();i++)occ[i]=false;
	for(int i=1;i<=m;i++){
		int x=lower_bound(v.begin(),v.end(),p[i].first)-v.begin(),y=lower_bound(v.begin(),v.end(),p[i].second)-v.begin();
		for(int j=x;j<y;j++)occ[j]^=1;
	}
	int ret=0;
	for(int i=0;i+1<v.size();i++)if(occ[i])ret+=v[i+1]-v[i];
	return ret;
}
```
两个特殊时刻间的面积，可以直接通过梯形面积公式求出。

时间复杂度 $O(n^3\log n)$，因为最多有 $O(n^2)$ 个特殊时间，每个特殊时间的有效长度需要 $O(n\log n)$ 地求出。

（所以明显本题可以被加强到 $n=100$，卡掉容斥的异端算法）

总代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
struct node{
	int x,y1,y2;
	friend bool operator <(const node &u,const node &v){return u.x<v.x;}
}a[20];
pair<int,int>p[20];
vector<int>v;
bool occ[100];
int nex(){
	int mn=0x3f3f3f3f;
	for(int i=1;i<=m;i++)for(int j=1;j<=m;j++)if(p[j].second>p[i].first)mn=min(mn,p[j].second-p[i].first);
	return mn;
}
int calc(){
	v.clear();
	for(int i=1;i<=m;i++)v.push_back(p[i].first),v.push_back(p[i].second);
	sort(v.begin(),v.end()),v.resize(unique(v.begin(),v.end())-v.begin());
	for(int i=0;i+1<v.size();i++)occ[i]=false;
	for(int i=1;i<=m;i++){
		int x=lower_bound(v.begin(),v.end(),p[i].first)-v.begin(),y=lower_bound(v.begin(),v.end(),p[i].second)-v.begin();
		for(int j=x;j<y;j++)occ[j]^=1;
	}
	int ret=0;
	for(int i=0;i+1<v.size();i++)if(occ[i])ret+=v[i+1]-v[i];
	return ret;
}
void nex(int x){
	for(int i=1;i<=m;i++)p[i].second-=x;
	int len=0;
	for(int i=1;i<=m;i++)if(p[i].first!=p[i].second)p[++len]=p[i];
	m=len;
}
long long res;
int main(){
//	freopen("I.in","r",stdin);
//	freopen("A.out","w",stdout);
	scanf("%d",&n);
	for(int i=1,x,y,z;i<=n;i++)scanf("%d%d%d",&x,&y,&z),a[i].x=x,a[i].y1=y,a[i].y2=y+z;
	sort(a+1,a+n+1);
	for(int i=1,las=0,laslen=0;;){
		if(!m&&i>n)break;
		int delta=nex();
		if(i<=n)delta=min(delta,a[i].x-las);
		nex(delta);
		int now=calc();
		if(las!=0)res+=1ll*delta*(now+laslen),las+=delta;
		else las=delta;
		if(i<=n&&a[i].x<=las)p[++m]=make_pair(a[i].y1,a[i].y2),i++,laslen=calc();
		else laslen=now;
	}
	printf("%lld.%d\n",res>>1,(res&1)?5:0);
	return 0;
}
```

---

## 作者：jiazhaopeng (赞：6)

[题目链接](https://www.luogu.com.cn/problem/P4515)

[博客链接](https://www.cnblogs.com/JiaZP/p/13471506.html)

一看范围那么小，就知道是~~状压~~暴力容斥。题目可以转化为，求 $t$ 个三角形的交的面积，乘一个系数 $k_t$ 作为贡献。

首先第一步，求交的面积。由于三角形都是相同方向的，直角边平行坐标轴的等腰直角三角形，我们有除了计算几何以外更方便的方法。

考虑到如果有交，那么交一定也是一个三角形。这个三角形的左下角顶点坐标很好求，是 $(\max(x_i),\max(y_i))$。那么就差求边长或者斜边了。显然，斜边一定是最靠“左下”的那根直线，即 $x + y$ 最小的那根直线，这个其实就是直线 $x+y=\min(x_i+y_i+r_i)$。这样，左下角顶点和斜边方程找到以后，面积也就好求很多了。$S=\dfrac{(\min(x_i+y_i+r_i)-\max(x_i)-\max(y_i))^2}{2}$。另外，如果没有交，需要特判一下。

然后第二步，求容斥系数。我们需要系数 $k_i$，满足 $t$ 个三角形的交被算了恰好 $[2 \nmid t]$ 次。即

$$\sum_{i=0}^t{t \choose i}k_i=[2 \nmid t]$$

看起来好像二项式反演的式子。我们设 $g_t=[2 \nmid  t]$，那么：

$$g_t=\sum_{i=0}^t {t \choose i}k_i$$

$$k_t=\sum_{i=0}^t {t \choose i} (-1)^{t-i}g_i$$

$i$ 为偶数的时候没有贡献，那么:

$$k_t=(-1)^{t-1}\sum_{i=0}^t {t \choose i}[2 \nmid i]$$

二项式定理：

$$k_t=(-1)^{t-1}\frac{(1+1)^t-(1-1)^t}{2}=(-2)^{t-1}$$

最后直接暴力$2^n$容斥即可。


```cpp
#include <cstdlib>
#include <cstdio>
#include <iostream>
#include <cmath>
#include <string>
#include <cstring>
#include <ctime>
#include <algorithm>
typedef long long ll;
template <typename T> inline void read(T &x) {
	x = 0; char c = getchar(); bool flag = false;
	while (!isdigit(c)) { if (c == '-')	flag = true; c = getchar(); }
	while (isdigit(c)) { x = (x << 1) + (x << 3) + (c ^ 48); c = getchar(); }
	if (flag)	x = -x;
}
using namespace std;
const int inf = 987654321;
inline void MIN(int &a, int b) {
	if (b < a)	a = b;
}
inline void MAX(int &a, int b) {
	if (b > a)	a = b;
}
int n;
int X[12], Y[12], R[12];
int mi[12];
ll ans;
inline ll Pow(int x) {
	return 1ll * x * x;
}
inline void work(int s) {
	int mn = inf, mxx = -inf, mxy = -inf, ct = 0;
	for (register int i = 0; i < n; ++i) if ((s >> i) & 1) {
		MIN(mn, X[i] + Y[i] + R[i]);
		MAX(mxx, X[i]);
		MAX(mxy, Y[i]);
		++ct;
	}
	ans += 1ll * mi[ct - 1] * Pow(max(0, mn - mxx - mxy));
}
int main() {
	read(n);
	for (register int i = 0; i < n; ++i)	read(X[i]), read(Y[i]), read(R[i]);
	mi[0] = 1;
	for (register int i = 1; i <= n; ++i)	mi[i] = -2 * mi[i - 1];
	int All = (1 << n) - 1;
	for (register int s = 1; s <= All; ++s) {
		work(s);
	}
	printf("%.1lf\n", 0.5 * ans);
	return 0;
}
```

---

## 作者：kernel_panic (赞：2)

## 思路

记第 $i$ 个三角形的左下顶点坐标为 $(a_i, b_i)$，腰长为 $c_i$。以下分析省略三角形面积中 $\frac{1}{2}$ 的常数，最后一起除！

直接考虑容斥，凑一下可以发现系数是 $(-2)^{|S| - 1}$。设 $f_S$ 表示集合 $S$ 中三角形交的面积，答案为：

$$
\sum_{S} (-2)^{|S| - 1} f_S
$$

考虑如何计算 $f_S$。画图可以发现，这些三角形的交也是一个等腰三角形，且顶点为 $(\max_{i \in S} a_i, \max_{i \in S} b_i)$，斜边解析式为 $y = -x + \min_{i \in S} \{a_i + b_i + c_i\}$。故面积为 $(\min_{i \in S} \{a_i + b_i + c_i\} - \max_{i \in S} a_i - \max_{i \in S} b_i)^2$。

此时直接暴力枚举集合计算，复杂度 $O(n 2^n)$，足以通过本题。但是我们考虑一个更牛的做法就是，我们把三角形按 $a_i + b_i + c_i$ 降序排序，这样第一个 $\min$ 就只和集合中编号最大的元素有关了！于是可以设 $f_{i, j, p, q}$ 为当前考虑了前 $i$ 个三角形，选了 $j$ 个，$\max x_i = p$，$\max y_i = q$ 的方案数，有转移：

$$
\begin{aligned}
f_{i - 1, j, p, q} &\to f_{i, j, p, q} \\
f_{i - 1, j - 1, p, q} &\to f_{i, j, \max\{p, a_i\}, \max\{q, b_i\}}
\end{aligned}
$$

令 $g_{i, j, p, q}$ 为钦定 $i$ 选时的 $f_{i, j, p, q}$，答案可写作：

$$
\sum_{i = 1}^n \sum_{j = 1}^i (-2)^{j - 1} \sum_p \sum_q g_{i, j, p, q} \times \max\{0, a_i + b_i + c_i - p - q\}^2
$$

直接做，时间复杂度 $O(n^4)$。还能不能再牛一点？

考虑将容斥系数拆成 $(-1)^{|S| - 1} 2^{|S| - 1}$，然后将第二部分塞到 DP 里计算，这样就只用记录选取个数的奇偶性。具体地，我们重新设 $f_{i, b, p, q}$ 为考虑了前 $i$ 个三角形，选了 $j$ 个，$j \bmod 2 = b$，$\max x_i = p$，$\max y_i = q$ 的方案数乘 $2^{j - 1}$ 的值，有转移：

$$
\begin{aligned}
f_{i - 1, b, p, q} &\to f_{i, b, p, q} \\
2 \times f_{i - 1, (b - 1) \bmod 2, p, q} &\to f_{i, b, \max\{p, a_i\}, \max\{q, b_i\}}
\end{aligned}
$$

对 $g_{i, j, p, q}$ 做类似的改动，答案可写作：

$$
\sum_{i = 1}^n \sum_{j < 2} (-1)^{j + 1} \sum_p \sum_q g_{i, j, p, q} \times \max\{0, a_i + b_i + c_i - p - q\}^2
$$

时间复杂度 $O(n^3)$。

实现上有个细节就是，中间结果可能很大，但是答案是在 $10^6 \times 10^6 = 10^{12}$ 这个范围之内的，故可找个大于这个范围的数，对其取模。

## 代码

```cpp
#include <cstdio>
#include <algorithm>
#include <cstring>
#define debug(...) fprintf(stderr, __VA_ARGS__)

using i64 = long long;

inline i64 rd() {
    i64 x = 0, f = 1, c = getchar();
    while (((c - '0') | ('9' - c)) < 0)
        f = c != '-', c = getchar();
    while (((c - '0') | ('9' - c)) > 0)
        x = x * 10 + c - '0', c = getchar();
    return f ? x : -x;
}

using i128 = __int128_t;

const int N = 100;
const i128 P = 1000000000000000003;
const i128 I2 = 500000000000000002;

int n; struct ele { int x, y, l; } a[N + 5];
int bx[N + 5], xc, by[N + 5], yc;
i128 pw[N + 5], f[2][2][N + 5][N + 5];

int main() {
    n = rd();
    for (int i = 1; i <= n; i++) {
        int x = rd(), y = rd(), l = rd();
        a[i] = {x, y, l}, bx[i] = x, by[i] = y;
    }
    std::sort(bx + 1, bx + 1 + n), xc = std::unique(bx + 1, bx + 1 + n) - (bx + 1);
    std::sort(by + 1, by + 1 + n), yc = std::unique(by + 1, by + 1 + n) - (by + 1);
    std::sort(a + 1, a + 1 + n, [](ele a, ele b) { return a.x + a.y + a.l > b.x + b.y + b.l; });
    for (int i = 1; i <= n; i++) a[i].x = std::lower_bound(bx + 1, bx + 1 + xc, a[i].x) - bx;
    for (int i = 1; i <= n; i++) a[i].y = std::lower_bound(by + 1, by + 1 + yc, a[i].y) - by;

    i128 ans = 0;

    f[0][0][0][0] = I2;
    for (int i = 1; i <= n; i++) {
        memset(f[i & 1], 0, sizeof(f[i & 1]));
        static i128 g[2][N + 5][N + 5]; memset(g, 0, sizeof(g));
        for (int j = 0; j <= 1; j++) {
            for (int p = 0; p <= xc; p++) {
                int np = std::max(p, a[i].x);
                for (int q = 0; q <= yc; q++) {
                    int nq = std::max(q, a[i].y);
                    (f[i & 1][j][p][q] += f[(i - 1) & 1][j][p][q]) %= P;
                    (f[i & 1][j][np][nq] += 2 * f[(i - 1) & 1][j ^ 1][p][q]) %= P;
                    (g[j][np][nq] += 2 * f[(i - 1) & 1][j ^ 1][p][q]) %= P;
                }
            }
        }
        for (int j = 0; j <= 1; j++) {
            i128 tot = 0, L = bx[a[i].x] + by[a[i].y] + a[i].l;
            for (int p = 0; p <= xc; p++) {
                for (int q = 0; q <= yc; q++) {
                    i128 l = std::max<i128>(0, L - bx[p] - by[q]);
                    (tot += l * l % P * g[j][p][q] % P) %= P;
                }
            }
            (ans += (!j) ? P - tot : tot) %= P;
        }
    }

    printf("%lld.%d\n", (i64)ans >> 1, (ans & 1) ? 5 : 0);
    return 0;
}
```

---

## 作者：1saunoya (赞：2)

令 $g_i$ 为容斥系数。

使得 $\sum_{i}^{t} \binom{t}{i} g_i = [2 \nmid t]$。

令 $f_t = [2\nmid t]$。

二项式反演 $f_t = \sum_{i}^{t} \binom{t}{i} g_i \iff g_t = \sum_{i}^{t} (-1)^{t-i} \binom{t}{i}f_i$。


然后我们发现 $f_i$ 在 $[2 \mid i]$ 的时候没有贡献。

$g_t = (-1)^{t-1} \sum_{i}^{t}\binom{t}{i}f_i$。

考虑后面半部分 $\sum_{i}^{t} \binom{t}{i}1^{t-i}f_i$。

二项式定理$(x+y)^n = \sum_{k}^{n}\binom{n}{k}x^{n-k}y^k$。

考虑 $f_i$ 是交替的 0/1。整体乘上 $2$ 就可以认为 $f'_i = 1$。

$(1+1)^n = \sum_{k}^{n}\binom{n}{k} 1^{n-k}1^k$。

那么 $\sum_{k}^{n}\binom{n}{k} 1^{n-k}1^k = \sum_{i}^{t} \binom{t}{i}1^{t-i}f_i \times 2$

所以 $g_t = (-1)^{t-1} \times \frac{(1+1)^t}{2} = (-2)^{t-1}$

然后暴力状压就做完了。

---

## 作者：lzkAK2009 (赞：1)

观察到黑色部分非常复杂，无法直接求面积，但等腰直角三角形的交都是等腰直角三角形，面积好求，所以考虑容斥。

首先需要考虑如何求**若干三角形交的面积**。前文提到，所有等腰直角三角形的交都是等腰直角三角形，只需解决两个三角形的交。

可以观察到，新三角形顶点的横坐标就是原来两个三角形中横坐标的最大值，纵坐标就是两个纵坐标中最大的，斜边的截距就是两条斜边中截距最小的。把斜边的解析式求出后，就可得到新的 $R = \min (x + y + r) - \max (x) - \max (y)$

如果 $R \le 0$，则说明不存在交，把新三角形的 $R$ 设为 $0$ 即可。

接下来，考虑容斥，我们发现如果题目求的是所有被覆盖的面积，也就是奇偶都有贡献，容斥系数就是 $(-1) ^ {|S|}$（$S$ 指我们选的三角形集合），但本题中，面积被奇数个三角形包围时有贡献，被偶数个三角形包围时无贡献，就需要我们来凑容斥系数。

设集合大小为 $t$，容斥系数为 $g(t)$。即
$$ \sum _ {i = 1} ^ t {t \choose i} g(i) = [2 \nmid t] $$
因为0个三角形的面积交没有意义，所以 $i$ 从 $1$ 开始。

为了得到组合数，我们将右边表示为 $-1$ 的幂的形式，再用二项式定理展开。即
$$ \begin{aligned} [2 \nmid t] &= \frac {(-1) ^ {t - 1} + 1} {2} \\ &= \frac {(-2 + 1) ^ t - 1} {-2} \\ &= \frac {\sum _ {i = 0} ^ t {t \choose i} (-2) ^ i - 1} {-2} \\ &= \frac {\sum _ {i = 1} ^ t {t \choose i} (-2) ^ i}{-2} \\ &= \sum _ {i = 1} ^ t {t \choose i} (-2) ^ {i - 1} \end{aligned}$$
故容斥系数 $g (t) = (-2) ^ {t - 1}$。

从 $1$ 枚举到 $2 ^ n - 1$ 容斥即可。需要注意浮点数左移无意义，先把三角形的面积当作 $r ^ 2$ 计算，最后再除以 $2$。

代码：
```cpp
#include <bits/stdc++.h>

using namespace std;

int n;

long long ans;

struct trian {
	int x, y, r;
}t[11];

trian interse (trian i, trian j) {
	int a = max (i.x, j.x), b = max (i.y, j.y), c = min (i.r + i.x + i.y, j.r + j.x + j.y);
	int r = c - a - b;
	if (r <= 0)
		r = 0;
	return (trian) {a, b, r};
}

int main () {
	scanf ("%d", &n);
	for (int i = 1; i <= n; i++)
		scanf ("%d%d%d", &t[i].x, &t[i].y, &t[i].r);
	for (int i = (1 << n) - 1; i; i--) {
		int l = 0;
		trian s;
		for (int j = 0; j < n; j++)
			if (i >> j & 1) {
				if (!l)
					s = t[j + 1];
				else s = interse (s, t[j + 1]);
				l++;
			}
		l--;
		long long a = s.r * s.r;
		a <<= l;
		if (l & 1)
			a = -a;
		ans += a;
	}
	printf ("%lld", ans >> 1);
	if (ans & 1)
		printf (".5");
	else printf (".0");
	return 0;
}
``````

---

## 作者：Hexarhy (赞：1)

### Preface

数学题。第一次练二项式反演，感觉很有趣。

**前置知识：二项式定理，二项式反演，容斥原理。**

### Description

给定 $n$ 个等腰直角三角形的顶点坐标和腰长，且每个三角形顶点一定在左下角，两边与坐标轴平行。求出被奇数个三角形所覆盖的区域的面积和。

数据规模：$1\le n \le 10$，坐标与腰长的值域为 $[1,10^6]$。

### Solution

看着样例图就觉得像容斥。

先考虑相交的三角形面积怎么算。设其面积为 $S,c_i=x_i+y_i+r_i$，则三角形面积为：

$$\dfrac{1}{2}(\min\{c_i\}-\max\{x_i\}-\max\{y_i\})^2$$

画个图，发现无论如何相交部分一定是等腰直角三角形，再用下直线解析式就很轻松得出来。**这里就必须自己动手画了。**

-----------

接下来就是算容斥系数 $k_i$。根据题意，有：

$$\sum_{i=0}^n \binom{n}{i}\times k_i= [2\nmid n]$$

设 $g(n)=[2\nmid n]$，则

$$g(n)=\sum^n_{i=0}\binom{n}{i}\times k_i$$

二项式反演得：

$$k_n=\sum^n_{i=0}(-1)^{n-i}\binom{n}i{}g_{i} $$

$2|i$ 时 $g(i)=0$，答案没有贡献，所以： 

$$k_n=\sum^n_{i=0}(-1)^{n-1}[2\nmid i]\binom{n}{i}=(-1)^{n-1}\sum^n_{i=0}\binom{n}{i}[2\nmid i]$$

发现 $\sum$ 那里很像二项式定理，只不过偶数项为 $0$。因此，消除偶数项用常见的加减消元：

$$(a+b)^n+(a-b)^n=\sum^n_{i=0}\binom{n}{i}a^{n-i}b^i+\sum^n_{i=0}(-1)^i\binom{n}{i}a^{n-i}b^i$$

$$(a+b)^n+(a-b)^n=2\times \sum^n_{i=0}[2\nmid i]\binom{n}{i}a^{n-i}b^{i}$$

于是就有：

$$k_n=(-1)^{n-1}\times \dfrac{(1+1)^n+(1-1)^n}{2}=(-2)^{n-1}$$

别忘了 $k_0=1$。

活干完了，二进制枚举状态再做容斥即可，时间复杂度 $O(2^n\times n)$。

### Code

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<climits>
using namespace std;

typedef long long ll;
const int MAXN=1500;
int n,N;
double ans;
struct triangle
{
	int x,y,r,c;
}a[MAXN];
ll k[MAXN];

void solve(const int s)
{
	int c=INT_MAX,x=INT_MIN,y=INT_MIN,t=0;
	for(int i=0;i<n;i++)
		if((s>>i)&1)
		{
			t++;
			c=min(c,a[i].c);
			x=max(x,a[i].x);
			y=max(y,a[i].y);
		}
	if(c-x-y<=0)	return;
	ans+=1ll*(c-x-y)*(c-x-y)/2.0*k[t-1];
}

int main()
{
	cin>>n;k[0]=1;
	for(int i=0;i<n;i++)	cin>>a[i].x>>a[i].y>>a[i].r;
	for(int i=0;i<n;i++)	a[i].c=a[i].x+a[i].y+a[i].r;
	for(int i=1;i<=n;i++)	k[i]=-2*k[i-1];
	for(int i=1;i<=(1<<n)-1;i++)	solve(i);
	printf("%.1lf\n",ans);
	return 0;
}
```

---

## 作者：gan1234 (赞：0)

求面积并一般是转化为更简单的交来容斥一下求。

对于一般的面积并容斥系数为 $(-1)^{i+1}$。为什么是这个数呢？因为 $\sum^n_{i=1} \binom n i (-1)^{i+1}=1$。这样我们可以保证对于一块面积，枚举所有覆盖的它的三角形的集合的子集来计算后恰好为 $1$。

本题求得面积是异或面积，但是我们可以仿照上面的做法。

对于一块面积，覆盖它的三角形数为偶数时，答案为 $0$，否则答案为 $1$。也就是说我们需要构造出一个函数 $f(x)$ 满足：

$$\sum^n_{i=1}\binom n i f(i)=[n\bmod 2=1]$$

我们根据这个式子，可以反过来递推 $f(i)$ 的值，我们有：

$$f(i)=(n \bmod 2)-\sum^{i-1}_{k=1}\binom ik f(k)$$

直接预处理 $f$ 然后算出面积交直接乘上 $f$ 即可。

#### 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n;
struct P{
    int x,y;
};
struct T{
    int x,y,r;
}a[15];
int chk(T t,P p){
    return p.x>=t.x&&p.y>=t.y&&p.x+p.y<=t.x+t.y+t.r;
}
double getS(T t){
    return (double)t.r*t.r/2.0;
}
T getc(T t1,T t2){
    if(chk(t1,P{t2.x,t2.y})||chk(t1,P{t2.x+t2.r,t2.y})||chk(t1,P{t2.x,t2.y+t2.r}))swap(t1,t2);
    if(chk(t2,P{t1.x,t1.y})&&chk(t2,P{t1.x+t1.r,t1.y})&&chk(t2,P{t1.x,t1.y+t1.r}))return t1;
    if(chk(t2,P{t1.x,t1.y}))return T{t1.x,t1.y,t2.y+t2.r-t1.y-(t1.x-t2.x)};
    else if(chk(t2,P{t1.x+t1.r,t1.y}))return T{t2.x,t1.y,t1.x-t2.x+t1.r};
    else if(chk(t2,P{t1.x,t1.y+t1.r}))return T{t1.x,t2.y,t1.y-t2.y+t1.r};
    return T{0,0,0};
}
int f[15];
int C[15][15];
double ans;
signed main(){
    cin>>n;
    for(int i=1;n>=i;i++)cin>>a[i].x>>a[i].y>>a[i].r;
    for(int i=0;n>=i;i++)C[i][0]=1;
    for(int i=1;n>=i;i++)
        for(int j=1;n>=j;j++)C[i][j]=C[i-1][j]+C[i-1][j-1];
    for(int i=1;n>=i;i++){
        for(int j=i-1;j;j--)
            f[i]-=C[i][j]*f[j];
        if(i&1)f[i]++;
    }
    for(int S=1;(1<<n)>S;S++){
        T t=T{0,0,10000001};
        for(int i=1;n>=i;i++)
            if(S&(1<<(i-1)))t=getc(t,a[i]);
        ans+=(double)f[__builtin_popcount(S)]*getS(t);
    }
    printf("%.1lf",ans);
    return 0;
}
```

---

## 作者：封禁用户 (赞：0)

### 题意：

平面直角坐标系中有一些等腰直角三角形，且直角边平行于坐标轴，直角顶点在右下方，求奇数次被覆盖的面积。$N\le10$。输入为 $x,y,r$，分别表示三角形顶点的坐标与三角形的边长。

### 思考：

看到数据范围，就肯定是优美的暴力。

这题思路很清奇。首先我们要先求出任意几个三角形面积的交，但我们知道两个之间的关系就行了，因为这样特殊的三角形最后的交必然一模一样（只是缩放了）。

为了算出面积的交，我们先考虑算出最后交的三角形的边长，因为这样子平方一下除以二就是面积。

我们还知道，交的边长关于 $x,y,r$ 一定是一次关系，至少是只有一次项，而且没有常数。我们不妨考虑这些三角形的 $y$ 都相等。不难发现，若有 $n$ 个三角形重叠，则数量上的贡献为 $(-2)^n-1$，具体证明归纳法。

dfs 一下即可。

代码：

```cpp
 #include<bits/stdc++.h>
  using namespace std;
  typedef long long int ll;
  const ll maxn=15;
  const ll inf=INT_MAX;
  ll max(ll x,ll y){return x>y?x:y;}
  ll x[maxn],y[maxn],r[maxn],n,ans;
  void dfs(ll s,ll maxx,ll maxy,ll maxc,ll g)
  {
     if(s==n+1)
     {
         if(g>=1)ans+=pow(-2,g-1)*max(0,maxc-maxx-maxy)*max(0,maxc-maxx-maxy);
         return;
     }
     dfs(s+1,maxx,maxy,maxc,g);
     dfs(s+1,max(maxx,x[s]),max(maxy,y[s]),min(maxc,x[s]+y[s]+r[s]),g+1);
 }
 int main()
 {
     ios::sync_with_stdio(false);
     cin>>n;
     for(int i=1;i<=n;++i)cin>>x[i]>>y[i]>>r[i];
     dfs(1,0,0,inf,0);
     cout<<fixed<<setprecision(1)<<double(ans)/2<<endl;
     return 0;
 }
```
[AC记录](https://www.luogu.com.cn/record/193376727)

管理大大幸苦了，求过。

---

## 作者：_HCl_ (赞：0)

简单的容斥，建议降蓝。（虽然我一开始脑瘫推出了假结论）

# P4515 题解

**题意简述**

给出 $n$ 个等腰直角三角形，求出它们的异或和面积。

**思路引导**

由于 $n\leq 10$，显然可以暴力容斥。

先考虑怎么计算一堆三角形的面积交。我们可以把三角形一个一个地往上去和目前的图形去交。不难发现，交出的结果一定也是一个等腰直角三角形。那么求一堆三角形的面积交就转化成了求若干次两个直角三角形的面积交。

直接用题目的三个参数去计算面积交比较困难，我们可以转换思路。考虑如何表示一个直角三角形。对于三角形 $(X,Y,R)$，我们可以用三条直线（竖边，横边，斜边）来表示：横边 $y=Y$，竖边 $x=X$，斜边 $x+y=X+Y+R$。

显然，两个三角形的交的三条边都来自原来的两个三角形。具体地，新三角形的竖边是原三角形靠右的那一条，横边是原三角形靠上的那一条，斜边是原三角形靠左下的那一条。形式化地，三角形 $(X_0,Y_0,R_0)$ 和 $(X_1,Y_1,R_1)$ 的交的三条边分别是 $x=\max(X_0,X_1)$，$y=\max(Y_0,Y_1)$，$x+y=\min(X_0+Y_0+R_0,X_1+Y_1+R_1)$。那么新三角形的腰长就是 $\min(X_0+Y_0+R_0,X_1+Y_1+R_1)-\max(X_0,X_1)-\max(Y_0,Y_1)$。

设 $A_S$ 表示集合 $S$ 内三角形的面积交。那么答案就是：
$$
\sum_{S}(-2)^{|S|-1}\cdot A_S
$$

这个容斥系数算是一个结论吧？证明略去。

**代码**

```cpp
#include<bits/stdc++.h>
#define LL long long
using namespace std;
int n,x[11],y[11],r[11];
int main(){
	cin>>n;
	for(int i=1;i<=n;++i)
		scanf("%d%d%d",x+i,y+i,r+i);
	double ans=0; 
	for(int s=1;s<(1<<n);++s){
		int cnt=0,curx=0,cury=0,curl=1e9;
		for(int i=1;i<=n;++i){
			if(s&(1<<(i-1))){
				cnt++;
				curx=max(curx,x[i]);
				cury=max(cury,y[i]);
				curl=min(curl,x[i]+y[i]+r[i]);
			}
		}
		int rr=max(curl-curx-cury,0);
		LL area=1ll*rr*rr;
		ans+=area*(1ll<<(cnt-1))*((cnt&1)?1:-1);
	}
	ans/=2;
	printf("%.1lf",ans);
	return 0;
}
```

---

## 作者：Genius_Star (赞：0)

### 思路：

#### Sub1：

首先考虑容斥原理，因为要求被覆盖奇数次的位置，所以要重新求一个容斥系数 $f(i)$，要使得：

$$\sum_{i=0}^n C_{n,i} \times f(i) = [2 \nmid n]$$

发现符合二项式反演的式子，令 $g(i)= [ 2 \nmid i]$，则推出：

$$\begin{cases} g(n) = \sum\limits_{i=0}^n C_{n,i} \times f(i) \\ f(n) = \sum\limits_{i=0}^n C_{n,i} \times (-1)^{n-i} \times g(i)\end{cases}$$

因为 $i$ 为偶数的时候没有贡献，所以只用看 $n$ 的奇偶性，则原式可以化为：

$$(-1)^{n-1} \sum_{i=0}^n C_{n,i}  \times g(i)$$

发现 $g(i)$ 是一个 $0/1$ 交替的序列，无法直接套用二项式定理。

考虑一个加减消元：

$$(a+b)^n + (a-b)^n = \sum_{i=0}^n C_{n,i} \times a^{n-i}  \times b_i + \sum_{i=0}^n (-1)^i \times C_{n,i} \times a^{n-i}  \times b_i$$

因为有同类项，是可以合并的，则当 $2 \nmid i$ 时，该项直接为 $0$，即可以转化为：

$$2 \times \sum_{i=0}^n [2 \nmid i] C_{n,i} \times a^{n-i} \times b_i = 2 \times \sum_{i=0}^n g(i) \times C_{n,i} \times a^{n-i} \times b_i$$

原式是：

$$\sum_{i=0}^n C_{n,i} \times  1^{n-i} \times 1^i \times g(i) = \frac{(1-1)^n + (1+1)^n}{2} = 2^{n-1}$$

所以得：

$$f(n) = (-2)^{n-1}$$

#### Sub2：

现在想一下如何求两个三角形的交，首先有两个结论：

- 两个三角形的交一定也是一个三角形（后称新三角）。

- 新三角的三条边是由原来两三角形的边组成的。

对于一个三角形有三个元素 $(X_i,Y_i,R_i)$ 和三条边其三条边所在的直线解析式分别是：

- 底：$y=Y_i$。

- 高：$x=X_i%$。

- 斜边：$x+y=X_i+Y_i+R_i$。

对于两个三角形 $(X_i,Y_i,R_i)$ 和 $(X_j,Y_j,R_j)$；画一下图可知，新三角的底所在的直线为 $y=\max(Y_i,Y_j)$，高所在的直线为 $x=\max(X_i,Y_i)$，斜边所在的直线为 $x+y=\min(X_i+Y_i+R_i,X_j+Y_j+R_j)$。

那么可以得到新三角的三元素为 $(\max(X_i,Y_i),\max(Y_i,Y_j),\min(X_i+Y_i+R_i,X_j+Y_j+R_j)-\max(X_i,Y_i)-\max(Y_i,Y_j))$，若新的 $R \le 0$，那么这两个三角形就不存在交集。

每次求出交的时间复杂度是 $O(1)$ 的。

-----

于是直接枚举二进制的全集，算出这些三角形的并，然后乘上容斥系数计算即可，时间复杂度为 $O(2^N \times N)$。

### 完整代码：

```cpp
#include<bits/stdc++.h>
#define NLL Node(0,0,0)
using namespace std;
typedef long long ll;
typedef double db;
const ll N=12;
inline ll read(){
    ll x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')
          f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=(x<<1)+(x<<3)+(c^48);
        c=getchar();
    }
    return x*f;
}
inline void write(ll x){
	if(x<0){
		putchar('-');
		x=-x;
	}
	if(x>9)
	  write(x/10);
	putchar(x%10+'0');
}
struct Node{
	ll x,y,r;
	Node(ll _x,ll _y,ll _r){
		x=_x;
		y=_y;
		r=_r;
	}
	Node(){}
	bool operator==(const Node&rhs)const{
		return x==rhs.x&&y==rhs.y&&r==rhs.y;
	} 
}a[N];
ll n,sum;
db ans;
Node t;
Node merge(Node x,Node y){
	Node ans;
	ans.x=max(x.x,y.x);
	ans.y=max(x.y,y.y);
	ans.r=min(x.x+x.y+x.r,y.x+y.y+y.r)-ans.x-ans.y;
	if(ans.r<=0)
	  ans=NLL;
	return ans;
}
ll size(Node x){
	return x.r*x.r;
}
int main(){
	n=read();
	for(int i=1;i<=n;i++)
	  a[i]={read(),read(),read()};
	for(int i=1;i<(1ll<<n);i++){
		sum=0; 
		for(int j=1;j<=n;j++){
			if((i>>(j-1))&1ll){
				if(sum)
				  t=merge(t,a[j]);
				else
				  t=a[j];
				sum++;
			}
		}
		if((sum-1)&1ll)
		  ans-=(1ll<<(sum-1))*size(t);
		else
		  ans+=(1ll<<(sum-1))*size(t);
	}
	printf("%.1lf\n",ans/2.00);
	return 0;
}
```

---

## 作者：_Aurore_ (赞：0)

# [COCI2009-2010#6] XOR

本文同步发表于[我的博客](https://www.cnblogs.com/Diavolo/)

## 题目描述

坐标系下有若干个等腰直角三角形，且每个等腰直角三角形的直角顶点都在左下方，两腰与坐标轴平行。被奇数个三角形覆盖的面积部分为灰色，被偶数个三角形覆盖的面积部分为白色，如下图所示。
![](https://cdn.luogu.com.cn/upload/pic/18669.png)
已知 $N$个等腰直角三角形的顶点坐标及腰长，求灰色部分面积。

$1 \leq N \leq 10, 1 \leq X, Y, R \leq 10^6$

## 思路点拨

### 容斥做法
这题的数据范围十分的明显, $n=10$ ,搜索,状压,容斥什么的。再加上本题的题目配图,很容易往容斥的角度思考问题。本题具体有两种容斥做法:

#### 第一种(不好想但是简单)
我们假设一片区域被 $m$ 个三角形包含,这 $m$ 个三角形共同组成了一个集合 $S$
有一个结论:

$$[2 \nmid m]=\sum_{T \subseteq S}(-1)^{|T|+1}2^{|T|-1}$$

这里给出一个简单的证明:

$$\sum_{T \subseteq S}(-1)^{|T|+1}2^{|T|-1} = \sum_{i=1}^{|S|}C_{m}^{i} (-1)^{i+1}2^{i-1}$$

$(-1)^{i+1}=(-1)^{i-1}$ 本质上是一样的,方便与后面的 $2^{i-1}$ 同类项。
$$=\sum_{i=1}^{m}C_{m}^{i} (-1)^{i-1}2^{i-1}=\sum_{i=1}^m C_{m}^i (-2)^{i-1}$$

这个东东有点像 $(-2+1)^m$ 的二项式定理展开式,我们将 $(-2)^{i-1}$ 凑成 $(-2)^{i}$ , 然后二项式定理减去 $i=0$ 的贡献就可以了。

$$=\dfrac{-1}{2}\sum_{i=1}^m C_{m}^i (-2)^{i}=\dfrac{\sum_{i=0}^m C_{m}^i (-2)^{i}-1}{-2}$$

$$=\dfrac{1-(-2+1)^{m}}{2} = [2 \nmid m]$$

OK,我们就获得了一个容斥系数。代码实现比较简单。

#### 第二种(好想,二项式反演)

我们令 $f(m)$ 表示 $m$ 的容斥系数, $g(m)=[2 \nmid m]$ 。

那么应该有 $$g(m)=\sum_{i=1}^m C_{m}^i f(i)$$

二项式反演得:

$$f(m)=\sum_{i=0}^m (-1)^{m-i} C_{m}^i g(i)$$

其实以上两种方法得到的容斥系数是一样的,至于为什么是一样的,留给读者自己思考。可以从杨辉三角或者组合恒等式的角度进行思考。

以上的两种做法都需要使用多个三角形求交,初中数学自己推一下,这里给出代码:

## $code$

`````
#include<bits/stdc++.h>
#define int long long
using namespace std;
inline int read(){
	int x=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){
		if(ch=='-') f=-f;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9'){
		x=x*10+ch-'0';
		ch=getchar();
	}
	return x*f;
}
const int MAXN=11;
int n;
struct node{
	int x,y,w;
}a[MAXN];
int siz(node A){
	return A.w*A.w;
}
node insert(node A,node B){
	node C;
	C.x=max(A.x,B.x);
	C.y=max(A.y,B.y);
	C.w=max((int)0,min(A.x+A.y+A.w,B.x+B.y+B.w)-C.x-C.y);
	return C;
}
signed main(){
	n=read();
	for(int i=1;i<=n;i++){
		a[i].x=read(),a[i].y=read();
		a[i].w=read();
	}
	int ans=0; 
	for(int i=1;i<(1<<n);i++){
		node temp;
		int flag=0,popcount=0;
		for(int j=0;j<n;j++){
			if(!(i&(1<<j))) continue;
			popcount++;
			if(!flag){
				temp=a[j+1];
				flag=1;
			} 
			else temp=insert(temp,a[j+1]);
		}
		if(popcount&1) ans+=(siz(temp)<<popcount);
		else ans-=(siz(temp)<<popcount);
	}
	printf("%.1lf",1.0*ans/4);
	return 0;
}
`````

---


# [CmdOI2019] 高塔与晶石

## 题目背景

**温馨提示 : 请注意常数因子对程序效率带来的影响 + 本题特殊的空间限制**

几何王国之中，矗立着$n$座古老的高塔，传说，它们是这片净土的守护者。

随着几何学日新月异的发展，王国的繁荣引来了烈炎深处的恐怖：动点P。

驯服动点恶龙的英雄笛卡尔尚未出现，几何王国的领主决定固守静态几何的阵地。



## 题目描述

他得到了静态几何的三颗智慧晶石(里面当然是神级数学题啦)，并且可以把它们安放在高塔之中。

三颗安放着晶石的高塔，可以保护其围成的三角形内部不受侵入。

但是，如果晶石围成的三角型面积太大，防线将会十分容易被击破。

如果三角型面积太小，其中能够产生的几何能量又不足以维持晶石的运作。

经过几天的推算，领主在认为， $\binom{n}{3}$ 种做法中,面积第 $k$ **小**的方案是最合适的。

(三角形面积可以为 $0$)

他对这个结果很不放心，于是拜托单手虐爆无数几何题的你,来帮他计算这个面积具体是多少。

## 说明/提示

| subtask编号 | 　n　 | 备注 | 分值 | 时限 |
| :--: | :--: | :--: | :--: | :--: |
| 1 | 200 | - | 15 | 1S |
| 2 | 500 | $k\leq10$ | 20 | 1S |
| 3 | 500 | $k\leq10000$ | 15 | 1S |
| 4 | 800 | - | 50 | 2S |

$1\leq x_i,y_i \leq 10^6$ , 所有坐标都是正整数 , 高塔的坐标不会重复。

**样例解释:**

![](https://cdn.luogu.com.cn/upload/image_hosting/y3is3hxv.png)

## 样例 #1

### 输入

```
4 3
2 3
3 4
4 3
3 1```

### 输出

```
3```

# 题解

## 作者：yyandy (赞：6)

**注：本篇题解的做法是官方题解底下提到的开桶分段统计做法，复杂度较劣，要学习更加优秀的做法，请看官方题解。**      


------------

**题意：**

求平面上 $n$ 个点围成的 $\binom{n}{3}$ 个三角形中面积第 $k$ 小的三角形面积（三角形面积可以为 $0$）。    
数据范围：$n\le 800$。



------------
**题解：**

由于 $n\le 800$，而枚举 $3$ 个不同的点又带着 $\frac{1}{6}$ 的小常数。    
所以是可以直接枚举所有三角形计算面积的。     
计算面积可以直接使用叉积计算，不会的可以看[这里](https://www.luogu.com.cn/problem/P1183)。      
现在的问题就是如何快速求出 $k$ 大。    

一个非常简单的想法就是将所有面积值存下来然后再 `nth_element`求。    
但是注意到本题空间限制非常的紧，直接存肯定会爆，这种想法走不通。

另一种想法是开桶存三角形面积。    
但是值域非常大，而且桶里的元素可能会非常多，照样行不通。      
不过这种做法能非常容易拓展改进，比上一种做法灵活。      
如果一个桶里装的不是面积恰好为一个值的三角形，而是面积大小在一段范围内的三角形，就可以开较少的桶，也就不会 MLE 了。    
具体的，搞个阈值 $B$，第 $i+1$ 个桶存面积大小为 $\lbrack iB,(i+1)B)$ 的三角形个数。    
这样通过一次枚举我们就能快速求出第 $k$ 大的三角形面积范围。       
再做一次然后把符合这段范围的三角形再加进另一个桶里进行计算就可以了。      
显然第一次枚举确定出的范围的长度不会超过 $B$，所以第二个桶的大小只用开 $B$。    

空间复杂度 $O(\frac{w^2}{B}+B)$。（其中 $w$ 为值域）     
时间复杂度 $O(n^3)$，可以通过。        
我的代码里 $B$ 取了 $2^{20}$，跑得比较快。  

官方题解提到了将值域 $w$ 开到 $10^9$ 的设想试图卡掉这种做法。    
但是其实是卡不掉的，就是把上面的两次枚举改成三次枚举而已，其他基本相似。      


------------

**代码：**

```cpp
#include<bits/stdc++.h>
using namespace std;
const int Lim=1<<20;
typedef long long ll;
int t[1050000],n,k,x[888],y[888],K;
ll L,R;
inline ll Abs(ll x) {
	return x<0?-x:x;
}
int main() {
	cin>>n>>k;
	for(int i=1; i<=n; ++i)cin>>x[i]>>y[i];
	for(int i=1; i<=n; ++i)
		for(int j=i+1; j<=n; ++j) {
			ll c;
			for(int k=j+1; k<=n; ++k)
				c=Abs(1ll*(x[i]-x[j])*(y[i]-y[k])+1ll*(x[k]-x[i])*(y[i]-y[j])),t[c>>20]++;
		}
	for(int i=0,r=0; i<=1000000; ++i)
		if(r+t[i]>=k) {
			K=k-r,L=i*1ll<<20,R=(i+1)*1ll<<20;
			break;
		} else r+=t[i];
	memset(t,0,sizeof(t));
	for(int i=1; i<=n; ++i)
		for(int j=i+1; j<=n; ++j) {
			ll c;
			for(int k=j+1; k<=n; ++k) {
				c=Abs(1ll*(x[i]-x[j])*(y[i]-y[k])+1ll*(x[k]-x[i])*(y[i]-y[j]));
				if(c>=L&&c<R)t[c-L]++;
			}
		}
	for(int i=0,sm=0; i<Lim; ++i)
		if(sm+t[i]>=K)cout<<L+i<<'\n',exit(0);
		else sm+=t[i];
}
```
居然跑得比 $O(n^2\log^2 n)$ 快很多？（逃

另外，感觉这个做法和基数排序的思想有一点像？

---

## 作者：command_block (赞：4)

# 官方题解:高塔与晶石

[总题解Link](https://www.luogu.org/blog/command-block/post-solution-to-CmdOI2019)

------------

**一句话题意** : 给出$n$个点,求面积$k$小三角形。

(~~这是一道卡内存的SB题~~)

## subtask1

首先你要知道暴力枚举三个顶点,算出三角形面积(可以用叉积)。

可以使用堆来做,也可以全部存下来之后排序……

不过更高明的做法是存下来之后`nth_element`带走,复杂度$O(n^3)$。

```cpp
#include<algorithm>
#include<cstdio>
#define ll long long
#define MaxN 205
using namespace std;
struct Point
{
  int x,y;
  Point operator - (const Point &B) const
  {return (Point){x-B.x,y-B.y};}
  ll operator ^ (const Point &B) const
  {return (ll)x*B.y-(ll)y*B.x;}
}p[MaxN];
int n,k,tot;
ll sav[1333333];
void solve()
{
  for (int i=1;i<=n;i++)
    for (int j=i+1;j<=n;j++)
      for (int k=j+1;k<=n;k++)
        if ((sav[++tot]=(p[j]-p[i])^(p[k]-p[i]))<0)
          sav[tot]=-sav[tot];
  nth_element(sav+1,sav+k,sav+tot+1);
  printf("%lld",sav[k]);
}
int main()
{
  scanf("%d%d",&n,&k);
  for (int i=1;i<=n;i++)
  	scanf("%d%d",&p[i].x,&p[i].y);
  solve();
  return 0;
}
```

## subtask2

留给一些乱搞做法。

## subtask3

如果使用堆的话,复杂度将是$O(n^3logk)$,肯定是过不去的。

但是$O(n^3)$的叉积暴力自带一个$\dfrac{1}{6}$的小常数,我们可以考虑$O(n^3)$艹过去。

可是采用subtask1的暴力直接做的话,会被卡内存。

我们考虑分块`nth_element`,每加入$B$个元素`nth_element`一次,得到前$k$个,放进一个数组里。

最后在对那个保存数组`nth_element`一次就可以得到答案了。

空间复杂度$O(\dfrac{n^3k}{B}+B)$时间复杂度$O(n^3+\dfrac{n^3k}{B})$

取$B=\sqrt{n^3k}≈10^6$比较合适,于是总复杂度是空间$O(\sqrt{n^3k})$,时间$O(n^3+\sqrt{n^3k})$。

```cpp
#include<algorithm>
#include<cstdio>
#define ll long long
#define MaxN 850
using namespace std;
struct Point
{
  int x,y;
  Point operator - (const Point &B) const
  {return (Point){x-B.x,y-B.y};}
  ll operator ^ (const Point &B) const
  {return (ll)x*B.y-(ll)y*B.x;}
}p[MaxN];
int n,K,tot,tot2;
ll sav[1111111],sav2[2111111];
void solve()
{
  for (int i=1;i<=n;i++)
    for (int j=i+1;j<=n;j++)
      for (int k=j+1;k<=n;k++){
        if ((sav[++tot]=(p[j]-p[i])^(p[k]-p[i]))<0)
          sav[tot]=-sav[tot];
        if (tot>1000000){
          nth_element(sav+1,sav+K,sav+tot+1);
          for (int p=1;p<=K;p++)
            sav2[++tot2]=sav[p];
          tot=0;
        }
      }
  for (int p=1;p<=tot;p++)sav2[++tot2]=sav[p];
  nth_element(sav2+1,sav2+K,sav2+tot2+1);
  printf("%lld",sav2[K]);
}
int main()
{
  scanf("%d%d",&n,&K);
  for (int i=1;i<=n;i++)
  	scanf("%d%d",&p[i].x,&p[i].y);
  solve();
  return 0;
}
```

## subtask4

考虑二分答案,把问题转化成**统计面积小于等于给定值的三角形个数**。

如何check?

这个技巧叫维护叉积序。

首先,把任意两点连成向量都找出来,按照与x轴夹角排序。

对于每条向量,都把所有点以它为斜率基准进行叉积排序。

(设基准向量为$\vec{AB}$,点为$C$,即按照$\vec{AB}$与$\vec{AC}$的叉积值来排序)

具体来说:

![](https://cdn.luogu.org/upload/pic/75940.png)

这就是图上几个点根据有向线段叉积排序的结果。

显然,如果对于每条线段都排序一次,复杂度将会达到$O(n^3logn)$,比暴力还劣。

我们的基准向量是按照与x轴夹角排序的,每次只会转动一小点。

事实上,每次转动的时候,只有向量的两个端点的叉积序改变了,其余的都没变。

(注意,要**保持基准向量的起始点排在终止点的后面**)

如图,把上图的向量逆时针转动以后,新的叉积序:

![](https://cdn.luogu.org/upload/pic/75941.png)

那么我们可以一开始排序一次,然后`swap`那么$n^2$次就好了。

那么对于每条基准向量,我们从叉积值0开始向前后二分,统计个数就好了。

总复杂度$O(n^2log^2n)$,而且常数极大。

我们发现每个三角形会被统计到$6$次(3条边,2种方向),这里有些常数可卡。

统计叉积值的时候只往正方向二分,也就是只统计逆时针贡献的三角形,这样可以使常数除以2。

保留上一次check中的答案做下一次的边界,这样可以使常数再除以2。

```cpp
#include<algorithm>
#include<cstdio>
#include<cmath>
#define ll long long
#define MaxN 850
#define MaxS 666666
using namespace std;
struct Point {
  int x,y;
  Point operator - (const Point &B) const
  {return (Point){x-B.x,y-B.y};}
  ll operator ^ (const Point &B) const
  {return (ll)x*B.y-(ll)y*B.x;}
}p[MaxN]; int n,k;

struct Line {
  int f,t;
  Point a,c;
  double rt;
}v[MaxS]; int m;

bool cmp(const Line &A,const Line &B){ return A.rt<B.rt; }
Line bas;
bool cmp2(int A,int B)
{ return (bas.c^(p[A]-bas.a))<(bas.c^(p[B]-bas.a)); }

int tp[MaxN],a[MaxN],sava[MaxN];
int sl[MaxS],sr[MaxS],s[MaxS];
void pre()
{
  for (int i=1;i<=n;i++)tp[a[i]=sava[i]]=i;

  for (int i=1;i<=m;i++){

    if (tp[v[i].f]>tp[v[i].t]){
      swap(a[tp[v[i].f]],a[tp[v[i].t]]);
      swap(tp[v[i].f],tp[v[i].t]);
    }

    sl[i]=1;sr[i]=tp[v[i].f];

    swap(a[tp[v[i].f]],a[tp[v[i].t]]);
    swap(tp[v[i].f],tp[v[i].t]);
  }
}
bool check(ll lim)
{
  lim=-lim-1;
  int tot=0;
  for (int i=1;i<=n;i++)tp[a[i]=sava[i]]=i;

  for (int i=1;i<=m;i++){

    if (tp[v[i].f]>tp[v[i].t]){
      swap(a[tp[v[i].f]],a[tp[v[i].t]]);
      swap(tp[v[i].f],tp[v[i].t]);
    }
    
    int l=sl[i],r=sr[i],mid;
    while(l<r){
      mid=(l+r)>>1;
      if ((v[i].c^(p[a[mid]]-v[i].a))>lim)r=mid;
      else l=mid+1;
    }s[i]=r;
    tot+=tp[v[i].f]-r;
  
    swap(a[tp[v[i].f]],a[tp[v[i].t]]);
    swap(tp[v[i].f],tp[v[i].t]);
  }
  
  tot/=3;
  if (tot<k) for (int i=1;i<=m;i++)sr[i]=s[i];
  else for (int i=1;i<=m;i++)sl[i]=s[i];
  return tot>=k;
}
int main()
{
  scanf("%d%d",&n,&k);
  for (int i=1;i<=n;i++)
  	scanf("%d%d",&p[i].x,&p[i].y);
  for (int i=1;i<=n;i++)
    for (int j=1;j<=n;j++)if (i!=j)
      v[++m]=(Line){i,j,p[i],p[j]-p[i],
        -atan2((p[j]-p[i]).x,(p[j]-p[i]).y),
      };
  sort(v+1,v+m+1,cmp);bas=v[1];
  for (int i=1;i<=n;i++)sava[i]=i;
  sort(sava+1,sava+n+1,cmp2);
  pre();

  ll l=0,r=1000000000000ll,mid;
  while(l<r){
    mid=(l+r)>>1;
    if (check(mid))r=mid;
    else l=mid+1;
  }printf("%lld",r);
  return 0;
}
```

# 其他解法

坐等其他大佬来解释……

我留意到了一些神奇的$O(n^3)$解法,大概是开$10^6$个桶分段确定面积什么的。

如果把坐标范围开到$10^9$能不能卡掉呢?

---

## 作者：NTT__int128 (赞：3)

# P5571 [CmdOI2019] 高塔与晶石 题解
## Subtask $1$
直接 `nth_element`。
## Subtask $2,3$
每次只存最大的 $k$ 个三角形的面积。
## Subtask $4$
我们发现，每个三角形的面积不会超过 $10^{12}$。考虑分块。

按块长为 $L=10^6$ 分块，记录每一块的答案。确定答案在哪一个块中。再统计答案所在的块中的每种面积的个数，就可以求出答案了。

时间复杂度：$\Theta(n^3+L)$。

代码：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e6+5,L=1e6;
struct point{
	int x,y;
}p[805];
int area(point a,point b,point c){return abs(a.x*(b.y-c.y)+b.x*(c.y-a.y)+c.x*(a.y-b.y));}
int n,k,c[N];
signed main(){
	cin>>n>>k;
	for(int i=1;i<=n;i++)cin>>p[i].x>>p[i].y;
	for(int i=3;i<=n;i++)
		for(int j=2;j<i;j++)
			for(int k=1;k<j;k++){
				int t=area(p[i],p[j],p[k]);
				c[t/L]++;
			}
	int g=0,cnt=0;
	while(1){
		cnt+=c[g];
		if(cnt>=k)break;
		g++;
	}
	cnt-=c[g];
	memset(c,0,sizeof c);
	for(int i=3;i<=n;i++)
		for(int j=2;j<i;j++)
			for(int k=1;k<j;k++){
				int t=area(p[i],p[j],p[k]);
				if(t>=g*L&&t<g*L+L)c[t-g*L]++;
			}
	int f=0,sum=0;
	while(1){
		sum+=c[f];
		if(sum+cnt>=k)break;
		f++;
	}
	cout<<g*L+f;
	return 0;
}
```

---

## 作者：刘辰雨 (赞：1)

# P5571

### 修改日志：
	
    一审：未能通过审核。原因是 审核管理员：_RSY_，标点符号使用不当：数学公式外应使用中文（全角）标点； 。
    
    已修改Latex后标点符号为中文（全角）。
----

### 注：本题解思想系 分块+计数排序

-----

### 分析：

1. 注意到时间限制出现 "2s" 字样，可以处理 $ 10^{17} $ 左右数据，那么考虑 $ n^3 $ 枚举三角形面积。

2. 注意到 $ n \le 800 $， 那么 $ n^3 \le 5.12 \times 10^8 $ ，**似乎**可以存下，但是很快注意到内存限制 "64MB"，那么毫无疑问是存不下的。（厚礼蟹······）

3. 关于空间似乎没什么思路，来想想排序。 $ n^3 $ 的枚举会很大的消耗时间，所以排序选用非常快的算法，观察面积大小， $ 1 \le x_i,y_i \le 10^6 $ ，所以 $ 1 \le x_i \times y_i \le 10^{12} $ ，似乎计数排序不现实，但是！我们可以**分块储存**！将每个区间的值作为一个桶保存，先进行区间排序；再通过枚举确认第 $ K $ 小的值的范围， $ n^3 $ 遍历第二遍，将符合区间的值加入另一个"货真价实"的桶，实现区间的逐步缩小。   

4. 空间的问题迎刃而解。储存在桶数组中即可，需要时反复计算。

### 详见代码：

Ps：本题求面积使用向量点积，如没有接触此类方法，请移步 [P1183](https://www.luogu.com.cn/problem/P1183) .


```cpp
#include <iostream>
#include <cstdio>
#include <cmath>

using namespace std;

const long long B = (1LL<<20);//分块的大小
long long Tong[1000006];//区间排序桶
long long T[(1<<21)];//"货真价实"桶

long long Num,Adv;
long long NumInP,AdvInP;//"InP" == "In The Part".

long long N,K;
long long X[880],Y[880];

long long VF;
long long L,R;

long long GetV(long long i,long long j,long long k)
{
	return abs((X[j]-X[i])*(Y[k]-Y[i])-(Y[j]-Y[i])*(X[k]-X[i]));
}
//向量点积求面积

int main()
{
	scanf("%lld%lld",&N,&K);
	for(register long long i = 1 ; i<= N ; i++)
	{
		scanf("%lld%lld",&X[i],&Y[i]);
	}
	for(register long long i = 1 ; i<= N ; i++)
	{
		for(register long long j = i+1 ; j<= N ; j++)
		{
			for(register long long k = j+1 ; k<= N ; k++)
			{
				Tong[GetV(i,j,k)/B]++;
           //计算面积并加入区间桶
			}
		}
	}
	while(Adv <= 1000000)
	{
		if(Num + Tong[Adv] >= K)
		{
			K -= Num;
			L = Adv*B;
			R = (Adv+1)*B;
			break;	
		}
		else
			Num += Tong[Adv++]; 
	}
	for(register long long i = 1 ; i<= N ; i++)
	{
		for(register long long j = i+1 ; j<= N ; j++)
		{
			for(register long long k = j+1 ; k<= N ; k++)
			{
				VF = GetV(i,j,k);
				if(L <= VF && VF < R)
					++T[VF-L]; 
           //二次遍历，加入"货真价实"桶
			}
		}
	}
	while(AdvInP < B)
	{
		if(NumInP + T[AdvInP] >= K)
		{
			break;
		}
		else
			NumInP += T[AdvInP++];
	}
	printf("%lld\n",AdvInP+L);//输出
	return 0;
}
```

[AC 记录 ](https://www.luogu.com.cn/record/95275262)


---

## 作者：Trafford1894 (赞：0)

### 关键词：叉积求三角形面积，优化空间

做这道题应当知道如何使用叉积求三角形面积。具体地，设 $\vec{a}=(x_1,y_1),\vec{b}=(x_2,y_2),$ 有 $\vec{a}\times \vec{b} = x_1\times y_2-x_2\times y_1$。而根据叉积的几何意义有叉积是两个向量张成平面四边形的有向面积。求三角形面积时先除二再求绝对值即可。

注意到 $\dbinom{n}{3}$ 约等于 $8.5\times10^7$，时限又有 2s，所以枚举三个点并不是瓶颈。但是 $k$ 大值怎么求？如果把所有的面积全存下来再排序或者 nth_element，空间是 $O(n^3)$ 的，会爆。

这时我们面对的问题和值域过大的桶排序类似，而后者可以用基数排序解决。考虑借鉴基数排序的思想，记 $x_i\times y_i$ 的最大值为 $w$，本题中 $w=10^{12}$。设我们要将 $w$ 划分为 $p$ 进制，空间复杂度即是 $O(p \log_p w)$ 的，时间复杂度是 $O(n^3 \log_p w)$。平衡一下取 $p=\sqrt w=10^6$ 是两方面都可以接受的。

具体的实现过程就是先开一个 $10^6$ 的桶，$O(n^3)$ 枚举一遍，记计算出来的面积为 $s$，统计所有 $\dfrac{s}{10^6}$ 的个数。由此，可以先确定 $k$ 的一段范围，这个区间是小于 $10^6$ 的；再枚举一遍，将在范围内的面积的出现次数用另一个桶统计出来，暴力计算即可。

记得开 long long！

[AC 记录。](https://www.luogu.com.cn/record/190859398)

---


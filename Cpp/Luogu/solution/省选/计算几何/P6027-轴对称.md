# 轴对称

## 题目背景

小 W 学习了轴对称变换。

## 题目描述

小 W 觉得轴对称变换实在太好玩了，于是在平面上随机点了 $n$ 个点 $A_1,A_2,\cdots,A_n$，然后进行了一系列轴对称变换，得到了 $B_1,B_2,\cdots,B_n$ 这 $n$ 个点，其中 $A_1$ 得到 $B_1$，以此类推。

可是他突然忘记自己是怎么变换到的了，所以他请你帮他找到一组步数尽量少的合法的变换。

## 说明/提示

## 样例解释
![](https://cdn.luogu.com.cn/upload/image_hosting/8msdygxi.png)
## 提示
对于直线 $Ax+By+C=0$，如果 $B$ 非零，那么它就是一次函数 $y=-\dfrac ABx-\dfrac CB$ 的图像；否则，它表示一条垂直于 $x$ 轴的直线 $x=-\dfrac CA$。

本题带有 $\text{SPJ}$。**因为某种原因，本题不提供** $\text{SPJ}$ **给选手。**

对于每个测试点，如果你的 $k$ 正确，则获得 $30\%$ 的分数；

接下来，我们将对 $A_1,A_2,\cdots,A_n$ 分别进行你给的 $k$ 次轴对称变换，记 $A_i$ 得到的点为 $C_i$。如果对于所有的 $i$，$B_i$ 与 $C_i$ 的 $x,y$ 坐标之差的绝对值都不超过 $10^{-2}$，则你获得 $100\%$ 的分数。

如果你只想输出 $k$，也请在后面随意输出一些值，防止 $\text{UKE}$。
## 数据范围

| 测试点编号 | $n=$ | 构造数据时翻折的次数 |
| ---------- | ---- | -------------------- |
| 1,2        | $1$  | $\le1$               |
| 3,4        | $2$  | $\le10$              |
| 5,6        | $5$  | $\le10^3$            |
| 7,8,9,10   | $10$ | $\le10^5$            |

对于所有数据，$1\le n\le10$，$|x|,|y|\le 10^5$。

所有数据点已经经过 $\text{SPJ}$ 验证无误。 

请保证你的输出中的所有 $A,B,C$ 满足 $|A|,|B|,|C|\le 10^5$。

## 样例 #1

### 输入

```
2
1.000000 1.000000
2.000000 2.000000
4.000000 4.000000
3.000000 3.000000
```

### 输出

```
1
1.000000 1.000000 -5.000000```

# 题解

## 作者：WYXkk (赞：8)

# 题解 轴对称

~~欢迎来到手算几何的世界~~

前置技能：基本几何变换（平移旋转轴对称）知识，相似三角形，推导手算几何的能力

引理 I：两次轴对称相当于一次平移或者旋转；反过来一次旋转或平移可以分解为两次平移或者旋转。

结合下图自行理解，严谨证明就略了~~其实我不会~~。

![](https://cdn.luogu.com.cn/upload/image_hosting/tb9v6r4o.png)

引理 II：一次旋转再一次平移相当于一次平移再一次旋转。

请再次结合下图理解，注意相似，严谨证明再次略去~~其实这个我会~~。

![](https://cdn.luogu.com.cn/upload/image_hosting/xkri0n53.png)

引理 III：本题的答案不超过 $3$。

证明：如果两个图形反向，那就把其中一个随便往哪里翻一下；然后将两个图形旋转至相同角度；最后平移至重合。后两次可以合并为一次旋转或平移，共计 $1+2=3$ 次轴对称就可以解决。

引理 IV：线段 $(x_1,y_1)$ $(x_2,y_2)$ 的垂直平分线是
$$2(x_1-x_2)x+2(y_1-y_2)y+(x_2^2+y_2^2-x_1^2-y_1^2)=0$$
点 $(x,y)$ 关于直线 $Ax+By+C=0$ 对称的点的坐标为
$$(\frac{(B^2-A^2)x-2ABy-2AC}{A^2+B^2},\frac{(A^2-B^2)y-2ABx-2BC}{A^2+B^2})$$
证明从略，手推即可。

于是，我们就有了下面的算法：

- 验证两个点集是否重合，如重合输出答案。
- 将任意一个不在对应点上的点翻折到对应点上。
- 重复上述过程。

可以证明这是对的。

$\texttt{code:}$

```cpp
#include<cstdio>
#include<iostream>
#include<fstream>
#include<cmath>
#include<cstring>
#include<algorithm>
using namespace std;
#define Set(a) memset(a,0,sizeof(a))
#define F(i,a,b) for(register int i=a,i##end=b;i<=i##end;++i)
#define UF(i,a,b) for(register int i=a,i##end=b;i>=i##end;--i)
#define openf(a) freopen(#a".in","r",stdin);freopen(#a".out","w",stdout)
#define re register
#define ri re int
#define il inline
typedef long long ll;
typedef unsigned long long ull;
template<typename T> inline T rd(T& x)
{
	T f=1;x=0;char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
	for(; isdigit(c);c=getchar()) x=(x<<3)+(x<<1)+(T)(c-'0');
	x*=f;
	return x;
}
ll rd(){ll x;rd(x);return x;}
inline int max(int a,int b){return a>b?a:b;}
inline int min(int a,int b){return a<b?a:b;}
const int inf=1<<30;

typedef double db;
struct Point{db x,y;Point(db x=0,db y=0):x(x),y(y){}};//(x,y)
struct Line{db A,B,C;Line(db a=0,db b=0,db c=0):A(a),B(b),C(c){}};//Ax+By+C=0
Point dc(Point A,Line l)
{
	db x=l.A*l.A+l.B*l.B,y=l.A*l.A-l.B*l.B,z=2*l.A*l.B;
	return Point((-z*A.y-y*A.x-2*l.A*l.C)/x,(-z*A.x+y*A.y-2*l.B*l.C)/x);
}
Line small(Line l){while(fabs(l.A)>100000||fabs(l.B)>100000||fabs(l.C)>100000) l.A/=2,l.B/=2,l.C/=2;return l;}
Line mid(Point A,Point B){return small(Line(A.x-B.x,A.y-B.y,(B.x*B.x+B.y*B.y-A.x*A.x-A.y*A.y)/2));}
db eps=1e-2;bool eq(db a,db b){return fabs(a-b)<eps;}
bool eq(Point x,Point y){return eq(x.x,y.x)&&eq(x.y,y.y);}
Point A[20],B[20];Line ans[5];int num=0;int n;
void put(Line x){printf("%.6lf %.6lf %.6lf\n",x.A,x.B,x.C);}
void f(Line x){F(i,1,n) A[i]=dc(A[i],x);ans[++num]=x;}
void work()
{
    bool flg=true;F(i,1,n) flg=flg&&eq(A[i],B[i]);
    if(flg){printf("%d\n",num);F(i,1,num) put(ans[i]);exit(0);}
	for(int i=1,j=n;i<j;++i) while(eq(A[i],B[i])&&i<j){swap(A[i],A[j]);swap(B[i],B[j]);--j;}
	f(mid(A[1],B[1]));
}
int main()
{
	rd(n);
	F(i,1,n) scanf("%lf%lf",&A[i].x,&A[i].y);
	F(i,1,n) scanf("%lf%lf",&B[i].x,&B[i].y);
	while(true) work();
	return 0;
}
```



---


# [THUPC 2022 初赛] 喵喵花園

## 题目描述

喵喵是一只非常富有的猫咪，他在海淀区拥有一个大花园。

这个大花园是由一些旧栅栏为边界所形成的 $N$-gon（即具有 $N$ 边的多边形）。

由于圣诞节快到了，喵喵想用 $K$ 棵圣诞树来装饰一下花园。 同时，喵喵坚信找到一些好的位置来种树会给他带来好运。

作为一只好猫咪，他决定寻找最佳位置如下：

- 所有的树都应该在花园的边界上。
- 这些 $K$ 树应该平均划分花园的周长。
- 由树木形成的新凸面$K$-gon 的面积应尽可能小。

虽然喵喵比你有钱，但他没有你那么聪明。 因此，他给了你一些钱，让你帮他找出凸$K$-gon 的最小面积。

## 说明/提示

【数据范围】

- $3 \le N, K \le 1000$；
- $-10^5 \le x_i, y_i \le 10^5$。

## 样例 #1

### 输入

```
5 4
0 0
1 0
2 1
2 2
0 2```

### 输出

```
1.9892766953```

## 样例 #2

### 输入

```
3 3
0 0
1 0
0 1```

### 输出

```
0.1226170434```

# 题解

## 作者：tiger2005 (赞：10)

是我喜欢的计算几何！赛场上一边吃午饭一边写完的（

首先我们知道这 $K$ 棵圣诞树均匀分割了整个凸多边形的边长，那么相邻两棵圣诞树在凸多边形边上的距离就是一定的（设为 $dis$）。我们选择一棵树观察，将其向顺时针方向挪动 $dis$，发现对于每一棵树，其后面一棵树来到了它先前所在的位置，整体也就回到了挪动前的状态。

我们定义 **跳边** 代表树挪到一条边的端点，然后前往下一条边的瞬间，那么由于所有树移动的距离恰好覆盖整个凸多边形的周长，发生的 **跳边** 次数和凸多边形拐角数目一样，也就是 $N$。

考虑模拟整个过程，钦定一棵树，一开始在凸多边形的某一个端点，然后向右挪 $dis$。期间我们可以求出其它所有点的位置，由此推出所有 **跳边** 的时间点。由于两次 **跳边** 之间，每个点都在一个线段之间移动，所以我们尝试用函数表示出这段时间的凸多边形面积，并求出最小值。

我们定义这 $K$ 棵树所在位置为 $t_1, t_2, ..., t_K$，这 $N$ 条边的长度为 $s_1, s_2, ..., s_N$，其中 $s_1$ 代表的边连接 $p_1$ 和 $p_2$，依次类推，同时默认 $p_{N+1}=p_1$。

在这个时间段的开始，每个点在凸多边形的周长上和 $p_1$ 的距离（$p_1$ 顺时针到达该点的距离）是确定的。我们可以按顺序枚举每个点，然后使用指针维护当前点所在的边。

假设第 $i$ 个点落在了第 $j$ 条边上，和 $p_j$ 的距离为 $d$。那么我们考虑将这个点的坐标借助时间表示出来。我们不妨假设时间为 $x$，那么前面的距离将会扩大到 $d+x$，根据向量的知识，我们可以求出 $\overrightarrow{p_jp_{j+1}}$ 的单位向量于距离相加，加上初始点 $p_j$，即：

$$t_i = p_j + \dfrac{\overrightarrow{p_jp_{j+1}}}{|\overrightarrow{p_jp_{j+1}}|} \times (d + x)$$

我们就成功使用时间表示了每个点的位置。

然后我们就可以使用叉积算出凸多边形的面积（具体而言，选择一个点向其余所有非相邻点连边，将凸多边形拆成若干个三角形，而向量叉积的结果的绝对值恰为其围成三角形面积的两倍），最终得到一个二次函数。那么我们只需要考虑这个时间段内二次函数的最小值就能解决问题。

最后把所有时间段的答案统计起来就完成了，复杂度为 $O(NK + N^2)$。如果在求出 **跳边** 时间点的同时存储对应点，就可以省去重新获取所有点所在边的位置的时间复杂度，使总复杂度降为 $O(NK)$。

代码中 `KBs` 维护了 $kx + b$。

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <cmath>
#include <vector>

using namespace std;
struct KBs{
	double k, b;
	KBs(double k=0, double b=0)
		:k(k), b(b){}
	KBs operator + (const KBs x) const{
		return KBs(k + x.k, b + x.b);
	}
	KBs operator - (const KBs x) const{
		return KBs(k - x.k, b - x.b);
	}
	KBs operator * (const double p) const{
		return KBs(k * p, b * p);
	}
};
struct Point{
	KBs x, y;
	Point(KBs x = 0, KBs y = 0)
		:x(x), y(y){}
	Point operator + (const Point& p)const{
		return Point(x + p.x, y + p.y);
	}
	Point operator - (const Point& p)const{
		return Point(x - p.x, y - p.y);
	}
	Point operator * (const double k)const{
		return Point(x * k, y * k);
	}
	Point operator * (const KBs k)const{
		return Point(k * x.b, k * y.b);
	}
};
double sqr(double x){
	return x * x;
}
struct Segment{
	Point st, ed;
	Segment(Point st = Point(KBs(), KBs()), Point ed = Point(KBs(), KBs()))
		:st(st), ed(ed){}
	double len(){
		return sqrt(sqr(st.x.b - ed.x.b) + sqr(st.y.b - ed.y.b));
	}
	Point at(KBs k){
		return st + (ed - st) * k;
	}
};
struct Function{
	double a, b, c;
	Function(double a=0, double b=0, double c=0)
		:a(a), b(b), c(c){}
	Function operator + (const Function& f)const{
		return Function(a + f.a, b + f.b, c + f.c);
	}
	Function operator - (const Function& f)const{
		return Function(a - f.a, b - f.b, c - f.c);
	}
	double at(double x){
		return a * x * x + b * x + c;
	}
	double minn(double l, double r){
		if(a == 0)
			return min(at(l), at(r));
		// return 0.0;
		double mn = -1.0 * b / (2 * a);
		if(l <= mn && mn <= r)
			return min({at(l), at(r), at(mn)});
		return min(at(l), at(r));
	}
};
Point ps[1010];
Segment segs[1010];
int N, K;
int curr[1010];
double lens[1010];
double lenfnt[1010];
vector<pair<double, int> > vec;

Function KBsCross(KBs x, KBs y){
	return Function(x.k * y.k, x.k * y.b + x.b * y.k, x.b * y.b);
}
Function pointCross(Point x, Point y){
	return KBsCross(x.x, y.y) - KBsCross(x.y, y.x);
}

int main(){
	scanf("%d%d", &N, &K);
	for(int i=N; i>=1; i--)
		scanf("%lf %lf", &ps[i].x.b, &ps[i].y.b);
	ps[N+1] = ps[1];
	double C = 0;
	for(int i=1; i<=N; i++)
		segs[i] = Segment(ps[i], ps[i+1]), C += lens[i] = segs[i].len();
	segs[N+1] = segs[1];
	C /= K;
	double las = 0;
	int m = 1;
	curr[1] = 0;
	for(int i=1; i<=N; i++){
		las += lens[i];
		lenfnt[i] = lenfnt[i-1] + lens[i];
		while(las >= C && m != K)
			las -= C, curr[++m] = i;
		if(i == N)
			m = 1;
		else
			vec.emplace_back(las, m);
	}
	lens[N+1] = lens[1];
	vec.emplace_back(0, 1);
	vec.emplace_back(C, 1);
	sort(vec.begin(), vec.end());
	double ans = 1e18;
	for(int i=0; i<(int)vec.size()-1; i++){
		pair<double, int> pr = vec[i];
		curr[pr.second] ++;
		double L = pr.first, R = vec[i+1].first;
		vector<Point> plist(K + 2);
		for(int j=1; j<=K; j++){
			int id = curr[j];
			double y = (j-1) * C - lenfnt[id-1];
			KBs num(1.0 / lens[id], y / lens[id]);
			plist[j] = segs[id].at(num);
		}
		Function f;
		for(int i=1; i<=K; i++){
			int j = i % K + 1;
			f = f + pointCross(plist[i], plist[j]);
		}
		if(f.at(L) < 0) // 建议加上这个检查，防止凸多边形叉出来面积是个负数
			f.a *= -1, f.b *= -1, f.c *= -1;
		ans = min(ans, f.minn(L, R));
	}
	printf("%.12f", ans / 2);
	return 0;
}
```

---

## 作者：donghanwen1225 (赞：5)

考虑到本题的难度，这篇题解会忽略：如何求凸 $k$ 边形面积；已知一个出发点，如何找出全部 $k$ 个点这两部分。如果您不会这两个部分，您可以先学习一下基础的计算几何知识。

------------

首先容易发现，只要我们确定了任意一个点，就可以从这个点出发得到所需的 $k$ 个点。

令 $x_{n+1}=x_1,y_{n+1}=y_1,C=\sum\limits_{i=2}^{n+1}\sqrt{\left(x_i-x_{i-1}\right)^2+\left(y_i-y_{i-1}\right)^2}$ (即题目所给的 $n$ 边形的周长)。

那么我们只需找出从第一个点出发、总长度为 $\dfrac{C}{k}$ 的一段边上的一个最优点，根据这个点找到全部 $k$ 个点并算出其面积，即可求出答案。

问题转化为如何求出这个最优点。

接下来我们引出一个关键结论：离最优点越近，则面积越大；否则面积就越小。

先来讨论由这个结论如何得到正解。既然离最优点越近则越优，那么只需要三分当前点到第一个点的距离即可。

接下来证明这个结论。

考虑将最优点向顺时针方向移动一个 $dx$ 的距离。那么，原先的 $k$ 个点均会向顺时针方向移动 $dx$。

我们知道，中间围成的多边形面积就等于原先的 $n$ 边形面积，减去这 $k$ 条线段与原来的边围成的所有多边形的面积之和。

那么当每个点都顺时针移动了一个 $dx$ 后，对于每个多边形，先假设其边数不变，那么如下图所示：![](https://cdn.luogu.com.cn/upload/image_hosting/7cbie9hf.png)

蓝色标出的部分是这次 $dx$ 的移动所产生的贡献。

可以发现，当 $O$ 点的位置越来越处在黑线 / 红线的中间时，两边的面积就越接近。

显而易见，随着 $dx$ 的大小单调变化，$O$ 点的变化一定是单向的，也就是不会调转移动方向。因此，对每一个这样的多边形，其面积变化和 $dx$ 的大小是一个**凸函数**。

而我们知道，多个凸函数之和仍然是凸函数。所以，$dx$ 的大小和 $k$ 条边与原先的边围成的多边形面积之和构成一个凸函数关系。于是就证明了其单峰性。

有了这个结论，用上面已经提到的方法，即可解决此题。时间复杂度为 $O(n\log V)$，$V$ 为三分时的值域。

题外话 $1$：由此也可见，原题的数据范围是相当小的。

题外话 $2$：这题的精度要求极低。实际上，三分精度调到 $50$ 都是可以过的。~~一开始我还怕被卡精度而开到了 $10^{-9}$。~~

code：

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
using namespace std;
int n,k,x[1005],y[1005];
double dis,ans=1e15,d[1001],t1[1001],t2[1001];
double getd(double x1,double y1,double x2,double y2){return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));}
double crs(double x1,double y1,double x2,double y2){return x1*y2-x2*y1;}
double calS()
{
	double res=0;
	for(int i=1;i<=k;i++) res+=crs(t1[i],t2[i],t1[i%k+1],t2[i%k+1]);
	return 0.5*res;
}
void getpt(double &ex,double &ey,double x1,double y1,double x2,double y2,double len)
{
	double td=getd(x1,y1,x2,y2);
	ex=x1+(x2-x1)/td*len;
	ey=y1+(y2-y1)/td*len;
}
double cal(int l,double len)
{
	int cur=l%n+1;
	getpt(t1[1],t2[1],x[l],y[l],x[l+1],y[l+1],len);
	for(int i=2;i<=k;i++)
	{
		double cx=t1[i-1],cy=t2[i-1],resd=dis;
		while(1)
		{
			double tl=getd(cx,cy,x[cur],y[cur]);
			if(tl<resd)
			{
				cx=x[cur],cy=y[cur];
				resd-=tl;cur=cur%n+1;
			}
			else{getpt(t1[i],t2[i],cx,cy,x[cur],y[cur],resd);break;}
		}
	}
	return calS();
}
int main()
{
	scanf("%d%d",&n,&k);
	for(int i=1;i<=n;i++) scanf("%d%d",&x[i],&y[i]);x[n+1]=x[1],y[n+1]=y[1];
	for(int i=1;i<=n;i++) d[i]=getd(x[i],y[i],x[i+1],y[i+1]),dis+=d[i];dis/=k;
	int en=0;double tmp=0;while(tmp<dis) tmp+=d[++en];
	for(int i=1;i<=en;i++)
	{
		double l=0,r=d[i];
		while(r-l>1e-9)
		{
			double mid1=l+(r-l)/3.0,mid2=r-(r-l)/3.0;
			double res1=cal(i,mid1),res2=cal(i,mid2);
			ans=min(ans,min(res1,res2));
			if(res1<res2) r=mid2;
			else l=mid1;
		}
	}
	printf("%.10f",ans);
	return 0;
}
```

---

## 作者：ADNAP (赞：1)

### 计算树与树之间的距离
因为树是平均划分边界的，所以两棵树之间的边界长度应该是 $\frac{C}{n}$，其中 $C$ 表示边界的总长度，计算边界长度过程用 $dist_i$ 来表示第 $i$ 个顶点到第 $i+1$ 个顶点之间的边界长，用两点间距离公式即可，为了后面方便计算，会把 $dist$ 的长度复制到 $2n+1$，同时也要复制记录顶点的数组，后面计算需要。
### 模拟退火
考察其中一个树的位置，则其他树都会确定下来。如果这棵树的位置稍微移动一点点，最终凸多边形的面积几乎一样，说明该问题的结果具有连续性，考虑使用模拟退火。

我们只需随机第一棵树的位置，事实上这棵树可以是边界上的任何一个位置。

考虑到第一棵树的位置只能在边界上跳动，所以跳动的边界长至多为边界的周长 $C$，初始温度为 $C$。

因为题目的精度要求较高，所以终止温度尽可能小，而衰减系数尽可能接近 $1$，这里本人分别调为 $1^{-10}$ 和 $0.999$ 就直接过掉了。

每一次随机取一个距离，当然也要小于等于 $C$ 啦，该距离表示原来的点与新点之间的边界长度，并且新点由原来点逆时针沿边界移动随机出来的距离长得到。

### 计算凸多边的面积
这里就要依靠一些数学知识了。
用到的是计算凸 $n$ 边形的面积公式，**鞋带原理**。

公式如下$:$

计 $n$ 个已经按逆时针排好顺序的点分别为 $(x_1,y_1),(x_2,y_2)......(x_n,y_n)$

$$S=\frac{1}{2}((x_1y_2+x_2y_3+...+x_{n-1}y_n+y_nx_1)-(y_1x_2+y_2x_3+......+y_{n-1}x_n+y_nx_1))$$

因为该公式计算的是有向面积，所以前面在记录点的过程中要按逆时针顺序。

### Code

```
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
#define PDD pair<double,double>
#define x first
#define y second
const ll N=1e5+1e4,M=1e3+1e2;
ll n,k;
double ans=1e12;
//记录答案，凸多边形的面积
PDD a[N];
double C;
//记录总周长
double dist[N];
//在i<n时表示顶点i到顶点i+1的距离，dist[n]表示顶点n到顶点1的距离
double Rand(double l,double r)
{
    return (double)rand()/RAND_MAX*(r-l)+l;
}//该函数是随机一个从l到r左闭右开的浮点数
PDD point[M];
double calc(PDD p,ll wher,double ptl)//计算以点p为起点，点p在第wher个顶点和第wher+1个顶点间的边界上,ptl表示点p到顶点wher的距离
{
    double dis=C/(double)k;
    //每两棵树之间的距离
    point[1]=p;
    for(ll i=2;i<=k;i++)
    {
        ptl+=dis;
        while(ptl>dist[wher])ptl-=dist[wher],wher++;  
        point[i]={ptl/dist[wher]*(a[wher+1].x-a[wher].x)+a[wher].x,ptl/dist[wher]*(a[wher+1].y-a[wher].y)+a[wher].y};
        //计算每颗树所在位置
    }
    double res=0;
    for(ll i=1;i<k;i++)res+=point[i].x*point[i+1].y;
    res+=point[k].x*point[1].y;
    for(ll i=1;i<k;i++)res-=point[i].y*point[i+1].x;
    res-=point[k].y*point[1].x;
    res*=0.5;
    //鞋带原理
    ans=min(ans,res);
    return res;
}
void simulate_anneal()
{
    
    double ptl=Rand(0,(double)C/(double)k);
    //随机一个初始点
    ll q=1;
    while(ptl>dist[q])ptl-=dist[q],q++;
    PDD pt={ptl/dist[q]*(a[q+1].x-a[q].x)+a[q].x,ptl/dist[q]*(a[q+1].y-a[q].y)+a[q].y};
    for(double t=C;t>1e-10;t*=0.999)
    {
        ll xx=calc(pt,q,ptl);
        //旧点确定的面积
        double ptll=ptl;
        ptll+=Rand(0,t);
        if(ptll>C)ptll-=C;
        ll qq=1;
        while(ptll>dist[qq])ptll-=dist[qq],qq++;
        PDD np={ptll/dist[qq]*(a[qq+1].x-a[qq].x)+a[qq].x,ptll/dist[qq]*(a[qq+1].y-a[qq].y)+a[qq].y};
        ll yy=calc(np,qq,ptll);
        //新点确定的面积
        double dt=yy-xx;
        if(exp(-dt/t)>Rand(0,1))pt=np,q=qq,ptl=ptll;
        q%=n;
        if(q==0)q=n;
        //确保q落在1到n，否则会超出dist的范围，即2n+1
    }
}
signed main()
{
    cin>>n>>k;
    for(ll i=1;i<=n;i++)
        cin>>a[i].x>>a[i].y;
    for(ll i=1;i<n;i++)
        dist[i]+=sqrt((a[i].x-a[i+1].x)*(a[i].x-a[i+1].x)+(a[i].y-a[i+1].y)*(a[i].y-a[i+1].y)),C+=dist[i];
    dist[n]+=sqrt((a[n].x-a[1].x)*(a[n].x-a[1].x)+(a[n].y-a[1].y)*(a[n].y-a[1].y)),C+=dist[n];
    //计算dist和总周长
    for(ll i=n+1;i<=2*n+1;i++)a[i]=a[i-n],dist[i]=dist[i-n];
    //复制dist
    while((double)clock()/CLOCKS_PER_SEC<0.8)simulate_anneal();
    //这里采用卡时的做法
    printf("%.8lf",ans);
}
//鞋带原理
//模拟退火
```

---


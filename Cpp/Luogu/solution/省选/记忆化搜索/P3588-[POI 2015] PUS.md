# [POI 2015] PUS

## 题目描述

给定一个长度为 $n$ 的正整数序列 $a$，每个数都在 $1$ 到 $10^9$ 范围内，告诉你其中 $s$ 个数，并给出 $m$ 条信息，每条信息包含三个数 $l,r,k$ 以及接下来 $k$ 个正整数，表示 $a_l, a_{l+1}, \ldots, a_{r-1}, a_r$ 里这 $k$ 个数中的任意一个都比任意一个剩下的 $r-l+1-k$ 个数大（严格大于，即没有等号）。

请任意构造出一组满足条件的方案，或者判断无解。

## 说明/提示

原题名称：Pustynia。

本题另外提供两组额外样例，可以在附件中下载。

## 样例 #1

### 输入

```
5 2 2
2 7
5 3
1 4 2 2 3
4 5 1 4```

### 输出

```
TAK
6 7 1000000000 6 3```

## 样例 #2

### 输入

```
3 2 1
2 3
3 5
1 3 1 2
```

### 输出

```
NIE
```

## 样例 #3

### 输入

```
2 1 1
1 1000000000
1 2 1 2```

### 输出

```
NIE
```

# 题解

## 作者：BJpers2 (赞：26)

## 我们在做题之前，先要知道这是一道图论题

题意描述有些绕，我在这里再阐述一遍：

- 给出一个部分未知的数列的**长**，以及数列已知的部分
- 再给出一些区间。对于每一个区间，在它的内部钦定一些位置，并要求这些位置上的数最后的值，都严格大于区间内其他**未钦定**的位置上的数。
- 要求给出任意一种可行的满足条件的数列。

大于关系可以看做是一条边，由较大的数指向较小的数。对于每一个询问，我们考虑让这k个位置上的数与区间内其他的位置两两连有向边。这样一来，问题就转化到图上了。

首先，图上若有环则一定无解，因为它意味着$x>x$。

那么问题变为DAG上问题，只要我们从入读为0的位置开始DP即可。贪心的想，最大的数越大，留给下面的空间就越大(注意数列中的数大于0！)，所以每个数的可能值全部设置为1e9。DP时假如遇到了已经确定的数，却发现它撑死了也打不到他预设的值（否则与其他单调关系矛盾），那么问题无解。

最后若有解，输出答案即可。

好完美啊，在你看到$\sum k\leq 300000$之前还以为是提高组水题。

假如按之前说的那样建图，一次操作就要加入$k(r-l+1-k)$条边，最坏情况下加入的边数在$N^3$级别，空间直接爆炸。

也许你会说，我们可以采用“电话交换机”的建图思想，不再两两连边
而是新拉出一个**超级节点**，然后只需要k个点向它连边，它向区间内其余点连边即可，只要$k+(r-l+1-k)=r-l+1$条边即可

然而这还是不行。因为如果每个操作区间都是上十万的大区间，而k每次只有1，最多还是要连$N\sum k$条边,仍然爆炸。

注意到，每次我们的空间浪费在，有大量位置连续的点，**超级节点**却向它们一一连了边。发挥想象力，有什么东西能提高区间操作的效率呢？

**线段树！！！**

没错，我们把数列建成一棵线段树，然后对于每个操作区间，它会被k个点割成最多k+1个子区间，对于每个区间，可以化成线段树上的最多$log(n)$个已知区间，对于超级节点连出的边，一次操作要加$klog(n)$条，算上连向超级节点的，总共是$k+klog(n)$。于是总共的边数在$(\sum k)log(n)$级别，完全可以接受。

这样连边以后，要注意线段树自身的边只是形式，要赋权为0。

之后按照之前所说的，按拓扑序DP就行了。

```cpp
#include<iostream>
#include<cstdio>
#include<queue>
#define lson ls[u],l,md
#define rson rs[u],md+1,r 
#define FOR(i,a,b) for(int i=a;i<=b;i++)
#define REP(u) for(int i=hd[u],v=e[i].v,w=e[i].w;i;i=e[i].n,v=e[i].v,w=e[i].w) 
using namespace std;
const int N=100100,TO=600600,M=7007000,INF=1000000000;
struct edge{int n,v,w;}e[M];
int n,s,m,p,v,u,x,k,l,r,pr,cnt,fl,ok,id[N],ins[TO];
int hd[TO],vis[TO],in[TO],f[TO],ls[TO],rs[TO],o[TO];
void add(int u,int v,int w){e[++fl]=(edge){hd[u],v,w};hd[u]=fl;in[v]++;}
queue<int>q; 
int read(){
    char ch=getchar();int x=0,o=1;
    for(;ch<'0' || '9'<ch;ch=getchar()) if(ch=='-') o=-1;
    for(;'0'<=ch&&ch<='9';ch=getchar()) x=(x<<1)+(x<<3)+(ch^'0');
    return x*o;
}
void prg(){
    FOR(x,1,cnt){
        cout<<x<<':';
        REP(x) cout<<v<<'-'<<w<<' ';cout<<endl;
    }
}
void bld(int u,int l,int r){
    if(l==r) {id[l]=u;cnt=max(cnt,u);return;}
    int md=l+r>>1;
    ls[u]=++cnt,rs[u]=++cnt;
    bld(lson),bld(rson);
    add(u,ls[u],0),add(u,rs[u],0); 
}
void adde(int u,int l,int r,int x,int y,int z){
    if(x<=l && r<=y) {add(z,u,1);return;}
    if( y<l || r<x ) return;
    int md=l+r>>1;
    adde(lson,x,y,z),adde(rson,x,y,z);
}
void dfs(int u){
    vis[u]=1;ins[u]=1;
    REP(u){
        if(ins[v]) ok=0;
        if(!vis[v]) dfs(v);
    }
    ins[u]=0;
} 
int main(){
    scanf("%d%d%d",&n,&s,&m); 
    cnt=1,bld(1,1,n);
    FOR(i,1,s) p=read(),f[id[p]]=read(),o[id[p]]=f[id[p]];
    FOR(i,1,m){
        l=read(),r=read(),k=read();
        pr=l;++cnt;
        FOR(j,1,k){
            x=read();
            add(id[x],cnt,0);
            if(pr<=x-1) adde(1,1,n,pr,x-1,cnt);
            pr=x+1; 
        }if(pr<=r) adde(1,1,n,pr,r,cnt);
    } 
    FOR(i,1,cnt) if(!f[i]) f[i]=INF;
    FOR(i,1,cnt) if(!vis[i]){
        ok=1;dfs(i);
        if(!ok){printf("NIE");return 0;}
    }
    FOR(i,1,cnt) if(!in[i]) q.push(i);
    while(!q.empty()){
        u=q.front();q.pop();
        REP(u){
            in[v]--;
            if(o[v]>f[u]-w){printf("NIE");return 0;}
            f[v]=min(f[v],f[u]-w);
            if(!in[v]) q.push(v);
            if(f[v]<1){printf("NIE");return 0;}  
        }
    } 
    printf("TAK\n");
    FOR(i,1,n) printf("%d ",f[id[i]]);
}
```


---

## 作者：E_huan (赞：11)

# 差分约束+线段树优化建图

### 差分约束
这种不等式关系求是否有解 / 构造任意一组解是经典的差分约束问题。

如果需要保证 $dist[u]>dist[v]$，则从 $u$ 向 $v$ 连一条边权是 $-1$ 的边，再跑最段路。根据最段路更新 $dist$ 的条件可以发现，最终只要有解就一定满足 $dist[u]-1 \ge dist[v]$ 即 $dist[u]>dist[v]$。如果无解就会出现环或者和原本的已知权值矛盾。本题边权都是 $1$，可以直接 bfs 求最短路。判环只需要看是否所有点都入过队既可。

### 建立超级节点优化建图
本题中每条边都是多个点向多个点连边的情况，暴力建图时间复杂度高达 $O(n^3)$，可以用常见的方法，对于每条限制建立一个超级点，把 $x_1,x_2...x_{k_i}$ 向超级点连边，边权是 $-1$，超级点向这个区间其它所有点连边，边权是 $0$。但是这样的复杂度上限是 $O(n^2)$ 的，还是不可接受。
发现超级点对“该区间内其它所有点”连边其实就是对被 $x_1,x_2...x_{k_i}$ 分割的若干个小区间连边（小区间个数不超过 $3 \times 10^5$），可以考虑线段树优化建图。

### 线段树优化建图

线段树优化建图的特点很明显，建图过程存在“与区间连边”的操作。如果暴力建边就会高达 $O(n^2)$ 的复杂度，这个时候用区间问题常用的“线段树”来辅助建图可以将复杂度降到 $O(n \log n)$。

常见的是维护两个线段树（入树和出树），那么 $v$ 向区间 $[l,r]$ 连边就变成了出树表示 $v$ 的叶子节点向入树的 $[l,r]$ 区间连边（每次最多与 $\log n$ 个线段树上节点连边），边权即原图的边权。区间向点连边同理。点与点之间的连边其实也是点和区间/区间和点连边的特殊情况了。

由于叶子节点都表示图中的对应节点，所以两个线段树编号向同的叶子节点其实是一个点，在每一对之间连上边权是 $0$ 的边。（注意这两个点是同一个点，为了完全等效要连双向而不是单向）。
所有节点表示图上从这个区间出发 / 到这个区间的边。
根据实际含义，对于入树（别人向它连边），所有节点向其子节点连边，边权是 $0$ 
。对于出树，所有节点向其父节点连边，边权是 $0$。

但本题只有单点向区间连边的情况，而没有区间向单点连边的情况，所以**本题只需要一颗入树就可以了！** 入树和出树之间的边就不需要了，其它的和前面说的一样。

### 代码实现：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=600010,M=6600010,up=1000000000;
int n,s,m,tot,a[N];
int id[N];//id[i]表示：表示区间[i,i]的叶子节点的编号
int idx=1,e[M],ne[M],head[N],w[M];//!!! head[]
int in[N];
inline void add(int x,int y,int z)
{
    e[++idx]=y;
    ne[idx]=head[x];
    head[x]=idx;
    w[idx]=z;
    in[y]++;
}
void build(int u,int l,int r)
{
    tot=max(tot,u);
    if(l==r) {id[l]=u; return;}
    int mid=(l+r)>>1;
    build(u<<1,l,mid); build(u<<1|1,mid+1,r);
    add(u,u<<1,0); add(u,u<<1|1,0);//入树 
}
void Add(int u,int l,int r,int U,int al,int ar)
{
    if(al<=l&&r<=ar)
    {
        add(U,u,0); //u向[l,r]连边，说明u代表入树节点
        return;
    }
    int mid=(l+r)>>1;
    if(al<=mid) Add(u<<1,l,mid,U,al,ar);
    if(ar>mid) Add(u<<1|1,mid+1,r,U,al,ar);
}
int dist[N];
bool vis[N];
void toposort()
{
    queue<int> q;
    for(int i=1;i<=tot;i++)
    {
        if(!in[i]) q.push(i);
        if(!dist[i]) dist[i]=up;
    }
    while(!q.empty())
    {
        int u=q.front(); q.pop(); vis[u]=1;
        for(int i=head[u];i;i=ne[i])
        {
            int v=e[i];
            dist[v]=min(dist[v],dist[u]+w[i]);
            if(a[v]&&dist[v]<a[v]) //按照限制的含义，v最后的权值必须<=dist[v]，而v权值已知是a[v]，那么无解
            {
                puts("NIE");
                exit(0);
            }
            if(!(--in[v])) q.push(v);
        }
    } 
}
int main()
{
    scanf("%d%d%d",&n,&s,&m);
    build(1,1,n);
    for(int i=1,p,d;i<=s;i++)
        scanf("%d%d",&p,&d),a[id[p]]=dist[id[p]]=d;
    for(int t=1,l,r,k;t<=m;t++)
    {
        scanf("%d%d%d",&l,&r,&k);
        tot++;
        for(int i=1,x;i<=k;i++)
        {
            scanf("%d",&x);
            add(id[x],tot,-1);
            if(l<x) Add(1,1,n,tot,l,x-1);
            l=x+1;
        }
        if(l<=r) Add(1,1,n,tot,l,r);
    }
    toposort();
    for(int i=1;i<=tot;i++)
        if(!vis[i]||dist[i]<1)
        {
            puts("NIE");
            return 0;
        }
    puts("TAK");
    for(int i=1;i<=n;i++) printf("%d ",dist[id[i]]);
    return 0;
}
```

---

## 作者：Ebola (赞：8)

# 【POI2015】Pustynia 题解

首先来看一个这样的问题：有一个数列$A$，存在若干关系，每个关系形如$A_x<A_y$，序列中有一些数是已知的，求序列的一种可能构造

这是差分约束的经典问题，解决起来非常简单。我们将每个位置看做一个点，将一个$A_x<A_y$的关系看做一条边$(x,y)$，边权为$1$。如果这样建出来的图存在环，那么问题显然无解。所以有解的图一定是一个DAG。因此我们求出多源最长路，源点就是入度为0的点，求最长路的过程可以在拓扑排序的过程中实现。某个点的最长路表示的就是这个点的最小可能取值，因此假如一个已知点的最长路大于给定值，那么问题无解

上面这个问题就是本题的弱化版本。而本题是说，一个区间$[l,r]$中，有$k$个位置比其它位置大。那么要是暴力解决的话，就按大小关系直接连若干条边。具体地，将区间$[l,r]$中的位置分为两个集合，$S_1$是给定的$k$个点，$S_2$就是其它点，然后集合$S_2$中的所有点都向集合$S_1$中的所有点连边，边权为$1$，然后就和上面那个弱化版问题一样了。

这样连出来的边有$|S_1|\times|S_2|$条，显然是不能接受的。那么稍微聪明一点就会想到：我们新建一个虚拟点，$S_1$中所有点向虚拟点连边，虚拟点再向$S_2$中所有点连边，两种边的边权分别为$0$和$1$，至于哪个是$0$哪个是$1$，可以凭个人喜好决定，这样连出来的边就是$|S_1|+|S_2|$条

但这还是我们不能接受的，因为我们有$m$个区间。不难发现，对于每个区间$[l,r]$，我们的$k$个点将区间分成了若干段，也就是说，虚拟点连向的点，是最多$k+1$段连续的区间，向连续区间连边，就是非常套路的线段树优化建边了。向每段区间至多连$\log\;n$条边，区间总数是$\sum k$，线段树内部需要$2n$条边，给定的$k$个点需要向虚拟点连边，因此边的总数是$k+\sum k\;\log\;n+2n$，这就是我们可以接受的了

另外，在代码实现时，并不需要写多余的判环过程，只要在拓扑排序时加上$vis$标记，最后如果有任意一个点没被访问过，就说明存在环

```cpp
#include<bits/stdc++.h>
using namespace std;

namespace IO
{
	const int S=(1<<20)+5;
	//Input Correlation
	char buf[S],*H,*T;
	inline char Get()
	{
		if(H==T) T=(H=buf)+fread(buf,1,S,stdin);
		if(H==T) return -1;return *H++;
	}
	inline int read()
	{
		int x=0;char c=Get();
		while(!isdigit(c)) c=Get();
		while(isdigit(c)) x=x*10+c-'0',c=Get();
		return x;
	}
	//Output Correlation
	char obuf[S],*oS=obuf,*oT=oS+S-1,c,qu[55];int qr;
	inline void flush(){fwrite(obuf,1,oS-obuf,stdout);oS=obuf;}
	inline void putc(char x){*oS++ =x;if(oS==oT) flush();}
	template <class I>inline void print(I x)
	{
		if(!x) putc('0');
		if(x<0) putc('-'),x=-x;
		while(x) qu[++qr]=x%10+'0',x/=10;
		while(qr) putc(qu[qr--]);
		putc(' ');
	}
}

inline void upmax(int &x,const int &y){if(y>x) x=y;}

using namespace IO;
const int N=500010,lim=(int)1e9;
struct Edge{int to,capa,next;} e[5000000];
int h[N],sum=0,tot,n,m,s;
int a[N],dis[N],deg[N];
int pnt[N];
bool vis[N];

void add_edge(int u,int v,int w)
{
	e[++sum].to=v;
	e[sum].capa=w;
	e[sum].next=h[u];
	h[u]=sum;
	deg[v]++;
}

void Build(int o,int l,int r)
{
	if(l==r){pnt[o]=l;return;}
	pnt[o]=++tot;
	int mid=(l+r)/2;
	Build(o<<1,l,mid);
	Build(o<<1|1,mid+1,r);
	add_edge(pnt[o<<1],pnt[o],0);
	add_edge(pnt[o<<1|1],pnt[o],0);
}

void link(int o,int l,int r,int nl,int nr,int x)
{
	if(l>=nl&&r<=nr){add_edge(pnt[o],x,0);return;}
	int mid=(l+r)/2;
	if(nl<=mid) link(o<<1,l,mid,nl,nr,x);
	if(nr>mid) link(o<<1|1,mid+1,r,nl,nr,x);
}

void TopoSort()
{
	queue<int> q;
	for(int i=1;i<=tot;i++)
	{
		if(!dis[i]) dis[i]=1;
		if(!deg[i]) q.push(i);
	}
	while(!q.empty())
	{
		int u=q.front();q.pop();vis[u]=1;
		for(int tmp=h[u];tmp;tmp=e[tmp].next)
		{
			int v=e[tmp].to;
			upmax(dis[v],dis[u]+e[tmp].capa);
			if(a[v]&&dis[v]>a[v]) puts("NIE"),exit(0);
			if(! --deg[v]) q.push(v);
		}
	}
}

int main()
{
	int k,x,l,r,pre;
	tot=n=read();s=read();m=read();
	Build(1,1,n);
	for(int i=1;i<=s;i++)
	{
		k=read();x=read();
		a[k]=dis[k]=x;
	}
	for(int i=1;i<=m;i++)
	{
		l=read();r=read();k=read();
		pre=l-1;tot++;
		for(int j=1;j<=k;j++)
		{
			x=read();
			add_edge(tot,x,1);
			if(x>pre+1) link(1,1,n,pre+1,x-1,tot);
			pre=x;
		}
		if(x<r) link(1,1,n,x+1,r,tot);
	}
	TopoSort();
	for(int i=1;i<=tot;i++)
		if(!vis[i]||dis[i]>lim)
		{
			puts("NIE");
			return 0;
		}
	puts("TAK");
	for(int i=1;i<=n;i++) print(dis[i]);
	flush();
	return 0;
}
```



---

## 作者：cyffff (赞：6)

[$\text{Link}$](https://www.luogu.com.cn/problem/P3588)
## 题意
给一个长度为 $n$ 的序列 $a$ 的 $s$ 项，给出 $m$ 条限制，一条限制以 $l,r,k,x_1,x_2,\cdot\cdot\cdot,x_k$ 描述，表示在 $[l,r]$ 区间中，$a_{x_1},a_{x_2},\cdot\cdot\cdot,a_{x_k}$ 都严格大于没被选中的数。

求一种构造方案。

$1\le s\le n\le10^5,1\le m\le 2\times 10^5,\sum k\le 3\times 10^5$
## 思路
模拟赛 $\text C$ 题，赛时做出来了！！1

首先看到大于，可以想到差分约束，但是要是直接暴力连边的话边数是 $O(\sum k(r-l+1-k))=O(n^2m)$ 的。显然不能通过。

稍加思考可以想到建立两个虚点，两边分别向虚点连边（或被虚点连向），边数是 $O(\sum k+\sum r-l+1-k)=O(nm)$ 的。仍然不能通过。

考虑到第二部分为整个区间被 $k$ 个位置隔开的若干个子区间，直接由子区间向虚点连边，考虑线段树优化建图，边数为 $O(\sum k+\sum \log (r-l+1-k))=O(\sum k+m\log n)$ 的，此时边数已在合理范围内。

接下来考虑解决原问题。考虑拓扑排序，可以同时求出是否有环和最长路，最开始需要先把给出的 $s$ 项的最长路设定为给出的，其余设定为 $1$，此时便可以进行拓扑排序了。

时间复杂度 $O((\sum k+m)\log n)$。

注意，经我测试，极限数据下边数不少于 $5.5\times 10^6$，点数不少于 $6\times 10^5$，许多题解也因此被我 hack 了。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
namespace IO{//by cyffff
	
}
const int N=6e5+10,E=6e6+10;
int n,m,s,r[N],ind[N];
int cnt,head[N]; 
struct Edge{
	int to,nxt,w;
}a[E];
inline void add(int u,int v,int w){
	cnt++;
	a[cnt].w=w;
	a[cnt].to=v;
	a[cnt].nxt=head[u];
	head[u]=cnt;
	ind[v]++;
}
int id;
int num[N];
#define ls (rt<<1)
#define rs (rt<<1|1)
inline void build(int rt,int l,int r){
	if(l==r){
		num[rt]=l;
		return ;
	}
	num[rt]=++id;
	int mid=l+r>>1;
	build(ls,l,mid);
	build(rs,mid+1,r); 
	add(num[ls],num[rt],0);
	add(num[rs],num[rt],0);
}
inline void add(int rt,int l,int r,int L,int R,int u){
	if(L<=l&&r<=R){
		add(num[rt],u,0);
		return ;
	}
	int mid=l+r>>1;
	if(L<=mid) add(ls,l,mid,L,R,u);
	if(R> mid) add(rs,mid+1,r,L,R,u);
}
int dis[N];
bool vis[N];
inline int topo(){
	queue<int>q;
	for(int i=1;i<=id;i++){
		dis[i]=max(dis[i],1);
		if(!ind[i]) q.push(i);
	}
	while(!q.empty()){
		int cur=q.front();
		q.pop();
		vis[cur]=1;
		for(int i=head[cur];i;i=a[i].nxt){
			int t=a[i].to; 
			dis[t]=max(dis[t],dis[cur]+a[i].w);
			if(r[t]&&dis[t]>r[t]) return -1;
			if(--ind[t]==0)
				q.push(t);
		}
	}
	for(int i=1;i<=id;i++)
		if(!vis[i]||dis[i]>1e9)
			return -1;
	return 1;
}
int main(){
//	freopen("data_C2.in","r",stdin);
//	freopen("data_C2.out","w",stdout); 
	n=id=read(),s=read(),m=read();
	build(1,1,n);
	for(int i=1;i<=s;i++){
		int p=read();
		r[p]=dis[p]=read();
	} 
	while(m--){
		int l=read(),r=read(),k=read();
		id++;
		int cur=l-1;
		for(int i=1;i<=k;i++){
			int p=read();
			add(id,p,1);
			if(p-1!=cur)
				add(1,1,n,cur+1,p-1,id);
			if(i==k&&p<r)
				add(1,1,n,p+1,r,id);
			cur=p;
		}
	}
	if(~topo()){
//		printf("%d %d\n",cnt,id);
		puts("TAK");
		for(int i=1;i<=n;i++)
			printf("%d ",dis[i]);
	}else{
		puts("NIE");
	}
}
```
再见 qwq~

---

## 作者：小塘空明 (赞：5)

这种区间对区间的建边，当然要用线段树来优化咯。

对于每个区间，我们将不在a数组中的所有数看成一个集合1，剩下的看成一个集合2，再建立一个虚拟节点。

利用线段树将集合1所处的区域向虚拟节点连一条权值为0的边，同时虚拟节点向集合2中所有点连一条权值为1的边。

最后我们跑一遍拓扑排序。

答案不存在有三种可能：

**（1）：** 该节点值已经确立且该节点所能取最小值大于该值。

**（2）：** 约束条件存在环。

**（3）：** 该节点所能取最小值不在范围内。

```
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<string>
#include<cstring>
#include<cmath>
#include<queue>
using namespace std;
const int size=5e5+10,inf=1e9;
int n,m,s,cnt,tot,a[size],id[size],dis[size],vis[size],head[size],ver[size*10],edge[size*10],next[size*10],du[size];
struct node{
	int l,r;
	#define l(x) tree[x].l
	#define r(x) tree[x].r
}tree[size];
queue<int> q;
inline int read(){
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+ch-'0';ch=getchar();}
	return x*f;
}
inline void add(int x,int y,int z){ver[++tot]=y;edge[tot]=z;next[tot]=head[x];head[x]=tot;du[y]++;}
inline void build(int p,int l,int r){
	l(p)=l;r(p)=r;
	if(l==r){id[p]=l;return;}
	id[p]=++cnt;
	int mid=(l(p)+r(p))>>1;
	build(p*2,l,mid);build(p*2+1,mid+1,r);
	add(id[p*2],id[p],0);add(id[p*2+1],id[p],0);
}
inline void update(int p,int l,int r,int x){
	if(l<=l(p)&&r(p)<=r){add(id[p],x,0);return;}
	int mid=(l(p)+r(p))>>1;
	if(l<=mid) update(p*2,l,r,x);
	if(r>mid) update(p*2+1,l,r,x);
}
inline void topsort(){
	for(int i=1;i<=cnt;i++){
		dis[i]=(dis[i])?dis[i]:1;
		if(!du[i]) q.push(i);
	}
	while(q.size()){
		int x=q.front();q.pop();vis[x]=1;
		for(int i=head[x];i;i=next[i]){
			int y=ver[i],z=edge[i];
			dis[y]=max(dis[y],dis[x]+z);
			if(a[y]&&dis[y]>a[y]){
				printf("NIE\n");exit(0);
			}
			if(!(--du[y])) q.push(y);
		}
	}
}
int main(){
	n=cnt=read();s=read();m=read();
	build(1,1,n);
	for(int i=1;i<=s;i++){int p=read(),d=read();a[p]=dis[p]=d;}
	for(int i=1;i<=m;i++){
		int l=read(),r=read(),k=read();
		int pre=l-1;cnt++;
		for(int j=1;j<=k;j++){
			int x=read();
			if(x>pre+1) update(1,pre+1,x-1,cnt);
			add(cnt,x,1);pre=x;
		}
		if(pre<r) update(1,pre+1,r,cnt);
	}
	topsort();
	for(int i=1;i<=n;i++){
		if(!vis[i]||dis[i]>inf){
			printf("NIE\n");return 0;
		}
	}
	printf("TAK\n");
	for(int i=1;i<=n;i++){printf("%d ",dis[i]);}
	return 0;
}
```


---

## 作者：Alex_Wei (赞：3)

> [P3588 [POI2015]PUS](https://www.luogu.com.cn/problem/P3588)
>
> [POI 合集](https://www.cnblogs.com/alex-wei/p/POI.html)。

裸的线段树优化建图板子。对于每个区间被选中的数 $p_1,p_2,\cdots,p_k$，向区间 $[l,p_1-1],[p_1+1,p_2-1],\cdots,[p_k+1,r]$ 连边表示 $p_i$ 大于这些区间中的任何数。

若干个点向若干个区间两两连边可以建虚点优化 + 线段树区间连边。注意只有当指向的节点为叶子结点时有指向的点的值要小于当前点的值，否则只需满足不大于。最后跑一遍拓扑排序即可得到答案。

时间复杂度线性对数，注意不要开小数组了。

```cpp
const int N = 1e5 + 5;
int n, s, m, mx, label[N], type[N * 6], d[N * 6], deg[N * 6], fix[N * 6];
vint e[N * 6];
void add(int u, int v) {e[u].pb(v), deg[v]++;}
void build(int l, int r, int x) {
	if(l == r) return cmax(mx, label[l] = x), type[x] = l, void();
	int m = l + r >> 1;
	build(l, m, x << 1), build(m + 1, r, x << 1 | 1);
}

int ql, qr, from;
void link(int l, int r, int x) {
	if(ql > qr) return;
	if(ql <= l && r <= qr) return add(from, x), void();
	int m = l + r >> 1;
	if(ql <= m) link(l, m, x << 1);
	if(m < qr) link(m + 1, r, x << 1 | 1);
}
void push(int l, int r, int x) {
	if(l == r) return; 
	if(deg[x]) add(x, x << 1), add(x, x << 1 | 1);
	int m = l + r >> 1;
	push(l, m, x << 1), push(m + 1, r, x << 1 | 1);
}

int main() {
	cin >> n >> s >> m, build(1, n, 1);
	for(int i = 1, p; i <= s; i++) p = read(), d[label[p]] = read(), fix[label[p]] = 1;
	for(int i = 1; i <= m; i++) {
		int l = read(), r = read(), k = read();
		static int p[N]; from = ++mx, p[0] = l - 1, p[k + 1] = r + 1;
		for(int i = 1; i <= k; i++) p[i] = read(), add(label[p[i]], from);
		for(int i = 1; i <= k + 1; i++)
			ql = p[i - 1] + 1, qr = p[i] - 1, link(1, n, 1);
	} push(1, n, 1);
	queue <int> q; int tot = 0;
	for(int i = 1; i <= n; i++) if(!deg[label[i]])
		q.push(label[i]), d[label[i]] = !d[label[i]] ? 1e9 : d[label[i]];
	while(!q.empty()) {
		int t = q.front(); q.pop(), tot += type[t] > 0;
		for(int it : e[t]) {
			if(type[it] && fix[it] && d[it] >= d[t]) return puts("NIE"), 0;
			if(!d[it]) d[it] = d[t] - (type[it] > 0);
			else cmin(d[it], d[t] - (type[it] > 0));
			if(d[it] < 1) return puts("NIE"), 0; 
			if(!--deg[it]) q.push(it);
		}
	}
	if(tot != n) return puts("NIE"), 0;
	puts("TAK");
	for(int i = 1; i <= n; i++) cout << d[label[i]] << " ";
	cout << endl; 
	return cerr << "Time : " << clock() << " ms" << endl, flush(), 0;
}
```

---

## 作者：i_love_xqh (赞：2)

## 题目链接

[[POI2015] PUS](https://www.luogu.com.cn/problem/P3588)

## 分析

### 题目大意

给定一个长度为 $n$ 范围为 $1\sim 10^9$ 的序列 $a$，其中已经给出 $s$ 个数。然后有 $m$ 条限制关系，表示已知 $l\sim r$ 区间中的 $k$ 个数是严格大于剩下 $r-l+1-k$ 个数。

### 题目分析

首先判断无解的情况，肯定是当几种限制情况出现矛盾的时候，比如说已经有 $a>b$，$b>c$ 了，现在又给出一条 $c>a$，这时候就是无解的情况。然后可以发现，如果把 $a>b$ 的关系放在一个图上，就是 $a$ 向 $b$ 连一条有向边，而无解情况也就是图上出现了一个环。于是整道题就转变成了一个图上问题。

首先一种最朴素的思想是，对于每一条限制关系，对 $l\sim r$ 区间内的 $k$ 个数，每个数向其他 $r-l+1-k$ 个数连一条有向边。

然后判断一张图是否有环，就只需要拓扑排序。先将入度为 $0$ 的点存入队列里，然后看当前弹出的点 $u$ 连出去的点 $v$，将 $v$ 的入度减 $1$，如果 $v$ 的入度也变成 $0$ 了，就将 $v$ 给弹进队列里。最后如果发现还有入度不为 $0$ 的点，那么就出现了环，也就是无解。

然后还要考虑是否满足范围在 $1\sim 10^9$ 间并且还要满足 $s$ 个数的限制，设点 $x$ 最终的值是 $f_x$，那么在拓扑排序前，对于入度为 $0$ 的点 $x$（如果 $x$ 没有给出限制），就将 $f_x$ 设为 $10^9$。然后在拓扑过程中，对于当前 $u\to v$，就有 $f_v=\min(f_v,f_u-1)$，为了尽可能的满足条件，所以每次只用是当前值减 $1$。然后对于一个没有给出限制的点 $x$，如果有 $f_x<1$，那么也是无解的；对于一个给出限制的的点 $x$，如果有 $f_x$ 小于给出的值，那么也是无解的。

但是会发现，对于前半部分建边的时候，连边数量是 $k\times n$ 级别的，时间复杂度也是 $O(k\times n)$，所以就要想想怎么优化。发现对于 $l\sim r$ 区间内的 $k$ 个数，因为它们都有大于剩下 $r-l+1-k$ 个数的限制，于是就想着增加一个虚拟节点 $p$，每个点向虚拟节点连一条有向边，再由该虚拟节点连向剩下 $r-l+1-k$ 个数，这样时间空间就降到了 $O(m\times n)$。

但是肯定还是要继续优化，发现剩下的数本质上最多是 $k+1$ 个连续的区间，一说到一个点连向一个区间，就会想到用线段树优化建图，所以就只需要建一颗 $1\sim n$ 的线段树，然后每次向一个区间连边，这样最多连 $\log_2 n$ 个点，空间复杂度也就降到 $O(m\log_2n)$，时间复杂度也是 $O(m\log_2n)$。

但是要注意一点，要区分线段树连的边、$k$ 个点向虚拟节点连的边、虚拟节点向线段树节点连的边，发现只有第三种边，在拓扑转移 $f$ 的值的时候才用减 $1$，其他保持不变即可。然后还要注意将点的编号从 $1\sim n$ 转变成线段树上单个点的编号。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
struct node{
    int y,z,next;
}e[6000010];//边数是mlogn+4n，即连的边数加线段树的边数
int cnt,elast[600010],ds;//点数是m+4n，即虚拟节点加线段树的点数
int rd[600010];
void add(int x,int y,int z){
    e[++cnt].y=y;
    e[cnt].z=z;//z负责区分第一二种边与第三种边
    e[cnt].next=elast[x];
    elast[x]=cnt;
    rd[y]++;
}//链式前向星
struct Tree{
    int l,r;
}Tree[400010];
int change[100010];
void build(int p,int l,int r){
    Tree[p].l=l;
    Tree[p].r=r;
    if(l==r){
        ds=max(ds,p);//看最大点数，便于后边加虚拟节点
        change[l]=p;//获取每个点在线段树中的编号
        return;
    }
    int mid=(l+r)>>1;
    build(p*2,l,mid);
    build(p*2+1,mid+1,r);
    add(p,p*2,0);
    add(p,p*2+1,0);//第一种边
}
void Add(int p,int l,int r,int u){
    if(Tree[p].l>=l&&Tree[p].r<=r){
        add(u,p,1);//第三种边
        return;
    }
    int mid=(Tree[p].l+Tree[p].r)>>1;
    if(l<=mid)Add(p*2,l,r,u);
    if(r>mid)Add(p*2+1,l,r,u);
}//向区间连边
int a[600010],a2[600010];//a是它最终的值，a2是题目所给出的值
queue<int>pq;
bool flag;
int main(){
    int n,s,m;
    scanf("%d%d%d",&n,&s,&m);
    build(1,1,n);
    for(int i=1;i<=s;i++){
        int x,d;
        scanf("%d%d",&x,&d);
        a[change[x]]=a2[change[x]]=d;
    }
    for(int i=1;i<=m;i++){
        int l,r,k;
        scanf("%d%d%d",&l,&r,&k);
        int now=l;
        ++ds;//虚拟节点
        for(int j=1;j<=k;j++){
            int x;
            scanf("%d",&x);
            add(change[x],ds,0);//第二种边
            if(now<=x-1)Add(1,now,x-1,ds);//向now至x-1的区间连边
            now=x+1;更新now
        }
        if(now<=r)Add(1,now,r,ds);
    }
    for(int i=1;i<=ds;i++){
        if(!a[i])a[i]=1e9;//只给没有给出限制的点赋初值
        if(!rd[i])pq.push(i);//弹进入度为0的点
    }
    while(!pq.empty()){
        int u=pq.front();
        pq.pop();
        for(int i=elast[u];i;i=e[i].next){
            int v=e[i].y;
            if(a[u]-e[i].z<a2[v]||a[u]-e[i].z<1){
                flag=true;
                break;
            }//无解情况
            a[v]=min(a[v],a[u]-e[i].z);
            rd[v]--;
            if(!rd[v])pq.push(v);
        }
    }//拓扑
    for(int i=1;i<=ds;i++)if(rd[i])flag=true;//有环的情况
    if(flag)printf("NIE");
    else{
        printf("TAK\n");
        for(int i=1;i<=n;i++)printf("%d ",a[change[i]]);
    }
    return 0;
}
```

---

## 作者：glorious_dream (赞：2)

### 题目描述：

给定一个长度为 $n$ 的正整数序列 $a$，每个数在 $1$ 到 $10^9$ 范围内，告诉你其中 $s$ 个数，并给出 $m$ 条信息，每条信息包含三个数 $l$，$r$，$k$ 以及接下来 $k$ 个正整数，表示 $a_l$ 到 $a_r$ 里这 $k$ 个数中的任意一个都比任意一个剩下的 $r-l+1-k$ 个数大(严格大于)。请构造出一组满足条件的方案，或判断无解。

### 算法分析：

首先，有一个最简单的思路，把这个区间里的其它数向这 $k$ 个数连一条边权为 $1$ 的边，表示这 $k$ 个数要比其它的数大，然后跑一边拓扑排序，求最长路。如果有环，那么问题就无解。否则，有解的图一定是一个有向无环图。

考虑为什么要求最长路。这里的最长路表示该点的最小取值。如果我们求出来的这个点的 $dis_i$ 大于给定数范围的限制，或者当前点是给定的，但我们求出的最长路大于他给定的值，那么就无解，否则直接输出从 $1$ 到 $n$ 的 $dis_i$ 即可。

但这道题的边数有 $\mid S1 \mid \times \mid S2 \mid$ 条，$S1$ 是给定的 $k$ 个点，$S2$ 是其余的点。显然炸了。

考虑第一个优化，我们可以建一个虚拟点 $node$，把 $node$ 向 $k$ 个点连一条边权为 $1$ 的边，然后把其它的区间向虚拟点 $node$ 连一条边权为 $0$ 的边，这样我们就可以表示上述所说的把这个区间里的其它数向这 $k$ 个数连一条边权为 $1$ 的边。

但边的条数我们还是不能接受。

考虑进一步的优化。我们有 $m$ 个区间，每一个区间最多有 $k+1$ 段。跟区间有关的连边，我们可以想到线段树优化建图。具体就是，线段树的两个孩子节点分别向父节点连一条边权为 $0$ 的边，然后区间向虚拟点 $node$ 连边就可以表示为线段树上的一段区间向虚拟点 $node$ 连边。这样向每段区间最多有 $\log n$ 条边，区间的总数是 $\sum k$，线段树内部有 $2n$ 条边，给定的 $k$ 个点需要连边，这样边的总数是 $k + \sum k \log n + 2n$，可以过这道题。

最后说一下如何判环，我们发现在拓扑排序中，把每一个点 $i$ 如果访问到就 $vis_i = 1$ 最后看是否有点没有被访问过，如果有的话那就是有环，没有的话直接判最长路即可。

### 总代码：

```cpp
#include <cstdio>
#include <iostream>
#include <cstring>
#include <algorithm>
#include <cmath>
#include <queue>
#define re register
#define rep(a,b,c)  for(re int a(b) ; a<=c ; ++a)
#define drep(a,b,c) for(re int a(b) ; a>=c ; --a)
using namespace std;
inline int read(){
    int x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch == '-') f=-1 ; ch=getchar();}
    while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48) ; ch=getchar();}
    return x*f;
}
const int M = 5e5+10;
const int limit = 1e9;
int a[M],dis[M],head[M],vis[M];
int du[M],t[M];
int n,s,m;
int cnt,tot;
struct edge{
    int to,nxt,w;
}e[M*10]; //注意不要开小
inline void add(int u,int v,int w){ //加边
    e[++cnt].to = v;
    e[cnt].w = w;
    e[cnt].nxt = head[u];
    head[u] = cnt;
    du[v]++;
}
inline void build(int k,int l,int r){ //正常的线段树建立
    if(l == r){
        t[k] = l; //叶节点的编号
        return;
    }
    t[k] = ++tot; //每一个节点的编号
    int mid = (l+r)>>1;
    build(k<<1,l,mid);
    build(k<<1|1,mid+1,r);
    add(t[k<<1],t[k],0),add(t[k<<1|1],t[k],0); //左右儿子分别向父亲连边
}
inline void link(int k,int l,int r,int x,int y,int node){
    if(x<=l && r<=y){
        add(t[k],node,0); // 这个区间向虚拟点node连边
        return;
    }
    int mid = (l+r)>>1;
    if(x<=mid) link(k<<1,l,mid,x,y,node);
    if(y>mid)  link(k<<1|1,mid+1,r,x,y,node); //正常操作
}
inline void topo(){
    queue<int> q;
    for(re int i(1) ; i<=tot ; ++i){
        if(!dis[i]) dis[i] = 1; //从1开始
        if(du[i] == 0) q.push(i); //把入度为0的点先加进队列
    }
    while(!q.empty()){
        int u = q.front();
        q.pop();
        vis[u] = 1; //标记这个点走到了
        for(re int i(head[u]) ; i ; i=e[i].nxt){
            int v = e[i].to,w = e[i].w;
            if(dis[v] < dis[u] + w) dis[v] = dis[u] + w; //更新最长路
            if(a[v] && dis[v] > a[v]) printf("NIE\n"),exit(0); //如果不满足条件
            du[v]--;
            if(!du[v]) q.push(v);
        }
    }
}
signed main(){
    n=read(),s=read(),m=read();
    tot = n;
    build(1,1,n);
    rep(i,1,s){
        int pos=read(),x=read();
        a[pos] = dis[pos] = x;
    }
    rep(i,1,m){
        int l=read(),r=read(),k=read();
        tot++; //tot就是虚拟点
        int pre = l-1; //上一段区间的左端点
        int x;
        for(re int j(1) ; j<=k ; ++j){
            x = read();
            add(tot,x,1); //虚拟点向x连边
            if(x > pre+1) link(1,1,n,pre+1,x-1,tot); //这个区间没有被连边，就连边
            pre = x; //更新pre
        }
        if(x < r) link(1,1,n,x+1,r,tot); //最后看是否会剩一段区间没有连边
    }
    topo();
    for(re int i(1) ; i<=tot ; ++i) if(!vis[i] || dis[i] > limit) { printf("NIE\n"); return 0; } //判无解
    printf("TAK\n");
    rep(i,1,n) printf("%d ",dis[i]);
    return 0;
}
```


---

## 作者：Treaker (赞：2)

$$\color{cornflowerblue}{\mathcal{Treaker}}$$
# 拓扑排序 + 线段树优化建图

这道题，先不想正解的话，写暴力的时候应该很容易发现有约束关系~~废话~~，而这个约束关系似乎差分约束并不可做，拓扑排序还想可以试试。

那就拓扑排序建一张图，表示约束关系，那么你得到了部分的分。

那么它的瓶颈在哪里呢？ 

你发现建图是$O(n^2)$的，不可接受。。。

肿么办呢。。

我们能不能$O(n)$建图呢~~你在想屁吃~~

$O(nlogn)$还差不多。

想到一个东西，叫线段树优化建图，~~这种题应该还是比较少见的吧~~。

就是每次操作我们都新建一个节点，然后向这个新节点连边，这样建图就很方便了。

然后没了。

完整代码如下：
```cpp
#include <cstdio>
#include <iostream>
#include <cstring>
#include <algorithm>
#include <queue>
#define mid ((p -> l + p -> r) >> 1)
using namespace std;
const int N = 1000005 , inf = 1e9;
inline int read()
{
	int x = 0 , f = 1;	char ch = getchar();
	while(ch < '0' || ch > '9')	{if(ch == '-')	f = -1; ch = getchar();}
	while(ch >= '0' && ch <= '9') {x = (x << 3) + (x << 1) + (ch ^ 48); ch = getchar();}
	return x * f;
}
int n , s , m , cnt;
int mon[N] , in[N] , a[N];
bool vis[N] , flag[N];
struct Edge
{
	int to , dis; Edge *nxt;
	Edge(int to = 0,int dis = 0,Edge *nxt = NULL) : to(to) , dis(dis) , nxt(nxt) {}
}*head[N];
inline void add(int u,int v,int w) {head[u] = new Edge(v,w,head[u]);}
inline bool toposort()
{
	queue<int> q;
	for(int i = 1;i <= cnt;i ++) if(!in[i])
	{
		if(!flag[i] && i <= n) mon[i] = 1;
		q.push(i); if(mon[i] > inf || mon[i] < 1) return 0;
	}
	while(q.size())
	{
		int now = q.front(); q.pop(); vis[now] = 1;
		for(Edge *i = head[now];i;i = i -> nxt)
		{
			int to = i -> to;
			mon[to] = max(mon[to],mon[now] + i -> dis);
			if(a[to] && a[to] < mon[to]) return 0;
			if(mon[to] > inf || mon[to] < 1) return 0;
			if(--in[to] == 0) q.push(to);
		}
	}
	for(int i = 1;i <= n;i ++) if(!vis[i] || mon[i] > inf) return 0;
	return 1;
}
struct node
{
	node *ls , *rs;
	int l , r , id;
	node(int l = 0,int r = 0) : l(l) , r(r) {id = 0;}
}*root;
void build(node *&p,int l,int r)
{
	p = new node(l,r);
	if(l == r) return (void)(p -> id = l);
	else p -> id = ++cnt;
	build(p -> ls,l,mid); build(p -> rs,mid+1,r);
	add(p -> ls -> id,p -> id,0), add(p -> rs -> id,p -> id,0); in[p -> id] += 2;
}
void chenge(node *p,int x,int y)
{
	if(x <= p -> l && p -> r <= y) return (void)(add(p -> id,cnt,0) , in[cnt] ++);
	if(x <= mid) chenge(p -> ls,x,y);
	if(y > mid) chenge(p -> rs,x,y);
}
int main()
{
// 	freopen("c.in","r",stdin);
// 	freopen("c.out","w",stdout);
	n = read(); s = read(); m = read(); cnt = n;
	build(root,1,n);
	for(int i = 1 , x , y;i <= s;i ++) 
	{
		x = read(); y = read();
		a[x] = mon[x] = y; flag[x] = 1;
		if(mon[x] > 1e9 || mon[x] < 1) return puts("NIE") , 0;
	}
	for(int _ = 1 , l , r , k , last;_ <= m;_ ++)
	{
		l = read(); r = read(); k = read(); last = l; cnt ++;
		for(int i = 1 , x;i <= k;i ++)
		{
			x = read(); add(cnt,x,1); in[x] ++;
			if(last < x) chenge(root,last,x-1);
			last = x + 1;
		}
		if(last <= r) chenge(root,last,r);
	}
	bool tmp = toposort();
	puts(tmp ? "TAK" : "NIE");
	if(tmp) for(int i = 1;i <= n;i ++) printf("%d ",mon[i]);
	fclose(stdin);
	fclose(stdout);
	return 0;
}
```


---

## 作者：wnsyou (赞：1)

# [PUS](https://www.luogu.com.cn/problem/P3588)

推销我的[博客园。](https://www.cnblogs.com/wnsyou-blog/p/18313027/P3588_solution)

## 题意

给出三个整数 $n,s,m$，请你构造一个整数数组 $a$ 满足 $1\leqslant a_i \leqslant 10^9(1\leqslant i \leqslant n)$ 以及 $m$ 个约束条件，或判断无解。$a$ 数组中 $s$ 个数已经给出（保证合法）。 

$m$ 个约束条件格式如下：$l,r,k,x_1,x_2\cdots x_k$，表示对于 $\forall i,l\leqslant i \leqslant r,i \not\in x$，都有 $a_j > a_i(j\in x)$。

如果存在一个满足要求的数组 $a$，输出 `TAK`，然后在下一行输出任意一种满足要求的 $a$；否则输出 `NIE`。

### 数据范围

- $1\leqslant s\leqslant n \leqslant 10^5, 1\leqslant m \leqslant 2 \times 10^5$。
- $1\leqslant l < r \leqslant n, 1\leqslant k \leqslant r - l$。
- $l \leqslant x_1 < x_2 < \cdots < x_k \leqslant r$。
- $\sum k \leqslant 3 \times 10^5$。

## 思路

线段树优化建图。

### 初步思路：将约束条件转为建图

题目要求构造一个合法的 $a$ 数组，可以很显然的发现，当你从大到小的确定 $a$ 中的元素时，$a_i$ **越大越好。**

那么我们可以根据约束条件，建出一张由较大元素连向较小元素的有向图，最后根据这张图即可构造 $a$ 数组(用 $mi_i$ 表示所有连向它的元素的 $a_{j}$ 最小值，那么 $a_i$ 最大就为 $mi_i - 1$)。

如果是暴力建图，我们需要将每个 $x$ 中的元素都连向其他在 $[l,r]$ 中却不在 $x$ 中的元素，很明显边的数量是 $n^2$ 级别的，无法接受。

### 建图的优化：集中点

如果做过 [abc270_f Transportation](https://www.cnblogs.com/wnsyou-blog/p/17410723.html) 的话，你可以想到对于每个约束条件都建一个集中节点 $id$，将每个在 $x$ 中的元素都连向 $id$，再将 $id$ 连向每个在 $[l,r]$ 中却不在 $x$ 中的元素，边的数量便变成了 $O(m \times n + \sum k)$，似乎更差劲了。

别着急，这都是为了为下一步优化做铺垫。

注意有一个细节，题目中约束条件是严格大于，所以 $a_i = mi_i - 1$（参考上方），但对于这些集中点来说，他们**并不用严格小于连向它的元素**，即 $mi_i=a_i$，需要特别注意。

### 建图再次优化：线段树优化建图

可以发现，$id$ 暴力连向每个在 $[l,r]$ 中却不在 $x$ 中的元素的复杂度过大，**但是我们能发现，与其使用暴力连单点，我们不如转换为连接区间，这样就可以使用线段树优化建图。**

由于题目保证 $\sum k \leqslant 3 \times 10^5$，可以发现区间数量也是这个级别（只用考虑相邻两个 $x$ 之间的区间 $(x_i, x_{i+1})$），那么就好办了。

附：[线段树优化建图的模板](https://vjudge.d0j1a1701.cc/problem/CodeForces-786B)。

### 最终：整理答案和判断无解

这个很简单，使用拓扑排序即可解决，注意上面所说的细节。

无解情况如下：

- 在最优秀的构造方案中，你的 $a_i$ 肯定是尽量越大越好，所以当你发现某个 $a_i < 1$，那么必然是无解的。

- 如果你发现最初已经给定了某个元素 $a_i$ 并且 $mi_i - 1 < a_i$，那么也是不合法的。

- 如果出现了环，那么也是不合法的。

那么本题就结束了，还不理解就看代码。

### 复杂度

- 时间：$O(n+m+\sum k \log n)$。
- 空间：$O(n + m)$。

## Code

```cpp
#include <bits/stdc++.h>

using namespace std;
using ll = long long;

const int N = 1e5 + 10, M = 2e5;

// ls 和 rs 用于记录线段树左右儿子，a 用于记录方案，b 是上文所说的 x，cnb 用于拓扑排序，mi 见上文
int n, m, s, rt, ncnt, ls[3 * N + M], rs[3 * N + M], a[3 * N + M], b[N], cnb[3 * N + M], mi[3 * N + M];
vector<int> g[3 * N + M];
queue<int> q;

//----------------------------------------------------------------- 线段树优化建图
void Add_edge (int x, int y) {
  g[y].push_back(x), cnb[x]++;
}

void build (int id, int l, int r) {
  if (l == r) {
    ls[id] = l;
    Add_edge(l, id);
    return ;
  }
  int mid = (l + r) >> 1;
  ls[id] = ++ncnt, rs[id] = ++ncnt;
  build(ls[id], l, mid), build(rs[id], mid + 1, r);
  Add_edge(ls[id], id), Add_edge(rs[id], id);
}

void modify (int id, int l, int r, int x, int y, int u) {
  if (x <= l && r <= y) {
    Add_edge(id, u);
    return ;
  }
  if (l > y || r < x)
    return ;
  int mid = (l + r) >> 1;
  modify(ls[id], l, mid, x, y, u), modify(rs[id], mid + 1, r, x, y, u);
}
//----------------------------------------------------------------- 线段树优化建图

int main () {
  ios::sync_with_stdio(0), cin.tie(0);
  cin >> n >> s >> m, ncnt = n;
  rt = ++ncnt, build(rt, 1, n);
  for (int i = 1, x, y; i <= s; i++)
    cin >> x >> y, a[x] = y; // 最初给定的元素直接赋值即可
  for (int x, k; m--; ) {
    cin >> b[0] >> x >> k, ncnt++, b[0]--;
    for (int i = 1; i <= k; i++) {
      cin >> b[i], g[b[i]].push_back(ncnt), cnb[ncnt]++;
      if (b[i] != b[i - 1] + 1) //只用管相邻两个元素之间的区间
        modify(rt, 1, n, b[i - 1] + 1, b[i] - 1, ncnt);
    }
    if (x != b[k]) // 最后一个区间别漏了
      modify(rt, 1, n, b[k] + 1, x, ncnt);
  }
  for (int i = 1; i <= ncnt; i++) // 初始化为 1e9 + 1 是为了方便下方减一
    mi[i] = 1e9 + 1;
  q.push(rt);
  while (q.size()) {
    int x = q.front();
    q.pop();
    if (a[x]) {// 初始时有数
      if (mi[x] - 1 < a[x]) { // 判断无解情况 #2
        cout << "NIE";
        return 0;
      }
    } else {
      a[x] = mi[x] - (x <= n); // 细节：集中点 a[i] = mi[i]
      if (a[x] <= 0) { // 判断无解情况 #1
        cout << "NIE";
        return 0;
      }
    }
    for (int i : g[x]) { // 拓扑排序都会写吧
      mi[i] = min(mi[i], a[x]), cnb[i]--;
      if (!cnb[i])
        q.push(i);
    }
  }
  for (int i = 1; i <= n; i++)
    if (a[i] <= 0) { // 如果有环的话，肯定有元素没被赋值。判断无解情况 #1
      cout << "NIE";
      return 0;
    }
  cout << "TAK\n";
  for (int i = 1; i <= n; i++)
    cout << a[i] << ' ';
  return 0;
}
```

---

## 作者：小超手123 (赞：1)

##### 题意：

给定一个长度为 $n$ 的序列 $a$ 的部分位置的值。需要构造该序列使得满足以下 $m$ 个条件。每个条件给出了 $l,r,k$ 和 $k$ 个数，表示在 $[l,r]$ 的这 $k$ 个数都比其他数大。

$\sum k \le 3 \times 10^5$。

##### 分析：

 先考虑 $\sum k$ 较小时怎么做。

一个很显然的思路是把这 $k$ 个数与另外 $r-l+1-k$ 个数两两连一条边，连 $x \rightarrow y$ 表示 $a_y$ 严格大于 $a_x$。

如果有环就无解。~~不会真有人用 tarjan 判环吧，我不说是谁。~~

那么图就变成了一个 DAG。即可利用拓扑排序。

如果 $a_y$ 被给出的话，就要判断 $a_y$ 是否大于等于 $a_x+1$，否则就无解。

$a_y$ 没有给出，显然有转移 $a_y=\max(a_x+1)$。

根据贪心的原则，我们对入度为 $0$ 且没有给出的点，有 $a_x=1$。



但这样做边的数量级是 $n^2$ 的。

对每个条件都新建一个点，记作 $x$。

一共有 $k$ 个数，划分成了 $k+1$ 段。对这 $k$ 个数，我们称为 $k_i$，对着 $k+1$ 段我们称为 $l_i,r_i$。

显然有 $[l_i,r_i] \rightarrow x$（边权为 $0$），以及 $x \rightarrow k_i$（边权为 $1$）。

边权为 $0$ 表示 $a_u \le a_v$，边权为 $1$ 表示 $a_u < a_v$。

显然可以用线段树优化建图。不会去做 [模板题](https://www.luogu.com.cn/problem/CF786B)。

建图代码如下：

```cpp
for(int i = 1, l, r, k; i <= m; i++) {
		l = read(), r = read(), k = read();
		cnt++; //对每个限制建立一个源点 
		int L = l, x;
		for(int j = 1; j <= k; j++) { //k把小的数分成了k+1段 
			X[j] = read();
			if(L <= X[j] - 1) update(1, 1, n + m, L, X[j] - 1, cnt, 0); //建边：小的数 <= 源点 
			L = X[j] + 1;
		}
		if(L <= r) update(1, 1, n + m, L, r, cnt, 0);
		for(int j = 1; j <= k; j++) add(h[cnt], h[X[j]], 1); //建边：源点 < 大的数 
}
```

其他部分跟最开始的暴力方法差不多，不过转移要改成 $a_y=\max(a_x+w)$。

##### 代码：

```cpp
#include<bits/stdc++.h>
#define int long long
#define N 1300006
using namespace std;
int read() {
	char ch = getchar(); int x = 0, f = 1;
	while(ch < '0' || ch > '9') { if(ch == '-') f = -1; ch = getchar(); }
	while(ch >= '0' && ch <= '9') x = x * 10 + ch - '0', ch = getchar();
	return x * f;
}
void write(int x) {
	if(x < 0) putchar('-'), x = -x;
	if(x > 9) write(x / 10);
	putchar('0' + x % 10);
}
int n, s, m, cnt, P;
int ans[N], X[N], d[N], o[N], h[N];
struct edge{
	int to, w; //w=0表示x<=to w=1表示x<to 
};
vector<edge>p[N];
void add(int u, int v, int w) {if(u == v && w == 0) return; p[u].push_back((edge){v, w}); d[v]++; }
void build(int u, int L, int R) {
	if(L == R) {
		h[L] = u;
		o[u] = L;
		P = max(P, u);
		return;
	}
	add(u * 2, u, 0);
	add(u * 2 + 1, u, 0);
	int mid = (L + R) / 2;
	build(u * 2, L, mid);
	build(u * 2 + 1, mid + 1, R);
}
void update(int u, int L, int R, int l, int r, int x, int w) {
	if(r < L || R < l) return;
	if(l <= L && R <= r) {
		add(u, h[x], w);
		return;
	}
	int mid = (L + R) / 2;
	update(u * 2, L, mid, l, r, x, w);
	update(u * 2 + 1, mid + 1, R, l, r, x, w);
}
int dfn[N], low[N], tot, ins[N], S[N], top;
void tarjan(int x) { //判断环 
	dfn[x] = low[x] = ++tot;
	S[++top] = x;
	ins[x] = 1;
	for(auto y : p[x]) {
		if(!dfn[y.to]) {
			tarjan(y.to);
			low[x] = min(low[x], low[y.to]);
		}
		else if(ins[y.to]) low[x] = min(low[x], dfn[y.to]);
	}
	if(low[x] == dfn[x]) {
		int num = 0;
	    while(1) {
		    int now = S[top];
		    top--;
		    num++;
		    ins[now] = 0;
		    if(now == x) break;
	    }
	    if(num > 1) {
	    	printf("NIE");
	    	exit(0);
		}
	}
}
int z[N];
bool G[N];
void Sort_On_Graph() {
	queue<int>Q;
	for(int i = 1; i <= P; i++) 
	    if(d[i] == 0) {
	    	Q.push(i);
	    	if(!G[o[i]]) z[i] = 1;
		}
	while(!Q.empty()) {
		int x = Q.front();
	    Q.pop();
		for(int i = 0; i < p[x].size(); i++) {
			int y = p[x][i].to;
			if(G[o[y]]) {
				if(z[x] + p[x][i].w > z[y]) { //不满足默认值,说明无解 
					printf("NIE");  
		            exit(0);
				}
			}
			else {
				if(z[y] != 0) z[y] = max(z[y], z[x] + p[x][i].w);
			    else z[y] = z[x] + p[x][i].w;
			}
			
			d[y]--;
			if(d[y] == 0) Q.push(y);
		} 
	}
} 
signed main() {
	n = read(), s = read(), m = read();
	build(1, 1, n + m);
	for(int i = 1, p, d; i <= s; i++) {
		p = read(), d = read();
		ans[p] = d;
		z[h[p]] = d; 
		G[p] = 1;
	}
	cnt = n;
	for(int i = 1, l, r, k; i <= m; i++) {
		l = read(), r = read(), k = read();
		cnt++; //对每个限制建立一个源点 
		int L = l, x;
		for(int j = 1; j <= k; j++) { //k把小的数分成了k+1段 
			X[j] = read();
			if(L <= X[j] - 1) update(1, 1, n + m, L, X[j] - 1, cnt, 0); //建边：小的数 <= 源点 
			L = X[j] + 1;
		}
		if(L <= r) update(1, 1, n + m, L, r, cnt, 0);
		for(int j = 1; j <= k; j++) add(h[cnt], h[X[j]], 1); //建边：源点 < 大的数 
	}
	for(int i = 1; i <= P; i++) {
		if(!dfn[i]) tarjan(i);
	}
	Sort_On_Graph();
	for(int i = 1; i <= n; i++) {
		if(z[h[i]] > 1e9) {
			printf("NIE");  
		    exit(0);
		}
	}
	printf("TAK\n");
	for(int i = 1; i <= n; i++) {
		write(z[h[i]]);
		printf(" ");
	}
	return 0;
}













```



---

## 作者：suxxsfe (赞：1)

# [P3588 【[POI2015]PUS】](https://www.luogu.com.cn/problem/P3588)  
终于有个能让我一遍过的题了，写篇题解纪念一下  
给定长度为n的序列和其中部分已知的数，还有m个大小关系：区间$[l,r]$中，有k个给定的数比剩下的$r-l+1-k$个数都大  
求是否有解，有解给出任意一个合法方案  
按大小关系，从大的数向小的数连边  
直接建图肯定不行，考虑用线段树优化，如果你不会线段树优化建边，点[这里](https://www.luogu.com.cn/blog/suxxsfe/xian-duan-shu-you-hua-jian-bian)  
对于每个$[l,r]$的区间，这k个给定的数会把区间分成$k+1$个小区间  
新建一个虚拟节点，这k个数分别向虚拟节点连边，这个虚拟节点再通过线段树向$k+1$个小区间连边  
&nbsp;  
有环会出现自己大于自己的情况，要先判掉  
再拓扑排序，求一种序列  
先把未给出的数赋值为1e9，然后对于每一条u->v的边，```a[v]=min(a[v],a[u]-len[i])```，```len[i]```为边权  
线段树中的边是虚构的只是为了让它联通起来，所以边权为0，实际的边边权为1，也就是```a[v]```至少比```a[u]```少1    
如果出现```a[v]```为给定的数，且```a[v]>a[u]-len[i]```，则找不出合法方案  
如果出现了```a[v]<0```的情况，超出题目要求的值域，无解  
剩下的在注释里  
```cpp  
#include<cstdio>
#include<algorithm>
#include<iostream>
#include<cmath>
#include<queue>
#include<iomanip>
#include<cstring>
#define R register
#define EN std::puts("")
#define LL long long
inline int read(){
	int x=0,y=1;
	char c=std::getchar();
	while(c<'0'||c>'9'){if(c=='-') y=0;c=std::getchar();}
	while(c>='0'&&c<='9'){x=x*10+(c^48);c=std::getchar();}
	return y?x:-x;
}
int n,s,m,nn;
int a[2000006],should[2000006];//should[i]=1，说明i号数字为给定的数字 
int in[2000006];
struct tr{
	tr *ls,*rs;
	int id;
}dizhi[2000006],*root=&dizhi[0];
int tot;
int fir[2000006],to[2000006],nex[2000006],len[2000006];
int etot;
int vis[2000006],instack[2000006];//vis标记是否被访问，instack标记是否在栈中 
int huan;//记录是否有环 
void dfs(int u){
	vis[u]=instack[u]=1;
	for(R int i=fir[u];i;i=nex[i]){
		if(instack[to[i]]) huan=1;//遇到已经在栈中节点，说明有环 
		if(!vis[to[i]]) dfs(to[i]);
	}
	instack[u]=0;
}
inline void add(int u,int v,int x){
	to[++etot]=v;len[etot]=x;
	nex[etot]=fir[u];fir[u]=etot;
}
void build(tr *tree,int l,int r){
	if(l==r){tree->id=l;return;}
	int mid=(l+r)>>1;
	tree->ls=&dizhi[++tot];tree->rs=&dizhi[++tot];
	build(tree->ls,l,mid);build(tree->rs,mid+1,r);
	tree->id=++nn;
//		std::printf("block %d %d   id:%d\n",l,r,tree->id);
	add(tree->id,tree->ls->id,0);add(tree->id,tree->rs->id,0);
	in[tree->ls->id]++;in[tree->rs->id]++;
}
void addtree(tr *tree,int l,int r,int ql,int qr,int u){
	if(ql<=l&&r<=qr){add(u,tree->id,0);in[tree->id]++;return;}//在由k个点向虚拟节点连边时建的边边权为1，所以这里要建边权为0的边
	int mid=(l+r)>>1;
	if(ql<=mid) addtree(tree->ls,l,mid,ql,qr,u);
	if(qr>mid) addtree(tree->rs,mid+1,r,ql,qr,u);
}
std::queue<int>q;
inline void topo(){
	for(R int i=1;i<=nn;i++) if(!a[i])a[i]=1e9;//先把为给定的数设为最大 
	for(R int i=1;i<=nn;i++) if(!in[i])q.push(i);
	while(!q.empty()){
		R int u=q.front();q.pop();
		for(R int i=fir[u];i;i=nex[i]){
			int v=to[i];
			if(should[v]){ 
				if(a[v]>a[u]-len[i]){std::puts("NIE");std::exit(0);}
			}
			else a[v]=std::min(a[v],a[u]-len[i]);
			if(a[v]<1){std::puts("NIE");std::exit(0);}//超出值域 
			if(!--in[v]) q.push(v);
		}
	}
}
int main(){
	nn=n=read();s=read();m=read();
	for(R int i=1;i<=s;i++){
		int pos=read();
		a[pos]=read();should[pos]=1;
	}
	build(root,1,n);
	while(m--){
		int l=read(),r=read(),k=read();nn++;
		R int last=l,x;
		for(R int j=1;j<=k;j++){
			x=read();
			add(x,nn,1);in[nn]++;
			if(x>last) addtree(root,1,n,last,x-1,nn);
			last=x+1;
		}
		if(last<=r) addtree(root,1,n,last,r,nn);
	}
	for(R int i=1;i<=n;i++)if(!vis[i]){
		huan=0;dfs(i);
		if(huan){std::puts("NIE");std::exit(0);}
	}
	topo();
	std::puts("TAK");
	for(R int i=1;i<=n;i++) std::printf("%d ",a[i]);
//		EN;
//		for(R int i=1;i<=nn;i++){
//			std::printf("%d:",i);
//			for(R int j=fir[i];j;j=nex[j]){
//				std::printf("(%d %d) ",to[j],len[j]);
//			}
//			EN;
//		}
	return 0;
}
```

---

## 作者：_JF_ (赞：0)

[Link](https://www.luogu.com.cn/problem/P3588)

~~独立切了，说话！~~

线段树优化建图不错的练习题。

首先对于 $x>y$ 条件，我们可以转化为 $y$ 向 $x$ 连一条边，把问题拍到图上解决。

然后我们考虑拓扑排序，钦定入度为 $0$ 为最小值 $1$，然后在拓扑的过程中赋值就行。

然后现在是怎么优化这个连边。

首先，对于一个询问里面，$k$ 个数把 $[l,r]$ 划分成 $k+1$ 个区间，这些区间里面的数都小于这 $k$ 个数。

表示区间的话线段树显然可以胜任，这样我们就把这些区间也都能看成点。

所以我们就直接把这些区间拍到线段树上面去，转成线段树的区间向这 $k$ 个点去连边。

但问题是现在边数还是很多。

考虑建立中转点，这是一个很经典的情况。有 $x$ 个点要和 $y$ 个点两两连边，且限制条件相同。因为“限制条件相同”，所以我们建立中转点 $p$，让 $x$ 个点连到 $p$，$p$ 连到 $y$ 个点即可。

你注意到这样做以后，$x$ 所有点 到 $y$ 所有点都是连通的。且共性“小于”的性质也能满足。

然后线段树因为我们是区间连向点，为了传递信息，我们线段树上连边向上连即可。

注意拓扑排序的时候，中转点连出去的边，传递到所连向的点时，要加 $1$。（题目要求大于。）

所以这样做以后一共至多是 $k\log n+k$ 个点的有关连边，拓扑排序也是线性的。

所以时间复杂度为 $O(k \log n)$。


```cpp
#include<bits/stdc++.h>
using namespace std;
const int N =4e6+10;
#define int long long
#define DEBUG cout<<"when can get npy"<<endl;
vector<int> g[N],G;
int n,lst,s,m,X[N],in[N],tot,id[N],Vus[N],Id[N],Re[N],a[N],Ans[N];
void Add(int u,int v){
	g[u].push_back(v),in[v]++;
}
void Tree_build(int s,int t,int p){
	tot++,id[p]=tot;
	if(s==t){
		if(a[s]!=0)	Vus[tot]=true;
		Id[s]=tot,Re[tot]=s;
		return ;
	}
	int mid=(s+t)>>1;
	Tree_build(s,mid,p<<1),Tree_build(mid+1,t,p<<1|1);
	Add(id[p<<1],id[p]),Add(id[p<<1|1],id[p]);
}
void Tree_Query(int l,int r,int s,int t,int p){
	if(l<=s&&t<=r){
		G.push_back(id[p]); return ;
	}
	int mid=(s+t)>>1;
	if(l<=mid)	Tree_Query(l,r,s,mid,p<<1);
	if(r>mid)	Tree_Query(l,r,mid+1,t,p<<1|1);
}
void Topo(){
	queue<int> q;
	int Dot=0;
	for(int i=1;i<=tot;i++){
		if(in[i]==0){
			Dot++,q.push(i);
			if(Vus[i]==false)	Ans[i]=1;
			else	Ans[i]=a[Re[i]];
		}
	}
	while(!q.empty()){
		int u=q.front(); q.pop();
		for(int i=0;i<g[u].size();i++){
			int v=g[u][i];
			if(Vus[v]==true){
				Ans[v]=a[Re[v]];
				if((u>lst&&Ans[v]<=Ans[u])||(u<=lst&&Ans[v]<Ans[u]))	cout<<"NIE"<<endl,exit(0);
			}
			else{	
				if(u>lst)	Ans[v]=max(Ans[v],Ans[u]+1);
				else	Ans[v]=max(Ans[v],Ans[u]);
			}
			in[v]--;
			if(in[v]==0)	Dot++,q.push(v);
		}
	}
	if(Dot!=tot)	cout<<"NIE"<<endl,exit(0);
	for(int i=1;i<=n;i++){
		if(Ans[Id[i]]>1000000000)	cout<<"NIE"<<endl,exit(0);
	}
	cout<<"TAK"<<endl;
	for(int i=1;i<=n;i++)	cout<<Ans[Id[i]]<<' ';
	cout<<endl;
}
signed main(){
	cin>>n>>s>>m;
	for(int i=1,p,d;i<=s;i++)	cin>>p>>d,a[p]=d;
	Tree_build(1,n,1),lst=tot;
	for(int i=1,l,r,k;i<=m;i++){
		cin>>l>>r>>k,G.clear();
		for(int j=1;j<=k;j++){
			cin>>X[j];
			if(X[j]-1-(X[j-1]+1)+1>=1&&j>1){
				int L=X[j-1]+1,R=X[j]-1;
				Tree_Query(L,R,1,n,1);
			}
		}
		if(X[1]>l)	Tree_Query(l,X[1]-1,1,n,1);
		if(X[k]<r)	Tree_Query(X[k]+1,r,1,n,1);	
		tot++;
//		cout<<"zhong"<<' '<<tot<<endl;
//		cout<<"Do:";
		for(int j=0;j<G.size();j++){
//			cout<<G[j]<<' ';
			Add(G[j],tot);
		}
//		cout<<endl;
//		cout<<"To:";
		for(int j=1;j<=k;j++){
//			cout<<Id[X[j]]<<' ';
			Add(tot,Id[X[j]]);
		}
//		cout<<endl;
	} 
	Topo();
	return 0;
}

```

---

## 作者：LJ26yanxingyu (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P3588)
## 题意
给出一个长度为 $n$ 的数列的一部分和一些大小关系（就是在区间 $l$ 到 $r$ 里，给 $k$ 个下标，这些下标上的数比区间其它数都大），并且每个数都在 $1$ 到 $10^9$ 之间，求出这个序列，或判断无解。
## 分析
首先我们可以先想到差分约束来求，但是时，空复杂度都会炸，为什么会炸呢，因为一个区间里每个 $x$ 都连了相同的很多个数，所以复杂度就炸了，对于相同的区间里的 $x$，我们可以拉一个中转点来降低时空复杂度，但是依然会炸，这时我们再看看 $\sum k$ 的范围，发现 $\sum k \leq 3 \times 10^5$，十分小，所以我们就可以用线段树优化建图来过这题，单次时间复杂度  $\log n$ 级别。
## 做法
将每段区间分成 $k$ 段向中转点连线，再向每个 $x$ 连线，再用拓扑排序 DP 来做，和 Dijkstra 算法差不多，如果跑完了都还有点没被遍历，就说明无解。
## 代码
```cpp
#include<bits/stdc++.h>
#define N 100005
#define ls (xu<<1)
#define rs (xu<<1|1)
#define mid ((l+r)>>1)

using namespace std;

//#define DEBUG 1  // 调试开关
struct IO {
#define MAXSIZE (1 << 20)
#define isdigit(x) (x >= '0' && x <= '9')
  char buf[MAXSIZE], *p1, *p2;
  char pbuf[MAXSIZE], *pp;
#if DEBUG
#else
  IO() : p1(buf), p2(buf), pp(pbuf) {}

  ~IO() { fwrite(pbuf, 1, pp - pbuf, stdout); }
#endif
  char gc() {
#if DEBUG  // 调试，可显示字符
    return getchar();
#endif
    if (p1 == p2) p2 = (p1 = buf) + fread(buf, 1, MAXSIZE, stdin);
    return p1 == p2 ? ' ' : *p1++;
  }
  bool blank(char ch) {
    return ch == ' ' || ch == '\n' || ch == '\r' || ch == '\t';
  }
  template <class T>
  void read(T &x) {
    double tmp = 1;
    bool sign = 0;
    x = 0;
    char ch = gc();
    for (; !isdigit(ch); ch = gc())
      if (ch == '-') sign = 1;
    for (; isdigit(ch); ch = gc()) x = x * 10 + (ch - '0');
    if (ch == '.')
      for (ch = gc(); isdigit(ch); ch = gc())
        tmp /= 10.0, x += tmp * (ch - '0');
    if (sign) x = -x;
  }
  void read(char *s) {
    char ch = gc();
    for (; blank(ch); ch = gc());
    for (; !blank(ch); ch = gc()) *s++ = ch;
    *s = 0;
  }
  void read(char &c) { for (c = gc(); blank(c); c = gc()); }
  void push(const char &c) {
#if DEBUG  // 调试，可显示字符
    putchar(c);
#else
    if (pp - pbuf == MAXSIZE) fwrite(pbuf, 1, MAXSIZE, stdout), pp = pbuf;
    *pp++ = c;
#endif
  }

  template <class T>
  void write(T x) {
    if (x < 0) x = -x, push('-');  // 负数输出
    static T sta[35];
    T top = 0;
    do {
      sta[top++] = x % 10, x /= 10;
    } while (x);
    while (top) push(sta[--top] + '0');
  }
  void write_s(string S_tr){
  	string::iterator it=S_tr.begin();
  	while(it!=S_tr.end())push(*it),++it;
  }

  template <class T>
  void write(T x, char lastChar) {
    write(x), push(lastChar);
  }
} io;

struct jie{int to,net,w;}e[N*75];
int hed[N*5],W=1;
int id[N],dis[N*5],du[N*5],vis[N*5],cctv[N*5];
int n,s,m,cnt,pre;
void _add(int a1,int b1,int c1){
	e[W]=(jie){b1,hed[a1],c1},hed[a1]=W++,du[b1]++;
	return;
}
void build(int l,int r,int xu){
	if(l==r){id[l]=xu; cnt=max(xu,cnt); return;}
	build(l,mid,ls),build(mid+1,r,rs);
	_add(xu,ls,0),_add(xu,rs,0); return;
}
void ADD(int aa,int L,int R,int l,int r,int xu){
	if(L<=l&&r<=R){_add(aa,xu,0); return;}
	if(L<=mid)ADD(aa,L,R,l,mid,ls);
	if(R>mid)ADD(aa,L,R,mid+1,r,rs);
	return;
}
queue<int> q;
void topu(){
	for(int i=1;i<=cnt;i++){
		if(!cctv[i])dis[i]=1e9;
		else dis[i]=cctv[i];
		if(du[i]==0)q.push(i);
	}
	while(!q.empty()){
		int now=q.front();
		q.pop(),vis[now]=1;
		for(int j=hed[now];j;j=e[j].net){
			int y=e[j].to,d=e[j].w;
			dis[y]=min(dis[now]+d,dis[y]);
			if(cctv[y]&&dis[y]<cctv[y]){
				io.write_s("NIE"),exit(0);
			}
			du[y]--;
			if(!du[y])q.push(y);
		}
	}
	for(int i=1;i<=cnt;i++)if(!vis[i]||dis[i]<1){
		io.write_s("NIE"),exit(0);
	}
	return;
}

int main(){
	io.read(n),io.read(s),io.read(m);
	build(1,n,1);
	for(int i=1,p,o;i<=s;i++){
		io.read(p),io.read(o),cctv[id[p]]=o;
	}
	for(int i=1,l,r,k;i<=m;i++){
		io.read(l),io.read(r),io.read(k);
		cnt++,pre=l;
		for(int j=1,x;j<=k;j++){
			io.read(x);
			_add(id[x],cnt,-1);
			if(x>pre)ADD(cnt,pre,x-1,1,n,1);
			pre=x+1;
		}
		if(pre<=r)ADD(cnt,pre,r,1,n,1);
	}
	topu();
	io.write_s("TAK\n");
	for(int i=1;i<=n;i++){
		if(!cctv[id[i]])io.write(dis[id[i]],' ');
		else io.write(cctv[id[i]],' ');
	}
	return 0;
}
``````

---

## 作者：Forg1weN (赞：0)

## [P3588 [POI2015] PUS](https://www.luogu.com.cn/problem/P3588)

考虑条件的对应关系，其相当于是一串大于的传递关系，如果这个传递关系出现了环，则说明无解。

这样的话，便考虑转化成图论问题，将若干个数大于另外若干个数转化成单向边，但是这样子边的复杂度是 $O(N^2)$ 量级的，于是考虑优化，观察到 $k$ 很小，而且需要的是点之间的关系，根据优化建图的理论，建立虚点与 $k$ 的关系，然后再用虚点连向对应点。

具体而言，考虑这个大于关系有点难转化，可能要把一些未知点赋值成无限大，但显然把未知点赋值为 $1$ 更好想。于是转化问题成 $u\rightarrow v$ 表示 $u$ 的权值比 $v$ 小。于是建立出树（其边权为 $0$），对于 $m$ 个条件建立虚点，虚点分别向 $k$ 个点连边，其余 $r-l+1-k$ 个点最多有 $k+1$ 个区间连向虚点，为了体现严格关系，钦定虚点的出边有边权 $1$。

然后跑拓扑排序，$f_i$ 记为其可能的最大值，因为 $i$ 的入边 $u\rightarrow i$ 表示 $u$ 的点权严格小于 $v$。$known_i$ 表示其点权是否已知，不合法的情况即 $f_u+w>f_i$ 且 $known_i=1$ 或者 $f_i>10^9$。

空间复杂度 $O((N+M)\log N)$，时间复杂度$O((N+\sum k)\log N)$。

## code
```cpp
#include<bits/stdc++.h>
using namespace std;
#define lson (now<<1)
#define rson (now<<1|1)
#define mid ((l+r)>>1)
const int maxn=1e6;
int n,s,m,cnt;
int du[maxn],f[maxn],id[maxn],rd[maxn],known[maxn];
struct node { int v,w; };
vector<node>ad[maxn];
struct TREE {
	void build(int now,int l,int r) {
		cnt=max(cnt,now);
		if(l==r) { id[l]=now;return; }
		build(lson,l,mid);
		build(rson,mid+1,r);
		ad[lson].push_back({now,0}),du[now]++;
		ad[rson].push_back({now,0}),du[now]++;
	}
	void update(int now,int l,int r,int x,int y,int z) {
		if(x<=l&&r<=y) {
			ad[now].push_back({z,0}),du[z]++;
			return;
		}
		if(x<=mid)update(lson,l,mid,x,y,z);
		if(mid<y)update(rson,mid+1,r,x,y,z);
	}
}t;
bool topo() {
	queue<int>Q;
	for(int i=1;i<=cnt;i++)
		if(!du[i])Q.push(i),f[i]=(known[i]?f[i]:1);
	while(!Q.empty()) {
		int u=Q.front();
		Q.pop();
		for(auto i:ad[u]) {
			int v=i.v,w=i.w;
			if(known[v]&&f[u]+w>f[v])return 0;
			f[v]=max(f[v],f[u]+w);
			du[v]--;
			if(!du[v])Q.push(v);
		}
	}
	for(int i=1;i<=n;i++)if(f[id[i]]>1000000000)return 0;
	for(int i=1;i<=cnt;i++)if(du[i])return 0;
	return 1;
}
int main() {
	scanf("%d%d%d",&n,&s,&m);
	t.build(1,1,n);
	for(int i=1;i<=s;i++) {
		int pos,x;
		scanf("%d%d",&pos,&x);
		f[id[pos]]=x,known[id[pos]]=1;
	}
	for(int i=1;i<=m;i++) {
		int l,r,k;
		scanf("%d%d%d",&l,&r,&k);
		++cnt;
		for(int j=1;j<=k;j++) {
			scanf("%d",&rd[j]);
			ad[cnt].push_back({id[rd[j]],1}),du[id[rd[j]]]++;
		}
		int L=l;
		for(int j=1;j<=k;j++) {
			if(L<rd[j]) t.update(1,1,n,L,rd[j]-1,cnt),L=rd[j]+1;
			if(L==rd[j]) {L++;continue;}
		}
		if(L<=r)t.update(1,1,n,L,r,cnt);
	}
	bool pd=topo();
	printf(pd?"TAK\n":"NIE");
	if(pd)for(int i=1;i<=n;i++)printf("%d ",f[id[i]]);
	return 0;
}
```


---


# [APIO2013] 机器人

## 题目描述

VRI（Voltron 机器人学会）的工程师建造了 n 个机器人。任意两个兼容的机 器人站在同一个格子时可以合并为一个复合机器人。

我们把机器人用 1 至 n 编号（n ≤ 9）。如果两个机器人的编号是连续的，那 么它们是兼容的，可以合并成一个复合机器人。最初这 n 个机器人各自都只有唯 一的编号。而一个由两个或以上的机器人合并构成的复合机器人拥有两个编号， 分别是构成它的所有机器人中最小和最大的编号。

例如，2 号机器人只可以与 1 号或 3 号机器人合并。若 2 号机器人与 3 号机 器人合并，可构成编号为 2-3 的复合机器人。如果编号为 2-3 的复合机器人与编 号为 4-6 的复合机器人合并，可构成编号为 2-6 的复合机器人。当所有机器人合 并以后则构成 1-n 复合机器人。

工程师把这 n 个机器人放在了一个封闭的房间中，房间四周均是墙。该房间 被划分成 w × h 个方格。有些方格有障碍物，机器人不可经过或停留；其余方格 允许多个机器人停留，同时允许机器人经过。任何时候一个机器人只占用一个方 格。初始时刻，所有机器人均在不同的方格中。

这些原始的机器人不会自发地移动。它们只有被工程师沿 x 轴或 y 轴推动 后，才会沿推动的方向不断向前直线移动，直至碰到障碍物或墙停止移动。停止 移动后，它会扫描当前的格子是否存在可以与它合并的机器人，如果有，则合并 并继续检查，直至不能再合并为止。工程师只能沿水平向左、水平向右、竖直向 上、竖直向下四个方向推动机器人，并且，在机器人尚未停止移动时，不允许推 动其它机器人，因此任何时刻，房间中都只能有一个机器人移动。

为了帮助机器人转向，工程师在一些格子中放置了转向器。具体地说，转向 器分为顺时针转向器（右转器）和逆时针转向器（左转器），顺时针转向器可以 使到达该格子的机器人沿顺时针方向转向 90°；逆时针转向器可以使到达该格 子的机器人沿逆时针方向转向 90°。

现在，我们将告诉你初始时刻房间内的信息。请你计算工程师最少共计需要 推动机器人多少次，才能把所有的 n 个机器人全部合并（如果可能的话）。


## 说明/提示

第一步：向右推动 3 号机器人，当它碰到转向器后会向上继续移动，直至碰 到墙壁停止移动。

第二步：向上推动 4 号机器人，当它碰到墙壁后停止移动，与 3 号机器人合 并，构成 3-4 号机器人

第三步：向上推动 2 号机器人，当它碰到转向器后会向左移动，由于左侧为 墙壁，故停留在原地。

第四步：向右推动 2 号机器人，由于它在一个转向器上，故它会向上移动， 直至碰到墙壁停止移动，与 1 号机器人合并，构成 1-2 号机器人。

第五步：向左推动 3-4 号机器人，当它碰到墙壁后停止移动，与 1-2 号机器 人合并，构成 1-4 号机器人。


我们将使用以下 4 类输入测例测试你的程序。

1. （10 分）测例满足 n = 2，w ≤ 10 且 h ≤ 10，没有任何转向器。

2. （20 分）测例满足 n = 2，w ≤ 10 且 h ≤ 10。

3. （30 分）测例满足 n ≤ 9，w ≤ 300 且 h ≤ 300。

4. （40 分）测例满足 n ≤ 9，w ≤ 500 且 h ≤ 500。


## 样例 #1

### 输入

```
4 10 5 
1.........
AA...x4...
..A..x....
2....x....
..C.3.A...```

### 输出

```
5```

# 题解

## 作者：shadowice1984 (赞：10)

我也不知道为什么随手写了一下就抢了这题的rk1……

~~拒绝stl的队列从我做起~~

为了方便起见我们认为$(-1,0),(0,1),(1,0),(0,-1)$这四个方向的标号分别为$0,1,2,3$

首先我们设$dp(i,j,k)$ 表示在$i,j$点按照k这个方向踹一脚机器人这个机器人会跑到什么地方去

那么这个东西还是比较好转移的，直接递归下去记忆化搜索就可以了

但是我们可能需要注意两个点，第一点就是如果$(i+dx(k),j+dy(k))$这个点是墙或者障碍物的话我们需要将$dp(i,j,k)$设为$num(i,j)$意思就是说这个机器人不会动了

另外一点就是环，我们在记忆化搜索的时候记录一下什么状态被压在了栈里，如果我们发现我们访问了一个栈内的元素,那么将这个栈内的元素的dp值置为$-1$，注意这里一定要和墙的标号区别开，不然会导致一些奇奇怪怪的错误

好了那么假设我们处理出了这个dp数组，现在我们就可以建出一张图来了~

然后我们发现这个问题十分的像斯坦纳树问题，只是我们不是状压dp而是区间dp了

具体点来讲我们设$dp(i,j,k)$表示$(i,j)$这个复合机器人出现在$k$点的最小代价

那么层外转移就是向区间dp一样的枚举分割点mid进行转移

$$dp(i,j,k)=\min_{mid=l}^{r-1}(dp(i,mid,k)+dp(mid+1,r,k))$$

然后层内的转移我们发现似乎满足三角不等式(其中$k.alist$表示点k的出边集合)

$$dp(i,j,k) \leq min_{v\in k.alist}dp(i,j,v)+1$$

不过此时似乎转移是带环的……

那么一般斯坦树的套路就是用spfa进行转移……

不过这里不知道为什么spfa会tle，所以我们需要一些比较nb一点的剪枝，不然过不去

具体点来讲我们开两个队列，一个存一开始的点，并且这个队列中点是排好序的，排序这里建议手写计数排序，会快一点，另一个队列存需要去松弛别的点的点

然后每次取队头的时候去两个点中dis值较小的那个去松弛，加上这个玄学剪枝之后我们的spfa就跑的飞起了，然后就不用担心tle了~

然后这题并没有你想的那么毒瘤，注意实现方式的话还是很好写的~

上代码~

```C
// luogu-judger-enable-o2
#include<cstdio>
#include<algorithm>
using namespace std;const int N=520;const int E=4*1e6+10;const int M=12;
int dx[4]={-1,0,1,0};int dy[4]={0,1,0,-1};
bool book[N][N][4];int dp[N][N][4];int tr[N][N];int ctt;int n;int w;int h;
int v[4*N*N];int x[4*N*N];int ct;int al[N*N];char mp[N][N];
inline void add(int u,int V){v[++ct]=V;x[ct]=al[u];al[u]=ct;}
inline int dfs(const int& x,const int& y,const int& tw)//记忆化搜索
{
    if(book[x][y][tw]){return dp[x][y][tw]=-1;}
    if(dp[x][y][tw]!=-2)return dp[x][y][tw];
    book[x][y][tw]=true;int tx=x+dx[tw];int ty=y+dy[tw];
    switch(mp[tx][ty])
    {
        case 'x':{dp[x][y][tw]=tr[x][y];break;}
        case 'A':{dp[x][y][tw]=dfs(tx,ty,(tw+3)%4);break;}
        case 'C':{dp[x][y][tw]=dfs(tx,ty,(tw+1)%4);break;}
        default:{dp[x][y][tw]=dfs(tx,ty,tw);break;}
    }book[x][y][tw]=false;return dp[x][y][tw];
}int sum[N*N];int q1[N*N];int q2[E];bool inq[N*N];int hd;int tl;int dis[M][M][N*N];
inline void rixs(int* dis)//计数排序
{
    int mx=0;for(int i=1;i<=ctt;i++)if(dis[i]<0x3f3f3f3f)mx=max(mx,dis[i]);
    for(int i=1;i<=ctt;i++)if(dis[i]<0x3f3f3f3f)sum[dis[i]]++;
    for(int i=1;i<=mx;i++)sum[i]+=sum[i-1];
    for(int i=ctt;i>=1;i--)if(dis[i]<0x3f3f3f3f)q1[sum[dis[i]]--]=i;
    for(int i=1;i<=ctt;i++)if(dis[i]<0x3f3f3f3f)inq[i]=true;
    for(int i=0;i<=mx;i++)sum[i]=0;
}
inline void ex_spfa(int* dis)//spfa
{
    rixs(dis);int cur=1;int hd=1;int tl=0;
    while((cur<=ctt)||(hd<=tl))
    {
        int nw=0x3f3f3f3f;
        if((cur<=ctt)&&(hd>tl||dis[q1[cur]]<=dis[q2[hd]]))nw=q1[cur],cur++;
        else nw=q2[hd],hd++;inq[nw]=false;
        for(int i=al[nw];i;i=x[i])
            if(dis[v[i]]>dis[nw]+1){dis[v[i]]=dis[nw]+1;if(!inq[v[i]])inq[v[i]]=true,q2[++tl]=v[i];}
    }
}
int main()
{
    scanf("%d%d%d",&n,&w,&h);
    for(int i=1;i<=h;i++)scanf("%s",mp[i]+1);
    for(int i=1;i<=h;i++)//各种初始化~
        for(int j=1;j<=w;j++)if(mp[i][j]!='x')tr[i][j]=++ctt;
    for(int j=0;j<=w+1;j++)mp[0][j]='x';for(int j=0;j<=w+1;j++)mp[h+1][j]='x';
    for(int i=0;i<=h+1;i++)mp[i][0]='x';for(int i=0;i<=h+1;i++)mp[i][w+1]='x';
    for(int i=1;i<=h;i++)
        for(int j=1;j<=w;j++)for(int k=0;k<4;k++)dp[i][j][k]=-2;
    for(int i=1;i<=h;i++)
        for(int j=1;j<=w;j++)if(mp[i][j]!='x')for(int k=0;k<4;k++)dfs(i,j,k);
    for(int i=1;i<=h;i++)
        for(int j=1;j<=w;j++)
            if(mp[i][j]!='x')for(int k=0;k<4;k++)
                if(dp[i][j][k]!=-1&&dp[i][j][k]!=tr[i][j])add(tr[i][j],dp[i][j][k]);
    for(int i=1;i<=n;i++)
        for(int j=i;j<=n;j++)for(int k=1;k<=ctt;k++)dis[i][j][k]=0x3f3f3f3f;
    for(int i=1;i<=h;i++)
        for(int j=1;j<=w;j++)
            if('0'<mp[i][j]&&mp[i][j]<='9'){int t=mp[i][j]-'0';dis[t][t][tr[i][j]]=0;}
    for(int len=1;len<=n;len++)
        for(int l=1,r=l+len-1;r<=n;l++,r++)//dp
        {
            for(int mid=l;mid<r;mid++)
                for(int k=1;k<=ctt;k++)dis[l][r][k]=min(dis[l][r][k],dis[l][mid][k]+dis[mid+1][r][k]);
            ex_spfa(dis[l][r]);
        }int ans=0x3f3f3f3f;
    for(int i=1;i<=ctt;i++)ans=min(ans,dis[1][n][i]);printf("%d",(ans==0x3f3f3f3f)?-1:ans);//拜拜程序~
}

```


---

## 作者：约瑟夫用脑玩 (赞：8)

# P3638 [APIO2013]机器人

#### 简易题意：

给定一个带障碍网格图以及 $n$ 个顺次编号机器人，每次将一个机器人推向某个方向知道碰到墙或障碍才会停止，如果碰到了转向器(不算障碍)，会转向继续前进。在停下后若有编号相邻的，则将两个机器人合并，新编号为最小的编号与最大的编号。同一时刻只能有一个机器人移动，求最小推动次数使所有机器人合并。（好长啊，累死我了）

数据范围：测例满足 $n \leq 9$，$w \leq 500$ 且 $h \leq 500$。

#### 分析：

局面很大，不能直接作为状态转移着走，容易发现每个机器人的状态是独立的，即与整个局面无关，故分开考虑。

那么分为 $n$ 个分层图，每个分层图代表一个机器人编号为 $i \in [1,n]$ 的转移。

但由于机器人会合并，合并了还是一样的走，所以对于每个合并了的机器人也应单独有一层转移。

那么重新定义每一层，每个分层图代表一个机器人编号为 $(l,r) $ ，将初始的机器人 $i$ 看做 $(i,i) $ ，其中 $l \leq r$ 且 $l,r \in [1,n]$ 的转移，故总共有 $\binom{n}{2}$ 层。

先考虑分层图内的转移，容易发现每个位置往某个方向推一次后停下的位置是固定的，直接预处理出来，注意判环即可，对于每个分层图只有一个机器人，那么就可以直接用最短路转移到其他位置了。

而对于分层图间的转移，显然可以看出 $(l,r) $ 的分层图可以由 $mid \in [l,r)$ ， $(l,mid) $ 以及 $(mid+1,r) $ 两层中的相同位置转移过来。

最后一层不用跑，因为推了步数一定增加，直接检查当前局面最小即为答案。

在此给出 $\texttt{Dijkstra}$ 的代码，容易理解，但由于并不优秀的常数会**T**飞。

#### 代码：

```cpp
inline int Get(int &x,int &y) {
	if(fl[nxt[x][y]]==-1) {
		return 0;
	}
	if(vis[x][y]&&~fl[nxt[nxt[x][y]][flg[x][y]]]) {
		return 1;
	}
	vis[x][y]=1;
	if(Get(nxt[x][y],flg[x][y])) {
		x=0;
		y=flg[x][y];
		return 1;
	}
	int tpx=nxt[x][y],tpy=flg[x][y];
	x=tpx;
	y=tpy;
	return 0;
}
inline void Mrg(int l,int mid,int r) {
	int now;
	for(now=1; now<=al; now++) {
		if(~F[l][mid][now]&&~F[mid+1][r][now]) {
			if(~F[l][r][now]) {
				ckmn(F[l][r][now],F[l][mid][now]+F[mid+1][r][now]);
			} else {
				F[l][r][now]=F[l][mid][now]+F[mid+1][r][now];
			}
		}
	}
}
inline void Upd(int l,int r) {//Dij
	int i,k,mn=INT_MAX,now;
	for(now=1; now<=al; now++) {
		vst[now]=0;
		if(~F[l][r][now]) {
			ckmn(mn,F[l][r][now]);
			q.push(mkp(-F[l][r][now],now));
		}
	}
	if(l==1&&r==n) {
		ans=mn==INT_MAX?-1:mn;
		return;
	}
	while(!q.empty()) {
		now=s(q.top());
		q.pop();
		if(vst[now]) {
			continue;
		}
		vst[now]=1;
		for(i=0; i<4; i++) {
			k=nxt[now][i];
			if(~fl[k]&&(F[l][r][k]==-1||F[l][r][k]>F[l][r][now]+1)) {
				q.push(mkp(-(F[l][r][k]=F[l][r][now]+1),k));
			}
		}
	}
}
signed main() {
	int i,j,k,tp,now;
	n=read();
	C=read();
	R=read();
	al=R*C;
	for(memset(fl,-1,sizeof(fl)),i=1; i<=R; i++) {
		for(j=1; j<=C; j++) {
			now=ps(i,j);
			fl[now]=gt();
			if(fl[now]==-1) {
				continue;
			}
			if(1<=fl[now]&&fl[now]<=9) {
				psx[fl[now]]=i;
				psy[fl[now]]=j;
				fl[now]=0;
			}//urdl
			tp=ps(i-1,j);
			nxt[now][0]=tp;
			nxt[tp][2]=now;
			tp=ps(i,j-1);
			nxt[now][3]=tp;
			nxt[tp][1]=now;
			for(k=0; k<4; k++) {
				flg[now][k]=k;
			}
		}
	}//one
	for(now=1; now<=al; now++) {
		if(~fl[now]&&fl[now]) {
			if(fl[now]-10) { //C
				tp=nxt[now][0];
				for(k=0; k<3; k++) {
					flg[now][k]=k+1;
					nxt[now][k]=nxt[now][k+1];
				}
				flg[now][3]=0;
				nxt[now][3]=tp;
			} else { //A
				tp=nxt[now][3];
				for(k=3; k; k--) {
					flg[now][k]=k-1;
					nxt[now][k]=nxt[now][k-1];
				}
				flg[now][0]=3;
				nxt[now][0]=tp;
			}
		}
	}//cng
	for(now=1; now<=al; now++) {
		if(~fl[now]) {
			for(k=0; k<4; k++) {
				int tpnw=now,tpk=k;
				Get(tpnw,tpk);
			}
		}
	}//all
	for(tp=0,memset(F,-1,sizeof(F)),i=n; i; i--) {
		for(F[i][i][ps(psx[i],psy[i])]=0,j=i; j<=n; j++) {
			for(k=i; k<j; k++) {
				Mrg(i,k,j);
			}
			Upd(i,j);
		}
	}
	writenum(ans,10);
	return output;
}//two samples
/*
4 10 5
1.........
AA...x4...
..A..x....
2....x....
..C.3.A...
*/
/*
0 2 2
AA
AA
*/
```

首先这里的复杂度还有点大，而且这道题略卡常，在此介绍一下这道题的优化&卡常小技巧。

1. 使内存连续。容易发现分层图的数组是 $F[big][small][small]​$ 的形式，调整顺序 $F[small][small][big]​$ 后能快2~4倍。

2. 用 $\texttt{Dijkstra}$ 不如 $\texttt{Spfa}$ (大雾)。由于初始状态较多故 $\texttt{Dijkstra}$ 的 $O(m log m)$ 就可能被卡得较满，而 $\texttt{Spfa}$ 就可能为优秀。这样的条件显然是不足以让某已死算法超过 $\texttt{Dijkstra}$ 的，更进一 步的优化，引用[shadowice1984](https://www.luogu.com.cn/user/56384)的话：

   具体点来讲我们开两个队列，一个存一开始的点，并且这个队列中点是排好序的，排序这里建议手写计数排序，会快一点，另一个队列存需要去松弛别的点的点

   然后每次取队头的时候去两个点中dis值较小的那个去松弛，加上这个玄学剪枝之后我们的 $\texttt{Spfa}$ 就跑的飞起了，然后就不用担心 $Tle$ 了~

那么我们来仔细的思考一下这个东西到底变成了什么，由于边权为1，不太显然但你意会、细品能品出来地，这是个 $\texttt{BFS}$ 于是复杂度成功地由 $O(72*mlogm)$ 变为了 $O(72*n)$。

```cpp
inline int GetMx(int *a,int l,int r,int *ds) {
	int i,mx=0;
	for(i=l; i<=r; i++) {
		ckmx(mx,ds[a[i]]);
	}
	return mx;
}
inline void J_sort(int *a,int l,int r,int mx,int *ds) {//js_sort
	int i;
	for(i=l; i<=r; i++) {
		num[ds[a[i]]]++;
	}
	for(i=1; i<=mx; i++) {
		num[i]+=num[i-1];
	}
	for(i=r; i>=l; i--) {
		tpp[num[ds[a[i]]]--]=a[i];
	}
	for(i=l; i<=r; i++) {
		a[i]=tpp[i];
	}
	for(i=0; i<=mx; i++) {
		num[i]=0;
	}
}
inline void Upd(int l,int r,int *ds) {//Spfa
	int i,k,mn=INT_MAX,now,fst;
	for(tot=0,now=1; now<=al; now++) {
		vst[now]=0;
		if(~ds[now]) {
			ckmn(mn,ds[now]);
			vst[now]=1;
			tmp[++tot]=now;
		}
	}
	if(l==1&&r==n) {
		ans=mn==INT_MAX?-1:mn;
		return;
	}
	J_sort(tmp,fst=1,tot,GetMx(tmp,1,tot,ds),ds);
	while(fst<=tot||!q.empty()) {
		now=(q.empty()||(fst<=tot&&ds[tmp[fst]]<ds[q.front()])?tmp[fst++]:(k=q.front(),q.pop_front(),k));
		vst[now]=0;
		for(i=0; i<4; i++) {
			k=nxt[now][i];
			if(~fl[k]&&(ds[k]==-1||ds[k]>ds[now]+1)) {
				ds[k]=ds[now]+1;
				if(!vst[k]) {
					if(q.empty()||ds[k]>ds[q.front()]) {
						q.push_back(k);
					} else {
						q.push_front(k);
					}
					vst[k]=1;
				}
			}
		}
	}
}
```

#### 回顾：

$Q:$ 这道题到底是个什么东西？

$A:$ 其实是斯坦纳树的魔改，想象一个斯坦纳树模板，出题人强行将状态连续起来了，由状压 $\texttt{DP}$ 变成了一个区间 $\texttt{DP}$ ，状态就只需 $l,r$ 两个编号就能表示了，所以你发现分层图+最短路转移的思路和斯坦纳树的一模一样，仅仅在于状态间转移不同。

$Q:$ 做这道题有什么用？

$A:$ 提高奇怪的题目分析并学习奇怪的优化方法。

$Upd:$ 补了一下 $\LaTeX$，增添了对于 $\texttt{Spfa}$ 优化的分析。

---

## 作者：loverintime (赞：3)

首先， 令 $g(i,j,k)$ 表示把机器人从 $(i,j)$ 这个点向 $k$ 方向退一下最终会到哪里 $k=0,1,2,3 $ 分别表示上、 右、 下、 左

可以用记忆化搜索求出

因为题中说 “如果两个机器人的编号是连续的，那 么它们是兼容的，可以合并成一个复合机器人。” 我们可以得出组成复合机器人的机器人是一段区间。 于是， 令 $f(l,r,i,j)$ 表示区间 $[l,r]$ 中的机器人组成的复合机器人在点 $(i,j)$ 时的最小步数。 

转移分两种：
#### 1. 这个复合机器人由两个机器人合并而成

$f(l,r,i,j)=\min_{mid\in [l,r-1]}\{f(l,mid,i,j)+f(mid+1,r,i,j)\}$

这个部分直接转移即可

#### 2. 这个复合机器人从另一个地方推过来

$f(l,r,i,j)=\min_{g(i',j',k)=(i,j),k\in [0,3]} \{f(l,r,i',j') \}$

这一部分我们用改版的 $bfs$ 解决：

在步骤 1 转移完成后， 将所有满足条件的点 $(i,j)$ 放进一个队列中， 将队列中的元素按照步数排序， 更新出来的点放进另外一个队列， 每次取出两个队列的队首步数最小的那一个，对其往四个方向扩展， 加入第二个队列。

接下来是优化。


~~其实这道题不需要手写队列和排序，吸氧就过了~~

这里还是建议手写队列和计数排序， 可以优化常数。

## Code:
```cpp
#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;
typedef pair<int, int> pr;
const int N = 502, inf = 0x3f3f3f3f;
const int dx[4] = { -1, 0, 1, 0 }, dy[4] = { 0, -1, 0, 1 };
int T, n, m, f[10][10][N][N], L_, R_;
char mp[N][N];
pr a[N], mem[N][N][4], gto[N][N][4];
bool vis[N][N][4], used[N][N];
pr dfs(int x, int y, int k) {
    if (mem[x][y][k].first >= 0)
        return mem[x][y][k];
    if (vis[x][y][k])
        return mem[x][y][k] = pr(0, 0);
    vis[x][y][k] = 1;

    int k_ = (mp[x][y] == 'A') ? (k + 1) % 4 : ((mp[x][y] == 'C') ? (k + 3) % 4 : k);
    int x_ = x + dx[k_], y_ = y + dy[k_];
    if (x_ < 1 || x_ > m || y_ < 1 || y_ > n || mp[x_][y_] == 'x')
        mem[x][y][k] = pr(x, y);
    else
        mem[x][y][k] = dfs(x_, y_, k_);
    vis[x][y][k] = 0;
    return mem[x][y][k];
}
class Pair_Queue {
protected:
    int head, tail, tms[N * N], st, ed;
    pr q[N * N], cts[N * N];

public:
    void init() { memset(tms, 0, sizeof tms); }
    inline void reset() { head = 1, tail = 0; }
    inline bool empty() { return tail < head; }
    inline void push(int k, int h) { q[++tail] = pr(k, h); }
    inline pr front() { return q[head]; }
    inline void pop() { head++; }
#define dis(k) (f[L_][R_][(k).first][(k).second])
    inline void countsort() {
        st = inf, ed = 0;
        for (int i = head, val; val = dis(q[i]), i <= tail; i++)
            cts[i] = q[i], st = min(st, val), ed = max(ed, val), tms[val]++;
        for (int i = st + 1; i <= ed; i++) tms[i] += tms[i - 1];
        for (int i = head; i <= tail; i++) q[tms[dis(cts[i])]--] = cts[i];
        for (int i = st; i <= ed; i++) tms[i] = 0;
    }
#undef dis
} q1, q2;
void bfs(int l, int r) {
    q1.reset(), q2.reset(), L_ = l, R_ = r;
    for (int i = 1; i <= m; i++)
        for (int j = 1; j <= n; j++)
            if (f[l][r][i][j] < inf)
                q1.push(i, j);
    if (q1.empty())
        return;
    memset(used, 0, sizeof used), q1.countsort();
    pr u;
#define dis(k) (f[l][r][(k).first][(k).second])
#define use(k) (used[(k).first][(k).second])
    for (int x, y, x_, y_; !q1.empty() || !q2.empty();) {
        if (q1.empty())
            u = q2.front(), q2.pop();
        else if (q2.empty())
            u = q1.front(), q1.pop();
        else if (dis(q1.front()) < dis(q2.front()))
            u = q1.front(), q1.pop();
        else
            u = q2.front(), q2.pop();
        x = u.first, y = u.second, used[x][y] = 1;
        for (int o = 0; o < 4; o++) {
            x_ = gto[x][y][o].first, y_ = gto[x][y][o].second;
            if (!(x_ < 1 || x_ > m || y_ < 1 || y_ > n || mp[x_][y_] == 'x') &&
                f[l][r][x][y] + 1 < f[l][r][x_][y_])
                f[l][r][x_][y_] = f[l][r][x][y] + 1, used[x_][y_] = 1, q2.push(x_, y_);
        }
        while (!q1.empty() && use(q1.front())) q1.pop();
    }
}
int main() {
    memset(mem, -1, sizeof(mem));
    scanf("%d%d%d", &T, &n, &m), memset(f, 0x3f, sizeof f), q1.init(), q2.init();
    char ch = getchar();
    for (int i = 1, k; i <= m; i++) {
        while (!(('0' <= ch && ch <= '9') || ch == '.' || ch == 'x' || ch == 'A' || ch == 'C'))
            ch = getchar();
        for (int j = 1; j <= n; j++) {
            mp[i][j] = ch, ch = getchar();
            if ('0' <= mp[i][j] && mp[i][j] <= '9')
                a[k = mp[i][j] - '0'] = pr(i, j), f[k][k][i][j] = 0;
        }
    }
    for (int i = 1; i <= m; i++)
        for (int j = 1; j <= n; j++)
            if (mp[i][j] != 'x')
                for (int k = 0; k < 4; k++) gto[i][j][k] = dfs(i, j, k);
    for (int len = 1; len <= T; len++)
        for (int l, r = T; l = r - len + 1, l; r--) {
            for (int mid = l; mid < r; mid++)
                for (int x = 1; x <= m; x++)
                    for (int y = 1; y <= n; y++)
                        f[l][r][x][y] = min(f[l][r][x][y], f[l][mid][x][y] + f[mid + 1][r][x][y]);
            bfs(l, r);
        }
    int ans = inf;
    for (int x = 1; x <= m; x++)
        for (int y = 1; y <= n; y++) ans = min(ans, f[1][T][x][y]);
    printf("%d\n", ans < inf ? ans : -1);
    return 0;
}

---

## 作者：FreeTimeLove (赞：2)

首先可以发现在一个位置向一个方向走**一步**的后继位置是唯一的，因此考虑使用记忆化搜索求出每个位置走一步可以到达的位置。

问题转化为一个边权为 $1$ 的有向图中使所有机器人合并的最小代价。这实质上是最小斯坦纳树模板加上**编号相邻合并**的限制，将原有的状压 DP 改为区间 DP 即可求出答案。转移方程：

$$
f(l,r,i)=\min_{1\le j\le n}\{f(l,r,j)+1\}
$$
$$
f(l,r,i)=\min_{l\le x<r}\{f(l,x,i)+f(x+1,r,i)\}
$$

由于边权全为 $1$，使用 bfs 更新第一条即可。

设 $n$ 为矩形的长宽，$K$ 为机器人个数，则时间复杂度为 $O(K^3n^2)$。

### code

```cpp
/*FreeTimeLove's code.
Love has a nasty habit of disappearing over night.*/
#include<bits/stdc++.h>
namespace chiptune{
#define ll long long
#define LD long double
#define i7 __int128
#define re return
#define con continue
using namespace std;
inline void ckmin(auto &a,auto b){if(b<a)a=b;}
inline void ckmax(auto &a,auto b){if(a<b)a=b;}
const int N=505;
inline int rd(){
	int ans=0,f=0;
	char ch=getchar();
	while(ch<'0'||ch>'9')f^=(ch=='-'),ch=getchar();
	while(ch>='0'&&ch<='9')ans=(ans<<3)+(ans<<1)+(ch^48),ch=getchar();
	re f?-ans:ans;
}
int nxt[4][2]={{1,0},{0,1},{-1,0},{0,-1}};
int n,m,K,nm,INF=0x3f3f3f3f,f[10][10][N*N];
char a[N][N],vis[N][N][5];
int nd[N*N],tt=1;
struct edge{
	int v,nxt;
}e[N*N*4];
void add(int u,int v){
	e[++tt]={v,nd[u]};
	nd[u]=tt;
//	printf("(%d,%d)\n",u,v);
}
struct xxs{
	int x,y;
}to[N][N][5];
xxs dfs(int x,int y,int t){
	if(to[x][y][t].x)re to[x][y][t];
	int nt=t,nx,ny;
	if(a[x][y]=='A')nt=(nt+1)&3;
	if(a[x][y]=='C')nt=(nt+3)&3;
	nx=x+nxt[nt][0],ny=y+nxt[nt][1];
	if(!nx||nx>n||!ny||ny>m||a[nx][ny]=='x')re to[x][y][t]={x,y};
	if(vis[nx][ny][nt])re to[x][y][t]={-1,-1};
	vis[x][y][t]=1;
	to[x][y][t]=dfs(nx,ny,nt);
	vis[x][y][t]=0;
	re to[x][y][t];
}
int bk[N*N],id[N*N];
int bt[N*N],b[N*N];
void bfs(int *dis){
	memset(bk,0,sizeof bk);
	memset(bt,0,sizeof bt[0]*nm);
	queue<int>q;
	int cnt=nm;
	for(int i=nm;i;i--)
		if(dis[id[i]]==INF)swap(id[i],id[cnt--]);
	for(int i=1;i<=cnt;i++)bt[dis[id[i]]]++;
	for(int i=1;i<=nm;i++)bt[i]+=bt[i-1];
	for(int i=cnt;i;i--)b[bt[dis[id[i]]]--]=id[i];
	memcpy(id+1,b+1,sizeof b[0]*cnt);
	cnt=2;
	q.push(id[1]);
	while(q.size()){
		int u=q.front();q.pop();
		if(bk[u])con;
		bk[u]=1;
		while(cnt<=nm&&dis[id[cnt]]<=dis[u]+1)q.push(id[cnt++]);
		for(int i=nd[u];i;i=e[i].nxt){
			int v=e[i].v;
			if(dis[v]>dis[u]+1)dis[v]=dis[u]+1,q.push(v);
		}
	}
}
int main(){
//	freopen("data.in","r",stdin);
	K=rd(),m=rd(),n=rd(),nm=n*m;
	for(int i=1;i<=nm;i++)id[i]=i;
	for(int l=1;l<=K;l++)
		for(int r=l;r<=K;r++)memset(f[l][r],0x3f,sizeof f[l][r]);
	for(int i=1;i<=n;i++){
		scanf("%s",a[i]+1);
		for(int j=1;j<=m;j++)
			if(a[i][j]>'0'&&a[i][j]<='9'){
				int x=a[i][j]-'0';
				f[x][x][(i-1)*m+j]=0;
			}
	}
	for(int i=1;i<=n;i++)
	for(int j=1;j<=m;j++){
		if(a[i][j]=='x')con;
		for(int t=0;t<4;t++){
			if(!to[i][j][t].x)dfs(i,j,t);
			int x=to[i][j][t].x,y=to[i][j][t].y;
			if(x>0)add((i-1)*m+j,(x-1)*m+y);
		}
	}
	/*--------------------------------*/
	for(int r=1;r<=K;r++)
	for(int l=r;l;l--){
		for(int i=l;i<r;i++)
			for(int j=1;j<=nm;j++)ckmin(f[l][r][j],f[l][i][j]+f[i+1][r][j]);
		bfs(f[l][r]); 
	}
	int ans=INF;
	for(int i=1;i<=nm;i++)ckmin(ans,f[1][K][i]);
	printf("%d\n",ans==INF?-1:ans);
	re 0;
}
/*
2 5 5
.x1Ax
..A..
..C.C
Cx...
2....

*/
}int main(){re chiptune::main();}
```

> Love has a nasty habit of disappearing over night.

---

## 作者：St_john (赞：0)

# [[APIO2013] 机器人](https://www.luogu.com.cn/problem/P3638)


先记忆化搜索，找到每个点 $(i,j)$ 向方向 $k$ 移动最终到的位置。  
`A` 向左转， `C` 向右转。  
似乎问题不是那么简单，有可能出现环。  
比如下面的情况。  
```cpp

AA
AA

```
从任意一个 `A` 向附近的 `A` 出发，最终都会一直在转圈圈。  
特判一下即可。  

发现合并是有顺序的，类似区间合并，考虑区间 DP。  
设 $f_{l,r,k}$ 表示 $[l,r]$ 的机器人在位置 $k$ 合并的答案。  

不同机器人的转移 $f_{l,mid,k}+f_{mid+1,r,k}\to f_{l,r,k}$ 。  
同一种机器人的转移 $f_{l,r,k'}+1\to f_{l,r,k}(k\ne k';k,k' \text{连通})$。  

第二种转移，满足三角不等式，一看就是斯坦纳树，可以写个最短路。  

关于卡常，用 C++20 和 O2 能过。  

```cpp
#include<cstdio>
#include<cstring>
#include<queue>
#define _for(i,a,b) for(register int i=(a);i<=(b);++i)
#define __for(i,a,b) for(register int i=(a);i>=(b);--i)
#define Re register int
#define il inline
#define pc putchar
using namespace std;
typedef long long ll;
const int N=500+10,M=(1<<11)+10,mod=1e9+7;
il int re(){
    int x=0;
    bool f=0;
    char ch=getchar();
    while(ch<'0'||ch>'9')
        f|=ch=='-',ch=getchar();
    while(ch>='0'&&ch<='9')
        x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
    return f?-x:x;
}
void pr(int x){
    if(x<0) x=-x,pc('-');
    if(x>9) pr(x/10);
    pc(x%10|48);
}

int n,w,h;
char a[N][N];
int id[N][N],num;

 int dx[4]={0,0,1,-1},dy[4]={1,-1,0,0};
bool now[N][N][4];
int to[N][N][4];
int dfs( int x, int y, int d){
	if(now[x][y][d]){
		to[x][y][d]=-1;
		return -1;
	}
	if(to[x][y][d]) return to[x][y][d];
	now[x][y][d]=1;
	 int xx=x+dx[d],yy=y+dy[d];
	if(a[xx][yy]=='x'){
		to[x][y][d]=id[x][y];
	}
	else if(a[xx][yy]=='A'){
		if(d==0)
			to[x][y][d]=dfs(xx,yy,3);
		else if(d==1)
			to[x][y][d]=dfs(xx,yy,2);
		else if(d==2)
			to[x][y][d]=dfs(xx,yy,0);
		else
			to[x][y][d]=dfs(xx,yy,1);
	}
	else if(a[xx][yy]=='C'){
		if(d==0)
			to[x][y][d]=dfs(xx,yy,2);
		else if(d==1)
			to[x][y][d]=dfs(xx,yy,3);
		else if(d==2)
			to[x][y][d]=dfs(xx,yy,1);
		else 
			to[x][y][d]=dfs(xx,yy,0);
	}
	else to[x][y][d]=dfs(xx,yy,d);
	now[x][y][d]=0;
	return to[x][y][d];
}

int r[N*N],cnt;
struct Edge{
	int t,n;
}edge[N*N*4];
il void add_edge(int u,int v){
	edge[++cnt]=(Edge){v,r[u]};r[u]=cnt;
}
int f[10][10][N*N];


void init(){
	_for(i,1,h)
		_for(j,1,w)
			if(a[i][j]!='x')
				id[i][j]=++num;
	_for(i,1,h)
		a[i][0]=a[i][w+1]='x';
	_for(j,1,w)
		a[0][j]=a[h+1][j]='x';
	_for(i,1,h){
		_for(j,1,w){
			if(a[i][j]!='x')
				_for(k,0,3)
					dfs(i,j,k);
			
		}
		
	}
	_for(i,1,h)
		_for(j,1,w)
			if(a[i][j]!='x')
				_for(k,0,3)
					if((~to[i][j][k])&&to[i][j][k]!=id[i][j])
						add_edge(id[i][j],to[i][j][k]);
	memset(f,0x3f,sizeof(f));
	_for(i,1,h)
		_for(j,1,w)
			if(a[i][j]>'0'&&a[i][j]<='9'){
				int number=a[i][j]^48;
				f[number][number][id[i][j]]=0;
			}
	
}

struct node{
	int x,v;
};
bool operator <(const node &x,const node &y){
	return x.v>y.v;
}
priority_queue<node> q;
bool done[N*N];
void dijkstra(int L,int R){
	memset(done,0,sizeof(done));
	while(!q.empty()){
		int x=q.top().x;q.pop();
		if(done[x]) continue;
		done[x]=1;
		for(Re i=r[x],y;i&&(y=edge[i].t);i=edge[i].n)
			if(f[L][R][y]>f[L][R][x]+1){
				f[L][R][y]=f[L][R][x]+1;
				q.push((node){y,f[L][R][y]});
			}
	}
}
void calc(int &x,int y){
	if(x>y) x=y;
}

signed main(){
    n=re(),w=re(),h=re();
    _for(i,1,h)
    	scanf("%s",a[i]+1);
    init();
    
    _for(len,1,n){
    	for(Re l=1,r;(r=l+len-1)<=n;++l){
			_for(k,1,num){
				for(Re mid=l;mid<r;++mid)
					calc(f[l][r][k],f[l][mid][k]+f[mid+1][r][k]);
				if(f[l][r][k]<f[0][0][0])
					q.push((node){k,f[l][r][k]});
			}
			dijkstra(l,r);
		}
    }
	int ans=f[0][0][0];
	_for(k,1,num)
		if(f[1][n][k]<ans)
			ans=f[1][n][k];
	if(ans==f[0][0][0])
		ans=-1;
	pr(ans);
    return 0;
}
```


---


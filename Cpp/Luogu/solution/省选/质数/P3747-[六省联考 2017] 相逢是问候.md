# [六省联考 2017] 相逢是问候

## 题目描述

> Informatik verbindet dich und mich.  
> 信息将你我连结。

B 君希望以维护一个长度为 $n$ 的数组，这个数组的下标为从 $1$ 到 $n$ 的正整数。

一共有 $m$ 个操作，可以分为两种：

- `0 l r` 表示将第 $l$ 个到第 $r$ 个数（ $a_l,a_{l+1} ...a_r$）中的每一个数 $a_i$ 替换为 $c^{a_i}$，即 $c$ 的 $a_i$ 次方，其中 $c$ 是输入的一个常数，也就是执行赋值 $a_i = c^{a_i}$。

- `1 l r` 求第 $l$ 个到第 $r$ 个数的和，也就是输出： $\sum_{i=l}^{r}a_i$

因为这个结果可能会很大，所以你只需要输出结果 $\bmod \space p$ 的值即可。


## 说明/提示

【数据范围】  

对于 $0\%$ 的测试点，和样例一模一样；

对于另外 $10\%$ 的测试点，没有修改；

对于另外 $20\%$ 的测试点，每次修改操作只会修改一个位置（也就是 $l = r$ ），并且每个位置至多被修改一次；

• 对于另外 $10\%$ 的测试点， $p = 2$；

对于另外 $10\%$ 的测试点， $p = 3$；

对于另外 $10\%$ 的测试点， $p = 4$；

对于另外 $20\%$ 的测试点， $1\le n,m \le 100$；

对于 $100\%$ 的测试点， $1\le n,m \le 5\times 10^4$，$1 \le p \le 10^8$，$0< c < p$，$0 \le a_i < p$。


## 样例 #1

### 输入

```
4 4 7 2
1 2 3 4
0 1 4
1 2 4
0 1 4
1 1 3```

### 输出

```
0
3```

## 样例 #2

### 输入

```
1 40 19910626 2
0
0 1 1
1 1 1
0 1 1
1 1 1
0 1 1
1 1 1
0 1 1
1 1 1
0 1 1
1 1 1
0 1 1
1 1 1
0 1 1
1 1 1
0 1 1
1 1 1
0 1 1
1 1 1
0 1 1
1 1 1
0 1 1
1 1 1
0 1 1
1 1 1
0 1 1
1 1 1
0 1 1
1 1 1
0 1 1
1 1 1
0 1 1
1 1 1
0 1 1
1 1 1
0 1 1
1 1 1
0 1 1
1 1 1
0 1 1
1 1 1```

### 输出

```
1
2
4
16
65536
11418102
18325590
13700558
13700558
13700558
13700558
13700558
13700558
13700558
13700558
13700558
13700558
13700558
13700558
13700558```

# 题解

## 作者：Luan_233 (赞：59)

## Solution

+ 这真是一道浪费时间浪费生命的好题啊！我从11月8号踏上去秦皇岛的征途时，在火车上和SGCollin一起搞这道题，直到现在才把这题搞掉。果然还是自己太菜了。

+ 如果没有做过[P4139 上帝与集合的正确用法](https://www.luogu.org/problemnew/show/P4139)建议先去做一做，别看这是个紫牌题，其实核心代码超级短。具体来讲，你只需要一个线性筛法，一个快速幂，一个dfs跑扩展欧拉定理就做完了。

+ 扩展欧拉定理不必多说，注意好它的分类讨论情况，即指数是否比$\varphi(p)$大，若指数比$\varphi(p)$小则无法进入指数循环节，不能用$ a^k \equiv a^{k \% \varphi(p)+\varphi(p) } \ (mod \ p) $，但是在那个紫牌题中，显然$ 2^{2^{2^{......}} } $是比$\varphi(p)$要大的多的，所以定理最后一条可以直接用。

+ 很显然每一次的模数都会变为它自己的欧拉函数，而这个过程的次数不会超过对数级别。有一个简单的证明，根据欧拉函数的公式，可以看到一个偶数在求欧拉函数时，一定会把一个素因子2提出来变成1，也就是至少除以2，而一个奇数一定会把自己的一个奇质因子提出来减1，变成一个偶数，接下来就是重复以上过程，直到模数变成1为止。这时任意实数模1都是0，直接返回就好。故P4139的核心代码如下：

```
inline int dfs(int mod){
    if(mod==1) return 0;
    return quick_pow(2,dfs(phi[mod])+phi[mod],mod);
}
```

+ 我们看这道题，$c^{c^{c^{......}}} mod \ p$可以转化为$c^{c^{c^{......}} \ mod \ \varphi(p)+\varphi(p)} mod \ p $，然后再计算$ c^{c^{c^{......}}} \ mod \ \varphi(p) $，这又可以转化为$ c^{c^{c^{......}} \ mod \ \varphi(\varphi(p))+\varphi(\varphi(p))} mod \ \varphi(p) $，如此反复嵌套，根据上面提到的东西，它至多进行对数级别层，也就是说只有这几层会对答案产生影响。

+ 还有一道题，[P4145 上帝造题的七分钟2 / 花神游历各国](https://www.luogu.org/problemnew/show/P4145)。为什么要提这道题呢？注意到题目中的操作不具有区间性质，但是$ c^{c^{c^{......}}} mod \ p $的值，在指数的层数达到一定值以后就不再变化，就变成了上面提到的这个过程，并且对数很小，可以考虑维护其单点修改次数，修改时直接暴力，达到临界条件后就不再更改。与这道蓝牌题的思路就很相似。

+ 回到这道题，上面的东西综合起来就是这题的正解算法。考虑线段树，维护一个区间的最小修改次数。由于我们要用到的欧拉函数的数目很少，可以直接暴力算出来，修改时的$power \ tower$直接暴算到底，快速幂时加上一点特判，就可以判断扩展欧拉定理运用的两个条件，也就是：

```
typedef long long LL;

inline LL qpow(LL t,LL mod){
    LL val=1,a=c;
    flag=0;
    while(t){
        if(t&1) val=val*a;
        a=a*a;
        t>>=1;
        if(val>=mod) val%=mod,flag=1;
        if(a>=mod) a%=mod;
    }
    return val;
}
```

+ 然后单次修改的复杂度就是 序列操作$\times$递归层数$\times$快速幂，达到了三个$\log$，复杂度比较高，常数大的会被第9、11两个点卡T（我吸了氧把第9个点过了，恩）。

+ 然后就是最终的优化。根据网上说法，欧拉函数很少，意味着模数很少，考虑将快速幂预处理，分为$c^{i}\ (mod \ p)$ 与 $c^{10000 \times i} \ (mod \ p)$，查询时直接将两块进行拼接，上面的特判用一个bool数组存下来，就可以少掉一个$\log$了。然后加读优、inline，再写的美观一些，就足以通过此题。

## Code
```
#include<cmath>
#include<cctype>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<iostream>
#include<algorithm>

#define M 55
#define maxn 100005

using namespace std;

typedef unsigned long long LL;

template<typename T> inline void read(T &x){
    x=0; char c=getchar();
    while(!isdigit(c)) c=getchar();
    while(isdigit(c)) x=(x<<1)+(x<<3)+(c^48),c=getchar();
}

int n,m,mint,ls[maxn],rs[maxn],ti[maxn],cnt;

LL p,c,pow1[maxn][M],pow2[maxn][M],v[maxn],val[maxn],phi[M];

bool flag,b1[maxn][M],b2[maxn][M];

inline LL calc_phi(LL vi){
    LL ret=vi,tmp=vi,lim=sqrt(vi);
    for(LL i=2;i<=lim;++i){
        if(!(tmp%i)){
            ret=ret*(i-1)/i;
            while(!(tmp%i)) tmp/=i;
        }
    }
    if(tmp>1) ret=ret*(tmp-1)/tmp;
    return ret;
}

inline void pre_work(){
    LL tmp=p; phi[0]=p;
    while(tmp!=1) tmp=calc_phi(tmp),phi[++mint]=tmp;
    phi[++mint]=1;
    for(int i=0;i<=mint;++i){
        pow1[0][i]=1;
        for(int j=1;j<=10000;++j){
            pow1[j][i]=pow1[j-1][i]*c;
            if(pow1[j][i]>=phi[i]) pow1[j][i]%=phi[i],b1[j][i]=1;
            b1[j][i]|=b1[j-1][i];
        }
    }
    for(int i=0;i<=mint;++i){
        pow2[0][i]=1;
        b2[1][i]=b1[10000][i];
        for(int j=1;j<=10000;++j){
            pow2[j][i]=pow2[j-1][i]*pow1[10000][i];
            if(pow2[j][i]>=phi[i]) pow2[j][i]%=phi[i],b2[j][i]=1;
            b2[j][i]|=b2[j-1][i];
        }
    }
}

inline LL calc(LL v,LL id){
    flag=0;
    LL v1=v%10000,v2=v/10000,ret=pow1[v1][id]*pow2[v2][id];
    if(ret>=phi[id]) ret=ret%phi[id],flag=1;
    flag|=b1[v1][id]|b2[v2][id];
    return ret;
}

inline LL dfs(LL vi,int deep,int lim){
    flag=0;
    if(deep==lim){
        if(vi>=phi[deep]) flag=1,vi%=phi[deep];
        return vi;
    }
    LL ci=dfs(vi,deep+1,lim);
    return calc(flag?ci+phi[deep+1]:ci,deep);
}

inline void build(int L,int R,int cur){
    if(L==R){ read(v[cur]); val[cur]=v[cur]; return ; }
    int mid=(L+R)>>1;
    ls[cur]=++cnt; build(L,mid,ls[cur]);
    rs[cur]=++cnt; build(mid+1,R,rs[cur]);
    val[cur]=val[ls[cur]]+val[rs[cur]];
    if(val[cur]>=p) val[cur]-=p;
}

inline void update(int L,int R,int l,int r,int cur){
    if(ti[cur]>=mint) return ;
    if(L==R){
        ++ti[cur]; val[cur]=dfs(v[cur],0,ti[cur]);
        return ;
    }
    int mid=(L+R)>>1;
    if((l<=mid)&&(ti[ls[cur]]<mint)) update(L,mid,l,r,ls[cur]);
    if((r>mid)&&(ti[rs[cur]]<mint)) update(mid+1,R,l,r,rs[cur]);
    val[cur]=val[ls[cur]]+val[rs[cur]];
    if(val[cur]>=p) val[cur]-=p;
    ti[cur]=min(ti[ls[cur]],ti[rs[cur]]);
}

inline LL query(int L,int R,int l,int r,int cur){
    if((l<=L)&&(R<=r)) return val[cur];
    int mid=(L+R)>>1; LL ret=0;
    if(l<=mid) ret=query(L,mid,l,r,ls[cur]);
    if(r>mid) ret+=query(mid+1,R,l,r,rs[cur]);
    return (ret>=p)?(ret-p):ret;
}

int main(){
    ios::sync_with_stdio(false);
    cin.tie(0); cout.tie(0);
    read(n); read(m); read(p); read(c);
    build(1,n,++cnt); pre_work();
    while(m--){
        int opt,l,r;
        read(opt); read(l); read(r);
        if(opt==0) update(1,n,l,r,1);
        else if(opt==1) cout<<query(1,n,l,r,1)<<endl;
    }
    return 0;
}
```

---

## 作者：s_r_f (赞：26)

安利$:$ [杂题选做](https://www.luogu.com.cn/blog/s-r-f/liu-yue-qi-yue-za-ti-xuan-zuo)

[P3747 [六省联考2017]相逢是问候](https://www.luogu.com.cn/problem/P3747)

首先可以想到通过欧拉定理计算$.$

不难发现只有前$log$次修改是有用的$,$那么直接维护就可以了$.$

注意不要每次计算的时候直接调用快速幂$,$这样会多一个$\log.$

正确的姿势是对于每个$mod$ $O(\sqrt{2\times mod})$预处理一下$c^x$和$c^{mx}$ $,$然后就可以做到$O(1)$计算一个$c^x.$

实现的好可以做到$O(nlog^2max(p,n))$

代码$:$

```cpp
#include <bits/stdc++.h>
#define LL long long
using namespace std;
const int N = 50005,D = 60;
inline int calcphi(int n){
	static int t,i,ans; t = n,ans = n;
	for (i = 2; i * i <= n; ++i) if (t % i == 0){
		while (!(t%i)) t /= i;
		ans = ans / i * (i-1);
	}
	if (t > 1) ans = ans / t * (t-1);
	return ans;
}
int P;
int c;
int p[D],cntp,c1[D][1<<15],c2[D][1<<15];
inline int Mo(LL n,int p){ return n >= p ? (n % p + p) : n; }
inline void init_c(){
	int i,j;
	for (i = 0; i <= cntp; ++i){
		c1[i][0] = c2[i][0] = 1;
		for (j = 1; j < 1<<15; ++j) c1[i][j] = Mo((LL)c1[i][j-1] * c,p[i]);
		c2[i][1] = Mo((LL)c1[i][(1<<15)-1] * c,p[i]);
		for (j = 2; j < 1<<15; ++j) c2[i][j] = Mo((LL)c2[i][j-1] * c2[i][1],p[i]);
	}
}
inline int power(int n,int i){ return Mo((LL)c1[i][n&32767]*c2[i][n>>15],p[i]); }
int n,m,a[N][D];
inline int calc(int x,int cnt,int i){
	if (!cnt) return Mo(x,p[i]); if (i == cntp) return c ? 1 : 0;
	return power(calc(x,cnt-1,i+1),i);
}
int sum[N<<2],mn[N<<2];
inline void up(int o){
	mn[o] = min(mn[o<<1],mn[o<<1|1]);
	sum[o] = sum[o<<1] + sum[o<<1|1];
	if (sum[o] >= P) sum[o] -= P; 
}
inline void Build(int o,int l,int r){
	mn[o] = 0; if (l == r){ sum[o] = a[l][0]; return; }
	int mid = l+r>>1; Build(o<<1,l,mid); Build(o<<1|1,mid+1,r); up(o);
}
int ll,rr;
inline void Add(int o,int l,int r){
	if (mn[o] > cntp) return;
	if (l == r){ ++mn[o],sum[o] = a[l][mn[o]]; return; } 
	if (ll <= l && rr >= r){ int mid = l+r>>1; Add(o<<1,l,mid); Add(o<<1|1,mid+1,r); up(o); return; }
	int mid = l+r>>1; if (ll <= mid) Add(o<<1,l,mid); if (rr > mid) Add(o<<1|1,mid+1,r); up(o);
}
int qans;
inline void Ask(int o,int l,int r){
	if (ll <= l && rr >= r){ qans = (qans + sum[o] >= P) ? (qans + sum[o] - P) : (qans + sum[o]); return; }
	int mid = l+r>>1; if (ll <= mid) Ask(o<<1,l,mid); if (rr > mid) Ask(o<<1|1,mid+1,r);
}
int main(){
	int i,j,op;
	cin >> n >> m >> P >> c;
	p[cntp = 0] = P; while (p[cntp] > 1) ++cntp,p[cntp] = calcphi(p[cntp-1]);
	init_c();
	for (i = 1; i <= n; ++i){
		cin >> a[i][0];
		for (j = 1; j <= cntp+1; ++j) a[i][j] = calc(a[i][0],j,0) % P;
		a[i][0] %= P;
	}
	Build(1,1,n);
	while (m--){
		cin >> op >> ll >> rr;
		if (op == 0) Add(1,1,n);
		else qans = 0,Ask(1,1,n),cout << qans << '\n';
	}
	return 0;
}
```

---

## 作者：juju527 (赞：23)

Latex挂了可以去洛谷blog或者下面的链接查看

[更好的阅读体验](https://juju527.github.io/post/ti-jie-p3747-liu-sheng-lian-kao-2017xiang-feng-shi-wen-hou/)

## 线段树+扩展欧拉定理+预处理

记录一下刚了我一晚上的毒瘤题

### 前置知识
线段树(~~您都来做黑题了还不会线段树是不是有点过分~~)

扩展欧拉定理

---
### 扩展欧拉定理

这里丢个式子

$$a^b\equiv a^{b \mod \varphi(p)}\mod p[gcd(a,p)==1]$$
$$a^b\equiv a^{b}\mod p[gcd(a,p)!=1\And b<\varphi(p)]$$
$$a^b\equiv a^{b\mod \varphi(p)+\varphi(p)}\mod p[gcd(a,p)!=1\And b>=\varphi(p)]$$

至于该定理的证明是根据欧拉定理$a^{\varphi(p)}\equiv 1\mod p$证的

有了欧拉定理扩展欧拉定理可以理解为每$\varphi(p)$个$a$乘起来就变成了1

至于欧拉定理的证明网上应该有挺多的，扩展欧拉定理的严谨证明也有挺多的，这里就不再赘述

### 思路

看到题意是区间修改+区间查询和，这很线段树

但是修改操作并不与一般的线段树题相同

每一个点权值形式为$c^{c^{...^{a_i}}}$这样子

记这个一个k个c的幂,$a_i$模p为$f(a_i,k,p)$

对$f(k,a_i)$用扩展欧拉定理

(这里默认是扩展欧拉定理的第三种情况，但具体实现时需考虑其他的情况)

$$
f(a_i,k,p)\equiv c^{f(a_i,k-1, \varphi(p))+\varphi(p)}\mod p
$$

我们可以对下面这个东西做同样的事情
$$f(a_i,k-1,\varphi(p))$$

模数会有$p,\varphi(p),\varphi(\varphi(p))...$

直到某次迭代得到的值为1则后面的幂都没有意义了

由于偶数的欧拉函数迭代1次后至少缩小一半(所有偶数不与它互质)

奇数的欧拉函数迭代1次后必为偶数(由$\varphi$的计算式可知)

故迭代次数是log级的

这也代表着一个值最多经过log个修改操作后值不再改变

都会变成$c^{c^{c^{...^c}}}$

记对$p$进行$h$次欧拉函数迭代后p变为1

我们只要对于每一个$a_i$预处理$f(i,a_i,m),i\in[0,h]$m为p迭代出来的所有数即可

而想求f，我们可以设$s_1(i,m),s_2(i,m)$用于求$c^i$模m的值，m的定义与上方一样

而特判欧拉定理我们可以再开两个bool数组判断

具体可以看下代码里的pre函数

### 复杂度分析
每次修改对于每一个位置暴力修改，由于一个位置修改log次后继续修改值是不变的

故我们记录一下每个位置的修改次数，每个点最多修改log次。

由于我们每次遍历了所有覆盖某个区间的线段树节点，总复杂度$O(nlog^2)$

我们预处理出了$f(i,j,k)$,这个东西是$nlog^2的$

空间复杂度也是$O(nlog^2)$

~~好像题解大佬有空间更优秀的做法qaq~~
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int maxn=50005;
struct seg{
	int v,mn;
}t[maxn<<2];
int n,m,p,c;
int len=0;
int phi[30];
long long s1[10005][30],s2[10005][30];
bool b1[maxn][30],b2[maxn][30];
long long f[maxn][30][30];
bool bj[maxn][30][30];
int g[30];
int a[maxn];
int read(){
	int x=0,y=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')y=-1;ch=getchar();}
	while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+(ch^48),ch=getchar();
	return x*y;
}
int gcd(register int x,register int y){
	return y==0?x:gcd(y,x%y);
}
int get_phi(int x){
	long long ans=x;
	for(long long i=2;i<=sqrt(x);i++){
		if(x%i)continue;
		ans=ans*(i-1)/i;
		while(x%i==0)x/=i;
	}
	if(x>1)ans=ans*(x-1)/x;
	return ans;
}
void pre(){
	int x=p;
	phi[0]=p;
	while(x!=1){x=get_phi(x);phi[++len]=x;}
	phi[++len]=1;
	for(int i=0;i<=len;i++)g[i]=gcd(c,phi[i]);
	for(int j=0;j<=len;j++){
		s2[0][j]=1;
		for(int i=1;i<=10000;i++){
			s2[i][j]=s2[i-1][j]*c;
			if(s2[i][j]>=phi[j]){s2[i][j]%=phi[j];b2[i][j]=1;}
			b2[i][j]|=b2[i-1][j];
		}
	}
	for(int j=0;j<=len;j++){
		s1[0][j]=1;
		b1[1][j]=b2[10000][j];
		for(int i=1;i<=10000;i++){
			s1[i][j]=s1[i-1][j]*s2[10000][j];
			if(s1[i][j]>=phi[j]){s1[i][j]%=phi[j];b1[i][j]=1;}
			b1[i][j]|=b1[i-1][j];
		}
	}
	for(int i=1;i<=n;i++){
		for(int k=0;k<=len;k++){
			f[i][0][k]=a[i]%phi[k];
			if(a[i]>=phi[k])bj[i][0][k]=1;
		}
		for(int j=1;j<=len;j++){
			f[i][j][len]=0;
			for(int k=0;k<len;k++){
				f[i][j][k]=s1[f[i][j-1][k+1]/10000][k]*s2[f[i][j-1][k+1]%10000][k];
				bj[i][j][k]=(b1[f[i][j-1][k+1]/10000][k]||b2[f[i][j-1][k+1]%10000][k]);
				if(f[i][j][k]>=phi[k]){f[i][j][k]%=phi[k];bj[i][j][k]=1;}
				if(g[k]!=1&&bj[i][j-1][k+1]){
					f[i][j][k]=f[i][j][k]*s1[phi[k+1]/10000][k]%phi[k]*s2[phi[k+1]%10000][k];
					if(f[i][j][k]>=phi[k]){f[i][j][k]%=phi[k];bj[i][j][k]=1;}
					bj[i][j][k]=(bj[i][j][k]||b1[phi[k+1]/10000][k]||b2[phi[k+1]%10000][k]);
				}
			}	
		}
	}
	return ;
}
void pushup(int k){
	t[k].v=t[k<<1].v+t[k<<1|1].v;
	t[k].mn=min(t[k<<1].mn,t[k<<1|1].mn);
	return ;
}
void build(int k,int l,int r){
	if(l==r){
		t[k].v=a[l];
		t[k].mn=0;
		return ;
	}
	int mid=l+((r-l)>>1);
	build(k<<1,l,mid);
	build(k<<1|1,mid+1,r);
	pushup(k);
	return ;
}
void modify(int k,int l,int r,int x,int y){
	if(t[k].mn>=len)return ;
	if(l>y||r<x)return ;
	if(l==r){
		t[k].mn++;t[k].v=f[l][t[k].mn][0]%p;
		return ;
	}
	int mid=l+((r-l)>>1);
	if(t[k<<1].mn<len)modify(k<<1,l,mid,x,y);
	if(t[k<<1|1].mn<len)modify(k<<1|1,mid+1,r,x,y);
	pushup(k);
	return ;
}
int query(int k,int l,int r,int x,int y){
	if(l>y||r<x)return 0;
	if(l>=x&&r<=y)return t[k].v%p;
	int mid=l+((r-l)>>1);
	return (query(k<<1,l,mid,x,y)+query(k<<1|1,mid+1,r,x,y))%p;
}
signed main(){
	n=read();m=read();p=read();c=read();
	for(int i=1;i<=n;i++)a[i]=read();
	pre();
	build(1,1,n);
	for(int i=1;i<=m;i++){
		int opt,l,r;
		opt=read();l=read();r=read();
		if(opt==0)modify(1,1,n,l,r);
		else printf("%lld\n",query(1,1,n,l,r));
	}
	return 0;
}

```

---

## 作者：s_a_b_e_r (赞：12)

在同余p的情况下对一个数c不断取φ，最多阶乘log p次就可以保持不变。于是对于一个数。我们可以扩展欧拉函数对数c的幂次不断抽取φ,反复迭代。

最后会迭代出c^((c.......)%φ(φ(φ(φ.......p)))+φ(φ(φ(φ.......p)))<``φ(φ(φ(φ.......p)))=1``>

所以我们只用找到一个临界是一堆φ等于1。然后就不用再对他进行修改。

然后用线段树维护一个区间最少修改的次数。如果已经到临界就不用再修改了。

如果还要再改就暴力到根节点~~但是常数比较大~~

[三人cp博客](http://www.cnblogs.com/ck666/p/7499209.html)

```cpp
#include<iostream>
#include<cstdlib>
#include<cstdio>
#include<algorithm>
#define ll (long long)
#define LL long long 
#define IN int 
using namespace std;
const IN maxn=50000+99;
const IN N=10000+99;
int read(){
    int an=0,f=1;
    char ch=getchar();
    while(!('0'<=ch&&ch<='9')){if(ch=='-')f=-f;ch=getchar();}
    while('0'<=ch&&ch<='9'){an=an*10+ch-'0';ch=getchar();}
    return an*f;
}
IN phi[35],a[maxn],F;
IN n,m,p,c;
IN prime[maxn],isp[maxn],k,maxp;//k是质数个数,ips说明这是和数 
struct saber{
IN sum,tag,l,r;
}tr[maxn<<2];
IN Phi(IN x){
    LL ans=x;
    for(IN i=1;i<=k && prime[i]*prime[i]<=x;i++){
        if(!(x%prime[i]))ans=ans*(prime[i]-1)/prime[i];
        while(!(x%prime[i]))x=x/prime[i];
    }
    if(x>1)ans=ans/x*(x-1);
    return ans;
}
void euler(){
    for(IN i=2;i<=N;i++){
        if(!isp[i])k++,prime[k]=i;
        for(IN j=1;j<=k;j++){
            if(i*prime[j]>N)break;
            isp[i*prime[j]]=1;
            if(!(i%prime[j]))break;
        }
    }
    phi[maxp]=p;
    while(phi[maxp]!=1)maxp++,phi[maxp]=Phi(phi[maxp-1]);
    maxp++;
    phi[maxp]=1;
}
void build(IN k,IN l,IN r){
    tr[k].l=l;
    tr[k].r=r;
    if(l==r){
        tr[k].sum=a[l];
        return ;
    }
    IN mid=(l+r)>>1;
    build(k<<1,l,mid);
    build(k<<1|1,mid+1,r);
    tr[k].sum=tr[k<<1].sum+tr[k<<1|1].sum;
}
IN ask(IN k,IN i,IN j){
    IN l=tr[k].l,r=tr[k].r;
    if(l==i&&r==j)return tr[k].sum;
    IN mid=(l+r)>>1;
    if(mid>=j)return ask(k<<1,i,j);
    else if(i>mid)return ask(k<<1|1,i,j);
    else return (ask(k<<1,i,mid)+ask(k<<1|1,mid+1,j))%p;
}
IN qw(LL k,IN mod){
    LL ans=1;LL s=c;
    while(k){
        if(k&1)ans*=s;
        k>>=1;
        s*=s;
        if(s>=mod)F=1,s%=mod;
        if(ans>=mod)F=1,ans%=mod;
    }
    return ans%mod;
}
LL work(LL a,LL t){
    LL tmp=a;
    if(tmp>phi[t])tmp=tmp%phi[t]+phi[t];
    for(IN i=t;i>0;i--){
        F=0;tmp=qw(tmp,phi[i-1]);
        if(F)tmp+=phi[i-1],F=0;
    }
    return tmp;
}
void change(IN k,IN i,IN j){
    if(tr[k].tag>=maxp)return;
    LL l=tr[k].l,r=tr[k].r;
    if(l==r){
        tr[k].tag++;
        tr[k].sum=work(a[l],tr[k].tag)%p;
        return;
    }
    IN mid=(l+r)>>1;
    if(mid>=j)change(k<<1,i,j);
    else if(i>mid)change(k<<1|1,i,j);
    else {change(k<<1,i,mid);change(k<<1|1,mid+1,j);}
    tr[k].sum=tr[k<<1].sum+tr[k<<1|1].sum;
    tr[k].tag=min(tr[k<<1].tag,tr[k<<1|1].tag);
}
int main(){
    n=read();m=read();p=read();c=read();
    for(IN i=1;i<=n;i++)a[i]=read();
    euler();
    build(1,1,n);
    while(m)
    {m--;
        IN x,y,z;
        x=read();y=read();z=read();
        if(x){
            printf("%lld\n",ask(1,y,z)%p);
        }
        else {
            change(1,y,z);
        }
    }
    return 0;
}
```
~~按照某讲题人打的,常数问题T两个点,在这加个题解给思路~~


---

## 作者：花淇淋 (赞：11)

# Solution
 - 建议先做[这题](https://www.luogu.org/problemnew/show/P4139)
 - 根据扩展欧拉定理
 $$a^b\% p ≡ a^{b \%\phi(p)+\phi(p)}\% p,b≥\phi(p)$$
 $$a^b\% p ≡ a^{b \%\phi(p)}\% p,b<\phi(p)$$
 - [这题](https://www.luogu.org/problemnew/show/P4139)核心代码如下
 ```cpp
 inline int solve(int p) // 递归处理模数为p的答案
{
    if (p == 1) return 0;
    return ksm(2, solve(phi[p]) + phi[p], p); // ksm(x,y) = x ^ y
}
 ```
 - 发现每次递归都会将 $p$ 变为 $\phi(p)$
 - 当 $p$ 是偶数时， $p$ 变 $\phi(p)$ 至少除以 $2$；当 $p$ 是奇数时，根据 $\phi(p)$ 的计算公式 ($q[i]$ 为 $p$ 的所有质因子，且互不相同)$$p*\Pi_{i=1}^k(q[i]-1)\div q[i]$$
 - $q[i]-1$必有偶数，那么$\phi(p)$是偶数
 - **可知 $p$ 会在 $O(\log p)$ 内次变为 $1$，结束递归**
 ****
 - 而上题中，对扩展欧拉定理的应用为：$$2^{2^{2^{2^{...}}}}\% p ≡ 2^{2^{2^{2^{...}}} \%\phi(p)+\phi(p)}$$
 - 假设 $2$ 的个数有限，等式左边有 $x$ 个 $2$， 那么等式右边的指数，也就是递归处理的部分，有 $x-1$ 个 $2$
 - 也就是说，每次递归减少了一个 $2$
 - **那么减少 $O(\log p)$ 个 $2$ 后必定结束递归，即当 $2$ 的个数超过 $\log p$ 时，答案全部一样**
 - 回到本题，可以得出一个数的修改次数上限为 $O(\log p)$
 - 那么维护线段树，如果整个区间修改次数都到上限了，就 $return$
 - 易得一共会碰到叶子节点 $O (n \log p)$ 次
 ****
 - ~~为了方（偷）便（懒）~~ ，记 $b[i][j]$ 为 $c^{c^{c^{...^{a_{i}}}}}$ (共 $j$ 个 $c$，**注意没有取模**），记 $f(i,j,p)$ 为 $c^{c^{c^{...^{a_{i}}}}} \%p$ (共 $j$ 个 $c$)，那么有递推式$$f(i,j,p)=c^{f(i,j-1,\phi(p))+(b[i][j-1]<\phi(p)?0:\phi(p))}$$
 - **预处理几个值在 $1e8$ 内的 $b[i][j]$** 就好了，显然 $j$ 都比较小，$j$ 稍大一点就是天文数字了，肯定比 $\phi(p)$ 大，当然，**注意特判 $c=1$ 和 $j$ 较大的情况**
 - **$p$ 有 $1e8$，不能用数组把所有的 $\phi(x),x≤p$ 都存下来**，发现用到的 $x$ 只有 $p,\phi(p),\phi(\phi(p)),...,1$，考虑预处理出所有这样的 $x$，并存下它们的 $\phi$，记这些 $x$ 分别为 $d[m..1]$（即 $d[k-1] = \phi(d[k])$），那么上式改写为$$f(i,j,k)=c^{f(i,j-1,k-1)+(b[i][j-1]<d[k-1]?0:d[k-1])}$$ 
 - 注意递归边界：$j=0$ 或 $k=1$
 - 由于用到快速幂，上式时间复杂度 $O (\log^2p)$
 - 发现 $f(i,j,m)$ 不能直接由 $f(i,j-1,m)$ 得来，也就是说，每次到叶子节点都要重新计算，那么总复杂度 $O (n \log n \log^2p)$，~~直接爆炸~~，考虑优化掉快速幂
 ****
 - **对于这$m$个模数**，分别预处理 $c1[i]$ 为 $c^{i*20000}$，$c2[i]$ 为 $c^i$，那么 $$c^y=c1[y/20000]*c2[y\%20000]$$
 - 然后就可以 $O(1)$ 快速幂了
 - 总时间复杂度 $O(n (\log n \log p + \log^2p))$

# Code
```cpp
#include <bits/stdc++.h>

using namespace std;

#define ll long long
#define p2 p << 1
#define p3 p << 1 | 1

template <class t>
inline void read(t & res)
{
	char ch;
	while (ch = getchar(), !isdigit(ch));
	res = ch ^ 48;
	while (ch = getchar(), isdigit(ch))
	res = res * 10 + (ch ^ 48);
}

const int e = 5e4 + 5, o = 5e4 + 5, bl = 2e4, z = 105;
int a[e], cnt[o * 4], c1[z][20005], c2[z][20005], n, m, c, mod, phi[e];
int num[e], d[e], c4, c3[e], b[e][20], sum[o * 4];

inline void upt(int &x, int y)
{
	x = y;
	if (x >= mod) x -= mod;
}

inline int solve(int x)
{
	int s = sqrt(x), res = x, i;
	for (i = 2; i <= s; i++)
	if (x % i == 0)
	{
		while (x % i == 0) x /= i;
		res /= i;
		res *= i - 1;
	}
	if (x > 1)
	{
		res /= x;
		res *= x - 1;
	}
	return res;
}

inline void init()
{	
	d[d[0] = 1] = mod;
	for (;;)
	{
		d[0]++;
		d[d[0]] = solve(d[d[0] - 1]);
		if (d[d[0]] == 1) break;
	}
	reverse(d + 1, d + d[0] + 1);
	int i, j;
	ll y = 1;
	c3[0] = 1;
	for (i = 1; i < bl; i++) 
	{
		if (y <= 1e8)
		{
			y = y * c; 
			c3[i] = y;
			if (y <= 1e8) c4 = i;
		}
		else break;
	}
	for (i = 1; i <= d[0]; i++)
	{
		c1[i][0] = c2[i][0] = 1;
		for (j = 1; j < bl; j++) c2[i][j] = (ll)c2[i][j - 1] * c % d[i];
		c1[i][1] = (ll)c2[i][bl - 1] * c % d[i];
		for (j = 2; j < bl; j++) c1[i][j] = (ll)c1[i][j - 1] * c1[i][1] % d[i];
	}
	for (i = 1; i <= n; i++)
	{
		b[i][0] = a[i];
		for (j = 1; j <= 6; j++)
		{
			int x = b[i][j - 1], p1 = x / bl, p0 = x % bl;
			if (c3[p0] > 1e8 || p1 || p0 > c4) break;
			b[i][j] = c3[p0];
			num[i] = j;
		}
	}
}

inline int ksm(int y, int id)
{
	return (ll)c1[id][y / bl] * c2[id][y % bl] % d[id]; 
}

inline int f(int i, int j, int mod)
{
	if (mod == 1) return 0;
	if (j == 0) return a[i] % d[mod];
	if (c == 1 || (c != 1 && j - 1 <= num[i] && b[i][j - 1] < d[mod - 1])) 
	return ksm(f(i, j - 1, mod - 1), mod);
	else return ksm(f(i, j - 1, mod - 1) + d[mod - 1], mod);
}

inline void collect(int p)
{
	cnt[p] = min(cnt[p2], cnt[p3]);
	upt(sum[p], sum[p2] + sum[p3]);
}

inline void build(int l, int r, int p)
{
	if (l == r)
	{
		sum[p] = a[l];
		return;
	}
	int mid = l + r >> 1;
	build(l, mid, p2);
	build(mid + 1, r, p3);
	collect(p);
}

inline void update(int l, int r, int s, int t, int p)
{
	if (cnt[p] > d[0]) return;
	if (l == r)
	{
		cnt[p]++;
		sum[p] = f(l, cnt[p], d[0]);
		return;
	}
	int mid = l + r >> 1;
	if (s <= mid) update(l, mid, s, t, p2);
	if (t > mid) update(mid + 1, r, s, t, p3);
	collect(p);
}

inline int query(int l, int r, int s, int t, int p)
{
	if (l == s && r == t) return sum[p];
	int mid = l + r >> 1, res = 0;
	if (t <= mid) res = query(l, mid, s, t, p2);
	else if (s > mid) res = query(mid + 1, r, s, t, p3);
	else upt(res, query(l, mid, s, mid, p2) + query(mid + 1, r, mid + 1, t, p3));
	return res;
}

int main()
{
	read(n); read(m); read(mod); read(c);
	int i, opt, l, r;
	for (i = 1; i <= n; ++i) read(a[i]);
	init();
	build(1, n, 1);
	while (m--)
	{
		read(opt);
		read(l);
		read(r);
		if (!opt) update(1, n, l, r, 1);
		else printf("%d\n", query(1, n, l, r, 1));
	}
	return 0;
}
```


---

## 作者：诗乃 (赞：6)

前置芝士扩展欧拉定理：

![](https://cdn.luogu.com.cn/upload/image_hosting/kxeno956.png)

引理：一个数至多取$O(log)$次欧拉函数会变为1.

口胡证明：对于偶数，所有小于它的偶数都与它不互质，其欧拉函数至少为其$\frac{1}{2}$。对于奇数，其欧拉函数必是偶数。证毕。

由此可得某数在修改$O(log)$次之后将不再改变。

考虑暴力分块。

将序列分为$\frac{n}{B}$个大小为$B$的块。修改时暴力修改整块与散块，若某一次修改后发现当前块没有数字被改变，说明继续修改这个块也不再生效，打上标记不再修改。

考虑如何修改单点。

记录每个位置的修改次数，用扩展欧拉定理直接嵌套求解，容易写出像这样的代码：

```cpp
void getans(int x, int t, int p) {
//x为当前位置初始值，t为修改次数，p为当前模数。
	if(!t) return x%p;
	if(p==1) return 0;
	int b = getans(x, t-1, phi[p])+phi[p];
	return pwc(b, p);
//其中pwc(b, p)表示求c^b mod p的值。
}
```
这样写显然是有一点点小问题的，代码中并没有判断$b$与$\varphi(p)$的大小，引入一个结构体来存储数据是否已经超过$p$即可解决此问题。

```cpp
struct Node {int x, flag;};
Node getans(int x, int t, int P) {
	if(!t) return (Node) {x%P, x>=P};
	if(P == 1) return (Node) {0, 1};
	Node tmp = getans(x, t-1, phi[P]);
	int b = tmp.x + phi[P] * tmp.flag;
	return pwc(b, P); //在pwc()中也需要判断，详见代码。
}
```
这样看起来单点修改的时间是$O(log^2n)$的，难以接受。考虑优化快速幂。

考虑暴力分块。设最大指数为$V$，则可以对于每一个模数预处理出以下两个信息：

1、$c^1,c^2,c^3,c^4,c^5....,c^{\sqrt{V}}$。

2、$c^{\sqrt{V}},c^{2\sqrt{V}},c^{3\sqrt{V}},c^{4\sqrt{V}},....c^{V}$。

对于每一个指数$b<V$，有：

$$b=k\sqrt{V}+t(k \in N,t≤\sqrt{V})$$

由于模数最多只有$O(logn\sqrt{V})$预处理$O(1)$求解$c$的幂次方。

由此达成了$O(logn)$单点修改。

随便假设一下$log(n),log(p)$同阶来分析复杂度。(懒）

由于每个块最多被整块修改$O(logn)$次，每次修改复杂度为$O(Blogn)$，共有$O(\frac{n}{B})$个块，因此整块修改的复杂度为均摊$O(nlog^2n)$，散块修改复杂度$O(nBlogn)$。

对于询问操作，复杂度为$O(nB+\frac{n^2}{B})$

当$B=\sqrt{\frac{n}{log_2n}}$的时候复杂度最优，为$O(nlog^2n+(nlogn)^{\frac{3}{2}})$

可以草过本题。上代码：

```cpp
#include <bits/stdc++.h>
#define bl(x) ((x-1)/siz+1)
#define L(x) (x-1)*siz+1
#define R(x) std::min(x*siz, n)
using namespace std;
const int MAXN = 50050, MAXB = 250, GSM = 12000, MAXV = 1e8;
int s[MAXB], a[MAXN], tag[MAXN], n, m, p, c, siz, tms[MAXN], ori[MAXN], notp[MAXV+5], phi[MAXV+5], prime[MAXV+5];
int id[MAXV+5], _c[150][GSM+5], __c[150][GSM+5], ccc, cntp, _b[150][GSM+5], __b[150][GSM+5];
struct Node {int x, flag;};
void read(int &x) {
	char ch; while(ch = getchar(), ch < '!'); x = ch - 48;
	while(ch = getchar(), ch > '!') x = (x << 3) + (x << 1) + ch - 48;
}
void write(int x) {if(x > 9) write(x / 10); putchar(x % 10 + 48);}
int Getphi(int x) {
	int ans = x;
	for(int i = 2; i * i <= x; ++i)
		if(x % i == 0) {
			ans = ans / i * (i-1);
			while(x % i == 0) x /= i;
		}
	if(x > 1) ans = ans / x * (x-1);
	return ans;
}
void init(int P) {
	id[P] = ++ccc; _c[id[P]][0] = __c[id[P]][0] = 1;
	for(int i = 1; i <= GSM; ++i) {
		_c[id[P]][i] = 1ll*_c[id[P]][i-1]*c%P;
		_b[id[P]][i] = (_b[id[P]][i-1] || _c[id[P]][i-1]*c >= P);
	}
	__c[id[P]][1] = _c[id[P]][GSM]; __b[id[P]][1] = _b[id[P]][GSM];
	for(int i = 2; i <= GSM; ++i) {
		__c[id[P]][i] = 1ll*__c[id[P]][i-1]*__c[id[P]][1]%P;
		__b[id[P]][i] = (__b[id[P]][i-1] || __c[id[P]][i-1]*_c[id[P]][1] >= P);
	}
}
Node pwc(int b, int P) {
	return (Node) {1ll*__c[id[P]][b/GSM]*_c[id[P]][b%GSM]%P, __b[id[P]][b/GSM]||_b[id[P]][b%GSM]||__c[id[P]][b/GSM]*_c[id[P]][b%GSM]>=P};
}
Node getans(int x, int t, int P) {
	if(!t) return (Node) {x%P, x>=P};
	if(P == 1) return (Node) {0, 1};
	Node tmp = getans(x, t-1, phi[P]);
	int b = tmp.x + phi[P] * tmp.flag;
	return pwc(b, P);
}
void update(int b) {for(int i = L(b); i <= R(b); ++i) s[b] = (s[b] + a[i]) % p;}
void modify(int i) {
	s[bl(i)] -= a[i]; ++tms[i];
	a[i] = getans(ori[i], tms[i], p).x;
	s[bl(i)] += a[i]; s[bl(i)] = (s[bl(i)] + p) % p;
}
void work(int b) {
	if(tag[b]) return; tag[b] = 1;
	for(int i = L(b); i <= R(b); ++i) {
		int t = a[i]; modify(i);
		if(t != a[i]) tag[b] = 0;
	}
}
int main() {
	read(n); read(m); read(p); read(c); siz = max(1.0, sqrt(n/log2(n)));
	int tmp = p;
	for(; tmp > 1; tmp = phi[tmp]) phi[tmp] = Getphi(tmp), init(tmp); init(1);
	for(int i = 1; i <= n; ++i) read(a[i]), ori[i] = a[i];
	for(int i = 1; i <= bl(n); ++i) update(i);
	for(int opt, l, r; m--; ) {
		read(opt); read(l); read(r);
		if(!opt) {
			if(bl(l) == bl(r))
				for(int i = l; i <= r; ++i) modify(i);
			else {
				for(int i = l; i <= R(bl(l)); ++i) modify(i);
				for(int i = bl(l)+1; i <= bl(r)-1; ++i) work(i);
				for(int i = L(bl(r)); i <= r; ++i) modify(i);
			}
		} else {
			if(bl(l) == bl(r)) {
				int res = 0;
				for(int i = l; i <= r; ++i) res = (res + a[i]) % p;
				write(res); putchar('\n');
			} else {
				int res = 0;
				for(int i = l; i <= R(bl(l)); ++i) res = (res + a[i]) % p;
				for(int i = bl(l)+1; i <= bl(r)-1; ++i) res = (res + s[i]) % p;
				for(int i = L(bl(r)); i <= r; ++i) res = (res + a[i]) % p;
				write(res); putchar('\n');
			}
		}
	}
}
```

---

## 作者：_WA自动机 (赞：6)

更好的阅读体验点[这里](https://wa-automaton.github.io/2019/03/18/%E4%B9%9D%E7%9C%81%E8%81%94%E8%80%832018-%E7%9B%B8%E9%80%A2%E6%98%AF%E9%97%AE%E5%80%99/)~
## 题目大意
> Informatik verbindet dich und mich.  
> 信息将你我连结。 

维护一个数列A，支持两种操作：
* 0 l r ：表示将A[l..r]这个区间的每个数$A_i$变成$c^{A_i}$（c是输入给定的常量）
* 1 l r : 表示求$A[l..r]$的和，结果对p（输入给定的常量）取模。

## 数据范围与约定
* 对于 100% 的测试点， $1 \leq n \leq 50000; 1 \leq m \leq 50000; 1 \leq p \leq 100000000; 0 < c <p; 0 \leq ai < p$。

## 解法
观察数据范围，$n,m\leq 50000$。这个~~不伦不类的~~范围应该是$O(n \log n \log C)$之类的吧？  
还有区间求和...?线段树？  
不知道大家有没有做过线段树区间取模和区间开方之类维护奇怪运算的题？它们有一个共同点：暴力递归到叶子节点修改，因为运算的特殊性质决定了修改次数不超过$O(n\log C)$，所以复杂度正确。
考虑这个奇怪的运算。现在我们要解决的问题就是如何快速（$O(\log\ n)$以内）求这个：
$$\LARGE{c^{c^{c^{c^{...a_i}}}}}$$
不知道您有没有做过[这个题](https://www.luogu.org/problemnew/show/P4139)，如果没有珂以去做一下qwq.  
做完了吧？那现在您一定会了欧拉定理：  
$$a^b \bmod p=\left \{  \begin{aligned}  &a^{b \bmod \phi (p) +\phi(p)} &b\geq \phi (p)\\  &a^b &b<\phi (p)  \end{aligned} \right.  $$

> 引理：对于一个数$n\in \mathbb N^*$，一直取$\phi (n)$,最多取$O(\log n)$次就会变成1.  
> 简要证明：对于偶数，所有偶数都与它不互质。取$\phi (n)$至少会除以2.对于奇数，考虑定义式，它一定会变成偶数。所以最多$2\log n$次会变成1.

所以当修改次数太大的时候，从某一层开始，模数都是1.这就没必要算了。所以用区间开方的思路，线段树记录区间和、区间修改次数。修改次数超过最大值时忽略修改。否则继续递归。每递归到叶子节点时，暴力修改叶子的值。顺便维护区间和。这时，总复杂度是$O(n \log^2 n\log C)$的。不太能承受。但是我们发现计算过程中模数只有$O(\log n)$种取值，所以光速幂预处理一下，就可以少掉一个log啦。然后就珂以愉快地通过本题啦。我人丑自带大常数，所以好像还要wys~~或者mcfx~~一下代码
## 代码：
略丑qwq见谅
```cpp
#pragma GCC optimize("-Ofast")
#pragma GCC optimize(3)
#include <cstdio>
#include <cctype>
#include <cmath>
#include <utility>
#define ls l,mid,o<<1
#define rs mid+1,r,o<<1|1

using std::pair;
using std::make_pair;

typedef long long ll;

const int maxn=(5e4+100)*2;

int a[maxn<<2],count[maxn<<2],P,c,maxlim;
ll sumv[maxn<<2];
int phi[maxn],Sqrt[maxn];

char buf[1<<24],*fs;
ll c_sqrt[150][maxn],c_x[150][maxn];
bool is_greater[100][maxn],is_greater_sqrt[100][maxn];

// #define gc() getchar()
#define gc() (*fs++)

template<class T>inline T max(T a,T b){return a<b?b:a;}
template<class T>inline T min(T a,T b){return a<b?a:b;}

inline int read()
{
    char ch;
    while (!isdigit(ch=gc()));
    int x=ch^48;
    while (isdigit(ch=gc())) x=x*10+ch-48;
    return x;
}

inline pair<ll,bool> qpow(ll a,ll b,ll P)
{
    ll ans=1%P;
    bool gr=false;
    for (;b;b>>=1)
    {
        if (b&1) ans=ans*a;
        if (ans>=P) ans%=P,gr=true;
        a=a*a%P;
    }
    return make_pair(ans,gr);
}

inline void CalcPower(int x,int now)
{
    int T=Sqrt[now]=sqrt(x);
    c_x[now][0]=1;c_x[now][1]=c;
    c_sqrt[now][0]=1;pair<ll,bool> pr=qpow(c,T,x);c_sqrt[now][1]=pr.first;
    if (c_x[now][1]>=x) is_greater[now][1]=true,c_x[now][1]%=x;
    if (pr.second) is_greater_sqrt[now][1]=true;
    if (c_x[now][0]>=x) is_greater[now][0]=true,c_x[now][0]%=x;
    if (c_sqrt[now][0]>=x) is_greater_sqrt[now][0]=true,c_sqrt[now][0]%=x;
    for (int i=2;i<=T*2;++i)
    {
        c_x[now][i]=c_x[now][i-1]*c;
        c_sqrt[now][i]=c_sqrt[now][i-1]*c_sqrt[now][1];
        if (c_x[now][i]>=x) is_greater[now][i]=true,c_x[now][i]%=x;
        if (c_sqrt[now][i]>=x) is_greater_sqrt[now][i]=true,c_sqrt[now][i]%=x;
    }
}

inline pair<ll,bool> Fastpow(int b,int now)
{
    ll t=c_x[now][b%Sqrt[now]]*c_sqrt[now][b/Sqrt[now]];
    bool flag=is_greater[now][b%Sqrt[now]]|is_greater_sqrt[now][b/Sqrt[now]];
    if (t>=phi[now]) flag=true,t%=phi[now];
    return make_pair(t,flag);
}

inline int Getphi(int x)
{
    int ret=x;
    for (int i=2;i<=x;++i)
    {
        if (x%i==0)
        {
            while (x%i==0) x/=i;
            ret=ret/i*(i-1);
        }
    }
    if (x>1) ret=ret/x*(x-1);
    return ret;
}

inline void Prework(int P,int i=1)
{
    ++maxlim;
    if (P==1) phi[i]=1;
    CalcPower(phi[i]=Getphi(P),i);
    if (P==1) return;
    Prework(phi[i],i+1);
}

inline ll CalcNumber(int expo,int depth,int limit)
{
    // if (phi[depth-1]==1) return 0;
    if (depth==limit+1) return expo>phi[limit]?expo%phi[limit]+phi[limit]:expo;
    int t=CalcNumber(expo,depth+1,limit);
    pair<ll,bool> pr=Fastpow(t,depth-1);
    // printf("depth=%d ,exp=%d\n",depth,pr.second?pr.first+phi[depth-1]:pr.first);
    if (pr.second==1) return pr.first+phi[depth-1];
    return pr.first;
}

inline void Pushup(int o)
{
    sumv[o]=sumv[o<<1]+sumv[o<<1|1];
    if (sumv[o]>=P) sumv[o]-=P;
}

inline void BuildSeg(int l,int r,int o)
{
    if (l==r) return void(sumv[o]=a[l]);
    int mid=(l+r)>>1;
    BuildSeg(ls);BuildSeg(rs);
    Pushup(o);
}

inline void Modify(int L,int R,int l,int r,int o)
{
    if (count[o]>=maxlim) return;
    if (l==r)
    {
        ++count[o];
        sumv[o]=CalcNumber(a[l],1,count[o])%P;
        // printf("pos=%d num=%d\n",l,sumv[o]);
        return;
    }
    int mid=(l+r)>>1;
    if (L<=mid) Modify(L,R,ls);
    if (R> mid) Modify(L,R,rs);
    Pushup(o);
    count[o]=min(count[o<<1],count[o<<1|1]);
}

inline int Query(int L,int R,int l,int r,int o)
{
    if (L<=l && R>=r) return sumv[o];
    int mid=(l+r)>>1;
    int tot=0;
    if (L<=mid) tot+=Query(L,R,ls);
    if (R> mid) tot+=Query(L,R,rs);
    if (tot>=P) tot-=P;
    return tot;
}

int main()
{
    fread(fs=buf,1,1<<24,stdin);
    int n=read(),m=read();phi[0]=P=read(),c=read();Sqrt[0]=sqrt(P);
    CalcPower(P,0);
    for (int i=1;i<=n;++i) a[i]=read();
    Prework(P);BuildSeg(1,n,1);
    for (int i=1,opt,l,r;i<=m;++i)
    {
        opt=read();l=read();r=read();
        if (opt) printf("%d\n",Query(l,r,1,n,1));
        else Modify(l,r,1,n,1);
    }
}
```

---

## 作者：yhy2024 (赞：3)

考虑线段树 + [欧拉定理](https://cn.bing.com/search?q=%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86\&qs=n\&form=QBRE\&sp=-1\&lq=0\&pq=%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86\&sc=12-4\&sk=\&cvid=4D86A1CE97B247CFB72372D9F961D275\&ghsh=0\&ghacc=0\&ghpl=)。

难点在修改操作，修改后长这样：$c^{c^{c^{....}}}$, 和[上帝与集合的正确用法](https://www.luogu.com.cn/problem/P4139)很像。

根据上帝与集合的正确用法的思路，考虑单点修改，可以证明一个点最多被修改 $\log_p$ 次，就不再改变，势能分析复杂度为 3 只 $\log$ 会 T, 用光速幂，预处理后，$\operatorname{O(1)}$ 查询，降到 2 只 $\log$

hack 数据好像 hack 的是这个：对于 $\gcd(a,m)=1\;a^c\equiv a^{c\ \bmod\phi(m)} (\bmod m)$

```cpp
#include<bits/stdc++.h>
#define ll long long
#define N 50005
#define bl 10005
#define gcd __gcd
using namespace std;
ll a[N],phi[1005],cnt,md,x,f[10020][105][2],c,p,n,m,op,l,r;
ll tr[N*4],vis[N*4];
bool flag,fl[10020][105][2];
int get(ll x){//求phi(x)
	ll ans=1,num=1;
	for(ll i=2;i*i<=x;i++){
		if(!(x%i)){
			num=i-1,x/=i;
			while(!(x%i)) num=num*i,x/=i;
			ans=num*ans;
		}
	}
	if(x!=1) ans=ans*(x-1);
	return ans;
} 
void init(){//光速幂初始化，cnt是修改多少次修改变得无意义
	ll x=md;
	phi[0]=x;
	while(x>1){
		x=get(x);
		phi[++cnt]=x;
	} 
	phi[++cnt]=1;
	for(int i=0;i<=cnt;i++){
		f[0][i][0]=1;
		for(int j=1;j<=bl;j++){
			f[j][i][0]=f[j-1][i][0]*c;
			if(f[j][i][0]>=phi[i]) f[j][i][0]%=phi[i],fl[j][i][0]=1;
			fl[j][i][0]|=fl[j-1][i][0];
		}
	}
	for(int i=0;i<=cnt;i++){
		f[0][i][1]=1;
		for(int j=1;j<=bl;j++){
			f[j][i][1]=f[j-1][i][1]*f[bl][i][0];
			if(f[j][i][1]>=phi[i]) f[j][i][1]%=phi[i],fl[j][i][1]=1;
			fl[j][i][1]|=fl[j-1][i][1];
		}
	}
}
ll Pow(ll a,ll b){
	flag|=fl[a%bl][b][0]|fl[a/bl][b][1];
	ll res=f[a%bl][b][0]*f[a/bl][b][1];
	if(res>=phi[b]) res%=phi[b],flag=1;
	return res;
}
ll add(ll a,ll b,ll dep){//单点修改
	flag=0;
	if(dep==b){
		if(gcd(c,phi[dep-1])==1) return a%phi[dep]; 
		if(a>=phi[dep]){	
			flag=1;
			return a%phi[dep]+phi[dep];
		}
		return a; 
	}	
	ll x=add(a,b,dep+1);
	if(gcd(c,phi[dep])==1) x%=phi[dep+1],flag=0; 
	else if(flag) x+=phi[dep+1],flag=0;
	return Pow(x,dep); 
} 
void pushup(int k){//vis存区间最少被修改的次数
	tr[k]=(tr[k<<1]+tr[k<<1|1])%md;
	vis[k]=min(vis[k<<1],vis[k<<1|1]);
}
void build(int k,int l,int r){
	if(l==r){
		tr[k]=a[l];
		return;
	}
	int mid=(l+r)>>1;
	build(k<<1,l,mid);
	build(k<<1|1,mid+1,r);
	pushup(k);
}
ll query(int k,int l,int r,int x,int y){
	if(l>y||r<x) return 0;
	if(x<=l&&r<=y) return tr[k];
	int mid=(l+r)>>1;
	ll ans=(query(k<<1,l,mid,x,y)%md+query(k<<1|1,mid+1,r,x,y)%md)%md;
	return ans; 
}
void modify(int k,int l,int r,int x,int y){
	if(vis[k]>=cnt||((l>y||r<x))) return;//如果都大于cnt就跳过
	if(l==r){
		vis[k]++;
		tr[k]=add(a[l],vis[k],0);
		return;
	}
	int mid=(l+r)>>1;
	modify(k<<1,l,mid,x,y);
	modify(k<<1|1,mid+1,r,x,y);
	pushup(k); 
}
int main(){
	scanf("%lld%lld%lld%lld",&n,&m,&md,&c);
	init();
	for(int i=1;i<=n;i++){
		scanf("%lld",&a[i]);
	}
	build(1,1,n);
	for(int i=1;i<=m;i++){
		scanf("%lld%lld%lld",&op,&l,&r);
		if(op==0) modify(1,1,n,l,r);
		else printf("%lld\n",query(1,1,n,l,r));
	}
	return 0;
}
```

---

## 作者：freoepn (赞：0)

建议先做 [P4139 上帝与集合的正确用法](https://www.luogu.com.cn/problem/P4139) 再来做此题。

通过  [P4139 上帝与集合的正确用法](https://www.luogu.com.cn/problem/P4139) 可以知道，每一个元素顶多操作 $O(\log)$ 就会恒定不变，考虑把问题丢到线段树上，也就是说每个叶子顶多被到达  $O(\log)$ 次，记录下每个区间里被访问次数最少的元素即可 $O(\log^2)$ 实现修改查询。

然后考虑预处理出第 $i$ 个元素被操作 $j$ 次后得到的数 $a_{i,j}$，这部分和 [P4139 上帝与集合的正确用法](https://www.luogu.com.cn/problem/P4139) 基本相同，只是快速幂会导致复杂度多一个 $\log$，无法通过，考虑到不同的底数只有 $\log$ 个，可以把指数写成 $2^{15}$ 进制的形式，预处理出每一个底数每一位为多少时幂是多少，即可实现 $O(1)$ 快速幂，可以通过本题。


```cpp
#include <bits/stdc++.h>
using namespace std;
const int kMaxN = 50005, kMaxM = 1 << 15;
int qp[60][kMaxM + 1][2];
vector<int> v;
int qpow(int x, int p) {
 // cout << x << "?"<< p <<" "<<  qp[p][x % kMaxM][0] << " "<<  qp[p][x / kMaxM][1] <<" "<< x / kMaxM<<   '\n';
  return ((long long)qp[p][x % kMaxM][0] * qp[p][x / kMaxM][1] >= v[p] ? (long long)qp[p][x % kMaxM][0] * qp[p][x / kMaxM][1] % v[p] + v[p] : (long long)qp[p][x % kMaxM][0] * qp[p][x / kMaxM][1]);
}
int n, m, mod, c;
int getphi(int x) {
  int y = x, z = x;
  for (int i = 2; i * i <= x; ++i) {
    if (y % i == 0) {
      while (!(y % i)) {
        y /= i;
      }
      z = z / i * (i - 1);
    }
  }
  if (y > 1) {
    z = z / y * (y - 1);
  }
  return z;
}
int getpow(int x, int y, int z) {
 //  cout << x << " "<< y << " "<< z <<" "<< v[z]<<  '\n';
  if (y == 0) {
    //cout << (x < v[z] ? x : x % v[z] + v[z])<< '\n';
    return x < v[z] ? x : x % v[z] + v[z];
  }
  if (z == v.size() - 1) {
    return c;
  }
 //  cout << x << " "<< y << " "<< z << '\n';
  return qpow(getpow(x, y - 1, z + 1), z);
}
int a[kMaxN][60];
int tr[4 * kMaxN], trr[4 * kMaxN];
void build(int x, int l, int r) {
  if (l == r) {
    tr[x] = a[l][0];
    return;
  }
  int mid = (l + r) >> 1;
  build(x <<  1, l, mid), build(x<< 1 | 1, mid + 1, r);
  tr[x] = (tr[x << 1] + tr[x << 1 | 1]) % mod;
}
void change(int x, int l, int r, int ql, int qr) {
  if (trr[x] >= v.size()) {
    return;
  }
  if (l == r) {
    trr[x]++, tr[x] = a[l][trr[x]];
   // cout << tr[x]<< "!"<< l << " "<< r << '\n';
    return;
  }
  int mid = (l + r) / 2;
  if (ql <= mid) {
    change(x << 1, l, mid, ql, qr);
  }
  if (qr > mid) {
    change(x << 1 | 1, mid + 1, r, ql, qr);
  }
  tr[x] = (tr[x << 1] + tr[x <<1 | 1]) % mod;
  trr[x] = min(trr[x << 1], trr[x << 1 | 1]);
}
int query(int x, int l, int r, int ql, int qr) {
  if (ql <= l && r <= qr) {
    return tr[x];
  }
  int mid = (l + r) / 2, ans = 0;
  if (ql <= mid) {
    ans += query(x << 1, l, mid, ql, qr);
  }
  if (qr > mid) {
    ans += query(x << 1 | 1, mid + 1, r, ql, qr);
  }
  return ans % mod;
}
int main() {
  ios::sync_with_stdio(0);
  cin.tie(0),cout.tie(0);
  cin >> n >> m >> mod >> c;
  int modd = mod;
  while (1) {
    v.push_back(mod);
    if (mod <= 1) break;
    mod = getphi(mod);
  }
  mod = modd;
 //for(int i = 0;i < v.size();i++){
 //  cout << v[i]<< " ";
 //}
 //cout << '\n';
  for (int j = 0; j < v.size(); j++) {
    qp[j][0][0] = qp[j][0][1] = 1;
    for (int i = 1; i <= kMaxM; i++) {
      qp[j][i][0] = ((long long)qp[j][i - 1][0] * c >= v[j] ? (long long)qp[j][i - 1][0] * c % v[j] + v[j] : (long long)qp[j][i - 1][0] * c);
    }
    qp[j][1][1] = qp[j][kMaxM][0];
    // cout << qp[j][kMaxM][0] << '\n';
    for (int i = 2; i <= kMaxM; i++) {
    // if(i == 2){
    //   cout<< j << " "<< i  <<"!!!!!!!!!!"<<qp[j][i - 1][1] << " "<<  qp[j][1][1]<<" "<< ((long long)qp[j][i - 1][1] * qp[j][1][1])<<  '\n';
    // }
      qp[j][i][1] = ((long long)qp[j][i - 1][1] * qp[j][1][1] >= v[j]?(long long)qp[j][i - 1][1] * qp[j][1][1]  % v[j]+v[j]:(long long)qp[j][i - 1][1] * qp[j][1][1]);
    }
  }
  for (int i = 1; i <= n; i++) {
    cin >> a[i][0];
    for (int j = 1; j <= v.size(); j++) {
      a[i][j] = getpow(a[i][0], j, 0) % mod;
     // cout << i << " "<< j << ":"<< a[i][j]<< '\n';
    }
    a[i][0] %= mod;
  }
  build(1, 1, n);
  while (m--) {
    int p, l, r;
    cin >> p >> l >> r;
    if (!p) {
      change(1, 1, n, l, r);
    } else {
      cout << query(1, 1, n, l, r) << '\n';
    }
  }
  return 0;
}
```

---


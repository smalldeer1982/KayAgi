# 【模板】任意模数多项式乘法

## 题目背景

模板题，无背景

## 题目描述

给定 $2$ 个多项式 $F(x), G(x)$ ，请求出 $F(x) * G(x)$。    

**系数对 $p$ 取模**，且**不保证** $p$ 可以分解成 $p = a \cdot 2^k + 1$ 之形式。

## 说明/提示

对于 $100 \%$ 的数据，$1 \leq n, m \leq 10^5$，$0 \leq a_i, b_i \leq 10^9$，$2 \leq p \leq 10^9 + 9$。

## 样例 #1

### 输入

```
5 8 28
19 32 0 182 99 95
77 54 15 3 98 66 21 20 38```

### 输出

```
7 18 25 19 5 13 12 2 9 22 5 27 6 26```

# 题解

## 作者：Memory_of_winter (赞：82)

[我的博客](https://www.cnblogs.com/Memory-of-winter/p/10223844.html)

**题目大意：**给你两个多项式$f(x)$和$g(x)$以及一个模数$p(p\leqslant10^9)$，求$f*g\pmod p$

**题解：**任意模数$NTT$，最大的数为$p^2\times\max\{n,m\}\leqslant10^{23}$，所以一般选$3$个模数即可，求出这三个模数下的答案，然后中国剩余定理即可。

假设这一位的答案是$x$，三个模数分别为$A,B,C$，那么：

$$\begin{aligned}x\equiv x_1\pmod{A} \\ x\equiv x_2\pmod{B} \\ x\equiv x_3\pmod{C}\end{aligned}$$

先把前两个合并：

$$\begin{aligned}x_1+k_1A=x_2+k_2B\\x_1+k_1A\equiv x_2\pmod{B}\\k_1\equiv \frac{x_2-x_1}A\pmod{B}\end{aligned}$$

于是求出了$k_1$，也就求出了$x\equiv x_1+k_1A\pmod{AB}$，记$x_4=x_1+k_1A$

$$\begin{aligned}x_4+k_4AB=x_3+k_3C\\x_4+k_4AB\equiv x_3\pmod{C}\\k_4\equiv \dfrac{x_3-x_4}{AB}\pmod{C}\end{aligned}$$

求出了$k_4$，$x\equiv x_4+k_4AB\pmod{ABC}$，因为$x<ABC$，所以$x=x_4+k_4AB$



**C++ Code：**

```cpp
#include <algorithm>
#include <cstdio>
#include <cstring>
int mod;
namespace Math {
	inline int pw(int base, int p, const int mod) {
		static int res;
		for (res = 1; p; p >>= 1, base = static_cast<long long> (base) * base % mod) if (p & 1) res = static_cast<long long> (res) * base % mod;
		return res;
	}
	inline int inv(int x, const int mod) { return pw(x, mod - 2, mod); }
}

const int mod1 = 998244353, mod2 = 1004535809, mod3 = 469762049, G = 3;
const long long mod_1_2 = static_cast<long long> (mod1) * mod2;
const int inv_1 = Math::inv(mod1, mod2), inv_2 = Math::inv(mod_1_2 % mod3, mod3);
struct Int {
	int A, B, C;
	explicit inline Int() { }
	explicit inline Int(int __num) : A(__num), B(__num), C(__num) { }
	explicit inline Int(int __A, int __B, int __C) : A(__A), B(__B), C(__C) { }
	static inline Int reduce(const Int &x) {
		return Int(x.A + (x.A >> 31 & mod1), x.B + (x.B >> 31 & mod2), x.C + (x.C >> 31 & mod3));
	}
	inline friend Int operator + (const Int &lhs, const Int &rhs) {
		return reduce(Int(lhs.A + rhs.A - mod1, lhs.B + rhs.B - mod2, lhs.C + rhs.C - mod3));
	}
	inline friend Int operator - (const Int &lhs, const Int &rhs) {
		return reduce(Int(lhs.A - rhs.A, lhs.B - rhs.B, lhs.C - rhs.C));
	}
	inline friend Int operator * (const Int &lhs, const Int &rhs) {
		return Int(static_cast<long long> (lhs.A) * rhs.A % mod1, static_cast<long long> (lhs.B) * rhs.B % mod2, static_cast<long long> (lhs.C) * rhs.C % mod3);
	}
	inline int get() {
		long long x = static_cast<long long> (B - A + mod2) % mod2 * inv_1 % mod2 * mod1 + A;
		return (static_cast<long long> (C - x % mod3 + mod3) % mod3 * inv_2 % mod3 * (mod_1_2 % mod) % mod + x) % mod;
	}
} ;

#define maxn 131072

namespace Poly {
#define N (maxn << 1)
	int lim, s, rev[N];
	Int Wn[N | 1];
	inline void init(int n) {
		s = -1, lim = 1; while (lim < n) lim <<= 1, ++s;
		for (register int i = 1; i < lim; ++i) rev[i] = rev[i >> 1] >> 1 | (i & 1) << s;
		const Int t(Math::pw(G, (mod1 - 1) / lim, mod1), Math::pw(G, (mod2 - 1) / lim, mod2), Math::pw(G, (mod3 - 1) / lim, mod3));
		*Wn = Int(1); for (register Int *i = Wn; i != Wn + lim; ++i) *(i + 1) = *i * t;
	}
	inline void NTT(Int *A, const int op = 1) {
		for (register int i = 1; i < lim; ++i) if (i < rev[i]) std::swap(A[i], A[rev[i]]);
		for (register int mid = 1; mid < lim; mid <<= 1) {
			const int t = lim / mid >> 1;
			for (register int i = 0; i < lim; i += mid << 1) {
				for (register int j = 0; j < mid; ++j) {
					const Int W = op ? Wn[t * j] : Wn[lim - t * j];
					const Int X = A[i + j], Y = A[i + j + mid] * W;
					A[i + j] = X + Y, A[i + j + mid] = X - Y;
				}
			}
		}
		if (!op) {
			const Int ilim(Math::inv(lim, mod1), Math::inv(lim, mod2), Math::inv(lim, mod3));
			for (register Int *i = A; i != A + lim; ++i) *i = (*i) * ilim;
		}
	}
#undef N
}

int n, m;
Int A[maxn << 1], B[maxn << 1];
int main() {
	scanf("%d%d%d", &n, &m, &mod); ++n, ++m;
	for (int i = 0, x; i < n; ++i) scanf("%d", &x), A[i] = Int(x % mod);
	for (int i = 0, x; i < m; ++i) scanf("%d", &x), B[i] = Int(x % mod);
	Poly::init(n + m);
	Poly::NTT(A), Poly::NTT(B);
	for (int i = 0; i < Poly::lim; ++i) A[i] = A[i] * B[i];
	Poly::NTT(A, 0);
	for (int i = 0; i < n + m - 1; ++i) {
		printf("%d", A[i].get());
		putchar(i == n + m - 2 ? '\n' : ' ');
	}
	return 0;
}

```



---

## 作者：Kewth (赞：46)

惊奇地发现你谷竟然没有 4 次 FFT 的 MTT 的题解。

拆系数就不说了，把两个多项式 $A(x), B(x)$ 分别拆成 $A_0(x), A_1(x)$ 和$B_0(x), B_1(x)$ 后，考虑求出它们的点值表示，也就是做 DFT 。  
朴素地做 DFT 需要 4 次，但是由于这些多项式虚部都为 0 ，可以考虑将两次 DFT 合并成一次。

例如要给两个多项式 $A, B$ 做 DFT ，考虑构造两个多项式：

$$P(x) = A(x) + i B(x)$$
$$Q(x) = A(x) - i B(x)$$

那么由于 $A, B$ 的虚部都为 0 ，$P, Q$ 的每一项系数都互为共轭，同样每一个点值也互为共轭。  
那么只需对 $P$ 做一次 DFT ，就可以通过共轭 $O(n)$ 求出 $Q$ 的点值表示。  
然后通过 $P, Q$ 的点值表示求 $A, B$ 的点值表示就是解上面的二元二次方程组，也是可以 $O(n)$ 做到的。

于是就可以用两次 DFT 求出 $A_0, A_1, B_0, B_1$ 的点值表示。

接下来需要求 $A, B$ 之间的两两乘积。直接乘出来后要对 $A_0 B_0, A_0 B_1, A_1 B_0, A_1 B_1$ 四个多项式做 IDFT 。  
并且这时候它们的虚部并不为 0 ，不能用上述的方法。

但是上述方法的思想仍可借鉴，考虑构造两个多项式：

$$P(x) = A_0(x) B_0(x) + i A_1(x) B_0(x)$$
$$Q(X) = A_0(x) B_1(x) + i A_1(x) B_1(x)$$

通过已知的点值求出此时 $P, Q$ 的点值，然后分别对 $P, Q$ 做 IDFT ，  
由于 $A_0 B_0, A_0 B_1, A_1 B_0, A_1 B_1$ 这四个多项式卷起来后的系数表示中虚部一定为 0 ，  
那么此时 $P$ 的实部和虚部就分别为 $A_0(x) B_0(x)$ 和 $A_1(x) B_0(x)$ ，
同样 $Q$ 的实部和虚部就分别为 $A_0(x) B_1(x)$ 和 $A_1(x) B_1(x)$ 。

参考实现：

```cpp
#include <cstdio>
#include <complex>
#define debug(...) fprintf(stderr, __VA_ARGS__)

typedef long long lolong;
typedef std::complex<double> complex;

inline int input() { int x; scanf("%d", &x); return x; }
inline lolong linput() { lolong x; scanf("%lld", &x); return x; }

const int maxn = 400005, maxk = 20;
const complex I(0, 1);
int R[maxn];
complex Wn[maxn];

void FFT(complex *A, int n, int t) {
	if(t == -1)
		for(int i = 1; i < n; i ++)
			if(i < (n - i))
				std::swap(A[i], A[n - i]);
	for(int i = 0; i < n; i ++)
		if(i < R[i])
			std::swap(A[i], A[R[i]]);

	for(int m = 1, l = 0; m < n; m <<= 1, l ++) {
		/* complex Wn(cos(M_PI / m), sin(M_PI / m) * t); */
		for(int i = 0; i < n; i += m << 1) {
			/* complex W = 1; */
			for(int k = i; k < i + m; k ++) {
				/* complex W(cos(M_PI / m * (k - i)), sin(M_PI / m * (k - i)) * t); */
				complex W = Wn[1ll * (k - i) * n / m];
				/* if(t == -1) W = std::conj(W); */
				complex a0 = A[k], a1 = A[k + m] * W;
				A[k] = a0 + a1;
				A[k + m] = a0 - a1;
				/* W *= Wn; */
			}
		}
	}

	if(t == -1)
		for(int i = 0; i < n; i ++)
			A[i] /= n;
}

int mod;
inline lolong num(complex x) {
	double d = x.real();
	return d < 0 ? lolong(d - 0.5) % mod : lolong(d + 0.5) % mod;
}

inline void FFTFFT(complex *a, complex *b, int len, int t) {
	for(int i = 0; i < len; i ++)
		a[i] = a[i] + I * b[i];
	FFT(a, len, t);
	for(int i = 0; i < len; i ++)
		b[i] = std::conj(a[i ? len - i : 0]);
	for(int i = 0; i < len; i ++) {
		complex p = a[i], q = b[i];
		a[i] = (p + q) * 0.5;
		b[i] = (q - p) * 0.5 * I;
	}
}

complex a0[maxn], a1[maxn], b0[maxn], b1[maxn];
/* complex a0b0[maxn], a1b0[maxn], a0b1[maxn], a1b1[maxn]; */
complex p[maxn], q[maxn];

int main() {
	int n = input(), m = input();
	mod = input();
	int M = int(sqrt(mod) + 1);

	for(int i = 0; i <= n; i ++) {
		int x = input() % mod;
		a0[i] = x / M;
		a1[i] = x % M;
	}
	for(int i = 0; i <= m; i ++) {
		int x = input() % mod;
		b0[i] = x / M;
		b1[i] = x % M;
	}

	int len = 1;
	while(len < n + m + 1)
		len <<= 1;

	for(int i = 1; i < len; i ++)
		R[i] = R[i >> 1] >> 1 | ((i & 1) * (len >> 1));

	for(int i = 0; i < len; i ++)
		Wn[i] = complex(cos(M_PI / len * i), sin(M_PI / len * i));

	FFTFFT(a0, a1, len, 1);
	FFTFFT(b0, b1, len, 1);

	for(int i = 0; i < len; i ++) {
		p[i] = a0[i] * b0[i] + I * a1[i] * b0[i];
		q[i] = a0[i] * b1[i] + I * a1[i] * b1[i];
	}

	FFT(p, len, -1);
	FFT(q, len, -1);

	for(int i = 0; i <= n + m; i ++)
		printf("%lld ", (M * M * num(p[i].real()) % mod +
				M * (num(p[i].imag()) + num(q[i].real())) % mod +
				num(q[i].imag())) % mod);
	puts("");
}
```


---

## 作者：command_block (赞：43)

一种奇怪的拆系数FFT?需要5次FFT但是推导很简单,便于记忆,常数也不大。

卷积后，能产生的最大的数也就是$mod*mod*len$,实战应用中一般是$10^9*10^9*10^5=10^{23}$。

我们只要弄一个精度够高的多项式乘法,就能做到不丢精度。

一种想法是:跑九次NTT(三次乘法),把答案用中国剩余定理合并,精度可达$10^{26}$

这种做法常数实在过大,而且$10^{26}$使用`long long`存不下,还需要一些黑科技辅助,所以不推荐。

另一种想法是:拆系数FFT。

把一个数拆成$a*2^{15}+b$的形式,那么$a,b<=2^{15}$

把$a$和$b$弄成两个多项式,这样相乘的值域是$n*mod≈10^{14}$

那么$c_1*c_2=(a_1*2^{15}+b_1)(a_2*2^{15}+b_2)$

$=a_1a_2*2^{30}+(a_1b_2+a_2b_1)2^{15}+b_1b_2$

那么就是要做$4$次多项式乘法?12次FFT?常数爆炸!

冷静分析:每个多项式只用插值一次,共4次。

点乘复杂度忽略,最后得到的四个多项式各插值一次,共4次。

这样就是8次FFT,常数还是爆炸……

我们考虑推推式子来优化:

我们有四个多项式$A1,A2,B1,B2$,求这些多项式的两两乘积。

考虑到$(a+bi)*(c+di)=a(c+di)*bi(c+di)=ac-bd+(ad+bc)i$

那么我们设复多项式$P=A1+iA2;\ Q=B1+iB2;$

那么$T1=P*Q=A1B1-A2B2+(A1B2+A2B1)i$

我们又设$P'=A1-iA2$

那么$T2=P'*Q=A1B1+A2B2+(A1B2-A2B1)i$

$T1+T2=2(A1B1+iA1B2)$,这样我们就求出了其中两个,减一减就能得到另外两个。

总的FFT次数是:3次DFT+2次IDFT=5次.

不过,值域并不是美好的$10^{14}$,而是$10^{19}$,因为在IDFT出来之前还得除以$n$……

`long double`信仰跑吧,代码并不难写。

```cpp
#include<algorithm>
#include<cstdio>
#include<cmath>
#define Maxn 100500
#define lim 32000
const long double Pi=acos(-1);
using namespace std;
inline int read()
{
  register int X=0;
  register char ch=0;
  while(ch<48||ch>57)ch=getchar();
  while(ch>=48&&ch<=57)X=X*10+(ch^48),ch=getchar();
  return X;
}
int n,m,p,tr[Maxn<<2];
struct CP
{
  long double x,y;
  CP operator + (const CP& B) const
  {return (CP){x+B.x,y+B.y};}
  CP operator - (const CP& B) const
  {return (CP){x-B.x,y-B.y};}
  CP operator * (const CP& B) const
  {return (CP){x*B.x-y*B.y,x*B.y+y*B.x};}
}P1[Maxn<<2],P2[Maxn<<2],Q[Maxn<<2];
void FFT(CP *f,int op,int n)
{
  for (int i=0;i<n;i++)
   if (i<tr[i])swap(f[i],f[tr[i]]);
  for(int p=2;p<=n;p<<=1){
    int len=p>>1;
    CP tmp=(CP){std::cos(Pi/len),op*std::sin(Pi/len)};
    for(int k=0;k<n;k+=p){
      CP buf=(CP){1,0};
      for(int l=k;l<k+len;l++){
        CP tt=buf*f[len+l];
        f[len+l]=f[l]-tt;
        f[l]=f[l]+tt;
        buf=buf*tmp;
      }//F(x)=FL(x^2)+x*FR(x^2)
       //F(W^k)=FL(w^k)+W^k*FR(w^k)
       //F(W^{k+n/2})=FL(w^k)-W^k*FR(w^k)
    }
  }
}
int ans[Maxn<<2];
int main()
{
  scanf("%d%d%d",&n,&m,&p);n++;m++;
  for (int i=0,sav;i<n;i++){
    sav=read();
    P1[i]=(CP){sav/lim,sav%lim};
    P2[i]=(CP){sav/lim,-sav%lim};
  }
  for (int i=0,sav;i<m;i++){
    sav=read();
    Q[i]=(CP){sav/lim,sav%lim};
  }
  int len=1;
  for (m=m+n-1;len<m;len<<=1);
  for (int i=1;i<len;i++)
    tr[i]=tr[i>>1]>>1|((i&1)?len>>1:0);
  FFT(P1,1,len);FFT(P2,1,len);FFT(Q,1,len);
  for (int i=0;i<len;i++){Q[i].x/=len;Q[i].y/=len;}
  for (int i=0;i<len;i++)P1[i]=P1[i]*Q[i];
  for (int i=0;i<len;i++)P2[i]=P2[i]*Q[i];
  FFT(P1,-1,len);FFT(P2,-1,len);
  for (int i=0;i<m;i++){
    long long a1b1=0,a1b2=0,a2b1=0,a2b2;
    a1b1=(long long)floor((P1[i].x+P2[i].x)/2+0.49)%p;
    a1b2=(long long)floor((P1[i].y+P2[i].y)/2+0.49)%p;
    a2b1=((long long)floor(P1[i].y+0.49)-a1b2)%p;
    a2b2=((long long)floor(P2[i].x+0.49)-a1b1)%p;
    ans[i]=((a1b1*lim+(a1b2+a2b1))*lim+a2b2)%p;
    ans[i]=(ans[i]+p)%p;
    printf("%d ",ans[i]);
  }return 0;
}
```

如果被卡,考虑预处理单位根。

目测常数是$NTT$的4倍……

---

## 作者：panda_2134 (赞：28)

其实这个题卡精度来着……我也没想到要开long double才能过……因为数据是用ddd的模板做的，他用的好像是合并dft精度比较高来着QAQ  
其实就是把每个数拆成 $a \cdot 32768 + b$ 的形式，然后乘起来再展开就可以了。当然你想要NTT合并也行qwq  
代码如下：
```cpp
#include <bits/stdc++.h>

typedef long long int64;
typedef long double D;

int MOD;
const int MAXN = 524288;
const D PI = acos(-1);

struct complex {
	D real, imag;
	complex() { real = imag = 0; }
	complex(D x): real(x), imag(0) {} 
	complex(D x, D y): real(x), imag(y) {}
	inline complex conj() { return complex(real, -imag); }
	inline complex operator+(complex rhs) const { return complex(real + rhs.real, imag + rhs.imag); }
	inline complex operator-(complex rhs) const { return complex(real - rhs.real, imag - rhs.imag); }
	inline complex operator*(complex rhs) const { return complex(real * rhs.real - imag * rhs.imag,
																 imag * rhs.real + real * rhs.imag); }
	inline complex operator*=(complex rhs) { return (*this) = (*this) * rhs; }
	//(a+bi)(c+di) = (ac-bd) + (bc+ad)i
	friend inline complex operator*(D x, complex cp) { return complex(x * cp.real, x * cp.imag); }
	inline complex operator/(D x) const { return complex(real / x, imag / x); }
	inline complex operator/=(D x) { return (*this) = (*this) / x; }
	friend inline complex operator/(D x, complex cp) { return x * cp.conj() / (cp.real * cp.real - cp.imag * cp.imag); }
	inline complex operator/(complex rhs) const { 
		return (*this) * rhs.conj() / (rhs.real * rhs.real - rhs.imag * rhs.imag); 
	}
	inline complex operator/=(complex rhs) { return (*this) = (*this) / rhs; }
	inline D length() { return sqrt(real * real + imag * imag); }
};

inline complex get_omega(int len, bool inv) {
	return inv ? complex(std::cos(2*PI / len), -std::sin(2*PI / len))
				:complex(std::cos(2*PI / len),  std::sin(2*PI / len));
}

inline void fft(int len, complex* A, bool inv = false) {
	static int R[MAXN+10];
	for(int i = 0; i < len; i++)
		R[i] = ((R[i>>1]>>1) | (len >> (i&1))) & (len-1);
	for(int i = 0; i < len; i++)
		if(R[i] > i) std::swap(A[i], A[R[i]]);
	for(int step = 1; step < len; step <<= 1) 
		for(int i = 0; i < len; i += (step<<1)) {
			complex omega = 1, t = 0, rt = get_omega(step<<1, inv);
			for(int j = 0; j < step; j++, omega *= rt) {
				t = A[i+j+step] * omega;
				A[i+j+step] = A[i+j] - t;
				A[i+j] = A[i+j] + t;
			}
		}
	if(inv)
		for(int i = 0; i < len; i++)
			A[i] /= len;
}

void mtt(int deg, int *lhs, int *rhs, int *ret) {
	static complex A[MAXN+10], B[MAXN+10], C[MAXN+10], D[MAXN+10],
				   E[MAXN+10], F[MAXN+10], G[MAXN+10], H[MAXN+10];
	int len; for(len = 1; len <= 2*deg; len<<=1);
	for(int i = 0; i < len; i++) {
		lhs[i] %= MOD; rhs[i] %= MOD;
		A[i] = lhs[i] >> 15; B[i] = lhs[i] & 0x7fff;
		C[i] = rhs[i] >> 15; D[i] = rhs[i] & 0x7fff;
	}
	fft(len, A); fft(len, B); fft(len, C); fft(len, D);
	for(int i = 0; i < len; i++) {
		E[i] = A[i] * C[i]; F[i] = B[i] * C[i];
		G[i] = A[i] * D[i]; H[i] = B[i] * D[i];
	}
	fft(len, E, true); fft(len, F, true); 
	fft(len, G, true); fft(len, H, true);
	for(int i = 0; i < len; i++)
		ret[i] = (((int64(round(E[i].real)) % MOD)<<30) % MOD + ((int64(round(F[i].real)) % MOD)<<15) % MOD
			+ ((int64(round(G[i].real)) % MOD)<<15) % MOD + int64(round(H[i].real)) % MOD) % MOD;
}

int deg, n, m, F[MAXN+10], G[MAXN+10], H[MAXN+10];

inline int readint() {
	int f=1, r=0; char c=getchar();
	while(!isdigit(c)) { if(c=='-')f=-1; c=getchar(); }
	while(isdigit(c)) { r=r*10+c-'0'; c=getchar(); }
	return f*r;
}

int main() {
	n = readint(); m = readint(); MOD = readint();
	for(int i = 0; i <= n; i++) 
		F[i] = readint();
	for(int i = 0; i <= m; i++)
		G[i] = readint();
	mtt(std::max(n, m), F, G, H);
	for(int i = 0; i <= n + m; i++)
		printf("%d ", H[i]);
}
```

---

## 作者：Prean (赞：26)

这是一个 $5$ 次 FFT 的做法，但是可以把 $4$ 次 FFT 吊起来锤。

我给同学讲了这种做法，他说这个做法吊打别的 $5$ 次 FFT，建议我发篇题解，那就发吧。。。

这种 $5$ 次 FFT 的做法不需要根据系数的关系解方程什么的，只需要设复多项式然后大力卷就行了。。。重要的是 $4$ 次 FFT 不能用转置但是这种 $5$ 次的可以。

假设我们要计算 $F(x)\times G(x)$。

设 $F(x)=A(x)+c\times B(x),G(x)=C(x)+c\times D(x)$，那么我们要求的就是：
$$A(x)C(x)+c\times(A(x)D(x)+B(x)C(x))+c^2\times B(x)D(x)$$
对比一下：
$$A(x)C(x),A(x)D(x)$$
$$B(x)C(x),B(x)D(x)$$
设 $T(x)=C(x)+i\times D(x)$，那么我们可以在 $A(x)T(x)$ 和 $B(x)T(x)$ 中找到我们需要的所有项。

需要对 $A(x),B(x),T(x)$ 做 DFT，$A(x)T(x)$ 和 $B(x)T(x)$ 做 IDFT，跑起来还是相当快的。

并且我使用这种 MTT 跑长度为 $2^{21}$ 的卷积时仍然没掉精度。
```cpp
#include<cstdio>
#include<cctype>
#include<cmath>
#define IMP(lim,act) for(int qwq=(lim),i=0;i^qwq;++i)act
typedef double db;
const int M=1<<18|5;
const db Pi=acos(-1);
int n,m,P,F[M],G[M],H[M];
struct Barrett{
	typedef unsigned long long ull;
	typedef __uint128_t LL;
	ull B,m;
	Barrett(const ull&m=2):m(m),B((LL(1)<<64)/m){}
	friend inline ull operator%(const ull&a,const Barrett&mod){
		ull r=a-mod.m*(LL(mod.B)*a>>64);return r>=mod.m?r-mod.m:r;
	}
}mod;
struct complex{
	db x,y;
	complex(const db&x=0,const db&y=0):x(x),y(y){}
	inline complex operator+(const complex&it)const{
		return complex(x+it.x,y+it.y);
	}
	inline complex operator-(const complex&it)const{
		return complex(x-it.x,y-it.y);
	}
	inline complex operator*(const complex&it)const{
		return complex(x*it.x-y*it.y,x*it.y+y*it.x);
	}
}buf[M<<1],*w[20];
inline int Getlen(const int&n){
	int len(0);while((1<<len)<n)++len;return len;
}
inline void swap(complex&a,complex&b){
	complex c=a;a=b;b=c;
}
inline int Get(const db&x){
	return((long long)(x+.5))%mod;
}
inline void init(const int&n){
	const int&m=Getlen(n);complex*now=buf;w[m]=now;now+=1<<m;
	IMP(1<<m,w[m][i]=complex(std::cos(i*Pi/(1<<m)),std::sin(i*Pi/(1<<m))));
	for(int k=m-1;k>=0&&(w[k]=now,now+=1<<k);--k)IMP(1<<k,w[k][i]=w[k+1][i<<1]);
}
inline void DFT(complex*f,const int&M){
	const int&n=1<<M;
	for(int len=n>>1,d=M-1;d>=0;--d,len>>=1)for(int k=0;k^n;k+=len<<1){
		complex*W=w[d],*L=f+(k),*R=f+(k|len),x,y;IMP(len,(x=*L,y=*R)),*L++=(x+y),*R++=*W++*(x-y);
	}
}
inline void IDFT(complex*f,const int&M){
	const int&n=1<<M;
	for(int len=1,d=0;d^M;++d,len<<=1)for(int k=0;k^n;k+=len<<1){
		complex*W=w[d],*L=f+(k),*R=f+(k|len),x,y;IMP(len,(x=*L,y=*W++**R)),*L++=(x+y),*R++=(x-y);
	}
	IMP(n,(f[i].x/=n,f[i].y/=n));for(int i=1;(i<<1)<n;++i)swap(f[i],f[n-i]);
}
inline void MTT(int*f,int*g,int*h,const int&n,const int&m,const int&LEN){
	static complex Q[M],P[M],T[M];const int&len=Getlen(n+m-1);
	IMP(n,(Q[i].x=f[i]&32767,P[i].x=f[i]>>15));IMP(m,T[i]=complex(g[i]&32767,g[i]>>15));
	DFT(Q,len);DFT(P,len);DFT(T,len);IMP(1<<len,(Q[i]=Q[i]*T[i],P[i]=P[i]*T[i]));IDFT(Q,len);IDFT(P,len);
	IMP(LEN,h[i]=(Get(Q[i].x)+(1ll*(Get(Q[i].y)+Get(P[i].x))<<15)+(1ll*Get(P[i].y)<<30))%mod);
	IMP(1<<len,Q[i]=P[i]=T[i]=complex());
}
inline int read(){
	int n(0);char s;while(!isdigit(s=getchar()));while(n=n*10+(s&15),isdigit(s=getchar()));return n;
}
inline void write(int n){
	static char s[15];int top(0);while(s[++top]=n%10^48,n/=10);while(putchar(s[top]),--top);putchar(' ');
}
signed main(){
	n=read()+1;m=read()+1;mod=Barrett(P=read());init(n+m-1);
	IMP(n,F[i]=read());IMP(m,G[i]=read());MTT(F,G,H,n,m,n+m-1);IMP(n+m-1,write(H[i]));
}
```

---

## 作者：skydogli (赞：24)

大家好，作为一名多项式菜鸡，我用karatsuba乘法通过了本题。

$\quad$众所周知，如果模数不同，NTT支持的值域只能小于模数，也就是取模对所有答案都不会产生影响，不然就只能使用三模NTT加中国剩余定理解决。而FFT支持取模操作，但是精度爆炸，入门多项式选手通常要用7、8次FFT（当然，很多神仙可以只用4次5次甚至3次）。相比于模板，这道题使用NTT和FFT的难度加大了许多。

$\quad$然而，多项式乘法并不只有这两种乘法，还有一种思路更加简单的、只靠代数转化来降低复杂度的算法：karatsuba乘法。它的原理只有短短几行：

我们把多项式$f$拆成$A\times x^p+B$,$g$拆成$C\times x^p+D$
$$f\times g$$
$$=(A\times x^p+B)\times(C\times x^p+D)$$
$$=AC\times x^{2p}+BC\times x^p+AD\times x^p+BD$$
$$=AC\times x^{2p}+(BC+AD)\times x^p+BD$$
而$BC+AD=(A+B)(C+D)-AC-BD$

所以原式$=AC\times x^{2p}+[(A+B)(C+D)-AC-BD]\times x^p+BD$

我们发现只需要3次多项式乘法和若干次加减法即可。

那这个复杂度是多少呢？

学习了[这篇博客](https://zhuanlan.zhihu.com/p/55653747)

它的递推式是$T(n)=3T(\frac{n}{2})+O(n),T(1)=1$

我们推一下：

设 
$$k=log_2n,n=2^k,f(k)=T(2^k)$$
所以
$$f(k)=3f(k-1)+2^k$$
同时除以$3^k$
$$\frac{f(k)}{3^k}=\frac{f(k-1)}{3^{k-1}}+(\frac{2}{3})^k$$
设
$$g(k)=\frac{f(k)}{3^k}$$
所以
$$g(k)=\sum_{i=1}^k{(\frac{2}{3})^i}\leq 3$$
上面可以用等比数列求和证明,带回来：
$$f(k)\leq 3^{k+1}$$
$$T(n)=f(log_2n)\leq f({3}^{log_2n+1})$$
$$=O(3^{log_2n})=O(2^{log_2 3\times log_2 n})=O(n^{log_2 3})$$

$log_23$大概是1.585，所以我们的复杂度可以近似地看成$O(n\sqrt{n})$

另外如果$n=2^k$，它的通项是$T(n)=2\times 3^k-2^{k+1}$(orz [Crazyali](https://www.luogu.com.cn/user/18215))，感兴趣的同学可以推一下。

当然，其实我们可以分更多组，复杂度可以进一步降低，但会增大常数且变换更加复杂，通常不会使用。

介绍完这个算法后，我们发现它在真正的乘法过程中没有任何的要求，也没有单位根、原根等限制，所以这题对于karatsuba乘法来说和多项式乘法模板几乎没有差别，加上这题仅$10^5$的数据范围，对karatsuba非常友好~~当然还是卡常~~

于是出现了小蒟蒻第一份代码:
```cpp

void fill(vector<LL> &f,vector<LL> &a,vector<LL> &b,int len){
	b.resize(len);a.resize(f.size()-len);
	int cnt=0;
	for(int i=0;i<len;++i)
		b[cnt++]=f[i];
	cnt=0;
	for(int i=len;i<f.size();++i)
		a[cnt++]=f[i];
}
//(a*p+b)(c*p+d)=ac*p^2+bc*p+ad*p+bd
//=ac*p^2+(ad+bc)*p+bd
//=ac*p^2+((a+b)(c+d)-ac-bd)*p+bd
void add(LL &a,LL b){((a+=b)>=Mod)?(a-=Mod):0;}
void sub(LL &a,LL b){((a-=b)<0)?(a+=Mod):0;} 
void MUL(vector<LL> &f,vector<LL> &g,vector<LL> &res){
	res.resize(f.size()+g.size()-1);
	for(int i=0;i<res.size();++i)res[i]=0;
	if(f.size()<2||g.size()<2){
		for(int i=0;i<f.size();++i)
			for(int j=0;j<g.size();++j)
				res[i+j]=(res[i+j]+f[i]*g[j])%Mod;
		return;
	}
	vector<LL>a,b,c,d,r1,r2,r3,r4;
	int len1=(f.size())/2,len2=(g.size())/2;
	a.clear();b.clear();c.clear();d.clear();
	fill(f,a,b,len1);fill(g,c,d,len2);
	r1.clear();r2.clear();r3.clear();r4.clear();
	MUL(a,c,r1);
	for(int i=0;i<r1.size();++i){
		add(res[i+len1+len2],r1[i]);
		sub(res[i+len1],r1[i]);
	}
	MUL(b,d,r4);
	for(int i=0;i<r4.size();++i){
		add(res[i],r4[i]);
		sub(res[i+len1],r4[i]);
	}
	for(int i=0;i<len1;++i)add(a[i],b[i]);
	for(int i=0;i<len2;++i)add(c[i],d[i]);
	MUL(a,c,r3);
	for(int i=0;i<r3.size();++i){
		add(res[i+len1],r3[i]);
	}
}
```
[结果](https://www.luogu.com.cn/record/29927587)

要是这样就能过，那估计也轮不上我写题解了。
- 小技巧0

这个应该不用解释吧
```cpp
#pragma GCC optimize(2) 
#pragma GCC optimize(3) 
#pragma GCC optimize("Ofast")
```
- 小技巧1

我们发现这个算法的常数还是比较大的，要好几次多项式加减法，所以我们到比较小的数据范围时可以直接暴力算。窝取的范围是30以内。
```cpp

void fill(vector<LL> &f,vector<LL> &a,vector<LL> &b,int len){
	b.resize(len);a.resize(f.size()-len);
	int cnt=0;
	for(int i=0;i<len;++i)
		b[cnt++]=f[i];
	cnt=0;
	for(int i=len;i<f.size();++i)
		a[cnt++]=f[i];
}
//(a*p+b)(c*p+d)=ac*p^2+bc*p+ad*p+bd
//=ac*p^2+(ad+bc)*p+bd
//=ac*p^2+((a+b)(c+d)-ac-bd)*p+bd
void add(register LL &a,register LL b){((a+=b)>=Mod)?(a-=Mod):0;}
void sub(register LL &a,register LL b){((a-=b)<0)?(a+=Mod):0;} 
void MUL(vector<LL> &f,vector<LL> &g,vector<LL> &res){
	res.resize(f.size()+g.size()-1);
	for(int i=0;i<res.size();++i)res[i]=0;
	if(f.size()<32||g.size()<32){
		for(int i=0;i<f.size();++i)
			for(int j=0;j<g.size();++j)
				res[i+j]=(res[i+j]+f[i]*g[j])%Mod;
		return;
	}
	vector<LL>a,b,c,d,r1,r2,r3,r4;
	int len1=(f.size())/2,len2=(g.size())/2;
	a.clear();b.clear();c.clear();d.clear();
	fill(f,a,b,len1);fill(g,c,d,len2);
	r1.clear();r2.clear();r3.clear();r4.clear();
	MUL(a,c,r1);
	for(int i=0;i<r1.size();++i){
		add(res[i+len1+len2],r1[i]);
		sub(res[i+len1],r1[i]);
	}
	MUL(b,d,r4);
	for(int i=0;i<r4.size();++i){
		add(res[i],r4[i]);
		sub(res[i+len1],r4[i]);
	}
	for(int i=0;i<len1;++i)add(a[i],b[i]);
	for(int i=0;i<len2;++i)add(c[i],d[i]);
	MUL(a,c,r3);
	for(int i=0;i<r3.size();++i){
		add(res[i+len1],r3[i]);
	}
}
```
[结果](https://www.luogu.com.cn/record/29928466)

- ~~小技巧2~~

~~可以把int改成long long~~

然后发现甚至慢了一点。

洛谷的评测机是64位，所以long long真的没有比int慢。

~~屑~~

- 小技巧3

都说vector常数大，那我改成数组？

在我神奇的本机从20s变成了6s！（本机20s交上去真有70）
```cpp
void fill(LL *f,LL *a,LL *b,int len,int sz){
	for(rint i=0;i<len;++i)
		b[i]=f[i];
	int cnt=0;
	for(rint i=len;i<sz;++i)
		a[cnt++]=f[i];
}
//(a*p+b)(c*p+d)=ac*p^2+bc*p+ad*p+bd
//=ac*p^2+(ad+bc)*p+bd
//=ac*p^2+((a+b)(c+d)-ac-bd)*p+bd
void add(register LL &a,register LL b){((a+=b)>=Mod)?(a-=Mod):0;}
void sub(register LL &a,register LL b){((a-=b)<0)?(a+=Mod):0;} 
void MUL(LL *f,LL *g,LL *res,int dep,int sz1,int sz2){
	for(int i=0;i<sz1+sz2;++i)res[i]=0;
	if(sz1<28){
		for(register int i=0;i<sz1;++i)
			for(register int j=0;j<sz2;++j)
				res[i+j]=(res[i+j]+f[i]*g[j])%Mod;
		return;
	}
	int len=sz1/2;
	fill(f,a[dep],b[dep],len,sz1);fill(g,c[dep],d[dep],len,sz2);
	MUL(a[dep],c[dep],r1[dep],dep+1,sz1-len,sz2-len);
	int L=sz1+sz2-len-len-1;
	for(int i=0;i<L;++i){
		sub(res[i+len],r1[dep][i]);
		add(res[i+(len<<1)],r1[dep][i]);
	}
	MUL(b[dep],d[dep],r4[dep],dep+1,len,len);
	for(rint i=0;i<len*2-1;++i){
		register LL tmp=r4[dep][i];
		add(res[i],tmp);
		sub(res[i+len],tmp);
	}
	for(rint i=0;i<len;++i)add(a[dep][i],b[dep][i]);
	for(rint i=0;i<len;++i)add(c[dep][i],d[dep][i]);
	MUL(a[dep],c[dep],r3[dep],dep+1,sz1-len,sz2-len);
	for(rint i=0;i<L;++i){
		add(res[i+len],r3[dep][i]);
	}
}
```
[发现毫无意义](https://www.luogu.com.cn/record/29930918)

内存调用好玄学啊，~~又想起k级祖先长剖被树剖吊打的恐惧~~

- 最暴力的操作

一直在70分徘徊好久，万念俱灰之际，看到暴力乘法：
```cpp
	for(register int i=0;i<sz1;++i)
		for(register int j=0;j<sz2;++j)
			res[i+j]=(res[i+j]+f[i]*g[j])%Mod;
	return;
```
取模好像有点多。。。。

但是long long 肯定要随时取模啊。。。

### __int128???

洛谷是64位机子来着。。。

```cpp

	if(sz1<28){
		for(register int i=0;i<sz1;++i)
			for(register int j=0;j<sz2;++j)
				qwq[i+j]+=(LL)f[i]*g[j];
		for(int i=0;i<sz1+sz2;++i)res[i]=qwq[i]%Mod,qwq[i]=0;
		return;
	}
    //qwq是__int128
```

然后提交——[???](https://www.luogu.com.cn/record/29931859)

过 了

行吧，真玄学。

最后的AC代码：
```cpp
#pragma GCC optimize(2) 
#pragma GCC optimize(3) 
#pragma GCC optimize("Ofast")
#include<bits/stdc++.h>
using namespace std;
#define LL long long
#define mn 19
#define MN 200005
#define rint register int
int Mod=998244353,n,m;
__int128 qwq[59]; 
//vector<LL>F,G,ANS;
int a[mn][MN],b[mn][MN],c[mn][MN],d[mn][MN],r1[mn][MN],r4[mn][MN],r3[mn][MN],F[MN],G[MN],ANS[MN];
void fill(int *f,int *a,int *b,int len,int sz){
	for(rint i=0;i<len;++i)
		b[i]=f[i];
	int cnt=0;
	for(rint i=len;i<sz;++i)
		a[cnt++]=f[i];
}
//(a*p+b)(c*p+d)=ac*p^2+bc*p+ad*p+bd
//=ac*p^2+(ad+bc)*p+bd
//=ac*p^2+((a+b)(c+d)-ac-bd)*p+bd
void add(register int &a,register int b){((a+=b)>=Mod)?(a-=Mod):0;}
void sub(register int &a,register int b){((a-=b)<0)?(a+=Mod):0;} 
void MUL(int *f,int *g,int *res,int dep,int sz1,int sz2){
	for(int i=0;i<sz1+sz2;++i)res[i]=0;
	if(sz1<28){
		for(register int i=0;i<sz1;++i)
			for(register int j=0;j<sz2;++j)
				qwq[i+j]+=(LL)f[i]*g[j];
		for(int i=0;i<sz1+sz2;++i)res[i]=qwq[i]%Mod,qwq[i]=0;
		return;
	}
	int len=sz1/2;
	fill(f,a[dep],b[dep],len,sz1);fill(g,c[dep],d[dep],len,sz2);
	MUL(a[dep],c[dep],r1[dep],dep+1,sz1-len,sz2-len);
	int L=sz1+sz2-len-len-1;
	for(int i=0;i<L;++i){
		sub(res[i+len],r1[dep][i]);
		add(res[i+(len<<1)],r1[dep][i]);
	}
	MUL(b[dep],d[dep],r4[dep],dep+1,len,len);
	for(rint i=0;i<len*2-1;++i){
		register LL tmp=r4[dep][i];
		add(res[i],tmp);
		sub(res[i+len],tmp);
	}
	for(rint i=0;i<len;++i)add(a[dep][i],b[dep][i]);
	for(rint i=0;i<len;++i)add(c[dep][i],d[dep][i]);
	MUL(a[dep],c[dep],r3[dep],dep+1,sz1-len,sz2-len);
	for(rint i=0;i<L;++i){
		add(res[i+len],r3[dep][i]);
	}
}
inline int read(){
	int a=0;char c=getchar();
	while(c>'9'||c<'0')c=getchar();
	while('0'<=c&&c<='9'){
		a=a*10+c-48;
		c=getchar();
	}
	return a;
}
int main(){
//	freopen("qwq.in","r",stdin);
//	freopen("qwq.out","w",stdout);
	n=read();m=read();Mod=read();
	int N=max(n+1,m+1);
	for(int i=0;i<=n;++i)F[i]=read()%Mod;
	for(int i=0;i<=m;++i)G[i]=read()%Mod;
	MUL(F,G,ANS,0,N,N);
	for(int i=0;i<=n+m;++i)
		printf("%d ",ANS[i]);
	return 0;
}
```
于是决定写篇博客供大家娱乐。

另外，小蒟蒻的实现不算清真，欢迎大家提出改进建议和批评。




---

## 作者：KLauraLee (赞：18)

## 任意模数NTT

### 暴力

有如下两种解决思路：

- 选取三个有原根的模数，并且三个模数的乘积大于最终结果的理论最大值，进行三次NTT，最后把每一项用CRT合并，需要9次DFT。
- 令$k=sqrt(p)$，多项式$M(x)=k*A(x)+B(x)$，$N(x)=k*C(x)+D(x)$，然后$M(x)N(x)=k^2A(x)C(x)+k(A(x)D(x)+B(x)C(x))+B(x)D(x)$，要进行8次DFT。

都很慢...

### 优化

myy在《再探快速傅里叶变换》中介绍了一种方法。

令$Q_j=A_j+iB_j$,$E_j=C_j+iD_j$。

复数m实部为$m.a$，虚部为$m.b$，$Q(x)$中第$j$项贡献为$Q(x)_j$。

展开
$$
Q(w_n^j)_x=(A_x+iB_x) {w_n^j}^x=A_x(cos({2πx j\over n})+isin({2πxj \over n}))+B_x(icos({2πx j\over n})-sin({2πxj \over n}))
$$
同理
$$
Q(w_n^{-j})_x=A_x(cos({2πxj\over n})-isin({2πx j \over n}))+B_x(icos({2πx j\over n})+sin({2πxj \over n}))
$$

因此
$$
A(w_n^j)_x={Q(w_n^j)_x.a+Q(w_n^{-j})_x.a\over 2}+i{Q(w_n^j)_x.b-Q(w_n^{-j})_x.b\over 2}
$$

同理
$$
B(w_n^j)_x={Q(w_n^j)_x.b+Q(w_n^{-j})_x.b\over 2}+i{Q(w_n^{-j})_x.a-Q(w_n^j)_x.a\over 2}
$$

先上代码。
```cpp
const int LIM=(1<<15)-1;
for(int i=0;i<len;++i)Q[i]= {M[i]&LIM,M[i]>>15};
for(int i=len;i<n;++i)Q[i]= {0,0};
for(int i=0;i<len1;++i)E[i]= {N[i]&LIM,N[i]>>15};
for(int i=len1;i<n;++i)E[i]= {0,0};
DFT(Q,1),DFT(E,1);
for(int i=0;i<n;++i){
	int fr=(n-i)&(n-1);
	c1[i]= (cp) {0.5*(Q[i].a+Q[fr].a),0.5*(Q[i].b-Q[fr].b)}*E[i];
	d1[i]= (cp) {0.5*(Q[i].b+Q[fr].b),0.5*(Q[fr].a-Q[i].a)}*E[i];
}
DFT(c1,-1),DFT(d1,-1);
for(int i=0;i<n;++i)c1[i]=c1[i]/n,d1[i]=d1[i]/n;
for(int i=0;i<n;++i){
	long long p=c1[i].a+0.5,o=c1[i].b+0.5,x=d1[i].a+0.5,u=d1[i].b+0.5;
	ans[i]=(p%mod+((o+x)%mod<<15)+(u%mod<<30))%mod;
}
```

显然$c1(x)=A(x)*E(x)=A(x)*C(x)+i*A(x)*D(x)$。

易知$c1(x)$实部为$A(x)C(x)$，虚部为$A(x)D(x)$。

对于$d1$同理。

因此最终只需要4次DFT即可求出$A(x)C(x),A(x)D(x),B(x)C(x),B(x)D(x)$。


### FFT三合二

同样的可以将上述方法应用到FFT中。

两个多项式$A(x),B(x)$,令$C(x)=A(x)+iB(x)$，可以将2次DFT简化为1次DFT。

具体实现很简单。



---

## 作者：远航之曲 (赞：15)

安利下[blog](http://www.yhzq-blog.cc/任意模数ntt总结/)

这里用的是三模数NTT

题意：两个多项式做乘法，$n \leq 10^5, a_i \leq 10^9$

我们发现这样的最大值是$10^{9^2} \times 10^5 = 10^{23}$，好像是爆longlong的。而且不是质数没法ntt啊。

那么我们就想到选三个满足NTT性质且乘起来$ > 10^{23} $的模数分别NTT，最后中国剩余定理合并。

这只解决了后面的那个问题，怎么解决炸longlong的问题呢。这需要一些特殊技巧

我们得到的同余式是这样的

![](http://www.yhzq-blog.cc/wp-content/uploads/2018/04/m1.png)

先用中国剩余定理合并前两个同余式，得到

![](http://www.yhzq-blog.cc/wp-content/uploads/2018/04/m2.png)

把ans拆开

$$Ans=kM+A=k'm_3+a_3$$

假如在$\pmod {m_3}$的意义下的话，那么有（消掉$k'm_3$）

$$kM \equiv a_3 - A \pmod {m_3}$$

也就是说

$$k \equiv (a_3 − A) M^{−1} \pmod {m_3}$$

求出k之后代入$Ans = kM + A$，这样就可以直接模任意数了。

注意在中国剩余定理合并的时候需要快速乘。

2009国家集训队论文：骆可强：《论程序底层优化的一些方法与技巧》

![](http://www.yhzq-blog.cc/wp-content/uploads/2018/04/fastmul.png)

```cpp
// luogu-judger-enable-o2
#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;
const int N = 300010, m1 = 469762049, m2 = 998244353, m3 = 1004535809, g = 3;
const long long M = 1ll * m1 * m2;
int n, m, r[N], a[N], b[N], c[N], d[N], ans[3][N], mod;
int fast_pow(int a, int p, int mod) {
    int ans = 1;
    for (; p; p >>= 1, a = 1ll * a * a % mod)
        if (p & 1) ans = 1ll * ans * a % mod;
    return ans;
}
long long fast_mul(long long a, long long b, long long mod) {
    a %= mod, b %= mod;
    return ((a * b - (long long)((long long)((long double)a / mod * b + 1e-3) * mod)) % mod + mod) % mod;
}
void ntt(int n, int *a, int opt, int mod) {
    for (int i = 0; i < n; ++i)
        if (i < r[i]) swap(a[i], a[r[i]]);
    for (int k = 1; k < n; k <<= 1)
        for (int i = 0, wn = fast_pow(g, (mod - 1) / (k << 1), mod); i < n; i += (k << 1))
            for (int j = 0, w = 1; j < k; ++j, w = 1ll * w * wn % mod) {
                int x = a[i + j], y = 1ll * w * a[i + j + k] % mod;
                a[i + j]= (x + y) % mod, a[i + j + k] = (x - y + mod) % mod;
			}
    if (opt == -1) {
        a[0] = 1ll * a[0] * fast_pow(n, mod - 2, mod) % mod;
        for (int i = 1, inv = fast_pow(n, mod - 2, mod); i <= n / 2; ++i) {
            a[i] = 1ll * a[i] * inv % mod;
            if (i != n - i) a[n - i] = 1ll * a[n - i] * inv % mod;
            swap(a[i], a[n - i]);
        }
    }
}
main() {
    static int fn = 1, l = 0;
    scanf("%d%d%d", &n, &m, &mod);
    for (int i = 0; i <= n; ++i) scanf("%d", &a[i]);
    for (int i = 0; i <= m; ++i) scanf("%d", &b[i]);
    while (fn <= n + m) fn <<= 1, ++l;
    for (int i = 0; i < fn; ++i)
        r[i] = (r[i >> 1] >> 1) | ((i & 1) << (l - 1));
    copy(a, a + n + 1, c), copy(b, b + m + 1, d), ntt(fn, c, 1, m1), ntt(fn, d, 1, m1);
    for (int i = 0; i <= fn; ++i) ans[0][i] = 1ll * c[i] * d[i] % m1;
    memset(c, 0, sizeof c), memset(d, 0, sizeof d);
    copy(a, a + n + 1, c), copy(b, b + m + 1, d), ntt(fn, c, 1, m2), ntt(fn, d, 1, m2);
    for (int i = 0; i <= fn; ++i) ans[1][i] = 1ll * c[i] * d[i] % m2;
    memset(c, 0, sizeof c), memset(d, 0, sizeof d);
    copy(a, a + n + 1, c), copy(b, b + m + 1, d), ntt(fn, c, 1, m3), ntt(fn, d, 1, m3);
    for (int i = 0; i <= fn; ++i) ans[2][i] = 1ll * c[i] * d[i] % m3;
    ntt(fn, ans[0], -1, m1), ntt(fn, ans[1], -1, m2), ntt(fn, ans[2], -1, m3);
    for (int i = 0; i <= n + m; ++i) {
        long long A = (fast_mul(1ll * ans[0][i] * m2 % M, fast_pow(m2 % m1, m1 - 2, m1), M) +
                       fast_mul(1ll * ans[1][i] * m1 % M, fast_pow(m1 % m2, m2 - 2, m2), M)) % M;
        long long k = ((ans[2][i] - A) % m3 + m3) % m3 * fast_pow(M % m3, m3 - 2, m3) % m3;
        printf("%d ", ((k % mod) * (M % mod) % mod + A % mod) % mod);
    }
}
```

---

## 作者：AzusaCat (赞：12)

如果不取模，按 OI 常见数据范围来讲两个多项式相乘以后系数不超过 $10^9\times10^9\times10^5=10^{23}$，如果我们算出该多项式分别 $\bmod$ 3 个 NTT 模数下的值，我们就可以通过 CRT 合并计算出模三个模数之积的值，而这样最高精度能达到 $10^{26}$ 级别，足够应付。但是这种方法一次多项式乘法需要 9 次 DFT，比较慢。下面介绍一下比较常见的优化拆系数 FFT。

众所周知，FFT 中不用取模，只需要结果取一次模就可以了。但是这题最大的系数达到了 $10^{23}$ 级别，直接 FFT 精度不足。对此我们引出拆系数 FFT。

设 $bas$ 为一个 $\sqrt{p}$ 级别的数，$F(x),G(x)$ 为我们要进行乘法的多项式，那么我们可以把 两个多项式表示成以下形式：
$$
\begin{aligned}
F(x)=basA(x)+B(x)\\
G(x)=basC(x)+D(x)
\end{aligned}
$$
其中，$[x^n]A(x)=\lfloor \frac{[x^n]F(x)}{bas} \rfloor$，$[x^n]B(x)=[x^n]F(x)\bmod bas$，对于 $C(x),D(x)$ 同理。这样系数就被降低到了 $10^5bas^2$ 的级别。那么有
$$
\begin{aligned}
F(x)G(x)&=(basA(x)+B(x))(basC(x)+D(x))\\
&=bas^2A(x)C(x)+bas(A(x)D(x)+B(x)C(x))+B(x)D(x)
\end{aligned}
$$
这样先算出 $A(x),B(x),C(x),D(x)$ 的点值表示，然后根据乘的系数不同做三次 IDFT，这样一次多项式乘法一共要做 7 次 FFT。

我们发现 DFT 的时候虚部一开始全为 0，可以通过一些方法利用上这里，减少 DFT 次数。

首先我们要明白 DFT 的本质是 $F(w_n^k)=\sum\limits_{i=0}^nf_iw_n^{ki}$ ，假设我们现在要算出 $A(x)$ 与 $B(x)$ 的点值表示。

如果我们知道了一个数组使得 $F[k]=A(w_n^k)+iB(w_n^k)$，$G[k]=A(w_n^k)-iB(w_n^k)$，那么我们可以通过解方程组的方式知道 $A(w_n^k)$ 与 $B(w_n^k)$。

现在我们尝试推导 $F$ 与 $G$ 的关系，通过 DFT 的定义可以知道：
$$
\begin{aligned}
F[k]&=A(w_n^k)+iB(w_n^k)\\
&=\sum\limits_{j=0}^{n-1}a_iw_n^{kj}+i\sum\limits_{i=0}^nb_jw_n^{kj}\\
&=\sum\limits_{j=0}^{n-1}{n-1}(a_j+ib_j)w_n^{kj}\\
&=\sum\limits_{j=0}^{n-1}(a_j+ib_j)(\cos(X)+i\sin(X))\\
&=\sum\limits_{j=0}^{n-1}(a_j\cos(X)-b_j\sin(X))+i(b_j\cos(X)+a_j\sin(X))\\
\end{aligned}
$$
其中，$X=\frac{2\pi kj}{n}$。

同时，我们有
$$
\begin{aligned}
G[n-k]&=A(w_n^{n-k})-iB(w_n^{n-k})\\
&=A(w_n^{-k})-iB(w_n^{-k})\\
&=\sum\limits_{j=0}^{n-1}a_iw_n^{-kj}-i\sum\limits_{i=0}^nb_jw_n^{-kj}\\
&=\sum\limits_{j=0}^{n-1}{n-1}(a_j-ib_j)w_n^{-kj}\\
&=\sum\limits_{j=0}^{n-1}(a_j-ib_j)(\cos(X)-i\sin(X))\\
&=\sum\limits_{j=0}^{n-1}(a_j\cos(X)-b_j\sin(X))-i(b_j\cos(X)+a_j\sin(X))\\
\end{aligned}
$$
所以，我们发现 $F[k]$ 与 $G[n-k]$ 是共轭的（$k=0$ 时要特判一下放到 $G[0]$ 去），所以我们只需要计算出 $F$，就可以 $O(n)$ 计算出 $G$。这样只需要 2 次 FFT，就可以计算出四个多项式的点值。

然后考虑 IDFT 部分，这里也可以省一次 FFT。我们正常求 IDFT 的时候最后结果全部都在实部（不明白去看单位根反演），那么如果我们在最开始每个点值都乘上 $i$，那么最后出来的结果应该都在虚部，而且数值和放在实部上相等。我们知道 FFT 是一个线性变换，所以我们可以把要求的两个多项式分别放在实部和虚部上，然后 IDFT 之后实部和虚部上就是分别的原多项式了。这样就又省了一次 FFT，一次多项式乘法总共需要 4 次。

实际使用一般设 $bas$ 为 $2$ 的次幂，比较方便提取系数。  
这份代码实现不够精细，没有预处理单位根，导致精度不足必须开 `long double`  
```cpp
#include<bits/stdc++.h>
using namespace std;
namespace poly
{
    long double const pi=acos(-1);
    struct comp
    {
        long double r,i;
        comp(){r=i=0;}
        comp(long double x,long double y){r=x,i=y;}
        comp conj(){return comp(r,-i);}
        friend comp operator +(comp x,comp y){return comp(x.r+y.r,x.i+y.i);}
        friend comp operator -(comp x,comp y){return comp(x.r-y.r,x.i-y.i);}
        friend comp operator *(comp x,comp y){return comp(x.r*y.r-x.i*y.i,x.i*y.r+x.r*y.i);}
    };
    typedef long long ll;
    int r[400005];
    comp a[400005],b[400005],c[400005],d[400005];
    void fft(comp *f,int n,int op)
    {
        for(int i=1;i<n;i++)r[i]=(r[i>>1]>>1)+((i&1)?(n>>1):0);
        for(int i=1;i<n;i++)if(i<r[i])swap(f[i],f[r[i]]);
        for(int len=2;len<=n;len<<=1)
        {
            int q=len>>1;
            comp wn=comp(cos(pi/q),op*sin(pi/q));
            for(int i=0;i<n;i+=len)
            {
                comp w=comp(1,0);
                for(int j=i;j<i+q;j++,w=w*wn)
                {
                    comp d=f[j+q]*w;
                    f[j+q]=f[j]-d;
                    f[j]=f[j]+d;
                }
            }
        }
    }
    void mtt(int *f,int *g,int *h,int n,int p)
    {
        for(int i=0;i<n;i++)
            a[i].r=(f[i]>>15),a[i].i=(f[i]&32767),
            c[i].r=(g[i]>>15),c[i].i=(g[i]&32767);
        fft(a,n,1),fft(c,n,1);
        for(int i=1;i<n;i++)b[i]=a[n-i].conj();
        b[0]=a[0].conj();
        for(int i=1;i<n;i++)d[i]=c[n-i].conj();
        d[0]=c[0].conj();
        for(int i=0;i<n;i++)
        {
            comp 
            aa=(a[i]+b[i])*comp(0.5,0),
            bb=(a[i]-b[i])*comp(0,-0.5),
            cc=(c[i]+d[i])*comp(0.5,0),
            dd=(c[i]-d[i])*comp(0,-0.5);
            a[i]=aa*cc+comp(0,1)*(aa*dd+bb*cc),b[i]=bb*dd;
        }
        fft(a,n,-1),fft(b,n,-1);
        for(int i=0;i<n;i++)
        {
            int 
            aa=(ll)(a[i].r/n+0.5)%p,
            bb=(ll)(a[i].i/n+0.5)%p,
            cc=(ll)(b[i].r/n+0.5)%p;
            h[i]=((1ll*aa*(1<<30)+1ll*bb*(1<<15)+cc)%p+p)%p;
        }
    }
}
using namespace poly;
int f[400005],g[400005],h[400005];
int main()
{
    int n,m,p;
    scanf("%d%d%d",&n,&m,&p);
    for(int i=0;i<=n;i++)scanf("%d",&f[i]);
    for(int i=0;i<=m;i++)scanf("%d",&g[i]);
    int lim=1;
    while(lim<=(n+m))lim<<=1;
    mtt(f,g,h,lim,p);
    for(int i=0;i<=n+m;i++)printf("%d ",h[i]);
    return 0;
}

---

## 作者：ccviolett (赞：10)

写这种又长，又需要扩展性的东西，当然要用`面向对象`来优化程序啊。

证明和讲解上面已经有了，这里给出一个封装性好、速度快（900ms 左右）的模板。

其中运用到的知识点：

- 继承
  - 继承模式
- 重载
- 多态
  - 纯虚函数
- 基础多项式
- 诡异的神仙优化

```cpp
/* Header {{{ */
#include <bits/stdc++.h>
using namespace std;

typedef long long readtype;
typedef long long var;
typedef long double let;

readtype read() {
  readtype a = 0, c = getchar(), s = 0;
  while (!isdigit(c)) s |= c == '-', c = getchar();
  while (isdigit(c)) a = a * 10 + c - 48, c = getchar();
  return s ? -a : a;
}

#ifdef LOCAL_LOGGER
#define logger(...) fprintf(stderr, __VA_ARGS__)
#else
#define logger(...);
#endif
/* }}} */

struct Node {
  double x, y;
  void operator = (int t) { x = t >> 15, y = t & 32767; }
  Node operator + (Node t) { return (Node) {x + t.x, y + t.y}; }
  Node operator - (Node t) { return (Node) {x - t.x, y - t.y}; }
  Node operator * (Node t) { 
    return (Node) {x * t.x - y * t.y, x * t.y + y * t.x }; 
  }
  Node operator * (double t) { return (Node) {x * t, y * t}; }
  Node operator ~ () { return (Node) {x, -y}; }
};

class Poly {
  protected:
    static const int N = 1e6 + 1;

    int MOD;
    int limit, rev[N];
    void InitLimit(const int need_len) {
      if (limit >= need_len) return ;
      for (limit = 1; limit <= need_len; limit <<= 1);
      for (int i = 0; i < limit; ++i) 
        rev[i] = (rev[i >> 1] >> 1) | ((i & 1) ? (limit >> 1) : 0);
      InitLimitExtra(need_len);
    }

    virtual void InitLimitExtra(const int need_len) = 0;
    virtual void Transform() = 0;

  public:
    void SetMod(int p) { MOD = p; }
    virtual void Mul(const int len_a, const int *a, const int len_b, const int *b,
        int &len_c, int *c) = 0;
};

class FFT: public Poly {
  private:
    Node w[N];

  protected:
    void InitLimitExtra(const int need_len) {
      const double Pi = acos(-1.0);
      for (int mid = 1; mid < limit; mid <<= 1) {
        w[mid] = (Node) {1, 0};
        for (int i = 1; i < mid; ++i) {
          if ((i & 31) == 1) 
            w[i + mid] = (Node) {cos(Pi * i / mid), sin(Pi * i / mid)};
          else
            w[i + mid] = w[i + mid - 1] * w[mid + 1];
        }
      }
    }

    void Transform() {};
    void Transform(Node *val, const int type) {
      if (type == -1) reverse(val + 1, val + limit);
      for (int i = 0; i < limit; ++i) 
        if (i < rev[i]) swap(val[i], val[rev[i]]);
      for (int mid = 1; mid < limit; mid <<= 1) {
        int R = mid << 1;
        for (int i = 0; i < limit; i += R) {
          for (int j = 0; j < mid; ++j) {
            Node v = w[mid + j] * val[i + mid + j];
            val[i + mid + j] = val[i + j] - v;
            val[i + j] = val[i + j] + v;
          }
        }
      }
    }

};

class MTT: public FFT {
  private:
    Node tmp_a[N], tmp_b[N], tmp_c[N], tmp_d[N];

  public:
    void Mul(const int len_a, const int *a, const int len_b, const int *b,
        int &len_c, int *c) {
      assert(MOD);

      len_c = len_a + len_b;
      InitLimit(len_c);

      for (int i = 0; i <= len_a; ++i) tmp_a[i] = a[i];
      for (int i = 0; i <= len_b; ++i) tmp_b[i] = b[i];
      Transform(tmp_a, 1), Transform(tmp_b, 1);

      for (int i = 0; i < limit; ++i) {
        Node ft = ~tmp_a[i ? (limit - i) : 0], 
             f0 = (tmp_a[i] - ft) * (Node) {0, -0.5}, 
             f1 = (tmp_a[i] + ft) * 0.5;
        Node gt = ~tmp_b[i ? (limit - i) : 0], 
             g0 = (tmp_b[i] - gt) * (Node) {0, -0.5},
             g1 = (tmp_b[i] + gt) * 0.5;
        tmp_c[i] = f1 * g1, tmp_d[i] = f0 * g1 + f1 * g0 + f0 * g0 * (Node) {0, 1};
      }
      for (int i = 0; i < limit; ++i) tmp_a[i] = 0, tmp_b[i] = 0;

      Transform(tmp_c, -1), Transform(tmp_d, -1);
      for (int i = 0; i <= len_c; ++i) {
        var v1 = (var) (tmp_c[i].x / limit + 0.5) % MOD, 
            v2 = (var) (tmp_d[i].x / limit + 0.5) % MOD,
            v3 = (var) (tmp_d[i].y / limit + 0.5) % MOD;
        c[i] = ((v1 << 30) + (v2 << 15) + v3) % MOD;
        tmp_c[i] = 0, tmp_d[i] = 0;
      }
    }

};

const int N = 1e6 + 1;

int n, m, p;
int f[N], g[N];
MTT poly;
int len, res[N];

int main() {
#ifndef ONLINE_JUDGE
  freopen("P4245.in", "r", stdin);
  freopen("P4245.out", "w", stdout);
#endif
#ifdef LOCAL_LOGGER
  freopen("P4245.log", "w", stderr);
#endif
  n = read(), m = read(), p = read();
  poly.SetMod(p);
  for (int i = 0; i <= n; ++i) f[i] = read();
  for (int i = 0; i <= m; ++i) g[i] = read();
  poly.Mul(n, f, m, g, len, res);
  for (int i = 0; i <= len; ++i)
    printf("%d ", res[i]);
  puts("");
  return 0;
}

/* ==== Makefile ==== {{{
CompileAndRun:
make Compile
make Run

Compile:
g++ -o P4245 P4245.cpp -g -Wall -DLOCAL_LOGGER

CompileUF:
g++ -o P4245 P4245.cpp -g -Wall -DLOCAL_LOGGER -fsanitize=undefined

Run:
./P4245 < P4245.in > P4245.out
==================
}}} */
```

---

## 作者：Vocalise (赞：8)

4次FFT的MTT做法。权当给自己看的了。

此题系数范围很大，如果用朴素的FFT会掉精度，从而我们需要将一个整数 $a$ 分解成 $a0\times B+a1$ 的形式，其中 $B$ 可取常数，代码中是 $2^{15}$。这样取到了精度，但是会增加复杂度。

然后就表示出 ${a0\times B+a1}$ 和 ${b0\times B+b1}$ 的乘法为：

$$B^2a0b0+B(a0b1+a1b0)+a1b1$$

于是我们要求四个多项式的积：$a0b0,a1b1,a1b0,a0b1$。

考虑先求出 $a0,b0,a1,b1$ 的点值。

因为它们都是实数，不妨以虚数的形式将其两两结合。

有：

$$A_x=a0_x+ia1_x$$

$$B_x=b0_x+ib1_x$$

考虑借助第一个 $A$ 如何求出 $a0,a1$ 的点值。

先求 $A$ 的点值为 $A1$。然后将 $A$ 的系数共轭后再构造 $A2$。

下面试图证明 $A1$ 的第 $k$ 项与 $A2$ 的第 $n-k$ 项是共轭的。

$$\begin{aligned}
A1_k&=\sum_{i=0}^{n-1}(a0_i+ia1_i)(w_n^k)^i \\
&=\sum_{i=0}^{n-1}a0_i(w_n^k)^i+ia1_i(w_n^k)^i \\
&=\sum_{i=0}^{n-1}a0_i\cos\theta+ia0_i\sin\theta+ia1_i\cos\theta+i^2a1_i\sin\theta \\
&=\sum_{i=0}^{n-1}(a0_i\cos\theta-a1_i\sin\theta)+i(a0_i\sin\theta+a1_i\cos\theta)
\end{aligned}$$

$$\begin{aligned}
A2_{n-k}&=\sum_{i=0}^{n-1}(a0_i-ia1_i)(w_n^{-k})^i \\
&=\sum_{i=0}^{n-1}a0_i(w_n^{-k})^i-ia1_i(w_n^{-k})^i \\
&=\sum_{i=0}^{n-1}a0_i\cos\theta-ia0_i\sin\theta-ia1_i\cos\theta+i^2a1_i\sin\theta \\
&=\sum_{i=0}^{n-1}(a0_i\cos\theta-a1_i\sin\theta)-i(a0_i\sin\theta+a1_i\cos\theta)
\end{aligned}$$

然后就可以通过一次 $A$ 的DFT求出 $A1$ 和 $A2$。

再可以用普通线性方程求出 $a0,a1$ 的点值了。

求 $b0,b1$ 类似。

这里一共两次FFT。

然后得到 $a0,a1,b0,b1$ 的点值，现在求两两乘积的系数，同样考虑合并：

$$P(x)=a0_xb0_x+ia1_xb0_x$$

$$Q(x)=a0_xb1_x+ia1_xb1_x$$

得到 $P$ 和 $Q$ 的点值后两次FFT求出系数，取出各部代入篇头的式子里即可。

代码如下。

```cpp
#include <cstdio>
#include <iostream>
#include <cstring>
#include <cmath>
#include <algorithm>

typedef long long ll;
typedef long double ldb;
const ldb pi = acos(-1);
const int MAXN = 400001;
const ll B = 1 << 15;

inline int read() {
    int x = 0,f = 1; char ch = getchar();
    while(ch > '9' || ch < '0') { if(ch == '-') f = -1; ch = getchar(); }
    do x = x * 10 + ch - 48, ch = getchar(); while(ch >= '0' && ch <= '9');
    return x * f;
}

struct Complex
{
    ldb x,y;
    Complex() { x = y = 0; }
    Complex(const ldb _x,const ldb _y) : x(_x), y(_y) {}
    Complex operator +(const Complex a) { return Complex(x + a.x,y + a.y); }
    Complex operator -(const Complex a) { return Complex(x - a.x,y - a.y); }
    Complex operator *(const Complex a) { return Complex(x * a.x - y * a.y,x * a.y + y * a.x); }
    Complex operator *(const ldb t) { return Complex(x * t,y * t); }
    Complex operator /(const ldb t) { return Complex(x / t,y / t); }
};

Complex I(0,1);

int n,m,p,r[MAXN]; Complex wn[MAXN];
Complex a0[MAXN],a1[MAXN],b0[MAXN],b1[MAXN];
Complex P[MAXN],Q[MAXN];

void FFT(Complex *a,int N) {
    for(int i = 0;i < N;i++) if(i < r[i]) std::swap(a[i],a[r[i]]);
    Complex t1,t2;
    for(int n = 2, m = 1;n <= N;m = n, n <<= 1)
        for(int l = 0;l < N;l += n)
            for(int i = l;i < l + m;i++) {
                Complex w = wn[N / m * (i - l)];
                t1 = a[i], t2 = w * a[i + m];
                a[i] = t1 + t2;
                a[i + m] = t1 - t2;
            }
    return;
}

void IFFT(Complex *a,int N) {
    FFT(a,N);
    std::reverse(a + 1,a + N);
    for(int i = 0;i < N;i++) a[i] = a[i] / N;
    return;
}

void ConnectFFT(Complex *a,Complex *b,int N) {
    for(int i = 0;i < N;i++) a[i].y = b[i].x;
    FFT(a,N);
    b[0] = Complex(a[0].x,-a[0].y);
    for(int i = 1;i < N;i++) b[i] = Complex(a[N - i].x,-a[N - i].y);
    Complex t1,t2;
    for(int i = 0;i < N;i++) {
        t1 = a[i], t2 = b[i];
        a[i] = (t1 + t2) / 2.0;
        b[i] = (t2 - t1) * I / 2.0;
    }
    return;
}

ll rd(const ldb x) {
    if(x >= 0) return ll(x + 0.5) % p;
    else return ll(x - 0.5) % p;
}

int main() {
    n = read(), m = read(), p = read();
    for(int i = 0,v;i <= n;i++) v = read() % p, a0[i].x = v / B, a1[i].x = v % B;
    for(int i = 0,v;i <= m;i++) v = read() % p, b0[i].x = v / B, b1[i].x = v % B;
    int N = 1, l = -1; while(N <= n + m) N <<= 1, l++;
    for(int i = 1;i < N;i++) r[i] = (r[i >> 1] >> 1) | ((i & 1) << l);
    for(int i = 0;i < N;i++) wn[i] = Complex(cos(pi / N * i),sin(pi / N * i));
    ConnectFFT(a0,a1,N); ConnectFFT(b0,b1,N);
    for(int i = 0;i < N;i++) {
        P[i] = a0[i] * b0[i] + I * a1[i] * b0[i];
        Q[i] = a0[i] * b1[i] + I * a1[i] * b1[i];
    }
    IFFT(P,N); IFFT(Q,N);
    for(int i = 0;i <= n + m;i++) {
        ll ans = B * B % p * rd(P[i].x) % p +
                 B * rd(Q[i].x + P[i].y) % p +
                 rd(Q[i].y) % p;
        std::printf("%lld ",ans % p);
    }
    return 0;
}

```

---

## 作者：huangzirui (赞：6)

题意：

对给定的两个多项式 $F(x)\ ,G(x)$ 求出 $F(x)*G(x)$ 对 $p$ 取模的结果。

$p$ 为任意小于等于 $10^9+9$ 的整数。

多项式位数 $n \leq 10^5$ ， 多项式系数 $0 \leq a_i,b_i \leq 10^9$ 

---
因为使用 $\text{NTT}$ 需要保证模数可以分解成 $a\times2^k+b$ 的形式，这里没办法直接解决。

首先考虑直接计算：随便用一个质数（ 设这个质数是 $P'$ ）算，那么算出来的结果（ 设它为 $ans'$ ）肯定不是正确答案，它只满足这样一个式子：

$$ans'\ \equiv ans\ \pmod {P'}$$

于是考虑从左边推出右边：多建立几个方程，然后利用中国剩余定理计算出答案。

取三个质数 $P_1,P_2,P_3$ ，设算出来结果分别是 $A_1,A_2,A_3$ ， 那么有：

$$\begin{cases}
{A_1\ \equiv ans\ \pmod {P_1}}\\
{A_2\ \equiv ans\ \pmod {P_2}}\\
{A_3\ \equiv ans\ \pmod {P_3}}\\
\end{cases}$$

于是可以利用中国剩余定理计算出 $ans \mod (P_1P_2P_3)$ 的结果，由于 $ans \leq \max\{A_i\} \times \max\{B_i\} \times n$ ，只要模数之积大于 $10^{23}$，这时计算的答案就是真正的答案。

推荐模数 $998244353,1004535809,469762049$

---

关于中国剩余定理：可以知道答案为

$ans = A_1P_2P_3P'_{2,1}P'_{3,1}+A_2P_1P_3P'_{1,2}P'_{3,2}+A_3P_1P_2P'_{1,3}P'_{2,3}$

其中 $P'_{i,j}$ 表示第 $i$ 个质数在模 $P_j$ 意义下的逆元。

---

```cpp
#include <bits/stdc++.h>
#define ll long long
#define Mid ((L+R)>>1)
using namespace std;
typedef pair<int,int> pii;
inline int read(){
	char c;int x=0;int b=1;do{c=getchar();if(c==45)b=-1;}while(c>57||c<48);
	do x=x*10+c-48,c=getchar();while(c<=57&&c>=48);x*=b;return x;
}
const ll mod1=998244353,mod2=1004535809,mod3=469762049,P=3;
const int maxn=100010;
ll i,j,k,n,m,p,a[maxn*4],b[maxn*4];

ll A[maxn*4],B[maxn*4],Ans[maxn*4][4],tmp[maxn*4];
int R[maxn*4];
ll ksm(ll sum,ll num,ll mod){
	ll ans=1;
	while(num){
		if(num&1)ans=ans*sum%mod;
		sum=sum*sum%mod;
		num>>=1;
	}return ans;
}
void NTT(int len,ll *a,bool op,ll mod){
	for(int i=0;i<len;i++)tmp[R[i]]=a[i];
	for(int i=0;i<len;i++)a[i]=tmp[i];
	ll Wn,w,P2=ksm(P,mod-2,mod);
	for(int i=1;i<len;i*=2){
		Wn=ksm((op? P:P2),(mod-1)/(i*2),mod);
		for(int j=0;j<len;j+=i*2){
			w=1;
			for(int k=0;k<i;k++,w=w*Wn%mod){
				int K=k+j;
				ll S1=a[K],S2=a[K+i]*w%mod;
				a[K]=(S1+S2)%mod;
				a[K+i]=(S1-S2+mod)%mod;
			}
		}
	}
}
void work1(){
	memset(A,0,sizeof(A));memset(B,0,sizeof(B));
	for(i=0;i<n;i++)A[i]=a[i]%mod1;for(i=0;i<m;i++)B[i]=b[i]%mod1;
	int len=1,L=0;
	while(len<=n+m)len*=2,++L;
	for(i=0;i<len;i++)R[i]=(R[i/2]/2)+((i&1)*(1<<L-1));
	NTT(len,A,true,mod1);NTT(len,B,true,mod1);
	for(i=0;i<len;i++)A[i]=A[i]*B[i]%mod1;
	NTT(len,A,false,mod1);
	for(i=0;i<len;i++)Ans[i][0]=A[i]*ksm(len,mod1-2,mod1)%mod1;
}
void work2(){
	memset(A,0,sizeof(A));memset(B,0,sizeof(B));
	for(i=0;i<n;i++)A[i]=a[i]%mod2;for(i=0;i<m;i++)B[i]=b[i]%mod2;
	int len=1,L=0;
	while(len<=n+m)len*=2,++L;
	for(i=0;i<len;i++)R[i]=(R[i/2]/2)+((i&1)*(1<<L-1));
	NTT(len,A,true,mod2);NTT(len,B,true,mod2);
	for(i=0;i<len;i++)A[i]=A[i]*B[i]%mod2;
	NTT(len,A,false,mod2);
	for(i=0;i<len;i++)Ans[i][1]=A[i]*ksm(len,mod2-2,mod2)%mod2;
}
void work3(){
	memset(A,0,sizeof(A));memset(B,0,sizeof(B));
	for(i=0;i<n;i++)A[i]=a[i]%mod3;for(i=0;i<m;i++)B[i]=b[i]%mod3;
	int len=1,L=0;
	while(len<=n+m)len*=2,++L;
	for(i=0;i<len;i++)R[i]=(R[i/2]/2)+((i&1)*(1<<L-1));
	NTT(len,A,true,mod3);NTT(len,B,true,mod3);
	for(i=0;i<len;i++)A[i]=A[i]*B[i]%mod3;
	NTT(len,A,false,mod3);
	for(i=0;i<len;i++)Ans[i][2]=A[i]*ksm(len,mod3-2,mod3)%mod3;
}
void out(__int128 x){
	if(x/10)out(x/10);
	putchar(x%10+'0');
}
void get(int i){
	__int128 ans=0,A=mod1,B=mod2,C=mod3,a=Ans[i][0],b=Ans[i][1],c=Ans[i][2],MOD=A*B*C;
	//out(a);cout<<' ';out(b);cout<<' ';out(c);cout<<endl;
	ans+=a*C%MOD*B%MOD*ksm(B,A-2,A)%MOD*ksm(C,A-2,A)%MOD;
	ans+=b*A%MOD*C%MOD*ksm(C,B-2,B)%MOD*ksm(A,B-2,B)%MOD;
	ans+=c*B%MOD*A%MOD*ksm(A,C-2,C)%MOD*ksm(B,C-2,C)%MOD;
	ans%=MOD;printf("%lld ",(ll)(ans%p));
}
int main() {
	freopen("P4245.in","r",stdin);
	freopen("P4245.out","w",stdout);
	cin>>n>>m>>p;++n;++m;
	for(i=0;i<n;i++)a[i]=read();
	for(i=0;i<m;i++)b[i]=read();
	work1();work2();work3();
	for(i=0;i<n+m-1;i++)get(i);
	cout<<endl;
	//cerr << 1.0*clock()/CLOCKS_PER_SEC << endl;
	return 0;
}
```

---

## 作者：Awar3ness (赞：4)

这道题因为模数不一定有原根，所以朴素的NTT无法通过，而朴素FFT会导致精度炸掉也无法通过。这里我们使用一种奇技淫巧：
我们取一个参数t，将多项式表示成它除以t的商和余数，这样会生成2n个多项式，分别对他们FFT以后，再合并答案即可。
由于这种算法对精度要求较高，所以需要使用long double。
代码非常容易实现：
```
#include <bits/stdc++.h>
#define ll long long
using namespace std;
int n,m,i,j,k,len,A[500005],B[500005],p;ll C[500005];const long double pi=acos(-1);
struct cp
{
	long double x,y;
	cp(long double x=0.0,long double y=0.0):x(x),y(y){}
	friend cp operator+(cp a,cp b){return cp(a.x+b.x,a.y+b.y);}
	friend cp operator-(cp a,cp b){return cp(a.x-b.x,a.y-b.y);}
	friend cp operator*(cp a,cp b){return cp(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);}
}w,wn,t,a[524288],b[524288],c[524288],d[524288],e[524288],f[524288],g[524288],h[524288];
void fft(cp *a,int n,int op)
{
    for(i=k=0;i<n;i++)
    {
        if(i>k) swap(a[i],a[k]);
        for(j=(n>>1);(k^=j)<j;j>>=1);
    }
    for(k=2,wn=cp(cos(2*pi*op/k),sin(2*pi*op/k));k<=n;k<<=1,wn=cp(cos(2*pi*op/k),sin(2*pi*op/k)))
        for(i=0,w=cp(1,0);i<n;i+=k,w=cp(1,0)) for(j=0;j<(k>>1);j++,w=w*wn)
            t=a[i+j+(k>>1)]*w,a[i+j+(k>>1)]=a[i+j]-t,a[i+j]=a[i+j]+t;
    if(op==-1) for(i=0;i<n;i++) a[i].x/=n;
}
void mtt(int n,ll M)
{
	for(int i=0;i<n;i++) a[i].x=A[i]/M,b[i].x=A[i]%M,c[i].x=B[i]/M,d[i].x=B[i]%M;//拆分
	fft(a,n,1);fft(b,n,1);fft(c,n,1);fft(d,n,1);
	for(int i=0;i<n;i++) e[i]=a[i]*c[i],f[i]=a[i]*d[i],g[i]=b[i]*c[i],h[i]=b[i]*d[i];//合并，ab，cd不用合并，因为没有意义
	fft(e,n,-1);fft(f,n,-1);fft(g,n,-1);fft(h,n,-1);
	for(int i=0;i<n;i++) C[i]=((ll)(e[i].x+0.1)*M%p*M%p+(ll)(f[i].x+0.1)*M%p+(ll)(g[i].x+0.1)*M%p+(ll)(h[i].x+0.1))%p;//拆分的时候除了几次参数，这里就要乘回去几次
}
int main()
{
	scanf("%d%d%d",&n,&m,&p);
	for(int i=0;i<=n;i++) scanf("%d",&A[i]);
	for(int i=0;i<=m;i++) scanf("%d",&B[i]);
	for(len=1;len<=n+m;len<<=1);mtt(len,32768);
	for(int i=0;i<=n+m;i++) printf("%lld ",C[i]);
}
```

---

## 作者：EternalEpic (赞：3)

模数不是像 $998244353$ 这样可以用NTT搞的玩意儿啦，这不满足NTT的性质，不能直接用原根搞，要MTT或3模NTT，笔者这里采用的是利用复数共轭性质（三次变两次优化？）的5次FFT，比4次正宗MTT的稍微慢一点但好想。

不妨令：
$$a_1 = a / c$$
$$a_0 = a - a_1$$

同理：
$$b_1 = b / c$$
$$b_0 = b - b_1$$

这里取
$$c = 32767 (2^{15} - 1)$$

我们就可以拆系数保持精度FFT辣~~~

然后，朴素算法是需要调用7次FFT。这里我们可以构造复数：
$$f = a_0 + a_1i$$
$$h = a_0 - a_1i$$
$$g = b_0 + b_1i$$
所以
$$f * g = a_0b_0 + (a_1b_0 + a_0b_1)i - a_1b_1$$
$$h * g = a_0b_0 - (a_1b_0 - a_0b_1)i + a_1b_1$$
我们就可以通过两式加减来得到
$$a_0b_0 \ a_1b_1 \ a_1b_0 \ a_0b_1$$
我们实际上只需要先dft出  $f \ h \ g$ 再把两个答案数组idft即可。

参考[command_block大佬博客](https://www.luogu.com.cn/blog/command-block/solution-p4245)

```cpp
namespace _MTT {
	const long double PI = acos(-1.0);
	const Complex I = Complex(1, 0);
	const int mod = 1e9 + 7;
	int lim = 1, rev[Maxn];
	Complex f[Maxn], g[Maxn], h[Maxn];
	
	inline void FFT(int limit, Complex *arr, int type) {
		for (int i = 0; i < limit; i++)
			if (i < rev[i]) swap(arr[i], arr[rev[i]]);
		for (int mid = 1; mid < limit; mid <<= 1) {
			Complex tmp(cos(PI / mid), type * sin(PI / mid));
			for (int i = 0; i < limit; i += mid << 1) { Complex w(1, 0);
				for (register int j = 0; j < mid; j++, w = w * tmp) {
					Complex x = arr[i + j], y = w * arr[i + j + mid];
					arr[i + j] = x + y, arr[i + j + mid] = x - y;
				}
			}
		}
	}

	inline void MTT(int *a, int *b, int n, int m, int *ret) {
		int c = 32767; int v = 1ll * c * c % mod; ll a0b0, a1b1, a0b1, a1b0;
		for (int i = 0; i < lim; i++) f[i] = g[i] = h[i] = Complex(0, 0);
		for (int i = 0; i < n; i++) f[i] = Complex(a[i] % c, a[i] / c), h[i] = f[i].Vary();
		for (int i = 0; i < m; i++) g[i] = Complex(b[i] % c, b[i] / c);
		FFT(lim, f, 1), FFT(lim, g, 1), FFT(lim, h, 1);
		for (int i = 0; i < lim; i++)
			g[i] = g[i] / lim, f[i] = f[i] * g[i], h[i] = h[i] * g[i];
		FFT(lim, f, -1), FFT(lim, h, -1);
		for (int i = 0; i < lim; i++) {
    		a0b0 = ll(round((f[i].x + h[i].x) / 2.0)) % mod;
    		a0b1 = ll(round((f[i].y + h[i].y) / 2.0)) % mod;
    		a1b0 = ll(round(f[i].y) - a0b1) % mod;
    		a1b1 = ll(round(h[i].x) - a0b0) % mod;
    		ret[i] = ll(a0b0 + 1ll * c * (a0b1 + a1b0) % mod) % mod;
    		ret[i] = ll(ret[i] + 1ll * v * a1b1 % mod) % mod;
    		ret[i] = ll(ret[i] + mod) % mod;
		}
	}
} using namespace _MTT;
```


---

## 作者：w33z8kqrqk8zzzx33 (赞：2)

我是一只菜鸡，学不会 NTT，所以只能用 **系数分支** 做这道题了。。。

如果直接暴力用 FFT，用 `long double` 还是0分。明显精度炸了，所以考虑如何缩小系数。

首先，设定 $C=\lceil\sqrt{P}\rceil$。

可以把 $A(x)$ 写成 $A_0(x)+C\times A_1(x)$，和 $A_0(x)$ 和 $A_1(x)$ 的系数都小于 $C$。

把 $B(x)$ 一样写成 $B_0(x)+C\times B_1(x)$。

现在，

$$A(x)B(x)=A_0(x)B_0(x)+A_0(x)B_1(x)C+A_1(x)B_0(x)C+A_1(x)B_1(x)C^2$$

这些系数缩小的时候，相乘最大结果系数是 $N(C-1)^2$，大概在 $10^{14}$ 级别，使用 `long double` 就可以过。只用 4 次多项式相乘。如果记一化 $A_0$，$A_1$，$B_0$，$B_1$ 的 DFT 和 $A_0(x)B_1(x)+A_1(x)B_0(x)$ 捆绑 IDFT，可以达到 7 次 FFT。

主要代码：

```cpp
cd a1[262144], b1[262144];
cd a2[262144], b2[262144];
cd r1[262144], r2[262144], r3[262144];
int Av[100005], Bv[100005];
ll ans[262144];

void mult(const int& as, const int& bs, const int& C, const int& P) {
	int n = as+bs-1;
	while(n - (n & (-n))) n += (n & (-n));
	constructrev(n);
	rep(i, as) {
		a1[i] = cd(Av[i] % C);
		a2[i] = cd(Av[i] / C);
	}
	rep(i, bs) {
		b1[i] = cd(Bv[i] % C);
		b2[i] = cd(Bv[i] / C);
	}
	fft(a1, n, 0); fft(a2, n, 0); fft(b1, n, 0); fft(b2, n, 0);
	rep(i, n) r1[i] = a1[i]*b1[i];
	rep(i, n) r2[i] = (a1[i]*b2[i]+a2[i]*b1[i]);
	rep(i, n) r3[i] = a2[i]*b2[i];
	fft(r1, n, 1); fft(r2, n, 1); fft(r3, n, 1);
	int V = C*C%P;
	rep(i, n) ans[i] = (((ll)round(r1[i].real())%P)+C*((ll)round(r2[i].real()))%P+V*((ll)round(r3[i].real())%P))%P;
}


```

---

## 作者：VenusM1nT (赞：2)

$\textbf{MTT}$.  
（这个 sb 写 $\textbf{FFT}$ 的时候忘记 $/\text{lim}$ 调了一年）  
这题是不是三模 $\textbf{NTT}$ 要奇技淫巧啊……咱不会那种东西，还是拆系数 $\textbf{FFT}$ 友好一点，好记……  
似乎可以从 7 次优化到 2 / 1.5 次诶……不过不会那种东西也可以过……  
思路就是把每个数拆成 $a\times2^{15}+b$，这样可以令 $F=a* b$，$G=c* d$ ，那么 $F* G$ 就可以表示为 $a* c+a* d+b* c+b* d$，最后的答案就是 $a* c\times2^{30}+(a* d+b* c)\times 2^{15}+b* d$。  
一共 7 次 $\textbf{FFT}$，优秀，恩。
```cpp
#include<bits/stdc++.h>
#define MAXN 1000005
#define reg register
#define inl inline
#define int long long
#define db long double
using namespace std;
const db Pi=acos(-1.0);
struct Complex
{
	db x,y;
	friend Complex operator + (const Complex &a,const Complex &b)
	{
		return ((Complex){a.x+b.x,a.y+b.y});
	}
	friend Complex operator - (const Complex &a,const Complex &b)
	{
		return ((Complex){a.x-b.x,a.y-b.y});
	}
	friend Complex operator * (const Complex &a,const Complex &b)
	{
		return ((Complex){a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x});
	}
}a[MAXN],b[MAXN],c[MAXN],d[MAXN],f[MAXN],g[MAXN],h[MAXN];
int n,m,Mod,lim=1,maxn,rev[MAXN],F[MAXN],G[MAXN],ans[MAXN];
inl void FFT(reg Complex *A,reg int opt)
{
	for(reg int i=0;i<lim;i++) if(i<rev[i]) swap(A[i],A[rev[i]]);
	for(reg int mid=1;mid<lim;mid<<=1)
	{
		reg Complex Wn=((Complex){cos(Pi/(db)mid),(db)opt*sin(Pi/(db)mid)});
		for(reg int j=0;j<lim;j+=(mid<<1))
		{
			reg Complex W=((Complex){1,0});
			for(reg int k=0;k<mid;k++,W=W*Wn)
			{
				reg Complex x=A[j+k],y=W*A[j+k+mid];
				A[j+k]=x+y;
				A[j+k+mid]=x-y;
			}
		}
	}
}
inl void MTT(reg int *A,reg int *B)
{
	while(lim<=(n+m))
	{
		lim<<=1;
		maxn++;
	}
    for(reg int i=0;i<lim;i++) rev[i]=((rev[i>>1]>>1)|((i&1)<<maxn-1));
	for(reg int i=0;i<lim;i++)
	{
		a[i].x=A[i]>>15;
		b[i].x=A[i]&0x7fff;
		c[i].x=B[i]>>15;
		d[i].x=B[i]&0x7fff;
	}
	FFT(a,1); FFT(b,1); FFT(c,1); FFT(d,1);
	for(reg int i=0;i<lim;i++)
	{
		f[i]=a[i]*c[i];
		g[i]=a[i]*d[i]+b[i]*c[i];
		h[i]=b[i]*d[i];
	}
	FFT(f,-1); FFT(g,-1); FFT(h,-1);
	for(reg int i=0;i<lim;i++) ans[i]=((((int)(f[i].x/(db)lim+0.5)%Mod)<<30)%Mod+(((int)(g[i].x/(db)lim+0.5)%Mod)<<15)%Mod+(int)(h[i].x/(db)lim+0.5)%Mod)%Mod;
    //不要忘了 /lim 啊！
}
signed main()
{
	scanf("%lld %lld %lld",&n,&m,&Mod);
	for(reg int i=0;i<=n;i++) scanf("%lld",&F[i]),F[i]%=Mod;
	for(reg int i=0;i<=m;i++) scanf("%lld",&G[i]),G[i]%=Mod;
	MTT(F,G);
	for(reg int i=0;i<=n+m;i++) printf("%lld ",ans[i]);
	return 0;
}
```

---

## 作者：lahlah (赞：2)

# ~~三模数NTT~~
~~不会~~

本来想写三模数NTT，发现常数太TM大了，还不知道怎么优化，于是就写拆系数FFT吧


首先一个简单的方法就是直接FFT开long double 去跑，发现精度掉得十分严重（值域大于long long），于是考虑如何解决


~~通过学习bitset的经验我们知道要压位~~

考虑拆系数

假设多项式$A * B$, 模数是$P$

确定一个常数 $C$ 一般为$2^{15}= 32$,$768$ 或 $\sqrt{P}$


考虑把$A_i$ 拆成 $a_i *C+b_i$

把$B_i$ 拆成 $c_i *C+d_i$

即

$A_i = a_i *C+b_i$

$B_i = c_i *C+d_i$

考虑两个数$X,Y$相乘

设$X = a*C+b$

$Y= c *C+d$

$X*Y=(a *C+b)*(c *C+d)$

$=ac*C^2 + (ad+bc)C+bd$

发现$C$先不用管，要求的是$ac,ad+bc,bd$

然后把$a,b,c,d$分别求值(DFT)，乘起来后再对$ac,ad+bc,bd$做插值(IDFT)就行了

一共是4次DFT+3次IDFT=7次FFT


常数巨大

发现一开始的虚数部并没有用到，参考FFT3次变2次的优化，试试这个能不能行


设$X = a+bi$

$Y= c +di$

$X*Y=(a+bi)*(c+di)=ac-bd + (bc+ad)i$


然鹅和我们要求的$ac,bd,ad+bc$

现在已经就出来了$ad+bc$

考虑如何求剩下两个

设$X' = a - bi$

$Y= c + di$

$X'*Y=(a-bi)*(c+di)=ac+bd + (ad-bc)i$

然后就知道了实数部$ac+bd$的值

结合上面$ac-bd$的值就可以求出来$ac$和$bd$了

然后代入$ac*C^2 + (ad+bc)C+bd$就行了


这样貌似只用对$X,Y,X'$做3次求值（DFT）

再对$X*Y,X'*Y$做2次插值就可以了

也就是说一共5次

据说myy有4次的%%%%% orz


code:

```cpp
#include<bits/stdc++.h>
#define N 4000005
#define ll long long
#define double long double
using namespace std;
const double pi = acos(-1);
const double eps = 0.49;
const int C = 32768;//常数
struct cp {
	double a, b;
}X[N], Y[N], Xd[N];
cp operator +(cp x, cp y) {return cp{x.a + y.a, x.b + y.b};}
cp operator -(cp x, cp y) {return cp{x.a - y.a, x.b - y.b};}
cp operator *(cp x, cp y) {return cp{x.a * y.a - x.b * y.b, x.b * y.a + x.a * y.b};}
int rev[N], n, m, P;
void fft(cp *a, int len, int o) {
	for(int i = 1; i <= len; i ++) rev[i] = (rev[i >> 1] >> 1) | ((i&1) * len >> 1);
	for(int i = 1; i <= len; i ++) if(i < rev[i]) swap(a[i], a[rev[i]]);

	for(int i = 2; i <= len; i <<= 1) {
		cp wn = cp{cos(2 * pi / i), o * sin(2 * pi / i)};
		for(int j = 0, p = i / 2; j + i - 1 <= len; j += i) {
			cp w0 = cp{1, 0};
			for(int k = j; k < j + p; k ++, w0 = w0 * wn) {
				cp x = a[k], y =  w0 * a[k + p];
				a[k] = x + y;
				a[k + p] = x - y;
			}
		}
	}
	if(o == -1) for(int i = 0; i <= len; i ++) a[i].a /= len, a[i].b /= len;
}
int main() {
	scanf("%d%d%d", &n, &m, &P);
	for(int i = 0; i <= n; i ++) {
		int x;
		scanf("%d", &x);
		X[i].a = x / C;
		X[i].b = x % C;
		Xd[i].a = x / C;//Xd就是X'
		Xd[i].b = -(x % C);
	}
	for(int i = 0; i <= m; i ++) {
		int x;
		scanf("%d", &x);
		Y[i].a = x / C;
		Y[i].b = x % C;
	}
	int len = 1;
	for(; len <= n + m;) len <<= 1;
	fft(X, len, 1), fft(Xd, len, 1), fft(Y, len, 1);//DFT 三次
	for(int i = 0; i <= len; i ++) X[i] = X[i] * Y[i], Xd[i] = Xd[i] * Y[i];
	fft(X, len, -1), fft(Xd, len, -1);//IDFT两次
	for(int i = 0; i <= n + m; i ++) {
		ll ac = (X[i].a + Xd[i].a) / 2 + eps;
		ll bd = Xd[i].a - ac + eps;
		ll bcad = X[i].b + eps;
		printf("%lld ", (ac * C % P * C % P + bcad * C % P + bd) % P);//计算
	}
	return 0;
}

```
板子一遍过，感动.jpg


---


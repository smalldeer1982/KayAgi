# [CQOI2016] 密钥破解

## 题目描述

一种非对称加密算法的密钥生成过程如下：

1.任选两个不同的质数$p,q$

2.计算$N=p \times q$，$r=(p-1)(q-1)$

3.选取小于$r$，且与$r$互质的整数$e$

4.计算整数$d$，使得$ed≡1(mod r)$

5.二元组$(N,e)$称为公钥，二元组$(N,d)$称为私钥。

当需要加密消息$n$时，（假设$n$是一个小于$N$的整数，因为任何格式的消息都可转为整数表示），使用公钥$(N,e)$，按照

$$n^e≡c(mod N)$$

运算，可得到密文$c$

对密文$c$解密时，用私钥$(N,d)$，按照

$$c^d≡n(mod N)$$

运算，可得到原文 $n$。算法正确性证明省略。

由于用公钥加密的密文仅能用对应的私钥解密，而不能用公钥解密，因此称为非对称加密算法。通常情况下，公钥由消息的接收方公开，而私钥由消息的接收方自己持有。这样任何发送消息的人都可以用公钥对消息加密，而只有消息的接收方自己能够解密消息。

现在，你的任务是寻找一种可行的方法来破解这种加密算法，即根据公钥破解出私钥，并据此解密密文。

## 说明/提示

对于$30\%$的数据，$e,N,c \le 2^{20}$；

对于$100\%$的数据，$e,N,c \le 2^{62},c<N$

## 样例 #1

### 输入

```
3 187 45```

### 输出

```
107 12```

# 题解

## 作者：Weng_Weijie (赞：9)

显然将$N$分解因数之后能得到$p,q$，然后就能算出$r,d,n$  

所以这题的难点就在于如何分解因数，这里用到了Pollard rho算法  

Pollard rho 算法原理：

生成一个随机数$x_1$, 判断$x_1$能否整除$N$, 如果不能，那么继续由$x_1$生成下一个$x_2$，已知循环做下去，必定构成一个环，形状类似一个$\rho$，所以叫Pollard rho算法

Pollard rho 算法流程 (注:2至6均在模$N$意义下)：

1. 判断$N$是否为质数，若是质数直接退出
2. 随机一个$x$和常数$c$  
3. 令$y=x$
4. 令$x=x^2+c,d=\gcd(x-y,n)$
5. 重复执行4，直到$x=y$或$d|n$且$0<d<n$
6. 若$x=y$那么重新从1开始执行
7. 继续递归分解$d$和$\frac{n}{d}$

之后得到$N = pq$，之后剩余的就轻松解决了

代码如下

```cpp
#include <stdio.h>
#include <stdlib.h>

#define int long long

int e, N, c, d, n, r;
//计算x,y的积
inline int mul(int x, int y, int c) {
	x %= c, y %= c; int r = 0;
	while (y) {
		if (y & 1) {r = r + x; if (r >= c) r -= c; }
		x = x + x; if (x >= c) x -= c; y = y >> 1;
	}
	return r;
}
//计算x的y次方
inline int pow(int x, int y, int c) {
	x %= c; int r = 1;
	while (y) {
		if (y & 1) r = mul(r, x, c); x = mul(x, x, c);
		y >>= 1;
	}
	return r;
}
int gcd(int a, int b) { return b ? gcd(b, a % b) : a; }
//求逆元
void exgcd(int a, int b, int &x, int &y) {
	if (!b) x = 1, y = 0;
	else {
		exgcd(b, a % b, y, x);
		y = (r + y - mul(a / b, x, r)) % r;
	}
}
//pollard rho算法
int pollard(int n, int c) {
	int x, y, d, i = 1, k = 2;
	x = 1LL * rand() * rand() % (n - 1) + 1;
	y = x;
	while (1) {
		x = (mul(x, x, n) + c) % n;
		d = gcd((x - y + n) % n, n);
		if (d > 1 && d < n) return d;
		if (x == y) return n;
        // x=y说明构成了一个环，说明选定的c不好，那么重新来一遍
		if (++i == k) k <<= 1, y = x; 
        // 由于y不一定在环内，所以随时更新y的值，不然会死循
	}
	return 23333333;
}

int tmp;
signed main() {
	signed x; srand(x);

	scanf("%lld%lld%lld", &e, &N, &c);
	int p = N;
	while (p >= N) p = pollard(N, 1LL * rand() * rand() % (n - 1) + 1);
	r = (p - 1) * (N / p - 1); exgcd(e, r, d, tmp);
	printf("%lld %lld\n", d, pow(c, d, N));
	return 0;
}
```

---

## 作者：Fatalis_Lights (赞：4)

**题目传送门：** [Link.](https://www.luogu.com.cn/problem/P4358)

**题意简述：**

> 给定正整数 $e,N,c$ ，其中 $N$ 满足 $N=p\times q$， $p,q$ 为两个不相等的素数， $e$ 满足 $e\leq (p-1)(q-1)$ 且 $\gcd(e,(p-1)(q-1))=1$。

> 求出正整数 $d,n$ ，使得 $d$ 和 $n$ 分别满足以下两个式子：

> $$ed\equiv 1\pmod{(p-1)(q-1)}$$

> $$n\equiv c^d\pmod{N}$$

> 数据范围：$e,N,c\leq 2^{62},c< N$。

## Solution

~~快速幂，扩欧，分解素因数三合一板子题实锤。~~

先看第一个式子，我们已经知道了 $e$ ，显然再搞出 $p,q$ 就可以了。一看数据范围是 $2^{62}$ ，那么很显然套 Pollard_rho 求 $p,q$ 了，顺便开 int128 。

然后就可以把第一个式子里的模数搞定了，套一个 exgcd 就能做出 $d$ ，第二个式子里再放一个快速幂就能做 $n$ 。

~~再然后呢？再然后输出就完了。~~

code:

```cpp
#include<bits/stdc++.h>
#define times 10
#define N 6081
#define ll __int128
using namespace std;

ll ct,cnt;
ll fac[N],num[N];

inline __int128 read(){
    __int128 x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}

inline void print(__int128 x){
    if(x<0){putchar('-');x=-x;}
    if(x>9) print(x/10);
    putchar(x%10+'0');
}

//

inline ll gcd(ll a,ll b){ 
	return b? gcd(b,a%b): a; 
}

inline ll abss(ll x){ return (x<0)?-x:x; }

inline ll ksc(ll a, ll b, ll m){
	ll res=0; a%=m;
	while(b){
		if(b&1){ res=(res+a)%m; b--; }
		b>>=1; a=(a+a)%m;
	}
	return res;
}

inline ll ksm(ll a, ll b, ll m){
	ll res=1; a%=m;
	while(b){
		if(b&1){ res=ksc(res,a,m); b--; }
		b>>=1; a=ksc(a,a,m);
	}
	return res;
}

inline bool Miller_Rabin(ll n){
	if(n==2) return true;
	if(n<2 || !(n&1)) return false; 
	ll m=n-1;
	int k=0;
	while((m&1)==0) k++, m>>=1;
	for(int i=0;i<times;i++){
		ll a=rand()%(n-1)+1;
		ll x=ksm(a,m,n);
		ll y=0;
		for(int j=0;j<k;j++){
			y=ksc(x,x,n);
			if(y==1 && x!=1 && x!=n-1) return false;
			x=y;
		}
		if(y!=1) return false;
	}
	return true;
}

ll pollard_rho(ll n,int a){
    ll x=2,y=2,d=1,k=0,i=1;
    while(d==1){
        k++;
        x=(x*x+a)%n;
        d=gcd(abss(x-y),n);
        if(k==i){y=x;i<<=1;}
    }
    if(d==n) return pollard_rho(n,a+1);
    return d;
}

void find(ll n){
	if(n==1) return;
	if(Miller_Rabin(n)){ fac[ct++]=n; return; }
	ll p=n;
	while(p>=n) p=pollard_rho(p,rand()%(n-1)+1);
	find(p); find(n/p);
}

//brent_pollard_rho

ll n,p,q,e,c,r,x,y,k;
ll ans;

void exgcd(ll a, ll b){
    if(!b) x=1,y=0;
    else{
        exgcd(b,a%b);
        k=x; x=y;
    	y=k-a/b*y;
    }
}//ax=1(mod b), exgcd(a,b);

void solve(){
    find(n);
    p=fac[0],q=fac[1];
    r=(p-1)*(q-1);
    exgcd(e,r);
    x=(x%r+r)%r;
    ans=ksm(c,x,n);
    return;
}

signed main(){
    e=read(), n=read(); c=read();
    srand(114514); solve();
    print(x);putchar(32);print(ans);puts("");
	return 0;
}
```

---

## 作者：andysk (赞：3)

# 【CQOI2016】密钥破解



题目链接：[Link](https://www.luogu.org/problemnew/show/P4358)



### 题解

其实就是一个Pollard-Rho的板子题，但是Luogu上的[【模板】Pollard-Rho算法](https://www.luogu.org/problemnew/show/P4718) 难度是道黑题，然后这道是个紫题。

这个题就是把它告诉你的流程算一遍就可以了。

做法很显然，那个$ p, q $的计算显然非常的简单，直接Pollard-Rho把$N$分解了就是。

$p,q$出来了，$r$直接按照$(p - 1)(q - 1) $ 算就可以了。

这个时候，它给了你一个同余方程, $ed \equiv 1\pmod {r}$ ，知道了$1, r$，所以直接扩欧求解即可。

然后最后快速幂求$n$

但是注意$2^{64} * 2 ^ {64}$ 是肯定会炸 long long 的，所以要么就用__int128或者快速乘了



### Code

```c++
#include <bits/stdc++.h>
using namespace std;

typedef long long LL;

inline LL read()
{
    char ch = getchar();
    LL f = 1, x = 0;
    while (ch < '0' || ch > '9') { if (ch == '-') f = -1; ch = getchar(); }
    while (ch >= '0' && ch <= '9') { x = (x << 1) + (x << 3) + ch - '0'; ch = getchar(); }
    return x * f;
}

inline void write(LL x)
{
    if(x < 0) x = -x, putchar('-');
    if(x >= 10) write(x / 10);
    putchar(x % 10 + '0');
}

LL e, N, c, r;

inline LL Qmul(LL a, LL b, LL p)
{
    LL d = (long double) a / p * b + 1e-8;
    LL r = a * b - d * p;
    return r < 0 ? r + p : r;
}

inline LL Qpow(LL x, LL y, LL p)
{
    LL ans = 1;
    for ( ; y ; x = Qmul(x, x, p), y >>= 1) y & 1 ? ans = Qmul(ans, x, p) : 0;
    return (LL) ans % p ;
}

inline LL gcd(LL a, LL b) {return b ? gcd(b, a % b) : a;}

inline LL f(LL x, LL a, LL mod) {return (Qmul(x, x, mod) + a) % mod;}

int a[] = {2, 3, 5, 7, 11};
const int M = (1 << 7) - 1;

inline LL find(LL n)
{
    for (int i = 0; i < 5; ++i) if (n % a[i] == 0) return a[i];
    LL x = rand(), y = x, a = rand() % (n - 2) + 2, t = 1;
    for (int k = 2; ; k <<= 1, y = x)
    {
        LL p = 1;
        for (int i = 1; i <= k; ++i)
        {
            x = f(x, a, n);
            p = Qmul(p, abs(x - y), n);
            if (!(i & M))
            {
                t = gcd(p, n);
                if (t > 1) break;
            }
        }
        if (t > 1 || (t = gcd(p, n)) > 1) break;
    }
    return t;
}
inline LL pollard_rho(LL x)
{
    LL p = x;
    while (p == x) p = find(x);
    return p;
}

inline void exgcd(LL a, LL b, LL& x, LL& y, LL& t)
{
    if (!b) t = a, x = 1, y = 0;
    else exgcd(b, a % b, y, x, t), y -= a / b * x;
}

int main()
{
    srand(time(NULL));
    e = read(), N = read(), c = read();
    LL p = pollard_rho(N), q = N / p; LL r = (p - 1) * (q - 1);
    LL d, y, t;
    exgcd(e, r, d, y, t);
    t = r / t;
    d = (d % t + t) % t;
    LL n = Qpow(c, d, N);
    std::cout << d << " " << n;
    return 0;
}
```



这个写法目前全Luogu第七快????

---

## 作者：龙翔凤翥 (赞：3)

### 一道Pollard-Rho的模板题;
## 思路:
1. 先将N用Pollard-Rho分解
2. 看到同余用拓展欧几里得求解线性同余方程
# Code:
```cpp
// luogu-judger-enable-o2
#include<bits/stdc++.h>
using namespace std;
#define RN register int
#define LL long long 
inline LL read()//快读
{
    int k=1;LL x=0;  
    char c=getchar();
    while ((c<'0'||c>'9')&&c!='-')c=getchar();
    if(c=='-')
    k=-1,c=getchar();
    while(c>='0'&&c<='9')
    x=(x<<3)+(x<<1)+c-'0',c=getchar();
    return k*x;
}   
LL n,x1,x2,c,e,C,x,y;
inline LL quick(LL a,LL b,LL c)//快速乘
{
    LL res=0;
    while(b)
    {
        if(b&1)
        res=(res+a)%c;
        a=(a+a)%c;
        b>>=1;
    }
    return res;
}
inline LL mul(LL a,LL b,LL c)//快速幂
{
    LL res=1;
    while(b)
    {
        if(b&1)
        res=quick(res,a,c);
        a=quick(a,a,c);
        b>>=1;	
    }
    return res;
}
inline LL gcd(LL a,LL b)
{
    return b?gcd(b,a%b):a;
}
inline void exgcd(LL a,LL b)//拓欧解线性同余方程
{
    if(!b)
    {
        x=1;y=0;
        return ;
    }
    exgcd(b,a%b);
    LL t=x;
    x=y;
    y=t-(a/b)*y;
}
inline LL  poLL(LL n)//Pollard-Rho
{
    LL xx=rand()%(n-1)+1,x1=xx,r,c=rand()%(n-1)+1,s=1;
    for(register LL k=2;;k<<=1,xx=x1,s=1)
    {
        for(register LL i=1;i<=k;i++)
        {
            x1=(__int128)x1*x1%n+c;//防止爆long long
            s=(__int128)s*abs(x1-xx)%n;
            if(!(i%127))//每计算127次算一次DCD,加速
            {
                r=gcd(s,n);
                if(r>1)return r;//找到一个不平凡因子
            }
        }
        r=gcd(s,n);
        if(r>1)
        return r;
    }
}
int main()
{
    srand(time(NULL));
    e=read(),n=read(),C=read();
    LL t=n;
    while(t==n)
    t=poLL(n);
    LL r=(t-1)*(n/t-1);
    exgcd(e,r);
    LL d=(x%r+r)%r;//解线性同余方程
    printf("%lld %lld\n",d,mul(C,d,n));
    return 0;
}
```


---

## 作者：critnos (赞：2)

**这篇题解着重讲如何将 $n$ 分解为 $pq$。**

虽然 Pollard-rho 挺简单的，但是我试图用暴力水过去。

---

最简单的方法就是，枚举 $n$ 的因数。

```cpp
for(i=2;n%i;i++);
```
得分：$50\ pts$。

---

然后加一个优化：因为 $p,q$ 均是素数，而素数不可能是偶数，所以 $i$ 枚举奇数就行了。

```cpp
for(i=3;n%i;i+=2);
```
（当然还要考虑 $p=2$ 的情况）

得分：$60\ pts$。

---

考虑出题人的心理：它肯定要构造两个相近的大素数相乘，所以我再用一个 $j$ 从 $\sqrt n$ 向下枚举。两边同时进行。

```cpp
for(i=2,j=sqrt(n);n%i&&n%j;i++,j--);
```
得分：$80\ pts$。

---

把上面两个优化结合起来。

```cpp
j=sqrt(n);
if(j%2==0) j--;
for(i=3;n%i&&n%j;i+=2,j-=2);
```

得分：$90\ pts$。

---

事实上，每次 $+2$ 是个好方法，但还有更好的。

除了 $2,3$，每个素数 $\bmod\ 6$ 只能是 $1$ 或 $5$。

证明：显然余 $0$ 不可能。若余数为 $x$，则原数为 $6a+x$。令 $g=\gcd(6,x)$，原式可化为 $g(6a/g+x/g)$。显然如果 $g>1$ 那么原数至少有因数 $g$，则不满足“原数是素数”这一条件。则 $g$ 只能等于 $1$。这样说明 $x$ 必然与原数互质，而小于 $6$ 的正整数只有 $1,5$ 和 $6$ 互质。这个结论可以推广到任意正整数。

打广告：https://www.luogu.com.cn/blog/2-6-5-3-5/dui-ou-la-shai-di-chang-shuo-you-hua

```cpp
j=sqrt(n);
while(j%6!=5) j--;
for(i=5;n%i&&n%(i+2)&&n%j&&n%(j+2);i+=6,j-=6);
```
得分：$100\ pts$。

---

## 作者：Guess00 (赞：2)

## Pollard-Rho模板
### 前置知识：
- $1.\text{Pollard-Rho}$算法

> $\text{Pollard-Rho}$是一个高效分解质因数的算法$,$这是一个随机算法$,$比较玄学$.$
 
> 关于$\text{Pollard-Rho}$算法可参考以下资料:
[$\text{洛谷日报167 PollardRho-快速分解质因数}$](https://www.luogu.org/blog/zenyz/pollardrho-kuai-su-fen-xie-zhi-yin-shuo)
[$\text{P4718 【模板】Pollard-Rho算法}$](https://www.luogu.org/problemnew/show/P4718)

- $2.$扩展欧几里得($exgcd$)算法
> 基础数论算法,求$ax+by=gcd(a,b)$


---

### 本题分析:

- $0.$根据题意列出所有式子(帮助分析):

$\qquad\qquad N=p*q \;$①

$\qquad\qquad r=(p-1)*(q-1)\;$②

$\qquad\qquad gcd(r,e)=1 \;$③

$\qquad\qquad e*d≡1(mod\;\; r) \;$④

$\qquad\qquad n^e≡c(mod\;\; N) \;$⑤

$\qquad\qquad c^d≡n(mod\;\; N) \;$⑥

$\qquad\qquad \text{已知:N,e,c}$

- $1.$根据①②式用$\text{Pollard-Rho}$分解出$p$和$q,$利用已求出的$p$和$q$计算出$r$

- $2.$将④式转化为$e*d+r*x=1\;(d>0),$已知$e,r,$套$exgcd,$求出$d$

- $3.$根据⑥式$,$已知$c,d,N,$用快速幂求出$n$

---

### $Code:$
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int pri[]={2,3,5,7,11,13,17,23,29};
int e,N,c,Np,Nq,r,d,n;
inline void read(int &x)   //快读 
{
    short negative=1;
    x=0;
    char c=getchar();
    while(c<'0' || c>'9')
    {
        if(c=='-')
            negative=-1;
        c=getchar();
    }
    while(c>='0' && c<='9')
        x=(x<<3)+(x<<1)+(c^48),c=getchar();
    x*=negative;
}
inline void print(int x)    //快输 
{
    if (x<0)
        putchar('-'),x=-x;
    if(x>9)
        print(x/10);
    putchar(x%10+'0');
}
inline int gcd(int a,int b){return b==0?a:gcd(b,a%b);}
inline int ksc(int x,int y,int mod)   //快速乘 
{
    return (x*y-(long long)((long double)x/mod*y)*mod+mod)%mod;
}
inline int ksm(int a,int b,int m)      //快速幂 
{
    int ans=1;
    a%=m;
    while(b)
    {
        if(b&1)
            ans=ksc(a,ans,m);
        b/=2;
        a=ksc(a,a,m);
    }
    ans%=m;
    return ans;
}
inline bool MR(int x,int p)
{
    if(ksm(x,p-1,p)!=1)
        return false;
    int k=p-1;
    while(!(k&1))
    {
        k>>=1;
        int t=ksm(x,k,p);
        if(t!=1 && t!=p-1)
            return false;
        if(t==p-1)	
            return true;
    }
    return true;
}
inline bool Miller_Rabin(int p)
{
    if (p==1 || p==2152302898747)
        return false;
    for (int i=0;i<9;i++)
    	if (p==pri[i])
    		return true;
    	else
    		if (p%pri[i]==0 || (!MR(pri[i],p)))
    			return false;
    return true;
}
inline void Pollard_Rho(int x) 
{
	//因为本蒟蒻被七宗罪之一Sloth牢牢控制,懒得删Miller_Rabin 
    if(Miller_Rabin(x))
    {
    	Np=x;
        return; 
    }
    int t1=rand()%(x-1)+1;
    int t2=t1,b=rand()%(x-1)+1;
    t2=(ksc(t2,t2,x)+b)%x;
    int p=1,i=0;
    while(t1!=t2)
    {
        i++;
        p=ksc(p,abs(t1-t2),x);
        if(p==0)
        {
            int t=gcd(abs(t1-t2),x);
            if(t!=1 && t!=x) 
                Pollard_Rho(t),Pollard_Rho(x/t);
            return;
        }
        if(i%127==0)
        {
            p=gcd(p,x);
            if(p!=1 && p!=x)
            {
                Pollard_Rho(p);
                Pollard_Rho(x/p);
                return;
            }
            p=1;
        }
        t1=(ksc(t1,t1,x)+b)%x;
        t2=(ksc(t2,t2,x)+b)%x;
        t2=(ksc(t2,t2,x)+b)%x;
    }
    p=gcd(p,x);
    if(p!=1 && p!=x)
    {
        Pollard_Rho(p);
        Pollard_Rho(x/p);
        return;
    }
}
inline void exgcd(int a,int b,int &x,int &y)
{
    if (b==0)
    {
    	x=1,y=0;
    	return;
    }
    exgcd(b,a%b,y,x);
    //y=y-a/b*x;        Important:y是正数,所以不能直接这样写.正解如下 
    (y=r+y-ksc(a/b,x,r))%=r;      //加上r再模r,确保y为正 
}
signed main(void)
{
    int x;
    read(e),read(N),read(c);  //读入 
    Pollard_Rho(N);           //Pollard_Rho分解N,求出一个质数 
    Nq=N/Np;                  //算出另一个质数 
    r=(Np-1)*(Nq-1);          //通过两个质数求出r 
    exgcd(e,r,d,x);           //exgcd 算出 d 
    n=ksm(c,d,N);             //快速幂算出n 
    print(d),putchar(' '),print(n);  //输出 
    return 0;
}
```

---

## 作者：WeLikeStudying (赞：1)

**背景**
- [RSA加密算法](https://baike.baidu.com/item/RSA%E7%AE%97%E6%B3%95/263310?fromtitle=RSA%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95&fromid=9645994&fr=aladdin)。
- ~~似乎是因为它数论才备受重视。~~
- [本题题面](https://www.luogu.com.cn/problem/P4358)。
- 为什么我们不可以用这种方式破译呢？
- 给出一组数据：到 2009 年，常用的大质数乘积 $N$ 一般在 $768$ 到 $2048$ 个（二进制）位之间，这显然远远超出我们的处理范围。
- 另外为了下面的方便，我们重新给出了 $\text{RSA}$ 的定义方式。
- 给出质数 $p,q$（应该满足 $p\ne q$），取 $N=p\times q$，$r=(p-1)\times(q-1)$，取 $e\perp r$，取其模 $r$ 下的逆元 $d$。
- 当 $a\perp p$ 时，$a^{p-1}=a\pmod p$，否则 $p|a$，$a^{p-1}=0=a\pmod p$。
- 故容易得到 $(a^e)^d=a^{e\times d}=a\pmod N$，但给出 $e,N$，要求 $d$ 是困难的，所以每个人都可以利用公钥 $N,e$ 对文章加密，但持有私钥 $N,d$ 才能解密。

**题意**
- 给出 $e,N,c$，求 $d,n$ 其中 $c=n^e\pmod N$，它代表着密文。
- 题面中给出的数据保证不大于 $2^{62}$。

**思路**
- 如果能得到 $N$ 的质因数分解 $p\times q$，即可得到 $r=(p-1)\times(q-1)$，接着求 $e$ 模 $r$ 下的逆元即可得到 $d$，最后计算 $c^d\bmod N$ 即可得到 $n$。
- 后面我们会说明没有比分解 $N$ 更简单的方法。
- 但这里 $N$ 的规模达到了 $2^{62}$，普通的试除法行不通。
- [可以观看质因数分解模板题的题解了解如何分解这个规模的大数](https://www.luogu.com.cn/blog/luo1gu1zui1bang1/zhi-yin-shuo-fen-xie)。
- 不过由于这题的特殊性质，我们并不需要 Miller-Rabin 来判断是不是质数~~这不更好不用担心自己 RP。~~
- 另外由于模数并不是质数，需要用[拓展欧几里得](https://www.luogu.com.cn/blog/luo1gu1zui1bang1/ta-zhan-ou-ji-li-dei)求解逆元。
- [代码实现](https://www.luogu.com.cn/paste/qu5inf70)。
- 下面是关于这道题目的一些拓展，引自《算法导论》。

**一些有趣的性质**
- 设 $P(n)=n^e\bmod N$ 函数用来表示加密过程。
- 显然 $P(a)\times P(b)\equiv P(a\times b)\pmod N$，同样的性质对解密也成立。
- 下面我们来证明：如果你有一种算法能较好地破译模 $N$ 意义下 $1\%$ 的 $P(a)$，那么你可以运行一种概率性算法以破译每一个 $P(a)$。
- 方法：随机一个 $b$，利用公钥计算 $P(b)$ 和 $P(a)\times P(b)=P(a\times b)$，如果能破译出（以 $1\%$ 的概率） $a\times b$，那么我们即可破译出 $a$。

---

## 作者：thecold (赞：1)

### 前置知识 Pollard_Rho和EXgcd

我们看到$ N <= 2^{62}$的，而且这题我们只要分解出来P , Q就可以了，但是我们发现$ O(\sqrt n)$分解质因数算法不可过，于是我们就可以选择$O(n^{\frac{1}{4}})$来分解质因数，之后我们就可以快乐的求出来r，随后用exgcd求出e$ (ed\equiv1(\bmod r) \Leftrightarrow e*d + x * r = 1)$

又因为$ e , r$互质，所以$ e * d + x * r = 1$有解，求出来一个通解$d$之后不要忘记了把$d$化成最小正整数，要不然你快速幂的时候会死得很惨

愉快的代码时间：

```
#include <cstdio>
#include <cctype>
#include <algorithm>
#include <chrono>
#include <ctime>
#include <random>
using namespace std;
typedef long long ll;
inline ll read()
{
	ll res = 0;
	bool flag = false;
	char c;
	c = getchar();
	while(!isdigit(c))
	{
		flag = (c == '-');
		c = getchar();
	}
	while(isdigit(c))
	{
		res = res * 10 + (c ^ 48);
		c = getchar();
	}
	return !flag ? res : -res;
}
inline ll mul(ll x , ll y , ll MOD)
{
	ll ret = 0;
	while(y)
	{
		if(y & 1)	ret += x , ret %= MOD;
		x += x , x %= MOD;
		y >>= 1;
	}
	return ret;
}
mt19937 rnd;
inline ll getr(ll l , ll r)
{
	uniform_int_distribution<ll> dis(l , r);
	return dis(rnd);
}
int prime[10] = {0 , 2 , 3 , 5 , 7 , 11 , 13 , 17};
inline ll quickpow(ll x , ll y , ll MOD)
{
	ll ret = 1;
	while(y)
	{
		if(y & 1)	ret = mul(ret , x , MOD);
		x = mul(x , x , MOD);
		y >>= 1;
	}
	return ret;
}
inline ll gcd(ll a , ll b)
{
	return !b ? a : gcd(b , a % b);
}
inline ll f(ll a , ll b , ll MOD)
{
	return (mul(a , a , MOD) + b) % MOD;
}
inline ll Pollard_Rho(ll p)
{
	ll x = 1 , y = 1 , cnt , ply = 1;
	ll c = getr(1 , p);
	for(int k = 1 ;  ; k <<= 1 , y = x , ply = 1)
	{
		for(cnt = 1 ; cnt <= k ; ++ cnt)
		{
			x = f(x , c , p);
			ply = mul(ply , abs(x - y) , p);
			if(cnt % 127 == 0)
			{
				ll g = gcd(ply , p);
				if(g > 1)	return g;
			}
		}
		ll g = gcd(ply , p);
		if(g > 1)	return g;
	}
}
ll son , e , N , c , d , n , ansd , ansx;
void exgcd(ll tmpa , ll tmpb)//a * ansd + b * ansx = 1
{
	if(!tmpb)
	{
		ansd = 1 , ansx = 0;
		return;
	}
	exgcd(tmpb , tmpa % tmpb);
	ll lastd = ansd , lastx = ansx;
	ansd = lastx , ansx = lastd - tmpa / tmpb * lastx;
}
int main()
{
	rnd.seed(std::chrono::steady_clock::now().time_since_epoch().count());
	e = read() , N = read() , c = read();
	son = N;
	while(son == N)
		son = Pollard_Rho(N);
	ll r = (son - 1) * (N / son - 1);
	exgcd(e , r);
	ansd = (ansd % r + r) % r;
	n = quickpow(c , ansd , N);
	printf("%lld %lld" , ansd , n);
	return 0;
}
```


---

## 作者：chihik (赞：1)

这道题没有想象中的那么难，只不过板子[P4718 【模板】Pollard-Rho算法](https://www.luogu.org/problem/P4718)是黑的（~~为什么这道题是紫的~~）

既然题目保证$n$为两质数$p,q$乘积。我们可以用
$Pollard~Rho$求出$p,q$。

然后跟着题目一步步模拟，计算$r=(p-1)*(q-1)$

然后根据$ed≡1(mod~r)$计算$d$（我用的扩欧）。

最后，用快速幂求出$n≡c^d(mod~N)$

因为数据范围很大，我用的是__int128，注意它不能用标准输入输出，要手写读优输优。

```cpp
#include <cstdio>
#include <ctime>
#include <cstdlib>
using namespace std;
#define int __int128

void Read( int &x ) {
	x = 0;int f = 1;
	char s = getchar( );
	while( s < '0' || s > '9' ) {
		if( s == '-' ) f = -1;
		s = getchar( );
	}
	while( '0' <= s && s <= '9' ) {
		x = x * 10 + s - '0';
		s = getchar( );
	}
	x *= f;
}
void Write( int x ) {
	if( x < 0 ) {
		x = -x;
		putchar('-');
	}
	if( x >= 10 )
		Write( x / 10 );
	putchar( x % 10 + '0' );
}

int Exgcd( int a , int b , int &x , int &y ) {
	if( !b ) {
		x = 1 , y = 0;
		return a;
	}
	else {
		int r = Exgcd( b , a % b , y , x );
		y -= x * ( a / b );
		return r;
	}
}
int Gcd( int x , int y ) {
	return y == 0 ? x : Gcd( y , x % y );
}
int Abs( int x ) {
	return x >= 0 ? x : -x;
}
int f( int x , int a , int Mod ) {
	return ( x * x + a ) % Mod;
}
int Quick_pow( int x , int po , int Mod ) {
	int Ans = 1;
	while( po ) {
		if( po % 2 )
			Ans = Ans * x % Mod;
		x = x * x % Mod;
		po /= 2;
	}
	return Ans;
}
int Inv( int x , int Mod ) {
	int u , v;
	Exgcd( x , Mod , u , v );
	return ( u % Mod + Mod ) % Mod;
}

int Pollard_rho( int n ) {
	int r = rand( ) % ( n - 1 ) + 1;
	int a = f( 0 , r , n ) , b = f( f( 0 , r , n ) , r , n ); 
	while( b != a ) {
		int p = Gcd( Abs( b - a ) , n );
		if( p > 1 ) return p;
		a = f( a , r , n ) , b = f( f( b , r , n ) , r , n );
	}
	return n;
}

int N , e , c , p , q , r , d , n; 
signed main( ) {
	srand( 20060204 );
	
	Read( e ) , Read( N ) , Read( c ); 
	p = Pollard_rho( N ) , q = N / p;
	r = ( p - 1 ) * ( q - 1 );
	d = Inv( e , r );
	n = Quick_pow( c , d , N );
	/*Write( d ) , putchar('\n');
	Write( n ) , putchar('\n');
	Write( p ) , putchar('\n');
	Write( q ) , putchar('\n');
	Write( r ) , putchar('\n'); */
	Write( d ) , putchar(' ') , Write( n ); 
	return 0;
} 
```


---

## 作者：anideahe (赞：1)

### 题意：  

给定正整数 $e$，$N$，$c$，其中 $N$ 满足 $N=p\times q$，$p$，$q$ 为两个不相等的素数，$e$ 满足 $e\leq (p-1)(q-1)=r$ 且 $\gcd(e,r)=1$。

求出正整数 $d$,$n$，使得 $d$ 和 $n$ 分别满足以下两个式子：

$ed\equiv 1\pmod{r}$

$n\equiv c^d\pmod{N}$

数据范围：$e$，$N$，$c\leq 2^{62}$，$c< N$。

### 思路

由于题目保证 $r$，$e$ 互质，但不保证 $r$ 为质数，采用 exgcd 算法。

由于数据较大，采用龟速乘，__int128 也可以处理。

难点在于质因数分解，我采取的方法是~~骗分~~。

最朴素的想法直接大力分解$O(\sqrt{N}^2)$：

```
for(int i=2;i<=sqrt(N);i++)
   if(check(i)&&check(N/i)&&N%i==0){
		p=i,q=N/i;
		break;
	}
```

发现由于给出的 $N$ 能被两个唯一的质数分解，所以根本没必要判断，$O(\sqrt{N})$：

```
for(p=2;N%p;p++);
q=N/p;
```

考虑数据，如果 $N$ 可以被分解为一个小质数，那么一下子就扫到了，所以转换枚举顺序：

```
for(p=sqrt(N);N%p;p--);
q=N/p;
```

然后就能 AC 了。

实际上可以继续优化，如除 2 以外质数均为奇数：

```
p=sqrt(N);
if(p%2==0) p--;
for(p;N%p;p-=2);
q=N/p;
if(N%2==0) p=2,q=N/2;
```

### Code:

```cpp
#include<cstdio>
#include<cmath>
using namespace std;
#define int long long
int p,q,N,r,e,d,c,k;
inline int check(int x){
	for(int i=2;i<=sqrt(x);i=-~i)
		if(x%i==0)
			return 0;
	return 1;
}
inline int gcd(int a,int b){
	return !b?a:gcd(b,a%b);
}
inline int mul(int a,int b,int mod){
	int res=0;
	while(b){
		if(b&1) res=(res+a)%mod;
		a=(a+a)%mod;
		b>>=1;
	}
	return res;
}
void exgcd(int a,int b,int &x,int &y){
	if(!b){
		x=1,y=0;
		return ;
	}
	exgcd(b,a%b,x,y);
	int z=x;
	x=y,y=(z-mul(a/b,y,r)+r)%r;
}
inline int qpow(int a,int b,int p){
	int s=1;
	while(b){
		if(b&1) s=mul(s,a,p);
		a=mul(a,a,p),b>>=1;
	}
	return s;
}
signed main(){
	scanf("%lld%lld%lld",&e,&N,&c);
	p=sqrt(N);
	if(p%2==0) p--;
	for(p;N%p;p-=2);
	q=N/p;
	if(N%2==0) p=2,q=N/2;
	r=(p-1)*(q-1);
	exgcd(e,r,d,k);
	d=(d%r+r)%r;
	printf("%lld %lld",d,qpow(c,d,N));
	return 0;
}
```


---

## 作者：Endt (赞：0)

# 密钥破解-题解

> 任选两个不同的质数 $p,q$。
>
> 计算 $N=p \times q,r=(p-1)(q-1)$。

已知 $N$，可以用 Pollard-Rho 或类似的大整数分解算法求解出 $p,q$，以及 $r$。

> 计算整数 $d$，使得 $ed\equiv 1\pmod{r}$。

已知 $e$，求解出了 $r$，用 exGCD 解出 $e$ 在模 $r$ 意义下的逆元 $d$。

> $c^d\equiv n\pmod{N}$。

已知 $c,N$，求解出了 $d$，用快速幂求出 $n$。

```cpp
#include<bits/stdc++.h>

#define  Int  long long int
#define  get  auto
#define  Pub  public
#define  rand  Rand
std::mt19937_64 rand(time(NULL));

using std::min;using std::max;

Int qpow(Int a,Int b,Int mod){
    Int A=1;
    while(b){
        if(b&1)A=(__int128)A*a%mod;
        a=(__int128)a*a%mod;
        b>>=1;
    }
    return A;
}
Int gcd(Int a,Int b){
    if(!b)return a;
    else return gcd(b,a%b);
}
void exgcd(Int a,Int b,Int &x,Int &y){
    if(!b)x=1,y=0;
    else{
        Int xx,yy;
        exgcd(b,a%b,xx,yy);
        x=yy,y=xx-a/b*yy;
    }
}
Int inv(Int a,Int b){
    Int x,y;
    exgcd(a,b,x,y);
    return (x%b+b)%b;
}

bool Miller_Rabin(Int p){
    if(p<2)return 0;
    if(p==2)return 1;
    Int d=p-1,r=0;
    while((d&1)==0)++r,d>>=1;
    for(Int k=1;k<=10;++k){
        Int a=rand()%(p-2)+2;
        Int x=qpow(a,d,p);
        if(x==1||x==p-1)continue;
        for(int i=0;i<r-1;++i){
            x=(__int128)x*x%p;
            if(x==p-1)break;
        }
        if(x!=p-1)return 0;
    }
    return 1;
}

Int Pollard_Rho(Int x){
    Int s=0,t=0;
    Int c=rand()%(x-1)+1;
    Int val=1;
    for(int goal=1;;goal*=2,s=t,val=1){
        for(int step=1;step<=goal;++step){
            t=((__int128)t*t+c)%x;
            val=(__int128)val*std::abs(t-s)%x;
            if(step%127==0){
                Int d=gcd(val,x);
                if(d>1)return d;
            }
        }
        Int d=gcd(val,x);
        if(d>1)return d;
    }
}

Int ans;
void fac(Int x){
    if(x<=ans||x<2)return;
    if(Miller_Rabin(x)){
        ans=max(ans,x);
        return;
    }
    Int p=x;
    while(p>=x)p=Pollard_Rho(x);
    while(x%p==0)x/=p;
    fac(x),fac(p);
}
int T;Int e,n,c,p,q,r,d;
int main(){
    scanf("%lld%lld%lld",&e,&n,&c);
    fac(n);
    p=ans,q=n/ans;
    r=(p-1)*(q-1);
    d=inv(e,r);
    printf("%lld %lld",d,qpow(c,d,n));
    return 0;
}
```

---

## 作者：SunsetSamsara (赞：0)

## 前置知识

Pollard Rho 算法

## 分析

其实只需要分解 $n$ 即可，剩下直接使用题目中的信息。

Pollard-Rho 可以查看 [PR 模板](https://www.luogu.com.cn/problem/P4718)，

中间的 $d$ 可以用拓展欧几里得或者欧拉定理求逆元的方法解决。

## 代码

PR代码:
```cpp

lld _rand(){return 1ll*rand()*rand();}
lld _pollardrho(lld m,lld r){
	lld x,y,g;
	int i=1,k=2;
	x=_rand()%(m-1)+1;
	y=x;
	while(1){
		x=(mul(x,x,m)+r)%m;
		g=gcd((x-y+m)%m,m);
		if(1<g&&g<m)return g;
		if(x==y)return m;
		if(++i==k)k<<=1,y=x;
	}
}
lld pollardrho(lld m){
	int x;srand(x);
	lld p=m;
	while(p>=m)p=_pollardrho(n,_rand()%(m-1)+1);
	return p;
}
```


---


# 「EZEC-3」四月樱花

## 题目背景

$$又到樱花曼舞的春日，$$

$$花蕾，像无数星星闪烁在枝头含春嬉戏，$$

$$心有灵犀；$$

$$又是为花吹雪的季节，$$

$$花蕊，引万千蜂蝶赶树梢抱春絮语，$$

$$心有念想。$$

$$开了，一夜乍起，$$

$$火树樱花汇聚开遍山野好似茫茫沧海；$$

$$大地樱花，$$

$$赏心悦目怒放层林尽染好似朵朵云霞；$$

$$纵有三千烦恼，$$

$$不过灿烂阳光下释然地娓娓一笑；$$

$$纵有万般郁闷，$$

$$不如和煦暖风里淡淡地悠悠一了；$$



[——《四月樱花》](http://music.163.com/song?id=1355079681&userid=587823498)

![樱花](https://cdn.luogu.com.cn/upload/image_hosting/g5m4h8a3.png)

## 题目描述

在樱花盛开的四月，```Muxii``` 望着满天飘落的樱花，向身旁的 ```ZZH``` 问道：

“究竟有多少朵樱花在这个四月飘落？”

```ZZH``` 答道：“樱花飘落的朵数 $s$ 与时间 $t$ 有如下关系：

$$s=\prod_{x=1}^t\prod_{y|x}\frac{y^{d(y)}}{\prod_{z|y}(z+1)^2}$$

其中 $d(y)$ 表示 $y$ 的约数个数。”

但作为一个~~文科生~~萌新，```Muxii``` 显然无法清楚地知道具体的数目，因此他只好继续向 ```ZZH``` 询问这个问题的答案。

由于数量可能很大，所以你只需要替 ```ZZH``` 告诉 ```Muxii``` 他所需要的答案对 $p$ 取模的结果就好了。

## 说明/提示

**「样例 1 说明」**

代入计算可得答案为 $\frac1{2073600}$，由于 $2073600$ 在模 $998244353$ 意义下的逆元为 $648735108$，故最终答案为 $1×648735108\bmod998244353 = 648735108$。

**「数据范围与约定」**

**数据保证答案的最简表示中分母不含 $p$ 和 $p$ 的倍数。**

对于所有数据，保证 $1\leq t\leq 2.5×10^9$，$9.9×10^8<p<1.1×10^9$ 且 $p$ 为质数。
|子任务编号|$t≤$|分值|
|:-:|:-:|:-:|
|$1$|$10^3$|$5$|
|$2$|$10^4$|$5$|
|$3$|$2×10^5$|$10$|
|$4$|$2×10^6$|$20$|
|$5$|$10^7$|$20$|
|$6$|$10^8$|$20$|
|$7$|$2.5×10^9$|$20$|

注：本题采用**捆绑测试**，即必须通过单个子任务的所有测试点才可获得该子任务的分数。

## 样例 #1

### 输入

```
4 998244353```

### 输出

```
648735108```

## 样例 #2

### 输入

```
10 1000000007```

### 输出

```
872041698```

# 题解

## 作者：ZigZagKmp (赞：26)

本题解同步发表于[我的cnblog](https://www.cnblogs.com/ZigZagKmp/archive/2020/09/01.html)
### 2020.8.29更新
被命题人@了，原来的做法已经过不去了……

这题是一道很不错的数论题，对整除分块的考察及其时间复杂度分析与优化较为深入。

### 算法考察
整除分块，常见数论函数性质。

## 算法分析

我们来推一推柿子。

显然$d(y)=\sum_{z|y}1$，因此$y^{d(y)}=\prod_{z|y}y$。

我们把$y$拆开：
$$\prod_{z|y}y=\prod_{z|y}z\times\prod_{z|y}\frac{y}{z}=\left(\prod_{z|y}z\right)^2=\prod_{z|y}z^2$$

因此原式可推导如下：
$$\prod_{x=1}^t\prod_{y|x}\prod_{z|y}\frac{z^2}{(z+1)^2}$$

改为枚举$y$

$$\left(\prod_{y=1}^t\prod_{z|y}\frac{z^2}{(z+1)^2}\right)^{\left\lfloor\frac{t}{y}\right\rfloor}$$

改为枚举$z$

$$\left(\prod_{z=1}^t\frac{z^2}{(z+1)^2}\right)^{\sum_{y=1}^{\left\lfloor\frac{t}{z}\right\rfloor}\left\lfloor\frac{t}{yz}\right\rfloor}$$

我们设$f(n)=\sum_{i=1}^n \left\lfloor\frac{n}{i}\right\rfloor$：
$$\left(\prod_{z=1}^t\frac{z^2}{(z+1)^2}\right)^{f\left(\left\lfloor\frac{t}{z}\right\rfloor\right)}$$

----
### 整除分块基础——求解$f(n)$

考虑$f(n)$如何求解。（有整除分块基础的同学可以跳过）

通过观察，我们可以发现$\left\lfloor\frac{n}{i}\right\rfloor$最多有$O(\sqrt n)$种不同的取值，且随$i$增大单调不减。

单调性显然，取值个数简单证明一下：
- $i\le \sqrt n$时，有$\sqrt n$个不同的$i$，对应至多$\sqrt n$个不同的$\left\lfloor\frac{n}{i}\right\rfloor$；
- $i>\sqrt n$时，发现$\left\lfloor\frac{n}{i}\right\rfloor<\sqrt n$，因此也至多有$\sqrt n$个不同的取值。

因此我们考虑枚举这$\sqrt n$种不同的取值即可求解，单次求解的时间复杂度为$O(\sqrt n)$。

求解$f(n)$的代码如下：
```cpp
int get_f(int n){
	int ret=0;
	for(int l=1,r;l<=n;l=r+1){
		r=n/(n/l);
		// l,r表示区间[l,r]内的整数i，floor(n/i)相等（均为 n/l）
		// l,r 的值的推导本处不展开
		// 可以参考下面相关题目的题解 
		ret=(ret+1ll*(r-l+1)*(n/l))%mod;
		// 区间[l,r]内有(r-l+1)个整数，它们的整除值都是 n/l 
	}
	return ret;
}
```

相关题目：[[CQOI2007]余数求和](https://www.luogu.com.cn/problem/P2261)

----

回到原问题，现在我们已经可以用$O(\sqrt n)$的时间复杂度求出$f(n)$的值。

### 整除分块进阶——整除分块嵌套

我们再观察式子：

$$\left(\prod_{z=1}^t\frac{z^2}{(z+1)^2}\right)^{f\left(\color{red}{\left\lfloor\frac{t}{z}\right\rfloor}\right)}$$

我们发现$f(n)$的自变量也出现整除，也就意味着**会出现一段连续的$z$，使得$\left\lfloor\frac{t}{z}\right\rfloor$的值相同，即$f\left({\left\lfloor\frac{t}{z}\right\rfloor}\right)$也一定相同**。

因此对于**指数相同的部分**，我们只需要知道**底数的部分积**即可。

观察底数部分的部分积。

$$\prod_{z=l}^r\frac{z^2}{(z+1)^2}=\frac{l^2}{(r+1)^2}$$

发现这个值可以配合费马小定理求逆元快速求出。

类比整除分块的过程，我们枚举$O(\sqrt t)$个不同的$\left\lfloor\frac{t}{z}\right\rfloor$的值，指数部分可以用整除分块求解。

这就是整除分块套整除分块。

类比杜教筛，时间复杂度为$O(t^{\frac{3}{4}}\log t)$，前面是整除分块套整除分块的复杂度，即$\sum_{i=1}^{\sqrt t}O(\sqrt i)+O(\sqrt{\frac{n}{i}})=O(t^{\frac{3}{4}})$，后面$\log t$是过程中求逆元。

----

### 算法优化
本算法还有进一步优化的空间。

继续类比杜教筛。在杜教筛中，我们**预处理出部分函数值及其前缀和**，从而将时间复杂度由$O(n^\frac{3}{4})$优化到$O(n^\frac{2}{3})$。对于本题，我们能不能也预处理出一部分$f(n)$，从而优化时间复杂度呢？

### 因数与倍数——$f(n)$求法优化

我们考虑$\left\lfloor\frac{a}{b}\right\rfloor$的实际含义，其可以表示**不超过$a$的数中有多少个是$b$的倍数**，即$\sum_{i=1}^a [b|i]$。

因此我们把$f(n)$改写如下：

$$f(n)=\sum_{i=1}^n \left\lfloor\frac{n}{i}\right\rfloor$$
$$=\sum_{i=1}^n \sum_{j=1}^n [i|j]$$
$$=\sum_{j=1}^n \sum_{i=1}^n [i|j]$$
$$=\sum_{j=1}^n \sum_{i|j}1$$
$$=\sum_{j=1}^n \sigma(j)$$

其中$\sigma(n)$表示$n$有多少个因数。

根据$\sigma(n)$的定义，我们不难写出单次询问$O(\sqrt n)$的算法求出单个$\sigma(n)$，但这个显然不能满足我们的需求。

现在我们考虑如何批量求出$\sigma(n)$。

注意到对每一个数$i$，**都会对$i$的倍数产生$1$的贡献**，因此我们再次**枚举倍数**，即可批量求出$\sigma(n)$，最后求一遍前缀和即可批量求出$f(n)$。

具体实现如下：
```cpp
for(int i=1;i<=N;i++){
	for(int j=1;i*j<=N;j++){
		sig[i*j]++;
	}
}
```
时间复杂度为$\sum_{i=1}^n\frac{n}{i}=O(n\log n)$，可用调和级数证明。

上述过程也可以用狄利克雷卷积解释，即$1\ *\ 1$，而求狄利克雷卷积的通用方法正是枚举倍数。

我们也不难看出$\sigma(n)$是一个**积性函数**，并且$\sigma(p^k)=k+1$，这意味着我们可以线性筛批量求出$\sigma(n)$，时间复杂度为$O(n)$。

相关题目：[[AHOI2005]约数研究](https://www.luogu.com.cn/problem/P1403)

----

综上，我们可以用$O(n\log n)$的时间复杂度求出前$n$个$f(n)$。假设我们预处理前$M$个$f(n)$的值，那么总时间复杂度为
$$M\log M+\sqrt t\log t+\sum_{i=1}^{t/M}\sqrt{\frac{t}{i}}\approx(2\sqrt{\frac{t^2}{M}}+M)\log t$$
由不等式相关知识得$M=t^\frac{1}{3}$，原式取最小值为$O(t^{\frac{2}{3}}\log t)$，实测$M=500000$较优。


## 代码实现
1. 注意$2.5\times10^9$超出了 `int` 范围，要使用`unsigned int`；
2. 注意对指数上的整除分块求和模数应为$\varphi(p)=p-1$；
3. 注意常数优化。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define maxn 1000005
#define ui unsigned
template <typename Tp> void read(Tp &x){
	int fh=1;char c=getchar();x=0;
	while(c>'9'||c<'0'){if(c=='-'){fh=-1;}c=getchar();}
	while(c>='0'&&c<='9'){x=(x<<1)+(x<<3)+(c&15);c=getchar();}x*=fh;
}
ui n,mod;
ui ans=1;
ui ksm(ui B,ui P){ui ret=1;while(P){if(P&1)ret=1llu*ret*B%mod;B=1llu*B*B%mod;P>>=1;}return ret;}
ui f[maxn];
ui calc(ui x){//整除分块求f(n) 
	if(x<=1000000)return f[x];
	ui ret=0;
	for(ui l=1,r;l<=x;l=r+1){
		r=x/(x/l);
		ret=(ret+1ll*(r-l+1)*(x/l))%(mod-1);
	}
	return ret;
}
void preprocess(int N){//预处理求f(n) 
	for(int i=1;i<=N;i++){
		for(int j=1;i*j<=N;j++){
			f[i*j]++;
		}
	}
	for(int i=1;i<=N;i++)f[i]=(f[i-1]+f[i])%mod;
}
signed main(){
	read(n);read(mod);
	preprocess(1000000);
	for(ui l=1,r;l<=n;l=r+1){
		r=n/(n/l);//整除分块嵌套 
		ui invr=1llu*l*ksm((r+1)%mod,mod-2)%mod;
		invr=1llu*invr*invr%mod;
		ans=1llu*ans*ksm(invr,calc(n/l))%mod;
	}
	printf("%u\n",ans);
	return 0;
}
```

## 后记
本题解中附有一些相关题目，其本身可能难度不是很大，但其思想与本题相同。

对于求解不同的数论问题，枚举因数与枚举倍数各有所长，有时可能要反复转化。

---

## 作者：peterwuyihong (赞：23)

# P6788 「EZEC-3」四月樱花
花了三天独自手推公式$A$掉这道题，代码还贼简单，常数特小

###### 吸氧中毒导致上不了$rank1$？？？
## $Day\ 1$
打完月赛回学校，我得意扬扬的说：“你看我$div2\ 320pts$！”

然后被 @YellowBean $D$了：“你无不无聊啊天天水比赛你个菜鸡，你打打$div1$么，你这个分搞一搞可以到$div1$的$rank100$，第三题拿个暴力分，再$\dots\dots$一下，$rank$就可以到第一页了。”（震惊！

回了家康了康$T3$，这是个啥啊草，$3$个$\Pi$，做个锤子$*****$。

欸是求$f(x)$类型的啊，那就好办了，看我$Oeis$神仙秒了它。欸不对是分母啊，这怎么办？？？

后来发现：咦？分子都是$1$耶！爷又活了！

算出了分母的数列，放到$Oeis$上：挂了。好，此题不可做，下一个！（初步结论

欸还可以分别算出分子分母啊，然后各自放在$Oeis$上：挂了。（大悲

## 关于$Oeis$，他死了
###### 我还翻译成$Python$辛辛苦苦搞了一通，害，看来$luogu$出题人都是毒瘤


好像一个一个预处理每个数的因子，$nlogn$可以搞到$20,30$的鸭子。我一预处理
```cpp
#include<bits/stdc++.h>
using namespace std;
#define maxn 2000010
#define int long long
int n,p;
int ans=1;
int ksm(int a,int b,int p){
	int ans=1;
	for(;b;b>>=1,a=a*a%p)
	if(b&1)ans=ans*a%p;
	return ans;
}
vector<int>v[maxn];
int d(int x){
	return (int)v[x].size();
}
int one(int x){
	int ans=1;
	for(int i=0;i<(int)v[x].size();i++)
	ans=ans*ksm((v[x][i]+1)*(v[x][i]+1)%p,p-2,p)%p;
	ans=ans*ksm(x,d(x),p)%p;
	return ans;
}
int two(int x){
	int ans=1;
	for(int i=0;i<(int)v[x].size();i++)
	ans=ans*one(v[x][i])%p;
	return ans;
}
signed main(){
	cin>>n>>p;
	for(int i=1;i<=n;i++)
	for(int j=i;j<=n;j+=i)
	v[j].push_back(i);
	for(int i=1;i<=n;i++)ans=ans*two(i)%p;
	cout<<ans;
}
```
然而只有十分，人傻常数大，不愧是我，然后我坚信复杂度正确，卡了一晚上常数$register,inline,trainhead$，还是挂了。（大悲
## $Day\ 2$
$YB:$今天我$AK$了$IMO$，$IMO$太水了。

在学校划了一天水，回了家忽然有了兴致推柿子，$t$都写成$n$了，实在是太喜欢$n$这个字母了
$$
\prod_{x=1}^n\prod_{y|x}\frac{y^{d(y)}}{\prod_{z|y}{(z+1)^2}}
$$
哎我可不可以算出$y^{d(y)}$，$(z+1)^2$分别乘除了几次啊

设$c1$是$y^{d(y)}$次数，$c2$是$(z+1)^2$次数

编了个程序计算，输入$100\ 54188$，输出
![](https://cdn.luogu.com.cn/upload/image_hosting/0i7gz40i.png)
咦$c1$不是$\lfloor\frac{100}{i}\rfloor$么！

哎哎$c2$是什么鬼啊，发现它好像和$c1$一一对应的（不大准确，就是那个意思），总是感觉$c2$是$c1$的函数，然后我猜想了$30min$是什么函数，是$\lfloor\frac{n^2}{i^2}\rfloor$么，是$\lfloor\frac{nk}{i}\rfloor$么（$k$为常数），是$Balabala。。。$么？

推了好久也没有进展，但是可以初步确定这玩意儿和$\lfloor\frac{n}{i}\rfloor$有关系了。于是回到原来的式子。
$$
\prod_{x=1}^n\prod_{y|x}\frac{y^{d(y)}}{\prod_{z|y}{(z+1)^2}}=\frac{\prod_{y=1}^n\prod_{x=1}^n{[x\%y==0]}y^{d(y)}}{\prod_{y=1}^n\prod_{x=1}^n[x\%y==0]\prod_{z|y}(z+1)^2}
$$
其中$[x\%y==0]$表示$x$除得尽$y$就算，相当于$if$语句。
$$
\frac{\prod_{y=1}^n\prod_{x=1}^n{[x\%y==0]}y^{d(y)}}{\prod_{y=1}^n\prod_{x=1}^n[x\%y==0]\prod_{z|y}(z+1)^2}=\frac{\prod_{y=1}^ny^{d(y)\lfloor\frac{n}{y}\rfloor}}{\prod_{z=1}^n\prod_{y=1}^n\prod_{x=1}^n[x\%y==0][y\%z==0](z+1)^2}
$$
说实话还是第一次推$\Pi$的式子呢
$$
\prod_{z=1}^n\prod_{y=1}^n\prod_{x=1}^n[x\%y==0][y\%z==0](z+1)^2=\prod_{z=1}^n(z+1)^{2\sum_{y=1}^n\sum_{x=1}^n[x\%y==0][y\%z==0]}
$$
这个式子$\prod_{y=1}^ny^{d(y)\lfloor\frac{n}{y}\rfloor}$就说明了$c1$为什么是$\lfloor\frac{n}{i}\rfloor$了。

这个式子$\prod_{z=1}^n(z+1)^{2\sum_{y=1}^n\sum_{x=1}^n[x\%y==0][y\%z==0]}$利用电脑发现$\sum_{y=1}^n\sum_{x=1}^n[x\%y==0][y\%z==0]$就是$c2$啊，就来搞一搞这个式子。
$$
\sum_{y=1}^n\sum_{x=1}^n[x\%y==0][y\%z==0]=\sum_{y=1}^n[y\%z==0]\sum_{x=1}^n[x\%y==0]
$$
$$
\sum_{y=1}^n[y\%z==0]\sum_{x=1}^n[x\%y==0]=\sum_{y=1}^n[y\%z==0]\lfloor\frac{n}{y}\rfloor=\sum_{y=1}^{\lfloor\frac{n}{z}\rfloor}\lfloor\frac{n}{yz}\rfloor
$$
由于整除的性质
$$
\lfloor\frac{a}{bc}\rfloor=\lfloor\frac{\lfloor\frac{a}{b}\rfloor}{c}\rfloor
$$
$$
\sum_{y=1}^{\lfloor\frac{n}{z}\rfloor}\lfloor\frac{n}{yz}\rfloor=\sum_{y=1}^{\lfloor\frac{n}{z}\rfloor}\lfloor\frac{\lfloor\frac{n}{z}\rfloor}{y}\rfloor=f(\lfloor\frac{n}{z}\rfloor)
$$
我们设$f(x)=\sum_{i=1}^n\lfloor\frac{n}{i}\rfloor$这个可以$O(\sqrt{n})$求，有一个常数很小的写法
```cpp
int f(int x){
	int ans=0;
	int m=sqrt(x);
	for(int i=1;i<=m;i++)ans+=x/i;
	ans<<=1,ans-=m*m;
	return ans;
}
```
这个比光整数分块常数小，原理可以自行$BFS$

然后我就打出了如下代码，$O(20pts)$
```cpp
#include<bits/stdc++.h>
using namespace std;
#define maxn 2000010
#define int long long
#ifndef ONLINE_JUDGE
	#define fuck getchar
#else
	#define fuck nc
#endif
char nc(){
  	static char buf[1<<25],*p=buf,*q=buf;
  	if(p==q&&(q=(p=buf)+fread(buf,1,1<<25,stdin),p==q))return EOF;
  	return *p++;
}
template<class T>void read(T&x){
	short f=1;x=0;
	char ch=fuck();
	while(!isdigit(ch)){
		if(ch=='-')f=-1;
		ch=fuck();
	}while(isdigit(ch)){
		x=(x<<1)+(x<<3)+(ch^48);
		ch=fuck();
	}x*=f;
}
template<class T>void write(T x){
	if(x<0)putchar('-'),x=-x;
	if(x>=10)write(x/10);
	putchar(x%10+48);
}

int n,p;
int ans=1;
int ksm(int a,int b,int p){
	int ans=1;
	for(;b;b>>=1,a=a*a%p)
	if(b&1)ans=ans*a%p;
	return ans;
}
vector<int>v[maxn];
int c1[maxn];//i^d(i)几次
int c2[maxn];//(i+1)^2几次 
int  pr[maxn], d[maxn], t[maxn], cnt;  // t 表示 i 的最小质因子出现的次数
bool bp[maxn];
void prime_work(int k) {
  bp[0] = bp[1] = 1,  d[1] = 1;
  for (int i = 2; i <= k; i++) {
    if (!bp[i]) pr[++cnt] = i, d[i] = 2, t[i] = 1;
    for (int j = 1; j <= cnt && i * pr[j] <= k; j++) {
      bp[i * pr[j]] = 1;
      if (i % pr[j] == 0) {
        d[i * pr[j]] = d[i] / (t[i] + 1) * (t[i] + 2),
               t[i * pr[j]] = t[i] + 1;
        break;
      } else
        d[i * pr[j]] = d[i] << 1, t[i * pr[j]] = 1;
    }
  }
}
signed main(){
	read(n),read(p);
	prime_work(n);
	for(int i=1;i<=n;i++)c1[i]=n/i;
	for(int i=1;i<=n;i++){
		for(int j=i;j<=n;j+=i)
		c2[i]+=n/j;
	}
	for(int i=1;i<=n;i++)ans=ans*ksm(ksm(i,d[i],p),c1[i],p)%p;
	for(int i=1;i<=n;i++)ans=ans*ksm(ksm((i+1)%p*(i+1),p-2,p),c2[i],p)%p;
	write(ans);
}
```
也就是说我一晚上加了十分？？？
## $Day\ 3$
今天是七夕，$YB$向他的女神求爱被拒，气的刷完了珂朵莉系列题。

昨天已经打开了思路的大门，今天课上都忍不住开始推。

第一节语文课，讲评的试卷没带，我就一边划水一边推柿子。

这个$d(x)$我能不能把它搞开啊？于是我开始手搞样例，并画了这样一张图。
![](https://cdn.luogu.com.cn/upload/image_hosting/qy2osy05.png)

表示$1$给乘了几下，$2$给乘了几下等。
![](https://cdn.luogu.com.cn/upload/image_hosting/arjkxgw9.png)
那么根据定义只需要把$1,2,3,4$分别乘上下面各列所有数之和个，再乘起来，就是分子。

$4,9,16,25$分别乘上右边各行所有数之和个，再乘起来，就是分母。

那么式子变成了这样：
$$
\frac{\prod_{x=1}^n\prod_{y=1}^{\lfloor\frac{n}{x}\rfloor}(xy)^{\lfloor\frac{n}{xy}\rfloor}}{\prod_{x=1}^n\prod_{y=1}^{\lfloor\frac{n}{x}\rfloor}(x+1)^{2\lfloor\frac{n}{xy}\rfloor}}
$$
草然后呢？

简写推不出来就展开来！

原式等于！
$$
\frac{\prod_{y=1}^{n}y^{\lfloor\frac{n}{y}\rfloor}\prod_{y=1}^{\lfloor\frac{n}{2}\rfloor}(2y)^{\lfloor\frac{n}{2y}\rfloor}\prod_{y=1}^{\lfloor\frac{n}{3}\rfloor}(3y)^{\lfloor\frac{n}{3y}\rfloor}\prod_{y=1}^{\lfloor\frac{n}{4}\rfloor}(4y)^{\lfloor\frac{n}{4y}\rfloor}}{\prod_{y=1}^{n}(2^2)^{\lfloor\frac{n}{y}\rfloor}\prod_{y=1}^{\lfloor\frac{n}{2}\rfloor}(3^2)^{\lfloor\frac{n}{2y}\rfloor}\prod_{y=1}^{\lfloor\frac{n}{3}\rfloor}(4^2)^{\lfloor\frac{n}{3y}\rfloor}\prod_{y=1}^{\lfloor\frac{n}{4}\rfloor}(5^2)^{\lfloor\frac{n}{4y}\rfloor}}
$$
我们分别统计$1,2,3,4$被乘了多少次。
### 分子
考虑$y$的项，$y$的项不就是上面图的每一行嘛！把$y$项提出来，就是
$$
\prod_{y=1}^ny^{f(\lfloor\frac{n}{y}\rfloor)}
$$
考虑常数项，就是
$$
\prod_{y=1}^n1^{\lfloor\frac{n}{y}\rfloor}\prod_{y=1}^{\lfloor\frac{n}{2}\rfloor}2^{\lfloor\frac{n}{2y}\rfloor}\prod_{y=1}^{\lfloor\frac{n}{3}\rfloor}3^{\lfloor\frac{n}{3y}\rfloor}\prod_{y=1}^{\lfloor\frac{n}{4}\rfloor}4^{\lfloor\frac{n}{4y}\rfloor}=\prod_{i=1}^ni^{\sum_{j=1}^{\lfloor\frac{n}{i}\rfloor}{\lfloor\frac{n}{ij}\rfloor}}=\prod_{i=1}^ni^{f(\lfloor\frac{n}{i}\rfloor)}
$$
### 分母
同理就是
$$
\prod_{i=1}^n(i+1)^{2f(\lfloor\frac{n}{i}\rfloor)}
$$
### 揉在一起
$$
\frac{\prod_{y=1}^ny^{f(\lfloor\frac{n}{y}\rfloor)}\prod_{i=1}^ni^{f(\lfloor\frac{n}{i}\rfloor)}}{\prod_{i=1}^n(i+1)^{2f(\lfloor\frac{n}{i}\rfloor)}}
$$
整理一下
$$
(\prod_{i=1}^n{(\frac{i}{i+1}})^{f(\lfloor\frac{n}{i}\rfloor)})^2
$$
对于一个$\Pi$式子，我们也是可以整数分块的。

发现这样前缀积很简单，就可以轻松推出来，整数分块$O(\sqrt{n})$，计算$f(x)$也是$O(\sqrt{n})$，总体应该是$O(n)$吧，但是跑不满（可能是我复杂度计算错了没关系我是粗略计算的$dalao$们随便$D$吧）

### $Update\ 2020.8.29$
感谢$alpha1022$，算法复杂度准确来说是$O(n^\frac{3}{4})$，具体证明方法好像是用积分证明的，原理应该和[这个](https://oi-wiki.org/math/du/)
一样
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long 
int n,p,ans=1;
int ksm(int a,int b,int p){
	int ans=1;
	for(;b;b>>=1,a=a*a%p)
	if(b&1)ans=ans*a%p;
	return ans;
}
int f(int x){
	int ans=0;
	int m=sqrt(x);
	for(int i=1;i<=m;i++)ans+=x/i;
	ans<<=1,ans-=m*m;
	return ans;
}
int L,R;
signed main(){
	cin>>n>>p;
//	for(int i=1;i<=n;i++)
//		ans=ans*ksm(i*ksm(i+1,p-2,p)%p,f(n/i),p)%p;
	for(L=1;L<=n;L=R+1){
		R=n/(n/L);
		ans=ans*ksm(L*ksm(R+1,p-2,p)%p,f(n/L),p)%p;
	}
	ans=ans*ans%p;
	cout<<ans;
}

```
## $BB$
码$Latex$好不容易啊草

码到现在已经$22:56$了，明天还要$6:00$起来上课怎么办啊肝吃不消

~~老妈~~母亲一直在催，可能有一些不详细可以私信问我

自己推出来感觉太好了虽然你谷还不准发题解可我忍不住了

关注！

点赞！

$A$了这道题！
###### 洛谷上不支持一键三连但是可以手动三连↑

---

## 作者：George1123 (赞：11)

去蒟蒻无人问津的博客园看看![/kel](https://cdn.luogu.com.cn/upload/pic/62226.png) $\to$

[$\Huge\it\color{#982443}{George1123}$](https://www.cnblogs.com/George1123/p/13556913.html)

---
## 题面

> [洛谷P6788 「EZEC-3」四月樱花](https://www.luogu.com.cn/problem/P6788)

> 给定 $n,p$，求：
> $$ans=\left(\prod_{x=1}^n\prod_{y|x}\frac{y^{d(y)}}{\prod_{z|y}(z+1)^2}\right)\bmod p$$

> 数据范围：$1\le n\le 2.5\cdot 10^9$，$9.9\cdot 10^8<p<1.1\cdot 10^9$。

---
## 蒟蒻语

一道题撑起一场月赛，良心又劲爆。

膜拜出题人 @[SOSCHINA](https://www.luogu.com.cn/user/73480)，@[muxii](https://www.luogu.com.cn/user/39719muxii)。

---
## 蒟蒻解

开局一波猛操作：

$$y^{d(y)}=\prod_{z|y}y=\prod_{z|y}z\cdot\frac{y}{z}=\prod_{z|y}z^2$$

$$s=\prod_{x=1}^n\prod_{y|x}\frac{y^{d(y)}}{\prod_{z|y}(z+1)^2}=\prod_{x=1}^n\prod_{y|x}\prod_{z|y}\left(\frac{z}{z+1}\right)^2=^{\color{#dd6622}{(1)}}\prod_{z=1}^n\left(\frac{z}{z+1}\right)^{2sumd(\lfloor\frac{n}{z}\rfloor)}$$

$\color{#dd6622}{(1)}$ 的原理就是 $\sum_{z|y,y|n}=d(\frac{n}{z})$，其中 $sumd(n)=\sum_{i=1}^n d(i)$。

---
然后就是要求：

$$\prod_{z=1}^n\left(\frac{z}{z+1}\right)^{2sumd(\lfloor\frac{n}{z}\rfloor)}$$

很明显 $\frac{z}{z+1}$ 的前缀积是可以 $\Theta(\log n)$ 求的，问题是怎么求 $sumd(\lfloor\frac{n}{z}\rfloor)$。

其实是可以分块套分块的，时间复杂度 $\Theta(n^{\frac 34}+\sqrt{n}\log n)$，勉强卡得过去。

但是有两种时间复杂度 $\Theta(n^{\frac 23}+\sqrt{n}\log n)$ 的方法：

**第一种：** 由 @[alpha1022](https://www.luogu.com.cn/user/75840) 巨佬提供，先筛出 $n^{\frac 23}$ 的 $sumd$，然后剩下分块套分块。

**第二种：** 

蒟蒻的做法，看到数据范围和 $\Theta(n^{\frac 23})$ 想到杜教筛。

很明显 $d$ 这个东西不能直接筛，但是有一个炫酷的魔术：杜教套杜教。

首先 $f=d=1*1$，所以可以令 $g=\mu$，$f*g=1*1*\mu=1$，满足 $f*g$ 前缀和可以速速求，问题是要求 $\mu$ 的前缀和。

于是再来一次：$f=\mu$，$g=1$，$f*g=\mu*1=\epsilon$，就是杜教筛模板，随意筛。

至于具体怎么套可以看代码，考虑到这题只需要求 $n$ 及 $n$ 的根号分块的前缀和，所以可以预处理形杜教筛。

---
## 代码

```cpp
//Data
using mint=unsigned int;
mint n,nn,mod,ans=1;
mint m(mint x){(x>=mod)&&(x%=mod);return x;}
mint p(mint x){(x>=mod-1)&&(x%=(mod-1));return x;}
void mm(mint&x){(x>=mod)&&(x%=mod);}
void pm(mint&x){(x>=mod-1)&&(x%=(mod-1));}
mint mt(mint x,mint y){return 1ll*x*y%mod;}
mint pt(mint x,mint y){return 1ll*x*y%(mod-1);}
mint Pow(mint a,mint x){mint res=1;for(;x;a=mt(a,a),x>>=1)if(x&1) res=mt(res,a);return res;}

//Sieve
const mint N=5841399+1;
bitset<N> np;
vector<mint> prime;
mint mc[N],d[N],mu[N];
void Sieve(){
	np[1]=true,mc[1]=0,d[1]=mu[1]=1;
	R(i,2,nn){
		if(!np[i]) prime.pb(i),mc[i]=1,d[i]=2,mu[i]=mod-2;
		for(mint p:prime){
			if(!(i*p<nn)) break; np[i*p]=true;
			if(i%p==0){mc[i*p]=mc[i]+1,d[i*p]=d[i]/(mc[i]+1)*(mc[i*p]+1),mu[i*p]=0;break;}
			d[i*p]=d[i]*d[p],mu[i*p]=pt(mu[i],mu[p]),mc[i*p]=1;
		}
	}
	R(i,2,nn) pm(d[i]+=d[i-1]),pm(mu[i]+=mu[i-1]);
}

//DuSieve
const mint iN=427+1;
mint dud[iN],dumu[iN];
bitset<iN> vis;
mint D(mint i){return i<nn?d[i]:dud[n/i];}
mint Mu(mint i){return i<nn?mu[i]:dumu[n/i];}
void DuSieve(mint i){
	if(i<nn||vis[n/i]) return; vis[n/i]=true;
	for(mint l=1,r;l<=i;l=r+1) r=i/(i/l),DuSieve(i/l),
	pm(dumu[n/i]+=p(mod-1-pt(p(r-l+1),Mu(i/l)))); pm(dumu[n/i]+=1);
	for(mint l=2,r;l<=i;l=r+1) r=i/(i/l),
	pm(dud[n/i]+=p(mod-1-pt(p(mod-1+Mu(r)-Mu(l-1)),D(i/l)))); pm(dud[n/i]+=p(i));
	//必须先筛 mu，筛 d 时会用到 mu(i)
}

//Main
int main(){
	read(n),read(mod),nn=1+pow(n,0.72),Sieve(),DuSieve(n); //事实证明0.72最快，可以卡进1s
	for(mint l=1,r;l<=n;l=r+1) r=n/(n/l),ans=mt(ans,Pow(mt(m(l),Pow(m(r+1),mod-2)),D(n/l)));
	write(mt(ans,ans)),putchar(10);
	return 0;
}
```
---
**祝大家学习愉快！**

---

## 作者：ForgotMe (赞：6)

真-推柿子魔怔题。艹了一天终于过了。

先来看看给出的柿子：

给出一个 $n$。

$$
\prod_{i=1}^n\prod_{j|i}\dfrac{j^{d(j)}}{\prod_{k|j}(k+1)^2}
$$

后面这坨 $\dfrac{j^{d(j)}}{\prod_{k|j}(k+1)^2}$ 很恶心先化个简。

首先你得知道一个结论：

设 $f(x)$ 表示 $x$ 的约数之积，$g(x)$ 表示 $x$ 的约数个数，有：

$$
f(x)=x^{\frac{g(x)}{2}}
$$

两边平方一下，可得：

$$
f(x)^2=x^{g(x)}
$$

带会原柿子可得

$$
\dfrac{j^{d(j)}}{\prod_{k|j}(k+1)^2}=\dfrac{\prod_{k|j}k^2}{\prod_{k|j}(k+1)^2}
$$

然后带回去可得

$$
(\prod_{i=1}^n\prod_{j|i}\prod_{k|j}\dfrac{k}{k+1})^2
$$

考虑枚举这个 $k$，可得

$$
\prod_{k=1}^n(\dfrac{k}{k+1})^{\sum_{i=1}^n\sum_{j|i}\sum_{l|j}[k=l]}
$$

然后把这坨指数提出来处理

$$
\sum_{i=1}^n\sum_{j|i}\sum_{l|j}[k=l]
$$

枚举 $j$，柿子变为

$$
\sum_{i=1}^n\lfloor\dfrac{n}{i}\rfloor\sum_{l|i}[k=l]
$$

发现 $\sum_{l|i}[k=l]$ 就等价于 $[k|i]$。

于是柿子变为：
$$
\sum_{i=1}^n\lfloor\dfrac{n}{i}\rfloor[k|i]
$$

枚举 $k$ 的倍数。

$$
\sum_{i=1}^{\lfloor\frac{n}{k}\rfloor}\lfloor\dfrac{n}{ik}\rfloor
$$

把这个指数带回去，可得：

$$
\prod_{k=1}^n(\dfrac{k}{k+1})^{\sum_{i=1}^{\lfloor\frac{n}{k}\rfloor}\lfloor\frac{n}{ik}\rfloor}
$$

发现这个指数就是

$$
\sum_{i=1}^n\lfloor\dfrac{n}{i}\rfloor
$$

这个是整除分块的板子题，相信有数论基础的人都会做。

于是对 $k$ 整除分块，指数直接整除分块算，现在还有一个问题 $\dfrac{k}{k+1}$ 的连乘怎么解决。

发现

$$
\prod_{k=l}^r\dfrac{k}{k+1}=\dfrac{l}{r+1}
$$

为什么呢？发现 $\dfrac{l}{l+1}\cdot\dfrac{l+1}{l+2}......\cdot\dfrac{r-1}{r}\cdot\dfrac{r}{r+1}$ 中的分子分母会有一大堆会被抵消，最后只剩下 $l$ 与 $\dfrac{1}{r+1}$。

至此，这个题就做完了，~~至于时间复杂度，我也不知道，反正能过~~。不过距大佬分析应该是 $\mathcal{O(n^{\frac{3}{4}}\log n)}$ 的。

当然如果你还想更快，算指数那里可以用单次 $\mathcal{O(n^{\frac{1}{3}}\log n)}$ 的算法。

updata：出题人把 $\mathcal{O(n^{\frac{3}{4}}\log n)}$ 的算法卡掉了，于是你需要去 SPOJ-divcnt1 那里去爬一波板子换上就能过了。


---

## 作者：Aleph1022 (赞：5)

首先有引理：$n^{\sigma_0(n)} = \prod_{d|n} d^2$。  
证明：
$$\begin{aligned}n^{\sigma_0(n)} & = \prod_{d|n} n \\ & = \prod_{d|n} d \cdot \frac nd \\ & = \left(\prod_{d|n} d\right) \left(\prod_{d|n} \frac nd\right) \\ & = \left(\prod\limits_{d|n} d\right)^2 \\ & = \prod\limits_{d|n} d^2\end{aligned}$$

然后这道题就变成了
$$\begin{aligned}s&=\prod\limits_{i=1}^t \prod\limits_{d|i} \frac{\prod_{k|d} k^2}{\prod_{k|d} (k+1)^2} \\&=\prod\limits_{i=1}^t \prod\limits_{d|i} \prod\limits_{k|d} \frac{k^2}{(k+1)^2} \\&=\prod\limits_{k=1}^t \left[\frac{k^2}{(k+1)^2}\right]^{\sum_{d=1}^{\left\lfloor t/k\right\rfloor} \left\lfloor\frac t{dk}\right\rfloor}\end{aligned}$$

不难发现指数的东西可以数论分块计算，数论分块嵌套就得到了一个 $O(n^{3/4})$ 的解法。

实际上，指数上的东西等于
$$\sum\limits_{d=1}^{\left\lfloor\frac tk\right\rfloor} \sigma_0(d)$$

这个东西可以线性筛预处理 $n^{2/3}$ 以内的前缀和，以上的使用数论分块计算即可。  
此处总复杂度为 $O(n^{2/3})$。

另外需要计算 $\prod\limits_{k=l}^r \frac{k^2}{(k+1)^2}$，不过不难发现这个就是 $\frac{l^2}{(r+1)^2}$。

---

## 作者：1saunoya (赞：5)

~~简单题~~

发现 $x^{d_x}= \prod_{d|x} d \times \frac{x}{d} = \prod_{d|x} d^2$ 就非常好做了。


然后这个就变成了 $\prod_{x=1}^{t}\prod_{y|x}\prod_{z|y} \frac{z^2}{(z+1)^2}$

我们就只需要知道 $z$ 的出现次数了。

根据这个柿子的含义，$z$ 是 $y$ 的因数，$y$ 是 $x$ 的因数，也就是要求 **z 的倍数的倍数**小于等于 $t$ 的个数。

既然是倍数，随便搞搞，把 $\prod$ 整到指数上面去。

$\sum_{z|y}\sum_{y|x} [x\leq t]$。

然后发现这个 $y$ 和 $x$ 都是 $z$ 的倍数。

所以这个柿子相当于 $\huge \sum_{1|\frac{y}{z}}\sum_{\frac{y}{z}|\frac{x}{z}}[x \leq t]$。

前面的那部分没啥用，令 $k = \frac{y}{z}$。

$\sum_{k=1}^{\frac{t}{z}} \sum_{k|o} [o \leq \frac{t}{z}]$。

发现这个其实就是 $\sum_{k=1}^{\frac{t}{z}} d_k$。可以直接整除分块算。

然后就变得简单起来了？

答案就会变成

$\huge (\prod_{z=1}^{t} \frac{z}{z+1}^{\sum_{k=1}^{\frac{t}{z}} d_k})^2$


发现 $\frac{t}{z}$ 不会超过 $\sqrt t$ 种取值而且连续一段好多都是相同的，那么就可以直接约分掉了。

这里还有一个小问题，$a^{p-1}=1(\mod p)$ 。

然后就做完了？整除分块模板题？unsigned int 就卡过去了？


```cpp
#pragma GCC optimize("Ofast")
#pragma GCC optimize("unroll-loops")
#pragma GCC target("sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native")

#include<bits/stdc++.h>
using namespace std;
#define rep(i,x,y) for(int i=x;i<=y;i++)

using uint_t=unsigned int;
uint_t n;
int p;

uint_t mul(const uint_t&x,const uint_t&y){return 1ll*x*y%p;}
void _add(uint_t&x,const uint_t&y){(x+=y)>=(p-1)?x-=(p-1):0;}
uint_t _mul(const uint_t&x,const uint_t&y){return 1ll*x*y%(p-1);}
uint_t qpow(uint_t x,uint_t y){
	uint_t result=1;
	while(y){if(y&1)result=mul(result,x);x=mul(x,x);y>>=1;}
	return result;
}
uint_t inv(const uint_t&x){return qpow(x,p-2);}
uint_t qwq(const uint_t&x){if(x>=p)return x%p;return x;}
uint_t _qwq(const uint_t&x){if(x>=p-1)return x%(p-1);return x;}
uint_t pre(const uint_t&x){uint_t answer=0;for(uint_t i=1,j=0;i<=x;i=j+1){j=x/(x/i);_add(answer,_mul(_qwq(x/i),j-i+1));}return (uint_t)answer;}

int main(){
#ifdef LOCAL
	freopen("testdata.txt","r",stdin);
#endif
	ios::sync_with_stdio(false);
	cin.tie(NULL);
	cin>>n>>p;
	uint_t answer=1;
	for(uint_t i=1,j=0;i<=n;i=j+1){
		j=n/(n/i);uint_t tmp=pre(n/i);
		answer=mul(answer,qpow(mul(qwq(i),inv(j+1)),tmp));
	}
	cout<<mul(answer,answer)<<'\n';
	return 0;
}
```

---

## 作者：Warriors_Cat (赞：5)

upd on 2020.8.28：之前的做法已经假了，于是优化了一下。

目前最优解第二，当然自己还有一些奇葩常数优化（

### $Solution:$

首先先证一下引理 1：

$$y^{d(y)}=\prod_{z\mid y}z^2$$

证明：

$$y^{d(y)}=\prod_{z\mid y}y = \prod_{z\mid y}(z \times\dfrac{y}{z})=\prod_{z\mid y}z^2$$

$\mathcal{Q.E.D.}$

---

然后再证一个引理 2：$\sum_{i=1}^n \left\lfloor \dfrac{n}{i}\right\rfloor=\sum_{i=1}^n d(i)$。

证明：

数学归纳法。$n=1$ 时显然成立。当 $n>1$ 时，考虑从 $n-1$ 到 $n$ 多了多少。

很显然当 $i \mid n$ 时，$\left\lfloor \dfrac{n}{i}\right\rfloor-\left\lfloor \dfrac{n-1}{i}\right\rfloor=1$，否则为 $0$。

那么 $n$ 的时候就比 $n-1$ 的时候多了 $d(n)$。

于是 $\sum_{i=1}^n \left\lfloor \dfrac{n}{i}\right\rfloor=\sum_{i=1}^n d(i)$。

或者直接推式子（感谢 @SOSCHINA 补充）：

$$\begin{aligned}\sum_{i=1}^n d(n)&=\sum_{i=1}^n\sum_{j\mid i}1\\&=\sum_{i=1}^n \left\lfloor \dfrac{n}{i}\right\rfloor\end{aligned}$$

$\mathcal{Q.E.D}.$

---

然后将引理 1 这个式子带回原式：

$$s=\prod_{x=1}^t\prod_{y\mid x}\prod_{z\mid y}\dfrac{z^2}{(z+1)^2}$$

推式子常见套路：调换求和/积顺序：

$$\begin{aligned}s&=\prod_{z=1}^t\left[\dfrac{z^2}{(z+1)^2}\right]^{\sum_{z\mid y}^t\sum_{y\mid x}1}\\&=\prod_{z=1}^t\left[\dfrac{z^2}{(z+1)^2}\right]^{\sum_{y=1}^{\left\lfloor \frac{t}{z}\right\rfloor}\sum_{x=1}^{\left\lfloor \frac{t}{yz}\right\rfloor}1}\\&=\prod_{z=1}^t\left[\dfrac{z^2}{(z+1)^2}\right]^{\sum_{y=1}^{\left\lfloor \frac{t}{z}\right\rfloor}\left\lfloor \frac{t}{yz}\right\rfloor}\end{aligned}$$

指数上面就是引理 2，可以线性筛 $t^{\frac{2}{3}}$ 以内的 $d(t)$，求个前缀和直接算即可。大于 $t^{\frac{2}{3}}$ 直接暴力数论分块。

然后由于有个 $\left\lfloor \frac{t}{z}\right\rfloor$ 所以 $z$ 可以数论分块。

于是这题就是一个很常见的数论分块套数论分块，不过优化还是挺巧的。

还有一个小细节，即如何求：

$$\prod_{z=i}^j\dfrac{z^2}{(z+1)^2}$$

直接展开就行了吧：

$$\begin{aligned}\text{原式}&=\dfrac{i^2}{(i+1)^2}\times\dfrac{(i+1)^2}{(i+2)^2}\times...\times\dfrac{j^2}{(j+1)^2}\\&=\dfrac{i^2}{(j+1)^2}\end{aligned}$$

于是这题就没了……

### $Code:$

以下只放核心代码。

```cpp
#define int long long
const int N = 2000000;
int n, mod, pri[N + 10], len, num[N + 10], d[N + 10]; bool vis[N + 10];
inline int fpow(int n, int p){
	n %= mod;
	int ans = 1, base = n;
	while(p){
		if(p & 1) ans = ans * base % mod;
		base = base * base % mod;
		p >>= 1;
	}
	return ans;
}
inline void sieve(){
	d[1] = 1;
	for(int i = 2; i <= N; ++i){
		if(!vis[i]) pri[++len] = i, d[i] = 2, num[i] = 1;
		for(int j = 1; j <= len && i * pri[j] <= N; ++j){
			int k = i * pri[j]; vis[i * pri[j]] = 1;
			if(i % pri[j] == 0){
				num[k] = num[i] + 1;
				d[k] = d[i] / num[k] * (num[k] + 1);
				break;
			}
			num[k] = 1; d[k] = d[i] * d[pri[j]];
		}
	}
	for(int i = 1; i <= N; ++i) d[i] += d[i - 1];
}
inline int cal(int n){
	int ans = 0;
	for(int i = 1, j; i <= n; i = j + 1){
		j = n / (n / i);
		ans += (j - i + 1) * (n / i);
	}
	return ans;
}
inline int sol(int n){
	int ans = 1; sieve();
	for(int i = 1, j; i <= n; i = j + 1){
		j = n / (n / i);
		ans = ans * fpow(i * fpow(j + 1, mod - 2) % mod, n / i <= N ? d[n / i] : cal(n / i)) % mod;
	} 
	return ans * ans % mod;
}
```


---

## 作者：qwaszx (赞：5)

按部就班处理即可，并不需要任何观察

以下的 $n$ 即原题中的 $t$，除法为整除

分子分母分开计算，对分子有

$$
\begin{aligned}
&\prod_{x=1}^n\prod_{y|x}y^{d(y)}\\
=&\prod_{x=1}^n\prod_{y|x}\prod_{z|y}y\\
=&\prod_{z=1}^n\prod_{y=1}^{n/z}y^{n/yz}z^{n/yz}\\
=&\prod_{yz\leq n}y^{n/yz}z^{n/yz}\\
=&\left(\prod_{yz\leq n}z^{n/yz}\right)^2
\end{aligned}
$$

对分母有

$$
\begin{aligned}
&\prod_{x=1}^n\prod_{y|x}\prod_{z|y}(z+1)^2\\
=&\prod_{z=1}^n\prod_{y=1}^{n/z}(z+1)^{2(n/yz)}\\
=&\left(\prod_{yz\leq n}(z+1)^{n/yz}\right)^2
\end{aligned}
$$

从而分子分母具有相似的形式，放在一起继续计算:

$$
\begin{aligned}
&\prod_{yz\leq n}\left(\frac{z}{z+1}\right)^{n/yz}\\
=&\prod_{z=1}^n\left(\frac{z}{z+1}\right)^{\sum_{y=1}^{n/z}n/yz}
\end{aligned}
$$

直接整除分块，底数在连续的一段 $[l,r]$ 上的乘积会被抵消为 $l/(r+1)$，可以快速计算，指数上可以发现就是 $1$ 到 $n$ 的因子个数和，可以预处理 $n^{2/3}$ 的答案剩下的整除分块计算，这部分复杂度

$$
\int_{1}^{n^{1/3}}\sqrt{\frac{n}{i}}\ \mathrm{di}=O(n^{2/3})
$$

使用更快速的因子个数和算法可以做到 $O(n^{3/5}\mathrm{polylog})$，但没有必要

我们甚至可以分别计算出分子分母，利用快速阶乘算法做到 $O(n^{2/3}\mathrm{polylog})$，但同样没有必要.

---

## 作者：Natsuzora (赞：5)

## $O(n^2\sim n^3),$ $10$ $pts$
暴力循环模拟即可。
## $O(n\log n),$ $20$ $pts$
暴力 + 预处理。
- 第一步：改变枚举方式。

对于一个数 $x$，暴力遍历 $1\sim x$ 每个数并判断其是否为 $x$ 的约数的枚举方式将会造成大量不必要的时间浪费，考虑从约数的角度出发进行遍历。  
具体地说，枚举每个数 $i$，然后枚举 $i$ 的倍数 $i*j$ $(j≥1)$，于是 $i$ 为 $i*j$ 的约数。这样枚举的时间复杂度为 $O(n\log\log n)$，具体证明可以参考埃氏筛法的时间复杂度证明。
- 第二步：预处理两个子函数。

观察式子发现我们可以预处理两个函数，分别为
$$f(y)=y^{d(y)}=y^{\sum_{i|y}1}$$
以及
$$g(y)=\prod_{z|y}(z+1)$$
这样可以避免重复计算，降低时间复杂度。
- 第三步：计算答案和代码实现。

实现方式比较多样化。不展开讲。

下面给出一份比较简洁的实现代码。

```cpp
#include <cstdio>
using namespace std;
const int N = 2e6 + 1;

long long n;
int p, d[N], f[N], g[N];

inline int fpow(int base, int t = p - 2){
	int ret = 1;
	while(t){
		if(t & 1) ret = 1ll * ret * base % p;
		base = 1ll * base * base % p;
		t >>= 1;
	}
	return ret;
}

int main(){
	scanf("%lld%d", &n, &p);
	for(int i = 1; i <= n; i++) f[i] = g[i] = 1;
	int up = 1, down = 1;
	for(int i = 1; i <= n; i++){
		for(int j = 1; i * j <= n; j++){
			f[i * j] = 1ll * f[i * j] * (i * j) % p;
			g[i * j] = 1ll * g[i * j] * (i + 1) % p;
		}
		up = 1ll * up * fpow(f[i], n / i) % p;
		down = 1ll * down * fpow(g[i], n / i) % p;
	}
	printf("%lld", 1ll * up * fpow(1ll * down * down % p) % p);
	return 0;
}
```
## $O(n\log n),$ $40$ $pts$
对于会推式子的同学来说，一个比较显然的想法是将分子分母分开计算。下面分别展示两个式子的化简过程。（以下 $d(n)$ 默认使用线性筛预处理）
- 分子
$$f(n)=\prod_{x=1}^n\prod_{y|x}y^{d(y)}$$
交换 $x$ 和 $y$ 的枚举顺序得
$$f(n)=\prod_{y=1}^ny^{\lfloor\frac ny\rfloor d(y)}$$
其中 $d(x)$ 使用线性筛处理，然后再直接计算即可。
- 分母（开方之后的）
$$g(n)=\prod_{x=1}^n\prod_{y|x}\prod_{z|y}(z+1)$$
交换 $y$ 和 $z$ 的枚举顺序
$$g(n)=\prod_{x=1}^n\prod_{z|x}\prod_{z|y,y|x}(z+1)$$
考虑满足 $z|y,y|x$ 的 $y$ 的个数，显然答案为 $d(\frac xz)$。
$$g(n)=\prod_{x=1}^n\prod_{z|x}(z+1)^{d(\frac xz)}$$
再设 $x=x'z$，交换 $x$ 和 $z$ 的枚举顺序
$$g(n)=\prod_{z=1}^n\prod_{x'=1}^{\lfloor\frac nz\rfloor}(z+1)^{d(x')}$$
$$=\prod_{z=1}^n(z+1)^{d(1)+d(2)+...+d(\lfloor\frac nz\rfloor)}$$
可以整除分块，但仍然有 $O(n)$ 计算阶乘的复杂度无法进一步优化。

```cpp
#include <cstdio>
using namespace std;
const int N = 1e8 + 1;

long long n;
int p, d[N], s[N], prime[N], tot;
bool vis[N];

inline int fpow(int base, int t = p - 2){
	int ret = 1;
	while(t){
		if(t & 1) ret = 1ll * ret * base % p;
		base = 1ll * base * base % p;
		t >>= 1; 
	}
	return ret;
}

int main(){
	scanf("%lld%d", &n, &p);
	s[1] = d[1] = 1;
	for(int i = 2; i <= n; i++){
		if(!vis[i]){
			prime[++tot] = i;
			d[i] = 2;
		}
		for(int j = 1; j <= tot && i * prime[j] <= n; j++){
			vis[i * prime[j]] = true;
			if(i % prime[j] == 0){
				d[i * prime[j]] = (2ll * d[i] - d[i / prime[j]]) % (p - 1);
				break;
			}
			d[i * prime[j]] = 2ll * d[i] % (p - 1);
		}
		s[i] = (1ll * d[i] + s[i - 1]) % (p - 1);
	}
	int up = 1, down = 1;
	for(int i = 1; i <= n; i++)
		up = 1ll * up * fpow(i, (n / i) * d[i] % (p - 1)) % p;
	for(int i = 1, j; i <= n; i = j + 1){
		j = n / (n / i);
		int tmp = 1;
		for(int k = i; k <= j; k++)
			tmp = 1ll * tmp * (k + 1) % p;
		down = 1ll * down * fpow(tmp, s[n / i]) % p;
	}
	printf("%lld", 1ll * up * fpow(1ll * down * down % p) % p);
	return 0;
}
```
## $O(n),$ $60$ $pts$
考虑如何整体统一分子分母两个部分。

设
$$f(n)=\prod_{x|n}x=x_1x_2\cdots x_{d(n)}$$
设 $n=x_iy_i$，于是 $f(n)$ 等价于
$$f(n)=\prod_{y|n}y=y_1y_2\cdots y_{d(n)}$$
将两式逐项相乘得
$$f^2(n)=(x_1y_1)(x_2y_2)\cdots (x_{d(n)}y_{d(n)})=n^{d(n)}$$
即
$$n^{d(n)}=\prod_{x|n}x^2$$
代回原式即得
$$s=\prod_{x=1}^n\prod_{y|x}\prod_{z|y}(\frac z{z+1})^2=(\prod_{x=1}^n\prod_{y|x}\prod_{z|y}\frac z{z+1})^2$$
经过一系列化简（具体过程可以参考 $40$ 分解法中的分母部分化简方法）得
$$s=(\prod_{z=1}^{n}(\frac z{z+1})^{S(\lfloor\frac nz\rfloor)})^2$$
其中 $S(n)$ 表示 $d(n)$ 的前缀和。  
整除分块处理上式即可，但线性筛的时间复杂度无法进一步优化。总时间复杂度为 $O(n)$。

```cpp
#include <cstdio>
using namespace std;
const int N = 1e8 + 1;

long long n;
int p, d[N], s[N], prime[N], tot;
bool vis[N];

inline int fpow(int base, int t = p - 2){
	int ret = 1;
	while(t){
		if(t & 1) ret = 1ll * ret * base % p;
		base = 1ll * base * base % p;
		t >>= 1; 
	}
	return ret;
}

int main(){
	scanf("%lld%d", &n, &p);
	s[1] = d[1] = 1;
	for(int i = 2; i <= n; i++){
		if(!vis[i]){
			prime[++tot] = i;
			d[i] = 2;
		}
		for(int j = 1; j <= tot && i * prime[j] <= n; j++){
			vis[i * prime[j]] = true;
			if(i % prime[j] == 0){
				d[i * prime[j]] = (2ll * d[i] - d[i / prime[j]]) % (p - 1);
				break;
			}
			d[i * prime[j]] = 2ll * d[i] % (p - 1);
		}
		s[i] = (1ll * d[i] + s[i - 1]) % (p - 1);
	}
	int ans = 1;
	for(int i = 1, j; i <= n; i = j + 1){
		j = n / (n / i);
		ans = 1ll * ans * fpow(1ll * i * fpow(j + 1) % p, s[n / i]) % p;
	}
	printf("%lld", 1ll * ans * ans % p);
	return 0;
}
```
## $O(n^{\frac 34}),$ $80$ $pts$
由 $60$ 分解法我们得到式子
$$f(n)=\prod_{x=1}^n\prod_{y|x}\prod_{z|y}\frac z{z+1}$$
之前是从右向左化简，我们这次考虑从左向右化简。

交换 $x$ 和 $y$ 的枚举顺序
$$f(n)=\prod_{y=1}^n\prod_{z|y}(\frac z{z+1})^{\lfloor\frac ny\rfloor}$$
再设 $y=y'z$，交换 $y$ 和 $z$ 的枚举顺序得
$$f(n)=\prod_{z=1}^n\prod_{y'=1}^{\lfloor\frac nz\rfloor}(\frac z{z+1})^{\lfloor\frac n{y'z}\rfloor}$$
$$=\prod_{z=1}^n(\frac z{z+1})^{\sum_{y'=1}^{\lfloor\frac nz\rfloor}\lfloor\frac{\lfloor\frac nz\rfloor}{y'}\rfloor}$$
然后套两次整除分块即可，积分证明这样做的时间复杂度为 $O(n^{\frac 34})$。
```cpp
#include <cstdio>
using namespace std;

long long n;
int p, ans;

inline int fpow(int base, int t = p - 2){
	int ret = 1;
	while(t){
		if(t & 1) ret = 1ll * ret * base % p;
		base = 1ll * base * base % p;
		t >>= 1;
	}
	return ret;
}

int main(){
	scanf("%lld%d", &n, &p);
	ans = 1;
	for(long long i = 1, j, x; i <= n; i = j + 1){
		x = n / i, j = n / x;
		int sum = 0;
		for(long long l = 1, r; l <= x; l = r + 1){
			r = x / (x / l);
			sum = (sum + (r - l + 1) % (p - 1) * (x / l)) % (p - 1);
		}
		ans = 1ll * ans * fpow(i * fpow((j + 1) % p) % p, sum) % p;
	}
	printf("%lld", 1ll * ans * ans % p);
	return 0;
}
```
## $O(n^{\frac 23})$ $Sol$ $1,$ $100$ $pts$
回到 $60$ 分做法的那个式子
$$s=(\prod_{z=1}^{n}(\frac z{z+1})^{S(\lfloor\frac nz\rfloor)})^2$$
猜想 $d(n)$ 的前缀和 $S(n)$ 能够使用杜教筛预处理，而事实上也是可行的。

利用
$$d=1*1$$
两边同时卷上 $\mu$ 得
$$d*\mu=1*1*\mu=1*\varepsilon=1$$
于是带入杜教筛的递推式得
$$\mu(1)S(n)=\sum_{i=1}^n1(i)-\sum_{i=2}^n\mu(i)S(\lfloor\frac ni\rfloor)$$
即
$$S(n)=n-\sum_{i=2}^n\mu(i)S(\lfloor\frac ni\rfloor)$$
只需用杜教筛同步筛出 $\mu$ 和 $d$ 的前缀和即可。总时间复杂度为 $O(n^{\frac 23})$。

```cpp
#include <cstdio>
#include <cmath>
#include <unordered_map>
#define getmu(x) ((x) < m ? mu[x] : mpmu[x])
#define getd(x) ((x) < m ? d[x] : mpd[x])
using namespace std;
const long long N = 2.5e9 + 1;
const int M = pow(N, 2.0 / 3);

long long n;
int p, m, prime[M], mu[M], d[M], tot, ans;
bool vis[M];
unordered_map<long long, int> mpmu, mpd;

inline int fpow(int base, int t = p - 2){
	int ret = 1;
	while(t){
		if(t & 1) ret = 1ll * ret * base % p;
		base = 1ll * base * base % p;
		t >>= 1;
	}
	return ret;
}

int main(){
	scanf("%lld%d", &n, &p);
	m = pow(n, 2.0 / 3);
	mu[1] = d[1] = 1;
	for(int i = 2; i < m; i++){
		if(!vis[i]){
			prime[++tot] = i;
			mu[i] = -1, d[i] = 2;
		}
		for(int j = 1; j <= tot && i * prime[j] < m; j++){
			vis[i * prime[j]] = true;
			if(i % prime[j] == 0){
				d[i * prime[j]] = (2ll * d[i] - d[i / prime[j]]) % (p - 1);
				break;
			}
			d[i * prime[j]] = 2ll * d[i] % (p - 1);
			mu[i * prime[j]] = -mu[i];
		}
	}
	for(int i = 2; i < m; i++)
		mu[i] = (1ll * mu[i] + mu[i - 1]) % (p - 1), d[i] = (1ll * d[i] + d[i - 1]) % (p - 1);
	for(long long y = n / m, x; y; y = n / (x + 1)){
		x = n / y;
		int tmp = 1;
		for(long long i = 2, j; i <= x; i = j + 1){
			j = x / (x / i);
			tmp = (tmp - (j - i + 1) * getmu(x / i)) % (p - 1);
		}
		mpmu[x] = tmp, tmp = x % (p - 1);
		for(long long i = 2, j; i <= x; i = j + 1){
			j = x / (x / i);
			tmp = (tmp - (1ll * getmu(j) - getmu(i - 1)) * getd(x / i)) % (p - 1);
		}
		mpd[x] = tmp;
	}
	ans = 1;
	for(long long i = 1, j; i <= n; i = j + 1){
		j = n / (n / i);
		ans = 1ll * ans * fpow(i * fpow((j + 1) % p) % p, (1ll * getd(n / i) + p - 1) % (p - 1)) % p;
	}
	printf("%lld", 1ll * ans * ans % p);
	return 0;
}
```
## $O(n^{\frac 23})$ $Sol$ $2,$ $100$ $pts$
依然是上面那个式子
$$s=(\prod_{z=1}^{n}(\frac z{z+1})^{S(\lfloor\frac nz\rfloor)})^2$$
对于 $S(n)$，我们有
$$S(n)=\sum_{i=1}^nd(n)$$
$$=\sum_{i=1}^n\sum_{j|i}1$$
$$=\sum_{j=1}^n\lfloor\frac nj\rfloor$$
该式使用整除分块可在 $O(\sqrt n)$ 时间内计算。（事实上仔细观察可以发现这个式子在 $80$ 分做法中就出现过）  
如果对于每个 $S(n)$ 都使用该式计算，时间复杂度为 $O(n^\frac34)$，退化为 $80$ 分解法。  
考虑类似于杜教筛的方法，对于 $i<n^\frac23$ 的 $S(i)$，使用线性筛预处理出 $d(i)$ 再计算出前缀和。  
对于 $i≥n^\frac23$ 的 $S(i)$，使用上式处理。  
总复杂度为 $O(n^\frac23)$。
```cpp
#include <cstdio>
#include <cmath>
using namespace std;
const int M = 2e6;

long long n, d[M];
int m, p, ans;

inline int fpow(int base, int t = p - 2){
	int ret = 1;
	while(t){
		if(t & 1) ret = 1ll * ret * base % p;
		base = 1ll * base * base % p;
		t >>= 1;
	}
	return ret;
}

inline long long s(long long n){
	long long ret = 0;
	for(long long i = 1, j; i <= n; i = j + 1){
		j = n / (n / i);
		ret += (j - i + 1) * (n / i);
	}
	return ret;
}

int main(){
	scanf("%lld%d", &n, &p);
	m = pow(n, 2.0 / 3);
	for(int i = 1; i < m; i++){
		for(int j = i; j < m; j += i)
			d[j]++;
		d[i] += d[i - 1];
	}
	ans = 1;
	for(long long i = 1, j; i <= n; i = j + 1){
		j = n / (n / i);
		ans = 1ll * ans * fpow(i % p * fpow((j + 1) % p) % p, (n / i < m ? d[n / i] : s(n / i)) % (p - 1)) % p;
	}
	printf("%lld", 1ll * ans * ans % p);
	return 0;
}
```
## $Bonus$
参考 [DIVCNT1 - Counting Divisors](https://www.luogu.com.cn/problem/SP26073) 可以得到更快的做法。

---

## 作者：whiteqwq (赞：4)

[P6788 「EZEC-3」四月樱花](https://www.luogu.com.cn/problem/P6788)解题报告：

[更好的阅读体验](https://zybuluo.com/xiaoziyao/note/1736791)

这是一道比较套路的推柿子题，代码短，~~可惜我不会做~~

## 题意
求
$$\prod_{x=1}^t\prod_{y\mid x}\frac{y^{d(y)}}{\prod_{z\mid y}(z+1)^2}$$

对一质数$p$取模，其中$d(x)$为$x$的约数个数。

数据范围：$1\leqslant t\leqslant 2.5\cdot 10^9$,$1\leqslant p\leqslant 1.1\cdot 10^9$

## 分析
考场上看到$y^{d(y)}$就想到$\prod_{w\mid y}y$去了，结果死活想不出来用$w\cdot\frac{y}{w}$来替代$y$，最后写了个$O(t\log t)$的暴力丢人/kk。

~~可能是求和做多了，一看到求积就蒙了~~

首先我们有：
$$\prod_{d\mid x} d^2=\prod_{d\mid x}(d\cdot\frac{x}{d})=\prod_{d\mid x}y=y^{d(y)}$$

所以原式可以转换一下：
$$\prod_{x=1}^t\prod_{y\mid x}\frac{y^{d(y)}}{\prod_{z\mid y}(z+1)^2}=\prod_{x=1}^t\prod_{y\mid x}\frac{\prod_{w\mid y} w^2}{\prod_{z\mid y}(z+1)^2}\\=\prod_{x=1}^t\prod_{y\mid x}\prod_{z\mid y}\frac{z^2}{(z+1)^2}\\=(\prod_{x=1}^t\prod_{y\mid x}\prod_{z\mid y}\frac{z}{z+1})^2$$

然后比较套路地枚举$z$，这样式子可以转化为：
$$(\prod_{z=1}^t\prod_{z\mid y}^t\prod_{y\mid x}^t\frac{z}{z+1})^2$$

套路枚举倍数，然后把求积转化为指数上的求和：
$$\prod_{x=1}^t\prod_{y\mid x}\frac{y^{d(y)}}{\prod_{z\mid y}(z+1)^2}=(\prod_{z=1}^t\prod_{y=1}^{\lfloor\frac{t}{z}\rfloor}\prod_{x=1}^{\lfloor\frac{t}{z\cdot y}\rfloor}\frac{z}{z+1})^2\\=(\prod_{z=1}^t(\frac{z}{z+1})^{\sum_{y=1}^{\lfloor\frac{t}{z}\rfloor}\sum_{x=1}^{\lfloor\frac{t}{z\cdot y}\rfloor}1})^2$$

注意一下，这里有一个细节，第二个式子的第三个$\prod$中：$\prod_{x=1}^{\lfloor\frac{t}{z\cdot y}\rfloor}$，之所以上面是$\lfloor\frac{t}{z\cdot y}\rfloor$而不是$\lfloor\frac{t}{y}\rfloor$，是因为这里$y$是枚举$z$的倍数，此时$y$代表的数应该为$z\cdot y$。

展开$\sum$，就会有：
$$\prod_{x=1}^t\prod_{y\mid x}\frac{y^{d(y)}}{\prod_{z\mid y}(z+1)^2}=(\prod_{z=1}^t(\frac{z}{z+1})^{\sum_{y=1}^{\lfloor\frac{t}{z}\rfloor}\lfloor\frac{t}{z\cdot y}\rfloor})^2$$

因为$\lfloor\frac{a}{b\cdot c}\rfloor$，所以上面$\frac{z}{z+1}$的指数可以看做$\sum_{y=1}^{n}\lfloor\frac{n}{y}\rfloor$，其中$n=\lfloor\frac{t}{z}\rfloor$，这样我们的指数就可以整除分块做到根号的复杂度了。

对$\frac{z}{z+1}$求积其实也是一样的，因为它们的指数满足整除分块的性质，所以可以对$t$进行整除分块。

但是还有一个小问题，如何求$\prod_{i=l}^r\frac{i}{i+1}$。我们只需要展开这个求积式，就有
$$\prod_{i=l}^r\frac{i}{i+1}=\frac{l}{l+1}\cdot\frac{l+1}{l+2}\cdots\frac{r}{r+1}$$
我们只需要抵消一下，答案就是$\frac{l}{r+1}$了。

## 代码
```
#include<stdio.h>
#define int long long
int i,j,k,m,n,mod,l,r,ans;
int ksm(int a,int b){
	b%=(mod-1);
	int res=1;
	while(b){
		if(b&1)
			res=res*a%mod;
		a=a*a%mod,b>>=1;
	}
	return res;
}
int calc(int n){
	int l=1,r,res=0;
	while(l<=n){
		r=n/(n/l);
		res+=(r-l+1)*(n/l);
		l=r+1;
	}
	return res;
}
signed main(){
	scanf("%lld%lld",&n,&mod);
	l=1,r=0,ans=1;
	while(l<=n){
		r=n/(n/l);
		ans=(ans*ksm(l*ksm(r+1,mod-2)%mod,calc(n/l))%mod)%mod;
		l=r+1;
	}
	printf("%lld\n",ans*ans%mod);
	return 0;
}
```
## 更新
然而现在出题人卡掉了上述的算法，现在对上面进行加速。

把上面的式子搬下来：
$$\prod_{x=1}^t\prod_{y\mid x}\frac{y^{d(y)}}{\prod_{z\mid y}(z+1)^2}=(\prod_{z=1}^t(\frac{z}{z+1})^{\sum_{y=1}^{\lfloor\frac{t}{z}\rfloor}\lfloor\frac{t}{z\cdot y}\rfloor})^2$$

上面的指数我们还可以化为：$\sum_{y=1}^{\lfloor\frac{t}{x}\rfloor} d(y)$，然后我们可以用一个神奇的科技来处理$d$的前缀和：杜教套杜教！

因为$d=I\cdot I,I\cdot\mu=\epsilon$，所以有$d\cdot\mu=\epsilon$

然后掏出杜教筛的式子·
$$g(1)\cdot S(n)=\sum_{i=1}^n(f\cdot g)(i)-\sum_{i=2}^n g(i)\cdot S(\lfloor\frac{n}{i}\rfloor)$$

带入进去：
$$\mu(1)\cdot Sumd(n)=\sum_{i=1}^n I(i)-\sum_{i=2}^n\mu(i)\cdot Sumd(\lfloor\frac{n}{i}\rfloor)=n-\sum_{i=2}^n\mu(i)\cdot Sumd(\lfloor\frac{n}{i}\rfloor)$$

我们需要对后面的式子进行整除分块，所以我们需要筛出$\mu$的前缀和，这里需要另一个杜教筛（
## 代码
```
#include<stdio.h>
#include<map>
#define int long long
using namespace std;
const int maxn=5000005;
int i,j,k,m,n,mod,ans,cnt;
int a[maxn],p[maxn],d[maxn],r[maxn],mu[maxn],sumd[maxn],summu[maxn];
map<int,int>ansd,ansmu;
int ksm(int a,int b){//快速幂
	b%=(mod-1);//用费马小定理处理一下
	int res=1;
	while(b){
		if(b&1)
			res=res*a%mod;
		a=a*a%mod,b>>=1;
	}
	return res;
}
int getmu(int n){//杜教筛筛出莫比乌斯函数
	if(n<maxn)
		return summu[n];
	if(ansmu.count(n))
		return ansmu[n];
	int l=2,r,res=1;
	while(l<=n){
		r=n/(n/l);
		res-=(r-l+1)*getmu(n/l);
		l=r+1;
	}
	return ansmu[n]=res;
}
int getd(int n){//杜教筛筛出约数函数
	if(n<maxn)
		return sumd[n];
	if(ansd.count(n))
		return ansd[n];
	int l=2,r,res=n;
	while(l<=n){
		r=n/(n/l);
		res-=(getmu(r)-getmu(l-1))*getd(n/l);
		l=r+1;
	}
	return ansd[n]=res;
}
void init(){//线性筛筛出2/3的前缀和
	p[1]=1,d[1]=1,r[1]=1,mu[1]=1;
	for(int i=2;i<maxn;i++){
		if(p[i]==0)
			a[++cnt]=i,d[i]=2,r[i]=1,mu[i]=-1;
		for(int j=1;j<=cnt;j++){
			if(i*a[j]>=maxn)
				break;
			p[i*a[j]]=1;
			if(i%a[j]==0){
				r[i*a[j]]=r[i]+1;
				d[i*a[j]]=d[i]/r[i*a[j]]*(r[i*a[j]]+1);
				mu[i*a[j]]=0;
				break;
			}
			r[i*a[j]]=1;
			d[i*a[j]]=d[i]*2;
			mu[i*a[j]]=-mu[i];
		}
	}
	for(int i=1;i<maxn;i++)
		sumd[i]=sumd[i-1]+d[i],summu[i]=summu[i-1]+mu[i];
}
int getans(int n){//对答案进行整除分块
	int l=1,r=0,res=1;
	while(l<=n){
		r=n/(n/l);
		res=(res*ksm(l*ksm(r+1,mod-2)%mod,getd(n/l))%mod)%mod;
		l=r+1;
	}
	return res;
}
signed main(){
	scanf("%lld%lld",&n,&mod);
	init();
	ans=getans(n);
	printf("%lld\n",ans*ans%mod);
	return 0;
}
```

---

## 作者：FxorG (赞：1)

## $\text{Solution}$

简单题就敢于乱搞。

$$ans=\prod_{x=1}^{t}\prod_{y|x}\dfrac{y^{d(y)}}{\prod_{z|y}(z+1)^2}$$

$$\prod_{x=1}^{t}\prod_{y|x}y^{d(y)}\prod_{z|y}\dfrac{1}{(z+1)^2}$$

单独处理

$$y^{d(y)}$$

$$d(n)=\sum_{d|n}1$$

$$y^{\sum_{d|y}1}$$

$$\prod_{d|y}y$$

我们发现 $d$ 实际上就是原式的 $z$，回代。

$$\prod_{x=1}^{t}\prod_{y|x}\prod_{z|y}\dfrac{y}{(z+1)^2}$$

有 $z|y$，考虑 $\prod_{z|y}y$ 能否转化为 z 的形式，就要敢于乱代。

有个东西可以有点启发

$$ \prod_{d|n}d=\prod_{d|n}\dfrac{n}{d}$$

考虑构造

$$\prod_{z|y}z\prod_{z|y}z'=\prod_{z|y}y$$

有 $z'=\dfrac{y}{z}$

$$\prod_{z|y}z\prod_{z|y}\dfrac{y}{z}=(\prod_{z|y}z)^2=\prod_{z|y}y$$

$$\prod_{x=1}^{t}\prod_{y|x}\prod_{z|y}\dfrac{z^2}{(z+1)^2}$$

枚举 $y$

$$\prod_{y=1}^{t}\prod_{y|x}\prod_{z|y}\dfrac{z^2}{(z+1)^2}$$

有

$$ x \in [1,t],y|x$$

$$(\prod_{y=1}^t\prod_{z|y}\dfrac{z^2}{(z+1)^2})^{\lfloor\frac{t}{y}\rfloor}$$

~~其实我一直觉得打下取整符号挺烦的 所以我不打了~~

枚举 $z$

$$(\prod_{z=1}^{t}\prod_{z|y}\dfrac{z^2}{(z+1)^2})^{\frac{t}{y}}$$

$$((\prod_{z=1}^{t}\dfrac{z^2}{(z+1)^2})^{\frac{t}{yz}})^{\sum_{y=1}^{\frac{t}{z}}1}$$

$$(\prod_{z=1}^{t}\dfrac{z^2}{(z+1)^2})^{\sum_{y=1}^{\frac{t}{z}}\frac{t}{yz}}$$

指数很整除分块

记

$$h(n)=\sum_{i=1}^{n}\dfrac{n}{i}$$

指数就是

$$h(\dfrac{t}{z})$$

$$\prod_{z=l}^{r}\dfrac{z^2}{(z+1)^2}=\dfrac{l}{(r+1)^2}$$

再套个快速幂即可。

然而我以为能过的时候，却 TLE 了。

我们发现瓶颈是在 $h(\dfrac{t}{z})$。

$$h(n)=\sum_{i=1}^{n}\dfrac{n}{i}=\sum_{i=1}^{n}\sum_{j=1}^{n}[j|i]=\sum_{i=1}^{n}\sigma(i)$$

我们要快速求出 $\sigma(i)$。

预处理大法好！我们可以预处理
  $\sigma(i),i\in[1,n^{\frac{2}{3}}]$ 的前缀和，对于剩下的整除分块。
  
暴力枚举是 $O(n' \ln n'),n'=n^{\frac{2}{3}}$，足已通过本题，但是有个东西叫做狄利克雷前缀和，可以做到 $O(n \log^2 n)$ ，其中 $n$ 是$[1,n']$ 的质数数量。

目前是最优解。

这道题就被我们解决了！

## $\text{Code}$

```cpp
#include <cstdio>
#include <algorithm>
#include <iostream>
#include <cstring>
#include <vector>
#include <cmath>
#include <queue>
#include <map>

#define ll long long
#define uint unsigned int

using namespace std;
int rd() {
	int f=1,sum=0; char ch=getchar();
	while(!isdigit(ch)) {if(ch=='-') f=-1;ch=getchar();}
	while(isdigit(ch)) {sum=(sum<<3)+(sum<<1)+ch-'0';ch=getchar();}
	return sum*f;
}
uint urd() {
	uint sum=0; char ch=getchar();
	while(!isdigit(ch)) {ch=getchar();}
	while(isdigit(ch)) {sum=(sum<<3)+(sum<<1)+ch-'0';ch=getchar();}
	return sum;
}
ll lrd() {
	ll f=1,sum=0; char ch=getchar();
	while(!isdigit(ch)) {if(ch=='-') f=-1;ch=getchar();}
	while(isdigit(ch)) {sum=(sum<<3)+(sum<<1)+ch-'0';ch=getchar();}
	return sum*f;
}
void pr(uint x) {
	if(x<0) {putchar('-');x=-x;}
	if(x>9) pr(x/10);
	putchar(x%10+'0');
}

uint fpow(uint x,uint y,uint mod) {
	uint res=1; x%=mod;
//	cout<<x<<" "<<y<<endl;
	while(y) {
		if(y&1) res=1llu*res*x%mod;
		x=1llu*x*x%mod; y>>=1;
	}
//	cout<<res<<endl;
	return res;
}

#define N (int)(5e5+5)

bool vis[N];
int pri[N>>1],a[N],tot;
void init() {
	for(int i=2;i<N;i++) {
		if(!vis[i]) pri[++tot]=i;
		for(int j=1;j<=tot&&i*pri[j]<N;j++) {
			vis[i*pri[j]]=1;
			if(i%pri[j]==0) break;
		}
	}
	for(int i=1;i<N;i++) a[i]=1;
	for(int i=1;i<=tot;i++)
		for(int j=1;j*pri[i]<N;j++)
			a[j*pri[i]]+=a[j];
	for(int i=1;i<N;i++) a[i]+=a[i-1];
}

uint H(uint n,uint mod) {
	if(n<N) return a[n];
	uint ans=0;
	for(uint l=1,r;l<=n;l=r+1) {
		r=n/(n/l);
		ans+=(r-l+1)*(n/l);
		ans%=mod;
	}
	return ans;
}

int main() {
	init();
	uint n=urd(),mod=urd();
	uint ans=1;
	for(uint l=1,r;l<=n;l=r+1) {
		r=n/(n/l);
		ans=(1llu*ans*fpow(1llu*l*l%mod*fpow(1llu*(r+1)*(r+1)%mod,mod-2,mod)%mod,H(n/l,mod-1)%mod,mod))%mod;
	}
	pr(ans);
	return 0;
}
```

---

## 作者：Prean (赞：0)

> 太慢了！太慢了！我的替身 **【The World】** 是最强的替身！

$ O(n^{\frac 2 3}) $ 的解法！不清楚用 sbt 能不能更快一些，可能会吧。灵感来源于[BZOJ4176](https://darkbzoj.tk/problem/4176)，同时也可看到我也是 BZOJ4176 的最优解。~~理所当然地，我也是 P6788 的最优解~~

首先看着这个柿子：
$$ \prod_{i=1}^n\prod_{d|i}\frac {d^{\sigma_0(d)}} {\prod_{k|d} (k+1)^2} $$
考虑将 $ d^{\sigma_0(d)} $ 展开：
$$ \prod_{i=1}^n\prod_{d|i}\frac {\prod_{k|d}d} {\prod_{k|d}(k+1)^2} $$
设 $ kx=d $

$$ \prod_{i=1}^n\prod_{d|i}\prod_{k|d}\frac {kx} {(k+1)^2} $$
容易发现 $ \prod_{k|d}k \times (\frac d k)=\prod_{k|d} k \times \prod_{k|d}k=(\prod_{k|d}k)^2 $
所以：
$$ (\prod_{i=1}^n\prod_{d|i}\prod_{k|d}\frac k {k+1})^2 $$
$$ (\prod_{k=1}^n(\frac k {k+1})^{\prod_{i=1}^{\lfloor \frac n k \rfloor}\lfloor \frac n {ki} \rfloor})^2 $$
大多数同学是使用整除分块暴力计算 $ \sum_{i=1}^n \lfloor \frac n i \rfloor $ 而达到 $ O(n^{\frac 3 4}) $ 的复杂度，但是这玩意儿其实有性质。

$$ \sum_{i=1}^n\sigma_0(i) = \sum_{i=1}^n \sum_{d|i}1 = \sum_{d=1}^n \lfloor \frac n d \rfloor $$
所以这玩意儿相当于求 $ \sigma_0 $ 的块筛。求块筛的常见做法是使用杜教筛或挖掘性质，这里考虑杜教筛。

因为 $ \sigma_0 = 1 * 1 $，所以考虑配对一个 $ \mu $ 上去，使其变为 $ 1 $。

只需要同时筛 $ mu $ 和 $ \sigma_0 $ 即可。

没有必要对 $ n^{\frac 2 3} $ 以下的 $ \sigma_0 $ 使用整除分块计算前缀和，因为在筛 $ \mu $ 的同时把 $ \sigma_0 $ 也筛了，这样反而会增加常数。同样也没有必要使用 sbt。

upd:我麻烦了，不需要使用杜教筛，小部分线性筛大部分整除分块即可。其他的好像都没这个快。
```cpp
#include<cstdio>
#include<cmath>
typedef unsigned ui;
typedef unsigned long long ull;
const int M=2e6;
ui n,mod,lim,top,pri[149000],idx[M+5],d[M+5];
double inv[200005];
inline ui Pow(ui a,ui b=mod-2){
	ui ans(1);
	for(;b;b>>=1,a=1ull*a*a%mod)if(b&1)ans=1ull*ans*a%mod;
	return ans;
}
inline void sieve(const ui&M){
	register ui i,j,x;d[1]=1;
	for(i=2;i<=M;++i){
		if(!d[i])pri[++top]=i,d[i]=2,idx[i]=1;
		for(j=1;j<=top&&(x=i*pri[j])<=M;++j){
			if(!(i%pri[j])){
				idx[x]=idx[i]+1;d[x]=((ui)(d[i]*inv[idx[x]]))*(idx[x]+1);break;
			}
			idx[x]=1;d[x]=d[i]*2;
		}
	}
	for(i=1;i<=M;++i)d[i]+=d[i-1];
}
inline ui GetSd(const ui&n){
	if(n<=lim)return d[n];
	ull ans(0);ui i;
	for(i=1;i*i<=n;++i)ans+=n*inv[i];
	return ((ans<<1)-(i-1)*(i-1))%(mod-1);
}
signed main(){
	register ui i,x,L,R,ans=1;
	scanf("%u%u",&n,&mod);
	for(i=1;(i-1)*(i-1)<=n;++i)inv[i]=1./i+1e-15;sieve(lim=ceil(pow(n,2./3)));
	for(L=1;L*L<=n;++L)ans=1ull*ans*Pow(1ull*L*Pow(L+1)%mod,GetSd(n*inv[L]))%mod;
	for(x=n*inv[L];L<=n;L=R+1){
		if(x*L>n)--x;R=n*inv[x];
		ans=1ull*ans*Pow(1ull*L*Pow(R+1)%mod,GetSd(x))%mod;
	}
	printf("%u",1ull*ans*ans%mod);
}
```

---


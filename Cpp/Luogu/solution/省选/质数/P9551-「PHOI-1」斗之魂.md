# 「PHOI-1」斗之魂

## 题目背景

**本题数据已加强。**

小 X 忙了一天，于是打起了一款叫斗之魂的游戏。

![](https://cdn.luogu.com.cn/upload/image_hosting/5ha5fx0q.png)

## 题目描述

小 X 要击败 $n$ 个 BOSS，他可以选择以下两种击败 BOSS 的方式：

1. 独自一人击败第 $i$ 个 BOSS 并获得 $k_{i,0}$ 块稀有金属，且保证 $k_{i,0}=k_{i,1}=k_{i,2}$。
2. 和小 Y 一起击败第 $i$ 个 BOSS ，小 X 理应获得 $k_{i,1}$ 块稀有金属，小 Y 理应获得 $k_{i,2}$ 块稀有金属，但是 BOSS 本身实力并没有因为人数的改变而改变，击败难度相对要简单一点，所以系统判定两人实际各获得 $k_{i,0}$ 块稀有金属，其中保证 $\dfrac{1}{k_{i,0}}=\dfrac{1}{k_{i,1}}+\dfrac{1}{k_{i,2}}$。

小 X 已经计划好用第 $b_i$ 种方式击败第 $i$ 个 BOSS，但是考虑到某些因素，小 X 有 $q$ 次询问，每次询问给定一个正整数 $m$，为小 X 击败完所有 BOSS 后获得的稀有金属总数，已知 $k_{i,0},k_{i,1},k_{i,2}$ 均为正整数，求每次询问后所有可能的 $k$ 的值的方案数，两种方案不同当且仅当至少存在一个 $k$ 的值不同，由于这个答案可能很大，你只需要输出它对 $998244353$ 取模后的结果。

## 说明/提示

**本题采用捆绑测试。**

| Subtask |      $n\le$       |      $m \le$      | $q \le$ |  时限  | 分值 |
| :-----: | :---------------: | :---------------: | :-----: | :----: | :--: |
|   $0$   |       $10$        |       $20$        |   $5$   |  $1s$  | $8$  |
|   $1$   |       $30$        |       $60$        |   $5$   |  $1s$  | $7$  |
|   $2$   |       $40$        |       $100$       | $10^3$  |  $1s$  | $5$  |
|   $3$   |       $150$       |       $500$       | $10^3$  |  $1s$  | $5$  |
|   $4$   |       $200$       |      $5000$       | $10^4$  |  $1s$  | $20$ |
|   $5$   |      $2000$       |  $5 \times 10^4$  | $10^5$  |  $1s$  | $25$ |
|   $6$   | $1.5 \times 10^5$ | $2.5 \times 10^5$ | $10^5$  | $1.8s$ | $30$ |

对于 $100\%$ 的数据，保证 $1 \le n \le 1.5 \times 10^5$，$1 \le m \le 2.5 \times 10^5$，$1 \le b_i \le 2$，$1 \le q \le 10^5$。

### 样例解释 #1：

- 当 $m=3$ 时，所有可能的 $k$ 的值的方案数为 $4$。

    第 $1$ 种：$k_{1,0}=1,k_{1,1}=k_{1,2}=2,k_{2,0}=k_{2,1}=k_{2,2}=2$

    第 $2$ 种：$k_{1,0}=2,k_{1,1}=3,k_{1,2}=6,k_{2,0}=k_{2,1}=k_{2,2}=1$

    第 $3$ 种：$k_{1,0}=2,k_{1,1}=k_{1,2}=4,k_{2,0}=k_{2,1}=k_{2,2}=1$

    第 $4$ 种：$k_{1,0}=2,k_{1,1}=6,k_{1,2}=3,k_{2,0}=k_{2,1}=k_{2,2}=1$

- 当 $m=4$ 时，所有可能的 $k$ 的值的方案数为 $7$。

    第 $1$ 种：$k_{1,0}=1,k_{1,1}=k_{1,2}=2,k_{2,0}=k_{2,1}=k_{2,2}=3$

    第 $2$ 种：$k_{1,0}=2,k_{1,1}=3,k_{1,2}=6,k_{2,0}=k_{2,1}=k_{2,2}=2$

    第 $3$ 种：$k_{1,0}=2,k_{1,1}=k_{1,2}=4,k_{2,0}=k_{2,1}=k_{2,2}=2$

    第 $4$ 种：$k_{1,0}=2,k_{1,1}=6,k_{1,2}=3,k_{2,0}=k_{2,1}=k_{2,2}=2$

    第 $5$ 种：$k_{1,0}=3,k_{1,1}=4,k_{1,2}=12,k_{2,0}=k_{2,1}=k_{2,2}=1$

    第 $6$ 种：$k_{1,0}=3,k_{1,1}=6,k_{1,2}=6,k_{2,0}=k_{2,1}=k_{2,2}=1$

    第 $7$ 种：$k_{1,0}=3,k_{1,1}=12,k_{1,2}=4,k_{2,0}=k_{2,1}=k_{2,2}=1$

## 样例 #1

### 输入

```
2 2
2 1
3
4
```

### 输出

```
4
7
```

## 样例 #2

### 输入

```
5 5
1 2 1 2 1
4
6
8
10
12
```

### 输出

```
0
9
119
630
2210```

# 题解

## 作者：yydfj (赞：11)

这是本蒟蒻第三十三次写的题解，如有错误点请好心指出！

显然如果小 X 用第 $1$ 种方式击败第 $i$ 个 BOSS，当 $k_{i,0}$ 确定时，$k_{i,1}$ 和 $k_{i,2}$ 也是确定的，考虑小 X 用第 $2$ 种方式击败第 $i$ 个 BOSS 的情况，先对 $\dfrac{1}{k_{i,0}}=\dfrac{1}{k_{i,1}}+\dfrac{1}{k_{i,2}}$ 中右边式子进行通分，则

$$
\dfrac{1}{k_{i,0}}=\dfrac{k_{i,1}+k_{i,2}}{k_{i,1}k_{i,2}}
$$

去分母得：

$$
\begin{aligned}
k_{1,0}(k_{i,1}+k_{i,2})&=k_{i,1}k_{i,2}\\
0&=-k_{1,0}(k_{i,1}+k_{i,2})+k_{i,1}k_{i,2}
\end{aligned}
$$

两边各加上一个 $k_{1,0}^2$ 得：

$$
k_{i,0}^2=k_{i,0}^2-k_{1,0}(k_{i,1}+k_{i,2})+k_{i,1}k_{i,2}
$$

发现右边式子是个完全平方公式，因式分解得：

$$
k_{i,0}^2=(k_{i,0}-k_{i,1})(k_{i,0}-k_{i,2})
$$

因为 $k_{i,0},k_{i,1},k_{i,2}$ 均为正整数且 $k_{i,1},k_{i,2}$ 一定大于 $k_{i,0}$，所以当 $k_{i,0}$ 确定时，$k_{i,1}$ 和 $k_{i,2}$ 的方案数为 $k_{i,0}^2$ 的因子个数。

将 $k_{i,0}$ 质因数分解成 $p_1^{\alpha_1} \times p_2^{\alpha_2} \times p_3^{\alpha_3} \cdots p_x^{\alpha_x}$，则 $k_{i,0}^2$ 的因子个数为 $(2\alpha_1+1) \times (2\alpha_2+1) \times (2\alpha_3+1)\cdots(2\alpha_x+1)$，用线性筛 $O(m)$ 维护最小质因子次数并求出。

预处理好因子个数之后，就可以用 dp 求方案数了。设 $f_{i,j}$ 为当前击败第 $i$ 个 BOSS，获得的总稀有金属个数为 $j$ 的方案数，最终答案为 $f_{n,m}$，则当 $b_i=1$ 时，转移方程为

$$
f_{i,j}=\sum_{k=1}^{j-1}f_{i-1,k}
$$

当 $b_i=2$ 时，转移方程为

$$
f_{i,j}=\sum_{k=1}^{j-1}f_{i-1,k} \times a_{(j-k)^2}
$$

其中 $a_{(j-k)^2}$ 为 $(j-k)^2$ 的因子个数。

发现转移方程均与击败 BOSS 的顺序无关，我们可以先全部处理第 $1$ 种转移方程，再全部处理第 $2$ 种转移方程，其中第 $1$ 种转移方程可以用组合数学计算，我们直接考虑第 $2$ 种转移方程，记 $g_i=a_{i^2}$，则转移方程为

$$
f_{i,j}=\sum_{k=1}^{j-1}f_{i-1,k} \times g_{j-k}
$$

设状态函数 $F_t(x)$，转移函数 $G(x)$，答案函数 $A(x)$，使

$$
F_t(x)=\sum_{i=0}^\infty f_{t,i}x^i
$$

$$
G(x)=\sum_{i=1}^{j-1}g_{i}x^i
$$

$$
A(x)=\sum_{i=0}^\infty \sum_{j=0}^k f_{t,i} g_{j} x^i
$$

其中 $F_0(x)=1$，则

$$
\begin{aligned}
F_t(x)&=F_{t-1}(x)G(x)\\
&=G^t(x)
\end{aligned}
$$
然后答案函数为

$$
\begin{aligned}

A(x)&=F_t(x)\\

&=G^t(x)\\

&=\exp(t \ln G(x))

\end{aligned}
$$


用多项式快速幂即可做到时间复杂度为 $O(m \log m+q)$。

```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
using namespace std;
typedef long long ll;
const ll mod=998244353,gg=3,ggi=(mod+1)/3;
ll yz[250005]={0,1},zs[250005],tot[250005],cnt;
int inv[600005]={0,1},jc[600005]={1},ni[600005];
int n,q,mx,m[100005],bl[600005],F[600005],G[600005],G1[600005],G2[600005],b1[600005],c1[600005],d1[600005],e1[600005],lim,ss,cnt1,cnt2;
bool bz[250005];
inline ll read()
{
    ll x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}
    return x*f;
}
inline void ycl()
{
    for(int i=2;i<=mx;i++)
    {
        if(!bz[i])
        {
            zs[++cnt]=i;
            tot[i]=1;
            yz[i]=3;
        }
        for(int j=1;j<=cnt;j++)
        {
            if(i*zs[j]>mx) break;
            bz[i*zs[j]]=1;
            if(i%zs[j]==0)
            {
                tot[i*zs[j]]=tot[i]+1;
                yz[i*zs[j]]=yz[i]/(2*tot[i]+1)*(2*tot[i]+3);
                break;
            }
            tot[i*zs[j]]=1;
            yz[i*zs[j]]=yz[i]*3;
        }
    }
}
inline int ksm(int x,int y)
{
    int res=1;
    while(y)
    {
        if(y&1) res=(ll)res*x%mod;
        x=(ll)x*x%mod;
        y>>=1;
    }
    return res;
}
void NTT(int *A,int type)
{
    for(int i=0;i<lim;i++)
    if(i<bl[i]) swap(A[i],A[bl[i]]);
    for(int i=2;i<=lim;i<<=1)
    {
        int mid=i>>1;
        ll gn=ksm(type==1?gg:ggi,(mod-1)/i);
        for(int j=0;j<lim;j+=i)
        {
            ll mi=1;
            for(int k=j;k<j+mid;k++,mi=mi*gn%mod)
            {
                ll ax=A[k],ay=(ll)mi*A[k+mid]%mod;
                A[k]=(ax+ay)%mod;
                A[k+mid]=(ax-ay+mod)%mod;
            }
        }
    }
    if(type==0)
    {
        ll inv=ksm(lim,mod-2);
        for(int i=0;i<lim;i++) A[i]=(ll)A[i]*inv%mod;
    }
}
void init(int len)
{
    lim=1,ss=0;
    while(lim<=len) lim<<=1,ss++;
    for(int i=0;i<lim;i++) bl[i]=(bl[i>>1]>>1)|((i&1)<<(ss-1));
}
void getinv(int *A,int *B,int len)
{
    if(len==1)
    {
        B[0]=ksm(A[0],mod-2);
        return;
    }
    getinv(A,B,(len+1)>>1);
    init(len<<1);
    for(int i=0;i<len;i++) d1[i]=A[i];
    NTT(B,1);NTT(d1,1);
    for(int i=0;i<lim;i++) B[i]=(ll)B[i]*(2-(ll)B[i]*d1[i]%mod+mod)%mod;
    NTT(B,0);
    for(int i=0;i<len;i++) d1[i]=0;
    for(int i=len;i<lim;i++) B[i]=d1[i]=0;
}
void ln(int *A,int *B,int len)
{
    for(int i=1;i<len;i++) b1[i-1]=(ll)A[i]*i%mod;
    b1[len]=0;
    getinv(A,c1,len);
    init(len<<1);
    NTT(b1,1);NTT(c1,1);
    for(int i=0;i<lim;i++) b1[i]=(ll)b1[i]*c1[i]%mod;
    NTT(b1,0);
    for(int i=1;i<len;i++) B[i]=(ll)b1[i-1]*inv[i]%mod;
    B[0]=0;
    for(int i=0;i<lim;i++) b1[i]=c1[i]=0;
}
void exp(int *A,int *B,int len)
{
    if(len==1)
    {
        B[0]=1;
        return;
    }
    exp(A,B,(len+1)>>1);
    ln(B,e1,len);
    e1[0]=(A[0]+1-e1[0]+mod)%mod;
    for(int i=1;i<len;i++) e1[i]=(A[i]-e1[i]+mod)%mod;
    init(len<<1);
    NTT(B,1);NTT(e1,1);
    for(int i=0;i<lim;i++) B[i]=(ll)B[i]*e1[i]%mod;
    NTT(B,0);
    for(int i=len;i<lim;i++) B[i]=e1[i]=0;
}
int main()
{
    n=read();q=read();
    for(int i=1;i<=n;i++)
    {
        ll x=read();
        if(x==1) cnt1++;
        else cnt2++;
    }
    for(int i=1;i<=q;i++) m[i]=read(),mx=max(mx,m[i]);
    ycl();
    for(int i=2;i<=600000;i++) inv[i]=(ll)(mod-mod/i)*inv[mod%i]%mod;
    for(int i=1;i<=n+mx;i++) jc[i]=(ll)jc[i-1]*i%mod;
    ni[n+mx]=ksm(jc[n+mx],mod-2);
    for(int i=n+mx-1;i>=0;i--) ni[i]=(ll)ni[i+1]*(i+1)%mod;
    if(!cnt1) F[0]=1;
    else
    {
        for(int i=0;i<=mx;i++) F[i]=(ll)jc[i+cnt1-1]*ni[i]%mod*ni[cnt1-1]%mod;
        F[mx]=(F[mx]-1+mod)%mod;
    }
    if(!cnt2) G2[0]=1;
    else
    {
        for(int i=0;i<mx;i++) G[i]=yz[i+1];
        ln(G,G1,mx+1);
        for(int i=0;i<=mx;i++) G1[i]=(ll)G1[i]*cnt2%mod;
        for(int i=mx+1;i<lim;i++) G1[i]=0;
        exp(G1,G2,mx+1);
    }
    init((mx+1)<<1);
    NTT(F,1);NTT(G2,1);
    for(int i=0;i<lim;i++) F[i]=(ll)F[i]*G2[i]%mod;
    NTT(F,0);
    for(int i=1;i<=q;i++)
    {
        if(m[i]<n) printf("0\n");
        else printf("%d\n",F[m[i]-n]);
    }
    return 0;
}
```

---

## 作者：Fzrcy (赞：2)

先考虑在两种击败 BOSS 的方式下，$k_{i,0}$ 已知时 $k_{i,1},k_{i,2}$ 的取值的方案数：

- 对于第一种方式，显然 $k_{i,1}=k_{i,2}=k_{i,0}$，方案数只有一种。
- 对于第二种方式，显然 $\frac{1}{k_{i,0}}=\frac{k_{i,1}+k_{i,2}}{k_{i,1}k_{i,2}}$。

有：
$$
k_{i,0}(k_{i,1}+k_{i,2})=k_{i,1}k_{i,2}
$$

$$
k_{i,0}^2=k_{i,1}k_{i,2}-k_{i,0}(k_{i,1}+k_{i,2})+k_{i,0}^2=(k_{i,0}-k_{i,1})(k_{i,0}-k_{i,2})
$$

所以 $(k_{i,0}-k_{i,1})|k_{i,0}^2$，$(k_{i,0}-k_{i,2})|k_{i,0}^2$，当 $k_{i,0}-k_{i,1}$ 确定时，$k_{i,2}$ 也确定了，所以 $(k_{i,1},k_{i,2})$ 的方案数为 $k_{i,0}^2$ 的因子数 $d(k_{i,0}^2)$，这个可以用筛法加上质因数分解求解，复杂度似乎是 $O(V\log\log V)$。

由于击败 BOSS 的方式只有两种，并且转移方程只和使用哪种方式击败 BOSS 有关，所以我们考虑生成函数，设 $A$ 为用第一种方式击败的 BOSS 的个数，$B$ 为用第二种方式击败的 BOSS 的个数，生成函数 $F(x)=\sum_{i=1}^{\infty}x^i$、$G(x)=\sum_{i=1}^{\infty}d(i^2)x^i$。

则答案为：
$$
[x^m]F^{A}(x)G^{B}(x)
$$
$F^{A}(x)$ 可以直接用组合意义计算，对于 $G^{B}(x)$ 直接快速幂即可。

有一个细节：由于$[x^0]G$ 为 $0$、$[x^1]G$ 为 $1$，所以我们要将多项式 $G$ 除以一个 $x$，再做多项式快速幂，最后乘上 $x^{B}$ 即可。

复杂度 $O(n\log n)$。

```cpp
// Fzrcy
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
constexpr int N=6.1e5+9;
constexpr int mod=998244353;
inline int suf(int x,int y){return (x+y)>mod?x+y-mod:x+y;}
inline int sub(int x,int y){return (x-y)<  0?x-y+mod:x-y;}
inline int pmo(int x){return x>=mod?x-mod:x;}
inline int ksm(int x,int y=mod-2){
    int ret=1;y<0&&(y+=mod-1);
    for(;y;y>>=1,x=(LL)x*x%mod)
        if(y&1)ret=(LL)ret*x%mod;
    return ret;
}
int REV[N];
inline void DFT(int*a,int len,int op){
    for(int i=1;i<len;i++)if(REV[i]>i)swap(a[REV[i]],a[i]);
    for(int d=1;d<len;d<<=1)for(int i=0,w=ksm(ksm(3,(mod-1)/(d<<1)),op);i<len;i+=d<<1)
        for(int j=0,a0,a1,W=1;j<d;j++,W=(LL)W*w%mod)
            a0=a[i+j],a1=(LL)a[i+j+d]*W%mod,a[i+j]=suf(a0,a1),a[i+j+d]=sub(a0,a1);
    if(op==-1){for(int i=0,x=ksm(len);i<len;i++)a[i]=(LL)a[i]*x%mod;}
}
inline int init(int n){
    int len=1;while(len<n)len<<=1;
    for(int i=1;i<len;i++)REV[i]=(REV[i>>1]>>1)+(i&1?len>>1:0);
    return len;
}
int NF[N<<1],NG[N<<1];
inline void mul(int*a,int*b,int A,int B,int*c,int C){
    int len=init(A+B);
    memcpy(NF,a,A<<2),memset(NF+A,0,(len-A)<<2);
    memcpy(NG,b,B<<2),memset(NG+B,0,(len-B)<<2);
    DFT(NF,len,1),DFT(NG,len,1);
    for(int i=0;i<len;i++)NF[i]=(LL)NF[i]*NG[i]%mod;
    DFT(NF,len,-1);memcpy(c,NF,C<<2);
}
int Tmp1[N];
inline void PolyInv(int*a,int n,int*b){
    if(n==1){b[0]=ksm(a[0]);return;}
    int m=(n+1)>>1;  PolyInv(a,m,b);
    mul(a,b,n,m,Tmp1,n),Tmp1[0]=sub(Tmp1[0],2);
    for(int i=0;i<n;i++)  Tmp1[i]=sub(0,Tmp1[i]);
    return mul(b,Tmp1,m,n,b,n);
}
int Tmp2[N],ninv[N];
inline void dao(int*a,int n){for(int i=0;i<n-1;i++)a[i]=(LL)a[i+1]*(i+1)%mod;a[n-1]=0;}
inline void jifen(int*a,int n){for(int i=n-1;i;i--)a[i]=(LL)a[i-1]*ninv[i]%mod;a[0]=0;}
inline void Ln(int*a,int n,int*b){PolyInv(a,n,Tmp2),memcpy(b,a,n<<2),dao(b,n),mul(b,Tmp2,n,n,b,n),jifen(b,n);}
int Tmp3[N];
inline void Exp(int*a,int n,int*b){
    if(n==1){b[0]=1;return;}
    int m=n+1>>1;Exp(a,m,b);
    for(int i=m;i<n;i++)b[i]=0;
    Ln(b,n,Tmp3);Tmp3[0]=sub(Tmp3[0],1);
    for(int i=0;i<n;i++)Tmp3[i]=sub(a[i],Tmp3[i]);
    return mul(b,Tmp3,m,n,b,n);
}
int Tmp4[N];
inline void PolyKsm(int*a,int n,int K){
    memset(Tmp4,0,n<<3);
    Ln(a,n,Tmp4);
    for(int i=0;i<n;i++)Tmp4[i]=(LL)Tmp4[i]*K%mod;
    memset(a,0,n<<2);Exp(Tmp4,n,a);
}
int n,Q,q[N],op1,op2,pr[N],pc,vis[N],ci[N],f[N],A[N],B[N];
void sieve(int n){
    vis[1]=1;f[0]=1;
    for(int i=2;i<=n;i++){
        if(!vis[i])pr[++pc]=i,ci[i]=1,vis[i]=i;
        for(int j=1;j<=pc&&i*pr[j]<=n;j++)
            if(i%pr[j])ci[i*pr[j]]=1,vis[i*pr[j]]=pr[j];
            else {ci[i*pr[j]]=ci[i]+1;vis[i*pr[j]]=vis[i]*pr[j];break;}
    }
    for(int i=2;i<=n;i++){
        int cur=1,x=i;
        while(x>1){
            cur=1ll*cur*(ci[x]*2+1)%mod;
            x/=vis[x];
        }
        f[i-1]=cur;
    }
}
int jc[N],ijc[N];
int main(){
    int Max=-2.5e5+1; cin>>n>>Q;
    ijc[0]=ijc[1]=ninv[0]=ninv[1]=jc[0]=jc[1]=1;
    for(int i=1,x;i<=n;i++) cin>>x,(x==1?op1:op2)++;
    for(int i=1;i<=Q;Max=max(Max,q[i]),i++)cin>>q[i];
    for(int i=2;i<=Max;i++)ninv[i]=(LL)ninv[mod%i]*(mod-mod/i)%mod;
    for(int i=2;i<=Max;i++)jc[i]=(LL)jc[i-1]*i%mod,ijc[i]=(LL)ijc[i-1]*ninv[i]%mod;
    if(!op1)A[0]=1;
    else{
        for(int i=0;i<=Max;i++)A[i]=(LL)jc[i+op1-1]*ijc[i]%mod*ijc[op1-1]%mod;
    }
    if(!op2)B[0]=1;
    else{
        sieve(Max+2);
        for(int i=0;i<=Max;i++)B[i]=f[i];
        PolyKsm(B,Max+1,op2);
    }
    mul(A,B,Max,Max,A,Max);
    for(int i=1;i<=Q;i++)
        printf("%d\n",q[i]<n?0:A[q[i]-n]);
    return 0;
}
```

---


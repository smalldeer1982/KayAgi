# [厦门小学生 C++ 2023] 太空旅行

## 题目背景

本试题为 2023 年厦门市小学生 C++ 语言**复赛**试题，数据为洛谷自造。

**初赛**为笔试。

## 题目描述

在未来，太空旅行已经是一件稀松平常的事，星际部又宣称即将开通一条火星至天王星的航线。

所有的星际飞船必须先经过航线 $1$（地球 $\to$ 火星），再经过航线 $X$（火星 $\to$ 天王星）才能顺利抵达天王星。

为了避免星际飞船发生碰撞，每条航线只能有一架飞船正在行驶。已知星际飞船从地球到火星需要 $U(i)$ 时间，火星到天王星需要 $V(i)$ 时间。飞船们可能会滞留在火星，它们必须等待航线状态为空才能起飞。飞船到达火星和离开火星的顺序可能会不一致。

请计算从地球出发的 $N$ 架星际飞船，全部抵达天王星，需要花费的最短时间。

## 说明/提示

### 样例解释

最优方案总耗时为：$2+6+8+1=17$。

| 飞船状态\时间 | 地球 $\to$ 火星出发时刻 | 地球 $\to$ 火星到达时刻 | 火星 $\to$ 天王星出发时刻 | 火星 $\to$ 天王星到达时刻 |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| 第 1 架 | $2$ | $8$ | $8$ | $12$ |
| 第 2 架 | $8$ | $16$ | $16$ | $17$ |
| 第 3 架 | $0$ | $2$ | $2$ | $5$ |

第 $3$ 架飞船最先从地球出发抵达火星，然后到天王星。第 $3$ 架飞船抵达火星后，第 $1$ 架飞船即刻从地球出发。等第 $1$ 架飞船抵达火星后，第 $2$ 架飞船最后从地球出发。

### 【数据范围】

对于所有数据有：$1 \leq N \leq 25000$，$1 \leq U(i),V(i) \leq 50000$。

| 测试点编号 | 特殊性质 | $1 \leq N \leq$ | $1 \leq U(i),V(i) \leq$ |
|:------------:|:----------:|:----------:|:-----------------:|
| $1\sim 2$        | 无       | $10$       | $100$             |
| $3\sim 8$        | 无       | $100$      | $500$             |
| $9\sim 12$       | 无       | $10000$    | $5000$            |
| $13\sim 14$      | B        | $25000$    | $50000$           |
| $15\sim 16$      | A        | $25000$    | $50000$           |
| $17\sim 20$      | 无       | $25000$    | $50000$           |

其中：

- 特殊性质 A：保证所有的 $U(i)$ 都相同。
- 特殊性质 B：保证所有的 $V(i)$ 都相同。

## 样例 #1

### 输入

```
3
6 4
8 1
2 3```

### 输出

```
17```

# 题解

## 作者：chen_zhe (赞：16)

本题是运筹学的经典模型——流水线调度作业模型的 Johnson 不等式的运用。其他的常见模型可参考 [运营管理学习笔记-第十章](https://www.luogu.com.cn/article/84bcjmyb)。

Johnson 不等式是 S. M. Johnson 在 1954 年提出的用于解决两台机器流水车间调度问题以最小化最大完工时间的最优算法。它是一种贪心算法，步骤如下：

1. 将所有 $N$ 架飞船分成两个集合。集合 $S_1$ 包含所有满足 $U(i) \le V(i)$ 的飞船 $i$。集合 $S_2$ 包含所有满足 $U(i) > V(i)$ 的飞船 $i$。
2. 对集合 $S_1$ 中的飞船，按照它们的 $U(i)$ 值进行**非递减 (升序)** 排序。对集合 $S_2$ 中的飞船，按照它们的 $V(i)$ 值进行**非递增 (降序)** 排序。
3. 最终的最优处理顺序是先按照排序后的顺序处理 $S_1$ 中的所有飞船，然后紧接着按照排序后的顺序处理 $S_2$ 中的所有飞船。

这也就是其他题解中所写的：$U$ 值小的尽量往前放，$V$ 值大的尽量往后放。如果 $U \le V$，就看 $U$ 值，越小越靠前；如果 $U > V$，就看 $V$ 值，越大越靠后。这样进行排序统计答案，即可通过本题。

这样做确实能完成本题。但是我不认为这个贪心是非常直观显然的。而这一个贪心的证明也并不简单，甚至可以说是十分繁琐。证明 Johnson 不等式可以使用邻项交换法完成。下面给出一个简要证明。

假设存在一个飞船处理序列 $\pi$，其不完全符合 Johnson 不等式，也即存在一对相邻的飞船 $(i,j)$，它们的顺序不符合 Johnson 不等式。我们需要证明的是，将 $(i,j)$ 交换可以让总花费时间不增加的同时，其符合 Johnson 不等式的排序思路，成为最优方案。为方便叙述，我们定义 $C_{k,1}(\pi)$ 表示在一个飞船处理序列 $\pi$ 中，第 $k$ 艘飞船到达火星的时间，$C_{k,2}(\pi)$ 表示第 $k$ 艘飞船到达天王星的时间。

假设 $i$ 是序列中第 $k$ 个元素，那么，原本不交换的飞船处理序列是 $\pi=(\pi_1,\pi_2,\dots,\pi_{k-1},i,j,\pi_{k+2},\dots,\pi_N)$，而交换后的序列是 $\pi'=(\pi_1,\pi_2,\dots,\pi_{k-1},j,i,\pi_{k+2},\dots,\pi_N)$。实际上我们只需要比较的是 $C_{k+1,2}(\pi)$ 和 $C_{k+1,2}(\pi')$ 的大小，因为之后的元素不会再产生差异。接下来，为了表述方便，我们简记 $A=C_{k-1,1}(\pi)$，即第 $k-1$ 艘飞船到达火星的时间，以及 $B=C_{k-1,2}(\pi)$，即第 $k-1$ 艘飞船到达天王星的时间。根据这些定义和变量，我们可以得出以下的几个数值：

对于飞船处理序列 $\pi$，我们有：
- $C_{k,1}(\pi) = A + U(i)$；
- $C_{k+1,1}(\pi) = C_{k,1}(\pi) + U(j) = A + U(i) + U(j)$；
- $C_{k,2}(\pi) = \max(C_{k,1}(\pi), B) + V(i) = \max(A + U(i), B) + V(i)$。这里的 $\max$ 函数是因为需要等待前一艘飞船到达天王星后，后一艘飞船才能出发；
- $C_{k+1,2}(\pi) = \max(C_{k+1,1}(\pi), C_{k,2}(\pi)) + V(j)$。这里的 $\max$ 函数指，第 $k+1$ 艘飞船已经到达了火星待飞天王星，同时前一艘飞船已经到达了天王星后，才可起飞。

代入上述数值可以得出：$C_{k+1,2}(\pi) = \max(A + U(i) + U(j), \max(A + U(i), B) + V(i)) + V(j)$；

对于飞船处理序列 $\pi'$，类似地我们有：

- $C_{k,1}(\pi') = A + U(j)$；
- $C_{k+1,1}(\pi') = C_{k,1}(\pi') + U(i) = A + U(j) + U(i)$。这一数值与 $C_{k+1,1}(\pi)$ 相同；
- $C_{k,2}(\pi') = \max(C_{k,1}(\pi'), B) + V(j) = \max(A + U(j), B) + V(j)$；
- $C_{k+1,2}(\pi') = \max(C_{k+1,1}(\pi'), C_{k2}(\pi')) + V(i)$；

代入上述数值可以得出：$C_{k+1,2}(\pi') = \max(A + U(j) + U(i), \max(A + U(j), B) + V(j)) + V(i)$

下面我们证明：如果飞船 $i$ 在飞船 $j$ 之前，但它们满足 $\min(U(i), V(j)) > \min(U(j), V(i))$，那么将它们的顺序交换为 $(j, i)$，至少不会增加第 $k+1$ 个位置飞船的完工时间。

根据 $\max$ 函数的运算性质：$\max(x,y)+z=\max(x+z,y+z)$，展开表达式可得：
- $C_{k+1, 2}(\pi) = \max(A+U(i)+U(j)+V(j), A+U(i)+V(i)+V(j), B+V(i)+V(j))$
- $C_{k+1, 2}(\pi') = \max(A+U(j)+U(i)+V(i), A+U(j)+V(j)+V(i), B+V(j)+V(i))$

由于 $C_{k+1, 2}(\pi)$ 和 $C_{k+1, 2}(\pi')$ 的 $\max$ 函数中都含有 $B+V(i)+V(j)$，我们可以忽略它，而只在意 $\max$ 函数的前两项。具体地，我们设 $T_1=A+U(i)+U(j)+V(j)$，$T_2=A+U(i)+V(i)+V(j)$。对应地，$T_1'=A+U(j)+U(i)+V(i)$，$T_2'=A+U(j)+V(j)+V(i)$。此时我们有：
- $T_1-T_1'=[A+U(i)+U(j)+V(j)]-[A+U(j)+U(i)+V(i)]=V(j)-V(i)$；
- $T_2-T_2'=[A+U(i)+V(i)+V(j)]-[A+U(j)+V(j)+V(i)]=U(i)-U(j)$

由于 $\min(U(i), V(j)) > \min(U(j), V(i))$，我们可以进行分类讨论，讨论获取 $U(i),U(j),V(i),V(j)$ 的大小关系：
- $U(i)\leq V(j)$：
  - 情况 1：$U(j)\leq V(i)$。此时 $U(i)>U(j)$ 成立，即 $T_2>T_2'$。而至于 $T_1-T_1'=V(j)-V(i)$，若 $V(j)\geq V(i)$ 则直接得证；若 $V(j)<V(i)$，我们希望此时的 $T_1'$ 不会成为交换后较大的候选值，因此应当比较 $T_2$ 和 $T_1'$。由于 $T_2-T_1'=[A+U(i)+V(i)+V(j)]-[A+U(j)+U(i)+V(i)]=V(j)-U(j)$，由于 $U(i)\leq V(j)$，$U(i)>U(j)$ 可以得出 $T_2-T_1'>0$，即 $T_2>T_1'$，且又有 $T_2>T_2'$，从而 $\max(T_1',T_2')\leq \max(T_1,T_2)$。
  - 情况 2：$V(i)<U(j)$。此时 $U(i)>V(i)$ 成立。由于 $U(i)\leq V(j)$，因此有 $V(j)>V(i)$，可得 $T_1>T_1'$。至于 $T_2-T_2'=U(i)-U(j)$，若 $U(i)\geq U(j)$ 则直接得证；若 $U(i)<U(j)$ 则考虑 $T_1-T_2'=[A+U(i)+U(j)+V(j)]-[A+U(j)+V(j)+V(i)]=U(i)-V(i)$。此时因为 $U(i)>V(i)$，因此 $T_1>T_2'$。又有 $T_2>T_2'$，从而 $\max(T_1',T_2')\leq \max(T_1,T_2)$。
- $V(j)<U(i)$：
  - 情况 1：$U(j)\leq V(i)$。证明与上方一致，从略。
  - 情况 2：$V(i)<U(j)$。证明与上方一致，从略。

由于两个序列中第三个项完全相同，所以可得：

$$C_{k+1,2}(\pi') = \max\{T'_1,\,T'_2,\,B+V(i)+V(j)\} \le \max\{T_1,\,T_2,\,B+V(i)+V(j)\} = C_{k+1,2}(\pi)$$

也即排序方式成立。因此，通过逐步交换所有违反 Johnson 不等式的相邻对 $(i,j)$，调整得到最优的飞船处理序列 $\pi$，计算该序列所需的时间，即为答案。

接下来从编写代码的角度出发，如果直接根据 $\min(U(i), V(j)) \leq \min(U(j), V(i))$ 编写排序的方式是错误的。在这一篇 [题解](https://www.luogu.com.cn/article/uz8uogas) 里面说的非常清楚明白。总而言之，使用本文开头所讲述的方式：

1. 将所有 $N$ 架飞船分成两个集合。集合 $S_1$ 包含所有满足 $U(i) \le V(i)$ 的飞船 $i$。集合 $S_2$ 包含所有满足 $U(i) > V(i)$ 的飞船 $i$。
2. 对集合 $S_1$ 中的飞船，按照它们的 $U(i)$ 值进行**非递减 (升序)** 排序。对集合 $S_2$ 中的飞船，按照它们的 $V(i)$ 值进行**非递增 (降序)** 排序。

即可完成对飞船的排序，从而计算得出结论。从证明贪心方式到错误的排序，都体现出本题难度很高，并非部分用户所认为的只有黄题难度。

参考代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(nullptr);
	int n;
	cin >> n;
	vector <pair<int, int >> s(n);
	for (int i = 0; i<n; i++)
		cin >> s[i].first >> s[i].second;
	vector <pair<int, int >> g1, g2;
	for (int i = 0; i<n; i++) {
		if (s[i].first <= s[i].second)
			g1.push_back(s[i]);
		else
			g2.push_back(s[i]);
	}
	sort(g1.begin(), g1.end(), [](auto a, auto b) {
		return a.first<b.first;
	});
	sort(g2.begin(), g2.end(), [](auto a, auto b) {
		return a.second>b.second;
	});
	vector <pair<int, int >> ans;
	for (auto s: g1)
		ans.push_back(s);
	for (auto s: g2)
		ans.push_back(s);
	long long t1 = 0, t2 = 0;
	for (auto s: ans) {
		t1 += s.first;
		t2 = max(t1, t2) + s.second;
	}
	cout << t2 << endl;
	return 0;
}
```

---

## 作者：zzy0618 (赞：9)

假如我们确定了顺序，我们计算总时间的方式应该是这样的。

```cpp
int tmp=0,ans=0;
for(int i=1;i<=n;++i){
    tmp+=a[i].u;
    ans=max(ans,tmp)+a[i].v;
}cout<<ans<<'\n';
```

因为地球到火星是可以不停顿的，所以 $tmp$ 可以一直加上，最终到天王星的时间取决与火星到天王星和地球到火星两个值，所以要取 $\max$。

那么我们可以通过这个计算方式考虑我们的贪心。对答案变化有影响的就是其中的 $\max$，我们将 $u<v$ 和 $u\ge v$ 的各分一组。由于最终 $ans\ge sum(v)$ 不可逃避，我们只希望 $tmp$ 不对 $ans$ 造成过大的影响，所以优先让 $u<v$ 的通过。同样 $u<v$ 的选择 $u$ 小的先通过。对于 $u>v$ 的将 $v$ 大的优先通过。

总感觉怪怪的，但是通过了洛谷的所有 hack 数据，欢迎质疑。

```cpp
#include<bits/stdc++.h>
#define int long long
#define pii pair<int,int>
#define pb push_back
#define mk make_pair
using namespace std;
const int N=25005,INF=1e9;
int n,tmp,ans;
vector<pii> v1,v2;
signed main(){
    ios::sync_with_stdio(0);
    cin.tie(0),cout.tie(0);
    cin>>n;
    for(int i=1,x,y;i<=n;++i)
        cin>>x>>y,x<y?v1.pb(mk(x,y)):v2.pb(mk(y,x));
    sort(v1.begin(),v1.end());
    sort(v2.begin(),v2.end());
    reverse(v2.begin(),v2.end());
    for(auto v:v1)
        tmp+=v.first,ans=max(ans,tmp)+v.second;
    for(auto v:v2)
        tmp+=v.second,ans=max(ans,tmp)+v.first;
    cout<<ans<<'\n';
    return 0;
}
```

---

## 作者：yedalong (赞：6)

四倍经验  
[P2123](https://www.luogu.com.cn/problem/P2123)  
[P1248](https://www.luogu.com.cn/problem/P1248)  
[P1561](https://www.luogu.com.cn/problem/P1561)  
~~六百六十六，演都不演了，连样例都一毛一样~~  
~~出题人是怎么敢出原题的~~  
~~话说给小学生紫题有点过分了吧~~  

## Solution
回归正题。  

首先，我们先考虑对于从地球到火星这一段应该优先安排怎样的飞船先走。  
很容易想到，我们要把花时间短的安排在前面。因为如果将花时间长的飞船安排在前面会拖慢后面的飞船，相对花时间短的飞船不是最优的。  

在谈论从火星到天王星这一段的策略之前，我们先想想怎样才能使得花的时间最短。  
因为不管怎样，这两条航线最多都只有一架飞船，那么有一种策略就是让第二段航线上的飞船尽可能的连着，那也就是想办法让火星上尽可能地有飞船停泊在那里。  
接着我们再来谈论一下怎样的飞船应该先走第二段航线。由于我们前面说到要让火星上尽可能的有飞船，那么就想办法让第二段航线上的飞船尽可能的拖延时间，使得飞船从地球转移到火星上。所以，第二段航线我们应该让花的时间长的飞船优先排在前面。  

接着我们分讨一下飞船。对于飞船，我们可以分为两类。一种是第一段航线花的时间比第二段航线花的时间短，另一类相反。根据我们上面讨论到的策略，很容易想到，第一段航线花的时间比第二段航线花的时间短的飞船必定在另一类前面。那么对于同一类就是直接按照策略排序就好了。  

假设现在我们已经排好了序，飞船的顺序已经是最优的顺序。那么答案怎样计算呢？对于第 $i$ 架飞船，设前 $i-1$ 架飞船完成的时间为 $ans$，那么第 $i$ 架飞船完成的时间就是 $\max(ans,\sum_{j=1}^{i}{U(j)})+V(i)$，这一部分其实挺好想的，这里就不多解释了。  

时间复杂度为 $O(n\log n)$，可以通过此题。  

## AC code

```cpp
#include <bits/stdc++.h>
using namespace std;
struct spaceship{
	int u,v;
}arr[25005];
bool cmp(spaceship a,spaceship b){
	if(a.u<a.v){
		if(b.u<b.v) return a.u<b.u;
		return 1;
	}
	else{
		if(b.u<b.v) return 0;
		return a.v>b.v;
	} 
}
int main(){
	int n;cin>>n;int summ=0;
	for(int i = 0;i<n;i++){
		cin>>arr[i].u>>arr[i].v;
	}
	int ans=0;
	sort(arr,arr+n,cmp);
	for(int i = 0;i<n;i++){
		summ+=arr[i].u;
		ans=max(summ,ans)+arr[i].v;
	}
	cout<<ans;
}
```

---

## 作者：wangif424 (赞：5)

考虑经典贪心，将飞船分为两类：那些 $U(i) \le V(i)$ 的，和 $U(i) > V(i)$ 的。对于前一类，按 $U(i)$ 升序排列；对于后一类，按 $V(i)$ 降序排列。然后将前一类排在前面，后一类排在后面，依次处理即可。 

考虑证明，这里举一例 $U \le V$ 的情况。

有 $U(i)\le V(i),U(i)\lt U(j),U(j)\le V(j)$，那么总时间有两种可能 $A=U(i)+\max(U(j),V(i))+V(j)$ 或 $B=U(j)+\max(U(i),V(j))+V(i)$。

先化简一步 $B=U(j)+V(j)+V(i)$，然后做差 $A-B=U(i)-\min(V(i),U(j))\le 0$，所以 $A\le B$。

其他情况同理可以证明得到，故不过多阐述。

考虑具体实现只需要一遍排序后，再扫一下数组即可，故不贴出代码。

---


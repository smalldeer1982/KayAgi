# 「KDOI-10」水杯降温

## 题目背景

**本场比赛所有题目从标准输入读入数据，输出到标准输出。**

## 题目描述

小 S 有一棵包含 $n$ 个节点的有根树，且根为节点 $1$。节点 $i$ $(1\le i\le n)$ 上放置了一个初始水温为 $a_i$ 的水杯。

在不知道水温的情况下拿起水杯喝水并被烫了 inf 次的小 S 决定将这些水杯的水温全部变为 $0$ 后再喝它们。

现在，小 S 可以分别进行以下两种操作任意次：

* 使用一个在节点 $i$ 的加热装置。这会使以 $i$ 为根的子树内所有水杯里的水温均增加 $1$；
* 或者，从某个**叶子**节点 $i$ 向根方向吹一阵风。这会使 $i$ 到根所有水杯里的水温均减少 $1$。

请你帮小 S 判断：能否将所有节点上的水杯的水温都变为 $0$。



## 说明/提示

**【样例 1 解释】**

记 $A_u$ 表示在节点 $u$ 使用加热装置的操作，$B_u$ 表示从节点 $u$ 吹一阵风的操作，$(S)^k$ 表示将操作序列 $S$ 重复 $k$ 次。

- 对于第一、三、四组测试数据，可以证明，小 S 无法将所有水杯的水温都变为 $0$；
- 对于第二组测试数据，一种可能的操作序列为：$B_3(A_4)^2(B_4)^4B_5$；
- 对于第五组测试数据，一种可能的操作序列为：$(A_4)^3A_1$。

**【样例 2】**

见选手目录下的 `water/water2.in` 与 `water/water2.ans`。

这个样例满足测试点 $3$ 的约束条件。

**【样例 3】**

见选手目录下的 `water/water3.in` 与 `water/water3.ans`。

这个样例满足测试点 $7,8$ 的约束条件。

**【样例 4】**

见选手目录下的 `water/water4.in` 与 `water/water4.ans`。

这个样例满足测试点 $12$ 的约束条件。

**【样例 5】**

见选手目录下的 `water/water5.in` 与 `water/water5.ans`。

这个样例满足测试点 $13,14$ 的约束条件。

**【样例 6】**

见选手目录下的 `water/water6.in` 与 `water/water6.ans`。

这个样例满足测试点 $15\sim 17$ 的约束条件。

**【样例 7】**

见选手目录下的 `water/water7.in` 与 `water/water7.ans`。

这个样例满足测试点 $18\sim 21$ 的约束条件。


***

**【数据范围】**

记 $\sum n$ 为单个测试点内所有测试数据中 $n$ 的和。

对于全部的测试数据，保证：

- $1\leq t\leq 1\,000$；
- $2\leq n\leq 10^5$，$\sum n\le 10^6$；
- 对于任意 $2\le i\le n$，$1\le f_i<i$；
- 对于任意 $1\le i\le n$，$-10^{12}\leq a_i\leq10^{12}$。

| 测试点 | $n\leq$ | $\sum n\le $ | $\lvert a_i\rvert\leq$ | 特殊性质 |
| :----: | :-----: | :----------: | :--------------------: | :------: |
| $1$ | $5$ | $50$ | $5$ | 无 |
| $2$ | $5$ | $200$ | $5$ | 无 |
| $3$ | $5$ | $5\,000$ | $5$ | 无 |
| $4,5$ | $50$ | $500$ | $50$ | 无 |
| $6$ | $50$ | $500$ | $10^{8}$ | 无 |
| $7,8$ | $200$ | $2\,000$ | $200$ | 无 |
| $9$ | $200$ | $2\,000$ | $10^{8}$ | 无 |
| $10,11$ | $1\,000$ | $10^4$ | $1\,000$ | 无|
| $12$ | $1\,000$ | $10^4$ | $10^{8}$ | 无 |
| $13,14$ | $10^5$ | $3\times 10^5$ | $10^{12}$ | A |
| $15\sim 17$ | $10^5$ | $3\times 10^5$ | $10^{12}$ | B |
| $18\sim 21$ | $10^5$ | $3\times 10^5$ | $10^{12}$ | C |
| $22,23$ | $3\times 10^4$ | $10^5$ | $10^{8}$ | 无 |
| $24,25$ | $10^5$ | $10^6$ | $10^{12}$ | 无 |

- 特殊性质 A：对于任意 $2\le i\le n$，$f_i=i-1$；
- 特殊性质 B：对于任意 $1\le i\le n$，$a_i\le \left(\sum_{f_j=i}a_j\right)+5$，其中设 $f_1=0$；
- 特殊性质 C：树的深度不超过 $2$，其中深度指所有节点到根的边数中的最大值。

***

**【提示】**

本题输入输出量较大，请使用适当的 I/O 方式。

## 样例 #1

### 输入

```
0
5
5
1 1 2 3
6 5 2 2 1
5
1 1 2 2
6 5 1 2 1
5
1 1 2 2
4 -1 5 -2 -2
5
1 1 2 2
6 -4 8 -3 -3
5
1 1 2 2
-1 -1 -1 -4 -1```

### 输出

```
Shuiniao
Huoyu
Shuiniao
Shuiniao
Huoyu```

# 题解

## 作者：Lavaloon (赞：38)

**Update on 2024.10.15：**$anc_i$ 的定义并不完善，事实上应包含 $i$ 节点本身的贡献。在此感谢 @_Fatalis_ 的指出！

**Update on 2024.12.10**：刚刚了解到使用 `align*` 而非 `align` 可以去除公式后的编号，为优化读者阅读体验故作出修改。辛苦管理员了！

**Update on 2025.7.13**：~~虽然笔者已经退役~~但是我咋刚刚注意到文章所有左右引号都用反了啊，在此改正。

---

很多人赛时考虑过“**先做子树加操作，再去判定链减的合法性**”的思路，但在中途改变了想法。故该题解旨在说明该思路的可行性。

**做法可能相对复杂，但笔者相信其亦具有一定的参考性。**

## 基本定义

**下将“链减”操作称为 A 操作，“子树加”操作称为 B 操作。**

**下记 $\mathbb{LEAF}$ 为叶节点所组成的的集合，$e_i$ 为 $i$ 的子节点所组成的集合，$fa_i$ 为 $i$ 的父节点（即题目中的 $f_i$）。**

**记 $d_i$ 为 $i$ 的子节点所组成的集合大小，即子节点个数。**

## 确定大体思路

可以考虑先进行一种操作，再去判断：进行完这一种操作后的局面是否能使用另一种操作，来使局面变得合法。

讨论两种思路：

- **思路一**：若一个局面在只使用 A 操作下可以变得合法，则需要满足：
  - **条件一：**$\forall i,a_i\ge 0$;
  - **条件二：**$\forall i\notin \mathbb{LEAF},a_i=\sum_{j\in e_i} a_j$.
- **思路二**：若一个局面在只使用 B 操作下可以变得合法，则需要满足：
  - **条件一：**$\forall i,a_i\le 0$;
  - **条件二：**$\forall i\ne 1,a_i\le a_{fa_i}$.

注意到题目给出的 B 性质恰为：$a_i\le \left(\sum_{{j\in e_i}}a_j\right)+5$，于是我们对思路一进行考虑！！！

## 考察判定条件

**下文的所有内容将围绕思路一展开。**

考察条件二的等式，令 $b_i=a_i-\sum_{j\in e_i} a_j$，答案是否存在的判定即转化为：对 $\forall i\notin \mathbb{LEAF},b_i=0$ 可行性的判定。

**特别地，将 $b_i$ 对于 $i\in \mathbb{LEAF}$ 定义为 $a_i$。**

考察一次 B 操作对 $b$ 数组的影响。

若对 $u$ 子树执行一次 B 操作，那么：

- 对于 $u$ 子树内任意一**非叶节点** $i$，$b_i\leftarrow b_i-d_i+1$;
- 对于 $u$ 的父节点 $p$，$b_p\leftarrow b_p-1$.

每一次操作后 $b_i$ 不增。

因此对于原局面的一个非叶结点 $i$，若有 $b_i<0$，那么一定无解。提前判掉。

## 优化判定形式

当时我接下来就没啥思路了，于是我选择将每个点执行了几次 B 操作设出来：

**设对 $i$ 子树执行了 B 操作的次数为  $c_i$。**

**下令 $anc_i$ 表示 $i$ 节点及其祖先所构成的集合。**

那么在执行完所有 B 操作后，$b_i$ 的值应当为 $0$，这给出：
$$
b_i=\sum_{j\in e_i} c_j+(d_i-1)\sum_{j\in anc_i} c_j
$$
这个式子的结构相当令人恼火。

首先，其具有非常丑陋的**后效性**——无论是考虑从上到下确定 $c_i$，还是从下到上确定 $c_i$，都无法简单建立递推关系。

其次，该式中 $c_i$ 的取值和 $i$ 的所有祖先都有关，而这种结构着实难以处理。

这启发我们定义：
$$
f_i=\sum_{j\in anc_i} c_j
$$
**注意：由 $f_i$ 的定义，我们需要保证 $f_i\ge f_{fa_i}$.**

将 $c_i$ 用 $f_i-f_{fa_i}$ 替换，得出：
$$
\begin{align*}
b_i&=\sum_{j\in e_i} (f_j-f_i)+(d_i-1)f_i
\\
&=\sum_{j\in e_i} f_j-f_i
\end{align*}
$$
这个式子的结构非常优雅且具有高贵的**无后效性**！现在我们可以考虑**自底向上确定 $f_i$** 的思路了。

## 设计判定信息

**下文遵循自底向上考虑的逻辑顺序展开。**

首先是**考虑所有叶子**：假如 $b_i<0$，那么 $f_i$ 至少要是 $-b_i$，否则 $f_i$ 的下界是 $0$（这其实是思路一的条件一）。

对于一个**子节点全是叶子的节点** $u$，若 $f_u=k$ 是可行的，那么需要满足以下条件：
$$
\sum_{v\in e_u} \max(-b_v,k)\le b_u+k
$$
左边是每个叶子节点 $f_v$ 取值的**下界**之和，其应当小于等于 $b_u+k$。因为要是这个成立的话，只需要把一些 $f_v$ 取大一点，就可以构造出 $b_u=\sum_{v\in e_u} f_v-k$ 了。

**这启示我们对于每个 $u$ 维护 $f_u$ 的下界。不妨记之为 $\ell_u$.**

假如我们已经确定了 $\ell_u$，那么 $k$ 可以取到的值应呈现如何的性质？

可以考虑暴力从 $\ell_u$ 开始枚举，一个个 Check 每个值（不妨称为 $t$）作为 $k$ 是否合法。这个值增大 $1$ 的过程中，上式会发生如下变化：

- 对于右边：
  - 稳定增大 $1$.

- 对于左边：
  - 一开始可能会比任何一个 $-b_v$ 都小，每次增大 $0$；
  - 随着 $t$ 的增大，可能会恰好超过其中一个 $-b_v$，每次增大 $1$；
  - 又随着 $t$ 的增大，可能会恰好超过其中两个 $-b_v$，每次增大 $2$；
  - 以此类推。

![](https://cdn.luogu.com.cn/upload/image_hosting/wb37lo9y.png)

那么 $b_u+t-\sum_{v\in e_u} \max(-b_v,t)$ 呈先增后减，这给出：

**$k$ 可以取到的值是一段区间。**

**这启示我们对于每个 $u$ 维护 $f_u$ 的上界。不妨记之为 $r_u$.**

这同时启示我们使用二分即可轻松求得 $r_u$，只需要把上面 $f_u=k$ 可行的条件抄下来 check 就行了。

回过头来思考如何求解 $\ell_u$。

- 首先，在“左边每次增大 $0$ ”终止的那个时刻（上图点 $\text{B}$），$b_u+t-\sum_{v\in e_u} \max(-b_v,t)$ 达到巅峰。左端点一定在此位置或其之前。
- 其次，假如在点 $\small\mathrm{B}$ 之前，那么每往前一步，这个值就减 $1$。然而这个值要始终大于等于 $0$，那么可行的左端点就是容易求得的。

于是我们解决了子节点都是叶子的情况。

对于**子节点不全是叶子的情况**，处理思路与之类似。具体来说：

若 $f_u=k$ 是可行的，那么需要满足以下条件：
$$
\begin{align*}
\left\{\begin{matrix}
\sum_{v\in e_u} \max(\ell_v,k)&\le b_u+k
 \\
\sum_{v\in e_u} r_v&\ge b_u+k
\end{matrix}\right.
\end{align*}
$$
解释一下：

- 上面那个式子和之前的那个类似，即每个子节点 $f_v$ 取值的**下界**之和，应当小于等于 $b_u+k$.

- 下面那个式子是说，上界不能小于 $b_u+k$。这样才能确保 $b_u+k$ 是取得到的（为什么在子节点全是叶子的情况中没有这一条？因为叶子节点 $i$ 的 $g_i$ 可以被认为是 $+\infty$，该式自然满足）。

可以使用与上一种情况类似的思路求解 $\ell_u$ 和  $r_u$。

至此我们解决了整个问题。

## 程序流程

- 首先求解 $b_i$。若存在非叶结点 $b_i<0$ 则返回无解并退出。
- 接下来递归求解 $f_i$：
  - 对叶子节点，定下界 $\ell_i=\max(0,-b_i)$，上界 $r_i=+\infty$.
  - 对非叶节点，容易计算 $\ell_i$ 并通过二分确定 $r_i$。若不存在合法的 $r_i$ 则返回无解并退出。
    - 二分的上下界存在细节：**前文那个大括号下面的式子不能忽略**。

- 返回有解，退出程序。

## 代码实现

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int Mx=100005,p=998244353;
int read(){
	char ch=getchar();
	int Alice=0,Aya=1;
	while(ch<'0'||ch>'9'){
		if(ch=='-') Aya=-Aya;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')
		Alice=(Alice<<3)+(Alice<<1)+(ch^48),ch=getchar();
	return (Aya==1?Alice:-Alice);
}
int n;
int fa[Mx];
int a[Mx],b[Mx];
int deg[Mx];
int l[Mx],r[Mx];
vector<int>e[Mx];
void Solve(){
	n=read();
	for(int i=1;i<=n;i++) deg[i]=0,l[i]=0,r[i]=1e13,e[i].clear();
	for(int i=2;i<=n;i++) fa[i]=read(),deg[fa[i]]++,e[fa[i]].push_back(i);
	for(int i=1;i<=n;i++) a[i]=b[i]=read();
	for(int i=2;i<=n;i++) b[fa[i]]-=a[i];//计算 b[i]
	for(int i=1;i<=n;i++){
		if(deg[i]&&b[i]<0){//判无解
			puts("Shuiniao");
			return;
		}
	}
	for(int i=1;i<=n;i++) if(deg[i]==0&&b[i]<0) l[i]=-b[i];
	for(int i=n;i>=1;i--){
		if(deg[i]==0) continue;
		int L=1e13,R=1e13,ok=-1;
		for(int v:e[i]) L=min(L,l[v]);
		for(int v:e[i]) R=min(R,r[v]);
		int sf=0,sg=0;
		for(int v:e[i]) sf+=l[v];
		for(int v:e[i]) sg+=r[v];
		if(sg<b[i]){
			puts("Shuiniao");
			return;
		}
		L=min(L,sg-b[i]),R=min(R,sg-b[i]);//注意二分的上下界
		l[i]=min(L,max(0ll,sf-b[i]));//计算下界
		while(L<=R){
			int mid=((L+R)>>1);
			int w=0;
			for(int v:e[i]) w+=max(mid,l[v]);
			w-=mid;
			if(w<=b[i]) L=mid+1,ok=mid;
			else R=mid-1;
		}
		if(ok==-1){//判无解
			puts("Shuiniao");
			return;
		}
		r[i]=ok;//二分上界
	}
	puts("Huoyu");
}
signed main(){
	read();
	int T=read();
	for(int i=1;i<=T;i++) Solve();
	return 0;
}
```

---

## 作者：Link_Cut_Y (赞：36)

哦很好的一道题啊，不过比较套路就是了。

首先肯定要树上差分。不妨设每个点的新权值 $nw_u = w_{u} - w_{fa}$。那么每个点的实际权值就是它到根的路径和。于是两个操作被等价成：

- 操作 $1$：任意选取一个点 $u$，并将 $a_u$ 加上 $1$。

- 操作 $2$：任意选取一个叶子 $u$，设 $u$ 到根的路径是 $\{p\}$。将与 $p$ 直接相连且不属于 $p$ 的点 $v$ 的权值加上 $1$。最后将根节点权值 $-1$。

可以发现除了对于根节点，其他点无论怎么操作权值都变大。即若存在 $u \ge 2$ 使得 $nw_u > 0$ 则无解。

可以发现，如果一个点权值是负的，则可以通过操作 $1$ 将其变成 $0$。因此接下来如果 $nw_1 \le 0$ 则一定有解。

接下来考虑 $nw_1 > 0$ 的情况。这需要看用操作 $2$ 最多能减掉多少。

不妨设 $f_u$ 表示以 $u$ 为根的子树，它的叶子最多能减掉多少。考虑一下怎么转移。

假设 $u$ 的儿子集合是 $\{son(u)\}$，大小为 $|son(u)|$。则我们需要对每个儿子都选择一个值贡献到 $u$ 上。假设 $v$ 的贡献是 $b_v$。首先要满足 $b_v \le f_v$。

由于每个值一定不能给他弄成正的，所以这里还有别的限制。不妨设 $s = \sum_{v \in son(u)} b_i$。$\forall v \in son(u)$，都应该满足 $s - b_v \le lim_v$，其中 $lim_v = |nw_v|$。

这个限制怎么理解呢？其实就是说，对于所有不经过 $v$ 且经过 $u$ 的那些路径（我指经过 $u$ 的），$v$ 一定与他们直接相邻；但是经过 $v$ 的则不是。因此这种方案下，$nw_v$ 在操作二下增加了 $s - b_v$。而它又必须是负的。

上面我们得到了两个限制：$s - lim_v \le b_v \le f_v$。由于 $s$ 的大小一定具有单调性，所以可以进行二分。

不妨设当前二分到的就是 $s$。如何检查 $s$ 是否合法呢？

首先假设所有的 $b_v$ 都取到了上界即 $f_v$。如果他们的和仍然小于 $s$，说明 $s$ 无法达到。

否则，假设所有 $b_v$ 都取到了下界即 $\max\{s - lim_v, 0\}$。如果有某个 $b_v > f_v$ 则也是不符合条件的。他们的和 $s'$ 如果大于 $s$，那么也说明 $s$ 是不可取到的。其他情况下都是合法的。

这样去转移可以得到 $f_1$。如果 $f_1 \ge |nw_1|$，则说明可以将 $1$ 减成 $0$。否则不能。

时间复杂度 $O(n \log V)$。

```cpp
const int N = 100010;
const int INF = 1e13;
int f[N], fa[N], nw[N], w[N], n;
vector<int> E[N]; int id;
int lim[N], b[N];
bool check(int u, int mid) {
	int m = E[u].size(); int s = 0;
	rop(i, 0, m) s += f[E[u][i]];
	if (s < mid) return 0;
	rop(i, 0, m) b[i] = max(0ll, mid - lim[i]);
	s = 0; rop(i, 0, m) s += b[i];
	if (s > mid) return 0; return 1;
}
void dfs(int u) {
	int m = E[u].size();
	if (!m) { f[u] = INF; return; }
	for (auto v : E[u]) dfs(v);
	rop(i, 0, m) lim[i] = abs(nw[E[u][i]]);
	int mn = INF; rop(i, 0, m) mn = min(mn, f[E[u][i]] + lim[i]);
	int l = 0, r = mn;
	while (l < r) {
		int mid = l + r + 1 >> 1;
		if (check(u, mid)) l = mid;
		else r = mid - 1;
	} f[u] = l;
}
void sub(int o) {
	read(n);
	rep(i, 1, n) f[i] = 0;
	rep(i, 2, n) read(fa[i]);
	rep(i, 1, n) E[i].clear();
	rep(i, 1, n) E[fa[i]].push_back(i);
	rep(i, 1, n) read(w[i]);
	rep(i, 1, n) nw[i] = w[i] - w[fa[i]];
	rep(i, 2, n) if (nw[i] > 0) {
		return puts("Shuiniao"), void();
	} dfs(1); 
	if (f[1] >= w[1]) puts("Huoyu");
	else puts("Shuiniao"); return;
}
signed main() {
	read(id); read(T);
	rep(o, 1, T) sub(o);
	return 0;
}
```

---

## 作者：piggy123 (赞：19)

大概断断续续干了两天，也算是把这个题干出来了。其中接触到了一些关于这个题的争议。说一下我的看法吧。

其实我感觉这个题很符合我对 CSP-S T2 的认识，没有什么非常 adhoc 的地方，循规蹈矩一步步想就能想到；但是很容易走到错误的思考方式上，需要有及时抛弃从头开始的勇气。如果真正在考场上看到这道题，我不能保证自己会切掉他，但我绝不会惊讶，因为这个题很 CNOI（于我而言，思考过程比较类似迷宫守卫，所以我认为这题紫是合理的）。

注意到操作顺序无关。所以我们可以先使用一种操作，然后再使用另一种操作调整为最终结果。一个简单的想法是，先做 $1$ 操作再做 $2$ 操作，那么可以调整为全 $0$ 的条件为：
1. 叶子节点权值非负。
2. 每个节点权值等于其儿子节点权值之和。
   
接着刻画 $1$ 操作的影响，你会发现这涉及到儿子结点个数，而且对 $u$ 操作还会影响 $u$ 分父亲，非常繁琐，我大概思考了二十分钟没有什么想法。

那么此时我们应该回头，不妨假设先做 $2$ 操作再做 $1$ 操作，那么再次刻画条件：
1.根节点权值非正。
2.所有节点权值小于等于其父亲。

而 $1$ 操作的影响是，设 $b_i=a_i-a_{f_i}$，为某条叶子到根路径的 $1$ 邻域 $b_i$ 加一。这看起来也不好维护。

但是注意到，初始时，$2$ 条件必定被满足，否则无解。这是因为 $b_i$ 在所有过程中是不降的，比较显然。于是我们只需要满足条件 $1$ 即可，如果根节点最初就是非正的，那么显然合法，否则我们需要至少做 $a_1$ 次操作才可以使其合法。

但是我们不能任意多地做操作，因为这可能使得某些 $b$ 加太多变为正的。这于是启示我们采用 DP 求解最多能做多少次操作。（以下的部分 $b_i$ 取绝对值）

想到了这一点之后，后面就比较显然了。设 $u$ 的儿子节点为 $v_1,v_2,\dots,v_k$，那么我们就需要求解一个最大的 $\sum p_i$，使得：
1. $\sum p_i-p_i\leq b_i$
2. $0\leq p_i\leq dp_{v_i}$

比较显然地，这是一个不等式组，有满足条件的一组 $p_i$ 的 $\sum p_i$ 一定形成了一个区间（具体地，最小值 $0$ 显然可达，接下来每次选取最小值操作即可）。我们二分最大值并 check 即可。

代码比较好写，注意爆 ll 的问题

---

## 作者：eastcloud (赞：8)

先单独分析一下这两个操作，它们都形似对于树上一个特殊的“前缀”或“后缀”作加减，这启发我们考虑差分。

设 $d_u=a_u-a_{fa_u}$，你会发现子树加相当于把 $a_1$ 或某个 $d_u$ 加一，如果我们先做完所有到根减的操作，那这个局面有解当且仅当 $\forall u,a_u \le 0 \wedge d_u \le 0$。

由于每次操作后所有 $d_u$ 要么不变要么增加，因此做太多操作一定是很劣的，并且这也限制了我们能做的操作数量，这个限制与孩子节点的权值有关，并且好像很能递推，于是我们从下往上考虑一个节点能否利用孩子子树内的操作变得合法。

具体地，我们设 $g_u$ 表示自最多还可以操作当前节点子树的叶子多少次并保证子树内仍然合法，设 $f_u$ 表示当前节点的子树里已经操作了多少次，可以得到：

- 对于于叶子节点，$g_u=\inf$，$f_u=\max(0,a_u)$。

- 对于非叶子节点，我们先令 $g_u \leftarrow \sum_{v\in son_u} g_v$，$f_u$ 可以通过孩子的信息进行二分，你需要保证操作后仍然有 $d_v \le 0$，最后如果有 $a_u \ge 0$，再消耗 $a_u$ 的代价将其减为 0 即可。

如果在过程中出现孩子大于祖先或者不够减的情况就是不合法，一些细节可以参照代码（代码可能写的稍显抽象/wul）。


```cpp

#include<bits/stdc++.h>

#define ll long long
#define pi pair<ll,ll>
#define vi vector<ll>
#define cpy(x,y,s) memcpy(x,y,sizeof(x[0])*(s))
#define mset(x,v,s) memset(x,v,sizeof(x[0])*(s))
#define all(x) begin(x),end(x)
#define fi first
#define se second
#define mp make_pair
#define pb push_back
#define ary array
#define IL inline

#define mod 998244353
#define N 1000005
#define inf 1e14

using namespace std;
ll read(){
    ll x=0,f=1;char ch=getchar();
    while(ch<'0' || ch>'9')f=(ch=='-'?-1:f),ch=getchar();
    while(ch>='0' && ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
    return x*f;
}
void write(ll x){
    if(x<0)x=-x,putchar('-');
    if(x/10)write(x/10);
    putchar(x%10+'0');
}

vi e[N];
ll flag=0,done[N],a[N],ok[N];

void dfs(ll x,ll fa){
    vi S;
    for(auto v:e[x]){
        dfs(v,x),S.pb(a[v]),done[x]+=done[v],a[x]-=done[v];
    }
    if(flag)return;
    sort(all(S),[](ll x,ll y){return x>y;});
    if(!S.size()){
        if(a[x]>0){
            done[x]=a[x];a[x]=0;ok[x]=-1;return;
        }
        return ok[x]=-1,void();
    }
    if(S[0]>a[x])return flag=1,void();
    if(S.size()==1){
        ll v=e[x][0];
        if(a[x]<=0)return ok[x]=ok[v],void();
        if(ok[v]!=-1 && a[x]>ok[v])return flag=1,void();
        ok[x]=(ok[v]==-1?-1:ok[v]-a[x]);done[x]+=a[x];a[x]=0;
        return;
    }
    ll l=0,r=inf;
    while(l<r){
        ll mid=(l+r+1)>>1;
        ll flag2=1,must=0,ava=0;
        for(auto v:e[x]){
            if(ok[v]!=-1 && a[x]-mid<a[v]-ok[v]){flag2=0;break;}
            if(a[v]>a[x]-mid)must+=a[v]-(a[x]-mid);
            ava=(ok[v]==-1 || ava==-1?-1:ava+a[x]-mid-(a[v]-ok[v]));
        }
        if(!flag2){r=mid-1;continue;}
        if(mid<must){r=mid-1;continue;}
        if(ava!=-1 && mid>must+ava){r=mid-1;continue;}
        l=mid;
    }
    ok[x]=(l==inf?-1:l);
    if(a[x]<0)return;
    if(ok[x]!=-1 && ok[x]<a[x])return flag=1,void();
    if(ok[x]!=-1)ok[x]-=a[x];
    done[x]+=a[x];a[x]=0;
}

void solve(){
    ll n=read();flag=0;
    for(ll i=2;i<=n;i++){
        ll x=read();e[x].pb(i);
    }
    for(ll i=1;i<=n;i++)a[i]=read();
    dfs(1,0);
    if(flag)printf("Shuiniao\n");
    else printf("Huoyu\n");
    for(ll i=1;i<=n;i++)e[i].clear(),done[i]=ok[i]=a[i]=0;
}

int main(){
    #ifdef EAST_CLOUD
    freopen("a.in","r",stdin);
    freopen("a.out","w",stdout);
    #endif

    ll id=read();
    ll T=read();while(T--)solve();
    return 0;
}
//cerr<<fabs(&Med-&Mbe)/1048576.0<<"MB\n";
//cerr<<"\n"<<clock()*1.0/CLOCKS_PER_SEC*1000<<"ms\n";
```

---

## 作者：SamHJD (赞：8)

两个操作互相不影响，钦定先做操作二后做操作一。将操作一转化为差分值（自身点权减父结点点权）加一，显然，能只通过操作一使点权全变为 $0$ 的条件为每个点的差分均小于等于 $0$，且根的点权小于等于 $0$。

操作一和操作二不会使除根节点以外的差分值减少，因此若初始局面下存在非根节点差分值为正则无解。

在保证每个点的差分值小于等于 $0$ 下，要尽可能使根节点的点权最小，于是设 $f_u$ 为 $u$ 的子树中保证该条件下最多能做几次操作二。

考虑如何从 $f_v$ 推出 $f_u$。设 $d_v=a_u-a_v$，每在子树 $v$ 中做一次操作二，会使除 $d_v$ 外的所有 $d$ 减一，转化为如下问题：

> 有 $n$ 堆石子，第 $i$ 堆有 $d_i$ 个。每次选 $n-1$ 堆，各拿一个，并要求第 $i$ 堆最多不选 $f_i$ 次，问最多拿几次石子。

将操作转化为从每堆石子中拿一个再选一堆放回去，二分操作次数 $x$，判断 $\max(0,x-d_i)$ 的和是否大于 $x$、$x-d_i$ 是否大于 $f_i$，均不成立则 $x$ 合法。最终二分出的值即为当前节点的 $f_u$ 的值。

最后判断 $f_1$ 是否不小于 $a_1$ 即可。

```cpp
#include "bits/stdc++.h"
#define int long long
#define rep(i,k,n) for(int i=k;i<=n;++i)
#define per(i,n,k) for(int i=n;i>=k;--i)
using namespace std;
template<typename T>
inline void read(T &x){
	x=0;int f=1;char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
	for(;isdigit(c);c=getchar()) x=(x<<3)+(x<<1)+(c-'0');
	x*=f;
}
const int N=1e6+10,INF=1e12;
int c,T;
int n,a[N],f[N];
vector<int> g[N];
bool ck(int u,int mid){
    int sum=0,sum2=0;
    for(auto v:g[u]){
        int need=max({0ll,mid-(a[u]-a[v])});
        if(need>f[v]) return 0;
        sum+=need;
    }
    return sum<=mid;
}
void dfs(int u){
    if(!g[u].size()){f[u]=INF;return;}
    int l=0,r=0;
    for(auto v:g[u]){dfs(v),r+=f[v];}
    while(l<=r){
        int mid=(l+r)>>1;
        if(ck(u,mid)) l=mid+1;
        else r=mid-1;
    }
    f[u]=r;
}
void solve(){
    read(n);
    rep(i,1,n) g[i].clear();
    rep(i,2,n){
        int fa;read(fa);
        g[fa].push_back(i);
    }
    rep(i,1,n) read(a[i]);
    rep(i,1,n) for(auto v:g[i]){
        if(a[i]<a[v]){printf("Shuiniao\n");return;}
    }
    dfs(1);
    if(f[1]<a[1]){printf("Shuiniao\n");return;}
    else{printf("Huoyu\n");return;}
}
signed main(){
    read(c);read(T);
    while(T--) solve();
	return 0;
}
```

---

## 作者：Albert_van (赞：6)

[题](https://www.luogu.com.cn/problem/P11189)。高妙转化题，但还是被物竞女队大佬（前？）一眼了，具备榜前实力。

首先两个操作无前置条件且互不影响，不妨把操作一（子树加）放到全部操作二（链减）之后。容易发现，仅通过操作一能够将点权清零的充要条件：$a_1\le 0$，且 $\forall u\ne 1,a_u\le a_{\operatorname{fa}(u)}$（以下称后者为性质 $2$）。若点权序列 $a$ 不满足性质 $2$，那么无论如何进行操作二，性质 $2$ 都得不到满足（$a_{\operatorname{fa}(u)}-a_u$ 不会增大）。因此，对初始状态判错后，问题转化为：在维持性质 $2$ 的前提下，是否可以通过操作二把 $a_1$ 扣到 $0$ 或更小。

记 $d_u=a_{\operatorname{fa}(u)}-a_u$。直观感受到，任意 $u$ 子树（在操作二以 $u$ 为根时）存在一个操作次数上限，超过它会使得性质 $2$ 被破坏。考虑 DP，记 $f_u$ 表示这个上限，注意可能取到 $+\infty$。既然是上限，就可以二分求 $f_u$，尝试判定 $f_u=k$ 是否合法。每次操作为，**选中** $u$ 的一个儿子 $v$，保持 $d_v$ 不动，令剩下所有儿子 $w$ 的 $d_w$ 减去 $1$，$f_u$ 即为保持所有 $d_v\ge 0$ 的最多操作次数。为了保证所有 $v$ 子树内的操作仍然合法，我们规定 $v$ 被**选中**的次数 $\le f_v$，显然充分。

判定合法性不难，可以把“$k$ 轮，每一轮选中一个 $v$”转化为“全体减去 $k$，然后 $k$ 次选中某个 $d_v$ 加上 $1$”，注意每个 $v$ 选中次数上限 $f_v$。那么令 $\Delta_v=|d_v-k|[d_v-k<0]$，要求即为 $\Delta_v\le f_v$ 且 $\sum \Delta_v\le k$。最终只需看是否有 $f_1\ge a_1$ 。复杂度 $\mathcal O(n\log a_i)$，注意 $+\infty$ 的处理、以及 $k$ 的上界为 $\sum f_v$ 即可。

```cpp
#include <cstdio>
#include <vector>
#define ll __int128

template<class tp>void re(tp &x){
	x=0;int c=getchar();bool f=0;
	while(c<'0'||c>'9') f|=c=='-',c=getchar();
	while(c>='0'&&c<='9') x=(x<<3)+(x<<1)+(c^48),c=getchar();
	if(f) x=-x;
}

const int N=114514;const ll inf=(ll)1e18;

std::vector<int> vc[N];

ll a[N]={inf},f[N];

void dfs(int u){
	if(vc[u].empty()) return f[u]=inf,void();
	ll l=0,r=0;for(int v:vc[u]){dfs(v);if((r+=f[v])>inf) r=inf;};
	while(l<=r){
		ll k=l+r>>1,s=0;bool flg=0;
		for(int v:vc[u]){
			ll d=-a[u]+a[v]+k;if(d>f[v]){flg=1;break;}
			if(d>0) s+=d;
		}
		flg||s>k?r=k-1:(f[u]=k,l=k+1);
	}
}

int fa[N];

int main()
{
	int akcsp,T;re(akcsp);re(T);while(T--){
		int n;re(n);for(int i=2;i<=n;++i) re(fa[i]),vc[fa[i]].push_back(i);
		bool flg=0;for(int i=1;i<=n;++i) re(a[i]),flg|=a[i]>a[fa[i]];
		if(flg) puts("Shuiniao");
		else dfs(1),puts(f[1]>=a[1]?"Huoyu":"Shuiniao");
		for(int i=1;i<=n;++i) vc[i].clear();
	}
}
```

---

## 作者：xieziheng (赞：6)

只能说场上这题没做出来是真的唐完了。

唯一没想到的就是第一步（）

考虑把每个点的权值变为 $a_x-a_{f_x}$，这样的话，条件可以从根节点一路递推一下，发现还是等价于所有点权值为 $0$。

操作一等价于选一个点权值加一。

操作二等价于选一条从叶子到根的路径对所有父亲在路径上且自己不在路径上的权值加一，根节点权值减一。

转化后的好处在于，发现除了根节点，别的节点权值不减，故开始一定小于零。

不妨先进行若干次操作二，然后进行操作一。等价于操作二做完后所有点权值都 $\leq 0$。即求操作二可以进行的最大次数。

下面我们将进行完操作二后每个节点的权值的绝对值记为 $a_x$。

将每个叶子操作次数视为一个变量，对于节点 $x$，记 $s_x$ 为其子树内所有叶子操作次数之和。注意到对于节点 $x,y$ 满足 $x$ 是 $y$ 的父亲，有 $-a_y+s_x-s_y\leq 0$，且 $s_x=\sum_{f_y=x} s_y$.

自然地，考虑设 $g_x$ 表示 $s_x$ 的最大值。合法等价于 $g_x\geq a_1$。

得到 $g_x$ 的限制：

- $g_x\leq \min_{f_y=x} a_y+g_y$

- $g_x\leq \sum_{f_y=x} g_y$

- $\sum_{f_y=x}\max\{0,g_x-a_y\}\leq g_x$

前两个直接做即可。后面那个二分，或者对 $a_y$ 排个序讨论一下都行。

代码非常好写。

---

## 作者：_Cheems (赞：6)

有趣的题目，考场想了个贪心但没敲，之后才发现可以二分。

显然和操作顺序没有关系，所以不妨将两个操作分开考虑。那么可以只通过子树加使得温度全 $0$，当且仅当 $\forall i,a_i\le a_{fa_i}$，这是因为父亲被加了儿子一定也被加；同时 $\forall i,a_i\le 0$，即 $a_1\le 0$。

再来考虑链减，$a_1$ 被减的次数等价于总共进行了多少次链减。不妨记 $w_i=a_{fa_i}-a_i$，每次链减会让所选路径上的所有点的相邻边（除了路径上的）都减一，我们要在 $w\ge 0$ 的情况下尽量多链减。

考虑 dp，记 $f_u$ 表示在 $u$ 子树内所有边都非负的情况下最多进行几次链减，记 $u$ 的儿子是 $v_1\dots v_m$，边权分别为 $w_1\dots w_m$。那么每个 $v_i$ 可以进行 $[0,f_{v_{i}}]$ 次操作，每次操作会导致 $\forall j\ne i,w_j-1$。

记 $b_i$ 表示 $v_i$ 进行几次操作，那么问题等价于满足 $b_i\in [0,f_{v_i}]$ 且 $\sum\limits_{j\ne i} b_j \le w_i$ 时最大化 $\sum b_i$。可以二分它，现在判定 $S=\sum b_i$ 是否可行，上面两条限制等价于 $\max(0,S-w_i)\le b_i\le f_{v_i}$，然后计算出 $\sum b_i$ 的取值范围，看看 $S$ 在不在里面就好。

#### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;

#define int long long
const int N = 1e5 + 5, inf = 1e13;
int n, fa[N], a[N], fl, T, f[N];
vector<int> to[N];

inline void dfs(int u){
	if(to[u].empty()) {f[u] = inf; return ;} 
	for(auto v : to[u]) dfs(v);
	
	int L = 0, R = inf, mid, fl, l, r;
	while(L + 1 < R){
		mid = L + R >> 1;
		
		fl = true;
		l = 0, r = 0;
		for(auto v : to[u]){
			int mi = max(0ll, mid - (a[u] - a[v]));
			if(mi > f[v]) {fl = false; break;}
			l += mi, r += f[v]; 
		}
		fl &= (l <= mid && mid <= r);
		
		if(fl) L = mid;
		else R = mid; 
	} 
	f[u] = L;
}
signed main(){
	cin >> T >> T;
	while(T--){
		scanf("%lld", &n), fl = true;
		for(int i = 1; i <= n; ++i) to[i].clear();
		for(int i = 2; i <= n; ++i) scanf("%lld", &fa[i]), to[fa[i]].push_back(i);
		for(int i = 1; i <= n; ++i){
			scanf("%lld", &a[i]);
			if(i > 1 && a[i] > a[fa[i]]) fl = false;
		}
		if(!fl) {puts("Shuiniao"); continue;}
		dfs(1);
		if(a[1] - f[1] <= 0) puts("Huoyu");
		else puts("Shuiniao");
	}
	return 0;
}
```

---

## 作者：vme50xiex2 (赞：6)

不妨钦定先执行所有操作 2。如何判定一个局面合法？设 $f_i$ 为 $i$ 执行完操作 2 后的权值，那么有 $f_i \le 0$ 且 $f_{fa(i)} \ge f_i$，构造就是从上往下执行操作 1。

设 $x_u$ 为 $u$ 的子树总共有几次操作 2。限制相当于 $x_u \ge a_u$ 和 $a_u - x_u \ge a_v - x_v$。

不难发现一棵树能执行的总操作次数是一个区间，因此设 $l_u$ 和 $r_u$ 表示操作次数的上下界，考虑转移。

比较显然的转移有 $\max(a_u, \sum l_v) \le l_u \le r_u \le \sum r_v$，现在只考虑 $a_u - x_u \ge a_v - x_v$ 这个限制。

我们不太好通过这个直接得出 $x_u$ 的范围，尝试枚举 $s = x_u$。

- 有 $a_u - s \ge a_v - x_v \ge a_v - r_v$，因此马上可以得到 $s \le a_u - a_v + r_v$。
- 有 $\sum \max(l_v,a_v - a_u + s) \le s$，因为要保证 $x_u$ 可以通过 $\sum x_v$ 得到。

前面的限制可以 $\mathrm{O}(1)$ 求，最后一个限制直接二分即可。无解就是存在 $l_u > r_u$。时间复杂度 $\mathrm{O}(n \log V)$。

注意过程中的值要时刻对 inf 取 min，否则可能会爆 long long。

### Code

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
const int N = 1e5 + 10;
const ll INF = 1e18;
int n, isOK;
ll a[N], l[N], r[N];
vector<int> G[N];
void Solve() {
	cin >> n;
	for(int i = 2, x; i <= n; ++i)
		cin >> x, G[x].push_back(i);
	for(int i = 1; i <= n; ++i)
		cin >> a[i];
	isOK = 1;
	for(int u = n; u >= 1; --u) {
		if(G[u].empty()) {
			l[u] = max((ll)0, a[u]), r[u] = INF;
			continue;
		}
		ll mn = INF;
		for(int v : G[u]) {
			l[u] = l[u] + l[v];
			r[u] = min(r[u] + r[v], INF);
			mn = min(mn, a[u] - a[v] + r[v]);
		}
		l[u] = max(l[u], a[u]);
		r[u] = min(r[u], mn);
		ll lef = l[u], rig = r[u], pos = l[u] - 1;
		while(lef <= rig) {
			ll mid = (lef + rig) / 2, sum = 0;
			for(int v : G[u]) {
				sum += max(l[v], mid - a[u] + a[v]);
				if(sum > mid) break;
			}
			if(sum <= mid) pos = mid, lef = mid + 1;
			else rig = mid - 1;
		}
		r[u] = pos;
		if(l[u] > r[u]) {
			isOK = 0; break;
		}
	}
	if(isOK) printf("Huoyu\n");
	else printf("Shuiniao\n");
	for(int i = 1; i <= n; ++i)
		l[i] = r[i] = 0, G[i].resize(0);
}
int main() {
	cin.tie(0)->sync_with_stdio(0);
	int id, t; cin >> id >> t;
	while(t--) Solve();
	return 0;
}
```

---

## 作者：modfish_ (赞：3)

## 思路
让我们思考：如果只有操作二，什么样的树才是合法的？

容易发现，由于叶子结点的权值只能通过操作它自己来改变，所以我们必定会对每个叶子 $v$ 操作 $a_v$ 次（当然如果 $a_v<0$ 就无解了）。那么，结点 $x$ 被减 $1$ 的次数就是 $\sum_{v\in sub(x)}a_v$，其中 $sub(x)$ 表示 $x$ 子树内所有点的集合，$v$ 是叶子结点。

不难发现，这等价于 $a_x=\sum_{j\in son(x)}a_j$，其中 $son(x)$ 是结点 $x$ 的儿子集合。

所以，问题转化成了：进行若干次子树加 $1$ 操作，能否使得这棵树的点权满足：每个点的点权等于其所有儿子点权之和。

这个问题听上去很简洁，但判断起来似乎又没那么简单。

首先，我们很容易能想出一种无解的情况：如果 $a_x<\sum_{j\in son(x)}a_j$，那么一定无解。因为此时，如果对儿子进行操作，只会使 $\sum_{j\in son(x)}a_j$ 变得更大；如果对 $x$ 进行操作，因为 $\lvert son(x)\rvert\ge 1$，所以不等号右边的增量不会比左边小，所以永远不可能满足条件。

然而，这并不能帮到我们太多。但这启示我们：对儿子的操作会影响父亲，所以，直接判断对某个点的操作次数是不现实的。

不妨记 $l_x,r_x$ 表示如果要使 $x$ 的子树满足条件，对 $x$ 结点**及其祖先**（因为对祖先操作也会使 $x$ 的子树加 $1$）进行操作次数的上界和下界。对于叶子结点，显然有 $l_v=\max(-a_v,0),r_v=+\infty$。

然后考虑转移。若已知 $x$ 的每个儿子 $j$ 的 $l_j,r_j$，如何求出 $l_x,r_x$ 呢？

当 $\lvert son(x)\rvert=1$ 时，显然，必须对儿子操作 $a_x-a_j$ 次（前文已提及，$a_x<a_j$ 是无解的）。那么，应有 $l_x=\max(l_j-(a_x-a_j),0),r_x=r_j-(a_x-a_j)$（因为已经用掉了 $a_x-a_j$ 次操作）。此时，若 $r_x<0$，说明能用的操作已经用尽了，此时 $j$ 的子树内已不合法了，所以无解。

当 $\lvert son(x)\rvert>1$ 时，假设对 $x$ 及其祖先进行 $y$ 次操作，则显然有 $y\le\min_{j\in son(x)}r_j$。此外，应满足：

- 如果对每个 $j$ 都对其祖先操作 $\max(l_j,y)$ 次，那么应满足 $a_x\ge\sum_{j\in son(x)}a_j$。

- 如果对每个 $j$ 都对其祖先操作 $r_j$ 次，那么应满足 $a_x\le\sum_{j\in son(x)}a_j$。

这是因为 $y$ 固定时，$a_x$ 时固定的。对 $j$ 操作得越多，不等号右边就越大。所以，当对 $j$ 的操作次数达到下界时，结果不应比 $a_x$ 大；同理，对 $j$ 的操作次数达到上界时，结果不应比 $a_x$ 小。

于是，列出不等式：

$$\sum_{j\in son(x)}(a_j+\max(l_j,y))\le a_x+y$$

$$\sum_{j\in son(x)}(a_j+r_j)\ge a_x+y$$

对于下面的式子，容易得出 $y\le\sum_{j\in son(x)}(a_j+r_j)-a_x$，这是 $r_x$ 的一个可能值。

而上面的式子就不好处理了。怎么办？

令 $f(y)=\sum_{j\in son(x)}(a_j+\max(l_j,y))-y$。不难发现，$f(y)$ 是一个分了若干段的一次函数。其中，当且仅当 $y<\min_{j\in son(x)}l_j$ 时，$f(y)$ 是递减的（因为 $y>\min_{j\in son(x)}l_j$ 时，左边的求和式中能拆出至少一个 $y$，此时函数的斜率非负）。所以，对左右两部分分别二分出临界点的 $y$ 即可。此时，记左临界点为 $L$，右临界点为 $R$，则：

$$l_x=\max(L,0)$$

$$r_x=\min(\min_{j\in son(x)}r_j,\sum_{j\in son(x)}(a_j+r_j)-a_x,R)$$

于是我们完成了 $l_x,r_x$ 的转移。如果存在某个点使得 $l_x>r_x$，说明无解。

时间复杂度 $O(n\log V)$，其中 $V$ 为值域。

## 代码

```cpp
#include <bits/stdc++.h>
#define ll long long

using namespace std;

const int maxn = 2e5 + 5;

int head[maxn], nxt[maxn], to[maxn], cnt = 0;
ll a[maxn], l[maxn], r[maxn];

inline ll read(){
	ll x = 0, f = 1;
	char c = getchar();
	while(!isdigit(c)){
		if(c == '-') f = -1;
		c = getchar();
	}
	while(isdigit(c)) x = (x << 3) + (x << 1) + (c ^ 48), c = getchar();
	return x * f;
}
void match(int u, int v){
	nxt[++ cnt] = head[u], to[cnt] = v, head[u] = cnt;
}
bool check(int x, ll y){
	ll ans = 0;
	for(int i = head[x]; i; i = nxt[i]){
		int j = to[i];
		ans += max(l[j], y) + a[j];
	}
	return ans - y <= a[x];
}
bool dfs(int x){
	ll s = 0, sa = 0, ml = (ll)1e17, sl = 0, mr = (ll)1e17, sr = 0;
	for(int i = head[x]; i; i = nxt[i]){
		int j = to[i];
		if(!dfs(j)) return false;
		sa += a[j], ml = min(ml, l[j]), sl += l[j], mr = min(mr, r[j]), sr += r[j];
		sr = min(sr, (ll)1e17);
		s ++;
	}
	if(!s){
		l[x] = max(-a[x], 0ll), r[x] = (ll)1e17;
		return true;
	}
	if(s == 1){
		if(a[x] < sa) return false;
		int j = to[head[x]];
		l[x] = max(l[j] - (a[x] - a[j]), 0ll), r[x] = r[j] - (a[x] - a[j]);
		if(r[x] < l[x]) return false;
		return true;
	}
	if(a[x] < sa) return false;
	r[x] = min(min(mr, sa + sr - a[x]), (ll)1e17);
	ll l1 = 0, r1 = ml, res = (ll)1e18 + 114514;
	while(l1 <= r1){
		ll mid = l1 + r1 >> 1;
		if(check(x, mid)) r1 = mid - 1, res = mid;
		else l1 = mid + 1;
	}
	l[x] = res; 
	l1 = ml, r1 = (ll)1e17, res = -1;
	while(l1 <= r1){
		ll mid = l1 + r1 >> 1;
		if(check(x, mid)) l1 = mid + 1, res = mid;
		else r1 = mid - 1;
	}
	r[x] = min(r[x], res);
	if(r[x] < l[x]) return false;
	return true;
}

int main(){
	int cid = read(), T = read();
	while(T --){
		int n = read();
		for(int i = 2; i <= n; i ++){
			int f = read();
			match(f, i);
		}
		for(int i = 1; i <= n; i ++) a[i] = read();
		if(dfs(1)) printf("Huoyu\n");
		else printf("Shuiniao\n");
		for(int i = 1; i <= n; i ++) head[i] = 0;
		for(int i = 1; i <= cnt; i ++) nxt[i] = to[i] = 0;
		cnt = 0;
	}
	return 0;
}
```
请注意正无穷的值不要取太小，并且在对 $r_j$ 求和时，时刻对正无穷取最小值，否则会超出 $64$ 位整数的存储范围。

---

## 作者：vegetable_king (赞：3)

[可能更好的阅读体验](https://yjh965.github.io/post/p11189-kdoi-10-shui-bei-jiang-wen-ti-jie/)

好题。

以下将操作一改为子树 $-1$，操作二改为链 $+1$，$a_i$ 取反。

两个操作之间是独立的，我们考虑先搞出只使用其中一种操作就能归零的一个条件，然后再用另外一种操作去达成这个条件。

那么显然只使用操作一就能归零的条件是 $\forall 2 \le i \le n, a_i \ge a_{fa_i}$ 且 $a_1 \ge 0$。

我们将这两个条件分开来看。操作二对第一个条件 $a_i \ge a_{fa_i}$ 的影响是给 $a_i - a_{fa_i}$ 减去一个非负整数，这是不优的；而其对第二个条件的影响是给 $a_1$ 加一，这是不劣的。

所以第一个条件如果初始不满足，那么一定无解。现在我们的目标就是在不违反第一个条件的情况下尽可能多的操作。

那么我们可以 dp，设 $f_u$ 表示 $u$ 子树内最大的操作次数，那么 $f_1 + a_1 \ge 0$ 是有解的充要条件。转移也是简单的，我们二分 $f_u$，则 $f_u$ 合法的条件是：

- $\sum_v \max(a_u + f_u - a_v, 0) \le f_u$；

- 若 $u$ 不是叶子，则 $f_u \le \sum_v f_v$。

正确性显然。那么这个题就做完了，总时间复杂度为 $O(\sum n \log v)$。

[代码](https://www.luogu.com.cn/paste/x8md1l7x)。

---

## 作者：sunkuangzheng (赞：2)

$\textbf{Lemma 1}$：如果存在 $a_u > a_{fa_u}$ 则一定无解。

- Proof：设 $f_u$ 是 $u$ 这个点最终权值增加了多少，子树加、到根链减两种操作都会使得 $f_u \ge f_{fa_u}$。

以下称树合法，当且仅当 $\forall u \in [2,n],a_u \le a_{fa_u}$。

$\textbf{Lemma 2}$：如果树合法且 $a_1 \le 0$，则一定有解。
- Proof：直接从下往上把每个点的权值都变成其父亲即可。

结合以上两条观察，我们只需要用若干次 2 操作，在始终保证合法的情况下将根的权值减到非正数即有解。

不难注意到减法操作对合法性的影响是单调的，即多做一次链减只可能让树从合法变成不合法，而不可能让树从不合法变成合法。

考虑设计一个 DP，设 $dp_u$ 表示 $u$ 子树内最多进行的链减操作数是多少，则有解当且仅当 $dp_1 \ge a_1$。叶子节点有 $dp_u = \inf$。

$\textbf{Lemma 3}$：对于任意节点 $u$，做链减时会优先选择 $a_v$ 最大的儿子 $v$。
- Proof：调整法。

由于 $a_i$ 高达 $10^{12}$，暴力的每次选一条链减 $1$ 肯定不可取。考虑动态维护最大的 $a_v$ 集合 $S$，每次给这个集合里所有 $a_v$ 减 $1$。$S$ 发生变化有这几种可能情况：

- $a_v$ 减到了比不在 $S$ 中的 $a_v'$ 还小。
- $S$ 中的某个 $v$ 的 $dp_v$ 值不够减了。
- $a_u$ 的值不够减了。

用堆维护 $S$ 的 $dp$ 值，每次二分出减多少次会使得 $S$ 发生变化。$u$ 的每个儿子只会出入堆一次，故总的时间复杂度为 $\mathcal O(n \log n)$。

```cpp
/**
 *    author: sunkuangzheng
 *    created: 13.10.2024 15:14:54
**/
#include<bits/stdc++.h>
#ifdef DEBUG_LOCAL
#include <mydebug/debug.h>
#endif
using ll = long long;
const int N = 5e5+5;
const ll inf = 1e13;
using namespace std;
int T,n,fa[N],C; vector<int> g[N]; ll a[N],dp[N];
void dfs(int u){
    if(!g[u].size()) return dp[u] = inf,void();
    for(int v : g[u]) if(dfs(v),dp[v] == -inf) dp[u] = -inf;
    if(dp[u] == -inf) return ;
    sort(g[u].begin(),g[u].end(),[&](int x,int y){return a[x] > a[y];});
    if(a[g[u][0]] > a[u]) return dp[u] = -inf,void();
    int m = g[u].size(),ct = 1,p = 1; ll Mx = -inf,val = a[u],now = a[g[u][0]];
    priority_queue<ll,vector<ll>,greater<ll>> q; q.push(dp[g[u][0]]); ll tg = 0;
    while(ct){
        ll nxt = (p == m ? -inf : a[g[u][p]]); 
        ll l = 0,mx = max(Mx,nxt),r = val - mx;
        while(l <= r){
            ll mid = (l + r) / 2;
            auto ck = [&](ll x){return val - x  >= now - x / ct && (x + ct - 1) / ct <= q.top() - tg 
                && x <= val - mx && now - (x + ct - 1) / ct >= nxt;};
            if(ck(mid)) l = mid + 1; else r = mid - 1;
        }l --;
        if(l < ct){
            if(p != m && l == 0 && nxt == now) ct ++,q.push(dp[g[u][p]] + tg),p ++;
            else if(l == 0 && q.top() - tg == 0){
                Mx = max(Mx,now),q.pop(),ct --;
                if(ct == 0){
                    if(p != m) ct ++,q.push(dp[g[u][p]] + tg),now = a[g[u][p ++]];
                    else return ;
                }
            }else{
                ll sm = 0;
                while(q.size()) sm += q.top() - tg,q.pop();
                dp[u] += min(sm,l); return ;
            }
        }else{
            l = l / ct * ct;
            dp[u] += l,val -= l,tg += l / ct,now -= l / ct;
        }
    }
}void los(){
    cin >> n;
    for(int i = 1;i <= n;i ++) g[i].clear();
    for(int i = 2;i <= n; i++) cin >> fa[i],g[fa[i]].push_back(i);
    for(int i = 1;i <= n;i ++) cin >> a[i],dp[i] = 0;
    dfs(1);
    cout << (dp[1] < a[1] ? "Shuiniao\n" : "Huoyu\n");
    // printarr(1,n,dp);
}int main(){
    ios::sync_with_stdio(0),cin.tie(0);
    for(cin >> C >> T;T --;) los();
}
```

---

## 作者：critnos (赞：2)

水题解/se

为了看着方便不妨把 $a$ 取反，然后操作 $1$ 变成减 $1$ 操作 $2$ 变成加 $1$。那么仅考虑操作 $1$ 能清空怎样的 $a$？显然是 $a_1 \ge 0$ 然后 $\forall 1<i\le n,a_{f_i}\le a_i$。进行操作 $2$ 只会破坏条件 $2$，所以不难想到一个树形 dp：$dp_i$ 表示求子树中最多能进行几次操作 $2$。然后判定 $a_1+dp_1 \ge 0$ 即可。

考虑如何转移，相当于要给 $i$ 的每个儿子 $v$ 的子树选择一个操作次数 $c_v \in [0,dp_v]$，需要满足 $a_i+\sum_{u\in son_i \land u\neq v} c_u \le a_v$，然后最大化 $\sum c_v$。稍微把式子变形一下，那么是容易二分 $\sum c_v$ 的。时间复杂度 $O(n\log v)$。

---

## 作者：strcmp (赞：2)

操作之间满足交换律是非常重要的性质。

这意味着我们可以任意决定当前要做什么类型的操作。

考虑把子树加操作放到后面，链减放到前面。

子树加什么时候能给树全部变成 $0$。当且仅当 $\forall a_u \le 0 \wedge a_{fa_u} \ge a_{u}$。

考虑链减如何把原树变成这样。

注意到链减不改变父亲到儿子的差分，所以如果初始有 $a_{fa_u} > a_u$ 那就只能输出 `Shuiniao` 了。

判掉，现在的限制只是根结点必须 $\le 0$。

注意到根结点的值是原值减去所有链减操作执行的次数。

设 $f_u$ 代表 $u$ 子树内最多进行 $f_u$ 次链减。

限制变为：

$$
\begin{aligned}
& v \in \text{subtree}(u) \\
& a_u - \sum g \ge a_v - g_v,\,0 \le g_v \le f_v \\
& f_u \leftarrow \sum g
\end{aligned}
$$

注意到 $f_u$ 的取值合法性必然是 $1111\dots10\dots0000$ 的形式的。

所以二分 $f_u$ 的值（也就是 $\sum g$），然后贪心判定即可。

时间复杂度 $\Theta(n \log n)$，可以通过。

```cpp
#include <bits/stdc++.h>
#define X first
#define Y second
#define rep(i, a, b) for (int i = a; i <= b; i++)
#define per(i, a, b) for (int i = a; i >= b; i--)
#define pb push_back
using namespace std;
typedef long long int ll;
using ull = unsigned long long int;
using pll = pair<ll, ll>;
const int maxn = 2e5 + 10, mod = 1e9 + 7; 
int C, T, n, fg; ll a[maxn], f[maxn]; vector<int> g[maxn];
inline int ck(int u, ll mid) {
    ll w = 0;
    for (int v : g[u]) w += max(a[v] + mid - a[u], 0LL);
    if (w > mid) return 0; w = 0;
    for (int v : g[u]) if (a[u] - mid < a[v] - f[v]) return 0; 
    return 1;
}
void dfs(int u, int fa) {
    f[u] = 1e13; 
    if (!fg || g[u].empty()) return; 
    ll l = 0, r = 0;
    for (int v : g[u]) dfs(v, u), r += f[v];
    while (l <= r) {
        ll mid = l + r >> 1;
        if (ck(u, mid)) l = mid + 1;
        else r = mid - 1;
    }
    f[u] = l - 1;
    if (f[u] < 0) fg = 0;
}
int main() {
    scanf("%d%d", &C, &T);
    while (T--) {
        scanf("%d", &n); int x;
        rep(i, 2, n) scanf("%d", &x), g[x].pb(i);
        rep(i, 1, n) scanf("%lld", &a[i]);
        fg = 1; dfs(1, 0);
        puts((fg && f[1] >= a[1]) ? "Huoyu" : "Shuiniao");
        rep(i, 1, n) g[i].clear(), f[i] = 0;
    }
    return 0;
}
```

---

## 作者：sbno333 (赞：2)

我们考虑只有一种操作的时候怎么做。

我这里用的是操作一。

首先所有数必须非正，否则无解。

然后父亲必须非严格大于儿子，因为父亲加，儿子必定加，反之则不是，为了让二者相等，所以需要父亲非严格大于儿子。

这是后考虑证明存在操作。

考虑数学归纳法，证明一个满足条件的树可以让所有节点都和根一个值。

一个节点显然。

对于一个树，我们先对于其儿子的子树进行操作，然后再分别对于每个儿子子树加到和根一样，证毕。

发现操作具有交换律，所以我们先进行操作二，在进行操作一。

我们问题变成了进行若干次操作二，使得这棵树非正且父亲非严格大于儿子。

考虑树上 DP 的思想。

我们在操作时发现儿子操作了，父亲必定操作。

我们考虑对于儿子子树都完成了操作使得符合条件的情况下操作次数最小，因为多了就不容易在父亲的转移与判定中成功了。

此时我们记录总的操作次数，然后让当前节点减去。

如果此时根已经比一个儿子小了，报告无解，因为之后无论怎么操作，我们都无法挽回。

如果当前根比 $0$ 大，就考虑进行若干次操作变为 $0$。

然后这些操作在根后进行后要分给儿子子树进行。

我们可以证明一个子树合法所需要的操作次数为一个区间，在进行最少此操作后，满足均非正，之后也不会影响。

然后一直操作，如果发现儿子不得已大于父亲，之后也无法挽回，得证。

我们发现要分给儿子子树查看是否能分就要维护最多操作次数。

考虑已经知道了最少。

最多操作次数有可能正无穷，当且仅当只有一个儿子且也是最多为正无穷，否则早晚会导致根迫不得已比儿子小。

然后对于非无穷的情况，我们可以二分。

左边界为最少操作次数，右边界为儿子操作次数之和（如果有正无穷，这里要特别注意右边界是一个极大值），这样判定时不用担心儿子分不完操作。

判定首先让根减去操作次数。

然后每个儿子要保证小于等于根，同时满足在操作次数区间，看操作是否还够分，不够分报告判定失败，如果能分就判定成功。

时间复杂度 $O(n\log(\max a_i))$。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int fa[100009];
struct st{
	int v,ne;
}sd[100009];
int h[100009];
int inn;
void add(int u,int v){
	sd[++inn].v=v;
	sd[inn].ne=h[u];
	h[u]=inn;
}
int a[100009];
int n;
int l[100009];
int r[100009];
bool check(int x,int t){
	int z;
	z=a[t]-x;
	for(int i=h[t];i;i=sd[i].ne){
		x-=max(l[sd[i].v],a[sd[i].v]-z);
		if(a[sd[i].v]-z>r[sd[i].v]){
			return 0;
		}
	}
	return (x<0?0:1);
}
void dfs(int t){
	if(!h[t]){
		l[t]=max(a[t],0ll);
		r[t]=1e18;
		return;
	}
	int sum;
	sum=0;
	for(int i=h[t];i;i=sd[i].ne){
		dfs(sd[i].v);
		if(l[sd[i].v]==1e18){
			l[t]=1e18;
			return;
		}
		sum+=l[sd[i].v];
	}
	int p;
	p=a[t];
	p-=sum;
	if(p>0){
		for(int i=h[t];i;i=sd[i].ne){
			if(r[sd[i].v]==1e18){
				p=0;
				break;
			}
			p-=r[sd[i].v]-l[sd[i].v];
		}
		if(p>0){
			l[t]=1e18;
			return;
		}
		p=0;
	}
	for(int i=h[t];i;i=sd[i].ne){
		if(p<a[sd[i].v]-l[sd[i].v]){
			l[t]=1e18;
			return;
		}
	}
	l[t]=a[t]-p;
	if(r[sd[h[t]].v]==1e18&&!sd[h[t]].ne){
		r[t]=1e18;
		return;
	}
	int ss;
	ss=0;
	for(int i=h[t];i;i=sd[i].ne){
		ss+=r[sd[i].v];
		if(ss>=1e18){
			ss=1e18;
		}
	}
	int ll,rr;
	ll=l[t],rr=ss;
	while(ll<rr){
		int mid;
		mid=ll+rr+1;
		mid>>=1;
		if(check(mid,t)){
			ll=mid;
		}else{
			rr=mid-1;
		}
	}
	r[t]=ll;
}
void _main(){
	cin>>n;
	inn=0;
	for(int i=0;i<=n+3;i++){
		h[i]=0;
		l[i]=r[i]=a[i]=fa[i]=0;
	}
	for(int i=2;i<=n;i++){
		cin>>fa[i];
		add(fa[i],i);
	}
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	dfs(1);
	cout<<(l[1]==1e18?"Shuiniao":"Huoyu")<<endl;
}
signed main(){
	int c,t;
	cin>>c>>t;
	while(t--){
		_main();
	}
	return 0;
}
```

---

## 作者：luckydrawbox (赞：0)

[$\text{Link}$](https://www.luogu.com.cn/problem/P11189)

## 题意

给出一棵 $n$ 个节点的树，根节点为 $1$，节点 $i$ 有一个点权 $a_i$。你可以对这棵树进行如下操作：

1. 将节点 $i$ 的子树内的所有点点权增加 $1$。
1. 选择一个叶子 $i$，将 $i$ 到根节点的链上所有点的点权减少 $1$。

求是否能进行若干次操作，使整个树的点权全为 $0$。

## 分析

点权全为 $0$ 等价于根节点点权为 $0$，且任意一个非根节点与其父节点的差为 $0$；再结合操作修改时同时被修改的点之间的差不变，可以考虑从差分的角度分析操作。

令 $b_i=a_{fa_i}-a_i(2\le i\le n)$，那么一次操作 $1$ 相当于将 $b_i$ 减 $1$，若 $i$ 为 $1$ 则使 $a_1+1$，操作 $2$ 相当于将链上所有点的不在链上的儿子的 $b_i$ 减 $1$，同时使 $a_1$ 减 $1$。也就是说差分数组只会减小！由于最后 $b_i=0$，所以若开始时存在 $b_i<0$，则无解。

在满足 $b_i\ge 0$ 的情况下：

1. $a_1\le 0$，那么我们完全可以只用 $1$ 操作把 $a_1$ 增加到 $0$，再用操作 $1$ 把所有的 $b_i$ 变为 $0$ 即可。
1. $a_1>0$，则必须用若干 $2$ 操作将 $a_1$ 减小到非正数，同时保证 $b_i$ 非负。

考虑到交换操作顺序不影响答案，我们钦定所有 $2$ 操作在 $1$ 操作之前，这样问题就变成能否通过若干次操作 $2$ 使树满足情况 $1$ 的前置条件。

由于有 $b_i$ 的限制，我们能进行的操作 $2$ 的次数必然有上限，于是我们考虑求出这个上限 $m$，判断是否 $a_1\le m$ 即可，

设 $f_i$ 表示节点 $i$ 的子树内能进行的操作 $2$ 的最大次数，若 $i$ 为叶节点，显然 $f_i=+\infty$，否则，二分出 $f_i$。具体地，二分答案为 $val$，对于每个儿子 $j$，我们先执行 $d_j=\min\{f_j,\max\{val-b_j,0\}\}$ 次 $2$ 操作，即在保证 $b_j-(val-d_j)\ge 0$ 的情况下执行尽可能少的操作，$val-d_j$ 是其他儿子执行操作对 $b_j$ 的影响，若某个 $b_j$ 执行后不满足条件，或总执行次数超过了 $val$，则无解。否则，我们分配剩下的操作，随便地给 $f_j> d_j$ 的 $j$ 分配次数，能分配完则有解。这样的贪心策略正确性显然。

最终时间复杂度 $O(n\log V)$，$V$ 为值域。

## 代码

考场代码，有一些无用的片段，请自动忽略。

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
long long read(){
	long long x=0,f=1;char ch=getchar();
	while(!isdigit(ch))
	{if(ch=='-') f=-1;ch=getchar();}
	while(isdigit(ch)){x=x*10+ch-48;ch=getchar();}
	return x*f;
}
void write(long long x){
    if(x<0) putchar('-'),x=-x;
    if(x>9) write(x/10);
    putchar(x%10+'0');
}
const int N=1e5+10;
int C,T,n;
int head[N],ver[N<<1],nxt[N<<1],tot,fa[N];
void add(int x,int y){
	ver[++tot]=y,nxt[tot]=head[x],head[x]=tot;
}
ll a[N],f[N],b[N],d[N];
int id[N];
bool check(int ti,ll val,int x){
	ll v=val;
	for(int i=1;i<=ti;i++){
		b[i]=a[x]-a[id[i]];
		d[i]=min(f[id[i]],max(val-b[i],0ll));
		if(b[i]+d[i]<val)return 0;
		v-=d[i];b[i]+=d[i];
		if(v<0)return 0;
	}
	for(int i=1;i<=ti;i++){
		ll e=min(f[id[i]]-d[i],v);
		v-=e;
	}
	if(v!=0)return 0;
	return 1;
}
void dfs(int x){
	for(int i=head[x];i;i=nxt[i]){
		int y=ver[i];
		dfs(y);
	}
	int ti=0;
	for(int i=head[x];i;i=nxt[i])
		id[++ti]=ver[i];
	if(!ti)f[x]=2e12+1;
	else if(ti==1){
		f[x]=f[id[ti]];
	}
	else{
		ll l=0,r=0;
		//printf("x=%d\nid:",x);
		for(int i=1;i<=ti;i++){
			//printf("%d ",id[i]);
			r+=f[id[i]];
			r=min(r,(ll)(2e12+1));
		}
		while(l<r){
			ll mid=(l+r+1)>>1;
			if(check(ti,mid,x)){
				l=mid;
			}
			else r=mid-1;
		}
		f[x]=l;
	}
	//printf("f[%d]=%lld\n",x,f[x]);
}
void solve(){
	for(int i=2;i<=n;i++)
		if(a[fa[i]]<a[i]){
			puts("Shuiniao");return;
		}
	dfs(1);
	if(a[1]-f[1]<=0)puts("Huoyu");
	else puts("Shuiniao");
}
int main(){
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	C=read();T=read();
	while(T--){
		n=read();
		tot=0;
		for(int i=1;i<=n;i++)head[i]=0;
		for(int i=2;i<=n;i++)
			add(fa[i]=read(),i);
		for(int i=1;i<=n;i++)
			a[i]=read();
		solve();
	}
	return 0;
}
```

---


# 【MX-S6-T3】「KDOI-11」简单的字符串问题 2

## 题目背景

原题链接：<https://oier.team/problems/S6C>。

## 题目描述

给定 $n$ 个字符串 $S_1, \ldots, S_n$ 以及一个字符串 $T$。

对于一个字符串 $R$，定义 $|R|$ 表示 $R$ 的长度、$R_{[l,r]}$ 表示 $R$ 的第 $l\sim r$ 个字符组成的字符串。字符串 $R'$ 是字符串 $R$ 的前缀当且仅当存在 $1\leq p\leq |R|$ 且 $p$ 为整数使得 $R'=R_{[1,p]}$。

定义一个字符串 $R$ 是**好的**当且仅当它是某个 $S_i$ 的前缀**或** $R$ **为空**。

对于若干字符串 $R_1,R_2,\dots,R_k$，定义 $R_1+R_2+\dots+R_k$ 为 $R_1,R_2,\dots,R_k$ 顺次拼接得到的字符串。

定义一个三元组 $(l,r,k)$（$l,r,k$ 均为整数）是好的当且仅当 $1\leq l\leq r\leq|T|$，$1\leq k\leq K$ 且存在 $k$ 个**好的**字符串 $R_1,R_2,\dots,R_k$ 使得 $R_1+R_2+\dots+R_k=T_{[l,r]}$。

请你求出好的三元组的数量，并对于每个 $i$ 求出有多少好的三元组 $(l,r,k)$ 满足 $l\leq i\leq r$。如果你只能求出两者中其一，也可以获得部分分数，见【**输出格式**】。

## 说明/提示

**【样例解释 #1】**

符合要求的 $(l,r,k)$ 有以下 $13$ 组：

* $(1,1,1)$；
* $(1,1,2)$；
* $(1,2,1)$；
* $(1,2,2)$；
* $(1,3,2)$；
* $(3,3,1)$；
* $(3,3,2)$；
* $(3,4,2)$；
* $(3,5,2)$；
* $(4,4,1)$；
* $(4,4,2)$；
* $(4,5,1)$；
* $(4,5,2)$。

**【样例 #4】**

见附件中的 `string/string4.in` 与 `string/string4.ans`。

该组样例满足测试点 $1\sim3$ 的约束条件。

**【样例 #5】**

见附件中的 `string/string5.in` 与 `string/string5.ans`。

该组样例满足测试点 $4\sim6$ 的约束条件。

**【样例 #6】**

见附件中的 `string/string6.in` 与 `string/string6.ans`。

该组样例满足测试点 $7\sim10$ 的约束条件。

**【样例 #7】**

见附件中的 `string/string7.in` 与 `string/string7.ans`。

该组样例满足测试点 $13\sim14$ 和测试点 $16\sim17$ 的约束条件。

**【样例 #8】**

见附件中的 `string/string8.in` 与 `string/string8.ans`。

该组样例满足测试点 $18\sim20$ 的约束条件。

**【数据范围】**

对于所有测试数据，保证：$1\leq n\leq10$，$1\leq |S_i|\leq5\times10^4$，$1\leq |T|,K\leq5\times10^5$，字符串仅包含小写英文字母 $\texttt{a}\sim\texttt{z}$。

| 测试点编号 | $n\leq$ | $\lvert S_i\rvert\leq$ |  $\lvert T\rvert\leq$ | $K\leq$ | 特殊性质 |
|:--:|:--:|:--:|:--:|:--:|:--:|
| $1\sim3$ | $10$ | $50$ | $50$ | $50$ | 无 |
| $4\sim6$ | $10$ | $100$ | $300$ | $300$ | 无 |
| $7\sim10$ | $10$ | $1000$ | $5000$ | $5000$ | 无 |
| $11\sim12$ | $10$ | $5\times10^4$ | $5\times10^5$ | $1$ | 无 |
| $13\sim14$ | $10$ | $5\times10^4$ | $5\times10^5$ | $10$ | 无 |
| $15$ | $10$ | $5\times10^4$ | $5\times10^5$ | $5\times10^5$ | 所有字符均为 $\texttt{a}$ |
| $16\sim17$ | $10$ | $5\times10^4$ | $5\times10^5$ | $5\times10^5$ | 所有字符在 $\{\texttt{a},\texttt{b}\}$ 中独立均匀随机生成 |
| $18\sim20$ | $10$ | $5\times10^4$ | $5\times10^5$ | $5\times10^5$ | 无 |

## 样例 #1

### 输入

```
0 1 2
ab
abaab```

### 输出

```
13
5 3 5 6 3```

## 样例 #2

### 输入

```
0 3 2
abc
ac
b
bacabcab```

### 输出

```
27
4 9 6 11 10 5 6 5```

## 样例 #3

### 输入

```
0 10 10
wooogpgpoo
owpwgwwp
ooogpgpooo
gppwppgwoo
wooogpgpoo
wowooogpgp
gwwp
ggggogwgpp
wowooogpgp
pgpoooowpw
pgwgwggggggogwgppwppgwooggoogwowooogpgpoooowpwgwwp```

### 输出

```
7698
183 390 577 792 990 1213 1422 1651 1780 1889 1984 2099 2235 2355 2491 2458 2435 2426 2439 2466 2478 2498 2503 2489 2481 2477 2477 2483 2491 2527 2532 2559 2571 2540 2489 2433 2372 2276 2163 2041 1932 1803 1662 1491 1308 1111 900 702 486 252```

# 题解

## 作者：RainWetPeopleStart (赞：20)

赛时 70pts 没调完，最后只写了 50pts。

**下文中 $T_{[a,a-1]}$ 表示空串**（其中 $T$ 是字符串，$a\le|T|$）。

这里稍微改一下前缀的定义（为方便叙述）：

字符串 $R'$ 是字符串 $R$ 的前缀当且仅当存在 $\color{red}{0\le p\le|R|}$ 且 $p$ 为整数使得 $R'=R_{[1,p]}$。

### 15pts

首先，发现三元组的个数是 $O(|T|^2K)$ 的，考虑暴力枚举三元组，但此时不好 chk。

那如何 chk 呢。考虑 DP，设 $f_{l,r,k}$ 表示 $(l,r,k)$ 是否合法，转移时枚举新加的串的位置即可，复杂度 $O(n^4)$。（不过这个东西貌似可以bitset优化，可能能过 30）

### 30pts

发现一个状态表示一个 bool 十分浪费，考虑优化。发现若 $f_{l,r,k}$ 合法，则可以通过添加空串的方式使 $f_{l,r,k+1}$ 合法，可以设 $f_{l,r}$ 表示使 $(l,r,k)$ 合法的最小 $k$ 值，就有转移 $f_{l,r}=\min_{l<i\le r+1}(f_{i,r})+1$（要求 $T_{[l,i-1]}$是某个 $S_i$ 的前缀）。

判断前缀可以使用哈希，复杂度 $O(n|T|^3)$，用 trie 则为 $O(|T|^3)$。（实际上加剪枝后在原题数据中可以拿 50pts）

### 50pts

考虑优化转移，上文中合法的 $i$ 构成了一段区间，此时可以预处理出 $to_i$ 表示最大的 $j$ 使 $T_{[i,j]}$ 是某个 $S_i$ 的前缀（因为 $T_{[i,i-1]}$ 是空串，故 $j$ 一定存在）。

此时 $i$ 的上界为 $\min(to_l,r)+1$。由于对查 $f_{i,r}$ 而言，左端点是递减的，可以使用单调栈上二分，复杂度 $O(|T|^2\log|T|)$。

### 70pts

此时状态数会炸，考虑将状态与 $K$ 挂钩。

发现对于 $l,k$ 来说，使 $(l,r,k)$ 合法的 $r$ 构成一段区间，考虑交换状态和答案，记 $f_{l,k}$ 表示使 $(l,r,k)$ 合法的最大的 $r$。

转移如下：

$f_{l,k}=\max_{l\le i\le f_{l,k-1}+1}(f_{i,1})$。

其中 $f_{i,1}=to_i$。方便起见，可设 $f_{|T|+1,1}=|T|$。

转移就相当于 RMQ，可以 ST 表维护。

如何求 $to_i$ 呢，注意到 $to_i$ 具有可二分性，使用字符串哈希 chk 即可。

答案为 $\sum\limits_{i=1}^{|T|}\sum\limits_{j=1}^Kf_{i,j}+1-i$。

下面考虑第二问，每一个 $f$ 值对答案的贡献形如区间加等差数列，将其变为在二重差分数组上单点改，最后还原即可。

复杂度 $O(K|T|+n|T|\log|T|)$。

### 100pts

发现 max 里面 $k$ 那一维是 1，能不能依此优化？

可以的，记 $tr_{i,j}$ 表示区间 $[i,j]$ 中使 $to_i$ 取最大值的 $i$。可以将转移过程大致抽象为：

1.对当前区间求 $tr$。

2.更新 $r$ 为 $to_{tr}$ 并转移到 $k+1$。

此时，我们发现，$[l,tr-1]$ 的 $to$ 值一定不会成为 max。

修改 $tr$ 定义，设 $tr_i$ 表示 $[i,to_i+1]$ 中使 $to_i$ 取最大值的 $i$。

依此建 $tr_i\rightarrow i$ 的边，发现建出来的是根节点为自环的外向“森林”，转移到 $k+1$ 就相当于跳父亲（定义根节点父亲为自身）。

设当前在点 $u$，则所对 $f$ 值为 $to_u$。

我们求出 $s_u$ 表示 $\sum\limits_{i=1}^Kf_{u,i}$。$v_u$ 表示有多少个 $f$ 值跳到了 $u$，前者可以树上倍增，后者可以树上差分求，可以依据这两个东西来做第二问，依据 $s$ 做第一问。

综上，本题在 $O(n|T|\log|T|)$ 的时间复杂度内得到解决。

### 代码


```cpp
#include<bits/stdc++.h>
#define ll long long
#define pii pair<int,int>
#define fi first
#define se second
#define mk make_pair
using namespace std;
const int N1=5050,N=5e5+10,SG=30;
int n,K;int sub;
int to[N];
int hs[12][N],ln[12],pb[N];
int base=131,mod=1011451423;
int hsh[N];
int gh(int l,int r){
    return (hsh[r]-1ll*pb[r-l+1]*hsh[l-1]%mod+mod)%mod;
}ll g[N];
int tr[N];
struct segtree{
    pii T[N<<2];
    #define ls p*2
    #define rs p*2+1
    #define mid (l+r)/2
    void pu(int p){
        T[p]=max(T[ls],T[rs]);
    }
    void bd(int p,int l,int r){
        if(l==r){
            T[p]=mk(to[l],-l);return ;
        }bd(ls,l,mid);bd(rs,mid+1,r);pu(p);
    }pii qry(int p,int l,int r,int pl,int pr){
        if(pl<=l&&r<=pr) return T[p];
        pii res=mk(-1,0);
        if(pl<=mid) res=max(res,qry(ls,l,mid,pl,pr));
        if(pr>mid) res=max(res,qry(rs,mid+1,r,pl,pr));
        return res;
    }
    #undef ls
    #undef rs
    #undef mid
}sgt;
vector<int> E[N];
int dep[N];
int fa[N][22];ll sm[N][22];
bool vis[N];
ll val[N],sum[N],tg[N];
void dfs(int u,int pr){
    vis[u]=1;dep[u]=dep[pr]+1;
    fa[u][0]=pr;sm[u][0]=to[u];
    for(int i=1;i<=19;i++) fa[u][i]=fa[fa[u][i-1]][i-1],sm[u][i]=sm[u][i-1]+sm[fa[u][i-1]][i-1];
    for(auto v:E[u]) if(!vis[v]) dfs(v,u);
}void dfs2(int u){
    vis[u]=1;
    for(auto v:E[u]){
        if(!vis[v]) dfs2(v),val[u]+=val[v];
    }
}
void slv1(){
    cin>>n>>K;
    for(int i=1;i<=n;i++){
        string s;cin>>s;
        ln[i]=s.length();
        int hsh=0;
        for(int j=0;j<ln[i];j++){
            hsh=1ll*hsh*base%mod;
            hsh=(hsh+s[j]-'a')%mod;
            hs[i][j+1]=hsh;
        }
    }string t;cin>>t;
    int len=t.length();
    t=' '+t;
    for(int i=1;i<=len;i++){
        hsh[i]=1ll*hsh[i-1]*base%mod+t[i]-'a';
        hsh[i]%=mod;
    }pb[0]=1;for(int i=1;i<=len;i++) pb[i]=1ll*pb[i-1]*base%mod;
    for(int i=1;i<=len;i++){
        int l=i-1,r=len;
        while(l<r){
            int mid=(l+r+1)/2;
            int hsh1=gh(i,mid),lenn=mid-i+1,cnt=0;
            for(int j=1;j<=n;j++){
                if(lenn>ln[j]) continue;
                if(hsh1==hs[j][lenn]) cnt++;
            }
            if(cnt>0) l=mid;
            else r=mid-1;
        }to[i]=l;
    }to[len+1]=len;
    sgt.bd(1,1,len+1);
    for(int i=1;i<=len;i++) tr[i]=-sgt.qry(1,1,len+1,i,to[i]+1).se;
    for(int i=1;i<=len;i++) E[tr[i]].push_back(i);
    for(int i=len;i>=1;i--) if(!vis[i]) dfs(i,i);
    ll ans=0;
    for(int i=1;i<=len;i++){
        ll s=0;int now=i;
        for(int j=19;j>=0;j--){
            if((K>>j)&1) s+=sm[now][j],now=fa[now][j];
        }ans+=s;sum[i]=s;
        if(dep[i]>K){
            val[i]++,val[now]--;
        }else{
            val[i]++,val[now]--;tg[now]+=K-(dep[i]-1);
        }vis[i]=0;sum[i]+=K;sum[i]-=1ll*K*i;
        //cout<<i<<' '<<now<<endl;
    }
    ans+=1ll*len*K;ans-=1ll*K*(1ll*len*(len+1)/2);
    for(int i=len;i>=1;i--) if(!vis[i]) dfs2(i);
    for(int i=1;i<=len;i++){
        val[i]+=tg[i];//cout<<i<<' '<<val[i]<<' '<<dep[i]<<endl;
        g[i+1]-=K;g[i]+=sum[i];g[i+1]-=sum[i];g[to[i]+2]+=val[i];
    }
    for(int i=1;i<=len;i++) g[i]+=g[i-1];
    for(int i=1;i<=len;i++) g[i]+=g[i-1];
    cout<<ans<<endl;for(int i=1;i<=len;i++) cout<<g[i]<<' ';
}
int main(){
    cin>>sub;
    slv1();
    return 0;
}
```

---

## 作者：Hoks (赞：11)

## 前言
感觉很神的题。

个人感觉比[简单的字符串问题](https://www.luogu.com.cn/problem/P10716)要 hard 很多。
## 思路分析
### 第一问
#### 9 分做法
优先考虑下第一问先。

我们显然的有一个暴力的做法，直接进行一个区间 dp。

转移就是设两个好的三元组 $(l,i,k_1),(i,r,k_2)$，那么三元组 $(l,r,k_1+k_2)$ 就是好的。

这个复杂度是 $O(K|T|^3)$，期望得分 $9$，代码笔者没写（）。

---
#### 18 分做法
然后我们来考虑优化。

类似于[简单的字符串问题](https://www.luogu.com.cn/problem/P10716)中的 $R$ 字符串可空的定义，我们可以观察到一个单调性。

那么就是 $(l,r,k),k<K$ 若为好的，$(l,r,k+1)$ 也一定是好的。

原因很简单，你直接多插入一个空的字符串在末尾就行了。

我们现在的问题就变成了计算对于每个 $(l,r)$，求最小的 $k$ 满足 $(l,r,k)$ 是好的。

那么我们就可以想到枚举 $(l,r)$ 去计算。

把一个串拆分为最小段数的**前缀**，其中**前缀**让我们想到了 trie。

所以我们只要把 $(l,r)$ 这段字符串扔到 trie 上尝试贪心的拆分就行了。

具体的，我们尝试把这段字符串 $s$ 拆分为 $t'+t$，其中 $t'$ 是一段前缀，可以通过在 trie 上走求出来，而拆分 $t$ 的方法直接通过前面已经求的值转移就行了。

那这样的话我们先枚举长度 $i$，再枚举左端点 $l$，得出右端点 $l+i-1$ 就可以转移了。

复杂度 $O(|T|^3)$，期望得分 $18$，实际得分 $30$，代码可以见 [link](https://www.luogu.com.cn/discuss/997088)。

---
#### 30 分做法
上面的代码理论而言不能拿到 $30$ 分，所以我们可以进一步优化复杂度。

其实这里就是一个平衡复杂度的过程。

每次都在 trie 上跳一遍太浪费时间了，我们不妨直接预处理出来每个点开始能最多跳几步，这样就是一个 $O(|T|^2)$ 的预处理。

然后查询就变成了一个树链的 $\min$，可以用线段树来实现。

复杂度 $O(|T|^2\log|T|)$，期望得分 $30$，实际得分 $30$，[code by sgl654321](https://www.luogu.com.cn/paste/bjnwcq1d)。

---
#### 30 分做法
然后这个做法貌似就没什么优化的余地了~~没前途的做法~~，我们考虑进一步观察性质。

其实我们可以发现这里还有一个单调性。

就是如果 $(l,r,k)$ 不是好的，那么 $(l,r+1,k)$ 也**一定不是**好的。

略证一下，既然 $(l,r)$ 不能用 $k$ 个前缀拼出，那么 $(l,r+1)$ 不妨拆分为 $(l,r)$ 和 $(r,r)$。

拆分出的两者中前者都不能用 $k$ 个前缀拼出，加起来显然也不行了。

有了这个单调性我们就有了另一种 dp 的定义方式。

这次我们不钦定 $l,r$ 计算 $k$，而是选择钦定 $l,k$，计算可能的最大 $r$。

由前面的性质，我们知道可能的 $r$ 是一段连续的区间，而左端点就是 $l$，所以记录一个最右端点即可。

设这个定义的最右端点为 $g_{l,k}$，那么我们可以先预处理出 $g_{l,1}$。

这东西就是 $l$ 出发最多能匹配上的长度，在 trie 树上暴力跑一遍就可以做到 $O(|T|^2)$。

然后我们考虑暴力的转移，对于 $g_{l,k}$ 而言：
$$g_{l,k}\leftarrow\max\limits_{i=l}^{g_{l,k-1}+1}g_{i,1}$$
考虑下这个式子的意义。

就是对于 $i\in[l,g_{l,k-1}+1]$，我们可以用 $k-1$ 个前缀把 $[l,i)$ 拼出来，最后再尝试一个前缀从 $i$ 处开始匹配最远能匹配到的位置转移即可。

这个东西有关的值只有 $g_{i,1},i\in[1,|T|]$，所以我们可以把这些值全部扔到 ST 表里去，每次就是一个区间查询。

那么总的复杂度就是 $O(|T|^2+|T|\log|T|+K|T|)$，期望得分 $30$，代码笔者懒得写（）。

当然如果你用四毛子就可以把丑陋的 $\log$ 剥掉。

---
#### 42 分做法
然后继续优化这个东西。

发现复杂度瓶颈在 trie 的这个预处理上，我们考虑加速这个预处理。

这个预处理其实就是在找从位置 $i$ 开始，尝试对每种串的前缀进行匹配，找到一个最长的匹配。

这种匹配我们可以用 hash+二分的经典技巧来加速，可以做到 $O((n|S|+|T|)\log |S|)$。

这样的总复杂度就来到了 $O((n|S|+|T|)\log |S|+|T|\log|T|+K|T|)$，期望得分 $30$，实际得分 $30$。

当然你也可以用 Z 函数直接剥掉 hash+二分的 $\log$。

[code by Hoks](https://www.luogu.com.cn/paste/m7g4jgm1)。

当然你还可以通过数据点分治的方法拿到 $11\sim14$ 的分，期望得分 $42$。

---
#### 60 分做法
然后我们来考虑最后一个优化。

前面不管我们怎么优化，都会有一个无法逾越的瓶颈：
- **我们的 $g_{l,k}$ 的总状态数就是 $O(K|T|)$ 的，对每个求值复杂度不可能低于 $O(K|T|)$。**

其实我们可以注意到的是，对于这 $O(K|T|)$ 个状态，总共只有 $O(|T|)$ 种取值。

因为所有的 $g_{1,k},k>1$ 的值都是从某个 $g_{x,1}$ 取来的，所以取值只有 $O(|T|)$ 种。

考虑观察这些取值之间互相转移的性质。

不妨设 $f_{l,k}$ 表示 $g_{l,k}=g_{f_{l,k},1}$。

因为 $g_{l,k}=\max\limits_{i=l}^{g_{l,k-1}+1}g_{i,1}=g_{f_{l,k},1}$。

所以 $f_{l,k}$ 一定不劣于 $i\in[l,f_{l,k}]$，可以直接把这段无用区间去掉。

那么我们考虑 $g_{l,k+1}=\max\limits_{i=l}^{g_{l,k}+1}g_{i,1}=\max\limits_{i=f_{l,k}}^{g_{f_{l,k},1}+1}g_{i,1}$。

换元法，我们令 $l'=f_{l,k}$，那么最右边的那个式子就可以化为 $\max\limits_{i=l'}^{g_{l',1}+1}g_{i,1}=g_{l',2}=g_{f_{l',2},1}$。

然后我们就得到了 $f_{l,k+1}=f_{l',2}=f_{f_{l,k},2}$。

这东西长得一脸图的样子，我们直接建图，给 $i\rightarrow f_{i,2}$ 连边，那么 $i$ 跳 $k$ 步到达的 $k$ 级祖先即为 $f_{i,k+1}$。

那么我们就可以把第一问的答案用一个形式化的式子表达出来：
$$\sum\limits_{i=1}^{|T|}\sum\limits_{j=1}^K(g_{f_{i,j},1}-i+1)$$
把中间平凡的 $-i+1$ 剥出来再化简可以得到：
$$\sum\limits_{i=1}^{|T|}\sum\limits_{j=1}^Kg_{f_{i,j},1}-K\sum\limits_{i=1}^{|T|}i+K|T|$$

后两项是平凡的，只需要考虑第一项就可以了。

因为 $g_{l,1}$ 的取值只有 $|T|$ 种，所以我们只要对每种 $l$ 数有多少 $f_{i,j}=1$ 就行了。

那么就是对于每个 $i$ 来讲对他的 $j$ 级祖先出现次数 $+1$，这东西可以简单树上差分然后前缀和解决。

但是注意树的根节点有自环，要特殊处理。

使用 Z 函数，这样我们就在 $O(n(|T|+|S|)+|T|\log|T|)$ 的复杂度完成了第一问，期望得分 $60$。

当然如果会四毛子+长剖可以去掉 $\log|T|$。

当然这个东西他求的 $k$ 级祖先是固定的，直接记录的方法就可以省掉大常的长剖了。

[code by Hoks](https://www.luogu.com.cn/paste/10k39wpj)。

实际得分 $60$，但是调的我很折磨，从 $57\rightarrow54\rightarrow21\rightarrow60$，前面两个甚至对拍都拍不出来。

---
### 第二问
#### 15 分做法
做完第一问后，我们来考虑第二问。

首先是对于最开头写的 $O(K|T|^3)$ 的暴力。

在算出 $(l,r,k)$ 为好的后暴力枚举 $i\in[l,r]$ 给当前位置值 $+1$ 就行了。

复杂度还是 $O(K|T|^3)$，期望得分 $15$。

---
#### 30/50 分做法
接着是 $O(|T|^3)$ 和 $O(|T|^2\log |T|)$ 的做法。

因为其本质并没有区别，所以第二问的做法相同。

我们现在已经处理出了 $(l,r)$ 的最小值 $k$，那么 $i\in[k,K],(l,r,i)$ 都是好的。

也就是对于 $[l,r]$ 一个区间加 $K-k+1$，暴力做是 $O(|T|^3)$，随便扔个 DS 是 $O(|T|^2\log|T|)$，差分前缀和是 $O(|T|^2)$。

第一个期望得分 $30$，剩下的两个结合 $O(|T|^3)$ 期望得分 $30$，结合 $O(|T|^2\log |T|)$ 期望得分 $50$。

实际而言得分都是 $50$。

代码可以看上面附的链接。

---
#### 50/70 分做法
然后是对于~~有前途~~钦定了 $l,k$ 做法的第二问。

第一种是无脑的做法，我们直接通过 $g$ 求出 $f$ 然后就变成了和上面一样的东西。

这样期望得分 $50$，实际得分 $50$。

[code by Hoks](https://www.luogu.com.cn/paste/mgzq1ha8)。

但这样还是~~没有前途~~太劣了。

我们不妨直接对每个 $g_{l,k}$ 去考虑他的贡献。

他的贡献就是对于区间 $i\in[l,g_{l,k}]$ 加上 $g_{l,k}-i+1$。

这里面有一个 $i$ 看着非常 ex，所以我们先通过一次差分前缀和的方法给每个位置 $-1$，做到把式子转化为 $g_{l,k}-l+1$。

然后再差分一次前缀和累加就行了。

具体的先给 $l+1$ 位置减 $1$，$g_{l,k}+2$ 位置加 $1$。

然后前缀和累加一次。

再给 $l$ 位置加 $g_{l,k}-l+1$，再前缀和累加一次就可以得到正确的答案了。

复杂度和前面的期望 $42$ 分的做法一样，这样期望得分来到 $70$，实际得分也是 $70$。

[code by Hoks](https://www.luogu.com.cn/paste/5xro8ma5)，非常丑陋就是给一个东西拼了两次（）。

---
#### 100 分做法
然后我们考虑 $100$ pts 做法。

根据前面的 $60$ pts 第一问做法，我们知道求的这个值其实就是一个森林上跳 $k$ 步的问题。

我们尝试把刚刚的 $70$ pts 做法推广到森林上来。

修改之后我们的具体操作就是：
1. 给 $l+1$ 位置 $-K$。
2. 给 $g_{l,1}+2$ 位置加上 $g_{l,1}$ 的统计次数。
3. 然后累加一遍前缀和。
4. 给 $l$ 位置加上 $\sum\limits_{k=0}^{K-1}g_{l,k}-K\cdot(i-1)$。
5. 再累加一遍前缀和。

这其实就只是把刚刚的操作扔到森林上来了。

细节注意点还是相同的，注意根节点的自环。

实现上而言，我们可以不用真的这样二阶前缀和，直接二阶差分把值差分出来就行了。

复杂度仍是 $O(n(|T|+|S|)+|T|\log|T|)$ 期望得分 $100$，实际得分 $100$。
## 代码

```cpp
#include<bits/stdc++.h>
#define ls (p<<1)
#define rs (ls|1)
#define mid ((l+r)>>1)
#define int long long
using namespace std;
const int N=1e6+10,V=315,M=23,INF=1e9,mod=998244353;
int n,m,k,ans,l[N],z[N<<1],g[N];char s[M][N],t[N],ss[N<<1];
vector<int>e[N];int top,st[N],f[N],kf[N],mp[N],a[N],b[N],c[N],d[N];
int tt[M][N],stt[M][N];
namespace Fast_IO
{
    static char buf[1000000],*paa=buf,*pd=buf,out[10000000];int length=0;
    #define getchar() paa==pd&&(pd=(paa=buf)+fread(buf,1,1000000,stdin),paa==pd)?EOF:*paa++
    inline int read()
    {
        int x(0),t(1);char fc(getchar());
        while(!isdigit(fc)){if(fc=='-') t=-1;fc=getchar();}
        while(isdigit(fc)) x=(x<<1)+(x<<3)+(fc^48),fc=getchar();
        return x*t;
    }
    inline void flush(){fwrite(out,1,length,stdout);length=0;}
    inline void put(char c){if(length==9999999) flush();out[length++]=c;}
    inline void put(string s){for(char c:s) put(c);}
    inline void print(int x)
    {
        if(x<0) put('-'),x=-x;
        if(x>9) print(x/10);
        put(x%10+'0');
    }
    inline bool chk(char c) { return !(c>='a'&&c<='z'||c>='A'&&c<='Z'||c>='0'&&c<='9'||c=='|'||c=='-'); }
    inline bool ck(char c) { return c!='\n'&&c!='\r'&&c!=-1&&c!=' '; }
    inline void rd(char s[],int&n)
    {
        s[++n]=getchar();
        while(chk(s[n])) s[n]=getchar();
        while(ck(s[n])) s[++n]=getchar();
        n--;
    }
}
using namespace Fast_IO;
namespace function_Z
{
	inline void get_Z(char s[],int n,int z[])
	{
		for(int i=2,l=1,r=0;i<=n;i++)
		{
			z[i]=i>r?0:min(z[i-l+1],r-i+1);
			while(i+z[i]<=n&&s[z[i]+1]==s[i+z[i]]) z[i]++;
			if(i+z[i]-1>r) l=i,r=i+z[i]-1;
		}z[1]=n;
	}
}
using namespace function_Z;
inline void dfs1(int u,int rt)
{
    st[++top]=u;d[u]=d[f[u]]+1;b[u]=b[f[u]]+g[u];
    if(top>=k) kf[u]=st[top-k+1];
    else{kf[u]=rt;if(mp[u]) ans+=(k-top)*g[rt];}
    for(int v:e[u]) dfs1(v,rt);a[f[kf[u]]]--,a[u]++;top--;
}
inline void dfs2(int u,int t)
{
    for(int v:e[u]) dfs2(v,t),a[u]+=a[v];ans+=a[u]*g[u];int cur=0;
    if(d[u]>=k) cur=b[u]-b[f[kf[u]]]-k*(u-1);
    else cur=(k-d[u])*g[t]+b[u]-k*(u-1),c[g[t]+2]+=k-d[u];
    c[u]+=cur,c[u+1]-=cur+k,c[g[u]+2]+=a[u];
}
inline void solve()
{
    n=read();k=read();for(int i=1;i<=n;i++) rd(s[i],l[i]);rd(t,m);
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++) if(s[i][1]==t[j]) mp[j]=1;
        for(int j=1;j<=l[i];j++) ss[j]=s[i][j];
        for(int j=1;j<=m;j++) ss[j+l[i]]=t[j];get_Z(ss,m+l[i],z);
        for(int j=1;j<=m;j++) g[j]=max(g[j],j+min(l[i],z[j+l[i]])-1);
    }for(int j=1;j<=m;j++) if(mp[j]) stt[0][j]=g[j],tt[0][j]=j;
    for(int j=1;j<M;j++)
        for(int i=1;i+(1<<j)-1<=m;i++)
        {
            if(stt[j-1][i]>stt[j-1][i+(1<<j-1)]) tt[j][i]=tt[j-1][i];
            else tt[j][i]=tt[j-1][i+(1<<j-1)];
            stt[j][i]=max(stt[j-1][i],stt[j-1][i+(1<<j-1)]);
        }
    for(int i=1;i<=m;i++)
    {
        if(!mp[i]){f[i]=i;continue;}int r=g[i]+1,K=log2(r-i+1);
        if(stt[K][i]>stt[K][r-(1<<K)+1]) f[i]=tt[K][i];
        else f[i]=tt[K][r-(1<<K)+1];
        if(f[i]!=i) e[f[i]].emplace_back(i);else f[i]=0;
    }for(int i=1;i<=m;i++) if(!f[i]) dfs1(i,i),dfs2(i,i);
    for(int i=1;i<=m;i++) if(mp[i]) ans-=(i-1)*k;
    print(ans);put('\n');
    for(int i=1;i<=m;i++) c[i]+=c[i-1];
    for(int i=1;i<=m;i++) c[i]+=c[i-1];
    for(int i=1;i<=m;i++) print(c[i]),put(' ');
}
signed main()
{
    int T=1,tp=read();
    // T=read();
    while(T--) solve();
    genshin:;flush();return 0;
}
```

---

## 作者：良心WA题人 (赞：5)

## 前言

笑点解析，赛时代码有三行，其中有三个非常离谱的错误。然而，这样的东西可以通过到大样例 6，并使得无法测试剩余两个大样例，只好假装自己过了。最后喜提 $0$ 昏。

## 思路

考虑第二问，发现找到这样的区间看起来十分困难，故考虑用第一问的答案减去 $l,r$ 不合法的区间。

故需要计算任意前缀和后缀的答案。先观察一下性质，发现如果 $[l,r]$ 是好的，则 $[l,r-1]$ 也一定是好的。故确定左端点后右端点可行的位置是从 $l$ 开始的一个区间，记这个右端点为 $p_l$。那么，对于拼接的第二个字符串，就是在 $(l,r+1]$ 内 $p_i$ 最大的一个，依次类推。

则从 $i$ 向这个最大的位置连边，在 $k-1$ 步之内到达的所有 $u$ 的 $p_i$ 都减一，$i$ 加一算一个前缀和即可得到对于所有 $r$ 合法的 $l,k$ 的个数。需要注意如果出现了自环要特判。

现在只需要求对于所有 $l$ 合法的 $r,k$ 个数即可。发现 $i$ 从那个最大的位置可以转移得到当前位置每种**不同的 $r$ 的最小的 $k$** 的个数。而这之间的变化是全局平移 $1$、单点修改。查询是一段长度为 $k$ 的区间，可以使用可持久化线段树通过。

---

## 作者：Genius_Star (赞：3)

**本题解提供详细部分分讲解和代码。**

### 思路：

首先容易想到 $f_{l, r, k}$ 表示 $(l, r, k)$ 是否满足，可以刷表转移，即枚举一个 $i$ 使得 $T_{[r + 1, i]}$ 是某个 $S_i$ 的前缀，则：
$$
dp_{l, i, k + 1} = dp_{l, i, k + 1} \operatorname{or} dp_{l, r, k} [T_{[r + 1, i]} \ is \ good]
$$
然后考虑优化下状态，注意到**空串**也是好的，则若 $f_{l, r, k}$ 满足，可以在后面添加一个空串使得 $f_{l, r, k + 1}$ 也满足；即满足的 $k$ 是一段后缀。

则令 $f_{l, r}$ 表示使得 $(l, r, k)$ 满足的最小的 $k$，考虑从小到大枚举 $r$，从大到小枚举 $l$，转移：
$$
f_{l, r} = 1 + \min\limits_{i = l + 1}^{r + 1} f_{i, r} [T_{[l, i - 1]} \ is \ good]
$$
即枚举一个 $i$，使得 $T_{[l, i - 1]}$ 是某个 $S_i$ 的前缀；其中 $f_{r + 1, r} = 0$，代表选的是一个空串。

然后继续优化，注意到对于每个 $l$，满足 $T_{[l, r]}$ 是好的 $r$ 是一段前缀，故可以求出 $nxt_i$ 表示最大的 $j$ 使得 $T_{[i, j]}$ 是好的（可以使用二分求 $nxt_i$，时间复杂度为 $O(|T|n \log |T|)$，故状态转移方程可以变为：
$$
f_{l, r} = 1 + \min\limits_{i = l + 1}^{\min(nxt_l, r) + 1} f_{i, r}
$$
现在我们需要支持进行若干个强制在线的左端点单调递减的区间最小值的询问，使用单调栈和二分或者直接上线段树。

就可以做到 $O(|T|^2 \log |T|)$ 的时间复杂度。

该部分的 [Code](https://www.luogu.com.cn/record/189922612)（这个代码被卡哈希了请注意，可以使用双哈希）。

发现题目给了个 $K$ 很小的部分分，考虑从 $K$ 入手；容易发现使得 $(l, r, k)$ 合法的 $r$ 是一段前缀，那么更新下状态令 $dp_{l, k}$ 表示使得 $(l, r, k)$ 合法的最大的 $r$，则有转移方程;
$$
dp_{i, k} = \max\limits_{j = i}^{dp_{i, k - 1} + 1} nxt_j
$$
维护区间最大值可以用 ST 表或线段树，时间复杂度为 $O(|T|K)$，答案为：
$$
\sum_{i = 1}^n \sum_{k = 1}^K dp_{i, k} - i + 1 = \sum_{i = 1}^n \sum_{k = 1}^K dp_{i ,k} + nK - \sum_{i = 1}^n Ki = \sum_{i = 1}^n \sum_{k = 1}^K dp_{i ,k} + nK - \frac{n(n + 1)}{2}K
$$

该部分的 [Code](https://www.luogu.com.cn/record/190031795)。

继续考虑优化，设 $nxt_j = dp_{l, k - 1}$，则容易发现 $[1, j - 1]$ 范围内的点的 $nxt$ 值是不会造成贡献的；只有 $[j, dp_{l, k - 1}( = nxt_j) + 1]$ 范围内的点的 $nxt$ 才会造成影响。

故考虑令 $t_i$ 表示 $[i, nxt_i + 1]$ 范围内使得 $nxt_j$ 最大的那个 $j$。

则每次转移，令 $g_{i, k}$ 表示使得 $nxt_j = dp_{i, k}$ 的 $j$，则：
$$
g_{i, k} = t_{g_{i, k - 1}} \\
dp_{i ,k} = nxt_{g_{i, k}}
$$
则考虑建 $t_i \to i$ 的有向边构成一棵树，每次转移相当于由当且节点跳到了父亲节点，每个点的权值是 $nxt_i$。

那么我们若要求 $s_i = \sum\limits_{k = 1}^K dp_{i, k}$ 的话，相当于从 $i$ 开始，往上跳 $K - 1$ 个节点，算所有这些点的权值之和；直接树上倍增做即可。

然后再来看第二问，每次相当于在 $[l, dp_{l, k}]$ 范围内加上一个首项为 $dp_{l, k} - l + 1$ 公差为 $-1$ 的等差数列；经过二阶差分后，$dp_{l, k}$ 的贡献相当于以下几个操作：

- $d_l \gets d_l + dp_{l, k} - l + 1$。
- $d_{l + 1} \gets d_{l + 1} - dp_{l, k} + l - 2$。
- $d_{dp_{l, k} + 2} \gets d_{dp_{l, k} + 2}  + 1$。

即可以得到：
$$
d_l \gets d_l -lK + K + \sum_{k = 1}^K dp_{l, k} = d_l - lK + K + s_l \\
d_{l + 1} \gets d_{l + 1} + lK - 2K - \sum_{k = 1}^K dp_{l, k} = d_{r + 1} + lK - 2K - s_i \\
$$
然后还需要给 $i$ 节点和其上面 $K - 1$ 个父亲节点的权值 $+2$ 处都增加 $1$（这个树上差分解决要增加多少次）。

此时就解决了这两个问题。

总时间复杂度为 $O(|T| n \log |T| + |T| \log |T|)$。

### 完整代码：

```cpp
#include<bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp>
#include<ext/pb_ds/hash_policy.hpp>
#define lowbit(x) x&(-x)
#define mkp(x, y) make_pair(x, y)
#define pi pair<ll,ll>
#define pii pair<ll,pair<ll,ll>>
#define iip pair<pair<ll,ll>,ll>
#define ppii pair<pair<ll,ll>,pair<ll,ll>>
#define fi first
#define se second
#define full(l,r,x) for(auto it = l; it != r; ++it) (*it)=x
#define Full(a) memset(a, 0, sizeof(a))
#define open(s1,s2) freopen(s1, "r", stdin), freopen(s2, "w", stdout);
#define For(i,l,r) for(register int i = l; i <= r; ++i)
#define _For(i,l,r) for(register int i = r; i >= l; --i)
using namespace std;
using namespace __gnu_pbds;
typedef double db;
typedef unsigned long long ull;
typedef long long ll;
bool Begin;
const int N = 5e5 + 10, M = 22, base1 = 127, mod1 = 2045000011, base2 = 17, mod2 = 1e9 + 7;
inline ll read(){
    ll x = 0, f = 1;
    char c = getchar();
    while(c < '0' || c > '9'){
        if(c == '-')
          f = -1;
        c = getchar();
    }
    while(c >= '0' && c <= '9'){
        x = (x << 1) + (x << 3) + (c ^ 48);
        c = getchar();
    }
    return x * f;
}
inline void write(ll x){
	if(x < 0){
		putchar('-');
		x = -x;
	}
	if(x > 9)
	  write(x / 10);
	putchar(x % 10 + '0');
}
struct Node{
	int v, id;
	bool operator<(const Node&rhs)const{
		if(v ^ rhs.v)
		  return v < rhs.v;
		return id > rhs.id;
	}
};
ll ans;
ll d[N];
int n, m, K;
int a[N], t[N], w[N], nxt[N], dp[N], sd[N], dep[N], FA[N], poww1[N], poww2[N];
int fa[M][N];
ll sum[M][N];
Node F[M][N];
int p1[11][N], p2[11][N];
vector<int> E[N];
char s[N];
bool f[N];
inline void add(int u, int v){
	E[u].push_back(v);
}
inline void init(){
	poww1[0] = poww2[0] = 1;
	for(int i = 1; i < N; ++i){
		poww1[i] = 1ll * base1 * poww1[i - 1] % mod1;
		poww2[i] = 1ll * base2 * poww2[i - 1] % mod2;
	}
}
inline pair<int, int> gethash(int l, int r){
	return {(p1[0][r] - 1ll * p1[0][l - 1] * poww1[r - l + 1] % mod1 + mod1) % mod1, (p2[0][r] - 1ll * p2[0][l - 1] * poww2[r - l + 1] % mod2 + mod2) % mod2};
}
inline void Hash(int id = 0){
	int m = strlen(s + 1);
	for(int i = 1; i <= m; ++i){
		p1[id][i] = (1ll * p1[id][i - 1] * base1 % mod1 + s[i]) % mod1;
		p2[id][i] = (1ll * p2[id][i - 1] * base2 % mod2 + s[i]) % mod2;
	}
}
inline Node query(int l, int r){
	int k = log2(r - l + 1);
	return max(F[k][l], F[k][r - (1 << k) + 1]);
}
inline void add(int l, int r, int v){
	d[l] += v;
	d[l + 1] += -v - 1;
	d[r + 2] ++;
}
inline void dfs(int u, int pre){
	f[u] = 1;
	sum[0][u] = w[u];
	fa[0][u] = pre;
	for(int i = 1; i < M; ++i){
		fa[i][u] = fa[i - 1][fa[i - 1][u]];
		sum[i][u] = sum[i - 1][u] + sum[i - 1][fa[i - 1][u]];
	}
	for(auto v : E[u]){
		if(f[v])
		  continue;
		FA[v] = FA[u];
		dep[v] = dep[u] + 1;
		dfs(v, u);
	}
}
inline void dfs2(int u){
	f[u] = 1;
	for(auto v : E[u]){
		if(f[v])
		  continue;
		dfs2(v);
		sd[u] += sd[v];
	}
}
bool End;
int main(){
//	open("A.in", "A.out");
	init();
	read(), n = m = read(), K = read();
	for(int i = 1; i <= m; ++i){
		scanf("%s", s + 1);
		Hash(i);
	}
	scanf("%s", s + 1);
	n = strlen(s + 1);
	Hash();
	for(int i = 1; i <= n; ++i){
		nxt[i] = i - 1;
		int l = i, r = n;
		while(l <= r){
			bool F = 0;
			int mid = (l + r) >> 1;
			auto now = gethash(i, mid);
			int len = mid - i + 1;
			for(int j = 1; j <= m; ++j){
				if(mkp(p1[j][len], p2[j][len]) == now){
					F = 1;
					break;
				}
			}
			if(F){
				nxt[i] = mid;
				l = mid + 1;
			}
			else
			  r = mid - 1;
		} 
		F[0][i] = {nxt[i], i};
		w[i] = nxt[i];
	}
	nxt[n + 1] = n, F[0][n + 1] = {n, n + 1};
	for(int j = 1; j < M; ++j)
	  for(int i = 1; i <= n + 1 && i + (1 << j) - 1 <= n + 1; ++i)
	    F[j][i] = max(F[j - 1][i], F[j - 1][i + (1 << (j - 1))]);
	for(int i = 1; i <= n; ++i){
		t[i] = query(i, nxt[i] + 1).id;
		add(t[i], i);
	}
	for(int i = n; i >= 1; --i){
		if(f[i])
		  continue;
		FA[i] = i;
		dfs(i, i);
	}
	for(int i = 1; i <= n; ++i){
		ll s = 0;
		int x = i;
		for(int j = M - 1; j >= 0; --j){
			if((K >> j) & 1){
				s += sum[j][x];
				x = fa[j][x];
			}
		}
		ans += s;
		d[i] += K + s - 1ll * i * K;
		d[i + 1] += 1ll * i * K - 2ll * K - s;
		++sd[i];
		if(dep[i] <= K - 1)
		  d[w[FA[i]] + 2] += (K - 1 - dep[i]);
		else
		  --sd[x];
	}
	for(int i = n; i >= 1; --i)
	  f[i] = 0;
	for(int i = n; i >= 1; --i){
		if(f[i])
		  continue;
		dfs2(i);
	}
	for(int i = 1; i <= n; ++i)
	  d[w[i] + 2] += sd[i];
	write(ans + 1ll * K * n - (1ll * n * (n + 1) >> 1) * K);
	putchar('\n');
	for(int i = 1; i <= n; ++i)
	  d[i] += d[i - 1];
	for(int i = 1; i <= n; ++i){
		d[i] += d[i - 1];
		write(d[i]);
		putchar(' ');
	}
	cerr << '\n' << abs(&Begin - &End) / 1048576 << "MB";
	return 0;
}
```

---

## 作者：Richard_Whr (赞：2)

请注意 $R$ 可以是空串。

这意味着我们可以计数转最优化，求出区间 $[l,r]$ 最少用多少个前缀拼接而成，多余的可以放空串。

设 $f_i$ 表示最大的 $x$，使得存在一个 $j$，满足：$T[i:i+x-1]=S_k[1:x]$，这个可以看成和每一个给定字符串求一下 LCP，可以使用各种字符串算法维护。

考虑贪心的匹配，找到当前能覆盖的位置中，$j+f_j$ 最大的，然后把下一段的开头定在 $j$，正确性比较显然。

先考虑第一问，从左到右扫，每次我们计算 $l=i$ 的三元组数量 $sum_i$。

设 $p_i$ 为第 $i$ 段的起始位置，形如：$(l,[p_i,p_i+f_{p_i}-1],[i,k])$ 的三元组是合法的。

容易发现 $sum_i = \sum\limits_{j=1}^{k}p_j+f_{p_j}-i$。

这样第一问就做完了。

对于第二问，考虑先把答案记在右端点上，然后做类似后缀和一样的东西传递给其他点，观察注意到刚才那个柿子本质上来说在做区间加，比较好维护。

换句话说，我们记录 $s_i$ 表示三元组中 $r=i$ 的数量，那么对于 $i \in [p_i,p_i+f_{p_i}-1]$ ，有 $s_i\leftarrow s_i+k+1-i$。

这是一个形如区间加的形式，我们考虑差分。

最终部分抵消后形如：在 $i$ 处的差分 $+k$，在每一个 $p_i+f_{p_i}$ 的位置 $-1$，如果不足 $k$ 次则在最后一个 $p_i+f_{p_i}$ 处减掉多余的即可。

假设我们的 $l=i=1$，那么直接做一遍后缀和就能得到最终的答案。

如果 $l \not =1$，就在 $l-1$ 处将 $l$ 的贡献消去，即减掉 $sum_l$，然后再做后缀和就是对的了。

这样算下来复杂度是 $O(n\times(|S|+|T|)+|T| \times k)$，可以获得 85pts 的高分。

瓶颈在于贪心，发现每次选定一个左端点后，下一次选定的左端点都是固定的，可以用倍增做这个。

倍增如何支持给其中的每个 $i+f_i$ 都 $-1$ 嘞？

类似萌萌哒一题的思路，设计一个 $tag_{i,j}$ 表示从 $i$ 开始跳 $2_j$ 次经过的不算最后跳到的点，都要加上的权值。

然后从大到小枚举 $j$ 依次下放即可。

不懂得看看代码更清楚：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=5e5+10,M=20;
int z[N],f[N],p[N];
char str[10][N],t[N];
int mx[N][M];
int Id,_n,n,m,k;
int ans[N];
int s[N],To[N][M],g[N][M],tag[N][M];

void get_Z(char *s,int n)
{
	memset(z,0,sizeof z);
	z[1]=n;
	for(int i=2,l=0,r=0;i<=n;i++)
	{
		if(i<=r) z[i]=min(z[i-l+1],r-i+1);
		while(i+z[i]<=n && s[1+z[i]]==s[i+z[i]]) z[i]++;
		if(i+z[i]-1>r) l=i,r=i+z[i]-1;
	}
}

void exkmp(char *s,int m,char *t,int n)
{
	get_Z(s,m);
	memset(p,0,sizeof p);
	for(int i=1,l=0,r=0;i<=n;i++)
	{
		if(i<=r) p[i]=min(z[i-l+1],r-i+1);
		while(1+p[i]<=m && i+p[i]<=n && s[1+p[i]]==t[i+p[i]]) p[i]++;
		if(i+p[i]-1>r) l=i,r=i+p[i]-1;
	}
}

inline int Max(int i,int j){return i+f[i]>j+f[j]?i:j;}

inline int RMax(int l,int r)
{
	if(l>r) return 0;
	int j=log2(r-l+1);
	return Max(mx[l][j],mx[r-(1<<j)+1][j]);
}

signed main()
{
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);

	cin>>Id>>_n>>k;
	for(int i=0;i<_n;i++) cin>>(str[i]+1);

	cin>>(t+1);
	n=strlen(t+1);

	for(int i=0;i<_n;i++)
	{
		m=strlen(str[i]+1);
		exkmp(str[i],m,t,n);
		for(int j=1;j<=n;j++) f[j]=max(f[j],p[j]);
	}
	
	for(int i=1;i<=n;i++) mx[i][0]=i;

	for(int j=1;j<M;j++)
		for(int i=1;i+(1<<j)-1<=n;i++)
			mx[i][j]=Max(mx[i][j-1],mx[i+(1<<(j-1))][j-1]);

	for(int i=1;i<=n;i++)
	{
		To[i][0]=0;
		int j=RMax(i,i+f[i]);
		if(j+f[j]>i+f[i]) To[i][0]=j;
		g[i][0]=i+f[i];
	}
	
	for(int j=1;j<M;j++)
	{
		for(int i=1;i<=n;i++) 
			To[i][j]=To[To[i][j-1]][j-1],g[i][j]=g[i][j-1]+g[To[i][j-1]][j-1]; 
	}

	int res=0;
	for(int i=1;i<=n;i++)
	{
		if(!f[i]) continue;
		s[i]+=k;
		int w=k,x=i;
		for(int j=M-1;j>=0;j--)
		{
			if(To[x][j]==0) continue;
			if(w>=(1<<j)) ans[i]+=g[x][j],tag[x][j]--,w-=(1<<j),x=To[x][j];
		}
		ans[i]+=(x+f[x])*w;
		s[x+f[x]]-=w;
		ans[i]-=k*i;
		res+=ans[i];
	}
	
	cout<<res<<"\n";
	
	for(int j=M-1;j>=1;j--)
	{
		for(int i=1;i<=n;i++)
		{
			if(To[i][j]==0) continue;
			tag[i][j-1]+=tag[i][j];
			tag[To[i][j-1]][j-1]+=tag[i][j];
		} 
	}
	
	for(int i=1;i<=n;i++) s[i+f[i]]+=tag[i][0];
	
	for(int i=1;i<=n+1;i++) s[i]+=s[i-1];

	for(int i=1;i<=n;i++) s[i-1]-=ans[i];

	for(int i=n;i>=1;i--) s[i]+=s[i+1];

	for(int i=1;i<=n;i++) cout<<s[i]<<" ";
	cout<<"\n";
}
```

---

## 作者：一只绝帆 (赞：2)

本题存在线性做法，即与输入量同阶，在保证其他范围的前提下 $n$ 可以开到任意大。

首先来刻画结构，我们发现可以贪心求解，从 $l$ 往右跳 $\rm lcp$，这一段贡献是 $K$，然后不断将 $r$ 设为区间 $\max$，贡献逐级递减，这样我们就会了平方算法，第二问只需区间加等差数列。

求解 $\rm lcp$ 时，我们使用广义 $\rm SAM$，把所有串的反串都扔进去，把所有属于 $S$ 前缀都标记上（即每个 $S$ 插入的最后一个节点的所有祖先），标记的节点的 $\rm len$ 对子树取 $\max$。

考虑将跳的过程连成森林，每个点连向他第二步的“跳板”，则我们求的是祖孙链贡献。

形式化地讲，我们设第 $i$ 个位置一步能覆盖到 $r_i-1$，则令 $k_i=\text{argmax}\{ r_j\mid j\in[i,r_i]\}$，我们 $i\to k_i$，令这条边的边权是 $r_{k_i}-r_i$，则每个点作为 $l$ 的贡献是 链底点权 $\ K$ 加上 链上每条边的 $($边权 $\ ($边下方点的深度$))$ 减掉 链上每条边的边权和 $*\ ($链底点深度 $-K+1)$。

求解 $k_i$ 时，如果想要追求线性的复杂度，可以使用线性 $\rm RMQ$。


尝试解决第二问，考虑并不每段加每段的，而是求出单步可达、两步可达、三步可达等等的贡献，注意“单步可达”实质上意味着 $l$ 固定，$r\in[l,R]$。

所以这是公差为 $-1$ 的等差数列加，那么我们提前进行二阶差分（第一阶我们倒着差分），考虑一条距离 $\le K$ 的祖孙链 $(x,y),d_x\ge d_y$，贡献形式就变成了简单的 `s2[x]++,s2[r[y]]--`。

直接考虑 `s2[x]` 被加了多少次，以及 `s2[r[y]]` 被减了多少次即可，前一个是 `dfs` 栈，后一个是 `dfs` 子树，我们要询问子树内深度 $\ge x$ 的点数，只需维护深度数组前缀和，递归子树前减一下，递归子树后加一下，前缀和可以在更新点值的时候动态更新（也可以给祖先打差分标记，回溯的时候对标记前缀和）。

---

## 作者：chroneZ (赞：2)

提供一个巨大复杂的场内做法。

由于允许 $R_i$ 为空，所以对于子串 $T_{[l, r]}$，记 $k'$ 为其至少需要多少个好的字符串拼接而成，则 $\forall k \in [k', K]$，$(l, r, k)$ 均为好的三元组。

考虑贪心求解 $k'$：记 $T_{[i, |T|]}$ 与 $n$ 个串的 $\text{lcp}$ 的最大值为 $p_i$，从 $l$ 开始每次跳最远的右端点即可求解。

具体地，记 $ans_{l, i}$ 表示 $T_{[l, i]}$ 对应的 $k'$。为了对于一个左端点 $l$ 求出所有 $[l, r]$ 的 $ans$，考虑维护一个 $t$，初始为 $l - 1$，每次在 $[l, t + 1]$ 范围内取一个 $i$，最大化 $q = i + p_i$，然后令 $ans_{l, [t + 1, q - 1]} \gets \text{steps}$，再令 $t \gets q - 1$，其中 $\text{steps}$ 为操作次数，如果 $q - 1 \leq t$ 那么提前终止，否则在 $q = |T| + 1$ 时终止。

容易发现从初始状态跳跃一次之后，剩余的问题是一个几乎独立的子问题。形式化地讲，先判掉两种边界情况，第一种是 $l + p_l = |T| + 1$ 的情况，此时有 $ans_{l, *} = 1$，第二种是 $p_l = 0$ 的情况，此时不妨令 $ans_{l, *} = K + 1$。对于一般情况，我们求出一个 $i \in [l + 1, l + p_l]$，最大化 $i + p_i$（多个任取其一），那么可以用下述方式计算 $ans$ 序列：

- 令 $ans_{l, j} \gets \min(ans_{i, j} + 1, K + 1), j \geq i$。
- 然后令 $ans_{l, j} \gets 1, l \leq j < l + p_l$。

为了更有利于后续处理，我们将这个过程精细化一点：

- 显然 $ans$ 序列是不降的，记 $x$ 为最小的位置满足 $ans_{i, x} = K + 1$，若没有则为 $|T| + 1$。假定 $ans$ 序列初始全 $0$。
- 令 $ans_{l, j} \gets ans_{i, j}, j \geq i$。
- 对 $ans_{l, [l, i - 1]}$ 加 $1$。
- 对 $ans_{l, [l + p_l, x - 1]}$ 加 $1$，如果 $l + p_l \leq x - 1$。

这意味着，我们只需要支持将 $ans_l$ 继承 $ans_i$，以及区间加两种操作，很难不想到用线段树处理。乍一看继承操作得用主席树，但是事实上我们可以把继承操作建树，从而离线处理掉。

具体来说，对于每个“$ans_l$ 继承 $ans_i$”的操作，我们连一条 $i \to l$ 的边，这样我们可以得到一个森林。考虑从根结点开始 dfs，每进入一个点时，我们分两种情况讨论：

- 点是根结点：这对应了上文 $ans_{l, *} = 1$ 或 $ans_{l, *} = K + 1$ 的情况，直接在线段树上对区间 $[l, |T|]$ 区间加 $1/K + 1$ 即可。
- 否则：线段树二分出上文中的 $x$，然后对 $[l, i - 1]$ 与 $[l + p_l, x - 1]$ 区间加 $1$ 即可。

当我们从一个点回溯时，只需要撤销加入时的贡献即可。这样一来我们可以做到 $\Theta(|T| \log |T|)$ 求出所有 $ans$。

考虑统计答案。统计好的三元组数量是容易的，对于每个 $l$ 合法的三元组数为 $\sum \limits_{r \geq l} (K + 1 - ans_{l, r}) = (|T| - l + 1)(K + 1) - \sum \limits_{r \geq l} ans_{l, r}$，而 $\sum ans_{l, r}$ 容易用线段树求出。对所有 $l$ 的答案求和即可。

第二问会棘手一些，考虑将 $l \leq i \leq r$ 这一限制容斥，即总三元组数减去 $[l, r] \subseteq [1, i - 1]$ 的三元组数，再减去 $[l, r] \subseteq [i + 1, |T|]$ 的三元组数。

$[l, r] \subseteq [i + 1, |T|]$ 的三元组数是容易计算的，实质上就是求每个左端点 $l$ 对应的三元组数量，直接用上一问中的求法即可。

$[l, r] \subseteq [1, i - 1]$ 的限制下，我们需要对每个 $r$ 求出三元组数。实质上只需对于所有 $ans_{*, r}$ 求和，可以使用线段树维护历史和解决。

至此我们以 $\Theta(|T| \log |T|)$ 但是巨大常数的复杂度解决了问题。

> 关于代码：作者偷懒用了二分哈希求 $\text{lcp}$，所以会多出来一个 $\Theta(n |T| \log|S|)$ 的复杂度，当然肯定是可以用字符串算法做到更优的。

```cpp
// Such a destiny was not desired.
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

constexpr int N = 5e5 + 5, Maxl = 5e4 + 5;
int n, K;
char S[12][Maxl]; int LS[12];
char T[N]; int m;
ll res;

constexpr int mod[2] = {998244353, 1004535809};
constexpr int base[2] = {31, 29};
int Pow[2][N];
inline pair<int, int> add(pair<int, int> H, char ch) {
  int x = H.first, y = H.second;
  x = (1ll * x * base[0] + (ch - 'a' + 1)) % mod[0];
  y = (1ll * y * base[1] + (ch - 'a' + 1)) % mod[1];
  return {x, y};
}
struct Hash {
  char *s; int n;
  vector<pair<int, int>> w;
  inline void build() {
    w.resize(n + 1);
    for(int i = 1; i <= n; i++) {
      w[i] = add(w[i - 1], s[i]);
    }
  }
  inline pair<int, int> getH(int l, int r) {
    int x = w[r].first, y = w[r].second;
    x = (mod[0] + x - 1ll * w[l - 1].first * Pow[0][r - l + 1] % mod[0]) % mod[0];
    y = (mod[1] + y - 1ll * w[l - 1].second * Pow[1][r - l + 1] % mod[1]) % mod[1];
    return {x, y};
  }
} HS[12], HT;

int p[N];

struct SparseTable {
  pair<int, int> st[19][N];
  inline void build() {
    for(int i = 1; i <= m; i++) {
      st[0][i] = {p[i] + i, i};
    }
    for(int i = 1; i <= 18; i++) {
      for(int j = 1; j + (1 << i) - 1 <= m; j++) {
        st[i][j] = max(st[i - 1][j], st[i - 1][j + (1 << i - 1)]);
      }
    }
  }
  inline pair<int, int> query(int l, int r) {
    int L = __lg(r - l + 1);
    return max(st[L][l], st[L][r - (1 << L) + 1]);
  }
} st;

// constexpr int maxn = 1000;
// int ans[maxn][maxn];
ll sumL[N], sumR[N];

vector<int> G[N];
int op[N], to[N];

struct SegmentTree {
  int t;
  ll tagc[N << 2], taga[N << 2], c[N << 2], a[N << 2], maxa[N << 2];
  inline void pushdown(int pos, int l, int r) {
    if(taga[pos] == 0 && tagc[pos] == 0) return;
    int mid = (l + r) >> 1;
    c[pos << 1] += tagc[pos] * (mid - l + 1);
    c[pos << 1 | 1] += tagc[pos] * (r - mid);
    a[pos << 1] += taga[pos] * (mid - l + 1);
    a[pos << 1 | 1] += taga[pos] * (r - mid);
    maxa[pos << 1] += taga[pos];
    maxa[pos << 1 | 1] += taga[pos];

    taga[pos << 1] += taga[pos]; 
    taga[pos << 1 | 1] += taga[pos];
    tagc[pos << 1] += tagc[pos];
    tagc[pos << 1 | 1] += tagc[pos];
    tagc[pos] = taga[pos] = 0;
  }
  inline void pushup(int pos) {
    c[pos] = c[pos << 1] + c[pos << 1 | 1]; 
    a[pos] = a[pos << 1] + a[pos << 1 | 1];
    maxa[pos] = max(maxa[pos << 1], maxa[pos << 1 | 1]);
  }
  inline void modify_a(int l, int r, int L, int R, ll k, int pos) {
    if(L <= l && r <= R) {
      a[pos] += (r - l + 1) * k;
      taga[pos] += k;
      maxa[pos] += k;
      return;
    }
    int mid = (l + r) >> 1;
    pushdown(pos, l, r);
    if(L <= mid) modify_a(l, mid, L, R, k, pos << 1);
    if(R > mid) modify_a(mid + 1, r, L, R, k, pos << 1 | 1);
    pushup(pos);
  }
  inline void modify_c(int l, int r, int L, int R, ll k, int pos) {
    if(L <= l && r <= R) {
      c[pos] += (r - l + 1) * k;
      tagc[pos] += k;
      return;
    }
    int mid = (l + r) >> 1;
    pushdown(pos, l, r);
    if(L <= mid) modify_c(l, mid, L, R, k, pos << 1);
    if(R > mid) modify_c(mid + 1, r, L, R, k, pos << 1 | 1);
    pushup(pos);
  }
  inline ll query_a(int l, int r, int L, int R, int pos) {
    if(L <= l && r <= R) return a[pos];
    int mid = (l + r) >> 1; ll ret = 0;
    pushdown(pos, l, r);
    if(L <= mid) ret += query_a(l, mid, L, R, pos << 1);
    if(R > mid) ret += query_a(mid + 1, r, L, R, pos << 1 | 1);
    pushup(pos);
    return ret;
  }
  inline ll query_c(int l, int r, int L, int R, int pos) {
    if(L <= l && r <= R) return c[pos] + t * a[pos];
    int mid = (l + r) >> 1; ll ret = 0;
    pushdown(pos, l, r);
    if(L <= mid) ret += query_c(l, mid, L, R, pos << 1);
    if(R > mid) ret += query_c(mid + 1, r, L, R, pos << 1 | 1);
    pushup(pos);
    return ret;
  }
  inline void modify(int l, int r, int L, int R, int x, int pos = 1) {
    modify_a(l, r, L, R, x, 1);
    modify_c(l, r, L, R, -1ll * t * x, 1);
  }
  inline int get(int l = 1, int r = m, int pos = 1) {
    if(l == r) return l;
    int mid = l + r >> 1; pushdown(pos, l, r);
    if(maxa[pos << 1] == K + 1) return get(l, mid, pos << 1);
    return get(mid + 1, r, pos << 1 | 1);
  }
} sgt;

void dfs(int i) {
  int o;
  if(!to[i]) sgt.modify(1, m, i, m, op[i]);
  else {
    sgt.modify(1, m, i, to[i] - 1, 1);
    o = (sgt.maxa[1] == K + 1 ? sgt.get() : m + 1);
    if(i + p[i] <= o - 1) sgt.modify(1, m, i + p[i], o - 1, 1);
  }
  sgt.t++;
  ll w = 1ll * (m - i + 1) * (K + 1) - sgt.query_a(1, m, i, m, 1);
  sumR[i] = w, res += w;
  // for(int j = i; j <= m; j++) {
  //   sumL[j] += K + 1 - sgt.query_a(1, m, j, j, 1);
  // }
  for(auto u : G[i]) {
    dfs(u);
  }

  if(!to[i]) sgt.modify(1, m, i, m, -op[i]);
  else {
    sgt.modify(1, m, i, to[i] - 1, -1);
    if(i + p[i] <= o - 1) sgt.modify(1, m, i + p[i], o - 1, -1);
  }
}

int main() {
  // freopen("string.in", "r", stdin);
  // freopen("string.out", "w", stdout);
  ios::sync_with_stdio(false);
  cin.tie(nullptr), cout.tie(nullptr);
  
  Pow[0][0] = Pow[1][0] = 1;
  for(int i = 1; i < N; i++) {
    for(int o = 0; o < 2; o++) {
      Pow[o][i] = 1ll * Pow[o][i - 1] * base[o] % mod[o];
    }
  }

  int _; cin >> _ >> n >> K;
  for(int i = 1; i <= n; i++) {
    cin >> S[i] + 1;
    LS[i] = strlen(S[i] + 1);
    HS[i].s = S[i], HS[i].n = LS[i], HS[i].build();
  }
  cin >> T + 1; m = strlen(T + 1);
  HT.s = T, HT.n = m, HT.build();

  for(int i = 1; i <= m; i++) {
    for(int j = 1; j <= n; j++) {
      int l = 1, r = min(m - i + 1, LS[j]), res = 0;
      while(l <= r) {
        int mid = l + r >> 1;
        if(HS[j].w[mid] == HT.getH(i, i + mid - 1)) {
          res = mid;
          l = mid + 1;
        } else {
          r = mid - 1;
        }
      }
      p[i] = max(p[i], res);
    }
  }
  st.build();
  
  // int res = 0;
  for(int i = m; i >= 1; i--) {
    if(p[i] == 0) {
      op[i] = K + 1;
      // fill(ans[i] + i, ans[i] + m + 1, K + 1);
    } else {
      if(i + p[i] > m) op[i] = 1;
      else {
        int t = (st.query(i + 1, i + p[i])).second;
        G[t].push_back(i);
        to[i] = t;
      }
      // for(int j = 1; j <= m; j++) ans[i][j] = ans[t][j] + 1;
      // for(int j = i; j < i + p[i]; j++) ans[i][j] = 1;
    }
    // for(int j = i; j <= m; j++) {
    //   res += max(0, K + 1 - ans[i][j]);
    //   sumL[j] += max(0, K + 1 - ans[i][j]);
    //   sumR[i] += max(0, K + 1 - ans[i][j]);
    // }
  }
  for(int i = m; i >= 1; i--) {
    if(to[i]) continue;
    dfs(i);
  }
  for(int i = 1; i <= m; i++) {
    sumL[i] = 1ll * (K + 1) * i - sgt.query_c(1, m, i, i, 1);
  }

  cout << res << "\n";
  for(int i = 1; i <= m; i++) sumL[i] += sumL[i - 1];
  for(int i = m; i >= 1; i--) sumR[i] += sumR[i + 1];
  for(int i = 1; i <= m; i++) {
    cout << res - sumL[i - 1] - sumR[i + 1] << " \n"[i == m];
  }
}
```

---

## 作者：Petit_Souris (赞：1)

~~第一步：读对题。不要像某些人一样读成非空做了大半天。~~

设 $|T|=m$。

首先因为每个前缀可以为空，所以具有单调性，这个结构还是很不错的。于是我们的主体思路就是对于每个 $(l,k)$，求出最大的 $r$ 满足 $(l,r,k)$ 合法，再对答案进行贡献。

找到最大的 $r$ 是容易的，每次跳最长的前缀就行了。我们设 $nxt_i$ 表示最大的 $j$ 满足 $[i,j]$ 是一个给定 $S$ 的前缀，容易二分 + 哈希预处理。那么我们每次就是跳 $[l,i]$ 中 $nxt$ 最大的，这样跳 $k$ 次。时间复杂度 $\mathcal O(mK)$。

考虑优化。这样的向后跳的结构启发我们倍增优化，但是由于每次要进行一个跟 $l$ 有关的 RMQ，看起来并不好处理。发现我们每次跳到 $nxt_i$ 之后，$[l,i]$ 的 $nxt$ 不会成为下一次的最大值，因此每一步只和上一步相关了。

我们可以建树，记 $pos_i$ 表示 $[i,nxt_i+1]$ 中 $nxt$ 最大的下标，那么 $i$ 向 $pos_i$ 连边。这形成了一个森林（根节点有一个自环），那么我们跳 $k$ 次的过程实际上相当于在这棵树上跳 $k-1$ 次祖先，途中经过的 $k$ 个点（可能重复）对应的 $nxt$ 作为 $k$ 个区间的右端点。

那么这就可以倍增了。先考虑第一问，我们可以设 $f_{i,j}$ 表示从 $i$ 开始跳 $2^j$ 步到哪里，$g_{i,j}$ 表示从 $i$ 开始跳 $2^j$ 步的 $nxt$ 之和，这样就能算答案了。

第二问也是类似的，我们需要给过程中所有点进行若干次区间加等差数列，可以用树上差分维护二阶差分的标记次数，要分类讨论每个点深度是否 $\ge K$（如果 $<K$ 会在自环上跳，要特殊处理）。总时间复杂度 $\mathcal O(nm+m\log m)$。

代码实现的是 $\mathcal O(nm\log m)$ 的，实际上二分哈希的查询容易优化到 $\mathcal O(1)$。

好像写丑了，大家看一乐吧。

```cpp
#include<bits/stdc++.h>
typedef long long ll;
typedef long double ld;
typedef unsigned long long ull;
#define pii pair<ll,ll>
#define rep(i,a,b) for(ll i=(a);i<=(b);++i)
#define per(i,a,b) for(ll i=(a);i>=(b);--i)
using namespace std;
bool Mbe;
ll read(){
    ll x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
void write(ll x){
    if(x<0)putchar('-'),x=-x;
    if(x>9)write(x/10);
    putchar(x%10+'0');
}
const ll N=5e5+9,B=3147;
ll typ,n,K,m,nxt[N],len[11];
ll rg[N],st[20][N],lg[N],dep[N];
ll go[N],up[20][N],sum[20][N];
ll tag[N],tag2[N],s1[N],s2[N],tag3[N],tag4[N],tag5[N],tag6[N];
char s[11][50009],t[N];
ull preh[11][50009],pw[N],th[N];
vector<ll>to[N];
ull Ht(ll l,ll r){
    return th[r]-th[l-1]*pw[r-l+1];
}
ll Query(ll l,ll r){
    r=min(r,m);
    ll p=lg[r-l+1];
    if(rg[st[p][l]]>rg[st[p][r-(1<<p)+1]])return st[p][l];
    return st[p][r-(1<<p)+1];
}
bool Med;
int main(){
    cerr<<fabs(&Med-&Mbe)/1048576.0<<"MB\n";
    typ=read(),n=read(),K=read();
    rep(i,1,n)scanf("%s",s[i]+1),len[i]=strlen(s[i]+1);
    scanf("%s",t+1),m=strlen(t+1);
    rep(i,1,n){
        rep(j,1,len[i])preh[i][j]=preh[i][j-1]*B+s[i][j];
    }
    pw[0]=1;
    rep(i,1,m)pw[i]=pw[i-1]*B,th[i]=th[i-1]*B+t[i];
    rep(i,1,m){
        ll l=i,r=m,pos=i-1;
        while(l<=r){
            ll mid=(l+r)>>1;
            ull H=Ht(i,mid);
            bool fl=0;
            rep(j,1,n){
                if(mid-i+1<=len[j]&&preh[j][mid-i+1]==H){
                    fl=1;
                    break;
                }
            }
            if(fl)pos=mid,l=mid+1;
            else r=mid-1;
        }
        rg[i]=pos;
    }
    rep(i,1,m)st[0][i]=i;
    rep(i,2,m)lg[i]=lg[i>>1]+1;
    rep(k,1,lg[m]){
        rep(i,1,m-(1<<k)+1){
            if(rg[st[k-1][i]]>rg[st[k-1][i+(1<<(k-1))]])st[k][i]=st[k-1][i];
            else st[k][i]=st[k-1][i+(1<<(k-1))];
        }
    }
    rep(i,1,m)go[i]=Query(i,rg[i]+1);
    per(i,m,1)dep[i]=dep[go[i]]+1;
    rep(i,1,m)up[0][i]=go[i],sum[0][i]=rg[i];
    rep(k,1,19){
        rep(i,1,m){
            up[k][i]=up[k-1][up[k-1][i]];
            sum[k][i]=sum[k-1][up[k-1][i]]+sum[k-1][i];
        }
    }
    ll ans=0;
    rep(i,1,m){
        ll u=i,sm=0;
        per(k,19,0){
            if((K>>k)&1)sm+=sum[k][u],u=up[k][u];
        }
        if(dep[i]>K){
            tag[i]++,tag[u]--;
            tag4[i]-=i-2,tag4[u]+=i-2;
            tag5[i]--,tag5[u]++;
            tag6[i]+=i-1,tag6[u]-=i-1;
            tag3[i]+=i-2,tag3[u]-=i-2;
            tag2[i]--,tag2[u]++;
        }
        else {
            tag[i]++,tag[u]+=(K-dep[i]);
            tag4[i]-=i-2,tag4[u]-=(K-dep[i])*(i-2);
            tag5[i]--,tag5[u]-=(K-dep[i]);
            tag6[i]+=i-1,tag6[u]+=(K-dep[i])*(i-1);
            tag3[i]+=i-2,tag3[u]+=(K-dep[i])*(i-2);
            tag2[i]--,tag2[u]-=(K-dep[i]);
        }
        ll sumlen=sm-K*(i-1);
        ans+=sumlen;
        s1[i]+=sumlen+K,s2[i]-=K;
    }
    write(ans),putchar('\n');
    rep(i,1,m){
        if(go[i]^i){
            tag[go[i]]+=tag[i];
            tag2[go[i]]+=tag2[i];
            tag3[go[i]]+=tag3[i];
            tag4[go[i]]+=tag4[i];
            tag5[go[i]]+=tag5[i];
            tag6[go[i]]+=tag6[i];
        }
    }
    rep(i,1,m){
        s2[rg[i]+1]+=rg[i]*tag[i]+tag4[i];
        s2[rg[i]+2]+=rg[i]*tag5[i]+tag6[i];
        s1[rg[i]+1]+=rg[i]*tag2[i]+tag3[i];
    }
    rep(i,1,m)s2[i]+=s2[i-1];
    rep(i,1,m)s1[i]+=s1[i-1],s2[i]+=s2[i-1];
    rep(i,1,m)write(s1[i]+s2[i]),putchar(' ');
    cerr<<"\n"<<clock()*1.0/CLOCKS_PER_SEC*1000<<"ms\n";
    return 0;
}
```

---

## 作者：nullqtr_pwp (赞：1)

### P11291

dp 优化题，需要发掘一下转移的性质。

令 $n=|T|$。首先将字符串的限制转化掉，可以使用二分哈希的方法处理出 $t[i:n]$ 与某个 $S_i$ 的 $\text{lcp}$，我们显然只关心 $\max$，令这个最大值为 $g_i$，那么就要求如果以 $i$ 开头，那么这个 $R$ 的结尾必须落在 $[i,i+g_i)$ 之中。先考虑如何判定合法，从前缀匹配是存在后效性的，但是可以转换维度，从后缀开始消。先考虑 $70$ 分做法（我的赛时做法）：注意到对于一个固定的 $l,k$，合法的 $r$ 是一段前缀，因此可以定义域值域互换，维护 $f_{k,l}$ 表示对于固定的 $k,l$，最大的 $r$ 使得 $(l,r,k)$ 合法。转移考虑枚举 $k$ 然后从 $f_{*,k-1}$ 进行转移，可以倒序枚举 $i$ 从 $n$ 到 $1$，然后树状数组维护 $[i,i+g_i)$ 中最大的 $f_{*,k-1}$，可以做到 $\mathcal O(nk\log n)$，第二问可以在此过程中维护区间加一次函数，进行离线并使用二次差分维护。

一个废话是 $f$ 的具体值一定是某个 $i+g_i-1$ 的值，对于 $f_{l,k}$ 我们将这个 $i$ 记作 $R_{l,k}$（$R$ 是单词 $\text{Real}$ 的简写，与题面中的 $R$ 没有任何关系），即 $f_{l,k}=g_{R_{l,k}}$。考虑对这个 dp 进行优化，对于 $k$ 很大时我们显然无法直接求，考虑发掘一下转移的性质，一个事情是你可以将 $f$ 视为线段拓展一样的东西，就是要求从 $l$ 拓展 $k$ 次，每次拓展的左端点必须落在当前已有区间之中。显然你每次都会去贪心选取最优的转移点（即 $j+g_j$ 最大的点），一个结论就是，在不考虑无法拓展时，每次选取的位置一定在新拓展的部分之中。证明是显然的，如果不在，在本次拓展你会直接选取这个点而不是在下一次拓展再选取。首先有 $R_{i,1}=i$，其次考虑 $[i,i+g_i)$ 中的最大值位置 $p$，那么就一定对于任意 $k$ 有 $R_{i,k}=R_{p,k-1}$，因为你其实可以看成是在左边拓展这个线段。

此时 $k$ 的具体值是无用的，我们只关心从 $i$ 开始不断跳 $p$ 跳 $k$ 次可以跳到哪里，不难想到建立边 $i\to p$，此时这张图在不考虑根的自环时是个森林。$R_{i,k}$ 即为 $i$ 的 $\min(\text{dep}_i,k)$ 级祖先。第一问就是对到 $k$ 级祖先的路径的 $g_{i}$ 进行求和，由于 $k$ 是固定的，所以容易拆贡献进行一些分讨维护。第二问就是考虑在暴力时你会进行二次差分的修改，具体而言你会对于 $x\in[l,r]$ 加上一个函数 $y=(r-l+1)-(x-l)$，你会对二阶差分的数组进行四次单点修改。在前缀和意义也是容易维护的。时间复杂度 $\mathcal O(n\log n+nm\log n)$。

---

## 作者：wrkwrkwrk (赞：1)

先考虑如何对一个三元组 $(l,r,k)$ 进行判断：

从左向右考虑，每次从目前已经包括的区域贪心地选取尽可能后的串。之后和 $k$ 比较即可（可以塞空串）。

显然可以固定左端点，贪心对每个 $(l,r)$ 求得最小的 $k$ 满足条件。并且可知当 $l$ 一定，最小的 $k$ 具有单调性。

发现对贪心取得的序列贪心拓展是简单的。考虑每次把扩展的答案进行计数。

一段区间 $l=L,r\in [L,R)$ 在 $k$ 固定时，对总答案的贡献为 $R-L$，对 $ans_i,i\in [L,R)$ 的贡献为 $R-i$。可以通过二阶差分进行计算，时间复杂度 $O(nk)$。

考虑我们如何计算这个二阶差分：对 $\Delta^2_l $ ，$\Delta^2 _{l+1}$，$\Delta^2_{r+1}$ 分别存在赋值。
第一项加上 $R-L$，第二项减去 $R-L+1$，第三项加上 $1$。

先处理第一项：其为 $\sum (R -L)=\sum R-k L$。

考虑每次贪心扩展的过程：找到最大的扩展区域，并在新扩展区域找到下一步可能最大的扩展区域。

“找到最大”可以 ST 表。以上过程可以倍增：跳 $2^k$ 步骤的位置和 $\sum R$。

第二项类似。现在考虑第三项：再次考虑跳的过程：其相当于有一些起点，每次往一个位置赋值并且跳，每个点都跳 $k$ 步。

可能在某一步骤开始不动。考虑跳 $k$ 步后的终点，其可能被作为保持不动的点进行若干轮次。于是处理出第一次到终点的步骤数，起点 $+1$，终点 $-1$，终点之后的打转先算，剩下的从左向右扫即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
bool st;
namespace _wrk{;
#define int long long
string s[500005],t;
int sl[500005];
unsigned long long bas[500005],tb[500005];
const int base=41;
vector<int>nex[500005];
int maxr[500005];
int st[20][500005];
int stp[20][500005];
int gemax(int l,int r){
	int le=r-l+1,p=__lg(le);
	return max(st[p][l],st[p][r-(1ll<<p)+1]);
}
int gemaxpos(int l,int r){
	int le=r-l+1,p=__lg(le);
	if(gemax(l,r)==st[p][r-(1ll<<p)+1])return stp[p][r-(1ll<<p)+1];
	else return stp[p][l];
}
int pans,ans[500005],dans[500005],ddans[500005];
int nec[500005][21],suc[500005][21];
int pk[500005];
//int nec[500005][20];
signed main(){
//	freopen("a.in","r",stdin);
//	freopen("a.out","w",stdout);
	bas[0]=1;
	for(int i=1;i<=500001;i++)bas[i]=bas[i-1]*base;
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	int id,n,k;
	cin>>id>>n>>k;
	for(int i=1;i<=n;i++){
		cin>>s[i];
		sl[i]=s[i].length();
		s[i]='&'+s[i]+'&';
	}
	cin>>t;
	int m=t.length();
	t='$'+t+'$';
	for(int i=1;i<=m;i++){
		maxr[i]=i;
		tb[i]=tb[i-1]*base+t[i]-'a'+1;
	}
	for(int i=1;i<=n;i++){
		nex[i].resize(s[i].size());
		nex[i][0]=0;
		for(int j=1;j<=sl[i];j++){
			nex[i][j]=nex[i][j-1]*base+s[i][j]-'a'+1;
		}
		for(int j=1;j<=m;j++){
			int l=0,r=sl[i]+1;
			while(l+1<r){
				int mid=(l+r)>>1;
				if(j+mid-1<=m&&nex[i][mid]==tb[j+mid-1]-tb[j-1]*bas[mid])l=mid;
				else r=mid;
			}
			maxr[j]=max(maxr[j],j+l);
//			cout<<l<<' '<<r<<endl;
		}
	}
	maxr[m+1]=m+1;
	for(int i=1;i<=m+1;i++){
		st[0][i]=maxr[i];
		stp[0][i]=i;
	}
	for(int j=1;j<=20;j++){
		for(int i=1;i+(1ll<<j)-1<=m+1;i++){
			st[j][i]=max(st[j-1][i],st[j-1][i+(1ll<<(j-1))]);
			if(st[j-1][i]>st[j-1][i+(1ll<<(j-1))])stp[j][i]=stp[j-1][i];
			else stp[j][i]=stp[j-1][i+(1ll<<(j-1))];
		}
	}
	nec[m+1][0]=m+1;
	suc[m+1][0]=m+1;
	for(int i=1;i<=m;i++){
		nec[i][0]=gemaxpos(i,maxr[i]);
		suc[i][0]=maxr[i];
	}
	for(int j=1;j<=20;j++){
		for(int i=1;i<=m+1;i++){
			
			nec[i][j]=nec[nec[i][j-1]][j-1];
			suc[i][j]=suc[i][j-1]+suc[nec[i][j-1]][j-1];
//			cout<<i<<' '<<j<<' '<<nec[i][j]<<' '<<suc[i][j]<<endl;
		}
	}
	for(int l=1;l<=m;l++){
		int r=l;
		int su=0;int kk=k;
//		cout<<l<<' '<<kk<<endl;
		for(int j=20;j>=0;j--){
			while(kk>=1ll<<j){
//				cout<<r<<' '<<j<<' '<<' '<<suc[r][j]<<endl;
				su+=suc[r][j];
				r=nec[r][j];
				kk-=1ll<<j;
			}
		}
//		cout<<r<<endl;
		pans+=su-l*k;
		ddans[l]+=su-l*k;
		ddans[l+1]-=su-l*k+k;
		pk[l]++;
		int p=r;r=l;
		int ste=0;
		for(int i=20;i>=0;i--){
			while((ste+(1ll<<i))<=k&&nec[r][i]!=p){
				ste+=1ll<<i;
				r=nec[r][i];
			}
		}
		if(r!=p)ste++;
		pk[p]--;
//		cout<<l<<' '<<r<<' '<<p<<endl;
		ddans[maxr[p]+1]+=k-ste;
		
	}
//	for(int i=1;i<=m;i++){
//		cout<<pk[i]<<' ';
//	}
	for(int i=1;i<=m;i++){
		ddans[maxr[i]+1]+=pk[i];
		pk[nec[i][0]]+=pk[i];
	}
	cout<<pans<<'\n';
	for(int i=1;i<=m;i++){
//		cout<<ddans[i]<<' ';
		dans[i]=dans[i-1]+ddans[i];
		ans[i]=ans[i-1]+dans[i];
		cout<<ans[i]<<' ';
	}
	return 0;
}
}
bool en;
signed main(){
	#ifdef LOCAL_WRK
	cerr<<"[Static Memory : "<<fixed<<((&st)-(&en))/1048576.0<<"MB]"<<endl;
	#endif
	   return _wrk::main();
}
```

[AC](https://www.luogu.com.cn/record/189450433) 记录。

---

## 作者：123456xwd (赞：0)

设 $m=\left|T\right|$。

显然，若有二元组 $(l,r,k)$，那么必然有 $(l,r,k+1)$，设 $dp_{l,r}$ 表示二元组 $(l,r,x)$ 中最小的 $x$。

设 $to_i$ 表示最大的 $j$，满足 $T_{i\cdots j}$ 为一个 $S$ 的前缀，显然对于 $k\in[i,to_i]$，$T_{i\cdots k}$ 都满足条件，没有的话设置为 $i-1$，表示空串，可以简单二分求得。

转移显然，为：$dp_{l,r}=\min_{l<i\le \min(to_l,r)+1}(f_{i,r})+1$。

但是接下来似乎没有优化空间了，考虑 $K$ 较小的时候的部分分，设 $f_{l,k}$ 表示最大的 $r$，满足 $(l,r,k)$ 为合法区间，显然对于 $r'\in[l,r]$ 随之也都满足。

考虑转移，显然为：$f_{l,k}=\max_{l\le i\le f_{l,k-1}+1}(f_{i,1})$。

而 $f_{i,1}$ 实际上就是 $to_i$，方便起见设 $f_{m+1,1}=m$。

那么转化为 RMQ 问题，简单的 ST 表维护即可。

考虑如何统计答案，对于答案 1，为 $\sum_{i=1}^{m}\sum_{j=1}^K f_{i,j}-i+1$。

对于答案 2，若枚举到了 $f_{i,j}$，那么相当于对于 $[i,i]$ 加上1，$[i,i+1]$ 加上 1，以此类推。

考虑维护二维差分数组 $c$，相当于 $c_i\gets f_{i,j}-i+1,c_{i+1}\gets -(f_{i,j}-i+1),c_{i+1}\gets -1,c_{f_{i,j}+2}\gets 1$

如何进一步的优化呢？

我们发现，第一维不同的 $f$ 互不干扰，设现在考虑 $f_{l,?}$。

我们知道，$f_{l,1}=to_l$，而转移到 $f_{l,2}$ 的时候，相当于在 $[l,f_{l,1}+1]$ 中找一个 $to_j$ 最大的 $j$，然后进一步的转移。

然后，我们可以发现这个 $j$ 一定是单调不降的，也就是说每次 $f_{l,k-1}=to_j$ 的时候，若要转移到 $f_{l,k}$，新的 $j$ 一定是 $[j,to_j+1]$ 中满足 $to_{j'}$ 最大的 $j'$。

那么设 $fa_i$ 表示满足 $j\in[i,to_i+1]$ 且 $to_j$ 最大的 $j$。

那么建立一个 $fa_i\to i$ 的边，这样子建立出来基环树森林，且环为自环，所谓的 dp 转移其实就是在这个森林上面跳。

然后考虑答案如何统计，比较麻烦。

先考虑答案 1，那么贡献其实是 $K\times \left|T\right|-K\times\frac{(m+1)m}{2}+\sum \sum f_{i,j}$，而 $f_{i,j}$ 可以树上倍增简单计算 $to_i$ 的和。

考虑答案 2，设 $sum_u=\sum f_{u,i}-i+1,val_u=\text{u被跳到的次数}$，前者在求答案 1 的时候顺带求得，后者树上差分求得，需要注意的是一个子孙节点可能对一个根节点有多次的贡献。

那么类似上面维护 $c$ 的，此时对于 $c$ 的贡献为：$c_i\gets sum_i,c_{i+1}\gets -sum_i,c_{i+1}\gets -K,c_{to_i+2}\gets val_i$。


```c++
#include<bits/stdc++.h>
#define ull unsigned long long
#define int long long
#define p_b push_back
#define m_p make_pair
#define pii pair<int,int>
#define fi first
#define se second
#define ls k<<1
#define rs k<<1|1
#define mid ((l+r)>>1)
#define gcd __gcd
#define lowbit(x) (x&(-x))
using namespace std;
int rd(){
    int x=0,f=1; char ch=getchar();
    for(;ch<'0'||ch>'9';ch=getchar())if (ch=='-') f=-1;
    for(;ch>='0'&&ch<='9';ch=getchar())x=(x<<1)+(x<<3)+(ch^48);
    return x*f;
}
void write(int x){
    if(x>9) write(x/10);
    putchar('0'+x%10);
}
const int N=5e5+5,INF=0x3f3f3f3f;
const ull p=13331;
int n,m,K,len[11],ans;
char S[11][N],T[N];
ull pn[N],Ha[N],Has[11][N];
int to[N],dad[N],c[N],val[N],sum[N],fa[N][20],s[N][20],tag[N];
int st[N][20],lg[N];
int Max(int u,int v){return to[u]>to[v]?u:v;}
int ask(int l,int r){
    int k=lg[r-l+1];
    return Max(st[l][k],st[r-(1<<k)+1][k]);
}
vector<int> G[N];
bool vis[N];int deep[N];
void dfs(int u){
    fa[u][0]=dad[u],s[u][0]=to[u],vis[u]=1,deep[u]=deep[dad[u]]+1;
    for(int i=1;i<=19;i++) s[u][i]=s[u][i-1]+s[fa[u][i-1]][i-1],fa[u][i]=fa[fa[u][i-1]][i-1];
    for(auto v : G[u]) dfs(v);
} 
void DFS(int u){
    vis[u]=1;
    for(auto v : G[u]) DFS(v),val[u]+=val[v];
}
bool check(int x,int len){
    ull tmp=Ha[x+len-1]-Ha[x-1]*pn[len];
    for(int i=1;i<=n;i++) if(tmp==Has[i][len])return 1;
    return 0;
}
signed main(){
    int id=rd();n=rd(),K=rd();
    for(int i=1;i<=n;i++){
        scanf("%s",S[i]+1);len[i]=strlen(S[i]+1);
        for(int j=1;j<=len[i];j++) Has[i][j]=Has[i][j-1]*p+(S[i][j]-'a'+1);
    }
    scanf("%s",T+1);m=strlen(T+1);
    for(int i=1;i<=m;i++)Ha[i]=Ha[i-1]*p+(T[i]-'a'+1);
    pn[0]=1;for(int i=1;i<N;i++)pn[i]=pn[i-1]*p;
    for(int i=1;i<=m;i++){
        int l=1,r=m-i+1,res=0;
        while(l<=r){
            if(check(i,mid))res=mid,l=mid+1;
            else r=mid-1;
        }
        to[i]=i+res-1,st[i][0]=i;
    }
    to[m+1]=m,lg[1]=0;
    for(int i=2;i<=m;i++)lg[i]=lg[i>>1]+1;
    for(int j=1;j<=19;j++){
        for(int i=1;i+(1<<j)-1<=m;i++) st[i][j]=Max(st[i][j-1],st[i+(1<<(j-1))][j-1]);
    }
    for(int i=1;i<=m;i++)dad[i]=ask(i,min(m,to[i]+1));
    for(int i=1;i<=m;i++) if(dad[i]!=i)G[dad[i]].p_b(i);
    for(int i=m;i>=1;i--) if(!vis[i]) dfs(i);
    memset(vis,0,sizeof(vis));
    for(int i=1;i<=m;i++){
        int res=0,u=i;
        for(int j=0;j<=19;j++) if((K>>j)&1) res+=s[u][j],u=fa[u][j];
        ans+=res,sum[i]=res-i*K+K;
        val[i]++,val[u]--;
        if(deep[i]<=K) tag[u]+=K-(deep[i]-1); 
    }
    ans+=K*m-(m+1)*m/2*K;
    for(int i=m;i>=1;i--) if(!vis[i]) DFS(i);
    for(int i=1;i<=m;i++) val[i]+=tag[i],c[i]+=sum[i],c[i+1]-=sum[i],c[i+1]-=K,c[to[i]+2]+=val[i];
    for(int i=1;i<=m;i++) c[i]+=c[i-1];
    for(int i=1;i<=m;i++) c[i]+=c[i-1];
    printf("%lld\n",ans);
    for(int i=1;i<=m;i++) printf("%lld ",c[i]);
    return 0;
}
```

---


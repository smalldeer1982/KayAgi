# 加工生产调度

## 题目描述

某工厂收到了 $n$ 个产品的订单，这 $n$ 个产品分别在 A、B 两个车间加工，并且必须先在 A 车间加工后才可以到 B 车间加工。

某个产品 $i$ 在 A、B 两车间加工的时间分别为 $A_i,B_i$。怎样安排这 $n$ 个产品的加工顺序，才能使总的加工时间最短。

这里所说的加工时间是指：从开始加工第一个产品到最后所有的产品都已在 A、B 两车间加工完毕的时间。


## 说明/提示

$1\leq n\leq 1000$。

## 样例 #1

### 输入

```
5
3 5 8 7 10
6 2 1 4 9
```

### 输出

```
34
1 5 4 2 3
```

# 题解

## 作者：花里心爱 (赞：221)

### P1248 题解
感觉之前的题解都太复杂了……

读完题后，我们可以发现，这道题中的决策无后效性，可以用贪心来解。

### 如何确定贪心的顺序

首先，我们假设只有$2$个产品，在$A$车间加工的时间为$a1,a2$，在$B$车间加工的时间为$b1,b2$。我们假设先加工产品$1$的方案较优

如果先加工$1$，再加工$2$，所需时间即为最后加工完$2$所需的时间。也就是 $a1+\max(b1,a2)+b2$。

反过来，如果先加工$2$，再加工$1$，所需时间为 $a2+max(b2,a1)+b1$。

因为我们假设了先加工产品$1$的方案较优，所以前一种方案的时间更少，也就是 $a1+\max(b1,a2)+b2 < a2+\max(b2,a1)+b1$ 。

移项，得到 $\max(b1,a2)-a2-b1 < \max(b2,a1)-b2-a1$

然后我们发现不等式两边较大的数都被消掉了，原式即为 $-\min(b1,a2)<-\min(b2,a1)$

也就是$\min(a1,b2)<\min(a2,b1)$

可以用贪心思想排序的题都有这么一条性质：如果$2$个物品按某种方法排序时结果较优，那么多个物品按这种方法排序时结果一定最优。

式子化不化简对于结果没有影响，下面是用$a1+\max(b1,a2)+b2 < a2+\max(b2,a1)+b1$ 排序的代码（洛谷上能A，但是方法是错的）
```
struct node{
	long long a,b;  //在两个车间分别加工的时间
	int in; //原来的下标
	bool operator<(const node &x)const{
		return a+max(b,x.a)+x.b < x.a+max(x.b,a)+b;//重载小于运算符，用于sort
	}
}c[1005];

sort(c+1,c+n+1);
```
### 为什么刚才的方法是错的
~~因为$\sout{\min(a1,b2)<\min(a2,b1)}$中，不等关系不具有传递性。~~

表示我翻了一下网上的题解发现都是这么说的，不过后来我手动模拟~~分类讨论逐一判断~~了一下发现这个式子具有传递性。

不等式的传递性是指：有3个元素$x,y,z$和不等关系（此处设为$a<b$），当$x<y$且$y<z$时，$x<z$一定成立。

那么，基于上面的公式排序后，所有相邻的元素都满足$\min(a1,b2)<\min(a2,b1)$时，最终结果是正确的。

下面我们考虑$\min(a1,b2)=\min(a2,b1)$的情况。设有3个工件$x,y,z$，我们发现当$\min(x.a, y.b) = \min(x.b, y.a)$且$\min(y.a, z.b) = \min(y.b, z.a)$时，$\min(x.a, z.b) = \min(x.b, z.a)$不一定成立。

举个栗子：$x.a = 3, x.b = 5, y.a = 1, y.b = 1, z.a = 6, z.b = 4$

如果有3个元素$x,y,z$和不等关系（此处设为$a<b$），当$x<y, y<x$与$y<z, z<y$均不成立时，$x<z$与$z<x$一定不成立，这叫做不可比性的传递性。

（你可以暂时理解为有三个数均相等，这是不可比性的传递性的一个例子。）

而在排序时的不等关系除了要满足传递性外，还要满足不可比性的传递性。所以不能够直接用$\min(a1,b2)<\min(a2,b1)$排序。

（如果你对于上述说明还不能完全理解，可以参考一下dalao ouuan的文章 [浅谈邻项交换排序的应用以及需要注意的问题](https://ouuan.github.io/%E6%B5%85%E8%B0%88%E9%82%BB%E9%A1%B9%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F%E7%9A%84%E5%BA%94%E7%94%A8%E4%BB%A5%E5%8F%8A%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E9%97%AE%E9%A2%98/) %%%ouuan tql）

---
所以我们要找出一个具有不可比性的传递性的式子

分析一下这个式子，我们发现这与两个元素$a,b$的大小有关 :

1. $a1<b1$且$a2<b2$时，按$a1<a2$排序。

2. $a1=b1$且$a2=b2$时，如何排序对结果没有影响。

3. $a1>b1$且$a2>b2$时，按$b2<b1$排序。

然后我们发现上面的不等式要优先找a比b小的，所以将上面的3种情况按顺序排即可。

于是我们设$d_i=\begin{cases}-1&a_i<b_1\\0&a_i=b_i\\1&a_i>b_i\end{cases}$

（也就是$a_i-b_i$的符号）

以d为第一关键字，d相等的按上面的规则排序即可。

这有个名词叫做`Johnson 法则`

排序代码 :
```
	bool operator<(const node &x)const{
		if(d==x.d){
			if(d<=0)return a<x.a;//这里的等于是将上面的情况2找了一种方法排序
			else return b>x.b;
		}
		return d<x.d;
	}
```
然后，这道题需要我们求出总共需要的时间。按题意模拟一下即可。
```
	fa=c[1].a;fb=c[1].a+c[1].b;//fa为i在车间A加工完需要的时间，fb为i在车间B加工完需要的时间
	for(int i=2;i<=n;++i){
		fb=max(fa+c[i].a,fb)+c[i].b;//i开始在车间B加工时，需要先在车间A加工完成，而且i-1需要完成在车间B的工序
        fa+=c[i].a;
	}
```

---

## 作者：_ztyqwq (赞：54)

分享一种跟大家有一点小差别的思路。

这个题其实是个数学题？~~我以前在看一本叫《数学花园漫游记》的书的时候见到过这个问题并且它把解法讲得非常清楚我就是写了下来233~~

首先，按照常规的贪心做法。考虑两个产品 $ i, j $。如果按照 $ i, j $ 的顺序，那么有两种情况，我们分别画图解释：

①![1](https://cdn.luogu.com.cn/upload/pic/51281.png)

这种情况下 $ A_j <= B_i $，总时间 $ = A_i + B_i + B_j $。

②![2](https://cdn.luogu.com.cn/upload/pic/51282.png)

这种情况下 $ A_j > B_i $，总时间 $ = A_i + A_j + B_j $。

~~（给SketchPad打广告？）~~

整理得到**总时间 $ = A_i + max(A_j, B_i) + B_j $**

$ = tot - min(A_j, B_i) $，其中 $ tot = A_i + A_j + B_i + B_j $。

同理若按照 $ j, i $ 的顺序，总时间 $ = tot - min(A_i, B_j) $。

**所以 $ i, j $ 比 $ j, i $ 更优或一样 $ \Longleftrightarrow min(A_i, B_j) \leqslant min(A_j,B_i) $。**

然后常规思路就排序了。但是像各位大神所说，这个式子似乎没有传递性。~~所以他们就用了各种神奇的方法进行变形然后成功地搞出了正解碾压了标算Orz~~

然鹅这里有另外一种的思路：

找出 $ A, B $ 两个数组剩余数的最小数，如果：

① **它在 $ A $ 数组中**。不妨设它为 $ A_i $。如果 $ i $ 号产品已经被安排过，则跳过。否则**将 $ i $ 号产品安排到剩余可供安排的位置的最前面**，将 $ A_i $ 号删除。

② **它在 $ B $ 数组中**。不妨设它为 $ B_i $。对称地，如果 $ i $ 号产品已经被安排过，则跳过。否则**将 $ i $ 号产品安排到剩余可供安排的位置的最后面**，将 $ B_i $ 号删除。

然后回到前面继续找最小数直到所有产品都被安排。

为什么这样做是对的呢？我们讨论一下，在剩余数中：

① 如果 $ A_i $ 最小，那么**对于任何剩余的产品 $ j $，都有 $ min(A_i, B_j) \leqslant min(A_j, B_i) $，所以 $ i $ 要排在 $ j $ 前面。所以 $ i $ 应该排在剩余位置的最前面。**注意这里并没有用到传递性。这一步是因为 $ i $ 始终应该排在它前面一个的前面，所以它只能排在第一个。

② 如果 $ B_i $ 最小，对称地，**对于任何剩余的产品 $ j $，都有 $ min(A_j, B_i) \leqslant min(A_i, B_j) $，所以 $ j $ 要排在 $ i $ 前面。所以 $ i $ 应该排在剩余位置的最后面。**

所以上述思路正确，可以得出一个正确的顺序。

最后就是计算总时间了。我们可以看图，用 $ ta $ 表示 $ A $ 车间当前总时间，$ tb $ 表示 $ B $ 车间当前的总时间。那么对于第 $ i $ 个产品，$ A $ 车间可以直接生产，$ ta += A_i $；而 $ B $ 车间不一定，**它开始生产的时间应该是 $ A $ 生产完 $ i $ 的时间与 $ B $ 生产完 $ i - 1 $ 的时间的最大值，即 $ tb = max(tb, ta) $。**最后 $ B $ 生产 $ i $，$ tb += B_i $。

代码细节：$ p[i] $ 代表一个数，$ num $ 属性是数值，$ ind $ 属性是它代表的产品编号，$ sign $ 属性代表它是 $ A $ 数组的还是 $ B $ 数组的（$ A $ 为 $ true $，$ B $ 为 $ false $）。$ l, r $ 分别维护剩余队列的左右端点。

上代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
struct number
{
	int num,ind;
	bool sign;
	bool operator<(const number& ano)const
	{
		return num<ano.num;
	}
}p[2001];
int a[1001],b[1001],s[1001];
bool vis[1001];
int main()
{
	int n;
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&a[i]);
		p[i].num=a[i];
		p[i].ind=i;
		p[i].sign=true;
	}
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&b[i]);
		p[i+n].num=b[i];
		p[i+n].ind=i;
		p[i+n].sign=false;
	}
	sort(p+1,p+2*n+1);
	int l=1,r=n;
	for(int i=1;i<=2*n;i++)
	{
		if(vis[p[i].ind])
			continue;
		vis[p[i].ind]=true;
		if(p[i].sign)
			s[l++]=p[i].ind;
		else
			s[r--]=p[i].ind;
		if(l>r)
			break;
	}
	int ta=0,tb=0;
	for(int i=1;i<=n;i++)
	{
		ta+=a[s[i]];
		tb=max(tb,ta);
		tb+=b[s[i]];
	}
	printf("%d\n",tb);
	for(int i=1;i<=n;i++)
		printf("%d ",s[i]);
	putchar('\n');
	return 0;
}
```

---

## 作者：agicy (赞：39)

首先，声明一点

**第一篇题解的思路完全正确，但缺乏证明**

***

---


第一篇题解的思路：
>by ljc20020730

>n个作业要在由两台机器M1和M2组成的流水线上完成加工．每个作业i必须先在M1上然后在M2上加工，时间分别为ai和bi。

>确定这n个作业的加工顺序，使得从第一个任务开始在M1上加工到最后一个任务在M2上加工完成的总时间尽量小。
直观上，最优调度一定让M1没有空闲，M2的空闲时间尽量少。

提供的算法:

>①使用数组f1[j] 存放a[i]<b[i]的作业；

>②使用数组f2[k] 存放a[i]>=b[i]的作业;

>③对f1[j]根据a[j]进行升序排列;

>④对f2[k]根据b[k]进行降序排列;

>⑤遍历两个数组，依次求时间:取两个机器运行时间的较大值作为作业用时。
程序易于实现，时间O(nlogn)，关键在于正确性证明。

***

***

下面是我给出的**证明**

设$S=${$J_1,J_2$···$J_n$}，为待加工部件的作业排序，若$A$机器开始加工$S$中的部件时，$B$机器还在加工其他部件，$t$时刻后$B$机器可加工$A$机器加工过的部件。在这样的条件下，加工$S$中任务的最短时间$T(S,t)=${$a_i+T(S-${$J_i$}$,b_i+max${$t-a_i,0$}$)$}。

设最佳的方案中，现加工作业$J_i$，然后加工作业$J_j$，则


$T(S,t)=a_i+T(S-${$J_i$}$,b_i+max${$t-a_i,0$}

$=a_i+a_j+T(S-${$j_i,J_j$}$,b_j+max${$t-a_i,0$}$-a_j,0$}$)$

$=a_i+a_j+T(S-${$J-i,J_j$}$,T_{ij})$

所以

$T_{ij}=$ $\begin{cases}t+b_i+b_j-a_i-a_j(if(max(t,a_i,a_i+a_j-b_i)==t))\\b_i+b_j-a_j(if(max(t,a_i,a_i+a_j-b_i)==a_i))\\b_j(if(max(t,a_i,a_i+a_j-b_i)==a_j-b_i))\end{cases}$

将工作顺序调换，则同理可得

$T_{ji}=b_i+b_j-a_i-a_j+max${$t,a_i,a_i+a_j-b_j$}

又因为假设
>现加工作业$J_i$，然后加工作业$J_j$是最佳情况

所以

$max${$t,a_i,a_i+a_j-b_j$}$≤$ $max${$t,a_i,a_i+a_j-b_i$}

即

$min${$b_j,a_i$}$≤min${$b_i,a_j$}

所以按照上面的操作符合证明结果，可以得到最优解，证明完毕。

Q：那为什么这样做得到$24$分。
A：这道题出得不好，未开启$SPJ$，排序时不能使用不稳定的排序方法，如快速排序，所以用了```std::sort();```的人全都只有$24$分。

总的来说，这道题有毒，不推荐大家尝试。

[我的60分测评记录](https://www.luogu.org/record/show?rid=8040707)

$60$分，代码如下

```
#include<stdio.h>
struct Node{
    int M,ID;
    bool operator<=(Node a){
        return this->M<=a.M;
    }
    Node operator=(Node a){
        this->M=a.M;
        this->ID=a.ID;
    }
};
int n,A[1000],B[1000],ans[1000],index1,index2,time1,time2,i,j;
Node C[1000],temp;
/*
Memory=20,036 Byte=19.566,406,25 KB
*/ 
int min(int a,int b){
    return a<b?a:b;
}
void swap(Node &a,Node &b){
    temp=a,a=b,b=temp;
    return;
}
int main(void){
    scanf("%d",&n);
    for(i=0;i<n;i++)
        scanf("%d",&A[i]);
    for(i=0;i<n;i++)
        scanf("%d",&B[i]),
        C[i].M=min(A[i],B[i]),
        C[i].ID=i;
    //下面是超级稳定的排序算法，O(n^2)
    for(i=0;i<n-1;i++)
        for(int j=i+1;j<n;j++)
            if(C[i].M>C[j].M)
                swap(C[i],C[j]);
    //排序结束
    for(i=0,index1=0,index2=n-1;i<n;i++)
        if(C[i].M==A[C[i].ID])
            ans[index1++]=C[i].ID;
        else
            ans[index2--]=C[i].ID;
    for(i=0;i<n;i++)
        time1+=A[ans[i]],
        time2=((time2<time1)?(time1):(time2)),
        time2+=B[ans[i]];
    printf("%d\n",time2);
    for(i=0;i<n;i++)
        printf("%d ",ans[i]+1);
    return 0;
}
```

---

## 作者：ljc20020730 (赞：33)

~~第一吃螃蟹的感觉真好！~~

第一篇题解 by ljc20020730

n个作业要在由两台机器M1和M2组成的流水线上完成加工．每个作业i必须先在M1上然后在M2上加工，时间分别为ai和bi。

确定这n个作业的加工顺序，使得从第一个任务开始在M1上加工到最后一个任务在M2上加工完成的总时间尽量小。

直观上，最优调度一定让M1没有空闲，M2的空闲时间尽量少。

算法:①使用数组f1[j] 存放a[i]<b[i]的作业；

②使用数组f2[k] 存放a[i]>=b[i]的作业;

③对f1[j]根据a[j]进行升序排列;

④对f2[k]根据b[k]进行降序排列;

⑤遍历两个数组，依次求时间:取两个机器运行时间的较大值作为作业用时。

程序易于实现，时间O(nlogn)，关键在于正确性证明。

---

## 作者：唔啊唔 (赞：26)

这是教练教的升级版贪心类型的模板题之一，也就是Johnson算法的模板。

**题目解析：**

本题是要求一个加工顺序使得总的加工时间最少，而要使加工时间最少，就是让各车间的空闲时间最少。

此题要求必须先送到A再送到B，所以要使A和B两车间的空闲时间最少：

（1）就要把在A车间加工时间最短的部件最先加工，这样使得B车间能更快开始加工。

（2）就要把在B车间加工时间最短的部件最后加工，这样使得A车间的空闲时间最短。

最后附上证明：[此题正确性证明](https://wenku.baidu.com/view/9c31776727d3240c8447ef42.html###)

**代码实现：**
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,ans[10000],ti[10000],a[10000],b[10000];
struct node{
	int mi,wan;//mi:A和B中时间更短的,wan:序号 
}hzy[10000];
inline int v(node x,node y){
	return x.mi<y.mi;
}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		hzy[i].wan=i;
		cin>>a[i];
	}
	for(int i = 1;i <= n;i++){
		cin>>b[i];
		hzy[i].mi=min(a[i],b[i]);
	}
	sort(hzy+1,hzy+1+n,v);
	int z=0,y=n+1;
	for(int i=1;i<=n;i++){
		if(hzy[i].mi==a[hzy[i].wan]){//A时间短的往前面塞 
			z++;
			ans[z]=hzy[i].wan;
		}
		else{//反之，B时间短的往后面塞 
			y--;
			ans[y]=hzy[i].wan;
		}
	}
	for(int i=1;i<=n;i++){
		ti[i]=ti[i-1]+a[ans[i]];
	}//轮到某一个零件时A车间的总加工时间 
	int sum=ti[1]+b[ans[1]];
	for(int i=2;i<=n;i++){
		sum=max(ti[i],sum)+b[ans[i]];
	}//要等到A车间加工完:t[i],或等到B车间加工完:sum。再取其中最大值。 
	cout<<sum<<endl;
	for(int i=1;i<=n;i++)cout<<ans[i]<<" ";
	return 0;
}
```


---

## 作者：蔡俊黠 (赞：10)

## 思路

求一个加工顺序使得加工总用时最短，就是让机器的空闲时间最短。

一旦A车间开始加工，则A车间就会不停地进行作业，关键是B车间在加工过程中有可能要等待A车间。很明显第一个产品在A车间上加工时，B车间必须等待，最后一个产品在B车间上加工时，A车间也在等待B车间的完工。

可以大胆猜想，要使车间的空闲时间最短，就要把在A车间上加工时间最短的产品最先加工，这样使得B车间能在最短的空闲时间内开始加工；把在B车间上加工时间最短的产品放在最后加工，这样使得A车间用最短的时间等待B车间完工。

所以我们应该让在A车间上加工时间短的产品优先，而在B车架上加工时间短的产品排在后面

所以我们要做的事就是：

（1）就要把在A车间加工时间最短的部件优先加工，这样使得B车间能以最快的速度开始加工

（2）把放在B车间加工时间最短的产品放在最后加工，这样使得最后A车间的空闲时间最少

## code

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1010;
int n,a[N],b[N],order[N];
struct node{
	int time,belong,id;
}c[N];
void init()
{
	scanf("%d",&n);
	for (int i=1;i<=n;i++) scanf("%d",&a[i]);
	for (int i=1;i<=n;i++)
	{
		scanf("%d",&b[i]);
		c[i].id=i;
		if (a[i]<b[i]) //在A上加工的时间更短 
		{
			c[i].time=a[i];
			c[i].belong=0;
		}
		else //在B上加工的时间更短 
		{
			c[i].time=b[i];
			c[i].belong=1;
		}
	}
	return;
}

int cmp(node x,node y) { return x.time<y.time; }

void make_order()
{
	int cnt1=1,cnt2=n;
	sort(c+1,c+1+n,cmp);
	for (int i=1;i<=n;i++)
	{
		if (c[i].belong==0) //在A上加工的时间更短，从头开始排 
	    	order[cnt1++]=c[i].id;
	    else //在B上加工的时间更短，从尾开始排 
			order[cnt2--]=c[i].id;
	}
	return;
}

void work()
{
	int A=0,B=0;//A：A的加工时间 B：B的加工时间 
	for (int i=1;i<=n;i++)
	{
		A+=a[order[i]];
		if (B<A) B=A;
		B+=b[order[i]];
	}
	cout<<B<<endl;
	for (int i=1;i<=n;i++) printf("%d ",order[i]);
	return;
}
int main()
{
	init(); 
	make_order();
	work();
	return 0;
}
```



---

## 作者：かみじょ (赞：10)

# 蒟蒻系列
第一次写题解，所以不是很会写

思路主要是贪心排序+模拟求和

思路和证明上面第一篇都有了

可能程序不够好，主要是也锻炼一下

总之轻喷，谢谢
```cpp
#include<bits/stdc++.h>
using namespace std;
struct NN
{
	int a,b,minn,pm; //结构体记录原下标
};
NN T1[1005];
NN T2[1005];
bool cmp(NN x,NN y){return x.minn<y.minn;}
int main()
{
	int n;
	cin>>n;
	for(int i=1;i<=n;i++)cin>>T1[i].a;
	for(int i=1;i<=n;i++)cin>>T1[i].b;
	for(int i=1;i<=n;i++){T1[i].minn=min(T1[i].a,T1[i].b);T1[i].pm=i;}
	sort(T1,T1+n+1,cmp);//排序
	int l=1,r=n;
	for(int i=1;i<=n;i++)
	{//贪心算法，思路跟上面一样
		if(T1[i].minn==T1[i].a){T2[l++]=T1[i];}
		else {T2[r--]=T1[i];}
	}
	int i=1,at=0,bt=0,t=T2[1].a;T2[n+1].a=0;
	while(i<=n)//模拟求总时间
	{
		bt+=T2[i].b;at=T2[++i].a;
		if(at<bt)
		{
			bt-=at;t+=at;at=0;
		} 
		else if(at>=bt)
		{
			t+=at;at=0;bt=0;
		}
	}t+=bt;
	cout<<t<<endl;
	for(int i=1;i<=n;i++)
		cout<<T2[i].pm<<' ';
		cout<<endl; 
}
```

---

## 作者：swkyccbb (赞：9)

这一道题我们可以用Johnson算法来解决。	

我们设M(i)=min{a(i),b(i)}.
将M按照从小到大的顺序排序,然后从第一个作业开始处理,若M(i)=a(i),则将它排在从头开始的作业后面，若M(i)=b(i),则将它排在从尾开始的作业前面。这样组成的序列就是最小加工时间的加工顺序。再按照这一序列即可算出最少的加工时间。

附上代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,c[10003],d[10003],Worktime[10002];
struct node{
	int m,num; 
}a[10002];
bool cmp(node a,node b){
	return a.m<b.m;
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++) scanf("%d",&c[i]);
	for(int i=1;i<=n;i++){
		scanf("%d",&d[i]);
		a[i].m=min(c[i],d[i]);
		a[i].num=i;
	}
	sort(a+1,a+1+n,cmp);	//排序 
	int l=0,r=n+1;
	for(int i=1;i<=n;i++){
		if(a[i].m==c[a[i].num]) Worktime[++l]=a[i].num;		//按上述方法排出最小加工时间的加工顺序 
		else Worktime[--r]=a[i].num; 		//注意这里一定要写else，不然只有40分
	}
	int TA=0,TB=0;		//TA：A厂的加工时间		TB:B厂的加工时间 
	for(int i=1;i<=n;i++){		//按照最小加工时间的加工顺序算出在A，B厂最少的加工时间 
		TA+=c[Worktime[i]];
		if(TA>TB) TB=TA;
		TB+=d[Worktime[i]];
	}
	printf("%d\n",TB);		//因为必须先在A车间加工后才可以到B车间加工，所以TA>TB 
	for(int i=1;i<=n;i++) printf("%d ",Worktime[i]);
	return 0;
} 
```


---

## 作者：Forgive_Me (赞：5)

**P1248 加工生产调度 题解**

标签：**贪心** **模拟退火（？）**

刷贪心刷到的此题，想了半天终于研究明白了题解区大佬的贪心策略和细节，然后——

机房大佬~~鑫哥~~提示我，这题似乎不用贪心？

发现对于一个工作顺序，可以直接计算答案，也就是说，完全可以用**模拟退火**做！！！（而且好像没有题解这样写）

那么这题就和下面这题非常像

[P3878 [TJOI2010] 分金币](https://www.luogu.com.cn/problem/P3878)

（我的模拟退火初体验）

模拟退火具体算法这里不多阐述，可以到上面题的题解区里面看。

简单来说，就是更优的一定更新答案，不优的也有一定概率成为答案，然后不停交换看看是否更优。


代码:
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,ans[1010],num[1010],a[1010],b[1010],Ans=1e10,sum;
void update()
{
    for(int i=1;i<=n;i++) ans[i]=num[i];
    Ans=sum;
}
int get()
{
    //模拟过程，这里其他题解也有类似写法
    int nowa=0,nowb=0;
    for(int i=1;i<=n;i++)
    {
        nowa+=a[num[i]];
        nowb=max(nowa,nowb);
        nowb+=b[num[i]];
    }
    return nowb;
}
void sa()//模拟退火
{
    double st=100,ed=1e-8,delta=0.9357;
    for(double t=st;t>ed;t*=delta)
    {
        int x=rand()%n+1,y=rand()%n+1;
        swap(num[x],num[y]);
        sum=get();
        int dt=sum-Ans;
        if(dt<0) update();
        else if(exp(-dt/t)<double(rand())/RAND_MAX) swap(num[x],num[y]);
    }
}
signed main()
{
    srand(rand());
    srand(rand());
    cin>>n;
    for(int i=1;i<=n;i++) cin>>a[i];
    for(int i=1;i<=n;i++) cin>>b[i];
    for(int i=1;i<=n;i++) num[i]=i;
    int cnt=500;
    while(cnt--) sa();
    cout<<Ans<<'\n';
    for(int i=1;i<=n;i++) cout<<ans[i]<<" ";
}
```

---

## 作者：CrTsIr400 (赞：4)

补一个第一篇题解的证明。

拿出原来的排序不等式的式子。需要让最终序列满足：

$\min(a_i,b_{i+1})\le \min(a_{i+1},b_{i})$。

我们分析一下，因为依旧是四个元素两两之间最小值的东西，不好求。

这里就分析 $\min(a_1,b_2)\le \min(a_2,b_1)$ 好了。

需要分类讨论。

首先可以尝试画拓扑图来解决问题。研究同一个变量 $a,b$ 之间的关系。

+ 一，$a_1<b_1,a_2<b_2$ 时候，如下图所示，我们要求 $a_1$ 为最小值（因为这种情况下 $b_2$ 不可能为最小值），就是需要在拓扑图上连接一条边使得 $a_1$ 是拓扑图的起点。
+ 则可以如下图红色、蓝色所示方式连边。最本质的答案就是需要保证 $a_1\le a_2$。

![](https://cdn.luogu.com.cn/upload/image_hosting/rg0vqer2.png)

+ 二，讨论 $a_1<b_1,a_2\ge b_2$ 的情况。如图所示，要求 $a_1$ 为最小值。
+ 则需要保证 $a_1\le b_2$。

![](https://cdn.luogu.com.cn/upload/image_hosting/bypk7uuj.png)![](https://cdn.luogu.com.cn/upload/image_hosting/qaq29i5h.png)

+ 这种情况下 $b_2$ 可能为最小值，那么就是上图这样：本质是 $a_1\ge b_2$ 时候才会出现。
+ 所以 $a_1<b_1,a_2\ge b_2$ 的情况，无论 $a_1$ 和 $b_2$ 的大小关系如何，都能够成立。
+ 三，当 $a_1=b_1$ 且 $a_2<b_2$ 时候，只能让 $a_1$ 为最小值，这个时候，就需要 $a_1\le a_2$ 时候 $a_1$ 才有可能为最小值了。

![](https://cdn.luogu.com.cn/upload/image_hosting/pepklszv.png)

+ 四，当 $a_1=b_1$ 且 $a_2=b_2$ 时候，这时怎么排序都没有影响了，因为等号一定成立。
+ 五，当 $a_1=b_1$ 且 $a_2>b_2$ 时候，当 $a_1$ 为最小值时，如下图所示，这时要想小于等于号成立，就得 $b1\le b2$。

![](https://cdn.luogu.com.cn/upload/image_hosting/u9jco77n.png)

+ 当 $b_2$ 为最小值时，就有 $b_1\ge b_2$ 了。（图未画出）
+ 六，当 $a_1>b_1$ 且 $a_2\le b_2$ 时候，$a_1$ 取不到最小值，$b_2$ 可能取到全局最小值，所以当小于等于号成立时候，必有 $a_2=b_2$ ，且满足 $b_1\le a_2$。如下图所示。实际上，原式恒成立。

![](https://cdn.luogu.com.cn/upload/image_hosting/mxmhovvr.png)

+ 七，当 $a_1>b_1$ 且 $a_2>b_2$ 时候，只有 $b_2$ 才有可能取到最小值，则有 $b_1\ge b_2$。

![](https://cdn.luogu.com.cn/upload/image_hosting/8eik50j6.png)

+ 总结上述七种情况：
+ 当 $a_1<b_1$ 时候，如果 $a_2<b_2$ 则应该有 $a_1\le a_2$；如果 $a_2\ge b_2$ 则原式恒成立；
+ 当 $a_1=b_1$ 时候，如果 $a_2<b_2$ 则应该有 $a_1\le a_2$；如果 $a_2=b_2$ 则原式恒成立；如果 $a_2>b_2$ 则有 $b_1\le b_2$。
+ 当 $a_1>b_1$ 时候，如果 $a_2\le b_2$ 则原式恒成立；如果 $a_2>b_2$ 则有 $b_1\ge b_2$。

具体写程序的时候，可以设置 $d$ 表示 $a$ 与 $b$ 的大小关系来实现。

```cpp
struct nd{
	I a,b,d,id;
	friend bool operator <(nd x,nd y){
		if(y.d==x.d){
			if(x.d<0)return x.a<y.a;
			if(x.d==0)return x.id<y.id;
			return x.b>y.b;
		}return x.d<y.d;
	}
}
```

---

## 作者：狛枝凪斗 (赞：4)

解题思路和证明都与前面几篇题解的大佬相同

这里想说一种题解没有提到的求最后时间的方法

根据解题思路的开头：

设先加工a优于b，a、b两个物品的加工时间分别为a1，b1以及a2，b2，则最短加工时间为a1+max(b1+a2)+b2

解题时排完序以后整个序列已经满足了先加工排在前面的最优，那么可以直接用上面的式子，推广到整个序列，求加工时间

加工时间为：a1+max(a2+a3+a4+...+an,b1+b2+b3+...+bn-1)+bn

开头和结尾的时间一定要分离出来考虑。设ans1=a2+a3+...+an,ans2=b1+b2+b3...+bn

首先在a车间各个物品中间没有加工时间间隔，所以a1+ans1就是a车间整体所用时间。如果a车间加工时间长就选择ans1。这里发现an加工完才能加工bn，所以后面要加上bn

但是如果在b车间加工时间比a长，这个时候b车间整体加工时间为ans2+bn。加工完a1才能加工b1，所以前面要加上a1。

即：
```cpp
for(int i=1;i<=n;i++){
	if(i!=1)ans1+=f[i].a;
	if(i!=n)ans2+=f[i].b;
}
printf("%d\n",max(ans1,ans2)+f[1].a+f[n].b);
```

全部代码：
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
using namespace std;
int n,ans1,ans2;
struct node{
    int a,b,d,id;
}f[1001];
bool cmp(node x,node y){
    if(x.d<y.d)return true;
    else if(x.d==y.d){
        if(x.d<=0){
            if(x.a<y.a)return true;
            else return false;
        }
        else{
            if(x.b>y.b)return true;
            else return false;
        }
    }
    else return false;
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)scanf("%d",&f[i].a);
    for(int i=1;i<=n;i++){
        scanf("%d",&f[i].b);
        if(f[i].a==f[i].b)f[i].d=0;
        else f[i].d=(f[i].a-f[i].b)/abs(f[i].a-f[i].b);
        f[i].id=i;
    }
    sort(f+1,f+n+1,cmp);
    for(int i=1;i<=n;i++){
        if(i!=1)ans1+=f[i].a;
        if(i!=n)ans2+=f[i].b;
    }
    printf("%d\n",max(ans1,ans2)+f[1].a+f[n].b);
    for(int i=1;i<=n;i++)printf("%d ",f[i].id);
    return 0;
}

```


---

## 作者：封禁用户 (赞：3)

 [观感更加的地方](https://www.cnblogs.com/wo-shi-zhen-de-cai/p/11553033.html)

这类题目显然是邻项交换，但是有要注意的点。

先用邻项交换的方法跑一边，发现$cmp$函数为：$x.a+max(x.b,y.a)+y.b < y.a+max(y.b,x.a)+x.b$

其实可以化简：$min(x.a,y.b)<min(x.b,y.a)$（因为$max(x,y)-x-y=-min(x,y)$）

但是这是一个错的排序方式，[所以说这个证明及其完全我就不写了](https://ouuan.github.io/%E6%B5%85%E8%B0%88%E9%82%BB%E9%A1%B9%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F%E7%9A%84%E5%BA%94%E7%94%A8%E4%BB%A5%E5%8F%8A%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E9%97%AE%E9%A2%98/)

我感性理解了一下，就是化简后有$max,min$函数之类的好像都不行。

网上很多人说这个式子没有传递性，实际上这个式子不满足不可比的传递性。

而这个传递性可以理解成三个元素$a,b,c$对于某个不等关系满足$a=b,b=c\Rightarrow a=c$。（这是个不完全的理解，但暂时可以这么理解，泛用性应该还不差）

实际上，我们这样带有$max,min$函数的式子一般不满足，拿此题来说对于以下的三个产品就不满足：

```
7 3
1 1
1 6
```

至此我们先强调一点，我并没有说$Johnson$算法是错的，实际上从原理上来说，这个要求是完全正确，也就是说，我们的最优排序方案一定满足这个式子，用这个式子人工排序也一定能成，但是在计算机中行，因为sort的排序方式是一定会满足不可比的传递性，也就是说两个数相等对其顺序没有影响，但是这种排序方式不一定，所以我们要将其转化，化为满足不可比的传递性的形式。

换句话说，我们要找到一种等价的比较方式，使的无论什么情况下均满足上面的式子且具有不可比的传递性。

转换的时候实际上我们并不是说完全抛弃掉原来的方式，观察$Hack$样例，实际上就是当有$a_i==b_i$时会出锅。

也就是说，我们将这种情况单独领出来考虑即可：

- $a_i<b_i\&\&a_j=b_j$时不用交换（分类讨论）
- $a_i>b_i\&\&a_j=b_j$时需要交换（分类讨论）

所以我们得到了如下的分类（每一类的顺序即为其优先级）：

- $a_i<b_i\&\&a_j<b_j$，这时可以用$min(x.a,y.b)<min(x.b,y.a)$（或者你可以说按照$a_i<a_j$排序，因为你分类讨论之后发现这两者一样）
- $a_i=b_i$，这时随意（自行讨论）。
- $a_i>b_i\&\&a_j>b_j$，这时可以用$min(x.a,y.b)<min(x.b,y.a)$（或者你可以说按照$b_i>b_j$排序，因为你分类讨论之后发现这两者一样）

这时我们就可以写了。

```c++
#include<bits/stdc++.h>
using namespace std;
#define int long long
inline int read()
{
    int f=1,w=0;char x=0;
    while(x<'0'||x>'9') {if(x=='-') f=-1; x=getchar();}
    while(x!=EOF&&x>='0'&&x<='9') {w=(w<<3)+(w<<1)+(x^48);x=getchar();}
    return w*f;
}
const int N=20010;
int n,f[N];
struct Person
{
	int x,y,d,id;
	bool operator < (const Person &b)
		{
			return d==b.d?min(x,b.y)<min(y,b.x):d<b.d;
		}
}p[N];
main(){
#ifndef ONLINE_JUDGE
    freopen("A.in","r",stdin);
#endif
	n=read();
	for(int i=1;i<=n;i++) p[i].x=read(),p[i].id=i;
	for(int i=1;i<=n;i++)
	{
		p[i].y=read();
		p[i].d=p[i].x<p[i].y?-1:p[i].x>p[i].y?1:0;
	}
	sort(p+1,p+n+1);
	int Ta=p[1].x,Tb=p[1].x+p[1].y;
	for(int i=2;i<=n;i++) Tb=max(Ta+p[i].x,Tb)+p[i].y,Ta+=p[i].x;
	printf("%lld\n",Tb);
	for(int i=1;i<=n;i++) printf("%lld ",p[i].id);
}
```

---

## 作者：Celtic (赞：2)

要使时间最短，则就是让机器的空闲时间最短。
A 机器在加工过程中，有可能要等待 A 机器。
最后一个部件在 B 机器上加工， A 机器也在等待 B 机器的完工。

要使总的空闲时间最少，就要把在 A 机器上加工时间最短的部件最先加工，这样使得 B 机器能以最快的速度开始加工；把在 B 机器上加工时间最短的部件放在最后加工。这样使得 A 机器能尽快的等待 B 机器完工。

于是我们可以设计出这样的贪心法：

   设 $M_i=min(a_i,b_i)$
   将 M 按照从小到大的顺序排序。然后从第 1 个开始处理，若$M_i=a_i$，则将它排在从头开始的作业后面，若$M_i=b_i$，则将它排在从尾开始的作业前面。

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#define N 2001001
#define re register 
#define eps 1e-10 
#define MAX 2001
using namespace std; 
typedef long long ll; 
typedef double db;
inline void read(re ll &ret) 
{ 
    ret=0;re ll pd=0;re char c=getchar(); 
    while(!isdigit(c)){if(c=='-')pd=1;c=getchar();} 
    while(isdigit(c)){ret=(ret<<1)+(ret<<3)+(c^48);c=getchar();} 
    ret=pd?-ret:ret; 
}
ll n,ans[N];
struct cow
{
	ll a,b,data;
	inline friend bool operator <(re cow x,re cow y)
	{
		return min(x.a,y.b)<min(x.b,y.a);
	}
}c[N];
int main() 
{
	read(n);
	for(re int i=1;i<=n;i++)
	{
		read(c[i].a);
		c[i].data=i;
	}
	for(re int i=1;i<=n;i++)
		read(c[i].b);
	sort(c+1,c+n+1);
	re ll now1=0,now2=0;
	for(re int i=1;i<=n;i++)
	{
		now1+=c[i].a;
		now2=now2>now1?now2:now1;
		now2+=c[i].b;
	}
	printf("%lld\n",now2);
	for(re int i=1;i<=n;i++)
		printf("%lld ",c[i].data);
	exit(0);
}
```

---

## 作者：sgbzlzy (赞：2)

# P1248 加工生产调度
##### 这次是本蒟蒻第4次写博客，有错请多多指教
## 题目
某工厂收到了n个产品的订单，这n个产品分别在A、B两个车间加工，并且必须先在A车间加工后才可以到B车间加工。

某个产品i在A、B两车间加工的时间分别为Ai、Bi。怎样安排这n个产品的加工顺序，才能使总的加工时间最短。这里所说的加工时间是指：从开始加工第一个产品到最后所有的产品都已在A、B两车间加工完毕的时间。
## 思路
1. 将同一个零件A机器和B机器的时间小的存储在一个数组C里
2. 将C数组从左到右排序
3. 将C数组中原是A机器快的零件放在开头，否则放在结尾
4. 模拟机器运行
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,x,y,t,l,r,k=0,best=0;
int a[10001],b[10001],m[10001],shu[10001],last[10001];
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
		shu[i]=i;
	}
	for(int i=1;i<=n;i++)
	{
		cin>>b[i];
		if(a[i]>b[i])m[i]=b[i];
		else m[i]=a[i];
	}//输入，并处理 
	for(int i=1;i<=n-1;i++)
	for(int j=i+1;j<=n;j++)
	{
		if(m[i]>m[j])
		{
			t=m[i];
			m[i]=m[j];
			m[j]=t;
			t=shu[i];
			shu[i]=shu[j];
			shu[j]=t;
		}
	}//排序 
	l=1;
	r=n;
	for(int i=1;i<=n;i++)
	{
		if(m[i]==b[shu[i]])
		{
			last[r]=shu[i];
			r--;
		}
		else
		{
			last[l]=shu[i];
			l++;
		}
	}//安排顺序 
	for(int i=1;i<=n;i++)
	{
		k+=a[last[i]];
		if(best<k)best=k;
		best+=b[last[i]];
	}//模拟执行 
	cout<<best<<endl;
	for(int i=1;i<=n;i++)
	{
		cout<<last[i]<<" ";
	}//输出 
}
```


---

## 作者：四氧化二磷 (赞：2)

# 加工生产调度
【题目描述】

　　某工厂收到了 n 个产品的订单，这 n 个产品分别在 A、B 两个车间加工，并且必须先在 A 车间加工后才可以到 B 车间加工。

　　某个产品 i 在 A，B 两车间加工的时间分别为Ai,Bi。怎样安排这 n 个产品的加工顺序，才能使总的加工时间最短。

　　这里所说的加工时间是指：从开始加工第一个产品到最后所有的产品都已在 A，B 两车间加工完毕的时间。
  
  
------------
　　
  
　　算法：Johnson算法+贪心
  
　　对于这一类问题，Johnson算法是一个十分奇妙的解决方法。实质上就是**A机器上加工时间短的任务应优先，而在B机器上加工时间短的任务应该排在后面。**
  
　　当然要先按min{a，b}排序。
  
　　确定了顺序之后使用一个简单的分类思想即可（由于A车间不会中途停止工作，所以sum{B}是当前用时）：
  
　　如果到当前sum{A}>sum{B}则B有一段时间无事可做（sum{B}等于sum{A}）；
  
　　如果到当前sum{A}<=sum{B}则B一定有空余，可以直接开始做下一个，（sum{B}等于sum{B}）；
  
　　由此可得，当前总用时是受最长用时限制的。
  
　　~~就是B是在{A，B}中取最大值啊...~~
  
　　注意：因为要先加工A才能加工B，这将直接导致**B的取值判断操作在B的叠加操作之前**。
  
  
```cpp
#include<bits/stdc++.h>
using namespace std;
struct st{
	int a,b,s,num;
	bool operator <(const st f)const{
		return f.s>s;
	}
}a[1010100],b[1010100];
int n,l,r,A,B,h;
int lst[1010100];
int main(){
	scanf("%d",&n);l=0;r=n+1;
	for(int i=1;i<=n;i++)
	scanf("%d",&a[i].a);
	for(int i=1;i<=n;i++)
	a[i].num=i;
	for(int i=1;i<=n;i++)
	scanf("%d",&a[i].b);
	for(int i=1;i<=n;i++)
	a[i].s=min(a[i].a,a[i].b);
	for(int i=1;i<=n;i++)b[i]=a[i];
	sort(a+1,a+n+1);
	for(int i=1;i<=n;i++){
		if(a[i].s==a[i].a)
		lst[++l]=a[i].num;
		else lst[--r]=a[i].num;
	}
	for(int i=1;i<=n;i++){
		A+=b[lst[i]].a;
		B=max(A,B);
		B+=b[lst[i]].b;
	}
	printf("%d\n",B);
	for(int i=1;i<=n;i++)
	printf("%d ",lst[i]);
	return 0;
}
```

---

## 作者：羽儇 (赞：2)

![](https://cdn.luogu.com.cn/upload/image_hosting/6d6vlvq0.png)

[P2123](https://www.luogu.org/problem/P2123)题面的公式正是本题的核心

让窝来解释一下趴QAQ：

```cpp
如图，C[i]表示当到第i个产品被加工完后最多所花费的时间

窝觉得，举栗纸更通俗易懂点：

C1 = a1 + b1

则C2 = max(C1 , a1 + a2) + b2

即C2 = max(a1+b1 , a1 + a2) + b2//敲黑板！！！

如果第一个产品在b车间加工的时间大于第二个产品在a车间加工的时间，则以第一个产品在b车间加工的时间为基准，再+b2
如果第二个产品在a车间加工的时间大于第一个产品在b车间，则以第二个产品在a车间加工的时间为基准，再+b2
至于相等时，无所谓哪一个惹QAQ

图上的式子是可以化简的，


```

[戳窝](https://www.luogu.org/problemnew/solution/P2123)



里面的第一篇很详尽惹

然后先去做P2123

再回来做本题

最终可化简为

```cpp
if(p1.d!=p2.d)return p1.d<p2.d;
	else if(p1.d<=0)return p1.a<p2.a;
	return p1.b>p2.b;
```



AC代码

```cpp
#include <cstdio>
#include <algorithm>
#define maxn 30100
using namespace std;
struct node 
{
	int a,b,id,d;
}ob[maxn];
int T,n;
long long C[maxn];
bool cmp(node p1,node p2)
{
	if(p1.d!=p2.d)return p1.d<p2.d;
	else if(p1.d<=0)return p1.a<p2.a;
	return p1.b>p2.b;
}
signed main()
{
		long long suma = 0;
		scanf("%d",&n);
		for(int i = 1 ;i <= n ;i++)
		{
			scanf("%d",&ob[i].a);
			ob[i].id = i;
		}
		for(int i = 1 ;i <= n ;i++)
		{
			scanf("%d",&ob[i].b);
			if (ob[i].a>ob[i].b) ob[i].d=1;
            else if (ob[i].a<ob[i].b) ob[i].d=-1;
            else ob[i].d=0;
		}
		sort(ob+1,ob+1+n,cmp);
		for(int i = 1;i<=n;i++)
		{
			suma += ob[i].a;
		    C[i] = max(C[i-1],suma) + ob[i].b;
		}
		printf("%lld\n",C[n]);
		for(int i = 1;i<= n;i++)printf("%d ",ob[i].id);		
	return 0;
}
三倍经验题

```
[P2123](https://www.luogu.org/problem/P2123)

[P1248](https://www.luogu.org/problem/P1248)

[P1561](https://www.luogu.org/problem/P1561)

---

## 作者：luminouris (赞：1)

分析：
由于要总时间最短，所以我们应保持A车间生产连续和B车间不生产时间尽量短。

我们不难发现若我们将所有在A车间生产时间小于B车间生产的话，当前耗费时间为A车间生产时间而生产第一个零件时B车间一定在浪费，我们不妨先生产A车间生产时间最少的零件，再生产A车间生产时间大于B车间的零件。

若最后A车间总生产时间大于B车间总生产时间，则输出A车间生产总时间+加上A车间最后一个零件在B车间生产所需时间，最后一个零件应选择B车间生产时间最短的，如果B车间总生产时间大于A车间总时间则输出B车间生产总时间加上第一个零件的A车间生产时间。
附上代码：

```c++
#include<cstdio>
#include<algorithm>
#include<iostream>
using namespace std;
struct node
{
	int a;
	int b;
	int num;
}k[10005],p[10005],q[10005];
bool cmp1(node x,node y)
{
	return x.b>y.b;
}
bool cmp2(node x,node y)
{
	return x.a<y.a;
}
int main()
{
	int n,pi=0,qi=0,al=0,bl=0,flag=0;
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>k[i].a;
		k[i].num=i;
	}
	for(int i=1;i<=n;i++)
	{
		cin>>k[i].b;
		if(k[i].b<k[i].a)
		{
			pi++;
			p[pi]=k[i];
		}
		else
		{
			qi++;
			q[qi]=k[i];
		}
	}
	sort(q+1,q+qi+1,cmp2);
	sort(p+1,p+1+pi,cmp1);

	for(int i=1;i<=qi;i++)
	{
		al+=q[i].a;
		bl+=q[i].b;
	}
	for(int i=1;i<=pi;i++)
	{
		if(al<=bl)
		{
		al+=p[i].a;
		bl+=p[i].b;	
		}
		else
		{
			flag=1;
			al+=p[i].a;
		}
	}
	if(flag==1)
	cout<<al+p[pi].b<<endl;
	else
	cout<<bl+q[1].a<<endl;
	for(int i=1;i<=qi;i++)
	{
		cout<<q[i].num<<" ";
	}
	for(int j=1;j<=pi;j++)
	{
		cout<<p[j].num<<" ";
	}
	return 0;
}
```

---

## 作者：__wzy__ (赞：1)

# 用贪心策略！！！

## 解题思路：

```
求一个加工顺序使得加工总用时最短，就是让机器的空闲时间最短。一旦A机器开始加工，则A机器将会不停地进行作业，关键是B机器在加工过程中有可能要等A机器。
很明显第一个部件在A机器上加工时，B机器必须等待，最后一个部件在B机器上加工时，A机器也在等待B机器的完工。

可以大胆猜想，要使机器总的空闲时间最短，就是要把在A机器上加工时间最短的部件最先加工，这样使得B机器能在最短的空闲时间内开始加工；把在B机器上加工时间最短的部件放在最后加工，这样使得A机器用最短时间等待B机器完工。

于是我们可以设计出这样的贪心策略：

设M[i]=min{a[i],b[i]}。
将M按照从小到大的顺序排序，然后从第一个开始处理，若M[i]=a[i]，则将它排在从头开始的作业后面，若M[i]=b[i]，则将它排在从尾开始的作业前面。

例如：N=5,
(a[1],a[2],a[3],a[4],a[5])=(3,5,8,7,10),
(b[1],b[2],b[3],b[4],b[5])=(6,2,1,4,9),
则(m[1],m[2],m[3],m[4],m[5])=(3,2,1,4,9),
排序后为(m[3],m[2],m[1],m[4],m[5]).

处理m[3]:∵m[3]=b[3],∴m[3]排在后面；加入m[3]之后的加工顺序为(,,,,3);
处理m[2]:∵m[2]=b[2],∴m[2]排在后面；加入m[2]之后的加工顺序为(,,,2,3);
处理m[1]:∵m[1]=a[1],∴m[1]排在前面；加入m[1]之后的加工顺序为(1,,,2,3);
处理m[4]:∵m[4]=b[4],∴m[4]排在后面；加入m[4]之后的加工顺序为(1,,4,2,3);
处理m[5]:∵m[5]=b[5],∴m[5]排在后面；加入m[5]之后的加工顺序为(1,5,4,2,3);

则最优加工顺序就是(1,5,4,2,3)，最短时间为34。显然是这个结果的最优解。
 
```

# 问题是这种贪心策略是否正确？还需证明。

## 算法证明：

```
设S={j[1],j[2]...j[n]}，为待加工部件的作业顺序，若A机器开始加工S中的部件时，B机器还在加工其他部件，t时刻后B机器可加工A机器加工过的部件。在这样的条件下，加工S中任务所需的最短时间T(S,t)=min{a[i]+T(S-{j[i]},b[i]+max{t-a[i],0})},其中，j[i]∈S。

假设最佳的方案中，先加工作业j[i]，然后加工作业j[i]，则有：
T(S,t)=a[i]+T(S-{j[i]},b[i]+max{t-a[i],0})
      =a[i]+a[j]+T(S-{j[i],j[j]},b[j]+max{b[i]+max{t-a[i],0}-a,0})
      =a[i]+a[j]+T(S-{j[i],j[j]},T[i,j])

T[i,j]=b[j]+max{b[i]+max{t-a[i],0}-a[j],0}
	  =b[j]+b[i]-a[j]+max{max{t-a[i],0},a[j]-b[i]}
	  =b[i]+b[j]-a[j]+max{t-a,a[j]-b,0}
	  =b[i]+b[j]-a[i]-a[j]+max{t,a[i],a[i]+a[j]-b[i]}
	     | t+b[i]+b[j]-a[i]-a[j],  若max{t,a[i],a[i]+a[j]-b[i]}=t 
	  =-<  b[i]+b[j]-a[j],         若max{t,a[i],a[i]+a[j]-b[i]}=a[i] 
	  	 | b[j],                   若max{t,a[i],a[i]+a[j]-b[i]}=a[i]+a[j]-b[i]
		   
若按作业j[i]和作业j[j]的加工顺序调换，则有：

T′(S,t)=a[i]+a[j]+T(S-(j[i],j[j]),T[j,i]),其中

T[j,i]=b[i]+b[j]-a[i]-a[j]+max{t,a[j],a[i]+a[j]-b[j]}

按假设，因为T≤T′，所以有：

max{t,ai+aj-bi,ai}≤ max{t,ai+aj-bj,aj}

于是有：

a[i]+a[j]+max{-b[i],-a[j]}≤a[i]+a[j]+max{-b[j],-a[i]} ..........①

即

min{b[j],a[i]}≤min{b[i],a[j]} ..................................②

②式便是Johnson算法的数学表达式。也就是说在②式成立的情况下，任务j[i]安排在任务j[j]之前加工可以得到最优解，即在A机器上加工时间短的任务应优先，而在B机器上加工时间短的任务应排在后面。
 
```

### 至此，Johnson算法的正确性证明完毕。

#### 处理程序：

```cpp
inline void qwq()//核心程序 
{
	for(int i=1;i<=n;i++)
	{
		m[i]=min(a[i],b[i]);
		s[i]=i;
	}
	for(int i=1;i<n;i++)//按产品的加工顺序从小到大排序 
		for(int j=i+1;j<=n;j++)
			if(m[i]>m[j])
			{
				swap(m[i],m[j]);
				swap(s[i],s[j]);
			}
	k=0;
	t=n+1;
	for(int i=1;i<=n;i++)//安排产品的加工顺序 
		if(m[i]==a[s[i]])
			ans[++k]=s[i];
		else
			ans[--t]=s[i];
	k=0;//A加工时间 
	t=0;//B加工时间 
	for(int i=1;i<=n;i++)//模拟计算最少加工时间(贪心) 
	{
		k+=a[ans[i]];
		if(t<k)
			t=k;
		t+=b[ans[i]];
	}
	return ;
}
```

## 完整代码如下：

```cpp
#include<bits/stdc++.h>//万能头文件 
#define INF 1001 
using namespace std; 
int ans[INF],n,k,t,a[INF],b[INF],m[INF],s[INF];//定义 (懒得打struct) 
inline int read()//快读模板 
{
	int s=0,w=1;
	char ch=getchar();
	while(ch<'0'||ch>'9')
	{
		if(ch=='-')
			w=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')
	{
		s=s*10+ch-'0';
		ch=getchar();
	}
	return s*w;
}
inline void write(int x)//快写模板 
{
    if(x<0)
	{
    	putchar('-');
		x=-x;
	}
    if(x>9)
		write(x/10);
    putchar(x%10+'0');
    return ;
} 
inline void init()//输入不解释 
{
	n=read();
	for(int i=1;i<=n;i++)
		a[i]=read();
	for(int i=1;i<=n;i++)
		b[i]=read();
	return ;
}
inline void print()//输出不解释 
{
	write(t);
	printf("\n");
	for(int i=1;i<=n;i++)
	{
		write(ans[i]);
		printf(" ");
	}
	printf("\n");
	return ;
}
inline void qwq()//核心程序 
{
	for(int i=1;i<=n;i++)
	{
		m[i]=min(a[i],b[i]);
		s[i]=i;
	}
	for(int i=1;i<n;i++)//按产品的加工顺序从小到大排序 
		for(int j=i+1;j<=n;j++)
			if(m[i]>m[j])
			{
				swap(m[i],m[j]);
				swap(s[i],s[j]);
			}
	k=0;
	t=n+1;
	for(int i=1;i<=n;i++)//安排产品的加工顺序 
		if(m[i]==a[s[i]])
			ans[++k]=s[i];
		else
			ans[--t]=s[i];
	k=0;//A加工时间 
	t=0;//B加工时间 
	for(int i=1;i<=n;i++)//模拟计算最少加工时间(贪心) 
	{
		k+=a[ans[i]];
		if(t<k)
			t=k;
		t+=b[ans[i]];
	}
	return ;
}
int main()//简陋的主函数 emm... 
{
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	init();//调用输入函数 
	qwq();//贪心 
	print();//调用输出函数 
	return 0;//好习惯 
}

```



---

## 作者：Wichiene (赞：1)

## 和各位大佬说的一样，这就是Johnson算法的模板

a1<b1，a2<b2时，按a1<a2排序

a1>b1，a2>b2时，按b1>b2排序

a1=b1，a2=b2时，爱咋排咋排

把a比b小的先处理，b比a小的后处理

以上证明过程大佬们都讲得清晰明了，使像我这样的蒟蒻受益匪浅%%%

主要就是代码实现上有一点不同，我觉得我的思路可能比较~~智障~~浅显易懂，~~毕竟我菜~~

```
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<cstring>
#define ll long long
using namespace std;
int n;
struct node
{
	int a;int b;int id;
	bool operator<(const node &x)const
	{
       		if(a<=b){return a<x.a;}//a<b，按a升序排
		if(a>b){return b>x.b;}//否则按b降序排
    	}
}pro[10001];
node am[10001],bm[10001],omg[10001];
int cnt1,cnt2;
int ans1,ans2;
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		int aa;
		cin>>aa;
		pro[i].id=i;
		pro[i].a=aa;
	}
	for(int i=1;i<=n;i++)
	{
		int bb;
		cin>>bb;
		pro[i].b=bb;
	}
	for(int i=1;i<=n;i++)
	{
		if(pro[i].a<=pro[i].b)
		am[++cnt1]=pro[i];
	}//am里放a<=b的产品
	for(int i=1;i<=n;i++)
	{
		if(pro[i].a>pro[i].b)
		bm[++cnt2]=pro[i];
	}//bm里放a>b的
	sort(am+1,am+cnt1+1);
	sort(bm+1,bm+cnt2+1);//按规则，分别排序
	for(int i=1;i<=n;i++)
	{
		if(i<=cnt1)omg[i]=am[i];
		else omg[i]=bm[i-cnt1];
	}//把排好序的bm接在排好序的am后边，就得到了最后的正确序列
	for(int i=1;i<=n;i++)
	{
        if(i!=1)ans1+=omg[i].a;
        if(i!=n)ans2+=omg[i].b;
    }//统计一下时间
    printf("%d\n",max(ans1,ans2)+omg[1].a+omg[n].b);
    for(int i=1;i<=n;i++)printf("%d ",omg[i].id);
    return 0;
}
```


---

## 作者：灵小沙 (赞：1)

	#include <cstdio>
	#include <cstring>
	#include <iostream>
	using namespace std;
	const int MaxNumber = 1010;
	int n, min_time; // 生产任务的个数及最少的时间
	int a[MaxNumber], b[MaxNumber];
	int m[MaxNumber], o[MaxNumber], order[MaxNumber];
	// a 数组存放每一个产品在 A 车间加工所需的时间，
	// b 数组存放每一个产品在 B 车间加工所需的时间，
	// m 数组取在 A 车间、B 车间加工时间较少的一个值，
	// o 数组记录由小到大排序后产品的编号，
	// order 数组记录具体的加工生产顺序
	void init()
	{
	 int i;
	//freopen(“prod.in”, “r”, stdin);
	 cin >> n;
	 
	for(i=1; i<=n; i++) cin >> a[i];
	 
	for(i=1; i<=n; i++) cin >> b[i];
	 //fclose(stdin);
	}
	void work()
	{
	int i, j, k, s, t, t1, t2;
	 
	memset(m, 0, sizeof(m));
	 
	for(i=1; i<=n; i++) // 取某一产品在 A、B 车间中加工时间之短者
	if (a[i] < b[i])
	 m[i] = a[i];
	else
	 m[i] = b[i];
 
	for (i=1; i<=n; i++) o[i] = i; // 记录序号
 
	for (i=1; i<=n-1; i++) // 从小到大排序
	for (j=i+1; j<=n; j++)
	 if (m[o[i]] > m[o[j]]) { // o: 2 3 1
	 k = o[i];
	 o[i] = o[j];
	 o[j] = k;
	 }
 
	memset(order, 0, sizeof(order));
	 s = 1; // 头指针
	 t = n; // 尾指针
 
	for (i=1; i<=n; i++)
	if (m[o[i]]==a[o[i]]) { // 如果 a[o[i]]<b[o[i]]则安排在前面
	 order[s] = o[i];
	 s++;
	 }
	else { // 否则安排在后面生产
	 order[t] = o[i]; 
	 t--;
	 }
	t1 = 0;
 	t2 = 0;
 
	for(i=1; i<=n; i++) { 
	//求最少的加工时间——这一块是核心，体现了数学处理}
 	t1 = t1 + a[order[i]];
 	if (t2 < t1) t2 = t1;
 	t2 += b[order[i]];
	}
 
	min_time = t2;
	}
	void print()
	{
	int i;
 	cout << min_time<<endl;
 	for (i=1; i<=n-1; i++) cout << order[i]<<" ";
 	cout << order[n];
	}
	int main()
	{
	 init();
	 work();
	 print();//只要打三个就好了
	 return 0;
	}

---


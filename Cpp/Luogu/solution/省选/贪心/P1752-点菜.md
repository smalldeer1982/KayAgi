# 点菜

## 题目描述

有 $n$ 个人到一家餐馆点菜。这家餐馆总共有 $m$ 道菜，每一道菜都有两个属性——美味度和价格。这 $n$ 个人每周都会来一次，每次只会点一道菜或不点。在这 $n$ 个人中，有 $p$ 个人比较挑剔，他们只能接受美味度大于等于一定值的菜；有 $q$ 个人比较贫穷，他们只能点价格小于等于一定值的菜。现在请你计算：这些人至少要来几周，才可能能把餐馆的所有的菜都点过一遍？

## 说明/提示

### 数据范围及约定

- 对于 $20\%$ 的数据，$m \le 20$；
- 对于 $40\%$ 的数据，$m \le 2000$；
- 对于 $100\%$ 的数据，$p+q \le n \le 50000,m \le 200000$。

## 样例 #1

### 输入

```
2 3 1 1
5 2
5 3
6 4
5
1```

### 输出

```
3
```

# 题解

## 作者：CEFqwq (赞：12)

脑洞题。绝世好题。

首先，我们经过分析可以得出贪心策略：让挑剔的人选美味的，让贫穷的人点价廉的。

这也是本题的核心思路。

然后我们可以发现，如果 $k$ 周可以点完所有菜，那么 $k+1$ 周也能点完所有菜。

根据数学归纳法，推出：如果 $k$ 周可以点完所有菜，那么若 $n>k$，$n$ 周一定能点完所有菜。

看起来上面的性质都非常简单，但实际上这些是解决这道题目的关键。

我们推出来了，如果 $k$ 天可以点完所有菜，那么若 $n>k$，$n$ 天一定能点完所有菜。那么我们二分查找最小的 $k$，不就可以解决了吗？

二分的板子看这篇题解的人应该都会。~~二分都不会还做什么紫题~~关键在于判断函数怎么写。

首先，如果除去这些贫穷的人和挑剔的人，其他人都已经可以把菜选完了，那当然能把菜都选一遍。

然后我们进行贪心，即让挑剔的人选美味的，让贫穷的人点价廉的：

先把菜按照美味度排序。放到一个大根堆里，然后枚举挑剔的人，注意先把这些人喜欢的美味度按从大到小排。枚举过程很简单，开一个大根堆（推荐用 `priority_queue`），把每个挑剔的人喜欢的菜放进堆里，放完之后弹出直到堆空了或者是已经弹出了 $k$（当前二分校验的值）个元素。

因为挑剔的人从大到小排，在堆里的菜一定是让下一个人满意的。

这样挑剔的人就解决了。

剩下贫穷的人同理，把没取完的菜放入一个数组，按价格从小到大排序，然后放到任意队列里（当然为了思路更清晰，可以另开一个小根堆进行如上操作）。

最后算一算有多少道菜没取完。判断一下剩下的人能不能把这些菜点完。

然后，这道题就轻松地解决了！

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,p,q,b[114514<<2],c[114514<<2];
struct node{
	int x,y;
	bool operator<(node b)const{
		return this->y < b.y;
	}
}a[114514<<2],pp[114514<<2];
priority_queue<node>qq;
bool cmp(node x,node y){
	return x.x>y.x;
}
bool check(int k){
	if((long long)(n-p-q)*k>=m)return 1;//不需要挑剔和贫穷的人就可以取完
	while(qq.size())qq.pop();//多测清空，因为函数最后直接加上 size 了，下一次调用不清空会出错
	int top=1;
	for(int i=1;i<=p;i++) {
		while(top<=m&&a[top].x>=b[i])qq.push(a[top++]);
		for(int j=1;j<=k&&qq.size();j++)qq.pop(); 
	}//枚举挑剔的人
	int cnt=0;
	while(qq.size()){
		pp[++cnt]=qq.top();
		qq.pop();
	} 
	for(int i=top;i<=m;i++)pp[++cnt]=a[i];
	sort(pp+1,pp+cnt+1);//存入数组，按价格升序排序
	top=1;
	for(int i=1;i<=q;i++) {
		while(top<=cnt&&pp[top].y<=c[i])qq.push(pp[top++]);
		for(int j=1;j<=k&&qq.size();j++)qq.pop();
	}//枚举贫穷的人
	int res=qq.size()+cnt-top+1;
	return(res<=(n-p-q)*k);//判断剩下的人能不能取完
}
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	cin>>n>>m>>p>>q;
	for(int i=1;i<=m;i++)cin>>a[i].x>>a[i].y;
	for(int i=1;i<=p;i++)cin>>b[i];
	for(int i=1;i<=q;i++)cin>>c[i];
	sort(b+1,b+p+1);
	reverse(b+1,b+p+1);
	sort(c+1,c+q+1);
	sort(a+1,a+m+1,cmp);//全部排序
	int l=1,r=m,ans=-1;//设为 -1 可以直接判无解
	while(l<=r){//二分板子
		int mid=(l+r)>>1;
		if(check(mid))ans=mid,r=mid-1;
		else l=mid+1;
	}
	cout<<ans;
}
```

题目出的真好，我开始感觉没有头绪，但细细拆分就变成了一道不难的题目，赞美伟大出题人！

---

## 作者：litc (赞：11)

其实，这道题是我改编自2013IOI的Day2T2（凡是有见过许昊然的解题报告的人，应该一眼就能看出来）。尽管它是IOI的题目，但它的难度并不大。解题报告详见NOI官网上许昊然的版本，这里我只简述我的方法。

首先，把菜按美味度从大到小排序，挑剔的人从大到小排序。

接着，二分答案，设答案为ans

然后把菜按美味度从大到小扔到一个价格的大根堆里（扔p次，每次扔的是挑剔的人可以取的），然后挑剔的人依次取出ans个（不足则全取）。剩下的再让贫穷的人贪心，判断当前答案是否可行。


---

## 作者：FutaRimeWoawaSete (赞：8)

md这个题解怎么是挂的啊（（（     

不难发现原题可以二分图匹配模拟算，但是这样的时间复杂度爆炸。 

发现排序后连边有连续性以及答案具有单调性，考虑二分答案后贪心选。        

我们可以任意先满组美味度或价格的限制，以先满足美味度限制举例，我们对人的美味度单调不增排对于食物也单调不增拍，然后用双指针去把每个人可选的食物都加入一个集合里后尽量选就好了。              

但是考虑到还有价格的限制，所以我们把集合拿一个优先队列维护，每次从可以选的集合里优先拿出价格大的食物即可。               

对于剩下的食物直接用价格以上述类似的方法双指针贪心尽量选就好了，最后看剩下没有限制的人能否选完就知道当前二分答案合不合法了。           

时间复杂度 $O(n \log ^ 2 n)$。

```cpp
#include "bits/stdc++.h"
using namespace std;
const int Len = 4e5 + 5;
int n,m,p,q,tas[Len],costt[Len];
struct node
{
	int x,y;
	node(){x = y = 0;}
	node(int X,int Y){x = X , y = Y;}
	bool operator < (const node &Ano) const
	{
		return y < Ano.y;
	}
}s[Len],now[Len];
priority_queue<node> Q;
bool cmp1(node x,node y){return x.x > y.x;}
bool cmp2(node x,node y){return x.y < y.y;}
bool check(int len)
{
	if(1ll * (n - p - q) * len >= m) return 1;
	while(!Q.empty()) Q.pop();
	int idx = 1;
	for(int i = 1 ; i <= p ; i ++) 
	{
		while(idx <= m && s[idx].x >= tas[i]) Q.push(s[idx ++]);
		for(int j = 1 ; j <= len && !Q.empty() ; j ++) Q.pop(); 
	}
	int nowl = 0;
	while(!Q.empty()) 
	{
		now[++ nowl] = Q.top();
		Q.pop();
	} 
	for(int i = idx ; i <= m ; i ++) now[++ nowl] = s[i];
	sort(now + 1 , now + 1 + nowl , cmp2);
	idx = 1;
	for(int i = 1 ; i <= q ; i ++) 
	{
		while(idx <= nowl && now[idx].y <= costt[i]) Q.push(now[idx ++]);
		for(int j = 1 ; j <= len && !Q.empty() ; j ++) Q.pop();
	}
	int surp = 0;
	while(!Q.empty()) 
	{
		surp ++;
		Q.pop();
	}
	surp += nowl - idx + 1;
	return surp <= (n - p - q) * len;
}
int main()
{
	scanf("%d %d %d %d",&n,&m,&p,&q);
	for(int i = 1 ; i <= m ; i ++) scanf("%d %d",&s[i].x,&s[i].y);
	for(int i = 1 ; i <= p ; i ++) scanf("%d",&tas[i]);
	for(int i = 1 ; i <= q ; i ++) scanf("%d",&costt[i]);
	sort(tas + 1 , tas + 1 + p);
	reverse(tas + 1 , tas + 1 + p);
	sort(costt + 1 , costt + 1 + q);
	sort(s + 1 , s + 1 + m , cmp1);
	int l = 1 , r = m , anss = -1;
	while(l <= r)  
	{
		int mid = (l + r) >> 1;
		if(check(mid)) anss = mid , r = mid - 1;
		else l = mid + 1;
	}
	if(!anss) puts("-1");
	else printf("%d\n",anss);
	return 0;	
} 
```

---

## 作者：Linshey (赞：6)

二分应该很明显,
我们在答案上二分,
设我们需要mid周,
那我们要check的是这mid周能不能把菜完整地吃个遍.

# check:

若从菜出发,
我们要考虑这m个菜怎么分给这n个人,
会发现很难分,
因为我完全不知道这盘菜究竟该给穷人还是给挑剔的人,
所以我们要

# 换个考虑角度

我们来想一想每个穷人应该要什么样的菜
。我们容易发现每个穷人应该要的是能买得起的菜中
，最难吃的那mid个。

我们按照上述贪心
，先把穷人的菜选好
，然后挑剔的人在剩下的菜中挑能接受的中最难吃的那mid个
，最后看看剩下的菜能不能被正常人在mid周中吃完。

check结束

至于上述贪心的具体实现，
前半段用堆，后半段用set即可。
复杂度$ O(n * log2n * log2n) $
开$ O(2) $即可过

```cpp

#include <iostream>
#include <cstdio>
#include <algorithm>
#include <queue>
#include <set>
#include <cmath>

using namespace std;
const int maxn = 200005;

int n, m, p, q;

struct Food
{
	int prc, del, cnt;
	bool operator <(const Food& b) const
	{
		return del > b.del;
	}
} fd[maxn];

int del[maxn], prc[maxn];

bool cmp(Food a, Food b)
{
	return a.prc < b.prc;
}

void init()
{
	cin >> n >> m >> p >> q;
	for (int i = 1; i <= m; i++)
	{
		cin >> fd[i].del >> fd[i].prc;
		fd[i].cnt = i;
	}
	for (int i = 1; i <= p; i++) cin >> del[i];
	for (int i = 1; i <= q; i++) cin >> prc[i];
	sort(del + 1, del + p + 1);
	sort(prc + 1, prc + q + 1);
	sort(fd + 1, fd + m + 1, cmp);
}

struct Food2
{
	int prc, del, cnt;
	bool operator <(const Food2& b) const
	{
		return del < b.del;
	}
};

bool check(int mid)
{
	priority_queue<Food> hp;
	multiset<Food2> st;
	int pt = 1;
	for (int i = 1; i <= m; i++)
	{
		Food2 tmp2;
		tmp2.cnt = fd[i].cnt;
		tmp2.del = fd[i].del;
		tmp2.prc = fd[i].prc;
		st.insert(tmp2);
	}
	//cout << st.size() << endl;
	for (int i = 1; i <= q; i++)
	{
		while (pt <= m && fd[pt].prc <= prc[i])
		{
			hp.push(fd[pt]);
			pt++;
		}
		for (int j = 1; j <= min((int)hp.size(), mid); j++)
		{
			Food tmp = hp.top();
			hp.pop();
			Food2 tmp2;
			tmp2.cnt = tmp.cnt;
			tmp2.del = tmp.del;
			tmp2.prc = tmp.prc;
			st.erase(tmp2);
		}
	}
	for (int i = 1; i <= p; i++)
	{
		Food2 tmp2;
		tmp2.del = del[i];
		for (int j = 1; j <= mid; j++)
		{
			if (st.lower_bound(tmp2) != st.end())
			{
				st.erase(st.lower_bound(tmp2));
			}
			else break;
		}
	}
	int num = st.size();
	if (num <= (n - p - q) * mid) return true;
	else return false;
}

int main()
{
	init();
	int l = 1, r;
	if (n - p - q) r = ceil(1.0 * m / (n - p - q));
	else r = m + 1;
	while (l < r)
	{
		int mid = (l + r) / 2;
		if (check(mid)) r = mid;
		else l = mid + 1;
	}
	if (!(n - p - q))
	{
		if (r == m + 1)
		{
			cout << -1;
			return 0;
		}
	}
	cout << l << endl;
	return 0;
}
```

细节很多

比如说这个set需要拿multiset

因为有可能重复

还有，二分右边界这里取m / (n - p - q)

要考虑 (n - p - q) = 0 的情况

另外无解的情况只能是(n - p - q) = 0 且 l = m + 1(r 的初始值）

还有输入的数据要排序

p、q不要搞反了

谢谢


---

## 作者：zyj578335934 (赞：5)

既然题解这么少，我也来写一篇题解~

对于这道题目，要求用最少的时间点到所有的菜肴，很容易发现所求的答案满足单调性，即如x天满足条件，则用多于x天的时间一定能满足条件，于是我们考虑二分答案。

二分答案now后，我们如何进行判定呢？我们先对所有挑剔的人的美味度下限进行排序，并记为f[i]，该美味度在菜单中的排名记为fpos[i]，则对于每一个挑剔的人i，贪心的考虑，他一定优先选fpos[i]~(fpos[i+1]-1)，因为其他挑剔的人无法选到这个范围内的菜，所以这个挑剔的人所选的菜一定最优。同时我们记下一个变量now1,表示现在所拥有的点菜时间总和，对于fpos[i]~(fpos[i+1]-1)内的情况，我们进行分类讨论：

1. 当fpos[i+1]-fpos[i]>now1，即所拥有的时间不够点完所有的菜，就使未点的菜减去now1，并使now1=0，表示一次性用完了所有的时间点尽可能多的菜，剩下的菜由那些无限制的人去点。

2. 当fpos[i+1]-fpos[i]<=now1，即所拥有的时间足够点完所有的菜，就使now1和sum一起减去(fpos[i+1]-fpos[i])。

当我们处理完每一个人，即将处理下一个人时，直接让now1+=now,表示这个人之前所有人剩下的时间都可以帮这个人点菜。

对于贫穷的人也是这样处理即可，但需要判断这盘菜被点过没有，开一个布尔数组记录即可。

于是就有了下面的代码：
```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
int n,m,p,q;
struct sb{
	int data;
	long long len,val;
}s[200010],e[200010];
int fpos[50010],gpos[50010];
long long f[50010],g[50010];
inline bool comp(long long x,long long y){
	return x>y;
}
inline bool comp1(sb x,sb y){
	return x.len<y.len;
}
inline bool comp2(sb x,sb y){
	return x.val<y.val;
}
inline int find1(long long now){
	int l=1,r=m,ans=m+1;
	while(l<=r){
		int mid=(l+r)>>1;
		if(s[mid].len>=now){
			r=mid-1;
			ans=mid;
		}
		else {
			l=mid+1;
		}
	}
	return ans;
}
inline int find2(long long now){
	int l=1,r=m,ans=0;
	while(l<=r){
		int mid=(l+r)>>1;
		if(e[mid].val<=now){
			l=mid+1;
			ans=mid;
		}
		else {
			r=mid-1;
		}
	}
	return ans;
}
bool inv[200010];
inline bool check(int now){
	memset(inv,false,sizeof inv);
	int now1=0,sum=m;
	int pos,pos1;
	for(register int i=1;i<p;i++){
		now1+=now;
		pos=fpos[i],pos1=fpos[i+1];
		for(register int j=pos;j<pos1;j++){
			if(now1==0) break;
			inv[s[j].data]=true;
			sum--;
			now1--;
		}
	}
	now1+=now;
	pos=fpos[p];
	for(register int i=pos;i<=m;i++){
		if(now1==0){
			break;
		}
		inv[s[i].data]=true;
		sum--;
		now1--;
	}
	now1=0;
	for(register int i=1;i<q;i++){
		now1+=now;
		pos=gpos[i],pos1=gpos[i+1];
		for(register int j=pos;j>pos1;j--){
			if(now1==0) break;
			while(inv[e[j].data]) {
				j--;
				if(j==0) break;
			}
			if(j==0) break;
			inv[e[j].data]=true;
			now1--;
			sum--;
		}
	} 
	pos=gpos[q];
	now1+=now;
	for(register int i=pos;i>=1;i--){
		if(now1==0) break;
		while(inv[e[i].data]){
			i--;
			if(i==0) break;
		}
		if(i==0) {
			break;
		}
		inv[e[i].data]=true;
		now1--;
		sum--;
	}
	int ans1=n-p-q;
	if(ans1*now>=sum){
		return true;
	}
	else {
		return false;
	}
}
int main(){
	scanf("%d%d%d%d",&n,&m,&p,&q);
	for(register int i=1;i<=m;i++){
		scanf("%lld%lld",&s[i].len,&s[i].val);
		s[i].data=i;
	}
	for(register int i=1;i<=m;i++){
		e[i]=s[i];
	}
	for(register int i=1;i<=p;i++){
		scanf("%lld",&f[i]);
	}
	for(register int i=1;i<=q;i++){
		scanf("%lld",&g[i]);
	}
	sort(f+1,f+p+1);
	sort(g+1,g+q+1,comp);
	sort(s+1,s+m+1,comp1);
	for(register int i=1;i<=p;i++){
		fpos[i]=find1(f[i]);
	}
	sort(e+1,e+m+1,comp2);
	for(register int i=1;i<=q;i++){
		gpos[i]=find2(g[i]);
	}
	int l=1,r=m,ans=-1;
	while(l<=r){
		int mid=(l+r)>>1;
		if(check(mid)){
			r=mid-1;
			ans=mid;
		}
		else{
			l=mid+1;
		}
	}
	printf("%d\n",ans);
}
```
当我信心满满的交上去后，只有80分。。。

我调了很久，怎么都调不出来，最后我一气之下：

```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
long long n,m,p,q;
struct sb{
	long long data;
	long long len,val;
}s[200010],e[200010];
long long fpos[50010],gpos[50010];
long long f[50010],g[50010];
inline bool comp(long long x,long long y){
	return x>y;
}
inline bool comp1(sb x,sb y){
	return x.len<y.len;
}
inline bool comp2(sb x,sb y){
	return x.val<y.val;
}
inline long long find1(long long now){
	long long l=1,r=m,ans=m+1;
	while(l<=r){
		long long mid=(l+r)>>1;
		if(s[mid].len>=now){
			r=mid-1;
			ans=mid;
		}
		else {
			l=mid+1;
		}
	}
	return ans;
}
inline long long find2(long long now){
	long long l=1,r=m,ans=0;
	while(l<=r){
		long long mid=(l+r)>>1;
		if(e[mid].val<=now){
			l=mid+1;
			ans=mid;
		}
		else {
			r=mid-1;
		}
	}
	return ans;
}
bool inv[200010];
inline bool check(long long now){
	memset(inv,false,sizeof inv);
	long long now1=0,sum=m;
	long long pos,pos1;
	for(register long long i=1;i<p;i++){
		now1+=now;
		pos=fpos[i],pos1=fpos[i+1];
		for(register long long j=pos;j<pos1;j++){
			if(now1==0) break;
			inv[s[j].data]=true;
			sum--;
			now1--;
		}
	}
	now1+=now;
	pos=fpos[p];
	for(register long long i=pos;i<=m;i++){
		if(now1==0){
			break;
		}
		inv[s[i].data]=true;
		sum--;
		now1--;
	}
	now1=0;
	for(register long long i=1;i<q;i++){
		now1+=now;
		pos=gpos[i],pos1=gpos[i+1];
		for(register long long j=pos;j>pos1;j--){
			if(now1==0) break;
			while(inv[e[j].data]) {
				j--;
				if(j==0) break;
			}
			if(j==0) break;
			inv[e[j].data]=true;
			now1--;
			sum--;
		}
	} 
	pos=gpos[q];
	now1+=now;
	for(register long long i=pos;i>=1;i--){
		if(now1==0) break;
		while(inv[e[i].data]){
			i--;
			if(i==0) break;
		}
		if(i==0) {
			break;
		}
		inv[e[i].data]=true;
		now1--;
		sum--;
	}
	long long ans1=n-p-q;
	if(ans1*now>=sum){
		return true;
	}
	else {
		return false;
	}
}
int main(){
	scanf("%lld%lld%lld%lld",&n,&m,&p,&q);
	for(register long long i=1;i<=m;i++){
		scanf("%lld%lld",&s[i].len,&s[i].val);
		s[i].data=i;
	}
	for(register long long i=1;i<=m;i++){
		e[i]=s[i];
	}
	for(register long long i=1;i<=p;i++){
		scanf("%lld",&f[i]);
	}
	for(register long long i=1;i<=q;i++){
		scanf("%lld",&g[i]);
	}
	sort(f+1,f+p+1);
	sort(g+1,g+q+1,comp);
	sort(s+1,s+m+1,comp1);
	for(register long long i=1;i<=p;i++){
		fpos[i]=find1(f[i]);
	}
	sort(e+1,e+m+1,comp2);
	for(register long long i=1;i<=q;i++){
		gpos[i]=find2(g[i]);
	}
	long long l=1,r=m,ans=-1;
	while(l<=r){
		int mid=(l+r)>>1;
		if(check(mid)){
			r=mid-1;
			ans=mid;
		}
		else{
			l=mid+1;
		}
	}
	printf("%lld\n",ans);
}
```

然后我就A了。。。。。。。

# 不开long long 见祖宗！！！



---

## 作者：__maqiyue (赞：2)

这题是一道绝世好题。  
为什么咩？  
~~因为它代码长。~~  
因为它没有运用什么高级算法，但用低级算法组成了一道紫题。
# 题意转化
读完题后，我们可以发现，重复吃菜是对题目没有贡献的，所以即使没有能吃并且没有吃过的的菜，也不重复吃。  
换一种讲法，就是每种菜只有一盘，问最少要吃多少天。（原本是周，以下为了方便说成天）
# 思路
首先，~~根据算法标签~~我们得知应该使用二分，因为~~算法标签~~天数越多越容易每种菜都吃一遍，反之越少越不容易。

现在问题就变为了如何判断 $k$ 天能否每种菜都吃一遍。

很容易发现应该用贪心。 
## 证明贪心
我们贪的做法是：让挑剔的人在他**能吃的菜中吃最贵的**，穷人也是一样，从他**能吃的菜中吃最不美味的**。  
为什么这么做呢？因为~~谁叫他们这么挑剔~~挑剔的人是没有钱的限制的，所以尽量让他吃最贵的，把便宜的留给穷人吃。穷人也是一样，吃不美味的，把美味的留给挑剔的人吃。
### 既是最便宜又是最美味的菜
聪明的读者可能会想到，如果一种菜既是最便宜又是最美味的，这种应该给挑剔的人吃开始给穷人吃呢？
![](https://cdn.luogu.com.cn/upload/image_hosting/oeizu2p7.png)  
其实要根据挑剔的人可以吃的数量还是穷人可以吃的数量确定，但是这不影响，因为我们不是让挑剔的人吃最美味的，或者让穷人吃最便宜的。
### 给挑剔的人还是给穷人
如果穷人所有能吃的挑剔的人也能吃，那给谁呢？
![](https://cdn.luogu.com.cn/upload/image_hosting/k8txyorp.png)
其实不影响，因为题目的目的不是给谁吃。
# 代码
思路讲完了，代码又该怎么实现呢（天数为 $k$）？

首先，如果 $(n-p-q)\times k \geq m$ 那么一定可以吃完，因为如果普通的人吃 $k$ 天都能吃完那算上有限制的人也一定能吃完。
```cpp
if((long long)(n - cn - pn) * k >= m)//注意使用long long
	return true; 
```

然后，枚举挑剔的人能吃的菜，从中选出**最贵**给挑剔的人吃掉。  
其中，选出最贵的菜可以使用优先队列（`priority_queue`）。
```cpp
priority_queue <point> q;
int sum = 1;
for(int i = 1; i <= cn; i++)
{
	while(sum <= m && a[sum].x >= c[i])
		q.push(a[sum++]);
	for(int j = 1; j <= k && (!q.empty()); j++) q.pop(); 
}
```

选出剩下的菜和挑剔的人不能吃的菜放到一个数组里。
```cpp
int cnt = 0;
while(!q.empty())
{
	s[++cnt] = q.top();
	q.pop();
} 
for(int i = sum; i <= m; i++)
	s[++cnt] = a[i];
```

按价格排序，在剩下的菜把穷人能吃的给穷人吃。
```cpp
sort(s + 1, s + cnt + 1);
int top = 1;
for(int i = 1; i <= pn; i++)
{
	while(top <= cnt && s[top].y <= p[i]) q.push(s[top++]);
	for(int j = 1; j <= k && q.size(); j++) q.pop();
}
```


判断剩下的菜普通人能否吃完。
```cpp
int res = qq.size() + cnt - top + 1;
return(res <= (n - p - q) * k);
```
# 最终代码
```cpp
#include<bits/stdc++.h> I AK IOI.
using namespace std;
int n, m, cn, pn, c[50010], p[50010];
struct point{
	int x, y;
	bool operator < (point t) const
	{
		return y < t.y;
	}
}a[200010], s[200010];

bool cmp(point x, point y){
	return x.x > y.x;
}
bool check(int k)
{
	if((long long)(n - cn - pn) * k >= m)
		return true; 
	priority_queue <point> q;
	int sum = 1;
	for(int i = 1; i <= cn; i++)
	{
		while(sum <= m && a[sum].x >= c[i]) q.push(a[sum++]);
		for(int j = 1; j <= k && (!q.empty()); j++) q.pop(); 
	}
	
	int cnt = 0;
	while(!q.empty())
	{
		s[++cnt] = q.top();
		q.pop();
	} 
	for(int i = sum; i <= m; i++)
		s[++cnt] = a[i];
	sort(s + 1, s + cnt + 1);
	int top = 1;
	for(int i = 1; i <= pn; i++)
	{
		while(top <= cnt && s[top].y <= p[i]) q.push(s[top++]);
		for(int j = 1; j <= k && q.size(); j++) q.pop();
	}
	int res = q.size() + cnt - top + 1;
	return(res <= (n - cn - pn) * k);
}
int main()
{
	cin >> n >> m >> cn >> pn;
	for(int i = 1; i <= m; i++) cin >> a[i].x >> a[i].y;
	for(int i = 1; i <= cn; i++) cin >> c[i];
	for(int i = 1; i <= pn; i++) cin >> p[i];
	
	sort(a + 1, a + m + 1, cmp);
	
	sort(c + 1, c + cn + 1, greater<int>());
	
	sort(p + 1, p + pn + 1);
	
	int l = 1, r = m, mid, ans = -1;
	while(l <= r)
	{
		mid = (l + r) >> 1;
		if(check(mid)) ans = mid, r = mid - 1;
		else l = mid + 1;
	}
	cout << ans;
	return 0;
}
```

---

## 作者：toolong114514 (赞：2)

# P1752 点菜 题解
upd on 2024/7/16：忘写时间复杂度了，补一下。
## 题面大意
[传送门。](https://www.luogu.com.cn/problem/P1752)
## 解题思路
注意到答案具备单调性。

如果花费 $x$ 周能点完所有的菜，那么花费 $x+1$ 周也一定可以，这是显然的。

考虑对花费的周数 $x$ 二分，其下界为 $1$，上界为 $m$（如果一周只点一道菜，最多只有 $m$ 周），在这个范围内没有合法答案即为无解。

接下来要对 $x$ 进行 check。

注意到这个时间限制可以转化为点菜的限制，所以下文默认 $x$ 为每个人点菜的数量上限。

我们采取贪心的策略，让每个人都尽可能吃完他能吃的菜，且每个人吃的都不同（相同没有意义），判断最后是否能吃完。

依题意，按可以将客人分类按顺序讨论：
1. 想吃好的人。
2. 穷人。
3. 正常人。

对于想吃好的人，先将菜品按美味度降序排序，再将每个人的下限按降序排序，将菜品不断甩进一个大根堆（以价格为值），每个人从堆里拿菜，直到拿 $x$ 份或者堆空。

考虑证明其正确性：

按下限降序排序，使得前面的人选的菜，后面的人都能选，同时后面的人选的前面的人不一定能选，所以改变此方案一定不优。

容易发现此方案在只考虑想吃好的人时显然成立。

接下来讨论穷人。

对穷人，我们按每个人的价格上限升序排序，并对之前选剩的菜按价格升序排序，每个人按顺序那菜，直到拿满 $x$ 份或者无菜可拿。

与讨论想吃好的人的证明同理，改变此方案一定不优。

最后，计算正常人能点的最大菜数，如果大于等于剩菜数，$x$ 可以是合法答案，否则不是。

现在要将三部分的方案合起来，判断是否还是最优。

注意到想吃好的人已经将较贵的部分挑走了，所以无论是去补充没拿完的穷人还是和穷人交换，或者给正常人，都无法更优，所以我们已将想吃好的人和穷人的拿菜数最大化了。

同样，正常人的吃菜数也被最小化了，也是最优。

综上所述，我们证明了三个贪心的最优方案合起来是最优的。

所以，对 $x$ 的 check 是正确的（拿菜数最大化还是拿不完，就是不成立，否则成立）。

按上述思路编写代码即可。

##### 时间复杂度约为 $O(m\log^2m)$，可以通过本题。

~~代码难度至少严格弱于 [P1084](https://www.luogu.com.cn/problem/P1084)。~~
## 参考代码
```cpp
#include<algorithm>
#include<iostream>
#include<cstring>
#include<queue>
using namespace std;
#define int long long
const int N=5e5+10;
struct ccf{
	int qul,num,cont;
	friend bool operator<(ccf pre,ccf nxt){
		return pre.num<nxt.num;
	}
}dish1[N],dish2[N];
priority_queue<ccf> Q;
inline bool cmp1(ccf pre,ccf nxt){
	return pre.qul>nxt.qul;
}
inline bool cmp2(ccf pre,ccf nxt){
	return pre.num<nxt.num;
}
inline bool cmp3(int pre,int nxt){
	return pre>nxt;
}
inline bool cmp4(int pre,int nxt){
	return pre<nxt;
}
int n,m,p,q,ans=-1;
int lim1[N],lim2[N],cont[N];
bool vst[N];
inline bool check(int x){
	memset(vst,0,sizeof(vst));
	while(!Q.empty()) Q.pop();
	int i,j,t=1,tmp=x;
	for(i=1;i<=p;i++){
		for(j=t;j<=m;j++){
			if(dish1[j].qul>=lim1[i]){
				Q.push(dish1[j]);
			}else{
				break;
			}
		}
		t=j;
		tmp=x;
		while(!Q.empty()&&tmp>0){
			vst[Q.top().cont]=true;
			Q.pop();
			tmp--;
		}
	}
	int cnt1=0;
	for(i=1;i<=m;i++){
		if(!vst[dish1[i].cont]) dish2[++cnt1]=dish1[i];
	}
	sort(dish2+1,dish2+cnt1+1,cmp2);
	tmp=x;j=1;
	for(i=1;i<=cnt1;i++){
		if(dish2[i].num>lim2[j]||!tmp){
			tmp=x;
			j++;
		}
		if(j>q) break;
		vst[dish2[i].cont]=true;
		tmp--;
	}
	int cnt2=0;
	for(int i=1;i<=m;i++){
		if(!vst[i]) cnt2++;
	}
	if((n-p-q)*x>=cnt2) return true;
	else return false;
}
inline void read(int &x) {
	x=0;int f=1;
	char s=getchar();
	for(;s<'0'||s>'9';s=getchar()) f=s=='-'?-f:f;
	for(;s>='0'&&s<='9';s=getchar()) x=x*10+s-'0';
	x*=f;
}
signed main(){
	dish1[0].cont=-1;
	ios::sync_with_stdio(false);
	read(n);read(m);read(p);read(q);
	for(int i=1;i<=m;i++){
		read(dish1[i].qul);read(dish1[i].num); 
		dish1[i].cont=i;
	}
	sort(dish1+1,dish1+m+1,cmp1);
	for(int i=1;i<=p;i++){
		read(lim1[i]);
	}
	sort(lim1+1,lim1+p+1,cmp3);
	for(int i=1;i<=q;i++){
		read(lim2[i]);
	}
	sort(lim2+1,lim2+q+1,cmp4);
	int ll=1,rr=m;
	while(ll<=rr){
		int mid=(ll+rr)/2;
		if(check(mid)){
			ans=mid;
			rr=mid-1;
		}else{
			ll=mid+1;
		}
	}
	cout<<ans;
	return 0;
}
```
[本代码可以通过洛谷评测。](https://www.luogu.com.cn/record/165371149)

Written by [toolong114514](www.luogu.com/user/477821) on 2024/7/15.

---

## 作者：under_the_time (赞：2)

## 题意

> 有 $n$ 个人，每个人每周至多选一道菜吃掉，求吃完 $m$ 道菜的最小时间或无解。
>
> 这 $m$ 道菜有美味值和价格两个参数，$n$ 个人中 $p$ 个人只能吃美味值大于等于一定值的菜，$q$ 个人只能吃价格小于等于一定值的菜，其余人没有限制。

## 解法

可以发现如果 $x$ 周能吃完则 $x + 1$ 周也能吃完；如果 $x$ 周吃不完则 $x - 1$ 周也吃不完，说明答案具有单调性。于是考虑二分答案，`check` 的部分则贪心检查。

根据题意，一个可行的贪心方案是：总是让有限制的人群优先选择菜，且限制宽松的人总是吃掉条件更苛刻的（例如更贵的、更难吃的）菜，从而让限制较大的人产生更大的贡献。

这里我们选择优先考虑挑剔的 $p$ 个人。设第 $i$ 个挑剔的人的美味值下限为 $P_i$，第 $j$ 个贫穷的人的价格上限为 $Q_j$；第 $k$ 道菜的美味值为 $A_k$，价格为 $B_k$。

先将挑剔的人的美味值下限 $P$ 从大到小排序，将 $m$ 道菜按照美味值从大到小排序。对于第 $k$ 道菜，如果第 $i$ 个挑剔的人能接受这道菜，则把这道菜加入到一个待处理菜的队列里（原因后面会讲），然后考虑第 $(k+1)$ 道菜；如果不能接受，则让他尽可能吃光这个队列里的菜，然后考虑第 $(i + 1)$ 个人。

做法原因：因为对原数组进行过排序，第 $i$ 个人不能接受的菜，前 $(i-1)$ 个人一定无法接受；同理第 $i$ 个人能接受的菜，后 $(p-i)$ 个人一定可以接受。对于第 $i$ 个人，当前队列里的菜都是他能吃的，后面的人也能吃。这就保证了每个人在限制内吃到最多的菜，对答案贡献最大。

~~肯定有更简洁的方法，这种方法只是写起来清晰一些o.O~~

考虑完所有的菜后，如果还有挑剔的人没有被考虑，此时队列里的菜他们肯定都能吃，所以让他们去尽可能吃光队列里的菜。最后队列里剩下的菜交给穷人和普通人处理。

将贫穷的 $q$ 个人的价格上限 $Q$ 也从大到小排序。这里因为是上限，第 $j$ 个人能吃的菜，前 $(j-1)$ 个人都能吃；反之则后 $(q-i)$ 个人一定吃不起。对于第 $j$ 个贫穷的人，如果他不能接受队列中第 $k$ 贵的菜，而前面的人又都吃了尽可能多的才，则说明这道菜只能由普通人吃，将其弹出并记录，然后考虑队列中第 $(k+1)$ 贵的菜；否则当前队列比第 $k$ 贵的菜便宜的菜他都吃得起，就让他尽可能去吃这些菜，然后考虑第 $(j+1)$ 个贫穷的人。

考虑完所有贫穷的人后，队列里剩下的菜和被记录的菜由剩下的 $(n-p-q)$ 个普通人解决。最后判断普通人能否吃完即可。

## 实现

考虑挑剔的人时可以用两个指针，分别记录当前考虑到了哪道菜、哪个人，待处理队列使用优先队列（按照价格从大到小）。假设当前二分的答案为 $week$，则每个人最多可以吃掉 $week$ 道菜。最后可以用一个变量 $tot$ 记录有几道菜没被吃而被弹出（被记录的菜），设最终优先队列里还剩下 $siz$ 道菜，如果 $tot+siz\leq week(n-p-q)$，则当前答案 $week$ 合法。

设有 $m$ 道菜（$m\leq2\times10^5$），二分答案 $O(\log m)$，贪心部分 $O(m\log m)$，总时间复杂度 $O(m\log^2m)$。

## 代码

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int maxn = 50005,maxm = 2e5 + 5;
ll P[maxn],Q[maxn]; int q,n,m,p,ans = -1; pair<ll,ll> M[maxm];
bool check(int week) {
    int j = 1,tot = 0; priority_queue<int> pq;
    for (int i = 1;i <= m;i ++) {
        for (;j <= p && P[j] > M[i].first;j ++)
            for (int k = 1;k <= week;k ++)
                if (pq.empty()) break;
                else pq.pop();
        pq.push(M[i].second);
    }
    for (;j <= p;j ++)
        for (int k = 1;k <= week;k ++)
            if (pq.empty()) break;
            else pq.pop();
    for (int i = 1;i <= q;i ++) {
        while (!pq.empty() && Q[i] < pq.top())
            pq.pop(), tot ++;
        for (int k = 1;k <= week;k ++)
            if (pq.empty()) break;
            else pq.pop();
    }
    return (n - p - q) * week >= tot + pq.size();
}
int main() {
    scanf("%d%d%d%d",&n,&m,&p,&q);
    for (int i = 1;i <= m;i ++)
        scanf("%lld%lld",&M[i].first,&M[i].second);
    for (int i = 1;i <= p;i ++) scanf("%lld",&P[i]);
    for (int i = 1;i <= q;i ++) scanf("%lld",&Q[i]);
    sort(M + 1,M + m + 1); reverse(M + 1,M + m + 1);
    sort(P + 1,P + p + 1); reverse(P + 1,P + p + 1);
    sort(Q + 1,Q + q + 1); reverse(Q + 1,Q + q + 1);
    int l = 1,r = m,mid;
    while (l <= r) {
        mid = l + r >> 1;
        if (check(mid)) ans = mid, r = mid - 1;
        else l = mid + 1;
    }
    printf("%d",ans);
    return 0;
}
```

- [AC记录](https://www.luogu.com.cn/record/148323656)

---

## 作者：Awlgot (赞：2)

## P1752:

发现直接贪心得到最终答案很麻烦，但是答案具有可二分性，考虑二分答案。

有以下策略：

* 尽量让每个人都能吃到菜

* 尽量在满足限制的情况下使得全局更优

* 优先处理有限制的人群


所以将菜以美味度从大到小排序，挑剔的人同理，然后双指针将菜加入一个价格的大根堆中操作即可。

剩下的菜也用同样的策略处理给穷人，最后保证菜能吃光就行。

要注意数据的大小！

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=5e4+5,M=2e5+5;
#define pii pair<int,int>
#define fi first
#define se second
#define ll long long
int n,m,p,q;
pii a[M];
int b[N],c[N];
struct node{
	int x,y;
	bool operator<(const node &p) const{
		if(y==p.y) return x>p.x;
		return y<p.y;
	}
};
priority_queue<node> Q;
vector<pii> ans;
bool check(int x){
	ans.clear();
	int j=1;
	for(int i=1;i<=p;i++){
		while(a[j].fi>=b[i]&&j<=m){
			Q.push({a[j].fi,a[j].se});
			j++;
		}
		for(int k=1;k<=x&&!Q.empty();k++){
			Q.pop();
		}
	}
	while(!Q.empty()){
		ans.push_back(make_pair(Q.top().x,Q.top().y));
		Q.pop();
	}
	for(int i=j;i<=m;i++) ans.push_back(a[i]);
	sort(ans.begin(),ans.end(),[](pii x,pii y){
		if(x.se==y.se) return x.fi<y.fi;
		return x.se<y.se;
	});
	int cnt=0;
	for(int i=1;i<=q;i++){
		for(int k=1;k<=x&&cnt<(int)ans.size()&&ans[cnt].se<=c[i];k++,cnt++);
	}
	return ((ll)(n-p-q)*x>=(int)ans.size()-cnt?1:0);
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>n>>m>>p>>q;
	for(int i=1;i<=m;i++) cin>>a[i].fi>>a[i].se;
	sort(a+1,a+m+1,[](pii x,pii y){
		return x>y;
	});
	for(int i=1;i<=p;i++) cin>>b[i];
	sort(b+1,b+p+1,[](int x,int y){
		return x>y;
	});
	for(int i=1;i<=q;i++) cin>>c[i];
	sort(c+1,c+q+1);
	int l=1,r=m,ans=-1;
	while(l<=r){
		int mid=(l+r)>>1;
		if(check(mid) ) ans=mid,r=mid-1;
		else l=mid+1;
	}
	cout<<ans<<"\n";
}
```

---

## 作者：Waldin (赞：1)

**需要注意：这 $n$ 个人中可能存在既不挑剔也不贫穷的人。**
### 思路分析
首先，要让要来的周数最少，肯定要让每个人每周都点之前没点过的菜——不能出现不点或者重复点同一道菜的情况，不然一定不优。

然后，容易发现**答案具有单调性**，所以考虑二分答案——二分要来的周数。

接下来考虑如何判断某个要来的周数是否可行。设当前考虑的要来的周数为 $ans$，那么 $ans$ 显然可以直接看成是每个人可以点的总菜数——**不再考虑时间问题**。

然后这里显然可以贪心：先每次让挑剔的人们中最挑剔的那个还没点菜的人点他能点的菜中，价格最贵的 $ans$ 个。然后再每次让贫穷的人们中最富有的那个还没点菜的人点剩下的菜中他能点的价格最贵的 $ans$ 个。最后如果发现既不挑剔也不贫穷的人数 $\times ans\ge$ 最后剩余菜的数量，那么这个答案可行；否则就不行。
### 代码实现
二分答案的时间复杂度为 $\text O(\log m)$；贪心部分可以用**排序加二叉堆**实现：二叉堆的时间复杂度为 $\text O(m\log m)$，对挑剔和贫穷的人们排序的时间复杂度因为 $n\log n\,$比$\,p\log p+q\log q$ 增长快，所以取 $\text O(n\log n)$，对菜排序的时间复杂度为 $\text O(m\log m)$；遍历挑剔和贫穷的人们的时间复杂度为 $\Theta(n)$。故总时间复杂度为 $\text O[n\log n+m\log m+(m\log m+n)\log m]$。

具体可以参考以下实现：
```cpp
#include <bits/stdc++.h>
using namespace std;

#define typeof(...) __decltype(__VA_ARGS__)
constexpr size_t MAXn = 5e4, MAXm = 2e5;

#ifndef _getchar_nolock
#define _getchar_nolock getchar_unlocked
#endif
class FastIn_Base {
public:
    template<typename _Ty>
    FastIn_Base& operator>>(_Ty& __restrict__ int_var) noexcept {
        int c; bool f;
        if (is_signed<_Ty>::value)
            f = false;
        while (!isdigit(c = _getchar_nolock()))
            if (is_signed<_Ty>::value && c == 45)
                f = true;

        int_var = c - 48;
        while (isdigit(c = _getchar_nolock()))
            int_var = int_var * 10 + (c - 48);

        if (is_signed<_Ty>::value && f)
            int_var = -int_var;
        return *this;
    }
};
#define intIn ((FastIn_Base) {})
#define cin intIn

// 菜
class Dish {
public:
    unsigned long dainty;  // 美味度
    unsigned long price;  // 价格

    constexpr bool operator<(const Dish& y) const noexcept {
        return dainty > y.dainty;
    }
};

int main(void) noexcept {
    Dish dishes[MAXm];  // 菜们
    unsigned short n, p, q;
    unsigned long m,
        picky[MAXn],  // 挑剔的人能接受的菜的美味度的下限
        poor[MAXn];  // 贫穷的人能点的菜的价格的上限
    cin >> n >> m >> p >> q;
    for (typeof(m)i = 0; i < m; ++i)
        cin >> dishes[i].dainty >> dishes[i].price;
    for (typeof(p)i = 0; i < p; ++i)
        cin >> picky[i];
    for (typeof(q)i = 0; i < q; ++i)
        cin >> poor[i];
    sort(dishes, dishes + m);
    sort(picky, picky + p, greater<>());
    sort(poor, poor + q, greater<>());

    typeof(m)l = 1, r = m, ans = 0;
    while (l <= r) {
        auto mid = (l + r) / 2;
        priority_queue<unsigned long> h;
        typeof(m)cnt = 0;
        for (typeof(p)i = 0; i < p; ++i) {
            while (cnt < m && dishes[cnt].dainty >= picky[i]) {
                h.push(dishes[cnt].price);
                ++cnt;
            }
            for (auto j = mid; !h.empty() && j--; h.pop());
        }

        while (cnt < m) {
            h.push(dishes[cnt].price);
            ++cnt;
        }

        cnt = 0;
        for (typeof(q)i = 0; i < q; ++i) {
            while (!h.empty() && h.top() > poor[i]) {
                ++cnt;
                h.pop();
            }
            for (auto j = mid; !h.empty() && j--; h.pop());
        }

        if (cnt + h.size() <= mid * (n - p - q)) {
            ans = mid;
            r = mid - 1;
        }
        else
            l = mid + 1;
    }
    if (ans)
        cout << ans;
    else
        cout << "-1";
    return 0;
}
```

---

## 作者：wei2013 (赞：0)

## 思路：
### 单调性：
显然的，当 $k$ 越大，吃完菜的可能是越大的。
### 贪心：
将题目拆解成子问题。

根据题意归纳可得，你一定需要让挑剔的人在保证美味度的情况下，尽可能的吃贵的菜，让贫穷的人在保证价格的情况下尽可能吃美味度小的菜（其实随便吃就行，不影响），可以用优先队列进行维护。

将挑剔的人从大到小排序后，可以保证上一个人可以吃的菜，这一个人也一定能吃，然后尽可能吃 $k$ 周贵的。

将贫穷的人从小到大排序后，可以保证上一个人可以吃的菜，这一个人也一定能吃，然后尽可能吃 $k$ 周美味度小的的。
### 时间复杂度：

$\mathcal{O(n\log^2{n})}$。
## code：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int MAXM=200005,MAXN=50005;
int n,l1,l2,m,b[MAXN],c[MAXN];
struct node{
	int w,v;
	bool operator <(const node &x)const{
		return v<x.v;
	}
}a[MAXN<<2],sf[MAXN<<2];
priority_queue <node> q;
bool cmp(node a,node b){
	return a.w>b.w;
}
bool check(int k){
	if((n-l1-l2)*k>=m){
		return 1;
	}
	while(!q.empty()){
		q.pop();
	}
	int tot=1;
	for(int i=1;i<=l1;i++){
		while(tot<=m && a[tot].w>=b[i]){
			q.push(a[tot++]);
		}
		for(int j=1;j<=k && !q.empty();j++){
			q.pop();
		}
	} 
	int cnt=0;
	while(!q.empty()){
		sf[++cnt]=q.top();
		q.pop();
	}
	for(int i=tot;i<=m;i++){
		sf[++cnt]=a[i];
	}
	sort(sf+1,sf+cnt+1);
	tot=1;
	for(int i=1;i<=l2;i++){
		while(tot<=m && sf[tot].v<=c[i]){
			q.push(sf[tot++]);
		}
		for(int j=1;j<=k && !q.empty();j++){
			q.pop();
		}
	}
	int r=q.size()+cnt-tot+1;
	return r<=(n-l1-l2)*k;
}
signed main(){
	cin>>n>>m>>l1>>l2;
	for(int i=1;i<=m;i++){
		cin>>a[i].w>>a[i].v;
	}
	sort(a+1,a+m+1,cmp);
	for(int i=1;i<=l1;i++){
		cin>>b[i];
	}
	sort(b+1,b+l1+1);
	reverse(b+1,b+l1+1);
	for(int i=1;i<=l2;i++){
		cin>>c[i];
	}
	sort(c+1,c+l2+1);
	int l=1,r=m,ans=-1;
	while(l<=r){
		int mid=(l+r)>>1;
		if(check(mid)){
			ans=mid;
			r=mid-1;
		}else{
			l=mid+1;
		}
	}
	cout<<ans;
	return 0;
} 
```

---

## 作者：封禁用户 (赞：0)

## 题目传送门：[P1752 点菜](https://www.luogu.com.cn/problem/P1752)
## 思路：
我们先来看算法标签，如下图：[算法标签](https://cdn.luogu.com.cn/upload/image_hosting/hdteascq.png?x-oss-process=image/resize,m_lfit,h_170,w_225)。

我们可以知道本题的算法，可是怎么把[这三者](https://cdn.luogu.com.cn/upload/image_hosting/hdteascq.png?x-oss-process=image/resize,m_lfit,h_170,w_225)结合在一起呢？

不难发现，贪心算法可以套到二分答案的 check 函数里，再与堆一结合，完美！！！
## AC Code:
```cpp
#include<bits/stdc++.h>
#include<iostream>
#include<cmath>
#include<cstdio>
#include<map>
#include<ios>
#include<ostream>
#include<queue>
#include<stack>
#include<vector>
#include<set>
#include<string>
#include<cwchar>
#include<fstream>
#include<list>
#include<iomanip>
#include<cwctype>
#include<utility>
#include<iosfwd>
#include<streambuf>
#include<algorithm>
#include<bitset>
#include<complex.h>
#include<ctime>
#define ll long long
using namespace std;
const int maxn=50005,maxm=2e5+5;ll P[maxn],Q[maxn];int q,n,m,p,ans=-1;pair<ll,ll>M[maxm];
bool check(int week)
{
 int j=1,tot=0;priority_queue<int> pq;
 for (int i=1;i<=m;i++)
 {
  for (;j<=p&&P[j]>M[i].first;j++)
  {
   for (int k=1;k <= week;k++)
   {
    if(pq.empty())break;else pq.pop();
   }
    pq.push(M[i].second);
  }
 }
 for(;j <= p;j++){
  for (int k=1;k<=week;k++)
  {
   if (pq.empty())break;else pq.pop();
  }
 }
 for (int i=1;i <= q;i++)
 {
  while (!pq.empty() && Q[i] < pq.top())
  {
  	pq.pop();tot++;
  }
  for (int k=1;k<=week;k++)
   if(pq.empty())break;
   else pq.pop();
 }
 return (n-p-q)*week>=tot+pq.size();
}
int main()
{
 cin>>n>>m>>p>>q;
 for(int i=1;i<=m;i++)
  cin>>M[i].first>>M[i].second;
 for (int i=1;i <= p;i++)cin>>P[i];
 for (int i=1;i <= q;i++)cin>>Q[i];
 sort(M+1,M+m+1);reverse(M+1,M+m+1);sort(P+1,P+p+1);reverse(P+1,P+p+1);sort(Q+1,Q+q+1);reverse(Q+1,Q+q+1);
 int l=1,r=m,mid;
 while(l<=r)
 {
  mid=(l+r)/2;if(check(mid))ans=mid,r=mid-1;else l=mid+1;
 }
 cout<<ans;
}
``````

---

## 作者：cxoi1501 (赞：0)

### 思路：
首先，把菜按美味度从大到小排序，挑剔的人从大到小排序。   
接着，二分答案，设答案为 $ans$。   
然后把菜按美味度从大到小扔到一个价格的大根堆里（扔 
 $p$ 次，每次扔的是挑剔的人可以取的），然后挑剔的人依次取出 $ans$ 个（不足则全取）。剩下的再让贫穷的人贪心，判断当前答案是否可行。
### AC 代码：
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int maxn = 50005,maxm = 2e5 + 5;
ll P[maxn],Q[maxn]; int q,n,m,p,ans = -1; pair<ll,ll> M[maxm];
bool check(int week) {
    int j = 1,tot = 0; priority_queue<int> pq;
    for (int i = 1;i <= m;i ++) {
        for (;j <= p && P[j] > M[i].first;j ++)
            for (int k = 1;k <= week;k ++)
                if (pq.empty()) break;
                else pq.pop();
        pq.push(M[i].second);
    }
    for (;j <= p;j ++)
        for (int k = 1;k <= week;k ++)
            if (pq.empty()) break;
            else pq.pop();
    for (int i = 1;i <= q;i ++) {
        while (!pq.empty() && Q[i] < pq.top())
            pq.pop(), tot ++;
        for (int k = 1;k <= week;k ++)
            if (pq.empty()) break;
            else pq.pop();
    }
    return (n - p - q) * week >= tot + pq.size();
}
int main() {
    scanf("%d%d%d%d",&n,&m,&p,&q);
    for (int i = 1;i <= m;i ++)
        scanf("%lld%lld",&M[i].first,&M[i].second);
    for (int i = 1;i <= p;i ++) scanf("%lld",&P[i]);
    for (int i = 1;i <= q;i ++) scanf("%lld",&Q[i]);
    sort(M + 1,M + m + 1); reverse(M + 1,M + m + 1);
    sort(P + 1,P + p + 1); reverse(P + 1,P + p + 1);
    sort(Q + 1,Q + q + 1); reverse(Q + 1,Q + q + 1);
    int l = 1,r = m,mid;
    while (l <= r) {
        mid = l + r >> 1;
        if (check(mid)) ans = mid, r = mid - 1;
        else l = mid + 1;
    }
    printf("%d",ans);
    return 0;
}
``````

---

## 作者：FeelGood (赞：0)

这是一道二分加贪心的题目。

我们先二分最少需要多少天能吃完，然后我们思考怎么去检查答案。

使用贪心的策略，先考虑挑剔的人。一个挑剔的人我们再肯定想让他吃尽可能贵的食物，这样剩下的美味程度低的菜价格也会低。然后我们就可以让贫穷的人去吃剩下的菜，穷人吃完之后剩下的菜我们让既不贫穷也不挑剔的人吃，最后再判断是否吃完这些菜即可。

然后其实并不需要用数据结构，直接排序即可。下面是代码，复杂度 $O(n \log n \log m)$，需要开 O2。

```cpp
#include <bits/stdc++.h>

#define ll long long
#define lll __int128

using namespace std;

namespace FastRead
{
	void read() {}

	template<typename T1, typename ...T2>
	void read(T1 &n, T2 &...m)
	{
		T1 op = 1;
		char c;
		while (isdigit(c = getchar()) == false)
			if (c == '-')
				op = -1;
		n = c ^ 48;
		while (isdigit(c = getchar()))
			n = (n << 1) + (n << 3) + (c ^ 48);
		n *= op;
		read(m...);
	}
}

using FastRead::read;

namespace Solve
{
	const int MaxN = 5e4, MaxM = 2e5;
	
	ll a[MaxN + 10], b[MaxN + 10], n, m, p, q;
	
	bool cmp(ll a, ll b)
	{
		return a > b;
	}
	
	struct Dish
	{
		ll d, p;
	} d[MaxM + 10];
	
	bool cmp1(Dish a, Dish b)
	{
		if (a.d != b.d)
			return a.d > b.d;
		else
			return a.p > b.p;
	}
	
	bool cmp2(Dish a, Dish b)
	{
		if (a.p != b.p)
			return a.p < b.p;
		else
			return a.d < b.d;
	}
	
	bool chk(ll day)
	{
		sort(d + 1, d + m + 1, cmp1);
		ll k = 0;
		for (ll i = 1; i <= p && k < m; ++i)
		{
			for (ll j = 1; j <= day && k < m; ++j)
			{
				if (d[k + 1].d >= a[i] && k < m)
					++k;
				else
					break;
			}
		}
		sort(d + k + 1, d + m + 1, cmp2);
		for (ll i = 1; i <= q && k < m; ++i)
		{
			for (ll j = 1; j <= day && k < m; ++j)
			{
				if (d[k + 1].p <= b[i] && k < m)
					++k;
				else
					break;
			}
		}
		return (m - k) <= (n - p - q) * day;
	}
	
	void Sol()
	{
		read(n, m, p, q);
		for (ll i = 1; i <= m; ++i)
			read(d[i].d, d[i].p);
		for (ll i = 1; i <= p; ++i)
			read(a[i]);
		for (ll i = 1; i <= q; ++i)
			read(b[i]);
		sort(a + 1, a + p + 1, cmp);
		sort(b + 1, b + q + 1);
		ll l = 1, r = m, ans = -1;
		while (l <= r)
		{
			ll mid = (l + r) >> 1;
			if (chk(mid))
				ans = mid, r = mid - 1;
			else
				l = mid + 1;
		}
		printf("%lld\n", ans);
	}
}

using Solve::Sol;

int main()
{
	Sol();
	return 0;
}


```

---


# 皇后游戏

## 题目背景

还记得 NOIP 2012 提高组 Day1 的国王游戏吗？时光飞逝，光阴荏苒，两年过去了。国王游戏早已过时，如今已被皇后游戏取代，请你来解决类似于国王游戏的另一个问题。


## 题目描述

皇后有 $n$ 位大臣，每位大臣的左右手上面分别写上了一个正整数。恰逢国庆节来临，皇后决定为 $n$ 位大臣颁发奖金，其中第 $i$ 位大臣所获得的奖金数目为第 $i - 1$ 位大臣所获得奖金数目与前 $i$ 位大臣左手上的数的和的较大值再加上第 $i$ 位大臣右手上的数。

形式化地讲：我们设第 $i$ 位大臣左手上的正整数为 $a_i$，右手上的正整数为 $b_i$，则第 $i$ 位大臣获得的奖金数目为 $c_i$ 可以表达为：

$$ c_{i} = \begin{cases} a_{1}+b_{1}  & ,i=1 \\ \displaystyle \max \left \{ c_{i-1},\sum_{j=1}^{i}a_{j} \right \} +b_{i} & ,2\leq i \leq n \end{cases} % ![](https://cdn.luogu.com.cn/upload/pic/1257.png) $$

当然，吝啬的皇后并不希望太多的奖金被发给大臣，所以她想请你来重新安排一下队伍的顺序，使得获得奖金最多的大臣，所获奖金数目尽可能的少。

注意：重新安排队伍并不意味着一定要打乱顺序，我们允许不改变任何一位大臣的位置。

## 说明/提示

按照 $1,2,3$ 这样排列队伍，获得最多奖金的大臣获得奖金的数目为 $10$；

按照 $1,3,2$ 这样排列队伍，获得最多奖金的大臣获得奖金的数目为 $9$；

按照 $2,1,3$ 这样排列队伍，获得最多奖金的大臣获得奖金的数目为 $9$；

按照 $2,3,1$ 这样排列队伍，获得最多奖金的大臣获得奖金的数目为 $8$；

按照 $3,1,2$ 这样排列队伍，获得最多奖金的大臣获得奖金的数目为 $9$；

按照 $3,2,1$ 这样排列队伍，获得最多奖金的大臣获得奖金的数目为 $8$。

当按照 $3,2,1$ 这样排列队伍时，三位大臣左右手的数分别为：

$(1,2),(2,2),(4,1)$。

- 第 $1$ 位大臣获得的奖金为 $1+2=3$；
- 第 $2$ 位大臣获得的奖金为 $\max{3,3}+2=5$；
- 第 $3$ 为大臣获得的奖金为 $\max{5,7}+1=8$。

对于全部测试数据满足：$T\le10$，$1\le n\le 2\times 10^4$，$1\le a_i,b_i\le 10^9$。

## 样例 #1

### 输入

```
1
3
4 1
2 2
1 2```

### 输出

```
8```

## 样例 #2

### 输入

```
2
5
85 100
95 99
76 87
60 97
79 85
12
9 68
18 45
52 61
39 83
63 67
45 99
52 54
82 100
23 54
99 94
63 100
52 68```

### 输出

```
528
902```

# 题解

## 作者：liuzibujian (赞：610)

[洛谷p2123](https://www.luogu.org/problemnew/show/P2123)
## 前言
这是一道省选/NOI-的题目，我认为这道题确实有这么难。很多人认为没有这么难，那是因为他们的做法并不是完全正确的。我看了洛谷仅有的三篇题解，竟然有两篇是有错的。正确的那篇题解在[这里](https://www.luogu.org/blog/namasikanam/solution-p2123)。这篇仅有的正解的作者还给出了一组证明另外几篇题解有误的数据，将在后面给出。

也欢迎大家来我的[博客](https://blog.csdn.net/liuzibujian/article/details/81435356)
## 题目大意
有n个大臣，第i位大臣左手的数为$a_i$，右手的数为$b_i$，且$a_i$和$b_i$均为正整数。他能获得的数$c_i$由以下关系给出：
![这里写图片描述](https://cdn.luogu.com.cn/upload/pic/1257.png)

求$c_i$最大的大臣的$c_i$最小为多少。
##题目思路
乍一看，这题和NOIP 2012 提高组 Day1 的国王游戏很像，做题方法应该也差不多，找出一个排序方法，使得以这样排序得到的序列会使最大的$c_i$最小。观察可知，$c_i$是逐渐递增的。我们用相邻交换法考虑。设某个位置上的大臣编号为i，后面一位大臣的编号为j。设i前面所有大臣的a值之和为x，i前面那一位大臣的c值为y。若不交换，则c值较大的大臣的c值（$c_j$）为

$max(max(y,x+a_i)+b_i,x+a_i+a_j)+b_j$

化简后为

$max(y+b_i+b_j,x+a_i+b_i+b_j,x+a_i+a_j+b_j$)

同理，这两位大臣交换后，c值较大的大臣的c值（$c_i$）为

$max(y+b_i+b_j,x+a_j+b_i+b_j,x+a_i+a_j+b_i$)

假设不交换更优，则有

$max(y+b_i+b_j,x+a_i+b_i+b_j,x+a_i+a_j+b_j)\leq max(y+b_i+b_j,x+a_j+b_i+b_j,x+a_i+a_j+b_i)$

发现两边都有$y+b_i+b_j$，则可以消去（数学上是不能消去的，但这道题可以，下面会给出证明），

消去后有：

$max(x+a_i+b_i+b_j,x+a_i+a_j+b_j)\leq max(x+a_j+b_i+b_j,x+a_i+a_j+b_i)$

然后可以把x消去：

$max(a_i+b_i+b_j,a_i+a_j+b_j)\leq max(a_j+b_i+b_j,a_i+a_j+b_i)$①

再进行化简：

$max(b_i,a_j)+a_i+b_j\leq max(b_j,a_i)+a_j+b_i$②

移项：

$max(b_i,a_j)-a_j-b_i\leq max(b_j,a_i)-a_i-b_j$③

观察左式，$a_j$和$b_i$中大的数被消掉了，只剩下$a_j$和$b_i$中较小数的相反数，用数学语言表述出来就是$-min(a_j,b_i)$，那么③式可以变成：

$-min(a_j,b_i)\leq-min(a_i,b_j)$④

再把负号处理掉：

$min(a_i,b_j)\leq min(a_j,b_i)$⑤

于是我们得到了一个非常简单的式子。
#### 关于消去$y+b_i+b_j$的证明
本来我是不想写的，但有很多人来问，我就证明一下吧。

把前面的式子概括一下，可变成：

$max(a,c)\leq max(b,c)$①

现在要证明在本题中$c$可以消掉，即该式等价于$a\leq b$②

开始分类讨论：

1.$a\leq b$，满足②式，则$a$和$b$不用交换，同时又满足①式。

2.$a>b$，不满足②式，按照题意，则需要交换$a$和$b$，交换后自然就满足①式了。

综上，在本题中，$y+b_i+b_j$可以消去。
## 在洛谷AC但是错误的方法
根据得到的⑤式重载小于号（里面不能写小于等于，不然有几个点会RE，原因会在下面讲），然后进行排序。有了排完序的序列，后面只需要模拟求出每个数的c值就行了。

这是我的程序：

```
#include<iostream>
#include<algorithm>
using namespace std;
struct node
{
    int x,y;
    bool operator <(node a) const
    {
        return min(x,a.y)<min(y,a.x);//不能写<=
    }
}a[20005];
int t,n;
long long c[20005];
int main()
{
    cin>>t;
    for (int k=1;k<=t;k++)
    {
        cin>>n;
        for (int i=1;i<=n;i++) cin>>a[i].x>>a[i].y;
        sort(a+1,a+n+1);
        long long s=0;
        for (int i=1;i<=n;i++)
        {
            s+=a[i].x;
            c[i]=max(c[i-1],s)+a[i].y;
        }
        cout<<c[n]<<'\n';
    }
}
```
其实不一定要用⑤式进行排序，按照上面的①②③④式进行排序都是可以的，只不过要注意开long long，因为数据很大，加法容易溢出。

这是我用②式写的程序：

```
#include<iostream>
#include<algorithm>
using namespace std;
struct node
{
    long long x,y;
    bool operator <(node a) const
    {
        return x+a.y+max(a.x,y)<y+a.x+max(a.y,x);
    }
}a[20005];
int t,n;
long long c[20005];
int main()
{
    cin>>t;
    for (int k=1;k<=t;k++)
    {
        cin>>n;
        for (int i=1;i<=n;i++) cin>>a[i].x>>a[i].y;
        sort(a+1,a+n+1);	
        long long s=0;
        for (int i=1;i<=n;i++)
        {
            s+=a[i].x;
            c[i]=max(c[i-1],s)+a[i].y;
        }
        cout<<c[n]<<'\n';
    }
}
```
#### 为什么重载小于号时不能加等号
我也是想了好久才想出来的。这其实是你快排没有掌握好，才会加等号。系统自带的排序和手写快排差不多，于是我手写了一下快排。

```
#include<iostream>
#include<algorithm>
using namespace std;
int n,a[1005];
void qsort(int l,int r)
{
    int x=a[(l+r)/2];
    int i=l,j=r;
    while (i<=j) 
    {
        while (a[i]<=x) 
		{
//			cout<<i<<' '<<a[i]<<'\n';
			i++;
		}
        while (a[j]>=x) j--;
        if (i<=j)
        {
            int t=a[i];
            a[i]=a[j];
            a[j]=t;
            i++;
            j--;	
        }
    }
    if (l<j) qsort(l,j);
    if (r>i) qsort(i,r);
}
int main()
{
	cin>>n;
	for (int i=1;i<=n;i++) cin>>a[i];
	qsort(1,n);
	for (int i=1;i<=n;i++) cout<<a[i]<<' ';
}
```
重载小于号重载的就是第11行和16行的小于号，让我们看看改成小于等于号会有怎样的结果。你可以把注释掉的那行话的注释符取消掉，输出来。你会发现，它会循环到数组越界之后才会停止（本来开的100000的数组，等了好久才等到它输完，方便起见，改为1000）。所以重载小于号一定不能加等于，不然很容易RE。
#### 为什么这种方法是错的
之前提到的三篇题解中唯一一篇正确的题解的作者提供了一组hack数据：
输入：

```
2
7
6 3
1 1
7 3
1 1
1 6
1 1
6 10

7
6 10
1 1
6 3
1 1
7 3
1 1
1 6
```
输出：

```
26
26
```

两组数据只是顺序不一样，但用上面的程序输出的结果也是不同的。为什么会这样呢？再具体地分析一下。假设有三位大臣，他们的a[i]和b[i]分别是：

```
7 3
1 1
1 6
```

显然，这样可以是排完序后的结果，因为两两之间用条件判断都是等于。这样算出来答案是17。而如果这样排：
```
1 1
1 6
7 3
```
答案是12，显然这样更优，但程序却有可能排成17的那种情况。

虽然按条件判断相等的两组数交换一次对后面确实不会产生影响，但可以通过多次交换对最终结果产生影响。

错误的根本原因就是，这个判断条件不满足传递性。
## 正确解法
写正确解法之前，我先要好好感谢一下那位第一个写正解的大佬，是他的博客和他的数据才引发了我以下的思考。
既然要使排序能满足传递性，就应该想出一个对所有数普遍适用的一个排序条件，而不只针对于相邻的两个数。上面得到的⑤式肯定要被用起来。再仔细观察一下这个式子：

$min(a_i,b_j)\leq min(a_j,b_i)$

可以发现，大概应该和a与b的大小关系有关（$a_i$和$b_i$哪个大）。还有，要使一个数排在前面，那么a越小越好，b越大越好。我们先按a与b的大小关系把所有数据分为三大组，然后开始讨论：

1.当$a_i<b_i$，$a_j<b_j$时，$a_i\leq a_j$，应该按a升序排序（$a_i$和$a_j$相等时无所谓）。

2.当$a_i=b_i$，$a_j=b_j$时，爱怎么排怎么排。

3.当$a_i>b_i$，$a_j>b_j$时，$b_i\geq b_j$，应该按b降序排序。

那么这三大组之间应该怎样排序呢？

1组和2组，1组在2组前肯定能保证满足条件。2组和3组，2组在3组前面肯定能保证满足条件。那么1组在前，2组在中，3组在后，是肯定能保证满足要求的。

我们令$d_i=\frac{a_i-b_i}{|a_i-b_i|}$，那么1组的d值为-1，2组为0，3组为1。

于是我们得到了最终的排序条件：**先按d值排序；然后若d值小于等于0，按a升序排序（这里把2组归入1组）；若d值大于0，则按b降序排序。**
这样就可以满足传递性了。

这是完全正确的代码：
```
#include<iostream>
#include<algorithm>
#include<cmath>
using namespace std;
struct node
{
    int x,y,d;
    bool operator <(node a) const
    {
        if (d!=a.d) return d<a.d;
        if (d<=0) return x<a.x;
        return y>a.y;
    }
}a[20005];
int t,n;
long long c[20005];
int main()
{
    cin>>t;
    for (int k=1;k<=t;k++)
    {
        cin>>n;
        for (int i=1;i<=n;i++) 
		{
			cin>>a[i].x>>a[i].y;
			if (a[i].x>a[i].y) a[i].d=1;
			else if (a[i].x<a[i].y) a[i].d=-1;
			else a[i].d=0;
		}
        sort(a+1,a+n+1);
        long long s=0;
        for (int i=1;i<=n;i++)
        {
            s+=a[i].x;
            c[i]=max(c[i-1],s)+a[i].y;
        }
        cout<<c[n]<<'\n';
    }
}
```
## 总结
这一道题是一道不错的题，美中不足的是，数据太弱了，以致于让错误的解法鱼目混珠。这一道题对得起省选/NOI-的难度评定。希望下次来看的时候，数据已经加强了，正确的解法已经深入人心了。

---

## 作者：ouuan (赞：163)

[题目地址](https://www.luogu.org/problemnew/show/P2123)

[相关文章](https://ouuan.github.io/浅谈邻项交换排序的应用以及需要注意的问题/)

## 内容简介

1. 详细说明直接比较 $\min(a_i,b_j)$ 和 $\min(a_j,b_i)$ 为什么是错的。

2. 给出一（实际上是两）种无需 $d_i=sgn(a_i-b_i)$ 的做法。

3. 给出一份判断一个比较方式是否是正解的代码。

所以，看懂本篇题解并不是解题所必要的，事实上本篇题解并没有讲如何推导出贪心式，这部分其它题解已经讲得很详细了。

但如果能看懂本篇题解的思想，并亲自推一遍，一定会有不小的收获。

本篇题解公式极多，等号极多，下标极多，难免手误，还请指出。

## Part0

看本篇题解需要对`Strict Weak Ordering`有所了解，可以参考[这篇博客](https://www.cnblogs.com/walkerlala/p/5561339.html)。

简单来说，$\rm STL$ 的任何比较函数（包括但不限于使用`std::sort`、`std::lower_bound`、`std::priority_queue`时重载的小于号），都需要满足以下四个条件：（用 $<$ 表示重载的运算符）

1. $x\not<x$ （非自反性）
2. 若 $x<y$，则 $y\not<x$ （非对称性）
3. 若 $x<y,y<z$，则 $x<z$ （传递性）
4. 若 $x\not<y,y\not<x,y\not<z,z\not<y$，则 $x\not<z,z\not<x$ （不可比性的传递性）

事实上可以由 $1$ 和 $3$ 推出 $2$ 。

## Part1

这部分严格地证明了不能直接比较 $\min(a_i,b_j)$ 和 $\min(a_j,b_i)$

### 一、

为什么比较时不能加等号，即为什么不能是 $\min(a_i,b_j)\le \min(a_j,b_i)$。

因为如果加了等号，$\min(a_i,b_i)\le \min(a_i,b_i)$，不满足非自反性。

### 二、

为什么不加等号也是错的呢？~~因为有hack数据~~

```
2
7
6 3
1 1
7 3
1 1
1 6
1 1
6 10
7
6 10
1 1
6 3
1 1
7 3
1 1
1 6
```
```
26
26
```

在[这篇题解](https://www.luogu.org/blog/liuzibujian/solution-p2123)中提到了：

```
错误的根本原因就是，这个判断条件不满足传递性。
```

实际上这个判断条件满足传递性，但不满足不可比性的传递性。

### 满足传递性的证明：

命题：$\forall \begin{cases}\min(a_i,b_j)<\min(a_j,b_i)\\\min(a_j,b_k)<\min(a_k,b_j)\end{cases}$，有 $\min(a_i,b_k)<\min(a_k,b_i)$。

将上式拆解成逻辑式，即证：

$\forall \begin{cases}(a_i<a_j\lor b_j<a_j)\land(a_i<b_i\lor b_j<b_i)\\(a_j<a_k\lor b_k<a_k)\land(a_j<b_j\lor b_k<b_j)\end{cases}$，有 $(a_i<a_k\lor b_k<a_k)\land(a_i<b_i\lor b_k<b_i)$。

假设原命题不成立，即 $\exists\begin{cases}(a_i<a_j\lor b_j<a_j)\land(a_i<b_i\lor b_j<b_i)\quad(1)\\(a_j<a_k\lor b_k<a_k)\land(a_j<b_j\lor b_k<b_j)\quad(2)\\(a_i\ge a_k\land b_k\ge a_k)\lor(a_i\ge b_i\land b_k\ge b_i)\quad(3)\end{cases}$

分别讨论 $(3)$ 式成立的两种情况：

若 $a_i\ge a_k\land b_k\ge a_k$，由 $(2)$ 式得 $a_j<a_k$，进而推出 $a_j<a_i$，再由 $(1)$ 式得 $b_j<a_j$，再由 $(2)$ 式得到 $b_k<b_j$，所以 $b_k<b_j<a_j<a_k$，与 $b_k\ge a_k$ 矛盾，不成立。

若 $a_i\ge b_i\land b_k\ge b_i$，与上面类似，由 $(1)$ 式得 $b_j<b_i$，进而推出 $b_j<b_k$，再由 $(2)$ 式得到 $a_j<b_j$，再由 $(1)$ 式得到 $a_i<a_j$，所以 $a_i<a_j<b_j<b_i$，与 $a_i\ge b_i$ 矛盾，不成立。

综上所述，假设不成立。

所以，$P_{i,j}=\min(a_i,b_j)<\min(a_j,b_i)$ 具有传递性。

### 不具有不可比性的传递性的证明：

命题：$\forall \begin{cases}\min(a_i,b_j)=\min(a_j,b_i)\\\min(a_j,b_k)=\min(a_k,b_j)\end{cases}$，有 $\min(a_i,b_k)=\min(a_k,b_i)$。

很明显，当 $a_j=b_j$ 且都很小时存在反例，如：

$\begin{array}{c|c|c}&a&b\\i&3&5\\j&1&1\\k&2&7\end{array}$

$\begin{cases}\min(3,1)=\min(1,5)\\\min(1,7)=\min(2,1)\end{cases}$，但 $\min(3,7)\ne \min(2,5)$。

这样的反例还有很多，所以，$P_{i,j}=\min(a_i,b_j)<\min(a_j,b_i)$ 不具有不可比性的传递性。

### 三、

总结：$P_{i,j}=\min(a_i,b_j)<\min(a_j,b_i)$ 不满足`Strict Weak Ordering`的要求，不能作为`std::sort`的比较函数。

## Part2

真的需要用 $d_i=sgn(a_i-b_i)$ 来分组比较吗？当然是不用的，而且个人认为像[这篇题解](https://www.luogu.org/blog/namasikanam/solution-p2123)这样做很不自然..起码我是想不到这种神奇的做法的QAQ.

上面写了一大堆公式，是不是已经有人已经跑路了..现在开始讲一些纯贪心内容。

比较相邻两项时，若 $\min(a_i,b_j)=\min(a_j,b_i)$ ，从全局来看，把 $a$ 更小的放前面是不会更差的。所以得到另一个排序方式：

$P^{'}_{i,j}=\begin{cases}a_i<a_j\quad(\min(a_i,b_j)=\min(a_j,b_i))\\\min(a_i,b_j)<\min(a_j,b_i)\quad(otherwise)\end{cases}$

~~讲完了短暂的贪心，又要开始证明了~~

### 满足非自反性：

$\min(a_i,b_i)=\min(a_i,b_i)$，$a_i\not <a_i$。

### 满足非对称性：

当 $\min(a_i,b_j)<\min(a_j,b_i)$ 时，$\min(a_j,b_i)\not <\min(a_i,b_j)$。

当 $\min(a_i,b_j)=\min(a_j,b_i),a_i<a_j$ 时，$\min(a_j,b_i)=\min(a_i,b_j),a_j\not <a_i$。

### 满足传递性和不可比性的传递性：

一开始我想像上面那样分类讨论做..然后差点就把这篇文章弃坑了..

~~后来才想起来我是OIer不是MOer~~

```
#include <iostream>
#include <cstdio>
#include <algorithm>

using namespace std;

bool cmp(int x,int y);

int a[10],b[10];

int main()
{
	for (a[0]=1;a[0]<=6;++a[0])
	{
		for (b[0]=1;b[0]<=6;++b[0])
		{
			if (cmp(0,0))
			{
				printf("No irreflexivity:%d %d\n",a[0],b[0]);
			}
			for (a[1]=1;a[1]<=6;++a[1])
			{
				for (b[1]=1;b[1]<=6;++b[1])
				{
					if (cmp(0,1)&&min(a[0],b[1])>min(a[1],b[0]))
					{
						printf("Not the best:%d %d %d %d\n",a[0],b[0],a[1],b[1]);
					}
					for (a[2]=1;a[2]<=6;++a[2])
					{
						for (b[2]=1;b[2]<=6;++b[2])
						{
							if (cmp(0,1)&&cmp(1,2)&&!cmp(0,2))
							{
								printf("No transitivity:%d %d %d %d %d %d\n",a[0],b[0],a[1],b[1],a[2],b[2]);
							}
							if (!cmp(0,1)&&!cmp(1,0)&&!cmp(1,2)&&!cmp(2,1)&&(cmp(0,2)||cmp(2,0)))
							{
								printf("No transitivity of incomparability:%d %d %d %d %d %d\n",a[0],b[0],a[1],b[1],a[2],b[2]);
							}
						}
					}
				}
			}
		}
	}
	
	return 0;
}

bool cmp(int x,int y)
{
	return min(a[x],b[y])==min(a[y],b[x])?a[x]<a[y]:min(a[x],b[y])<min(a[y],b[x]);
}
```

运行，什么都没发生？？那就对了！

这说明 $P^{'}_{i,j}=\begin{cases}a_i<a_j\quad(\min(a_i,b_j)=\min(a_j,b_i))\\\min(a_i,b_j)<\min(a_j,b_i)\quad(otherwise)\end{cases}$ 既满足`strict weak ordering`，又保证排好序后替换邻项不会更优，是一个可以解决这道题目的排序方式。

事实上，更改上面给出的代码中的`cmp`，若没有任何输出即可作为本题的比较函数。

可以利用上面的代码快速验证：

- $P_{i,j}=\min(a_i,b_j)<\min(a_j,b_i)$ 不具有不可比性的传递性。

- $P^{''}_{i,j}=\begin{cases}b_i>b_j\quad(\min(a_i,b_j)=\min(a_j,b_i))\\\min(a_i,b_j)<\min(a_j,b_i)\quad(otherwise)\end{cases}$ 是这题另一个可行的比较方式。

- $P^{'''}_{i,j}=\begin{cases}a_i>a_j\quad(\min(a_i,b_j)=\min(a_j,b_i))\\\min(a_i,b_j)<\min(a_j,b_i)\quad(otherwise)\end{cases}$ 不具有传递性。

---

## 作者：TA123 (赞：110)

### 做法

令$d_i = sgn(a_i - b_i)$

先按$d_i(-1,0,1)$顺序把大臣分为三组，在每一组内分别排序：
1. $d_i=-1$，按$a_i$升序排序。
2. $d_i=0$，以任意顺序排序。
3. $d_i=1$，按$b_i$降序排序。

求出$c_n$并输出。

### 证明

#### 偏序关系

令$P_{i,j}=\left \{ \begin{aligned} [d_i<d_j] & ,d_i != d_j \\ [a_i \le a_j] & ,d_i=d_j \le 0 \\ [b_i > b_j] & ,d_i=d_j=1 \end{aligned} \right.$

（即按上述做法重载$\le$）

因为$P_{i,j}$不过是多个排序的复合，所以它满足自反、反对称和传递性，是一个偏序关系，可以以$P_{i,j}$作为$\le$来排序。

接下来只需要证明若$P_{i,i+1}=1$，则交换$i$和$i+1$不会使答案更优即可。

#### 何时更优

注意到$\forall 0 \le i < n,c_i \le c_{i+1}$，所以交换时我们只需要考虑后一项的大小关系，什么时候交换不会导致答案变优呢？（下面以$j=i+1$；$c$是$c_{i-1}$；$s=\sum_{k=1}^{i-1}a_k$）

$$\max ( \max (c,s + a_i) + b_i,s + a_i + a_j) + b_j$$
$$= \max \{ c , s + a_i , s + a_i - b_i + a_j \} + b_i + b_j$$
$$\le \max \{ c, s + a_j , s + a_j - b_j + a_i \} + b_i + b_j$$

化简：$\max (a_i, a_i - b_i + a_j ) \le \max (a_j,a_j - b_j + a_i)$

两边同时减去$a_i + a_j$：$\max (-a_j,-b_i) \le \max (-a_i,-b_j)$

乘以$-1$：$\min (a_j,b_i) \ge \min (a_i,b_j)$

拆解成逻辑表达式：
$$(a_i \le a_j \lor b_j \le a_j) \land (a_i \le b_i \lor b_j \le b_i)(*)$$

#### 在此相遇

至此，我们只需要验证$P_{i,j}=1$时符合$( * )$式即可。

1. $d_i = d_j \le 0$：$a_i \le a_j$，满足左边；$a_i \le b_i$，满足右边。
2. $d_i = d_j =1$：$b_j < a_j$，满足左边；$b_j < b_i$，满足右边。
3. $d_i < d_j$：$b_j \le a_j$，满足左边；$a_i \le b_i$，满足右边。

### 代码
```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 50000;
struct Secretary
{
    int a, b, d;
} sty[N + 5];
inline bool cmp(const Secretary &x, const Secretary &y)
{
    if (x.d != y.d)
        return x.d < y.d;
    if (x.d <= 0)
        return x.a < y.a;
    else
        return x.b > y.b;
}
int main()
{
    int T;
    scanf("%d", &T);
    while (T--)
    {
        int n;
        scanf("%d", &n);
        for (int i = 1; i <= n; ++i)
        {
            scanf("%d%d", &sty[i].a, &sty[i].b);
            sty[i].d = sty[i].a - sty[i].b;
            if (sty[i].d)
                sty[i].d /= abs(sty[i].d);
        }
        sort(sty + 1, sty + n + 1, cmp);
        ll c = 0, s = 0;
        for (int i = 1; i <= n; ++i)
        {
            s += sty[i].a;
            c = max(c, s) + sty[i].b;
        }
        printf("%lld\n", c);
    }
}
```

---

## 作者：lsoer (赞：51)

#### 前置链接

[P1080 国王游戏](https://www.luogu.com.cn/problem/P1080)（如果没过的话建议先过）

[P2123 皇后游戏](https://www.luogu.com.cn/problem/P2123)（本题）

[大佬的题解](https://ouuan.github.io/post/%E6%B5%85%E8%B0%88%E9%82%BB%E9%A1%B9%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F%E7%9A%84%E5%BA%94%E7%94%A8%E4%BB%A5%E5%8F%8A%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E9%97%AE%E9%A2%98/)（如果需要深入了解和更多知识）

### 一，目标：最后的大臣

这是一个困难的任务，但无论如何，皇后请我们去解决问题，我们应该全力以赴，~~说不定省下的钱可以分一点~~~~

让我们观察一下奖金的表达式：

$$
c_{i}=
\begin{cases} 
a_{1}+b_{1},  & \ i=1 \\
\max \left \{  c_{i-1},\sum_{j=1}^{i}a_{j}  \right \}+b_{i}, & \ 2\leq i \leq n
\end{cases}
$$

有
$$
c_i=\max \{ c_{i-1},\sum_{j=1}^{i}a_{j} \}+b_i \geqslant c_{i-1}+b_i > c_{i-1}
$$

这说明，**排得越靠后的大臣得到的奖金越多**。

由此可以知道得到奖金最多的大臣就是排最后的大臣，而皇后需要得到奖金最多的大臣的到的奖金尽量少，所以我们需要让排最后的大臣尽量少得奖金。

### 二，两个人间的选择

让我们从简单的情况开始吧。

现在假设一位不愿留下姓名的智者已经帮我们把前面的队伍排好了，只剩下两位大臣伊凡（Ivan）和杰克（Jack）在等待中了。我们就叫他们 $i$ 和 $j$ 好了。 

两位大臣都想站在最后以获得最多的奖金，但皇后有她的心思。

当 $i$ 站在 $j$ 前时队伍是这样的(前面队伍的最后一个人是萨姆Sam,称为 $s$ ）：

| **大臣** | $1$ | $2$ | ... | $s$ | $i$ | $j$ |
| ------------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: |
| **左手** | $a_1$ | $a_2$ | ... | $a_s$ | $a_i$ | $a_j$ |
| **右手** | $b_1$ | $b_2$ | ... | $b_s$ | $b_i$ | $b_j$ |
| **奖金** | $c_1$ | $c_2$ | ... | $c_s$ | $c_i$ | $c_j$ |

设
$S=a_1+a_2+...+a_s=\sum_{k=1}^s a_k$

此时 $i$ 得到的奖金为
$ c_{i,1}=\max(c_s,S+a_i)+b_i  $

 $j$ 得到的奖金为
$ C_1=c_{j,1}=\max(c_{i,1},S+a_i+a_j)+b_j $

**$C_1$为我们将 $i$ 排前面时发出的最多奖金。**

**如果将他们两个交换位置，那么同理我们可以得到我们将 $j$ 排前面时发出的最多奖金为$C_2=c_{i,2}=\max(c_{j,2},S+a_i+a_j)+b_i$**

(  $c_{j,2}=\max(c_s,S+a_j)+b_j$  )

现在我们比较一下 $C_1$ 和 $C_2$ ：
$$
C_1=\max(\max(c_s,S+a_i)+b_i,S+a_i+a_j)+b_j
$$
$$
C_2=\max(\max(c_s,S+a_j)+b_j,S+a_i+a_j)+b_i
$$

嗯。。。有些惨不忍睹。

在下一步处理前你要先看一下这几个式子（~~都很显然~~）

$$
\max(p,q)+r=\max(p+r,q+r)
$$
$$
\max(\max(p,q),r)=\max(p,q,r)
$$

就这样我们得到了：
$$
C_1=\max(c_s+b_i+b_j,S+a_i+b_i+b_j,S+a_i+a_j+b_j)
$$
$$
C_2=\max(c_s+b_i+b_j,S+a_j+b_i+b_j,S+a_i+a_j+b_i)
$$

冷静一下，让我们来仔细观察一下这两个式子。

很容易发现两边都有（$c_s+b_i+b_j$）这个部分。

那么设
$$
P=c_s+b_i+b_j
$$
$$
Q=\max(S+a_i+b_i+b_j,S+a_i+a_j+b_j)
$$
$$
R=\max(S+a_j+b_i+b_j,S+a_i+a_j+b_i)
$$

有
$$
C_1=\max(P,Q)
$$
$$
C_2=\max(P,R)
$$

看上去好多了，不是吗？

要比较两者，先关注不同的部分 $Q$ 和 $R$ 。

我们请皇后叫一个计算师来计算一下这两个值。

“报告，经计算，$Q$不大于$R$。”（~~这怎么算的，把计算师拖下去。。。~~）

那么，已知 $Q \leqslant R$ ,如何比较 $C_1$ 和 $C_2$ 呢？

其实有：$Q \leqslant R \Rightarrow \max(P,Q)\leqslant\max(P,R)$即$C_1 \leqslant C_2$

如何证明？

若 $P \leqslant Q \leqslant R$ ,则 $\max(P,Q)=Q \leqslant R=\max(P,R)$

若 $Q \leqslant P \leqslant R$ ,则 $\max(P,Q)=P \leqslant R=\max(P,R)$

若 $Q \leqslant R \leqslant P$ ,则 $\max(P,Q)=P=\max(P,R)$

**很好，梳理一下，由我们得知 $Q \leqslant R$ ,可得到 $C_1 \leqslant C_2$，即表明如果我们让 $i$ 站在 $j$ 前，发出的最多奖金将会更少。**

通知皇后将伊凡排在杰克前，大功告成。

### 三，更深入的准则

刚才我们分析了最后两个人的情况，并得到了一个结论（即比较 $Q$ 和 $R$ )，但事实上我们需要解决的是整个大臣群体的排队问题，我们需要继续研究之前的结论来获得更多的启示。

$Q \leqslant R$ ，根据各自的定义，即是
$$\max(S+a_i+b_i+b_j,S+a_i+a_j+b_j) \leqslant \max(S+a_j+b_i+b_j,S+a_i+a_j+b_i)$$

根据之前的那个显然的式子，有

$$\max(b_i,a_j)+S+a_i+b_j \leqslant \max(b_j,a_i)+S+a_j+b_i$$

$$a_i+b_j-\max(a_i,b_j) \leqslant a_j+b_i-\max(a_j,b_i)$$

不等号左边的意思是 $a_i$ 和 $b_j$ 的和减去二者中较大的那个，这会使较小的那个留下，等价于 $\min(a_i,b_j)$ ，同理右边等价于 $\min(a_j,b_i)$ 。

$$\min(a_i,b_j) \leqslant \min(a_j,b_i)$$

这即是我们需要的重要准则。它表明：

**1.对于两个大臣 $i$ 和 $j$ ，我们需比较 $\min(a_i,b_j)$ 和 $\min(a_j,b_i)$ ，若 $\min(a_i,b_j) \leqslant \min(a_j,b_i)$ ，那将 $i$ 排在 $j$ 前可使靠后一个人得到的奖金尽可能少。**

**2.这不受他们前面和后面的大臣的影响。**

在另一方面，我们再看一次这个式子：$c_i=\max \{ c_{i-1},\sum_{j=1}^{i}a_{j} \}+b_i$

对于任何一个大臣，改变他前方大臣的排序不会影响到 $\sum_{j=1}^{i}a_{j}$的大小 ($a+b+c=b+a+c$)，而如果 $c_{i-1}$ 变小，那 $c_i$ 也不会变得更大（只可能不变或变小），这对我们的最终目标：最后的大臣尽量少拿钱是有帮助的。

**综上所述，我们可以将这个重要准则用于所有大臣，每一次交换位置都对我们的最终目标有利。让这个准则成为排序准则，得到一个大臣队伍序列，那应该就是答案。**

但事情还没完。。。

### 四，不完整的准则

理想丰满，现实残酷。

皇后下命令让士兵给大臣排队，但在执行中，我们很快发现了问题：

如果 $\min(a_i,b_j) = \min(a_j,b_i)$，二者如何排序？

随便排吗？哦，那可会出问题的。

让我们请来 $i$ , $j$ ,$k$ 三位大臣，假设他们左右手上数字的情况如下：

| **大臣** | **左手a** | **右手b** |
| -----------: | -----------: | -----------: |
| $i$ | 2 | 3 |
| $j$ | 3 | 4 |
| $k$ | 1 | 1 |

士兵先看了看 $i$ 和 $k$ ，$\min(a_i,b_k)=\min(2,1)=1$ , $\min(a_k,b_i)=\min(1,3)=1$ 。

“好吧，你们俩就随便排吧。 $k$ 就排 $i$ 前面吧。”

士兵又看了看 $j$ 和 $k$ , $\min(a_j,b_k)=\min(3,1)=1$ , $\min(a_k,b_j)=\min(1,j)=1$ 。

“也是无所谓。 $j$ 就排 $k$ 前面吧。”

现在的情况（越向下越靠前）：

| **大臣** | **左手a** | **右手b** | **奖赏c** |
| -----------: | -----------: | -----------: | -----------: |
| $j$ | 3 | 4 | 7 |
| $k$ | 1 | 1 | 8 |
| $i$ | 2 | 3 | 11 |

但，细心的你一定已经发现了：$\min(a_i,b_j)=\min(2,4)=2<\min(a_j,b_i)=\min(3,3)=3$

这表明， $i$ 应该在 $j$ 前，如果我们交换 $i$ 和 $j$ ,那结果是：

| **大臣** | **左手a** | **右手b** | **奖赏c** |
| -----------: | -----------: | -----------: | -----------: |
| $i$ | 2 | 3 | 5 |
| $k$ | 1 | 1 | 6 |
| $j$ | 3 | 4 | 10 |

看到这里，皇后已经打算把那个士兵扔到海里喂鱼了。但这并不是他的错，问题出在我们的排序准则上：

$i=k,j=k \nRightarrow i=j$

我们需要更完整的准则。

### 五，解决之道

让我们去采访一下伊凡（$i$)吧，他正为自己排在 $j$ 前面而生气呢。

“你对于这次排队的情况，有什么看法吗？”

“天哪，这完全是因为我左手上的数字太小，而右手上的太大了！”

就是这样，让我们再次观察一下那个重要准则：

$$\min(a_i,b_j) \leqslant \min(a_j,b_i)$$

从 $i$ 的角度出发，他无法左右 $a_j$ 和 $b_j$ 的大小，于是他只关注 $a_i$ 和 $b_i$ ，他看到了：

$$a_i \leqslant b_i$$

$a_i$ 太小，$b_i$ 太大促成了上式的成立，最终让他排得靠前。

**重要结论：左手数字越小，右手数字越大，越应该靠前排。**

于是我们应该这样排序：

**1.如果$\min(a_i,b_j) < \min(a_j,b_i)$，将 $i$ 排在 $j$ 前。**

**2.如果$\min(a_i,b_j) = \min(a_j,b_i)$，将左手数字小的排前，或将右手数字大的排前。**

这样就没什么问题了。

### 六，神奇时刻

还有另一种排序方式。

让我们把所有大臣分为三组：倒霉蛋组，普通组，幸运儿组。

#### 倒霉蛋组：

如果一个大臣左手上的数字小于右手上的数字（$a_i<b_i$)，那么他进入此组。

**对于此组的大臣，按左手上数字进行升序排序。**

这样做符合重要准则，证明如下：

已知：$a_i<b_i,a_j<b_j,a_i \leqslant a_j$

证：$\min(a_i,b_j) \leqslant \min(a_j,b_i)$

证明：$\min(a_i,b_j) \leqslant a_i$，又$a_i<b_i,a_i \leqslant a_j$可得$\min(a_i,b_j) \leqslant \min(a_j,b_i)$

#### 普通组：

如果一个大臣左手上的数字等于右手上的数字（$a_i=b_i$)，那么他进入此组。

**对于此组的大臣，无排序规则。**

此组大臣任意两人间都无法用重要准则排序，因此虽然是随便排，但是不会出现之前一样的问题。

#### 幸运儿组：

如果一个大臣左手上的数字大于右手上的数字（$a_i>b_i$)，那么他进入此组。

**对于此组的大臣，按右手上数字进行降序排序。**

这样做也符合重要准则，证明类似倒霉蛋组。

#### 组与组之间：

**倒霉蛋组始终在前，普通组在中，幸运儿组始终在后。**

这样做符合重要准则。

(假设$i$在倒霉蛋组，$k$在普通组，$j$在幸运儿组）

$$a_i<b_i,a_k=b_k \Rightarrow \min(a_i,b_k)<\min(a_k,b_i)$$
$$a_j>b_j,a_k=b_k \Rightarrow \min(a_j,b_k)>\min(a_k,b_j)$$

事实上就是：

($P$ 代表普通组）

$$Q<R \Rightarrow \min(Q,P)<\min(P,R)$$
(倒霉蛋组与普通组）
$$Q>R \Rightarrow \min(Q,P)>\min(P,R)$$
（幸运儿组与普通组）

证明类似于**二**中的$Q \leqslant R \Rightarrow \max(P,Q)\leqslant\max(P,R)$。

### 七，代码如下
**五**中的方法：

```
#include<iostream>
#include<algorithm>
using namespace std;
struct meo
{
	int a,b;
}m[20010];//大臣们 
bool cmp(meo x,meo y)
{
	if (min(x.a,y.b)==min(x.b,y.a))
	return x.a<y.a;//或是 return x.b>y.b; 
	else
	return min(x.a,y.b)<min(x.b,y.a);
}
long long c[20010];
int main()
{
	int T,n;
	cin>>T;
	long long sum;
	for (int i=1;i<=T;++i)
	{
		cin>>n;
		for (int j=1;j<=n;++j)
		cin>>m[j].a>>m[j].b;
		sort(m+1,m+n+1,cmp);//排序部分，再下为模拟部分 
		sum=0;
		for (int j=1;j<=n;++j)
		{
			sum+=m[j].a;
			c[j]=max(c[j-1],sum)+m[j].b;
		}
		cout<<c[n]<<endl;
	}
	return 0;
}
```
**六**中的方法：
```
#include<iostream>
#include<algorithm>
using namespace std;
struct meo
{
	int a,b,d;//d表示组别，1=倒霉蛋，0=普通，-1=幸运儿 
}m[20010];
bool cmp(meo x,meo y)
{
	if (x.d!=y.d)
	return x.d>y.d;
	else if (x.d>0)
	return x.a<y.a;
	else
	return x.b>y.b;
	
}
long long c[20010];
int main()
{
	int T,n;
	cin>>T;
	long long sum;
	for (int i=1;i<=T;++i)
	{
		cin>>n;
		for (int j=1;j<=n;++j)
		{
			cin>>m[j].a>>m[j].b;
			if (m[j].a<m[j].b)
			m[j].d=1;//倒霉蛋组 
			else if (m[j].a>m[j].b)
			m[j].d=-1;//幸运儿组 
			else
			m[j].d=0;//普通组
			/*
			事实上这里写成
			m[j].d=(m[j].b-m[j].a)/abs(m[j].b-m[j].a);
			会更聪明 
			*/ 
		}
		sort(m+1,m+n+1,cmp);
		sum=0;
		for (int j=1;j<=n;++j)
		{
			sum+=m[j].a;
			c[j]=max(c[j-1],sum)+m[j].b;
		}
		cout<<c[n]<<endl;
	}
	return 0;
}
```


---

## 作者：Cry_For_theMoon (赞：12)

[传送门](https://www.luogu.com.cn/problem/P2123)

主要补充一下最后构造答案的说明（第一篇题解最后讲的有点简略了我觉得qwq）

首先看到“安排顺序”自然想到比较相邻两项的经典套路。但如果是和国王游戏一样去交换前的 $\max(c_i,c_j)$ 和交换后 $\max(c_i,c_j)$ 去比是不必要的，因为 $c_i$ 递增所以只需要比较交换前的 $c_j$ 与交换后的 $c_i$ 即可。这部分内容别的题解完全讲透了没有什么好讲的，总之我们得出这个式子：

$$\min(a_i,b_j)<=\min(a_j,b_i)$$

这个式子代表的是相邻两项 $i,j=i+1$ 当满足这个不等式的时候不交换一定更优。通常到这里我们就直接sort了，但是它是没有传递性的，这点别的题解也都说到了。

但是我们不能放弃这个式子，因为最后的答案序列一定是满足这个式子的，只不过它不满足传递性导致了不能直接 sort。按照我的神仙老师的说法，就需要“人为地构造一个满足这个不等式的答案序列”。

我没看懂第一篇题解怎么想到直接讨论 $a_i<b_i$ 的，虽然我最后也这么做了但是我的思考过程不一样：

当 $a_i<=b_j$ 时，有 $a_i<=a_j$ 且 $a_i<=b_i$

当 $b_j<=a_i$ 时，有 $b_j<=a_j$ 且 $b_j<=b_i$

观察这两个式子，$a_i$ 和 $b_j$ 的关系比较复杂我们先放弃控制QwQ，注意到上下两个情况包含的三个式子都是“且”的关系，而和 $i,j$ 两项有关的只剩下 $a_i<=a_j$ 与下面的 $b_i>=b_j$ 。还各剩下一个 $a_i<=b_i$ 与 $b_j<=a_j$ ，这告诉我们讨论 $a_i$ 与 $b_i$ 的关系，再决定对其按照 $a$ 升序排序还是 $b$ 降序排序。即使已经分别忽略了两种情况的第一个式子，也必须先按照这样排，这个式子实际上也决定了 $a<b$ 的要放在 $a>b$ 的前面，因为第二种情况中有 $a_j>=b_j$。

再考虑加入第一个式子的影响，一类和一类之间，二类和二类之间因为 $a<=b$ 或者 $a>b$ 的缘故，要么化简成了 $a_i<=a_j$，要么化简成了 $b_j<=b_i$（我觉得第一篇题解是从这里开始讲的qwq）。唯一值得探讨的是一类和二类的分解处，一类的结尾有若干的 $a_i$ 相等的，二类的开头处有若干 $b_i$ 相等的，这些项的顺序是否有讲究。当不等式左边取 $a_i$ 时，因为 $a_j>b_j$ 且 $a_i<b_i$ 所以显然成立，当不等式左边取 $b_j$ 时亦然。综上，我们得出了本题的构造方法：把 $a<=b$ 的项放在 $a>b$ 的项的前面，对前半部分按照 $a_i$ 升序排序，对后半部分按照 $b_i$ 降序排序。

我个人认为这部分的难度完全配得上紫题的数学难度，同时交换相邻两项的套路本就是绿题难度（参照国王游戏），所以个人觉得这题降蓝还是不太合理的qwq（网络流那么多板子题不是蓝就是紫要降也是那些题降啊qwq）

~~希望最后一部分的正确思考方法已经深入人心了qwq~~

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int MAXN=2e4+10;
typedef long long ll;
int T,n;
struct Node{
	ll a,b,t;
	bool operator<(const Node& n2)const{
		if(t!=n2.t)return t<n2.t;
		if(t!=3)return a<n2.a;
		else return b>n2.b;
	}
}node[MAXN];
ll ans,sum;
int main(){
	cin>>T;
	while(T--){
		cin>>n;
		for(int i=1;i<=n;i++){
			cin>>node[i].a>>node[i].b;
			if(node[i].a<node[i].b)node[i].t=1;
			else if(node[i].a==node[i].b)node[i].t=2;
			else node[i].t=3;
		}
		sort(node+1,node+1+n);
		sum=node[1].a;ans=node[1].a+node[1].b;
		for(int i=2;i<=n;i++){
			sum+=node[i].a;
			ans=max(ans,sum)+node[i].b;
		}
		cout<<ans<<endl;
	}
	return 0;
} 
```


---

## 作者：_XHY20180718_ (赞：8)

首先简单说明一下为什么这题使用 $\min(a_i,b_j)<\min(a_j,b_i)$ 的邻项排序法是错误的。

其实，这一排序条件并不满足严格弱序中的不可比性的传递性。

关于严格弱序，可以看[这里](https://ouuan.github.io/post/%E6%B5%85%E8%B0%88%E9%82%BB%E9%A1%B9%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F%E7%9A%84%E5%BA%94%E7%94%A8%E4%BB%A5%E5%8F%8A%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E9%97%AE%E9%A2%98/#%E4%B8%A5%E6%A0%BC%E5%BC%B1%E5%BA%8F)。

也就是说，其不满足：

$\forall x\not<y,x\not>y,y\not<z,y\not>z$，$\exists x\not<z,x\not>z$。

一般来说式子中有不等号的话基本都是：

若 $x=y,y=z$，则 $x=z$。

而在这里，它是：
$$
\forall 
\left\{
\begin{aligned} 
\min(a_i,b_j)=\min(a_j,b_i)\\
\min(a_i,b_k)=\min(a_k,b_i)\\
\end{aligned}
\right.
\exists
\min(a_j,b_k)=\min(a_k,b_j)
$$

将序列中若干个不可比（相等）的相邻元素互换后，可能会出现前面的元素“大于”（在你的重定义之下）后面的元素，从而使得原先的排列方式不是最优的。

## 思路：

我们知道 $\min(a_i,b_j)<\min(a_j,b_i)$ 不具有不可比性的传递性，那么我们直接给他大力加个条件即可。

$$ 
c_i = 
\begin{cases} a_{1}+b_{1}  & ,i=1 \\ 
\displaystyle \max \left \{ c_{i-1},\sum_{j=1}^{i}a_{j} \right \} +b_{i} & ,2\leq i \leq n 
\end{cases}
$$

观察这个式子，发现 $a$ 的前缀和对答案的影响也较大，所以我们可以在 $\min(a_i,b_j)=\min(a_j,b_i)$ 时，比较 $a$ 的大小，$a$ 越大排得越前，$a$ 的前缀和也就越大。

所以，只需要在将原式子改成：

$$
\left\{
\begin{aligned} 
a_i<a_j ,\min(a_i,b_j)=\min(a_j,b_i)\\
\min(a_i,b_j)<\min(a_j,b_i),\min(a_i,b_j)\not=\min(a_j,b_i)\\
\end{aligned}
\right.
$$

随后，我们发现其完全满足严格弱序。

然后我们就打出了正解。

## Code:
```cpp
struct node{
	int a,b,x;
	bool operator<(const node &tty)const
	{return min(a,tty.b)==min(b,tty.a)?a<tty.a:min(a,tty.b)<min(b,tty.a);}
}nds[N];
signed main()
{
	T=read();
	while(T--)
	{
		n=read();
		for(re int i=1; i<=n; i++)
			nds[i].a=read(),nds[i].b=read();
		sort(nds+1,nds+1+n);ans=tmp=0;
		for(re int i=1; i<=n; i++)
			tmp+=nds[i].a,ans=max(ans,tmp)+nds[i].b;
		print(ans);
	}
	return 0;
}
```

参考文献：

[ouuan 博客。](https://ouuan.github.io/post/%E6%B5%85%E8%B0%88%E9%82%BB%E9%A1%B9%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F%E7%9A%84%E5%BA%94%E7%94%A8%E4%BB%A5%E5%8F%8A%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E9%97%AE%E9%A2%98/#%E4%B8%BA%E4%BD%95%E4%BC%9A%E9%94%99)

---

## 作者：ACtheQ (赞：8)

写一篇清晰的题解，方便捋捋笔者的思路。

这很清晰是一道贪心题目。

我们试着用交换法来证明：

- 首先在这题使用交换法对前面的 $C_i$ 没有影响。

- 每次 $C_i$ 至少比 $C_{i-1}$ 大 $B_i$，所以 $C_i \ge C_{i-1}$。

- 可发现单调性，所以使得前面的最小，后面才能尽可能的小。

- 由于交换两个相邻元素更加容易操作，所以使用交换法，并且本题使用交换法是正确的。

这是几个点。

然后开始推式子：

考虑 $i$ 在 $i+1$ 前：

$$C_i=\max(C_{i-1},\sum ^ {i}_{j=1} a_j)+b_i$$

$$C_{i+1}=\max(C_{i},\sum ^ {i+1}_{j=1} a_j)+b_{i+1} = \max(\max(C_{i-1},\sum ^ {i}_{j=1} a_j)+b_i,\sum ^ {i+1}_{j=1} a_j)+b_{i+1}$$

可以把 $b_i,b_{i+1}$ 带进去。

$$C_{i+1}= \max(\max(C_{i-1}+b_i+b_{i+1},\sum ^ {i}_{j=1} a_j+b_i+b_{i+1}),\sum ^ {i+1}_{j=1} a_j+b_{i+1})$$

可以整理出三项的 $\max$。

$$C_{i+1}= \max(C_{i-1}+b_i+b_{i+1},\sum ^ {i}_{j=1} a_j+b_i+b_{i+1},\sum ^ {i+1}_{j=1} a_j+b_{i+1})$$

同理可以得出 $i+1$ 在 $i$ 前的式子。

$$C_{i+1}= \max(C_{i-1}+b_{i+1}+b_i,\sum ^ {i-1}_{j=1} a_j+a_{i+1}+b_{i+1}+b_i,\sum ^ {i+1}_{j=1} a_j+b_{i})$$

由于第一项一样所以不影响比大小的结果，所以消掉。（由于方便式子的表达，接下来的式子并不是 $C_{i+1}$ 的值，而是 $i$ 在 $i+1$ 前与 $i+1$ 在 $i$ 前的大小关系。）

$$C_{i+1}= \max(\sum ^ {i}_{j=1} a_j+b_i+b_{i+1},\sum ^ {i+1}_{j=1} a_j+b_{i+1})$$

$$C_{i+1}= \max(\sum ^ {i-1}_{j=1} a_j+a_{i+1}+b_{i+1}+b_i,\sum ^ {i+1}_{j=1} a_j+b_{i})$$

由于每一项有都带了 $\sum ^ {i-1}_{j=1} a_j$ 所以抵消。

$$C_{i+1}= \max(a_i+b_i+b_{i+1},a_i+a_{i+1}+b_{i+1})$$

$$C_{+1}= \max(a_{i+1}+b_{i+1}+b_i,a_i+a_{i+1}+b_i)$$

由于都是 $a_i,a_{i+1},b_i,b_{i+1}$ 这四项里面选三项，可以简化成：

$$C_{i+1}= \max(-a_{i+1},-b_i)$$

$$C_{i+1}= \max(-a_i,-b_{i+1})$$

可以把符号提出去，记得把 $\max$ 变成 $\min$。

$$C_{i+1}= -\max(-a_{i+1},-b_i)$$

$$C_{i+1}= -\max(-a_i,-b_{i+1})$$
 
$-\min(a_{i+1},b_i) < -\min(a_i,b_{i+1})$ 代表 $i$ 在 $i+1$ 前更优。

同样把符号提走：

$\min(a_{i+1},b_i) > \min(a_i,b_{i+1})$ 代表 $i$ 在 $i+1$ 前更优。

接下来说下传递性的问题。

首先设 $g(x,y)$ 为 $x<y$ 成不成立。

- 如果 $g(x,y)$ 成立，那么 $g(y,x)$ 一定不成立

- $g(x,x)$ 不成立

- 如果 $g(x,y),g(y,z)$ 成立，那么 $g(x,z)$ 一定成立（传递性）

这是排序需要的。

拿 $\min$ 来说，当 $a_i$ 与 $a_{i+1}$ 极小时，得不到 $b$ 数组的关系。

没有传递性排不了序，考虑用拓扑序做。

把 $a$ 和 $b$ 数组混在一起做。

设在前头更优的数，连向后头的数。

先排个序，假如最小的是 $a_i$ 那么它连向后面的人，放在最前头。

假如最小的是 $b_i$ 那么后面的人连向它，放在最后头。

同时把另一个 $a_i$ 或 $b_i$ 扔掉，因为位置已经选好了。

然后按照这个顺序 $O(n) $ 统计遍答案就好了！

---

## 作者：杨戬大师 (赞：8)

恕我直言，完成这道题，大体可以分为两个步骤：

1，找到**正确的贪心策略**，然后根据这个策略写出sort排序的bool函数，注意一定要定义一个**结构体**，再用**sort**排序一遍，这样我们就可以得到一个我们想要的让max最小的序列。

2，排序后贪心就完成了，接下来只需要按照题目所述的要求进行**模拟**。模拟完了，答案就出来了。


先来说说第一步，根据：

c[1]=a[1]+b[1];

c[i]=max(c[i-1],(a[1]+a[2]+...+a[i]))+b[i]。(1<i<=n)

可以看出，前后两个大臣，后面的肯定比前面的得到的钱多，所以题中所谓的“**拿钱最多的大臣”不过是指站在最后的大臣**。这是很简单就能看出来也是很重要的一步。然后，我们开始思考贪心的策略。

我们在做比较简单的贪心题的时候，每一步都是在都贪心，即找到最优方案。每一步贪，最后得到的便是最优的，这道题也一样：根据刚刚我们得到的结论，如果我们在**每一次小小的排序中取最优解**的话，那么排完序得到最后一个大臣的也便是最优解了。所以，我们先从两个大臣排序的情况入手：

c[2]=a[1]+b[2]+max(a[2],b[1])，我们再进行一下恒等变换

c[2]=(a[1]+a[2]+b[1]+b[2])-min(a[2],b[1]),排序一共有两种情况，这是第一种，1在2前面。

c[2]=(a[1]+a[2]+b[1]+b[2])-min(a[1],b[2]),这是第二种情况，2在1前面。

比较两种情况，发现区别就在min里面：如果a[1],a[2],b[1],b[2]四个数的最小值在a[1]或b[2]中，那么第一种情况的c[2]无疑比第二种情况的c[2]要小，排序要将1排在2前面。反之，若在a[2]或b[1]中，那么把2排到1前面就是更好的选择了。看一下这一部分的代码：
```cpp
struct dachen
{
    int l,r;
}zz[20005];
bool master_cmp(dachen a, dachen b)
{
    if (a.l<=a.r&&a.l<=b.l||b.l<=a.l&&b.l<=b.r)
    {//若a.l或b.l中有可以碾压对方两组的
        if (a.l!=b.l)
            return a.l<b.l;
        return a.r>b.r;//若a.l与b.l相等就换一边
    }
    if (a.r!=b.r)//下面的意思同上一个if里的一样
        return a.r>b.r;
    return a.l<b.l;
}

```
刚刚，我们通过贪心完成了此题最难想的一步，接下来，只需要通过模拟推出答案，这便是第二步。这一步的模拟思维难度较刚刚说的贪心低多了，代码也很容易实现。我们只需要一次从1到n的循环，每一出来都求一下那个大臣的钱数，最后出来的最后一个大臣的钱数，就是答案了。

直接上代码：
```
#include <cstdio>
#include <algorithm>

using namespace std;

struct dachen
{
    int l,r;
}zz[20005];
bool master_cmp(dachen a, dachen b)
{
    if (a.l<=a.r&&a.l<=b.l||b.l<=a.l&&b.l<=b.r)
    {
        if (a.l!=b.l)
            return a.l<b.l;
        return a.r>b.r;
    }
    if (a.r!=b.r)
        return a.r>b.r;
    return a.l<b.l;
}
int main()
{
    int t,n,i;
    long long left,ans;//一定要注意long long!
    scanf("%d",&t);
    while (t--)
    {
        left=0;
        ans=0;
        scanf("%d",&n);
        for (i=1;i<=n;i++)
            scanf("%d%d",&zz[i].l,&zz[i].r);
        sort(zz+1,zz+n+1,master_cmp);
        for (i=1;i<=n;i++)
        {
            left+=zz[i].l;//left表示到现在为止前面所有大臣的左手的和
            if (ans<left)//按要求求每个人的钱数
                ans=left+zz[i].r;
            else
                ans+=zz[i].r;
        }
        printf("%lld\n",ans);
    }
    return 0;
}
```
这道题现在看来，就是一个贪心的排序加模拟。难度集中在如何找到好的排序方法，根据贪心找到方法后，题目便变容易了。

---

## 作者：Broken_Army (赞：7)

我认为对该题的贪心策略的思考由两部分组成，第一个部分是推出式子：$\min(a_i,b_j)<=\min(a_j,b_i)$ , 而第二个部分是在发现这个贪心策略是不完整的之后对排序方式做出的调整。

   第二部分大致有两种方法，一种是先按照 $a_i$ 和 $b_i$ 的大小关系分组，确定组间关系后进行排序。另一种是考虑到 $a$ 的前缀和对后续计算有影响，猜测当 $\min(a_i,b_j)=\min(a_j,b_i)$ 时需要按 $a$ 的升序来排列使得其满足严格弱序并足够贪心。

   第一种方法中分组这个想法对于我这种思维能力较弱的人来说是比较难想到的，虽然它非常的巧妙。相比之下，第二种方法是比较容易猜测出来的，但是光有猜测是不够的，正确的贪心策略往往要有严格的证明。所以该题解旨在完成对第二种方法的正确性的证明。也是对[@ouuan](https://www.luogu.com.cn/user/49742)大佬的文章的一个补充，因为他是用自己写的判断器验证的（orz），~~我看不懂~~。至于其他部分，题解区中的大佬们都已经讲的非常详细了，这里不再赘述。

   温馨提示：在阅读该题解时最好先阅读[这篇文章](https://ouuan.github.io/post/%E6%B5%85%E8%B0%88%E9%82%BB%E9%A1%B9%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F%E7%9A%84%E5%BA%94%E7%94%A8%E4%BB%A5%E5%8F%8A%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E9%97%AE%E9%A2%98/)。

   由于[@ouuan](https://www.luogu.com.cn/user/49742)大佬已经对非自反性和非对称性做出证明，所以该题解只做对排序方式：

$P(i,j) = \begin{cases}
\ a_i<a_j & (\min(a_i,b_j)=\min(a_j,b_i))\\
\min(a_i,b_j)<\min(a_j,b_i)&\text{(otherwise)}
\end{cases}$

的传递性和不可比性的传递性的证明的补充。


### 传递性的证明：

命题: $\forall$ $\begin{cases}
\min(a_i,b_j)<\min(a_j,b_i) ,& a_i<a_j\\
\min(a_j,b_k)<\min(a_k,b_j),& a_j<a_k \\
\end{cases}\ \ \ $ 有$\min(a_i,b_k)$ $<$ $\min(a_k,b_i) ,\quad $ $a_i$ $<$ $a_k$

先转化为逻辑表达式方便判断：

$\forall$ $\begin{cases}
\ (a_i<a_j \lor\  b_j<a_j)\ \land\ (a_i<b_i\ \lor\  b_j<b_i) ,& a_i<a_j\ \ (1)\\
\ (a_j<a_k \lor\  b_k<a_k)\ \land\ (b_k<b_j\ \lor\  a_j<b_j) ,& a_j<a_k\ \ (2)
\end{cases}$

有 $(a_i<a_k\ \lor\  b_k<a_k)\ \land\ (a_i<b_i\ \lor\  b_k<b_i),\ \ 
\ a_i<a_k\ \ (3)$

先分析（1）和（2）：

（1）的左半部分必然为 true ，因为已经有 $ a_i<a_j$ 了。
为了减少讨论的复杂程度可以直接分析右半部分。也就是说只要讨论 $(a_i<b_i\ \lor\  b_j<b_i)$ ，不需要考虑 $ b_j<a_j $ 是否为 true ，因为它不会影响分析结果。

有两种情况：
$a_i<a_j$ $\begin{cases}
\ a_i<b_i\  \\
\  b_j<b_i\ 
\end{cases}$
满足（1）。

同理可得
有两种情况：
$a_j<a_k$ $\begin{cases}
\ b_k<b_j\  \\
\  a_j<b_j\ 
\end{cases}$
满足（2）。

通过组合可以得到以下四种情况：

$(a_i<a_j) \ \land\ (a_i<b_i)\ \land\ (a_j<a_k)\ \land\ (b_k<b_j)$  ①

$(a_i<a_j) \ \land\ (a_i<b_i)\ \land\ (a_j<a_k)\ \land\ (a_j<b_j)$  ② 

$(a_i<a_j) \ \land\ (b_j<b_i)\ \land\ (a_j<a_k)\ \land\ (b_k<b_j)$  ③

$(a_i<a_j) \ \land\ (b_j<b_i)\ \land\ (a_j<a_k)\ \land\ (a_j<b_j)$  ④

如果这四种情况都满足：

$(a_i<a_k\ \lor\  b_k<a_k)\ \land\ (a_i<b_i\ \lor\  b_k<b_i),\ \ 
\ a_i<a_k\ \ (3)$ 。

则该排序方式满足传递性。

已知 $a_i<a_j<a_k$ 在四种情况中都成立，所以（3）的左半部分都为 true，因此只需要关心右半部分的结果。

①式和②式中都有现成的 $a_i<b_i$ , 都能使（3）成立。

③式中可以提取出 $b_k<b_j<b_i$ , 可以使（3）成立。

④式中可以提取出 $a_i<a_j<b_j<b_i$ ,可以使（3）成立。

因此传递性得证。

### 不可比性的传递性的证明：

证明逻辑和传递性的逻辑完全一致。

命题: $\forall$ $\begin{cases}
\min(a_i,b_j)=\min(a_j,b_i) ,& a_i=a_j\\
\min(a_j,b_k)=\min(a_k,b_j),& a_j=a_k \\
\end{cases}$

有$\min(a_i,b_k)$ $=$ $\min(a_k,b_i) ,\quad $ $a_i$ $=$ $a_k$


先转化为逻辑表达式方便判断：

$\forall$ $\begin{cases}
\ (a_i=a_j \lor\  b_j=a_j)\ \land\ (a_i=b_i\ \lor\  b_j=b_i) ,& a_i=a_j\ \ (1)\\
\ (a_j=a_k \lor\  b_k=a_k)\ \land\ (b_k=b_j\ \lor\  a_j=b_j) ,& a_j=a_k\ \ (2)
\end{cases}$

有 $(a_i=a_k\ \lor\  b_k=a_k)\ \land\ (a_i=b_i\ \lor\  b_k=b_i),\ \ 
\ a_i=a_k\ \ (3)$

同上述的传递性的证明，也有以下四种情况：

$(a_i=a_j) \ \land\ (a_i=b_i)\ \land\ (a_j=a_k)\ \land\ (b_k=b_j)$  ①

$(a_i=a_j) \ \land\ (a_i=b_i)\ \land\ (a_j=a_k)\ \land\ (a_j=b_j)$  ② 

$(a_i=a_j) \ \land\ (b_j=b_i)\ \land\ (a_j=a_k)\ \land\ (b_k=b_j)$  ③

$(a_i=a_j) \ \land\ (b_j=b_i)\ \land\ (a_j=a_k)\ \land\ (a_j=b_j)$  ④

如果这四种情况都满足：

$(a_i=a_k\ \lor\  b_k=a_k)\ \land\ (a_i=b_i\ \lor\  b_k=b_i),\ \ 
\ a_i=a_k\ \ (3)$ 。

则该排序方式满足不可比性的传递性。

已知 $a_i=a_j=a_k$ 在四种情况中都成立，所以（3）的左半部分都为 true，因此只需要关心右半部分的结果。

①式和②式中都有现成的 $a_i=b_i$ , 都能使（3）成立。

③式中可以提取出 $b_k=b_j=b_i$ , 可以使（3）成立。

④式中可以提取出 $a_i=a_j=b_j=b_i$ ,可以使（3）成立。

因此不可比性的传递性得证。

由此可以得知排序方式：

$P(i,j) = \begin{cases}
\ a_i<a_j & (\min(a_i,b_j)=\min(a_j,b_i))\\
\min(a_i,b_j)<\min(a_j,b_i)&\text{(otherwise)}
\end{cases}$

满足严格弱序，符合贪心策略。

最后贴一下代码：
```cpp
#include<iostream>
#include<algorithm>
#define maxn 20007
using namespace std;
struct node {
    int a, b;
    bool operator<(const node& k) {
        if (min(a, k.b) != (min(b, k.a)))
            return min(a, k.b) < min(b, k.a);
        else
            return a < k.a;
    }
}arr[maxn];
int n, T;
int main(void)
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cin >> T;
    while (T--)
    {
        cin >> n;
        for (int i = 1; i <= n; i++)
            cin >> arr[i].a >> arr[i].b;
        sort(arr + 1, arr + n + 1);
        long long sum = arr[1].a, ans = arr[1].a + arr[1].b;
        for (int i = 2; i <= n; i++)
        {
            sum += arr[i].a;
            ans = max(ans, sum) + arr[i].b;
        }
        cout << ans << '\n';
    }
    return 0;
}

```

希望能够给你带来帮助。如果上述题解有误，欢迎指出。

---

## 作者：老卡手机 (赞：7)

这题说是国王游戏的升级版，但感觉不到哪升级了啊233

~~你甚至连高精度都不要写只要long long就可以了~~

#### 具体做法类似国王游戏，不懂的可以先去翻翻那的题解（[国王游戏题解](https://www.luogu.org/problemnew/solution/P1080)），讲解的很清楚，我就简单提一下

首先我们只要假设出两个人i和j(j=i+1)，不妨设i排在j前面更优，那么第j个人的奖金为(设s表示前缀和，a表示大臣左手数，b为右手数，c表示大臣获得的奖金数。下同）

![](https://cdn.luogu.com.cn/upload/pic/26506.png)


交换i和j的位置，比较两个cj并化简

![](https://cdn.luogu.com.cn/upload/pic/26508.png)

~~连条件都和国王游戏很像~~

于是我们就很愉快的水过了这题
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
typedef long long ll;//用long long防数据过大

using namespace std;
struct people
{
	ll a,b;
}f[20005];
/*如果用重载9、10两个点会re，求神犇解答
bool operator <(const people &a,const people &b)
{
	return min(a.a,b.b)<=min(a.b,b.a);
}
*/
bool cmp(const people& a,const people &b)
{
	return min(a.a,b.b)<min(a.b,b.a);
}//贪心关键
ll s[20005];
int main()
{
	//freopen("in.txt","r",stdin);
	int t;
	cin>>t;
	while(t--)
	{
     //本题由于每次都有更新两个数组所以不用初始化，但还是可以加养成好习惯  
	 //memset(f,0,sizeof(f));
	 //memset(s,0,sizeof(s));
		int n;
		cin>>n;
		for(int i=1;i<=n;i++)
		cin>>f[i].a>>f[i].b;
		
		sort(f+1,f+n+1,cmp);
		
		for(int i=1;i<=n;i++)
		s[i]=s[i-1]+f[i].a;
		ll c=f[1].a+f[1].b;//由于第i个人的钱只和第i-1人的钱有关，所以直接滚动省略c数组（这算是滚动吗233）
		for(int i=2;i<=n;i++)
		{
			c=max(s[i],c)+f[i].b;
		}
		cout<<c<<endl;
	}
	return 0;
}
```
### 题目做了四五十分钟，题解写了一个半小时/捂脸

### ~~为什么洛谷不支持markdown数学公式啊弄图片好麻烦啊~~

---

## 作者：wlj_55 (赞：6)

### 前言
此题的关键就是证明对于两位大臣$i,j$，如果$min(a_i,b_j)\le min(a_j,b_i)$，那么我们将$i$放在前面更优。

由于笔者认为大部分题解对于上述结论的证明都是大同小异或是一带而过，故此处给出上述结论的一种不同的证明方式，后续处理其余题解已经讲得很清楚，故此处不再赘述。
### 正题

[传送门](https://www.luogu.org/problem/P2123)

解析：题目要求的是这样一个式子中$c[i]$的最大值的最小值：
![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4ubHVvZ3UuY29tLmNuL3VwbG9hZC9waWMvMTI1Ny5wbmc?x-oss-process=image/format,png)
由于$a_i,b_i$均为正数，所以$c_i$一定是递增的，故我们要求的即为$c_n$的最小值。

我们有一个结论：对于两位大臣$(a_i,b_i),(a_j,b_j)$，如果$min(a_i,b_j)\le min(a_j,b_i)$，那么我们将$(a_i,b_i)$放在前面更优，证明如下：

$$c_1=a_1+b_1$$
$$c_2=max(c_1,a_1+a_2)+b_1=max(a_1+b_1,a_1+a_2)+b_2$$
$$c_2=max(a_1+b_1+b_2,a_1+a_2+b_2)$$
$$c_3=max(c_2,a_1+a_2+a_3)+b_3$$
$$c_3=max(a_1+b_1+b_2,a_1+a_2+b_2,a_1+a_2+a_3)+b_3$$
$$c_3=max(a_1+b_1+b_2+b_3,a_1+a_2+b_2+b_3,a_1+a_2+a_3+b_3)$$
综上，我们可以发现一个规律：

我们记$S_n(k)$为$\sum_{i=1}^ka_i+\sum_{i=k}^nb_i$

那么$c_i=max(S_i(1),S_i(2),S_i(3),...,S_i(i))$

但这只是我们找出来的规律，下面给出严谨证明：

我们考虑用一个$2*n$的矩阵来表示我们的序列$(a_1,b_1),(a_2,b_2),...,(a_n,b_n)$

以$c_3$为例，我们来画出这些走法，它们分别对应所有的$S_3$：

![](https://cdn.luogu.com.cn/upload/image_hosting/erbaq8nc.png)

所以$c_n$在我们的矩阵里表示从$a_1$到$b_n$的$n$条路径中$n+1$个数字和的最大值。

我们用数学归纳法证明$c_i=max(S_i(1),S_i(2),S_i(3),...,S_i(i))$：

当$n=1$时，$c_1=max(S_1(1))$，显然成立。

假设当$n=k(k\ge1)$时，命题成立，即$c_k=max(S_k(1),S_k(2),S_k(3),...,S_k(k))$

那么当$n=k+1$时，

$$c_{k+1}=max(c_k,a_1+a_2+...+a_{k+1})+b_{k+1}$$
将$b_{k+1}$带入$max$中
$$c_{k+1}=max(c_k+b_{k+1},a_1+a_2+...+a_{k+1}+b_{k+1})$$
合并后面的项
$$c_{k+1}=max(c_k+b_{k+1},S_{k+1}(k+1))$$
将$c_k$拆开
$$c_{k+1}=max(S_k(1)+b_{k+1},S_k(2)+b_{k+1},...,S_k(k)+b_{k+1},S_{k+1}(k+1))$$
按照$S$的定义合并所有项
$$c_{k+1}=max(S_{k+1}(1),S_{k+1}(2),...,S_{k+1}(k+1))$$
原命题得证。

下一步，我们来证明如果$min(a_i,b_j)\le min(a_j,b_i)$，那么我们将$(a_i,b_i)$放在前面更优。

考虑上文提到的矩阵，我们对于一个矩阵
$$
\begin{bmatrix} a_1 & a_2 &a_3 &...&a_n\\\\ b_1 & b_2&b_3&...&b_n \end{bmatrix}
$$
我们如果调换两人的顺序，也就是调换矩阵中两列的顺序。

我们假设调换第$k$列和第$k+1$列，我们得到一个新矩阵

$$
\begin{bmatrix} a_1' & a_2' &a_3' &...&a_n'\\\\ b_1' & b_2'&b_3'&...&b_n' \end{bmatrix}
$$
其中
$$
\begin{bmatrix} a_i \\\\ b_i \end{bmatrix}=\begin{bmatrix} a_i' \\\\ b_i' \end{bmatrix}\quad(1\le i\le n,i≠k,i≠k+1)
$$
$$
\begin{bmatrix} a_k \\\\ b_k \end{bmatrix}=\begin{bmatrix} a_{k+1}' \\\\ b_{k+1}' \end{bmatrix}\quad
$$
$$
\begin{bmatrix} a_{k+1} \\\\ b_{k+1} \end{bmatrix}=\begin{bmatrix} a_{k}' \\\\ b_{k}' \end{bmatrix}\quad
$$
我们记$S_n'(k)$为$\sum_{i=1}^ka_i'+\sum_{i=k}^nb_i',c'_n=max(S_n'(1),S_n'(2),...,S_n'(n))$

我们设$\sigma=S_n(k-1)=S_n'(k-1)=\sum_{i=1}^{k-1}a_i+\sum_{i=k+2}^{n}b_i=\sum_{i=1}^{k-1}a_i'+\sum_{i=k+2}^{n}b_i'$，那么我们有：

$$S_n(k)=\sigma+a_k+b_k+b_{k+1}$$
$$S_n(k+1)=\sigma+a_k+a_{k+1}+b_{k+1}$$
$$S_n'(k)=\sigma+a_k'+b_k'+b_{k+1}'=\sigma+a_{k+1}+b_{k+1}+b_k$$
$$S_n'(k+1)=\sigma+a_k'+a_{k+1}'+b_{k+1}'=\sigma+a_{k+1}+a_k+b_k$$
记$m=min(a_k,a_{k+1},b_k,b_{k+1}),M=max(S_n(k),S_n(k+1),S_n'(k),S_n'(k+1))$

我们分别讨论$m$的取值，

当$m=a_k$时，依照上文推出的$S,S'$的表达式，$M=S_n'(k)$，所以$max(S'_n(k),S_n'(k+1))\ge max(S_n(k),S_n(k+1))$，即$c_n'\ge c_n$

其余三种情况同理。

最后我们得出当$m=a_k$或$b_{k+1}$时，$c_n\le c_n'$，所以不应交换。

当$m=a_{k+1}$或$b_k$时，$c_n\ge c_n'$，此时应交换$k$与$k+1$两列。

证毕。

---

## 作者：Cat_cc (赞：5)

看了各位大佬的题解，发现大多数都是用

#### min(a i ,b j )≤min(a j ,b i)
进行排序的

但是在参考了 一本叫做“信息学奥赛一本通·提高篇”的书 以后，发现了有一个东西叫“流水调度问题”，我们发现，A机器显然在不停的工作是最优的，要让A、B的总时间最短，就是要让B机器的空闲时间最短 而最终时间的求法恰好是题目中的式子（在上一件产品在B机器加工完，并且当前产品在A机器上加工完的时候，把当前产品放到B机器上加工）

怎样让B的空闲时间最小呢？显然，先生产a<b的产品，再生产a>b的产品是可以减少“A机器工作时，B机器没有活干”的情况

我们可以意会一下，我们要尽量地让B机器跟不上A机器的速度，好减少B机器的空闲时间，而且要避免A机器生产一个加工时间很长的产品时，B机器没有“存货”了

所以我们先生产a小b大的零件，多搞一些“存货”，减少B机器的空闲时间，排个序就行了。

但是证明这一块还无法给出绝对的证明，不知道有没有大佬能够在评论里说一下......

ac代码如下：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=20010;
int T,n,cnt1,cnt2,c[N];
struct NODE{
int x,y;
} t[N],s1[N],s2[N];
inline bool cmp1(NODE a,NODE b){
return a.x<b.x;
}
inline bool cmp2(NODE a,NODE b){
return a.y>b.y;
}
undef int
int main()
define int long long
{
cin>>T;
while(T--){
    cin>>n;
    cnt1=cnt2=0;
    for(int i=1;i<=n;++i){
        cin>>&t[i].x>>&t[i].y;
        if(t[i].x<=t[i].y) s1[++cnt1]=t[i];
        else s2[++cnt2]=t[i];
    }
    sort(s1+1,s1+1+cnt1,cmp1);
    sort(s2+1,s2+1+cnt2,cmp2);
    for(int i=1;i<=cnt1;i++)
        t[i]=s1[i];
    for(int i=1;i<=cnt2;i++)
        t[cnt1+i]=s2[i];
    c[1]=t[1].x+t[1].y;
    int sum=t[1].x;
    for(int i=2;i<=n;i++){
        sum+=t[i].x;
        c[i]=max(c[i-1],sum)+t[i].y;
    }
    cout<<c[n]<<endl;
}
return 0;
}
```


---

## 作者：MoonCake2011 (赞：4)

[P1561 ----- 赌神与hack的搏斗](https://www.luogu.com.cn/article/x4hjcvqo)。

这道题是与 P1561 相同的~~大水题~~。

在上面链接的题解中，有讲 Johnson 不等式与 knuth 算法随机化。

先用 Johnson 不等式排序。

用 knuth 算法随机打乱序列去做。

改一下输入与多测，交一发。

[95 pts](https://www.luogu.com.cn/record/116363466)。

这题 Hack 数据显然比上题要大。

LBY 这个蒟蒻尝试了几十次，终于，一个能通过的简单的随机算法来了。

按照 dalao 说的，Johnson 不等式不具有不具有不可比性的传递性。

所以在不同序列上，有不同的答案。

于是我们在每次 knuth 后，直接用 Johnson 排一下序。

~~我不信还不能排出所有序列~~。

于是就过了。

[AC 记录](https://www.luogu.com.cn/record/169653091)。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n;
struct node{
	int a,b;
}a[20010];
inline void knuth(){//knuth算法 
	for(int i=1;i<=n;i++)
		swap(a[1],a[rand()%n+1]);
}
inline int count(){
	int sum=0,ans=0;
	for(int i=1;i<=n;i++){
        sum+=a[i].a;
        ans=max(ans,sum)+a[i].b;
    }
	return ans;
}
bool cmp(node x,node y){
	return (min(x.a,y.b)<min(x.b,y.a)) ? 1 : 0;
}
inline void solve(){
	cin>>n;
	for(int i=1;i<=n;i++)
		cin>>a[i].a>>a[i].b;
	sort(a+1,a+n+1,cmp);
	int cnt=0,ans=2e15;
	while(cnt+2*n<=2e6){//时间足够就继续枚举 
		cnt+=2*n;
		int p=count();
		ans=min(ans,p);
		knuth();
		sort(a+1,a+n+1,cmp);
	}
	cout<<ans<<"\n";
}
signed main() {
    ios::sync_with_stdio(0);
    srand(time(0));
    int t;
    cin>>t;
    while(t--) solve();
    return 0;
}
```

## 细节

首先，这份代码需要你有把控时间的能力。

你需要判断这个时间是否能过。

第二，把打乱时间的 $2 \times 10^6$ 改为 $10^6$ 就过不了，所以你要对随机有把控。

第三，$2\times 10^6$ 需要加入 `inline` 与 `ios` 优化才能过，这种需要足够的卡常。

---

## 作者：Piwry (赞：4)

**这里是对[liuzibujian](https://www.luogu.org/blog/liuzibujian/solution-p2123)和[TA123](https://www.luogu.org/blog/namasikanam/solution-p2123)两位大佬题解的补充**

其他细节可参考上两篇文章，这里主要是证明中对$max$括号内元素的**消去**的正确性**解释**

---
考虑第$J,K$两个元素之间的关系，

不妨设$J<K$;

并设$a_{J},b_{J},a_{K},b_{K}$含义同题意;

再设$Dog_{c},Dog_{a}$分别等价$c_{J-1},\sum_{x=1}^{J-1}$;

若第$I,B$两个元素排列最优,即交换后只会使结果变差,可列出$max(max(Dog_{c},Dog_{a}+a_{J})+b_{J},Dog_{a}+a_{K})+b_{K}\leq max(max(Dog_{c},Dog_{a}+a_{K})+b_{K},Dog_{a}+a_{J})+b_{J}$

即$max(Dog_{c}+b_{J}+b_{K},Dog_{a}+a_{J}+b_{J}+b_{K},Dog_{a}+a_{K}+b_{K})\leq max(Dog_{c}+b_{J}+b_{K},Dog_{a}+a_{K}+b_{J}+b_{K},Dog_{a}+a_{J}+b_{J})$

---
可以发现左右两边$max$中的$Dog_{c}+b_{J}+b_{K}$是共有的，且只要它"**消失**"就可以很快推出一个**只与第**$J,K$**个元素有关**的式子

其实这个消去是**正确**的

下面先将式子简化为(~~设略~~)
①$max(Dog,A)\leq max(Dog,B)$

我们只需要证明它和②$A\leq B$**等价**就行了

首先，我们可以发现在本题中$A$和$B$一个特别**重要**的性质，**即对于最优解总是有**$A\leq B$（对于非最优解，我们将$A,B$调换，其实就是**令**$A\leq B$**必须成立**）

然后再分类讨论

1. 当$Dog\leq A\leq B$时，可推得$A\leq B$，成立，和②等价
1. 当$A<Dog<B$时，可推得$Dog\leq B$，仍成立，和②等价
1. 当$A\leq B\leq Dog$时，可推得$Dog\leq Dog$，同上

于是其正确性就被证明了

---
其实，这份证明的说辞不算严格，因为两个式子并不是**完全等价**，但从**返回值**来说，它们是等价的，~~因此这其实只是一篇伪证明~~

从意义上来看，就是找到和**最优解策略**等价(①)的**程序调换元素的策略**(②)(就像hash的映射一样，只关心映射的**唯一性**)
###### 其他部分可以参考文首的两篇文章

---
#### 附：
对于上两篇题解中d值的作用，个人认为其实就是避免原来的排序方式**不同组别间的**错插，至于d值相同按原式排序就行了
###### 因此有了更~~简介易懂~~的比较实现
```cpp
int get(int x){
	if(a[x]-b[x] == 0) return 0;
	else return (a[x]-b[x])/abs(a[x]-b[x]);
}

int cmp(int x, int y){
	if(get(x) == get(y)) return min(a[x], b[y]) < min(a[y], b[x]);
	else return get(x) < get(y);
}
```
###### ~~请放入sort+数组指针(？)使用~~

## CODE

```cpp
#include <cstdio>
#include <algorithm>
using namespace std;

int read(){
	int x =0; char c =getchar();
	while(c < '0' || c > '9') c =getchar();
	while(c >= '0' && c <= '9') x = (x<<3) + (x<<1) + (48^c), c =getchar();
	return x;
}

int a[20000], b[20000], hash[20000];

int get(int x){
	if(a[x]-b[x] == 0) return 0;
	else return (a[x]-b[x])/abs(a[x]-b[x]);
}

int cmp(int x, int y){
	if(get(x) == get(y)) return min(a[x], b[y]) < min(a[y], b[x]);
	else return get(x) < get(y);
}

int main(){
	int T =read();
	while(T--){
		int n =read();
		for(int i =0; i < n; ++i) a[i] =read(), b[i] =read(), hash[i] =i;
		sort(hash, hash+n, cmp);
		int lastc =0, suma =0;//不开long long一场空
		for(int i =0; i < n; ++i){
			suma +=a[hash[i]];
			lastc = max(lastc, suma)+b[hash[i]];//总是升序 
		}
		printf("%d\n", lastc);
	}
}
```


---

## 作者：lwz2002 (赞：4)

我一开始做这道题也是按照min(ai,bj)<=min(aj,bi)公式排序，而在看题解后我却发现了这个做法竟然不对（QAQ），而楼下的****dalao****的排序方式我看完之后一直不理解为什么这样排序还满足min(ai,bj)<=min(aj,bi)（可能是因为我太菜了），经过我漫长的思索后，终于理解了那样排序的精妙之处

我写这篇题解是给像我这样的蒟蒻一个更容易的理解

建议把我的题解和之前那几位****dalao****的题解结合看，毕竟我没给公式证明

（如果您太强，可以直接忽略掉我这篇题解QAQ）

## 思路

通过相邻交换法可得到

min(ai,bj)<=min(aj,bi)

这个简单而又精妙的公式，既然前面的****dalao****给出了证明，我这里就直接忽略了（逃

我就直接从楼下****dalao****的排序出发了

![](https://cdn.luogu.com.cn/upload/pic/31856.png)
```
struct node
{
    int x,y,d;
    bool operator <(node a) const
    {
        if (d!=a.d) return d<a.d;
        if (d<=0) return x<a.x;
        return y>a.y;
    }
}a[20005];
```
把min(ai,bj)<=min(aj,bi)记为①式;

d表示的是a[i].x与a[i].y的大小，若x>y，则把d赋成1，x==y时d=0，x<y时d=-1

因为排序的第一步是比较d的值，我来解释一下（其实我一开始没看懂QAQ）

可以举个例子：若d不相等，设ai<bi,aj>bj，此时d<a.d

若ai<bj,则ai一定是这四个值中的最小值，所以min(ai,bj)就等于ai,又因为ai为最小值，所以①式成立

若ai>bj,则bj一定是这四个值中的最小值，所以min(ai,bj)就等于bj,又因为bj为最小值，所以①式成立

所以这个排序看似没有按①式排序，实则却巧妙穿插,所以楼下****dalao****太强了%%%



以下是我的代码
```
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>

using namespace std;
struct node
{
	int l;
	int r;
	int xuanxue;   //由于一开始没看懂dalao的代码，所以命名为xuanxueQAQ
}a[20010];
int n,t;
long long c[20010],f[20010];
int cmp(node a,node b)
{
	if(a.xuanxue!=b.xuanxue) return a.xuanxue<b.xuanxue;
	if(a.xuanxue<=0&&b.xuanxue<=0) return a.l<b.l;
	return a.r>b.r;
}
int main()
{
	scanf("%d",&t);
	for(int i=1;i<=t;i++)
	{
//		memset(c,0,sizeof c);
//		memset(f,0,sizeof f);
		int n;
		scanf("%d",&n);
		for(int j=1;j<=n;j++)
		{
			scanf("%d%d",&a[j].l,&a[j].r);
			if(a[j].l-a[j].r<0) a[j].xuanxue=-1;
			else if(a[j].l-a[j].r>0) a[j].xuanxue=1;
			else a[j].xuanxue=0;
		}
		sort(a+1,a+n+1,cmp);
		c[1]=a[1].l+a[1].r;
		f[1]=a[1].l;
		for(int j=2;j<=n;j++)
		{
			f[j]=a[j].l+f[j-1];
			c[j]=max(c[j-1],f[j])+a[j].r;
		}
		printf("%lld\n",c[n]);
	}
	return 0;
}
```

---

## 作者：Syamoe (赞：3)

[原题 Link](https://www.luogu.com.cn/problem/P2123)

感谢那个第一位写出此题正解且没有被 hack 掉的大佬。

----

建议这一道题目和[国王游戏](https://www.luogu.com.cn/problem/P1080)一起看

但是这两道题目在算法上却有一些本质的不同。（这一篇会主要讲讲）

### 整理做法

首先看到**安排顺序**，考虑进行相邻两项的比较，跟国王游戏的套路没啥区别；

再来看一眼题目中给出的表达式：

$$
c_{i}=
\begin{cases} 
a_{1}+b_{1}         ,  & \ i=1 \\
\max \left \{  c_{i-1},\sum_{j=1}^{i}a_{j}  \right \}+b_{i}, & \ 2\leq i \leq n
\end{cases}
$$

这其实就足以证明**越往后钱就约多**，然而皇后却希望奖金最多的大臣得到的钱要尽量少，所以我们要让后面的大臣的奖金尽量少；

### 相邻两项之间的比较

国王游戏这一道题目我们是比较的 

$$\max(b_{i+1},a_i\cdot b_i)<\max(b_i,a_{i+1}\cdot b_{i+1})$$

说简单点也就是比较交换前的 $\max(c_i,c_j)$ 和交换后的  $\max(c_i,c_j)$ 但是这里我们显然是不用这么去比较的，其他题解都讲的很清楚力，由于 $c_i$ 相对于其他的量来说是一只在变化的，所以，我们只需要比较 **交换前的 $c_j$ 和交换后的 $c_i$** 就可以了；

然后其实这一部分比较就是一个一直化简、举例的过程，别的题解讲的很透了，这里不说了，总之我们珂以推出下面的柿子：

$$\max(a_i,b_j) \le \max(a_j,b_i)$$

（注：这里满足的条件是 $j=i+1$）

从这里我们可以得出要来：

若 $\min(a_i,b_j) \le \max(a_j,b_i)$ 那么调换一下 $i$ 和 $j$ 的位置就可；

这个不受这两个大臣前后的大臣的影响。

但是为了证实这个是正确的，我们就需要考虑一个极端的可能性：

由于上面那个柿子和 $a_i$ 与 $b_i$ 的大小有着直接的关系，我们不妨分情况来看一下：

- 若 $a_i \le b_i$，因此，$a_j \le a_i$ 并且 $a_j \le b_j$ 不难看出，这一组要按照 **$a$ 的升序** 排列；

- 若 $a_i>b_i$，则有 $b_j \ge b_i$ 或者 $b_j \ge a_j$ 这一组要按照 **$b$ 的降序** 排列；

所以我们可以得出一个结论：

把 $a \le b$ 的部分尽量放在前面，然后按照 **$a$ 的升序排列**，后面的部分显然就是 $a>b$ 的部分，按照 **$b$ 的降序排列**

于是，可以得出代码：
```cpp
#include <iostream>
#include <algorithm>
#define ll long long
using namespace std;
struct Node {
	ll a, b, t;
	bool operator<(const Node& n2)const {
		if (t != n2.t)
		{
			return t < n2.t;
		}
		if (t != 3) { 
			return a < n2.a; 
		}
		else
		{
			return b > n2.b;
		}
	}
}node[100005];
//这里可以对比国王游戏的代码部分
int main() {
	int T, n;
	cin >> T;
	while (T--)
	{
		cin >> n;
		for (int i = 1; i <= n; i++) {
			cin >> node[i].a >> node[i].b;
			if (node[i].a < node[i].b) {
				//a[i]<b[i]的情况：
				node[i].t = 1;
			}
			else if (node[i].a == node[i].b) {
				//a[i]=b[i]的情况：
				node[i].t = 2;
			}
			else {
				node[i].t = 3;
			}
		}
		sort(node + 1, node + 1 + n);
		ll x, y;
		x = node[1].a, y = node[1].a + node[1].b;//开始第一个人的钱数
		for (int i = 2; i <= n; i++) {
			x += node[i].a;
			y = max(y, x) + node[i].b;
		}
		cout << y << endl;
	}
	return 0;
}
```
代码没啥好说的吧；

总结一下，这道题最难的地方是推柿子还有最后的证明过程，希望相邻两项比较的方法可以深入人心吧。

---

## 作者：ReModer (赞：3)

> $zhx$：  
> 贪心题的核心是排序，排序的标准就去看 $n=2$ 的情况。

按着长者的话，去研究 $n=2$ 时的情况。假设两个人左右手的数分别是 $(a_1,b_1)$，$(a_2,b_2)$，有两种排列方式：

$Case \: 1$: 第一个人在前，第二个人在后，不难列出他们各自的奖金：$res_1 = a_1+b_1$，$res_2 = max(a_1+b_1,a_1+a_2)+b_2$。

$Case \: 2$: 第二个人在前，第一个人在后，同样也可以得到 $res_3 = a_2+b_2$，$res_4 = max(a_2+b_2,a_1+a_2)+b_2$。

两种情况各自的最大值显然是 $res_2$ 和 $res_4$。

不妨设 $res_2 <  res_4$，也就是按 $Case \: 1$ 的方式满足题意。此时可以展开分类讨论：

- 若 $res_2 = a_1+b_1+b_2$，即 $b_1 \geq a_2$：
    - 若 $res_4 = a_2+b_2+b_1$，即 $b_2 \geq a_1$，此时有 $a_1 \lt a_2$。
    - 若 $res_4 = a_1+a_2+b_1$，即 $a_1 \geq b_2$，此时有 $b_2 \lt a_2$。
- 若 $res_2 = a_1+a_2+b_2$，即 $a_2 \geq b_1$：
    - 若 $res_4 = a_2+b_2+b_1$，即 $b_2 \geq a_1$，此时有 $a_1 \lt b_1$。
    - 若 $res_4 = a_1+a_2+b_1$，即 $a_1 \geq b_2$，此时有 $b_2 \lt b_1$。

看着上面的一大坨式子，我对于化简充满了恐惧，于是直接将其搬到了代码中：

```cpp
bool operator < (const Data& cmp) const{
        return ((a < cmp.a && b >= cmp.a && cmp.b >= a) ||
                (cmp.b < cmp.a && b >= cmp.a && a >= cmp.b) ||
                (a < b && cmp.a >= b && cmp.b >= a) ||
                (cmp.b < b && cmp.a >= b && a >= cmp.b));
    }
```

得分 $80pts$，应该是败在了 [讨论区~~毒瘤~~大佬](luogu.org/discuss/show/106039) 的数据下。认真研究了一下，发现以上代码在奖金相等的两个人之间无法做出正确的反应。考虑 $a$ 的前缀和会对答案产生影响，所以要把 $a$ 比较小的那个人扔在前面（详见[大佬的Blog](https://ouuan.github.io/%E6%B5%85%E8%B0%88%E9%82%BB%E9%A1%B9%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F%E7%9A%84%E5%BA%94%E7%94%A8%E4%BB%A5%E5%8F%8A%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E9%97%AE%E9%A2%98/))：

```cpp
bool operator < (const Data& cmp) const{
        if ((a == cmp.a && b >= cmp.a && cmp.b >= a) ||
            (cmp.b == cmp.a && b >= cmp.a && a >= cmp.b) ||
            (a == b && cmp.a >= b && cmp.b >= a) ||
            (cmp.b == b && cmp.a >= b && a >= cmp.b))
                return a < cmp.a;
        return ((a < cmp.a && b >= cmp.a && cmp.b >= a) ||
                (cmp.b < cmp.a && b >= cmp.a && a >= cmp.b) ||
                (a < b && cmp.a >= b && cmp.b >= a) ||
                (cmp.b < b && cmp.a >= b && a >= cmp.b));
}
```

排序后算出答案即可，代码就不贴了。

因此，总结一下这类贪心题的套路：
1. 考虑 $n = 2$ 的情况。
2. 如果懒得化简直接搬到代码里没有问题。
3. 要考虑相等时如何处理两者之间的关系。


---

## 作者：Palace (赞：3)

[走你](https://www.luogu.org/problemnew/show/P2123)

鸣谢：[liuzibujian](https://www.luogu.org/blog/liuzibujian/solution-p2123)

## 思路：

题目已经明说了，类似于国王游戏。先来回忆一下，在国王游戏中，我们除了疯狂的高精度，最重要的是如何排序。在国王游戏中，我们任意挑选相邻的两个人，分别列出两个人一前一后的金币数，然后交换两人的位置，再求金币数。在皇后游戏中，我们也采用这种方法。得到如何排序并排好序之后，直接模拟，最后一个大臣的金币就是所有大臣中最多的。

## 推导：

设有两人x,y（x,y满足y=x+1）。x之前的所有大臣的左手数字之和为s

交换位置之前，y的金币数显然多（因为有单调性）。则

cy=max(cx,s+ax+ay)+by

↓

cy=max( max(cx-1,s+ax)+bx, s+ax+ay)+by

↓

cy=max(cx-1+bx+by,s+ax+bx+by,s+ax+ay+by)

同理，交换位置之后，较大的金币数cx为

cx=max(cx-1+bx+by,s+ay+bx+by,s+ay+ax+bx)

我们设不交换位置的最大金币数最小，即

max(cx-1+bx+by,s+ax+bx+by,s+ax+ay+by) < max(cx-1+bx+by,s+ay+bx+by,s+ay+ax+bx)

经过一通化简（消去不等式两边max内相同位置上相同的数），我们可以得到

max(ax+bx+by,ax+ay+by) < max(ay+bx+by,ay+ax+bx)

提取每个max中逗号两边（说的可能有点通俗）相同的数到括号外并移项，得到

max(bx,ay)-ay-bx < max(by,ax)-ax-by

我们继续化简的话不等号两边会剩下较小值的相反数，即-min(x,y)

则式子继续化简，为min(by,ax) < min(bx,ay)

我们则可以以此排序。

### @liuzibujian 在这里向这位大佬致敬%%% 以上说明的解法并不是完全正确，而我是在他（的题解）的帮助下领会了真正正确的解法。本来我并不打算写这篇题解而只是作为自己做题的记录，但我觉得我有必要传播正确的解法。

这里截取他的一组数据

输入：

```
2
7
6 3
1 1
7 3
1 1
1 6
1 1
6 10

7
6 10
1 1
6 3
1 1
7 3
1 1
1 6
```

输出：

```
26
26
```

两组数据只是顺序不一样，但用上面的算法，结果不同，原因在于这个判断条件不满足传递性。

我们对上面的判断条件可以做出三种讨论：

1.当相邻大臣满足a<b时，是按a的升序排列。

2.当满足a=b时，顺序任意。

3.当满足a>b时，按b降序。

## 代码：

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define re register
#define LL long long
#define N 20020
#define clr(a) memset(a,0,sizeof(a))
#define rep(i,a,b) for(re LL i=a;i<=b;i++)
using namespace std;
struct haha{
	LL l,r,d;
	bool operator < (haha a) const{
		if(d!=a.d) return d<a.d;
		if(d<=0) return l<a.l;
		return r>a.r;
	}
}pri[N];
LL t,n;
LL sum[N],c[N];
int main(){
	scanf("%lld",&t);
	while(t--){
		clr(pri);
		clr(sum);
		clr(c);
		scanf("%lld",&n);
		rep(i,1,n){
			scanf("%lld%lld",&pri[i].l,&pri[i].r);
			if(pri[i].l<pri[i].r) pri[i].d=-1;
			if(pri[i].l>pri[i].r) pri[i].d=1;
			if(pri[i].l==pri[i].r) pri[i].d=0;
		}
		sort(pri+1,pri+1+n);
		rep(i,1,n){
			sum[i]=sum[i-1]+pri[i].l;
			c[i]=max(c[i-1],sum[i-1]+pri[i].l)+pri[i].r;
		}
		printf("%lld\n",c[n]);
	}
	return 0;
}
```

---

## 作者：哔哩哔哩 (赞：3)

### 【思路】
chen_zhe在讨论说，贪心的推导较难。

我不是自己推导出来的排序方法

真的非常抱歉！

但是其他题解有详细的公示推导qwq


关键的排序函数
```cpp

bool cmp(node a, node b)
{
	return min(a.l, b.r) < min(b.l, a.r);
}
```

我这里还是讲一下大体思路。

除了排序，主要的部分就是这张图了：
![](https://cdn.luogu.com.cn/upload/pic/1257.png)

排序+按照图模拟就可以求解。

（一个可以小小的优化是前缀和，就不用每次循环,虽然不加也没事的qwq）


### 【代码】
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=20000+10;
typedef long long ll;//本题要longlong 否则过不去（惨痛的经验）
struct Node{
    ll a,b;
}p[N];//p数组来存放a,b，可以供排序
ll read()//读优
{
	ll s=0,base=1;
	char c;
	while(!isdigit(c=getchar()))if(c=='-')base=-base;
	while(isdigit(c)){s=s*10+(c^48);c=getchar();}
	return s*base;
}
bool cmp(Node poj,Node bzoj)
{
    return min(poj.a,bzoj.b)<min(bzoj.a,poj.b);
}//这个是本题关键 这里不细说
int main()
{
    ll T=read();
    while(T--)
    {
        ll n=read(),c[N];
        for(ll i=1;i<=n;i++) p[i].a=read(),p[i].b=read();//读入
        sort(p+1,p+1+n,cmp);//排序 贪心体现
        ll s=0;c[0]=0;
        for(ll i=1;i<=n;i++)
        {
            s+=p[i].a;
            c[i]=max(c[i-1],s)+p[i].b;//图上式子的实现
        }
        printf("%lld\n",c[n]);//输出
    }
    return 0;
}
```
改了3个多小时的紫题QAQ,关键是推导难啊，~~（我没开longlong辗转了快2个小时）~~，希望对大家有所帮助

---

## 作者：Cocoly1990 (赞：2)

![image.png](https://i.loli.net/2021/05/14/CzMKcVqjLZDbN93.png)

很显然对于上式，要使得每一个$c_i$尽可能小，因为$c_{i-1}$尽可能小，$c_i$也会尽可能小

作如下考虑

$x,x,x,x,j,i,x,x,x,x$

$x,x,x,x,i',j',x,x,x,x$

假设有两个**相邻的**位置$c_i,c_j$，在什么情况下交换$c_i,c_j$能使$c_j$减小

令$sum_i=\sum\limits_{j=1}^i a_j$

那么有

$c_j=max(c_{j-1}+b_j,sum_j+b_j)$

$c_i=max(c_{j},sum_i)+b_i=max(c_{j-1}+b_j+b_i,sum_j+b_j+b_i,sum_i+b_i)$

交换后有

$c_{i'}=max(c_{j-1}+b_i,sum_i-a_j+b_i)$

$c_{j'}=max(c_{j-1}+b_i+b_j,sum_i-a_j+b_i+b_j,sum_i+b_j)$

那么$c_{j'} \ge c_i$这说明$j$在$i$前面

首先，如果$c_i=c_{j-1}+b_j+b_i$，那么$c_{j'} \ge c_i$一定成立（很好理解吧）

所以在比较$c_{j'},c_i$时可以忽略$c_{j-1}+b_j+b_i$

所以只需要比较

$max(sum_i-a_j+b_i+b_j,sum_i+b_j) \ge max(sum_j+b_j+b_i,sum_i+b_i)$

$max(sum_i-a_j,sum_i-b_i) \ge max(sum_j,sum_i-b_j)$

然后再减$sum_i$，注意$sum_j-sum_i=-a_i$

$max(-a_j,-b_i) \ge max(-a_i,-b_j)$

$min(a_j,b_i) \le min(a_i,b_j)$

也就是说，如果上式满足，则有$j$在$i$前面

**但不具备传递性**，也就是假设有$j$在$i$前面且$k$在$j$前面，不一定有$k$在
$i$前面

**分类讨论**

1. $a_i \le b_i$ 则有$a_j \le a_i$且 $a_j \le b_j$ 这一组按$a$升序排列


2. $a_i > b_i$ 则有$b_j \ge b_i$或$b_j \ge a_j$ 这一组按$b$降序排列

如果$\dfrac{a_i-b_i}{abs(a_i-b_i)}\le 0$，分到$1$

如果$\dfrac{a_i-b_i}{abs(a_i-b_i)}> 0$，分到$2$

代码就很好写了，记得``long long``









---

## 作者：水千_弱 (赞：2)

实话实说，这个题真的卡了好久（...当然是因为long long）

至于代码风格，其实我的确有些另类吧（望见谅QAQ）

Johnson算法什么的就看其他大佬们的分析吧

~~数学渣~~弱弱不敢说话



```cpp
#include<iostream>
#include<cstring>
#include<algorithm>
using namespace std;
struct aa
{
	long long ai;
	long long bi;
}q[30000];//其实这就是个过场
struct bb
{
	long long l11;
	long long l12;
}l1[30000];//用来存储左手小的大臣（日后再合并）
struct cc
{
	long long l21;
	long long l22;
}l2[30000];//用来存储右手小的大臣
long long a[30000],b[30000],c[30000];
bool c1(const bb&a,const bb&b)
{
	return a.l11<b.l11;//上升序列
}
bool c2(const cc&a,const cc&b)
{
	return a.l22>b.l22;//下降序列
}
int main()
{
	int ppp;
	cin>>ppp;
	for(int pp=1;pp<=ppp;pp++)
	{
		int n;
		cin>>n;
		memset(a,0,sizeof(a));
		memset(c,0,sizeof(c));
		memset(b,0,sizeof(b));
		memset(q,0,sizeof(q));
		memset(l1,0,sizeof(l1));
		memset(l2,0,sizeof(l2));//由于要多组数据，所以每次都初定义
		long long f=0;
		long long e=0;
		for(int i=1;i<=n;i++)
		{
			cin>>a[i]>>b[i];//输入左右手
		}
		for(int i=1;i<=n;i++)
		{
			q[i].ai=a[i];
			q[i].bi=b[i];
			if(q[i].ai==min(a[i],b[i]))
			{
				l1[++f].l11=q[i].ai;//f用来看一共有多少符合左手小的
				l1[f].l12=q[i].bi;
			}
			else
			{
				l2[++e].l21=q[i].ai;//e用来看一共有多少符合右手小的
				l2[e].l22=q[i].bi;
			}
		}
		sort(l1+1,l1+1+f,c1);
		sort(l2+1,l2+1+e,c2);//按照johnson排序不解释,使得前后的空挡最小
		for(int i=1;i<=e;i++)
		{
			l1[i+f].l11=l2[i].l21;
			l1[i+f].l12=l2[i].l22//整合在一起
		}
		c[1]=l1[1].l11+l1[1].l12;
		long long sum=l1[1].l11;
		for(int i=2;i<=n;i++)
		{
			sum+=l1[i].l11;
			c[i]=max(c[i-1],sum)+l1[i].l12;
		}//朴素模拟而已
		cout<<c[n]<<endl;
	}
	return 0;
} 
```
对于这个代码，其实可以看出有很多啰嗦的地方

相信大家在此基础上能够进行不小的优化

最后膜拜置顶大佬Orz

---

## 作者：dfydada⚡⚡⚡ (赞：2)

这题只要把排序的方式找出来就可以了，

其他的都可以按照题目描述的公式写出。

我只调试了4次就过了。

15分代码：

```cpp
#include<bits/stdc++.h>
//#pragma GCC optimize(2)//O2优化
using namespace std;
typedef long long ll;
const int N=3000+10;
int t,n;
int ans,maxx,c[N];
struct asd
{
	int x,y;
}a[N];
bool bll(asd l,asd r)
{
	return l.x<r.x;
}
int main()
{
	cin>>t;
	while(t--)
	{
		scanf("%d",&n);
		for(int i=1;i<=n;i++)
		{
			scanf("%d%d",&a[i].x,&a[i].y);
		}
		sort(a+1,a+1+n,bll);
//		cout<<endl;
		for(int i=1;i<=n;i++)
		{
//			cout<<a[i].x<<" "<<a[i].y<<endl;
		}
//		cout<<endl;
		for(int i=1;i<=n;i++)
		{
			if(i==1)
			{
				c[i]=a[i].x+a[i].y;
			}
			else
			{
				ans=0;
				for(int j=1;j<=i;j++)
				{
					ans+=a[j].x;
				}
				c[i]=max(c[i-1],ans)+a[i].y;
//				cout<<i<<" = "<<c[i-1]<<" "<<ans<<endl;
			}
		}
//		cout<<endl;
		maxx=0;
		for(int i=1;i<=n;i++)
		{
			maxx=max(maxx,c[i]);
//			cout<<c[i]<<" ";
		}
//		cout<<endl;
		cout<<maxx<<endl;
	}
	return 0;
}
```
这是没按照题目本意写的代码，就随便排了个序。提交之后一堆WA和RE。我表示看题目正的很重要。然后我把数组大小改了改。其实我主要是看看不按题意的排序能得多少分。

然后经过一系列调试，弄出了排序的规律。

20分：

```cpp
#include<bits/stdc++.h>
//#pragma GCC optimize(2)//O2优化
using namespace std;
typedef long long ll;
const int N=200000+10;
int t,n;
int ans,maxx,c[N];
struct asd
{
	int x,y,z;
}a[N];
bool bll(asd l,asd r)
{
	if(l.z!=r.z)
	{
		return l.z<r.z;
	}
	if(l.z<=0)
	{
		return l.x<r.x;
	}
	else
	{
		return l.y>r.y;
	}
}
int main()
{
	cin>>t;
	while(t--)
	{
		scanf("%d",&n);
		for(int i=1;i<=n;i++)
		{
			scanf("%d%d",&a[i].x,&a[i].y);
			a[i].z=a[i].x-a[i].y;
			if(a[i].z>0)
			{
				a[i].z/=abs(a[i].z);
			}
		}
		sort(a+1,a+1+n,bll);
		ans=0;
		for(int i=1;i<=n;i++)
		{
			ans+=a[i].x;
			if(i==1)
			{
				c[i]=a[i].x+a[i].y;
			}
			else
			{
				c[i]=max(c[i-1],ans)+a[i].y;
			}
		}
		maxx=0;
		for(int i=1;i<=n;i++)
		{
			maxx=max(maxx,c[i]);
		}
		cout<<maxx<<endl;
	}
	return 0;
}

```

发现还是有还多WA，毕竟是个省选题，肯定不会那么简单。最后发现int大小的空间不够用（明明定义了long long 却不用）。真是不开long long 见祖宗啊。改完long long 就得了45分。

最后就干脆下了一个测试点。发现是我的排序出了点问题。本来思想是对的，可是打代码的时候打错了。为此还看了下别的大佬的代码进行核对（半天也没看出来）。后来调试了一波，最终搞定。

输入a，b 以结构体来存没毛病吧。
我们在结构体里面在加一个变量，来控制它的排序。

原先的排序：

```cpp
a[i].z=a[i].x-a[i].y;
			if(a[i].z>0)这里有问题
			{
				a[i].z/=abs(a[i].z);
			}
```

经过调试才想起来，0不能被除（小学知识给忘了）。
最后就把 if(a[i].z>0) 改成了 if(a[i].z!=0) 然后就AC。
其余的还是按原来的写。千万不要初始化，会超时。如果对自己代码有什么不满的也可以优化一下。

总代码：

```cpp
#include<bits/stdc++.h>
//#pragma GCC optimize(2)//O2优化
using namespace std;
typedef long long ll;
const int N=200000+10;
ll t,n;
ll ans,maxx,c[N];
struct asd
{
	ll x,y,z;
}a[N];
bool bll(asd l,asd r)
{
	if(l.z!=r.z)
	{
		return l.z<r.z;
	}
	if(l.z<=0)
	{
		return l.x<r.x;
	}
	else
	{
		return l.y>r.y;
	}
}
int main()
{
	cin>>t;
	while(t--)
	{
		scanf("%d",&n);
		for(int i=1;i<=n;i++)
		{
			scanf("%d%d",&a[i].x,&a[i].y);
			a[i].z=a[i].x-a[i].y;
			if(a[i].z!=0)
			{
				a[i].z/=abs(a[i].z);
			}
		}
		sort(a+1,a+1+n,bll);
		ans=0;
		for(int i=1;i<=n;i++)
		{
			ans+=a[i].x;
			if(i==1)
			{
				c[i]=a[i].x+a[i].y;
			}
			else
			{
				c[i]=max(c[i-1],ans)+a[i].y;
			}
		}
		maxx=0;
		for(int i=1;i<=n;i++)
		{
			maxx=max(maxx,c[i]);
		}
		cout<<maxx<<endl;
	}
	return 0;
}

```


---

## 作者：木木！ (赞：1)

蒟蒻的第一道紫题……

当时本蒟蒻在写[P1561](https://www.luogu.org/problemnew/show/P1561)，在得出最优序列之后生成答案的程序是这样子的：

```cpp
int downtime = 0;
int uptime = 0;
for(int i=1; i<=n; ++i)
{
	if(uptime+cows[i].up > downtime)
	{
		downtime = uptime+cows[i].up;
	}
	uptime += cows[i].up;
	downtime += cows[i].down;
}
```

（最优序列存储在数组cows里面）

我这道题实在啃不出（约hack掉了自己5个贪心策略），然后就去看了题解，发现这是一道所谓的“双流水线作业模板题”，Jhonson算法可解

上网搜了一下Jhonson算法，发现叫这个名字的算法有两个，把那个图论算法理解了之后，发现自己死活理解不了这道题的算法，于是对着这个程序段死啃

“在计算某一个点的downtime的时候，需要参考到上一个点的downtime”，我想到，“这个点的downtime是上个点的downtime与从1号到该号的uptime之和的最大值，再加上这个点的downtime”

然后就突然想到了这道题

如果将`ci`与代码段中的`downtime`对应，`ai` `bi`分别和`cow[i].up` `cow[i].down`对应，该题的计算式就是这个程序段

那也就是说，这道题实际上是一道双流水线作业模板题……

Jhonson算法代码自己网上找，找下来几乎原样交就能过，所以不贴代码了

有趣的是，P1561是道黄题……一道黄题和一道紫题双倍经验是什么情况……

附蒟蒻的cmp（虽然要翻译一下）

```cpp
bool cmp(cow a,cow b)
{
	if((a.up<a.down) != (b.up<b.down))
	{
		return a.up<a.down;
	}
	else if(a.up<a.down)
	{
		return a.up<b.up;
	}
	else
	{
		return a.down>b.down;
	}
}
```

---

## 作者：一架飞机 (赞：0)

## 题目大意
有n个大臣，每个大臣能获得的数$c_i$由以下关系给出:

![](https://cdn.luogu.com.cn/upload/pic/1257.png)

求$c_i$的最大值

## 重要思路
此题为贪心，所以我们需要构造一个数列，使答案最优。我们遵循的原则是：**只要所构造的数列满足原始不等式即可。（只要下面能推出上面）**。此题是用**相邻交换法**

## 具体解题步骤

易得：$c_i$是递增的。我们用相邻交换法考虑。设某个位置上的大臣编号为i，后面一位大臣的编号为j。设i前面所有a之和为x，i前面那一位大臣的c值为y。

若不交换，则后面的大臣的c值为：
$max(max(y,x+a_i)+b_i,x+a_i+a_j)+b_j$

化简后得：
$max(y+b_i+b_j,x+a_i+b_i+b_j,x+a_i+a_j+b_j)$

同理，这两位大臣交换后（ j 在 i 前），后面的大臣的c值为：
$max(y+b_i+b_j,x+a_j+b_i+b_j,x+a_i+a_j+b_i)$

假设不交换（ i 在 j 前）更优，则有：
$max(y+b_i+b_j,x+a_i+b_i+b_j,x+a_i+a_j+b_j)≤max(y+b_i+b_j,x+a_j+b_i+b_j,x+a_i+a_j+b_i)$

化简得：
$min(a_i,b_j)≤min(a_j,b_i)$ (这里不是等价的，下面会解释)

- 当$a_i<b_i,a_j<b_j$时，$a_i<a_j$
- 当$a_i>b_i,a_j>b_j$时，随便
- 当$a_i=b_i,a_j=b_j$时，$b_i>b_j$

所以现在的数列为：
- 所有$a_i-b_i<0$的为1组，以 a 的升序排列
- 所有$a_i-b_i=0$的为2组，随便排
- 所有$a_i-b_i>0$的为3组，以 b 的降序排列

组与组之间如何排序呢？

- 当$a_i<b_i,a_j=b_j$时，易得原不等式成立，所以1组在2组前
- 当$a_i=b_i,a_j>b_j$时，易得原不等式成立，所以2组在3组前

所以以1，2，3的顺序排。

## AC代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int M=2e4+5;
struct node{int a,b,seg;long long c;}tr[M];
bool cmp(node x,node y){return x.seg<y.seg;}
bool cmp1(node x,node y){return x.a<y.a;}
bool cmp2(node x,node y){return x.b>y.b;}
int sgn(int x){if(x<0)return -1;if(x==0)return 0;if(x>0)return 1;}
int n,d1,d2;long long sum;
int main(){
	int t;scanf("%d",&t);
	while(t--){
		scanf("%d",&n);
		for(int i=1;i<=n;i++)
			scanf("%d%d",&tr[i].a,&tr[i].b),tr[i].seg=sgn(tr[i].a-tr[i].b);
		sort(tr+1,tr+n+1,cmp);
		d1=n+1,d2=n+1;
		for(int i=1;i<=n;i++)if(tr[i].seg!=-1){d1=i;break;}
		for(int i=d1;i<=n;i++)if(tr[i].seg!=0){d2=i;break;}
		if(d1>1)sort(tr+1,tr+d1,cmp1);
		if(d2<n+1)sort(tr+d2,tr+n+1,cmp2);
		tr[1].c=tr[1].a+tr[1].b;
		sum=tr[1].a;
		for(int i=2;i<=n;i++){
			sum+=tr[i].a;
			tr[i].c=max(tr[i-1].c,sum)+tr[i].b;
		}
		printf("%lld\n",tr[n].c);
	}
	return 0;
}
```


---

## 作者：xiaosongliu (赞：0)

python3没用好， 先做好标记。本来想直接用 sort 函数， 结果参数key 写不出来， 被逼写一个类， 代码增加了不少行（6行），目的是重载“<”符号。
C++结构体实现起来很简洁
python3暂时还没找到解决读入很多数据超时的办法。
本题参考大神的推理（按照相应的判断来进行排序就可得到答案）

C++ AC代码
```cpp
#include <iostream>
#include <algorithm>
using namespace std;
struct node{
    int l, r;
    bool operator<(node t) const{
        return min(l, t.r) < min(r, t.l);//定义结构体，重载“<”符号
    }
};
node s[20001];
int t, n;
int  main()
{
    cin >> t;
    while(t--){
        cin >> n;
        for (int i = 0; i < n; ++i)
            cin >> s[i].l >> s[i].r;
        sort(s, s + n);
        long long q = 0, ans = 0;
        for(int i = 0; i < n; ++i){
            q += s[i].l;
            ans = max(ans, q) + s[i].r;
        }
        cout << ans << endl;
    }
    return 0;
}
```

python3 86分代码

```python
class ele(object):#定义类，重载“<”符号
    def __init__(self, s):
        self.l = int(s[0])
        self.r = int(s[1])

    def __lt__(self, other):
        return min(self.l, other.r) < min(self.r, other.l)


T = int(input())
while T > 0:
    T -= 1
    N, s, ans, p = int(input()), [], 0, 0
    for i in range(N):
        s.append(ele(input().split()))
    s.sort()
    for i in range(N):
        p += s[i].l
        ans = max(ans, p) + s[i].r
    print(ans)
```




---


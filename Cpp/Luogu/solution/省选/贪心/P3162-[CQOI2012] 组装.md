# [CQOI2012] 组装

## 题目描述

数轴上有 $m$ 个生产车间可以生产零件。一共有 $n$ 种零件，编号为 $1\sim n$。第 $i$ 个车间的坐标为 $x_i$ ，生产第 $p_i$ 种零件（$1\le p_i\le n$）。你需要在数轴上的某个位置修建一个组装车间，把这些零件组装起来。为了节约运输成本，你需要最小化 $cost_1+cost_2+\ldots+cost_n$，其中 $cost_x$ 表示生产第 $x$ 种零件的车间中，到组装车间距离的平方的最小值。

## 说明/提示

- 测试点 $1 \sim 4$，满足 $n\le 15$，$m\le 25$，$x_i\le100$；
- 测试点 $5 \sim 10$，满足 $n\le 10^4,m\le 10^5,x_i\le10^5$。

## 样例 #1

### 输入

```
3 5
-1 3
0 1
2 3
4 2
5 2```

### 输出

```
2.0000```

# 题解

## 作者：newbiechd (赞：6)

# [CQOI2012]组装

UPD：感谢 @liyuting_233 ，修正了一个手误。

[LG传送门](https://www.luogu.org/problemnew/show/P3162)

首先有一个必须要能推的式子：设第$i$种零件选的生产车间位置为$x _ i$，组装车间位置为$x$， 则总的花费为

$$f(x) = \sum \limits _{i = 1} ^ n (x - x_i) ^ 2$$

$$= n x^ 2 - 2 \sum \limits _{i = 1} ^ n x _ i x + \sum \limits _{i = 1} ^ n x _ i ^ 2$$

这是一个关于$x$的二次函数， 在$x = \frac {\sum \limits _{i = 1} ^n x_i}{n}$时取得最小值$\sum \limits _{i = 1} ^ n x _ i ^ 2 - \frac {\sum \limits _{i = 1} ^ n x _ i} {n}$。做到这步，我们就可以获得前40分，只需要枚举每种零件选的生产车间，复杂度是指数级的。考虑贪心优化枚举的过程。

下面为了表述方便，设$o = \sum \limits _ {i = 1} ^ n x _ i ^ 2$，$e = \sum \limits _{i = 1} ^ n x _ i$。

首先我们对于同一种零件的生产车间按坐标从小到大排序，每次枚举把某种零件的生产车间替换成他的下一个，这样是有一些情况枚举不到的，但事实上我们只要保证可能的情况都枚举到了就行了，于是贪心.

先给出贪心的结论：设一次替换用一个二元组$\{x _ i, y _ i\}(x_i < y_i)$来表示，如果我们先把表示替换的二元组按照$x _ i + y _ i$从小到大排序，这样就一定不会错过最优解。

下面证明这个结论：用反证法，假设我们这样做会错过最优解，那么一定存在$\{x_1, y_1\}$和$\{x_2, y_2\}$表示的替换使得$x_1$和$y_2$是满足最优解的条件，且替换$\{x_1, y_1\}$比替换$\{x_2, y_2\}$先进行。由于$x_1$是满足最优解的条件，而$y_1$不是，那么必有$\frac {e} {n}$（满足最优解的组装车间）$< \frac {x_1+ y_1} {2}$（二者之间线段的中点），这个结论是显然的（可以自己手玩）。同理有$\frac {e} {n} > \frac {x_2 + y_2} {2}$，由此及上式得$x_1 + y_1 > x_2 + y_2$，但我们已经事先排序保证$x_1 + y_1 < x_2 + y_2$，矛盾。

实现起来就非常简单了，每次替换维护$o$和$e$的变化量，再用$o - \frac {e ^ 2} {n}$和$e / n$更新最小值和答案就行了。

```cpp
#include <cstdio>
#include <cctype>
#include <vector>
#include <algorithm>
#define R register
#define I inline
#define B 1000000
#define D double
#define P pair <int, int>
using namespace std;
const int N = 10003;
char buf[B], *p1, *p2;
I char gc() { return p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, B, stdin),p1 == p2) ? EOF : *p1++; }
I int rd() {
    R int f = 0, b = 1;
    R char c = gc();
    while ((c < 48 || c > 57) && c ^ 45)
        c = gc();
    if (c == 45)
        b = 0, c = gc();
    while (c > 47 && c < 58)
        f = f * 10 +(c ^ 48), c = gc();
    return b ? f : ~f + 1;
}
vector <int> f[N];
vector <pair <int, int> > g;
I D pow(D x) { return x * x; }
I int cmp(P x, P y) { return x.first + x.second < y.first + y.second; }
int main() {
    R int n = rd(), m = rd(), i, j, s, x, y;
    D o = 0, e = 0, del, tmp, ans;
    for (i = 1; i <= m; ++i)
        x = rd(), y = rd(), f[y].push_back(x);
    for (i = 1; i <= n; ++i) {
        s = f[i].size(), sort(&f[i][0], &f[i][0] + s);
        for (j = 1; j < s; ++j)
            g.push_back(make_pair(f[i][j - 1], f[i][j]));
    }
    for (i = 1; i <= n; ++i)
        o += pow(f[i][0]), e += f[i][0];
    tmp = o - pow(e) / n, ans = e / n, s = g.size(), sort(&g[0], &g[0] + s, cmp);
    for (i = 0; i < s; ++i) {
        o += pow(g[i].second) - pow(g[i].first), e += g[i].second - g[i].first;
        if ((del = o - pow(e) / n) < tmp)
            tmp = del, ans = e / n;
    }
    printf("%.4lf", ans);
    return 0;
}

```



---

## 作者：灯芯糕 (赞：4)

### solution:

蒟蒻表示并不会模拟退火，所以用了差分数组加贪心吗。我们先来看题：

1. **在数轴上**的某个位置修建一个组装车间
2. 到组装车间**距离的平方**的最小值。
3. 1<=n<=**20000**


### 心路历程：

1. 在一条直线上
2. 距离的平方？（二次函数？）
3. 1<=n<=10000？（nlogn(logn.....)?）

嗯？乍一看还真不知道怎么做啊！

可是在x轴上？还要距离的平方，好像几个二次函数加一起还是二次函数来着？

莫非？这整体就是一个单峰函数？

好吧，零件种类有多种，但（既然是平方）应该还是要从二次函数出手吧。

既然每种物资只能选一个的话那干脆写一个分段函数吧。|xi|<=200000，他给的又是整形，分界点最多只有400000个，好像可行

### 所以：

贪心：它的范围是-100000～100000，但如果我们将一个零件看成一个二次函数，数轴看成x轴，因为他们都是平方，每个零件所构成的函数都是$y={(x+k)}^2$的形式（ｋ表示零件在数轴上的位置）。

所以对于每一类零件，建立一个坐标轴，将零件画成二次函数的形式，这样对于每一个ｘ值，我们贪心的选ｙ值最小的那个零件。这样就能构成一个分段函数，而我们将每一种类的零件所构成的分段函数放在一起（用差分数组维护$y=ax^2+bx+c$ 中的b与c），几个二次函数加一起还是二次函数，虽然分的段特别多，但绝对在我们的承受范围内，然后我们用二次函数求最小值的公式把最小值求出来即可（最小值可以在段外！！！）

零件位置给的是整形，分段的点的小数部分绝对为0或0.5,我们在差分数组前先处理一下（乘个二，加上200001，避免负数）（当然！你也可以用莫对思想维护！（比如鸽王发的那篇题解））

### code：


```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#define ll long long
#define db double
#define rg register int
using namespace std;
struct su{
	int x,y;
}t[200005];

int n,m,l,r;
ll s[800015];
ll v,k[800015];//请不要吝啬您的long long和double
db a,b,c,res=(ll)1<<50,ans,tot;//res初值赋大些

inline bool cmp(su x,su y){
	return x.y==y.y?x.x<y.x:x.y<y.y;
}

int main(){
	//freopen("battle.in","r",stdin);
	//freopen("battle.out","w",stdout);
	cin>>n>>m;a=n;
	for(rg i=1;i<=m;++i)
		cin>>t[i].x>>t[i].y;
	sort(t+1,t+m+1,cmp);
	for(rg i=1;i<=m;++i){
		if(t[i].y!=t[i-1].y)l=1;
		else l=t[i].x+t[i-1].x+400001;
		if(t[i].y!=t[i+1].y)r=800002;
		else r=t[i].x+t[i+1].x+400001;
		v=-2*t[i].x;s[l]+=v;s[r]-=v;
		v>>=1;v=v*v;k[l]+=v;k[r]-=v;
	}
	for(rg i=1;i<=800001;++i){
		b=b+s[i];c=c+k[i];tot=c-(b*b)/(4*a);
		if(tot<res)res=tot,ans=-b/(2*a);
	}printf("%.4lf",ans);
	return 0;
}

```

---

## 作者：谁是鸽王 (赞：2)

## 【题解】[[CQOI2012\]组装](https://www.luogu.org/problemnew/show/P3162)

考虑化为代数的形式，序列$\left[a_i \right]$表示选取的$i$种类仓库的坐标。

$ans=\Sigma(a_i-x)^2,(*)$，展开:

$ans=nx^2-2\Sigma a_ix+\Sigma a_i^2(**)$

(\*\)是二次函数看到没？初中填空题第一题。最小值的对称轴$\frac{\Sigma a_i}{n}$。

至于选取$a_i$，根据(\*\)贪心选取$a_i$即可,（意思就是选近的）。

考虑用莫队的形式维护$\Sigma a_i$和$\Sigma a_i^2$，把复杂度降到$O(n)$

我们假设仓库在所有点的左侧，我们先把所有颜色最靠左的点选中。

然后仓库慢慢右移

考虑枚举变化点，需要选取的$a_i$变化，当且仅当我们假定的仓库的位置越过了相邻的相同种类的中点(根据(\*\)式)，把变化的信息记录下来像莫队一样的加入待处理的队列，每次改变直接根据二次函数的性质查询最小值和对称轴就好了。

至于有时候对称轴可能不在我们假定的仓库位置，没关系，我们的目的是取到最小值，只关心(\**\)式的系数，不关心实际位置。

看不懂解释就看代码就好了，但是那两个式子一定要理解。


复杂度是上限是$sort$导致的，最后的时间复杂度是$O(nlogn)$。

考场代码(没开$long$ $long$见了三十分祖宗)

```cpp
#include<bits/stdc++.h>

#define RP(t,a,b) for(register int (t)=(a),edd_=(b);t<=edd_;++t)
#define DRP(t,a,b) for(register int (t)=(a),edd_=(b);t>=edd_;--t)
#define ERP(t,a) for(int t=head[a];t;t=e[t].nx)
#define Max(a,b) ((a)<(b)?(b):(a))
#define Min(a,b) ((a)<(b)?(a):(b))
#define pushup(x) seg[(x)]=seg[(x)<<1]+seg[(x)<<1|1]
#define midd register int mid=(l+r)>>1
#define chek if(R<l||r<L)return
#define TMP template<class ccf>
#define rgt L,R,mid,r,pos<<1|1
#define lef L,R,l,mid,pos<<1
#define all 1,n,1

using namespace std;typedef long long ll;
TMP inline ccf qr(ccf k){
    char c=getchar();
    ccf x=0;
    int q=1;
    while(c<48||c>57)q=c==45?-1:q,c=getchar();
    while(c>=48&&c<=57)x=x*10+c-48,c=getchar();
    return q==-1?-x:x;
}
const int maxn=2e4+15;
ll ai2,ai;
vector < int > p[maxn];
struct node{
    int id,pos;
    inline bool operator < (node x)const{
	return pos<x.pos;
    }
}data[200005];

struct chd{
    double pos;
    int col,last,to;
    inline bool operator < (chd x)const{
	return pos<x.pos;
    }
}C[200005];
int ccnt;
int cnt;
double n;
int m;
int t1,t2;

inline void mk(int col,int last,int to,double pos){
    ccnt++;
    C[ccnt].col=col;C[ccnt].last=last;C[ccnt].to=to;C[ccnt].pos=pos;
}

//就是此处见祖宗 注意upd参数的类型！
inline void upd(int last,int to){
    ai-=last;ai2-=last*last;
    ai+=to;  ai2+=to*to;
}

inline double f(double x){
    return (double)n*x*x-(double)2*ai*x+(double)ai2;
}


double ans,anspos;
int main(){
#ifndef ONLINE_JUDGE
    freopen("battle.in","r",stdin);
    freopen("battle.out","w",stdout);
#endif
    cnt=qr(1);m=qr(1);
    n=cnt;
    RP(t,1,m){
	t1=qr(1);
	t2=qr(1);
	data[t].pos=t1;
	data[t].id=t2;
    }
    sort(data+1,data+m+1);
    
    RP(t,1,m){
	p[data[t].id].push_back(data[t].pos);
    }
    
    RP(t,1,cnt){
	RP(i,1,p[t].size()-1){
	    mk(t,p[t][i-1],p[t][i],(p[t][i-1]+p[t][i])/2.0);
	}
    }
    
    sort(C+1,C+ccnt+1);
    
    RP(t,1,cnt){
	ai+=p[t][0];
	ai2+=p[t][0]*p[t][0];
    }

    ans=f(ai/n);
    anspos=ai/n;
    
    RP(t,1,ccnt){
	upd(C[t].last,C[t].to);
	register double psj=ai/n,yyb=f(ai/n);
	//if(psj>C[t].pos)
	//puts("PSJAKIOI");
	//puts("yybAKIOI");
	if(yyb<ans||(yyb==ans&&psj<anspos)){
	    anspos=psj;
	    ans=yyb;
	}
    }
    
    printf("%.4lf\n",anspos);
    return 0;
}
/*
  
  考虑化为代数的形式

  ans=\Sigma(a_i-x)^2

  ans=nx^2-2\Sigma a_ix+\Sigma a_i^2

  二次函数看到没？

  考虑用莫队的形式维护\Sigma a_i和\Sigma a_i^2

  考虑枚举断点，显然选取的a_i是会变化的，预处理相同颜色的中点即可。
  
*/

```


---

## 作者：bztMinamoto (赞：2)

[传送门](https://www.luogu.org/problemnew/show/P3162)

~~退火大法好~~

我并不会正解于是只好打退火了……其他没啥好讲……只要对每一种颜色开一个vector，存一下所有这个颜色的位置，判定的时候可以去所有的颜色里二分找到前缀和后缀，把和当前点距离小的加入答案

然后就没有然后了……
```
//minamoto
#include<bits/stdc++.h>
#define IT vector<int>::iterator
#define R register
#define double long double
#define RD T*(rand()*2-RAND_MAX)
#define fp(i,a,b) for(R int i=a,I=b+1;i<I;++i)
#define fd(i,a,b) for(R int i=a,I=b-1;i>I;--i)
#define go(u) for(R int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)
using namespace std;
char buf[1<<21],*p1=buf,*p2=buf;
inline char getc(){return p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++;}
int read(){
    R int res,f=1;R char ch;
    while((ch=getc())>'9'||ch<'0')(ch=='-')&&(f=-1);
    for(res=ch-'0';(ch=getc())>='0'&&ch<='9';res=res*10+ch-'0');
    return res*f;
}
const int N=1e4+5;const double D=0.97,eps=1e-14;
vector<int>pos[N];double ans=1e10,pp,pr,T,res,best,pq,hp;int n,m,x,c,mn=1e5+5,mx=-1e5+5;
IT it;
double calc(R double x){
    double r=0,p;
    fp(i,1,n){
        p=1e12;
        it=lower_bound(pos[i].begin(),pos[i].end(),x);
        if(it!=pos[i].end())p=min(p,(*it)-x);
        if(it!=pos[i].begin())p=min(p,x-*(it-1));
        r+=p*p;
    }return r;
}
int main(){
	srand(time(0));
//	freopen("testdata.in","r",stdin);
    n=read(),m=read();fp(i,1,m)x=read(),c=read(),pos[c].push_back(x),mn=min(mn,x),mx=max(mx,x);
    pr=(1.0*mn+mx)/2,best=calc(pr);
    while(clock()<CLOCKS_PER_SEC*0.5){
        hp=pp=pr,ans=best;
        for(T=100000;T>eps;T*=D){
            pq=pp+RD,res=calc(pq);
            if(best>res)best=res,pr=pq;
            if(ans>res||exp((ans-res)/T)>(double)rand()/RAND_MAX)
            ans=res,pp=pq;
        }if(pr==hp)break;
    }printf("%.4Lf\n",pr);
}
```

---

## 作者：ifffer_2137 (赞：1)

upt on 2024/12/10：感谢评论区老哥给的 hack，把所有颜色都只有一个位置的情况改好了。
### 题意
求一个形如 $\sum_{S}\min_{i\in S}(x-k_i)^2 $ 的函数的最小值点。
### 分析
容易发现从数轴上扫过去时，对于一种颜色考虑 $(x-k_i)^2$ 取到 $\min$ 时的 $k_i$ 的变化次数是 $O(|S|)$ 的，变化的点就是 $k_i$ sorted 以后相邻两值的平均数，证明显然。

所以把这些变化的点全部拿出来总量是 $O(n)$ 的，于是就可以排序扫一遍的同时把原式里的 $\min$ 给拿掉，变成一车抛物线的求和，显然也是一个抛物线，所以直接动态维护总和得到的抛物线三项各自的系数，修改一条也是容易的。然后变成二次函数区间内最值点，初中数学课内内容，不多赘述。

时间复杂度 $O(n\log n)$，瓶颈是排序。
### 代码

```cpp
//From: ifffer_2137
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define inf 4e18
#define eb emplace_back
#define pii pair<int,int>
#define pdi pair<double,int>
#define mkpr make_pair
#define fir first
#define sec second
#define double long double
inline int read(){
	char ch=getchar();int x=0,w=1;
	while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
	while(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+ch-48,ch=getchar();return w==1?x:-x;
}
const int maxn=1e5+5;
int n,m;
double A,B,C;
double mn,ans;
vector<int> p[maxn];
vector<pdi> t;
int ch[maxn];
double mnpos(double a,double b,double c,double l,double r){
	double k=(-b)/a*0.5;
	if(k<l) return l;
	if(k>r) return r;
	return k;
}
double calc(double a,double b,double c,double x){return a*x*x+b*x+c;}
signed main(){
	#ifndef ONLINE_JUDGE
	freopen("data.in","r",stdin);
	freopen("test.out","w",stdout);
	#endif
	cin.tie(0),cout.tie(0);
	n=read(),m=read();
	for(int i=1;i<=m;i++){
		int x=read(),k=read();
		p[k].eb(x);
	}
	for(int i=1;i<=n;i++){
		if(p[i].empty()) continue;
		ch[i]=0,A+=1,B-=p[i][0]*2,C+=p[i][0]*p[i][0];
		for(int j=1;j<p[i].size();j++) t.eb((p[i][j-1]+p[i][j])*0.5,i);
	}
	sort(t.begin(),t.end());mn=inf;
	double x=mnpos(A,B,C,-inf,(t.size()?t[0].fir:inf));
	if(calc(A,B,C,x)<mn){
		mn=calc(A,B,C,x);
		ans=x;
	}
	for(int i=0;i<(int)t.size()-1;i++){
		int x=t[i].sec,k=(++ch[x]);
		A--,B+=p[x][k-1]*2,C-=p[x][k-1]*p[x][k-1];
		A++,B-=p[x][k]*2,C+=p[x][k]*p[x][k];
		double X=mnpos(A,B,C,t[i].fir,t[i+1].fir);
		if(calc(A,B,C,X)<mn){
			mn=calc(A,B,C,X);
			ans=X;
		}
	}
	if(t.size()){
		A=B=C=0;
		for(int i=1;i<=n;i++){
			if(p[i].empty()) continue;
			A+=1,B-=p[i][p[i].size()-1]*2,C+=p[i][p[i].size()-1]*p[i][p[i].size()-1];
		}
		x=mnpos(A,B,C,t[t.size()-1].fir,inf);
		if(calc(A,B,C,x)<mn){
			mn=calc(A,B,C,x);
			ans=x;
		}
	}
	printf("%.4Lf\n",ans);
	return 0;
}
```

---

## 作者：LiuIR (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P3162)

先考虑已确定每种零件的生产车间的情况。

记组装车间为 $x$，第 $i$ 种零件选择的车间为 $p_i$，那么有

$$
\begin{aligned}
ans&=\sum_{i=1}^n(x-p_i)^2\\
&=nx^2-\left(2\sum_{i=1}^np_i\right)x+\sum_{i=1}^np_i^2
\end{aligned}
$$

因为 $n>0$，开口向上，所以当 $x=\frac{\sum_{i=1}^np_i}{n}$ 时取到最小。

现在只需求出一个最优的 $p$。

先令 $p$ 为所有零件最小的车间，考虑逐步更换数组 $p$。定义 $(i,a,b)(a<b)$ 表示将 $p_i$ 从 $a$ 改为 $b$，通过邻项交换法来决定更换顺序。

假设先执行 $(i,a,b)$ 后执行 $(j,a^\prime,b^\prime)$ 没有取到最优解，说明：

+ 因为 $a$ 在最优解中二 $b$ 不在，说明最优的 $x<\frac{a+b}2$。否则保持 $x$ 不变，将 $a$ 换成 $b$ 会使答案更小。

+ 同理，得到最优的 $x>\frac{a^\prime,b^\prime}2$。

综上，有 $a+b>a^\prime+b^\prime$。所以只要按 $a+b$ 从小到大执行上述更换，就不会出现上述情况。

初步考虑认为这样的 $(i,a,b)$ 对可能有 $n^2$ 种。但实际上对于同一个 $a$，只有最小的 $b$ 才会参与更换，所以只有 $n$ 对。

具体来讲，只需要对同一个零件相邻的生产车间对考虑即可。

时间复杂度 $O(n\log n)$。瓶颈在排序。

实现上可以实时维护 $\sum p_i,\sum p_i^2$ 更新答案。

代码如下：

``` c++
struct Node{
    int id, old, now;
}tmp[N];

int n, m, tot, pos[N];
ll sum, sqrsum;
ld ans, anspos;
vector<int> vec[N];

signed main()
{
    SetIO();
    cin >> n >> m;
    for (int i = 1, x, p; i <= m; i++)
        cin >> x >> p, vec[p].eb(x);
    for (int i = 1; i <= n; i++)
    {
        pos[i] = vec[i][0];
        for (int j = 1; j < vec[i].size(); j++)
            tmp[++tot] = Node{i, vec[i][j - 1], vec[i][j]};
    }
    sort(tmp + 1, tmp + tot + 1, [](Node x, Node y){return x.old + x.now < y.old + y.now;});
    for (int i = 1; i <= n; i++)
    {
        sum += pos[i];
        sqrsum += 1ll * pos[i] * pos[i];
    }
    ans = sqrsum - (ld)sum * sum / n, anspos = (ld)sum / n;
    for (int i = 1; i <= tot; i++)
    {
        sum -= pos[tmp[i].id];
        sqrsum -= 1ll * pos[tmp[i].id] * pos[tmp[i].id];
        pos[tmp[i].id] = tmp[i].now;
        sum += pos[tmp[i].id];
        sqrsum += 1ll * pos[tmp[i].id] * pos[tmp[i].id];
        ld res = sqrsum - (ld)sum * sum / n;
        if (Cmp(res, ans) < 0)
        {
            ans = res;
            anspos = (ld)sum / n;
        }
    }
    cout << fixed << setprecision(4) << anspos;
    return 0;
}
```

---

## 作者：int08 (赞：0)

## 前言
本题解差点成为我为数不多没有前言的题解。
# Solution
（下文中 $n,m$ 定义与题目相反）

假如说每种零件只有一个车间加工，这道题就太简单了：假设选中的位置为 $p$，答案显然是 $\sum \limits^{n}_{i=1}(p-x_i)^2$，这显然是一个关于 $p$ 的二次函数（多个二次函数相加仍然是至多二次函数）而且开口向上，可以用顶点公式（$x=\frac{-b}{2a}$）迅速求出最小值。

问题是每种零件有很多个车间加工，意味着不同的位置会有不同的函数，怎么办呢？

但是，注意到只有跨过“某一对相邻的加工同一种零件的车间”的中点的时候，这个零件的贡献会从一个二次函数变成另一个二次函数，这样的变化总共只有 $O(n)$ 次，换句话说，**这是一个分 $O(n)$ 段，每段都是二次函数的分段函数**。

那我们分别计算每个分段的最小值就好了，注意顶点不一定在区间中，此时取到最小值的位置是区间的某个端点。

把变化位置存进 `vector`，从前往后扫描即可，注意变化点由于是中点，坐标不一定是整数，考虑所有坐标乘 $2$ 以解决。

## AC Code

```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 600805
int n,m,x[N],p[N],i,j;
double a,b,c,ans=1e17,anp;
double f(double x)
{
	return x*x*a+x*b+c;
}
vector<int> col[N],pl[N],mi[N];
int main()
{
	cin>>m>>n>>x[0]>>p[1];col[p[1]].push_back(0);
	for(i=2;i<=n;i++) cin>>x[i]>>p[i],x[i]=(x[i]-x[0])*2,col[p[i]].push_back(x[i]);
	for(i=1;i<=m;i++)
	{
		pl[0].push_back(col[i][0]);
		for(j=0;j<col[i].size()-1;j++)
		{
			int mid=(col[i][j]+col[i][j+1])/2;
			mi[mid].push_back(col[i][j]),pl[mid].push_back(col[i][j+1]);
		}
	}
	double l=0;
	for(i=0;i<=x[n];i++)
	{
		if(i&&(pl[i].size()||mi[i].size())||i==x[n])
		{
			double r=i;
			double mid=(-b/2.0/a);
			if(mid<l)
			{
				if(ans>f(l)) ans=f(l),anp=l;
			}
			else if(mid>r) 
			{
				if(ans>f(r)) ans=f(r),anp=r;
			}
			else
			{
				if(ans>f(mid)) ans=f(mid),anp=mid;
			}
		}
		for(auto x:pl[i])
			a+=1.0,b-=2*x,c+=1ll*x*x;
		for(auto x:mi[i])
			a-=1.0,b+=2*x,c-=1ll*x*x;
	}
	printf("%.4f",anp/2.0+double(x[0]));
}
```
# The End.

---

## 作者：Starrykiller (赞：0)

考虑每种零件唯一的时候怎么办。

注意到，我们要求的是

$$f(x)=\sum_{i=1}^n (x-x_i)^2$$

的最小值。将其展开，得到

$$f(x)=nx^2-2x\sum_{i=1}^n x_i+\sum x_i^2$$

不难发现当 $x=\bar{x_i}$ 时 取到最小值。

这个是不难 $\Theta(n)$ 解决的。但问题是，现在能生产每种零件的车间不止一个，该如何选择？

考虑用 $\texttt{std::priority\_queue}$ 维护每个车间，每次删掉最左边的车间，然后维护函数最值。时间复杂度 $\Theta(m\log m)$。

但是很不幸，这样是错误的。事实上，设某类车间相邻两个车间位置为 $x,x'$，我们按照 $(x+x')$ 排序才是正确的。


考虑相邻的两个车间，当（不含这类车间时的）平均数在中点左侧时，左边的车间贡献更优；否则右边的车间贡献更优。

代码非常好写就不放了。

---


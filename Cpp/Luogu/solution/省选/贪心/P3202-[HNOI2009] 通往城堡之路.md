# [HNOI2009] 通往城堡之路

## 题目描述

听说公主被关押在城堡里，彭大侠下定决心：不管一路上有多少坎坷，不管城堡中的看守有多少厉害，不管救了公主之后公主会不会再被抓走，不管公主是否漂亮、是否会钟情于自己，他将义无反顾地朝着城堡前进。

可是，通往城堡的路上出现了一些情况。抽象地说，假象地图在二维平面的第一象限。在每个横轴的x位置上有一个高为hx的支撑点，如果彭大侠没有跳到支撑点上，那么他就会掉下去，牺牲在路途。

开始时彭大侠在起点（1，h1）处，而城堡的入口在（n，hn）处。彭大侠每次可以从支撑点（x，hx）跳到支撑点（x+1，hx+1）。但是彭大侠每次的跳跃能量只有d，也就是说，每次跳跃必须满足条件|hx+1-hn|<=d。换句话说，如果两个相邻支撑点的纵向落差大于d，那么彭大侠就无法跳跃了！幸运的是，彭大侠还有一个杀手锏。
在起点处，他可以花一个金币，把某个支撑点升高1个单位，或者降低1个单位。但是，起点处和城堡入口处的支撑点高度不能改变，并且一旦离开起点彭大侠就无法使用该杀手锏。

彭大侠被告知100个金币可兑换一单位生命。于是他希望通过少花金币来保存更多单位的生命。

他终于找到了你这位热心的高手，请你帮他规划一下以便耗费尽量少的金币来到达城堡。


## 说明/提示

对样例中的第一个输入数据块，d=2，把第三个支撑点降低3个单位，把第六个支撑点降低1个单位，把第七个支撑点升高2个单位，原序列变成：4 5 7 6 6 8 6 7 9 8，这时任意相邻支撑点的纵向落差没有超过2，彭大侠可以到达城堡！

对样例中的第二个输入数据块，d=1，这时不管怎样调节第二个支撑点的高度，都无法使任意相邻支撑点的纵向落差不超过1。

对样例中的第三个输入数据块，d=2，这时，把第二个支撑点升高1个单位，把第三个支撑点降低3个单位就满足条件了。

【数据规模】

     20%     n<=100

     40%     n<=1000

100%    n<=5000


## 样例 #1

### 输入

```
3
10 2
4 5 10 6 6 9 4 7 9 8
3 1
6 4 0
4 2
3 0 6 3```

### 输出

```
6
impossible
4```

# 题解

## 作者：MloVtry (赞：11)

【膜拜解决此题的远古神犇】

首先，我们构造出一组【可行解】，也就是以a[i]为初始高度，后面每一级都下降d个高度（此时不考虑a[n]不变的条件）

我们可以肯定，最终答案一定是在这个【（伪）解】基础上，让一些区间升高得到的

那么我们现在就要升高一些区间

（当前【可行解】用b数组来表示）

假定我们让一个区间升高h，并且满足b[i]+h<=a[i]，那么，假定这段区间有s1个点，b[i]<a[i]，s2个点，b[i]>=a[i]，则ans-=(s1\*h);ans+=(s2\*h)

也就是说，此时让这段区间升高h，答案会更优

那么我们每次寻找一段区间，使其加上这个h

当然，前提是满足这个区间的b[i]+h<=a[i]，也就是h=min（a[i]-b[i]）

【当然还有奇奇怪怪的小边界咯，这里并不会说，自己推一推吧！】

我们可以发现，b[n]这个点，一定是需要升高的，并且升高到a[n]之后就不能再升高

那么我们寻找一个后缀区间，则至少会增高b[n]这个节点

假设通过上述操作，现在b[n]已经等于a[n]，这个解法就是最优的


1.任何一段区间再增高，不会使答案更优

首先设该区间为[i,j]，既然该区间能够升高，那么则必有s1\*h>s2\*h--->s1>s2

假定[j+1,n]增加过，那么在枚举后缀时，是不会遗漏的，所以此时[i,j]不增高是不可能的

假定[j+1,n]没有增加过，那么，b[j]与b[j+1]的差值必定为d，一旦增加b[j]，则解必定不合法

2.任何一段区间再降低，不会使答案更优

设区间为[i,j]

假定[i,j]增高过，那么降低就相当于增高的反操作，也就是撤销增高---既然撤销更优，那么我们根本就不会增加它

假定[i,j]没有增高过，那么他们就必定不能降低---因为初始的b[i~j]已经是可行解的最低高度了

由此得证

代码
        
        
```cpp
#define ll long long
#define inf 1LL<<50
#include<iostream>
#include<cstdio>
#include<cmath>
#define N 5010
using namespace std;
int n,T;
ll d;
ll a[N],b[N];
ll ans;
int main()
{
    scanf("%d",&T);
    while(T--)
    {
        scanf("%d%lld",&n,&d); 
        ans=0;
        for(int i=1;i<=n;++i) scanf("%lld",&a[i]);
        b[1]=a[1];
        for(int i=2;i<=n;++i) b[i]=b[i-1]-d;
        if(abs(a[n]-a[1])>(ll)d*(n-1))
        {puts("impossible");continue;}
        while(b[n]!=a[n])
        {
            ll tm=-inf,at,add,val=inf,s=0;
            for(int i=n;i>1;--i)
            {
                if(b[i]<a[i]) s++,val=min(val,a[i]-b[i]);
                else s--;
                if(s>tm&&b[i]!=b[i-1]+d) tm=s,at=i,add=val;
            }
            add=min(add,b[at-1]+d-b[at]);
            for(int i=at;i<=n;++i) b[i]+=add;
        }
        for(int i=1;i<=n;++i) ans+=abs(a[i]-b[i]);
        printf("%lld\n",ans);
    }
    return 0;
}
```

---

## 作者：wuzhoupei (赞：9)

太难了；

首先，它标了个Tarjan的标签；

然后，应该是有人用什么仙人掌+DP做的吧；

然而还是用的贪心；

根本不会；


****

就是把所有的==都先设为最差值==；

然后一点点的往上调；

然后就是贪心；

> 定义 ：  
low : 从n到现在i b[i]<=a[i] 的个数；  

up : 从n到现在i b[i]>a[i] 的个数；


我们找一个 ==low-up 最大的后缀==；

先上调；

调的距离是 min ( a[i]-b[i] ) |a[i]>b[i];

因为这样我们 up 增加的值可以用 low 增加的值来==抵消==；

而且会有一部分 low 的值会使 ans 减小；

所以最优；

但是上调距离==有边界==， 即前一个 b[i-1]+d < b[i];

所以 b[i] 上调的最大距离要和 b[i-1]+d-b[i] 取 min；


****

```cpp
    #include "iostream"
    #include "stdio.h"
    #include "algorithm"
    #define II int
    #define LO long long
    #define R register
    #define I 123456
    using namespace std;
    
    
    II t,n;
    
    LO d;
    
    LO a[I], b[I];
    
    LO gg(R LO x) { return x<0 ? -x : x ; }
    
    LO smaler(R LO a,R LO b) { return a<b ? a : b ; }
    
    
    int main()
    {
        scanf("%d",&t);
        while (t--) {
            scanf("%d%lld",&n,&d);
            for(R II i=1;i<=n;i++) scanf("%lld",&a[i]);
            
            if(gg(a[n]-a[1])>d*(n-1)) {
                printf("impossible\n");
                continue ;
            }
            
            b[1]=a[1];
            for(R II i=2;i<=n;i++) b[i]=b[i-1]-d; 
            
            while (b[n]!=a[n]) {
                R LO low=0,up=0,wei,oo=-1e18,op=1e18, ko=0;
                for(R II i=n;i>1;i--)
                {
                    a[i]>b[i] ? low++ : up++ ;     
                    if(a[i]>b[i]) {
                        op=smaler(op,a[i]-b[i]);
                    } 
                    if(low-up>=oo && b[i-1]+d!=b[i]) {
                        oo=low-up;
                        wei=i;
                        ko=op;
                    }
                }
                
                ko=smaler(ko,b[wei-1]+d-b[wei]);
                for(R II i=wei;i<=n;i++) b[i]+=ko;
            }
            
            R LO ans=0;
            for(R II i=1;i<=n;i++) ans+=gg(a[i]-b[i]);
            printf("%lld\n",ans); 
        }
        exit(0);
    }
```

****

---

## 作者：IcyFoxer_XZY (赞：2)

**[题目传送门](https://www.luogu.com.cn/problem/P3202)**

### ~~好久没写题解了，来个紫题练练手......~~

这题虽然标签是动态规划，奈何萌新苦苦钻研，还是不会，用了一个贪心的思路。

具体来讲和 **[这篇题解](https://www.luogu.com.cn/blog/user36716/solution-p3202)** 差不多，说明会更加详细。

### 分析：

我们先考虑一下最坏的情况，令数组 $b[1]=a[1]$ 。由于题目的目的是使 $b[n]=a[n]$ ，就可以把后缀逐步提高，毕竟这样可以考虑到是否提高每个点。

接下来设 $s$ 为当前后缀的 $a[i]>b[i]$ ，那么只要 $s \ge 0$ ，这种后缀就一定优了。那么这样不断提高至多提高 $n-1$ 次，时间复杂度为 $O(n^2)$ 。

因为每次我们加的都是最小值，结果必然最小，方法自然是没问题的啦~~

**Code：**
```cpp
#include<bits/stdc++.h>
#define int long long//注意long long 
#define re register int
using namespace std;
const int N=1e6+1;
int t,n,d,ans,a[N],b[N];
signed main(){//long long main是不存在的，因此用signed main 
	scanf("%lld",&t);//数据组数 
	while(t--){
		scanf("%lld%lld",&n,&d);//输入n、d 
		ans=0;
		for(re i=1;i<=n;++i)scanf("%lld",&a[i]);//输入支撑点高度 
		if(abs(a[1]-a[n])>(n-1)*d){//无法到达城堡的情况 
			puts("impossible");
			goto bre;//直接跳过 
		}
		b[1]=a[1];//赋初值 
		for(re i=2;i<=n;++i)b[i]=b[i-1]-d;
		while(b[n]!=a[n]){
			int maxx=-N*100,minn=N*100,s=0,x=N*100,j;
			for(re i=n;i>=2;--i){
				if(a[i]>b[i]){
					s++;
					minn=min(minn,a[i]-b[i]);//贪心 
				}else s--;
				if(s>maxx&&b[i]<b[i-1]+d){
					maxx=s;
					j=i;
					x=minn;
				}
			}
			x=min(x,b[j-1]+d-b[j]);//贪心 
			for(re i=j;i<=n;++i)b[i]+=x;
		}
		for(re i=1;i<=n;++i)ans+=abs(a[i]-b[i]);//答案累加 
		printf("%lld\n",ans);//输出 
		bre:;//goto出口 
	}
	return 0;
}
```
Bye!

---

## 作者：耶梦加得 (赞：1)

~~首先那个 100 金币一条命的条件是题目背景，本身并没有什么用~~

首先，我们容易判断 impossible 的情况，亦即当 $|h_1 - h_n| > (n - 1) * d$ 的时候，无论如何都不可能到达终点。
（另外为了表述方便，此后将 $h_i$ 重命名为 $a_i$）

题目要求最优解，粗看似乎并没有什么好的思路。我们考虑先给出一个解，再看看该如何加以调整。

由于我们给出的这个解必须有普适性，亦即对于 $|a_1 - a_n| = (n - 1) * d$ 这种极端情况也能套用我们的结论，所以我们给出的构造也是极端的：

$b_1 = a_1$ 并且 $b_i = b_{i-1} - d (1 < i \le n)$

（在这里我们先假设我们可以改变终点的高度）

容易发现 $b_n \le a_n$ ，我们需要通过若干次调整使得 $b_n = a_n$

由于需要保证可行性，我们显然不会再下调任何柱子的高度（在之后的操作中也不会，因为“反悔”是无意义的。另外，我们可以将操作转换为区间操作方便计算贡献。

将区间 $[i,j]$ 升高高度 $h$ 后，可能会有一些位置上会出现 $b_i < a_i$ 但是 $b_i + h > a_i$ 的情况，难以计算贡献。

~~只要我们把 $h$ 设置成 $a_i - b_i$ 的最小正值就没有这种问题~~

去除掉这种妨碍计算的情况后，如果有 $s1$ 个位置满足 $b_i < a_i$ ， $s2$ 个位置不满足，那么花费的金币数会减少 $s1 * h$ ，增多 $s2 * h$ 。

也就是说，我们操作的区间 $s1 - s2$ 越大越好（并且 $s1 <= s2$ 时操作没有意义）。

当然，为了保证可行性，我们还要判断 $b_{i - 1} + d$ 和 $b_i$ 的大小关系。

由于我们的目标是增大 $b_n$ ，我们应该可以通过每次选择一个**后缀**进行操作来满足条件。下面证明所有策略都等价于若干次对后缀的区间增高。

如果我们在区间 $[i,j]$ ($1 < i \leq j < n$) 增加了 $h$ 个单位， 由于必须满足 $b_j$ 与 $b_{j+1}$ 差值不超过 $d$ ，因此 $b_{j + 1}$ 必然已经在之前的某一次操作中增加了高度 $h$ ，假设这一次操作的区间为 $[j + 1, k]$ ……

我们发现，$[i, n]$ 的所有元素必定都增加了 $h$ ！

每次操作后 $b_n$ 的高度一定会增加。容易在 $O(n)$ 时间内完成该操作。

另外，我们注意到，假设这次操作的 $h = a_i - b_i$ ，那么新的 $b'_i = b_i + h = b_i + a_i - b_i = a_i \geq a_i$ 

也就是说每次操作都会导致满足 $b_i < a_i$ 的数至少 -1且没有途径增加（$b_i$单调增而$a_i$为定值），而操作又依赖于这种元素。这导致我们的操作次数不会超过 $n$ 次。

操作完了以后，由上文中的结论，我们可以保证增加任何区间 $[i,j]$ 不会使得答案更优。

（码风略怪，见谅）：
```
#include<algorithm>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<queue>
#include<vector>
#define miu 5007
using namespace std;
template<class T>inline T mmin(register T x, register T y) {
    return x > y ? y : x;
}
long long a[miu], b[miu];
int T;
int n;
long long d;
signed main() {
    scanf("%d", &T);
    while(T--) {
        long long ans = 0ll;
        scanf("%d %lld", &n, &d);
        for(int i = 1; i <= n; ++i) scanf("%lld", a + i);
        b[1] = a[1];
        for(int i = 2; i <= n; ++i) b[i] = b[i - 1] - d;
        if(labs(a[1] - a[n]) > 1ll * d * (n - 1)) {puts("impossible"); continue;}
        while(b[n] != a[n]) {
            int ds = 0, as = -0x3f3f3f3f, ap = n;
            long long av = 0x3f3f3f3f3f3f3f3f, val = 0x3f3f3f3f3f3f3f3f;
            for(int i = n; i > 1; --i) {
                if(b[i] < a[i]) {++ds; val = mmin(val, a[i] - b[i]);}
                else --ds;
                if(b[i] != b[i - 1] + d && ds > as) {
                    as = ds; ap = i; av = val;
                }
            }
            av = mmin(av, b[ap - 1] + d - b[ap]);
            for(int i = ap; i <= n; ++i)b[i] += av;
        }
        for(int i = 1; i <= n; ++i) ans = (ans + labs(a[i] - b[i]));
        printf("%lld\n", ans);
    }
    return 0;
}

```





---


# [SCOI2016] 美味

## 题目描述


一家餐厅有 $n$ 道菜，编号 $1, 2, \ldots, n$，大家对第 $i$ 道菜的评价值为 $a_i$。有 $m$ 位顾客，第 $i$ 位顾客的期望值为 $b_i$，而他的偏好值为 $x_i$。因此，第 $i$ 位顾客认为第 $j$ 道菜的美味度为 $b_i\oplus (a_j + x_i)$，$\oplus$ 表示异或运算。

第 $i$ 位顾客希望从这些菜中挑出他认为最美味的菜，即美味值最大的菜，但由于价格等因素，他只能从第 $l_i$ 道到第 $r_i$ 道中选择。请你帮助他们找出最美味的菜。

## 说明/提示

对于 $100\%$ 的数据，满足 $1 \le n \le 2 \times 10^5$，$0 \le a_i,b_i,x_i < 10^5$，$1 \le l_i \le r_i \le n$（$1 \le i \le m$），$1 \le m \le 10^5$。

## 样例 #1

### 输入

```
4 4
1 2 3 4
1 4 1 4
2 3 2 3
3 2 3 3
4 1 2 4```

### 输出

```
9 
7 
6 
7```

# 题解

## 作者：XY_cpp (赞：44)

这题调了一个上午不知哪里错了，~~可能我写代码像c*k~~

>十年生死两茫茫，BUG何处藏，唯有泪千行

于是乎,随便打了个暴力碰运气,吸一口氧气,还不够,再吸一口臭氧

```cpp
// luogu-judger-enable-o2
#pragma GCC optimize("O3")
#include<bits/stdc++.h>
using namespace std;
const int N=2e5+1;
int a[N],b[N],x[N],l[N],r[N];
int main()
{
    int n,m;
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;++i)
        scanf("%d",&a[i]);
    for(int i=1;i<=m;++i)
        scanf("%d%d%d%d",&b[i],&x[i],&l[i],&r[i]);
    for(int i=1;i<=m;++i)
    {
        int res=0;
        for(int j=l[i];j<=r[i];++j)
        {
            int now=b[i]^(a[j]+x[i]);
            res=max(res,now);
        }
        printf("%d\n",res);
    }
    return 0;
}
```
然后我发现我愉快的[$AC$](https://www.luogu.org/record/22048101)了

正所谓

>n方过百万,暴力碾标算


~~不过如果你像我一样，是个求知若渴，勤奋好学的好孩子，请看下面的正解~~

-------



**我来口胡一下正解**

睡了一个中午醒来看了一眼题面,发现$a[i]$可以是$0$,于是恍然大悟~~大雾~~,把左边端点改成$0$,宝宝就愉快的$AC$了

题目要求$b_i\  xor\ (a_j+x_i)$ 显然不能硬求,看到异或,考虑按照位处理

假设从高到低处理到第$i$位(从右往左数,个位是第$0$位),

设之前求出的$a[i]$的答案为$ans$(如果你不太明白这个变量的意思,请看下面的例子,前提是你要知道基本的$xor$性质)

---
当前处理到第$2$位
$$ \ \ \ \ b:1010**\ *$$
$$ans:0101** \ *$$
所以当前$ans$记录的是一个满足题目限制的$a[j]+x_i$,使得$b$ $xor$ $a[j]+x_i$的$3-7$位达到最大值,我们之所以要从高到低枚举,就是因为要贪心的求,先让高位满足最大值.

这时,聪明的你就要发问了:万一没有一个$a[j]+x_i$能使某一位达到最大值,那怎么办呢?

答:没有办法,$b$ $xor$ $a[j]+x_i$之后的这一位只能为$0$

---

经过一番分析之后,我们得出核心思路:

若第 $b$的第$i$位是$1$,那么我们希望它是长这样的
       
$$\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ b:---1**\ *$$
$$(min)a[j]+x:---0\ 0\ 0\ 0$$
$$(max)a[j]+x:---0\ 1\ 1\ 1$$

容易求出$a[i] \in [ans-x,ans-x+(1<<i)-1]$


同理当$b$的第$i$位是$0$时

$a[i] \in [ans-x+(1<<i),ans-x+(1<<i+1)-1]$

我们可以直接主席树上查询对于第$i$个人的$[l_i,r_i]$内有无$a[i]$满足上述条件

- 当$b$的第$i$位是$1$时，若有这样一个$a[i]$，$ans+=0<<i$，反之$ans+=1<<i$
- 当$b$的第$i$位是$0$时，若有这样一个$a[i]$，$ans+=1<<i$，反之$ans+=0<<i$

---

关于主席树部分，因为有区间内查询的约束，所以我们首先想到的是主席树

首先按照套路把$l-1$，$r$提出来，$sum$相减后得出这段区间内的数值个数，然后按照一般套路分成两半往下找就可以了

~~如果你连主席树部分都不能理解，建议先把模版切熟练~~
	

---


上代码，很短，~~暴力更短~~
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=5e5+5;
int a[N],rt,t[N<<5],ch[N<<5][2],sum[N<<5];
void update(int pre,int &k,int l,int r,int x)
{ 
    if(r<x||l>x) return ;
    k=++rt,ch[k][0]=ch[pre][0],ch[k][1]=ch[pre][1],sum[k]=sum[pre]+1;
    if(l==r) return;
    int mid=(l+r)>>1;
    update(ch[pre][0],ch[k][0],l,mid,x);
    update(ch[pre][1],ch[k][1],mid+1,r,x);
}
int query(int u,int v,int l,int r,int x,int y)
{
    int num=sum[v]-sum[u],mid=(l+r)>>1;
    if(y<l||x>r||num==0) return 0;
    if(x<=l&&r<=y) return num;
    return query(ch[u][0],ch[v][0],l,mid,x,y)+query(ch[u][1],ch[v][1],mid+1,r,x,y);
}
int main()
{
    int n,m,q;
    scanf("%d%d",&n,&q);
    for(int i=1;i<=n;i++)
        scanf("%d",&a[i]),m=max(a[i],m);
    for(int i=1;i<=n;i++)
        update(t[i-1],t[i],0,m,a[i]);
    while(q--)
    {
        int b,x,l,r,ans=0;
        scanf("%d%d%d%d",&b,&x,&l,&r);
        for(int i=18;i>=0;i--)
        {
            if(b&(1<<i)&&!query(t[l-1],t[r],0,m,ans-x,ans-x+(1<<i)-1)) ans+=(1<<i);//之前就是这写错了
            if(!(b&(1<<i))&&query(t[l-1],t[r],0,m,ans-x+(1<<i),ans-x+(1<<(i+1))-1)) ans+=(1<<i);
        }      
        printf("%d\n",ans^b);
    }
    return 0;
}
```







---

## 作者：I_AM_HelloWord (赞：40)

蒟蒻第一次写首发题解,心中是无比的激动啊(๑╹◡╹)ﾉ"""

好吧，说说这道题怎么搞吧。

最大异或和dalao们应该都会搞吧？

凡是异或的题目大多都要用Trie来搞，对于这道题，我们需要借鉴一下最大异或和的解题思想（（废话，俩个题简直是一模一样））

同样是按照数位一位一位的贪心，因为加了一个x，所以我们考虑对于所有的ai+x与b的按位异或。

假设我们已经处理到b的第i位（转换成二进制），假设是1（0同理），

那么我们只需要查找是否存在aj+x使得其二进制第i位数字是0，显然我们已经处理了前i-1位了，设当前结果是ans，那么我们需要查找的数的大小就是在区间[ans-x,ans+(1<<i)-1-x]，手算一下就知道这个区间里的数字的第i位加了x后就都是0，

那么现在我们就是要在a[1]...a[n]中找出是否存在于[ans-x,ans+(1<<i)-1-x]的数字，两个区间范围限制，用主席树模板一套就好了。

[主席树基础传送门。](http://blog.csdn.net/no1\_terminator/article/details/77601599)


参考代码：

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
const int N=5e5+5;
const int M=N*20;
int a[N],root[N];
int n,m,totn=0,T_cnt=1;
struct President_Tree{
    int L,R,sum;
}T[M];
int read(){
    int x=0,f=1;char ch=getchar();
    while (ch<'0' || ch>'9'){if (ch=='-')f=-1;ch=getchar();}
    while ('0'<=ch && ch<='9'){x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}
    return x*f;
}
void insert(int &now,int index,int l=0,int r=totn){
    T[T_cnt++]=T[now];now=T_cnt-1;
    T[now].sum++;
    if (l==r)return;
    int mid=(l+r)>>1;
    if (index<=mid)insert(T[now].L,index,l,mid);
        else insert(T[now].R,index,mid+1,r);
}
int query(int i,int j,int ql,int qr,int l=0,int r=totn){
    if (ql<=l && r<=qr)return T[j].sum-T[i].sum;
    int mid=(l+r)>>1,tt=0;
    if (ql<=mid)tt+=query(T[i].L,T[j].L,ql,qr,l,mid);
    if (mid<qr)tt+=query(T[i].R,T[j].R,ql,qr,mid+1,r);
    return tt;
}
bool find(int i,int j,int ql,int qr){
    ql=max(0,ql);qr=min(qr,totn);
    if (ql>qr)return 0;
    return query(root[i],root[j],ql,qr);
}
int main(){
    n=read(),m=read();
    for (int i=1;i<=n;i++)
        totn=max(totn,a[i]=read());
    root[0]=0;
    for (int i=1;i<=n;i++){
        root[i]=root[i-1];
        insert(root[i],a[i]);
    }
    for (int i=1;i<=m;i++){
        int b=read(),x=read(),ql=read(),qr=read(),ans=0;
        for (int i=17;i>=0;i--){
            int now=ans+((1^((b>>i)&1))<<i);
            if (find(ql-1,qr,now-x,now+(1<<i)-1-x))ans=now;
            else ans+=((b>>i)&1)<<i;
        }
        printf("%d\n",ans^b);
    }
    return 0;
}
```

---

## 作者：__gcd (赞：30)

伪 $\text{01trie}$ 树+主席树。

称之为伪 $\text{01trie}$ 树是因为它没有建树过程，但是原理却和 $\text{01trie}$ 树及其相像。

## $01$ 字典树的另一种理解方式
实际上，$01$ 字典树求异或最大值的本质是找到一个最合适的数，使它与所求数在二进制位上的高位尽量相反。

同样，$01$ 字典树上的每一个结点都可以看作一个值域。假设一个结点 $u$ 在 $01$ 字典树上从根到它的前缀所对应的二进制数值为 $sum$，它的对应位数为 $i$，那么它的值域为 $[sum,sum+2^i-1]$，左儿子值域为 $[sum,sum+2^{i-1}-1]$，右儿子值域为 $[sum+2^{i-1},sum+2^i-1]$。

关于查询一个结点是否存在，只需要查询在它的值域内是否有被插入过的数即可。

## 在本题的应用

如果使用一般的 $01$ 字典树，稍加思考可以发现，随着偏好值 $x_i$ 的改变，字典树的形态也会发生改变。而如上的理解把字典树的“结点”，改成了“值域”，方便了我们操作。

假设我们要查询原字典树上值域 $[l,r]$ 有没有被插入过的数。因为所有的数都被加上了 $x_i$，所以只要在当前字典树上查询区间 $[l-x_i,r-x_i]$ 就可以了。

区间求值存在问题，可以使用可持久化权值线段树。

详见代码。

## 代码

```cpp
#include<bits/stdc++.h>
#define ll long long
#define db double
using namespace std;
inline int read() {
	int x = 0; bool op = false;
	char c = getchar();
	while(!isdigit(c))op |= (c == '-'), c = getchar();
	while(isdigit(c))x = (x << 1) + (x << 3) + (c ^ 48), c = getchar();
	return op ? -x : x;
}
const int N = 200010;
const int T = 1e5;
int n, m, tot;
int rt[N]; 
struct Node {
	int ls, rs; int val;
}tree[N * 20];
int update(int cur, int l, int r, int pos, int val) {
	int p = ++tot;
	tree[p] = tree[cur];
	if(l == r) {
		tree[p].val += val;
		return p;
	}
	int mid = l + r >> 1;
	if(pos <= mid)tree[p].ls = update(tree[cur].ls, l, mid, pos, val);
	else tree[p].rs = update(tree[cur].rs, mid + 1, r, pos, val);
	tree[p].val = tree[tree[p].ls].val + tree[tree[p].rs].val;
	return p;
}
int query(int p, int q, int l, int r, int qx, int qy) {
	if(l >= qx && r <= qy)return tree[p].val - tree[q].val;
	int mid = l + r >> 1, ans = 0;
	if(qx <= mid)ans += query(tree[p].ls, tree[q].ls, l, mid, qx, qy);
	if(qy > mid)ans += query(tree[p].rs, tree[q].rs, mid + 1, r, qx, qy);
	return ans;
}
int main() {
	n = read(); m = read();
	rt[0] = 1; tot = 1;
	for(int i = 1; i <= n; i++) {
		int x = read();
		rt[i] = update(rt[i - 1], 0, T, x, 1);
	}
	for(int i = 1; i <= m; i++) {
		int b = read(), x = read(), l = read(), r = read();
		int ans = 0; //ans记录前缀（即上面提到的sum） 
		for(int j = 18; j >= 0; j--) {
			int flg = 1;
			if((b >> j & 1) == 1) { //模拟trie树操作 
				int lef = ans, rig = ans + (1 << j) - 1;//查找左儿子，即在这一位上为0 
				if(rig - x < 0 || lef - x > T)flg = 0;
				else if(query(rt[r], rt[l - 1], 0, T, max(lef - x, 0), min(T, rig - x)) == 0)flg = 0;
				//查询值域内有没有数，即左二子是否存在 
				ans += (flg ^ 1) * (1 << j); //如果左儿子存在，则走左儿子；否则走右儿子，下面同理 
			}
			else {
				int lef = ans + (1 << j), rig = ans + (1 << (j + 1)) - 1;
				if(rig - x < 0 || lef - x > T)flg = 0;
				else if(query(rt[r], rt[l - 1], 0, T, max(lef - x, 0), min(T, rig - x)) == 0)flg = 0;
				ans += flg * (1 << j); //如果右儿子存在，走右儿子，否则走左二子 
			}
		}
		printf("%d\n", ans ^ b);//trie数到达底端，ans为异或b最大的数 
	}
	return 0;
}

```


---

## 作者：3493441984zz (赞：21)

# 主席树

感觉其他关于主席树题解不是很好懂？那我来一发


------------
# 思路：

首先，我们看到要选区间的数，并且结合题意就知道用主席树啦~~(看题目标签也阔以QAQ)~~

然后我们看到要求最大异或和，因为异或中，二进制每一位都是独立的，所以我们考虑按位处理

而题目是给定两个数$b,x$，要求$(a[i]+x)\oplus b$，那么既然$b,x$给定了，我们只需要维护一下$a[i]$就行了

于是，我们开一颗主席树，以$a[i]$为下标，里面存的值表示出现次数

- 那么我们考虑下面的情况：

首先，我们根据贪心思路，我们从高到低一位一位来看，显然如果可以让当前这一位为$1$，那么肯定会更优（不管对后面的影响）

那么我们分两类讨论（$ans$记录的是$a[i]+x$,主席树如上文所述）：

- 假设现在我们处理到了第$i$位，如果此时$b$这一位为$0$，那么我们为了最终$ans\oplus b$更大，$ans$最好在这一位为$1$，那么$ans$的范围多少呢？

其实就是$[ans+(1<<i),ans+(1<<(i+1))-1]$

为什么呢？

举个例子，假设枚举到了第$4$位，最右边为最低位，此时的$ans$为$1010000$,因为只枚举到了第四位，所以第五位之后都是$0$，那么为了让第四位是$1$，那么范围就是$[1011000,1011111]$

而我们知道了$ans$的范围，而$ans$代表的是$a[i]+x$，那么我们其实只需要知道有没有$a[i]$在$[ans+(1<<i)-x,ans+(1<<(i+1))-1-x]$这个区间就可以了，而题目中限制了在某个区间中，直接上主席树板子查询就$ok$

- 那么如果$b$此时为$1$的话同理，那么我们为了最终$ans\oplus b$更大，$ans$这一位最好为$0$，那么$ans$的取值范围是$[ans,ans+(1<<i)-1]$,自然$a[i]$的取值范围就是$[ans-x,ans+(1<<i)-1-x]$了


最后把$ans$异或一下$b$就是答案啦


------------
下面是美滋滋的代码时间~~~

~~~cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define N 200007
#define M 100007
using namespace std;
struct Tree
{
	int ls,rs,sum;
}tr[N<<7];
int n,m,cnt;
int root[N];
void Pushup(int rt)
{
	tr[rt].sum=tr[tr[rt].ls].sum+tr[tr[rt].rs].sum;
}
void Build(int &rt,int l,int r)
{
	if(!rt)
		rt=++cnt;
	if(l==r)
		return;
	int mid=l+((r-l)>>1);
	Build(tr[rt].ls,l,mid);
	Build(tr[rt].rs,mid+1,r);
}
void Insert(int &now,int last,int l,int r,int pos)
{
	if(!now)
		now=++cnt;
	if(l==r)
	{
		tr[now].sum=tr[last].sum+1;
		return;
	}
	int mid=l+((r-l)>>1);
	if(pos<=mid)
	{
		tr[now].rs=tr[last].rs;
		Insert(tr[now].ls,tr[last].ls,l,mid,pos);
	}
	else
	{
		tr[now].ls=tr[last].ls;
		Insert(tr[now].rs,tr[last].rs,mid+1,r,pos);
	}
	Pushup(now);
}
bool Search(int now,int last,int l,int r,int ql,int qr)
{
	if(tr[last].sum-tr[now].sum<1)
		return 0;
	if(ql<=l&&r<=qr)
		return 1;
	int mid=l+((r-l)>>1),tot=0;
	if(ql<=mid)
		tot+=Search(tr[now].ls,tr[last].ls,l,mid,ql,qr);
	if(qr>mid)
		tot+=Search(tr[now].rs,tr[last].rs,mid+1,r,ql,qr);
	return tot;
}
int main()
{
	scanf("%d%d",&n,&m);
	Build(root[0],0,M);
	for(int i=1;i<=n;++i)
	{
		int in;
		scanf("%d",&in);
		Insert(root[i],root[i-1],0,M,in);
	}
	for(int i=1;i<=m;++i)
	{
		int b,x,ql,qr,ans=0;
		scanf("%d%d%d%d",&b,&x,&ql,&qr);
		for(int j=17;j>=0;--j)
		{
			int L,R,opt;
			if(b&(1<<j))
				L=ans,R=ans+((1<<j)-1),opt=0;
			else
				L=ans+(1<<j),R=ans+((1<<(j+1))-1),opt=1;
			//printf("\n-------test-------\n"),printf("ans:%d",opt),printf("\n-------test-------\n");
			if(!Search(root[ql-1],root[qr],0,M,max(L-x,0),min(R-x,M)))
				opt^=1;
			ans+=(opt<<j);
		}
		printf("%d\n",ans^b);
	}
	return 0;
}
~~~





---

## 作者：Nt_Tsumiki (赞：7)

## 题意

先给你一个长度为 $n$ 的数组 $a$，接下来有 $m$ 组数据，每组数据各有一组 $b,x,l,r$，让你求在区间 $[l,r]$ 中 $b \oplus (a_i+x)$ 的最大值。

## 做法

相信很多人跟我一样，第一眼看到这个题面，就觉得是可持久化线段树加 Trie 树乱搞的，但写了写就发现，Trie 树好像用不到，贪心就可以了，具体如下。

因为是判断异或最大和，我们不妨，一位一位的贪心，即按位贪心，那么就有两种情况：

1. $b$ 的第 $j$ 位为 $0$ 时，因为考虑异或最大，所以最好使 $a_i$ 的第 $j$ 位为 $1$，那么搜索的范围就为 $[ans+(1<<j),ans+(1<<(j+1))-1]$，$ans$ 为前几位的贪心结果，这也很好推导，假设一个二进制数它的最高位 $k$ 为 $1$，后面的几位随意，那么，它最大就为 $1<<(k+1)-1$，即后面全是 $1$，最小就为 $1<<k$，即后面全是 $0$。

2. $b$ 的第 $j$ 位为 $1$ 时，考虑异或最大，所以最好使 $a_i$ 的第 $j$ 位为 $0$，所以搜索的范围为 $[ans,ans+(1<<j)-1]$，推导同上。

所以只需要从高往低贪心，再用主席树搜索判断区间中是否存在符合要求的数即可。
 
## Code
```cpp
#include <algorithm>
#include <iostream>
#include <cstdio>

#define N 200001

using namespace std;
int n,m,cnt;
int a[N],maxn;
int root[N];

struct Node {
    int l,r,sum;
}e[N<<5];

int clone(int x) {
    e[++cnt]=e[x];
    e[cnt].sum++;
    return cnt;
}

void build(int &x,int l,int r) {
    x=++cnt;
    if (l==r) return;
    int mid=(l+r>>1);
    build(e[x].l,l,mid);
    build(e[x].r,mid+1,r);
}

void add(int &x,int l,int r,int k) {
    x=clone(x);
    if (l==r) {
        return;
    }
    int mid=(l+r>>1);
    if (k>mid) add(e[x].r,mid+1,r,k);
    else add(e[x].l,l,mid,k);
}

bool ask(int x,int y,int l,int r,int L,int R) {
    int tmp=0;
    if (e[y].sum-e[x].sum<1) return 0;
    if (L<=l and r<=R) return 1;
    int mid=(l+r>>1);
    if (L<=mid) tmp+=ask(e[x].l,e[y].l,l,mid,L,R);
    if (R>mid) tmp+=ask(e[x].r,e[y].r,mid+1,r,L,R);
    return tmp;
}

int main() {
    scanf("%d%d",&n,&m);
    for (int i=1;i<=n;i++) scanf("%d",a+i),maxn=max(maxn,a[i]);
    build(root[0],0,maxn);
    for (int i=1;i<=n;i++) {
        root[i]=root[i-1];
        add(root[i],0,maxn,a[i]);
    }
    for (int i=1,b,x,l,r,ans=0;i<=m;i++) {
        ans=0;
        scanf("%d%d%d%d",&b,&x,&l,&r);
        for (int j=17,ll,rr,tt=0;j>=0;j--) {
            int tmp=(1<<j);
            if (b&tmp) ll=ans,rr=ans+(1<<j)-1,tt=0;
            else ll=ans+(1<<j),rr=ans+(1<<(j+1))-1,tt=1;
            if (!ask(root[l-1],root[r],0,maxn,max(ll-x,0),min(rr-x,maxn)))
                tt^=1;
            ans+=(tt<<j);
        }
        printf("%d\n",ans^b);
    }
    return 0;
}
```

---

## 作者：myee (赞：6)

### 前言

![CMLL02_AK_DSPOLY.jpg](https://cdn.luogu.com.cn/upload/image_hosting/0mabjd42.png)

### 思路

考虑二分答案。

对答案 $ans$ 从高位到低位考虑，直接考虑 $(ans\operatorname{XOR}b)-x$ 的取值范围。

考虑低位任意，高位已定，直接易得 $ans\operatorname{XOR}b$ 之值域亦为**低位任意，高位已定**。

于是立刻得到 $(ans\operatorname{XOR}b)-x$ 的值域，拿颗主席树判断一下该区间内是否存在该值即可。

复杂度 $O(n\log v+q\log^2v)$。

### Code

由于使用指针实现，时空常数较大。

```cpp
#include <algorithm>
#include <stdio.h>
#include <vector>
typedef long long llt;
typedef unsigned uint;typedef unsigned long long ullt;
typedef bool bol;typedef char chr;typedef void voi;
typedef double dbl;
template<typename T>bol _max(T&a,T b){return(a<b)?a=b,true:false;}
template<typename T>bol _min(T&a,T b){return(b<a)?a=b,true:false;}
template<typename T>T power(T base,T index,T mod){return((index<=1)?(index?base:1):(power(base*base%mod,index>>1,mod)*power(base,index&1,mod)))%mod;}
template<typename T>T lowbit(T n){return n&-n;}
template<typename T>T gcd(T a,T b){return b?gcd(b,a%b):a;}
template<typename T>T lcm(T a,T b){return(a!=0||b!=0)?a/gcd(a,b)*b:(T)0;}
template<typename T>T exgcd(T a,T b,T&x,T&y){if(!b)return y=0,x=1,a;T ans=exgcd(b,a%b,y,x);y-=a/b*x;return ans;}
uint X[300005];
struct node
{
    friend uint size(node*p){return p==NULL?0:p->siz;}
    uint siz,dep;node*son[2];
    node(uint d):siz(0),dep(d){son[0]=son[1]=NULL;}
    uint find(uint l,uint r)
    {
        if(l>=r)return 0;
        if(!l&&r==(1u<<(dep+1)))return siz;
        if(l<(1u<<dep))
            if(r<=(1u<<dep))return son[0]==NULL?0:son[0]->find(l,r);
            else return(son[0]==NULL?0:son[0]->find(l,1u<<dep))+(son[1]==NULL?0:son[1]->find(0,r-(1u<<dep)));
        else return son[1]==NULL?0:son[1]->find(l-(1u<<dep),r-(1u<<dep));
    }
};
uint cnt=0;
node*R[300005];
int main()
{
    uint n,q;scanf("%u%u",&n,&q);
    for(uint i=0;i<n;i++)scanf("%u",X+i);
    R[0]=new node(20);
    for(uint i=0;i<n;i++)
    {
        uint v=X[i];
        *(R[i+1]=new node(20))=*R[i];
        node*p=R[i],*q=R[i+1];
        q->siz++;
        for(uint i=20;~i;i--)
        {
            uint op=v>>i&1;
            q=q->son[op]=new node(i-1);
            if(p!=NULL)p=p->son[op];
            if(p!=NULL)*q=*p;
            q->siz++;
        }
    }
    while(q--)
    {
        uint b,x,l,r;scanf("%u%u%u%u",&b,&x,&l,&r),l--;
        uint ans=0;
        for(uint i=20;~i;i--)
        {
            uint p=ans|(1u<<i);
            p^=b&~((1u<<i)-1);
            uint q=p+(1u<<i);
            if(p>x)p-=x;else p=0;
            if(q>x)q-=x;else q=0;
            if(R[r]->find(p,q)>R[l]->find(p,q))
                ans|=1u<<i;
        }
        printf("%u\n",ans);
    }
    return 0;
}
```



---

## 作者：oscar (赞：3)

本题为经典的可持久化trie练习题

先对所有菜建一棵可持久化trie

顾客的偏好值相当于在trie上的“偏移量”，需要支持一个查询操作：查询两个版本间trie上数值L~R区间是否存在菜

查询的时候将r版本和l-1版本trie相减，在trie上跑一遍类似线段树的查询就好

最后对于每个顾客，跑一下带偏移的按位贪心，也就是贪到每一层时，分别用上面的操作查询出L-x~mid-x区间和mid-x+1~R-x区间分别是否存在菜。

复杂度貌似是 $ O ( m log^2 \cdot n ) $ ？


良心提示：在bzoj上不要用cin。。RE了我好久


贴代码

```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
using namespace std;
const int MAXN=524287;
struct node
{
    int cnt;
    node *ls,*rs;
}pool[6000010],*root[2*MAXN];
int top,curt;
int n,m,a,b,x,l,r;
void inorder(node *cur)
{
    printf("{");
    if(cur->ls){inorder(cur->ls);}
    printf("(%d)",cur->cnt);
    if(cur->rs){inorder(cur->rs);}
    printf("}");
}
node* bt(int l,int r)
{
    node *tmp=&pool[top++];
    tmp->cnt=0;
    if(l!=r)
    {
        int m=(l+r)/2;
        tmp->ls=bt(l,m);
        tmp->rs=bt(m+1,r);
    }
    return tmp;
}
node* Change(node *pre,int x,int l,int r)
{
    node *tmp=&pool[top++];
    tmp->cnt=pre->cnt+1;
    if(l==r){return tmp;}
    int m=(l+r)/2;
    if(x<=m){tmp->ls=Change(pre->ls,x,l,m);tmp->rs=pre->rs;}
    else {tmp->ls=pre->ls;tmp->rs=Change(pre->rs,x,m+1,r);}
    return tmp;
}
bool hn(node *cur,node *sub,int l,int r,int lrg,int rrg)
{
    if(l==lrg&&r==rrg)return cur->cnt-sub->cnt;
    int m=(l+r)/2;
    if(rrg<=m)return hn(cur->ls,sub->ls,l,m,lrg,rrg);
    if(lrg>m)return hn(cur->rs,sub->rs,m+1,r,lrg,rrg);
    return hn(cur->ls,sub->ls,l,m,lrg,m)||hn(cur->rs,sub->rs,m+1,r,m+1,rrg);
}
bool HN(int lt,int rt,int lrg,int rrg)
{
    if(rrg<0)return false;
    return hn(root[rt],root[lt-1],0,MAXN,max(0,lrg),rrg);
}
int query(int lt,int rt,int dep,int l,int r,int x,int b)
{
    if(l==r)return l^b;
    int oi=(b>>dep)&1,m=(l+r)/2;
    if(oi)
    {
        if(HN(lt,rt,l-x,m-x))
            return query(lt,rt,dep-1,l,m,x,b);
        else
            return query(lt,rt,dep-1,m+1,r,x,b);
    }
    else
    {
        if(HN(lt,rt,m+1-x,r-x))
            return query(lt,rt,dep-1,m+1,r,x,b);
        else
            return query(lt,rt,dep-1,l,m,x,b);
    }
}
int Query(int b,int x,int l,int r)
{
    return query(l,r,18,0,MAXN,x,b);
}
int main()
{
    scanf("%d%d",&n,&m);
    root[0]=bt(0,MAXN);
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&a);
        root[curt+1]=Change(root[curt],a,0,MAXN);
        curt++;
    }
    for(int i=1;i<=m;i++)
    {
        scanf("%d%d%d%d",&b,&x,&l,&r);
        printf("%d\n",Query(b,x,l,r));
    }
    return 0;
}
```

---

## 作者：nofind (赞：3)

题意:https://www.luogu.org/problem/P3293

看见位运算必然会想到按位贪心

要求$b_iXOR(a_j+x_i)$最大,那么由于$x_i$和$b_i$固定,只需要找$a_j$即可

考虑当期找到的$a_j+x$为ans,考虑到了$b_i$的k位

假设$b_i$的这一位为0,那么我们要找的$a_j+x_i$的第k位应该尽可能为1,于是$a_j+x_i$的范围就是$[ans+2^k,ans+2^{k+1}-1]$

假设$b_i$的这一位为1,那么我们要找的$a_j+x_i$的第k位应该尽可能为0,于是$a_j+x_i$的范围就是$[ans,ans+2^k]$

由于是区间查询,用主席树即可

注意这句话：
```
if(R<l||L>r||sum(p)-sum(pre)<=0)return 0;
```
$ans+2^k$是很可能超过maxm的,不加这句会使你RE

code：
```
#include<bits/stdc++.h>
using namespace std;
#define lc(p) (seg[p].lc)
#define rc(p) (seg[p].rc)
#define sum(p) (seg[p].sum)
const int maxn=2*1e5+10;
const int maxm=1e5+10;
int n,m,num,tot;
int a[maxn],root[maxn];
struct Seg
{
    int lc,rc;
    int sum;
}seg[maxn*50];
inline void up(int p){sum(p)=sum(lc(p))+sum(rc(p));}
void insert(int pre,int &p,int l,int r,int pos)
{
    p=++tot;
    sum(p)=sum(pre)+1;
    if(l==r)return;
    int mid=(l+r)>>1;
    if(pos<=mid)insert(lc(pre),lc(p),l,mid,pos),rc(p)=rc(pre);
    else insert(rc(pre),rc(p),mid+1,r,pos),lc(p)=lc(pre);
    up(p);
}
int query(int pre,int p,int L,int R,int l,int r)
{
    /*printf("%d %d %d %d\n",L,R,l,r);
    getchar();*/
    if(R<l||L>r||sum(p)-sum(pre)<=0)return 0;
    if(L>=l&&R<=r)return sum(p)-sum(pre);
    int mid=(L+R)>>1,ans=0;
    if(l<=mid)ans+=query(lc(pre),lc(p),L,mid,l,r);
    if(r>mid)ans+=query(rc(pre),rc(p),mid+1,R,l,r);
    return ans;
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)scanf("%d",&a[i]);
    for(int i=1;i<=n;i++)insert(root[i-1],root[i],0,maxm,a[i]);
    //printf("test::%d\n",query(root[0],root[4],0,maxm,1,4));
    for(int i=1;i<=m;i++)
    {
        int b,x,l,r,ans=0;
        scanf("%d%d%d%d",&b,&x,&l,&r);
        for(int j=18;~j;j--)
        {
            if(b&(1<<j)&&!query(root[l-1],root[r],0,maxm,ans-x,ans+(1<<j)-1-x))ans+=1<<j;
            if(!(b&(1<<j))&&query(root[l-1],root[r],0,maxm,ans+(1<<j)-x,ans+(1<<(j+1))-1-x))ans+=1<<j; 
        }
        printf("%d\n",ans^b);
    }
    return 0;
}
```


---

## 作者：_Anchor (赞：2)

[$Akamey's$ $blog$](https://www.cnblogs.com/Akmaey/p/14310192.html)

# 题意

[传送门](https://www.luogu.com.cn/problem/P3293)

# 分析

题意是查询一段区间中的异或和的最大值，所以可以想到**按位贪心**

也就是说，我们枚举当前可能的答案$ans=a[i]+x$的每一位（从高到低），于是我们可以发现，

最终答案$a[i]$一定落在：

$\large [ans+(1<<i)-x,ans+(1<<(i+1))-1-x]$ $\quad \large (b[i]$这一位为$\large 0)$

$\large [ans-x,ans+(1<<i)-1-x]$ $\quad \large (b[i]$这一位为$\large1)$

上面两种情况分别对应$b[i]$的当前位为$0$和$1$的情况

当$b[i]$为$0$，则当前位为$1$答案更优

当$b[i]$为$1$，则当前位为$0$答案更优

所以我们直接查询在两段值域区间内有没有数即可，如果有，那么继续下一位的枚举，当前这一位就变成$1/0$，如果没有，那么当前这一位就变成$0/1$，还是继续下一位，直到结束

此时$ans=a[i]+x$，所以我们直接$ans \bigoplus b$就是最优的答案

因为要区间查询值域上数的个数，所以我们用值域线段树来维护

但是我们这样干只能记录对于下标区间$[1,n]$的值域线段树（也就是全局），但是我们这里还要求某一个特定区间$[l,r]$当中的值域线段树

这就是主席树的经典应用了，静态区间第$k$大的问题中我们就用过值域线段树维护值域，然后用下标的差来维护区间即可

所以我们这里采用主席树来维护值域就行了
# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
template <typename T>
inline void read(T &x){
	x=0;char ch=getchar();bool f=false;
	while(!isdigit(ch)){if(ch=='-'){f=true;}ch=getchar();}
	while(isdigit(ch)){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}
	x=f?-x:x;
	return ;
}
template <typename T,typename... Args> inline void read(T& t, Args&... args){read(t);read(args...);}
template <typename T>
inline void write(T x){
	if(x<0) putchar('-'),x=-x;
	if(x>9) write(x/10);
	putchar(x%10^48);
	return ;
}
template <typename T>
inline void print(T x){write(x),putchar(' ');}
#define ll long long
#define ull unsigned long long
#define inc(x,y) (x+y>=MOD?x+y-MOD:x+y)
#define dec(x,y) (x-y<0?x-y+MOD:x-y)
#define min(x,y) (x<y?x:y)
#define max(x,y) (x>y?x:y)
const int N=2e5+5,M=1e5+5,MOD=1e9+7;
int n,m,a[N],b[N],root[N],cnt;
struct Segment_Tree{
	int sum,ls,rs;
	#define sum(x) Tree[x].sum
	#define ls(x) Tree[x].ls
	#define rs(x) Tree[x].rs
}Tree[N<<5];
void build(int &rt,int l,int r){
	rt=++cnt;
	if(l==r){sum(rt)=0;return;}
	int mid=l+r>>1;
	build(ls(rt),l,mid),build(rs(rt),mid+1,r);
	return ;
}
void modify(int &rt,int pre,int l,int r,int pos,int v){
	rt=++cnt;
	if(l==r){sum(rt)=sum(pre)+v;return ;}
	int mid=l+r>>1;
	ls(rt)=ls(pre),rs(rt)=rs(pre),sum(rt)=sum(pre)+v;
	if(pos<=mid) modify(ls(rt),ls(pre),l,mid,pos,v);
	else modify(rs(rt),rs(pre),mid+1,r,pos,v);
	return ;
}
bool query(int u,int v,int l,int r,int ql,int qr){
	if(sum(v)-sum(u)<1) return false;
	if(ql<=l&&r<=qr) return true;
	int mid=l+r>>1,res=0;
	if(ql<=mid) res+=query(ls(u),ls(v),l,mid,ql,qr);
	if(qr>mid) res+=query(rs(u),rs(v),mid+1,r,ql,qr);
	return res;
}

int main(){
	read(n),read(m);build(root[0],0,M);
	for(int i=1;i<=n;i++){
		read(a[i]);
		modify(root[i],root[i-1],0,M,a[i],1);
	}
	for(int i=1,b,x,l,r;i<=m;i++){
		read(b),read(x),read(l),read(r);
		int ans=0;
		for(int k=17;k>=0;k--){
			int L,R,op;
			if(b&(1<<k)) L=ans,R=ans+((1<<k)-1),op=0;
			else L=ans+(1<<k),R=ans+((1<<(k+1))-1),op=1;
			if(!query(root[l-1],root[r],0,M,max(L-x,0),min(R-x,M))) op^=1;
			ans+=(op<<k);
		}
		write(ans^b),putchar('\n');
	}
	system("Pause");
	return 0;
}

---

## 作者：xyz32768 (赞：2)

可以利用二分的思想，具体步骤，就是**从高到低**确定每一个二进制位的数值。

可以看出，如果当前已经确定了前几位，那么这个解的范围一定是一个连续的区间。举个例子，假设初始解的枚举范围是$[0,262143]$（即$18$位二进制数），如果当前已经确定了第$18,17,16$位分别为$1,0,1$，那么这时候解的范围就是$[163840,196607]$。

设当前解的范围是$[s,t]$，第$i+1$位到第$18$位已经被确定，现在考虑怎样确定第$i$位，也就是说判断要把解的范围缩小为$[s,\frac{s+t}{2}]$还是缩小为$[\frac{s+t}{2}+1,t]$。由于要取最大值，所以先尝试可否把解的范围缩小到$[\frac{s+t}{2}+1,t]$，下面令$L=\frac{s+t}{2}+1,R=t$。

然后可以继续发现，$[L,R]$内的数被$\mbox{xor}$上$b$之后得到的值域，仍然是一段连续的区间。这时候，由于$a\mbox{ xor }b=c$时一定有$a\mbox{ xor }c=b$，所以将$L$和$R$的**第$i$位到第$18$位**分别与$b$的**第$i$位到第$18$位**进行异或，就能得到一个新的区间$[u,v]$，也就是说$[u,v]$里的数被$\mbox{xor}$上$b$之后得到的值域为$[L,R]$。

可以得出：

$u=\lfloor\frac{L\mbox{ xor }b}{2^{i-1}}\rfloor*2^{i-1}$

$v=\lfloor\frac{R\mbox{ xor }b}{2^{i-1}}\rfloor*2^{i-1}+2^{i-1}-1$

这时候就可以看出，所有美味度为$[L,R]$的菜，都是评价值在区间$[u-x,v-x]$内的菜。如果在给定的可选择菜品区间内，存在一道菜的评价值在区间$[u-x,v-x]$内，那么就可以把答案区间调整为$[\frac{s+t}{2}+1,t]$，否则调整为$[s,\frac{s+t}{2}]$。

对于询问一个可选择菜品区间内评价值在区间$[u-x,v-x]$内的菜的个数，可以用树状数组离线询问。但是由于询问之间有联系，所以用主席树代替树状数组，以达到在线查询的目的。

代码：

```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
inline int read() {
    int res = 0; bool bo = 0; char c;
    while (((c = getchar()) < '0' || c > '9') && c != '-');
    if (c == '-') bo = 1; else res = c - 48;
    while ((c = getchar()) >= '0' && c <= '9')
        res = (res << 3) + (res << 1) + (c - 48);
    return bo ? ~res + 1 : res;
}
const int N = 2e5 + 5, NLogN = 7e6 + 5;
struct cyx {
    int lc, rc, cnt;
} T[NLogN];
int n, m, a[N], QAQ, rt[N];
void ins(int y, int &x, int l, int r, int p) {
    T[x = ++QAQ] = T[y]; T[x].cnt++; int mid = l + r >> 1;
    if (l == r) return; if (p <= mid) ins(T[y].lc, T[x].lc, l, mid, p);
    else ins(T[y].rc, T[x].rc, mid + 1, r, p);
}
int query(int l, int r, int s, int e, int p1, int p2) {
    if (l == s && r == e) return T[p2].cnt - T[p1].cnt;
    int mid = l + r >> 1;
    if (e <= mid) return query(l, mid, s, e, T[p1].lc, T[p2].lc);
    else if (s >= mid + 1) return query(mid + 1, r, s, e, T[p1].rc, T[p2].rc);
    else return query(l, mid, s, mid, T[p1].lc, T[p2].lc) +
        query(mid + 1, r, mid + 1, e, T[p1].rc, T[p2].rc);
}
void init() {
    int i; for (i = 1; i <= n; i++)
        ins(rt[i - 1], rt[i], 0, 131071, a[i]);
}
int main() {
    int i, b, x, l, r, ans; n = read(); m = read();
    for (i = 1; i <= n; i++) a[i] = read(); init();
    while (m--) {
        b = read(); x = read(); l = read(); r = read();
        ans = 0; for (i = 17; i >= 0; i--) {
            int tl = ans | (1 << i), tr = tl + (1 << i) - 1;
            tl ^= b; tr ^= b; tl = (tl >> i) << i; tr = (tr >> i) << i;
            tr += (1 << i) - 1; tl -= x; tr -= x;
            if (tr < 0 || tl > 131071) continue;
            if (tl < 0) tl = 0; if (tr > 131071) tr = 131071;
            if (query(0, 131071, tl, tr, rt[l - 1], rt[r]))
                ans = ans | (1 << i);
        }
        printf("%d\n", ans);
    }
    return 0;
}
```

---

## 作者：Utilokasteinn (赞：1)

## [Link](https://www.luogu.com.cn/problem/P3293)

首先令 $c_i=a_i+x(l\le i\le r)$。

那么对于一个 $b$，我们要找一个 $c_i$ 使得 $b\oplus c_i$ 最大。

显然这可以贪心。

将 $b$ 转为二进制，最低位为第 $0$ 位。

从高到低位考虑，显然，将第 $i$ 位赋为相反的那个数比将后 $i-1$ 位全赋为相反的数都更优。

设当前处理到第 $i$ 位，第 $i$ 位为 $ch$。

若 $ch$ 为 $0$，那么找区间内是否有第 $i$ 位为 $0$ 的数，且满足之前的要求。

若 $ch$ 为 $1$，那么找区间内是否有第 $i$ 位为 $1$ 的数，且满足之前的要求。

其实这就是一个找区间内一个值域的数的个数，这是可以用主席树维护的。

然后把 $c$ 拆开，同理，还是找区间内一个值域的数的个数的过程。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read()
{
	int s=0;char c=getchar();
	for(;!isdigit(c);c=getchar());
	for(;isdigit(c);c=getchar())
		s=s*10+c-'0';
	return s;
}
int n,m,a[200005],maxn;
int tot,rt[200005];
struct segment_tree{
	int ls,rs,cnt;
}s[200005*21];
void update(int l,int r,int pos,int pre,int &p)
{
	p=++tot;
	s[p]=s[pre],s[p].cnt++;
	if(l==r)return;
	int mid=(l+r)/2;
	if(pos<=mid)update(l,mid,pos,s[pre].ls,s[p].ls);
	else update(mid+1,r,pos,s[pre].rs,s[p].rs);
}
int query(int l,int r,int ql,int qr,int p1,int p2)//找值域[ql,qr]中是否有数 
{
	if(ql>r||qr<l||!(s[p2].cnt-s[p1].cnt))return 0;
	if(ql<=l&&r<=qr)return s[p2].cnt-s[p1].cnt;
	int mid=(l+r)/2;
	return query(l,mid,ql,qr,s[p1].ls,s[p2].ls)+query(mid+1,r,ql,qr,s[p1].rs,s[p2].rs);
}
bool check(int p,int q,int ql,int qr)
{
	ql=max(ql,0);qr=min(qr,maxn);
	if(ql>qr) return false;
	return query(0,maxn,ql,qr,rt[p],rt[q]);
}
int main()
{
	n=read(),m=read();
	for(int i=1;i<=n;i++)
		a[i]=read(),maxn=max(maxn,a[i]);
	for(int i=1;i<=n;i++)
		update(0,maxn,a[i],rt[i-1],rt[i]);
	while(m--)
	{
		int b=read(),x=read(),l=read(),r=read(),ans=0;
		for(int i=17;i>=0;i--)
		{
			int c=(b>>i)&1;
			if(c&&!query(0,maxn,ans-x,ans+(1<<i)-1-x,rt[l-1],rt[r]))ans+=(1<<i);//这位只能填1
            if(!c&&query(0,maxn,ans+(1<<i)-x,ans+(1<<i+1)-1-x,rt[l-1],rt[r]))ans+=(1<<i);//这位可以填1
		}
		printf("%d\n",b^ans);
	}
	return 0;
}
```


---

## 作者：ButterflyDew (赞：1)

因为我想了好久这个鬼值域是怎么划分的，所以来发一个直观一点的理解

考虑每次对$b$和$d$求$c=d \ xor \ (a+b)$的最大值，因为异或每一位是独立的，所以我们可以尝试按位贪心。

如果要求$c$的从低到高第$i$位为$0$(最低位为第$0$位)，那么此时$c$的更高位是确定好的了

$$\begin{aligned}\_\_\_\_\_\_\_ 01111111\\ \_\_\_\_\_\_\_00000000\end{aligned}$$

这是$c$的上界和下界，分别减去$b$后，得到$a$需要满足的区间，然后在原位置区间里面查询$a$需要满足的值域区间，直接主席树即可

然后如果要求此位为$1$

$$\begin{aligned}\_\_\_\_\_\_\_11111111\\\_\_\_\_\_\_\_10000000\end{aligned}$$

可以看出刚好是把值域分完了的，所以这样是对的

---

## 作者：ListenSnow (赞：0)

[原题链接](https://www.luogu.com.cn/problem/P3293)

## 题意

一家餐厅有 $n$ 道菜，编号 $1,2,...,n$ ，大家对第 $i$ 道菜的评价值为 $a_i$。有 $m$ 位顾客，第 $i$ 位顾客的期望值为 $b_i$，而他的偏好值为 $x_i$。因此，第 $i$ 位顾客认为第 $j$ 道菜的美味度为 $b_i\,\,xor\,\, (a_j+x_i)$，$xor$ 表示异或运算。

第 $i$ 位顾客希望从这些菜中挑出他认为最美味的菜，即美味值最大的菜，但由于价格等因素，他只能从第 $l_i$ 道到第 $r_i$ 道中选择。请你帮助他们找出最美味的菜。

## 数据范围

$1 \le n \le 2 \times 10^5$，$0 \le a_i,b_i,x_i < 10^5$，$1 \le l_i \le r_i \le n$（$1 \le i \le m$），$1 \le m \le 10^5$。

## 思路

由于是求异或的最大值，可以考虑按二进制位从高到底贪心地枚举。 

假设当前枚举到第 $i$ 位，已经枚举过的位数上的答案为 $val$，$b$ 的第 $i$ 位为 $1$（为 $0$ 时同理），那么此时我们就想要在 $a_{l} \sim a_{r}$ 中查询一个数，满足其加上 $x$ 后前 $i-1$ 位为 $val$，且第 $i$ 位为 $0$。可以推出这样的数在区间 $[val-x,val+2^i-1-x]$ 中。

而需要在给定的区间中寻找特定的值，可以用主席树维护序列 $a$。具体实现可以看代码。 


## code：

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int N=2e5+10;
int n,m,tot,a[N],root[N],w;
struct tree{int ls,rs,cnt;}tr[N*21];
void insert(int p,int &q,int l,int r,int val)
{
	q=++tot;if(l==r) { tr[q].cnt=tr[p].cnt+1;return ;}int mid=l+r>>1;
	tr[q]=tr[p];tr[q].cnt++;
	if(val<=mid) insert(tr[p].ls,tr[q].ls,l,mid,val);
	else insert(tr[p].rs,tr[q].rs,mid+1,r,val);
}
int query(int p,int q,int l,int r,int ql,int qr)
{
	if(ql<=l&&r<=qr) return tr[q].cnt-tr[p].cnt;
	int res=0,mid=l+r>>1;
	if(ql<=mid) res+=query(tr[p].ls,tr[q].ls,l,mid,ql,qr);
	if(qr>mid) res+=query(tr[p].rs,tr[q].rs,mid+1,r,ql,qr);
	return res;
}
bool check(int p,int q,int ql,int qr)
{
	ql=max(ql,0);qr=min(qr,w);
	if(ql>qr) return false;
	return query(root[p],root[q],0,w,ql,qr);
}
int main()
{
	scanf("%d%d",&n,&m);for(int i=1;i<=n;i++) scanf("%d",&a[i]),w=max(w,a[i]);
	for(int i=1;i<=n;i++) insert(root[i-1],root[i],0,w,a[i]);
	while(m--)
	{
		int b,x,l,r,val=0;scanf("%d%d%d%d",&b,&x,&l,&r);
		for(int i=17;i>=0;i--)
		{
			int tmp=val+((1^((b>>i)&1))<<i);
			if(check(l-1,r,tmp-x,tmp+(1<<i)-1-x)) val=tmp;
			else val+=(((b>>i)&1)<<i);
		}
		printf("%d\n",val^b);
	}
	return 0;
}
```


---

## 作者：raincity (赞：0)

## 分析
看到异或值最大容易想到 01 trie，但是这道题要 $+x_i$ 所以不好做。

但是其实还是可以用 01 trie 的思想。

从高往低考虑二进制位。设当前在考虑从低到高第 $d$ 位，最优的 $a_j+x_i$ 的高位为 $ans$。

假设 $b_i$ 的第 $d$ 位为 0，为 1 的情况类似。尽量让 $a_j+x_i$ 的第 $d$ 位为 1。

若 $a_j+x_i$ 的第 $d$ 位为 1，则 

$$ans+2^{d-1}\le a_j+x_i<ans+2^d$$

也就是 

$$ans+2^{d-1}-x_i\le a_j\le ans+2^d-x_i-1$$

只需要查询 $l$ 到 $r$ 中有没有区间内的值。可以用主席树（可持久化值域线段树）维护。

## 解决
~~常数怎么这么大~~

CCF 已经进步到 C++14 O2 时代了，所以常数大一点也没关系（确信）

```cpp
#include <cstdio>
#include <cstring>
#include <iostream>

using namespace std;
using LL = long long;
using LLL = __int128;

const int N = 2e5 + 5, A = 1e5 + 5, LOG = 18;
int n, m;

class chairmanTree {
   private:
    static const int C = N * LOG;
    int lc[C], rc[C], val[C], root[N], cnt;

    int modify(int p, int l, int r, int po) {
        int q = ++cnt;
        val[q] = val[p];
        if (l == r) return val[q]++, q;
        int mid = (l + r) >> 1;
        if (po <= mid)
            lc[q] = modify(lc[p], l, mid, po), rc[q] = rc[p];
        else
            lc[q] = lc[p], rc[q] = modify(rc[p], mid + 1, r, po);
        return val[q] = val[lc[q]] + val[rc[q]], q;
    }

    int query(int p, int q, int l, int r, int ql, int qr) {
        if (ql <= l && qr >= r) return val[q] - val[p];
        int mid = (l + r) >> 1;
        return (ql <= mid ? query(lc[p], lc[q], l, mid, ql, qr) : 0) +
               (qr > mid ? query(rc[p], rc[q], mid + 1, r, ql, qr) : 0);
    }

   public:
    void modify(int ver, int base, int po) {
        root[ver] = modify(root[base], 0, A, po);
    }

    bool query(int l, int r, int ql, int qr) {
        return query(root[l - 1], root[r], 0, A, max(ql, 0), min(qr, A));
    }
} tree;

template <class T>
void read(T &ret) {
    ret = 0;
    char ch = getchar();
    bool found = false;
    while ((ch < '0' || ch > '9') && ch != '-') ch = getchar();
    if (ch == '-') ch = getchar(), found = true;
    while (ch >= '0' && ch <= '9') ret = ret * 10 + ch - '0', ch = getchar();
    if (found) ret = -ret;
}

template <class T, class... Args>
void read(T &ret, Args &...rest) {
    read(ret), read(rest...);
}

int main() {
    read(n, m);
    for (int i = 1, a; i <= n; i++) read(a), tree.modify(i, i - 1, a);
    while (m--) {
        int b, x, l, r, ans = 0;
        read(b, x, l, r);
        for (int i = LOG; i >= 1; i--) {
            int cur = b >> (i - 1) & 1;
            if (!cur && tree.query(l, r, ans + (1 << (i - 1)) - x,
                                   ans + (1 << i) - 1 - x))
                ans += 1 << (i - 1);
            if (cur && !tree.query(l, r, ans - x, ans + (1 << (i - 1)) - 1 - x))
                ans += 1 << (i - 1);
        }
        cout << (ans ^ b) << endl;
    }
    return 0;
}
```

---

## 作者：FutaRimeWoawaSete (赞：0)

这道题首先很好想到可持久化 $01Trie$ 吧，感觉 $01Trie$ 好像好想并且本人刚开始也想的是 $01Trie$ ，不过在学习了这道题的主席树打法后还是决定来一篇主席树题解。    

首先我们不妨先用正常 $01Trie$ 的角度来思考这道题，异或最大，显然先考虑 $01Trie$ 和 线性基 ， 线性基想不出来了，不过中间有个加号好像也可以通过值域维护在 $01Trie$ 上实现？到此这道题的第一印象思路就是这样。    

如果您想写可持久化 $01Trie$ 的话您就在 $Trie$ 上直接查询即可，其他题解里面也有详细解析此题的 $01Trie$所以在这里不作过多解释。    

这道题我们可以借用一下 $01Trie$ 的思想，具体来做还是从高到低贪心，由于位之间相互不影响，所以我们单独来考虑。    

设 $T = a_j + x$ ，当前已经从高位到低位考虑到了 $T_i$。   

- 如果 $b_i$ 为 $0$ ，那么当前这位最优为 $1$ ，即我们的 $T$ 需要为$[T + 2 ^ i , T + 2 ^ {i + 1} - 1]$ ，这里大家可以手算一下就知道这个区间里的所有值的第 $i$ 位都为 $1$ 。  
- 如果 $b_i$ 为 $1$ ，那么当前这位最优为 $0$ ，即我们的 $T$ 需要为 $[T , T + 2 ^ k]$ ，和上面一个一样，这个区间的所有值第 $i$ 位都为 $0$。   

这里可能会有人问怎么实现，我们从高位考虑，每次我们都进行上述操作的查找，可以得证我们查找的区间都是在原有的基础上依次减小的，因而保证了正确性(大家也可以在草稿纸上画一画)。   

判断在一个序列的区间里有没有一段值域里面的值出现过，主席树不用说了吧，不过这里需要注意一下由于这个值域有亿点大，一定要在查询里面判断当前你查的区间里面还有没有原序列的数不然要 $T$ 飞……    

如果还不理解的同学可以再多在草稿纸上画一下或者看代码:   
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;
const int Len = 2e5 + 5 , maxn = 2e5;
int n,q,rt[Len],cnt,b,x,l,r,top;
struct node
{
	int l,r,sum;
}tree[Len * 23];
int clone(int p)
{
	top ++;
	tree[top] = tree[p];
	tree[top].sum ++;
	return top;
}
int build(int p,int l,int r)
{
	p = ++ top;
	if(l == r) return p;	
	int mid = (l + r) >> 1;
	tree[p].l = build(tree[p].l , l , mid);
	tree[p].r = build(tree[p].r , mid + 1 , r);
	return p;
}
int update(int p,int l,int r,int wh)
{
	p = clone(p);
	if(l == r) return p;
	int mid = (l + r) >> 1;
	if(wh <= mid) tree[p].l = update(tree[p].l , l , mid , wh);
	else tree[p].r = update(tree[p].r , mid + 1 , r , wh);
	return p;
}
int query(int l,int r,int nl,int nr,int L,int R)
{
	if(tree[nr].sum - tree[nl].sum == 0) return 0; 
	if(L <= l && R >= r) return tree[nr].sum - tree[nl].sum;
	int mid = (l + r) >> 1 , res = 0;
	if(L <= mid) res += query(l , mid , tree[nl].l , tree[nr].l , L , R);
	if(R > mid) res += query(mid + 1 , r , tree[nl].r , tree[nr].r , L , R);
	return res; 
} 
int main()
{
	scanf("%d %d",&n,&q);
	rt[0] = build(0 , 0 , maxn);
	for(int i = 1 ; i <= n ; i ++) 
	{
		int x;scanf("%d",&x);
		rt[i] = update(rt[i - 1] , 0 , maxn , x);
	}
	for(int i = 1 ; i <= q ; i ++)
	{
		scanf("%d %d %d %d",&b,&x,&l,&r);int ans = 0;
		for(int j = 18 ; j >= 0 ; j --)
		{
			if(b & (1 << j) && !query(0 , maxn , rt[l - 1] , rt[r] , max(0 , ans - x) , min(maxn , ans + (1 << j) - 1 - x))) ans += (1 << j);//如果答案位无法为1当前的aj + x的位就只能为1 
			if(!(b & (1 << j)) && query(0 , maxn , rt[l - 1] , rt[r] , ans + (1 << j) - x , ans + (1 << (j + 1)) - 1 - x)) ans += (1 << j);//如果答案位可以为1当前的aj + x位为1 
		}
		printf("%d\n",ans ^ b);
	}
	return 0;
}
```

---

## 作者：ez_lcw (赞：0)

看到异或最大，第一反应是用 01trie 做。

但是 01trie 不能实现区间加法，所以不好做。

看回题目，从最简单的思路去想：

设 $ans$ 能使得 $ans\ \operatorname{xor}\ b$ 最大。每次将 $b$ 二进制拆分，设二进制下 $b$ 的第 $i$ 位为 $b_i$（第 $0$ 位为最低位），$ans$ 的第 $i$ 位为 $ans_i$。

然后我们贪心地**从高位往低位**考虑如何取 $ans$。假设当前考虑取第 $i$ 位，前面取的总和为 $sum$（即 $sum=\sum_{j>i}ans_j\times 2^j$）。显然，$ans_i$ 取 $b_i\operatorname{xor}1$ 最优。

但是这样取可能导致我们无法找到一个合法的 $a_i+x=ans$，所以我们考虑当 $ans_i$ 取 $b_i\operatorname{xor}1$ 时，$ans$ 的取值会在哪个范围。

易得此时 $ans\in [sum+(b_i\operatorname{xor}1)\times2^i,sum+(b_i\operatorname{xor}1)\times2^{i}+2^i-1]$。

那么对应合法的 $a_i=ans-x$ 的取值范围也就出来了：

$a_i\in[sum+(b_i\operatorname{xor}1)\times2^i-x,sum+(b_i\operatorname{xor}1)\times2^{i}+2^i-1-x]$。

那么我们只用找到是否存在这么一个 $a_i$ 在这个范围里就好了。如果存在，$ans_i$ 就能取 $b_i\operatorname{xor}1$，否则只能取 $b_i$。

我们再看一下现在要维护的东西：$m\log (10^5)$ 次询问，每次给出两个区间 $[l,r]$ 和 $[v_1,v_2]$，问是否存在 $a_i\in[v_1,v_2]$（$l\leq i\leq r$）。

这种形式就很熟悉了，我们可以使用可持久化权值线段树来维护这个东西。

代码中的细节还是挺多的，如下：

```cpp
#include<bits/stdc++.h>

#define LN 18
#define N 200010
#define lc(u) t[u].ch[0]
#define rc(u) t[u].ch[1]

using namespace std;

struct Segment_Tree
{
	int ch[2],size;
}t[(N<<2)+N*LN];//主席数空间：4n+nlogn

int n,m,a[N];
int node,root[N];

void build(int &u,int l,int r)
{
	u=++node;
	if(l==r) return;
	int mid=(l+r)>>1;
	build(lc(u),l,mid);
	build(rc(u),mid+1,r);
}

void insert(int &u,int last,int l,int r,int x)
{
	u=++node;
	t[u]=t[last];
	t[u].size++;
	if(l==r) return;
	int mid=(l+r)>>1;
	if(x<=mid) insert(lc(u),lc(last),l,mid,x);
	else insert(rc(u),rc(last),mid+1,r,x);
}

bool query(int a,int b,int l,int r,int ql,int qr)
{
	if(ql<=l&&r<=qr) return t[b].size-t[a].size;//如果两次query分别求两棵树的size再相减判断的话可能会TLE，所以直接一次query判断
	int mid=(l+r)>>1;
	bool flag=false;
	if(ql<=mid) flag|=query(lc(a),lc(b),l,mid,ql,qr);
	if(qr>mid) flag|=query(rc(a),rc(b),mid+1,r,ql,qr);
	return flag;
}

int main()
{
	scanf("%d%d",&n,&m);
	build(root[0],0,1e5);//树的区间不是1到n，而是0到10^5，因为这是权值线段树
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&a[i]);
		insert(root[i],root[i-1],0,1e5,a[i]);
	}
	while(m--)
	{
		int b,x,l,r;
		scanf("%d%d%d%d",&b,&x,&l,&r);
		int sum=0;
		for(int i=17;i>=0;i--)//i要从17开始枚举，否则会WA，因为 2^16<=max ai<=2^17
		{
			int tmp=(b>>i)&1;
			tmp^=1;
			int minn,maxn;
			if(tmp)
			{
				minn=sum+(1<<i);
				maxn=sum+(1<<(i+1))-1;
			}
			else
			{
				minn=sum;
				maxn=sum+(1<<i)-1;
			}
			minn-=x;
			maxn-=x;//求出ai的范围
			bool flag=true;
			if(maxn<0) flag=false;//特判右端点小于0 
			else if(minn>1e5) flag=false;//特判左端点大于10^5
			else flag=query(root[l-1],root[r],0,1e5,max(minn,0),min(maxn,(int)1e5));//记得取max、min
			if(flag) sum+=tmp*(1<<i);
			else sum+=(tmp^1)*(1<<i);
		}
		printf("%d\n",sum^b);
	}
	return 0;
}
```

---


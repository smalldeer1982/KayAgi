# [JOISC 2016 Day2] 如厕计划

## 题目描述

竞赛比完之后，水箱里充满水的选手们鱼贯而出。凡华中学的厕所规划的很糟，只有两个厕位，于是厕所门前排起了长长的队伍。


厕所有两个，一个是女生专用厕所，另一个是男女混用厕所。**一共有2N个选手正在排队**，男女生数量可能不同。如果队头的是妹子，只要某个厕所是空的就可以进入，但是如果两个厕所都是空的，那么优先进入女性专用厕所。而如果队头是个绅♂士，只有在男女混用厕所是空的时候才能使用；如果只有女性专用厕所是空的，那么队伍中最靠前的妹子就可以不用继续等直接如厕。我们假设所有人如厕都需要花1分钟，不考虑切换的时间。


然而，**N分钟后，就要开饭了，所有人必须如厕完**，不过看样子似乎来不及。主办方可以重新调换顺序，不过有些人会因为新的顺序中自己更加后面了而感到不满，不满度是自己相比于原队列后退了几个顺序（除此之外跟自己的实际如厕顺序无关）。


主办方发现了这一点，所以希望你帮助他们解决这个问题，设计出一种方案，对于其中不满意度最大的学生，尽可能让他的不满意度最小。你只需要告诉他门最不满意的学生的不满意度是多少。


## 说明/提示

原队列是FFFMMMMMFF

改进后的队列是FMMFFMMMFF

所以厕所会按照下面的时间使用：

```cpp
分钟 1   2   3   4   5
共用 2   3   6   7   8
女用 1   4   5   9   10
```
两个妹子往后面移动了2位，所以不满意度是2

20% N<=10;M=1;K1=1

40% N<=100000;M=1;K1=1

100% 1<=N,Ki<=10^18;1<=M<=100000;所有Si字符串长度之和不超过200000


## 样例 #1

### 输入

```
5
3
FFF 1
M 5
FF 1```

### 输出

```
2```

# 题解

## 作者：kkksc03 (赞：48)

- ~20分做法：输出-1~出题人下次再也不敢了这么做了。

- 真·20分做法：2^N\*N^2的暴力生成每一种队列，然后计算不满意度。然而显然没人这么写。

- 60分做法：

首先我们要判断，怎样的一个序列是可行的。你可以从头开始模拟……可是没必有。题目有一个条件，N分钟，2N个人。那么所有的厕所必须不可以空。那我们可以倒者推。

如果最后面有两个男的，那么最后一分钟你们还是商量一下谁进女厕吧。所以我们可以猜想，男的应该尽可能靠前。而且不能超过N个男的，否则N个混合厕所不够分啊。

还是从后面推。我们把女性设为+1，男性设为-1，然后从队伍末尾开始开始计算后缀和。一但后缀和到了-2，就说明到了两个男的商量谁去女厕的地步。所以说只要保证后缀和一直大于等于-1，那么这个就一定可以在N分钟内解决（请读者自行证明，利用数学归纳法）

```cpp
               1   2   3   4   5
   F   F   F   M   M   M   M   M   F   F
                   -2  -1  0   1   2   1
                 (gg了)
```
因此，我们希望每个妹子退后C位，使后缀和一直不小于-1。因此不满的永远是妹子（奸笑）。这个C要尽可能小。

怎么构造这样一个队列呢？很简单，从队伍末尾挑出C（这里为2）个汉子，全部安排在队首。对了，每个M或者每个F都是不区分的。

```cpp
   1   2               3   4   5
   M   M   F   F   F   M   M   M   F   F
   0  -1   2   1   0  -1   0   1   2   1
```
我们可以看出，编号相同的男的，不会变的更加前面，而除了后面的女的，都退后了2个位。

于是，我们可以很愉快的二分C。60分

- 100分解法

其实完全没有必要。

我们可以画一个折线图，记录后缀和曲线（请读者自备纸笔），从后往前。我们可以发现，每将一个男的移动到前面去，折线图就会整体往上面移动1。所以说，我们只要计算整个序列中后缀和最小值是多少。每一个小段都可以算出后缀和的贡献，然后我们就O(M+sigma(Si))可以求出这个值，假设是-k。那么最终答案就是k-1。


---

## 作者：哔哩哔哩 (赞：14)

感谢@kkksc03的天才想法 感谢@Davidjing的无私分享

思路和kkk的一样，就是将其代码实现了一下

~~直接输出能拿20分~~

下面来自kkk的博客

> 我们只要计算整个序列中后缀和最小值是多少。每一个小段都可以算出后缀和的贡献，然后我们就O(M+sigma(Si))可以求出这个值，假设是-k。那么最终答案就是k-1

代码实现：

```cpp
#include<bits/stdc++.h>
#define ll long long
#define N 100005
using namespace std;
ll tot=0,n,m,pd,tans,ans;
ll b[N],p[N],maxp[N];
char s[2*N];
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++)
	{
		cin>>s+1>>b[i];
		int lens=strlen(s+1);
		for(int j=lens;j>=1;j--)
		p[i]+=(s[j]=='F'?-1:1),maxp[i]=max(p[i],maxp[i]);
		pd+=p[i]*b[i];//读入的同时进行操作 进行前缀后缀处理 见Kkk题解
	}
	if(pd>0){
		puts("-1");
		return 0;
	}//如果没有 输出-1
	tans=1;
	for(int i=m;i>=1;i--)
	{
		if(p[i]>0) tans=max(tans,ans+(b[i]-1)*p[i]+maxp[i]);//计算
		else tans=max(tans,ans+maxp[i]);
		ans+=p[i]*b[i];
	}
	printf("%lld",tans-1);//如kkk所说，输出要-1
	return 0;
}
```
希望对大家有帮助 Davidjing Orz

---

## 作者：封禁用户 (赞：11)

[原博客](https://blog.csdn.net/qq_42101694/article/details/103738357)

# 思路
感谢[@kkksc03 的博客](https://www.luogu.com.cn/blog/kkksc03/solution-p3615)提供了思路；感谢[@哔哩哔哩 的博客](https://www.luogu.com.cn/blog/fsy2017/solution-p3615)提供了代码。

$2n$ 个人，只有 $n$ 分钟，所以 __每一分钟，两个厕所都在使用中__。

简化题意：操作 $n$ 次，每次拿出两个等待队列的元素删掉。删掉的规则：

- 一定要删掉队列头。
- 如果队头是 $M$ ，则再删去第一个 $F$ （毕竟两个绅 ♂ 士不能共同如厕）。
- 如果队头是 $F$ ，则再删去新的队头（反正还剩一个公用厕所）。


我们的目的是，每次都能成功的删去两个元素。

有几个很显然的结论（但是很重要）：

- __不会有两个男性同时如厕__（我相信这些绅 ♂ 士都是洁身自好的）。
- __只有情况一可能导致失败__（因为情况二是直接删去最前面的两个元素，只要有元素剩余，就一定可以成功删去；而情况一要求后面还有一个 $F$ ）。

#### 结论一
这句话很简单：__如果队列中男多女少，那么失败__。这是很显然的——毕竟不会同时删去两个 $M$ ，男女比例只会愈发失调。

更有意思的是，__如果会失败，那么一定在某一瞬间出现了男多女少的状况__。根据`显然结论二`，失败时一定是情况一，即：队头是男性，但后方没有女性了。这不就是男多女少的情况嘛！

#### 结论二
如果存在一个后缀，满足男性的数量$=$女性的数量$+2$，那么一定不能成功的如厕。

> 注：如果存在一个后缀，满足男性的数量$\ge$女性的数量$+2$，那么也一定存在一个后缀，使其取等。

试着去证明它吧。考虑一个这样的后缀，它一定是以 $M$ 作为第一个；否则可以将其起始端点右移。

对于队头的 $M$ ，他可能会与之前的某个 $F$ 一同从队列里删去，也可能和后方的 $F$ 一起如厕（~~不要往奇怪的方面想~~）。无论哪种情况，都要注意到这一点：__剩下的人，一定是男多女少__——原本有 $x+2$ 个男性、$x$ 个女性，第一个男性离开后，剩下的数量为 $\langle x+1,x\rangle$ 或者 $\langle x+1,x-1\rangle$ ——`结论一`中已经说了，男多女少，是一定无法完成任务的。

#### 结论三
如果不存在一个后缀，满足男性的数量$=$女性的数量$+2$，那么一定可以成功的如厕。

试着去证明它吧。为了方便论述，我们讨论男性数量$-$女性数量的值——它只要一直不等于$2$，就可以成功如厕。

一开始一定有至少一个女性（否则男$-$女$\ge 2$），所以不会一来就失败。如果队头是女性，没有任何分析的意义：从队头直接拿走两个，对于剩下元素的后缀没有改变。所以我们分析队头是男性的情况。如图。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20191227194352406.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTAxNjk0,size_16,color_FFFFFF,t_70)
操作之后，对于$F$右边的，男$-$女没有发生变动。我们只需要考虑红色的部分（注意：它们都是$M$；这是由操作的要求规定的：第一个$F$）。

正如我用黑笔所写的差，由于它们忘掉了队头的$M$（导致$cnt_M$减小），红色部分原本的差一定$<x-y$（即队头的值）；$F$的离开又让$cnt_F$减小了$1$，所以差增大了一。最终，这个差$\le x-y<2$，所以我们得到的仍然是一个满足条件的队列。

也就是说，对于一个满足该条件的序列，第一次操作不会失败，并且操作后仍然满足条件。所以最终可以成功的完成如厕任务。

#### 总结结论
总结一下：__将男性设为$1$、女性设为$-1$，只需控制后缀和一直小于$2$__（也就是充要条件）。

#### 改变序列
你至少得发现这一点：__同一种性别之间的内部顺序不发生变化__。因为不愉快度就是逆序对，将其交换，逆序对只会更少，并且仍然是合法的队列。

一定要注意，我们要最小化的是不愉快度的最大值，而非其总和。

假设当前的序列不能完成任务，那么我们就要试着去调整它。考虑每次调整一个男性的位置。

我们实行如下策略：找到最后一名男性，将其往前移动，直到遇到另一名男性。然后这一名男性继续前移……直到某一名男性走到队伍的最前。

显然，男性之间的相对位置不会改变，女性也只会被某一个原本在后方的男性超过。所以此时的不愉快度的最大值恰好增大$1$（这里的增量是不可避免的：只消考虑一下最前方的女性即可）。

发现这样的操作相当于将最后方的$M$移动到了队列最前方，后缀和（除了队头和最后方的一段连续的 $F$ ）整体减小一：$cnt_M$减少了一嘛。

最后一段连续的 $F$ 没必要特殊考虑：我不信一个负数会大于等于$2$；队头也无需特殊考虑：如果队头都不满足条件，就可以直接说拜拜了（所以说要记得特判）。

所以我们到底要调整多少个男性呢？其实就是$(\max sum)-1$呗——把$(\max sum)$调整为$1$.

当然咯，答案至少是$0$嘛（不然操作$-1$次是什么东西？时光倒流？）。然后就没了。

# 代码
```cpp
#include <cstdio>
#include <iostream>
#include <vector>
#include <cstring>
using namespace std;
inline long long readint(){
	long long a = 0; char c = getchar(), f = 1;
	for(; c<'0' or c>'9'; c=getchar())
		if(c == '-') f = -f;
	for(; '0'<=c and c<='9'; c=getchar())
		a = (a<<3)+(a<<1)+(c^48);
	return a*f;
}
inline void writeint(long long x){
	if(x < 0) putchar('-'), x = -x;
	if(x > 9) writeint(x/10);
	putchar(x%10+'0');
}

const int MaxN = 100005;
long long k[MaxN], n, sum[MaxN], maxSuf[MaxN], m;
char s[MaxN<<1];

int main(){
	n = readint(), m = readint();
	for(int i=1; i<=m; ++i){
		scanf("%s",s), k[i] = readint();
		for(int len=strlen(s),j=len-1; ~j; --j){
			int val = (s[j] == 'F' ? -1 : 1);
			sum[i] += val; // [j,len)的后缀和
			maxSuf[i] = max(maxSuf[i],sum[i]);
		}
	}
	long long ans = 1, suf = 0;
	for(int i=m; i; --i){
		if(sum[i] > 0) // 把k次全部累计进去
			ans = max(ans,suf+(k[i]-1)*sum[i]+maxSuf[i]);
		else // 只留下最后一个的后缀
			ans = max(ans,suf+maxSuf[i]);
		suf += sum[i]*k[i]; // 后方所有的后缀之和
	}
	if(suf >= 2) // 总和都不满足
		puts("-1");
	else // 输出的是 max 后缀和 - 1 的值
		writeint(ans-1), putchar('\n');
	return 0;
}
```

---

## 作者：KemononeRou (赞：5)

调了一下午 + 一晚上结果发现是把 M 的个数当成字符串长度来算了/youl

这是一个复杂度很垃圾的做法，但是我感觉很容易想到（

容易发现 M 只能跟 F 一起走，而两个 F 可以一起走。

因此每走一个 M 就会少一个 F，在 $n$ 分钟内走不完就相当于 M 走的时候没有 F 了。

所以要让 M 先走，留下 F 后走。

记 $\text{Mcnt}$ 为 M 的总个数，$\text{Fcnt}$ 为 F 的总个数。

那么要有 $\text{Mcnt}$ 个 F 留下来跟 M 一起走，剩下的 $\text{Fcnt}-\text{Mcnt}$ 个 F 随意。

无解的情况就是 $\text{Mcnt}>\text{Fcnt}$。

一个很显然的贪心就是把最后的一些 M 丢到最前面，答案就是被移动的 M 的个数。

注意到放到前面的越多越容易满足条件，所以可以二分答案。

考虑判断从最后丢 $mid$ 个 M 到前面后是否可行。

记 $\text{Mpre}_i$ 为前缀 $i$ 中 M 的个数，$\text{Fpre}_i$ 同理。

那么当存在一个 $i$ 使得 $\text{Mcnt}-\text{Mpre}_i>\text{Fcnt}-\text{Fpre}_i$ 时就不行。

因为此时剩余的 M 个数多于剩余的 F 个数，M 走不完。

移一下项就是 $\text{Fpre}_i-\text{Mpre}_i>\text{Fcnt}-\text{Mcnt}$。

那么就是要满足 $\max \{\text{Fpre}_i-\text{Mpre}_i\} \leq \text{Fcnt}-\text{Mcnt}$。

$\text{Fpre}_i-\text{Mpre}_i$ 实际上是将 F 当作 1，M 当作 -1 后的前缀和。

注意到每次都是两个一起走的，所以只要看 $i$ 为偶数时是否满足条件。

40pts 的代码十分好写，只要把最终的字符串搞出来就行了。

100pts 的代码因为 $n$ 很大所以不能直接把字符串搞出来。

考虑找出最后一个 M 的位置，那么只要考虑它之前的字符串即可，因为它后面全是 F。

需要找出它在哪一个串的哪一次拼接的哪一个位置。

假设它是在第 $\text{p}$ 个串的第 $\text{t}$ 次拼接的 $\text{pos}$ 位置。

然后整个字符串可以看成 $1\sim \text{p}-1$ 的所有串的所有拼接 + 第 $\text{p}$ 个串的 $\text{t}-1$ 次拼接 + 第 $\text{p}$ 个串的前 $\text{pos}$ 位组成的字符串。

先判断完整出现的串是否可行。

记 $\text{Pre}$ 表示当前的前缀和。

记 $\text{sum}_i$ 表示第 $i$ 个字符串将 F 换成 1，M 换成 -1 后的和。

记 $\text{tim}_i$ 表示第 $i$ 个字符串在当前的串里面出现的次数。

如果 $\text{sum}_i<0$，那么最大值只可能出现在第一次拼接中。

先暴力跑一遍前缀和，然后再将剩下的 $\text{tim}_i-1$ 次的贡献算上即可。

$\text{sum}_i>0$ 时同理，最大值只可能出现在最后一次拼接中。

然后再暴力跑一遍最后一个没有完整出现的串（最后一个 M 所在的串），求个前缀和即可。

[40pts Code](https://www.luogu.com.cn/paste/eu0esx6j)

[100pts Code](https://www.luogu.com.cn/paste/k4tyz73n)

因为复杂度带个 $\log$ 的原因拿到了最裂解！

---

## 作者：ShwStone (赞：5)

## toilet

### 思路分析

为了 $n$ 分钟之内结束，两个厕所一刻都不能停。由于男生不能进女厕，所以一个男生必须要和一个女生一起才能上厕所（奇怪啊）。如果把男生视为 $1$，女生视为 $-1$，那么对于任意位置，后缀和必须要小于等于 $1$ 才能保证成功。（后缀和为 $1$ 时多出来的那个男生可以跟着他之前的女生走）。

如果出现了后缀和大于 $1$ 怎么办呢？就需要把一些男生放到前面去。如果累计的男生个数有 $x$ 个，则至少要放 $x-1$ 个到女生前面，则答案应该对 $x-1$ 取 $\max$。

这样的话，考虑从后往前扫描字符串，用一个变量来存储后缀和，当后缀和大于 $1$ 时，更新一下答案。

然后考虑怎么处理重复字符串。容易想到，重复的字符串对于后缀和的影响是相同的，并且无论影响是正是负，对答案有影响的只有可能是第一个串和所有串连在一起。所以维护一个字符串产生的后缀和变化量 $delta$ 以及变化过程中的最大变化量 $maxdelta$，如果一共重复 $t$ 次，并且在这个字符串之前的后缀和是 $cnt$，那么在这些重复的字符串中，最大后缀和是 $\max(cnt+maxdelta, cnt+maxdelta+delta\times(t-1))$，而对总后缀和的影响是 $cnt \leftarrow cnt + delta\times t$。

最后看一下无解：如果总后缀和最终大于 $0$（$1$ 也不行，如果是 $1$ 第一个男生无法上厕所），说明男生过多了，则输出 $-1$。否则输出过程中的最大后缀和减一。

### AC 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

// #define FILE_IO
namespace io {...};
using namespace io;

const int maxm = 1e5 + 5;

long long n, ans;
int m;
string s[maxm];
long long t[maxm];

int main() {
    // freopen("toilet.in", "r", stdin);
    // freopen("toilet.out", "w", stdout);
    read(n); read(m);
    for (int i = 1; i <= m; i++) {
        cin >> s[i];
        read(t[i]);
        reverse(s[i].begin(), s[i].end());
    }
    long long cnt = 0;
    for (int i = m; i >= 1; i--) {
        
        long long delta = 0, mxc = 0;
        for (int j = 0; j < s[i].size(); j++) {
            if (s[i][j] == 'F') delta--;
            else delta++;
            mxc = max(mxc, delta);
        }
        ans = max(ans, mxc + cnt);
        ans = max(ans, mxc + cnt + delta * (t[i] - 1));
        cnt += delta * t[i];
    }
    if (cnt > 0) write(-1);
    else if (ans > 1) write(ans - 1);
    else write(0);
    return 0;
}
```

---

## 作者：pomelo_nene (赞：4)

$\ \ \ \ \ \ $因为这道题我们的序列是复读给出来的，所以很长，不会想到把序列还原。

$\ \ \ \ \ \ $考虑我们的时间和我们的人，因为有$2n$个人只有$n$分钟，所以每时每刻厕所必须有人蹲坑。

$\ \ \ \ \ \ $于是乎，我们可以倒推回去，我们就能够想到后缀和，把男生设为$1$，女生设为$-1$，进行一次后缀和。   
$\ \ \ \ \ \ $我们惊奇地发现如果我们的后缀和在某一时刻发生了值是大于等于$2$，那么只有两个男生考虑一起上了，这时直接输出$-1$。

$\ \ \ \ \ \ $这么说，我们能够发现我们要让队列合法，当且仅当$i \in [1,n]$，从后往前的第$i$个女生在从后往前的$2i$个位置及以外。

$\ \ \ \ \ \ $然后考虑计算我们的答案。我们还是选择倒推。当前如果我们遇到一个女生在从后往前的第$i$个位置，我们发现把她移到从后往前第$2i$个位置是最优的（因为没人站她的位置，并且如果更远，答案越大），我们就可以$\Theta(n)$计算答案

$\ \ \ \ \ \ $正如kkk所说的

>我们可以画一个折线图，记录后缀和曲线（请读者自备纸笔），从后往前。我们可以发现，每将一个男的移动到前面去，折线图就会整体往上面移动1。所以说，我们只要计算整个序列中后缀和最小值是多少。每一个小段都可以算出后缀和的贡献，然后我们就$\Theta(M+\sum^n_{i=1} (S_i))$可以求出这个值，假设是$-k$。那么最终答案就是$k-1$。

$\ \ \ \ \ \ $于此，我们将从后往前数的第$i$个女生匹配在第$2i$个位置，当前处理的长度为$a$的，其中女生有$b$个的话，对于每次$repeat$，我们匹配的位置也会相对移动$2b-a$

$\ \ \ \ \ \ $我们只需要计算最大不满值，如果$2b-a>0$考虑第一次$repeat$，否则考虑最后一次

$\ \ \ \ \ \ $时间复杂度$\Theta(m+\sum_{i=1}^n)$，至此我们的题目完美解决

```cpp
#include<cstdio>
#include<algorithm>
#include<string>
#include<iostream>
#include<cstring>
using namespace std;
string p;
long long bak[100005],mbak[100005],cnt=1,k[100005];
int main(){
	long long n,m;
	cin>>n>>m;
	long long check=0;
	for(long long i=1;i<=m;++i)
	{
		cin>>p>>k[i];
		for(long long j=p.length()-1;~j;--j)
		{
			if(p[j]=='F')	--bak[i];
			else	++bak[i];
			mbak[i]=max(mbak[i],bak[i]);
		}
		check+=bak[i]*k[i];
	}
	if(check>0)
	{
		cout<<-1;
		return 0;
	}
	long long ans=1,calc=0;
	for(long long i=m;i>=1;--i)
	{
		if(bak[i]>0)	ans=max(ans,calc+(k[i]-1)*bak[i]+mbak[i]);
		else	ans=max(ans,calc+mbak[i]);
		calc+=bak[i]*k[i];
	}
	cout<<ans-1;
	return 0;
}
```

---

## 作者：神之蒟蒻xyk (赞：2)

某校校内训练题。。。

思路其实差别不大，转化模型：一个队列，每次删除最前面的人及最前的女生。

2N人，N时间，能想到：从后往前的第i个女生的实际位置如果在2i（从后往前）之前，则不能实现，于是贪心将该女生放到第2i个位置。

直接贴标算：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define MN 100000
string s[MN+5];long long n,l,ans,t[MN+5];
void solve(string&s)
{
	for(int i=s.size();i--;--l)
		if(s[i]=='F'&&n)ans=max(ans,2*--n+1-l);
}
int main()
{
	int m,i,j,x;
	cin>>n>>m;l=2*n;
	for(i=1;i<=m;++i)cin>>s[i]>>t[i];
	for(i=m;i;--i)
	{
		for(j=x=0;j<s[i].size();++j)if(s[i][j]=='F')++x;
		if(2*x>=s[i].size())
		{
			solve(s[i]);
			l-=(t[i]-1)*s[i].size();
			if((n-=(t[i]-1)*x)<=0)break;
		}
		else if(x*t[i]<n)
		{
			l-=(t[i]-1)*s[i].size();
			n-=(t[i]-1)*x;
			solve(s[i]);
		}
		else
		{
			long long k=(n+x-1)/x;
			if(k>1)l-=(k-2)*s[i].size(),n-=(k-2)*x,solve(s[i]);
			solve(s[i]);
			break;
		}
	}
	printf("%lld",n>0?-1:ans);
}
```


---

## 作者：ZnPdCo (赞：0)

采用 [loj](https://loj.ac/p/2734) 题面，更有趣。

首先容易观察到因为是 $2N$ 个人，$2$ 个发放点，$N$ 的时间限制，所以每时每刻每个点都必须有人。也就是不能有发放点空着。

如果队首是女装大佬的话，她肯定不会等的，因为只要空了**就可以进**。如果是正常男生的话，**如果进不了**，就会让给后面的**女装大佬来进**，但是如果后面没有女装大佬，那就女生位置就空了。所以没办法了，~~这个正常男生只能变成女装大佬了。~~

就是我们把正常男生看成 $-1$，**女装大佬是** $\bf{1}$，每个后缀的和不能为 $-2$，不然就会出现两个正常男生选择一个变成女装大佬。

这时候如果你强硬地去维护，也是可以做出来的，但是不够优美。考虑一种优美的实现方法。

对于一个后缀如果和为 $-2$ 了，我们需要将后缀最前面的正常男生移动到一个女装大佬**正前面**，如果两个移动：$a\larr b$，$c\larr d$ 满足一个包含另一个，那么中间的元素会产生 $2$ 的贡献。也就是说我们的移动嵌套最大数量就是答案。另一方面，也就是设最小的后缀和为 $-k$，答案就是 $k-1$，为什么要减一，因为后缀和为 $-1$ 就行了。

当然你可能发现还有一种移动方法就是女装大佬移动到正常男生前面，那这样代价就和移动距离有关，发现因为前者的代价是嵌套层数，这个数是小于等于距离的，所以这么做肯定不优。

关于 $-1$ 的判法，要求女装大佬数量不比正常男生少，不然肯定有男生要变女装大佬。

```cpp
#include <bits/stdc++.h>
#define N 100010
#define ll long long
using namespace std;
ll n, m, k[N], z[N], ans = -1, pre;
string s[N];
int main() {
    z['M'] = -1, z['t'] = 0, z['F'] = 1;
    cin >> n >> m;
    for (int i = 1; i <= m; i++) cin >> s[i] >> k[i], reverse(s[i].begin(), s[i].end());
    for (int i = m; i >= 1; i--) {
        ll sum = 0, mn = 0;
        for (char c : s[i]) sum += z[c], mn = min(mn, sum);
        if (sum < 0) {
            pre += sum * (k[i] - 1);
            ans = min(ans, pre + mn);
            pre += sum;
        } else {
            ans = min(ans, pre + mn);
            pre += sum * k[i];
        }
    }
    cout << ((pre < 0) ? -1 : (-ans - 1)) << endl;
}
```

---


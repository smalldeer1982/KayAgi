# [湖南集训] Hungry Rabbit

## 题目描述

可怕的洪水在夏天不期而至，兔子王国遭遇了前所未有的饥荒，它们不得不去外面的森林里寻找食物。

为了简化起见，我们假设兔子王国中有 $n$ 只兔子，编号为 $1$ 到 $n$。在救济粮到来之前的 $m$ 天中，每天恰好有 $k$ 只兔子需要去森林里寻找粮食。森林里居住着可怕的大灰狼，所幸兔子已经摸清了大灰狼捕食习惯，即狼们在每一天只会捕食特定编号的兔子。为了安全起见，兔子们需要保证每次出去觅食的 $k$ 只兔子都不会被狼捕食。

由于每天出去捕食的兔子都不尽相同，它们为每一天定义了一个生疏度 $p_i$ ，即第 $i$ 天出来寻找食物，但是第 $i−1$ 天却没有出来觅食的兔子个数。规定第 $1$ 天的生疏度为 $0$。

现在兔子们希望在保证安全的前提下，每天的生疏度不能超过 $l$，请为兔子们构造一个合法的方案。

## 说明/提示

#### 样例 1 解释

对于样例，在这 $4$ 天中，出去觅食的兔子集合分别为 $\{2, 3, 4\}; \{2, 3, 4\}; \{3, 4, 5\}; \{2, 3, 5\}$。

---

#### 数据规模与约定

- 对于 $20\%$ 的测试数据，保证 $1\leq n,m\leq 10$；
- 对于 $100\%$ 的测试数据，保证 $1\leq n,m\leq 800,$，$1\leq k\leq n$，$1\leq l\leq k$。

## 样例 #1

### 输入

```
5 4 3 1
1001
1101
1111
1110
0111```

### 输出

```
2 3 4
2 3 4
3 4 5
2 3 5```

# 题解

## 作者：学无止境 (赞：5)

$update:$ $2019.8.6$

之前出了一个小锅 , 导致程序会忽略一些无解的情况 , 已改正(是我太菜了)

鸣谢右侧评论区的各位大佬让我意识到的我的问题.    $orz$
______________________________________________________________
## 正文:

既然你看到了这里，先猜猜解法是什么？（不否认其他解法的存在）

### 贪心

贪心 $max$ 级别难度的题目（不明白为什么$6000ms$，贪心只用了$500$多$ms$就 $AC$ 了）。

**（1）** 每轮判断根据 **（3）**，只要能出门（对应 $days[ $   $ ][ $   $ ]$ 大于零且上次没出门）就加入序列 $being[ $    $ ]$ 

> $PS:$上次出门的在 $ been[ $   $ ]$ 中，我们之所以不选，是因为我们就是以been为基础选当前的兔子（因为生疏度不能太高），再贪心，将本轮选出的上次未出门且对应 $ days[ ][ ] $ 与大于 $ been[ ] $ 中兔子对应 $ days[ $   $ ][ $   $ ] $ 较小的交换 $ / $ 或直接赋值（因为贪心的法则，优先选天数多的加入）

**( 2  )** 我们要让哪些兔子去第i轮，因为有l（生疏度）这个玩意，所以**优先选i-1去过的**（第一轮特殊处理）

**( 3 )** 其次我们定义一个二维数组 $days[ $  $ ][ $   $ ]$ ,来存每天每只兔子从当天开始可以连续出去觅食几天而不死掉，我们优先选对应天开始出去天数多的（因为之后不能生疏度过低，要保证兔子可以连续出门），所以要排序，这里**我们将天数多的往前排。**

**（4）** 但我们会发现一个问题，从$ i-1$ 的决策中筛选第i天会有一个尴尬情况——有的兔子出不了门，那么我们就以 **( 3 )** 的标准，从$ i-1$ 天出门兔子序列后往前判断（排过序了，靠后兔子的可连续出门天数少，最可能会死），此时就用 **( 1 )** 中 $PS$ 说的方法，替换值，但是注意，不止替换会死的，还替换天数少的（在生疏度范围内）

什么时候输出 $-1$ 呢？在没有 $been$ 的第一天，我们判兔子够不够，其余判断时就看有没有 $0$ 在里面（有就代表选不出来）

可能大部分人看到这里还是蒙的，可以先看代码，多花点心思想想，结合上面的说明慢慢就理解了。


**Code：**
```
#include<iostream>
#include<cstring>
#include<algorithm>
#include<cstdio>
using namespace std;
int n,m,k,l,been[810],being[810],isit[810],days[810][810],ans[810][810],q;//days存从当天开始天兔子可持续觅食的天数 
char wolf[810][810];

bool cmp(int a,int b)
{
    return days[q][a]>days[q][b];//排序规则：将天数多的往前放，q是全局变量 
}

inline char _getchar()
{
	register char c=getchar();
	while(!isdigit(c))
		c=getchar();
	return c;
}

int main()
{
    scanf("%d%d%d%d",&n,&m,&k,&l);
    for(register int i=1;i<=n;i++)
    	for(int j=1;j<=m;j++)
    		wolf[j][i]=_getchar(); //读入狼捕杀兔子的表，注意是char！不能用int，因为中间没有空格 
    for(register int i=m;i>0;i--)
    	for(register int j=1;j<=n;j++)
    		if(wolf[i][j]=='1')   
    			days[i][j]=days[i+1][j]+1;
    		else    
    			days[i][j]=0;//处理出每天对应兔子从对应天开始最大连续出门天数 
    for(q=1;q<=m;q++)//m天 
    {
        register int u=0;//u代表选出来的上次没出门的且这次可以出门的兔子个数 
        for(register int i=1;i<=n;i++)
        	if(days[q][i]&&!isit[i])
        		being[++u]=i; //being存上次没出门的且这次可以出门的兔子序列 
        sort(being+1,being+1+u,cmp);//将其排序，便于贪心 
        if(q==1)//在第一天，没有been，特判 
        {
            if(u<k)//兔子不够就输出-1，return 0; 
            {
                printf("-1\n");
                return 0;
            }
        }
        else//除第一天外 
        {
            register int i;
            sort(been+1,been+1+k,cmp);//been因为值被操作了，所以每次要排序 
            for(i=1;i<=u&&i<=l;i++)//既要满足生疏度，也要满足在下标范围内（小于等于u） 
            	if(days[q][being[i]]>days[q][been[k-i+1]])//在生疏度范围内，从being中由大致小判断能不能替换been中天数少的兔子————贪心法 
            		been[k-i+1]=being[i];//能就换 
            if(i!=k+1&&!days[q][been[k-i+1]])//最后（如果换了）换的是been[k-i+1]，它非零整个been序列也非零，但要加上i!=k+1，应对 l==k或u==k的情况，这时k-i+1=0，那么瞬间爆炸（忽略这一点会WA第一个点） 
            {
                printf("-1\n");
                return 0;
            }
            swap(been,being);//要存答案了，交换后答案在being （交换的原因：下面还要换（除q==1的特判）） 
        }
        memset(isit,0,sizeof(isit));//isit存上次去的兔子 
        for(register int i=1;i<=k;i++)
        	isit[being[i]]=1,ans[q][i]=being[i];//这次去了，isit对应为1，并存答案 
        swap(been,being); //每天结束后当前的 being就是下一天的been 
    }
    for(register int i=1;i<=m;i++)//输出不解释 
    {
        for(register int j=1;j<=k;j++)
        	printf("%d ",ans[i][j]);
        printf("\n");
    }
    return 0; 
} 
```

---

## 作者：麻省理工学院 (赞：4)

没人写网络流做法的题解啊。。。

口胡一下吧

## **正文**

按天建分层图，两天之间一只兔子如果都可以出行，就直接连向下一天，所有上一天能出行的就连向下一个转换点，转换点拆一下就好了，限制流量为L，拆成两个也是为了限制流量。一个兔子不可以即走转换点又直接走向下一天，所以兔子也拆点限制一下流量为 1 即可。总流量 k 只要将源点拆点限制流量为 k 即可。每只兔子向中转点连边，中转点再向下一天的每只兔子连边，表示可以换L只兔子。

时间复杂度$O(\text{玄})$

可能需要高标预留推进？~~反正是口胡的我不管~~

需要极其高深的算法~~及卡常技巧~~

对于网络流来说，其实是一道不错（~~毒瘤~~）的题

---


# [JXOI2018] 排序问题

## 题目背景

九条可怜是一个热爱思考的女孩子。

## 题目描述



九条可怜最近正在研究各种排序的性质，她发现了一种很有趣的排序方法： Gobo sort ！

Gobo sort 的算法描述大致如下：

- 假设我们要对一个大小为 $n$ 的数列 $a$ 排序。
- 等概率随机生成一个大小为 $n$ 的排列 $p$ 。
- 构造一个大小为 $n$ 的数列 $b$ 满足 $b_i=a_{p_i}$ ，检查 $b$ 是否有序，如果 $b$ 已经有序了就结束算法，并返回 $b$ ，不然返回步骤 2。


显然这个算法的期望时间复杂度是 $O(n\times n!)$ 的，但是九条可怜惊奇的发现，利用量子的神奇性质，在量子系统中，可以把这个算法的时间复杂度优化到线性。

九条可怜对这个排序算法进行了进一步研究，她发现如果一个序列满足一些性质，那么 Gobo sort 会很快计算出正确的结果。为了量化这个速度，她定义 Gobo sort 的执行轮数是步骤 2 的执行次数。

于是她就想到了这么一个问题：

现在有一个长度为 $n$ 的序列 $x$ ，九条可怜会在这个序列后面加入 $m$ 个元素，每个元素是 $[l,r]$ 内的正整数。 她希望新的长度为 $n+m$ 的序列执行 Gobo sort 的期望执行轮数尽量的多。她希望得到这个最多的期望轮数。

九条可怜很聪明，她很快就算出了答案，她希望和你核对一下，由于这个期望轮数实在是太大了，于是她只要求你输出对 $998244353$ 取模的结果。

## 说明/提示

###样例解释

对于第一组数据，我们可以添加 $\{1,2,2\}$ 到序列的最末尾，使得这个序列变成 `1 3 4 1 2 2` ，那么进行一轮的成功概率是 $\frac{1}{180}$ ，因此期望需要 $180$ 轮。

对于第二组数据，我们可以添加 $\{5,6,7\}$ 到序列的最末尾，使得这个序列变成 `1 3 4 5 6 7` ，那么进行一轮的成功概率是 $\frac{1}{720}$ ，因此期望需要 $720$ 轮。

### 数据范围

对于 30% 的数据， $T\leq 10 , n,m,l,r\leq 8$。  
对于 50% 的数据， $T\leq 300,n,m,l,r,a_i\leq 300$ 。  
对于 60% 的数据， $\sum{r-l+1}\leq 10^7$ 。  
对于 70% 的数据， $\sum{n} \leq 2\times 10^5$ 。  
对于 90% 的数据， $m\leq 2\times 10^5$。  
对于 100% 的数据， $T\leq 10^5,n\leq 2\times 10^5,m\leq 10^7,1\leq l\leq r\leq 10^9$ ， $1\leq a_i\leq 10^9,\sum{n}\leq 2\times 10^6$ 。

## 样例 #1

### 输入

```
2
3 3 1 2
1 3 4
3 3 5 7
1 3 4```

### 输出

```
180
720
```

# 题解

## 作者：Ebola (赞：16)


### 吐槽

样例解释真的给了我很大的提示。我的期望学的不好，结果样例解释直接就告诉了我轮数期望就是一次成功概率的倒数，这一点吉老师真的很良心了

然后本题的两个关键结论，我在考场上真的全都想到了，但当时代码能力实在是差，套路又学的不够多，导致想到了结论都不知道怎么做

### 题解

从简单的开始想起。若数列中有$cnt$个最小值，那么这些最小值可以放在$1$到$cnt$之间的任意位置，于是它们有$cnt!$种可行排列方式。再用一样的方式去考虑其它的值。那根据乘法原理，一次成功的概率显然就是$\frac{\prod cnt_x!}{n!}$

然后感谢吉老师的样例解释，让我知道了期望就是它的倒数：$\frac{n!}{\prod cnt_x!}$

于是现在我们的任务就是让$cnt_x!$的乘积尽可能小，这样期望才会尽可能大

于是不难想到贪心。每次选$cnt$最小的数$x$，把它加入数列，并更新答案

选最小数？难不成用堆？不行！插入的次数达到了$10^7$的级别，再加之有$10^5$组询问，我们的复杂度甚至不能和$m$扯上半毛钱关系，否则就只能拿到$50$分的暴力分了！

考虑把原数列离散化。然后对于区间$[l, r]$内的数$x$，将它的$cnt$保存下来，然后将保存下的所有$cnt$排个序。这样我们就可以从左往右扫$cnt$数组，对于第$i$个$cnt$，我们将$cnt_i$及其前面的所有$cnt$填平到$cnt_{i+1}$的高度，答案也就需要乘上$\left(\frac{cnt_{i+1}!}{cnt_i!}\right)^i$，预处理阶乘及其逆元，再写一个快速幂即可

当然，并不是要一直填平。若继续填平会导致操作次数大于$m$，显然需要停止。设$c$为此时剩余操作次数，此时只要填平到$\left\lfloor\frac{c}{i}\right\rfloor$的高度就可以了，然后再处理一下剩余的$c\mod i$次操作即可

考虑到$l$和$r$的跨度可能比较大，中间可能会有很多元素是原数列里没有的，所以我们计算出$[l, r]$中在原数列里没有出现的元素数量$s$，在排序后的$cnt$数组头部加一个$0$，并且给它附上一个系数$s$即可

记住不要每次询问都把$cnt$数组整个memset一遍，否则复杂度会退化成$O(T\times 10^5)$。只需清空$cnt$数组的前$n$个元素即可。

```cpp
#include<bits/stdc++.h>
using namespace std;

namespace IO
{
    const int S=(1<<20)+5;
    char buf[S],*H,*T;
    inline char Get()
    {
        if(H==T) T=(H=buf)+fread(buf,1,S,stdin);
        if(H==T) return -1;return *H++;
    }
    inline int read()
    {
        int x=0;char c=Get();
        while(!isdigit(c)) c=Get();
        while(isdigit(c)) x=x*10+c-'0',c=Get();
        return x;
    }
    char obuf[S],*oS=obuf,*oT=oS+S-1,c,qu[55];int qr;
    inline void flush(){fwrite(obuf,1,oS-obuf,stdout);oS=obuf;}
    inline void putc(char x){*oS++ =x;if(oS==oT) flush();}
    template <class I>inline void print(I x)
    {
        if(!x) putc('0');
        if(x<0) putc('-'),x=-x;
        while(x) qu[++qr]=x%10+'0',x/=10;
        while(qr) putc(qu[qr--]);
    }
}

using namespace IO;
const int N=200010;
const int M=10200010;
const int ha=998244353;
int n,m,l,r,cnt[N],sum[N];
int a[N],Hash[N],hs;
int fac[M],ifac[M];

int Pow(int a,int b)
{
    int ans=1;
    for(;b;b>>=1,a=1ll*a*a%ha)
        if(b&1) ans=1ll*ans*a%ha;
    return ans;
}

void Init(int n)
{
    fac[0]=1;
    for(int i=1;i<=n;i++)
        fac[i]=1ll*fac[i-1]*i%ha;
    ifac[n]=Pow(fac[n],ha-2);
    for(int i=n-1;i>=0;i--)
        ifac[i]=1ll*ifac[i+1]*(i+1)%ha;
}

int main()
{
    Init(10200000);
    for(int T_T=read();T_T;T_T--)
    {
        n=read();m=read();l=read();r=read();
        memset(cnt,0,sizeof(int)*(n+5));
        memset(sum,0,sizeof(int)*(n+5));
        int all=fac[n+m],rest=r-l+1,ans=1;
        for(int i=1;i<=n;i++) Hash[i]=a[i]=read();
        sort(Hash+1,Hash+1+n);
        hs=unique(Hash+1,Hash+1+n)-(Hash+1);
        for(int i=1;i<=hs;i++) rest-=(Hash[i]>=l&&Hash[i]<=r);
        for(int i=1;i<=n;i++)
        {
            a[i]=lower_bound(Hash+1,Hash+1+hs,a[i])-Hash;
            if(Hash[a[i]]>=l&&Hash[a[i]]<=r) cnt[a[i]]++;
            sum[a[i]]++;ans=1ll*ans*sum[a[i]]%ha;
        }
        sort(cnt+1,cnt+1+hs);int zero=0;
        for(int i=1;i<=hs;i++) if(cnt[i]==0) zero=i;
        for(int i=1;i<=hs-zero;i++) cnt[i]=cnt[i+zero]%ha;
        n=hs-zero;
        for(int i=0;i<n;i++)
        {
            if(cnt[i+1]==cnt[i]) continue;
            if(1ll*(cnt[i+1]-cnt[i])*(i+rest)<=m)
            {
                m-=(cnt[i+1]-cnt[i])*(i+rest);
                int x=1ll*fac[cnt[i+1]]*ifac[cnt[i]]%ha;
                ans=1ll*ans*Pow(x,i+rest)%ha;
            }
            else
            {
                int x=m/(i+rest);
                int t=1ll*fac[cnt[i]+x]*ifac[cnt[i]]%ha;
                ans=1ll*ans*Pow(t,i+rest)%ha;
                ans=1ll*ans*Pow(cnt[i]+x+1,m%(i+rest))%ha;
                m=0;break;
            }
        }
        if(m>0)
        {
            int x=m/(r-l+1);
            int t=1ll*fac[cnt[n]+x]*ifac[cnt[n]]%ha;
            ans=1ll*ans*Pow(t,r-l+1)%ha;
            ans=1ll*ans*Pow(cnt[n]+x+1,m%(r-l+1))%ha;
        }
        ans=1ll*all*Pow(ans,ha-2)%ha;
        print(ans);putc('\n');
    }
    flush();
    return 0;
}
```



---

## 作者：Midvoy_尺 (赞：7)

看到白白胖胖的两个样例难道没有一点想法？

~~不会数学期望也糊弄得出答案的核心解法：~~

令$b_i$为$i$在最终的序列中出现的次数

则$ans=A^{n+m}_{n+m}\times\prod_{i} \frac{1}{b_i!}$

但难点在于如何快速求解：

技巧一 **阶乘预处理**

没什么好说的,应该都想得到~~线性求阶乘逆元~~把分母乘起来后用费马小定理求逆元

技巧二 **筛去固点**

在已知的$n$个点中排序

小于$l$或大于$r$的点提取出贡献

在$l$与$r$之间的存起来(存出现的次数)
```cpp
if(l<=a[i]&&a[i]<=r){
	mp[++tot]=1;
	while(a[i+1]==a[i]){mp[tot]++;i++;}
}else{
	int sum=1;
	while(a[i+1]==a[i]){sum++;i++;}
	ans=(ll)ans*inv[sum]%mod;
}
```
技巧三 **水往低处流**

存起来后数本身已经不重要,而数出现的次数是已知的信息

可以发现，共$m$次，每次增加的一定是出现次数最少的那些数字

$50pts$思路 **堆**

$100pts$思路

排完序后,数$i(i\in~[l,r])$的出现次数排成一个单增形状

此时想象有$m$滴水,水往低处流补在低洼处,符合我们的贪心思路

于是就把新数列分成水区(后$m$个数)与陆地(前$n$个数)(也可以~~水淹大陆~~没有陆地)

陆地:单独处理提取贡献

水区:由于可能剩余一些水无法布满当前的水面,于是将水区又划分为高度(代表次数)为$m/len(len$为水面宽度$)$和$len/m+1$两部分用快速幂求出贡献

在求解时可以把固定的次数(陆地)先化为可动的次数(水滴)
再尝试从右端最高处向左依次判断此时水面能否达到该处的固定次数,当能达到时,再往左一定水面高于原陆地,此时便是最优解的状态

```cpp
#include<bits/stdc++.h>
#define ll long long
#define MX 10200005
#define MXN 2000005
#define mod 998244353 
using namespace std;
int n,m,l,r;
int T;
int jc[MX];
int inv[MX];
int mp[MX],tot=0;
int a[MXN];
int ans=0,jcn=0;
int power(int x,int y){
	int sum=1;
	for(;y;y>>=1){
		if(y&1) sum=(ll)sum*x%mod;
		x=(ll)x*x%mod;
	}
	return sum;
}
void Init(){
	jc[0]=1;
	for(int i=1;i<=MX-3;++i){
		jc[i]=(ll)jc[i-1]*i%mod;
	}
}
int main(){
	//freopen("sort.in","r",stdin); 
	//freopen("sort.out","w",stdout);
	scanf("%d",&T);
	Init();
	while(T--){
		scanf("%d%d%d%d",&n,&m,&l,&r);
		int len=r-l+1;
		jcn=jc[n+m];
		for(int i=1;i<=n;++i) scanf("%d",&a[i]);
		a[n+1]=0;
		sort(a+1,a+n+1);
		tot=0,ans=1;
		for(int i=1;i<=n;++i){
			if(l<=a[i]&&a[i]<=r){
				mp[++tot]=1;
				while(a[i+1]==a[i]){mp[tot]++;i++;}
				m+=mp[tot];//将陆地化为水滴
			}else{
				int sum=1;
				while(a[i+1]==a[i]){sum++;i++;}
				ans=(ll)ans*jc[sum]%mod;//提取贡献
			}
		}
		sort(mp+1,mp+tot+1);
		for(int i=tot;i>=0;--i) {
			if(m/len>=mp[i]) {//水高于当前陆地
				ans=(ll)power(jc[m/len+1],m%len)*ans%mod*power(jc[m/len],len-m%len)%mod;
				break;
			}
			m-=mp[i];//水无法达到i处本需的高度,化为陆地
			--len;//减少水面宽度
			ans=(ll)ans*jc[mp[i]]%mod;//提取贡献
		}
		ans=(ll)power(ans,mod-2)*jcn%mod;//分母求逆元
		printf("%d\n",ans);
	}
	return 0;
}
```
口才不好,请原谅~~我在这瞎扯浪费大家时间~~

---

## 作者：SUPER_ZJC (赞：3)

这题并不难。

设最后构成的数列为 $a_1,a_2,\dots,a_{n+m}$ 中共有 $s$ 种不同的数字，从小到大第 $i$ 种数字共有 $cnt_i$ 个。

则答案为 $\frac{(n+m)!}{\prod_{i=1}^s cnt_i!}$。

可以发现，若存在 $i,j$，使得 $cnt_i+1>cnt_j$，那么令 $cnt_i\to cnt_i-1$，$cnt_j\to cnt_j+1$ 一定会更优。

所以可以发现选出的数的个数越平均答案会越大，考虑贪心。

考虑记 $num_i$ 表示满足 $l\leq x \leq r$ 且 $x$ 在初始的 $a$ 数组中恰好出现 $i$ 次的 $x$ 的个数之和。考虑从小到大枚举 $i$，每一次求出目前出现次数比 $i$ 小或相等的数的个数，记为 $sum$，那么将答案乘上 $\frac{1}{(i+1)^{\min(m,sum)}}$，同时将 $m$ 减去 $sum$。

可以发现这样求解是正确的，因为对于每一个 $i$ 相当于取出 $\min(m,sum)$ 个数使它们的出现个数加一，此时它们出现个数是所有数出现个数最少的，所以符合我们平均取数的贪心策略。

最后在枚举完 $i$ 后 $m$ 还可能会大于 $0$，直接算即可。

此时复杂度可以做到 $O(m+n\log n)$。

但我们不能止步于此，可以发现 $sum$ 只会在 $num_i \ne 0$ 的时候改变，而最多只会有 $O(\sqrt n)$ 个 $num_i \ne 0$，所以只需要考虑这些 $i$。

最终复杂度可以做到 $O(m+n\log \sqrt n)$。

---

## 作者：撤云 (赞：3)

点击食用效果更佳:[$blog$](https://www.cnblogs.com/hbxblog/p/10422957.html)

### $Solution$

#### $50\ pts$

我们来看一下题目,可以很容易的写出来答案的式子:

$$\frac{(n+m)!}{a_1!a_2!...a_{tot}!}$$

$a_1,a_2,...,a_{tot}$为$n+m$个数中不同的数出现的个数

那么$50$便很好想了.

我们现在要求的是期望轮数最多,所以${a_1!a_2!...a_{tot}!}$要尽量小

所以我们可以贪心求解,每次找出$[l,r]$中出现次数最少的数,找$m$次即可,这用个堆维护一下就好了

#### $100 \ pts$

我们还是需要${a_1!a_2!...a_{tot}!}$尽量小

于是我们可以二分出$a_1,a_2,...,a_{tot}$中的最小值的最大值，我们令这个值为$ans$

那么我们现在就可以知道了$a_1,a_2,...,a_{tot}$的分布

对于$>ans$的或不在[l,r]这个区间内的,直接将他们阶乘乘起来即可.

对于[l,r]内个数$<=ans$的,进行如下操作:

算出将[l,r]内个数$<=ans$的边成$ans$后剩下$m$个数还剩下几个.我们令这个数为$c$,[l,r]内去见个数$<=ans$的数有$k$个

我们将这$c$个数分成不同的$c$个插入数列即可.

所以现在的个数为:

$c$ 个个数为 $ans+1$    

$k-c$个个数为 $ans$

直接快速幂求,最后吧求的乘起来,用$(n+m)!$除他就好了.


### $Code$

``` cpp
#include<bits/stdc++.h>
#define int long long
#define rg register
#define file(x) freopen(x".in","r",stdin);freopen(x".out","w",stdout);
using namespace std;
const int mod=998244353;
inline int read(){
    int x=0,f=1;char c=getchar();
    while(c<'0'||c>'9') f=(c=='-')?-1:1,c=getchar();
    while(c>='0'&&c<='9') x=x*10+c-48,c=getchar();
    return f*x;
}
int n,m,tot,a[2000010],sum[2000010];
inline int check(int x,int len){
    int ans=0,flag=0;
    for(int i=1;i<=tot;i++){
        if(sum[i]>x)
            break;
        ans+=sum[i],flag=i;
    }
    int k=(len-tot+flag);
    return m-(k*x-ans);
}
inline int ksm(int a,int b){
    int ans=1;
    while(b){
        if(b&1)
            ans=ans*a%mod;
        a=a*a%mod,b>>=1;
    }
    return ans;
}
int jc[20000010];
main(){
    int T=read(),l,r;
    jc[0]=1;
    for(int i=1;i<=10200000;i++)
        jc[i]=jc[i-1]*i%mod;
    while(T--){
        n=read(),m=read(),l=read(),r=read(),tot=0;
        for(int i=1;i<=n;i++)
            a[i]=read();
        sort(a+1,a+1+n);
        int p=0,js=1;
        a[n+1]=-2147483647;
        for(int i=1;i<=n+1;i++){
            if(a[i]!=a[i+1]){
                if(a[i]<=r&&a[i]>=l)
                    sum[++tot]=i-p;
                else js=js*jc[(i-p)]%mod;
            p=i;
            }
        }
        sort(sum+1,sum+1+tot);
        int L=0,R=m+n,maxx=0;
        while(L<=R){
            int mid=(L+R)>>1;
            if(check(mid,(r-l+1))>=0)
                L=mid+1,maxx=max(maxx,mid);
            else R=mid-1;
        }
        int ans=0,flag=0,len=(r-l+1);
        for(int i=1;i<=tot;i++) {
            if(sum[i]>maxx) break;
            ans+=sum[i],flag=i;
        }
        int k=(len-tot+flag),c=m-(k*maxx-ans);
        for(int i=flag+1;i<=tot;i++) js=js*jc[sum[i]]%mod;
        js=js*ksm(jc[maxx+1],c)%mod,js=js*ksm(jc[maxx],k-c)%mod;
        printf("%lld\n",jc[n+m]*ksm(js,mod-2)%mod);
    }
    return 0;
}
```


---

## 作者：shadowice1984 (赞：3)

偷懒使了unordered_map结果t飞了……

事实证明手写hash表保平安……

_____________
### ~~(可以跳过的)~~前置芝士:离散随机变量的几何分布

~~如果对数学无感可以跳过此部分~~

对于一个离散型随机变量X，如果$P([x==k])=(1-p)^{k-1}p$(中k为正整数，$P([x==k])$表示x取k这个值的概率)的话

我们说这个离散型随机变量X服从**参数为p的几何分布**

一个比较实际的例子是不停的抛一个正面朝上概率为p的硬币，抛到正面之后立即停止，此时抛硬币的步数就**服从参数为p的几何分布**

那么扯这个玄学的东西有什么用呢？

因为如果一个随机变量服从几何分布，它的期望和方差就会非常非常的好算

那么让我们尝试着推导一发服从几何分布的随机变量的期望

## $E(X)=p\sum_{i=1}^{\infty}i(1-p)^{i-1}$

后边的东西是大家在高中数学中常见的等差数列乘等比数列求和的形式了

可以证明后边的式子是$\frac{1}{p^2}$

所以，服从几何分布的变量的期望出奇的好算……

## $E(x)=p\frac{1}{p^2}=\frac{1}{p}$

这里顺便给出服从参数为p的集合分布的离散型随机变量的方差(尽管和这道题关系不大就是了)

## $V(x)=\frac{1-p}{p^2}$


# 本题题解

先来证明一发期望运行次数到底怎么算

假设这个序列有x个合法的有序序列(比如说序列元素全部一样的时候$x=N!$)

那么显然算法每一轮结束的概率是$\frac{x}{N!}$因为你只需要ran出来一个合法的序列就可以了

所以说算法在恰好第k轮结束的概率是$(1-\frac{x}{N!})^{k-1}\frac{x}{N!}$

所以说算法运行的轮数服从参数为$\frac{x}{N!}$的几何分布

那么算法期望运行轮数自然就是$\frac{N!}{x}$了(如果你跳过了刚才的数学部分，现在只需要知道算法的期望运行轮数是$\frac{N!}{x}$就好了)

________________

所以问题来了x怎么算

显然如果这个序列中所有数字互不相同的话x=1

但是如果有相同的数字的话，由于相同的数字长的完全一样，所以我们可以把相同的数字换来换去而不影响这个序列的有序性

所以说，如果设$cnt_{i}$表示i这个数字的出现次数的话，我们的x可以这么算(当然，这里认为0的阶乘是1)

## $x=\prod_{i=1}^{\infty}cnt_{i}!$

所以我们现在要向这个序列里额外放m个元素……所以显然分子已经定了就是$(n+m)!$我们的目标是最小化分母x

然后这里有一个贪心的结论就是各个cnt之间应该尽可能的接近

换句话说除非碰到了不可调整的情况，否则我们每个数字的出现次数应该只有两种值，并且这两种值只差1

证明嘛就是让出现i次的数字少出现1然后出现j次的数字多出现1的话，x会乘上一个$\frac{j+1}{i}$如果i>j的话我们总是可以得到一个不劣的解，由于i和j刚好差1的情况是x不动所以我们认为这种情况就是最优解了

所以我们各个数字的出现次数应该尽可能的接近，除非这个数字不在$[l,r]$之内(此时我们放m个数根本改变不了它的出现次数)或者他出现的过于多了，以至于我们最后无法让他和其他的数字出现次数只差1

那么我们可以认为是这样一个模型

有一个长度为$r-l+1$的水池里边有一些突出的宽为1高为$cnt_{i}$的挡板

然后我们现在向里边注入m个单位的水，求最后水面的高度

当然这里最后你求出所谓的"水面高度"之后其实还是要取成整数的

最后在l,r内部的的数字的出现次数应该是有一部分是a另一部分是a+1还有一些数字的出现次数高出了"水面"这个东西我们就管不了……

所以怎么算水面高度呢？

~~(和我一样想到二分的自觉面壁去，实在是太蠢了)~~

我们把在原序列中，值在$[l,r]$范围内的数字按照**出现次数**排一个序

然后对于每一个数字，处理出来这样一个值

如果水面高度和它的高度(也就是这个数字的出现次数)平齐，那么水池里有多少水，姑且可以记做$Fil$什么的

~~然后你可以像我一样蠢得不行的使用lower_bound找到那些数字是高出水面的~~

其实我们只需要从最高的点从右向左扫一遍，看这个点的$Fil$值什么时候小于m就可以了，然后之前经过的$Fil$值大于m的点就是所谓的"高出水面的点"

然后你根据高度的前缀和+m一类的东西算出总体积，然后除一下此时的长度就是所谓的水面高度，然后体积膜一下len就是高出水面1个高度的数字的个数了

然后就可以通过快速幂算出这部分数字的贡献了

至于高出水面的部分，我们单算贡献暴力阶乘即可

然后我们算出了x之后输出$\frac{(n+m)!}{x}$即可

(这样干讲不是非常明白，可以通过画图和看代码加深理解)

统计每个数字出现了几次可以通过$std::map$(T飞)和$std::tr1::unordered\_map$(还是T)和手写的hash表来解决

其实代码还是很好写的~

上代码~

```C
// luogu-judger-enable-o2
#include<cstdio>
#include<algorithm>
using namespace std;const int N=2*1e5+10;const int M=1e7+N;typedef long long ll;const ll mod=998244353;
const int Md=(1<<25)-1;
struct hsh_map\\&哈希大法好！
{
    int f[N];int v[N];int ct;int x[N];int al[Md+10];
    inline void clear(){for(int i=1;i<=ct;i++)al[v[i]&Md]=0;for(int i=1;i<=ct;i++)f[i]=0;ct=0;}
    inline void add(int u,int V){v[++ct]=V;x[ct]=al[u];al[u]=ct;}
    int& operator [](int va)\\重载了[]方便写代码
    {for(int i=al[va&Md];i;i=x[i])if(v[i]==va)return f[i];add(va&Md,va);return f[ct];}
}cnt1,cnt2;
int n;int m;int L;int R;ll fac[M];ll res;int ct;int T;
struct data{int v;ll fil;int sum;friend bool operator <(data a,data b){return a.v<b.v;}}s[N];
inline ll po(ll a,ll p){ll r=1;for(;p;p>>=1,a=a*a%mod)if(p&1)r=r*a%mod;return r;}
inline bool cmp(const data& a,const data& b){return a.fil<b.fil;}
inline void solve()
{
    scanf("%d%d%d%d",&n,&m,&L,&R);
    res=1;int len=R-L+1;
    for(int i=1,t;i<=n;i++){scanf("%d",&t);((L<=t&&t<=R)?cnt1:cnt2)[t]++;}
    if(m==0)//特判m=0不然会re
    {
        for(int i=1;i<=cnt2.ct;++i)(res*=fac[cnt2.f[i]])%=mod;
        for(int i=1;i<=cnt1.ct;++i)(res*=fac[cnt1.f[i]])%=mod;
        printf("%lld\n",fac[n]*po(res,mod-2)%mod);return;
    }
    for(int i=1;i<=cnt2.ct;++i){(res*=fac[cnt2.f[i]])%=mod;}//单算不在l,r范围内的数字
    for(int i=1;i<=cnt1.ct;++i){s[++ct]=(data){cnt1.f[i],0};}sort(s+1,s+ct+1);//按出现次数排序
    for(int i=1,sum=0;i<=ct;i++){sum+=s[i].v;s[i].fil=(ll)(len-ct+i)*s[i].v-sum;s[i].sum=sum;}
    data *p=lower_bound(s+1,s+ct+1,(data){0,m,0},cmp);int sum=(p-1)->sum;//蠢得不行的用了lower_bound
    for(;p!=s+ct+1;++p,len--)(res*=fac[p->v])%=mod;//计算高出水面部分
    (res*=po(fac[(m+sum)/len],len))%=mod;(res*=po((m+sum)/len+1,(m+sum)%len))%=mod;//然后快速幂计算水面下部分
    printf("%lld\n",fac[n+m]*po(res,mod-2)%mod);
}
inline void clear(){cnt1.clear();cnt2.clear();ct=0;}
int main()
{
    fac[0]=1;for(int i=1;i<=M-10;i++)fac[i]=(fac[i-1]*i)%mod;scanf("%d",&T);
    for(int z=1;z<=T;z++){solve();clear();}return 0;//拜拜程序~
}
```











---

## 作者：mrclr (赞：1)

这是我今天做的第二道九条可怜的题，现在对他的题的印象是：表面清真可做，实则毒瘤坑人。

不过首先要感谢吉司机，我期望学的特烂，好在样例直接告诉我们期望怎么求了。
令$b_i$表示第$i$个不同的数的出现次数，那么期望就是
$$\frac{(n + m)!}{b_1! * b_2! * \ldots b_{tot}!}$$
所以我们只要让分母尽量小就行了。

这个问题也不难，想想就知道，只要让所有$b_i$尽可能接近就行了。

证明很简单，以两个数为例：如果$a + b = x$，问$a, b$取什么值的时候$a! * b!$最小。
设$a_1 + b_1 = x, a_2 + b_2 = x$，其中$a_1 \geqslant b_1, a_2 \geqslant b_2, a_1 > a_2, b_1 < b_2$，那么$a_1! * b_1! = a_2! * b_2! * \frac{(a_2 + 1) * (a_2 + 2) * \ldots * a_1}{(b_1 + 1) * (b_1 + 2) * \ldots * b_2}$。因为$a_1 = a_2 + \Delta t, b_1 = b_2 - \Delta t$，所以后面的分数的分子分母项数相同，而分子的每一项都大于分母，所以整个分数必定大于1.

尽量接近，翻译过来就是最大的最小，那么自然想到二分。然后似乎就没了。

但为什么裸二分不对呢，因为有的$b_i$可能在原数列中存在，且非常大，那么二分的时候就不能考虑他了，必须在后面单独算贡献。

令二分的答案是$x$，我们再列一个二元一次方程组解出来哪些$b_i$等于$x$，哪些$b_i$是$x - 1$。（手算一下就行）

这题最后一个坑点就是用map会超时，秉着死也不写哈希表的精神，离散化后直接$O(nlogn)$预处理加上吸氧，总算给过了（loj就可以过）。虽然都带个$log$，但map常数似乎真不小……

代码奉上
```c++
#include<cstdio>
#include<iostream>
#include<cmath>
#include<algorithm>
#include<cstring>
#include<cstdlib>
#include<cctype>
#include<vector>
#include<stack>
#include<queue>
#include<map>
using namespace std;
#define enter puts("") 
#define space putchar(' ')
#define Mem(a, x) memset(a, x, sizeof(a))
#define In inline
//#define int long long
typedef long long ll;
typedef double db;
const int INF = 0x3f3f3f3f;
const db eps = 1e-8;
const int maxn = 2e6 + 5;
const int maxN = 1.2e7 + 5;
const ll mod = 998244353;
const int base = 999979;
inline ll read()
{
  ll ans = 0;
  char ch = getchar(), last = ' ';
  while(!isdigit(ch)) last = ch, ch = getchar();
  while(isdigit(ch)) ans = (ans << 1) + (ans << 3) + ch - '0', ch = getchar();
  if(last == '-') ans = -ans;
  return ans;
}
inline void write(ll x)
{
  if(x < 0) x = -x, putchar('-');
  if(x >= 10) write(x / 10);
  putchar(x % 10 + '0');
}

int n, _n, m, l, r;
ll a[maxn], b[maxn], c[maxn], cnt = 0, tot = 0;
ll bnum[maxn], cnum[maxn];

In ll quickpow(ll a, ll b)
{
  ll ret = 1;
  for(; b; b >>= 1, a = a * a % mod)
    if(b & 1) ret = ret * a % mod;
  return ret;
}

ll fac[maxN], inv[maxN];
In void init()
{
  fac[0] = inv[0] = 1;
  for(int i = 1; i < maxN; ++i) fac[i] = fac[i - 1] * i % mod;
  inv[maxN - 1] = quickpow(fac[maxN - 1], mod - 2);
  for(int i = maxN - 2; i; --i) inv[i] = inv[i + 1] * (i + 1) % mod;
}

In bool judge(int x)
{
  ll sum = cnt * x;
  for(int i = 1; i <= tot; ++i) if(cnum[i] < x) sum += x - cnum[i];
  return sum >= m;
}

In ll solve()
{
  n = read(), m = read(), l = read(), r = read();
  cnt = r - l + 1, tot = 0;
  for(int i = 1; i <= n; ++i)
    {
      a[i] = b[i] = read(); 
      bnum[i] = 0;
    }
  sort(b + 1, b + n + 1);
  _n = unique(b + 1, b + n + 1) - b - 1;
  for(int i = 1; i <= n; ++i)
    ++bnum[lower_bound(b + 1, b + _n + 1, a[i]) - b];
  for(int i = 1; i <= _n; ++i)
      if(b[i] >= l && b[i] <= r) c[++tot] = b[i], cnum[tot] = bnum[i], --cnt;
  ll L = 0, R = m + n;
  while(L < R)
    {
      int mid = (L + R) >> 1;
      if(judge(mid)) R = mid;
      else L = mid + 1;
    }
  ll cnt2 = cnt, sum = 0;
  for(int i = 1; i <= tot; ++i) if(cnum[i] < L) ++cnt2, sum += cnum[i];
  ll ans = fac[n + m];
  if(cnt2 * L == m + sum) ans = ans * quickpow(inv[L], cnt2) % mod;
  else
    {
      ll x = (1 - L) * cnt2 + m + sum, y = cnt2 * L - m - sum;
      ll tp1 = quickpow(inv[L], x), tp2 = quickpow(inv[L - 1], y);
      ans = ans * tp1 % mod * tp2 % mod;
    }
  for(int i = 1; i <= _n; ++i) if(b[i] < l || b[i] > r) ans = ans * inv[bnum[i]] % mod;
  for(int i = 1; i <= tot; ++i) if(cnum[i] >= L) ans = ans * inv[cnum[i]] % mod;
  return ans;
}

int main()
{
  init();
  int T = read();
  while(T--) write(solve()), enter;
  return 0;
}
```

---

## 作者：creation_hy (赞：0)

~~这也能紫是吧~~

考虑相同数字的相对关系不管怎么排都是对的，于是最终答案即为：

$$\dfrac{(n+m)!}{\prod a_i!}$$

然后来看怎么加数字，对于 $a_i$ 来说，把它加一会使答案多除以 $a_i+1$，于是应该优先加出现次数最小的。看一眼数据范围，最终复杂度看上去应该是 $O(\sum n\log n)$ 这样的。

把出现次数相同的数字放到一起考虑即可。记 $c_i$ 表示 $[L,R]$ 中出现次数为 $i$ 的有多少个数，显然最开始给你的每个数出现次数最多为 $n$。然后遍历一遍这个数组，如果还没放完（$m>0$）就把 $c_i$ 的数分别再放一次。

即 `c[i+1]+=c[i],m-=c[i],c[i]=0`。

最后如果全都出现 $n$ 次了还没放完，那就算一下最后会放到多少次，即 $\lfloor\dfrac{m}{c_n}\rfloor$。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 2e5 + 5;
const int M = 1e7 + 2e5 + 1;
const int mod = 998244353;
int T, n, m, L, R, a[N], c1[N], c2[N], tot;
ll fac[M + 5], inv[M + 5];
inline ll qpow(ll x, ll y)
{
    ll res = 1;
    while (y)
    {
        if (y & 1)
            res = res * x % mod;
        x = x * x % mod;
        y >>= 1;
    }
    return res;
}
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    fac[0] = 1;
    for (int i = 1; i <= M; i++)
        fac[i] = fac[i - 1] * i % mod;
    inv[M] = qpow(fac[M], mod - 2);
    for (int i = M; i; i--)
        inv[i - 1] = inv[i] * i % mod;
    cin >> T;
    while (T--)
    {
        cin >> n >> m >> L >> R, tot = n + m;
        for (int i = 1; i <= n; i++)
            cin >> a[i];
        sort(a + 1, a + 1 + n), a[n + 1] = -1;
        c2[0] = R - L + 1;
        for (int i = 1, cur = 0; i <= n + 1; i++)
            if (a[i] == a[i - 1] || i == 1)
                cur++;
            else if (L <= a[i - 1] && a[i - 1] <= R)
                c2[cur]++, c2[0]--, cur = 1;
            else
                c1[cur]++, cur = 1;
        for (int i = 0; i < n; i++)
            if (m <= c2[i])
            {
                c2[i + 1] += m, c2[i] -= m, m = 0;
                break;
            }
            else
                m -= c2[i], c2[i + 1] += c2[i], c2[i] = 0;
        ll ans = fac[tot];
        if (!m)
            for (int i = 2; i <= n; i++)
                (ans *= qpow(inv[i], c1[i] + c2[i])) %= mod;
        else
        {
            for (int i = 2; i <= n; i++)
                (ans *= qpow(inv[i], c1[i])) %= mod;
            int k = m / c2[n], d = m - k * c2[n];
            (ans *= qpow(inv[n + k], c2[n] - d) * qpow(inv[n + k + 1], d) % mod) %= mod;
        }
        cout << ans << '\n';
        for (int i = 1; i <= n + 1; i++)
            c1[i] = c2[i] = 0;
    }
    return 0;
}
```

---

## 作者：541forever (赞：0)

可以考虑到若生成一个排列合法的概率为 $p$，则期望次数为 $1 \over p$，那么，最大化期望其实就相当于最小化概率。
我们又可以发现，$p={\prod cnt_i! \over n!}$,其中 $n$ 为总长度， $cnt_i$ 为值 $i$ 出现的次数。因为每次只能插入值在 $[l,r]$ 的数，考虑最小化 $\prod_{i=l} ^ r cnt_i$，那么，我们只需每次将最小的 $cnt_i$ 尽量向第二小的 $cnt_i$ 靠，具体实现时，因为在没加 $m$ 个数时的 $cnt_i$ 的数目是 $O(n)$ 级别的，可以直接从小往大枚举 $cnt_i$ 并不断让其加一，最后若所有数都变成了 $n$  且还有步数，即将其整体尽量往后加即可。最后再算除掉 $[l,r]$ 之间的数的 $cnt$，直接带入式子计算即可。最后提个醒，这题有些许卡常，如果你用的是 ``` unordered_map``` 来实现离散，请勿每次做 $clear$，因为这样常数巨大，可以考虑每次开个哈希表。

[Code](https://www.luogu.com.cn/paste/f83af7vn)

---


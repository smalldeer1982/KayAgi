# 【模板】最小树形图

## 题目背景

这是一道模板题。

## 题目描述

给定包含 $n$ 个结点， $m$ 条有向边的一个图。试求一棵以结点 $r$ 为根的最小树形图，并输出最小树形图每条边的权值之和，如果没有以 $r$ 为根的最小树形图，输出 $-1$。

## 说明/提示

**样例 $1$ 解释**

最小树形图中包含第 $2$， $5$， $6$ 三条边，总权值为 $1 + 1 + 1 = 3$

**样例 $2$ 解释**

最小树形图中包含第 $3$， $5$， $6$ 三条边，总权值为 $2 + 1 + 1 = 4$

**样例 $3$ 解释**

无法构成最小树形图，故输出 $-1$ 。

**数据范围**

对于所有数据，$1 \leq u, v \leq n \leq 100$, $1 \leq m \leq 10^4$​​, $1 \leq w \leq 10^6$​​。

## 样例 #1

### 输入

```
4 6 1
1 2 3
1 3 1
4 1 2
4 2 2
3 2 1
3 4 1```

### 输出

```
3```

## 样例 #2

### 输入

```
4 6 3
1 2 3
1 3 1
4 1 2
4 2 2
3 2 1
3 4 1```

### 输出

```
4```

## 样例 #3

### 输入

```
4 6 2
1 2 3
1 3 1
4 1 2
4 2 2
3 2 1
3 4 1```

### 输出

```
-1```

# 题解

## 作者：封禁用户 (赞：61)

## 写在前面的话

1. 作者水平不够，如果看不懂，差不多就是我错了
1. 本文**主要**是补充$tarjan$优化朱刘算法这个黑科技，因为大多数人都说只要暴力朱刘就够了，如果不把这个东西介绍出来，它永远也不会成为考点
1. 本文会顺便**简单**介绍朱刘，因为网上的证明比较少，它也是tarjan优化的前提，另外感觉其他题解一上来就是一堆生僻的名词，很劝退
1. 我想我已经开始逐级改变了我写题解的目的了，不再是为了自己的复习或者巩固，学的再好也会忘记,只落得悲伤与痛苦了，而是为了能够真正介绍知识给大家了，一个人的意志很薄弱，而人民的力量是无限的。
1. 作者不可能介绍到所有前置知识，部分还得自行根据需要查询相关资料,因此需要有一定基础的人阅读本文
1. 一切都将逝去，唯有修涵永生。

## 契约

1. $(N^i)$表示注释$i$
1. $in[x]$表示$x$的入边的最小边权;
1. $pre[x]$表示$x$的入边，边权为$in[x]$的另外一端。
1. $d[x]$表示左偏树中$x$的距离
1. $a[x]$表示左偏树中$x$的点权
1. $l[x]$表示二叉树中，$x$的左儿子，同样的道理可以定义$r[x]$
1. $dep[x]$表示有根树中$x$的深度，$dep[\text{根}]$是$0$还是$1$无所谓
1. $sz[x]$表示有根树中以$x$为根的子树大小
1. 图论的时间复杂度分析中，默认$n$表示点数，$m$表示边数
1. 部分二元组$(u,v)$默认表示$u$连向$v$的一条边
1. 部分三元组$(u,v,w)$默认表示表示$u$连向$v$的边权为$w$的边
1. 接下来所有的套路都是在无重边的基础之上，因为重边你可以特判掉，选最小的那条即可。

## 朱刘算法

1. 考虑树形图的性质，每个点都有唯一的入边（根节点除外，以后讨论入边，都不考虑根节点），于是我们提出这样一个算法，强制选择每个点边权最小的入边，这样如果不存在环，我们**肯定**得到了最小的树形图。
1. 考虑如何处理环，有一条性质，因为这个环是由最小的入边所形成的环，因此**存在**一棵最小树形图，只缺少了环上的一条边，而且缺少的这条边所指向的点的入边必在**该棵**最小树形图上$(N^1)$。
1. 我们想要这个环缩成一个点$cnt$，而且要表现环上的每条边选与不选，对于进入环上的每条边$(u,v,w)$,$v$为环上的点,$u$非环上的点，令$w-=in[v]$，然后$v=cnt$，答案强制选上环上的边权，然后删除环上所有的内部连边$(N^2)$,把这个环缩成一个点，递归进行。
1. 每次形成一个环会至少少一个点，时间复杂度$O(nm)$。

---

$(N_1)$:

可以这样考虑证明，假设存在一棵最小树形图$T$,从$T$出发，肯定可以走到环上的某个点，假设走到了$x_0$，此时$x_0$已经有入边了，假设环长$L$,从$x_0$开始，顺时针给环上的点标号$x_0,x_1,x_2,...,x_{L-1}$,此时我们考虑$x_1$,对于$pre[x_1]$,我们可以删掉最小树形图上的$(pre[x_1],x_1)$，连上$(x_0,x_1)$,这样肯定不会变劣答案,可以证明的是，这样得到的还是一棵最小树形图,意味着环上$(x_0,x_1)$的边权等于$in[x_1]$,然后用同样的方法考虑$(x_1,x_2)$,依次类推，我们发现我们环上唯一不能选的边只有$(x_{L-1},x_0)$。

$(N_2)$:

这是一个常见贪心技巧，不知道的人应该仔细理解，自己给出证明。

## 左偏树

### 外节点

定义：二叉树中，一个节点没有左儿子或者右儿子就叫做外节点，或者理解为儿子个数小于等于1。

### 左偏树的距离

定义：在左偏树中，一个节点$x$的子树中，找到深度最大的外节点$y$，那么$dep[y]-dep[x]$就叫做左偏树中$x$到$y$的距离，以后谈距离省略左偏树，特别地空节点距离为$-1$。

### 左偏树

定义：如果一棵二叉树满足以下性质

1. 二叉堆（以后默认为小根堆进行讨论）
1. 对于任意一个节点$x$，有$d[l[x]]\geq d[r[x]]$

我们就把这个二叉树叫做左偏树。

### 左偏树的性质

1. $d[x]=d[r[x]]+1$
1. 对于任意一个$x$，$d[x]\leq log(n)$($n$为左偏树的大小)$(N_3)$

---

$(N_3)$


考虑一个节点$x$，会对哪些节点的距离产生贡献，数学归纳可得，如果他对$y$产生了贡献，那么$y$是以满二叉树为基础上建立的二叉树，故$y$的深度每次减$1$,$sz[y]$至少扩大两倍，故得证。

### 左偏树的操作

1. 合并:定义函数$merge(x,y)$为合并以$x$为根的左偏树和以$y$为根的左偏树，返回值为新的树根，如果$a[x]>a[y]$就交换$x,y$，然后递归进行$a[x].r[x]=merge(r[x],y)$，此时如果$d[l[x]]<d[r[x]]$就交换$l[x],r[x]$,最后令$d[x]=d[r[x]]+1$,$return\ x$，时间复杂度为$log(n)$,$(N_4)$
1. 删除：删除$x$，直接$merge(l[x],r[x])$即可，也告诉我们，可以在$log(n)$的时间复杂度删除树上任意一个节点，前提是找得到。
1. 加入一个节点，其实把一个节点看作一棵树，就和$1$一样了。

---

$(N_4)$

时间复杂度证明，其实每次递归发现$d[x],d[y]$其中至少有一个减少了$1$,因此时间复杂度为$O(log(sz[x])+log(sz[y]))$，**也侧面告诉我们不能启发式合并**。

### [模板](https://www.luogu.com.cn/problem/P3377)

## tarjan优化朱刘

### 算法流程

1. 朱刘相当于最小生成树中$B$字开头的算法,而现在介绍的优化，其实相当于$prim$。
1. 枚举每个**原图**中的节点$x$，然后不停地把边$(pre[x],x)$加入最小树形图，答案累加$in[x]$，在某一时刻发现出现了环，删除该环内部所有边，然后暴力把每个指向该环的边$(u,v)$，令边权减去$in[v]$,然后将这个环缩成一个点,然后迭代进行，直至到达根节点$r$，这样还是$O(nm)$。
1. 考虑优化，我们对于每个点$x$建一棵左偏树$T_x$，然后我们就可以在$O(1)$的时间复杂度查询一个节点的最小入边，缩环的时候直接合并左偏树即可，边权减打标记即可,因此我们需要很好的实现标记下放，一次对环的合并我们不妨及做$log(n)$，每个节点属于哪个环可以用并查集路径压缩+按秩合并，删除节点可以用延迟删除$(N_5)$，那么最终时间复杂度不难分析的出来是$O(m+nlog(n))$。

---

$(N_5)$


如果我没记错的话，应该也叫懒惰删除法


### 参考代码


```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cstdlib>
#define il inline
#define ri register
#define Size 100050
using namespace std;
int fa[Size],cnt,is[Size];
il int find(int);
il void read(int&),Union(int,int);
struct leftist{
	struct point{
		int l,r,d,v,t,to;
	}a[Size]={{0,0,-1,0,0,0}};
	int r[Size];
	il void merge(int&x,int&y){
		if(!x||!y){x^=y;return;}
		if(a[x].v>a[y].v)x^=y^=x^=y;
		a[y].t-=a[x].t,a[y].v-=a[x].t;
		merge(a[x].r,y);
		if(a[a[x].l].d<a[a[x].r].d)
			a[x].l^=a[x].r^=a[x].l^=a[x].r;
		a[x].d=a[a[x].r].d+1;
	}
	il void spread(int&p){
		a[a[p].l].t+=a[p].t,a[a[p].r].t+=a[p].t;
		a[a[p].l].v+=a[p].t,a[a[p].r].v+=a[p].t;
		a[p].t=0;
	}
	il void pop(int&x){
		spread(x),merge(a[x].l,a[x].r),x=a[x].l;
	}
	il point*top(int&x){
		while(r[x]&&!(find(a[r[x]].to)^x))pop(r[x]);
		if(!r[x])puts("-1"),exit(0);
		a[r[x]].to=find(a[r[x]].to);
		return &a[r[x]];
	}
}L;
int pre[Size];
int main(){
	int n,m,r,ans(0);leftist::point*temp;
	read(n),read(m),read(r),cnt=n,is[r]=r;
	for(int i(1),u,v,w;i<=m;++i)
		read(u),read(v),read(w),
			L.a[i]={0,0,0,w,0,u},
			L.merge(L.r[v],u=i);
	for(int i(1);i<=n<<1;++i)fa[i]=i;
	for(int i(1),j(i);i<=n;j=++i)
		while(!is[j]){
			while(!is[j])
				is[j]=i,j=(temp=L.top(j))->to,
					ans+=temp->v;if(is[j]^i)break;
			while(~is[j])
				is[j]=-1,j=pre[j]=(temp=L.top(j))->to,
					temp->t-=temp->v,temp->v=0;++cnt;
			while(is[j]^i)is[j]=i,Union(j,cnt),j=pre[j];
			j=cnt;
		}return printf("%d",ans),0;
}
il void Union(int u,int v){
	if((u=find(u))^(v=find(v)))
		L.merge(L.r[v],L.r[u]),fa[u]=v;
}
il int find(int x){
	return x^fa[x]?fa[x]=find(fa[x]):x;
}
il void read(int&x){
	x^=x;ri char c;while(c=getchar(),c<'0'||c>'9');
	while(c>='0'&&c<='9')x=(x<<1)+(x<<3)+(c^48),c=getchar();
}
```


## 扩展知识

1. 求没有确定的根的树形图:建立一个超级根$r$，以它为根跑算法,只要将$r$向原图每个点连接一条权值大于原图中所有边的边权的边，这样选这些边肯定不划算，因此只会选择一条。
1. 判无解的奇技淫巧:从小到大依次枚举每个点$i$,加入边$(i,(i+1)\%n+1,+\infty)$,这样如果你最后得到的答案为$+\infty$，那么就无解了。


## 写在后面的话

既然你会$O(E+nlog(n))$，是不是也想谴责luogu为什么放暴力朱刘过了吗？

---

## 作者：lgswdn_SA (赞：52)

### 1 DAG的最小树形图  

一个树形图中，除了r点其他点都**只有一个入边**  

那么对于一个DAG，只要我们**对于每一个点选出最小的入边**，那么这一定是个树形图（显然，易证

那么算法就非常的简单

```cpp
for(int i=1;i<=n;i++,des=r){
	for(int j=1;j<=n;j++)
		if(e[i][j]<e[i][des]&&i!=j)
			des=j;
	ans+=e[i][des];
}
```

### 2 环的最小树形图
这个问题十分傻，显然，从r开始绕一圈少一条边就行了

### 3 真正的最小树形图
这个东西叫做朱刘算法  
好像伟大的图论专家塔扬先生有一种更好的方法，不过太烦了，没必要研究这种黑科技
![](https://cdn.luogu.com.cn/upload/image_hosting/yiueg28r.png)

我们看到，我们用DAG的算法把边分为了两种，红边就是要选的边，蓝边是因为比红边长而被抛弃的边，然后黄色的是个红边组成的环


如果我们一开始用DAG的贪心算出来的图就是一个一个DAG，那么皆大欢喜，这个环没有影响，直接输出即可  

![](https://cdn.luogu.com.cn/upload/image_hosting/6xzclqjq.png)
（这是一个逆时针的环）  

> 1处理环

那么有环呢？

一旦有个环，那么这个环在选出来的图上肯定不会被其他点连接

那我们肯定要把其中一条边换成环外边

那么如果有环，我们就把贪心算出来的那个所谓的“树形图”上的环**缩成一个点**，环外边指向这个所称的点

为了方便统计，由于我们确信环外边的长度$\ge$环内边的长度，那么我们ans先加上这个环的边权和，然后指向环的边边权设为**自己的长度-所连向的环内点在环中指向的点的边的长度**

用那张图解释一下：  

左上角的那个点，指向它的那条边，边权设为自己的长度，减去左上角的点到左下角的点的边的长度

有什么好处呢？

![](https://cdn.luogu.com.cn/upload/pic/22858.png)
(引用一下别人的别人的别人的题解的图，这张图实在太好用了，放这里做参考)

这样，我们以后再选到这条边，就**直接把它加到ans里面**，就得到了这个环和连接这个环的边的所需长度了

为什么呢？易证，易得，显然如此，  

假设环内去除的边权为$x$，连向这个环的边权为$y$，环的长度为$k$，那么这个环+连向这个环用的总长度应该是$k-x+y$，转换一下就是$k+(y-x)$，其中$y-x$就是那条连线环的边的边长

> 2 找环

说一遍，我不想TARJAN


**fa[u]**：$u$的入边另一个点，也就是$u$的“父亲”  
**tp[u]**：相当于并查集路径压缩的数组，代表$u$的当前最早前驱  
**lp[u]**：代表u是哪个环上的。如果lp=0，那么代表这个点目前还不是环上的

遍历每个节点$u$，然后沿着fa一路逆向走，直到根或者前驱是自己的点（路径压缩）或是环上点（一个点不可能处于两个环）。

如果最后走到了根，代表目前这个点还不是环上点

如果最后走到了前驱是自己的点$v$，分类讨论：

- lp[v]不是0，代表它已经是另一个环的节点，一个节点不可能同时处于两个环，不用设置新环

- lp[v]是0，代表这是发现的一个新环，给环上的每个点的id都标记上
```cpp
for(int u=1,v=1;u<=n;u++,v=u){
	while(v!=root&&tp[v]!=u&&!lp[v]) tp[v]=u,v=fa[v];
	if(v!=root&&!lp[v]){
		lp[v]=++tot;
		for(int k=fa[v];k!=v;k=fa[k]) lp[k]=tot;
	}
}
```

> 3 循环结束时间

总体的算法流程：对于每一次，求出所谓的“带环最小树形图”，然后把环缩点，修改边权

何时结束？

我们知道，一旦他是一个没有环的树形图，那么就是一个树形图了（雾

总的来说，一旦没有环，那么**所有点都能到**，那么就OK了，直接退出循环

**撒花HORRAY**

### 算法流程
对于每一次循环：  

1. 贪心找出所谓的“最小带环树形图”，（就是上面的万能图的红边）  
顺便记录一下自己是从哪里来的（入边的起点）  
2. 把所有选出的边加到ans里面  
3. 找环记录环，统计数量  
4. 如果没环，代表完成了，退出循环  
5. 把所有不是环上的点全部设置为自己是一个独立环（大小为1的新环）  
6. 重新设置边权&缩点
7. 完成缩点，重新设置n和root，然后初始化

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=109,M=10009; 
struct edge{int u,v,w;}e[M]; //用边表存储 

int n,m,root,mn[N],fa[N],tp[N],lp[N],tot,ans;
int zl(){
	while(1){
		for(int i=1;i<=n;i++) mn[i]=1e9,fa[i]=tp[i]=lp[i]=0;
		
		for(int i=1,u,v,w;i<=m;i++) //Step 1
			if(e[i].u!=e[i].v&&(w=e[i].w)<mn[v=e[i].v])
				mn[v]=w,fa[v]=e[i].u;
		mn[root]=0;
		for(int u=1;u<=n;u++){ans+=mn[u];if(mn[u]==1e9)return -1;} //Step 2
		
		for(int u=1,v=1;u<=n;u++,v=u){ //Step 3
			while(v!=root&&tp[v]!=u&&!lp[v]) tp[v]=u,v=fa[v];
			if(v!=root&&!lp[v]){
				lp[v]=++tot;
				for(int k=fa[v];k!=v;k=fa[k]) lp[k]=tot;
			}
		}
		if(!tot) return ans; //Step 4
		for(int i=1;i<=n;i++) if(!lp[i]) lp[i]=++tot; //Step 5
		
		for(int i=1;i<=m;i++) //Step 6
			e[i].w-=mn[e[i].v],e[i].u=lp[e[i].u],e[i].v=lp[e[i].v];
		n=tot, root=lp[root], tot=0; //Step 7
	}
}

int main(){
	scanf("%d%d%d",&n,&m,&root);
	for(int i=1,u,v,w;i<=m;i++)
		scanf("%d%d%d",&u,&v,&w),e[i]=(edge){u,v,w};
	printf("%d",zl());
	return 0;
}
```
最后说一下个人的想法：

最小树形图在联赛中并不常见，但是zl算法却有一个很重要的思想：见到有向有环图，可以想到缩点，然后利用DAG的特性去做题，因为许多算法在 DAG 上可以有更优/更方便的解。



---

## 作者：i207M (赞：50)

## 题意

给定一张**有向图**，求出以给定节点为根的最小树形图；树形图的定义是，从根节点出发可以到达所有其他点（所以图首先要联通）

## 实现

![](https://cdn.luogu.com.cn/upload/pic/22858.png)

![](https://cdn.luogu.com.cn/upload/pic/22859.png)

总的来说：

1. 求最短弧集合E；

2. 判断集合E中有没有有向环，如果有转步骤3，否则转4；

3. 收缩点，把有向环收缩成一个点，并且对图重新构建，包括边权值的改变和点的处理，之后再转步骤1；

4. //展开收缩点，求得最小树形图；

　　(1)求最短弧集合E0.

　　从所有以Vi(i ≠ 0)为终点的弧中取一条最短的,若对于点i,没有入边,则不存在最小树形图,算法结束;如果能取,则得到由n个点和n-1条边组成的图G的一个子图G',这个子图的权值一定是最小的,但是不一定是一棵树.
  
```
		for(ri i=1; i<=n; ++i) ine[i]=inf;  // 初始化
		for(ri i=1; i<=m; ++i)
		{
			int u=e[i].u,v=e[i].v;
			if(u!=v&&e[i].w<ine[v])  // 遍历所有边，对每个点找到最小的入边
				ine[v]=e[i].w,pre[v]=u;
		}
```

**找到以每个点为终点的边的最小值并记录；根没有入边；被缩的点忽略；如果从一个点没有入边，一定不存在树形图；**

　　(2)检查E0.

　　若E0没有有向环且不包含收缩点,则计算结束,E0就是G以V0为根的最小树形图,若E0没有有向环,但是存在收缩点,转到步骤(4),若E0含有有向环,则转入步骤(3).
  
如果没有环，那么选出来的就是树形图；否则就要缩点；

```
		for(ri i=1; i<=n; ++i) vis[i]=id[i]=0;
		for(ri i=1; i<=n; ++i)
		{
			if(i==root) continue;
			ans+=ine[i];
			int v=i;
			while(vis[v]!=i&&!id[v]&&v!=root)  // 找环
			{
				vis[v]=i;
				v=pre[v];
			}
			if(!id[v]&&v!=root)
			{
				id[v]=++cnt;  // 把环上的店标记为同一点
				for(ri u=pre[v]; u!=v; u=pre[u])
					id[u]=cnt;
			}
		}
```

**一定要记录cnt或开一个bool数组记录走过的边，不然可能疯狂走环；**

　　(3)收缩G中的有向环.

　　把G中的环C收缩成点u,对于图G中两端都属于C的边就会被收缩掉,其他弧仍然保留,得到一个新的图G1,G1中以收缩点为终点的弧的长度要变化,变化的规则是:设点v在环C中,且环中指向v的边的权值为w,点v'不在环C中,则对于G中的每一条边<v', v>,在G1中有边<v', u>和其对应,且权值WG1(<v', u>) = WG(<v', v>) - w;对于图G中以环C中的点为起点的边<v', v>,在图G1中有边<u, v'>,则WG1(<u, v'>) = WG(<v', v>).有一点需要注意,在这里生成的图G1可能存在重边.

　　对于图G和G1:

　　<1>:如果图G1中没有以v0为根的最小树形图,则图G也没有.

　　<2>:如果G1中有一v0为根的最小树形图,则可按照步骤(4)的展开方法得到图G的最小树形图.

　　所以,应该对于图G1代到(1)中反复求其最小树形图,直到G1的最小树形图u求出.
  
**缩环的时候记得加入答案，环上的出边直接接上，入边要注意，选一条入边相当于删掉一条环边，所以加入入边的权值为$w-ine[v]$**

　　(4)展开收缩点.
  
## 扩展：无根树的树形图

~~以写挂了的HDU2121为例~~

不限定根结点的树形图，我们可以虚拟一个0号根节点，并向各个点连一条权值为$sum(w)+1$的边，因为权值很大，所以最终结果一定只包含一条这样的边；但是如果答案大于$sum+sum+1$，其实是无解的，这样相当于两个点不联通，只好多选一条大边；否则答案是$ans-sum-1$

如果要输出编号最小的根节点，多解的情况一定是有环，而超级源点最后选择的一条出边一定就是最优解（多加的边按照点的编号排序）；所以我们就在找边的时候加上一句就好了；

```
if (u == root) pos = i;
```

那么答案即为pos-m-1（pos为边的编号）

## 易错

1.非常重要，不然T飞：在判环时一定要加上cnt计数，并在cnt>n时break；否则就开一个bool数组记录是否经过该点；不然可能会有一个环然后就在里面不停转；

2.缩点时，变量名不要写错……

## 代码

```
struct Edge
{
	int u,v,w;
} e[M];
const int inf=2e9;
int n,m,root;
int pre[N],ine[N];
int vis[N],id[N];
int zhuliu()
{
	int ans=0;
	while(1)
	{
		for(ri i=1; i<=n; ++i) ine[i]=inf;  // 初始化
		for(ri i=1; i<=m; ++i)
		{
			int u=e[i].u,v=e[i].v;
			if(u!=v&&e[i].w<ine[v])  // 遍历所有边，对每个点找到最小的入边
				ine[v]=e[i].w,pre[v]=u;
		}
		for(ri i=1; i<=n; ++i)  // 判定无解
			if(i!=root&&ine[i]==inf) return -1;
		int cnt=0;
		for(ri i=1; i<=n; ++i) vis[i]=id[i]=0;
		for(ri i=1; i<=n; ++i)
		{
			if(i==root) continue;
			ans+=ine[i];
			int v=i;
			while(vis[v]!=i&&!id[v]&&v!=root)  // 找环
			{
				vis[v]=i;
				v=pre[v];
			}
			if(!id[v]&&v!=root)
			{
				id[v]=++cnt;  // 把环上的店标记为同一点
				for(ri u=pre[v]; u!=v; u=pre[u])
					id[u]=cnt;
			}
		}
		if(cnt==0) break; // 无环，得到解
		for(ri i=1; i<=n; ++i)
			if(!id[i]) id[i]=++cnt;
		for(ri i=1; i<=m; ++i)
		{
			int u=e[i].u,v=e[i].v;
			e[i].u=id[u],e[i].v=id[v];
			if(id[u]!=id[v]) e[i].w-=ine[v]; // 修改边权
		}
		root=id[root];
		n=cnt;
	}
	return ans;
}
```

---

## 作者：旋转卡壳 (赞：26)

模板题 刚看完题解学了波 【朱-刘算法】 发发自己的见解

最小树形图，就是在【有向】带权图中指定一个特殊的点root，求一棵【以root为根】的有向生成树，并且树中所有边的总权值最小。

咋看之下是不是感觉跟最小生成树一样 = =

首先我们知道 【树】的根节点没有入边 出边可以无限多

而其他节点出边也可以无限多 但【入边只有一条】

既然要所有点都在树内 我们就贪心地选取【所有入点u的边中权值最小的】

如果此时能形成一棵树 那无疑就是最优解了

可以直接直觉认为 当前选的n-1条边中【没有边成环就能形成树】

如果有环 我们就进行缩点 【把在同一个环内的点看成一个点 同时更新指向环中任意一点的边权】

看着好像跟这道题一点关系都扯不上 那么废话不多说 上别人题解里的图

![qaq](https://cdn.luogu.com.cn/upload/pic/22858.png)

【1】 以1号节点为根 先贪心选一波边 发现成环

【2】 将2/3/4节点缩成一点 同时更新指向它的边的权值

可以看到1->4的边权是4 如果我们要选这条边 那么就可以不选3->4 因为【入边只有一条】

又因为3->4的边权已经计入答案了 所以这条边的边权可以变成4-2=2

选的话就又2+2+2变成2+2+4

其他同理 可以自己推一下加深印象

重复【1】【2】直到不成环

下面给出代码+注释

```
#include <cstdio>

using namespace std;

typedef long long ll;

const int maxn=1e2+50;
const int maxm=1e4+50;
const int inf=0x3f3f3f3f;

int n,m,r;
ll ans;

inline int read() {
    int a=0;char c=getchar();
    while(c<'0'||c>'9') c=getchar();
    while(c>='0'&&c<='9') a=(a<<1)+(a<<3)+c-'0',c=getchar();
    return a;
}

struct edge {int u,v,w;}e[maxm];

int cnt,fa[maxn],id[maxn],top[maxn],min[maxn];
//cnt当前图环的数量 
//id[u]代表u节点在第id[u]个环中
//top[u]代表u所在链的代表元素 类似并查集 
//min[u]为当前连到u点的最短边的边权 fa[v]当前连到v点的最短边的u 

inline int getans() {
    while(1) {
        for(register int i=1;i<=n;++i) id[i]=top[i]=0,min[i]=inf;
        for(register int i=1;i<=m;++i)
            if(e[i].u!=e[i].v&&e[i].w<min[e[i].v])
            //不是自环 并且边权比选定的还小 
                fa[e[i].v]=e[i].u,min[e[i].v]=e[i].w;
        int u=min[r]=0;
        for(register int i=1;i<=n;++i) {
            if(min[i]==inf) return 0; //存在一个不可以连接的点 
            ans+=min[i];
            for(u=i;u!=r&&top[u]!=i&&!id[u];u=fa[u]) top[u]=i;
            //找到包含不在环中的点最多的链 打上标记 
            if(u!=r&&!id[u]) { //这时候还满足条件说明vis[u]==i 即成环 
                id[u]=++cnt;
                for(int v=fa[u];v!=u;v=fa[v]) id[v]=cnt;
            }
        }if(!cnt) return 1; //没环就是找到答案了 
        for(register int i=1;i<=n;++i) if(!id[i]) id[i]=++cnt;
        //i节点不存在当前树中 就给他自己成一个环 
        for(register int i=1;i<=m;++i) {
            int last=min[e[i].v];
            //last等于当前连进v点的边的最小权值 
            if((e[i].u=id[e[i].u])!=(e[i].v=id[e[i].v])) e[i].w-=last;
            //当前边的两个端点不在同一个环内 
        }n=cnt;r=id[r];cnt=0;
        //缩完点后 当前点数就为环数 根节点就是根节点所在的环 
    }
}

int main() {
    n=read();m=read();r=read();
    for(register int i=0;i<m;e[++i]=(edge){read(),read(),read()});
    if(getans()) printf("%lld",ans);
    else printf("-1");
    return 0;
}
```


---

## 作者：Great_Influence (赞：19)

就是模板吧。目前还没找到这个东西除了模板有什么用......

当然，可以用来解决[这道题](https://www.luogu.org/problemnew/show/P3244)(但是和算法本身没有关系)

以下讲的是朱-刘算法，还有神仙Tarjan提出的更快的算法($O(m+nlogn)$)，不过一般用不上就是了。

大体来说，就是发现一个合法的树形图的每个点都只有一条入边~~(废话)~~，所以贪心地对每个点都选择一条通向它的最短的边(没有就没有树形图了)。这样连出来的图有$n-1$条边，但不一定是树。不过，这个图最多只有几个简单环(因为每个点只连入$1$条边)。所以，我们将这些环搜出并缩起来，然后在缩完后的边中继续跑最小树形图直到选择的边构成树。时间复杂度$O(nm)$，但是一般情况会快很多。

注意每次跑一遍算法后，答案已经加上每个点的最短入边了。但是如果要将这条边更换，那么需要将其他的边长减去原来最短入边边长，再继续计算。

然后这道题(以及基本所有的题)只要求这个边权和就可以了，所以就不需要展开之类的操作了。

代码:

```cpp
#include<bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp>
#define Rep(i,a,b) for(register int i=(a),i##end=(b);i<=i##end;++i)
#define Repe(i,a,b) for(register int i=(a),i##end=(b);i>=i##end;--i)
#define For(i,a,b) for(i=(a),i<=(b);++i)
#define Forward(i,a,b) for(i=(a),i>=(b);--i)
template<typename T>inline void read(T &x)
{
    T f=1;x=0;char c;
    for(c=getchar();!isdigit(c);c=getchar())if(c=='-')f=-1;
    for(;isdigit(c);c=getchar())x=x*10+(c^48);
    x*=f;
}

inline void write(int u,char ed='\n')
{
	if(!u){putchar(48);putchar(ed);return;}
	static int sta[43],tp;
	for(tp=0;u;u/=10)sta[++tp]=u%10;
	for(;tp;putchar(sta[tp--]^48));
	putchar(ed);
}

using namespace std;

const int MAXN=111,MAXM=1e4+7;

static int n,m,rt;

static struct edge
{
	int u,v,w;
}p[MAXM];

inline void init()
{
	read(n);read(m);read(rt);
	Rep(i,1,m)read(p[i].u),read(p[i].v),read(p[i].w);
}

static int in[MAXN],pre[MAXN],vis[MAXN],id[MAXN];

const int inf=0x3f3f3f3f;

inline long long getans()
{
	static long long ans=0;
	static int cnt=0,u,v,laz;
	while(1)
	{
		Rep(i,1,n)in[i]=inf,id[i]=vis[i]=0;
		Rep(i,1,m)if(p[i].u^p[i].v&&p[i].w<in[p[i].v])
			pre[p[i].v]=p[i].u,in[p[i].v]=p[i].w;
		in[rt]=0;
		Rep(i,1,n)
		{
			if(in[i]==inf)return -1;
			ans+=in[i];
			for(u=i;u^rt&&vis[u]^i&&!id[u];u=pre[u])vis[u]=i;
			if(u^rt&&!id[u])
			{
				id[u]=++cnt;
				for(v=pre[u];v^u;v=pre[v])id[v]=cnt;
			}
		}
		if(!cnt)return ans;
		Rep(i,1,n)if(!id[i])id[i]=++cnt;
		Rep(i,1,m)
		{
			laz=in[p[i].v];
			if((p[i].u=id[p[i].u])^(p[i].v=id[p[i].v]))
				p[i].w-=laz;
		}
		n=cnt;rt=id[rt];cnt=0;
	}
}

inline void solve(){printf("%lld\n",getans());}

int main()
{
    init();
    solve();
    return 0;
}
```

---

## 作者：KiDDOwithTopTree (赞：13)

~~估值快没了，赶紧写篇题解水水。~~

[传送门](https://www.luogu.com.cn/problem/P4716)。

本文将会讲到 $\texttt{Tarjan}$ 的优化朱刘算法。这种方法是我从所看过的博客中理解的，有可能有些地方我理解错了，请在评论区或私信中提出。

大家都知道朱刘算法可以做到 $O(nm)$ 求最小树形图，那有没有更快的做法呢？$\texttt{Tarjan}$ 的优化朱刘算法便可以做到 $O((n+m)\log m)$ 求最小树形图。

这个算法是对朱刘的优化，那么我们来看看朱刘算法主要有哪些步骤：

1. 求最短弧集。
2. 找环并缩环。
3. 判定无解。

#### 1. 维护最短弧集：

设以 $x$ 为终点的边的集合为 $E_x$，$E_x$ 中边权最小值为 $E_{x_{\min}}$。

在朱刘算法中关于最短弧集的操作有一下几种：

1. 查找 $E_{x_{\min}}$。
2. 找到一个环，把一个环内的节点 $a_1,a_2,...,a_k$ 缩为 $p$，把集合 $E_{a_x}$ 中所有值减去 $E_{a_{x_{\min}}}$，把 $E_{a_{x_{\min}}}$ 从集合 $E_{a_x}$ 中删去，把集合 $E_{a_1},E_{a_2},...,E_{a_k}$ 合并为 $E_p$。

我们把这些东西抽象化，那就变为 $3$ 种操作：

1. 查询最小值。
2. 整体减一个数。
3. 合并几个集合。

根据这些，我们可以发现，**可并堆**这种数据结构可以十分优秀地维护这些操作。

#### 2. 找环与缩环：

朱刘算法中结束的标志是没有环，但是这个条件未免过于苛刻，很难快速判断。那么我们干脆直接把它进阶，变为**缩成一个点**，也就是**整张图没有边**。

但是原图不可能一定强连通，那么我们需要强行使其变为强连通，就是加 $n$ 条边权为 $INF$ 的边。

我们用一个**栈**进行存储，每次将栈顶 $x$ 的**最短弧的起点** $y$ 压入栈。如果 $y$ 不在栈中，压入即可；否则说明找到一个环，在栈中把环弹出，把环缩为一个点 $p$。

在加答案时如果终点是 $r$ 或含有 $r$ 的环，那么这条边不能计入答案。因为最小树形图 $r$ 没有入边。

因为要找一个点被收缩多次后的新点，所以需要一个并查集来维护。

#### 3. 判定无解：

因为边权为 $INF$ 的边是新加入的，如果答案大于 $INF$ 则说明我们用了新加的边，也就是说原图无法形成最小树形图，即无解。

代码只有 $99$ 行，带有注释，请放心食用：
```cpp
#include<iostream>
#include<cstring>
using namespace std;
#define int long long
const int N=1e6+10,INF=0x3f3f3f3f;
struct ltt_node{
	int lson,rson;
	int val,tag;
	int from,to;
	int dis;
};
struct leftist_tree{
	ltt_node ltt[N];
	int tot;
	inline int newnode(int val,int from,int to){
		tot++;
		ltt[tot].val=val;
		ltt[tot].from=from;
		ltt[tot].to=to;
		return tot;
	}
	inline void pushdown(int now){
		int ls=ltt[now].lson,rs=ltt[now].rson;
		ltt[ls].val+=ltt[now].tag;
		ltt[rs].val+=ltt[now].tag;
		ltt[ls].tag+=ltt[now].tag;
		ltt[rs].tag+=ltt[now].tag;
		ltt[now].tag=0;
	}
	int merge(int x,int y){
		if(!x||!y) return x+y;
		pushdown(x),pushdown(y);
		if(ltt[x].val>ltt[y].val) swap(x,y);
		ltt[x].rson=merge(ltt[x].rson,y);
		if(ltt[ltt[x].rson].dis>ltt[ltt[x].lson].dis)
			swap(ltt[x].lson,ltt[x].rson);
		ltt[x].dis=ltt[ltt[x].rson].dis+1;
		return x;
	}
	int del(int rt){
		pushdown(rt);
		int ls=ltt[rt].lson;
		int rs=ltt[rt].rson;
		return merge(ls,rs);
	}
};//左偏树基本操作
leftist_tree ltt;
int root[N],fa[N];
int sta[N],top;
bool vis[N];
inline int find(int x){
	return x==fa[x]?x:fa[x]=find(fa[x]);
}//并查集，用于查找一个点被收缩多次后的新点
signed main(){
	int n,m,r;
	cin>>n>>m>>r;
	for(int i=1;i<=m;i++){
		int x,y,z;
		cin>>x>>y>>z;
		int lp=ltt.newnode(z,x,y);//新建一个左偏树节点，边从x到y，边权为z
		root[y]=ltt.merge(root[y],lp);//插入到y的左偏树中
	}
	for(int i=1;i<=n;i++){
		int x=i,y=i%n+1;
		int p=ltt.newnode(INF,x,y);
		root[y]=ltt.merge(root[y],p);
	}//加入n条边强行使其强连通
	for(int i=1;i<=2*n;i++) fa[i]=i;//算上收缩的点共有2n个点
	sta[++top]=r,vis[r]=true;
	int ans=0,cnt=n;
	while(root[sta[top]]){//还有边
		int lp=root[sta[top]];
		ltt_node tmp=ltt.ltt[lp];
		int u=find(tmp.from);
		if(u==sta[top]){
			root[sta[top]]=ltt.del(root[sta[top]]);
			continue;
		}//自环
		if(!vis[u]){
			sta[++top]=u;
			vis[u]=true;
			continue;
		}//不构成环，加入即可
		int p=++cnt;//把环缩为p
		while(vis[u]){//u还没被弹出
			int v=sta[top--];//环上的节点
			vis[v]=false,fa[v]=p;//这个点缩成了p
			int val=ltt.ltt[root[v]].val;//最短弧的边权
			ltt.ltt[root[v]].tag-=val;//懒标记
			int x=find(ltt.ltt[root[v]].to);
			ans+=(x!=find(r))*val;//如果x等于r，说明这条边通向r，不能选
			root[v]=ltt.del(root[v]);//删掉最短弧
			root[p]=ltt.merge(root[p],root[v]);//合并到p的左偏树上
		}//把整个环找出来
		sta[++top]=p;
		vis[p]=true;//把p加入
	}
	cout<<(ans>=INF?-1:ans)<<'\n';
}
```

总共有 $2n$ 个点，合并的时复为 $O(n\log m)$，每条边都会访问一次，每次访问要 $O(\log m)$，时复为 $O(m\log m)$，总时复为 $O((n+m)\log m)$。

参考资料：

[OI Wiki-最小树形图](https://oi-wiki.org/graph/dmst/)。

[yybakioi 的博客-题解 P4716 【【模板】最小树形图】](https://www.luogu.com.cn/blog/xiaojiji/solution-p4716)。

---

## 作者：YellowBean_Elsa (赞：5)

传说中的【朱-刘】算法

#### 基本思路

似乎是个大贪心。。。

由于最后得到一颗树，所以首先保证每个点（除了根）都有入边。

考虑贪心，对于每个点我们选最小入边，加入 ans。

但是这样会构成环。

所以我们要处理掉他们！

#### 判环

从每个点沿着找出的入边往回走，走到同一个点就是环。

#### 处理环

扫描每一条边，如果连结的不是同一个环里的点，把边权减去终点的原最小入边边权，因为那条边不再需要了，终点已经有新入边了。（这条）

#### 缩点

把在同一个环里的点缩成一个，编号就是环的编号。

最后还要注意更新点的总数和根。

```cpp
//coder: Feliks*GM-YB
#include<bits/stdc++.h>
#define fu(i,a,b) for(register int i = a, I = (b) + 1; i < I; ++i)
#define fd(i,a,b) for(register int i = a, I = (b) - 1; i > I; --i)
typedef long long ll;
using namespace std;
const int N=1e4+5;
const int inf=(1<<30);
int n,m,rt;
ll ans;
inline int read(){
    int x=0;char ch=getchar();
    while(!isdigit(ch))ch=getchar();
    while(isdigit(ch))x=(x<<1)+(x<<3)+ch-'0',ch=getchar();
    return x;
}int u[N<<1],v[N<<1],nex[N<<1],first[N],w[N<<1],tot;
//其实这道题不用邻接表只是我懒得改模板了（雾 
inline void add(int x,int y,int z){
    v[++tot]=y,u[tot]=x,w[tot]=z;
    nex[tot]=first[x];
    first[x]=tot;
}int scc[N],cnt,mn[N],fa[N],top[N];
//scc：每个点在哪个环里；mn：最小入边边权；fa：最小入边起点；top：在找环时记录起点 
inline void init(){
	fu(i,1,n)scc[i]=top[i]=0,mn[i]=inf;
	mn[rt]=cnt=0;
}
inline bool solve(){
	while(1){
		init();
		fu(i,1,m)//寻找最小入边 
			if(u[i]!=v[i] && w[i]<mn[v[i]])
				mn[v[i]]=w[i],fa[v[i]]=u[i];
		fu(i,1,n)if(mn[i]==inf)return 0;//有点莫得入边，死也构不成树 
		fu(i,1,n){
			ans+=mn[i];
			int x; 
			//从i点沿着挑出来的边走，注意不要侵扰到别的环或跑到根去 
			for(x=i;x!=rt && top[x]!=i && !scc[x];x=fa[x])top[x]=i;
			if(x!=rt && !scc[x]){//top[x]=i, 即跑了一圈回到了 x
				scc[x]=(++cnt);
				for(int y=fa[x];y!=x;y=fa[y])scc[y]=cnt;
			}
		}if(!cnt)return 1;//莫得环了，弄到了最小树形图 
		fu(i,1,n)if(!scc[i])scc[i]=(++cnt);//必要操作，否则缩点后点数与根会受影响 
		fu(i,1,m){
			int x=u[i],y=v[i];
			u[i]=scc[x],v[i]=scc[y];//缩点 
			if(scc[x]!=scc[y])w[i]-=mn[y];//修改边权 
		}n=cnt,rt=scc[rt];
	}
}
int main(){
	n=read(),m=read(),rt=read();
	fu(i,1,m){
		int x=read(),y=read(),z=read();
		add(x,y,z);
	}if(solve())printf("%lld\n",ans);
	else puts("-1");
	return 0;
}
```
#### 时间复杂度

每次找环缩点 $O(n+m)$, 可以看成 $O(m)$

最多缩点 $O(n)$ 次

故复杂度 $O(nm)$

---

## 作者：ljk123 (赞：3)

# 最小树形图(朱刘算法)学习笔记

蒟蒻理解不透彻的地方还请各位dalao多多包涵。

树形图，应该就是指能从根节点到达其他节点的有向的树形结构，

最小树形图则是权值和最小的树形图(~~废话~~)

一般来说,分为三步：

![过程](https://cdn.luogu.com.cn/upload/pic/22858.png)

1.选出每个点的最短边[同一个环中的不算]，并记录(为判环缩环作准备)。（若有点无最短边，则树形图无解）

2.判断最短边是否能构成环。（不能构成环则结束）

3.缩环为点。

1.
注:所选出的边可能不是一棵树
```cpp
cnt=0;
for(int i=1;i<=n;++i) ine[i]=inf,vis[i]=0,id[i]=0;//预处理
for(int i=1;i<=m;++i) if(q[i].x!=q[i].y&&ine[q[i].y]>q[i].c) ine[q[i].y]=q[i].c,pre[q[i].y]=q[i].x;//每个点的最短边
for(int i=1;i<=n;++i) if(i!=rt&&ine[i]==inf) return -1;//有点无最短边
```
2.
```cpp
for(int i=1;i<=n;++i){
    if(i==rt) continue;
    ans+=ine[i],t=i;//加贡献
    while(vis[t]!=i&&!id[t]&&t!=rt) vis[t]=i,t=pre[t];
    //能走到环的点或者换上的点停下
    if(!id[t]&&t!=rt){
          id[t]=++cnt; //将环上的点标记为新的环
          for(int o=pre[t];o!=t;o=pre[o]) id[o]=cnt;
    }
}//找环
if(!cnt) break;//无环结束
```
3.
```cpp
for(int i=1;i<=n;++i) if(!id[i]) id[i]=++cnt;
for(int i=1;i<=m;++i){
    t=q[i].y,q[i].x=id[q[i].x],q[i].y=id[q[i].y];
    if(q[i].x!=q[i].y) q[i].c-=ine[t];
}
n=cnt,rt=id[rt];
//去旧图,换新图
```

### 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=106,M=10006,inf=2e8;
int n,m,rt,t,cnt=0,id[N],pre[N],ine[N],vis[N];
struct line{int x,y,c;}q[M];
inline int read(){
   int T=0,F=1; char ch=getchar();
   while(ch<'0'||ch>'9'){if(ch=='-') F=-1; ch=getchar();}
   while(ch>='0'&&ch<='9') T=(T<<3)+(T<<1)+(ch-48),ch=getchar();
   return F*T;
}
int zl(){
    int ans=0;
    while(true){
         cnt=0;
         for(int i=1;i<=n;++i) ine[i]=inf,vis[i]=0,id[i]=0;//预处理
         for(int i=1;i<=m;++i) if(q[i].x!=q[i].y&&ine[q[i].y]>q[i].c) ine[q[i].y]=q[i].c,pre[q[i].y]=q[i].x;//每个点的最短边
         for(int i=1;i<=n;++i) if(i!=rt&&ine[i]==inf) return -1;//有点无最短边
         for(int i=1;i<=n;++i){
             if(i==rt) continue;
             ans+=ine[i],t=i;
             while(vis[t]!=i&&!id[t]&&t!=rt) vis[t]=i,t=pre[t];
             //能走到环的点或者换上的点停下
             if(!id[t]&&t!=rt){
                id[t]=++cnt; //将环上的点标记为新的环
                for(int o=pre[t];o!=t;o=pre[o]) id[o]=cnt;
             }
         }//找环
         if(!cnt) break;//无环结束
         for(int i=1;i<=n;++i) if(!id[i]) id[i]=++cnt;
         for(int i=1;i<=m;++i){
             t=q[i].y,q[i].x=id[q[i].x],q[i].y=id[q[i].y];
             if(q[i].x!=q[i].y) q[i].c-=ine[t];
         }
         n=cnt,rt=id[rt];
         //去旧图,换新图
    }
    return ans;
}
int main(){
    n=read(),m=read(),rt=read();
    for(int i=1;i<=m;++i) q[i].x=read(),q[i].y=read(),q[i].c=read();
    printf("%d\n",zl());
    return 0;
} 
```
### 拓展，无根树的最小树形图：
建一个超级源点，以他为根。




---

## 作者：GOD_hj (赞：2)

**这是一道关于 最小树形图（朱刘算法）的模板题**

---

## 题意
给定一张**有向图**，求出以给定节点 $r$ 为根的最小树形图。

最小树形图定义：一个有向图，存在从某个点为根的，可以**到达所有点的一个最小生成树**，则它就是最小树形图。

---

## 思路
- 步骤一：给当前图 $Q$ 中每一个点找一条最小的前驱边（除根外），如此贪心建一新图 $Q'$。
- 步骤二：判断 $Q'$ 中是否有环，若无，直接输出 $Q'$ 中所有边权之和，否则继续。
- 步骤三：将 $Q'$ 中的环对应到 $Q$ 中，中的环的边 $x$，$y$ 的权值都减去 &y& 的最小前驱边的权值。然后将 $Q'$ 中的环对应到 $Q$ 上进行缩点，将得到的新图代替 $Q$，回到步骤一。

![](https://cdn.luogu.com.cn/upload/image_hosting/fvj33wtp.png)

---

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e4+10;
static inline int read(){//快读 
	int x=0,f=1;char s=getchar();
	while(s<'0'||s>'9'){if(s=='-')f=-1;s=getchar();}
	while(s>='0'&&s<='9'){x=(x<<1)+(x<<3)+(s^48);s=getchar();}
	return x*f;
}
int n,m,r;
struct node{int from,to,w;}e[N];
int in[N],pre[N],id[N],vis[N];
static inline int zhuliu(int root){
	int res=0;
	while(1){
		memset(in,0x3f,sizeof in);//初始化 
		for(int i=1;i<=m;++i){//贪心建图 
			int u=e[i].from,v=e[i].to;
			if(u!=v&&in[v]>e[i].w){
				in[v]=e[i].w;
				pre[v]=u;
//				cout<<pre[v]<<endl;
			}
		}
		in[root]=0;//注意：得把在根去掉，调了好久 ！ 
		for(int i=1;i<=n;++i)//判断是否有单独点 
			if(i!=root&&in[i]==0x3f3f3f3f)
				return -1;
		int hs=0;//环的数量 
		memset(id,-1,sizeof id);
		memset(vis,-1,sizeof vis);
		for(int x,i=1;i<=n;++i){
			res+=in[i];x=i;
			/*
			找图中的有向环 三种情况会终止while循环  
            1,直到出现带有同样标记的点说明成环  
            2,节点已经属于其他环  
            3,遍历到根 
            */
			while(vis[x]!=i&&id[x]==-1&&x!=root){
				vis[x]=i;
				x=pre[x];
			}
			if(x!=root&&id[x]==-1){
				id[x]=++hs;
				for(int j=pre[x];j!=x;j=pre[j])//id用来存节点在那个环中 
					id[j]=hs;
			}
		}
		if(!hs) break;
		for(int i=1;i<=n;++i)
			if(id[i]==-1)
				id[i]=++hs;
		for(int i=1;i<=m;++i){
			e[i].w-=in[e[i].to];
			e[i].from=id[e[i].from];
			e[i].to=id[e[i].to];
		}
		n=hs;//回到步骤一 
		root=id[root];
	}
	return res;//所有边权之和 
}
signed main(void){
	n=read();m=read();r=read();
	for(int i=1;i<=m;++i){
		e[i].from=read();
		e[i].to=read();
		e[i].w=read();
	}
	int ans=zhuliu(r);
	printf("%d\n",ans);
	return 0;
}
```


---

## 作者：王大神——A001 (赞：2)

[传送门](https://www.luogu.com.cn/problem/P4716)

## 最小树形图

其实就是有向的 [最小生成树](https://wdsa001.github.io/2021/08/09/zui-xiao-sheng-cheng-shu/)。

从根节点，可以到达所有节点，那么可以形成很多树，走过的路径综合最小的就是最小树形图（有向图）。如果一条路都没有，就不能找出树形图，输出 $-1$。

不难发现，有很多种情况出现的原因是“环”的存在，所以要找最小树形图，就要不断找“环”，求出环的最优情况。不断缩点，就可以找到最小值了。（思想类似于发问题分成小问题，解决小问题就解决了问题）。

**注意：根节点是不能被指向的，因为那一定不优！**

### 朱刘算法

从小到大统计所有节点的理论最小值（别的点到达这一点的最小值）。同时根据统计的来的节点判断处理是否会形成环，如果形成环，缩点处理（贪心的处理，其实就是暴力找最小环）。

在所完后的时候，所有指向新点的边都要减去环中的最小边的值（类似于反悔贪心的思想）。

#### 代码实现思路
- 读入基本信息。

- 初始化基本信息。

- 记录到大每个点的最小权值（理论最小值）和从何来的点。

- 如果发现有断点（不能成树）直接返回 $-1$。

- 找到新环，统计权值（同时缩点）。

- 更新和新点有关的边。

- 继续找是否还有环。

- 更新点的数量（缩好的环上的点，全被“屏蔽”了）。

- 输出结果。

#### 代码
```cpp
#include<iostream>
#include<cstring>
#include<string>
#include<cstdio>
#include<algorithm>
#include<cctype>
using namespace std;
int r_r(){//快读 
	int x=0,f=1;
	char c=getchar();
	while(!isdigit(c)){
		if(c=='-')f=-1;
		c=getchar();
	}
	while(isdigit(c)){
		x=(x<<1)+(x<<3)+(c^48);
		c=getchar();
	}
	return x*f;
}
const int o_o=1e6+10;
const int m_a=1e9+10;
int n,m;
int g_g;//根节点  
long long a_s;
struct po{
	int u;//从而来的点 
	int v;//去往的点 
	int w;//权值 
}p_p[o_o];
int x_p;//当前图环的数量 
int i_d[o_o];//每个点的新节点编号 
int t_p[o_o];//链头 
int f_a[o_o];//到当前节点最小值的路径是由哪个点提供的 
int m_i[o_o];//到当前节点的理论最小值 
int g_a(){
    while(1){
        for(int i=1;i<=n;++i){//初始化 
        	i_d[i]=t_p[i]=0;
			m_i[i]=m_a;
		}
        for(int i=1;i<=m;++i)//遍历每条边 
            if(p_p[i].u!=p_p[i].v&&p_p[i].w<m_i[p_p[i].v]){//不是自环并且到其他节点的值更优 
            	f_a[p_p[i].v]=p_p[i].u;//更新来的路径节点 
				m_i[p_p[i].v]=p_p[i].w;//更新最小值 
			}
        int k_k=m_i[g_g]=0;//初始化根节点 
        for(int i=1;i<=n;++i){//枚举节点 
            if(m_i[i]==m_a)return 0;//不连通 
            a_s+=m_i[i];//统计所有点的理论最小值 
            for(k_k=i;k_k!=g_g&&t_p[k_k]!=i&&!i_d[k_k];k_k=f_a[k_k])//非链顶节点向上爬，不在环中 
				t_p[k_k]=i;//更新链顶 
            if(k_k!=g_g&&!i_d[k_k]){//不是根节点并且不在环中 
                i_d[k_k]=++x_p;//开新点（缩点） 
                for(int j=f_a[k_k];j!=k_k;j=f_a[j])i_d[j]=x_p;//更新环上的节点的新节点 
            }
        }
		if(!x_p)return 1;//没有点了 
        for(int i=1;i<=n;++i)if(!i_d[i])i_d[i]=++x_p;//节点没有在环内的，自己开新点 
        for(int i=1;i<=m;++i){//枚举所有边 
            int l_t=m_i[p_p[i].v];//记录当前边通向的节点的理论最小值 
            if((p_p[i].u=i_d[p_p[i].u])!=(p_p[i].v=i_d[p_p[i].v]))p_p[i].w-=l_t;//不在一个环中更新边的价值 
		}
		n=x_p;//更新点的数量 
		g_g=i_d[g_g];//更新根节点 
		x_p=0;//初始化环编号 
    }
}
int main(){
    n=r_r();m=r_r();g_g=r_r();
    for(int i=1;i<=m;i++){//读入存边 
    	p_p[i].u=r_r();
    	p_p[i].v=r_r();
    	p_p[i].w=r_r();
	}
    if(g_a())printf("%lld",a_s);//输出结果 
    else puts("-1");
    return 0;
}
```

### 左偏树优化

为了快速找到最小入边 （[左偏树](https://wdsa001.github.io/2021/12/17/zui-xiao-shu-xing-tu-zuo-pian-shu/#toc-heading-6)）。

#### 优化的代码思路
主要思路（这里的图为了描述边是按照从小到大得权值判断的，画的过程有些夸张，实际上，会直接找到第一小的环处理）：

![主要过程](https://s4.ax1x.com/2021/12/17/TkcJ0K.png)

同样是反悔贪心的思想。

- 读入信息并初始化所有信息。

- 度读入时，将所有可以到当前点的点和权值存入以当前节点为根的左偏树中。（主要优化取点）。

- 这样根据边权值找新环，缩点，统计。

- 更新和新点有关的边的权值。

- 当所有点都处理后，输出结果即可。

#### 优化后代码
~~没有指针！~~

```cpp
#include<iostream>
#include<cstring>
#include<string>
#include<cstdio>
#include<algorithm>
#include<cctype>
using namespace std;
int r_r(){//快读 
	int x=0,f=1;
	char c=getchar();
	while(!isdigit(c)){
		if(c=='-')f=-1;
		c=getchar();
	}
	while(isdigit(c)){
		x=(x<<1)+(x<<3)+(c^48);
		c=getchar();
	}
	return x*f;
}
const int o_o=1e5+10;
int f_a[o_o];//存父节点 
int x_p;//开新点的编号 
int b_b[o_o];//点是否被遍历过 
struct po{
	int l,r;//左右子树 
	int d;//深度 
	int v_l;//边权 
	int l_n;//懒标记，到点的最小值。所有相关的边都要减。 
	int u;//从哪个点来的 
	po(){//初始化 
		int l=0,r=0;
		int d=-1;
		int v=0;
		int l_n=0;
		int u=0;
	} 
}t_r[o_o];
int g_g[o_o];//每个点多可以成为临时根节点（环的“根”） 
void b_g(int&x,int&y){//小根堆合并 
	if(!x||!y){//有一个树是空 
		x^=y;//直接更新 
		return;
	}
	if(t_r[x].v_l>t_r[y].v_l)swap(x,y);//保证主树干“粗” 
	t_r[y].l_n-=t_r[x].l_n;//更新懒标记 
	t_r[y].v_l+=t_r[x].l_n;//更新权值 
	b_g(t_r[x].r,y);//继续合并右子树 
	if(t_r[t_r[x].l].d<t_r[t_r[x].r].d)swap(t_r[x].l,t_r[x].r);//保证左子树深度大 
	t_r[x].d=t_r[t_r[x].r].d+1;//深度更新 
}
int f(int x){//找父节点 
	if(f_a[x]==x)return x;
	return f_a[x]=f(f_a[x]);
}
void g_f(int u,int v){ 
	if((u=f(u))!=(v=f(v))){//是否公共祖先 
		b_g(g_g[v],g_g[u]);//合并小根堆 
		f_a[u]=v;//公共祖先 
	}
}
void p_d(int&k){//懒标记下传 
	t_r[t_r[k].l].l_n+=t_r[k].l_n;
	t_r[t_r[k].r].l_n+=t_r[k].l_n;
	
	//更新边权 
	t_r[t_r[k].l].v_l-=t_r[k].l_n;
	t_r[t_r[k].r].v_l-=t_r[k].l_n;
	t_r[k].l_n=0;//清空标记 
}
void x_y(int&x){//将右子树并到左子树中 
	p_d(x);//释放懒标记 
	b_g(t_r[x].l,t_r[x].r);//将右子树并到左子树中 
	x=t_r[x].l;//更新根节点 
}
int t_p(int&x){
	while(g_g[x]&&f(t_r[g_g[x]].u)==x)x_y(g_g[x]);//将右子树并到左子树中 
	if(!g_g[x]){//不存在根节点 
		puts("-1");//图不连通 
		exit(0);//结束运行 
	}
	t_r[g_g[x]].u=f(t_r[g_g[x]].u);
	//更新来的点（直接更新记录“根节点”即可）已经将环缩成点了 
	
	return g_g[x];//返回根节点序号 
}
int i_n[o_o];//到当前点的点 
int main(){
	int n=r_r(),m=r_r(),r=r_r();//读入 
	int a_s=0;//初始化 
	x_p=n;//初始化点的个数 
	b_b[r]=r;//标记 
	for(int i=1;i<=m;++i){
		int u=r_r(),v=r_r(),w=r_r();//读入 
		t_r[i].v_l=w;//记录价值 
		t_r[i].u=u;//记录来点 
		t_r[i].d=0;//更新深度 
		int k_k=i;//临时标记（防止合并时更新 i 的值，导致无限循环） 
		b_g(g_g[v],k_k);//当前节点加入到目标小根堆中 
	}
	int k_k;//临时变量，存根节点编号 
	for(int i=1;i<=n<<1;++i)f_a[i]=i;//初始化父节点 
	for(int i=1,j=i;i<=n;j=++i)//枚举节点 
		while(!b_b[j]){//点未遍历过 
			while(!b_b[j]){//点未遍历过 
				b_b[j]=i;//标记 
				k_k=t_p(j);//记录根节点编号 
				j=t_r[k_k].u;//爬向来的节点（往回爬） 
				a_s+=t_r[k_k].v_l;//统计权值 
			}
			if(b_b[j]!=i)break;//不是同一个环了，结束 
			while(b_b[j]>=0){
				b_b[j]=-1;//标记 
				k_k=t_p(j);//记录根节点编号 
				j=i_n[j]=t_r[k_k].u;//往回爬并记录 
				
				t_r[k_k].l_n+=t_r[k_k].v_l;
				//更新懒标记，边的理论最小值（懒标记更新为负数） 
				//代表每个相关联的边要减去的量 
				
				t_r[k_k].v_l=0;//更新边的价值 
			}
			++x_p;//开新点（缩环后的点） 
			while(b_b[j]==-1){//恢复标记，善后 
				b_b[j]=i;//更新环标记 
				g_f(j,x_p);//新节点连入树中，在树上建立“坐标”
				j=i_n[j];//上爬 
			}
			j=x_p;//下回更新新点 
		}
	printf("%d",a_s);//输出结果 
	return 0;
}
```



---

## 作者：灰原 (赞：0)

做法其他题解已有，但为什么最小树形图不能用Prim呢（个人感觉是个裸的最小生成树）：

Prim是贪心，及当前所连通的点所连出去的边中，最短且能连接新点的一定是最优的。

那为什么有向就不行了呢？

对于无向图的Prim：连了就是连了，如果还要绕过当前最小的边再去连那个点，一定会亏，也浪费路径，证明是将这条边放到假设的最小生成树中去替代边，发现产生了更小生成树（滑稽），故证。


有向图：对于当前最小边要连的点而言一定最优，但由于有向，使得选了当前点后其它点的可能性被扼杀.由于图是有向的，这并不满足Prim证明中的替代边，因为替代了边之后将会引起连锁效应，即一些点的到达路径更改等（无向就不会，它不会管你从哪儿来，它只管连不连），而这时并不能保证最小


hack数据：1为根——

1 2 8

1 3 9

2 3 5

3 2 3

解释：1到2之间连一条距离为8的边，其余类似，可手动模拟Prim，正确答案：12

至今不会正确的换行方式……

---

## 作者：maomao9173 (赞：0)

[更好的阅读体验$Click$  $Here$](https://www.cnblogs.com/maomao9173/p/10780452.html)

不知道有什么用的一个东西。本来不打算再大量扩知识点了但还是学一下好了，反正也不难。

原理：树上父亲唯一，每次选最短的父边。

此时会有两类情况：

- 就这样正常连下去，这样我们就得到了一个尽可能小的树形图。

- 成环。这种情况下我们需要拆掉环里的一条边换成其他的边。

我们记录一下到达每个点的最短父边权值是多少。对于成环的情况，可以先把环里面所有边的权值选上，把环里面的所有点看成一个。然后等到有其它外来的边连进来的时候，再选一个最小的外来边，去掉环里面原先所暂时使用的边，换成外来的那个，就这样一直求解直到不再有环。

```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;
const int N = 100 + 5;
const int M = 10000 + 5;
const ll INF = 0x3f3f3f3f;

int n, m, r;

struct edge {int u, v, w;} e[M];

int fa[N], id[N], top[N], minw[N];

ll get_ans (int n, int m) {
	ll ans = 0;
    while (true) {
    	int cnt = 0;
		for (int i = 1; i <= n; ++i) {
			id[i] = top[i] = 0; minw[i] = INF;
		}
        for (int i = 0; i < m; ++i) {
        	if (e[i].u != e[i].v && e[i].w < minw[e[i].v]) {
            	fa[e[i].v] = e[i].u;
				minw[e[i].v] = e[i].w;
            }
        }
        minw[r] = 0;
        for (int i = 1; i <= n; ++i) {
            if (minw[i] == INF) return -1;
            ans += minw[i];
            int u = i;
			while (u != r && top[u] != i && !id[u]) {
				top[u] = i;
         		u = fa[u];
		    }
            if (u != r && !id[u]) {
                id[u] = ++cnt;
                for (int v = fa[u]; v != u; v = fa[v]) id[v] = cnt;
            }
        }
		if (cnt == 0) return ans;
        for (int i = 1; i <= n; ++i) {
			if (!id[i]) id[i] = ++cnt;
		}
		for (int i = 0; i < m; ++i) {
            int prew = minw[e[i].v];
            e[i].u = id[e[i].u];
            e[i].v = id[e[i].v];
            if (e[i].u != e[i].v) {
				e[i].w -= prew;
			}
        }
		n = cnt; r = id[r];
    }
}

int main () {
	cin >> n >> m >> r;
    for (int i = 0; i < m; ++i) {
    	static int u, v, w;
    	cin >> u >> v >> w; 
		e[i] = (edge) {u, v, w};
	}
	cout << get_ans (n, m) << endl;
}
```

以及非常感谢 @旋转卡壳 的代码。仅仅是读注释就可以快速理解整个算法的流程。（虽然代码不加空格$www$）

---


# [BalkanOI 2018] Parentrises

## 题目描述

**翻译自 [BalkanOI 2018](http://boi2018.ro) Day2 T1「[Parentrises](http://boi2018.ro/assets/Tasks/BOI/Day_2/parentrises/parentrises_en.pdf)」**

**「括号串」**是一个仅由 `(` 和 `)` 构成的字符串。如果在括号串中插入一些 `1` 和 `+` 可以将其转化为正确的表达式，该字符串就是一个**「良括号串」**。例如，`(())` 和 `(())` 是良括号串，而 `)(` 和 `(` 不是。空字符串可视为良括号串。（就是你们学 Catalan 数时学的那个啊）  
将一个**括号串**（不是良括号串）的每个括号都涂成红绿蓝三种颜色之一，如果有一种方案同时满足：
+ 忽略该串的所有蓝色括号后它是**良括号串**；
+ 忽略该串的所有红色括号后它是良括号串；

该串就是 **RGB 可读**的。  

你会接到两类任务之一。任务类型用一个整数 $P$ 表示，$P=1$ 或 $2$。

* $P=1$：你会接到 $T$ 组询问，每组询问包含一个括号串，试问该串是否 RGB 可读，如果是，请输出一种染色方案，如果否请输出 `impossible`；
* $P=2$：你会接到 $T$ 组询问，每组询问包含一个数 $N$，试求：有多少个长度为 $N$ 的 RGB 可读的良括号串。输出答案模 $(10^9+7)$ 的结果。

## 说明/提示

样例 $1$ 解释：

对于查询 1，忽略原串的所有蓝色括号后它变为 `()()`；忽略原串的所有红色括号后它也变为 `()()`。
对于查询 2，忽略原串的所有蓝色括号后它变为 `()`；忽略原串的所有红色括号后它变为 `()()`。

$P = 1$：  
设 $L$ 为字符串总长。  
* 子任务 #1（5 分）：$1 ≤ T ≤ 5,$ $1 ≤ len(S) ≤ 13$。  
* 子任务 #2（11 分）：$1 ≤ L ≤ 100$。  
* 子任务 #3（6 分）：$1 ≤ L ≤ 1000$。  
* 子任务 #4（28 分）：$1 ≤ L ≤ 10^6$。

$P = 2$：
* 子任务 #5（6 分）：$1 ≤ N, T ≤ 15$。  
* 子任务 #6（16 分）：$1 ≤ N, T ≤ 30$。  
* 子任务 #7（28 分）：$1 ≤ N, T ≤ 300$。

感谢 Planet6174 提供的翻译

## 样例 #1

### 输入

```
1
3
())(()
()(()
()))```

### 输出

```
GRBRBG
BBRBG
impossible```

## 样例 #2

### 输入

```
2
2
6
100```

### 输出

```
12
959772055```

# 题解

## 作者：XL4453 (赞：1)


[小 广 告](https://www.luogu.com.cn/blog/JSYZCHTHOLLY/)

------------
**题意简述：**

1. 给出良括号串的定义，原文中是这样说的：
		
        「括号串」是一个仅由 ( 和 ) 构成的字符串。如果在括号串中插入一些 1 和 + 可以将其转化为正确的表达式，该字符串就是一个「良括号串」。

	其实就是就是每一个后括号都有且仅有唯一的前括号与之对应。

2. 给出“ $RGB$可读 ”的定义，原文中是这样说的：
		
        将一个括号串（不是良括号串）的每个括号都涂成红绿蓝三种颜色之一，如果有一种方案同时满足：
    	忽略该串的所有蓝色括号后它是良括号串；
    	忽略该串的所有红色括号后它是良括号串；
    
   挺清楚的了。
   
3. 给出两类任务：
	
    一个是询问一个串是否 $RBG$可读。
    
    另一个是询问有多少个长度为N的串是 $RBG$可读的。
    
（细节还请看原文）

------------
**题目分析：**

首先根据题意，可以用一种类似于栈的方式来模拟括号，即当有一个前括号，将其进栈，若有一个后括号，将一个前括号退栈。有色括号也是类似，这里不多讲。

考虑第一问，有一个不算难的 $Dp$（注：这个 $Dp$ 仅为辅助分析，能直接想到贪心更好），可以设 $f(i,j,k)$ 表示考虑到第i个括号，其中对于忽略蓝括号栈中有j个括号，忽略红括号栈中有k个括号。对于一个前括号，将其分别涂成红绿蓝并扩展，最终答案就是 $f(n,0,0)$ ，比较简单，也不多说。（我相信你们都会 $QwQ$ ）

观察这个 $Dp$ ，其实可以想到考虑对于每一个括号，给其$1$或$2$的权值，最后将所有前括号的权减去后括号的权，若结果为$0$则可行。

可以这样理解：若当前括号设置为绿色，那么也就相当于将红蓝两个括号栈中个加入（如果是后括号就弹出）一个括号，一共造成了“两点影响”（姑且让我这么说说罢），而如果是红蓝括号，他们一共只能对他们自己所在的栈造成“一点影响”，所以权值只有1。

值得注意的是，这里的红蓝括号是放在一起考虑的，也就是先确定这个括号是红蓝的还是绿的，然后考虑他到底是红的还是蓝的，这一部分理解可能有偏差。

那么此时，一个贪心想法已经产生了，可以维护当前获得的最大和最小前括号权值数，因为若最小权值都无法达到0，那么就会出现后括号过少，导致最终有前括号剩余的情况，而如果最大权数在某一时刻小于0了，那么一定会出现某一个时刻前括号太少，导致后括号要求前括号退栈时前括号不够用的情况。

想通了这个，具体操作也并不是很难，扫描到前括号时，最大加2，最小加1；扫描到后括号时，最大减1，最小减二。同时，若最小权小于0，那么将其重设为0，毕竟没有办法欠括号（手动滑稽）。

----------------------------------

然后考虑如何把方案倒腾出来。

方法是把之前判断时用的最大权提出来，从后往前扫描，把每最大权个前括号变成红蓝括号，其他前括号都是绿的。然后从前往后扫一直扫到从后往前扫的最后一个位置，将这个里面的所有后括号变成红蓝括号。

原因是这样的：还是用贪心的思想，最多权意味着最后栈中还剩下这么多个前括号，那么把这么多绿色的前括号（在贪心里就是这样做的）变成红蓝括号，或把等量的红蓝后括号变成绿括号就可以使得最终权值为0了。其余的，也就是“到从后往前扫的最后一个位置”之前，就直接按照贪心里的做就可以了。

当然，求解方法不唯一，这种比较好理解罢了（其实是我菜）。

------------

继续考虑第二问，根据上面的可行性贪心，设计出一个这样的 $Dp$。

设 $f(i,j,k)$ 表示考虑到第 $i$ 位，最少前括号权为 $j$，最大前括号权为 $k$ 有多少种方案（还是贪心里的那些），转移分成前后括号，写法和贪心里的思路差不多。这不是重点，也就不详细说了。实在不懂可以翻代码，那一部分有注释。

------------
吐槽一下 $300ms$ 的时间限制。这道题需要加上一些卡常的小技巧，比如 namespace ，快读快数等，实在不行就多交几次，机子状态好说不定就放你过了。

----

Update：2021.10.5，修了一个小锅。

------------
代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int kind,T,ans[1000006],n;
namespace Task1{
	char s[1000006];
	int ch,now;
	int check(){
		int d=0,u=0;
		for(int i=1;i<=n;i++){
			if(s[i]=='('){
				d+=1;u+=2;
			}
			else{
				d-=2;u-=1;
				if(d<0)d=0;
				if(u<0)return -1;
			}
		}
		if(d>0)return -1;
		return u;
	}
	void work(){
		scanf("%s",s+1);
		n=strlen(s+1);
		ch=check();
		if(ch==-1){
			printf("impossible\n");
			return;
		}
		for(int i=1;i<=n;i++)ans[i]=0;
//		不可以用memset，在这里他会很慢 
		now=-1;
		if(ch)
		for(int i=n;i>=1;i--){
			if(s[i]=='('){
				ans[i]=now;
				now=-now;
			}
			else ans[i]=2;
			ch--;
			if(!ch)break;
		}
		now=-1;
		for(int i=1;i<=n;i++){
			if(s[i]==')'){
				if(ans[i]==2)break;
				ans[i]=now;
				now=-now;
			}
		}
		for(int i=1;i<=n;i++){
			if(ans[i]==1)printf("R");
			else if(ans[i]==-1)printf("B");
			else printf("G");//注意这里不一定是2，有可能是没打标记的前括号（以我的写法） 
		}
		printf("\n");
	}
	void work1(){
		while(T--)work();
	}
};
namespace Task2{ 
	const int MOD=1e9+7;
	int f[305][305][605];//注意这里最好不要定义到外面，开数组可是要时间的，可能会TLE 
	void work2(){
		f[0][0][0]=1;
		for(int i=0;i<=299;i++){//直接把所有的都跑出来然后应付询问，一次性处理 
			for(int j=0;j<=i;j++)
			for(int k=0;k<=2*i;k++){
				f[i+1][j+1][k+2]=(f[i+1][j+1][k+2]+f[i][j][k])%MOD;//下一个是前括号 
				if(k!=0)//下一个是后括号 
				f[i+1][max(j-2,0)][k-1]=(f[i+1][max(j-2,0)][k-1]+f[i][j][k])%MOD;
			}
			for(int j=0;j<=2*i;j++)
			ans[i+1]=(ans[i+1]+f[i+1][0][j])%MOD;//仅收录有效方案 
		}
		while(T--){
			scanf("%d",&n);
			printf("%d\n",ans[n]);
		}
	}
};
int main(){
	scanf("%d%d",&kind,&T);
	if(kind==1)Task1::work1();
	else Task2::work2();
	return 0;
}
```


---

## 作者：LCuter (赞：0)

二合一题，先解决 $P=1$ 的情况。

考虑 $\mathtt{R,B}$ 的作用：将两个相同字符缩为一个。首先如果这两个字符连续，显然成立；否则形如 $\mathtt{()S)}$，对于两个右括号，要么形成 $\mathtt{(S)}$ 要么形成 $\mathtt{()S}$，其可行性都仅与 $\mathtt{S}$ 有关。

于是我们可以先将匹配的子段设为 $\mathtt{G}$，然后会剩下 $\mathtt{))\ldots((}$，让它们尽可能与已被设为 $\mathtt{G}$ 的字符匹配即可。

现在考虑 $P=2$ 的情况。一个想法是，枚举剩下的 $\mathtt{))\ldots((}$，往其中插入匹配括号串，这可以分为两个等价的部分计算。

设 $f(i,j)$ 表示在 $j$ 个 $\mathtt{)}$ 前插入总长度为 $i$ 的匹配串括号串数量，$g(i)$ 表示长度为 $i$ 的匹配串数量，则有：
$$
g(n)=[n\bmod{2}=0]\frac{\binom{n}{n/2}}{n/2+1}
$$
当 $2j\le i$ 时，有：
$$
f(i,j)\leftarrow f(k,j-1)\times g(i-k)
$$
设 $h(i)=\sum_{j\ge 1}f(i-j,j)$，于是答案为：
$$
\sum_{i+j+k=n}^{}h(i)h(j)g(k)
$$
时间复杂度 $O(n^3)$。

---


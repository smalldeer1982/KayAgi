# LJJ爱数书

## 题目背景

题解请查看[https://www.cnblogs.com/Blog-of-Eden/p/9367521.html](https://www.cnblogs.com/Blog-of-Eden/p/9367521.html)

## 题目描述

LJJ的家里有一本“数书”，也就是说里面全都是数字的书，LJJ十分喜爱它。
数书里有一个序列A，每次操作可以**使一段连续的区间加1或减1**并**对K取模**（K-1加1后变为0，0减1后变为K-1），我们定义**和谐函数F(A,K)表示最少的操作次数，使得序列的所有元素都变为0**。
例如A={3,3,2,3}，K=4时，通过把A变成{0,0,3,0}，再把A变成{0,0,0,0}就能达到要求，所以F(A,K)=2。

现在，输入长度为**n（n<=200000）**的序列A，设A[L][R]表示序列A第L个位置到第R个位置的连续子序列。
 有**m（m<=100000）**次询问，每次询问**输入L,R,K**，求**F(A[L][R],K)的值**。

**注：数据保证K>Max{A[1],A[2],....,A[n]}。**

## 说明/提示

数据保证每组询问的K>Max{A[1],A[2],....,A[n]}。

10%：n<=10，m=1，K<=10

30%：n<=1000，m=1，K<=2^30

50%：n<=200000，m=1，K<=2^30

另有10%数据：n<=200000，m<=100000，K=2

另有20%数据：n<=30000，m<=30000，K<=2^30

100%：n<=200000，m<=100000，K<=2^30

## 样例 #1

### 输入

```
7 2
8 8 8 0 8 8 8
1 7 9
3 5 17```

### 输出

```
2
16```

## 样例 #2

### 输入

```
4 1
5 3 8 2
1 4 9```

### 输出

```
8```

## 样例 #3

### 输入

```
10 10
7 7 6 5 5 2 8 5 0 3 
1 8 11
3 10 11
4 7 12
9 10 12
3 5 10
2 7 10
7 9 10
2 7 11
1 4 11
4 7 10
```

### 输出

```
12
15
9
3
5
8
5
9
6
7
```

# 题解

## 作者：Rorschachindark (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P4846)
# Description
对于一个序列 A ，我们定义 $f(A,k)$ 表示在模 $k$ 意义下 A 序列对于一段连续区间 $+1$ 或 $-1$ 使得 A 序列所有元素皆为 $0$ 的最少操作步数。

现在给出一个长度为 $n$ 的 $a_{1,2,...,n}$ 序列，有 $m$ 次查询，每次给出 $l,r,k$，表示需要查询 $f([l,r],k)$。

$n\le 2\times 10^5,m\le 10^5,\max\{a_1,a_2,...,a_n\}<k\le 2^{30}$
# Solution
>
出题人：唯一一道数据结构题，所以思路不是那么难。只要你会50分，就可以轻松优化到100分。

我表示我™想不到 $50$ 分做法，看了题解之后才恍然大悟。

这篇题解又跟官方题解有所不同，但是整体思路差不多，代码实现要简单一些。

我们首先考虑一个序列的情况。我们先在首尾加 $0$。假如没有模 $k$ 的条件的话，我们设 $b_i=a_i-a_{i-1}$，那么问题就相当于 $\sum b_i=0$，每次可以对于 $b_i\to b_i+1,b_j\to b_j-1(i<j)$，问最小步数使得所有 $b_i$ 皆为 $0$ 。

不难看出，因为 $\sum b_i=0$，所以如果现在还没有满足条件，那么，一定有 $b_i>0$ 且 $b_j<0$，所以可以想到，答案就是 $(\sum|b_i|)/2$ 。

考虑有模 $k$ 的条件，那么，我们可以看成是一开始序列某些值 $+k$ 或 $-k$。可以看出，$\sum b_i$ 仍需等于 $0$，所以你一个数 $+k$，那么必有另外一个数 $-k$。另外可以看出的是，对于 $-a$，如果你加 $k$，那么贡献就会减少 $2a-k$，对于 $a$，如果你减 $k$ ，那么贡献也会减少 $2a-k$。这个时候我们就可以做到 $50$ 分了，就是直接每次直接把 $2a-k$ 提出来排个序求前缀和，然后求个最大值即可。

考虑优化，不难看出，我们可以使用主席树维护一个区间 $|2a|$ 的前 $s$ 大的和。也就是说，如果我们知道我们要加多少次 $s$ ，我们就可以计算出贡献。

我们可以看出的另一个性质是，这个贡献随 $s$ 的变化实际上是一个凸函数，所以我们二分顶点，证明的话应该可以感性理解一下。

时间复杂度 $\Theta(n\log w+m\log n\log w)$，其中 $w$ 是值域，$\log w=30$。
# Code for 50 pts
```cpp
#include <bits/stdc++.h>
using namespace std;

#define Int register int
#define int long long
#define MAXN 200005

template <typename T> inline void read (T &t){t = 0;char c = getchar();int f = 1;while (c < '0' || c > '9'){if (c == '-') f = -f;c = getchar();}while (c >= '0' && c <= '9'){t = (t << 3) + (t << 1) + c - '0';c = getchar();} t *= f;}
template <typename T,typename ... Args> inline void read (T &t,Args&... args){read (t);read (args...);}
template <typename T> inline void write (T x){if (x < 0){x = -x;putchar ('-');}if (x > 9) write (x / 10);putchar (x % 10 + '0');}

int n,m,A[MAXN],pre1[MAXN],pre2[MAXN];

#define abs(x) ((x)<0?-(x):(x))
int Count (int L,int R,int K){
	int ans = abs (A[L]) + abs (A[R]);
	for (Int i = L + 1;i <= R;++ i) ans += abs (A[i] - A[i - 1]);
	int tot1 = 0,tot2 = 0;
	if (A[L] < 0) pre1[++ tot1] = 2 * abs(A[L]) - K;else pre2[++ tot2] = 2 * abs(A[L]) - K;
	if (A[R] > 0) pre1[++ tot1] = 2 * abs(A[R]) - K;else pre2[++ tot2] = 2 * abs(A[R]) - K;
	for (Int i = L + 1;i <= R;++ i) 
		if (A[i] - A[i - 1] < 0) pre1[++ tot1] = 2 * abs(A[i] - A[i - 1]) - K;
		else pre2[++ tot2] = 2 * abs (A[i] - A[i - 1]) - K; 
	sort (pre1 + 1,pre1 + tot1 + 1,[](int a,int b){return a > b;}),
	sort (pre2 + 1,pre2 + tot2 + 1,[](int a,int b){return a > b;});
	for (Int i = 1;i <= tot1;++ i) pre1[i] += pre1[i - 1];
	for (Int i = 1;i <= tot2;++ i) pre2[i] += pre2[i - 1];
	int res = ans;
	for (Int i = 1;i <= tot1 && i <= tot2;++ i) res = min (res,ans - pre1[i] - pre2[i]);
	return res >> 1;
}

signed main(){
	read (n,m);
	for (Int i = 1;i <= n;++ i) read (A[i]);
	for (Int i = 1,l,r,k;i <= m;++ i) read (l,r,k),write (Count (l,r,k)),putchar ('\n');
	return 0;
}
```
# Code for 100 pts
```cpp
#include <bits/stdc++.h>
using namespace std;

#define Int register int
#define int long long
#define MAXN 200005

template <typename T> inline void read (T &t){t = 0;char c = getchar();int f = 1;while (c < '0' || c > '9'){if (c == '-') f = -f;c = getchar();}while (c >= '0' && c <= '9'){t = (t << 3) + (t << 1) + c - '0';c = getchar();} t *= f;}
template <typename T,typename ... Args> inline void read (T &t,Args&... args){read (t);read (args...);}
template <typename T> inline void write (T x){if (x < 0){x = -x;putchar ('-');}if (x > 9) write (x / 10);putchar (x % 10 + '0');}

int n,m,inf,A[MAXN],pre[MAXN];

#define abs(x) ((x)<0?-(x):(x))

struct Segment{
#define LOGN 105
	int tot,rt[MAXN],siz[MAXN * LOGN],sum[MAXN * LOGN],son[MAXN * LOGN][2];
	void modify (int &x,int y,int l,int r,int pos){
		x = ++ tot,siz[x] = siz[y] + 1,sum[x] = sum[y] + pos,son[x][0] = son[y][0],son[x][1] = son[y][1];
		if (l == r) return ;
		int mid = (l + r) >> 1;
		if (pos <= mid) modify (son[x][0],son[y][0],l,mid,pos);
		else modify (son[x][1],son[y][1],mid + 1,r,pos);
	}
	int query (int x,int y,int l,int r,int k,int pos){
		if (!k) return 0;
		if (l == r) return k * l;
		int mid = (l + r) >> 1,alls = siz[son[y][1]] - siz[son[x][1]] + (mid < pos && pos <= r);
		if (alls <= k) return query (son[x][0],son[y][0],l,mid,k - alls,pos) + sum[son[y][1]] - sum[son[x][1]] + (mid < pos && pos <= r) * pos;
		else return query (son[x][1],son[y][1],mid + 1,r,k,pos);
	}
}Tree[2];

int Count (int l,int r,int k,int S){
	int ans = (pre[r] - pre[l] + A[l] + A[r]) / 2;
	return S * k + ans - Tree[0].query (Tree[0].rt[l],Tree[0].rt[r],0,inf,S,A[r]) - Tree[1].query (Tree[1].rt[l],Tree[1].rt[r],0,inf,S,A[l]); 
}

int Work (int l,int r,int K){
	int tot1 = Tree[0].siz[Tree[0].rt[r]] - Tree[0].siz[Tree[0].rt[l]] + 1,tot2 = Tree[1].siz[Tree[1].rt[r]] - Tree[1].siz[Tree[1].rt[l]] + 1;
	int L = 0,R = min (tot1,tot2),ans = 0;
	while (L <= R){
 		int mid = (L + R) >> 1;
		if (mid == 0 || Count (l,r,K,mid - 1) >= Count (l,r,K,mid)) ans = mid,L = mid + 1;
		else R = mid - 1;
	}
	return Count (l,r,K,ans);
}

signed main(){
//	freopen ("data.in","r",stdin);
//	freopen ("WA.out","w",stdout);
	read (n,m),inf = 1 << 30;
	for (Int i = 1;i <= n;++ i) read (A[i]);
	for (Int i = 2,val;i <= n;++ i){
		val = abs (A[i] - A[i - 1]),pre[i] = pre[i - 1] + abs (A[i] - A[i - 1]);
		if (A[i] >= A[i - 1]) Tree[0].rt[i] = Tree[0].rt[i - 1],Tree[1].modify (Tree[1].rt[i],Tree[1].rt[i - 1],0,inf,val);
		else Tree[1].rt[i] = Tree[1].rt[i - 1],Tree[0].modify (Tree[0].rt[i],Tree[0].rt[i - 1],0,inf,val); 
	}
	for (Int i = 1,l,r,k;i <= m;++ i) read (l,r,k),write (Work (l,r,k)),putchar ('\n');
	return 0;
}
```

---

## 作者：FQ04gty (赞：0)

##### [原题链接](https://www.luogu.com.cn/problem/P4846)

---

看到区间修改，我们首先想到将其差分。

那么问题转变成：

在一个序列中，每次将一个元素 $+1$ 并将另一个元素 $-1$，或者将一个元素 $+1$ 或 $-1$，使其能够满足所有元素为对 $k$ 取模为 $0$。

我们设 $a$ 的差分序列为 $b$，可以发现，每次询问 $l$、$r$ 所问的序列，就是 $a_l,b_l+1,\cdots,b_r$。

由于 $0\leq a_i<k$ 而 $-k<b_i<k$，所以最后元素的值只有可能是 $-k$、$0$ 或 $k$。

我们设上面询问的序列为 $c$。

可以发现，我们一定可以找到一个分界点 $mid$，使得对于 $0<c_i\leq mid$  和 $-k\leq c_i\leq-k+mid$ 分别最终变成 $0$ 和 $-k$，而对于 $mid<c_i\leq k$ 和 $-k+mid<c_i<0$ 的元素分别变成 $0$ 和 $k$。

理由如下：

我们把 $c$ 中的所有元素对 $k$ 取模之后放在数轴上，如果有两个元素 $u$、$v$ 满足 $u$ 离左边的 $0$ 近，$v$ 离右边的 $k$ 近，我们当然要使 $u$ 成为 $0$，$v$ 成为 $k$。

二分找到分界线之后，我们可以发现：

最终的答案为 $max(\sum_{c_i\bmod k\leq mid} c_i\bmod k,\sum_{c_i \bmod k>mid} k-(c_i\bmod k))$。

也就是将二者步数的公共部分配对，剩下的部分单独操作。

那么最优的分界线应当让两侧的步数尽可能相等。

这样，每次询问就可以用二分和可持久化权值线段树实现。

总时间复杂度 $O(n\log^2 n)$。

##### 实现细节

第一个元素 $a_l$ 需要单独计算。

找到分界线之后，注意分界线上的值相同的元素可以被分别划分到左右两侧，这也要单独计算。

### Code

```cpp
#include<cstdio>
#define mid ((l+r)/2)
#define v(x) (x+HALF)
using namespace std;
typedef long long ll;
const ll SIZE=2e5+10,EXTRA=1e7+10,HALF=1e9,MAXV=2e9;
inline ll read()
{
    ll x=0;char ch=getchar();
    while(ch<'0'||ch>'9')ch=getchar();
    while(ch>='0'&&ch<='9')x=(x*10)+(ch^48),ch=getchar();
    return x;
}
inline ll abs(ll x){return x>0?x:-x;}
ll n,m,a[SIZE],b[SIZE];
ll root[SIZE],ls[EXTRA],rs[EXTRA],sum[EXTRA],cnt[EXTRA],sizep;
inline ll copy(ll thisp){return sizep++,ls[sizep]=ls[thisp],rs[sizep]=rs[thisp],sum[sizep]=sum[thisp],cnt[sizep]=cnt[thisp],sizep;}
inline void pushup(ll thisp){sum[thisp]=sum[ls[thisp]]+sum[rs[thisp]],cnt[thisp]=cnt[ls[thisp]]+cnt[rs[thisp]];}
ll modify(ll thisp,ll l,ll r,ll t,ll val)
{
    thisp=copy(thisp);
    if(l==r)return sum[thisp]+=val,cnt[thisp]++,thisp;
    return t<=mid?ls[thisp]=modify(ls[thisp],l,mid,t,val):rs[thisp]=modify(rs[thisp],mid+1,r,t,val),pushup(thisp),thisp;
}
inline ll modify(ll thisp,ll t,ll val){return modify(thisp,1,MAXV,t,val);}
ll getsum(ll u,ll v,ll l,ll r,ll L,ll R)
{
    if(!v)return 0;
    if(L<=l&&r<=R)return sum[v]-sum[u];
    if(R<=mid)return getsum(ls[u],ls[v],l,mid,L,R);
    if(mid<L)return getsum(rs[u],rs[v],mid+1,r,L,R);
    return  getsum(ls[u],ls[v],l,mid,L,R)+getsum(rs[u],rs[v],mid+1,r,L,R);
}
inline ll getsum(ll u,ll v,ll L,ll R){return getsum(u,v,1,MAXV,L,R);}
ll getcnt(ll u,ll v,ll l,ll r,ll L,ll R)
{
    if(!v)return 0;
    if(L<=l&&r<=R)return cnt[v]-cnt[u];
    if(R<=mid)return getcnt(ls[u],ls[v],l,mid,L,R);
    if(mid<L)return getcnt(rs[u],rs[v],mid+1,r,L,R);
    return  getcnt(ls[u],ls[v],l,mid,L,R)+getcnt(rs[u],rs[v],mid+1,r,L,R);
}
inline ll getcnt(ll u,ll v,ll L,ll R){return getcnt(u,v,1,MAXV,L,R);}
inline ll getpre(ll u,ll v,ll t,ll k)
{
    if(t<=0)return 0;
    return getsum(u,v,v(0),v(t))+getsum(u,v,v(-k),v(t-k))+k*getcnt(u,v,v(-k),v(-k+t));
}
inline ll getsuf(ll u,ll v,ll t,ll k)
{
    if(t>k)return 0;
    return k*getcnt(u,v,v(t),v(k))-getsum(u,v,v(t),v(k))-getsum(u,v,v(t-k),v(-1));
}
inline ll div(ll x,ll y){return x%y==0?x/y:x/y+1;}
inline ll min(ll x,ll y){return x<y?x:y;}
inline ll max(ll x,ll y){return x>y?x:y;}
int main()
{
    n=read(),m=read();
    for(ll i=1;i<=n;i++)a[i]=read(),b[i]=a[i]-a[i-1],root[i]=modify(root[i-1],v(b[i]),b[i]);
    for(ll i=1,l,r,ans,L,R,K,res,t1,t2,tmp,prt;i<=m;i++)
    {
        L=read(),R=read(),K=read(),ans=l=0,r=K;
        while(l<=r)
        {
            res=getsuf(root[L],root[R],mid+1,K)-getpre(root[L],root[R],mid,K);
            if(a[L]<=mid)res-=a[L];
            else res+=K-a[L];
            if(res>=0)ans=mid,l=mid+1;
            else r=mid-1;
        }
        t1=getpre(root[L],root[R],ans,K),t2=getsuf(root[L],root[R],ans+1,K);
        if(a[L]<=ans)t1+=a[L];
        else t2+=K-a[L];
        prt=max(t1,t2);
        tmp=div(t2-t1,K);
        prt=min(prt,max(t1+tmp*(ans+1),t2-tmp*(K-(ans+1))));
        printf("%lld\n",prt);
    }
    return 0;
}
```



---


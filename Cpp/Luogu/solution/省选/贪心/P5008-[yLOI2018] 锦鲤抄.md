# [yLOI2018] 锦鲤抄

## 题目背景

> 你在尘世中辗转了千百年，  
> 却只让我看你最后一眼。  
> 火光描摹容颜燃尽了时间，  
> 别留我一人，孑然一身，凋零在梦境里面。

—— 银临 & 云の泣《锦鲤抄》

本题原名《逛庭院》。

这首歌的文案如下：（注：不阅读文案不影响下面的阅读）

> 宁武皇仁光九年锦文轩刻本《异闻录》载：扶桑画师浅溪，居泰安，喜绘鲤。院前一方荷塘，锦鲤游曳，溪常与嬉戏。  
> 其时正武德之乱，藩镇割据，战事频仍，魑魅魍魉，肆逆于道。兵戈逼泰安，街邻皆逃亡，独溪不舍锦鲤，未去。  
> 是夜，院室倏火。有人入火护溪，言其本鲤中妖，欲取溪命，却生情愫，遂不忍为之。翌日天明，火势渐歇，人已不见。  
> 溪始觉如梦，奔塘边，但见池水干涸，莲叶皆枯，塘中鲤亦不知所踪。  
> 自始至终，未辨眉目，只记襟上层迭莲花，其色魅惑，似血着泪。  
> 后有青岩居士闻之，叹曰：魑祟动情，必作灰飞。犹蛾之投火耳，非愚，乃命数也。

## 题目描述

扶苏被画师和锦鲤的故事深深地打动了。为了能让锦鲤和画师继续生活在一起，他决定回到着火的庭院中灭掉大火。

画师的庭院可以抽象成一个有向图，每个点代表着一个着火的位置。为了量化火势的大小，扶苏给每个点一个火力值，火力值越大，代表这个点的火势越强。

风助火势，火借风力，对于每一个着火点，都有可能因为大风使得火扩散到其他点。有向图的每条边 $<u,v>$ 代表大火是从点 $u$ 扩散到点 $v$ 的。需要注意的是一个点可能会扩散到很多点，也可能是由很多点的大火一起扩散成的。

为了不因为灭掉火源让画师发现有人在帮他灭火，在任意时刻，扶苏不能灭掉任何一个不被任何点所扩散的点的火。一个点的火被灭掉后，所代表该点的火扩散的所有边将消失。需要说明的是，虽然边消失了，但是该点扩散到的所有点属性除入度以外都不会改变，更不会消失。

因为穿越的时间有限，扶苏只能灭掉最多 $k$ 个点的火。他想问问你他最多能扑灭多少火力值。

#### 简化版题意：

给你一张有向图，每个点有一个点权。任意时刻你可以任意选择一个**有入度**的点，获得它的点权并把它和它的出边从图上删去。最多能选择 $k$ 个点，求最多能获得多少点权。

## 说明/提示

### 样例输入输出 1 解释

选择 $3, 5, 7$ 三个节点。

---

### 数据规模与约定

**本题采用多测试点捆绑测试，共有 $5$ 个子任务**。

- Subtask 1（30 points）：$n = 10$，$m = 50$。
- Subtask 2（30 points）：$n = 100001$，$m = 500001$。**保证给出的图是一个有向无环图**。
- Subtask 3（20 points）：$n = 100002$，$m = 500002$。保证给出的图中，没有入度的点有且仅有一个。
- Subtask 4（17 points）：$n = 100003$，$m = 500003$。
- Subtask 5（3 points）：$n = 500004$，$m = 2000004$。

对于全部的测试点，保证 $1 \leq n \leq 5 \times 10^5 + 4$，$1 \leq m \leq 2 \times 10^6 + 4$，$0 \leq w_i \leq 10^3$，$0 \leq k \leq n$。

**不保证**给出的图没有自环。

---

### 提示

- 请注意数据读入对程序效率造成的影响。
- $n$ 的末位数字可以帮助你快速的判断测试点所在的子任务。



## 样例 #1

### 输入

```
7 7 3
10 2 8 4 9 5 7
1 2
1 3
1 4
2 5
3 6
3 7
4 7```

### 输出

```
24```

# 题解

## 作者：一扶苏一 (赞：27)

## [yLOI2018] 锦鲤抄

我永远喜欢银临女神！  
这是一篇完全重构后的题解。

### Description

给你一张有向图，每个点有一个点权。任意时刻你可以任意选择一个**有入度**的点，获得它的点权并把它和它的出边从图上删去。最多能选择 $k$ 个点，求最多能获得多少点权。

$1 \leq n \leq 5 \times 10^5 + 4$，$1 \leq m \leq 2 \times 10^6 + 4$，$0 \leq w_i \leq 10^3$，$0 \leq k \leq n$。

### Analysis

#### Algorithm 1

爆搜，搜出所有删点的顺序，复杂度 $O(A_n^k)$，期望得分 $30$ 分。

#### Algorithm 2

考虑一个 DAG，我们按拓扑序从后向前（若 $u$ 指向 $v$，则 $u$ 在 $v$ 之前）删点，则删除后面的点不会对前面的入度的点产生任何影响。于是按照拓扑序的倒序删点，可以删除所有入度不为 $0$ 的点。只需要把这些点的权值取前 $k$ 大即可。时间复杂度 $O(n + m)$ 或 $O(n \log n + m)$，期望得分 $30$ 分，结合算法 1 可以得到 $60$ 分。

#### Algorithm 3

子任务 2 明示把一个普通图缩成一个 DAG。对于缩完后的图，同样按照拓扑序的倒叙考虑每个 SCC 的删点方案，则后面的 SCC 不影响前面的 SCC。于是我们只需要考虑一个 SCC 内部的情况。

考虑对于一个 SCC 内的任何一个点 $u$，$u$ 到该 SCC 内其他节点的最短路树构成一棵外向树（或者说，从 $u$ 开始 bfs，只访问该 SCC 内的节点且不重复访问节点，最后会得到一棵 bfs 树，这棵树上所有的边都由父亲指向孩子且在原图上存在）。这棵树具有良好的拓扑结构：只有父亲指向孩子的边，显然是个 DAG。且这棵树上只有 $u$ 一个（在树上）入度为 $0$ 的节点。所以按照算法 2 的考虑，我们可以把除了 $u$ 以外的节点都按照某个顺序删掉。注意这个性质对任何的 $u$ 都成立，也就是说，我们总可以删除某个 SCC 内除了某个点以外的所有点。

- 考虑一个 SCC，如果它在缩点后的图上存在入度，也就是说，有另一个 SCC 内的某点 $s$ 指向该 SCC 内的点 $t$，则我们令 $t$ 为上一段中外向树的根，则删除完该 SCC 内除 $t$ 外的所有节点后，$t$ 仍有入度，可以删除。此时该 SCC 可以被全部删除。
- 如果一个 SCC 在缩点后的图上没有入度，也就是不存在另一个 SCC 内的某点指向该 SCC 内的点，但该 SCC 内存在一个自环，则我们让有自环的点做外向树的根，删除该 SCC 内其余点后，该点仍有入度，可以删除。此时该 SCC 可以被全部删除。
- 如果一个 SCC 在缩点后的图上没有入度，也没有自环，则我们取权值最小的点做外向树的根。此时只有权值最小的点不能被删除。

于是我们把除了上述第三种情况中 SCC 内点权最小的点以外的所有点的点权排序，取前 $k$ 大即可。时间复杂度 $O(m + n \log n)$，期望得分 $100$ 分。

#### Algorithm 4

取前 $k$ 大无需排序，只需要调用 `std::nth_element`。它可以把第 $k$ 小的数放在容器第 $k$ 个位置上，且小于第 $k$ 小的数在第 $k$ 个位置左边，大于第 $k$ 小的数在第 $k$ 个数右边（只能保证左右，不能保证比第 $k$ 小的数大/小的数的相对大小顺序）。这一算法的复杂度为 $O(n)$。而缩点的时间复杂度为 $O(n + m)$，所以总复杂度为 $O(n + m)$，期望得分 100 分。实际效率跑的好像还是不如 std::sort 快。

### Code

```cpp
#include <climits>
#include <array>
#include <bitset>
#include <vector>
#include <iostream>
#include <algorithm>
#include <functional>

const int maxn = 500005;
const int maxm = 2000006;

int n, m, k, vistime, top, scnt, ans;
std::array<int, maxn> w, ind, minw, dfn, low, stk, bel;
std::vector<int> ww;
std::bitset<maxn> slfLoop, instk;
std::array<std::vector<int>, maxn> e;

void dfs(const int u);

int main() {
  std::ios::sync_with_stdio(false);
  std::cin.tie(0);
  std::cin >> n >> m >> k;
  for (int i = 1; i <= n; ++i) std::cin >> w[i];
  for (int u, v; m; --m) {
    std::cin >> u >> v;
    e[u].push_back(v);
  }
  for (int i = 1; i <= n; ++i) if (dfn[i] == 0) dfs(i);
  for (int u = 1; u <= n; ++u) {
    for (auto v : e[u]) if (bel[u] != bel[v]) {
      ++ind[bel[v]];
    } else if (u == v) {
      slfLoop.set(bel[u]);
    }
  }
  for (int u = 1; u <= n; ++u) if (ind[bel[u]] || (minw[bel[u]] != u) || slfLoop[bel[u]]) {
    ww.push_back(w[u]);
  }
  while (ww.size() < k) ww.push_back(0);
  std::nth_element(ww.begin(), ww.begin() + k, ww.end(), std::greater<int>());
  for (auto u = ww.begin(), v = ww.begin() + k; u != v; ++u) {
    ans += *u;
  }
  std::cout << ans << std::endl;
  return 0;
}

void dfs(const int u) {
  dfn[u] = low[u] = ++vistime;
  instk[stk[++top] = u] = true;
  for (auto v : e[u]) if (dfn[v] == 0) {
    dfs(v);
    low[u] = std::min(low[u], low[v]);
  } else if (instk[v]) {
    low[u] = std::min(low[u], dfn[v]);
  }
  if (low[u] == dfn[u]) {
    instk[minw[bel[u] = ++scnt] = u] = false;
    for (int v = stk[top--]; v != u; v = stk[top--]) {
      bel[v] = scnt;
      if (w[v] < w[minw[scnt]]) minw[scnt] = v;
      instk[v] = false;
    }
  }
}
```



---

## 作者：251Sec (赞：9)

怎么感觉我最近写的紫题越来越水了？？？

这题和[P3472](https://www.luogu.com.cn/problem/P3472)很像，写完这题可以尝试一下。

## 分析

考虑 DAG 的情况，显然可以按照拓扑序的逆序删点，那么除了入度为 0 的点以外，其它点都可以删掉。我们选择其中点权最大的 $k$ 个即可。

对于一般情况，我们尝试将其转化为 DAG。

对于有向图中的一个 SCC，我们对其进行缩点。缩点完成后，若这个 SCC 的入度为 0，显然我们一定有一个点删不掉，所以我们贪心地，不删点权最小的那个点。若该 SCC 入度不为 0，那么其中的点就都是可以删的。特别地，如果一个 SCC 中有自环，那么我们也可以删掉其中所有的点。

考虑证明。因为是个 SCC，任意点均可达，所以我们可以钦定任意一个节点作为根节点，然后获得一个生成树。我们从生成树的叶子向根依次删点，显然最后只会剩下根。如果有 SCC 外的点连边向根节点或者根节点有自环，那么我们就可以把根也删掉。

所以这题就做完了。

Code:

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
int n, m, k;
struct Node {
    int w, ava;
	bool operator<(const Node &o) const {
		return w > o.w;
	}
} a[500005];
struct Edge {
	int to, next;
} e[2000005];
int head[500005], len;
void Insert(int u, int v) {
	e[++len].to = v;
	e[len].next = head[u];
	head[u] = len;
}
int dfn[500005], low[500005], ts, st[500005], top;
bool ind[500005];
bool vis[500005];
int bel[500005];
int scc[500005];
int cnt;
void Tarjan(int u) {
	dfn[u] = low[u] = ++ts;
	st[++top] = u;
	vis[u] = true;
	for (int i = head[u]; i; i = e[i].next) {
		int v = e[i].to;
		if (!dfn[v]) {
			Tarjan(v);
			low[u] = min(low[u], low[v]);
		}
		else if (vis[v]) {
			low[u] = min(low[u], dfn[v]);
		}
	}
	if (low[u] == dfn[u]) {
		int mn = 0x3f3f3f3f, pos = -1;
		cnt++;
		int siz = 0;
		while (st[top + 1] != u) {
			int v = st[top--];
			siz++;
			bel[v] = cnt;
			vis[v] = false;
			if (a[v].w < mn) {
				mn = a[v].w;
				pos = v;
			}
		}
		if (siz > 1) {
			scc[cnt] = pos;
		}
	}
}
int ans;
int main() {
	scanf("%d%d%d", &n, &m, &k);
	for (int i = 1; i <= n; i++) {
		scanf("%d", &a[i].w);
		a[i].ava = false;
	}
	for (int i = 1; i <= m; i++) {
		int u, v;
		scanf("%d%d", &u, &v);
		Insert(u, v);
		a[v].ava = true;
	}
	for (int i = 1; i <= n; i++) if (!dfn[i]) Tarjan(i);
	for (int i = 1; i <= n; i++) {
		for (int j = head[i]; j; j = e[j].next) {
			int u = bel[i], v = bel[e[j].to];
			if (u != v) {
				ind[v] = true;
			}
			if (i == e[j].to) {
				ind[v] = true;
			}
		}
	}
	for (int i = 1; i <= cnt; i++) {
		if (!ind[i]) a[scc[i]].ava = false;
	}
	sort(a + 1, a + n + 1);
	for (int i = 1; i <= n; i++) {
		if (a[i].ava) {
			ans += a[i].w;
			k--;
			if (!k) break;
		}
	}
	printf("%d", ans);
	return 0;
}
```

---

## 作者：vectorwyx (赞：4)

有趣的题目，本身并不困难。

首先考虑 DAG 怎么做，显而易见的是 DAG 给出了一个完美的顺序使得按这个顺序总能消掉选出来的点集，除非这个点集里包含了本身就没有入度的点。

沿用这个思路，对于一般图不难想到缩点。缩点之后，点与点之间仍然按照 DAG 的顺序做，现在只需要考虑一个强连通分量内部怎么做。首先我们最多只需要牺牲一个点就可以消去其余的所有点，这个过程大概类似于欧拉回路里那个大环套小环+回溯的结构，手玩一下就很明了。看了题解发现还有更高的角度是 bfs 生成树，因为 bfs 生成树只有横叉边没有返祖边，所以选定一个点当 bfs 生成树的根，从叶子起自底向上消，每个点在被消之前它的父亲到它的边一定是存在的。

由于是强连通分量，所以每个点都可以当根，那如果存在一个点满足其它强连通分量里的点到它有一条边，或者它自己到自己有一条边，我们把它当做根就可以消掉它所在连通分量里的所有点。如果不存在这样的点，首先我们一定会牺牲一个点，因为消到只剩一个点的时候这个点显然不能再动了，而由刚才的论述可得我们也只需要牺牲一个点，所以就贪心，把点权最小的那个点作为根牺牲掉。在没有被牺牲的所有点中求前 $k$ 大之和，做完了。

```cpp
//author:望远星
#include<bits/stdc++.h>
#define pii pair<int,int>
#define fi first
#define se second
#define pb push_back
#define eb emplace_back
#define mk make_pair
#define sml(x,y) (x=min(x,y))
#define big(x,y) (x=max(x,y))
#define ll long long
#define uint unsigned int
#define ull unsigned long long
#define umap unordered_map
#define db double
#define fo(i,x,y) for(int i=x;i<=y;++i)
#define go(i,x,y) for(int i=x;i>=y;--i)
#define ptc putchar
#define emp emplace
using namespace std;
ll seed=chrono::system_clock::now().time_since_epoch().count();
mt19937 rnd(seed);
inline int rm(int x,int y){return (int)(rnd()%(y-x+1ll)+x);}
inline int read(){int ch=getchar(),x=0,f=1;while(!isdigit(ch)){if(ch==(int)('-'))f=-1;ch=getchar();}while(isdigit(ch)){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}return x*f;}
inline void out(int *a,int l,int r){fo(i,l,r) cout<<*(a+i)<<' ';puts("");}

const int N=5e5+10,M=3e6;
struct Edge{
	int to,next,val;
}e[M];
int head[N],tot,n,m,a[N],dfn[N],ti,low[N],stk[N],top,ins[N],deg[N],bel[N];
int b[N],n_;
vector<int> g[N];

void connect(int x,int y,int v){
	e[++tot]=(Edge){y,head[x],v};
	head[x]=tot;
}

void dfs(int x){
	stk[++top]=x;ins[x]=1;
	dfn[x]=low[x]=++ti;
	for(int i=head[x];i;i=e[i].next){
		int p=e[i].to;
		if(!dfn[p]) dfs(p),sml(low[x],low[p]);
		else if(ins[p]) sml(low[x],dfn[p]);
	}
	if(dfn[x]==low[x]){
		//printf("%d:",x);
		int p;
		do{
			p=stk[top--];
			ins[p]=0;
			bel[p]=x;
			g[x].pb(p);
			//printf("%d ",p);
		}while(p!=x);//puts("");
	}
}

signed main(){
	cin>>n>>m;int k=read();
	fo(i,1,n) a[i]=read();
	fo(i,1,m){
		int x=read(),y=read(),v=0;
		connect(x,y,v);
	}
	fo(i,1,n) if(!dfn[i]) dfs(i);
	fo(i,1,n) 
		for(int j=head[i];j;j=e[j].next){
			int p=e[j].to;
			if(p==i||bel[p]!=bel[i]) deg[bel[p]]++;
		}
	//cout<<"deg:";out(deg,1,n);
	fo(i,1,n) if(bel[i]==i){
		if(deg[i]){
			for(int j:g[i]) b[++n_]=a[j];
			continue;
		}
		auto cmp=[](int x,int y){return a[x]>a[y];};
		sort(g[i].begin(),g[i].end(),cmp);
		for(int j:g[i]) b[++n_]=a[j];
		--n_;
	}
	sort(b+1,b+1+n_);
	//cout<<n_<<":";out(b,1,n_);
	int ans=0;
	go(i,n_,1){
		ans+=b[i];
		k--;
		if(!k) break;
	}
	cout<<ans;
	return 0;
}

```


---

## 作者：Pwtking (赞：2)

- 首先考虑有向无环图的情况：

我们发现，只要按照拓扑序倒序删点的话，所有的的有入度的点都是可以删掉的。

- 有环图：

此时，与有向无环图情况不同的地方即是多了一些强连通分量，于是考虑缩点转化为有向无环图，接下来只需考虑这些强连通分量内部如何处理即可。

若这个强连通分量有入度，画图可知只要按照一定顺序，整个强连通分量都是可以删去的。

若这个强连通分量没有入度，显然的是至少有一个点删不掉，于是我们贪心的不删点权最小的点即可。

同时，若这个强连通分量内部有自环，整个强连通分量也是可以全部删去的，和这个强连通分量有入度的原理相同。



------------

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define inf 0x7fffffff
const ll maxn=2e6+10;
ll flag[maxn],scc[maxn],per[maxn];
ll n,m,k,U[maxn],V[maxn];
ll low[maxn],vis[maxn],dfn[maxn],tot,cnt;
ll f[maxn],minn[maxn],val[maxn];
vector<ll> G[maxn],si[maxn];
stack<ll> q;
ll p[maxn];
inline bool cmp(ll x,ll y) {return x>y;}
inline void solve(ll u) {
	q.pop();
	if (val[u]<minn[tot]) {f[u]=1;minn[tot]=val[u];}
	per[u]=tot;vis[u]=0;si[tot].push_back(u);
}
inline void tarjan(ll u) {
	vis[u]=dfn[u]=low[u]=++cnt;
	q.push(u);
	for (ll i=0;i<G[u].size();++i) {
		ll v=G[u][i];
		if (!dfn[v]) {
			tarjan(v);
			low[u]=min(low[u],low[v]);
		}
		else if (vis[v]) low[u]=min(low[u],dfn[v]);
	}
	if (dfn[u]==low[u]) {
		++tot;
		minn[tot]=inf;
		while (q.top()!=u) solve(q.top());
		solve(u);
	}
}
inline ll in() {
    char a=getchar();
	ll t=0,f=1;
	while(a<'0'||a>'9') {if (a=='-') f=-1;a=getchar();}
    while(a>='0'&&a<='9') {t=(t<<1)+(t<<3)+a-'0';a=getchar();}
    return t*f;
}
signed main() {
	n=in(),m=in(),k=in();
	for (ll i=1;i<=n;++i) val[i]=in();
	for (ll i=1;i<=m;++i) {
		U[i]=in(),V[i]=in();
		G[U[i]].push_back(V[i]);
	}
	for (ll i=1;i<=n;++i) if (!dfn[i]) tarjan(i);
	for (ll i=1;i<=m;++i) {
		if (U[i]==V[i]||per[U[i]]!=per[V[i]]) flag[per[V[i]]]=1;
	}
	ll T=0;
	for (ll i=1;i<=tot;++i) {
//		printf("%lld\n",flag[i]);
		for (ll j=0;j<si[i].size();++j) {
			ll u=si[i][j];
			if (f[u]&&minn[i]==val[u]&&!flag[i]) continue;
			p[++T]=val[u];
		}
	} 
//	printf("%lld\n",T);
	sort(p+1,p+1+T,cmp);
	ll ans=0;
	for (ll i=1;i<=k;++i) ans+=p[i];
	printf("%lld",ans);
	return 0;
}
```




---

## 作者：One_JuRuo (赞：2)

# 思路

我们可以先找出所有的可以被删除的点，然后取点权前 $k$ 大的点就好了。

因为图可能存在环，所以我们需要先缩点，考虑缩点后的 DAG，我们可以按照拓扑序倒序删点就好。

再来考虑每个 SCC 如何取点。

我们先把 SCC 分为三种情况：

1. 该 SCC 没有入度，且无自环。
2. 该 SCC 没有入度，且有点存在自环。
3. 该 SCC 有入度。

对于第一种情况，我们只能随意删一个点，然后按照顺序删点，最后会发现最开始删掉的点链接的那个点无法被删除，所以这种情况至少会剩下一个点不能删除，我们可以直接贪心，让权值最小的那个点不删除就好了。

![](https://cdn.luogu.com.cn/upload/image_hosting/w49jp57q.png)

如果，点上的数字代表删除的顺序。

对于第二种情况，我们可以先删除链接有自环点的点，然后按照顺序删点，最后剩下的点因为有自环，可以删除，所以这种情况所有的点都可以被删除。

![](https://cdn.luogu.com.cn/upload/image_hosting/3v4ems9c.png)

对于第三种情况，我们可以最后删除有入度来自 SCC 外的点，即第一个删除链接该点的点，所以这种情况所有的点都可以被删除。

![](https://cdn.luogu.com.cn/upload/image_hosting/hc72v20u.png)

所以我们的思路现在很顺畅了：建图-> tarjan 缩点->统计入度->找到可删除的点->取权值前 $k$ 大的点，计算答案。

# AC 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,m,k,v[500010],x,y,e[2000010],ne[2000010],h[500010],idx=1,a,dfn[500010],low[500010],cnt,id[500010],z[500010],top,in_z[500010],in[500010];
long long ans[500010],ta,res;
vector<long long>vec[500010];//记录每个SCC有哪些点
inline void add(long long a,long long b){e[idx]=b,ne[idx]=h[a],h[a]=idx++;}//链式前向星
inline bool cmp(long long a,long long b){return v[a]>v[b];}
void dfs(long long u)//tanjar缩点
{
	dfn[u]=low[u]=++cnt,z[++top]=u,in_z[u]=1;
	for(long long i=h[u];i;i=ne[i])
	{
		if(!dfn[e[i]]) dfs(e[i]),low[u]=min(low[u],low[e[i]]);
		else if(in_z[e[i]]) low[u]=min(low[u],dfn[e[i]]);
	}
	if(dfn[u]==low[u])
	{
		long long y;
		do{y=z[top--],vec[u].push_back(y),in_z[y]=0,id[y]=u;}while(y!=u);//用点的编号当SCC的编号
	}
}
int main()
{
	scanf("%lld%lld%lld",&n,&m,&k);
	for(long long i=1;i<=n;++i) scanf("%lld",&v[i]);
	for(long long i=1;i<=m;++i) scanf("%lld%lld",&x,&y),add(x,y);
	for(long long i=1;i<=n;++i) if(!dfn[i]) dfs(i);
	for(long long i=1;i<=n;++i) for(long long j=h[i];j;j=ne[j]) if(i==e[j]||id[i]!=id[e[j]]) in[id[e[j]]]++;//统计入度，存在自环这种特殊情况，但是自环和有入度的情况结果一样，所以把自环也看作入度
	for(long long i=1;i<=n;++i)
		if(id[i]==i)
		{
			if(in[i]){for(long long j=0;j<vec[i].size();++j) ans[++ta]=vec[i][j];}//有入度可以把所有点删完，所以全部加入统计
			else{
				sort(vec[i].begin(),vec[i].end(),cmp);//无入度至少剩一个，贪心剩下权值最小的那个，所以需要排序
				for(long long j=0;j<vec[i].size()-1;++j) ans[++ta]=vec[i][j];
			}
		}
	sort(ans+1,ans+ta+1,cmp);//把所有可删除的点排序
	for(long long i=1;i<=k;++i) res+=v[ans[i]];//取前k个
	printf("%lld",res);
	return 0;
}

```

---

## 作者：james1BadCreeper (赞：2)

先考虑一个 DAG 的情况。我们只要先找到需要删除的点（能够被删除且是前 $k$ 大），然后按照这些点的拓扑序的倒序删点，那么可以发现这些点都可以被删去，并不会影响后面的点的入度。

因此对原图进行 SCC 缩点，这样整体上的逻辑是不变的，我们只需要单独考虑一下 SCC 内部怎么删。看一个简单的：

![](https://pic.imgdb.cn/item/639150e2b1fccdcd36618c48.png)

现在 $2,3,4$ 在一个 SCC 内，由于这个 SCC 是有一个入度的 $1\rightarrow 2$，因此只要不先删 $2$，那么这个 SCC 就可以删干净。但是如果没有 $1\rightarrow 2$ 这条边呢？那么 SCC 删完必须留一个点（只需要从任意一个位置开始顺着环删，最后就会剩一个点），但是！如果这个 SCC 内存在自环，那么它还是可以被删干净的。

因此我们只需要排除掉本来就入度为 $0$ 的点和一个没有入度没有自环的 SCC 内的点权最小的点，剩下的点取前 $k$ 大即可。


```cpp
#include <iostream>
#include <cstdio>
#include <vector>
#include <algorithm>

using namespace std;

int n, m, k;
int w[500010];
int dfn[500010], low[500010], num = 0;
int st[500010], tot = 0; 
int cnt = 0, c[500010];
bool ins[500010];
vector<int> G[500010];
vector<int> scc[500010];
bool self[500010];
bool selfscc[500010];

void tarjan(int x) {
    dfn[x] = low[x] = ++num;
    ins[st[++tot] = x] = true;
    for (int y : G[x])
        if (!dfn[y]) {
            tarjan(y);
            low[x] = min(low[x], low[y]);
        } else if (ins[y]) low[x] = min(low[x], dfn[y]);
    if (low[x] == dfn[x]) {
        int y; ++cnt;
        do {
            y = st[tot--]; ins[y] = false;
            c[y] = cnt; scc[cnt].push_back(y);
            selfscc[cnt] |= self[y];
        } while (x != y);
    }
}

int in[500010];
int val[500010], tot2 = 0;

int main(void) {
    scanf("%d%d%d", &n, &m, &k);
    for (int i = 1; i <= n; ++i) scanf("%d", w + i);
    while (m--) {
        int u, v; scanf("%d%d", &u, &v);
        if (u != v) G[u].push_back(v);
        else self[u] = true;
    }
    for (int i = 1; i <= n; ++i) if (!dfn[i]) tarjan(i);
    for (int i = 1; i <= n; ++i)
        for (int j : G[i]) if (c[i] != c[j]) ++in[c[j]];
    for (int i = 1; i <= cnt; ++i) {
        int minn = 1e9, flag = false;
        for (int j : scc[i]) minn = min(minn, w[j]);
        for (int j : scc[i])
            if (in[i] || selfscc[i]) val[++tot2] = w[j];
            else if (w[j] > minn || flag) val[++tot2] = w[j];
            else flag = true;
    }
    sort(val + 1, val + tot2 + 1, greater<int>());
    int ans = 0;
    for (int i = 1; i <= k; ++i) ans += val[i];
    printf("%d\n", ans);
    return 0;
}
```

---

## 作者：云浅知处 (赞：2)

小清新题 suki

- 可以发现，如果图是有向无环图，那么除了那些一开始就没有入度的点，别的点都是可以被选中的。也就是说我们只需要在一开始有入度的点中选出前 $k$ 大即可。
- 对于一个单独的大小为 $n$ 的环，可以发现我们总可以确定一个方案来选出环上的任意 $n-1$ 个点。类似地可以得到对于一个 $\text{SCC}$ 也有这样的结论。
- 现在我们回到原图上考虑。将原图缩点，对于此时的一个 $\text{SCC}$，若其在缩点后的图中入度不为 $0$，那么我们总可以将它删完。否则，我们至少要保留这个 $\text{SCC}$ 中的一个点。
- 我们考虑从大到小依次贪心地选，同时记录每个 $\text{SCC}$ 目前已经选了多少个点，对于现在的数能选就尽可能地选上。不难发现这个贪心是对的。
- 但这个算法有一些缺陷：如果一个 $\text{SCC}$ 中某个点存在自环，那么就算这个 $\text{SCC}$ 没有入度，它也可以被删完。那么我们只要特判一下是否存在自环就可以了。

时间复杂度：$O(n\log n+m)$。

```cpp
#include<bits/stdc++.h>

#define int long long

using namespace std;

inline int read(){
	int x=0,f=1;char c=getchar();
	for(;(c<'0'||c>'9');c=getchar()){if(c=='-')f=-1;}
	for(;(c>='0'&&c<='9');c=getchar())x=x*10+(c&15);
	return x*f;
}

const int N=5e5+15;
const int M=2e6+15;

vector<int>G[N];

int dfn[N],low[N],w[N],cnt[N],scc[N],sc,fr[M],to[M];
int top=0,stk[N],n,m,tot=0;
bool ins[N];
bool cyc[N],zyz[N];

void tarjan(int u){
	stk[++top]=u,ins[u]=1,dfn[u]=++tot,low[u]=dfn[u];
	for(int v:G[u]){
		if(!dfn[v])tarjan(v),low[u]=min(low[u],low[v]);
		else if(ins[v])low[u]=min(low[u],dfn[v]);
	}
	if(low[u]!=dfn[u])return ;
	scc[u]=++sc,cnt[sc]++,ins[u]=0,zyz[sc]|=cyc[u];
	while(top>0&&stk[top]!=u){
		int v=stk[top];top--,ins[v]=0;
		scc[v]=sc,cnt[sc]++,zyz[sc]|=cyc[v];
	}
	top--;
}

priority_queue<pair<int,int> >q;

#define fi first
#define se second
#define mk make_pair

int ind[N];

signed main(void){

#ifndef ONLINE_JUDGE
	freopen("in.in","r",stdin);
#endif

	n=read(),m=read();int k=read();
	for(int i=1;i<=n;i++)w[i]=read();
	for(int i=1;i<=m;i++){
		int u=read(),v=read();
		fr[i]=u,to[i]=v;
		if(u==v){cyc[u]=1;continue;}
		G[u].push_back(v);
	}
	for(int i=1;i<=n;i++)if(!dfn[i])tarjan(i);
	for(int i=1;i<=m;i++){
		int u=fr[i],v=to[i];
		if(scc[u]!=scc[v])ind[scc[v]]++;
	}
	
//	for(int i=1;i<=n;i++)cout<<scc[i]<<' ';puts("");
//	for(int i=1;i<=n;i++)cout<<ind[i]<<" "<<cnt[i]<<endl;
	
	int ans=0;
	for(int i=1;i<=n;i++)q.push(mk(w[i],scc[i]));
	while(k&&q.size()){
		auto t=q.top();q.pop();
//		cout<<t.fi<<" "<<t.se<<endl;
		if((!ind[t.se])&&(cnt[t.se]==1)&&(!zyz[t.se]))continue;
		cnt[t.se]--,ans+=t.fi;k--;
	}
	cout<<ans<<endl;

	return 0;
}

```

---

## 作者：快斗游鹿 (赞：0)

## 思路

先考虑 DAG 的情况。这时只要一个点入度不为 $0$，那它就一定可以被删去。为什么？我们只需要按照拓扑序的逆序删点就行了。

那么接下来，容易想到可以先进行缩点，把原图变为 DAG。这时每个 SCC 分为两种情况：入度为 $0$ 和入度不为 $0$。

如果入度不为 $0$，那么这个 SCC 所有点都一定可以被删掉。如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/xrni8u4g.png)

红色数字表示被删的顺序。

如果入度为 $0$，显然有一个点是一定删不掉的。这时根据贪心的原则，我们不删点权最小的点。

然后这题就做完了。需要注意，如果一个 SCC 中存在自环，这个 SCC 内所有点也是能全部删掉的。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e6;
const int M=6e6;
struct Node{
	int to,nxt;
}e[M];
int n,m,k,w[N],d[N],a[N],U[N],V[N],ttt,cnt,head[N],ans;
int dfn[N],low[N],id[N],minn[N],minid[N],ccount;
stack<int>st;
bool flag[N],f[N],g[N],o[N];
int read(){
	int x=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+ch-'0';ch=getchar();}
	return x*f;
}
void add(int u,int v){
	d[v]++;
	e[++cnt].to=v;
	e[cnt].nxt=head[u];
	head[u]=cnt;
} 
void tarjan(int u){
	dfn[u]=low[u]=++cnt;
	st.push(u);
	flag[u]=1;
	for(int i=head[u];i;i=e[i].nxt){
		int v=e[i].to;
		if(!dfn[v]){
			tarjan(v);
			low[u]=min(low[u],low[v]);
		}
		else if(flag[v])low[u]=min(low[u],dfn[v]);
	}
	if(dfn[u]==low[u]){
		ccount++;
		int y=0;
		while(u!=y&&!st.empty()){
			y=st.top();st.pop();
			flag[y]=0;
			id[y]=ccount;
			o[ccount]|=g[y];
			if(w[y]<minn[ccount]){
				minn[ccount]=w[y];
				minid[ccount]=y;
			}
		}
	}
}
void solve(){
	memset(e,0,sizeof(e));
	memset(head,0,sizeof(head));
	cnt=0;
	memset(d,0,sizeof(d));
	for(int i=1;i<=m;i++){
		int u=U[i],v=V[i];
		if(id[u]!=id[v])add(id[u],id[v]);//cout<<id[u]<<" "<<id[v]<<endl;
	}
}
int main(){
	//freopen("P5008_6.in","r",stdin);
	//freopen("std.in","r",stdin);
	memset(minn,0x3f,sizeof(minn));
	n=read();m=read();k=read();
	for(int i=1;i<=n;i++)w[i]=read();
	for(int i=1;i<=m;i++){
		int u,v;u=read();v=read();add(u,v);U[i]=u;V[i]=v;
		if(u==v)g[u]=1;
	}
	cnt=0;
	for(int i=1;i<=n;i++){
		if(!dfn[i])tarjan(i); 
	}
	solve();
	//for(int i=1;i<=n;i++)cout<<id[i]<<endl;
	for(int i=1;i<=ccount;i++){
		if(!d[i]&&!o[i])f[minid[i]]=1;//cout<<w[minid[i]]<<endl;
	}
	for(int i=1;i<=n;i++){
		if(!f[i])a[++ttt]=w[i];//cout<<i<<endl;
	}
	sort(a+1,a+1+ttt);
	int now=0;
	for(int i=ttt;i>=1;i--){
		now++;
		if(now<=k)ans+=a[i];
		else break;
	}
	cout<<ans;
	return 0;
}
```


---


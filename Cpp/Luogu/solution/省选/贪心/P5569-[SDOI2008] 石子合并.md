# [SDOI2008] 石子合并

## 题目描述

在一个操场上摆放着一排 $N$ 堆石子。现要将石子有次序地合并成一堆。规定每次只能选相邻的 $2$ 堆石子合并成新的一堆，并将新的一堆石子数记为该次合并的得分。

试设计一个算法，计算出将 $N$ 堆石子合并成一堆的最小得分。

## 说明/提示

$ N \leq 40000, a_i \leq 200$

**请注意 $N$ 的范围（来自上传者的提示）**

## 样例 #1

### 输入

```
4
1
1
1
1```

### 输出

```
8```

# 题解

## 作者：Eastern (赞：156)

## [做法] GarsiaWachs算法

*更多内容及证明见后文

1. 找到满足 $q_{k-1} \lt q_{k+1}$ 的最小下标 $k$
2. 找到满足 $q_{j-1} \gt q_{k-1} + q_k$ 的最大 $j \lt k$
3. 从列表中清除 $q_{k-1}, q_k$
4. 在 $q_{j-1}$ 之后插入 $q_{k-1} + q_k$ 
5. $q_{-1}$ 和 $q_{n+1}$ 可以用 $\infty$ 处理

**例**：$q[5]=\{183,64,35,32,103\}$

| $q_{-1}$ | $q_0$ | $q_1$ | $q_2$ | $q_3$ | $q_4$ | $q_5$ | $k$ | $j$ |
| -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: |
| $\infty$ | 186 | 64 | 35 | 32 | 103 | $\infty$ | 3 | 1 |
| $\infty$ | 186 | 67 | 64 | 103 | $\infty$ |  | 2 | 1 |
| $\infty$ | 186 | 131 | 103 | $\infty$ |  |  | 2 | -1 |
| $\infty$ | 234 | 186 | $\infty$ |  |  |  | 1 | -1 |
| $\infty$ | 420 | $\infty$ |  |  |  |  |  |  |

**代码实现：** 通过 $vector$ 模拟上述过程

**因为删除$erase$ 和 插入 $insert$ 操作速度较慢，代码需要O2优化** ~~我太菜了~~


```cpp
#include <bits/stdc++.h>//懒
using namespace std;

int n, k, j;
int ans, sum;
vector<int> v;

int read()
{
    int x = 0, f = 1;
    char c = getchar();
    while (c < '0' || c > '9') {if (c == '-') f = -1; c = getchar();}
    while (c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();
    return x * f;
}

int main()
{
    n = read();
    v.push_back(INT_MAX - 1);
    for (int i = 1; i <= n; i++)
        v.push_back(read());
    v.push_back(INT_MAX);

    while (n-- > 1)
    {
        for (k = 1; k <= n; k++)
            if (v[k - 1] < v[k + 1])
                break;
        sum = v[k] + v[k - 1];
        for (j = k - 1; j >= 0; j--)
            if (v[j] > v[k] + v[k - 1])
                break;
        v.erase(v.begin() + k - 1);
        v.erase(v.begin() + k - 1);
        v.insert(v.begin() + j + 1, sum);
        ans += sum;
    }
    
    printf("%d", ans);
    return 0;
}
```


### 加西亚-瓦克斯(GarsiaWachs)算法.

这种算法是基于最优二叉树提出的，有一个概念叫做

**二叉树中预期比较次数**

![](https://s2.ax1x.com/2020/02/19/3V3io8.png)

根节点的 $level = 0$ 

二叉查找树中给定几个概率值, $p_1, p_2,\ldots, p_n$ 和 $q_0, q_1, \ldots, q_n$
 
$p_i$ 表示查找参数是 $K_i$ 的概率， $q_i$ 表示查找参数介于 $p[K_i,K_i+1]$ 概率 

查找预期比较次数是 

${\sum_{j=1}^n p_j(level+1)+{\sum_{k=0}^n}q_k(level_k)}$  

$q_k$ 针对外节点的，其实这理解起来也不难，外节点是直接暴露在外面的

根据只要知道它的层数，比如 $1,2$ 两个外节点都在第 $3$ 层，这时候只要

$3 \times q_1$ 就可以知道 $1$ 出现的概率，也就可以知道比较次数了

$p_j$ 是针对内节点的，一定要通过外节点才能进入内节点，所以要$level + 1$ 



上述公式叫 **树的成本**，预期比较次数为

外节点:  $\{0,1,2,3\},2q_0+3q_1+3q_2+q_3$ 

内节点:  $\{1,2,3\},2p_1+3p_2+p_3$

二者的和就是这个树的成本



**加西亚瓦克斯算法就是上述树的成本中，$p_k = 0$ 时候的特例** 
$$
c = \sum_{k=0}^nq_kl_k
$$


#### 引理一，最优二叉树的转化

如果 $q_{k-1} \gt q_{k+1}$，则在每棵最优树中，$l_k \le l_{k+1}$

如果 $q_{k-1} = q_{k+1}$，则在某些最优树中，$l_k \le l_k+1$ 



证明方法，看一个二叉树的剪裁

![](https://s2.ax1x.com/2020/02/19/3V36ld.png)

不妨设 $q_{k-1} \ge q_{k+1}$，并且考虑$l_k \gt l_{k+1}$

那么树的形状一定如上图所示，$k$ 为右孩子

这个时候如果按照图中的方式剪裁，两条线中的部分裁掉

让左子节点 $L$ 成为新的 $parent$ ，并且 $[l_k-1,l_{k+1}]$ 部分裁掉

使得 $k$ 节点上浮，并且 $k+1$ 节点下沉一个单位

不妨设 $L$ 是一个权值为 $w$ 的子树， $w \ge q_{k-1}$ ，这是显然的

因为我们假定 $q_{k-1} \ge q_{k+1}$ ，那么在左边的外节点权值更大

这样裁剪之后，总的权值变化包括 $3$ 个部分

1） $L$ 裁掉，$-w $}

2） $k$ 上浮，$-q_k(l_k-l_{k+1}-1)$    

3） $k+1$下沉，$q_{k+1}$

$$\Delta = -w-q_k(l_k-l_{k+1}-1)+q_{k+1} \le -q_{k-1}-q_k(l_k-l_{k-1}-1)+q_{k+1}\le q_{k+1} - q{k-1}$$

如果 $q_{k+1}-q_{k-1}\lt0$ ，显然不是最优的，矛盾

另外，如果 $q_{k-1}=q_{k+1}$ ，则已经将一棵最优树转变成为另一颗了

 $k-1$ 和 $k+1$ 这个层次上等价，$l_{k-1}=l_{k+1}$，构成最优树



#### 引理二，树的旋转调整分支高度

假定 $j$ 和 $k$ 是满足 $j \lt k$ 的下标，并且满足

1. 对于 $1\le i\lt k,q_{i-1} \gt q_{i+1}$ 
2. $q_{k-1} \le q_{k+1}$
3. 对于 $j \le i \lt k-1,q_i \lt q_{k-1} + q_k$ 
4. $q_{j-1} \ge q_{k-1} + q_k$

于是，**存在一颗满足 $l_{k-1}=l_k$ 的最优树**，同时，它还满足以下条件之一

$a. l_j=l_k-1$

$b.l_j=l_k$ 且 $j$ 为左孩子

证明方法，从引理一直到 $q_{k-1} \le q_{k+1}$，存在满足 $l_{k-1}\ge l_k$ 的最优树

对于 $1 \le i \lt k$ 而言，还有 $l_1 \le l_2 \le \ldots \le l_k$，因此有 $l_{k-1}=l_k$

其次，我们关注树的层次，如下图所示

![](https://s2.ax1x.com/2020/02/19/3V3vkT.png)

先看如图所示的三层结构，对于满足 $j \le s \lt k-1 $ 的  $s$ 有

$l_s \lt l_k-1 \le l_{s+1}$，假设 $t$ 是满足 $l_t=l_k$ 且小于 $k$ 的最小下标

于是，对于 $s\lt i\lt t $ ，有 $l_i = l_k-1$ 并且 $s+1$ 为左孩子，或者

$s+1=t$，这样我们可以通过二叉树旋转等操作

**让部分节点上升，部分节点下降**

如果让s所在的分支下降，t所在的分支上升的话

$\Delta=q_s-q_t-q_t+1$，因为$t \lt k$，所以 $q_t\gt q_{k-1} \& q_{t+1} \gt q_k$

$\Delta=q_s-q_t-q_{t+1} \le q_s-q_{k-1}-q_k$

如果 $q_s\lt q_{k-1}+q_k$ ，所以 $\Delta \lt 0$ ，次时能得到更优的二叉树

旋转之后， $l_j \ge l_k-1$

再看最后一个部分，如果 $l_j=l_k$ 并且 $j$ 是有孩子的话，则一定有如下情况

![](https://s2.ax1x.com/2020/02/19/3V8PXR.png)

如果旋转二叉树，让 $j-1$ 下降，让 $k-1,k$ 这个分支上升

$\Delta = -q_{j-1}+q_{k-1}+q_k \le 0$ ，此时二叉树并不是最优的，和假设矛盾



#### 引理三，加西亚瓦克斯算法核心

如上所述，可以考虑删除 $q_{k-1}$ 和 $q_k$ 并且在 $q_{j-1}$ 之后插入 $q_{k-1}+q_k$

所得到的概率 $(q_0',\ldots ,q_{n-1}')=(q_0,\ldots,q_{j-1}, q_{k-1}+q_k,q_j,\ldots,q_{k-2},q_k+1,\ldots,q_n)$

于是，$C(q_0',\ldots,q_{n-1}')\le C(q_0,\ldots,q_n)-(q_{k-1}+q_k)$

排列方式

$0,\ldots,j-1,k-1,k,j,\ldots,k-2,k+1,\ldots,n$

更优

这就很简单了，根据**引理二**，如果是$b$类型的，只需要重命名这些叶节点就可以

如果是$a$类型的呢？可以通过**旋转二叉树**的方式，**让 $(k-1,k)$ 这两个叶子对**

**上升一个高度**，实际上就是在 $l_k$ 这个高度上，减掉 $q_{k-1}+q_k$ ，然后向左移动

在 $j-1$ 后面插入即可

#### 引理四

任何一个排列方式如**引理三**所述的树，都可以转化成为

成本相同，叶子排列顺序为 $0,1,\ldots,n$ 的树

1. 如果 $j=k-1$ ，显然成立

2. 如果不相等，因为 $q_{j-1} \ge q_{k-1} + q_k \gt q_j$ (**引理二**条件)

   $0,\ldots,j-1,k-1,k,j,\ldots,k-2,k+1,\ldots,n$

                     ↑             ↑

                     j           k - 1 

   $q'$ 的下标表示如上所示，所以对于 $j \le i \le k-1$，有 $q_{i-1}' \gt q_{i+1}'$

   于是根据引理，有 $l_x \le l_j \le \ldots \le l_{k-2}$，其中 $l_x$ 是 $x$ 的级别，并且

   对于 $j \le i \lt k-1$，$l_i$ 是 $i$ 的级别

    $a.$  如果 $l_x=l_{x-2}$，都在同一级上

   ​		$i,\ldots,k-2,x$ 替换序列 $x,i,\ldots,k-2$

     $b.$  否则，假定 $l_s=l_x$，$l_{s+1}>l_x$，令 $l=l_x+1$，并且

   ​  	  $l$ 是节点 $(k-1,k)$ 的公共级别，使得

   ​		$l \le l_{s+1}\le \ldots\le l_{k-2}$，最后可以通过循环位移操作，使得

   ​		$k-1,k,s+1,\ldots,k+2$ 变成 $s+1,\ldots,k-2,k-1,k$  

	~~有看不懂的别找我~~
    
   ~~这个 $\LaTeX$ 快敲死我了~~ 
    
   终

---

## 作者：jyz666 (赞：47)

# 题解 P5569 【[SDOI2008]石子合并】

[传送门](https://www.luogu.com.cn/problem/P5569)

这题一开始一看，还以为是双倍经验。。

写一个普通dp。

AC：3 RE：7

仔细一看是一个加强版，N<=40000

啊这。。。

费（kan）尽（le）心（ti）思（jie），才知道原来这道题要用GarsiaWachs算法。

这个算法简述来说就是：加入有$a,b,c$三个石子堆

先合并左边两个的代价是$2a+2b+c$，而先合并右边两个的代价是$a+2b+2c$，所以只用看$a$和$c$，$a<c$

于是先合并$a<c$的吧，完了之后如果还有剩就从右边开始合并$bc$

合并$ab$的时候，合并之后插入从左边数第一个大于他的数的后面开始，究竟为什么这么做我也不怎么理解。。。

但是如果这道题就这样按照所说的话会$TLE$
，因为插入删除都是$O(n)$的，所以只好想个办法让这个$n$变得比较小

新开了一个数组，一个一个加石头进去，满足$a b$的合并条件就合并，这样会保持$n$比较小

### 上代码》》

```cpp
#include<cmath>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<algorithm>
#include<queue>
#include<vector>
#include<iostream>
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef double db;
#define maxn 50010
#define inf 0x3f3f3f3f
const int mod=100003;

void read(int &x){
	int f=1;x=0;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-') f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9') {x=x*10+ch-'0';ch=getchar();}
	x*=f;
}
int n,w; long long ans=0; 
vector<int> l; 
int solu(){
	int k=l.size()-2,q=-1; 
	for(int i=0;i<l.size()-2;++i) if (l[i]<=l[i+2]) {k=i;break;}
	int t=l[k]+l[k+1]; 
	l.erase(l.begin()+k);l.erase(l.begin()+k);
	for(int i=k-1;i>=0;--i) if (l[i]>t) {q=i; break;}
    l.insert(l.begin()+q+1,t); 
	return t; 
}
int main(){
	read(n); 
	for(int i=1;i<=n;++i) read(w),l.push_back(w); 
	for(int i=0;i<n-1;i++) ans+=solu(); 
	printf("%lld",ans); 
	return 0;
}
```

###  _勝負は時の運、と言うでしょ？_ 

---

## 作者：VRVRVR (赞：40)

作为一个蒟蒻，我只是想以此题介绍一个名叫GarsiaWachs的算法。
奆佬千万不要d我，下面切入正题。
## 算法介绍
没啥可说的，对于这个算法，我只知道结论。GarsiaWachs算法专门解决石子合并问题：

设一个序列是A[0..n-1]，每次寻找最小的一个满足A[k-1]<=A[k+1]的k,那么我们就把A[k]与A[k-1]合并，之后从k向前寻找第一个满足A[j]>A[k]+A[k-1]的j,把合并后的值A[k]+A[k-1]插入A[j]的后面。 听上去十分绕口，那我们举个栗子吧。

a[5]=186 64 35 32 103   
因为35<103，所以最小的k是3，我们先把35和32删除，得到他们的和67，并向前寻找一个第一个超过67的数，把67插入到他后面   
186 64（k=3,A[3]与A[2]都被删除了） 103    
于是186 67 64 103   
186 131 103    
234 186   
420   
则ans=420+234+131+67=852   
知道了这个就可以轻松AC此题（Tip:此题数据比较大，一开始没优化，就TLE了，qwq)
下面是AC代码：（详见https://blog.csdn.net/lycheng1215/article/details/73290279/）
## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
long long ans,n;
vector<int> l;
inline int read()
{
    int i=0; char c=getchar();
    while(c>'9'||c<'0')c=getchar();
    while(c>='0'&&c<='9')i=i*10+c-'0',c=getchar();
    return i;
}
int merge()
{
    int k=l.size()-1-1;//如果我们在A[0]到A[n-3]找不到A[k]<=A[k+2]，那么k的值应该为n-2
    for(int i=0;i<l.size()-2;++i)
    {
        if(l[i]<=l[i+2])
        {
            k=i;
            break;
        }
    }
    int tmp=l[k]+l[k+1];
    l.erase(l.begin()+k);
    l.erase(l.begin()+k);//删除
    int in=-1;
    for(int i=k-1;i>=0;--i) //从右往左找第一个 
    {
        if(l[i]>tmp)
        {
            in=i;
            break;
        }
    }
    l.insert(l.begin()+in+1,tmp);//因为是在后面插入，所以要+1
  return tmp; 
}
int main()
{
    cin>>n;
    for(int i=1; i<=n;++i)
        l.push_back(read());
    for(int i=0;i<n-1;i++)
        ans+=merge();
    cout<<ans;
    return 0;
}
```
qwq.

---

## 作者：Provicy (赞：25)

此题的$n$范围较大，故$O(n^2)$算法肯定无法通过。

仔细思考一下，其实石子合并问题就是一个**最优树**问题

我们从序列中找到第一个$a[i]$，使得$a[i-1]<=a[i+1]$，然后我们就将$a[i-1]$和$a[i]$合并。

然后我们再从序列的第$i$位向前找到第一个$a[k]$使得$a[k]>a[i-1]+a[i]$，然后将这个数放在第$k$个位置后。如果根本找不到这样的数就将这个合并的数扔在序列最前面就行了。如果连$i$都找不到，显然最后两个数最小。根据[合并果子](https://www.luogu.org/problem/P1090)这题的经验，直接将这两个数合并即可。

如以上操作直到最后只剩两堆石子为止，可以证明此时为最优解。

代码如下（**$Tip$：本人思考思路和代码思路均来自[此文章](https://blog.csdn.net/nameofcsdn/article/details/79682936)，若看不懂的可以去这篇文章看看，讲的基本和我一样，对于这个做法还有一篇严格证明的文章**)

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
const ll N=41000;
ll n,a[N],ans,now=1,pro;
int main()
{
	scanf("%lld",&n);
	for(ll i=1;i<=n;i++) scanf("%lld",&a[i]);
	while(now<n-1)
	{
		for(pro=now;pro<n-1;pro++)
		{
			if(a[pro+2]<a[pro]) continue;
			a[pro+1]+=a[pro];
            ans+=a[pro+1];ll k;
			for(k=pro;k>now;k--) a[k]=a[k-1]; 
            now++; k=pro+1;
			while(now<k&&a[k-1]<a[k]) {a[k]^=a[k-1]^=a[k]^=a[k-1];k--;}
			break;
		}
		if(pro==n-1) {a[n-1]+=a[n];ans+=a[n-1];n--;}
	}
	if(now==n-1) ans+=(a[n-1]+a[n]); 
    printf("%lld\n",ans);
	return 0;
}
```


---

## 作者：EternalHeart1314 (赞：20)

### [题目传送门](https://www.luogu.com.cn/problem/P5569)

$\text{Upd on 2024.8.20}$：之前写的是“时间复杂度 $O(n\log n)$”，但那是加了平衡树优化的，我用的是链表，[~~然后被一个大佬叉掉了~~](https://www.luogu.com.cn/discuss/837580)，时间复杂度应是 $O(n\max a_i)$。

第一篇紫题题解，激动！

# 题意

我认为是个正常人都能理解。

# 错解：区间DP

此题数据范围 $n \le 40000$，即使加了四边形不等式优化，$O(n ^ 2)$ 也肯定爆炸，[这道](https://www.luogu.com.cn/problem/P1775)和[这道](https://www.luogu.com.cn/problem/P1880)才能用四边形不等式优化，~~为什么弱化版数据比普通版大~~。

# 正解：Garsia–Wachs 算法

时间复杂度较为玄学，但不超过 $O(n \log n)$。

具体什么原理~~我也不知道~~，给个[link](https://oi-wiki.org/misc/garsia-wachs/)。

### 个人感性理解：

有三个连续的石子堆，分别有 $x$，$y$，$z$ 个石子。

先合并 $x$ 和 $y$ 的得分是 $2x + 2y + z$。

先合并 $y$ 和 $z$ 的得分是 $x + 2y + 2z$。

所以如果 $x \le z$，就先合并 $x$ 和 $y$，否则就先合并 $y$ 和 $z$。

~~要证明就去看别的题解吧~~，[link](https://eastern.blog.luogu.org/post-ti-xie-garsiawachs-suan-fa)。

但 $O(n\log n)$ 的时间复杂度是需要平衡树优化的，我当时不会（现在会了），发现 $a_i$ 很小，于是绞尽脑汁，~~最后翻了翻题解区~~：嗯？怎么没一个链表？这么明显的删除和插入，居然没有链表？

于是，我就愤然敲了一个链表，跑得还挺快，~~虽然开了O2还被挤到了第5页~~，[link](https://www.luogu.com.cn/record/134068938)。

用链表的时间复杂度是 $O(n\max a_i)$。

剩下的细节都在代码里了。

# code
```
#include<bits/stdc++.h>
#define int long long 
using namespace std;

const int N(41514);
int n, i, j, s, ans, a[N], l[N], r[N] = {1};

signed main() {
	ios::sync_with_stdio(0);
	cin.tie(0), cout.tie(0);
	cin >> n;
	for(int i(1); i <= n; ++ i) {
		l[i] = i - 1;
		r[i] = i + 1;
		cin >> a[i];
	}
	a[0] = a[n + 1] = 0x3f3f3f3f3f3f3f3f;	//够大了吧 
	while(-- n) {
		i = r[0];	//0号的右边就是第一个位置 
		while(a[l[i]] > a[r[i]]) {
			i = r[i];
		}	//找到 a[l[i]] <= a[r[i]] 的第一个位置 
		s = a[i] + a[l[i]];	//合并的分数 
		j = i;	//记住位置 
		r[l[l[i]]] = r[i];
		l[r[i]] = l[l[i]];	//删除位置 l[i] 和 i 
		i = l[l[i]];
		while(a[i] < s) {
			i = l[i];
		}
		l[j] = i, r[j] = r[i];	//由于 j 是刚刚的 i，而刚刚的 i 已经被删除了，所以就把 j 当作一个新节点插入到 i 的右边 
		l[r[i]] = j, r[i] = j;
		a[j] = s;	//更新值 
		ans += s;	//累计 
	}
	cout << ans;
	return 0;
}
```

### 珍惜生命，远离抄袭

---

## 作者：RainsAFO (赞：8)

**GarsiaWachs**了解一下

据说专为石子合并设计？

记石子个数为st[i]。

扫出满足stone[k-1] <= st[k+1]的k，找到后合并st[k]和st[k-1]，再从当前位置反向找maxj，使st[j] > st[k]+st[k-1]，扔到j后面。

重复以上操作，最后答案为合并所需之和。

假设st[-1]和st[n]为无穷，避免不必要的问题。

复杂度n方，很慌~~然而过了~~

效率在于找最小的k，于是考虑平衡树维护，降低至nlong（n）。

代码就不放了qwq

---

## 作者：Edward1002001 (赞：4)

## 详细揭秘：如何实现 $O(n\log n)$ 的 Garsia-Wachs 算法（不限制值域情况下复杂度依然正确）

首先，我们通过查阅其他题解知道了 Garsia-Wachs 算法的正确性证明和操作方法，以下简述一遍操作方法：令 $a_0=a_{n+1}=\inf$，重复下列操作直到序列只有一个元素：找到最小的下标 $k$ 使得 $a_{k-1}\le a_{k+1}$，合并 $a_{k-1}$ 和 $a_k$ 为权值 $v$，将 $v$ 计入答案并将其插入到其前侧最后一个大于等于其的数之后。

下面是一个朴素实现，已经可以通过本题。

```cpp
#include<cstdio>
#include<vector>
const int N=40007;
std::vector<int> a;
int main()
{
	int n;scanf("%d",&n);
	a.push_back(1e9);
	for(int i=1,x;i<=n;++i)
		scanf("%d",&x),a.push_back(x);
	a.push_back(1e9);
	long long ans=0;
	while(a.size()>3)
	{
		int k=1;while(a[k-1]>a[k+1])++k;
		int x=a[k-1],y=a[k];ans+=x+y;
		a.erase(a.begin()+k-1,a.begin()+k+1);
		int p=k-2;while(a[p]<x+y)--p;
		a.insert(a.begin()+p+1,x+y);
	}
	printf("%lld",ans);
	return 0;
}
```

接下来我们考虑优化该实现，注意到我们需要优化的 $O(n^2)$ 瓶颈分别位于寻找最小 $a_{k-1}\le a_{k+1}$ 和寻找插入位置，我们先考虑优化寻找插入位置。运用你聪慧的信息学头脑，即可注意到可以用分别维护奇偶下标位置的两棵平衡树来维护 $a_k$ 及其之前的位置[1]，这是由于在其前侧都不满足 $a_{k-1}\le a_{k+1}$，故奇偶位置分别构成递减序列，因此可以在平衡树上查询最后一个比 $v$ 大的数，并取两个位置中较大的一个作为真正要插入的位置。

接下来，我们可以简单的从前到后依次加入元素，如果最新加入的元素 $a_z$ 满足 $a_{z-2}\le a_z$，则反复合并前两个元素直至不满足条件。

**但是，此时我们还有一个重要的问题需要解决**，当我们新插入元素时，可能在前面引入了一些“不满足对”，接下来我们考虑以 `dfs` 的办法处理这一问题：

$\cdots\ \ A_1\ \ B_1\ \ A_2\ \ B_2\ | \ C\ \ A_3\ \ B_3\ \ \cdots$


假如我们的 $C$ 元素插入在了 $B_2$ 后面一位的位置，那么我们考虑有哪些对会不满足条件。注意到分隔号前面和后面各自都满足条件，故只需考虑分隔符两侧的，但是我们又有 $B_2\ge C>A_3$，这是因为 $B_2$ 是最靠右的比 $C$ 大的。并且我们在接下来的操作中要么将 $A_2$ 和 $B_2$ 同时拿走归来 $B_1$，要么将 $A_2$ 和 $B_2$ 的和放入尾端，那么这样 $C$ 前面的值一直不降，故而接下来处理过程中一定一直有 $B_2>A_3$。

故只需考虑是否有 $A_2\le C$ 即可，如果满足 $A_2\le C$，那么就对 $A_2$ 和 $B_2$ 递归执行合并插入过程，然后再检查 $A_2\le C$ 的条件即可，这里和 `dfs` 式朴素实现[2]是类似的。

更具体地来说，我们使用两个 `treap` 来实现平衡树，这样更好实现分裂和合并操作（注意最后可能会将一个平衡树中的一段合并进另一个平衡树中）。由于可能会对同一个 $C$ 合并多次前面的部分，前面的长度奇偶性也会发生改变，故而每次判断的时候要根据长度判定需要取 $A$ 数组还是 $B$ 数组的最后一位判定，不过 $C$ 本身并不会参加合并，故而可以直接将其和后部数列同奇偶性的合并，代码中的 $A$ 平衡树维护的是奇数位，$B$ 是偶数位，但代码中 `dfs` 内后半段的 $A2,B2$ 分别指代含有 $C$ 元素的后半段模二同余数列和不含其的后半段模二同余数列。

以下是代码实现。

```cpp
#include<cstdio>
#include<vector>
#include<random>
const int N=100007;
typedef long long ll;
const ll inf=1e18;
std::mt19937 rng(0x66ccff);
int sz[N],ls[N],rs[N],tar[N],vc;
ll mn[N],mx[N],vl[N];
inline int New(ll v)
{
	int p=++vc;sz[p]=1;mn[p]=mx[p]=vl[p]=v;
	ls[p]=rs[p]=0;tar[p]=rng();return p;
}
inline void pull(int x)
{
	sz[x]=sz[ls[x]]+sz[rs[x]]+1;
	mn[x]=rs[x]?mn[rs[x]]:vl[x];
	mx[x]=ls[x]?mx[ls[x]]:vl[x];
}
void splitw(int p,ll w,int&x,int&y)//>=w,<w
{
	if(!p){x=y=0;return;}
	if(w<=vl[p])x=p,splitw(rs[x],w,rs[x],y);
	else y=p,splitw(ls[y],w,x,ls[y]);
	pull(p);
}
void splitsz(int p,int k,int&x,int&y)//<=k,>w
{
	if(!p){x=y=0;return;}
	if(k>sz[ls[p]])x=p,splitsz(rs[x],k-sz[ls[p]]-1,rs[x],y);
	else y=p,splitsz(ls[y],k,x,ls[y]);
	pull(p);
}
int merge(int x,int y)
{
	if(!x||!y)return x|y;
	if(tar[x]<=tar[y])return rs[x]=merge(rs[x],y),pull(x),x;
	return ls[y]=merge(x,ls[y]),pull(y),y;
}
int a[N],Ts;ll ans;
void dfs(int&A,int&B)
{
	int A1,A2,B1,B2,x,y;
	splitsz(A,sz[A]-1,A,x);splitsz(B,sz[B]-1,B,y);
	vl[x]+=vl[y];ans+=vl[x];pull(x);
	splitw(A,vl[x],A1,A2);splitw(B,vl[x],B1,B2);
	
	int aid=sz[A1]*2-2,bid=sz[B1]*2-1,kpos=std::max(aid,bid);
	if(kpos&1)splitsz(A2,sz[B1]-sz[A1],Ts,A2),A1=merge(A1,Ts),B2=merge(x,B2),std::swap(A2,B2);
	else splitsz(B2,sz[A1]-sz[B1]-1,Ts,B2),B1=merge(B1,Ts),A2=merge(x,A2);
	//A2:hav-x,B2:non-x
	
	while(mn[sz[A1]==sz[B1]?A1:B1]<=vl[x])dfs(A1,B1);
	if(sz[A1]!=sz[B1])std::swap(A2,B2);
	A=merge(A1,A2);B=merge(B1,B2);
}
int main()
{
	int n;scanf("%d",&n);
	for(int i=1;i<=n;++i)scanf("%d",a+i);
	int A=New(inf),B=New(inf);
	for(int i=1;i<=n+1;++i)
	{
		int x=New(i<=n?a[i]:inf-1);
		while(mn[sz[A]==sz[B]?A:B]<=vl[x])dfs(A,B);
		if(sz[A]==sz[B])A=merge(A,x);else B=merge(B,x);
	}
	printf("%lld",ans);
	return 0;
}
```

参考文献：

[1]https://oiwiki.org/misc/garsia-wachs/

[2]https://www.cnblogs.com/NINGLONG/p/7624787.html

[3]\(可能是2的较早出处,2014年\)https://blog.csdn.net/acdreamers/article/details/18043897

[4]\(一篇使用dfs实现的题解\)https://www.luogu.com.cn/discuss/835184

---

## 作者：licn (赞：3)

介绍一下一个专门解决石子合并问题的算法，**GarsiaWachs** 算法。（本算法局限性较强可以了解一下）

## **做法：**

我们把合并过程看成一颗树，它一定是一个二叉树。但是合并顺序影响结果的是合并顺序如何去找出正确的合并顺序？

1.寻找本次需要合并的点：从左往右找到第一个 $a_{i-1}<a_{i+1}$ 我们将 $a_{i-1}$ 和 $a_{i}$ 合并。

2.合并之后放置的位置：从 $i-1$ 开始向左找到第一个 $a_{j}>a_i+a_{i-1}$ 将 $a_i+a_{i-1}$ 插入到 $j$ 前面。并且将原来位置上的删掉。

可使用动态数组实现，将 $a_0$ 和 $a_{n+1}$ 赋为 $\infty$ 方便操作。

## code
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=4e4+10,M=1e16;
int n,ans,x;
vector<int>v;
signed main(){
	scanf("%lld",&n);
	v.push_back(M);
	for(int i=1;i<=n;i++)scanf("%lld",&x),v.push_back(x);
	v.push_back(M);
	n++;
	while(n--&&n>1)
	{
		int i;
		for(i=1;i<=n;i++)
			if(v[i-1]<v[i+1])break;
		int ret=v[i-1]+v[i];
		ans+=ret;
		int k;
		for(k=i-1;k>=0;k--)
			if(v[k]>ret)break;
		v.erase(v.begin()+i-1);
		v.erase(v.begin()+i-1);//删除原来位置
		v.insert(v.begin()+k+1,ret);//将合并出来的值插入
	}
	printf("%lld",ans);
	return 0;
}

---

## 作者：dtw35l (赞：2)

# 思路
本题使用 GarsiaWachs 算法，算法过程如下（$a_i$ 代表第 $i$ **堆**石子）
### 算法过程
1. 我们首先从左到右找到第一个 $a_i \le a_{i+2}$，把 $i$ 合并到 $i+1$ 上面
2. 不断地把 $i$ 向前移动（将 $i$ 和 $i-1$ 换位置）直到 $a_j \ge a_i+a_{i+1}$，就把新合并的 $i+1$ 放在 $j$ 后面（若一直没有 $j$ 让她停下，就把她放在最前面）
3. 如果没有找到这样的 $i$ 就合并 $a_n$ 和 $a_{n-1}$
4. 继续第一步，直到石子堆数为 2 堆，就可以直接合并了

### 算法实现
我们用一个变量 $left$ 表示目前第一堆，用 $right$ 表示最后一堆，显然初始 $left=1,right=n$ 所以一直模拟算法操作，直到堆的数量在两堆及以内，就可以直接合并了，模拟不难写，用一个数组就可以，~~大佬们都在用 vector 可是蒟蒻不会~~，要记得每次合并都记上代价，具体的操作细节看代码注释即可。
# 代码
```cpp
#include <bits/stdc++.h>
#define int long long
#define AC return 0 
using namespace std;
const int N = 4e4 + 10;
int n, a[N], ans; // a[i]为第i堆石子数量，ans答案 
signed main() {
	cin >> n;
	for (int i = 1; i <= n; i++) scanf("%lld", &a[i]);
	int left = 1, right = n; // 如上面所说，初始状态 
	while (right - left + 1 >= 3) { // 堆数比3多 
		int k;
		for (k = left; k + 2 <= right; k++) { // 找那个数 
			if (a[k] <= a[k + 2]) { // 找到了 
				a[k + 1] += a[k]; // 合并 
				ans += a[k + 1];  // 把合并所需要的代价记上 
				for (int i = k; i > left; i--) 
					a[i] = a[i - 1]; // 把石子合并后左边的往右错一位，填补空位 
				left++;
				int j = k; // 算法过程第二步 
				while (j >= left && a[j + 1] > a[j]) {
					swap(a[j], a[j + 1]); j--; // 向前移动 
				}
				break;
			}
		}
		if (k + 2 == right + 1) { // 如果没有找到，即操作3 
			a[right - 1] += a[right]; // 合并最后的两个石子堆 
			right--;
			ans += a[right]; // 代价也要记 
		}
	}
	ans += a[left] + a[right]; // 一定别忘了记上最后一次合并两堆的代价 
	cout << ans << endl;
	AC;
}
```

---

## 作者：ZBH_123 (赞：2)

### 错误思路：区间 dp
根据题意，**只有推算出长度短的子序列所需的最小合并代价，才能推算出长度长的子序列所需的最小合并代价。** 那我们就设 $dp_{l,r}$ 为把第 $l \sim r$ 堆石子合并成一堆石子的最少代价。那么，对于所有的 $1 \le i \le N$，都有 $dp_{i,i}=0$。接着，我们先枚举区间长度 $len$，接着再区间合法的情况下枚举区间的左端点 $l$，根据左端点推算出右端点 $r$。然后，我们枚举位于 $l$ 和 $r-1$ 之间的断点 $k$，表明把第 $l \sim r$ 堆石子合并成的一堆石子是由第 $l \sim k$ 堆石子合并成的一堆石子以及第 $k+1 \sim r$ 堆石子合并成的一堆石子合并而成的。由于把两大堆石子合并的代价为第 $l \sim r$ 堆石子的重量和，所以考虑使用前缀和优化，使得合并代价的时间复杂度为 $O(1)$。

综上所述，区间 dp 的整体时间为 $O(n^3)$，对于 $N \le 10^5$ 的数据在效率方面难以忍受，只能通过本题的弱化版，也就是 [P1775](https://www.luogu.com.cn/problem/P1775) 。所以我们需要换一种做法。
### 正解思路：GarsiaWachs 算法
第一步：在目前的序列中找到第一个满足 $a_{k-1} \le a_{k+1}$ 的 $k$，如果找不到就把 $k$ 设为当前序列的长度。

第二步：将 $a_k$ 和 $a_{k-1}$ 从序列中删除，并将它们合并。

第三步：从 $k$ 开始向前找，找到第一个满足 $a_l>a_k+a_{k-1}$ 的 $l$，将 $a_k+a_{k-1}$ 插到 $a_l$ 的后面。

第四步：若当前序列长度为 $1$，则退出程序，输出答案。否则回到第一步，继续合并操作。

AC code：
```cpp
#include<iostream>
#include<vector>
using namespace std;
#define int long long
const int maxn=4e4;
int n,x,ans;
vector<int>a;
signed main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>x;
		a.push_back(x);
	}
	while(a.size()>1){
		int k=a.size()-2,p=-1;
		for(int i=0;i<a.size()-2;i++){
			if(a[i]<=a[i+2]){
				k=i;
				break;
			}
		}
		int tmp=a[k]+a[k+1];
		a.erase(a.begin()+k);
		a.erase(a.begin()+k);
		for(int i=k-1;i>=0;i--){
			if(a[i]>tmp){
				p=i;
				break;
			}
		}
		a.insert(a.begin()+p+1,tmp);
		ans+=tmp;
	}
	cout<<ans;
	return 0;
}
```

---


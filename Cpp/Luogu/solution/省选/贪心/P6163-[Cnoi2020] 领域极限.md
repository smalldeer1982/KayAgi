# [Cnoi2020] 领域极限

## 题目描述

Cirno 有 $n$ 个整数，分别记作 $a_1,a_2,a_3,...,a_n$。

对于每一个数 $a_i$ 都有一个限制二元组 $(l_i,r_i)$。

Cirno 想知道：

$$\min_{\forall t, a_t \in [l_t,r_t]}\big\{\sum_{i=1}^{n}\sum_{j=1}^{n}\left| a_i - a_j \right|\big\}$$

## 说明/提示

### Sample1说明

$(a_1,a_2,a_3)=(2,3,3)$ 时，答案取到最小值。

### 数据范围与约定

**「本题采用捆绑测试」**

 - Subtask1( $20\%$ ) : $n \le 10$，且 $r_i - l_i \le 5$；
 - Subtask2( $20\%$ ) : $n \le 20$；
 - Subtask3( $20\%$ ) : $n \le 10^3$；
 - Subtask4( $40\%$ ) : $n \le 10^5$；

对于 $100\%$ 的数据 : $n \in (0,10^5]$，$0 \le l_i \le r_i \le 10^9$，答案在 $[0,4 \times 10^{18}]$ 内。

## 样例 #1

### 输入

```
3
1 2
2 3
3 4```

### 输出

```
4```

## 样例 #2

### 输入

```
8
39 42
53 55
51 52
46 47
52 54
33 38
2 7
32 34```

### 输出

```
910```

# 题解

## 作者：George1123 (赞：9)

# 题解-[Cnoi2020]领域极限
**参考资料**
> https://www.luogu.com.cn/blog/qwq-qwq/solution-p6163

---
## $\color{#000}\texttt{Introduction}$
蒟蒻参赛做不出此题，比赛完后看了神仙 $\color{#000}\texttt{N}\color{#f00}\texttt{antf}$ 的某个粉丝的题解，于是想到了二分。但是做法比他的更简单。

---
## $\color{#000}\texttt{Description}$

> [\[Cnoi2020\]领域极限](https://www.luogu.com.cn/problem/P6163)

> 就是给 $n$ 个区间 $[L_i,R_i]$，求 $a_i\in[L_i,R_i]$ 使 $ans=\sum\limits_{i=1}^n\sum\limits_{j=1}^n|a_i-a_j|$ 最小。然后输出这个最小值。

> 数据范围：$1\le n\le 10^5,0\le L_i\le R_i\le 10^9,0\le ans\le 4\times 10^{18}$。

---
## $\color{#000}\texttt{Solution}$
这题的直接思路无非是让每个 $a_i$ 尽量接近，当然，每个 $a_i$ 能一样是最佳情况。如果不能取到每个都一样的 $a_i$ 必然是被某个很大的 $L_i$ 或很小的 $R_i$ 套住了。

所以可以找一个基点 $x$。使

$$
a_i=
\begin{cases}
L_i ~~~(L_i>x)\\
R_i~~~(R_i<x)\\
x~~~~~(L_i\le x\le R_i)
\end{cases}
$$

显然对于不同基点生成的序列不同，但是有一点可以确定——**因为取值中庸最佳，所以答案随 $x$ 而变化的函数应该呈现 $V$ 型**。所以可以二分查找这个基点 $x$。

直接的查找方法是值域二分，可是这里有一个可以优化二分的结论：$x$ 必然等于某个 $L_i$ 或 $R_i$。因为如果最终的 $x$ 不在某个 $L_i$ 或 $R_i$ ，可以集体调整那些等于 $x$ 的 $a_i$ 来无偿或减偿地来使 $x$ 等于某个 $L_i$ 或 $R_i$（这时就没什么中庸了）。

还有个问题，得到 $a_1,a_2,...,a_n$ 怎么计算 $ans$？这里就直接放代码了，这应该是普及知识。

**code**

```cpp
//f 即 a
sort(f+1,f+n+1); lng res=0,sum=0;
for(int i=2;i<=n;i++) sum+=1ll*(f[i]-f[i-1])*(n-i+1);
res+=sum;
for(int i=2;i<=n;i++) sum-=1ll*(f[i]-f[i-1])*(n-i+1),res+=sum;
return res*2;
```
---
## $\color{#000}\texttt{Code}$

```cpp
#include <bits/stdc++.h>
using namespace std;

//&Start
#define lng long long
#define lit long double
const int inf=0x3f3f3f3f;
const lng Inf=1e17;

//&Check
const int N=1e5+10;
int n,l[N],r[N],sor[N<<1],f[N],cnt;
lng ans=Inf;//不开longlong见祖宗
lng Check(int x){
	for(int i=1;i<=n;i++) f[i]=min(max(x,l[i]),r[i]);
	sort(f+1,f+n+1); lng res=0,sum=0;
	for(int i=2;i<=n;i++) sum+=1ll*(f[i]-f[i-1])*(n-i+1);
	for(int i=2;res+=sum,i<=n;i++) sum-=1ll*(f[i]-f[i-1])*(n-i+1);
	return res*2;
}

//&Main
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++) scanf("%d%d",l+i,r+i),sor[++cnt]=l[i],sor[++cnt]=r[i];
	//离散去重
	sort(sor+1,sor+cnt+1),cnt=unique(sor+1,sor+cnt+1)-sor-1;
	int l=0,r=cnt+1;
	while(l<r-1){
		int mid=(l+r)>>1;
		//取中点判断V的谷点的位置
		lng pl=Check(sor[mid]),pr=Check(sor[mid+1]);
		if(pl>pr) l=mid; else r=mid;
		ans=min(ans,min(pl,pr));
	}
	printf("%lld\n",ans);
	return 0;
}
```
---
要是比赛时想到就好了，看来我还是太蒻了。**祝大家学习愉快！**

---

## 作者：xuanxuan001 (赞：8)

打 ARC 的时候做了这题，赛后知道洛谷上有这道原题，不得不说[AT官方题解](https://atcoder.jp/contests/arc147/editorial/4764)的做法是真的妙，所以就讲讲我赛时的贪心做法吧(???)。

先推个式子，首先把 $x$ 按升序排序，那么有

$$
\sum\limits_{i=1}^n\sum\limits_{j=1}^n|x_i - x_j|=2\sum\limits_{i=1}^n\sum\limits_{j=i+1}^nx_j - x_i
$$

先抛掉前面那个那个 2，然后考虑每个 x 被算了多少次，转化为

$$
\sum\limits_{i=1}^n(n-i-(i-1))x_i=\sum\limits_{i=1}^n(-2i+n+1)x_i
$$

也就是说，第 $i$ 个人（按 $x$ 递增排序后的）的位置会给答案带来一个 $2i-n-1$ 的贡献，所以要让前一半的人尽量靠后，后一半人尽量靠前，于是考虑贪心。

最开始一定是让所有人尽量靠后，所以直到遇到某个人的右端点了再把他放下。

考虑将所有的 $l$ 值和 $r$ 值放到一起离散化，然后维护扫描线，对于当前扫描到的位置 $p$，记 $vl_p$ 表示以 $p$ 为左端点的人的数量，$vr_p$ 表示以 $p$ 为右端点的人的数量，$lst$ 为目前确定位置的人的数量，$cnt$ 为左端点在 $p$ 以及 $p$ 之前的人的数量。

那么首先 $cnt \leftarrow cnt + vl_p$，$ans \leftarrow ans + p \sum\limits_{i=lst+1}^{lst+vr_p}(2i-n-1)$，$lst \leftarrow lst + vr_p$，这几步应该不用多说，就是更新 $lst,cnt$，然后更新放在这里的答案，因为右端点就在 $p$ 上的只能放在这上面了。

然后接下来就是比较关键的一步了，就是如果 $cnt+lst \ge n+1$，那么就意味着把目前挂在手上的这 $cnt-lst$ 个人再往后放一个位置对答案的贡献开始增加，否则就是会减少。所以如果发现 $cnt+lst \ge n+1$ 了，那么就将现在挂着的人全部放在 $p$ 上，而再后面的人一定都是后半段了，它们要尽量靠前，所以都取左端点计算答案即可。

感觉整篇题解写的挺草率的，也不知道讲没讲明白，欢迎各位指正。

代码：
```
#include<cstdio>
#include<algorithm>
#define TY ll
#define MAXN 300002
#define debug if( 1 &&putchar('>'))
#define FOR(i,a,b) for(TY i=(a);i<=(b);++i)
#define fOR(i,a,b) for(TY i=(a);i<(b);++i)
#define ROF(i,a,b) for(TY i=(a);i>=(b);--i)
#define rOF(i,a,b) for(TY i=(a);i>(b);--i)
using namespace std;
typedef long long ll;
const TY M=998244353;
typedef unsigned long long ull;
TY _abs(TY a){return a<0?-a:a;}
TY maxn(TY a,TY b){return a>b?a:b;}
TY minn(TY a,TY b){return a<b?a:b;}
TY gcd(TY a,TY b){return b?gcd(b,a%b):a;}
TY qp(TY a,TY b){TY ans=1;do{if(b&1)ans=ans*a%M;a=a*a%M;}while(b>>=1);return ans;}
char getc(){char ch=getchar();while(ch==' '||ch=='\n')ch=getchar();return ch;}
TY qr(){
	char ch=getchar();TY s=0,x=1;
	for(;ch<'0'||ch>'9';ch=getchar())if(ch=='-')x=-1;
	for(;ch>='0'&&ch<='9';ch=getchar())s=s*10+ch-'0';return x*s;
}void qw(TY a,char ch){
	if(a<0){a=-a;putchar('-');}
	if(a>9)qw(a/10,0);putchar(a%10+'0');
	if(ch)putchar(ch);
}TY n=qr(),m,l[MAXN],r[MAXN],b[MAXN<<1],ans,cnt,lst,vl[MAXN<<1],vr[MAXN<<1];
inline TY js(TY x,TY y){return (y-x)*(x+y-n);}
//将(lst,cnt]的人放在某个位置的权值和，其实循环计算也可以
int main(){
	FOR(i,1,n){b[i*2-1]=l[i]=qr();b[i<<1]=r[i]=qr();}
	sort(b+1,b+(n<<1|1));m=unique(b+1,b+(n<<1|1))-b-1;
	FOR(i,1,n){
		++vl[l[i]=lower_bound(b+1,b+m+1,l[i])-b];
		++vr[r[i]=lower_bound(b+1,b+m+1,r[i])-b];//预处理一些数组
	}FOR(i,1,m){
		cnt+=vl[i];
		if(lst+vr[i]+cnt>n){//如果开始转变为后半段
			ans+=b[i]*js(lst,cnt);
			FOR(j,i+1,m)fOR(k,0,vl[j])
				ans+=((++cnt)*2-n-1)*b[j];//将后面的全部取左端点
			break;//考虑完直接退出
		}fOR(j,0,vr[i])ans+=((++lst)*2-n-1)*b[i];//更新lst
	}qw(ans,0);
	return 0;
}
```

---

## 作者：bzy (赞：6)

### [Cnoi2020]领域极限 官方拾遗

#### Subtask1( 20% ) : $n \le 5, r_i-l_i\le 5$ ( 暴力枚举 )

直接枚举每个每个数地取值，枚举次数小于等于 $6^5=7776$，可以轻松通过。

#### Subtask2( 20% ) : $n \le 20$ ( 随机化算法 )

数据范围比较小，使用爬山退火等随机算法都很容易得到最优解。

#### Subtask3( 20% ) : $n \le 1000$ ( 观察性质 )

考虑调整一个数的取值，且各数相对顺序未发生变化，答案的变化等于移动距离乘以该数两边数的个数的差。所以一个显然的贪心是让所有数都尽可能靠近数列的中位数。然后 $2n$ 个端点将数轴分割成 $2n+1$ 个线段，所以枚举中位数所在段即可做到 $O(n^2)$。

注意，中位数在某些段不能取得。

#### Subtask4( 40% ) : $n \le 100000$ ( 三分法 or 继承优化 or 进一步观察性质 )

**三分法** : 其它题解大多选用三分法，却没有给出正确性证明，这里补充一下。我们将离散化后的端点序列看成一个括号序列，令 $f(x)$ 表示中位数取在序列 $x$ 位置时的答案。我们可以知道 $\Delta f(x) = f(x)-f(x-1)=L_x\times ( nxt_x - pre_x )$。$L_x$ 表示 $x$ 段的长度,$pre_x$ 表示 $x$ 前的左括号数, $nxt_x$ 表示 $x$ 后的右括号数。可以知道 $\Delta f(x)$ 单调递减，所以 $f(x)$ 是凹函数。

注意，二分法是错误的，因为中位数不能在某些段取得，那些区域不具有单调性。

**继承优化** : 通过三分法中 $\Delta f(x)$ 的式子可以 $O(1)$ 的从 $f(x)$ 递推到 $f(x+1)$，然后即可 $O(n)$ 求出所有的 $f(x)$ 的值。

**进一步观察性质** : 这是 std 的做法，我自认为比上述两种做法都优秀，但是没有人写。。。

即，当 $x$ 取得括号序列的正中间时 $f(x)$ 必然最小。证明也很简单。我们将括号序列从中间切开，由于序列合法，所以左侧未匹配的左括号与右侧未匹配的右括号数相等，所以此时 $\Delta f(x)=0$ , 凹函数 $f(x)$ 有最小值，于是我们做到 $O(1)$ 确定最优的 $x$。


---

## 作者：Arghariza (赞：4)

应该是最简单的做法，同时也是 AT 官方题解做法。

考虑计算 $\min\sum\limits_{1\le i\le j\le n}|a_i-a_j|$，乘二即为答案。

考虑 $n$ 个线段中使 $l_x$ 最大的 $x$ 以及使 $r_y$ 最小的 $y$。

- 若 $l_x\le r_y$，那么 $\forall i\in [1,n],l_i\le l_x,r_i\ge r_y$，则 $a_i$ 取 $[l_x,r_y]$ 之间的任意数即可，答案为 $0$。
- 否则 $l_x>r_y$，画图发现此时任意 $[l_i,r_i]$ 都与 $[r_y,l_x]$ 有交。所以任意的 $a_i$ 都能取到 $[r_y,l_x]$ 之间的某个值。所以 $|a_i-a_x|+|a_i-a_y|=|a_x-a_y|$。

那么我们把 $[r_y,l_x]$ 的贡献拎出来单独考虑，设剩下的 $n-2$ 个 $l_{\max},r_{\min}$ 的贡献为 $T$，此时的答案为：

$$\begin{aligned}&T+|a_x-a_y|+\sum\limits_{i\neq x,y}(|a_i-a_x|+|a_i-a_y|)\\=\quad&T+(n-1)|a_x-a_y|\end{aligned}$$

由于 $a_x,a_y$ 对后续的统计没有影响了，直接令 $a_x=l_x,a_y=r_y$：

$$\text{ans}=T+(n-1)(l_x-r_y)$$

所以我们每次拿出一个 $l_{\max},r_{\min}$，计算这对 $l,r$ 的贡献，然后再把这对 $l,r$ 从数组中删去，不断重复这个过程直到 $l_{\max}\le r_{\min}$ 即可。

因为这个过程中 $[r_{\min},l_{\max}]$ 这个区间始终是不断缩紧的，所以每个剩下的 $a_i$ 都能满足在任意时刻能取在 $[r_{\min},l_{\max}]$ 之间。

复杂度 $O(n\log n)$，瓶颈在于排序。


```cpp
const int N = 3e5 + 300;
int n, l[N], r[N];

int main() {
    n = rd();
    for (int i = 1; i <= n; i++)
        l[i] = rd(), r[i] = rd();
    sort(l + 1, l + n + 1, greater<int> ());
    sort(r + 1, r + n + 1);
    ll res = 0;
    for (int i = 1; i <= n; i++) {
        if (l[i] <= r[i]) break;
        res += 1ll * (l[i] - r[i]) * (n - 2 * i + 1);
    }
    wr(res * 2);
    return 0;
}
```

---

## 作者：Sol1 (赞：3)

好像我的做法和题解做法全都不一样啊（

考虑一个经典转化：以 $n=6$ 为例，如果最终序列是 $x_1\leq x_2\leq x_3\leq x_4\leq x_5\leq x_6$，那么答案可以被表示成 $-5x_1-3x_2-x_3+x_4+3x_5+5x_6$。

然后把所有区间离散化一下，把右端点挂到左端点。

考虑一个直接的想法，就是从左往右扫，系数为负的时候就等到达一个区间右端点再选，系数为正的时候遇到一个就选一个，但是发现跨过中间的时候会有问题。

于是做一个特判，还是先把再不选就选不了了的选上，然后如果把目前所有可以选的区间选了，它们的系数和为正，那么就全选了；否则就暂时不选。因为再拖一步它们肯定还都能选，所以系数和为负肯定就再拖更优，否则就立刻选了更优。

于是最终的算法流程如下：

- 把所有区间离散化一下，把右端点挂到左端点；
- 从左往右扫，维护一个小根堆存储所有包含当前点的区间的右端点。
- 把所有右端点等于当前位置的区间选了。
- 用当前已经选的区间个数与堆的大小判一下系数和，如果 $\geq 0$ 就把优先队列选到空。

总复杂度 $O(n\log n)$。

```cpp
const int N = 300005;
int n, l[N], r[N], p[N * 2], pl[N], vsz;
long long mul[N], mup[N];
vector <int> adj[N * 2];
priority_queue <int, vector <int>, greater <int> > que;

inline void Read() {
    n = qread();
    for (int i = 1;i <= n;i++) {
        l[i] = qread(); r[i] = qread();
    }
}

inline void Prefix() {
    for (int i = 1;i <= n;i++) {
        p[i] = l[i]; p[i + n] = r[i];
    }
    sort(p + 1, p + 2 * n + 1);
    vsz = unique(p + 1, p + 2 * n + 1) - p - 1;
    for (int i = 1;i <= n;i++) pl[i] = lower_bound(p + 1, p + vsz + 1, l[i]) - p;
    for (int i = 1;i <= n;i++) adj[pl[i]].push_back(i);
    for (int i = 1;i <= n;i++) {
        mul[i] = 2 * (i - 1) - n + 1;
        mup[i] = mup[i - 1] + mul[i];
    }
}

inline void Solve() {
    int cnt = 0;
    long long ans = 0;
    for (int i = 1;i <= vsz;i++) {
        for (int x : adj[i]) que.push(r[x]);
        while (!que.empty() && que.top() == p[i]) {
            que.pop();
            cnt++;
            ans += 1ll * mul[cnt] * p[i];
        }
        if (mup[cnt + que.size()] - mup[cnt] >= 0) {
            while (!que.empty()) {
                cnt++;
                ans += 1ll * mul[cnt] * p[i];
                que.pop();
            }
        }
    }
    cout << (ans * 2) << endl;
}
```

---

## 作者：MikukuOvO (赞：3)

这是一个会$T5$不会$T2$的$zz$选手。。。

这题还是比较好像的，由于要使得答案最小，不难发现应该有一个中心点，所有的点都要尽可能靠近这个中心点。

人类直觉告诉我们，这个中心点的$ans$函数时下凸的。。。

然后直接三分就好了，统计答案可以暴力排序然后前后缀维护就行了。。。

复杂度$nlog^2n$

```cpp
const int N=1e5+5;

int n;
int x[N],y[N],a[N];
ll pre[N],suf[N];

ll calc(int t)
{
    ll res=0;
    for(int i=1;i<=n;++i)
    {
        if(y[i]<t) a[i]=y[i];
        else if(x[i]>t) a[i]=x[i];
        else a[i]=t;
    }
    sort(a+1,a+n+1);
    for(int i=1;i<=n;++i) pre[i]=pre[i-1]+a[i];
    for(int i=n;i>=1;--i) suf[i]=suf[i+1]+a[i];
    for(int i=1;i<=n;++i) res+=1ll*a[i]*i-pre[i]+suf[i]-1ll*a[i]*(n-i+1);
    return res;
}
int main()
{
    fio();
    gi(n);
    int l=INF,r=0;
    for(int i=1;i<=n;++i)
    {
        gi(x[i],y[i]);
        l=min(l,x[i]),r=max(r,y[i]);
    }
    while(l<=r)
    {
        int lmid=l+(r-l)/3,rmid=r-(r-l)/3;
        if(calc(lmid)<calc(rmid)) r=rmid-1;
        else l=lmid+1;
    }
    print(calc(r));
    end();
}
```

---

## 作者：dyc2022 (赞：2)

一个妙的题。

首先，式子里面有一个很烦的绝对值。考虑将绝对值去掉，这样就可以用一个多项式来表达它，从而也好求每个元素的贡献。

我们注意到，当我们得到 $a$ 序列后，答案是和其顺序无关的。因此，我们令 $\{b_1,b_2,\dots,b_n\}$ 为将序列 $\{a_1,a_2,\dots,a_n\}$ 升序排序得到的序列。则我们可以把绝对值去掉：

$$\sum_{i=1}^{n}\sum_{j=1}^{n} \left| a_i - a_j \right| = 2 \sum_{i=2}^{n}\sum_{j=1}^{i-1} (b_i - b_j)$$

进一步化开，观察每一个 $b_i$ 的贡献（即其系数），得：

$$2\sum_{i=1}^{\frac{n}{2}}(n-i \times 2 + 1)(b_{n-i+1} - b_i)$$

那么我们就可以贪心地赋值了。我们想要让 $b_{n-i+1}$ 尽可能小，$b_i$ 尽可能大。所以，我们可以将题目给的区间进行排序，按左端点降序，右端点升序分别排一次。然后直接选端点就能得到最小的代价。

那么这题就做完了，代码奇短：

```cpp
#include<bits/stdc++.h>
#define int long long
#define endl '\n'
#define N 300006
using namespace std;
int n,l[N],r[N],ans;
main()
{
	scanf("%lld",&n);
	for(int i=1;i<=n;i++)scanf("%lld%lld",&l[i],&r[i]);
	sort(l+1,l+1+n,[](int x,int y){return x>y;}),sort(r+1,r+1+n);
	for(int i=1;i<=n&&l[i]>r[i];i++)ans+=(n-2*i+1)*(l[i]-r[i]);
	printf("%lld\n",ans<<1);
	return 0;
}
```

---

## 作者：lanos212 (赞：2)

一篇不使用二分三分的题解。

双倍经验:

https://atcoder.jp/contests/arc147/tasks/arc147_c

考虑如果已经确定了 $a_1,a_2,\dots,a_n$，如果将它们从小到大排序（$a_1$ 最小 $a_n$ 最大），那么可以将答案式子拆开来：

$ans=2(n-1)a_n+2(n-3)a_{n-1}+\dots-2(n-3)a_2-2(n-1)a_1$

（写得形式化一点就是 $ans=2\sum_{i=1}^{n} (2i-n-1)a_i$）

那么大的一段数显然要尽可能往小取，小的一段数显然要尽可能往大了取，那么取的数都会往一个中值靠拢。

我们考虑暴力枚举这个中值，然后将区间分成三段。

![](https://cdn.luogu.com.cn/upload/image_hosting/7xnydovs.png)

为了方便，下文中包含中值的叫做中区间，右端点小于中值的叫做左区间，左端点大于中值的叫做右区间。

那么左区间显然都取自己的右端点最优，右区间都取自己的左端点最优，中区间都取中值最优。

考虑中值每次向右移动一个单位长度时答案的变化：

如果右边有 $r$ 个右区间，那么它们对答案造成的贡献是上面那个式子中的这些部分：

$2(n-1)a_n+2(n-3)a_{n-1}+...+2(n-2r+1)a_{n-r+1}$

如果左边有 $l$ 个左区间，那么它们对答案造成的贡献是上面那个式子中的这些部分：

$-2(n-1)a_1-2(n-3)a_2-...-2(n-2l+1)a_l$

中值向右移动一个单位长度时，中区间仍然都取中值，那么可以看做中区间取值不变而左区间和右区间的都取小了 $1$。

那么右区间对答案贡献的变化值就是：

$-2(n-1)-2(n-3)-\dots-2(n-2r+1)$

左区间对答案贡献的变化值就是:

$2(n-1)+2(n-3)+\dots+2(n-2l+1)$

虽然可以化简这个式子，但没必要，移动过程中维护一下 $l$ 和 $r$，以及这两个式子的和即可。

那么每一次移动只需要加上左右两边的贡献变化值，移动的过程中如果左区间多了或者右区间少了，对贡献变化的式子进行加减即可。

值域是 $10^9$ 的，如果这样枚举可能会超时，可以中间算一下下一次区间发生变化的中值是什么时候，然后一次挪完，或者倍增瞎搞跳到下一次区间变化之前都可以，这样复杂度是 $O(n \log n)$ 的。

code
```cpp
#include<bits/stdc++.h>
#define pii pair<int,int>
using namespace std;
long long n,lsum,rsum,lx,rx,now,ans;
priority_queue<pii,vector<pii>,greater<pii> > rq,mq;
struct st{
	long long l,r;
} e[500001];
inline bool cmp(st aa,st bb){return aa.r>bb.r;}
inline bool cmpp(st aa,st bb){return aa.l<bb.l;}
int main(){
	ios::sync_with_stdio(false);
	cin>>n;
	for (int i=1;i<=n;++i) cin>>e[i].l>>e[i].r;
	sort(e+1,e+n+1,cmp);
	for (int i=1;i<=n;++i) rq.push({e[i].l,e[i].r});
	for (int i=1;i<=n;++i) rsum+=(n-(i*2-1));
	sort(e+1,e+n+1,cmpp);
	for (int i=1;i<=n;++i) now-=(n-(i*2-1))*e[i].l;
	rx=n; ans=now;//一开始中值无限小时答案先算好 
	for (int i=0;i<=1000000001;++i){
		now-=rsum;//rsum是右边的贡献变化值 rx是右区间个数 
		now+=lsum;//lsum是左边的贡献变化值 lx是左区间个数 
		ans=min(ans,now);
		while (!rq.empty() && rq.top().first<=i){
			int l=rq.top().first,r=rq.top().second; rq.pop();
			mq.push({r,l});
			rsum-=(n-(rx*2-1));
			--rx;
		}//左区间移成中区间 
		while (!mq.empty() && mq.top().first<=i){
			int r=mq.top().first; mq.pop();
			++lx;
			lsum+=(n-(lx*2-1));
		}//中区间移成左区间（为了方便，右端点等于中值的也放到左区间里了） 
		if (rq.empty()) break;
		for (int j=20;j>=0;--j) 
			if (i+(1<<j)<rq.top().first && (mq.empty() || i+(1<<j)<mq.top().first)){
				now-=rsum*(1<<j);
				now+=lsum*(1<<j);
				ans=min(ans,now);
				i+=(1<<j);
			}//倍增瞎跳 
	}
	cout<<(ans<<1);//中间过程没乘2最后乘 
	return 0;
}
```


---

## 作者：破忆 (赞：2)

### 【题目大意】
有n个点，每个点的位置都有范围

构造每个点的位置，使得每两个点之间的距离和的两倍最短

------------

### 【分析】

* 如果固定一个基点，那么其它点都应尽可能向它靠近，抱成一团，感性理解一下

* 实验发现~~其实是我不会证~~，距离和与基本点的位置关系，是个下凸函数

* 直觉告诉我~~没错这个我也不会证~~，基点选在区间边界比其它地方更优

直接果断二分/三分即可

~~其实思路和其它题解一样~~

此篇题解主要优化一下计算距离和的部分

------------


### 【算法】
贪心+二分/三分

------------
### 【代码】
```cpp
#include<bits/stdc++.h>
#define LL long long//不开long long见祖宗
using namespace std;
const int maxn=1e5+5,maxt=maxn<<1;
int n,m;
LL a[maxn];
LL l[maxn],r[maxn],d[maxt],c[maxt];
LL read(){
	LL ret=0,f=1;char ch=getchar();
	while(ch>'9'||ch<'0'){if(ch=='-')f=-f;ch=getchar();}
	while(ch>='0'&&ch<='9') ret=ret*10+ch-'0',ch=getchar();
	return ret*f;
}
LL ans=1ll<<60;
LL check(LL x){
	for(int i=1;i<=n;i++) a[i]=min(max(x,l[i]),r[i]);//让所取的点尽量靠近基点
	sort(a+1,a+1+n);
	LL s=0;
	for(int i=1;i<n;i++) s+=1ll*(a[i+1]-a[i])*i*(n-i);
    //a[i+1]-a[i]为相邻两个点的距离
    //这一段，左边有i个点，右边有n-i个点
    //所以对整体的贡献是以上的公式
	ans=min(s*2,ans);//注意需要*2
	return s*2;
}
int main(){
// 	freopen("P6163.in","r",stdin);
// 	freopen("P6163.out","w",stdout);
	n=read();
	for(int i=1;i<=n;i++){
		l[i]=read(),r[i]=read();
		c[2*i-1]=l[i],c[2*i]=r[i];
	}
	sort(c+1,c+1+2*n);//排序
	d[++m]=c[1];
	for(int i=2,e=n*2;i<=e;i++){
		if(c[i]!=c[i-1]) d[++m]=c[i];
	}//去重
	LL L=1,R=m;
	while(R-L>1){//二分
		LL mid=L+(R-L>>1);
		if(check(d[mid])<check(d[mid+1])) R=mid;//比较mid与mid+1谁更优
		else L=mid;
	}
	printf("%lld\n",ans);
	return 0;
}
```


---

## 作者：daduoli (赞：1)

~~蒟蒻太菜了不会贪心，只会暴力。~~

提供一种不需要贪心的做法。

首先很明显答案和我们选的序列的中点有关，对于可以选择中点的区间，我们考虑选择中点，对于无法选择中点的区间，如果他在中点的左边，那么他就要尽量选择他最右端点，如果他在中点的右边，那么他就要尽量选择他最左端点。~~（这是明显的）~~

我们可以知道中点一定在某个区间的端点处，这是可以证明的。

考虑一个中点 $mid$ 不是区间的端点。

如果他左边的数大于 $\frac n2$，那么 $mid$ 往左移一定更优。

若等于 $\frac n2$，那么往左移也一定不劣，对于右边也是同理，所以我们可能成为答案的中点一定在于区间的某个端点。

所以我们考虑枚举区间端点作为中点，我们需要快速求出对于每个中点的贡献。

我们首先需要知道有多少个区间是在 $mid$ 的左边，还要知道有多少个区间在 $mid$ 的右边，这个显然使用树状数组是可以的。

但是我们还要知道在 $mid$ 左边的区间内部贡献，右边同理，这些显然是预处理可以解决，而左边区间与 $mid$ 与右边区间的贡献也可以通过预处理解决。

时间复杂度 $O(n\log n)$

```
#include<bits/stdc++.h>
typedef long long LL;
 
using namespace std;
const int MAXN=6e5+10;
LL n;
LL b[MAXN],cnt,tr[2][MAXN];
LL suf[MAXN],pre[MAXN],pp[MAXN],ss[MAXN];
struct daduoli {
	LL l,r;
}a[MAXN];
bool cmp(daduoli a,daduoli b) {
	return a.l<b.l;
}
bool cmp1(daduoli a,daduoli b) {
	return a.r<b.r;
}
LL ans=1e18;
int lowbit(int x) {
	return x&(-x);
}
void add(int opt,int x) {
	if(opt) x=cnt-x+1;
	for(int i=x;i<=cnt;i+=lowbit(i)) {
		++tr[opt][i];
	}
	return ;
}
LL query(int opt,int x) {
	if(opt) x=cnt-x+1;
	LL ret=0;
	for(int i=x;i;i-=lowbit(i)) {
		ret+=tr[opt][i];
	}
	return ret;
}
void check(int x) {
	LL L=query(0,x-1),R=query(1,x+1),total=n-L-R;
	LL tmp=0;
	R=n-R+1;
	tmp=pre[L]+suf[R];
	tmp+=(LL)(L*b[x]*total-total*pp[L])+(LL)(total*ss[R]-(n-R+1)*b[x]*total);
	tmp+=(LL)(ss[R]*L-pp[L]*(n-R+1));
	if(tmp<ans) {
		ans=tmp;
	}
}
signed main () {
	scanf("%lld",&n);
	for(int i=1;i<=n;++i) {
		scanf("%lld%lld",&a[i].l,&a[i].r);
		b[++cnt]=a[i].l;
		b[++cnt]=a[i].r;
	}
	sort(b+1,b+1+cnt);
	cnt=unique(b+1,b+1+cnt)-b-1;
	for(int i=1;i<=n;++i) {
		a[i].l=lower_bound(b+1,b+1+cnt,a[i].l)-b;
		a[i].r=lower_bound(b+1,b+1+cnt,a[i].r)-b;
		add(0,a[i].r);
		add(1,a[i].l);
	}
	sort(a+1,a+1+n,cmp);
	LL tot=0;
	for(int i=n;i>=1;--i) {
		ss[i]=ss[i+1]+b[a[i].l];
		suf[i]=suf[i+1]+(tot-(n-i)*b[a[i].l]);
		tot+=b[a[i].l];
	}
	sort(a+1,a+1+n,cmp1);
	tot=0;
	for(int i=1;i<=n;++i) {
		pp[i]=pp[i-1]+b[a[i].r];
		pre[i]=pre[i-1]+((i-1)*b[a[i].r]-tot);
		tot+=b[a[i].r];
	}
	for(int i=1;i<=n;++i) {
		check(a[i].l);
		check(a[i].r);
	}
	printf("%lld\n",ans*2);
	return 0;
}
```

讲个笑话，这题的双倍经验是个绿的 [[ARC147C] Min Diff Sum](https://www.luogu.com.cn/problem/AT_arc147_c)

---

## 作者：Dantal10n (赞：1)

大家好啊，我是扫描线枚举分割点说的道理。今天给大家来点想看的东西。

[题目链接](https://www.luogu.com.cn/problem/P6163)。给你数轴上 $n$ 个区间，每个区间选一个点，问你这些点两两距离差的和的最小值。

这个题和 [ARC147](https://atcoder.jp/contests/arc147/tasks/arc147_c)[ ](https://vdse.bdstatic.com//192d9a98d782d9c74c96f09db9378d93.mp4)[C](https://atcoder.jp/contests/arc147/tasks/arc147_c) 基本是完全一样的，就是答案差个 2 倍，数据范围有少许差异而已；[AtCoder](https://atcoder.jp/contests/arc147/editorial/4764)[ ](https://vdse.bdstatic.com//192d9a98d782d9c74c96f09db9378d93.mp4)[官方题解](https://atcoder.jp/contests/arc147/editorial/4764)非常的神奇，但是它也是非常的难想到，所以我们带来一个“每一步都比较好想基本，而思维路径稍微长一点，代码稍微难写一点”的做法。

首先我们考虑一下最优解大概是个什么形式。

题目要求点的两两距离差最小，那我们考虑对于某个 $n$ 个点的状态，把最右边的点尽可能往左移，把最左边的点尽可能往右移一定最优；除了最值点外，我们也可以抽象的把区间分成左中右三部分，右边尽可能往左，左边尽可能往右。

于是我们可以枚举一下每个分割点，然后对于每个分割点可以确定每个区间具体选哪个点，然后我们就有了一个优秀的 $O(Vn^2)$ 解法。

我们发现对于 $n$ 个点算距离和其实不需要平方级算法，只要增量式，记录当前有的点数和位置和，考虑每个点加进来时对已有点的贡献就可以了。这个后面有用。然后我们就有了一个优秀的 $O(Vn)$ 解法。

观察到如果包含分割点的区间情况一样，分割点对应的答案也是一样的，于是只需要考虑分割点作为区间左右端点的情况即可，其它的情况要不然不够优要不然答案与已计算的一样。然后我们就有了一个优秀的 $O(n^2)$ 解法。

我们回头想一下对于一个已知的分割点怎么计算答案的来着：右端点在分割点左边的区间，取右端点；包含了分割点的区间，取分割点本身；左端点在分割点右边的区间，取左端点。

也就是说，如果我们从左往右的自然顺序考虑所有分割点，取右端点的区间数量会不断增加；取左端点的区间数量会不断减少；而包含了分割点的区间可以动态维护。

这启发我们把区间和分割点排个序，扫一遍就得了。

那贡献怎么维护呢？类比之前增量式考虑点的贡献的算法，可以解决左中右三部分内部自己的贡献；而几个部分之间的贡献也可以类比三个点之间的贡献计算。

然后就做完了。时间复杂度 $O(n \log_2 n)$，瓶颈在于纯纯的排序。不过就像开头说的，代码难度还是有一些的，做好心理准备。

双倍经验的时候别忘了改改 `*2`。

[Code](https://www.luogu.com.cn/paste/6uckaijz)[ ](https://vdse.bdstatic.com//192d9a98d782d9c74c96f09db9378d93.mp4)[link](https://www.luogu.com.cn/paste/6uckaijz)


[剪贴板](https://www.luogu.com.cn/paste/gms3tgmj)[ ](https://vdse.bdstatic.com//192d9a98d782d9c74c96f09db9378d93.mp4)[备份](https://www.luogu.com.cn/paste/gms3tgmj)

---

## 作者：DerrickLo (赞：0)

如果将所有 $a_i$ 从小到大排序，设中间的数为 $x$，那么在左边的 $a_i$ 的贡献是负的，右边的 $a_i$ 的贡献是正的。

考虑枚举 $x$，对于 $r_i<x$ 的区间显然选 $r_i$ 最优，对于 $l_i>x$ 的区间显然选 $l_i$ 最优，而其他区间显然选 $x$ 是最优的。

进一步地，我们会发现实际上 $x$ 只会在这 $2n$ 个端点中取到，如果在中间必然可以通过左移或右移使得答案不劣。那么对所有端点排序后对 $x$ 扫描线，我们发现可以动态维护第一种情况和第二种情况的个数，而这两种情况的贡献我们可以通过前缀和预处理，而第三种情况我们发现就是一个等差数列求和，直接计算即可。

时间复杂度 $\mathcal O(n\log n)$，瓶颈在排序。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,l[100005],r[100005],ans=1e18,m,s1[100005],s2[100005];
struct nd{
	int x,op;
	friend bool operator<(const nd&a,const nd&b){
		return a.x<b.x;
	}
}a[200005];
signed main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++)cin>>l[i]>>r[i],a[++m]={l[i],0},a[++m]={r[i],1};
	sort(a+1,a+m+1),a[m+1].x=1e18;
	int x=0;
	for(int i=m;i>=1;i--)if(a[i].op==0)x++,s1[x]=s1[x-1]+a[i].x*(n-2*x+1);x=0;
	for(int i=1;i<=m;i++)if(a[i].op==1)x++,s2[x]=s2[x-1]+a[i].x*(2*x-n-1);x=0;
	int cnt1=n,cnt2=0;
	for(int i=1;i<=m;i++){
		if(a[i].op==0)cnt1--;
		if(a[i].x!=a[i+1].x&&cnt1<=n/2&&cnt2<=n/2){
			int now=s1[cnt1]+s2[cnt2],l=2*(cnt2+1)-n-1,r=n-2*(cnt1+1)+1;
			ans=min(ans,now+(l+r)*((r-l+1)/2+1)/2*a[i].x);
		}
		if(a[i].op==1)cnt2++;
	}
	cout<<2*ans;
	return 0;
}
```

---

## 作者：jiayixuan1205 (赞：0)

## 题解：P6163 [Cnoi2020] 领域极限
### 算法
贪心
### 分析
考虑绝对值这个东西是不好处理的，因此我们把他它拆开。

在什么情况下是可以没有绝对值的呢？我们思考这个式子实质上在两两之间都会发生，因此直接从小到大排序后直接选取即可。

接下来我们需要对这个求和式子进行转化使其有更明显的特征，我们可以把它转化为：
$$ \sum\limits_{i=1}^{\left\lfloor\frac{n}{2}\right\rfloor}(n-i\times2+1)(a_{n-i+1}-a_i)$$
那么我们只需要前者小后者大就可以获取到最小值了。只需要把存左端点和右端点的数分别贪心选取即可。如果当前的两个点前者的左端点比后者的右端点小呢？这说明两个区间存在交点，于是最优的方法就是他俩重合，不产生贡献，否则前者选左端点后者选右端点直接计算即可。

有没有可能排序完之后选到了同一个区间呢？考虑右端点小的左端点只会更小，左端点大的左端点只会更大，因此可以保证选取的一定不相同。

注意这里一组数会被选取两次，因此答案需要乘上二。
### 代码展示
```cpp
#include<bits/stdc++.h>
#define int long long

using namespace std;

const int N = 3e5+10;
int n;
int l[N],r[N];

inline bool cmp(int x,int y)
{
    return x>y;
}

signed main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    cin>>n;
    for(int i=1;i<=n;i++) cin>>l[i]>>r[i];
    sort(r+1,r+n+1);
    sort(l+1,l+n+1,cmp);
    int ans=0;
    for(int i=1;i<=n/2;i++)
    {
        if(l[i]<r[i]) continue;
        else ans+=(n-i*2+1)*(l[i]-r[i]);
    }
    cout<<ans*2<<'\n';
    return 0;
}
```

---

## 作者：Purslane (赞：0)

# Solution

考虑最终点的坐标是 $x_1 \le x_2 \le \cdots \le x_n$。

最自然的思路就是，两两距离之和为 $\sum_{i=1}^{\lfloor \frac{n}{2} \rfloor} (n-i)(x_{n-i+1}-x_i)$，我们要将其最小化。

显然，$x_{n}-x_1$ 的最小值是**所有 $l$ 的最大值减去所有 $r$ 的最小值**，其他同理。

因此我们每次取出 $l$ 的最大值 $l_{\max}$ 和 $r$ 的最小值 $r_{\min}$。

如果 $l_{\max} \le r_{\min}$，说明**所有未被处理的线段交于至少一个共同点**，因此可以让他们坐标都相等。

否则把 $(n-i)(l_{\max}-r_{\min})$ 加入答案。

还有一个视角是进行调整法，找必要条件，但是思维过程更加复杂，没这种方法好。

代码太简单了，不放了。

---

## 作者：Skicyer (赞：0)

# [题目传送门](https://www.luogu.com.cn/problem/P6163)
# 题意
给你 $n$ 个小球，每个小球有一个要求的区间。问每两个小球之间的距离的和。
# 题解
题意是转换过的，这比较好理解。考虑一个右边界的限制小于所有其他左边界的球肯定放在右边界。

进而考虑一个在中间的小球。我们让和他同位置且可以向右移的小球合为一个整体。其他同位置的视为在左边。如果这个小球(组)的左边的数比右边的数小。那么，向右移一定更优。否则，小球原地放下。

再考虑其实对于非边界的点是无效的，因为这些点上不会有小球的变化。那么就可以离散化加扫描线了。

所以假设所有的小球均放在左边界，将右边界放入优先队列，扫一遍就好。

对于每一种初始状态，要使其更优，一定可以做如上的操作。所以任何情况，都可以从我们假设的情况移动过来。所以这么做应该是对的。
# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int maxn=1e6+5;
struct node{
	int l,r;
	node(){}
	node(int _l,int _r){
		l=_l,r=_r;
	}
}c[maxn];
bool cmp(node x,node y){
	return x.l<y.l; 
}
priority_queue<int,vector<int>,greater<int> > q;
int n,z[maxn],tot,val[maxn];
signed main(){
	scanf("%lld",&n);
	for(int i=1,x,y;i<=n;i++){
		scanf("%lld%lld",&x,&y);
		z[++tot]=x,z[++tot]=y;
		c[i]=node(x,y);
	}
	sort(z+1,z+tot+1);
	tot=unique(z+1,z+tot+1)-z-1;
	for(int i=1;i<=n;i++){
		c[i].l=lower_bound(z+1,z+tot+1,c[i].l)-z;
		c[i].r=lower_bound(z+1,z+tot+1,c[i].r)-z;
	}
	sort(c+1,c+n+1,cmp);
	int now=1,cnt=0,L=0,R=n;
	for(int i=1;i<=tot;i++){
		while(c[now].l<i&&now<=n) now++;
		while(c[now].l==i&&now<=n){
			R--;
			cnt++;
			q.push(c[now].r);
			now++;
		}
		while(q.size()&&i==q.top()){
			val[i]++,q.pop();
			L++;
			cnt--;
		}
		if(L>R){
			L+=cnt;
			val[i]+=cnt;
			cnt=0;
			while(q.size()) q.pop();
		}
	} 
	int sum=0,k=0;
	int ans=0;
	for(int i=1;i<=tot;i++){
		for(int j=1;j<=val[i];j++){
			ans+=(k*z[i]-sum);
			sum+=z[i];
			k++;
		}
	}
	printf("%lld",ans*2);
	return 0;
} 
```

---

## 作者：Cxny (赞：0)

## Preface
ARC147 原题，数据范围甚至更大？

## Solution

先考虑值域在 $10^7$ 以内时的做法。

显然，为了使答案尽可能小，我们希望各个变量的值都接近于某个值。

所以我们枚举这个值，从左往右扫。

考虑从值为 $i-1$ 递推到值为 $i$。

若有 $suml$ 个线段**完全**在 $i$ 左侧，$sumr$ 个完全在右侧，$mid$ 个可以取到 $i$，则有：

$$
suml+sumr+mid=n\\
\Delta ans=suml\times mid+sumr\times mid
$$

式 $1$ 显然成立。下面着重解释一下式 $2$。

由于此时有 $suml$ 个取值在 $i$ 左侧，当值 $+1$ 时**每一对**左侧值和值 $i$ 都会产生 $1$ 的贡献。右侧也是同理。

开桶统计左 / 右端点在某个值的线段数来维护 $suml$ 与 $sumr$，预处理出所有线段都取左端点时的结果，每次 $O(1)$ 转移即可。

---

当值域增加到 $10^9$，我们可以通过离散化缩小值域。但此时递推会忽略在线段内部的值，怎么办？

注意到，**必存在一组最优解，使得取到的“逼近值”为一条线段左右端点之一**。

~~是这样的，感受一下。~~

感性理解，在线段中间的取值变化**并没有改变** $suml$ 与 $sumr$ 的值，而取值在两端点之一时一定**不劣**于在中间时的情况。

总时间复杂度 $O(n\log n)$，瓶颈在排序离散化。

```cpp
//Author: Cxny
#include<bits/stdc++.h>
using namespace std;
#define pb push_back
#define fi first
#define se second
const int maxn = 3e5 + 10, maxm = 6e5 + 10;
const ll inf = 9e18;
int n, lcnt[maxm], rcnt[maxm], a[maxn], num[maxn << 1], cnt = 0;
pair<int, int> seg[maxn];
ll res, ans = inf, suml, sumr, mid;
const int maxn = 3e5 + 10, maxm = 6e5 + 10;
const ll inf = 9e18;
int n, lcnt[maxm], rcnt[maxm], a[maxn], num[maxn << 1], cnt = 0;
pair<int, int> seg[maxn];
ll res, ans = inf, suml, sumr, mid;
int main(){
	scanf("%d", &n);
	for(int i = 1; i <= n; i++){
		scanf("%d%d", &seg[i].fi, &seg[i].se);
		num[++cnt] = seg[i].fi, num[++cnt] = seg[i].se;
	}
	sort(num + 1, num + cnt + 1);
	cnt = unique(num + 1, num + cnt + 1) - num - 1;
	for(int i = 1; i <= n; i++){
		seg[i].fi = lower_bound(num + 1, num + cnt + 1, seg[i].fi) - num;
		seg[i].se = lower_bound(num + 1, num + cnt + 1, seg[i].se) - num;
		lcnt[seg[i].fi]++, rcnt[seg[i].se]++;
		a[i] = seg[i].fi;
	}
	sort(a + 1, a + n + 1);
	ll tot = 0;
	for(int i = 1; i <= n; i++){
		res += 1ll * (i - 1) * num[a[i]] - tot;
		tot += num[a[i]];
	}
	sumr = n;
	for(int i = 0; i <= cnt; i++){
		// printf("%d: %lld %lld %lld\n", num[i], res, suml, sumr);
		ans = min(ans, res);
		sumr -= lcnt[i], suml += rcnt[i];
		mid = n - suml - sumr;
		res += (suml * mid - sumr * mid) * (num[i + 1] - num[i]);
	}
	printf("%lld\n", ans * 2);
	return 0;
}
```

---


# [IOI 2020] 嘉年华奖券

## 题目背景

**本题为交互题。**

请在程序开头声明 `void allocate_tickets(std::vector<std::vector<int> > s);` 和使用 vector 头文件，并且请在调用函数前加上 `extern "C"`。

## 题目描述

Ringo 正在参加在新加坡举办的一个嘉年华活动。他的口袋里装有一些奖券，这些奖券可以在嘉年华的游戏展位使用。假设共有 $n$ 种颜色的奖券，每张奖券涂上了其中的一种颜色并且印上了一个非负整数。不同奖券上的数字可能相同。依据嘉年华活动的规则要求，$n$ 保证是偶数。

Ringo 每种颜色的奖券有 $m$ 张，也就是说他共有 $n \cdot m$ 张奖券。其中，第 $i$ 种颜色对应的第 $j$ 张奖券上印的数字为 $x[i][j]$（$0 \le i \le n-1$ 且 $0 \le j \le m-1$）。

一次奖券游戏要进行 $k$ 轮，轮次的序号从 $0$ 到 $k-1$。每一轮按照下面的方式进行：

- 首先，Ringo 从每种颜色的奖券中各选出一张奖券，形成一个 $n$ 张奖券的 **集合**。
- 随后，游戏负责人记录下这个集合中奖券上的数字 $a[0],a[1],\ldots,a[n-1]$。不需要考虑这 $n$ 个整数的顺序。
- 接下来，游戏负责人从一个幸运抽奖箱中抽取一张特殊卡片，上面印有整数 $b$。
- 对于上述集合中每一个奖券上的数字 $a[i](0\le i \le n-1)$，游戏负责人会计算 $a[i]$ 和 $b$ 的差的绝对值。让 $S$ 代表这 $n$ 个差的绝对值之和。
- 所得到的数字 $S$ 就是 Ringo 本轮能够获得的奖励数额。
- 一轮游戏结束后，本轮集合中的奖券全部被丢弃，不会在未来的轮次所使用。

当 $k$ 轮游戏结束后，Ringo 会丢弃口袋中的所有奖券。

通过仔细观察，Ringo 发现这个奖券游戏被操控了！实际上，幸运抽奖箱里面内置了一台打印机。在每一轮，游戏负责人首先找到一个能够最小化当前轮次游戏奖励的整数 $b$，然后将该数字打印在他所抽取的特殊卡片上。

知道了这些信息之后，Ringo 想要设计每轮游戏中的奖券分配方案，使得 $k$ 轮游戏中获得的总体奖励数额之和最大。

#### 实现细节

你需要实现下面这个函数：

```cpp
long long find_maximum(int k,std::vector<std::vector<int>> x)
```

- $k$：游戏的轮数。
- $x$：一个 $n \times m$ 的数组，记录了奖券上的数字。每种颜色的奖券按照上面的数字非递减顺序排序。
- 这个函数只会被调用一次。
- 这个函数应该只调用一次函数 `allocate_tickets`（参见下面的内容），它描述了 $k$ 轮游戏中的奖券分配方案，每一轮对应一个奖券集合。奖券的分配方案应该使得所获奖励数额之和达到最大。
- 这个函数需要返回能够获得的最大的奖励数额之和。

函数 `allocate_tickets` 按照如下的方式进行定义：

```cpp
void allocate_tickets(std::vector<std::vector<int>> s)
```
  
- $s$：一个 $n \times m$ 的数组。如果第 $i$ 种颜色的第 $j$ 张奖券如果被分配到了第 $r$ 轮游戏，那么 $s[i][j]$ 的值应该为 $r$；如果未被使用，应该为 $-1$。
- 对于 $0 \le i \le n-1$，在 $s[i][0],s[i][1],\ldots,s[i][m-1]$ 中，每个值 $0,1,\ldots,k-1$ 必须只出现一次，而其他元素应该为 $-1$。
- 如果存在多种奖券分配方案能够达到最优的奖励数值，可以给出其中任何一种最优方案。

## 说明/提示

#### 样例说明

#### 例 1

考虑下面的函数调用：

```cpp
find_maximum(2, [[0, 2, 5],[1, 1, 3]])
  ```
这意味着：

- 游戏共进行 $k=2$ 轮；
- 第 $0$ 种颜色奖券上的整数数字分别是 $0,2$ 和 $5$；
- 第 $1$ 种颜色奖券上的整数数字分别是 $1,1$ 和 $3$；

一种能够获得最优奖励数值的分配方案是：

- 在第 $0$ 轮，Ringo 选择第 $0$ 种颜色的第 $0$ 张奖券（印有整数 $0$）和第 $1$ 种颜色的第 $2$ 张奖券（印有整数 $3$）。本轮获得的最小奖励数额是 $3$。例如，游戏负责人可以选择 $b=1$：$|1-0| + |1-3| = 1+2 = 3$。
- 在第 $1$ 轮，Ringo 选择第 $0$ 种颜色的第 $2$ 张奖券（印有整数 $5$）和第 $1$ 种颜色的第 $1$ 张奖券（印有整数 $1$）。本轮能够获得的最小奖励是 $4$。例如，游戏负责人可以选择 $b=3$：$|3-1|+|3-5|=2+2=4$。
- 因此，本次游戏两轮的奖励之和为 $3+4=7$。

为了给出这个分配方案，函数 `find_maximum` 应该按照如下方式调用 `allocate_tickets`：

```cpp
allocate_tickets([[0, -1, 1], [-1, 1, 0]])
```
  
  最终，函数 `find_maximum` 应该返回数字 $7$。
  
#### 例 2

考虑下面的函数调用：

```cpp
find_maximum(1, [[5, 9], [1, 4], [3, 6], [2, 7]])
```

这意味着：

- 游戏只进行一轮；
- 第 $0$ 种颜色奖券上的数字分别是 $5$ 和 $9$；
- 第 $1$ 种颜色奖券上的数字分别是 $1$ 和 $4$；
- 第 $2$ 种颜色奖券上的数字分别是 $3$ 和 $6$；
- 第 $3$ 种颜色奖券上的数字分别是 $2$ 和 $7$；

一种能够获得最优奖励的分配方案是：

- 在第 $0$ 轮，Ringo 选择第 $0$ 种颜色的第 $1$ 张奖券（印有整数 $9$），第 $1$ 种颜色的第 $0$ 张奖券（印有整数 $1$），第 $2$ 种颜色的第 $0$ 张奖券（印有整数 $3$），第 $3$ 种颜色的第 $1$ 张奖券（印有整数 $7$）。本轮能够获得的最小奖励是 $12$。例如，游戏负责人可以选择 $b=3$：$|3-9| + |3-1| + |3-3| + |3-7| = 6 + 2 + 0 + 4 = 12$。

为了给出这个分配方案，函数 `find_maximum` 应该按照如下方式调用 `allocate_tickets`：

```cpp
allocate_tickets([[-1, 0], [0, -1], [0, -1], [-1, 0]])
```

最终，函数 `find_maximum` 应该返回数字 $12$。

#### 约束条件

- $2\le n\le 1500$ 且 $n$ 为偶数
- $1\le k\le m\le 1500$
- $0 \le x[i][j] \le 10^9$（对于所有的 $0 \le i \le n-1$ 且 $0 \le j \le m-1$）
- $x[i][j-1] \le x[i][j]$（对于所有的 $0 \le i \le n-1$ 且 $0 \le j \le m-1$）

#### 子任务

1. （11 分）$m=1$
2. （16 分）$k=1$
3. （14 分）$0 \le x[i][j] \le 1$（对于所有的 $0 \le i \le n-1$ 且 $0 \le j \le m-1$）
4. （14 分）$k=m$
5. （12 分）$n,m \le 80$
6. （23 分）$n,m \le 300$
7. （10 分）没有额外约束条件

#### 评测程序示例

评测程序示例按照下面的格式读入数据：

第 $1$ 行：$n\ m\ k$        
第 $2+i$ 行（$0 \le i \le n-1$）：$x[i][0]\ x[i][1]\ \ldots \ x[i][m-1]$

评测程序示例按照下面的格式打印你的答案：

第 $1$ 行：`find_maximum` 的返回值       
第 $2+i$ 行（$0 \le i \le n-1$）：$s[i][0]\ s[i][1]\ \ldots\ s[i][m-1]$

# 题解

## 作者：s_r_f (赞：13)

安利：[IOI2020题解-洛谷博客](https://www.luogu.com.cn/blog/s-r-f/ioi2020-ti-xie) [IOI2020题解-cnblogs](https://www.cnblogs.com/s-r-f/p/13697373.html)

---

[题目链接-LOJ](https://loj.ac/problem/3366) [题目链接-洛谷](https://www.luogu.com.cn/problem/P6831)

首先我们考虑如何求出最大值。

不难发现这个抽奖的过程中，工作人员必然会取中位数来最小化当前轮次的奖励。

因为n是偶数，不难发现我们能获得的奖励为：

设当前轮次使用的奖券上的数值为 $a_{1,2...n}$ 并且已经从小到大排序，那么

$\large ans=\sum\limits_{\frac{n}{2}+1\leq i\leq n} a_i -\sum\limits_{1\leq i\leq \frac{n}{2}} a_i$

也就是说，有 $\large \frac{n}{2}$ 个数对答案的贡献为 $a_i$ ,另 $\large \frac{n}{2}$ 个数对答案的贡献为 $-a_i$ , **并且所有负贡献的数字都不大于正贡献的数字。**

可以发现，经过 $k$ 次过程获得的最大值，相当于我们在 $n$ 种颜色的奖券上的数字中，每种颜色选取 $k$ 个数字，并在其中选 $\large \frac{nk}{2}$ 个数字，使其对答案的贡献为正数 ，令另外一半的数字的贡献为负数 ，然后求和即为答案。

不难发现如果我们获得了这个取数问题的最优解，那么**必然存在一种方案把这 $nk$ 个数分成 $k$ 组使得每组中有 $n$ 个颜色两两不同的数，一半取负贡献，一半取正贡献，并且负贡献的数都不大于正贡献的数字。即有对应原问题的合法方案。**

证明：如果不存在合法方案，那么对于任何一种方案，必然存在同一组数字中有一个取负贡献的数大于一个取正贡献的数。这时候交换一下它们的符号就可以获得一个更优的解，所以如果取得了最优解的取数方案，必然有一个对应了原问题的合法方案。

取数问题的贪心：先默认都取负数，然后再贪心的做 $\large \frac{nk}{2}$ 次把负数换成正数的操作即可。

然后我们考虑如何构造方案。

递归构造，考虑从当前的 $nk$ 个数字中取出 $n$ 个颜色两两不同的成为一组，保证它合法后再对剩下的 $n(k-1)$ 个数字继续构造。

从每种颜色中取出一个最大的正数和一个最小的负数并将正数和负数分别排序，枚举正数和负数之间的边界，$two-pointers$ 的同时维护可用的正/负数数目即可。

因为正数和负数分别取到了最大和最小，所以在整个取数问题有对应方案的时候这个子问题必然能找到一组解，可以继续递归。

由于递归的时候**保证了选数方案一直是当前的最优解**，所以一直都能保证当前的选数方案有一组对应原问题的解。

$\Theta(nm\log n)$

code(LOJ上通过):

```cpp
#include "tickets.h"
#include <bits/stdc++.h>
#define LL long long
using namespace std;

const int N = 1505,M = 1505;
int n,m,k,ans[N][M],val[N][M];
int z[N][M];

LL AANS;
namespace CALCZ{
	int vv[N],nl[N],nr[N];
	struct Node{
		int id,v;
		bool operator < (const Node w) const{ return v < w.v; }
	}tmp;
	priority_queue<Node>H;
	inline void calcz(){
		int i,j,ll = n*k/2;
		for (i = 0; i < n; ++i) for (j = 0; j < m; ++j) z[i][j] = 0;
		for (i = 0; i < n; ++i) for (j = 0; j < k; ++j) z[i][j] = -1;
		for (i = 0; i < n; ++i){
			nl[i] = k-1,nr[i] = m-1;
			vv[i] = val[i][nl[i]] + val[i][nr[i]];
			tmp.id = i,tmp.v = vv[i],H.push(tmp);
		}
		while (ll--){
			tmp = H.top(); H.pop();
			i = tmp.id;
			z[i][nl[i]] = 0,z[i][nr[i]] = 1;
			--nl[i],--nr[i];
			if (nl[i] >= 0){
				vv[i] = val[i][nl[i]] + val[i][nr[i]];
				tmp.id = i,tmp.v = vv[i],H.push(tmp);
			}
		}
		for (i = 0; i < n; ++i) for (j = 0; j < m; ++j) AANS += z[i][j] * val[i][j];
	}
}

inline void solve_k_1(){
	int i,j;
	for (i = 0; i < n; ++i) for (j = 0; j < m; ++j) if (z[i][j]) ans[i][j] = 0;
	vector<vector<int> >a; vector<int>ret; ret.resize(m),a.clear();
	for (i = 0; i < n; ++i){
		for (j = 0; j < m; ++j) ret[j] = ans[i][j];
		a.push_back(ret);
	}
	allocate_tickets(a);
}
namespace Try{
	int nl[N],nr[N];
	struct Node{
		int id,v;
		inline bool operator < (const Node w) const{ return v < w.v; }
	}tz[N],tf[N]; int lz,lf;
	int okz[N],okf[N];
	int cntz,cntf,cntzf;
	inline void addf(int x){
		x = tf[x].id;
		if (okf[x]) return;
		++cntf,okf[x] = 1; if (okz[x]) ++cntzf;
	}
	inline void delz(int x){
		x = tz[x].id;
		if (!okz[x]) return;
		--cntz,okz[x] = 0; if (!okf[x]) --cntzf;
	}
	inline void work(){
		int i;
		static int Time = -1; ++Time;
		cntf = cntz = 0;
		for (lz = lf = i = 0; i < n; ++i){
			okz[i] = 0,okf[i] = 0;
			if (nl[i] >= 0 && z[i][nl[i]] == -1){
				++lf; tf[lf].id = i,tf[lf].v = val[i][nl[i]];
			}
			if (nr[i] >= 0 && z[i][nr[i]] == 1){
				++lz; tz[lz].id = i,tz[lz].v = val[i][nr[i]]; okz[i] = 1,++cntz;
			}
		}
		sort(tf+1,tf+lf+1); sort(tz+1,tz+lz+1);
		int ll = 1;
		for (i = 1; i <= lf; ++i){
			addf(i);
			while (ll <= lz && tz[ll].v < tf[i].v) delz(ll),++ll;
			if (cntz + cntf - cntzf >= n && cntz >= n/2 && cntf >= n/2) break;
		}
		int nz = n/2,nf = n/2;
		for (i = 0; i < n && (nz || nf); ++i){
			if (!okz[i] && !okf[i]) continue;
			if (!okz[i]){
				if (!nf) continue;
				--nf; --cntf; ans[i][nl[i]] = Time,--nl[i];
				continue;
			}
			if (!okf[i]){
				if (!nz) continue;
				--nz; --cntz; ans[i][nr[i]] = Time,--nr[i];
				continue;
			}
			
			if (nz && cntz <= nz){
				--nz; ans[i][nr[i]] = Time,--nr[i];
				--cntz,--cntf;
				continue;
			}
			--nf; ans[i][nl[i]] = Time,--nl[i];
			--cntz,--cntf;
			continue;
		}
	}
	inline void MAIN(){ for (int i = 0; i < n; ++i){ nr[i] = m-1,nl[i] = 0; while (z[i][nl[i]+1] == -1) ++nl[i]; } while (k--) work(); }
}


LL find_maximum(int k,vector<vector<int> >x) {
	::k=k;
	int i,j;
	n = x.size(),m = x[0].size();
	for (i = 0; i < n; ++i) for (j = 0; j < m; ++j) ans[i][j] = -1,val[i][j] = x[i][j];
	CALCZ::calcz();
	if (k == 1){ solve_k_1(); return AANS; }
	Try::MAIN();
	vector<vector<int> >a; vector<int>ret; ret.resize(m),a.clear();
	for (i = 0; i < n; ++i){
		for (j = 0; j < m; ++j) ret[j] = ans[i][j];
		a.push_back(ret);
	}
	allocate_tickets(a);
	return AANS;
}
```

---

## 作者：tzc_wk (赞：3)

小清新 IOI 题。

首先考虑怎么求出答案。等价于我选择 $\dfrac{nk}{2}$ 个数令它们系数为 $1$，再选 $\dfrac{nk}{2}$ 个数令它们系数为 $-1$，最大化每个数的值乘以系数之和，并且要求每个奖券选择的数的个数恰好是 $k$ 个。

考虑先令每个奖券的前 $k$ 个数系数为 $-1$，然后再将 $\dfrac{nk}{2}$ 个数改成正数。因为每次我显然是选择一个奖券，将最靠右的负数去掉，再选择最靠左的没有选择的数作为正数，而你发现这个贡献是凸的，所以优先队列维护即可。时间复杂度 $O(nm\log n)$。

最后考虑怎么构造方案。直接每次选择剩余负数最多的 $\dfrac{n}{2}$ 个奖券填上 $-1$，另外 $\dfrac{n}{2}$ 个奖券填上 $+1$ 即可。你可能会担心如果这 $n$ 个奖券的 $\pm 1$ 的系数不符合我们构造出来的系数怎么办，不过仔细想想不会出现这样的情况。因为我们选择的最大的负数肯定不会超过最小的正数，否则我们一定可以交换这两个数的系数使得答案变得更优，于是 $\pm 1$ 的系数一定是对的，直接 xjb 取即可。

```cpp
const int MAXN=1500;
int n,m,pt[MAXN+5],coef[MAXN+5][MAXN+5],L[MAXN+5],R[MAXN+5];
ll find_maximum(int k,vector<vector<int> >x){
	n=x.size();m=x[0].size();int cnt=n*k/2;
	for(int i=0;i<n;i++)for(int j=0;j<k;j++)coef[i][j]=-1;
	for(int i=0;i<n;i++)pt[i]=k-1;
	priority_queue<pii>q;
	for(int i=0;i<n;i++)q.push(mp(x[i][m-1]+x[i][k-1],i));
	while(cnt--){
		pii p=q.top();q.pop();int id=p.se;
		coef[id][pt[id]]=0;coef[id][pt[id]+m-k]=1;--pt[id];
		if(pt[id]>=0)q.push(mp(x[id][pt[id]+m-k]+x[id][pt[id]],id));
	}
	ll res=0;
	for(int i=0;i<n;i++)for(int j=0;j<m;j++)res+=coef[i][j]*x[i][j];
	vector<vector<int> >ans;ans.resize(n);
	for(int i=0;i<n;i++)ans[i].resize(m);
	for(int i=0;i<n;i++)L[i]=pt[i],R[i]=pt[i]+m-k+1;
	for(int i=0;i<n;i++)for(int j=0;j<m;j++)ans[i][j]=-1;
	for(int i=0;i<k;i++){
		static int ord[MAXN+5];
		for(int j=0;j<n;j++)ord[j]=j;
		sort(ord,ord+n,[&](int x,int y){return L[x]>L[y];});
		for(int j=0;j<n/2;j++)ans[ord[j]][L[ord[j]]]=i,--L[ord[j]];
		for(int j=n/2;j<n;j++)ans[ord[j]][R[ord[j]]]=i,++R[ord[j]];
	}
	allocate_tickets(ans);
	return res;
}
```



---


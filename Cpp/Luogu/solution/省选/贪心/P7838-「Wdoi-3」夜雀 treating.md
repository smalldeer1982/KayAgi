# 「Wdoi-3」夜雀 treating

## 题目背景

经历了一整天的磨难，米斯蒂娅终于迎来了这一天最后一位客人——蓬莱山辉夜。

作为永远亭的大小姐、月之都的公主，辉夜对于经营着平凡小吃摊的米斯蒂娅，向来是一个巨大的挑战。辉夜的口味极其挑剔，以至于米斯蒂娅常常难以满足她的需求。更棘手的是，如果辉夜认为米斯蒂娅招待不周，那么夜雀食堂的后果可能并不会比被幽幽子摧毁好多少。

于是可怜的小夜雀只能向你求助了。

## 题目描述

为了伺候这位主客，米斯蒂娅事先准备好了 $2n+1$ 种食材，并排成了一排，第 $i$ 种食材在左起第 $i$ 位，作为**预选食材**。

接着，辉夜对所有食材进行了打分，每个食材被给予了一个在 $[1,2n+1]$ 当中的**互不相等**的分数。其中第 $i$ 种食材的评分为 $A_i$。

由于月之民的奇怪癖好，辉夜喜欢一组连续的数字。因此，她对最终选出来的食材（不妨称为**最终食材**）的满意度，定义为将这些食材**按照其评分从小到大排序后**，其中**最长**的**评分连续**的食材的**长度**。评分连续，也就是这些食材的评分形成了公差为 $1$ 的等差数列。例如，$\{1,4,5,6,8,10,11\}$ 当中，能挑选出来的最长的评分连续的序列是 $\{4,5,6\}$，因此对于这套方案，辉夜的满意度是 $3$。

然而喜欢看乐子的辉夜，决定使用一种诡异的选择方式来折磨米斯蒂娅——

1. 设当前一共有 $2k+1$ 种食材。这些食材被依次排开，米斯蒂娅将这些食材从左到右依次编号为 $1,2,3\cdots (2k+1)$。
2. 米斯蒂娅选择当前处于**中间位置**的材料（也就是编号为 $k+1$ 的材料），并加入最终食材。注意，加入最终食材的食材会被**移出**候选食材。
3. 米斯蒂娅**任选**候选食材中的一种食材，**并移除**。保持剩余食材的相对位置不变。特别的，如果候选食材已空，那么米斯蒂娅不做任何操作。

米斯蒂娅将会不断进行 $1\sim3$ 操作，直到最终食材当中已经有了恰好 $n+1$ 种食材。她想知道，如果按照最优的操作方案，辉夜能获得的最大的满意度是多少。

## 说明/提示

#### 样例 1 解释

$$
\def\arraystretch{1.7}
\begin{array}{|c|c|c|c|}\hline
\textbf{候选食材} & \textbf{选择} & \textbf{删除} & \textbf{最终食材} \cr\hline
4,7,3,6,1,2,5 & 6 & 1 & 6\cr \hline
4,7,3,2,5 & 3 & 7 & 3,6\cr \hline
4,2,5 & 2 & 5 & 2,3,6\cr \hline
4 & 4 & - & 2,3,4,6\cr \hline
\end{array}$$

此时最终食材中最长连续食材编号为 $\{2,3,4\}$ ，长度为 $3$ 。可以证明，没有更优方案。

---

#### 数据范围及约定

$$
\def\arraystretch{1.7}
\begin{array}{|c|c|c|c|}\hline
\textbf{Subtask} & \bm{n\le} & \textbf{特殊性质} & \textbf{分值} \cr\hline
1 & 5 & - & 10\cr\hline
2 & 200 & - & 15\cr\hline
3 & 800 & - & 15\cr\hline
4 & 5\times 10^3& - & 20\cr\hline
5 & 2\times 10^5& \text{A} & 5\cr\hline
6 & 2\times 10^5& - & 35\cr\hline
\end{array}
$$

- 特殊性质 A ：保证 $\forall i\in[1,2n+1]$ 有 $A_i=i$ 。样例 3 即满足该性质。
- 对于 $100\%$ 的数据，有 $1 \leq n \leq 2 \times 10^5$，并且 $A$ 是一个 $1 \sim 2n+1$ 的排列。

## 样例 #1

### 输入

```
3
4 7 3 6 1 2 5```

### 输出

```
3```

## 样例 #2

### 输入

```
7
1 15 2 14 3 13 4 12 5 11 6 10 7 9 8```

### 输出

```
8```

## 样例 #3

### 输入

```
1
1 2 3```

### 输出

```
2```

# 题解

## 作者：幽云蓝 (赞：8)

这里是八云蓝的官方题解~

$\textbf{Subtask1}$

读题分，直接大力搜索即可。时间复杂度指数级，具体的蓝没有算。

$\textbf{Subtask2}$

考虑对题意进行转化。我们将所有食材的第 $n+1$ 个食材单独提取出来，然后将区间 $[1,n]$ 的食材从 $n$ 到 $1$ 依次入栈 $A$，将区间 $[n+2,2n+1]$ 的食材从 $n+2$ 到 $2n+1$ 依次入栈 $B$。那么每次取食材操作可以看成取出某一栈栈顶的食材，并将另一栈中的某一食材删除。考虑大力枚举最后挑选出来的评分连续的序列中的最小评分 $l$ 和最大评分 $r$，判断是否存在一种操作方案使得最终可以选出这样一个序列。那么最终我们一定取了评分在区间 $[l,r]$ 内的所有食材，其他的食材可以忽略。考虑将评分在区间 $[l,r]$ 内的左右食材称作关键食材，其余食材称作非关键食材。

现在的任务就是给出若干关键食材，问是否可以将它们全部取到，也可以转化成让它们全部不被删（建立在忽略第 $n+1$ 个食材的情况下哦）。考虑枚举选食材的情况——选非关键删非关键，选关键删非关键，选非关键删关键，选关键删关键。如果选一个非关键的时候只能删除关键食材，那么就说明令一栈中的每个食材都是关键食材，所以可以选另一栈中的关键食材并且删该栈中的非关键食材。于是，可能会导致关键食材被删的情况只有选关键删关键。

考虑使用贪心让选关键食材的时候尽可能可以删非关键。感性理解一下，在删除的过程中，越接近栈底的关键食材越有用，因为不可以通过删关键食材的方式让一个非关键食材接近栈底，并且考虑计算非关键食材 $i$ 的贡献值 $w_i$，代表有多少关键食材满足取某一关键食材时可以删除食材 $i$，那么显然越靠近栈底的食材贡献值就越大，那么删除时就要尽可能保留靠近栈低的关键食材。由此能得出一个贪心策略：① 如果栈顶有两非关键，取一个删另一个；② 如果栈顶有一关键一非关键，取关键删非关键；③ 如果栈顶有两关键，那么取栈 $A$ 栈顶的关键，删栈 $B$ 中最靠近栈顶的非关键，再取栈 $B$ 栈顶的关键，删栈 $A$ 中最靠近栈顶的非关键。如果取某一关键食材的时候不能找出相对应的非关键食材了，那么选出的区间就无解。直接暴力模拟贪心过程是 $O(n^2)$ 的，但是可以通过单调性来 $O(n)$ 模拟。具体来说，取某个关键食材时删除的非关键食材一定在取上方的某个关键食材时删除的非关键食材的下方（感性理解一下吧，严谨证明在题解的最后哦）。

综上，贪心复杂度为 $O(n)$，枚举复杂度为 $O(n^2)$，总复杂度为 $O(n^3)$，可以通过该 subtask。

$\textbf{Subtask3}$

考虑寻找性质。可以发现，如果最后可以取评分在区间 $[l,r]$ 内的所有食材，那么对于该区间的任一子区间，都可以取评分在该子区间内的所有食材。那么容易想到对于每个 $l$，二分数 $r$ 满足可以取评分在区间 $[l,r]$ 内的所有食材，但是不能取区间 $[l,r+1]$ 的食材。二分得到的 $r$ 也可看作一个最大的数 $r$ 满足区间 $[l,r]$ 可以取。时间复杂度为 $O(n^2\log n)$，可以通过该 subtask。

$\textbf{Subtask4}$

考虑寻找更加优秀的性质。记 $m_l$ 代表 $l$ 对应的最大的 $r$ 满足可以取评分在区间 $[l,r]$ 内的所有食材，易证有 $m_l\le m_{l+1}$。使用双指针即可做到 $O(n^2)$ 的复杂度。

$\textbf{Subtask5}$

易得对于任一长度为 $2n+1$ 的初始食材序列有最大满意度小于等于 $n+1$。显然对于该情况能构造出一种取的方法满足最大满意度等于 $n+1$。直接输出 $n+1$ 即可。

$\textbf{Subtask6}$

根据 subtask3，我们可以使用双指针来解决该问题。容易发现指针只会挪动 $n$ 次，每次挪动造成的变化很少，但是在之前的做法中，每次都要重新贪心一遍，复杂度开销巨大。那么现在我们需要一个数据结构使得——可以将某个关键食材变为非关键食材，或者将某个非关键食材变为关键食材，并且要能迅速的根据贪心算出是否可以取所有关键食材。似乎是没有数据结构能直接维护这一贪心，我们继续发掘性质。

我们可以把是否存在解看作一个二分图是否存在完美匹配——记关键食材为黑点，非关键食材为白点，记取某一关键食材，删去另一栈中的某个非关键食材为该关键食材和非关键食材进行匹配。那么我们可以得到两个二分图，二分图 $1$ 代表栈 $A$ 的黑点与栈 $B$ 的白点间的关系，二分图 $2$ 代表栈 $A$ 的白点与栈 $B$ 的黑点间的关系。记点 $i$ 在栈内和栈顶的距离为 $d_i$，蓝先抛出结论：贪心能得到解，相当于对于两张二分图，所有黑点 $x$ 向满足 $d_y\ge d_x$ 的白点 $y$ 连边，都能找出完美匹配。这个也很好证明，在贪心的过程中，容易发现每个黑点都一定与一个 $d$ 比它大的白点进行了匹配。换句话说，如果不存在这样的匹配，那么就意味着贪心得不到解。这等价于对建出的二分图进行二分图匹配，最后看是否有完美匹配。那么直接运用 hall 定理（当然也可以用其他的方式进行推导），我们可以得到贪心是否存在的解 or 二分图是否存在完美匹配的条件：

对于两个栈的每个后缀（即栈底到栈中的某一个元素形成的区间）都有，一个栈的黑色点数量小于等于另一个栈白色点数量，那么解存在，否则解不存在。

上面的问题可以转化成区间加、查询全局 $\min$ 值是否为负数，那么我们就可以使用线段树来维护了。上面的问题还有一个更好的性质，即对于栈 $A$，若其满足其每个后缀的黑色点数量小于等于栈 $B$ 的白色点数量，那么由于一个点不是黑色就是白色，所以栈 $B$ 也满足其每个后缀的黑色点数量小于等于栈 $A$ 的白色点数量。于是最后只需要维护一棵线段树即可。

综上，我们在 $O(n\log n)$ 的时间复杂度内解决了此题。完结撒花~

补：对于上述的贪心，我们有一个严谨的证明（不过使用了最终的结论）。首先，对于最终结论（也就是对于两个栈的每个后缀都有一个栈的黑色点数量小于等于另一个栈白色点数量）满足的情况，容易使用上述的贪心构造一组操作取到所有的黑色点。那么考虑对于两栈的一个长度为 $m$ 的后缀，满足栈 $A$ 的黑点数量 $s1$ 大于栈 $B$ 的白点数量 $s2$。考虑两栈长度为 $n-m$ 的前缀对长度为 $m$ 的后缀的影响。由于黑点必然不会被删除，考虑分类讨论：栈 $A$ 的后缀中的某个白点被删除，此时可能从上方落下一个白点，那么 $s1$ 不变，所以仍有 $s1>s2$，如果落下一个黑色点，那么 $s1$ 加一，仍有 $s1>s2$。如果栈 $B$ 的后缀中的某个白点被删除，此时可能从上方落下一个白点，那么 $s2$ 不变，所以仍有 $s1>s2$，如果落下一个黑色点，那么 $s2$ 减一，仍有 $s1>s2$。综上，如果存在长度为 $m$ 的后缀不满足条件，那么在进行了 $n-m$ 次取食材操作后，两栈 $A$ 和 $B$ 必然仍满足一栈的黑点数大于另一栈的白点数，而这种情况显然是不可能存在合法的方案的。所以最终的结论即合法的取食材方案存在的充分且必要条件。

---

## 作者：今天也要开心a (赞：6)

[更好的阅读体验](https://www.cnblogs.com/vegtable-foraino/p/16250074.html)

**题目：[P7838 「Wdoi-3」夜雀 treating](http://www.luogu.com.cn/problem/P7838 "P7838 「Wdoi-3」夜雀 treating")**
# 题解

### method 1  暴力
信仰 $2^n$，谁试谁爽。

### method 2 观察性质
首先取掉 $a_{n+1}$，然后就不管它了，现在还剩下 $2n$ 个数。

在不取数的情况下，数列中点在第 $n$ 个数和第 $n+1$ 个数之间。每次在删除一个数后，中点会移动到第 $n$ 个数或者第 $n+1$ 个数。并且容易发现如果删除的数在左边的一段，中间的数会往第 $n$ 个数移；如果删除的数在右边的一段，中间的数会往第 $n+1$ 个数移。并且取掉这个数以后，原来被中点分成的两端现在仍然被中点隔开，也就是说，我们始终是在前一半取一个数，后一半取一个数，并且这两个数中至少有一个与中点相邻，所以我们把整个数列看成两个子数列 $A$ 和 $B$，其中 $A$ 为 $a_1$~$a_n$，$B$ 为 $a_{2n+1}$~$a_{n+2}$。我们每次进行的操作就是从一个数列中取出最后一个数，再从另外一个数列中删掉任意的一个数，询问最多取出多长的连续数字。

我们在完成一个取数然后抵消的事情，如果某个数列（假设是数列 $A$）底部的某个数在所枚举区间内，我们肯定要想办法把它拿出来，并且 $B$ 中和这个要选的数抵消的数一定不能在区间内，那我们取哪个数比较好呢？显然，如果选较前的数，较后的数就容易跑到数列的末端，如果两个不在区间内的数都到了序列末端，那就必须取掉至少一个，就相当于浪费了这个原本可以抵消掉的数。所以我们应该每次尽量选靠后的数来抵消，所以每次取 $B$ 最后一个不在区间内的数和 $A$ 的最后一个抵消就好了。当然，如果 $A$ 和 $B$ 尾端的两个数都不是区间内的数，那就只能被迫让它们互相抵消。所以如果枚举到某个在区间内的数，另一个数列中没有能与它抵消的了，这个区间就不满足答案应该有的性质；如果成功抵消完了，这个区间就是满足的。

然后似乎就不能在区间这个条件上动手脚，就只能枚举这段连续数字了，然后模拟上述操作，依次判断，时间复杂度 $O(n^3)$。

### method 3 双指针
显然如果区间 $[l,r]$ 是满足的，那么区间 $[l+1,r]$ 和 $[l,r-1]$ 就都是满足的。对于这种性质，我们可以双指针维护，就可以不用分别枚举 $l$ 和 $r$ 了，可以做到 $O(n^2)$。

### method 4 线段树
发现双指针每次只修改一个数，如果每次都重新模拟一遍很亏，所以考虑能不能数据结构维护。

因为我们每次都是取最靠近 $B$ 尾端的一个非区间内的数来抵消掉 $A$ 的最后一个数，只考虑 $A$ 在区间内数的抵消情况时，如果 $A$ 数列中靠前的数都能有 $B$ 数列中的数与其抵消，并且 $B$ 数列中截至这一位不在区间内的数的数量大于等于 $A$ 数列截至这一位在区间内的数的数量时，$A$ 数列截至这一位都是能被抵消的，所以我们可以记录 $A$ 数列在区间内的数的数量的前缀数组和 $B$ 数列不在区间内的数的数量的前缀数组，保证 $A$ 的前缀数组每一位都大于 $B$ 的前缀数组。考虑 $B$ 在区间内的数抵消情况同理，但是因为 $A$ 和 $B$ 中的数的数量是相等的，所以如果  $A$ 中在区间内的数的数量大于 $B$ 中在不区间内的数的数量，那么 $B$ 中在区间内的数的数量一定大于 $A$ 中在不区间内的数的数量，所以考虑其中一个就可以了。

那么用线段树维护 $A$ 的前缀数组与 $B$ 的前缀数组的差，使其最小值保持在 $0$ 以上即可，复杂度 $O(nlogn)$。

# 代码
```cpp
#include<bits/stdc++.h>
#define max(a,b) ((a>b)?a:b)
#define min(a,b) ((a<b)?a:b)
using namespace std;
const int N=4e5+50;
int n;
int a[N],loc[N];
int delt[N];
struct Tree {
    int l,r;
    int ans;
    int tag;
}tr[N*4];
void pushup(int p) {
    tr[p].ans=min(tr[p<<1].ans,tr[(p<<1)|1].ans);
}
void pushdown(int p) {
    int tag=tr[p].tag;
    tr[p<<1].tag+=tag;
    tr[(p<<1)|1].tag+=tag;
    tr[p<<1].ans+=tag;
    tr[(p<<1)|1].ans+=tag;
    tr[p].tag=0;
}
void build(int l,int r,int p) {
    tr[p].l=l,tr[p].r=r;
    if(l==r) {
        tr[p].ans=l;
        return;
    }
    int mid=l+r>>1;
    build(l,mid,p<<1);
    build(mid+1,r,(p<<1)|1);
    pushup(p);
}
void change(int l,int r,int x,int p) {
    if(tr[p].l>=l&&tr[p].r<=r) {
        tr[p].ans+=x;
        tr[p].tag+=x;
        return;
    }
    pushdown(p);
    int mid=tr[p].l+tr[p].r>>1;
    if(mid>=l) change(l,r,x,p<<1);
    if(mid<r) change(l,r,x,(p<<1)|1);
    pushup(p);
}
int ans;
int main() {
    scanf("%d",&n);
    for(int i=1;i<=n*2+1;++i) scanf("%d",&a[i]),loc[a[i]]=i;
    build(1,n,1);
    int l=1,r=0;
    while(r<=n*2+1) {
        if(tr[1].ans<0) {
            l++;
            if(loc[l-1]==n+1) continue;
            else if(loc[l-1]<n+1) change(loc[l-1],n,1,1);
            else change(2*n+2-loc[l-1],n,1,1);
        }
        else {
            ans=max(ans,r-l+1);
            r++;
            if(loc[r]==n+1) continue;
            else if(loc[r]<n+1) change(loc[r],n,-1,1);
            else change(2*n+2-loc[r],n,-1,1);
        }
    }
    printf("%d\n",ans);
}
```

---

## 作者：World_Creater (赞：4)

给出一种跟题解区思考方向不一样的方式。

之前做过一个类似的题，那个题是通过分析出来选中位数的可选方案，然后推出所有可行方式，最后直接做。

那么同样考虑分析选数的可行方案。

首先我们将序列分层一下，便于思考：

比如 ${1,2,3,4,5,6,7}$，我们可以拆成 $[4,4]$ 第一层，$[3,5]$ 第二层，$[2,6]$ 第三层， $[1,7]$ 第四层。

显然每次取中位数肯定满足：第一次取在第一层，第二次取在第二层，第三次取在第三层等等，证明可以考虑每次删数之后中位数的偏移为 $1$。

考虑对每层进行分析。

发现有这么一种情况：如果存在一种选数方案，每层中被删掉的数比被选出来的数多的话，那么这种方案就不合法，因为一层一层选选到这一层没有数字可以选了，**即，每一层选的数比删掉的数多。**

将选的数标记为 $1$，不选的数标记为 $-1$，那么满足：每一层的和都大于 $0$。

考虑维护这个东西。

直接分成若干层难以维护，但是考虑到每一层相当于上一层多添了两个数，那么层与层之间其实是一个前缀和，即 $[3,5]=[4,4]+3+5,[2,6]=[3,5]+2+6$，依次类推。那么每层都是正的即相当于这样的前缀和是正的。

那么这样，我们就可以判断一个方案是否可行：即通过前缀和把所有层算出来在检查。

思考一个更难的地方：如果我们的选数方案不完整（即假如本来要取 $4$，我只取了 $2$ 个），我们能否判断把数选完之后是否合法？

考虑依然把每层的和搞出来，并且算出哪一层缺的最多（即每一层的和最小值），**有结论：假如剩下 $x$ 个数可以选，并且每一层和的最小值为 $y$，那么这种方案合法当且仅当：$2x+y>0$。**

必要性显然（考虑每次把一个数从没选变成选的状态它对和的变化为加二）。

构造证明充分性：从第一层开始往上枚举每一层，如果是和是负的，我们就选上数，使得它变成正的。显然这样会将后面所有和为负的都影响，因此选到和最小的层时，如果可以选成和为正的，那么在它之后的层和之前的层都是正的，因此我们通过选了 $x$ 个数使得方案成立，证毕。

想到这里，就可以考虑在值域上双指针了，（单调性显然吧，一个选数方案成立那么它的子集也成立），设以 $i$ 为右端点左端点选数选到 $r$，统计所有 $r-l+1$ 的最大值即可。

但是这样还不够，每次双指针加入删除都重新做一遍前缀和太慢了，是 $\mathcal{O}(n^2)$ 的。

考虑将某一个数选或不选状态影响统计：所有包含它的层（显然是一段后缀）加二或减二，查询是全局最大值，线段树即可，复杂度 $\mathcal{O}(n\log n)$。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[500005],p[500005],ans;
struct segtree{
	#define lc(x) (x<<1)
	#define rc(x) (x<<1|1)
	#define M(l,r) ((l+r)>>1)
	int tree[2000005],tag[2000005];
	void pushup(int p)
	{
		tree[p]=min(tree[lc(p)],tree[rc(p)]);
	}
	void maketag(int p,int k)
	{
		tree[p]+=k;
		tag[p]+=k;
	}
	void pushdown(int p)
	{
		maketag(lc(p),tag[p]);
		maketag(rc(p),tag[p]);
		tag[p]=0;
	}
	void build(int p,int l,int r)
	{
		if(l==r)
		{
			tree[p]=-(2*l-1);
			return ;
		}
		int mid=M(l,r);
		build(lc(p),l,mid);
		build(rc(p),mid+1,r);
		pushup(p);
	}
	void modify(int p,int l,int r,int L,int R,int k)
	{
		if(L<=l&&r<=R)
		{
			maketag(p,k);
			return ;
		}
		pushdown(p);
		int mid=M(l,r);
		if(L<=mid) modify(lc(p),l,mid,L,R,k);
		if(mid<R) modify(rc(p),mid+1,r,L,R,k);
		pushup(p);
	}
}T;
void add(int x)
{
	int l=abs(n+1-x)+1;
	T.modify(1,1,n+1,l,n+1,2);
}
void del(int x)
{
	int l=abs(n+1-x)+1;
	T.modify(1,1,n+1,l,n+1,-2);
}
bool check(int l,int r)
{
	int mx=T.tree[1];
	int cnt=n+1-(r-l+1);
	// cerr<<"?"<<l<<" "<<r<<" "<<cnt*2<<" "<<mx<<"\n";
	if(cnt*2+mx>=0) return 1;
	return 0; 
}
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>n;
	m=n*2+1;
	for(int i=1;i<=m;i++)
	{
		cin>>a[i];
		p[a[i]]=i;
	}
	int l=1;
	T.build(1,1,n+1);
	for(int i=1;i<=m;i++)
	{
		add(p[i]);
		while(l<i&&(!check(l,i)||i-l+1>n+1)) del(p[l++]);
		ans=max(ans,i-l+1);
	}
	cout<<ans;
}
```

---

## 作者：C　C　A (赞：3)

看到这个题发现一脸不可做的样子，考虑转化一下题意。
首先可以发现第一次取的数是固定的，于是将它先取掉。后面的操作就变成了：先取任意一个位置，然后再取剩下的中间的数。
可以发现这个东西可以用两个栈拟合得很好，于是考虑将左右两边的数分别插入两个栈中，每次取其中一个栈内任意元素，然后将另一个栈的栈顶删除。

考虑枚举最终选择的区间，将这个区间内的点称作 “关键点” 并在栈中标记。可以发现，这些关键点一定要作为栈顶删除。
于是原问题被转化成一个判定问题：对于两个栈，每次操作为，将其中一个的栈顶与另一个中的任意元素一起删除。需要知道是否存在某种删除方式使所有关键点都作为栈顶被删除。

考虑栈顶的情况，发现一共有 $3$ 种 ：两个都是关键点，两个都不是关键点或一个是关键点而另一个不是。
考虑到出现不合法情况当且仅当其中一个栈内还有关键点而另一个栈内全都是关键点。而在三种情况中只有两个都不是关键点的情况才会浪费非关键点，所以我们要尽可能将关键点往上放，让它尽快消掉。这等价于尽可能先删除靠近栈顶的非关键点。
于是可以得到一个贪心的判定方法：对于两个都是非关键点的情况，将它们两个一起删除。对于一个是关键点而另一个不是的情况，将他们两个一起删除。对于两个都是关键点的情况，将其中一个与另一个栈中最靠近栈顶的非关键点匹配，这个可以用指针维护。
单次判定 $\Theta(n).$

再考虑到同时枚举最终选择两个端点非常浪费，由于极大合法区间的右端点一定随着左端点单调递增，所以可以用双指针维护。
再加上单次 $\Theta(n)$ 的判定，可以做到 $\Theta(n^2).$

考虑到枚举端点似乎已经没法优化，而判定时每次只修改了一个点的关键性，却要 $\Theta(n)$ 地重新判定，非常冗余，于是考虑从判定上下手继续优化。
可以发现，上文所述的删除方式相当于是给一个栈中的所有关键点找一个匹配，又因为关键点只能跟深度比自己大的点匹配，所以考虑建立一张二分图，每个栈中的关键点向另一个栈中比自己深的非关键点连边。
这两张二分图什么时候有完美匹配呢？根据 $\rm Hall$ 定律，设一边的某个点集 $S$ 向另一边的连边集合为 $E(S)$，一张二分图存在完美匹配，当且仅当对于任意集合 $S$，满足 $|E(S)|\geqslant |S|.$ 在这道题中就是在两个栈的任何两个长度相等的后缀内，其中一个里的关键点数量不大于另一个里的非关键点数量。并且由于一个栈内的点不是关键点就是非关键点，所以如果一个栈内的关键点相对于另一个栈内的非关键点合法，则两张二分图都存在完美匹配。

可以发现，如果将关键点看作 $-1$，非关键点看作 $+1$，那么这种标记关键点的方式合法当且仅当任何一个后缀和不小于 $0.$
这个可以用树状数组维护，每次区间端点移动则对后缀和区间修改，维护一下总体的最小值，判一下它是否为负数即可。

时间复杂度 $\Theta(n\log n).$

---

## 作者：Elma_ (赞：0)

不太一样的贪心推导思路（不过最后结论好像是一样的）。

转化一下题意：显然一开始就在 $A$ 中间的一定会被取，剩下的操作相当于是给定两个长为 $n$ 的栈，进行 $n$ 次操作，每次操作删除其中一个栈的某个元素，然后将另一个栈的栈顶删除并扔到 $B$ 里。

不妨先考察一下最后的 $B$ 在原来的栈中可能分布成什么样子。我们钦定栈中的一些元素最后在 $B$ 里，考虑如何判定是否存在一种满足条件的操作方式。不妨假设操作已经提前确定，即已经知道了选这些元素的时候删的是另一个栈中的哪些元素，把这些关系写成 $(p_i,q_i)$ 的形式，那么判定能否完成这些操作是简单的：能完成全部操作的充要条件是不存在某两个操作 $i,j$ 满足 $p_i < q_j$，且 $p_j < q_i$。

必要性是显然的，充分性随便构造一下就行了。于是我们要解决的问题变成，给定 $B$ 中的元素，我们要为它们找匹配，使得上面的情况尽可能不发生。感性地想，我们希望 $q_i$ 尽量小，这样可能的 $p_j$ 就会尽量少。同时，对于较小的 $p_i$，由于可能的 $q_j$ 更多，所以我们希望能够把较小的 $q_i$ 分给它。于是我们的贪心策略是这样的：对于每个栈的关键元素，从栈低开始，依次匹配另一个栈最靠栈低的非关键元素。考虑直接枚举最长值域连续段，使用双指针，直接模拟判定过程可以得到 $\mathcal{O}(n^2)$ 的时间复杂度。

考虑寻找更快的判定方式。设在 $B$ 中的元素为 $1$，其余元素为 $0$，此时两个栈从栈低开始前缀 $0$ 的个数分别为 $L0_i,R0_i$，前缀 $1$ 的个数分别为 $L1_i,R1_i$，那么合法当且仅当不存在 $i,j$ 使得 $L1_i > R0_j$，且 $R1_j > L0_i$。考虑若这样的 $i,j$ 存在，那么根据贪心匹配过程，一定会出现两组匹配 $(p1,q1),(p2,q2)$ 满足 $p1\leq i,q1 > j$，且 $p2 \leq j,q2 > i$，而这两组匹配矛盾。充分性也可以通过类似的分析得到。

但这个东西似乎没有办法快速维护。 事实上我们有更强的结论：合法当且仅当对于所有 $i$，有 $L1_i \leq  R0_i$。这是因为，若 $L1_i > R0_j$，由于 $1 \sim i$ 中 $0$ 和 $1$ 的总和固定，因此自然有 $L0_i > R1_i$，反之亦然。于是可以直接用线段树维护 $R0_i - L1_i$ 的最小值，每次只需要做一个区间加。

总时间复杂度 $\mathcal{O}(n \log n)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
constexpr int N = 4e5 + 5;
int n, a[N], q[N];
#define m ((l + r) >> 1)
int tr[N << 2], tg[N << 2];
void ptag(int x, int v) { tr[x] += v, tg[x] += v; }
void down(int x) {
	if (tg[x]) ptag(x << 1, tg[x]), ptag(x << 1 | 1, tg[x]), tg[x] = 0;
}
void build(int x, int l, int r) {
	if (l == r) return tr[x] = l, void();
	build(x << 1, l, m), build(x << 1 | 1, m + 1, r);
	tr[x] = min(tr[x << 1], tr[x << 1 | 1]);
}
void mdf(int x, int l, int r, int ql, int qr, int v) {
	if (ql <= l && qr >= r) return ptag(x, v);
	down(x);
	if (ql <= m) mdf(x << 1, l, m, ql, qr, v);
	if (qr > m) mdf(x << 1 | 1, m + 1, r, ql, qr, v);
	tr[x] = min(tr[x << 1], tr[x << 1 | 1]);
}
#undef m
signed main() {
	ios :: sync_with_stdio(false);
	cin.tie(nullptr);
	cin >> n;
	for (int i = 1; i <= 2 * n + 1; i++) cin >> a[i], q[a[i]] = i;
	build(1, 1, n);
	int ans = 0;
	for (int l = 1, r = 1; r <= 2 * n + 1; r++) {
		int pos = q[r];
		if (pos <= n) mdf(1, 1, n, pos, n, -1);
		else if (pos > n + 1) mdf(1, 1, n, 2 * n + 1 - pos + 1, n, -1);
		while (tr[1] < 0) {
			int pos = q[l];
			if (pos <= n) mdf(1, 1, n, pos, n, 1);
			else if (pos > n + 1) mdf(1, 1, n, 2 * n + 1 - pos + 1, n, 1);
			l += 1;	
		}
		ans = max(ans, r - l + 1);
	}
	cout << ans << "\n";
 	return 0;
}
```


---


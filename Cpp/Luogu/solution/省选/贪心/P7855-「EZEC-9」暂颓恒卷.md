# 「EZEC-9」暂颓恒卷

## 题目背景

一些人坐成一横排，学习知识。其中有的人卷，有的人颓。

## 题目描述

### 人的行为与定义

一个人要么处于卷态，要么处于颓态。不卷则颓，不颓则卷。

这题中我们认为一共有四种人：

1. 恒卷人。恒卷人无论何时都为卷态。

2. 恒颓人。恒颓人无论何时都为颓态。

3. 暂卷人。若在某一秒暂卷人处于卷态而左右两人都处于颓态，则其下一秒状态更新为颓态。若在某一秒暂卷人处于颓态而左右有一人处于卷态，则其下一秒状态更新为卷态。__简而言之：有卷则卷。__

4. 暂颓人。若在某一秒暂颓人处于颓态而左右两人都处于卷态，则其下一秒状态更新为卷态。若在某一秒暂颓人处于卷态而左右有一人处于颓态，则其下一秒状态更新为颓态。__简而言之：有颓则颓。__

我们称处于卷态的暂卷人为卷态暂卷人，处于颓态的暂卷人为颓态暂卷人，处于卷态的暂颓人为卷态暂颓人，处于颓态的暂颓人为颓态暂颓人。

我们称恒卷人与恒颓人为恒人，暂卷人与暂颓人为暂人。

### 定义后的题目描述

有 $n$ 个人坐成一横排。最左边为第 $1$ 个人，最右边为第 $n$ 个人。

初始时给定第 $i$ 个人为第 $a_i$ 种人。保证 $a_i\in \{1,2,3,4\}$，$a_1,a_n\in\{1,2\}$（这四个编号如上文所示），即第 $1$ 个人和第 $n$ 个人都为恒人。__保证没有两个同类型恒人之间不存在其他恒人，也就是说只看恒人，恒卷人和恒颓人交替出现。__

这排人每人有一种状态，形成一个状态组。一个状态组是稳定的，当且仅当下一秒没有人状态更新。一个状态组的卷数是处于卷态的人数（恒卷人，卷态暂颓人，卷态暂卷人处于卷态）。

这排人的最佳状态组为一个 __稳定__ 的状态组，且卷数是所有稳定的状态组中的最大值（也就是说你可以任意钦定初始状态）。这排人的优秀程度被定义为最佳状态组的卷数。

老师认为他们~~太逊了~~不够优秀。由于恒卷人不必交换，恒颓人无可救药，老师让你交换小于等于 $k$ 对暂人。问交换后优秀程度的最大值。

## 说明/提示


【样例 $1$ 说明】

交换第 $5$ 个人与第 $6$ 个人，此时优秀程度为 $7$（第 $1,2,3,5,6,7,8$ 个人处于卷态）。

【数据规模与约定】

**本题采用捆绑测试。**

-  Subtask 1（30 points）：$1\leq k\leq2$，$n=9$。
-  Subtask 2（20 points）：只有第 $1$ 个人和第 $n$ 个人是恒人， $k>0$。
-  Subtask 3（10 points）：$k = 0$。
-  Subtask 4（40 points）：无特殊限制。

对于 $100\%$ 的数据，$a_i\in \{1,2,3,4\}$，$a_1,a_n\in\{1,2\}$，$4 \le n \leq 2\times10^6$，$0\le k \le 2\times 10^6$。



### 提示

Subtask 4 的数据经过了多次加强，一共有 $62$ 个测试点。

## 样例 #1

### 输入

```
8 3
1 3 3 2 4 3 4 1```

### 输出

```
7```

# 题解

## 作者：Perfound (赞：9)

# P7855 「EZEC-9」 暂颓恒卷 题解
~~为防棕名~~先发个声明：和 wyy332623 的 3 个代码雷同是因为我一天内交的次数满了,就把代码给他交.

------------

# 思路

------------

这题最重要的一点是要知道 1-3 之间（无 2 或 1）可全部变卷。

方便起见，把每个 1-2（之间无 2 或 1）叫做一个区间。

要求最大值，那就先把所有输入的区间内 1-3（离 2 最近的）的距离（包括 2 个端点）之和记作 $res$。

那这 1-3（离 2 最近的）之间的3就没用了，数量记作 $us3$（不包括 2 个端点）。

要移动 3（离 2 最近的）当然要移到那个 2（本区间）边上，区间 i 的移动所加的值记为 $add_ i$。

但这通过率不到 2% 的 ~~大水题~~ 肯定会有像 1-2（无 1 或 2）之间只有 4 的 ~~比较水的~~ 数据，把它定义为 ~~水区间~~。

那怎么办呢？

肯定先用 $us3$ 因为它可以进行 ~~人见人爱花见花开的白嫖~~，把它放到 ~~水区间~~ 的 2 边上。

把 ~~水区间~~ i 内 4 的个数记为 $empty_i$。

那 $res=res+empty_{headempty}$。

$us3=us3-1$（~~白嫖次数减一~~）//哭

那有 ~~更水的~~ 数据连 3 都不够（$us3<tailempty-headempty+1$）就 ~~拆东墙补西墙~~，把区间 i 拆下要减的 1-3 （离 2 最近的）的距离（包括 1 个端点）记为 $wipe_i$（加到 ~~水区间~~ 的 2 边上）

即 $res=res+empty_{headempty}-wipe_{headwipe}$

（$empty_{headempty}-wipe_{headwipe}<0$ 时退出）因为这样 $res$ 会倒减且这是最后方案（即 ~~白嫖失败~~）

排序：

$add$ 从大到小。

$empty$ 从大到小。

$wipe$ 从小到大。

（$add_{headadd} \geq empty_{headempty}$ 时）先用 $add$。

否则用 $us3$（因为 ~~可以白嫖~~）最后用 $wipe$，即 ~~有代价的白嫖~~（$us3$ 没了所以可以用）。

$add_i$ 用了 $wipe_i$ 就用不了了（反过来也一样）用 set 即可解决这个问题。

为使 $add$ 和 $wipe$ 一一对应，$add_k=0$ 时也应算入。

记得把 $wipe$ 生成的 $empty$ 重新加入。

------------

# 代码

------------

```cpp
#include<bits/stdc++.h>
using namespace std;
int add[2000010],wipe[2000010];
struct ad{
	int v,p;
	friend bool operator <(ad x,ad y){
		return x.v==y.v?x.p>y.p:x.v>y.v; 
	}
};
struct wp{
	int v,p;
	friend bool operator <(wp x,wp y){
		return x.v==y.v?x.p<y.p:x.v<y.v; 
	}
};
struct ep{
	int v;
	friend bool operator <(ep x,ep y){
		return x.v>y.v; 
	}
};
set<ad>s1;set<wp>s2;
multiset<ep>s3;
int empty[2000010],is[2000010];
bool cme(int a,int b){return a>b;}
int hw,he,ha;
int ta=-1,tw=-1,te=-1;
int f,b13,b3,b1,b2;
int res,us3;
void usa(){
	auto it=s1.begin();
    s2.erase((wp){wipe[(*it).p],(*it).p});
    res+=(*it).v,s1.erase(it);
}
void usw(){
	auto it=s2.begin();
	s1.erase((ad){add[(*it).p],(*it).p});
    res+=(*s3.begin()).v-(*it).v;
	s3.erase(s3.begin());
	s3.insert((ep){is[(*it).p]});
	s2.erase(it);
}
int main(){
    int k,c,a;
    scanf("%d%d",&k,&c);
    for(int i=1;i<=k;i++){
        scanf("%d",&a);
        if(a==1){
            if(b13>0)wipe[++tw]=i-b3,is[tw]=i-b2-1;
            if(b13<=0&&i!=1)empty[++te]=i+b13-1;
            f=min(f+1,2),us3+=(f==2);
            if(b13>=0)res+=i-b13;
            else res++;
            b13=b1=i,f=0;
        }else if(a==2){
            if(b13!=b1)wipe[++tw]=b13-b1,is[tw]=i-b1-1;
            if(f==0&&i!=1)empty[++te]=i-b13-1;
            if(f>0)add[++ta]=i-b13-1;b13=-i,b2=i,f=0;
        }else if(a==3){
            if(b13>0)res+=i-b13,f=min(f+1,2),us3+=(f==2);//去掉二个端点 f 就这样搞 
            else add[++ta]=i+b13-1,b3=i,res++;b13=i;
        }
    }
    for(int i=0;i<=ta;i++)s1.insert((ad){add[i],i});
    for(int i=0;i<=tw;i++)s2.insert((wp){wipe[i],i});
    for(int i=0;i<=te;i++)s3.insert((ep){empty[i]});
    for(int i=0;i<c;i++){
        if(s3.size()){
            if(s1.size()){
                if((*s1.begin()).v>=(*s3.begin()).v)usa();
                else if((us3--)>0)res+=(*s3.begin()).v,s3.erase(s3.begin());
                else if(!s2.size())usa();
                else if((*s1.begin()).v>=(*s3.begin()).v-(*s2.begin()).v)usa();
                else if((*s3.begin()).v-(*s2.begin()).v>0)usw();
                else break;
            }else if((us3--)>0)res+=(*s3.begin()).v,s3.erase(s3.begin());
            else if(!s2.size())break;
            else if((*s3.begin()).v-(*s2.begin()).v>0)usw();
            else break;
        }else if(s1.size())usa();
        else break;
    }
    cout<<res;
    return 0;
}
```

------------

# 总结

------------


~~洛谷月赛真是越来越毒瘤了~~

~~都开始传播白嫖主义了~~

---

## 作者：SDNetFriend (赞：7)

## P7855 「EZEC-9」暂颓恒卷

[题面链接](https://www.luogu.com.cn/problem/P7855)

AC 的时候只有 $19$ 份通过记录，祭一下一道做了一上午的题

这是一道贪心题

然后题目不再赘述

我们用 $A$ $a$ $B$ $b$ 分别代表恒卷人，暂卷人，恒颓人，暂颓人，这样看起来方便一点

然后我们会发现一个性质，既然保证 $A$ 与 $B$ 交替出现，那么每个区间左边不是 $A$ 就是 $B$，我们只考虑左侧是 $A$ 的区间，右侧同理

那么这个区间~~能有多卷呢~~能产生多大价值呢？我们发现如果出现这种情况：$A$……$a$ $b$……$b$ $B$，只要我们刚开始让区间全都卷起来，那最右边的暂卷人左边的人都会很卷，这是这个题能够贪心的原因

然后我们需要交换暂卷人，而且完全不用在意暂颓人，而且我们发现，一个区间不是在最右端的暂卷人换掉了都无所谓，那么我们换的时候肯定先换这些人。

并且换到哪里去呢？一定是换到当前区间挨着 $B$ 的那个位置，这样整个区间就可以卷起来

但如果没有空闲的暂卷人呢？我们把空闲的暂卷人叫做一个币，当我们还有币的时候就找到最大的还没卷的区间让它卷起来，否则找一个区间取出其端点暂卷人来造币。并且原来就是非空区间，把端点的 $a$ 挪到另一边是不费币的。

这样就有空区间和非空区间两种区间（我们这里就不用考虑人了，全都看成区间），刚开始把所有的空闲的暂卷人取出当做币，然后每次操作比较下没填满的部分最大的空区间和非空区间，有币直接填最大的那个，否则把非空区间的价值减去造币代价最小的区间的代价，我们需要维护三个 set

#### 维护信息

$s_0$：按照区间剩余价值从大到小排序的所有空区间

$s_1$：按照区间剩余价值从大到小排序的所有非空区间

$s_2$：按照区间已有的价值从小到大排序的所有非空区间（用来造币）

#### 算法流程

刚开始找到所有区间，空的放进 $s_0$，非空放进 $s_1$ 和 $s_2$，每次操作比较 $s_0$ $s_1$ 的队头哪个最大，如果没币把 $s_1$ 的价值减去造币代价，如果 $s_1$ 大那么直接操作，如果 $s_0$ 大那就把 $s_2$ 的队头造币然后塞进 $s_0$ 里面，并且把原来 $s_0$ 的队头塞进 $s_1$ $s_2$ 里面，这题就完了。

（提交好多题解说重复解法，这个总不能重了（逃））

#### 贴代码

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <set>
#include <vector>
#define lint long long
#define rint register int
using namespace std;
inline int read(){
	char c;int f=1,res=0;
	while(c=getchar(),!isdigit(c))if(c=='-')f*=-1;
	while(isdigit(c))res=res*10+c-'0',c=getchar();
	return res*f;
}
const int N=2e6+5;
int n,k,cnt=0,len[N],fu[N],a[N],co=0,ans=0;
struct _s0{int id;};
bool operator<(_s0 x,_s0 y){
	if(len[x.id]==len[y.id])
		return x.id<y.id;
	return len[x.id]<len[y.id];
}
set<_s0> s0;
struct _s1{int id;};
bool operator<(_s1 x,_s1 y){
	if(len[x.id]-fu[x.id]==len[y.id]-fu[y.id])
		return x.id<y.id;
	return len[x.id]-fu[x.id]<len[y.id]-fu[y.id];
}
set<_s1> s1;
struct _s2{int id;};
bool operator<(_s2 x,_s2 y){
	if(fu[x.id]==fu[y.id])
		return x.id<y.id;
	return fu[x.id]<fu[y.id];
}
set<_s2> s2;
inline void init(){
	int p=0;
	bool work=false;
	for(rint l=1,r=1;r<=n;++r){
		if(a[r]==1){
			l=r;
			p=0;
			work=true;
		}else if(a[r]==2){
			work=false;
			if(r==1)continue;
			len[++cnt]=r-l-1;
			if(p)fu[cnt]=p-l,s1.insert((_s1){cnt}),s2.insert((_s2){cnt});
			else s0.insert((_s0){cnt});
		}else if(a[r]==3&&work){
			if(p)++co;
			p=r;
		}
	}
	work=false;
	p=0;
	for(rint l=n,r=n;l>=1;--l){
		if(a[l]==1){
			r=l;
			p=0;
			work=true;
		}else if(a[l]==2){
			work=false;
			if(l==n)continue;
			len[++cnt]=r-l-1;
			if(p)fu[cnt]=r-p,s1.insert((_s1){cnt}),s2.insert((_s2){cnt});
			else s0.insert((_s0){cnt});
		}else if(a[l]==3&&work){
			if(p)++co;
			p=l;
		}
	}
}
inline void mk(int i){
	s1.erase((_s1){i});
	s2.erase((_s2){i});
	fu[i]=0;
	s0.insert((_s0){i});
}
inline void solve(){
	while(k--){
		int p0,p1,p2,v0,v1;
		if(!s0.empty()){
			p0=(--s0.end())->id;
			v0=len[p0];
			if(!co){//如果没币就从s2里面提出来一个 
				if(!s2.empty()){
					p2=s2.begin()->id;
					v0-=fu[p2];//能提的话除去花费 
				}else v0=0;//否则没法选，就抛弃这种情况 
			}
		}else v0=0;
		if(!s1.empty()){
			p1=(--s1.end())->id;
			v1=len[p1]-fu[p1];
		}else v1=0;
		if(v0>v1){
			if(!co)mk(p2);
			else --co;
			s0.erase((_s0){p0});
			fu[p0]=len[p0];
			s1.insert((_s1){p0});
			s2.insert((_s2){p0});
		}else if(v1){
			s1.erase((_s1){p1});
			s2.erase((_s2){p1});
			fu[p1]=len[p1];
			s1.insert((_s1){p1});
			s2.insert((_s2){p1});
		}
	}
}
/*
s0 专存空区间的剩余价值，填满花费币，填了之后塞到s2里面
s1 存非空区间剩余价值，填满不花费币 
s2 存所有非区间已填长度，用来造币，造完之后塞回s0
用mk来造币，init预处理区间 
len保存区间总长度 fu存区间已经填了多少 
不用考虑造币产生的不是空区间，既然没币了说明当前区间也就一个点了 
*/
int main(){
	n=read();
	k=read();
	for(rint i=1;i<=n;++i){
		a[i]=read();
		if(a[i]==1)++ans;
	}
	init();
	solve();
	for(rint i=1;i<=cnt;++i)
		ans+=fu[i];
	printf("%d",ans);
	return 0;
}
```


---

## 作者：dead_X (赞：2)

## 前言
题解区已经有的题解都是什么牛魔，建议全部撤下。
## 思路
考虑一个和恒颓人贴贴的暂颓人，他最后肯定要颓废，然后剩下的人只要最开始全在卷就可以一直卷下去。那么我们可以发现如果交换，我们一定将一个恒颓人旁边的人换成暂卷人。

所以转化题意看起来是这样的：

- 给定两个序列 $a_i,b_i$，一个常数 $c$ 和步数限制 $k$。
- 每一步可以将 $c-1$，然后将 $a_i\leftarrow b_i$。
- 每一步也可以将 $a_i\neq 0$ 进行 $a_i\leftarrow b_i$。
- 每一步也可以将 $a_i\neq 0$ 进行 $a_i\leftarrow 0$，$a_j\leftarrow b_j$。

然后这个好像没法简单贪，考虑流一下，这个还是简单的。

最后把流的部分变成模拟费用流就完了，决策只有四种：

- 将 $x$ 选为 $a_x\leftarrow b_x$。
- 将 $x$ 牺牲掉，使某个 $a_y=0$ 选为 $a_y\leftarrow b_y$。
- 将 $x$ 代替 $y$ 牺牲掉。

维护三类决策就做完了，时间复杂度 $O(n\log n)$ 或 $O(n)$。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read(){
   int s=0,w=1;
   char ch=getchar();
   while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
   while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
   return s*w;
}
int a[2000003];
int A[2000003],B[2000003],nf;
int v[2000003];
signed main()
{
	int n=read(),m=read(),ans=0;
	for(int i=1; i<=n; ++i) a[i]=read(),ans+=(a[i]==1);
	priority_queue<int> g;
	for(int i=2,j=1; i<=n; ++i) if(a[i]<=2)
	{
		int S=0,fir=0;
		for(int k=j+1; k<i; ++k)
			if(a[k]==3) ++S;
		if(S==0){g.push(i-j-1),j=i;continue;}
		if(a[i]==2)	for(int k=i-1; a[k]==4; --k) ++fir;
		else for(int k=j+1; a[k]==4; ++k) ++fir;
		A[++nf]=fir,B[nf]=i-j-fir-1;
		for(int i=1; i<S; ++i) ++nf;
		ans+=i-j-fir-1,j=i;
	}
	priority_queue<pair<int,int>> qa,qb,qab;
	m=min(m,nf);
	for(int i=1; i<=nf; ++i)
		qa.push({A[i],i}),qb.push({-B[i],i});
	while(m--)
	{
		while(!qa.empty()&&v[qa.top().second]) qa.pop();
		while(!qb.empty()&&v[qb.top().second]) qb.pop();
		int v1=-1,v2=-1;
		if(!qa.empty()) v1=qa.top().first;
		if(!qb.empty()&&!g.empty()) v2=qb.top().first+g.top();
		if(v1<0&&v2<0) break;
		ans+=max(v1,v2);
		if(v1>=v2) v[qa.top().second]=2;
		else v[qb.top().second]=1,
		g.pop(),g.push(A[qb.top().second]+B[qb.top().second]);
	}
	puts("HaitangSuki");
	return 0;
}
```

---


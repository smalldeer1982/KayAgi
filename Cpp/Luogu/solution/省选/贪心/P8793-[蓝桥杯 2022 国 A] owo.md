# [蓝桥杯 2022 国 A] owo

## 题目背景

与蓝桥杯评测数据不同，本题约定了字符不是 `o` 就是 `w`，避免无意义的更复杂的分类讨论（原题也并未写清数据范围）。

## 题目描述

小蓝很喜欢 `owo`，他现在有一些字符串，他想将这些字符串拼接起来，使得最终得到的字符串中出现尽可能多的 `owo`。

在计算数量时，允许字符重叠，即 `owowo` 计算为 $2$ 个，`owowowo` 计算为 $3$ 个。请算出最优情况下得到的字符串中有多少个 `owo`。

## 说明/提示

**【评测用例规模与约定】**

- 对于 $10\%$ 的评测用例，$n \leq 10$；
- 对于 $40\%$ 的评测用例，$n \leq 300$；
- 对于 $60\%$ 的评测用例，$n \leq 5000$；
- 对于所有评测用例，$1 \leq n \leq 10^6$，$1 \leq |s_i|,\sum|s_i| \leq 10^6$，其中 $|s_i|$ 表示字符串 $s_i$ 的长度。字符不是 $\tt o$ 就是 $\tt w$。

蓝桥杯 2022 国赛 A 组 E 题。

## 样例 #1

### 输入

```
3
owo
w
ow```

### 输出

```
1
1
2```

# 题解

## 作者：Register_int (赞：7)

之前两个变量打错了，谢罪。

先暴论一下题解区全是水过去的，再锐评一下数据水的要死乱搞都能过。

首先字符串内部的先不管，手动统计一下即可。接下来能拼接的也只有这几类：

- 前缀为 `o` 的：
	- 前缀为 `o`，后缀为 `o`。
	- 前缀为 `o`，后缀为 `ow`。
	- 前缀为 `o`，后缀为 `ww`。

- 前缀为 `wo` 的：
	- 前缀为 `wo`，后缀为 `o`。
	- 前缀为 `wo`，后缀为 `ow`。
	- 前缀为 `wo`，后缀为 `ww`。
    
- 前缀为 `ww` 的：
	- 前缀为 `ww`，后缀为 `o`。
	- 前缀为 `ww`，后缀为 `ow`。
	- 前缀为 `ww`，后缀为 `ww`。（由于两端封死可以不需要计数）
    
- 单独一个 `w`。

由于匹配 `w` 需要用两个字符串，显然是不优的，所以在动态加入字符串时应单独储存该类字符串数量，最后再单独计算。

显然，我们关心的只是字符串能进行合并的次数，而将新加入的字符串接在已匹配的字符串之前或之后都没有区别。因此，可以直接考虑默认往字符串两端合并。然而合并的优先级仍需继续讨论。

维护每种字符串的个数，加入时讨论该字符串的前后两端即可。具体分讨实现需要注意以下细节：

- 先处理 `o-o` 与 `o-ow`、`wo-o` 可以连成一串。

- 之后处理 `o-ow`、`wo-o` 与一端封死的情况合并。

- 接着处理 `o-o`、`wo-ow` 与一端封死的情况合并。

- 再处理一端封死的情况相互合并，如 `ww-ow` 与 `o-ww` 合并、`ww-o` 和 `wo-ww` 合并。

- 然后处理 `o-o` 与 `wo-ow` 合并。

- 最后处理 `?-o`、`w` 与 `o-?` 合并，以及 `o-o` 与 `w` 合并。

详见代码。

# AC 代码

```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;

const int MAXN = 1e6 + 10;

int cnt[9], t[9], ans;

/*
0: o-o
1: o-ow
2: o-ww

3: wo-o
4: wo-ow
5: wo-ww

6: ww-o
7: ww-ow
8: ww-ww 不用管 

w: w
*/

inline 
int merge() {
	int k = 0, res = 0;
	for (int i = 0; i < 9; i++) t[i] = cnt[i];
	
	// o-o, wo-ow
	
	if (t[0] || t[4]) res += t[1] + t[3], t[1] = t[3] = 0;
	
	// o-ow, wo-o
	
	if (t[1] && (t[2] || t[7])) res += t[1], t[1] = 0;
	if (t[3] && (t[5] || t[6])) res += t[3], t[3] = 0;
	
	// 2:o-ww, 5:wo-ww
	
	if (t[0] && t[5]) k = min(t[0], t[4]), res += k << 1, t[0] -= k, t[4] -= k;
	k = min(t[0], t[5]), res += k, t[0] -= k, t[5] -= k, t[2] += k;
	
	if (t[2] && t[4]) k = min(t[0], t[4]), res += k << 1, t[0] -= k, t[4] -= k;
	k = min(t[2], t[4]), res += k, t[2] -= k, t[4] -= k, t[5] += k;
	
	k = min(t[0], t[5]), res += k, t[0] -= k, t[5] -= k, t[2] += k;
	
	// 6:ww-o, 7:ww-ow
	
	if (t[0] && t[7]) k = min(t[0], t[4]), res += k << 1, t[0] -= k, t[4] -= k;
	k = min(t[0], t[7]), res += k, t[0] -= k, t[7] -= k, t[6] += k;
	
	if (t[4] && t[6]) k = min(t[0], t[4]), res += k << 1, t[0] -= k, t[4] -= k;
	k = min(t[4], t[6]), res += k, t[4] -= k, t[6] -= k, t[7] += k;
	
	k = min(t[0], t[7]), res += k, t[0] -= k, t[7] -= k, t[6] += k;
	
	// 2:o-ww, 5:wo-ww, 6:ww-o, 7:ww-ow
	
	k = min(t[2], t[7]), res += k, t[2] -= k, t[7] -= k;
	k = min(t[5], t[6]), res += k, t[5] -= k, t[6] -= k;
	
	// o-ow, wo-o
	
	if (t[1]) res += t[1] - 1, t[1] = 1;
	if (t[3]) res += t[3] - 1, t[3] = 1;
	
	// o-o, wo-ow
	
	k = min(t[0], t[4]);
	if (k && t[0] == t[4]) res--, t[1] < t[3] ? t[1]++ : t[3]++;
	
	// o-o + wo-ow : wo-ow + o-o
	
	t[0] -= k, t[4] -= k, res += k << 1;
	
	// ?-o + w + o-?, o-o + w + o-o + ... 
	
	int pre = t[3] + t[6], suf = t[1] + t[2];
	
	k = min({ pre, suf, t[8] }), pre -= k, suf -= k, t[8] -= k, res += k;
	if (!(k | pre | suf)) t[0] = max(t[0] - 1, 0); // 需要一个 ?-o 或 o-? 
	return res + min(t[0], t[8]);
}

int n, m; char s[MAXN];

int main() {
    scanf("%d", &n);
    for (int i = 1; i <= n; i++) {
    	scanf("%s", s), m = strlen(s);
    	for (int i = 0; i <= m - 3; i++) if (s[i] == 'o' && s[i + 1] == 'w' && s[i + 2] == 'o') ans++;
    	// w
    	if (m == 1 && *s == 'w') cnt[8]++;
    	// o-?
    	else if (*s == 'o' && s[m - 1] == 'o') cnt[0]++;
    	else if (*s == 'o' && s[m - 2] == 'o' && s[m - 1] == 'w') cnt[1]++;
    	else if (*s == 'o' && s[m - 2] == 'w' && s[m - 1] == 'w') cnt[2]++;
    	// wo-?
    	else if (*s == 'w' && s[1] == 'o' && s[m - 1] == 'o') cnt[3]++;
    	else if (*s == 'w' && s[1] == 'o' && s[m - 2] == 'o' && s[m - 1] == 'w') cnt[4]++;
    	else if (*s == 'w' && s[1] == 'o' && s[m - 2] == 'w' && s[m - 1] == 'w') cnt[5]++;
    	// ww-?
    	else if (*s == 'w' && s[1] == 'w' && s[m - 1] == 'o') cnt[6]++;
    	else if (*s == 'w' && s[1] == 'w' && s[m - 2] == 'o' && s[m - 1] == 'w') cnt[7]++;
    	
		printf("%d\n", ans + merge());
	}
}
```

---

## 作者：myee (赞：2)

### 前言

退役人限时返场，听说蓝桥杯国赛也有难题，然后翻了下就翻到了这题。感觉除了代码不太好写也不算很难啊？

### 思路

容易把串分为 $10$ 类：单独的一个 `w`；或者按左右含 `owo` 的后缀和前缀分类。

除了一个串内部的贡献，其余的贡献均为合并是额外的贡献。这只包含
* 后缀 `o` + `w` + `o` 前缀
* 后缀 `ow` + `o` 前缀
* 后缀 `o` + `wo` 前缀

直观感受下会发现第一种不是很优（会同时占掉后面两类贡献的要素），所以先尽可能满足后两种。

事实上，只要不是所有相关的串都是前缀 `o` + `ow` 后缀，第二类贡献总可以取满；否则必须严格少于这样的串数（避免成环）。第三类同理。

为了同时取满后两类贡献，还需要保证不会出现后缀 `o` = `wo` 前缀且后缀 `ow` = `o` 前缀且所有权值均在两者之间的情况。

在考虑完后两类贡献后要再考虑 `w` 部分的贡献。如果前面两类都不会出现必须严格少于的情况且当前存在多余的前后缀 `o` 且 `w` 充足，那么这一步可能产生环。

可能产生环当且仅当所有含 `o` 前后缀的串都是以 `o` 开头 `o` 结尾的。于是这意味着前两类的贡献串合并后若含有前后缀 `o`，则必定两类连在一起且其首尾含 `o`。于是任一含非空前后缀串的都不能对应空前后缀。

于是直接计算就好了，总复杂度 $O(n)$。

### Code

以下是核心代码。

```cpp
uint Cnt[9],CL[3],CR[3];
int main()
{
    uint n,base=0;scanf("%u",&n);
    while(n--)
    {
        static chr C[1000005];scanf("%s",C);
        uint c=0;while(C[c])c++;
        if(c==1)
        {
            if(C[0]=='w')Cnt[0]++;else Cnt[4]++,CL[1]++,CR[1]++;
        }
        else
        {
            uint l=C[0]=='o'?1:(C[1]=='o'?2:0);
            uint r=C[c-1]=='o'?1:(C[c-2]=='o'?2:0);
            if(l||r)Cnt[l*3+r]++,CL[l]++,CR[r]++;
            for(uint j=2;j<c;j++)base+=C[j-2]=='o'&&C[j-1]=='w'&&C[j]=='o';
        }
        uint Lo=CL[1],Ro=CR[1],Lwo=CL[2],Row=CR[2],w=Cnt[0];
        uint ans=base;
        bol ok=false;
        if(Lo||Row)
        {
            if(Lo==Row&&Lo==Cnt[5])ans+=Lo-1,Lo=Row=1,ok=true;
            else if(Lo<=Row)ans+=Lo,Row-=Lo,Lo=0;
            else ans+=Row,Lo-=Row,Row=0;
        }
        if(Ro||Lwo)
        {
            if(Ro==Lwo&&Ro==Cnt[7])ans+=Ro-1,Lwo=Ro=1,ok=true;
            else if(Ro<=Lwo)ans+=Ro,Lwo-=Ro,Ro=0;
            else ans+=Lwo,Ro-=Lwo,Lwo=0;
        }
        if(!ok&&!Cnt[1]&&!Cnt[2]&&!Cnt[3]&&!Cnt[6]&&!Lo&&!Row&&!Ro&&!Lwo&&CL[1]&&CL[2])ans--,ok=true;
        if(ok||CL[0]||CR[0]||Lo!=Ro||!Lo||w<Lo)ans+=std::min({Lo,Ro,w});
        else ans+=std::min({Lo,Ro,w})-1;
        printf("%u\n",ans);
    }
    return 0;
}
```

---


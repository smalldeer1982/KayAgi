# 「SvR-2」G64

## 题目描述

定义对于两棵有根二叉树 $T_1,T_2$，$\operatorname{merge}(T_1,T_2)$ 的结果是一棵二叉树，满足其根节点的左子树为 $T_1$，右子树为 $T_2$，显然 $\operatorname{merge}(T_1,T_2)$ 的结果唯一且必然存在。

定义对于一棵有根二叉树 $T$，有函数 $G_x(T)$。其中 $G_1(T)$ 表示沿着 $T$ 的根向右儿子走，直到走到某个不存在右儿子的节点，将其右子树变为 $T$，这棵新树即为 $G_1(T)$ ，而当 $x>1$ 时，$G_x(T)$ 满足如下关系：

$$G_x(T)=G_1(\operatorname{merge}(G_{x-1}(T),G_{x-1}(T)))$$

给一棵 $n$ 个节点的以 $1$ 为根的有根二叉树，记以 $i$ 为根的子树为 $T_i$，$q$ 次询问，每次询问给定 $x,i$，求 $G_x(T_i)$ 的最大独立集。


## 说明/提示

### 样例解释

对于第一组样例，$G_2(T_5)$ 的结果如下图（忽略编号）：
![](https://cdn.luogu.com.cn/upload/image_hosting/fcjnzc23.png) 
 

对于第二组样例，我有一个绝妙的解释，可惜 $G_{64}$ 太大了，这里写不下。

#### 数据规模与约定

**本题开启捆绑测试和 O2 优化。**

| Subtask | 数据范围/特殊性质 | 分值 |
| :------: | :------: | :------: |
| $1$ |  $n,q,x\le 10$| $10 \operatorname{pts}$ |
| $2$ | $x =1$ | $5 \operatorname{pts}$ |
| $3$ |$x\le 3$ | $10 \operatorname{pts}$ |
| $4$ | $x\le 10$ | $15 \operatorname{pts}$ |
| $5$ | 保证 $T_i$ 大小为 $1$ | $10 \operatorname{pts}$ |
| $6$ | 无特殊限制 | $50 \operatorname{pts}$ |


对于 $100\%$ 的数据，
$1\le x\le 10^9$，$1\le n\le 5\times 10^5$，$1\le q\le 5\times 10^5$。

## 样例 #1

### 输入

```
5 3
2 3
0 4
5 0
0 0 
0 0
2 5 
2 1
1 1```

### 输出

```
5
24
6```

## 样例 #2

### 输入

```
5 1
2 3
0 4
5 0
0 0 
0 0
64 1```

### 输出

```
592424678```

# 题解

## 作者：Leasier (赞：6)

来点对注意力要求不高的做法。

------------

### Subtask $1 \sim 4$
首先可以直接 dp 求出每个子树的最大独立集。

接下来不难发现从 $G_{x - 1}(T)$ 到 $G_x(T)$ 的过程中我们只关心**根**和**右链端点**选不选，于是设 $dp_{x, i = 0/1, j = 0/1}$ 表示 $G_x(T)$ 中根选的情况为 $i$，右链端点选的情况为 $j$，此时的最大独立集为多少。

$dp_{1, i, j}$ 不难简单讨论得出，$\forall x > 1, dp_{x, i, j}$ 不难复杂讨论得出 $dp_{x - 1, i, j}$ 到其的转移。

暴力实现即可。时间复杂度为 $O(n + qx)$。
### 无特殊限制
类似于 [[SDOI / SXOI2022] 小 N 的独立集](https://www.luogu.com.cn/problem/P8352)，我们有结论：

- 当二叉树 $T$ 的右链长度 $> 2$，$f(T, i, j)$ 的极差 $\leq 2$，这里 $f$ 的定义基本同 $dp_{x, i, j}$。

证明：

- 考虑一个独立集去掉一个点还是一个独立集，有 $T(x, 0, i) \geq T(x, 1, i) - 1, T(x, i, 0) \geq T(x, i, 1) - 1$。
- 考虑强行将根或右链端点加入独立集并删去周围点，有 $T(x, 1, i) \geq T(x, 0, i) - 1, T(x, i, 1) \geq T(x, i, 0) - 1$。
- 综合上式，有 $|T(x, 0, i) - T(x, 1, i)| \leq 1, |T(x, i, 0) - T(x, i, 1)| \leq 1$。
- 于是 $|T(x, 0, 0) - T(x, 1, 1)| \leq 2, |T(x, 0, 1) - T(x, 1, 0)| \leq 2$，遂得证。

于是我们可以这样表出一个 $x$ 对应的状态：

- $(base, v_{0/1, 0/1})$，表示 $dp_{x, i, j} = v_{i, j} + base$。
- 其中 $\min(v_{i, j}) = 0, \max(v_{i, j}) \leq 2$。

可见后面 $v_{0/1, 0/1}$ 的状态数 $\leq 81$（实际上打表可知只有 $30$ 个）。

每次转移 $dp_{x - 1, i, j} \to dp_{x, i, j}$ 时，我们可以预处理出其从 $v_{0/1, 0/1}$ 转移到了 $v'_{0/1, 0/1}$，且 $base \leftarrow 4base + \Delta$。

在此基础上倍增即可。时间复杂度为 $O(n + q \log x)$。

我的实现中直接把表放在预处理函数里了（下示代码中略去）。

代码：
```cpp
#include <stdio.h>

typedef long long ll;

const int N = 66, M = 29, K = 1e6 + 7, P = 1 + 1, mod = 998244353;
int to[N + 7][M + 7], delta[N + 7][M + 7], power[M + 7], ls[K], rs[K], dp[K][P][P], g1[K][P][P], temp[P][P];

inline int add(int x, int y){
	return x + y >= mod ? x + y - mod : x + y;
}

inline void init(){
	// 打表结果放这里
	power[0] = 4;
	for (register int i = 1; i <= M; i++){
		for (register int j = 0; j <= N; j++){
			to[j][i] = to[to[j][i - 1]][i - 1];
			delta[j][i] = add(1ll * delta[j][i - 1] * power[i - 1] % mod, delta[to[j][i - 1]][i - 1]);
		}
		power[i] = 1ll * power[i - 1] * power[i - 1] % mod;
	}
}

inline int read(){
	int ans = 0;
	char ch = getchar();
	while (ch < '0' || ch > '9'){
		ch = getchar();
	}
	while (ch >= '0' && ch <= '9'){
		ans = ans * 10 + (ch ^ 48);
		ch = getchar();
	}
	return ans;
}

inline int max(int a, int b){
	return a > b ? a : b;
}

void dfs(int u){
	if (ls[u] != 0) dfs(ls[u]);
	if (rs[u] != 0) dfs(rs[u]);
	int p = max(dp[ls[u]][0][0], dp[ls[u]][0][1]), q = max(p, max(dp[ls[u]][1][0], dp[ls[u]][1][1]));
	if (rs[u] == 0){
		dp[u][0][0] = max(p, max(dp[ls[u]][1][0], dp[ls[u]][1][1]));
		dp[u][0][1] = dp[u][1][0] = 0x80000000;
		dp[u][1][1] = p + 1;
	} else {
		dp[u][0][0] = q + max(dp[rs[u]][0][0], dp[rs[u]][1][0]);
		dp[u][0][1] = q + max(dp[rs[u]][0][1], dp[rs[u]][1][1]);
		dp[u][1][0] = p + dp[rs[u]][0][0] + 1;
		dp[u][1][1] = p + dp[rs[u]][0][1] + 1;
	}
	for (register int i = 0; i <= 1; i++){
		for (register int j = 0; j <= 1; j++){
			g1[u][i][j] = max(dp[u][i][0] + max(dp[u][0][j], dp[u][1][j]), dp[u][i][1] + dp[u][0][j]);
		}
	}
}

inline int min(int a, int b){
	return a < b ? a : b;
}

inline void trans(int f[P][P], int &base, int &state){
	for (register int i = 0; i <= 1; i++){
		for (register int j = 0; j <= 1; j++){
			temp[i][j] = 0x80000000;
		}
	}
	for (register int i = 0; i <= 1; i++){
		for (register int j = 0; j <= 1; j++){
			for (register int k = 0; i + k <= 1; k++){
				for (register int l = 0; l <= 1; l++){
					for (register int x = 0; i + x <= 1; x++){
						for (register int y = 0; y <= 1; y++){
							for (register int z = 0; y + z <= 1; z++){
								for (register int w = 0; z + w <= 1; w++){
									for (register int p = 0; p <= 1; p++){
										for (register int q = 0; z + q <= 1; q++){
											temp[i][j] = max(temp[i][j], f[k][l] + f[x][y] + f[w][p] + f[q][j] + i + z);
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
	base = min(temp[0][0], min(temp[0][1], min(temp[1][0], temp[1][1])));
	state = (temp[0][0] - base) + (temp[0][1] - base) * 3 + (temp[1][0] - base) * 9 + (temp[1][1] - base) * 27;
}

int main(){
	int n = read(), q = read();
	init();
	for (register int i = 1; i <= n; i++){
		ls[i] = read();
		rs[i] = read();
	}
	dfs(1);
	for (register int I = 1; I <= q; I++){
		int x = read(), i = read();
		if (--x == 0){
			printf("%d\n", max(g1[i][0][0], max(g1[i][0][1], max(g1[i][1][0], g1[i][1][1]))));
			continue;
		}
		int base, state;
		trans(g1[i], base, state);
		x--;
		for (register int j = 0; (1 << j) <= x; j++){
			if (x >> j & 1){
				base = add(1ll * base * power[j] % mod, delta[state][j]);
				state = to[state][j];
			}
		}
		printf("%d\n", max(state % 3, max(state / 3 % 3, max(state / 9 % 3, state / 27))) + base);
	}
	return 0;
}
```

---

## 作者：rizynvu (赞：6)

[我的博客](https://www.cnblogs.com/rizynvu/p/18521935)。

小爆个标，给出一个 $\mathcal{O}(n + q + \sqrt{x} + \log \operatorname{mod})$ 的做法。

可能写的有点意识流了，可以结合代码理解或者私信我吧 qaq。

首先对于最大独立集有 DP：  
设 $f'_{i, 0 / 1}$ 表示考虑 $i$ 的子树，$i$ 选没选的最大独立集点数。  
转移就是 $f'_{i, 0} = \max\{f'_{ls, 0}, f'_{ls, 1}\} + \max\{f'_{rs, 0}, f'_{rs, 1}\}, f'_{i, 1} = f'_{ls, 0} + f'_{rs, 0} + 1$。

但是 $\max\{f'_{ls, 0}, f'_{ls, 1}\}$ 太丑了，考虑换个写法。  
记 $f_{i, 0} = f'_{i, 0}, f_{i, 1} = \max\{f'_{i, 0}, f'_{i, 1}\}$。  
那么转移就是 $f_{i, 0} = f_{ls, 1} + f_{rs, 1}, f_{i, 1} = \max\{f_{i, 0}, f_{ls, 0} + f_{rs, 0} + 1\}$。  

同时记 $g_{i} = f_{i, 1} - f_{i, 0}$。  
接下来给出几个结论，感性理解应该比较简单：  
- $0\le g_i\le 1$。  
  证明考虑如果 $f'_{i, 0}\ge f'_{i, 1}$，显然 $g_i$ 为 $0$；否则若 $f'_{i, 0} < f'_{i, 1}$，那么直接不选 $i$ 这个点，差也只会为 $1$，那么此时 $g_i = 1$ 得证。  
- $g_{i} = [g_{ls} = 0]\times [g_{rs} = 0]$，$f_{i, 1} = f_{ls, 1} + f_{rs, 1} + g_i$，手玩转移式得到。

那么考虑直接维护 $f_i = f_{i, 1}$ 与 $g_i$，转移式就是上面提到的 $g_{i} = [g_{ls} = 0]\times [g_{rs} = 0]$，$f_{i} = f_{ls} + f_{rs} + g_i$，最后的 $f_{rt}$ 即为答案。

接下来考虑如何应用到此问题上。  

考虑 $G_1$ 的操作，能够明确的是实质上只关心右链。  
进一步的，发现因为对于 $f$ 转移就是 $f_{ls} + f_{rs} + g_i$，对于最末的右链结点这里只是把 $f_{rs}$ 给填充了并且可能影响了 $g_{i}$。  
所以实际上只需要考虑下右链的 $g$ 即可了，对于 $f$ 基本是每 $\operatorname{merge}$ 一次或者 $G_1$ 一次就是 $\times 2$，改变的量放在 $g$ 中考虑。

考虑到对于右链的节点 $i$，如果 $g_{ls} = 1$，那么 $g_i$ 一定为 $0$，否则 $g_{i} = 1 - g_{rs}$。  
于是可以预处理出子树内右链从底到根满足 $g_{ls} = 0$ 的极长链 $l$（即从末尾节点开始往上爬，直到离开这颗树或者 $g_{ls} = 1$，而之前走过的点就构成了 $l$）。

记 $p$ 为右链末尾节点（注意的是 $p$ 其实可能不存在，但是这里先假设存在，后面的讨论能够发现其实 $p$ 点是否存在是无关紧要的），那么此时肯定有 $g_p = 1$，因为不存在右儿子且 $g_{ls} = 0$。

先考虑 $G_1$ 操作的贡献，考虑 $g_{rt}$ 的值：
- $g_{rt} = 0$，本来就有 $g_p = 1$，所以并不影响。
- $g_{rt} = 1$，那么 $g_p$ 原本为 $1$，就会变成 $0$，对应的就会使得链 $l$ 上的点的 $g$ 全部取反。  
  那么如果链 $l$ 长度为奇数，原本 $g$ 为 $1$ 的个数比 $0$ 的个数多一个，取反后就变成了 $0$ 的个数比 $1$ 的个数多一个了，于是此时有 $-1$ 的贡献。

然后考虑先 $\operatorname{merge}$ 后 $G_1$（轮数 $> 1$）的操作，此时要对这个链 $l$ 进行分讨。

注：因为第一轮操作比较特殊，不涉及 $\operatorname{merge}$，所以第一轮需要特殊处理一下。  

1. 这个极长链并非右链。  
   对于 $G_1$ 操作，贡献如上。  
   同时因为链 $l$ 是被阻断的，所以在 $G_1$ 操作后整颗树的底至根极长链与 $l$ 是相同的。

   考虑 $\operatorname{merge}$ 操作，这个就比较简单了，因为左右两颗子树是一样的，那么就有 $g_{rt'} = 1 - g_{rt}$。  
   所以当 $g_{rt} = 0$ 时新产生的 $g_{rt'} = 1$，就有 $+1$ 的新贡献。  
   同时极长链 $l$ 也不会被影响。

   同时可以知道，此时 $g_{rt}$ 就以 $0, 1, 0, 1$（假设初始 $g_{rt} = 0$）这样不断的循环，那么每 $2$ 轮就会在 $\operatorname{merge}$ 操作时产生 $+1$ 的新贡献，如果 $l$ 长度为奇数也会在下次的 $G_1$ 操作产生 $-1$ 的贡献。  
   如果去考虑产生的新贡献往后影响的系数，能发现这其实对应的是个 $16$ 为公比的等比数列。  
   
2. 这个极长链就是右链。  

   那么考虑到 $G_1$ 操作后，右链 $l$ 长度肯定翻倍，那么此时右链长度必为偶数（第一轮就有 $G_1$ 了）。  

   于是可以知道此时必有 $g_{rt} = 0, g_{p} = 1$。  
   那么对于 $\operatorname{merge}$ 操作，必定有 $g_{rt'} = 1$，能产生 $+1$ 的贡献。  

   并且在这之后极长链对应会再加上 $rt'$，长度就变为奇数了，又因为 $g_{rt'} = 1$，所以在 $G_1$ 操作后会有 $-1$ 的贡献。  

   于是分析后可以知道每一轮必定有 $+1$ 的贡献，对应的贡献系数是个公比为 $4$ 的等比数列。

分讨完毕！  

于是 $g$ 的这个贡献其实都是公比数列，对于 $f$ 的贡献因为上面提到的增量算在 $g$ 中，对应的就是每一轮 $\times 4$。

（所以形式这么优美，官解却似乎没往这边想，有点可惜。）

于是可以用光速幂预处理出 $4$ 的幂次，并预处理出 $\operatorname{inv}(3), \operatorname{inv}(15)$。  

对于初始 $f, g$ 及极长链的一些信息都是可以 $\mathcal{O}(n)$ 预处理出的。

那么就在 $\mathcal{O}(n + q + \sqrt{x} + \log \operatorname{mod})$ 的时间复杂度做完了。

代码中的 $f, g$ 含义不变，$h$ 代表判断极长链是否是右链，$hd$ 代表右链的长度的奇偶。  
需要注意的是里面先直接把第一轮的 $G_1$ 做了，实际算的 $g$ 的贡献只涉及了后面的 $x - 1$ 轮。

```cpp
#include<bits/stdc++.h>
#define gc getchar_unlocked
inline int read(int x = 0, int c = gc()) {
   while (! isdigit(c)) c = gc();
   while (isdigit(c)) x = x * 10 + (c ^ 48), c = gc();
   return x;
}
using ll = long long;
constexpr ll mod = 998244353;
constexpr inline ll qpow(ll a, ll b, ll v = 1) {
   while (b) {
      b & 1 && ((v *= a) %= mod), b >>= 1, (a *= a) %= mod;
   }
   return v;
}
constexpr ll inv15 = qpow(15ll, mod - 2), inv3 = qpow(3ll, mod - 2);
constexpr int B = 32768, Z = 32767;
ll pw1[B + 1], pw2[B + 1];
inline void init() {
   for (int i = pw1[0] = 1; i <= B; i++) {
      pw1[i] = (pw1[i - 1] * 4ll) % mod;
   }
   for (int i = pw2[0] = 1; i <= B; i++) {
      pw2[i] = (pw2[i - 1] * pw1[B]) % mod;
   }
}
inline ll pw4(int x) {
   return pw1[x & Z] * pw2[x >> 15] % mod;
}
const int maxn = 5e5 + 10;
int n, q;
int ls[maxn], rs[maxn], f[maxn], g[maxn], h[maxn], hd[maxn];
void dfs(int u) {
   if (! u) return ;
   dfs(ls[u]), dfs(rs[u]);
   g[u] = ! (g[ls[u]] | g[rs[u]]);
   f[u] = f[ls[u]] + f[rs[u]] + g[u];
   h[u] = h[rs[u]] & (! g[ls[u]]);
   hd[u] = h[u] ? g[u] : hd[rs[u]];
}
int main() {
   init();
   n = read(), q = read();
   for (int i = 1; i <= n; i++) ls[i] = read(), rs[i] = read();
   h[0] = 1;
   dfs(1);
   for (int x, u; q--; ) {
      x = read() - 1, u = read();
      ll ans;
      if (! h[u]) {
         ans = 1ll * (f[u] * 2 - (g[u] && hd[u])) * pw4(x) % mod;
         if (g[u] == 0 && x >= 1) {
            (ans += 1ll * (1 + (! hd[u])) * (pw4(x + 1) - pw4(~ x & 1) + mod) * inv15) %= mod;
         }
         if (g[u] == 1 && x >= 2) {
            (ans += 1ll * (1 + (! hd[u])) * (pw4(x) - pw4(x & 1) + mod) * inv15) %= mod;
         }
      } else {
         ans = 1ll * (f[u] * 2 - hd[u]) * pw4(x) % mod;
         (ans += (pw4(x) - 1ll + mod) * inv3) %= mod;
      }
      printf("%lld\n", ans);
   }
   return 0;
}
```

---

## 作者：cryozwq (赞：0)

## subtask 2
读题分，预处理每个点的最大独立集然后分类讨论一下。
## subtask 1，3，4

首先特殊处理 $G_1$ 。

然后考虑从 $G_x$ 到 $G_{x+1}$ 只关心两个点选不选：$G_x$ 的根和最右那个点选不选，如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/z2se4ynu.png)

设 $f_{i,st}$ ，其中 $st=(0/1,0/1)$ 表示这两个点选不选，$G_i$ 的答案。

然后考虑枚举 $G_{x+1}$ 中根节点（包括下方那个），最右边节点的状态即可列出转移式，暴力 dp 即可。

## subtask 5
通过一些贪心的讨论，可以得到一个递推式，矩阵快速幂即可。

## subtask 6

发现结果很大，无法取 $\max$。

可以证明（证明见最下方）如果把每层 $f$ 的取值分成如下几类（记为状态 $1$ 到 $5$）：
- $f_{1,1}$ 严格最大
- $f_{0,0}$ 为最大值之一
- $f_{1,0}$ 严格最大（$f_{1,1}$可以等于 $f_{1,0}$）
- $f_{0,1}$ 严格最大（$f_{1,1}$可以等于 $f_{0,1}$）
- $f_{1,0} $ 和 $f_{0,1}$ 并列最大（$f_{1,1}$可以等于 $f_{0,1}$），

那么从第 $i$ 层到第 $i+1$ 层，发生如下变化： 

- 第 $i$ 层若为状态 $1$ ，下一层为状态 $4$。
- 第 $i$ 层若为状态 $2$ ，下一层为状态 $3$。
- 第 $i$ 层若为状态 $3$ ，下一层为状态 $2$。
- 第 $i$ 层若为状态 $4$ ，下一层为状态 $1$。
- 第 $i$ 层若为状态 $5$ ，下一层为状态 $5$。

容易发现最后一定是 $4$ ，$1$ 间循环或者 $2$ ，$3$ 间或者 $5$ 一直循环，而五种变化是均可以写出一个不带 $\max$ 的递推式的。即可矩乘。

证明：

把每个状态的转移列出来，枚举上一层状态即可解出这层每个状态的最大值，如下图：

```
1：-1 0 -2 -1
2：1 1 2 2
3：0 0 -1 -1
4：-1 0 0 1
5：0 1 1 1
```

验证程序如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
int st[5][4];
const int inf=1e9;
void init(int now,int a,int b,int c,int d){
	st[now][0]=a;st[now][1]=b;st[now][2]=c;st[now][3]=d;
}
int S;
int f1(int a){
	if(a)return max(st[S][0],st[S][1]);
	else return max(max(st[S][0],st[S][1]),max(st[S][2],st[S][3]));
}
int f2(int a,int b){
	int ans=-inf;
	for(int x=0;x<=1;x++){
		for(int y=0;y<=1;y++){
			if(a&&x)continue;
			if(b&&y)continue;
			ans=max(ans,st[S][x*2+y]);
		}
	}
	return ans;
}
int f3(int a){
	if(a)return max(st[S][0],st[S][1]);
	else return max(max(st[S][0],st[S][1]),max(st[S][2],st[S][3]));
} 
int f4(int a,int b){
	int ans=-inf;
	for(int x=0;x<=1;x++){
		for(int y=0;y<=1;y++){
			if(a&&x)continue;
			if(y!=b)continue;
			ans=max(ans,st[S][x*2+y]);
		}
	}
	return ans;
}
int res[4];
int main(){
	init(0,-1,-1,-1,0); 
	init(1,0,0,0,0); 
	init(2,-1,-1,0,0); 
	init(3,-1,0,-1,0); 
	init(4,-1,0,0,0);
	for(int s=0;s<=4;s++){ 
		S=s;
		res[0]=res[1]=res[2]=res[3]=-inf; 
		for(int a=0;a<=1;a++){
			for(int b=0;b<=1;b++){
				for(int c=0;c<=1;c++){ 
					res[a*2+c]=max(res[a*2+c],f1(a)+f2(a,b)+f3(b)+f4(b,c)+a+b);	 
				}
			}
		} 
		cout<<res[0]<<" "<<res[1]<<" "<<res[2]<<" "<<res[3]<<endl; 
	} 
	return 0;
}
```

同时根据上表也得到了了每个状态的递推式（设上一层答案为 $x$）：
 
$1$ 到 $4$：$x=4x$

$2$ 到 $3$：$x=4x+2$

$3$ 到 $2$：$x=4x$

$4$ 到 $1$：$x=4x+1$

$5$ 到 $5$：$x=4x+1$  

或者可以欣赏一下[由 bot 书写的证明](https://www.luogu.com.cn/paste/cpery0mu)。



---


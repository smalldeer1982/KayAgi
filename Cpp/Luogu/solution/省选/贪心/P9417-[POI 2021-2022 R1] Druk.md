# [POI 2021/2022 R1] Druk

## 题目背景

译自 [XXIX Olimpiada Informatyczna – I etap](https://sio2.mimuw.edu.pl/c/oi29-1/dashboard/) [Druk](https://sio2.mimuw.edu.pl/c/oi29-1/p/dru/)。

## 题目描述

给你一个 $n\times m$ 的字符矩形，只含小写英文字母。

你需要制作两块模板，一个是横的（一行 $l$ 列），一个是竖的（$l$ 行一列），$l$ 称为模板长度，上面有完全相同的字符串（从左到右，从上到下，不可翻转）。你需要保证你可以用这两块模板不重不漏地印刷这个字符矩形。

模板的制作方案可能有很多，你只需要输出所有的可行的模板长度即可。

## 说明/提示

样例一解释：![图挂了](https://cdn.luogu.com.cn/upload/image_hosting/2zs08vop.png)

样例四解释：![图挂了](https://cdn.luogu.com.cn/upload/image_hosting/p1zo7v6x.png)

对于所有数据，$1\leq n,m\leq 1000$。

| 子任务编号 | 附加限制 | 分数 |
| :----------: | :----------: | :----------: |
| 1 | $n=1,m\leq 1000$ | 10 |
| 2 | $n\leq 3,m\leq 1000$ | 25 |
| 3 | $n,m\leq 20$ | 20 |
| 4 |  | 45 |

## 样例 #1

### 输入

```
5 8
aabaaaaa
babaabbb
aabaaaaa
aabaaaaa
abaaabaa
```

### 输出

```
1
4
```

## 样例 #2

### 输入

```
1 1000
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
```

### 输出

```
16
1 2 4 5 8 10 20 25 40 50 100 125 200 250 500 1000
```

## 样例 #3

### 输入

```
3 1000
abababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababab
abababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababab
abababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababab
```

### 输出

```
12
2 4 8 10 20 40 50 100 200 250 500 1000
```

## 样例 #4

### 输入

```
4 9
aabaaabaa
babababab
aabaaabaa
abaabaaba
```

### 输出

```
1
3
```

## 样例 #5

### 输入

```
见附件```

### 输出

```
0

```

## 样例 #6

### 输入

```
见附件```

### 输出

```
1
4
```

# 题解

## 作者：kyEEcccccc (赞：6)

考虑枚举长度 $L$：显然 $L | n,L | m$ 必须至少有一条成立，这样的 $L$ 不超过 $d(n) + d(m)$ 种；对于每个 $L$ 只有两种可能的模板串，判定即可。通过对矩阵用 $(i + j)\bmod L$ 为颜色进行染色容易证明这一结论。

如果字符矩阵全同，则唯一的模板串必然合法，这是朴素的。

接下来假设字符矩阵并不全同，我们断言：若某个位置 $(x, y)$ 左方和上方的位置都不存在或已经被填满，且可以以这个位置为起点横向填充，则它必须被横向填充。这一断言基于这样的观察：如果有一种合法方案，$(x, y)$ 被纵向填充，则模板串必须全同，而这与字符矩阵不全同相矛盾。

下面考虑证明：从 $(x, y)$ 开始的 $L$ 个位置恰为模板串，如果它们都被竖着填充，则显然模板串全同；而如果存在一个 $1\le t\le L - 1$，从 $(x, y+t)$ 开始被横向填充，前面都被纵向填充，则 $L-t$ 是模板串的一个 border，根据 border 理论我们知道 $t$ 是模板串的一个（非严格）周期，而前 $t$ 个元素都被纵向填充，显然全同；一个串的周期全同，它必然全同，所以模板串全同。

所以我们得出了这样的做法：枚举模板串以后从上往下、从左往右遍历每个位置，通过字符串哈希判定一个位置是否可以横向覆盖，如果可以直接暴力标记，否则暴力纵向标记，同时判定纵向覆盖是否合法。一个位置不会被标记两次，所以判定的过程总复杂度是 $\mathrm O(nm)$。$1000$ 以内约数个数不会太多，而且判定过程很难跑满，可以通过。

现在给出代码。写的时候发现需要一些神秘处理才能让判定复杂度不退化，但是实在比较简单，大家自己看着办吧。

```cpp
// Author: kyEEcccccc

#include <bits/stdc++.h>

using namespace std;

using LL = long long;
using ULL = unsigned long long;

#define F(i, l, r) for (int i = (l); i <= (r); ++i)
#define FF(i, r, l) for (int i = (r); i >= (l); --i)
#define MAX(a, b) ((a) = max(a, b))
#define MIN(a, b) ((a) = min(a, b))
#define SZ(a) ((int)((a).size()) - 1)

constexpr int N = 1005;
constexpr ULL BS = 1145141;

int n, m;
string s[N];
ULL hsh[N][N], pw_bs[N];

ULL get_hash(int x, int y, int L)
{
	return hsh[x][y + L - 1] - hsh[x][y - 1] * pw_bs[L];
}

bool vis[N][N], nok[N][N];

bool check(int len)
{
	if (n % len != 0 && m % len != 0) return false;

	auto f = [len] (string ss, ULL hh) -> bool
	{
		memset(vis, 0, sizeof (vis));
		memset(nok, 0, sizeof (nok));
		F(i, 1, n) F(j, 1, m)
		{
			if (vis[i][j]) continue;
			if (j + len - 1 <= m && get_hash(i, j, len) == hh && !nok[i][j])
			{
				bool eq = true;
				F(k, 0, len - 1)
				{
					if (vis[i][j + k])
					{
						nok[i][j] = true;
						break;
					}
					if (s[i][j + k] != ss[k])
					{
						eq = false;
						break;
					}
				}
				if (eq)
				{
					if (nok[i][j])
					{
						F(k, 1, len - 1)
						{
							if (vis[i][j + k]) break;
							nok[i][j + k] = true;
						}
					}
					else
					{
						F(k, 0, len - 1) vis[i][j + k] = true;
						continue;
					}
				}
			}
			if (i + len - 1 > n) return false;
			F(k, 0, len - 1)
			{
				if (s[i + k][j] != ss[k]) return false;
				vis[i + k][j] = true;
			}
		}
		return true;
	};

	string x = "";
	ULL h = 0;
	if (len <= m)
	{
		F(i, 1, len) x += s[1][i], h = h * BS + s[1][i];
		if (f(x, h)) return true;
		x = "", h = 0;
	}
	if (len <= n)
	{
		F(i, 1, len) x += s[i][1], h = h * BS + s[i][1];
		if (f(x, h)) return true;
	}
	return false;
}

signed main(void)
{
	// freopen(".in", "r", stdin);
	// freopen(".out", "w", stdout);
	ios::sync_with_stdio(0), cin.tie(nullptr);

	cin >> n >> m;
	F(i, 1, n) cin >> s[i], s[i] = '#' + s[i];

	pw_bs[0] = 1;
	F(i, 1, m) pw_bs[i] = pw_bs[i - 1] * BS;

	F(i, 1, n)
	{
		hsh[i][0] = 0;
		F(j, 1, m) hsh[i][j] = hsh[i][j - 1] * BS + (ULL)s[i][j];
	}

	vector<int> ans;
	F(len, 1, max(n, m)) if (check(len)) ans.push_back(len);

	cout << ans.size() << '\n';
	for (auto x : ans) cout << x << ' ';
	cout << endl;
	
	return 0;
}
```

---

## 作者：Zhao_daodao (赞：3)

# P9417 [POI 2021/2022 R1] Druk

模拟赛 T2，被许多大神爆切！

## Solution

因为本人非常愚钝，所以需要判断。

首先其他题解都说了，$len$ 是 $n$ 的因数，或者是 $m$ 的因数。

所以答案的数量就只有 $d(10^6)\times 2$ 的量级。

考虑一个一个暴力判断。但是这样肯定会超时。

---

首先，判断 $a_{1,1}$ 这个点的选法。

就是，要么从上往下，或者从左往右。

所以对于一个固定的 $len$，一共只有两种可能的模板状态。

直接每一个都搜索一遍。

搜索：从上往下，从左往右。

如果遇到一个点，从来没有被印刷，那么这个点肯定是一个模板的开头。

因为他左边和上面都已经被印刷过了。

直接两个暴力枚举下去，最后所有点都被枚举过就完成了搜索。

这样就通过了本题。

## Code
赛时代码，非常丑陋。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=1e3+5;
int n,m;
char a[MAXN][MAXN];
int cnt[26],ncnt[26];
bool vis[MAXN][MAXN];int siz;
string A;
bool dfs(int x,int y,int len){
	if(siz==n*m)return 1;
	if(x+len-1<=n){
		string now;bool flag=1;
		for(int i=x;i<=x+len-1;i++){
			if(vis[i][y]){flag=0;break;}
			now.push_back(a[i][y]);
		}
		if(flag&&now==A){
			siz+=len;
			for(int i=x;i<=x+len-1;i++)vis[i][y]=1;
			int xx=x,yy=y+1;
			while(siz<n*m&&(vis[xx][yy]||xx>n||yy>m)){
				if(yy<m)yy++;else xx++,yy=1;
			}
			int nowans=dfs(xx,yy,len);
			siz-=len;
			for(int i=x;i<=x+len-1;i++)vis[i][y]=0;
			if(nowans)return 1;
		}
	}
	if(y+len-1<=m){
		string now;bool flag=1;
		for(int i=y;i<=y+len-1;i++){
			if(vis[x][i]){flag=0;break;}
			now.push_back(a[x][i]);
		}
		if(flag&&now==A){
			siz+=len;
			for(int i=y;i<=y+len-1;i++)vis[x][i]=1;
			int xx=x,yy=y+1;
			while(siz<n*m&&(vis[xx][yy]||xx>n||yy>m)){
				if(yy<m)yy++;else xx++,yy=1;
			}
			int nowans=dfs(xx,yy,len);
			siz-=len;
			for(int i=y;i<=y+len-1;i++)vis[x][i]=0;
			if(nowans)return 1;
		}
	}
	return 0;
}
inline bool check(int len){
	int tim=n*m/len;
	if(n>=len){
		A.clear();
		for(int i=0;i<26;i++)ncnt[i]=0;
		for(int i=1;i<=len;i++)A+=a[i][1],ncnt[a[i][1]-'a']++;
		bool flag=1;
		for(int i=0;i<26;i++)if(ncnt[i]!=(cnt[i]/tim))flag=0;
		if(flag&&dfs(1,1,len)){
			return 1;
		}
	}
	if(m>=len){
		A.clear();
		for(int i=0;i<26;i++)ncnt[i]=0;
		for(int i=1;i<=len;i++)A+=a[1][i],ncnt[a[1][i]-'a']++;
		bool flag=1;
		for(int i=0;i<26;i++)if(ncnt[i]!=(cnt[i]/tim))flag=0;
		if(flag&&dfs(1,1,len)){
			return 1;
		}
	}
	return 0;
}
signed main(){
	cin.tie(0);
	cout.tie(0);
	ios::sync_with_stdio(false);
	cin>>n>>m;
	for(int i=1;i<=n;i++)for(int j=1;j<=m;j++)cin>>a[i][j],cnt[a[i][j]-'a']++;
	int tim=n*m;
	for(int i=0;i<26;i++)if(cnt[i]){
		tim=__gcd(tim,cnt[i]);
	}
	if(tim==n*m){
		set<int>s;
		for(int i=1;i<=n;i++)if(n%i==0)s.insert(i);
		for(int i=1;i<=m;i++)if(m%i==0)s.insert(i);
		cout<<s.size()<<"\n";
		for(auto it=s.begin();it!=s.end();it++)cout<<(*it)<<" ";
		cout<<"\n";
		return 0;
	}
	vector<int>ans;
	for(int i=1;i<=tim;i++)if(tim%i==0){
		int res=n*m/(tim/i);
		if(res>max(n,m))break;
		if(check(res))ans.push_back(res);
	}
	cout<<ans.size()<<"\n";
	for(int i:ans)cout<<i<<" ";
	cout<<"\n";
}
```

---

## 作者：qnqfff (赞：2)

赛时莫名奇妙挂了，赛后重构一发过，怎么会是呢。

### 思路

容易发现长度 $L\mid n$ 或 $L\mid m$，证明就考虑把点 $(i,j)$ 染成 $(i+j)\bmod L$，那么合法的条件之一就是每种颜色出现次数相同，如果 $L\nmid n$ 且 $L\nmid m$，则该条件一定不满足。

于是可以枚举 $L$，容易发现模板串要么是 $s_{1,1}s_{1,2}...s_{1,L}$ 要么是 $s_{1,1}s_{2,1}...s_{L,1}$。

考虑如何填，从上往下，从左往右考虑以这个位置为开头，发现优先向右填一定不劣，证明如下：

设当前位置为 $(i,j)$，可以向右边也可以向下，若当前向下，那么设 $(i,j),(i,j+1),...,(i,j+x-1)$ 都是向下填的，$(i,j+x)$ 向右填，则模板串前 $x$ 个字符相同，而且 $s_{i,j+x}s_{i,j+x+1}...s_{i,j+L-1}$ 是模板串的一个 border，于是可以知道 $s_{i,j}s_{i,j+1}...s_{i,j+x-1}$ 是模板串的一个周期，所以模板串全部相同，所以这种情况向右填没有问题。

然后直接填即可，判断能否填可以使用哈希。

### 代码

```cpp
#include<bits/stdc++.h>
#define int long long
const int B=23,mod=1e9+7;
using namespace std;
int read(){int p=0,flg=1;char c=getchar();while(c<'0'||c>'9'){if(c=='-') flg=-1;c=getchar();}while(c>='0'&&c<='9'){p=p*10+c-'0';c=getchar();}return p*flg;}
int n,m,pw[1010],hs[1010][1010],_hs[1010][1010],vis[1010][1010];char mp[1010][1010];
signed main(){
	n=read();m=read();for(int i=1;i<=n;i++) for(int j=1;j<=m;j++) cin>>mp[i][j];
	pw[0]=1;for(int i=1;i<=max(n,m);i++) pw[i]=pw[i-1]*B%mod;for(int i=1;i<=n;i++) for(int j=1;j<=m;j++) hs[i][j]=(hs[i][j-1]*B%mod+mp[i][j])%mod,_hs[i][j]=(_hs[i-1][j]*B%mod+mp[i][j])%mod;
	auto get=[&](int i,int l,int r){return (hs[i][r]-hs[i][l-1]*pw[r-l+1]%mod+mod)%mod;};
	auto _get=[&](int i,int l,int r){return (_hs[r][i]-_hs[l-1][i]*pw[r-l+1]%mod+mod)%mod;};
	auto check=[&](int L,int H){
		for(int i=1;i<=n;i++) for(int j=1;j<=m;j++) vis[i][j]=0;
		for(int i=1;i<=n;i++) for(int j=1;j<=m;j++) if(!vis[i][j]){
			if(j+L-1<=m&&get(i,j,j+L-1)==H){bool flg=0;for(int k=j;k<=j+L-1;k++) flg|=vis[i][k];if(!flg){for(int k=j;k<=j+L-1;k++) vis[i][k]=1;continue;}}
			if(i+L-1<=n&&_get(j,i,i+L-1)==H){bool flg=0;for(int k=i;k<=i+L-1;k++) flg|=vis[k][j];if(!flg){for(int k=i;k<=i+L-1;k++) vis[k][j]=1;continue;}}
			return 0;
		}return 1;
	};
	vector<int>ans;for(int L=1;L<=max(n,m);L++) if(!(n%L)||!(m%L)){
		bool flg=0;if(L<=m) flg|=check(L,get(1,1,L));
		if(L<=n) flg|=check(L,_get(1,1,L));if(flg) ans.push_back(L);
	}cout<<ans.size()<<'\n';for(auto i:ans) cout<<i<<' ';
	return 0;
}
```

---

## 作者：_Cheems (赞：2)

牛子题，刚开始还以为不可做，看了题解恍然大悟。那我也写一篇帮助后人理解。

首先枚举模板长度 $len$，直觉告诉我们不用枚举太多无用长度。

结论 $1$：不考虑字母，$len\mid n$ 或 $len\mid m$ 是能够完全填充的充要条件。

证明：充分性易证，下面证必要性。考虑 $len\nmid n$ 的情况，将列分为若干个大小为 $len$ 的组，如 $[1,len]$、$[len+1,2len]\dots$。

每一列都要满足覆盖它的横着的模板串数量是 $ilen+c$ 的，其中 $c= n\bmod len$。

然后对于 $[1,len]$ 这一组，显然只能由 $ilen+c$ 个起点在第一列的横着的模板串覆盖。再考虑 $[len+1,2len]$ 这一组，因为不能破坏前一组的覆盖方案，所以跨过 $[1,len]$ 和 $[len+1,2len]$ 组的横着的模板串数量只能是 $jlen$ 个。所以 $[len+1,2len]$ 组只能由 $klen+c$ 的起点在第 $len+1$ 的横着的模板串覆盖。

以此类推，就不可能出现 $len\nmid m$ 的情况，即最后一组 $[plen+1,m]$ 的大小不为 $len$。否则，无法同时满足不破坏先前的覆盖方案且最后一组均被覆盖的要求。
 
（感觉不太严谨而且繁琐了些，应该有更好的证明）。
 
再考虑怎么判定。

结论 $2$：从上到下，从左到右填充。若某一时刻即可以向下，又可以向右，则必定向右填。

证明：在前 $[1,p]$ 向下填充，$[p+1,len]$ 向右填充，接下来证 $p=0$ 即可。

$[1,p]$ 部分：因为是向下填充，首字母一样，所以$[1,p]$ 全同。

$[p+1,len]$ 部分：后半部分可得 $[p+1,len]=[1,len-p]$，构成 $\rm border$ 的形式，所以 $[1,p]$ 是模板串的周期。

综上所述，模板串全同。而我们是用模板串填充矩阵，所以矩阵全同，此时向右向下都无所谓了。

故一般情况下只能有 $p=0$，即优先向右填充。

于是变成纯纯模拟题。
#### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;

const int N = 1e3 + 5;
const int base = 1331, _base = 13331, mod = 998244353, _mod = 19260817;
int n, m, len, ans[N], cnt;
int X[N][N], Y[N][N], bas[N], K;
int _X[N][N], _Y[N][N], _bas[N], _K;
char c[N][N]; 
bool vis[N][N];

inline int H(int x, int y) {return (y + len - 1 > m) ? -1 : (1ll * (1ll * X[x][y + len - 1] - 1ll * X[x][y - 1] * bas[len] % mod + mod) % mod);}
inline int L(int x, int y) {return (x + len - 1 > n) ? -1 : (1ll * (1ll * Y[x + len - 1][y] - 1ll * Y[x - 1][y] * bas[len] % mod + mod) % mod);}
inline int _H(int x, int y) {return (y + len - 1 > m) ? -1 : (1ll * (1ll * _X[x][y + len - 1] - 1ll * _X[x][y - 1] * _bas[len] % _mod + _mod) % _mod);}
inline int _L(int x, int y) {return (x + len - 1 > n) ? -1 : (1ll * (1ll * _Y[x + len - 1][y] - 1ll * _Y[x - 1][y] * _bas[len] % _mod + _mod) % _mod);}
inline bool No_H(int x, int y) {if(y + len - 1 > m) return false; for(int i = y; i < y + len; ++i) if(vis[x][i]) return false; return true;}
inline bool No_L(int x, int y) {if(x + len - 1 > n) return false; for(int i = x; i < x + len; ++i) if(vis[i][y]) return false; return true;}
inline bool check(){
	memset(vis, 0, sizeof vis);
	for(int i = 1; i <= n; ++i)
		for(int j = 1; j <= m; ++j){
			if(vis[i][j]) continue;
			if(No_H(i, j) && H(i, j) == K && _H(i, j) == _K)
				for(int p = j; p < j + len; ++p) vis[i][p] = true;
			else if(No_L(i, j) && L(i, j) == K && _L(i, j) == _K)
				for(int p = i; p < i + len; ++p) vis[p][j] = true;
			else return false;
		}
	return true;
}
signed main(){
	bas[0] = _bas[0] = 1;
	for(int i = 1; i < N; ++i) bas[i] = 1ll * bas[i - 1] * base % mod, _bas[i] = 1ll * _bas[i - 1] * _base % _mod;
	cin >> n >> m; 
	for(int i = 1; i <= n; ++i) scanf("%s", c[i] + 1);
	for(int i = 1; i <= n; ++i)
		for(int j = 1; j <= m; ++j){
			X[i][j] = (1ll * X[i][j - 1] * base + c[i][j]) % mod, Y[i][j] = (1ll * Y[i - 1][j] * base + c[i][j]) % mod;
			_X[i][j] = (1ll * _X[i][j - 1] * _base + c[i][j]) % _mod, _Y[i][j] = (1ll * _Y[i - 1][j] * _base + c[i][j]) % _mod;
		}
	for(int i = 1; i <= max(n, m); ++i){
		if(n % i && m % i) continue;
		len = i, K = H(1, 1), _K = _H(1, 1);
		if(K != -1 && check()) ans[++cnt] = i;
		else{
			K = L(1, 1), _K = _L(1, 1);
			if(K != -1 && check()) ans[++cnt] = i;
		}
	}
	printf("%d\n", cnt);
	for(int i = 1; i <= cnt; ++i) printf("%d ", ans[i]);
	return 0;
}
```

---

## 作者：晴空一鹤 (赞：2)

大家好，这是一道喵喵题，建议多想想再来看题解。

首先我们考虑一个特殊情况，也就是所有格子都是一个字母，那只需要考虑是不是能被完美覆盖就行了。

显然在 $l\mid n$ 或 $l\mid m$ 时是有解的。事实上这也是必要的，严谨证明可以在其他题解找到，这里给出一个感性解释：我们考虑第一行的覆盖情况，是若干横条加若干竖条（全是竖条消掉递归），那么这些横条所对应的列一定会在同一位置齐平，而旁边的竖条只有在 $l$ 倍数时才会与横条齐平，因此只有  $l\mid n$ 或 $l\mid m$ 时可以完整覆盖这个矩形。

考虑多个字符的情况，对于 $(1,1)$ 只有两种覆盖方式，因此只有两种可能。直接枚举得到的字符串，从左上到右下进行覆盖，对于一个未染色的格子，先试一下往下染，不行就往右染，再不行就直接无解。

为什么这样保证能在合法时找到一组解呢？考虑一个格子若又能往下又能往右染实际上一定是无解的，因为你染了一边之后另一边的格子只能作为开头，而矩阵又必然存在不同字符，所以另一边必然染不了，无解了。

实现还是很容易的，这可是喵喵题呀。

---

## 作者：kkxacj (赞：2)

#### 前言

模拟赛考的，看可以交题解就写了。

#### 思路

首先一个很显然的是 $L$ 必须是 $n\times m$ 的约数，因为每次印刷会减少 $L$ 个空位，所以只有 $L$ 是 $n\times m$ 的约数时才能恰好填完。

然后考虑对于满足上述条件的 $L$ 是否合法，只需要贪心的将能横着放的横着放，能竖着放的竖着放，都能就随便选一种放，最后看是否有空位就行了，考虑如何证明。

先抛开字符全相等的情况，因为这种情况只要 $L$ 是 $n\times m$ 的约数一定行。

对于其他情况，我们对于每个字符从它开始覆盖，若它只能被横着或只能被竖着覆盖，那就尝试覆盖就行了。否则就像下面这种情况

![](https://cdn.luogu.com.cn/upload/image_hosting/velw7h19.png)

会发现，由于**抛开了字符全相等的情况**，如果我横着放，则下面的**一定不能全横着放**，因为一定会有一个字符与模板开头不一样，同时也**一定不能全竖着放**，全竖着放等同于要证明 $\left[1,len-1\right] = \left[2,len\right]$ 且字符不能全相等，显然无解，竖着放同理，在实现是我们可以不管，因为这种情况一定会有字符没被覆盖到。

所以这样贪心就可以证明是正确的了。

**code**

```cpp
#include<bits/stdc++.h>
using namespace std;
namespace IO
{
	template<typename T>
	void read(T &_x){_x=0;int _f=1;char ch=getchar();while(!isdigit(ch)) _f=(ch=='-'?-1:_f),ch=getchar();while(isdigit(ch)) _x=_x*10+(ch^48),ch=getchar();_x*=_f;}
	template<typename T,typename... Args>
	void read(T &_x,Args&...others){Read(_x);Read(others...);}
	const int BUF=20000000;char buf[BUF],to,stk[32];int plen;
	#define pc(x) buf[plen++]=x
	#define flush(); fwrite(buf,1,plen,stdout),plen=0;
	template<typename T>inline void print(T x){if(!x){pc(48);return;}if(x<0) x=-x,pc('-');for(;x;x/=10) stk[++to]=48+x%10;while(to) pc(stk[to--]);}
}
using namespace IO;
const int N = 1010;
int n,m,sum,st[N],o,v[N][N],l;
char a[N][N],b[N];
inline bool ok(int len)
{
	for(int i = 1;i <= n;i++)
		for(int j = 1;j <= m;j++)
			v[i][j] = 0;
	for(int i = 1;i <= n;i++)
		for(int j = 1;j <= m;j++)
		{
			if(v[i][j]) continue;
			if(j+len-1 <= m)
			{
				int l = 0;
				for(int z = 1;z <= len;z++)
					if(a[i][j+z-1] != b[z] || v[i][j+z-1])
					{
						l = 1;
						break;
					}
				if(!l) for(int z = 1;z <= len;z++) v[i][j+z-1] = 1;
			}
			if(v[i][j]) continue;
			if(i+len-1 <= n)
			{
				int l = 0;
				for(int z = 1;z <= len;z++)
					if(a[i+z-1][j] != b[z] || v[i+z-1][j])
					{
						l = 1;
						break;
					}
				if(!l) for(int z = 1;z <= len;z++) v[i+z-1][j] = 1;
			}
			if(!v[i][j]) return 0;
		}
	return 1;
}
signed main()
{
//	freopen("print.in","r",stdin);
//	freopen("print.out","w",stdout);
	read(n),read(m); o = max(n,m);
	for(int i = 1;i <= n;i++)
		for(int j = 1;j <= m;j++)
			cin>>a[i][j];
	for(int i = 1;i <= o;i++)
		if(n*m%i==0)
		{
			l = 0;
			if(i <= m)
			{
				for(int j = 1;j <= i;j++) b[j] = a[1][j];
				l = ok(i);
			}
			if(i <= n && !l)
			{
				for(int j = 1;j <= i;j++) b[j] = a[j][1];
				l = ok(i);
			}
			if(l) sum++,st[sum] = i;
		}
	print(sum),pc('\n'); 
	for(int i = 1;i <= sum;i++) print(st[i]),pc(' ');
	flush();
	return 0;
}//千山万水总是情，不要挂分行不行 
```

---

## 作者：tbdsh (赞：1)

# P9417 [POI 2021/2022 R1] Druk 题解
## 题意简述
[题目传送门](/problem/p9417)

[更好的阅读体验](/article/dbf9owae)

给定 $n\times m$ 的只有小写字母的矩阵。你需要指定一个长度为 $L$ 的字符串并将它分别变为 $1\times L$ 和 $L\times 1$ 的字符矩阵。问有多少个 $L$ 使得存在长度为 $L$ 的字符串变为字符矩阵后能够不重不漏的覆盖整个矩阵。

## 分析
首先可以注意到，$L$ 可以成为答案的前提条件是 $L\mid n$ 或 $L\mid m$，这样就决定了答案的 $L$ 不超过 $\sqrt {\max(n,m)}\approx 31$ 个，可以暴力枚举。

同时，我们枚举的模式串的第一个字符一定是第一行第一列的字符，且枚举的模式串必定在第一行或第一列出现过，否则第一行和第一列就无法被匹配。

那么，可能的答案串最多就只有 $2\times \sqrt {\max(n,m)}\approx 62$ 个了，同样也是很小的。

接下来考虑对于每个模式串如何判断能否覆盖整个矩阵。

首先如果整个矩阵只有一种字符，那么满足 $L\mid n$ 或 $L\mid m$ 的所有 $L$ 都可以成为答案。

对于其他情况，我们以下方 $3\times 4$ 的字符矩阵举例：
```txt
klkl
kklk
lkll
```

当模式串为 `kl` 时，对于第一行第三列的字符 `k`，它既可以向右匹配，也可以向下匹配。

但我们注意到，如果向下匹配，第一行第四列的字符 `l` 将无法被匹配。

因此，在这个示例中，我们可以发现当模式串可以同时向右和向下匹配时，向右匹配一定不会更劣。

这个结论可以推广到一般情况，这里给出一个较为感性的证明：

由于我们是从上往下一行一行进行匹配，当模式串可以在当前位置向右匹配时，此时显然右边的字符串不存在上方匹配下来的可能。此时，若右边的字符串本身不能与模式串匹配，那么模式串在当前位置向右匹配一定是不劣的。否则右边的字符串将有可能无法完成匹配。

有了这个结论的支撑，接下来只要按照做法模拟即可。

时间复杂度为 $O(n\times m)$。

## Code
```cpp
#include<bits/stdc++.h>
#define QWQ

using namespace std;
const int MAXN = 1005;
int n, m;
string s[MAXN];
vector<int> ans;
inline void print(){
  sort(ans.begin(), ans.end());
  ans.erase(unique(ans.begin(), ans.end()), ans.end());
  cout << ans.size() << '\n';
  for (auto v : ans){
    cout << v << ' ';
  }
}
bool vis[MAXN][MAXN];
bool check(string t){
  int T = t.size();
  t = ' ' + t;
  for (int i = 1; i <= n; i++){
    for (int j = 1; j <= m; j++){
      vis[i][j] = 0;
    }
  }
  int CNT = 0;
  for (int i = 1; i <= n; i++){
    for (int j = 1; j <= m; j++){
      if (!vis[i][j] && j + T - 1 <= m){
        bool f = 1;
        for (int k = j; k < j + T && f; k++){
          if (vis[i][k] || s[i][k] != t[k - j + 1]){
            f = 0;
          }
        }
        if (f){
          for (int k = j; k < j + T; k++){
            vis[i][k] = 1;
            CNT++;
          }
        }
      }
      if (!vis[i][j] && i + T - 1 <= n){
        bool f = 1;
        for (int k = i; k < i + T && f; k++){
          if (vis[k][j] || s[k][j] != t[k - i + 1]){
            f = 0;
          }
        }
        if (f){
          for (int k = i; k < i + T; k++){
            vis[k][j] = 1;
            CNT++;
          }
        }
      }
    }
  }
  return CNT == n * m;
}
signed main(){
  ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
  #ifndef QWQ
  freopen("print.in", "r", stdin);
  freopen("print.out", "w", stdout);
  #endif
  cin >> n >> m;
  for (int i = 1; i <= n; i++){
    cin >> s[i];
    s[i] = ' ' + s[i];
  }
  for (int i = 1; i <= n; i++){
    if (n % i == 0 || m % i == 0){
      string s;
      for (int k = 1; k <= i; k++){
        s.push_back(::s[k][1]);
      }
      if (check(s)){
        ans.push_back(i);
      }
    }
  }
  for (int i = 1; i <= m; i++){
    if (m % i == 0 || n % i == 0){
      string s;
      for (int k = 1; k <= i; k++){
        s.push_back(::s[1][k]);
      }
      if (check(s)){
        ans.push_back(i);
      }
    }
  }
  print();
  return 0;
}
```

---

## 作者：shinkuu (赞：1)

挺简单的。

首先观察到合法的 $l$ 不多，因为一定有 $l|n$ 或 $l|m$，远少于 100 个，于是如果可以在 $O(nm)$ 的复杂度内判断一个 $l$ 是否合法就行了。

但是此时我们只知道了 $l$ 而不知道这个模板长什么样。怎么办呢？对于这种“找出一个满足若干个限制的东西”的问题，一般有一个方法是找到一种一个限制来缩小这个东西可能的范围。

具体地，对于这一题，考虑 $(1,1)$ 这个位置，要不 $(1,1)$ 到 $(1,l)$ 是一个模板，要不 $(1,1)$ 到 $(l,1)$ 是一个模板。只有这两种模板是可能可行的。于是只用判断这两种。

然后考虑一行一行枚举，如果有没填的位置 $(x,y)$ 就以它为模板的一端，填上一个模板，填完了再到下一行。此时会出现一个问题：如果一个位置既可以横着填又可以竖着填怎么办？事实上，此时一定是横着填。

为什么？首先如果模板内字符全部相同显然可以。否则，不妨设当前位置的元素 $S_{x,y}=a$，考虑模板中第一个不为 $a$ 的位置 $i$，则若这里竖着填，$S_{x+i-1,y}$ 一定无法被满足，因为它上面一排已经被填满，左边距离它最近的填了的格子也不足以横着填一个模板。

于是对于每个位置这样暴力判断即可。暴力判断可行的原因是，对于一个没填的位置，要不以 $O(l)$ 的时间代价填上 $l$ 个位置，要不判断无解直接 return，均摊是 $O(1)$ 的。总复杂度 $O(nmd(n))$。

code：

```cpp
int n,m,a[N][N],b[N];
bool vis[N][N];
char s[N];
vector<int> ans;
bool check1(int x,int y,int l){
	rep(i,y,y+l-1){
		if(vis[x][i]||a[x][i]!=b[i-y+1]||i>m){
			return 0;
		}
	}
	return 1;
}
bool check2(int x,int y,int l){
	rep(i,x,x+l-1){
		if(vis[i][y]||a[i][y]!=b[i-x+1]||i>n){
			return 0;
		}
	}
	return 1;
}
bool check(int l){
	mems(vis,0);
	rep(i,1,n){
		rep(j,1,m){
			if(vis[i][j]){
				continue;
			}
			if(check1(i,j,l)){
				rep(k,j,j+l-1){
					vis[i][k]=1;
				}
			}else if(check2(i,j,l)){
				rep(k,i,i+l-1){
					vis[k][j]=1;
				}
			}else{
				return 0;
			}
		}
	}
	return 1;
}
void Yorushika(){
	read(n,m);
	rep(i,1,n){
		scanf("%s",s+1);
		rep(j,1,m){
			a[i][j]=s[j]-'a';
		}
	}
	rep(l,1,max(n,m)){
		if(n%l&&m%l){
			continue;
		}
		if(l<=m){
			rep(i,1,l){
				b[i]=a[1][i];
			}
			if(check(l)){
				ans.eb(l);
				continue;
			}
		}
		if(l<=n){
			rep(i,1,l){
				b[i]=a[i][1];
			}
			if(check(l)){
				ans.eb(l);
			}
		}
	}
	printf("%d\n",(int)ans.size());
	for(int i:ans){
		printf("%d ",i);
	}
}
signed main(){
	int t=1;
	//read(t);
	while(t--){
		Yorushika();
	}
}
```

---

## 作者：NATO (赞：1)

【数据删除】sol

（下设字符矩形为 $s$）

考虑哪些长度可能成为答案。

经过观察，可以发现一个长度 $len$ 是合法的则必然有 $len\mid n$ 或 $len\mid m$，证明如下：

考虑对矩形染色，将一个点 $(i,j)$ 染为 $(i+j)\bmod len$，则一次覆盖必然是覆盖掉了颜色为 $0,1,...,len-1$ 的点各一个，则染色后的矩形每种颜色出现次数必须相同。

考虑若 $len\nmid n$ 的同时有 $len\nmid m$，则每行有 $m\bmod len$ 个颜色多了一次，则每 $len$ 行每个颜色就同时多了 $m\bmod len$ 次，而由于 $len\nmid n$，故必然每个颜色不是同时多了一定的次数，故此时每种颜色出现次数并不相同，故若 $len\nmid n$ 成立则必有 $len\mid m$。

若 $len\nmid m$ 成立则必有 $len\mid n$ 的证明同上。

故一个长度 $len$ 是合法的则必然有 $len\mid n$ 或 $len\mid m$。

枚举 $len$，考虑如何 check。

模板显然必须是从 $s_{1,1}s_{1,2}...s_{1,len}$ 或 $s_{1,1}s_{2,1}...s_{len,1}$。

考虑我们从左往右，从上往下地枚举某个位置作为填充模板的开头。

若无法填充，由于矩形必须填充完，故显然无解；

若只能往下或往右，直接填充即可；

若同时能，我们断言往右填充必然是不劣的，证明如下：

假设现在枚举的位置是 $(i,j)$，若当前向下填充，考虑 $(i,j+1),...(i,j+len-1)$ 是如何被填充的。

若它们均是向下填充掉的，则说明模板串每个字符全同，显然有解则必然矩形全同，这样填显然没有问题。

否则，若在 $(i,j),(i,j+1),...,(i,j+t-1)$ 这些位置是向下填充掉的，后面是向右填充的，则说明模板串前 $t$ 个字符是全同的，而由于后面 $(i,j+t)$ 开始是被向右填充的，之前 $(i,j)$ 开始也是可以向右填充的，故 $s_{i,j+t}s_{i,j+t+1}...s_{i,j+len-1}$ 是模板串的一个 border。

根据刚才的那个 border 我们可以知道 $s_{i,j}s_{i,j+1}...s_{i,j+t-1}$ 是模板串的一个周期，故模板串仍然全同！

所以这种情况仍然是有解则必然矩形全同的，这样填显然没有问题。

证毕。

故枚举模板串后直接按上述方法填即可，判断是否是模板串直接 $O(len)$ 暴力判断即可，因为每次必然有 $len$ 个位置被填充，而一共有 $n\times m$ 个位置，故这样 check 单次时间复杂度是 $O(nm)$ 的。

总时间复杂度 $O((d(n)+d(m))nm)$（$d(x)$ 为 $x$ 的因数个数），可以通过本题。

#### 参代码考：


```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll n,m;
char s[1005][1005],ss[1005];
bool vis[1005][1005];
set<ll>val;
vector<ll>ans;
bool check(ll len)
{
	memset(vis,0,sizeof(vis));
	for(ll i=1;i<=n;++i)
		for(ll j=1;j<=m;++j)
		{
			if(vis[i][j])continue;
			if(j+len-1<=m)
			{
				bool ok=1;
				for(ll k=j;k<=j+len-1;++k)
					if(ss[k-j+1]!=s[i][k]||vis[i][k])
					{
						ok=0;break;
					}
				if(ok)for(ll k=j;k<=j+len-1;++k)vis[i][k]=1;
			}
			if(vis[i][j])continue;
			if(i+len-1<=n)
			{
				bool ok=1;
				for(ll k=i;k<=i+len-1;++k)
					if(ss[k-i+1]!=s[k][j]||vis[k][j])
					{
						ok=0;break;
					}
				if(ok)for(ll k=i;k<=i+len-1;++k)vis[k][j]=1;
			}
			if(vis[i][j])continue;
			return 0;
		}
	return 1;
}
int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);cout.tie(0);
	cin>>n>>m;
	for(ll i=1;i<=n;++i)
		for(ll j=1;j<=m;++j)
		cin>>s[i][j];
	for(ll i=1;i<=n;++i)if(n%i==0)val.insert(i);
	for(ll i=1;i<=m;++i)if(m%i==0)val.insert(i);
	for(auto len:val)
	{
		bool ok=0;
		if(len<=m)
		{
			for(ll i=1;i<=len;++i)ss[i]=s[1][i];
			ok|=check(len);
		}
		if(len<=n)
		{
			for(ll i=1;i<=len;++i)ss[i]=s[i][1];
			ok|=check(len);
		}
		if(ok)ans.emplace_back(len);
	}
	cout<<ans.size()<<'\n';
	for(auto it:ans)cout<<it<<' ';
    return 0;
}
```

---

## 作者：liuzhenhao09 (赞：1)

首先枚举长度，通过简单数学知识可得 $len \mid n$ 或 $len \mid m$。

其次枚举第一个格子上的模板是横着的还是竖着的，这样只有两种可能。

然后枚举每个点，判断能否横着竖着放。如果都不行则返回此长度无解，如果都行就选择横着的放，否则就选择能放的那个放。事实证明这是个真理。

然后直接双哈希判一下字符串，树状数组判一下模板是否交叉。

复杂度 $O(nm\operatorname{d}(n)\log n)$。

（随便胡的，没想到和标程一个道理，比某些爆搜做法靠谱。）

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int base = 1e8 + 7,MOD1 = 1e9 + 7,MOD2 = 998244353;
int n,m,tot = 0;
bool flag;
int ans[1000010];
int faca[1000010],facb[1000010],hsh1a[1010][1010],hsh1b[1010][1010],hsh2a[1010][1010],hsh2b[1010][1010];
int bit[1010][1010];
int LSB(int i){
	return i & (-i);
}
void upd(int i,int j,int k){
	while(j <= m){
		bit[i][j] += k;
		j += LSB(j);
	}
}
int psq(int i,int j){
	int res = 0;
	while(j){
		res += bit[i][j];
		j -= LSB(j);
	}
	return res;
}
int rowa(int i,int l,int r){
	return (hsh1a[i][r] - hsh1a[i][l - 1] * faca[r - l + 1] % MOD1 + MOD1) % MOD1;
}
int rowb(int i,int l,int r){
	return (hsh1b[i][r] - hsh1b[i][l - 1] * facb[r - l + 1] % MOD2 + MOD2) % MOD2;
}
int cola(int i,int l,int r){
	return (hsh2a[r][i] - hsh2a[l - 1][i] * faca[r - l + 1] % MOD1 + MOD1) % MOD1;
}
int colb(int i,int l,int r){
	return (hsh2b[r][i] - hsh2b[l - 1][i] * facb[r - l + 1] % MOD2 + MOD2) % MOD2;
}
char a[1010][1010];
bool vis[1010][1010];
bool get(int len,int xa,int xb){
	for(int i = 1; i <= n; i++) for(int j = 1; j <= m; j++) vis[i][j] = 0,bit[i][j] = 0;
	for(int i = 1; i <= n; i++){
		for(int j = 1; j <= m; j++){
			if(!vis[i][j]){
				int valra = -1,valrb = -1,valca = -1,valcb = -1;
				if(j + len - 1 <= m && psq(i,j + len - 1) - psq(i,j - 1) == 0){
					valra = rowa(i,j,j + len - 1);
					valrb = rowb(i,j,j + len - 1);
				}
				if(i + len - 1 <= n){
					valca = cola(j,i,i + len - 1);
					valcb = colb(j,i,i + len - 1);
				}
				if((valra != xa || valrb != xb) && (valca != xa || valcb != xb)) return 0;
				if(valra == xa && valrb == xb){
					for(int x = 1; x <= len; x++) vis[i][j + x - 1] = 1,upd(i,j + x - 1,1);
				}
				if(valca == xa && valcb == xb && (valra != xa || valrb != xb)){
					for(int x = 1; x <= len; x++) vis[i + x - 1][j] = 1,upd(i + x - 1,j,1);
				}
			}
		}
	}
}
bool check(int len){
	if(flag) return 1;
	if(get(len,rowa(1,1,len),rowb(1,1,len)) || get(len,cola(1,1,len),colb(1,1,len))) return 1;
	else return 0;
}
signed main(){
	scanf("%lld %lld",&n,&m);
	flag = 1;
	char c = 'A';
	for(int i = 1; i <= n; i++){
		string s;
		cin>>s;
		for(int j = 1; j <= m; j++){
			a[i][j] = s[j - 1];
			if(c == 'A') c = a[i][j];
			else if(c != a[i][j]) flag = 0;
		}
	}
	faca[0] = 1,facb[0] = 1;
	for(int i = 1; i <= n * m; i++){
		faca[i] = (faca[i - 1] * base) % MOD1;
		facb[i] = (facb[i - 1] * base) % MOD2;
	}
	for(int i = 1; i <= n; i++){
		hsh1a[i][0] = hsh1b[i][0] = 0;
		for(int j = 1; j <= m; j++){
			hsh1a[i][j] = (hsh1a[i][j - 1] * base + (a[i][j] - 'a' + 1)) % MOD1;
			hsh1b[i][j] = (hsh1b[i][j - 1] * base + (a[i][j] - 'a' + 1)) % MOD2;
		}
	}
	for(int i = 1; i <= m; i++){
		hsh2a[0][i] = hsh2b[0][i] = 0;
		for(int j = 1; j <= n; j++){
			hsh2a[j][i] = (hsh2a[j - 1][i] * base + (a[j][i] - 'a' + 1)) % MOD1;
			hsh2b[j][i] = (hsh2b[j - 1][i] * base + (a[j][i] - 'a' + 1)) % MOD2;
 		}
	}
	for(int i = 1; i <= max(n,m); i++){
		if(n % i == 0 || m % i == 0){
			if(check(i)) ans[++tot] = i;
		}
	}
	printf("%lld\n",tot);
	for(int i = 1; i <= tot; i++) printf("%lld ",ans[i]);
	return 0;
} 
```

---

## 作者：sidekick257 (赞：1)

$len$ 必须是 $n$ 或 $m$ 的因数，证明看其他题解。

考虑写一个 $O(nm)$ 的 ```check``` 就做完了。

全部字符相同特判掉。

我们钦定左上角放了一个横着的模板串。

不妨设模板串第一个字符为 ```a```，第一个不是 ```a``` 的字符为 ```b```。

那么我们从上到下找到第一列的所有没被打印过的 ```b```，每找到一个直接在这里打印一个竖着的模板串（因为横着打印打印不出 ```b```）。

这一列的其余的所有没被打印的位置都必须横着打印模板串。

递归接下来的每一列即可，如果打印的时候发现和目标不一样了或者这个地方已经被打印过了证明此模板串不合法。

---


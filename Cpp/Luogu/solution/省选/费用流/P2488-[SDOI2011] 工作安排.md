# [SDOI2011] 工作安排

## 题目描述


你的公司接到了一批订单。订单要求你的公司提供 $n$ 类产品，产品被编号为 $1 \sim n$，其中第 $i$ 类产品共需要 $C_i$ 件。公司共有 $m$ 名员工，员工被编号为 $1 \sim m$ 员工能够制造的产品种类有所区别。一件产品必须完整地由一名员工制造，不可以由某名员工制造一部分配件后，再转交给另外一名员工继续进行制造。

我们用一个由 $0$ 和 $1$ 组成的 $m \times n$ 的矩阵 $A$ 来描述每名员工能够制造哪些产品。矩阵的行和列分别被编号为 $1 \sim m$ 和 $1 \sim n$，$A_i,j$ 为 $1$ 表示员工 $i$ 能够制造产品 $j$，为 $0$ 表示员工 $i$ 不能制造产品 $j$。

如果公司分配了过多工作给一名员工，这名员工会变得不高兴。我们用愤怒值来描述某名员工的心情状态。愤怒值越高，表示这名员工心情越不爽，愤怒值越低，表示这名员工心情越愉快。员工的愤怒值与他被安排制造的产品数量存在某函数关系，鉴于员工们的承受能力不同，不同员工之间的函数关系也是有所区别的。

对于员工 $i$，他的愤怒值与产品数量之间的函数是一个 $S_i+1$ 段的分段函数。当他制造第 $1 \sim T_{i,1}$ 件产品时，每件产品会使他的愤怒值增加 $W_{i,1}$，当他制造第 $T_{i,1}+1 \sim T_{i,2}$ 件产品时，每件产品会使他的愤怒值增加 $W_{i,2}$ ……为描述方便，设 $T_{i,0}=0,T_{i,s_{i+1}}=+\infty$，那么当他制造第 $T_{i,j-1}+1 \sim T_{i,j}$ 件产品时，每件产品会使他的愤怒值增加 $W_{i,j}$，$1 \le j \le S_i+1$。

你的任务是制定出一个产品的分配方案，使得订单条件被满足，并且所有员工的愤怒值之和最小。由于我们并不想使用Special Judge，也为了使选手有更多的时间研究其他两道题目，你只需要输出最小的愤怒值之和就可以了。


## 说明/提示


### 数据范围及约定

- 存在 $30\%$ 的数据，保证 $1\le n,m\le 30$；
- 均匀分布着约 $30\%$ 的数据，满足 $S_i = 0$；
- 均匀分布着约 $30\%$ 的数据，满足 $S_i \le 1$（不包含上述 $S_i = 0$ 的数据）。

对于全部数据，满足 $1\le m,n\le 250$，$0\le S_i\le 5$，$0\le A_{i, j}\le 1$，$0< T_{i, j}< T_{i, j + 1}$，$0< W_{i,j} < W_{i, j + 1}$。所有数据均不大于 $10^5$。

## 样例 #1

### 输入

```
2 3
2 2 2
1 1 0
0 0 1
1
2
1 10
1
2
1 6```

### 输出

```
24```

# 题解

## 作者：revenger (赞：6)

先吐槽一下时限，0.5s什么鬼，不应该是1s么。。

好吧回到正题，先观察数据范围，n,m<=250，这是明显的网络流的数据范围。

所以我们就来建一下图。

如果抛开分段函数，这道题的建图思路应该非常清晰，S往人连费用为愤怒值的边，人往能加工的产品连流量inf，费用为0的边，产品往T连流量为ci，费用为0的边，跑一遍费用流即可。

但是怎么处理分段函数呢。看一下分段函数的段非常少，那我们可以拆边。把S往人连的费用为愤怒值的边按照分段函数进行拆分，拆解成si+1条边，前si条边的流量就等于ti-t(i-1)，费用就等于这一段的愤怒值wi，第si+1条边的流量为inf，费用为w(i+1)。这样子拆完边后，跑一遍费用流就可以了。

顺便分享一下之前的思路：把人拆点，每个人拆成si+1个点，往每个点连拆出来的边，这样子会导致边数暴增。但是在BZOJ上依旧能过，洛谷上会被卡掉。所以最后我发现我怎么这么蠢呢，直接拆边不就好了么。。。

附跑的比大陆记者还慢的代码：

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<queue>
using namespace std;
int head[1010],nxt[500010],point[500010],remain[500010],sum;
long long w[500010];
int lastedge[1010],exist[1010];
long long dis[1010];
int wi[1010],si[255][255];
int ti[10],ci[10];
int n,m,x;
const int inf=1e9+7;
const long long longinf=(1ll<<50);
queue<int>q;
#define min(a,b) (a<b?a:b)
void read(int &ans,char ch=getchar())
{
    ans=0;
    for(;ch<'0'||ch>'9';ch=getchar());
    for(;ch>='0'&&ch<='9';ans=ans*10+ch-48,ch=getchar());
} 
void add(int x,int y,int flow,int cost)
{
    ++sum;nxt[sum]=head[x];head[x]=sum;point[sum]=y;remain[sum]=flow;w[sum]=cost;
    ++sum;nxt[sum]=head[y];head[y]=sum;point[sum]=x;remain[sum]=0;w[sum]=-cost;
}
int addflow(int s,int t)
{
    int now=t,f=inf;
    while(now!=s)
    {
        f=min(f,remain[lastedge[now]]);
        now=point[lastedge[now]^1];
    }
    now=t;
    while(now!=s)
    {
        remain[lastedge[now]]-=f;
        remain[lastedge[now]^1]+=f;
        now=point[lastedge[now]^1];
    }
    return f;
}
bool spfa(int s,int t,int &maxflow,long long &mincost)
{
    memset(dis,127,sizeof(dis));
    dis[s]=0;
    q.push(s);
    while(!q.empty())
    {
        int now=q.front();q.pop();
        exist[now]=0;
        for(int tmp=head[now];tmp!=-1;tmp=nxt[tmp])
        {
            int u=point[tmp];
            long long v=w[tmp];
            if(dis[u]>dis[now]+v&&remain[tmp])
            {
                dis[u]=dis[now]+v;
                lastedge[u]=tmp;
                if(!exist[u])
                q.push(u),exist[u]=1;
            }
        } 
    }
    if(dis[t]>longinf) return false;
    int flow=addflow(s,t);
    maxflow+=flow;
    mincost+=flow*dis[t];
    return true;
} 
void mfmc(int s,int t,int &maxflow,long long &mincost)
{
    mincost=maxflow=0;
    while(spfa(s,t,maxflow,mincost));
}
int main()
{
    sum=-1;
    memset(nxt,-1,sizeof(nxt));
    memset(head,-1,sizeof(head));
    read(n),read(m);
    for(int i=1;i<=m;i++)
    {
        read(x);
        add(i+n,m+n+1,x,0);
    }
    for(int i=1;i<=n;i++)
    for(int j=1;j<=m;j++)
    read(si[i][j]);
    for(int i=1;i<=n;i++)
    {
        read(x);
        for(int j=1;j<=x;j++)
        read(ti[j]);
        for(int j=1;j<=x+1;j++)
        read(ci[j]);
        for(int j=1;j<=x;j++)
        add(0,i,ti[j]-ti[j-1],ci[j]);
        add(0,i,inf,ci[x+1]);
        for(int j=1;j<=m;j++)
        if(si[i][j])
        add(i,j+n,inf,0);
    }
    int mflow;
    long long mcost;
    mfmc(0,m+n+1,mflow,mcost);
    printf("%lld",mcost);
} 
最后，再吐槽一遍时限，不放1s真的好么。。
```

---

## 作者：Dispwnl (赞：2)

> 11.29 修改排版

裸的最小费用最大流，只要读懂题意就行了

建超源点和超汇点，超源点连物品，边容量为$C_i$

超汇点连人，每个人连$S_{i+1}$条边

每条边容量为$T_{i,j}-T_{i,j-1}$，费用为$W_{i,j}$

然后根据已知信息，把物品和人之间建边

容量为$inf$，费用为$0$

然后跑最小费用最大流就行了

答案似乎要开```long long```

代码：
```cpp
# include<iostream>
# include<cstring>
# include<cstdio>
# include<queue>
using namespace std;
struct p{
    int x,y,dis,cn;
}c[200001];
int n,m,num,t;
long long tot1;
int h[2001],pre[2001],T[11];
long long d[2001];
bool use[2001];
bool a[301][301];
void add(int x,int y,int dis,int cn)
{
    c[num].x=h[x];
    c[num].y=y;
    c[num].cn=cn;
    c[num].dis=dis;
    h[x]=num++;
}
void EK()
{
    while(1)
    {
        memset(use,0,sizeof(use));
        memset(d,127,sizeof(d));
        d[0]=0;
        queue<int> qu;
        qu.push(0);
        while(!qu.empty())
        {
            int tt=qu.front();
            qu.pop();
            use[tt]=0;
            for(int i=h[tt];i;i=c[i].x)
              if(d[c[i].y]>d[tt]+c[i].cn&&c[i].dis)
              {
                  d[c[i].y]=d[tt]+c[i].cn;
                  pre[c[i].y]=i;
                  if(!use[c[i].y])
                  {
                      use[c[i].y]=1;
                      qu.push(c[i].y);
                }
              }
        }
        if(d[t]>1e8) return;
        int hh=t,sum=1e9;
        while(pre[hh])
        {
            int l=pre[hh];
            sum=min(sum,c[l].dis);
            hh=c[l^1].y;
        }
        hh=t;
        while(pre[hh])
        {
            int l=pre[hh];
            c[l].dis-=sum;
            c[l^1].dis+=sum;
            tot1+=sum*c[l].cn;
            hh=c[l^1].y;
        }
    }
}
int main()
{
    scanf("%d%d",&m,&n);
    t=n+m+1;
    for(int i=1;i<=n;i++)
      {
          int x;
          scanf("%d",&x);
          add(i,0,0,0);
          add(0,i,x,0);
      }
    for(int i=1;i<=m;i++)
      for(int j=1;j<=n;j++)
        {
            scanf("%d",&a[i][j]);
            if(!a[i][j]) continue;
            add(i+n,j,0,0);
            add(j,i+n,1e9,0);
        }
    for(int i=1;i<=m;i++)
      {
          int s;
          scanf("%d",&s);
          memset(T,0,sizeof(T));
          for(int j=1;j<=s;j++)
            scanf("%d",&T[j]);
          T[s+1]=1e9;
          for(int j=1;j<=s+1;j++)
            {
                int x;
                scanf("%d",&x);
                add(t,i+n,0,-x);
                add(i+n,t,T[j]-T[j-1],x);
          }
      }
    EK();
    printf("%lld",tot1);
    return 0;
}
```

---

## 作者：ddwqwq (赞：1)

我主要说明我的方法的不同之处，读者可以参考其他题解。

正如前人所说，如果抛开分段函数，这道题的建图思路应该非常清晰，S往人连费用为愤怒值的边，人往能加工的产品连流量inf，费用为0的边，产品往T连流量为ci，费用为0的边，跑一遍费用流即可。

分段函数的处理可以参照P2053 [SCOI2007]修车，然而有一点不同，那就是修车那道题保证修得越晚，费时越多，而本题并没有保证w单调递增。因此，直接把S往人连的费用为愤怒值的边按照分段函数进行拆分可能导致错误的结果（比如说某个人还没做第一件产品，就开始做第二件）。

如何解决呢？我们可以采用动态加边的方法。首先添加分段函数的第一阶段的边和其它的边。之后在増广过程中，每当某一阶段的边被填满，就加入下一阶段的边，这样就可以保证结果合法。同时，动态加边也可以加快速度。

[评测记录](https://www.luogu.org/record/show?rid=6837112)，以下是代码，我把模板封装在了结构体中，可以直接跳过上面的结构体定义看主函数，函数名应该还算清楚。
```
#include <cstdlib>
#include <iostream>
#include <cstdio>
#include <math.h>
#include <cstring>
#include <time.h>

#pragma warning(disable:4996)
#define INF 2000000005//2 * 10^9
#define lowbit(a) ((a)&-(a))
inline long long max(long long a, long long b)
{
    return a>b ? a : b;
}
inline long long min(long long a, long long b)
{
    return a<b ? a : b;
}

const long long MAXN = 100000;

struct Graph {

    struct element {
        long long id;
        long long d;
        bool operator < (element &a)
        {
            return d < a.d;
        }
    };
    struct heap {
    private:
        element e[1000000];
        long long hsize;
        void swap(element &a, element &b)
        {
            element t = a;
            a = b;
            b = t;
        }
    public:
        void heapify(long long i)
        {
            long long m;
            if (i * 2 <= hsize&&e[i * 2] < e[i])
                m = i * 2;
            else
                m = i;
            if (i * 2 + 1 <= hsize&&e[i * 2 + 1] < e[m])
                m = i * 2 + 1;
            if (m != i)
            {
                swap(e[i], e[m]);
                heapify(m);
            }
        }
        void fixup(long long i)
        {
            if (i > 1 && e[i] < e[i / 2])
            {
                swap(e[i], e[i / 2]);
                fixup(i / 2);
            }
        }
        void push(element i)
        {
            e[++hsize] = i;
            fixup(hsize);
        }
        element pop()
        {
            element t = e[1];
            e[1] = e[hsize--];
            heapify(1);
            return t;
        }
        void clear()
        {
            hsize = 0;
        }
        long long size()
        {
            return hsize;
        }
    };

    struct node {
        long long to;
        long long cp;
        long long w;
        node *next;
    };
    long long c[1000000], bak[1000000], k;

    void add(node *&head, long long to, long long C, long long w)
    {
        node *p = new(node);
        p->to = to;
        p->w = w;
        p->cp = k;
        bak[k] = C;
        c[k++] = C;
        p->next = head;
        head = p;
    }
    node *edge[MAXN];
    long long d[MAXN], fa[MAXN], S, T;
    node *path[MAXN];
    long long to;
    node *eto;

    bool relax(long long v, node *p)
    {
        if (d[p->to] > d[v] + p->w)
        {
            d[p->to] = d[v] + p->w;
            fa[p->to] = v;
            path[p->to] = p;
            return true;
        }
        return false;
    }

    heap H;

    bool spfa()
    {
        long long i;
        H.clear();
        memset(fa, 0, sizeof(fa));
        memset(path, 0, sizeof(path));
        for (i = 0; i < MAXN; i++)
            d[i] = INF;
        d[S] = 0;
        H.push({ S,0 });

        while (H.size())
        {
            element t = H.pop();
            while (H.size() && d[t.id] != t.d)
                t = H.pop();
            long long v = t.id;
            for (node *p = edge[v]; p; p = p->next)
                if (c[p->cp] && relax(v, p))
                    H.push({ p->to,d[p->to] });
        }
        return d[T] < INF;
    }

    long long flow(long long cur, long long lim)
    {
        if (cur == S)
            return lim;
        if (fa[cur] == S)
        {
            to = cur;
            eto = path[cur];
        }
        long long f = flow(fa[cur], min(lim, c[path[cur]->cp]));
        c[path[cur]->cp] -= f;
        c[path[cur]->cp ^ 1] += f;
        return f;
    }

    long long flow()
    {
        return flow(T, INF);
    }

    long long getans()
    {
        long long i, ans = 0;
        for (i = 0; i < MAXN; i++)
            for (node *p = edge[i]; p; p = p->next)
                if (bak[p->cp] - c[p->cp] > 0)
                    ans += (bak[p->cp] - c[p->cp])*p->w;
        return ans;
    }

    long long MC, MF;
    void addedge(long long u, long long v, long long C, long long w = 0)
    {
        add(edge[u], v, C, w);
        add(edge[v], u, 0, -w);
    }
    long long MCMF(long long s, long long t, const char *ch = "C")
    {
        memcpy(c, bak, sizeof(c));
        S = s;
        T = t;
        long long ans = 0;
        while (spfa())
            ans += flow();
        MF = ans;
        MC = getans();
        if (ch == "F")
            return MF;
        return MC;
    }
};

long long N, M, S, T;
long long C[300], s[300], r[300][10], w[300][10];
long long cur[MAXN];
bool A[300][300];
Graph G;

long long id(long long i)
{
    return M + i;
}

int main()
{
    long long i, j;

    scanf("%lld %lld", &M, &N);
    T = M + N + 1;

    for (i = 1; i <= N; i++)
        scanf("%lld", &C[i]);

    for (i = 1; i <= M; i++)
        for (j = 1; j <= N; j++)
            scanf("%d", &A[i][j]);

    for (i = 1; i <= M; i++)
    {
        scanf("%lld", &s[i]);
        for (j = 1; j <= s[i]; j++)
            scanf("%lld", &r[i][j]);
        r[i][s[i] + 1] = INF;
        for (j = 1; j <= s[i] + 1; j++)
            scanf("%lld", &w[i][j]);
        cur[i] = 1;
    }

    G.S = S;
    G.T = T;

    for (i = 1; i <= M; i++)
        G.addedge(S, i, r[i][1], w[i][1]);
    for (i = 1; i <= N; i++)
        G.addedge(id(i), T, C[i], 0);
    for (i = 1; i <= M; i++)
        for (j = 1; j <= N; j++)
            if (A[i][j])
                G.addedge(i, id(j), INF, 0);

    long long ans = 0;
    while (G.spfa())
    {
        ans += G.flow();
        if (!G.c[G.eto->cp])
        {
            cur[G.to]++;
            G.addedge(S, G.to, r[G.to][cur[G.to]] - r[G.to][cur[G.to] - 1]
                , w[G.to][cur[G.to]]);
        }
    }

    printf("%lld", G.getans());

//	system("pause");
    return 0;
}
```

---

## 作者：lao_wang (赞：0)

## 前言

这是卡 spfa？？？

## 建图

首先我们可以想到的就是题意建模，也就是每个人向能做的物品连边。（这种连边方法是错的就不详细说了）

但是我们会发现一点：每人所造的物品在图中会变得不已知。

所以在这里要使用建模中经常会遇到的方法：拆点。

把代表人的点拆成成入点和出点，在出点流向的点的流量设为 inf，源点向入点连流量为 inf 边。让后再让入点连向出点，边数为 $S_{i}+1$，每条边的流量就为 $T_{i,j}-T_{i,j-1}$，费用就为 $w_{i,j}$（只有这种边有费用其余均没有）。（因为在数据中愤怒值递增不用怕 spfa 跑错边的顺序）

最后将所有代表物品的点连向汇点流量为所需个数，这个题就做完了。

但真的做完了吗？

测评结果告诉我们：No。

这样只能得 85 分（如果常数差可能为 75 分）因为边数过多。

应该怎么解决？

我们都知道，一次费用流的 dinic 只会增广源点到汇点的最短路，所以我们只需要让他们只跑这一条路，就不会 TLE。

## 代码

```cpp
#include<bits/stdc++.h>
#define int long long 
#define inf 21474836471
#define N 50121
using namespace std ;
int m , n , head[N] , now[N] , dep[N] , s , t , cnt=0 , money=0 , S[N] , to[N] , go[N] ;
bool f[N] ;
struct node{
	int to , next , w , c , I ;
}e[1123456];
void use(int u,int v,int w,int c){
	e[cnt].I = u ;
	e[cnt].to = v ;
	e[cnt].w = w ;
	e[cnt].next = head[u] ;
	e[cnt].c = c ;
	head[u] = cnt++ ;
}
void newnet(int u,int v,int w,int c){use(u,v,w,c) , use(v,u,0,-c) ;}
bool bfs(){
	for(int i=1;i<=t;i++) dep[i] = inf , now[i] = head[i] , f[i] = 0 ;
	queue<int> q ;
	q.push(s) ;
	dep[s] = 0 ;
	while(!q.empty()){
		int u=q.front() ;
		f[u] = 0 ;
		q.pop() ;
		for(int i=head[u];~i;i=e[i].next){
			int x=e[i].to ;
			if(e[i].w&&dep[u]+e[i].c<dep[x]){
				to[x] = i ;
				dep[x] = dep[u]+e[i].c ;
				if(!f[x]){
					f[x] = 1 ;
					q.push(x) ;
				}
			}
		}
	}
	return dep[t]!=inf ;
}
int dfs(int u,int sum){
	if(u==t) return sum ;
	f[u] = 1 ;
	int use=0 ;
	while(1){
		int i = go[u] ;
		int x=e[i].to ;
		if(dep[u]+e[i].c!=dep[x]||!e[i].w||f[x]) continue ;
		int temp=dfs(x,min(sum,e[i].w)) ;
		if(!temp) continue ;
		e[i].w -= temp ;
		e[i^1].w += temp ;
		money += temp*e[i].c ;
		sum -= temp ;
		use += temp ;
		break ;
	}
	return use ;
}
void dinic(){
	while(bfs()){
		int temp=t ;
		while(temp!=s){
			go[e[to[temp]].I] = to[temp] ;
			temp = e[to[temp]].I ;
		}
		dfs(s,inf) ;
	}
	cout << money ;
}
int read(){
	int x=0 , f=1 ;
	char a=getchar() ;
	while(!(a>='0'&&a<='9')){
		if(a=='-') f = -f ; 
		a = getchar() ;
	}
	while(a>='0'&&a<='9'){
		x  *= 10 ;
		x += a-'0' ;
		a = getchar() ;
	}
	return x*f ;
}
signed main(){
	memset(head,-1,sizeof head) ;
	cin >> m >> n ;
	s = m*2+n+1 ;
	t = s+1 ;
	for(int i=1;i<=n;i++){
		int w=read() ;
		newnet(i+m*2,t,w,0) ;
	}
	for(int i=1;i<=m;i++){
		newnet(s,i,inf,0) ;
		for(int j=1;j<=n;j++){
			int temp=read() ;
			if(temp) newnet(i+m,j+m*2,inf,0) ;
		}
	}
	for(int i=1;i<=m;i++){
		int temp1=read() ;
		S[temp1+1] = inf ;
		for(int j=1;j<=temp1;j++)
			S[j] = read() ;
		for(int j=1;j<=temp1+1;j++){
			int temp=read() ;
			newnet(i,i+m,S[j]-S[j-1],temp) ;
		}
	}
	dinic() ;
	return 0 ;
}
```

---

## 作者：赵悦岑 (赞：0)

# P2488 [SDOI2011]工作安排

[P2488 [SDOI2011]工作安排](https://www.luogu.com.cn/problem/P2488)

## 分析

这道题看起来可以直接跑最小费用最大流，把点分成 $n$ 个代表产品的点和 $m$ 个代表员工的点，把员工可以做的货物之间连边，容量为 $1$，费用为 $0$，把员工和汇点连起来，容量为 $inf$，费用为 $W_i$，把源点和产品连起来后跑一遍最小费用最大流就可以了。

但是定睛一看，员工的单位产品愤怒值居然不是定值，愤怒值和产品数为一个分段函数，这就不能用上面的方法做了。这时我们想到了要让一条边的单位费用也随流量变化，这就让我们很容易想到“拆边”。将员工 $i$ 和汇点连 $S_i+1$ 条边：第一条边的容量为 $T_{i,1}$，费用为 $W_{i,1}$，表示流量为 $1 \sim T_{i,1}$ 的时候单位愤怒值为 $W_{i,1}$；第二条边的容量为 $T_{i,2}-T_{i,1}$，费用为 $W_{i,2}$，由于 $W_{i,1}<W_{i,2}$，所以流量会先流满第一条边再流满第二条边，所以表示流量为 $T_{i,1}+1 \sim T_{i,2}$ 的时候单位愤怒值为 $W_{i,2}$；第 $j$ 条边的容量为 $T_{i,j}-T_{i,j-1}$，费用为 $W_{i,j}$，表示流量为 $T_{i,j-1}+1 \sim T_{i,j}$ 的时候单位愤怒值为 $W_{i,j}$。这里我们令 $T_{i,0}=0$，$T_{i,S_i+1}=maxn$ 就可以了。接下来跑最小费用最大流就可以了。


## code

```cpp
#include<cstdio>
#include<algorithm>
#include<queue>
using namespace std;
typedef long long ll;
const int N=10001,M=1000001;
int n,m,p=1,s1,s2,t[N],t0[N],c[N];
ll f[N],b[N],q,v;
bool h[N];
struct str
{
    int m,q;
    ll r,w;
}a[M];
void road(int x,int y,ll r,ll w)
{
    a[++p].m=y;
    a[p].q=t[x];
    t[x]=p;
    a[p].r=r;
    a[p].w=w;
}
bool SPFA()
{
    queue<int> Q;
    Q.push(s1);
    for(int i=1;i<=s2;++i)
    {
        f[i]=1e18;
        h[i]=false;
    }
    f[s1]=0;
    h[s1]=true;
    while(!Q.empty())
    {
        int k=Q.front();
        Q.pop();
        if(h[k]==false) continue;
        h[k]=false;
        for(int i=t[k];i!=0;i=a[i].q)
        {
            if(a[i].r>0&&f[k]+a[i].w<f[a[i].m])
            {
                f[a[i].m]=f[k]+a[i].w;
                Q.push(a[i].m);
                h[a[i].m]=true;
            }
        }
    }
    if(f[s2]!=1e18) return true;
    return false;
}
ll dfs(int x,ll r)
{
    if(x==s2) return r;
    ll s=0;
    for(int i=t0[x];i!=0;i=a[i].q)
    {
        t0[x]=i;
        if(h[a[i].m]==false&&a[i].r>0&&f[a[i].m]==f[x]+a[i].w)
        {
            h[a[i].m]=true;
            ll z=dfs(a[i].m,min(r,a[i].r));
            h[a[i].m]=false;
            if(z!=0)
            {
                a[i].r-=z;
                a[i^1].r+=z;
                r-=z;
                s+=z;
                v+=z*a[i].w;
            }
            else f[a[i].m]=0;
            if(r==0) return s; 
        }
    }
    return s;
}
int main()
{
    scanf("%d%d",&m,&n);
    for(int i=1;i<=n;++i)
    {
        scanf("%lld",&b[i]);
        q+=b[i];
    }
    s1=n+m+1;
    s2=n+m+2;
    for(int i=1;i<=n;++i)
    {
        road(s1,i,b[i],0);
        road(i,s1,0,0);
    }
    for(int i=1;i<=m;++i)
    {
        for(int j=1;j<=n;++j)
        {
            int z;
            scanf("%d",&z);
            if(z==0) continue;
            road(j,n+i,1e18,0);
            road(n+i,j,0,0);
        }
    }
    for(int i=1;i<=m;++i)
    {
        int s;
        scanf("%d",&s);
        c[0]=0;
        c[s+1]=q;
        for(int j=1;j<=s;++j)
        {
            scanf("%d",&c[j]);
        }
        for(int j=1;j<=s+1;++j)
        {
            ll w;
            scanf("%lld",&w);
            road(n+i,s2,c[j]-c[j-1],w);
            road(s2,n+i,0,-w);
        }
    }
    while(SPFA())
    {
        for(int i=1;i<=s2;++i) 
        {
            t0[i]=t[i];
            h[i]=false;
        }
        dfs(s1,1e18);
    }
    printf("%lld",v);
    return 0;
}
```

---

## 作者：Orion545 (赞：0)

# 广告

[蒟蒻的blog](http://www.cnblogs.com/dedicatus545/p/8745373.html)

# 正文

数据范围n,m<=250

分配任务问题

这是典型的“看到数据范围就知道算法”类型

而且我们发现我们要保证一定产出的情况下最小化花费

这句话等价于保证一定流量的情况下最小化费用

所以先确定算法：最小费用最大流

再观察一下，我们发现这道题的费用和人唯一相关，而且人和物品之间的关系是独立的

因此我们建立一个网络流图，其中包含S，T，人点和物品点

对于每个物品i，我们连边(i,T)，费用0，流量为$C_i$

对于一个人i可以操作物品j，我们连边(i,j)，费用0，流量inf

接下来的问题就是处理人的费用了

我们发现这道题的费用是分段处理的

看到分段，第一想法就是把人拆点，但是这样势必会大大增加冗余边数，拖慢程序速度

因此我们考虑不拆点来做

观察发现，这道题分段中保证$W_{i,j}$递增

也就是说，如果有一坨重边，我们的算法会先跑代表靠前的分段的边

这引导我们往重边方向上想

对于一个点i，我们把每个长度为l，段中费用为cost的分段，连一条边(S,i)，费用cost，流量l

因为每个点最多六段，所以这个算法的边数很少，跑得过

最后只要一步(S,T)费用流，输出总费用就可以了

# Code:

这题卡常数啊......

而且我的zkw费用流被卡了过不了，洛谷评测机又不稳定，一会TLE一会RE的......

```cpp
// luogu-judger-enable-o2
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define inf 1e9
#define ll long long
using namespace std;
inline ll read(){
    ll re=0,flag=1;char ch=getchar();
    while(ch>'9'||ch<'0'){
        if(ch=='-') flag=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9') re=(re<<1)+(re<<3)+ch-'0',ch=getchar();
    return re*flag;
}
ll first[5010],dis[5010],vis[5010],n,m,cnt=-1,ans;
struct edge{
    ll to,next,w,cap;
}a[600010];
inline void add(ll u,ll v,ll w,ll cap){
    a[++cnt]=(edge){v,first[u],w,cap};first[u]=cnt;
    a[++cnt]=(edge){u,first[v],-w,0};first[v]=cnt;
}
ll q[1000010];
ll limit[5010],pre[5010];
bool Spfa(int s,int t){
    ll head=0,tail=1,i,u,v,w;
    memset(dis,-1,sizeof(dis));memset(vis,0,sizeof(vis));
    memset(limit,0,sizeof(limit));memset(pre,-1,sizeof(pre));
    q[0]=s;dis[s]=0;vis[s]=1;limit[s]=inf;
    while(head<tail){
        u=q[head++];vis[u]=0;
        for(i=first[u];~i;i=a[i].next){
            v=a[i].to;w=a[i].w;
            if(a[i].cap&&((dis[v]==-1)||(dis[v]>dis[u]+w))){
                dis[v]=dis[u]+w;pre[v]=i;
                limit[v]=_min(limit[u],a[i].cap);
                if(!vis[v]) q[tail++]=v,vis[v]=1;
            }
        }
    }
    return ~dis[t];
}
int mcmf(int s,int t){
    int re=0,u;
    while(Spfa(s,t)){
        re+=limit[t];
        for(u=t;~pre[u];u=a[pre[u]^1].to){
            a[pre[u]].cap-=limit[t];a[pre[u]^1].cap+=limit[t];
            ans+=limit[t]*a[pre[u]].w;
        }
    }
    return re;
}
int main(){
    memset(first,-1,sizeof(first));
    m=read();n=read();ll i,j,t1,t2[10],t3;
    for(i=1;i<=n;i++) t1=read(),add(0,i,0,t1);
    for(i=1;i<=m;i++){
        for(j=1;j<=n;j++){
            t1=read();
            if(t1) add(j,n+i,0,inf);
        }
    }
    for(i=1;i<=m;i++){
        t1=read();t2[0]=0;
        for(j=1;j<=t1;j++) t2[j]=read();
        for(j=0;j<t1;j++){//分段建重边
            t3=read();
            add(n+i,n+m+1,t3,t2[j+1]-t2[j]);
        }
        t3=read();add(n+i,n+m+1,t3,inf);
    }
    mcmf(0,n+m+1);
    cout<<ans<<endl;
}
```

---

## 作者：alpq010815 (赞：0)

裸的最小费用最大流

思路是弄一个原点，弄一个会点，将原点连上物品容量为c[i]，

费用为零，将物品和人按a数组的关系连起来，容量为INF,花费为零，然后将人和会点连起来容量为他

做几件物品，也就是ss[j]-ss[j-1],花费为他做这几件的愤怒值,再跑最大流最小费用算法就行了;

    
    
            
        

        
        
   
  
         
    
    

        
        
   
  
    
  
```cpp
#include<cstdio>
#include<iostream>
#include<cstring> 
#include<queue>
#define LL long long
using namespace std;
const int M=199999;
const int INF=2139062143;
int n,m,s,t;int dis[M],c[M],a[999][999],ss[M];
int nex[M],head[M],cos[M],to[M],tot,pre[M],cap[M],vis[M],flo[M],id[M];
int add(int x,int y,int z,int w){
    cos[tot]=z;
    cap[tot]=w;
    nex[++tot]=head[x];
    to[tot]=y;
    head[x]=tot;
     cos[tot]=-z;
    cap[tot]=0;
    nex[++tot]=head[y];
    to[tot]=x;
    head[y]=tot;
}
int spfa(int s,int t){
    queue <int> q;
    memset(dis,127,sizeof(dis));
    memset(vis,0,sizeof(vis));
    memset(pre,-1,sizeof(pre));
    dis[s]=0;
    vis[s]=1;
    q.push(s);
    flo[s]=INF;
    while(!q.empty()){
        int x=q.front();
        vis[x]=0;
        q.pop();
        for(int i=head[x];i;i=nex[i])
        {
            int tmp=to[i];
            if(dis[tmp]>dis[x]+cos[i-1]&&cap[i-1]){
                dis[tmp]=dis[x]+cos[i-1];
                pre[tmp]=x;
                flo[tmp]=min(flo[x],cap[i-1]);
                id[tmp]=i-1;
                if(!vis[tmp]){
                q.push(tmp);
                vis[tmp]=1;
                }
            }
        }
    }
    if(dis[t]>=INF)return 0;
    return 1; 
}
struct st{
    LL cost;
    LL flow;
}; 
st  maxflow(int s,int t){
       st a;
       a.flow=0,a.cost=0;
    while(spfa(s,t)){
        int k=t;
           while(k!=s){
            cap[id[k]]-=flo[t];
            cap[id[k]^1]+=flo[t];
            k=pre[k];
        }
           //a.flow+=flo[t];
           a.cost+=flo[t]*dis[t];
    }
    return a;
}
int main(){
    scanf("%d%d",&m,&n);
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&c[i]);
        add(0,i,0,c[i]);
    }// 将原点连上物品容量为c[i]，费用为零
    for(int i=1;i<=m;i++)
    for(int j=1;j<=n;j++){
        scanf("%d",&a[i][j]);
        if(a[i][j]){
            add(j,i+n,0,INF);//将物品和人按a数组的关系连起来，容量为INF,花费为零
        }
    }
    for(int i=1;i<=m;i++){
        int s;
        scanf("%d",&s);
        for(int j=1;j<=s;j++){
            scanf("%d",&ss[j]);
        } 
        ss[s+1]=INF;
        for(int j=1;j<=s+1;j++){
            int w;
            scanf("%d",&w);
                add(i+n,n+m+1,w,ss[j]-ss[j-1]);//然后将人和会点连起来容量为他做几件物品，也就是ss[j]-ss[j-1],花费为他做这几件的愤怒值
        }
    }
    st d=maxflow(0,n+m+1);
    printf("%lld",d.cost);
    return 0;
}
```

---

## 作者：MSavannah (赞：0)

**Solution**

难点在于理解题意？反正我读了好久。

一眼费用流。但是分段函数给建图带来了一点麻烦。那先不考虑分段函数这个限制看看图怎么建。显然是源点向人连费用为愤怒值的边，人向每个他能够制造的物品连容量为 $\inf$ 费用为 $0$ 的边，每个物品向汇点连容量为 $c_i$ 费用为 $0$ 的边。

那加上限制怎么做，我们的目的是让一条边的费用随着流量的变化变化，而且分段函数的段数又很少（$s_i\leq 1$），考虑拆边。从源点向人 $i$ 连 $s_i+1$ 条边每条边的容量为 $t_j-t_{j-1}$ 费用为 $w_j$，注意令 $t_{s_{i+1}}=\inf$，$t_0=0$。由于有 $w_{i,j}\leq w_{i,j+1}$ 这一性质，跑费用流的时候一定是把小的流满了再流大的。没有问题。

这里说一下为什么把人拆成 $s_i+1$ 个点是不行的，因为这样就会使边数过多，但是发现把点拆开连边和把点合并起来连边其实效果是一样的，图的规模还更小。所以选择拆边。

[code](https://www.luogu.com.cn/record/159330018)

---

## 作者：crashed (赞：0)

# 题目
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[点这里](https://www.luogu.com.cn/problem/P2488)看题目。  
# 分析
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不难看出是费用流的题目。考虑如果没有分段函数的限制，这就是一个网络流的板子题。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有了这个限制，我们首先可以想到拆点，将原来的一个人拆成$S+1$个点，分别对应了不同段的函数；然后用$(\infty, 0)$（前一个为容量，后一个为费用，下同）的边将它们串起来，并各自以$(T_j-T_{j-1},W_j)$连向终点。由于有$W_j<W_{j+1}$这个限制，所以在跑网络流的时候，一定会按照费用正序流过这些边，这是符合题意的。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不过，考虑到流过$(\infty,0)$的边相当于啥也没干，我们便可以想到，将$S+1$个点合并为一个点，也就相当于将边拆成了$S+1$条，这样就减小了图的规模。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后提醒一下，一定要开$long\ long$，不然怎么爆零的都不知道。  
# 代码
```cpp
#include <queue>
#include <cstdio>
using namespace std;

typedef long long LL;

#define int LL

const int INF = 0x3f3f3f3f3f3f3f3f;
const int MAXN = 255, MAXM = 255, MAXS = 6, MAXSIZ = 100005, MAXE = 200005;

template<typename _T>
void read( _T &x )
{
	x = 0;char s = getchar();int f = 1;
	while( s > '9' || s < '0' ){if( s == '-' ) f = -1; s = getchar();}
	while( s >= '0' && s <= '9' ){x = ( x << 3 ) + ( x << 1 ) + ( s - '0' ), s = getchar();}
	x *= f;
}

template<typename _T>
void write( _T x )
{
	if( x < 0 ){ putchar( '-' ); x = ( ~ x ) + 1; }
	if( 9 < x ){ write( x / 10 ); }
	putchar( x % 10 + '0' );
}

template<typename _T>
_T MIN( const _T a, const _T b )
{
	return a < b ? a : b;
}

struct edge
{
	int to, nxt, c, w;
}Graph[MAXE];

queue<int> q;

int C[MAXN], Ss[MAXM], beg[MAXM], Ts[MAXM][MAXS], W[MAXM][MAXS];
int head[MAXSIZ], dist[MAXSIZ], pre[MAXSIZ];
int N, M, cnt = 1, siz;
bool inQ[MAXSIZ], G[MAXM][MAXN];

void addEdge( const int from, const int to, const int C, const int W )
{
	Graph[++ cnt].to = to, Graph[cnt].nxt = head[from], Graph[cnt].c = C, Graph[cnt].w = W;
	head[from] = cnt;
}

void addE( const int from, const int to, const int C, const int W ) 
{ addEdge( from, to, C, W ), addEdge( to, from, 0, -W ); }

bool SPFA( const int S, const int T, int &cost )
{
	while( ! q.empty() ) q.pop();
	for( int i = 1 ; i <= siz ; i ++ ) dist[i] = INF, inQ[i] = false;
	inQ[S] = true, dist[S] = 0, q.push( S );
	int u, v, w;
	while( ! q.empty() )
	{
		inQ[u = q.front()] = false, q.pop();
		for( int i = head[u] ; i ; i = Graph[i].nxt )
			if( Graph[i].c && dist[v = Graph[i].to] > dist[u] + ( w = Graph[i].w ) )
			{
				dist[v] = dist[u] + w, pre[v] = i;
				if( ! inQ[v] ) inQ[v] = true, q.push( v );
			}
	}
	if( dist[T] == INF ) return false;
	LL mn = INF;
	for( int i = T ; i ^ S ; i = Graph[pre[i] ^ 1].to ) mn = MIN( mn, Graph[pre[i]].c );
	for( int i = T ; i ^ S ; i = Graph[pre[i] ^ 1].to ) Graph[pre[i]].c -= mn, Graph[pre[i] ^ 1].c += mn;
	cost += mn * dist[T];
	return true;
}

int EK( const int S, const int T )
{
	LL cost = 0;
	while( SPFA( S, T, cost ) );
	return cost;
}

signed main()
{
//	freopen( "1.in", "r", stdin );
	read( M ), read( N );
	for( int i = 1 ; i <= N ; i ++ ) read( C[i] );
	for( int i = 1 ; i <= M ; i ++ )
		for( int j = 1 ; j <= N ; j ++ )
			read( G[i][j] );
	siz = N + M + 2;
	for( int i = 1 ; i <= M ; i ++ )
	{
		read( Ss[i] );
		for( int j = 1 ; j <= Ss[i] ; j ++ ) read( Ts[i][j] );
		for( int j = 0 ; j <= Ss[i] ; j ++ ) read( W[i][j] );
	}
	int S = N + M + 1, T = siz;
	for( int i = 1 ; i <= N ; i ++ ) addE( S, i, C[i], 0 );
	for( int i = 1 ; i <= M ; i ++ )
		for( int j = 1 ; j <= N ; j ++ )
			if( G[i][j] )
				addE( j, N + i, INF, 0 );
	for( int i = 1 ; i <= M ; i ++ )
	{
		for( int j = 0 ; j < Ss[i] ; j ++ ) 
			addE( N + i, T, Ts[i][j + 1] - Ts[i][j], W[i][j] );
		addE( N + i, T, INF, W[i][Ss[i]] );
	}
	write( EK( S, T ) ), putchar( '\n' );
	return 0;
}
```

---


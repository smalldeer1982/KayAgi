# [CQOI2012] 交换棋子

## 题目描述

有一个 $n$ 行 $m$ 列的黑白棋盘，你每次可以交换两个相邻格子（**相邻是指有公共边或公共顶点**）中的棋子，最终达到目标状态。要求第 $i$ 行第 $j$ 列的格子只能参与 $m_{i,j}$ 次交换。

## 说明/提示

### 数据规模与约定

对于 $100\%$ 的数据，$1\leq n,m\leq20$。

## 样例 #1

### 输入

```
3 3
110
000
001
000
110
100
222
222
222```

### 输出

```
4```

# 题解

## 作者：George1123 (赞：72)

[${\color{#cc0055}\text{欢迎拜访我这个蒟蒻的博客}}$](https://www.luogu.com.cn/blog/Wendigo/)

[P3159 【\[CQOI2012\]交换棋子】](https://www.luogu.com.cn/problem/P3159)

### 此题算法:费用流

题目很简洁，做法很恶心的典型。

因为是网络流题，所以模板就不说了，只考虑**加边**。

**大致思路：**

**简化问题**

记录初始和结束状态，把**白棋**看作没棋。

把开始结束**都有黑棋**的格子看作没棋。

如果开始结束时**黑棋数**不等，$-1$ 掉。

**加边**

**1.拆点，每个格子有格子 $x$和格子 $y$。**

>控制格子交换次数。

**2.$s$ 向每个黑棋格 $x$ 连流量 $1$ 费用 $0$ 的边。**

>表示需匹配状态。

**3.每个黑棋格 $y$ 向 $t$ 连流量 $1$ 费用 $0$ 的边。**

>表示匹配状态。

**4.每个格子 $x$ 向对应 $y$ 连流量 $($允许交换数$\div 2)$ 费用 $0$的边。**

>两次交换只会消耗 $1$ 的流量。

**※.如果格子初始或结束时有黑棋**并且**允许交换数为奇数，在上面那条边上附上 $1$的流量。**

>不交换本来就要通过的流量。

**5.每个格子 $y$ 向八连通的格子 $x$ 连流量 $\inf $ 费用 $1$ 的边。**

>用来交换。

**然后跑模板就好了，网络流的题都差不多。**

![14.jpg](https://i.loli.net/2020/01/04/vlfeG3rF57WakgB.jpg)

> 图片仅供参考，以实物为准。

## 以下是代码 $+$ 注释

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=1e3+10;
const int M=5e4+10;
const int inf=1e8+10;
int p,n,m,s,t,S,T,fans,cans;
struct edge{
	int adj,nex,fw,r;
}e[M];
int g[N],top=1;
void add(int x,int y,int z,int w){
	e[++top]=(edge){y,g[x],z,w};
	g[x]=top;
}
void Add(int x,int y,int z,int w){
	add(x,y,z,w),add(y,x,0,-w);
}
int dep[N],cur[N];
bool vis[N];
queue<int> Q;
bool spfa(){
	// puts("spfa()");
	for(int i=1;i<=p;i++)
		vis[i]=0,dep[i]=inf,cur[i]=g[i];
	Q.push(s),vis[s]=1,dep[s]=0;
	while(Q.size()){
		int x=Q.front(); Q.pop();
		vis[x]=0;
		for(int i=g[x];i;i=e[i].nex){
			int to=e[i].adj,d=e[i].r;
			if(e[i].fw&&dep[to]>dep[x]+d){
				dep[to]=dep[x]+d;
				if(!vis[to]){
					vis[to]=1;
					Q.push(to);
				}
			}
		}
	}
	return dep[t]!=inf;
}
int dfs(int x,int F){
	// puts("dfs");
	if(!F||x==t)
		return F;
	int flow=0,f;
	vis[x]=1;
	for(int i=cur[x];i;i=e[i].nex){
		int to=e[i].adj; cur[x]=i;
		if(!vis[to]&&dep[x]+e[i].r==dep[to]&&
		(f=dfs(to,min(F,e[i].fw)))>0){
			e[i].fw-=f;
			e[i^1].fw+=f;
			flow+=f,F-=f;
			if(!F){
				vis[x]=0;
				break;
			} 
		}
	}
	return flow;
}
int P(int x,int y){return (x-1)*m+y;} //点序
int tx[]={-1,1,0,0,-1,-1,1,1};
int ty[]={0,0,-1,1,1,-1,1,-1}; //八向
int Ss[25][25],Ts[25][25]; //初始，终局
int main(){
	scanf("%d%d",&n,&m);
	p=t=2*n*m+2,s=t-1;
	char c[25];
	for(int i=1;i<=n;i++){
		scanf("%s",c);
		for(int j=1;j<=m;j++)
			if(c[j-1]=='1')
				Ss[i][j]=1,S++;
				
	}
	for(int i=1;i<=n;i++){
		scanf("%s",c);
		for(int j=1;j<=m;j++)
			if(c[j-1]=='1')
				Ts[i][j]=1,T++;
	}
	if(S!=T) return puts("-1"),0;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if(Ss[i][j]&&!Ts[i][j])
				Add(s,P(i,j),1,0),fans++; //2
			if(!Ss[i][j]&&Ts[i][j])
				Add(P(i,j)+n*m,t,1,0);   //3
		}
	}
	for(int i=1,x;i<=n;i++){
		scanf("%s",c);
		for(int j=1;j<=m;j++){
			x=c[j-1]-'0';
			Add(P(i,j),P(i,j)+n*m,x>>1,0); //4
			if((Ss[i][j]^Ts[i][j])&&(x&1))
				Add(P(i,j),P(i,j)+n*m,1,0); //※
			for(int k=0;k<8;k++){
				int xt=i+tx[k],yt=j+ty[k];
				if(xt<1||xt>n||yt<1||yt>m)
					continue;
				Add(P(i,j)+n*m,P(xt,yt),inf,1); //5
			}
		}
	}
	while(spfa()){
		int d=dfs(s,inf);
		fans-=d;
		cans+=d*dep[t];
	}
	if(fans) puts("-1");
	else printf("%d\n",cans);
	return 0;
}
```

图是手画的，写题解不易。

**关注博主，为文章点赞是你应该做的。**

谢谢大家! !


---

## 作者：maomao9173 (赞：34)

#### 最近一直在学习网络流。写到这个题目的时候，第一反应是：“这怎么可能是网络流呢？”用了一个下午写出来这道题后，感觉其思路实在妙极。

#### 本题解力求让像我一样初学网络流（~~初学OI~~）的人能够看懂，如果还存在疑惑的话欢迎联系我哦~

#### 看这个题目，很容易想到：可以记录黑色棋子的起始和终结位置，想办法去让棋子从起始位置走到终止位置，一一匹配。棋子在棋盘上走，走的过程中，棋子受到必须成功匹配（最大流）和在此基础上费用最小的约束条件。这样考虑的话，跑费用流自然是再合适不过了。如下图所示：

#### ![](http://images.cnblogs.com/cnblogs_com/maomao9173/1317473/o_tmp.png)


#### 进一步考虑会发现，棋子的交换可以被视为在棋盘上的坐标移动。想要连通起始点和终止点，只需要在二者之间建立棋盘的八连通图，让棋子在对应位置上进出棋盘即可。

#### 但是现在，有一个关键的问题：起始点和终止点作交换的时候， 消耗流量是$1$，但是对于中间节点，消耗流量却都应该是$2$。如果单纯的考虑把一个点拆分成一条边的话，无法处理这种边界情况，事情就变得相对比较麻烦。

#### 回归题目来考虑，题目要求是交换，那么交换就有交换进来和交换出去这两种交换方法。根据这个给我们的灵感，我们可以考虑把一个点拆成$3$个：$inn$，$mid$和$out$，把原本的最大访问量均分在两端上，而把每次的进出流量视为$1$。这样同时又解决了进出棋盘的问题：直接在$mid$处进入棋盘就不用考虑其他麻烦的事情了。

#### 那么流量均分的想法是否正确呢？基本上是对的。但是，现在我们有了$inn$->$mid$和$mid$->$out$两种边，如果边权是奇数，进出棋盘需要的流量只为$1$，原本不应该被忽略的零头$1$可能会被忽略或者非最优地分配。

#### 所以这里又牵涉到了这一点边界的处理问题。如果棋盘开始和结束都有或都没有该棋子，那么我们对可用点权$maxf$取$1/2$。否则的话，分别考虑进入和出去的情况：

![](https://cdn.luogu.com.cn/upload/pic/43646.png)

#### 可以看到，进入时的$mid$->$out$，出去时的$inn$->$mid$会有一条耗流为$1$的边，我们考虑如果这个点不是既进又出节点，就给其存在$1$耗流边的一部分尝试多分配一点"零头"流量（即偶数分配为$n/2$或$(n+1)/2$都一样，而奇数则分配为$n/2$：$(n+1)/2$。）

#### 为了便于各位理清思路，这里本人贴一下建图流程：

- 初始点->$S$ $f=1$ $w=0$
- 最终点<-$T$ $f=1$ $w=0$
- 初始点->对应坐标的$mid$节点 $f=1$  $w=0$
- 对应坐标的$mid$节点->终止点 $f=1$  $w=0$
- 棋盘内部的八连通：($out$->$in$) $f=INF$  $w=1$
- $inn$->$mid$和$mid$->$out$：$w=0$，根据情况确认选择 $f=maxf/2$ 或者 $f=(maxf+1)/2$

#### 至此，问题得以完美解决。代码冗长求轻喷。

```cpp
#include<queue>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#define MAXN 2010
#define MAXM 64010 
#define INF 0x3f3f3f3f
#define fpop(x) x.front();x.pop()
using namespace std;

int pre_node[MAXN],pre_edge[MAXN];

char ch,mp_bg[25][25],mp_ed[25][25];

int n,m,cnt=-1,dis[MAXN],vis[MAXN],flow[MAXN],head[MAXN],maxf[25][25];

struct edge{
	int nxt,to,w,f;
}e[MAXM];
	
inline int _bg(int x,int y){return n*m*0+(x-1)*m+y;}//起始点[x,y]的编号
inline int _ed(int x,int y){return n*m*1+(x-1)*m+y;}//目标点[x,y]的编号 
inline int _inn(int x,int y){return n*m*2+(x-1)*m+y;}//棋盘[x,y]的Inn点编号 
inline int _mid(int x,int y){return n*m*3+(x-1)*m+y;}//棋盘[x,y]的mid点标号
inline int _out(int x,int y){return n*m*4+(x-1)*m+y;}//棋盘[x,y]的Out点编号 

inline bool in_map(int x,int y){
	return 1<=x && x<=n && 1<=y && y<=m;
}//判断是否越界 

inline void add_edge(int from,int to,int flw,int val){
	e[++cnt].nxt=head[from];
	e[cnt].to=to;
	e[cnt].f=flw;
	e[cnt].w=val;
	head[from]=cnt;
}

queue<int>que;

inline bool spfa(int s,int t){
	memset(vis,0,sizeof(vis));
	memset(dis,0x3f,sizeof(dis));
	memset(flow,0x3f,sizeof(flow));
	que.push(s); vis[s]=true; dis[s]=0;
	while(!que.empty()){
		int u=fpop(que);
		for(int i=head[u];~i;i=e[i].nxt){
			int v=e[i].to;
			if(dis[v]>dis[u]+e[i].w && e[i].f){
				dis[v]=dis[u]+e[i].w;
				flow[v]=min(flow[u],e[i].f);
				pre_node[v]=u;
				pre_edge[v]=i;
				vis[v]=true;que.push(v);
			}
		}
	}
	return dis[t]!=INF;
}

int mv[8][2]={{1,0},{-1,0},{0,1},{0,-1},{1,1},{1,-1},{-1,1},{-1,-1}};

int main(){
	memset(head,-1,sizeof(head));
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;++i){
		for(int j=1;j<=m;++j){
			scanf(" %c",&mp_bg[i][j]);
		}
	}
	for(int i=1;i<=n;++i){
		for(int j=1;j<=m;++j){
			scanf(" %c",&mp_ed[i][j]);
		}
	}
	for(int i=1;i<=n;++i){
		for(int j=1;j<=m;++j){
			scanf(" %c",&ch);
			maxf[i][j]=ch-'0';
			//最大经过次数 
		}
	}
	//输入起始态和目标态棋盘
	int s=0,t=n*m*5+1;
	int cnt_1=0,cnt_2=0;
	for(int i=1;i<=n;++i){
		for(int j=1;j<=m;++j){
			if(mp_bg[i][j]==mp_ed[i][j]){
				add_edge(_inn(i,j),_mid(i,j),maxf[i][j]/2,0);
				add_edge(_mid(i,j),_inn(i,j),000000000000,0);
				
				add_edge(_mid(i,j),_out(i,j),maxf[i][j]/2,0);
				add_edge(_out(i,j),_mid(i,j),000000000000,0);
			}else{
				if(mp_bg[i][j]=='1'){
					add_edge(_inn(i,j),_mid(i,j),(maxf[i][j]+0)/2,0);
					add_edge(_mid(i,j),_inn(i,j),000000000000,0);
					
					add_edge(_mid(i,j),_out(i,j),(maxf[i][j]+1)/2,0);
					add_edge(_out(i,j),_mid(i,j),000000000000,0);
				}
				if(mp_ed[i][j]=='1'){
					add_edge(_inn(i,j),_mid(i,j),(maxf[i][j]+1)/2,0);
					add_edge(_mid(i,j),_inn(i,j),000000000000,0);
					
					add_edge(_mid(i,j),_out(i,j),(maxf[i][j]+0)/2,0);
					add_edge(_out(i,j),_mid(i,j),000000000000,0);
				}
			}
			
			if(mp_bg[i][j]=='1'){
				++cnt_1;
				//连接源点到初始点     f=1 w=0;
				add_edge(s,_bg(i,j),1,0);
				add_edge(_bg(i,j),s,0,0);
				//连接起始点到棋盘 
				add_edge(_bg(i,j),_mid(i,j),1,0);
				add_edge(_mid(i,j),_bg(i,j),0,0);
			}
			if(mp_ed[i][j]=='1'){
				++cnt_2;
				//连接终结点到汇点     f=1 w=0; 
				add_edge(_ed(i,j),t,1,0);
				add_edge(t,_ed(i,j),0,0);
				//连接棋盘到终结点 
				add_edge(_mid(i,j),_ed(i,j),1,0);
				add_edge(_ed(i,j),_mid(i,j),0,0);
			}
			//棋盘的八连通边  f=INF w=1;
			for(int k=0;k<8;++k){
				int ni=i+mv[k][0];
				int nj=j+mv[k][1];
				if(in_map(ni,nj)){
					//从点[i,j]的out连接点[ni,nj]的inn 
					add_edge(_out(i,j),_inn(ni,nj),INF,+1);
					add_edge(_inn(ni,nj),_out(i,j),000,-1);
				}
			}
		}
	}
	//棋子数变动->No solution 
	if(cnt_1!=cnt_2){
		puts("-1");
		return 0;
	}
	//然后跑费用流 
	int max_flow=0,min_cost=0;
	while(spfa(s,t)){
		max_flow+=flow[t];
		min_cost+=flow[t]*dis[t];
		int u=t;
		while(u!=s){
			e[pre_edge[u]^0].f-=flow[t];
			e[pre_edge[u]^1].f+=flow[t];
			u=pre_node[u];
		}
	}
	if(max_flow!=cnt_1){
		puts("-1");
		return 0;
	}
	printf("%d\n",min_cost);
}

```



---

## 作者：Orion545 (赞：24)

# 广告

[蒟蒻のblog](http://www.cnblogs.com/dedicatus545/p/8781976.html)

# 正文

### 抖机灵

一开始看到这题我以为是棋盘模型-\_-||

然而现实是骨感的

后来我尝试使用插头dp来交换，然后又惨死

最后我不得不把目光转向那个总能化腐朽为神奇的算法：网络流

### 思维

我们要先有一个思维的转变：要把棋盘上的“交换”操作，看成所有的黑色棋（白色棋等价）在移动

我们考虑令一个黑子往下移动一个

此时当前格子和下方格子的交换数都加一

考虑一条移动的路径，那么显然，这条路径两端的格子只进行了一次交换，但是路径上的所有格子进行了两次

我们可以考虑把这个过程变成网络流来做

但是有一个问题：一个格子如果本来就有一个黑棋，最后没有黑棋，或者本来是白棋，最后是黑棋，那么这个格子的收支会不平衡，也就是说我们硬做，连无向边的时候满足了流量平衡条件但却得不到最优解

而且如果每个格子只建一个点，也并不能把格子的交换次数限制考虑进去

那我们就要考虑拆点了

### 拆点

最基础的拆点：一个格子拆成两个，分别代表进入和走出，中间连一条容量为交换次数上限的边

但是这样有另一个问题：无法体现出路径两端的点和路径中间的点的区别（也就是如果“经过”了一个点，也只统计一点流量）

那我们再拆：把一个点拆成三个：left,now,right

从left向now连边、now向right连边，流量上限分别为限制的一半

这样就完美体现了只有流出、只有流入和流入流出都有的区别

相邻的点之间从right连向left

我们令源点向所有初始图中黑棋格子的now连边，汇点跟所有最终图中的黑棋格子的now连边，跑S-T最大流即可

### 问题

第一个大问题：如何解决上文中流量收支可能不平衡的问题？

答：如果该点是黑子->白子，那么这个点的出一定比入大一点流量；如果是白子->黑子，那么入一定比出大一点流量

第二个大问题：如何找最小？

做这个比较好办，把left-now和now-right边增加费用1就好了

### 结论&&最终实现方法

以下用<u,v,w,cap>表示u到v的有向边，费用w流量cap

建立费用流图，每个点拆成left,now,right

若该点在初始图中是黑的、最终图中是白的，那么连边(left,now,1,$\frac{limit}{2}$),(now,right,1,$\frac{limit+1}{2}$)

若该点在初始图中是白的、最终图中是黑的，那么连边(left,now,1,$\frac{limit+1}{2}$),(now,right,1,$\frac{limit}{2}$)

若该点在初始图和最终图中颜色相同，那么连边(left,now,1,$\frac{limit}{2}$),(now,right,1,$\frac{limit}{2}$)

其中limit表示这个格子的交换次数上限

建立附加源汇S-T

对于初始图中的黑点i，连边(S,now(i),0,1)

对于最终图中的黑点i，连边(now(i),T,0,1)

相邻的点i,j之间连边(right(i),left(j),0,inf)

# Code

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define inf 1e9
#define tot (n*m*3)
#define left(i,j) ((i-1)*m+j)
#define now(i,j) (((i-1)*m+j)+n*m)
#define right(i,j) (((i-1)*m+j)+(n*m<<1))
using namespace std;
inline int read(){
	int re=0,flag=1;char ch=getchar();
	while(ch>'9'||ch<'0'){
		if(ch=='-') flag=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9') re=(re<<1)+(re<<3)+ch-'0',ch=getchar();
	return re*flag;
}
const int dx[9]={0,-1,-1,-1,0,0,1,1,1},dy[9]={0,-1,0,1,-1,1,-1,0,1};
int n,cnt=-1,m,first[2010],dis[2010],vis[2010],ans=0;
struct edge{
	int to,next,w,cap;
}a[50010];
inline void add(int u,int v,int w,int cap){
	a[++cnt]=(edge){v,first[u],w,cap};first[u]=cnt;
	a[++cnt]=(edge){u,first[v],-w,0};first[v]=cnt;
}
int q[10010];
bool spfa(int s,int t){
	int head=0,tail=1,i,v,u,w;
	memset(dis,-1,sizeof(dis));memset(vis,0,sizeof(vis));
	q[0]=t;vis[t]=1;dis[t]=0;
	while(head<tail){
		u=q[head++];vis[u]=0;
		for(i=first[u];~i;i=a[i].next){
			v=a[i].to;w=a[i].w;
			if(a[i^1].cap&&((dis[v]==-1)||(dis[v]>dis[u]-w))){
				dis[v]=dis[u]-w;
				if(!vis[v]) q[tail++]=v,vis[v]=1;
			}
		}
	}
	return ~dis[s];
}
int dfs(int u,int t,int limit){
	if(u==t||!limit){vis[u]=1;return limit;}
	int i,v,f,flow=0,w;vis[u]=1;
	for(i=first[u];~i;i=a[i].next){
		v=a[i].to;w=a[i].w;
		if(!vis[v]&&a[i].cap&&dis[v]==dis[u]-w){
			if(!(f=dfs(v,t,min(limit,a[i].cap)))) continue;
			a[i].cap-=f;a[i^1].cap+=f;
			flow+=f;limit-=f;ans+=w*f;
			if(!limit) return flow;
		}
	}
	return flow;
}
int zkw(int s,int t){
	int re=0;
	while(spfa(s,t)){
		vis[t]=1;
		while(vis[t]){
			memset(vis,0,sizeof(vis));
			re+=dfs(s,t,inf);
		}
	}
	return re;
}
int x1[30][30],x2[30][30];
int main(){
	memset(first,-1,sizeof(first));
	int i,j,t1=0,t2=0,ti,tj,k;char s[30];
	n=read();m=read();
	for(i=1;i<=n;i++){
		scanf("%s",s);
		for(j=1;j<=m;j++){
			if(s[j-1]=='1'){
				t1++;add(0,now(i,j),0,1);
				x1[i][j]=1;
			}
		}
	}
	for(i=1;i<=n;i++){
		scanf("%s",s);
		for(j=1;j<=m;j++){
			if(s[j-1]=='1'){
				t2++;add(now(i,j),tot+1,0,1);
				x2[i][j]=1;
			}
		}
	}
	if(t1!=t2){
		puts("-1");return 0;
	}
	for(i=1;i<=n;i++){
		scanf("%s",s);
		for(j=1;j<=m;j++){
			t2=s[j-1]-'0';
			if(x1[i][j]==x2[i][j]) 
				add(left(i,j),now(i,j),0,t2/2),add(now(i,j),right(i,j),0,t2/2);
			if(x1[i][j]&&!x2[i][j])
				add(left(i,j),now(i,j),0,t2/2),add(now(i,j),right(i,j),0,(t2+1)/2);
			if(!x1[i][j]&&x2[i][j])
				add(left(i,j),now(i,j),0,(t2+1)/2),add(now(i,j),right(i,j),0,t2/2);
		}
	}
	for(i=1;i<=n;i++){
		for(j=1;j<=m;j++){
			for(k=1;k<=8;k++){
				ti=i+dx[k];tj=j+dy[k];
				if(ti<1||ti>n||tj<1||tj>m) continue;
				add(right(i,j),left(ti,tj),1,inf);
			}
		}
	}
	if(zkw(0,tot+1)!=t1){
		puts("-1");return 0;
	}
	cout<<ans<<endl;
}
```

---

## 作者：FlierKing (赞：16)

使用费用流解决本题，设点![](http://latex.codecogs.com/gif.latex?p[i][j])的参与交换的次数上限为![](http://latex.codecogs.com/gif.latex?v[i][j])，以下为建图方式：

1. 将一个点分成三个点，分别为入点，原点和出点。

2. 如果开始的图上该位置有棋子，那么从S到该点的原点连一条边权1，费用0的边

3. 如果结束的图上该位置有棋子，那么从该点的原点到T连一条边权1，费用0的边

4. 如果该点只在开始的图上出现，那么从该点的入点向原点连一条边权为![](http://latex.codecogs.com/gif.latex?\frac{v[i][j]}{2})，费用为1的边，从该点的原点向出点连一条边权为![](http://latex.codecogs.com/gif.latex?\frac{v[i][j]+1}{2})，费用为0的边

5. 如果该点只在结束的图上出现，那么从该点的入点向原点连一条边权为![](http://latex.codecogs.com/gif.latex?\frac{v[i][j]+1}{2})，费用为1的边，从该点的原点向出点连一条边权为![](http://latex.codecogs.com/gif.latex?\frac{v[i][j]}{2})，费用为0的边

6. 如果以上两点都不符合，那么从该点的入点向原点连一条边权为![](http://latex.codecogs.com/gif.latex?\frac{v[i][j]}{2})，费用为1的边，从该点的原点向出点连一条边权为![](http://latex.codecogs.com/gif.latex?\frac{v[i][j]}{2})，费用为0的边


本代码使用zkw费用流

```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
#include <vector>
#include <cstdlib>
#include <ctime>
#include <algorithm>
#define ll long long
#define INF 715827882 
#define N 1205
#define M 10000
using namespace std;
    int n,m,S,T,sz=1,res,st,en,tot,cnt,ad1,ad2,ls;
    int to[M],nex[M],las[N],cost[M],dist[N],Q[M],v[M];
    bool mark[N];
    char ch[3][50][50];
    const int wx[]={-1,-1,-1,0,1,1,1,0};
    const int wy[]={-1,0,1,1,1,0,-1,-1};
int inline read()
{
    int x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
void ins(int x,int y,int z=1,int u=0)
{
    sz++;to[sz]=y;v[sz]=z;cost[sz]=u;nex[sz]=las[x];las[x]=sz;
    sz++;to[sz]=x;v[sz]=0;cost[sz]=-u;nex[sz]=las[y];las[y]=sz;
}
inline int ts(const int &x,const int &y){return (x-1)*m+y;}
void init()
{
    int nx,ny,tmp;
    for (int i=1;i<=n;i++)
    {
        scanf("%s",ch[0][i]+1);
        for (int j=1;j<=m;j++)
            if (ch[0][i][j]=='1') ins(S,n*m+ts(i,j)),cnt++;
    }
    for (int i=1;i<=n;i++)
    {
        scanf("%s",ch[1][i]+1);
        for (int j=1;j<=m;j++)
            if (ch[1][i][j]=='1') ins(n*m+ts(i,j),T);
    }
    for (int i=1;i<=n;i++)
    {
        scanf("%s",ch[2][i]+1);
        for (int j=1;j<=m;j++)
        {
            tmp=ts(i,j);
            if (ch[0][i][j]=='0'&&ch[1][i][j]=='1') ad1=1,ad2=0;
            else if (ch[0][i][j]=='1'&&ch[1][i][j]=='0') ad1=0,ad2=1;
            else ad1=ad2=0;
            ins(tmp,n*m+tmp,(ch[2][i][j]-'0'+ad1)/2,1);
            ins(n*m+tmp,2*n*m+tmp,(ch[2][i][j]-'0'+ad2)/2,0);
            for (int k=0;k<8;k++)
            {
                nx=i+wx[k],ny=j+wy[k];
                if (nx>0&&ny>0&&nx<=n&&ny<=m) ins(2*n*m+tmp,ts(nx,ny),INF,0);
            }
        }
    }
}
bool spfa()
{
    memset(dist,127/3,sizeof(dist));
    memset(mark,0,sizeof(mark));
    st=en=N;Q[N]=T;mark[T]=1;
    dist[T]=0;
    while (st<=en)
    {
        int tmp=Q[st++];
        mark[tmp]=0;
        for (int i=las[tmp];i;i=nex[i])
        if (v[i^1]&&dist[to[i]]>dist[tmp]-cost[i])
        {
            dist[to[i]]=dist[tmp]-cost[i];
            if (!mark[to[i]])
            {
                mark[to[i]]=1;
                if (st<=en&&dist[to[i]]<dist[st])
                    Q[--st]=to[i];
                else
                    Q[++en]=to[i];
            }
        }
    }
    return dist[0]!=dist[S];
}
int dfs(int x,int F)
{
    mark[x]=true;
    if (x==T) return F;
    int w,used=0;
    for (int i=las[x];i;i=nex[i])
    if (v[i]>0&&!mark[to[i]]&&dist[x]-cost[i]==dist[to[i]])
    {
        w=min(v[i],F-used);
        w=dfs(to[i],w);
        v[i]-=w,v[i^1]+=w,used+=w;
        if (used==F) return F;
    }
    return used;
}
int main()
{
    n=read(),m=read();
    S=3*n*m+1,T=S+1;
    init();
    while (spfa())
    {
        memset(mark,0,sizeof(mark));
        tot+=ls=dfs(S,INF);
        res+=ls*dist[S];
    }
    printf("%d",tot==cnt?res:-1);
    return 0;
}
```

---

## 作者：zubizakeli (赞：14)

其实这道题完全不用拆三个点啊... 拆成两个点照样可以A

其实难点无非就是起点和终点只通过一次，路径上的其余点要通过两次。

我们先不考虑起点和终点，那么路径上的格子其实每经过一个棋子就要被翻转两次，所以我们让通过次数除以2就可以了。

再考虑起点和终点，如果一个格子既是起点又是终点，显然可以不用管它,当做这里没有棋子处理即可。

对于一个是起点或终点的格子，我们可以先给他留出一个初始通过的交换次数，即让以该格子为起点的棋子离开，然后剩下的就按照这个格子是路径上的点处理即可，即容量为(w-1)/2+1。

于是就可以拆成两个点做辣qwq  (安利一波自己的博客：[传送门](http://www.cnblogs.com/zub23333/p/8849559.html)

```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<queue>
#include<bitset>
#define dx(i,j) ((i-1)*m+j)
#define dy(i,j) ((i-1)*m+j+400)
using namespace std ;
const int INF = 0x7ffffff ;
const int N = 20 + 2 ;
const int FN = 800 + 10 ;
const int M = 1e6 + 10 ;

const int cx[] = {-1,-1,-1,0,0,1,1,1} ;
const int cy[] = {1,0,-1,1,-1,1,0,-1} ;

inline int read() {
    int k = 0, f = 1 ; char c = getchar() ;
    for( ; !isdigit(c) ; c = getchar())
      if(c == '-') f = -1 ;
    for( ; isdigit(c) ; c = getchar())
      k = k*10 + c-'0' ;
    return k*f ;
}
struct Edge {
    int to, next, flow, cost ;
}e[M] ;
int n, m, s, t, ansf, ansc ; int head[FN], dis[FN] ; bool hh[N][N], gg[N][N], vis[FN] ;
inline void add_edge(int x,int y,int ff,int cc) {
    static int cnt = 1 ;
    e[++cnt].to = y, e[cnt].next = head[x], head[x] = cnt, e[cnt].flow = ff, e[cnt].cost = cc ;
    e[++cnt].to = x, e[cnt].next = head[y], head[y] = cnt, e[cnt].flow = 0, e[cnt].cost = -cc ;
}

inline bool spfa() {
    for(int i=1;i<=t;i++) dis[i] = INF ; dis[s] = 0 ;
    deque<int>q ; q.push_back(s) ; bitset<FN>inq ; inq[s] = 1 ;
    while(!q.empty()) {
        int x = q.front() ; q.pop_front() ; inq[x] = 0 ;
        for(int i=head[x];i;i=e[i].next) {
            int y = e[i].to ; if(!e[i].flow) continue ;
            if(dis[y] > dis[x]+e[i].cost) {
                dis[y] = dis[x]+e[i].cost ;
                if(!inq[y]) {
                    inq[y] = 1 ;
                    if(!q.empty() && dis[y] < dis[q.front()]) q.push_front(y) ;
                    else q.push_back(y) ;
                }
            }
        }
    }
    return dis[t] < INF ;
}
int FFdfs(int x,int minflow) {
    vis[x] = 1 ;
    if(x == t || !minflow) return minflow ;
    int fflow = 0 ;
    for(int i=head[x];i;i=e[i].next) {
        int y = e[i].to ; if(!e[i].flow || vis[y] || dis[y] != dis[x]+e[i].cost) continue ;
        int temp = FFdfs(y,min(minflow,e[i].flow)) ;
        fflow += temp, minflow -= temp ;
        e[i].flow -= temp, e[i^1].flow += temp ;
        ansc += temp*e[i].cost ;
        if(!minflow) break ;
    }
    return fflow ;
}

int main() {
    n = read(), m = read() ; s = 801, t = s+1 ; int tot = 0, tot1 = 0 ;
    for(int i=1;i<=n;i++) 
      for(int j=1;j<=m;j++) {
      	 char cc ; cin>>cc ; 
      	 if(cc == '1') {
      	 	hh[i][j] = 1, tot1++ ;
         }
      }
    for(int i=1;i<=n;i++) 
      for(int j=1;j<=m;j++) {
      	 char cc ; cin>>cc ;
      	 if(cc == '1') {
      	 	gg[i][j] = 1, tot++ ;
         }
      }
    while(tot != tot1) {
        printf("-1") ; return 0 ;
    } tot = 0 ;
    for(int i=1;i<=n;i++)
      for(int j=1;j<=m;j++) {
      	 if(hh[i][j] && !gg[i][j]) add_edge(s,dx(i,j),1,0), tot++ ;
         else if(!hh[i][j] && gg[i][j]) add_edge(dy(i,j),t,1,0) ; 
      }
    for(int i=1;i<=n;i++) 
      for(int j=1;j<=m;j++) {
      	 char cc ; cin>>cc ; int x = cc-'0' ; 
      	 add_edge(dx(i,j),dy(i,j),x>>1,0) ;
      	 if(hh[i][j] != gg[i][j] && x&1) add_edge(dx(i,j),dy(i,j),1,0) ;
      	 for(int k=0;k<8;k++) {
      	 	int xx = i+cx[k], yy = j+cy[k] ; if(!xx || !yy || xx > n || yy > m) continue ;
      	 	add_edge(dy(i,j),dx(xx,yy),INF,1) ;
         }
      }
    while(spfa()) {
        vis[t] = 1 ;
        while(vis[t]) {
            memset(vis,0,sizeof(vis)) ;
            ansf += FFdfs(s,INF) ;
 		}
    } 
    if(ansf < tot) {
        printf("-1") ; return 0 ;
    }
    printf("%d",ansc) ;
    return 0 ;
}
```

---

## 作者：ironwheel (赞：8)

## 题解 P3159  [CQOI2012] 交换棋子

### 题目描述

有一$n$行$m$列的黑白棋盘，你每次可以交换两个相邻格子（相邻是指有公共边或公共顶点）中的棋子，最终达到目标状态。要求第$i$行第$j$列的格子只能参与$m_{i,j}$次交换。先给出求达到目标状态的最小交换次数。



#### 输入样例1                                                               输出样例1

```cassandra
3 3                                              4
110
000
001
000
110
100
222
222
222
```

#### 数据范围



$1 <= m,n <= 20$



### 解题思路

#### 思路的确定

首先当我们看到这种数据范围的时候，

**这不是标准状压吗？**

但是这是网络流。显然不能状压。爆搜肯定惨死。

看到这种题，就会想到从起始棋盘向目标状态连边。交换次数自然就是费用。

同时，棋子的交换也可以视为流量的转移。

**于是我们给这道题定了性：最小费用最大流**

但是有一些小问题：比如我们选取了一条路径：$(1,1) -> (2,2)$

我们需要交换两次：$swap((1,1),(1,2))$      $swap((1,2),(2,2))$

于是中间的节点使用了两次的交换次数。
如果我们只是把点拆成一条边，很难处理这个节点到底是中间点、起始点还是目标点。

所以我们考虑拆点。

#### 拆点

这道题采用了一个蛇皮的方法，当时我没有想到，应该是我太菜了。

基础的拆点可以将一个节点拆成入点和出点。但是这道蛇皮的题是要将每个格子拆成三个点的：$in$,$mid$,$out$。

![无标题](https://cdn.luogu.com.cn/upload/pic/60563.png)

我们把起始状态中每一个有黑棋子的点连向原点，目标状态中每一个有黑棋子的点连向汇点。

把这些点向拆完的格子连边。

从每一个格子的$out$点向与这个格子联通的格子的$in$点连边。

现在有以下几种情况。我们用$<a,b>$这个数对表示起始是否为黑，目标是否为黑。

$<1,0>$

![无标题](https://cdn.luogu.com.cn/upload/pic/60565.png)

图中蓝色的边表示水流方向。

解释一下：起始状态下有黑子，但是目标状态没有黑子，所以$mid -> end$  这条边流量为0。

这个黑子（也可以视为水流）就会流向$out$，向下一个格子的$in$流去。



$<0,1>$

![无标题](https://cdn.luogu.com.cn/upload/pic/60566.png)

起始状态没有黑子。没有流量流向mid。

但是目标状态有黑子。所以只会有从上一个格子跑过来的棋子流向$end$。$mid -> end$ 流量为1。



$<0,0>$



![无标题](https://cdn.luogu.com.cn/upload/pic/60567.png)

这个格子只能当中转站。





$<1,1>$

![无标题](https://cdn.luogu.com.cn/upload/pic/60568.png)

一通狂流即可。

#### 小提问

碰到$<1,1>$能不能直接不连呢？



显然答案是否定的。这个点还可以当中转点。

------

至此，连边部分就结束了。



等等，还有一些小问题！

#### 小问题

$in -> mid$ 以及 $mid -> out$ 的流量怎么办？

考虑将$m_{i,j}$均等分配即可。

这样子这题就可以过了。

等等，还有一些小问题！

#### 真的可以过吗？

\#1**AC**6ms/3364KB #2**AC**20ms/3376KB \#3**AC**6ms/3356KB #4**WA** #5**WA** #6**WA** #7**WA** #8**WA**  #9**WA** #10**WA**

（我不会用笔记本截图）



当$m_{i,j}$是奇数的时候，交换次数就会莫名其妙地少掉一个。

所以我们要考虑将这一个流量给到哪里。继续分类讨论。

$<0,0>$

由于这个点只能当中转站，所以不能分配这一个流量。要保证$in -> mid$与$mid -> out$的流量相同。要不然就会出现一个黑点流进来却流不出去，或者是黑点流不进来$mid -> out$却莫名其妙多出来一个流量。

$<1,1>$

同上。

$<1,0>$

除了均分的交换次数之外，有一个黑点需要流出去。所以分配给$mid -> out$这条边。

$<0,1>$

除了均分的交换次数之外，有一个黑点要流进来。所以分配给$in -> mid$这条边。

这样子就可以过了。

```
#include<bits/stdc++.h>

using namespace std;

const int N = 3e5;
const int inf = 1e9;

int cnt = 1, sum = 0, n, m, s = 1e4, t = s + 1, cost = 0, tmp = 0, dd = 0;

struct dt{
    int to, val, w, next;
}e[N];

int dt[N], dep[N], cur[N], dis[N];

char beg[21][21], lst[21][21], f[21][21];

bool vis[N];

void add(int x, int y, int value, int wa){
    cnt++;
    e[cnt].to = y;
    e[cnt].val = value;
    e[cnt].w = wa;
    e[cnt].next = dt[x];
    dt[x] = cnt;
    cnt++;
    e[cnt].to = x;
    e[cnt].val = 0;
    e[cnt].w = -wa;
    e[cnt].next = dt[y];
    dt[y] = cnt;
}

bool /*SPFA*/dijstra(){
    memset(vis, 0, sizeof(vis));
    memset(dis, 0x3f, sizeof(dis));
    for(int i = 0; i <= N; i++)cur[i] = dt[i];
    queue<int> q;
    q.push(s);
    vis[s] = 1;
    dis[s] = 0;
    while(!q.empty()){
        int u = q.front();
        vis[u] = 0;
        q.pop();
        for(int i = dt[u]; i; i = e[i].next){
            int v = e[i].to, w = e[i].w;
            if(e[i].val > 0 && dis[v] > dis[u] + w){
                dis[v] = dis[u] + w;
                //cout << v << " " << pre[v].fa << endl;
                if(!vis[v]){
                    q.push(v);
                    vis[v] = 1;
                }
            }
     	}
    }
    return dis[t] < 0x3f3f3f3f;
}

int dfs(int now, int low){
    if(now == t) return low;
    int flow = 0;
    vis[now] = 1;
    for(int i = cur[now]; i; i = e[i].next){
        cur[now] = i;
        int v = e[i].to;
        if(!vis[v] && e[i].val && dis[v] == dis[now] + e[i].w){
            if(flow = dfs(v, min(low, e[i].val))){
                e[i].val -= flow;
                e[i ^ 1].val += flow;
                cost += e[i].w * flow;
                return flow;
            }
        }
    }
    return 0;
}

int dinic(){
    int minflow, maxflow = 0;
    while(dijstra()){
        while(minflow = dfs(s, inf)){
            memset(vis, 0, sizeof(vis));
            maxflow += minflow;
        }
    }
    return maxflow;
}

int begin(int i, int j){return (i - 1) * m + j;}
int last(int i, int j){return n * m * 1 + (i - 1) * m + j;}
int in(int i, int j){return n * m * 2 + (i - 1) * m + j;}
int mid(int i, int j){return n * m * 3 + (i - 1) * m + j;}
int out(int i, int j){return n * m * 4 + (i - 1) * m + j;}

int x[8] = {0, 0, 1, -1, 1, 1, -1, -1}, y[8] = {1, -1, 0, 0, 1, -1, 1, -1};

int main(){
    cin >> n >> m;
    for(int i = 1; i <= n; i++)
        for(int j = 1; j <= m; j++){
            char c;
            cin >> c;
            beg[i][j] = c - '0';
        }
    for(int i = 1; i <= n; i++)
        for(int j = 1; j <= m; j++){
            char c;
            cin >> c;
            lst[i][j] = c - '0';
        }
    for(int i = 1; i <= n; i++)
        for(int j = 1; j <= m; j++){
            char c;
            cin >> c;
            f[i][j] = c - '0';
        }
    for(int i = 1; i <= n; i++){
        for(int j = 1; j <= m; j++){
            if(beg[i][j] == lst[i][j]){
                add(in(i, j), mid(i, j), f[i][j] >> 1, 0);
                add(mid(i, j), out(i, j), f[i][j] >> 1, 0);
            }
            else{
                if(beg[i][j] == 1){
                    add(in(i, j), mid(i, j), f[i][j] >> 1, 0);
                    add(mid(i, j), out(i, j), (f[i][j] + 1) >> 1, 0);
                }
                if(lst[i][j] == 1){
                    add(in(i, j), mid(i, j), (f[i][j] + 1) >> 1, 0);
                    add(mid(i, j), out(i, j), f[i][j] >> 1, 0);
                }
            }
            
            if(beg[i][j] == 1){
				tmp++;
                add(s, begin(i, j), 1, 0);
                add(begin(i, j), mid(i, j), 1, 0);
            }
            if(lst[i][j] == 1){
				dd++;
                add(last(i, j), t, 1, 0);
                add(mid(i, j), last(i, j), 1, 0);
            }
			for(int k = 0; k < 8; k++){
            	int xx = i + x[k], yy = j + y[k];
            	if(xx < 1 || xx > n || yy < 1 || yy > m) continue;
            	add(out(i, j), in(xx, yy), inf, 1);
        	}
        }
    }
    if(tmp != dinic()) cout << -1 << endl;
    else cout << cost << endl;
}
```





---

## 作者：Awar3ness (赞：3)

对于这题第一反应就是搜，然而状态数太多了，根本过不了。

第二反应是能不能钦定一些点的目标点然后dp，然而不能钦定啊，因为根本没法求哪个和哪个匹配。

然后突然发现一个道理就是任何两个棋子在交换过程中路径一定不会相交，因为相交的话肯定可以交换两个棋子的后半段路径使得不相交。

这样每个棋子的移动都是独立的了，只要满足交换限制就行了。

于是就可以想到网络流。

拆点是必须的，但是冷静思考一下发现只拆两个点好像非常难做，反正我太菜了不会，但是我们可以把它拆成三个点，我们把棋子的移动看成黑棋子在走，那么黑棋子从a走到b，我们就称a交换了b，b被a交换。然后对于每个黑棋子，它的起点只会交换别人，对于每个黑棋子，它的终点只会被交换，所以我们把三个点串起来，如果某个点开始是黑色就从源点连边到中间点，结束是黑色就从中间点连边到汇点，一个点的右点和别的可达点的左点连边，走右边表示交换了别人，走左边表示被交换，那么就可以很好地解决这个问题了。

需要思考的是流量的分配。费用不用多说，两个不同格子之间的连边费用为1别的都是0就行了，流量的话如果它不是起始点也不是结束点就给两个边均摊，奇数剩下的1不用管，是起始点的话剩下的1给右边，是结束点的话剩下的1给左边。

总结如下：

S向所有起始格子中间点连(1,0)的边；

所有结束格子中间点向T连(1,0)的边；

每个格子左点向中间点，中间点向右点连(a,0)的边，注意奇数时起始点结束点多分配的流量；

每个格子的右点向八连通的格子的左点连(inf,1)的边；

如果未能满流，则无解，否则最小费用最大流即为答案。

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define N 1500
#define can (x>=1&&y>=1&&x<=n&&y<=m)
#define F(i,a,b) for(int i=a;i<=b;i++)
int n,m,x,y,h,f,g[25][25][3],tot=1,cnt,he[N],ne[N*100],to[N*100],v[N*100],c[N*100],dis[N],inq[N],mxf[N],pre[N];
int X[]={-1,-1,-1,0,0,1,1,1},Y[]={-1,0,1,-1,1,-1,0,1};
char s[25][25],t[25][25],a[25][25];
void add(int x,int y,int z,int f)
{
    to[cnt]=y;ne[cnt]=he[x];v[cnt]=z;c[cnt]=f;he[x]=cnt++;
    to[cnt]=x;ne[cnt]=he[y];v[cnt]=0;c[cnt]=-f;he[y]=cnt++;
}
int bfs(int S,int T)
{
    memset(dis,0x3f,sizeof(dis));memset(inq,0,sizeof(inq));
    dis[S]=0;inq[S]=1;mxf[S]=2e9;queue<int>q;q.push(S);
    while(!q.empty())
    {
        int x=q.front();q.pop();inq[x]=0;
        for(int i=he[x],y;~i;i=ne[i]) if(dis[y=to[i]]>dis[x]+c[i]&&v[i])
        {
            dis[y]=dis[x]+c[i];mxf[y]=min(mxf[x],v[i]);pre[y]=i;
            if(!inq[y]) inq[y]=1,q.push(y);
        }
    }
    return dis[T]<1e9;
}
int mcmf(int S,int T)
{
    int g=0,f=0;
    for(;bfs(S,T);g+=dis[T]*mxf[T],f+=mxf[T]) for(int x=T,i;x!=S;x=to[i^1]) i=pre[x],v[i]-=mxf[T],v[i^1]+=mxf[T];
    return f<h?-1:g;
}
int main()
{
    scanf("%d%d",&n,&m);memset(he,-1,sizeof(he));
    F(i,1,n) scanf("%s",s[i]+1);
    F(i,1,n) scanf("%s",t[i]+1);
    F(i,1,n) scanf("%s",a[i]+1);
    F(i,1,n) F(j,1,m) if(s[i][j]=='1'&&t[i][j]=='1') s[i][j]=t[i][j]='0';
    F(i,1,n) F(j,1,m) F(k,0,2) g[i][j][k]=++tot;
    F(i,1,n) F(j,1,m) if(s[i][j]=='1') add(0,g[i][j][1],1,0),h++;
    F(i,1,n) F(j,1,m) if(t[i][j]=='1') add(g[i][j][1],1,1,0);
    F(i,1,n) F(j,1,m) add(g[i][j][0],g[i][j][1],(a[i][j]-'0')/2,0);
    F(i,1,n) F(j,1,m) add(g[i][j][1],g[i][j][2],(a[i][j]-'0')/2,0);
    F(i,1,n) F(j,1,m) if(s[i][j]=='1'&&(a[i][j]-'0')&1) add(g[i][j][1],g[i][j][2],1,0);
    F(i,1,n) F(j,1,m) if(t[i][j]=='1'&&(a[i][j]-'0')&1) add(g[i][j][0],g[i][j][1],1,0);
    F(i,1,n) F(j,1,m) F(k,0,7) {x=i+X[k],y=j+Y[k];if(can) add(g[i][j][2],g[x][y][0],1e9,1);}
    printf("%d\n",mcmf(0,1));
}
```

---

## 作者：Epworth (赞：1)

求棋盘上一个状态转移到另一个状态的最小交换次数，考虑费用流。

因为任意两个棋子交换要消耗两次交换次数(两个格子一次)，所以考虑拆点。

但如果像平常拆点那样将每个点拆为入点和出点也有问题。

因为在一次连续的交换中，路径上的并非每个格子都消耗了两次交换机会。

左右端点一个换出去一次，一个换进来一次，中间的进来出去各一次。

从初态和末态来看，点的转移分为三种情况：(假定转移黑色)

①初态是黑色，末态是白色，交换出去比交换进来的次数要多一。

②初态是白色，末态是黑色，交换进来比交换出去的次数要多一。

③出态末态同色，交换进来与出去的次数相同(相当于一个中继站)。



所以考虑将一个点拆成三个：入点，中点，出点。

建图流程：

$S=>mid$(初态黑色) $f=1$，$w=0$

$mid$(末态黑色)$=>T$  $f=1$，$w=0$

棋盘内部八联通 $out=>in$ $f=INF$，$w=1$

$每个点内部连接$in=>mid=>out$ $w=0$，根据初末态情况决定容量是$(xx+1)/2$还是$xx/2$



为什么这样可以处理两端的边界情况勒?

因为$s$和$t$都是连接点的$mid$部分，在每一次连续交换中：

起点是黑色，只会换出去一次$mid=>out$

终点是白色，只会换进来一次$in=>mid$

中间点进去一次出来一次$in=>mid=>out$

正好满足要求。



注意在判断是否有解的时候分为两种情况:

①初态黑棋子数量与末态黑棋子数量不等，显然无解。

②最大流流量与黑棋数量不等，无解。

## 代码
```cpp
#include<bits/stdc++.h>
#define maxn 1000005
#define inf 0x3f3f3f3f
using namespace std;
int n,m;
int s,t;
struct data{
    int to;
    int p;
    int val;
    int nextt;
}line[maxn];
int first[maxn];
int tail=1;
void add(int x,int y,int w,int c){
    tail++;
    line[tail].to=y;
    line[tail].p=w;
    line[tail].val=c;
    line[tail].nextt=first[x];
    first[x]=tail;
    swap(x,y);
    tail++;
    line[tail].to=y;
    line[tail].val=-c;
    line[tail].nextt=first[x];
    first[x]=tail;
}
int dist[maxn];
int inqueue[maxn];
int pre_node[maxn];
int pre_edge[maxn];
queue<int> q;
bool SPFA(){
    while(!q.empty()) q.pop(); 
    memset(dist,0x3f,sizeof(dist));
    memset(inqueue,0,sizeof(inqueue));
    dist[s]=0;
    inqueue[s]=1;
    q.push(s);
    while(!q.empty()){
        int x=q.front();
        inqueue[x]=0;
        q.pop();
        for(int i=first[x];i;i=line[i].nextt){
            int y=line[i].to;
            int w=line[i].p;
            int c=line[i].val;
            if(w&&dist[y]>dist[x]+c){
                dist[y]=dist[x]+c;
                pre_node[y]=x;
                pre_edge[y]=i;
                if(inqueue[y]==0){
                    inqueue[y]=1;
                    q.push(y);	
                }
            }
        }
    }
    return dist[t]!=inf;
}
int tot1,tot2; 
int EK(){
    int ansf=0,ansc=0;
    while(SPFA()){
        int flow=inf;
        for(int i=t;i!=s;i=pre_node[i]){
            flow=min(flow,line[pre_edge[i]].p);
        }
        for(int i=t;i!=s;i=pre_node[i]){
            line[pre_edge[i]].p-=flow;
            line[pre_edge[i]^1].p+=flow;
        }
        ansf+=flow;
        ansc+=flow*dist[t];
    }
    return ansf==tot2?ansc:-1;
}
int pos(int k,int x,int y){
    return (k-1)*n*m+(x-1)*m+y;
}
int dx[9]={0,-1,-1,-1,0,0,1,1,1};
int dy[9]={0,-1,0,1,-1,1,-1,0,1};
int to[100][100];
int from[100][100];
char x;
int main(){
	cin>>n>>m;
	s=3*n*m+1;t=s+1;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            for(int k=1;k<=8;k++){
                int ti=i+dx[k];
				int tj=j+dy[k];
                if(ti<1||ti>n||tj<1||tj>m) continue;
                add(pos(3,i,j),pos(1,ti,tj),inf,1);
            }
        }
    }
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cin>>x; from[i][j]=x-'0';
			if(from[i][j]) tot1++,add(s,pos(2,i,j),1,0);			
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cin>>x; to[i][j]=x-'0';
			if(to[i][j]) tot2++,add(pos(2,i,j),t,1,0);
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cin>>x; int xx=x-'0';
			if(from[i][j]&&!to[i][j]){
				add(pos(1,i,j),pos(2,i,j),xx/2,0);	
				add(pos(2,i,j),pos(3,i,j),(xx+1)/2,0);
			}
			if(!from[i][j]&&to[i][j]){
				add(pos(1,i,j),pos(2,i,j),(xx+1)/2,0);	
				add(pos(2,i,j),pos(3,i,j),xx/2,0);
			}
			else{
				add(pos(1,i,j),pos(2,i,j),xx/2,0);	
				add(pos(2,i,j),pos(3,i,j),xx/2,0);
			}
		}
	}
	if(tot1!=tot2) puts("-1");
	else cout<<EK()<<endl;
	return 0;
}

```

---

## 作者：⚡114514_zzm⚡ (赞：0)

首先判掉起始状态和目标状态黑色棋子不等的情况（无解），下面默认两种状态黑色棋子相等。

我们可以发现，交换两个同色棋子是毫无意义的，交换两个异色格子，相当于把黑色格子移动了一步。

所以我们这个题可以转化为这样一个模型：

给定一些黑色棋子的初始位置，再给定一些目标位置，你每次可以将一个黑色棋子向相邻的格子移动，在满足限制的情况下，如何移动才能使得所有终止位置上都有一个黑色棋子且移动次数最少？

我们需要知道一个事实，给出任意一个移动方案，都可以调整移动顺序使得移动的过程中棋子不会重叠，**所以我们可以认为每个棋子的移动是独立的**。所以这个模型可以转化为费用流：建立源点汇点，将每个格子看做一个点。考虑所有格子，如果初始和目标状态的棋子颜色相同，就不考虑它。如果初始为黑（意味着目标为白），从源点向这个格子连边；如果初始为白（意味着目标为黑），从这个格子连边向汇点连边。

然后就是相邻的格子直接连边，费用设置为 11。重要的是如何用流量表示限制，将一个格子代表的点拆为 2 个（一个负责连入边，一个负责连出边），我们考虑拆出的两个点之间的流量限制 c。对于这个格子，题目限制的是「参与交换的次数 m_{i, j}」，而我们这个拆的这两个点之间的流量代表的是「经过的次数」。由于一次交换有两个点参与，所以这个流量不能 c 单的设置为 m_{i, j}，需要分析性质。

我们考虑如何用交换实现黑棋子的移动： v_1-> v_2->...->v_k ，相邻两个格子都要交换一次。其中 v_1和 v_k 只被交换了 1次，其余的都被交换了 2次。

也就是说，如果一个格子作为起点或者终点（就是向源点或者汇点连了边），它会被交换奇数次，否则它被交换偶数次。考虑「参与交换的次数」与「经过的次数」之间的关系，对于非起点非终点的格子，「参与交换的次数」= 2 *「经过的次数」，所以只需要将这种点限制经过 \lfloor \frac {m_{i, j}}2\rfloor 次。对于起点或者终点，「参与交换的次数」 = 2 * 「经过的次数」 - 1，**所以只需要将这种点限制经过 \lfloor \frac {m_{i, j}} 2 + 1\rfloor次即可。**   

跑**最小费用流**，满流则有解，否则无解。由于一次移动对应一次交换，所以最小费用即为最小交换次数。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
inline int readInt() {
	static int n, ch;
	n = 0, ch = getchar();
	while (!isdigit(ch)) ch = getchar();
	while (isdigit(ch)) n = n * 10 + ch - '0', ch = getchar();
	return n;
}
const int MAX_N = 20 + 3, MAX_M = 20 + 3, INF = 0x3f3f3f3f;
namespace MinCostMaxFlow {
	const int MAX_NODE = MAX_N * MAX_M * 2 + 2;
	struct edge {
		int to, cost, cap, rev;
		edge(int to, int cost, int cap, int rev): to(to), cost(cost), cap(cap),
		rev(rev) {}
	};
	vector<edge> G[MAX_NODE];
	inline void addEdge(int f, int t, int cap, int cost) {
	G[f].push_back(edge(t, cost, cap, G[t].size()));
	G[t].push_back(edge(f, -cost, 0, G[f].size() - 1));
	}
	int dis[MAX_NODE], preve[MAX_NODE], prevv[MAX_NODE];
	bool inq[MAX_NODE];
	int minCostMaxFlow(int s, int t, int flow) {
		int ans = 0;
		while (flow) {
			queue<int> q;
			memset(dis, 0x3f, sizeof dis);
			memset(inq, 0, sizeof inq);
			q.push(s), dis[s] = 0;
				while (!q.empty()) {
				int u = q.front(); q.pop();
				inq[u] = false;
				for (int i = 0; i < (int)G[u].size(); ++i) {
					edge &e = G[u][i];
					if (e.cap && e.cost + dis[u] < dis[e.to]) {
						dis[e.to] = dis[u] + e.cost;
						prevv[e.to] = u, preve[e.to] = i;
						if (!inq[e.to]) q.push(e.to), inq[e.to] = true;
					}
				}
			}
			if (dis[t] == INF) return -1;
			int d = flow;
			for (int u = t; u != s; u = prevv[u]) d = min(d, G[prevv[u]][preve[u]].cap);
			ans += d * dis[t], flow -= d;
			for (int u = t; u != s; u = prevv[u]) {
				edge &e = G[prevv[u]][preve[u]];
				e.cap -= d;
				G[e.to][e.rev].cap += d;
			}
		}
		return ans;
	}
}
using namespace MinCostMaxFlow;
int n, m;
char A[MAX_N][MAX_N], B[MAX_N][MAX_M], C[MAX_N][MAX_M];
#define ID(i, j) ((i) * m + (j))
inline bool check(int x, int y) {
	return x >= 0 && x < n && y >= 0 && y < m;
}
int main() {
	#ifdef DEBUG
	freopen("test.in", "r", stdin);
	#endif
	n = readInt(), m = readInt();
	for (int i = 0; i < n; ++i) scanf("%s", A[i]);
	for (int i = 0; i < n; ++i) scanf("%s", B[i]);
	for (int i = 0; i < n; ++i) scanf("%s", C[i]);
	int S = n * m * 2, T = n * m * 2 + 1, c = 0, cnt = 0;
	for (int i = 0; i < n; ++i)
		for (int j = 0; j < m; ++j) {
			if (A[i][j] == '1') ++c;
			if (B[i][j] == '1') --c;
			if (A[i][j] == B[i][j]) addEdge(ID(i, j) * 2, ID(i, j) * 2 + 1,
			(C[i][j] - '0') / 2, 0);
			else addEdge(ID(i, j) * 2, ID(i, j) * 2 + 1, (C[i][j] - '0' + 1) /2, 0);
			for (int k = 0; k < 8; ++k) {
				static const int dx[] = {0, 0, 1, 1, 1, -1, -1, -1}, dy[] = {1,-1, 0, 1, -1, 0, 1, -1};
				int x = i + dx[k], y = j + dy[k];
				if (check(x, y)) addEdge(ID(i, j) * 2 + 1, ID(x, y) * 2, INF,1);
			}
		}
	for (int i = 0; i < n; ++i)
	for (int j = 0; j < m; ++j)
	if (A[i][j] == '1' && B[i][j] == '0') addEdge(S, ID(i, j) * 2, 1,
	0), ++cnt;
	for (int i = 0; i < n; ++i)
	for (int j = 0; j < m; ++j)
	if (B[i][j] == '1' && A[i][j] == '0') addEdge(ID(i, j) * 2 + 1, T,1, 0);
	if (c != 0) puts("-1");
	else printf("%d\n", minCostMaxFlow(S, T, cnt));
	return 0;
}
```


---


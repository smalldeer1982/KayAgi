# [SDOI2013] 刺客信条

## 题目描述

故事发生在1486 年的意大利，Ezio 原本只是一个文艺复兴时期的贵族，后来因为家族成员受到圣殿骑士的杀害，决心成为一名刺客。最终，凭借着他的努力和出众的天赋，成为了杰出的刺客大师，他不仅是个身手敏捷的武林高手，飞檐走壁擅长各种暗杀术。刺客组织在他的带领下，为被剥削的平民声张正义，赶跑了原本统治意大利的圣殿骑士首领-教皇亚历山大六世。在他的一生中，经历了无数次惊心动魄、扣人心弦的探险和刺杀。


曾经有一次，为了寻找Altair 留下的线索和装备，Ezio 在佛罗伦萨中的刺客墓穴进行探索。这个刺客墓穴中有许多密室，且任何两个密室之间只存在一条唯一的路径。这些密室里都有一个刺客标记，他可以启动或者关闭该刺客标记。为了打开储存着线索和装备的储藏室，Ezio 必须操作刺客标记来揭开古老的封印。要想解开这个封印，他需要通过改变某些刺客标记的启动情况，使得所有刺客标记与封印密码“看起来一样”。


在这里，“看起来一样”的定义是：存在一种“标记”密室与“密码”密室之间一一对应的关系，使得密室间的连接情况和启动情况相同（提示中有更详细解释）。幸运的是，在Ezio 来到刺客墓穴之前，在Da Vinci 的帮助下，Ezio 已经得知了打开储藏室所需要的密码。


而你的任务则是帮助Ezio 找出达成目标所需要最少的改动标记次数。


## 说明/提示

密室的编号是可以变的！将第三个密室关闭后，在当前标记和密码之间，存在1->4,2->3,3->2,4->1 的对应关系，重新编号后连接情况没有改变，且标记与密码对应。对于更一般的情况，存在一个1 到n 的置换P，使得对于任意密室之间的道路u-v，都一定有密码密室中的道路P(u)-P(v)；如果不存在密室之间的道路u-v，则一定没有密码密室中的道路P(u)-P(v)。


对于100%的数据，n<=700，且每个密室至多与11个密室相通


## 样例 #1

### 输入

```
4
1 2
2 3
3 4
0 0 1 1
1 0 0 0```

### 输出

```
1```

# 题解

## 作者：xyz32768 (赞：17)

关于树同构，有一个神奇的性质：

一棵树的重心只有 $1$ 个或 $2$ 个，如果有 $2$ 个（记为 $u$ 和 $v$），那么一定有边 $(u,v)$ ，而此时可以断开边 $(u,v)$ ，新建一个节点，分别向 $u$ 和 $v$ 建边，这样新建的节点就是重心。上面所说的性质是：如果有两棵树，强制以重心为根，那么这两棵树同构当且仅当形成的两棵**有根树**同构。

而两棵有根树（分别以 $u$ 和 $v$）同构，当且仅当 $u$ 和 $v$ 的度数相同，

并且设 $u$ 的子节点集合为 $son_u=\{x_1,x_2,...,x_m\}$ ，

$v$ 的子节点集合为 $son_v=\{y_1,y_2,...,y_m\}$ ，

存在一个 $1$ 到 $m$ 的排列 $P$ 使得对于每个 $i$ ，满足以 $x_i$ 为根的子树与以 $y_{P_i}$ 为根的子树同构。

回到原问题。根据性质，可以先找出树的重心，然后强制以重心为根，做一次树形 DP：

$f[x][y]$ ：使 $x$ 的子树和 $y$ 的子树启动情况同构的最小代价。其中 $x$ 和 $y$ 必须深度相同且子树同构。

转移当然是从 $x$ 和 $y$ 的子树转移。也就是找到一个合法的，最优的子树匹配，使得满足条件：

（1）如果 $x$ 的一个子树 $u$ 和 $y$ 的一个子树 $v$ 进行匹配，那么 $u$ 的子树和 $v$ 的子树必须同构。

（2）$u$ 和 $v$ 匹配的代价为 $f[u][v]$ ，必须最小化 $\sum f[u][v]$ 。

显然，关键在于条件（2）。而条件（2）是一个最小权和完备匹配问题，用 KM / 费用流可以求得。

现在还剩下最后一个问题，那就是，如何判断深度相同的两个子树 $u$ 和 $v$ 是否同构。

Hash ~~大法好！~~

也就是为每个子树定义一个 Hash 函数，如果 $u$ 和 $v$ 的 Hash 值相等，那么 $u$ 的子树和 $v$ 的子树同构。

具体地，构造这个 Hash 函数的方法是：

将子树内的所有节点按照 Hash 值从大到小排序，那么 Hash 函数为：

$$H(u)=((A\times H(son[u]_1))\times p+H(son[u]_2))\times p+...$$

~~调了 37 遍，最后才发现 KM 写挂了~~

代码：

```cpp
#include <cmath>
#include <cstdio>
#include <vector>
#include <cstring>
#include <iostream>
#include <algorithm>
#define For(i, a, b) for (i = a; i <= b; i++)
#define Edge(u) for (int e = adj[u], v; e; e = nxt[e])
using namespace std;
inline int read() {
	int res = 0; bool bo = 0; char c;
	while (((c = getchar()) < '0' || c > '9') && c != '-');
	if (c == '-') bo = 1; else res = c - 48;
	while ((c = getchar()) >= '0' && c <= '9')
		res = (res << 3) + (res << 1) + (c - 48);
	return bo ? ~res + 1 : res;
}
typedef long long ll;
const int N = 805, M = N << 1, INF = 0x3f3f3f3f;
int n, ecnt, nxt[M], adj[N], go[M], st[N], ed[N], dis[N], pyz[N], lpf[N],
Root = -1, Root0 = -1, tot, cnt, mo[N], ox[N], f[N][N], fa[N], dep[N];
vector<int> edg[N];
ll has[N], orz[N];
struct cyx {
	int n, val[N][N], tox[N], ex[N], ey[N], orz[N];
	bool visx[N], visy[N];
	bool dfs(int u) {
		int v; visx[u] = 1; For (v, 1, n) {
			if (visy[v] || val[u][v] == -1) continue;
			int t = val[u][v] - ex[u] - ey[v]; if (t == 0) {
				visy[v] = 1; if (!tox[v] || dfs(tox[v]))
					return tox[v] = u, 1;
			}
			else orz[v] = min(orz[v], t);
		}
		return 0;
	}
	int solve() {
		if (n == 0) return 0;
		int i, j; For (i, 1, n) tox[i] = 0;
		For (i, 1, n) {
			ey[i] = 0; ex[i] = INF; For (j, 1, n)
				if (val[i][j] != -1) ex[i] = min(ex[i], val[i][j]);
		}
		For (i, 1, n) {
			For (j, 1, n) orz[j] = INF; int cnt = 0; while (1) {
				For (j, 1, n) visx[j] = visy[j] = 0;
				if (dfs(i)) break; int mind = INF; For (j, 1, n)
					if (!visy[j]) mind = min(mind, orz[j]);
				For (j, 1, n) {
					if (visx[j]) ex[j] += mind;
					if (visy[j]) ey[j] -= mind;
					else orz[j] -= mind;
				}
			}
		}
		int ans = 0; For (i, 1, n) ans += ex[i] + ey[i]; return ans;
	}
} km;
void add_edge(int u, int v) {
	nxt[++ecnt] = adj[u]; adj[u] = ecnt; go[ecnt] = v;
	nxt[++ecnt] = adj[v]; adj[v] = ecnt; go[ecnt] = u;
}
int dfs(int u, int fu) {
	fa[u] = fu; dis[u] = 0; pyz[u] = u; Edge(u) {
		if ((v = go[e]) == fu) continue; dfs(v, u);
		if (2 + dis[v] > dis[u]) dis[u] = 2 + dis[v], pyz[u] = pyz[v];
	}
	return pyz[u];
}
void calcHash(int u, int fu) {
	dep[u] = dep[fu] + 1;
	has[u] = 14221; Edge(u) if ((v = go[e]) != fu) calcHash(v, u);
	int i; tot = 0; Edge(u) if ((v = go[e]) != fu) orz[++tot] = has[v];
	sort(orz + 1, orz + tot + 1); For (i, 1, tot)
		has[u] = (has[u] * 4481 % 1060469 ^ orz[i]) % 1060469;
	has[u] = has[u] * 20707 % 1060469;
}
bool comp(int u, int v) {return has[u] < has[v];}
bool comp2(int u, int v) {
	if (dep[u] != dep[v]) return dep[u] > dep[v]; return has[u] < has[v];
}
int DP() {
	int i, j, k; For(i, 1, n) lpf[i] = i; sort(lpf + 1, lpf + n + 1, comp2);
	for (k = 1; k <= n;) {
		int nx = k; while (nx <= n && dep[lpf[k]] == dep[lpf[nx]]
			&& has[lpf[k]] == has[lpf[nx]]) nx++;
		For (i, k, nx - 1) For (j, k, nx - 1) {
			int u = lpf[i], v = lpf[j], sb = 0; km.n = 0;
			for (int e = adj[u]; e; e = nxt[e])
				if (dep[go[e]] == dep[u] + 1) km.n++;
			for (int e = adj[u]; e; e = nxt[e]) if (dep[go[e]] == dep[u] + 1) {
				sb++; int sp = 0; for (int r = adj[v]; r; r = nxt[r])
					if (dep[go[r]] == dep[v] + 1) {
						km.val[sb][++sp] = has[go[e]] == has[go[r]]
							? f[go[e]][go[r]] : -1;
					}
			}
			f[u][v] = km.solve() + (st[u] != ed[v]);
		}
		k = nx;
	}
	return f[Root][Root];
}
int main() {
	int i, j, x, y, d; n = read(); For (i, 1, n - 1)
		x = read(), y = read(), edg[x].push_back(y),
		edg[y].push_back(x), add_edge(x, y);
	For (i, 1, n) st[i] = read(); For (i, 1, n) ed[i] = read();
	x = dfs(1, 0); y = dfs(x, 0); Root = y; d = dis[x] >> 1;
	For (i, 1, d >> 1) Root = fa[Root]; if (d & 1) Root0 = fa[Root];
	if (Root0 != -1) {
		ecnt = 0; memset(adj, 0, sizeof(adj));
		For (i, 1, n) {
			int tmp = edg[i].size(); For (j, 0, tmp - 1)
				if (i < edg[i][j] && !(i == Root && edg[i][j] == Root0) &&
					!(i == Root0 && edg[i][j] == Root)) add_edge(i, edg[i][j]);
		}
		add_edge(++n, Root); add_edge(n, Root0); Root = n;
	}
	calcHash(Root, 0); printf("%d\n", DP());
	return 0;
}
```

---

## 作者：Corycle (赞：11)

#### 题目链接：[P3296 [SDOI2013]刺客信条](https://www.luogu.org/problemnew/show/P3296)

### ⊙人话：

   **给你一棵树，每个点上有权值（0或1），
   问通过更改点权（1变0或0变1）达到相似的指定状态最少需要多少次。
相似状态的定义为“看起来是一样的”，就是说不一定每个点都是和原来的位置对应的，只要树的形状没变，树（包括点权）与目标树同构即可。**

**比如：下面这两棵树就是“看起来一样的”**

![1](https://cdn.luogu.com.cn/upload/pic/55272.png)
 
### ①思路： 
  **1.我们先以1为根节点进行DFS找到树的一个重心root。**
  
  **2.我们再以root根，以树的同构的方法，求出每一棵子树的Hash值，同时存下每一个点的所有孩子，用途见下文。**
  
  **3.我们查找每一个点p，若以p为根的树和以root为根的树同构，则进行DP。**
  
### ☆DP方式
**a. 记y是以root为根的树中的某节点，x为y在以p为根的树中的对应点，并且x在p为根的树中的子树与y在root为根中的子树同构。**

**b. 我们先让x和y在对应子树中的孩子匹配，例如a为x的某个孩子，b为y的孩子，并且a子树（记做A）与b的子树（记做B）同构,我们再让x，y的孩子的孩子进行匹配……**

**c. 对，这是个递归。我们在a和b的孩子DP过后再来确定最终a的每个孩子对应b的哪个娃。这个东西我们可以用二分图的KM算法或者网络流的费用流来完成。**

![4213](https://cdn.luogu.com.cn/upload/pic/55273.png)
 **（让x 的孩子和y的孩子对应）**
 
 ### ②下面是我的丑代码：
```cpp
#include<iostream>
#include<cmath>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define ll long long
using namespace std;
const int inf=0x3f3f3f3f;
const int Mod=152383;//随便找一个数 
const int Mul=5579;//再随便找一个数 
const int N=1005;
int read(){
	int s=0,f=1;char c=getchar();
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
	while(c>='0'&&c<='9'){s=s*10+c-'0';c=getchar();}
	return s*f;
}
struct Xinyue_Shuai{
	//这是一个裸的 KM  
	//xinyue宇宙第一帅 
	int n,lx[N],ly[N],visx[N],visy[N],p[N],w[N][N];
	bool DFS(int x){
		visx[x]=1;
		for(int y=1;y<=n;y++){
			if(!visy[y]&&lx[x]+ly[y]==w[x][y]){
				visy[y]=1;
				if(!p[y]||DFS(p[y])){p[y]=x;return true;}
			}
		}
		return false;
	}
	void Adjust(){
		int d=inf;
		for(int i=1;i<=n;i++){
			if(!visx[i])continue;
			for(int j=1;j<=n;j++){
				if(!visy[j])d=min(d,lx[i]+ly[j]-w[i][j]);
			}
		}
		for(int i=1;i<=n;i++){
			if(visx[i])lx[i]-=d;
			if(visy[i])ly[i]+=d;
		}
	}
	int KM(){
		memset(p,0,sizeof(p));
		for(int i=1;i<=n;i++){
			lx[i]=-inf;ly[i]=0;
			for(int j=1;j<=n;j++){
				w[i][j]*=-1;
				//求的是最小更改次数 
				//所以我们将所有边取反 
				lx[i]=max(lx[i],w[i][j]);
			}
		}
		for(int i=1;i<=n;i++){
			while(1){
				memset(visx,0,sizeof(visx));
				memset(visy,0,sizeof(visy));
				if(DFS(i))break;Adjust();
			}
		}
		int ans=0;
		for(int i=1;i<=n;i++){
			if(p[i])ans+=w[p[i]][i];
		}
		return -ans;//注意 
	}
}P;
int n,cnt,root,Ans=inf,tmp=inf;
int h[N],fa[N],s1[N],s2[N],vis[N],sum[N];
int Hash[N],f[N][N],c1[N][N],c2[N][N];
struct edge{int to,next;}d[N*2];
void Add(int x,int y){//双向边 
	d[++cnt]=(edge){y,h[x]};h[x]=cnt;
	d[++cnt]=(edge){x,h[y]};h[y]=cnt;
}
bool cmp(int x,int y){
	//以Hash值从小到大排序 
	return Hash[x]<Hash[y];
}
void Find(int x){//求树的重心 
	int Max=0;
	vis[x]=sum[x]=1;
	for(int i=h[x];i;i=d[i].next){
		int y=d[i].to;
		if(vis[y])continue;
		Find(y);
		sum[x]+=sum[y];
		Max=max(Max,sum[y]);
	}
	Max=max(Max,n-sum[x]);
	if(Max<tmp){tmp=Max;root=x;}
	//找重心，不说了 
}
void DFS(int x,int prt,int c[][N]){
	fa[x]=prt;Hash[x]=2019;
	memset(c[x],0,sizeof(c[x]));
	for(int i=h[x];i;i=d[i].next){
		int y=d[i].to;
		if(y==fa[x])continue;
		DFS(y,x,c);
		c[x][++c[x][0]]=y;
		//存入每个点的所有孩子，用于DP
	}
	sort(c[x]+1,c[x]+c[x][0]+1,cmp);
	//将x的所有孩子以Hash值排序 
	for(int i=1;i<=c[x][0];i++){
		Hash[x]=((Hash[x]*Mul)^Hash[c[x][i]])%Mod;
		//树的同构 Hash 
	}
}
int DP(int x,int y){
	if(f[x][y]!=-1)return f[x][y];//类似记忆化 
	f[x][y]=s1[x]^s2[y];//x的初始值是否与目标值不同 
	int num=c1[x][0];
	//既然x和y同构，那他们的孩子的Hash值肯定相同 
	for(int i=1;i<=num;i++){
		int j=i;
		while(j<=num&&Hash[c1[x][j+1]]==Hash[c1[x][i]])j++;
		//i-j中的所有子树都同构 
		//方便之后的建边，孩子在DFS中是排过序的 
		for(int k=i;k<=j;k++){
			for(int l=i;l<=j;l++){
				DP(c1[x][k],c2[y][l]);
				//处理x和y的孩子的对应关系 
			}
		}
		//先对孩子处理完再处理本身 
		for(int k=i;k<=j;k++){
			for(int l=i;l<=j;l++){
				int dlt=DP(c1[x][k],c2[y][l]);
				P.w[k-i+1][l-i+1]=dlt;
				//让x的孩子和y的孩子看起来一样所需要的最小代价 
			}
		}
		//初始化边权 
		P.n=j-i+1;
		f[x][y]+=P.KM();
		//KM进行匹配，费用流也可以 
		i=j;
	}
	return f[x][y];
}
int main(){
	n=read();
	for(int i=1;i<n;i++)Add(read(),read());
	for(int i=1;i<=n;i++)s1[i]=read();//这是初始状态 
	for(int i=1;i<=n;i++)s2[i]=read();//这是目标状态 
	Find(1);//先找到重心 root 
	DFS(root,0,c2);
	//以重心为根重新 Hash，每个点的孩子存入 C2 
	tmp=Hash[root];
	for(int i=1;i<=n;i++){
		DFS(i,0,c1);
		//以i为根重新 Hash，每个点的孩子存入 C1 
		if(Hash[i]==tmp){//如果与原树同构 
			memset(f,-1,sizeof(f));
			Ans=min(Ans,DP(i,root));//DP，更新答案 
		}
	}
	printf("%d\n",Ans);
	return 0;
}
```


---

## 作者：Martin_MHT (赞：3)

### 前言
做法来自：@pzrpzr ，写一下！Orz pzr！


### 题目大意
$n$ 个点的无根树，每个点有两个 $0/1$ 权值，合适地安排节点在同构树中的顺序，使得前后对应的权值不同节点个数最小，并输出。

### 解题思路

首先，我们套路地将**无根树的同构问题**转化成**以重心为根的有根树的同构问题**。（相关证明请查阅相关资料，此处不赘述。）

找出重心，以此为根。若有两个重心，则新增一个点，使其为根，并删去原重心之间的连边，且两个重心分别向根连边。不难发现此节点一定为重心，且不影响答案。

注意到一个条件即一个节点的度数 $<=11$，这启示我们使用dp解决这个问题。（ $son_x$ 表示 $x$ 的儿子个数。）

设 $f_{x,y}$ 表示 $x$ 子树与 $y$ 子树同构，$x$ 对应 $y$ 时，最小的代价。容易发现 $x$ 和 $y$ 的深度、儿子个数、子树大小均应该相等。故真正有用的状态很小。

至于转移，pzr想到不需要通过树hash进行判断同构。如果我们能将 $x$ 和 $y$ 的子树分别一一配对，由其转移即可。设一个辅助dp数组 $g_{i,s}$ 表示 $x$ 的儿子匹配到第 $i$ 个，$y$ 的儿子匹配的状态为 $s$ 的最小代价。转移可以枚举子集。显然

$$f_{x,y}=g_{son_x,2^{son_y+1}-1}(son_x=son_y)+[val_{1,i} \ne val_{2,j}]$$
。


时间复杂度不好分析，恳请大神帮忙算一下。

最后要注意，找到重心以后 $siz$ , $son$ 要重新算。因为这个wa了一发。

```cpp
#include <cstdio>
#include <vector>
#include <cstring>
#include <algorithm>
#define M 13
#define W 1030
#define N 710
#define INF 0x3f3f3f3f
#define ff(i, a, b) for(int i = (a); i < (b); ++i)
#define fo(i, a, b) for(int i = (a); i <= (b); ++i)
#define fd(i, a, b) for(int i = (a); i >= (b); --i)
using namespace std;
inline int read() // negative , long long
{
	int x = 0; char ch = getchar();
	while(ch < '0' || ch > '9')	ch = getchar();
	while(ch >= '0' && ch <= '9')	x = (x << 3) + (x << 1) + (ch ^ 48), ch = getchar();
	return x;
}
int n, p2[M] = {1}, cnt[W], siz[N], fa[N], son[N], c[3], f[N][N], g[M][W];
int last[N], pre[N << 1], to[N << 1];
bool op1[N], op2[N];
inline void add(int u, int v){static int tot = 0; pre[++tot] = last[u], to[tot] = v, last[u] = tot;}
void findC(int u)
{
	siz[u] = 1, son[u] = 0;
	bool ok = 1;
	for(int i = last[u]; i; i = pre[i])
	{
		int v = to[i];
		if(v == fa[u])	continue ;
		fa[v] = u, findC(v), ++son[u], siz[u] += siz[v];
		if(siz[v] > (n >> 1))	ok = 0;
	}
	if(ok && n - siz[u] <= (n >> 1))	c[++c[0]] = u;
}
void delEdge(int u, int v)
{
	if(to[last[u]] ^ v)
		for(int i = last[u]; pre[i]; i = pre[i])
			if(to[pre[i]] == v && (pre[i] = pre[pre[i]]))	return ;
	last[u] = pre[last[u]];
}
void dfs(int x, int y)
{
	f[x][y] = INF;
	vector<int> sx, sy;
	int full = p2[son[y]] - 1, s = son[x];
	if(s != son[y] || siz[x] != siz[y])	return ;
	for(int i = last[x]; i; i = pre[i])
		if(to[i] ^ fa[x])	sx.push_back(to[i]);
	for(int i = last[y]; i; i = pre[i])
		if(to[i] ^ fa[y])	sy.push_back(to[i]);
	fo(i, 1, s)	fo(j, 1, s)
		dfs(sx[i - 1], sy[j - 1]);
	fo(i, 1, s)	memset(g[i], 0x3f, sizeof(int) * (full + 3));
	fo(i, 1, s)	fo(j, 1, s)	fo(S, p2[j - 1], full)
		if(cnt[S] == i && (S & p2[j - 1]))
			g[i][S] = min(g[i][S], g[i - 1][S ^ p2[j - 1]] + f[sx[i - 1]][sy[j - 1]]);
	f[x][y] = min(f[x][y], g[s][full] + (op1[x] != op2[y]));
}
int main()
{
	n = read();
	fo(i, 1, 10)	p2[i] = p2[i - 1] << 1;
	fo(i, 1, p2[10])	cnt[i] = cnt[i >> 1] + (i & 1);
	int u, v, rt;
	fo(i, 2, n)	u = read(), v = read(), add(u, v), add(v, u);
	fo(i, 1, n)	op1[i] = read();
	fo(i, 1, n)	op2[i] = read();
	findC(1);
	if(c[0] ^ 1)
	{
		rt = ++n; add(n, c[1]), add(n, c[2]), add(c[1], n), add(c[2], n);
		delEdge(c[1], c[2]), delEdge(c[2], c[1]);
	}
	else rt = c[1];
	fa[rt] = 0, findC(rt);
	dfs(rt, rt);
	printf("%d\n", f[rt][rt]);
	return 0;
}


```

---

## 作者：Jayun (赞：1)

## 题目大意

给定一棵树和两组 01 权值，求对这棵树重标号后，第一组权值和第二组权值最小不同数。

$n\leq700$。

## 题解

真是一场酣畅淋漓的写题啊！

处理无根树的方式与 [P4895 独钓寒江雪](http://124.222.41.183/blog/jayun/post/181)（[题目链接](https://www.luogu.com.cn/problem/P4895)）一样，重心作根，两个重心就新开个点向两中心连边；哈希也与之相同。

有根后设 $f_{x,y}$ 表示在子树 $x,y$ 同构的条件下，二者权值最小不同数。考虑转移，$x,y$ 同构而它们的所有子树的形态一样的，所谓重编号，就相当于 $x$ 中同构的子树与 $y$ 中同构的子树可以对应（连边）而我们需要一个最优的匹配，这样就把问题转化为二分图带权匹配，用费用流即可。

## 代码

真是一场酣畅淋漓的敲代码啊！

```cpp
const int N = 710, mod = 1e9 + 7;
const int BASE = 19260817;

inline ll Read() {
	ll x = 0, f = 1;
	char c = getchar();
	while (c != '-' && (c < '0' || c > '9')) c = getchar();
	if (c == '-') f = -f, c = getchar();
	while (c >= '0' && c <= '9') x = (x << 3) + (x << 1) + c - '0', c = getchar();
	return x * f;
}

namespace Main {
	int n;
	int a[N], b[N];
	struct Edge {
		int to, nxt;
	} e[N << 1];
	int head[N], tot;
	void add_edge (int u, int v) { e[++tot] = (Edge) {v, head[u]}, head[u] = tot; }

	int rt;
	int siz[N], mx[N];
	void get_root(int u, int fa) {
		siz[u] = 1;
		for (int i = head[u]; i; i = e[i].nxt) {
			int v = e[i].to;
			if (v == fa) continue;
			get_root(v, u);
			siz[u] += siz[v];
			mx[u] = max(mx[u], siz[v]);
		}
		mx[u] = max(mx[u], n - siz[u]);
		if (!rt || mx[u] < mx[rt]) rt = u;
	}
	unsigned ll hash[N];
	int r1 = 0, r2 = 0;
	int tmp[N], fa[N], dep[N];
#define nop(u, v) (u == r1 && v == r2 || u == r2 && v == r1)
	void calc_hash(int u) {
		hash[u] = 1;
		dep[u] = dep[fa[u]] + 1;
		for (int i = head[u]; i; i = e[i].nxt) {
			int v = e[i].to; if (v == fa[u] || nop(u, v)) continue;
			fa[v] = u;
			calc_hash(v);
		}
		int tot = 0;
		for (int i = head[u]; i; i = e[i].nxt) {
			int v = e[i].to; if (v == fa[u] || nop(u, v)) continue;
			tmp[++tot] = hash[e[i].to];
		}
		sort(tmp + 1, tmp + tot + 1);
		for (int i = 1; i <= tot; i++) (((hash[u] *= BASE) += tmp[i]) ^= tmp[i]) += tmp[i];
	}

	bool DEBUG = 0;

	struct NetworkFlow {
		const int inf = 707406378;
		const static int N = 25;
		int S, T, n;
		int head[N], tot = 1;
		struct Edge {
			int to; ll w, c; int nxt;
		} e[N * N];
		void add_edge(int u, int v, ll w, ll c) {
			e[++tot] = (Edge) {v, w, c, head[u]}, head[u] = tot;
			e[++tot] = (Edge) {u, 0, -c, head[v]}, head[v] = tot;
		}
		NetworkFlow() {tot = 1;}

		bool vis[N];
		int dis[N];
		deque <int> q;
		bool spfa() {
			while (!q.empty()) q.pop_back();
			for (int i = 1; i <= n; i++) vis[i] = 0, dis[i] = inf;
			dis[T] = 0, vis[T] = 1;
			q.push_back(T);
			while (!q.empty()) {
				int u = q.front(); q.pop_front(); vis[u] = 0;
				for (int i = head[u]; i; i = e[i].nxt) {
					int v = e[i].to;
					if (dis[v] > dis[u] - e[i].c && e[i ^ 1].w) {
						dis[v] = dis[u] - e[i].c;
						if (!vis[v]) {
							vis[v] = 1;
							if (q.size() && dis[v] < dis[q.front()]) q.push_front(v);
							else q.push_back(v);
						}
					}
				}
			}
			return dis[S] < inf;
		}
		ll mcost = 0;
		ll dfs (int u, ll flow) {
			vis[u] = 1;
			if (u == T || !flow) return flow;
			ll sum = 0;
			for (int i = head[u]; i; i = e[i].nxt) {
				int v = e[i].to;
				if (dis[v] == dis[u] - e[i].c && e[i].w && !vis[v]) {
					ll f = dfs(v, min(e[i].w, flow - sum));
					if (!f) continue;
					e[i].w -= f;
					e[i ^ 1].w += f;
					sum += f;
					mcost += f * e[i].c;
					if (sum == flow) break;
				}
			}
			return sum;
		}
		ll mcmf () {
			ll ret = 0;
			// if (DEBUG) printf ("%d\n", tot);
			while (spfa()) {
				vis[T] = 1;
				for (; vis[T]; ret += dfs(S, inf))
					for (int i = 1; i <= n; i++) vis[i] = 0;
			}
			return ret;
		}

		void clear(int num) {
			S = num + 1, T = S + 1; tot = 1;
			n = num + 2; mcost = 0;
			for (int i = 1; i <= n; i++) head[i] = 0;
		}
	} nf;

	int f[N][N];
	pair <unsigned ll, int> p1[N], p2[N];
	void solve (int x, int y) {
		int tot1 = 0, tot2 = 0;
		for (int i = head[x]; i; i = e[i].nxt)
			if (e[i].to != fa[x] && !nop(x, e[i].to)) p1[++tot1] = make_pair(hash[e[i].to], e[i].to);
		for (int i = head[y]; i; i = e[i].nxt)
			if (e[i].to != fa[y] && !nop(y, e[i].to)) p2[++tot2] = make_pair(hash[e[i].to], e[i].to);
		sort (p1 + 1, p1 + 1 + tot1); sort (p2 + 1, p2 + 1 + tot2);
		DEBUG =  (x == 5 && y == 5);
		for (int i = 1; i <= tot1; i++) {
			int j;
			for (j = i; j < tot1 && p1[j].first == p1[j + 1].first; j++);
			int len = j - i + 1;
			nf.clear (len * 2);
			for (int k1 = i; k1 <= j; k1++)
				for (int k2 = i; k2 <= j; k2++)
					nf.add_edge(k1 - i + 1, k2 - i + 1 + len, 1, f[p1[k1].second][p2[k2].second]);
			for (int k = 1; k <= len; k++) nf.add_edge(nf.S, k, 1, 0), nf.add_edge(k + len, nf.T, 1, 0);
			nf.mcmf(); f[x][y] += nf.mcost;
			//if (x == 5 && y == 5) printf ("%d %d\n", i, j);
			i = j;
		}
		if (a[x] != b[y]) f[x][y]++;
	}
	pair<int, pair <unsigned ll, int> > w[N];
	int main () {
		n = Read();
		for (int i = 1; i < n; i++) {
			int u = Read(), v = Read();
			add_edge(u, v), add_edge(v, u);
		}
		for (int i = 1; i <= n; i++) a[i] = Read();
		for (int i = 1; i <= n; i++) b[i] = Read();
		get_root(1, 0);
		for (int i = 1; i <= n; i++)
			if (mx[i] == mx[rt]) r2 = r1, r1 = i;
		if (r2) n++, add_edge(n, r1), add_edge(n, r2), rt = n;
		calc_hash(rt);
		for (int i = 1; i <= n; i++) w[i] = make_pair(-dep[i], make_pair(hash[i], i));
		sort (w + 1, w + 1 + n);
		for (int i = 1; i <= n; i++) {
			int j;
			for (j = i; j < n && w[j].first == w[j + 1].first && w[j].second.first == w[j + 1].second.first; j++);
			for (int k1 = i; k1 <= j; k1++)
				for (int k2 = i; k2 <= j; k2++)
					solve (w[k1].second.second, w[k2].second.second);
			i = j;
		}
		printf ("%d\n", f[rt][rt]);
		return 0;
	}
}

int main () {
	string str = "";
//	freopen((str + ".in").c_str(), "r", stdin);
//	freopen((str + ".out").c_str(), "w", stdout);
	Main::main();
	return 0;
}
```

---

## 作者：liugh_ (赞：0)

## [[SDOI2013] 刺客信条](https://www.luogu.com.cn/problem/P3296)

> $n$ 个点的树，有点权 $a_i,b_i$，求 $\min_{P}\sum_{i=1}^{n} [a_i\ne b_{P_i}]$，其中 $P$ 为一个 $1$ 到 $n$ 的排列。$n\le 700$。

套路地考虑树形 dp，设 $f(x,y)$ 为令 $x$ 子树与 $y$ 子树匹配的最小花费，值合法当且仅当 $x,y$ 深度相同且 $x$ 子树与 $y$ 子树**同构**。但是对于无根树，我们怎么定义“深度”和“子树”？换根是麻烦的，我们有关键的结论：

- 若有两个重心则断开二者的边并新建一点连接二者，新点必为重心。
- 两棵重心唯一的无根树同构当且仅当以重心为根的有根树同构。

判同构考虑树哈希，提供一种不容易卡掉的哈希函数
$$
h(u)=\left(1+\sum_{v\in son_u} g(h(v))\right)\bmod P
$$
其中 $g$ 为线性映射，可以是 xorshift，$P$ 为固定的模数，可以自然溢出。xorshift 为防止被卡可以一前一后异或两遍一个固定的随机值，详见代码。

按深度枚举 $x,y$，问题转化为找到花费最小的方案使 $x$ 与 $y$ 的儿子**两两匹配**，二分图最小权完美匹配，费用流即可。时间复杂度是玄学的，实际上跑的很快。

自认为代码还是比较清晰的。

```cpp
#include<iostream>
#include<algorithm>
#include<cstring>
#include<cassert>
#include<queue>
#include<array>
#include<random>
using namespace std;namespace lgh{
#define ll long long
#define ull unsigned long long
#define db double
#define pii pair<int,int>
#define fi first
#define se second
#define pb push_back
template<class T1,class T2>bool tomin(T1&x,T2&&y){return y<x?x=y,1:0;}
template<class T1,class T2>bool tomax(T1&x,T2&&y){return y>x?x=y,1:0;}

const int maxn=1400+5,maxm=5e5+5,inf=0x3f3f3f3f;

int n,S,T;
vector<int> G[maxn];
bool a[maxn],b[maxn];
int cen,cen2,mx[maxn]{inf},siz[maxn],dep[maxn],fa[maxn],hs[maxn];
vector<int> li[maxn];
int f[maxn][maxn];

unsigned shift(unsigned x){ // xorshift
    static const unsigned msk=random_device()();
    x^=msk;x^=x<<13;x^=x>>7;x^=x<<17;x^=msk;return x;
}

void find(int u,int lst){ // find centroid
    mx[u]=0,siz[u]=1;
    for(auto v:G[u])if(v!=lst){
        find(v,u);
        tomax(mx[u],siz[v]);
        siz[u]+=siz[v];
    }
    tomax(mx[u],n-siz[u]);
    if(mx[u]<mx[cen])cen=u,cen2=0;
    else if(mx[u]==mx[cen])cen2=u;
}

void dfs(int u,int lst){ // preprocessing
    siz[u]=1,dep[u]=dep[lst]+1,fa[u]=lst;
    li[dep[u]].pb(u);
    hs[u]=1;
    for(auto it=G[u].begin();it!=G[u].end();it++)if(*it==lst){
        G[u].erase(it);
        break;
    }
    for(auto v:G[u]){
        dfs(v,u);
        siz[u]+=siz[v];
        hs[u]+=shift(hs[v]);
    }
}

namespace fl{ // mcmf
struct _eg{int pre,v,c,w;}eg[maxm*2];int ei=1,eh[maxn],cur[maxn];
void ea(int u,int v,int c,int w){eg[++ei]={eh[u],v,c,w};eh[u]=ei;}
#define ef(u,v,c,w) (ea(u,v,c,w),ea(v,u,0,-(w)))
int dis[maxn];bool vis[maxn];
bool spfa(){
    fill(dis,&dis[T]+1,inf);fill(vis,&vis[T]+1,0);
    deque<int> q{S};dis[S]=0;
    while(q.size()){
        int u=q.front();
        q.pop_front();
        vis[u]=0;
        for(int e=eh[u];e;e=eg[e].pre){
            auto [_,v,c,w]=eg[e];
            if(c>0&&dis[u]+w<dis[v]){
                dis[v]=dis[u]+w;
                if(!vis[v])vis[v]=1,q.pb(v);
            }
        }
    }return dis[T]!=inf;
}
int dfs(int u,int fl){
    if(u==T)return fl;
    vis[u]=1;int sum=0;
    for(int&e=cur[u];e;e=eg[e].pre){
        auto [_,v,c,w]=eg[e];
        if(vis[v])continue;
        if(c>0&&dis[u]+w==dis[v]){
            int can=dfs(v,min(c,fl));
            if(!can){dis[v]=inf;continue;}
            eg[e].c-=can,eg[e^1].c+=can;
            fl-=can,sum+=can;
            if(!fl)break;
        }
    }
    vis[u]=0;return sum;
}
pii dinic(){
    int F=0,C=0;while(spfa()){
        fill(vis,&vis[T]+1,0);
        copy(eh,&eh[T]+1,cur);
        int can=dfs(S,inf);
        F+=can,C+=can*dis[T];
    }return {F,C};
}
}using fl::ei,fl::eh,fl::ea,fl::dinic;

void main(){
    cin>>n;
    for(int i=2;i<=n;i++){
        int u,v;cin>>u>>v;
        G[u].pb(v),G[v].pb(u);
    }
    for(int i=1;i<=n;i++)cin>>a[i];
    for(int i=1;i<=n;i++)cin>>b[i];
    find(1,0);
    if(cen2){ // create new node
        for(auto it=G[cen].begin();it!=G[cen].end();it++)if(*it==cen2){
            G[cen].erase(it);
            break;
        }
        for(auto it=G[cen2].begin();it!=G[cen2].end();it++)if(*it==cen){
            G[cen2].erase(it);
            break;
        }
        n++;
        G[n].pb(cen),G[n].pb(cen2);
        cen=n;
    }
    dfs(cen,0);
    fill(*f,*end(f),inf);
    S=n*2+1,T=S+1;
    for(int d=n;d>=1;d--){ // implement by dep
        for(int i=0;i<li[d].size();i++){
            for(int j=0;j<li[d].size();j++){
                // notice that matching y with x isn't equivalent to maching x with y
                int u=li[d][i],v=li[d][j];
                if(hs[u]!=hs[v])continue;
                if(siz[u]==1){
                    f[u][v]=(a[u]!=b[v]);
                    continue;
                }
                ei=1,fill(eh,&eh[T]+1,0);
                for(auto x:G[u])ef(S,x,1,0);
                for(auto y:G[v])ef(y+n,T,1,0);
                for(auto x:G[u]){
                    for(auto y:G[v]){
                        ef(x,y+n,1,f[x][y]);
                    }
                }
                f[u][v]=dinic().se+(a[u]!=b[v]);
            }
        }
    }
    cout<<f[cen][cen];
}
}
signed main(){
    #ifndef ONLINE_JUDGE
    freopen("1.in","r",stdin);
    freopen("1.out","w",stdout);
    #endif
    cin.tie(0)->sync_with_stdio(0);
    signed cse=1;
    // cin>>cse;
    while(cse--)lgh::main();
}
```

---

## 作者：TYxxj (赞：0)

设 $f_{u,v}$ 表示 $u$ 子树和 $v$ 子树同构且同层的情况下$u$子树原标记变动成$v$子树的新标记需要的最少次数。

那么实际上就是枚举 $u$ 和 $v$ 的儿子子树互相匹配，用他们的$f$转移到$f_{u,v}$上，很明显这是一个带权二分图匹配的过程，KM是一个很好的选择。

如果要是枚举根来做的话，复杂度就是 $O(1331n^2)$ 过不了，当然如果你使用动态换根的话，虽然我没有想过，但是到目前位置，代码已经快200行了，如果再动态换根的话就要累死了（当然debug就更累了）。

我们有个很妙的性质：取这棵树的重心（如果有两个重心，则将两个重心之间的边上建这个点，取这个点）作为根。

因为我们有一个美妙的结论：两棵树同构，当且仅当以两棵树重心为根的树同构。

代码：
```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
typedef unsigned long long ll;
const int M=12;
const int N=705;
const int B=6662333;
const int INF=1e9;
inline int read() {
	int X=0,w=0;
	char ch=0;
	while(!isdigit(ch)) {
		w|=ch=='-';
		ch=getchar();
	}
	while(isdigit(ch))X=(X<<3)+(X<<1)+(ch^48),ch=getchar();
	return w?-X:X;
}
int dis[M][M],wx[M],wy[M],match[M],sla[M];
bool vx[M],vy[M];
bool dfs2(int u,int n) {
	vx[u]=1;
	for(int v=1; v<=n; v++) {
		if(!vy[v]) {
			int w=wx[u]+wy[v]-dis[u][v];
			if(!w) {
				vy[v]=1;
				if(!match[v]||dfs2(match[v],n)) {
					match[v]=u;
					return 1;
				}
			} else sla[v]=min(sla[v],w);
		}
	}
	return 0;
}
int KM(int n) {
	memset(wx,-127,sizeof(wx));
	memset(wy,-127,sizeof(wy));
	memset(match,0,sizeof(match));
	for(int i=1; i<=n; i++)
		for(int j=1; j<=n; j++)
			wx[i]=max(wx[i],dis[i][j]);
	for(int i=1; i<=n; i++) {
		memset(sla,127,sizeof(sla));
		while(1) {
			memset(vx,0,sizeof(vx));
			memset(vy,0,sizeof(vy));
			if(dfs2(i,n))break;
			int minn=INF;
			for(int j=1; j<=n; j++)
				if(!vy[j])minn=min(minn,sla[j]);
			for(int j=1; j<=n; j++) {
				if(vx[j])wx[j]-=minn;
				if(vy[j])wy[j]+=minn;
				else sla[j]-=minn;
			}
		}
	}
	int ans=0;
	for(int i=1; i<=n; i++)if(dis[match[i]][i]!=-INF)ans-=dis[match[i]][i];
	return ans;
}
struct node {
	int to,nxt;
} e[N*2];
int n,cnt,head[N],fa[N],a[N],b[N],q[N],size[N],son[N],dep[N];
ll h[N];
inline void add(int u,int v) {
	e[++cnt].to=v;
	e[cnt].nxt=head[u];
	head[u]=cnt;
}
int calcg(int st) {
	int r=0,g1,g2=0,maxn=n;
	q[++r]=st;
	fa[st]=0;
	for(int l=1; l<=r; l++) {
		int u=q[l];
		size[u]=1;
		son[u]=0;
		for(int i=head[u]; i!=-1; i=e[i].nxt) {
			int v=e[i].to;
			if(v==fa[u])continue;
			fa[v]=u;
			q[++r]=v;
		}
	}
	for(int l=r; l>=1; l--) {
		int u=q[l],v=fa[u];
		if(r-size[u]>son[u])son[u]=r-size[u];
		if(son[u]<maxn)g1=u,maxn=son[u],g2=0;
		else if(son[u]==maxn)g2=u;
		if(!v)break;
		size[v]+=size[u];
		if(size[u]>son[v])son[v]=size[u];
	}
	if(!g2)return g1;
	for(int i=head[g1]; i!=-1; i=e[i].nxt) {
		int v=e[i].to;
		if(v==g2) {
			e[i].to=++n;
			e[i^1].to=n;
			add(n,g1);
			add(n,g2);
			return n;
		}
	}
}
ll dfs1(int u) {
	ll num[N];
	int r=0;
	size[u]=1;
	h[u]=B;
	for(int i=head[u]; i!=-1; i=e[i].nxt) {
		int v=e[i].to;
		if(v==fa[u])continue;
		fa[v]=u;
		dep[v]=dep[u]+1;
		num[++r]=dfs1(v);
		size[u]+=size[v];
	}
	sort(num+1,num+r+1);
	for(int i=1; i<=r; i++)h[u]=h[u]*B+num[i];
	return h[u]*=size[u];
}
int f[N][N],to1[N],to2[N];
int find(int u1,int u2) {
	int idx1=0,idx2=0;
	memset(to1,0,sizeof(to1));
	memset(to2,0,sizeof(to2));
	for(int i=head[u1]; i!=-1; i=e[i].nxt) {
		int v1=e[i].to;
		if(v1==fa[u1])continue;
		if(!to1[v1])to1[v1]=++idx1;
		for(int j=head[u2]; j!=-1; j=e[j].nxt) {
			int v2=e[j].to;
			if(v2==fa[u2])continue;
			if(!to2[v2])to2[v2]=++idx2;
			dis[to1[v1]][to2[v2]]=-f[v1][v2];
		}
	}
	return KM(idx1)+(a[u1]!=b[u2]);
}
int bfs(int s) {
	int r=0;
	q[++r]=s;
	for(int l=0; l<=r; l++) {
		int u=q[l];
		for(int i=head[u]; i!=-1; i=e[i].nxt) {
			int v=e[i].to;
			if(v==fa[u])continue;
			q[++r]=v;
		}
	}
	for(int i=r; i>=0; i--) {
		if(dep[q[i]]!=dep[q[r]]) {
			i++;
			for(int j=r; j>=i; j--)
				for(int k=r; k>=i; k--)
					if(h[q[j]]==h[q[k]]) {
						f[q[j]][q[k]]=find(q[j],q[k]);
					}
			r=i-1;
		}
	}
	return find(s,s);
}
int main() {
	cnt=-1,memset(head,-1,sizeof(head));
	n=read();
	for(int i=1; i<n; i++) {
		int u=read(),v=read();
		add(u,v);
		add(v,u);
	}
	for(int i=1; i<=n; i++)a[i]=read();
	for(int i=1; i<=n; i++)b[i]=read();
	int rt=calcg(1);
	fa[rt]=0;
	dfs1(rt);
	for(int i=1; i<=n; i++)for(int j=1; j<=n; j++)f[i][j]=INF;
	printf("%d",bfs(rt));
	return 0;
}
```

---


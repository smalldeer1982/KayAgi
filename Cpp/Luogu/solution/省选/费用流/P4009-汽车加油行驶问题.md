# 汽车加油行驶问题

## 题目描述

给定一个 $N \times N$ 的方形网格，设其左上角为起点◎，坐标$(1,1)$，$X$ 轴向右为正， $Y$ 轴向下为正，每个方格边长为 $1$ ，如图所示。



 ![](https://cdn.luogu.com.cn/upload/pic/12156.png) 

一辆汽车从起点◎出发驶向右下角终点▲，其坐标为 $(N,N)$。


在若干个网格交叉点处，设置了油库，可供汽车在行驶途中加油。汽车在行驶过程中应遵守如下规则:


1. 汽车只能沿网格边行驶，装满油后能行驶 $K$ 条网格边。出发时汽车已装满油，在起点与终点处不设油库。

1. 汽车经过一条网格边时，若其 $X$ 坐标或 $Y$ 坐标减小，则应付费用 $B$ ，否则免付费用。

1. 汽车在行驶过程中遇油库则应加满油并付加油费用 $A$。

1. 在需要时可在网格点处增设油库，并付增设油库费用 $C$(不含加油费用$A$ )。

1. $N,K,A,B,C$ 均为正整数， 且满足约束: $2\leq N\leq 100,2 \leq K \leq 10$。


设计一个算法，求出汽车从起点出发到达终点所付的最小费用。


## 说明/提示

$2 \leq n \leq 100,2 \leq k \leq 10$


## 样例 #1

### 输入

```
9 3 2 3 6
0 0 0 0 1 0 0 0 0
0 0 0 1 0 1 1 0 0
1 0 1 0 0 0 0 1 0
0 0 0 0 0 1 0 0 1
1 0 0 1 0 0 1 0 0
0 1 0 0 0 0 0 1 0
0 0 0 0 1 0 0 0 1
1 0 0 1 0 0 0 1 0
0 1 0 0 0 0 0 0 0```

### 输出

```
12```

# 题解

## 作者：mzy2003 (赞：40)

第一次写题解

emmm。。。

看到这么多红名dalao打的题解，我这个蒟蒻不禁颤抖

本蒟蒻水平有限，看题只是想到了搜索

再一看，可以记忆化

于是有了如下AC代码~~（居然AC了）~~

~~（还是深搜）~~
```cpp
#include<cstdio>
#include<algorithm>
#include<iostream>
#include<cstring>
using namespace std;
int map[102][102],f[102][102][11],n,k,a,b,c,an=199999999;
void dfs(int x,int y,int fy,int rs)//横坐标，纵坐标，目前费用，剩余步数 
{
	int add=0;//此步费用 
	if (map[x][y]==-1) return;//边界 
	if (rs<=0||fy>=an) return;//最优性剪枝 
	rs--;
	for (int i=rs;i<=k;i++)//一个剪枝操作：当此坐标剩i（rs（当前剩步）<=i<=k）步时，
	if (f[x][y][i]<=fy) return;//费用还比目前费用少，则可剪枝。（其实可用树状数组logk的，但这儿数据小） 
	f[x][y][rs]=fy;//更新此坐标剩rs步时最小费用（记忆化） 
	if (x==n&&y==n)
	{
		an=min(an,fy);//更新答案 
		return;
	}
	if (map[x][y]==1) add=a,rs=k;//强制加油 
	if (rs==0) add=a+c,rs=k;//没油了，才设站加油 
	dfs(x+1,y,fy+add,rs);
	dfs(x,y+1,fy+add,rs);
	dfs(x-1,y,fy+add+b,rs);
	dfs(x,y-1,fy+add+b,rs);//扩展 
}
int main()
{
	scanf("%d%d%d%d%d",&n,&k,&a,&b,&c);
	for (int i=0;i<=n+1;i++)
	map[0][i]=map[i][0]=map[i][n+1]=map[n+1][i]=-1;//设边界 
	for (int i=1;i<=n;i++)
	for (int j=1;j<=n;j++)
	{
		scanf("%d",&map[i][j]);
		for (int k=0;k<=10;k++)
		f[i][j][k]=99999999;//初始化 
	}
	dfs(1,1,0,k+1);
	printf("%d",an);
	return 0;//好习惯 
}
```
第一次写，写的不好，请dalao们见谅

---

## 作者：Adove (赞：36)

本题适合作分层图最短路的模板题（~~当然你也可以用来练最小费用最大流~~。

分层图大概长这样↓（这是费用流建图，最短路去掉源汇点即可）

![](https://cdn.luogu.com.cn/upload/pic/15950.png)

图分为k+1层，箭头所指可以直达，蓝线自下而上需要付费（即最短路边权，费用流费用），黄线自高层连到基层需要付费（同上），最后在每一层的右下扫一遍取最小值即可。

上代码↓

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;

const int INF=2e9;

int n,k,p,b,c,np;
int h[350005],ln[350005],q[900005];
bool vis[350005],oil;
struct rpg{
	int li,nx,ln;
}a[900005];

void add(int x1,int y1,int z1,int x2,int y2,int z2,int ln){
	int ls=n*n*(z1-1)+(x1-1)*n+y1,nx=n*n*(z2-1)+(x2-1)*n+y2;
	a[++np]=(rpg){h[ls],nx,ln};
	h[ls]=np;
}

void spfa(){
	for(int i=1;i<=n*n*(k+1);++i) ln[i]=INF;
	int hd=1,tl=1;
	q[hd]=1;
	ln[1]=0;
	while(hd<=tl){
		int nw=q[hd++];
		vis[nw]=0;
		for(int i=h[nw];i;i=a[i].li){
			if(ln[a[i].nx]>ln[nw]+a[i].ln){
				ln[a[i].nx]=ln[nw]+a[i].ln;
				if(!vis[a[i].nx]){
					vis[a[i].nx]=1;
					q[++tl]=a[i].nx;
				}
			}
		}
	}
}

int main(){
	scanf("%d%d%d%d%d",&n,&k,&p,&b,&c);
	for(int i=1;i<=n;++i){
		for(int j=1;j<=n;++j){
			scanf("%d",&oil);
			for(int l=1;l<=k;++l){
				add(i,j,l,i,j,l+1,0);
			}
			if(oil){
				for(int l=2;l<=k+1;++l){
					add(i,j,l,i,j,1,p);
				}
				if(i<n) add(i,j,1,i+1,j,2,0);
				if(j<n) add(i,j,1,i,j+1,2,0);
				if(i>1) add(i,j,1,i-1,j,2,b);
				if(j>1) add(i,j,1,i,j-1,2,b);
			}else{
				for(int l=1;l<=k;++l){
					if(i<n) add(i,j,l,i+1,j,l+1,0);
					if(j<n) add(i,j,l,i,j+1,l+1,0);
					if(i>1) add(i,j,l,i-1,j,l+1,b);
					if(j>1) add(i,j,l,i,j-1,l+1,b);
				}for(int l=2;l<=k+1;++l){
					add(i,j,l,i,j,1,p+c);
				}
			}
		}
	}spfa();
	int ans=INF;
	for(int i=1;i<=k+1;++i) ans=min(ans,ln[n*n*i]);
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：吾王美如画 (赞：25)

# 唔姆
~~果然薯片+cola才是第一生产力~~

看这题明明是网络流24却没有一篇网络流的题解，我就来写一篇。~~我知道费用流肯定跑不过大佬们的最短路~~


------------
首先如果没有油量的限制，这就是一个标准费用流了，直接把向右下走的连费0容1，往回走的连费B容1，原点向（1,1）连费0容1，（N,N）向汇点连费0容1，然后跑一边最小费用最大流就完事了。

但是问题来了，我们如何控制油量呢？？

我们想到了分层图这个好东西。我们把图变成k+1层，第零层代表：满油，第一层代表：k-1格油....第k层代表没油。
- 当此处没有加油站时，我们要把第i层（0<=i<K）连向第i+1层的下一个位置，第k层则直接向第1层同一位置连上一个流1费A+C的边，因为到了第k层不加油就没法走了
- 当此处有加油站时，因为题目里说了是**强制消费**！！！，所以我们只能从第1层到第k层都向第0层连上一个费A流1的边，代表加油，然后第0层再向别的点连边
- 特别的，原点我们只连向第一层的(1,1)，但是所以层的（n,n）都要连向汇点，因为不管你还剩多少油，能到(n,n)就OK了

贴上代码~~依旧是那毒瘤码风~~
```cpp
#include<queue>
#include<cstdio>
#include<iostream>
#include<cstring>
#define MAXM 5000100
#define MAXN 1001000
using namespace std;
int to[MAXM],next[MAXM],w[MAXM],cost[MAXM],head[MAXN];
int n,m,S,T,ansl=0,ansc=0;
int cnt=-1;
int pre1[MAXN],pre2[MAXN],low[MAXN],dis[MAXN];
void link(int a,int b,int c,int d){
     cnt++;
     next[cnt]=head[a];
     w[cnt]=c;
     cost[cnt]=d;
     to[cnt]=b;
     head[a]=cnt;
     cnt++;
     next[cnt]=head[b];
     w[cnt]=0;
     cost[cnt]=-d;
     to[cnt]=a;
     head[b]=cnt;
}
bool spfa(){
     queue<int>q;
     fill(dis,dis+MAXN,66666666);
     int vis[MAXN];
     memset(vis,0,sizeof(vis));
     q.push(S);
     dis[S]=0;
     vis[S]=1;
     low[S]=66666666;
     while(!q.empty()){
                       int now=q.front();
                       vis[now]=0;
                       q.pop();
                       for(int i=head[now];i!=-1;i=next[i]){
                               if (w[i]>0&&cost[i]+dis[now]<dis[to[i]]){
                                                                        dis[to[i]]=dis[now]+cost[i];
                                                                        low[to[i]]=min(low[now],w[i]);
                                                                        pre1[to[i]]=now;
                                                                        pre2[to[i]]=i;
                                                                        if (!vis[to[i]]){
                                                                                         vis[to[i]]=1;
                                                                                         q.push(to[i]);
                                                                        }
                               }
                       }
     }
     return dis[T]!=66666666;
}
void work(){
     while(spfa()){
                   int now=T;
                   while(now!=S){
                                 int y=pre2[now];
                                 w[y]-=low[T];
                                 w[y^1]+=low[T];
                                 now=pre1[now];
                   }
                   ansl+=low[T];
                   ansc+=low[T]*dis[T];
     }
}
int num(int a,int b){
    return (a-1)*n+b;
}
int main(){
    int K,A,B,C;
    memset(head,-1,sizeof(head));
    cin>>n>>K>>A>>B>>C;
    S=0;T=MAXN-1;
    link(S,num(1,1),1,0);
    for(int i=0;i<=K;i++)
            link(num(n,n)+10001*i,T,1,0);
    for(int i=1;i<=n;i++){
            for(int j=1;j<=n;j++){
                    int a;
                    scanf("%d",&a);
                    if (a)for(int k=1;k<=K;k++)link(num(i,j)+k*10001,num(i,j),1,A);
                    for(int k=0;k<K;k++){
                            if (a&&k)break;
                            if (i+1<=n)link(num(i,j)+k*10001,num(i+1,j)+(k+1)*10001,MAXM,0);
                            if (j+1<=n)link(num(i,j)+k*10001,num(i,j+1)+(k+1)*10001,MAXM,0);
                            if (i-1>0)link(num(i,j)+k*10001,num(i-1,j)+(k+1)*10001,MAXM,B);
                            if (j-1>0)link(num(i,j)+k*10001,num(i,j-1)+(k+1)*10001,MAXM,B);
                    }
                    link(num(i,j)+K*10001,num(i,j),1,A+C);
            }
    }
    work();
    cout<<ansc<<endl;
    return 0;
}

```

---

## 作者：MloVtry (赞：25)

n<=100
k<=10
100\*100\*10=100000

.......

出来吧SPFA！

上来就是一发spfa

处理一下转移

有加油站一定加油，所以如果在加油站并且油不是满的，那肯定得先加一发油

然后枚举四个方向转移一下，求个坠短路

代码
        
```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<queue>
using namespace std;
int dis[110][110][15],init[110][110][15];
int n,k,a,b,c,ma[110][110];
struct node
{
    int x,y,k;
};
queue<node> q;
int dx[4]={-1,0,1,0};
int dy[4]={0,1,0,-1};
int main()
{
    scanf("%d%d%d%d%d",&n,&k,&a,&b,&c);
    for(int i=1;i<=n;++i)
    for(int j=1;j<=n;++j) scanf("%d",&ma[i][j]);
    memset(dis,20,sizeof(dis));
    dis[1][1][k]=0;init[1][1][k]=1;
    q.push((node){1,1,k});
    while(!q.empty())
    {
        int X=q.front().x;
        int Y=q.front().y;
        int K=q.front().k;q.pop();
//        cout<<"("<<X<<","<<Y<<")"<<" :"<<K<<"   "<<dis[X][Y][K]<<endl;
        init[X][Y][K]=0;
        if(ma[X][Y]&&K!=k)//加油 
        {
            if(dis[X][Y][k]>dis[X][Y][K]+a)
            {
                dis[X][Y][k]=dis[X][Y][K]+a;
                if(!init[X][Y][k])
                init[X][Y][k]=1,q.push((node){X,Y,k});
            }
            continue;
        } 
        else
        {
            if(dis[X][Y][k]>dis[X][Y][K]+a+c)
            {
                dis[X][Y][k]=dis[X][Y][K]+a+c;
                if(!init[X][Y][k])
                init[X][Y][k]=1,q.push((node){X,Y,k});
            }
        }
        if(K>0)//开车 
        for(int i=0;i<4;++i)
        {
            int x=X+dx[i];
            int y=Y+dy[i];
            if(x<1||x>n||y<1||y>n) continue;
            int len=0;
            if(x<X||y<Y) len=b;
            if(dis[x][y][K-1]>dis[X][Y][K]+len)
            {
                dis[x][y][K-1]=dis[X][Y][K]+len;
                if(!init[x][y][K-1])
                init[x][y][K-1]=1,q.push((node){x,y,K-1});
            }
        }
    }
    int ans=(1<<30);
    for(int i=0;i<=k;++i)
    ans=min(ans,dis[n][n][i]);
    printf("%d\n",ans);
    return 0;
}
//岛风快回家啊啊啊啊啊啊
//有戒指有新衣服就差人了啊啊啊啊啊啊啊啊啊

```

---

## 作者：辰星凌 (赞：20)


# **【题解】【网络流24题】汽车加油行驶问题 [P4009] [Loj6223]**

**传送门：[汽车加油行驶问题 $[P4009]$](https://www.luogu.org/problem/P4009) [$[Loj6223]$](https://loj.ac/problem/6223)**

## **【题目描述】**

给出一个 $N \times N$ 的方形网格，设$(1,1)$为起点，$(N,N)$ 为终点，$X$ 轴向右为正， $Y$ 轴向下为正。

某些地方设有油库，可供汽车加油。汽车行驶应遵守如下规则:
$(1).$ 汽车装满油后能行驶 $K$ 次，每次行驶距离为 $1$。**出发时**汽车为**满油**状态，**在起点与终点处不设油库**。

$(2).$  汽车行驶路线 $X$ 坐标或 $Y$ 坐标每减小 $1$，则应付费用 $B$ ，反之则不用。

$(3).$  在行驶过程中遇到油库会**强制加满油**并付加油费用 $A$。

$(4).$  途中可在某点处增设加油站，增设费用为 $C$ $($**不含加油费用** $A$ $)$。

求出汽车从起点出发到达终点所付的最小费用。

**【输入】**

第一行五个**正整数** $N,K,A,B,C$。
接下来是一个 $N \times N$ 的 $01$ 矩阵，一共 $n$ 行，每行 $n$ 个整数。
矩阵的第 $i$ 行第 $j$ 列处的值为 $1$ 表示$(i,j)$ 处有一个加油站,为 $0$ 则无。

**【数据范围】**

$100\%$ $2 \leqslant n \leqslant 100,$ $2 \leqslant k \leqslant 10$

-------

## **【分析】**

这明明是一道网络瘤的题中 なのに，但为啥网络瘤的题解基本没几篇啊 $...$

解题思路与这位大佬类似：[吾王美如画](https://www.luogu.org/blog/I-love-saber/solution-p4009)，本篇题解将针对一些细节进行分析。

首先，应该如何建模呢？

### **【建模】**

俗话说得好啊：**网络瘤，网络瘤，网络建模最毒瘤。**

注意题目描述中加黑字体部分，如果仔细想想的话，会发现出题人特别良心，为我们去除了很多复杂的情况，建模也方便了许多。

先将题目略微修改一下，原题意不变：**一份油可供汽车走一个单位长度，油箱最多可装 $K$ 份油。**

$(1).$ **分层**：

把每个坐标分为 $K+1$ 层，用第 $0$ 层表示满油状态，第 $1$ 层表示用掉了 $1$ 份油，第 $2$ 表示用掉了 $2$ 份油 $...$ 第 $K$ 层表示油被用光的状态。

$(2).$ 搞一个**超级源点**和一个**超级汇点**：

**超级源点**与第 $0$ 层的 $(1,1)$（满油状态的起点）连一条**流量为** $1$ **费用为** $0$ 的边。

每一层的 $(n,n)$（任意状态的终点）与**超级汇点**分别连一条**流量为** $1$ **费用为** $0$ 的边。
由于起点与终点重合的情况不存在，所以汽车不可能以满油的状态到达任意一个点，只会以满油的状态从某个点出发（在起点或者加了油之后），因此第 $0$ 层也可以不用连。

$(3).$ 当处理某个点 $(i,j)$ 时，发现这里~~满是汽油味~~（**有加油站**）：

**不管油箱里还有多少油**，不知所措的可怜新司机都会被黑心商家**强迫加油**，所以每一层的 $(i,j)$ 都要与第 $0$ 层的 $(i,j)$ 连一条**流量为** $1$ **费用为** $A$的边，与上面所说相同，第 $0$ 层可以不连（实际上自己到自己的边就算连了也不会选）。然后第 $0$ 层的 $(i,j)$ 再与上下左右四个方向坐标的第 $1$ 层分别连一条**流量为** $1$ 的边，当**向左**、**向上**时**费用为** $B$，反之**费用为** $0$ 。

$(4).$ 当处理某个点 $(i,j)$ 时，发现这里~~空气清新~~（**没有加油站**）：

可以选择在这里**生成一个加油站**，将第 $K$ 层的 $(i,j)$（空油箱）与 第 $0$ 层的 $(i,j)$ 连一条流量为 $1$ 费用为 $A+C$ 的边。然后对于 $k \in [0,K-1]$，将第 $k$ 层的 $(i,j)$ 与上下左右四个方向坐标的第 $k+1$ 层分别连一条**流量为** $1$ 的边，**费用**同上。注意：可以从满油状态出发，所以第 $0$ 层也要连出去。

$Q:$ あの、あの、为什么坐标与坐标连边时流量为 $1$ 鸭？嗯 $...$ 为什么只在油箱为空时才生成加油站捏？还有哇，生成的加油站可能会在下一次到达时再次使用咩？

$A:$ 其实是有点贪心的味道，由于往回走有花费且为**正整数**，所以不会回到已经走过的地方去。生成加油站也是一样的，反正早点生成晚点生成都没有影响，在一条路走到底后再生成不是更好吗？因此上面所有的建边**流量都为** $1$，而不是 $inf$。如果你愿意，用 $inf$ 也没关系，只要把超级源点或超级汇点连出去的边流量设为 $1$ 即可。

### **【求答案】**

跑一便 $MCMF$ 模板就可以了。最大流为 $1$，最小花费即为答案。

$Q:$ 什么?最大流为 $1$？那和跑最短路有什么区别？直接去掉费用流中 $EK$ 的过程，留下 $SPFA$ 不就是个最短路了吗？
$A:$ 好像没毛病。。。但毕竟这道题考察的是建模能力嘛，只要模型分析了出来，用什么算法实现都无所谓啦！$QAQ$

最后再粗略地算一算这道题的空间复杂度：
首先是点数，$N*N$ 个坐标，$K+1$ 层，加上超级源、汇点，总点数为：$(100*100*11+2=110002)$。
然后是边数，$N*N$ 个坐标，$K+1$ 层，每层每个坐标要与上下左右四个方向连边，还要与第 $0$ 层连边（表示加油），然后终点的每一层都要与超级汇点相连，最后是超级源点和起点的连边，对于每条边都要同时建一条反向边供我们反悔，总边数为：$(N*N*(K+1)*4+K+1)*2=440011*2$ 。当然，实际上基本达不到这个值。

## **【Code】**

```cpp
#include<algorithm>
#include<cstdio>
#include<queue>
#define LL long long
#define Re register int
using namespace std;
const int N=11e4+5,M=6e5+5,inf=2e9;
int x,y,z,w,o=1,n,m,h,t,A,B,C,K,st,ed,cyf[N],pan[N],pre[N],dis[N],head[N];LL mincost,maxflow; 
struct QAQ{int w,to,next,flow;}a[M<<1];queue<int>Q;
inline void in(Re &x){
    int f=0;x=0;char c=getchar();
    while(c<'0'||c>'9')f|=c=='-',c=getchar();
    while(c>='0'&&c<='9')x=(x<<1)+(x<<3)+(c^48),c=getchar();
    x=f?-x:x;
}
inline void add(Re x,Re y,Re z,Re w){a[++o].flow=z,a[o].w=w,a[o].to=y,a[o].next=head[x],head[x]=o;}
inline void add_(Re a,Re b,Re flow,Re w){add(a,b,flow,w),add(b,a,0,-w);}
inline int SPFA(Re st,Re ed){
    for(Re i=0;i<=ed;++i)dis[i]=inf,pan[i]=0;
    Q.push(st),pan[st]=1,dis[st]=0,cyf[st]=inf;
    while(!Q.empty()){
    	Re x=Q.front();Q.pop();pan[x]=0;
    	for(Re i=head[x],to;i;i=a[i].next)
            if(a[i].flow&&dis[to=a[i].to]>dis[x]+a[i].w){
            	dis[to]=dis[x]+a[i].w,pre[to]=i;
            	cyf[to]=min(cyf[x],a[i].flow);
            	if(!pan[to])pan[to]=1,Q.push(to);
            }
    }
    return dis[ed]!=inf;
}
inline void EK(Re st,Re ed){
    while(SPFA(st,ed)){
    	Re x=ed;maxflow+=cyf[ed],mincost+=(LL)cyf[ed]*dis[ed];
    	while(x!=st){
            Re i=pre[x];
            a[i].flow-=cyf[ed];
            a[i^1].flow+=cyf[ed];
            x=a[i^1].to;
    	}
    }
}
inline int P(Re x,Re y,Re k){return (x-1)*n+y+k*n*n;}
int main(){
    in(n),in(K),in(A),in(B),in(C),st=(K+1)*n*n+1,ed=st+1;//一共有(K+1)层 
    add_(st,P(1,1,0),1,0);//超级源点连到满油的起点 
    for(Re k=1;k<=K;++k)add_(P(n,n,k),ed,1,0);
    //把每一层的终点连到超级汇点，所以第0层可以不连 
    for(Re i=1;i<=n;++i)
    	for(Re j=1;j<=n;++j){
            in(x);
            if(x){//已有加油站 
            	for(Re k=1;k<=K;++k)add_(P(i,j,k),P(i,j,0),1,A);
            	//所有状态都必须花费A加油加到满，但由于不可能满油到达某一点，所以满油的第0层可以不加（连） 
            	//加满油之后状态可以由满油状态到达K-1油的上下左右四个方向 
            	if(i<n)add_(P(i,j,0),P(i+1,j,1),1,0);//横坐标+1,费用为0 
            	if(j<n)add_(P(i,j,0),P(i,j+1,1),1,0);//纵坐标+1,费用为0 
            	if(i>1)add_(P(i,j,0),P(i-1,j,1),1,B);//横坐标-1,费用为B 
            	if(j>1)add_(P(i,j,0),P(i,j-1,1),1,B);//纵坐标-1,费用为B 
            }
            else{//无加油站 
            	for(Re k=0;k<K;++k){//从有油的状态到达下一层的四个方向 
                    if(i<n)add_(P(i,j,k),P(i+1,j,k+1),1,0);//横坐标+1,费用为0 
                    if(j<n)add_(P(i,j,k),P(i,j+1,k+1),1,0);//纵坐标+1,费用为0 
                    if(i>1)add_(P(i,j,k),P(i-1,j,k+1),1,B);//横坐标-1,费用为B 
                    if(j>1)add_(P(i,j,k),P(i,j-1,k+1),1,B);//纵坐标-1,费用为B 
            	}
            	add_(P(i,j,K),P(i,j,0),1,A+C);//没有加油站的地方可以自给自足 
            }
    	}
    EK(st,ed);//跑一跑模板MCMF 
    printf("%lld",mincost);
}
```




---

## 作者：wjyyy (赞：14)

[欢迎来我的blog食用](http://www.wjyyy.top/728.html)

### 它真的是网络流24题吗

本题要求从左上角走到右下角，并且还会有强制消费，因此我们根据状态**递推**。为了保证最优解，我们是可以不理会它的强制消费转而向左或向上走，但是这样可能会有**时间不同步**的情况，不方便处理，所以我们试着把这个过程**分层**。类似广搜，实则**DP**，我们每次**只走一步**更新状态是最稳妥的。而对于每个状态取的都是**最小值**，所以引出了**DP**的思想。

对于每个点来说，我们一旦出发,**时间轴**就会向前推进，为了保证状态正确，我们额外开一维使得状态只能来**自同时的相邻的四个点**，也就是**分层**的思想。那么一直推下去，理论最坏复杂度为$N^5$，路径长度可能达到$N^2$甚至更多，而根据考试策略，对于最大情况100×100控制在1s以内（最好是0.8s左右），来控制分层图的层数。于是我就定了分层为一个**固定的不会爆1s**的常数~~（经测试33333可能比较符合我的常数）~~除以n的大小，这样既保证了小数据的正确性（此时n较小），又可以碰碰运气看较大数据是否能跑出正确解。

这个题还是有一些细节需要注意的，不仅是判断加油或绕路，而且还可以在**任何想建立**加油站的地方建立加油站，然后更新每个状态取最小值就可以了，只要**方程中**状态相同，从这里怎么转移出去都是一样的，就有点像**DP**的做法了。

实际上，由于最短路径长度为2n-1，加油费用与向上/左绕路在变动较大时可能是**加油更优**，那么我们基本可以推测到最短路径的长度在4n以内（虽然题目没给A,B,C的范围），考试时为了稳妥还是稍微卡一下时好了。转移方程也是比较清晰的~~，就是状态比较多**而已**~~。

## Code：
```cpp
#include<cstdio>
#include<cstring>
int min(int x,int y)
{
    return x<y?x:y;
}
int f[2][105][105][12];//第一维滚动 二三维坐标 第四维是还剩多少油
int g[105][105];
int ans=0x7fffffff;
int main()
{
    memset(f,0x3f,sizeof(f));
    int n,k,a,b,c;
    scanf("%d%d%d%d%d",&n,&k,&a,&b,&c);
    f[0][1][1][k]=0;//初始化
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
            scanf("%d",&g[i][j]);
    int up=33333/n;
    for(int t=1;t<=up;t++)//这是一个不爆时间的范围
        for(int i=1;i<=n;i++)
            for(int j=1;j<=n;j++)
            {
                if(g[i][j]==0)//没有强制消费
                {
                    for(int l=1;l<=k;l++)
                    {
                        f[t&1][i][j][l-1]=0x3f3f3f3f;//滚动数组优化时间（也可以不用这一行，因为越到后面越费钱）
                        if(i>1)
                            f[t&1][i][j][l-1]=min(f[t&1][i][j][l-1],f[t&1^1][i-1][j][l]);
                        if(i<n)
                            f[t&1][i][j][l-1]=min(f[t&1][i][j][l-1],f[t&1^1][i+1][j][l]+b);
                        if(j>1)
                            f[t&1][i][j][l-1]=min(f[t&1][i][j][l-1],f[t&1^1][i][j-1][l]);
                        if(j<n)
                            f[t&1][i][j][l-1]=min(f[t&1][i][j][l-1],f[t&1^1][i][j+1][l]+b);
                        if(i==j&&j==n)//更新答案
                            ans=ans<f[t&1][i][j][l-1]?ans:f[t&1][i][j][l-1];
                    }
                    if(i>1)
                        f[t&1][i][j][k]=min(f[t&1][i][j][k],f[t&1^1][i-1][j][1]+c+a);
                    if(i<n)
                        f[t&1][i][j][k]=min(f[t&1][i][j][k],f[t&1^1][i+1][j][1]+c+a+b);
                    if(j>1)
                        f[t&1][i][j][k]=min(f[t&1][i][j][k],f[t&1^1][i][j-1][1]+c+a);
                    if(j<n)
                        f[t&1][i][j][k]=min(f[t&1][i][j][k],f[t&1^1][i][j+1][1]+c+a+b);
                    if(i==j&&j==n)
                        ans=ans<f[t&1][i][j][k]?ans:f[t&1][i][j][k];
                }
                else//有强制消费
                {
                    for(int l=1;l<=k;l++)
                    {
                        if(i>1)
                            f[t&1][i][j][k]=min(f[t&1][i][j][k],f[t&1^1][i-1][j][l]+a);
                        if(i<n)
                            f[t&1][i][j][k]=min(f[t&1][i][j][k],f[t&1^1][i+1][j][l]+a+b);
                        if(j>1)
                            f[t&1][i][j][k]=min(f[t&1][i][j][k],f[t&1^1][i][j-1][l]+a);
                        if(j<n)
                            f[t&1][i][j][k]=min(f[t&1][i][j][k],f[t&1^1][i][j+1][l]+a+b);
                    }
                }
            }
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：getchar123 (赞：12)

分层图+堆优化Dijkstra   
其它的看注释吧  
下面代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,a,b,c,ma[101][101],ma1[101][101][11],xx[4]={0,1,0,-1},yy[4]={1,0,-1,0},vis[101][101][11];//ma记录地图，ma1分层图，记录各种情况所需费用
priority_queue<pair<int,pair<int,pair<int,int> > > >q;
void Dijkstra(){
	memset(ma1,0x7f,sizeof(ma1));
	ma1[1][1][k]=0;
	q.push(make_pair(0,make_pair(k,make_pair(1,1))));
	while(q.empty()==false){
		int z=q.top().second.first,x=q.top().second.second.first,y=q.top().second.second.second;q.pop();//x,y为坐标，z为油量
		if(vis[x][y][z]==0){
			vis[x][y][z]=1;
			for(int i=0;i<4;i++){//类似于广搜，扩展上下左右
				int x1=x+xx[i],y1=y+yy[i],z1=z-1,rmb=ma1[x][y][z];//x1,y1为坐标，z1为油量，rmb为花费的人民币（划掉）
				if(x1>0&&x1<=n&&y1>0&&y1<=n){
					if(ma[x1][y1]==1){//强制消费
						rmb+=a;z1=k;
					}
					if(z1==0){//没油了建一个油库加油（至于为什么不用记录到地图里，因为任意一条最优路径都不可能经过同一个油库两次（应该一眼就能看出来吧））
						rmb+=c+a;z1=k;
					}
					if(i>=2){//正常走路
						rmb+=b;
					}
					if(rmb<ma1[x1][y1][z1]){//更新
						ma1[x1][y1][z1]=rmb;
						q.push(make_pair(-rmb,make_pair(z1,make_pair(x1,y1))));
					}
				}
			}
		}
	}
	int minn=1e9;
	if(ma1[n][n][k]!=0x7f)ma1[n][n][0]=ma1[n][n][k]-c-a;//可能会出现走到终点正好没油的情况
	for(int i=0;i<k;i++){//扫描终点所有层
		minn=min(minn,ma1[n][n][i]);
	}
	cout<<minn;
	return;
}
int main(){
	cin>>n>>k>>a>>b>>c;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			cin>>ma[i][j];
		}
	}
	Dijkstra();
	return 0;
}

```

最后，推荐一道题https://www.luogu.org/problemnew/show/P4011 同样是分层图+堆优化Dijkstra+~~二进制状压~~

---

## 作者：bugaile (赞：10)

题目大意$:$
给你一个$N*N$的矩阵,求汽车从$(1,1)$到$(N,N)$的最小花费,汽车行进一格需要消耗一点油,汽车油储量为$k$.

$1.$若汽车到达一个有加油站的点,那么必须将油加满为$k$,花费为$a;$

$2.$若汽车往回走,即前往的点的横坐标或者纵坐标在减小,需要花费$b;$

$3.$汽车也可以自己新建一个加油站,花费$c($不包括加油费用$a);$


该题目直接想不容易,但如果想到了分层图$($~~蒟蒻不知道网络流~~$)$,也就比较容易了.

我们按耗油量划分层数,对于每一个点$(now,x,y)$,$now$表示档期用了多少油,即划分层数,$x,y$表示点在当前层的位置.而点$(now,x,y)$可以向$(now+1,x+1,y),(now+1,x,y+1),(now+1,x-1,y),(now+1,x,y-1)$连边,具体权值按题目要求即可.

对于每个点都如此连边即可.但有一些需要注意的$:$

$1.$如果当前点$(now,x,y)$有加油站,那么需要在$(now,x,y)$向$(0,x,y)$连接一条边即可.

$2.$如果当前点已耗油$k$,即当前点为$(k,x,y)$,并且没在上一种情况中处理,那么需要新建一个加油站,即从$(k,x,y)$向$(0,x,y)$连一条**权值为$a+c$的边**
因为新建的加油站是不包含加油费用的.

$3.$一个相对容易忽略的细节,就是在情况$1$中,如果油已经满了,即$now=k$,需要向周围连边,如果你不连边,那么你就只能在每一个节点新建加油站,而不能利用已有的加油站,因为你没有从有加油站的点走出来.

最后跑一遍最短路即可总体时间复杂度为$O(K*N*N+K*N*N*log(K*N*N))$


```cpp
#include<queue>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#define mian main
using namespace std;
const int N=102,K=11;
int n,k,a,b,c,cnt;
int id[N][N],dis[N*N*K],o[N][N],vis[N*N*K];
int wx[5]={0,-1,0,1,0};
int wy[5]={0,0,-1,0,1};
int to[N*N*K<<2],nex[N*N*K<<2],w[N*N*K<<2],head[N*N*K],tt;
priority_queue<pair<int,int>,vector<pair<int,int> >,greater<pair<int,int> > >Q;
inline void add(int x,int y,int W){
	to[++tt]=y,w[tt]=W,nex[tt]=head[x],head[x]=tt;
	return ;
}
int mian(){
	cin>>n>>k>>a>>b>>c;
	for(int i=1;i<=n;++i)
		for(int j=1;j<=n;++j)
			id[i][j]=++cnt,cin>>o[i][j];预处理节点编号,读入加油站;
	for(int now=0;now<=k;++now){
		for(int i=1;i<=n;++i)
			for(int j=1;j<=n;++j){
				int p1=id[i][j];
				if(o[i][j]){
					add(now*n*n+p1,p1,a);//处理当前有油的情况;
					if(!now){//加满油后同样要向四周连边;
						for(int Q=1;Q<5;++Q){
							int nx=wx[Q]+i;
							int ny=wy[Q]+j;
							if(nx<1||ny<1||nx>n||ny>n)continue;
							int p2=id[nx][ny];
							if(Q<3)//处理后退的情况;
								add(now*n*n+p1,(now+1)*n*n+p2,b);
							else
								add(now*n*n+p1,(now+1)*n*n+p2,0);
						}
					}
				}
				else
					if(now==k)
						add(now*n*n+p1,p1,c+a);//没油,也没加油站,连接的边权为a+c;
					else
						for(int Q=1;Q<5;++Q){
							int nx=wx[Q]+i;
							int ny=wy[Q]+j;
							if(nx<1||ny<1||nx>n||ny>n)continue;
							int p2=id[nx][ny];//向四周连边;
							if(Q<3)
								add(now*n*n+p1,(now+1)*n*n+p2,b);
							else
								add(now*n*n+p1,(now+1)*n*n+p2,0);
						}
			}
	}
	memset(dis,0x3f,sizeof dis);
	dis[1]=0;//从(0,1,1),即0耗油,在(1,1)节点;
	Q.push(make_pair(0,1));
	while(Q.size()){//跑最短路;
		int q=Q.top().second;Q.pop();
		if(vis[q])continue;
		vis[q]=1;
		for(int i=head[q],u;i;i=nex[i]){
			u=to[i];
			if(dis[u]>dis[q]+w[i]){
				dis[u]=dis[q]+w[i];
				Q.push(make_pair(dis[u],u));
			}
		}
	}
	int ans=0x3f3f3f3f;
	for(int i=0;i<=k;++i)//耗油量不影响终点的位置,所以要在所有耗油量中求个最小值;
		ans=min(ans,dis[i*n*n+id[n][n]]);
	cout<<ans<<endl;
	return 0;
}

---

## 作者：L_key (赞：7)

这个代码大概不是最优解，可是用简单的广搜也AC了。

代码里打了一些要注意的细节。

简单的代码：
```cpp
#include<cstdio>
#include<cstring>
using namespace std;
int mymin(int x,int y){return x<y?x:y;}
int dx[4]={-1,0,1,0};
int dy[4]={0,-1,0,1};
int n,k;long long a,b,c;
struct node
{
	int x,y,o;long long s;//s表示花费，o（oil）表示剩多少油。
}list[8110010];int head,tail;
int map[110][110];
long long d[110][110];//目前最小花费。
int kk[110][110];//当小花费时剩余有多少油。
int main()
{
	scanf("%d%d%lld%lld%lld",&n,&k,&a,&b,&c);
	for(int i=1;i<=n;i++)for(int j=1;j<=n;j++)scanf("%d",&map[i][j]);
	memset(d,63,sizeof(d));d[1][1]=0;kk[1][1]=k;
	list[1].x=list[1].y=head=1;tail=2;list[1].s=0;list[1].o=k;
	while(head!=tail)
	{
		for(int t=0;t<=3;t++)
		{
			node x=list[head];
			x.x+=dx[t];
			x.y+=dy[t];
			if(x.x>=1&&x.x<=n&&x.y>=1&&x.y<=n)
			{
				if(x.x==n&&x.x==x.y){d[n][n]=mymin(d[n][n],x.s);continue;}//当到达终点，就不需要再加油了。
				x.o--;
				if(map[x.x][x.y]==1)x.s+=a,x.o=k;
				else if(x.o==0)x.s+=(c+a),x.o=k;
				if(t<=1)x.s+=b;
				if(x.s>d[n][n])continue;
				if(x.s<d[x.x][x.y])
				{
					d[x.x][x.y]=x.s;
					kk[x.x][x.y]=x.o;
					list[tail++]=x;
				}
				else if(x.o>kk[x.x][x.y]&&x.s<d[x.x][x.y]+a+c)list[tail++]=x;
                //留条活路给比目前最小费用高但剩的油多的。
//因为目前的最小花费未来可能会因油不够而加油，加油后费用比这个费用要高。
			}
			if(tail==8110000)tail=1;
		}
		if((++head)==8110000)head=1;
	}
	printf("%lld\n",d[n][n]);
	return 0;
}
```
如果有什么问题、错误或建议请留言。

---

## 作者：Santiego (赞：6)


> 1. 汽车只能沿网格边行驶，装满油后能行驶 $K$ 条网格边。出发时汽车已装满油，在起点与终点处不设油库。
> 2. 汽车经过一条网格边时，若其 $X$ 坐标或 $Y$ 坐标减小，则应付费用 $B$ ，否则免付费用。
> 3. 汽车在行驶过程中遇油库则应加满油并付加油费用 $A$。
> 4. 在需要时可在网格点处增设油库，并付增设油库费用$C$(不含加油费用$A$ )。

建$k+1$层图，表示汽车油量$k$的状态（油量$0\cdots k$），然后根据具体规则在其上建图**以转移状态**。规定第$k$层（从$0$开始）第$i$行第$j$列点编号为$k*n*n+(i-1)*n+j$，然后起点即为$k*n*n+1$，新建一个超级终点，将每层图的$n*n$这个点建一条边权为$0$的边指向这个超级终点即可。

跑最短路的过程相当于状态转移求解$DP$的过程。

```cpp
#include <cstdio>
#include <queue>
#include <cstring>
using namespace std;
#define MAXN 110*110
#define MAXK 13
#define MAXM MAXN*4
inline int read(){
    char ch=getchar();int s=0;
    while(ch<'0'||ch>'9') ch=getchar();
    while(ch>='0'&&ch<='9') s=s*10+(ch^'0'), ch=getchar();
    return s;
}
int head[MAXN*MAXK],nxt[MAXM*MAXK],vv[MAXM*MAXK],ww[MAXM*MAXK],tot;
inline void add_edge(int u, int v, int w){
    vv[++tot]=v;
    ww[tot]=w;
    nxt[tot]=head[u];
    head[u]=tot;
}
bool ins[MAXN*MAXK];
int dis[MAXN*MAXK];
queue <int> q;
void spfa(int s){
    memset(dis, 0x3f, sizeof dis);
    memset(ins, 0, sizeof ins);
    while(!q.empty()) q.pop();
    dis[s]=0;
    q.push(s);
    while(!q.empty()){
        int u=q.front();q.pop();
        ins[u]=0;
        for(register int i=head[u];i;i=nxt[i]){
            int v=vv[i],w=ww[i];
            if(dis[v]>dis[u]+w){
                dis[v]=dis[u]+w;
                if(!ins[v]) q.push(v),ins[v]=1;
            }
        }
    }
}
int n,k,cost_a,cost_b,cost_c;
inline void add(int ux, int uy, int uz, int vx, int vy, int vz, int w){
    add_edge((ux-1)*n+uy+uz*n*n, (vx-1)*n+vy+vz*n*n, w);
}
int main(){
    n=read(),k=read(),cost_a=read(),cost_b=read(),cost_c=read();
    for(register int i=1;i<=n;++i)
        for(register int j=1;j<=n;++j){
            int rd=read();
            if(rd==0){
                for(int t=0;t<k;++t) add(i, j, t, i, j, k, cost_a+cost_c);
                for(int t=1;t<=k;++t){
                    if(i>=2) add(i, j, t, i-1, j, t-1, cost_b);
                    if(j>=2) add(i, j, t, i, j-1, t-1, cost_b);
                    if(i<=n-1) add(i, j, t, i+1, j, t-1, 0);
                    if(j<=n-1) add(i, j, t, i, j+1, t-1, 0);
                }
            }else{
                for(int t=0;t<k;++t) add(i, j, t, i, j, k, cost_a);
              	// 有加油站的必须加满油，所以只在k层图上建边
                if(i>=2) add(i, j, k, i-1, j, k-1, cost_b);
                if(j>=2) add(i, j, k, i, j-1, k-1, cost_b);
                if(i<=n-1) add(i, j, k, i+1, j, k-1, 0);
                if(j<=n-1) add(i, j, k, i, j+1, k-1, 0);
            }
        }
    for(int i=0;i<=k;++i)
        add(n, n, i, 1, 1, k+1, 0); // 超级终点
    spfa(1+n*n*k);
    printf("%d", dis[1+n*n*(k+1)]);
    return 0;
}
```




---

## 作者：FREEH (赞：2)

### 【题目】
![题目](https://cdn.luogu.com.cn/upload/pic/25940.png)
### 【解题思路】
- 虽然本题是网络流24题之一，但可以用最短路径。
- 根据题目所说的方法跑最短路径就可以了。

### 【解题反思】
- 本题有很多细节
	1. 油没满**必须**加
	1. 油**仅有**为0时才新增加油站
- 以上2点都**没有选择**的机会
- 在处理加油的时候要考虑清楚：遇到油站时，原地加油**只算一个状态**，不能多算，因为遇到油站时必须要加（没满）油，因此不加油的情况是不存在的。
- 读题要非常仔细，考虑状态要全面。

### 【参考程序】
```cpp
#include<cstdio>
#include<queue>
#include<cstring>
#include<iostream>
using namespace std;

#define INF 0x3f3f3f3f3f
int n,a,b,c,k;
int oil[105][105],vis[105][105][15];
int dis[105][105][15];

struct QUE{
	int x,y,oil;
};
queue < QUE > q;
int dx[5]={0,1,0,-1,0},dy[5]={0,0,1,0,-1};
void SPFA()
{
	memset(dis,0x3f,sizeof dis);
	memset(vis,0,sizeof vis);
	q.push((QUE){1,1,k});
	dis[1][1][k]=0;
	while (!q.empty())
	{
		QUE u=q.front();q.pop();
		QUE v=u;
		vis[u.x][u.y][u.oil]=false;
		
		int plus=0;
		if (oil[u.x][u.y])
		{
			if (u.oil!=k)
			{
				v.oil=k;
				plus+=a;
				if (dis[u.x][u.y][u.oil]+plus<dis[v.x][v.y][v.oil])
				{
					dis[v.x][v.y][v.oil]=dis[u.x][u.y][u.oil]+plus;
					if (!vis[v.x][v.y][v.oil])
					{
						vis[v.x][v.y][v.oil]=true;
						q.push(v);
					}
				}
				continue;//注意要continue
			}
		}
		else
		if (u.oil==0)
		{
			v.oil=k;
			plus+=a+c;
		}
		if (dis[u.x][u.y][u.oil]+plus<dis[v.x][v.y][v.oil])
		{
			dis[v.x][v.y][v.oil]=dis[u.x][u.y][u.oil]+plus;
			if (!vis[v.x][v.y][v.oil])
			{
				vis[v.x][v.y][v.oil]=true;
				q.push(v);
			}
		}
		
		for (int i=1;i<=4;i++)
		{
			plus=0;
			v=u;
			v.x=u.x+dx[i];
			v.y=u.y+dy[i];
			if (v.x<1||v.x>n||v.y<1||v.y>n) continue;
			if (i>=3)
				plus+=b;
			v.oil--;
			if (v.oil<0) continue;
			if (dis[u.x][u.y][u.oil]+plus<dis[v.x][v.y][v.oil])
			{
				dis[v.x][v.y][v.oil]=dis[u.x][u.y][u.oil]+plus;
				if (!vis[v.x][v.y][v.oil])
				{
					vis[v.x][v.y][v.oil]=true;
					q.push(v);
				}
			}
		
		}
	}
}
int main()
{
	scanf("%d%d%d%d%d",&n,&k,&a,&b,&c);
	for (int i=1;i<=n;i++)
		for (int j=1;j<=n;j++)
			scanf("%d",&oil[i][j]);
	
	SPFA();
	
	int ans=INF;
	for (int i=0;i<=k;i++)
		ans=min(ans,dis[n][n][i]);
	printf("%d",ans);
	return 0;
}
```

---

## 作者：SIGSEGV (赞：2)

这题实在是坑...... 强制用广搜AC

别问我为什么没开循环队列

广搜时要注意判重，我运用了分层思想。
```cpp
#include <bits/stdc++.h>
using namespace std;
struct Node{int x,y,money,power;} q[1000001];
int st,en,a,b,c,arr[101][101][21],l,mx,mz[101][101],
    dx[] = {1,0,-1,0},dy[] = {0,1,0,-1};
int ans = INT_MAX;
int main ()
{
    scanf("%d%d%d%d%d",&l,&mx,&a,&b,&c);
    for (int i = 1;i <= l;++i)
        for (int j = 1;j <= l;++j) scanf("%d",&mz[i][j]);
    arr[1][1][mx] = 0;
    q[en++] = {1,1,0,mx};
    for (int i = 1;i <= l;++i)
        for (int j = 1;j <= l;++j)
            for (int k = 0;k <= 10;++k) arr[i][j][k] = INT_MAX;//arr里记录的是在坐标分别为i,j的情况下邮箱里还剩下k油时花掉的最小金钱
    while (st != en) //BFS正片
    {
        Node nd = q[st++];
        for (int i = 0;i < 4;++i)
        {
            int nx = nd.x + dx[i],ny = nd.y + dy[i],nm = nd.money; 
            if(nx <= 0 || nx > l || ny <= 0 || ny > l) continue;
            if(nx < nd.x || ny < nd.y) nm += b;//如果是逆行
            if(mz[nx][ny]) //此处有加油站
            {
                nm += a;
                if(arr[nx][ny][mx] <= nm) continue; //以花钱更少的路径到此
                arr[nx][ny][mx] = nm;
                q[en++] = {nx,ny,nm,mx};//入队
            }
            else
            {
                if(nd.power == 1) //没油啦
                {
                    if(nx == l && ny == l)
                    {
                        if(nm < ans) ans = nm;
                        continue;
                    }
                    if(arr[nx][ny][mx] <= nm + c + a) continue;
                    arr[nx][ny][mx] = nm + c + a;//原地制造加油站（不用标记，没有一辆车会闲的无聊开来开去）
                    q[en++] = {nx,ny,nm + c + a,mx};
                }
                else
                {//还能撑
                    if(nx == l && ny == l)
                    {
                        if(nm < ans) ans = nm;
                        continue;
                    }
                    bool ok = 1;
                    for (int i = nd.power - 1;i <= mx;++i) //花钱是否最少
                        if(arr[nx][ny][i] <= nm)
                        {
                            ok = 0;break;
                        }
                    if(!ok) continue;
                    arr[nx][ny][nd.power - 1] = nm;
                    q[en++] = {nx,ny,nm,nd.power - 1};
                }
            }
        }
    }
    printf("%d",ans); 
}
```

---

## 作者：zyh2333 (赞：1)

看到题目可以看出是有关费用流的（毕竟费用的摆在明面上了）重点在于强制消费的加油问题。

也就是重点在于控制油量~~因为在油量充足的图中才是标准的最小费最大流~~.

分层图是解决控制油量问题的。我们将图分成n + 1层，源点连向第０层，满油出发，每一层的(n,n)都要连向汇点~~到了就可以了，不在乎最后还有多少油~~

有一点要注意，第1层到第k层都向第0层连上一个费A流1的边，代表加油，然后第0层再向别的点连边，因为黑心商家**强制消费！！！~~消费者权益被侵犯的一干二净~~**，借一张题解的图

![这个是费用流](https://cdn.luogu.com.cn/upload/image_hosting/172bgq7u.png)

图片来源[题解第一的博客，感激不尽，如有冒犯，立马删除](https://www.luogu.com.cn/blog/AH2002/solution-p4009)

费用流建图是这样的，蓝色代表往回走~~顺便说一句，这位大佬的代码好简短。。。没有比较就没有伤害~~

代码：

```cpp
#include <bits/stdc++.h>

using namespace std;

inline int read(){
    int num = 0, x = 1;
    char c = getchar();
    while(c < '0' || c > '9'){
        if(c == '-') x = -x;
        c = getchar();        
    }
    while(c <= '9' && c >= '0'){
        num = (num << 1) + (num << 3) + c - '0';
        c = getchar();
    }
    return num * x;
}

#define MAXM 5000100
#define MAXN 1001000
#define INF  0x3f3f3f3f

int to[MAXM], nxt[MAXM], w[MAXM];
int cost[MAXM], head[MAXN];
int n, m, S, T, cnt = -1;
int ans1 = 0, ansc = 0;
int pre1[MAXN], pre2[MAXN];
int low[MAXN], dis[MAXN];

void link(int a, int b, int c, int d){
    ++cnt; nxt[cnt] = head[a]; w[cnt] = c;
    cost[cnt] = d; to[cnt] = b; head[a] = cnt;

    ++cnt; nxt[cnt] = head[b]; w[cnt] = 0;
    cost[cnt] = -d; to[cnt] = a; head[b] = cnt;
}

bool spfa(){
    queue<int>q;
    fill(dis, dis + MAXN, INF);
    int vis[MAXN];
    memset(vis, 0, sizeof(vis));
    q.push(S);
    dis[S] = 0;
    vis[S] = 1;
    low[S] = INF;
    while(!q.empty()){
        int now = q.front();
        vis[now] = 0;
        q.pop();
        for(register int i = head[now]; i != -1; i = nxt[i]){
            if(w[i] > 0 && cost[i] + dis[now] < dis[to[i]]){
                dis[to[i]] = dis[now] + cost[i];
                low[to[i]] = min(low[now], w[i]);
                pre1[to[i]] = now;
                pre2[to[i]] = i;
                if(!vis[to[i]]){
                    vis[to[i]] = 1;
                    q.push(to[i]);
                }
            }
        }
    }
    return dis[t] != INF;
}

void work(){
    while(spfa()){
        int now = T;
        while(now != S){
            int y = pre2[now];
            w[y] -= low[T];
            w[y ^ 1] += low[T];
            now = pre1[now];
        }
        ans1 += low[T];
        ansc += low[T] * dis[T];
    }
}

int num(int a, int b){ return (a - 1) * n + b;}

int main(){
    int K, A, B, C;
    memset(head, -1, sizeof(head));
    n = read(); K = read(); A = read(); B = read(); C = read();
    S = 0; T = MAXN - 1;
    link(S, num(1, 1), 1, 0);
    for(register int i = 0; i <= K; ++i)
        link(num(m, n) + 10001 * i, T, 1, 0);
    for(register int i = 1; i <= n; ++i){
        for(register int j = 1; j <= n; ++j){
            int a;
            a = read();
            if(a)
                for(register int k = 1; k <= K; ++k)
                    link(num(i, j) + k * 10001, num(i, j), 1, A);
            for(register int k = 0; k < K; ++k){
                if(a && k) break;
                if((i + 1) <= n)
                    link(num(i, j) + k * 10001, num(i + 1, j) + (k + 1) * 10001, MAXM, 0);
                if((j + 1) <= n)
                    link(num(i, j) + k * 10001, num(i, j + 1) + (k + 1) * 10001, MAXM, 0);
                if((i - 1) > 0)
                    link(num(i, j) + k * 10001, num(i - 1, j) + (k + 1) * 10001, MAXM, B);
                if((j - 1) > 0)
                    link(num(i, j) + k * 10001, num(i, j - 1) + (k + 1) * 10001, MAXM, B);
            }
            link(num(i, j) + k * 10001, num(i ,j), 1, A + c);
        }
    }
    work();
    cout << ansc << endl;
    return 0;
}
```

最后说一句，要是有大佬可以告诉我为什么主函数里
```cpp
if(a)
                for(register int k = 1; k <= K; ++k)
                    link(num(i, j) + k * 10001, num(i, j), 1, A);
```

这个10001是个啥，感激不尽~~老师上课说的代码，还是没完全理解~~

---

## 作者：Uniecho1 (赞：1)

网络流？您配吗？不，您~不~配~！我可去你的网络流吧！

某本蓝色的书上把这道题作为了最短路的练习。当我打开这个网页，我心里一片WA凉......可是仔细一看题面和数据范围，突然觉得能用华容道的思路做？？？

等等......这个题好像预处理都不需要吧！！！！它怎么当上紫题的？？？？似乎只要对于每个位置根据当前的剩余油量分个层就可以阉了它啊！

思考五秒，想出了两个宽搜优化:

1.用f[i][j][k]记录当前位置为(i,j)，还可以走k条最短路时最少的费用。

2.因为**无论在什么位置，新增一个加油站及其加油费用都是一样的**，所以我们可以用**贪心**的策略，仅在无油时才加油(有加油站的地方你怎么都得加油所以无所谓)

好了不废话了上码
```cpp
#include<bits/stdc++.h>
using namespace std;

int G[105][105],f[105][105][12],ans=INT_MAX;
int N,K,A,B,C;
int dx[4]={-1,0,1,0};
int dy[4]={0,-1,0,1};
int cost[4];

struct node{
	int x,y,dis,sum;
};

bool check(int nx,int ny){
	return nx>=1&&nx<=N&&ny>=1&&ny<=N;
}

void BFS(){
	queue<node>q;
	q.push(node{1,1,K,0});
	while(!q.empty()){
		node u=q.front();
		q.pop();
		if(u.sum>=f[u.x][u.y][u.dis])continue;
		f[u.x][u.y][u.dis]=u.sum;
		for(int i=0;i<4;i++){
			int nx=u.x+dx[i];
			int ny=u.y+dy[i];
			if(!check(nx,ny))continue;
			if(G[u.x][u.y])q.push(node{nx,ny,K-1,u.sum+cost[i]+A});
			else if(!u.dis)q.push(node{nx,ny,K-1,u.sum+cost[i]+A+C});
			else q.push(node{nx,ny,u.dis-1,u.sum+cost[i]});
		}
	}
}

int main(){
	//freopen("in.txt","r",stdin);
	memset(f,0x7f,sizeof(f));
	scanf("%d%d%d%d%d",&N,&K,&A,&B,&C);
	cost[0]=cost[1]=B;
	for(int i=1;i<=N;i++)
	for(int j=1;j<=N;j++)
	scanf("%d",&G[i][j]);
	BFS();
	for(int i=0;i<=K;i++)
	ans=min(ans,f[N][N][i]);
	printf("%d",ans);
	return 0;
}
```


---

## 作者：香风智乃 (赞：1)

[P4009 汽车加油行驶问题](https://www.luogu.org/problemnew/show/P4009)

清一色的spfa....送上一个**堆优化Dijkstra**吧（貌似代码还挺短）

顺便说一句，堆优化Dj跑分层图灰常好写

[juruo's blog](https://www.cnblogs.com/kafuuchino/p/9685104.html)

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<queue>
using namespace std;
template <typename T> inline T min(T &a,T &b) {return a<b ?a:b;}
struct data{ //对于不同题目的要求，我们只需要在结构体中按题意增减变量即可
	int d,x,y,k; //d:费用 x,y:坐标 k:油量
	bool operator < (const data &tmp) const {return d>tmp.d;}
}; priority_queue <data> h;
int d1[4]={0,1,0,-1};
int d2[4]={1,0,-1,0};
int n,tk,a,b,c,ans=2e9,d[12][102][102],oil[102][102];
int main(){
	scanf("%d%d%d%d%d",&n,&tk,&a,&b,&c);
	for(int i=1;i<=n;++i)
		for(int j=1;j<=n;++j)
			scanf("%d",&oil[i][j]);
	memset(d,127,sizeof(d));
	h.push((data){d[tk][1][1]=0,1,1,tk}); //优先队列直接放结构体
	while(!h.empty()){
		data u=h.top(); h.pop();
		if(u.d!=d[u.k][u.x][u.y]) continue; //记忆化
		if(!u.k) u.k=tk,u.d+=a+c; //没油了就新建一个油库并加油
		for(int i=0;i<4;++i){
			int r1=u.x+d1[i],r2=u.y+d2[i],cost= i>1 ? b:0; //cost:当向左或向上是要加的费用
			if(r1<1||r1>n||r2<1||r2>n) continue;
			if(oil[r1][r2]){ //有油库必须加满
				if(u.d+cost+a<d[tk][r1][r2]){
					d[tk][r1][r2]=u.d+cost+a;
					h.push((data){d[tk][r1][r2],r1,r2,tk});
				}
			}else if(u.d+cost<d[u.k-1][r1][r2]){ //普通的行驶
				d[u.k-1][r1][r2]=u.d+cost;
				h.push((data){d[u.k-1][r1][r2],r1,r2,u.k-1});
			}
		}
	}
	for(int i=0;i<=tk;++i) ans=min(ans,d[i][n][n]); //查找最小值
	printf("%d",ans);
	return 0;
}
```

---

## 作者：白菜道士 (赞：1)

* 环顾题解区,$dalao$们都用了各种神奇的办法
* 可是这让蒟蒻们怎么看得懂呢
* $bfs$就可以搞定了
-----
详情见下
```cpp
#include <iostream>
#include <cstdlib>
#include <cstdio>
#include <cmath>
#include <queue>
#include <string>
#include <cstring>
#include <algorithm>
using namespace std;

const int Max=101;
bool mp[Max][Max];
bool H[Max][Max][11];//简易hash 
int dx[4]={0,0,1,-1};
int dy[4]={1,-1,0,0};//方向 
int N,K,A,B,C;
struct node
{
	int x,y;//坐标 
	int oil;//油量 
	int pay;//花费 
	friend bool operator <(node a,node b)
	{
		return a.pay>b.pay;
	}//优先队列 
};

int bfs()
{
	node tmp,nx;
	priority_queue<node> Q;
	Q.push((node){1,1,K,0});//初始化起点 
	while(!Q.empty())
	{
		tmp=Q.top();Q.pop();
		if(H[tmp.x][tmp.y][tmp.oil])continue;
		H[tmp.x][tmp.y][tmp.oil]=true;//hash表判重 
		if(tmp.x==N&&tmp.y==N)	return tmp.pay;//到达终点 
		for(int i=0; i<4; i++)
		{
			nx=tmp;
			nx.x=nx.x+dx[i],nx.y=nx.y+dy[i],nx.oil--;//改变坐标，减少油量 
			if(nx.oil<0||nx.x<0||nx.y<0||nx.x>N||nx.y>N)	continue;//没油或越界就退出 
			if(nx.x<tmp.x||nx.y<tmp.y)	nx.pay+=B;//往回走就付B元 
			if(mp[nx.x][nx.y])	nx.oil=K,nx.pay+=A;//到加油站就（一定要）付钱A元并加油 
			Q.push(nx);//将上种情况入队 
			if(!mp[nx.x][nx.y]&&nx.oil<K)	nx.oil=K,nx.pay+=A+C;//没加油站就造加油站,付钱A+C元并加油
			Q.push(nx);//将上种情况入队 
		}
	}
	return -1;
}

int main()
{
	memset(H,false,sizeof(H));
	memset(mp,false,sizeof(mp));
	scanf("%d%d%d%d%d",&N,&K,&A,&B,&C);
	for(int i=1; i<=N; i++)
		for(int j=1; j<=N; j++)
			cin>>mp[i][j];//输入 
	cout<<bfs()<<endl;//输出 
	return 0;
}
```


---

## 作者：key_rA9 (赞：0)

设d[i][j][k]表示到(i,j)用k升油所需的最小费用，跑SPFA的队列也有这三个变量。
初始化起点满油时费用0。
```pascal
  SPFA分三步：
  1. 强制加油新状态
  2. 自行加油新状态
  3. 模拟开车
```
然后枚举到终点时油量找答案。  
详细的请$\color{white}\colorbox{white}{不要}$  看代码:
```cpp
#include<cstdio>
#include<cstring>
#define inf 0x7fffffff
#define pd(x,y) (x&&x<=n&&y&&y<=n)//判断越界
#define mes(x,y) memset(x,y,sizeof(x))
#define min(x,y) (x<y?x:y)
using namespace std;
const int dx[4]={0,-1,0,1};//方向
const int dy[4]={-1,0,1,0};
inline int qr()//快读
{
    int x=0,f=1;char c=getchar();
    while(c<'0'||'9'<c){c=='-'?f=-1:1;c=getchar();}
    while('0'<=c&&c<='9'){x=x*10+(c&15);c=getchar();}
    return x*f;
}
struct node
{
    int x,y,c;
}q[10001];int hd,tl;//队列
int n,K,A,B,C,ans=inf;
int d[101][101][11];
bool mp[101][101],bk[101][101][11];
int main()
{
    n=qr();K=qr();A=qr();B=qr();C=qr();
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
            mp[i][j]=qr();
    mes(d,63);d[1][1][K]=0;
    bk[1][1][K]=1;
    hd=1;tl=2;q[1]=(node){1,1,K};
    while(hd!=tl)
    {
        int x=q[hd].x,y=q[hd].y,c=q[hd].c;
        bk[x][y][c]=0;
        hd++;if(hd>10000)hd=1;
        if(x==n&&y==n)continue;//到终点不可能再走
        if(mp[x][y]&&c<K)//如果有油站必须加油
        {//油满表示这个状态是上一次在这进入队列的，所以不能再加油
        	int dis=d[x][y][c]+A;//油费
        	if(d[x][y][K]>dis)
        	{
        		d[x][y][K]=dis;
        		if(!bk[x][y][K])
        		{
        			bk[x][y][K]=1;
        			q[tl++]=(node){x,y,K};
        			if(tl>10000)tl=1;
				}
			}
			continue;//因为强制加油所以当前还未加油的状态废了
		}
		else//否则再新建一个自行加油的状态
		{
			int dis=d[x][y][c]+A+C;//建站费
			if(d[x][y][K]>dis)
			{
				d[x][y][K]=dis;
				if(!bk[x][y][K])
				{
					bk[x][y][K]=1;
					q[tl++]=(node){x,y,K};
					if(tl>10000)tl=1;
				}
			}
		}
        if(c)//有油开车
        for(int t=0;t<4;t++)
        {
			int xx=x+dx[t];
			int yy=y+dy[t];
			if(!pd(xx,yy))continue;
			int dis=d[x][y][c];
			if(t<2)dis+=B;//前两个状态是往回走的需要加费
			if(d[xx][yy][c-1]>dis)//耗1 油
			{
				d[xx][yy][c-1]=dis;
				if(!bk[xx][yy][c-1])
				{
					bk[xx][yy][c-1]=1;
					q[tl++]=(node){xx,yy,c-1};
					if(tl>10000)tl=1;
				}
			}
        }
    }
    for(int i=0;i<=K;i++)ans=min(ans,d[n][n][i]);
    printf("%d\n",ans);
    return 0;
}
```
代码里面有些语句忘记删掉注释了，貌似~~不~~是不小心弄得。~~（请珍惜颜色）~~

---


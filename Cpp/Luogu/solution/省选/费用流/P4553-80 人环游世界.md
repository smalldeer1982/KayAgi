# 80 人环游世界

## 题目描述

想必大家都看过成龙大哥的《80 天环游世界》，里面的紧张刺激的打斗场面一定给你留下了深刻的印象。现在就有这么一个 80 人的团伙，也想来一次环游世界。

他们打算兵分多路，游遍每一个国家。

因为他们主要分布在东方，所以他们只朝西方进军。设从东方到西方的每一个国家的编号依次为 $1, \cdots, N$。假若第 $i$ 个人的游历路线为 $P_1,P_2,\cdots ,P_k\ (0\le k\le N)$，则 $P_1<P_2<\cdots <P_k$。

众所周知，中国相当美丽，这样在环游世界时就有很多人经过中国。我们用一个正整数 $V_i$ 来描述一个国家的吸引程度，$V_i$ 值越大表示该国家越有吸引力，同时也表示有且仅有 $V_i$ 个人会经过那一个国家。

为了节省时间，他们打算通过坐飞机来完成环游世界的任务。同时为了省钱，他们希望总的机票费最小。
  
明天就要出发了，可是有些人临阵脱逃，最终只剩下了 $M$ 个人去环游世界。他们想知道最少的总费用，你能告诉他们吗？ 

## 说明/提示

在 $10\%$ 的数据中，$M=1$；  
在 $20\%$ 的数据中，$1\le M\le 2$；  
在 $40\%$ 的数据中，$1\le M\le 3$；  
在 $60\%$ 的数据中，$1\le M\le 4$；  
在 $100\%$ 的数据中，$1 \le N\le 100$，$1\le M\le 79$。

保证所以输入数据中最少费用小于 $10^6$。  
保证至少存在一种可行方案。

纪中联赛模拟题  
BY CQF  

## 样例 #1

### 输入

```
6 3
2 1 3 1 2 1
2 6 8 5 0
8 2 4 1
6 1 0
4 -1
4```

### 输出

```
27```

# 题解

## 作者：Morpheuse (赞：22)

并不需要上下界网络流.

## 题意

用 $m$ 条可相交的路径覆盖每个点 $v_i$ 次.

## 做法

对于每个点 $i$ 有且仅有 $v_i$ 次进入，也有 $v_i$ 次离开.

$s$ 为源点， $t$ 为汇点.

以下除特殊说明，费用均为 $0$.

$s\to i$ 流量为 $v_i$ 表示一定有 $v_i$ 次离开.

$i + n \to t$ 流量为 $v_i$ 表示必须要有 $v_i$ 次进入.

因为 $m$ 个人都可以从任意点开始.

相当于我们有 $m$ 次无需费用即可进入的权限.

所以我们新建一个点 $M$.

$s\to M$ 流量为 $m$ 表示有 $m$ 次无需费用进入的权限.

对于每个 $i , M\to i + n$ 流量为 $inf$ 表示可以从无需费用进入 $i$.

对于每条边 $(u,v,w)$ 建边 $u\to v + n$ 流量为 $inf$ , 费用为 $w_i$.

最小费用最大流即可.

## 代码

```cpp
scanf("%d%d", &n,&m);
for(int i = 1 ; i <= n ; ++ i) scanf("%d", &a[i]);
s = 0 , t = maxn - 10;

/*
源点.
数组大小.
初始化. 
*/
int ss = maxn - 11;
add(s , ss , m , 0);
for(int i = 1 ; i <= n ; ++ i)
	add(ss , i + n , inf , 0);
for(int i = 1 ; i <= n ; ++ i)
	add(s , i , a[i] , 0);
for(int i = 1 ; i <= n ; ++ i)
	add(i + n , t , a[i] , 0);
for(int i = 1 ; i <= n - 1 ; ++ i)
{
	for(int j = 1 ; j <= n - i ; ++ j)
	{
		int x;
		scanf("%d", &x);
		if(x == -1) x = inf;
		add(i , i + j + n , inf , x);
	}
}
printf("%d", cot);
```

---

## 作者：Su_Zipei (赞：14)

## 最小费用最大流

并不需要上下界网络流。

这题个人感觉和餐巾计划问题有点类似的情况，餐巾计划是每天结束之后提供脏餐巾，这个是走完一个点之后给后边提供人。

所以可以类似的建图。

首先每个点向汇点建边，流量为 $v_i$ 费用为 $0$ ，保证每个点恰好有 $v_i$ 个人经过。

然后对于每个点，新开一个节点表示提供了 $v_i$ 个人，原点向其连流量为 $v_i$ 费用为 $0$ 的边，这个点再依次向它之后的各个点连流量为无穷费用为路费的边。

这样图还是不全，因为开始的 $m$ 个人没有限制，所以再新开一个点，原点向其连流量为 $m$ 费用为 $0$ 的边，这个点向各点连流量为无穷费用为 $0$ 的边。

考虑这样做为什么是对的，会不会 $m$ 个人没有走完的情况，就是 $m$ 个人有的人没有出发，答案是不会，那条边的费用为 $0$ 所以会优先走。

```cpp
#include<deque>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int N=1e3+10;
const int INF=0x3f3f3f3f;
#define rg register
struct Edge{
	int to,nxt,val,cost;
}e[N*N];
int h[N],idx=1;
inline void Ins(int a,int b,int c,int d){
	e[++idx].to=b;e[idx].nxt=h[a];h[a]=idx;
	e[idx].val=c;e[idx].cost=d;
}
int st,ed,cnt,v[N],dis[N],pre[N];
bool inq[N];
deque<int> q;
bool spfa(){
	memset(dis,0x3f,sizeof(dis));
	memset(inq,0,sizeof(inq));
	dis[st]=0;
	q.push_back(st);
	while(!q.empty()){
		rg int u=q.front();q.pop_front();inq[u]=0;
		for(rg int i=h[u];i;i=e[i].nxt){
			rg int v=e[i].to;
			if(e[i].val&&dis[v]>dis[u]+e[i].cost){
				dis[v]=dis[u]+e[i].cost;
				pre[v]=i;
				if(!inq[v]){
					if(q.empty()||dis[v]<=dis[q.front()])q.push_front(v);
					else q.push_back(v);
					inq[v]=1;
				}
			}
		}
	}
	return dis[ed]!=INF;
}
int main(){
	int n,m;
	scanf("%d%d",&n,&m);
	cnt=n;
	st=++cnt;ed=++cnt;
	++cnt;
	Ins(st,cnt,m,0);
	Ins(cnt,st,0,0);
	for(rg int i=1;i<=n;i++){
		scanf("%d",&v[i]);
		Ins(cnt,i,INF,0);
		Ins(i,cnt,0,0);
		Ins(i,ed,v[i],0);
		Ins(ed,i,0,0);
	}
	for(rg int i=1;i<=n;i++){
		++cnt;
		Ins(st,cnt,v[i],0);
		Ins(cnt,st,0,0);
		for(rg int j=i+1;j<=n;j++){
			int w;
			scanf("%d",&w);
			if(w==-1)continue;
			Ins(cnt,j,INF,w);
			Ins(j,cnt,0,-w);
		}
	}
	int res=0;
	while(spfa()){
		int Min=1e9;
		for(rg int now=ed;now!=st;now=e[pre[now]^1].to)
			Min=min(Min,e[pre[now]].val);
		for(rg int now=ed;now!=st;now=e[pre[now]^1].to){
			e[pre[now]].val-=Min;
			e[pre[now]^1].val+=Min;
		}
		res+=Min*dis[ed];
	}
	printf("%d\n",res);
	return 0;
}


```


---

## 作者：disangan233 (赞：9)

讲一种我考膜你赛的时候的做法，不用建上下界，直接用最小费用最大流做出来了。

### 具体做法

将每一个点拆点，将两个点之间连一条容量 $v_i$，费用为 $-\infty$ 的边： 

```cpp
add(i,i+n,v[i],-inf);
```  

再沿边建边+连源点汇点：  

```cpp
s=0,t=n+n+1;
for(int i=1;i<=n;i++) add(s,i,m,0),add(i+n,t,inf,0);
for(int i=1;i<n;i++) for(int j=2;j<=n;j++)
{
	int x=read();
	if(x==-1) continue;
	add(i+n,j,-inf,x);sum+=x;
}
```
最后限制流量

```cpp
add(S,s,m,0);add(t,T,m,0);
while(spfa()) solve();
```  

答案即为去除 $-\infty$ 后的答案：$ans+sum\times \infty$  


### 实现原理

利用最小费用最大流的性质，使拆点间的 $-\infty$ 边保证满流，即可满足题目中有且仅有 $V_i$ 个人的性质。

飞机航线的费用不取反，同时满足了最小费用的性质。

这种建图方式在 $n\leq m $ 时会出错，把容量改成 $\min(n,m)$ 就行了。  


### Code

```
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define re register int
#define ak *
#define inf 1e10
#define loc(i,j) ((i-1)*m+j)
int v[215],cnt=1,n,m,s,t,ns,nt,st,ed,h[215],dis[215],l,r,q[215],vis[215],pre[215],ans,maxflow,sum;
struct did{
	int u,next,to,f,w;
}e[160005],e1[160005];
char qwq;
inline int read()
{
	int yz=0,ioi=1;qwq=getchar();
	while(qwq<'0'||qwq>'9') ioi=qwq=='-'?~ioi+1:1,qwq=getchar();
	while(qwq>='0'&&qwq<='9') yz=(yz<<3)+(yz<<1)+(qwq^48),qwq=getchar();
	return yz ak ioi;
}
inline void add(re a,re b,re c,re d)
{
	e[++cnt]=(did){a,h[a],b,c,d},h[a]=cnt;
	e[++cnt]=(did){b,h[b],a,0,-d},h[b]=cnt;
}
inline int spfa()
{
	memset(pre,0,sizeof(pre));memset(vis,0,sizeof(vis));
	for(re i=0;i<=t;i++) dis[i]=i==s?0:inf;
	queue<int>q;q.push(s);vis[s]=1;
	while(!q.empty())
	{
		re i=q.front();vis[i]=0;q.pop();
		for(re j=h[i],k;k=e[j].to,j;j=e[j].next)
		if(e[j].f&&dis[k]>dis[i]+e[j].w)
		{
			dis[k]=dis[i]+e[j].w;pre[k]=j;
			if(!vis[k]) q.push(k),vis[k]=1;
		}
	}	
	return dis[t]<inf;
}
inline void solve()
{
	re delta=inf;
	for(re i=t,p;p=pre[i],i!=s;i=e[p^1].to)
	delta=min(delta,e[p].f);
	for(re i=t,p;p=pre[i],i!=s;i=e[p^1].to)
	e[p].f-=delta,e[p^1].f+=delta;
	maxflow+=delta;ans+=delta*dis[t];
}
signed main()
{
	freopen("tour.in","r",stdin);
	freopen("tour.out","w",stdout);
	n=read(),m=read();st=0,ed=n+n+1;s=ed+1;t=ed;
	add(s,st,min(n,m),0);
	for(re i=1;i<=n;i++) add(st,i,min(n,m),0),add(i+n,t,inf,0);
	for(re i=1;i<=n;i++) add(i,i+n,v[i]=read(),-inf),sum+=v[i];
	for(re i=1;i<n;i++)
	for(re j=i+1;j<=n;j++)
	{
		re x=read();
		if(x==-1) continue;
		add(i+n,j,inf,x);  
	}
	while(spfa()) solve();
	cout<<(int)(ans+sum*inf)<<endl;
}
```

---

## 作者：Great_Influence (赞：8)

简单上下界最小费用流。

模型很简单，将每个点拆成$a_i$和$a_i'$，然后进行以下连边:

$s$向$a_i$连边，权值为$0$,下界为$0$,上界为$m$。

$a_i$向$a_i'$连边，权值为$0$,下界为$v_i$,上界为$v_i$。

若存在$i$向$j$的连边，则$a_i'$向$a_j$连边,权值为$w_{i,j}$,下界为$0$,上界为$m$。

$a_i'$向$t$连边,权值为$0$,下界为$0$,上界为$m$。

$t$向$t'$连边,权值为$0$,下界为$0$,上界$m$。

那么答案就是$s$向$t'$的最小费用最大流。因为涉及到上下界问题,所以开超级源和超级汇补流,答案变为超级源和超级汇之间地最大流。时间复杂度$O(maxflow(n,n+m))$。

代码:

```cpp
#include<bits/stdc++.h>
#include<ext/pb_ds/assoc_container.hpp>
#define Rep(i,a,b) for(register int i=(a),i##end=(b);i<=i##end;++i)
#define Repe(i,a,b) for(register int i=(a),i##end=(b);i>=i##end;--i)
#define For(i,a,b) for(i=(a),i<=(b);++i)
#define Forward(i,a,b) for(i=(a),i>=(b);--i)
#define Chkmin(a,b) a=a<b?a:b
#define Chkmax(a,b) a=a>b?a:b
#define pb push_back

template<typename T>inline void read(T &x){
    T s=0,f=1;char k=getchar();
    while(!isdigit(k)&&k^'-')k=getchar();
    if(!isdigit(k)){f=-1;k=getchar();}
    while(isdigit(k)){s=s*10+(k^48);k=getchar();}
    x=s*f;
}

inline void write(int a,char ed='\n')
{
	static short s[13],tp;
	if(!a){putchar('0'),putchar(ed);return;}
	for(tp=0;a;a/=10)s[++tp]=a%10;
	for(;tp;putchar(s[tp--]^48));
	putchar(ed);
}
using namespace std;

const int MAXN=411+7;

static int n,m,e=1,head[MAXN];

static struct edge
{
	int v,nxt,w,f;
}p[MAXN*MAXN];

inline void add(int u,int v,int w,int f,int laz=1)
{
	p[++e]=(edge){v,head[u],w,f};head[u]=e;
	if(laz)add(v,u,-w,0,0);
}

static int s,t,ss,tt,kt;

const int inf=0x3f3f3f3f;

inline void init()
{
	read(n);read(m);s=2*n+1;t=s+1;kt=t+1,ss=kt+1;tt=ss+1;
	static int x;
	Rep(i,1,n)read(x),add(ss,i+n,0,x)
		,add(i,tt,0,x),add(s,i,0,m),add(i+n,t,0,m);
	add(t,kt,0,m);
	add(kt,s,0,inf);
	Rep(i,1,n)Rep(j,i+1,n)
	{
		read(x);
		if(~x)add(n+i,j,x,inf);
	}
}

static int cost;

static deque<int>G;

static int dis[MAXN],vis[MAXN],cur[MAXN];

inline bool spfa(int s,int t)
{
	memset(dis,0x3f,sizeof dis);
	dis[s]=0;G.push_back(s);
	static int u;
	while(!G.empty())
	{
		u=G.front();G.pop_front();vis[u]=false;
		for(register int v=head[u];v;v=p[v].nxt)
			if(p[v].f&&dis[p[v].v]>dis[u]+p[v].w)
			{
				dis[p[v].v]=dis[u]+p[v].w;
				if(!vis[p[v].v])
				{
					vis[p[v].v]=true;
					if(G.empty()||dis[p[v].v]<dis[G.front()])
						G.push_front(p[v].v);
					else G.push_back(p[v].v);
				}
			}
	}
	return dis[t]^dis[0];
}

int dfs(int u,int t,int flow=inf)
{
	if(u==t||!flow)return flow;
	vis[u]=true;
	int sum=0,f;
	for(register int&v=cur[u];flow&&v;v=p[v].nxt)
		if(!vis[p[v].v]&&p[v].f&&dis[p[v].v]==dis[u]+p[v].w)
		{
			f=dfs(p[v].v,t,min(flow,p[v].f));
			p[v].f-=f;p[v^1].f+=f;sum+=f;flow-=f;
			cost+=p[v].w*f;
		}
	vis[u]=false;
	return sum;
}

inline void Dinic(int s,int t)
{while(spfa(s,t))memcpy(cur,head,sizeof head),dfs(s,t);}

inline void solve()
{
	Dinic(ss,tt);
	printf("%d\n",cost);
}

inline void file()
{
	#ifndef ONLINE_JUDGE
	freopen("water.in","r",stdin);
	freopen("water.out","w",stdout);
	#endif
}

int main()
{
	file();
	init();
	solve();
	cerr<<1.0*clock()/CLOCKS_PER_SEC<<endl;
	return 0;
}
```

---

## 作者：javalyc (赞：6)

#### [博客传送门qwq](https://www.cnblogs.com/LLTYYC/p/10805569.html)

### 大家都写上下界网络流？不是最小覆盖的魔改版吗？
之前写了道星际竞速，这题一看就是星际竞速改版..

考虑构建费用流模型

把每个点拆成两个点 $u,v$

$u$ 表示入点，$v$ 表示出点

连边 $(u,T,a[i],0)$ （$a[i]$ 表示点 $i$ 需要的经过次数），表示节点 $i$ 要进入 $a[i]$ 次

因为每个点都一定恰好进入 $a[i]$ 次，所以也一定有 $a[i]$ 个人从 $i$ 出发
，连边$(S,v,a[i],0)$ 表示一定有 $a[i]$ 个人有从点 $i$ 出发到其他点

对于有边相连的两点 $(x,y)$，连边 $(v[x],u[y],INF,cst)$ 表示一个人从 $x$
发到达点 $y$ 需要 $cst$ 代价

因为人数有限制，所以新建一个点 $SS$ ，连边 $(S,SS,K,0)$，表示只有 $K$ 个人

因为每个人可以任选位置作为起点，所以连边 $(SS,u[i],a[i],0)$

这样最小费用最大流就是答案了

因为只要跑一次费用流所以跑得还挺快...

会构图了代码就不用讲了吧...

```cpp
// luogu-judger-enable-o2
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cmath>
#include<queue>
using namespace std;
typedef long long ll;
inline int read()
{
    int x=0,f=1; char ch=getchar();
    while(ch<'0'||ch>'9') { if(ch=='-') f=-1; ch=getchar(); }
    while(ch>='0'&&ch<='9') { x=(x<<1)+(x<<3)+(ch^48); ch=getchar(); }
    return x*f;
}
const int N=1e5+7,M=1e7+7,INF=1e9+7;
int fir[N],from[M],to[M],val[M],cst[M],cntt=1;
inline void add(int a,int b,int c,int d)
{
    from[++cntt]=fir[a]; fir[a]=cntt;
    to[cntt]=b; val[cntt]=c; cst[cntt]=d;
    from[++cntt]=fir[b]; fir[b]=cntt;
    to[cntt]=a; val[cntt]=0; cst[cntt]=-d;
}
int dis[N],mif[N],pre[N],S,T;
queue <int> q;
bool inq[N];
bool SPFA()
{
    for(int i=S;i<=T;i++) dis[i]=INF;
    q.push(S); inq[S]=1; dis[S]=0,mif[S]=INF;
    while(!q.empty())
    {
        int x=q.front(); q.pop(); inq[x]=0;
        for(int i=fir[x];i;i=from[i])
        {
            int &v=to[i]; if(!val[i]||dis[v]<=dis[x]+cst[i]) continue;
            dis[v]=dis[x]+cst[i]; pre[v]=i;
            mif[v]=min(mif[x],val[i]);
            if(!inq[v]) q.push(v),inq[v]=1;
        }
    }
    return dis[T]<INF;
}
ll ans;
void upd()
{
    for(int now=T,i=pre[T]; now!=S; now=to[i^1],i=pre[now])
        val[i]-=mif[T],val[i^1]+=mif[T];
    ans+=1ll*mif[T]*dis[T];
}

int n,m,SS;
int main()
{
    n=read(),m=read(); int a;
    S=0,SS=(n<<1)+1,T=SS+1;
    add(S,SS,m,0);
    //代码中1~n为v，n+1~n+n为u
    for(int i=1;i<=n;i++)
    {
        a=read();
        add(SS,n+i,a,0); add(n+i,T,a,0);
        add(S,i,a,0);
    }
    for(int i=1;i<n;i++)
        for(int j=i+1;j<=n;j++)
        {
            a=read();
            if(a!=-1) add(i,n+j,INF,a);
        }
    while(SPFA()) upd();
    printf("%lld",ans);
    return 0;
}
```


---

## 作者：CAICAIA (赞：4)

一眼丁真，鉴定为费用流。

## 思路

类似于路径覆盖问题。

考虑把每个点拆成 **入点 $x$** 和 **出点 $y$**。

对于每个点的 **入点 $x$** 都向这个点的 **出点 $y$** 连一条 容量为$V_i$，费用为$0$ 的边来控制每个点会被访问 $V_i$ 次。

然后建一个 **中间点 $p$**，连一条 $s\Rightarrow p$ 容量为 $m$，费用为 $0$ 的边来控制总人数为 $m$ 人。

从 $p$ 向每个点的 **入点 $x$** 连一条容量为 $inf$，费用为 $0$ 的边。

从每个点的 **出点 $y$** 向 **汇点 $t$** 连一条容量为 $inf$，费用为 $0$ 的边。

对于每一条边 $(u,v,c)$，建一条 $u_y\Rightarrow v_x$ 容量为 $inf$，费用为 $c$ 的边。

跑一边最小费用最大流。

**然后你就会发现你 $Wa$ 的很惨。**

为什么呢？

把剩余容量输出出来会发现：有些点没有被经过 $V_i$ 次，也就是每个点的 **入点 $x$** 向 **出点 $y$** 连的边有剩余容量。

这是与题目描述不符的，思考我们建边的过程，发现我们只控制了**入点 $x$** 向**出点 $y$** 的上界，但其实这条边的**上下界**都应该为 $V_i$。

考虑上下界网络流。

但我们不会啊 ~~相信咱们都是懒得写啊~~。

所以现在得想办法让所有 **入点 $x$** 向 **出点 $y$** 连的边都为*满流*。

想到我们用的是最小费用最大流，我们可以让这些边的花费都为 $-inf$，这样就能保证这些边一定为满流了。

我们定义最小费用为 $ans$。

最后的答案为：$ans+ \sum\limits_{i = 1}^{n} V_i \times inf$ 。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MX_N=5010,MX_M=50100,INF=0x3f3f3f3f,inf=1e6+10;//注意INF一定要大于inf，要不会死循环。
struct node{
    int next,to;
    int w,c;
}edge[MX_M<<1];
int head[MX_N]={0},edge_cnt=0;
inline void Add(int x,int y,int w,int c){
    node &i=edge[edge_cnt];
    i.w=w,i.c=c,i.to=y,i.next=head[x];
    head[x]=edge_cnt++;
}
inline void add(int x,int y,int w,int c){
    Add(x,y,w,c),Add(y,x,0,-c);
}
int dist[MX_N]={0},lim[MX_N]={0},pre[MX_N];
bool vis[MX_N]={0};
int s=0,t=MX_N-1;
bool spfa(){
    memset(dist,INF,sizeof(dist));memset(lim,0,sizeof(lim));memset(vis,0,sizeof(vis));
    queue<int >qu;qu.push(s);
    vis[s]=1,lim[s]=INF,dist[s]=0;
    while(!qu.empty()){
        int now=qu.front();qu.pop();vis[now]=0;
        for(int i=head[now];~i;i=edge[i].next){
            int to=edge[i].to,w=edge[i].w,c=edge[i].c;
            if(dist[to]>dist[now]+c&&w){
                dist[to]=dist[now]+c;
                pre[to]=i;
                lim[to]=min(lim[now],w);
                if(!vis[to]){
                    qu.push(to);
                    vis[to]=1;
                }
            }
        }
    }
    return lim[t]>0;
}
void EK(int &flow,int &cost){
    flow=cost=0;
    while(spfa()){
        flow+=lim[t];
        cost+=lim[t]*dist[t];
        for(int i=t;i!=s;i=edge[pre[i]^1].to){
            edge[pre[i]].w-=lim[t];
            edge[pre[i]^1].w+=lim[t];
        }
    }
}
signed main(){
    memset(head,-1,sizeof(head));
    //=======================================
    int n,m;scanf("%d%d",&n,&m);
    int p=t-2,sum=0;add(s,p,m,0);    //建立中间点p
    for(int i=1;i<=n;i++){
        int xi;scanf("%d",&xi);sum+=xi;
        add(i,i+n,xi,-inf);            //保证这一条边一定为满流
        add(p,i,INF,0);add(i+n,t,INF,0);
    }
    for(int i=1;i<n;i++){
        for(int j=1;j<=n-i;j++){
            int xi;scanf("%d",&xi);int to=i+j;
            if(xi==-1)  continue;
            add(i+n,to,INF,xi);
        }
    }
    int cost,flow;EK(flow,cost);
    printf("%d",cost+sum*inf);     //最后答案得去除-inf的影响
    //=======================================
    return 0;
}
```

---

## 作者：wangif424 (赞：3)

首先这道题要求环游世界的最小花费，不难想到使用费用流维护。

关于上下界流和普通费用流，其所建的最终的图实际上是大同小异的。~~可以说普通费用流推出来的人是自己发明了上下界流~~。

## 建图

- 典中典之起手割点，首先把每个国家当成两个点，两个点之间连边，流量为 $[V_i,V_i]$。

- 从起点往每个点连边，从每个点向终点连边，流量为 $[0,m]$，即每个人最多经过每条边一次。

- 对于每条飞机路线，连边，流量为 $[0,m]$，费用为 $c_{i,j}$，意义同上。

## 上下界最大流

[见模板](https://www.luogu.com.cn/problem/P5192)

## 上下界最小费用最大流

把上下界最大流中的搜索找增广路换成 `SPFA` 找增广路即可。

## AC 代码

```cpp
#include <bits/stdc++.h>
#define R(x) x = read()
#define ENDL push('\n');
#define SPACE push(' ');
#define int long long
using namespace std;
char pbuf[1<<20], *pp=pbuf;
inline void push(const char &c) {
	if(pp - pbuf == 1<<20)fwrite(pbuf, 1, 1<<20, stdout),pp = pbuf;
	*pp++ = c;
}
class io {public:~io() {fwrite(pbuf, 1, pp - pbuf, stdout);}} _;
inline void write(int x) {
	if (x<0)x=-x,push('-');
	int sta[35],top=0;
	do {
		sta[top++]=x%10,x/=10;
	} while (x);
	while(top)push(sta[--top]^'0');
}
#ifndef LOCAL
	char buf[1<<23],*p1=buf,*p2=buf;
	#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
#endif
inline int read() {
    int x=0,f=1;char ch=getchar();
    while(!isdigit(ch)){if(ch=='-') f=-1;ch=getchar();}
    while(isdigit(ch)) x=x*10+(ch^48),ch=getchar();
    return x*f;
}
int n,m;
struct edge{
	int to,nxt,flow,cost;
}v[40010];
int len=1,fir[1010];
void add(int x,int y,int f,int c){
	++len;
	v[len].to=y;
	v[len].nxt=fir[x];
	v[len].flow=f;
	v[len].cost=c;
	fir[x]=len;
	return;
}
const int inf=1e17;
int s,t;
int s2,t2;
int d[1010];
int flow[1010],dis[1010],vis[1010],lst[1010];
bool spfa(){
//	cout << endl;
	queue<int> q;
	q.push(s2);
	memset(dis,0x3f3f3f3f,sizeof(dis));
	memset(flow,0x3f3f3f3f,sizeof(flow));
	memset(vis,0,sizeof(vis));
	memset(lst,-1,sizeof(lst));
	dis[s2]=0;
	while(!q.empty()){
		int u=q.front();
		q.pop();
		vis[u]=0;
//		cout << fir[u] << endl;
		for(int i=fir[u];i;i=v[i].nxt){
//			cout << ":" << u << "->" << v[i].to << " "<< v[i].flow << "dd:\n";
			if(v[i].flow>0&&dis[v[i].to]>dis[u]+v[i].cost){
				dis[v[i].to]=dis[u]+v[i].cost;
				flow[v[i].to]=min(flow[u],v[i].flow);
//				cout << ":" << u << "->" << v[i].to << " " << flow[v[i].to] << ":\n";
				lst[v[i].to]=i;
				if(!vis[v[i].to]){
					vis[v[i].to]=1;
					q.push(v[i].to);
				}
			}
		}
	}
	return lst[t2]^(-1);
}
int ans;
void ek(){
	while(spfa()){
		ans+=dis[t2]*flow[t2];
		int u=t2;
		while(u^s2){
			v[lst[u]].flow-=flow[t2];
			v[lst[u]^1].flow+=flow[t2];
			u=v[lst[u]^1].to;
		}
	}
}
signed main(){
	R(n);R(m);
	s=n+n+1;
	t=s+1;
	s2=t+1;
	t2=s2+1;
	for(int i=1,vi;i<=n;i++){
		R(vi);
		add(s,i,m,0);
		add(i,s,0,0);
		add(i+n,t,m,0);
		add(t,i+n,0,0);
		add(i,i+n,0,0);
		add(i+n,i,0,0);
		d[i]+=vi;
		d[i+n]-=vi;
	}
	for(int i=1;i<=n;i++){
		for(int j=i+1;j<=n;j++){
			R(int c);
			if(c==-1)continue;
			add(i+n,j,m,c);
			add(j,i+n,0,-c);
		}
	}
	add(t,s,m,0);
	add(s,t,0,0);
	for(int i=1;i<=t;i++){
//		cout << d[i] << " ";
		if(d[i]<0){
			add(s2,i,-d[i],0);
			add(i,s2,0,0);
		}
		else if(d[i]>0){
			add(i,t2,d[i],0);
			add(t2,i,0,0);
		}
	}
	ek();
	write(ans);
    return 0;
}
```

---

## 作者：xht (赞：3)

题目地址：[P4553 80人环游世界](https://www.luogu.org/problemnew/show/P4553)

### 上下界网络流

#### 无源汇上下界可行流

> 给定 $n$ 个点， $m$ 条边的网络，求一个可行解，使得边 $(u,v)$ 的流量介于 $[B(u,v),C(u,v)]$ 之间，并且整个网络满足流量守恒。

如果把 $C-B$ 作为容量上界， $0$ 作为容量下界，就是一般的网络流模型。

然而求出的实际流量为 $f(u,v)+B(u,v)$ ，不一定满足流量守恒，需要调整。

设 $inB[u]=\sum B(i,u)$ ， $outB[u]=\sum B(u,i)$ ， $d[u]=inB[u]-outB[u]$ 。

新建源汇， $S$ 向 $d>0$ 的点连边， $d<0$ 的点向 $T$ 连边，容量为相应的 $d$ 。

在该网络上求最大流，则每条边的流量 $+$ 下界就是原网络的一个可行流。

具体实现时，可省略 $inB,outB$ 数组，直接在 $d$ 数组上修改。

#### 有源汇上下界可行流

从 $T$ 到 $S$ 连一条下界为 $0$ ，上界为 $+inf$ 的边，把汇流入的流量转移给源流出的流量，转化为无源汇的网络，然后求解**无源汇上下界可行流**。

#### 有源汇上下界最小费用可行流

类似**有源汇上下界可行流**，求最大流改为求最小费用最大流。

每个国家拆成两个点（入点 $i$ 和出点 $i+n$），建立源 $s$ 汇 $t$ 附加源 $s\_$ 。

连边：

1. $(s,s\_,m,m,0)$ ；
2. $(s\_,i,0,m,0)$ ；
3. $(i+n,t,0,m,0)$ ；
4. $(i,i+n,V[i],V[i],0)$ ；
5. 若 $i,j$ 两个国家通航，连边 $(i+n,j,0,m,Cost_{i,j})$ 。

对网络 $s-t$ 求**有源汇上下界最小费用可行流**。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 206, M = 1e5 + 6, inf = 0x3f3f3f3f;
int n, m, S, T, s, s_, t, d[N], now[N], pre[N], ans;
int Head[N], Edge[M], Leng[M], Cost[M], Next[M], tot = 1;
bitset<N> v;

inline void add(int x, int y, int z, int w) {
	Edge[++tot] = y;
	Leng[tot] = z;
	Cost[tot] = w;
	Next[tot] = Head[x];
	Head[x] = tot;
	Edge[++tot] = x;
	Leng[tot] = 0;
	Cost[tot] = -w;
	Next[tot] = Head[y];
	Head[y] = tot;
}

inline void ins(int x, int y, int l, int r, int w) {
	add(x, y, r - l, w);
	d[x] -= l;
	d[y] += l;
}

inline bool spfa() {
	v.reset();
	memset(d, 0x3f, sizeof(d));
	queue<int> q;
	q.push(S);
	v[S] = 1;
	d[S] = 0;
	now[S] = m;
	while (q.size()) {
		int x = q.front();
		q.pop();
		v[x] = 0;
		for (int i = Head[x]; i; i = Next[i]) {
			int y = Edge[i], z = Leng[i], w = Cost[i];
			if (!z || d[y] <= d[x] + w) continue;
			d[y] = d[x] + w;
			now[y] = min(now[x], z);
			pre[y] = i;
			if (!v[y]) {
				q.push(y);
				v[y] = 1;
			}
		}
	}
	return d[T] != inf;
}

inline void upd() {
	ans += d[T] * now[T];
	int x = T;
	while (x != S) {
		int i = pre[x];
		Leng[i] -= now[T];
		Leng[i^1] += now[T];
		x = Edge[i^1];
	}
}

int main() {
	cin >> n >> m;
	s = n * 2 + 1, s_ = s + 1, t = s_ + 1;
	S = t + 1, T = S + 1;
	ins(s, s_, m, m, 0);
	for (int i = 1; i <= n; i++) {
		ins(s_, i, 0, m, 0);
		ins(i + n, t, 0, m, 0);
		int x;
		scanf("%d", &x);
		ins(i, i + n, x, x, 0);
	}
	for (int i = 1; i <= n; i++)
		for (int j = i + 1; j <= n; j++) {
			int x;
			scanf("%d", &x);
			if (~x) ins(i + n, j, 0, m, x);
		}
//	ins(t, s, 0, m, 0);
	for (int i = 1; i <= t; i++) {
		if (d[i] > 0) add(S, i, d[i], 0);
		else if (d[i] < 0) add(i, T, -d[i], 0);
	}
	while (spfa()) upd();
	cout << ans << endl;
	return 0;
}
```

**注意：代码中注释的那一条语句加不加都可以AC，具体原因有待研究（[讨论](https://www.luogu.org/discuss/show/104176)）**

---

## 作者：lenlen (赞：2)

最小费用最大流。

### Problem

题目大意：选择 $m$ 条路径，满足第 $i$ 点经过 $v_i$ 次，最小化路径和，保证有解。

数据范围：$n \leq 100,m \leq 79$。

### Solution

先讲连边过程，再讲为什么这样连。

对于每一个点 $i$，源点向 $i$ 连容量为 $v_i$ 的边，$i+n$ 向汇点连一条容量为 $v_i$ 的边，同时新建一个点 $M$，源点向 $M$ 连一条容量为 $m$ 的边，$M$ 向每一个 $i+n$ 连一条容量为 $\infty$ 的边。对于原图中的一条边 $u,v$，$u$ 向 $v+n$ 连一条容量为 $\infty$，权值为 $w$ 的边。

我们可以发现，每一个点被经过 $v_i$ 次，代表了这个点必须被进入 $v_i$ 次，对于 $i+n$ 向汇点连容量为 $v_i$ 的边代表了必须被进入 $v_i$ 次。而源点向 $i$ 连的边，代表了一个点最多出去 $v_i$ 次，而 $M$ 点，也就是作为起始点的最多 $m$ 个，所以容量为 $m$，向每一个 $i+n$ 连容量为 $\infty$ 的边。

同时我们可以发现，因为经过 $M$ 的流费用是 $0$，而从起点经过 $i$ 的费用是一个非负整数，所以可以保证最小费用时必然会先选择 $M$ 点，也就是 $m$ 个人都会出发，所以正确。

跑一遍最小费用最大流就可以了。

### Code

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+7232,inf=1e9+7;
int n,m;
int x,y,z,dis[N];
struct hl{
	int v,nxt,c,w;
}e[N];
int h[N],cnt=1;
void add(int u,int v,int c,int w)
{
	e[++cnt].v=v;e[cnt].nxt=h[u];h[u]=cnt;e[cnt].c=c;e[cnt].w=w;
	e[++cnt].v=u;e[cnt].nxt=h[v];h[v]=cnt;e[cnt].c=0;e[cnt].w=-w;
}
int ans,st,ed,M;
int cur[N];
bitset<N> vis;
queue<int> q;
int mi(int x,int y){return x<y?x:y;}
bool spfa()
{
	for(int i=1;i<=M;i++) dis[i]=inf;
	q.push(st);vis.reset();
	while(!q.empty())
	{
		int tmp=q.front();q.pop();
		vis[tmp]=0;cur[tmp]=h[tmp];
		for(int i=h[tmp];i;i=e[i].nxt)
		{
			if(e[i].c&&dis[e[i].v]>dis[tmp]+e[i].w) 
			{
				dis[e[i].v]=dis[tmp]+e[i].w;
				if(!vis[e[i].v]) q.push(e[i].v),vis[e[i].v]=1;
			}
		}
	}
	if(dis[ed]!=inf) return true;
	return false;
}
int dfs(int x,int dist)
{
	if(x==ed) return dist;
	vis[x]=1;
	for(int &i=cur[x];i;i=e[i].nxt)
	{
		if(e[i].c&&dis[e[i].v]==dis[x]+e[i].w&&!vis[e[i].v])
		{
			int d=dfs(e[i].v,mi(dist,e[i].c));
			if(d)
			{
				e[i].c-=d;
				e[i^1].c+=d;
				ans+=d*e[i].w;
				// vis[x]=0;
				return d;
			}
		}
	}
	vis[x]=0;
	return 0;
}
void dinic()
{
	while(spfa())
	while(dfs(st,inf)) ;
}
signed main()
{
	scanf("%d%d",&n,&m);st=0;ed=n<<1|1,M=n*2+2;
	for(int i=1;i<=n;i++) scanf("%d",&x),add(st,i,x,0),add(i+n,ed,x,0),add(M,i+n,inf,0);
	add(st,M,m,0);
	for(int i=1;i<=n;i++)
	for(int j=i+1;j<=n;j++)
	{
		scanf("%d",&x);
		if(x!=-1) add(i,j+n,inf,x);
	}
	dinic();
	printf("%d\n",ans);
}
```


---

## 作者：Illusory_dimes (赞：2)

### 题目大意
共有 $n$ 个国家和 $m$ 个人，他们可以选择 $n$ 个国家中任意一个开始，任意一个结束，要求每一次到达的国家编号大于上一个的编号，且第 $i$ 个国家必须恰好经过 $v_i$ 人。已知每个国家到每个编号比它大的国家的费用 $w_{i,j}$ （若是-1则为没有该路径），求最小花费。

$1\leq n \leq 100$ ， $1\leq m \leq 79$ ，最小花费保证小于$10^6$

### solution
这跟[这道题](https://www.luogu.com.cn/problem/P4001)有那么一点相似的地方，一个要用上下界，一个要用对偶图，然而我们玄学的网络流都能很轻松的怼过去。。

应该都知道是最小费用流吧。

因为有总人数限制,所以加一个点，就叫新点吧，由源点连向新点，权值为 $m$ ，费用为 $0$ 来限制人数。

看到每个国家有人数限制，果断选择拆点，分为入点和出点。

接下来是建图，

$1.$ 由源点向每一个入点连一条权值为 $v_i$ ，费用为 $0$ 的边，表示这个国家进入了 $v_i$ 个人。

$2.$ 由每一个出点向汇点连一条权值为 $v_i$ ，费用为 $0$ 的边，表示这个国家到达了 $v_i$ 个人。

$3.$ 由新点向每一个入点连一条权值为 $\infty$ 或 $m$ 均可，费用为 $0$ 的边，表示所有人可以从任意国家出发。

$4.$ 对于每个有航线的两点，由编号小的入点连向编号大的出点，权值为 $\infty$ 或 $m$ 均可，费用为航线价钱，表示什么都明白（主要是因为语文差）。

这不就好起来了。

因为是最大流，所以每一个到汇点的边都会跑满。

又因为考虑到 $\sum v_i \geq m$ ，所以限制人数的边无论如何都将被跑满，一个人都跑不了。

所以并没有什么问题，就整好了。

代码码风有点怪，仅供参考
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=5e3+10,M=1e5+10,P=1e6+10;
const int INF=0x3f3f3f3f;
int n,m,s,t,S,cur[N],dis[N],vis[N],q[P];
int ans1,ans2;
int fst[N],nxt[M],to[M],val[M],pay[M],tot=2;
inline int read()
{
	int s=0,w=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
	while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
	return s*w;
}
inline void add(int u,int v,int w,int c)
{
	nxt[tot]=fst[u];
	to[tot]=v,val[tot]=1ll*w,pay[tot]=c;
	fst[u]=tot;++tot;
	nxt[tot]=fst[v];
	to[tot]=u,val[tot]=0,pay[tot]=-c;
	fst[v]=tot;++tot;
}
int spfa()
{
	for(int i=s;i<=S;++i)dis[i]=INF,vis[i]=0;
	int hd=0,tl=1;
	q[tl]=S,dis[S]=0;
	while(hd<tl)
	{
		int u=q[++hd];vis[u]=0;
		for(int i=fst[u];i;i=nxt[i])
		{
			int v=to[i];
//			if(!val[i])continue;
			if(dis[u]+pay[i]<dis[v]&&val[i]>0)
			{
				dis[v]=dis[u]+pay[i];
				if(!vis[v])
				{
					if(dis[v]<dis[q[hd+1]])q[hd--]=v;
					else q[++tl]=v;
					vis[v]=1;
				}
			}
		}
	}
	return dis[t]!=INF;
}
int dfs(int u,int lim)
{
	if(u==t||(!lim))return lim;
	vis[u]=1;
	int ans=0,tmp;
	for(int i=cur[u];i;i=nxt[i])
	{
		int v=to[i];
		cur[u]=i;
		if(dis[v]!=dis[u]+pay[i])continue;
		if(!vis[v]&&val[i]&&(tmp=dfs(v,min(lim,val[i]))))
		{
			ans2+=tmp*pay[i];
			val[i]-=tmp,lim-=tmp;
			ans+=tmp,val[i^1]+=tmp;
		}
	}
	vis[u]=0;
	return ans;
}
inline void dinic()
{
	while(spfa())
	{
		for(int i=s;i<=S;++i)cur[i]=fst[i];
		ans1+=dfs(S,INF);
	}
}
int main()
{
	n=read(),m=read(),s=0,t=n<<1|1,S=t+1;
	add(S,s,m,0);
	for(int i=1;i<=n;++i)
	{
		int w=read();
		add(S,i,w,0),add(s,i+n,INF,0),add(i+n,t,w,0);
	}
	for(int i=1;i<n;++i)
	for(int j=i+1;j<=n;++j)
	{
		int c=read();
		if(c==-1)continue;
		add(i,j+n,INF,c);
	}
	dinic();
	printf("%d",ans2);
	return 0;
}
```
只求能帮助到几个人罢。。

---

## 作者：LEWISAK (赞：1)

[广告](https://www.cnblogs.com/lewisak)

##### 题目大意

每个国家只能向编号大于自己的飞，给定从 $i$ 到 $j$ 的费用（如果有航线的话）$d_{i,j}$，现在有 $m$ 个人从任意位置出发，求让第 $i$ 个国家恰好被经过 $V_i$ 次的最小费用。

##### 题解

首先把国家 $u$ 拆点拆成入点 $u$ 和出点 $u'$。

连 $s\to u,u'\to t,t\to t'$ 费用 $0$，上界 $m$，这里的最后一条边是为了防止有超过 $m$ 个人加入了这次旅行，其实前两条的上界都可以设成 $inf$ 的。

对于航线 $u\to v$，连 $u'\to v$ 费用为航线费用，最后连 $u\to u'$ 上下界都是 $V_u$，费用为 $0$ 即可。

##### 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
namespace kong{bool st;}
namespace zhu{
int tot=1,head[1001000],n,m,s,t,ys,yt,liu[1001000],all,nb,answ,ansc,vis[1001000],dis[1001000],h[1001000],js;
queue<int> q;
struct node{
	int v,id;
	bool operator<(const node& a)const{
		return v>a.v;
	}
};
priority_queue<node> qq;
struct{
	int nxt,to,w,c;
}e[2002000],fr[2002000];
void add(int u,int v,int w,int c){
	e[++tot]={head[u],v,w,c};
	head[u]=tot;
	e[++tot]={head[v],u,0,-c};
	head[v]=tot;
	return;
}
void add(int u,int v,int l,int r,int c){
	add(u,v,r-l,c);
	liu[u]-=l,liu[v]+=l;
}
void spfa(){
	while(!q.empty()) q.pop();
	memset(vis,0,sizeof vis);
	memset(h,0x3f,sizeof h);
	h[s]=0;vis[s]=1;
	q.push(s);
	while(!q.empty()){
		int x=q.front();
		q.pop();
		vis[x]=0;
		for(int i=head[x];i;i=e[i].nxt){
			int v=e[i].to,c=e[i].c;
			if(e[i].w&&h[v]>h[x]+c){
				h[v]=h[x]+c;
				if(vis[v]) continue;
				vis[v]=1;
				q.push(v);
			}
		}
	}
}
bool dij(){
	while(!qq.empty()) qq.pop();
	for(int i=1;i<=2*n+5;i++) vis[i]=0,dis[i]=1e18;
	dis[s]=0;
	qq.push({0,s});
	while(!qq.empty()){
		int x=qq.top().id;
		qq.pop();
		if(vis[x]) continue;
		vis[x]=1;
		for(int i=head[x];i;i=e[i].nxt){
			int v=e[i].to,w=e[i].c+h[x]-h[v];
			if(e[i].w&&dis[v]>dis[x]+w){
				dis[v]=dis[x]+w;
				fr[v].nxt=i;
				fr[v].to=x;
				if(!vis[v]) qq.push({dis[v],v});
			}
		}
	}
	return dis[t]!=1e18;
}
void PD(){
	answ=ansc=0;
	spfa();
	while(dij()){
		int minn=1e18;
		for(int i=1;i<=2*n+5;i++){
			h[i]+=dis[i];
		}
		for(int i=t;i!=s;i=fr[i].to){
			minn=min(minn,e[fr[i].nxt].w);
		}
		for(int i=t;i!=s;i=fr[i].to){
			e[fr[i].nxt].w-=minn;
			e[fr[i].nxt^1].w+=minn;
		}
		answ+=minn;
		ansc+=minn*h[t];
	}
}
string main(){
	cin>>n>>m;
	ys=2*n+1,yt=ys+1,js=yt+1,s=js+1,t=s+1;
	add(yt,js,m,m,0);
	for(int i=1;i<=n;i++){
		int v;
		cin>>v;
		add(i,i+n,v,v,0);
		add(js,i,0,m,0);
		add(i+n,yt,0,m,0);
	}
	for(int i=1;i<n;i++){
		for(int j=i+1;j<=n;j++){
			int x;
			cin>>x;
			if(x!=-1){
				add(i+n,j,0,m,x);
			}
		}
	}
	for(int i=1;i<=js;i++){
		if(liu[i]>0){
			add(s,i,liu[i],0);
			all+=liu[i];
		}
		else if(liu[i]<0){
			add(i,t,-liu[i],0);
		}
	}
	PD();
	int flow=ansc;
	e[nb].w=e[nb^1].w=0;
	t=yt,s=ys;
	PD();
	return "12321";
}
}
namespace kong{bool ed;double MB(){return (&st-&ed)/1048576.0;}}
signed main(){
	cerr<<zhu::main()<<' '<<kong::MB();
	return 0;
}
```

---

## 作者：YZren (赞：1)

发现题解中没有用 vector 写的，~~赶紧来水一发~~。

[题目传送门](https://www.luogu.com.cn/problem/P4553)

# 思路
- 明显此题是费用流，先看一下费用流模版。

```cpp
inline bool Spfa(){
	f(i,S,T) dis[i]=LLONG_MAX,vis[i]=cur[i]=0;
	queue<int> q; q.push(S); dis[S]=0; vis[S]=1;
	while(!q.empty()){
		int p=q.front(); q.pop(); vis[p]=0;
		for(auto y:vec[p]) if(y.val&&dis[y.to]>dis[p]+y.cost){
			dis[y.to]=dis[p]+y.cost;
			if(!vis[y.to]) q.push(y.to),vis[y.to]=1;
		}
	}
	return dis[T]!=LLONG_MAX;
}
inline int dfs(int x,int inc){
	if(x==T) return inc;
	int delta=inc;	vis[x]=1;
	f(i,cur[x],(int)vec[x].size()-1){
		cur[x]=i;
		if(dis[vec[x][i].to]==dis[x]+vec[x][i].cost&&vec[x][i].val&&!vis[vec[x][i].to]){
			int d=dfs(vec[x][i].to,min(delta,vec[x][i].val));
			vec[x][i].val-=d; vec[vec[x][i].to][vec[x][i].id].val+=d;
			delta-=d; if(!d) dis[vec[x][i].to]=LLONG_MAX;
			if(!delta) break;
		}
	} vis[x]=0;
	return inc-delta;
}
inline void Dinic(){
	while(Spfa()) ans+=dfs(S,LLONG_MAX)*dis[T];
	write(ans);
}
```
- 总所周知，网络流的模版很简单，关键是建图，可以想到将几个国家拆点，然后源点连出边（流量为到该国的最大人数，费用为零），入边连汇点（流量为到该国的最大人数，费用为零），一个出边连另一个入边（流量为正无穷，费用为机票费），新建一个 $M$ 节点由入边连一条边（流量为正无穷，费用为零），再从源点连 $M$（流量为 $m$，费用为零）。建边代码如下。
```cpp
inline void add(int u,int v,int w,int c){Uto=vec[u].size(),Vto=vec[v].size(),vec[u].push_back({v,w,c,Vto}),vec[v].push_back({u,0,-c,Uto});}
```
这样此题就结束了。

# Code

```cpp
#include<bits/stdc++.h>
#define int long long
#define endl "\n"
#define f(i,j,k) for(int i=j;i<=k;i++)
#define F(i,j,k) for(int i=j;i>=k;i--)
using namespace std;
const int maxn=3e3+10;
inline int read(){
	int x=0,f=1;char ch=getchar();
	while (ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}
	while (ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}
	return x*f;
}
inline void write(int x){
	if(x<0) {x=~(x-1); putchar('-');}
	if(x>9) write(x/10);
	putchar(x%10+'0');
}
int n=read(),m=read(),cost,Uto,Vto,cur[maxn],dis[maxn],S=0,T=n*2+2,M=n*2+1,vis[maxn],ans;
struct node{int to,val,cost,id;}; vector<node> vec[maxn];
inline void add(int u,int v,int w,int c){Uto=vec[u].size(),Vto=vec[v].size(),vec[u].push_back({v,w,c,Vto}),vec[v].push_back({u,0,-c,Uto});}
inline bool Spfa(){
	f(i,S,T) dis[i]=LLONG_MAX,vis[i]=cur[i]=0;
	queue<int> q; q.push(S); dis[S]=0; vis[S]=1;
	while(!q.empty()){
		int p=q.front(); q.pop(); vis[p]=0;
		for(auto y:vec[p]) if(y.val&&dis[y.to]>dis[p]+y.cost){
			dis[y.to]=dis[p]+y.cost;
			if(!vis[y.to]) q.push(y.to),vis[y.to]=1;
		}
	}
	return dis[T]!=LLONG_MAX;
}
inline int dfs(int x,int inc){
	if(x==T) return inc;
	int delta=inc;	vis[x]=1;
	f(i,cur[x],(int)vec[x].size()-1){
		cur[x]=i;
		if(dis[vec[x][i].to]==dis[x]+vec[x][i].cost&&vec[x][i].val&&!vis[vec[x][i].to]){
			int d=dfs(vec[x][i].to,min(delta,vec[x][i].val));
			vec[x][i].val-=d; vec[vec[x][i].to][vec[x][i].id].val+=d;
			delta-=d; if(!d) dis[vec[x][i].to]=LLONG_MAX;
			if(!delta) break;
		}
	} vis[x]=0;
	return inc-delta;
}
inline void Dinic(){
	while(Spfa()) ans+=dfs(S,LLONG_MAX)*dis[T];
	write(ans);
}
inline void work(){
	f(i,1,n) cost=read(),add(S,i,cost,0),add(i+n,T,cost,0),add(M,i+n,LLONG_MAX,0);
	add(S,M,m,0);
	f(i,1,n-1) f(j,i+1,n){
		cost=read(); if(cost==-1) continue;
		add(i,j+n,LLONG_MAX,cost);
	}
	Dinic();
}
signed main(){work();return 1^1;}
```

---

## 作者：_Ch1F4N_ (赞：1)

考虑上下界最小费用可行流。

建模如下，考虑对于每个点 $u$ 拆成 $(u_1,u_2)$ 中间连一条边，钦定它的流量上下界是 $(v_i,v_i)$ 并且费用为 $0$，然后点与点之间连边 $(u,v,0,\infty,w)$ 最后求解出这张图的上下界最小费用可行流。

怎么求解上下界最小费用可行流？

考虑依然建出附加源点汇点，然后在连边 $(x,y,l,r,w)$ 建出附加边 $(x,T,l,0)$ 与 $(S,y,l,0)$，当然由于已经有了 $l$ 的流量，所以答案先加上 $l \times w$，等于说是一般的可行流加上边权，最后求解新图的最小费用最大流即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn = 1e6+114;
const int maxm = 1e6+114;
const int inf = 1e9+114;
int pre[maxn],head[maxm<<1],vis[maxn],tot=1;
int flow[maxn];
int dis[maxn];
int s,t,maxflow,ans,n,m;
struct Node{
	int v,w,nxt,val;
}e[maxm<<2];
inline void add(int u,int v,int w,int val){
	e[++tot].v=v;
	e[tot].nxt=head[u];
	e[tot].w=w;
	e[tot].val=val;
	head[u]=tot;
	e[++tot].v=u;
	e[tot].nxt=head[v];
	e[tot].w=0;
	e[tot].val=-val;
	head[v]=tot;
}
bool spfa(){
	memset(dis,inf,sizeof(dis));
	memset(vis,false,sizeof(vis));
	queue<int> q;
	flow[s]=inf;
	vis[s]=true;
	dis[s]=0;
	q.push(s);
	while(!q.empty()){
		int u=q.front();
		vis[u]=false;
		q.pop();
		for(int i=head[u];i;i=e[i].nxt){
			int v=e[i].v,cost=e[i].val;
			if(e[i].w>0&&dis[u]+cost<dis[v]){
				dis[v]=dis[u]+cost;
				flow[v]=min(flow[u],e[i].w);
				pre[v]=i;
				if(vis[v]==false)
					q.push(v),vis[v]=true;
			}
		}
	}
	return dis[t]<inf;
}
void update(){
	int u=t;
	while(u!=s){
		e[pre[u]].w-=flow[t];
		e[pre[u]^1].w+=flow[t];
		u=e[pre[u]^1].v;
	}
	maxflow+=flow[t];
	ans+=flow[t]*dis[t];
	return ;
}
void add_ULFlow(int x,int y,int l,int r,int w){
    add(x,y,r-l,w);
    add(x,t,l,0);
    add(s,y,l,0);
    ans=l*w;
}
//[1,2*n] 是国家 2*n+1 是虚拟起点 2*n+2 是虚拟终点 2*n+3 是源点 2*n+4 是汇点
int main(){
    cin>>n>>m;
    s=2*n+5,t=2*n+6;
    for(int i=1;i<=n;i++){
        int v;
        cin>>v;
        add_ULFlow(2*i-1,2*i,v,v,0);
        add_ULFlow(2*n+1,2*i-1,0,inf,0);
        add_ULFlow(2*i,2*n+2,0,inf,0);
    }
    add_ULFlow(2*n+3,2*n+1,m,m,0);
    add_ULFlow(2*n+2,2*n+4,m,m,0);
    for(int i=1;i<=n;i++){
        for(int j=1;i+j<=n;j++){
            int w;
            cin>>w;
            if(w!=-1) add_ULFlow(2*i,2*(i+j)-1,0,inf,w);
        }
    }
    add_ULFlow(2*n+4,2*n+3,0,inf,0);
   	while(spfa()==true) update();
	cout<<ans;
	return 0;
}

```


---

## 作者：sangshang (赞：1)

## Description

$m$ 个人旅游，有 $n$ 个点，$i$ 个点人流量一定要是 $V_i$。

对于每个人的路线，可以在任意位置开始，任意位置结束，但途经节点编号单调递增。两个城市间移动有固定费用，也有可能不连通。保证有解，求最小花费。

# Solution

考虑不同路径，任意起点终点，人流量一定，和费用最小，可以确定是费用流模型。注意具体的，因为点的出入人流量一定，所以考虑**有源汇上下界最小费用可行流**。

为了保证每个点贡献唯一，将每个点拆成入点和出点，从入点向出点连一条边，表示经过该城市。像这样，流量从入点进入，全部途经向出点的连边，保证贡献唯一。为保证人流流量一定，对于一个点拆成的两点，从出点到汇点的连边是一条上下界均为 $V_i$ 费用为 $0$ 的边。

虚拟源汇点，表示有 $m$ 个人旅游。因为旅游人数一定，所以所以新建立两点，将源汇点也拆成两点，入点到出点的连边是一条上下界均为 $m$ 费用为 $0$ 的边。并从源点的出点向每个城市的入点连下界为 $0$ 上界为 $+\infty$ 费用为 $0$ 的边。汇点同理。

对于一条从城市 $i$ 到城市 $j$ 费用为 $cost$ 的边，从 $i$ 的出点向 $j$ 的入点连一条下界为 $0$ 上界为 $+\infty$ 费用为 $cost$ 的边。表示经过点 $i$ 流向点 $j$。

## 有源汇上下界最小费用可行流

如果不会上下界网络流看[这道题](https://www.luogu.com.cn/problem/P5192)。

将最大流改成费用流也是一个道理，边的费用不变，先将边的下界流满，注意预先累加费用。

再虚拟超级源汇点，将流量不平衡的边与超级源汇点对应连边，意为根据每条边剩余可调整流量将流量调整平衡。

上述两步费用累加起来，就是可行流最小费用。

## C++ Code

```cpp
#include <bits/stdc++.h>
using namespace std;

class Dinic {
	public:
		typedef int TYPE;
		static const int maxn = 1e4, inf = 0x7f7f7f7f, maxm = inf;
		class edge {
			public:
				int to, rev;
				TYPE flow, cost;
				edge(int to, TYPE flow, TYPE cost, int rev): to(to), flow(flow), cost(cost), rev(rev) {}
				edge() {}
		};
		std::vector<edge>vec[maxn];
		TYPE MinCost, MaxFlow, dist[maxn], W[maxn];
		int cur[maxn], n, m, s, t;
		bool vis[maxn];
		Dinic(int n, int m, int s, int t): n(n), m(m), s(s), t(t),
			MinCost(0), MaxFlow(0), cur({0}), dist({0}), vis({false}) {}
		Dinic() {}
		inline void _Add_Edge_(int from, int to, TYPE flow, TYPE cost) {
			vec[from].push_back(edge(to, flow, cost, vec[to].size()));
			vec[to].push_back(edge(from, 0, -cost, vec[from].size() - 1));
		}
		inline void Add_Edge(int from, int to, TYPE flowL, TYPE flowR, TYPE cost) {
			W[from] -= flowL, W[to] += flowL;
			MinCost += flowL * cost;
			_Add_Edge_(from, to, flowR - flowL, cost);
		}
		inline bool SPFA() {
			std::memset(dist, inf, sizeof(dist));
			dist[t] = 0;
			std::memset(cur, 0, sizeof(cur));
			std::queue<int>que;
			for (que.push(t), vis[t] = true; !((bool)  que.empty());) {
				int u = que.front();
				vis[u] = false;
				que.pop();
				for (edge &e : vec[u]) {
					int v = e.to;
					if (vec[v][e.rev].flow && dist[u] + vec[v][e.rev].cost < dist[v]) {
						dist[v] = dist[u] + vec[v][e.rev].cost;
						if (!vis[v]) {
							que.push(v);
							vis[v] = true;
						}
					}
				}
			}
			return dist[s] != inf;
		}
		inline TYPE dfs(int u, TYPE flow) {
			if (u == t || !flow) {
				return flow;
			}
			vis[u] = true;
			TYPE res = 0;
			int sz = vec[u].size();
			for (int &i = cur[u]; i < sz && flow; ++i) {
				edge &e = vec[u][i];
				int v = e.to;
				if (e.flow && dist[u] == dist[v] + e.cost && !vis[v]) {
					TYPE Preflow = dfs(v, std::min(flow, e.flow));
					res += Preflow, flow -= Preflow, MinCost += Preflow * (e.cost);
					e.flow -= Preflow, vec[v][e.rev].flow += Preflow;
				}
			}
			vis[u] = false;
			return res;
		}
		inline TYPE Get_MaxFlow_MinCost() {
			MaxFlow = 0;
			while (SPFA()) {
				std::memset(vis, false, sizeof(vis));
				TYPE Preflow = dfs(s, inf);
				MaxFlow += Preflow;
			}
			return MaxFlow;
		}
		inline TYPE clac(int S, int T) {
			Add_Edge(T, S, 0, inf, 0);
			int PreS = n + 1, PreT = n + 2;
			this->s = PreS, this->t = PreT;
			TYPE sum = 0;
			for (int i = 0; i <= n; ++i) {
				if (W[i] > 0) {
					Add_Edge(PreS, i, 0, W[i], 0);
					sum += W[i];
				} else if (W[i] < 0) {
					Add_Edge(i, PreT, 0, -W[i], 0);
				}
			}
			if (Get_MaxFlow_MinCost() < sum) {
				return -1;
			} else {
				return (MaxFlow = vec[S].back().flow);
			}
		}
		inline void Solve() {
#define id(a,CLASS) (a+(CLASS*N))
			int N, M;
			scanf("%d%d", &N, &M);
			this[0] = Dinic(N * 2 + 5, inf, N * 2 + 1, N * 2 + 2);
			for (int i = 1; i <= N; ++i) {
				int tmp;
				scanf("%d", &tmp);
				Add_Edge(id(i, 0), id(i, 1), tmp, tmp, 0);
			}
			for (int i = 1; i < N; ++i) {
				for (int j = i + 1; j <= N; ++j) {
					int tmp;
					scanf("%d", &tmp);
					if (tmp != -1) {
						Add_Edge(id(i, 1), id(j, 0), 0, inf, tmp);
					}
				}
			}
			int LimS = N * 2 + 3, LimT = N * 2 + 4;
			Add_Edge(s, LimS, M, M, 0);
			Add_Edge(LimT, t, M, M, 0);
			for (int i = 1; i <= N; ++i) {
				Add_Edge(LimS, id(i, 0), 0, inf, 0);
				Add_Edge(id(i, 1), LimT, 0, inf, 0);
			}
			TYPE Ans = clac(s, t);
			if (~Ans) {
				printf("%d\n", MinCost);
			} else {
				printf("No Solution.%d\n", MinCost);
			}
		}
};
Dinic Main;

int main() {
	Main.Solve();
	return 0;
}
```


---

## 作者：walk_alone (赞：1)

费用流好题。

首先应该注意到一个事情：$\sum v_i>m$。相当于每个人要多跑几个国家，否则答案就是0——直接玩一个国家没有路费的问题了。

错误做法：这个题一开始我还以为建图挺简单的：中间每个国家拆点限制流量，汇点也拆开继续限制容量，然后每个点和源汇一连，中间那些航线双向建边。结果爆零（双重）——**这么建边源点到汇点距离恒为0。** 为什么？因为国家（正经点）经过拆点后**零费用边**的流量总和大于$m$（由上面分析），此处还尚未考虑国家之间的带费用的边；然后由于每个点的入点和源点相连，流量无穷，费用为0；出点和汇点相连，唯一限制只有总流量小于等于$m$，费用还是零。那么，我们就有一个全0的走法：s->一个国家入点->对应出点->t。因而错误。

下面来讲正解。

先拆分整个问题：**先把这$m$个人起点给放好了，再让他们互相的坐飞机去别的地方玩。**

首先考虑$\sum v_i$的意义：出游的**人次**。由于$m$必然会小于人次数，则要求一个人要出游多个国家（这不是废话）。但是，**一个人出游的第一个国家显然是不会收费的——即，一个人可以从任意国家出发**，那么首先应该处理的是这一部分问题，也就是前半句。

这一部分应该如何处理呢？因为他们无论在哪里开始，都是免费的，那么我们就应该先让**源汇之间连一些（一条只串联一个正经节点，费用为0）的边，这些边的总容量为$m$**。 因为这里只关心这$m$个人从哪里开始，因而只能让这些边连接**一个节点**；同时由于一个人只能从一个地方开始，总容量就只能有$m$了；同时，一个国家**必须**有$v[i]$个人去玩，那么最多不能超过$v[i]$个人去，因而进出这个节点的总容量要进行限制。

这个地方处理方法非常简单：每个点和源和汇各连**流量为$v[i]$，费用为0**的边，最后在源点或者汇点附近搞一个限制节点就可以了（每个点和限制节点连，限制节点最后牵出一个容量为$m$的边到汇点/源点）。

那么考虑第二部分问题：**如何让他们互相转移**。

转移的次数应该为$\sum v_i-m$——总人次减去第一波游览的。那么，这部分的总容量应该是$\sum v_i-m$。但是，一个人如果要玩很多个城市，好像处理起来有点复杂；我们把问题转化为**坐飞机**——即，$\sum v_i-m$人去在这些国家之间坐飞机，使得每个国家到着人次符合要求。这样处理的合理性在于：我们不关心单个人的旅程，而关心宏观的总费用。那我们从宏观上看，如果每个人游玩时间为0，我们眼前的图景其实就是这么多人在不停坐飞机从这儿到那儿，因而不妨让$n$人次变成$n$个人坐**一次飞机**。

那么我们的方法就变成了：**我再给图上$\sum v_i$的总流量（人），从一层节点（记为层1）出发到另一层节点（记为层2，即第一波操作与源汇相连的那些节点）坐飞机付钱，然后直接结束旅程，连入汇点**。因为只坐一次飞机，那么只需要两层图即可解决；此外，**我们不再新增从层2到汇点的流量**——注意到我们在第一波操作中已经让这一层节点连向汇点总流量为$\sum v_i$，显然这个东西是包含了这两个操作中的所有人次的，因而不能再次连边扩容。**这样我们就控制了总容量为$\sum v_i$**。同时基于费用流的特征——流要优先最大，因而我们必然可以保证每个点被到了$v_i$次——这些点到汇点都连了个$v[i]$的边。

下面给出样例对应建出的图，非常密集。

[![yt1GAe.png](https://s3.ax1x.com/2021/02/07/yt1GAe.png)](https://imgchr.com/i/yt1GAe)

解释一下：7为起点，8为终点，9为第一次操作的限制节点，控制总容量为$m$。10-15为层1，1-6为层2，它们之间建立航线。

其中流量关系为：$7\to 9$：$m$。$9 \to \text{层2}$与$\text{层2} \to 8$：各国家限额。$\text{层1} \to \text{层2}$：无穷。

费用关系：除了层1与层2有航线费用其余全部为0。

附上建立这个图的代码，其余部分就是费用流的板子了。

```cpp
    int m, maxflow = 0, mincost = 0, s, t, a, tot = 0;
    scanf("%d%d", &n, &m);
    tot = n;
    s = ++tot;
    t = ++tot;
    tot++;//第一辅助点，限制总流量的点
    add(s, tot, m, 0);
    add(tot, s, 0, 0);
    for (int i = 1; i <= n; i++)
    {
        scanf("%d", &v[i]);
        add(tot, i, inf, 0);//限额点到每个国家，可以为inf——反正后面还要限制出口的
        add(i, tot, 0, 0);
        add(i, t, v[i], 0);//出口记得限制
        add(t, i, 0, 0);
    }
    //以上为第一步操作
    for (int i = 1; i <= n; i++)
    {
        tot++;
        add(s, tot, v[i], 0);//tot为层1，代表国家，所以要限额
        add(tot, s, 0, 0);
        for (int j = i + 1; j <= n; j++)
        {
            scanf("%d",&a);
            if(a==-1)
                continue;
            add(tot, j, inf, a);//两层点之间的航线
            add(j, tot, 0, -a);
        }
    }//第二步操作
```


---

## 作者：Aftglw (赞：1)

## 题目大意
自东向西有 $n$ 个国家。有 $m$ 个人，他们可以选择 $n$ 个国家中任意一个开始，任意一个结束，但路线必须自东向西，且第 $i$ 个国家必须恰好经过 $v_i$ 人。已知每个国家到它西方的国家的费用，求最小花费。
## 最小费用最大流
蒟蒻不会上下界，看了一些大佬写的费用流，想了一下，发表一下自己的理解，希望对大家有帮助。

首先因为对于每个点(国家)都有经过限制，所以将拆点为入点和出点。 $i\rightarrow (i,i+n)$

$s$ 向第 $i$ 入点连容量 $v_i$ 费用 $0$ 的边，因为每个国家必须要有 $v_i$ 人来，连这条边就相当于这 $v_i$ 个人进入了该国。

同理，出点向 $t$ 连容量 $v_i$费用 $0$ 的边，表示有 $v_i$ 个人到达了这个国家。 

对于每条航线 $(u,v)$，由 $u$ 的入点向 $v$ 的出点连容量 $\infty$ 费用 $0$ 的边，表示进入国家 $u$ 的人可以前往国家 $v$ 并声明到达了国家 $v$ (即从 $v$ 的出点到达汇点)。

最后额外再建一个点，由 $s$ 向它连容量 $m$ 费用 $0$ 的边，然后让他向每个出点连容量 $\infty$ 费用 $0$ 的边表示这 $m$ 个人可以随便选出发点。

然后跑最小费用最大流即可。

考虑正确性：因为跑的是最大流，所以每个出点到汇点的边一定会跑满，也就保证了每个国家限定经过次数。
又因为从那个额外点到其他出点的边费用为 $0$ 所以这些边会被优先选择，也就意味着从源点到额外点着条边一定会跑满，也就意味着这 $m$ 个人一定会出发(不会有人临阵脱逃)。

## Code
```cpp
#include<bits/stdc++.h>
//#define int long long
#define pair pair<int,int>
using namespace std;
inline void end()
{
	puts("");
	system("pause");
}
inline int read()
{
	int s=0,w=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-') w=-1;ch=getchar();}
	while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
	return s*w;
}
const int N=222,M=2e4+4,inf=0x3f3f3f3f,INF=1e9;
int s,t,maxf,minc;
int first[N],nex[M],to[M],w[M],c[M],num=1;
inline void add(int u,int v,int val,int cos)
{
	nex[++num]=first[u];
	first[u]=num;
	to[num]=v;
	w[num]=val;
	c[num]=cos;
}
inline void Add(int u,int v,int val,int cos)
{
	add(u,v,val,cos);
	add(v,u,0,-cos);
}
int dis[N],vis[N],cur[N];
inline bool SPFA()
{
	memset(dis,0x3f,sizeof(dis));
	memset(vis,0,sizeof(vis));
	deque<int> q;
	q.push_back(s);
	vis[s]=1;dis[s]=0;
	while(!q.empty())
	{
		int u=q.front();q.pop_front();vis[u]=0;
		for(int i=first[u];i;i=nex[i])
		{
			int v=to[i];
			if(!w[i]) continue;
			if(dis[v]>dis[u]+c[i])
			{
				dis[v]=dis[u]+c[i];
				if(!vis[v])
				{
					vis[v]=1;
					if(q.empty()||dis[v]>dis[q.front()]) q.push_back(v);
					else q.push_front(v);
				}
			}
		}
	}
	if(dis[t]==inf) return 0;
	return 1;
}
int dfs(int u,int in)
{
	if(u==t) return in;
	vis[u]=1;
	int out=0;
	for(int i=cur[u];i;i=nex[i])
	{
		int v=to[i];
		if(!w[i]||vis[v]) continue;
		if(dis[v]==dis[u]+c[i])
		{
			int res=dfs(v,min(w[i],in-out));
			w[i]-=res;
			w[i^1]+=res;
			out+=res;
			minc+=c[i]*res;
			if(in==out) break;
		}
	}
	vis[u]=0;
	if(!out) vis[u]=1;
	return out;
}
void Dinic()
{
	while(SPFA())
	{
		memcpy(cur,first,sizeof(first));
		while(1)
		{
			int detal=dfs(s,1e9);
			if(!detal) break;
			maxf+=detal;
		}
	}
}
int n,m,v[N],ex;
main()
{
	n=read(),m=read();ex=2*n+1;s=0,t=ex+1;
  //ex为额外点
	Add(s,ex,m,0);
	for(int i=1;i<=n;++i)
	{
		v[i]=read();
		Add(i+n,t,v[i],0);
		Add(ex,i+n,INF,0);
	}
	for(int i=1;i<=n;++i)
	{
		Add(s,i,v[i],0);
		for(int j=i+1;j<=n;++j)
		{
			int val=read();
			if(val==-1) continue;
			Add(i,j+n,INF,val);
		}
	}
	Dinic();//最小费用最大流
	printf("%d",minc);
	//end();
	return 0;
}
```


---

## 作者：lao_wang (赞：0)

## 前言

同学们读题一定要仔细~~我读错了四遍~~。

## 题意

$M$ 个人想尽一切办法让 $N$ 个国家仅有 $V_i$ 个人拜访，同时要满足费用最小。

## 建图

提前定义一下 $(u,v,down,up,money)$ 为 $u$ 向 $v$ 连下界为 $down$ 上界为 $up$ 费用为 $money$ 的边。源点为 $s$，汇点为 $t$。附加源点为 $ss$，附加汇点 $tt$。

显然有两个地方我们需要拆点：

1. 每个人的开始地点。
2. 国家与国家相连的边。

这两个地方我们不能保证一定小于或等于他们的定值，所以需要将拆成一个入点（$a'$）一个出点 ($a$)。

由“他们主要分布在东方” 中“分布” 一词可得出发点不一样所以 $(s',s,0,m,0)$、$(s,i',0,inf,0)$、$(i,t,0,inf,0)$。

由“有且仅有 $V_i$ 个人会经过那一个国家” 可得 $(i',i,V_i,V_i,0)$（这样便于不用想其他方式表示它）。

由“打算通过坐飞机” 可得每个国家连边为 $(i,(i+j)',0,inf,money_i)$。

然后跑一个有上下界最小费用最大流，就做完了。

## 代码

```cpp
#include<bits/stdc++.h>
#define int long long
#define inf 2147483647
#define N 112345
using namespace std;
int n , m , s , t , ss , tt , s_ , head[N] , temp_head[N] , now[N] , dep[N] , cnt=0 , money , v[N] ;
bool f[N] ;
struct node{
	int to , next , w , c ;
}e[N<<2],temp[N<<2];
void use(int u,int v,int w,int c){
	e[cnt].to = v ;
	e[cnt].w = w ;
	e[cnt].c = c ;
	e[cnt].next = head[u] ;
	head[u] = cnt++ ;
}
void newnet(int u,int v,int w,int c){
	use(u,v,w,c) ;
	use(v,u,0,-c) ;
}
bool bfs(){
	for(int i=1;i<=n*3;i++) now[i] = head[i] , f[i] = 0 , dep[i] = inf ;
	queue<int> q ;
	q.push(s) ;
	dep[s] = 0 ;
	while(!q.empty()){
		int u=q.front() ;
		q.pop() ;
		f[u] = 0 ;
		for(int i=head[u];~i;i=e[i].next){
			int x=e[i].to ;
			if(dep[u]+e[i].c<dep[x]&&e[i].w){
				dep[x] = dep[u]+e[i].c ;
				if(!f[x]){
					f[x] = 1 ;
					q.push(x) ;
				}
			}
		}
	}
	return dep[t]!=inf ;
}
int dfs(int u,int sum){
	if(u==t) return sum ;
	if(f[u]) return 0 ;
	f[u] = 1 ;
	int use=0 ;
	for(int i=now[u];~i;i=e[i].next){
		now[u] = i ;
		int x=e[i].to ;
		if(!e[i].w||dep[u]+e[i].c!=dep[x]) continue ;
		int temp=dfs(x,min(sum,e[i].w)) ;
		if(!temp) continue ;
		e[i].w -= temp ;
		e[i^1].w += temp ;
		use += temp ;
		money += e[i].c*temp ;
		sum -= temp ;
		if(!sum) break ;
	}
	return use ;
}
int dinic(){
	int ans=0 ;
	while(bfs()) ans += dfs(s,inf) ;
	return ans ;
}
signed main(){
	memset(head,-1,sizeof head) ;
	cin >> n >> m ;
	s = n*2+1 ;t = s+1 ;ss = t+1 ;tt = ss+1 ; s_ = tt+1 ;
	newnet(s,s_,m,0) ;
	for(int i=1;i<=n;i++) scanf("%lld",v+i) ;
	for(int i=1;i<=n;i++) newnet(i+n,tt,v[i],0) , newnet(ss,i,v[i],0) , newnet(s_,i+n,m,0) ;
	for(int i=1;i<=n;i++){
		int u ;
		newnet(i,t,inf,0) ;
		for(int j=1;j<=n-i;j++){
			scanf("%lld",&u) ;
			if(u==-1) continue ;
			newnet(i,j+i+n,inf,u) ;
	
		}
	}
	newnet(t,s,inf,0) ;
	swap(ss,s) ;
	swap(tt,t) ;
	dinic() ;
	swap(ss,s) ;
	swap(tt,t) ;
	cout << money << endl ;
	return 0 ;
}
```

---

## 作者：AubRain (赞：0)

## 有源汇点有上下界最小费用可行流。

若未特殊说明，连边的费用为 $0$ 

1、首先把每个国家拆成入点和出点，入点向出点连下界为 $vi$ ,上界为 $vi$ 的边，代表这个国家能且必须要被经过 $vi$ 次。

2、建一个虚拟节点，源点向该节点连流量为 $m$  的边，该节点向每个国家的入点连无流量限制（下界为 $0$ ,上界 $INF$ ）的边。这代表了人数的限制。

3、每个国家的出点向汇点连无流量限制的边。

4、若 $i$ 国可以到达 $j$ 国，则 $i$ 国的出点向 $j$ 国的入点连无流量限制，费用为机票费用的边。

然后跑最小费用有上下界的最小费用流即可。

代码：（$ss$ 为源点，$tt$ 为汇点，$s,t$ 为超级源汇点）
```cpp
#include <bits/stdc++.h>
#define N 1005
#define M 1000005
#define INF 1e9
using namespace std;

inline void rd(int &X){
    X=0;int w=0;char ch=0;
    while(!isdigit(ch))w|=ch=='-',ch=getchar();
    while( isdigit(ch))X=(X<<3)+(X<<1)+(ch^48),ch=getchar();
    X=w?-X:X;
}

int n,m,ans,s=N-1,t=N-2,ss,tt;
int head[N],cnt=1,T[N];
int d[N],mn[N],v[N],pre[N];
struct nd{int nxt,to,v,c,l,r,pd;}e[M];
#define For(x) for(int y,i=head[x];(y=e[i].to);i=e[i].nxt)

inline void add(int x,int y,int v,int c=0,int l=0,int r=0){
	if(!v) v=r-l;
	e[++cnt]=(nd){head[x],y,v, c,l,r,-1};head[x]=cnt;
	e[++cnt]=(nd){head[y],x,0,-c,l,r, 1};head[y]=cnt;
}
bool SPFA()
{
    memset(d,0x3f,sizeof d);d[s]=0;
    queue<int> q;q.push(s);mn[s]=1<<29;
    while(!q.empty()){
        int x=q.front();q.pop();v[x]=0;
        For(x) if(e[i].v&&d[y]>d[x]+e[i].c)
        {
            pre[y]=i; d[y]=d[x]+e[i].c;
            mn[y]=min(mn[x],e[i].v);
            if(!v[y]) v[y]=1,q.push(y);
        }
    }
    return d[t]!=0x3f3f3f3f;
}
void up()
{
    ans+=d[t]*mn[t];
    for(int i,x=t;x!=s;x=e[i^1].to)
        i=pre[x],e[i].v-=mn[t],e[i^1].v+=mn[t];
}
void solve()
{
	for(int x=1;x<=n+n+3;x++)
		For(x) T[x]+=e[i].pd*e[i].l,ans+=e[i].l*e[i].c*(e[i].pd<0);
	for(int i=1;i<=n+n+3;i++)
		if(T[i]>0) add(s,i,T[i],0);
		else if(T[i]<0) add(i,t,-T[i],0);
	while(SPFA()) up();
}
signed main(){
	rd(n);rd(m);ss=n+n+2;tt=n+n+3;
	add(ss,n+n+1,m);add(tt,ss,INF);
	for(int i=1;i<=n;i++)
		add(n+n+1,i,0,0,0,INF);
	for(int x,i=1;i<=n;i++)
		rd(x),add(i,i+n,0,0,x,x),add(i+n,tt,0,0,0,INF);
	for(int x,i=1;i<=n;i++)
		for(int j=i+1;j<=n;j++){
			rd(x);if(x!=-1) add(i+n,j,0,x,0,INF);
		}
	solve();cout<<ans;
}

```

---


# [THUSC 2017] 换桌

## 题目描述

班级聚会的时候，班主任为了方便管理，规定吃饭的时候同一个寝室的同学必须坐在一起；但是吃完饭后，到了娱乐时间，喜欢不同游戏的同学会聚到一起；在这个过程中就涉及到了座位分配的问题。

有 $n$ 张圆桌排成一排（从左到右依次编号为 $0$ 到 $n-1$），每张桌子有 $m$ 个座位（按照逆时针依次编号为 $0$ 到 $m-1$），在吃饭时每个座位上都有一个人；在吃完饭后的时候，每个人都需要选择一个新的座位（新座位可能和原来的座位是同一个），具体来说，第 $i$ 桌第 $j$ 个人的新座位只能在第 $L_{i,j}$ 桌到第 $R_{i,j}$ 桌中选，可以是这些桌中的任何一个座位。确定好新座位之后，大家开始移动，移动的体力消耗按照如下规则计算：

移动座位过程分为两步：

1. 从起始桌移动到目标桌**对应座位**，这个过程中的体力消耗为**两桌距离的两倍**，即从第 $i$ 桌移动到第 $j$ 桌对应座位的体力消耗为 $2\times |i-j|$；
1. 从目标桌的对应座位绕着桌子移动到目标座位，由于桌子是圆的，所以客人会选择**最近的方向**移动，体力消耗为**移动距离的一倍**，即从编号为 $x$ 的座位移动的编号为 $y$ 的座位的体力消耗为 $\min(|x-y|,m-|x-y|)$；

详情如下图：
![pic1](https://i.loli.net/2019/01/16/5c3f2f01e0336.png)
现在，给定每个客人的限制（即每个人的新座位所在的区间），需要你设计一个方案，**使得所有客人消耗的体力和最小；本题中假设客人在移动的时候互不影响。**

## 说明/提示

#### 样例解释
对于样例 $1$，
![pic2](https://i.loli.net/2019/01/16/5c3f2f01d91ae.png)

第 $0$ 桌的 $0$ 和 $3$ 号，以及第 $1$ 桌的 $0$ 号和 $2$ 号都被限制为只能坐在他们原来的桌子（可以不是原来的座位），其他人分别需要换到第 $1$ 桌和第 $0$ 桌；

可以发现，最优方案如上图，总体力消耗为 $10$。

对于样例 $2$，所有人都想坐到第 $0$ 桌，所以没有合法的方案。

对于全部数据：$1\le n\le 300$，$1\le m\le 10$，$0\le L_i\le R_i\le n-1$ 。
| 测试点 | $n\le$ |
| :----------: | :----------: |
| 1~2 | $2$ |  |
| 3~8 | $40$ |  |
| 9~14 | $100$ |  |
| 15~20 | $300$ |  |


## 样例 #1

### 输入

```
2 4
0 1 1 0
1 0 1 0
0 1 1 0
1 0 1 0```

### 输出

```
10```

## 样例 #2

### 输入

```
2 4
0 0 0 0
0 0 0 0
0 0 0 0
0 0 0 0```

### 输出

```
no solution```

## 样例 #3

### 输入

```
2 10
0 0 1 1 0 0 0 1 0 0
1 1 1 0 0 1 0 0 0 0
1 0 1 1 1 0 1 1 1 1
1 1 1 1 1 1 0 0 1 0```

### 输出

```
22```

# 题解

## 作者：Prean (赞：2)

~~来一个瞎几把口胡的费用流做法~~

首先每个点向目标点连边，显然是一个二分图完备匹配。

然后显然直接跑 MCMF 是会寄掉的。

不妨来想一想怎么让费用流模型帮我们“自动”计算费用。

因为绕着一个环的那个绝对值的最小值相当于最短路，所以我们可以对于每个桌子，连一条边 $(i,(i+1)\bmod n,n)$（最坏有 $n$ 个节点会经过这条边）

然后在桌子与桌子之间连边。

具体地

对于 $nm$ 个位置，每个位置连每张桌子上对应的位置

每个桌子内部有 $2m$ 条边。

节点数量是 $2nm+2$，边数量是 $n^2m+2nm$。

也许是可以跑过去的。（$6002$ 个点和 $900600$ 条边）

而且还有分层，边权也很有规律。。。

需要注意的是此图存在负环，需要处理一下细节。

好像数据有点儿水，直接跑就能过（

以及不知道为什么要把前向星换成 vector 才能过。

听说正解是把这个建图在连 $[L,R]$ 的时候用线段树优化建图。（好像是说不这样的话不写 zkw 费用流过不去）
```cpp
#pragma GCC optimize(2)
#pragma GCC optimize(3)
#pragma GCC optimize("no-stack-protector")
#pragma GCC optimize("-funroll-loops","-fdelete-null-pointer-checks")
#include<cstdio>
#include<vector>
#include<queue>
const int M=305,N=15;
int n,m,s,t,tot,l[M][N],r[M][N],in[M][N],out[M][N];
int d[6005];bool iq[6005],vis[6005];
std::deque<int>q;int flow,ret;
inline int min(const int&a,const int&b){return a>b?b:a;}
inline int abs(const int&a){return a>0?a:-a;}
struct Edge{
	int v,w,flow,id;
};std::vector<Edge>G[6005];
inline void Add(const int&u,const int&v,const int&flow,const int&w){
	G[u].push_back((Edge){v,w,flow,G[v].size()});
	G[v].push_back((Edge){u,-w,0,G[u].size()-1});
}
inline bool BFS(){
	for(int i=s;i<=t;++i)d[i]=0x7fffffff,vis[i]=false;d[s]=0;q.push_back(s);
	while(!q.empty()){
		const int u=q.front();int v;iq[u]=false;q.pop_front();
		for(Edge&E:G[u])if(E.flow){
			const int&w=d[u]+E.w;
			if(w<d[v=E.v]){
				d[v]=w;if(iq[v])continue;iq[v]=true;
				if(!q.empty()&&d[v]<d[q.front()])q.push_front(v);else q.push_back(v);
			}
		}
	}
	return d[t]!=0x7fffffff;
}
inline int DFS(const int&u,const int&flow){
	if(u==t)return flow;
	int v,ret(flow);vis[u]=true;
	for(Edge&E:G[u])if(d[v=E.v]==d[u]+E.w&&E.flow&&!vis[v]){
		const int&F=DFS(v,min(ret,E.flow));if(!F)d[v]=-0x7fffffff;E.flow-=F;G[v][E.id].flow+=F;ret-=F;
		if(!ret)return flow;
	}
	return flow-ret;
}
inline void Dinic(){
	while(BFS())while(const int&F=DFS(s,n*m))ret+=F*d[t],flow+=F;
	if(flow!=n*m)printf("no solution");else printf("%d",ret);
}
signed main(){
	scanf("%d%d",&n,&m);
	s=++tot;for(int i=1;i<=n;++i)for(int j=1;j<=m;++j)scanf("%d",l[i]+j),++l[i][j],in[i][j]=++tot;
	for(int i=1;i<=n;++i)for(int j=1;j<=m;++j)scanf("%d",r[i]+j),++r[i][j],out[i][j]=++tot;t=++tot;
	for(int i=1;i<=n;++i)for(int j=1;j<=m;++j){
		Add(s,in[i][j],1,0);Add(out[i][j],t,1,0);Add(out[i][j],out[i][j%m+1],m,1);Add(out[i][j%m+1],out[i][j],m,1);
		for(int k=l[i][j];k<=r[i][j];++k)Add(in[i][j],out[k][j],1,abs(i-k)<<1);
	}
	Dinic();
}
```

---

## 作者：yanchengzhi (赞：1)

## [THUSCH 2017 换桌](https://www.luogu.com.cn/problem/P7452)（费用流，线段树优化建图）

二分图带权匹配，可以用费用流解决。

首先有个很明显的连边方式，每个人向能去的座位连边，边数是 $\mathcal{O}(n^2m^2)$ 的，很明显不行。

考虑优化一下建图方式。

可以把**桌子编号**的移动和**位置编号**的移动**分开考虑**。

建立 $nm$ 个中转点，一侧的边表示桌子编号的移动，一侧的边表示位置编号的移动，这样边数就可以优化到 $\mathcal{O}(nm(n+m))$。

然后发现桌子编号的移动是一段区间，因此可以使用**线段树优化建图**，这样边数可以优化到 $\mathcal{O}(nm(\log n+m))$。有一个细节是绝对值的处理，这可以用两次线段树优化建图解决。

考虑继续优化，发现位置编号的移动可以连成一个环的形式，这样就可以把边数优化到 $\mathcal{O}(nm\log n)$。

```c++
#include <bits/stdc++.h>
typedef long long ll;
const int inf = 1e9;
namespace MCMF {
	const int maxN = 1e5;
	const int maxM = 1e6;
	int S, T, n, tot, maxflow, mincost;
	int head[maxN], now[maxN], dis[maxN];
	bool vis[maxN];
	struct edge {
		int to, nxt;
		int f, c;
	} e[maxM];
	void add(int u, int v, int f, int c) {
		e[++tot].to = v;
		e[tot].nxt = head[u];
		e[tot].f = f;
		e[tot].c = c;
		head[u] = tot;
	}
	void add2(int u, int v, int f, int c) {
		add(u, v, f, c);
		add(v, u, 0, -c);
	}
	bool spfa() {
		for(int i = 1; i <= n; i++) {
			dis[i] = inf;
			vis[i] = 0;
		}
		std::deque<int> q;
		q.push_back(S);
		dis[S] = 0;
		vis[S] = 1;
		while(!q.empty()) {
			int u = q.front();
			q.pop_front();
			vis[u] = 0;
			for(int i = head[u]; i; i = e[i].nxt) {
				int v = e[i].to, f = e[i].f, c = e[i].c;
				if(f && dis[u] + c < dis[v]) {
					dis[v] = dis[u] + c;
					if(!vis[v]) {
						if(!q.empty() && dis[v] < dis[q.front()]) {
							q.push_front(v);
						}
						else {
							q.push_back(v);
						}
						vis[v] = 1;
					}
				}
			}
		}
		return dis[T] < inf;
	}
	int dfs(int u, int flow) {
	    if(u == T) {
	    	return flow;
		}
	    int res = 0;
	    vis[u] = 1;
	    for(int &i = now[u]; i; i = e[i].nxt) {
	        int v = e[i].to, c = e[i].c, f = e[i].f;
			if(dis[v] == dis[u] + c && f && !vis[v]) {
				int t = dfs(v, std::min(flow, f));
				if(t) {
					flow -= t;
					res += t;
					mincost += t * c;
					e[i].f -= t;
					e[i ^ 1].f += t;
				}
				else {
					dis[v] = -inf;
				}
				if(!flow) {
					break;
				}
			}
	    }
	    vis[u] = 0;
	    return res;
	}
	void mcmf() {
	    while(spfa()) {
	    	for(int i = 1; i <= n; i++) {
	    		vis[i] = 0;
	    		now[i] = head[i];
			}
			maxflow += dfs(S, inf);
	    }
	}
	void init(int x) {
		n = x;
		S = n - 1;
		T = n;
		tot = 1;
		for(int i = 1; i <= n; i++) {
			head[i] = 0;
		}
	}
}
using MCMF::S;
using MCMF::T;
using MCMF::add2;
using MCMF::maxflow;
using MCMF::mincost;
using namespace std;
const int maxn = 305;
int n, m, cnt, l[maxn][maxn], r[maxn][maxn];
int id(int x, int y) {
	return (x - 1) * m + y;
}
#define lc (x << 1)
#define rc (x << 1 | 1)
#define mid ((l + r) >> 1)
struct SGT {
	int num[maxn * 4], leaf[maxn];
	void build_pre(int x, int l, int r) {
		num[x] = ++cnt;
		if(l == r) {
			leaf[l] = cnt;
			return;
		}
		build_pre(lc, l, mid);
		build_pre(rc, mid + 1, r);
	}
	void build(int x, int l, int r) {
		if(l == r) {
			return;
		}
		add2(num[x], num[lc], inf, 0);
		add2(num[x], num[rc], inf, 0);
		build(lc, l, mid);
		build(rc, mid + 1, r);
	}
	void link(int x, int l, int r, int L, int R, int u, int f, int c) {
		if(L > R || l > R || r < L) {
			return;
		}
		if(l >= L && r <= R) {
			add2(u, num[x], f, c);
			return;
		}
		link(lc, l, mid, L, R, u, f, c);
		link(rc, mid + 1, r, L, R, u, f, c);
	}
} A[11], B[11];
#undef lc
#undef rc
#undef mid
int main() {
	ios::sync_with_stdio(0);
	cin.tie(0);
	cin >> n >> m;
	for(int i = 1; i <= n; i++) {
		for(int j = 1; j <= m; j++) {
			cin >> l[i][j];
			l[i][j]++;
		}
	}
	for(int i = 1; i <= n; i++) {
		for(int j = 1; j <= m; j++) {
			cin >> r[i][j];
			r[i][j]++;
		}
	}
	/*
	O(nm(m + log n))
	cnt = n * m * 3;
	for(int i = 1; i <= m; i++) {
		A[i].build_pre(1, 1, n);
		B[i].build_pre(1, 1, n);
	}
	MCMF::init(cnt + 2);
	for(int i = 1; i <= m; i++) {
		A[i].build(1, 1, n);
		B[i].build(1, 1, n);
	}
	for(int i = 1; i <= n * m; i++) {
		add2(S, i, 1, 0);
		add2(i, i + n * m, 1, 0);
		add2(i + n * m * 2, T, 1, 0);
	}
	for(int i = 1; i <= n; i++) {
		for(int j = 1; j <= m; j++) {
			for(int k = 1; k <= m; k++) {
				add2(A[j].leaf[i], id(i, k) + n * m * 2, inf, min(abs(j - k), m - abs(j - k)) + i * 2);
				add2(B[j].leaf[i], id(i, k) + n * m * 2, inf, min(abs(j - k), m - abs(j - k)) - i * 2);
			}
			if(l[i][j] >= i) {
				A[j].link(1, 1, n, l[i][j], r[i][j], id(i, j) + n * m, 1, -i * 2);
			}
			else if(r[i][j] <= i) {
				B[j].link(1, 1, n, l[i][j], r[i][j], id(i, j) + n * m, 1, i * 2);
			}
			else {
				A[j].link(1, 1, n, i, r[i][j], id(i, j) + n * m, 1, -i * 2);
				B[j].link(1, 1, n, l[i][j], i - 1, id(i, j) + n * m, 1, i * 2);
			}
		}
	}
	*/
	// O(nm log n)
	cnt = n * m * 2;
	for(int i = 1; i <= m; i++) {
		A[i].build_pre(1, 1, n);
		B[i].build_pre(1, 1, n);
	}
	MCMF::init(cnt + 2);
	for(int i = 1; i <= m; i++) {
		A[i].build(1, 1, n);
		B[i].build(1, 1, n);
	}
	for(int i = 1; i <= n * m; i++) {
		add2(S, i, 1, 0);
		add2(i + n * m, T, 1, 0);
	}
	for(int i = 1; i <= n; i++) {
		for(int j = 1; j <= m; j++) {
			int L = j - 1 > 0 ? j - 1 : m, R = j + 1 <= m ? j + 1 : 1;
			add2(A[j].leaf[i], A[L].leaf[i], inf, 1);
			add2(A[j].leaf[i], A[R].leaf[i], inf, 1);
			add2(B[j].leaf[i], B[L].leaf[i], inf, 1);
			add2(B[j].leaf[i], B[R].leaf[i], inf, 1);
			add2(A[j].leaf[i], id(i, j) + n * m, inf, i * 2);
			add2(B[j].leaf[i], id(i, j) + n * m, inf, -i * 2);
			if(l[i][j] >= i) {
				A[j].link(1, 1, n, l[i][j], r[i][j], id(i, j), 1, -i * 2);
			}
			else if(r[i][j] <= i) {
				B[j].link(1, 1, n, l[i][j], r[i][j], id(i, j), 1, i * 2);
			}
			else {
				A[j].link(1, 1, n, i, r[i][j], id(i, j), 1, -i * 2);
				B[j].link(1, 1, n, l[i][j], i - 1, id(i, j), 1, i * 2);
			}
		}
	}
	MCMF::mcmf();
	if(maxflow < n * m) {
		cout << "no solution\n";
	}
	else {
		cout << mincost << '\n';
	}
	return 0;
}
```

---


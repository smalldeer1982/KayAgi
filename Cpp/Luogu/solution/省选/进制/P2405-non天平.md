# non天平

## 题目背景

non 最近正在为自己的体重而苦恼，他想称量自己的体重。于是，他找来一个天平与许多砝码。

## 题目描述

砝码的重量均是 $n$ 的幂次，$n^1, n^2, n^3, n^4, n^5$ 的……non 想知道至少要多少个砝码才可以称出他的重量 $m$。注意砝码可以放左边，也可以放右边。

## 说明/提示

### 数据范围及约定

对于 $30\%$ 的数据点，$m \le 2^{63}-1$。

对于 $100\%$ 的数据点，$0 \le m \le 10^{10000}$，$0<n \le 10000$。

## 样例 #1

### 输入

```
99
10
```

### 输出

```
2```

# 题解

## 作者：PanH (赞：10)

 我来~~水题解~~提供另一种转移方程。
 
 设 $f[i]$ 为前 $i$ 位（从高到低）全部解决的最小使用砝码数量。
 
 $$f[i]=\min(f[i-1]+a[i],f[j]+(n-1)\cdot(i-j)+2-\sum_{k=j+1}^{i}a[k])$$
 
 意思是先枚举每一位，再枚举有多少进位，这些位置一起进位时对答案的贡献就是 $(n-1)\cdot(i-j)+2-\sum_{k=j+1}^{i}a[k]$ 。
 
 计算前缀和后是 $O(n^2)$ 的，虽然也可以过（高精可能才是复杂度瓶颈），但显然可以优化成 $O(n)$ 。
 
 把柿子拎出来：
 $$f[i]=f[j]+(n-1)\cdot(i-j)+2-sum[i]+sum[j]$$
 拆，移：
 $$f[i]-n\cdot i+i+sum[i]=f[j]-n\cdot j+j+sum[j]+2$$
 
 发现我们在计算的时候维护一个最小的 $f[j]-n\cdot j+j+sum[j]$ 就彳亍了。
 
~~高精部分我就不讲了吧，别的题解好像挺清楚的~~。。。
 
 code：
 ```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
char s[100005];
int n,a[5000005],f[5000005],sum[5000005],tot;
signed main()
{
	scanf("%s%lld",s+1,&n);
	if(n==1)
	{
		printf("%s",s+1);
		return 0;
	}
	int m=strlen(s+1);
	for(int j=1;j<=m;j++)
	{
		int p=0;
		for(int i=1;i<=tot;i++)
			a[i]=a[i]*10+p,p=a[i]/n,a[i]%=n;
		while(p)	a[++tot]=p%n,p/=n;
		p=s[j]-'0';
		for(int i=1;i<=tot;i++)
		{
			a[i]+=p,p=a[i]/n,a[i]%=n;
			if(!p)	break;
		}
		while(p)	a[++tot]=p%n,p/=n;
	}
	for(int i=1;i<=tot;i++)	sum[i]=sum[i-1]+a[i];
	for(int i=1,minn=0;i<=tot;i++)
	{
		f[i]=f[i-1]+min(a[i],n-a[i]+1);
		f[i]=min(f[i],minn+n*i-i-sum[i]+2);
		minn=min(minn,f[i]-n*i+i+sum[i]);
//		for(int j=0;j<i;j++) //O(n^2)
//			f[i]=min(f[i],f[j]+n*(i-j)-sum[i]+sum[j]-i+j+2);
	}
	printf("%lld",f[tot]);
	return 0;
}
```


---

## 作者：_Lemon_ (赞：8)

看见没有C++版的，就顺便发一下自己的代码了

特别注意DP的初始条件，然后当前一位进位后一位要加一

详细情况请看楼下巨佬的讲解吧，我的思路和那位一样的

先把M转成N进制，然后一位一位处理就行了。

```cpp
#include<iostream>
#include<cstdlib>
#include<cstdio>
#include<cstring>
using namespace std;
char cl[10005];
int head,ym[10005],m[10005],n,h[10005],laji[10005];
int ln,lm,tail,f[500005][2];
void deal()//转N进制。
{
 int i;
 while(1)
 {
      int u=0;
      tail=-1;
      int yu=0;
    for(i=0;i<lm;i++)
    {
          tail++;
        u=yu*10+m[i];
          h[tail]=u/n;
          yu=u%n;
    }
      head++;
      ym[head]=yu;
    for(i=0;i<lm;i++)
      if(h[i]!=0) break;
    for(int j=i;j<lm;j++)
      m[j-i]=h[j];
    lm-=i;
    if(lm<=ln) { 
                 int po=0;
                 for(i=0;i<lm;i++)
                    po=po*10+m[i];
                 head++;
                 ym[head]=po%n;
                 po=po/n;
                 head++;
                 ym[head]=po;
                 break;
               }
    }
}
int main()
{
   cin>>cl;
   lm=strlen(cl);
   cin>>n;
   if(n==1) cout<<cl;
   else 
   {
    for(int i=0;i<lm;i++)
      m[i]=cl[i]-'0'; 
    deal();
    int ans=0;
    f[0][1]=1;
    for(int i=1;i<head;i++)
     {
         f[i][0]=min(f[i-1][0]+ym[i],f[i-1][1]+ym[i]+1);
         f[i][1]=min(f[i-1][0]+n-ym[i],f[i-1][1]+n-ym[i]-1);
     }
    cout<<min(f[head-1][0],f[head-1][1]);
    }
    return 0;
}
```

---

## 作者：浅色调 (赞：7)

###**高精进制转换，先转换为N进制，从低位到高位使用动归or贪心。**###

思路：和楼下pascal党的思路差不多，对于题目中的范围超大的m，势必用到高精度，然后对于底数n，我们考虑将m转换成n进制，这样的好处是对于第i位，我们很容易知道要达到前i位的质量所需要的最少是多少(因为只有3种情况)，即要么是由i-1位进位而来，要么是由上一位不进位只取i的值，要么是取i+1位的值+1(相当于进位)而其它值不取。。。说的不太清楚，可以看一下楼下别人的思路。。。用f[i][0]表示第i位没有进位，f[i][1]表示第i位存在进位(或不取)。这样便能得到状态转移方程：

**f[i][0]=min(f[i+1][0]+p[i],f[i+1][1]+n-p[i]);**

**f[i][1]=min(f[i+1][0]+p[i]+1,f[i+1][1]+n-p[i]-1);**

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<string>
#include<cmath>
#include<queue>
#include<map>
using namespace std;
#define ll long long
#define il inline
ll len,i,n,s[100005],f[100005][2],t[100005],ans,p[100005],cnt;
il ll getmod()
{
  ll i,x=0;
  for(i=1;i<=len;i++)
  {
    x=x*10+s[i];
    x%=n;
  }
  return x;
}
il void div()
{
  ll i,o=0,x=0,flag=0;
  memset(t,0,sizeof(t));
  for(i=1;i<=len;i++)
  {
    x=x*10+s[i];
    if(x>=n)flag=1;
    if(flag==1)
    t[++o]=x/n;
    x%=n;
  }
  len=o;
  memcpy(s,t,sizeof(s));
  return;
}
int main()
{
    freopen("balance.in","r",stdin);
    freopen("balance.out","w",stdout);
    char ch=getchar();
      while(ch<'0'||ch>'9')ch=getchar();
      while(ch>='0'&&ch<='9')
      {
        s[++len]=ch-'0';
        ch=getchar();
      }
    scanf("%lld",&n);
    if(n==1){for(i=1;i<=len;i++)printf("%lld",s[i]);return 0;}
      while(len)
      {
            p[++cnt]=getmod();
            ans+=p[cnt];
            div();
      }
      f[cnt+1][1]=1;
      for(i=cnt;i>=1;i--)
      {
            f[i][0]=min(f[i+1][0]+p[i],f[i+1][1]+n-p[i]);
            f[i][1]=min(f[i+1][0]+p[i]+1,f[i+1][1]+n-p[i]-1);
      }
      cout<<min(ans,f[1][0])<<endl;
    return 0;
}

```

---

## 作者：凯特琳 (赞：6)

non的天平:高精除+DP

DP。。

non最近正在为自己的体重而苦恼，他想称量自己的体重。于是，他找来一个天平与许多砝码。

题目描述 Description

砝码的重量均是n的幂次，n^0、n^1、n^2、n^3、n^4、n^5的……non想知道至少要多少个砝码才可以称出他的重量m。注意砝码可以放左边，也可以放右边。

输入输出格式 Input/output

输入格式：

第一行一个正整数m，表示non的重量；

第二行一个正整数n，表示砝码重量幂次的底；

输出格式：

一个整数表示最少所需的砝码数。

输入输出样例 Sample input/output

样例测试点#1

输入样例： 在线IDE

99
10
输出样例：

2
说明 description

【数据范围】

对于30%的数据点，m <= 2^63 - 1

对于100%的数据点，0 <= m <= 10^10000, 0 < n <= 10000




分析：对于本题的数据范围，势必要高精了。

首先说明白一点：天平使用原则：左物右码。

那么题目可以等效成这样：右边的质量-左边的质量=给出的质量，所以砝码就有了加减两个策略可以选择

我们先来看题目的样例：99

99的得出有两种大的方向：加策略 和 减策略

首先加策略的话，需要9\*10+9\*1  ->18个

其次减策略的话，需要1\*100-1\*1  ->2个

样例减策略要优于加策略。


原题目也就等价于这样一个等式

k0\*10^0+k1\*10^1+k2\*10^2+k3\*10^3=99 这里我们假设左边就三项把  方便研究

k的系数可正可负，正就是放在右边，负就是放在左边。

那么我们要求∑|k|最小，可以这样想：
我们先考虑最小的质量是1的砝码，我们要确定使用了几个1砝码，那么我们就要把个位的9补平，要么是10-1，需要一个； 要么是0+9，需要9个；

显然减一下好，而且减掉一个刚好。于是我们确定了上述方程的第一项系数k0= -1

那么方程就是这样：-1\*10^0+k1\*10^1+k2\*10^2+k3\*10^3=99

把第一项移到右边：k1\*10^1+k2\*10^2+k3\*10^3=100

我们看到我们成功的把个位填平了，使得方程可以同除以10

那么就变成了k1\*10^0+k2\*10^1+k3\*10^2=10

于是到这里我们看到了问题具有很强的  最优子结构性质。


而无后效性是显然的，我们确定了小法吗的个数后，右边的个位被填平，所以我们不在需要小法吗

于是问题就是一道DP问题。

而这个m是一个高精数，在说我们的n=10是很特殊的，对于其他的n我们 要进行很多的 m div n 和m mod n操作

于是我们整体的预处理一下，

把m进行n进制的分解

不断的把 计算m mod n这个余数，记录，再把m div n，把m除干净为止；

于是我们得到了n进制下的 每一位上的数字，对应于我们每一个数量级的砝码

对于每一位我们有两个策略，直接使用yu【i】这么多的砝码，或者用n-yu【i】这么多的砝码进上去，两种操作都可以使n进制下的个位变成0

于是我们发现他其实是0/1 DP 也就是说我们开一个数组f【0..m,0..1】，前一维意思是处理到n进制下的第i位，后一维意思是我们当前这一位的处理策略 0代表直接拿出yu【i】这么多的砝码，1代表我们把当前位补平，进到下一位去

数组元素存储处理完当前第i位需要的砝码数

于是状态转移方程：

f[i,0]:=min(f[i-1,0]+yu[i],f[i-1,1]+yu[i]+1);

f[i,1]:=min(f[i-1,0]+b-yu[i],f[i-1,1]+b-yu[i]-1);

写状态转移方程的时候仔细一点就不会错：使用f【i-1，1】的时候，我们当前位就+1


AC代码：

```delphi

program exam1;
var ans,k,j,b,d,num:int64;
var i,ii:longint;
var a:array[0..10000]of integer;//高精度原数组
var yu:array[1..100000]of longint;//余数数组，也就是n进制下的位数组
var f:array[0..10000,0..1]of longint;//DP数组
ss:ansistring;

function min(aa,bb:longint):longint;//DP最小值函数
begin
if aa>bb then exit(bb)
else exit(aa);
end;

procedure devide;//高精除法，记录下余数的同时，把商数组在重新赋给a数组，继续做高精除
  {c:=a div b; d:= a mod b}
  var ix,len:integer;
  var c:array[0..10000]of integer;//商数组
  begin
    fillchar(c,sizeof(c),0);
    len:=a[0]; d:=0;
    for ix:=len downto 1 do begin
      d:=d*10+a[ix];
      c[ix]:=d div b;
      d:=d mod b;
    end;//高精除法结束

    while (len>=1) and (c[len]=0) do dec(len);
    c[0]:=len;//位数处理
    fillchar(a,sizeof(a),0);
    for ix:=0 to c[0] do
    a[ix]:=c[ix];//a数组重赋值为c  等价于a:=a div b;

    inc(num);
    yu[num]:=d;//得到余数
  end;

procedure print;//特质判断输出，因为有个巨坑无比的点b=1，只有1这一种砝码。把质量数原样输出就对
var i:longint;
begin
for i:=a[0] downto 1 do
write(a[i]);
end;

begin
readln(ss);
readln(b);
a[0]:=length(ss);
for i:=1 to a[0] do
a[a[0]-i+1]:=ord(ss[i])-48;//高精读入
 
if b=1 then//特判
begin
print;
halt;
end;

repeat//处理成n进制
devide;
until a[0]=0;//直到原数除空了


f[0,0]:=0;f[0,1]:=1;//赋初值，为什么f[0,1]:=1呢 看下面红色的 为了让f[1,0]和f[0,0]的值正常等于yu[1]和n-yu[1]；
for i:=1 to num do//num位n进制位
begin
f[i,0]:=min(f[i-1,0]+yu[i],f[i-1,1]+yu[i]+1);//如果前一位不进到这一位，那么0的DP直接加上yu[i]，如果前一位进上来了，就多+1
f[i,1]:=min(f[i-1,0]+b-yu[i],f[i-1,1]+b-yu[i]-1);//若前一位不进，1的DP加上补足数n-yu[i]，若前一位进上来了，补足数就是n-(yu[i]+1)
end;
writeln(min(f[num,0],f[num,1]+1));//注意输出的时候f[num，0]的意义是最高位是直接给出这么多的砝码；
end.                          而f[num,1]的意义是最高位是补平的，而如果最高位是补平进到下一位这样处理，就额外需要更高位砝码x1

```


至此，我们发现有效代码就这么几行。

我都惊呆了！只有60+行！！

而这面的想法是很多的。

精彩的 高精+数论+DP

最精髓的在于进制转换和 0/1 DP 的部分

好吧，也就这两部分了



---


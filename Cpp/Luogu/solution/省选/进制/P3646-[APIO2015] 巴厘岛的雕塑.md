# [APIO2015] 巴厘岛的雕塑

## 题目描述

印尼巴厘岛的公路上有许多的雕塑,我们来关注它的一条主干道。

在这条主干道上一共有 $N$ 座雕塑，为方便起见，我们把这些雕塑从 $1$ 到 $N$ 连续地进行标号，其中第 $i$ 座雕塑的年龄是 $Y_i$ 年。为了使这条路的环境更加优美，政府想把这些雕塑分成若干组，并通过在组与组之间种上一些树，来吸引更多的游客来巴厘岛。

下面是将雕塑分组的规则：

这些雕塑必须被分为恰好 $X$ 组，其中 $A \leq X \leq B$，每组必须含有至少一个雕塑，每个雕塑也必须属于且只属于一个组。同一组中的所有雕塑必须位于这条路的连续一段上。

当雕塑被分好组后，对于每个组，我们首先计算出该组所有雕塑的年龄和。

计算所有年龄和按位取或的结果。我们这个值把称为这一分组的最终优美度。

请问政府能得到的最小的最终优美度是多少?

备注：将两个非负数 $P$ 和 $Q$ 按位取或是这样进行计算的：

首先把 $P$ 和 $Q$ 转换成二进制。

设 $n_P$ 是 $P$ 的二进制位数，$n_Q$ 是 $Q$ 的二进制位数，$M$ 为 $n_P$ 和 $n_Q$ 中的最大值。$P$ 的二进制表示为 $p_{M-1}p_{M-2} \dots p_1p_0$，$Q$ 的二进制表示为 $q_{M-1}q_{M-2} \dots q_1 q_0$，其中 $p_i$ 和 $q_i$ 分别是 $P$ 和 $Q$ 二进制表示下的第 $i$ 位，第 $M -1$ 位是数的最高位，第 $0$ 位是数的最低位。

$P$ 与 $Q$ 按位取或后的结果是： $(p_{M-1}\mathbin{\mathrm{OR}} q_{M-1})(p_{M-2}\mathbin{\mathrm{OR}}q_{M-2})\dots (p_1\mathbin{\mathrm{OR}} q_1) (p_0\mathbin{\mathrm{OR}}q_0)$。其中：$0 \mathbin{\mathrm{OR}} 0 = 0$

$0 \mathbin{\mathrm{OR}} 1 = 1$

$1 \mathbin{\mathrm{OR}} 0 = 1$

$1 \mathbin{\mathrm{OR}} 1 = 1$


## 说明/提示

【样例解释】

将这些雕塑分为 $2$ 组，$(8, 1, 2)$ 和 $(1, 5, 4)$，它们的和是 $(11)$ 和 $(10)$，最终优美度是 $(11 \mathbin{\mathrm{OR}} 10) = 11$。（不难验证，这也是最终优美度的最小值。）

【数据范围】

子任务 1 （9 分）$1 \leq N \leq 20$

$1 \leq A \leq B \leq N$

$0 \leq Y_i \leq 1000000000$


子任务 2 （16 分）$1 \leq N \leq 50$

$1 \leq A \leq B \leq \min\{20, N\}$

$0 \leq Y_i \leq 10$


子任务 3 （21 分）$1 ≤ N ≤ 100$

$A = 1$

$1 \leq B \leq N$

$0 \leq Y_i \leq 20$


子任务 4 （25 分）$1 \leq N \leq 100$

$1 \leq A \leq B \leq N$

$0 \leq Y_i \leq 1000000000$


子任务 5 （29 分）$1 \leq N \leq 2000$

$A = 1$

$1 \leq B \leq N$

$0 \leq Y_i \leq 1000000000$


## 样例 #1

### 输入

```
6 1 3
8 1 2 1 5 4```

### 输出

```
11
```

# 题解

## 作者：打脸不疼 (赞：17)

# 本蒟蒻第一次水题解
### 希望管理员大大给过
今天刚好考了这题， 在考场上写了个朴素的DP，结果数据太水，得了80分，知道洛谷上有这题， 来试水，结果出乎意料，错误的DP竟然有90分（haha）， 下面是丑陋的代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read(){
	int x = 0, f = 1; char ch = getchar();
	while(!isdigit(ch)) (ch == '-') && (f = -1), ch = getchar();
	while(isdigit(ch)) x = (x << 1) + (x << 3) + (ch ^ 48), ch = getchar();
	return x * f;
}
#define N 2005
#define ll long long
#define reg register
int n, A, B;
ll f[N][N];
ll ans = 0, res = 0;
int main(){
	//freopen("sculpture.in", "r", stdin);
	//freopen("sculpture.out", "w", stdout);
	n = read(), A = read(), B = read();
	for(reg int i = 0; i <= n; i++){
		for(reg int j = 0; j <= B; j++)
			f[i][j] = 9999999999999;
	}
	f[0][1] = 0;
	for(reg int i = 1; i <= n; i++)
		f[i][1] = (ll)(read() + f[i - 1][1]);
	for(reg int i = 1; i <= n; i++)
		for(reg int k = 2; k <= min(i, B); k++)
			for(reg int j = i - 1; j >= 1; j--)
				if(f[i][1] - f[j][1] > f[i][k])break;//玄学剪枝，O(n^3) 超时不存在的 
				else f[i][k] = min(f[i][k], f[j][k - 1] | (f[i][1] - f[j][1]));
	ll ans = 9999999999999;
	for(reg int i = A; i <= B; i++){
		ans = min(f[n][i], ans);
	}
	printf("%lld", ans);
	return 0;
}
```
为什么错？ 因为前一个分段的最小优美值与后一个分段的值或运算起来不一定是最小的答案，这个可以自己思考一下。

那咋搞， 本蒟蒻自己当然想不出。听大佬说是数位DP，本蒟蒻当然不会，自己马上查了资料，借鉴Cao某的代码和Only_xiaohuang的解释，终于打出了这题，自己想的成分（0%）；
## 正片
所谓数位DP就是逐个数位考虑，一般运用于二进制运算这样的题。不太懂得自行百度。

先看到这个题，很显然我们要找到一个解使得二进制高位上的数为0。我们就可以从高位到低位逐位考虑这一位是否为0的情况。我们令分bool f[i][j] 前i个数分成j段的当前数位能否为0，能为0则为true， 不能则为false；
那么我们每枚举一个数位就要DP一次，第一层循环代码如下
```cpp
#define ll long long
#define N 2005
bool f[N][N];
ll solve1(){
	ll ans = 0, res = 0;
	int maxn = log2(sum) + 1;//sum为每一个Y的和，这是确定枚举的最高位
	for(int i = maxn; i >= 0; i--){
		res = ans | ((1LL << i) - 1LL);
		memset(f, false, sizeof(f));//每次枚举都要清空
		f[0][0] = true;//初始值
        .
        .
        .
        bool flag = false;
		for(int j = A; j <= B; j++){//枚举分A到B段的所有情况
			if(f[n][j]){
				flag = true;
				break;
			}
		}
		if(!flag)ans |= (1LL << i);//不可以放0则只能放1
	}
    return ans;
}
```
那么res，ans分别是什么呢？
ans比较好理解，假如当前枚举的数位不能放0，那就把ans二进制下的第i位改为1，最后得到的ans值就是最后的答案。
那么res呢，这里是仿照Cao某的方法，假如ans（二进制） = 1101 0000，枚举到第四位，那么res = 1101 0111，也就是把第四位扣下来，再把后面每一位附为1，这里就是假设这一位为0，这样做是为了下面的状态转移。
那么最重要的来了，f数组的状态转移：
```cpp
for(int j = 1; j <= n; j++){//枚举第几个数
	for(int k = 1; k <= min(j, B); k++){//分段数
		ll s = 0;
		for(int t = j - 1; t >= k - 1; t--){//枚举分段位置
			s += d[t + 1];//s表示t+1~j的Y的和
			if(f[t][k - 1] && ((s | res) == res)){
				f[j][k] = true;
				break;
			}
		}
	}
}
```
为什么(f[t][k - 1] && ((s | res) == res))成立，则f[j][k]便可以为真？；
(s | res) == res 表示s二进制上的每一个1的位置，在res上也为1，那么当前面一段的值 或 上s时并不会影响之前的答案，且当前枚举的数位上可以为0，那么只要f[t][k - 1],也就是1~t中分k - 1段这一位上可以为0，那么f[j][k]的这一位上也能为0；
那就很简单了，完整代码如下
```cpp
#define ll long long
#define N 2005
bool f[N][N];
ll solve1(){
	ll ans = 0, res = 0;
	int maxn = log2(sum) + 1;//sum为每一个Y的和，这是确定枚举的最高位
	for(int i = maxn; i >= 0; i--){
		res = ans | ((1LL << i) - 1LL);
		memset(f, false, sizeof(f));//每次枚举都要清空
		f[0][0] = true;//初始值
        for(int j = 1; j <= n; j++){//枚举第几个数
            for(int k = 1; k <= min(j, B); k++){//分段数
                ll s = 0;
                for(int t = j - 1; t >= k - 1; t--){//枚举分段位置
                    s += d[t + 1];//s表示t+1~j的Y的和
                    if(f[t][k - 1] && ((s | res) == res)){
                        f[j][k] = true;
                        break;
                    }
                }
            }
        }
        bool flag = false;
		for(int j = A; j <= B; j++){//枚举分A到B段的所有情况
			if(f[n][j]){
				flag = true;
				break;
			}
		}
		if(!flag)ans |= (1LL << i);//不可以放0则只能放1
	}
    return ans;
}
```
可是这样做只能得80分，原因是太慢了，四个for套在一起不超时才怪。
那怎么办，从数据入手，发现所有的大样例都有特殊性质，A = 1。
前面的代码是因为枚举了分段数，因为要保证正确的解分段数大于等于A， 防止最优解小于A，但A = 1的话就不需要考虑，只需保证最优解小于等于B就行了。
用g数组表示，前j个数分段使得当前数位为0所需的最小分段数， 很容易想到如何转移：
```cpp
if((s | res) == res)
     g[j] = min(g[j], g[k] + 1);
```
完整代码与原函数类似：
```cpp
ll solve2(){
	ll ans = 0, res = 0;
	int maxn = log2(sum) + 1;
	for(int i = maxn; i >= 0; i--){
		res = ans | ((1LL << i) - 1LL);
		memset(g, 127, sizeof(g));
		g[0] = 0;
		for(int j = 1; j <= n; j++){
			ll s = 0;
			for(int k = j - 1; k >= 0; k--){
				s += d[k + 1];
				if((s | res) == res)
					g[j] = min(g[j], g[k] + 1);
			}
		}
		if(g[n] > B) ans |= (1LL << i);//如果得到0的最小分段数大于B，那么这一位只能为1
	}
	return ans;
}
```
这道题就这样完美的解决了；
##### 真完整代码如下
```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read(){
	int x = 0, f = 1; char ch = getchar();
	while(!isdigit(ch)) (ch == '-') && (f = -1), ch = getchar();
	while(isdigit(ch)) x = (x << 1) + (x << 3) + (ch ^ 48), ch = getchar();
	return x * f;
}
#define N 2005
#define ll long long
int n, A, B, g[N];
ll d[N], sum;
bool f[N][N];
ll solve1(){
	ll ans = 0, res = 0;
	int maxn = log2(sum) + 1;//sum为每一个Y的和，这是确定枚举的最高位
	for(int i = maxn; i >= 0; i--){
		res = ans | ((1LL << i) - 1LL);
		memset(f, false, sizeof(f));//每次枚举都要清空
		f[0][0] = true;//初始值
        for(int j = 1; j <= n; j++){//枚举第几个数
            for(int k = 1; k <= min(j, B); k++){//枚举分段数
                ll s = 0;
                for(int t = j - 1; t >= k - 1; t--){//枚举分段位置
                    s += d[t + 1];//s表示t+1~j的Y的和
                    if(f[t][k - 1] && ((s | res) == res)){
                        f[j][k] = true;
                        break;
                    }
                }
            }
        }
        bool flag = false;
		for(int j = A; j <= B; j++){//枚举分A到B段的所有情况
			if(f[n][j]){
				flag = true;
				break;
			}
		}
		if(!flag)ans |= (1LL << i);//不可以放0则只能放1
	}
    return ans;
}
ll solve2(){
	ll ans = 0, res = 0;
	int maxn = log2(sum) + 1;
	for(int i = maxn; i >= 0; i--){
		res = ans | ((1LL << i) - 1LL);
		memset(g, 127, sizeof(g));
		g[0] = 0;
		for(int j = 1; j <= n; j++){
			ll s = 0;
			for(int k = j - 1; k >= 0; k--){
				s += d[k + 1];
				if((s | res) == res)
					g[j] = min(g[j], g[k] + 1);
			}
		}
		if(g[n] > B) ans |= (1LL << i);//如果得到0的最小分段数大于B，那么这一位只能为1
	}
	return ans;
}
int main(){
	//freopen("sculpture.in", "r", stdin);
	//freopen("sculpture.out", "w", stdout);
	n = read(), A = read(), B = read();
	for(int i = 1; i <= n; i++) d[i] = read(), sum += d[i];
	if(A == 1)	printf("%lld", solve2());
	else printf("%lld", solve1());
	return 0;
}

```
祝大家早日AC！！！

---

## 作者：Silent_E (赞：8)


## 【大意】

给定$A$，$B$，使一个区间的元素分为$A\le x\le B$组，每组的贡献为组内元素之和，最小化所有组贡献的或运算和。

## 【分析】

开始一晃眼没看见区间连续这个条件，~~感觉做了假的题~~。。。

思考一个容易想到的$dp$式子，设$f[i][j]$表示前$i$个元素，分为$j$个组的最小化答案，考虑枚举转移点$k$，然后转移。。。。

```cpp
#include <ctime>
#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#define ll long long
using namespace std;
const ll INF = 5e18;
const int MAX = 2000 + 5;
inline ll read() {
    ll res = 0; bool f = 0; char ch = getchar();
    while (ch < '0' || ch > '9') { if (ch == '-') f = 1; ch = getchar(); }
    while (ch <= '9' && ch >= '0') { res = (res << 3) + (res << 1) + ch - '0'; ch = getchar(); }
    return f ? (~ res + 1) : res;
}
ll n, A, B, Y[MAX], sum[MAX], f[MAX][MAX], ans = INF;
int main() {
    n = read(), A = read(), B = read();
    for (int i = 1;i <= n; ++i) 
    for (int j = 0;j <= n; ++j) f[i][j] = INF;
    for (int i = 1;i <= n; ++i) Y[i] = read(), sum[i] = sum[i - 1] + Y[i], f[i][1] = sum[i];
    for (int i = 1;i <= n; ++i) {
        int limit = min((ll)i, B);
        for (int j = 2;j <= limit; ++j) {
            for (int k = 1;k < i; ++k) {
                f[i][j] = min(f[i][j], f[k][j - 1] | (sum[i] - sum[k]));
            }
        }
    }
    for (int i = A;i <= B; ++i) ans = min(ans, f[n][i]);
    printf("%lld", ans);
    return 0;
}
```



去提交。。啊！$75Pt$？？？$TLE$我还可以接受，还有的点$WA$？

仔细思考了一下，发现这个式子并不满足**无后效性**。为什么？你选择前面的使它最小化了，但在或运算下，后面的影响你是不知道的。换句话说，本题中，若按之前的$dp$方程转移，局部最优解并不是全局最优解。

我们需要重新思考。

由**或**这个二进制运算和题目~~明显的~~提示，想到拆分考虑二进制数位，又因为最小化，所以贪心地从最高位开始对每一位进行考虑。

对于每一位$pos$，我们用$f[i][j]$表示用前$i$个元素，分成$j$组，能否使当前位为$0$（因为要最小化嘛）。

枚举转移点$k$，若$f[k][j-1]$为真，且$sum[k+1...i]$在当前$pos$位上是$0$，那么就可以转移过来$f[i][j]=1$。然后累计$ans$。

若存在$f[n][i]=1(A\le i\le B)$那么该位就可以等于$0$。

再仔细思考，我们会发现若直接这样做，有可能会存在着低位的分组与高位的分组发生冲突。显然，我们应保留高位分组的情况，所以说，我们应保留之前已匹配好的位的状态，并且让转移也不能与这个状态发生冲突。

接着来思考子任务$5$。

我们会发现它的数据有特殊性：$A=1$。

怎么特殊？分组没有下限！

那我直接记录最少能用多少组让$pos$位可以填$0$不就行了？

设$g[i]$表示前$i$位最少能分成多少组使当前位$pos$可以填$0$，那么同样的，只要满足转移条件，就有$g[i]=min(g[i],g[k] + 1)$。其中除$g[0]=0$以外，其余$g$均为$INF$。

然后就写了个分段$dp$。

```cpp
#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#define ll long long
#define Re register
using namespace std;
const int MAX = 2000 + 5;
inline ll read() {
    ll res = 0; bool f = 0; char ch = getchar();
    while (ch < '0' || ch > '9') { if (ch == '-') f = 1; ch = getchar(); }
    while (ch <= '9' && ch >= '0') { res = (res << 3) + (res << 1) + ch - '0'; ch = getchar(); }
    return f ? (~ res + 1) : res;
}
ll Y[MAX], sum[MAX], f[MAX][MAX], ans;
int n, A, B, g[MAX];
bool flag;
inline void solution_1() {
    int limit = log2(sum[n]) + 1;
    for (int pos = limit; pos >= 0; --pos) {
        
        ll res = ans | ((1LL << pos) - 1LL);
        memset(g, 127, sizeof g);
        g[0] = 0;
        for (int i = 1;i <= n; ++i) {
            for (int k = 0;k < i; ++k) {
                if (((sum[i] - sum[k]) | res) == res) {
                    g[i] = min(g[i], g[k] + 1);
                }
            }
        }
        
        if (g[n] > B) ans |= (1LL << pos);
    }
}

inline void solution_2() {
    int limit = log2(sum[n]) + 1;
    for (int pos = limit;pos >= 0; --pos) {

        ll res = ans | ((1LL << pos) - 1LL);
        memset(f, 0, sizeof f);
        f[0][0] = 1;
        flag = 0;
        
        for (int i = 1;i <= n; ++i) {
            int up = min(i, (int)B);
            for (int j = 1;j <= up; ++j) {
                for (int k = j - 1;k < i; ++k) {
                    if (f[k][j - 1] && ((sum[i] - sum[k]) | res) == res) {
                        f[i][j] = 1;
                    }
                }
            }
        }
        
        for (int i = A;i <= B; ++i) if (f[n][i]) flag = 1;
        if (!flag) ans |= (1LL << pos);
    }
}

int main() {
    n = read(), A = read(), B = read();
    for (int i = 1;i <= n; ++i) Y[i] = read(), sum[i] = sum[i - 1] + Y[i];
    if (A == 1) solution_1();
    else solution_2();
    printf("%lld", ans);
    return 0;
}
```



---

## 作者：ww3113306 (赞：7)

写了好久。。。。

刚刚调了一个小时各种对拍，，，，最后发现是多写了一个等号，，，，内心拒绝

表示一开始看真的是各种懵逼啊

~~在偷听到某位大佬说的从高位开始贪心后发现可做~~

首先考虑小数据~~（因为可以乱搞）~~

所以先从高位开始枚举位数:

for(int k=all; k ;k--)

ans表示当前答案，f[i][j]表示dp到第i为，分为j段，是否可以满足第k位为0

ans初始为0，每次DP完就修改ans，

所以枚举i和j，然后枚举上一段的结尾l，

由于是or，所以之前已经有的是消不掉的，

于是有    if(!f[l][j-1]) continue;

这样就可以保证之前的都已经满足了，所以只要考虑当前段就好了

sum[i]表示到i的前缀和。

先获取当前段大小now=sum[i] - sum[l]

所以如果now的第k位为0，并且之前的高位都不与当前ans冲突，就可以转移了

因为如果高位与ans冲突，而前面已经最优了，所以如果冲突只能是不那么优，

于是后面再优都补不回来了。**其实这也是从高位贪心的意义所在**

最后如果在f[n][A ~ B]中有任意一个为true的话，ans就不用修改（因为默认已经是0了）

而如果一个都没有，那么就将ans的当前位变成1，

那么考虑如何判断，

首先运算符肯定只能用or，不然是会遗漏信息的（也许可以用其他的吧，但是我没想到）

考虑这样两个二进制串:

now ：101100 1011

ans ： 101100 0000

中间的空格代表把第k位和后面隔开,

通过一些二进制的基本性质（其实也是所有进制的基本性质）可以发现，

如果前面都是相同的话，因为ans的小于k的位数都还不确定，都是0，

所以最大相差也就是2^(k-1),

反之如果前面有冲突，那么由于冲突在前面，相差一定会超过2^(k-1),

所以直接判断now和ans的差就可以了？

**不是！**

因为now是中间过程，所以now是可能小于ans的，

所以如果是这样的情况的话：

now : 10**0**1**1**0 1011

ans : 101100 0000

这样的话now < ans,所以now - ans 一定小于 2^(k-1),-1是因为第k位对应的是2^(k-1),(因为从0次方开始数的)

但是这样是不合法的，之所以这样会被误判为合法，是因为它之前的那个粗体0帮后面的粗体1抵消掉了。

因此为了这样的0不会对真正不合法的1造成干扰，

我们只需要计算(now | ans) - ans < 2^(k-1)是否成立即可，

因为这样的话，所有这样的0都会变为1，于是这时要再有不合法的1出现就无法被抵消了。

于是小数据就解决了，但是考虑到最大的点n <= 2000，这样的复杂度肯定是过不去的

但是观察发现，对于最大的那几个点，满足A == 1,

而之前的f数组之所以要开二维，还要枚举段数，就是因为只有枚举了所有情况才能保证不漏掉A～B之间的答案，

因为段数小不一定更优，不然可能会找到小于A的答案，

但是因为A == 1，就不可能会找到小于A的答案了，这时也满足段数小的一定更优，

所以我们直接令g[i]表示dp到i，使第k位为0的最小段数，

然后转移时判断条件和上面一样即可，注意初始化g[0]=0,其余为极大值

下面放代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define R register int
#define AC 2100
#define getchar() *o++
#define LL long long
char READ[5000100],*o=READ;
int n,A,B,all;
int s[AC],g[AC];
LL sum[AC];//g[i]是适用于没有下限的情况
LL ans;
bool f[AC][250];

inline int read()
{
	int x=0;char c=getchar();
	while(c > '9' || c < '0') c=getchar();
	while(c >= '0' && c <= '9') x=x*10+c-'0',c=getchar();
	return x;
}

void work1()//f[i][j]代表前i位分成j段，第k位能否在保证前k位都不变且不考虑后面all-k位的情况下是否可能与当前ans相同(此时第k位默认为0)
{//这样的话相当于给了一个判断依据ans，于是就可以提高复杂度以解决问题
	LL now;//获取最高位数
	bool done=false;
	all=log2(sum[n]) + 1;
	for(R k=all; k ;k--)//枚举位数(从高位开始贪心)
	{
		memset(f,0,sizeof(f));
		f[0][0]=true;
		done=false;//error!!!每次都要重置
		for(R i=1;i<=n;i++)//枚举到了哪里
		{
			int be=min(i,B);
			for(R j=1;j<=be;j++)//枚举分的段数
			{
				for(R l=j-1;l<i;l++)//枚举上一段的结尾,error!!!上一段啊怎么可以等于。。。。
				{
					if(!f[l][j-1]) continue;//因为是|,所以前面有1不能消掉，所以前面不满足就不能取了
					now=sum[i] - sum[l];//获取区间和
					if(((now | ans) - ans) < (1LL<<(k-1)))//error!!!注意longlong 
					{//如果相差小于当前位，代表不一样的都在后面，就没关系了
						f[i][j]=true;
						break;
					}
				}
				if(i == n)
				{
					if(j >= A && j <= B && f[i][j])
					{
						done=true;
						break;//如果找到了就无需再找了
					}
				}
			}
		}
		if(!done) ans+=1LL<<(k-1);//因为1已经有一位了，所以只要移动k-1位就可以了(其实是因为本来就只要判断2^(k-1),因为第一位对应的是2^0)
	}
	printf("%lld\n",ans);
}
//g[i]代表满足这位为0最少需要的段数
void work2()
{
	LL now;
	all=log2(sum[n]) + 1;
	for(R k=all; k ;k--)
	{
		memset(g,127,sizeof(g));
		g[0]=0;
		for(R i=1;i<=n;i++)//枚举树
		{
			for(R j=0;j<i;j++)//枚举上一段的结尾，，，懒得特判1了,就从0开始吧
			{
				now=sum[i] - sum[j];
				if(((now | ans) - ans) < (1LL<<(k-1))) g[i]=min(g[i],g[j]+1);//error!!!注意longlong 
			}//因为要求最小的,所以就不能跳过了
		}
	 /*   printf("!!!%d:\n",k);
        for(int i=1;i<=n;i++) printf("%d ",g[i]);
        printf("\n");*/
		if(g[n] > B) ans+=1LL<<(k-1);//error!!!貌似在这里也要加LL吧 
	}
	printf("%lld\n",ans);
}

void pre()
{
	n=read(),A=read(),B=read();
	for(R i=1;i<=n;i++) s[i]=read(),sum[i]=sum[i-1] + (LL)s[i];
}

int main()
{
	freopen("in.in","r",stdin);
//	freopen("sculpture.in","r",stdin);
//	freopen("sculpture.out","w",stdout);
	fread(READ,1,5000000,stdin);	
	pre();
	if(A == 1) work2();//特殊点特殊处理
	else work1();
	fclose(stdin);
//	fclose(stdout);
	return 0;
}
```

---

## 作者：elijahqi (赞：6)

一开始第一眼想到dp 但是没想到数位dp 如果朴素的写dp 方程那么我不能保证每次or的最小就能使后面的or小

于是在leoly的介绍下，学习了数位dp

一共这些数加起来是2000\*10^9

我们对于他的每一个二进制位去dp 然后贪心的从最高位开始做

那么前5个子任务 中的四个是100以内的

我们定义方程f[i][j]表示前1~i个间分j组 能否满足条件

这个满足条件的含义很多就是我现在这个数位能否是0

f[i][j]表示1~i分成j个，当前数位可以是0  tmp用来储存我此前已经确定了的最优值，每回做的时候我先认为这个地方可以是0 那么tmp这一位就需要+1 然后每次用位运算去判断能否满足条件

时间复杂度:100^3\*log2(和最大)

那么这种复杂度显然子任务5是做不了的，观察到子任务5  A的范围就是1说明我们只要看满足条件（最优分法）的组数是否超过了B

 
样例的二进制

01000
00001
00010
00001
00101
00100    每次都是一个数位从上往下 注意小细节：如1LL<<  以及可能存在全是0的情况

(http://www.elijahqi.win/2017/09/23/luogu3646-apio2015%e5%b7%b4%e5%8e%98%e5%b2%9b%e7%9a%84%e9%9b%95%e5%a1%91/)  蒟蒻的blog  欢迎前来交流qwq



```cpp
#include<cstdio> 
#include<algorithm>
#include<cstring>
#include<cmath>
#define inf 0x7f7f7f7f
using namespace std;
#define N 2200
inline int read(){
    int x=0,f=1;char ch=getchar();
    while (ch<'0'||ch>'9') {if (ch=='-') f=-1;ch=getchar();}
    while (ch<='9'&&ch>='0'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
int A,B,n,a[N];
long long sum,s[N];
bool f[N][N];int g[N];
void dp1(){
    int kk=log2(sum);long long tmp=0;
    for (int p=1;p<=kk+1;++p){
        memset(f,0,sizeof(f));tmp+=1LL<<kk-p+1;
        for (int i=1;i<=n;++i) if (!(s[i]&tmp)) f[i][1]=1;bool flag=false;
        for (int j=2;j<=B;++j){
            for (int i=j;i<=n;++i){
                for (int k=j-1;k<i;++k){
                    if (!(s[i]-s[k]&tmp)&&f[k][j-1]) f[i][j]=1;//k+1位到结尾 
                }
            }
            if (j>=A&&j<=B) if (!flag&&f[n][j]) flag=true;
        }    
        if (f[n][1]) flag=true;
        if (!flag) tmp-=1LL<<kk-p+1;
    }
    printf("%lld",(1LL<<kk+1)-tmp-1);
}
void dp2(){
    int kk=log2(sum);long long tmp=0;
    for (int p=1;p<=kk+1;++p){
        for (int i=1;i<=n;++i) g[i]=inf;
        tmp+=1LL<<kk-p+1;
        for (int i=1;i<=n;++i){
            for (int j=0;j<i;++j){
                if (!((s[i]-s[j])&tmp)){
                    g[i]=min(g[i],g[j]+1);
                }
            }
        }
        if (g[n]>B) tmp-=1LL<<kk-p+1;
    }
    printf("%lld",(1LL<<kk+1)-tmp-1);
}
int main(){
    freopen("3646.in","r",stdin);
    n=read();A=read();B=read();
    for(int i=1;i<=n;++i) a[i]=read(),sum+=a[i];if (!sum){printf("0");return 0;}
    for (int i=1;i<=n;++i) s[i]=s[i-1]+a[i]; 
    if (A!=1) dp1();else dp2();
    return 0;
}
```

---

## 作者：hl666 (赞：5)

深夜写题解系列，话说这题暑假的时候就在LOJ上做掉了，然后今天看到Luogu上有就去交了一下，发现没写过题解，赶紧来补一下

~~说句题外话APIO2015的题目好水啊~~

首先考虑按位取或的过程，很显然要从二进制位从高到低**贪心**，尽量地让这一位能取$0$，那么就是考虑怎么判断这一位能否取到$0$的过程了

考虑直接设一个状态$f_{i,j}$表示把前$i$个数分成$j$段是否满足条件，最后看一下$f_{n,i}(i\in [A,B])$是否有$1$即可

那么转移也很简单，记录一下前缀和，然后向前枚举一个点转移，那么这段区间和在这一位上必须是$0$同时选择这一段不能使答案变大，这个详见代码的转移

因此我们现在有了一个$O(n^3\log \sum Y_i)$的做法，可以通过前4个Subtask

那么再看一下第5个Subtask有什么特殊之处，仔细一看会发现它的$A=1$！

那么很显然之前的DP之所以会慢就是因为考虑了答案的下界，但现在我们不用考虑了，直接考虑求出分开的最少段数，判断是否小于$B$即可，同样转移的方法和上面类似

所以这部分的复杂度是$O(n^2\log \sum Y_i)$的，两者综合即可通过此题

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#define RI register int
#define CI const int&
using namespace std;
const int R=40,N=2005;
int n,l,r,a[N]; long long ans;
namespace Case1 //n<=100 solver
{
	const int MN=105;
	bool f[MN][MN];
	inline bool check(CI idx)
	{
		RI i,j,k; memset(f,0,sizeof(f));
		for (f[0][0]=i=1;i<=n;++i) for (j=1;j<=i;++j)
		{
			long long sum=a[i]; for (k=i-1;~k;--k)
			f[i][j]|=f[k][j-1]&&(!((sum>>idx)&1))&&((((sum>>idx)<<idx)|ans)==ans),sum+=a[k];
		}
		bool flag=0; for (i=l;i<=r;++i) flag|=f[n][i]; return flag;
	}
};
namespace Case2 //l=1 solver
{
	int f[N];
	inline bool check(CI idx)
	{
		RI i,j; for (memset(f,127,sizeof(f)),f[0]=0,i=1;i<=n;++i)
		{
			long long sum=a[i]; for (j=i-1;~j;--j)
			{
				if ((!((sum>>idx)&1))&&((((sum>>idx)<<idx)|ans)==ans))
				f[i]=min(f[i],f[j]+1); sum+=a[j];
			}
		}
		return f[n]<=r;
	}
};
int main()
{
	RI i; for (scanf("%d%d%d",&n,&l,&r),i=1;i<=n;++i) scanf("%d",&a[i]);
	for (i=40;~i;--i) if (!(n<=100?Case1::check(i):Case2::check(i))) ans|=(1LL<<i);
	return printf("%lld",ans),0;
}
```



---

## 作者：Piwry (赞：4)

给出一个我无法确定正确性的 $O(n^2\log n)$ 的算法...（虽然以目前的数据没跑出问题...）

## 解析

首先前面部分和其它题解无异：先贪心地从高位考虑到低位，对答案二进制每一位 dp 该位是否可以为 $0$（并且同时要满足前面高位的要求）

具体来说，对第 $x$ 位 dp 时，我们设 $f(i, k)$ 表示处理到第 $i$ 个元素，共分 $k$ 段，答案第 $x$ 位**可以放的最小值**

当时我就猜想 $f$ 关于 $k$ 的图像的最小值是否是**连续的一段**...后来打表观察了几份数据也发现都是连续的...（其实一开始想到的是 wqs 二分，不过后来做着做着发现这东西和 wqs 二分以及凸函数都没什么关系 \fad）

这里就先假设最小值是连续的。具体来说，若 $f$ 关于 $k$ 的函数 $g(k)=f(i,k)$，其中 $i$ 为一定值，有 $g(x), g(y), x<y$ 的值为 $g$ 在定义域内的最小值，那么对于 $g(z), x<z<y$，也一定有 $g(z)$ 的值为 $g$ 在定义域内的最小值

其图像差不多就是这样：

![g](https://cdn.luogu.com.cn/upload/image_hosting/v18vo6ni.png)

考虑我们如果不对划分数 $k$ 设维数，直接 dp 会发生什么事：

具体来说，对第 $x$ 位 dp 时，我们设 $dp(i)$ 表示处理到第 $i$ 个元素，答案 $x$ 位可以放的最小值

显然 dp 出的值应当是上面函数的最小值（可以按意义理解）；并且若设此时划分的段数 $k$，$k$ 应当在上面 $g$ 的最小值的区间 $[l, r]$ 内

我们考虑在 dp 时记录划分的段数。对于**值相同的转移**，可以想到，如果总是尽量取段数最小的，那么最后就应当有 $k=l$；如果总是取段数最大的，那么最后就应当有 $k=r$（证明还是考虑 $g$ 函数的含义）

于是我们就得到的 $g$ 最小值的区间；即对第 $x$ 位 dp 时，可以使该位放 $0$ 的划分段数的取值的区间。只需再拿去和 $A, B$ 比较下就可以了

于是最后就只需证明 $g$ 的最小值是否是连续的一段...然而我试了很久也没想到什么好的证明思路...

但目前按原题的数据测过来都没问题 /kk

## CODE

如有不理解的部分可以参考代码

```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
#include <cmath>
#define ll long long
using std::pair;
using std::min;
using std::max;
typedef pair<short, bool> pad;

const int MAXN =2002;

ll sum[MAXN];
ll pow_2[MAXN];

bool dp[MAXN];
short cnt_div[MAXN];

/*------------------------------Dp------------------------------*/

pad calc_l(const int &n, const ll &ans, const int &dig){
	memset(cnt_div, -1, sizeof(cnt_div));
	dp[0] =0, cnt_div[0] =0;
	ll tmp_ans =((~ans)^(pow_2[dig]-1));
	for(int i =1; i <= n; ++i){
		for(int j =1; j <= i; ++j){
			ll Sum =(sum[i]-sum[j-1]), Dig =pow_2[dig-1];
			if((tmp_ans&Sum) == 0){/*高位需要满足之前的答案*/
				bool check =dp[j-1]|((Sum&Dig) != 0);
				if(cnt_div[i] == -1 || (!check && dp[i])/*check < dp[i]*/){
					dp[i] =check;
					cnt_div[i] =cnt_div[j-1]+1;
				}
				else if((check && dp[i]) || (!check && !dp[i]))
					cnt_div[i] =min(cnt_div[i], (short)(cnt_div[j-1]+1));/*尽可能少分段 - 左端点*/
			}
		}
	}
	return pad(cnt_div[n], dp[n]);
}

pad calc_r(const int &n, const ll &ans, const int &dig){
	memset(cnt_div, -1, sizeof(cnt_div));
	dp[0] =0, cnt_div[0] =0;
	ll tmp_ans =((~ans)^(pow_2[dig]-1));
	for(int i =1; i <= n; ++i){
		for(int j =1; j <= i; ++j){
			ll Sum =(sum[i]-sum[j-1]), Dig =pow_2[dig-1];
			if((tmp_ans&Sum) == 0){
				bool check =dp[j-1]|((Sum&Dig) != 0);
				if(cnt_div[i] == -1 || (!check && dp[i])){
					dp[i] =check;
					cnt_div[i] =cnt_div[j-1]+1;
				}
				else if((check && dp[i]) || (!check && !dp[i]))
					cnt_div[i] =max(cnt_div[i], (short)(cnt_div[j-1]+1));/*尽可能多分段 - 右端点*/
			}
		}
	}
	return pad(cnt_div[n], dp[n]);
}

/*------------------------------Check------------------------------*/

bool check(const int &n, const int &A, const int &B, const ll &ans, const int &dig){
	if(A == 1){
		pad L =calc_l(n, ans, dig);
		if(L.second == 1)
			return 0;
		else{
			if(L.first <= B)
				return 1;
			else
				return 0;
		}
	}
	else{
		pad L =calc_l(n, ans, dig), R =calc_r(n, ans, dig);
		if(L.second == 1)/*定义域内不存在不放该数位的方案*/
			return 0;
		else{
			/*注意包含 -V*/
			if((L.first < A && R.first > B) || (L.first >= A && L.first <= B) || (R.first >= A && R.first <= B))
				return 1;
			else
				return 0;
		}
	}
}

/*------------------------------Main------------------------------*/

int read(){
	int x =0; char c =getchar();
	while(c < '0' || c > '9') c =getchar();
	while(c >= '0' && c <= '9') x =(x<<1)+(x<<3)+(48^c), c =getchar();
	return x;
}

int main(){
	int n =read(), A =read(), B =read();
	for(int i =1; i <= n; ++i)
		sum[i] =sum[i-1]+read();
	
	int cnt =log2(sum[n]);
	pow_2[0] =1;
	for(int i =1; i <= cnt; ++i)
		pow_2[i] =pow_2[i-1]<<1;
	ll ans =0;
	for(int i =cnt; i >= 0; --i){
		if(!check(n, A, B, ans, i+1))
			ans |=(1ll<<i);
	}
	printf("%lld", ans);
}
```

---

## 作者：Ryan_ (赞：3)

a!=1：

从高位到低位一位一位的算

记录下哪些位必须为0

dp[i][j] 表示前i个数分为j组，这一位为0，且满足之前必须为0的位也是0 是否可行

枚举k，表示k+1~i分为一组

若k+1~i的和满足 必须为0的位是0，且dp[k][j-1] 为true

则dp[i][j]为true

 

a=1：

从高位到低位一位一位的算

记录下哪些位必须为0

dp[i] 表示前i个数，这一位为0，且满足之前必须为0的位也是0，最少能划分的组数

枚举k，表示k+1~i划分为一组

若k+1~i的和满足 必须为0的位是0，且dp[k]合法，dp[i]=min{ dp[k] }+1


```cpp
#include<cstdio>
#include<cstring>
#include<iostream>

#define N 2001

using namespace std;

typedef long long LL;

int n,a,b;
LL sum[N];

LL zero,ans;

bool dp1[N][N];

int dp2[N];

template<typename T>
void read(T &x)
{
    x=0; char c=getchar();
    while(!isdigit(c)) c=getchar();
    while(isdigit(c)) { x=x*10+c-'0'; c=getchar(); }
}

bool judge(int l,int r,int t)
{
    LL s=sum[r]-sum[l-1];
    return !(zero&s) && !(s&(1LL<<t));
} 

void solve1()
{
    for(int t=40;t>=0;--t)
    {    
        memset(dp1,false,sizeof(dp1));
        dp1[0][0]=true;
        for(int i=1;i<=n;++i)
            for(int j=1;j<=b;++j)
                for(int k=0;k<i;++k)
                    if(dp1[k][j-1] && judge(k+1,i,t)) dp1[i][j]=true;
        int j;
         for(j=a;j<=b;++j)
             if(dp1[n][j]) 
             {
                 zero+=1LL<<t;
                break;
            }
        if(j==b+1) ans+=1LL<<t;
    } 
}

void solve2()
{
    for(int t=40;t>=0;--t)
    {
        memset(dp2,63,sizeof(dp2));
        dp2[0]=0;
        for(int i=1;i<=n;++i)
            for(int j=0;j<i;++j)
                if(dp2[j]!=-1 && judge(j+1,i,t)) dp2[i]=min(dp2[i],dp2[j]+1);
        if(dp2[n]<=b) zero+=1LL<<t;
        else ans+=1LL<<t;
    } 
}

int main()
{
     //freopen("sculpture.in","r",stdin);
    //freopen("sculpture.out","w",stdout); 
    read(n); read(a); read(b);
     for(int i=1;i<=n;++i) read(sum[i]),sum[i]+=sum[i-1];
    if(a!=1) solve1();
     else solve2();
     cout<<ans;
}
```


---

## 作者：Jean (赞：3)

毒瘤题。    

[题目链接](https://www.luogu.org/problemnew/show/P3646)

~~还不是因为今天模拟赛刚好出了这道题, 不然我这种蒟蒻怎么会来做这个题~~ 

悄咪咪的说， 我今天只是把所有的统统按位或，结果是可以拿到50分的...我们的数据也太水了吧哈哈哈哈哈

~~骗分的艺术~~

至于正解，是要用到数位DP.

要使答案最小，就要尽量使一个位上的数**都为0** ,  
而且很显然数位越高对答案的影响就越大，所以就需要从高位开始往后DP.

我们可以设一个$ f[i][j] $ 表示前1-i个数中分为j个区间能否使当前的数位为0。  
首先$f[i][j]$ 初始化为0，再用k 枚举1~i 中的分组位置，当前要求的当然就是最后一组， 1~k 为前 j-1 种分法；

对了，事先还要对这个序列求一遍前缀和，我们用sum数组将其保存。  
于是可以直接求第 k~i 区间的和 ，为sum[i]-sum[k];（这里不需要将k-1，因为k本身不在最后一组中）

现在的任务就是判断啦 

把最后一组的和求出来后，先与之前的ans按位或，得到新的答案，再与ans按位异或， 就是求出比之前的ans新增的值；  
比如判断   
  000   
  011  
如果这一位为1，则 100 > 011, 不行，反之则可以，满足条件；   

后面$ gi $数组就是对任务5，由于A=1,则只需满足小于B的条件即可，不需要再求满足条件的组数；  
 
 代码


```
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll d[1111];
ll n,  a,  b,  ans ;
ll f[1005][1005], g[1005], sum[1005] ,flag;
inline ll read(){
	ll res = 0;
	char ch = getchar();
	while(ch<'0'||ch>'9') ch = getchar();
	while(ch>='0'&&ch<='9') res = (res<<3)+(res<<1)+ch-'0', ch = getchar();
	return res;
}

int main()
{
	scanf("%lld%lld%lld",&n,&a,&b);
	for(ll i = 1; i<=n; i++){
		d[i] = read();
		sum[i]= sum[i-1]+d[i];
	}
	if(n<=100){
		f[0][0] = 1;
		for(ll l = (1LL<<50); l!=0; l>>=1){
			for(ll  i = 1;i<=n;i++)
				for(ll j = 1; j<=i;j++)
					f[i][j] = 0;
			flag = 0;
			for(ll i = 1; i<=n; i++)
				for(ll j = 1; j<=i;j++)
					for(ll k = 0; k<i ;k++)
						if((((sum[i]-sum[k])|ans)^ans)<=l-1&&f[k][j-1]==1)
							f[i][j] = 1;	
				for(ll j = a; j<=b;j++)	
					if(f[n][j]==1){ flag = 1; break;}
			if(flag==0) ans |= l;
		}
	}
	else{
		g[0] = 1;
		for(ll l = (1LL<<50);l;l>>=1){
			for(ll i = 1;i<=n;i++)
				g[i] = 99999999;
			for(ll i = 1; i<=n; i++)
				for(ll k = 0;k < i ; k++)
					if((((sum[i]-sum[k])|ans)^ans)<=l-1&&g[k])
						g[i] = min(g[i],g[k]+1);
			int flag = 0;
				if(g[n]<=b+1) flag = 1;
			if(flag==0) ans |= l;
		}
	}
	
	printf("%lld",ans);
			
	return 0;
}
```

---

## 作者：LinkyChristian (赞：2)

看数据范围，经典二合一

- 二进制问题可以分位考虑

由于或操作的性质，二进制中的某一位只要在一段数中为 $1$ ，那么其在最终答案肯定为 $1$ 。

- 二进制最值问题可以贪心

显然每一位都大于所有比它小的位的和。从大到小贪心，如果能让某一位为 $0$ 就直接让其为 $0$ 。显然关于这个我们可以得出一个 dp 方程：

$$
	f_{i,j} \leftarrow f_{i,j}| (f_{k,j-1} \&[sum(k+1,j)|S==S]),k\in [1,i-1]
$$

其中 $f_{i,j}$ 表示将前 $i$ 个数分成 $j$ 段并满足条件的可行性。$S$ 为已有的位的限制。如果某一位无限制则默认为 $1$ 。显然这种存在性的 dp 我们可以使用 bitset 优化。将状态的两维掉转一下即可。

由此我们可以通过 $n \le 100$ 的点，考虑下一个部分，这个部分的特点是没有下限。

考虑优化 dp 。由于没有下限，因此 dp 状态中就不需要记下分成几段了。设 $g_i$ 为考虑前 $i$ 个数，在满足条件的情况下最少分成几段，对于每一位 $O(n^2)$ 转移即可。

---

## 作者：cqbzlwz (赞：1)

### 前言
根本不知道数位 DP 是什么，只想到用 DP 去做，写到一半发现有问题，非常无语地去 wiki 上面找每种 DP 的题型，最终找到了数位 DP。

### 数位 DP 简介
数位：把一个数字一位一位拆开，每个数位是数位 DP 的重点。根据题目情况决定进制。

数位 DP：用来解决关于数位的问题 ~~（废话）~~，一般具有以下几个特征：
1. 需统计数量、方案总数。

1. 可以使用**数位**的思想去理解。

1. 题目提供了一个**区间**作为统计的限制。

总之，个人理解为与**数位**和**统计**有关。

不管怎么样，数位 DP 始终是 DP，和普通 DP 的打法仍然大同小异。

### 本题分析

本题符合数位 DP 特征的第 2/3 条，考虑数位 DP ~~（不然开头为啥要讲数位 DP）~~。

众所周知，一个数的最高位越小，这个数越小。而题目要求的优美度是由或运算得到的，所以每个组的最高位要尽可能小。因此从高位到低位依次枚举，使高位尽可能小（即二进制为0）。

定义状态： $dp_{i, j}$ 表示将前 $i$ 个数分成 $j$ 段，是否能让当前数位为0。

外层循环（解释在注释中）：
```cpp
for (int k = (1ll << 40); k; k >>= 1) {//枚举数位对应的状态
	memset(dp, 0, sizeof(dp));
	dp[0][0] = 1;//初始化
	int tot = ans | (k - 1);
	bool flag = 0;//flag 表示当前数位为能否为0
	...//中间部分
	for (int i = l; i <= r; ++i) {
    		if (dp[n][i]) {
			flag = 1; break;//当前数位可以为0
		}
	}	
	if (!flag) ans |= k;//当前数位不能为0，将答案的这一位改为1
}
```
接下来，是最关键的状态转移部分，
其中的 if 语句解释如下：
`(s[i]-s[p] | tot) == tot` 表示 tot 前面一段的值按位或 `s[i]-s[p]` 时不会影响 tot，并且当前枚举的数位可以为 0，也就是说，只要 1 到 t 中间分成 `j - 1` 段,也就是 `dp[p][j - 1]` 这一位上可以为 0，那么 `dp[i][j]` 的这一位上也能为 0。
```cpp
for (int j = 1; j <= min(i, r); ++j) {//分成的段数
	for (int p = 0; p < i; ++p) {//分割点，(p,i]为最后一段
		if (((s[i] - s[p]/*前缀和求(p,i]的和*/) | tot) == tot && dp[p][j - 1]) {
			dp[i][j] = 1;
		}
	}
}
```

我们将代码拼接起来，提交一下。然而，对于子任务五，这个算法就不能胜任。我们再仔细观察一下，第五个子任务有特殊条件 $A=1$！之前我们为了保证分的组数不低于下界，而现在我们可以无视下界了。

来重新定义状态：$f_i$ 表示前 $i$ 个数分段使得当前数位为 $0$ 所需的最小分段数。

最后给出转移部分：
```cpp
for (int i = 1; i <= n; ++i) {
	for (int j = 0; j < i; ++j) {
		if (((s[i] - s[j]) | tot) == tot) f[i] = min(f[i], f[j] + 1);
	}
}
```

最终的最后，发出完整代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int n, l, r, a[2005], s[2005], f[2005], ans;
bool dp[2005][2005];
int read() {
	int s = 0;
	char ch = getchar();
	while (ch < '0' || ch > '9') ch = getchar();
	while (ch >= '0' && ch <= '9') s = (s << 3) + (s << 1) + ch - '0', ch = getchar();
	return s;
}
signed main() {
	scanf("%lld%lld%lld", &n, &l, &r);
	for (int i = 1; i <= n; ++i) {
		a[i] = read();
		s[i] = s[i - 1] + a[i];
	}
	if (n <= 100) {
		for (int k = (1ll << 45); k > 0; k >>= 1) {
			memset(dp, 0, sizeof(dp));
			dp[0][0] = 1;
			int tot = ans | (k - 1);
			bool flag = 0;
			for (int i = 1; i <= n; ++i) {
				for (int j = 1; j <= min(i, r); ++j) {
					for (int p = 0; p < i; ++p) {
						if (((s[i] - s[p]) | tot) == tot && dp[p][j - 1]) {
							dp[i][j] = 1;
						}
					}
				}
			}
			for (int i = l; i <= r; ++i) {
				if (dp[n][i]) {
					flag = 1; break;
				}
			}
			if (!flag) ans |= k;
		}
	} else {
		for (int k = (1ll << 45); k > 0; k >>= 1) {
			memset(f, 0x3f, sizeof(f));
			f[0] = 0;
			int tot = ans | (k - 1);
			for (int i = 1; i <= n; ++i) {
				for (int j = 0; j < i; ++j) {
					if (((s[i] - s[j]) | tot) == tot) f[i] = min(f[i], f[j] + 1);
				}
			}
			if (f[n] > r) ans |= k;
		}
	}
	
	printf("%lld", ans);
	return 0;
}
```

---

## 作者：clamee (赞：0)

这道题目比较简单。但我还是卡常卡了很久。

首先从高位向低位贪心考虑，需要高位尽可能地为 **0**。

考虑如果最大值的二进制表示中的一位如果为 **0** 的话，相当于这一位在划分出来的每一段中都必须为 **1**。  
每次判断最高位能否取零便能得到最小解。

所以问题转化为是否存在一种划分使得它能满足现有约束并且划分出的段数在 A,B 之间。

可以 DP 求解，设 $f[i][j]$ 表示前 $i$ 个划分为 $j$ 块能否满足要求，最后答案看 $f[n][A-B]$ 之间能否满足要求即可。

这个 DP 是 $O(n^3)$ ，再加上拆位的 log ，显然过不了。

然后发现当 n>50 时，A=1，故可以数据分治。这样的话便可以设 $g[i]$ 表示划分前 i 个满足条件的最小段数是多少，显然 $f[n]<=B$ 是满足条件。

故结合以上两算法即可通过本题。

```
#include<bits/stdc++.h>
using namespace std;


#define il inline
#define rg register

#define int long long

il int read()
{
	int re=0,k=1;char ch=getchar();
	while(ch>'9'||ch<'0'){if(ch=='-')k=-1;ch=getchar();}
	while(ch<='9'&&ch>='0'){re=re*10+ch-48;ch=getchar();}
	return re*k;
}

il void write(int x)
{
	if(x<0)return write(-x),void();
	if(x<10)return putchar(x+48),void();
	return write(x/10),write(x%10),void();
}

int n,m,A,B;

int f[2005],g[205][205],a[2005],s[2005],ans,T;

bool p[51],vis[2005];

bool judge(int x)
{
	for(rg int i=40ll;i>=T;i--)
	{
		bool now=(x>>i)&1;
		if(now&p[i])return 0;
	}
	return 1;
}

bool sol1()
{
	memset(g,0,sizeof(g));
	g[0][0]=1;
	for(rg int i=1;i<=n;i++)
		for(rg int j=0;j<i;j++)
		{
			if(!judge(s[i]-s[j]))continue;
			for(rg int k=1;k<=i;k++)
				g[i][k]|=g[j][k-1];
		}
	for(rg int i=A;i<=B;i++)
		if(g[n][i])return 1;
	return 0;
}

bool sol2()
{
	f[0]=0;
	for(rg int i=1;i<=n;i++)
	{
		f[i]=0x3f3f3f3f;
		for(rg int j=0;j<i;j++)
		{
			if(!judge(s[i]-s[j]))continue;
			f[i]=min(f[i],f[j]+1);
		}
	}
//	cerr<<f[3];
	return f[n]<=B;
}

signed main()
{
	n=read();A=read();B=read();

	for(rg int i=1;i<=n;i++)
		a[i]=read(),s[i]=s[i-1]+a[i];
	if(A!=1)
	{
		for(rg int i=40ll;i>=0ll;i--)
		{
			p[i]=1;T=i;
			if(!sol1())
			{
				p[i]=0;
				ans^=(1ll<<i);
			}
		}
	}
	else
	{
		for(rg int i=40ll;i>=0ll;i--)
		{
			p[i]=1;T=i;
			if(!sol2())
			{
				//cerr<<i<<" "<<f[n]<<endl;
				p[i]=0;
				ans^=(1ll<<i);
			}
		}
	}
	//cerr<<judge(11);
	write(ans);
}
```

---


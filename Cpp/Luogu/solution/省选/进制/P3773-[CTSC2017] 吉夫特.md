# [CTSC2017] 吉夫特

## 题目描述

简单的题目，既是礼物，也是毒药。

B 君设计了一道简单的题目，准备作为 gift 送给大家。

输入一个长度为  $n$  的数列  $a_1, a_2, \cdots , a_n$  问有多少个长度大于等于  $2$  的不上升的子序列满足：

 $$\prod _{i=2}^{k} \binom{a_{b_{i-1}}}{a_{b_i}} \bmod 2 = \binom{a_{b_1}}{a_{b_2}} \times \binom{a_{b_2}}{a_{b_3}} \times \cdots \binom{a_{b_{k-1}}}{a_{b_k}} \bmod 2 > 0$$ 

输出这个个数对  $1000000007$  取模的结果。

G 君看到题目后，为大家解释了一些基本概念。

我们选择任意多个整数  $b_i$  满足

 $$1 \leq b_1 < b_2 < \dots < b_{k-1} < b_k \leq n$$ 

我们称  $a_{b_1}, a_{b_2}, \cdots, a_{b_k} $  是  $a$  的一个子序列。

如果这个子序列同时还满足

 $$a_{b_1} \geq a_{b_2} \geq \cdots \geq a_{b_{k-1}}\geq a_{b_k}$$ 

我们称这个子序列是不上升的。

组合数  $\binom {n} {m} $  是从  $n$  个互不相同的元素中取  $m$  个元素的方案数，具体计算方案如下：

 $$\binom {n}{m}=\frac{n!}{m!(n-m)!}=\frac{n \times (n-1) \times \cdots \times 2 \times 1}{(m \times (m-1) \cdots \times 2 \times 1)((n-m)\times(n-m-1)\times \cdots \times 2 \times 1)}$$ 

这里要特别注意，因为我们只考虑不上升子序列，所以在求组合数的过程中，一定满足  $n \geq m$ ，也就是 $\binom {a_{b_{i-1}}}{a_{b_i}}$ 中一定有 $a_{b_{i-1}} \geq a_{b_i}$ 。

我们在这里强调取模  $x \mod y$  的定义：

 $x \bmod y = x -\left \lfloor \frac{x}{y} \right \rfloor \times y$ 

其中  $\left \lfloor n \right \rfloor$  表示小于等于  $n$  的最大整数。

 $x \bmod 2 > 0$  ，就是在说  $x$  是奇数。

与此同时，经验告诉我们一个长度为  $n$  的序列，子序列个数有  $O(2^n)$  个，所以我们通过对答案取模来避免输出过大。

B 君觉得 G 君说的十分有道理，于是再次强调了这些基本概念。

最后， G 君听说这个题是作为 gift 送给大家，她有一句忠告。

“Vorsicht, Gift!”

“小心. . . . . .剧毒！ ”

## 说明/提示

对于前 $10\%$ 的测试点，$n \leq 9$，$1\leq a_i\leq 13$。

对于前 $20\%$ 的测试点，$n\leq 17$，$1\leq a_i\leq 20$。

对于前 $40\%$ 的测试点，$n\leq 1911$，$1\leq a_i\leq 4000$。

对于前 $70\%$ 的测试点，$n\leq 2017$。

对于前 $85\%$ 的测试点，$n\leq 100084$。

对于 $100\%$ 的测试点，$1\leq n\leq 211985$，$1\leq a_i\leq 233333$。所有的 $a_i$ 互不相同，也就是说不存在 $i, j$ 同时满足 $1\leq i < j\leq n$ 和 $a_i = a_j$。


## 样例 #1

### 输入

```
4
15
7
3
1```

### 输出

```
11```

# 题解

## 作者：_ctz (赞：35)

[安利blog](https://ctz45562.github.io/2019/10/10/%E6%B4%9B%E8%B0%B7-P3773-CTSC2017-%E5%90%89%E5%A4%AB%E7%89%B9/)

[传送门](https://www.luogu.org/problem/P3773)

我好菜啊连卢卡斯都不会了$QAQ$

卢卡斯搞那一坨组合数：

$C_{a_i}^{a_j}\equiv C_{a_i/2}^{a_j/2}\times C_{a_i\%2}^{a_j\%2}\pmod 2$

后面那个$C_{a_i\%2}^{a_j\%2}$有四种情况$C_0^0,C_0^1,C_1^0,C_1^1$，其中只有$C_0^1=0$。

然后继续处理$C_{a_i/2}^{a_j/2}$。

我们发现，这不就是把$a_i$和$a_j$按二进制拆位了。其中只要出现过$C_0^1$，$C_{a_i}^{a_j}$就为$0$。

也就是说二进制下不存在某一位$a_i$为$0$而$a_j$为$1$，即$a_j$二进制下是$a_i$的子集。

问题就变成了求子序列的个数，满足每一项在二进制下是前一项的子集。

$a_i\le 233333$还互不相同，直接设$f(i)$为以$i$为结尾的子序列个数，枚举子集刷表转移就没了。

而且都是它的子集了，就不用考虑序列的单调性了。

复杂度就是枚举子集的$O(3^{\log_2\max\{a_i\}})$

非常简短的代码：

``` cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <cstring>

#define maxn 250005
#define inf 0x3f3f3f3f

const int mod = 1e9 + 7;

using namespace std;

inline int read(){
	int x=0,y=0;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')y=1;ch=getchar();}
	while(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
	return y?-x:x;
}
int f[maxn];
int main(){
	int n=read(),a,ans=0;
	for(register int i=1;i<=n;++i){
		a=read();
		for(register int S=a-1&a;S;S=S-1&a)(f[S]+=f[a]+1)%=mod;
		(ans+=f[a])%=mod;
	}
	printf("%d\n",ans);
}

```



---

## 作者：litble (赞：25)

[~~点击就送屠龙刀~~ 个人博客安利](https://blog.csdn.net/litble/article/details/80172715)

~~解题思路：B君出的题，不可做~~

**如何判断组合数是否是奇数？**

首先，$C_n^k=\frac{n!}{k!(n-k)!}$，假设$n!$的2因子数为$a$，$k!$的2因子数是$b$，$(n-k)!$的2因子数为$c$，那么如果$C_n^k$是奇数，则$a=b+c$

怎么求出$x!$的2因子个数呢？首先我们可以将x除以2，相当于一个提取公因数的过程，而那些不能被2整除的项就会被丢掉，于是剩下来的是$2*(\frac{x}{2}!)$，一直这样处理下去，得到答案为

$$f(x)=\sum_{i=1}^{ \infty} \frac{x}{2^i}$$

我们设$g(x)=x$，那么$g(x)=g(\frac{x}{2})+\frac{x}{2}+(x\bmod 2)=\sum_{i=1}^{ \infty} \frac{x}{2^i}+$(x在二进制下1的个数）
所以$x!$的2因子个数就是(x-x在二进制下1的个数)

那么$C_n^k$是奇数的条件即为：n在二进制下1的个数=k在二进制下1的个数+(n-k)在二进制下1的个数。

假设二进制下，n拥有的某一个1，k并没有，那么：

n: ...0...

k: ...1...

n-k: ...11....

会发现k和(n-k)二进制下1的个数和一定会大于n，所以必须k所有的1 n都拥有才能符合条件，综上，$C_n^k$是奇数的条件为：`(n&k)=k`

那么后面的事情就简单了，设$f_i$表示以$a_i$开头的子序列个数，用桶存每一个$a_i$出现的位置$i$。计算$f_i$时，考虑下一个放什么，也就是枚举$a_i$的子集，判断这个数是否在$i$后面，然后统计方案即可。

复杂度是$O(3^{\log maxa})$的

```cpp
#include<bits/stdc++.h>
using namespace std;
#define RI register int
int read() {
	int q=0;char ch=' ';
	while(ch<'0'||ch>'9') ch=getchar();
	while(ch>='0'&&ch<='9') q=q*10+ch-'0',ch=getchar();
	return q;
}
const int N=240000,mod=1000000007;
int a[N],T[N],f[N];
int n,ans;
int qm(int x) {return x>=mod?x-mod:x;}
int main()
{
	n=read();
	for(RI i=1;i<=n;++i) a[i]=read(),T[a[i]]=i;
	for(RI i=n;i>=1;--i) {
		f[i]=1;
		for(RI j=a[i]&(a[i]-1);j;j=a[i]&(j-1))
			if(T[j]>i) f[i]=qm(f[i]+f[T[j]]);
		ans=qm(ans+f[i]);
	}
	ans=(ans-n+mod)%mod;
	printf("%d\n",ans);
	return 0;
}
```

---

## 作者：GoAway (赞：12)

一道不难但是拖了很久的题,我这个傻逼活该要退役.

[Click here to read the problem.](https://www.luogu.org/problemnew/show/P3773)

令 $N= log_2(max_{a_i})$.
网上很多 $3^N$ 的做法,不具体说了,大概就是$dp[x]$代表以$x$结尾的方案数.

考虑分块,把数字二进制下分成前一段和后一段.
设$f[u][v] = \sum_{v \in x}*dp[u*2^\frac{N}{2}+x]$.即前一半为$u$,后一半$v$的超集的方案数之和.(超集就是子集的补集).

每加进一个数字,枚举前一半的超集,计算答案;再枚举后一半的子集,因为这个数字结尾的答案将影响后一半子集的$f$值.

时间复杂度$O(6^\frac{N}{2})$.

```cpp
#include <bits/stdc++.h>
#define LL long long
using namespace std ;
template <class T> void Read ( T &x, char c = getchar(), bool f = 0 ) {
	for ( x = 0 ; !isdigit(c) ; c = getchar() ) f |= c == '-' ;
	for ( ; isdigit(c) ; c = getchar() ) x = 10*x + c - '0' ;
	if (f) x = -x ;
}
const int maxn = 220000, Mod = 1000000007 ;
int n, m, S, f[520][520] ;
int main() {
	int i, x, u, v, val, ans = 0 ;
	Read(n) ;
	m = 1<<9, S = m-1 ;
	for ( i = 1 ; i <= n ; i ++ ) {
		Read(x) ;
		u = x/m, v = x%m ;
		val = 1 ;
		for ( x = u^S ; x ; x = (x-1)&(u^S) )
			if (f[x|u][v]) (val += f[x|u][v]) %= Mod ;
		(val += f[u][v]) %= Mod ;
		for ( x = v ; x ; x = (x-1)&v ) (f[u][x] += val) %= Mod ;
		(f[u][0] += val) %= Mod ;
	}
	for ( i = 0 ; i <= S ; i ++ )
		(ans += f[i][0]) %= Mod ;
	(ans += Mod-n) %= Mod ;
	cout << ans << endl ;
	return 0 ;
}
```

---

## 作者：SovietPower✨ (赞：10)

~~[更好的阅读体验](https://www.cnblogs.com/SovietPower/p/9775319.html)~~

首先$C(n,m)$为奇数当且仅当$n\&m=m$。证明不再在这写了。

因为要满足$n\&m=m$，所以题意即为，有多少个$a$的子序列$b$，满足$b_i\&b_{i+1}=b_{i+1}$。

令$f[i]$表示以$A[i]$结尾的合法子序列数。
那么有两种显然的方式：

1. 枚举$i$，$ans+=f[i]$，再更新后面满足 $A[j]$的二进制位是$A[i]$二进制位的子集 的$j$，$f[j]+=f[i]$。

2. 枚举$i$，枚举$j$，求$f[i]=\sum_{j<i}f[j]$($j$满足$A[j]$是$A[i]$的超集)，然后$ans+=f[i]$。

两种都是枚举子集。第一种是不需要查询，转移$O(3^{18})$；第二种是查询$O(3^{18})$，不需要转移。

（整个算法实际上是对每个$a_i$的二进制表示枚举了它的子集，而$a_i$互不相同，相当于是对所有二进制子集枚举了它的子集，所以复杂度是$3^{\log a_{max}}=3^{18}$）

这样好像比较危险？（比如出二进制$1$很多的$a_i$）

------------
我们将这两种方式综合一下：

转移时，固定$i$的后$9$位，枚举$i$前$9$位的子集$j$，用$f[i]$更新后面的$f[j]$；

求值时，固定$i$的前$9$位，枚举$i$后$9$位的超集$j$，从前面的$f[j]$转移，即$f[i]=\sum f[j]$。

这样复杂度是啥啊。。我不知道，反正靠谱很多。然后就可以200ms内AC了。

~~dls现场分析：大概是从之前的$2^{\log_23\cdot n}=2^{1.59n}$优化到了$2^{1.5n}$。
考虑枚举不满，大概有$2^{(0.6+\frac{1.59}{2})n}=2^{1.3n+}$？~~

by the way，好像很多人不知道枚举子集为什么是$3^n$的。
> 证明：设集合有$n$个元素，我们把所有子集$s$按元素个数$k=|s|$分类（因为它们的子集都为$2^k$个。那么枚举的集合数为：$$\sum_{k=0}^nC_{n}^k2^k=(1+2)^n=3^n$$

------------
```cpp
#include <cstdio>
#include <cctype>
#include <algorithm>
#define gc() getchar()
#define mod 1000000007
#define Mod(x) x>=mod&&(x-=mod)
typedef long long LL;
const int N=(1<<18)+3,L=(1<<9)-1;

inline int read()
{
	int now=0;register char c=gc();
	for(;!isdigit(c);c=gc());
	for(;isdigit(c);now=now*10+c-'0',c=gc());
	return now;
}

int main()
{
	static int f[N];
	int n=read(); LL ans=0,sum;
	for(int i=1,a; i<=n; ++i)
	{
		a=read(),sum=0;
		int l=a&L, r=a>>9;
		for(int j=r; j<=L; j=(j+1)|r)
			sum+=f[(j<<9)|l];
		ans+=sum%=mod, ++sum;
		r<<=9;
		for(int j=l; j; j=(j-1)&l)
			f[j|r]+=sum, Mod(f[j|r]);
		f[r]+=sum, Mod(f[r]);//0|r
	}
	printf("%lld\n",ans%mod);

	return 0;
}
```

------------

---

## 作者：Orion545 (赞：3)

# 广告

[这里观赏体验更佳](https://www.cnblogs.com/dedicatus545/p/9261490.html)

# 思路

一句话题意：

给出一个长度为 n 的序列，求所有长度大于等于2的子序列个数，满足：对于子序列中任意两个相邻的数 a和 b （b 在 a 前面），$C_a^b mod 2=1$，答案对1e9+7取模

显然膜2余1是个非常特殊的性质，应当好好加以利用

和组合数取模有关的东西，有Lucas定理，因此我们来试着推一推

$C_n^m\;mod\;2=C_{n\;mod\;2}^{m\;mod\;2}\ast C_{n/2}^{m/2}$

这个玩意的意义，显然就是把n和m转成二进制，那么只要没有某一位上n是0m是1（此时$C_0^1$无意义，视作0）就OK了

那么我们就把问题转化成了一个可以DP的问题

设dp[i]表示序列$[i,n]$中可能的种类数，那么可以通过枚举$a[i]$和哪些数满足上属性质

这个枚举过程可以巧妙地利用$j=(j+1)|a[i]$来完成，相当于是把$a[i]$的0一个个变成1

总效率不太会算，但是O(能过)还是有的

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define ll long long
using namespace std;
inline ll read(){
    ll re=0,flag=1;char ch=getchar();
    while(ch<'0'||ch>'9'){
        if(ch=='-') flag=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9') re=(re<<1)+(re<<3)+ch-'0',ch=getchar();
    return re*flag;
}
ll MOD=1e9+7; 
ll n,a[300010],dp[300010],lim=233333;
ll pl(ll a,ll b){
    return (a+b>MOD)?a+b-MOD:a+b;
}
int main(){
    n=read();ll i,j,ans=0;
    for(i=1;i<=n;i++) a[i]=read();
    for(i=n;i>=1;i--){
        for(j=a[i];j>=1;j=(a[i]&(j-1))){//注意枚举方法
            dp[a[i]]=pl(dp[a[i]],dp[j]);
        }
        ans=pl(ans,dp[a[i]]);
        dp[a[i]]=pl(dp[a[i]],1);
    }
    printf("%I64d\n",ans); 
}
```

---

## 作者：wurzang (赞：2)

题意：求有多少子序列 $a_{b_1},a_{b_2},\dots,a_{b_m}$ 满足 对于任意一个 $i \in[1,m-1]$ ，均有 $\binom {a_{b_i}}{a_{b_{i+1}}} \mod 2=1$。

根据 AGC 某题的结论，$\binom n m \equiv 1 (\mod 2)$ 当且仅当 $n \  \& \ m =m$

至于证明的话，考虑 $\operatorname{Lucas}$， $\binom n m\equiv \binom {n/2}{m/2} \times \binom{n \mod 2}{m \mod 2}\ (\mod 2)$


考虑 `dp` 了，设 $f_{i}$ 为以 $i$ 为终点的满足题意的子序列个数。

对于每一个 $i$，向 $a_i$ 的子集转移即可。

代码就不放了。

---

## 作者：cirnovsky (赞：2)

## 题意简述

求满足

$$\prod _{i=2}^{k} \binom{a_{b_{i-1}}}{a_{b_i}} \mod 2 = \binom{a_{b_1}}{a_{b_2}} \times \binom{a_{b_2}}{a_{b_3}} \times \cdots \binom{a_{b_{k-1}}}{a_{b_k}} \mod 2 > 0$$

的子序列个数。

## 题解

哇哦。

$$
\begin{aligned}
&\ \ \ \ \prod_{i=2}^{k}{a_{b_{i}-1}\choose a_{b_{i}}} \\
&\equiv\prod_{i=2}^{k}{\lfloor\frac{a_{b_{i}-1}}{2}\rfloor\choose\lfloor\frac{a_{b_{i}}}{2}\rfloor}\times{a_{b_{i}-1}\bmod2\choose a_{b_{i}}\bmod2}
\end{aligned}
(\operatorname{mod} 2)
$$

式子后面的 $\dbinom{a_{b_{i}-1}\bmod2}{a_{b_{i}\bmod2}}$ 一共有四种情况，其中只有 $\dbinom{0}{1}=0$。其他都为 $1$。

意味着只要出现 $a_{b_{i}-1}\equiv0\bmod2$ 且 $a_{b_{i}}\equiv1\bmod1$ 的情况，整个式子就为零了。

结论：$\dbinom{n}{m}\equiv0\space(\operatorname{mod}2)$ 当且仅当 $n\operatorname{bitand}m=m$。

证明（也许不是特别严谨）：我们可以知道：
$$
{n\choose m}={\lfloor\frac{n}{2}\rfloor\choose\lfloor\frac{m}{2}\rfloor}\times{n\bmod 2\choose m\bmod2}={\lfloor\frac{\lfloor\frac{n}{2}\rfloor}{2}\rfloor\choose\lfloor\frac{\lfloor\frac{m}{2}\rfloor}{2}\rfloor}\times {\lfloor\frac{n}{2}\rfloor\bmod2\choose\lfloor\frac{m}{2}\rfloor\bmod2}\times{n\bmod 2\choose m\bmod2}=\cdots
$$
我们发现：
$$
{\lfloor\frac{\lfloor\frac{\lfloor\frac{n}{2}\rfloor}{2}\rfloor}{\cdots}\rfloor\choose\lfloor\frac{\lfloor\frac{\lfloor\frac{m}{2}\rfloor}{2}\rfloor}{\cdots}\rfloor}
$$
这一坨，就是在一直进行二进制移位，$\operatorname{shr}1$。

那么我们可以得出一个结论：如果对于我们记 $(n)_{k}$ 表示 $n$ 在二进制意义下的第 $k$ 位。$(n)_{k}\in[0,1]$

那么对于 $\forall i$，有 $(n)_{i}=0$ 且 $(m)_{i}=1$，那么 $\dbinom{n}{m}\equiv0\space(\operatorname{mod} 2)$。

所以 $n\operatorname{bitand}m=m$，证毕。

我们题目要求的是最后算出来是个奇数，那么就不能存在 $a_{b_{i}-1}\operatorname{bitand}a_{b_{i}}=a_{b_{i}}$。

也就是 $a_{b_{i}}$ 为 $a_{b_{i}-1}$ 的子集。

接下来我们可以设计一个 DP，我们设 $f_{i}$ 为以 $a_{i}$ 为开头的答案。

那么转移就是加法原理：
$$
f_{i}=f_{i}+f_{j},j\in a_{i}\wedge t_{j}>i
$$
其中 $t_{i}$ 表示 $i$ 在序列中的位置。

时间复杂度由二项式定理可知是 $\Theta(3^{\log_{2}\max\{a_{i}\}})$。

```cpp
#include <cstdio>
#define mod ( 1000000007 )

const int MAXN = 250000 + 5;

int N;
int val[MAXN], dp[MAXN];
int buc[MAXN];

int main( ){
	scanf( "%d", &N ); for( int i = 1; i <= N; ++ i ){ scanf( "%d", &val[i] ); buc[val[i]] = i; }
	int Ans = 0;
	for( int i = N; i; -- i ){
		dp[i] = 1;
		for( int j = val[i] & ( val[i] - 1 ); j; j = ( j - 1 ) & val[i] ){
			if( buc[j] > i )	dp[i] = ( dp[i] + dp[buc[j]] ) % mod;
		}
		Ans = ( Ans + dp[i] ) % mod;
	}
	printf( "%d\n", ( Ans - N + mod ) % mod );
	return 0;
}
```

---

## 作者：wtyqwq (赞：1)

- [P3773 [CTSC2017]吉夫特](https://www.luogu.com.cn/problem/P3773)

- 题意描述：给定一个长度为 $n$ 的正整数序列 $a_1,a_2,\cdots ,a_n$，其中对于 $\forall i,j\in[1,n]\cap i < j$，有 $a_i\neq a_j$，问有多少个长度 $\ge 2$ 的子序列 $b_1,b_2\cdots b_m$，满足每个数在二进制下看作集合后，对于 $\forall i \in [2,n]$，有 $b_i$ 是 $b_{i-1}$ 的子集。$1\le n\le 211985$，$1\le a_i \le 233333$。

- 解题思路：

  将每个数在二进制下看作集合后，$b$ 是 $a$ 的子集，当且仅当 $a\  \text{and} \ b = b$。
  
  以下的三个做法都可以去掉 $a$ 数列中的元素两两不同的限制。

  - 方法一：
  
      很容易想到一种动态规划的解法，令 $f_i$ 表示有多少满足条件的序列以 $a_i$ 为结尾。和 $\text{LIS}$ 类似。状态转移方程：
  
      $$f_i=\left (\sum_{j=1}^{i-1}\ [a_j \ \text{and}\ a_i=a_i]\ f_j\right) +1$$
  
      $$\text{ans}=\left (\sum_{i=1}^n f_i\right) - n$$
    
  - 方法二：
  
      传统动态规划的时间复杂度 $O(n^2)$，不能通过本题。如何优化呢？
    
      将序列分块，每块 $\text{size}$ 个数。对于 $f_i$ 的计算，暴力枚举块内所有 $j$，更新 $f_i$。每算完一块的所有 $f$ 的值时，设 $g_x$ 表示前面所有数中，包含 $x$ 的数的 $f$ 的和，则 $g$ 可以用高维前缀和在 $O(a_i \log_2 a_i)$ 的时间内算出。那么 $f_i = $ 块内的贡献 $+\ g({a_i})$。
    
      一共要重新计算 $g$ 数组 $\lceil \dfrac {n}{\text{size}}\rceil$ 次，所以时间复杂度为 $O\left(\lceil \dfrac {n}{\text{size}}\rceil \times  a_i \times  \log_2 a_i + n \times  \text{size}\right)$，当 $\text{size} = \sqrt{a_i\times \log_2a_i}$ 时复杂度取到最小值，为 $O\left(\sum_{i=1}^n \sqrt{a_i\times \log_2 a_i}\right)$。
    
      这样的复杂度还是有点悬，有没有更好的方法？
    
  - 方法三：
  
      因为 $1\le a_i\le 233333$，所以 $a_i$ 在二进制下最多有 $18$ 位。设 $g(x,y)$ 表示二进制下前 $9$ 位为 $x$ 的数对二进制下后 $9$ 位为 $y$ 的 $\text{DP}$ 值的贡献。要计算 $f_i$ 时，令 $A$ 为 $a_i$ 二进制下的前 $9$ 位，$B$ 为 $a_i$ 二进制下的后 $9$ 位，则
  
      $$f_i = \left(\sum_{x\ \text{and}\ a = a} g(x, B)\right)+1$$
  
      计算 $f_i$ 完毕后，将所有的 $g(A,y)$ 都加上 $f_i$，其中 $B$ 包含 $y$。此算法的时间复杂度为 $O\left(\sum_{i=1}^n \sqrt{a_i}\right)$，可以通过本题。

------------
```cpp
#include <stdio.h>
#include <ctype.h>
#define R register
#define MAX (1 << 9)
#define mod 1000000007
using namespace std;
char Buf[1 << 21], *S(Buf), *T(Buf);
#define getchar() (S == T && (T = (S = Buf) + fread(Buf, 1, 1 << 24, stdin), S == T) ? EOF : *S++)
inline void Input(int &x) {
    R char c(getchar());
    for (x = 0; !isdigit(c); ) c = getchar();
    while (isdigit(c)) x = (x << 1) + (x << 3) + (c ^ 48), c = getchar();
}
int n, x, ans, cnt, i, A, B, f[MAX][MAX];
inline int Add(int &x, int y) {
	x += y;
	if (x >= mod)
		x -= mod;
	return x;
}
int main() {
	for (Input(n), ans = -n; n--; ) {
		Input(x), A = x >> 9, B = x & 511;
		for (cnt = 1, i = A; ; i = (i + 1) | A) {
			Add(cnt, f[i][B]);
			if (i == MAX - 1)
				break;
		}
		for (Add(ans, cnt), i = B; ; i = (i - 1) & B) {
			Add(f[A][i], cnt);
			if (i == 0)
				break;
		}
	}
	printf("%d\n", ans);
	return 0;
}
```
- 算法标签：线性动态规划，位运算。

- 时间复杂度：$O\left(\sum_{i=1}^n \sqrt{a_i}\right)$。

- 空间复杂度：$O(\max{a_i})$。

- 期望得分：$100$ 分。[提交记录](https://www.luogu.com.cn/record/36032458)。

---

## 作者：金爷爷哈哈 (赞：1)

楼下说的这个结论估计很多像我一样的蒟蒻会懵掉吧。。。

那么为了帮助大家理解我就来证明一下这个结论吧


我们假设(n&m)==m,那么先假设这个结论是对的，看能不能找到反例推翻它。


1.当m的二进制最右位是1时：

这时n的二进制最右位肯定是1，所以((n-1)&(m-1))==m-1,可以递归证明C(n-1,m-1)是奇数；

又因为((n-1)&m)!=m,因为n-1的二进制最右位没有1了，所以可以递归证明 C(n-1,m)是偶数，

进而可以证明 C(n,m)是奇数。


2.m二进制最右位不是1时：

这样(m-1)的二进制最右端显然会有一排1(长度>=1)。

(1):如果此时n的二进制最右位的1和m是相同的位置，那么依然满足((n-1)&(m-1))==m-1。

有因为n的二进制最右位的1在n减去1之后被消去了，所以此时((n-1)&m)!=m，仍可证明C(n,m)是奇数。


(2):如果n二进制最右位的1在m二进制最右位1的右边，那么减去1后，m右端连续的变成1的序列会长于n，比如m=10100(2),n=10110(2),那么m-1=10011,n-1=10101,2^1这位m-1是1而n-1不是1，所以此时((n-1)&(m-1))!=m-1;又因为n减去1之后并不影响最右端1左边那些1，所以可以证明((n-1)&m)==m,这样又证明了C(n,m)是奇数。

   
代码楼上的就比较好了，我就不贴我的丑代码了hhh


---

## 作者：LCGUO (赞：0)

$p.s.$公式好像不支持居中诶，麻烦管理员了awa。

做这题的前置知识是 Lucas 定理，可以先做一下[这题](https://www.luogu.com.cn/problem/P3807)。

我就当大家都会 Lucas 定理了awa。

---

Lucas 定理：

$C^m_n\!\equiv\!C^{\left\lfloor\frac{m}{p}\right\rfloor}_{\left\lfloor\frac{n}{p}\right\rfloor}\times C^{m\mod p}_{n\mod p}\pmod{p}$

所以我们来看看原式:

$\prod_{i=2}^k \dbinom{a_{b_i}}{a_{b_{i-1}}}\!\mod 2$

重点就在于 $\!\mod 2$ 这个地方。

由 Lucas 定理可知，原式的答案不是 0，就是 1。

所以我们要保证 $\forall \dbinom{a_{b_i}}{a_{b_{i-1}}} \equiv 1 \pmod 2$。

又因为 $\dbinom{0}{0}$，$\dbinom{1}{0}$，$\dbinom{1}{1}$ 为 1，$\dbinom{0}{1}$ 为 0。

根据 Lucas 定理，每次 $\mod 2$ 相当于把 $a_{b_i}$ 和 $a_{b_{i-1}}$ 二进制拆分，并且保证，$a_{b_i}$ 为 0 的那个位上 $a_{b_{i-1}}$ 不能为 1。

即 $a_{b_{i}}\!\And a_{b_{i-1}}\!=\!a_{b_i}$，我们设 $f(i)$ 为以 $i$ 开头的子序列数，枚举子集进行 dp 即可。

$p.s.$ 在最后累加的时候，要减去只有一个数的情况。

代码如下：
```cpp
#include<bits/stdc++.h>
#define rint register int
using namespace std;
inline int read(){
    int s=0,f=1;char c=getchar();
    while(c<'0'||c>'9'){if(c=='-')f=0;c=getchar();}
    while(c>='0'&&c<='9')s=(s<<1)+(s<<3)+c-48,c=getchar();
    return f?s:-s;
}
const int Mod=1e9+7;
int n,a[300010],f[300010],ans;
int main(){
    n=read();
    for(rint i=1;i<=n;++i) a[i]=read();
    for(rint i=n;i;--i){
        for(rint j=(a[i]-1)&a[i];j;j=(j-1)&a[i])
            f[a[i]]=(f[a[i]]+f[j])%Mod;
        f[a[i]]=(f[a[i]]+1)%Mod;
    }
    for(rint i=1;i<=n;++i) ans=(ans+f[a[i]]-1)%Mod;
    printf("%d",ans%Mod); 
    return 0;
}
```

没了awa。

---

## 作者：caidzh (赞：0)

~~讲真挺水的~~

首先你需要会$\text{Lucas}$定理，不过不会也没关系，下面我们介绍一下$\text{Lucas}$定理：

$$\dbinom{n}{m}=\dbinom{n/p}{m/p}\dbinom{n\mod{p}}{m\mod{p}}\pmod{p}$$

其中模数$p$是质数

这个定理有什么用呢？比如我们要计算组合数的时候，如果模数$p$非常小，显然这样我们就无法预处理阶乘逆元直接利用定义去算了，但是通过$\text{Lucas}$定理就可以进行计算

当然还可以拿来做这个题

因为模数是$2$，所以注意到$\text{Lucas}$定理中我们相当于对组合数中的$n$与$m$进行了二进制分拆，又因为：

$$\dbinom{0}{0}=1,\dbinom{1}{0}=1,\dbinom{0}{1}=0,\dbinom{1}{1}=1$$

这说明了一个重要的性质，如果题中的$a_{b_{i-1}}$存在某一位为$0$，而在这一位上$a_{b_i}$为$1$，那么$\dbinom{a_{b_{i-1}}}{a_{b_i}}$为偶数，否则为奇数

更加简便的说法就是，如果$\dbinom{a_{b_{i-1}}}{a_{b_i}}$是奇数，$a_{b_i}$是$a_{b_{i-1}}$的在二进制意义下的子集

题目要求的合法序列要求了这些组合数全是奇数，因此合法序列中相邻的$a$，后面的那个必是前面的子集

注意到序列中数的范围非常小，且没有重复数字，所以显然可以设计出一个动态规划做法，我们定义$f_i$为以第$i$个位置为**开头**的合法序列个数，从序列结尾处倒着往前$dp$，转移通过扫$a_i$的子集来完成，复杂度$O(3^{18})$
```cpp
#include<bits/stdc++.h>
using namespace std;
int inline read(){
    int num=0,neg=1;char c=getchar();
    while(!isdigit(c)){if(c=='-')neg=-1;c=getchar();}
    while(isdigit(c)){num=(num<<3)+(num<<1)+c-'0';c=getchar();}
    return num*neg;
}
const int maxn=250010,mod=1e9+7;
int n,a[maxn],f[maxn],pos[maxn],ans;
int main()
{
	n=read();
	for(int i=1;i<=n;i++)a[i]=read(),pos[a[i]]=i;
	for(int i=n;i>=1;i--){
		f[i]=1;
		for(int j=a[i];j;j=(j-1)&a[i])
			if(pos[j]>i)f[i]=(f[i]+f[pos[j]])%mod;
	}int ans=(-n+mod)%mod;
	for(int i=1;i<=n;i++)ans=(ans+f[i])%mod;
	cout<<ans;return 0;
}
```


---

## 作者：Sweetie_Liu (赞：0)

## 免责声明，含借鉴成分，不喜勿喷

DP好题啊，这计数非常的CTSC，既然是DP优化，我们就$step by step$.

**40$pts$**

$O(n^2)$处理组合数$%2$的值，我们设$f_{i,j}$为选到$i$，
$\binom{a_{b_1}}{a_{b_2}} \times \binom{a_{b_1}}{a_{b_2}} \times \cdots \binom{a_{b_{k-1}}}{a_{b_k}} \mod 2=j$的方案数。

**转移方程**

```cpp

if(a[j]>a[i]) {
	if(C[a[j]][a[i]]%2==0) {
		f[i][0] = (f[i][0]+f[j][1])%MOD;
	} else f[i][1] = (f[i][1]+f[j][1])%MOD;
	f[i][0] = (f[i][0]+f[j][0])%MOD;
}
```
大数据妥妥的跑到过年~~

**优化**

我们考虑一个组合数为奇数是的情况，$C_n^mmod\;2>0$

众所周知$2$是一个素数，还是最小的素数，那就让我们想到一个好东西 ***lucas*** 定理。

$C_n^m mod\;2=C_{n\;mod\;2}^{m\;mod\;2}C_{n/2}^{m/2}$，这显然是告诉我们$C_{n}^mmod\;2=1$的条件是，$m$二进制拆分之后，是$n$的子集，之后我们把等于$a_i$的值的位置的$f_i$都加起来，我们就可以$O(3^n)$完成此题了。

***Code***
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <vector>
using namespace std;
int read(){
	int w=1,x=0,ch=getchar();
	for(;ch<'0'||ch>'9';ch=getchar())if(ch=='-')w=-1;
	for(;ch>='0'&&ch<='9';ch=getchar())x=x*10+ch-'0';
	return x*w;
}
const int MAXN = (int)4e5+10;
int n,a[MAXN];
long long f[MAXN],ans;
const long long MOD = (int)1e9+7;
long long chain[MAXN];
int main(){
	n = read();
	for(int i=1;i<=n;i++){
		a[i] = read();
	}
	for(int i=n;i>0;i--){
		for(int j=a[i];j;j=(j-1)&a[i]){
			f[i] = (f[i]+chain[j])%MOD;
		}
		f[i] = (f[i]+1)%MOD;
		ans = (ans+f[i]-1+MOD)%MOD;
		chain[a[i]] += f[i]; 
	}
	printf("%lld\n",ans%MOD);
	return 0;
}
```

---


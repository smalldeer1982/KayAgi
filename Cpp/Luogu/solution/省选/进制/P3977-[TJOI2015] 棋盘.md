# [TJOI2015] 棋盘

## 题目描述

为了提高智商，ZJY 去新世界旅游了。可是旅游过后的 ZJY 杯具地发现要打开通往原来世界的门，必须要解开门上面画的谜题。谜题是这样的：

有个 $n$ 行 $m$ 列的棋盘，棋盘上可以放许多特殊的棋子。每个棋子的攻击范围是 $3$ 行 $p$ 列。输入数据用一个 $3\times p$ 的矩阵给出了棋子攻击范围的模板，棋子被默认为模板中的第 $1$ 行，第 $k$ 列，则棋子能攻击到的位置是 $1$，不能攻击到的位置是 $0$。输入数据保证第 $1$ 行第 $k$ 列的位置是 $1$。打开门的密码就是，在要求棋子互相不能攻击到的前提下，摆放棋子的方案数。注意什么棋子都不摆放也算作一种可行方案。由于方案数可能很大,而密码为 $32$ 位的二进制密码,所以 ZJY 仅需要知道方案数对 $2^{32}$ 次方取余数的结果即可。

注意：编号从 $0$ 开始，即第 $1$ 行指的是中间那行。

## 说明/提示

### 数据范围

对于 $10\%$ 的数据，$1 \leq n \leq 5$，$1 \leq m \leq5$。

对于 $50\%$ 的数据，$1 \leq n \leq 1000$，$1 \leq m \leq 6$。

对于 $100\%$ 的数据，$1 \leq n \leq 10^{6}$，$1 \leq m \leq 6$。

## 样例 #1

### 输入

```
5 5
3 1
0 1 0
1 1 1
0 1 0
```

### 输出

```
55447
```

# 题解

## 作者：shadowice1984 (赞：11)

阅读理解题……

所有的东西都是从0开始标号的……因此，也就是说，棋子在中间那行……所以可以打前面一行也可以打后边一行，因此我们只需要状态压缩一行就可以了……

因此合法的方案最多只有64种……考虑到不合法的情况，会更少……

因此可以使用矩阵快速幂优化……(话说为什么n只有$10^6$啊明明可以开到$10^9$的)现在来讲如何列dp式子好了

(如果不会矩阵快速幂优化的话可以先去写写其他的题，这里就不讲了)

我们一次填一行棋子$dp_{i,j}$表示决策到了第i行，j是一个仅在二进制下有意义的数字，j的第p位为0或1表示第i行第p列是否有棋子，当然显然有些j的情况本来就是不合法的，所以先打个表把所有合法的j值打出来

然后我们再把每种状态找出来那么如何状态i能否转移j呢，直接打一个每一种集合可以攻击到的集合的表，然后判断下两个集合是否可以相互攻击到，如果不可以相互攻击到的话，就不可以转移到了

代码方面，为了好写的话，可以把输入的表格转化成二进制集合，然后处理出每种行集合的情况可以攻击的集合，然后就可以快速判断了，注意为了方便，我们假定每个棋子都攻击不到自己……

上代码~

```C
#include<cstdio>
#include<algorithm>
using namespace std;const int N=80;typedef unsigned int uit;
int n;int m;int p;int k;uit t[N][N];int up;int bk[N][N];uit ans;
int at[3];int att[3][N];int zt[N];int ct;bool book[N];int lg[N];
struct mar//矩阵类 
{
    uit mp[N][N];
    void operator *=(const mar& b)
    {
        for(int i=1;i<=ct;i++)for(int j=1;j<=ct;j++)t[i][j]=0;
        for(int i=1;i<=ct;i++)
            for(int k=0;k<=ct;k++)
                for(int j=1;j<=ct;j++)
                    t[i][j]+=mp[i][k]*b.mp[k][j];
        for(int i=1;i<=ct;i++)for(int j=1;j<=ct;j++)mp[i][j]=t[i][j];
    }
}tr,res,st;
int main()
{
    scanf("%d%d%d%d",&n,&m,&p,&k);
    for(int i=0;i<3;i++)
    {for(int j=0,t;j<p;j++){scanf("%u",&t);at[i]+=(1<<j)*t;}}at[1]-=(1<<k);
    up=(1<<m);zt[++ct]=0;book[0]=true;//先把表格转化成二进制集合，钦定自己不可以攻击自己的 
    for(int i=1;i<up;i++)//然后处理每个集合可以攻击的集合 
    {
        for(int j=0,p=i;p;p>>=1,j++)
        {
            if((p&1)==0){continue;}
            att[0][i]|=(j<k)?at[0]>>(k-j):at[0]<<(j-k);
            att[1][i]|=(j<k)?at[1]>>(k-j):at[1]<<(j-k);
            att[2][i]|=(j<k)?at[2]>>(k-j):at[2]<<(j-k);
        }
    }
    for(int i=1;i<up;i++){if((i&att[1][i])==0){zt[++ct]=i;}}//判定一下合法的状态 
    for(int p1=1;p1<=ct;p1++)//然后判断两个状态是否可以转移 
    {
        for(int p2=1;p2<=ct;p2++)
        {if((att[2][zt[p1]]&zt[p2])==0&&(att[0][zt[p2]]&zt[p1])==0){tr.mp[p1][p2]++;}}
    }
    for(int i=1;i<=ct;i++){res.mp[i][i]=1;}st.mp[1][1]=1;//矩阵快速幂 
    for(;n;n>>=1,tr*=tr){if(n&1){res*=tr;}}st*=res;
    for(int i=1;i<=ct;i++){ans+=st.mp[1][i];}printf("%u",ans);return 0;//拜拜程序~ 
}
```

```


---

## 作者：8atemak1r (赞：7)

这篇文章是给像我一样初学矩阵优化 dp，然后看其他大佬写的题解看的一脸雾水的蒟蒻看的，所以比较详细，语文水平不好还请多多包涵

---
## Solution

先用状压 dp 的思路分析，每一行的摆放状态可以压成一个二进制数，根据给出矩阵的第二行可以预处理出每一行合法的状态集合 $S$，再 dfs / 瞎搞出相邻行的合法转移，设 $f_{i,sta}$ 表示第 $i$ 行的状态是 $sta$ 时的方案总数，$check_{sta,nxt}$ 表示上一行的状态为 $sta$，下一行的状态为 $nxt$ 是否合法，则转移方程显然：
$$
f_{i,sta}=\sum_{pre\in S} check_{pre,sta}f_{i-1, pre}
$$
问题是，这样转移的时间复杂度为 $O(n2^{2m})$，大概是在 4e9 的级别，无法接受。

注意到每一层的转移都是相同的，于是我们可以考虑用矩阵快速幂优化。

为了方便描述，我们将 $S$ 构成的序列称作 $p_1, p_2, \dots, p_{size}$，设矩阵 $A^k$ 中 $a_{i,j}$ 表示状态 $a_i$ 经过 $k$ 行转移到状态 $a_j$ 的方案总数，则初始矩阵为 
$$
a_{i,j} = check_{p_i,p_j}
$$
再来看转移矩阵，考虑等式 $A^p\times A^q=A^{p+q}$，令 $B=A^q$，$C=A^{p+q}$，则我们想做到 $c_{i,j}=\sum^{size}_{k=1}a_{i,k}b_{k,j}$，注意到这个式子恰好符合矩阵乘法的定义，所以转移矩阵与初始矩阵相同，接下来矩阵快速幂即可。

注意到第 $1$ 行到第 $n$ 行转移了 $n-1$ 次，所以指数要等于 $n-1$。

## Code

```cpp
#include<bits/stdc++.h>
#define int unsigned int
const int maxn = 1000006, maxm = 6;
int n, m, p, K, len, siz;
int att[3];
std :: vector<int> fst;
int cal(int x, int p, int ik) {
    if(p <= ik) 
        return x << (ik - p);
    return x >> (p - ik);
}
bool check(int x) {
    int tmp = x;
    for(int i = 0; tmp >> i; ++ i) {
        if((x & (1 << i)) == 0) continue;
        if((x & cal(att[1], p, i + K)) & ((len - 1) ^ (1 << i))) 
            return false;
    }
    return true;
}//一行内是否合法
bool con(int x, int y) {
    x ^= y ^= x ^= y;
    int tmp = x;
    for(int i = 0; i < m; ++ i) {
        if((x & (1 << i)) == 0) continue;
        if(y & cal(att[2], p, i + K)) 
            return false;
    }     
    tmp = y;
    for(int i = 0; i < m; ++ i) {
        if((y & (1 << i)) == 0) continue;
        if(x & cal(att[0], p, i + K))
            return false;
    }    
    return true;
}//相邻两行是否合法
struct matrix {
    int m[(1 << maxm) + 5][(1 << maxm) + 5], a, b;
    matrix (int x, int y) {
        a = x; b = y;
        for(int i = 1; i <= a; ++ i)
            for(int j = 1; j <= b; ++ j)
                m[i][j] = 0;
    }
    matrix friend operator *  (matrix x, matrix y) {
        matrix ans(x.a, y.b);
        for(int i = 1; i <= x.a; ++ i)
            for(int k = 1; k <= y.a; ++ k) {
                int s = x.m[i][k];
                for(int j = 1; j <= y.b; ++ j)
                    ans.m[i][j] = (ans.m[i][j] + s * y.m[k][j]);
            }
        return ans;
    }
};
matrix ksm(matrix base, int p) {
    matrix res(siz, siz);
    for(int i = 1; i <= siz; ++ i) res.m[i][i] = 1;
    while(p) {
        if(p & 1) res = base * res;
        base = base * base; p >>= 1;
    }
    return res;
}   
signed main() {
    std :: cin >> n >> m >> p >> K; ++ K;
    len = 1 << m;
    for(int i = 0; i < 3; ++ i)
        for(int j = 1, tmp; j <= p; ++ j)
            att[i] <<= 1, std :: cin >> tmp, att[i] |= tmp;
    fst.push_back(0x7fffffff);
    for(int i = 0; i < len; ++ i)
        if(check(i)) fst.push_back(i);
    siz = fst.size() - 1; 
    matrix zy(siz, siz);
    for(int i = 1; i <= siz; ++ i) 
        for(int j = 1; j <= siz; ++ j)
            if(con(fst[i], fst[j]))
                zy.m[i][j] = 1;
    matrix res = ksm(zy, n - 1);
    int ans = 0;
    for(int i = 1; i <= siz; ++ i) {
        for(int j = 1; j <= siz; ++ j)
            ans += res.m[i][j];
    }
    std :: cout << ans;
    return 0;
}
```



---

## 作者：CYJian (赞：6)

这道题~~怕是一道假黑题~~。。

首先看到这个$m$的大小就会发现可以状压。。

我们首先可以考虑设置状态$f[i][j]$表示第$i$行棋的摆放方式为$j$时合法的方案数，然后再枚举$k$为下一行的状态，如果$j$和$k$相邻摆放的时候棋子不会互相攻击的话，我们就可以这么转移一下:

$f[i+1][k]=(f[i+1][k]+f[i][j])\ \%\ mod$

但是算一下时间复杂度:

$O(N*2^{2M}=10^6*2^{12} \thickapprox 4*10^9)$

完美爆炸。。

这样最多做掉$50\%$的数据。。

那么$100\%$的数据呢？

经过观察，我们可以发现相邻两行之间的转移实际上是**定向**的。

何谓定向？

定向，就是不管当前是在哪一个阶段，我们转移的方向不会因为阶段而改变。

比如说这道题，当攻击矩阵已知的时候，对于任何一个自身并不矛盾的行的状态$j$来说，它所能转移的下一行的状态肯定是某些确定的状态。

而且对于这种定向的转移，我们拥有一个堪称完美的武器可以解决这种DP超时的问题——矩阵快速幂。

我们只要有了存储了转移方向及转移时需要乘上去的常数的矩阵和初始状态，那么我们就可以用初始状态$*$矩阵A的$n$次幂就可以解决问题了。

这样的时间复杂度就是:

$O(2^{3M}*log_2N \thickapprox 2.5*10^5*20=5*10^6)$

~~完美解决~~

---

## 作者：i207M (赞：6)

## 题目总结

给定一个棋子的攻击范围（3行），求$N*M$棋盘中放置棋子的方案数（取模）

## 数据范围

1 ≤ n ≤ 1000000，1 ≤ m ≤ 6

## 解题思路

首先，出题人可能脑子有坑，编号从零开始都没说！

看到如此小的M，自然想到状态压缩；

因为一个棋子只对上中下三行有影响，所以只用状压一行；

M非常小，有效状态<=64个，所以直接DFS求出一行内满足要求的摆放状态；

然后考虑行与行状态的转移，显然我们可以枚举状态；这时可以矩阵快速幂优化；

如果一个状态能转移到另一个状态（即棋子不能相互攻击），那么就将此处的转移矩阵设为1；然后快速幂一下；

注意一下初始矩阵，应该是$f[0][0]=1$，所以要乘以转移矩阵的N次方；统计答案时，把最后一行所有情况加起来即可；

## 易错误区

N次方不是N-1！

这道题很考验位运算的技巧，好好计算不要差错

## 代码展示

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cmath>
#include<cstring>
#include<string>
#include<algorithm>
#include<vector>
#include<map>
#include<set>
#include<list>
#include<queue>
#include<stack>
#include<bitset>
#include<deque>
using namespace std;
#define ll long long
#define ull unsigned long long
#define inf 0x3f3f3f3f
#define ri register int
#define il inline
#define fi first
#define se second
#define mp make_pair
#define pi pair<int,int>
#define mem0(x) memset((x),0,sizeof (x))
#define mem1(x) memset((x),0x3f,sizeof (x))
il char gc() {
    static const int BS = 1 << 22;
    static unsigned char buf[BS], *st, *ed;
    if (st == ed) ed = buf + fread(st = buf, 1, BS, stdin);
    return st == ed ? EOF : *st++;
}
#define gc getchar
template<class T>void in(T &x)
{
    x = 0; bool f = 0; char c = gc();
    while (c < '0' || c > '9') {if (c == '-') f = 1; c = gc();}
    while ('0' <= c && c <= '9') {x = (x << 3) + (x << 1) + (c ^ 48); c = gc();}
    if (f) x = -x;
}
#undef gc
void out(int x) {
    if (x < 0) putchar('-'), x = -x;
    if (x > 9) out(x / 10);
    putchar(x % 10 + '0');
}
#define int ull
int n, m, k, p;
int atm[5][8], atk[5], atd;
int zt[1000], cnt;
il void print(int x){
	cout<<bitset<6>(x)<<endl;
}
bool check(int z){
	for (ri i = 1, t,tz=z; i <= m &&tz; i++, tz >>= 1) {
        if (tz & 1) {
            t = atk[2];
            if (p - k < i) t <<= i - p + k;
            else if (p - k > i) t >>= p - k - i;
            t>>=1;
            if (z & t) return 0;
        }
    }
    return 1;
}
void dfs(int k, int z) {
    if (k == m) {
        if(check(z)) zt[++cnt] = z;
        return;
    }
    dfs(k + 1, z<<1);
    dfs(k + 1, z<<1|1);
}
#define Maxsz 70
#define md ((ull)1<<32)
void mod(int &x) {
    while (x > md) x -= md;
    while (x < 0) x += md;
}
struct Mat {
    int sz;
    int m[Maxsz][Maxsz];
    il void clear() {mem0(m);}
    Mat () {sz = 0; clear();}
    Mat operator*(const Mat &x)const {
        Mat res; res.sz = sz;
        for (ri i = 1; i <= sz; i++) {
            for (ri k = 1; k <= sz; k++) {
                for (ri j = 1; j <= sz; j++)
                    mod(res.m[i][j] += m[i][k] * x.m[k][j] % md);
            }
        }
        return res;
    }
    void operator*=(const Mat &x) {
        *this = (*this) * x;
    }
    void print() {
        for (ri i = 1; i <= sz; i++) {
            for (ri j = 1; j <= sz; j++)
                printf("%lld ", m[i][j]);
            puts("");
        }
    }
    void toe() {
        clear();
        for (ri i = 1; i <= sz; i++) {
            m[i][i] = 1;
        }
    }
    Mat qpow(int x) {
        Mat res = *this, mul = res; x--;
        for (; x; x >>= 1, mul *= mul) if (x & 1) res *= mul;
        return res;
    }
};
il bool judge(int nx, int ny) {
    int x = zt[nx], y = zt[ny];
    for (ri i = 1, t, tx = x; i <= m && x; i++, tx >>= 1) {
        if (tx & 1) {
            t = atk[3];
            if (p - k < i) t <<= i - p + k;
            else if (p - k > i) t >>= p - k - i;
            t>>=1;
            if (y & t) return 0;
        }
    }
    for (ri i = 1, t, ty = y; i <= m && y; i++, ty >>= 1) {
        if (ty & 1) {
            t = atk[1];
            if (p - k < i) t <<= i - p + k;
            else if (p - k > i) t >>= p - k - i;
            t>>=1;
            if (x & t) return 0;
        }
    }
    return 1;
}
Mat dp;
int ans;
signed main() {
    in(n), in(m), in(p), in(k);
    k++;
    for (ri i = 1, t; i <= 3; i++) {
        for (ri j = 1; j <= p; j++) {
            in(t);
            atm[i][j] = t;
        }
    }
    atm[2][k] = 0;
    for (ri j = 1; j <= 3; j++)
        for (ri i = 1; i <= p; i++)
            (atk[j] <<= 1) |= atm[j][i];
    atd = atk[2] % (1 << (k - 1));
    dfs(0, 0);
    dp.sz = cnt;
    for (ri i = 1; i <= cnt; i++) {
        for (ri j = 1; j <= cnt; j++) {
            if (judge(i, j)) dp.m[i][j]++;
        }
    }
    dp = dp.qpow(n);
    for (ri i = 1; i <= cnt; i++) mod(ans += dp.m[1][i]);
    printf("%llu", ans);
    return 0;
}
```

---

## 作者：codwarm (赞：4)

怎么题解都用矩阵加速 dp，其实本题加个滚动数组就能过。

观察到 $m \le 6$，可以想到用状压。需要注意的是本题下标从 $0$ 开始，即棋子在模板中间一行。观察到棋子只会影响到前一行的棋子。因此设 $\large {f_{i,st}}$ 表示考虑前 $i$ 行，且第 $i$ 行状态为 $st$ 的方案数。

首先我们需要考虑一行内的所有合法状态，然后根据一行内每一个合法状态再预处理出对应的前一行的合法状态并记录下来。这一步要细心一点，根据棋子在模板中的位置，判断状态是否合法。

令 $S_{st}$ 为可以满足 $st$ 为第一行的前一行合法状态集合。

则转移为:
$$\large{f_{i-1,S_{st}} \rightarrow f_{i,st}}$$

此时会发现爆空间了，然后滚动一下 $i$ 这一维就做完了。

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define INF 0x3f3f3f3f
#define re register
#define int unsigned int
#define PII pair<int,int>
int read()
{
	int f=1,k=0;char c = getchar();
	while(c <'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
	while(c>='0'&&c<='9')k=(k<<1)+(k<<3)+(c^48),c=getchar();
	return k*f;
}

const int N = 1e6+5;

int n,m,p,k;

int mb[5][15];

int f[N][75];

int num[515];

vector<int> good,goode2[75];
bool fk[N],fk2[N];
bool pd(int e2,int e) // 判断 e2 对 e 是否有影响
{
	memset(fk2,0,sizeof fk2);
	for (int i = 1;i <= m;i++) num[i] = e2 >> (i-1) & 1;
	for (int i = 1;i <= m;i++)
	{
		if (num[i])
		{
			for (int j = 1,l = i-(k-1);j <= p;j++,l++)
			{
				if (l < 1 || l > m) continue;
				fk2[l] |= mb[3][j];
			}
		}
	}
	
	for (int i  = 1;i <= m;i++) if (((e >> (i-1)) & 1) && fk2[i]) return 1;
	return 0;
	
}

void prework() // 预处理出e2 e
{
	for (int e = 0;e < (1u << m);e++)
	{
		bool flag = 1;
		for (int i = 1;i <= m;i++) num[i] = e >> (i-1) & 1;
		for (int i = 1;i <= m;i++)
		{
			if (num[i])
			{
				for (int j = k-1,l = i-1;j >= 1;j--,l--)
				{
					if (l < 1) break;
					if (mb[2][j] && num[l]) 
					{
						flag = 0;
						break;
					}
				}
				for (int j = k + 1,l = i + 1;j <= p;j++,l++)
				{
					if (l > m) break;
					if (mb[2][j] && num[l])
					{
						flag =0;
						break;
					}
				}
			}
		}
		if (flag) good.push_back(e);
	}
	
	for (int e : good)
	{
		memset(fk,0,sizeof fk);
		for (int i = 1;i <= m;i++) num[i] = e >> (i-1) & 1;
		for (int i = 1;i <= m;i++)
		{
			if (num[i])
				for (int j = 1,l = i-(k-1);j <= p;j++,l++)
				{
					if (l < 1 || l > m) continue;
					fk[l] |= mb[1][j];
				}
		}
		for (int e2 : good)
		{
			bool flag = 1;
			
			for (int i = 1;i <= m;i++) 
				if (((e2 >> (i-1)) & 1) && (fk[i] == 1)) 
				{flag = 0;break;}
			
			if (!flag) continue;
			if (!pd(e2,e))	goode2[e].push_back(e2);
		}
	}
	
}	

signed main()
{
	cin >> n >> m >> p >> k;
	k++;
	for (int i = 1;i <= 3;i++)
		for (int j =  1;j <= p;j++) 
			mb[i][j] = read();
	prework();
	for (int e : good)
	{
		for (int i = 1;i <= m;i++) num[i] = e >> (i-1) & 1;
		for (int e2 : goode2[e]) for (int i = 1;i <= m;i++) num[i] = e2 >> (i-1) & 1;
	}
	f[0][0] = 1;
	for (int i =1 ;i <= n;i++)
	{
		memset(f[i%3],0,sizeof f[i % 3]); // 滚动数组清空	
		for (int e : good)
			for (int e2 : goode2[e])
				f[i % 3][e] += f[(i-1+3) % 3][e2]; 
	}	
	int ans = 0;
	for (int e : good) ans += f[n % 3][e];
	cout << ans << endl;
	return 0;
}
```

---

## 作者：TernaryTree (赞：2)

为啥大家都会矩阵快速幂，像我这种菜比就只会暴力过题呜呜。

因为棋子在中间一行，所以我们 dp 只需要记一行的状态。$f_{i,S}$ 表示考虑了 $1\sim i$ 行，第 $i$ 行放的棋子的状态是 $S$ 的方案数。转移枚举 $T$ 表示 $i-1$ 行的状态，若 $T$ 与 $S$ 不冲突则转移。

我们可以处理出 $S$ 自身会不会让同一行的棋子相互攻击到，然后再处理出 $S$ 和 $T$ 在上下两行时会不会相互攻击，得到朴素的 $n4^m$ 转移。

看起来很过不去，但是我们充分发挥人类智慧，注意到 $S\to T$ 的转移不会很多，所以我们把所有转移拿出来跑就行。但是开 $n2^m$ 的数组会 MLE，滚动数组一下就行了。最大点 162ms，飞快。

---

## 作者：chihik (赞：2)

你得知道题目下表是从 $0$ 开始编号，那么每个棋子只能控制与它距离不大于 $1$ 的行。

所以只需压当前这一行的状态，令 $dp(i,S)$ 表示前 $i$ 行棋子，第 $i$ 的摆放状态为 $S$ 的方案。

那么有转移：

$$dp(i,S)=\sum_{last} dp(i-1,last)$$

转移需要保证 $S,last$ 的两行棋子不冲突，这也是本题的难点。

首先可以处理摆放棋子后不能再摆棋子的位置的二进制。（其实就是输入的模板取反。）

- 判断两行是否冲突

1. 找到第一行的所有 '1'

2. 将 '1' 和 $k$ 对齐后，如果第二行和不能再摆棋子的位置有重合部分则不合法。

同理用第二行判断第一行。

- 判断同行是否冲突

直接看成两行按上述方法比较。

注意第 $k$ 位一定为 $1$ ，会误判为重合，直接减去就可以了。

***

因为转移是一样的，所以可以用矩阵加速这个过程。

可以通过预处理合法的行来降低时间，不过复杂度最坏还是$\mathcal O(({2^{m}})^3 \log n)= \mathcal O(8^m \log n)$

```cpp
#include <cstdio>
#define uint unsigned int

const int MAXM = 6;

int n , m , p , k , ban[ 3 ];
int Cnt , rS[ ( 1 << MAXM ) + 1 ];

struct Matrix {
	int n , m; uint a[ ( 1 << MAXM ) + 1 ][ ( 1 << MAXM ) + 1 ];

	Matrix operator * ( const Matrix &oth ) const {
		Matrix Ans = {}; Ans.n = n , Ans.m = oth.m;
		for( int i = 1 ; i <= Ans.n ; i ++ )
			for( int j = 1 ; j <= Ans.m ; j ++ )
				for( int k = 1 ; k <= m ; k ++ )
					Ans.a[ i ][ j ] += a[ i ][ k ] * oth.a[ k ][ j ];
		return Ans;
	}
	Matrix Quick_pow( Matrix x , int po ) {
		Matrix Ans = {}; Ans.n = x.n , Ans.m = x.m;
		for( int i = 1 ; i <= x.n ; i ++ ) Ans.a[ i ][ i ] = 1;
		for( ; po ; po >>= 1 , x = x * x )
			if( po & 1 ) Ans = Ans * x;
		return Ans;
	}
}St , Trans , Ed;

bool check1( int S ) {
	for( int i = 0 ; i < m ; i ++ )
		if( ( S >> i ) & 1 ) {
			if( i == k && ( S & ban[ 1 ] ^ ( 1 << k ) ) ) return 0;
			if( i < k && ( ( S << ( k - i ) ) & ban[ 1 ] ^ ( 1 << k ) ) ) return 0;
			if( i > k && ( ( S >> ( i - k ) ) & ban[ 1 ] ^ ( 1 << k ) ) ) return 0;
		}
	return 1;
}

bool check2( int S1 , int S2 ) {
	for( int i = 0 ; i < m ; i ++ )
		if( ( S1 >> i ) & 1 ) {
			if( i <= k && ( ( S2 << ( k - i ) ) & ban[ 2 ] ) ) return 0;
			if( i > k  && ( ( S2 >> ( i - k ) ) & ban[ 2 ] ) ) return 0;
		}
	for( int i = 0 ; i < m ; i ++ )
		if( ( S2 >> i ) & 1 ) {
			if( i <= k && ( ( S1 << ( k - i ) ) & ban[ 0 ] ) ) return 0;
			if( i > k  && ( ( S1 >> ( i - k ) ) & ban[ 0 ] ) ) return 0;
		}
	return 1;
}

void InitS( ) {
	for( int S = 0 ; S < 1 << m ; S ++ )
		if( check1( S ) ) rS[ ++ Cnt ] = S;
}

int main( ) {
	scanf("%d %d",&n,&m);
	scanf("%d %d",&p,&k);
	for( int i = 0 , x ; i < 3 ; i ++ )
		for( int j = 0 ; j < p ; j ++ )
			scanf("%d",&x) , ban[ i ] |= ( x << j );

	InitS( );

	St.n = 1 , St.m = Cnt;
	St.a[ 1 ][ 1 ] = 1;

	Trans.n = Trans.m = Cnt;
	for( int i = 1 ; i <= Cnt ; i ++ )
		for( int j = 1 ; j <= Cnt ; j ++ )
			Trans.a[ i ][ j ] = check2( rS[ i ] , rS[ j ] );
	
	Ed = St * Trans.Quick_pow( Trans , n );

	uint Ans = 0;
	for( int dS = 1 ; dS <= Cnt ; dS ++ )
		Ans += Ed.a[ 1 ][ dS ];
	printf("%u\n", Ans );
	return 0;
}
```


---

## 作者：DiruiXiao (赞：1)

# [P3977 [TJOI2015]棋盘](https://www.luogu.com.cn/problem/P3977)

题目给出了一个 $n$ 行 $m$ 列的棋盘。可以在上面摆放棋子，要求出让所有棋子互不攻击的方案总数。

查看数据范围发现 $m$ 很小，可以考虑枚举所有方案。直接枚举较为麻烦，考虑状态压缩。令 $x$ 为当前状态， 2进制下若第 $k$ 为 $1$ 则表示第 $k$ 当前有棋子。因此只需从 $1$ 挨个枚举到 $(1 << m) - 1$。

答案求方案数，考虑状压DP，令 $F(i, j)$ 为前 $j$ 行状态为 $i$ 的方案数个数。则有 $F(i, j) = \sum F(k, j - 1) (k \in S)$ 其中 $S$ 为所有能够转移到 $i$ 的状态集合。因此只需考虑求出 $S$ 即可。而 $S$ 则可以直接枚举两排的状态来暴力判断即可。

由于 $S$ 只与 $i$ 有关，因此可以在预处理中完成。此时的时间复杂度为 $O(n\cdot 2^m)$。 由于 $n$ 过大，肯定会超时。因此考虑优化。

因为 $S$ 只与 $i$ 有关， 因此每次 $i$ 都是从固定的前一个状态转移而来。可以构造出一个转移矩阵 $T$，使得包含 $2^m$ 个状态的原矩阵 $O$ 能通过与 $T$ 做矩阵乘法转移到下一种状态。即最终的矩阵为 $O \cdot T ^ {n - 1}$ 的运算结果。最后在使用矩阵快速幂优化，使时间复杂度降到 $O(K^3logn \cdot 2^m)$。其中 $K$ 为矩阵大小。

但直接构造矩阵常数较大，可以考虑只将合法的排列加入，可以减小 $K$ 的值。

注：题目要求对 $2^{32}$ 取模，可以直接用 `unsigned int` 的自然溢出，会比取模快。 

贴下代码

```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#define MAXN 100005
using namespace std;
int cnt = 0, rev[MAXN]; // rev 数组记录了当是第 i 个可行解的原状态值。
typedef unsigned int uint;

template<typename T>
inline void read(T &x) {
	char ch = getchar();
	x = 0;
	while (ch < '0' || ch > '9') {
		ch = getchar();
	}
	while (ch <= '9' && ch >= '0') {
		x = (x << 1) + (x << 3) + (ch ^ 48);
		ch = getchar();
	}
}

int n, m, p, k, atk[4]; // 攻击的模式

bool check(int x) { // 检查对于状态 x 是否合法
	for (int i = 0; i <= m; ++i) {
		if ((x >> i) & 1) {
			if (i - k < 0) {
				if (x & (atk[1] >> (k - i))) return false;
			} else {
				if (x & (atk[1] << (i - k))) return false;
			}
		}
	}
	return true;
}

bool check_two_layer(int x, int y) { // 检查 x, y 状态能否转移
	for (int i = 0; i <= m; ++i) {
		if ((x >> i) & 1) {
			if (i - k < 0) {
				if (y & (atk[2] >> (k - i))) return false;
			} else {
				if (y & (atk[2] << (i - k))) return false;
			}
		}
	}
	for (int i = 0; i <= m; ++i) {
		if ((y >> i) & 1) {
			if (i - k < 0) {
				if (x & (atk[0] >> (k - i))) return false;
			} else {
				if (x & (atk[0] << (i - k))) return false;
			}
		}
	}
	return true;
}

struct Matrix { // 矩阵类
	uint a[70][70];
	int W, H;
	Matrix() {
		W = H = 0;
		memset(a, 0, sizeof(a));
	}
	Matrix(int w, int h) {
		W = w, H = h;
		memset(a, 0, sizeof(a));
	}
	void makeMatrix() {
		int K = min(H, W);
		memset(a, 0, sizeof(a));
		for (int i = 0; i < K; ++i) a[i][i] = 1;
	}
	void print() {
		puts("-------------");
		for (int i = 0; i < H; ++i) {
			for (int j = 0; j < W; ++j) {
				printf("%d ", a[i][j]);
			}
			putchar('\n');
		}
		puts("-------------");
	}
};

Matrix trans, origin;

Matrix mul(Matrix a, Matrix b) { // 矩阵乘法
	Matrix ans;
	ans.H = a.H, ans.W = b.W;
	for (int i = 0; i < a.H; ++i) {
		for (int j = 0; j < b.W; ++j) {
			for (int k = 0; k < a.W; ++k) {
				ans.a[i][j] += a.a[i][k] * b.a[k][j];
			}
		}
	}
	return ans;
}

void prework() { // 预处理转移方式
	int lim = ((1 << m) - 1);
	for (int i = 0; i <= lim; i++) {
		if (!check(i)) continue;
		rev[++cnt] = i;
		origin.a[0][i] = 1; // 只有可行解才加入矩阵
	}
	for (int i = 1; i <= cnt; ++i) {
		for (int j = 1; j <= cnt; ++j) {
			if (check_two_layer(rev[i], rev[j])) {
				trans.a[i - 1][j - 1] = 1; // 构造转移矩阵
			}
		}
	}
}

Matrix quick_pow(Matrix a, int b) { // 矩阵快速幂
	Matrix ans; ans.H = a.H, ans.W = a.W;
	ans.makeMatrix(); // 构造单位矩阵
	while (b) {
		if (b & 1) {
			ans = mul(ans, a);
		}
		a = mul(a, a);
		b >>= 1;
	}
	return ans;
}

int main() {
	read(n), read(m), read(p), read(k);
	for (int i = 0; i < 3; ++i) {
		for (int j = 0; j < p; ++j) {
			int re; read(re);
			if (j == k && i == 1) continue; // 对于自己的位置不攻击 - 不然判断会出bug...
			atk[i] |= (re << j); // 读入攻击状态并压缩，以便于判断
		}
	}
	prework();
	origin.H = 1, origin.W = cnt; trans.H = cnt, trans.W = cnt;

	Matrix mi = quick_pow(trans, n - 1);
	for (int i = 0; i < cnt; ++i) {
		origin.a[0][i] = 1; // 因为加入矩阵的一定是可行解，因此初始放安均为 1
	}
	Matrix ans = mul(origin, mi);
	uint res = 0;
	for (int i = 0; i < cnt; ++i) {
		res += ans.a[0][i]; // 统计答案
	}
	printf("%u", res);
	return 0;
}
```


---

## 作者：antimo (赞：1)

[传送门](https://www.luogu.com.cn/problem/P3977)  
早该学学状压DP了  
可是谁能想到一来就遇到这么毒瘤的题呢

发现$m$很小，可以状压，一行最多64种状态  
用$f[i][j]$表示第$i$行，状态为$j$的总方案数  
若状态$k$能转移到$j$，有转移：
$$
f[i][j]=\sum f[i-1][k]
$$

考虑优化：  
转化为矩阵  
矩阵$A_{i,j}=1$表示$i\to j$转移  
考虑转移$i\to j\to k$，显然这是个矩阵乘法  
转移$n$次求和得到答案（状态1转移到每个状态）

```cpp
#include<bits/stdc++.h>
using namespace std;
#define in Read()
int in{
	int i=0,f=1;char ch=0;
	while(!isdigit(ch)&&ch!='-') ch=getchar();
	if(ch=='-') ch=getchar(),f=-1;
	while(isdigit(ch)) i=(i<<1)+(i<<3)+ch-48,ch=getchar();
	return i*f;
}

typedef unsigned int unt;
const int N=100;
unt n,m,xx[N],yy[N],cnt,sta[N],tot,p,k,result;

struct Mat{
    unt mat[N][N];

    friend inline Mat operator * (const Mat a,const Mat b){
        Mat res;
        for(int i=1;i<=64;++i)
            for(int j=1;j<=64;++j)
                res.mat[i][j]=0;
        for(int i=1;i<=64;++i)
            for(int j=1;j<=64;++j)
                for(int k=1;k<=64;++k)
                    res.mat[i][j]+=a.mat[i][k]*b.mat[k][j];
        return res;
    }
}ans,s;

Mat qpw(Mat a,unt b){
    Mat res;
    res.mat[1][1]=1;
    while(b){
        if(b&1) res=res*a;
        a=a*a;
        b>>=1;
    }
    return res;
}

bool check(int x,int y){
    for(int i=0;i<m;++i){
        if(x&(1<<i)){
            for(int j=1;j<=cnt;++j){
                int tmp=i+yy[j];
                if(tmp>=m) continue;
                if(xx[j]==0){
                    if(x&(1<<tmp)) return false;
                }else if(xx[j]==1){
                    if(y&(1<<tmp)) return false;
                }
            }
        }
        if(y&(1<<i)){
            for(int j=1;j<=cnt;++j){
                int tmp=i+yy[j];
                if(tmp>=m) continue;
                if(xx[j]==0){
                    if(y&(1<<tmp)) return false;
                }else if(xx[j]==-1){
                    if(x&(1<<tmp)) return false;
                }
            }
        }
    }
    return true;
}

int main(){
    n=in,m=in,p=in,k=in;
    for(int i=0;i<3;++i)
        for(int j=0;j<p;++j){
            int x=in;
            if(x==1&&(i!=1||j!=k)){
                ++cnt;
                xx[cnt]=i-1;
                yy[cnt]=j-k;
            }
        }
    for(int i=0;i<(1<<m);++i)
        if(check(i,0)) sta[++tot]=i;
    for(int i=1;i<=tot;++i)
        for(int j=1;j<=tot;++j)
            if(check(sta[i],sta[j])) s.mat[i][j]=1;
    ans=qpw(s,n);
    for(int i=1;i<=tot;++i)
        result+=ans.mat[1][i];
    printf("%u\n",result);
    return 0;
}
```

---

## 作者：SpringFullGarden (赞：0)

## 题意

**题目中的所有编号都是从 $0$ 开始！！！**

有一个 $n$ 行 $m$ 列的棋盘，每个棋子的攻击范围是 $3$ 行 $p$ 列，棋子在中间一行，第 $k$ 列，棋子不能互相攻击到，求摆放棋子的方案数。

## 思路

发现 $m \le 6$，所以考虑状压 dp。

先预处理出所有合法的状态 $s$。设 $dp_{i,s}$ 表示第 $i$ 行状态为 $s$ 的方案数，则 $dp_{i,s} = \sum\limits_{t\in V_s} dp_{i - 1, t}$，这里集合 $V_s$ 代表不会被状态 $s$ 攻击到的状态集合，可以预处理出来或者 dp 时进行判断。

但是这样时间复杂度是 $O(2^{2m}n)$ 的，会超时，考虑优化。

观察到 $dp_{i,s}$ 只与 $dp_{i - 1, t}$ 有关，所以考虑矩阵快速幂优化。

设 $f_{s,t}$ 表示状态 $t$ 是是否属于 $V_s$，则转移矩阵为：

$$
\begin{bmatrix}
 dp_{i,0} & dp_{i,1} & \cdots & dp_{i,2^m-1} 
\end{bmatrix}
\times
\begin{bmatrix}
 f_{1, 1} & f_{2, 1} & \cdots & f_{2^m-1,1} \\
 f_{1, 2} & f_{2, 2} & \cdots & f_{2^m-1,2} \\
 \vdots \\
 
 f_{1, 2^m-1} & f_{2, 2^m-1} & \cdots & f_{2^m-1,2^m-1} \\
\end{bmatrix}
= 
\begin{bmatrix}
 dp_{i+1,0} & dp_{i+1,1} & \cdots & dp_{i+1,2^m-1} 
\end{bmatrix}
$$

第一行可以预处理出来，状态 $s$ 合法就为 $1$，否则为 $0$，所以只用转移 $n - 1$ 次：

$$
\begin{bmatrix}
 dp_{1,0} & dp_{1,1} & \cdots & dp_{1,2^m-1} 
\end{bmatrix}
\times
\begin{bmatrix}
 f_{1, 1} & f_{2, 1} & \cdots & f_{2^m-1,1} \\
 f_{1, 2} & f_{2, 2} & \cdots & f_{2^m-1,2} \\
 \vdots \\
 
 f_{1, 2^m-1} & f_{2, 2^m-1} & \cdots & f_{2^m-1,2^m-1} \\
\end{bmatrix}^{n-1}
= 
\begin{bmatrix}
 dp_{n,0} & dp_{n,1} & \cdots & dp_{n,2^m-1} 
\end{bmatrix}
$$

最后答案为 $\sum\limits_{s = 0}^{2^m-1} dp_{n,s}$。

## 代码

```cpp
struct node {
    ll a[80][80];
} zero, one, f, g;
ll N, a[20];
const ll mod = (1ll << 32);
vector <ll> v;

node mul(node x, node y) {
    node res = zero;
    for(ll i = 0; i <= N; i++) 
        for(ll j = 0; j <= N; j++)
            for(ll k = 0; k <= N; k++)
                res.a[i][j] = (res.a[i][j] + x.a[i][k] * y.a[k][j] % mod) % mod;
    return res;
}
node pw(node x, ll y) {
    node res = one;
    while(y) {
        if(y & 1) res = mul(res, x);
        x = mul(x, x), y >>= 1;
    }
    return res;
}
signed main() {
    ll n = rd(), m = rd(), p = rd(), k = rd();
    N = (1 << m) - 1;
    for(ll i = 1; i <= 3; i++) 
        for(ll j = 0; j < p; j++) a[i] |= rd() * (1ll << j);
    for(ll s = 0; s <= N; s++) {
        one.a[s][s] = 1;
        ll flag = 1;
        for(ll i = 0; i < m; i++) {
            if(!((1 << i) & s)) continue;
            ll t = s;
            if(i < k) t <<= k - i;
            if(i > k) t >>= i - k;
            if((t & a[2]) != (1 << k)) flag = 0, i = m;
        }
        if(flag) v.push_back(s), g.a[1][s] = 1;  
    }
    for(ll s : v) for(ll t : v) {
        ll flag = 1;
        for(ll i = 0; i < m; i++) {
            if(!((1 << i) & t)) continue;
            ll tt = s;
            if(i < k) tt <<= k - i;
            if(i > k) tt >>= i - k;
            if(tt & a[1]) flag = 0, i = m;
        }
        for(ll i = 0; i < m; i++) {
            if(!((1 << i) & s)) continue;
            ll tt = t;
            if(i < k) tt <<= k - i;
            if(i > k) tt >>= i - k;
            if(tt & a[3]) flag = 0, i = m;
        }
        if(flag) f.a[t][s] = 1;
    }
    node res = mul(g, pw(f, n - 1));
    ll ans = 0;
    for(ll i = 0; i <= N; i++) ans = (ans + res.a[1][i]) % mod;
    cout << (ans + mod) % mod;
    return 0;
}
```

---

## 作者：TLE_AK (赞：0)

### 题意
给出一个 $n$ 行 $m$ 列的棋盘（$n \le 10^6,m \le 6$）与 $3$ 行 $p$ 列的棋子攻击范围，棋子本身在 $1$ 行 $k$ 列（从 $0$ 计数），求棋子互相不能攻击到的前提下，摆放棋子的方案数。  
## 思路
首先我们发现不寻常的 $m \le 6$，一种直接的方法是把每一个情况表示出来，那么每行最多有 $64$ 种可能的情况。

然后由于这是限定限制的~~技术~~计数问题，所以选择 dp 来解决问题：  
1. 考虑状态，一个直接的想法是设状态 $dp_{i,st}$ 表示第 $i$ 行二进制棋子表示为 $st$ 的方案数。  
2. 考虑转移，我们要知道每个状态可以从哪里转移来，发现与dp过程无关（不需要过程求）所以选择预处理（处理过程见代码）。
3. 最后考虑复杂度及其优化，预处理的复杂度为 $O(2^mm^2)$，dp 过程的复杂度 $O(n2^m)$，可以通过本题（也可使用矩阵快速幂优化）。

这样就做完了。
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ui unsigned int

namespace acac
{
	int n,m,sz;
	
	int read()
	{
		int ans=0,fs=1;
		char ch=getchar();
		while(ch<'0'||ch>'9')
		{
			if(ch=='-')fs*=-1;
			ch=getchar();
		}
		while(ch>='0'&&ch<='9')
		{
			ans=ans*10+ch-'0';
			ch=getchar();
		}
		return ans;
	}
	
	int mp[10][10],no[10]; 
	ui dp[3][70];
	
	vector<int>ve,S[100];
//所有合法情况，每种情况上一行可以是什么
	
	int main()
	{
		n=read(),m=read();
		int p=read(),k=read();
		for(int i=1;i<=3;i++)
		{
			for(int j=1;j<=p;j++)
			{
				mp[i][j]=read();
			}
		}
		int N=(1<<m)-1;
		for(int i=0;i<=N;i++)
		{
			int tf=1;
			//计算这一行的状态是否合法
			for(int j=1;j<=m;j++)
			{
				if((1<<(j-1))&i)
				{
					int xz=min(j+p-k-1,m);
					for(int l=max(j-k,1);l<=xz;l++)
					{
						if(l==j)continue;
						if(mp[2][l-(j-k)+1]&&((1<<(l-1))&i))tf=0;
					}
					if(!tf)break;
				}
			}
			if(!tf)continue;
			ve.push_back(i);
			
			
		}
		sz=ve.size();
		for(int i=0;i<sz;i++)
		{
			for(int j=1;j<=m;j++)
			{
				no[j]=0;
			}
      //预处理下面一行打上面一行的情况
			for(int j=1;j<=m;j++)
			{
				if((1<<(j-1))&ve[i])
				{ 
					int xz=min(j+p-k,m);
					for(int l=max(j-k,1);l<=xz;l++)
					{
						no[l]|=mp[1][l-(j-k)+1];												
					}
				}
			}
      //处理上面打下面的情况
			for(int j=0;j<sz;j++)
			{
				int tf=1;
				for(int l=1;l<=m;l++)
				{
					if(((1<<(l-1))&ve[j])&&no[l])tf=0;
					if(!((1<<(l-1))&ve[j]))continue;
					int xz=min(l+p-k-1,m);
					for(int a=max(l-k,1);a<=xz;a++)
					{
						if(mp[3][a-(l-k)+1]&&((1<<(a-1))&ve[i]))tf=0;
						
					}
				}
				if(tf)S[i].push_back(j);
			}
		}
//检查状态正确的代码，可以不写qwq
//		for(int i=0;i<sz;i++)
//		{
//			cout<<ve[i]<<": ";
//			for(int j=0;j<S[i].size();j++)
//			{
//				cout<<ve[S[i][j]]<<' ';
//			}
//			cout<<'\n';
//		}
		int pre=0,now=1;
		ui ans=0;
		dp[pre][0]=1;
//直接dp,滚动数组优化
		for(int i=1;i<=n;i++)
		{
			for(int j=0;j<sz;j++)
			{
				dp[now][j]=0;
			}
			for(int j=0;j<sz;j++)
			{
				for(int k=0;k<S[j].size();k++)
				{
					dp[now][j]+=dp[pre][S[j][k]];
				}
				if(n==i)ans+=dp[now][j];
			}
			swap(now,pre);
		}
		cout<<ans;
		return 0;
	}
}

int main()
{
	acac::main();
	return 0;
}
```

---

## 作者：封禁用户 (赞：0)

#### [题目传送门](https://www.luogu.com.cn/problem/P3977)

### 分析

一道比较明显的状态压缩 DP 题。

我们只要对它在这一行、这一行、下一行各压缩成攻击状态。

因为 $m \le 6$，所以状态数最多只有 $2^6$ 种，即 $64$ 种。（一种很强烈的暗示，这里埋个雷，之后再填）

流程：

1. 先预处理出合法的状态。

1. 再预处理出合法的转移。

1. 进行状态压缩 DP。

为了运算方便，我们定义一个 $P$ 函数，左移负数即右移其相反数。

### 代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define D(i,a,b) for(register int i=a;i>=b;--i)
#define F(i,a,b) for(register int i=a;i<=b;++i)
int n,m,p,k;
int b[3],g[70],cnt = 0;
unsigned int dp[1010][70]; 
bool ok[70][70];
inline int P(int x,int y)
{
	if(y >= 0) return x << y; 
	return x >> (-y);
}
inline bool check(int x,int y)
{
	F(i,0,m-1)
		if(x & 1 << i)
			if(b[2] & P(y,k-i))
				return 0;			
	F(i,0,m-1)
		if(y & 1 << i)
			if(b[0] & P(x,k-i))
				return 0;
	return 1;
}
int main()
{
	scanf("%d%d%d%d",&n,&m,&p,&k);
	k = p - 1 - k;
	F(i,0,2)
	{
		int x;
		F(j,0,p-1)
		{
			scanf("%d",&x);
			b[i] = b[i]<<1|x;	
		}
	}
	b[1] ^= 1<<k;
	F(i,0,(1<<m)-1)
	{
		bool flag = 1;
		F(j,0,m-1)
			if(i & 1<<j)
				if(P(b[1],j-k) & i)
				{
					flag = 0;
					break;
				}
		if(flag) g[++cnt] = i;
	}  
	F(i,1,cnt) dp[1][i] = 1ull;
	F(i,1,cnt)
		F(j,1,cnt)
			ok[i][j] = check(g[i],g[j]);
	F(t,2,n)
		F(i,1,cnt)
			F(j,1,cnt)
				if(ok[i][j])
					dp[t][i] += dp[t-1][j];
	unsigned int ans = 0;
	F(i,1,cnt) ans += dp[n][i];
	printf("%llu",ans);
	return 0;
}
```
### 局限性

可以看出，以上代码的最大时间复杂度为：$O(n \times 2 ^{2m})$，只能通过 $n \le 1000$ 的 $5$ 个点。

可以看出这题的转移比较类似，那么，对于 $n \le 10^6$ 的点，矩阵快速幂就呼之欲出了。

这也是为什么题目给了 $m \le 6$ 的条件。

### 正解

我们把所有的状态转移压缩成一个矩阵，一个合法的转移就在矩阵上标为 $1$，否则标为 $0$。

这个矩阵的 $n-1$ 次方的所有数字求和即为答案。

### AC 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
#define D(i,a,b) for(register int i=a;i>=b;--i)
#define F(i,a,b) for(register int i=a;i<=b;++i)
int n,m,p,k;
int b[3],g[70],cnt = 0;
inline int P(int x,int y)
{
	if(y >= 0) return x << y;
	return x >> (-y);
}//x << y 包含负数情况 
inline bool check(int x,int y)
{
	F(i,0,m-1)
		if(x & P(1,i))
			if(b[2] & P(y,k-i))
				return 0;			
	F(i,0,m-1)
		if(y & P(1,i))
			if(b[0] & P(x,k-i))
				return 0;
	return 1;
}
struct Mat
{
	unsigned int a[70][70];
	Mat()
	{
		memset(a,0,sizeof(a));
	}
	inline void friend operator*=(Mat &A,const Mat B)
	{
		Mat ans;
		F(i,1,cnt)
			F(l,1,cnt)
				F(j,1,cnt)
					ans.a[i][j] += A.a[i][l] * B.a[l][j];
		A = ans;
	}
};
inline Mat qp(Mat A,int x)
{
	Mat ans = A;
	--x;
	while(x)
	{
		if(x & 1) ans *= A;
		A *= A;
		x >>= 1;	
	} 
	return ans;
}
int main()
{
	scanf("%d%d%d%d",&n,&m,&p,&k);
	k = p - 1 - k;
	F(i,0,2)
	{
		int x;
		F(j,0,p-1)
		{
			scanf("%d",&x);
			b[i] = b[i]<<1|x;	
		}
	}
	b[1] ^= 1<<k;
	F(i,0,(1<<m)-1)
	{
		bool flag = 1;
		F(j,0,m-1)
			if(i & 1<<j)
				if(P(b[1],j-k) & i)
				{
					flag = 0;
					break;
				}
		if(flag) g[++cnt] = i;
	}  
	if(n == 1)
	{
		printf("%d",cnt);
		return 0;
	}
	Mat A;
	F(i,1,cnt)
		F(j,1,cnt)
			if(check(g[i],g[j]))
				A.a[j][i] = 1;//j -> i	
//	F(i,1,cnt)
//	{
//		F(j,1,cnt)
//			printf("%u ",A.a[i][j]);
//		putchar('\n');
//	}
	A = qp(A,n-1); 
	unsigned int ans = 0;
	F(i,1,cnt)
		F(j,1,cnt)
			ans += A.a[i][j];
	printf("%u",ans);
	return 0;
}
```



---

## 作者：complete_binary_tree (赞：0)

[原题传送门](https://www.luogu.com.cn/problem/P3977)

看到 $m \le 6$，考虑状压。

我们记状态 $f(i,j)$ 为第 $i$ 行状态为 $j$ 的方案数。

我们预处理 $g(i,j)$ 为上一行状态为 $i$ 这一行状态为 $j$ 是否可行。

那么转移是显然的，$f(i, j) = \sum_k f(i - 1, k)[g(k,j)=1]$。

这样的转移是 $O(2^{2n}n)$ 的，只能得到 $50$ 分。

考虑到转移方程与 $i$ 无关，矩阵快速幂优化到 $O(2^{3m} \log n)$。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N = 1e6 + 5, M = 10;

typedef unsigned int uint;

int n, m, p, k, can[4];

struct mat {
    uint a[1 << 6][1 << 6];
    void csh( int __ = 0 ) { memset( a, __, sizeof a ); }
    void build1() { for( int i = 0; i < ( 1 << 6 ); ++i ) a[i][i] = 1; }
    friend mat operator*( mat a, mat b ) {
        mat c; c.csh();
        for( int i = 0; i < ( 1 << 6 ); ++i ) {
            for( int j = 0; j < ( 1 << 6 ); ++j ) {
                for( int k = 0; k < ( 1 << 6 ); ++k ) {
                    c.a[i][j] += a.a[i][k] * b.a[k][j];
                }
            }
        }
        return c;
    }
};

mat ksm( mat a, int b ) {
    mat ans, x = a;
    ans.csh(); ans.build1();
    while( b ) {
        if( b & 1 ) ans = ans * x;
        x = x * x, b >>= 1;
    }
    for( int i = 0; i < ( 1 << 6 ); ++i ) {
        for( int j = 0; j < ( 1 << 6 ); ++j ) {}
    }
    return ans;
}

bool check( int i, int j ) {
    for( int _i = 0; _i < m; ++_i ) {
        if( i & ( 1 << _i ) ) {
            if( _i >= k ) {
                if( i & ( can[2] << ( _i - k ) ) ) return 0;
                if( j & ( can[3] << ( _i - k ) ) ) return 0;
            }
            else {
                if( i & ( can[2] >> ( k - _i ) ) ) return 0;
                if( j & ( can[3] >> ( k - _i ) ) ) return 0;
            }
        }
    }
    for( int _i = 0; _i <= m; ++_i ) {
        if( j & ( 1 << _i ) ) {
            if( _i >= k ) {
                if( j & ( can[2] << ( _i - k ) ) ) return 0;
                if( i & ( can[1] << ( _i - k ) ) ) return 0;
            }
            else {
                if( j & ( can[2] >> ( k - _i ) ) ) return 0;
                if( i & ( can[1] >> ( k - _i ) ) ) return 0;
            }
        }
    }
    return 1;
}

int main(){
    ios::sync_with_stdio( 0 ), cin.tie( 0 ), cout.tie( 0 );
    cin >> n >> m >> p >> k;
    for( int i = 1; i <= 3; ++i ) {
        for( int j = 0; j < p; ++j ) {
            int __;
            cin >> __;
            if( i == 2 && j == k ) continue;
            can[i] |= ( __ << j );
        }
    }
    mat a; a.csh();
    for( int i = 0; i < ( 1 << m ); ++i )
        for( int j = 0; j < ( 1 << m ); ++j )
            a.a[i][j] = check( i, j );
    a = ksm( a, n - 1 );
    uint ans = 0;
    for( int i = 0; i < ( 1 << m ); ++i )
        for( int j = 0; j < ( 1 << m ); ++j )
            ans += a.a[i][j];
    cout << ans << endl;
    return 0;
}
```

---


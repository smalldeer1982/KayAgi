# [CQOI2013] 二进制A+B

## 题目描述

输入三个整数$a, b, c$，把它们写成无前导0的二进制整数。
比如$a=7, b=6, c=9$，写成二进制为$a=111, b=110, c=1001$。

接下来以位数最多的为基准，其他整数在前面添加前导0，使得$a, b, c$拥有相同的位数。比如在刚才的例子中，添加完前导0后为$a=0111, b=0110, c=1001$。

最后，把$a, b, c$的各位进行重排，得到a’, b’, c’，使得a’+b’=c’。比如在刚才的例子中，可以这样重排：a’=0111, b’=0011, c’=1010。


你的任务是让c’最小。如果无解，输出-1。

## 说明/提示

$a,b,c <= 2^{30}$


## 样例 #1

### 输入

```
7 6 9```

### 输出

```
10```

# 题解

## 作者：TYxxj (赞：16)

>题目大意：给定n位二进制数a,b,c，要求重组三个数的各个位，使得 $a^\prime$+$b^\prime$=$c^\prime$ 且最小化 $c^\prime$。

不考虑位数限制，显然答案只与三个数中1的个数有关。

令$x=cnta,y=cntb,z=cntc$，其中 $cntx$ 代表x中1的个数。

不妨**令x$\geqslant$y**。

以下用 $x=10,y=5$ 来举例。

### 1. 若 $z=1$ ，构造方式如下：

    000001111111111
    011110000000001
    100000000000000

    
证明：显然最低位肯定是 $1+1=10$ ，然后再往上肯定都是单个1，构造方式唯一。

### 2. 若$1<z<y$，构造方式如下：

    0001111111111
    0110000000111
    1000000000110
    
    
证明：
若最低位为$1+0=1$，则去掉最低位后变成了 $(x−1,y,z−1)$ 或 $(x,y−1,z−1)$ 。

二者都需要 $x+y−z+1$ 位，算上最低位有 $x+y−z+2$ 位，而这种构造法只需要 $x+y−z+1$ 位。

由数学归纳法可证最低位为 $1+0=1$ 不优。

那么最低位为 $1+1=10$ 就确定了。

然后……然后自己YY吧我没证出来不过应该是对的，感觉数学归纳法啥的能证。

### 3. 若 $z=y$ ，构造方式如下：

    01111111111
    00000011111
    10000011110
    
证明：这种构造方式保证 $a^\prime$ 和 $b^\prime$ 都是最小的，显然最优。

### 4. 若y<z$\leqslant$x，构造方式如下：

    01111111111
    00011111000
    10011110111
    
证明：

显然 $c^\prime$ 最小 $x+1$ 位。

如果想要使 $c^\prime$ 减小，只能将前面的那些0往前挪或将最后一个0往前挪。

显然前面那些0挪不动，只能将最后一个0往前挪(比如变成1001101111)。

这说明最后 $z−y$ 位必须是 $1+0=1$。

那么去掉最后 $z−y$位，问题变成了 $(x+y−z,y,y)$。

由y=z的证明可得这种构造法是最优的。

### 5. 若x<z<x+y，构造方式如下：

    0111111111100
    0111000000011
    1110111111111
    
证明：

显然答案至少 $z+1$ 位，因为z个 $1−x$ 个1一定会得到 $z−x$ 个1，

而 $z−x<y$ ，矛盾。

然后位数确定后证明就同上了。

若 $z=x+y$ ，构造方式如下：

    000001111111111
    111110000000000
    111111111111111
    
然后……就完事了。

代码：
```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
int Digit(int x) {
	int re=0;
	while(x)++re,x>>=1;
	return re;
}
int Count(int x) {
	int re=0;
	while(x)x^=x&-x,++re;
	return re;
}
int main() {
	int x,y,z,limit,ans;
	cin>>x>>y>>z;
	limit=max( max( Digit(x) , Digit(y) ) , Digit(z) );
	x=Count(x);
	y=Count(y);
	z=Count(z);
	if(x<y) swap(x,y);
	if(z<=y) ans=((1<<x)-1)+((1<<z)-1|((1<<y-z)-1<<x));
	else if(z<=x) ans=((1<<x)-1)+((1<<y)-1<<z-y);
	else if(z<=x+y) ans=((1<<x)-1<<z-x)+((1<<z-x)-1|((1<<x+y-z)-1<<z+z-x-y));
	else ans=-1;
	if(Digit(ans)>limit) ans=-1;
	cout<<ans<<endl;
	return 0;
}
```

ps：蒟蒻第一题题解不会排版，请见谅，管理员请放松一下要求，过了这篇题解，谢谢。

---

## 作者：南苑沁青 (赞：11)

## 思路：

本题可用**数位DP**来做，设 **f [ i ][ a ][ b ][ c ][ j ]** 表示当前枚举到(二进制下的)第i位，a' b' c'各用a,b,c了几个1，j表示最后一位是否有进位。转移方程就只要暴力枚举8种情况（不同位置及是否进位）。
#### DP方程如下：
```cpp
inline void dp()//动态规划，强行枚举八种情况 
{
    f[0][0][0][0][0]=0;
    for (int i=0;i<n;++i)
        for (int j=0;j<=jla;++j)
            for (int k=0;k<=jlb;++k)
                for (int l=0;l<=jlc;++l)
                {
                    long long tmp=f[i][j][k][l][0];//枚举最后一位不进位的情况
                    f[i+1][j+1][k+1][l+1][1]=min(f[i+1][j+1][k+1][l+1][1],tmp+(1<<i+1));
                    f[i+1][j+1][k][l+1][0]=min(f[i+1][j+1][k][l+1][0],tmp+(1<<i));
                    f[i+1][j][k+1][l+1][0]=min(f[i+1][j][k+1][l+1][0],tmp+(1<<i));
                    f[i+1][j][k][l][0]=min(f[i+1][j][k][l][0],tmp);
                    tmp=f[i][j][k][l][1];//枚举最后一位进位的情况
                    f[i+1][j+1][k+1][l+1][1]=min(f[i+1][j+1][k+1][l+1][1],tmp+(1<<i+1));
                    f[i+1][j][k+1][l][1]=min(f[i+1][j][k+1][l][1],tmp+(1<<i));
                    f[i+1][j+1][k][l][1]=min(f[i+1][j+1][k][l][1],tmp+(1<<i));
                    f[i+1][j][k][l][0]=min(f[i+1][j][k][l][0],tmp);
                }
}
```
#### 完整代码：
```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<algorithm>
#include<cmath>
using namespace std;
#define INF 0x7f7f7f7f7f7f7f
int T,a,b,c;
int n,jla,jlb,jlc;//n记录三个数的二进制数码长度的最大值，jla、jlb、jlc分别记录a、b、c的二进制数码 
long long f[33][33][33][33][2];
inline int read()//快读 
{
    char kr=0;
    char ls;
    for(;ls>'9'||ls<'0';kr=ls,ls=getchar());
    int xs=0;
    for(;ls>='0'&&ls<='9';ls=getchar())
    {
        xs=xs*10+ls-48;
    }
    if(kr=='-') xs=0-xs;
    return xs;
}
inline int lowbit(int x)//求出x的二进制数码 
{
    int sum=0;
    for (;x;x>>=1)
        sum+=x&1;
    return sum;
}
inline void dp()//动态规划，强行枚举八种情况 
{
    f[0][0][0][0][0]=0;
    for (int i=0;i<n;++i)
        for (int j=0;j<=jla;++j)
            for (int k=0;k<=jlb;++k)
                for (int l=0;l<=jlc;++l)
                {
                    long long tmp=f[i][j][k][l][0];//枚举最后一位不进位的情况
                    f[i+1][j+1][k+1][l+1][1]=min(f[i+1][j+1][k+1][l+1][1],tmp+(1<<i+1));
                    f[i+1][j+1][k][l+1][0]=min(f[i+1][j+1][k][l+1][0],tmp+(1<<i));
                    f[i+1][j][k+1][l+1][0]=min(f[i+1][j][k+1][l+1][0],tmp+(1<<i));
                    f[i+1][j][k][l][0]=min(f[i+1][j][k][l][0],tmp);
                    tmp=f[i][j][k][l][1];//枚举最后一位进位的情况
                    f[i+1][j+1][k+1][l+1][1]=min(f[i+1][j+1][k+1][l+1][1],tmp+(1<<i+1));
                    f[i+1][j][k+1][l][1]=min(f[i+1][j][k+1][l][1],tmp+(1<<i));
                    f[i+1][j+1][k][l][1]=min(f[i+1][j+1][k][l][1],tmp+(1<<i));
                    f[i+1][j][k][l][0]=min(f[i+1][j][k][l][0],tmp);
                }
}
inline void clear()//为做DP初始化 
{
    memset(f,INF,sizeof(f)); 
    n=max((int)log2(a)+1,(int)log2(b)+1);
    n=max(n,(int)log2(c)+1);//求 n 
    jla=lowbit(a),jlb=lowbit(b),jlc=lowbit(c);
}
int main()
{
    a=read();b=read();c=read();
    clear();
    dp();
    if(f[n][jla][jlb][jlc][0]>=INF)//注意是“≥INF” 
    {
        printf("-1\n");
        return 0;
    }//如果无解就输出-1 
    printf("%lld\n",f[n][jla][jlb][jlc][0]);//输出最小值 
    return 0;
}
```
### 一些注意事项
1. 本题的 f 数组要开long long 不然会爆int。
2. INF也要尽量开大。
3. 在判断无解时要判 " ≥ INF ”（因为转移过程中会加上部分的值）

其他的细节瞎搞搞就AC了。

#### 最后安利下我的博客：[蒟蒻的博客](https://www.cnblogs.com/lck-lck/p/9665321.html)

---

## 作者：TheLostWeak (赞：8)

[在博客查看](https://www.cnblogs.com/chenxiaoran666/p/BZOJ3107.html)

好不容易才做出来这道题......

做完后到题解区里翻了翻发现基本上都是数位$DP$的题解，因此水一发我的强行构造的做法......

### 构造

一道构造题，大量分类讨论.......

我们设$ta,tb,tc$分别表示$a,b,c$二进制下$1$的个数，$l$表示最高的位数。

方便起见，我们强制$ta\le tb$。

显然，当$ta+tb=tc$时，答案在二进制下就是连续$tc$个$1$。

否则，我们考虑做二进制下加法，每一次进位，$1$的总数便会减少$1$个。

所以，如果$ta+tb<tc$，就肯定无解。

不然，$ta+tb>tc$，则我们设$t=ta+tb-tc$，即所需进位的次数。

然后就是分类讨论了。

### 分类讨论

当$ta\ge t$且$tb\ge t$时，我们可以从$a,b$中各拎出$t$个$1$，把它们放在一起做加法，就实现了进位$t$次。这个运算的结果在二进制下就是$t$个连续的$1$和一个$0$。

然后，$a,b$中分别剩下了$ta-t$和$tb-t$个$1$，由于我们不能让它再进位，所以就必须将它们错开做加法。这个运算的结果就是$ta+tb-2\times t$个$1$。

也就是说，最后的答案将由$t$个连续的$1$和一个$0$、$ta+tb-2\times t$个$1$两部分组成。

由于要让答案最小，所以我们尽量让$0$靠左。

而且，容易发现答案的总位数是$(t+1)+(ta+tb-2\times t)=ta+tb-t+1=tc+1$。

假设从右边开始首位为第$1$位，则最后答案中为$1$的区间就是：

$$[1,ta+tb-2\times t],[ta+ta-2\times t+2,tc+1]$$

------

当$ta<t$且$tb\ge t$时，首先把$a$中的$1$全部拎出来，再从$b$从同样拎出$ta$个$1$和它配合在一起做加法进位$ta$次。

但由于$ta<t$，所以此时进位次数还不够，因此我们需要再从$b$中拎出$t-ta$个$1$放在这$ta$对$1$左侧，这样一来，$ta$对$1$经过加法进位后得到的最高位的那个$1$就会连带地让这$t-ta$个$1$全部进位。这个运算的结果在二进制下就是一个$1$、$t-ta$个$0$、$ta-1$个$1$和一个$0$。

而$tb$中我们一共拎出了$ta+(t-ta)=t$个$1$，也就是还剩下$tb-t$个$1$。

同样容易发现，答案的总位数是$1+(t-ta)+(ta-1)+1+(tb-t)=tb+1$。

像前一种情况一样，由于要尽量让$0$靠左，所以最后答案中为$1$的区间就是：

$$[1,tb-t],[tb-t+2,tb-t+ta],[tb+1,tb+1]$$

------

当$ta<t$且$tb<t$时，发现如果按之前的方法去做就无法凑成$t$次进位。

假设我们需要从$a,b$中各拎出$x$个$1$让它们成对进位，而将$a,b$中剩下的$1$按照前面第二种情况中的方法连带进位，则就有：$x+(ta-x)+(tb-x)\ge ta+tb-tc$。化简得到$x\le tc$。

而根据$ta<t$，即$ta<ta+tb-tc$，得到$tb>tc$，同理也能得到$ta>tc$。

所以，$x$一定能够取到$tc$，且显然$x$越大答案越优（因为凑成的对数越多，答案的位数就越少）。

我们从$a,b$中各拎出$tc$个$1$，然后把剩下的$ta+tb-2\times tc=t-tc$个$1$一股脑地堆在这$tc$对$1$的左侧。

加法后，就得到一个$1$、$t-tc$个$0$、$tc-1$个$1$和一个$0$。

所以，最后答案中为$1$的区间就是：

$$[2,tc],[t+1,t+1]$$

------

顺便提一下，在之前的做法中有可能最后得到的$c'$二进制下位数超过$l$，显然与题意不符。

因此我们最后要判断$c'<2^l$，才能输出答案。

### 代码

```cpp
#include<bits/stdc++.h>
#define Tp template<typename Ty>
#define Ts template<typename Ty,typename... Ar>
#define Reg register
#define RI Reg int
#define Con const
#define CI Con int&
#define I inline
#define W while
#define swap(x,y) (x^=y^=x^=y)
#define Fill(x,y) for(i=x;i<=y;++i) ans|=1<<(i-1)
using namespace std;
int a,b,c;
int main()
{
	RI i,ta=0,tb=0,tc=0,l;scanf("%d%d%d",&a,&b,&c);
	for(i=a;i;i&=i-1) ++ta;for(i=b;i;i&=i-1) ++tb;for(i=c;i;i&=i-1) ++tc;//统计1的个数
	for(ta>tb&&swap(ta,tb),l=1;(1LL<<l)<=max(a,max(b,c));++l);//注意一定要1LL，否则2^31会挂掉
	RI ans=0,t=ta+tb-tc;if(ta+tb==tc) {Fill(1,tc);goto End;}//以下是各种分类讨论
	if(t<0) return puts("-1"),0;
	if(ta<t&&tb<t) {Fill(2,tc);Fill(t+1,t+1);goto End;}
	if(ta<t) {Fill(1,tb-t);Fill(tb-t+2,tb-t+ta);Fill(tb+1,tb+1);goto End;}
	Fill(1,ta+tb-2*t);Fill(ta+tb-2*t+2,tc+1);
	End:return ans<(1LL<<l)?printf("%d\n",ans):puts("-1"),0;//最后输出答案前记得判断
}
```


---

## 作者：koobee (赞：5)

动态规划题。

令 $a$ 二进制中 $1$ 的个数为 $A$，$b$ 中 $1$ 的个数为 $B$，$c$ 中 $1$ 的个数为 $C$。$n=a,b,c$ 二进制位数的最大值。生成一个 $n$ 位二进制之和的算式，要求三行中 $1$ 的个数分别为 $A,B,C$。

$f[i][j][k][l][0$ $or$ $1]$ 表示长度为 $i$ 的算式，$a$ 用了 $j$ 个 $1$，$b$ 用了 $k$ 个 $1$，$c$ 用了 $l$ 个 $1$，此时最小的 $c$。

$0$ 表示上一位没有进位，$1$ 表示上一位进了位。

答案：$f[n][A][B][C][0]$。

建议顺推更新。分情况讨论。

$p=f[i][j][k][l][0]$；

 - $a$，$b$ 都选 $0$：$f[i+1][j][k][l][0]=\min(f[i+1][j][k][l][0], p);$
 
 - $a$ 选 $1$，$b$ 选 $0$：$f[i+1][j+1][k][l+1][0]=\min(f[i+1][j+1][k][l+1][0],p+(1<<i));$
 
 - $b$ 选 $1$，$a$ 选 $0$：$f[i+1][j][k+1][l+1][0]=\min(f[i+1][j][k+1][l+1][0],p+(1<<i));$
 
 - $a$，$b$ 都选 $1$：$f[i+1][j+1][k+1][l][1]=\min(f[i+1][j+1][k+1][l][1], p+(1<<(i+1)));$
 
 $p=f[i][j][k][l][1]$ 同理。
 
 代码：
 
 ```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int a, b, c, n, f[35][35][35][35][2], INF = 2e9;
int calc(int x){
	int cnt = 0;
	while(x) x /= 2, cnt++;
	return cnt;
}
int cal(int x){
	int cnt = 0;
	while(x) x -= (x & (-x)), cnt++;
	return cnt;
}
signed main(){
	cin>>a>>b>>c;
	n = max(max(calc(a), calc(b)), calc(c)), a = cal(a), b = cal(b), c = cal(c);
	memset(f, 0x3f, sizeof(f));
	f[0][0][0][0][0] = 0;
	for(int i = 0; i < n; i++)
		for(int j = 0; j <= a; j++)
			for(int k = 0; k <= b; k++)
				for(int l = 0; l <= c; l++){
					int p = f[i][j][k][l][0];
					f[i+1][j][k][l][0] = min(f[i+1][j][k][l][0], p);
					f[i+1][j+1][k][l+1][0] = min(f[i+1][j+1][k][l+1][0], p + (1<<i));
					f[i+1][j][k+1][l+1][0] = min(f[i+1][j][k+1][l+1][0], p + (1<<i));
					f[i+1][j+1][k+1][l][1] = min(f[i+1][j+1][k+1][l][1], p + (1<<(i+1)));
					p = f[i][j][k][l][1];
					f[i+1][j][k][l+1][0] = min(f[i+1][j][k][l+1][0], p);
					f[i+1][j+1][k][l][1] = min(f[i+1][j+1][k][l][1], p + (1<<i));
					f[i+1][j][k+1][l][1] = min(f[i+1][j][k+1][l][1], p + (1<<i));
					f[i+1][j+1][k+1][l+1][1] = min(f[i+1][j+1][k+1][l+1][1], p + (1<<(i+1)));
				}
	if(f[n][a][b][c][0] < INF) cout<<f[n][a][b][c][0];
	else cout<<-1;
	return 0;
}
```


---

## 作者：Lonehll (赞：2)

ps：首篇题解不会排版，丑请见谅

这题呢可以dp来做

~~反正某不用dp的题解我是没看懂。。~~

（果然我还是太弱了）

那么我的思路其实跟另外两篇题解的思路是一模一样的

~~疑似抄袭现场~~

设立 dp[i][a][b][c][0/1] 表示目前枚举到第i位（二进制下）a'用了a个1，b'用了b个1，c'用了c个1的状态（0/1表示是否进位）。

### 那么，状态转移方程式其实是很容易得出的
1.  dp[i+1][a1][b1][c1][0] = min(dp[i+1][a1][b1][c1][0], dp[i][a1][b1][c1][0]);
1.  dp[i+1][a1+1][b1][c1+1][0] = min(dp[i+1][a1+1][b1][c1+1][0], - dp[i][a1][b1][c1][0]+(1<<i));
1.  dp[i+1][a1][b1+1][c1+1][0] = min(dp[i+1][a1][b1+1][c1+1][0], dp[i][a1][b1][c1][0]+(1<<i));
1.  dp[i+1][a1+1][b1+1][c1+1][1] = min(dp[i+1][a1+1][b1+1][c1+1][1], dp[i][a1][b1][c1][0]+(1<<(i+1)));
1.  dp[i+1][a1][b1][c1][0] = min(dp[i+1][a1][b1][c1][0], dp[i][a1][b1][c1][1]);
1.  dp[i+1][a1+1][b1][c1][1] = min(dp[i+1][a1+1][b1][c1][1], dp[i][a1][b1][c1][1]+(1<<i));
1.  dp[i+1][a1][b1+1][c1][1] = min(dp[i+1][a1][b1+1][c1][1], dp[i][a1][b1][c1][1]+(1<<i));
1.  dp[i+1][a1+1][b1+1][c1+1][1] = min(dp[i+1][a1+1][b1+1][c1+1][1], dp[i][a1][b1][c1][1]+(1<<(i+1)));

其实就是八种状态转移枚举过去就行了。。。
大概写一下这八个的推导过程、、、

- ###  前四个是上一位状态下莫得进位的情况


    转换1就是个普通转换也没啥好说的。。
   
    转换2就是只有a'多用一个1，那c'也必会多用一个1，值的转移就是上个值直接加上（1<<i）。自己大概模拟一下就知道为什么了。。这里要注意i是从0开始的，转换3与转换2同理。
    
    转换4则是两个都选，此时会进位，因此最后一个标记变成1，进位导致值的转换上加的值变成（1<<(i+1)）
- ### 后四个是上一位状态下有进位的情况
    其实与前四个大同小异，只不过是因为上一位有进位，所以相当于这一位本身就有一个1的值，在是否进位的判断下会变得有些不同。
    
    转换6和转换7则是只选一个1的情况，此时因为上一位进位本身有1，所以在状态的转移上是有进位的。其他的转换实际上都是与前四个同理。
    
    
最后贴出AC代码：
```c
#include<bits/stdc++.h>
using namespace std;

int a, b, c, n;
int numa = 0, numb = 0, numc = 0;
long long dp[35][35][35][35][2];
int num(int x) {//求x在二进制下有几个1 
	int ans = 0;
	while(x) {
		if(x & 1) ans++;
		x >>= 1;
	}
	return ans;
}

int main() {
	memset(dp, 0x3f, sizeof dp);//初始化 
	dp[0][0][0][0][0] = 0;//初始化 
	cin >> a >> b >> c;
	numa = num(a);//numa,numb,numc分别表示a,b,c有多少个1 
	numb = num(b);
	numc = num(c);
	n = max(max(int(log2(a)+1), int(log2(b)+1)), int(log2(c)+1));
	for (int i = 0; i < n; i++)//i枚举位数 
		for (int a1 = 0; a1 <= numa; a1++)//a1枚举a'用的1的个数 
			for (int b1 = 0; b1 <= numb; b1++)//b1枚举b'用的1的个数 
				for (int c1 = 0; c1 <= numc; c1++) {//c1枚举c'用的1的个数  
					dp[i+1][a1][b1][c1][0] = min(dp[i+1][a1][b1][c1][0], dp[i][a1][b1][c1][0]);//前四个转移（上一位无进位） 
					dp[i+1][a1+1][b1][c1+1][0] = min(dp[i+1][a1+1][b1][c1+1][0], dp[i][a1][b1][c1][0]+(1<<i));
					dp[i+1][a1][b1+1][c1+1][0] = min(dp[i+1][a1][b1+1][c1+1][0], dp[i][a1][b1][c1][0]+(1<<i));
					dp[i+1][a1+1][b1+1][c1+1][1] = min(dp[i+1][a1+1][b1+1][c1+1][1], dp[i][a1][b1][c1][0]+(1<<(i+1)));
					
					dp[i+1][a1][b1][c1][0] = min(dp[i+1][a1][b1][c1][0], dp[i][a1][b1][c1][1]);//后四个转移（上一位有进位） 
					dp[i+1][a1+1][b1][c1][1] = min(dp[i+1][a1+1][b1][c1][1], dp[i][a1][b1][c1][1]+(1<<i));
					dp[i+1][a1][b1+1][c1][1] = min(dp[i+1][a1][b1+1][c1][1], dp[i][a1][b1][c1][1]+(1<<i));
					dp[i+1][a1+1][b1+1][c1+1][1] = min(dp[i+1][a1+1][b1+1][c1+1][1], dp[i][a1][b1][c1][1]+(1<<(i+1)));
				}
	if(dp[n][numa][numb][numc][0] == 0x3f3f3f3f3f3f3f3f)//如果与初始值相同则证明无解输出-1 
		cout << "-1";
	else
		cout << dp[n][numa][numb][numc][0];
	return 0;
}
```


---

## 作者：Anoxiacxy (赞：2)

网上有构造的题解。。。但是我不会。。。所以敲了一个DP，也挺短的。

显然，由于状态只和 $A, B, C$ 中 1 的个数有关，所以我们希望得到一个函数 $f(maxL,|A|,|B|,|C|)=min\{C|A+B=C,|C|<=maxL\}$

先来逐位考虑，发现 $C$ 的第 $i$ 位只和 $A, B$ 的第 $i$ 位以及$A, B$ 的后面是否会进位有关，所以状态中再加一维表示是否需要进位，然后暴力枚举 $2^3$ 种转移即可

$f[i][a][b][c][0] \rightarrow f[i + 1][a][b][c][0]$

$f[i][a][b][c][0] \rightarrow f[i + 1][a+1][b][c+1][0]$

$f[i][a][b][c][0] \rightarrow f[i + 1][a+1][b][c+1][0]$

$f[i][a][b][c][0] \rightarrow f[i + 1][a][b][c+1][1]$

$f[i][a][b][c][1] \rightarrow f[i + 1][a+1][b][c][1]$

$f[i][a][b][c][1] \rightarrow f[i + 1][a][b+1][c][1]$

$f[i][a][b][c][1] \rightarrow f[i + 1][a+1][b+1][c][0]$

$f[i][a][b][c][1] \rightarrow f[i + 1][a+1][b+1][c+1][1]$

```
#include<bits/stdc++.h>
#define REP(i, s, t) for (int i = (s); i != (t); i++) 
using namespace std;
template < typename T > bool chkmax(T &a, T b) { return a < b ? (a = b, true) : false; }
template < typename T > bool chkmin(T &a, T b) { return a > b ? (a = b, true) : false; }
typedef long long ll;

inline int read(int u = 0, char c = getchar(), bool f = false) {
	for (;!isdigit(c); c = getchar()) f |= c == '-';
	for (; isdigit(c); c = getchar()) u = (u << 1) + (u << 3) + c - '0';
	return f ? -u : u;
}

ll f[32][32][32][32][2];
	
int bitof(int x) { return x ? bitof(x >> 1) + (x & 1) : 0; }
int main() {
	memset(f, 0x3f, sizeof f);
	ll An = read(), Bn = read(), Cn = read();
	ll A = bitof(An), B = bitof(Bn), C = bitof(Cn), S = 1;
	while (S <= An) S <<= 1; 
	while (S <= Bn) S <<= 1;
	while (S <= Cn) S <<= 1;
	f[0][0][0][0][0] = 0;
	REP(i, 0, 31) REP(a, 0, i + 1) REP(b, 0, i + 1) REP(c, 0, i + 1) {
		chkmin(f[i + 1][a][b][c][0], f[i][a][b][c][0] << 1);
		chkmin(f[i + 1][a + 1][b][c + 1][0], f[i][a][b][c][0] << 1 | 1);
		chkmin(f[i + 1][a][b + 1][c + 1][0], f[i][a][b][c][0] << 1 | 1);
		chkmin(f[i + 1][a + 1][b + 1][c][0], f[i][a][b][c][1] << 1);
		
		chkmin(f[i + 1][a][b][c + 1][1], f[i][a][b][c][0] << 1 | 1);
		chkmin(f[i + 1][a + 1][b][c][1], f[i][a][b][c][1] << 1);
		chkmin(f[i + 1][a][b + 1][c][1], f[i][a][b][c][1] << 1);
		chkmin(f[i + 1][a + 1][b + 1][c + 1][1], f[i][a][b][c][1] << 1 | 1);
	}	
	ll ans = 0x3f3f3f3f3f3f3f3fll;
	REP(i, 0, 32) if (1ll << i - 1 < S) chkmin(ans, f[i][A][B][C][0]);
	printf("%lld", ans == 0x3f3f3f3f3f3f3f3fll ? -1 : ans);
}
```

---

## 作者：xuantianhao (赞：1)

## [ [CQOI2013] 二进制A+B](https://www.luogu.com.cn/problem/P4574)

最后判无解试了很多次才判成功，主要是因为 $a,b,c\leq2^{30}$ 中有个 $\leq$ 而不是 $<$ 就很烦人。

思路很简单：设 $f[i][j][k][l][0/1]$ 表示：

按位 DP 到第 $i$ 位，$a,b,c$ 中分别用了 $j,k,l$ 个 1，并且进位的情况是 0 或 1 的最小方案。

转移之间枚举这一位 $a,b$ 分别填 1 还是填 0 即可。

复杂度约是 $O(\log^4)$。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int lim=31;
int a,b,c,f[lim][lim][lim][lim][2],res=0x3f3f3f3f3f3f3f3f;
void read(int &x){
    int t;
    x=0;
    scanf("%lld",&t);
    for(int i=0;i<lim;i++)x+=((t>>i)&1);
}
void chmin(int &a,int b){
    a=min(a,b);
}
signed main(){
    read(a),read(b),read(c),memset(f,0x3f3f3f3f,sizeof(f));
//  printf("%d %d %d\n",a,b,c);
    f[0][0][1][1][0]=1;
    f[0][1][0][1][0]=1;
    f[0][1][1][0][1]=0;
    f[0][0][0][0][0]=0;
    for(int i=0;i<lim-1;i++)for(int j=0;j<=a;j++)for(int k=0;k<=b;k++)for(int l=0;l<=c;l++)for(int p=0;p<2&&j+p<=a;p++)for(int q=0;q<2&&k+q<=b;q++){
        chmin(f[i+1][j+p][k+q][l+((p+q)&1)][(p+q)>1],f[i][j][k][l][0]+(((p+q)&1)<<(i+1)));
        chmin(f[i+1][j+p][k+q][l+((p+q+1)&1)][(p+q)>0],f[i][j][k][l][1]+(((p+q+1)&1)<<(i+1)));
    }
//  for(int i=0;i<lim-1;i++)for(int j=0;j<=a;j++)for(int k=0;k<=b;k++)for(int l=0;l<=c;l++)for(int m=0;m<2;m++)printf("%d %d %d %d %d:%d\n",i,j,k,l,m,f[i][j][k][l][m]);
    for(int i=0;i<lim;i++)res=min(res,f[i][a][b][c][0]);
    printf("%lld\n",res>(0x7f7f7f7f)?-1:res);
    return 0;
}

```


---

## 作者：robertuu (赞：1)

[题目传送门](https://www.luogu.com.cn/problem/P4574)

### 题意简述

给出三个整数 $a,b,c$，把这三个整数转化为二进制形式并按照二进制最长的哪一个的长度补前导 $0$，将这三个数的二进制位重组，使得其满足 $a + b = c$，求重组后 $c$ 最小是多少（弱不可能班组要求输出 `-1`）

### 题目分析

补 $0$ 的操作可以视为没有，将二进制重组视为把原数二进制位的 $1$ 填充在前 $x$ 位二进制上（$x$ 为那个最长二进制长度）。

因此可以考虑二进制数位 dp，设置升维的状态 $dp[i][j][k][l][t]$，$i$ 表示已经处理了几位二进制，$j,k,l$ 分别表示 $a,b,c$ 分别已经重新分配了几位二进制，$t$ 表示这一位是否进位（转移下一位的时候进位影响答案），由于转移过于复杂，还是应该使用刷表法，通过一个状态更新新状态。

转移需要分类讨论，对于这个状态下的进位情况和不进位情况分开转移，决策就是 $a$ 和 $b$ 在新的一位选 $1$ 还是选 $0$。选择情况会影响 $c$ 在这一位上的取值和答案产生影响，第 $i$ 为上一个 $1$ 的贡献是 $2^{i-1}$（进位会使得 $c$ 增加 $1$，我的写法是在进位产生时就更新 $c$ 已确定的 $1$ 的个数，有的写法是转移新状态时更新）。

转移方程共八种（很多）：
```cpp
// 上一位不进位
tmp = f[i][j][k][l][0];
f[i+1][j][k][l][0] = min(f[i+1][j][k][l][0],tmp); // 00
f[i+1][j+1][k][l+1][0] = min(f[i+1][j+1][k][l+1][0],tmp+(1<<i)); // 10
f[i+1][j][k+1][l+1][0] = min(f[i+1][j][k+1][l+1][0],tmp+(1<<i)); // 01
f[i+1][j+1][k+1][l+1][1] = min(f[i+1][j+1][k+1][l+1][1],tmp+(1<<(i+1))); // 11（l+1处理进位）
// 上一位进位
tmp = f[i][j][k][l][1]; // 注意这一位c的l已经在进位的时候加了，只有情况4因为会产生两个1才需要再+1
f[i+1][j][k][l][0] = min(f[i+1][j][k][l][0],tmp); // 00
f[i+1][j][k+1][l][1] = min(f[i+1][j][k+1][l][1],tmp+(1<<i)); // 01（会有进位）
f[i+1][j+1][k][l][1] = min(f[i+1][j+1][k][l][1],tmp+(1<<i)); // 10（会有进位）
f[i+1][j+1][k+1][l+1][1] = min(f[i+1][j+1][k+1][l+1][1],tmp+(1<<(i+1))); // 11（进位后还有1）
```

枚举范围：位数 $n$ 可以用拆位法求出最长几位二进制，$a,b,c$ 选择的 $1$ 的个数上限是 $\operatorname{popcount}(a),\operatorname{popcount}(b),\operatorname{popcount}(c)$，也可以拆位求得（或是使用 $\operatorname{lowbit}$）。最后一位是否进位不用枚举，分类讨论相当于枚举了。

答案：$dp[n][\operatorname{popcount}(a)][\operatorname{popcount}(b)][\operatorname{popcount}(c)][0]$ 最高位不能进位！注意这题是最小值，初始需要设为无穷大（由于转移过程中值可能爆 `int`，需要开 `long long`）。

时间复杂度：四重循环，每重循环的次数都是 $\log(n)$，整体复杂度 $O(\log(n)^4)$，可以很快通过。

AC code：
```cpp
#include<iostream>
#include<cstring>
using namespace std;
#define FOR(i,a,b) for(int i = a;i <= b;i++)
long long f[32][32][32][32][2];
int popcnt(int x)
{
	int ans = 0;
	while(x)
	{
		if(x&1) ans++;
		x >>= 1;
	}
	return ans;
}
int weicnt(int x)
{
	int ans = 0;
	while(x)
	{
		ans++;
		x >>= 1;
	}
	return ans;
}
int main()
{
	int a,b,c,n,A,B,C;
	long long tmp;
	scanf("%d%d%d",&a,&b,&c);
	A = popcnt(a); B = popcnt(b); C = popcnt(c);
	n = max(weicnt(a),max(weicnt(b),weicnt(c)));
	// 转移方式：上一位答案+这一位贡献
	memset(f,0x3f,sizeof(f));
	f[0][0][0][0][0] = 0;
	// i从0开始，这题是刷表下一位
	FOR(i,0,n-1) FOR(j,0,A) FOR(k,0,B) FOR(l,0,C)
	{
		// 上一位不进位
		tmp = f[i][j][k][l][0];
		f[i+1][j][k][l][0] = min(f[i+1][j][k][l][0],tmp); // 00
		f[i+1][j+1][k][l+1][0] = min(f[i+1][j+1][k][l+1][0],tmp+(1<<i)); // 10
		f[i+1][j][k+1][l+1][0] = min(f[i+1][j][k+1][l+1][0],tmp+(1<<i)); // 01
		f[i+1][j+1][k+1][l+1][1] = min(f[i+1][j+1][k+1][l+1][1],tmp+(1<<(i+1))); // 11
		// 上一位进位
		tmp = f[i][j][k][l][1];
		f[i+1][j][k][l][0] = min(f[i+1][j][k][l][0],tmp); // 00
		f[i+1][j][k+1][l][1] = min(f[i+1][j][k+1][l][1],tmp+(1<<i)); // 01
		f[i+1][j+1][k][l][1] = min(f[i+1][j+1][k][l][1],tmp+(1<<i)); // 10
		f[i+1][j+1][k+1][l+1][1] = min(f[i+1][j+1][k+1][l+1][1],tmp+(1<<(i+1))); // 11
	}
	printf("%d",f[n][A][B][C][0]<2.1e9?f[n][A][B][C][0]:-1);
	return 0;
}
```

---

## 作者：Thunder_S (赞：1)

[不一样的阅读体验](https://www.cnblogs.com/Livingston/p/15374275.html)

## Solution

考虑 dp。

先统计出 $a$，$b$，$c$ 里 1 的个数，然后统计出最多有多少位 $n$。

设 $f_{i,x,y,z,0/1}$ 表示到了二进制下的第 $i$ 位，$a$，$b$，$c$ 分别用了 $x,y,z$ 个 1，上一位是否进位的最小的 $c'$。

因为是最小值，所以初值为 $\inf$。

转移（我是采用由当前往下个结果转移）：

$f_{i+1,x,y,z,0}=\min(f_{i+1,x,y,z,0},f_{i,x,y,z,0})$

$f_{i+1,x+1,y,z+1,0}=\min(f_{i+1,x+1,y,z+1,0},f_{i,x,y,z,0}+2^i)$

$f_{i+1,x,y+1,z+1,0}=\min(f_{i+1,x,y+1,z+1,0},f_{i,x,y,z,0}+2^i)$

$f_{i+1,x+1,y+1,z+1,1}=\min(f_{i+1,x+1,y+1,z+1,1},f_{i,x,y,z,0}+2^{i+1})$

$f_{i+1,x,y,z,0}=\min(f_{i+1,x,y,z,0},f_{i,x,y,z,1})$

$f_{i+1,x+1,y,z,1}=\min(f_{i+1,x+1,y,z,1},f_{i,x,y,z,1}+2^i)$

$f_{i+1,x,y+1,z,1}=\min(f_{i+1,x,y+1,z,1},f_{i,x,y,z,1}+2^i)$

$f_{i+1,x+1,y+1,z+1,1}=\min(f_{i+1,x+1,y+1,z+1,1},f_{i,x,y,z,1}+2^{i+1})$

首先前 4 个转移是从没有进位的来转移，第 1 个转移是都不放 1，就直接转移。

第 2、3 个转移是放一个 1，此时 $c$ 在第 $i$ 位就多了一个 1，就需要加上 $2^i$。

第 4 个转移是放两个 1，此时就会进位，令 $c$ 在第 $i+1$ 位增加一个 1，所以是加上 $2^{i+1}$ 而不是 $2^i$。

后面 4 个转移同理，第 5 个转移同样是不放 1，此时上一位的进位就不再进位，因此是 $f_{i+1,x,y,z,0}$。注意下第 6、7 个转移是不需要令 $z$ 加 1 的，因为只放一个是不影响 $c$ 中 1 的个数的，只会使得 1 向后移一位。

## Code

```cpp
#include<cmath>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define N 50
#define inf 0x7f7f7f7f
#define ll long long
using namespace std;
int numa,numb,numc,n;
ll a,b,c,f[N][N][N][N][3];
int lowbit(int x)
{
	int res=0;
	while (x)
	{
		res+=(x&1);
		x>>=1;
	}
	return res;
}
int main()
{
	scanf("%lld%lld%lld",&a,&b,&c);
	n=max((int)log2(a)+1,(int)log2(b)+1);
	n=max(n,(int)log2(c)+1);
	memset(f,inf,sizeof(f));
	numa=lowbit(a);
	numb=lowbit(b);
	numc=lowbit(c);
	f[0][0][0][0][0]=0;
	for (int i=0;i<n;++i)
		for (int x=0;x<=numa;++x)
			for (int y=0;y<=numb;++y)
				for (int z=0;z<=numc;++z)
				{
					ll t=f[i][x][y][z][0];
					f[i+1][x][y][z][0]=min(f[i+1][x][y][z][0],t);
					f[i+1][x+1][y][z+1][0]=min(f[i+1][x+1][y][z+1][0],t+(1<<i));
					f[i+1][x][y+1][z+1][0]=min(f[i+1][x][y+1][z+1][0],t+(1<<i));
					f[i+1][x+1][y+1][z+1][1]=min(f[i+1][x+1][y+1][z+1][1],t+(1<<(i+1)));
					t=f[i][x][y][z][1];
					f[i+1][x][y][z][0]=min(f[i+1][x][y][z][0],t);
					f[i+1][x+1][y][z][1]=min(f[i+1][x+1][y][z][1],t+(1<<i));
					f[i+1][x][y+1][z][1]=min(f[i+1][x][y+1][z][1],t+(1<<i));
					f[i+1][x+1][y+1][z+1][1]=min(f[i+1][x+1][y+1][z+1][1],t+(1<<(i+1)));
				}
	if (f[n][numa][numb][numc][0]>=inf) printf("-1\n");
	else printf("%lld\n",f[n][numa][numb][numc][0]);
	return 0;
}
```



---

## 作者：xhhhh36 (赞：0)

[传送门](https://www.luogu.com.cn/problem/P4574)

这题可以直接考虑数位 dp。设 $dp_{i,j,k,l,0/1}$ 为枚举到了前 $i$ 位，$a$ 用了 $j$ 个 $1$，$b$ 用了 $k$ 个 $1$，$c$ 用了 $l$ 个 $1$，最高位没有或有向下一位进位时 $c$ 的最小值。初始状态为 $dp_{0,0,0,0,0}=0$，其余值的为 $inf$，最终答案为 $dp_{\lfloor\max\{\log a,\log b,\log c\}\rfloor+1,\operatorname{popcount}(a),\operatorname{popcount}(b),\operatorname{popcount}(c),0}$。

考虑分类讨论进行转移，我使用的是填表法。

1. 当前最高位不进位，也就是考虑 $dp_{i,j,k,l,0}$ 从 $dp_{i-1}$ 中的哪些值转移。
- 第 $i-1$ 位没有进位且 $a$ 和 $b$ 的第 $i$ 位都不为 $1$，此时 $c$ 的第 $i$ 位为 $0$，$dp_{i,j,k,l,0}=\min(dp_{i,j,k,l,0},dp_{i-1,j,k,l,0})$。
- 第 $i-1$ 位没有进位且 $a$ 和 $b$ 的第 $i$ 位共有一个 $1$，此时 $c$ 的第 $i$ 位为 $1$，$dp_{i,j,k,l,0}=\min(dp_{i,j,k,l,0},dp_{i-1,j-1,k,l-1,0}+2^{i-1},dp_{i-1,j,k-1,l-1,0}+2^{i-1})$。
- 第 $i-1$ 位有进位且 $a$ 和 $b$ 的第 $i$ 位都不为 $1$，此时 $c$ 的第 $i$ 位为 $1$，$dp_{i,j,k,l,0}=\min(dp_{i,j,k,l,0},dp_{i-1,j,k,l-1,1}+2^{i-1})$。
2. 当前最高位进位，也就是考虑 $dp_{i,j,k,l,1}$ 从 $dp_{i-1}$ 中的哪些值转移。
- 第 $i-1$ 位没有进位且 $a$ 和 $b$ 的第 $i$ 位都为 $1$，此时 $c$ 的第 $i$ 位为 $0$，$dp_{i,j,k,l,1}=\min(dp_{i,j,k,l,1},dp_{i-1,j-1,k-1,l,1})$。
- 第 $i-1$ 位有进位且 $a$ 和 $b$ 的第 $i$ 位共有一个 $1$，此时 $c$ 的第 $i$ 位为 $0$，$dp_{i,j,k,l,1}=\min(dp_{i,j,k,l,1},dp_{i-1,j-1,k,l,1},dp_{i-1,j,k-1,l,1})$。
- 第 $i-1$ 位有进位且 $a$ 和 $b$ 的第 $i$ 位没有 $1$，此时 $c$ 的第 $i$ 位为 $1$，$dp_{i,j,k,l,0}=\min(dp_{i,j,k,l,1},dp_{i-1,j-1,k-1,l-1,1}+2^{i-1})$。

注意考虑边界的情况。
# AC code
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N=35,inf=0x3f3f3f3f3f3f3f3f;
int dp[N][N][N][N][2],pw[N];
int cal(int x){int ans=0;
	while (x){
		ans++;x>>=1;
	}return ans;
}
signed main(){
	ios::sync_with_stdio(0);
	memset(dp,0x3f,sizeof(dp));
	dp[0][0][0][0][0]=0;pw[0]=1;
	for (int i=1;i<=31;i++) pw[i]=pw[i-1]*2;
	for (int i=1;i<=31;i++){
		for (int j=0;j<=31;j++){
			for (int k=0;k<=31;k++){
				for (int l=0;l<=31;l++){
					int &now=dp[i][j][k][l][0];
					now=min(now,dp[i-1][j][k][l][0]);
					if (l) now=min(now,dp[i-1][j][k][l-1][1]+pw[i-1]);
					if (j&&l) now=min(now,dp[i-1][j-1][k][l-1][0]+pw[i-1]);
					if (k&&l) now=min(now,dp[i-1][j][k-1][l-1][0]+pw[i-1]);
					int &now1=dp[i][j][k][l][1];
					if (j) now1=min(now1,dp[i-1][j-1][k][l][1]);
					if (k) now1=min(now1,dp[i-1][j][k-1][l][1]);
					if (j&&k) now1=min(now1,dp[i-1][j-1][k-1][l][0]);
					if (j&&k&&l) now1=min(now1,dp[i-1][j-1][k-1][l-1][1]+pw[i-1]);
				}
			}
		}
	}
	int t;t=1;
	while (t--){
		int a,b,c;cin>>a>>b>>c;
		int ans=dp[max(cal(a),max(cal(b),cal(c)))][__builtin_popcount(a)][__builtin_popcount(b)][__builtin_popcount(c)][0];
		if (ans>=inf) cout<<-1<<"\n";
		else cout<<ans<<"\n";
	}
	return 0;
}
```

---

## 作者：Ag2WO4 (赞：0)

~~（[哼！才不会告诉你这题有重题呢！](https://www.luogu.com.cn/problem/P1633)）~~

考虑贪心。~~（其实这题多测试几个动归的结果之后规律就出来了）~~。

首先处理数据，将数字转化为 $1$ 的个数（记为 $m,n$，不妨设 $m<n$）和长度限制 $L$。

然后考虑极端情况：如果目标只有一个 $1$，必然是最低位两个 $1$ 相加然后全部进位；如果是 $m+n$ 个 $1$，必然是全部错位。这两种情况显然结果位数特别大（前者 $m+n+1$ 位；后者 $m+n$ 位，方便讨论接下来视作首位为 $0$ 的 $m+n+1$ 位），而任何结果都最少有 $n+1$ 位（除非如上全部错开，进位在所难免）。

考虑尽可能减少位数的构造：低位进位而来的 $1$ 和一个加数的 $1$ 进位产生的 $0$ 可以由另一个加数的 $1$ 填充，同时另一个加数独占的 $1$ 位数减少；若该独占 $1$ 有低位进位而来的 $1$，则 $1$ 的个数增多 $1$，同时位数减少 $1$。同理对于目标 $1$ 较多的情况，将首位进位的 $1$ 分配到独立位上，则 $1$ 的个数增多 $1$，同时位数增多 $1$。

同时，对于 $1$ 的个数少于 $m$ 的情况（进位产生的 $0$ 不少于 $n$ 个，但并没有 $m$ 个 $1$ 参与填充）和 $1$ 的个数多于 $n$ 的情况（以 $1$ 的个数显然）结果位数必然大于 $n+1$ 位，且可归纳位数的严格单调性。由此证明了位数变换的正确性。

确定了位数和 $1$ 的个数，最小值只需使结果合法的前提下 $1$ 尽可能靠后即可，即尽可能填充靠后的 $0$ 或将 $1$ 置于所有位之后即可。通过归纳可得出构造公式（见 AC 代码），是 $O(1)$ 的。
#### 代码
```python
a, b, c = map(lambda i: bin(int(i)), input().split())
max_len = max(len(a), len(b), len(c))
x = a.count('1')
y = b.count('1')
z = c.count('1')
    
if z < min(x, y):
    ans = '0b1' + '0' * (x + y - z - z) + '1' * (z - 1) + '0'
elif z < max(x, y):
    ans = '0b1' + '0' * (max(x, y) - z) + '1' * (min(x, y) - 1) + '0' + '1' * (z -min(x, y))
elif z < x + y:
    ans = '0b' + '1' * (x + y - z) + '0' + '1' * (z + z - x - y)
else:
    ans = '0b' + '1' * (x + y)#其实和上一组同理，但是前导零是个问题，所以单拿出来

if len(ans) > max_len:
    print(-1)
else:
    print(eval(ans))
```

---


# [TJOI2018] 异或

## 题目描述

现在有一颗以 $1$ 为根节点的由 $n$ 个节点组成的树，节点从 $1$ 至 $n$ 编号。树上每个节点上都有一个权值 $v_i$。现在有 $q$ 次操作，操作如下：

- $1~x~z$：查询节点 $x$ 的子树中的节点权值与 $z$ 异或结果的最大值。
- $2~x~y~z$：查询节点 $x$ 到节点 $y$ 的简单路径上的节点的权值与 $z$ 异或结果最大值。

## 说明/提示

#### 数据规模与约定


- 对于 $10\%$ 的数据，保证 $n, q \leq 10^2$；
- 对于 $20\%$ 的数据，保证 $n, q \leq 10^3$；
- 对于 $40\%$ 的数据，保证 $n, q \leq 10^4$；
- 对于 $100\%$ 的数据，保证 $2\leq n, q \leq10^5$，$1 \leq u, v, x, y \leq n$，$1 \leq op \leq 2$，$1 \leq v_i, z \lt 2^{30}$。

## 样例 #1

### 输入

```
7 5
1 3 5 7 9 2 4
1 2
1 3
2 4
2 5
3 6
3 7
1 3 5
2 4 6 3
1 5 5
2 5 7 2
1 1 9```

### 输出

```
7
6
12
11
14```

# 题解

## 作者：小粉兔 (赞：43)

###  题意简述：

题面说的很清楚了。

### 题解：

发现没有修改很快乐。再看异或最大值操作，很容易想到可持久化 01trie。

这里要把 01trie 搬到树上，有点难受。

树剖太捞了，考虑 DFS 序。

子树查询转成 DFS 序上一段区间，而链上查询转成两条链。

所以维护两(个?)种可持久化 01trie，一个按照 DFS 序，另一个按照从根到结点的路径。

还要求 LCA，这里我写了个倍增。

```cpp
#include <cstdio>

inline int Max(int x, int y) { return x > y ? x : y; }

const int MN = 100005;
const int MS = 6200005;
const int BK = 29;

int N, Q;
int A[MN];
int eh[MN], nxt[MN * 2], to[MN * 2], tot;
inline void insw(int x, int y) {
	nxt[++tot] = eh[x]; to[tot] = y; eh[x] = tot;
	nxt[++tot] = eh[y]; to[tot] = x; eh[y] = tot;
}

int sz[MS], ch[MS][2], cnt;
int rt1[MN], rt2[MN];
inline void Ins(int &rt, int x, int j) {
	ch[++cnt][0] = ch[rt][0], ch[cnt][1] = ch[rt][1], sz[cnt] = sz[rt], rt = cnt;
	++sz[rt];
	if (~j) Ins(ch[rt][x >> j & 1], x, j - 1);
}

int ldf[MN], rdf[MN], dep[MN], faz[MN][17], dfc;

void DFS(int u, int fa) {
	ldf[u] = ++dfc; faz[u][0] = fa; dep[u] = dep[fa] + 1;
	Ins(rt1[dfc] = rt1[dfc - 1], A[u], BK);
	Ins(rt2[u] = rt2[fa], A[u], BK);
	for (int j = 1; 1 << j < dep[u]; ++j) faz[u][j] = faz[faz[u][j - 1]][j - 1];
	for (int i = eh[u]; i; i = nxt[i]) if (to[i] != fa) DFS(to[i], u);
	rdf[u] = dfc;
}

inline int LCA(int x, int y) {
	if (dep[x] < dep[y]) x ^= y ^= x ^= y;
	for (int d = dep[x] - dep[y], j = 0; d; d >>= 1, ++j) if (d & 1) x = faz[x][j];
	if (x == y) return x;
	for (int j = 16; ~j; --j) if (faz[x][j] != faz[y][j]) x = faz[x][j], y = faz[y][j];
	return faz[x][0];
}

int Qu(int rt1, int rt2, int x, int j) {
	if (j == -1) return 0;
	int p = (x >> j & 1) ^ 1;
	if (sz[ch[rt1][p]] - sz[ch[rt2][p]])
		return Qu(ch[rt1][p], ch[rt2][p], x, j - 1) | 1 << j;
	return Qu(ch[rt1][p ^ 1], ch[rt2][p ^ 1], x, j - 1);
}

int main() {
	scanf("%d%d", &N, &Q);
	for (int i = 1; i <= N; ++i)
		scanf("%d", A + i);
	for (int i = 1, x, y; i < N; ++i) {
		scanf("%d%d", &x, &y);
		insw(x, y);
	}
	DFS(1, 0);
	for (int i = 1, opt, x, y, z; i <= Q; ++i) {
		scanf("%d", &opt);
		if (opt == 1) {
			scanf("%d%d", &x, &z);
			printf("%d\n", Qu(rt1[rdf[x]], rt1[ldf[x] - 1], z, BK));
		}
		else {
			scanf("%d%d%d", &x, &y, &z);
			int w = faz[LCA(x, y)][0];
			printf("%d\n", Max(Qu(rt2[x], rt2[w], z, BK), Qu(rt2[y], rt2[w], z, BK)));
		}
	}
	return 0;
}
```

---

## 作者：Karry5307 (赞：20)

### 题意

给一棵 $n$ 个点的树，每个点有点权。有 $q$ 次操作，每次操作为查询链上或子树中点权与 $x$ 异或的最大值。

$\texttt{Data Range:}1\leq n,q\leq 10^5$

### 题解

不会数据结构的大彩笔居然不看题解 1A 了这题，感动……

首先这种题目应该是 01trie 求最大异或和。由于处理子树询问的时候对每个点都开一个 01trie 显然不现实，所以考虑可持久化 01trie。

首先考虑所有的子树内询问。因为可持久化 01trie 本质上是高度为 $32$ 的主席树，具有可减性，所以如果把这个东西拍到序列上会非常好做。于是用 dfs 序将一个子树内的东西拍到一段连续的区间上，然后类似区间 $k$ 小值就做完了。

对于所有的链上询问，可以参考 Count on a tree 那题的做法，也就是一个节点上的可持久化 01trie 上有这个节点到根路径上所有数，对于查询的话直接树上差分就好了。因为这东西具有可减性所以没什么问题。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef int ll;
typedef long long int li;
const ll MAXN=2e5+51;
struct Edge{
	ll to,prev;
};
Edge ed[MAXN<<1];
ll n,qcnt,op,u,v,c,tot,totn,totd;
ll x[MAXN],last[MAXN],rt[MAXN],rt2[MAXN],dfn[MAXN],sz[MAXN];
ll fa[MAXN],depth[MAXN],rdfn[MAXN],hv[MAXN],top[MAXN],s[MAXN<<6];
ll ch[MAXN<<6][2];
inline ll read()
{
    register ll num=0,neg=1;
    register char ch=getchar();
    while(!isdigit(ch)&&ch!='-')
    {
        ch=getchar();
    }
    if(ch=='-')
    {
        neg=-1;
        ch=getchar();
    }
    while(isdigit(ch))
    {
        num=(num<<3)+(num<<1)+(ch-'0');
        ch=getchar();
    }
    return num*neg;
}
inline void addEdge(ll from,ll to)
{
	ed[++tot].prev=last[from];
	ed[tot].to=to;
	last[from]=tot;
}
inline ll insert(ll x,ll node,ll depth) 
{
	ll cur=++totn;
	s[cur]=s[node]+1,ch[cur][0]=ch[node][0],ch[cur][1]=ch[node][1];
	if(depth==-1)
	{
		return cur;
	}
	return ch[cur][(x>>depth)&1]=insert(x,ch[node][(x>>depth)&1],depth-1),cur;
}
inline void dfs(ll node,ll f)
{
	ll mx=-1;
	rdfn[dfn[node]=++totd]=node,sz[node]=1,depth[node]=depth[f]+1;
	rt2[node]=insert(x[node],rt2[fa[node]=f],31);
	for(register int i=last[node];i;i=ed[i].prev)
	{
		if(ed[i].to!=f)
		{
			dfs(ed[i].to,node),sz[node]+=sz[ed[i].to];
			sz[ed[i].to]>mx?mx=sz[hv[node]=ed[i].to]:1;
		}
	}
}
inline void dfs2(ll node,ll link)
{
	ll to;
	top[node]=link;
	if(!hv[node])
	{
		return;
	}
	dfs2(hv[node],link);
	for(register int i=last[node];i;i=ed[i].prev)
	{
		(to=ed[i].to)!=fa[node]&&to!=hv[node]?dfs2(to,to):(void)1;
	}
}
inline ll LCA(ll x,ll y)
{
	while(top[x]!=top[y])
	{
		depth[top[x]]<depth[top[y]]?swap(x,y):(void)1,x=fa[top[x]];
	}
	return depth[x]<depth[y]?x:y;
}
inline ll query(ll x,ll lc,ll rc,ll depth)
{
	if(depth==-1)
	{
		return 0;
	}
	ll nxt=!((x>>depth)&1),d=nxt^(!(s[ch[rc][nxt]]-s[ch[lc][nxt]]));
	return (d<<depth)+query(x,ch[lc][d],ch[rc][d],depth-1);
}
inline ll query(ll x,ll l1,ll l2,ll l3,ll l4,ll depth)
{
	if(depth==-1)
	{
		return 0;
	}
	ll nxt=!((x>>depth)&1);
	ll d=nxt^(!(s[ch[l1][nxt]]+s[ch[l2][nxt]]-s[ch[l3][nxt]]-s[ch[l4][nxt]]));
	return (d<<depth)+query(x,ch[l1][d],ch[l2][d],ch[l3][d],ch[l4][d],depth-1);
}
inline ll query(ll u,ll v,ll x)
{
	ll l=LCA(u,v);
	return query(x,rt2[u],rt2[v],rt2[l],rt2[fa[l]],31);
}
int main()
{
	n=read(),qcnt=read();
	for(register int i=1;i<=n;i++)
	{
		x[i]=read();
	}
	for(register int i=0;i<n-1;i++)
	{
		u=read(),v=read(),addEdge(u,v),addEdge(v,u);
	}
	dfs(1,0),dfs2(1,1);
	for(register int i=1;i<=n;i++)
	{
		rt[i]=insert(x[rdfn[i]],rt[i-1],31);
	}
	for(register int i=1;i<=qcnt;i++)
	{
		op=read();
		if(op==1)
		{
			u=read(),c=read();
			printf("%d\n",query(c,rt[dfn[u]-1],rt[dfn[u]+sz[u]-1],31)^c);
		}
		if(op==2)
		{
			u=read(),v=read(),c=read(),printf("%d\n",query(u,v,c)^c);
		}
	}
}
```

---

## 作者：Owen_codeisking (赞：12)

我没有想到差分的思路……我来提供 $O(30nlogn)$ 的思路

操作 $1$：将子树问题转化为一段 $dfs$ 序然后在可持久化 $trie$ 上利用异或的性质高位往低位贪心，单次操作 $O(30)$

操作 $2$：用树剖的思想不停往 $top$ 上跳，将一条树上路径转化为多段 $dfs$ 序的答案取个 $max$，单次操作 $O(30logn)$

不过我相当于两个 $log$ 的代码没开 $O_2$ 最大一个点 $425ms$，可能是树剖常数跑不满所以没有被卡掉

$Code\ Below:$

```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn=100000+10;
int n,m,a[maxn],head[maxn],to[maxn<<1],nxt[maxn<<1],tot;
int top[maxn],dep[maxn],siz[maxn],son[maxn],fa[maxn],id[maxn],mp[maxn],tim;
int T[maxn],ch[maxn<<5][2],sum[maxn<<5],cnt;
bool b[maxn];

inline int read(){
	register int x=0,f=1;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}
	while(isdigit(ch)){x=(x<<3)+(x<<1)+ch-'0';ch=getchar();}
	return (f==1)?x:-x;
}
inline void add(int x,int y){
	to[++tot]=y;
	nxt[tot]=head[x];
	head[x]=tot;
}

void dfs1(int x,int f){
	siz[x]=1;fa[x]=f;
	dep[x]=dep[f]+1;
	int maxson=-1;
	for(int i=head[x],y;i;i=nxt[i]){
		y=to[i];
		if(y==f) continue;
		dfs1(y,x);
		siz[x]+=siz[y];
		if(maxson<siz[y]){
			maxson=siz[y];
			son[x]=y;
		}
	}
}

void dfs2(int x,int topf){
	id[x]=++tim;
	mp[tim]=a[x];
	top[x]=topf;
	if(son[x]) dfs2(son[x],topf);
	for(int i=head[x],y;i;i=nxt[i]){
		y=to[i];
		if(y==fa[x]||y==son[x]) continue;
		dfs2(y,y);
	}
}

void split(int x){
	for(int i=0;i<=30;i++){
		b[i]=x&1;x>>=1;
	}
}

void update(int pre,int now){
	for(int i=30;i>=0;i--){
		ch[now][b[i]]=++cnt;
		ch[now][b[i]^1]=ch[pre][b[i]^1];
		now=ch[now][b[i]];pre=ch[pre][b[i]];
		sum[now]=sum[pre]+1;
	}
}

int query(int u,int v){
	int ans=0;
	for(int i=30;i>=0;i--){
		ans<<=1;
		if(sum[ch[v][b[i]^1]]-sum[ch[u][b[i]^1]]>0){
			ans|=1;
			v=ch[v][b[i]^1];u=ch[u][b[i]^1];
		}
		else {
			v=ch[v][b[i]];u=ch[u][b[i]];
		}
	}
	return ans;
}

int main()
{
	n=read(),m=read();
	for(int i=1;i<=n;i++) a[i]=read();
	int opt,x,y,z,ans;
	for(int i=1;i<n;i++){
		x=read(),y=read();
		add(x,y);add(y,x);
	}
	dfs1(1,0);dfs2(1,1);
	for(int i=1;i<=n;i++){
		split(mp[i]);T[i]=++cnt;
		update(T[i-1],T[i]);
	}
	for(int i=1;i<=m;i++){
		opt=read();
		if(opt==1){
			x=read(),y=read();split(y);
			printf("%d\n",query(T[id[x]-1],T[id[x]+siz[x]-1]));
		}
		else {
			x=read(),y=read(),z=read();
			split(z);ans=0;
			while(top[x]!=top[y]){
				if(dep[top[x]]<dep[top[y]]) swap(x,y);
				ans=max(ans,query(T[id[top[x]]-1],T[id[x]]));
				x=fa[top[x]];
			}
			if(dep[x]>dep[y]) swap(x,y);
			ans=max(ans,query(T[id[x]-1],T[id[y]]));
			printf("%d\n",ans);
		}
	}
	return 0;
}
```

---

## 作者：Fading (赞：6)

这道题正解（雾，是可持久化$01Trie$。

前置知识:可持久化$01Trie$求解区间$Xor$问题($P4735 \text{最大异或和}$)、树上版可持久化线段树求$k$小($P2633Count\ on\ a\ tree$)

这题其实就是树上版。第$1$问很简单，直接用$DFS$序维护子树信息就可以了。

```
tr.query(tpos[x],tpos[x]+size[x]-1,y)//tpos 节点x的DFS序
```

第$2$问?回想一下树上的可持久化线段树($count\ on \ a \ tree\ COT1$)

对于每一个节点，直接在$DFS$遍历整棵树的时候以此时节点的父亲为基础插入这个权值就好了。

$P4735 \text{最大异或和}$是这么插入的:
```
root[i]=root[i-1];
tr.insert(root[i],x);
```
我们只需要改为:
```
root[i]=root[fa];
tr.insert(root[i],x);
```
就好了$QwQ$

查询？和$count\ on \ a \ tree\ COT1$一样，利用$LCA$进行差分查询就可以啦！

我用$struct$封装了$01Trie$，代码短了很多而且丑了很多……

```
#include<bits/stdc++.h>
using namespace std;
int n,m,sum,dep[200001],a[200001],ktot,size[200001],tpos[200001],pre[200001],head[200001],tot,f[200001][25];
struct edge{
    int to,next;
}g[1000001];
inline void made(int from,int to){
    g[++tot].to=to;g[tot].next=head[from];head[from]=tot;
}
inline int read(){
    int x=0,f=1;char ch=getchar();
    while (!isdigit(ch)){if (ch=='-') f=-1;ch=getchar();}
    while (isdigit(ch)){x=(x<<1)+(x<<3)+ch-48;ch=getchar();}
    return x*f;
}
struct Trie{
    int n,son[10000001][2],cnt=1,sum,root[200001],ct[10000001];
    void ins(int &rt,int x,int T){
        ct[++cnt]=ct[rt]+1;son[cnt][0]=son[rt][0];
        son[cnt][1]=son[rt][1];rt=cnt;
        if (T==-1) return;
        register bool y=(x>>T)&1;
        ins(son[rt][y],x,T-1);
    }
    inline void insert(int pre,int rt,int x){
        root[rt]=root[pre];
        ins(root[rt],x,30);
    }
    int QUE(int i,int j,int x,int T){//序列版
        if (T==-1) return 0;
        register bool y=(x>>T)&1;
        if (ct[son[j][1^y]]>ct[son[i][1^y]]) return ((1<<T)+QUE(son[i][1^y],son[j][1^y],x,T-1));
        else return QUE(son[i][y],son[j][y],x,T-1);
    }
    int queryxx(int i,int j,int lc,int flc,int x,int T){//树上差分版
        if (T==-1) return 0;
        register bool y=(x>>T)&1;
        if (ct[son[j][1^y]]+ct[son[i][1^y]]>ct[son[lc][1^y]]+ct[son[flc][1^y]]) return ((1<<T)+queryxx(son[i][1^y],son[j][1^y],son[lc][1^y],son[flc][1^y],x,T-1));
        else return queryxx(son[i][y],son[j][y],son[lc][y],son[flc][y],x,T-1);
    }
    int queryx(int i,int j,int lc,int flc,int x,int T){
        return queryxx(root[i],root[j],root[lc],root[flc],x,T);
    }
    inline int query(int l,int r,int x){
        return QUE(root[l-1],root[r],x,30);
    }
}tr1,tr2;
void dfs0(int u,int fa){
    dep[u]=dep[fa]+1;f[u][0]=fa;tpos[u]=++ktot;pre[ktot]=u;
    tr1.insert(fa,u,a[u]);size[u]=1;
    for (int i=1;i<=21;i++) f[u][i]=f[f[u][i-1]][i-1];
    for (int i=head[u];i;i=g[i].next){
        int v=g[i].to;
        if (v==fa) continue;
        dfs0(v,u);size[u]+=size[v];
    }
}
inline int lca(int x,int y){
    if (dep[x]<dep[y]) swap(x,y);
    for (int i=21;i>=0;i--){
        if (dep[f[x][i]]>=dep[y]) x=f[x][i];
    }
    if (x==y) return x;
    for (int i=21;i>=0;i--){
        if (f[x][i]!=f[y][i]) x=f[x][i],y=f[y][i];
    }
    return f[x][0];
}
int main(){
    n=read();m=read();
    for (int i=1;i<=n;i++) a[i]=read();
    for (int i=1;i<n;i++){
    	int x=read(),y=read();
    	made(x,y);made(y,x);
    }
    dfs0(1,0);
    for (int i=1;i<=n;i++){
    	tr2.insert(i-1,i,a[pre[i]]);
    }
    while (m--){
        int opt=read();
        if (opt==1){
            int x=read(),y=read();
            printf("%d\n",tr2.query(tpos[x],tpos[x]+size[x]-1,y));
        }else{
            int x=read(),y=read(),z=read(),a=lca(x,y);
            printf("%d\n",tr1.queryx(x,y,a,f[a][0],z,30));
        }
    }
}

```

---

## 作者：Hehe_0 (赞：5)

------------
我们审题：两个操作  
1. 从子树中选一个点使得异或结果更大  
2.   $  x  \to  y  $  的路径上选一个点使得异或结果更大    
（树上主席树可以解决）

------------

  
此外：查询最大值（异或）。  
我们可以用主席树来存储  01trie  树 。  
也就是建立一个可持久的  01trie  再结合树剖。
    
  在每次查找最大值时，我们可以考虑一种类似贪心的想法，尽量让前几位大 。  
  记得开 long long 。  
  推荐其他题 ：  [最大异或和](https://www.luogu.com.cn/problem/P4735)
```cpp
#include<bits/stdc++.h>

#define int long long 
using namespace std;
const int N=4e5+7;

int n,m;
int son[N],dep[N],siz[N],f[N];
int top[N],id[N],p;
int tot,t[N];

int head[N],nxt[N],to[N];

int tree[N*20][2];
int root[N],num[N*20];
int data[N],flag[2];
int ans;


int _,cnt;
void added(int x,int y)//加边
{
	_++;
	to[_]=y;
	nxt[_]=head[x];
	head[x]=_;
	return ;
}

int add(int fa,int x,int k)//我们插入
{
	int re=++cnt;
	int now=((x>>k)&1);
	//取出来 
	
	tree[re][0]=tree[fa][0];//继承上层关系
	tree[re][1]=tree[fa][1];
	num[re]=num[fa]+1;
	
	if(k>=0)
	tree[re][now]=add(tree[re][now],x,k-1);
	
	return re;//返回标号 
}


void query(int l,int r,int x,signed k)
{
	int now=((x>>k)&1);
	flag[0]=num[tree[r][0]]-num[tree[l][0]];
	flag[1]=num[tree[r][1]]-num[tree[l][1]];	
	
	if(flag[now^1])
	{//因为1^0=1的情况最大
		ans+=(1<<k);
		if(k>=0)
		query(tree[l][now^1],tree[r][now^1],x,k-1);
	}
	else if(k>=0)
	{
		query(tree[l][now],tree[r][now],x,k-1);
	}
	return ;
}

void dfs1(int x)//树剖
{
    siz[x]=1;
    for(int i=head[x];i;i=nxt[i])
    {
        int tt=to[i];
        if(!siz[tt])
        {
            dep[tt]=dep[x]+1;
            f[tt]=x;
            dfs1(tt);
            siz[x]+=siz[tt];
            if(siz[tt]>siz[son[x]])
            son[x]=tt;
        }
    }
}
void dfs2(int x,int fa)
{
    top[x]=fa;
    id[x]=++tot;
    t[tot]=data[x];
    if(son[x])
    dfs2(son[x],fa);
    for(int i=head[x];i;i=nxt[i])
    {
        int y=to[i];
        if(!top[y])
        if(y!=son[x])
            dfs2(y,y);
    }
    return ; 
}


int solve(int x,int y,int w)
{
    int  re=0;
    while(top[x]!=top[y])
    {//lca下
        if(dep[top[x]]<dep[top[y]])
        swap(x,y);
        ans=0;
       //32二进制位 
       query(root[id[top[x]]-1],root[id[x]],w,32);
        re=max(ans,re);
        x=f[top[x]];
    }
    if(id[x]>id[y])
    swap(x,y);
    ans=0;
    query(root[id[x]-1],root[id[y]],w,32);
    re=max(re,ans);
    // 最大 
    return re;
}

signed main()
{
	ios::sync_with_stdio(false);
	cin>>n>>m;
	
	for(int i=1;i<=n;i++)
	cin>>data[i];
	
	for(int i=1;i<n;i++)
	{
		int q,w;
		cin>>q>>w;
		added(q,w);
		added(w,q);
	}
	dfs1(1);//树剖的树建出来 
    dfs2(1,1);
    
    for(int i=1;i<=n;i++)
    {
    	root[i]=add(root[i-1],t[i],32);
	}
	
	while(m--)
	{
		int tmp,q,w,e;
		cin>>tmp;
		if(tmp==1)
		{
			cin>>q>>w;
			ans=0;
			query(root[id[q]-1],root[id[q]+siz[q]-1],w,32);
			cout<<ans<<endl;
		}
		else
		{
			cin>>q>>w>>e;
			if(q==w)//一个点的话，直接异或 
			cout<<(data[q]^e)<<endl;
			else//q到w的链上 
			cout<<solve(q,w,e)<<endl;
		}
		
		
	}
	
	
	return 0;
 } 
```



---

## 作者：Leianha (赞：3)

## 可持久化0/1Trie树

[博客阅读](https://www.cnblogs.com/wljss/p/12601445.html)

对于一段区间查询最大异或值，我们可以用 可持久化0/1Trie树 来维护。

对于一个点的子树，它们的 $dfs$ 序是一段连续的区间。

对于一条路经，我们拆成两个端点分别到达 $LCA$ 的两条路径，它们的 $dep$ 是连续的。

我们分别建出来 1.以 $dfs$ 序为外层的树 2.以 $dep$ 为外层的树 这两种树即可。
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int n, q, x, y, z, tot, DFN, opt, cnt, lca;
const int N = 100010;
int head[N], to[N << 1], nt[N << 1], v[N], dfn[N], nfd[N], siz[N], son[N], top[N], dep[N], fa[N], root1[N], root2[N], tr[N * 63][2], sum[N * 63];
void add(int f, int t)
{
	to[++tot] = t; nt[tot] = head[f]; head[f] = tot;
}
void Insert(int pre, int &k, int x, int t)
{
	k = ++cnt; sum[k] = sum[pre] + 1;
	if (!t)return;
	int i = (x >> (t - 1)) & 1;
	tr[k][!i] = tr[pre][!i]; Insert(tr[pre][i], tr[k][i], x, t - 1);
}
int ask(int pre, int k, int x, int t)
{
	if (!t)return 0;
	int i = x >> (t - 1) & 1;
	if (sum[tr[k][!i]] > sum[tr[pre][!i]])return (1 << (t - 1)) | ask(tr[pre][!i], tr[k][!i], x, t - 1);
	else return ask(tr[pre][i], tr[k][i], x, t - 1);
}
void dfs1(int x, int f)
{
	Insert(root1[f], root1[x], v[x], 30); //父子
	fa[x] = f; siz[x] = 1; dep[x] = dep[f] + 1;
	for (int i = head[x]; i; i = nt[i])
		if (to[i] != f)
		{
			dfs1(to[i], x);
			siz[x] += siz[to[i]];
			if (siz[to[i]] > siz[son[x]])son[x] = to[i];
		}
}
void dfs2(int x, int t)
{
	top[x] = t; dfn[x] = ++DFN; nfd[DFN] = x;
	Insert(root2[nfd[DFN - 1]], root2[x], v[x], 30); //子树
	if (son[x])dfs2(son[x], t);
	else return;
	for (int i = head[x]; i; i = nt[i])
		if (to[i] != fa[x] && to[i] != son[x])dfs2(to[i], to[i]);
}
int LCA(int x, int y)
{
	while (top[x] != top[y])
	{
		if (dep[top[x]] < dep[top[y]])swap(x, y);
		x = fa[top[x]];
	}
	return dep[x] < dep[y] ? x : y;
}
int main()
{
	cin >> n >> q;
	for (int i = 1; i <= n; ++i)scanf("%d", &v[i]);
	for (int i = 1; i < n; ++i)
	{
		scanf("%d%d", &x, &y);
		add(x, y); add(y, x);
	}
	dfs1(1, 0); dfs2(1, 1);
	while (q--)
	{
		scanf("%d", &opt);
		if (opt == 1)
		{
			scanf("%d%d", &x, &z);
			printf("%d\n", ask(root2[nfd[dfn[x] - 1]], root2[nfd[dfn[x] + siz[x] - 1]], z, 30));
		}
		else
		{
			scanf("%d%d%d", &x, &y, &z);
			lca = LCA(x, y);
			printf("%d\n", max(ask(root1[fa[lca]], root1[x], z, 30), ask(root1[fa[lca]], root1[y], z, 30)));
		}
	}
	return 0;
}
```

---

## 作者：nekko (赞：3)

子树查询，也就是说dfs序上的连续一段了，也就转化成了区间问题

链上查询，相当于x到lca，y到lca查询，也就相当于区间问题了

区间问题？这不就是可持久化trie树的模板题么

考虑给定一个集合，每次查询y，找一个x使得x xor y最大

不妨将集合中的元素按照二进制从高向低位插入到trie中（字典集大小为2）

那么对于y，只需要从高往低位贪心的去跑就可以了

比如说y的当前位为bit，那么要贪心的话，必须走bit xor 1那个下一位

只要你空间开对了，以及没有犯一些zz错误，就可以1A了

``` cpp
// luogu-judger-enable-o2
#include "bits/stdc++.h"
using namespace std;
const int N = 1e5 + 10;
typedef long long ll;

int n, q, val[N];

int head[N], rest[N * 2], to[N * 2], tot;

void add(int u, int v) {
    to[++ tot] = v, rest[tot] = head[u], head[u] = tot;
}

struct Trie {
    int root[N], tot, ch[N * 35][2], cnt[N * 35];
    Trie() { root[0] = tot = 1; }
    void ins(int last, int &now, int x) {
        int rt = now = ++ tot;
        for(int i = 30 ; ~ i ; -- i) {
            int bit = (x >> i) & 1;
            ch[rt][!bit] = ch[last][!bit];
            ch[rt][bit] = ++ tot;
            rt = ch[rt][bit];
            last = ch[last][bit];
            cnt[rt] = cnt[last] + 1;
        }
    }
    int query(int L, int R, int x) {
        int res = 0;
        for(int i = 30 ; ~ i ; -- i) {
            int bit = (x >> i) & 1;
            if(cnt[ch[R][!bit]] - cnt[ch[L][!bit]]) {
                R = ch[R][!bit];
                L = ch[L][!bit];
                res |= 1 << i;
            } else {
                R = ch[R][bit];
                L = ch[L][bit];
            }
        }
        return res;
    }
} seq, tre;

int dfn[N], l[N], r[N], clk, fa[N][30], dep[N];

void dfs(int u, int fa) {
    tre.ins(tre.root[fa], tre.root[u], val[u]);
    :: fa[u][0] = fa;
    dep[u] = dep[fa] + 1;
    l[u] = ++ clk;
    dfn[clk] = val[u];
    for(int i = head[u] ; i ; i = rest[i]) {
        int v = to[i];
        if(v == fa) continue;
        dfs(v, u);
    }
    r[u] = clk;
}

int lca(int u, int v) {
    if(dep[u] < dep[v]) swap(u, v);
    for(int i = 25 ; ~ i ; -- i)
        if(dep[fa[u][i]] >= dep[v])
            u = fa[u][i];
    if(u == v) return u;
    for(int i = 25 ; ~ i ; -- i)
        if(fa[u][i] != fa[v][i])
            u = fa[u][i],
            v = fa[v][i];
    return fa[u][0];
}

int main() {

    scanf("%d%d", &n, &q);
    for(int i = 1 ; i <= n ; ++ i) scanf("%d", &val[i]);
    for(int i = 1, u, v ; i < n ; ++ i) {
        scanf("%d%d", &u, &v);
        add(u, v), add(v, u);
    }
    dfs(1, 0);
    for(int j = 1 ; j <= 25 ; ++ j)
        for(int i = 1 ; i <= n ; ++ i)
            fa[i][j] = fa[fa[i][j - 1]][j - 1];
    for(int i = 1 ; i <= n ; ++ i) {
        seq.ins(seq.root[i - 1], seq.root[i], dfn[i]);
    }
    for(int i = 1, op, x, y, z ; i <= q ; ++ i) {
        scanf("%d%d%d", &op, &x, &y);
        if(op == 1) {
            printf("%d\n", seq.query(seq.root[l[x] - 1], seq.root[r[x]], y));
        } else {
            scanf("%d", &z);
            int d = lca(x, y);
            printf("%d\n", max(tre.query(tre.root[fa[d][0]], tre.root[x], z), tre.query(tre.root[fa[d][0]], tre.root[y], z)));
        }
    }
}
```

---

## 作者：elijahqi (赞：3)

求子树或x-y路径上任意一个数和某个数异或值最大
分别dfs序和到根建可持久化trie树
每次加加减减得到互相的关系 在trie树上贪心即可
```
#include<cstdio>
#include<cctype>
#include<algorithm>
using namespace std;
inline char gc(){
	static char now[1<<16],*S,*T;
	if (T==S){T=(S=now)+fread(now,1,1<<16,stdin);if (T==S) return EOF;}
	return *S++;
}
inline int read(){
	int x=0,f=1;char ch=gc();
	while(!isdigit(ch)) {if (ch=='-') f=-1;ch=gc();}
	while(isdigit(ch)) x=x*10+ch-'0',ch=gc();
	return x*f;
}
const int N=1e5+10;
struct node{
	int sum[2],ch[2];
}tree1[N*33],tree2[N*33];
struct node1{
	int y,next;
}data[N<<1];
int h[N],cnt1,cnt2,num,rt1[N],rt2[N],fa[N][20],v[N],dep[N],Log[N],n,q,in[N],out[N],ans,bin[33];
inline void init1(int &x){tree1[++cnt1]=tree1[x];x=cnt1;}
inline void insert1(int &x,int v){
	init1(x);int p=x;
	for (int i=30,op;~i;--i){
		op=(v&bin[i])>0;
		++tree1[p].sum[op];init1(tree1[p].ch[op]);p=tree1[p].ch[op];
	}
}
inline void init2(int &x){tree2[++cnt2]=tree2[x];x=cnt2;}
inline void insert2(int &x,int v){
	init2(x);int p=x;
	for (int i=30,op;~i;--i){
		op=(v&bin[i])>0;
		++tree2[p].sum[op];init2(tree2[p].ch[op]);p=tree2[p].ch[op];
	}
}
inline void query1(int rt1,int rt2,int v){
	for (int i=30,op;~i;--i){
		op=(v&bin[i])>0;
		if (tree1[rt2].sum[op^1]-tree1[rt1].sum[op^1]){
			ans+=bin[i];rt2=tree1[rt2].ch[op^1];rt1=tree1[rt1].ch[op^1];
		}else rt2=tree1[rt2].ch[op],rt1=tree1[rt1].ch[op];
	}
}
inline void query2(int rt1,int rt2,int rt3,int rt4,int v){
	for (int i=30,op;~i;--i){
		op=(v&bin[i])>0;
		if (tree2[rt4].sum[op^1]+tree2[rt3].sum[op^1]-tree2[rt2].sum[op^1]-tree2[rt1].sum[op^1]){
			rt4=tree2[rt4].ch[op^1];rt3=tree2[rt3].ch[op^1];ans+=bin[i];
			rt2=tree2[rt2].ch[op^1];rt1=tree2[rt1].ch[op^1];
		}else{
			rt4=tree2[rt4].ch[op];rt3=tree2[rt3].ch[op];
			rt2=tree2[rt2].ch[op];rt1=tree2[rt1].ch[op];
		}
	}
}
inline void dfs(int x){
	in[x]=++num;rt1[in[x]]=rt1[in[x]-1];insert1(rt1[in[x]],v[x]);insert2(rt2[x],v[x]);
	for (int i=h[x];i;i=data[i].next){
		int y=data[i].y;if (y==fa[x][0]) continue;
		fa[y][0]=x;dep[y]=dep[x]+1;rt2[y]=rt2[x];
		for (int j=1;j<=Log[dep[y]];++j) fa[y][j]=fa[fa[y][j-1]][j-1];dfs(y);
	}out[x]=num;
}
inline int lca(int x,int y){
	if (dep[x]<dep[y]) swap(x,y);int dis=dep[x]-dep[y];
	for (int i=0;i<=Log[dis];++i) if (dis&(1<<i)) x=fa[x][i];
	if (x==y) return x;
	for (int i=Log[dep[y]];~i;--i)
		if (fa[x][i]!=fa[y][i]) x=fa[x][i],y=fa[y][i];
	return fa[x][0];
}
int main(){
	freopen("xor.in","r",stdin);
	freopen("xor.out","w",stdout);
	n=read();q=read();Log[0]=-1;
	for (int i=0;i<=30;++i) bin[i]=1<<i;
	for (int i=1;i<=n;++i) v[i]=read(),Log[i]=Log[i>>1]+1;
	for (int i=1;i<n;++i){
		int x=read(),y=read();
		data[++num].y=y;data[num].next=h[x];h[x]=num;
		data[++num].y=x;data[num].next=h[y];h[y]=num;
	}num=0;dfs(1);
	for (int i=1;i<=q;++i){
		int op=read();
		if (op==1){
			int x=read(),z=read();ans=0;
			query1(rt1[in[x]-1],rt1[out[x]],z);printf("%d\n",ans);
		}else{
			int x=read(),y=read(),z=read(),t=lca(x,y);ans=0;
			query2(rt2[fa[t][0]],rt2[t],rt2[x],rt2[y],z);printf("%d\n",ans);
		}
	}
}
```

---

## 作者：qiyue7 (赞：2)

给个比较小清新的做法，我们注意到1操作和2操作互不干扰而且不带修改，
那么我们就可以很轻易地用离线做法做到nlogn的复杂度。1操作1采用dsu on tree 离线处理，操作2可以用类似树上点权k小的做法去解决，这样子这题就变成比较无脑的码农题了/


AC代码：
```cpp
namespace trie01
{
	const int sigma = 32;
	long long base = 1;
	struct node
	{
		node *child[2];
		int times;
		int element;
		bool lazy;
		void clear()
		{
			lazy = times = element = 0;
		}
	};
	node *prefix[120000], *dsu[120000];
	int ans[120000], w[120000];
	vector<pair<int, int> > query1[120000];
	queue<tuple<int, int, int, int> > query2;
	node *history[200000];
	node pool[11000000];
	node *root, *cur = pool, *null;
	node *new_()
	{
		cur->clear();
		cur->child[0] = cur->child[1] = null;
		return cur++;
	}
	void init()
	{
		null = new node();
		null->times = null->element = null->lazy = 0;
		null->child[0] = null->child[1] = null;
		cur = pool;
		root = new_();
		history[0] = new_();
	}
	void insert(node *ver_s, int pos, int element, int add)
	{
		node *found = ver_s;
		bitset<sigma + 1> kkk = pos;
		found->times += add;
		for (int i = sigma; i >= 0; --i)
		{
			if (found->child[kkk[i]] == null)
			{
				found->child[kkk[i]] = new_();
				found = found->child[kkk[i]];
			}
			else
				found = found->child[kkk[i]];
			found->times += add;
		}
		found->element = element;
	}
	node *insert_new(int pos, int element, node *old, int add)
	{
		node *found = old, *_new = new_(), *_new2;
		bitset<sigma + 1> kkk = pos;
		_new2 = _new;
		for (int i = sigma; i >= 0; --i)
		{
			_new->times += add;
			_new->child[kkk[i]] = new_();
			if (found == null)
				_new = _new->child[kkk[i]];
			else
			{
				_new->times += found->times;
				_new->child[!kkk[i]] = found->child[!kkk[i]];
				_new = _new->child[kkk[i]];
				found = found->child[kkk[i]];
			}
		}
		_new->times += found->times;
		_new->times += add;
		_new->element = element;
		return _new2;
	}
	void merge(node *a, node *b)
	{
		b->times += a->times;
		for (int i = 0; i < 2; ++i)
		{
			if (a->child[i] != null && b->child[i] != null)
				merge(a->child[i], b->child[i]);
			else if (b->child[i] == null)
				b->child[i] = a->child[i];
		}
	}
	int querymax(node *p, int a)
	{
		bitset<sigma + 1> kkk = a, ans;
		for (int i = sigma; i >= 0; --i)
		{
			if (p->child[!kkk[i]] != null && p->child[!kkk[i]]->times > 0)
				p = p->child[!kkk[i]], ans[i] = !kkk[i];
			else
				p = p->child[kkk[i]], ans[i] = kkk[i];
		}
		return ans.to_ulong() ^ a;
	}
	int querymax(int a, int u, int v, int lca, int fal)
	{
		bitset<sigma + 1> kkk = a, ans;
		node *pu = prefix[u], *pv = prefix[v], *plca = prefix[lca], *falca;
		if (lca == 1)
			falca = null;
		else
			falca = prefix[fal];
		for (int i = sigma; i >= 0; --i)
		{
			int kk = pu->child[!kkk[i]]->times + pv->child[!kkk[i]]->times - plca->child[!kkk[i]]->times - falca->child[!kkk[i]]->times;
			if (kk > 0)
				pu = pu->child[!kkk[i]], pv = pv->child[!kkk[i]], plca = plca->child[!kkk[i]], ans[i] = !kkk[i], falca = falca->child[!kkk[i]];
			else
				pu = pu->child[kkk[i]], pv = pv->child[kkk[i]], plca = plca->child[kkk[i]], ans[i] = kkk[i], falca = falca->child[kkk[i]];
		}
		return ans.to_ulong() ^ a;
	}
}
using namespace trie01;
const int maxn = 120000;
const int max2 = 22;
vector<int> edge[120000];
int father[max2][maxn];
int depth[maxn];
void addedge(int u, int v)
{
	edge[u].emplace_back(v);
	edge[v].emplace_back(u);
}
void dfs2(int x)
{
	for (auto &s : edge[x])
	{
		if (father[0][x] != s)
		{
			father[0][s] = x;
			depth[s] = depth[x] + 1;
			dfs2(s);
		}
	}
}
void  build(int root, int n)
{
	depth[root] = 1;
	dfs2(root);
	for (int k = 0; k < max2; k++)
		for (int i = 1; i <= n; i++)
			if (father[k][i])
				father[k + 1][i] = father[k][father[k][i]];
}
int LCA(int u, int v)
{
	if (depth[u] > depth[v])
		return LCA(v, u);
	if (depth[u] != depth[v]) {
		for (int k = 20 - 1; k >= 0; k--) {
			if (depth[v] - (1 << k) >= depth[u])
				v = father[k][v];
		}
	}
	if (u == v) return u;
	for (int k = max2 - 1; k >= 0; k--) {
		if (father[k][u] == 0) continue;
		if (father[k][u] != father[k][v]) {
			u = father[k][u];
			v = father[k][v];
		}
	}
	return father[0][u];
}
long long Max = INT_MAX;

void dfs(int cur, int fa)
{
	for (auto &p : edge[cur])
	{
		if (p != fa)
		{
			dfs(p, cur);
			merge(dsu[p],dsu[cur]);
		}
	}
	for (auto &p : query1[cur])
		ans[p.second] = querymax(dsu[cur], p.first);
}
void dfs1(int cur, int fa)
{
	for (auto &p : edge[cur])
	{
		if (p != fa)
		{
			prefix[p] = insert_new(w[p], w[p], prefix[cur], 1);
			dfs1(p, cur);
		}
	}
}
int32_t main()
{
	init();
	int n, q, u, v, val, opt;
	cin >> n >> q;
	for (int i = 1; i <= n; ++i)
	{
		cin >> w[i];
		dsu[i] = new_();
		insert(dsu[i], w[i], w[i], 1);
	}
	for (int i = 1; i < n; ++i)
	{
		cin >> u >> v;
		addedge(u, v);
	}
	build(1, n);
	for (int i = 1; i <= q; ++i)
	{
		cin >> opt;
		if (opt == 1)
		{
			cin >> u >> v;
			query1[u].emplace_back(v, i);
		}
		else if (opt == 2)
		{
			cin >> u >> v >> val;
			if (u != v)
				query2.push(make_tuple(u, v, val, i));
			else
				ans[i] = val ^ w[u];
		}
	}
	dfs(1, 0);
	init();
	prefix[1] = new_();
	insert(prefix[1], w[1], w[1], 1);
	dfs1(1, 0);
	while (!query2.empty())
	{
		auto p = query2.front();
		query2.pop();
		int lca = LCA(get<0>(p), get<1>(p)), fal = father[0][lca];
		ans[get<3>(p)] = querymax(get<2>(p), get<0>(p), get<1>(p), lca, fal);
	}
	for (int i = 1; i <= q; ++i)
		 cout<< ans[i] << endl;
	return 0;
}
```


---

## 作者：BzhH (赞：1)

对于题目给出的两个查询，我们我可以将它这样转换：

对于操作一，用dfs序将一个子树转化为一段连续的区间,然后根据dfs序建立一个trie树，那么查询一个子树即为查询一段区间

对于操作二，根据根到结点的路径建立一个trie树,同样也可以转化为一个区间查询

于是就可以建两个trie树,分别对应两个操作

结合代码理解
```
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
const int N = 4e5 + 50, M = 32 * N;

int tr1[M][2], root1[N], tot1, siz[N];
int w[N], n, q, maxn[M], id[N], it[N];
int head[N], ver[N], net[N], idx, cnt, root2[N];
int tr2[M][2], dep[N], fa[N][25], maxd[M], tot2;

void add(int a, int b)
{
    net[idx] = head[a];
    ver[idx] = b;
    head[a] = idx++;
}

void insert1(int p, int q, int i, int k)
{
    if (i < 0)
    {
        maxn[p] = k;//记录一下最大dfs序
        return;
    }
    int v = w[it[k]] >> i & 1;
    if (q)
        tr1[p][!v] = tr1[q][!v];
    tr1[p][v] = ++tot1;   
    insert1(tr1[p][v], tr1[q][v], i - 1, k);
    maxn[p] = max(maxn[tr1[p][0]], maxn[tr1[p][1]]);
    return;
}

void insert2(int p, int q, int i, int k)
{
    if (i < 0)
    {
        maxd[p] = dep[k];//记录一下最大深度
        return;
    }
    int v = w[k] >> i & 1;
    if (q)
        tr2[p][!v] = tr2[q][!v];
    tr2[p][v] = ++tot2;
    insert2(tr2[p][v], tr2[q][v], i - 1, k);
    maxd[p] = max(maxd[tr2[p][0]], maxd[tr2[p][1]]);
    return;
}

int query1(int p, int v, int l)
{
    for (int i = 30; ~i; --i)
    {
        int s = v >> i & 1;
        if (maxn[tr1[p][!s]] >= l)
            p = tr1[p][!s];
        else
            p = tr1[p][s];
    }
    return v ^ w[it[maxn[p]]];
}

int query2(int p, int v, int l)
{
    int res = 0;
    for (int i = 30; ~i; --i)
    {
        int s = v >> i & 1;
        if (maxd[tr2[p][!s]] >= l)
            p = tr2[p][!s], res += 1 << i;
        else
            p = tr2[p][s];
    }
    return res;
}

void dfs(int u, int f)
{
    id[u] = ++cnt, it[cnt] = u;
    siz[u] = 1, dep[u] = dep[f] + 1, fa[u][0] = f;
    for (int i = 1; i <= 20; i++)
        fa[u][i] = fa[fa[u][i - 1]][i - 1];
    root2[u] = ++tot2;
    insert2(root2[u], root2[f], 30, u);//按照到根节点的路径建树
    for (int i = head[u]; ~i; i = net[i])
    {
        int v = ver[i];
        if (v == f)
            continue;
        dfs(v, u);
        siz[u] += siz[v];
    }
}

int lca(int x, int y)
{
    if (dep[x] > dep[y])
        swap(x, y);
    for (int i = 20; ~i; --i)
        if (dep[fa[y][i]] >= dep[x])
            y = fa[y][i];
    if (x == y)
        return x;
    for (int i = 20; ~i; --i)
        if (fa[x][i] != fa[y][i])
            x = fa[x][i], y = fa[y][i];
    return fa[x][0];
}

int main()
{
    memset(head, -1, sizeof(head));
    scanf("%d%d", &n, &q);
    for (int i = 1; i <= n; i++)
        scanf("%d", &w[i]);
    for (int i = 1; i < n; i++)
    {
        int u, v;
        scanf("%d%d", &u, &v);
        add(u, v), add(v, u);
    }
    dfs(1, 0);
    for (int i = 1; i <= n; i++)
    {
        root1[i] = ++tot1;
        insert1(root1[i], root1[i - 1], 30, i);
    }
    while (q--)
    {
        int op, x, y, z;
        scanf("%d", &op);
        if (op == 1)
        {
            scanf("%d%d", &x, &z);
            printf("%d\n", query1(root1[id[x] + siz[x] - 1], z, id[x]));//查找x的子树,
        }
        else
        {
            scanf("%d%d%d", &x, &y, &z);
            int u = lca(x, y);
            printf("%d\n", max(query2(root2[x], z, dep[u]), query2(root2[y], z, dep[u])));
        }
    }
    return 0;
}
```


---

## 作者：Jμdge (赞：1)

其实这道题很水？

好久没有打持久化 trie 的我还是~~用小号~~ 一遍 A 掉了（我会告诉你我用大号交的时候改了下数组大小结果 RE 了么？）

# noteskey

反正就是树剖+可持久化 trie 啦，挺裸的吧...

现在还是很流行树上玩游戏的啊...

总之打的时候注意一点细节就好了吧...

# code

作为数据结构题这代码够短的了（何况两个数据结构）

```cpp
//by Judge
#include<cstdio>
#include<cstring>
#include<iostream>
#define Rg register
#define fp(i,a,b) for(Rg int i=(a),I=(b)+1;i<I;++i)
#define fd(i,a,b) for(Rg int i=(a),I=(b)-1;i>I;--i)
#define go(G,u) for(Rg int i=G.head[u],v=G.e[i].to;i;v=G.e[i=G.e[i].nxt].to)
#define ll long long
using namespace std;
const int N=1<<30|3;
const int M=6e6+3;
typedef int arr[M];
#ifndef Judge
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
#endif
char buf[1<<21],*p1=buf,*p2=buf;
inline bool cmax(int& a,int b){return a<b?a=b,1:0;}
inline int read(){ int x=0,f=1; char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
	for(;isdigit(c);c=getchar()) x=x*10+c-'0'; return x*f;
} char sr[1<<21],z[20];int CCF=-1,Z;
inline void Ot(){fwrite(sr,1,CCF+1,stdout),CCF=-1;}
inline void print(int x,char chr='\n'){
    if(CCF>1<<20)Ot();if(x<0)sr[++CCF]=45,x=-x;
    while(z[++Z]=x%10+48,x/=10);
    while(sr[++CCF]=z[Z],--Z);sr[++CCF]=chr;
} int n,q,cnt,tim,ans,to[M][2],d[33],num[M];
arr a,siz,dep,f,son,top,dfn,rt;
struct Gr{ int pat,head[M];
	struct Edge{ int to,nxt; }e[M<<1];
	inline void add(int u,int v){
		e[++pat]={v,head[u]},head[u]=pat;
		e[++pat]={u,head[v]},head[v]=pat;
	}
}G;
inline void div(int x){ fp(i,0,30) d[i]=x&1,x>>=1; }
inline void update(int now,int las){
	for(int k=30;~k;--k,num[now]=num[las]+1)
		to[now][d[k]^1]=to[las][d[k]^1],
		now=to[now][d[k]]=++cnt,las=to[las][d[k]];
}
inline int query(int u,int v){ int ans=0;
	for(int k=30;~k;--k)
		if(num[to[v][d[k]^1]]-num[to[u][d[k]^1]])
			ans|=1<<k,u=to[u][d[k]^1],v=to[v][d[k]^1];
		else u=to[u][d[k]],v=to[v][d[k]]; return ans;
}
void dfs(int u,int fa){
	siz[u]=1,dep[u]=dep[fa]+1;
	go(G,u) if(v^fa){
		f[v]=u,dfs(v,u),siz[u]+=siz[v];
		if(siz[v]>siz[son[u]]) son[u]=v;
	}
}
void dfs(int u){ dfn[u]=++tim; if(!top[u]) top[u]=u;
	div(a[u]),rt[tim]=++cnt,update(rt[tim],rt[tim-1]);
	if(son[u]) top[son[u]]=top[u],dfs(son[u]);
	go(G,u) if(v^f[u]&&v^son[u]) dfs(v);
}
inline int ask(int u,int v,int w){ ans=0,div(w);
	for(;top[u]^top[v];u=f[top[u]]){
		if(dep[top[u]]<dep[top[v]]) swap(u,v);
		cmax(ans,query(rt[dfn[top[u]]-1],rt[dfn[u]]));
	} if(dep[u]>dep[v]) swap(u,v);
	return cmax(ans,query(rt[dfn[u]-1],rt[dfn[v]])),ans;
}
inline int ask(int u,int w){ ans=0,div(w);
	return query(rt[dfn[u]-1],rt[dfn[u]+siz[u]-1]);
}
int main(){ n=read(),q=read();
	fp(i,1,n) a[i]=read(); int x,y;
	fp(i,2,n) x=read(),y=read(),G.add(x,y);
	for(dfs(1,0),dfs(1);q;--q){ int op=read(),x,y,z;
		if(op&1) x=read(),y=read(),print(ask(x,y));
		else x=read(),y=read(),z=read(),print(ask(x,y,z));
	} return Ot(),0;
}
```

---

## 作者：lfxxx (赞：1)

分开考虑两个询问。

对于第二个操作，拆分成两条链，然后考虑在树上 dfs 的过程中把当前遍历的点以及其所有祖先加入字典树，然后我们在字典树上对于每个点 $u$ 求出原树上深度最深的点 $v$ 使得插入这个点的点权 $a_v$ 后字典树上存在点 $u$，我们记 $dp_{u} = dep_v$，那么查询一条链时只要视字典树上只存在 $dp_{u} \geq dep_{lca}$ 的节点 $u$，也就是不走 $dp_{u} < dep_{lca}$ 的点，然后用一样的贪心处理异或最大值。在完成对一个点的 dfs 后需要记得撤销操作。

对于第一个操作，子树限制变为 dfs 序区间限制，记这个区间限制为 $[L,R]$，我们把询问挂在 $R$ 上，从小到大对区间做扫描线，相仿的，扫描线的过程中对于字典树上每个点 $u$ 维护最大的点 $v$ 使得插入 dfs 序为 $v$ 的原树上的节点的点权后字典树上存在点 $u$，记这个值为 $dp_{u}$，在贪心求异或最大值时只走 $dp_{u} \geq L$ 的点即可。

时间复杂度依然是 $O(n \log V)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn = 1e5+114;
int n,a[maxn];
vector<int> E[maxn];
int dep[maxn],sz[maxn],son[maxn],top[maxn],father[maxn];
int L[maxn],R[maxn],dfncnt;
int node[maxn];
/*树剖*/
void dfs1(int u,int fa){
    father[u]=fa;
    sz[u]=1;
    L[u]=++dfncnt;
    node[dfncnt]=u;
    dep[u]=dep[fa]+1;
    for(int v:E[u]){
        if(v!=fa){
            dfs1(v,u);
            sz[u]+=sz[v];
            if(sz[v]>sz[son[u]]) son[u]=v;
        }
    }
    R[u]=dfncnt;
}
void dfs2(int u,int tp){
    top[u]=tp;
    if(son[u]!=0) dfs2(son[u],tp);
    for(int v:E[u]){
        if(v!=father[u]&&v!=son[u]) dfs2(v,v);
    }
}
int LCA(int u,int v){
    while(top[u]!=top[v]){
        if(dep[top[u]]<dep[top[v]]) swap(u,v);
        u=father[top[u]];
    }
    if(dep[u]<dep[v]) swap(u,v);
    return v;
}
/*字典树*/
int tot,rt;
int tr[maxn*31],ls[maxn*31],rs[maxn*31];
vector< pair<int,int> > del[maxn];
void ins(int x,int tm,int p){
    int u=rt;
    for(int i=30;i>=0;i--){
        if((1<<i)&x){
            if(rs[u]==0) rs[u]=++tot;
            u=rs[u];
            if(tm>tr[u]) del[p].push_back(make_pair(u,tr[u])),tr[u]=tm;            

        }else{
            if(ls[u]==0) ls[u]=++tot;
            u=ls[u];
            if(tm>tr[u]) del[p].push_back(make_pair(u,tr[u])),tr[u]=tm;
        }
    }
}
void delet(int p){
    while(del[p].size()>0){
        tr[del[p].back().first]=del[p].back().second;
        del[p].pop_back();
    }
}
int ask(int x,int ltm){
    //>=ltm
    int u=rt,ans=0;
    for(int i=30;i>=0;i--){
        if((1<<i)&x){
            if(tr[ls[u]]>=ltm){
                u=ls[u];
                ans+=(1<<i);
            }else u=rs[u];
        }else{
            if(tr[rs[u]]>=ltm){
                u=rs[u];
                ans+=(1<<i);
            }else u=ls[u];
        }
    }
    return ans;
}
/*处理询问*/
int answer[maxn],q;
int type[maxn],X[maxn],Y[maxn],Z[maxn],lca[maxn];
vector<int> opt1[maxn];//(r id)
vector<int> opt2[maxn];//(x id)
void solve1(int u){
    ins(a[u],dep[u],u);
    for(int id:opt2[u]){
        answer[id]=max(answer[id],ask(Z[id],dep[lca[id]]));
    }
    for(int v:E[u]){
        if(v!=father[u]) solve1(v);
    }
    delet(u);
}
void solve2(){
    for(int i=1;i<=tot;i++) tr[i]=ls[i]=rs[i]=0;
    tot=0;
    rt=++tot;
    for(int i=1;i<=n;i++){
        ins(a[node[i]],i,i);
        for(int id:opt1[i]){
            answer[id]=max(answer[id],ask(Z[id],L[X[id]]));
        }
    }
}
/*主函数*/
int main(){
    ios::sync_with_stdio(0);
    cin.tie(0),cout.tie(0);
    cin>>n>>q;
    for(int i=1;i<=n;i++){
        cin>>a[i];
    }
    for(int i=1;i<n;i++){
        int u,v;
        cin>>u>>v;
        E[u].push_back(v);
        E[v].push_back(u);
    }
    dfs1(1,0);
    dfs2(1,1);
    for(int i=1;i<=q;i++){
        cin>>type[i];
        if(type[i]==1){
            cin>>X[i];
            cin>>Z[i];
            opt1[R[X[i]]].push_back(i);
        }else{
            cin>>X[i]>>Y[i]>>Z[i];
            lca[i]=LCA(X[i],Y[i]);
            opt2[X[i]].push_back(i);
            opt2[Y[i]].push_back(i);
        }
    }
    rt=++tot;
    solve1(1);
    solve2();
    for(int i=1;i<=q;i++) cout<<answer[i]<<'\n';
    return 0;
}
```

---

## 作者：1saunoya (赞：1)

[$myblog$](https://www.cnblogs.com/Isaunoya/p/11771880.html)

[Problem](https://www.luogu.org/problem/P4592)

- 1 $x,y$：查询节点$x$的子树中与$y$异或结果的最大值
- 2 $x,y,z$：查询路径$x$到$y$上点与$z$异或结果最大值

看到区间异或的最大值 不难想到 `可持久化trie`

用树剖把这些剖成链 每次就是链的查询。。这样就可以了。

```cpp

#include<bits/stdc++.h>
using namespace std ;
int n , q ;
const int N = 1e5 + 10 ;
struct node { int v , nxt ; } e[N << 1] ;
int val[N] ;
int head[N] , cnt = 0 ;
inline void add(int u , int v) { e[++ cnt] = { v , head[u] } ; head[u] = cnt ; }
int size[N] , son[N] , fa[N] , d[N] ;
inline void dfs1(int u) { size[u] = 1 ;
  for(int i = head[u] ; i ; i = e[i].nxt) {
    int v = e[i].v;
    if(v == fa[u]) continue ;
    fa[v] = u ; d[v] = d[u] + 1 ;
    dfs1(v) ;
    size[u] += size[v] ;
    if(size[v] > size[son[u]]) son[u] = v ;
  }
}
int top[N] , id[N] , idx = 0 , a[N] ;
inline void dfs2(int u , int t) {
  top[u] = t ; id[u] = ++ idx ; a[idx] = val[u] ;
  if(! son[u]) return ; dfs2(son[u] , t) ;
  for(int i = head[u] ; i ; i = e[i].nxt) {
    int v = e[i].v ;
    if(v == fa[u]) continue ;
    if(v == son[u]) continue ;
    dfs2(v , v) ;
  }
}
int tot = 0 ;
int t[N] ; int ch[N << 5][2] ;
int sz[N << 5] ;
inline void upd(int x , int p , int q) {
	ch[p][0] = ch[q][0] ; ch[p][1] = ch[q][1] ; sz[p] = sz[q] + 1 ;
	for(register int i = 29 ; ~ i ; i --) {
		int c = (x >> i) & 1 ;
		ch[p][c] = ++ tot ;
		p = ch[p][c] ;
		q = ch[q][c] ;
		ch[p][0] = ch[q][0] ;
		ch[p][1] = ch[q][1] ;
		sz[p] = sz[q] + 1 ;
	}
}
inline int query(int x , int p , int q) {
  int res = 0 ;
	for(register int i = 29 ; ~ i ; i --) {
		int c = (x >> i) & 1 ;
		if(sz[ch[q][c ^ 1]] - sz[ch[p][c ^ 1]]) res |= 1 << i , p = ch[p][c ^ 1] , q = ch[q][c ^ 1] ;
		else p = ch[p][c] , q = ch[q][c] ;
	} return res ;
}
inline int query_range(int x , int y , int val) {
  int fx = top[x] , fy = top[y] ; int res = 0 ;
  while(fx ^ fy) {
    if(d[fx] < d[fy]) swap(x , y) , swap(fx , fy) ;
    res = max(res , query(val , t[id[fx] - 1] , t[id[x]])) ;
    x = fa[fx] , fx = top[x] ;
  }
  if(d[x] > d[y]) swap(x , y) ;
  res = max(res , query(val , t[id[x] - 1] , t[id[y]])) ;
  return res ;
}
signed main() {
  ios :: sync_with_stdio(false) ;
  cin.tie(nullptr) ;
  cout.tie(nullptr) ;
  cin >> n >> q ;
  for(register int i = 1 ; i <= n ; i ++) cin >> val[i] ;
  for(register int i = 1 ; i <= n - 1 ; i ++) {
    int u , v ; cin >> u >> v ;
    add(u , v) ; add(v , u) ;
  } dfs1(1) ; dfs2(1 , 1) ;
  for(register int i = 1 ; i <= n ; i ++) t[i] = ++ tot , upd(a[i] , t[i] , t[i - 1]) ;
  for(register int i = 1 ; i <= q ; i ++) {
    int opt ; cin >> opt ;
    if(opt == 1) {
      int x , y ;
      cin >> x >> y ;
      cout << query(y , t[id[x] - 1] , t[id[x] + size[x] - 1]) << '\n' ;
    }
    else {
      int x , y , z ;
      cin >> x >> y >> z ;
      cout << query_range(x , y , z) << '\n' ;
    }
  }
  return 0 ;
}
```

---

## 作者：dsidsi (赞：1)

# Description

现在有一颗以 $1$ 为根节点的由 $n$ 个节点组成的树，树上每个节点上都有一个权值 $v_i$。现在有$Q$次操作，操作如下：

 - 1 $x$ $y$ ：查询节点 $x$ 的子树中与 $y$ 异或结果的最大值。
 - 2 $x$ $y$ $z$ ：查询路径 $x$ 到 $y$ 上点与 $z$ 异或结果最大值。
 
# Solution

考虑可持久和Trie。

首先对于每个节点到根的路径建立可持久化Trie。

对于一条路径，把它拆分成$x$到根加上$y$到跟减去$lca$到根再减去$lca$的父亲到根的路径。然后就可以回答类型$2$的询问。

然后对于$dfs$序建立可持久化Trie。

对于一个子树，把它拆成$low_x$减去$dfn_x-1$即可。

```cpp
// luogu-judger-enable-o2
#include <bits/stdc++.h>
using namespace std;

const int maxn = 100005;

int n, Q;
int op[maxn], x[maxn], y[maxn], z[maxn], ans[maxn], v[maxn];
int dep[maxn], Siz[maxn], son[maxn], dfn[maxn], low[maxn], ord[maxn], Time, fa[maxn], top[maxn];
int root[maxn], ch[maxn * 35][2], siz[maxn * 35];

inline int gi()
{
    char c = getchar();
    while (c < '0' || c > '9') c = getchar();
    int sum = 0;
    while ('0' <= c && c <= '9') sum = sum * 10 + c - 48, c = getchar();
    return sum;
}

struct edge
{
    int to, next;
} e[maxn * 2];
int h[maxn], tot;

inline void add(int u, int v)
{
    e[++tot] = (edge) {v, h[u]}; h[u] = tot;
    e[++tot] = (edge) {u, h[v]}; h[v] = tot;
}

void insert(int &s, int k, int v)
{
    ++tot;
    ch[tot][0] = ch[s][0]; ch[tot][1] = ch[s][1]; siz[tot] = siz[s] + 1;
    s = tot;
    if (k == -1) return ;
    if ((v >> k) & 1) insert(ch[s][1], k - 1, v);
    else insert(ch[s][0], k - 1, v);
}

int query(int s1, int s2, int s3, int s4, int v)
{
    int t, ans = 0;
    for (int i = 29; i >= 0; --i) {
        t = (v >> i) & 1;
        if (siz[ch[s1][t ^ 1]] + siz[ch[s2][t ^ 1]] - siz[ch[s3][t ^ 1]] - siz[ch[s4][t ^ 1]]) {
            s1 = ch[s1][t ^ 1];
            s2 = ch[s2][t ^ 1];
            s3 = ch[s3][t ^ 1];
            s4 = ch[s4][t ^ 1];
            ans ^= 1 << i;
        } else {
            s1 = ch[s1][t];
            s2 = ch[s2][t];
            s3 = ch[s3][t];
            s4 = ch[s4][t];
        }
    }
    return ans;
}

void dfs1(int u, int fa)
{
    root[u] = root[fa]; Siz[u] = 1;
    insert(root[u], 29, v[u]);
    ord[dfn[u] = ++Time] = u; dep[u] = dep[fa] + 1;
    for (int i = h[u], v; v = e[i].to, i; i = e[i].next)
        if (v != fa) {
            dfs1(v, u);
            Siz[u] += Siz[v];
            if (Siz[v] >= Siz[son[u]]) son[u] = v;
        }
    low[u] = Time;
}

void dfs2(int u)
{
    if (son[u]) fa[son[u]] = u, top[son[u]] = top[u], dfs2(son[u]);
    for (int i = h[u], v; v = e[i].to, i; i = e[i].next)
        if (v != fa[u] && v != son[u]) top[v] = v, fa[v] = u, dfs2(v);
}

int lca(int u, int v)
{
    while (top[u] != top[v]) {
        if (dep[top[u]] > dep[top[v]]) u = fa[top[u]];
        else v = fa[top[v]];
    }
    return dep[u] < dep[v] ? u : v;
}

int main()
{
    n = gi(); Q = gi();
    for (int i = 1; i <= n; ++i) v[i] = gi();
    for (int i = 1; i < n; ++i) add(gi(), gi());

    for (int i = 1; i <= Q; ++i) {
        op[i] = gi(); x[i] = gi(), y[i] = gi();
        if (op[i] == 2) z[i] = gi();
    }
    
    tot = 0;
    dfs1(1, 0);
    top[1] = 1; dfs2(1);

    for (int i = 1; i <= Q; ++i)
        if (op[i] == 2) ans[i] = query(root[x[i]], root[y[i]], root[lca(x[i], y[i])], root[fa[lca(x[i], y[i])]], z[i]);

    tot = 0;
    for (int i = 1; i <= n; ++i)
        root[i] = root[i - 1], insert(root[i], 29, v[ord[i]]);

    for (int i = 1; i <= Q; ++i)
        if (op[i] == 1) ans[i] = query(root[low[x[i]]], root[0], root[0], root[dfn[x[i]] - 1], y[i]);

    for (int i = 1; i <= Q; ++i) printf("%d\n", ans[i]);
    
    return 0;
}
```

---


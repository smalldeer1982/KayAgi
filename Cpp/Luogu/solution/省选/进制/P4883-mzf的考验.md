# mzf的考验

## 题目背景

$mzf$立志要成为一个豪杰，当然，他也是一个$OIer$。
他希望自己除了会$OI$之外还会各种东西，比如心理学、吉他、把妹等等。
为了让自己有更大的魅力，他不驼背，不熬夜，整天锻炼，双目炯炯有神，是我们机房最不像$OIer$的人。
然而，在与我们格格不入若干天并且将《易经》研究透彻之后，承受不住我们对他另类的言论，他爆发了。
机房在那一刹那仿佛天塌地陷，世界末日。

## 题目描述

八卦有乾、坤、震、巽、坎、离、艮、兑；
两两组合，一上一下，形成了六十四卦，每卦六爻，一共三百八十四爻。
爻分阴阳，阳爻性属阳刚，阴爻性属阴柔。天下之大，无奇不有。千奇百怪，皆出此处。
$mzf$研究透彻了易经之后，画出了$n$个奇怪的图案。他说那是他改进出来的更强大的卜卦体系。
每一个图案有二十行，每一行要么是阴爻$(0)$，要么是阳爻$(1)$，作为一个$OIer$，我们可以将卦象看成一个个二进制串；
他将$n$个图案画在了符纸上，然后进行$m$次操作：

操作1：翻转区间$[l,r]$的图案，比如$(3,1,2,5)$变成$(5,2,1,3)$；

操作2：$mzf$画地为卦，将$[l,r]$之间的卦象都异或上新画的那个卦象；

操作3：$mzf$会询问机房里的其他人$[l,r]$之间卦象代表的二进制数权值和。

如果不能正确回答每个操作$3$，那么机房风水格局将会改变，我们都将...！

由于$mzf$疯狂之下将我们都捆♂绑♂了起来，所以只能求求你来帮我们解决这个问题。

## 说明/提示

对于 $20\%$ 的数据，$n\le1000$，$m\le 1000$。

对于另外 $20\%$ 的数据，不存在操作 $1$。

对于另外 $20\%$ 的数据，保证 $n$ 为 $2$ 的次幂，且在操作 $1$ 中，保证 $l=i\times(2^j)+1$，$r=(i+1)\times(2^j)$，其中 $i,j$ 为任意值。

对于 $100\%$ 的数据，$n\le 10^5$，$m\le 5\times 10^4$，$1\le l\le r\le n$，$0\le d<2^{20}$。

## 样例 #1

### 输入

```
8 9
4 6 2 1 7 9 10 2
1 1 4
3 1 6
2 4 5 2
3 1 6
2 1 5 8
3 1 6
2 5 7 10
3 4 7
3 1 8
```

### 输出

```
29
29
69
24
59```

# 题解

## 作者：VenusM1nT (赞：5)

平衡树。

非常裸的平衡树，带翻转似乎只有平衡树能做了吧（

反正 $\texttt{fhq}$ 天下第一就是了【暴论】

依然是区间翻转打标记，区间查询就维护一个 $\texttt{sum}$ 数组，比较难搞的是这个区间异或，注意到题目中有写：$\texttt{d}\in[0,2^{20})$，考虑使用常用的套路，即将它拆成一位一位的分别维护，由于只有 $20$ 位，所以可以很轻松地存下来。

（尝试了一下新的毒瘤码风，各位感性理解一下吧qaq）

![](http://wx3.sinaimg.cn/large/0060lm7Tly1g39abmz8sxj30ap05at8w.jpg)

```cpp
#pragma GCC optimize(2)
#include<bits/stdc++.h>
#define MAXN 100005
#define K 20
#define reg register
#define inl inline
#define int long long
using namespace std;
int n,m,a[MAXN];
struct FHQTreap
{
	int ch[MAXN][2],siz[MAXN],val[MAXN],key[MAXN],tag[MAXN],root,sze,num[MAXN][K+5],fg[MAXN],stk[MAXN],top;
	int sum[MAXN];
	bool rev[MAXN];
	inl void Mxr(reg int rt,reg int v)
	{
		tag[rt]^=v;
		val[rt]^=v;
		sum[rt]=0;
		for(reg int i=0;i<=K;i++) fg[i]=(v>>i)&1;
		for(reg int i=0;i<=K;i++)
		{
			if(fg[i]) num[rt][i]=siz[rt]-num[rt][i];
			sum[rt]+=(1<<i)*num[rt][i];
		}
	}
	inl void Psu(reg int rt)
	{
		siz[rt]=siz[ch[rt][0]]+siz[ch[rt][1]]+1;
		sum[rt]=sum[ch[rt][0]]+sum[ch[rt][1]]+val[rt];
		for(reg int i=0;i<=K;i++) num[rt][i]=num[ch[rt][0]][i]+num[ch[rt][1]][i]+((val[rt]>>i)&1);
	}
	inl void Psd(reg int rt)
	{
		if(rev[rt])
		{
			swap(ch[rt][0],ch[rt][1]);
			if(ch[rt][0]) rev[ch[rt][0]]^=1;
			if(ch[rt][1]) rev[ch[rt][1]]^=1;
			rev[rt]=0;
		}
		if(tag[rt])
		{
			reg int v=tag[rt];
			tag[rt]=0;
			if(ch[rt][0]) Mxr(ch[rt][0],v);
			if(ch[rt][1]) Mxr(ch[rt][1],v);
		}
	}
	int Mrg(reg int x,reg int y)
	{
		if(!x || !y) return x+y;
		if(key[x]<key[y])
		{
			Psd(x);
			ch[x][1]=Mrg(ch[x][1],y);
			Psu(x);
			return x;
		}
		else
		{
			Psd(y);
			ch[y][0]=Mrg(x,ch[y][0]);
			Psu(y);
			return y;
		}
	}
	void Spt(reg int rt,reg int pos,reg int &x,reg int &y)
	{
		if(!rt) x=y=0;
		else
		{
			Psd(rt);
			if(pos<=siz[ch[rt][0]])
			{
				y=rt;
				Spt(ch[rt][0],pos,x,ch[rt][0]);
			}
			else
			{
				x=rt;
				Spt(ch[rt][1],pos-siz[ch[rt][0]]-1,ch[rt][1],y);
			}
			Psu(rt);
		}
	}
	inl int Nwd(reg int v)
	{
		reg int rt=++sze;
		siz[rt]=1;
		val[rt]=v;
		key[rt]=rand();
		tag[rt]=rev[rt]=0;
		ch[rt][0]=ch[rt][1]=0;
		return rt;
	}
	inl int Bld()
	{
		memset(stk,0,sizeof(stk));
		top=0;
		reg int x,pre;
		for(reg int i=1;i<=n;i++)
		{
			x=Nwd(a[i]);
			pre=0;
			while(top && key[stk[top]]>key[x])
			{
				Psu(stk[top]);
				pre=stk[top];
				stk[top--]=0;
			}
			if(top) ch[stk[top]][1]=x;
			ch[x][0]=pre;
			stk[++top]=x;
		}
		while(top) Psu(stk[top--]);
		return stk[1];
	}
	inl void Mdy(reg int l,reg int r,reg int v)
	{
		reg int x,y,z;
		Spt(root,r,x,z);
		Spt(x,l-1,x,y);
		Mxr(y,v);
		root=Mrg(Mrg(x,y),z);
	}
	inl void Rev(reg int l,reg int r)
	{
		reg int x,y,z;
		Spt(root,r,x,z);
		Spt(x,l-1,x,y);
		rev[y]^=1;
		root=Mrg(Mrg(x,y),z);
	}
	inl int Qry(reg int l,reg int r)
	{
		reg int x,y,z;
		Spt(root,r,x,z);
		Spt(x,l-1,x,y);
		reg int res=sum[y];
		root=Mrg(Mrg(x,y),z);
		return res;
	}
}T;
signed main()
{
	scanf("%lld %lld",&n,&m);
	for(reg int i=1;i<=n;i++) scanf("%lld",&a[i]);
	T.root=T.Bld();
	while(m--)
	{
		reg int opt,x,y,z;
		scanf("%lld %lld %lld",&opt,&x,&y);
		if(opt==1) T.Rev(x,y);
		else if(opt==2)
		{
			scanf("%lld",&z);
			T.Mdy(x,y,z);
		}
		else if(opt==3) printf("%lld\n",T.Qry(x,y));
	}
	return 0;
}
```

---

## 作者：Wolfycz (赞：4)

这个题实际上是我出的。。。结果随机数据可以被吸了氧的$O(n^2)$跑过去~~（还不是数据水了）~~。。。然后重新构造了几组数据，结果私人题库卡掉$O(n^2)$了，洛谷题库没卡掉，说明洛谷评测姬是真的快，比其他oj快得多啊~~（拍马屁，逃）~~。最后题目改成1s了，然后写平衡树的记得要吸氧，不吸氧应该是跑不过的（不排除大佬有常数极小的平衡树写法）

然后讲讲这题，区间翻转，肯定要用平衡树，然后由于要异或，异或和区间和没有直接联系，因此平衡树上每个节点要记录20位的信息，就是把这个子树内所有的点的权值转成二进制后，记录每一位1的个数，这样就可以在异或之后统计子树权值和。

然后就是一些splay基本操作什么的了
``` cpp
/*program from Wolfycz*/
#include<cmath>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#define inf 0x7f7f7f7f
using namespace std;
typedef long long ll;
typedef unsigned int ui;
typedef unsigned long long ull;
inline int read(){
	int x=0,f=1;char ch=getchar();
	for (;ch<'0'||ch>'9';ch=getchar())	if (ch=='-')    f=-1;
	for (;ch>='0'&&ch<='9';ch=getchar())	x=(x<<1)+(x<<3)+ch-'0';
	return x*f;
}
inline void print(int x){
	if (x>=10)	print(x/10);
	putchar(x%10+'0');
}
const int N=5e5;
int v[N+10],g[20]; 
void Extract(int x,int *cnt){for (int i=0;i<20;i++)	cnt[i]=x&1,x>>=1;}
struct Splay{
	#define ls(x) tree[x][0]
	#define rs(x) tree[x][1]
	#define T(x) (rs(f[x])==x)
	ll sum[N+10];
	int tree[N+10][2],f[N+10],size[N+10],cnt[N+10][20],Xor[N+10],val[N+10],A[20];
	bool rev[N+10];
	int root,len;
	void updata(int x){
		size[x]=size[ls(x)]+size[rs(x)]+1;
		sum[x]=sum[ls(x)]+sum[rs(x)]+val[x];
		for (int i=0;i<20;i++)	cnt[x][i]=cnt[ls(x)][i]+cnt[rs(x)][i]+((val[x]>>i)&1);
	}
	void move(int x){
		int fa=f[x],son=tree[x][T(x)^1];
		tree[x][T(x)^1]=fa;
		tree[fa][T(x)]=son;
		if (son)	f[son]=fa;
		f[x]=f[fa];
		if (f[x])	tree[f[x]][T(fa)]=x;
		f[fa]=x;
		updata(fa),updata(x);
	}
	void splay(int x){
		while (f[x]){
			if (f[f[x]])	T(f[x])==T(x)?move(f[x]):move(x);
			move(x);
		}
		root=x;
	}
	void Add_rev(int x){
		if (!x)	return;
		swap(ls(x),rs(x));
		rev[x]^=1;
	}
	void Add_xor(int x,int v){
		if (!x)	return;
		Extract(v,A);
		ll res=0;
		for (int i=0;i<20;i++){
			if (A[i])	cnt[x][i]=size[x]-cnt[x][i];
			res+=1ll*cnt[x][i]*g[i];
		}
		sum[x]=res;
		val[x]^=v,Xor[x]^=v;
	}
	void pushdown(int x){
		if (rev[x]){
			Add_rev(ls(x));
			Add_rev(rs(x));
			rev[x]=0;
		}
		if (Xor[x]){
			Add_xor(ls(x),Xor[x]);
			Add_xor(rs(x),Xor[x]);
			Xor[x]=0;
		}
	}
	int find(int x,int i){
		pushdown(i);
		if (size[ls(i)]+1==x)	return i;
		if (x<=size[ls(i)])	return find(x,ls(i));
		return find(x-size[ls(i)]-1,rs(i));
	}
	void reverse(int l,int r){
		int x=find(l,root),y=find(r+2,root);
		splay(x),splay(y);
		if (f[x]!=root)	move(x);
		Add_rev(rs(x));
//		updata(x),updata(y);
	}
	void _xor(int l,int r,int v){
		int x=find(l,root),y=find(r+2,root);
		splay(x),splay(y);
		if (f[x]!=root)	move(x);
		Add_xor(rs(x),v);
		updata(x),updata(y);
	}
	ll Query(int l,int r){
		int x=find(l,root),y=find(r+2,root);
		splay(x),splay(y);
		if (f[x]!=root)	move(x);
		return sum[rs(x)];
	}
	void build(int fa,int l,int r,int &x){
		if (l>r)	return;
		int mid=(l+r)>>1;
		x=++len,f[x]=fa,val[x]=v[mid];
		if (l==r){
			size[x]=1,sum[x]=val[x];
			Extract(val[x],cnt[x]);
			return;
		}
		build(x,l,mid-1,ls(x));
		build(x,mid+1,r,rs(x));
		updata(x);
	}
	void init(int n){
		len=2,root=1;
		rs(1)=size[1]=2,f[2]=size[2]=1;
		build(2,1,n,ls(2));
		updata(2),updata(1);
	}
}Tree;
int main(){
	g[0]=1;
	for (int i=1;i<20;i++)	g[i]=g[i-1]<<1;
	int n=read(),m=read();
	for (int i=1;i<=n;i++)	v[i]=read();
	Tree.init(n);
	for (int i=1;i<=m;i++){
		int type=read(),l=read(),r=read();
		if (type==1)	Tree.reverse(l,r);
		if (type==2)	Tree._xor(l,r,read());
		if (type==3)	printf("%lld\n",Tree.Query(l,r));
	}
	return 0;
}
```

---

## 作者：Arghariza (赞：2)

### 题意：

给定长度为 $n$ 的序列 $a_i$，$m$ 次操作，操作分为 $3$ 种：

1. 给定两个整数 $l,r$，翻转区间 $[l,r]$。即 $a_l,a_{l+1},...,a_r\to a_r,a_{r-1},...,a_l$。
2. 给定三个整数 $l,r,d$，对于 $i\in [l,r]$，$a_i\gets a_i\oplus d$。$\oplus$ 表示异或运算。
3. 给定两个整数 $l,r$，查询 $\sum\limits_{i\in [l,r]}a_i$ 的值。

---

平衡树卡常题。

每一二进制位互相独立，所以可以建 $20$ 棵平衡树，每棵维护一个二进制位。操作变成 $01$ 序列支持区间翻转，区间取反以及查询区间 $1$ 的个数。

平衡树维护翻转 $\text{rev}$ 标记、反转 $\text{tag}$ 标记和区间 $1$ 的个数 $\text{cnt}$ 即可。答案就是 $\sum\limits_{i=0}^{19}2^i\times\text{cnt}$。

然后你直接这么写发现你常数炸飞了，随手造一组数据跑了 16s。因为有很多信息比如 $\text{siz,rd}$ 甚至左儿子右儿子对于每棵平衡树都是相同的，然而你求了 $20$ 遍。

发现可以直接开一棵平衡树，$\text{tag}$ 直接维护这个子树应该异或的值 $d$，而不再是 $d$ 的某一位。$\text{cnt}$ 还是要维护每一位，多记录一个 $\text{sum}$ 表示子树和，每次 pushup 和 pushdown 的时候根据每一位的 $\text{cnt}$ 可以推出来。

做完了，$O(n\log n\log w)$。

```cpp
mt19937 rnd(time(0));
const int maxn = 1e5 + 100;
int n, m, a[maxn];
int rt, tot, x, y, z;
ll sum[maxn];
int rd[maxn], sz[maxn], cnt[maxn][25], rev[maxn], tag[maxn], val[maxn], ch[maxn][2];

void pushup(int x) { 
	sz[x] = sz[ch[x][0]] + sz[ch[x][1]] + 1, sum[x] = sum[ch[x][0]] + sum[ch[x][1]] + val[x]; 
	for (int i = 19; ~i; i--) cnt[x][i] = cnt[ch[x][0]][i] + cnt[ch[x][1]][i] + ((val[x] >> i) & 1); 
}

void pushrev(int x) {
	if (!rev[x]) return;
	swap(ch[x][0], ch[x][1]);
	if (ch[x][0]) rev[ch[x][0]] ^= 1;
	if (ch[x][1]) rev[ch[x][1]] ^= 1; 
	rev[x] = 0;
}

void pushxor(int x) {
	if (!tag[x]) return;
	if (ch[x][0]) {
		val[ch[x][0]] ^= tag[x], tag[ch[x][0]] ^= tag[x], sum[ch[x][0]] = 0;
		for (int i = 19; ~i; i--) {
			if ((tag[x] >> i) & 1) cnt[ch[x][0]][i] = sz[ch[x][0]] - cnt[ch[x][0]][i];
			sum[ch[x][0]] += (1ll << i) * cnt[ch[x][0]][i];
		}
	}
	if (ch[x][1]) {
		val[ch[x][1]] ^= tag[x], tag[ch[x][1]] ^= tag[x], sum[ch[x][1]] = 0;
		for (int i = 19; ~i; i--) {
			if ((tag[x] >> i) & 1) cnt[ch[x][1]][i] = sz[ch[x][1]] - cnt[ch[x][1]][i];
			sum[ch[x][1]] += (1ll << i) * cnt[ch[x][1]][i];
		}
	}
	tag[x] = 0;
}

void pushdown(int x) { pushrev(x), pushxor(x); }
void split(int p, int k, int &x, int &y) {
	if (!p) return x = y = 0, void();
	pushdown(p);
	if (sz[ch[p][0]] < k) x = p, split(ch[x][1], k - sz[ch[x][0]] - 1, ch[x][1], y);
	else y = p, split(ch[y][0], k, x, ch[y][0]);
	pushup(p);
}

int merge(int x, int y) {
	if (!x || !y) return x | y;
	pushdown(x), pushdown(y);
	if (rd[x] < rd[y]) return ch[x][1] = merge(ch[x][1], y), pushup(x), x;
	else return ch[y][0] = merge(x, ch[y][0]), pushup(y), y;
}

void reverse(int l, int r) {
	split(rt, l - 1, x, y), split(y, r - l + 1, y, z);
	rev[y] ^= 1, rt = merge(x, merge(y, z));
}

void update(int l, int r, int d) {
	split(rt, l - 1, x, y), split(y, r - l + 1, y, z);
	val[y] ^= d, tag[y] ^= d, sum[y] = 0;
	for (int i = 19; ~i; i--) {
		if ((d >> i) & 1) cnt[y][i] = sz[y] - cnt[y][i];
		sum[y] += (1ll << i) * cnt[y][i];
	}
	rt = merge(x, merge(y, z));
}

ll query(int l, int r) {
	split(rt, l - 1, x, y), split(y, r - l + 1, y, z);
	ll res = sum[y]; rt = merge(x, merge(y, z));
	return res;
} 

int main() { 
	n = read(), m = read();
	for (int i = 1; i <= n; i++) {
		a[i] = read();
		sum[i] = val[i] = a[i], rd[i] = rnd(), sz[i] = 1;
		for (int j = 19; ~j; j--) 
			if ((a[i] >> j) & 1) cnt[i][j] = 1;
		rt = merge(rt, i);
	}
	while (m--) {
		int op = read(), l = read(), r = read();
		if (op == 1) reverse(l, r);
		else if (op == 2) update(l, r, read()); 
		else write(query(l, r)), puts("");
	}
	return 0;
}
```

---

## 作者：5k_sync_closer (赞：2)

本题为带翻转 [CF242E](https://www.luogu.com.cn/problem/CF242E)。
# 思路
用平衡树维护之，考虑经典平衡树五问：
### 节点信息
因为我们写的是 FHQ，所以要记录左右孩子、两个权值、子树大小。

注意到有区间异或操作，考虑拆位。记录数组 $\{q_w\}$，$q_i$ 表示子树内二进制第 $i$ 位为 $1$ 的数的个数。

注意到有区间求和操作，容易发现子树和为 $\sum\limits_{i=0}^w 2^iq_i$。
### 节点标记
根据题意，记录区间翻转、区间异或标记。
### 下传标记
发现两个标记没有优先级之分，可以单独考虑。

区间翻转标记和[文艺平衡树](https://www.luogu.com.cn/problem/P3391)一样，交换左右子树即可，不解释。

设区间异或标记为 $x$，令左右子树分别执行

$$
q_i\gets\begin{cases}\text{size}-q_i&x\text{ 二进制第 }i \text{ 位为 }1\\q_i&x\text{ 二进制第 }i \text{ 位为 }0\end{cases}
$$

即可。记得修改节点本身的权值。
### 区间修改
区间翻转和[文艺平衡树](https://www.luogu.com.cn/problem/P3391)一样，标记取反即可，不解释。

设区间异或的值为 $x$，执行

$$
q_i\gets\begin{cases}\text{size}-q_i&x\text{ 二进制第 }i \text{ 位为 }1\\q_i&x\text{ 二进制第 }i \text{ 位为 }0\end{cases}
$$

即可。记得修改节点本身的权值。（与下传标记完全一致）
### 上传信息
正常更新子树大小。执行 $q_i\gets l.q_i+r.q_i+[\text{节点本身权值二进制第 }i\text{ 位为 }1]$ 即可。

于是我们可以写出：
```cpp
#define G(x) if(x & (1 << i))
#define F for(int i = 0;i < 20;++i)
inline int R()
{
    int r = 0;char c = getchar();while(!isdigit(c)) c = getchar();
    while(isdigit(c)) r = r * 10 + c - '0', c = getchar();return r;
}
struct T
{
    T *l, *r;int v, k, s, x, q[20];bool f;T(int _) : l(0), r(0), v(_),
    k(rand()), s(1), x(0), f(0) {memset(q, 0, sizeof q);F G(_) q[i] = 1;}
    void u()
    {
        s = 1;memset(q, 0, sizeof q);F G(v) q[i] = 1;
        if(l) {s += l->s;F q[i] += l->q[i];}
        if(r) {s += r->s;F q[i] += r->q[i];}
    }
    void d()
    {
        if(f) {T *t = l;l = r;r = t;if(l) l->f ^= 1;if(r) r->f ^= 1;f = 0;}if(x)
        {
            if(l) {F G(x) l->q[i] = l->s - l->q[i];l->v ^= x;l->x ^= x;}
            if(r) {F G(x) r->q[i] = r->s - r->q[i];r->v ^= x;r->x ^= x;}x = 0;
        }
    }
}*r, *a, *b, *c, *s[30];
void S(T *x, int k, T *&a, T *&b)
{
    if(!x) {a = b = 0;return;}if(!k) {a = 0;b = x;return;}
    if(k >= x->s) {a = x;b = 0;return;}x->d();int z = x->l ?
    x->l->s : 0;if(z >= k) b = x, S(x->l, k, a, b->l), b->u();
    else a = x, S(x->r, k - z - 1, a->r, b), a->u();
}
T *M(T *a, T *b)
{
    if(!a) return b;if(!b) return a;if(a->k < b->k)
    {a->d();a->r = M(a->r, b);a->u();return a;}else
    {b->d();b->l = M(a, b->l);b->u();return b;}
}
```
（可以选择）用笛卡尔树优化建树过程。
```cpp
for(int i = 1;i <= n;++i)
{
    a = new T(R());k = a->k;p = l;while(l && k < s[l - 1]->k)
    s[--l]->u();if(l < p) a->l = s[l];if(l) s[l - 1]->r = a;s[l++] = a;
}
while(l) s[--l]->u();r = s[0];
```
分别处理每种操作。
```cpp
while(m--)
{
    o = R();x = R();y = R();S(r, y, a, c);S(a, x - 1, a, b);switch(o)
    {
        case 1: b->f ^= 1;break;
        case 2: d = R();F G(d) b->q[i] = b->s - b->q[i];b->v ^= d;b->x ^= d;break;
        case 3: q = 0;F q += b->q[i] * (1ll << i);printf("%lld\n", q);break;
    }
    r = M(a, M(b, c));
}
```
这题做完了。
# Code
```cpp
#include <cstdio>
#include <cctype>
#include <cstdlib>
#include <cstring>
#define G(x) if(x & (1 << i))
#define F for(int i = 0;i < 20;++i)
inline int R()
{
    int r = 0;char c = getchar();while(!isdigit(c)) c = getchar();
    while(isdigit(c)) r = r * 10 + c - '0', c = getchar();return r;
}
int n, m, l, k, p, o, x, y, d;long long q;struct T
{
    T *l, *r;int v, k, s, x, q[20];bool f;T(int _) : l(0), r(0), v(_),
    k(rand()), s(1), x(0), f(0) {memset(q, 0, sizeof q);F G(_) q[i] = 1;}
    void u()
    {
        s = 1;memset(q, 0, sizeof q);F G(v) q[i] = 1;
        if(l) {s += l->s;F q[i] += l->q[i];}
        if(r) {s += r->s;F q[i] += r->q[i];}
    }
    void d()
    {
        if(f) {T *t = l;l = r;r = t;if(l) l->f ^= 1;if(r) r->f ^= 1;f = 0;}if(x)
        {
            if(l) {F G(x) l->q[i] = l->s - l->q[i];l->v ^= x;l->x ^= x;}
            if(r) {F G(x) r->q[i] = r->s - r->q[i];r->v ^= x;r->x ^= x;}x = 0;
        }
    }
}*r, *a, *b, *c, *s[30];
void S(T *x, int k, T *&a, T *&b)
{
    if(!x) {a = b = 0;return;}if(!k) {a = 0;b = x;return;}
    if(k >= x->s) {a = x;b = 0;return;}x->d();int z = x->l ?
    x->l->s : 0;if(z >= k) b = x, S(x->l, k, a, b->l), b->u();
    else a = x, S(x->r, k - z - 1, a->r, b), a->u();
}
T *M(T *a, T *b)
{
    if(!a) return b;if(!b) return a;if(a->k < b->k)
    {a->d();a->r = M(a->r, b);a->u();return a;}else
    {b->d();b->l = M(a, b->l);b->u();return b;}
}
int main()
{
    srand(388651);n = R();m = R();for(int i = 1;i <= n;++i)
    {
        a = new T(R());k = a->k;p = l;while(l && k < s[l - 1]->k)
        s[--l]->u();if(l < p) a->l = s[l];if(l) s[l - 1]->r = a;s[l++] = a;
    }
    while(l) s[--l]->u();r = s[0];while(m--)
    {
        o = R();x = R();y = R();S(r, y, a, c);S(a, x - 1, a, b);switch(o)
        {
            case 1: b->f ^= 1;break;
            case 2: d = R();F G(d) b->q[i] = b->s - b->q[i];b->v ^= d;b->x ^= d;break;
            case 3: q = 0;F q += b->q[i] * (1ll << i);printf("%lld\n", q);break;
        }
        r = M(a, M(b, c));
    }
    return 0;
}
```

---

## 作者：周道_Althen (赞：1)

~~居然还没有Fhq_Treap的题解,那周道就来发一篇吧。~~

---

$\ \ \ \ \ \ \,$首先我们看他的操作：

-  $opt==1$：两个正整数：$l$，$r$。请翻转区间$[l,r]$；
-  $opt==2$：三个正整数：$l$，$r$，$d$。请将区间$[l,r]$中的所有卦象都异或卦象$d$;
-  $opt==3$：两个正整数：$l$，$r$。请查询区间$[l,r]$的卦象权值和。

$\ \ \ \ \ \ \,$显然是一个平衡树可以做的啦，我们试着选择$Fhq\_treap$ 做一下：

$\ \ \ \ \ \ \,$对于操作 $1$，$3$ 操作很简单，我们 $pushup$ 一下子树和， $pushdown$ 一下旋转标记，提出区间 $[l,r]$ 进行对应的操作就可以了。

$\ \ \ \ \ \ \,$那么对应的 $2$ 操作似乎没有那么简单操作了，我们先看看我们需要修改的 $pushdown$ 操作是什么：

1. 单点权值$(val)$：直接异或上修改的值，在$pushdown$操作的时候同理。
2. 权值懒人标记$(lazy\_w)$：直接异或上修改的值，在$pushdown$操作的时候同理。
3. 子树和$(sum)$：？

$\ \ \ \ \ \ \,$可以发现子树和的处理特别麻烦，但是对于异或问题，我们通常可以拆位解决，对于每一个节点，我们新开一个数组 $num[i]$ ，表示这个子树内的值，数位 $i$ 上面为 $1$ 的值是多少，这个很显然，我们可以通过 $pushup$ 一并传递上去。

$\ \ \ \ \ \ \,$如何处理子树和呢？因为打了标记的子树都要异或这一个值，所以我们把这个值拆了，如果这一位为 $1$ ，那么子树这一位都会 $1$变$0$，$0$变$1$，所以说有：

$$num[i]=size-num[i]$$

$\ \ \ \ \ \ \,$其中$size$为子树大小，修改了$num$数组之后，我们就可以重新计算子树和了：

$$sum=\sum_{i=0}^{limit}2^i\times num[i]$$

$\ \ \ \ \ \ \,$所以 $pushup$ 和 $pushdown$ 差不多应该是这样的：


```cpp

void Xor(int rt,int x){
	lazy_w[rt]^=x;val[rt]^=x;
    sum[rt]=0;
	for(int i=0;i<=20;++i)tmp[i]=(x>>i)&1;
  	for(int i=0;i<=20;++i){
      	if(tmp[i])num[rt][i]=size[rt]-num[rt][i];
      	sum[rt]+=(1ll<<i)*num[rt][i];
    }
}
void pushup(int rt){
	size[rt]=size[lson]+size[rson]+1;
	sum[rt]=sum[lson]+sum[rson]+1ll*val[rt];
	for(int i=0;i<=20;i++)
	num[rt][i]=num[lson][i]+num[rson][i]+((val[rt]>>i)&1);
}
void pushdown(int rt){
	if(lazy[rt]){
		swap(lson,rson);
		if(lson)lazy[lson]^=1;
		if(rson)lazy[rson]^=1;
		lazy[rt]=0;
	}
	if(lazy_w[rt]){
		int x=lazy_w[rt];lazy_w[rt]=0;
		if(lson){Xor(lson,x);}
		if(rson){Xor(rson,x);}
	}
}

```

$\ \ \ \ \ \ \,$总期望复杂度应该是$O(n\log n\ limit)$，其中$limit=\log val$

$\ \ \ \ \ \ \,$懒得卡常了，吸氧过：


```cpp
#include<algorithm>
#include<iostream>
#include<cstdlib>
#include<cstring>
#include<cctype>
#include<cstdio>
#include<vector>
#include<string>
#include<queue>
#include<stack>
#include<cmath>
#include<ctime>
#include<map>
#include<set>
using namespace std;
const int inf=0x7fffffff;
const double eps=1e-10;
const double pi=acos(-1.0);
//char buf[1<<15],*S=buf,*T=buf;
//char getch(){return S==T&&(T=(S=buf)+fread(buf,1,1<<15,stdin),S==T)?0:*S++;}
inline int read(){
	int x=0,f=1;char ch;ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-') f=0;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch&15);ch=getchar();}
	if(f)return x;else return -x;
}
const int N=1e5+10;
struct fhq_treap{
	#define lson ls[rt]
	#define rson rs[rt]
	int ls[N],rs[N];
	bool lazy[N];
	int lazy_w[N],val[N],key[N],size[N];
	long long sum[N];
	int root,cnt;
	int tmp[25],num[N][25];
	void Xor(int rt,int x){
		lazy_w[rt]^=x;val[rt]^=x;
    	sum[rt]=0;
		for(int i=0;i<=20;++i)tmp[i]=(x>>i)&1;
  		for(int i=0;i<=20;++i){
      		if(tmp[i])num[rt][i]=size[rt]-num[rt][i];
      		sum[rt]+=(1ll<<i)*num[rt][i];
    	}
	}
	void pushup(int rt){
		size[rt]=size[lson]+size[rson]+1;
		sum[rt]=sum[lson]+sum[rson]+1ll*val[rt];
		for(int i=0;i<=20;i++)
		num[rt][i]=num[lson][i]+num[rson][i]+((val[rt]>>i)&1);
	}
	void pushdown(int rt){
		if(lazy[rt]){
			swap(lson,rson);
			if(lson)lazy[lson]^=1;
			if(rson)lazy[rson]^=1;
			lazy[rt]=0;
		}
		if(lazy_w[rt]){
			int x=lazy_w[rt];lazy_w[rt]=0;
			if(lson){Xor(lson,x);}
			if(rson){Xor(rson,x);}
		}
	}
	int merge(int a,int b){
		if(!a||!b)return a|b;
		if(key[a]<key[b]){pushdown(a);rs[a]=merge(rs[a],b);pushup(a);return a;}
		else {pushdown(b);ls[b]=merge(a,ls[b]);pushup(b);return b;}
	}
	void split(int rt,int x,int &a,int &b){
		if(!rt){a=b=0;return;}
		pushdown(rt);
		if(x<=size[lson]){b=rt;split(lson,x,a,lson);}
		else {a=rt;split(rson,x-size[lson]-1,rson,b);}
		pushup(rt);
	}
	int newnode(int x){
		int rt=++cnt;
		size[rt]=1;val[rt]=x;key[rt]=rand();
		lazy[rt]=0;lazy_w[rt]=0;
		lson=rson=0;
		return rt;
	}
	int build(int a[],int len){
		stack<int> S;
		int rt,last;
	  	for(int i=1;i<=len;i++){
	    rt=newnode(a[i]);last=0;
	    while(!S.empty()&&key[S.top()]>key[rt])
			pushup(last=S.top()),S.pop();
	    	if(!S.empty())rs[S.top()]=rt;
	    	lson=last;S.push(rt);
	  	}
	  	while(!S.empty())pushup(last=S.top()),S.pop();
	  	return last; 
	}
	void Revers(int l,int r){
		int a,b,c;
		split(root,r,a,c);
		split(a,l-1,a,b);
		lazy[b]^=1;
		root=merge(merge(a,b),c);
	}
	void Update(int l,int r,int d){
		int a,b,c;
		split(root,r,a,c);
		split(a,l-1,a,b);
		Xor(b,d);
		root=merge(merge(a,b),c);
	}
	long long Query(int l,int r){
		int a,b,c;
		split(root,r,a,c);
		split(a,l-1,a,b);
		long long ret=sum[b];
		root=merge(merge(a,b),c);
		return ret;
	}
}Tree;
int n,m;
int a[N],op,l,r,d;
int main()
{
	srand(time(NULL));
	n=read();m=read();
	for(int i=1;i<=n;i++)a[i]=read();
	Tree.root=Tree.build(a,n);
	while(m--){
		op=read();l=read();r=read();
		if(op==1)Tree.Revers(l,r);
		if(op==2)d=read(),Tree.Update(l,r,d);
		if(op==3)cout<<Tree.Query(l,r)<<endl;
	}
	return 0;
}
```


---

## 作者：creation_hy (赞：0)

经典套路，翻转区间容易想到平衡树，修改看上去比较麻烦，但是容易发现异或每位是独立运算的（没有进位），所以可以维护子树内有多少个节点第 $i$ 位为 $1$，然后修改的时候对于每个 $d$ 为 $1$ 的位做翻转，即 `cnt[i]=tot_size-cnt[i]`。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 2e5 + 5;
int n, m, L[N], R[N], sz[N], pri[N], tot;
int val[N], rev[N], tag[N], cnt[N][21], rt;
mt19937 rnd(19260817);
inline int insert(int x)
{
	sz[++tot] = 1, val[tot] = x, pri[tot] = rnd();
	for (int i = 0; i <= 20; i++)
		cnt[tot][i] = x >> i & 1;
	return tot;
}
inline void push_up(int x)
{
	sz[x] = sz[L[x]] + sz[R[x]] + 1;
	for (int i = 0; i <= 20; i++)
		cnt[x][i] = cnt[L[x]][i] + cnt[R[x]][i] + (val[x] >> i & 1);
}
inline void Rev(int x) { rev[x] ^= 1, swap(L[x], R[x]); }
inline void Xor(int x, int k)
{
	tag[x] ^= k, val[x] ^= k;
	for (int i = 0; i <= 20; i++)
		if (k >> i & 1)
			cnt[x][i] = sz[x] - cnt[x][i];
}
inline void push_down(int x)
{
	if (rev[x])
		Rev(L[x]), Rev(R[x]), rev[x] = 0;
	if (tag[x])
		Xor(L[x], tag[x]), Xor(R[x], tag[x]), tag[x] = 0;
}
inline int merge(int x, int y)
{
	if (!x || !y)
		return x + y;
	if (pri[x] < pri[y])
	{
		push_down(x);
		R[x] = merge(R[x], y);
		push_up(x);
		return x;
	}
	else
	{
		push_down(y);
		L[y] = merge(x, L[y]);
		push_up(y);
		return y;
	}
}
inline void split(int p, int k, int &x, int &y)
{
	if (!p)
	{
		x = y = 0;
		return;
	}
	push_down(p);
	if (sz[L[p]] >= k)
		y = p, split(L[y], k, x, L[y]);
	else
		x = p, split(R[x], k - sz[L[p]] - 1, R[x], y);
	push_up(p);
}
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	cin >> n >> m;
	for (int i = 1, x; i <= n; i++)
		cin >> x, rt = merge(rt, insert(x));
	while (m--)
	{
		int op, l, r, k, x, y, z;
		cin >> op >> l >> r;
		split(rt, r, y, z), split(y, l - 1, x, y);
		if (op == 1)
			Rev(y);
		else if (op == 2)
			cin >> k, Xor(y, k);
		else
		{
			ll res = 0;
			for (int i = 0; i <= 20; i++)
				res += (ll)cnt[y][i] << i;
			cout << res << '\n';
		}
		rt = merge(x, merge(y, z));
	}
	return 0;
}
```

---

## 作者：Genius_Z (赞：0)

这题其实就是[这题](https://www.luogu.org/problemnew/show/CF242E)加上了个区间翻转。

所以我们考虑把线段树换成$Splay$解决。

基本上只要知道了那题的处理方法这题就很简单了，对于每个节点的值进行二进制分解，维护每一位的值，注意$Splay$不光要维护$tot$还要维护自己的值，所以要维护的东西有点多。

异或操作就当成是区间取反，还是比较好处理的，还要就是注意要开$\text{long long}$

常数极大的代码（不吸氧过不去：

```cpp
#pragma region revive
#include <set>
#include <map>
#include <cmath>
#include <queue>
#include <stack>
#include <tuple>
#include <bitset>
#include <cstdio>
#include <vector>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <unordered_map>
#define inl inline
#define re register int
#define fa(x) t[x].fa
#define ls(x) t[x].child[0]
#define rs(x) t[x].child[1]
#define ll long long
const int inf = 0x7fffffff;
#define lowbit(x) ((x) & (-x))
using namespace std;
template <class Read>
inl Read read() {
	Read x = 0;
	register bool w = 0;
	register char c = getchar();
	while (c > '9' || c < '0') {
		if (c == '-') w = 1;
		c = getchar();
	}
	while (c >= '0' && c <= '9') {
		x = (x << 3) + (x << 1) + (c ^ 48);
		c = getchar();
	}
	return w ? -x : x;
}
#pragma endregion
int root, cnt, a[100005];
struct node {
	int fa, child[2], bit[21], totbit[21], w, size, xxor;
	ll tot;
	bool filp;
}t[100005];
inl void maintain(int x) {
	t[x].w = 0;
	for (re i = 0; i <= 20; i++) {
		if (t[x].bit[i]) {
			t[x].w += (1 << i);
		}
		t[x].totbit[i] = t[ls(x)].totbit[i] + t[rs(x)].totbit[i] + t[x].bit[i];
	}
	t[x].tot = t[ls(x)].tot + t[rs(x)].tot + t[x].w;
	t[x].size = t[ls(x)].size + t[rs(x)].size + 1;
}
inl bool poi(int x) {
	return rs(fa(x)) == x;
}
inl void rotate(int x) {
	re f = fa(x), gf = fa(f), fs = poi(x), gfs = poi(f), s = t[x].child[fs ^ 1];
	if (gf)t[gf].child[gfs] = x;
	t[f].child[fs] = s, t[x].child[fs ^ 1] = f;
	if (s)fa(s) = f;
	fa(x) = gf, fa(f) = x;
	maintain(f);
}
inl void splay(int x, int to) {
	while (fa(x) != to) {
		if (fa(fa(x)) != to)poi(x) == poi(fa(x)) ? rotate(fa(x)) : rotate(x);
		rotate(x);
	}
	maintain(x);
	if (!to)root = x;
}
inl void xxor(int x, int w) {
	for (re i = 0; i <= 20; i++) {
		if ((w >> i) & 1) {
			t[x].tot -= 1ll * t[x].totbit[i] * (1 << i);
			t[x].w -= t[x].bit[i] * (1 << i);
			t[x].totbit[i] = t[x].size - t[x].totbit[i];
			t[x].bit[i] ^= 1;
			t[x].tot += 1ll * t[x].totbit[i] * (1 << i);
			t[x].w += t[x].bit[i] * (1 << i);
		}
	}
	t[x].xxor ^= w;
}
inl void reverse(int x) { swap(ls(x), rs(x)), t[x].filp ^= 1; }
inl void pushdown(int x) {
	if (t[x].xxor) {
		if (ls(x))xxor(ls(x), t[x].xxor);
		if (rs(x))xxor(rs(x), t[x].xxor);
		t[x].xxor = 0;
	}
	if (t[x].filp) {
		if (ls(x))reverse(ls(x));
		if (rs(x))reverse(rs(x));
		t[x].filp = 0;
	}
}
inl int find(int k) {
	re x = root;
	while (x) {
		pushdown(x);
		if (t[ls(x)].size >= k)x = ls(x);
		else if (t[ls(x)].size + 1 >= k) return x;
		else k -= t[ls(x)].size + 1, x = rs(x);
	}
	return x;
}
inl void build(int &x, int l, int r) {
	if (l > r)return;
	re mid = l + r >> 1;
	x = mid;
	t[x].w = a[mid];
	for (re i = 0; i <= 20; i++) {
		t[x].bit[i] = (a[mid] >> i) & 1;
	}
	build(ls(x), l, mid - 1), build(rs(x), mid + 1, r);
	if (ls(x))fa(ls(x)) = x; if (rs(x))fa(rs(x)) = x;
	maintain(x);
}
inl void split(int x, int y) {
	splay(find(x), 0);
	splay(find(y + 2), root);
}
inl void travel(int x) {
	if (ls(x))travel(ls(x));
	pushdown(x), printf("%d ", t[x].w);
	if (rs(x))travel(rs(x));
}
signed main() {
	re n = read<int>(), m = read<int>();
	for (re i = 1; i <= n; i++)a[i + 1] = read<int>();
	build(root, 1, n + 2);
	while (m--) {
		re op = read<int>(), l = read<int>(), r = read<int>();
		if (op == 1) {
			split(l, r);
			reverse(ls(rs(root)));
		}
		else if (op == 2) {
			re d = read<int>();
			split(l, r), xxor(ls(rs(root)), d);
		}
		else {
			split(l, r);
			printf("%lld\n", t[ls(rs(root))].tot);
		}
	}
}
```



---


# 列队

## 题目背景

本题是数据加强版，弱化版请参考$NOIP2017$   $DAY2$   $T3$

~~好了吓吓你们~~

## 题目描述

前段时间，$k$小$l$参加了$CTYZ$高一的的军训。众所周知，军训的时候需要站方阵。

$k$小$l$ 所在的队伍中有原本有蒟蒻（巨佬）$2*N$个，然而现在的只剩$k$小$l$等少数巨佬和一些蒟蒻了。

巨佬 $dwq$ ：教官我还有今年$IOI$的最后一题没调完，我先回去把题切了。

教官：行，准假，过十分钟调完了就先回去休息吧。

蒟蒻 $yz$ ：教官我今天任务计划里的红题还没做完，我要回去做。

教官：你现在回去也调不出来，乖乖站♂好，不要老是想偷懒。

$k$小$l$是一个热爱学习的男♀孩子，现在他发现，操场上只剩两列队了，原本两列的长度都为$N$，并且这两列队还残缺不全，蒟蒻在第一列，巨佬在第二列，并且如果一行中有巨佬，其气场会导致旁边不敢站蒟蒻。

#### 就算是这样，仅存巨佬们的战斗力还是比蒟蒻们的战斗力大（废话）

在$CTYZ$里面，一列队战斗力值是这样定义的

 $Fight=\sum_{i=0}^{n-1} p_{i}*2^{i}$ 

其中$i$为行标号，从$0$开始，$p_{i}=1/0$表示这一行是否有人，

现在$k$小$l$已经知道目前巨佬队伍的站队情况，现在他想问你，蒟蒻们有多少种可能的站队方式。

然而$k$小$l$觉得这样的太简单了，$k$小$l$现在有$M$个询问，每次会给你一个蒟蒻战斗力值范围$[a,b]$和一个$k$，表示他希望知道蒟蒻们的战斗力值在$[a,b]$之间，战斗力值第$k$大的蒟蒻站队方式的战斗力值，如果站队方式总数小于$k$，那么输出$POOR$ $AFO!$。







## 说明/提示

对于$50$%的数据，$N<=20,M<=50$

对于$100$%的数据，$N<=62,M<=500000$

时限很松，请放心食用。

## 样例 #1

### 输入

```
5 5
0 1 0 1 0 
0 4 5
0 3 4
0 0 1
0 1 2
4 4 1
```

### 输出

```
POOR AFO!
POOR AFO!
0
0
4
```

## 样例 #2

### 输入

```
10 5
1 1 0 1 1 0 0 1 0 0 
0 56 7
30 126 7
62 116 5
20 100 1
8 108 1
```

### 输出

```
POOR AFO!
POOR AFO!
POOR AFO!
100
100
```

## 样例 #3

### 输入

```
5 1
0 0 0 0 1
0 999 1```

### 输出

```
15```

# 题解

## 作者：__JR_飘摇__ (赞：6)

题解放这里吧！

当然也在[my blog](https://www.cnblogs.com/dwqhca/p/10185318.html)里放了一份

吐槽ing：一道有趣的二进制题.

~~注意加粗部分是限制条件~~

我们先考虑暴力分$40$分：

首先那个$Fight$值一看就知道是二进制。

对于这个暴力分，应该是一种很暴力（~~废话~~）的解法，我们直接从$b$向$a$枚举，然后判断这一个数合不合法，如果合法，就+1，直到找到第$k$大，输出答案即可。

考虑$100pts:$

这里我们就要开始讨论二进制算法了。

首先我们考虑巨佬站队方式的限制，对于每个询问$[a,b]$，**假设巨佬的$Fight$值是$p$**，若$p>b$，那区间$[b,p]$就没有作用了，我们的查询区间就直接缩成了$[a,min_{b,p-1}]$,这一个限制条件就解决了。

我们再考虑巨佬的站队对蒟蒻的约束作用（~~即限制了某些位必须是0~~）：

首先我们假设没有这个条件，很显然的，如果第$i$大的站队方式的$Fight$值是$j$，那么第$i+1$大的站队方式的$Fight$值就是$j-1$（二进制转十进制），

接着我们再考虑存在某些位必须是$0$的情况：

这里的方法是把所有有约束条件的$0$删去，得到一个新的，没有约束条件的数。

比如这里有一个第$i$大的数的二进制数，其中所有$0$都是被限制了的

```
1 0 1 0 1 0
```

我们把所有被限制的0删去，得到一个没有被限制的数：

```
1 1 1
```

显然这个$Fight$值是7，求第$i+1$大的数时，我们将7-1，得到6.

```
1 1 0
```
然后，我们再把刚才去掉的0加回去

```
1 0 1 0 0 0
```

这就是我们要找的数。

关于删除操作，我是这样做的，假设我们要删除下面这个二进制的第3个数：

```
1 1 1 1 1 1
      ^
```

我们先把后2位取下来：

```
1 1 1 1 0 0
s = 1 1
```

再删除第3位：

```
1 1 1 0 0 0
```

整体右移一位，在把$s$搬回去。

插入也是同理(改成左移)

具体代码实现（时间复杂度$O(1)$）：

```
void del(LL c)
{
    LL o = c - 1;
    s = ((((s & (~ c)) & (~ o)) >> 1) ^ (s & o));
}
void insert(LL c)
{
    LL o = c - 1;
    x = (((x & (~ o)) << 1) ^ (x & o));
} 
```

然后还有一个问题就是，我们首先要找到满足$[a,min_{b,p-1}]$的最大值（知道了以后就可以解题了）。

我们同样先不考虑后面的限制，我们把$min_{b,p-1}$和$p$列出来从高位到低位枚举，假设蒟蒻的站队方式最大值为$r$，如果我们枚举到一位，满足这一位$p$是1，$min_{b,p-1}$也是1，由于约束，则蒟蒻的站队在这一位上必须是0，由于是从高位往低位枚举，则高位上肯定没有这种情况(否则就不会出现在这里了）,那$r$在这位上肯定是0，这时，可以发现，无论后面取什么数，其结果都比$min_{b,p-1}$小！那我们的$r$值就可以取到这位是0，后面都是1的情况。

对于其他情况，不难发现，我们必须要取$min_{b,p-1}$所在的值才能保证最大。

最后，找到了$r$后，我们去除限制条件，把所有巨佬所在值为1的权位上的值改为0，我们就找到了最大值。

代码也不长(甚至连数组都不用开)，但是如果没思路的话，代码不一定看得懂：

```cpp
#include<cstdio>
#include<iostream>
#define LL unsigned long long
using namespace std;
LL n,m,t,q;
LL p,a,b,k,s,x;
void del(LL c)
{
    LL o = c - 1;
    s = ((((s & (~ c)) & (~ o)) >> 1ll) ^ (s & o));
}
void getmax()
{
    LL j = (1ll << (n - 1));
    for( ;j ; (j >>= 1))
      if((b & j) && (p & j)) break;
      if(!j) k = b;
      else k = ((b & (~ j)) | (j - 1));
    j = (1ll << (n - 1));
    for(; j; (j >>= 1))
      if(p & j) k = (k & (~ j));
    j = (1ll << (n - 1));s = k;
    for(; j; (j >>= 1))
      if((k & (~ (j - 1))) && (p & j)) del(j);
}
void insert(LL c)
{
    LL o = c - 1;
    x = (((x & (~ o)) << 1ll) ^ (x & o));
} 
int main()
{
    scanf("%lld%lld", &n,&m);
    for(LL i = 0;i<n;++i)
    {
        scanf("%lld", &t);
        p |= (t << i);
    }
    while(m --)
    {
        scanf("%lld%lld%lld",&a,&b,&q);
        b = min(p-1, b);
        getmax();
        x = s - q + 1;
        for(LL j = 1;j <= (1ll << n);j <<= 1)
          if(p & j) insert(j);
         if(x < a|| x>p) printf("POOR AFO!\n");
         else printf("%lld\n", x % 20031102);
    }
}
```

---

## 作者：aSunnyDay (赞：1)

这题不难，我和2018年那篇题解的思路貌似不一样？

我的思路是这样的，先不要看 $a$，直接计算 $\leq b$ 的第 $k$ 大的数字 $ans$，如果 $ans<a$ 或 $ans$ 根本不存在，就是无解。否则直接输出。

现在的任务就是计算 $\leq b$ 的第 $k$ 大的数字

# 数位DP+各种位运算

$f_{i,lmt}$ 代表枚举权值最低的 $i$ 位， 当前是否受到 $b$ 的限制，其方案数

这里要分类讨论很多东西，大概有 $lmt$，$b$ 是否允许，“巨佬”在不在旁边之类的。


# 对于 $f_{i,1}$

**若 $b$ 不允许放在第 $i$ 位，那么只能放 $0$ ，$f_{i,1}=f_{i-1,1}$**

**若 $b$ 允许放在第 $i$ 位**

继续分类讨论

 如果巨佬站在第 $i$ 位，那么这一位必须得是 $0$，而且 $lmt=0$, $f_{i,1}=f_{i-1,0}$

 如果巨佬不站在第 $i$ 位，那么 $0$ 和 $1$ 都可以。 $f_{i,1}=f_{i-1,0}+f_{i-1,1}$

=======================================
# 对于 $f_{i,0}$

**如果有大佬**，$f_{i,0}=f_{i-1,0}$

**否则**，$f_{i,0}=2*f_{i-1,0}$

=======================================

然后就是查找，查找的大体思路和上面是一致的。

即先判断能放 $0$ 还是 $1$，然后和 $k$ 比较，判断该位是什么。

代码
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll MOD=20031102; 
const ll N=73;
const ll INF=1e15;
ll n,m,cnt[N],f[N][2],a,b,k;
bool vis[N];
ll read(){
	ll x=0,f=1;
	char c=getchar();
	while(c<'0'||c>'9') f=((bool)(c^'-')<<1)-1,c=getchar();
	while(c>='0'&&c<='9') x=(x<<3)+(x<<1)+(c^48),c=getchar();
	return x*f;
}
ll F(ll x,bool lmt){//find 1<<
	if(x==-1) return 1;
	if(f[x][lmt]) return f[x][lmt];
	f[x][lmt]=0;
	if(lmt){
		if(b>=(1ll<<n)||(b&(1ll<<x))){
			if(!vis[x]) f[x][1]=F(x-1,1);
			f[x][1]+=F(x-1,0);
		}else f[x][1]=F(x-1,1);
	}else
		f[x][lmt]=(vis[x]?F(x-1,0):2*F(x-1,0));
	return f[x][lmt];
}
ll fans(ll x,ll lmt,ll k,ll cnt){
	if(x==-1){
		if(k==1) return 0;
		return -INF;
	}
	if(lmt){
		if(!vis[x]&&((b>=(1ll<<n))||(b&(1ll<<x)))){
			if(F(x-1,1)>=k) return (1ll<<x)+fans(x-1,1,k,cnt+1);
			return fans(x-1,0,k-F(x-1,1),cnt+1);
		}else{
			if(b>=(1ll<<n)||(b&(1ll<<x)))
				return fans(x-1,0,k,cnt+1);
			return fans(x-1,1,k,cnt+1);
		}
	}else{
		if(!vis[x]){
			if(F(x-1,0)>=k) return (1ll<<x)+fans(x-1,0,k,cnt+1);
			return fans(x-1,0,k-F(x-1,0),cnt+1);
		}else return fans(x-1,0,k,cnt+1);
	}
}
int main(){
	n=read(),m=read();
	for(ll i=0;i<n;++i) vis[i]=read();
	ll lst=n;
	for(ll i=0;i<n;++i)//战斗力取模
		if(!vis[i]) cnt[i]=max(cnt[lst]*2,1ll),lst=i;
	for(ll i=1;i<=m;++i){
		a=read(),b=read(),k=read();
		memset(f,0,sizeof(f));
		ll j=n-1;
		for(;j>=0;--j)
			if((1ll<<j)<=b) break;
		ll x=fans(j,1,k,0);
		if(k>F(j,1)||x<a) cout<<"POOR AFO!\n";
		else cout<<x%MOD<<"\n";
	}
	return 0;
}
```


---


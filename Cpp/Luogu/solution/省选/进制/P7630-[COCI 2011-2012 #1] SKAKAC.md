# [COCI 2011/2012 #1] SKAKAC

## 题目描述

Mirko 和 Slavko 正在玩一个游戏。

Mirko 把一个骑士棋子放在一个 $N \times N$ 的棋盘上，蒙住 Slavko 的眼睛，接下来将骑士移动 $T$ 步，每秒走一步。之后，Slavko 必须猜出骑士的最终位置才能获胜。

这个游戏中的棋盘是特别的，因为每个格子都有一部分时间被禁止通行。更准确地说，每个格子上都有一个为正整数的标记，标有数字 $K$ 的正方形只有在第 $0,K,K \times 2,K \times 3,...$ 秒内才是允许通行的，在其他时间这个格子都禁止通行。当然，骑士只能在某个格子允许通行时走到该格子。

游戏从第 $0$ 秒开始。每秒钟 Mirko 必须将骑士移动一步（根据国际象棋的规则，骑士走日字，类似中国象棋中的马）。请帮助 Slavko 写一个程序来计算出所有 $T$ 秒过后骑士可能位于的格子。

## 说明/提示

#### 【样例 1 解释】

棋盘的状态如下图所示。`.` 代表允许通行的格子，`#` 代表禁止通行的格子，`K` 代表骑士可能位于的格子。

![](https://cdn.luogu.com.cn/upload/image_hosting/9opnymlm.png)

#### 【数据范围】

对于 $40\%$ 的数据，$T \le 5 \times 10^4$。

对于 $100\%$ 的数据，$3 \le N \le 30$，$1 \le T \le 10^6$。

#### 【说明】

本题分值按 COCI 原题设置，满分 $160$。

题目译自 **[COCI2011-2012](https://hsin.hr/coci/archive/2011_2012/) [CONTEST #1](https://hsin.hr/coci/archive/2011_2012/contest1_tasks.pdf)** ___T6 SKAKAC___。

## 样例 #1

### 输入

```
3 2
1 1
1 3 2
2 3 2
3 1 1```

### 输出

```
2
1 1
1 3```

## 样例 #2

### 输入

```
5 6
2 3
4 5 3 2 3
1 3 4 3 1
3 4 1 3 2
4 4 2 1 3
4 6 4 9 2```

### 输出

```
5
1 4
2 1
2 5
4 5
5 2```

## 样例 #3

### 输入

```
3 3
2 2
3 6 4
2 2 5
1 3 7```

### 输出

```
0```

# 题解

## 作者：sgl654321 (赞：6)

这一题模拟赛做到的，也作为自己状压 dp 和根号分治的学习笔记，所以比较详细。

## 题目大意
- 有一个 $n\times n$ 的棋盘，每个点 $(i,j)$（第 $i$ 行，第 $j$ 列）上有一个数 $a_{i,j}$。
- 小马第 $0$ 秒在起点 $(1,1)$ 上，然后他会以中国象棋里面跳马的方式在棋盘里跳跃，每次跳跃会耗费 $1$ 的时间。
- 对于 $(i,j)$ 这个点，若当前时间 $t$ 满足 $a_{i,j}\big|t$，那么它可以经过。否则无法经过，相当于一个障碍。
- 询问经过 $t$ 秒以后，小马可能在哪些位置，并输出它们。

## 解题思路


### 考虑设计 dp 状态

首先考虑暴力 dp。设 $F[i][j][k]$ 表示经过 $i$ 秒时间，是否可能在 $(j,k)$ 这个位置上，转移就是直接跳马。当然，作为一道紫题，肯定不会放过这种 $O(n^2t)$ 的大暴力。

那么我们发现，这个 $n\le 30$，值域非常之小。我们自然想到状态压缩的算法，一下子记录一整行的信息。

具体地，我们定义 $f[i][j]$ 表示经过 $i$ 秒时间，$j$ 这一行的状态。即：
$$f[i][j]=\sum_{k=1}^{n}F[i][j][k]\times 2^{n-k}$$

我们考虑弱化一下这个题目，设现在没有 $a_{i,j}\big|t$ 的限制，那么我们就可以简单转移：（由于写公式不好写，我用 C++ 代码呈现）

```cpp
if(j-2>=1) s|= (f[i-1][j-2]<<1) | (f[i-1][j-2]>>1);
if(j-1>=1) s|= (f[i-1][j-1]<<2) | (f[i-1][j-1]>>2);
if(j+1<=n) s|= (f[i-1][j+1]<<2) | (f[i-1][j+1]>>2);
if(j+2<=n) s|= (f[i-1][j+2]<<1) | (f[i-1][j+2]>>1);
```
就是上一个时刻的 $8$ 个可能点。最后 $s$ 就是 $f[i][j]$ 了。


但是我们现在有了这个 $a_{i,j}\big|t$ 的限制，我们就要处理出，在 $i$ 这个时刻，$(j,k)$ 是不是障碍，记作 $Can[i][j][k]$。

同理，我们可以状态压缩成二维，变成 $can[i][j]$ 这个二维数组。

有了 $can[i][j]$，就有 $f[i][j]=s \text{ and }can[i][j]$。

现在的问题就转化成处理 $can[i][j]$ 了。

### 考虑处理 $can[i][j]$
你会发现直接处理它，比较困难，还是会回到最初 $O(n^2t)$ 的复杂度。这个时候我们考虑两种情况：

我们设一个阈值 $d$。

**当 $a_{i,j}$ 比较大的时候，即** $a_{i,j}>d$，$a_{i,j}$ 在 $[1,t]$  之间的倍数会比较少。这个怎么办，我们直接把贡献 $2^{n-j}$ 或到 $can[k\times a_{i,j}][i],k\in \mathbb{N}^+$ 就行了。

**当 $a_{i,j}$ 比较小的时候，即** $a_{i,j}\le d$，我们可以直接记录下值为 $i$ 的元素，在第 $j$ 行出现的状态是什么，记作 $cnt_{i,j}$。

在 dp 的时候，对于当前时间 $i$，求出它在 $[1,d]$ 之间的因数有哪些，然后对于所有的因数 $div$，对于每一行 $j$，把 $can[i][j]$ 或上 $cnt[div][j]$ 即可。


考虑下这样的复杂度是什么。

- 对于第一种情况，复杂度显然为 $O(n^2\times \dfrac{t}{d})$，瓶颈在预处理。

- 对于第二种情况，复杂度瓶颈不在预处理，而在 dp 的时候。我们设 $div(i,j)$ 表示数 $i$ 在 $[1,j]$ 内的因数个数。复杂度为 $O(t\times d+n\times \sum_{i=1}^t div(i,d) )$

我们发现这两个复杂度，一个 $d$ 被除了，一个 $d$ 被乘了。这种情况下，就会有**均值不等式**出现。

但是由于还有一个 $div(i,d)$ 感觉不太好搞，所以我们先考虑放大一下这个下式。我们把它直接放大成 $O(n\times t\times d)$。

那么我们有：

$$n^2\dfrac{t}{d}+ntd\ge nt\sqrt{n},d=\dfrac{n}{\sqrt{n}}\approx 6\text{ 时取等号。}$$

由于我们放大了一些下式，那么其实最优的 $d$ 应当比这个大。事实上，根据后文对于空间复杂度的分析，我们应该把 $d$ 开**大很多**。

由于这里的时限 1.5s 非常充裕，所以随便了。这下我们就得到了正解代码？……真的是这样吗？这里是[提交记录](https://www.luogu.com.cn/record/147711745)，只 AC 了 4 个点，其他都 MLE 了。

为什么呢？因为我们的空间只有 64MB，你的 $f,can$ 两个数组都开到了 $10^6\times 30$，直接爆炸了！

### 考虑优化空间
首先，$f$ 这个数组你会发现 $i$ 只与 $i-1$ 有关，这意味着你可以使用滚动数组，直接把它大大压缩到了 $n$ 的级别。

那么 $can$ 这个数组就没那么好办了，因为你预处理的时候有一个枚举 $k$ 的过程，这个影响不能用滚动数组处理。

所以我们不能直接把这个贡献或到 $can[k\times a_{i,j}][i]$ 里面去，而要对每一个时间 $i$ 开一个 `vector` $v_i$，里面记录预处理时，你有哪些 $(j,k)$。然后在 dp 的时候，再把贡献算到当前的数组 $can$ 里面去。

就像这样：
```cpp
for(int k=1;k<=t/a[i][j];k++)
	v[ k*a[i][j] ].push_back(make_pair(i,j));
```
在 dp 时就:
```cpp
for(auto x:v[i]){
	fi=x.first;
   	se=x.second;
	can[fi]|=1<<(n-se);
}
```

这样的话，你的空间瓶颈就是 `vector` 的空间了。`vector` 里面的 `pair`，即 $i,j$ 都是小于等于 $30$ 的，我们直接使用 `char` 类型就可以。

空间复杂度为 $O(n^2\dfrac{t}d)$。常数为 $2$，因为有 $2$ 个 `char`。注意到 $n=30,t=10^6$ 的最大情况时，$d=\dfrac{2n^2t\text{ Byte}}{64 \text{MB}}\approx 26$，同时由于 `vector` 初始也有空间，其他变量也有空间等等，我们得把 $d$ 开的比 $26$ 还要大一点点。反正你的时间充裕，我直接开了个 $d=200$。

这样我们这题就解完了。

## 参考代码
```cpp
#include<bits/stdc++.h>
#define maxn 1000010
using namespace std;
typedef int ll;
typedef pair<char,char> pll;
struct node{
	ll x,y;
}ans[1010];
ll n,t,x,y,a[40][40],f[2][40],d,s,now,las,can[40];
ll cnt[1010][40],sum,fi,se;
vector<pll>v[maxn];

int main(){
	cin>>n>>t>>x>>y;
	d=200;
	int i,j,k;
	for(i=1;i<=n;i++)
		for(j=1;j<=n;j++){
			cin>>a[i][j];
			/*
			根号分治算法：设立一个阈值 D，对于 x<=D 的，我们用一种解法
			对于 x>D 的，我们使用另一种解法
			
			case 1: 如果 a[i][j]>D 说明，它比较大，是 a[i][j] 倍数的 t 不是很多
			那么我们可以直接 for 过去加贡献 can [ k*a[i][j] ][i] |= ( 1<< n-j )
			-------------------------------------------------------------
			case 2: 如果 a[i][j]<=D 我们考虑首先记录下，对于值为 u 的元素，在第 v 行的状态 f[u][v]
			那么，就是 cnt[ a[i][j] ] [i] |= ( 1<< n-j ) 
			
			然后统计答案的时候该怎么办呢？见下半部分的注释。
			
			
			*/			
			if(a[i][j]<=d)cnt[a[i][j]][i]|=(1<<(n-j));
			else 
				for(k=1;k<=t/a[i][j];k++)
					v[ k*a[i][j] ].push_back(make_pair(i,j));
		}
	f[0][x]=(1<<(n-y));
	for(i=1;i<=t;i++){
		/*我们要把 case 2 的贡献也加到 can 里面去。
		这里的 a[i][j] 都很小 (<=D)，因此我们可以直接 枚举 1 ~ D  
		看看里面是他的因数的有几个，然后处理这个贡献。
		*/
		now=i%2;las=1-now;
		for(j=1;j<=n;j++)can[j]=0;
		for(auto x:v[i]){
			fi=x.first;se=x.second;
			can[fi]|=1<<(n-se);
		}
		
		for(j=1;j<=d;j++)
			if(i%j==0)
				for(int k=1;k<=n;k++)
					can[k]|=cnt[j][k];
	
		for(j=1;j<=n;j++){
			s=0;
			if(j-2>=1) s|= (f[las][j-2]<<1) | (f[las][j-2]>>1);
			if(j-1>=1) s|= (f[las][j-1]<<2) | (f[las][j-1]>>2);
			if(j+1<=n) s|= (f[las][j+1]<<2) | (f[las][j+1]>>2);
			if(j+2<=n) s|= (f[las][j+2]<<1) | (f[las][j+2]>>1);
		
			f[now][j]=s&can[j];
		}
	}
	for(i=1;i<=n;i++)
		for(j=1;j<=n;j++)
			if(f[now][i]&(1<<(n-j)))
				ans[++sum]=node{i,j};
	cout<<sum<<endl;
	for(i=1;i<=sum;i++)
		cout<<ans[i].x<<" "<<ans[i].y<<endl;
	/*
	时间复杂度分析： 
	a[i][j] > D 瓶颈在预处理，O(n^2 t/D) 
	a[i][j] < D 瓶颈在 dp 转移时处理贡献， O( t( D+ n* ∑f(t,D) ) ) 
	其中 f(i,j) 表示，值为 i 的元素在 [1,j] 中的因数有几个。
	
	这个东西啊，不好分析，，直接尝试微调阈值当然是一种方法。
	考虑放大一点，直接变成 n^2 t/D + ntD >= nt\sqrt(n)
	这样的话，你取 D = n/sqrt(n)
	由于你放大了 case 2, case 2 是 ×D 的，所以 D 应该更大一点。
	大多少我就不知道了，反正 nt\sqrt(n) 在本题应该也足以通过了。  
	*/ 
	return 0;
}
```





---

## 作者：伟大的王夫子 (赞：6)

直接暴力模拟的时间复杂度是 $O(n^2 T)$。

我们可以想到位运算优化，但我们还有预处理每个时间能到达的格子状态，所以最多优化一下常数，不能使时间复杂度得到显著的提升。

所以说现在整个算法的瓶颈在于预处理每个时间能到达的格子状态。我们想办法用根号分治进行优化。

对于大于 $1000$ 的 $x$ 可以暴力求。

而对于小于等于 $1000$ 的数来说，$1000$ 之内的质数并不多，只有 $100$ 多个，令 $f_{i, j, k}$ 表示当前时间是第 $i$ 个质数的 $j$ 次方的倍数时，第 $k$ 行的状态，对于每个时间 $T$，我们将其质因数分解，设 $T = \prod\limits_{i=1}^n p_i^{c_i}(c_i\ge 0)$，对于第 $k$ 行，我们求出 $f_{1, c_1, k},f_{2, c_2, k} \cdots f_{n, c_n, k}$ 这些数按位与后的结果即可。

但这样的时间复杂度还不如暴力。由于 $ > 0$ 的 $c_i$ 并不多，我们直接预处理一下 $f_{i, 0, k}$ 的按位与区间和即可。由于 $2 \times 3 \times 5 \times 7 \times 11 \times 13 \times 17 \times 19 > 10^6$，故时间复杂度为 $O(7 \cdot Tn)$。常数不要太大，就可以过。

但这样还会出现空间问题。为了优化，我们不能直接开一个 $30 \times 10^6$ 的数组，而应该用 vector 来存大于 $1000$ 的那些 $x$ 的下标。并且我们可以把一个二元组 $(x, y)$ 压成一个 short 变量。而我们也不用记录每个 $T$ 质因数分解的结果，而可以记录最大的整除 $T$ 的质数 $p$，那么便可以做到快速分解因数。这样就可以突破空间限制了。

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, m, dp[2][31], a[31], f[200][30][31], b[31], pri[200005], tot, g[200][200][31], ff[1000005];
const int B = 100;
vector<int> vec[1000005];
int main() {
    for (int i = 2; i <= 1000000; ++i) {
        if (ff[i])
            continue;
        pri[++tot] = i;
        ff[i] = tot;
        for (int j = 2 * i; j <= 1000000; j += i) ff[j] = tot;
    }
    for (int i = 1; i <= tot; ++i)
        if (pri[i] > B) {
            tot = i - 1;
            break;
        }
    int sx, sy;
    scanf("%d%d%d%d", &n, &m, &sx, &sy);
    --sx, --sy;
    dp[0][sx] |= 1 << sy;
    for (int i = 0; i < n; ++i)
        for (int j = 0, x; j < n; ++j) {
            scanf("%d", &x);
            if (x > B)
                for (int k = x; k <= m; k += x) vec[k].push_back(i * 30 + j);
            else {
                int now = x;
                while (now != 1) {
                    int xx = ff[now], cnt = 0;
                    while (now % pri[xx] == 0) now /= pri[xx], ++cnt;
                    f[xx][cnt][i] |= 1 << j;
                }
                for (int k = 1; k <= tot; ++k)
                    if (x % pri[k])
                        f[k][0][i] |= 1 << j;
            }
        }
    for (int i = 1; i <= tot; ++i) {
        for (int k = 0; k < n; ++k)
            for (int j = 1; j <= 29; ++j) f[i][j][k] |= f[i][j - 1][k];
    }
    bool at = 0;
    for (int l = 1; l <= tot; ++l) {
        for (int i = 0; i < n; ++i) {
            g[l][l][i] = f[l][0][i];
            for (int r = l + 1; r <= tot; ++r) g[l][r][i] = g[l][r - 1][i] & f[r][0][i];
        }
    }
    for (int cas = 1; cas <= m; ++cas) {
        for (int i = 0; i < n; ++i) a[i] = (1 << n) - 1;
        int x = cas, last = tot;
        while (x != 1) {
            int now = ff[x], cnt = 0;
            while (x % pri[now] == 0) ++cnt, x /= pri[now];
            if (now > tot)
                continue;
            for (int i = 0; i < n; ++i) a[i] &= f[now][cnt][i];
            if (last >= now + 1)
                for (int i = 0; i < n; ++i) a[i] &= g[now + 1][last][i];
            last = now - 1;
        }
        if (last)
            for (int i = 0; i < n; ++i) a[i] &= g[1][last][i];
        for (auto v : vec[cas]) {
            int r = v / 30, c = v % 30;
            a[r] |= 1 << c;
        }
        for (int i = 0; i < n; ++i) dp[at ^ 1][i] = 0;
        for (int i = 0; i < n; ++i) {
            if (i >= 1)
                dp[at ^ 1][i - 1] |= (dp[at][i] << 2) | (dp[at][i] >> 2);
            if (i + 1 < n)
                dp[at ^ 1][i + 1] |= (dp[at][i] << 2) | (dp[at][i] >> 2);
            if (i >= 2)
                dp[at ^ 1][i - 2] |= (dp[at][i] << 1) | (dp[at][i] >> 1);
            if (i + 2 < n)
                dp[at ^ 1][i + 2] |= (dp[at][i] << 1) | (dp[at][i] >> 1);
        }
        for (int i = 0; i < n; ++i) dp[at ^ 1][i] &= a[i];
        at ^= 1;
    }
    int ans = 0;
    for (int i = 0; i < n; ++i) ans += __builtin_popcount(dp[at][i]);
    printf("%d\n", ans);
    for (int i = 0; i < n; ++i)
        for (int j = 0; j < n; ++j)
            if (dp[at][i] >> j & 1)
                printf("%d %d\n", i + 1, j + 1);
}
```

~~区区 3K 的代码，不要慌。~~

---

## 作者：耳朵龙_ (赞：5)

提供一个目前除提答外用时最短、内存最小、代码最短的做法。

直接模拟，复杂度 $O(n^2T)$，过不去，考虑优化。

把可能有马的位置标记为 $1$，一定没马的位置标记为 $0$，则棋盘可以化为 $01$ 矩阵。将矩阵的每一行视为一个二进制数压缩，如果能对每一时刻 $k$ 的每一行 $i$，求出能走的格子集合 $st_{k,i}$（仍然状压表示），在模拟时位运算（按规则对有马的格子或运算，然后对没有障碍的格子与运算），即可 $\mathrm{O}(nT)$ 算出答案。

设输入的矩阵为 $c$，考虑求出每一时刻每一行能走的格子集合，初始时令这些集合均为空。

对于第 $i$ 行，设 $c_i$ 这一行中所有数构成的集合为 $A$，枚举 $x\in A$，令 $t=\{j\mid c_{i,j}=x\}$，再枚举所有 $x\mid k$，令 $st_{k,i}\gets st_{k,i}\cup t$。这样处理完第 $i$ 行复杂度为 $\sum_{x\in A}\frac{T}{x} \le \sum_{x=1}^n\frac{T}{x}=O(T\ln{n})$。处理完所有行，总复杂度为 $O(nT\ln{n})$，可以通过本题。

代码也很好写，这题卡空间，不能一下把 $st$ 数组开完，只能把 $T$ 分为三段依次处理了。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 30,T = 350000;
int n,st[T][N],c[N][N],a[N],b[N],msk,ans;
#define g(x,y) (((a[x]<<y)|(a[x]>>y))&msk)
void solve(int L,int R){
	memset(st,0,sizeof st);
	for(int i = 0;i < n;++i)
		for(int j = 0,t,k,d = msk;j < n;++j)
			if((d>>j)&1){
				for(k = j+1,t = 1<<j;k < n;++k) if(c[i][k] == c[i][j]) t |= 1<<k;d ^= t;
				for(k = ((L-1)/c[i][j]+1)*c[i][j];k <= R;k += c[i][j]) st[k-L+1][i] |= t;
			}
	for(int i = 1,t;i <= R-L+1;++i){
		memset(b,0,sizeof b);
		if(n > 1) b[1] |= g(0,2),b[n-2] |= g(n-1,2);
		if(n > 2) b[2] |= g(0,1),b[n-3] |= g(n-1,1);
		if(n > 3) b[3] |= g(1,1),b[n-4] |= g(n-2,1);
		for(int j = 1;j < n-1;++j) t = g(j,2),b[j-1] |= t,b[j+1] |= t;
		for(int j = 2;j < n-2;++j) t = g(j,1),b[j-2] |= t,b[j+2] |= t;
		for(int j = 0;j < n;++j) b[j] &= st[i][j];
		memcpy(a,b,sizeof b);
	}
}
int main(){
	int X,Z,T;
	scanf("%d%d%d%d",&n,&T,&X,&Z),a[X-1] |= 1<<Z-1,msk = (1<<n)-1;
	for(int i = 0;i < n;++i) for(int j = 0;j < n;++j) scanf("%d",&c[i][j]);
	solve(1,T/3),solve(T/3+1,T/3*2),solve(T/3*2+1,T);
	for(int i = 0;i < n;++i) for(int j = 0;j < n;++j) if((a[i]>>j)&1) ++ans;
	printf("%d",ans);
	for(int i = 0;i < n;++i) for(int j = 0;j < n;++j) if((a[i]>>j)&1) printf("\n%d %d",i+1,j+1);
	return 0;
}
```

---

## 作者：7KByte (赞：3)

有删减，原文见[**我的博客**](https://www.cnblogs.com/SharpnessV/p/14928842.html)。


直接朴素模拟一下，时间复杂度是 $\mathcal{O}(TN^2)$ ，可以通过 $40\%$ 个测试点。

我们只需要记录 $0/1$ 表示是否可达，直接状压，可以做到 $\mathcal{O}(TN)$ 转移。但是有些格子在某些时间不可到达，处理这个限制仍然是 $\mathcal{O}(TN^2)$ 。这个做法可以优化约 $10$ 倍常数，可以通过 $70\%$ 的测试点。


考虑根号分治，对于 $a_{i,j}\ge \sqrt{T}$  ，最多有 $\sqrt T$ 个时间点该格子是开放的，暴力维护即可，时间复杂度 $\mathcal{O}(N^2\sqrt T)$ 。

对于 $a_{i,j}< \sqrt T$ ，最多有 $168$ 个质数。

我们记录 $f[i][j][k]$ 表示第 $i$ 个质数 $p_i$，时间为 $p_i^j$ 的倍数，第 $k$ 行的状态，对每个 $a_{i,j}$ 分解质因数即可。

然后对于每个时间 $t$ ，我们对 $t$ 分解质因数，然后对于每个质数的 $f[i][j]$ 按位与即可。注意这里 $j=0$ 的质数 $p_i$ 也要计算进去。

直接计算的时间复杂度是 $\mathcal{O}(|P|TN)$ ，$|P|=168$ ，比朴素模拟还要劣。

所以我们可以预处理 $g[l][r][k]=f[l][0][k]\ \&\ f[l+1][0][k]\ \&\ \cdots\ \&\ f[r][0][k]$ 。这部分的时间复杂度是 $\mathcal{O}(|P|^2N)$ 。


---

## 作者：SUPERZGY (赞：1)

## COCI2011-2012#1 T6 SKAKAC

#### 算法：根号分治 状压 dp ~~数论~~

1. 首先由于 $n \leqslant 30$ 可以容易看出**状压 dp**。
   由此设计 dp 状态 $f_{i,j}$ 表示时刻为 $i$ 第 $j$ 行的压缩状态，我们可以通过滚动数组将其进一步压缩。

   $$f_{i,j}= \sum_{k=1}^nf_{i,j,k} \times 2 ^ {n-k}$$

   设现在没有时刻倍数的约束，有：

   ```cpp
   if(j-2>=1) s|= (f[i-1][j-2]<<1) | (f[i-1][j-2]>>1);
   if(j-1>=1) s|= (f[i-1][j-1]<<2) | (f[i-1][j-1]>>2);
   if(j+1<=n) s|= (f[i-1][j+1]<<2) | (f[i-1][j+1]>>2);
   if(j+2<=n) s|= (f[i-1][j+2]<<1) | (f[i-1][j+2]>>1);
   ```

2. 现在就需要考虑对于转移的约束，用 $clear_{i,j}$ 表示第 $j$ 行 在 $i$ 时刻是否被阻碍，处理该数组需要时间 $O(n ^ 2 T)$，考虑**根号分治**，$d$ 为阀值。

   - 当$a_{i,j} \le d$ 时：
     我们可以直接记录下时刻为 $j$ 的元素，在第 $i$ 行出现的状态是什么，记作 $state_{i,j}$；
   - 当$a_{i,j} > d$ 时：
     $a_{i,j}$ 在范围内的倍数较少，可以直接统计 $clear_{i,j}$ ，将贡献**或**到 $clear_{i \times k,j}$ 上；

     _参考第一篇题解，阀值 $d$ 应为 $6$ 左右，此代码将 $d$ 设为 $10$。_

3. 空间复杂度为 $O(n ^ 2 \times T)$，考虑优化空间复杂度。

   - 可将 $clear$ 数组通过**链式前向星**优化，在一定时间空间范围内实时求取；

   - 由于阀值 $d=10$，对于所有 $a_{i,j} \le 10$，可以将空间进行压缩：设特殊值 $maxl$，可以使得 $maxl \times k+j$ 时刻的 $state$与 $j$ 时刻相等；

   - 对于 $maxl$ 的计算：$maxl$ 一定使得 $maxl \times k+j$ 和 $j$ 时刻的 $state$ 值相等，故 $maxl \times k+j$ 和 $j$ 同时是对于一定取值的 $a_{i,j}$ 的倍数，对于另外取值的 $a_{i,j}$ ，二者一定都不是其倍数。可使 $maxl \times k+j \equiv j \pmod{a_{i,j}}$，$a_{i,j} \in [1,10]$，可取 $maxl$ 为 $\operatorname{lcm}(1,2,3,4,5,6,7,8,9,10)=2520$。

#### 附代码

```cpp
#include<cstdio>

using namespace std;

typedef long long LL;

const int maxn = 35;
const int maxl = 2520;
const int maxT = 1000005;

struct Tpsn{
	int x, y;
};

int det[maxn][maxn];
Tpsn next[maxn][maxn];
Tpsn fch[maxT];
LL state[maxn][maxl];
LL clear[maxn];
LL f[2][maxn];
int n, T, X, Y;
int N, P, ret;

void init()
{
	scanf("%d%d%d%d", &n, &T, &X, &Y);
	for (int i = 1; i <= n; i ++)
		for (int j = 1; j <= n; j ++) scanf("%d", &det[i][j]);
}

void add_psn(int t, int x, int y)//链式前向星
{
	if (t > T) return;
	next[x][y].x = fch[t].x;
	next[x][y].y = fch[t].y;
	fch[t].x = x; fch[t].y = y;
}//对空间优化

void work()
{
	for (int i = 1; i <= n; i ++)
		for (int j = 1; j <= n; j ++)
			if (det[i][j] > 10) add_psn(0, i, j);
        //预处理 >10 的部分
	N = 0; P = 1;
	for (int i = 1; i <= n; i ++) f[N][i] = 0;
	f[N][X] |= (1 << (Y - 1));
	LL L = (1 << n) - 1;
	for (int i = 1; i <= n; i ++)
		for (int j = 0; j < maxl; j ++)
			for (int k = 1; k <= n; k ++)
				if (det[i][k] <= 10 && j % det[i][k] == 0)
					state[i][j] |= 1 << (k - 1);
        //预处理 <10 的部分
        //state[i][j]表示 第i行关于 det<=10 时刻为j+k*maxl 的压缩状态
    int cnt = 0;
	for (int t = 0; t < T; t ++){
		N ^= 1; P ^= 1;
        //滚动数组
		for (int i = 1; i <= n; i ++){
			f[N][i] = 0; clear[i] = 0;
		}
		for (int i = 1; i <= n; i ++){
			f[N][i+1] |= ((f[P][i] << 2) | (f[P][i] >> 2)) & L;
			f[N][i-1] |= ((f[P][i] << 2) | (f[P][i] >> 2)) & L;
			if (i < n) f[N][i+2] |= ((f[P][i] << 1) | (f[P][i] >> 1)) & L;
			if (i > 1) f[N][i-2] |= ((f[P][i] << 1) | (f[P][i] >> 1)) & L;
		}
            //状压状态转移
		for (Tpsn i = fch[t]; i.x != 0; ){
			Tpsn tmp = next[i.x][i.y];
			add_psn(t + det[i.x][i.y], i.x, i.y);
			i = tmp;
		}
		for (Tpsn i = fch[t+1]; i.x != 0; i = next[i.x][i.y])
			clear[i.x] |= (1 << (i.y - 1));
            //clear[i] 表示 当前时刻 第i行关于 det>10 的压缩状态
		cnt ++;
        //cnt表示 时刻对maxl 的模数
		if (cnt == maxl) cnt = 0;
		for (int i = 1; i <= n; i ++)
			f[N][i] &= clear[i] | state[i][cnt];
	}
	ret = 0;
	for (int i = 1; i <= n; i ++)
		for (int j = 0; j < n; j ++)
			if (f[N][i] & (1 << j)) ret ++;
        //统计答案
}

void print()
{
	printf("%d\n", ret);
	for (int i = 1; i <= n; i ++)
		for (int j = 0; j < n; j ++)
			if (f[N][i] & (1 << j)) printf("%d %d\n", i, j + 1);
}

int main()
{
//  freopen("skakac.in", "r", stdin);
//  freopen("skakac.out", "w", stdout);

	init();
	work();
	print();
	return 0;
}
```

---

## 作者：guosoun (赞：1)

首先有一个的状压 DP，$dp(i,j)$ 表示 $i$ 时刻的 $j$ 行可能到达的列的集合（状态压缩）。

转移： $dp(i,j)$ 二进制或上「$dp(i-1,j\pm 1)$ 左移/右移 $2$」和「$dp(i-1,j\pm2)$ 左移/右移 $1$」。

但是发现并没有考虑到「当时间是这个格子数字的倍数时才可以到达」的条件，考虑预处理数组 $ct(i,j)$ 为第 $i$ 时刻的第 $j$ 列所有符合要求的列数的集合，将 $dp(i,j)$ 二进制与上 $ct(i,j)$ 即可。

这个 DP 本身的时间复杂度是 $O(TN)$，空间可以用滚动数组做到 $O(N)$。

要注意的是，$ct$ 数组由于空间限制不能储存，只能在 DP 到 $i$ 时刻时临时求出，接下来的问题就简化为如何预处理 $ct$ 数组。

考虑数据分治，对于数字大于 $D$ 的格子，能到达其的时间只有 $\frac T D$ 个，考虑将这个点的坐标二元组放进这 $ \frac T D$ 个时刻的`vector`里，在 DP 到这个时刻的时候再把这些二元组的位置的 $ct$ 赋上 $1$。空间和时间复杂度都是 $O(N^2\frac TD)$ 的。

对于数字小于等于 $D$ 的格子，考虑先对于小于等于 $D$ 的每个时刻 $i$，预处理每一行有多少个数字为 $i$ 的，即 $cx(i,j)$ 表示棋盘上第 $j$ 行数字为 $i$ 的列的集合。

再在 DP 的时候，对于每一个时刻 $i$，找出所有小于等于 $D$ 且是 $i$ 因子的时刻 $j$，将这 $N$ 列的 $ct(i,x)$ 二进制或上 $cx(j,x)$。空间复杂度 $O(DN)$，时间复杂度 $O(TDN)$，但由于满足要求的 $j$ 很少，所以跑不满。

实测，$D$ 为二十几时最快。

代码：

```cpp
#include <bits/stdc++.h>
#define ll long long
#define pii pair<int,int>
using namespace std;
const int N=32,T=1e6+10;
bool st;
int n,t,sx,sy,D=27;
unsigned int cx[N][1010],dp[2][N],ct[N];
struct node{short x,y;};
vector<node>cd[T];
bool ed;
int main(){
    cin>>n>>t>>sx>>sy;
    for(int i=0;i<n;i++){
        for(int j=0;j<n;j++){
            int v;cin>>v;
            if(v>D) for(int k=v;k<=t;k+=v)
                cd[k].push_back((node){i,j});
            else cx[v][i]|=(1<<j);
        }
    }
    dp[0][sx-1]|=(1<<(sy-1));
    for(int i=1;i<=t;i++){
        memset(dp[i&1],0,sizeof(dp[i&1]));
        memset(ct,0,sizeof(ct));
        for(node p:cd[i]) ct[p.x]|=(1<<p.y);
        for(int j=1;j<=D;j++) if(!(i%j)) for(int k=0;k<n;k++) ct[k]|=cx[j][k];
        for(int j=0;j<n;j++){
            if(j>=1) dp[i&1][j-1]|=dp[(i-1)&1][j]<<2,dp[i&1][j-1]|=dp[(i-1)&1][j]>>2;
            if(j<n-1) dp[i&1][j+1]|=dp[(i-1)&1][j]<<2,dp[i&1][j+1]|=dp[(i-1)&1][j]>>2;
            if(j>=2) dp[i&1][j-2]|=dp[(i-1)&1][j]<<1,dp[i&1][j-2]|=dp[(i-1)&1][j]>>1;
            if(j<n-2) dp[i&1][j+2]|=dp[(i-1)&1][j]<<1,dp[i&1][j+2]|=dp[(i-1)&1][j]>>1;
        }
        for(int j=0;j<n;j++) dp[i&1][j]&=ct[j];
    }
    int cnt=0;
    for(int i=0;i<n;i++) for(int j=0;j<n;j++) if(dp[t&1][i]&(1<<j)) cnt++;
    cout<<cnt<<'\n';
    for(int i=0;i<n;i++) for(int j=0;j<n;j++) if(dp[t&1][i]&(1<<j)) cout<<i+1<<' '<<j+1<<'\n';
    return 0;
}
```





---

## 作者：CarroT1212 (赞：0)

提供一个比较神金的实现。

朴素 $O(Tn^2)$ DP 是容易的。这个图没什么能用的性质，所以往直接优化这个暴力 DP 上想。

每轮转移方式已知且相同，每一步有若干格子不能走，求能走到哪些格子。看起来很状压啊。

就，这个时候可以把每行的 DP 数组 $f_{i,j}$ 压成一个数 $f_i$，转移的时候相当于不同行之间通过左移右移表示列的变化。每一步转移完把那些在不合法格子上的位跟预处理的 mask 与一下去掉。

但是我觉得把每一行都压一次有一些繁琐，考虑把整个矩阵压到一起。使用 bitset 压进整个矩阵（按遍历顺序重标号一遍这个矩阵然后拍到一维），理论上我们会得到一个 $n^2$ 的状压数组，然后在上面进行一些左移右移就可以实现走步操作。

不过压整个矩阵会出现的问题就是，如果你在矩阵的左右边缘，正常来说有一些操作是不合法的，会走到外面去，但是拍到一维做的话这会被判定成走到了矩阵的另一端。

我的解决方案是压位的时候在矩阵的左右虚空补一列格子，搞成一个 $n$ 行 $n+2$ 列的矩阵，这样不合法的操作都会移到后期补的这些格子，你求一个 bitset 记录一下原图有的格子是哪些，每次处理完一轮操作就把 DP 数组跟这个 bitset 与一下，非法操作就都不存在了。

八种方向相当于左移/右移 $n,n+4,2n+3,2n+5$ 位。

现在考虑怎么求每一轮能走的格子。设第 $i$ 轮能走的格子的 bitset 为 $t_i$。直接暴力对每个 $a_{i,j}$ 更新可能的 $t_i$ 显然会被一堆 $2$ 卡死，那么我们提前把所有 $a_{i,j}$ 相等的 $(i,j)$ 压到同一个 bitset 里再去用这个 bitset 统一更新 $t_{ka_{i,j}}$ 即可。

做完了吧。算一下空间，你发现 64MB 只能开下一半的 $T$ 个 $n^2$ 的 bitset。哇。

那好吧，目前的时间复杂度是一个类似 $O(\frac{Tn^2}{\omega})$ 的东西，看起来还有压榨空间。空间复杂度瓶颈是 $T$ 个 $t_i$，所以我们可以在 DP 的时候分两半做，每次预处理一半的 $t_i$。

不过预处理的部分也要用很多的 bitset，那么我们对于大于某个阈值 $B$ 的 $a_{i,j}$ 直接暴力更新，否则存进 bitset 里统一更新。$B$ 可以取 $1000$。

至此你可以以 63MB 的低劣空间通过此题。

```cpp
const ll J=1e18,N=37,K=970,T=1e6+7,TT=1e3;
ll n,t,sx,sy,a[N][N],c[N][N],cnn;
bitset<K> b[T/2],g[TT],tmp,msk;
void mian() {
	scanf("%lld%lld%lld%lld",&n,&t,&sx,&sy);
	for (ll i=1;i<=n;i++) for (ll j=0;j<=n+1;j++) {
		c[i][j]=++cnn;
		if (1<=j&&j<=n) msk.set(c[i][j]);
	}
	tmp.set(c[sx][sy]);
	for (ll i=1;i<=n;i++) for (ll j=1;j<=n;j++) scanf("%lld",&a[i][j]);
	ll t1=min(T/2-1,t),t2=max(t-T/2+1,0ll);
	for (ll i=1;i<=n;i++) for (ll j=1;j<=n;j++) if (a[i][j]<=t) {
		if (a[i][j]>=TT) { for (ll k=a[i][j];k<=t;k+=a[i][j]) if (k<T/2) b[k].set(c[i][j]); }
		else g[a[i][j]].set(c[i][j]);
	}
	for (ll i=1;i<TT;i++) for (ll k=i;k<=t;k+=i) if (k<T/2) b[k]|=g[i];
	for (ll i=1;i<=t1;i++) 
		tmp=((tmp<<n)|(tmp<<n+4)|(tmp<<n*2+3)|(tmp<<n*2+5)|(tmp>>n)|(tmp>>n+4)|(tmp>>n*2+3)|(tmp>>n*2+5))&b[i]&msk,
		b[i].reset();
	for (ll i=1;i<=n;i++) for (ll j=1;j<=n;j++) if (a[i][j]<=t) {
		if (a[i][j]>=TT) for (ll k=a[i][j];k<=t;k+=a[i][j]) if (k>=T/2) b[k-T/2+1].set(c[i][j]);
	}
	for (ll i=1;i<TT;i++) for (ll k=i;k<=t;k+=i) if (k>=T/2) b[k-T/2+1]|=g[i];
	for (ll i=1;i<=t2;i++)
		tmp=((tmp<<n)|(tmp<<n+4)|(tmp<<n*2+3)|(tmp<<n*2+5)|(tmp>>n)|(tmp>>n+4)|(tmp>>n*2+3)|(tmp>>n*2+5))&b[i]&msk;
	vector<pll> ans;
	for (ll i=1;i<=n;i++) for (ll j=1;j<=n;j++) if (tmp.test(c[i][j])) ans.pb({i,j});
	cout<<ans.size()<<"\n";
	for (pll i:ans) cout<<i.fi<<" "<<i.se<<"\n";
}
```

其实并没有变得好写。

---

## 作者：封禁用户 (赞：0)

首先是一个非常 Naive 的 dp，令 $dp_{i,x,y}$ 表示 $i$ 时刻 $x,y$ 是否能被跳到。

枚举，然后转移，如果滚动数组，就可以做到 $O(n^2)$ 空间，$O(Tn^2)$ 时间复杂度。

这显然是 $\textup{\textmd TLE}$ 的……

注意到题目的 $n \le 30$，可以直接用一个 int 存在某一行/列的答案。

设时刻 $i$ 第 $j$ 列的答案为 $dp_{i,j}$。

假设不考虑答案的限制，两者之间转移可以做到 $O(1)$，即
1. $dp_{i,j\pm 1}$ 左/右移两位
2. $dp_{i,j\pm 2}$ 左/右移一位

两者转移即可，但是涉及到倍数的限制，设 $can_{i,j} $ 为 $i$ 时刻 $j$ 列的可行跳跃位置，则只需要最后的时候让 $dp_{i,j}$ 与 $can_{i,j}$ 取交集即可。

如果直接枚举倍数，复杂度上限是 $O(Tn^2)$。

考虑分块决策，设将 $[1,D]$ 的因数挑出来额外记录一个数组 $can2_{x,j}$ 表示值为 $x$ 的第 $j$ 列有哪些。

不直接枚举他们，而是在每次访问时考虑他们对于 $can_{i,j}$ 的贡献。

在优秀实现下，复杂度上限为 $O(n^2\frac{T}{D+1}+T(D+\sum_{t=1}^D \frac{n}{t}))=O(n^2\frac{T}{D+1}+T(n \ln D+D))$。

这个实现上来说，就是枚举时间 $i$ 后，判断是否满足 $t \mid i$，然后再将 $can2_{t,j}$ 贡献到 $can_{i,j}$。

显然，$t \mid i$ 成立的次数就是 $\sum_{t=1}^D \frac{1}{t}$，也就是要循环这么多次取贡献 $j$ 这一维。

---

## 作者：syta (赞：0)

[传送门](https://www.luogu.com.cn/problem/P7630)

其实是比较板的根号分治（虽然我不会就是了。

直接暴力转移的复杂度是 $O(Tn^2)$ ，无法通过，但是注意到 $n$ 比较小，所以二进制压位 。

首先可以将每一行压成一个数，这样转移只需要左右移动 OR 起来，最后 AND 上这一行可以停留的位置即可。

于是现在问题就变成了怎么处理出 $x$ 时刻，$i$ 行的可以停留情况。

现在有 $n^2$ 个位置，对于大于 $7$ 的元素暴力跳倍数存下来即可，否则我们考虑在每一个时刻 $x$ 枚举前 $7$ 个数是否为 $x$ 的因数，对于每一行 OR 一下就行了。

这题略卡空间，可以将时刻劈成两份，跑到后一半的时候暴力重构，循环利用这个数组。

```cpp
const int N=30,M=5e5+5;
int n,m,v,sx,sy;
int bl=7;
int a[N][N];
int cn[M][N],p[10][N],dp[2][N];
pii s[M];
int main(){
	scanf("%d%d%d%d",&n,&m,&sx,&sy);
	v=m/2+1;
	for(int i=0;i<n;i++){
		for(int j=0;j<n;j++){
			int x;
			scanf("%d",&x);
			if(x<=bl) p[x][i]|=(1<<j);
			else for(int k=0;k<=v;k+=x) cn[k][i]|=(1<<j);
			a[i][j]=x;
		}
	}
	int cur=0,pre=1;
	dp[cur][sx-1]=1<<(sy-1);
	for(int i=1,nw=1;i<=m;i++,nw++){
		swap(cur,pre);
		for(int j=1;j<=bl;j++){
			if(i%j!=0) continue;
			for(int k=0;k<n;k++) cn[nw][k]|=p[j][k];
		}
		for(int j=0;j<n;j++){
			if(j>=1){
				dp[cur][j-1]|=dp[pre][j]<<2;
				dp[cur][j-1]|=dp[pre][j]>>2;
			}if(j>=2){
				dp[cur][j-2]|=dp[pre][j]<<1;
				dp[cur][j-2]|=dp[pre][j]>>1;
			}if(j<n-1){
				dp[cur][j+1]|=dp[pre][j]<<2;
				dp[cur][j+1]|=dp[pre][j]>>2;				
			}if(j<n-2){
				dp[cur][j+2]|=dp[pre][j]<<1;
				dp[cur][j+2]|=dp[pre][j]>>1;				
			}
		}
		for(int j=0;j<n;j++) dp[cur][j]&=cn[nw][j],dp[pre][j]=0;
		if(nw==v){
			for(int j=0;j<=v;j++) for(int k=0;k<n;k++) cn[j][k]=0;
			for(int l=0;l<n;l++){
				for(int j=0;j<n;j++){
					int x=a[l][j];
					if(x>bl) for(int k=(v/x+1)*x;k<=m;k+=x) cn[k-v][l]|=(1<<j);
				}
			}			
			nw=0;
		}
	}
	int tp=0;
	for(int i=0;i<n;i++)
		for(int j=0;j<n;j++)
			if((dp[cur][i]>>j)&1) s[++tp]={i+1,j+1};
	printf("%d\n",tp);
	sort(s+1,s+tp+1);
	for(int i=1;i<=tp;i++) printf("%d %d\n",s[i].fi,s[i].se);
	return 0;
}
```

---


# [HEOI2016/TJOI2016] 游戏

## 题目描述

在 2016 年，佳媛姐姐喜欢上了一款游戏，叫做泡泡堂。

简单的说，这个游戏就是在一张地图上放上若干个炸弹，看是否能炸到对手，或者躲开对手的炸弹。在玩游戏的过程中，小 H 想到了这样一个问题：当给定一张地图，在这张地图上最多能放上多少个炸弹能使得任意两个炸弹之间不会互相炸到。炸弹能炸到的范围是该炸弹所在的一行和一列，炸弹的威力可以穿透软石头，但是不能穿透硬石头。

给定一张 $ n \times m $ 的网格地图:其中 ``*`` 代表空地，炸弹的威力可以穿透，可以在空地上放置一枚炸弹。 ``x`` 代表软石头，炸弹的威力可以穿透，不能在此放置炸弹。``#`` 代表硬石头，炸弹的威力是不能穿透的，不能在此放置炸弹。例如：给出 $ 1 \times 4 $ 的网格地图 `` *xx*``，这个地图上最多只能放置一个炸弹。给出另一个$ 1 \times 4 $ 的网格地图 ``*x#*``，这个地图最多能放置两个炸弹。

现在小 H 任意给出一张 $ n \times m $ 的网格地图，问你最多能放置多少炸弹。

## 说明/提示

$1 \leq n,m \leq 50$

## 样例 #1

### 输入

```
4 4
#***
*#**
**#*
xxx#```

### 输出

```
5```

# 题解

## 作者：炎炎龙虾 (赞：46)

# [P2825][HEOI2016/TJOI2016]游戏

Algorithm: 匈牙利算法, 图论建模

Created: Aug 10, 2020 7:07 PM

Difficulty: 省选/NOI-

URL: https://www.luogu.com.cn/problem/P2825

画外音：在调试时我是这个表情： ????；AC了这题时我是这个表情： ????；看到这题的题解还没满时我是这个表情： ????

# 题目链接：

[[HEOI2016/TJOI2016]游戏](https://www.luogu.com.cn/problem/P2825)

[「TJOI / HEOI2016」游戏 - 题目 - LibreOJ](https://loj.ac/problem/2057)

# 题解：

在做这题前，你（不）需要先AC这题并且熟练掌握匈牙利算法求二分图的最大匹配：

[[ZJOI2007]矩阵游戏](https://www.luogu.com.cn/problem/P1129)

首先观察一下题目，若是把硬石子全部当成软石子，就可以将题意转换成：“每摆放一个炸弹，它所在的行和列都不再能摆放其它的棋子，其中本身就有一些点是不可以摆放炸弹的。”是不是很简单？将行看成集合 $S$，将列看成集合 $T$ ，那么能够摆放的炸弹的个数就是 $S$ 与 $T$ 的最大匹配（两个集合内部不会相交，众所周知，行与行不相交，列与列也不相交），这是一个经典的二分图最大匹配应用题。

加了硬石子，又怎么做？

我们可以从二分图的本质考虑起。二分图重在同一集合内部元素不相交，不同集合元素有相连边。那么此时，如果一行内存在一个硬石子，这一行就会被分成不相交的两部分。如果把这两部分都看成一个独立的行，此时，行与行仍然不相交，列与行仍然会相交，满足二分图的性质，那么，此方案可行。

拿样例举个例子吧：

```cpp
#***
*#**
**#*
xxx#
```

原来的矩阵长这样

```cpp
#111
2#22
33#3
xxx#
```

如果将硬石子看成软石子，我们会这样给每行中可以放炸弹的节点编号

```cpp
#111
2#33
44#5
xxx#
```

但是硬石子将每行划分成了多个单独的行，因此我们要将硬石子后的可放石子的节点所处的行加一。注意：这里的行已经不是原来意义上的行了，这里是被硬石子分割后抽象出来的单独的行

这样，我们就把行的编号处理完了，列的编号也同理。

直接上代码吧，这样方便理解，几个比较坑的点在注释里讲了：

```cpp
//File: P2825.cpp
//Author: yanyanlongxia
//Date: 2020/8/10
//
#include <bits/stdc++.h>
using namespace std;
int n,m,ntot,mtot,tot,head[3000],nxt[3000],ver[3000],row[60][60],col[60][60],match[3000],ans;
bool vis[3000];
void add(int x,int y)//链式前向星加边
{
    ver[++tot]=y;
    nxt[tot]=head[x];
    head[x]=tot;
}
bool find(int x)//匈牙利算法
{
    for(int i=head[x];i;i=nxt[i])
    {
        int y=ver[i];
        if(!vis[y])
        {
            vis[y]=true;
            if(!match[y] || find(match[y]))
            {
                match[y]=x;
                return true;
            }
        }
    }
    return false;
}
int main() {
    scanf("%d%d",&n,&m);
    char s[60][60];
    bool flag=1;//注意第一次需要单开一行
    pair<int,int>last;//与动态规划的思想相似，每个点所在的抽象出的行的编号都可以由上一个有编号的点转移过来
    for(int i=1;i<=n;i++)
    {
        scanf("%s",(s[i]+1));
        for(int j=1;j<=m;j++)
        {
            if(s[i][j]=='#')//下一次另开一行（抽象意义上的行）
            {
                flag=1;
                continue;
            }
            if(flag==0)//不需要加1
            {
                if(s[i][j]!='x')
                {
                    row[i][j]=row[last.first][last.second];//row数组的意义为该点所在的抽象的行的编号
                    last=make_pair(i,j);
                }
            } else
                if(s[i][j]!='x')
                {
                    row[i][j]=row[last.first][last.second]+1;
                    ntot++;
                    last=make_pair(i,j);
                    flag=0;//当前的加处理完毕
                }
        }
        flag=1;//换行一定要加一
    }
    flag=1;
    last=make_pair(0,0);//清零，赋初值
    for(int i=1;i<=m;i++)//列的处理，与行相似，但是i与j要取反
    {
        for(int j=1;j<=n;j++)
        {
            if(s[j][i]=='#')
            {
                flag=1;
                continue;
            }
            if(flag==0)
            {
                if(s[j][i]!='x')
                {
                    col[j][i]=col[last.second][last.first];//col数组与row数组的意义相似，是列的编号
                    last=make_pair(i,j);
                }
            } else
                if(s[j][i]!='x')
                {
                    col[j][i]=col[last.second][last.first]+1;
                    mtot++;
                    last=make_pair(i,j);
                    flag=0;
                }
        }
        flag=1;
    }
    for (int i = 1; i <= n; ++i)
        for (int j = 1; j <= m; ++j) {
            if (s[i][j]=='*')
                add(row[i][j],col[i][j]);//加边
        }
    for (int i = 1; i <= ntot; ++i) {
        memset(vis,0,sizeof(vis));
        if(find(i))
            ans++;//统计最大匹配
    }
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：xyz32768 (赞：29)

二分图匹配。

和$ZJOI2007$矩阵游戏那道题差不多。首先，提取出每一行里所有连续的不含#的极长非空子段，

举一个例子：\*xxxx##x\*x\*x，那么[\*xxxx]和[x\*x\*x]就是提取出的合法非空子段。

并把每一个子段抽象成一个节点，对每一列里也一样。

然后对于每一个可放炸弹的位置$(i,j)$，从$(i,j)$所在的**行内**合法子段对应的节点向$(i,j)$所在的**列内**合法子段对应的节点连一条**有向边**（注意，一定要连有向边）。

最后跑一遍二分图匹配，最大匹配数就是最后答案。

代码：

```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
inline int read() {
    int res = 0; bool bo = 0; char c;
    while (((c = getchar()) < '0' || c > '9') && c != '-');
    if (c == '-') bo = 1; else res = c - 48;
    while ((c = getchar()) >= '0' && c <= '9')
        res = (res << 3) + (res << 1) + (c - 48);
    return bo ? ~res + 1 : res;
}
inline char get() {
    char c; while ((c = getchar()) != '*' && c != 'x' && c != '#');
    return c;
}
const int N = 55, M = 2505;
int n, m, tot, ecnt, nxt[M], adj[M], go[M], my[M], row[N][N], col[N][N];
bool vis[M]; char a[N][N];
void add_edge(int u, int v) {
    nxt[++ecnt] = adj[u]; adj[u] = ecnt; go[ecnt] = v;
}
bool dfs(int u) {
    for (int e = adj[u], v; e; e = nxt[e])
        if (!vis[v = go[e]]) {
            vis[v] = 1;
            if (!my[v] || dfs(my[v])) {
                my[v] = u;
                return 1;
            }
        }
    return 0;
}
int solve() {
    int i, ans = 0;
    for (i = 1; i <= tot; i++) {
        memset(vis, 0, sizeof(vis));
        if (dfs(i)) ans++;
    }
    return ans;
}
int main() {
    int i, j; n = read(); m = read();
    for (i = 1; i <= n; i++) for (j = 1; j <= m; j++)
        a[i][j] = get();
    for (i = 1; i <= n; i++) for (j = 1; j <= m; j++) {
        if (a[i][j] == '#') continue;
        if (j == 1 || a[i][j - 1] == '#') tot++;
        row[i][j] = tot;
    }
    for (j = 1; j <= m; j++) for (i = 1; i <= n; i++) {
        if (a[i][j] == '#') continue;
        if (i == 1 || a[i - 1][j] == '#') tot++;
        col[i][j] = tot;
    }
    for (i = 1; i <= n; i++) for (j = 1; j <= m; j++) {
        if (a[i][j] != '*') continue;
        add_edge(row[i][j], col[i][j]);
    }
    printf("%d\n", solve());
    return 0;
}
```

---

## 作者：George1123 (赞：16)

**广告：[blog $\biguplus$](https://www.luogu.com.cn/blog/Wendigo/)**

[P2825 【\[HEOI2016/TJOI2016\]游戏】](https://www.luogu.com.cn/problem/P2825)

### 此题算法：网络最大流

**约束条件：**

先不考虑路障，转化已有约束条件：

$$

\begin{cases}
\text{炸一行一列}\\
\text{不能互炸}
\end{cases}\Rightarrow\begin{cases}
\text{同一行只能有一个炸弹......(1)}\\
\text{同一列只能有一个炸弹......(2)}
\end{cases}$$ 

由于**路障 #** 把一行一列分为了多段，所以一个炸弹并不能炸到一整行，所以：

$$
\begin{cases}
\text{炸行一段列一段}\\
\text{不能互炸}
\end{cases}\Rightarrow\begin{cases}
\text{同一行段只能有一个炸弹......(1)}\\
\text{同一列段只能有一个炸弹......(2)}
\end{cases}$$ 

**所以只需如下构造网络流模型：**

$S\xRightarrow{flow=1}\text{每个行段}$

$\text{每个列段}\xRightarrow{flow=1}T$

再对于每个空地 $sp$：

$\text{sp的行段}\xRightarrow{flow=1}\text{sp的列段}$

然后跑最大流就是最多能放的炸弹数。

## 以下是代码 $+$ 注释

```cpp
/******************
    . . 
  /\OwO/\
 /  ' '  \

Konny Wendigo
******************/
#include <bits/stdc++.h>
using namespace std;
#define lng long long
#define fo(i,a,b,c) for(int i=a;i<=b;i+=c)
#define al(i,h,x) for(int i=h[x];i;i=e[i].nex)
namespace rd{
	const int L=1<<16;
	char buf[L],*S,*T;
	inline char Gc_(){
		if(S==T){T=(S=buf)+fread(buf,1,L,stdin);
			if(S==T) return EOF;}
		return *S++;
	}
	inline char Gc(){return getchar();}
	char c;
	inline int d(){
		int f=1,x;
		for(c=Gc();c>'9'||c<'0';c=Gc())
			if(c=='-') f=-1;
		for(x=0;c>='0'&&c<='9';c=Gc())
			x=(x<<1)+(x<<3)+c-'0';
		return x*f;
	}
	inline lng lld(){
		lng f=1,x;
		for(c=Gc();c>'9'||c<'0';c=Gc())
			if(c=='-') f=-1;
		for(x=0;c>='0'&&c<='9';c=Gc())
			x=(x<<1)+(x<<3)+c-'0';
		return x*f;
	}
	inline double lf(){
		double f=1,x,y=0.1;
		for(c=Gc();c>'9'||c<'0';c=Gc())
			if(c=='-') f=-1;
		for(x=0;c>='0'&&c<='9';c=Gc())
			x=x*10+c-'0';
		if(c=='.') for(c=Gc();c>='0'&&c<='9';c=Gc())
			x=x+(c-'0')*y,y*=0.1;
		return x*f;
	}
}//快读
const int N=60;
const int V=3e3; //网络流图点边数估算很重要
const int M=1e4;
const int inf=1e9;
int n,m,cnth,cntk;
int mp[N][N],h[N][N],k[N][N];
int s,t,p,fans;
class edge{
public:
	int adj,nex,fw;
}e[M];
int g[V],top=1;
void add(int x,int y,int w){
	e[++top]=edge{y,g[x],w};
	g[x]=top;
}
void Add(int x,int y,int w){
	// printf("%d %d %d\n",x,y,w);
	add(x,y,w),add(y,x,0);
}
int dep[V],cur[V];
bool vis[V];
queue<int> q;
bool bfs(){
	fo(i,1,p,1) vis[i]=0,cur[i]=g[i];
	q.push(s),vis[s]=1,dep[s]=0;
	while(q.size()){
		int x=q.front();q.pop();
		al(i,g,x){
			int to=e[i].adj;
			if(!vis[to]&&e[i].fw){
				vis[to]=1;
				dep[to]=dep[x]+1;
				q.push(to);
			}
		}
	}
	return vis[t];
}
int dfs(int x,int F){
	if(x==t||!F) return F;
	int f,flow=0;
	al(i,cur,x){ cur[x]=i;
		int to=e[i].adj;
		if(dep[to]==dep[x]+1&&
		(f=dfs(to,min(F,e[i].fw)))>0){
			e[i].fw-=f,e[i^1].fw+=f;
			F-=f,flow+=f;
			if(!F) break;
		}
	}
	return flow;
}//模板
int main(){
	n=rd::d(),m=rd::d();
	char c=0;
	fo(i,1,n,1)fo(j,1,m,1){
		while(c!='#'&&c!='*'&&c!='x')c=rd::Gc();
		mp[i][j]=(c=='#')?2:(c=='x')?1:0,c=rd::Gc();
	}//读入图
	fo(i,1,n,1)fo(j,1,m,1){
		if(mp[i][j]==2) continue;
		if(j==1||mp[i][j-1]==2) ++cnth;//分裂行段
		h[i][j]=cnth;
	}
	fo(j,1,m,1)fo(i,1,n,1){
		if(mp[i][j]==2) continue;
		if(i==1||mp[i-1][j]==2) ++cntk;//分裂列段
		k[i][j]=cntk;
	}
	//这样分裂段可以减少无效段
	p=t=cnth+cntk+2,s=t-1;
	fo(i,1,cnth,1) Add(s,i,1);
	fo(i,1,cntk,1) Add(i+cnth,t,1);
	fo(i,1,n,1)fo(j,1,m,1)
		if(mp[i][j]==0) Add(h[i][j],cnth+k[i][j],1);
	while(bfs()) fans+=dfs(s,inf);
	//连边跑图
	printf("%d\n",fans);
	return 0;
}
```
**用 $\LaTeX$ 写题解不易，快点个赞吧。**

谢谢大家！！







---

## 作者：rediserver (赞：7)

# P2825 [HEOI2016/TJOI2016]游戏
[原题地址](https://www.luogu.org/problem/P2825)  
[Github题解](https://github.com/jerrykcode/luogu)

## 思路

### 二分图匹配

如果没有硬石头，那么只需将行看作是二分图的一边，列看作另一边，然后可以放置炸弹的地方，所在行向所在列连边即可。

本来一行只能放一颗炸弹，但硬石头的出现导致一行被隔开，所以在有硬石头的情况下，可以把一行看成多行。

### 即把行和列依据硬石头的位置分割成多行和多列

如题中示例

\#\*\*\*  
\*\#\*\*  
\*\*\#\*  
xxx\#

每个格子所在的行为:

\#000  
1\#11  
22\#2  
333\#

考虑到硬石头，则每个格子所在的"行"改为:

\#111  
2\#33  
44\#5  
666\#  
即原来第0行被硬石头分割成了第1行(为了编程方便，遇到硬石头就`行编号++`，所以这里编号为第1行，而不是第0行)  
原来第1行被硬石头分割成了第2行和第3行  
原来第2行被硬石头分割成了第4行和第5行  
原来第3行被硬石头分割成了第6行  
\#(硬石头)所在的格子不属于任一行

对列同样操作

初始每个格子所在列:

\#123  
0\#23  
01\#3  
012\#

重新编号后每个格子所在列:

\#246  
1\#46  
13\#6  
135\#  
即原来第0列被硬石头分割成了第1列  
原来第1列被硬石头分割成了第2列和第3列  
原来第2列被硬石头分割成了第4列和第5列  
原来第3列被硬石头分割成了第6列  
\#(硬石头)所在的格子不属于任一列  

代码中使用
```cpp
struct Grid {
	char c;
	uint16_t row;
	uint16_t col;
};
```
记录每个格子在`行和列被重新编号后的`的行和列

用Grid二维数组存储所有格子，输入时即可知道```grids[i][j].c```，

输入时用`n_rows`记录当前行数，初始为0，一行输入完毕时`n_rows++`，在输入中遇到'\#'也要`n_rows++`，
此时的`n_rows`表示的行数已经是根据硬石头重新编号后的行数了。输入时```grids[i][j].row = n_rows```即可。

之后`按列遍历`二维数组，使用`n_cols`记录当前列数，初始为0，一列遍历完毕时`n_cols++`，在遍历中遇到'\#'也要
`n_cols++`，此时的`n_cols`表示的列数已经是根据硬石头重新编号后的列数了。遍历时```girds[i][j].col = n_cols```即可。

之后再次遍历二维数组，`此时每个格子所在的行向所在的列连边即可构建二分图`。

注意这里二分图`左边顶点的数量是n_rows`，由于输入时最后一行结束后`n_rows++`，所以`n_rows`是`行重新编号后最大的行编号+1`，
`右边顶点数量是n_cols`，由于遍历时最后一列结束后`n_cols++`，所以`n_cols`是`列重新编号后最大的列编号+1`。

二分图匹配就不多说了，这里用的是匈牙利算法的BFS实现。为什么不用DFS递归实现啊，因为那样代码就太简单了QWQ

(逃

## 代码

```cpp
#include <cstdio>
#include <cstdlib>
#include <vector>
#include <queue>
#include "stdint.h"
#include <iostream>
using namespace std;

#define HARD '#'
#define SOFT 'x'
#define EMPTY '*'

//格子
struct Grid {
	char c;
	uint16_t row;
	uint16_t col;
};

typedef uint16_t vertex;
#define NOT_A_VERTEX 0xffff

size_t hungarian(vector<vertex> * graph, size_t left_num, size_t right_num) {
	//二分图匹配 匈牙利算法(BFS实现) 
	size_t result = 0;
	vertex * left_matching = new vertex[left_num];
	fill(left_matching, left_matching + left_num, NOT_A_VERTEX);
	vertex * right_matching = new vertex[right_num];
	fill(right_matching, right_matching + right_num, NOT_A_VERTEX);
	vertex * pre = new vertex[left_num];
	fill(pre, pre + left_num, NOT_A_VERTEX);
	bool * visited = new bool[right_num];
	queue<vertex> vq;
	vertex front_v, adj_v, from, to, tmp;
	for (vertex v = 0; v < left_num; v++) {
		fill(visited, visited + right_num, false);
		vq.push(v);
		while (!vq.empty()) {
			front_v = vq.front();
			vq.pop();
			for (auto it = graph[front_v].begin(); it != graph[front_v].end(); it++) {
				adj_v = *it;
				if (!visited[adj_v]) {
					visited[adj_v] = true;
					if (right_matching[adj_v] != NOT_A_VERTEX) {
						vq.push(right_matching[adj_v]);
						pre[right_matching[adj_v]] = front_v;
					}
					else {
						from = front_v;
						to = adj_v;
						while (from != NOT_A_VERTEX) {
							tmp = left_matching[from];
							left_matching[from] = to;
							right_matching[to] = from;
							from = pre[from];
							to = tmp;
						}
						while (!vq.empty()) vq.pop();
						goto NEXT;
					}
				}
			} //for auto
		} //while
	NEXT:
		if (left_matching[v] != NOT_A_VERTEX) result++;
	} //for (vertex v = 0; v < left_num; v++)
	free(left_matching);
	free(right_matching);
	free(pre);
	free(visited);
	queue<vertex>().swap(vq);
	return result;
}

int main() {
	int n, m;
	scanf("%d %d", &n, &m);
	Grid ** grids = new Grid*[n];
	size_t i, j;
	uint16_t n_rows = 0, n_cols = 0;
	for (i = 0; i < n; i++) {
		grids[i] = new Grid[m];
		for (j = 0; j < m; j++) {
			cin >> (grids[i][j].c); //输入该格的字符
			if (grids[i][j].c == HARD) 
				n_rows++; //若遇到硬石头，则该格本身不记录行数，而本行在硬石头之后剩下的格子记为下一行
			else grids[i][j].row = n_rows; //记录所在行
		}
		n_rows++; //进入下一行
	}
	for (j = 0; j < m; j++) {  //按列遍历
		for (i = 0; i < n; i++) {
			if (grids[i][j].c == HARD)
				n_cols++; //若遇到硬石头，则该格本身不记录列数，而本列在硬石头之后剩下的格子记为下一列
			else grids[i][j].col = n_cols; //记录所在列
		}
		n_cols++; //进入下一列
	}
	//建立二分图：以行作为左边顶点，列作为右边顶点
	vector<vertex> * graph = new vector<vertex>[n_rows]; //注意是n_rows不是n
	for (i = 0; i < n; i++) {
		for (j = 0; j < m; j++) 
			if (grids[i][j].c == EMPTY) graph[grids[i][j].row].push_back(grids[i][j].col);	 //所在行向所在列连边	
		free(grids[i]);
	}
	free(grids);
	printf("%u", hungarian(graph, n_rows, n_cols)); //输出二分图匹配结果
	for (i = 0; i < n_rows; i++)
		vector<vertex>().swap(graph[i]);
	return 0;
}
```

~END

---

## 作者：Orion545 (赞：4)

# 广告

[蒟蒻的blog](http://www.cnblogs.com/dedicatus545/p/8759898.html)

# 正文

看到棋盘摆放和棋子冲突，再加上这么小的数据范围，你能想到什么？

网络流棋盘模型啊！

就是 把源点连到每一行，每一列连到汇点，再在中间......

等等，这道题每行不一定全部冲突？？？

这倒是个问题，但是依旧难不倒网络流大法

我们考虑每一行中的一段“冲突区间”，就是两块硬石头中间的一段软石头和空地

例如一行\[##\*\*x\*\*#xx\*x##\*\]就包含三个冲突区间\[\*\*x\*\*\]\[xx\*x\]\[\*\]

那么显然每个冲突区间中只能摆放一个石子

同理，我们对于每一列也划分这样的区间

对于一个空地(i,j)，我们将它所处的行区间和所处的列区间连起来，我们就得到了一个二分图

那么此题的答案就是这个二分图的最大匹配

我们再把源点连到所有行区间、汇点连到所有列区间，

我们就得到了一个网络流模型，跑S-T最大流就是答案了

#Code：

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define ll long long
#define inf 1e9
using namespace std;
inline int read(){
    int re=0,flag=1;char ch=getchar();
    while(ch>'9'||ch<'0'){
        if(ch=='-') flag=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9') re=(re<<1)+(re<<3)+ch-'0',ch=getchar();
    return re*flag;
}
int n,m,cnt=-1,ans=0,first[10010],dep[10010],cur[10010],x[101][101]={0},bx[101][101],by[101][101]; 
struct edge{
    int to,next,w;
}a[500010];
inline void add(int u,int v,int w){
    a[++cnt]=(edge){v,first[u],w};first[u]=cnt;
    a[++cnt]=(edge){u,first[v],0};first[v]=cnt;
}
int q[10010];
bool bfs(int s,int t){
    int head=0,tail=1,i,u,v;
    for(i=s;i<=t;i++) dep[i]=-1,cur[i]=first[i];
    q[0]=s;dep[s]=0;
    while(head<tail){
        u=q[head++];
        for(i=first[u];~i;i=a[i].next){
            v=a[i].to;
            if(~dep[v]||!a[i].w) continue;
            dep[v]=dep[u]+1;q[tail++]=v;
        }
    }
    return ~dep[t];
}
int dfs(int u,int t,int limit){
    if(u==t||!limit) return limit;
    int i,v,f,flow=0;
    for(i=cur[u];~i;i=a[i].next){
        v=a[i].to;cur[u]=i;
        if(dep[v]==dep[u]+1&&(f=dfs(v,t,min(limit,a[i].w)))){
            a[i].w-=f;a[i^1].w+=f;
            limit-=f;flow+=f;
            if(!limit) return flow;
        }
    }
    return flow;
}
void dinic(int s,int t){
    while(bfs(s,t)) ans+=dfs(s,t,inf);
}
int main(){	
    std::ios::sync_with_stdio(false);
    memset(first,-1,sizeof(first));
    cin>>n>>m;int i,j;char s[100];
    for(i=1;i<=n;i++){
        cin>>s;
        for(j=1;j<=m;j++){
            if(s[j-1]=='x') x[i][j]=2;
            if(s[j-1]=='*') x[i][j]=1;
            if(s[j-1]=='#') x[i][j]=0;
        }
    }
    int tmp=0,tt;
    for(i=1;i<=n;i++){
        for(j=1;j<=m;j++){
            if(!x[i][j]) continue;
            if((j==1)||(!x[i][j-1])) add(0,++tmp,1);
            bx[i][j]=tmp;
        }
    }
    for(j=1;j<=m;j++){
        for(i=1;i<=n;i++){
            if(!x[i][j]) continue;
            if((i==1)||(!x[i-1][j])) add(++tmp,n*m-1,1);
            by[i][j]=tmp;
        }
    }
    for(i=1;i<=n;i++){
        for(j=1;j<=m;j++){
            if(x[i][j]==1) add(bx[i][j],by[i][j],1);
        }
    }
    dinic(0,n*m-1);
    cout<<ans<<endl;
}
```

---

## 作者：Little09 (赞：3)

这种题是经典的二分图套路题，做法也非常经典。

对于在棋盘上的和一行、一列有关的题目，应当把每行、每列作为二分图上的点跑最大匹配，就是把每行和每列匹配起来。

这道题存在“硬石头”的情况，我们应当换个角度。考虑“行段”和“列段”。一个行段即在同一行的连续的没有硬石头的段，列段同理。显然应当满足每个行段和列段最多放一个炸弹。

这时候考虑在一个点放置炸弹，会 **同时** 影响一个行段和一个列段。所以在行段与列段间连边跑二分图最大匹配就可以了。这里行段与列段的连边实质上表示的是在图中放炸弹的点。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,ans;
int h[10001],nxt[50001],t[50001],cnt,cnta,cntb;
bool visit[10001];
int v[10001];
int ta[51][51],tb[51][51];
char a[51][51];
void col(int flag,int x,int l,int r)
{
	if (l>r) return;
	if (flag==0)
	{
		cnta++;
		for (int i=l;i<=r;i++) ta[x][i]=cnta;
	}
	else
	{
		cntb++;
		for (int i=l;i<=r;i++) tb[i][x]=cntb;
	}
}
bool dfs(int x)
{
	for (int i=h[x];i;i=nxt[i])
	{
		if (!visit[t[i]])
		{
			visit[t[i]]=1;
			if (v[t[i]]==0||dfs(v[t[i]]))
			{
				v[t[i]]=x;
				return 1;
			}
		}
	}
	return 0;
}
void add(int x,int y)
{
	t[++cnt]=y;
	nxt[cnt]=h[x];
	h[x]=cnt;
}
int main()
{
	cin >> n >> m;
	for (int i=1;i<=n;i++)
	{
		for (int j=1;j<=m;j++) 
		{
			cin >> a[i][j];
		}
	}
	for (int i=1;i<=n;i++)
	{
		int last=1;
		for (int j=1;j<=m;j++)
		{
			if (a[i][j]=='#') 
			{
				col(0,i,last,j-1);
				last=j+1;
			}
		}
		col(0,i,last,m);
	}
	for (int j=1;j<=m;j++)
	{
		int last=1;
		for (int i=1;i<=n;i++)
		{
			if (a[i][j]=='#') 
			{
				col(1,j,last,i-1);
				last=i+1;
			}
		}
		col(1,j,last,n);
	}
	for (int i=1;i<=n;i++)
	{
		for (int j=1;j<=n;j++)
		{
			if (a[i][j]=='#'||a[i][j]=='x') continue;
			add(ta[i][j],tb[i][j]);
		}
	}
	for (int i=1;i<=cnta;i++)
	{
		memset(visit,0,sizeof(visit));
		if (dfs(i)) ans++;
	}
	cout << ans;
    return 0;
}
```

可能由于评测机变快的缘故，这份用 cin 读入又没开 O2 的代码成了目前本题的最优解。


---

## 作者：陈刀仔 (赞：3)

# 二分图匹配

这道题用二分图做小有难度，但这种棋盘问题做多了有点套路

先来看另一道相似的题

**[acwing373车的放置](https://www.acwing.com/problem/content/375/)**

**题面**

给定一个N行M列的棋盘，已知某些格子禁止放置。

问棋盘上最多能放多少个不能互相攻击的車。

車放在格子里，攻击范围与中国象棋的“車”一致。

**输入格式**

第一行包含三个整数N,M,T，其中T表示禁止放置的格子的数量。

接下来T行每行包含两个整数x和y，表示位于第x行第y列的格子禁止放置，行列数从1开始。

**输出格式**

输出一个整数，表示结果。

数据范围
1≤N,M≤200

**输入样例：**

8 8 0

**输出样例：**

8

**solution**

老师讲二分图匹配时，有跟我们强调这样一点

**判断一道题目可不可以用二分图匹配做，需要关注“0”的条件和“1”的条件**

什么意思？我大概这么理解

指有**两种有对应关系的量**， **他们都只能取一次**。对应在这道题，就是，我们取一行，一列，来确定一个车的位置，取完之后，这一行和这一列，就都不能再取了，这就翻译了“车不能在同一行或同一列”的条件

当我们找到了这两种具有对应关系的量，就可以尝试用他们建立起一个二分图模型

在这道题中，有了上面的分析，不难想到，**建立一个二分图，把列与行分成两个集合，将那些能放车的点的行，列坐标，在左右两边连起来**

此时再用匈牙利求解，就很显然了

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;
const int maxn=205;
int n,m,ans,t;
int cnt,head[maxn],to[maxn*maxn],nex[maxn*maxn];
int match[maxn*maxn],p[maxn*maxn];
int blo[maxn][maxn];
void add(int x,int y)
{
	to[++cnt]=y;
	nex[cnt]=head[x];
	head[x]=cnt;
}
int dfs(int u)
{
	for(int i=head[u];i;i=nex[i])
	{
		int v=to[i];
		if(p[v]==1)continue;
		p[v]=1;
		if(!match[v]||dfs(match[v]))
		{
			match[v]=u;
			return 1;
		}
	}
	return 0;
}
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>m>>t;
	while(t--)
	{
		int x,y;
		cin>>x>>y;
		blo[x][y]=blo[x][y]=1;
	}
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			if(!blo[i][j])add(i,n+j);
	for(int i=1;i<=n;i++)
	{
		memset(p,0,sizeof(p));
		ans+=dfs(i);
	}
	cout<<ans;
}
```
再回到这道题，好像除了多了硬石头，就没有任何区别了

如何解决呢？？？

我们的硬石头打断了原来正常可以炸得精光的行和列，那我们就干脆**把这些分裂出来的极长行，列拆出来，存进结构体数组里，并重新编号，在枚举拆出来的任意行，列，将能香蕉的组都在二分图中建个边**

然后就做van了：）

具体康代码

```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn=55;
int n,m,ans,tot1,tot2;
char ch[maxn][maxn];
string str;
struct node
{
	int d,x,y;
}a1[maxn*maxn],a2[maxn*maxn];
int cnt,head[maxn*maxn],to[maxn*maxn*4],nex[maxn*maxn*4];
int p[maxn*maxn],match[maxn*maxn];
bool vis[maxn][maxn];
inline int read()
{
	int s=0,w=1;
	char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')w=-1;ch=getchar();}
	while(isdigit(ch)){s=s*10+ch-'0';ch=getchar();}
	return s*w;
}
void add(int x,int y)
{
	to[++cnt]=y;
	nex[cnt]=head[x];
	head[x]=cnt;
}
bool dfs(int u)
{
	for(int i=head[u];i;i=nex[i])
	{
		int v=to[i];
		if(p[v])continue;
		p[v]=1;
		if(!match[v]||dfs(match[v])==true)
		{
			match[v]=u;
			return true;
		}
	}
	return false;
}
int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		cin>>str;
		for(int j=1;j<=m;j++)
			ch[i][j]=str[j-1];
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			if(vis[i][j])continue;
			if(ch[i][j]!='*')continue;
			int ex1=i,ex2=i;
			int ey1=j,ey2=j;
			while(ex1>1&&ch[ex1-1][j]!='#')
				ex1--;
			while(ex2<n&&ch[ex2+1][j]!='#')
				ex2++;
			for(int k=ex1;k<=ex2;k++)
				vis[k][j]=1;
			a1[++tot1]=node{j,ex1,ex2};
		}
	}
	memset(vis,0,sizeof(vis));
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			if(vis[i][j])continue;
			if(ch[i][j]!='*')continue;
			int ex1=i,ex2=i;
			int ey1=j,ey2=j;
			while(ey1>1&&ch[i][ey1-1]!='#')
				ey1--;
			while(ey2<m&&ch[i][ey2+1]!='#')
				ey2++;
			for(int k=ey1;k<=ey2;k++)
				vis[i][k]=1;
			a2[++tot2]=node{i,ey1,ey2};
		}
	}
/*	cout<<"()()()()()()()()()lie"<<endl;
	for(int i=1;i<=tot1;i++)
		cout<<a1[i].d<<' '<<a1[i].x<<' '<<a1[i].y<<endl;
	cout<<"()()()()()()()()()hang"<<endl;
	for(int i=1;i<=tot2;i++)
		cout<<a2[i].d<<' '<<a2[i].x<<' '<<a2[i].y<<endl;*/
	for(int i=1;i<=tot1;i++)
		for(int j=1;j<=tot2;j++)
			if(a1[i].x<=a2[j].d&&a1[i].y>=a2[j].d&&a2[j].x<=a1[i].d&&a2[j].y>=a1[i].d)
			{
				if(ch[a2[j].d][a1[i].d]=='x')
				{
				//	cout<<"!!!"<<endl;
					continue;
				}
				add(i,j+tot1);
			//	cout<<"** "<<i<<' '<<j<<endl;
			}
	for(int i=1;i<=tot1;i++)
	{
		memset(p,0,sizeof(p));
		ans+=dfs(i);
	}
	cout<<ans<<endl;
	return 0;
}
/*
input: 
5 5
**#*x
*#xx*
****#
**#*x
x****

output:
7
*/
```


---

## 作者：shadowice1984 (赞：3)

好吧这是网络流的另一种建图方式

网络流是可以描述互斥关系的

这张网格图可以抽象成一系列行块和列块

列块和行块就是说,这一个横行块或纵列块里至多放一个炸弹

另外显而易见的,我们发现选中一个点的时候会同时选中两个块

那么也就是说这张图满足两个限制条件

1.每个点最多被选中一次

2.某些点对之间有必选关系

这两个限制下,最大化选的点对数,就是二分图最大匹配的模型了

然后建图的时候,把行块和列块染上色,每个点对应了一条边,跑二分图最大匹配,直接网络流即可

上代码~

```C
#include<cstdio>
#include<algorithm>
#include<queue>
using namespace std;
char map[60][60];int n;int m;
int rcnt=1;int lcnt=1;
int row[60][60];int line[60][60];
struct data{int v;int nxt;int cot;}edge[20010];
int alist[5010];int cnt=1;int s;int t;
inline void add(int u,int v,int cot)
{
	edge[++cnt].v=v;edge[cnt].nxt=alist[u];alist[u]=cnt;edge[cnt].cot=cot;
	edge[++cnt].v=u;edge[cnt].nxt=alist[v];alist[v]=cnt;edge[cnt].cot=0;
}
int dep[5010];int flow;bool book[5010];queue <int> q;
inline void bfs()//网络流板子啦啦啦~ 
{
	for(int i=1;i<=rcnt+lcnt+2;i++){dep[i]=0;book[i]=false;}
	dep[s]=1;q.push(s);book[s]=true;
	while(!q.empty())
	{
		int now=q.front();q.pop();
		int nxt=alist[now];
		while(nxt)
		{
			int v=edge[nxt].v;
			int cot=edge[nxt].cot;
			if(cot!=0&&book[v]==false)
			{dep[v]=dep[now]+1;book[v]=true;q.push(v);}
			nxt=edge[nxt].nxt;
		}
	}
}
inline int dfs(int x,int lim)//不会板子的话还是先问度娘好咯 
{
	if(x==t)return lim;int nxt=alist[x];
	while(nxt)
	{
		int v=edge[nxt].v;int cot=edge[nxt].cot;
		if(dep[v]==dep[x]+1&&cot!=0)
		{
			int del=dfs(v,min(lim,cot));
			if(del!=0)
			{edge[nxt].cot-=del;edge[nxt^1].cot+=del;return del;}
		}nxt=edge[nxt].nxt;
	}return 0;
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++){scanf("%s",map[i]+1);}
	for(int i=0;i<=n;i++){map[i][0]='#';}//这里先设置好墙 
	for(int i=1;i<=m;i++){map[0][i]='#';}
	for(int i=1;i<=n;i++)//乱七八糟的n^2染色法 
	{
		bool flag=false;
		for(int j=1;j<=m;j++)
		{
			if(map[i][j]=='*'){row[i][j]=rcnt;flag=true;}
			if(map[i][j]=='#'&&map[i][j-1]!='#'){rcnt++;flag=false;}
		}if(flag)rcnt++;//这里是保证每个编号都能用到 
	}
	for(int j=1;j<=m;j++)
	{
		bool flag=false;
		for(int i=1;i<=n;i++)
		{
			if(map[i][j]=='*'){line[i][j]=lcnt;flag=true;}
			if(map[i][j]=='#'&&map[i-1][j]!='#'){lcnt++;flag=false;}
		}if(flag)lcnt++;
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			if(map[i][j]=='*')//每个空地都是一条边 
			{add(row[i][j],rcnt+line[i][j],1);}
		}
	}
	s=rcnt+lcnt+1;t=rcnt+lcnt+2;
	for(int i=1;i<=rcnt;i++){add(s,i,1);}//愉快的跑最大匹配 
	for(int i=1;i<=lcnt;i++){add(rcnt+i,t,1);}
	bfs();
	while(book[t])
	{
		while(1)
		{
			int p=dfs(s,0x3f3f3f);if(p==0)break;flow+=p;
		}bfs();
	}
	printf("%d\n",flow);
	return 0;//拜拜程序~ 
}
```



---

## 作者：SmallTownKid (赞：2)

二分图好题，我将详细的解释如何想到使用二分图到如何把此题转化为普遍的二分图
最大匹配求法。层层推进，搭建思维体系。

匈牙利算法求二分图最大匹配是个类似于协商的过程，这里就不展开说算法流程了。
首先考虑如果没有硬石头，只有软石头这题该怎么做。

二分图匹配模型有两个要素：

$0.$ 节点能分成独立的两个集合，每个集合内部有0条边。

$1.$ 每个节点只能与 $1$ 条匹配边相连。

我们把这两个要素简称为 $0$ 要素和 $1$ 要素。

我们可以把横坐标看成一个顶点集，纵坐标看成一个顶点集，我们把一个点的坐标看
做横坐标与纵坐标的一个连边，所有的边都是横坐标与纵坐标之间的，顶点集内没有
边。满足 $0$ 要素。一个点的横坐标和纵坐标之间有匹配边就意味着选中这个点，
同一行/同一列不能出现两个炸弹，也就是说不能出现一个横坐标对应两个纵坐标或一
个纵坐标对应两个横坐标，满足 $1$ 要素。所以这个题可以转化为求二分图的最大
匹配。软石头所在的点横坐标和纵坐标之间不连边就行，意味着不能选这个点。有连
边意味着可以选这个点，但匹配边才是真正选的了点。其他就是模板。

这个题有了硬石头，怎么处理呢？

**建立二分图**是本题的核心，图建好了，剩下的也都是模板。

考虑我们之前说的 $0$ 要素和 $1$ 要素，由于这里出现了硬石头，可能会把某一行
分成若干个部分，最简单的情况就是两部分，那如果我们还是按照之前的建图方式，
还满足 $0$ 要素和 $1$ 要素吗？只有满足 $0$ 要素和 $1$ 要素我们才能转化为
二分图匹配问题。显然，要素 $1$ 是不满足的，因为有了硬石头阻挡在一行的中
间，我们在两边可以各放一个炸弹。这样一个横坐标可以匹配两个纵坐标了。但这显
然不符合我们二分图求最大匹配的前提。其实简单来说，就是两个点横坐标和纵坐标
其中有一个相同的，那么这两个点就不能同时选。必须横纵坐标都不相同才能同时
选，按原始的建图方式违背了题意。那我们怎么把它转化呢？可以考虑染色法，以#为分界线染色，类似于tarjan缩点。把一段缩成一个点。这样，给每一段赋予
新的横坐标和纵坐标（详见代码）后，就满足了要素 $1$ 。这一段请务必自己画图理解。

```
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
int n,m;
struct node{
	int nxt,to;
}edge[3600];
int head[3600],vis[3600],match[3600];
int x1[60][60],y1[60][60];//记录每个新点的新的横纵坐标，其实严格意义上不是横纵，就是我们重新定义的。 
char a[60][60];
int ans,idx,tot;
void add(int u,int v)
{
	edge[++idx].nxt=head[u];
	edge[idx].to=v;
	head[u]=idx;
}
int dfs(int x)
{
	for(int i=head[x];i;i=edge[i].nxt)
	{
		int v=edge[i].to;
		if(!vis[v])
		{
			vis[v]=1;
			if(!match[v]||dfs(match[v]))
			{
				match[v]=x;
				return 1;
			}
		}
	}
	return 0;
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			scanf(" %c",&a[i][j]);
		}
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			if(a[i][j]=='#')
			continue;
			if(j==1||a[i][j-1]=='#') 
			tot++;
			x1[i][j]=tot;
		}
	}
	for(int j=1;j<=m;j++)
	{
		for(int i=1;i<=n;i++)
		{
			if(a[i][j]=='#')
			continue;
			if(i==1||a[i-1][j]=='#') 
			tot++;
			y1[i][j]=tot;
		}
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			if(a[i][j]!='*')
			continue;
			add(x1[i][j],y1[i][j]);
		}
	}
	for(int i=1;i<=tot;i++)
	{
		memset(vis,0,sizeof(vis));
		ans+=dfs(i);
	}
	cout<<ans;
	return 0;
}

---

## 作者：Mortidesperatslav (赞：2)

首先我们考虑没有硬石头的情况。

因为一行只能放一个炸弹，一列也只能放一个炸弹，这和二分图极为相似，我们可以把行和列作为左右节点，建立二分图，进行最大匹配。这是二分图的基本模型。

二分图的建立方法是，把能放炸弹的节点行列进行连边，这样因为二分图匹配的性质，满足每行每列只能放一个。

但是这题加入了硬石头的限制，不那么容易放。其实做法很简单，我们可以根据硬石头的分隔进行离散化。考虑在原来拆分的基础上，把硬石头和硬石头之间分成一行，或者把硬石头和边界之间分成一行。

我们先处理出每个格子属于分隔后的第几“列”，再边处理“行”边进行二分图的建边，最后跑一遍匈牙利就解决了。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n, m, N, M, q, a[100005], vis[100005], lcnt = 1, ccnt = 1, ans;
char mp[55][55];
map<pair<int, int>, int> rw;
vector<int> G[100005];
bool dfs(int u, int t){//匈牙利算法
	if (vis[u] == t)
		return 0;
	vis[u] = t;
	for (auto &v : G[u])
		if (!a[v] || dfs(a[v], t)){
			a[v] = u;
			return 1;
		}
	return 0;
}
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	cin >> N >> M;
	for (int i = 1; i <= N; i++)
		for (int j = 1; j <= M; j++)
			cin >> mp[i][j];
	for (int j = 1; j <= M; j++){//注意把 N 和 M 反过来
		for (int i = 1; i <= N; i++){
			if (mp[i][j] == '*')//能放
				rw[make_pair(i, j)] = ccnt;//记录这个格子属于第几“列”
			else if (mp[i][j] == '#')
				ccnt++;//遇到硬石头，新开一列
		}
		ccnt++;//遇到边界，新开一列
	}
	for (int i = 1; i <= N; i++){
		for (int j = 1; j <= M; j++){//行同理
			if (mp[i][j] == '*')
				G[lcnt].push_back(rw[make_pair(i, j)]);
			else if (mp[i][j] == '#')
				lcnt++;
		}
		lcnt++;
	}
	for (int i = 1; i < lcnt; i++)//进行匹配
		if (dfs(i, i))
			ans++;
	cout << ans;
}
```

---

## 作者：Mr_Wolfram (赞：1)

[蒟蒻的博客](http://www.cnblogs.com/Mr-WolframsMgcBox/)

##二分图匹配的匈牙利算法

这道题，如果没有硬石头的限制，那么就与[ZJOI 2007矩阵游戏](https://www.luogu.org/problemnew/show/1129)完全一样，但是如果有了硬石头的限制，我们就不能将整行整列作为元素建图，我们可以以硬石头为边界，将每一行、每一列分成若干段建图，然后跑二分图匹配即可。



```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;
int init(){
    int rv=0,fh=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-') fh=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        rv=(rv<<1)+(rv<<3)+c-'0';
        c=getchar();
    }
    return rv*fh;
}
int m,n,tot=1,tag1[55][55],tag2[55][55],g[2505][1000],match[10505];
char dt[55][55];
bool f[2505];
bool hungarian(int u){
    for(int i=1;i<=g[u][0];i++){
        int v=g[u][i];
        if(!f[v]){
            f[v]=1;
            if(!match[v]||hungarian(match[v])){
                match[v]=u;
                return 1;
            }
        }
    }
    return 0;
}
int main(){
    n=init();m=init();
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            scanf(" %c ",&dt[i][j]);
        }
    }
    for(int i=1;i<=n;i++){
        int j=1;
        while(j<=m){
            if(dt[i][j]=='#') {if(j!=1)  tot++;}
            else tag1[i][j]=tot;
            j++;
        }
        tot++;
    }
    int ma=tot-1;
    for(int j=1;j<=m;j++){
        int i=1;
        while(i<=n){
            if(dt[i][j]=='#') {if(i!=-1) tot++;}
            else tag2[i][j]=tot;
            i++;
        }
        tot++;
    }
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            if(dt[i][j]=='*'){
                int a=tag1[i][j],b=tag2[i][j];
                g[a][++g[a][0]]=b;
            }
        }
    }
    int ans=0;
    for(int i=1;i<=ma;i++){
        memset(f,0,sizeof(f));
        if(hungarian(i)) ans++;
    }
    cout<<ans<<endl;
    return 0;
}
```

---

## 作者：misaka0111 (赞：1)

思路同下，用的二分图最大匹配，代码实现用的邻接矩阵，更简洁一点

```cpp
#include<iostream>
#include<algorithm>
#include<cstring>
using namespace std;
int n,m,cnt1,cnt2;
char map[60][60];
int G[2505][2505],row[60][60],col[60][60];
int vis[2505],match[2505];
bool dfs(int u)
{
    for(int v=1;v<=cnt2;v++)
    {
        if(G[u][v]&&!vis[v])
        {
            vis[v]=1;
            if(!match[v]||dfs(match[v]))
            {
                match[v]=u;
                return true;
            }
        }
    }
    return false;
}
int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            cin>>map[i][j];
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
        {
            if(j==1||map[i][j-1]=='#')
                cnt1++;
            row[i][j]=cnt1;
        }
    for(int i=1;i<=m;i++)
        for(int j=1;j<=n;j++)
        {
            if(j==1||map[j-1][i]=='#')
                cnt2++;
            col[j][i]=cnt2;
        }
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            if(map[i][j]=='*')
                G[row[i][j]][col[i][j]]=1;
    int ans=0;
    for(int i=1;i<=cnt1;i++)
    {
        memset(vis,0,sizeof(vis));
        if(dfs(i))
            ans++;
    }
    cout<<ans<<endl;
    return 0;
}
```

---

## 作者：hehelego (赞：0)

最大独立集?看一下数据范围$O(3^{\frac{V}{3}})$,或者$O(V2^{\frac{V}{2}})$的一般图最大独立集算法都是不可能过的.  

-----

~~作为弱智选手,遇到这种二维网格上的最优化问题,肯定先黑白染色一发(bushi),然后钦定它是二分图写dinic求最大流~~  


### insight
对于横向/纵向的\[#???#\]这样的$1\times k,k\times 1$的部分,只能放一个(两端要么是#,要么是边界,内部只允许\*和x)  

### sol
我们考虑一个横向的,极大的不含#的$1\times k$矩形,如果在其中的某个位置$i$选择放炸弹,那么$i$所在的纵向的,极大不含#的矩形中是不能放炸弹的.  

我们可以这样想,对于所有横向,纵向的极大不含#的区间,分别记为集合$A,B$.放一个炸弹,就是选一个位置$(i,j)$,满足以下条件.

- $(i,j)$对应一个*
- A中存在一个包含$(i,j)$的横向框框.
- B中存在一个包含$(i,j)$的纵向框框.

考虑一个合法的方案,在$(x_1,y_1),(x_2,y_2)\dots (x_k,y_k)$放置了炸弹.  
每个炸弹,分别在$A,B$中选取了$a_i,b_j$.那么任意一个$a_i$,只能出现一次,任意一个$b_j$只能出现一次.这非常像一个二分图匹配的合法方案.  

我们考虑把A中所有元素$a_1,a_2\dots $,放在左侧;B中所有元素$b_1,b_2\dots $,放在右侧.  
对于$a_i\cap b_j=(x,y)$且(x,y)是\*的,我们连$(a_i,b_j)$.那么所有合法炸弹放置方式与二分图合法匹配方案,一一对应.  
从另一个角度来看,我们选一个横向/纵向的格子,就是选一个爆炸范围,这样选出来的一定是不冲突的.  
于是,我们求这个二分图的最大匹配即可.  

### code

```
#include <bits/stdc++.h>
const int INF=int(1e9);
namespace Net{
	const int N=100000+10;
	struct E{ int v,w;
		E(int a,int b):v(a),w(b){}
	}; std::vector<E> es;
	std::vector<int> g[N];
	void link(int a,int b,int c){
		g[a].push_back(es.size());
		es.push_back(E(b,c));
		g[b].push_back(es.size());
		es.push_back(E(a,0));
	}
	
	int S,T,vcnt;
	int q[N],ql,qr,cur[N],dis[N];
	int bfs(){
		for(int i=0;i<=vcnt;i++) cur[i]=dis[i]=0;
		dis[q[ql=0]=S]=1; qr=1; while(ql<qr){
			int u=q[ql++]; for(int i=0;i<g[u].size();i++){
				int j=g[u][i],v=es[j].v,w=es[j].w;
				if(w>0&&dis[v]==0) dis[q[qr++]=v]=dis[u]+1;
			}
		}
		return dis[T]>0;
	}
	int dfs(int u,int in){
		if(u==T||in==0) return in;
		int flow=0;
		for(int &i=cur[u];i<g[u].size();i++){
			int j=g[u][i],v=es[j].v,w=es[j].w;
			if(w>0&&dis[v]==dis[u]+1){
				int f=dfs(v,std::min(in,w));
				in-=f; flow+=f;
				es[j].w-=f; es[j^1].w+=f;
				if(in==0) break;
			}
		}
		if(in) dis[u]=-N;
		return flow;
	}
	int dinic(){int f=0; while(bfs())f+=dfs(S,INF); return f;}
}
const int N=50+3;
int n,m; char map[N][N];
std::vector<int> row,col;
std::vector<int> at[2][N][N];
int main(){
	std::cin>>n>>m;
	for(int i=1;i<=n;i++) std::cin>>(map[i]+1);

	int tmp=0;
	for(int i=1;i<=n;i++){ //提取出每一行中,横向的最大不含#的区间.
		int l=1,r=1;
		while(l<=m){ int cs=0;
			while(r<=m&&map[i][r]!='#') cs+=('*'==map[i][r++]);
			if(cs>0){ tmp++;
				for(int j=l;j<r;j++) at[0][i][j].push_back(tmp);
				row.push_back(tmp);
			}
			while(r<=m&&map[i][r]=='#') r++; l=r;
		}
	}
	for(int i=1;i<=m;i++){ // 这代码对称性很好...类似上面,这里是提取纵向极大不含#区间的.
		int l=1,r=1;
		while(l<=n){ int cs=0;
			while(r<=n&&map[r][i]!='#') cs+=('*'==map[r++][i]);
			if(cs>0){ tmp++;
				for(int j=l;j<r;j++) at[1][j][i].push_back(tmp);
				col.push_back(tmp);
			}
			while(r<=n&&map[r][i]=='#') r++; l=r;
		}
	}
	using Net::S; using Net::T; using Net::link;
	S=0; T=Net::vcnt=++tmp;
	for(int i=0;i<row.size();i++) link(S,row[i],1);
	for(int i=0;i<col.size();i++) link(col[i],T,1);

// 枚举满足map(i,j)='*'的(i,j),我们连出边来.
// 这里扯一下边的容量的事情,前面已经说过,这个图上的匹配,都是合法方案,而保证匹配合法,我们其实只需要限制(S->ai),(bj->T)的边就行了,它是保证每个点只出现一次的.
	for(int i=1;i<=n;i++) for(int j=1;j<=m;j++) if(map[i][j]=='*'){
		for(int x=0;x<at[0][i][j].size();x++) for(int y=0;y<at[1][i][j].size();y++)
			link(at[0][i][j][x],at[1][i][j][y],INF);
	}
	std::cout<<Net::dinic()<<std::endl;
	return 0;
}
```


---

## 作者：AntaresQAQ (赞：0)

题目描述中，"#"是可以挡住炸弹爆炸范围的。

那么，我们不妨对地图以"#"来分割地图的横行纵列。

简单来说，就是将地图字符串上横纵以"#"拆分若干子串，然后将每个子串看做一个点。

显然，炸弹只能放置在"\*"上面，而一旦放置一个炸弹，必定在其四周无"#"阻挡的串上面不得再放置炸弹。

那么，这就变成了一个二分图匹配的模型了，以源点向每个横行的合法子串连有向边，然后再以每个纵列子串向汇点连有向边。

之后，对于每个横行子串上课可以放置的位置，向每一个纵行子串上面可以放置的位置连有向边。注意是可以放置的位置，子串里面还包括有"x"，这里不能放置炸弹，一定不能连边。

跑网络流，源点到汇点最大流，同时也是二分图最大匹配。

```cpp
#include<bits/stdc++.h>
using namespace std;

const int maxn=5010;
const int inf=0x7fffffff;

typedef struct EdgeNode//前向星存边
{
    int to,flow;
    EdgeNode *next,*turn;
}*Edge;

Edge head[maxn],cur[maxn];
int s,t,n,m,cnt;//cnt为子串编号
int Lv[maxn];
char graph[60][60];//地图
int x[60][60],y[60][60];//用于存储子串的编号

void add(int u,int v,int w)
{
    Edge node1=new EdgeNode,node2=new EdgeNode;
    node1->to=v,node2->to=u;
    node1->flow=w,node2->flow=0;       
    node1->turn=node2,node2->turn=node1;
    node1->next=head[u],node2->next=head[v];
    head[u]=node1,head[v]=node2;
}

//以下网络流的板子
bool bfs()
{
    queue<int> que;
    memset(Lv,-1,sizeof Lv);
    que.push(s);
    Lv[s]=0;
    while(!que.empty())
    {
        int u=que.front();
        que.pop();
        for(Edge node=head[u];node;node=node->next)
        {
            int v=node->to;
            if(node->flow&&!~Lv[v])
            {
                Lv[v]=Lv[u]+1;
                que.push(v);
            }
        }
    }
    return ~Lv[t];
}

int dfs(int pos,int flow)
{
    if(pos==t)
        return flow;
    int sum=0;
    for(Edge node=cur[pos];node;node=node->next)
    {
        int v=node->to;
        if(Lv[v]==Lv[pos]+1&&node->flow)
        {
            int fl=dfs(v,min(flow-sum,node->flow));
            node->flow-=fl,node->turn->flow+=fl,sum+=fl;
            if(node->flow)//弧优化
                cur[pos]=node;
            if(sum==flow)
                break;
        }
    }
    return sum;
}

int dinic()
{
    int flow=0;
    while(bfs())
    {
        memcpy(cur,head,sizeof(head));
        flow+=dfs(s,inf);
    }
    return flow;
}

int main()
{
    scanf("%d%d",&n,&m);
    s=0,t=maxn-1;//源点汇点
    for(int i=1;i<=n;i++)
    	scanf("%s",graph[i]+1); 
    for(int i=1;i<=n;i++)//枚举横行纵列
        for(int j=1;j<=m;j++)
            if(graph[i][j]!='#')//以"#"分割当然不包括"#"区域
            {
                if(j==1||graph[i][j-1]=='#')//以"#"分割，并分配一个新的编号给当前子串
                    add(s,++cnt,1);//源点向横行当前编号子串连边
                x[i][j]=cnt;
            }
    for(int i=1;i<=m;i++)
        for(int j=1;j<=n;j++)
            if(graph[j][i]!='#')
            {
                if(j==1||graph[j-1][i]=='#')//同理
                    add(++cnt,t,1);//汇点向当前编号的纵行连边
                y[j][i]=cnt;
            }
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            if(graph[i][j]=='*')//注意，只有"*"处可以放置炸弹
                add(x[i][j],y[i][j],1);
    printf("%d\n",dinic());//跑网络流求出二分图最大匹配
    return 0;
}
```

---

## 作者：lwhllw (赞：0)

楼下的神犇讲的很好，补充一点，以每行/每列连通块为点，边实质上就是其交点。我们在找最大匹配时，选取的二分图里的边其实就是对应原图的点，那么显然交点是软石头的时候是不能连边的(不能放炮)，献上丑陋的pascal代码。






```cpp
const maxn=2500;
type link=^node;
     node=record
       data:longint;
       next:link;
     end;
var i,j,k,l,m,n,ans,totx,toty:longint;
    maps,pic:array[1..50,1..50]of longint;
    y:array[1..maxn]of longint;
    v:array[1..maxn]of boolean;
    a:array[1..maxn]of link;
procedure adds(x,y:longint);
var s:link;
begin
    new(s);s^.data:=y;s^.next:=a[x];
    a[x]:=s;
end;
procedure init;
var i,j,k:longint;
    ch:char;
begin
    fillchar(maps,sizeof(maps),0);
    fillchar(pic,sizeof(pic),0);
    fillchar(y,sizeof(y),0);
    totx:=0;toty:=0;
    readln(n,m);
    for i:=1 to n do
    begin
      for j:=1 to m do
      begin
        read(ch);
        if ch='#' then maps[i,j]:=-1;
        if ch='x' then pic[i,j]:=1;
      end;
      readln;
    end;
end;
procedure previous;
var i,j,k,head,tail:longint;
begin
    for i:=1 to m do
    begin
      head:=1;tail:=1;
      while tail<=n do
        if(maps[tail,i]>=0)then
        begin
          while(maps[tail,i]>=0)and(tail<=n)do inc(tail);
          inc(totx);for j:=head to tail-1 do maps[j,i]:=totx;
          head:=tail;
        end
        else
        begin
          inc(head);
          inc(tail);
        end;
    end;
    for i:=1 to n do
    begin
      head:=1;tail:=1;
      while tail<=m do
        if(maps[i,tail]>=0)then
        begin
          while(maps[i,tail]>=0)and(tail<=m)do inc(tail);
          inc(toty);
          for j:=head to tail-1 do
            if(pic[i,j]=0)then adds(maps[i,j],toty);
          head:=tail;
        end
        else
        begin
          inc(head);
          inc(tail);
        end;
    end;
end;
function find(i:longint):boolean;
var s:link;
begin
    s:=a[i];
    while s<>nil do
    begin
      if(v[s^.data])then
      begin
        v[s^.data]:=false;
        if(y[s^.data]=0)or(find(y[s^.data]))then
        begin
          y[s^.data]:=i;
          exit(true);
        end;
      end;
      s:=s^.next;
    end;
    exit(false);
end;
procedure work;
var i,j:longint;
begin
    previous;ans:=0;
    for i:=1 to totx do
    begin
      fillchar(v,sizeof(v),true);
      if(find(i))then inc(ans);
    end;
    writeln(ans);
end;
begin
    init;
    work;
end.

```

---

## 作者：MloVtry (赞：0)

思路同下...这里贴一下网络流的程序...

如果能帮到练习网络流的人就好了呢.....



```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<queue>
#define inf 1<<30
#define R register
#define N 30200
using namespace std;
char map[60][60];
int n,m;
int itx[60][60],ity[60][60],have[N];
int sum=1;
int s=1,t;
int head[N],to[N],next[N],cup[N];
int mflow,tot=1;
void buidit(int u,int v,int c)
{
    next[++tot]=head[u];
    head[u]=tot;
    cup[tot]=c;
    to[tot]=v;
}
queue<int> q;
int vis[N],itc[N],use[N];
bool bfs()
{
    memset(vis,0,sizeof(vis));
    memset(itc,0,sizeof(itc));
    itc[s]=1;
    vis[s]=1;
    q.push(s);
    while(!q.empty())
    {
        int now=q.front();
        q.pop();
        for(int i=head[now];i;i=next[i])
        {
            int j=to[i];
            if(cup[i]>0&&!vis[j])
            {
                vis[j]=1;
                itc[j]=itc[now]+1;
                q.push(j);
            }
        }
    }
    return vis[t];
}
int didit(int now,int want)
{
    if(now==t||want==0) {return want;}
    R int f,iget=0;
    for(int i=use[now];i;i=next[i])
    {
        R int j=to[i];
        if(itc[j]==itc[now]+1)
        {
            f=didit(j,min(want,cup[i]));
            if(f==0) continue;
            iget+=f;
            want-=f;
            cup[i]-=f;
            cup[i^1]+=f;
            use[now]=i;
        }
    }
   return iget;
}
void max_flow()
{
    while(bfs())
    {
        for(int i=1;i<=t;++i)
        {
            use[i]=head[i];
       }
        mflow+=didit(s,inf);
    }
}
string aaa;
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;++i)
    {
        cin>>aaa;
        for(int j=0;j<m;++j)
        {
            map[i][j+1]=aaa[j];
        }
    }
    for(int i=1;i<=n;++i)
    {
        R int fl=1;
        for(int j=1;j<=m;++j)
        {
            if(map[i][j]!='#'&&fl)
            {
                itx[i][j]=++sum;
                fl=0;
            }
            else if(map[i][j]!='#') itx[i][j]=sum;
            else fl=1;
        }
    }
    for(int i=2;i<=sum;++i)
    {
        buidit(s,i,1);
        buidit(i,s,0);
     }
     int sassy=sum;
    for(int j=1;j<=m;++j)
    {
        R int fl=1;
        for(int i=1;i<=n;++i)
        {
            if(map[i][j]!='#'&&fl)
            {
                ity[i][j]=++sum;
                fl=0;
            }
            else if(map[i][j]!='#') ity[i][j]=sum;
            else fl=1;
        }
    }
    t=++sum;
    for(int i=sassy+1;i<=sum;++i)
    {
        buidit(t,i,0);
        buidit(i,t,1);
    }
    for(int i=1;i<=n;++i)
    {
        for(int j=1;j<=m;++j)
        {
            if(map[i][j]=='#'||map[i][j]=='x') continue;
            buidit(itx[i][j],ity[i][j],1);
            buidit(ity[i][j],itx[i][j],0);
        }
    }
    max_flow();
    printf("%d",mflow);
    return 0;
}
```
/\*
4 4
#***
\*#**
**#\*
xxx#
今天也依然没有捞到岛风47厌战呢...

\*/

---


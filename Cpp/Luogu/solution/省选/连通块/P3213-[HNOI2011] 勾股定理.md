# [HNOI2011] 勾股定理

## 题目描述

沫沫最近在研究勾股定理。对于两个正整数 $A$ 与 $B$，若存在正整数 $C$ 使得 $A^2+B^2=C^2$，且 $A$ 与 $B$ 互质，则称 $(A,B)$ 为一个互质勾股数对。


有一天，沫沫得到了 $N$ 根木棍，其长度都是正整数，她准备从中挑选出若干根木棍来玩拼图游戏，为了使拼出的图案有凌乱美，她希望挑选出的木棍中任意两根的长度均不是互质勾股数对。现在，沫沫想知道有多少种满足要求的挑选木棍的方案。由于答案可能很大，你只要输出答案对 $10^9+7$ 取模的结果。

## 说明/提示

样例解释：$(5,12)$ 与 $(12,35)$ 是互质勾股数对，故满足要求的挑选木棍的方案有 $8$ 种，即：

$\{5\},\{12\},\{35\},\{5\},\{5,35\},\{35,5\},\{5,5\},\{5,35,5\}$。

## 样例 #1

### 输入

```
4				
5 12 35 5	
```

### 输出

```
8```

# 题解

## 作者：bzy369258147 (赞：13)

本文旨在探讨关于该题网上流传的唯一一个玄学题解的正确性证明，以及关于该题图的性质的分析.

实名反对楼上的题解关于HNOI2011出题人的评价(大雾

以及这题是一道类似 HNOI2018毒瘤 的 好(毒瘤) 题.

也是一个本质上的 提交答案题.

观察题意不难发现这题是给定图求独立集的个数.

然而对一般图而言这是NP的,所以我们猜想这是一个特殊图.

那它是不是:

链? (X)

树? (X)

基环树? (X)

仙人掌? (?)

二分图? (X)

正则图? (X)

弦图? (X)

那是不是出题人就是毒瘤，就是拿一个NP问题当普通题出出来? (X)

通过观察，我们发现这个图，它，至少，是，一个，平面图...

然而并没有什么X用23333

这是我在求出(1 - 2e5)所有边再拓扑排序以后剩下的图的样子:

![]( https://cdn.luogu.com.cn/upload/pic/54010.png )

把里边相交的环展到大环外面就是一个平面图了.

这是我在求出(2e4 - 1e6)所有边再拓扑排序以后剩下的图的样子:

![]( https://cdn.luogu.com.cn/upload/pic/54011.png )

我们发现它甚至是一个沙漠图(仙人掌森林).

也就是说出题人故意安排的部分分其实是有意义的。

具体分3档

30pt(1) : 树形DP

70pt(1 + 3) : 仙人掌DP

100pt(1 + 2 + 3) : 正解.

通过观察发现，原图所有的联通子图中最多比树多3条边，所以这题直接变成了毒瘤的弱化版，所以所谓的玄学做法(毒瘤的部分分做法)自然能过啦.

代码如下:

```cpp
#include<bits/stdc++.h>
using namespace std;

const int mod = 1e9 + 7;
int PW2[1000005];

const int maxN = 1e6;

int n;
int num[1000005];

vector<int> to[1000005];
bool vis[1000005];
bool ins[1000005];
int  sat[1000005];

vector<int> QE;

void dfs_init( int x, int f ) {
    vis[x] = true;
    for( auto N : to[x] ) if( N ^ f ) {
        if( !vis[N] ) dfs_init( N, x );
        else {
            if( !ins[x] ) QE.push_back( x );
            if( !ins[N] ) QE.push_back( N );
            ins[x] = ins[N] = true;
        }
    }
}

int dp[1000005][2];
int des[1000005];
int pnt = 0;

int dfs_dp( int x ) {
    dp[x][0] = 1; dp[x][1] = PW2[ num[x] ] - 1; des[x] = pnt;
    for( auto N : to[x] ) if( des[N] ^ pnt ) {
        dp[x][0] = 1ll * dp[x][0] * dfs_dp( N ) % mod;
        dp[x][1] = 1ll * dp[x][1] * dp[N][0] % mod;
    }
    if( sat[x] ==  1 ) dp[x][0] = 0;
    if( sat[x] == -1 ) dp[x][1] = 0;
    return ( dp[x][0] + dp[x][1] ) % mod;
}

bool check() {
    for( auto P : QE ) for( auto N : to[P] ) 
      { if( sat[P] == 1 and sat[N] == 1 ) return false; }
    return true;
}

int query(int x) {
    QE.clear(); dfs_init( x, x );
    int ans = 0;
    int len = 1 << QE.size();
    for( int i = 0; i < len; i ++ ) {
        for( int j = 0; j < QE.size(); j ++ ) 
          { sat[ QE[j] ] = (i & (1 << j)) ? 1 : -1; }
        if( check() ) pnt ++, ( ans += dfs_dp( x ) ) %= mod;
    }
    for( int i = 0; i < QE.size(); i ++ ) sat[ QE[i] ] = 0;
    return ans;
}

int main(){
    int n; cin >> n; PW2[0] = 1;
    for(int i = 1;i <= n;i ++) PW2[i] = PW2[i - 1] * 2 % mod;
    for(int i = 1;i <= n;i ++) { int x; cin >> x; num[x] ++; }
    for(int i = 1;i * i <= maxN;i ++) for(int j = i + 1;2 * i * j <= maxN;j ++) {
        if( j * j > 2 * maxN ) break;
        int x = j * j - i * i, y = 2 * i * j;
        if( x > maxN or y > maxN ) continue;
        if( !num[x] or !num[y] or __gcd( x, y ) != 1 ) continue;
        to[x].push_back(y); to[y].push_back(x);
    }
    int ans = 1;
    for(int i = 1;i <= maxN;i ++) if( num[i] and !vis[i] ) 
      { ans = 1ll * ans * query(i) % mod; }
    cout << ( ans - 1 + mod ) % mod;
    return 0;
}
```

拓扑排序的代码:

```cpp
#include<bits/stdc++.h>
using namespace std;

int N = 200000;
int M = 0;
int deg[1000005];
vector<int> to[1000005];

int main(){

    for(int i = 2;i <= N;i ++) {
        for(int j = 1;j <= i;j ++) {
            if( 1ll * 2 * i * j > N ) break;
            if( 1ll * i * i - 1ll * j * j > N ) continue;
            if( __gcd( i, j ) > 1 ) continue;
            long long u = i * i - j * j;
            long long v = 2 * i * j;
            if( __gcd( u, v ) > 1 ) continue;
            if( u > v ) swap( u, v );
            if( u < M or v < M ) continue;
            deg[u] ++; deg[v] ++; to[u].push_back(v); to[v].push_back(u);
            //printf( "%d %d\n", u, v );
        }
    }
    queue<int> Q;
    for(int i = 1;i <= N;i ++) if( deg[i] == 1 ) Q.push(i);
    while( !Q.empty() ) {
        int x = Q.front(); Q.pop();
        for( auto N : to[x] ) {
            deg[N] --;
            if( deg[N] == 1 ) Q.push( N );
        }
    }
    for(int i = 1;i <= N;i ++) if( deg[i] > 1 )for( auto E : to[i] ) if( deg[E] > 1 ) printf( "%d %d\n", i, E );
    //for(int i = 1;i <= N;i ++) if( deg[i] > 1 ) printf( "%d %d\n", i, deg[i] );
    return 0;
}
```


---

## 作者：斯德哥尔摩 (赞：5)

[P3213 [HNOI2011]勾股定理](https://www.luogu.org/problemnew/show/P3213)

这是一道神题。。。

我一开始把题目看错了，我以为是在$n$根木棒中选两个$i,j$满足$gcd(i,j)==1$，并且存在$k$使得$i^2+j^2==k^2$。

~~我说这不是网络流的沙茶题嘛？~~

然后数据范围$n<=10^6$。。。

怎么这么大？就算建图建完了，$Dinic$好像也会$TLE$，预流推进可能都会$TLE$。。。

然后回头看题——$MD$，我就是个$zz$。。。

选取若干个。。。

于是这题就比较好做了。

这里有一篇$YDC$巨佬的博客讲的比我好：[链接](http://ydcydcy1.blog.163.com/blog/static/216089040201311512248331/)

首先要预处理出$10^6$以内的勾股数对。

根据初中的经验，我们有：$$(m^2-n^2)^2+(2mn)^2=(m^2+n^2)^2$$

这个应该都会证吧，全部拆开就好了。

于是一对互质勾股数$(a,b)$与一对$(i,j)$应满足$$a=j^2-i^2,b=2\times i\times j,c=j^2+i^2,gcd(i,j)==1,i<j,\text{i和j不同奇偶}$$

我们枚举$i,j$，由于$i\times j<=\frac{10000000}{2}$，并且$gcd$的复杂度上限是$\log_2n$，一般不会达到，所以就是$500000\times \log_2 500000<500000\times 20=10^7$的复杂度。

我们对于互质勾股数$(a,b)$，在$a,b$间连边。

我们假设他们构成了一片森林，那么题目变成在森林中选点且互不相邻了，跟[P1352 没有上司的舞会](https://www.luogu.org/problemnew/show/P1352)很像，经典树形$DP$。

~~但是自从我发现这个不是基环无向树就不想做了。~~

设$dp[i][0]$表示在$i$这棵子树上不选$i$的方案数，$dp[i][1]$表示在$i$这颗子树上选$i$的方案数。

状态转移长这样：
$$dp[i][0]=(dp[v_1][0]+F[v_1][1])\times (dp[v_2][0]+dp[v_2][1])\times ...$$
$$dp[i][1]=(2^{num[i]}-1)\times dp[v_1][0]\times dp[v_2][0]\times ...$$

$num[i]$表示$i$出现了几次。

我们发现我们建的图将构成一片森林。

假设森林里每颗树的根是$rt_1,rt_2,...rt_k$，那么答案就是：
$$(dp[rt_1][0]+dp[rt_1][1])\times(dp[rt_2][0]+dp[rt_2][1])\times ...\text{之后再减1，即去掉空集}$$

$BUT$！这么做是$30$分。

我当时懵的一批啊。。。感觉这方法行得通吗？？？

然后我发现一个智障一样的问题——图并不一定是树，可能有环。。。

~~靠！这个坑。。。~~

接下来就开始乱搞了。。。

对于一条回边$(u,v)$，就像$tarjan$求强连通中的$dfn[v]<dfn[u]$一样，我们把$u,v$标记一下加入点集$stack$，把这条边删掉。

之后$2^{|stack|}$枚举每个点的选择情况，在合法的情况下套用树形$DP$。

这个时候由于是同一棵树，所以用加法原理而不是乘法原理，即每次统计的答案用个变量累加，最后乘以这个变量。

这题就做完了

吗？

没有！

但是因为数据水的原因，出题人强行把$NP$的题出成了普通题。。。

所以这题就当过了吧。。。

~~HN的出题人真是不负责任。。。~~

附代码：
```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<vector>
#define MAXN 1000010
#define MOD 1000000007
using namespace std;
vector<int> stack;//点集，为了方便用了vector
int n,c=1,d=1,T;
int head[MAXN],deep[MAXN],vis[MAXN],num[MAXN];
long long bit[MAXN],dp[MAXN][2];
bool used[MAXN],choose[MAXN];
struct Edge{
    int next,to;
}a[MAXN];
inline int read(){
	int date=0,w=1;char c=0;
	while(c<'0'||c>'9'){if(c=='-')w=-1;c=getchar();}
	while(c>='0'&&c<='9'){date=date*10+c-'0';c=getchar();}
	return date*w;
}
inline long long sqr(long long x){return x*x;}
int gcd(int x,int y){
    if(!y)return x;
    return gcd(y,x%y);
}
inline void add(int x,int y){
    a[c].to=y;a[c].next=head[x];head[x]=c++;
    a[c].to=x;a[c].next=head[y];head[y]=c++;
}
void build(){//预处理出互质勾股数对与2的幂
    int m=MAXN-10;
    for(int i=1;i<=m/2;i++)
    for(int j=i+1;j<=m/2/i&&sqr(j)-sqr(i)<=m;j++)
    if(((i&1)!=(j&1))&&gcd(i,j)==1)add(2LL*i*j,sqr(j)-sqr(i));
    bit[0]=1;
    for(int i=1;i<=m;i++)bit[i]=(bit[i-1]<<1)%MOD;
}
inline void insert(int x){//插入点集
    if(!used[x]){
        used[x]=true;
        stack.push_back(x);
    }
}
bool check(int u,int f){
    vis[u]=T;
    for(int i=head[u];i;i=a[i].next){
        int v=a[i].to;
        if(v==f||!num[v])continue;
        if(choose[u]&&choose[v])return false;
        if(vis[v]!=T)if(!check(v,u))return false;
    }
    return true;
}
void dfs1(int x,int f){
    deep[x]=d++;//deep[i]即为dfn[i]，但是习惯这样没法改了。。。
    for(int i=head[x];i;i=a[i].next){
        int v=a[i].to;
        if(!num[v]||v==f)continue;
        if(!deep[v])dfs1(v,x);
        else if(deep[v]<deep[x]){insert(x);insert(v);}
    }
}
void dfs2(int x,int f){//开始树形DP
    vis[x]=T;
    dp[x][0]=1;
    dp[x][1]=(bit[num[x]]-1+MOD)%MOD;
    if(used[x]){
        if(choose[x])dp[x][0]=0;
        else dp[x][1]=0;
    }
    for(int i=head[x];i;i=a[i].next){
        int v=a[i].to;
        if(v==f||!num[v]||vis[v]==T)continue;
        if(vis[v]!=T)dfs2(v,x);
        dp[x][0]=dp[x][0]*(dp[v][0]+dp[v][1])%MOD;
        dp[x][1]=dp[x][1]*dp[v][0]%MOD;
    }
}
void dfs3(int i,int m,int x,long long &ans){//暴力枚举状态
    if(i==m){
        T++;
        if(check(x,-1)){
            T++;
            dfs2(x,-1);
            ans=(ans+dp[x][0]+dp[x][1])%MOD;
        }
        return;
    }
    choose[stack[i]]=false;
    dfs3(i+1,m,x,ans);
    choose[stack[i]]=true;
    dfs3(i+1,m,x,ans);
}
long long solve(int x){//对每一个数处理
    stack.clear();
    dfs1(x,-1);
    int m=stack.size();
    long long ans=0;
    dfs3(0,m,x,ans);
    return ans;
}
void work(){
    long long ans=1;
    for(int i=1;i<=MAXN-10;i++)if(num[i]&&!deep[i])ans=ans*solve(i)%MOD;
    printf("%lld\n",(ans-1+MOD)%MOD);//不要忘了-1。。。
}
void init(){
    n=read();
    for(int i=1;i<=n;i++){
        int x=read();
        num[x]++;
    }
}
int main(){
    build();
    init();
    work();
    return 0;
}

```

---

## 作者：Gmt丶FFF (赞：1)

据说是NP问题。

很明显我们要先预处理出来勾股数对。

但由于数过于大，所以常规的枚举是解决不了问题的。

但也貌似没有什么很好的办法可以立马找到一个数的勾股数对。

所以只能缩减枚举范围。

已知：
$$\begin{aligned}

(x-y)^2+4xy&=(x+y)^2\\

(x^2-y^2)^2+4x^2y^2&=(x^2+y^2)^2\\

(x^2-y^2)^2+(2xy)^2&=(x^2+y^2)^2

\end{aligned}$$

所以可以把 $A$ 看成 $(x-y)$，$B$ 看成 $2xy$，然后枚举 $i,j$，代表式子中的 $x,y$，即可缩小枚举范围。因为要满足 $x^2-y^2\le10^6\hspace{0.3cm}2xy\le10^6$。枚举复杂度约为 $O(n)$。

然后对于每一对勾股数对，连接一条边，即可得到一个森林。

这样就可以进行树形dp了。

设 $dp_{i,(0,1)}$ 代表选与不选数 $i$ 的方案数。

如果不选，方案即为自己儿子所有方案的乘积

$$dp_{i,0}=\prod_{(i,j)} dp_{j,0}+dp_{j,1}$$

若选，则自己儿子不能选，乘上自己儿子不选的方案数与选这个数的子集数（不算空集）即可。

$$dp_{i,1}=2^{num_i}\prod_{(i,j)}dp_{j,0}$$

然后对每棵树树形dp即可。

复杂度 $O(n)$。

但是交上去不对，那是因为在这之前的所有假设都是基于建出来的是棵树。

那接下来就麻烦了。

但是通过楼上大佬的模拟，发现在本题的数据范围内建出来的仅仅是棵仙人掌，这样NP问题就可以转换为普通问题了，那么我们就可以进行仙人掌dp。

首先利用Tarjan思想，对于每个整棵仙人掌遍历一遍，建立时间戳，寻找环。

找到环以后，我们考虑断掉环上的一条边，并记录下来边两边的点。

然后对于每一棵仙人掌，对记录下来的点的状态进行搜索，然后在搜索终端判断两边的点是否同为 $1$。如果满足都不同为 $1$，进行一次树形dp。

那么这棵仙人掌所带来的方案数即为 $dp_{i,0}+dp_{i,1}$。

最后把所有仙人掌所得来的答案相乘，减去全部为空集情况，即减去一，就可得到答案。

```cpp
#include<iostream>
#include<cstdio>
#include<vector>
#define int long long
using namespace std;
const int N=1e6+5;
const int mod=1e9+7;
int n,num[N],p[N],vis[N],ins[N],dfn[N],cnt,dp[N][2],chose[N],col[N],color;
vector<int>a[N],t;
int gcd(int x,int y)
{
	if(y==0)return x;
	return gcd(y,x%y);
}
void insert(int x)//记录断掉的边两边的点。
{
	if(!vis[x])
	{
		vis[x]=1;
		t.push_back(x);
	}
}
void build(int x,int fa)//找环。
{
	dfn[x]=++cnt;
	int len=a[x].size();
	for(int i=0;i<len;i++)
	{
		if(a[x][i]==fa)continue;
		if(!dfn[a[x][i]])build(a[x][i],x);
		else if(dfn[a[x][i]]<dfn[x])insert(a[x][i]),insert(x);
	}
}
bool check(int x,int fa)//判断断掉的边的两点是否符合条件
{
	col[x]=color;
	int len=a[x].size();
	for(int i=0;i<len;i++)
	{
		if(a[x][i]==fa)continue;
		if(chose[x]&&chose[a[x][i]])return false;
		if(col[a[x][i]]!=color&&!check(a[x][i],x))return false;
	}
	return true;
}
void get_ans(int x,int fa)//树形dp。
{
	col[x]=color;
	int len=a[x].size();
	dp[x][0]=1;
	dp[x][1]=p[num[x]]-1;
	if(vis[x])
	{
		if(chose[x])dp[x][0]=0;
		else dp[x][1]=0;
	}
	for(int i=0;i<len;i++)
	{
		if(a[x][i]==fa||col[a[x][i]]==color)continue;
		if(col[a[x][i]]!=color)get_ans(a[x][i],x);
		dp[x][1]*=(dp[a[x][i]][0]);
		dp[x][1]%=mod;
		dp[x][0]*=(dp[a[x][i]][0]+dp[a[x][i]][1]);
		dp[x][0]%=mod;
	}
}
int dfs(int x,int step)//搜索。
{
	if(step==t.size())
	{
		color++;
		if(check(x,0))
		{
			color++;
			get_ans(x,0);
			return dp[x][0]+dp[x][1];
		}
		return 0;
	}
	chose[t[step]]=0;
	int sum=0;
	sum+=dfs(x,step+1);
	chose[t[step]]=1;
	sum+=dfs(x,step+1);
	return sum%mod;
}
int solve(int x)
{
	t.clear();
	build(x,0);
	int sum=dfs(x,0);
	return sum;
}
signed main()
{
	scanf("%lld",&n);
	for(int i=1,x;i<=n;i++)scanf("%lld",&x),num[x]++;
	p[0]=1;
	for(int i=1;i<=(N-5);i++)p[i]=p[i-1]*2,p[i]%=mod;
   //以下为预处理。
	for(int i=1;i<=(N-5)/2;i++)
	{
		for(int j=i+1;2*i*j<=(N-5)&&j*j-i*i<=(N-5);j++)
		{
			if(((i&1)^(j&1))&&gcd(i,j)==1)
			{
				int u=j*j-i*i,v=2*i*j;
				if(!num[u]||!num[v])continue;
				a[u].push_back(v);
				a[v].push_back(u);
			}
		}
	}
	int ans=1;
	for(int i=1;i<=N-5;i++)if(num[i]&&!col[i])ans=ans*solve(i)%mod;
	printf("%lld",ans-1);
	return 0;
}
```

---

## 作者：Add_Catalyst (赞：0)

# P3213 [HNOI2011] 勾股定理 题解

------

## 知识点

二进制枚举，树形计数 DP。

## 分析

### 连边

对于 $A^2+B^2=C^2$，有 $A=m^2-n^2,B=2mn,C=m^2+n^2$。

于是我们枚举 $m,n$，则可以在 $O(\sqrt{H}\ln{H})$ 的调和级数复杂度内求出所有互质勾股数对。

### 建模

考虑连边，发现会构成很多连通块，这个问题就变成了多个连通块的独立集计数，这是个 NP 问题。

取出其中任意一个连通块，设其边数为 $m$，点数为 $n$，$m-n+1$ 都会是一个很小的数，于是我们可以先在每个联通块中建出深搜树，二进制枚举其中的非树边上的点的状态，现在变成了一个树上独立集计数问题。

## 实现

### 法 1

我们直接枚举每个非树边相关的点的状态，时间复杂度为 $O(\sum_{(m,n)} 4^{m-n+1}(n+m))$。

### 法 2

想要进一步优化吗？我们枚举每一条非树边的两端点的状态，发现并不能都选，所以从 $4$ 个状态减少到了 $3$ 个，时间复杂度为 $O(\sum_{(m,n)} 3^{m-n+1}(n+m))$。

### 法 3

假设选为 $1$，不选为 $0$，那么非树边的两端点状态可以为 $(0,0),(0,1),(1,0)$，其中 $(0,0),(0,1)$ 我们可以在同一次 DP 里一起解决，枚举数变为 $2$，时间复杂度为 $O(\sum_{(m,n)} 2^{m-n+1}(n+m))$。

## 代码

```cpp
#define Plus_Cat "gougu"
#include<bits/stdc++.h>
#define INF 0x3f3f3f3f
#define ll long long
#define RCL(a,b,c,d) memset(a,b,sizeof(c)*(d))
#define FOR(i,a,b) for(int i(a);i<=(int)(b);++i)
#define DOR(i,a,b) for(int i(a);i>=(int)(b);--i)
#define tomax(a,...) ((a)=max({(a),__VA_ARGS__}))
#define tomin(a,...) ((a)=min({(a),__VA_ARGS__}))
#define EDGE(g,i,x,y) for(int i=(g).h[(x)],y=(g)[(i)].v;~i;y=(g)[(i=(g)[i].nxt)>0?i:0].v)
#define main Main();signed main(){ios::sync_with_stdio(0);cin.tie(0),cout.tie(0);return Main();}signed Main
using namespace std;
constexpr int N(1e6+10);

namespace IOEcat {
	//Fast IO...
} using namespace IOEcat;

namespace Modular {
	//Modular...
} using namespace Modular;

bool mark[N][2];
int n,m,ans,tot,tim;
int a[N],dep[N],des[N];
int f[N][2];
vector<int> g[N];
struct edge { int u,v; } e[10];

int gcd(int a,int b) { return !b?a:gcd(b,a%b); }

void dfs(int u,int fa) {
	dep[u]=dep[fa]+1;
	for(int v:g[u])if(v^fa) {
		if(dep[v]) {
			if(dep[v]<dep[u])e[++tot]= {v,u};
			continue;
		}
		dfs(v,u);
	}
}

void DP(int u,int fa) {
	des[u]=tim,f[u][0]=!mark[u][1],f[u][1]=(!mark[u][0]?a[u]:0);
	for(int v:g[u])if(des[v]!=tim)DP(v,u),tomul(f[u][0],add(f[v][0],f[v][1])),tomul(f[u][1],f[v][0]);
}

void Mark(const int c,const int &rt,int &res) {
	if(c>tot)return ++tim,DP(rt,0),toadd(res,f[rt][0],f[rt][1]),void();
	const int &u(e[c].u),&v(e[c].v);
	const bool mu1(mark[u][1]),mv0(mark[v][0]),mu0(mark[u][0]);
	if(!mark[u][1])mark[u][0]=1,Mark(c+1,rt,res),mark[u][0]=mu0;
	if(!mark[u][0]&&!mark[v][1])mark[u][1]=mark[v][0]=1,Mark(c+1,rt,res),mark[u][1]=mu1,mark[v][0]=mv0;
}

signed main() {
#ifdef Plus_Cat
	freopen(Plus_Cat ".in","r",stdin),freopen(Plus_Cat ".out","w",stdout);
#endif
	/*DE("Input");*/
	I(n);
	FOR(i,1,n) {
		int h;
		I(h),++a[h],tomax(m,h);
	}
	FOR(i,1,m)if(a[i])a[i]=add(Pow(2,a[i]),Mod-1);
	/*DE("Build");*/
	for(int i(1); i*i<=m; ++i)for(int j(i+1); 2*i*j<=m&&j*j-i*i<=m; ++j) {
		int x(j*j-i*i),y(2*i*j);
		if(!a[x]||!a[y]||gcd(x,y)!=1)continue;
		g[x].push_back(y),g[y].push_back(x);
	}
	/*DE("Solve");*/
	ans=1;
	FOR(rt,1,m)if(a[rt]&&!dep[rt]) {
		int res(0);
		tot=0,tim=0,dfs(rt,0),Mark(1,rt,res),tomul(ans,res);
		if(tot)DE(rt,res);
	}
	/*DE("Output");*/
	O(add(ans,Mod-1),'\n');
	return 0;
}
```

------

---

## 作者：Soroak (赞：0)

# 其实就是树形DP+DFS！！！
##### 注意数据范围。。。（不然会。。。你懂）
详细见标程

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#define MAXM 400000
#define MAXH 1000000
#define MAXN 1000010
#define MOD 1000000007
using namespace std;
typedef long long LL;
LL Two[MAXN]= {1},F[MAXN][2],ans=1;
bool use[MAXN],must[MAXN],mark[MAXN],out[MAXM];
int cnt[MAXN],digit[MAXN],n,point[MAXN],s,wait[MAXN],father[MAXN],edge[MAXN];
int tot=1,to[MAXM],next[MAXM],start[MAXN];
void make(int a,int b) {
	tot++,to[tot]=b,next[tot]=start[a],start[a]=tot;
}
int gcd(int a,int b) {
	return a%b?gcd(b,a%b):b;
}
void ptm() {
	for(LL i=2; (i<<1)<=MAXH; i++)
		for(LL j=1; j*i*2<=MAXH&&j<i; j++)
			if((i&1)!=(j&1)&&gcd(i,j)==1&&i*i-j*j<=MAXH) {
				int a=i*i-j*j,b=2*i*j;
				make(a,b),make(b,a);
			}
}
void Read(int &digit) {
	digit=0;
	char c;
	for(c=getchar(); c<'0'||c>'9'; c=getchar());
	for(; c>='0'&&c<='9'; digit=digit*10+c-'0',c=getchar());
}
void read() {
	Read(n);
	for(int i=1; i<=n; i++) {
		Two[i]=Two[i-1]*2%MOD;
		Read(digit[i]);
		cnt[digit[i]]++;
	}
	sort(digit+1,digit+n+1);
}
void Tree_Dp(int p) {
	F[p][0]=1,F[p][1]=Two[cnt[p]]-1;
	if(mark[p]&&must[p]==true) F[p][0]=0;
	if(mark[p]&&must[p]==false) F[p][1]=0;
	if(start[p]==0) return ;
	for(int i=start[p]; i; i=next[i])
		if(out[i]==false&&to[i]!=father[p]) {
			int q=to[i];
			if(cnt[q]==0) continue;
			Tree_Dp(q);
			F[p][0]=F[p][0]*(F[q][0]+F[q][1])%MOD;
			F[p][1]=F[p][1]*F[q][0]%MOD;
		}
}
void DFS(int p) {
	use[p]=true,point[++s]=p;
	for(int i=start[p]; i; i=next[i])
		if(cnt[to[i]]&&to[i]!=father[p]) {
			if(!use[to[i]]) father[to[i]]=p,DFS(to[i]);
			else out[i]=true,edge[++edge[0]]=i,mark[to[i]]=true,mark[p]=true;
		}
}
void DFS(int p,int n,LL &ans) {
	if(p>n) {
		for(int i=1; i<=edge[0]; i++) {
			int x=edge[i],a=to[x],b=to[x^1];
			if(must[a]&must[b]) return ;
		}
		Tree_Dp(point[1]);
		ans=(ans+F[point[1]][0]+F[point[1]][1])%MOD;
		return ;
	}
	must[wait[p]]=true,DFS(p+1,n,ans);
	must[wait[p]]=false,DFS(p+1,n,ans);
}
LL work(int p) {
	s=0,edge[0]=0,wait[0]=0;
	DFS(p);
	LL total=0;
	for(int i=1; i<=s; i++)
		if(mark[point[i]])
			wait[++wait[0]]=point[i];
	DFS(1,wait[0],total);
	return total;
}
void work() {
	for(int i=1; i<=n; i++)
		if(!use[digit[i]])
			ans=ans*work(digit[i])%MOD;
}
int main() {
	ptm();
	read();
	work();
	cout<<ans-1<<endl;
	return 0;
}
```
（本蒟蒻太蒟了，以至于调了一天，不过运气还好，一次就A了 ~QAQ~）

---


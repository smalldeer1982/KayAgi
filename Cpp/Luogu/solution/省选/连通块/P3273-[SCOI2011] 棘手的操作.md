# [SCOI2011] 棘手的操作

## 题目描述

有 $N$ 个节点，标号从 $1$ 到 $N$，这 $N$ 个节点一开始相互不连通。第i个节点的初始权值为 $a_i$，接下来有如下一些操作：
- `U x y`: 加一条边，连接第 $x$ 个节点和第 $y$ 个节点；
- `A1 x v`: 将第 $x$ 个节点的权值增加 $v$；
- `A2 x v`: 将第 $x$ 个节点所在的连通块的所有节点的权值都增加 $v$；
- `A3 v`: 将所有节点的权值都增加 $v$；
- `F1 x`: 输出第 $x$ 个节点当前的权值；
- `F2 x`: 输出第 $x$ 个节点所在的连通块中，权值最大的节点的权值；
- `F3`: 输出所有节点中，权值最大的节点的权值。

## 说明/提示

对于 $30\%$ 的数据，保证 $N\le 100，Q\le 10000$；

对于 $80\%$ 的数据，保证 $N\le 100000$，$Q\le 100000$；

对于 $100\%$ 的数据，保证 $N\le 300000$，$Q\le 300000$；

对于所有的数据，保证输入合法，并且 $-1000\le v,a_1,a_2,\dots,a_N \le 1000$。

## 样例 #1

### 输入

```
3
0 0 0
8
A1 3 -20
A1 2 20
U 1 3
A2 1 10
F1 3
F2 3
A3 -10
F3```

### 输出

```
-10
10
10```

# 题解

## 作者：ouuan (赞：23)

这题目前题解中所有左偏树做法均可被卡（一条链，不停单点询问链底端）。

其实这题是有左偏树正解的，就是[这篇题解](https://www.luogu.org/blog/user17667/solution-p3273)的做法，然而他是暴力向上跳找根的，所以还是可以被卡。

首先，找一个节点所在堆的堆顶要用并查集，而不能暴力向上跳。

再考虑单点查询，若用普通的方法打标记，就得查询点到根路径上的标记之和，最坏情况下可以达到 $\mathcal O(n)$ 的复杂度。如果只有堆顶有标记，就可以 $\mathcal O(\log n)$（只有路径压缩的并查集复杂度）地查询了，但如何做到呢？

可以用类似启发式合并的方式，每次合并的时候把较小的那个堆标记暴力下传到每个节点，然后把较大的堆的标记作为合并后的堆的标记。由于合并后有另一个堆的标记，所以较小的堆下传标记时要下传其标记减去另一个堆的标记。由于每个节点每被合并一次所在堆的大小至少乘二，所以每个节点最多被下放 $\mathcal O(\log n)$ 次标记，暴力下放标记的总复杂度就是 $\mathcal O(n\log n)$。

再考虑单点加，先删除，再更新，最后插入即可。

然后是全局最大值，可以用一个平衡树/左偏树/multiset 来维护每个堆的堆顶。

所以，每个操作分别如下：

1. 暴力下传点数较小的堆的标记，合并两个堆，更新 size、tag，在 multiset 中删去合并后不在堆顶的那个原堆顶。

2. 删除节点，更新值，插入回来，更新 multiset。需要分删除节点是否为根来讨论一下。

3. 堆顶打标记，更新 multiset。

4. 打全局标记。

5. 查询值+堆顶标记+全局标记。

6. 查询根的值+堆顶标记+全局标记。

7. 查询 multiset 最大值+全局标记。

参考代码：

```cpp
#include <iostream>
#include <cstdio>
#include <set>
#include <cctype>
#include <algorithm>

using namespace std;

int read()
{
    int out=0,f=1;
    char c;
    for (c=getchar();!isdigit(c)&&c!='-';c=getchar());
    if (c=='-') { f=-1; c=getchar(); }
    for (;isdigit(c);c=getchar()) out=out*10+c-'0';
    return out*f;
}

const int N=300010;

struct Node
{
    int val,ch[2],d,fa;
} t[N];

int& rs(int x);
int merge(int x,int y);
void pushup(int x);
void pushdown(int x,int y);

int find(int x);

int n,m,f[N],tag[N],siz[N],delta;
char op[10];
multiset<int> s;

int main()
{
    int i,x,y;

    n=read();

    for (i=1;i<=n;++i)
    {
        t[i].val=read();
        f[i]=i;
        siz[i]=1;
        s.insert(t[i].val);
    }

    m=read();

    while (m--)
    {
        scanf("%s",op);
        if (op[0]=='U')
        {
            x=find(read());
            y=find(read());
            if (x!=y)
            {
                if (siz[x]>siz[y]) swap(x,y);
                pushdown(x,tag[x]-tag[y]);
                f[x]=f[y]=merge(x,y);
                if (f[x]==x)
                {
                    s.erase(s.find(t[y].val+tag[y]));
                    tag[x]=tag[y];
                    siz[x]+=siz[y];
                    tag[y]=siz[y]=0;
                }
                else
                {
                    s.erase(s.find(t[x].val+tag[y]));
                    siz[y]+=siz[x];
                    tag[x]=siz[x]=0;
                }
            }
        }
        else if (op[0]=='A')
        {
            if (op[1]=='1')
            {
                x=read();
                if (x==find(x))
                {
                    t[t[x].ch[0]].fa=t[t[x].ch[1]].fa=0;
                    y=merge(t[x].ch[0],t[x].ch[1]);
                    s.erase(s.find(t[x].val+tag[x]));
                    t[x].val+=read();
                    t[x].fa=t[x].ch[0]=t[x].ch[1]=0;
                    t[x].d=1;
                    f[x]=f[y]=merge(x,y);
                    s.insert(t[f[x]].val+tag[x]);
                    if (f[x]==y)
                    {
                        tag[y]=tag[x];
                        siz[y]=siz[x];
                        tag[x]=siz[x]=0;
                    }
                }
                else
                {
                    t[t[x].ch[0]].fa=t[t[x].ch[1]].fa=t[x].fa;
                    t[t[x].fa].ch[x==t[t[x].fa].ch[1]]=merge(t[x].ch[0],t[x].ch[1]);
                    t[x].val+=read();
                    t[x].fa=t[x].ch[0]=t[x].ch[1]=0;
                    t[x].d=1;
                    y=find(x);
                    f[x]=f[y]=merge(x,y);
                    if (f[x]==x)
                    {
                        s.erase(s.find(t[y].val+tag[y]));
                        s.insert(t[x].val+tag[y]);
                        tag[x]=tag[y];
                        siz[x]=siz[y];
                        tag[y]=siz[y]=0;
                    }
                }
            }
            else if (op[1]=='2')
            {
                x=find(read());
                s.erase(s.find(t[x].val+tag[x]));
                tag[x]+=read();
                s.insert(t[x].val+tag[x]);
            }
            else delta+=read();
        }
        else
        {
            if (op[1]=='1')
            {
                x=read();
                printf("%d\n",t[x].val+tag[find(x)]+delta);
            }
            else if (op[1]=='2')
            {
                x=find(read());
                printf("%d\n",t[x].val+tag[x]+delta);
            }
            else printf("%d\n",*s.rbegin()+delta);
        }
    }

    return 0;
}

int& rs(int x) //一种比较清奇的左偏树写法，无需交换左右儿子，把dist较小的视作右儿子即可
{
    return t[x].ch[t[t[x].ch[1]].d<t[t[x].ch[0]].d];
}

int merge(int x,int y)
{
    if (!x||!y) return x|y;
    if (t[x].val<t[y].val) swap(x,y);
    t[rs(x)=merge(rs(x),y)].fa=x;
    pushup(x);
    return x;
}

void pushup(int x) //一种比较清奇的删节点写法，merge之后递归地pushup即可
{
    if (!x) return;
    if (t[x].d!=t[rs(x)].d+1)
    {
        t[x].d=t[rs(x)].d+1;
        pushup(t[x].fa);
    }
}

void pushdown(int x,int y)
{
    if (!x) return;
    t[x].val+=y;
    pushdown(t[x].ch[0],y);
    pushdown(t[x].ch[1],y);
}

int find(int x)
{
    return x==f[x]?x:f[x]=find(f[x]);
}
```

---

## 作者：Limit (赞：16)

# 题目大意

给出一些点和一些操作,资瓷链接两点,某个点所在的联通块都加上一个数,某个点加上一个数,全部加上一个数,查询单点的值,查询某个点所在的连通块中的最大值,查询所有值中的最大值.

# 分析

~~可并堆裸题~~.因为连边这个东西很难处理,所以考虑离线,考虑对每个点记录一下 $tim_i$ 表示当前节点连接其他节点的时间.再考虑建树,但是如果直接在需要连接的两点直接连边会出问题,没有办法处理某个时间的连通块,所以考虑用并查集维护一下,这样就可以保证对于某个节点的子节点连接父亲的时间都是在自己连接父亲之前,考虑当前修改的连通块在 DFS 序中必定是连续的一段,且左端点必定是当前节点的某个祖先,那么寻找祖先就可以用倍增来维护,在知道祖先后考虑修改的部分必定包含当前节点的若干子树,且在儿子中链接当前节点的时间是单调递增的,所以可以用二分来快速查询,然后就是一个线段树模板维护区间 $\max$ 就好了.

# 代码

```cpp
#include<bits/stdc++.h>
#define REP(i,first,last) for(int i=first;i<=last;++i)
#define DOW(i,first,last) for(int i=first;i>=last;--i)
using namespace std;
const int MAXN=3e5+5;
const int INF=1e9;
int n,m;
vector<int>edge[MAXN];
char opt[MAXN][2];
int x[MAXN],y[MAXN],v[MAXN];
int father[MAXN][21];
int Find(int now)//并查集部分
{
	if(now==father[now][0])
	{
		return now;
	}
	return father[now][0]=Find(father[now][0]);
}
int tim[MAXN]={MAXN};//记录链接父亲的时间
int val[MAXN];
int id[MAXN];
int dfs[MAXN];
int dfs_cnt=0;
int siz[MAXN];//记录子树大小
void DFS(int now)//遍历所有树
{
	REP(i,1,19)//倍增预处理
	{
		father[now][i]=father[father[now][i-1]][i-1];
	}
	id[now]=++dfs_cnt;//当前节点在dfs序的位置
	dfs[dfs_cnt]=now;
	siz[now]=1;
	if(edge[now].size())
	{
		REP(i,0,edge[now].size()-1)//遍历子节点
		{
			father[edge[now][i]][0]=now;
			DFS(edge[now][i]);
			siz[now]+=siz[edge[now][i]];
		}
	}
}
int l,r;
void Getlr(int now,int now_time)//得到对于某个时间时某个节点的联通快
{
	if(tim[now]<now_time)//如果当前节点在当前时间已经连接了父亲,那么就倍增找祖先
	{
		DOW(i,19,0)
		{
			if(tim[father[now][i]]<now_time)
			{
				now=father[now][i];
			}
		}
		now=father[now][0];
	}
	int left=0,right=edge[now].size()-1,middle;
	l=id[now];
	r=id[now];
	while(left<=right)//在自己的儿子内二分
	{
		middle=(left+right)>>1;
		if(tim[edge[now][middle]]<now_time)
		{
			r=id[edge[now][middle]];
			left=middle+1;
		}
		else
		{
			right=middle-1;
		}
	}
	if(r^id[now])//如果自己的子树有修改了那么这整颗子树都会被修改
	{
		r+=siz[dfs[r]]-1;
	}
}
//以下为一颗区间加,区间查询max的线段树,过于模板就不多讲了
struct LazyTag
{
	int add;
	void Clean()
	{
		add=0;
	}
}for_make;
LazyTag MakeTag(int add)
{
	for_make.add=add;
	return for_make;
}
struct SegmentTree
{
	long long sum;
	long long max;
	LazyTag tag;
}sgt[MAXN*4];
#define LSON (now<<1)
#define RSON (now<<1|1)
#define MIDDLE ((left+right)>>1)
#define LEFT LSON,left,MIDDLE
#define RIGHT RSON,MIDDLE+1,right
#define NOW now_left,now_right
void PushUp(int now)
{
	sgt[now].sum=sgt[LSON].sum+sgt[RSON].sum;
	sgt[now].max=max(sgt[LSON].max,sgt[RSON].max);
}
void Build(int now=1,int left=1,int right=n)
{
	if(left==right)
	{
		sgt[now].max=sgt[now].sum=val[dfs[left]];
		return;
	}
	Build(LEFT);
	Build(RIGHT);
	PushUp(now);
}
void Down(LazyTag tag,int now,int left,int right)
{
	sgt[now].sum+=1ll*tag.add*(right-left+1);
	sgt[now].max+=tag.add;
	sgt[now].tag.add+=tag.add;
}
void PushDown(int now,int left,int right)
{
	Down(sgt[now].tag,LEFT);
	Down(sgt[now].tag,RIGHT);
	sgt[now].tag.Clean();
}
void Updata(int now_left,int now_right,int add,int now=1,int left=1,int right=n)
{
	if(now_right<left||right<now_left)
	{
		return;
	}
	if(now_left<=left&&right<=now_right)
	{
		Down(MakeTag(add),now,left,right);
		return;
	}
	PushDown(now,left,right);
	Updata(NOW,add,LEFT);
	Updata(NOW,add,RIGHT);
	PushUp(now);
}
int QueryMax(int now_left,int now_right,int now=1,int left=1,int right=n)
{
	if(now_right<left||right<now_left)
	{
		return -INF;
	}
	if(now_left<=left&&right<=now_right)
	{
		return sgt[now].max;
	}
	PushDown(now,left,right);
	return max(QueryMax(NOW,LEFT),QueryMax(NOW,RIGHT));
}
#undef LSON
#undef RSON
#undef MIDDLE
#undef LEFT
#undef RIGHT
#undef NOW
int main()
{
	scanf("%d",&n);
	REP(i,1,n)
	{
		scanf("%d",&val[i]);
		father[i][0]=i;
	}
	scanf("%d",&m);
	REP(i,1,m)//离线
	{
		cin>>opt[i];
		if(opt[i][0]=='U')//对于连边操作连边
		{
			scanf("%d%d",&x[i],&y[i]);
			if(Find(y[i])^Find(x[i]))
			{
				tim[Find(y[i])]=i;
				edge[Find(x[i])].push_back(Find(y[i]));
				father[Find(y[i])][0]=Find(x[i]);
			}
		}
		if(opt[i][0]=='A')
		{
			if(opt[i][1]=='1')
			{
				scanf("%d%d",&x[i],&v[i]);
			}
			if(opt[i][1]=='2')
			{
				scanf("%d%d",&x[i],&v[i]);
			}
			if(opt[i][1]=='3')
			{
				scanf("%d",&v[i]);
			}
		}
		if(opt[i][0]=='F')
		{
			if(opt[i][1]=='1')
			{
				scanf("%d",&x[i]);
			}
			if(opt[i][1]=='2')
			{
				scanf("%d",&x[i]);
			}
			if(opt[i][1]=='3')
			{

			}
		}
	}
	REP(i,1,n)//获得这个森林的dfs序
	{
		if(!tim[i])
		{
			tim[i]=INF;
			DFS(i);
		}
	}
	Build();//建树
	REP(i,1,m)
	{
		if(opt[i][0]=='A')//修改操作
		{
			if(opt[i][1]=='1')
			{
				Updata(id[x[i]],id[x[i]],v[i]);
			}
			if(opt[i][1]=='2')
			{
				Getlr(x[i],i);
				Updata(l,r,v[i]);
			}
			if(opt[i][1]=='3')
			{
				Updata(1,n,v[i]);
			}
		}
		if(opt[i][0]=='F')//查询操作
		{
			if(opt[i][1]=='1')
			{
				printf("%d\n",QueryMax(id[x[i]],id[x[i]]));
			}
			if(opt[i][1]=='2')
			{
				Getlr(x[i],i);
				printf("%d\n",QueryMax(l,r));
			}
			if(opt[i][1]=='3')
			{
				printf("%d\n",QueryMax(1,n));
			}
		}
	}
	return 0;
}

```

---

## 作者：Merc03 (赞：12)

# 需要的知识储备

- 线段树

- 并查集

- 离线思想
    
# 分析
	
###  -图的结构上 
	 
_加一条边，连接第x个节点和第y个节点_ 

对于一个联通块，块内连边并不会改变什么（本题的查询也只针对单点和连通块）

那么当x,y不连通时，这个操作就会把两个连通块变成一个，类似**合并**

可以看到，这道题目的连通块只会合并而不会减少

一组元素不断取两个合并，这使我们想到了**并查集**

当然，本题如果直接对并查集求解，单点操作朝上传，连通块操作朝下传，就会得到这样的情况：

#### 以下为错误示范可以跳过

再分两种情况讨论

一，直接把区间最值存到代表节点上，修改时朝所有子节点更新答案

那么总复杂度妥妥的O(Qn)，单次操作O(n)，直接凉凉

二，每次合并把答案更新到一个新节点上，空间复杂度2倍

这种方法看上去很优越，新节点我们得到了一棵二叉树，似乎看起来长得像O(logn)的单词操作，而新节点也让我们能自由地使用lazytag进行优化

~~我打死也不会说我差点以为自己找到了不需要线段树的做法结果不T的三个点调到死都只A了一个~~

那么，我们再仔细想一下

![不看错误示范的朋友请继续翻](https://cdn.luogu.com.cn/upload/pic/46705.png)

就比如说1,2,3号节点组成的连通块，树上总节点个数为5，log值约为2

我们要对1号点进行操作的话，就要一直上溯，和兄弟节点比较(或者上溯后比较儿子节点)直到答案没被更新或到达根节点为止

~~先不谈同时存下来兄弟和父亲对并查集的违背~~

对于新加入的点，最低可能直接和根节点相连，一次上溯即可

但是，有一种特殊情况，如果每次都只合并进一个点，那么K次合并和深度可能为K+1，在最坏情况下仍然是单词操作O(n)

实际上的复杂度应该为常数较小的O(qn)

所以依旧GG

~~曾经我天真地以为是极不稳定的logn~~

~~还有一件魔法的事就是始终调不对~~

### -权值修改/查询上

_A1 x v: 将第x个节点的权值增加v_

_A2 x v: 将第x个节点所在的连通块的所有节点的权值都增加v_

_A3 v: 将所有节点的权值都增加v_

 _F1 x: 输出第x个节点当前的权值_

_F2 x: 输出第x个节点所在的连通块中，权值最大的节点的权值_

_F3: 输出所有节点中，权值最大的节点的权值_ 

修改一个集合的所有元素，或者求最值，这让我们想到了**区间修改/查询**类的数据结构

那么，对于一张不断更新的图，**常见的按照序号构造区间的数据结构似乎很难直接套用**，因为区间在序列上并不一定连续，是很难确定的

试想这样一种情况：

每次合并的连通块**在编号上连续**

因为上节所说，本题对图的结构的更改只有合并，那么我们可以把一串被合并的点试做一个序列，一次合并就是把两个序列**前后连**接，得到一个更长的序列，原来的两个序列均为其连续子序列

进一步想想，所有的合并操作都这么处理，如此往复，那么到最后，我们得到的不就是若干个互不关联的序列吗

而且这样的序列显然满足这样的性质

对于任意阶段对应的查询和修改，对应连通块的答案就是该**连续区间**的答案

这个时候，**线段树**就可以派上用场了

那么，怎么让这个合并过程连续呢?

**建立映射就好辣！**

# 实现思路与常数优化

这样多个询问的题目，算法总是分离线和在线的

在线算法肯定不能知道最后的连接情况的

那么考虑离线

先处理所有的U操作建立映射

在上文所述的映射关系下，使合并过程中的序号是连续的

对于这种改变首位连接顺序的的序列，我们不难想到用链表给节点一组新的“序号”，映射从而使之连续

再在合并过程中用并查集优化一下对首位节点的查找

（如果每次都遍历前后的话会T几个）

然后再愉快地跑线段树就可以啦

~~怎么这么短？~~

# Code

lb为链表，re为映射，具体看代码吧

有一些常数上和实现上的冗余~~，和凌乱的代码，~~还请见谅。

~~有时间我会回来更新一下更精简的代码(咕咕)~~

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
using namespace std;
const int Nmax=300000+5;
int n,Q,k[Nmax],ques[Nmax][3],totq,f[Nmax],re[Nmax],leftt[Nmax],rightt[Nmax];
struct lb{int pre,nex;}h[Nmax];
int a[Nmax];
struct tree{int l,r;long long pre,add;}t[4*Nmax];
inline void build(int p,int l,int r)
{
    t[p].l=l;t[p].r=r;
    if(l==r)
    {
        t[p].pre=a[l];
        return;
    }
    int mid=(l+r)/2;
    build(p*2,l,mid);
    build(p*2+1,mid+1,r);
    t[p].pre=max(t[p*2].pre,t[p*2+1].pre);
}
inline void speard(int p)
{
    if(t[p].add)
    {
        t[p*2].pre+=t[p].add;
        t[p*2+1].pre+=t[p].add;
        t[p*2].add+=t[p].add;
        t[p*2+1].add+=t[p].add;
        t[p].add=0;
    }
}
inline void change(int p,int x,int y,int z)
{
    if(x<=t[p].l&&y>=t[p].r)
    {
        t[p].pre+=z;
        t[p].add+=z;
        return;
    }
    speard(p);
    int mid=(t[p].l+t[p].r)/2;
    if(x<=mid) change(p*2,x,y,z);
    if(y>mid) change(p*2+1,x,y,z);
    t[p].pre=max(t[p*2].pre,t[p*2+1].pre);
}
inline int ask(int p,int x,int y)
{
    if(x<=t[p].l&&y>=t[p].r) return t[p].pre;
    speard(p);
    int mid=(t[p].l+t[p].r)/2;
    int ans=-1<<(30);
    if(x<=mid) ans=max(ans,ask(p*2,x,y));
    if(y>mid) ans=max(ans,ask(p*2+1,x,y));
    return ans;
}
inline int cz(int k)
{return k==f[k]?k:f[k]=cz(f[k]);}
inline void hb(int x,int y)
{x=cz(x);y=cz(y);f[y]=x;}
int main()
{
    ios::sync_with_stdio(0);
    cin>>n;
    for(register int i=1;i<=n;i++) cin>>k[i];
    for(register int i=1;i<=n;i++) h[i].pre=h[i].nex=i,f[i]=leftt[i]=rightt[i]=i;
    cin>>Q;
    char opt,t;
    int x,y;
    while(Q--)
    {
        cin>>opt;
        switch(opt)
        {
            case 'U':
                totq++;
                cin>>x>>y;
                if(cz(x)==cz(y)) continue;
                ques[totq][0]=0;
                ques[totq][1]=x;
                ques[totq][2]=y;
                x=cz(x);y=cz(y);
                h[rightt[x]].nex=leftt[y];h[leftt[y]].pre=rightt[x];
                leftt[y]=rightt[x];
                rightt[x]=rightt[y];
                hb(x,y);
                break;
            case 'A':
                cin>>t;totq++;
                switch(t)
                {
                    case '1':
                        cin>>x>>y;
                        ques[totq][0]=1;
                        ques[totq][1]=x;
                        ques[totq][2]=y;
                        break;
                    case '2':
                        cin>>x>>y;
                        ques[totq][0]=2;
                        ques[totq][1]=x;
                        ques[totq][2]=y;
                        break;
                    case '3':
                        cin>>x;
                        ques[totq][0]=3;
                        ques[totq][1]=x;
                        break;
                }
                break;
            case 'F':
                cin>>t;totq++;
                switch(t)
                {
                    case '1':
                        cin>>x;
                        ques[totq][0]=4;
                        ques[totq][1]=x;
                        break;
                    case '2':
                        cin>>x;
                        ques[totq][0]=5;
                        ques[totq][1]=x;
                        break;
                    case '3':
                        ques[totq][0]=6;
                        ques[totq][1]=x;
                        ques[totq][2]=y;
                        break;
                }
                break;
        }
    }
    for(register int i=1;i<=n;i++) f[i]=leftt[i]=rightt[i]=i;
    int maxt=0;
    for(register int i=1;i<=n;i++)
        if(h[i].pre==i) 
        {
            int p=i;
            while(h[p].nex!=p) a[++maxt]=k[p],re[p]=maxt,p=h[p].nex;
            a[++maxt]=k[p];re[p]=maxt;
        }
    build(1,1,n);
    int l,r;
    for(register int o=1;o<=totq;o++)
    {
        switch(ques[o][0])
        {
            case 0:
                leftt[cz(re[ques[o][1]])]=min(leftt[cz(re[ques[o][1]])],leftt[cz(re[ques[o][2]])]);
                rightt[cz(re[ques[o][1]])]=max(rightt[cz(re[ques[o][1]])],rightt[cz(re[ques[o][2]])]);
                hb(re[ques[o][1]],re[ques[o][2]]);
                break;
            case 1:change(1,re[ques[o][1]],re[ques[o][1]],ques[o][2]);break;
            case 2:
                l=leftt[cz(re[ques[o][1]])];r=rightt[cz(re[ques[o][1]])];
                change(1,l,r,ques[o][2]);
                break;
            case 3:change(1,1,n,ques[o][1]);break;
            case 4:cout<<ask(1,re[ques[o][1]],re[ques[o][1]])<<endl;break;
            case 5:
                l=leftt[cz(re[ques[o][1]])];r=rightt[cz(re[ques[o][1]])];
                cout<<ask(1,l,r)<<endl;
                break;
            case 6:cout<<ask(1,1,n)<<endl;break;
        }
    }
    return 0;
}
```

---

## 作者：HolseLee (赞：12)

　分析：

　　真是一道恶心的左偏树题。

　　需要维护两个左偏树，第一个维护正常的操作信息，第二个维护所有点中的最大值。

　　第一种操作：在第一个左偏树中$merge$即可，另外有一个小优化，合并的两个堆顶中较小的一个可以直接从第二个左偏树中删除（正确性自己思考）。

　　第二种操作：将该点从两个左偏树中删除，修改值以后再重新放回去。

　　第三种操作：用$lazy$标记，只修改堆顶的值，后面再$merge$或者删除节点的时候下方标记。

　　第四种操作：用一个变量记录，需要输出的时候再加上。

　　第五种操作：直接输出第一个左偏树中该节点的值。

　　第六种操作：直接输出第一个左偏树中该节点所在堆的堆顶的值。

　　第七种操作：直接输出第二个左偏树的根节点的值。

　　以上。

　　题如其名，真$TM$又棘手又恶心。。。

　　Code：
  ```cpp
//It is made by HolseLee on 28th Aug 2018
//Luogu.org P3273
#include<queue>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#define Max(a,b) (a)>(b) ? (a) : (b)
using namespace std;

const int N=3e5+7;
int n,a[N],m,allsign,root;
struct Leftist{
    int ch[N][2],val[N],sign[N],fa[N],dis[N];

    void clear(int x)
    {
        ch[x][0]=ch[x][1]=fa[x]=0;
    }

     int sum(int x)
    {
        int ret=0;
        while(x=fa[x])ret+=sign[x];
        return ret;
    }

     void pushdown(int x)
    {
        int ul=ch[x][0], ur=ch[x][1];
        if( ul )val[ul]+=sign[x], sign[ul]+=sign[x];
        if( ur )val[ur]+=sign[x], sign[ur]+=sign[x];
        sign[x]=0;
    }

    int merge(int x,int y)
    {
        if(!x||!y)return x+y;
        if( val[x]<val[y] )
            swap(x,y);
        pushdown(x);
        int &ul=ch[x][0], &ur=ch[x][1];
        ur=merge(ur,y); fa[ur]=x;
        if( dis[ur]>dis[ul] )swap(ul,ur);
        dis[x]=dis[ur]+1;
        return x;
    }

     int find(int x)
    {
        while(fa[x])x=fa[x];
        return x;
    }

     int delet(int x)
    {
        pushdown(x);
        int fx=fa[x];
        int ka=merge(ch[x][0],ch[x][1]);
        fa[ka]=fx;
        if( fx )ch[fx][x==ch[fx][1]]=ka;
        while( fx ) {
            if( dis[ch[fx][0]]<dis[ch[fx][1]] )
                swap(ch[fx][0],ch[fx][1]);
            if( dis[fx]==dis[ch[fx][1]]+1 )
                return root;
            dis[fx]=dis[ch[fx][1]]+1;
            ka=fx;
            fx=fa[fx];
        }
        return ka;
    }

     int add_point(int x,int v)
    {
        int fx=find(x);
        if( fx==x ) {
            if( ch[x][0]+ch[x][1]==0 ){
                val[x]+=v; return x;
            } else {
                if( ch[x][0] ) fx=ch[x][0];
                else fx=ch[x][1];
            }
        }
        delet(x);
        val[x]+=v+sum(x);
        clear(x);
        return merge(find(fx),x);
    }

    int build()
    {
        queue<int>t;
        for(int i=1; i<=n; ++i) t.push(i);
        int x,y,z;
        while( t.size()>1 ) {
            x=t.front(); t.pop();
            y=t.front(); t.pop();
            z=merge(x,y);t.push(z);
        }
        return t.front();
    }
}T,H;

 void read(int &x)
{
    x=0; char ch=getchar(); bool flag=false;
    while( ch<'0' || ch>'9' ) {
        if( ch=='-' )flag=true;
        ch=getchar();
    }
    while( ch>='0' && ch<='9' ) {
        x=(x<<1)+(x<<3)+(ch^48);
        ch=getchar();
    }
    flag?x*=(-1):1;
}

int main()
{
    read(n);
    T.dis[0]=H.dis[0]=-1;
    for(int i=1; i<=n; ++i){
        read(a[i]);
        T.val[i]=H.val[i]=a[i];
    }
    root=H.build();
    read(m);
    char op[3];int x,y,fx,fy,temp;
    for(int i=1; i<=m; ++i){
        scanf("%s",op);
        if( op[0]=='A' ) {
            switch( op[1] ){
                case '1':
                    read(x), read(y);
                    root=H.delet(T.find(x));
                    temp=T.add_point(x,y);
                    H.val[temp]=T.val[temp];
                    H.clear(temp);
                    root=H.merge(root,temp);
                    break;

                case '2':
                    read(x), read(y); fx=T.find(x);
                    root=H.delet(fx);
                    T.val[fx]+=y; T.sign[fx]+=y;
                    H.val[fx]=T.val[fx];
                    H.clear(fx);
                    root=H.merge(root,fx);
                    break;

                case '3':
                    read(y);
                    allsign+=y;
                    break;
            }
        } else if( op[0]=='F' ) {
            switch( op[1] ){
                case '1':
                    read(x);
                    printf("%d\n",T.val[x]+allsign+T.sum(x));
                    break;

                case '2':
                    read(x);
                    printf("%d\n",T.val[T.find(x)]+allsign);
                    break;

                case '3':
                    printf("%d\n",H.val[root]+allsign);
                    break;
            }
        } else {
            read(x), read(y);
            fx=T.find(x), fy=T.find(y);
            if( fx==fy )continue;
            temp=T.merge(fx,fy);
            if( temp==fx )root=H.delet(fy);
            else root=H.delet(fx);
        }
    }
    return 0;
}
  ```

---

## 作者：浮尘ii (赞：12)

网上对这道题的评价是毒瘤……

首先要左偏树合并，还要堆维护最大值，还有按秩合并并查集维护连通性和连通块的整体加值……


看着就烦……然后我就自己脑补出了以下做法，是速度比较快里面代码最短的（pb\_ds大法好）。


首先我们知道平衡树的启发式合并，每次合并两棵平衡树时，遍历小的往大的里面insert，这样保证每个点总共访问$O(log_2n)$次，而每次访问都会有$O(log_2n)$的insert操作，故总的时间复杂度为$O(nlog_2^2n)$。（注：splay由于某个性质最终复杂度为$O(nlog_2n)$，但由于常数原因，跑得比两个log的还慢）


接着我们开始乱搞。我们把这个平衡树改成堆，我称之为“堆的启发式合并”。

这里我选用配对堆，每次insert操作是$O(1)$的，故最后复杂度为$O(nlog_2n)$。

然后再用并查集维护连通性，用堆维护每个连通块的最大值，每个连通块记录一个统一的tag记录加的值，总体再开一个tag记录总体加的值。


然后配对堆可以用pb\_ds。


```cpp
#include <iostream>
#include <cstdio>
#include <cctype>
#include <ext/pb_ds/priority_queue.hpp>

using namespace std;

using node = pair<int, int>;
using tree = __gnu_pbds::priority_queue<node>;
using heap = __gnu_pbds::priority_queue<int>;

const size_t        MaxN = 300005;

int        N, A[MaxN], Q;
tree    T[MaxN];
tree::point_iterator    Tit[MaxN];
int        All, Tag[MaxN], Fa[MaxN];
heap    Max;
heap::point_iterator    Mit[MaxN];

int getfa(int x)
{ return Fa[x] == x ? x : Fa[x] = getfa(Fa[x]); }

void merge(int x, int y)
{
    x = getfa(x), y = getfa(y);
    if(T[x].size() > T[y].size())
        swap(x, y);
    if(x != y) {
        for(auto i: T[x]) {
            Tit[i.second] = T[y].push(node(i.first + Tag[x] - Tag[y], i.second));
            A[i.second] = i.first + Tag[x] - Tag[y];
        }
        T[x].clear();
        Max.erase(Mit[x]), Max.modify(Mit[y], T[y].top().first + Tag[y]);
        Fa[x] = y;
    }
}

int main()
{
    cin >> N;
    for(int i = 1; i <= N; ++i)
        scanf("%d", A + i), Fa[i] = i,
        Tit[i] = T[i].push(node(A[i], i)), Mit[i] = Max.push(A[i]);

    cin >> Q;
    while(Q--) {
        char    o[5];
        int    x, y, v;

        scanf("%s", o);
        if(*o == 'U')
            scanf("%d%d", &x, &y), merge(x, y);
        else if(*o == 'A')
            if(o[1] == '3')
                scanf("%d", &v), All += v;
            else {
                scanf("%d%d", &x, &v);
                if(o[1] == '1') {
                    int    t = getfa(x);
                    T[t].modify(Tit[x], node(A[x] += v, x));
                    Max.modify(Mit[t], T[t].top().first + Tag[t]);
                } else {
                    int    t = getfa(x);
                    Tag[t] += v;
                    Max.modify(Mit[t], T[t].top().first + Tag[t]);
                }
            }
        else if(o[1] == '3')
            printf("%d\n", Max.top() + All);
        else {
            scanf("%d", &x);
            int    t = getfa(x);
            if(o[1] == '1')
                printf("%d\n", A[x] + Tag[t] + All);
            else
                printf("%d\n", T[t].top().first + Tag[t] + All);
        }
    }

    return 0;
}
```

---

## 作者：nekko (赞：10)

这题画风很新奇，然后就随便水咯

[bzoj 2333](https://www.lydsy.com/JudgeOnline/problem.php?id=2333)

[code](https://www.luogu.org/recordnew/show/4099972)

> 有$n$个节点，标号从$1$到$n$，这$n$个节点一开始相互不连通
> 第$i$个节点的初始权值为$a_i$，接下来有如下一些操作
> **U x y** 加一条边，连接第$x$个节点和第$y$个节点
> **A1 x v** 将第$x$个节点的权值增加$v$
> **A2 x v** 将第$x$个节点所在的连通块的所有节点的权值都增加$v$
> **A3 v** 将所有节点的权值都增加$v$
> **F1 x** 输出第$x$个节点当前的权值
> **F2 x** 输出第$x$个节点所在的连通块中，权值最大的节点的权值
> **F3** 输出所有节点中，权值最大的节点的权值

连边和连通性？并查集

查询点？用vector存储每一个连通块的点

连通块加？打标记

如何合并？启发式合并，同时要更新标记

整体加？开个变量记录一下

局部和全局最大值？开个堆记录一下，需要支持可删除存在的元素，而且还需要支持可合并

下面介绍一下启发式合并和可删堆

### 启发式合并

> 给定一堆数据结构，每次诸如合并两个数据结构，或者在某个数据结构中查询一些信息
> 数据结构的插入和查询复杂度很低，但重构的复杂度很高

合并的时候，每次将大小（元素个数）小的数据结构中的元素一个一个插入到大的数据结构中，这样每次数据结构大小就会翻一倍，每个元素最多被访问$O(\text{log}n)$次

打个比方，要是合并两个堆的话，小的那个堆一直pop，大的那个堆将pop出来的元素push进去

### 可删堆

> 实现一个数据结构
> 支持插入一个数
> 删除一个数据结构中存在的数
> 查询最大值

开一个结构体，维护两个堆，分别叫做val和del

这两个堆的性质需要一样，即要么同时是最小堆要么同时是最大堆

对于插入，直接在val中push值

对于删除，直接在del中push值

对于查询，一直判断val和del的堆顶是否相同，相同的话都pop掉，一直到del为空，然后输出val的堆顶

``` cpp
%:pragma GCC optimize(2)

#include <cstdio>
#include <algorithm>
#include <queue>
#include <vector>
using namespace std;
const int N = 310000;
typedef long long ll;
int n, q;
ll a[N], globalTag, localTag[N], fa[N];
vector<ll> num[N];
int get(int x) {return x == fa[x] ? x : fa[x] = get(fa[x]);}
struct heap {
    priority_queue<ll> val, del;
    void push(ll x) {val.push(x);}
    void pop(ll x) {del.push(x);}
    ll top() {while(del.size() && val.top() == del.top()) val.pop(), del.pop(); return val.top();}
} globalMx, localMx[N];
char op[5];
int main() {
    scanf("%d", &n);
    for(int i = 1 ; i <= n ; ++ i) {
        scanf("%lld", &a[i]);
        fa[i] = i;
        num[i].push_back(i);
        localMx[i].push(a[i]);
        globalMx.push(a[i]);
    }
    scanf("%d", &q);
    for(int i = 1, x, y, v ; i <= q ; ++ i) {
        scanf("%s", op);
        if(op[0] == 'U') {
            scanf("%d%d", &x, &y), x = get(x), y = get(y);
            if(x != y) {
                if(num[x].size() < num[y].size()) swap(x, y);
                globalMx.pop(localMx[y].top() + localTag[y]);
                globalMx.pop(localMx[x].top() + localTag[x]);
                for(int j = 0 ; j < num[y].size() ; ++ j) {
                    int id = num[y][j];
                    fa[id] = x;
                    a[id] = a[id] + localTag[y] - localTag[x];
                    num[x].push_back(id);
                    localMx[x].push(a[id]);
                }
                num[y].clear();
                globalMx.push(localMx[x].top() + localTag[x]);
            }
        } else if(op[0] == 'A' && op[1] == '1') {
            scanf("%d%d", &x, &v);
            globalMx.pop(localMx[get(x)].top() + localTag[get(x)]);
            localMx[get(x)].pop(a[x]);
            localMx[get(x)].push(a[x] += v);
            globalMx.push(localMx[get(x)].top() + localTag[get(x)]);
        } else if(op[0] == 'A' && op[1] == '2') {
            scanf("%d%d", &x, &v);
            globalMx.pop(localMx[get(x)].top() + localTag[get(x)]);
            localTag[get(x)] += v;
            globalMx.push(localMx[get(x)].top() + localTag[get(x)]);
        } else if(op[0] == 'A' && op[1] == '3') {
            scanf("%d", &v);
            globalTag += v;
        } else if(op[0] == 'F' && op[1] == '1') {
            scanf("%d", &x);
            printf("%lld\n", a[x] + localTag[get(x)] + globalTag);
        } else if(op[0] == 'F' && op[1] == '2') {
            scanf("%d", &x);
            printf("%lld\n", localMx[get(x)].top() + localTag[get(x)] + globalTag);
        } else if(op[0] == 'F' && op[1] == '3') {
            printf("%lld\n", globalMx.top() + globalTag);
        }
    }
}
```

---

## 作者：xyz32768 (赞：9)

并查集+线段树。

首先我们可以发现，每个连通块可以映射成一个区间。所以，首先对于所有的U操作，通过并查集预处理出所有原来的元素在序列中的位置并构建序列，保证任何时候在同一个连通块里的元素是一个区间（可用链表实现），然后此问题就变成了序列上的修改/询问。线段树实现。

```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#define p2 p << 1
#define p3 p << 1 | 1
using namespace std;
inline int read() {
    int res = 0; bool bo = 0; char c;
    while (((c = getchar()) < '0' || c > '9') && c != '-');
    if (c == '-') bo = 1; else res = c - 48;
    while ((c = getchar()) >= '0' && c <= '9')
        res = (res << 3) + (res << 1) + (c - 48);
    return bo ? ~res + 1 : res;
}
inline char get1() {
    char c; while ((c = getchar()) != 'A' && c != 'F' && c != 'U');
    return c;
}
inline int get2() {
    char c; while ((c = getchar()) < '0' || c > '9');
    return c - 48;
}
const int N = 3e5 + 5;
int n, a[N], fa[N], pre[N], suf[N], fir[N], lst[N], L[N], R[N],
pos[N], idx[N], T[N << 2], add[N << 2];
struct cyx {int op, x, y;} que[N];
void build(int l, int r, int p) {
    if (l == r) return (void) (T[p] = a[idx[l]]);
    int mid = l + r >> 1;
    build(l, mid, p2); build(mid + 1, r, p3);
    T[p] = max(T[p2], T[p3]);
}
void change(int l, int r, int s, int e, int v, int p) {
    if (l == s && r == e) return (void) (add[p] += v);
    int mid = l + r >> 1; add[p2] += add[p]; add[p3] += add[p];
    add[p] = 0; if (e <= mid) change(l, mid, s, e, v, p2);
    else if (s >= mid + 1) change(mid + 1, r, s, e, v, p3);
    else change(l, mid, s, mid, v, p2),
        change(mid + 1, r, mid + 1, e, v, p3);
    T[p] = max(T[p2] + add[p2], T[p3] + add[p3]);
}
int ask(int l, int r, int s, int e, int p) {
    if (l == s && r == e) return T[p] + add[p];
    int mid = l + r >> 1, res; add[p2] += add[p]; add[p3] += add[p];
    add[p] = 0; if (e <= mid) res = ask(l, mid, s, e, p2);
    else if (s >= mid + 1) res = ask(mid + 1, r, s, e, p3);
    else res = max(ask(l, mid, s, mid, p2),
        ask(mid + 1, r, mid + 1, e, p3));
    T[p] = max(T[p2] + add[p2], T[p3] + add[p3]);
    return res;
}
int cx(int x) {
    if (fa[x] != x) fa[x] = cx(fa[x]);
    return fa[x];
}
void zm(int x, int y) {
    int ix = cx(x), iy = cx(y);
    if (ix != iy) {
        fa[iy] = ix;
        int u = lst[ix], v = fir[iy]; lst[ix] = lst[iy];
        pre[u] = v; suf[v] = u;
    }
}
void wy(int x, int y) {
    int ix = cx(x), iy = cx(y);
    if (ix != iy) {
        fa[iy] = ix;
        if (L[ix] < L[iy]) R[ix] = R[iy];
        else L[ix] = L[iy];
    }
}
int main() {
    int i, j, Q, id, tot = 0; n = read();
    for (i = 1; i <= n; i++) a[i] = read(),
        fa[i] = fir[i] = lst[i] = i;
    Q = read(); for (i = 1; i <= Q; i++) {
        char c = get1(); switch(c) {
            case 'U':
                que[i].x = read(); que[i].y = read();
                zm(que[i].x, que[i].y); que[i].op = 1; 
                break;
            case 'A': id = get2(); que[i].x = read();
                if (id < 3) que[i].y = read();
                que[i].op = id + 1;
                break;
            case 'F': id = get2();
                if (id < 3) que[i].x = read();
                que[i].op = id + 4;
                break;
        }
    }
    for (i = 1; i <= n; i++) if (!pre[i])
        for (j = i; j; j = suf[j])
            idx[pos[j] = ++tot] = j;
    for (i = 1; i <= n; i++) fa[i] = i, L[i] = R[i] = pos[i];
    build(1, n, 1);
    for (i = 1; i <= Q; i++) switch(que[i].op) {
        case 1: wy(que[i].x, que[i].y); break;
        case 2: change(1, n, pos[que[i].x], pos[que[i].x],
            que[i].y, 1); break;
        case 3: id = cx(que[i].x);
            change(1, n, L[id], R[id], que[i].y, 1);
            break;
        case 4: change(1, n, 1, n, que[i].x, 1); break;
        case 5: printf("%d\n", ask(1, n, pos[que[i].x],
            pos[que[i].x], 1)); break;
        case 6: id = cx(que[i].x);
            printf("%d\n", ask(1, n, L[id], R[id], 1));
            break;
        case 7: printf("%d\n", ask(1, n, 1, n, 1));
            break;
    }
    return 0;
}
```

---

## 作者：远航之曲 (赞：6)

学习左偏树姿势，欢迎来[blog](http://www.yhzq-blog.cc/左偏树学习总结/)


这个题需要左偏树的一种操作：删除堆中任意一点


因为左偏树没有平衡树的性质，所以我们没法删除权值为特定值的点，也没法查找特定值的点的位置。


但是要删除某特定位置的点还是能做到的。我们先和删除最值一样，把它的孩子合并起来。


<center>![](http://www.yhzq-blog.cc/wp-content/uploads/2017/09/QQ%E6%88%AA%E5%9B%BE20170904091719-344x137.png)</center>


因为我们合并后的新树的距离可能会改变，所以要更新一下q的距离。


假如q的距离是p的距离+1，那么无论p是左右子树都不需要调整。


假如p的距离+1小于q的距离，就改下q的距离，而且假如p是左子树的话需要交换子树。由于q的距离小了，还需要更新它的父亲。


假如p距离变大了的话，看看p是不是左子树，是左子树的话就结束了。但是p是右子树的话，就有两种可能，假如p的距离仍然小于q的左子树，那就直接改q的距离就好了；大于的话还要换下子树，向上走。(在这里还有一种情况就是原来的左右子树距离一样，那就不用更新q的距离，直接结束就好了)


```cpp
void del_pos(int x)
{
    int q=f[x],p=merge(ch[x][0],ch[x][1]);
    f[p]=q;val[x]=-1;
    if (q)
        ch[q][ch[q][1]==x]=p;
    while(q)
    {
        if (dis[ch[q][0]]<dis[ch[q][1]])
            swap(ch[q][0],ch[q][1]);
        if (dis[ch[q][1]]+1==dis[q])
            return;
        dis[q]=dis[ch[q][1]]+1;
        q=f[q];
    }
}
```

下面分两种情况讨论删除操作的时间复杂度。


情况1：p的距离减小了。在这种情况下，由于q的距离只能缩小，当循环结束时，要么根节点处理完了，q为空；要么p是q的右子树并且$dis[p]+1=dis[q]$；如果$dis[p]+1>dis[q]$，那么p一定是q的左子树，否则会出现q的右子树距离缩小了，但是加1以后却大于q的距离的情况，不符合左偏树的性质三。不论哪种情况，删除操作都可以结束了。注意到，每一次循环，p的距离都会加1，而在循环体内，$dis[p]+1$最终将成为某个节点的距离。根据性质四，任何的距离都不会超过$\log n$，所以循环体的执行次数不会超过$\log n$。


情况2：p的距离增大了。在这种情况下，我们将必然一直从右子树向上调整，直至q为空或p是q的左子树时停止。一直从右子树升上来这个事实说明了循环的次数不会超过$\log n$（性质四）。


最后我们看到这样一个事实，就是这两种情况只会发生其中一个。如果某种情况的调整结束后，我们已经知道要么q为空，要么$dis[p]+1=dis[q]$，要么p是q的左子树。这三种情况都不会导致另一情况发生。直观上来讲，如果合并后的新子树导致了父节点的一系列距离调整的话，要么就一直是往小调整，要么是一直往大调整，不会出现交替的情况。这样效率就是$O(\log n)$


1.合并两个堆：直接merge

2.把某个点加：把这个点删了，再加一个更新了权值之后的点。

3.整个堆加：在根上打mark

4.全局加：记个全局mark

5.查询单点：一路加上所有父亲的mark再输出

6.查询堆最大值：直接输出

7.查询全局最大值。。


第七个操作需要把所有堆的根提取出来再建个堆。每次merge都要把并进去的堆删掉，单点加和整堆加都需要更新最大值。


注意细节


```cpp
#include <cstdio>
#include <queue>
#define N 300010
using namespace std;
int inline read()
{
    int x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
void swap(int &x,int &y){int t=x;x=y,y=t;}
int n,m,add,root;
char com[10];
struct zps
{
    int ch[N][2],val[N],dis[N],f[N],mark[N];
    void clear(int x){f[x]=ch[x][0]=ch[x][1]=0;}
    int sum(int x)
    {
        int ans=0;
        while(x=f[x]) ans+=mark[x];
        return ans;
    }
    void pushdown(int x)
    {
        if (ch[x][0])
            val[ch[x][0]]+=mark[x],
            mark[ch[x][0]]+=mark[x];
        if (ch[x][1])
            val[ch[x][1]]+=mark[x],
            mark[ch[x][1]]+=mark[x];
        mark[x]=0;
    }
    int merge(int x,int y)
    {
        if (x*y==0)
            return x+y;
        if (val[x]<val[y])
            swap(x,y);
        pushdown(x);
        ch[x][1]=merge(ch[x][1],y);
        f[ch[x][1]]=x;
        if (dis[ch[x][0]]<dis[ch[x][1]])
            swap(ch[x][0],ch[x][1]);
        dis[x]=dis[ch[x][1]]+1;
        return x;
    }
    int getf(int x)
    {
        while(f[x]) x=f[x];
        return x;
    }
    int del_pos(int x)
    {
        pushdown(x);
        int q=f[x],p=merge(ch[x][0],ch[x][1]);
        f[p]=q;
        if (q)
            ch[q][ch[q][1]==x]=p;
        while(q)
        {
            if (dis[ch[q][0]]<dis[ch[q][1]])
                swap(ch[q][0],ch[q][1]);
            if (dis[ch[q][1]]+1==dis[q])
                return root;
            dis[q]=dis[ch[q][1]]+1;
            p=q;
            q=f[q];
        }
        return p;
    }
    void add_tree(int x,int v)
    {
        int fx=getf(x);
        val[fx]+=v;
        mark[fx]+=v;
    }
    int add_point(int x,int v)
    {
        int fx=getf(x);
        if (fx==x)
            if (ch[x][0]+ch[x][1]==0)
            {
                val[x]+=v;
                return x;
            }
            else
                if (ch[x][0])
                    fx=ch[x][0];
                else
                    fx=ch[x][1];
        del_pos(x);
        val[x]+=v+sum(x);
        clear(x);
        return merge(getf(fx),x);
    }
    int build()
    {
        queue<int>que;
        for (int i=1;i<=n;i++)
            que.push(i);
        while(que.size()>1)
        {
            int x=que.front();que.pop();
            int y=que.front();que.pop();
            int z=merge(x,y);
            que.push(z);
        }
        return que.front();
    }
}h1,h2;

main()
{
    n=read();
    h1.dis[0]=h2.dis[0]=-1;
    for (int i=1;i<=n;i++)
        h1.val[i]=read(),h2.val[i]=h1.val[i];
    root=h2.build();
    m=read();
    for (int i=1;i<=m;i++)
    {
        scanf("%s",com);
        if (com[0]=='U')
        {
            int x=read(),y=read();
            int temp,fx=h1.getf(x),fy=h1.getf(y);
            if (fx!=fy)
            {
                temp=h1.merge(fx,fy);
                if (temp==fx)
                    root=h2.del_pos(fy);
                else
                    root=h2.del_pos(fx);
            }
        }
        else 
        if (com[0]=='A')
            if (com[1]=='1')
            {
                int x=read(),v=read();
                root=h2.del_pos(h1.getf(x));
                int y=h1.add_point(x,v);
                h2.val[y]=h1.val[y];
                h2.clear(y);
                root=h2.merge(root,y);
            }
            else if (com[1]=='2')
            {
                int x=read(),v=read(),fx=h1.getf(x);
                root=h2.del_pos(fx);
                h1.val[fx]+=v;
                h1.mark[fx]+=v;
                h2.val[fx]=h1.val[fx];
                h2.clear(fx);
                root=h2.merge(root,fx);
            }
            else if (com[1]=='3')
            {
                int v=read();
                add+=v;
            }
            else;
        else if (com[0]=='F')
            if (com[1]=='1')
            {
                int x=read();
                printf("%d\n",h1.val[x]+add+h1.sum(x));
            }
            else if (com[1]=='2')
            {
                int x=read();
                printf("%d\n",h1.val[h1.getf(x)]+add);
            }
            else if (com[1]=='3')
                printf("%d\n",h2.val[root]+add);
                
    }
}
```

跑得还是挺快的。


---

## 作者：_ctz (赞：5)

[点击获取更好的阅读体验$QwQ$](https://ctz45562.github.io/2019/03/16/%E9%A2%98%E8%A7%A3-%E6%B4%9B%E8%B0%B7-P3273-%E3%80%90-SCOI2011-%E6%A3%98%E6%89%8B%E7%9A%84%E6%93%8D%E4%BD%9C%E3%80%91/)

[传送门](https://www.luogu.org/problemnew/show/P3273)

长得一点也不像线段树的线段树思维题。。。

看到连边首先想到了$LCT$。但是。。。$LCT$不能对一群不在同一条链上的节点修改和查询。

换个思路想：如果同一联通块节点编号连续的话，是不是就好维护了呢？这样问题就变成了**保证每次连边后形成的联通块编号连续**，然后就可以并查集$+$线段树维护了。

题目没有强制在线，自然可以把操作离线下来。

一开始每个点都是联通块，拥有一个编号序列（这里编号序列是一个**相对位置**，两个不同的联通块编号靠前靠后不会互相影响的）。当连接两个联通块时，把它们两个的形成编号拼接起来。蒟蒻用的朴素的链表，可以$O(1)$地将两个块编号序列连接起来。

然后用并查集维护联通块大小，线段树区间加维护最大值就好了$QwQ$。

注意！数据有不合法连边，要特判。

具体实现还是看代码清晰一些：（蒟蒻没写过链表，自己$yy$用数组写的的可能比较丑陋。。。）

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <cstring>

#define maxn 300005
#define inf 0x3f3f3f3f

using namespace std;

inline int read(){
	int x=0,y=0;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')y=1;ch=getchar();}
	while(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
	return y?-x:x;
}
template<typename T>
inline T read(){
	T x=0;
	int y=0;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')y=1;ch=getchar();}
	while(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
	return y?-x:x;
}
int nex[maxn],tail[maxn],a[maxn],pos[maxn],seg[maxn],fa[maxn],siz[maxn],cnt,n;
//nex指向链表节点的下一项，tail是链表尾指针
//seg是重新编的号，pos是每个seg对应的实际位置
//fa是并查集
int find(int x){
	if(fa[x]==x)return x;
	return fa[x]=find(fa[x]);
}
struct Order{
	int s,x,d;//s是操作类型
}o[maxn];//存储操作
struct Segment_Tree{
	int ma[maxn<<2],tag[maxn<<2];	
#define ls(x) (x<<1)
#define rs(x) (x<<1|1)
	inline void update(int node){
		ma[node]=max(ma[ls(node)],ma[rs(node)]);
	}
	inline void datadown(int node,int d){
		ma[node]+=d,tag[node]+=d;
	}
	inline void pushdown(int node){
		datadown(ls(node),tag[node]);
		datadown(rs(node),tag[node]);
		tag[node]=0;
	}
	void build(int l=1,int r=cnt,int node=1){
		if(l==r){
			ma[node]=a[pos[l]];
			fa[l]=l,siz[l]=1;
            //重置并查集和siz
			return;
		}
		int mid=l+r>>1;
		build(l,mid,ls(node));
		build(mid+1,r,rs(node));
		update(node);
	}
	void add(int L,int R,int l,int r,int node,int d){
		if(L<=l&&R>=r){
			datadown(node,d);
			return;
		}
		if(tag[node])pushdown(node);
		int mid=l+r>>1;
		if(L<=mid)add(L,R,l,mid,ls(node),d);
		if(R>mid)add(L,R,mid+1,r,rs(node),d);
		update(node);
	}
	int ask(int L,int R,int l,int r,int node){
		if(L<=l&&R>=r)return ma[node];
		if(tag[node])pushdown(node);
		int mid=l+r>>1,ans=-inf;
		if(L<=mid)ans=ask(L,R,l,mid,ls(node));
		if(R>mid)ans=max(ans,ask(L,R,mid+1,r,rs(node)));
		return ans;
	}
}st;//线段树常规操作
int main(){
	n=read();
	for(register int i=1;i<=n;++i)
		a[i]=read(),tail[i]=fa[i]=i;
	int m=read();
	for(register int i=1;i<=m;++i){
		char s[5];
		scanf("%s",s);
		if(s[0]=='A'){
			o[i].s=-s[1]+'0';
			if(s[1]<'3')o[i].x=read();
			o[i].d=read();
		}
		else if(s[0]=='F'){
			o[i].s=s[1]-'0';
			if(s[1]<'3')o[i].x=read();
		}
		else {
			o[i].s=45562;
			int x=read(),y=read(),u=find(x),v=find(y);
			o[i].x=x,o[i].d=y;
			if(u==v)continue;//特判
			nex[tail[u]]=v,tail[u]=tail[v],fa[v]=u;
            //把两段链表连起来
		}
	}
    //s<0为A操作，|s|为其后跟的编号
    //s==45562连边操作
    //s>0为F操作，s为其后跟的编号
	for(register int i=1;i<=n;++i)
		if(fa[i]==i){
            //如果一个点在并查集里是根的话，它也是所在链表的头
			for(register int j=i;j;j=nex[j])seg[j]=++cnt,pos[cnt]=j;
            //遍历每一个链表，直接按链表顺序编号
		}
	st.build();//初始建树
	for(register int i=1;i<=m;++i){
		int s=o[i].s;
		if(s==45562){
			int u=find(o[i].x),v=find(o[i].d);
			if(u==v)continue;
			siz[u]+=siz[v],fa[v]=u;
            //维护一下siz便于获取联通块的区间
		}
		else if(s<0){
			if(s==-1)st.add(seg[o[i].x],seg[o[i].x],1,cnt,1,o[i].d);
			else if(s==-2){
				int u=find(o[i].x);
				st.add(seg[u],seg[u]+siz[u]-1,1,cnt,1,o[i].d);
                //并查集根的编号+siz-1就是该联通块当前所代表的区间
			}
			else st.add(1,cnt,1,cnt,1,o[i].d);
		}
		else {
			if(s==1)printf("%d\n",st.ask(seg[o[i].x],seg[o[i].x],1,cnt,1));
			else if(s==2){
				int u=find(o[i].x);
				printf("%d\n",st.ask(seg[u],seg[u]+siz[u]-1,1,cnt,1));
			}
			else printf("%d\n",st.ma[1]);
		}
	}
}

```



---

## 作者：critnos (赞：4)

真的是恶心题。。

建立 $n$ 个 multiset 维护一个联通块内信息，和一个大的 multiset 维护每个联通块的最大值，还有原数组，和一个打联通块加标记的数组，一个全局加的变量。

对于操作 $1$，启发式合并。这里有一个细节，就是把小的 multiset 插入到大的 multiset 中的时候要先加上本块的标记，再减去新块的标记。注意还要同步更新原数组，所以每块的 multiset 就要 pair 一下原数组的下标。。诶还要更新大 multiset。。

对于操作 $2$，直接在原数组上修改，然后同步更新本联通块的 multiset 和大的 multiset，具体的说就是在本联通块的 multiset 中删去自己，在大 multiset 中删去当前联通块的最大值，修改自己，把自己插入本联通块的 multiset，在大 multiset 中插入当前联通块的最大值。

对于操作 $3$，直接打标记再同步更新大 multiset。

对于操作 $4$，全局加标记。

后三个操作就很简单了。

一开始因为实现常数太大被卡常了。。后面优化了一下操作 $1$ 才能过：在更新大 multiset 的时候删去两个联通块的最大值中的较小值即可。

这种题尽量一次写好，要不然调起来很难受。

```cpp
#include<bits/stdc++.h>
#define it multiset<pair<int,int> >::iterator
using namespace std;
multiset<pair<int,int>,greater<pair<int,int> > > p[300005];
multiset<int> mx;
int tag[300005];
int a[300005];
int f[300005];
static char buf[1000000],*p1=buf,*p2=buf,obuf[1000000],*p3=obuf;
#define getchar() p1==p2&&(p2=(p1=buf)+fread(buf,1,1000000,stdin),p1==p2)?EOF:*p1++
int find(int x)
{
	return f[x]==x?x:f[x]=find(f[x]);
}
int read()
{
	int s=0,w=1;
	char ch=getchar();
	while(ch<'0'||ch>'9') w=ch=='-'?-1:w,ch=getchar();
	while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
	return s*w;
}
void merge(int x,int y)
{
	int fx=find(x),fy=find(y),k;
	if(fx==fy) return;
	if(p[fx].size()>p[fy].size())
		swap(fx,fy);
	f[fx]=fy;
	mx.erase(mx.find(min((*p[fx].begin()).first+tag[fx],(*p[fy].begin()).first+tag[fy])));
	for(it i=p[fx].begin();i!=p[fx].end();i++)
	{
		pair<int,int> u=*i;
		a[u.second]=u.first-tag[fy]+tag[fx],p[fy].insert({a[u.second],u.second});
	}
	p[fx].clear();
}
bool t[1000];
void gc(char opt[])
{
	int cnt=0;
	char ch=getchar();
	while(!t[ch]) ch=getchar();
	while(t[ch]) opt[cnt++]=ch,ch=getchar();
}
int main()
{
	t['U']=t['A']=t['F']=t['1']=t['2']=t['3']=1;
	int s=0;
	int i,j,n,m,fx,fy,x,y,po;
	char opt[5];
	n=read();
	for(i=1;i<=n;i++)
	{
		a[i]=read();
		p[i].insert({a[i],i});
		mx.insert(a[i]);
		f[i]=i;
	}
	m=read();
	while(m--)
	{
		gc(opt);
		if(*opt=='U') x=read(),y=read(),merge(x,y);
		if(*opt=='A'&&opt[1]=='1') 
		{
			x=read(),y=read();
			fx=find(x);
			mx.erase(mx.find((*p[fx].begin()).first+tag[fx]));
			p[fx].erase(p[fx].find({a[x],x}));
			a[x]+=y;
			p[fx].insert({a[x],x});
			mx.insert((*p[fx].begin()).first+tag[fx]);
		}
		if(*opt=='A'&&opt[1]=='2')	
		{
			x=read(),y=read();
			fx=find(x);
            po=(*p[fx].begin()).first+tag[fx];
			mx.erase(mx.find(po));
			tag[fx]+=y;
			mx.insert(po+y);
		}
		if(*opt=='A'&&opt[1]=='3')
		{
			y=read();
			s+=y;
		}
		if(*opt=='F'&&opt[1]=='1') x=read(),printf("%d\n",a[x]+tag[find(x)]+s);
		if(*opt=='F'&&opt[1]=='2') x=read(),printf("%d\n",(*p[find(x)].begin()).first+tag[find(x)]+s);
		if(*opt=='F'&&opt[1]=='3') printf("%d\n",*--mx.end()+s);
	}
}
```


---

## 作者：feilongz (赞：3)

18本
楼上 @远航之曲 的题解非常正确。虽然这道题有更优秀的线段数解法，但是毕竟可以作为可并堆裸题。只是这道题左偏树的复杂度值得商榷。因为左偏树并不能保持平衡，其深度最差可能是O（n），而寻找某个节点的堆顶需要跳到顶，这个操作的效率可能被退化成O（n）。

一些类似的题目往往不需要。

但是根据bzojdiscuss里的说法，貌似数据是特别设计的，左偏树可以跑过，我就不清楚了。

楼上题解左偏树的写法，有一个下传标记操作，在Del操作和Add操作之前都需要下传标记。我这里有一种不同的方法。

对于每个存在的堆，只会维护一个标记，这个标记的数值表示这个堆中的所有元素都加了这个值。

也就是说，堆中某个点的实际值为点值+标记值。

你可以理解为，任何一个节点，如果不是某个堆得根节点，那么它绝对不会有mark（==0）。为了实现这一点，每次Merge的时候，并不是合并某两个具体的点，而只是合并他们的根节点。每次合并，只会在两个根节点上有标记需要考虑（其他点都没有mark啊。）

合并的时候，我们只能保留一个标记，另一个标记就必须暴力下传到每一个点。这里如果随便下传一个堆，保留另一个堆的mark，复杂度就不能保证。可以用一种类似启发式合并的方法，对堆中每个节点维护一个size，合并标记的时候选择小的堆下传，大的堆标记保留。这样总复杂度是可以证明的。

另外，要明白合并之后，两个堆公用一个标记（现在是一个堆了），我们还需要在下传小堆标记的时候减去大堆标记的影响。

例如，小堆的某个点是2，mark为1，那么这个点的实际值为3.但是如果大堆有一个MARK=3，合并之后共用标记，这个点的值就会变成6，显然是不可以的（因为合并前大堆的标记只对大堆有效）。因此下传小堆标记的时候要下传mark-MARK，这样下传之后该点的值为0，统计的时候加上MARK=3，正好等于3.

具体还有细节需要注意。上代码。（理论复杂度并不慢，只是我自带大常数。）



    
```cpp
#include<cstdio>
#include<iostream>
#include<queue>
using namespace std;
struct heap
{
    struct node
    {
        int val,dist,size;
        int l,r,fa;
    }e[301000];
    int ROOT;
    int mark[301000];
    int getroot(int x)
    {
        while(e[x].fa)    x=e[x].fa;
        return x;
    }
    void pushup(int x)
    {
        if(!x)
            return;
        e[x].size=1;
        if(e[x].l)
            e[x].size+=e[e[x].l].size;
        if(e[x].r)
            e[x].size+=e[e[x].r].size;
    }
    void pushdown(int root,int val)
    {
        e[root].val+=val;
        if(e[root].l)
            pushdown(e[root].l,val);
        if(e[root].r)
            pushdown(e[root].r,val);
    }
    void Mergemark(int x,int y)
    {
        int fx=getroot(x);
        int fy=getroot(y);
        if(fx==fy)
            return;
        int Y=fy,X=fx;
        if(e[fx].size<e[fy].size)
            swap(X,Y);
        pushdown(Y,mark[Y]-mark[X]);
        if(e[fx].val<e[fy].val)
            swap(fx,fy);
        mark[fx]=mark[X];
        mark[fy]=0;
    }
    int Merge2(int x,int y)
    {
        if(!x)    return y;
        if(!y)    return x;
        int fx=getroot(x);
        if(fx==getroot(y))
            return fx;
        if(e[x].val<e[y].val)
            swap(x,y);
//        down(x);
        e[x].r=Merge2(e[x].r,y);
        e[e[x].r].fa=x;
        if(e[e[x].r].dist>e[e[x].l].dist)
            swap(e[x].l,e[x].r);
        if(!e[x].r)
            e[x].dist=0;
        else
            e[x].dist=e[e[x].r].dist+1;
        pushup(x);
        return x;
    }
    int Merge(int x,int y)
    {
        Mergemark(x,y);
        return Merge2(x,y);
    }
    int Del(int x)
    {
        if(!x)    return 0;
        e[e[x].l].fa=0;
        e[e[x].r].fa=0;
        int q=e[x].fa,p=Merge(e[x].l,e[x].r);
        pushup(p);
        e[p].fa=q;
        if(q&&e[q].l==x)
            e[q].l=p;
        if(q&&e[q].r==x)
            e[q].r=p;
        if(!q)
            mark[p]=mark[x];
        while(q)
        {
            if (e[e[q].l].dist<e[e[q].r].dist)
                swap(e[q].l,e[q].r);
            if (e[e[q].r].dist+1==e[q].dist)
                return ROOT;
            e[q].dist=e[e[q].r].dist+1;
            p=q;
            q=e[q].fa;
            pushup(q);
        }
        return p;
    }
    void re(int x,int val)
    {
        mark[x]=0;
        e[x].fa=0;
        e[x].size=1;
        e[x].val=val;
        e[x].dist=0;
        e[x].l=e[x].r=0;
    }
    void Add(int x,int val)
    {
        re(x,val);
        if(!ROOT)    ROOT=x;
        else    ROOT=Merge(ROOT,x);
    }
}hp1,hp2;
int n;
void Merge(int x,int y)
{
    int fx=hp1.getroot(x);
    int fy=hp1.getroot(y);
    if(fx==fy)
        return;
    hp2.ROOT=hp2.Del(fx);
    hp2.ROOT=hp2.Del(fy);
    int z=hp1.Merge(fx,fy);
    hp2.Add(z,hp1.e[z].val+hp1.mark[z]);    
}
void Addpoint(int x,int v)
{
    int fx=hp1.getroot(x);
    hp2.ROOT=hp2.Del(fx);
    int val=hp1.e[x].val;
    if(fx==x)
        if(!hp1.e[x].l&&!hp1.e[x].r)
        {
            hp1.e[x].val+=v;
            hp2.Add(x,hp1.e[x].val+hp1.mark[x]);
            return;
        }
        else
        {
            if(hp1.e[x].l)
                fx=hp1.e[x].l;
            if(hp1.e[x].r)
                fx=hp1.e[x].r;
        }
    hp1.Del(x);
    int z=hp1.getroot(fx);
    hp1.re(x,hp1.e[x].val+v+hp1.mark[z]),z=hp1.Merge(x,z);
    hp2.Add(z,hp1.e[z].val+hp1.mark[z]);
}
void Addlink(int x,int v)
{
    int fx=hp1.getroot(x);
    hp1.mark[fx]+=v;
    hp2.ROOT=hp2.Del(fx);
    hp2.Add(fx,hp1.e[fx].val+hp1.mark[fx]);
}
int buff=0;
void Addheap(int v)
{
    buff+=v;
}
int Getpoint(int x)
{
    int addition=hp1.mark[hp1.getroot(x)];
    return hp1.e[x].val+addition+buff;
}
int Getlink(int x)
{
    int fx=hp1.getroot(x);
    return hp1.mark[fx]+hp1.e[fx].val+buff;
}
int Getheap()
{
    return hp2.e[hp2.ROOT].val+buff;
}
int a[301000];
queue<int> q;
int main()
{
    scanf("%d",&n);
    hp2.e[0].dist=-1;
    hp1.e[0].dist=-1;
    for(int i=1;i<=n;++i)
        scanf("%d",&a[i]),hp1.re(i,a[i]),hp2.re(i,a[i]),q.push(i);
    while(!q.empty())
    {
        int a1=q.front();
        q.pop();
        if(q.empty())
            break;
        int a2=q.front();
        q.pop();
        hp2.ROOT=hp2.Merge(a1,a2);
        q.push(hp2.ROOT);
    }
    int q;
    scanf("%d",&q);
    while(q--)
    {
        char s[3];
        int x,y,v;
        scanf("%s",&s);
        if(s[0]=='U')
        {
            scanf("%d %d",&x,&y);
            Merge(x,y);
        }
        if(s[0]=='A')
        {
            if(s[1]=='1'){    scanf("%d %d",&x,&v);    Addpoint(x,v);    }
            if(s[1]=='2'){    scanf("%d %d",&x,&v);    Addlink(x,v);    }
            if(s[1]=='3'){    scanf("%d",&v);    Addheap(v);                }
        }
        if(s[0]=='F')
        {
            int ans=0;
            if(s[1]=='1'){    scanf("%d",&x);    ans=Getpoint(x);}
            if(s[1]=='2'){    scanf("%d",&x);    ans=Getlink(x);    }
            if(s[1]=='3')    ans=Getheap();
            printf("%d\n",ans);
        }
    }
    return 0;
}
```

---

## 作者：KellyFrog (赞：2)

~~竟然没有重构树的题解（~~

对于加边，且之和连通性有关问题，我们一般有三种处理方式：

1. 采用可合并的数据结构，比如左偏树、线段树合并或者冰茶姬
2. 直接用数据结构维护，比如 LCT
3. 把操作离线，将时间信息扔到图上，即这个题解用的重构树

我们按照加边时间从小到大合并冰茶姬，如果两个联通块还没联通，就建一个虚点，和两个连通块的根连边，同时将虚点作为新连通块的根，虚点点权是这次的是第几次加边。

我们再记录每个操作是在第几次加边之后的，然后正序处理询问，在树上倍增到进行这次操作时连通块的根。

这样我们就把问题变成了树上问题，直接 dfs 序线段树就可以了，时间复杂度 $O((n+q)\log n)$

```cpp

// Problem: P3273 [SCOI2011]棘手的操作
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P3273
// Memory Limit: 125 MB
// Time Limit: 1000 ms
// Powered by CP Editor (https://github.com/cpeditor/cpeditor)


// Happy Chinese new year! (Feb. 12th, 2021)

/*
 * Codeforces @Chenkaifeng
 * Luogu @longer_name
 */

#include <bits/stdc++.h>

using namespace std;

typedef long long ll;
typedef unsigned long long ull;
typedef double db;
typedef long double ldb;
typedef vector<int> vi;
typedef pair<int, int> pii;
#define fi first
#define se second
#define rg register
#define mp make_pair
#define pb push_back
#define pf push_front

#define rep(i, s, t) for (rg int i = s; i <= t; i++)
#define per(i, s, t) for (rg int i = t; i >= s; i--)
#define OK cerr << "OK!\n"

namespace fastio {
const int SIZE = (1 << 20) + 1;
char ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = obuf + SIZE - 1;
char _st[55];
int _qr = 0;

inline char getchar() {
  return (iS == iT ? iT = (iS = ibuf) + fread(ibuf, 1, SIZE, stdin),
          (iS == iT ? EOF : *iS++) : *iS++);
}
inline void qread() {}
template <typename T1, typename... T2>
inline void qread(T1 &x, T2 &...ls) {
  x = 0;
  rg char ch = ' ';
  rg int ps = 1;
  while (!isdigit(ch) && ch != '-') ch = getchar();
  if (ch == '-') ps = -1, ch = getchar();
  while (isdigit(ch)) x = x * 10 + ch - '0', ch = getchar();
  x *= ps;
  qread(ls...);
}

inline void flush() {
  fwrite(obuf, 1, oS - obuf, stdout);
  oS = obuf;
  return;
}
inline void putchar(char _x) {
  *oS++ = _x;
  if (oS == oT) flush();
}
template <typename T>
inline void qwrite(T x) {
  if (x < 0) putchar('-'), x = -x;
  if (x < 10) return putchar('0' + x), void();
  qwrite(x / 10), putchar('0' + (x % 10));
}

template <typename T>
inline void qwrite(T x, char ch) {
  qwrite(x), putchar(ch);
}
};  // namespace fastio

const int N = 3e5 + 5;
const int inf = 1e9;

struct Opt {
	int op, x, y;
};

Opt qry[N];

int mx[N << 2], lazy[N << 2];
int fa[N << 1][21], weight[N<<1], uni[N], rt[N];
int dfn[N], dfncnt;
int a[N], tot;
int L[N<<1], R[N<<1];
int n, m;
int adj[N<<1][2];

inline int Find(int x) {
	return x == uni[x] ? x : uni[x] = Find(uni[x]);
}

inline void Lazy(int cur, int x) {
	mx[cur] += x;
	lazy[cur] += x;
}

inline void PushDown(int cur) {
	if(lazy[cur]) {
		Lazy(cur << 1, lazy[cur]);
		Lazy(cur << 1 | 1, lazy[cur]);
		lazy[cur] = 0;
	}
}

inline void PushUp(int cur) {
	mx[cur] = max(mx[cur << 1], mx[cur << 1 | 1]);
}

inline void Modify(int cur, int p, int x, int l, int r) {
	if(l == r) return mx[cur] = x, void();
	PushDown(cur);
	rg int mid = l + r >> 1;
	if(p <= mid) Modify(cur << 1, p, x, l, mid);
	else Modify(cur << 1 | 1, p, x, mid + 1, r);
	PushUp(cur);
}

inline void Add(int cur, int ql, int qr, int x, int l, int r) {
	if(ql <= l && r <= qr) return Lazy(cur, x), void();
	PushDown(cur);
	rg int mid = l + r >> 1;
	if(ql <= mid) Add(cur << 1, ql, qr, x, l, mid);
	if(mid < qr) Add(cur << 1 | 1, ql, qr, x, mid+1, r);
	PushUp(cur);
}

inline int Max(int cur, int ql, int qr, int l, int r) {
	if(ql <= l && r <= qr) return mx[cur];
	PushDown(cur);
	rg int mid = l + r >> 1;
	rg int res = -inf;
	if(ql <= mid) res = max(res, Max(cur << 1, ql, qr, l, mid));
	if(mid < qr) res = max(res, Max(cur << 1 | 1, ql, qr, mid + 1, r));
	return res;
}

inline void Dfs(int u, int f) {
	//debug("Dfs={} {}\n", u, f);
	L[u] = n+1;
	R[u] = -1;
	fa[u][0] = f;
	rep(i, 1, 20) fa[u][i] = fa[fa[u][i-1]][i-1];
	if(1 <= u && u <= n) {
		L[u] = R[u] = dfn[u] = ++dfncnt;
		return;
	}
	rep(i, 0, 1) {
		int v = adj[u][i];
		//if(v == 0) continue;
		Dfs(v, u);
		L[u] = min(L[u], L[v]);
		R[u] = max(R[u], R[v]);
	}
}

inline int GetT(int x, int t) {
	per(i, 0, 20) {
		if(fa[x][i] && weight[fa[x][i]] <= t) x = fa[x][i];
	}
	return x;
}

int main() {
	scanf("%d", &n);
	rep(i, 1, n) scanf("%d", &a[i]);
	rep(i, 1, n) uni[i] = rt[i] = i;
	scanf("%d", &m);
	tot = n;
	int p = 0;
	rep(i, 1, m) {
		char ch; int op;
		cin >> ch;
		if(ch == 'U') {
			p++;
			qry[i].op = 1;
			scanf("%d%d", &qry[i].x, &qry[i].y);
			int x = qry[i].x, y = qry[i].y;
			x = Find(x);
			y = Find(y);
			if(x == y) continue;
			tot++;
			weight[tot] = p;
			adj[tot][0] = rt[x];
			adj[tot][1] = rt[y];
			rt[y] = tot;
			uni[x] = y;
		} else if(ch == 'A') {
			scanf("%d%d%d", &op, &qry[i].x, &qry[i].y);
			qry[i].op = 1 + op;
		} else {
			scanf("%d", &op);
			if(op < 3) scanf("%d", &qry[i].x);
			qry[i].op = 4 + op;
		}
	}
	int tm = 0;
	per(i, 1, tot) if(!L[i]) Dfs(i, 0);
	rep(i, 1, n) Modify(1, dfn[i], a[i], 1, n);
	rep(i, 1, m) {
		if(qry[i].op == 1) {
			tm++;
		} else if(qry[i].op == 2) {
			Add(1, dfn[qry[i].x], dfn[qry[i].x], qry[i].y, 1, n);
		} else if(qry[i].op == 3) {
			int x = GetT(qry[i].x, tm);
			Add(1, L[x], R[x], qry[i].y, 1, n);
		} else if(qry[i].op == 4) {
			Add(1, 1, n, qry[i].x, 1, n);
		} else if(qry[i].op == 5) {
			fastio::qwrite(Max(1, dfn[qry[i].x], dfn[qry[i].x], 1, n), '\n');
		} else if(qry[i].op == 6) {
			int x = GetT(qry[i].x, tm);
			fastio::qwrite(Max(1, L[x], R[x], 1, n), '\n');
		} else if(qry[i].op == 7) {
			fastio::qwrite(mx[1], '\n');
		}
	}
  fastio::flush();
  return 0;
}
```

---

## 作者：轻尘 (赞：2)

## 看着道题的题解这么少，蒟蒻也来凑一篇。


------------

### 蒟蒻调了两天的题目，不得不说是真的毒瘤。大佬们都用什么左偏树，可并堆啥的，弱弱的我只得用并查集+线段树。

### 在这里还要说一下，我用的是dfs序的线段树，据说要更优秀一点emmm，大家可以试着理解一下，只是标号方式不同，其他与普通的线段树没什么不同。此处不在赘述。模版链接[线段树模版](http://tch.drifts.ml/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%A8%A1%E7%89%88/215/)
------------

![PBgWQO.png](https://s1.ax1x.com/2018/08/04/PBgWQO.png)
#### 思想： 现在我们只需要先模拟一遍加边过程（利用并查集），顺便把数据存储一下~~（面向数据的编程QAQ）~~，然后重新把数据排个序，将同一个联通块内的数放在一起，再用线段树维护一下单点、区间修改和区间最大值查询。岂不美哉？
#### 然鹅思想易懂，代码难写。并且为什么联通块内的点一定在一个连续的区间内呢？，这时候就要链表上场了QWQ。同摘录中说的，在并查集连边之后，一个联通块内的点都连成一条链，我们只要用双向链表把它们记下即可。可还记得邻接表，用相似的思想，我们写出了双向链表。
```cpp
void unionn(int x,int y)
{
    int r1=find(x),r2=find(y);
    if(r1!=r2)
    {
        f[r2]=r1;
        int u=lst[r1],v=fir[r2];
		lst[r1]=lst[r2];
        pre[u]=v,next[v]=u;//双向链表!!!
    }
   // QAQ;
}
```
#### lst[]用来存主体（就像head[]数组），per[]和next[]一个正向，一个反向。同时我们发现，链表的加入与并查集的合并是一起的~~（废话，都写到一起了）~~,也就是说我们重建后的数组中同一联通块内的点一定在一个连续的区间内，而且顺序是加入的先后顺序，是不是很神奇？QWQ。
#### 下面是重建数组部分
```cpp
int tot = 0;
   for (int i = 1; i <= n; i++)//遍历一下找表头
        if (!pre[i])
            for (int j = i; j; j = next[j])//向后找儿子
                pos[j] = ++tot，newa[tot] = j;//newa->新数组（标记当前点在原数组中的位置）
							//pos[]->反向记录位置。
```
#### 再然后我们维护了一个l[]、一个r[]来记录左右边界（因为连续嘛）在重新建边是，只要如下就好，自己可以试着理解一下
### code
```cpp
void reunion(int x,int y)
{
    int r1=find(x),r2=find(y);
    if(r1!=r2)
    {
        f[r2]=r1;
        if(l[r1]<l[r2]) r[r1]=r[r2];
        else l[r1]=l[r2];
    }
}
```
####  emmmm，线段树部分和模板没什么差别，就讲这么多吧，毕竟还要靠自己去悟啊，多说无益，上代码！！
### code
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#define QAQ cout<<"debug"<<endl
const int  maxn = 3000000;
using namespace std;
int n,f[maxn],lst[maxn],next[maxn],pre[maxn],pos[maxn];
int l[maxn],r[maxn],cnt=1,newa[maxn],a[maxn],fir[maxn];
struct option
{
    int x,y,v;
    char opt;
}data[maxn];
struct segtree
{
    int lc,rc,sum,tag;
}tree[maxn];
//////////////////////
int find(int x)
{
    if(f[x]==x) return x;
    else return f[x]=find(f[x]);
}
void unionn(int x,int y)
{
    int r1=find(x),r2=find(y);
    if(r1!=r2)
    {
        f[r2]=r1;
        int u=lst[r1],v=fir[r2];
		lst[r1]=lst[r2];
        pre[u]=v,next[v]=u;//双向链表!!!
    }
   // QAQ;
}
void reunion(int x,int y)
{
    int r1=find(x),r2=find(y);
    if(r1!=r2)
    {
        f[r2]=r1;
        if(l[r1]<l[r2]) r[r1]=r[r2];
        else l[r1]=l[r2];
    }
}
/////////并查集部分！！
/////////////////
void pushup(int u)
{
    tree[u].sum=max(tree[tree[u].lc].sum+tree[tree[u].lc].tag,tree[tree[u].rc].sum+tree[tree[u].rc].tag);
}//不多bb；
void pushdown(int u)
{
    tree[tree[u].lc].tag+=tree[u].tag;
    tree[tree[u].rc].tag+=tree[u].tag;
    tree[u].tag=0;
}//不多bb
void build(int u,int l,int r)//建树
{
    if(l==r)
    {
        tree[u].sum=a[newa[l]];
        return ;
    }
    tree[u].lc=++cnt;
    int mid=(l+r)>>1;
    build(tree[u].lc,l,mid);
    tree[u].rc=++cnt;
    build(tree[u].rc,mid+1,r);
    //tree[u].sum=max(tree[tree[u].lc].sum,tree[tree[u].rc].sum);
    pushup(u);
}
void add(int u,int l,int r,int ll,int rr,int w)
{
//	QAQ;
    if(l==ll&r==rr)
    {
        tree[u].tag+=w;
        return;
    }
    pushdown(u);
    int mid=(l+r)>>1;
    if(rr<=mid) add(tree[u].lc,l,mid,ll,rr,w);
    else if(ll>mid) add(tree[u].rc,mid+1,r,ll,rr,w);
    else
    {
        add(tree[u].lc,l,mid,ll,mid,w);
        add(tree[u].rc,mid+1,r,mid+1,rr,w);
    }
    pushup(u);
}
int query(int u,int l,int r,int ll,int rr)
{
	int ans=0;
    if(l==ll&r==rr)
        return tree[u].sum+tree[u].tag;
    pushdown(u);
    int mid=(l+r)>>1;
    if(rr<=mid) ans=query(tree[u].lc,l,mid,ll,rr);
    else if(ll>mid) ans=query(tree[u].rc,mid+1,r,ll,rr);
    else
    {
        ans=max(query(tree[u].lc,l,mid,ll,mid),query(tree[u].rc,mid+1,r,mid+1,rr));
    }
    pushup(u);
    return ans;
}
inline int read()
{
    int res = 0;
    bool bo = 0;
    char c;
    while (((c = getchar()) < '0' || c > '9') && c != '-')
        ;
    if (c == '-')
        bo = 1;
    else
        res = c - 48;
    while ((c = getchar()) >= '0' && c <= '9')
        res = (res << 3) + (res << 1) + (c - 48);
    return bo ? ~res + 1 : res;
}
inline char get1()
{
    char c;
    while ((c = getchar()) != 'A' && c != 'F' && c != 'U')
        ;
    return c;
}
inline int get2()
{
    char c;
    while ((c = getchar()) < '0' || c > '9')
        ;
    return c - 48;
}
int main()
{
    int i, j, Q, id, tot = 0;
    n = read();
    for (i = 1; i <= n; i++)
        a[i] = read(),
        f[i] = fir[i] = lst[i] = i;
    Q = read();
    for (i = 1; i <= Q; i++)
    {
        char c = get1();
        switch (c)
        {
        case 'U':
            data[i].x = read();
            data[i].y = read();
            unionn(data[i].x, data[i].y);
            data[i].opt = 1;
            break;
        case 'A':
            id = get2();
            data[i].x = read();
            if (id < 3)
                data[i].y = read();
            data[i].opt = id + 1;
            break;
        case 'F':
            id = get2();
            if (id < 3)
                data[i].x = read();
            data[i].opt = id + 4;
            break;
        }
    }
    for (i = 1; i <= n; i++)
        if (!pre[i])
            for (j = i; j; j = next[j])
                newa[pos[j] = ++tot] = j;
    for (i = 1; i <= n; i++)
        f[i] = i, l[i] = r[i] = pos[i];
    build(1,1, n);
    for (i = 1; i <= Q; i++)
        switch (data[i].opt)
        {
        case 1:
            reunion(data[i].x, data[i].y);
            break;
        case 2:
            //cout<<data[i].y<<endl;
            add(1,1, n, pos[data[i].x], pos[data[i].x], data[i].y);
            break;
        case 3:
            id = find(data[i].x);
            add(1,1, n, l[id], r[id], data[i].y);
            break;
        case 4:
            add(1, 1,n, 1, n, data[i].x);
            break;
        case 5:
            printf("%d\n", query(1,1, n, pos[data[i].x], pos[data[i].x]));
            break;
        case 6:
            id = find(data[i].x);
            printf("%d\n", query(1,1, n, l[id], r[id]));
            break;
        case 7:
            printf("%d\n", query(1,1, n, 1, n));
            break;
        }
    return 0;
}

```
### PS：主函数借鉴了一下n层楼上的代码，在此声明一下。
# 安利一下博客[蒟蒻的blog](http://tch.drifts.ml "蒟蒻的blog")

---

## 作者：山水一程_ (赞：2)

### 此题用可并堆勉强过，需加输入优化，但是这里有个问题就是set总是过不了一组数据，用multiset时间有点高，不懂这个问题，请懂此问题的给我留言。
## 左偏树+并查集
# 下面上代码：
```cpp
#include <cstdio>
#include <cstring>
#include <string>
#include <algorithm>
#include <cmath>
#include <cstdlib>
#include <utility>
#include <map>
#include <set>
#include <queue>
#include <vector>
#include <iostream>
#include <stack>
using namespace std;
#define INF 0x3f3f3f3f
#define eps 1e-6
#define CLR( a, v ) memset ( a, v, sizeof ( a ) )
#define LL long long
#define DBUG printf ( "here!!!\n" )
#define rep( i, a, b ) for ( int i = ( a ); i < ( b ); i ++ )
#define PB push_back
#define ULL unsigned long long
#define PI acos ( -1.0 )
#define lson l, m, rt << 1
#define rson m+1, r, rt << 1 | 1
#define lowbit( x ) ( ( x )&( -x ) )
#define CASE int Test; scanf ( "%d", &Test ); for ( int cas = 1; cas <= Test; cas ++ )
#define ALL( x ) x.begin ( ), x.end ( )
#define INS( x ) x, x.begin ( )
typedef pair < int, int > Pii;
typedef pair < double, double > Pdd;
typedef set < int > Set;
const int maxn = 300005;
int read_int ( ) {
	int res = 0, f = 1;
	int ch = getchar ( );
	while ( ch < '0' || ch > '9' ) {
		if ( ch == -1 )
			return -1;
		if ( ch == '-' )
			f = -1;
		ch = getchar ( );
	}
	while ( ch >= '0' && ch <= '9' ) {
		res = res*10+( ch-'0' );
		ch = getchar ( );
	}
	return res*f;
}
int rt[maxn], ch[maxn][2], sum[maxn], S[maxn], c;
int con[maxn], fa[maxn], a[maxn], dis[maxn];
int find ( int x ) {
	return con[x] == x ? x : con[x] = find ( con[x] );
}
void PushDown ( int u ) {
	if ( sum[u] ) {
		if ( ch[u][0] ) {
			sum[ ch[u][0] ] += sum[u];
			a[ ch[u][0] ] += sum[u];
		}
		if ( ch[u][1] ) {
			sum[ ch[u][1] ] += sum[u];
			a[ ch[u][1] ] += sum[u];
		}
		sum[u] = 0;
	}
}
void PushAll ( int x ) {
	c = 0;
	while ( x ) {
		S[c ++] = x;
		x = fa[x];
	}
	while ( c > 0 )
		PushDown ( S[-- c] );
}
int Merge ( int u, int v ) {
	if ( u == 0 )
		return v;
	if ( v == 0 )
		return u;
	if ( a[u] < a[v] )
		swap ( u, v );
	PushDown ( u );
	ch[u][1] = Merge ( ch[u][1], v );
	fa[ ch[u][1] ] = u;
	if ( dis[ ch[u][0] ] < dis[ ch[u][1] ] )
		swap ( ch[u][0], ch[u][1] );
	dis[u] = dis[ ch[u][1] ]+1;
	return u;
}
void remove ( int u ) {
	PushAll ( u );
	int p = fa[u];
	int x = Merge ( ch[u][0], ch[u][1] );
	fa[x] = p;
	ch[p][ ch[p][1] == u ] = x;
	while ( p ) {
		if ( dis[ ch[p][0] ] < dis[ ch[p][1] ] )
			swap ( ch[p][0], ch[p][1] );
		if ( dis[ ch[p][1] ]+1 == dis[p] )
			break ;
		dis[p] = dis[ ch[p][1] ]+1;
		p = fa[p];
	}
}
multiset < int > vis;
void solve ( ) {
	int n, Q, x, v, fx, fy, all = 0;
	char op[5];
	dis[0] = -1;
	n = read_int ( );
	vis.clear ( );
	for ( int i = 1; i <= n; i ++ ) {
		a[i] = read_int ( );
		rt[i] = con[i] = i;
		vis.insert ( a[i] );
	}
	Q = read_int ( );
	while ( Q -- ) {
		scanf ( "%s", op );
		if ( op[0] == 'U' ) {
			x = read_int ( ), v = read_int ( );
			fx = find ( x ), fy = find ( v );
			if ( fx == fy )
				continue ;
			con[fx] = fy;
			vis.erase ( vis.find ( min ( a[ rt[fx] ], a[ rt[fy] ] ) ) );
			rt[fy] = Merge ( rt[fy], rt[fx] );
			fa[ rt[fy] ] = 0;
		} else if ( op[0] == 'A' ) {
			if ( op[1] == '1' ) {
				x = read_int ( ), v = read_int ( );
				fx = find ( x );
				vis.erase ( vis.find ( a[ rt[fx] ] ) );
				if ( x != rt[fx] )
					remove ( x );
				else {
					PushDown ( x );
					rt[fx] = Merge ( ch[x][0], ch[x][1] );
					fa[ rt[fx] ] = 0;
				}
				sum[x] = fa[x] = ch[x][0] = ch[x][1] = 0;
				a[x] += v;
				rt[fx] = Merge ( rt[fx], x );
				vis.insert ( a[ rt[fx] ] );
				fa[ rt[fx] ] = 0;
			} else if ( op[1] == '2' ) {
				x = read_int ( ), v = read_int ( );
				fx = find ( x );
				vis.erase ( vis.find ( a[ rt[fx] ] ) );
				a[ rt[fx] ] += v;
				vis.insert ( a[ rt[fx] ] );
				sum[ rt[fx] ] += v;
			} else if ( op[1] == '3' ) {
				v = read_int ( );
				all += v;
			}
		} else if ( op[0] == 'F' ) {
			if ( op[1] == '1' ) {
				x = read_int ( );
				PushAll ( x );
				printf ( "%d\n", a[x]+all );
			} else if ( op[1] == '2' ) {
				x = read_int ( );
				fx = find ( x );
				printf ( "%d\n", a[ rt[fx] ]+all );
			} else if ( op[1] == '3' )
				printf ( "%d\n", *( -- vis.find ( INF ) )+all );
		}
	}
}
int main ( ) {
	solve ( );
	return 0;
}

```
# 感谢观看


---

## 作者：Juan_feng (赞：1)

## Leafy Tree 题解！

~~几天不写数据结构浑身难受.jpg~~

嗯呐蒟蒻就不废话了， 直接进入正题qwq



### 我们就直接来顺一下思路吧qwq

**操作1**： **加边**： 找到两个根直接把根merge起来

**操作2**：**将x节点的权值增加k** ： 先找到根， 同时对经过的路径做标记， 这样找到跟之后， 我们再顺着做好的标记往下推add标记， 推回到x节点之后， 修改x的值， 然后pushup。

**操作3**： **x所在连通块整体+k**： 找到x的根， 打add标记

**操作4**： **全局加k**：  我们发现全局加只要用一个变量ss维护一下就可以了， 用不着修改我们的树。

**操作5**： **输出一个节点的值**： 找到根， 同时对经过的路径做标记， 然后下推add标记， 最后输出x节点的值+ss。

**操作6**： **输出x连通块的最大值**： 找到根， 直接输出根所维护的最大值+ss。

**操作7**： **输出全局最大值**： 这里我们发现， 必须单独维护一下这个最大值了， 当然还是可以用Leafy Tree。 我们一开始把所有点的权值都插进这棵Leafy 然后每次合并或者修改的时候就在这棵Leafy上瞎搞就行了。

这里要说明一下， Leafy不像左偏树， ta的树高是可以保障的， 所以找根的时候可以直接像下面这样：
```
inline int find(int x) {
    while(fa[x])
      x = fa[x];
    return x;
}
```
而且我们发现一开始所保存的节点的序号始终不会发生改变， 这样我们第x个节点的ID肯定是x， 查询的时候就很容易啦。

另外还要注意一点: 开始的时候别忘了加上哨兵， 不然会RE3#， 且蒟蒻的代码没有手写内存池， 不过既然不写也能过就懒得加上去了qaqaq

那么这道题也就愉快的解决啦>_<！

代码如下：

```
#include <iostream>
#include <cmath>
#include <cstring>
#include <string>
#include <cstdio>
#define maxn 18000010
#define re register
#define FOR(i, l, r) for(re int i = l; i <= r; ++i)
using namespace std;

int n, m, c, r, t, x, y, z, k;
int a[maxn], b[maxn], siz[maxn], fa[maxn], son[maxn][2], dis[maxn], maxx[maxn], tag[maxn];
int cnt, res;
int root; //leafy2的根 
const double alp = 1.0-sqrt(2)/2, lim = (1.0-2*alp)/(1.0-alp), spl = alp/(1.0-alp);
int ex = 0;
char ch;

inline void in(re int &x){
    x=0;int f=1;char c=getchar();
    while(c<'0'||c>'9'){
        if(c==-1) return;
        if(c=='-')f=-1;
        c=getchar();
    }
    while(c<='9'&&c>='0'){
        x=(x<<1)+(x<<3)+(c^'0');
        c=getchar();
    }
    x=x*f;
}

void out(int a){
    if(a<0){
        a*=-1;
        putchar('-');
    } 
    if(a>=10)out(a/10);
    putchar(a%10+'0');
}

inline int ifr(int x) {
    return x == son[fa[x]][1];
}  

inline int New() {
    ++cnt;
    return cnt;
}

inline int NNew(int x) {
    ++cnt;
    maxx[cnt] = x;
    siz[cnt] = 1;
    return cnt;
} 

inline void Clear(int x) {
    siz[x] = fa[x] = son[x][0] = son[x][1] = tag[x] = 0;
    maxx[x] = -99999;
}

inline void push_up(int x) {
    if(son[x][0]) {
        siz[x] = siz[son[x][0]] + siz[son[x][1]];
        maxx[x] = max(maxx[son[x][0]], maxx[son[x][1]]);
    }
} 

inline void push_down(int x) {
    if(son[x][0] && tag[x]) {
        maxx[son[x][0]] += tag[x];
        maxx[son[x][1]] += tag[x];
        tag[son[x][0]] += tag[x];
        tag[son[x][1]] += tag[x];
        tag[x] = 0;
    }
}

inline void rotate(int x) {
    int f = fa[x], ff = fa[f], pd1 = ifr(x), pd2 = ifr(f), t = son[x][pd1^1];
    son[ff][pd2] = x;
    son[x][pd1^1] = f;
    son[f][pd1] = t;
    fa[t] = f;
    fa[f] = x;
    fa[x] = ff;
    push_up(f);
    push_up(x);
    if(f == root)
      root = x;
}

inline void maintain(int x) {
    int pd;
    if(son[x][0]) {
        if(siz[son[x][0]] < siz[x]*alp)
          pd = 1;
        else
          if(siz[son[x][1]] < siz[x]*alp)
            pd = 0;
          else
            return;
        if(siz[son[son[x][pd]][pd^1]] >= siz[son[x][pd]]*lim)
          rotate(son[son[x][pd]][pd^1]);
        rotate(son[x][pd]);
    }
}

void ins(int now, int x) {
    if(!root) {
        root = NNew(x);
        return;
    }
    if(siz[now] == 1) {
        fa[son[now][0] = NNew(x)] = now;
        fa[son[now][1] = NNew(maxx[now])] = now;
        if(x > maxx[now])
          swap(son[now][0], son[now][1]);
    }
    else  ins(son[now][x > maxx[son[now][0]]], x);
    push_up(now);
    maintain(now);
}

void del(int now, int x) {
    int sid = x > maxx[son[now][0]], t;
    if(siz[son[now][sid]] == 1) {
        Clear(son[now][sid]);
        fa[t = son[now][sid^1]] = fa[now];
        son[fa[now]][ifr(now)] = t;
        Clear(now);
        if(now == root)
          root = t;
        now = t;
    }
    else  del(son[now][sid], x);
    push_up(now);
    maintain(now);
}

inline int merge(int u, int v) {
    if(!u || !v)  return u+v;
    push_down(u), push_down(v);
    if(siz[u] >= siz[v] && siz[v] >= siz[u]*spl || siz[v] >= siz[u] && siz[u] >= siz[v]*spl) {
        int cur = New();
        fa[son[cur][0] = u] = cur;
        fa[son[cur][1] = v] = cur;
        push_up(cur);
        return cur;
    } 
    if(siz[u] >= siz[v]) {
        push_down(u);
        int ls = son[u][0], rs = son[u][1];
        Clear(u);
        if(siz[ls] >= (siz[ls]+siz[rs]+siz[v])*alp) 
          return merge(ls, merge(rs, v));
        push_down(rs);
        int lrs = son[rs][0], rrs = son[rs][1];
        Clear(rs);
        return merge(merge(ls, lrs), merge(rrs, v));
    }
    else {
        push_down(v);
        int ls = son[v][0], rs = son[v][1];
        Clear(v);
        if(siz[rs] >= (siz[ls]+siz[rs]+siz[u])*alp) 
          return merge(merge(u, ls), rs);
        push_down(ls);
        int lls = son[ls][0], rls = son[ls][1];
        Clear(ls);
        return merge(merge(u, lls), merge(rls, rs));
    }
}

inline int find(int x) {
    while(fa[x])
      x = fa[x];
    return x;
}
    
inline int mark_up(int x) { //标记并找根 
    while(fa[x]) 
      dis[x] = 1, x = fa[x];
    return x;
}
    
void clear_down(int x, int k) { //顺着标记往下找并清除标记, 修改数据 
    if(siz[x] == 1) {
        dis[x] = 0;
        maxx[x] += k;
        return;
    }
    push_down(x);
    if(dis[son[x][0]])
      clear_down(son[x][0], k);
    if(dis[son[x][1]])
      clear_down(son[x][1], k);
    push_up(x);
    dis[x] = 0; 
}
  
int main() {
    in(n);
    cnt = n;
    ins(root, -0x7fffffff);
    FOR(i, 1, n) {
    	in(maxx[i]),
        siz[i] = 1;
        ins(root, maxx[i]);
    }
    in(m);
    FOR(i, 1, m) {
    	ch = getchar();
    	while(ch != 'U' && ch != 'A' && ch != 'F')
    	  ch = getchar();
        if(ch == 'U') {
        	in(x), in(y);
            int fx = find(x), fy = find(y);
            if(fx != fy) {
            	del(root, maxx[fx]);
            	del(root, maxx[fy]);
            	ins(root, maxx[merge(fx, fy)]);
            }
            //这个地方需要维护一下leafy2 
        }
        if(ch == 'A') {
            ch = getchar();
            if(ch == '1') {
                in(x), in(k);
                int xx = mark_up(x);
                del(root, maxx[xx]); //leafy2
                //沿着标记找到x且下推标记, 最终修改并上推 
                //维护leafy2; 
                clear_down(xx, k);
                ins(root, maxx[xx]); //新旧交替 
            }
            if(ch == '2') {
                in(x), in(k);
                int xx = find(x);
                tag[xx] += k;
                
                del(root, maxx[xx]);
                maxx[xx] += k;
                ins(root, maxx[xx]);
            }
            if(ch == '3') {
                in(k);
                ex += k;
            }
        }
        if(ch == 'F') {
            ch = getchar();
            if(ch == '1') {
                in(x);
                int xx = mark_up(x);
            
                clear_down(xx, 0);	//沿着标记找到x且下推标记;
                out(maxx[x]+ex), putchar(10);
            }
            if(ch == '2') {
                in(x);
                int xx = find(x);
                out(maxx[xx]+ex), putchar(10);
                //注意与上面的不同 
            }
            if(ch == '3') {
                out(maxx[root]+ex), putchar(10);
            }
        }
    }
}
```

---

## 作者：啊嘞嘞嘞嘞 (赞：1)

哇哇哇大佬都出左偏树了  然而我并不会

操作很多，但每个都没那么复杂。合并2个点所处的连通块，很容易想到并查集。

需要支持操作：1.合并2个点所在的连通块。2.对单点、连通块进行add、求最值。3.求所有点中的最值。全局加实际上没啥用。

显然在连通块加tag是不可行的，并查集合并做不到，而且全局求最值不可行。只能将这题转化成维护序列，需要一个支持动态RMQ的数据结构，这里选择线段树。

如果按原来的序号进行处理序列，显然不可行，每个连通块里的点的序号没有任何顺序，根本不能维护。

我们希望，每个连通块中点的序号的连续的。可以联想到树剖，通过dfs序来构建序列。这里用不到dfs序，只是用到了维护非线性序列的思路。因为序数受到并集的影响，只能用离线做法，先处理好序数，再回答。

这里我用了二叉树。

合并连通块，为了方便，用连通块中原下标最小的点表示它。需要记录连通块的大小。每次只合并2个集合，得到一个新集合，新集合表示的区间是两个子集的并。显然如果两个子区间正好相邻，那么合并的逆向操作，就是将一个区间从中间拆开！想到什么了？线段树！这里需要的就是线段树的区间思想。现在我们要做的就是重排n个区间，使得每次合并的都是相邻2个区间。方便起见，用区间的最小下标表示区间，附加一个区间大小。

合并区间必须保留原区间，所以要动态开点，这个新区间要记录2个子区间在数组的位置、一个端点的原下标、区间大小。用cur[i]记录i所处的最大集合的位置。相当于自下而上建立一棵二叉树。因为最终并不一定只有一个集合，所以是森林。但没关系。

上面说的可能不是很好，我重新梳理一下流程

1.  c[]数组存集合（区间）。预处理n个集合（区间），每个区间无子区间，在c[]中下标即为i，大小为1，fa指向自己

2.  读入所有操作，对于修改和查询，只需记录点和值（如果是对连通块的操作，要记录的是连通块的最小下标）。对于并集，先检查是否在同一集合。如果不是，并集（siz也并上，确保u<v，并入u），c[]后面加一个新区间，左右孩子为cur[u]和cur[v]，区间长度为c[cur[u]].siz+c[cur[v]].siz，然后更新cur[u]

3.  逆向循环建树。这里可以用递归。取出c[i]这个集合，区间长度为c[i].siz，则区间为[s,s+c[i].siz-1]（s为可用的最小编号），如果它的大小不为1，递归左右结点，记得根据孩子的siz分割区间，如果它的大小为1，说明是叶结点，pos[i]即为l或r。这样我们就得到了想要的区间。

4.  回答询问。初始化siz[i]为1，遇到合并操作，就只合并siz。处理连通块时，区间为[pos[u],pos[u]+siz[u]-1]（已经确保u是区间左端点）

复杂度不是很优秀。操作没什么特别麻烦的。样例很良心，我过了样例就成功A这题了。

```cpp
#include <cstdio>
#include <cstring>
#define MAXN 300010
using namespace std;
int n,m,a[MAXN];
int fa[MAXN],siz[MAXN],pos[MAXN],cur[MAXN]; //cur表示集合当前下标
int q[MAXN][3];
struct node { int p,lc,rc,siz; } c[MAXN*2]; //p貌似没什么用
int tot; //结点数
inline int max(int a,int b) { return a<b ? b : a; }
template <class T,int size>
struct segment_tree {
	T addv[size],maxv[size];
	void build(int p,int l,int r,T* a){
		if (l==r) {
			maxv[p]=a[l];
		} else {
			int mid=l+r>>1;
			int lc=p<<1,rc=p<<1|1;
			build(lc,l,mid,a);
			build(rc,mid+1,r,a);
			maintain(p,l,r);
		}
	}
	inline void maintain(int p,int l,int r) {
		maxv[p]=max(maxv[p<<1],maxv[p<<1|1]);
	}
	void pushdown(int p,int l,int r) {
		if (l>r) return;
		maxv[p<<1]+=addv[p], maxv[p<<1|1]+=addv[p];
		addv[p<<1]+=addv[p], addv[p<<1|1]+=addv[p];
		addv[p]=0;
	}
	void add(int p,int l,int r,int ql,int qr,T x) {
		if (ql<=l && qr>=r) {
			addv[p]+=x;
			maxv[p]+=x;
		} else {
			pushdown(p,l,r);
			int mid=l+r>>1;
			if (ql<=mid) add(p<<1,l,mid,ql,qr,x);
			if (qr>mid) add(p<<1|1,mid+1,r,ql,qr,x);
			maintain(p,l,r);
		}
	}
	int query(int p,int l,int r,int ql,int qr) {
		if (ql<=l && qr>=r) return maxv[p];
		int mid=l+r>>1,lc=p<<1,rc=p<<1|1,ans=-1e9;
		pushdown(p,l,r);
		if (ql<=mid) ans=max(ans,query(lc,l,mid,ql,qr));
		if (qr>mid) ans=max(ans,query(rc,mid+1,r,ql,qr));
		return ans;
	}
};
segment_tree<int,MAXN<<2> segt;
inline void swap(int &a,int &b) { a^=b, b^=a, a^=b; }
int getfa(int u) {
	while (u=fa[u]=fa[fa[u]],u!=fa[u]);
	return u;
}
void build(int p,int l,int r) {
	if (!c[p].lc) {
		pos[c[p].p]=l;
	} else {
		int mid=l+c[c[p].lc].siz-1;
		build(c[p].lc,l,mid);
		build(c[p].rc,mid+1,r);
	}
	c[p].p=0; //防止二次建树
}
int main() {
	scanf("%d",&n);
	for (register int i=1;i<=n;i++) {
		scanf("%d",a+i);
		c[i].p=i, c[i].siz=1;
		fa[i]=i;
		siz[i]=1;
		cur[i]=i;
	}
	tot=n;
	scanf("%d",&m);
	for (register int i=0;i<m;i++) {
		char opt[5];
		scanf("%s",opt);
		switch (opt[0]) {
			case 'U':
				int u,v;
				scanf("%d%d",&u,&v);
				u=getfa(u), v=getfa(v);
				if (u==v) break;
				if (u>v) swap(u,v);
				fa[v]=u;
				c[++tot]=(node){u,cur[u],cur[v],c[cur[u]].siz+c[cur[v]].siz};
				cur[u]=tot;
				q[i][0]=1, q[i][1]=u, q[i][2]=v;
				break;
			case 'A':
				q[i][0]=opt[1]-'0'+1;
				scanf("%d",q[i]+1);
				if (opt[1]!='3') scanf("%d",q[i]+2);
				if (opt[1]=='2') q[i][1]=getfa(q[i][1]);
				break;
			case 'F':
				q[i][0]=opt[1]-'0'+4;
				if (opt[1]!='3') scanf("%d",q[i]+1);
				if (opt[1]=='2') q[i][1]=getfa(q[i][1]);
				break;
		}
	}
	int s=1; //区间起始序号
	for (register int i=tot;i>=1;i--) {
		if (c[i].p) build(i,s,s+c[i].siz-1), s+=c[i].siz;
	}
	for (register int i=1;i<=n;i++) { //原权值
		segt.add(1,1,n,pos[i],pos[i],a[i]);
	}
	for (register int i=0,j=0;i<m;i++) {
		switch (q[i][0]) {
			case 1: siz[q[i][1]]+=siz[q[i][2]];break;
			case 2: segt.add(1,1,n,pos[q[i][1]],pos[q[i][1]],q[i][2]);break;
			case 3: segt.add(1,1,n,pos[q[i][1]],pos[q[i][1]]+siz[q[i][1]]-1,q[i][2]);break;
			case 4: segt.add(1,1,n,1,n,q[i][1]);break;
			case 5: printf("%d\n",segt.query(1,1,n,pos[q[i][1]],pos[q[i][1]]));break;
			case 6: printf("%d\n",segt.query(1,1,n,pos[q[i][1]],pos[q[i][1]]+siz[q[i][1]]-1));break;
			case 7: printf("%d\n",segt.query(1,1,n,1,n));break;
		}
	}
	return 0;
}
```

---

## 作者：埃罗芒阿老师· (赞：0)

思路{


看到合并，查询最大值，我们果断想到了可并堆。


操作1:合并两个左偏树,找出两个节点所属的左偏树，合并即可


操作2:给一特定节点的值增加v，我们可以先取出这个元素，修改它的值，合并。


操作3:给一个左偏树的所有值增加一个数,像线段树那样打个标记都可以了。


操作4;直接搞个全局变量记录all都可以辣。


查询1:输出x节点的权值=当前的值加上跳父亲的lazy值+全局all。


查询2:直接取堆顶元素即可。


查询3:这个只要取各个堆的堆顶元素建一个堆，在各种操作中先删除，再单点修改，再插入。


}

---


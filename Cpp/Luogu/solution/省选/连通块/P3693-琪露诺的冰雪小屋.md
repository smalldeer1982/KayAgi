# 琪露诺的冰雪小屋

## 题目背景

琪露诺有一片正方形的雪地，她想在上面盖一栋小冰屋。


## 题目描述

琪露诺偶然间得到了一片 $N\times N$ 大小的正方形的雪地，她想在上面盖一栋冰雪小屋。

但调皮的⑨才不会认真地收集冰块呢，她要在这片土地上使用冰雪弹幕来制造冰砖，然后一块一块地搭起一个房子。

琪露诺制造冰砖的方式是这样的：她会站在某个方格上，然后向上，下，左，右，左上，左下，右上，右下这八个方向之一发射强力的冰雪弹幕，弹幕能影响到该方向一条直线上一定的距离以内的所有方格。

地面的每个方格都有一个冷冻度，初始为 $0$。被冰雪弹幕影响一次，冷冻度 $+1$，冷冻度的上限为 $4$。

在发射弹幕的间隙中，琪露诺会来到所有冷冻度为 $4$ 的格子，把那里的雪堆到一起，制作一个冰砖（大小为 $1\times1\times1$ 方格），并且将冷冻度重新归零。

琪露诺会拿着这些冰砖来盖房子。这个房子的长度、宽度和坐落位置她在一开始就已经规划好了，但她并不愿意提早确定房子的高度。

琪露诺是这样计划的：这个房子外观上看起来是一个长方体。

她会先盖起这个房子的四面墙（厚度为 $1$ 个方格），并在贴近地面的位置（废话）留一个宽度和高度分别为 $1$ 和 $2$ 的空位不放冰砖，作为房门。（显然，门无法开在墙的拐角处，但可以紧贴拐角）。

在她喜欢的时候，她会结束四面墙的建造，并一次性在墙顶部盖上一个厚度为 $1$ 方格的屋顶，使房子成为一个空心有顶的长方体。

计划已经非常充分了，但琪露诺还是不放心，所以她想请你帮她写一个程序，来随时提醒着她别出什么差错。这个程序需要具备的功能将在下文详细介绍。

----------------------
雪地由 $N$ 行 $N$ 列，$N\times N$ 个方格组成。（下标从 $0$ 开始，也就是说，存在第 $0$ 行第 $0$ 列，但不存在第 $N$ 行第 $N$ 列）每个方格都有一个冷冻度,范围 $[0,4]$，初始为 $0$。注意，空间是三维的，而冷冻度只是地面的属性。

琪露诺想将房子的左上角放在第 $H_R$行，$H_C$ 列（外墙也是房子的一部分，因此左上角位置不应该是房子的内部,而是外墙,并且是墙的拐角）。

这个房子的长度（平行于每列）是 $H_X$，宽度（平行于每行）是 $H_Y$，包含墙。保证房子所占空间不会超出雪地的范围。

除了最后搭建屋顶，琪露诺只会在高度 $[0,H_M-1]$ 放置冰砖。

一开始，琪露诺一个冰砖也没有。
在以下的介绍中，我们用俯视图来作示意：
```plain
0000
0000
4x90
0x01
```
数字代表当前该格子的冷冻度。如果位置紧贴地面（高度为 $0$）的地方放上了冰砖，那么用字母 $x$ 表示。

如果紧贴地面的位置没有冰砖，但是位置正上方的高空存在冰砖，那么仍然用数字表示地面的冷冻度，但这个数字会增加 $5$。即如果在示意图中看到了一个数字 $t\ge5$，表示该位置地面是空的，但高处有冰砖，且地面的冷冻度为 $t-5$。

第一个操作：`ICE_BARRAGE R C D S`  
---------------
表示琪露诺站在第 $R$ 行 $C$ 列的位置，朝着方向 $D$ 发射了一个强度为 $S$ 的弹幕。  
$R,C,D,S\in\mathbf{Z},0\le D\le7,0\le R,C,S<N$。  
方向编号 $0$ 表示上 $(R-1,C)$，$1$ 表示左上 $(R-1,C-1)$，   
$2$ 表示左 $(R,C-1)$，$3$ 表示左下 $(R+1,C-1)$，  
$4$ 表示下 $(R+1,C)$，$5$ 表示右下 $(R+1,C+1)$，  
$6$ 表示右 $(R,C+1)$，$7$ 表示右上 $(R-1,C+1)$。  
强度为 $S$ 的弹幕，可以使“处在发射方向直线上，距离琪露诺不超过 $S$ 格的所有格子（包括她站的格子）”的冷冻度都 $+1$。有以下几种特殊情况：

1. 如果某个格子冷冻度为 $4$，那么该格子冷冻度不变。
2. 如果弹幕所经路途上，有一个位置的地面上（高度为 $0$）已经放了冰砖（就是弹幕撞上了琪露诺已经盖了一半的房子），那么弹幕将被阻挡，无法影响到冰砖所在的格子以及冰砖后面被挡住的格子。
3. 弹幕超出雪地的部分忽略不计。

对于这个操作，需要如下输出一行：`CIRNO FREEZED k BLOCK(S)`  
如果这个弹幕将某个方格的冷冻度成功增加了 $1$，那么认为这个弹幕冻住了该方格。

`k` 表示这个弹幕总共冻住了多少方格。

如图：发射弹幕前地图如下：
```plain
00000
00000
00000
000x0
00000
```
执行操作 `ICE_BARRAGE 1 1 5 4`，地图变为：
```plain
00000
01000
00100
000x0
00000
```
输出：`CIRNO FREEZED 2 BLOCK(S)`  
解释：琪露诺站在第一行第一列，面对右下角发射了一个强度为 $4$ 的弹幕，但弹幕被 `x` 所阻挡，只能影响到 `x` 之前的格子。

第二个操作：`MAKE_ICE_BLOCK`  
-------------------------
琪露诺走遍地图上所有冷冻度为 $4$ 的方格，每个方格可以收集一个冰砖，然后将它们的冷冻度归零。 

对于这个操作，你需要给出如下输出一行：`CIRNO MADE x ICE BLOCK(S),NOW SHE HAS y ICE BLOCK(S)`  
表示琪露诺制造了 $x$ 个冰砖，目前她有 $y$ 个冰砖。  
比如琪露诺一开始有 $0$ 个冰砖，并且状态如下：
```plain
0xxx
0x4x
0x9x
0400
```
执行操作 `MAKE_ICE_BLOCK` 后变为
```plain
0xxx
0x0x
0x5x
0000
```
输出：`CIRNO MADE 3 ICE BLOCK(S),NOW SHE HAS 3 ICE BLOCK(S)`  
在这个示例中，房子已经完成了一部分，`x` 表示墙，`9` 这个位置地面没有冰砖，但高处有（可以猜出是门）。房间内唯一一块空地、门的位置，以及房间外的一个位置的冷冻度都达到了 $4$，因此可以收集到 $3$ 块冰砖，收集后将三个位置冷冻度都归零。

第三个操作：`PUT_ICE_BLOCK R C H` 
-----------------
表示在第 $R$ 行，第 $C$ 列，高度为 $H$ 的地方放一个冰砖。$0\le R,C<N,0\le H<H_M$。

贴近地面的位置高度为 $0$。如果冰砖放置成功，那么琪露诺库存的冰砖数量将减 $1$。

如果放置的位置贴近地面，该位置冷冻度立即归 $0$。

有以下几种情况，序号越小优先级越高，并且只能满足一种情况。

如果满足 $1$ 的话就忽视后面的，不满足 $1$ 的前提下才可能满足 $2\cdots\cdots$ 以此类推。

1. 琪露诺目前没有任何冰砖，无法放置。这种情况下你需要输出：`CIRNO HAS NO ICE_BLOCK`
2. 冰砖将放在半空中，无法依附其他任何冰砖，或者目标位置已有冰砖了。  
这种情况下你需要输出一行：`BAKA CIRNO,CAN'T PUT HERE`，并无视此次操作，不做任何工作。
3. 冰砖放在了规划建造房子的区域之外，即
$R<H_R$ 或 $R>H_R+H_x-1$  
或 $C<H_C$ 或 $C>H_C+H_Y-1$。请输出一行：`CIRNO MISSED THE PLACE`  
尽管琪露诺放错了地方，但你并不能阻止她放置这个冰砖。  
4. 冰砖留在了房子的内部，本应留空的地方被占用了，即  
$H_R+1\le R\le H_R+H_X-2$ 且 $H_C+1\le C\le H_C+H_Y-2$  
在屋顶的高度固定下来前，我们将所有满足上式的情况都认为是放在了房屋内部。  
请输出一行：`CIRNO PUT AN ICE_BLOCK INSIDE THE HOUSE`  
尽管琪露诺放错了地方，但你并不能阻止她放置这个冰砖。
5. 冰砖放在了正确的位置（不必考虑是否堵住了留给门的地方）  
请输出一行：`CIRNO SUCCESSFULLY PUT AN ICE_BLOCK,NOW SHE HAS x ICE_BLOCK(S)`  
`x` 表示放过这块冰砖后琪露诺剩余的冰砖。

第四个操作：`REMOVE_ICE_BLOCK R C H` 
---------
表示取走第 $R$ 行，第 $C$ 列，高度为 $H$ 处的冰砖。  
有以下几种情况，序号越小优先级越高，并且只能满足一种情况。

如果满足 $1$ 的话就忽视后面的，不满足 $1$ 的前提下才可能满足 $2\cdots\cdots$ 以此类推。

1. 目标位置没有冰砖，输出一行：`BAKA CIRNO,THERE IS NO ICE_BLOCK`
2. 目标位置有冰砖，并且在这个冰砖被移走后，至少有一个冰砖形成了一个悬空的块。  
如下面的“侧视图”，`x` 表示冰砖，`0` 表示空位。
```plain
xxxx
x000
x000
x000
```
$\ \ $在移走左上角的冰砖后，第一行右边三个冰砖没有了依靠，形成了一个悬空的连通块，就属于这种情况。  
$\ \ $这个冰砖将成功移走，琪露诺的冰砖库存将会 $+1$。并且所有的悬空连通块都会掉下来摔碎并消失  
$\ \ $（既不会进入冰砖库存，也不会在地面上留有任何痕迹）。  
$\ \ $输出一行：`CIRNO REMOVED AN ICE_BLOCK,AND k BLOCK(S) ARE BROKEN`，`k` 表示摔碎的冰砖数量。  
3. 琪露诺挪走了冰砖，并且其他冰砖不受任何影响。    
$\ \ \ $琪露诺的冰砖库存 $+1$，输出一行：`CIRNO REMOVED AN ICE_BLOCK`
    
第五个操作：`MAKE_ROOF` 
--------
这个操作只会出现一次，并且只会作为最后一个操作。  
这个操作表明琪露诺已经完成了冰雪小屋的四墙，只剩屋顶了！  

一般情况下，琪露诺将放置最后的 $H_X\times H_Y$ 个冰砖，把它们放置在墙壁最高的高度 $+1$ 的那一层，  
形成一个屋顶。然后她移除所有多余的冰砖，接下来补好所有残缺的墙壁。

你需要按顺序来执行整个过程，一旦遇到某种用 $\bullet$ 标识的特殊情况，则执行完该情况后退出流程。

在特殊情况之间所描述的均为一般情况，只要之前没有因为满足某种特殊情况而退出流程，均认为满足了一般情况。

首先，琪露诺将会一次性放置最多 $H_X\times H_Y$ 个冰砖来建造屋顶。

为什么是最多呢？请注意一点：如果之前错误放置在房子内部的冰砖恰好充当了屋顶的一部分，那么就不用在这个位置再放冰砖了。并且，所有比屋顶高的冰砖在之后将视为错误放置在了房子外部。

注意，放屋顶的时候可能会触及到高度为 $H_M$ 的那个平面。

建造屋顶前后将会碰到两种特殊情况：
- 琪露诺剩余的冰砖不足以建造屋顶。输出一行：`SORRY CIRNO,NOT ENOUGH ICE_BLOCK(S) TO MAKE ROOF`
- 墙壁的最高高度小于 $2$ 个方格，或者内部有效空间小于两个方格。  
墙壁所在的一圈不算内部空间。计算内部有效空间时请忽视错误放置的冰砖，因为它们将来要被移除。  
输出一行：`SORRY CIRNO,HOUSE IS TOO SMALL`

（特殊情况结束）

此后，我们认为琪露诺已经造好了屋顶，接下来该移除所有多余冰砖了。在移除过程中，琪露诺会尽可能让更少的冰砖摔碎。如果墙壁上某个冰砖因为移走了多余的冰砖而将要摔碎，那么她会先拆掉墙壁上的那个冰砖，然后在填补墙壁残缺时重新补回来（显然，这种行为不会影响到墙壁有无残缺的定性，但可以少损失一个冰砖）。她不会故意拆掉一个处在墙壁上且不会摔碎的冰砖。  
输出两行：  
`K1 ICE_BLOCK(S) INSIDE THE HOUSE NEED TO BE REMOVED`  
`K2 ICE_BLOCK(S) OUTSIDE THE HOUSE NEED TO BE REMOVED`  
`K1`表示房子内部错误放置的冰砖数量，`K2`表示房子外部错误放置的冰砖数量。

将有可能遭遇一种特殊情况：
- 琪露诺移除了所有多余的冰砖，但在移除过程中，屋顶塌陷了。  
输出一行：`SORRY CIRNO,HOUSE IS BROKEN WHEN REMOVING BLOCKS`

（特殊情况结束）

此后，我们认为琪露诺已经移除了所有多余的冰砖，接下来该填补墙壁的残缺了。

墙壁有残缺的定义是：除了宽为 $1$，高为 $2$ 的门以外，
在房子内部看外面还能看到其他缺口。

如果某个空位将来要作为门的一部分，则不属于残缺。并且房子只能有一个门。

如果墙壁没有残缺，则不要填补，否则需要填补。你需要记下墙壁是否有残缺，之后会用到。

填补的策略是：使用尽可能少的冰砖，在正确的位置填补墙壁，使房屋的状态不满足墙壁有残缺的定义（即不能放置多余的冰砖，通过遮挡视线来达到目的）。在此定义下，**大多数**情况我们无需考虑四角的柱子是否完整，因为在房间里看不到。

将有可能遭遇一种特殊情况：
- 琪露诺剩余的冰砖不足以填补墙壁的残缺。  
输出一行：`SORRY CIRNO,NOT ENOUGH ICE_BLOCKS TO FIX THE WALL`

（特殊情况结束）

此后，我们认为房子被成功建成了，这时你需要输出几行内容来对房子进行评价。

首先输出这么一行来庆祝房子的建成：`GOOD JOB CIRNO,SUCCESSFULLY BUILT THE HOUSE`  
1. 在贴近地面的位置找不到一个宽度为 $1$，高度为 $2$ 的位置留给门。  
	输出一行：`HOUSE HAS NO DOOR`，然后琪露诺会尽可能利用墙壁上的残缺来开一个门。  
    否则，输出一行：`DOOR IS OK`
2. 接下来输出一行表示填补之前墙壁的完整程度  
	2.1. 在之前的记录中，墙壁不完整而需要修补。输出：`WALL NEED TO BE FIXED`  
    2.2. 在之前的记录中，墙壁完整而无需修补。输出：`WALL IS OK`  
3. 接下来一行表示四角的完整程度。  
	如果四个角的柱子有不完整的地方，就输出：`CORNER NEED TO BE FIXED`  
    在这种情况下，如果琪露诺剩余的冰砖足够修复拐角的空缺，那么她直接会修复这个空缺。  
    如果不够的话，她会再多收集几个冰砖，数量恰好修复这个空缺，然后修复这个空缺。  
    否则，输出：`CORNER IS OK`
    
接下来，输出一行：`CIRNO FINALLY HAS k ICE_BLOCK(S)`  
`k` 表示琪露诺最后剩余的冰砖的数量。

最后，如果在之前的记录中，墙壁完整无缺，没有一个位置需要填补。房子内外都无任何多余的方块，没有一个位置需要移除。没有出现房子没门的情况，房子四角的柱子也在造屋顶前完全造好，而不是通过修补完善的。并且门恰好开在了某面墙的正中央（如果长度为偶数，中间的两个都算），输出一行：   
`CIRNO IS PERFECT!`

## 说明/提示

共分为 $6$ 个 **Subtask**，每个 **Subtask** 的数据都满足一定条件，并且同时满足序号更大的 **Subtask** 的条件。  
如 **Subtask #0** 同时满足 **Subtask #0~5** 的条件。  
每一个 **Subtask** 的得分取所有测试点的最低分。

**Subtask #0** $20\%$  
琪露诺只想玩玩冰雪弹幕，她不会放置任何冰砖，也不会盖房子(即只有操作一和操作二)。  


**Subtask #1** $10\%$  
琪露诺不会移除已经放置的冰砖。

**Subtask #2** $20\%$  
琪露诺很有信心，她将在没有 `MAKE_ROOF` 的情况下建造她的冰屋(这种情况下，放置方块的高度仍然会小于 $H_M$ 且没有 `MAKE_ROOF` 操作)。

**Subtask #3** $20\%$  
琪露诺在移除方块时会谨慎考虑,不会造成任何冰砖摔落。`MAKE_ROOF` 操作移除多余冰砖时，也不会造成屋顶塌陷。

**Subtask #4** $20\%$  
琪露诺不喜欢把门开到四角的柱子旁边(数据保证在所有可能作为门的墙壁空缺中，有一种可能使得门不紧贴四角的柱子)。 

**Subtask #5** $10\%$  
$4\le N\le 16$，$5\le H_M\le 20$，$10\le M\le 10^3$，保证不属于冰屋范围内的所有空地至多构成一个连通块。

注意：判断墙壁是否有残缺时，候选的开门位如果被方块堵住，在当时还未被清空。"能看到残缺"以当时的情况作为判断依据。

## 样例 #1

### 输入

```
8
10
4 0 4 4
63
ICE_BARRAGE 2 1 1 3
ICE_BARRAGE 0 1 3 1
MAKE_ICE_BLOCK
PUT_ICE_BLOCK 3 2 0
ICE_BARRAGE 1 0 6 7
ICE_BARRAGE 2 0 6 7
ICE_BARRAGE 3 0 6 7
ICE_BARRAGE 4 0 6 7
ICE_BARRAGE 1 0 6 7
ICE_BARRAGE 1 0 6 7
ICE_BARRAGE 1 0 6 7
ICE_BARRAGE 1 0 6 7
MAKE_ICE_BLOCK
PUT_ICE_BLOCK 4 0 1
PUT_ICE_BLOCK 4 0 0
PUT_ICE_BLOCK 4 0 1
PUT_ICE_BLOCK 3 0 1
REMOVE_ICE_BLOCK 4 0 1
PUT_ICE_BLOCK 4 2 0
PUT_ICE_BLOCK 6 1 0
PUT_ICE_BLOCK 4 3 0
PUT_ICE_BLOCK 5 3 0
PUT_ICE_BLOCK 6 3 0
PUT_ICE_BLOCK 7 3 0
ICE_BARRAGE 0 1 4 7
ICE_BARRAGE 1 0 6 7
ICE_BARRAGE 1 0 6 7
ICE_BARRAGE 1 0 6 7
ICE_BARRAGE 1 0 6 7
MAKE_ICE_BLOCK
ICE_BARRAGE 1 0 6 7
ICE_BARRAGE 1 0 6 7
ICE_BARRAGE 1 0 6 7
ICE_BARRAGE 1 0 6 7
MAKE_ICE_BLOCK
ICE_BARRAGE 1 0 6 7
ICE_BARRAGE 1 0 6 7
ICE_BARRAGE 1 0 6 7
ICE_BARRAGE 1 0 6 7
MAKE_ICE_BLOCK
ICE_BARRAGE 1 0 6 7
ICE_BARRAGE 1 0 6 7
ICE_BARRAGE 1 0 6 7
ICE_BARRAGE 1 0 6 7
MAKE_ICE_BLOCK
REMOVE_ICE_BLOCK 6 1 0
PUT_ICE_BLOCK 5 0 0
PUT_ICE_BLOCK 6 0 0
PUT_ICE_BLOCK 7 0 0
PUT_ICE_BLOCK 7 1 0
PUT_ICE_BLOCK 7 2 0
PUT_ICE_BLOCK 4 0 1
PUT_ICE_BLOCK 5 0 1
PUT_ICE_BLOCK 6 0 1
PUT_ICE_BLOCK 7 0 1
PUT_ICE_BLOCK 7 1 1
PUT_ICE_BLOCK 7 2 1
PUT_ICE_BLOCK 7 3 1
PUT_ICE_BLOCK 6 3 1
PUT_ICE_BLOCK 5 3 1
PUT_ICE_BLOCK 4 3 1
PUT_ICE_BLOCK 4 2 1
MAKE_ROOF
```

### 输出

```
CIRNO FREEZED 2 BLOCK(S)
CIRNO FREEZED 2 BLOCK(S)
CIRNO MADE 0 ICE BLOCK(S),NOW SHE HAS 0 ICE BLOCK(S)
CIRNO HAS NO ICE_BLOCK
CIRNO FREEZED 8 BLOCK(S)
CIRNO FREEZED 8 BLOCK(S)
CIRNO FREEZED 8 BLOCK(S)
CIRNO FREEZED 8 BLOCK(S)
CIRNO FREEZED 8 BLOCK(S)
CIRNO FREEZED 7 BLOCK(S)
CIRNO FREEZED 7 BLOCK(S)
CIRNO FREEZED 0 BLOCK(S)
CIRNO MADE 8 ICE BLOCK(S),NOW SHE HAS 8 ICE BLOCK(S)
BAKA CIRNO,CAN'T PUT HERE
CIRNO SUCCESSFULLY PUT AN ICE_BLOCK,NOW SHE HAS 7 ICE_BLOCK(S)
CIRNO SUCCESSFULLY PUT AN ICE_BLOCK,NOW SHE HAS 6 ICE_BLOCK(S)
CIRNO MISSED THE PLACE
CIRNO REMOVED AN ICE_BLOCK,AND 1 BLOCK(S) ARE BROKEN
CIRNO SUCCESSFULLY PUT AN ICE_BLOCK,NOW SHE HAS 5 ICE_BLOCK(S)
CIRNO PUT AN ICE_BLOCK INSIDE THE HOUSE
CIRNO SUCCESSFULLY PUT AN ICE_BLOCK,NOW SHE HAS 3 ICE_BLOCK(S)
CIRNO SUCCESSFULLY PUT AN ICE_BLOCK,NOW SHE HAS 2 ICE_BLOCK(S)
CIRNO SUCCESSFULLY PUT AN ICE_BLOCK,NOW SHE HAS 1 ICE_BLOCK(S)
CIRNO SUCCESSFULLY PUT AN ICE_BLOCK,NOW SHE HAS 0 ICE_BLOCK(S)
CIRNO FREEZED 6 BLOCK(S)
CIRNO FREEZED 8 BLOCK(S)
CIRNO FREEZED 8 BLOCK(S)
CIRNO FREEZED 8 BLOCK(S)
CIRNO FREEZED 7 BLOCK(S)
CIRNO MADE 8 ICE BLOCK(S),NOW SHE HAS 8 ICE BLOCK(S)
CIRNO FREEZED 8 BLOCK(S)
CIRNO FREEZED 8 BLOCK(S)
CIRNO FREEZED 8 BLOCK(S)
CIRNO FREEZED 8 BLOCK(S)
CIRNO MADE 8 ICE BLOCK(S),NOW SHE HAS 16 ICE BLOCK(S)
CIRNO FREEZED 8 BLOCK(S)
CIRNO FREEZED 8 BLOCK(S)
CIRNO FREEZED 8 BLOCK(S)
CIRNO FREEZED 8 BLOCK(S)
CIRNO MADE 8 ICE BLOCK(S),NOW SHE HAS 24 ICE BLOCK(S)
CIRNO FREEZED 8 BLOCK(S)
CIRNO FREEZED 8 BLOCK(S)
CIRNO FREEZED 8 BLOCK(S)
CIRNO FREEZED 8 BLOCK(S)
CIRNO MADE 8 ICE BLOCK(S),NOW SHE HAS 32 ICE BLOCK(S)
CIRNO REMOVED AN ICE_BLOCK
CIRNO SUCCESSFULLY PUT AN ICE_BLOCK,NOW SHE HAS 32 ICE_BLOCK(S)
CIRNO SUCCESSFULLY PUT AN ICE_BLOCK,NOW SHE HAS 31 ICE_BLOCK(S)
CIRNO SUCCESSFULLY PUT AN ICE_BLOCK,NOW SHE HAS 30 ICE_BLOCK(S)
CIRNO SUCCESSFULLY PUT AN ICE_BLOCK,NOW SHE HAS 29 ICE_BLOCK(S)
CIRNO SUCCESSFULLY PUT AN ICE_BLOCK,NOW SHE HAS 28 ICE_BLOCK(S)
CIRNO SUCCESSFULLY PUT AN ICE_BLOCK,NOW SHE HAS 27 ICE_BLOCK(S)
CIRNO SUCCESSFULLY PUT AN ICE_BLOCK,NOW SHE HAS 26 ICE_BLOCK(S)
CIRNO SUCCESSFULLY PUT AN ICE_BLOCK,NOW SHE HAS 25 ICE_BLOCK(S)
CIRNO SUCCESSFULLY PUT AN ICE_BLOCK,NOW SHE HAS 24 ICE_BLOCK(S)
CIRNO SUCCESSFULLY PUT AN ICE_BLOCK,NOW SHE HAS 23 ICE_BLOCK(S)
CIRNO SUCCESSFULLY PUT AN ICE_BLOCK,NOW SHE HAS 22 ICE_BLOCK(S)
CIRNO SUCCESSFULLY PUT AN ICE_BLOCK,NOW SHE HAS 21 ICE_BLOCK(S)
CIRNO SUCCESSFULLY PUT AN ICE_BLOCK,NOW SHE HAS 20 ICE_BLOCK(S)
CIRNO SUCCESSFULLY PUT AN ICE_BLOCK,NOW SHE HAS 19 ICE_BLOCK(S)
CIRNO SUCCESSFULLY PUT AN ICE_BLOCK,NOW SHE HAS 18 ICE_BLOCK(S)
CIRNO SUCCESSFULLY PUT AN ICE_BLOCK,NOW SHE HAS 17 ICE_BLOCK(S)
0 ICE_BLOCK(S) INSIDE THE HOUSE NEED TO BE REMOVED
0 ICE_BLOCK(S) OUTSIDE THE HOUSE NEED TO BE REMOVED
GOOD JOB CIRNO,SUCCESSFULLY BUILT THE HOUSE
DOOR IS OK
WALL IS OK
CORNER IS OK
CIRNO FINALLY HAS 1 ICE_BLOCK(S)
CIRNO IS PERFECT!
```

# 题解

## 作者：orangebird (赞：92)

嗯，一道看起来很恶心的模拟，实际上做起来大部分分还是很容易拿到的。

但貌似比赛的时候很少有人做，被题面长度吓住了吗？


第一个操作,放弹幕，很简单。

要注意如果琪露诺站在有冰砖的位置放弹幕，这个弹幕会直接被阻挡，等于无效。


第二个操作,收集冰砖，更简单。

直接遍历二维地图就可以了。

20分到手~


第三个操作，放冰砖。

注意一个细节，如果放到地面上，要把冷冻度归零。

30分到手，真容易


第四个操作，拿走冰砖。

不考虑摔碎的情况，非常好写，轻松50分到手

嗯,再来看看情况2...

什么？不是说好的模拟吗？怎么出来个找连通块？

好吧，这题不完全是模拟。

先删掉对应位置的方块，然后6遍BFS寻找连通块，注意如果某一块碰到了地面就不算悬空连通块。


大家内心:这么快就写完4/5了，这是什么辣鸡题，题面又长，难度又水。

出题人的内心是滑稽的


那么来看第五个操作,盖屋顶

\*首先判断冰砖是否不足，直接遍历即可，有小细节。

\*下来判断内部空间是否不足，第一种情况是屋顶太低，

第二种情况是四面墙挤到一起，没有内部空间。

\*然后输出房屋内外有多少个冰砖，注意屋顶建成以后，高于屋顶的算作房屋外部，如果是之前放冰砖

时统计，这里就要跳坑了。

\*接下来判断移除多余冰砖时屋顶会不会塌

和之前一样，BFS即可。

\*接下来一个大坑来了，修复墙壁。

其他没问题，重点是四个角。

如果门没选在角落旁边，那么如果四个角有残缺，根本不用管它，因为看不到。

如果门选到角落旁边，缺角在房屋里面是有可能被看到的。

怎么解决呢？提供一个思路:查表。

我们用以下矩阵

a b

c d

来表示一堵墙角落的情况。假设a和c表示角方块，b和d表示相邻的边方块。0表示没有方块，1表示有方块。

那么对于

1 0

0 0

的情况，显然在房子内能看到c的缺损，所以要将c填上。

而对于

1 0

0 1

的情况，无需对c进行填补，因为d遮住了c使得c并不可见。

可以用方块摆一摆，比较直观。

*#请注意一个开门位置有可能和两个角都相邻。*

选择开门的位置时不妨采取估价的方法，以开门位置缺少的冰砖个数为第一关键字(越大价值越高)，修补角花费的冰砖数量为第二关键字(越小价值越高)，是否在正中间为第三关键字(是则价值更高)排序，选择价值最高的位置来开门即可。

\*判断有没有门，上一个操作时应该顺便就弄了吧，没啥坑点。

\*判断填补前墙壁是否完整，如果刚才修复墙壁的时候没注意到那个大坑，这里就会跳进去

\*判断四角的完整程度，还是一样，修复墙壁的时候如果跳坑了，那么这里也跳坑了

\*输出剩余冰砖数量，只要前面都写对了这里应该没问题。

\*判断是否完美建造，同上。

好啦，这个题就结束了，已经有很多题解了，我自己代码写得太丑就不放了。

(std已经被hack掉好几次了，这次更新数据和题解也是发现了之前没注意到的特殊情况)

如果还发现一些非正确算法能通过此题，可以私戳我，我将会继续加强数据。非常感谢~

---

## 作者：灵乌路空 (赞：37)

## 知识点: 模拟 , ~~信仰~~     

### [原题面](https://www.luogu.org/problem/P3693)   

大 型 车 万 众  自 裁 现 场       

![baka⑥](https://ae01.alicdn.com/kf/H98d3a35cea914ebe987afe9e6f953dceL.jpg)

---

### 分析题意:   

1.  **操作: ICE_BARRAGE R C D S**   
	 - R:行 , C:列,  D:方向 , S:强度   
	 - 在(R,C) 向 D 射线上 发射弹幕,  将 距离 S 格内 的位置 冰冻度 $+1$   
	    -  冰冻度 只是 地面的属性 , 冰砖 无冰冻度属性   
	    - 冰冻度 操作前已经为 $4$ 的方格 冰冻度 不改变   
	    - 遇到冰砖 射线线停止延伸    
	    - **距离 $=$ 经过方格数量** ,  经过格子数量 $\ge S$ 时 直线停止延伸   
   
    **输出: CIRNO FREEZED k BLOCK(S)**   
      - k :  冰冻度 $+1$ 的位置的数量   


2. **操作: MAKE_ICE_BLOCK**   
	- 将 全地图上 冰冻度 $= 4$ 的 方格 冰冻度清零, 冰砖库存数 $+1$    
   
   **输出: CIRNO MADE x ICE BLOCK(S),NOW SHE HAS y ICE BLOCK(S)**   
     - x : 本次制造数 , y : 目前库存数   


3. **操作: PUT_ICE_BLOCK R C H**   
	  - R: 行 C:列 H:高   
	  - 库存冰砖数$-1$ , 在 三维空间中 $(R,C,H)$  处放置 一个冰砖   
	  - 放置在地面  $\Rightarrow$ 地面冰冻度清零    
	
	**输出 :**     
	可能出现多种结果 , 按照输出优先级排列 :     
	1. CIRNO HAS NO ICE_BLOCK   
		- 无库存冰砖     
		- 阻止操作进行   
	2. BAKA CIRNO,CAN'T PUT HERE   
		- 冰砖放置位置悬空 / 放置位置已有冰块   
		   - 冰砖悬空 $\Rightarrow$  三维空间中 周围六个位置 无冰砖存在   
		   - 对于 放置位置 接触地面的 冰砖 , 不可能悬空   
		- 阻止操作进行   
	3. CIRNO MISSED THE PLACE   
		 - $\text{R<HR}\ \text{或}\ \text{R>HR+HX-1}$       
			$\text{或} \ \text{C<HC}\ \text{或}\ \text{C>HC+HY-1}$     
		 - 放置在了 房子范围以外的位置   
		 - 不可阻止 操作进行   
	4. CIRNO PUT AN ICE_BLOCK INSIDE THE HOUSE   
		- $\text{HR+1}\le \text{R}\le \text{HR+HX-2}$    
		  $\text{且}\ \text{HC+1}\le \text{C}\le \text{HC+HY-2}$   
		- 冰砖放置在了 屋内 本应为空地处   
		- 不可阻止 操作进行   
	5. CIRNO SUCCESSFULLY PUT AN ICE_BLOCK,NOW SHE HAS x ICE_BLOCK(S)   
	    - x : 目前 库存冰砖数   
	    - 不考虑 是否堵住了 应该留门的位置   


4. **操作: REMOVE_ICE_BLOCK R C H**   
	- R: 行 C: 列 H: 高   
	- 将 $(R,C,H)$ 位置的冰砖取走 , 库存 冰砖数 $+1$   
    - 将 与地面接触的 冰砖取走后 , 地面冰冻度归零   
  
   **输出:**   
   可能出现多种结果 , 按照输出优先级排列:     
   1. BAKA CIRNO,THERE IS NO ICE_BLOCK   
	  - 被操作位置 无冰砖     
	  - 阻止操作进行     
   2. CIRNO REMOVED AN ICE_BLOCK,AND k BLOCK(S) ARE BROKEN     
	   - k: 碎掉冰块数    
	   - 本次操作 导致 一冰砖联通块 悬空 (不与 **与地面接触的联通块** 联通)     
	     悬空 冰块消失   
	   - 不可阻止 操作进行   
   3. CIRNO REMOVED AN ICE_BLOCK    
	  - 成功取走 , 对其他冰块无影响   


5. **操作: MAKE_ROOF**   
	- 最后一 条操作 , 只出现一次   
	- 按照下列顺序进行 子操作, 按照 子操作个指令排列优先级 进行操作 ,      
	  若不满足条件, 子操作无法进行 , 程序终止   
	
	**子操作:**   
	1. **搭建 房顶**   
	   - 在 **墙壁最高高度** $+1$ 处  一次性放置 至多 $\text{HX}\times \text{XY}$ 个冰砖,   
	   - 若 在 **MAKE_ROOF** 之前此高度处有冰砖 , 已有冰砖位置 不必重复放置   
	   - 比 此时放置的 屋顶的高度 高的 冰砖  视为存在于房外   
	  
	    **不满足条件:**    
	    可能出现多种结果 , 按照输出优先级排列:       
	      1. SORRY CIRNO,NOT ENOUGH ICE_BLOCK(S) TO MAKE ROOF     
			 - 按照上述规则 , 库存冰块不足 填满 房顶       
		  2. SORRY CIRNO,HOUSE IS TOO SMALL      
			 - 房顶建造完毕后 ,  墙高 $<2$  或  房屋内部空间 $<2$(忽略屋内错放冰砖)     
            
   2. **移除 多余冰砖:**   
	   - 将 不属于 房屋墙壁与 房屋顶部 的冰砖全部移走     
	   - 当 移走某冰砖时 , 可能 会导致 **墙壁上** 某冰砖 摔碎,   
	     则先将 墙壁上 会摔碎的冰砖 移走 (子任务3 中再进行填补)    
		 再 对原冰砖 进行移除    
		 
	  **输出:**    
	  k1 ICE_BLOCK(S) INSIDE THE HOUSE NEED TO BE REMOVED        
	  k2 ICE_BLOCK(S) OUTSIDE THE HOUSE NEED TO BE REMOVED      
	  -  k1 :  房子内部 错误放置的 多余冰砖数    
		 k2 :  房子外部 错误放置的 多余冰砖数     
	  

	  **不满足条件 :**   
	  1. SORRY CIRNO,HOUSE IS BROKEN WHEN REMOVING BLOCKS     
		 - 由于 将墙壁上冰砖移走 , 导致房顶 不 与地面联通 ,  使房顶塌陷    

   3. **填补 墙壁残缺:**   
		- 墙壁 有残缺的定义:    
			- 除 门的候选位置 之外 , 从屋内向外看 还可看到其他 残缺      
			- $\color{red}\text{注意:}$ **当 门不得不 开到 柱子旁时 , 可看到 柱子对应位置 是否残缺**       
			   **当 一个残缺位置 同时与两柱子相邻时 , 可同时看到 两柱子对应位置的残缺**     
			   **此过程中填补的所有残缺 都属于墙壁残缺 (包括柱子残缺)**    
				
            			
		 -  对于 高度$\ge 2$ 的残缺位置 ,  一定需要被填补        
		 -  对于 高度 $< 2$ 的残缺位置 ,  需要考虑  成为门的情况 :        
		    对于门的候选位置 , 应按照下列条件进行选择 (按照必要性优先级排序) :    
			
             1. 房屋能够建成  (不出现 冰砖数量不足的情况)    
			    - 对于门的候选位置 的选择 , 需要使填补冰砖数量尽可能 减少    
			      若门候选位置 相邻的柱子残缺 , 会导致 冰砖填补数量增加          
			         
	 	         - 需填补冰砖数 $=$ 墙壁残缺数(不包括柱子) $-$ 候选位置大小 $+$ 可看到柱子残缺数  
                  应将 门候选位置按照 **"可看到柱子残缺数$-$候选位置大小" 升序 **作为排序**第一优先级**        
			       - 显然 , 可看到的柱子残缺数 $\le$ 门候选位置大小        
			      
			       - 在此条件下, 可能出现: 选择 大小为 $1\times 1$ 的残缺 优于 大小为 $1\times 2$ 的残缺 的情况      
			      
		     2. 存在一 $1\times 2$ 大小的残缺作为 门        
				- 满足条件$1$ 的情况下 ,      
				  优先选择 高度为 $2$ 的残缺 作为 门的候选位置      
				  
				  应将 门候选位置 按照 **"残缺 的高度" 降序** 作为排序 **第二优先级**      
				   
		    3. 门 更靠近 墙壁的正中央   
				- 满足 条件 $1,2$ 的情况下     
				  优先选择  更靠近 墙壁正中央的 残缺    
				  为更接近 "CIRNO IS PERFECT!" 的情况 (定义详见 **检查 小屋** 第$6$条)    
			      
			    应将 门候选位置 按照 **"与墙壁中间位置的距离" 升序** 作为排序 **第三优先级**       

		   
	   **不满足条件 :**       
	   1. SORRY CIRNO,NOT ENOUGH ICE_BLOCKS TO FIX THE WALL    
		  - 经过上述过程, 减少填补冰砖数 后 ,     
		     库存冰砖 还是无法 填补所有的 非门残缺      
		     如果门开在 柱子旁 , 残缺也 包括可看到的柱子 的残缺     
		     
   4. **检查 小屋**     
	   1. 输出: GOOD JOB CIRNO,SUCCESSFULLY BUILT THE HOUSE     
		   - 庆祝小屋完工 ~~(不愧是琪露诺! 轻易就做到了我们做不到的事)~~      

	  2. 检查是否有 $1\times 2$ 的门 :      
		  - 无 , 输出 HOUSE HAS NO DOOR      
		  - 有 , 输出 DOOR IS OK     

	  3. 检查操作 $3$ 中是否进行了填补操作    
	      - 否 ,  输出 WALL IS OK    
	      - 是 , 输出 WALL NEED TO BE FIXED    

	   4. 检查 四角的柱子 是否 有残缺    
			- 否 , 输出 CORNER IS OK    
			- 是 , 输出 CORNER NEED TO BE FIXED    
				- 若此时库存冰砖 $\ge$ 修复所需要的冰砖数    
				   则 就花费 修复所需冰砖数 个冰砖   
			   -  否则 库存冰砖数置零   

	  5. **输出:** CIRNO FINALLY HAS k ICE_BLOCK(S)   
		  - k: 剩余库存冰砖数   
	
	  6. 若上述检查 的 过程中    
			1. 没有 一个冰砖 需要被移除     
			2. 没有 一个位置 需要被 填补       
			3. 未出现房子没门的情况   
			4. 房角 的四个柱子 在 建造房顶之前便已修好, 未再进行 修补    
			5. 门恰好开在了 某面墙的正中央 (若墙长为偶数, 则两中间位置都合法)     

			**输出 :** CIRNO IS PERFECT!       

 
   对于 $20\%$ 的数据 : 只有操作 $1, 2$      
   对于 $30\%$ 的数据 : 只有操作 $1, 2, 3$        
   对于 $50\%$ 的数据 : 只有操作 $1, 2, 3, 4$   
   对于 $70\%$ 的数据 :  不会造成任何冰砖摔落 , 也不会造成屋顶塌陷   
   对于 $90\%$ 的数据 : 不把门开到四角的柱子旁边。   
   (保证在所有可能作为门的墙壁空缺中，有一种可能 使得门 不紧贴四角的柱子)   
    对于 $100\%$ 的数据 :    
   $4\le \text{N}\le 16\ , \ 5\le \text{HM}\le 20 \ ,\ 10\le \text{M}\le 1000$   
    保证 不属于冰屋范围内 的 所有空地 至多构成一个连通块。   
    除 **MAKE_ROOF** 指令外 , 放置方块 的 高度小于 $\text{HM}$   

---

### 算法实现 : 

分析上述过程中 较为复杂的实现 :

1. 如何判断 悬空连通块, 并将其消除 $?$      
	可以 以某连通块中的 一个冰砖为起点 , 进行 $DFS/BFS$      
	转移时 向相邻的 冰砖 进行转移     
	
	 如果 可以转移到 一个 与地面接触的 冰砖,       
	 那么 证明此联通块 与地面接触 , 不悬空     
	 否则证明 此联通块悬空  , 需要 被全部消除     
	  - 不可 边判断边消除 , 会因为 搜索的 顺序 导致错误     
	
	  消除一个联通块时 , 也使用 $DFS/BFS$  ,     
	  对转移到的 冰砖直接消除即可      

	代码如下 : 

	```cpp
	int DFS1(int R,int C,int H,int FR,int FC,int FH)//dfs 判断某联通块是否悬空 
	{
		vis[R][C][H] = 1;//访问过,打标记 
		if(H == 0) return 1;//此冰砖 与地面接触 , 说明此连通块合法 
		for(int i = 0; i < 6; i ++)//枚举相邻的 冰砖 
		  if(R + EXX[i] >= 0 && R + EXX[i] <N && C + EXY[i] >= 0) //位置合法 
		    if(C + EXY[i] < N && H + EXZ[i] >= 0 && H + EXZ[i] <=HM)
		      if(R + EXX[i] != FR || C + EXY[i] != FC || H + EXZ[i] != FH)//不与 上一块冰砖位置相同 
		  	    if(ice_block[R + EXX[i]][C + EXY[i]][H + EXZ[i]])//有冰砖 
		  	      if(!vis[R + EXX[i]][C + EXY[i]][H + EXZ[i]])//转移 
		  	        if(DFS1(R + EXX[i],C + EXY[i],H + EXZ[i],R,C,H)) return 1;//连通块 与地面接触 
		return 0;//悬空 
	}
	int DFS2(int R,int C,int H,int FR,int FC,int FH)//dfs 将某联通块 删除 
	{
		int ret = 0;//计算 删除的个数 
		for(int i = 0; i < 6; i ++)
		  if(R + EXX[i] >= 0 && R + EXX[i] < N && C + EXY[i] >= 0) //枚举 合法的相邻冰砖 
		    if(C + EXY[i] < N && H + EXZ[i] >= 0 && H + EXZ[i] <= HM)
		      if(R + EXX[i] != FR || C + EXY[i] != FC || H + EXZ[i] != FH)
		  	    if(ice_block[R + EXX[i]][C + EXY[i]][H + EXZ[i]])
		  	      ret += DFS2(R + EXX[i],C + EXY[i],H + EXZ[i],R,C,H);//dfs深入 
		return ice_block[R][C][H] = 0, ret + 1;//更新冰砖存在情况,更新删除个数 
	}
	```

2. 如何: 表示一门的候选位置相邻的墙角 , 并计算 墙角的残缺大小$?$   
	 
	- 对于 一门的候选位置 相邻的墙角 ,    
		由于情况较少 , 暴力枚举寻找即可  
		
	- 对于一个候选位置 , 其与某墙角关系只有 **相邻/不相邻** 两种   
	  考虑 对候选位置与各墙角关系 进行状压   
		
      使用一 长度为$4$ 的二进制串 , 表示某候选位置 与各墙角关系   
	  如 : $(1001)_2$ 表示此位置 与墙角$1$ 与 墙角$4$ 相邻   

	- 在计算墙角残缺大小时 , 枚举 二进制串上对应位置   
		根据 门后选位置的高度 进行判断即可   

3. 如何实现 上述 对门的候选位置 的估价过程 $?$    

	- 首先找到 所有 **离地高度**$\le 2$ 的残缺位置 ,    
	   对于每一个残缺位置 , 计算出下列各值 :     
	   1. 保留此残缺 对总填补数的影响 (可看到的柱子残缺数 $-$ 门候选位置大小)   
	   2. 此残缺 的高度    
	   3. 此残缺 与墙壁中间位置的距离   
	 
	- 按照 **分析题意** 中规定优先级 进行排序   
	  排序后的 第一个残缺 一定使 **需要填补冰砖数** 最小   
	  
	- 若第一个残缺 高度为 $1$, 且所得 **需要填补冰砖数 $<$ 当前库存**   
	    说明 可以多消耗 **至多一个** 冰砖 , 来选择一个 高度为 $2$ 的残缺作门   
	    -  可以 手推 各种类的残缺 , 来得到 消耗 **至多一个** 冰砖 的结论   
	 
	  则可 在排序后的残缺中 向后寻找第一个 高度为 $2$ 的残缺   
	  由于 第 $2,3$ 排序优先级的存在 , 找到的第一个 一定为 最优的    
	 
	 
---

### 一些技巧
 
1. 做题前先写大纲 一定没有错   

2. 多写子函数 一定没有错   

3. 有 $\text{hack}$ 数据提早联系出题人一定没有错   

4. 有没有 什么方便的方法 可以 减小调试的难度 ?     
    考虑 使全局的 冰砖摆放情况 可视化   
 
	 - 发现 对于确定的 横纵坐标 , 在此 横纵坐标上的 冰砖 ,    
	   可以按照 存在情况 , 用一个二进制串表示    
	   即: 对 每一个 $z$ 轴 进行状压   

	   例: $9 = (1001)_2$ , 表示: 在某位置, 高度为 $0,3$ 处 , 分别有一 冰砖    
	  这样 状压后 输出 每个$(x,y)$  对应的值     
	  就可以 在 二维平面内 模拟 三维立体图形 , 以便于调试        
		
	 -  如果您有条件 , 可以用 $\text{MC}$ 手玩数据   
	   配合上述方法使用 效果更佳  
	    
代码如下 :
```cpp
void check()//调试使用, 输出地图 , 以检查合法性 
{
	for(int x = 0; x < N; putchar('\n'), x ++) 
	  for(int y =0; y < N; y ++)
	  {
	    long long sum = 0;//使用 状压思想 , 对每一个二维的 坐标上的冰砖进行状压 
	    for(int z = 0; z <= HM; z ++) sum+= (ice_block[x][y][z]) * (1 << z);
	    printf("%lld ",sum);
	  }
	printf("\n\n");
}
```

	
---

附完整代码 :       

```cpp
#include<cstdio>
#include<vector>
#include<algorithm> 
#include<cstring>
#include<cstdlib>
#include<iostream>
#include<string>
#include<ctype.h>
#define min(a,b) (a < b ? a : b)
const int DIR_X[8] = {-1,-1,0,1,1,1,0,-1};//ICE_BARRAGE 操作时的 方向改变量 
const int DIR_Y[8] = {0,-1,-1,-1,0,1,1,1};
const int EXX[6] = {0,0,1,-1,0,0};//立体空间内 相邻的冰砖 位置改变量 
const int EXY[6] = {0,0,0,0,1,-1};
const int EXZ[6] = {-1,1,0,0,0,0};
//=============================================================
struct alternative_position//门的候选位置 
{
	int x, y, z, h, wall;//位置信息, 
	int corner, corner_pos; //可看到的柱子残缺数
	int mid1, mid2;//此面墙 中间位置的坐标 
};
int N,HM,HR,HC,HX,HY,M;//输入的各常量 
int inventory;//库存冰砖数 
bool ice_block[17][17][30];//三维空间内某点 是否有冰砖存在 
int ground_freeze[17][17];//地面冰冻度 ,当地面有冰砖时为-1 
bool vis[17][17][30];//在dfs求 联通块时使用 
int max_high;//墙壁最高高度 
int doorx, doory, doorz, door_high, door_dis;
int corner_x[20], corner_y[20];
//=========子函数列表:==========================================
inline int read()
{
    int s=1, w=0; char ch=getchar();
    for(; !isdigit(ch);ch=getchar()) if(ch=='-') s =-1;
    for(; isdigit(ch);ch=getchar()) w = w*10+ch-'0';
    return s*w;
}
int abs(int x) {return x > 0? x : -x; }
bool cmp(alternative_position fir, alternative_position sec)
{
	if(fir.corner - fir.h == sec.corner - sec.h)//第一优先级, 消耗冰砖数 升序排序 
	{
	  if(fir.h == sec.h)//第二优先级 门的大小 降序排序 
	  {
	    int minfir = min(abs(fir.wall - fir.mid1), abs(fir.wall - fir.mid2));
		int minsec = min(abs(sec.wall - sec.mid1), abs(sec.wall - sec.mid2));
		return minfir < minsec;	//第三优先级, 与墙中央位置的距离 升序排序 
	  }
	  return fir.h > sec.h;
	}
	return fir.corner - fir.h < sec.corner - sec.h;
}
void ICE_BARRAGE();//操作1,释放弹幕 
void MAKE_ICE_BLOCK();//操作2,收集冰砖
 
void PUT_ICE_BLOCK();//操作3,放置冰砖 
bool JUDGE_PUT(int R,int C,int H);//判断 某位置 是否可以放置冰砖

int DFS1(int R,int C,int H,int FR,int FC,int FH);//dfs 判断某联通块是否悬空 
int DFS2(int R,int C,int H,int FR,int FC,int FH);//dfs 将某联通块 删除 
void REMOVE_ICE_BLOCK();//操作4,移除冰砖 

void MAKE_ROOF(); //操作5, 建造房顶, 移除多余,修补残缺,检查房屋 
int find_max_high();//寻找 墙壁最高处 
void remove_excess(int&,int&);

bool judge_outside(int,int,int);//判断某冰砖 是否位于 房屋内/外 
bool judge_inside(int,int,int);

bool fill_high_wall(int);//填补 高度>2的墙壁 
int judge_corner(int,int);//判断 一个位置否开在 墙角,并判断 开在哪个墙角 
void corner_could_see(int,int,int,int,int&,int&);//计算一个位置 能看到的墙角的残缺数 
bool find_door();//在 高度<2的位置 找门 ,并填补非门区域 
void check()//调试使用, 输出地图 , 以检查合法性 
{
	printf("%d \n",inventory); 
	for(int x=0; x<N; putchar('\n'),x++) 
	  for(int y=0; y<N; y++)
	  {
	  	long long sum=0;//使用 状压思想 , 对每一个二维的 坐标上的冰砖进行状压 
	    for(int z=0; z<=HM; z++) sum+= (ice_block[x][y][z]) * (1<<z);
	    printf("%lld ",sum);
	  }
	printf("\n\n\n");
}
//=============================================================
signed main()//sb main函数 
{
//	freopen("1.in","r",stdin);
//	freopen("koishi.txt","w",stdout);
	N=read(), HM=read(), HR=read(), HC=read(), HX=read(), HY=read(), M=read();
	corner_x[1] = corner_x[2] = HR, corner_x[4] = corner_x[8] = HR + HX - 1;//获得各墙角位置 
	corner_y[2] = corner_y[8] = HC + HY - 1, corner_y[1] = corner_y[4] = HC;
	while(M --)
	{
	  std::string order;
	  std::cin >> order;
	  if(order == "ICE_BARRAGE") ICE_BARRAGE();
	  if(order == "MAKE_ICE_BLOCK") MAKE_ICE_BLOCK();
	  if(order == "PUT_ICE_BLOCK") PUT_ICE_BLOCK();
	  if(order == "REMOVE_ICE_BLOCK") REMOVE_ICE_BLOCK();
	  if(order == "MAKE_ROOF") MAKE_ROOF(); 
	}
}
//=============================================================
void ICE_BARRAGE()
{
	int R=read(), C=read(), D=read(), S=read();
	int freeze_num = 0, pass_num = 0;//冰冻度改变的格子数 和 经过的格子数(距离 
	
	for(int x = R, y = C; ;x += DIR_X[D], y += DIR_Y[D])//枚举射线经过的格子 
	{
	  if(x < 0 || x >= N || y < 0 || y >= N || ground_freeze[x][y] == -1) break;//直线不可延伸
	  if(ground_freeze[x][y] < 4) ground_freeze[x][y]++ , freeze_num ++;//更新 变量 
	  pass_num ++;
	  if(pass_num > S) break;//直线不可延伸 
	}
	printf("CIRNO FREEZED %d BLOCK(S)\n",freeze_num);
}
void MAKE_ICE_BLOCK()
{
	int collect_num = 0;//收集 的冰砖数 
	for(int x = 0; x < N; x ++)
	  for(int y = 0; y < N; y ++)
	    if(ground_freeze[x][y] == 4)//可以进行收集 
	      inventory ++, collect_num ++, //加入库存 
		  ground_freeze[x][y] = 0;//冰冻度清零 
	printf("CIRNO MADE %d ICE BLOCK(S),NOW SHE HAS %d ICE BLOCK(S)\n",collect_num,inventory);
}
bool JUDGE_PUT(int R,int C,int H)//判断 某位置 是否可以放置冰砖 
{
	if(ice_block[R][C][H]) return 1;//此位置已被占用 
	if(H == 0) return 0;//冰砖与地面接触 
	for(int i = 0; i < 6; i ++) //枚举立体空间内相邻的 位置 
	  if(R + EXX[i] >= 0 && C + EXY[i] >= 0 && H + EXZ[i] >= 0)
	    if(R + EXX[i] < N && C + EXY[i] < N && H + EXZ[i] < HM)
		  if(ice_block[R + EXX[i]][C + EXY[i]][H + EXZ[i]]) //有相邻冰砖 
		    return 0; //放置位置合法 
	return 1;//冰砖悬空 
}
void PUT_ICE_BLOCK() 
{
	int R=read(),C=read(),H=read();
	if(! inventory) {printf("CIRNO HAS NO ICE_BLOCK\n"); return ;}//不合法情况 
	if(JUDGE_PUT(R,C,H)) {printf("BAKA CIRNO,CAN'T PUT HERE\n"); return ;}
	
	ice_block[R][C][H] = 1,inventory --;//放置冰砖 
	if(H == 0) ground_freeze[R][C] = -1;//与地面接触 ,更改地面冰冻值 
	if(R < HR || R > HR + HX - 1 || C < HC || C > HC + HY - 1) printf("CIRNO MISSED THE PLACE\n");//按照放置位置 输出 
	else if(HR + 1 <= R && R <= HR + HX - 2 && HC + 1 <= C && C <= HC + HY - 2) printf("CIRNO PUT AN ICE_BLOCK INSIDE THE HOUSE\n");
	else printf("CIRNO SUCCESSFULLY PUT AN ICE_BLOCK,NOW SHE HAS %d ICE_BLOCK(S)\n",inventory);
//	check();
}
int DFS1(int R,int C,int H,int FR,int FC,int FH)//dfs 判断某联通块是否悬空 
{
	vis[R][C][H] = 1;//访问过,打标记 
	if(H == 0) return 1;//此冰砖 与地面接触 , 说明此连通块合法 
	for(int i = 0; i < 6; i ++)//枚举相邻的 冰砖 
	  if(R + EXX[i] >= 0 && R + EXX[i] <N && C + EXY[i] >= 0) //位置合法 
	    if(C + EXY[i] < N && H + EXZ[i] >= 0 && H + EXZ[i] <=HM)
	      if(R + EXX[i] != FR || C + EXY[i] != FC || H + EXZ[i] != FH)//不与 上一块冰砖位置相同 
	  	    if(ice_block[R + EXX[i]][C + EXY[i]][H + EXZ[i]])//有冰砖 
	  	      if(!vis[R + EXX[i]][C + EXY[i]][H + EXZ[i]])//转移 
	  	        if(DFS1(R + EXX[i],C + EXY[i],H + EXZ[i],R,C,H)) return 1;//连通块 与地面接触 
	return 0;//悬空 
}
int DFS2(int R,int C,int H,int FR,int FC,int FH)//dfs 将某联通块 删除 
{
	int ret = 0;//计算 删除的个数 
	for(int i = 0; i < 6; i ++)
	  if(R + EXX[i] >= 0 && R + EXX[i] < N && C + EXY[i] >= 0) //枚举 合法的相邻冰砖 
	    if(C + EXY[i] < N && H + EXZ[i] >= 0 && H + EXZ[i] <= HM)
	      if(R + EXX[i] != FR || C + EXY[i] != FC || H + EXZ[i] != FH)
	  	    if(ice_block[R + EXX[i]][C + EXY[i]][H + EXZ[i]])
	  	      ret += DFS2(R + EXX[i],C + EXY[i],H + EXZ[i],R,C,H);//dfs深入 
	return ice_block[R][C][H] = 0, ret + 1;//更新冰砖存在情况,更新删除个数 
}
void REMOVE_ICE_BLOCK()
{
	int R = read(), C = read(), H = read(); 
	if(!ice_block[R][C][H]) {printf("BAKA CIRNO,THERE IS NO ICE_BLOCK\n"); return ;}//不合法情况
	
	ice_block[R][C][H] = 0, inventory ++;//移除冰砖, 并 加入库存 
	if(H == 0) ground_freeze[R][C] = 0;//将地面 冰砖移走,冰冻度置零 
	
	int sum_break = 0;//碎掉冰砖个数 
	for(int i = 0; i < 6; i ++)//枚举被删除位置 相邻的 存在的 冰砖 
	  if(R + EXX[i] >= 0 && R + EXX[i] < N && C + EXY[i] >= 0) 
	    if(C + EXY[i] < N && H + EXZ[i] >= 0 && H + EXZ[i] <= HM)
	      if(ice_block[R + EXX[i]][C + EXY[i]][H + EXZ[i]]) 
	  	  {
	  	  	memset(vis,0,sizeof(vis));//dfs判断 相邻冰砖 连通块是否与 地面接触 
	  	    if(!DFS1(R + EXX[i],C + EXY[i],H + EXZ[i],-1,-1,-1))
	  	      sum_break += DFS2(R + EXX[i],C + EXY[i],H + EXZ[i],-1,-1,-1);	
		  }
	
	printf("CIRNO REMOVED AN ICE_BLOCK");//按情况输出 
	if(sum_break) printf(",AND %d BLOCK(S) ARE BROKEN",sum_break);
	printf("\n");
}
void MAKE_ROOF()
{
	int remove = 0, filled = 0, corner_filled = 0;//判断 是否移除多余 , 填补残缺 , 墙角残缺 
	max_high = find_max_high() + 1;//找到 墙壁最高高度 
	//搭建 房顶:
	{
		for(int x = HR; x < HR + HX; x ++)//枚举 最高高度处 所有位置 
		  for(int y = HC; y < HC + HY; y ++)
		  {
		  	inventory -= (!ice_block[x][y][max_high]);//更新
		  	ice_block[x][y][max_high] = 1;
		  }
		if(inventory < 0) {printf("SORRY CIRNO,NOT ENOUGH ICE_BLOCK(S) TO MAKE ROOF\n"); return ;}//不合法情况 
		if(max_high < 2 || (HX - 2)*(HY - 2)*max_high < 2) {printf("SORRY CIRNO,HOUSE IS TOO SMALL\n"); return ;}
	}
	//移除 多余冰砖:
	{
		int inside = 0, outside = 0;
		remove_excess(outside,inside);// 移除多余 
		remove = (inside || outside);//判断是否 移除 
		
		printf("%d ICE_BLOCK(S) INSIDE THE HOUSE NEED TO BE REMOVED\n",inside);//按情况输出 
		printf("%d ICE_BLOCK(S) OUTSIDE THE HOUSE NEED TO BE REMOVED\n",outside);
		if(!DFS1(HR + 1,HC + 1,max_high,-1,-1,-1)) {printf("SORRY CIRNO,HOUSE IS BROKEN WHEN REMOVING BLOCKS\n"); return ;}//判断 屋顶连通块是否悬空 
	}
	//填补 墙壁残缺:
	{
		filled = fill_high_wall(max_high);//填补 高度>=2处 
		filled += find_door();//在高度 <2处寻找门,并填补 
		if(inventory < 0) {printf("SORRY CIRNO,NOT ENOUGH ICE_BLOCKS TO FIX THE WALL\n"); return ;}//不合法情况 
	}
	//检查小屋: 
	{
		printf("GOOD JOB CIRNO,SUCCESSFULLY BUILT THE HOUSE\n");
		if(door_high == 2) printf("DOOR IS OK\n");//有 高为2的门 
		else inventory += (2 - door_high), printf("HOUSE HAS NO DOOR\n");//移除冰块建门,库存增加 
		
		if(filled) printf("WALL NEED TO BE FIXED\n");//填补过残缺 
		else printf("WALL IS OK\n");
		
		for(int z = 0; z <= max_high; z ++) //判断 墙角的完整性 
		  for(int x = HR; x < HR + HX; x += HX - 1)
		    for(int y = HC; y < HC + HY; y += HY - 1)
		      if(!ice_block[x][y][z]) corner_filled = 1, inventory --;
		if(corner_filled) printf("CORNER NEED TO BE FIXED\n");
		else printf("CORNER IS OK\n");
		
		printf("CIRNO FINALLY HAS %d ICE_BLOCK(S)\n",inventory >= 0?inventory:0);//最后的冰砖数 (若修复过墙角,会导致 库存<=0,此时还会再制造冰砖并补齐空缺 
		if((!remove) && (!filled) && door_high == 2 && (!corner_filled) && (!door_dis)) //不愧是琪露诺! 轻易就做到了我们做不到的事
		  printf("CIRNO IS PERFECT!");
	}
}
//MAKE_ROOF 子操作 
int find_max_high()//寻找 墙壁最高处 
{ 
	for(int i = HM; i >= 0; i --)//自上往下枚举 高度 
	{
	  for(int j = HC; j < HC + HY; j ++)//枚举每一面墙 
	    if(ice_block[HR][j][i]) return i;
	  for(int j = HC; j < HC + HY; j ++)
	    if(ice_block[HR + HX - 1][j][i]) return i;
	  for(int j = HR; j < HR + HX; j ++)
	    if(ice_block[j][HC][i]) return i;
	  for(int j = HR; j < HR + HX; j ++)
	    if(ice_block[j][HC + HY - 1][i]) return i;
	}
	return -1; 
}
bool judge_outside(int x,int y,int z)//判断 某位置 是否在房外 
{
	if(HR <= x && x < HR + HX)
	  if(HC <= y && y < HC + HY)
	    if(z <= max_high) return 0;
	return 1;
}
bool judge_inside(int x,int y,int z)//判断 某位置 是否在房内 
{
	if(HR < x && x < HR + HX - 1)
	  if(HC < y && y < HC + HY - 1)
	    if(z < max_high) return 1;
	return 0;
}
void remove_excess(int &outside,int &inside)//移除 多余方块 
{
	for(int x = 0; x < N; x ++)//枚举 立体空间内 每一个位置 
	  for(int y = 0; y < N; y ++)
		for(int z = 0; z <= HM; z ++)
		  if(ice_block[x][y][z])//存在冰块 
		  {
		    if(judge_outside(x,y,z)) inventory ++, outside ++, ice_block[x][y][z] = 0;//在屋外 
		    if(judge_inside(x,y,z)) inventory ++, inside ++, ice_block[x][y][z] = 0;//在屋内 
			if(!ice_block[x][y][z])//冰块被移除后 
			  for(int i = 0; i < 6; i ++)
	  			if(x + EXX[i] >= 0 && x + EXX[i] < N && y + EXY[i] >= 0) //枚举相邻合法位置的 的 存在的 冰砖 
	    		  if(y + EXY[i] < N && z + EXZ[i] >= 0 && z + EXZ[i] <= HM)
	      			if(ice_block[x + EXX[i]][y + EXY[i]][z + EXZ[i]])
					  if(!judge_outside(x + EXX[i],y + EXY[i],z + EXZ[i]) && (!judge_inside(x + EXX[i],y + EXY[i],z + EXZ[i])))//如果在 墙壁上 
						{
						  memset(vis,0,sizeof(vis));	
						  if(!DFS1(x + EXX[i],y + EXY[i],z + EXZ[i],-1,-1,-1)) //如果 移除此位置后 墙壁上的 冰砖会摔碎 
						    inventory ++, ice_block[x + EXX[i]][y + EXY[i]][z + EXZ[i]] = 0;//将其移除 ,加入库存 
						}
		  }
}
bool fill_high_wall(int max_high)//填补 高度 >= 2处的墙 
{
	bool filled = 0;
	for(int x = HR; x < HR + HX; x ++)//枚举每一个位置 
	  for(int y = HC; y < HC + HY; y ++)
		for(int z = 2; z <= max_high; z ++)
		  if(!judge_outside(x,y,z))//判断 在墙上 
			if(!judge_inside(x,y,z))
			  if(!ice_block[x][y][z]) 
		      {
		      	if(x == HR && y == HC) continue;//在墙角,则 跳过 
		  		if(x == HR && y == HC + HY - 1) continue;
		  		if(x == HR + HX - 1 && y == HC) continue;
		  		if(x == HR + HX - 1 && y== HC + HY - 1) continue;
		  		inventory --, filled = 1, ice_block[x][y][z] = 1;//填补 
			  }
	return filled;//返回 是否填补过 
}
int judge_corner(int x,int y)//判断位置 (x,y) 是否与墙角相邻
{
	int ret = 0; //表示 一门的候选位置相邻的墙角 的 状态 
	if(x == HR)//枚举并判断 ,  
	{
	  if(y == HC + 1) ret += 1;
	  else if(y == HC + HY - 2) ret += 2;
	}
	if(x == HR + 1)
	{
	  if(y == HC) ret += 1;
	  else if(y == HC + HY - 1) ret += 2;
	}
	if(x == HR + HX - 2)
	{
	  if(y == HC) ret += 4;
	  else if(y == HC + HY - 1) ret += 8;
	}
	if(x == HR + HX - 1)
	{
	  if(y == HC + 1) ret += 4;
	  else if(y == HC + HY - 2) ret += 8;
	}
	return ret;
}
void corner_could_see(int x,int y,int z,int h,int &corner,int &corner_pos)//计算一个位置(x,y,z) 能看到的墙角的残缺数 
{
	corner_pos = judge_corner(x, y);//判断 是否哪个墙角, 并获得 此位置相邻的墙角 的 状态  
	corner = 0;
	if(!corner_pos) return;//不与墙角相邻 
	for(int i = 0; i < 4; i ++)//枚举墙角 
	  if((1 << i )& corner_pos)
	  {
	    int x1 = corner_x[1 << i], y1 = corner_y[1 << i];//计算残缺 
	    corner += (!ice_block[x1][y1][z]) + (!ice_block[x1][y1][!z])*(h == 2);
	  }
} 
bool find_door()//在 高度<2的位置 找门 ,并填补非门区域
{
	std:: vector <alternative_position> pos;//门的候选位置 
	int incomplete = 0, filled_sum = 0, corner_filled = 0;//残缺数, 填补数, 墙角位置的填补数 
	int midX1 = (HX + 1) /2 + HR - 1, midX2 = (HX + 2) /2 + HR - 1;//两墙壁中间位置 
	int midY1 = (HY + 1) /2 + HC - 1, midY2 = (HY + 2) /2 + HC - 1;

	for(int x = HR + 1, corner, corner_pos; x < HR + HX - 1; x ++)//枚举 墙上位置 
	  for(int y = HC; y < HC + HY; y += HY - 1)
	  	if(!ice_block[x][y][0])//根据 残缺的存在情况 进行判断 ,并加入候选位置 
	  	{
	  	  int z = 0, h = 1 + (!ice_block[x][y][1]);  incomplete += h;
	  	  corner_could_see(x,y,z,h,corner,corner_pos);
	  	  pos.push_back((alternative_position) {x,y,0,h,x,corner,corner_pos,midX1,midX2});
		}
		else if(!ice_block[x][y][1])
		{
	  	  corner_could_see(x,y,1,1,corner,corner_pos);  incomplete += 1;
	  	  pos.push_back((alternative_position) {x,y,1,1,x,corner,corner_pos,midX1,midX2});
		}
		
	for(int y = HC + 1, corner, corner_pos; y < HC + HY - 1; y ++)//枚举 墙上位置 
	  for(int x = HR; x < HR + HX; x += HX - 1)
	  	if(!ice_block[x][y][0])//根据 残缺的存在情况 进行判断 ,并加入候选位置 
	  	{
	  	  int z = 0, h = 1 + (!ice_block[x][y][1]); incomplete += h;
	  	  corner_could_see(x,y,z,h,corner,corner_pos);
	  	  pos.push_back((alternative_position) {x,y,0,h,y,corner,corner_pos,midY1,midY2});
		}
		else if(!ice_block[x][y][1])
		{
		  corner_could_see(x,y,1,1,corner,corner_pos); incomplete += 1;
	  	  pos.push_back((alternative_position) {x,y,1,1,y,corner,corner_pos,midY1,midY2});
		}
	
	std::sort(pos.begin(), pos.end(), cmp);//排序估值 
	if(pos.size()) //若有候选位置 可以选择 ,选择 最优的 位置 
	{
	  filled_sum = incomplete - pos[0].h + pos[0].corner; 
	  doorx = pos[0].x, doory = pos[0].y, doorz =  pos[0].z, door_high =pos[0].h;
	  door_dis = min(abs(pos[0].wall - pos[0].mid1), abs(pos[0].wall - pos[0].mid2));
	}
	if(door_high == 1 && filled_sum < inventory) //已选择的残缺大小为1, 库存冰块足够选择更大的残缺 
	  for(int i = 1, size = pos.size(); i < size; i ++)//找到 最优的 高度为2的残缺 
	    if(pos[i].h == 2) 
	    {
	      filled_sum = incomplete - pos[i].h + pos[i].corner;
	  	  doorx = pos[i].x, doory = pos[i].y, doorz =  pos[i].z, door_high = pos[i].h;
	  	  door_dis = min(abs(pos[i].wall - pos[i].mid1), abs(pos[i].wall - pos[i].mid2));
	  	  break;
		}
	inventory -= filled_sum;//更新库存 
	
	for(int i = 0, size = pos.size(); i < size; i ++)//填补 非门空缺 
	  if(pos[i].x != doorx && pos[i].y != doory && pos[i].z != doorz)//空缺 不为门 
	  {
	  	int x = pos[i].x, y = pos[i].y, z = pos[i].z;
		if(pos[i].h == 2) ice_block[x][y][1] = 1;
		ice_block[x][y][z] = 1;
	  }
	  else if(pos[i].x == doorx && pos[i].y == doory && pos[i].z == doorz && pos[i].corner_pos)
	  {
	  	for(int j = 0; j < 4; j ++) //空缺为门 , 填补 可以看到的墙角空缺 
		  if((1 << j) & pos[i].corner_pos)//枚举墙角 
		  {
		  	int x = corner_x[1 << j], y = corner_y[1 << j];//计算答案 
	  		corner_filled += (!ice_block[x][y][doorz]);
			ice_block[x][y][doorz] = 1;
	  		if(door_high == 2) corner_filled +=(!ice_block[x][y][!doorz]), ice_block[x][y][!doorz] = 1;
		  }
	  }
	return filled_sum;
}
```

---


最后无良宣传一下博客 $wwwwww$      
[文章列表 - 地灵殿 - 洛谷博客](https://www.luogu.org/blog/koishikoishi/) 

$\text{Updata on 2019.10.19 :}$    

数据加强后 原题解被卡掉了= =   
修改了 对在门与柱子相邻时 对柱子残缺的判断   
添加了 **算法实现**   

---

## 作者：tiger2005 (赞：29)

这篇文章将会从工程题目的角度对 [P3693 琪露诺的冰雪小屋](https://www.luogu.com.cn/problem/P3693) 进行分析。为了保证阅读的体验，建议先对题目进行阅读。如果只是看个爽的话，我会在每一步表明题面依据。

本文中的 `M` 代表题目中的 $H_M$，其余同理。

---

## Part 0: 必须元素构造

从题目中可以看到，整个场地实际上是一个 $N*N*M$ 的立方体，而琪露诺这个 ⑨ 会在这里面玩弹幕建高楼。因此，我们当然需要一个三维数组进行信息存储。

从后面提到的信息中可以知道的是，每一个格子中会有 0-4 的寒冷状态和一个冰块状态，因此我们将冰块映射至 5 并储存到三维数组中。

```cpp
struct IceHouse{
	short V[20][20][30];
	IceHouse(){memset(V, 0, sizeof(V));}
};
```

在平常我们使用的 dfs 中，通常会使用若干整型变量对坐标进行表示，但是我们发现对于维度上临近点的 dfs 中，我们每次对于每个变量进行操作 `_x[i] = x[i] + dir[i]`。为了准确性考虑，我们需要替换这种比较容易写错的形式，转而使用三维向量对三维空间上的点进行表达。为了迎合前面的公式，我们为这个三维向量加入加法的功能。

```cpp
struct Vec3{
	int x, y, z;
	Vec3(int x=0, int y=0, int z=0)
		:x(x), y(y), z(z){}
	Vec3 operator + (const Vec3& q)const{
		return Vec3(x+q.x, y+q.y, z+q.z);
	}
};
```

在我们使用 `Vec3` 类型对位置进行表达的时候，我们还需要对开始的 `IceHouse` 类型进行适配。我们对 `IceHouse` 类型进行修改：

```cpp
// return if x <= y <= z
inline bool inRange(int x, int y, int z){
	return y>=x && y<=z;
}
struct IceHouse{
	short V[20][20][30];
	IceHouse(){
		memset(V, 0, sizeof(V));
	}
	// check if the block is in the range
	inline bool check(Vec3 q){
		return inRange(0, q.x, N-1)
			&& inRange(0, q.y, N-1)
			&& inRange(0, q.z, M);
	}
	// get the value of the block
	inline short g(Vec3 x){
		if(!check(x))	return -1;
		return V[x.x][x.y][x.z];
	}
	// freeze the block
	inline void f(Vec3 x){
		V[x.x][x.y][x.z] = min(V[x.x][x.y][x.z]+1, 4);
	}
	// change the information of the block
	inline void c(Vec3 x, short v){
		V[x.x][x.y][x.z]=v;
	}
}House;
```

为了对之后的一些 dfs 提供辅助，在此定义一些常见的方向向量：

```cpp
// 2D direction vectors for UDLR
_2D4 = vector<Vec3>{Vec3(-1, 0, 0), Vec3(1, 0, 0), Vec3(0, -1, 0), Vec3(0, 1, 0)};
// 2D direction vectors for UDLR-UL-UR-DL-DR
_2D8 = vector<Vec3>{Vec3(-1, 0, 0), Vec3(-1, -1, 0), Vec3(0, -1, 0), Vec3(1, -1, 0),
						Vec3(1, 0, 0), Vec3(1, 1, 0), Vec3(0, 1, 0), Vec3(-1, 1, 0)};
// 3D direction vectors for UDLRFB
_3D6 = vector<Vec3>{Vec3(1, 0, 0), Vec3(-1, 0, 0), Vec3(0, 1, 0), Vec3(0, -1, 0),
						Vec3(0, 0, 1), Vec3(0, 0, -1)};
```

在准备好这些基础信息之后，我们可以准确的写出接下来的代码了。

## Part. 1: IceBarrage()

在第一个任务中，我们需要从一点向一个方向发送弹幕，在没有阻拦和衰弱允许的情况下增加经过块的寒冷值。

我们通过 `_2D8` 获得对应向量，每次对当前向量是否超出范围，以及当前块是否为冰块状态。随后进行判断和累加，并且将当前向量加上方向向量即可。

```cpp
int IceBlock;
inline void IceBarrage(int R, int C, int D, int S){
	Vec3 v = _2D8[D];
	Vec3 c = Vec3(R, C, 0);
	int s = 0; ++S;
	while(S--){
		if(!House.check(c) || House.g(c)==5)
			break;
		if(House.g(c) != 4)	++s;
		House.f(c);
		c = c + v;
	}
	printf("CIRNO FREEZED %d BLOCK(S)\n", s);
}
```

从这里其实就可以看出工程代码写法上的优势。在保证基础成分不出现错乱的情况下，实现中的代码可以非常轻松的写出对应的功能，并且减轻了调试压力。这一点在之后的很多地方可以展现。

## Part. 2: MakeIceBlock()

在这个任务中，我们需要对地面上的寒冷值进行计算，并且将寒冷值为 4 的块进行清理。

在这个时候，我们直接扫描整个地面即可。

```cpp
inline void MakeIceBlock(){
	int s = 0;
	for(int i = 0; i < N; i++)
		for(int j = 0; j < N; j++)
			if(House.g(Vec3(i, j, 0)) == 4){
				House.c(Vec3(i, j, 0), 0);
				++s;
			}
	IceBlock += s;
	printf("CIRNO MADE %d ICE BLOCK(S),NOW SHE HAS %d ICE BLOCK(S)\n", s, IceBlock);
}
```

## Part. 3: PutIceBlock() 

在这个例子中，我们需要将一个冰块放在一个块上。但是在这一个地方，对细节的处理已经开始了肉眼可见的升级。

对于“冰砖将放在半空中，无法依附其他任何冰砖”的条件，我们可以直接转换成 `p.z==0`（在地上）以及 `(p+_3D6[i]) => IceBlock`（在空中，需要依赖）两个条件。很轻松写出函数：

```cpp
// check if the block is close to something
inline bool AttachmentCheck(Vec3 v){
	if(v.z == 0)	return true;
	for(auto x: _3D6)
		if(House.g(v + x) == 5)	return true;
	return false;
}
```

随后的任务变成简单的可行性判断，直接讨论即可：

```cpp
inline void PutIceBlock(int r, int c, int h){
	Vec3 v(r, c, h);
	// no ice block left
	if(IceBlock == 0){
		printf("CIRNO HAS NO ICE_BLOCK\n");
		return;
	}
	// cannot be put
	if(House.g(v) == 5 || !AttachmentCheck(v)){
		printf("BAKA CIRNO,CAN'T PUT HERE\n");
		return;
	}
	House.c(v, 5); --IceBlock;
	// check if the block is at the wrong place
	if(v.x < R || v.x > R+X-1 || v.y < C || v.y > C+Y-1)
		printf("CIRNO MISSED THE PLACE\n");
	else if(v.x >= R+1 && v.x <= R+X-2 && v.y >= C+1 && v.y <= C+Y-2)
		printf("CIRNO PUT AN ICE_BLOCK INSIDE THE HOUSE\n");
	else
		printf("CIRNO SUCCESSFULLY PUT AN ICE_BLOCK,NOW SHE HAS %d ICE_BLOCK(S)\n", IceBlock);
}
```

## Part. 4: RemoveIceBlock()

在这个任务中，我们需要将一个冰块移除，并且计算和清理浮空的冰块。

在对异常进行处理之后，我们需要判断删除这个冰块后哪些块会悬浮在空中。此时需要对这个冰块临近的六个块进行 dfs，并且查看是否有贴近地面的块。

```cpp
int BrokenIce;
bool AttachmentIf;
bool hav[20][20][30];
vector<Vec3> List;
void dfsRemove(Vec3 v){
	hav[v.x][v.y][v.z] = true;
	List.push_back(v);
	if(v.z == 0)	AttachmentIf = true;
	for(auto x: _3D6){
		Vec3 p = v + x;
		if(House.g(p) == 5 && !hav[p.x][p.y][p.z])
			dfsRemove(p);
	}
}
// check if the block is float and remove them
inline void RemoveFloatIce(Vec3 v){
	if(House.g(v) != 5)	return;
	AttachmentIf = false;
	dfsRemove(v);
	for(auto y: List)
		hav[y.x][y.y][y.z] = false;
	if(!AttachmentIf){
		BrokenIce += List.size();
		for(auto y: List)
			House.c(y, 0);
	}
	List.clear();
}
// check if the block is float
inline bool isFloatIce(Vec3 v){
	if(House.g(v) != 5)	return false;
	AttachmentIf = false;
	dfsRemove(v);
	for(auto y: List)
		hav[y.x][y.y][y.z] = false;
	List.clear();
	return !AttachmentIf;
}
```

随后的任务变成简单的可行性判断，直接讨论即可：

```cpp
inline void RemoveIceBlock(int r, int c, int h){
	Vec3 v(r, c, h);
	// no ice block here
	if(House.g(v) != 5){
		printf("BAKA CIRNO,THERE IS NO ICE_BLOCK\n");
		return;
	}
	House.c(v, 0);
	BrokenIce = 0;
	// remove the float ice block
	for(auto x: _3D6)
		RemoveFloatIce(v + x);
	if(BrokenIce)
		printf("CIRNO REMOVED AN ICE_BLOCK,AND %d BLOCK(S) ARE BROKEN\n", BrokenIce);
	else	printf("CIRNO REMOVED AN ICE_BLOCK\n");
	++IceBlock;
}
```

## Part. 5: MakeRoof()

这个任务是整个题目中最难进行分析的任务，里面包含非常多的子任务。我们逐一进行分析。

首先，我们需要知道那些地方位于外围，哪些位于屋顶的投影。我们可以使用前面的 `inRange()` 函数进行编写的简化。

```cpp
vector<Vec3> Surround, Roof;
// initialize the surrounding and the roof
for(int i = 0; i < N; i++)
	for(int j = 0; j < N; j++){
		if(inRange(R, i, R+X-1)
		&& inRange(C, j, C+Y-1)
		&& (!inRange(R+1, i, R+X-2)
		|| !inRange(C+1, j, C+Y-2)))
			Surround.push_back(Vec3(i, j, 0));
		if(i >= R && i <= R + X - 1
		&& j >= C && j <= C + Y - 1)
			Roof.push_back(Vec3(i, j, 0));
	}
```

随后枚举每一个墙壁面上面的块获得高度，随后，对屋顶上面的所有点进行非冰块状态的统计，在判断特殊状况之后填满就行。

```cpp
// calculate the height of the building
for(auto x: Surround){
	for(int h = 0; h <= M; h++)
		if(House.g(x + Vec3(0, 0, h)) == 5)
			H = max(H, h + 1);
}
// get the ice block needed to cover the roof
int nd = 0;
for(auto x: Roof){
	nd += House.g(x + Vec3(0, 0, H)) != 5;
}
// check if the ice block is enough
if(nd > IceBlock){
	printf("SORRY CIRNO,NOT ENOUGH ICE_BLOCK(S) TO MAKE ROOF\n");
	return;
}
// check the room is big enough
if(H < 1 || X == 2 || Y == 2 || (X == 3 && Y == 3 && H == 1)){
	printf("SORRY CIRNO,HOUSE IS TOO SMALL\n");
	return;
}
// cover the roof
for(auto x: Roof)
	House.c(x + Vec3(0, 0, H), 5);
IceBlock -= nd;
```

在获得高度之后我们可以灵活运用 `inRange()` 函数写出以下函数（含义建议自行理解）：

```cpp
inline bool checkWall(Vec3 x){
	return x.x == R || x.x == R + X - 1
		|| x.y == C || x.y == C + Y - 1;
}
inline bool checkInside(Vec3 x){
	return inRange(R+1, x.x, R+X-2)
		&& inRange(C+1, x.y, C+Y-2)
		&& inRange(0, x.z, H-1);
}
inline bool checkOutside(Vec3 x){
	return !(inRange(R, x.x, R+X-1)
		&& inRange(C, x.y, C+Y-1)
		&& inRange(0, x.z, H));
}
inline bool checkPillar(Vec3 x){
	return (x.x == R || x.x == R + X - 1)
		&& (x.y == C || x.y == C + Y - 1);
}
inline bool checkPerfect(Vec3 x){
	return x.x == PX1 || x.x == PX2
		|| x.y == PY1 || x.y == PY2;
}
```

其中：

```cpp
// two perfect locations of X and Y
PX1 = R + X / 2; PX2 = R + (X - 1) / 2;
PY1 = C + Y / 2; PY2 = C + (Y - 1) / 2;
```

这些函数在编写完毕之后，在之后会产生强大的用处。

接下来我们需要清扫内部和外部的的冰块。这个时候我们直接枚举并且使用上面的 `checkInside()` 和 `checkOutside()` 函数判断就好了。在删除完毕之后，我们需要判断墙壁冰块的松动性。我们发现，如果一个块在删除之后会掉下来，那么我们可以在它的最后一个连接断开的时候进行判断。

由于所有的不符合位置的块都需要删除，所以我们在删除它们的时候可以不用考虑重力上的问题，因为都会被删除掉的。因此我们在删除的时候判断相邻的块是不是墙壁上漂浮的块，就可以判断漂浮的快需不需要回收了。

```cpp
for(int i = 0; i < N; i++)
	for(int j = 0; j < N; j++)
		for(int k = 0; k <= M; k ++)
			if(House.g(Vec3(i, j, k)) == 5){
				// check the type of the ice block
				if(checkInside(Vec3(i, j, k)))	++ins;
				else if(checkOutside(Vec3(i, j, k)))	++ous;
				else	continue;
				// remove the block
				++IceBlock; removeBlock = true;
				House.c(Vec3(i, j, k), 0);
				// check if the wall ice block is near
				for(auto x: _3D6){
					Vec3 p = Vec3(i, j, k) + x;
					if(!checkWall(p))	continue;
					if(isFloatIce(p)){
						++IceBlock;
						House.c(p, 0);
					}
				}
			}
printf("%d ICE_BLOCK(S) INSIDE THE HOUSE NEED TO BE REMOVED\n", ins);
printf("%d ICE_BLOCK(S) OUTSIDE THE HOUSE NEED TO BE REMOVED\n", ous);
// the roof is giong to drop
if(isFloatIce(Vec3(R+1, C+1, H))){
	printf("SORRY CIRNO,HOUSE IS BROKEN WHEN REMOVING BLOCKS\n");
	return;
}
```

接下来到了判断门的这一步。请注意，在此处被填上的柱子 **算作墙**。

我们需要计算每一个门对应需要补全多少冰块。我们发现第三层开始的缺失和门的位置选择毫无关系，所以我们单独把它们列出来：

```cpp
// fix the hole of third floor and above
for(auto x: Surround) if(!checkPillar(x))
	for(int h = 2; h < H; h++){
		if(House.g(x + Vec3(0, 0, h)) == 5)	continue;
		if(!IceBlock){
			printf("SORRY CIRNO,NOT ENOUGH ICE_BLOCKS TO FIX THE WALL\n");
			return;
		}
		House.c(x + Vec3(0, 0, h), 5);
		--IceBlock; fixWall = true;
	}
// and store the rest of the holes on the wall
nd = 0;
for(auto x: Surround) if(!checkPillar(x))
	for(int h = 0; h < 2; h++)
		nd += House.g(x + Vec3(0, 0, h)) != 5;
```

接下来，思考一下对于每一个门需要储存什么信息。首先我们要储存其位置和大小（一些门有可能只开了一半，后面还要重新开一次，或者说，在本身的设计上本来就要有一个 1\*2 的门，而 1\*1 的门是一种妥协），还有选择作为门的时候我们需要补充多少个冰块，外加这个门是不是完美的。

所以我们需要储存五个信息，在对门的筛选上，我们采用 补充升序-门大小升序（因为在后面 `PERFECT` 的判定就是有一个完整的门）-是否完美作为排序依据。

```cpp
struct Door{
	// location, perfect, cost, height (size of hole)
	int x, y, p, s, h;
	Door(int x=0, int y=0, int p=0, int s=0, int h=0)
		:x(x), y(y), p(p), s(s), h(h){}
	bool operator < (const Door& q)const{
		if(s != q.s)	return s < q.s;
		if(h != q.h)	return h > q.h;
		if(p != q.p)	return p < q.p;
		if(x != q.x)	return x < q.x;
		return y < q.y;
	}
}DR;
```

在求出这些条件下的最优解是 1\*1 的门的情况下，我们还需要特殊判断：如果确实有一个 1\*2 的门，那么我们就要选那个 1\*2 的门，尽管选择 1\*1 的方案取出的冰块更少，原理同上。

在计算需要填上的冰块时，我们除了墙上的，还需要注意柱子上的。我们在这里假设琪露诺只能平视，那么我们只需要看缺失的高度上可以看到的柱子部分即可。

对于找到相邻的柱子，其实并不需要太麻烦。想到开始预处理的 `_2D4` 和 `checkPillar()` 了吗？这会帮我们一个大忙。

```cpp
vector<Door> D; D.clear();
for(auto x: Surround) if(!checkPillar(x)){
	// get hole size
	int q = ((House.g(x) != 5) + (House.g(x + Vec3(0, 0, 1)) != 5));
	if(q == 0)	continue;
	// create new door
	Door curr(x.x, x.y, checkPerfect(x), nd - q, q);
	// check if the pillar is visible
	for(auto y: _2D4) if(checkPillar(x + y))
		for(int h = 0; h < 2; h++)
			if(House.g(x + Vec3(0, 0, h)) != 5)
			curr.s += (House.g(x + y + Vec3(0, 0, h)) != 5);
	D.push_back(curr);
}
sort(D.begin(), D.end());
if(D.size() == 0 || IceBlock < D[0].s){
	printf("SORRY CIRNO,NOT ENOUGH ICE_BLOCKS TO FIX THE WALL\n");
	return;
}
DR = D[0];
// change to 1*2 if current chosen is 1*1
if(IceBlock > DR.s && DR.h == 1)
	for(auto d: D)
		if(d.h == 2){
			DR = d;
			break;
		}
// fill the hole of pillars
Vec3 _DR = Vec3(DR.x, DR.y, 0);
for(auto y: _2D4) if(checkPillar(_DR + y))
	for(int h = 0; h < H; h++)
		if(House.g(_DR + y + Vec3(0, 0, h)) != 5
		&& House.g(_DR + Vec3(0, 0, h)) != 5){
			--IceBlock; fixWall = true;
			House.c(_DR + y + Vec3(0, 0, h), 5);
		}
// fill the hole of walls
for(auto x: Surround) if(!checkPillar(x) && x != _DR)
	for(int h = 0; h < 2; h++){
		if(House.g(x + Vec3(0, 0, h)) == 5)	continue;
		House.c(x + Vec3(0, 0, h), 5);
		--IceBlock; fixWall = true;
	}
```

接下来，到了任务结算的成分！先来一句：

```cpp
printf("GOOD JOB CIRNO,SUCCESSFULLY BUILT THE HOUSE\n");
```

随后根据每一项进行评分：

在贴近地面的位置找不到一个宽度为 1，高度为 2 的位置留给门 => `DR.h == 2`

填补之前墙壁的完整程度 => `fixWall`

四角的完整程度 => 对柱子上的缺口进行汇总判断即可

然后在前面的条件全部达成的情况下，保证 `removeBlock == false`（没有删掉屋内屋外的冰块）以及 `DR.p`（门的位置是好的）之后，我们就可以说这次的建房子行动 ALL PERFECT!

```cpp
bool AllPerfect = true;
// check the size of the foor
if(DR.h == 2)	printf("DOOR IS OK\n");
else	printf("HOUSE HAS NO DOOR\n"), AllPerfect = false;
// totally open the door
if(House.g(_DR) == 5){
	++IceBlock; House.c(_DR, 0);
}
if(House.g(_DR + Vec3(0, 0, 1)) == 5){
	++IceBlock; House.c(_DR + Vec3(0, 0, 1), 0);
}
// check if the walls have been fixed
if(!fixWall)	printf("WALL IS OK\n");
else	printf("WALL NEED TO BE FIXED\n"), AllPerfect = false;
// check if the pillars are still bloken
nd = 0;
for(auto x: Surround) if(checkPillar(x)){
	for(int h = 0; h < H; h++){
		if(House.g(x + Vec3(0, 0, h)) == 5)	continue;
		House.c(x + Vec3(0, 0, h), 5);
		++nd;
	}
}
if(nd == 0)	printf("CORNER IS OK\n");
else	printf("CORNER NEED TO BE FIXED\n"), AllPerfect = false;
// recalculate the ice block
IceBlock = max(IceBlock - nd, 0);
printf("CIRNO FINALLY HAS %d ICE_BLOCK(S)\n", IceBlock);
// check if this is ALL PERFECT
AllPerfect &= !removeBlock;
AllPerfect &= DR.p;
if(AllPerfect)
	printf("CIRNO IS PERFECT!\n");
```

## Part. 6: 代码整合

由于我们对函数的命名非常规整，所以直接进行引用就好了。

在这里放出所有的代码，其中省略了快速读入流 `iocin`（用法同 `cin`）以及头文件。

```cpp
int N, M, R, C, X, Y, T, H;
int PX1, PX2, PY1, PY2;
struct Vec3{
	int x, y, z;
	Vec3(int x=0, int y=0, int z=0)
		:x(x), y(y), z(z){}
	Vec3 operator + (const Vec3& q)const{
		return Vec3(x+q.x, y+q.y, z+q.z);
	}
	bool operator != (const Vec3& q)const{
		return x != q.x || y != q.y || z != q.z;
	}
};
struct Door{
	// location, perfect, cost, height (size of hole)
	int x, y, p, s, h;
	Door(int x=0, int y=0, int p=0, int s=0, int h=0)
		:x(x), y(y), p(p), s(s), h(h){}
	bool operator < (const Door& q)const{
		if(s != q.s)	return s < q.s;
		if(h != q.h)	return h > q.h;
		if(p != q.p)	return p < q.p;
		if(x != q.x)	return x < q.x;
		return y < q.y;
	}
}DR;
// return if x <= y <= z
inline bool inRange(int x, int y, int z){
	return y>=x && y<=z;
}
int IceBlock;
vector<Vec3> _2D4, _2D8, _3D6;
struct IceHouse{
	short V[20][20][30];
	IceHouse(){
		memset(V, 0, sizeof(V));
	}
	// check if the block is in the range
	inline bool check(Vec3 q){
		return inRange(0, q.x, N-1)
			&& inRange(0, q.y, N-1)
			&& inRange(0, q.z, M);
	}
	// get the value of the block
	inline short g(Vec3 x){
		if(!check(x))	return -1;
		return V[x.x][x.y][x.z];
	}
	// freeze the block
	inline void f(Vec3 x){
		V[x.x][x.y][x.z] = min(V[x.x][x.y][x.z]+1, 4);
	}
	// change the information of the block
	inline void c(Vec3 x, short v){
		V[x.x][x.y][x.z]=v;
	}
}House;
inline void IceBarrage(int R, int C, int D, int S){
	Vec3 v = _2D8[D];
	Vec3 c = Vec3(R, C, 0);
	int s = 0; ++S;
	while(S--){
		if(!House.check(c) || House.g(c)==5)
			break;
		if(House.g(c) != 4)	++s;
		House.f(c);
		c = c + v;
	}
	printf("CIRNO FREEZED %d BLOCK(S)\n", s);
}
inline void MakeIceBlock(){
	int s = 0;
	for(int i = 0; i < N; i++)
		for(int j = 0; j < N; j++)
			if(House.g(Vec3(i, j, 0)) == 4){
				House.c(Vec3(i, j, 0), 0);
				++s;
			}
	IceBlock += s;
	printf("CIRNO MADE %d ICE BLOCK(S),NOW SHE HAS %d ICE BLOCK(S)\n", s, IceBlock);
}
// check if the block is close to something
inline bool AttachmentCheck(Vec3 v){
	if(v.z == 0)	return true;
	for(auto x: _3D6)
		if(House.g(v + x) == 5)	return true;
	return false;
}
inline void PutIceBlock(int r, int c, int h){
	Vec3 v(r, c, h);
	// no ice block left
	if(IceBlock == 0){
		printf("CIRNO HAS NO ICE_BLOCK\n");
		return;
	}
	// cannot be put
	if(House.g(v) == 5 || !AttachmentCheck(v)){
		printf("BAKA CIRNO,CAN'T PUT HERE\n");
		return;
	}
	House.c(v, 5); --IceBlock;
	// check if the block is at the wrong place
	if(v.x < R || v.x > R+X-1 || v.y < C || v.y > C+Y-1)
		printf("CIRNO MISSED THE PLACE\n");
	else if(v.x >= R+1 && v.x <= R+X-2 && v.y >= C+1 && v.y <= C+Y-2)
		printf("CIRNO PUT AN ICE_BLOCK INSIDE THE HOUSE\n");
	else
		printf("CIRNO SUCCESSFULLY PUT AN ICE_BLOCK,NOW SHE HAS %d ICE_BLOCK(S)\n", IceBlock);
}
int BrokenIce;
bool AttachmentIf;
bool hav[20][20][30];
vector<Vec3> List;
void dfsRemove(Vec3 v){
	hav[v.x][v.y][v.z] = true;
	List.push_back(v);
	if(v.z == 0)	AttachmentIf = true;
	for(auto x: _3D6){
		Vec3 p = v + x;
		if(House.g(p) == 5 && !hav[p.x][p.y][p.z])
			dfsRemove(p);
	}
}
// check if the block is float and remove them
inline void RemoveFloatIce(Vec3 v){
	if(House.g(v) != 5)	return;
	AttachmentIf = false;
	dfsRemove(v);
	for(auto y: List)
		hav[y.x][y.y][y.z] = false;
	if(!AttachmentIf){
		BrokenIce += List.size();
		for(auto y: List)
			House.c(y, 0);
	}
	List.clear();
}
// check if the block is float
inline bool isFloatIce(Vec3 v){
	if(House.g(v) != 5)	return false;
	AttachmentIf = false;
	dfsRemove(v);
	for(auto y: List)
		hav[y.x][y.y][y.z] = false;
	List.clear();
	return !AttachmentIf;
}
inline void RemoveIceBlock(int r, int c, int h){
	Vec3 v(r, c, h);
	// no ice block here
	if(House.g(v) != 5){
		printf("BAKA CIRNO,THERE IS NO ICE_BLOCK\n");
		return;
	}
	House.c(v, 0);
	BrokenIce = 0;
	// remove the float ice block
	for(auto x: _3D6)
		RemoveFloatIce(v + x);
	if(BrokenIce)
		printf("CIRNO REMOVED AN ICE_BLOCK,AND %d BLOCK(S) ARE BROKEN\n", BrokenIce);
	else	printf("CIRNO REMOVED AN ICE_BLOCK\n");
	++IceBlock;
}
vector<Vec3> Surround, Roof;
inline bool checkWall(Vec3 x){
	return x.x == R || x.x == R + X - 1
		|| x.y == C || x.y == C + Y - 1;
}
inline bool checkInside(Vec3 x){
	return inRange(R+1, x.x, R+X-2)
		&& inRange(C+1, x.y, C+Y-2)
		&& inRange(0, x.z, H-1);
}
inline bool checkOutside(Vec3 x){
	return !(inRange(R, x.x, R+X-1)
		&& inRange(C, x.y, C+Y-1)
		&& inRange(0, x.z, H));
}
inline bool checkPillar(Vec3 x){
	return (x.x == R || x.x == R + X - 1)
		&& (x.y == C || x.y == C + Y - 1);
}
inline bool checkPerfect(Vec3 x){
	return x.x == PX1 || x.x == PX2
		|| x.y == PY1 || x.y == PY2;
}
inline void MakeRoof(){
	// initialize the surrounding and the roof
	for(int i = 0; i < N; i++)
		for(int j = 0; j < N; j++){
			if(inRange(R, i, R+X-1)
			&& inRange(C, j, C+Y-1)
			&& (!inRange(R+1, i, R+X-2)
			|| !inRange(C+1, j, C+Y-2)))
				Surround.push_back(Vec3(i, j, 0));
			if(i >= R && i <= R + X - 1
			&& j >= C && j <= C + Y - 1)
				Roof.push_back(Vec3(i, j, 0));
		}
	// calculate the height of the building
	for(auto x: Surround){
		for(int h = 0; h <= M; h++)
			if(House.g(x + Vec3(0, 0, h)) == 5)
				H = max(H, h + 1);
	}
	// get the ice block needed to cover the roof
	int nd = 0;
	for(auto x: Roof){
		nd += House.g(x + Vec3(0, 0, H)) != 5;
	}
	// check if the ice block is enough
	if(nd > IceBlock){
		printf("SORRY CIRNO,NOT ENOUGH ICE_BLOCK(S) TO MAKE ROOF\n");
		return;
	}
	// check the room is big enough
	if(H < 1 || X == 2 || Y == 2 || (X == 3 && Y == 3 && H == 1)){
		printf("SORRY CIRNO,HOUSE IS TOO SMALL\n");
		return;
	}
	// cover the roof
	for(auto x: Roof)
		House.c(x + Vec3(0, 0, H), 5);
	IceBlock -= nd;
	int ins = 0, ous = 0;
	bool fixWall = false;
	bool removeBlock = false;
	for(int i = 0; i < N; i++)
		for(int j = 0; j < N; j++)
			for(int k = 0; k <= M; k ++)
				if(House.g(Vec3(i, j, k)) == 5){
					// check the type of the ice block
					if(checkInside(Vec3(i, j, k)))	++ins;
					else if(checkOutside(Vec3(i, j, k)))	++ous;
					else	continue;
					// remove the block
					++IceBlock; removeBlock = true;
					House.c(Vec3(i, j, k), 0);
					// check if the wall ice block is near
					for(auto x: _3D6){
						Vec3 p = Vec3(i, j, k) + x;
						if(!checkWall(p))	continue;
						if(isFloatIce(p)){
							++IceBlock;
							House.c(p, 0);
						}
					}
				}
	printf("%d ICE_BLOCK(S) INSIDE THE HOUSE NEED TO BE REMOVED\n", ins);
	printf("%d ICE_BLOCK(S) OUTSIDE THE HOUSE NEED TO BE REMOVED\n", ous);
	// the roof is giong to drop
	if(isFloatIce(Vec3(R+1, C+1, H))){
		printf("SORRY CIRNO,HOUSE IS BROKEN WHEN REMOVING BLOCKS\n");
		return;
	}
	// fix the hole of third floor and above
	for(auto x: Surround) if(!checkPillar(x))
		for(int h = 2; h < H; h++){
			if(House.g(x + Vec3(0, 0, h)) == 5)	continue;
			if(!IceBlock){
				printf("SORRY CIRNO,NOT ENOUGH ICE_BLOCKS TO FIX THE WALL\n");
				return;
			}
			House.c(x + Vec3(0, 0, h), 5);
			--IceBlock; fixWall = true;
		}
	// and store the rest of the holes on the wall
	nd = 0;
	for(auto x: Surround) if(!checkPillar(x))
		for(int h = 0; h < 2; h++)
			nd += House.g(x + Vec3(0, 0, h)) != 5;
	vector<Door> D; D.clear();
	for(auto x: Surround) if(!checkPillar(x)){
		// get hole size
		int q = ((House.g(x) != 5) + (House.g(x + Vec3(0, 0, 1)) != 5));
		if(q == 0)	continue;
		// create new door
		Door curr(x.x, x.y, checkPerfect(x), nd - q, q);
		// check if the pillar is visible
		for(auto y: _2D4) if(checkPillar(x + y))
			for(int h = 0; h < 2; h++)
				if(House.g(x + Vec3(0, 0, h)) != 5)
				curr.s += (House.g(x + y + Vec3(0, 0, h)) != 5);
		D.push_back(curr);
	}
	sort(D.begin(), D.end());
	if(D.size() == 0 || IceBlock < D[0].s){
		printf("SORRY CIRNO,NOT ENOUGH ICE_BLOCKS TO FIX THE WALL\n");
		return;
	}
	DR = D[0];
	// change to 1*2 if current chosen is 1*1
	if(IceBlock > DR.s && DR.h == 1)
		for(auto d: D)
			if(d.h == 2){
				DR = d;
				break;
			}
	// fill the hole of pillars
	Vec3 _DR = Vec3(DR.x, DR.y, 0);
	for(auto y: _2D4) if(checkPillar(_DR + y))
		for(int h = 0; h < H; h++)
			if(House.g(_DR + y + Vec3(0, 0, h)) != 5
			&& House.g(_DR + Vec3(0, 0, h)) != 5){
				--IceBlock; fixWall = true;
				House.c(_DR + y + Vec3(0, 0, h), 5);
			}
	// fill the hole of walls
	for(auto x: Surround) if(!checkPillar(x) && x != _DR)
		for(int h = 0; h < 2; h++){
			if(House.g(x + Vec3(0, 0, h)) == 5)	continue;
			House.c(x + Vec3(0, 0, h), 5);
			--IceBlock; fixWall = true;
		}
	printf("GOOD JOB CIRNO,SUCCESSFULLY BUILT THE HOUSE\n");
	bool AllPerfect = true;
	// check the size of the foor
	if(DR.h == 2)	printf("DOOR IS OK\n");
	else	printf("HOUSE HAS NO DOOR\n"), AllPerfect = false;
	// totally open the door
	if(House.g(_DR) == 5){
		++IceBlock; House.c(_DR, 0);
	}
	if(House.g(_DR + Vec3(0, 0, 1)) == 5){
		++IceBlock; House.c(_DR + Vec3(0, 0, 1), 0);
	}
	// check if the walls have been fixed
	if(!fixWall)	printf("WALL IS OK\n");
	else	printf("WALL NEED TO BE FIXED\n"), AllPerfect = false;
	// check if the pillars are still bloken
	nd = 0;
	for(auto x: Surround) if(checkPillar(x)){
		for(int h = 0; h < H; h++){
			if(House.g(x + Vec3(0, 0, h)) == 5)	continue;
			House.c(x + Vec3(0, 0, h), 5);
			++nd;
		}
	}
	if(nd == 0)	printf("CORNER IS OK\n");
	else	printf("CORNER NEED TO BE FIXED\n"), AllPerfect = false;
	// recalculate the ice block
	IceBlock = max(IceBlock - nd, 0);
	printf("CIRNO FINALLY HAS %d ICE_BLOCK(S)\n", IceBlock);
	// check if this is ALL PERFECT
	AllPerfect &= !removeBlock;
	AllPerfect &= DR.p;
	if(AllPerfect)
		printf("CIRNO IS PERFECT!\n");
}
int main(){
	// 2D direction vectors for UDLR
	_2D4 = vector<Vec3>{Vec3(-1, 0, 0), Vec3(1, 0, 0), Vec3(0, -1, 0), Vec3(0, 1, 0)};
	// 2D direction vectors for UDLR-UL-UR-DL-DR
	_2D8 = vector<Vec3>{Vec3(-1, 0, 0), Vec3(-1, -1, 0), Vec3(0, -1, 0), Vec3(1, -1, 0),
						Vec3(1, 0, 0), Vec3(1, 1, 0), Vec3(0, 1, 0), Vec3(-1, 1, 0)};
	// 3D direction vectors for UDLRFB
	_3D6 = vector<Vec3>{Vec3(1, 0, 0), Vec3(-1, 0, 0), Vec3(0, 1, 0), Vec3(0, -1, 0),
						Vec3(0, 0, 1), Vec3(0, 0, -1)};
	iocin >> N >> M >> R >> C >> X >> Y >> T;
	// two perfect locations of X and Y
	PX1 = R + X / 2; PX2 = R + (X - 1) / 2;
	PY1 = C + Y / 2; PY2 = C + (Y - 1) / 2;
	string str;
	while(T--){
		iocin >> str;
		if(str == "ICE_BARRAGE"){
			int r, c, d, s;
			iocin >> r >> c >> d >> s;
			IceBarrage(r, c, d, s);
		}
		else if(str == "MAKE_ICE_BLOCK"){
			MakeIceBlock();
		}
		else if(str == "PUT_ICE_BLOCK"){
			int r, c, h;
			iocin >> r >> c >> h;
			PutIceBlock(r, c, h);
		}
		else if(str == "REMOVE_ICE_BLOCK"){
			int r, c, h;
			iocin >> r >> c >> h;
			RemoveIceBlock(r, c, h);
		}
		else if(str == "MAKE_ROOF"){
			MakeRoof();
		}
	}
	return 0;
}
```

希望这篇题解可以让大家清楚工程类代码编写过程中的复杂性和稳定性，也希望这篇题解可以让你清楚这个题目背后运行的逻辑。

---

## 作者：hehezhou (赞：10)

[可以在我的博客食用(没说效果更佳)](https://hehezhou.github.io/2019/06/15/node-js-P3693/#more)  
[题面](https://www.luogu.org/problemnew/show/P3693)  
显然模拟即可  
操作一:普及T1(早年)水平 直接for一遍就好了，记得判断出界或撞冰砖  
操作二:普及T1(近年)水平，直接for一遍就好了  
操作三:普及T1(早年)水平，判断一下有没有，是否连的上即可 记得地面冰冻度清零  
操作四:普及T2水平，由于数据范围很小，移走后直接对整图bfs判断是否接地即可  
操作五:  
有点烦琐  
首先是造房顶，普及T2水平，max出高度然后for一遍就好了  
接着是清理垃圾  
由于一定存在一种方式使得没有一个冰砖破碎  
所以直接内外拿掉再整图bfs一遍算墙上要拿多少  
记得判断房顶塌陷，房间过小  
然后补残缺，重点来了  
注意一下加红的**大多数**  
因为当门开在转角边上是要清理拐角的,因为房子里看的到  
好像题解里的老哥用了一大堆分类讨论  
其实并不用  
只要暴力枚举门的位置，然后算出来就可以了  
然后**注意**：当需要冰砖数相同的时候，应尽可能让拐角空位少一些，然后尽可能达到perfect  
也就是以(需要砖块数，拐角空位，完美)进行三关键字排序  
然后造门  
然后造角  
最后判断完美，以下条件缺一不可:1.门天然形成，开在正中间 2.不用填墙 3.不用补拐角 4.不需要清理垃圾
然后就做完了  
坑点不是很多，主要是那个柱子有的时候需要填补，以及最后一行不换行(Too long on line 1001???)  
js里输出有两个:console.log()换行 和 process.stdout.write()不换行(查了半天才查到)  
```js
"use strict";
const IO = require("readline").createInterface(process.stdin, process.stdout);
var nowline = 0, n, hm, sx, sy, ex, ey, m;
var optlist = [];
var map = [], ice = [];

IO.on("close", function () {
    process.exit();
});

var blockcnt = 0;

var fx = [-1, -1, 0, 1, 1, 1, 0, -1], fy = [0, -1, -1, -1, 0, 1, 1, 1];

function inmap(x, y, z) {
    return x >= 0 && x < n && y >= 0 && y < n && z >= 0 && z <= hm;
}

var get_size = (function() {
    var fx = [1, -1, 0, 0, 0, 0], fy = [0, 0, 1, -1, 0, 0], fz = [0, 0, 0, 0, 1, -1];
    return function(x, y, z) {
        var ans = 0;
        for(let i = 0; i < 6; i++)
            if(inmap(x + fx[i], y + fy[i], z + fz[i])) ans += map[x + fx[i]][y + fy[i]][z + fz[i]];
            else if(z + fz[i] < 0) ans++;
        return ans;
    }
})();//两个方向数组，不想用两个变量名

function ice_barrage(x, y, d, s) {
    x = Number(x), y = Number(y), d = Number(d), s = Number(s);
    var ans = 0;
    for(var i = 0; i <= s; i++) {
        // process.stdout.write(inmap(x, y, 0) + ' ' + map[x][y][0]);
        // process.stdout.write(x + ' ' + y + ' ' + 0);
        if(inmap(x, y, 0) && map[x][y][0] == 0) {
            if(ice[x][y] < 4) ice[x][y]++, ans++;
        }
        else break;
        x = x + fx[d], y = y + fy[d];
    }
    process.stdout.write("CIRNO FREEZED " + ans + " BLOCK(S)");
}//操作1

function make_ice_block() {
    var ans = 0;
    for(var i = 0; i < n; i++)
        for(var j = 0; j < n; j++) if(ice[i][j] == 4) ice[i][j] = 0, ans++;
    process.stdout.write("CIRNO MADE " + ans + " ICE BLOCK(S),NOW SHE HAS " + (ans + blockcnt) + " ICE BLOCK(S)");
    blockcnt += ans;
}//操作2

function inroom(x, y) {
    return x > sx && x < ex && y > sy && y < ey;
}//严格在屋子里面

function outroom(x, y) {
    return x < sx || x > ex || y < sy || y > ey;
}//严格在屋子外面 不管屋顶

function put_ice_block(x, y, z) {
    x = Number(x), y = Number(y), z = Number(z);
    if(blockcnt == 0) process.stdout.write("CIRNO HAS NO ICE_BLOCK");
    else if(!inmap(x, y, z) || map[x][y][z] || get_size(x, y, z) == 0) process.stdout.write("BAKA CIRNO,CAN'T PUT HERE");
    else {
        map[x][y][z] = 1;
        if(z == 0) ice[x][y] = 0;//注意！！！
        blockcnt -= 1;
        if(outroom(x, y)) process.stdout.write("CIRNO MISSED THE PLACE");
        else if(inroom(x, y)) process.stdout.write("CIRNO PUT AN ICE_BLOCK INSIDE THE HOUSE");
        else process.stdout.write("CIRNO SUCCESSFULLY PUT AN ICE_BLOCK,NOW SHE HAS " + blockcnt + " ICE_BLOCK(S)");
    }
}

var updata;//bfs找破碎冰砖数(详情见main函数里)

function remove_ice_block(x, y, z) {
    x = Number(x), y = Number(y), z = Number(z);
    if(!inmap(x, y, z) || map[x][y][z] == 0) process.stdout.write("BAKA CIRNO,THERE IS NO ICE_BLOCK");
    else {
        map[x][y][z] = 0;
        let k = updata();
        if(k != 0) process.stdout.write("CIRNO REMOVED AN ICE_BLOCK,AND " + k + " BLOCK(S) ARE BROKEN");
        else process.stdout.write("CIRNO REMOVED AN ICE_BLOCK");
        blockcnt++;
    }
}//操作4

var hei = -1, _fixc = 0;//屋顶高度，以及填补的拐角空位数量

function get_wall_size(doorx, doory) {
    var ans = _fixc = 0;
    for(let i = 0; i < n; i++)
        for(let j = 0; j < n; j++) {
            if(inroom(i, j) || outroom(i, j)) continue;
            if(i == doorx && j == doory)
                for(let h = 2; h < hei; h++) ans += 1 - map[i][j][h];
            else if((i != sx && i != ex) || (j != sy && j != ey))
                for(let h = 0; h < hei; h++) ans += 1 - map[i][j][h];
            else if(Math.abs(i - doorx) + Math.abs(j - doory) == 1)
                ans += 2 - map[i][j][0] - map[i][j][1], _fixc += 2 - map[i][j][0] - map[i][j][1];
        }
    return ans;
}//当门在(doorx，doory)时，需要填补的空位数

function get_corner_size(cx, cy) {
    var ans = 0;
    for(let i = 0; i < hei; i++) ans += 1 - map[cx][cy][i], map[cx][cy][i] = 1;
    return ans;
}//填拐角

function fix_wall(doorx, doory) {
    for(let i = 0; i < n; i++)
        for(let j = 0; j < n; j++) {
            if(inroom(i, j) || outroom(i, j)) continue;
            if(i == doorx && j == doory)
                for(let h = 2; h < hei; h++) map[i][j][h] = 1;
            else if((i != sx && i != ex) || (j != sy && j != ey))
                for(let h = 0; h < hei; h++) map[i][j][h] = 1;
            else if(Math.abs(i - doorx) + Math.abs(j - doory) == 1)
                map[i][j][0] = map[i][j][1] = 1;
        }
}//填墙(其实就是get_wall_size改了一下)

function per(doorx, doory) {
    if(map[doorx][doory][0] || map[doorx][doory][1]) return 0;
    if((doorx == sx || doorx == ex) && Math.abs((sy + ey) / 2 - doory) < 0.9) return 1;
    if((doory == sy || doory == ey) && Math.abs((sx + ex) / 2 - doorx) < 0.9) return 1;
    return 0;
}//门的位置完美

function make_roof() {
    for(let i = 0; i < n; i++)
        for(let j = 0; j < n; j++) {
            if(inroom(i, j) || inroom(i, j)) continue;
            for(let h = hei + 1; h < hm; h++) if(map[i][j][h]) hei = h;
        }
    hei++;//算屋顶高度
    var cnt = 0;
    for(let i = sx; i <= ex; i++)
        for(let j = sy; j <= ey; j++) cnt += 1 - map[i][j][hei];
    if(cnt > blockcnt) {
        process.stdout.write("SORRY CIRNO,NOT ENOUGH ICE_BLOCK(S) TO MAKE ROOF");
        return;
    }
    blockcnt -= cnt;
    if(hei < 2 || (ex - sx - 1) * (ey - sy - 1) <= 1) {//空间过小
        process.stdout.write("SORRY CIRNO,HOUSE IS TOO SMALL");
        return;
    }
    for(let i = sx; i <= ex; i++)
        for(let j = sy; j <= ey; j++) map[i][j][hei] = 1;//造房顶
    var k1 = 0, k2 = 0;
    for(let i = 0; i < n; i++)
        for(let j = 0; j < n; j++)
            for(let h = 0; h < hm; h++) {
                if(inroom(i, j) && h < hei) k1 += map[i][j][h], map[i][j][h] = 0;//在屋子里面
                else if(outroom(i, j) || h > hei) k2 += map[i][j][h], map[i][j][h] = 0;//外面
            }
    var k3 = updata();//"碎掉"的块数即为墙上拆掉的块数
    blockcnt += k1 + k2 + k3;
    process.stdout.write(k1 + " ICE_BLOCK(S) INSIDE THE HOUSE NEED TO BE REMOVED\n");
    process.stdout.write(k2 + " ICE_BLOCK(S) OUTSIDE THE HOUSE NEED TO BE REMOVED\n");
    if(map[sx][sy][hei] == 0) {
        process.stdout.write("SORRY CIRNO,HOUSE IS BROKEN WHEN REMOVING BLOCKS");
        return;
    }//塌了
    var doorx, doory, wallcnt = 100000000, doorneed, cornerneed, doorp = 0, _maxfix = 0;
    for(let i = 0; i < n; i++)
        for(let j = 0; j < n; j++) {
            if(inroom(i, j) || outroom(i, j)) continue;
            if((i == sx || i == ey) && (j == sy || j == ey)) continue;
			var newcost = get_wall_size(i, j);
			if(wallcnt == newcost) {
                if(_maxfix < _fixc) doorx = i, doory = j, wallcnt = newcost, _maxfix = _fixc, doorp = per(i, j);
                if(_maxfix == _fixc && per(i, j)) doorx = i, doory = j, wallcnt = newcost, _maxfix = _fixc, doorp = per(i, j);
            }
            if(wallcnt > newcost) doorx = i, doory = j, wallcnt = newcost, _maxfix = _fixc, doorp = per(i, j);//三关键字找最优解
        }
    if(wallcnt > blockcnt) {
        process.stdout.write("SORRY CIRNO,NOT ENOUGH ICE_BLOCKS TO FIX THE WALL");
        return;
    }
    blockcnt -= wallcnt;
    process.stdout.write("GOOD JOB CIRNO,SUCCESSFULLY BUILT THE HOUSE\n");
    if(map[doorx][doory][0] + map[doorx][doory][1] != 0) {
        process.stdout.write("HOUSE HAS NO DOOR\n");
        doorneed = 1;
        blockcnt += map[doorx][doory][0] + map[doorx][doory][1];
        map[doorx][doory][0] = map[doorx][doory][1] = 0;
    }
    else process.stdout.write("DOOR IS OK\n");
    if(wallcnt > 0) process.stdout.write("WALL NEED TO BE FIXED\n");
    else process.stdout.write("WALL IS OK\n");
    fix_wall(doorx, doory);
    cornerneed = get_corner_size(sx, sy) + get_corner_size(ex, sy) + get_corner_size(sx, ey) + get_corner_size(ex, ey);
    blockcnt -= cornerneed;
    if(blockcnt < 0) blockcnt = 0;
    if(cornerneed > 0) process.stdout.write("CORNER NEED TO BE FIXED\n");
    else process.stdout.write("CORNER IS OK\n");
    process.stdout.write("CIRNO FINALLY HAS " + blockcnt + " ICE_BLOCK(S)");
    if(cornerneed || doorneed || wallcnt || k1 || k2) return;
    if(doorp) process.stdout.write("\nCIRNO IS PERFECT!");
}

function main() {
    updata = (function() {
        var fx = [0, 0, 0, 0, 1, -1], fy = [0, 0, 1, -1, 0, 0], fz = [1, -1, 0, 0, 0, 0];
        var vis = [];
        for(let i = 0; i < n; i++) {
            vis.push([]);
            for(let j = 0; j < n; j++) {
                vis[i].push([]);
                for(let k = 0; k <= hm; k++) vis[i][j].push(0);
            }
        }
        return function() {
            var qx = [], qy = [], qz = [], head = 0, tail = -1;
            for(let i = 0; i < n; i++)
                for(let j = 0; j < n; j++) {
                    for(let k = 0; k <= hm; k++) vis[i][j][k] = 0;
                    if(map[i][j][0] == 1) {
                        vis[i][j][0] = 1;
                        qx.push(i), qy.push(j), qz.push(0);
                        tail++;
                    }
                }
            var ans = 0;
            while(head <= tail) {
                for(let i = 0, nx, ny, nz; i < 6; i++) {
                    nx = qx[head] + fx[i], ny = qy[head] + fy[i], nz = qz[head] + fz[i];
                    if(inmap(nx, ny, nz) && map[nx][ny][nz] == 1 && vis[nx][ny][nz] == 0) {
                        vis[nx][ny][nz] = 1;
                        tail++;
                        qx.push(nx), qy.push(ny), qz.push(nz);
                    }
                }
                head++;
            }
            for(let i = 0; i < n; i++)
                for(let j = 0; j < n; j++)
                    for(let k = 0; k <= hm; k++)
                        if(map[i][j][k] == 1 && vis[i][j][k] == 0) ans++, map[i][j][k] = 0;
            return ans;
        };
    })();
    for(let i = 0; i < n; i++) {
        map.push([]);
        ice.push([]);
        for(let j = 0; j < n; j++) {
            ice[i].push(0);
            map[i].push([]);
            for(let k = 0; k <= hm; k++) map[i][j].push(0);
        }
    }
    for(let i = 0; i < m; i++) {
        let list = optlist[i].trim().split(' ');
        if(list[0] == "ICE_BARRAGE") ice_barrage(list[1], list[2], list[3], list[4]);
        else if(list[0] == "MAKE_ICE_BLOCK") make_ice_block();
        else if(list[0] == "PUT_ICE_BLOCK") put_ice_block(list[1], list[2], list[3]);
        else if(list[0] == "REMOVE_ICE_BLOCK") remove_ice_block(list[1], list[2], list[3]);
        else if(list[0] == "MAKE_ROOF") make_roof();
		if(i != m - 1) process.stdout.write("\n");
    }
    IO.close();
}

IO.on("line", function (line) {
    nowline++;
    if(nowline == 1) n = Number(line.trim());
    if(nowline == 2) hm = Number(line.trim());
    if(nowline == 3) {
        let list = line.trim().split(' ').map(a => Number(a));
        sx = list[0], sy = list[1];
        ex = list[0] + list[2] - 1, ey = list[1] + list[3] - 1;
    }
    if(nowline == 4) m = Number(line);
    if(nowline > 4) {
        optlist.push(line);
        if(nowline == m + 4) main();
    }
});//读入(我习惯用readline)
```
刚学js，大佬轻喷

---

## 作者：wuzhaoxin (赞：7)

## 养生好题

先丢几个注意事项：

- 输出文本不要打错
- 第7个点的最后面不要输换行否则`too long on line 1001`（？？？）
- 操作字符串的长度最大为16，开小了不会`RE`会`OLE`或者`TLE`（？？？）
- 前四个操作最好写成小函数并一次写对
- 由于数据只有二十组并不能保证AC代码无BUG（数据较水要有信仰）
- 放门的地方如果有冰块需要移除并回收
- 如果修补柱子需要的冰块不够，琪露诺最终有0个冰块
- 最后移除冰块的时候只需要看屋顶会不会塌陷，别的都不用管因为题面没说

现在开始正文部分

首先看前四个操作，这不是PJ第三题水平吗，一百多行搞定（注意第一个操作如果是最后一个操作不要输换行）

> 你：~~这到题真简单这么快就做完`80%`了~~
>
> 出题人：没错

然后你跳进了一个天坑

300行=100行前四个操作+200行第五个操作

首先判高度、造屋顶、移冰块，这些直接做就可以了

然后开门，题面上说尽量用缺口造门并需要使得填补使用的冰砖尽量少，意味着把这个位置高度小于2的冰块数（0,1,2）从小到大作为第一关键字，把将门开到这个位置修补墙壁需要的冰块数从小到大作为第二关键字选择位置（注意这里不需要管太多prefect，只要最后选出的位置并不是两个空缺就把prefect设为0即可）

第一关键字确定的情况下，填补需要的冰块数只和与门相邻的柱子的状态相关，我们先分别算出四个柱子高度在2以下位置缺少的冰块数，然后枚举位置，对于每个合法的位置我们通过一堆`if`算出相邻柱子缺少的冰块数

门确定好后直接把门和相邻柱子的对应部分设为冰块再计算修补墙和柱子的冰块就好了

最后在看一下是否有prefect

-----

经过删减最后的代码为273行8975字节（没加注释）

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[17][17][22];
int n, hm;
int lx, ly, mx, my;
bool cpos(int x, int y, int z) {
	return x >= 0 && y >= 0 && z >= 0 && x < n && y < n && z <= hm;
}
bool vis[17][17][22];
// bfs的6个方向
int dx[6] = {0, 0, 0, 0, -1, 1};
int dy[6] = {0, 0, -1, 1, 0, 0};
int dz[6] = {-1, 1, 0, 0, 0, 0};
int ice = 0;
int shot(int x, int y, int d, int s) { // 操作1
	static int dirx[8] = {-1, -1, 0, 1, 1, 1, 0, -1};
	static int diry[8] = {0, -1, -1, -1, 0, 1, 1, 1};
	if(a[x][y][0] == 5 || s == 0) return 0;
	int sz = a[x][y][0] < 4 ? 1 : 0;
	a[x][y][0] = min(4, a[x][y][0] + 1);
	if(! cpos(x + dirx[d], y + diry[d], 0)) return sz;
	return sz + shot(x + dirx[d], y + diry[d], d, s - 1);
}
int collect() { // 操作2
	int ans = 0;
	for(int i = 0; i < n; i ++)
		for(int j = 0; j < n; j ++)
			if(a[i][j][0] == 4) a[i][j][0] = 0, ans ++;
	return ans;
}
void put(int x, int y, int z) { // 操作3
	if(ice == 0) return void(puts("CIRNO HAS NO ICE_BLOCK"));
	if(a[x][y][z] == 5) return void(puts("BAKA CIRNO,CAN'T PUT HERE"));
	bool flag = z != 0;
	for(int i = 0; i < 6 && flag; i ++) {
		int tx = x + dx[i], ty = y + dy[i], tz = z + dz[i];
		if(cpos(tx, ty, tz) && a[tx][ty][tz] == 5) flag = 0;
	}
	if(flag) return void(puts("BAKA CIRNO,CAN'T PUT HERE"));
	a[x][y][z] = 5;
	ice --;
	if(x < lx || x > mx || y < ly || y > my) puts("CIRNO MISSED THE PLACE");
	else if(x > lx && x < mx && y > ly && y < my) puts("CIRNO PUT AN ICE_BLOCK INSIDE THE HOUSE");
	else printf("CIRNO SUCCESSFULLY PUT AN ICE_BLOCK,NOW SHE HAS %d ICE_BLOCK(S)\n", ice);
}
int fall(int x, int y, int z) { // 判断冰块掉落
	memset(vis, 0, sizeof(vis));
	queue<int> qx, qy, qz;
	queue<int> r;
	qx.push(x), qy.push(y), qz.push(z);
	int sz = 0;
	vis[x][y][z] = 1;
	while(! qx.empty()) {
		x = qx.front(), y = qy.front(), z = qz.front();
		qx.pop(), qy.pop(), qz.pop();
		r.push(x), r.push(y), r.push(z);
		sz ++;
		if(z == 0) return 0;
		for(int i = 0; i < 6; i ++) {
			int tx = x + dx[i], ty = y + dy[i], tz = z + dz[i];
			if(cpos(tx, ty, tz) && a[tx][ty][tz] == 5 && ! vis[tx][ty][tz])
				qx.push(tx), qy.push(ty), qz.push(tz), vis[tx][ty][tz] = 1;
		}
	}
	while(! r.empty()) {
		x = r.front(), r.pop();
		y = r.front(), r.pop();
		z = r.front(), r.pop();
		a[x][y][z] = 0;
	}
	return sz;
}
void get(int x, int y, int z) { // 操作4
	if(a[x][y][z] != 5) return void(puts("BAKA CIRNO,THERE IS NO ICE_BLOCK"));
	a[x][y][z] = 0;
	ice ++;
	int dropped = 0;
	for(int i = 0; i < 6; i ++) {
		int tx = x + dx[i], ty = y + dy[i], tz = z + dz[i];
		if(cpos(tx, ty, tz) && a[tx][ty][tz] == 5) dropped += fall(tx, ty, tz);
	}
	if(dropped == 0) puts("CIRNO REMOVED AN ICE_BLOCK");
	else printf("CIRNO REMOVED AN ICE_BLOCK,AND %d BLOCK(S) ARE BROKEN\n", dropped);
}
int main() {
	scanf("%d", &n);
	scanf("%d", &hm);
	scanf("%d%d%d%d", &lx, &ly, &mx, &my);
	mx += lx - 1, my += ly - 1;
	int m;
	scanf("%d", &m);
	char op[30];
	while(m --) {
		scanf(" %s", op);
		if(op[0] == 'I') {
			int x, y, d, s;
			scanf("%d%d%d%d", &x, &y, &d, &s);
            // 注意这里的换行符
			if(m) printf("CIRNO FREEZED %d BLOCK(S)\n", shot(x, y, d, s + 1));
			else printf("CIRNO FREEZED %d BLOCK(S)", shot(x, y, d, s + 1));
		}
		if(op[0] == 'M' && op[5] == 'I') {
			int ans = collect();
			ice += ans;
			printf("CIRNO MADE %d ICE BLOCK(S),NOW SHE HAS %d ICE BLOCK(S)\n", ans, ice);
		}
		if(op[0] == 'P') {
			int x, y, z;
			scanf("%d%d%d", &x, &y, &z);
			put(x, y, z);
		}
		if(op[0] == 'R') {
			int x, y, z;
			scanf("%d%d%d", &x, &y, &z);
			get(x, y, z);
		}
		if(op[0] == 'M' && op [5] == 'R') {
			int height = -1;
			bool prefect = 1;
            // 取最大高度
			for(int i = lx; i <= mx; i ++)
				for(int j = hm; j > height; j --)
					if(a[i][ly][j] == 5) { height = j; break;}
			for(int i = lx; i <= mx; i ++)
				for(int j = hm; j > height; j --)
					if(a[i][my][j] == 5) { height = j; break;}
			for(int i = ly; i <= my; i ++)
				for(int j = hm; j > height; j --)
					if(a[lx][i][j] == 5) { height = j; break;}
			for(int i = ly; i <= my; i ++)
				for(int j = hm; j > height; j --)
					if(a[mx][i][j] == 5) { height = j; break;}
			height ++;
			if(height < 2 || mx - lx - 1 < 1 || my - ly - 1 < 1) {
				puts("SORRY CIRNO,HOUSE IS TOO SMALL");
				break;
			}
            // 造屋顶
			for(int i = lx; i <= mx; i ++)
				for(int j = ly; j <= my; j ++)
					if(a[i][j][height] != 5) a[i][j][height] = 5, ice --;
			if(ice < 0) {
				puts("SORRY CIRNO,NOT ENOUGH ICE_BLOCK(S) TO MAKE ROOF");
				break;
			}
            // 删除内部冰块
			int rm = 0;
			for(int i = lx + 1; i < mx; i ++)
				for(int j = ly + 1; j < my; j ++)
					for(int k = 0; k < height; k ++)
						if(a[i][j][k] == 5) rm ++, a[i][j][k] = 0;
			printf("%d ICE_BLOCK(S) INSIDE THE HOUSE NEED TO BE REMOVED\n", rm);
			ice += rm;
			if(rm) prefect = 0;
            // 删除外部冰块
			rm = 0;
			for(int i = 0; i < n; i ++)
				for(int j = 0; j < n; j ++)
					for(int k = 0; k < hm; k ++)
						if(i < lx || i > mx || j < ly || j > my || k > height)
							if(a[i][j][k] == 5) rm ++, a[i][j][k] = 0;
			printf("%d ICE_BLOCK(S) OUTSIDE THE HOUSE NEED TO BE REMOVED\n", rm);
			ice += rm;
			if(rm) prefect = 0;
            // 屋顶掉落
			if(fall(lx, ly, height)) {
				puts("SORRY CIRNO,HOUSE IS BROKEN WHEN REMOVING BLOCKS");
				break;
			}
            // 选门的位置
			int wall = 1, conner = 1;
			int dx = -1, dy = -1;
			int cll, clm, cml, cmm;
			cll = (a[lx][ly][0] != 5) + (a[lx][ly][1] != 5);
			clm = (a[lx][my][0] != 5) + (a[lx][my][1] != 5);
			cml = (a[mx][ly][0] != 5) + (a[mx][ly][1] != 5);
			cmm = (a[mx][my][0] != 5) + (a[mx][my][1] != 5);
			int now = 4, rmi = 3;
			bool door = 1;
			for(int i = 0; i < n; i ++)
				for(int j = 0; j < n; j ++) {
                    // 位置是否正确
					if(i < lx || i > mx || j < ly || j > my) continue;
					if(i > lx && i < mx && j != ly && j != my) continue;
					if(j > ly && j < my && i != lx && i != mx) continue;
					int pr = (a[i][j][0] == 5) + (a[i][j][1] == 5); // 位置多余冰块
					int pt = 0; // 相邻角对应位置缺少的冰块
					if(i == lx && j == ly + 1) pt += cll;
					else if(i == lx + 1 && j == ly) pt += cll;
					if(i == lx && j == my - 1) pt += clm;
					else if(i == lx + 1 && j == my) pt += clm;
					if(i == mx && j == ly + 1) pt += cml;
					else if(i == mx - 1 && j == ly) pt += cml;
					if(i == mx && j == my - 1) pt += cmm;
					else if(i == mx - 1 && j == my) pt += cmm;
					if(pr < rmi) rmi = pr, now = pt, dx = i, dy = j;
					else if(pr == rmi && pt < now) now = pt, dx = i, dy = j;
				}
			if(now) ice -= now, wall = 0, prefect = 0; // 这里的柱子有缺口则墙需要补
			if(rmi) door = 0, ice += rmi, prefect = 0; // 有多余冰块要回收并输出 NO DOOR
            // 把这些位置都设为有冰块
			a[dx][dy][0] = 5, a[dx][dy][1] = 5;
			if(dx - lx == 1 && dy == ly) a[lx][ly][0] = a[lx][ly][1] = 5;
			if(dx - lx == 1 && dy == my) a[lx][my][0] = a[lx][my][1] = 5;
			if(my - dx == 1 && dy == ly) a[mx][ly][0] = a[mx][ly][1] = 5;
			if(my - dx == 1 && dy == my) a[mx][my][0] = a[mx][my][1] = 5;
			if(dy - ly == 1 && dx == lx) a[lx][ly][0] = a[lx][ly][1] = 5;
			if(dy - ly == 1 && dx == mx) a[mx][ly][0] = a[mx][ly][1] = 5;
			if(my - dy == 1 && dx == lx) a[lx][my][0] = a[lx][my][1] = 5;
			if(my - dy == 1 && dx == mx) a[mx][my][0] = a[mx][my][1] = 5;
            // 计算墙的空缺
			for(int i = lx + 1; i < mx; i ++)
				for(int j = 0; j < height; j ++) {
					if(a[i][ly][j] != 5) {
						ice --;
						a[i][ly][j] = 5;
						wall = 0;
					}
					if(a[i][my][j] != 5) {
						ice --;
						a[i][my][j] = 5;
						wall = 0;
					}
				}
			for(int i = ly + 1; i < my; i ++)
				for(int j = 0; j < height; j ++) {
					if(a[lx][i][j] != 5) {
						ice --;
						a[lx][i][j] = 5;
						wall = 0;
					}
					if(a[mx][i][j] != 5) {
						ice --;
						a[mx][i][j] = 5;
						wall = 0;
					}
				}
			if(ice < 0) {
				puts("SORRY CIRNO,NOT ENOUGH ICE_BLOCKS TO FIX THE WALL");
				break;
			}
			puts("GOOD JOB CIRNO,SUCCESSFULLY BUILT THE HOUSE");
			if(door) puts("DOOR IS OK");
			else puts("HOUSE HAS NO DOOR");
			if(wall) puts("WALL IS OK");
			else puts("WALL NEED TO BE FIXED");
            // 角落缺口
			for(int i = 0; i < height; i ++)
				if(a[lx][ly][i] != 5) {
					conner = 0;
					a[lx][ly][i] = 5;
					ice --;
				}
			for(int i = 0; i < height; i ++)
				if(a[mx][ly][i] != 5) {
					conner = 0;
					a[mx][ly][i] = 5;
					ice --;
				}
			for(int i = 0; i < height; i ++)
				if(a[lx][my][i] != 5) {
					conner = 0;
					a[lx][my][i] = 5;
					ice --;
				}
			for(int i = 0; i < height; i ++)
				if(a[mx][my][i] != 5) {
					conner = 0;
					a[mx][my][i] = 5;
					ice --;
				}
			if(conner) puts("CORNER IS OK");
			else puts("CORNER NEED TO BE FIXED");
			printf("CIRNO FINALLY HAS %d ICE_BLOCK(S)\n", max(0, ice)); // 剩余冰块对0取max
			if(wall && conner && door && prefect && (dx == (lx + mx) / 2 || dx == (lx + mx + 1) / 2 || dy == (ly + my) / 2 || dy == (ly + my + 1) / 2))
				puts("CIRNO IS PERFECT!");
		}
	}
	return 0;
}
```



---

## 作者：Erina (赞：6)

# 首先吐槽一句出题人真是毒瘤

然后开始讲一下怎么做这道题

最简单的两个操作:冰雪弹幕,放冰块.直接暴力模拟即可......

```cpp
int freeze(int x, int y, int dir, int pow)
{
	if (x < 0 || y < 0 || x >= n || y >= n)
		return 0;
	if (pow < 0)
		return 0;
	if (ice[x][y][0])
		return 0;
	if (frzz[x][y] == 4)
		return freeze(x + mx[dir], y + my[dir], dir, pow - 1);
	else
		return freeze(x + mx[dir], y + my[dir], dir, pow - 1) + (frzz[x][y]++, 1);
}
int make()
{
	int cnt = 0;
	for (int i = 0; i < n; i++)
		for (int u = 0; u < n; u++)
			cnt += (frzz[i][u] == 4), bls += (frzz[i][u] == 4), frzz[i][u] %= 4;
	return cnt;
}
```

之后是放冰块,**注意冰块可以清零下面的地面**(被坑了).

```cpp
void put(int x, int y, int z)
{
	bool suc = 1;
	if (!bls)
	{
		cout << "CIRNO HAS NO ICE_BLOCK\n";
		return;
	}
	if (ice[x][y][z] || (z && !ice[x - 1][y][z] && !ice[x][y - 1][z] && !ice[x][y][z - 1] && !ice[x + 1][y][z] && !ice[x][y + 1][z] && !ice[x][y][z + 1]))
	{
		cout << "BAKA CIRNO,CAN'T PUT HERE\n";
		return;
	}
	if (x > ex || x < sx || y > ey || y < sy)
		cout << "CIRNO MISSED THE PLACE\n", suc = 0;
	else if (sx < x && x < ex && sx < y && y < ey)
		cout << "CIRNO PUT AN ICE_BLOCK INSIDE THE HOUSE\n", suc = 0;
	ice[x][y][z] = 1;
	bls--;
	if (!z)
		frzz[x][y] = 0;
	if (suc)
		cout << "CIRNO SUCCESSFULLY PUT AN ICE_BLOCK,NOW SHE HAS " << bls << " ICE_BLOCK(S)\n";
}
```

之后是移除操作,dfs出六个方向的联通快(掉下来指联通块没有碰到地面).

```cpp
bool dfs(int x, int y, int z)
{
	if (x < 0 || y < 0 || z < 0 || x >= n || y >= n || z >= hm)
		return false;
	if (!ice[x][y][z])
		return false;
	if (mark[x][y][z])
		return false;
	mark[x][y][z] = 1;
	bool ret = (z == 0);
	for (int i = 0; i < 6 && (!ret); i++)
		ret |= dfs(x + xm[i], y + ym[i], z + zm[i]);
	return ret;
}
int remc(int x, int y, int z)
{
	if (x < 0 || y < 0 || z < 0 || x >= n || y >= n || z >= hm)
		return false;
	if (!ice[x][y][z])
		return false;
	int siz = 1;
	ice[x][y][z] = 0;
	for (int i = 0; i < 6; i++)
		siz += remc(x + xm[i], y + ym[i], z + zm[i]);
	ice[x][y][z] = false;
	return siz;
}
int remove(int x, int y, int z, bool cnt)
{
	if (!ice[x][y][z])
	{
		cout << "BAKA CIRNO,THERE IS NO ICE_BLOCK\n";
		return 0;
	}
	ice[x][y][z] = 0;
	if (cnt)
		bls++;
	int broken = 0;
	for (int i = 0; i < 6; i++)
	{
		memset(mark, 0, sizeof(mark));
		if (!dfs(x + xm[i], y + ym[i], z + zm[i]))
			broken += remc(x + xm[i], y + ym[i], z + zm[i]);
	}
	if (broken && cnt)
		cout << "CIRNO REMOVED AN ICE_BLOCK,AND " << broken << " BLOCK(S) ARE BROKEN\n";
	else if (cnt)
		cout << "CIRNO REMOVED AN ICE_BLOCK\n";
	return broken + 1;
}
```
之后才是重点.

**make_roof操作该怎么做?**

make_roof前几个操作比较简单,求出高度以及铺屋顶,删多余的部分也不难.

修补墙的代码就非常窒息了.

第一遍看:ah_huh?这是干什么门在哪里

第二遍看:门在哪里门在哪里门在哪里?

注意题目所说的:尽可能少修补那么我们应该尽可能找到可以少修补的门的位置,为了perfect在少的条件下尽可能在中间.

于是我们为每一个门的位置规定一个优先级,按照需要的值为第一关键字,是否为中间为第二关键字,角处填补为第三关键字找到最大值.然后确定门的位置.

```cpp
int cntds(int x, int y) { return 2 - ice[x][y][0] - ice[x][y][1]; }
bool mid(int x, int y)
{
	if (x == (sx + ex) >> 1 || x == (sx + ex + 1) >> 1)
		return 1;
	if (y == (sy + ey) >> 1 || y == (sy + ey + 1) >> 1)
		return 1;
	return 0;
}
int iscorn(int x, int y)
{
	int ret = 0;
	bool flag = false;
	if (x - 1 == sx)
		ret += 2 - cntds(sx, y), flag = true;
	if (x + 1 == ex)
		ret += 2 - cntds(ex, y), flag = true;
	if (y - 1 == sy)
		ret += 2 - cntds(x, sy), flag = true;
	if (y + 1 == ey)
		ret += 2 - cntds(x, ey), flag = true;
	if (!flag)
		return 4;
	return ret;
}//找到角
int getid(int x, int y) { return cntds(x, y) << 4 | mid(x, y) << 3 | iscorn(x, y); }
int dx, dy, v;
void upd(int x, int y)
{
	int nv = getid(x, y);
	// cout << x << ' ' << y << ' ' << cntds(x, y) << ' ' << mid(x, y) << ' ' << iscorn(x, y) << ' ' << nv << endl;
	if (nv > v)
		v = nv, dx = x, dy = y;
}
#define isdoor(i, u, j) (i == dx && u == dy && j < 2)
int i_wanna_fix_the_wall()
{
	int need = 0;
	for (int i = sx + 1; i < ex; i++)
		upd(i, sy), upd(i, ey);
	for (int i = sy + 1; i < ey; i++)
		upd(sx, i), upd(ex, i);//找到最大值
	for (int i = sx + 1; i < ex; i++)
		for (int u = 0; u < maxh; u++)
		{
			if (!isdoor(i, sy, u))
				need += !ice[i][sy][u], ice[i][sy][u] = 1;
			if (!isdoor(i, ey, u))
				need += !ice[i][ey][u], ice[i][ey][u] = 1;
		}
	for (int i = sy + 1; i < ey; i++)
		for (int u = 0; u < maxh; u++)
		{
			if (!isdoor(sx, i, u))
				need += !ice[sx][i][u], ice[sx][i][u] = 1;
			if (!isdoor(ex, i, u))
				need += !ice[ex][i][u], ice[ex][i][u] = 1;
		}
	if (dx - 1 == sx)
		need += cntds(sx, dy), ice[sx][dy][0] = ice[sx][dy][1] = 1;
	if (dx + 1 == ex)
		need += cntds(ex, dy), ice[ex][dy][0] = ice[ex][dy][1] = 1;
	if (dy - 1 == sy)
		need += cntds(dx, sy), ice[dx][sy][0] = ice[dx][sy][1] = 1;
	if (dy + 1 == ey)
		need += cntds(dx, ey), ice[dx][ey][0] = ice[dx][ey][1] = 1;//修补角
	return need;
}
```
这样就好办了~~,就不用那200行代码了~~

下面是完整代码.
```cpp
#include <cstring>
#include <iostream>
#include <utility>
#if __cplusplus < 201103L
#error your compiler smells like shit!
#endif
using namespace std;
int n, hm;
int sx, sy, ex, ey;
int m;
string op;
int frzz[20][20];//冰冻值
bool ice[20][20][25], mark[20][20][25];//有没有冰,dfs标记
int bls;//有的冰块数
int mx[8] = {-1, -1, 0, 1, 1, 1, 0, -1},
	my[8] = {0, -1, -1, -1, 0, 1, 1, 1};//8方向
int xm[6] = {1, -1, 0, 0, 0, 0},
	ym[6] = {0, 0, 1, -1, 0, 0},
	zm[6] = {0, 0, 0, 0, 1, -1};//6方向
int freeze(int x, int y, int dir, int pow)
{
	if (x < 0 || y < 0 || x >= n || y >= n)
		return 0;
	if (pow < 0)
		return 0;
	if (ice[x][y][0])
		return 0;
	if (frzz[x][y] == 4)
		return freeze(x + mx[dir], y + my[dir], dir, pow - 1);
	else
		return freeze(x + mx[dir], y + my[dir], dir, pow - 1) + (frzz[x][y]++, 1);
}
int make()
{
	int cnt = 0;
	for (int i = 0; i < n; i++)
		for (int u = 0; u < n; u++)
			cnt += (frzz[i][u] == 4), bls += (frzz[i][u] == 4), frzz[i][u] %= 4;
	return cnt;
}
typedef pair<int, int> mp;
void put(int x, int y, int z)
{
	bool suc = 1;
	if (!bls)
	{
		cout << "CIRNO HAS NO ICE_BLOCK\n";
		return;
	}
	if (ice[x][y][z] || (z && !ice[x - 1][y][z] && !ice[x][y - 1][z] && !ice[x][y][z - 1] && !ice[x + 1][y][z] && !ice[x][y + 1][z] && !ice[x][y][z + 1]))
	{
		cout << "BAKA CIRNO,CAN'T PUT HERE\n";
		return;
	}
	if (x > ex || x < sx || y > ey || y < sy)
		cout << "CIRNO MISSED THE PLACE\n", suc = 0;
	else if (sx < x && x < ex && sx < y && y < ey)
		cout << "CIRNO PUT AN ICE_BLOCK INSIDE THE HOUSE\n", suc = 0;
	ice[x][y][z] = 1;
	bls--;
	if (!z)
		frzz[x][y] = 0;
	if (suc)
		cout << "CIRNO SUCCESSFULLY PUT AN ICE_BLOCK,NOW SHE HAS " << bls << " ICE_BLOCK(S)\n";
}
bool dfs(int x, int y, int z)
{
	if (x < 0 || y < 0 || z < 0 || x >= n || y >= n || z >= hm)
		return false;
	if (!ice[x][y][z])
		return false;
	if (mark[x][y][z])
		return false;
	mark[x][y][z] = 1;
	bool ret = (z == 0);
	for (int i = 0; i < 6 && (!ret); i++)
		ret |= dfs(x + xm[i], y + ym[i], z + zm[i]);
	return ret;
}
int remc(int x, int y, int z)
{
	if (x < 0 || y < 0 || z < 0 || x >= n || y >= n || z >= hm)
		return false;
	if (!ice[x][y][z])
		return false;
	int siz = 1;
	ice[x][y][z] = 0;//删除掉落方块
	for (int i = 0; i < 6; i++)
		siz += remc(x + xm[i], y + ym[i], z + zm[i]);
	ice[x][y][z] = false;
	return siz;
}
int remove(int x, int y, int z, bool cnt)
{
	if (!ice[x][y][z])
	{
		cout << "BAKA CIRNO,THERE IS NO ICE_BLOCK\n";
		return 0;
	}
	ice[x][y][z] = 0;
	if (cnt)
		bls++;
	int broken = 0;
	for (int i = 0; i < 6; i++)
	{
		memset(mark, 0, sizeof(mark));
		if (!dfs(x + xm[i], y + ym[i], z + zm[i]))
			broken += remc(x + xm[i], y + ym[i], z + zm[i]);//删掉落方块
	}
	if (broken && cnt)
		cout << "CIRNO REMOVED AN ICE_BLOCK,AND " << broken << " BLOCK(S) ARE BROKEN\n";
	else if (cnt)
		cout << "CIRNO REMOVED AN ICE_BLOCK\n";
	return broken + 1;
}
int roofheight()
{
	int h = 0;
	for (int i = sx; i <= ex; i++)
		for (int u = hm; u > h; u--)
			if (ice[i][sy][u] || ice[i][ey][u])
				h = u;
	for (int i = sy; i <= ey; i++)
		for (int u = hm; u > h; u--)
			if (ice[sx][i][u] || ice[ex][i][u])
				h = u;
	return h + 1;
}
int maxh;
int in(int x, int y, int z) { return (sx < x && x < ex && sy < y && y < ey && z < maxh); }
int out(int x, int y, int z) { return x < sx || x > ex || y < sy || y > ey || z > maxh; }
mp ioblock()
{
	mp ret = {0, 0};
	for (int i = 0; i < n; i++)
		for (int u = 0; u < n; u++)
			for (int j = 0; j < hm; j++)
				if (ice[i][u][j])
					ret.first += out(i, u, j), ret.second += in(i, u, j);
	return ret;
}
int cntds(int x, int y) { return 2 - ice[x][y][0] - ice[x][y][1]; }
bool mid(int x, int y)
{
	if (x == (sx + ex) >> 1 || x == (sx + ex + 1) >> 1)
		return 1;
	if (y == (sy + ey) >> 1 || y == (sy + ey + 1) >> 1)
		return 1;
	return 0;
}
int iscorn(int x, int y)
{
	int ret = 0;
	bool flag = false;
	if (x - 1 == sx)
		ret += 2 - cntds(sx, y), flag = true;
	if (x + 1 == ex)
		ret += 2 - cntds(ex, y), flag = true;
	if (y - 1 == sy)
		ret += 2 - cntds(x, sy), flag = true;
	if (y + 1 == ey)
		ret += 2 - cntds(x, ey), flag = true;
	if (!flag)
		return 4;
	return ret;
}
int getid(int x, int y) { return cntds(x, y) << 4 | mid(x, y) << 3 | iscorn(x, y); }
int dx, dy, v;
void upd(int x, int y)
{
	int nv = getid(x, y);
	// cout << x << ' ' << y << ' ' << cntds(x, y) << ' ' << mid(x, y) << ' ' << iscorn(x, y) << ' ' << nv << endl;
	if (nv > v)
		v = nv, dx = x, dy = y;
}
#define isdoor(i, u, j) (i == dx && u == dy && j < 2)
int i_wanna_fix_the_wall()
{
	int need = 0;
	for (int i = sx + 1; i < ex; i++)
		upd(i, sy), upd(i, ey);
	for (int i = sy + 1; i < ey; i++)
		upd(sx, i), upd(ex, i);
	for (int i = sx + 1; i < ex; i++)
		for (int u = 0; u < maxh; u++)
		{
			if (!isdoor(i, sy, u))
				need += !ice[i][sy][u], ice[i][sy][u] = 1;
			if (!isdoor(i, ey, u))
				need += !ice[i][ey][u], ice[i][ey][u] = 1;
		}
	for (int i = sy + 1; i < ey; i++)
		for (int u = 0; u < maxh; u++)
		{
			if (!isdoor(sx, i, u))
				need += !ice[sx][i][u], ice[sx][i][u] = 1;
			if (!isdoor(ex, i, u))
				need += !ice[ex][i][u], ice[ex][i][u] = 1;
		}
	if (dx - 1 == sx)
		need += cntds(sx, dy), ice[sx][dy][0] = ice[sx][dy][1] = 1;
	if (dx + 1 == ex)
		need += cntds(ex, dy), ice[ex][dy][0] = ice[ex][dy][1] = 1;
	if (dy - 1 == sy)
		need += cntds(dx, sy), ice[dx][sy][0] = ice[dx][sy][1] = 1;
	if (dy + 1 == ey)
		need += cntds(dx, ey), ice[dx][ey][0] = ice[dx][ey][1] = 1;
	return need;
}
void roof()
{
	int needb = 0;
	maxh = roofheight();
	for (int i = sx; i <= ex; i++)
		for (int u = sy; u <= ey; u++)
			needb += !ice[i][u][maxh];
	if (needb > bls)
		cout << "SORRY CIRNO,NOT ENOUGH ICE_BLOCK(S) TO MAKE ROOF", exit(0);
	if (maxh < 2 || (ex - sx - 1) * (ey - sy - 1) < 2)
		cout << "SORRY CIRNO,HOUSE IS TOO SMALL", exit(0);
	for (int i = sx; i <= ex; i++)
		for (int u = sy; u <= ey; u++)
			ice[i][u][maxh] = 1;
	bls -= needb;
	mp ans = ioblock();
	cout << ans.second << " ICE_BLOCK(S) INSIDE THE HOUSE NEED TO BE REMOVED\n";
	cout << ans.first << " ICE_BLOCK(S) OUTSIDE THE HOUSE NEED TO BE REMOVED\n";
	for (int i = 0; i < n; i++)
		for (int u = 0; u < n; u++)
			for (int j = 0; j < hm; j++)
			{
				if (!ice[i][u][j])
					continue;
				if (in(i, u, j) || out(i, u, j))
					bls += remove(i, u, j, 0);
			}
	for (int i = sx; i <= ex; i++)
		for (int u = sy; u <= ey; u++)
			if (!ice[i][u][maxh])
				cout << "SORRY CIRNO,HOUSE IS BROKEN WHEN REMOVING BLOCKS", exit(0);
	int need = i_wanna_fix_the_wall();
	if (bls < need)
		cout << "SORRY CIRNO,NOT ENOUGH ICE_BLOCKS TO FIX THE WALL", exit(0);
	bls -= need;
	cout << "GOOD JOB CIRNO,SUCCESSFULLY BUILT THE HOUSE\n";
	if ((v >> 4) == 2)
		cout << "DOOR IS OK\n";
	else
		cout << "HOUSE HAS NO DOOR\n", bls += ice[dx][dy][0] + ice[dx][dy][1], ice[dx][dy][0] = ice[dx][dy][1] = 0;
	if (!need)
		cout << "WALL IS OK\n";
	else
		cout << "WALL NEED TO BE FIXED\n";
	int cfx = 0;
	for (int i = 0; i < maxh; i++)
		cfx += !ice[sx][sy][i], cfx += !ice[sx][ey][i], cfx += !ice[ex][sy][i], cfx += !ice[ex][ey][i], ice[sx][sy][i] = ice[sx][ey][i] = ice[ex][sy][i] = ice[ex][ey][i] = 1;
	bls = max(0, bls - cfx);
	if (!cfx)
		cout << "CORNER IS OK\n";
	else
		cout << "CORNER NEED TO BE FIXED\n";
	cout << "CIRNO FINALLY HAS " << bls << " ICE_BLOCK(S)\n";
	if (ans == mp(0, 0) && !need && !cfx && (v & 1 << 3) && (v >> 4 == 2))
		cout << "CIRNO IS PERFECT!\n";
}
int main()
{
	cin >> n >> hm >> sx >> sy >> ex >> ey;
	ex += sx - 1, ey += sy - 1;
	cin >> m;
	for (int i = 0; i < m; i++)
	{
		cin >> op;
		if (op == "ICE_BARRAGE")
		{
			int x, y, d, z;
			cin >> x >> y >> d >> z;
			if (i != m - 1)
				cout << "CIRNO FREEZED " << freeze(x, y, d, z) << " BLOCK(S)\n";
			else
				cout << "CIRNO FREEZED " << freeze(x, y, d, z) << " BLOCK(S)";
		}
		else if (op == "MAKE_ICE_BLOCK")
			cout << "CIRNO MADE " << make() << " ICE BLOCK(S),NOW SHE HAS " << bls << " ICE BLOCK(S)\n";
		else if (op == "PUT_ICE_BLOCK")
		{
			int x, y, z;
			cin >> x >> y >> z;
			put(x, y, z);
		}
		else if (op == "REMOVE_ICE_BLOCK")
		{
			int x, y, z;
			cin >> x >> y >> z;
			remove(x, y, z, 1);
		}
		else if (op == "MAKE_ROOF")
			roof();
	}
}
```

---

## 作者：江户川·萝卜 (赞：3)

这道题，写得我快吐血了。

细节巨多。

我们来一块一块分析。

## 1.约定


代码中会出现以下内容：

`N,Hm,Hr,Hc,Hx,Hy,M,r,c,h` 都分别代表题面中的同名变量。`Hf` 记录屋顶高度。

`Put[i][j][k]` 标志 $(i,j,k)$ 这个位置是否放置冰砖。

`Freeze[i][j]` 记录地面这个平面上 $(i,j)$ 的冰冻度。

`Zcnt` 为当前冰砖数，`Ncnt` 是当前操作所需的冰砖数，`out` `out1` 等是将要输出的东西。

函数分别代表题面中同名操作。

`CanPut` 函数见 “前三个操作”的代码。

对于 `R,C,H` 的顺序，都是按照 `R,C,H` 排的。

---
## 2. 前三个操作

正如题解区的各位所说，前三个操作仅仅只需按照题面安排的逻辑顺序进行编写，不进行重点讲，仅给出代码。

```cpp
inline bool CanPut(int r,int c,int h){
	int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};
	if(!h||Put[r][c][h-1]) return 1;
	for(int i=0;i<4;i++)
		if(r+dx[i]>=0&&r+dx[i]<=N&&c+dy[i]>=0&&c+dy[i]<=N&&Put[r+dx[i]][c+dy[i]][h]) return 1;
	return 0;
}
inline void IceBarrage(){
	int r=read(),c=read(),d=read(),s=read();
	int dx[8]={-1,-1,0,1,1,1,0,-1},dy[8]={0,-1,-1,-1,0,1,1,1};
	int out=0;
	for(int i=0;i<=s;i++){
		if(Put[r][c][0]||r>N||c>N||r<0||c<0) break;
		if(Freeze[r][c]<4) Freeze[r][c]++,out++;
		r+=dx[d],c+=dy[d];
	}
	printf("CIRNO FREEZED %d BLOCK(S)\n",out);
}
inline void MakeIceBlock(){
	int out=0;
	for(int i=0;i<=N;i++)
	for(int j=0;j<=N;j++)
		if(!Put[i][j][0]&&Freeze[i][j]==4) Freeze[i][j]=0,out++;
	Zcnt+=out;
	printf("CIRNO MADE %d ICE BLOCK(S),NOW SHE HAS %d ICE BLOCK(S)\n",out,Zcnt);
} 
inline void PutIceBlock(){
	int r=read(),c=read(),h=read();
	if(!Zcnt) puts("CIRNO HAS NO ICE_BLOCK");
	else if(!CanPut(r,c,h)||Put[r][c][h]) puts("BAKA CIRNO,CAN'T PUT HERE");
	else{
		if(!h) Freeze[r][c]=0;
		Put[r][c][h]=1;Zcnt--;
		if(r<Hr||r>Hr+Hx-1||c<Hc||c>Hc+Hy-1) puts("CIRNO MISSED THE PLACE");
		else if(Hr<r&&r<Hr+Hx-1&&Hc<c&&c<Hc+Hy-1) puts("CIRNO PUT AN ICE_BLOCK INSIDE THE HOUSE");
		else printf("CIRNO SUCCESSFULLY PUT AN ICE_BLOCK,NOW SHE HAS %d ICE_BLOCK(S)\n",Zcnt);
	}
}
```
---
## 3. $\textbf{Remove Ice Block}$ 操作

如果 $(r,c,h)$ 这个点没有冰砖，输出 `BAKA CIRNO,THERE IS NO ICE_BLOCK`。

否则，删除掉这个冰砖，然后依次往六个方向进行 `bfs`，如果某个方向上的 `bfs` 不到地面的话，所有被搜索到的冰砖全部都 `BROKEN`。

注意：时时刻刻都需要判断是否越界！

```cpp
inline int bfs(int r,int c,int h){
	if(r<0||c<0||h<0||r>N||c>N||h>Hm||!Put[r][c][h]) return 0; //判越界1
	queue<triple>q;
	int dr[6]={1,0,0,-1,0,0},dc[6]={0,1,0,0,-1,0},dh[6]={0,0,1,0,0,-1};
	while(!q.empty()) q.pop();
	q.push(triple(r,c,h));
	bool f=0;
	memset(vis,0,sizeof vis);vis[r][c][h]=1;
	while(!q.empty()&&!f){
		int R=q.front().r,C=q.front().c,H=q.front().h;q.pop();
		if(H==0) {f=1;break;}
		for(int i=0;i<6;i++){
			int tr=R+dr[i],tc=C+dc[i],th=H+dh[i];
			if(tr<0||tc<0||th<0||tr>N||tc>N|th>Hm) continue;//判越界2
			if(Put[tr][tc][th]&&!vis[tr][tc][th]) vis[tr][tc][th]=1,q.push(triple(tr,tc,th));
		}
	}
	if(!f){
		int cnt=1;
		while(!q.empty()) q.pop();
		q.push(triple(r,c,h));Put[r][c][h]=0;
		while(!q.empty()){
			int R=q.front().r,C=q.front().c,H=q.front().h;q.pop();
			for(int i=0;i<6;i++){
				int tr=R+dr[i],tc=C+dc[i],th=H+dh[i];
				if(tr<0||tc<0||th<0||tr>N||tc>N|th>Hm) continue;//判越界3
				if(Put[tr][tc][th]) Put[tr][tc][th]=0,q.push(triple(tr,tc,th)),cnt++;
			}
		}
		return cnt;
	}
	return 0;
}
inline void RemoveIceBlock(){
	int r=read(),c=read(),h=read(),out=0;
	if(!Put[r][c][h]) puts("BAKA CIRNO,THERE IS NO ICE_BLOCK");
	else{
		printf("CIRNO REMOVED AN ICE_BLOCK");Zcnt++;Put[r][c][h]=0;
		int dr[6]={1,0,0,-1,0,0},dc[6]={0,1,0,0,-1,0},dh[6]={0,0,1,0,0,-1};
		for(int i=0;i<6;i++) out+=bfs(r+dr[i],c+dc[i],h+dh[i]);
		if(!out) puts("");
		else printf(",AND %d BLOCK(S) ARE BROKEN\n",out); 
	}
}
```
（我这里 `BROKEN` 的操作是再次进行 `bfs`，实际上可以把所有 `vis` 到的位置都删除即可。）

# 4. $\color{red}\textbf{Make Roof}$ 操作
毒瘤，即将到来。

首先直接从高到低枚举，求出屋顶的高度。

然后把屋顶做好，判断两个特殊情况。

然后，码代码前先读题面是个好习惯，这样你就会发现这样一个东西：

>最后，如果在之前的记录中，墙壁完整无缺，没有一个位置需要填补。房子内外都无任何多余的方块，没有一个位置需要移除。没有出现房子没门的情况，房子四角的柱子也在造屋顶前完全造好，而不是通过修补完善的。并且门恰好开在了某面墙的正中央（如果长度为偶数，中间的两个都算），输出一行：
`CIRNO IS PERFECT!`

所以说，最后还需要判个完美。

但其实这东西可以提到前面来先写。

我们可以先写三个判断是否在房内、房外、房上（就是屋顶或墙）的函数，分别称作 `InsideRoom,OutsideRoom,TheRoom`。

然后对于每一个块 $(i,j,k)$ 分两种情况：


- 放了冰砖。如果 `TheRoom(i,j,k)==false`，则就是不完美的。
- 未放冰砖。如果 `TheRoom(i,j,k)==true`：
	- 高度 $=0$ 且位于墙的中间，则这个必须当做门；如果门已经有了，那么一定是不完美的。
    - 高度 $=1$ 且不位于候选门上方，那么也是不完美的。
    - 否则，也一定是不完美的。

如果这么下来，是完美的，那就直接把所有应该输出的东西输出即可（详情看代码）。

---
这样，下面我们就无需判断是否是完美的，节省了许多判断，比如无需判断门是否要在墙中间，无需记录墙是否没修等等。

移除所有多余冰砖这块内容其实不需要考虑是否会摔碎冰砖，因为我们可以按照从地面开始的 `bfs` 的顺序倒序删除，不会有任何摔碎的情况，所以直接删除多余的冰砖即可。

然后，再从接触地面的墙壁块往上 `bfs`，只要没搜索到的地方都是需要删除的。

特殊情况记得判断。

接着，到了最恶心的环节——**选门**

- 如果有现成的门且不在柱子旁，那么直接选。
- 如果有现成的门但是在柱子旁，如果柱子不需要修补，那么也直接选。
- 如果有一个空格且不在柱子旁，那么作为候选门。
- 如果没有任何一个空位，那么随机选取一个（尽量不在柱子旁）的位置作为候选门。
- 然后，就剩下了，在柱子旁的，有空位的位置了。依次枚举，计算需要填补的格子数，取一个最小值作为候选门；若是候选门是完整的门，那么在之后也是要输出 `DOOR IS OK` 的。

这个枚举巨恶心，我调了巨久。

选完门继续填补。注意，如果门选在柱子旁，那么这段柱子不应算作 `CORNER` 而应算作 `WALL`。

后面几个评价，判断后输出即可。

注意如果修拐角时冰砖不够时，冰砖需清零。
```cpp
inline bool InsideRoom(int r,int c,int h){return r>Hr&&r<Hr+Hx-1&&c>Hc&&c<Hc+Hy-1&&h<Hf;}
inline bool OutsideRoom(int r,int c,int h){return r<Hr||r>Hr+Hx-1||c<Hc||c>Hc+Hy-1||h>Hf;}
inline bool TheRoom(int r,int c,int h){return (!InsideRoom(r,c,h))&&(!OutsideRoom(r,c,h));}
inline void MakeRoof(){
	bool Perfect=1;int Dx=-1,Dy=-1;
	for(Hf=Hm+1;Hf;Hf--){
		bool fl=0;
		for(int i=0;i<Hx;i++)
			if(Put[i+Hr][Hc][Hf]||Put[i+Hr][Hc+Hy-1][Hf]) fl=1;
		for(int i=0;i<Hy;i++)
			if(Put[Hr][i+Hc][Hf]||Put[Hr+Hx-1][i+Hc][Hf]) fl=1;
		if(fl) break; 
	}
	int Ncnt=0;Hf++;
	for(int i=0;i<Hx;i++)
	for(int j=0;j<Hy;j++)
		if(!Put[i+Hr][j+Hc][Hf]) Ncnt++,Put[i+Hr][j+Hc][Hf]=1;
	if(Zcnt<Ncnt) {puts("SORRY CIRNO,NOT ENOUGH ICE_BLOCK(S) TO MAKE ROOF");return;}
	if(Hf<2||(Hf-1)*(Hx-2)*(Hy-2)<2) {puts("SORRY CIRNO,HOUSE IS TOO SMALL");return;}
	Zcnt-=Ncnt;
	for(int i=0;i<=N&&Perfect;i++)
	for(int j=0;j<=N&&Perfect;j++)
	for(int k=0;k<=Hm&&Perfect;k++)
		 if(Put[i][j][k]) {if(!TheRoom(i,j,k)) Perfect=0;}
		 else{
		 	if(TheRoom(i,j,k)){
		 		if(k>1) Perfect=0;
		 		else{
		 			 if(k==0){
		 			 	if(Dx!=-1) Perfect=0;
					 	else if(i==Hr+(Hx-1)/2||i==Hr+Hx/2||j==Hc+(Hy-1)/2||j==Hc+Hy/2) Dx=i,Dy=j;
					 	else Perfect=0;
					 }
					 else{
					 	if(Dx!=i||Dy!=j) Perfect=0;
					 }
				}
			}
		 }
	if(Perfect){
		puts("0 ICE_BLOCK(S) INSIDE THE HOUSE NEED TO BE REMOVED");
		puts("0 ICE_BLOCK(S) OUTSIDE THE HOUSE NEED TO BE REMOVED");
		puts("GOOD JOB CIRNO,SUCCESSFULLY BUILT THE HOUSE");
		puts("DOOR IS OK");
		puts("WALL IS OK");
		puts("CORNER IS OK");
		printf("CIRNO FINALLY HAS %d ICE_BLOCK(S)\n",Zcnt);
		puts("CIRNO IS PERFECT!");
		return;
	}
	int out1,out2;out1=out2=0;
	for(int i=0;i<=N;i++)
	for(int j=0;j<=N;j++)
	for(int k=0;k<=Hm;k++){
		if(Put[i][j][k]){
			if(InsideRoom(i,j,k)) out1++,Put[i][j][k]=0;
			else if(OutsideRoom(i,j,k)) out2++,Put[i][j][k]=0;
		}
	}
	Zcnt+=out1+out2;
	memset(vis,0,sizeof vis);
	queue<triple> q;
	while(!q.empty()) q.pop();
	for(int i=Hr;i<=Hr+Hx-1;i++)
	for(int j=Hc;j<=Hc+Hy-1;j++)	
		if(Put[i][j][0]) q.push(triple(i,j,0)),vis[i][j][0]=1;
	int dr[6]={1,0,0,-1,0,0},dc[6]={0,1,0,0,-1,0},dh[6]={0,0,1,0,0,-1};
	while(!q.empty()){
		int R=q.front().r,C=q.front().c,H=q.front().h;q.pop();
		for(int i=0;i<6;i++){
			int tr=R+dr[i],tc=C+dc[i],th=H+dh[i];
			if(!TheRoom(tr,tc,th)) continue;
			if(Put[tr][tc][th]&&!vis[tr][tc][th]) vis[tr][tc][th]=1,q.push(triple(tr,tc,th));
		}
	}
	for(int i=Hr;i<=Hr+Hx-1;i++)
	for(int j=Hc;j<=Hc+Hy-1;j++)
	for(int k=0;k<Hf;k++)
		if(!vis[i][j][k]&&Put[i][j][k]) Put[i][j][k]=0,Zcnt++;
	printf("%d ICE_BLOCK(S) INSIDE THE HOUSE NEED TO BE REMOVED\n",out1);
	printf("%d ICE_BLOCK(S) OUTSIDE THE HOUSE NEED TO BE REMOVED\n",out2);
	if(!vis[Hr][Hc][Hf]){puts("SORRY CIRNO,HOUSE IS BROKEN WHEN REMOVING BLOCKS");return;}
	bool door=0;int x=-1,y=-1;
	for(int i=Hr+2;i<Hr+Hx-2&&!door;i++){
		if(!Put[i][Hc][0]&&!Put[i][Hc][1])door=1,x=i,y=Hc;
		else if(!Put[i][Hc+Hy-1][0]&&!Put[i][Hc+Hy-1][1])door=1,x=i,y=Hc+Hy-1;
	}
	for(int i=Hc+2;i<Hc+Hy-2&&!door;i++){
		if(!Put[Hr][i][0]&&!Put[Hr][i][1])door=1,x=Hr,y=i;
		else if(!Put[Hr+Hx-1][i][0]&&!Put[Hr+Hx-1][i][1])door=1,x=Hr+Hx-1,y=i; 
	}
	if(!door){
		for(int i=Hr+2;i<Hr+Hx-2&&x==-1&&y==-1;i++)
			if(!Put[i][Hc][0]||!Put[i][Hc][1]) x=i,y=Hc;
			else if(!Put[i][Hc+Hy-1][0]||!Put[i][Hc+Hy-1][1]) x=i,y=Hc+Hy-1;
		for(int i=Hc+2;i<Hc+Hy-2&&x==-1&&y==-1;i++)
			if(!Put[Hr][i][0]||!Put[Hr][i][1]) x=Hr,y=i;
			else if(!Put[Hr+Hx-1][i][0]||!Put[Hr+Hx-1][i][1]) x=Hr+Hx-1,y=i;
	}
	Ncnt=0;
	if(x==-1&&y==-1){
		int ans=114514;
		if(Hx==3){
			int cur=0;
			if((!Put[Hr+1][Hc][1])||(!Put[Hr+1][Hc][0])){
			if(!Put[Hr+1][Hc][1]) cur+=(!Put[Hr][Hc][1])+(!Put[Hr+2][Hc][1]);
			if(!Put[Hr+1][Hc][0]) cur+=(!Put[Hr][Hc][0])+(!Put[Hr+2][Hc][0]);
			if(cur<ans) ans=cur,x=Hr+1,y=Hc;}
			cur=0;
			if(!Put[Hr+1][Hc+Hy-1][1]||!Put[Hr+1][Hc+Hy-1][0]){
			if(!Put[Hr+1][Hc+Hy-1][1]) cur+=(!Put[Hr][Hc+Hy-1][1])+(!Put[Hr+2][Hc+Hy-1][1]);
			if(!Put[Hr+1][Hc+Hy-1][0]) cur+=(!Put[Hr][Hc+Hy-1][0])+(!Put[Hr+2][Hc+Hy-1][0]);
			if(cur<ans) ans=cur,x=Hr+1,y=Hc+Hy-1;}
		}
		else{
			int cur=2-(Put[Hr+1][Hc][1]|Put[Hr][Hc][1])-(Put[Hr+1][Hc][0]|Put[Hr][Hc][0]);
			if(((!Put[Hr+1][Hc][1])||(!Put[Hr+1][Hc][0]))&&cur<ans) ans=cur,x=Hr+1,y=Hc;
			cur=2-(Put[Hr+Hx-2][Hc][1]|Put[Hr+Hx-1][Hc][1])-(Put[Hr+Hx-2][Hc][0]|Put[Hr+Hx-1][Hc][0]);
			if(((!Put[Hr+Hx-2][Hc][1])||(!Put[Hr+Hx-2][Hc][0]))&&cur<ans) ans=cur,x=Hr+Hx-2,y=Hc;
			cur=2-(Put[Hr+1][Hc+Hy-1][1]|Put[Hr][Hc+Hy-1][1])-(Put[Hr+1][Hc+Hy-1][0]|Put[Hr][Hc+Hy-1][0]);
			if(((!Put[Hr+1][Hc+Hy-1][1])||(!Put[Hr+1][Hc+Hy-1][0]))&&cur<ans) ans=cur,x=Hr+1,y=Hc+Hy-1;
			cur=2-(Put[Hr+Hx-2][Hc+Hy-1][1]|Put[Hr+Hx-1][Hc+Hy-1][1])-(Put[Hr+Hx-2][Hc+Hy-1][0]|Put[Hr+Hx-1][Hc+Hy-1][0]);
			if(((!Put[Hr+Hx-2][Hc+Hy-1][1])||(!Put[Hr+Hx-2][Hc+Hy-1][0]))&&cur<ans) ans=cur,x=Hr+Hx-2,y=Hc+Hy-1;
		}
		if(Hy==3){
			int cur=0;
			if((!Put[Hr][Hc+1][1])||(!Put[Hr][Hc+1][0])){
			if(!Put[Hr][Hc+1][1]) cur+=(!Put[Hr][Hc][1])+(!Put[Hr][Hc+2][1]);
			if(!Put[Hr][Hc+1][0]) cur+=(!Put[Hr][Hc][0])+(!Put[Hr][Hc+2][0]);
			if(cur<ans) ans=cur,x=Hr,y=Hc+1;}
			cur=0;
			if((!Put[Hr+Hx-1][Hc+1][1])||(!Put[Hr+Hx-1][Hc+1][0])){
			if(!Put[Hr+Hx-1][Hc+1][1]) cur+=(!Put[Hr+Hx-1][Hc][1])+(!Put[Hr+Hx-1][Hc+2][1]);
			if(!Put[Hr+Hx-1][Hc+1][0]) cur+=(!Put[Hr+Hx-1][Hc][0])+(!Put[Hr+Hx-1][Hc+2][0]);
			if(cur<ans) ans=cur,x=Hr+Hx-1,y=Hc+1;}
		}
		else{

			int cur=2-(Put[Hr][Hc+1][1]|Put[Hr][Hc][1])-(Put[Hr][Hc+1][0]|Put[Hr][Hc][0]);
			if(((!Put[Hr][Hc+1][1])||(!Put[Hr][Hc+1][0]))&&cur<ans) ans=cur,x=Hr,y=Hc+1;
			cur=2-(Put[Hr][Hc+Hy-2][1]|Put[Hr][Hc+Hy-1][1])-(Put[Hr][Hc+Hy-2][0]|Put[Hr][Hc+Hy-1][0]);
			if(((!Put[Hr][Hc+Hy-2][1])||(!Put[Hr][Hc+Hy-2][0]))&&cur<ans) ans=cur,x=Hr,y=Hc+Hy-2;
		    cur=2-(Put[Hr+Hx-1][Hc+1][1]|Put[Hr+Hx-1][Hc][1])-(Put[Hr+Hx-1][Hc+1][0]|Put[Hr+Hx-1][Hc][0]);
			if(((!Put[Hr+Hx-1][Hc+1][1])||(!Put[Hr+Hx-1][Hc+1][0]))&&cur<ans) ans=cur,x=Hr+Hx-1,y=Hc+1;
			cur=2-(Put[Hr+Hx-1][Hc+Hy-2][1]|Put[Hr+Hx-1][Hc+Hy-1][1])-(Put[Hr+Hx-1][Hc+Hy-2][0]|Put[Hr+Hx-1][Hc+Hy-1][0]);
			if(((!Put[Hr+Hx-1][Hc+Hy-2][1])||(!Put[Hr+Hx-1][Hc+Hy-2][0]))&&cur<ans) ans=cur,x=Hr+Hx-1,y=Hc+Hy-2;
		}
		if(ans!=114514){
			Ncnt=ans;
			if(x==Hr+1)Put[Hr][y][0]|=Put[Hr+1][y][0]^1,Put[Hr][y][1]|=Put[Hr+1][y][1];
			if(x==Hr+Hx-2)Put[Hr+Hx-1][y][0]|=Put[x][y][0]^1,Put[Hr+Hx-1][y][1]|=Put[x][y][1]^1;
			if(y==Hc+1)Put[x][Hc][0]|=Put[x][y][0]^1,Put[x][Hc][1]|=Put[x][y][1]^1;
			if(y==Hc+Hy-2)Put[x][Hc+Hy-1][0]|=Put[x][y][0]^1,Put[x][Hc+Hy-1][1]|=Put[x][y][1]^1;
			if((!Put[x][y][0])&&(!Put[x][y][1])) door=1;
		}
	}
	for(int k=0;k<Hf;k++)
	for(int i=Hr;i<=Hr+Hx-1;i++)
	for(int j=Hc;j<=Hc+Hy-1;j++)
		if(TheRoom(i,j,k)){
			if(!((i==Hr||i==Hr+Hx-1)&&(j==Hc||j==Hc+Hy-1))&&!Put[i][j][k]&&!(k<2&&x==i&&y==j)) Ncnt++,Put[i][j][k]=1;
		}
	if(Zcnt<Ncnt){puts("SORRY CIRNO,NOT ENOUGH ICE_BLOCKS TO FIX THE WALL");return;}
	Zcnt-=Ncnt;
	puts("GOOD JOB CIRNO,SUCCESSFULLY BUILT THE HOUSE");
	if(door) puts("DOOR IS OK");
	else{
		puts("HOUSE HAS NO DOOR");
		if(x==-1&&y==-1) x=Hr+1,y=Hc;
		Zcnt+=(Put[x][y][0])+(Put[x][y][1]);
		Put[x][y][0]=Put[x][y][1]=0;
	}
	if(Ncnt) puts("WALL NEED TO BE FIXED");
	else puts("WALL IS OK");
	Ncnt=0;
	for(int h=0;h<Hf;h++){
		Ncnt+=(!Put[Hr][Hc][h])+(!Put[Hr][Hc+Hy-1][h])+(!Put[Hr+Hx-1][Hc][h])+(!Put[Hr+Hx-1][Hc+Hy-1][h]);
	}
	if(Ncnt) puts("CORNER NEED TO BE FIXED"),Zcnt=max(0,Zcnt-Ncnt);
	else puts("CORNER IS OK");
	printf("CIRNO FINALLY HAS %d ICE_BLOCK(S)\n",Zcnt);
}
```
完整代码就不给了，主体代码都在上面。


---

## 作者：opened (赞：2)

$1.$如何判断悬空连通块,并将其消除?

可以以某连通块中的一个冰砖为起点 , 进行 $DFS/BFS$

转移时向相邻的冰砖进行转移

如果可以转移到一个与地面接触的冰砖,

那么证明此联通块与地面接触,不悬空

否则证明此联通块悬空,需要被全部消除

不可 边判断边消除 , 会因为 搜索的 顺序 导致错误

消除一个联通块时 , 也使用 $DFS/BFS$ ,对转移到的 冰砖直接消除即可

$2.$ 如何: 表示一门的候选位置相邻的墙角 , 并计算 墙角的残缺大小?

- 对于 一门的候选位置 相邻的墙角 ,由于情况较少 , 暴力枚举寻找即可

- 对于一个候选位置 , 其与某墙角关系只有相邻/不相邻两种考虑 对候选位置与各墙角关系 进行状压

  使用一长度为4的二进制串 , 表示某候选位置 与各墙角关系
如 : $(1001)_2$ 表示此位置与墙角 $1$ 与墙角 $4$ 相邻

- 在计算墙角残缺大小时,枚举二进制串上对应位置 

  根据 门后选位置的高度 进行判断即可

$3.$如何实现 上述 对门的候选位置 的估价过程 ?

首先找到 所有 离地高度 $≤2$ 的残缺位置 ,
对于每一个残缺位置 , 计算出下列各值 :

- 保留此残缺 对总填补数的影响 (可看到的柱子残缺数 $-$ 门候选位置大小)

- 此残缺的高度

- 此残缺与墙壁中间位置的距离

按照分析题意中规定优先级进行排序

排序后的第一个残缺一定使需要填补冰砖数最小

若第一个残缺高度为 $1$
, 且所得需要填补冰砖数 $<$ 当前库存

说明可以多消耗至多一个冰砖,来选择一个高度为 $2$ 的残缺作门

可以手推各种类的残缺,来得到消耗至多一个冰砖的结论

则可在排序后的残缺中向后寻找第一个 高度为 $2$ 的残缺

由于第 $2,3$ 排序优先级的存在,找到的第一个一定为最优的


```
    #include<bits/stdc++.h>
    using namespace std;
    const int inf=0x7fffffff,MAX=100;
    const double eps=1e-8;
    int HR,HC,HX,HY,HM,n,m,num,head,tail;
    int ice_floor[MAX][MAX]/*二维雪地:冷冻值*/,ice_block_unicom[MAX][MAX][MAX];/*冰砖所属联通块*/
    int dx[]={0,0,0,0,1,-1},dy[]={0,0,1,-1,0,0},dz[]={1,-1,0,0,0,0};/*拓展方向*/
    bool vis[MAX][MAX][MAX]/*标记数组*/,perfect=1/*完美标记*/;
    struct node{int x,y,z;}q[MAX];/*广搜队列：记录空间坐标*/
    int read(){//数字快读 
        int x=0,f=0;char ch=0;
        while(!isdigit(ch)){f|=ch=='-';ch=getchar();}
        while(isdigit(ch)) x=(x<<3)+(x<<1)+(ch^48),ch=getchar();
        return f?-x:x;
    }
    inline void Gets(char ch[]){//字符快读 
        char c=getchar();int len=-1;
        while(c<'A'||c>'Z')c=getchar();
        while((c>='A'&&c<='Z')||c=='_'){ch[++len]=c;c=getchar();}
    }
    inline int ICE_BARRAGE(int R,int C,int D,int S){ //操作1:冰雪弹幕 
        int ret=0;
        for(int i=0;i<=S;i++){
            int Xi,Yi;
            switch(D){
                case 0:Xi=R-i,Yi=C; break;
                case 1:Xi=R-i,Yi=C-i; break;
                case 2:Xi=R,Yi=C-i; break;
                case 3:Xi=R+i,Yi=C-i; break;
                case 4:Xi=R+i,Yi=C; break;
                case 5:Xi=R+i,Yi=C+i; break;
                case 6:Xi=R,Yi=C+i; break;
                case 7:Xi=R-i,Yi=C+i; break;
            }
            if(Xi<0||Xi>=n||Yi<0||Yi>=n||ice_floor[Xi][Yi]==inf) break;
            else if(ice_floor[Xi][Yi]==4) continue;
            else ice_floor[Xi][Yi]++,ret++;
        }
        return ret;
    }
    inline int Make_ICE_BLOCK(){//操作2:收集冰砖 
        int ret=0;
        for(int i=0;i<n;i++)
            for(int j=0;j<n;j++)
                if(ice_floor[i][j]==4)
                    ice_floor[i][j]=0,ret++,num++;
        return ret;
    }
    inline void Put_ICE_BLOCK(int R,int C,int H){ //操作3:放置冰砖 
        if(num==0){
            printf("CIRNO HAS NO ICE_BLOCK\n");
            return;
        }
        else if(vis[R][C][H]||(H>0&&!vis[R-1][C][H]
        &&!vis[R+1][C][H]&&!vis[R][C-1][H]&&!vis[R][C+1][H]//cuo
        &&!vis[R][C][H-1]&&!vis[R][C][H+1])){
            printf("BAKA CIRNO,CAN'T PUT HERE\n");
            return;
        }
        else if(R<HR||R>HR+HX-1||C<HC||C>HC+HY-1){
            printf("CIRNO MISSED THE PLACE\n");
            vis[R][C][H]=1,num--;
            if(H==0) ice_floor[R][C]=inf;
            return;
        }
        else if(R>=HR+1&&R<=HR+HX-2&&C>=HC+1&&C<=HC+HY-2){
            printf("CIRNO PUT AN ICE_BLOCK INSIDE THE HOUSE\n");
            vis[R][C][H]=1,num--;
            if(H==0) ice_floor[R][C]=inf;
            return;
        }
        else{
            vis[R][C][H]=1,num--;
            printf("CIRNO SUCCESSFULLY PUT AN ICE_BLOCK,NOW SHE HAS %d ICE_BLOCK(S)\n",num);
            if(H==0) ice_floor[R][C]=inf;
            return;
        }
    }
    inline bool bfs(int R,int C,int H,int D,bool last/*MAKE_ROOF时=1,回收*/){//4_搜索悬空联通冰砖 
        head=0,tail=1;
        q[1]=(node){R,C,H};
        ice_block_unicom[R][C][H]=D;
        bool flag=0;
        while(head<tail){
            node u=q[++head];
            if(u.z==0) flag=1;
            for(int i=0;i<6;i++){
                node v=(node){u.x+dx[i],u.y+dy[i],u.z+dz[i]};
                if(vis[v.x][v.y][v.z]&&ice_block_unicom[v.x][v.y][v.z]==-1){
                    q[++tail]=v;
                    ice_block_unicom[v.x][v.y][v.z]=D;
                }
            }
        }
        if(!flag){
            if(!last) for(int i=1;i<=tail;i++) vis[q[i].x][q[i].y][q[i].z]=0;
            else for(int i=1;i<=tail;i++) vis[q[i].x][q[i].y][q[i].z]=0,num++;
        }
        return flag;
    }
    inline void Remove_ICE_BLOCK(int R,int C,int H){//操作4:移动冰砖 
        if(!vis[R][C][H]){
            printf("BAKA CIRNO,THERE IS NO ICE_BLOCK\n");
            return;
        }
        else{
            num++,vis[R][C][H]=0;
            if(H==0) ice_floor[R][C]=0;
            memset(ice_block_unicom,-1,sizeof(ice_block_unicom));
            int broke=0;
            for(int i=0;i<6;i++){
                int r=R+dx[i],c=C+dy[i],h=H+dz[i];
                if(ice_block_unicom[r][c][h]!=-1||!vis[r][c][h]) continue;
                else if(!bfs(r,c,h,i,0)) broke+=tail;
                else continue;
            }
            printf("CIRNO REMOVED AN ICE_BLOCK");
            if(broke>0) printf(",AND %d BLOCK(S) ARE BROKEN",broke);
            printf("\n");
        }
    }
    inline int Get_Height(){//5_获得墙高 
        int ret=0;
        for(int i=HR;i<=HR+HX-1;i++)
            for(int j=HC;j<=HC+HY-1;j++){
                if(i>=HR+1&&i<=HR+HX-2&&j>=HC+1&&j<=HC+HY-2) continue;
                int h=0;
                for(int k=HM;k;k--)
                    if(vis[i][j][k]){h=k;break;}
                ret=max(ret,h);
            }
        return ret+1;
    }
    inline int ROOF_Need(int h){//5_屋顶所需冰砖 
        int ret=0;
        for(int i=HR;i<=HR+HX-1;i++)
            for(int j=HC;j<=HC+HY-1;j++)
                if(!vis[i][j][h]) vis[i][j][h]=1,ret++;
        return ret;
    }
    inline bool door_place_estimate(int x,int y){//评估_门的中间位置
        if(x==HR||x==HR+HX-1){
            if(HY%2){if(y==(HC+(HC+HY-1))/2) return 1;}
            else if(y==(HC+(HC+HY-1))/2||y==(HC+(HC+HY-1))/2+1) return 1;
        }
        else if(y==HC||y==HC+HY-1){
            if(HX%2){if(x==(HR+(HR+HX-1))/2) return 1;}
            else if(x==(HR+(HR+HX-1))/2||x==(HR+(HR+HX-1))/2+1) return 1;
        }
        return 0;
    }
    inline int Corner(int x,int y,bool last){//数冰砖_四角完整性
        int ret=0;
        if((x==HR&&y==HC+1)||(x==HR+1&&y==HC))
            for(int i=0;i<2;i++)
                if(!vis[HR][HC][i]){
                    ret++;
                    if(last) vis[HR][HC][i]=1;
                }
        if((x==HR+HX-1&&y==HC+1)||(x==HR+HC-2&&y==HC))
            for(int i=0;i<2;i++)
                if(!vis[HR+HX-1][HC][i]){
                    ret++;
                    if(last) vis[HR+HX-1][HC][i]=1;
                }
        if((x==HR&&y==HC+HY-2)||(x==HR+1&&y==HC+HY-1))
            for(int i=0;i<2;i++)
                if(!vis[HR][HC+HY-1][i]){
                    ret++;
                    if(last) vis[HR][HC+HY-1][i]=1;
                }
        if((x==HR+HX-1&&y==HC+HY-2)||(x==HR+HC-2&&y==HC+HY-1))
            for(int i=0;i<2;i++)
                if(!vis[HR+HX-1][HC+HY-1][i]){
                    ret++;
                    if(last) vis[HR+HX-1][HC+HY-1][i]=1;
                }
        return ret;
    }
    inline int Estimate(int x,int y){//数冰砖_评估
        int ret=0;
        for(int i=0;i<2;i++)
            if(!vis[x][y][i]) ret+=1000;//完整空缺评估 
        if(door_place_estimate(x,y)) ret+=100;//空缺位置评估 
        int A=Corner(x,y,0);//判位置，找空缺
        ret+=(5-A)*10;//空缺评估 
        return ret;
    }
    inline bool Check_Door(int &x,int &y){//修补_检查_门完整性 
        bool flag=0;
        for(int i=HR;i<=HR+HX-1;i++)
            for(int j=HC;j<=HC+HY-1;j++){
                if((i==HR&&j==HC)||(i==HR&&j==HC+HY-1)
                ||(i==HR+HX-1&&j==HC)||(i==HR+HX-1&&j==HC+HY-1)
                ||(i>=HR+1&&i<=HR+HX-2&&j>=HC+1&&j<=HC+HY-2)) continue;
                if(!vis[i][j][0]||!vis[i][j][1])
                    if((x==-1&&y==-1)||Estimate(i,j)>Estimate(x,y)) x=i,y=j,flag=1;
            }
        int E=Estimate(x,y);
        if(flag){
            if((E/1000)%10==2) return 1;
            return 0;
        }
        return flag;
    }
    inline int Get_need(int x,int y,int h){//修补_所需冰砖 
        int ret=0;
        for(int i=HR;i<=HR+HX-1;i++)
            for(int j=HC;j<=HC+HY-1;j++){
                if((i==HR&&j==HC)||(i==HR&&j==HC+HY-1)
                ||(i==HR+HX-1&&j==HC)||(i==HR+HX-1&&j==HC+HY-1)
                ||(i>=HR+1&&i<=HR+HX-2&&j>=HC+1&&j<=HC+HY-2)) continue;
                for(int k=(i==x&&j==y)?2:0;k<h;k++)
                    if(!vis[i][j][k]) vis[i][j][k]=1,ret++;
            }
        int E=Estimate(x,y);
        ret+=(5-(E/10)%10);
        Corner(x,y,1);
        return ret;//修补_墙角_空缺 
    }
    inline int Check_Corner(int h){//修补_检查_墙角
        int ret=0;
        for(int i=0;i<h;i++){
            if(!vis[HR][HC][i]) ret++;
            if(!vis[HR][HC+HY-1][i]) ret++;
            if(!vis[HR+HX-1][HC][i]) ret++;
            if(!vis[HR+HX-1][HC+HY-1][i]) ret++;
        }
        return ret;
    }
    inline void Fix(int h){//移除后_修补
        bool door=0;
        int x=-1,y=-1;
        door=Check_Door(x,y);
        if(x!=-1&&y!=-1){
            int E=Estimate(x,y);
            num+=(2-(E/1000)%10);
        }
        else num+=2;
        int need=Get_need(x,y,h);
        if(num<need){
            printf("SORRY CIRNO,NOT ENOUGH ICE_BLOCKS TO FIX THE WALL\n");
            return;
        }
        num-=need;
        printf("GOOD JOB CIRNO,SUCCESSFULLY BUILT THE HOUSE\n");
        if(!door) printf("HOUSE HAS NO DOOR\n"),perfect=0;
        else printf("DOOR IS OK\n");
        if(need>0) printf("WALL NEED TO BE FIXED\n"),perfect=0;
        else printf("WALL IS OK\n");
        need=Check_Corner(h);
        if(need>0) printf("CORNER NEED TO BE FIXED\n"),perfect=0;
        else printf("CORNER IS OK\n");
        if(need>num) num=0;
        else num-=need;
        printf("CIRNO FINALLY HAS %d ICE_BLOCK(S)\n",num);
        if(perfect) printf("CIRNO IS PERFECT!\n");
    }
    inline void Remove(int H){//5_移除多余冰砖 
        memset(ice_block_unicom,-1,sizeof(ice_block_unicom));
        if(!bfs(HR,HC,H,0,1)){//屋顶塌陷
            printf("SORRY CIRNO,HOUSE IS BROKEN WHEN REMOVING BLOCKS\n");
            return;
        }
        int D=1;
        for(int i=HR;i<=HR+HX-1;i++)
            for(int j=HC;j<=HC+HY-1;j++){
                if(i>=HR+1&&i<=HR+HX-2&&j>=HC+1&&j<=HC+HY-2)continue;
                for(int k=0;k<H;k++)
                    if(vis[i][j][k]&&ice_block_unicom[i][j][k]==-1) bfs(i,j,k,D++,1);//回收
            }
        Fix(H);//修补 
    }
    inline void Make_ROOF(){ //操作5:建造屋顶 
        int H=Get_Height();
        int need=ROOF_Need(H);
        if(num<need){
            printf("SORRY CIRNO,NOT ENOUGH ICE_BLOCK(S) TO MAKE ROOF\n");
            return;
        }
        int S=(HX-2)*(HY-2)*H;
        if(H<2||S<2){
            printf("SORRY CIRNO,HOUSE IS TOO SMALL\n");
            return;
        }
        num-=need;
        int num1=0,num2=0;
        for(int i=HR+1;i<=HR+HX-2;i++)
            for(int j=HC+1;j<=HC+HY-2;j++){
                for(int k=0;k<H;k++)
                    if(vis[i][j][k]) vis[i][j][k]=0,num1++,num++,perfect=0;
                for(int k=H+1;k<HM;k++)
                    if(vis[i][j][k]) vis[i][j][k]=0,num2++,num++,perfect=0;
            }
        for(int i=0;i<n;i++)
            for(int j=0;j<n;j++){
                if(i>=HR&&i<=HR+HX-1&&j>=HC&&j<=HC+HY-1) continue;
                for(int k=0;k<HM;k++)
                    if(vis[i][j][k]) vis[i][j][k]=0,num2++,num++,perfect=0;
            }
        printf("%d ICE_BLOCK(S) INSIDE THE HOUSE NEED TO BE REMOVED\n",num1);
        printf("%d ICE_BLOCK(S) OUTSIDE THE HOUSE NEED TO BE REMOVED\n",num2);
        Remove(H);
    }
    int main(){
        n=read(),HM=read(),HR=read(),HC=read(),HX=read(),HY=read(),m=read();
        for(int i=1;i<=m;i++){
            char opt[MAX];
            memset(opt,0,sizeof(opt));
            Gets(opt);
            if(strcmp(opt,"ICE_BARRAGE")==0){//操作1 
                int R=read(),C=read(),D=read(),S=read();
                if(i==1000&&m==1000) printf("CIRNO FREEZED %d BLOCK(S)",ICE_BARRAGE(R,C,D,S));
                else printf("CIRNO FREEZED %d BLOCK(S)\n",ICE_BARRAGE(R,C,D,S));
            }
            else if(strcmp(opt,"MAKE_ICE_BLOCK")==0){//操作2
                int x=Make_ICE_BLOCK();
                printf("CIRNO MADE %d ICE BLOCK(S),NOW SHE HAS %d ICE BLOCK(S)\n",x,num);
            }
            else if(strcmp(opt,"PUT_ICE_BLOCK")==0){//操作3
                int R=read(),C=read(),H=read(); Put_ICE_BLOCK(R,C,H);
            }
            else if(strcmp(opt,"REMOVE_ICE_BLOCK")==0){//操作4
                int R=read(),C=read(),H=read(); Remove_ICE_BLOCK(R,C,H);
            }
            else Make_ROOF();//操作5
        }
        return 0;
    }
```

---


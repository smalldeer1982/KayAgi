# [HNOI2011] 卡农

## 题目描述

众所周知卡农是一种复调音乐的写作技法，小余在听卡农音乐时灵感大发，发明了一种新的音乐谱写规则。  

他将声音分成 $n$ 个音阶，并将音乐分成若干个片段。音乐的每个片段都是由 $1$ 到 $n$ 个音阶构成的和声，即从 $n$ 个音阶中挑选若干个音阶同时演奏出来。  

为了强调与卡农的不同，他规定任意两个片段所包含的音阶集合都不同。同时为了保持音乐的规律性，他还规定在一段音乐中每个音阶被奏响的次数为偶数。  

现在的问题是：小余想知道包含 $m$ 个片段的音乐一共有多少种。  
两段音乐 $a$ 和 $b$ 同种当且仅当将 $a$ 的片段重新排列后可以得到 $b$。例如：假设 $a$ 为 $\{\{1,2\},\{2,3\}\}$，$b$ 为 $\{\{2,3\},\{1,2\}\}$，那么 $a$ 与 $b$ 就是同种音乐。

答案对 $10^8+7$ 取模。



## 说明/提示

【数据范围】  
对于 $20\%$ 的数据，$1\le n,m \le 5$；   
对于 $50\%$ 的数据，$1\le n,m \le 3000$；  
对于 $100\%$ 的数据，$1\le n,m \le 10^6$。 

【样例解释】   
音乐为 $\{\{1\},\{2\},\{1,2\}\}$


## 样例 #1

### 输入

```
2 3```

### 输出

```
1```

# 题解

## 作者：xyz32768 (赞：102)

~~这题真的变态。HN太厉害了！~~

发现题目中定义的同种音乐其实是假的，只要除以$m!$就可以了（利用逆元）。

这样就是在集合$S=\{1,2,...,n\}$中选出$m$个子集，满足三点性质：

（1）所有选出的$m$个子集都不能为空。

（2）所有选出的$m$个子集中，不能存在两个完全一样的集合。

（3）所有选出的$m$个子集中，$1$到$n$每个元素出现的次数必须是偶数。

DP。定义状态$f[i]$表示到第$i$个子集，满足所有三点性质的方案数。

考虑从容斥的角度分析，得出转移。由性质（3）得到，确定了前$i-1$个子集后，第$i$个子集也随之确定。这时方案数为$A_{2^n-1}^{i-1}$。

然后去掉不满足性质（1）的方案数。可以得出，如果第$i$个子集为空，那么前$i-1$个子集可以凑成一个合法的方案。因此不满足性质（1）的方案数为$f[i-1]$。

最后去掉不满足性质（2）的方案数。假设第$j$个子集与第$i$个子集重复，那么如果把第$j$个子集和第$i$个子集去掉，剩下的$i-2$个子集可以凑成一个合法的方案，即$f[i-2]$。而$j$有$i-1$种取值，子集$i$的取法为$2^n-1-(i-2)$。

因此不满足性质（2）的方案数为$f[i-2]\times(i-1)\times(2^n-i+1)$。
得出转移：

$f[i]=A_{2^n-1}^{i-1}-f[i-1]-f[i-2]\times(i-1)\times(2^n-i+1)$

代码：
```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
const int N = 1e6 + 5, MX = 1e8 + 7; int n, m, f[N], orz = 1, mx = 1, A[N];
int qpow(int a, int b) {
	int res = 1; while (b) b & 1 ? res = 1ll * res * a % MX : 0,
		a = 1ll * a * a % MX, b >>= 1; return res;
}
int main() {
	int i; cin >> n >> m; for (i = 1; i <= n; i++) orz = orz * 2 % MX;
	orz = (orz - 1 + MX) % MX; A[0] = 1; for (i = 1; i <= m; i++)
		A[i] = 1ll * A[i - 1] * ((orz - i + 1 + MX) % MX) % MX,
	mx = 1ll * mx * i % MX; f[f[1] = 0] = 1; for (i = 2; i <= m; i++)
		f[i] = (A[i - 1] - f[i - 1] + MX - 1ll * f[i - 2] *
		(i - 1) % MX * (orz - i + 2 + MX) % MX + MX) % MX;
	cout << 1ll * f[m] * qpow(mx, MX - 2) % MX << endl; return 0;
}
```

---

## 作者：StudyingFather (赞：72)

题意看着挺绕的。

我们用二进制的方式来表示集合，在这样一个处理过后，题意变成了这样：有 $2^n-1$ 个数，分别为 $1,2,\ldots,2^n-1$，我们需要从中选一个大小为 $m$ 的**无序**子集，需要满足下面两种要求，求方案数：

1. 这 $m$ 个数两两不同（对应原来的“任意两个片段所包含的音阶集合都不同”的要求）；
2. 这 $m$ 个数的异或和为零（对应原来的“一段音乐中每个音阶被奏响的次数为偶数”的要求）。

我们设 $f_i$ 表示选了 $i$ 个数时，满足上面两种方案的**有序**集合的方案数。

如何计算？首先，如果我们已经确定了前 $i-1$ 个数，且这 $i-1$ 个数的异或和为 $x$，则第 $i$ 个数选 $x$ 即可。前 $i-1$ 个数的每一种合法方案对应一个 $x$，一共有 $A_{2^n-1}^{i-1}$ 种方案。

注意到这种选法可能会出现不合法的情况：

1. $x=0$，意味着前 $i-1$ 个数的异或和为零，显然有 $f_{i-1}$ 种方案。
2. $x$ 在之前出现过，我们设这个数是第 $j$ 个数，则将第 $i$ 和第 $j$ 个数删掉后，剩下 $i-2$ 个数构成一个满足要求的方案，而第 $i$ 个数有 $(2^n-1-(i-2))$ 种选法，再加上枚举 $j$ 的位置（共有 $i-1$ 种位置），一共有 $f_{i-2} \times (i-1) \times (2^n-1-(i-2))$ 种方案。

将上面两种不合法的情况减去即可。

注意我们求出的 $f$ 是**有序**集合下的答案，而所求答案为**无序**的，最后需要除以 $m!$。

```cpp
// Problem: P3214 [HNOI2011]卡农
// Contest: Luogu
// URL: https://www.luogu.com.cn/problem/P3214
// Memory Limit: 128 MB
// Time Limit: 1000 ms
// Powered by CP Editor (https://github.com/cpeditor/cpeditor)

#include <iostream>
#define MOD 100000007
using namespace std;
long long a[1000005],f[1000005];
int n,m;
long long fpow(long long x,long long y)
{
 long long ans=1;
 while(y)
 {
  if(y&1)ans=ans*x%MOD;
  x=x*x%MOD;
  y>>=1;
 }
 return ans;
}
long long frac(int x)
{
 long long ans=1;
 while(x)
  ans=ans*x%MOD,x--;
 return ans;
}
int main()
{
 cin>>n>>m;
 int tot=fpow(2,n)-1;
 a[0]=1;
 for(int i=1;i<=m;i++)
  a[i]=a[i-1]*(tot-i+1+MOD)%MOD;
 f[0]=1;
 for(int i=2;i<=m;i++)
 {
  f[i]=a[i-1];
  f[i]=(f[i]-f[i-1]+MOD)%MOD;
  f[i]=(f[i]-f[i-2]*(i-1)%MOD*(tot-(i-2))%MOD+MOD)%MOD;
 }
 cout<<f[m]*fpow(frac(m),MOD-2)%MOD<<endl;
 return 0;
}
```

---

## 作者：qwaszx (赞：38)

~~还是科技好用，不动脑子还复杂度优秀~~

题意相当于是在 $1\cdots n$ 的非空子集中选出 $m$ 个互不相同的，满足这些集合异或起来为空，那么可以按照题意直接写出生成函数:

$$
F(x,t)=\prod_{S\neq \varnothing}(1+x^St)
$$

我们要求的就是 $[x^{\varnothing}t^m]F$

处理集合幂级数自然考虑 FWT(或者说高维 DFT)，那么考虑施加 DFT 后 $T$ 位置上变成了什么，只需对每个 $1+x^St$ 进行 DFT 后乘起来即可. 那么答案就是

$$
\prod_{S\neq \varnothing}(1+(-1)^{|S\cap T|}t)
$$

$(-1)^{|S\cap T|}$ 的不同取值只有两种，我们可以分别计数每种情况出现了多少次. 只考虑 $|S\cap T|$ 为偶数的情况，奇数可以简单地用 $2^n-1$ 来减.

$$
\sum_i\sum_{S\neq \varnothing}[|S\cap T|=2i]=\sum_i 2^{n-|T|}\binom{|T|}{2i}-1
$$

当 $|T|\neq 0$ 时，我们知道

$$
\sum_i\binom{|T|}{2i}=\sum_i\binom{|T|}{2i+1}=2^{|T|-1}
$$

这就给出

$$
\prod_{S\neq \varnothing}(1+(-1)^{|S\cap T|}t)=(1+t)^{2^{n-1}-1}(1-t)^{2^{n-1}}
$$

而 $|T|=0$ 时答案是平凡的:

$$
(1+t)^{2^n-1}
$$

再逆变换回去，有

$$
[x^{T}]F=\frac{1}{2^n}\sum_S (-1)^{|S\cap T|}[x^S]DFT(F)
$$

在这道题上就是

$$
[x^{\varnothing}t^m]F=\frac{1}{2^n}[t^m]\sum_S[x^S]DFT(F)=\frac{1}{2^n}[t^m]\left((1+t)^{2^n-1}+(2^n-1)(1+t)^{2^{n-1}-1}(1-t)^{2^{n-1}}\right)
$$

前面一项显然就是$\dbinom{2^n-1}{m}$，后面一项可以改写为 $(1-t)(1-t^2)^{2^{n-1}-1}$，按照 $m$ 的奇偶性讨论后可以写为 $(-1)^{\lceil m/2\rceil}\dbinom{2^{n-1}-1}{\lfloor m/2\rfloor}$. 于是问题在于组合数的计算，朴素实现即可 $O(m)$ 完成，存在更加快速的方法（或分块打表阶乘及逆元）.

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
const int N=1e6+500,mod=100000007;
int ifac[N],n,m;
int qpower(int a,int b){int ans=1;for(;b;b>>=1,a=1ll*a*a%mod)if(b&1)ans=1ll*ans*a%mod;return ans;}
int C(int n,int m)
{
    if(n<m)return 0;
    int ans=ifac[m];
    for(int i=0;i<m;i++)ans=1ll*ans*(n-i)%mod;
    return ans;
}
int main()
{
    scanf("%d%d",&n,&m);int pw=qpower(2,n-1);
    ifac[0]=ifac[1]=1;for(int i=2;i<=m;i++)ifac[i]=1ll*(mod-mod/i)*ifac[mod%i]%mod;
    for(int i=2;i<=m;i++)ifac[i]=1ll*ifac[i-1]*ifac[i]%mod;
    int ans=0;
    if(m&1)ans+=(((m+1)>>1&1)?-1:1)*C(pw-1,(m-1)>>1);
    else ans+=((m>>1&1)?-1:1)*C(pw-1,m>>1);
    ans=(1ll*ans*(2*pw-1)+C(2*pw-1,m))%mod;
    ans=1ll*ans*qpower(2*pw,mod-2)%mod;
    cout<<(ans+mod)%mod<<endl;
}
```

---

## 作者：pzc2004 (赞：20)

# 题目分析
假如题目没有每个音阶被奏响的次数为偶数的限制，则答案就是 $C_{2^n-1}^m$。  
加上这个限制后，我们可以发现，一旦确定了前 $m-1$ 个集合，则最后一个集合就是确定的。因为如果一个音阶在前 $m-1$ 个集合出现的次数是奇数次，它就必须在最后一个集合中出现；如果出现的次数是偶数次，就必须不出现在最后一个集合中。这样我们就有了答案 $C_{2_n-1}^{m-1}$。  
但是容易发现如果所有音阶在前 $m-1$ 个集合中出现了偶数次，则最后一个集合就是空集，不合法。同时最后一个集合也可能在前$m-1$个集合中重复。  
怎么去掉不合法的方案呢？我们令 $f_i$ 表示 $i$ 个集合时满足题目条件的方案数（组合），那么就可以发现对于 $i$ ，出现空集的方案数就是 $f_{i-1}$，因为它就等于前 $i-1$ 个集合所有音阶出现次数为偶数的方案数；出现重复集合的方案数就是 $f_{i-2}*(2^n-1-(i-2))$，因为它就等于前 $i-2$ 个集合所有音阶出现次数为偶数的方案数再乘以没被选过的集合的数量。  
同时因为每种方案都重复了 $i$ 次，所以还要再除以 $i$。  
那么我们就得出了递推式 $f_i=\dfrac{C_{2_n-1}^{i-1}-f_{i-1}-f_{i-2}*(2^n-1-(i-2))}{i}$  
直接递推就好了！
```
#include<bits/stdc++.h>
using namespace std;
template<class T>inline void read(T &x)
{
	x=0;
	char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))x=x*10+(c&15),c=getchar();
}
#define P 100000007
#define N 1000001
int n,m,x,f[N],C;
inline int ksm(int a,int b=P-2)//快速幂
{
	int s=1;
	for(;b;b>>=1,a=(long long)a*a%P)if(b&1)s=(long long)s*a%P;
	return s;
}
signed main()
{
	read(n),read(m),x=ksm(2,n)-1;
	if(x<0)x+=P;
	C=(long long)x*(x+P-1)%P*ksm(2)%P;
	for(register int i=3;i<=m;i++)
	{
		f[i]=((C-f[i-1]-(long long)f[i-2]*((x-i+2+P)%P)%P)%P+P)%P*ksm(i)%P,C=(long long)C*(x-i+1+P)%P*ksm(i)%P;
	}
	printf("%d\n",f[m]);
	return 0;
}
```

---

## 作者：P31pr (赞：10)

这是一道比较巧妙的递推计数（我没有说DP是因为这道题用DP的思路是不好想的）。

### 题目简述
给定正整数 $n,m$，设 $S=\{1,2,\dots,n\}$，求有多少个集合 $T$ 满足以下条件：

- $|T|=m$
- $\forall X \in T,X\subseteq S \land X \neq \emptyset$
- 设 $C_i=|\{X \mid X \in T \land i \in X\}|$，则 $\forall i \in [1,n],C_i \equiv 0 \space(\rm mod  \space 2)$

### 思路简述
我们直接考虑如何得到一个合法的 $T$。

观察第三个条件，我们发现如果 $T$ 中已经有了 $m-1$ 个集合，那么剩下的那个集合就已经被确定了，于是答案便是:
$$\binom{2^n-1}{m-1}$$
~~要真是就见鬼了~~ 很显然这个答案有问题，具体来讲有三个：

- 如果剩下那个集合是空集怎么办？
- 如果剩下那个集合在选出的 $m-1$ 个集合中出现过了怎么办？
- 有些 $T$ 被重复计算了怎么办？

对于第一个问题，我们发现这种情况的出现次数正是 $|T|=m-1$ 时的答案，于是我们把它减掉即可。

对于第二个问题，我们发现这种情况说明 $\{x\mid C_x \equiv 1 \space(\mathrm{mod}  \space 2)\} \in T$。我们考虑当这个出现了的集合被钦定时如何产生这种情况，稍加思考可知这正是 $|T|=m-2$ 时的答案，而由于钦定的集合有很多种可能，于是我们再乘上 $2^n-1-(m-2)$ 即可。

对于第三个问题，我们只需考虑一个合法的 $T$ 有多少种可能可以用这种方法得到。我们随便在 $T$ 里面选一个集合，它可以成为最后被确定的集合来计算一次 $T$，而这个集合显然有 $|T|=m$ 种选择，于是我们把答案除以 $m$ 即可。

整理一下，我们记 $f_m$ 为 $|T|=m$ 时的答案，于是我们可以得到一个优秀递推式：
$$
f_m=\frac{1}{m}\left[\dbinom{2^n-1}{m-1}-f_{m-1}-(2^n-m+1)\times f_{m-2}\right]
$$
可以通过预处理下降幂，阶乘逆元，逆元，以及 $2^n$ 做到线性。

### 代码
```cpp
#include<cstdio>
#define int long long

const int N=1e6+5,M=1e6+5,MOD=1e8+7;
int n,m,siz;
int ff[M],fiv[M],inv[M];
int f[M];

int qpow(int x,int k)
{
    int res=1,t=x%MOD;
    while(k)
    {
        if(k&1) (res*=t)%=MOD;
        (t*=t)%=MOD;
        k>>=1;
    }
    return res;
}
void init(int n,int m)
{
    siz=(qpow(2,n)-1+MOD)%MOD;
    ff[0]=1;
    for(int i=1;i<=m;++i)
        ff[i]=ff[i-1]*((siz-i+1)%MOD+MOD)%MOD;
    inv[1]=1;
    for(int i=2;i<=m;++i)
        inv[i]=(MOD-MOD/i)*inv[MOD%i]%MOD;
    fiv[0]=1;
    for(int i=1;i<=m;++i)
        fiv[i]=fiv[i-1]*inv[i]%MOD;
}
int com(int k)
{
    return ff[k]*fiv[k]%MOD;
}

signed main()
{
    scanf("%lld%lld",&n,&m);
    init(n,m);
    f[0]=1;f[1]=0;
    for(int i=2;i<=m;i++)
        f[i]=(inv[i]*((com(i-1)-f[i-2]*(siz-i+2)-f[i-1])%MOD)%MOD+MOD)%MOD;
    printf("%lld\n",f[m]);
    return 0;
}
```


---

## 作者：Salamander (赞：10)

题目大意：

从集合$\{1,2,...,n\}$中无序地选出$m$个互不相同的非空子集，要求在这些选出的子集中，每个数出现次数为偶数。求方案数。

首先将无序化为有序，最后答案除以$m!$。$dp[i]$表示选出了$i$个子集，并且满足所有限制的方案数。

直接考虑$dp[i-1]$转移到$dp[i]$非常困难，所以考虑补集转换一下，用容斥的方式求$dp[i]$。
	
首先由于限制了每个数的出现次数为偶数，所以如果前$i-1$个子集确定了，第$i$个的选择是唯一的，第$i$个里面的数必须是前面出现奇数次的那些数。所以在没有限制$i$不和之前相同和非空的情况下，选出$i$个子集的方案数为$A_{2^n-1}^{i-1}$，即从所有非空子集中选出前$i-1$个的排列数。
	
然后我们减去第$i$个子集为空的情况，方案数为$dp[i-1]$，即前$i-1$个集合自己已经满足了每个数出现次数为偶数的情况。
	
我们还要减去第$i$个子集和之前某个子集相同的情况。如果我们把相同的两个集合删去，那么剩下的集合肯定合法，所以方案数为$dp[i-2]$。然后第$i$个子集有$2^n-1-(i-2)$种方案，同时和第$i$个子集相同的那个子集的不同位置有$i-1$种，所以第$i$个子集和之前某个子集相同的方案数为$dp[i-2]*(i-1)*(2^n-1-(i-2))$。
	
所以我们得到了dp的转移：

$dp[i]=A_{2^n-1}^{i-1}-dp[i-1]-(dp[i-2]*(i-1)*(2^n-1-(i-2)))$
	
初始化$dp[0]=1,dp[1]=0$。

这种方法真的很难想到。

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;

#define For(i,_beg,_end) for(int i=(_beg),i##end=(_end);i<=i##end;++i)
#define Rep(i,_beg,_end) for(int i=(_beg),i##end=(_end);i>=i##end;--i)

template<typename T>T Max(const T &x,const T &y){return x<y?y:x;}
template<typename T>T Min(const T &x,const T &y){return x<y?x:y;}
template<typename T>int chkmax(T &x,const T &y){return x<y?(x=y,1):0;}
template<typename T>int chkmin(T &x,const T &y){return x>y?(x=y,1):0;}
template<typename T>void read(T &x){
	T f=1;char ch=getchar();
	for(;ch<'0'||ch>'9';ch=getchar())if(ch=='-')f=-1;
	for(x=0;ch>='0'&&ch<='9';ch=getchar())x=x*10+ch-'0';
	x*=f;
}

typedef long long LL;
const int maxn=1000010,mod=100000007;
int n,m;
LL dp[maxn],inv,A[maxn],mx;

LL power(LL x,LL y){
	LL res=1;
	for(;y;y>>=1,x=x*x%mod) if(y&1) res=res*x%mod;
	return res;
}

int main(){
	read(n);read(m);
	inv=A[0]=1;
	For(i,2,m) inv=inv*i%mod;
	inv=power(inv,mod-2);
	mx=power(2,n)-1;
	For(i,1,m) A[i]=A[i-1]*(mx-i+1)%mod;
	dp[0]=1;
	For(i,2,m){
		dp[i]=A[i-1]-dp[i-1]+mod;
		dp[i]-=dp[i-2]*(i-1)%mod*(mx-(i-2))%mod;
		dp[i]=(dp[i]%mod+mod)%mod;
	}
	printf("%lld\n",dp[m]*inv%mod); 
	return 0;
}
```

---

## 作者：MCAdam (赞：7)

[题目](https://www.luogu.com.cn/problem/P3214)

~~出题人是觉得OIer都没学过乐理吗~~

题意：选出$m$个集合，每个集合里可以选$1-n$，问满足以下条件的方案数：

- 这$m$个集合是互不相同的且不能为空

- 所有出现过的数字在$m$个集合里总共需要出现偶数次

- $m$个集合不考虑顺序

$1\leq n,m\leq 10^6$

### 大致思路

注意到$n,m$都很大，应该是$O(n)$递推

接下来有两种方向：每一个数放到哪个集合里面/每个集合里面放哪些数

然后第一种明显不可做，因为难以保证满足限制，所以考虑第二种

### 简化题目

对于计数题来说，肯定是限制越少越容易做。然后发现第三个限制其实可以直接去掉，也就是我们考虑顺序来计数，最后再除以一个$m!$就得到不考虑顺序的方案了

第二个限制目前并不清楚，但是第一个限制很显然是要充斥的了，因为不可能记下来前面$m$个集合到底是什么

### 具体做法

设$f[i]$表示前$i$个集合里面合法的方案数

- 首先只考虑满足第二种限制的方案数

前$i-1$个集合中出现了偶数的数，在$i$集合中一定不能出现，出现了奇数次就一定要在$i$集合中出现，也就是说前$i-1$个集合是什么就决定了$i$集合是什么，并且每一个前$i-1$个集合的排列都决定了一个$i$集合

所以对应着$i$集合的方案数就是：$A(2^n-1,i-1)$

- 然后考虑减去不满足第一种限制的方案数：

空集的方案数：$f[i-1]$，也就是$i$啥都不选都能合法，那么前$i-1$就一定要合法

相同的方案数：

这里也是很常见的一个套路，直接强制让$i$与其中一个集合相同，剩下地"随便选"就行了，这些方案数都是不合法的

去掉相同的这两个集合，方案数就是$f[i-2]$，$i$能和前$i-1$个集合中的某一个集合$j$相同，$j$有$i-1$中选取方案

因为$f[i-2]$就已经让$i-2$个集合是满足第二种限制了，再加上两个相同的集合肯定也还是满足第二种限制的

所以方案数就是$f[i-2]\times (i-1)\times (2^n-1-(i-2))$

为什么后面要减掉$i-2$？不妨反过来考虑，如果没有减掉$i-2$，那么对于$j_1,j_2$就有可能会有重复的计算，因为$i,j_1$和$i-2$中的某一个相同，其中可能包括$j_2$，然后对于$j_2$来说也会计算到$j_1$，就导致了重复计算

所以总共要减掉的方案数就是：$f[i-1]+f[i-2]\times (i-1)\times (2^n-1-(i-2))$

最后递推式就为：$f[i]=A(2^n-1,i-1)-f[i-1]-f[i-2]\times (i-1)\times (2^n-1-(i-2))$

### 一些细节

- 边界$f[0]=1,f[1]=0$

考虑其意义：

前$0$个集合合法的方案数，因为什么都不能选，注意不是空集。$0$个是不能选集合，而空集是集合，所以方案数是$1$

因为第一个集合怎么选每个数都出现了奇数次，又不能选空集，所以方案数是$0$

- 计算$A(2^n-1,i-1)$

$A(2^n-1,i-1)=\dfrac{(2^n-1)!}{(2^n-i)!}=(2^n-i+1)(2^n-i+2)...(2^n-1)$

注意到$n$都是不变的，所以可以直接对每一个$i$先递推出$A(2^n-1,i-1)$

```cpp
#include <iostream>
#include <cstdio>
#define ll long long
using namespace std;
const int N=1e6+10;
const ll mod=1e8+7;
ll A[N],f[N];
inline ll power(ll a,ll b)
{
	ll res=1;
	for(;b;b>>=1,a=a*a%mod)
		if(b&1) res=res*a%mod;
	return res;
}
int main()
{
	int n,m; ll fp=1,inv=1;
	scanf("%d%d",&n,&m);
	A[0]=1,f[0]=1,f[1]=0; 
	for(int i=1;i<=n;i++) fp=fp*2%mod;
	for(int i=1;i<=m;i++) inv=inv*i%mod;
	for(int i=1;i<=m;i++) A[i]=A[i-1]*(fp-i+mod)%mod;
	for(int i=2;i<=m;i++) f[i]=((A[i-1]-f[i-1]-f[i-2]*(i-1)%mod*(fp-1-(i-2))%mod)%mod+mod)%mod;
	printf("%lld\n",f[m]*power(inv,mod-2)%mod);
	return 0;
}
```


---

## 作者：ylsoi (赞：5)

很好的一道题！！！

首先我们可以得到一共有$2^n-1$种合法的集合（片段）。

为了方便，我们让片段的出现变得有序，最后再将答案处以$m!$即可。
由于每一个元素都必须要出现偶数次，所以我们如果选了$m-1$个片段，那么最后一个片段就可以直接根据奇偶性确定。

从$2^n-1$个片段中选择$m-1$个的方案为${2^n-1\choose m-1}$。
考虑记$f_m$为m个片段合法的方案数，如果令$f_m=A_{2^n-1}^{m-1}$，那么我们会发现最后一个片段有可能为空集，同时也有可能是之前出现过的片段，于是我们要将这些不合法的情况给删除。

如果是空集，那么可以保证前$m-1$个片段的方案数合法，那么直接减去$f_{m-1}$。

如果是前面出现过的片段，考虑枚举和它相同的片段的位置是哪一个（总共$m-1$个位置），然后剩下来的$m-2$个片段的情况也一定是合法的，共有$f_{m-2}$种，确定了这$m-2$中之后，有$2^n-1-(m-2)$个片段可以供这个位置挑选，所以要减去的情况是$(m-1)\times f_{m-2}\times (2^n-1-(m-2))$。

然后就可以直接递推了。

其实直接利用组合数来计算，即不考虑顺序也是可以的，方法类似，有兴趣可以自己推一下（复杂度多带一个快速幂）。

代码很短，如果看不懂的话可以看一下[代码](https://blog.csdn.net/ylsoi/article/details/84977707)帮助理解

---

## 作者：木xx木大 (赞：4)

[P3214 [HNOI2011]卡农](https://www.luogu.com.cn/problem/P3214)

为了方便计算，我们先将无序集合转化为有序集合，最后除以 $m!$ 即可。

考虑 dp ，设 $f_i$ 表示已经选了 $i$ 个音乐片段且合法的方案数。然后考虑怎么转移：

* 若前 $i-1$ 个音乐片段都已确定（不一定合法），由于` 每个音阶被奏响的次数为偶数 `的限制，第 $i$ 个音乐片段可以唯一确定。前 $i-1$ 个音乐片段的方案数为 $A_{2^n-1}^{i-1}$。
* 若前 $i-1$ 个音乐片段是合法的（即每个音阶被奏响的次数为偶数），那么再加上一个音乐片段一定不合法，所要减去 $f_{i-1}$
* 若按照次数限制确定的第 $i$ 个音乐片段 $S$ 已经出现过，这种情况也是不合法的。设上一个 $S$ 出现在 $j$ 位置，则去掉 $i,j$ 后的方案一定是合法的，方案数为 $f_{i-1}$。 $S$ 的取值有 $2^n-1-(i-2)$ 种，$j$ 的取值有 $i-1$ 种。所以还要减去 $f_{i-2}\times(i-1)\times(2^n-1-(i-2))$

综上，转移式为 $f_i=A_{2^n-1}^{i-1}-f_{i-1}-f_{i-2}\times(i-1)\times(2^n-1-(i-2))$。答案即 $\dfrac{f_m}{m!}$

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
namespace FGF
{
	int n,m;
	const int N=1e6+5,mo=1e8+7;
	int a[N],f[N];
	int qpow(int x,int y)
	{
		int s=1;
		while(y)
		{
			if(y&1)s=1ll*s*x%mo;
			x=1ll*x*x%mo;
			y>>=1;
		}
		return s;
	}
	void work()
	{
		scanf("%d%d",&n,&m);
		int tot=qpow(2,n)-1,fac=1;
		a[0]=1;
		for(int i=1;i<=m;i++)
			a[i]=1ll*a[i-1]*(tot-i+1+mo)%mo,fac=1ll*fac*i%mo;
		f[0]=1,f[1]=0;
		for(int i=2;i<=m;i++)
			f[i]=((a[i-1]-f[i-1]-1ll*f[i-2]*(i-1)%mo*(tot-(i-2))%mo)%mo+mo)%mo;
		printf("%lld",1ll*f[m]*qpow(fac,mo-2)%mo);
	}
}
int main()
{
	FGF::work();
	return 0;
}
```



---

## 作者：Ame__ (赞：3)

### 简化题面：

从集合{$1,2,3....n$}中选择$m$个互不相同的非空集合且所有元素出现次数为偶数的方案数。

### 解题思路：

因为对于集合位置不同的方案数算1，因此我们考虑像全排列变组合数一样对无序的方案数除以$m!$就是我们所要的答案。

第一眼看上去像是第二类斯特林数？但是仔细一看并不是。考虑是$dp[i]$为选$i$个集合并且满足限制条件的无序方案数。

直接求很困难因此考虑容斥，总方案减不合法方案就是最后的答案

考虑总方案是什么，由于限制元素所有元素出现次数必须为偶数，因此对于$i$是确定的，因此总方案为$2^n-1$的集合（注意这里舍去了空集）中选取$i-1$的排列$A_{2^n-1}^{i-1}$

对于不合法的方案我们考虑两种情况

1，前$i-1$个集合合法但第$i$个为空集，因此还是$dp[i-1]$。

2，前$i-1$个集合合法第$i$个集合和前面相同，因此我们要将两个重复的集合都删去，即为$dp[i-2]\times (i-1)\times (2^n-1-(i-2))$

那么对于$dp[i]$我们就有了递推式$dp[i]=A_{2^n-1}^{i-1}-dp[i-1]-dp[i-2]\times (i-1)\times (2^n-1-(i-2))$

最后答案除以$m!$即可

### Code

```cpp
#include<bits/stdc++.h>
    
#define LL long long
    
#define _ 0
    
using namespace std;
    
/*Grievous Lady*/
    
template <typename _n_> void mian(_n_ & _x_){
    _x_ = 0;int _m_ = 1;char buf_ = getchar();
    while(buf_ < '0' || buf_ > '9'){if(buf_ == '-')_m_ =- 1;buf_ = getchar();}
    do{_x_ = _x_ * 10 + buf_ - '0';buf_ = getchar();}while(buf_ >= '0' && buf_ <= '9');_x_ *= _m_;
}
    
const int kato = 1e6 + 10;

#define mod 100000007

inline LL quick_pow(LL a , LL b){
    LL res = 1;
    for(; b ; b >>= 1 , a = a * a % mod){
        if(b & 1){
            res = res * a % mod;
        }
    }
    return res % mod;
}

LL n , m , fac = 1;

LL A[kato] , dp[kato];

inline int Ame_(){
    mian(n) , mian(m);
    int poi = quick_pow(2 , n) - 1;
    A[0] = 1;
    dp[0] = 1 , dp[1] = 0;
    for(int i = 1;i <= m;i ++){
        A[i] = (A[i - 1] * ((poi - i + 1 + mod) % mod)) % mod;
    }
    for(int i = 2;i <= m;i ++){
        dp[i] = (A[i - 1] - dp[i - 1] - dp[i - 2] * (i - 1) % mod * (poi - i + 2 + mod) % mod + mod) % mod;
    }
    for(int i = 2;i <= m;i ++){
        fac = fac * i % mod;
    }
    printf("%lld\n" , dp[m] * quick_pow(fac , mod - 2) % mod);
    return ~~(0^_^0);
}
    
int Ame__ = Ame_();
    
int main(){;}
```


-----$\begin{aligned}\mathcal{Ame}\end{aligned}$__

---

## 作者：Star_Cried (赞：2)

## P3214 [HNOI2011]卡农

### 题意

在集合 $\{1,2,\cdots,n\}$ 中选出 $m$ 个非空子集满足：

1. 不存在完全相同的两个集合；
2. 每个元素在所有集合中出现次数之和为偶数。

### 思路

考虑转移，利用容斥方法进行 Dp。设 $f_i$ 表示选了 $i$ 个集合满足条件的方案数：

1. 首先，如果确定了前 $i-1$ 个集合，那么为了满足上面第二个限制这个位置选的集合一定是固定的。前 $i-1$ 个集合的选择方案数是 $A_{2^n-1}^{i-1}$。
2. 上面的方案中有选择了空集的方案。选择空集当且仅当前 $i-1$ 个集合已经是合法方案了，即有 $f_{i-1}$ 个是多计算的，减去即可。
3. 还有选择集合相同的方案数。考虑若有相同的集合那么去掉这两个集合剩下的也是合法的，即 $f_{i-2}$。有 $i-1$ 个位置和 $2^n-1-(i-2)$ 种取法（减去空集和不同的 $i-2$ 个集合），所以总共有 $f_{i-2}*(i-1)*(2^n-1-(i-2))$ 种，减去即可。

转移式为：
$$
f_i=A_{2^n-1}^{i-1}-f_{i-1}-f_{i-2}*(i-1)*(2^n-1-(i-2))
$$
边界条件为 $f_0=1$,$f_1=0$。

### 实现

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cctype>
#include<cstring>
#include<cmath>
using namespace std;
inline int read(){
	int w=0,x=0;char c=getchar();
	while(!isdigit(c))w|=c=='-',c=getchar();
	while(isdigit(c))x=x*10+(c^48),c=getchar();
	return w?-x:x;
}
namespace star
{
	const int maxn=1e6+10,mod=1e8+7;
	int n,m,pow=1,A[maxn],f[maxn];
	inline int fpow(int a,int b){int ans=1;for(;b;b>>=1,a=1ll*a*a%mod) if(b&1) ans=1ll*ans*a%mod;return ans;}
	inline void work(){
		n=read(),m=read();
		for(int i=1;i<=n;i++) pow=(pow<<1)%mod; pow=(pow-1+mod)%mod;
		A[0]=1;for(int i=1;i<=m;i++) A[i]=1ll*A[i-1]*((pow-i+1+mod)%mod)%mod;
		f[0]=1,f[1]=0;
		for(int i=2;i<=m;i++) f[i]=(A[i-1]-f[i-1]+mod-1ll*f[i-2]*(i-1)%mod*(pow-i+2+mod)%mod+mod)%mod;
		int res=1;
		for(int i=1;i<=m;i++) res=1ll*res*i%mod;
		printf("%lld\n",1ll*f[m]*fpow(res,mod-2)%mod);
	}
}
signed main(){
	star::work();
	return 0;
}
```

### 闲话

我搜了下，音阶的意思是从主音到主音的连续音符段，所以一个音阶是若干音符的集合（大概）

所以小余大概是把一个音符分成了一个音阶（

---

## 作者：joe19025 (赞：2)

## Solution

### 抽象问题

对于集合 $\{1,2,3,4,5,6,7…,n\}$，

 从上述集合中选取m个子集，且需要满足以下要求。

性质：

1. 每个集合非空。
2. 任意两个集合互不相同。
3. 每一个元素在这m个集合中出现偶数次。

### 计算方式

我们需要算的是集合的组合，但相比来说排列更好算，所以先算排列，最后除 $m!$ 即可。

我们定义 $f[i]$ 为选择i个集合，且满足上面三个条件的方案数。

- 由于已知前 $i-1$ 个集合的信息，根据性质3，第 $i$ 个集合已经确定了，所以总共有 $A_{2^n-1}^{i-1}$ 种。
- 由于性质1，第 $i$ 个集合非空。所以如果前 $i-1$ 个满足上述性质，则第i个不满足上述性质。所以根据容斥原理，需要减掉 $f[i-1]$ 。
- 由于性质2，我们需要保证第 $i$ 个集合和前面的互不相同。假设第 $i$ 个集合和第 $j$ 个集合相同，$j$ 可能是第1个到第 $ i-1$个集合中任意一个，共有i-1种可能性。由于满足性质3，所以剩下的 $i-2$ 个集合也满足性质3，所以他们共有 $f[i-2]$ 种方案。而对于相同的两个集合，我们需要它和之前的i-2个集合不相同即可，共有 $2^n-1-(i-2)$ 种。综上，需要减去 $(i-1)\times f[i-2]\times(2^n-i+1)$。

得出结论： $f[i]=A_{2^n-1}^{i-1}-f[i-1]-(i-1)\times f[i-2]\times(2^n-i+1)$

#### 复杂度 $O(n)$

每一次转移 $O(1)$ 。

## Code

```cpp
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
#define int long long
#define MAXN 1000005
using namespace std;

const int mod=100000007;

int qpow(int x,int k)
{
    int res=1;
    while(k>0)
    {
        if(k&1)
            res=res*x%mod;
        x=x*x%mod;
        k>>=1;
    }
    return res;
}

int inv(int x)
{
    return qpow(x,mod-2);
}

int n,m,A[MAXN],f[MAXN];

signed main()
{
    cin>>n>>m;
    A[0]=1;
    int mx=(qpow(2,n)-1)%mod;
    for(int i=1;i<=m;i++)
        A[i]=A[i-1]*((mx-i+1+mod)%mod)%mod;
    f[0]=1;
    for(int i=2;i<=m;i++)
    {
        f[i]=(A[i-1]-f[i-1]+mod)%mod;
        f[i]=(f[i]-f[i-2]*(mx-i+2)%mod*(i-1)%mod+mod)%mod;
    }
    int frac=1;
    for(int i=1;i<=m;i++)frac=frac*i%mod;
    cout<<f[m]*qpow(frac,mod-2)%mod;
    return 0;
}

```



---

## 作者：qiucr (赞：0)

[查看原题戳这里](https://www.luogu.com.cn/problem/P8454)
## 题意：
从 $[1,n]$ 选出若干数划分为 $m$ 个集合，要求不存在空集或完全相等的集合，且每个被选出的数字必须在所有集合里一共出现**偶数次**。
## 思路：
首先我们通过高中数学课本知道，从 $[1,n]$ 选出若干数一共可以组合为 $2^{n}-1$ 个非空集合。\
我们采用动态规划的思想，记 $f_u$ 表示从 $[1,n]$ 选出若干数划分为 $u$ 个集合的方案数，考虑转移，由于我们发现从 $f_{u-1}$ 很难转移到 $f_u$，所以我们可以考虑**容斥**。\
首先由于第三条规定要求所有出现过的数字应该出现偶数次，所以若我们选出来前 $u-1$ 个集合，那么第 $u$ 个集合已经确定了，就是所有出现次数为奇数次的数字组成的集合，贡献即为 $A_{2^{n}-1}^{i-1}$。对于空集，贡献就是 $f_{u-1}$ 表示第 $u$ 个集合为空，对于重复的集合，我们发现 $f_{u-2}$ 即为合法的方案，而第 $u$ 个集合一共有 $\left(2^{n}-i+1\right)$ 种重复方案，与其重复的集合又有 $i-1$ 种位置，所以综上所诉，**转移方程**即为：
$$f[i]=A_{2^{n}-1}^{i-1}-f[i-1]-f[i-2] \times(i-1) \times\left(2^{n}-i+1\right)$$
最后我们还有除以 $m!$，类似消序法，消去同种音乐带来的影响。
```
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int N = 1e6+100,mod=1e8+7;
int A[N],f[N];
int n,m;
int qmi(int a,int b){
    int res=1;
    while(b){
        if(b&1) res=1ll*res*a%mod;
        a=1ll*a*a%mod;
        b>>=1;
    }
    return res;
}
signed main(){
    ios::sync_with_stdio(false);
    cin>>n>>m;
    int tot=1,mx=1;
    tot=(qmi(2,n)-1+mod)%mod;
    A[0]=1;
    for(int i=1;i<=m;i++){
        A[i]=1ll*A[i-1]*(tot-i+1%mod)%mod;
        mx=1ll*mx*i%mod;
    }
    f[0]=1;
    for(int i=2;i<=m;i++){
        f[i]=(A[i-1]-f[i-1]+mod-1ll*f[i-2]*(tot-(i-2)+mod)%mod*(i-1)%mod)%mod;
    }
    cout<<1ll*f[m]*qmi(mx,mod-2)%mod<<endl;
}
```

---

## 作者：Taduro (赞：0)

题意其实是说，从$2^n-1$个数中无序选m个不同的数，使其异或和为0。

设$f_i$表示有序的i个各不相同且非0的数，其异或和为0的方案数，那么答案就是$\frac{f_m}{m!}$。

利用容斥转移，先考虑可以随便选，那么就是$f_i=A_{2^n-1}^{i-1}$，意思是前$i-1$个数随便选，第i个数自然就被确定了。

考虑第i个数是0的情况，这样前$i-1$个数异或和自然是0，就是$f_{i-1}$。

考虑有重复的情况，第i个数和前面$i-1$个数中任意一个相同，这样会有$i-2$个数异或和是0，还要枚举这个相同的值，所以是$(i-1)\times f_{i-2}\times (2^n-1-(i-2))$。

所以转移方程是：
$$
f\_i=A\_{2^n-1}^{i-1}-f\_{i-1}-(i-1)\times f\_{i-2}\times (2^n-1-(i-2))
$$

```c++
#include<cstdio>
#include<iostream>
#define mod 100000007
using namespace std;
int f[1000001],sum,n,m,a[1000001],fac;
inline int add(int x,int y){return x+y>=mod?x+y-mod:x+y;}
inline int dec(int x,int y){return x-y<0?x-y+mod:x-y;}
inline int mul(int x,int y){return 1ll*x*y-1ll*x*y/mod*mod;}
inline int ksm(int x,int y){
	int num=1;
	while (y){
		if (y&1) num=mul(num,x);
		x=mul(x,x); y>>=1;
	}
	return num;
}
int main(){
	scanf("%d%d",&n,&m); sum=1;
	for (int i=1; i<=n; i++) sum=add(sum,sum);
	sum=dec(sum,1); a[0]=1;
	for (int i=1; i<=m; i++) a[i]=mul(a[i-1],dec(sum,(i-1)));
	f[0]=1,f[1]=0; fac=1;
	for (int i=2; i<=m; i++){
		f[i]=dec(dec(a[i-1],f[i-1]),mul(f[i-2],mul(i-1,dec(sum,i-2))));
		fac=mul(fac,i);
	}
	fac=ksm(fac,mod-2);
	printf("%d\n",mul(f[m],fac));
	return 0;
}
```


---

## 作者：楠枫 (赞：0)

## 题解
刚看到题意的时侯很懵，需要蹋下心研读

我是在学校 $OJ$ 状压 $DP$ 中做的这道题，所以我就想用二进制来存储不同的集合

题意可以转化成: 从一个 $\{1,2,3...2^n-1\}$ 的集合中选出 $m$ 个数，使得这 $m$ 个数构成一个**无序**的集合且符合两个条件：  
1. 所选出的几个子集非空，也就是选出的数非零。

2. 所选的 $m$ 个数其异或和为零。

3. 所选的 $m$ 个数中不能有相同的数

有了简化的题意后可以想到要用 $DP$ ， $f_i$ 表示选 $i$ 个数的合法情况数。因为要求异或和为零，所以前 $i-1$ 个数确定后则第 $i$ 个数也就确定了，所以此时**有序**方案数为 $A_{2^n-1}^{i-1}$ 。

但是这时会有不合法的情况，所以要进行处理：  
1. 前 $i-1$ 个数异或和为 $0$ ，所以前 $i-1$ 个数构成了合法情况，此时第 $i$ 个数为 $0$ ，不合法。所以此时不合法情况数即为 $f_{i-1}$

2. 前 $i-1$ 个数中有与第 $i$ 个数相同的，设这个数为第 $j$ 个，那么除去第 $j$ 个和第 $i$ 个数，剩余的即为合法的，为 $f_{i-2}$ ，此时 $j$ 有 $2^n-1-(i+2)$ 种，同时 $j$ 可以有 $i-1$ 个位置，所以不合法情况数为 $f_{i-2}×(2^n-1-(i+2))×(i-1)$

所以我们可以列出总转移方程:
$$
f(x)=\left\{
\begin{aligned}
&f_i=A_{2^n-1}^{i-1} \\
&f_i =f_i-f_{i-1}\\
&f_i=f_i-f_{i-2}×(2^n-1-(i+2))×(i-1)
\end{aligned}
\right.
$$
**注意**，因为我们求的是有序的排列，所以最后还需要除以 $m!$ ，借助逆元。

$AC \kern 0.4emCODE:$
```cpp
#include<bits/stdc++.h>
#define ri register int
#define p(i) ++i
#define int long long
using namespace std;
const int MOD=1e8+7,N=1e6+10;
inline int read() {
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}
	return x*f;
}
int f[N],a[N],n,m,mu;
inline int qpow(int x,int y) {
	int ans=1;
	while(y) {
		if (y&1) ans=ans*x%MOD;
		x=x*x%MOD;
		y>>=1;
	}
	return ans;
}
signed main() {
	n=read(),m=read();
	int tot=qpow(2,n)-1;
	a[0]=f[0]=1;//初始化可以自己手动模拟一下
	for (ri i(1);i<=m;p(i)) a[i]=a[i-1]*((tot-i+1+MOD)%MOD)%MOD;
	for (ri i(2);i<=m;p(i)) {
		f[i]=a[i-1];
		f[i]-=f[i-1];
		f[i]=(f[i]-f[i-2]*(tot-i+2)%MOD*(i-1)%MOD+MOD)%MOD;//记得处理正负
	}
	int k=m;mu=m;
	while(--k) {
		mu=mu*k%MOD;
	}
	printf("%lld\n",f[m]*qpow(mu,MOD-2)%MOD);
	return 0;
}
```

---


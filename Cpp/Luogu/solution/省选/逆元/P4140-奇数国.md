# 奇数国

## 题目描述

在一片美丽的大陆上有 $100\,000$ 个国家，记为 $1$ 到 $100\,000$。这里经济发达，有数不尽的账房，并且每个国家有一个银行。

某大公司的领袖在这 $100\,000$ 个银行开户时都存了 $3$ 大洋，他惜财如命，因此会不时地派小弟 GFS 清点一些银行的存款或者让 GFS 改变某个银行的存款。

该村子在财产上的求和运算等同于我们的乘法运算，也就是说领袖开户时的存款总和为 $3^{100000}$。这里发行的软妹面额是最小的 $60$ 个素数（$p_1=2,p_2=3,\ldots, p_{60}=281$），任何人的财产都只能由这 $60$ 个基本面额表示，即设某个人的财产为 $fortune$（正整数），则 $fortune=p_1^{k_1} \times p_2^{k_2} \times \ldots p_{60}^{k_{60}}$。

领袖习惯将一段编号连续的银行里的存款拿到一个账房去清点，为了避免 GFS 串通账房叛变，所以他不会每次都选择同一个账房。GFS 跟随领袖多年已经摸清了门路,知道领袖选择账房的方式。如果领袖选择清点编号在 $[a,b]$ 内的银行财产，他会先对 $[a,b]$ 的财产求和（记为 $product$），然后在编号属于 $[1,product]$ 的账房中选择一个去清点存款，检验自己计算是否正确同时也检验账房与 GFS 是否有勾结。GFS 发现如果某个账房的编号 $number$ 与 $product$ 相冲，领袖绝对不会选择这个账房。

怎样才算与 $product$ 不相冲呢？若存在整数 $x,y$ 使得 $number \times x+product \times y=1$，那么我们称 $number$ 与 $product$ 不相冲，即该账房有可能被领袖相中。当领袖又赚大钱了的时候，他会在某个银行改变存款，这样一来相同区间的银行在不同的时候算出来的 $product$ 可能是不一样的，而且领袖不会在某个银行的存款总数超过 $10^6$。

现在 GFS 预先知道了领袖的清点存款与变动存款的计划，想请你告诉他，每次清点存款时领袖有多少个账房可以供他选择，当然这个值可能非常大，GFS 只想知道对 $19\,961\,993$ 取模后的答案。

## 说明/提示

### 样例解释

- 初始化每个国家存款都为 $3$；
- $1$ 到 $3$ 的 $product$ 为 $27$，$[1,27]$ 与 $27$ 不相冲的有 $18$ 个数；
- $1$ 的存款变为 $5$；
- $1$ 到 $3$ 的 $product$ 为 $45$，$[1,45]$ 与 $45$ 不相冲的有 $24$ 个数；
- $1$ 的存款变为 $7$；
- $1$ 到 $3$ 的 $product$ 为 $63$，$[1,63]$ 与 $63$ 不相冲的有 $36$个数；
- $2$ 到 $3$ 的 $product$ 为 $9$，$[1,9]$ 与 $9$ 不相冲的有 $6$ 个数。

### 数据范围

所有数据均满足：$x \geq 1$，$c_i -b_i \geq 0$。

| 子任务编号 | 分值 |    $x \leq$     | $c_i - b_i \leq$ | 特殊性质 |
| :--------: | :--: | :-------------: | :--------------: | :------: |
|    $1$     | $20$ |     $10^4$      |      $100$       |    有    |
|    $2$     | $30$ | $5 \times 10^4$ |      $10^4$      |    无    |
|    $3$     | $50$ |     $10^5$      |      $10^5$      |    无    |

特殊性质指：所有 $product \leq 10^{18}$。

## 样例 #1

### 输入

```
6
0 1 3
1 1 5
0 1 3
1 1 7
0 1 3
0 2 3```

### 输出

```
18
24
36
6

```

# 题解

## 作者：Siyuan (赞：11)

[$$\Large\texttt{My Blog}$$](https://hydingsy.github.io/articles/problem-BZOJ-3813-Odd-Number-Country/)


---

## Description

> 题目链接：[Luogu 4140](https://www.luogu.org/problemnew/show/P4140)

在一片美丽的大陆上有 $100000$ 个国家，每个国家有一个银行。某大公司的领袖在这 $100000$ 个银行开户时都存了 $3$ 大洋，他惜财如命，因此会不时地派小弟 GFS 清点一些银行的存款或者让 GFS 改变某个银行的存款。这里发行的软妹面额是最小的 $60$ 个素数，任何人的财产都只能由这 $60$ 个基本面额表示。

领袖习惯将一段编号连续的银行里的存款拿到一个账房去清点。如果领袖选择清点编号在 $[a,b]$ 内的银行财产，他会先对 $[a,b]$ 的财产求和（计为 $\text{product}$），然后在编号属于 $[1,\text{product}]$ 的账房中选择一个去清点存款。一个账房 $\text{number}$ 可能被选中当且仅当 $\gcd(\text{product},\text{number})=1$。当领袖又赚大钱了的时候，他会在某个银行改变存款，但是领袖不会在某个银行的存款总数超过 $10^6$。

现在 GFS 预先知道了领袖的清点存款与变动存款的 $x$ 次计划，想请你告诉他，每次清点存款时领袖有多少个账房可以供他选择，当然这个值可能非常大，GFS 只想知道对 $19961993$ 取模后的答案。

数据范围：$1\le x\le 10^5$

------

## Solution

我们注意到，每个数的标准分解形式中只有可能出现前 $60$ 个数字，那么我们考虑用**线段树**维护区间内**每个质因子是否出现过**（笔者使用压位，用 $\text{long long}$ 储存，操作起来较为简单），并维护**区间内的乘积**。统计答案时，我们只需要求出区间的乘积的 $\varphi$ 函数值即可。

**时间复杂度**：$O(60\cdot m\log n)$

------

## Code

```cpp
#include <cstdio>
#include <algorithm>
#define lson p<<1
#define rson p<<1|1

const int prime[]={2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281};
const int invpr[]={9980997,6653998,11977196,8555140,5444180,1535538,10568114,14708837,3471651,11701858,17386252,1618540,16066970,2321162,18263100,16948862,12518538,15380552,10725847,1686929,13399146,17182475,12025297,15924736,13582387,395287,6395590,15857658,16299242,6359573,3300802,18742940,6702567,10914471,16210746,11765678,5340151,18247466,7769638,8077107,11932588,6506948,1985748,6619521,5877135,4413707,9744480,10115270,14597757,16475182,18334191,5011379,18885205,7555336,621385,11309266,12170137,12006660,18304499,11153142};
const int N=1e5+5;
const int mod=19961993;
int n=100000,m,a[N],mul[N<<2];
long long seg[N<<2];

void pushup(int p) {
	seg[p]=seg[lson]|seg[rson];
	mul[p]=1LL*mul[lson]*mul[rson]%mod;
}
void modify(int x,int p,int l,int r,long long f,int v) {
	if(l==r) {
		seg[p]^=f,mul[p]=v;
		return;
	}
	int mid=(l+r)>>1;
	if(x<=mid) modify(x,lson,l,mid,f,v);
	else modify(x,rson,mid+1,r,f,v);
	pushup(p);
}
long long queryFac(int x,int y,int p,int l,int r) {
	if(x<=l&&r<=y) return seg[p];
	int mid=(l+r)>>1;
	long long ans=0;
	if(x<=mid) ans|=queryFac(x,y,lson,l,mid);
	if(mid<y) ans|=queryFac(x,y,rson,mid+1,r);
	return ans;
}
int queryMul(int x,int y,int p,int l,int r) {
	if(x<=l&&r<=y) return mul[p];
	int mid=(l+r)>>1,ans=1;
	if(x<=mid) ans=1LL*ans*queryMul(x,y,lson,l,mid)%mod;
	if(mid<y) ans=1LL*ans*queryMul(x,y,rson,mid+1,r)%mod;
	return ans;
}
int query(int l,int r) {
	int ans=queryMul(l,r,1,1,n);
	long long f=queryFac(l,r,1,1,n);
	for(int i=0;i<60;++i) {
		if(f&(1LL<<i)) ans=1LL*ans*invpr[i]%mod*(prime[i]-1)%mod;
	}
	return ans;
}
void ins(int x,int val) {
	long long f=0;
	for(int i=0;i<60;++i) {
		if(val%prime[i]==0) f^=1LL<<i;#
	}
	modify(x,1,1,n,f,val);
}
int main() {
	for(int i=1;i<=n;++i) a[i]=3,modify(i,1,1,n,2,a[i]);
	for(scanf("%d",&m);m--;) {
		int o,x,y;
		scanf("%d%d%d",&o,&x,&y);
		if(o==0) {
			printf("%d\n",query(x,y));
		} else {
			ins(x,a[x]),ins(x,a[x]=y);
		}
	}
	return 0;
}
```



---

## 作者：gyh20 (赞：7)

提供一个树状数组+利用欧拉函数性质的做法。

与其他题解不同，我们知道 $φ$ 是一个积性函数，且在 $p^k(k>0)$ 的取值为 $p^{k-1}\times (p-1)$，也就是说，我们只用知道每个数的个数即可，由于质数个数很少，幂次可以预处理，也可以对于每一个质数开一个树状数组单点修改区间求和，时间复杂度 $O(60n\log n)$。

代码比较简单：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define re register
inline int read(){
	re int t=0;re char v=getchar();
	while(v<'0')v=getchar();
	while(v>='0')t=(t<<3)+(t<<1)+v-48,v=getchar();
	return t;
}
const int M=19961993;
int n,m,a[400002],c[61][400002],pw[61][400002],p[61]={0,2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281};
inline void add(re int x,re int y,re int z){for(;y<=n;y+=y&(-y))c[x][y]+=z;}
inline int ask(re int x,re int y){
	re int s=0;
	for(;y;y-=y&(-y))s+=c[x][y];
	return s;
}
char s[12];
signed main(){
	n=read(),m=read();
	for(re int y=1;y<=n;++y){
		a[y]=read();
		for(re int i=1;i<=60;++i){
			re int sum=0,tmp=a[y];
			while(tmp%p[i]==0)tmp/=p[i],++sum;
			if(sum)add(i,y,sum);
		}
	}
	for(re int i=1;i<=60;++i)for(re int j=pw[i][0]=1;j<=n;++j)pw[i][j]=1ll*pw[i][j-1]*(j>1?p[i]:(p[i]-1))%M;
	while(m--){
		scanf("%s",s+1);
		re int y=read(),z=read();
		if(s[1]=='T'){
			re int ans=1;
			for(re int i=1;i<=60;++i)ans=1ll*ans*pw[i][ask(i,z)-ask(i,y-1)]%M;
			printf("%d\n",ans);
		}
		else{
			for(re int i=1;i<=60;++i){
				re int sum=0,tmp=a[y];
				while(tmp%p[i]==0)tmp/=p[i],++sum;
				if(sum)add(i,y,-sum);
			}
			a[y]=z;
			for(re int i=1;i<=60;++i){
				re int sum=0,tmp=a[y];
				while(tmp%p[i]==0)tmp/=p[i],++sum;
				if(sum)add(i,y,sum);
			}
		}
	}
}

```


---

## 作者：Surge_of_Force (赞：3)

感觉自己在做这道题的时候思路不是很清晰，特此来写篇题解，~~同时造福社会~~。

### 1.题意
读完题，我们可以发现：~~题面全是废话~~，因为 $ax+by=1$ 有解等价于 $\gcd(a,b)=1$，所以题目要求的操作的实际上就是：

- 求 $\varphi(\prod_{i=l}^r a_i)$
- $a_x\longleftarrow y$

### 2.做法

区间操作，很容易想到线段树，累乘好办，但是欧拉函数怎么求呢？区间累乘极限情况下可以达到 $(10^6)^{10^5}$，没有任何变量类型存的下，也根本不可能直接算。

我们观察一下 $O(\sqrt n)$ 求 $\varphi(n)$ 的表达式：

$n\times\prod_{i=1}^k \frac{P_i-1}{P_i}$

可以发现 $\varphi(n)$ 只与 $n$ 含有哪些质因子有关，而与它们的个数无关，而这题又保证所有的 $a_i$ 都至多含有前 $60$ 个质数作为质因子，所以可以考虑状压维护区间累乘的质因子。

那么解法就很明显了：开一个线段树，维护区间乘积（$mul$），然后用一个 $w$ 来存 $mul$ 的质因子（若 $mul$ 含有第 $i$ 个质数这个质因子，那么 $w$ 二进制的第 $i$ 位就是 $1$）。

一点小优化：由于质数的范围很小（只有前 $60$ 个），我们可以提前把它们以及它们 $\bmod\ 19961993$ 意义下的逆元预处理出来，这样可以砍掉一只 $\log$，最后总的复杂度是 $O(m\log n)$。

### 3.一些坑点
总结一下我做这题时遇到的一些坑点：

- 注意取模
- 状压要开 `long long`
- 建树时是 `build(1,100000,1)` 而不是 `build(1,x,1)`

附上 `ACcode`：
```cpp
//状压+线段树+数学 
#include<bits/stdc++.h>
#define ll long long
#define lc(k) k<<1
#define rc(k) k<<1|1
#define int long long
using namespace std;
const int MAX=1e5+10;
const int MOD=19961993;
inline int read() {
  int fh = 1, res = 0; char ch = getchar();
  for(; !isdigit(ch); ch = getchar()) if(ch == '-') fh = -1;
  for(; isdigit(ch); ch = getchar()) res = (res << 3) + (res << 1) + (ch ^ '0');
  res = res * fh;
  return res;
}
inline void write(ll x) {
    if(x<0){putchar('-');x=-x;}
    if(x>9) write(x/10);
    putchar(x%10+'0');
}
int pri[61]={0,2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281};
int inv[61]={0,9980997,6653998,11977196,8555140,5444180,1535538,10568114,14708837,3471651,11701858,17386252,1618540,16066970,2321162,18263100,16948862,12518538,15380552,10725847,1686929,13399146,17182475,12025297,15924736,13582387,395287,6395590,15857658,16299242,6359573,3300802,18742940,6702567,10914471,16210746,11765678,5340151,18247466,7769638,8077107,11932588,6506948,1985748,6619521,5877135,4413707,9744480,10115270,14597757,16475182,18334191,5011379,18885205,7555336,621385,11309266,12170137,12006660,18304499,11153142};
struct node{int l,r,mul;ll w;}a[MAX<<2];
ll ans=0,ans2=1;
int phi(int x)
{
	int ret=ans2;
	for(int i=1;i<=60;i++)
		if(x&(1ll<<i)) 
			ret=(((ret*inv[i])%MOD)*(pri[i]-1))%MOD;
	return ret;
}
void push_up(int k)
{
	a[k].mul=(a[lc(k)].mul*a[rc(k)].mul)%MOD;
	a[k].w=a[lc(k)].w|a[rc(k)].w;
	return ;
}
void build(int l,int r,int k)
{
	a[k].l=l;a[k].r=r;
	if(l==r)
	{
		a[k].w=1ll<<2;
		a[k].mul=3;
		return ;
	}
	int mid=(l+r)>>1;
	build(l,mid,lc(k));
	build(mid+1,r,rc(k));
	push_up(k);
	return ;
}
void ask(int l,int r,int k)
{
	if(a[k].l>=l&&a[k].r<=r)
	{
		ans2=(ans2*a[k].mul)%MOD;
		ans|=a[k].w;return ;
	}
	int mid=(a[k].l+a[k].r)>>1;
	if(l<=mid) ask(l,r,lc(k));
	if(mid+1<=r) ask(l,r,rc(k));
	return ;
}
void change(int x,int z,int k)
{
	if(a[k].l==a[k].r)
	{
		a[k].w=0;a[k].mul=z;
		for(int i=1;i<=60;i++)
			a[k].w|=((a[k].mul%pri[i]==0)*1ll<<i);
		return ;
	}
	int mid=(a[k].l+a[k].r)>>1;
	if(x<=mid) change(x,z,lc(k));
	else change(x,z,rc(k));
	push_up(k);
	return ;
}
signed main()
{
	int m=read(),n=MAX-10;
	build(1,n,1);
	while(m--)
	{
		int opt=read(),x=read(),y=read();
		if(opt==0)
		{
			ans=0;ans2=1;ask(x,y,1);
			printf("%lld\n",phi(ans));
		}
		else change(x,y,1);
	}
	return 0;
}
```

完结撒花ヽ(￣▽￣)ﾉ

---

## 作者：Arcturus1350 (赞：3)

首先，按照题意，把前$60$个素数打出来$[2$ $-$ $281]$。

因为只有$60$个，再加上本宝宝极其懒得写线性筛于是每一个都$O(\sqrt{n})$暴力筛就好了。

代码如下：

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
int n;
int main()
{
//	freopen("1.txt","w",stdout);
	printf("0");//格式问题，以自己爱好稍作更改。
	for(int i=2;i<=281;i++)
	{
		for(int j=2;j*j<=i;j++)
		  if(i%j==0) goto rp;
		printf(",%d",i),n++;
		rp:; 
	}
	return 0;
}
```

如果我们用$prime[i]$表示第i个素数。
筛出来是这样的：
```cpp
int prime[61]={
	0,2,3,5,7,11,13,17,19,
	23,29,31,37,41,43,47,
	53,59,61,67,71,73,79,
	83,89,97,101,103,107,
	109,113,127,131,137,
	139,149,151,157,163,
	167,173,179,181,191,
	193,197,199,211,223,
	227,229,233,239,241,
	251,257,263,269,271,
	277,281
};

```

---

之后，我们看 清点存款 操作，

问$[1,product]$里，有多少个$num$满足：

$$num*x+product*y=1$$

这，与我们 素数的性质 好像啊。

这就是 $num*x≡1$ $ $ $ $ $(mod$ $ $ $product)$

也就是 $gcd(num$ $,$ $product)$ $=$ $1$

嗯，好，问题转化成了：

求 $[1,product]$ 里，有多少个 $num$ 与 $product$ 互质。

也就是 $\varphi(product)$ 等于多少。

之后，根据欧拉函数的通式。

$$\varphi(n)=n*\prod_{p_i|n}(1-\frac{1}{p_i})=n*\prod_{p_i|n}\frac{p_i-1}{p_i}$$

看数据范围，又让 $mod$ $ $ $p$

所以，

再线性推一下逆元,

求解即可。

---

$ps:$ 如果脸黑被卡常数了的话，可以把 $[1-281]$ 的逆元打表。

大概代码是这样的：
```cpp
    pni[1]=1;
	for(int i=2;i<=281;i++)
	pni[i]=(long long)(mod-mod/i)*pni[mod%i]%mod;
```

---

下面，就是区间维护。

题目中说了，~~（在出题人眼里）~~他们的加法相当于我们的乘法。

我们要维护区间 $[a,b]$ 的 “和” 记为 $product$

更改的是某个点（银行）$b_{i}$ 的存款

### 显然的线段树保存每段区间出现的质因子。

看题面，由于最多出现$60$个质数，我们用一个 $long$ $ $ $long$ 的每一位表示一个质数，然后用或运算$xor$即可实现 “加和” 相乘操作。

然后就……

好好的写代码吧。

不过……

模数为啥不是 $19260817$ 或者是 $998244353$ 或 $64123$ 呢……

---

$ps:$ 一定要看看线段树每次的区间边上判定 $!$ $!$ $!$

本宝宝调了两天 $……$

委屈巴巴。。。

---

上代码：

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
#define mod 19961993

const int prime[61]={
	0,2,3,5,7,11,13,17,19,
	23,29,31,37,41,43,47,
	53,59,61,67,71,73,79,
	83,89,97,101,103,107,
	109,113,127,131,137,
	139,149,151,157,163,
	167,173,179,181,191,
	193,197,199,211,223,
	227,229,233,239,241,
	251,257,263,269,271,
	277,281
};//记录质数。 

int pni[300];

	//线段树。
	struct data{
		long long sum;//区间（和）乘积 
		long long p;//包含哪些素数。第i个二进制位如果是1，则有prime[i]这个素数,从1开始。 
	}point[400010];
	data ans;//记录查询答案。
	
	void built(int l,int r,int o)
	{
		if(l==r) {point[o].sum=3;point[o].p=2;return ;}
		int mid=(l+r)/2;
		built(l,mid,o*2);
		built(mid+1,r,o*2+1);
		
	//	printf("%d %d %d %d\n",l,r,o,mid);
		
		point[o].sum=point[o*2].sum*point[o*2+1].sum%mod;
		point[o].p=2;
	// 	printf("%d %d\n",point[o].sum,point[o].p);
	}
	
	void chang(int l,int r,int o,const int t,const int k)//第t个点改为k 
	{
//		printf("%d %d %d %d %d\n",&l,&r,&o,&t,&k);
		if(l==r){
			point[o].sum=k;
			long long p=0;
			for(int i=1;i<=60;i++){
				if((k%prime[i])==0) p|=1LL<<(i-1);
				point[o].p=p;
			}
			return ;
		}
		int mid=(l+r)/2;
		if(t<=mid) chang(l,mid,o*2,t,k);
		else chang(mid+1,r,o*2+1,t,k);
		point[o].sum=point[o*2].sum*point[o*2+1].sum%mod;
		point[o].p=point[o*2].p|point[o*2+1].p;
	}
	
	void quest(int l,int r,int o,int l1,int r1)//查询L到R。 
	{
		if(l1<=l&&r<=r1){
			ans.sum=ans.sum*point[o].sum%mod;
			ans.p|=point[o].p;
			return ;
		}
		int mid=(l+r)/2;
		if(l1<=mid) quest(l,mid,o*2,l1,r1);
		if(mid<r1)  quest(mid+1,r,o*2+1,l1,r1);
	} 
//	void debug()
//	{
//		for(int i=1;i<=100;i++)
//		printf("%d %d %d\n",i,point[i].p,point[i].sum);
//	}

int main()
{

//	freopen("1.in","r",stdin);
//	freopen("1.out","w",stdout);
	built(1,100000,1);

	pni[1]=1;
	for(int i=2;i<=281;i++)
	pni[i]=(long long)(mod-mod/i)*pni[mod%i]%mod;
	//线性筛逆元 

	int tt;
	scanf("%d",&tt);
	while(tt--)
	{
		int x;scanf("%d",&x);
	
		if(x)
		{
		int t,k;
		scanf("%d%d",&t,&k);
		chang(1,100000,1,t,k);
		}
	
		else
		{
			int l1,r1;
			ans.sum=1;
			ans.p=0;
			scanf("%d%d",&l1,&r1);
			quest(1,100000,1,l1,r1);
		
			long long f=ans.sum;
			for(int i=1;i<=60;i++)//计算φ 
			if(ans.p&(1LL<<(i-1))) f=f*(prime[i]-1)%mod,f=f*pni[prime[i]]%mod;
			printf("%d\n",(int)f);
		
		}
//		debug();
	}
	return 0;//程序拜拜
}

```


---

## 作者：封禁用户 (赞：2)

题目的意思其实就是：

** 求区间积的欧拉函数 **

欧拉函数是什么呢？

下面给出公式：

$\phi(n)=n(1-\frac{1}{p1})(1-\frac{1}{p2})...(1-\frac{1}{pi})$

其中pi表示n的各个不同的质因子。

因为题目中说最多有60个质数，

所以只要把60个质数压到
一个```long long```的数组状态里即可

然后用单点修改的线段树维护区间积，质因子即可。

最后利用上面的公式输出就好了

下面是代码：

```cpp
//抄代码者会后悔的。
//你最好自己推质数和逆元表哼哼哼哼
#include<cstdio>
#define mod 19960883
using namespace std;
const long long prime[]={2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,199,199,211,223,227,229,233,239,241,251,257,263,269,270,274,280,289};
//打下了前60个质数
const long long ny[]={9980980,1323998,11977196,8555140,5444180,1535538,10568114,14708837,3471651,11701858,17386252,1618540,16066970,2321162,18263100,16948862,12518538,15380552,10725847,1686929,13399146,17182475,120212397,15924736,13582387,395287,6395590,15857658,16299242,6359573,3300802,187412312,6702567,10914471,16210746,11765678,5340151,18247466,7712338,8077107,11932588,6506948,1985748,6619521,5877135,4413707,9744480,10115270,14597757,16475182,18334191,5011379,18885205,7555336,621385,11309266,12170137,12006660,18304499,11153142};
//打下了前60个质数的逆元
int n,flag,x,y;
long long rar[1000005],tree[1000005];
void build(int l,int r,int root){
    rar[root]=2;
    if (l==r){
        tree[root]=3;
        return;
    }
    int mid=l+r>>1;
    build(l,mid,root<<1);build(mid+1,r,root<<1|1);
    tree[root]=tree[root<<1]*tree[root<<1|1]%mod;
}
void update(int l,int r,int root,int key,int v){
    if (l==r){
        long long now=0;
        for (int i=0;i<60;i++) if (!(v%prime[i])) now|=(1ll<<i);
        rar[root]=now;tree[root]=v;
        return;
    }
    int mid=l+r>>1;
    if (key<=mid) update(l,mid,root<<1,key,v);else update(mid+1,r,root<<1|1,key,v);
    rar[root]=rar[root<<1]|rar[root<<1|1];
    tree[root]=tree[root<<1]*tree[root<<1|1]%mod;
}
long long query(int l,int r,int root,int L,int R,long long &x){
    if (l>R||r<L||l>r) return 0;
    if (L<=l&&r<=R){
        x=x*tree[root]%mod;
        return rar[root];
    }
    int mid=l+r>>1;
    return query(l,mid,root<<1,L,R,x)|query(mid+1,r,root<<1|1,L,R,x);
}
long long calc(long long x,long long y){
    long long ans=x;
    for (int i=0;i<60;i++) if (y&(1ll<<i)) ans=ans*ny[i]%mod*(prime[i]-1)%mod;
    return ans;
}
//利用公式求解
int main(){
    scanf("%d",&n);
    build(1,100000,1);
    //线段树操作
    for (int i=1;i<=n;i++){
        scanf("%d%d%d",&flag,&x,&y);
        if (flag) update(1,100000,1,x,y);else{
            long long Calc=1;
            long long sum=query(1,100000,1,x,y,Calc);
            printf("%lld\n",calc(Calc,sum));
        }
    }
    return 0;
}
```

---

## 作者：winxp_qwq (赞：2)

首先，这道题是一道语文阅读题，描述需要好好看一下才能看懂。

注意到查询的是欧拉函数，我们如果知道乘积的素因数分解，就可以根据公式轻松搞出来。（求的时候需要卡速米）

然后考虑如何维护一段数的积的素因子分解。注意到它们的素因子只有至多60个，因此我们可以开60个树状数组，对每个树状数组维护这个素数在每个数中的次数，查询的时候区间求和就好。

注意初始全为3。

素数的话，暴求就行。

```cpp
// luogu-judger-enable-o2
#include <bits/stdc++.h>
#define LL long long
using namespace std;
#define mod 19961993
#define maxn 100233
LL p[62],tt=0;
LL bit[62][maxn];
LL num[maxn];
LL lowbit(LL a) {return (-a)&a;}
void add(LL x,LL a,LL b) {
	for(;a<=100000;a+=lowbit(a))
	bit[x][a]+=b;
}
LL qu(LL x,LL a) {
	LL ans=0;
	for(;a;a-=lowbit(a)) 
	ans+=bit[x][a];
	return ans;
}
LL kasumi(LL a,LL b) {
	LL ans=1;
	while(b) {
		if(b&1) ans=ans*a%mod;
		a=a*a%mod;
		b/=2;
	}
	return ans;
}
LL gao(LL a,LL b) {
    LL ret=0;
    while(a%p[b]==0) {
		a/=p[b];
		ret++;
	}
	return ret;
}
int main(){
	LL m,n=100000,a,b,c,i,j,k,op,ans;
	for(a=2;a<=281;a++) {
		j=0;
		for(b=2;b<a;b++) 
		if(a%b==0) j=1;
		if(j==0) p[++tt]=a;
	}
	for(a=1;a<=n;a++) add(2,a,1);
	for(a=1;a<=n;a++) num[a]=3;
	scanf("%lld",&m);
	for(a=1;a<=m;a++) {
		scanf("%lld%lld%lld",&op,&i,&j);
		if(op==0) {
			ans=1;
			for(b=1;b<=60;b++) {
				c=qu(b,j)-qu(b,i-1);
				if(c>0) {
					ans*=kasumi(p[b],c-1);
					ans%=mod;
					ans*=(p[b]-1);
					ans%=mod;
				}
			}
			printf("%lld\n",ans);
		}
		else {
			for(b=1;b<=60;b++)
			if(c=gao(num[i],b)) add(b,i,-c);
			for(b=1;b<=60;b++)
			if(c=gao(j,b)) add(b,i,c);
			num[i]=j;
		}
	}
	return 0;
}
```

---

## 作者：Buried_Dream (赞：1)

## 题意转换：

有两种操作：

操作一： 将 $a_i$ 变成 $x$。

操作二： 求出 $\varphi({\prod_{i=l}^{r}a_i})$。

## Solution:

我们考虑用线段树来维护。

我们不可能求出这个连乘后再求他的欧拉函数值。

但是题目有一个性质，保证只有前 $60$ 个素数为因子。

再联想到求欧拉函数的公式: $\varphi(x) = x \times \prod \frac{P_i-1}{P_i}$。

发现这个式子只与他有没有这个因子有关，而与个数无关。

于是我们考虑状压，二进制下第 $i$ 位 $1$ 表示有这个因子，$0$ 表示没有这个因子。

在线段树里，我们维护两个值，一个是连乘，一个状压后表示是否有这个因子的数 $W$。

更新节点信息的时候，他的连乘等于左右儿子的连乘，$W$ 就用左右儿子的 $W$ 或起来就行了。

```cpp
/**
 *	author: TLE_Automation
 *	creater: 2022.7.23
**/
#include<cmath>
#include<queue>
#include<cstdio>
#include<bitset>
#include<cstring>
#include<iostream>
#include<algorithm>
#define gc getchar 
using namespace std;
typedef long long ll;
#define int long long
const int N = 1e6 + 10;
const int MAXN = 2e5 + 10;
const int mod = 19961993;
const int INF = 0x3f3f3f3f;
const ll inf = 0x3f3f3f3f3f3f3f3f;
inline int gcd(int a, int b) {return !b ? a : gcd(b, a % b);}
inline void print(int x) {if (x < 0) putchar('-'), x = -x; if(x > 9) print(x / 10); putchar(x % 10 + '0');}
inline int ksm(int a, int b) {int base = a % mod, res = 1; while(b){if(b & 1) res = (res * base) % mod; base = (base * base) % mod, b >>= 1;}return res % mod;}
inline int mul(int a, int b) {int base = a % mod, res = 0; while(b){if(b & 1) res = (res + base) % mod; base = (base + base) % mod, b >>= 1;}return res % mod;}
inline char readchar() {static char buf[100000], *p1 = buf, *p2 = buf; return p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 100000, stdin), p1 == p2) ? EOF : *p1++;}
inline int read() { int res = 0, f = 0; char ch = gc();for (; !isdigit(ch); ch = gc()) f |= (ch == '-'); for (; isdigit(ch); ch = gc()) res = (res << 1) + (res << 3) + (ch ^ '0'); return f ? -res : res;}
const int Pri[100] = {0, 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293,};
const int inv[100] = {0, 9980997, 6653998, 11977196, 8555140, 5444180, 1535538, 10568114, 14708837, 3471651, 11701858, 17386252, 1618540, 16066970, 2321162, 18263100, 16948862, 12518538, 15380552, 10725847, 1686929, 13399146, 17182475, 12025297, 15924736, 13582387, 395287, 6395590, 15857658, 16299242, 6359573, 3300802, 18742940, 6702567, 10914471, 16210746, 11765678, 5340151, 18247466, 7769638, 8077107, 11932588, 6506948, 1985748, 6619521, 5877135, 4413707, 9744480, 10115270, 14597757, 16475182, 18334191, 5011379, 18885205, 7555336, 621385, 11309266, 12170137, 12006660, 18304499, 11153142, 6348337, 9878802, };

int W, res;

ll Getphi() {
	int ret = res;
	for(int i = 1; i <= 60; i++) {
		if(W & (1ll << i)) 
			ret = ((((ret * (Pri[i] - 1) % mod) * inv[i]) % mod)) % mod;
	}	
	return ret;
}

namespace Seg {
	#define lson rt << 1 
	#define rson rt << 1 | 1
	struct Node {int l, r, mul, val; } tree[N << 2];
	void pushup(int rt) {
		tree[rt].mul = (tree[lson].mul * tree[rson].mul) % mod;
		tree[rt].val = (tree[lson].val | tree[rson].val);
	}
	void build(int rt, int l, int r) {
		tree[rt].l = l, tree[rt].r = r;
		if(l == r) return tree[rt].mul = 3, tree[rt].val = (1ll	<< 2), void();
		int mid = (l + r) >> 1; build(lson, l, mid), build(rson, mid + 1, r);
		pushup(rt);
	}
	void change(int rt, int x, int k) {
		if(tree[rt].l > x || tree[rt].r < x) return;
		if(tree[rt].l == tree[rt].r) {
			tree[rt].mul = k, tree[rt].val = 0;
			for(int i = 1; i <= 60; i++)
				tree[rt].val |= ((tree[rt].mul % Pri[i] == 0) * (1ll << i));
			return;
		} change(lson, x, k), change(rson, x, k); pushup(rt);
	}		
	void Query(int rt, int l, int r) {
		if(tree[rt].l > r || tree[rt].r < l) return;
		if(tree[rt].l >= l && tree[rt].r <= r) {
			res = (res * tree[rt].mul) % mod;
			W |= tree[rt].val; return;
		} Query(lson, l, r), Query(rson, l, r);
	}
}
using namespace Seg;

signed main() 
{
	int n = read();
	build(1, 1, 1e5);
	for(int i = 1; i <= n; i++) {
		int opt = read(), x = read(), y = read();
		if(!opt) {
			W = 0, res = 1;
			Query(1, x, y);
//			cout << res << "\n";
			printf("%lld\n", Getphi());
		}
		else change(1, x, y);
	}
	return 0;
}
```

---

## 作者：SevenDawns (赞：1)

## [博客地址](https://www.cnblogs.com/huangchenyan/p/11279111.html)

# 线段树+数论
看完这么一长串题目，现将有用的信息提取出来

首先$number*x+product*y=1$这个条件

如果要使$x$,$y$有解，那么$number$和$product$必须满足$\gcd (number,product)=1$

那么将询问操作转化为求出$[1,product]$中有多少个数与$product$互质

那么这个就是求$\varphi (product)$

因为欧拉函数的通项公式$\varphi (x)=x\prod_{i=1}^{k}(1-\frac{1}{p_{i}})$，p为x的质因数

观察题目，题目保证所有的钱都是由前60个素数相乘得到的

那么只要求出$product$就能通过逆元求出答案，19961993是质数，那么费马小定理即可

因为求$product$是区间的操作，所以用线段树维护每个银行的所存钱数

在线段树中要记录区间的乘积和当前区间出现的质数

因为只有60个质数，可以状压到一个long long中保存

那么pushup时也方便，直接将左儿子和右儿子的状态或运算即可

那么接下来的问题就是线段树单点修改，区间询问求出$product$了

最后要注意开long long时，常数也要转成long long（查这个查了一个小时）
```cpp
#include <bits/stdc++.h>
#define mod (long long)19961993
using namespace std;
const long long MAXN=100100;
long long n,p[61],w,in[61];
struct node
{
    long long l,r;
    long long mask,mul;
}sh[MAXN*4];
bool check(long long x)//判断质数
{
    for (long long i=2;i*i<=x;i++)
    {
        if (x%i==0)
          return false;
    }
    return true;
}
long long split(long long x)//质因数分解
{
    long long m=0;
    for (long long i=0;i<w;i++)
    {
        if (x%p[i]==0)
          m|=(1ll<<i);//注意
    }
    return m;
}
long long m_pow(long long a,long long b)
{
    long long ans=1;
    while (b>0)
    {
        if (b&1)
          ans=(ans*a)%mod;
        a=(a*a)%mod;
        b>>=1;
    }
    return ans%mod;
}
long long inv(long long x)//用费马小定理求出逆元
{
    return m_pow(x,mod-2)%mod;
}
void pushup(long long x)
{
    sh[x].mul=(sh[x+x].mul*sh[x+x+1].mul)%mod;
    sh[x].mask=sh[x+x].mask|sh[x+x+1].mask;
}
void build(long long x,long long ll,long long rr)
{
    sh[x].l=ll;
    sh[x].r=rr;
    if (ll==rr)
    {
        sh[x].mul=(long long)3;//注意
        sh[x].mask=split((long long)3);
        return;
    }
    long long mid;
    mid=(ll+rr)>>1;
    build(x+x,ll,mid);
    build(x+x+1,mid+1,rr);
    pushup(x);
}
void change(long long x,long long wh,long long v)//线段树单点修改
{
    if (sh[x].l==wh && sh[x].r==wh)
    {
        sh[x].mul=v;
        sh[x].mask=split(v);
        return;
    }
    long long mid;
    mid=(sh[x].l+sh[x].r)>>1;
    if (wh<=mid)
      change(x+x,wh,v);
    else
      change(x+x+1,wh,v);
    pushup(x);
}
long long query1(long long x,long long ll,long long rr)//查找乘积
{
    if (sh[x].l>=ll && sh[x].r<=rr)
      return sh[x].mul;
    long long mid;
    long long ans=1;
    mid=(sh[x].l+sh[x].r)>>1;
    if (ll<=mid)
      ans=(ans*query1(x+x,ll,rr))%mod;
    if (rr>mid)
      ans=(ans*query1(x+x+1,ll,rr))%mod;
    pushup(x);
    return ans;
}
long long query2(long long x,long long ll,long long rr)//查找区间质数出现情况
{
    if (sh[x].l>=ll && sh[x].r<=rr)
      return sh[x].mask;
    long long mid;
    long long ma=0;
    mid=(sh[x].l+sh[x].r)>>1;
    if (ll<=mid)
      ma=ma|query2(x+x,ll,rr);
    if (rr>mid)
      ma=ma|query2(x+x+1,ll,rr);
    pushup(x);
    return ma;
}
int main()
{
    scanf("%lld",&n);
    for (long long i=2;i<=281;i++)
    {
        if (check(i))
        {
            p[w]=i;//预处理出前60个素数
            w++;
        }
    }
    for (int i=0;i<w;i++)
      in[i]=inv(p[i]);//及其逆元
    build(1,1,100000);
    while (n--)
    {
        long long a,b,c;
        scanf("%lld%lld%lld",&a,&b,&c);
        if (a==0)
        {
            long long pro,m;
            long long tot=1;
            pro=query1(1,b,c);
            m=query2(1,b,c);
            for (long long i=0;i<w;i++)
            {
                if ((m>>i)&1)
                  tot=(tot*(p[i]-1)%mod)*in[i]%mod;//欧拉函数通项公式
            }
            printf("%lld\n",(pro*tot)%mod);
        }
        else
        {
            change(1,b,c);
        }
    }
}
```


---

## 作者：Jayun (赞：1)

# 链接：

[题目](https://www.luogu.com.cn/problem/P4140)

[博客园](https://www.cnblogs.com/GJY-JURUO/p/14316453.html)

# 题目大意：

有 $10^5$ 个数，一开始都是 $3$，现在有两个操作：

1. 给定区间 $[l,r]$，求它的积的欧拉函数值。

2. 将第 $x$ 个数改为 $y$。

结果对 $19961993$ 取模。

# 正文：

本题的难点在于怎么求出 $\varphi(product)$。

题目中特意提示了：

>这里发行的软妹面额是最小的 $60$ 个素数 $(p_1=2,p_2=3,\cdots,p_{60}=281)$，任何人的财产都只能由这 $60$ 个基本面额表示。

也就说，我们可以通过枚举质因子的那个公式求解：

$$\varphi(n)=n\prod_{i|n}\left(1-\frac{1}{p_i}\right)$$

我们可以通过线段树维护区间积求解出 $product$，但是它的质因数呢？

仍然用线段树维护。因为至多 $60$ 个，我们就能用状压了。

如果先把质数和逆元预处理好，那么求解 $\varphi$ 值的时间复杂度就是 $O(60)$ 了。

# 代码：

```cpp
const ll mod = 19961993;
const ll pri[] = {2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281};
const ll inv[] = {9980997,6653998,11977196,8555140,5444180,1535538,10568114,14708837,3471651,11701858,17386252,1618540,16066970,2321162,18263100,16948862,12518538,15380552,10725847,1686929,13399146,17182475,12025297,15924736,13582387,395287,6395590,15857658,16299242,6359573,3300802,18742940,6702567,10914471,16210746,11765678,5340151,18247466,7769638,8077107,11932588,6506948,1985748,6619521,5877135,4413707,9744480,10115270,14597757,16475182,18334191,5011379,18885205,7555336,621385,11309266,12170137,12006660,18304499,11153142};

int m;
int n = 100000;

struct SegmentTree
{
	struct Seg
	{
		int l, r;
		ll val, pri;
	}t[N << 2];
	
	void build (int p, int l, int r)
	{
		t[p].l = l, t[p].r = r;
		if (l == r)
		{
			t[p].val = 3, t[p].pri = 2;
			return ;
		}
		int mid = t[p].l + t[p].r >> 1;
		build (p << 1, l, mid);
		build (p << 1 | 1, mid + 1, r);
		t[p].val = t[p << 1].val * t[p << 1 | 1].val % mod;
		t[p].pri = t[p << 1].pri | t[p << 1 | 1].pri;
	}
	void change (int p, int x, ll val, ll P)
	{
		if (t[p].l == t[p].r)
		{
			t[p].val = val, t[p].pri = P;
			return ;
		}
		int mid = t[p].l + t[p].r >> 1;
		if (t[p].l <= x && x <= mid) change (p << 1, x, val, P);
		if (mid + 1 <= x && x <= t[p].r) change (p << 1 | 1, x, val, P);
		t[p].val = t[p << 1].val * t[p << 1 | 1].val % mod;
		t[p].pri = t[p << 1].pri | t[p << 1 | 1].pri;
	}
	
	ll query (int p, int l, int r, int opt)
	{
		if (l <= t[p].l && t[p].r <= r)
			return opt? t[p].val: t[p].pri;
		int mid = t[p].l + t[p].r >> 1;
		ll ans = opt;
		if (l <= mid) ans = opt? ans * query(p << 1, l, r, opt) % mod: ans | query(p << 1, l, r, opt);
		if (mid < r) ans = opt? ans * query(p << 1 | 1, l, r, opt) % mod: ans | query(p << 1 | 1, l, r, opt);
		return ans;
	}
}t;

ll con(ll x)
{
	ll tmp = 0;
	for (ll i = 0; i < 60; i++)
		if(!(x % pri[i])) tmp |= (1ll << i);
	return tmp;
}

int main()
{
	scanf ("%d", &m);
	t.build(1, 1, n);
	while (m--)
	{
		int opt;
		ll x, y;
		scanf ("%d%lld%lld", &opt, &x, &y);
		if (opt == 1) t.change(1, (int)x, y, con(y));
		else 
		{
			ll tmp = t.query(1, (int)x, (int) y, 0);
			ll ans = t.query(1, (int)x, (int) y, 1);
			for (ll i = 0; i < 60; i++)
				if(tmp & (1ll << i)) 
					ans = (ans * inv[i]) % mod, ans = ans * (pri[i] - 1) % mod;
			printf("%lld\n", ans);
		}
	}
	return 0;
}
```

---

## 作者：_Imaginary_ (赞：1)

首先，这道题目我 debug 用了 15 天。（毫不夸张）

## 思路讲解

首先，让我们看看数据范围：$10^5$ 。我们想到了什么复杂度？

没错，$O(nlogn)$ ！

好，接下来让我们读读题吧。$number \times x\ +\ product \times\ y\ =1$ ，说明 $\gcd(number,product)=1$ .

所以，问题转化成：

- 一堆数，全是3 。
- 操作 1 ：修改一个数。**（单点修改）**
- 操作 2 ：查出连续的几个数的乘积 $p$ ，求出 $[1,p]$ 中 $\gcd(x,p)=1$ 的 $x$ 。**（区间查询）**

让我们来找找 $log$ 复杂度的算法中支持这些操作的算法：线段树！

线段树是一个细节贼多的算法（否则 15 天痛苦的 debug 之路怎么出来……）。

对于操作 2 ，我们可以想到欧拉函数。
$$
φ(x)=(1-\frac{1}{p_1})(1-\frac{1}{p_2})……(1-\frac{1}{p_k}), x=p_1^{a_1}\times p_2^{a_2}\times …… \times p_k^{a_k}
$$
也就是我们要求 $φ(p)$ .

所以，我们只要维护每个数的质因子。最多 $60$ 个不同的，可以用 $\operatorname{long long}$ 搞定。

## 代码实现

首先，先讲几个花费了我至少 1 天才调出来的 bug ：

1. 一开始 build 时需要从 $1$ 到 $100000$ 而不是 $1$ 到 $n$ 。

2.  移位要用 `1ll<<x` 不能用 `1<<x` 。

接着，送上较为丑陋的代码：

```c++
#include<bits/stdc++.h>
using namespace std;
#define P 19961993
const int maxn=100005;
const int pri[70]={表格内容被和谐了，请自己打前60个素数};
const int inv[70]={表格内容被和谐了，请打前60个素数的逆元};
int pro[maxn<<2],a[maxn];
long long val[maxn<<2];
int n=100000;
void push_up(int rt)
{
	pro[rt]=1ll*pro[rt*2]*pro[rt*2+1]%P;
	val[rt]=val[rt*2]|val[rt*2+1];
}
void build(int l,int r,int rt,int x,int v,long long f)
{
//	printf("%d %d %d %d\n",l,r,rt,mid);
	if(l==r)
	{
		val[rt]^=f;
		pro[rt]=v;
		return;
	}
	int mid=(l+r)/2;
	if(x<=mid) build(l,mid,rt*2,x,v,f);
	else build(mid+1,r,rt*2+1,x,v,f);
	push_up(rt);
}

long long query_val(int l,int r,int rt,int ql,int qr)
{
//	if(l>qr||r<ql||l>r) return 0;
	if(ql<=l&&r<=qr)
	{
//		x=x*pro[rt]%P;
		return val[rt];
	}
	long long ans=0;
	int mid=(l+r)/2;
	if(ql<=mid) ans|=query_val(l,mid,rt*2,ql,qr);
	if(qr>mid) ans|=query_val(mid+1,r,rt*2+1,ql,qr);
	return ans;
}
int query_pro(int l,int r,int rt,int x,int y)
{
//	printf("%d %d %d %d\n",l,r,rt,pro[rt]);
	if(x<=l&&r<=y) return pro[rt];
	int ans=1;
	int mid=(l+r)/2;
	if(x<=mid) ans=1ll*ans*query_pro(l,mid,rt*2,x,y)%P;
//	printf("a ans=%lld\n",ans);
	if(mid<y) ans=1ll*ans*query_pro(mid+1,r,rt*2+1,x,y)%P;
//	printf("b ans=%lld\n",ans);
	return ans;
}
int get_ans(int x,int y)
{
	int ans=query_pro(1,n,1,x,y);
	long long f=query_val(1,n,1,x,y);
	for(int i=0;i<60;++i)
	{
		if(f&(1ll<<i)) ans=1ll*ans*inv[i]%P*(pri[i]-1)%P;
	}
	return ans;
}
void change(int x,int v)
{
	long long f=0;
	for(int i=0;i<60;i++)
	{
		if(v%pri[i]==0) f^=1ll<<i;
	}
	build(1,n,1,x,v,f);
}
int main()
{
	for(int i=1;i<=n;i++) a[i]=3,build(1,n,1,i,a[i],2);
	int m;
	cin>>m;
	
	int flag,x,y;
	for(int i=1;i<=m;i++)
	{
//		for(int j=1;j<=2*n;j++) printf("%lld ",pro[j]); printf("\n");
		scanf("%d%d%d",&flag,&x,&y);
		if(flag==0)
		{
			printf("%d\n",get_ans(x,y));
		}
		else
		{
			change(x,a[x]),change(x,a[x]=y);

		}
	}
	return 0;
}
```




---

## 作者：ricky0916 (赞：1)

~~其实这道题讲了一堆的废话~~
# P4140 奇数国
“若存在整数x,y使得number\*x+product\*y=1，则number与product不

相冲”这句话告诉了我们number与product不相冲的充要条件是

(number,product)=1。又说“他会先对[a,b]的财产求和（记为

product），然后在编号属于[1,product]的账房中选择一个去清点存

款……”可以告诉我们ans=φ(al\*al+1\*......\*ar)

由于这一题需要求区间积的欧拉函数，于是想到用线段树。使用线

段树维护区间的积与区间的积有哪些质数约数。由于面额只能由最

小的60个质数乘起来，所以可以采用状压的方式存储。(欧拉函数使

用公式暴力求)

时间复杂度：O(60\*m\*log n)

代码：~~（写的很丑的）~~
```cpp
#include<bits/stdc++.h>
using namespace std;
const int mod=19961993,n=100000;
int t,prime[301],tot,check[301],ni[301],val2[1000010],a,b,c;
long long val1[1000010];
void init(int x){
	for(int i=2;i<=x;i++){
		if(!check[i]){
			prime[tot++]=i;
		}
		for(int j=0;j<tot&&i*prime[j]<=x;j++){
			check[i*prime[j]]=1;
			if(i%prime[j]==0) break;
		}
	}
	ni[1]=1;
	for(int i=2;i<=x;i++){
        ni[i]=1ll*ni[mod%i]*(mod-mod/i)%mod;
    }
}
void push_up(int rt){
	val1[rt]=val1[rt*2+1]|val1[rt*2+2];
	val2[rt]=1ll*val2[rt*2+1]*val2[rt*2+2]%mod;
}
void build(int rt,int l,int r){
	if(l==r) val1[rt]=2,val2[rt]=3;
	else{
		int mid=(l+r)/2;
		build(rt*2+1,l,mid);
		build(rt*2+2,mid+1,r);
		push_up(rt);
	}
}
long long query1(int rt,int l,int r,int ql,int qr){
	if(ql>r||qr<l) return 0;
	if(ql<=l&&qr>=r) return val1[rt];
	int mid=(l+r)/2;
	return query1(rt*2+1,l,mid,ql,qr)|query1(rt*2+2,mid+1,r,ql,qr);
}
int query2(int rt,int l,int r,int ql,int qr){
	if(ql>r||qr<l) return 1;
	if(ql<=l&&qr>=r) return val2[rt];
	int mid=(l+r)/2;
	return 1ll*query2(rt*2+1,l,mid,ql,qr)*query2(rt*2+2,mid+1,r,ql,qr)%mod;
}
void update_one(int rt,int l,int r,int idx,long long add){
	if(l==r){
		if(idx==l) val2[rt]=add;
		val1[rt]=0;
		for(int i=0;i<60;i++){
			if(val2[rt]%prime[i]==0){
				val1[rt]|=(1ll<<i);
			}
		}
		return;
	}
	int mid=(l+r)/2;
	if(idx<=mid) update_one(rt*2+1,l,mid,idx,add);
	else update_one(rt*2+2,mid+1,r,idx,add);
	push_up(rt);
}
int phi(long long x,int y){
	for(int i=0;i<60;i++){
		if((x&(1ll<<i))){
			y=1ll*y*(prime[i]-1)%mod*ni[prime[i]]%mod;
		}
	}
	return y;
}
int main(){
	init(300);
	scanf("%d",&t);
	build(0,0,n-1);
	while(t--){
		scanf("%d%d%d",&a,&b,&c);
		if(a) update_one(0,0,n-1,b-1,c);
		else printf("%d\n",phi(query1(0,0,n-1,b-1,c-1),query2(0,0,n-1,b-1,c-1)));
	}
	return 0;
}
```


---

## 作者：warzone (赞：1)

### 题目大意
---------

维护一段长度为$10^5$ 的序列(银行),初始全为3

对于每次询问的区间,求它们的积(product)

然后输出1~product与product互质的数(即欧拉函数)

(此处读题时注意账房和银行是两个不同的单位)

### 数据范围
---------

规定质因子在281及以下,共60个(面值只有60种)

每个数不超过 $10^6$

### solution
-----------

1.  欧拉函数的求法

    $(10^6)^{10^5}$ 不可能存的下,对于积就只需记录质因子
    
    也就需要提前做欧拉筛分解质因数和离散化,复杂度 $O(10^6)$
    
    ```cpp
    next[1]=0;
    for(register int i=2;i<=1000000;i++){//欧拉筛分解质因数
        if(bef[i]==0){
            for(register long long j=1,before=0;j!=0;j=next[j])
                if(j*i<=1000000){
                    bef[j*i]=j;
                    next[j*i]=next[j];
                    next[j]=j*i;
                    before=j;
                }
                else{
                    next[before]=next[j];
                    j=before;
                }
            }
        }    
    }
    for(register int i=2,id=0;i<=1000000;i++)//离散化
        if(bef[i]==1) next[i]=++id;
    ```
    
       同时众所周知,若 $n=p_1^{c_1}p_2^{c_2}...p_m^{c_m}$ ,则欧拉函数 
    
    ### $\phi(n)=n(\frac{p_1-1}{p_1})(\frac{p_2-1}{p_2})...(\frac{p_m-1}{p_m})$
    ### $=p_1^{c_1-1}p_2^{c_2-1}...p_m^{c_m-1}(p_1-1)(p_2-1)...(p_m-1)$
	 于是就可以用快速幂求,时间复杂度 $O(60logn)$
     ```cpp
    typedef unsigned int word;
    typedef unsigned long long ull;
    typedef unsigned char byte;
    const ull mod=19961993;
    const ull prime[]={//提前用欧拉筛打好的质数表
        1,2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,
        53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,
        131,137,139,149,151,157,163,167,173,179,181,191,193,197,199，
        211,223,227,229,233,239,241,251,257,263,269,271,277,28
    };
    struct pair{//封装好的质因子记录
        word count[64];
    	inline pair(){memset(count,0,sizeof(count));}
    	inline pair(const pair& p){memcpy(count,p.count,sizeof(count));}
    	inline pair& operator =(word num){//存入质因子
    		memset(count,0,sizeof(count));
    		for(;num!=1;num=bef[num])
    			count[next[num/bef[num]]]++;
    		return *this;
    	}
    	inline void update(const pair &l,const pair &r){//区间合并
    		for(register byte i=1;i<=60;i++){
    			count[i]=l.count[i]+r.count[i];
    		}
    	}
    	inline ull euler(){//快速幂求欧拉函数
    		register ull ans=1,p;
    		for(register byte i=1;i<=60;i++){
    			if(count[i]){
                    p=prime[i],count[i]--;
    				for(;count[i]>0;count[i]>>=1){
    					if(count[i]&1) ans=ans*p%mod;
    					p=p*p%mod;
    				}
    				ans=ans*(prime[i]-1)%mod;
    			}
    		}
    		return ans;
    	}
    };
     ```
     由于19961993为质数,也可以用费马小定理求逆元,同时维护区间积
     
     逆元打表就可以达到 $O(60)$
     
    ```cpp
    typedef unsigned int word;
    typedef unsigned long long ull;
    typedef unsigned char byte;
    const ull mod=19961993;
    const word inver[]={//费马小定理求逆元
        1,9980997,6653998,11977196,8555140,5444180,1535538,10568114,
        14708837,3471651,11701858,17386252,1618540,16066970,2321162,
        18263100,16948862,12518538,15380552,10725847,1686929,13399146,
        17182475,12025297,15924736,13582387,395287,6395590,15857658,
        16299242,6359573,3300802,18742940,6702567,10914471,16210746,
        11765678,5340151,18247466,7769638,8077107,11932588,6506948,
        1985748,6619521,5877135,4413707,9744480,10115270,14597757,
        16475182,18334191,5011379,18885205,7555336,621385,11309266,
        12170137,12006660,18304499,11153142
    };
    struct pair{//封装好的质因子记录
        byte count[64];
        word multi;
        inline pair(){memset(count,0,sizeof(count));multi=3;}
        inline pair(const pair& p){
            memcpy(count,p.count,sizeof(count));
            multi=p.multi;
        }
    	inline pair& operator =(word num){
            multi=num;
    		memset(count,0,sizeof(count));
    		for(;num!=1;num=bef[num])
    			count[next[num/bef[num]]]=1;
    		return *this;
    	}
    	inline void update(const pair &l,const pair &r){//区间合并
    		for(register byte i=1;i<=60;i++){
    			count[i]=l.count[i]|r.count[i];
    		}
            multi=l.multi*r.multi%mod;
    	}
    	inline ull euler(){//逆元求欧拉函数
    		register ull ans=multi;
    		for(register byte i=1;i<=60;i++){
    			if(count[i]){
    				ans=ans*(prime[i]-1)%mod;
                    ans=ans*inver[i]%mod;
    			}
    		}
    		return ans;
    	}
    };
    ```
    
2.  题目实现

    既然是区间询问,区间查询,必然是线段树了

    由于节点只需记录质因子,可以进行区间合并,剩下的输入输出也就不用多说
    
    ```cpp 
    class segment_tree{//线段树
        private:
            struct point{
                point *l,*r;
                word from,to;
                pair p;
                inline point(word f,word t){//初始化
                    from=f,to=t;
                    if(f==t) p.count[2]=1;
                    else{
                        l=new point(f,f+t>>1);
                        r=new point(l->to+1,t);
                        p.count[2].update(l->p,r->p);
                    }
                }
                inline ~point(){
                    if(from!=to){
                        delete l;
                        delete r;	
                    }
                }
                inline pair* sum(word f,word t){//区间查询
                    if(from==f&&to==t) return new pair(p);
                    if(t<=l->to) return l->sum(f,t);
                    if(r->from<=f) return r->sum(f,t);
                    register pair* outl=l->sum(f,l->to);
                    register pair* outr=r->sum(r->from,t);
                    outl->update(*outl,*outr);
                    delete outr;
                    return outl;
                }
                inline void is(word id,word num){//单点修改
                    if(from==to) p=num;
                    else{
                        if(id<=l->to) l->is(id,num);
                        else r->is(id,num);
                        p.update(l->p,r->p);
                    }
                }
            }*root;
        public:
            inline segment_tree(){root=new point(1,100000);}
            inline ~segment_tree(){delete root;}
            inline void is(word id,word num){//单点修改
                root->is(id,num);
            }
            inline word sum(word f,word t){//区间查询
                pair *p=root->sum(f,t);
                word ans=p->euler();
                delete p;
                return ans;
            }
    };
    ```
完整代码(2.96s,63.41MB)
```cpp
#include<cstdio>
#include<cstring>
using namespace std;
typedef unsigned int word;
typedef unsigned char byte;
typedef unsigned long long ull;
word bef[1000010];
word next[1000010];
const ull mod=19961993;
const ull prime[]={
    1,2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,
    61,67,71,73,79,83,89,97,101,103,107,109,113,127,
    131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,
	211,223,227,229,233,239,241,251,257,263,269,271,277,281
};
struct READ{
	inline READ(){
		next[1]=0;
        for(register int i=2;i<=1000000;i++){//欧拉筛分解质因数
            if(bef[i]==0){
                register long long j=1,before=0;
                for(;j!=0;j=next[j])
                    if(j*i<=1000000){
                        bef[j*i]=j;
                        next[j*i]=next[j];
                        next[j]=j*i;
                        before=j;
                    }
                    else{
                        next[before]=next[j];
                        j=before;
                    }
            }
        }
        for(register int i=2,id=0;i<=1000000;i++)//离散化
            if(bef[i]==1) next[i]=++id; 
    }
	template<typename type>
	inline READ& operator >>(type &num){//快读
		register char c=getchar(),w=1;
		while('0'>c||c>'9'){
			if(c==EOF) return *this;
			w=c=='-'? -1:1;
			c=getchar();
		}
		num=0;
		while('0'<=c&&c<='9'){
			num=(num<<1)+(num<<3)+(c-'0');
			c=getchar();
		}
		num*=w;
		return *this;
	}
}read; 
struct pair{//封装好的质因子记录
    word count[64];
    inline pair(){memset(count,0,sizeof(count));}
    inline pair(const pair& p){memcpy(count,p.count,sizeof(count));}
    inline pair& operator =(word num){//存入质因子
    	memset(count,0,sizeof(count));
    	for(;num!=1;num=bef[num])
    		count[next[num/bef[num]]]++;
    	return *this;
    }
    inline void update(const pair &l,const pair &r){//区间合并
    	for(register byte i=1;i<=60;i++){
    		count[i]=l.count[i]+r.count[i];
    	}
    }
    inline ull euler(){//快速幂求欧拉函数
    	register ull ans=1,p;
    	for(register byte i=1;i<=60;i++){
    		if(count[i]){
                p=prime[i],count[i]--;
    			for(;count[i]>0;count[i]>>=1){
    				if(count[i]&1) ans=ans*p%mod;
    				p=p*p%mod;
    			}
    			ans=ans*(prime[i]-1)%mod;
    		}
    	}
    	return ans;
    }
};
class segment_tree{ //线段树
	private:
		struct point {
			point *l,*r;
			word from,to;
			pair p;
			inline point(word f,word t){ //初始化
				from=f,to=t;
				if(f==t) p.count[2]=1;
				else {
					l=new point(f,f+t>>1);
					r=new point(l->to+1,t);
					p.update(l->p,r->p);
				}
			}
			inline ~point(){
				if(from!=to){
					delete l;
					delete r;
				}
			}
			inline pair* sum(word f,word t){ //区间查询
				if(from==f&&to==t) return new pair(p);
				if(t<=l->to) return l->sum(f,t);
				if(r->from<=f) return r->sum(f,t);
				register pair* outl=l->sum(f,l->to);
				register pair* outr=r->sum(r->from,t);
				outl->update(*outl,*outr);
				delete outr;
				return outl;
			}
			inline void is(word id,word num){ //单点修改
				if(from==to) p=num;
				else {
					if(id<=l->to) l->is(id,num);
					else r->is(id,num);
					p.update(l->p,r->p);
				}
			}
		}*root;
	public:
		inline segment_tree(){root=new point(1,100000);}
		inline ~segment_tree(){delete root;}
		inline void is(word id,word num){ //单点修改
			root->is(id,num);
		}
		inline word sum(word f,word t){ //区间查询
			pair *p=root->sum(f,t);
			word ans=p->euler();
			delete p;
			return ans;
		}
};
int main(){
	register word n,a,b,c;
	segment_tree tree;
	for(read>>n;n>0;n--){
		read>>a>>b>>c;
		if(a==0) printf("%llu\n",tree.sum(b,c));
		else tree.is(b,c);
	}
	return 0;
}
```


---

## 作者：蒟蒻丁 (赞：0)

虽然 $ntf$ 学长嘲讽了这道题，但我认为这道题很适合我(菜鸡)了解线段树的有趣用法  
首先翻译题面，就是每次进行一个操作——询问一个区间内所有数的乘积的欧拉函数或者修改数列中的一个数  
由于每个数上限是$10^6$，暴力求完一个区间的乘积再套欧拉函数是不可能的
首先了解先欧拉函数的公式
$$φ(x)=x*\prod_{i|x}^{}{(1-\frac{1}{i})}$$
($i$为质数，沙雕洛谷$markdown$爆炸)  
看到这个公式，发现我们其实没有必要求出区间数的乘积，我们只需要知道这个乘积里会有几个不同的质数就可以了  
然后每个数不超过$10^6$，所以会出现的质数不超过$60$个，可以状态压缩  
用一个$f$数组记录取模后的区间乘积，用一个$ff$记录区间内出现的质数种类的状压，每次查询一个区间的这两个值就能求出这个区间乘积的欧拉函数  
下面说下具体过程，不想剧透的小伙伴可以开始敲代码了
* 1、对于每个修改操作，分解出这个数的每个质因数，并状压
* 2、对于查询，首先求出区间积(公式里的x)
* 3、查询这个区间质因数种类的状压数字，还原出有哪些质因数
* 4、用第二步和第三步求出的值直接求欧拉函数
时间复杂度为$O(60*n*log(len))$  
下面AC代码

```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#define mid ((l+r)/2)
#define ll long long
using namespace std;
const ll P[]={2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281};
const ll inv[]={9980997,6653998,11977196,8555140,5444180,1535538,10568114,14708837,3471651,11701858,17386252,1618540,16066970,2321162,18263100,16948862,12518538,15380552,10725847,1686929,13399146,17182475,12025297,15924736,13582387,395287,6395590,15857658,16299242,6359573,3300802,18742940,6702567,10914471,16210746,11765678,5340151,18247466,7769638,8077107,11932588,6506948,1985748,6619521,5877135,4413707,9744480,10115270,14597757,16475182,18334191,5011379,18885205,7555336,621385,11309266,12170137,12006660,18304499,11153142};
const ll mod=19961993;
ll n,f[8000010],ff[8000010];

void build(ll l,ll r,ll o){
	if(l==r){
		f[o]=2,ff[o]=3;
		return ;
	}
	build(l,mid,o*2);
	build(mid+1,r,o*2+1);
	f[o]=f[o*2]|f[o*2+1];
	ff[o]=ff[o*2]*ff[o*2+1]%mod;
}

void modify(ll l,ll r,ll o,ll x,ll d,ll d2){
	if(l==r){
		f[o]=d,ff[o]=d2;
		return ;
	}
	if(x<=mid)modify(l,mid,o*2,x,d,d2);
	else modify(mid+1,r,o*2+1,x,d,d2);
	f[o]=f[o*2]|f[o*2+1];
	ff[o]=ff[o*2]*ff[o*2+1]%mod;
}

ll Query(ll l,ll r,ll o,ll i,ll j){
	if(i<=l&&r<=j){
		return ff[o];
	}
	ll ret=1;
	if(i<=mid)ret=ret*Query(l,mid,o*2,i,j)%mod;
	if(mid<j)ret=ret*Query(mid+1,r,o*2+1,i,j)%mod;
	return ret;
}

ll query(ll l,ll r,ll o,ll i,ll j){
	if(i<=l&&r<=j){
		return f[o];
	}
	ll ret=0;
	if(i<=mid)ret|=query(l,mid,o*2,i,j);
	if(mid<j)ret|=query(mid+1,r,o*2+1,i,j);
	return ret;
}

ll pre_work(ll x){
	ll tmp=0;
	for(ll i=0;i<60;i++){
		if(x%P[i]==0)tmp|=(1ll<<i);
	}
	return tmp;
}

int main(){
	cin>>n;
	for(ll i=1;i<=100000;i++)modify(1,100000,1,i,2,3);
	while(n--){
		ll opt,a1,a2;
		scanf("%lld%lld%lld",&opt,&a1,&a2);
		if(opt==1)modify(1,100000,1,a1,pre_work(a2),a2);
		else {
			ll tmp=query(1,100000,1,a1,a2);
			ll ans=Query(1,100000,1,a1,a2);
			for(ll i=0,a1;i<60;i++){
				if(tmp&(1ll<<i)){
					ans=(ans*inv[i])%mod,ans=(ans*(P[i]-1))%mod;
				}
			}
			printf("%lld\n",ans);
		}
	}
}
```

---

## 作者：DrLin (赞：0)

## [推荐在这里观看](https://www.cnblogs.com/linzhuohang/p/13476669.html)

# 题解
首先看到题目要求 $number\times x+product\times y=1$

这其实就是一个二元一次不定方程

在学习扩展欧几里得的时候我们知道

如果 $a,b$ 是整数，那么一定存在整数 $x,y$ 使得 $ax+by=gcd(a,b)$ 
 
那么 $ax+by=1$ 有解当且仅当 $a,b$ 互质，即要满足 $number$ 与 $product$ 互质
 
也就是说对于一次询问，求得就是 $product$ 以内有多少与它互质的数，这个就是欧拉函数
 
但是 $product$ 太大了，无法直接求，注意到题目说 $product$ 可以表示成 $p1^{k1}\times p2^{k2}\times …p60^{k60}$
 
我们知道欧拉函数有三条性质
 
1. 若 $a$ 为质数，则 $ψ(a)=a-1$

1. 若 $a,b$ 互质，则 $ψ(a\times b)=ψ(a)\times ψ(b)$

1. 若 $a$ 为质数，$b$ 为 $a$ 的倍数，则 $ψ(a\times b)=ψ(b)\times a$

那么

$ψ(p1^{k1}\times p2^{k2}\times …p60^{K60})$

$=ψ(p1^{k1})\times ψ(p2^{k2})…$（性质2）

$=ψ(p1)\times p1^{k1-1}\times ψ(p2)\times p2^{k2-1}…$（性质3）

$=(p1-1)\times p1^{k1-1}\times(p2-1)\times p2^{k2-1}…$（性质1）

$={(p1^{k1}\times p2^{k2}\times …)}/(p1\times p2\times …)\times (p1-1)\times (p2-1)… $

$=product/(p1\times p2\times …)\times (p1-1)\times (p2-1)…$

上式中的 $p$ 都是被 $product$ 包含的

除法可以用逆元处理

那么，我们可以用线段树维护每段区间的 $product$ (取模后)，每个质数是否出现（可以用一个 $long \space long$ 或者数组存储）

询问时根据返回的数组计算后面那一坨就行了

# 代码

注意线段树右边界要代100000进去，而不是 $n$ （我在这里调了0.5h）

```cpp
#include <iostream>
#include <cstring>
#include <cstdio>
using namespace std;
#define int long long
#define N 500010
#define lc id*2
#define rc id*2+1
#define mid (l+r)/2
#define mod 19961993
bool fact[N][61];
int prim[61]={0,2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281};
int inv[61];
int sum[N];
void build(int id,int l,int r)
{
	fact[id][2]=1;
	if(l==r)
	{
		sum[id]=3;
		return;
	}
	build(lc,l,mid);
	build(rc,mid+1,r);
	sum[id]=sum[lc]*sum[rc]%mod;
}
void modify(int id,int l,int r,int pos,int val)
{
	if(l==r)
	{
		memset(fact[id],0,sizeof(fact[id]));
		sum[id]=val;
		for(int i=1;i<=60;i++)
			if(val%prim[i]==0) fact[id][i]=1;
		return;
	}
	if(pos<=mid) modify(lc,l,mid,pos,val);
	else modify(rc,mid+1,r,pos,val);
	for(int i=1;i<=60;i++) fact[id][i]=fact[lc][i]|fact[rc][i];
	sum[id]=sum[lc]*sum[rc]%mod;
}
int query(int id,int l,int r,int tl,int tr,bool arr[])
{
	if(l>=tl&&r<=tr)
	{
		for(int i=1;i<=60;i++) arr[i]|=fact[id][i];
		return sum[id];
	}
	int ret=1;
	if(tl<=mid) ret=query(lc,l,mid,tl,tr,arr);
	if(tr>mid) ret*=query(rc,mid+1,r,tl,tr,arr);
	return ret%mod;
}
int qpow(int a,int b)
{
	int ans=1;
	while(b)
	{
		if(b&1) ans*=a,ans%=mod;
		a*=a;
		a%=mod;
		b>>=1;
	}
	return ans;
}
signed main()
{
	int n;
	cin>>n;
	build(1,1,100000);
	for(int i=1;i<=60;i++) inv[i]=qpow(prim[i],mod-2);
	for(int i=1;i<=n;i++)
	{
		int a,b,c;
		scanf("%lld%lld%lld",&a,&b,&c);
		if(a==0)
		{
			bool arr[61]={0};
			int tot=1,tot2=1,tot3=query(1,1,100000,b,c,arr);
			for(int j=1;j<=60;j++) if(arr[j]) tot*=inv[j],tot2*=(prim[j]-1),tot%=mod,tot2%=mod;
			printf("%lld\n", tot3*tot2%mod*tot%mod);
		}
		else modify(1,1,100000,b,c);
	}
}
```


---


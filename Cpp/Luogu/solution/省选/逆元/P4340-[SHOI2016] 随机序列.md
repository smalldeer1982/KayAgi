# [SHOI2016] 随机序列

## 题目描述

你的面前有 $n$ 个数排成一行，分别为 $a_1,a_2,...,a_n$ 。你打算在每相邻的两个 $a_i$​​  和 $a_{i+1}$ 间都插入一个加号、减号或者乘号。那么一共有$3^{n-1}$ 种可能的表达式。

你对所有可能的表达式的值的和非常感兴趣。但这毕竟太简单了，所以你还打算支持一个修改操作，可以修改某个 $a_i$ 的值。

你能够编写一个程序对每个修改都输出修改完之后所有可能表达式的和吗？注意，修改是永久的，也就是说每次修改都是在上一次修改的基础上进行，而不是在最初的表达式上进行。

## 说明/提示

对于20%的数据，n,q<=20

对于50%的数据，n,q<=1000

对于100%的数据，n,q<=100000

- 2023.11.17 添加一组 hack 数据。

## 样例 #1

### 输入

```
5 5
9384 887 2778 6916 7794
2 8336
5 493
3 1422
1 28
4 60```

### 输出

```
890543652
252923708
942282590
228728040
608998099```

# 题解

## 作者：浮尘ii (赞：11)

注意到有贡献的一定是开始的一段乘法段，因为后面的段一定又有 + 又有 -。

设 $S_n=\prod_{i=1}^na_i$，于是答案就为
$$\sum_{i=1}^{n-1}S_i\times2\times3^{n-i-1}+S_n$$

组合意义即为枚举第一个连续的乘法段的最后一个数在哪里，那么下一个位置必须填 `+` 或 `-`，其余的随便填。

对于 $a_i$ 的单点修改，有一个显然的想法是对于 $S_i$ 的一段后缀做乘法，于是用线段树区间乘法，维护区间和即可。

但是以上的做法是**错误**的！

由于 $0$ 不存在逆元，而题目中说是非负整数没有保证不为 $0$，所以该做法可以被以下数据轻松卡掉：
```
1 1
0
1 1
```

但是由于该题数据比较水，所以可以通过。

正确的维护方法应该是：仍然是单点修改，在向上回溯的过程中维护区间积 $\rm mul$ 和答案 $\rm ans$。则
$$\begin{aligned}\rm mul&=\rm mul_{lc}\cdot mul_{rc}\\\rm ans&=\rm ans_{lc}+mul_{lc}\cdot ans_{rc}\end{aligned}$$

```cpp
#include <cstdio>

typedef unsigned long long ull;
const int Mod = 1000000007;
const int maxN = 100005, maxL = 1 << 18 | 1;

int N, Q, A[maxN], Pow[maxN];

#define lc i << 1
#define rc i << 1 | 1
int Mul[maxL], Ans[maxL];
void build(int i, int l, int r)
{
	if (l == r)
	{
		Mul[i] = A[l];
		if (l == N)
			Ans[i] = A[l];
		else
			Ans[i] = A[l] * 2ULL * Pow[N - l - 1] % Mod;
		return;
	}
	int m = (l + r) >> 1;
	build(lc, l, m);
	build(rc, m + 1, r);
	Mul[i] = (ull)Mul[lc] * Mul[rc] % Mod;
	Ans[i] = ((ull)Mul[lc] * Ans[rc] + Ans[lc]) % Mod;
}
void modify(int i, int l, int r, int pos, int v)
{
	if (l == r)
	{
		A[l] = v;
		Mul[i] = A[l];
		if (l == N)
			Ans[i] = A[l];
		else
			Ans[i] = A[l] * 2ULL * Pow[N - l - 1] % Mod;
		return;
	}
	int m = (l + r) >> 1;
	if (pos <= m)
		modify(lc, l, m, pos, v);
	else
		modify(rc, m + 1, r, pos, v);
	Mul[i] = (ull)Mul[lc] * Mul[rc] % Mod;
	Ans[i] = ((ull)Mul[lc] * Ans[rc] + Ans[lc]) % Mod;
}
#undef lc
#undef rc

int main()
{
	scanf("%d%d", &N, &Q);
	for (int i = 1; i <= N; ++i)
		scanf("%d", A + i);
	Pow[0] = 1;
	for (int i = 1; i <= N; ++i)
		Pow[i] = 3U * Pow[i - 1] % Mod;

	build(1, 1, N);

	for (int t, v; Q--;)
	{
		scanf("%d%d", &t, &v);
		modify(1, 1, N, t, v);
		printf("%d\n", Ans[1]);
	}

	return 0;
}
```

---

## 作者：cjZYZtcl (赞：8)

看题解区都发现了这题贡献为一段前缀积的性质，来发一篇不需要这个性质的题解。

### 前置芝士：

动态 DP

### 做法：

首先设计 DP 状态。

设 $f_{i, 0/1/2}$ 表示第 $i$ 位前填了 $\times / + / -$ 号时除了最后一段积以外前面所有已经结束的区间积的和。

举个例子：

$$a_1 \times a_2 \times a_3 - a_4 \times a_5 + a_6 \times a_7$$

此时已经结束的区间积的和就是 $a_1 \times a_2 \times a_3 - a_4 \times a_5$ 。

设 $g_{i,0/1/2}$ 表示第 $i$ 位前填了 $\times / + / -$ 号时最后一段积的乘积。

再次引用上面那个例子，最后一段积即 $a_6 \times a_7$ 。

注意：最后一段积要连带前面的符号！

设 $cnt_{i,0/1/2}$ 表示第 $i$ 位前填了 $\times / + / -$ 号时的方案数。

则可得到 DP 转移方程：

$\begin{cases}f_{i,0}=f_{i-1,0}+f_{i-1,1}+f_{i-1,2}\\f_{i,1}=f_{i-1,0}+f_{i-1,1}+f_{i-1,2}+g_{i-1,0}+g_{i-1,1}+g_{i-1,2}\\f_{i,2}=f_{i-1,0}+f_{i-1,1}+f_{i-1,2}+g_{i-1,0}+g_{i-1,1}+g_{i-1,2}\\g_{i,0}=a_i \times (g_{i-1,0}+g_{i-1,1}+g_{i-1,2})\\g_{i,1}=a_i \times cnt_{i,1}\\g_{i,2}=(-a_i) \times cnt_{i,2}\\cnt_{i,0}=cnt_{i-1,0}+cnt_{i-1,1}+cnt_{i-1,2}\\cnt_{i,1}=cnt_{i-1,0}+cnt_{i-1,1}+cnt_{i-1,2}\\cnt_{i,2}=cnt_{i-1,0}+cnt_{i-1,1}+cnt_{i-1,2}\end{cases}$

所以可以得到一个 $9 \times 9$ 的矩阵：

$$\begin{bmatrix}1&1&1&0&0&0&0&0&0\\1&1&1&1&1&1&0&0&0\\1&1&1&1&1&1&0&0&0\\0&0&0&a_i&a_i&a_i&0&0&0\\0&0&0&0&0&0&a_i&a_i&a_i\\0&0&0&0&0&0&-a_i&-a_i&-a_i\\0&0&0&0&0&0&1&1&1\\0&0&0&0&0&0&1&1&1\\0&0&0&0&0&0&1&1&1\end{bmatrix}$$

至此，DP 过程就可以线段树动态维护了。

但是，由于矩阵是 $9 \times 9$ 的，所以时间复杂度高达 $O(9^3 \times n \log{n})$ ，难以通过此题。

于是考虑优化。

可以发现 $cnt$ 数组的三个转移是重复的，可以删去两个。

所以可以得到一个 $7 \times 7$ 的矩阵：

$$\begin{bmatrix}1&1&1&0&0&0&0\\1&1&1&1&1&1&0\\1&1&1&1&1&1&0\\0&0&0&a_i&a_i&a_i&0\\0&0&0&0&0&0&3a_i\\0&0&0&0&0&0&-3a_i\\0&0&0&0&0&0&3\end{bmatrix}$$

时间复杂度 $O(7^3 \times n \log{n})$ ，开 O2 可通过本题。

### AC Code：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define pr pair<int, int>
#define mp make_pair
#define pb push_back
#define mid (l + r) / 2
#define ls num << 1
#define rs num << 1 | 1
#define fi first
#define se second
const int mod = 1e9 + 7, N = 1e5 + 5;

struct matrix {
	int time[7][7];
	
	matrix() {
		memset(time, 0, sizeof(time));
	}
	
	void reset(int x) {
		for (int i = 0; i < 3; i++) time[0][i] = 1;
		
		time[6][6] = 3;
		
		for (int i = 0; i < 6; i++) time[1][i] = time[2][i] = 1;
		for (int i = 3; i < 6; i++) time[3][i] = x;
		
		time[4][6] = 3 * x % mod;
		time[5][6] = 3 * (mod - x) % mod;
	}
} tr[N << 2];
int a[N];

#define getchar() (uu == vv && (vv = (uu = cc) + fread(cc, 1, 1 << 21, stdin), uu == vv) ? EOF : *uu++)
char cc[1 << 21], *uu = cc, *vv = cc;

template <typename T_ = int> inline T_ read() {
	T_ x = 0;
	bool y = 0;
	char c = getchar();
	while (!isdigit(c)) {
		if (c == '-') y = 1;
		c = getchar();
	}
	while (isdigit(c)) x = x * 10 + (c ^ 48), c = getchar();
	return y ? ~(x - 1) : x;
}

inline void write(int x){
	if(x < 0){
		putchar('-');
		write(-x);
		return;
	}
	if(x >= 10) write(x / 10);
	putchar(x % 10 + '0');
}

matrix operator * (const matrix &x, const matrix &y) {
	matrix z;
	
	for (int k = 0; k < 7; k++) {
		for (int i = 0; i < 7; i++) {
			for (int j = 0; j < 7; j++) {
				z.time[i][j] += x.time[i][k] * y.time[k][j] % mod;
				
				if (z.time[i][j] >= mod) z.time[i][j] -= mod;
			}
		}
	}
	
	return z;
}

void print(matrix x) {
	for (int i = 0; i < 7; i++) {
		for (int j = 0; j < 7; j++) {
			write(x.time[i][j]);
			putchar(' ');
		}
		putchar('\n');
	}
	putchar('\n');
}

void update(int num) {
	tr[num] = tr[rs] * tr[ls];
}

void build(int l, int r, int num) {
	if (l == r) {
		tr[num].reset(a[l]);
		return;
	}
	
	build(l, mid, ls);
	build(mid + 1, r, rs);
	
	update(num);
}

void update(int l, int r, int x, int num) {
	if (l == r) {
		tr[num].reset(a[l]);
		return;
	}
	
	if (x <= mid) update(l, mid, x, ls);
	else update(mid + 1, r, x, rs);
	
	update(num);
}

signed main(){
	int n = read(), q = read();
	
	for (int i = 0; i < n; i++) {
		a[i] = read();
	}
	
	a[n] = 1;
	
	build(1, n, 1);
	
	matrix now;
	
	now.time[6][0] = 1;
	now.time[3][0] = a[0];
	
	while (q--) {
		int x = read() - 1, y = read();
		
		a[x] = y;
		
		if (x) update(1, n, x, 1);
		else now.time[3][0] = y;
		
		matrix ans = tr[1] * now;
		
		write(ans.time[1][0]);
		putchar('\n');
	}
}
```

#### 小优化：

发现矩乘中有极多乘法是无效的，形如 $0 \times 0=0$，所以可以提前找出有用的乘法，大大优化矩乘的复杂度，预计不开 O2 也可通过此题。

---

## 作者：shadowice1984 (赞：7)

线段树好题啊

猜中(分明是严谨而合理的推倒)结论的话，似乎非常简单的样子？

## 那么开始愉快的推倒结论吧~

我们发现一个很奇怪的事实是，这个长度为n的序列只有n-1个运算符号

也就是说，**第一项的系数必为正**

所以我们呢考虑去掉第一项，现在变成了每一位(第一项符号不能为乘)都是任意符号的序列

那么我们发现，在这个符号任意的所有序列当中，对于任意一个序列，加减号反转之后都会存在一个对应的序列与之相对应然后如果我们把这些序列两两配对相加之后总和一定是0(因为每一对相加都是0)

那么此时让我们来看被忽略的首项，显然因为第一项必为正所以肯定是消不掉的
那么我们来枚举这个首项，看看有多少个首项是消不掉的，换句话来讲我们呢统计后边的序列有多少中可能性，假设后边的长度为len，第一个符号显然不可以选乘，其他的任意选，一共有$2×3^n$种可能性，所以我们要对这个首项乘上一个系数就行了

然后我们发现这个首项呢就是序列的前缀积，而我们要维护前缀积的和，发现此时单点修改=前缀积区间乘法，此时我们只需要写一个资瓷区间乘区间求和的线段树就可以完成单点赋值的操作了~

上代码~

```C
#include<cstdio>
#include<algorithm>
using namespace std;const int N=1e5+10;typedef long long ll;
int n;int m;ll mod=1e9+7;ll mi[N];ll prm[N];ll val[N];//记得写乘法逆元 
inline ll po(ll a,ll p){ll r=1;for(;p;p>>=1,a=(a*a)%mod){if(p&1){r=(r*a)%mod;}}return r;}
struct linetree//区间乘区间求和的线段树~ 
{
	ll val[4*N];ll mult[4*N]; 
	inline void pushdown(int p)
	{
		val[p<<1]=val[p<<1]*mult[p]%mod;
		val[p<<1|1]=val[p<<1|1]*mult[p]%mod;
		mult[p<<1]=mult[p<<1]*mult[p]%mod;
		mult[p<<1|1]=mult[p<<1|1]*mult[p]%mod;mult[p]=1;
	}
	inline void setmul(int p,int l,int r,int dl,int dr,ll mul)
	{
		if(dl==l&&dr==r){mult[p]=mult[p]*mul%mod;val[p]=val[p]*mul%mod;return;}
		int mid=(l+r)/2;pushdown(p);
		if(dl<mid){setmul(p<<1,l,mid,dl,min(dr,mid),mul);}
		if(mid<dr){setmul(p<<1|1,mid,r,max(dl,mid),dr,mul);}
		val[p]=(val[p<<1]+val[p<<1|1])%mod;
	}
	inline ll getv(){return val[1];}
	inline void build(int p,int l,int r)
	{
		if(r-l==1){val[p]=prm[r];return;}int mid=(l+r)/2;mult[p]=1;
		build(p<<1,l,mid);build(p<<1|1,mid,r);val[p]=(val[p<<1]+val[p<<1|1])%mod;
	}
}lt;
int main()
{
	scanf("%d%d",&n,&m);mi[0]=1;prm[0]=1;
	for(int i=1;i<=n;i++){scanf("%lld",&val[i]);}
	for(int i=1;i<=n;i++){mi[i]=mi[i-1]*3%mod;}//处理3的幂次 
	for(int i=1;i<=n;i++){prm[i]=prm[i-1]*val[i]%mod;}//处理前缀积 
	for(int i=1;i<=n-1;i++){prm[i]=prm[i]*2*mi[n-i-1]%mod;}//乘上对应的系数 
	lt.build(1,0,n);//构建线段树~ 
	for(int i=1;i<=n;i++)
	{
		int t;ll v;scanf("%d%lld",&t,&v);
		lt.setmul(1,0,n,t-1,n,v*po(val[t],mod-2)%mod);//修改 
		val[t]=v;printf("%lld\n",lt.getv());//输出~ 
	}return 0;//拜拜程序~ 
}
```

---

## 作者：Hovery (赞：6)

不难发现两个符号对称的式子只有前缀积有贡献，考虑对于每一个前缀积算出它的贡献次数。

发现如果一个前缀积要有贡献，那么一定是一串乘号+加减符号，剩下的位置可以随便填。

这样对于一个前缀 $i,(1\le i<n)$ 它能产生的贡献是 $val_i=mul_i\times2\times3^{n-i-2},mul_i=\prod_{j=1}^{i}a_j$。

再对 $n$ 的贡献特判一下。

答案就是 $\sum_{i=1}^n val_i$。

对于修改，可以发现就是对 $val_{t\sim n}$ 这些位置除以 $a_t$ 再乘上 $v$，发现这个可以用线段树维护。

## Code 

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;

const int mod = 1e9 + 7;

int tr[400010], mul[100010], a[100010], tag[400010], n, pw[100010];

void pushdown(int num)
{
	if (tag[num] <= 1)
	return;
	tag[num * 2] = tag[num * 2] * tag[num] % mod;
	tag[num * 2 + 1] = tag[num * 2 + 1] * tag[num] % mod;
	tr[num * 2] = tr[num * 2] * tag[num] % mod;
	tr[num * 2 + 1] = tr[num * 2 + 1] * tag[num] % mod;
	tag[num] = 1;
}

int qpow(int x, int y)
{
	int ans = 1;
	for (;y;x = x * x % mod, y >>= 1)
	if (y & 1)
	{
		ans = ans * x % mod;
	}
	return ans;
}

void build(int l, int r, int num)
{
	if (l == r)
	{
		tr[num] = mul[l];
		tag[num] = 1;
		return;
	}
	int mid = l + r >> 1;
	build(l, mid, num * 2);
	build(mid + 1, r, num * 2 + 1);
	tr[num] = (tr[num * 2] + tr[num * 2 + 1]) % mod;
	tag[num] = 1;
}

void change(int l, int r, int x, int _, int num)
{
	if (r < _)
	return;
	if (l >= _)
	{
		tag[num] = tag[num] * x % mod;
		tr[num] = tr[num] * x % mod;
		return;
	}
	pushdown(num);
	int mid = l + r >> 1;
	change(l, mid, x, _, num * 2);
	change(mid + 1, r, x, _, num * 2 + 1);
	tr[num] = (tr[num * 2] + tr[num * 2 + 1]) % mod;
}

signed main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
	int q;
	cin >> n >> q;
	for (int i = 1;i <= n;i++)
	{
		cin >> a[i];
	}
	mul[0] = 1;
	pw[0] = 1;
	for (int i = 1;i <= n;i++)
	pw[i] = pw[i - 1] * 3 % mod;
	for (int i = 1;i <= n;i++)
	{
		mul[i] = mul[i - 1] * a[i] % mod;
	}
	for (int i = 1;i < n;i++)
	{
		mul[i] = mul[i] * pw[n - i - 1] % mod * 2 % mod;
	}
	build(1, n, 1);
	for (int i = 1;i <= q;i++)
	{
		int x, y;
		cin >> x >> y;
		y = y * qpow(a[x], mod - 2) % mod;
		a[x] = a[x] * y % mod;
		change(1, n, y, x, 1);
		cout << tr[1] << '\n';
	}
}
```

---

## 作者：蒟蒻君HJT (赞：4)

 P4340 [SHOI2016]随机序列
 
题解区竟然没有动态 dp 的做法，我来水一发题解。
 
线段树大水题。然而我强行把它做成了动态 dp 模板题。
这个题第一眼看上去很容易慌，但是冷静下来发现一车东西都会被消去。

设 $f_i$ 表示考虑到第 $i$ 个数字，所有答案的和。那么我们枚举最后一段连续乘积乘到哪里，因为加减号的存在，最后一段连续乘积只要不是一直乘到开头，就全部会被消去。

具体来说，存在转移方程：

$f_i=2\sum_{j=0}^{i-1}f_j + \prod_{i=1}^{n}a_i$ ；
$f_0=0$ 。

使用前缀和优化转移。

设 $s_i=\sum_{j=0}^{i}f_j$，
存在转移方程：

$s_i=3 s_{i-1}+a_i\prod_{j=1}^{i-1}a_j$ 。

那么答案即为 $s_i-s_{i-1}$ 。

再使用矩阵乘法优化转移。

设 $m_i=\prod_{j=1}^i a_j$ ，存在转移矩阵：

$\begin{bmatrix} s_i & m_i \end{bmatrix}=\begin{bmatrix} s_{i-1} & m_{i-1} \end{bmatrix}\cdot \begin{bmatrix} 3 & 0 \\ a_i & a_i \end{bmatrix}$ 。初始矩阵：$\begin{bmatrix} s_0 & m_0 \end{bmatrix}= \begin{bmatrix} 0 & 1 \end{bmatrix}$ 。

用线段树维护矩阵区间乘法，发现每次修改 $a_i$ 即为修改 $\log n$ 个矩阵乘积，可以高效动态维护。时间复杂度 $O(m^3q\log n)$ ，其中 $m=2$ ，常数较小。**这种做法相比较组合计数的方法规避了必须存在逆元的缺点。**

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
const long long mod=1e9+7;
long long n,q,a[100005],dp[100005],mul[100005];
struct Matrix{
	long long A[3][3];
	void _clear(){memset(A,0,sizeof A);return ;}
};
Matrix T[400005];
inline Matrix operator*(Matrix x,Matrix y){
	Matrix z;z._clear();
	for(long long i=1;i<=2;++i){
		for(long long j=1;j<=2;++j){
			for(long long k=1;k<=2;++k){
				z.A[i][j]+=x.A[i][k]*y.A[k][j];
				z.A[i][j]%=mod;
			}
		}
	}
	return z;
}
void Build_tree(long long x,long long l,long long r){
	if(l==r){
		T[x].A[1][1]=3ll,T[x].A[1][2]=0ll,
		T[x].A[2][1]=a[l],T[x].A[2][2]=a[l];
		return ;
	}
	long long mid=l+r>>1ll;
	Build_tree(x<<1ll,l,mid);
	Build_tree(x<<1ll|1ll,mid+1ll,r);
	T[x]=T[x<<1ll]*T[x<<1ll|1ll];
	return ;
}
void Modify_tree(long long x,long long l,long long r,long long t){
	if(l==r){
		T[x].A[2][1]=a[l],T[x].A[2][2]=a[l];
		return ;
	}
	long long mid=l+r>>1ll;
	if(t<=mid) Modify_tree(x<<1ll,l,mid,t);
	else Modify_tree(x<<1ll|1ll,mid+1ll,r,t);
	T[x]=T[x<<1ll]*T[x<<1ll|1ll];
	return ;
}
Matrix Ask_tree(long long x,long long l,long long r,long long L,long long R){
	if(l==L && r==R) return T[x];
	long long mid=l+r>>1ll;
	if(R<=mid) return Ask_tree(x<<1ll,l,mid,L,R);
	else if(L>=mid+1ll) return Ask_tree(x<<1ll|1ll,mid+1ll,r,L,R);
	else return Ask_tree(x<<1ll,l,mid,L,mid)*Ask_tree(x<<1ll|1ll,mid+1,r,mid+1,R);
}
int main(){
	scanf("%lld%lld",&n,&q);
	long long x,y,X,Y;
	for(long long i=1;i<=n;++i) scanf("%lld",&a[i]);
	Build_tree(1,1,n);
	for(long long j=1;j<=q;++j){
		scanf("%lld%lld",&x,&y);
		a[x]=y;
		Modify_tree(1,1,n,x);
		X=T[1].A[2][1];
		Y=Ask_tree(1,1,n,1,n-1).A[2][1];
		printf("%lld\n",(X-Y+mod)%mod);
	}
	return 0;
}
```


---

## 作者：Bitter_Tea (赞：4)

基本思路是**线段树维护区间积**

我们发现


两个数$a_1$,$a_2$,经过化简$ans=2a_1+a_1a_2$

三个数$a_1,a_2,a_3$,经过化简$ans=6a_1+2a_1a_2+a_1a_2a_3$

......

由于其他的项已经加减抵消，我们类比推广一下，

发现$ans=\sum_{i=1}^{n-1}2 \times3^{n-i-1}\times s_i +s_n$,其中$s_n=\prod_{i=1}^na_i$



这时候大多数童鞋都想到了用线段树来维护前缀积,又因为有 $mod$操作,所以我们预处理出逆元。


但是，要知道数据只保证$a_i$是非负整数，也就是说$a_i$可以为 $0$,$0$没有逆元！！所以这种做法是不对的。


我们其实可以直接线段树单点修改，维护区间积和区间对于答案的贡献，剩下的就是线段树的基本操作，在此不在赘述。




$Code$

```cpp
#include<cstdio>
#define ll long long
#define lc (o<<1)
#define rc (o<<1|1)
using namespace std;
const int N=100005,p=1e9+7;
struct D{ll mul,ans;int l,r;}e[N<<2];
ll a[N],s[N];
int n,q;
void build(int o,int l,int r)
{
	e[o].l=l;e[o].r=r;
	if(l==r)
	{
		e[o].mul=a[r];
		if(r==n) e[o].ans=a[r];
		else e[o].ans=2ll*s[n-r-1]*a[r]%p;
		return;
	}
	int mid=l+r>>1;
	build(lc,l,mid);
	build(rc,mid+1,r);
	e[o].mul=(e[lc].mul*e[rc].mul)%p;
	e[o].ans=(e[lc].mul*e[rc].ans%p+e[lc].ans)%p;
}
void update(int o,int x,int k)
{
	if(e[o].l==e[o].r)
	{
		e[o].mul=k;
		if(e[o].r==n) e[o].ans=k;
		else e[o].ans=2ll*s[n-e[o].r-1]*k%p;
		return;
	}
	int mid=e[o].l+e[o].r>>1;
	if(x<=mid) update(lc,x,k);
	if(x>mid) update(rc,x,k);
	e[o].mul=e[lc].mul*e[rc].mul%p;
	e[o].ans=(e[lc].mul*e[rc].ans%p+e[lc].ans)%p;
}
int main()
{
	scanf("%d%d",&n,&q);
	for(int i=1;i<=n;i++)
	scanf("%lld",&a[i]);
	s[0]=1;
	for(int i=1;i<=n;i++)
	s[i]=s[i-1]*3%p;
	build(1,1,n);
	while(q--)
	{
		int x,k;
		scanf("%d%d",&x,&k);
		update(1,x,k);
		printf("%lld\n",e[1].ans);
	}
	return 0;
}

```


---

## 作者：_Xiuer (赞：2)

[题目传送门](https://www.luogu.com.cn/problem/P4340)

【思路】

推规律+线段树维护

我们可以手玩几个样例：

3 3

1 2 3

我们会发现除了第一项以外,其他的项都是会加减相消的,所以我们只需要考虑乘法,设 $s_i=a_1*a_2*...*a_i$, 那对于每个$s_i$的贡献就是$s_i*2*3^{n-i-1}$项,对于最后一项$s_n$的贡献就是$s_n$.

然后我们考虑修改操作，我们修改一个数只会影响它和以后的前缀积，我们考虑线段树维护每个区间的贡献,那$t_1$就是整个序列的贡献.我们进行修改后,实际上就是改变了这个值以后的区间的贡献,我们让这个区间和先除以改变前的值,再乘上改变后的值,但我们过程中mod掉了,我们没办法直接除一个数,所以我们求一个逆元来进行这项操作。

 注：开始时要将所有的 lazy  标记设为 1。
```cpp
#include<iostream>
#include<cstdio>
#define mod 1000000007
#define N 100010
#define ll long long
using namespace std;
ll n,q,a[N],ans,w[N],jny[N],ny[N],maxx,sum[N],tz[N];
struct Node{
	ll mul,lazy;
	int l,r;
} s[N*4];
void re(ll &x)
{
	x=0;
	char i=getchar();
	while(i<'0'||i>'9') i=getchar();
	while(i>='0'&&i<='9') x=(x<<1)+(x<<3)+i-'0',i=getchar();
}
ll ksm(ll a,ll b)
{
	ll total=1;
	while(b)
	{
		if(b&1) total=(total*a)%mod;
		a=(a*a)%mod;
		b>>=1;
	}
	return total%mod;
}
void build(int p,int l,int r)
{
	s[p].l=l;
	s[p].r=r;
	if(l==r)
	{
		if(n-l-1<0) s[p].mul=w[l];
		else s[p].mul=w[l]*2*tz[n-l-1];
		s[p].mul%=mod;
		s[p].lazy=1;
		return;
	}
	int mid=(l+r)/2;
	build(p<<1,l,mid);
	build(p<<1|1,mid+1,r);
	s[p].mul=(s[p<<1].mul+s[p<<1|1].mul)%mod;
	s[p].lazy=1;
}
void pushdown(int p)
{
	s[p<<1].lazy*=s[p].lazy;
	s[p<<1].lazy%=mod;
	if(!s[p<<1].lazy) s[p<<1].lazy=1;
	s[p<<1].mul*=s[p].lazy;
	s[p<<1].mul%=mod;
	s[p<<1|1].lazy*=s[p].lazy;
	s[p<<1|1].lazy%=mod;
	if(!s[p<<1|1].lazy) s[p<<1|1].lazy=1;
	s[p<<1|1].mul*=s[p].lazy;
	s[p<<1|1].mul%=mod;
	s[p].lazy=1;
}
void update(int p,int l,int r,ll xny)
{
	if(s[p].l>=l&&s[p].r<=r)
	{
		s[p].mul*=xny;
		s[p].mul%=mod;
		s[p].lazy*=xny;
		s[p].lazy%=mod;
		if(!s[p].lazy) s[p].lazy=1;
		return;
	}
	if(s[p].lazy>1) pushdown(p);
	int mid=(s[p].l+s[p].r)/2;
	if(l<=mid) update(p<<1,l,r,xny);
	if(r>mid) update(p<<1|1,l,r,xny);
	s[p].mul=(s[p<<1].mul+s[p<<1|1].mul)%mod;
}
int main()
{
//	freopen("rand.in","r",stdin);
//	freopen("rand.out","w",stdout);
	re(n);re(q);
	w[0]=1;sum[0]=1;
	ny[1]=1;tz[0]=1;
	for(int i=1; i<=n; i++) 
	tz[i]=tz[i-1]*3,tz[i]%=mod;
	for(int i=1; i<=n; i++)
	{
		re(a[i]);
		w[i]=w[i-1]*a[i];
		w[i]%=mod;
		maxx=max(maxx,a[i]);
	}
	for(int i=1; i<=maxx; i++) sum[i]=sum[i-1]*i,sum[i]%=mod;
	jny[maxx]=ksm(sum[maxx],mod-2);
	for(int i=maxx-1; i>=1; i--)
	jny[i]=jny[i+1]*(i+1)%mod;
	for(int i=2; i<=maxx; i++)
	ny[i]=jny[i]*sum[i-1]%mod;
	ll x,y;
	build(1,1,n);
	for(int i=1; i<=q; i++)
	{
		re(x);
		re(y);
		update(1,x,n,ny[a[x]]*y%mod);
		a[x]=y;
		printf("%I64d\n",s[1].mul%mod);
	}
	return 0;
}

---

## 作者：GIFBMP (赞：2)

我们把表达式拆成若干个乘法段，我们发现，第一段的系数必然为正，而后面若干段的系数必然存在一个表达式与其相抵消，所以我们只用考虑第一段的贡献。

我们设 $p_i=\prod_{j=1}^ia_j$，显然有：

$$ans=\sum_{i=1}^{n-1}p_i\times2\times3^{n-i-1}+p_n$$

于是建立线段树，进行区间乘法，同时维护区间和即可。

然而可能存在 $a_i\equiv0\ (\bmod{\ 10^9+7})$ 的情况，这时候区间乘法就会被卡掉。

于是我们考虑直接单点修改。

我们记 $mul$ 表示区间积，$ans$ 表示答案。

显然有：

$$mul_o=mul_{lc}\times mul_{rc}$$

然后我们分类讨论，发现前缀积可能完全位于左区间，也可能跨越左区间，则：

$$ans_o=ans_{lc}+mul_{lc}\times ans_{rc}$$

Code:

```cpp
#include <cstdio>
#define lc (o << 1)
#define rc (o << 1 | 1)
using namespace std ; 
typedef long long ll ;
const int MAXN = 1e5 + 10 , mod = 1e9 + 7 ;
struct sgt {
	ll mul , ans ;
	int l , r ;
} t[MAXN << 2] ;
int n , q ; 
ll a[MAXN] , pw[MAXN] ;
void build (int o , int l , int r) {
	t[o].l = l ; t[o].r = r ;
	if (l == r) {
		t[o].mul = a[l] ;
		if (l == n) t[o].ans = a[l] ;
		else t[o].ans = 2LL * a[l] * pw[n - l - 1]  % mod ;
		return ;
	}
	int mid = l + r >> 1 ;
	build (lc , l , mid) ;
	build (rc , mid + 1 , r) ;
	t[o].mul = t[lc].mul * t[rc].mul % mod ;
	t[o].ans = (t[lc].mul * t[rc].ans % mod + t[lc].ans) % mod ;
}
void update (int o , int x , int k) {
	if (t[o].l == t[o].r) {
		t[o].mul = k ;
		if (t[o].l == n) t[o].ans = k ;
		else t[o].ans = 2LL * k * pw[n - t[o].l - 1]  % mod ;
		return ;
	}
	int mid = t[o].l + t[o].r >> 1 ;
	if (x <= mid) update (lc , x , k) ;
	else update (rc , x , k) ;
	t[o].mul = t[lc].mul * t[rc].mul % mod ;
	t[o].ans = (t[lc].mul * t[rc].ans % mod + t[lc].ans) % mod ;
}
int main () {
	scanf ("%d %d" , &n , &q) ;
	for (int i = 1 ; i <= n ; i++)
		scanf ("%lld" , &a[i]) ;
	pw[0] = 1 ;
	for (int i = 1 ; i <= n ; i++)
		pw[i] = pw[i - 1] * 3 % mod ;
	build (1 , 1 , n) ;
	while (q--) {
		int x , k ;
		scanf ("%d %d" , &x , &k) ;
		update (1 , x , k) ;
		printf ("%lld\n" , t[1].ans) ;
	}
	return 0 ;
}
```

---

## 作者：x义x (赞：2)

## 前排警告一大波辣鸡排版可能会损害您的视力

首先先考虑如果不修改该怎么办。

注意到像：

$$a_1*a_2*a_3+a_4*a_5-a_6*a_7*a_8*a_9$$

的式子一定会有一个对称的：

$$a_1*a_2*a_3-a_4*a_5+a_6*a_7*a_8*a_9$$

把除了$a_1*a_2*a_3$的其他东西全部消掉。

也就是说除了第一段“乘法段”一定会是正的以外其他的部分都会被消掉。

事实上，最终所有可能式子的加和只能是

$$\text{数个}\ a_1+\text{数个}\ a_1*a_2+\text{数个}\ a_1*a_2*a_3+…$$

对于$a_1*a_2*…*a_i$，后面还有$n-i$个符号要填，但是下一个决不能是乘号（否则就要算进$a_1*a_2*…*a_i*a_{i+1}$了），所以有$2*3^{n-i-1}$种可能的填法。只有$a_1*a_2*…*a_n$比较特殊，它只有一个。

设$S_i=a_1*a_2*…*a_n$，答案就是

$$S_1*2*3^{n-2}+S_2*2*3^{n-3}+…+S_{n-1}*2*3^0+S_n$$

------------

再看一下修改该怎么办。

一个显然的想法是用线段树，线段树维护区间和的每个元素是$S_i*2*3^{n-i-1}$，$sum[x]=S_l*2*3^{n-l-1}+…+S_r*2*3^{n-r-1}$（但要注意$S_n$的特殊性），每次改$a_i$为$A_i$就对$[i,n]$的元素除以$a_i$（乘以$a_i$的逆元）再乘以$A_i$。

然而题目里说$a_i,A_i$都可以是0，而0没有逆元，从0修改至其他正数会完蛋，以上方法是会WA的，然而题目里并没有这种毒瘤数据……

所以当然我们还有一个办法。我们改成单点修改，

$$sum=a_l*2*3^{n-l-1}+a_l*a_{l+1}*2*3^{n-l-2}+……+a_l*…*a_r*2*3^{n-r-1}$$

（务必看清）

（但要注意$n=r$时特殊情况）

显然$l=1,r=n$时就是我们要查询的那玩意。

在原先的基础上再加一个$mul[\ ]$数组，表示区间的$a_i$的乘积。容易写出：

$$mul[x]=mul[x*2]*mul[x*2+1]$$

$$sum[x]=sum[x*2+1]*mul[x*2]+sum[x*2]$$

这样就完美满足区间加法了。

代码如下：

```cpp
#include<bits/stdc++.h>
#define ull unsigned long long
using namespace std;

const int TT=1000000007,maxN=100005;

int N,Q,A[maxN],POW3[maxN];

int MUL[maxN*4],ANS[maxN*4];
void push_up(int x){
    MUL[x]=((ull)MUL[x*2]*MUL[x*2+1])%TT;
    ANS[x]=(((ull)MUL[x*2]*ANS[x*2+1])%TT+ANS[x*2])%TT; 
}
void Build(int x,int l,int r){
    if(l==r){
        MUL[x]=A[l];
        if(l==N)
            ANS[x]=A[l];
        else
            ANS[x]=((ull)A[l]*2)%TT*POW3[N-l-1]%TT;
        return;
    }
    int mid=(l+r)/2;
    Build(x*2,l,mid);Build(x*2+1,mid+1,r);
    push_up(x);
} 
void Update(int x,int l,int r,int POS,int K){
    if(l==r){
        A[l]=K;
        MUL[x]=K;
        if(l==N)
            ANS[x]=A[l];
        else
            ANS[x]=((ull)A[l]*2)%TT*POW3[N-l-1]%TT;
        return;	
    }
    int mid=(l+r)/2;
    if(POS<=mid) Update(x*2,l,mid,POS,K);
    else Update(x*2+1,mid+1,r,POS,K);
    push_up(x);
}

int main(){
    scanf("%d%d",&N,&Q);
    for(int i=1;i<=N;i++) scanf("%d",&A[i]);
    POW3[0]=1;
    for(int i=1;i<=N;i++) POW3[i]=((ull)POW3[i-1]*3)%TT;
    
    Build(1,1,N);
    
    while(Q--){
        int POS,K;scanf("%d%d",&POS,&K);
        Update(1,1,N,POS,K);
        printf("%d\n",ANS[1]);
    }
}
```


---

## 作者：ZepX_D (赞：1)

### 思路
提供另一种动态 dp 做法

首先考虑线性递推式，我们设 $f_{i,0/1/2}$ 分别为 $a_{i-1}$ 和 $a_i$ 之间填的 $+/-/\times$ 的表达式总和。

容易得到以下式子

$$\begin{cases}f_{i,0} = f_{i-1,0}+f_{i-1,1}+f_{i-1,2}+a_i\times3^{i-2}\\f_{i,1} = f_{i-1,0}+f_{i-1,1}+f_{i-1,2}-a_i\times3^{i-2}\end{cases}$$

但是 $f_{i,2}$ 似乎因为乘法的优先级较高而难以处理，那我们先不考虑 $a_{i-2}$ 和 $a_{i-1}$ 之间为 $\times$，即连乘的情况，考虑 $a_{i-2}$ 和  $a_{i-1}$ 之间填的为 $+/-$，那么这时有 

$$f_{i,2} = f_{i-1,0}-a_{i-1}\times3^{i-2}+a_{i-1}\times a_i\times3^{i-2}+f_{i-1,1}+a_{i-1}\times3^{i-2}-a_{i-1}\times a_i\times3^{i-2}$$

发现后面的都消掉了，即 $f_{i,2} = f_{i-1,0}+f_{i-1,1}$ 。

现在考虑连乘的情况，设连乘的第一个乘号在第 j 位出现，即 $a_j\times a_{j+1}\times \dots\times a_i$，那么此时 $f_{i,2}$ 要加上 $f_{j-1,0}+f_{j-1,1}$，类比上面两个数相乘，后面那一坨连乘的贡献都能消掉，同时还有一种情况是从 $a_1$ 一直乘到 $a_i$，此时的贡献为 $\prod\limits_{j=1}^i a_i$，所以得出最终式子 
$$f_{i,2} = \sum\limits_{j = 2}^{i-1} f_{j,0}+f_{j,1} + \prod\limits_{j=1}^i a_i$$ 

这两个东西一个前缀和，一个前缀积，扫的时候同时计算出来就好，此时时间复杂度 $O(nq)$，50pts [代码](https://www.luogu.com.cn/record/147986766) 。

考虑给他弄成矩阵相乘，令 $s1  = \sum\limits_{j = 2}^{i-1} f_{j,0}+f_{j,1},s2 = \prod\limits_{j=1}^i a_i$，容易得到转移矩阵

$$\begin{bmatrix}f_{i-1,0}&f_{i-1,1}&f_{i-1,2}&s1&s2&3^{i-2}\end{bmatrix} \times \begin{bmatrix}1&1&0&2&0&0\\1&1&0&2&0&0\\1&1&0&2&0&0\\0&0&1&1&0&0\\0&0&a_i&0&a_i&0\\a_i&-a_i&0&0&0&3\end{bmatrix} = \begin{bmatrix}f_{i,0}&f_{i,1}&f_{i,2}&s1&s2&3^{i-1}\end{bmatrix}$$

值得注意

$$s1 = s1+f_{i,0}+f_{i,1} = s1+2\times(f_{i-1,0}+f_{i-1,1}+f_{i-1,2})$$

$$f_{i,2} = s1+s2\times a_i$$ 

最后用线段树维护矩阵乘积即可，甚至只用写单点修改。

### code

因为我们有着优秀的 $6^3$ 的常数，所以记得吸氧
```cpp
#include <bits/stdc++.h>
#define LL long long

using namespace std;

const int P = 1e9+7,N = 1e5+5;
int n;

struct squ
{
	LL a[6][6];
	squ(){memset(a,0,sizeof(a));}
	void set(){a[0][0] = a[0][1] = a[1][0] = a[1][1] = a[2][0] = a[2][1] = a[3][2] = a[3][3] = 1,a[0][3] = a[1][3] = a[2][3] = 2,a[5][5] = 3;}
	void build(int k){a[5][0] = a[4][2] = a[4][4] = k,a[5][1] = -k;}
	squ operator *(const squ &b) const
	{
		squ c;
		for (int k = 0;k < 6;k++)
			for (int i = 0;i < 6;i++)
				for (int j = 0;j < 6;j++)
					c.a[i][j] = (c.a[i][j]+a[i][k]*b.a[k][j])%P;
		return c;
	}
}a[N],E;

struct tree{int l,r;squ t;}tr[N<<2];

void build(int l,int r,int i)
{
	tr[i].l = l,tr[i].r = r;
	if (l == r) return void(tr[i].t = a[l]);
	int mid = (l+r)>>1;
	build(l,mid,i<<1),build(mid+1,r,i<<1|1);
	tr[i].t = tr[i<<1].t*tr[i<<1|1].t;
}

void M(int p,int k,int i)
{
	if (tr[i].l == tr[i].r) return void(tr[i].t.build(k));
	if (p <= tr[i<<1].r) M(p,k,i<<1);
	else M(p,k,i<<1|1);
	tr[i].t = tr[i<<1].t*tr[i<<1|1].t;
}

int main()
{
	ios::sync_with_stdio(0);
	int Q;cin >> n >> Q;
	E.a[0][5] = 1;
	for (int i = 1,k;i <= n;i++)
	{
		cin >> k;
		if (i == 1) E.a[0][0] = E.a[0][4] = k;
		else {a[i-1].set();a[i-1].build(k);}
	}
	build(1,n-1,1);
	while(Q--)
	{
		int t,v;cin >> t >> v;
		if (t == 1) E.a[0][0] = E.a[0][4] = v;
		else M(t-1,v,1);
		squ ans = E*tr[1].t;
		cout << ((ans.a[0][0]+ans.a[0][1]+ans.a[0][2])%P+P)%P << '\n';
	}
	return 0;
}
```

### Extra
如果你不想吸氧，[Link](https://www.luogu.com.cn/record/148037000)，采用了[这篇博客](https://www.luogu.com.cn/blog/188286/solution-p4340)中的小优化。

---

## 作者：Focus_on (赞：1)

这题是个推柿子题

大概讲讲心路历程：

首先，看到这种题目我的第一反应是 dp，但是好像 dp 不可做，~~因为我怎么也写不出转移方程~~

然后开始考虑有没有一些奇技淫巧。

推推数学式子。

考虑 $A={a1,a2,a3,...,an}$ ，那么其实考虑其中的一项 $ak$ 的后面，会有一个空格，其中可以填任意的符号，那么其实不难想到，如果此处填加号的情况就会和减号的情况对于**后面**的贡献值正好抵消，也即可以看出对于一个已有符号的序列来说，只有最前面的连续乘号会对整个序列的值有贡献。

现在来计算贡献大小。

设 $Mul_i=\prod\limits_{j=1}^i a_j$ ，那么因为后面都约掉了，而后一个空有 $2$ 种选择（加或减），其他后面的空会有 $3$ 种选择（加或减或乘），则贡献值应该为 $s_i=2*3^{n-i-1}*Mul_i$

所以我们只要维护一个前缀积的区间和就好了

---

桥豆麻袋，尽管这样写出来的代码交上去是能够对的，但是是因为题目太水了，题目中本身只保证是非负整数而非正整数，所以如果有一次修改成了 0 之后后面就很难再搞了。

因此，我们重新考虑回单点修改。

考虑如何将左子区间和右子区间合并：

首先明显的，乘积有
$$Mul_x=Mul_{lc[x]}*Mul_{rc[x]}$$

然后呢，我们的答案本来是

$$Ans_x=2\times3^{n-l-1}\times s_i$$

合并时就可以发现，因为它是前缀积，所以我们如果要把右子区间段的真实值求出，要将它乘上左子区间的乘积，而左子区间是不变的（感性理解一下）

也即

$$Ans_x=Ans_{lc[x]}+Ans_{rc[x]}\times Mul_{lc[x]}$$

初始条件很容易处理，看代码

于是乎就愉快的做完了~

```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>

using namespace std;

const int N=100010;
const int M=10010;
const int p=1e9+7;

typedef long long ll;

ll pow3[N];

int a[N],n,q,t,m;

int lc[N<<2],rc[N<<2],cnt;
ll s1[N<<2],s2[N<<2];

void build(int x,int l,int r){
	
	if(l==r){
		
		s1[x]=a[l];
		
		if(l==n)
			s2[x]=a[l];
		else
			s2[x]=2ll*pow3[n-l-1]*a[l]%p;
		
		return;
	}
	
	int mid=l+r>>1;
	
	++cnt;
	lc[x]=cnt;
	build(lc[x],l,mid);
	
	++cnt;
	rc[x]=cnt;
	build(rc[x],mid+1,r);
	
	s1[x]=(s1[lc[x]]*s1[rc[x]])%p;
	s2[x]=(s2[rc[x]]*s1[lc[x]]%p+s2[lc[x]])%p;
}

void modify(int x,int l,int r,int t,int m){
	
	if(l==r){
		
		s1[x]=a[l]=m;
		
		if(l==n)
			s2[x]=a[l];
		else
			s2[x]=2ll*pow3[n-l-1]*a[l]%p;
		
		return;
	}
	
	int mid=l+r>>1;
	
	if(t<=mid)   modify(lc[x],l,mid,t,m);
	if(t>=mid+1) modify(rc[x],mid+1,r,t,m);
	
	s1[x]=(s1[lc[x]]*s1[rc[x]])%p;
	s2[x]=(s2[rc[x]]*s1[lc[x]]%p+s2[lc[x]])%p;
}

int main(){
	
	scanf("%d%d",&n,&q);
	
	pow3[0]=1;
	for(int i=1;i<=n;i++) pow3[i]=pow3[i-1]*3%p;
	
	for(int i=1;i<=n;i++) scanf("%d",&a[i]);
	
	cnt=1;
	build(1,1,n);
	
	while(q--){
		scanf("%d%d",&t,&m);
		modify(1,1,n,t,m);
		printf("%lld\n",s2[1]);
	}
	
	return 0;
}
```
说实话，我打线段树的板子是这种看着比较清爽的。

码风如果不合口味轻喷

---

## 作者：_ctz (赞：1)

[获取更好的阅读体验$QwQ$](https://ctz45562.github.io/2019/03/12/%E9%A2%98%E8%A7%A3-%E6%B4%9B%E8%B0%B7-P4340-%E3%80%90-SHOI2016-%E9%9A%8F%E6%9C%BA%E5%BA%8F%E5%88%97%E3%80%91/)

[传送门](https://www.luogu.org/problemnew/show/P4340)

这种题一般就慢慢推式子吧。。。


对一个数列，在任意添加符号时候你会发现，**某个数字前面有多少种情况添加加号，就有多少种情况添加减号，就会相互抵消**。而第一个数字前面加不了东西，不受这个规律影响。

所以经过一系列合并最后剩下的一定是若干个前缀乘（类比于前缀和）的和。

所以前缀乘组合情况是怎么样的呢？令$g(i)=\prod\limits_{i=1}^{n}a[i]$，即前缀乘。

假设数列有$5$个数字，为$a,b,c,d,e$。$g(5)=a*b*c*d*e$。显然$g(5)$只会出现$1$次。

把最后一个乘号替换为加号和减号，$a*b*c*d+e$和$a*b*c*d-e$就会相加相互抵消，得到$2$个$g(4)$。

再把$g(5)$和$g(4)$的每种情况的倒数第二个乘号替换为加号和减号，相加后就会得到$6$个$g(3)$。以此类推，有$18$个$g(2)$，$54$个$g(1)$。这样规律就比较明显了：**每个$g(i)$都珂以由$g(k)(i<k\le n)$修改对应位置的乘号，得到$2$个$g(i)$。**

定义函数$f(i)=\begin{cases}1&i=1\\\sum\limits_{j=1}^{i-1}f(j)*2&i>1\end{cases}$

答案就是 $ans=\sum\limits_{i=1}^{i\le n}g(i)*f(n-i+1)$

~~（其实这个规律完全可以爆搜用瞪眼法得出来）~~

$f(i)$和$g(i)$珂以直接预处理出来，然后直接上线段树维护，每个节点维护所代表区间的$\sum\limits_{i=l}^{r}g(i)*f(n-i+1)$。

对于修改：比如还是那五个数，要修改第三个数$c$为$k$。类似于前缀和，单点修改影响的是$g(3),g(4),g(5)$，也就是要把

$f(3)*a*b*c+f(2)*a*b*c*d+f(1)*a*b*c*d*e$

修改为

$f(3)*a*b*k+f(2)*a*b*k*d+f(1)*a*b*k*d*e$

就珂以把原式乘上$\frac{k}{c}$。有除法还要取模显然要用到乘法逆元，即为把带修点到$n$的区间乘上$k*inv(c)$，就是个线段树区间乘。

代码：

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <cstring>

#define maxn 100005
#define inf 0x3f3f3f3f

const long long mod = 1000000007;

using namespace std;

inline int read(){
	int x=0,y=0;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')y=1;ch=getchar();}
	while(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
	return y?-x:x;
}
template<typename T>
inline T read(){
	T x=0;
	int y=0;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')y=1;ch=getchar();}
	while(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
	return y?-x:x;
}
int n,a[maxn];
long long f[maxn],g[maxn],inv[maxn]={0,1};
struct Segment_Tree{
	long long dat[maxn<<2],tag[maxn<<2];
#define ls(x) (x<<1)
#define rs(x) (x<<1|1)
	inline void update(int node){
		dat[node]=(dat[ls(node)]+dat[rs(node)])%mod;
	}
	inline void datadown(int node,long long d){
		(dat[node]*=d)%=mod;
		(tag[node]*=d)%=mod;
	}
	inline void pushdown(int node){
		datadown(ls(node),tag[node]);
		datadown(rs(node),tag[node]);
		tag[node]=1;
	}
	void build(int l,int r,int node){
		tag[node]=1;
		if(l==r){
			dat[node]=g[l]*f[n-l+1]%mod;
			return;
		}
		int mid=l+r>>1;
		build(l,mid,ls(node));
		build(mid+1,r,rs(node));
		update(node);
	}
	void add(int L,int R,int l,int r,int node,long long d){
		if(L<=l&&R>=r){
			datadown(node,d);
			return;
		}
		if(tag[node]!=1)pushdown(node);
		int mid=l+r>>1;
		if(L<=mid)add(L,R,l,mid,ls(node),d);
		if(R>mid)add(L,R,mid+1,r,rs(node),d);
		update(node);
	}
}st;
int main(){
	for(register int i=2;i<=10000;++i)
		inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;//数据范围是允许预处理出逆元的
	n=read();
    int m=read();
	long long sum=1;
	f[1]=1,g[0]=1;
	for(register int i=2;i<=n;++i)
		f[i]=(sum<<1)%mod,(sum+=f[i])%=mod;//预处理f数组
	for(register int i=1;i<=n;++i)
		a[i]=read(),g[i]=g[i-1]*a[i]%mod;//预处理前缀乘
	st.build(1,n,1);
	while(m--){
		int x=read(),d=read();
		st.add(x,n,1,n,1,1ll*d*inv[a[x]]%mod);
		printf("%lld\n",st.dat[1]);
		a[x]=d;
	}
}

```



---

## 作者：zhangxy__hp (赞：0)

~~简单~~手摸后发现，答案就是这么一个式子：

$$
(3^{n-1}-3^{n-2})a_1+(3^{n-2}-3^{n-3})a_1a_2+\dots+(3^1-3^0)a_1a_2\dots a_{n-1}+a_1a_2\dots a_n
$$

啊当然证明也是好证的，对于 $a_1$ 这一项，它后面放 `+` 或 `-` 都会对系数加一，而放 `*` 不会影响系数，因此系数就是总数的三分之二。其它前缀乘积的系数都是类似的算法。

然后为什么没有别的项了呢？可以认为 `*` 不产生贡献，而 `+` 和 `-` 是相同数量的，因此都消掉了。

简单预处理，修改时取逆元区间乘就行了。

但其实不行，因为输入的是**非负数**，而不是**正整数**，而 $0$ 是没逆元的。

观察式子，发现从第一个 $0$ 往后的项就都是 $0$ 了。因此可以用一个 `set` 来维护 $0$ 的位置。操作时正常操作，把 $0$ 当成 $1$ 就行了。查询时只查 $1$ 到第一个 $0$ 的位置前面。

```cpp
#include<bits/stdc++.h>
#define ll long long
#define il inline
#define read(x){\
	char ch;\
	int fu=1;\
	while(!isdigit(ch=getchar()))\
		fu-=(ch=='-')<<1;\
	x=ch&15;\
	while(isdigit(ch=getchar()))\
		x=(x<<1)+(x<<3)+(ch&15);\
	x*=fu;\
}
#define lid id<<1
#define rid id<<1|1
using namespace std;
namespace asbt{
namespace cplx{bool begin;}
const int maxn=1e5+5,mod=1e9+7;
int n,m,a[maxn],b[maxn],pw3[maxn];
int sum[maxn<<2],tag[maxn<<2];
il void pushup(int id){
	sum[id]=(sum[lid]+sum[rid])%mod;
}
il void pushtag(int id,int val){
	tag[id]=tag[id]*1ll*val%mod;
	sum[id]=sum[id]*1ll*val%mod;
}
il void pushdown(int id){
	if(tag[id]>1){
		pushtag(lid,tag[id]);
		pushtag(rid,tag[id]);
		tag[id]=1;
	}
}
il void build(int id,int l,int r){
	tag[id]=1;
	if(l==r){
		sum[id]=a[l];
		return ;
	}
	int mid=(l+r)>>1;
	build(lid,l,mid);
	build(rid,mid+1,r);
	pushup(id);
}
il void upd(int id,int L,int R,int l,int r,int val){
	if(L>=l&&R<=r){
		pushtag(id,val);
		return ;
	}
	pushdown(id);
	int mid=(L+R)>>1;
	if(l<=mid){
		upd(lid,L,mid,l,r,val);
	}
	if(r>mid){
		upd(rid,mid+1,R,l,r,val);
	}
	pushup(id);
}
il int query(int id,int L,int R,int l,int r){
	if(L>=l&&R<=r){
		return sum[id];
	}
	pushdown(id);
	int mid=(L+R)>>1,res=0;
	if(l<=mid){
		(res+=query(lid,L,mid,l,r))%=mod;
	}
	if(r>mid){
		(res+=query(rid,mid+1,R,l,r))%=mod;
	}
	return res;
}
il void debug(int id,int l,int r){
	cout<<id<<" "<<l<<" "<<r<<" "<<sum[id]<<"\n";
	if(l==r){
		return ;
	}
	pushdown(id);
	int mid=(l+r)>>1;
	debug(lid,l,mid);
	debug(rid,mid+1,r);
}
il int qpow(int x,int y){
	int res=1;
	while(y){
		if(y&1){
			res=res*1ll*x%mod;
		}
		x=x*1ll*x%mod,y>>=1;
	}
	return res;
}
set<int> zero;
namespace cplx{
	bool end;
	il double usdmem(){return (&begin-&end)/1048576.0;}
}
int main(){
	read(n)read(m);
	pw3[0]=1;
	for(int i=1;i<=n;i++){
		read(a[i]);
		if(!a[i]){
			a[i]=1;
			zero.insert(i);
		}
		b[i]=a[i];
		pw3[i]=pw3[i-1]*3ll%mod;
	}
	zero.insert(n+1);
	for(int i=n;i;i--){
		(pw3[i]+=mod-pw3[i-1])%=mod;
	}
	for(int i=2;i<=n;i++){
		a[i]=a[i]*1ll*a[i-1]%mod;
	}
	for(int i=1;i<=n;i++){
		a[i]=a[i]*1ll*pw3[n-i]%mod;
	}
	build(1,1,n);
	while(m--){
		int pos,val;
		read(pos)read(val);
		zero.erase(pos);
		if(!val){
			val=1,zero.insert(pos);
		}
		upd(1,1,n,pos,n,val*1ll*qpow(b[pos],mod-2)%mod);
		b[pos]=val;
		printf("%d\n",*zero.begin()==1?0:query(1,1,n,1,*zero.begin()-1));
	}
	return 0;
}
}
int main(){return asbt::main();}
/*
4 1
1 2 3 4
1 2
*/
```

---

## 作者：xiezheyuan (赞：0)

## 简要题意

定义一个长度为 $n$ 的序列 $a$，我们可以在相邻两项间添加加号、减号或乘号。这样可以得到 $3^{n-1}$ 种表达式。定义这个序列的权值为所有表达式求值结果的和。

给出一个长度为 $n$ 的序列 $a$，$m$ 次操作，每次修改一个位置的值，你需要求出此时序列的权值。答案对 $10^9+7$ 取模。

$1\leq n,q\leq 10^5$，保证对于任意时刻，$0\leq a_i\leq 10^4$。

## 思路

有一个非常关键的观察，如果在一个位置填了加号，那么这个位置以后的东西不会对答案产生贡献，因为这个位置我们可以填减号将这些东西消去。又因为第一个数前面不能填符号，所以每一个表达式只有它的前缀积会造成贡献。

于是我们可以 dp。设 $f(i)$ 表示考虑到前缀 $[1,i]$ 的答案，则有：

$$
f(i)=\begin{cases}
f(i-1)+3^{n-i-1}\cdot 2\cdot \prod_{k=1}^{i}a_k& 1\leq i\lt n\\
f(i-1) + \prod_{k=1}^{i}a_k& i=n
\end{cases}
$$

转移思路比较平凡，就是枚举这个符号后面第一个符号有两种选择（加号或减号），然后这个符号后面的就可以随便填了。这样子可以做到单次 $O(n)$。

现在考虑如何做修改。一次修改操作除了会影响 $f(i)$，也会影响前缀积。我们可以尝试用矩阵去维护转移：

$$
\begin{bmatrix}
 \prod_{k=1}^{i-1}a_k & f(i-1)
\end{bmatrix}
\begin{bmatrix}
 a_i & a_i\cdot 2\cdot 3^{n-i-1} \\
 0 & 1
\end{bmatrix}
=
\begin{bmatrix}
 \prod_{k=1}^{i}a_k & f(i)
\end{bmatrix}
$$

当然这里是 $i<n$ 的情况，$i=n$ 的情况是类似的。

于是我们可以在线段树中维护后面的这一个 $2\times 2$ 的转移矩阵的乘积，单点修改是容易的。回答询问的时候只需要用 $\begin{bmatrix}1&0\end{bmatrix}$ 乘上 $n$ 个转移矩阵的乘积即可。

时间复杂度 $O(n+m\log n)$，带有一个 $8$ 倍常数。

## 代码

```cpp
#include <bits/stdc++.h>
#define int long long
#define ls (i << 1)
#define rs (i << 1 | 1)
#define mid ((l + r) >> 1)
using namespace std;

int n, m;
const int mod = 1e9 + 7, N = 1e5 + 5;

int M(int x){ return (x % mod + mod) % mod; }
int Add(int x, int y){ return (x + y) > mod ? (x + y - mod) : (x + y); }

struct matrix{
    int n,m,a[3][3];
    void clear(){memset(a, 0, sizeof(a));}
    void init(int N, int M){n = N, m = M, clear();}
    int* operator[](int p){return a[p];}
};

matrix operator*(matrix a, matrix b){
    matrix ans; ans.init(a.n, b.m);
    for(int k=1;k<=a.m;k++){
        for(int i=1;i<=a.n;i++){
            for(int j=1;j<=b.m;j++) ans[i][j] = Add(ans[i][j], M(1ll * a[i][k] * b[k][j]));
        }
    }
    return ans;
}

matrix t[N << 2];
int pw3[N];

void build(int i, int l, int r){
    if(l == r){
        t[i].init(2, 2);
        int v; cin >> v;
        t[i][1][1] = v;
        t[i][1][2] = M(v * (l == n ? 1 : (pw3[n - l - 1] * 2)));
        t[i][2][1] = 0;
        t[i][2][2] = 1;
        return;
    }
    build(ls, l, mid); build(rs, mid + 1, r);
    t[i] = t[ls] * t[rs];
}

void update(int p, int v, int i, int l, int r){
    if(l == r){
        t[i][1][1] = v;
        t[i][1][2] = M(v * (l == n ? 1 : (pw3[n - l - 1] * 2)));
        return;
    }
    if(p <= mid) update(p, v, ls, l, mid);
    else update(p, v, rs, mid + 1, r);
    t[i] = t[ls] * t[rs];
}

signed main(){
    ios::sync_with_stdio(false);
    cin.tie(0);cout.tie(0);
    cin >> n >> m;
    pw3[0] = 1;
    for(int i=1;i<=n;i++) pw3[i] = Add(pw3[i - 1], Add(pw3[i - 1], pw3[i - 1]));
    build(1, 1, n);
    while(m--){
        int p, v; cin >> p >> v;
        update(p, v, 1, 1, n);
        matrix mat; mat.init(1, 2);
        mat[1][1] = 1; mat[1][2] = 0;
        mat = mat * t[1];
        cout << mat[1][2] << '\n';
    }
    return 0;
}

// Written by xiezheyuan

```

---

## 作者：Uuuuuur_ (赞：0)

这是一道比较简单的结论题。

我们发现，对于一个已经确定的符号序列，可以将所有**极大连续乘积**看成一个数，那么贡献就是这些数加加减减，如果将所有加减号取反，那么产生的这一对符号序列，最终对答案有贡献的是序列开头的极大连乘积。

朴素算法是，枚举开头极大连乘积，$ans=f[n]+\sum^{n-1}_{i=1}(f[i] \times 2 \times 3^{n-i-1})$，其中 $f[i]$ 是到 $a[i]$ 的前缀积。对于 $f[n]$ 要单独算，因为后面没有符号决定了。

这个东西很容易用线段树维护，叶子结点维护连乘到第 $i$ 位对答案的贡献，对于在位置 $x$ 上的修改，其能影响到区间 $[x,n]$ 的贡献，直接区间乘法乘上 $v \times a[x]^{-1}$ 并更新 $a[x]$。 

当然了，这个题目还有一个头疼的地方就是可能会出现 $0$，而 $0$ 没有逆元，所以我们不能将元素的值改为 $0$，而是记录下标最小的 $0$ 出现位置 $k$，区间询问 $[1,k-1]$，这个可以用 STL set 维护。

对于初值为 $0$ 的，我们随便选一个值给它赋上去就行了。

```cpp
#include <bits/stdc++.h>
#define int long long
#define ls(x) ((x) << 1)
#define rs(x) ((x) << 1 | 1)

using namespace std;
const int mod = 1e9 + 7;
const int N = 1e5 + 5;
int n, q;
int val[N * 4];
int a[N];
int tag[N * 4];
set<int> zero;
int pow_mod(int a, int b) {
    int res = 1;
    while (b) {
        if (b & 1) res = res * a % mod;
        a = a * a % mod;
        b >>= 1;
    }   
    return res;
}
int mult(int x, int y) {
    return x * y % mod;
}
int add(int x, int y) {
    return (x + y) % mod;
}
int inv(int x) {
    return pow_mod(x, mod - 2);
}
void pushup(int p) {
    val[p] = add(val[ls(p)], val[rs(p)]);
}
void pushdown(int p) {
    if (tag[p] != 1) {
        tag[ls(p)] = mult(tag[ls(p)], tag[p]);
        val[ls(p)] = mult(val[ls(p)], tag[p]);
        tag[rs(p)] = mult(tag[rs(p)], tag[p]);
        val[rs(p)] = mult(val[rs(p)], tag[p]);
        tag[p] = 1;
    }
}
void build(int l, int r, int p, int& num) {
    tag[p] = 1;
    if (l == r) {
        if (a[l] == 0) {
            a[l] = 1;
            zero.insert(l);
        }
        num = mult(num, a[l]);
        if (l == n) val[p] = num;
        else val[p] = mult(num, 2 * pow_mod(3, n - l - 1));
        return ;
    }
    int mid = l + r >> 1;
    build(l, mid, ls(p), num);
    build(mid + 1, r, rs(p), num);
    pushup(p);
}
void update(int l, int r, int x, int y, int p, int v) {
    if (x <= l && r <= y) {
        val[p] = mult(val[p], v);
        tag[p] = mult(tag[p], v);
        return ;
    }
    pushdown(p);
    int mid = l + r >> 1;
    if (x <= mid) update(l, mid, x, y, ls(p), v);
    if (y > mid) update(mid + 1, r, x, y, rs(p), v);
    pushup(p);
}
int query(int l, int r, int x, int y, int p) {
    if (x > y) return 0;
    if (x <= l && r <= y) {
        return val[p];
    }
    pushdown(p);
    int mid = l + r >> 1;
    int res = 0;
    if (x <= mid) res = add(res, query(l, mid, x, y,ls(p)));
    if (y > mid) res = add(res, query(mid + 1, r, x, y, rs(p)));
    return res;
}
signed main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cin >> n >> q;
    for (int i = 1; i <= n; i++) cin >> a[i];
    int tmp = 1;
    build(1, n, 1, tmp);
    zero.insert(n + 1);
    while (q--) {
        int x, v;
        cin >> x >> v;
        int tmp = v;
        v = mult(v, inv(a[x]));
        if (v != 0) a[x] = tmp, zero.erase(x), update(1, n, x, n, 1, v);
        else zero.insert(x);
        cout << query(1, n, 1, *zero.begin() - 1, 1) << '\n';
    }
    return 0;
}
```


---

## 作者：Yansuan_HCl (赞：0)

众所周知，乘法会改变运算顺序。假设在原序列中放一些乘号，再放入加减号。此时，若取反这些加减号，两式相加，答案就只与第一段连乘相关。

假设 $1$ 到 $i$ 个数中间都是乘号，那么钦定 $a_i$ 后面只能放加减号（否则会算重），剩下的符号任意。简单推导，可以发现答案就是

$$\sum_{i=1}^{N} 2\times3^{N-i-1} \prod_{j=1}^i a_j$$

有个边界问题：$i=N$ 时会多乘 $2$，且出现了 $3^{-1}$ 。

处理一下，得到

$$2 \times \left(\sum_{i=1}^{N-1}3^{N-i-1}\prod_{j=1}^i a_j \right) + \prod_{i=1}^N a_i$$

于是可以用线段树进行维护括号内的东西。事实上，我们可以把 $3^{n-i-1}$ 变成 $3^{n-i}$ 来维护（其中 $n$ 是线段长度），再查询 $[1, N-1]$，以避免 $3^{-1}$ 的出现。

维护关于前缀积的信息，需要维护**前缀积**和**答案**。

考虑怎样合并两个区间：合并后，左区间的“相对右端点位置位置”变大了，答案乘上 $3^{\operatorname{len_r}}$，而右区间则要乘上左区间的前缀积。前缀积信息的合并是容易的。

于是单次查询 $O(\log N)$，可以通过本题。

```cpp
#include <bits/stdc++.h>
#define ms(x, v) memset(x, v, sizeof(x))
#define il inline
#define pii pair<int, int>
#define pil pair<int, long long>
#define pll pair<long long, long long>
#define U(i,l,r) for(int i(l),END##i(r);i<=END##i;++i)
#define D(i,r,l) for(int i(r),END##i(l);i>=END##i;--i)
using namespace std;

typedef unsigned long long ull;
typedef long long ll;
typedef __int128_t i128;
typedef __uint128_t u128;
template <typename T>
using BS = basic_string<T>;

template <typename T>
il int rd(T& s) {
	int c = getchar();
    // if (c == EOF) return -1;
	T f = 1; s = 0;
	while (c < '0' || c > '9') {
		if (c == '-') f = -1;
        c = getchar();
		// if (c == EOF) return -1;
	}
	while (c >= '0' && c <= '9') {
		s = (s << 1) + (s << 3) + (c ^ 48);
		c = getchar();
	}
	s *= f;
    return 0;
}
template <typename T, typename... Args>
il int rd(T& x1, Args&... args) { return rd(x1) || rd(args...); }
template <typename T>
il void pr(T s, bool fg = true) {
    if (s < 0) { printf("-"); s = -s; }
    if (!s) {
        if (fg) printf("0");
        return;
    }
    pr(s / 10, false);
    printf("%d", int(s % 10));
}
// 代码写的是左闭右开区间，比较丑
const int N = 100005;
const ll P = 1000000007;

int n, q;
ll a[N], pow3[N]; // 预处理 3^N 防止复杂度退化

#define mid ((l + r) >> 1)
#define L(p) ((p) << 1)
#define R(p) (((p) << 1) | 1)
#define M(x) ((x) % P)

struct Node {
    int l, r; // [l, r)
    ll mul, ans;
} tr[N << 2];
Node merge(Node& l, Node& r) {
    return {l.l, r.r, l.mul * r.mul % P, M(l.ans * pow3[r.r - r.l] % P + r.ans * l.mul % P) };
}
void build(int p = 1, int l = 0, int r = n) {
    tr[p] = {l, r, a[l], a[l]};
    if (r == l + 1) return;
    build(L(p), l, mid);
    build(R(p), mid, r);
    tr[p] = merge(tr[L(p)], tr[R(p)]);
}
void update(int x, ll v, int p = 1, int l = 0, int r = n) {
    if (r == l + 1) { tr[p] = {l, r, v, v}; return; }
    if (x < mid) update(x, v, L(p), l, mid);
    else update(x, v, R(p), mid, r);
    tr[p] = merge(tr[L(p)], tr[R(p)]);
}
Node query(int b, int e, int p = 1, int l = 0, int r = n) {
    if (b <= l && e >= r) { return tr[p]; }
    if (b < mid && e <= mid) return query(b, e, L(p), l, mid);
    else if (b >= mid && e > mid) return query(b, e, R(p), mid, r);
    else {
        Node la = query(b, e, L(p), l, mid), ra = query(b, e, R(p), mid, r);
        return merge(la, ra);
    }
}

int main() {
    rd(n, q);
    pow3[0] = pow3[1] = 1;
    U (i, 1, n) pow3[i] = pow3[i - 1] * 3 % P;
    U (i, 0, n - 1) rd(a[i]);
    build();
    while (q--) {
        int x, v; rd(x, v);
        update(x - 1, v);
        Node p = query(0, n - 1);
        printf("%lld\n", M(p.ans * 2 % P + tr[1].mul));
    }
    return 0;
}
```

---

## 作者：Mars_Dingdang (赞：0)

## 题目大意
给定一个长度为 $n$ 的序列 $a_i$，你需要在每两项之间添加一个 $\{+, -, \times\}$ 使其形成一个表达式，并支持 $q$ 次单点修改后求出所有 $3^{n-1}$ 个表达式之和，答案对 $10^9+7$ 取模。

## 大体思路
首先，手算 $n=3, 4$ 等小范围数据可以发现，最终只剩下 $a_1,\ a_1a_2,\ a_1a_2a_3\cdots $ 项。

对其进行归纳总结，并分开计算贡献：假设 $a_i(i<n)$ 及其之前都是乘号，而 $a_i,\ a_{i+1}$ 使用 $\pm$ 进行连接，则后面所有项都可以用一个 $+$ 与一个 $-$ 抵消，所以单个的贡献均为 $\prod_{j=1}^i a_j$。由于后面有 $n-i$ 个位置可以填写运算符，第一个位置只能填 $\pm$，后面每个位置有三种，总贡献为 $2\times 3^{n-i-1}\prod_{j=1}^i a_j$。注意需要单独加上 $\prod_{j=1}^n a_j$，所以，题目所求的答案为 
$$\left(\prod_{j=1}^n a_j+\sum_{i=1}^{n-1}2\times 3^{n-i-1}\cdot\prod_{j=1}^ia_j\right) \bmod 10^9+7$$

这样，每次线性计算，复杂度 $O(nq)$，拿到了 $50\%$ 的部分分。

进一步思考正解：我们可以用线段树维护，每个叶子节点 $i(i<n)$ 储存 $2\times 3^{n-i-1}a_i$，特殊地，最后一个叶节点 $i=n$ 储存 $a_n$。然后，每次合并左右区间，需要乘以 $a_1a_2\cdots a_{i-1}$。所以，我们可以在每个节点维护两个值 $mul, sum$，分别表示区间的乘数和贡献和。pushup 时，令 
$$mul_i\leftarrow mul_{lson}\times mul_{rson},\ \ sum_i\leftarrow sum_{lson}+mul_{lson}\times sum_{rson}$$
然后，利用线段树基本操作，并预处理 $3$ 的幂次方，最终复杂度为 $O(n+q\log n)$。

## 完整代码
```cpp
#include <bits/stdc++.h>
using namespace std;
#define rep(ii,aa,bb) for(re int ii = aa; ii <= bb; ii++)
#define Rep(ii,aa,bb) for(re int ii = aa; ii >= bb; ii--)
typedef long long ll;
typedef unsigned long long ull;
typedef double db;
typedef pair<int, int> PII;
const int maxn = 1e5 + 5, mod = 1e9 + 7;
namespace IO_ReadWrite {
	#define re register
	#define gg (p1 == p2 && (p2 = (p1 = _buf) + fread(_buf, 1, 1<<21, stdin), p1 == p2) ? EOF :*p1++)
	char _buf[1<<21], *p1 = _buf, *p2 = _buf;
	template <typename T>
	inline void read(T &x){
		x = 0; re T f=1; re char c = gg;
		while(c > 57 || c < 48){if(c == '-') f = -1;c = gg;}
		while(c >= 48 &&c <= 57){x = (x<<1) + (x<<3) + (c^48);c = gg;}
		x *= f;return;
	}
	inline void ReadChar(char &c){
		c = gg;
		while(!isalpha(c)) c = gg;
	}
	template <typename T>
	inline void write(T x){
		if(x < 0) putchar('-'), x = -x;
		if(x > 9) write(x/10);
		putchar('0' + x % 10);
	}
	template <typename T>
	inline void writeln(T x){write(x); putchar('\n');}
}
using namespace IO_ReadWrite;
ll n, q, a[maxn], P[maxn], mul[maxn * 4], sum[maxn * 4];
inline void pushup(int k) {
	mul[k] = (mul[k << 1] * mul[k << 1 | 1]) % mod;
	sum[k] = (sum[k << 1] + sum[k << 1 | 1] * mul[k << 1] % mod) % mod;
}
inline void build(int k, int l, int r) {
	if(l == r) {
		mul[k] = a[l];
		if(l == n) sum[k] = a[l];
		else sum[k] = (2ll * a[l] * P[n - l - 1]) % mod;
		return;
	}
	int mid = (l + r) >> 1;
	build(k << 1, l, mid), build(k << 1 | 1, mid + 1, r);
	pushup(k);
}
inline void modify(int k, int l, int r, int x, ll v) {
	if(l == r) {
		a[l] = mul[k] = v;
		if(l == n) sum[k] = a[l];
		else sum[k] = (2ll * a[l] * P[n - l - 1]) % mod;
		return;
	}
	int mid = (l + r) >> 1;
	if(x <= mid) modify(k << 1, l, mid, x, v);
	else modify(k << 1 | 1, mid + 1, r, x, v);
	pushup(k);
}
int main () {
	read(n); read(q);
	rep(i, 1, n) read(a[i]);
	P[0] = 1;
	rep(i, 1, n) P[i] = (P[i - 1] * 3ll) % mod;
	build(1, 1, n);
	while(q --) {
		int t; ll v;
		read(t); read(v);
		modify(1, 1, n, t, v);
		writeln(sum[1]);
	}
	return 0;
}
```

---

## 作者：zrzring (赞：0)

[更好的阅读体验](http://zrzring.cn/index.php/archives/238)

首先可以发现如果两个式子仅加号和减号互换的话，贡献仅为第一个加号或减号前面的表达式的值，于是我们枚举第一个+或-出现的位置，那么答案为
$$
\sum_{i = 1}^{n - 1}\left(\prod_{k = 1}^{i}a_i \times 2 \times 3^{n - i + 1}\right) + \prod_{k = 1}^{n}a_i
$$
因为要支持单点修改，考虑线段树维护这一个答案，其实这个式子在维护一个前缀积的前缀和，对于合并两个区间，合并完的右半部分的答案可以提取公因数，公因数为为左区间的累积，提取公因数后剩下的为右区间的答案

若该题没有出现$0$修改成正数的操作的话，还可以转化为叶子节点维护前缀积，线段树维护和，每次对区间$(x,n)$乘$x$位置上的数的逆元再乘上要修改的数即可

```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
#include <cstring>
#include <algorithm>
#include <queue>
using namespace std;
void file() {
    freopen("std.in", "r", stdin);
    freopen("wa.out", "w", stdout);
}
const int N = 1e6 + 10, inf = 1e9, dsq = 1e9 + 7;
inline int read() {
    bool sym = 0; int res = 0; char ch = getchar();
    while (!isdigit(ch)) sym |= (ch == '-'), ch = getchar();
    while (isdigit(ch)) res = (res << 3) + (res << 1) + (ch ^ 48), ch = getchar();
    return sym ? -res : res;
}
int n, m, a[N], m3[N];
namespace SEG {
    int ans[N], mul[N];
    #define ls x << 1
    #define rs x << 1 | 1
    void pushup(int x) {
        mul[x] = 1ll * mul[ls] * mul[rs] % dsq;
        ans[x] = (ans[ls] + 1ll * ans[rs] * mul[ls] % dsq) % dsq;
    }
    void build(int x, int l, int r) {
        if (l == r) {
            mul[x] = a[l]; if (l == n) ans[x] = a[l]; else ans[x] = 2ll * a[l] * m3[n - l - 1] % dsq;
            return;
        }
        int mid = l + r >> 1;
        build(ls, l, mid); build(rs, mid + 1, r);
        pushup(x);
    }
    void modify(int x, int l, int r, int pos, int t) {
        if (l == r) {
            mul[x] = t; if (l == n) ans[x] = t; else ans[x] = 2ll * t * m3[n - l - 1] % dsq;
            return;
        }
        int mid = l + r >> 1;
        if (mid >= pos) modify(ls, l, mid, pos, t);
        else modify(rs, mid + 1, r, pos, t);
        pushup(x);
    }
}
int main() {
    n = read(); m = read(); m3[0] = 1;
    for (int i = 1; i <= n; i++) a[i] = read(), m3[i] = 3ll * m3[i - 1] % dsq;
    using namespace SEG; build(1, 1, n);
    for (int i = 1; i <= m; i++) {
        int x = read(), t = read();
        modify(1, 1, n, x, t); printf("%d\n", ans[1]);
    }
    return 0;
}
```

---

## 作者：Caro23333 (赞：0)

考虑填入一组运算符之后一段乘起来的数对答案的贡献：

若这一段前面可以填的运算符有+和-两种，则+的方案和-的方案之间存在一一对应关系，消去这一段乘起来的数的贡献；

所以对答案有贡献的一定是一个前缀的积（可以视为第一个数前面只能填加号）。

不妨设$\prod_{i=1}^ka_i=P_k$，
发现一个长度为$i(1\le i<n)$的前缀对答案的贡献为$P_k\times3^{n-i-1}\times2$。
这是容易解释的，因为在这个前缀之后的第一个运算符只能填入+或者-两种;再往后的所有运算符都是任意的，每个位置有三种填法。

特别地，长度为$n$的前缀对答案的贡献就是$P_n$。

考虑到$P_k$后面的系数看起来不太清爽，我们令所有的$a_i$都除以$3$得到$b_i$，再考虑他们的前缀积$Q_i$，不难发现我们的答案就是
$$3^nQ_n +3^{n-1}\sum_{i=1}^{n-1}Q_{i}$$

考虑一个支持区间乘、区间求和的线段树来维护$Q_i$，将$b_x$修改为$y$时只要将区间$[x,n]$都乘以$\frac{y}{b_x}$即可......吗？

事实上我们仍需考虑$a_x=0$的情况，因为$0$是不能作为分母的。注意到只要存在某个$a_p=0$，那么对于所有$p\le i$，有$Q_i=P_i=0$。

因此我们可以维护所有$a_p=0$的位置$p$中的最靠前的一个，这里我使用了一个set。

在出现涉及到将$a_x$修改为$0$的操作时，我们可以不在线段树上实际修改，而是将$x$丢进set里面，保留原有的$b_x$；
将$a_x$从$0$修改为非$0$数$y$时再从set里面删掉，并且用先前的$b_x$进行更新（可以看代码）。

查询区间和时实际上只要查到set中最小位置之前的一个位置即可，后面全是$0$不用管。

代码：

```cpp
#include <iostream>
#include <cstdlib>
#include <cstring>
#include <cstdio>
#include <set>
#define setit set<int>::iterator
#define mod 1000000007ll
#define inv3 333333336ll

using namespace std;
typedef long long ll;
const int MAXN = 100005;
int n,q;
ll a[MAXN],b[MAXN],pre[MAXN];
struct Node
{
	int l,r;
	ll sum,lazy;
}t[MAXN<<2];
inline void buildtree(int id, int l, int r)
{
    t[id].l = l, t[id].r = r;
    t[id].lazy = 1;
    if(l==r)
    {
        t[id].sum = pre[l];
        return;
	}
	int mid = (l+r)>>1;
	buildtree(id<<1,l,mid);
	buildtree(id<<1|1,mid+1,r);
	t[id].sum = (t[id<<1].sum+t[id<<1|1].sum)%mod;
}
inline void pushdown(int id)
{
	t[id<<1].lazy = t[id<<1].lazy*t[id].lazy%mod;
	t[id<<1|1].lazy = t[id<<1|1].lazy*t[id].lazy%mod;
	t[id].sum = t[id].sum*t[id].lazy%mod;
	t[id].lazy = 1;
}
inline void pushup(int id)
{
	t[id].sum = (t[id<<1].lazy*t[id<<1].sum%mod+t[id<<1|1].lazy*t[id<<1|1].sum%mod)%mod;
}
inline void modify(int id, int l, int r, ll d)
{
	if(t[id].l==l&&t[id].r==r)
	{
	    t[id].lazy = t[id].lazy*d%mod;
	    return;
	}
	pushdown(id);
    int mid = (t[id].l+t[id].r)>>1;
    if(r<=mid)
        modify(id<<1,l,r,d);
    else if(l>mid)
        modify(id<<1|1,l,r,d);
    else
        modify(id<<1,l,mid,d), modify(id<<1|1,mid+1,r,d);
    pushup(id);
}
inline ll query(int id, int l, int r)
{
	if(l>r)
	    return 0;
	if(t[id].l==l&&t[id].r==r)
	    return t[id].lazy*t[id].sum%mod;
    pushdown(id);
    int mid = (t[id].l+t[id].r)>>1;
    if(r<=mid)
        return query(id<<1,l,r);
    else if(l>mid)
        return query(id<<1|1,l,r);
    else
        return (query(id<<1,l,mid)+query(id<<1|1,mid+1,r))%mod;
}
set<int> st;
inline int getMin()
{
	return *st.begin();
}
inline ll qpow(ll a, int b)
{
	ll res = 1;
	for(; b; a = a*a%mod, b >>= 1)
	    if(b&1)
		    res = res*a%mod;
	return res; 
}
inline ll getInv(ll x)
{
	return qpow(x,mod-2);
}

int main()
{
	cin >> n >> q;
    pre[0] = 1;
	for(int i = 1; i<=n; i++)
	{
	    scanf("%lld",&a[i]);
        b[i] = a[i]*inv3%mod;
	    if(!b[i])
	    {
	        st.insert(i);
	        b[i] = 1;
		}  
        pre[i] = pre[i-1]*b[i]%mod;
	}
	buildtree(1,1,n);
	int x,y;
	while(q--)
	{
	    scanf("%d%d",&x,&y);
       //注意此处操作
	    if(y==0)
	    {
	        st.insert(x);
	        a[x] = 0;
		}
		else
		{
	        if(a[x]==0)
	            st.erase(x);
	        ll tmp = y*inv3%mod;
	        modify(1,x,n,getInv(b[x])*tmp%mod);
			b[x] = tmp; 
		}
     //查询
		if(st.empty())
		{
	        ll res = query(1,1,n-1)*qpow(3,n-1)%mod*2%mod;
	        res = (res+query(1,n,n)*qpow(3,n)%mod)%mod;
	        printf("%lld\n",res);
		}
		else
		{
	        int pos = getMin();
	        if(pos==1)
	        {
	            printf("0\n");
	            continue;
			}
		    ll res = query(1,1,pos-1)*qpow(3,n-1)%mod*2%mod;
		    printf("%lld\n",res);
		}
	}
	return 0;
}
```


---


# 食堂

## 题目背景

我CYJian就是死，死外边，从这跳下去，也不会吃食堂一口饭。

$$\color{white}\text{真香。。}$$

## 题目描述

食堂第$i$天有$i$道菜.$CYJian$觉得第$i$天的第$j$道菜的美味程度为$\lbrace \frac{i}{j} \rbrace$({}就是取小数部分),当然,$CYJian$是一个勇于尝试的人,所以每一道菜都会吃那么一点.

现在CYJian有$T$个问题,每一个问题都是从第$A_i$天到第$B_i$天得到的美味值的总和.现在请你帮他算一算吧!请输出答案模$998244353$的值.

## 说明/提示

样例解释：第一天美味值为0.00，第二天美味值为0.00+0.00=0.00，第三天美味值为0.00+0.50+0.00=0.50，0.00+0.00+0.50=0.50=$\frac{1}{2}$,$499122177 \times 2 \equiv 1 (\bmod\ 998244353)$,所以答案为499122177.

数据范围：

| 数据点范围 | $T$= | $A\leqslant B \leqslant$ |
|:-------------------------:|:-----------------------:|:--------------:|
| $1 \sim 5$ | $1$ | $5000$  |
| $6 \sim 10$ | $1$ | $10^6$  |
| $10 \sim 15$ | $10^6$ | $5000$  |
| $16 \sim 20$ | $10^6$ | $10^6$  |

注意: **本题捆绑测试**

## 样例 #1

### 输入

```
1
1 3
```

### 输出

```
499122177
```

# 题解

## 作者：南城忆潇湘 (赞：10)

不得不说，这题目是一道对于noip选手的数论好题，涉及的知识点比较多，算法也都不是很难，但是很具有思考性。   
首先，我们对于每一个i，来枚举~~（打表）~~出它所对应的值。
![]( https://cdn.luogu.com.cn/upload/pic/35166.png )
然后，我们发现，对于第i-1行，如果它要变成第i行，我们就增加从1/2~1/i-1（也就是逆元之和，用前缀和来维护）,然后再减去它的约数,就可以得到这一行的和了qwq（不包括1和它自己，想一想为什么）      
然后递推即可(Ｏ(≧口≦)Ｏ,我一开始以为有啥数学方法诶)       
~~话说CYJian的题目怎么这么多离线算法，而且这次比赛这么多筛法~~     
顺带附上知识点所需的模板：   
[同余方程](https://www.luogu.org/problemnew/show/P1082)      
[乘法逆元](https://www.luogu.org/problemnew/show/P1082)      
[筛素数（稍微改一改就可以筛约数）](https://www.luogu.org/problemnew/show/P3383)    
代码（本人用的是埃氏筛，不知道为啥比标程的欧拉筛还快~~（玄学）~~，不过从1-n的每个数的约数之和接近nlnn吧（~~也就是说欧拉筛应该是被卡了~~））
```
#include<vector>
#include<cstdio>
#include<iostream>
using namespace std;
const int N=1000000,p=998244353;
int inv[N+1],f[N+1],sum[N+1],prime[N+1];
void pre(){
    inv[1]=1;
    for(int i=2;i<=N;i++)	
        inv[i]=(((long long)-inv[p%i]*(p/i))%p+p)%p;
    for(int i=2;i<=N;i++)
        sum[i]=((long long)sum[i-1]+inv[i])%p;
    for(int i=2;i<=N;i++)
        for(int j=i+i;j<=N;j+=i)
            prime[j]++;//注意，这里的prime指的是j的约数（除了1和它自己）的和，打习惯prime了qwq，大家将就一下
    for(int i=3;i<=N;i++){
        long long cnt=0;
        cnt=(f[i-1]-f[i-2]+p)%p+sum[i-1];
        cnt=(cnt+p-prime[i]+f[i-1])%p;	f[i]=cnt;//f[i]用前缀和的形式表示（后面要用）
    }
    return ;
}
int main(){
    int t; pre();
    cin>>t;
    while(t--){
        int a,b;
        scanf("%d%d",&a,&b);
        int ans=(((long long)f[b]-f[a-1])%p+p)%p;
        printf("%d\n",ans);
    }
    return 0;
}
```

---

## 作者：CYJian (赞：9)

#### $A\leqslant B \leqslant 5000$的算法

没有什么技术含量的吧..

只需要暴力预处理$5000$以内的逆元,然后直接暴力计算答案,记录一个前缀和就可以$O(1)$完成询问了.

#### $T = 1$的算法

首先一个询问求的东西就是这个:
$$\sum_{i=A}^{B}\sum_{j=1}^{i}\lbrace\frac{i}{j}\rbrace \qquad (\bmod\ 998244353)$$

然后我们可以把它变个形:

$$\sum_{i=A}^{B}\sum_{j=1}^{i}(\frac{i}{j}-\lfloor\frac{i}{j}\rfloor)\qquad(\bmod\ 998244353)$$

$$\sum_{i=A}^{B}\sum_{j=1}^{i}\frac{i}{j}-\sum_{i=A}^{B}\sum_{j=1}^{i}\lfloor\frac{i}{j}\rfloor\qquad(\bmod\ 998244353)$$

$$\sum_{i=1}^{B}\sum_{j=max(A,i)}^{B}\frac{j}{i}-\sum_{i=1}^{B}\sum_{j=A}^{B}\lfloor\frac{j}{i}\rfloor\qquad(\bmod\ 998244353)$$

$$\sum_{i=1}^{B}\sum_{j=max(A,i)}^{B}\frac{j}{i}-\sum_{i=1}^{B}(\sum_{j=0}^{B}\lfloor \frac{j}{i} \rfloor-\sum_{j=0}^{A-1}\lfloor \frac{j}{i} \rfloor)\qquad(\bmod\ 998244353)$$

然后我们只需要分别求出左右两边的值就好了.

前面一半我们只需要枚举$i$,然后里面的$j$可以用高斯求和公式直接算出来,然后乘上一个$i$的逆元就好.

后面一半的话..

我们先拿i=3的情况玩玩: 

0, 0, 0, 1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5...

发现了什么??

如果不太明白,再多拿一些数搞一搞,你就会发现这个规律了..

然后后面的一样只需要枚举$i$,后面的东西也可以用高斯求和公式算.

这样就有50分了.

#### 75分算法

把前面两个拼起来就好了.

#### 100分算法

首先我们还是用$T=1$的思路,把这个式子拆成这个样子:

$$\sum_{i=A}^{B}\sum_{j=1}^{i}\frac{i}{j}-\sum_{i=A}^{B}\sum_{j=1}^{i}\lfloor\frac{i}{j}\rfloor\qquad(\bmod\ 998244353)$$
有没有可以直接预处理的办法呢??

答案当然是有的..

对于前一个式子,我们只需要预处理$1$~$B$的逆元,然后求一个前缀和,我们发现$i$的每一次增加,实际上就是加上$1$~$i-1$的逆元+$1$($\frac{i}{i}$).这里可以好好思考一下.

所以我们只需要用线性求逆元的方法,求一遍前缀和后计算每一个$i$的里面的$\sum^i_{j=1}\frac{i}{j}$的值,然后再求一遍前缀和我们就可以$O(1)$求得前面一块的任意一对A,B的值了.

然后再考虑后面一块.

首先我们可以考虑$\lfloor\frac{i}{j}\rfloor$的更多的含义.

这个等同于求出小于等于$i$的数中有多少个数是$j$的倍数.

然后拓展到$\sum_{j=1}^{i}\lfloor\frac{i}{j}\rfloor$呢?

这个就是求小于等于$i$的数中有多少是$1$的倍数,$2$的倍数,$3$的倍数...$i$的倍数.

也就是说,对于每一个数,它对这个答案就有它的因子个数个贡献.

所以我们就可以得到这样一个等式:

$$\sum_{j=1}^{i}\lfloor\frac{i}{j}\rfloor=\sum_{j=1}^{i}d(i)$$

其中$d(i)$表示$i$的因子个数.

然后考虑如何快速求$1$~$n$的因子个数.

这个就是积性函数了..可以使用欧拉线行筛

求出$d(i)$之后,我们就只需要求两次前缀和就好了..这个可以直接把上面的等式代入原式就可以看出来了..

这样子这道题就解决了..

代码如下(请原谅蒟蒻丑陋的码风):

```
#include <bits/stdc++.h>

using namespace std;

#define reg register

typedef long long ll;

inline int read() {
    reg int s = 0; reg bool t = 0; reg char ch = getchar();
    while(!isdigit(ch)) t |= ch == '-', ch = getchar();
    while(isdigit(ch)) s = (s << 1) + (s << 3) + (ch ^ 48), ch = getchar();
    return t ? -s : s;
}

const char FI[] = "dinner.in";
const char FO[] = "dinner.out";
const int N = 1000000;
const int mod = 998244353;

int T;
int A;
int B;
int d[N + 1];
int s[N + 1];
int f[N + 1];
int ins[N + 1] = {0, 1};

int tot;
int prime[N + 1];
bitset<N + 1>Check;

void init() {
	d[1] = 1;
	for(reg int i = 2, tmp = 2; i <= N; i++, tmp = i) {
		if(!Check[i]) prime[++tot] = i, d[i] = 2;
		for(reg int j = 1, pr = prime[j], s = 2; j <= tot && i * pr <= N; pr = prime[++j]) {
			Check[i * pr] = 1;
			if(i % pr == 0) {
				while(tmp % pr == 0) tmp /= pr, s++;
				d[i * pr] = d[tmp] * s;
				break;
			}
			d[i * pr] = d[i] << 1;
		}
	}
	for(reg int i = 1; i <= N; i++) s[i] = s[i - 1] + d[i], s[i] -= s[i] >= mod ? mod : 0;
	for(reg int i = 1; i <= N; i++) s[i] += s[i - 1], s[i] -= s[i] >= mod ? mod : 0;
	for(reg int i = 2; i <= N; i++) ins[i] = 1LL * (mod - mod / i) * ins[mod % i] % mod;
	for(reg int i = 2; i <= N; i++) ins[i] += ins[i - 1], ins[i] -= ins[i] >= mod ? mod : 0;
	for(reg int i = 1; i <= N; i++) f[i] = f[i - 1] + ins[i - 1] + 1, f[i] -= f[i] >= mod ? mod : 0;
	for(reg int i = 1; i <= N; i++) f[i] += f[i - 1], f[i] -= f[i] >= mod ? mod : 0;
}

int main() {
	init();
	reg int T = read();
	for(reg int Q_Q = 0; Q_Q < T; Q_Q++) {
		A = read() - 1,	B = read(),
		printf("%d\n", ((f[B] - f[A] - s[B] + s[A]) % mod + mod) % mod);
	}
	return 0;
}
```

---

## 作者：Konjac_16 (赞：5)

上周模拟赛上见的这道题，嘴了个 $O(nlogn)$ 的做法，场切掉了。

可能复杂度并不很优秀，但是该思路好想好写，不需要化式子，不用筛约数 ~~（好像目前没有题解用这个方法）~~。
- $Ans=\sum\limits_{i=A}^{B}\sum\limits_{j=1}^{i}\left\{\frac{i}{j}\right\}$
- 根据分数的性质：$\left\{\dfrac{i}{j}\right\} = \dfrac{i\ mod\ j}{j}$
- 据 $1$ 式，我们暴力求 $Ans$ 时是以 $i$ 为第一关键字。观察 $2$ 式，我们可以改变思路，把 $j$ 作为第一关键字。对于每一个 $j$，考虑其对每一天的贡献，做出前缀和，询问时输出 $sum_r-sum_{l-1}$ 即可。
- 对于每一个 $j$ 的贡献，$\frac{1}{j}$ 作为系数不变，分子的贡献是 $0\sim j-1$ 的循环。
- 即对 $0\sim j-1$ 天，分别加 $0\sim j-1$；对 $j \sim 2\cdot j-1$ 天，分别加 $0\sim j-1$……
- 差分意义下即为：对 $1\sim j-1$ 天，分别加 $1$；对第 $j$ 天减 $j-1$ ，对 $j+1\sim 2\cdot j-1$ 天，分别加 $1$，对第 $2\cdot j$ 天减 $j-1$……
- 既然是静态区间加，可以考虑二次差分，这样每次加的复杂度就是 $O(1)$。对于每个 $j$，复杂度是 $O(\frac{n}{j})$，所以总复杂度是一个调和级数求和，也就是 $O(nlogn)$。
- 代码如下：
```cpp
#include <bits/stdc++.h>
#define int long long
#define For(i,a,b) for(int i=(a);i<=(b);++i)
const int N=1000000,mod=998244353;
inline int qpow(int a,int b){
		int res=1;
		for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}
		return res;
}
int a[N+5],sum[N+5],vis[N+5];
inline void add(int &x,int y){y%=mod;x+=y;x%=mod;}
inline void del(int &x,int y){y%=mod;x-=y;x=(x+mod)%mod;}
signed main(){
        For(j,2,N){
            int x=qpow(j,mod-2); add(vis[j+1],x);
            for(int i=j+j;i<=N;i+=j) del(vis[i],j*x),add(vis[i+1],j*x);
            //处理二次差分数组
        }
        For(i,1,N) add(vis[i],vis[i-1]); //得出差分数组
        For(i,1,N) add(vis[i],vis[i-1]); //得出原数组
        For(i,1,N) sum[i]=(sum[i-1]+vis[i])%mod;//得出前缀和数组
        int T; scanf("%lld",&T);
        while(T--){
            int l,r;scanf("%lld%lld",&l,&r);
            int res=(sum[r]-sum[l-1]+mod)%mod;
            printf("%lld\n",res);
        }
        return 0;
}
```



---

## 作者：ZigZagKmp (赞：3)

### 没有学过积性函数的看这里。
----

### 前备知识
1. 埃氏筛法
2. 乘法逆元的线性求法
3. 前缀和

### 题意分析与转化

题目相当于是求
$$\sum_{i=A}^{B}\sum_{j=1}^{i}\{\frac{i}{j}\}\ (\bmod\ 998244353)$$
我们一步步转化
$$\sum_{i=A}^{B}\sum_{j=1}^{i}\left(\frac{i}{j}-\lfloor\frac{i}{j}\rfloor\right)\ (\bmod\ 998244353)$$
$$\sum_{i=A}^{B}\sum_{j=1}^{i}\frac{i}{j}-\sum_{i=A}^{B}\sum_{j=1}^{i}\lfloor\frac{i}{j}\rfloor\ (\bmod\ 998244353)$$
到这里，我们已经可以做了。

----

先看前一部分，相当于
$$\sum_{i=A}^{B}\sum_{j=1}^{i}i\times inv(j)\ (\bmod\ 998244353)$$
根据乘法分配律，我们转化得：
$$\sum_{i=A}^{B}i\times\sum_{j=1}^{i} inv(j)\ (\bmod\ 998244353)$$
我们可以预处理出$inv(j)$的前缀和，求出
$$f(x)=i\times\sum_{j=1}^{i} inv(j)\ (\bmod\ 998244353)$$
再对$f(x)$求前缀和，即可解决第一部分。

----

再看第二部分：
#### 算法1
参考整除分块，用$O(n\sqrt n)$实现，可惜超时。
#### 算法2
可以参考[P1403 [AHOI2005]约数研究](https://www.luogu.org/problemnew/show/P1403)

在那一道题目中的$f(x)$，其实就是$\lfloor\frac{i}{j}\rfloor$，而在那一题中的$M$，其实就是$$\sum_{j=1}^{i}\lfloor\frac{i}{j}\rfloor$$

我们先看埃氏筛法的过程（此处我们把在筛法中忽略的非素数筛的过程也补上来）：

我们重点看每一个数字被筛去的次数。

![](https://cdn.luogu.com.cn/upload/pic/37617.png)

我们对最后的序列求一次前缀和：
```cpp
| 1 | 3 | 5 | 8 | 10 | 14 | 16 | 20 | 23 | 27 | 29 | 35 |
```
发现了什么？

求出来的序列的第$i$项就是$$ff(i)=\sum_{j=1}^{i}\lfloor\frac{i}{j}\rfloor$$

我们对这个序列再求一次前缀和，即可$O(1)$求出
$$\sum_{i=A}^{B}\sum_{j=1}^{i}\lfloor\frac{i}{j}\rfloor$$

#### 为什么这个规律是正确的？
我们考虑$ff(i)$的实际意义，相当于求**不大于$i$的数中有多少个数分别是1,2,3...i的整倍数**

这个“筛法”的实际意义，相当于求** $i$有多少个因数**，即**不大于$i$ 的数中有多少个数的整倍数是$i$**~~（蛮拗口的）~~

而它的前缀和，和$ff(i)$的实际意义相同。

换句话说，$ff(i)$和筛法前缀和一个从因数出发，一个从倍数出发，但是求出来的东西是相同的。

----

### 效率分析

总的时间复杂度为$O(n+n\log_2n+T)$，可以通过。

### 代码实现

```cpp
#include <bits/stdc++.h>
using namespace std;
#define maxn 1000005
#define LL long long int
#define mod 998244353
#define N 1000000
template <typename Tp>
inline void read(Tp &x){
	int f=1;char c=getchar();x=0;
	while((c>'9'||c<'0')&&c!='-')c=getchar();if(c=='-'){f=-1;c=getchar();}
	while(c>='0'&&c<='9'){x=(x<<1)+(x<<3)+(c^48);c=getchar();}x*=f;
}//快速读入，可删除
int l,r;
LL sf[maxn],sff[maxn],ivn[maxn],f[maxn];
int main(){
	int t;
	LL ll,rr;
	ivn[1]=1;
	for(int i=2;i<=N;i++)
        ivn[i]=(LL)(mod-mod/i)*ivn[mod%i]%mod;\\线性求出逆元
    for(int i=1;i<=N;i++)
		ivn[i]=(ivn[i-1]+ivn[i])%mod; \\逆元前缀和
    sf[1]=1;
    for(int i=2;i<=N;i++)
    	sf[i]=(i*ivn[i])%mod;\\f(i)
    for(int i=1;i<=N;i++)
    	sf[i]=(sf[i-1]+sf[i])%mod;\\f(i)前缀和
	for(int i=1;i<=N;i++){
		for(int j=i;j<=N;j+=i)sff[j]++;\\筛法
	}
	for(int i=1;i<=N;i++)
		sff[i]=(sff[i-1]+sff[i])%mod;\\求得ff(i)
	for(int i=1;i<=N;i++)
		sff[i]=(sff[i-1]+sff[i])%mod;\\ff(i)前缀和
	read(t);
	while(t--){
		read(l);read(r);
		printf("%lld\n",(sf[r]-sf[l-1]+mod-sff[r]+sff[l-1]+mod)%mod);
	}
    return 0;
}
```

---

## 作者：yizcdl2357 (赞：1)

一篇严格线性的题解，~~跑不过一只 log~~。

# 题目描述

$T$ 组数据，给定 $A,B\le 10^6$，求：

$$\sum_{i=A}^B \sum_{j=1}^i\left\{\dfrac{i}{j}\right\}$$

其中 $\{a\}=a-\lfloor a\rfloor$。

# 题解

不难发现 $\sum_{j=1}^i\left\{\dfrac{i}{j}\right\}$ 与 $A,B$ 无关，仅与 $i$ 有关，记为 $f(i)$。只需对 $f$ 做一个前缀和便可得到答案。问题变成如何求 $f$。

先按照定义拆开大括号：

$$f(i)=\sum_{j=1}^i\dfrac{i}{j}-\sum_{j=1}^i\lfloor\dfrac{i}{j}\rfloor$$

$$\qquad=i\sum_{j=1}^i\dfrac{1}{j}-\sum_{j=1}^i\lfloor\dfrac{i}{j}\rfloor$$

$$\qquad=iH_i-\sum_{j=1}^i\lfloor\dfrac{i}{j}\rfloor$$

其中 $H_i$ 是调和数，可先对 $1\sim 10^6$ 的数进行[线性求逆元](https://www.luogu.com.cn/problem/P3811)后做一遍前缀和求出。

问题变成：如何求 $\sum_{j=1}^i\lfloor\dfrac{i}{j}\rfloor$。

遇事不决，做个裂项：

$$\begin{aligned}
&\sum_{j=1}^i\lfloor\dfrac{i}{j}\rfloor-\sum_{j=1}^{i-1}\lfloor\dfrac{i-1}{j}\rfloor\\
=&\lfloor\dfrac{i}{i}\rfloor+\sum_{j=1}^{i-1}\lfloor\dfrac{i}{j}\rfloor-\lfloor\dfrac{i-1}{j}\rfloor\\
=&1+\sum_{j=1}^{i-1}[j|i]=d(i)\\
\end{aligned}$$

其中 $d(i)$ 表示 $i$ 的约数个数。

线性筛预处理 $d(i)$，做前缀和即得 $\sum_{j=1}^i\lfloor\dfrac{i}{j}\rfloor$。

# 代码
~~因为菜鸡很懒~~，此处没有使用递推求逆，而是使用线性筛逆元（逆元是积性函数），复杂度仍为 $O(n)$。

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define int long long
#define N 1000000
#define M 998244353
using namespace std;
int T,l,r,n,pn,p[N+5],low[N+5],d[N+5],H[N+5],ans[N+5];
bool ip[N+5];
inline int inv(int x,int y)
{
	if(y==1) return 0;
	return ((1-y*inv(y%x,x))/x%y+y)%y;
}
inline void sieve(int x)
{
    memset(ip,1,sizeof(ip));
    ip[1]=0,low[1]=d[1]=H[1]=1;
    for(int i=2;i<=x;i++)
    {
        if(ip[i]) p[++pn]=i,low[i]=i,d[i]=2,H[i]=inv(i,M);
        for(int j=1;j<=pn;j++)
        {
            if(i*p[j]>x) break;
            int _=i*p[j];
            ip[_]=0;
            low[_]=p[j];
            d[_]=d[i]*d[p[j]];
            H[_]=H[i]*H[p[j]]%M;
            if(i%p[j]==0)
            {
                low[_]=low[i]*p[j];
                if(i==low[i]) d[_]=1+d[i];
                else d[_]=d[i/low[i]]*d[p[j]*low[i]];
                break;
            }
        }
    }
}
signed main()
{
	sieve(N);
	for(int i=1;i<=N;i++)
		H[i]=(H[i]+H[i-1])%M,d[i]=(d[i]+d[i-1])%M,
		ans[i]=(i*H[i]-d[i]+M+ans[i-1])%M;
	cin>>T; while(T--)
		scanf("%lld%lld",&l,&r),printf("%lld\n",(ans[r]-ans[l-1]+M)%M);
    return 0;
}
```


---

## 作者：Find_Yourself (赞：1)

一道推式子的数学题。

$$
\begin{aligned}

\sum\limits_{i=l}^{r}\sum\limits_{j=1}^{i}\left\{\dfrac{j}{i}\right\}
&=\sum\limits_{i=l}^{r}\sum\limits_{j=1}^{i}\left(\dfrac{j}{i}-\left\lfloor\dfrac{j}{i}\right\rfloor\right)\\

&={\sum\limits_{i=l}^{r}\sum\limits_{j=1}^{i}}\dfrac{j}{i}-
{\sum\limits_{i=l}^{r}\sum\limits_{j=1}^{i}}\left\lfloor\dfrac{j}{i}\right\rfloor

\end{aligned}
$$

令 $g(x)$ 为 $1$ 到 $x$ 的所有数的约数个数之和。即：$\sum\limits_{i=1}^{x}\dfrac{x}{i}$

则最终式子可以化简为：$\sum\limits_{i=l}^{r}\left[i\cdot\left(\sum\limits_{j=1}^{i}j^{-1}\right)\right]-\sum\limits_{i=l}^{r}g(i)$

第一项和第二项均可用两次前缀和预处理。

预处理 $O(n\log n)$，查询 $O(1)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 5e5 + 5, N2 = 1e6 + 5, mod = 998244353;
ll T, s = 0, inv[N2], cnt[N2], x[N2], f[N2];
ll getans(ll n) {return (x[n] - f[n] + mod) % mod;}
int main() {
    inv[1] = s = x[1] = f[1] = cnt[1] = 1;
    for (ll i = 2; i <= 1e6; ++i) {
    	inv[i] = (mod - mod / i * inv[mod % i] % mod) % mod;
		s = (s + inv[i]) % mod;
		x[i] = (x[i - 1] + i * s) % mod;
	}
    for (ll i = 2; i <= 1e6; ++i) {
        ++cnt[i];
        for (int j = i; j <= 1e6; j += i) ++cnt[j];
    }
    s = 0;
    for (int i = 1; i <= 1e6; ++i) s = (s + cnt[i]) % mod, f[i] = (f[i - 1] + s) % mod;
    scanf("%d", &T); 
    while (T--) {
        ll p, q; scanf("%lld%lld", &p, &q);
        printf("%lld\n", (getans(q) - getans(p - 1) + mod) % mod);
    }
    return 0;
}
```


---

## 作者：Daniel_7216 (赞：1)

首先，我们对题目做一些变形：

$$\sum\limits_{i=l}^r\sum\limits_{j=1}^i \{ \frac{i}{j} \}=\sum\limits_{i=1}^r\sum\limits_{j=1}^i \{ \frac{i}{j} \}-\sum\limits_{i=l}^{l-1}\sum\limits_{j=1}^i \{ \frac{i}{j} \}$$

显然，两个式子的计算方法是相同。

所以可以用如下操作：

$$\sum\limits_{i=1}^l\sum\limits_{j=1}^i\{\frac{i}{j}\}=\sum\limits_{i=1}^l\sum\limits_{j=1}^i(\frac{i}{j}-\left\lfloor\frac{i}{j}\right\rfloor)=\sum\limits_{i=1}^l(i\sum\limits_{j=1}^i\frac{1}{j})-\sum\limits_{i=1}^l\sum\limits_{j=1}^i\left\lfloor\frac{i}{j}\right\rfloor$$

也就是说，我们把一个分数的小数部分拆分成这个分数减去它下取整，也就是整数部分，再把这个式子拆分成两个部分。

不难发现 $\sum\limits_{j=1}^i\frac{1}{j}$ 这一部分可以先预处理出一到十万的每一个 $\frac{1}{j}$，做一次前缀和，然后用这个前缀和再做第二次前缀和，求出每一个 $\sum\limits_{i=1}^l(i\sum\limits_{j=1}^i\frac{1}{j})$。两个前缀和分别用 $sum2$ 和 $sum3$ 数组表示。

```cpp
for (int i = 1; i <= 1000000; i++){
	sum2[i] = (sum2[i - 1] + frac(1, i)) % mod;
}
for (int i = 1; i <= 1000000; i++){
	sum3[i] = (i * sum2[i] + sum3[i - 1]) % mod;
}
```

第二个式子我们暂时没办法变化，是不是？我们可以用两个方式求解。

- 法一：打表。

我们选取 $i\in[10,15]$ 范围内的数，看看每一个 $\left\lfloor\frac{i}{j}\right\rfloor$ 的值。

```cpp
i=10: 10 5 3 2 2 1 1 1 1 1
i=11: 11 5 3 2 2 1 1 1 1 1 1
i=12: 12 6 4 3 2 2 1 1 1 1 1 1
i=13: 13 6 4 3 2 2 1 1 1 1 1 1 1
i=14: 14 7 4 3 2 2 2 1 1 1 1 1 1 1
i=15: 15 7 5 3 3 2 2 1 1 1 1 1 1 1 1
```
如果横着看似乎没什么规律，所以我们可以竖着看，即固定每一个 $j$，看随着 $i$ 的增大数值有什么变化。不难发现其实这个如果 $i$ 是 $j$ 的整倍数，有 $\left\lfloor\frac{i}{j}\right\rfloor=\left\lfloor\frac{i-1}{j}\right\rfloor+1$，否则 $\left\lfloor\frac{i}{j}\right\rfloor=\left\lfloor\frac{i-1}{j}\right\rfloor$。

- ~~法二：感性理解~~

我们知道，所谓下取整其实就是取有余数除法中的商。也就是说，$\left\lfloor\frac{i}{j}\right\rfloor= \frac{i-i\bmod j}{j}$。

感性理解一下，如果 $i\mod j$ 不为 $0$，也就是说刚才加的 $1$ 被当做余数舍去了，答案并没有增大。也就是 $\left\lfloor\frac{i}{j}\right\rfloor=\left\lfloor\frac{i-1}{j}\right\rfloor$。

反之，我们可以认为 $i-1$ 不是 $j$ 的倍数，但是 $i$ 是 $j$ 的倍数。那么这个时候，$\left\lfloor\frac{i}{j}\right\rfloor=\frac{i}{j}=\left\lfloor\frac{i-1}{j}\right\rfloor+1$，相当于我们“攒”了 $j$ 次余数，使得答案增大了 $1$。

推广一下就是，$\sum\limits_{j=1}^i\left\lfloor\frac{i}{j}\right\rfloor$ 相比 $\sum\limits_{j=1}^{i-1}\left\lfloor\frac{i-1}{j}\right\rfloor$ 增大的部分就是所有 $j$ 中 $i$ 的因数的个数。

我们用 $sum1_i$ 表示 $i$ 相比 $i-1$ 增大的量。

```cpp
for (int i = 1; i <= 1000000; i++){
	for (int j = i; j <= 1000000; j += i){
		sum1[j]++;
	}
}
```

仿照刚才的操作，我们对 $sum1$ 数组做两次前缀和，一次算 $\sum\limits_{j=1}^i\left\lfloor\frac{i}{j}\right\rfloor$，一次算 $\sum\limits_{i=1}^l\sum\limits_{j=1}^i\left\lfloor\frac{i}{j}\right\rfloor$。过程比较类似，不多做赘述。

由于范围只到 $10^6$，所以用比较 naive 的方法筛出一个数字的倍数也可以通过此题。

```cpp
#include <cstdio>
#include <iostream>
#define int long long
using namespace std;
const int mod = 998244353;
const int maxn = 1e6 + 1;
int sum1[maxn], sum2[maxn], sum3[maxn], T, l, r, R, L; 
int Pow(int aa, int p){
	int ans = 1;
	while (p != 0){
		if (p % 2 == 1){
			p--;
			ans = (ans * aa) % mod;
		}
		aa = (aa * aa) % mod;
		p /= 2; 
	}
	return ans;
}
int frac(int i, int j){
	return i * Pow(j, mod - 2) % mod;
}
signed main(){
	for (int i = 1; i <= 1000000; i++){
		for (int j = i; j <= 1000000; j += i){
			sum1[j]++;
		}
	}
	for (int i = 1; i <= 1000000; i++){
		sum1[i] = (sum1[i - 1] + sum1[i]) % mod;
	}
	for (int i = 1; i <= 1000000; i++){
		sum1[i] = (sum1[i - 1] + sum1[i]) % mod;
	}
	for (int i = 1; i <= 1000000; i++){
		sum2[i] = (sum2[i - 1] + frac(1, i)) % mod;
	}
	for (int i = 1; i <= 1000000; i++){
		sum3[i] = (i * sum2[i] + sum3[i - 1]) % mod;
	}
	scanf("%lld", &T);
	while (T--){
		scanf("%lld%lld", &l, &r);
		R = (sum3[r] - sum1[r] + mod) % mod;
		L = (sum3[l - 1] - sum1[l - 1] + mod) % mod;
		printf("%lld\n", (R - L + mod) % mod);
	}
	return 0;
}
```

我 LYH 就是死，死外边，从这跳下去，也不会做推式子的一道题。

$$\color{white}\text{真香。。}$$

---

## 作者：Memory_of_winter (赞：1)

**题目大意：**$n(n\leqslant10^6)$组询问，每组询问给出$l,r(l,r\leqslant10^6)$，求（$\{\dfrac ij\}$表示$\dfrac ij$的小数部分）：
$$\sum\limits_{i=l}^r\sum\limits_{j=1}^i\{\dfrac ij\}\pmod{998244353}$$
**题解：**令$f(x)=\sum\limits_{i=1}^x\{\dfrac xi\}$

$$\begin{aligned}f(x+1)=\sum\limits_{i=1}^{x+1}\{\dfrac{x+1}i\}\\f(x+1)=\sum\limits_{i=1}^{x+1}\{\dfrac xi+\dfrac 1i\}\\\because \{\dfrac{x+1}{x+1}\}=0\\\therefore f(x+1)=f(x)+\sum\limits_{i=1}^{x}\{\dfrac 1i\}-\sum\limits_{i=1}^{x+1}[\{\dfrac{x+1}i\}=0]+1\\\end{aligned}$$
令$s_0(x)$为$x$的约数个数
即$f(x+1)=f(x)+\sum\limits_{i=1}^{x}\{\dfrac 1i\}-s_0(x+1)+1$

求几次前缀和即可



**C++ Code：**

```cpp
#include <cstdio>
#include <iostream>
#define maxn 1000005
const int mod = 998244353;
inline void reduce(int &x) { x += x >> 31 & mod; }
inline int getreduce(int x) { return x + (x >> 31 & mod); }

int n;
int inv[maxn], sinv[maxn], f[maxn];
int ans[maxn], sans[maxn];
int main() {
	std::ios::sync_with_stdio(false), std::cin.tie(0), std::cout.tie(0);
	inv[1] = sinv[1] = 1;
	for (int i = 2; i < maxn; ++i) {
		inv[i] = static_cast<long long> (mod - mod / i) * inv[mod % i] % mod;
		reduce(sinv[i] = sinv[i - 1] + inv[i] - mod);
	}
	for (int i = 2; i < maxn; ++i)
		for (int j = i; j < maxn; j += i) ++f[j];
	for (int i = 2; i < maxn; ++i) {
		reduce(ans[i] = ans[i - 1] + sinv[i - 1] - mod);
		reduce(ans[i] -= f[i]);
		reduce(sans[i] = sans[i - 1] + ans[i] - mod);
	}
	std::cin >> n;
	while (n --> 0) {
		static int l, r;
		std::cin >> l >> r;
		std::cout << getreduce(sans[r] - sans[l - 1]) << '\n';
	}
	return 0;
}

```



---

## 作者：Φρανκ (赞：0)

题意：求 $\sum_{i=A}^B\sum_{j=1}^i\{\frac{i}{j}\}$ 

核心思想：前缀和

解：

容易发现 $\sum_{i=A}^B\sum_{j=1}^i\{\frac{i}{j}\}=\sum_{i=1}^B\sum_{j=1}^i\{\frac{i}{j}\}-\sum_{i=1}^{A-1}\sum_{j=1}^i\{\frac{i}{j}\}$，

并且由高斯函数定义有 $\sum_{i=1}^x\sum_{j=1}^i\{\frac{i}{j}\}=\sum_{i=1}^x\sum_{j=1}^i\frac{i}{j}-\sum_{i=1}^x\sum_{j=1}^i\lfloor\frac{i}{j}\rfloor$。

对于两个部分可以分别求算：

对于前一部分，注意到它形如（以 $x=4$ 为例）

$$
\begin{array}{cccc}
\frac{1}{1} & & & \\
\frac{2}{1} & \frac{2}{2} & &\\
\frac{3}{1} & \frac{3}{2} & \frac{3}{3} & \\
\frac{4}{1} & \frac{4}{2} & \frac{4}{3} & \frac{4}{4}\\
\end{array}
$$

等于 $\sum_{i=1}^x\frac{1}{i}\sum_{i=1}^xi-\sum_{i=1}^x\frac{\sum_{j=1}^{i-1}j}{i}=\frac{x(x+1)\sum_{i=1}^x\frac{1}{i}}{2}-\sum_{i=1}^x\frac{i(i-1)}{2i}=\frac{x(x+1)\sum_{i=1}^x\frac{1}{i}}{2}-\frac{i(i-1)}{4}$。（先计算全部，再减去右上缺失部分）$\sum_{i=1}^x\frac{1}{i}$ 部分可以用线性求逆元加前缀和 $O(n)$ 得到。

对于后一部分，注意到当且仅当 $j|i$ 时 $\lfloor\frac{i}{j}\rfloor=\lfloor\frac{i}{j-1}\rfloor+1$，故 $\sum_{j=1}^i\lfloor\frac{i}{j}\rfloor-\sum_{j=1}^{i-1}\lfloor\frac{i}{j}\rfloor=\sigma_0(i)$，将 $\sigma_0(i)$ 前缀和两遍就可得 $\sum_{i=1}^x\sum_{j=1}^i\lfloor\frac{i}{j}\rfloor$。$\sigma_0(i)$ 本身是积性函数可以线性筛得到。

将两部分相减就得结果的前缀和，之后可以 $O(1)$ 处理每个询问。总复杂度 $O(n+t)$。

代码：
```
#include <bits/stdc++.h>
using namespace std;
const long long mod=998244353;
long long t, a, b, inv[1000001], res[1000001], num[1000001], dvs[1000001], c[1000001], p[100001], flag;
int main()
{
	ios::sync_with_stdio(false);
	inv[1]=1;
	for(int i=2; i<=1000000; i++)
		inv[i]=(mod-mod/i)*inv[mod%i]%mod;
	for(int i=2; i<=1000000; i++)
		inv[i]=(inv[i]+inv[i-1])%mod;//求逆元前缀和
	dvs[1]=1;
	for(int i=2; i<=1000000; i++)
	{
	    if(c[i]==0)
	    {
	    	num[i]=1;
	    	dvs[i]=2;
	     	p[++flag]=i;
		}
	    for(int j=1; j<=flag; j++)
		{
			if(i*p[j]>1000000) 
			break;
			c[i*p[j]]=1;
			if(i%p[j]==0)
			{
				num[i*p[j]]=num[i]+1;
				dvs[i*p[j]]=dvs[i]/(num[i]+1)*(num[i]+2);
				break;
			}
			num[i*p[j]]=1;
			dvs[i*p[j]]=dvs[i]*dvs[p[j]];
		}
    }//线性筛约数个数
    for(int i=1; i<=1000000; i++)
    	dvs[i]=(dvs[i]+dvs[i-1])%mod;
    for(int i=1; i<=1000000; i++)
    	dvs[i]=(dvs[i]+dvs[i-1])%mod;//前缀和两次
//    for(int i=1; i<=100; i++)
//    	cout<<i<<" "<<dvs[i]<<endl;
    for(long long i=1; i<=1000000; i++)
    	res[i]=(inv[i]*i%mod*(i+1)%mod*499122177%mod-i*(i-1)%mod*748683265%mod-dvs[i]+2*mod)%mod;//算结果前缀和
    cin>>t;
    for(int i=1; i<=t; i++)
    {
    	cin>>a>>b;
    	cout<<(res[b]-res[a-1]+mod)%mod<<endl;//算结果本身
	}
	return 0;
}
```

---

## 作者：chihik (赞：0)

题目需要求的是这个式子：

$$\sum_{i=A}^B\sum_{j=1}^i \{\frac{i}{j}\}$$

由~~小学奥数~~知识可知：$\{x\}=x-[x]$

所以上式等价于：

$$\sum_{i=A}^B\sum_{j=1}^i(\frac{i}{j}-[\frac{i}{j}])$$

$$\sum_{i=A}^B\sum_{j=1}^i\frac{i}{j}-\sum_{i=A}^B\sum_{j=1}^i[\frac{i}{j}]$$

先看前部分，

$$\sum_{i=A}^B\sum_{j=1}^i\frac{i}{j}$$

$$\sum_{i=A}^Bi\sum_{j=1}^i inv[j]$$

递推求出 $inv$ 数组，做前缀和后与 $i$ 相乘，记为 $fir$

再将 $fir$ 数组求前缀和后得到第一部分答案。

再看后部分，

$$\sum_{i=A}^B\sum_{j=1}^i[\frac{i}{j}]$$

$$\sum_{i=A}^B\sum_{j=1}^id(j)$$

线性筛出[约数个数](https://www.luogu.com.cn/blog/chihik/ou-la-shai-fa-shai-ji-xing-han-shuo)后求两次前缀和即可。

时间复杂度 $\Theta(n+t)$。

```cpp
#include <cstdio>
#define Mod 998244353

const int MAXN = 1000000;
int t , l , r , k , d[ MAXN + 5 ] , num[ MAXN + 5 ] , prime[ MAXN + 5 ];
int inv[ MAXN + 5 ] , pre_inv[ MAXN + 5 ];
int fir[ MAXN + 5 ] , sec[ MAXN + 5 ];
bool vis[ MAXN + 5 ];

void sieve( ) {
    d[ 1 ] = 1;
	for( int i = 2 ; i <= MAXN ; i ++ ) {
        if( !vis[ i ] ) {
            prime[ ++ k ] = i;
            d[ i ] = 2 , num[ i ] = 1;
        }
        for( int j = 1 ; j <= k && 1ll * i * prime[ j ] <= MAXN ; j ++ ) {
            vis[ i * prime[ j ] ] = 1;
            if( i % prime[ j ] == 0 ) {
                d[ i * prime[ j ] ] = d[ i ] / ( num[ i ] + 1 ) * ( num[ i ] + 2 );
                num[ i * prime[ j ] ] = num[ i ] + 1;
                break;
            }
            d[ i * prime[ j ] ] = d[ i ] * d[ prime[ j ] ];
            num[ i * prime[ j ] ] = 1;
        }
    }
}
void Init( ) {
    inv[ 0 ] = inv[ 1 ] = 1;
    for( int i = 2 ; i <= MAXN ; i ++ )
        inv[ i ] = 1ll * ( Mod - Mod / i ) * inv[ Mod % i ] % Mod;
    for( int i = 1 ; i <= MAXN ; i ++ )
       pre_inv[ i ] = ( pre_inv[ i - 1 ] + inv[ i ] ) % Mod;

    for( int i = 1 ; i <= MAXN ; i ++ )
        fir[ i ] = 1ll * i * pre_inv[ i ] % Mod;
    for( int i = 1 ; i <= MAXN ; i ++ )
        fir[ i ] = ( fir[ i - 1 ] + fir[ i ] ) % Mod;
    
    sieve( );
    for( int i = 1 ; i <= MAXN ; i ++ )
        sec[ i ] = ( sec[ i - 1 ] + d[ i ] ) % Mod;
    for( int i = 1 ; i <= MAXN ; i ++ )
        sec[ i ] = ( sec[ i - 1 ] + sec[ i ] ) % Mod;
}

int main( ) {
    Init( );
    scanf("%d",&t);
    while( t -- ) {
        scanf("%d %d",&l,&r);
        printf("%d\n", ( ( fir[ r ] - fir[ l - 1 ] + Mod ) % Mod - ( sec[ r ] - sec[ l - 1 ] + Mod ) % Mod + Mod ) % Mod );
    }
    return 0;
}
```


---


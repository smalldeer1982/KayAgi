# 乘积

## 题目背景

$CYJian$在经过多次加强后的题目..

## 题目描述

给出$A$,$B$,求下面的式子的值.

$$\prod_{i=A}^{B}\prod_{j=1}^{i}(\frac{i}{j})^{\lfloor \frac{i}{j} \rfloor}\ (\bmod \ 19260817)$$

包含$T$组询问.

------

听说有许多人看不懂公式？？

好吧。。这里给出伪代码：

```
for i=A to B
  for j=1 to i
    res = res * power(i/j, floor(i/j))
res = solve(res)
```

最后的solve表示处理成分数取模的形式。。

不保证这样精度不会原地起爆。。

## 说明/提示

样例解释: $1 \times 4 \times 1 \times 27 \times \frac{3}{2} \times 1 \equiv 162$

| 数据点范围 | $T$= | $A\leqslant B \leqslant$ |
|:-------------------------:|:-----------------------:|:--------------:|
| $1 \sim 5$ | $1$ | $5000$  |
| $6 \sim 10$ | $1$ | $10^6$  |
| $11 \sim 15$ | $10^6$ | $5000$  |
| $16 \sim 20$ | $10^6$ | $10^6$  |

注意: **本题捆绑测试**

## 样例 #1

### 输入

```
1
1 3
```

### 输出

```
162
```

# 题解

## 作者：lqhsr (赞：32)

upd:10.21 LaTeX不支持多行，于是公式挂了，改成图片好了

# 写这篇题解的目的：

**1.分享一种目前最优解的做法**

**2.分享一些卡常的乱(hao)搞(sao)做法**

## 还是先讲做法吧

首先我们拿到这道题(一看就是一道数学题)

由于式子过于复杂，暴力得$n^2$显然稳T

于是我们考虑拆式子

![](https://cdn.luogu.com.cn/upload/image_hosting/1ns2hnv1.png)

把第二个$\prod$变成$\sum$并丢到指数位置是因为$x^a*x^b=x^{a+b}$

**想到这里就可以做了**

**我们记录每个i的答案，最后直接用B的答案除以A-1的答案就行(A-1是因为答案是累乘起来的，类比于前缀和)**

![](https://cdn.luogu.com.cn/upload/image_hosting/wgcoha90.png)

其实我们可以从i每次变化入手

举个例子

```
i=3
sum=3/1+3/2+3/3
ans=3  +1  +1	
i=4
sum=4/1+4/2+4/3+4/4
ans=4  +2  +1  +1
i=5
sum=5/1+5/2+5/3+5/4+5/5
ans=5  +2  +1  +1  +1
i=6
sum=6/1+6/2+6/3+6/4+6/5+6/6
ans=6  +3  +2  +1  +1  +1
```

说说你都发现了什么

**->ans[i]相比ans[i-1]于在每个i的约数的位置+1了！！！**

**然后就可以递推求了ans[i]**

**对于i我们在i+1时乘上i+1的约数个数**

**对于inv(j)我们没次在i+1时把$prod[j]$乘上$prod[k](j \mod k==0)$**

期望得分: 75 or 100

**[我的提交：用时1.76s内存34.91MB,TLE on Sub 4 #16、#17、#20](https://www.luogu.org/record/25456720)**

## 开始卡常啦

### 其实sub4TLE只是你少了几个无用的for循环

#### 卡常1：加上 register and inline ，i++变++i

**[还真的有用少T一个点：用时1.77s内存34.91MB,但是TLE on Sub 4 #16 #20](https://www.luogu.org/record/25457124)**

#### 卡常2：听说可以展开循环来刺激CPU

**[实践证明这是真的：用时1.72s内存34.99MB,TLE on Sub 4 #16](https://www.luogu.org/record/25458564)**

#### 卡常3：是不是展开的不够，再加几个无用的for试试

究竟是什么神仙操作，将一份TLE代码挽救于水深火热之中？？？

**那就是：**

```
	for(int i=1;i<=100000;i++);
	for(int i=1;i<=100000;i++);
	for(int i=1;i<=100000;i++);
```

对！！！你没有看错！！！就是他！！！

[用时1.66s内存34.87MB,AC](https://www.luogu.org/record/25458859)

#### 卡常4：发现上面的方(cao)法(zuo)只是有时能过有时过不了

再仔细一想，整个程序里面最慢的莫过于取模运算了，于是想到取模优化

[用时929ms内存35.04MB,AC](https://www.luogu.org/record/25466013)

## 给出最终代码

```cpp
#include<bits/stdc++.h>
#define ll long long
#define ld long double
using namespace std;
int tt,a[1000006],b[1000006],cnt[1000005],maxn;
const int mod=19260817;
ll ans[1000005],inv[1000005],prod[1000005];
inline int read(){
	register int x=0;register char ch=getchar();
	while(ch>'9'||ch<'0')ch=getchar();
	while(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
	return x;
}
inline ll mul(ll x,ll y){
    ll re=x*y;
    re-=re/mod*mod;//本来想用while实现 但运行之后发现比直接%还慢
    return re;
}
inline ll quick(ll x,ll p){
	register ll re=1;
	while(p){
		if(p&1)re=mul(re,x);
		p>>=1;
		x=mul(x,x);
	}
	return re;
}
inline void exgcd(ll aa,ll bb,ll &x,ll &y){
	if(!bb){x=1,y=0;return ;}
	exgcd(bb,aa%bb,y,x);
	y-=aa/bb*x;
}
inline ll getinv(ll k){
	ll x,y;
	exgcd(k,mod,x,y);
	x=(x%mod+mod)%mod;
	return x;
}
int main(){
	tt=read();
	for(int i=1;i<=100000;i++);
	for(int i=1;i<=100000;i++);
	for(int i=1;i<=100000;i++);
	for(register int i=1;i<=tt;++i)a[i]=read(),b[i]=read();
	for(int i=1;i<=tt;i++)maxn=maxn>b[i]?maxn:b[i];
	inv[1]=1,prod[1]=1;
	for(register int i=2;i<=maxn;++i){
		inv[i]=(mod-mod/i)*inv[mod%i]%mod;
	}
	for(register int i=1;i<=maxn;i++)prod[i]=1;
	for(register int i=1;i<=maxn;++i)
		for(register int j=i;j<=maxn;j+=i)
			++cnt[j];
	for(register int i=1;i<=maxn;++i)
		for(register int j=i;j<=maxn;j+=i)
			prod[j]=mul(prod[j],inv[i]);
	register ll now=0;
	prod[0]=1,ans[0]=1;
	for(register int i=1;i<=maxn;i++)cnt[i]+=cnt[i-1];
	for(register int i=1;i<=maxn;i++)prod[i]=mul(prod[i],prod[i-1]);
	for(register int i=1;i<=maxn;++i)ans[i]=mul(ans[i-1],mul(quick(i,cnt[i]),prod[i]))%mod;
	for(register int i=1;i<=tt;++i)printf("%lld\n",mul(ans[b[i]],getinv(ans[a[i]-1])));
}
```

---

## 作者：CYJian (赞：9)

首先我们在这里再写一下这个式子:

$$\prod_{i = A}^{B}\prod^i_{j=1}(\frac{i}{j})^{\lfloor \frac{i}{j} \rfloor}\ (\bmod\ 19260817)$$

如果只是看着而不给它来一个大手术是永远都做不出来的..~~除非你有天河一号~~

然后开始它的变形记:

$$\prod_{i = A}^{B}\prod^i_{j=1}i^{\lfloor \frac{i}{j} \rfloor} \times inv(j)^{\lfloor \frac{i}{j} \rfloor} (\bmod\ 19260817)$$

$$\prod_{i = A}^{B}\prod^i_{j=1}i^{\lfloor \frac{i}{j} \rfloor} \times \prod_{i = A}^{B}\prod^i_{j=1}inv(j)^{\lfloor \frac{i}{j} \rfloor} (\bmod\ 19260817)$$

到这里应该还是比较简单的吧..只是拆成了逆元然后分开了..

如果不会逆元请出门$P3811$不送..

好的继续..

$$\prod_{i = A}^{B}i^{\sum_{j=1}^{i}\lfloor \frac{i}{j} \rfloor} \times \prod_{i = A}^{B} \prod^B_{j = 1} inv(j) ^ {\lfloor \frac{i}{j} \rfloor} (\bmod\ 19260817)$$

前面一半应该都没有什么问题把..用了幂的乘积的一个公式:$x^a \cdot x^b = x^{a+b}$

后面一半就是一个变形..把$j$弄到$i$前面去..

你可能会觉得这个多乘了一些奇怪的东西,毕竟以前的$j$是到$i$,然而现在到了$B$..

但是并不会多..因为如果$j > i$,那么$\lfloor \frac{i}{j} \rfloor=0$,对于幂来说算出来的结果就是$1$,乘上一个$1$并不会造成什么奇怪的结果..

好的继续..

$$\prod_{i = A}^{B}i^{\sum_{j=1}^{i}\lfloor \frac{i}{j} \rfloor} \times \prod_{j = 1}^{B} (\prod^B_{i = 1} inv(j) ^ {\lfloor \frac{i}{j} \rfloor} \times \prod^A_{i = 1} j ^ {\lfloor \frac{i}{j} \rfloor}) (\bmod\ 19260817)$$

$$\prod_{i = A}^{B}i^{\sum_{j=1}^{i}\lfloor \frac{i}{j} \rfloor} \times inv(\prod_{j = 1}^{B} j ^ {\sum_{i=1}^{B}\lfloor \frac{i}{j} \rfloor}) \times \prod_{j = 1}^{A} j ^ {\sum_{i=1}^{A}\lfloor \frac{i}{j} \rfloor} (\bmod\ 19260817)$$

然后到这里就可以做了..

首先对于$\sum_{j=1}^{i}\lfloor \frac{i}{j} \rfloor$这个玩意可以使用一种神奇的变形变成一个可以方便求的东西..

这个在[这篇题解](https://www.luogu.org/blog/20782/resT1)的下方有有关证明,所以这里不再赘述..

然后就是后面那一坨东西了..

那一堆东西主要要求的东西就是$\prod_{j = 1}^{x} j ^ {\sum_{i=1}^{x}\lfloor \frac{i}{j} \rfloor}$...

我们可以从$x$->$x+1$的时候变多的地方来考虑..

首先多的就是$(x+1) ^ {\sum_{i=1}^{x+1}\lfloor \frac{i}{x+1} \rfloor}$

然而我们发现这个玩意就是$x+1$..

然后考虑其他的地方..

对于$1$~$x$的$j$,只可能在指数上面多了个$\lfloor \frac{x+1}{j} \rfloor$

如果然后我们还可以发现这个增多的$j$只会是$x+1$的因子..

然后这些增多的量就是$x+1$的因子的乘积了..

然后这个可以想一想,反正可以用线性筛搞一搞..

这个变化量求出来以后,就可以用两次前缀积搞掉了..

下面就是丑陋的代码..

```cpp
#include <bits/stdc++.h>

using namespace std;

#define reg register
#define space putchar(' ')
#define enter putchar('\n')
#define pin(a) printf("%d", a)

typedef long long ll;

inline int read() {
    reg int s = 0, t = 0; reg char ch = getchar();
    while(ch > '9' || ch < '0') t |= ch == '-', ch = getchar();
    while(ch >= '0' && ch <= '9') s = (s << 1) + (s << 3) + (ch ^ 48), ch = getchar();
    return t ? -s : s;
}

const int mod = 19260817;
const int MAXN = 1000000;

bitset<MAXN + 1>Check;

inline ll ksm(reg ll a, reg int k) {
    reg ll s = 1;
    while(k) {
        if(k & 1) s = s * a % mod;
        a = a * a % mod;
        k >>= 1;
    }
    return s;
}

int main() {
    reg int tot = 0;
    reg int f[MAXN + 1] = {1, 1};
    reg int d[MAXN + 1];
    reg int h[MAXN + 1];
    reg int prime[MAXN / 10];
    h[0] = h[1] = d[1] = 1;
    for(reg int i = 2; i <= MAXN; i++) {
        if(!Check[i]) prime[++tot] = i, d[i] = 2, h[i] = i;
        for(reg int j = 1; j <= tot && i * prime[j] <= MAXN; j++) {
            reg int pr = prime[j];
            Check[i * pr] = 1;
            if(i % prime[j] == 0) {
                reg int tmp = i, s = 2, F = 1;
                while(tmp % pr == 0) tmp /= pr, F += s, s++;
                d[i * pr] = d[tmp] * s;
                h[i * pr] = 1LL * ksm(h[tmp], d[i / tmp * pr]) * ksm(pr, 1LL * F * d[tmp] % (mod - 1)) % mod;
                break;
            }
            d[i * pr] = d[i] << 1;
            h[i * pr] = 1LL * h[i] * h[i] % mod * ksm(pr, d[i]) % mod;
        }
    }
    for(reg int i = 2; i <= MAXN; i++) {
        d[i] += d[i - 1];
        f[i] = 1LL * f[i - 1] * ksm(i, (d[i] %= mod - 1)) % mod;
    }
    for(reg int i = 2; i <= MAXN; i++) h[i] = 1LL * h[i - 1] * h[i] % mod;
    for(reg int i = 2; i <= MAXN; i++) h[i] = 1LL * h[i - 1] * h[i] % mod;
    reg int T = read();
    for(reg int QwQ = 0, A, B; QwQ < T; QwQ++)
        A = read() - 1, B = read(),
        pin(ksm(f[A], mod - 2)  * f[B] % mod * ksm(h[B], mod - 2) % mod * h[A] % mod),
        enter;
    return 0;
}
```

---

## 作者：_ztyqwq (赞：5)

$$ \prod_{i=A}^B\prod_{j=1}^i(\frac{i}{j})^{\lfloor\frac{i}{j}\rfloor} $$

$$ = \frac{\prod_{i=1}^B\prod_{j=1}^ii^{\lfloor\frac{i}{j}\rfloor}inv(j)^{\lfloor\frac{i}{j}\rfloor}}{\prod_{i=1}^{A-1}\prod_{j=1}^ii^{\lfloor\frac{i}{j}\rfloor}inv(j)^{\lfloor\frac{i}{j}\rfloor}} $$

所以对于任意的 $ n $，我们只需快速计算

$$ \prod_{i=1}^n \prod_{j=1}^i(\frac{i}{j})^{\lfloor\frac{i}{j}\rfloor} $$

$$ = ( \prod_{i=1}^n \prod_{j=1}^i i^{\lfloor\frac{i}{j}\rfloor} )( \prod_{i=1}^n \prod_{j=1}^i j^{\lfloor\frac{i}{j}\rfloor} )^{-1}  $$

（$ x^{-1} $ 代表 $ x $ 的逆元，$ \mod 19260817 $）

$$ = ( \prod_{i=1}^n i^{\sum_{j=1}^i \lfloor\frac{i}{j}\rfloor} )( \prod_{i=1}^n \prod_{j=1}^i j^{\lfloor\frac{i}{j}\rfloor} )^{-1}  $$

（左边利用 $ x^a \cdot x^b = x^{a+b} $ 合并）

这个时候你会发现左边比较好看，其实已经可以做了

dalao: 可是 $ \sum_{j=1}^i \lfloor\frac{i}{j}\rfloor $ 是 $ O(\sqrt i) $ 的鸭（数论分块），合在一起不是 $ O(n\sqrt n) $ 吗？

这个时候你会发现你需要计算所有 $ i $ 的 $ \sum_{j=1}^i \lfloor\frac{i}{j}\rfloor $，~~那么一定有快一点的办法~~

我们令 $ f(n) = \sum_{i=1}^n \lfloor\frac{n}{i}\rfloor $，观察 $ f(n) - f(n-1) $（从 $ n-1 $ 到 $ n $ 的增量）

$ f(n) - f(n-1) = \sum_{i=1}^n (\lfloor\frac{n}{i}\rfloor - \lfloor\frac{n-1}{i}\rfloor) $

我们发现，当且仅当 $ n $ 刚好整除 $ i $（$ i|n $）时，$ \lfloor\frac{n}{i}\rfloor = \lfloor\frac{n-1}{i}\rfloor + 1 $，其他情况下两者相等

所以 $ f(n) = f(n-1) + \sum_{i|n}1 $，即 $ n $ 的约数个数，而这是可以预处理的（可以不用欧拉筛，直接 $ O(n\ln n) $ 暴力即可，e.g.）

```cpp
for(int i=1;i<=n;i++)
    for(int j=i;j<=n;j+=i)
        d[j]++;
```

于是你发现你可以 $ O(n) $ 递推出所有 $ f(n) $，进而推出所有的 $ \prod_{i=1}^n i^{\sum_{j=1}^i \lfloor\frac{i}{j}\rfloor} = \prod_{i=1}^n i^{f(i)} $，也就是说柿子的左边被你愉快的解决了qwq

下面看右边

$$ ( \prod_{i=1}^n \prod_{j=1}^i j^{\lfloor\frac{i}{j}\rfloor} )^{-1} $$

$$ = ( \prod_{j=1}^n \prod_{i=j}^n j^{\lfloor\frac{i}{j}\rfloor} )^{-1} $$

（交换 $ \sum $ ）

$$ = ( \prod_{j=1}^n j^{\sum_{i=j}^n \lfloor\frac{i}{j}\rfloor} )^{-1} $$

（利用 $ x^a \cdot x^b = x^{a+b} $ 合并）

你会发现 $ \forall i \in [1, j-1], \lfloor\frac{i}{j}\rfloor = 0 $，所以上面那个柿子跟这个是一样的：

$$ = ( \prod_{j=1}^n j^{\sum_{i=1}^n \lfloor\frac{i}{j}\rfloor} )^{-1} $$

这个看起来好复杂啊……我们还是令 $ g(n) = \prod_{j=1}^n j^{\sum_{i=1}^n \lfloor\frac{i}{j}\rfloor} $，（逆元最后求一下就行）考虑从 $ g(n-1) $ 到 $ g(n) $ 的增量：

$$ \frac{g(n)}{g(n-1)} = \prod_{j=1}^n j^{\sum_{i=1}^n \lfloor\frac{i}{j}\rfloor - \sum_{i=1}^{n-1} \lfloor\frac{i}{j}\rfloor} $$

$$ = \prod_{j=1}^n j^{\lfloor\frac{n}{j}\rfloor} $$

然后你发现还是不那么好求……再令 $ h(n) = \prod_{i=1}^n i^{\lfloor\frac{n}{i}\rfloor} $，考察 $ h $ 的增量

$$ \frac{h(n)}{h(n-1)} = \prod_{i=1}^n i^{\lfloor\frac{n}{i}\rfloor - \lfloor\frac{n-1}{i}\rfloor} $$

~~根据上面的探究结论~~，当且仅当 $ i|n $ 时，$ \lfloor\frac{n}{i}\rfloor = \lfloor\frac{n-1}{i}\rfloor + 1 $，其他情况下两者相等

所以 $ \frac{h(n)}{h(n-1)} $

$$ = \prod_{i|n}i $$

你会发现这个东西也是可以预处理的（跟刚才那个代码几乎一样）

所以可以 $ O(n) $ 递推出所有 $ h(n) = h(n-1) \cdot \prod_{i|n}i $

所以可以 $ O(n) $ 递推出所有 $ g(n) = g(n-1) \cdot h(n) $

所以可以 $ O(n) $ 递推出柿子的右边

所以可以预处理出所有的答案，在询问的时候输出 $ ans(B) \cdot (ans(A-1))^{-1} $ 即可

~~于是你就秒了此题~~

**~~记得开long long~~**

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int mod=19260817;
inline int fastpow(int a,int n)
{
	int ans=1;
	while(n)
	{
		if(n&1)
			ans=ans*a%mod;
		a=a*a%mod;
		n>>=1;
	}
	return ans;
}
inline int inv(int x)
{
	return fastpow(x,mod-2);
}
int d[1000001],hd[1000001],ans[1000001];
void init(int n)
{
	for(int i=1;i<=n;i++)
		hd[i]=1;
	for(int i=1;i<=n;i++)
		for(int j=i;j<=n;j+=i)
		{
			d[j]++;
			hd[j]=hd[j]*i%mod;
		}
	int tot=1,f=0,g=1,h=1;
	ans[0]=1;
	for(int i=1;i<=n;i++)
	{
		f=(f+d[i])%mod;
		h=h*hd[i]%mod;
		g=g*h%mod;
		tot=tot*fastpow(i,f)%mod;
		ans[i]=tot*inv(g)%mod;
	}
}
signed main()
{
	init(1000000);
	int t;
	scanf("%lld",&t);
	while(t--)
	{
		int a,b;
		scanf("%lld %lld",&a,&b);
		printf("%lld\n",ans[b]*inv(ans[a-1])%mod);
	}
	return 0;
}
```

---

## 作者：Cgod (赞：1)

# 题面链接

[洛谷](https://www.luogu.org/problemnew/show/P4902)

# sol

我的做法是观察法，首先我们把$i$和$j^{-1}$分开做，可以看到

$i$的是这样的。表格内是每个$i$和$j$的对应$i$的贡献

| $1^1$ |       |       |       |       |       |
| :---: | :---: | :---: | :---: | :---: | :---: |
| $2^2$ | $2^1$ |       |       |       |       |
| $3^3$ | $3^1$ | $3^1$ |       |       |       |
| $4^4$ | $4^2$ | $4^1$ | $4^1$ |       |       |
| $5^5$ | $5^2$ | $5^1$ | $5^1$ | $5^1$ |       |
| $6^6$ | $6^3$ | $6^2$ | $6^1$ | $6^1$ | $6^1$ |

可以发现第$i$行我们只要快速求出指数就可以快速幂了。然后会发现一个神奇的性质，第$i$列每过$i$就会让指数加$1$。这样的话我们给$i,2i,3i,4i,5i...$加1，然后前缀和就行了。

要不还是再说清楚点吧。下面这个表是要加的指数。

|  1   |      |      |      |      |      |      |      |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|  1   |  1   |      |      |      |      |      |      |
|  1   |  0   |  1   |      |      |      |      |      |
|  1   |  1   |  0   |  1   |      |      |      |      |
|  1   |  0   |  0   |  0   |  1   |      |      |      |
|  1   |  1   |  1   |  0   |  0   |  1   |      |      |
|  1   |  0   |  0   |  0   |  0   |  0   |  1   |      |
|  1   |  1   |  0   |  1   |  0   |  0   |  0   |  1   |

然后对每列做一遍前缀和。

|  1   |      |      |      |      |      |      |      |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|  2   |  1   |      |      |      |      |      |      |
|  3   |  1   |  1   |      |      |      |      |      |
|  4   |  2   |  1   |  1   |      |      |      |      |
|  5   |  2   |  1   |  1   |  1   |      |      |      |
|  6   |  3   |  2   |  1   |  1   |  1   |      |      |
|  7   |  3   |  2   |  1   |  1   |  1   |  1   |      |
|  8   |  4   |  2   |  2   |  1   |  1   |  1   |  1   |

然后就变回去了，这也许是差分的思想？？？具体实现不需要对每列开数组，丢到一起就OK了。

### 下面的1,2,3,4,5,6均指 他们的逆元

| $1^1$ |       |       |       |       |       |
| :---: | :---: | :---: | :---: | :---: | :---: |
| $1^2$ | $2^1$ |       |       |       |       |
| $1^3$ | $2^1$ | $3^1$ |       |       |       |
| $1^4$ | $2^2$ | $3^1$ | $4^1$ |       |       |
| $1^5$ | $2^2$ | $3^1$ | $4^1$ | $5^1$ |       |
| $1^6$ | $2^3$ | $3^2$ | $4^1$ | $5^1$ | $6^1$ |

这是$j^{-1}$的贡献。

然后和上面一样搞，但我们直接把这个数乘上去而不是加指数。

相信泥萌都懂了。那么我就贴个代码。

[blog](https://www.cnblogs.com/cx233666/p/9736923.html)

---

## 作者：lzh0220 (赞：0)

## 思路

发现最外层的累乘可以通过前缀积直接求出来，因此只需要求：

$$\prod_{j=1}^i (\frac{i}{j})^{\lfloor \frac{i}{j} \rfloor}$$

发现分子 $i$ 对答案影响不大，考虑将他们分开，得：

$$\prod_{j=1}^i i^{\lfloor \frac{i}{j} \rfloor}(\prod_{j=1}^i j^{\lfloor \frac{i}{j} \rfloor})^{-1}$$

即：

$$i^{\sum_{j=1}^i\lfloor \frac{i}{j} \rfloor}(\prod_{j=1}^i j^{\lfloor \frac{i}{j} \rfloor})^{-1}$$

考虑函数 $f(x)=\sum_{j=1}^x\lfloor \frac{x}{j} \rfloor$，发现 $f(x)=f(x-1)+\sum_{d|x}1$，而一个数的因数个数可以在 $O(n\log n)$ 的复杂度内求出，因此前半部分的复杂度即为 $O(n\log n)$。

现在的目标就是求出：

$$\prod_{j=1}^i j^{\lfloor \frac{i}{j} \rfloor}$$

不妨假设函数 $g(x)=\prod_{j=1}^x j^{\lfloor \frac{x}{j} \rfloor}$，发现 $g(x)=g(x-1)\times\prod_{d|x}d$，将 $\prod_{d|x}d$ 前后两两配对，发现若 $x$ 为完全平方数，则 $\prod_{d|x}d=x^{\sum_{d|x \land d < \sqrt x}1} \sqrt x$，否则有 $\prod_{d|x}d=x^{\sum_{d|x \land d < \sqrt x}1}$，因此也可以在 $O(n\log n)$ 时间内求出。

最后将上面的所有东西相乘，做前缀积即可。

[code](https://www.luogu.com.cn/paste/ktr2b4gq)

---

## 作者：ifffer_2137 (赞：0)

随机跳到的小清新数论题。
### 题意
$T$ 次询问，每次给定 $l$ 和 $r$，求：
$$\prod_{i=l}^r\prod_{j=1}^i(\frac{i}{j})^{\lfloor \frac{i}{j} \rfloor}$$
对 $19260817$ 取模。
### 分析
我们考虑求出每一个
$$\prod_{j=1}^i(\frac{i}{j})^{\lfloor \frac{i}{j} \rfloor}$$
然后对它求前缀积。

现在看这个柿子，拆一下分子分母，对于分子：
$$\prod_{j=1}^ii^{\lfloor \frac{i}{j} \rfloor}=i^{\sum_{j=1}^i{\lfloor \frac{i}{j} \rfloor}}$$
求这个指数一般用整除分块，但这里对于每个 $i$ 做一遍整除分块无法接受，所以我们要充分利用前面的计算结果，考虑 $i-1$ 到 $i$ 的指数变化，相当于：
$$\sum_{j=1}^{i}{\lfloor \frac{i}{j} \rfloor-\lfloor \frac{i-1}{j} \rfloor}$$
这个某一项有贡献的充要条件是 $j|i$ 且贡献为 $1$，所以我们预处理每个数的因数个数，这里复杂度调和级数 $O(n\ln n)$。

然后看分母：
$$\prod_{j=1}^i j^{\lfloor \frac{i}{j} \rfloor}$$

一样的思路，考虑从 $i-1$ 到 $i$ 的增量，还是当 $j|i$ 时会乘上 $j$ 的贡献。我们发现把 $i$ 的因数两两配对，大多数都能配成 $i$，完全平方特判即可。所以我们预处理的应该是 $i$ 小于 $\lceil \sqrt i \rceil$ 的因数个数。

这样就可以 $O(n\ln n)$ 预处理，然后快速幂 $O(n\log n)$ 求出答案了，分子分母除一下，维护一个前缀积和逆元，最后每次 $O(1)$ 询问即可。

总复杂度 $O(n\log n+T)$，值得注意的是输出换行建议用```"\n"```，```endl```是龟速换行。
### 代码
```cpp
//From: ifffer_2137
#include <bits/stdc++.h>
using namespace std;
#define inf 0x7fffffff
#define eb emplace_back
#define pii pair<int,int>
#define mkpr make_pair
#define fir first
#define sec second
inline int read(){
    char ch=getchar();int x=0,w=1;
    while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
    while(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+ch-48,ch=getchar();return w==1?x:-x;
}
const int N=1e6;
const int maxn=1e6+5;
const int mod=19260817;
int qpow(int a,int x){
	int s=1;
	while(x){
		if(x&1) s=1ll*s*a%mod;
		a=1ll*a*a%mod;
		x>>=1;
	}
	return s;
}
int T,l,r;
int cnt[maxn];
int den[maxn],pw[maxn],mul[maxn],inv[maxn];
signed main(){
	cin.tie(0),cout.tie(0);
	for(int i=1;1ll*i*(i+1)<=N;i++){
		for(int j=1ll*i*(i+1);j<=N;j+=i){
			cnt[j]++;
		}
	}
	mul[0]=1,inv[0]=1;
	den[1]=1,pw[1]=1,mul[1]=1,inv[1]=1;
	for(int i=2;i<=N;i++){
		pw[i]=pw[i-1]+cnt[i]*2;
		int sq=sqrt(i);
		den[i]=1ll*den[i-1]*qpow(i,cnt[i])%mod;
		if(sq*sq==i) den[i]=1ll*den[i]*sq%mod,pw[i]++;
		mul[i]=1ll*mul[i-1]*qpow(i,pw[i])%mod*qpow(den[i],mod-2)%mod;
		inv[i]=qpow(mul[i],mod-2);
	}
	T=read();
	while(T--){
		l=read(),r=read();
		cout<<1ll*mul[r]*inv[l-1]%mod<<"\n";
	}
	return 0;
}
```

---

## 作者：Φρανκ (赞：0)

题意：求 $\prod_{i=A}^B\prod_{j=1}^i(\frac{i}{j})^{\lfloor\frac{i}{j}\rfloor}$。

核心思想：前缀和。

解：

易知所求 $=\frac{\prod_{i=1}^B\prod_{j=1}^i(\frac{i}{j})^{\lfloor\frac{i}{j}\rfloor}}{\prod_{i=1}^{A-1}\prod_{j=1}^i(\frac{i}{j})^{\lfloor\frac{i}{j}\rfloor}}$，且 $\prod_{i=1}^x\prod_{j=1}^i(\frac{i}{j})^{\lfloor\frac{i}{j}\rfloor}=\prod_{i=1}^xi^{\sum_{j=1}^i\lfloor\frac{i}{j}\rfloor}\prod_{i=1}^x\prod_{j=1}^i(\frac{1}{j})^{\lfloor\frac{i}{j}\rfloor}$。

对于前半部分，注意到当且仅当 $j|i$ 时 $\lfloor\frac{i}{j}\rfloor=\lfloor\frac{i}{j-1}\rfloor+1$，故 $\sum_{j=1}^i\lfloor\frac{i}{j}\rfloor-\sum_{j=1}^{i-1}\lfloor\frac{i}{j}\rfloor=\sigma_0(i)$，将 $\sigma_0(i)$ 前缀和一遍就可得 $\sum_{j=1}^i\lfloor\frac{i}{j}\rfloor$。$\sigma_0(i)$ 本身是积性函数可以线性筛得到。将所得前缀积一遍就得 $\prod_{i=1}^xi^{\sum_{j=1}^i\lfloor\frac{i}{j}\rfloor}$。

对于后半部分，类似地有 $\frac{\prod_{j=1}^i(\frac{1}{j})^{\lfloor\frac{i}{j}\rfloor}}{\prod_{j=1}^{i-1}(\frac{1}{j})^{\lfloor\frac{i}{j}\rfloor}}=\frac{1}{\prod_{j|i}j}$，可先线性预处理出逆元，再用 $O(n\log n)$ 暴力求出 $1\sim x$ 的约数积，前缀积两遍得到 $\prod_{i=1}^x\prod_{j=1}^i(\frac{1}{j})^{\lfloor\frac{i}{j}\rfloor}$。

之后对于每个询问可以 $O(1)$ 得到，总复杂度 $O(n\log n+t)$。

代码：
```
#include <bits/stdc++.h>
using namespace std;
const long long mod=19260817;
long long t, a, b, mx, pw[1000001], inv[1000001], pro[1000001], num[1000001], res[1000001], m, n;
int dvs[1000001], p[100001], flag;
bool c[1000001];
inline long long mul(long long x, long long y)
{
	long long t=x*y;
	t-=t/mod*mod;
	return t;
}//取模
long long read()
{
	long long x=0;
	char ch=getchar();
	while(ch>'9'||ch<'0')
		ch=getchar();
	while(ch>='0'&&ch<='9')
	{
		x=x*10+ch-48;
		ch=getchar();
	}
	return x;
}//快读
long long qp(long long x, long long y)
{
	if(y==0)
		return 1;
	long long t=qp(x, y/2);
	if(y%2==0)
		return mul(t, t);
	else
		return mul(x, mul(t, t));
}//快速幂
long long iv(long long x, long long y)
{
    if (y==0) 
    {
        m=1;
        n=0;
        return x;
    }
    long long z=iv(y, x%y);
    long long t=m;
    m=n;
    n=t-(x/y)*n;
    return m>=0?m:m+mod;
}//扩欧求逆元
void write(long long x)
{
    if(x>=10) 
		write(x/10);
    putchar(x-x/10*10+48);
}//快写
int main()
{
	ios::sync_with_stdio(false);
	inv[1]=1;
	for(int i=2; i<=1000000; ++i)
		inv[i]=(mod-mod/i)*inv[mod%i]%mod;//线性预处理逆元
	res[0]=1;
	dvs[1]=1;
	for(int i=2; i<=1000000; ++i)
	{
	    if(c[i]==0)
	    {
	    	num[i]=1;
	    	dvs[i]=2;
	     	p[++flag]=i;
		}
	    for(int j=1; j<=flag; ++j)
		{
			if(i*p[j]>1000000) 
			break;
			c[i*p[j]]=1;
			if(i/p[j]*p[j]==i)
			{
				num[i*p[j]]=num[i]+1;
				dvs[i*p[j]]=dvs[i]/(num[i]+1)*(num[i]+2);
				break;
			}
			num[i*p[j]]=1;
			dvs[i*p[j]]=dvs[i]*dvs[p[j]];
		}
    }//线性筛求约数个数
	for(int i=0; i<=1000000; ++i)
    	pro[i]=1;
    for(int i=1; i<=1000000; ++i)
    	for(int j=i; j<=1000000; j+=i)
    		pro[j]=mul(pro[j], inv[i]);
    for(int i=1; i<=1000000; ++i)
    {
    	dvs[i]=dvs[i]+dvs[i-1]>mod-1?dvs[i]+dvs[i-1]-mod+1:dvs[i]+dvs[i-1];
    	pw[i]=qp(i, dvs[i]);
    	pro[i]=mul(pro[i], pro[i-1]);
	}
    for(int i=2; i<=1000000; ++i)
    {
		pw[i]=mul(pw[i], pw[i-1]);
    	pro[i]=mul(pro[i], pro[i-1]);
	}
    for(int i=1; i<=1000000; ++i)
    	res[i]=mul(pw[i], pro[i]);//前缀积和前缀和，求1-x的答案
    t=read();
    for(int i=1; i<=t; ++i)
    {
    	a=read();
    	b=read();
    	write(mul(res[b], iv(res[a-1], mod)));//差分（或者说商分）
    	puts("");
	}
	return 0;
}
```

---

## 作者：yizcdl2357 (赞：0)

方便起见，下记 $i/j$ 为 $\lfloor\dfrac{i}{j}\rfloor$。

# 题意

给定 $A,B$，求

$$\prod_{i=A}^B\prod_{j=1}^i\left(\dfrac{i}{j}\right)^{i/j}$$

$10^6$ 组询问，$A,B\le 10^6$。
# 前置知识
基本的推式子能力，前缀和/积，乘法逆元。
# 解法
第一步是观察到要求的式子是一个前缀积的形式，所以可以拆成两个式子：

$$\text{原式}=\dfrac{f(B)}{f(A-1)},f(x)=\prod_{i=1}^x\prod_{j=1}^i\left(\dfrac{i}{j}\right)^{i/j}$$

遇到分数的乘积，一般要分开考虑分子分母：

$$f(x)=\dfrac{\prod_{i=1}^x\prod_{j=1}^ii^{i/j}}{\prod_{i=1}^x\prod_{j=1}^ij^{i/j}}$$

记分子为 $a(x)$，分母为 $b(x)$。
## $a(x)$ 的预处理

$$a(x)=\prod_{i=1}^x\prod_{j=1}^ii^{i/j}=\prod_{i=1}^x i^{\normalsize{\left(\sum_{j=1}^i(i/j)\right)}}$$

如果我们能预处理 $c(x)=\sum_{j=1}^x(x/j)$，那么 $a(x)=\prod_{i=1}^n i^{c(i)}$ 很自然地就可以预处理出来了。

问题变成如何预处理 $c(x)$。遇事不决，做个裂项：

$$\begin{aligned}
&c(x)-c(x-1)\\
=&\sum_{j=1}^x(x/j)-\sum_{j=1}^{x-1}((x-1)/j)\\
=&(x/x)+\sum_{j=1}^{x-1}(x/j)-((x-1)/j)\\
=&(x/x)+\sum_{j=1}^{x-1}[j|x]\\
=&d(x)\\
\end{aligned}$$
$$c(x)=\sum_{i=1}^x d(i)$$

其中 $d(x)$ 表示 $x$ 的约数个数。

线性筛即可。[我的另一篇题解](https://www.luogu.com.cn/blog/340940/p3362-cool-loves-shaxian-ti-xie)里提到了线性筛一般积性函数的方法，对 $d(x)$ 也适用。

## $b(x)$ 的预处理

菜鸡我一开始仿照 $a(x)$，将 $b(x)$ 变形为

$$\begin{aligned}
b(x)&=\prod_{i=1}^x\prod_{j=1}^ij^{i/j}\\
&=\prod_{j=1}^x\prod_{i=j}^xj^{i/j}\\
&=\prod_{j=1}^x j^{\normalsize\sum_{i=j}^x{i/j}}\\
\end{aligned}$$

最后误入歧途。因为 $\sum_{i=j}^x{i/j}$ 是关于 $j$ 和 $x$ 的二元函数，所以无法预处理。（大概吧，如果有大佬预处理出来了，可以私信本菜鸡）

正确的做法是注意到如果可以预处理 $e(x)=\prod_{j=1}^x j^{x/j}$，那做一次前缀积就得到了 $b(x)$。

$e(x)$ 还不是很好预处理。遇事不决，再裂个项：

$$\begin{aligned}
&\dfrac{e(x)}{e(x-1)}\\
=&\dfrac{\prod_{j=1}^x j^{x/j}}{\prod_{j=1}^{x-1} j^{(x-1)/j}}\\
=&x^{x/x}\times\prod_{j=1}^{x-1}\dfrac{j^{x/j}}{j^{(x-1)/j}}\\
\end{aligned}$$

$\dfrac{j^{x/j}}{j^{(x-1)/j}}$ 当 $j|x$ 时为 $j$，否则为 $1$。
$$\begin{aligned}
&\dfrac{e(x)}{e(x-1)}\\
=&x\times\prod_{j|x,j<x}^{x-1}j\\
=&\prod_{j|x}j
\end{aligned}$$

即 $x$ 的约数之积。

这是个经典问题，解法是将约数首尾配对：

$$\begin{aligned}
&\prod_{j|x}j\\
=&\sqrt{\prod_{j|x}j\times\prod_{j|x}\dfrac{x}{j}}\\
=&\sqrt{\prod_{j|x}j\times\dfrac{x}{j}}\\
=&\sqrt{\prod_{j|x}x}\\
=&\sqrt{x^{d(x)}}\\
\end{aligned}$$

当 $x=y^2$ 时，$\dfrac{e(x)}{e(x-1)}=y^{d(x)}$；

若 $x$ 并非完全平方数，则 $d(x)$ 为偶数，$\dfrac{e(x)}{e(x-1)}=x^\frac{d(x)}{2}$。

对 $\dfrac{e(x)}{e(x-1)}$ 做两次前缀积即得 $b(x)$。
# 代码
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#define int long long
#define M 19260817
#define N 1000000
using namespace std;
int T,A,B,pn,p[N+1],low[N+1],d[N+1],a[N+1],b[N+1];
bool ip[N+1];
inline int P(int x,int y=M-2)
{
	if(!y) return 1;
	if(y&1) return x*P(x,y^1)%M;
	int tmp=P(x,y>>1);
	return tmp*tmp%M;
}
inline void init()
{
	memset(ip,1,sizeof(ip));
	ip[1]=low[1]=d[1]=1;
	for(int i=2;i<=N;i++)
	{
		if(ip[i]) p[++pn]=i,low[i]=i,d[i]=2;
		for(int j=1;j<=pn;j++)
		{
			if(i*p[j]>N) break;
			ip[i*p[j]]=0;
			low[i*p[j]]=p[j];
			d[i*p[j]]=d[i]*d[p[j]];
			if(i%p[j]==0)
			{
				low[i*p[j]]=low[i]*p[j];
				if(low[i]==i)
					d[i*p[j]]=d[i]+1;
				else d[i*p[j]]=d[i/low[i]]*d[low[i]*p[j]];
				break;
			}
		}
	}
	for(int i=1;i<=N;i++) a[i]=(a[i-1]+d[i])%M;
	for(int i=1;i<=N;i++) a[i]=P(i,a[i]);
	a[0]=1;
	for(int i=1;i<=N;i++) a[i]=a[i-1]*a[i]%M;
	for(int i=1;i<=N;i++)
	{
		int j=sqrt(i);
		if(j*j==i) b[i]=P(j,d[i]);
		else b[i]=P(i,d[i]/2);
	}
	b[0]=1;
	for(int i=1;i<=N;i++) b[i]=b[i-1]*b[i]%M;
	for(int i=1;i<=N;i++) b[i]=b[i-1]*b[i]%M;
	for(int i=1;i<=N;i++) a[i]=a[i]*P(b[i])%M;
}
signed main()
{
	init();
	cin>>T;
	while(T--)
	{
		scanf("%lld%lld",&A,&B);
		printf("%lld\n",a[B]*P(a[A-1])%M);
	}
	return 0;
}
```


---

## 作者：zhouyuhang (赞：0)

求

$$
\prod_{i=l}^r\prod_{j=1}^i\left(\frac{i}{j}\right)^{\lfloor\frac{i}{j}\rfloor}
$$

直接做：

$$
\prod_{i=l}^r\prod_{j=1}^i\left(\frac{i}{j}\right)^{\lfloor\frac{i}{j}\rfloor}
$$
$$
=\frac{\prod_{i=l}^r\prod_{j=1}^ii^{\lfloor\frac{i}{j}\rfloor}}{\prod_{i=l}^r\prod_{j=1}^ij^{\lfloor\frac{i}{j}\rfloor}}
$$

考虑分别做分子分母。

分子：

$$
\prod_{i=l}^r\prod_{j=1}^ii^{\lfloor\frac{i}{j}\rfloor}
$$
$$
=\prod_{i=l}^ri^{H(i)}
$$

其中 $H(n)=\sum_{i=1}^n\lfloor\frac{n}{i}\rfloor$。$H$ 是可以线性筛的（考虑 $H(n)=H(n-1)+\tau(n)$，$\tau$ 为约数个数函数），那么就可以线性对数对所有的 $n$ 预处理 

$$
\prod_{i=1}^ni^{H(i)}
$$

那么分子的问题就解决了。接下来考虑分母。

分母：

$$
\prod_{i=l}^r\prod_{j=1}^ij^{\lfloor\frac{i}{j}\rfloor}
$$
$$
=\prod_{j=1}^r\prod_{i=l}^rj^{\lfloor\frac{i}{j}\rfloor}
$$
$$
=\prod_{j=1}^rj^{\sum_{i=l}^r\lfloor\frac{i}{j}\rfloor}
$$
$$
=\frac{\prod_{j=1}^rj^{\sum_{i=1}^r\lfloor\frac{i}{j}\rfloor}}{\prod_{j=1}^{l-1}j^{\sum_{i=1}^{l-1}\lfloor\frac{i}{j}\rfloor}}
$$

不难发现这个分式的分子分母本质相同。因此只需做

$$
\prod_{j=1}^nj^{\sum_{i=1}^n\lfloor\frac{i}{j}\rfloor}
$$

考虑 $n\to n+1$ 增量的这个过程中，上面式子的变化。显然贡献只在 $i=n+1$ 时产生。那么单拎一项来看：

$$
j^{\lfloor\frac{n}{j}\rfloor}\to j^{\lfloor\frac{n+1}{j}\rfloor}
$$

那么显然当且仅当 $j\mid (n+1)$ 时才会在产生原有贡献的基础后再产生 $j$ 的贡献。换言之，这个式子的二次（积）差分就是 $(n+1)$ 的因子积。而因子积就是 $\sqrt {n^{\tau (n)}}$。于是再线性筛一下就做完了。

---


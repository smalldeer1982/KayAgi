# 【XR-2】约定

## 题目背景

>「小圆，不要走！这一分离，我们何时才能重逢？」
>
>「小焰，我们一定还会相见的！在那之前，我们只是短暂的离别啊......」

## 题目描述

只因为那一句约定，小焰开始了看不到尽头的等待。

约定在小焰心中幻化成了一张 $n$ 个点的图。一开始，这是一张完全图，其中点的编号从 $1$ 到 $n$，连接点 $i,j$ 的边的权值为 $(i+j)^k$。

然而等待的过程中，岁月也在逐渐消磨着她的信仰，因此图中的一些边被随机地删掉了。最终，图变成了一棵 $n$ 个点的树，永远地留在了小焰的心中。

很久很久以后，小焰的魔力耗尽，在痛苦与绝望之中濒临崩溃。而就在这时，小圆终于来找小焰了。为了拯救自己唯一的朋友，她必须知道这棵树边权和的期望值对 $998244353$ 取模的结果是多少。

你能帮小圆求出答案，让她完成那个约定吗？

## 说明/提示

【样例 $1$ 说明】

这个完全图有 $3$ 个节点，$3$ 条边，形成了一个环。  
这些边的权分别为：$3,4,5$   
最后形成的树也有 $3$ 种可能，权值分别为：$7,8,9$  
期望值为 $8$。

【数据规模与约定】

**本题采用捆绑测试。**

Subtask 1（5 points）：$1 \le n \le 5$，$1\le k \le 10$。     
Subtask 2（11 points）：$k = 1$。  
Subtask 3（11 points）：$1 \le n,k \le 20000$。  
Subtask 4（13 points）：$1 \le n,k \le 10^5$。   
Subtask 5（23 points）：$1 \le k \le 10^5$。  
Subtask 6（37 points）：无特殊限制。

对于 $100\%$ 的数据，$1\le n \le 998244352,1\le k \le 10^7$。
****
>「抱歉，让你久等了...... 你一直努力到了今天吧......」  
>
>「小圆......」
>
>「来，我们走吧。今后我们永不分离......」
>
>「是啊，我等这一刻——望眼欲穿。」

## 样例 #1

### 输入

```
3 1
```

### 输出

```
8
```

## 样例 #2

### 输入

```
4 3
```

### 输出

```
450
```

## 样例 #3

### 输入

```
1926 817
```

### 输出

```
984167516
```

# 题解

## 作者：NaCly_Fish (赞：27)

### 【XR-2】约定 题解

先说句闲话（雾）

验题人 [EntropyIncreaser](https://www.luogu.org/space/show?uid=21423) 对这题是这么说的：“虽然比较裸，但是还是需要比较有经验啊”。

出题人只会出裸题，菜爆了 qaq

#### 题目大意

> $n$ 个点的无向完全图，编号从 $1$ 到 $n$。$u,v$ 之间的边权为 $(u+v)^k$，求这个图的生成树期望边权和。

#### 前置知识

- 期望
- 生成树
- 拉格朗日插值
- 线性求逆元

#### 题解

一个无向完全图有 $n^{n-2}$ 棵生成树，总共就有 $(n-1)n^{n-2}$ 条边。而完全图中一共有 $\frac{n(n-1)}{2}$ 条边，可以发现，每条边在生成树中均出现 $2n^{n-3}$ 次。

于是我们可以推出一个式子：

$$\large ans=\frac{2n^{n-3}}{n^{n-2}}\sum\limits_{i=1}^{n-1}\sum\limits_{j=i+1}^n(i+j)^k=\frac{2}{n}\sum\limits_{i=1}^{n-1}\sum\limits_{j=i+1}^n(i+j)^k$$

这样就可以暴力计算，预处理一下自然数$k$次幂，就可以做到 $\Theta(n^2)$ 了。  

但是这样显然是不够优秀的，我们考虑优化。

设：

$$\large a_n=\sum\limits_{i=1}^{n-1}\sum\limits_{j=i+1}^n(i+j)^k$$

那么做一下差分

$$\large a_{n}-a_{n-1}=\sum\limits_{i=n+1}^{2n-1}i^k$$

然后这样就能 $\Theta(n\log k)$ 来搞，但还是太慢。

注意到 $a_n$ 关于 $n$ 是一个多项式，稍微冷静分析一下，就发现这是 $k+2$ 次的。

看到这里，很显然需要用拉格朗日插值了。不过我们可以连续取值，直接算出前 $k$ 项的复杂度为 $\Theta(k\log k)$，插值的地方是 $\Theta(k)$ 的。

然而还是不能通过，考虑继续优化。

对于这样一个函数：

$$\large f(x)=x^k$$

显然它是个完全积性函数，可以用线性筛 $\Theta(k)$ 算出 $[1,k]$ 中所有 $f(x)$ 的值。

复杂度的证明很简单，小于 $k$ 的质数约为 $\lfloor k/\ln k \rfloor$ 个，做一次快速幂的是 $\Theta(\log k)$。而快速幂只会在筛到质数的时候做，所以复杂度为 $\Theta((k/\log k)\times\log k)=\Theta(k)$。

最后就是我们在做拉格朗日插值时，会用到求逆元。如果用快速幂或 exgcd 来求的话，还是会比较慢。

所以用一下[【模板】乘法逆元2](https://www.luogu.org/problemnew/show/P5431) 的套路，线性求一波即可。

~~当然你也可以用前后缀积直接解决。~~

把算出来的 $a_n$ 乘 $2$ 再除以 $n$ 即是答案。

#### 代码

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<cmath>
#include<algorithm>
#define N 20000007
#define p 998244353
#define ll long long
#define reg register
using namespace std;

inline void read(int &x);
void print(int x);
inline int power(int a,int t);
int solve();

inline int add(int a,int b){
    return a+b>=p?a+b-p:a+b;
}

inline int dec(int a,int b){
    return a<b?a-b+p:a-b;
}

int n,k,lim,ans,cnt;
int f[N],s[N],inv[N],fac[N];

int main(){
    read(n),read(k);
    lim = min((k+3),n+1)<<1;
    s[1] = 1;
    for(reg int i=2;i<=lim;++i){
        if(!s[i]){
            f[++cnt] = i;
            s[i] = power(i,k);
        }
        for(reg int j=1;j<=cnt&&i*f[j]<=lim;++j){
            s[i*f[j]] = (ll)s[i]*s[f[j]]%p;
            if(i%f[j]==0) break;
        }
    }
    for(reg int i=2;i<=lim;++i) s[i] = add(s[i],s[i-1]);
    lim >>= 1;
    f[1] = 0;
    f[2] = power(3,k);
    for(reg int i=3;i<=lim;++i)
        f[i] = add(f[i-1],dec(s[(i<<1)-1],s[i]));
    if(n<=lim) ans = f[n];
    else ans = solve();
    ans = (ll)(ans<<1)*power(n,p-2)%p;
    print(ans);
    return 0;
}

int solve(){
    s[0] = s[1] = 1;
    for(reg int i=2;i<=lim;++i)
        s[i] = (ll)s[i-1]*i%p;
    fac[0] = 1;
    reg int g,mul = 1,res = 0;
    for(reg int i=1;i<=lim;++i){
        mul = (ll)mul*(n-i)%p;
        inv[i] = fac[i] = (ll)s[i-1]*s[lim-i]%p*(n-i)%p;
    }
    for(reg int i=2;i<=lim;++i)
        fac[i] = (ll)fac[i-1]*fac[i]%p;
    fac[lim] = power(fac[lim],p-2);
    for(reg int i=lim;i>=1;--i){
        g = inv[i];
        inv[i] = (ll)fac[i-1]*fac[i]%p;
        fac[i-1] = (ll)g*fac[i]%p;
    }
    for(reg int i=1;i<=lim;++i){
        g = (ll)f[i]*mul%p*inv[i]%p;
        if((lim-i)&1) g = (ll)g*(p-1)%p;
        res = add(res,g);
    }	
    return res;
}

inline int power(int a,int t){
    int res = 1;
    while(t){
        if(t&1) res = (ll)res*a%p;
        a = (ll)a*a%p;
        t >>= 1;
    }
    return res;
}

inline void read(int &x){
    x = 0;
    char c = getchar();
    while(c<'0'||c>'9') c = getchar();
    while(c>='0'&&c<='9'){
        x = (x<<3)+(x<<1)+(c^48);
        c = getchar();
    }
}

void print(int x){
    if(x>9) print(x/10);
    putchar(x%10+'0');
}
```

#### 拓展

以上都是在 $n\neq 998244353$ 的前提下讨论的。

而对于 $n = 998244353$ 这种特殊情况，这里就多扯一句。

首先容易证明插值出来的这个多项式，常数项为 $0$。

要求的答案是 $\large \frac{2a_n}{n} \mod n$ ，相当于求 $2\times[n^1]a_n$。

那么只要求出其一次项系数乘 $2$，就是答案了。

由于只用求一次项，所以可以按照二项式的方法来算，更高次的直接忽略掉，对答案没有影响。

还有就是预处理一下二项式的前后缀积，做法和前面的很类似。

$$\large f(x)=\sum\limits_{i=1}^n\frac{f(i)(-1)^{n-i}}{(i-1)!(n-i)!}\prod_{j\neq i}(x-j)$$

这个式子就是前半部分把阶乘逆元预处理好，后半部分就是刚才说的前后缀积处理。

两种情况的时间复杂度都为 $\Theta(k)$。

对了，既然此题是用的小圆作为题面，那就在题解的最后放上一张图吧~
![](https://cdn.luogu.com.cn/upload/pic/60975.png)

---

## 作者：VenusM1nT (赞：21)

拉格朗日插值法。  
大概咕了两个月的题……难顶  
  
---
### 前置芝士：拉格朗日插值法  
因为不会所以瞎讲一点……  
首先给定若干点 $(x_i,y_i)$，试求出一条曲线的解析式 $f(x)$ 使其穿过这些点。  
假定现在有三个 $x,y$ 互不相同的点，不妨假设 $f(x)=ax^2+bx+c$，则可以得到三个方程，然后通过解三元一次方程来得到 $a,b,c$ 的取值，但我们也可以用更巧妙的办法，即拉格朗日插值法。  
我们可以分别构造三条曲线，第一条曲线 $f_1(x)$ 在 $x_1$ 处取值为 $1$，在 $x_2,x_3$ 处取值为 $0$；第二条曲线 $f_2(x)$ 在 $x_2$ 处取值为 $1$，在 $x_1,x_3$ 处取值为 $0$；第三条曲线 $f_3(x)$ 在 $x_3$ 处取值为 $1$，在 $x_1,x_2$ 处取值为 $0$，然后就可以得到：  
$$f(x)=y_1f_1(x)+y_2f_2(x)+y_3f_3(x)$$  
代值进去发现是没有问题的，我们再来考虑怎么求 $f_i(x)$。  
首先 $f_i(x)$ 必然是一个二次函数，然后就是 $f_i(x)$ 就是要满足我们上述的定义，即 $f_i(x_j)=[i=j]$，以下我们以 $f_1$ 为例进行推导。  
首先为了使 $f_1$ 在 $x_2,x_3$ 处为 $0$，我们不妨令 $f_1(x)=(x-x_2)(x-x_3)$，显然这样是满足在 $x_2,x_3$ 处为 $0$ 这一条件的，但是并不满足在 $x_1$ 处为 $1$ 这一条件，那么我们可以代入 $x_1$，得到 $f_1(x_1)=(x_1-x_2)(x_1-x_3)$，显然这是一个常数，为了让 $f_1(x_1)=1$，我们可以令  
$$f_1(x)=\frac{(x-x_2)(x-x_3)}{(x_1-x_2)(x_1-x_3)}$$  
显然，这个式子满足定义，且因为 $(x_1-x_2)(x_1-x_3)$ 是常数，也满足二次函数的要求。更一般地，我们可以将它扩展一下：  
$$f_i(x)=\prod_{j=1\& j\neq i}^{n}\frac{x-x_j}{x_i-x_j}$$  
代回至 $f(x)$，即得  
$$f(x)=\sum_{i=1}^{n}y_i\times f_i(x)$$

---

### 回到这道题  
首先这道题的期望式子还是很好推的，因为每条边被留下的次数是相等的，都是  
$$\frac{2\times(n-1)}{n(n-1)}=\frac2n$$  
因为生成树有 $n-1$ 条边，而完全图有 $\frac{n\times(n-1)}{2}$ 条边，所以概率是这个，转化为期望则可得：  
$$\frac2n\sum_{i=1}^{n-1}\sum_{j=i+1}^n(i+j)^k$$  
因为 $\frac2n$ 很不方便，考虑先将它提出来，最后再处理，则记：  
$$E_n=\sum_{i=1}^{n-1}\sum_{j=i+1}^n(i+j)^k$$  
考虑能不能找出递推式，将前一项与后一项作差得：  
$$E_n-E_{n-1}=\sum_{i=1}^{n-1}\sum_{j=i+1}^n(i+j)^k-\sum_{i=1}^{n-2}\sum_{j=i+1}^{n-1}(i+j)^k\ \ \ $$  
$$=\sum_{i=1}^{n-2}(n+i)^k+(n\times2-1)^k$$  
$$=\sum_{i=n+1}^{n\times2-1}i^k\quad \quad \quad\quad \quad \quad \quad \quad \ $$  
即得递推式如下： 
$$E_n=E_{n-1}+\sum_{i=n+1}^{n\times2-1}i^k$$  
考虑求其通项公式，因为 $E_1$ 对应的 $i$ 是从 $2$ 到 $1$，显然 $E_1=0$，得出通项公式如下：  
$$E_n=\sum_{i=2}^n\sum_{j=i+1}^{i\times2-1}j^k$$  
可以将它视作一个 $k+2$ 次的多项式，考虑大力插值，因为 $f(x)=x^k$ 这个函数完全积性，可以直接线筛一下，得到对应的值，然后考虑怎么优化插值的过程，由于我们下方取的 $x$ 是连续的，可以直接维护阶乘。  
至于逆元的操作，可以见 `P5431【模板】乘法逆元2`，维护前后缀积。  
```cpp
#include<bits/stdc++.h>
#define MAXN 10000005
#define reg register
#define inl inline
#define int long long
using namespace std;
const int Mod=998244353;
int tot,pri[MAXN],p[MAXN<<1];
int n,k,a[MAXN],pre[MAXN],suf[MAXN],inv[MAXN];
bool isp[MAXN<<1];
inl int Pow(reg int x,reg int y)
{
	reg int res=1;
	for(;y;y>>=1,x=x*x%Mod) if(y&1) res=res*x%Mod;
	return res;
}
inl void Init(reg int N)
{
	p[1]=1;
	for(reg int i=2;i<=N;i++)
	{
		if(!isp[i])
		{
			pri[++tot]=i;
			p[i]=Pow(i,k);
		}
		for(reg int j=1;j<=tot && i*pri[j]<=N;j++)
		{
			isp[i*pri[j]]=1;
			p[i*pri[j]]=p[i]*p[pri[j]]%Mod;
			if(!(i%pri[j])) break;
		}
	}
	for(reg int i=2;i<=N;i++) p[i]=(p[i]+p[i-1])%Mod;
}
inl void Lagrange(reg int N)
{
	a[1]=0;
	pre[0]=pre[N+1]=suf[0]=suf[N+1]=inv[0]=1;
	reg int prod=1;
	for(reg int i=2;i<=N;i++) a[i]=(a[i-1]+p[i*2-1]-p[i]+Mod)%Mod;
	for(reg int i=1;i<=N;i++)
	{
		prod=prod*i%Mod;
		pre[i]=(n-i)*pre[i-1]%Mod;
	}
	inv[N]=Pow(prod,Mod-2);
	for(reg int i=N;i>=1;i--)
	{
		suf[i]=(n-i)*suf[i+1]%Mod;
		inv[i-1]=inv[i]*i%Mod;
	}
}
inl int Solve(reg int N)
{
	reg int res=0;
	for(reg int i=1;i<=N;i++)
	{
		reg int x=a[i]*pre[i-1]%Mod*suf[i+1]%Mod*inv[i-1]%Mod*inv[N-i]%Mod;
		if((N-i)&1) x=Mod-x;
		res=(res+x)%Mod;
	}
	return res;
}
signed main()
{
	scanf("%lld %lld",&n,&k);
	Init((k+3)<<1);
	Lagrange(k+3);
	printf("%lld\n",Solve(k+3)*Pow(n,Mod-2)%Mod*2%Mod);
	return 0;
}
```

---

## 作者：Fading (赞：9)

思路比较顺的卡常题...



------------

### 题解

首先，一个$n$个点完全图的生成树有$n^{n-2}$种

假设一条边在所有生成树中出现了$x$次。

那么很显然：

$$x=\frac {n^{n-2}(n-1)}{[\frac {n(n-1)}2]}$$

为什么呢？

显然边是随机分布的，那么$x$就是

$$\frac {\text{所有生成树的边数和}}{\text{边的个数}}$$

就是上述结果，也就是

$$2n^{n-3}$$

好的，所以我们可以枚举所有的边，就是答案了。

$$ans=\frac {\sum_{i=1}^{n}\sum_{j=1}^{i-1}2n^{n-3}(i+j)^k}{n^{n-2}}$$

$$=\frac {2\sum_{i=1}^{n}\sum_{j=1}^{i-1}(i+j)^k}{n}$$

$i,j$不对称，真的烦，直接容斥一下，转化成对称的。

$$=\frac {2[\sum_{i=1}^{n}\sum_{j=1}^{n}(i+j)^k\ -\sum_{i=1}^n(2i)^k]}{2n}$$

后面这个是去掉$i=j$的贡献。

$$=\frac {\sum_{i=1}^{n}\sum_{j=1}^{n}(i+j)^k\ -2^k\sum_{i=1}^ni^k}{n}$$

接下来怎么做呢？

后面这个可以$O(klog_2k)$拉格朗日插值出来（不会的去[这里](https://www.luogu.org/problemnew/show/CF622F)学学）。

前面这个？

我用了二项式展开：

$$=\frac {\sum_{i=1}^{n}\sum_{j=1}^{n}\sum_{d=0}^kC_k^di^dj^{k-d}\ -2^k\sum_{i=1}^ni^k}{n}$$

$$=\frac {\sum_{d=0}^kC_k^d\sum_{i=1}^{n}i^d\sum_{j=1}^{n}j^{k-d}\ -2^k\sum_{i=1}^ni^k}{n}$$

难道我们要插出$1\sim k$的所有$f(k)=\sum_{i=1}^ni^k\ ?$

$naive$！

显然是不行的。

我们可以枚举$i+j=d$

$$=\frac {\sum_{d=1}^{2n}[i+j=d\text{的方案数}]d^k\ -2^k\sum_{i=1}^ni^k}{n}$$

$i+j=d(i\leq n,j\leq n)$的方程解数怎么求呢？

发现打一个表

$\ \ \ \ \ \ \ \ 1\ \ \ \ \ \ 2\ \ \ \ \ \ 3\ \ \ \ \ \  4\ \ ...$

$1\ \ \ \ \ \ 2^k\ \ \ \ 3^k\ \ \ 4^k\ \ \ \ \ 5^k$

$2\ \ \ \ \ \ 3^k\ \ \ \ 4^k\ \ \ 5^k\ \ \ \ \ 6^k$

$3\ \ \ \ \ \ 4^k\ \ \ \ 5^k\ \ \ 6^k\ \ \ \ \ 7^k$

$4\ \ \ \ \ \ 5^k\ \ \ \ 6^k\ \ \ 7^k\ \ \ \ \ 8^k$

可以发现每一条对角线的数都是一样的。

所以当$d\leq n$的时候，$i+j=d\text{的方案数}$是$d-1$

否则就是$2n-d+1$

那么解法就显而易见了！

$$=\frac {\sum_{d=1}^{n}(d-1)d^k+\sum_{d=n+1}^{2n}(2n-d+1)d^k\ -2^k\sum_{i=1}^ni^k}{n}$$

$$=\frac {\sum_{d=1}^{n}d^{k+1}-\ \sum_{d=1}^{n}d^k+\sum_{d=n+1}^{2n}(2n-d+1)d^k\ -2^k\sum_{i=1}^ni^k}{n}$$

我们设$D_{0,k}=\sum\limits_{d=1}^ni^k,D_{1,k}=\sum\limits_{d=1}^{2n}i^k,D_{0,k+1}=\sum\limits_{d=1}^ni^{k+1},D_{1,k+1}=\sum\limits_{d=1}^{2n}i^{k+1}$

答案就是

$$=\frac {(2n+1)D_{1,k}-(2n+2)D_{0,k}+2D_{0,k+1}-D_{1,k+1}-2^kD_{0,k}}{n}$$

所以拉格朗日插值四次,求出$D_{0,k},D_{1,k},D_{0,k+1},D_{1,k+1}$就好啦！

### 实现

等等这样是$O(k\log_2k)$的？？？

怎么办？

我们发现算法的这个$\log$的位置非常有趣:快速幂,逆元

那逆元就线性求就好了啊。

但是一个数的$k$次方怎么快速求？？？

可以**线性筛**。

首先$1\sim k$之间的质数个数是$\frac k{\ln k}$级别的。

我们可以先预处理每一个质数的$k$次方，然后根据$(i\times p_j)^k=i^k\cdot p_j^k$来筛。

这其实就是完全积性。

那么这个算法的复杂度就是稳稳的$O(k)$了。

### 卡常

~~由于比赛人太多了评测机极其不稳定于是我T了~~

所以我开始卡常：

$1,$O2

$2,$register

$3,$减小取模量

$4,k$次幂$k+1$次幂不需要线性筛两次，算出$k$的用的时候直接再乘一次就好了。

### 细节

拉格朗日插值$k$次多项式要代入$k+1$个点值！

$\sum\limits_{i=1}^ki^k$是$k+1$次的！

所以线性筛的时候最大值要设成$10000000+3\ !!!$

WA的飞起$...$~~如果是CF就去世了~~

下面献上千疮百孔的代码：

```cpp
#include<bits/stdc++.h>
#define ll long long
#define ljc 998244353
using namespace std;
#ifdef Fading
#define gc getchar
#endif
#ifndef Fading
inline char gc(){
    static char now[1<<16],*S,*T;
    if (T==S){T=(S=now)+fread(now,1,1<<16,stdin);if (T==S) return EOF;}
    return *S++;
}
#endif
inline ll read(){
    register ll x=0,f=1;char ch=gc();
    while (!isdigit(ch)){if(ch=='-')f=-1;ch=gc();}
    while (isdigit(ch)){x=(x<<3)+(x<<1)+ch-'0';ch=gc();}
    return (f==1)?x:-x;
}
inline ll fast_pow(ll a,ll b,ll p){
    ll t=1LL;
    while (b){
        if (b&1LL) t=t*a%p;
        b>>=1LL;a=a*a%p;
    }
    return t;
}
bool vis[10000222];
ll fac[10000222],p[3000222],inv[10000222];
ll ans[10000222],n,m,K,tot;
void init(ll KK){
    vis[1]=1;ans[1]=1;
    for (int i=2;i<=KK;i++){
        if (!vis[i]) p[++tot]=i,ans[i]=fast_pow(i,K,ljc);
        for (int j=1;j<=tot;j++){
            if (p[j]*i>1+KK) break;
            vis[p[j]*i]=1;
            ans[p[j]*i]=ans[p[j]]*ans[i]%ljc;
            if (i%p[j]==0) break;
        }
    }
}
ll L[10000321],R[10000321];
inline ll getik(ll K,ll n,ll op){
    register ll NOW=0,y=0;
    L[0]=R[K+3]=fac[0]=1;
    if (K==0) return n;
    for (register int i=1;i<=K+2;i++) L[i]=L[i-1]*(n-1LL*i+ljc)%ljc;
    for (register int i=K+2;i>=1;i--) R[i]=R[i+1]*(n-1LL*i+ljc)%ljc;
    if (n<=K+1){
    	for (register int i=1;i<=n;i++){
    		NOW=(NOW+(op?1LL*ans[i]*i:ans[i]))%ljc;
        }
        return NOW;
    }
    for (register int i=1;i<=K+2;i++){
        y=(y+(op?1LL*ans[i]*i:ans[i]))%ljc;
        register ll a=L[i-1]*R[i+1]%ljc;
        register ll b=inv[i-1]*((K-i)&1LL?-1LL:1LL)*inv[K+2-i]%ljc;
        NOW=(NOW+y*a%ljc*b)%ljc;
    }
    return (NOW+ljc)%ljc;
}
signed main(){
    cin>>n>>K;
    fac[0]=inv[0]=inv[1]=1;
    for (register ll i=1;i<=K+2;i++) fac[i]=fac[i-1]*1LL*i%ljc;
    for (register ll i=2;i<=K+2;i++) inv[i]=(ljc-(ljc/i)*inv[ljc%i]%ljc)%ljc;
    for (register int i=1;i<=K+2;i++) inv[i]=inv[i-1]*inv[i]%ljc;
    ll fm=fast_pow(n,ljc-1+n-2,ljc),fz=0,two=fast_pow(2,K,ljc);
    init(K+10);
    ll D1k=getik(K,2*n,0),D0k=getik(K,n,0),D1k1=getik(K+1,2*n,1),D0k1=getik(K+1,n,1);
    fz=((2*n+1)%ljc*D1k%ljc-(2*n+2)%ljc*D0k%ljc+ljc+2*D0k1%ljc-D1k1+ljc)%ljc;
    fz=(fz-two*D0k%ljc+ljc)%ljc;	
    fz=fz*fast_pow(n,ljc-1+n-3,ljc)%ljc;
    printf("%lld\n",fz*fast_pow(fast_pow(n,(ljc-1+n-2),ljc),ljc-2,ljc)%ljc);
    return 0;
}

```


---

## 作者：Soulist (赞：5)

综合了很多很多的东西？？？

$Step1:$对题意的转化。

原图有：$n(n-1)/2$条边

保留$n-1$条边

所以某条边被保留的概率是$\dfrac{n-1}{n(n-1)/2}=\dfrac{2}{n}$

考虑此边对答案的贡献：为$(i+j)^k$

所以原题所求即：

$$\dfrac{2}{n}\sum_{i=1}^{n-1}\sum_{j=i+1}^n(i+j)^k$$




我们不妨记：

$$S_n=\sum_{i=1}^{n-1}\sum_{j=i+1}^n(i+j)^k$$

可以发现：

$$S_n-S_{n-1}=\sum_{i=1}^{n-1}\sum_{j=i+1}^n(i+j)^k-\sum_{i=1}^{n-2}\sum_{j=i+1}^{n-1}(i+j)^k$$

也就是：

$$\sum_{i=1}^{n-2}(i+n)^k+(2n-1)^k$$

$$\sum_{i=n+1}^{2n-1}i^k$$

于是我们所困扰的原式，就变成了：

$$S_n=S_{n-1}+\sum_{i=n+1}^{2n-1}i^k$$

有趣的是，当$n=1$的时候，$S_1=0$

故，我们得到了：

$$S_n=0+\sum_{i=2}^n\sum_{j=i+1}^{2i-1}j^k$$

所以原式子即：

$$\sum_{i=2}^n\sum_{j=i+1}^{2i-1}j^k$$

接下来我们考虑如何快速求这个式子：

$1.$我会暴力

恭喜你白化简了。。。

$2.$拉格朗日插值法求解：

为了解决这个式子，我们需要一点前置芝士

**$1.$ 拉格朗日插值公式**

我们现在需要处理一个这样的问题：

给定$n+1$个点是可以确定一个$n$次多项式的

然后我们需要快速求出$f(k)$的值

方法$1$：我们可以把系数依次写出，列出连续的方程组，高斯消元求解，然后这样的做法复杂度是$O(n^3)$的

方法$2$：

考虑到对于$(n+1)$个点确定的$n$次多项式，我们可以进行一个微妙的拆分。

我们现在尝试去构造一些多项式$f_{k}(x)$，他满足这样的一个性质：

对于任意$x_i,i\neq k$，有：$f_k(x_i)=0$，且$f_k(x_k)=1$

乍一看，这个函数真的能被构造出来吗？

然后实际上真的可以，我们令：

$$f_k(x)=\prod_{(i=1)\&(i\neq k)}^n\dfrac{x-x_i}{x_k-x_i}$$

那么$f$函数如何求出？

我们发现构造出来的函数貌似求个和，对于$(x_i)$也只会等于$1$欸欸欸？

那么给哪一个小函数乘上$y_i$就好了？！

所以我们得到了：

$$f(x)=\sum_{i=1}^ny_i*f_i(x)$$

$$f(x)=\sum_{i=1}^ny_i*\prod_{j\neq i}\dfrac{x-x_j}{x_i-x_j}$$

我们考虑把$k$带入上式，不难发现求出答案的复杂度是$O(k^2)$

**回到主题**

我们仔细思考，貌似关于连续数的$k$次幂求和所得到的值是关于其上限的$k+1$次幂多项式。而且最后往往是关于其上界$(n)$的$k+1$次多项式

于是我们不难发现，这个东东是对些连续取值的$(k+1)$次多项式的求和，那么它应该是$k+2$次幂的多项式，也是关于$n$的

于是我们考虑插值，先求出$x=1,2,3...(k+3)$的时候函数的值，那么我们最后只需要求其$x$取$n$的时候的函数值即可。

但按照之前讲的插值方法，貌似带入值直接算不太合算。与暴力的复杂度大同小异。

所以我们考虑先预处理出这个函数的前缀和：

$$\sum_{i=1}^ni^k$$

因为我们需要知道至少$k+3$个点才行

考虑依次求出$k=1,2,3...k+3$时的函数值，那么最大最大时前缀和应求到：$(2*(k+3)-1)=(2k+5)$的时候

这也就意味着我们的复杂度和$N$：$say\quad goodbye$了

求这个东西的前缀和如果时暴力的，那么复杂度是$O(k\log k)$的

但有趣的在于它是一个被叫做完全积性函数的有趣函数。

所以我们实际上并不需要求出其所有的函数值，求出质数的即可。

其他的函数的函数值可以通过质数的函数值的乘积得到。

因为素数个数大致是:$(n/\ln n)$个，所以对他们求快速幂的复杂度是$O(k/\ln k * \log k)$ 近似于$O(K)$

然后我们考虑对于某个值$x$，我们想要$O(1)$求出它的$y$值

我们发现

$$f(x)=\sum_{i=2}^x\sum_{j=i+1}^{2i-1}j^k$$


我们发现它似乎又等于：

$$f(x) = f(x-1)+\sum_{i=x+1}^{2x-1}i^k$$

$$f(x-1)+(sum[2x-1]-sum[x])$$

所以求出这$k+3$的横纵坐标的复杂度已经是近似于$O(k)$了。

然而知道$k$个坐标求具体某个数带进去的函数值仍然是$O(k^2)$的

这个时候我们需要对拉格朗日插值公式的进一步理解？

**前置芝士$2:$** x值连续时如何做

我们发现一个特别有意思的地方。

在做题的时候我们常常是需要自己求出$k$个点的值

而它们常常是连续的。

于是我们考虑：

$$f(x)=\sum_{i=1}^ny_i*\prod_{j\neq i}\dfrac{x-x_j}{x_i-x_j}$$

对于分子，我们可以分别维护一下前缀积和后缀积

对于分母，我们不难发现$x$值是连续的$(1,2...k+3)$，所以有趣的就是，它们在底部作的差就是$1,2...k+2$的连续乘积。

比如$k$取$5$，$i$取$3(x_i=3)$的时候

底部即：$(3-1)(3-2)(3-4)...(3-7)$

我们发现它就是：$(2* 1*(-1)*...(-4))$

所以加上一个符号判断并对分母维护一下阶乘就好了。

但分母需要做逆元。

如果对每个阶乘积都求逆元，复杂度还是$O(k \log k)$

我们考虑记：$S_n=\prod_{i=1}^n i$

那么，我们考虑求出$S_{2k+5}(last \quad one)$的逆元。

因为： 

$$S_i^{-1}=S_{i+1}^{-1}*(i+1)$$

所以我们就可以从$S_{2k+5}$逆推回去得到所有的$S_i$

当我们将前缀积，后缀积(分母)，阶乘逆元均处理出来后，我们代回去求值的复杂度就是$O(K)$的了。

最终复杂度$O(K)$

现在我们回顾一下流程：

> $1.$ 根据题意，得到：
$\dfrac{2}{n}\sum_{i=1}^{n-1}\sum_{j=i+1}^n(i+j)^k$

> $2.$ 化简得到：$\dfrac{2}{n}\sum_{i=2}^n\sum_{j=i+1}^{2i-1}j^k$

> $3.$ 发现它是一个$k+2$次多项式，考虑快速求解它，需要$O(K)$的求出$k+3$个点的横纵坐标，可以考虑利用线性筛求出前缀和并处理。

> $4.$代入求值暴力的做法是$O(k^2)$的，所以我们利用一下取值连续的性质，得到$O(k)$做法

代码：(注意卡空间)

```cpp
#include<bits/stdc++.h>
using namespace std;
#define rep( i, s, t ) for( register int i = s; i <= t; ++ i )
#define drep( i, s, t ) for( register int i = t; i >= s; -- i )
#define re register
#define int long long
#define LL long long
const int N = 1e7 + 5 ;  
const int mod = 998244353 ; 
int read() {
	char cc = getchar(); int cn = 0, flus = 1;
	while(cc < '0' || cc > '9') {  if( cc == '-' ) flus = -flus;  cc = getchar();  }
	while(cc >= '0' && cc <= '9')  cn = cn * 10 + cc - '0', cc = getchar();
	return cn * flus;
}
int pr[N], sumf[2 * N], top ;
int n, b[N], pre[N], nxt[N], inv[N], K ; 
bool isp[2 * N] ; 
LL pow2( int x, int k ) {
	LL ans = 1, base = x ; 
	while( k ) {
		if( k & 1 ) ans *= base, ans %= mod ;
		base *= base, base %= mod ; 
		k >>= 1 ; 
	}
	return ans % mod ; 
}
void init( int x ) {
	sumf[1] = 1 ;
	rep( i, 2, x ) {
		if( !isp[i] ) pr[++ top] = i, sumf[i] = pow2( i, K );
		for( re int j = 1; j <= top && i * pr[j] <= x; ++ j ) {
			isp[i * pr[j]] = 1, sumf[i * pr[j]] = ( sumf[i] * sumf[pr[j]] ) % mod ; 
			if( i % pr[j] == 0 ) break; 
		} 
	}
	rep( i, 2, x ) sumf[i] = sumf[i - 1] + sumf[i] ; 
}
void lagr( int x ) {
	b[1] = 0, nxt[0] = nxt[x + 1] = pre[x + 1] = pre[0] = inv[0] = 1; int Fac = 1 ; 
	rep( i, 2, x ) b[i] = ( b[i - 1] + sumf[2 * i - 1] - sumf[i] + mod ) % mod ; 
	rep( i, 1, x ) Fac = ( Fac * i ) % mod, pre[i] = ( n - i ) * pre[i - 1] % mod;
	inv[x] = pow2( Fac, mod - 2 ) ; 
	drep( i, 1, x ) nxt[i] = ( nxt[i + 1] * ( n - i ) ) % mod, inv[i - 1] = ( inv[i] * i ) % mod ; 
	
}
int get( int x ) {
	int Ans = 0, d ;
	rep( i, 1, x ) {
		d = ( b[i] * pre[i - 1] ) % mod, d = ( d * nxt[i + 1] ) % mod;
		d = ( d * ( ( inv[i - 1] * inv[x - i] ) % mod ) ) % mod ; 
		if( ( x - i ) % 2 ) d = mod - d ; 
		Ans = ( Ans + d ) % mod ;
	}
	return Ans % mod ; 
}
signed main()
{
	n = read(), K = read() ; 
	init( 2 * K + 6 ), lagr( K + 3 ) ; 
	int Kth = pow2( n, mod - 2 ) * 2 % mod ; 
	printf("%d\n", ( 1ll * get( K + 3 ) * Kth % mod ) ) ; 
	return 0;
}

```

---

## 作者：Otue (赞：2)

## [P5437 【XR-2】约定](https://www.luogu.com.cn/problem/P5437)

### 题目大意

一张 $n$ 个点的图。一开始，这是一张完全图，其中点的编号从 $1$ 到 $n$，连接点 $i,j$ 的边的权值为 $(i+j)^k$。图中的一些边被随机地删掉了。最终，图变成了一棵 $n$ 个点的树，这棵树边权和的期望值对 $998244353$ 取模的结果是多少。

### 题目思路

可以知道，每条边因为随机留下，那么一条边留下的概率为 $\dfrac{2(n-1)}{n\times (n-1)}=\dfrac{2}{n}$。那么答案显然为 $\dfrac{2}{n}\times \sum\limits_{i=1}^n \sum\limits_{j=i+1}^n (i+j)^k$​。

有一个很妙的想法是差分。定义 $a_n=\sum\limits_{i=1}^n \sum\limits_{j=i+1}^n (i+j)^k$，那么可以得到 $a_n-a_{n-1}=\sum\limits_{i=n+1}^{2n-1} i^k$。处理出 $f(x)=\sum\limits_{i=1}^{x} i^k$，则 $a_n-a_{n-1}=f(2n-1)-f(n)$。如果 $f(x)$ 可以快速求出，那么则可以递推求出 $a_n$，那么可以直接 $O(n)$ 求解答案，但显然是过不了的。

考虑直接对 $a_n$ 进行插值！显而易见 $a_n$ 是 $k+2$ 次多项式。那么我们只要求出 $a_{1}$ 到 $a_{k+3}$，而不需要求解到 $n$ 就可以进行差值了。插值复杂度必须做到 $O(k)$，那么根据 CF622F 的思路直接预处理前缀积和后缀积，再加一个线性求逆即可。

只剩一个问题：如何快速在 $O(k)$ 时间内求解 $f(x)$ 当 $x\leq 2(k+3)-1$。只需要在 $O(1)$ 时间求解 $i^k$！因为 $i^k$​ 是完全积性函数，直接线性筛预处理即可！

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
 
#define PII pair<int, int>
#define _for(i, a, b) for (int i = (a); i <= (b); i++)
#define _pfor(i, a, b) for (int i = (a); i >= (b); i--)
//#define int long long
 
const int N = 4e6 + 5, M = 2e7 + 15, mod = 998244353;
 
int n, k, lim, prime[N], cnt;
long long res;
int s[M], f[M];
 
 
#define LL long long
int qpow(long long a, int k, int p) {
    if (a > mod) a -= mod;
//  cout << a << ' ' << k << ' ' << p << endl;
    long long res = 1;
    while (k) {
        if (k & 1) res = res * a % p;
        a = a * a % p;
        k >>= 1;
    }
    return res;
}
 
void init() {
    s[1] = 1;
    _for(i, 2, 2 * (k + 3) - 1) {
        if (!s[i]) {
            prime[++cnt] = i;
            s[i] = qpow(i, k, mod);
        }
        for (int j = 1; j <= cnt && i * prime[j] <= 2 * (k + 3) - 1; j++) {
            s[i * prime[j]] = (LL)1ll * s[i] * 1ll * s[prime[j]] % mod;
            if (i % prime[j] == 0) break; 
        }
    }
//  _for(i, 1, 2 * (k + 3) - 1) cout << s[i] << endl;
    _for(i, 2, 2 * (k + 3) - 1) s[i] = (s[i] + s[i - 1]) % mod;
    f[1] = 0; f[2] = qpow(3, k, mod);
    _for(i, 3, k + 3) f[i] = ((f[i - 1] + s[i * 2 - 1]) % mod - s[i] + mod) % mod;
//  _for(i, 1, k + 3) cout << f[i] << endl;
}
 
int fac[M], sfac[M], ffac[M], pfac[M], p[M];
int invfac[M];
 
void calc(int n) {
    fac[0] = pfac[0] = sfac[0] = 1;
    _for(i, 1, k + 3) sfac[i] = 1ll * sfac[i - 1] * 1ll * ((n - i + mod) % mod) % mod;
    ffac[k + 4] = 1;
    _pfor(i, k + 3, 1) ffac[i] = 1ll * ffac[i + 1] * 1ll * ((n - i + mod) % mod) % mod;
    _for(i, 1, k + 3) {
        fac[i] = 1ll * fac[i - 1] * 1ll * i % mod;
//      pfac[i] = pfac[i - 1] * (-i + mod) % mod;
    }
    invfac[k + 3] = qpow(fac[k + 3], mod - 2, mod);
    _pfor(i, k + 2, 0) invfac[i] = 1ll * invfac[i + 1] * 1ll * (i + 1) % mod;
    _for(i, 1, k + 3) {
        long long t1 = 1ll * sfac[i - 1] * 1ll * ffac[i + 1] % mod;
        long long t2 = 1ll * invfac[i - 1] * 1ll * invfac[k + 3 - i] % mod;
        if ((k + 3 - i) % 2 == 1) t2 = (-t2 + mod) % mod;
        p[i] = (LL)1ll * t1 * 1ll * t2 % mod;
    }
    res = 0;
    _for(i, 1, k + 3) {
        res = (res + 1ll * f[i] * 1ll * p[i] % mod) % mod;
    }
}
 
signed main() {
    cin >> n >> k;
    init();
    if (n <= k + 3) {
        cout << 1ll * f[n] * 2 % mod * qpow(n, mod - 2, mod) % mod  << endl;
        return 0;
    }
    calc(n);
    cout << 1ll * res * 2 % mod * qpow(n, mod - 2, mod) % mod << endl;
}

```

---

## 作者：chihik (赞：2)

每一条边被选中的概率： $\frac{n-1}{\frac{n(n-1)}{2}}=\frac{2}{n}$

所以答案为：


$$
\frac{2}{n} \sum_{i=1}^{n-1} \sum_{j=i+1}^n (i+j)^k
$$
单独考虑后面的和式：


$$
f(n)=\sum_{i=1}^{n-1}\sum_{j=i+1}^n(i+j)^k
$$

运用插值的套路：


$$
\Delta (f)=f(n+1)-f(n)=\sum_{i=1}^n\sum_{j=i+1}^{n+1}(i+j)^k-\sum_{i=1}^{n-1}\sum_{j=i+1}^n(i+j)^k=\sum_{i=1}^n(i+n+1)^k=\sum_{i=n+2}^{2n+1}i^k
$$


令 $S(n)=\sum_{i=1}^n i^k$ ，那么有：

$$
\Delta(f)=S(2n+1)-S(n+1)
$$

老祖宗告诉我们 $S$ 是一个 $k+1$ 次多项式，那么 $\Delta(f)$ 也是一个 $k+1$ 次多项式， $f$ 应该是一个 $k+2$ 次多项式。

众所周知前 $k$ 项的自然数幂和可以 $\mathcal O(k)$ 预处理，那么暴力算出 $f$ 前 $k+3$ 项的复杂度为 $\mathcal O(k)$。

然后 $\mathcal O(k)$ 插值即可。

~~做了这道题才发现自己 $\mathcal O(k)$ 的插值是假的~~

```cpp
#include <cstdio>
#include <iostream>
using namespace std;
#define LL long long

const int MAXN = 20000010 , Mod = 998244353;

int Quick_pow( int x , int po ) {
	int Ans = 1;
	for( ; po ; po >>= 1 , x = 1ll * x * x % Mod )
		if( po & 1 ) Ans = 1ll * Ans * x % Mod;
	return Ans;
}
int Inv( int x ) {
	return ( Quick_pow( x , Mod - 2 ) + Mod ) % Mod;
}
int Add( int x , int y ) { x += y; return x >= Mod ? x - Mod : x; }
int Sub( int x , int y ) { x -= y; return x < 0 ? x + Mod : x; }
int Mul( int x , int y ) { return 1ll * x * y % Mod; } 
int Div( int x , int y ) { return 1ll * x * Inv( y ) % Mod; } 
int Fix( int x ) { return ( x % Mod + Mod ) % Mod; }

int fac[ MAXN + 5 ] , ivf[ MAXN + 5 ];
void Init( ) {
	fac[ 0 ] = 1;
	for( int i = 1 ; i <= min( MAXN , Mod - 1 ) ; i ++ ) fac[ i ] = Mul( fac[ i - 1 ] , i );
	ivf[ min( MAXN , Mod - 1 ) ] = Inv( fac[ min( MAXN , Mod - 1 ) ] );
	for( int i = min( MAXN , Mod - 1 ) ; i >= 1 ; i -- ) ivf[ i - 1 ] = Mul( ivf[ i ] , i );
}
int binom( int n , int m ) {
	if( n < m ) return 0;
	return Mul( fac[ n ] , Mul( ivf[ m ] , ivf[ n - m ] ) );
}

int n , k;

int prnum , prime[ MAXN + 5 ] , Sk[ MAXN + 5 ];
bool vis[ MAXN + 5 ];
void sieve( ) {
	Sk[ 1 ] = 1;
	for( int i = 2 ; i <= MAXN ; i ++ ) {
		if( !vis[ i ] ) { 
			prime[ ++ prnum ] = i;
			Sk[ i ] = Quick_pow( i , k );
		}
		for( int j = 1 ; j <= prnum && 1ll * i * prime[ j ] <= MAXN ; j ++ ) {
			vis[ i * prime[ j ] ] = 1;
			Sk[ i * prime[ j ] ] = Mul( Sk[ i ] , Sk[ prime[ j ] ] );
			if( i % prime[ j ] == 0 ) break;
		}
	}
	for( int i = 1 ; i <= MAXN ; i ++ ) Sk[ i ] = Add( Sk[ i ] , Sk[ i - 1 ] ); 
} 

int m;
int pre[ MAXN + 5 ] , suf[ MAXN + 5 ];
int Lagrange( int *fx , int x0 ) {
	pre[ 0 ] = 1;
	for( int i = 1 ; i <= m ; i ++ ) pre[ i ] = Mul( pre[ i - 1 ] , Sub( x0 , i ) );
	suf[ m + 1 ] = 1;
	for( int i = m ; i >= 1 ; i -- ) suf[ i ] = Mul( suf[ i + 1 ] , Sub( x0 , i ) );
	
	int fk = 0;
	for( int i = 1 ; i <= m ; i ++ ) fk = Add( fk , Mul( fx[ i ] , Mul( Mul( pre[ i - 1 ] , suf[ i + 1 ] ) , Fix( ( ( m - i ) & 1 ? -1 : 1 ) * Mul( ivf[ i - 1 ] , ivf[ m - i ] ) ) ) ) );
	return fk;
}
int y[ MAXN + 5 ];

int main( ) {
	Init();
	scanf("%d %d",&n,&k); m = k + 3;
	sieve();
	
	for( int i = 0 ; i < m ; i ++ )
		y[ i + 1 ] = Add( y[ i ] , Sub( Sk[ 2 * i + 1 ] , Sk[ i + 1 ] ) );
	printf("%d\n", Mul( Div( 2 , n ) , Lagrange( y , n ) ) );
	return 0; 
}
```



---

## 作者：mrsrz (赞：2)

算期望的方法有很多，其中一种就是总权值除以方案数。

由于这是一张完全图，所以它每条边出现在生成树上的次数是一样的。

所以我们可以求出完全图的权值和，然后乘上每条边的出现次数，最后除以生成树总数就是期望。

设完全图的权值和为$S$，每条边的出现次数为$p$，生成树总数为$c$。

那么有$p=\frac{c(n-1)}{\frac 1 2n(n-1)}=\frac{2c}n$，$ans=\frac{Sp}c=\frac{2S}n$。

所以最后答案只和权值和与点数有关。

那么怎么求这个$S$。

通过推论/打表找规律等方式，可以发现如下结论：

1. 权值在$1\sim n+1$之间的$i$的出现次数为$\lfloor\frac{i-1}{2}\rfloor$。
2. 权值在$n+2\sim 2n$之间的$i$的出现次数为$\lfloor\frac{2n+1-i}2\rfloor$。

则

$$S=\left(\sum_{i=1}^{n+1}\lfloor\frac{i-1}{2}\rfloor i^k\right)+\left(\sum_{i=n+2}^{2n}\lfloor\frac{2n+1-i}2\rfloor i^k\right)$$

左右两边是相似的，因此只考虑其中一个。

考虑先把下取整去掉，那么就有：

$$\frac{\sum_{i=1}^{n+1}i^{k+1}-i^k}2$$

然后我们发现，这个式子在$i$为偶数的位置都多算了$\frac 1 2$，因此答案中还要减去：

$$\frac{\sum_{i=1}^{n+1}[i\bmod 2=0]i^k}{2}=\frac{\sum_{i=1}^{\lfloor(n+1)/2\rfloor}(2i)^k}2$$

右半边也是在偶数位置上多算了$\frac 1 2$。

我们观察两个式子，现在的问题就是如何快速求$\sum_{i=1}^n i^k$和$\sum_{i=1}^n (2i)^k$这样的式子了。

我们知道，左边那个东西是自然数幂和，其可以表示为一个$k+1$次多项式。那么大胆猜测，右边那个东西也是个$O(k)$次多项式。事实表明这个结论正确。

那么我们只要把这个多项式求出来，然后用秦九韶算法求值即可。快速幂求点值然后多项式快速插值即可，时间复杂度$O(k\log k)$。

这样的复杂度显然不能通过，有没有更快的方法呢。

实际上，我们不想知道那个多项式具体是什么，只需要求出这个多项式在某些点上的点值。

观察拉格朗日插值公式：

$$A(x)=\sum_{i=1}^n y_i\ell_i(x)$$

$$\ell_{i}(x)=\prod_{j=1,j\neq i}^{n}\frac{x-x_j}{x_i-x_j}$$

我们考虑直接带入每个$\ell(x)$。

考虑分母上面的部分，由于$x$和$x_j$都是固定的，因此对每个多项式都是一样的，可以用前缀、后缀积解决。

而分母下面的部分，由于我们插值时取的是连续点值，所以下面可以表示成两个阶乘相乘的形式，也可以预处理出来。

这样就可以在$O(k)$时间内求值。

再考虑如何把快速幂的那个$\log$降下来。

一个套路就是线性筛，由于$i^k$在$k$一定时是积性函数，所以可以线性筛出来，那么只要对于质数位置进行快速幂即可。于是这部分时间复杂度$O(\frac{k\log k}{\ln k})$，可以认为是$O(k)$。

而$(2i)^k=2^ki^k$，也可以通过上面筛出的值得到。

于是就可以在$O(k)$的复杂度内解决本题。

## Code：
```cpp
#include<cstdio>
const int md=998244353,N=1e7+10;
typedef long long LL;
inline void upd(int&a){a+=a>>31&md;}
inline int pow(int a,int b){
    int ret=1;
    for(;b;b>>=1,a=(LL)a*a%md)if(b&1)ret=(LL)ret*a%md;
    return ret;
}
int n,k,vis[N],pri[N/2],P[N],X[N];
int fac[N],iv[N],tot;
int pre[N],suf[N],ans=0;
void init(const int n){
    P[1]=1;
    for(int i=2;i<=n;++i){
        if(!vis[i])pri[++tot]=i,P[i]=pow(i,k);
        for(int j=1;j<=tot&&i*pri[j]<=n;++j){
            vis[i*pri[j]]=1;
            P[i*pri[j]]=(LL)P[i]*P[pri[j]]%md;
            if(i%pri[j]==0)break;
        }
    }
}
inline int query(int x){
    int ret=0;
    for(int i=1;i<=k+3;++i)
    pre[i]=pre[i-1]*(LL)(x-i+md)%md;
    for(int i=k+3;i;--i)
    suf[i]=suf[i+1]*(LL)(x-i+md)%md;
    for(int i=1;i<=k+3;++i){
        int y=X[i]*(LL)pre[i-1]%md*suf[i+1]%md*iv[i-1]%md*iv[k+3-i]%md;
        if((k+3-i)&1)upd(y=-y);
        upd(ret+=y-md);
    }
    return ret;
}
int main(){
    scanf("%d%d",&n,&k);
    if(n==1){puts("0");return 0;}
    init(k+5);
    for(int i=*fac=1;i<=k+5;++i)fac[i]=(LL)i*fac[i-1]%md;
    iv[k+5]=pow(fac[k+5],md-2);
    for(int i=k+5-1;~i;--i)iv[i]=(i+1LL)*iv[i+1]%md;
    pre[0]=suf[k+4]=1;
    for(int i=1;i<=k+5;++i)
    X[i]=(X[i-1]+(LL)(i-1)*P[i]%md)%md;
    ans=query(n+1);
    for(int i=1;i<=k+5;++i)
    X[i]=(X[i-1]+(LL)P[i]*P[2])%md;
    upd(ans-=query(n+1>>1)),ans=(LL)ans*iv[2]%md;
    int ans2=0;
    for(int i=1;i<=k+5;++i)
    X[i]=(X[i-1]+(2*n+1-i+md)*(LL)P[i])%md;
    ans2+=query(n<<1|1)-query(n+1)+md;
    for(int i=1;i<=k+5;++i)
    X[i]=(X[i-1]+(LL)P[i]*P[2])%md;
    ans2=(ans2-(LL)query(2*n+1>>1)+(LL)query(n+1>>1)+md)%md;
    ans=(ans+(LL)ans2*iv[2])%md;
    printf("%lld\n",ans*2*(LL)pow(n,md-2)%md);
    return 0;
}

```

---

## 作者：可爱的小棉羊 (赞：1)

怒调 $2$ 小时最后发现，$0!$ 的逆元写成了 $0$。

红温了。

注意到这是一颗树，考虑到每一条边都有可能同等概率有贡献。

一共有 $n^{n-2}$ 种树，完全图共 $\frac{n(n-1)}{2}$ 条边，树有 $(n-1)$ 条边，所以每条边会 $\frac{n^{n-2}(n-1)}{\frac{n(n-1)}2}=2n^{n-3}$ 次贡献。

答案就是：

$$\frac{2n^{n-3}}{n^{n-2}}\sum_{1\le i<j\le n}(i+j)^n$$

前面那个是 $\frac{2}{n}$，后面记作 $A_n$。

发现：

$$a_n=a_{n-1}+\sum_{i=n+1}^{2n-1}i^k$$

线性筛 $f(i)=i^k$ 这个完全积性函数，可以 $O(n)$。有了一个 $O(n)$ 的做法。

发现 $a_n$ 是一个  $(k+2)$ 次多项式，可以处理到 $k+3$ 的答案，然后进行线性插值。

---

## 作者：Prean (赞：1)

呃怎么感觉很裸啊（

题意是让求生成树边权之和的期望，那么我们只需要算出所有生成树的边权之和除以生成树边数即可。

由于是求和，我们只需要计算出每条边对答案的贡献即可。

我们知道一个完全图有 $ n^{n-2} $ 棵生成树，那么每条边在其中出现过多少次呢？

很容易发现每一条边的地位是相同的，所以所有边出现的次数相同。

那么出现次数就是 $ n^{n-2}\times (n-1) \div \frac {n \times (n-1)} 2 $，也就是 $ 2n^{n-3} $

答案就是 $ \frac {2n^{n-3} \times (\sum_{i=1}^n\sum_{j=i+1}^n (i+j)^k)} {n^{n-2}} $

$$ \frac 2 n \times (\sum_{i=1}^n\sum_{j=i+1}^n (i+j)^k) $$

里面的东西给转化一下：
$$ \frac 1 2 \times (\sum_{i=1}^n\sum_{j=1}^n (i+j)^k - 2^k\sum_{i=1}^n i^k) $$
我们枚举每一个 $ (i+j) $ 的出现次数：
$$ \sum_{i=1}^n (i-1)i^k + \sum_{i=n+1}^{2n} (2n+1-i)i^k - 2^k\sum_{i=1}^n i^k $$
$$ \sum_{i=1}^n i^{k+1}-\sum_{i=1}^n i^k + (2n+1)\sum_{i=n+1}^{2n} i^k - \sum_{i=n+1}^{2n} i^{k+1} - 2^k\sum_{i=1}^n i^k $$
我们只需要知道自然数的 $ k $ 次和 $ k+1 $ 次幂之和即可，使用拉格朗日插值可以做到 $ O(k) $。
```cpp
#include<cstdio>
const int M=1e7+5,mod=998244353;
int n,k,sl[M],sr[M],a1[M],a2[M],idk[M],idk1[M],ifac[M];
int top,pri[664580];bool zhi[M];
inline int Add(const int&a,const int&b){
	return a+b>=mod?a+b-mod:a+b;
}
inline int Del(const int&a,const int&b){
	return b>a?a-b+mod:a-b;
}
inline int pow(int a,int b){
	int ans=1;
	for(;b;b>>=1,a=1ll*a*a%mod)if(b&1)ans=1ll*ans*a%mod;
	return ans;
}
inline void sieve(const int&n){
	register int i,j,x;idk[1]=idk1[1]=1;
	for(i=2;i<=n;++i){
		if(!zhi[i])idk[pri[++top]=i]=pow(i,k);
		for(j=1;j<=top&&(x=i*pri[j])<=n;++j){
			zhi[x]=true;idk[x]=1ll*idk[i]*idk[pri[j]]%mod;
			if(!(i%pri[j]))break;
		}
		idk1[i]=1ll*idk[i]*i%mod;
	}
}
inline void init(){
	register int i;sieve(k+3);ifac[0]=ifac[1]=1;k+=2;
	for(i=2;i<=k+1;++i)ifac[i]=1ll*(mod-mod/i)*ifac[mod%i]%mod;
	for(i=2;i<=k+1;++i)ifac[i]=1ll*ifac[i-1]*ifac[i]%mod;
	for(i=1;i<=k;++i)idk[i]=Add(idk[i],idk[i-1]);
	for(i=1;i<=k+1;++i)idk1[i]=Add(idk1[i],idk1[i-1]);
	for(i=1;i<=k;++i){
		idk[i]=1ll*ifac[i-1]*(k-i&1?mod-ifac[k-i]:ifac[k-i])%mod*idk[i]%mod;
	}
	for(i=1;i<=k+1;++i){
		idk1[i]=1ll*ifac[i-1]*(k-i&1?ifac[k+1-i]:mod-ifac[k+1-i])%mod*idk1[i]%mod;
	}
}
inline int fk(const int&n){
	register int i,ans=0;sl[0]=sr[k+1]=1;
	for(i=1;i<=k;++i)sl[i]=1ll*sl[i-1]*Del(n,i)%mod;
	for(i=k;i>=1;--i)sr[i]=1ll*sr[i+1]*Del(n,i)%mod;
	for(i=1;i<=k;++i)ans=Add(ans,1ll*sl[i-1]*sr[i+1]%mod*idk[i]%mod);
	return ans;
}
inline int fk1(const int&n){
	register int i,ans=0;sl[0]=sr[k+2]=1;
	for(i=1;i<=k+1;++i)sl[i]=1ll*sl[i-1]*Del(n,i)%mod;
	for(i=k+1;i>=1;--i)sr[i]=1ll*sr[i+1]*Del(n,i)%mod;
	for(i=1;i<=k+1;++i)ans=Add(ans,1ll*sl[i-1]*sr[i+1]%mod*idk1[i]%mod);
	return ans;
}
signed main(){
	int f1,f2,f3,f4,g1,g2;
	scanf("%d%d",&n,&k);init();f1=fk(n);f2=fk(Add(n,n));f3=fk1(n);f4=fk1(Add(n,n));
	g1=Add(f3,1ll*Add(n,n+1)*Del(f2,f1)%mod);g2=Add(1ll*Add(pow(2,k-2),1)*f1%mod,Del(f4,f3));
	printf("%d",1ll*pow(n,mod-2)*Del(g1,g2)%mod);
}
```

---

## 作者：HECZ (赞：1)

可以发现每条边出现的概率都是相同的，那么：

$$
ans = \frac{2 n^{n-3}}{n^{n-2}} \sum_{i=1}^{n} \sum_{j=i+1}^{n} (i+j)^k = \frac 2 n \sum_{i=1}^n \sum_{j=i+1}^n (i+j)^k
$$

只需要求后面的值，不妨假设 $f(n, k) = \sum_{i=1}^n i^k$，则有：

$$
\begin{aligned}
\sum_{i=1}^n \sum_{j=i+1}^n (i+j)^k
&amp;= \frac 1 2 \left( \sum_{i=1}^n \sum_{j=1}^n (i+j)^k - \sum_{i=1}^n (i+i)^k \right) \\
&amp;= 2^{-1} \sum_{i=1}^n \sum_{j=1}^n (i+j)^k - 2^{k-1} \sum_{i=1}^n i^k \\
&amp;= 2^{-1} \sum_{i=1}^n \sum_{j=1}^n (i+j)^k - 2^{k-1} f(n, k)
\end{aligned}
$$

只需要求中间的那个双重和式，后面的可以插值。即：

$$
\begin{aligned}
\sum_{i=1}^n \sum_{j=1}^n (i+j)^k 
&amp;= \sum_{d=1}^{2n} d^k \sum_{i=1}^n \sum_{j=1}^n [i+j=d] \\
&amp;= \sum_{d=1}^n d^k (d-1) + \sum_{d=n}^{2n} d^k \left(2n-(d-1)\right) \\
&amp;= \sum_{d=1}^{n-1} d^{k+1} + \sum_{d=n}^{2n} 2n d^k - \sum_{d=n-1}^{2n-1} d^{k+1} \\
&amp;= f(n-1, k+1) + 2n \left( f(2n, k) - f(n-1, k) \right) - \left( f(2n-1, k+1) - f(n-2, k+1)\right)\\
\end{aligned}
$$

显然可以处理出 $f(n, k), f(2n, k), f(n, k+1), f(2n, k+1)$，并快速转移。复杂度为拉格朗日插值的复杂度。

**总结**：
难点在于如何求快速幂和求逆元 。前者是一个完全积性函数，可以使用线性筛求得；后者应当先线性求逆元，然后分别做一次前缀 / 后缀和即可。

---

## 作者：gyyyyx (赞：0)

以前觉得很难，现在觉得很水系列。

其实答案就是所有的生成树的权值和除以生成树个数。

根据矩阵树定理可以得知 $n$ 阶完全图的生成树个数为 $n^{n-2}$。

现在思考如何求所有生成树的权值和。

考虑每条边的贡献。

容易发现每条边都是等价的，也就是随机选取一棵生成树，每条边出现在这个生成树上的概率是一样的。

那么在所有生成树中，每条边出现的次数也是一样的。

简单推一下，一条边出现的次数为：

$$\frac{(n-1)n^{n-2}}{\frac{(n-1)n}{2}}=\frac{2n^{n-2}}{n}$$

那么答案即为：

$$\frac{2n^{n-2}}{n}\cdot\frac{1}{n^{n-2}}\cdot\sum\limits_{i=2}^n\sum\limits_{j=1}^{i-1}(i+j)^k=\frac{2}{n}\sum\limits_{i=2}^n\sum\limits_{j=1}^{i-1}(i+j)^k$$

现在只需要求出后面那坨求和就行了。

根据一些不知名定理我们知道 $\sum\limits_{i=1}^ni^k$ 是一个关于 $n$ 的 $k+1$ 次多项式。

那么合理猜测一下 $\sum\limits_{i=2}^n\sum\limits_{j=1}^{i-1}(i+j)^k$ 也是一个关于 $n$ 的多项式。

此时我们只需要对于所有 $x\in\big[1,lim\big]$ 求出 $f(x)=\sum\limits_{i=2}^x\sum\limits_{j=1}^{i-1}(i+j)^k$ 的值，然后任意 $f(n)$ 就都能用拉格朗日插值线性求出了。

令 $S(x)=\sum\limits_{i=1}^xi^k$，则 $f(x)=f(x-1)+\sum\limits_{i=1}^{x-1}(x+i)^k=f(x-1)+S(2x-1)-S(x)$。

只需要快速求出 $S(x)$ 即可。

显然可以线性筛完成。

进行一些简单的尝试之后得出 $lim=k+3$，即 $\sum\limits_{i=2}^n\sum\limits_{j=1}^{i-1}(i+j)^k$ 是一个关于 $n$ 的 $k+2$ 次多项式（不会证）。

然后这题就做完了。

复杂度是线性的。

```cpp
#include<bits/stdc++.h>
#define LL long long
#define mod 998244353
using namespace std;
inline LL fpow(LL a,LL b){
	LL ret(1);
	while(b){
		if(b&1) ret=ret*a%mod;
		a=a*a%mod;b>>=1;
	}
	return ret;
}
int n,k;
vector <int> prime;
vector <bool> vis;
vector <LL> f,g,inv,q,h;
inline void Init(int lim=min(k+3,n)){
	vis.resize((lim<<1)+1,0);vis[1]=1;
	f.resize((lim<<1)+1,1);
	for(int i(2);i<=(lim<<1);++i){
		if(!vis[i]){
			prime.push_back(i);
			f[i]=fpow(i,k);
		}
		for(auto p:prime){
			if(1ll*i*p>(lim<<1)) break;
			vis[i*p]=1;f[i*p]=f[i]*f[p]%mod;
			if(!(i%p)) break;
		}
	}
	for(int i(2);i<=(lim<<1);++i){
		f[i]+=f[i-1];
		if(f[i]>=mod) f[i]-=mod;
	}
	g.resize(lim+1,0);
	for(int i(2);i<=lim;++i){
		g[i]=g[i-1]+f[(i<<1)-1];
		if(g[i]>=mod) g[i]-=mod;
		g[i]=g[i]-f[i]+mod;
		if(g[i]>=mod) g[i]-=mod;
	}
	inv.resize(lim+1,1);
	for(int i(2);i<=lim;++i) inv[i]=inv[i-1]*i%mod;
	inv[lim]=fpow(inv[lim],mod-2);
	for(int i(lim-1);i;--i) inv[i]=inv[i+1]*(i+1)%mod;
	q.resize(lim+1);h.resize(lim+2);q[0]=h[lim+1]=1;
}
inline LL Lagrange(int x,int lim=k+3){
	if(n<=lim) return g[n];
	for(int i(1);i<=lim;++i) q[i]=q[i-1]*(x-i)%mod;
	for(int i(lim);i;--i) h[i]=h[i+1]*(x-i)%mod;
	LL ret(0);
	for(int i(lim),flg(0);i;--i,flg^=1){
		LL A(q[i-1]*h[i+1]%mod);
		LL B(inv[i-1]*inv[lim-i]%mod);
		LL now(A*B%mod*g[i]%mod);
		if(flg) ret=ret-now+mod;
		else ret=ret+now;
		if(ret>=mod) ret-=mod;
	}
	return ret;
}
int main(){
	scanf("%d%d",&n,&k);
	if(n==1){return puts("0"),0;}
	Init();
	printf("%lld\n",2*fpow(n,mod-2)*Lagrange(n)%mod);
	return 0;
}
```

---

## 作者：mRXxy0o0 (赞：0)

# 分析

题目中所给的是无向完全图，相当于提供了一个很好的性质：所有边等价。

考虑答案怎么算，应当是 $\sum\text{边权}\times\text{出现在树上概率}$。设 $n$ 个点生成树个数为 $tot$~~（问就是忘了结论）~~，因为所有边等价，所以该概率即为 $\dfrac{(n-1)tot}{\frac{n(n-1)}2tot}=\frac2n$。

把概率提出来，里面的经过观察，实质上是 $x^k$ 的二次前缀和一样的东西。已知 $\sum\limits_{i=1}^ni^k$ 为 $k+1$ 次多项式，所以 $\sum\limits_{i=1}^n\sum\limits_{j=1}^{i-1}(i+j)^k$ 是一个 $k+2$ 次多项式。线性筛加插值即可。

---

## 作者：Sym_Je (赞：0)

# P5437 【XR-2】约定   

## 题目大意   
给你一个完全图每个点都有编号 $1\to n$ ，每条边的边权为 $(i+j)^k$ . 问你生成一棵树后的边权和的期望 。         

## $solution$     
首先我们可以发现每一条边的出现的次数显然是一样的 ，所以我们考虑一下每条边出现的次数，首先我们根据 $Cayley$ 公式 , 知道一个完全图会生出 $n^{n-2}$ 个不同的数 $($边不同$)$ ，这样我们一共就会有  $(n-1)(n^{n-2})$ 条边 , 一个完全图里又有 $\frac{n(n-1)}{2}$ 条边 ，呢么每条边会出现 $2n^{n-3}$ . 好，呢么答案就是     
$$\frac{2n^{n-3}\sum_{i=1}^{n}\sum_{j=1}^{i-1}(i+j)^k}{n^{n-2}}$$     
$$\frac{2\sum_{i=1}^{n}\sum_{j=1}^{i-1}(i+j)^k}{n}$$    

好，呢么我们的问题就转换到如何快速求出 $\sum_{i=1}^{n}\sum_{j=1}^{i-1}(i+j)^k$ .   
我们发现直接求会很烦 ，呢么我们就想他能否通过递推来优化复杂度 ，我们设 $f(n)=\sum_{i=1}^{n}\sum_{j=1}^{i-1}(i+j)^k$ .     
$f(n)-f(n-1)=\sum_{i=n+1}^{2n-1}i^k$  
好这样我们预处理出 $i^k$ 的前缀和，呢我们就可以 $O(n)$ 得到 $f(n)$  。   

但是我们可以发现 $n$ 还是很大呀 ，这可咋办 ，但是我们知道每一个自然数的幂$(x)$数列，都可以化为一个数的 $x+1$ 次幂的多项式，比如我们熟知的 $1+2+3+...+n=\frac{(1+n)* n}{2}$   
$1^2+2^2+3^2+...+n^2=\frac{n(n-1)(2n-1)}{6}$   
$1^3+2^3+...+n^3 =(1+2+..+n)^2= (\frac{n (n+1)}{2})^2$    

然后呢我们就可以用我们的拉格朗日差值法来解  。又因为我们知道的 $x$ 是一个连续的 $1\to k$  的所以我们直接 $O(n)$ 差出值就好了 。   
对于 $O(n)$ 差出 $x$ 为连续坐标的拉格朗日我还是提一嘴吧 。    
首先我们可以下最根本的拉格朗日 。  
$$f(k)=\sum_{i=0}^{n}y_i\Pi_{j=0(j!=i)}^{n}\frac{k-y[j]}{x[i]-x[j]}$$   
呢么对于 $x$ 连续显然    

$$f(k)=\sum_{i=0}^{n}y_i\Pi_{j=0(j!=i)}^{n}\frac{k-y[j]}{i-j}$$    

前面都好说我们看后面   

$$\Pi_{j=0(j!=i)}^{n}\frac{k-y[j]}{i-j}$$   

我们计两个数组     
$N$ 为我们询问的答案 。  
$pre[k]=\Pi_{i=0}^{k}(N-i)$     
$suf[k]=\Pi_{i=k}^{n}(N-i)$   

呢么分子就解决了$pre[i-1] * suf[i+1]$ 。     

研究一下分母 ，显然我们用两个 $fac[]$ 就好了，记录阶乘 ， 分母就是 $fac[i] * fac[n-i]$ ，最后讨论一下 $n-i$ 的奇偶性 , 奇减偶加 .    

对于我们求分子时的逆元计算其实我们可以 $O(n)$ 求出所有逆元 ，原理就是我们处理出来要求逆元的数的前缀积 ， 然后我们求出总的积的逆元 ，然后往回推就好啦 。    




* $code$   

```cpp
// luogu-judger-enable-o2
#include<bits/stdc++.h>
using namespace std;
const int maxn=2e7+10;
const int mod=998244353;
int n,k,lim;
int s[maxn],f[maxn],cnt;
int mul(int x,int y) {
	return 1ll*x*y%mod;
}
int add(int x,int y) {
	return (x+y)%mod;
} 
int dec(int x,int y) {
	return (x-y+mod)%mod;
}
int poww(int x,int k) {
	int ans=1;
	while(k) {
		if(k&1) ans=mul(ans,x);
		x=mul(x,x);
		k>>=1;
	}
	return ans;
}
int ans,q[maxn],S[maxn],num,suf[maxn],pre[maxn],fac[maxn],inv[maxn];
int so() {
	pre[0]=n,fac[0]=1;
	for(int i=1;i<=lim;++i) pre[i]=mul(pre[i-1],n-i),fac[i]=mul(fac[i-1],i)%mod;
	suf[lim+1]=1;suf[0]=1;
	for(int i=lim;i;i--) suf[i]=mul(suf[i+1],n-i);s[0]=1;
	S[0]=1; 
	for(int i=1;i<=lim;++i){
		s[i]=mul(fac[i],fac[lim-i]);S[i]=mul(S[i-1],s[i]);
	} 
	inv[lim]=poww(S[lim],mod-2);
	for(int i=lim;i;i--) inv[i-1]=1ll*inv[i]%mod*s[i]%mod,inv[i]=mul(inv[i],S[i-1]);
	inv[0]=1;
	int ans=0;
	for(int i=1;i<=lim;++i) {
		int x=1ll*mul(pre[i-1],suf[i+1])%mod*inv[i]%mod*f[i]%mod;
		if((lim-i)&1) ans=dec(ans,x);
		else ans=add(ans,x);
	}
	return ans;
}
int main() 
{
	scanf("%d%d",&n,&k);
	lim=min(n+1,k+2)<<1;
	s[1]=1;
	for(int i=2;i<=lim;++i) {
		if(!s[i]) {
			f[++cnt]=i;
			s[i]=poww(i,k);
		} for(int j=1;j<=cnt;++j) {
			if(1ll*i*f[j]>lim) break ;
			s[i*f[j]]=mul(s[i],s[f[j]]);
			if(i%f[j]==0) break ;
		}
	}
	for(int i=2;i<=lim;++i) s[i]=add(s[i],s[i-1]);
	lim>>=1; 
	f[1]=0;
	f[2]=poww(3,k);
	for(int i=3;i<=lim;++i) 
		f[i]=add(f[i-1],dec(s[(i<<1)-1],s[i])); 
	if(n<=lim) ans=f[n];
	else ans=so();
	ans=(long long)1ll*(ans<<1)%mod*poww(n,mod-2)%mod;
	cout<<ans<<"\n";
	return 0;	
}



```






---


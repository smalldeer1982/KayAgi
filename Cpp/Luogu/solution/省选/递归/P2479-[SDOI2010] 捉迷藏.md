# [SDOI2010] 捉迷藏

## 题目背景

iPig 在大肥猪学校刚上完了无聊的猪文课，天资聪慧的 iPig 被这门对他来说无比简单的课弄得非常寂寞，为了消除寂寞感，他决定和他的好朋友 giPi（鸡皮）玩一个更加寂寞的游戏——捉迷藏。但是，他们觉得，玩普通的捉迷藏没什么意思，还是不够寂寞，于是，他们决定玩寂寞无比的螃蟹版捉迷藏。


## 题目描述

螃蟹版捉迷藏，顾名思义，就是说他们在玩游戏的时候只能沿水平或垂直方向走。

一番寂寞的剪刀石头布后，他们决定 iPig 去捉 giPi。由于他们都很熟悉大肥猪学校的地形了，所以 giPi 只会躲在大肥猪学校内 $N$ 个隐秘地点之一，显然 iPig 也只会在那 $N$ 个地点内找 giPi。

游戏一开始，他们从这 $N$ 个隐秘地点之中选定一个地点，iPig 保持不动，然后 giPi 用 $30$ 秒的时间逃离现场（显然，giPi 不会呆在原地）。然后 iPig 会随机地去找 giPi，直到找到为止。

由于 iPig 很懒，所以他总是走最短的路径，而且，他选择起始点不是随便选的，他想找一个地点，使得该地点到（除了这个地点以外的）最远的地点和最近的地点的距离差最小。iPig现在想知道这个距离差最小是多少。

由于 iPig 现在手上没有电脑，所以不能编程解决这个如此简单的问题，所以他马上打了个电话，要求你帮他解决这个问题。iPig 告诉了你大肥猪学校的 $N$ 个隐秘地点的坐标，请你编程求出 iPig 的问题。

## 说明/提示

$30\%$ 的数据中，$2\le N\le 10^3$；

$100\%$ 的数据中，$2\le N\le 10^5$，$0\le X_i,Y_i\le 10^9$。

数据保证点不重合。

## 样例 #1

### 输入

```
4
0 0
1 0
0 1
1 1
```

### 输出

```
1```

# 题解

## 作者：revenger (赞：12)

dalao们都用KDtree做题，但是我太蒻了不会KDtree。所以我来写一下线段树的做法，顺便帮助一下和我一样不会KDtree的同学。

两点之间的距离公式是|x1-x2|+|y1-y2|，带着绝对值不方便做，我们把绝对值去掉。
这个式子去绝对值后的结果有4种，和横纵坐标的大小关系有关。

所以我们先把以一种坐标为关键字排序(以横坐标为例)。排完序后在i前面的点x都比xi小，前面的点的纵坐标分两种情况讨论，y<=yi或者y>yi

对于y<=yi的情况距离为xi-x+yi-y，也就是xi+yi-x-y；对于y>yi的情况，距离为xi-x-yi+y，也就是xi-yi-x+y。因为xi和yi是定值，要取距离最大或最小值的时候，就需要让-x-y或者-x+y最大或最小，也就是在所有i前面的点中选择-x-y和-x+y的最大/小值。

这就是一个单点修改区间查询极值的问题，这种问题当然是需要用线段树来做啊。

所以我们就可以建一棵以y值大小为下标的线段树，先把y值离散化，然后按照x排序，每次选i点y值所在位置，从这个位置往前取-x-y(因为往前y值比yi小)，往后取y-x。然后把-xi-yi和yi-xi插入。单次操作效率logn，总效率(nlogn)。

但是这样还没算完。因为我们把每个i和i前面的点比较，还没有和后面的点比。

下一步就同理啦，从后往前依次插入点，再做一次线段树。但是因为i后面的点的横坐标x>xi，此时距离变成了x+y-xi-yi或者x-y-xi+yi。所以记录的值就对应地变成x+y和x-y。

前后两遍线段树，效率都是O(nlogn),总效率也是这样。

当然你愿意按照x坐标建线段树，按照y坐标排序也可以。

下面的代码里使用的是zkw线段树，比正常的递归线段树要快不少。

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
const int inf=1e9+7;
#define min(a,b) (a<b?a:b)
#define max(a,b) (a>b?a:b)
int n,x,y;
int m;
int sum[200010];
int dis[100010][2];
int tree[1000001][5];//minsxy maxsxy minbxy maxbxy
struct poi{
    int x,y,num;
}s[100010];
int cmp(poi a,poi b)
{
    return a.y<b.y;
}
int cmp2(poi a,poi b)
{
    return a.x<b.x;
}
void init()
{
    for(int i=1;i<=(m<<1|1);i++)
    tree[i][1]=tree[i][3]=inf,tree[i][2]=tree[i][4]=-inf;
}
void change(int x,int m1,int m2)
{
    x+=m;
    tree[x][1]=min(tree[x][1],m1);
    tree[x][2]=max(tree[x][2],m1);
    tree[x][3]=min(tree[x][3],m2);
    tree[x][4]=max(tree[x][4],m2);
    x>>=1;
    while(x)
    {
        tree[x][1]=min(tree[x<<1][1],tree[x<<1|1][1]);
        tree[x][2]=max(tree[x<<1][2],tree[x<<1|1][2]);
        tree[x][3]=min(tree[x<<1][3],tree[x<<1|1][3]);
        tree[x][4]=max(tree[x<<1][4],tree[x<<1|1][4]);
        x>>=1;
    }
}
int ask(int l,int r,int nm)
{
    int ans=nm%2?inf:-inf;
    for(l+=m-1,r+=m+1;l^r^1;l>>=1,r>>=1)
    {
        if(~l&1)
        ans=nm%2?min(ans,tree[l^1][nm]):max(ans,tree[l^1][nm]);
        if(r&1)
        ans=nm%2?min(ans,tree[r^1][nm]):max(ans,tree[r^1][nm]);
    }
    return ans;
}
int main()
{
    scanf("%d",&n);
    m=1;while(m<n+2) m<<=1;
    --m;
    for(int i=1;i<=n;i++)
    scanf("%d%d",&s[i].x,&s[i].y),s[i].num=i,dis[i][0]=inf,dis[i][1]=-inf;
    sort(s+1,s+n+1,cmp);
    int tot=1;
    for(int i=1;i<=n;i++)
    sum[s[i].num]=s[i].y==s[i-1].y?tot:++tot;
    sort(s+1,s+n+1,cmp2);
    init();
    for(int i=1;i<=n;i++)
    {
        int min1=ask(1,sum[s[i].num],1);
        int max1=ask(1,sum[s[i].num],2);
        int min2=ask(sum[s[i].num],tot,3);
        int max2=ask(sum[s[i].num],tot,4);
        dis[i][0]=min(dis[i][0],min1+s[i].x+s[i].y);
        dis[i][0]=min(dis[i][0],min2+s[i].x-s[i].y);
        dis[i][1]=max(dis[i][1],max1+s[i].x+s[i].y);
        dis[i][1]=max(dis[i][1],max2+s[i].x-s[i].y);
        change(sum[s[i].num],-s[i].x-s[i].y,s[i].y-s[i].x);
    }
    init();
    for(int i=n;i>=1;i--)
    {
        int min1=ask(1,sum[s[i].num],1);
        int max1=ask(1,sum[s[i].num],2);
        int min2=ask(sum[s[i].num],tot,3);
        int max2=ask(sum[s[i].num],tot,4);
        dis[i][0]=min(dis[i][0],min1-s[i].x+s[i].y);
        dis[i][0]=min(dis[i][0],min2-s[i].x-s[i].y);
        dis[i][1]=max(dis[i][1],max1-s[i].x+s[i].y);
        dis[i][1]=max(dis[i][1],max2-s[i].x-s[i].y);
        change(sum[s[i].num],s[i].x-s[i].y,s[i].y+s[i].x);
    }
    int ans=inf;
    for(int i=1;i<=n;i++)
    ans=min(ans,dis[i][1]-dis[i][0]);
    printf("%d",ans);
}
```

---

## 作者：破忆 (赞：9)

## 【题意】

$dis(A,B)$ 是 $AB$ 两点的曼哈顿距离。

求 $\min_{i=1}^{n}(\max_{j=1}^{n}dis(p_i,p_j)-\min_{j=1}^{n}dis(p_i,p_j)(i\ne j))$。

## 【分析】

平面上的点可以用 K-D Tree 维护。

求与点 $p_i$ 的距离的最大（小）值，可以在 K-D Tree 上搜索。

### 剪枝1：

对于每个区间，维护覆盖这个点集的矩形的边界。

估价函数设为当前点与该矩形的最近（远）距离，判断当前区间能否产生更优的答案。

### 剪枝2： 

遍历到某个节点时，计算两个子节点的估价函数。

先遍历估价函数更优的子节点。

注意搜索最近距离时不能计算重合的点。

## 【算法】

K-D Tree

## 【代码】

```cpp
#include<bits/stdc++.h>
#define DB double
using namespace std;
const int maxn=1e5+5,INF=2147483647;
const DB A=0.75;
int n;
int now1,now2;
int ans=INF;
int D;
struct point{
	int x[2];
	bool operator !=(point b)const{return x[0]!=b.x[0]||x[1]!=b.x[1];}
}p[maxn],a[maxn];
bool cmp(point x,point y){
	return x.x[D]<y.x[D];
}
int max(int x,int y){
	return x>y?x:y;
}
int min(int x,int y){
	return x<y?x:y;
}
int abs(int x){
	return x>0?x:-x;
}
struct KDT{
	int tot,rt;
	int top,rub[maxn];
	struct ele{
		point p;
		int l,r,s,mi[2],mx[2];
	}t[maxn];
	#define mid (l+r>>1)
	#define ls(k) t[k].l
	#define rs(k) t[k].r
	#define p(k) t[k].p
	#define s(k) t[k].s
	int New(){
		return top?rub[top--]:++tot;
	}
	void pushup(int k){
		t[k].mi[0]=t[k].mx[0]=p(k).x[0];
		t[k].mi[1]=t[k].mx[1]=p(k).x[1];
		s(k)=1;
		if(ls(k)){
			t[k].mi[0]=min(t[k].mi[0],t[ls(k)].mi[0]);
			t[k].mi[1]=min(t[k].mi[1],t[ls(k)].mi[1]);
			t[k].mx[0]=max(t[k].mx[0],t[ls(k)].mx[0]);
			t[k].mx[1]=max(t[k].mx[1],t[ls(k)].mx[1]);
			s(k)+=s(ls(k));
		}
		if(rs(k)){
			t[k].mi[0]=min(t[k].mi[0],t[rs(k)].mi[0]);
			t[k].mi[1]=min(t[k].mi[1],t[rs(k)].mi[1]);
			t[k].mx[0]=max(t[k].mx[0],t[rs(k)].mx[0]);
			t[k].mx[1]=max(t[k].mx[1],t[rs(k)].mx[1]);
			s(k)+=s(rs(k));
		}
	}
	int build(int l,int r,int d){
		if(l>r) return 0;
		int x=New();
		D=d;
		nth_element(p+l,p+mid,p+r+1,cmp);
		p(x)=p[mid];
		ls(x)=build(l,mid-1,d^1);
		rs(x)=build(mid+1,r,d^1);
		pushup(x);
		return x;
	}
	void clear(int k,int pos){
		if(ls(k)) clear(ls(k),pos);
		p[pos+s(ls(k))+1]=p(k);
		rub[++top]=k;
		if(rs(k)) clear(rs(k),pos+s(ls(k))+1);
	}
	void check(int &k,int d){
		int c=A*s(k);
		if(s(ls(k))>c||s(rs(k))>c){
			clear(k,0);
			k=build(1,s(k),d);
		}
	}
	void insert(int &k,point p,int d){
		if(!k){k=New();ls(k)=rs(k)=0,p(k)=p,pushup(k);return;}
		if(p.x[d]<=p(k).x[d]) insert(ls(k),p,d^1);
		else insert(rs(k),p,d^1);
		pushup(k);
		check(k,d);
	}
	int dis1(int x,int y,int x1,int y1,int x2,int y2){
		return (x<x1?x1-x:(x>x2?x-x2:0))+(y<y1?y1-y:(y>y2?y-y2:0));
	}
	void query1(int k,point x){
		if(!k) return;
		if(dis1(x.x[0],x.x[1],t[k].mi[0],t[k].mi[1],t[k].mx[0],t[k].mx[1])>now1) return;
		if(p(k)!=x) now1=min(now1,dis1(x.x[0],x.x[1],p(k).x[0],p(k).x[1],p(k).x[0],p(k).x[1]));
		int dl=ls(k)?dis1(x.x[0],x.x[1],t[ls(k)].mi[0],t[ls(k)].mi[1],t[ls(k)].mx[0],t[ls(k)].mx[1]):INF,
			dr=rs(k)?dis1(x.x[0],x.x[1],t[rs(k)].mi[0],t[rs(k)].mi[1],t[rs(k)].mx[0],t[rs(k)].mx[1]):INF;
		if(dl<=dr){
			query1(ls(k),x);
			query1(rs(k),x);
		}else{
			query1(rs(k),x);
			query1(ls(k),x);
		}
	}
	int dis2(int x,int y,int x1,int y1,int x2,int y2){
		return max(abs(x-x1),abs(x-x2))+max(abs(y-y1),abs(y-y2));
	}
	void query2(int k,point x){
		if(!k) return;
		if(dis2(x.x[0],x.x[1],t[k].mi[0],t[k].mi[1],t[k].mx[0],t[k].mx[1])<now2) return;
		now2=max(now2,dis2(x.x[0],x.x[1],p(k).x[0],p(k).x[1],p(k).x[0],p(k).x[1]));
		int dl=ls(k)?dis2(x.x[0],x.x[1],t[ls(k)].mi[0],t[ls(k)].mi[1],t[ls(k)].mx[0],t[ls(k)].mx[1]):-INF,
			dr=rs(k)?dis2(x.x[0],x.x[1],t[rs(k)].mi[0],t[rs(k)].mi[1],t[rs(k)].mx[0],t[rs(k)].mx[1]):-INF;
		if(dl>=dr){
			query2(ls(k),x);
			query2(rs(k),x);
		}else{
			query2(rs(k),x);
			query2(ls(k),x);
		}
	}
}T;
char gc(){
    static char buf[100000],*p1=buf,*p2=buf;
    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;
}
#define getchar gc
int read(){
    int ret=0,f=1;char ch=getchar();
    while(ch>'9'||ch<'0'){if(ch=='-')f=-f;ch=getchar();}
    while(ch>='0'&&ch<='9') ret=ret*10+ch-'0',ch=getchar();
    return ret*f;
}
int main(){
	freopen("P2479.in","r",stdin);
	freopen("P2479.out","w",stdout);
	n=read();
	for(int i=1;i<=n;i++){
		a[i].x[0]=read(),a[i].x[1]=read();
		T.insert(T.rt,a[i],0);
	}
	for(int i=1;i<=n;i++){
		now1=INF,now2=-INF;
		T.query1(T.rt,a[i]),T.query2(T.rt,a[i]);
		ans=min(ans,now2-now1);
	}
	printf("%d\n",ans);
	return 0;
}
```


---

## 作者：zcysky (赞：7)

额……一道K-D-Tree的裸题，但是不知道为啥没有这个tag……

所谓kdtree，就是按照维度对高维区间进行划分的一种数据结构。kdtree本质上是二叉树，性质上类似于二叉排序树。

但是kdtree的层数和维度有严格的对应关系，因此不可以像二叉排序树一样进行旋转。

但是替罪羊的拍扁重建法在kdtree上依旧可以使用。

这题不开O2卡常（可能是我数据结构日常被卡），可以尝试替罪羊维护？

代码：

```cpp
#include<bits/stdc++.h>
#define N 500005
#define inf 1000000000
using namespace std;
int x[N],y[N];
int n,f,rt,m,ans;
struct Point{
    int d[2],maxv[2],minv[2],l,r;
    int& operator[](int x){return d[x];}
    friend bool operator<(Point a,Point b){return a[f]<b[f];}
    friend int querydis(Point a,Point b){return abs(a[1]-b[1])+abs(a[0]-b[0]);}
}p[N];
struct K_D_Tree{
    Point t[N],T;int ans;
    void pushup(int x){
        int l=t[x].l,r=t[x].r;
        for(int i=0;i<=1;i++){
            t[x].minv[i]=t[x].maxv[i]=t[x][i];
            if(l){
                t[x].minv[i]=min(t[x].minv[i],t[l].minv[i]);
                t[x].maxv[i]=max(t[x].maxv[i],t[l].maxv[i]);
            }
            if(r){
                t[x].minv[i]=min(t[x].minv[i],t[r].minv[i]);
                t[x].maxv[i]=max(t[x].maxv[i],t[r].maxv[i]);
            }
        }
    }
    int build(int l,int r,int f){
        int mid=(l+r)>>1;
        nth_element(p+l,p+mid,p+r+1);
        t[mid]=p[mid];
        for(int i=0;i<=1;i++)t[mid].minv[i]=t[mid].maxv[i]=t[mid][i];
        if(l<mid)t[mid].l=build(l,mid-1,f^1);
        if(r>mid)t[mid].r=build(mid+1,r,f^1);
        pushup(mid);return mid;
    }
    int getmin(Point a){
        int ans=0;
        for(int i=0;i<=1;i++){
            ans+=max(T[i]-a.maxv[i],0);
            ans+=max(a.minv[i]-T[i],0);
        }
        return ans;
    }
    int getmax(Point a){
        int ans=0;
        for(int i=0;i<=1;i++){
            ans+=max(abs(T[i]-a.maxv[i]),abs(T[i]-a.minv[i]));
        }
        return ans;
    }
    void querymax(int x){
        ans=max(ans,querydis(t[x],T));
        int l=t[x].l,r=t[x].r,dl=-inf,dr=-inf;
        if(l)dl=getmax(t[l]);if(r)dr=getmax(t[r]);
        if(dl>dr){
            if(dl>ans)querymax(l);if(dr>ans)querymax(r);
        }
        else{
            if(dr>ans)querymax(r);if(dl>ans)querymax(l);
        }
    }
    void querymin(int x){
        int tmp=querydis(T,t[x]);
        if(tmp)ans=min(ans,tmp);
        int l=t[x].l,r=t[x].r,dl=inf,dr=inf;
        if(l)dl=getmin(t[l]);if(r)dr=getmin(t[r]);
        if(dl<dr){
            if(dl<ans)querymin(l);if(dr<ans)querymin(r);
        }else{
            if(dr<ans)querymin(r);if(dl<ans)querymin(l);
        }
    }
    int query(int f,int x,int y){
        T[0]=x;T[1]=y;
        if(!f)ans=inf,querymin(rt);
        else ans=-inf,querymax(rt);
        return ans;
    }
}kd;
inline int read(){
    int f=1,x=0;char ch;
    do{ch=getchar();if(ch=='-')f=-1;}while(ch<'0'||ch>'9');
    do{x=x*10+ch-'0';ch=getchar();}while(ch>='0'&&ch<='9');
    return f*x;
}
int main(){
    n=read();ans=inf;
    for(int i=1;i<=n;i++){
        x[i]=read();y[i]=read();
        p[i][0]=x[i];p[i][1]=y[i];
    }
    rt=kd.build(1,n,0);
    for(int i=1;i<=n;i++){
        int minv=kd.query(0,x[i],y[i]),maxv=kd.query(1,x[i],y[i]);
        ans=min(ans,maxv-minv);
    }
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：Wilderness_ (赞：6)

我们充分发扬人类智慧。

题目要求的式子是 $\min\limits_{1\le i\le n}(\max\limits_{1\le j\le n}dis(p_i,p_j)-\min\limits_{1\le j\le n}dis(p_i,p_j))$，其中 $dis(a,b)$ 是 $a,b$ 两点间的曼哈顿距离。

我们先将求固定一点的两点间最大曼哈顿的式子 $\max\limits_{1\le j\le n}dis(p_i,p_j)$ 转化一下。

展开 $dis(a,b)$，得
$$\max\limits_{1\le j\le n}|p_{i_x}-p_{j_x}|+|p_{i_y}-p_{j_y}|$$
拆开绝对值，得
$$\max\limits_{1\le j\le n}(\max\{(p_{i_x}+p_{i_y})−(p_{j_x}+p_{j_y}),(p_{i_x}-p_{i_y})−(p_{j_x}-p_{j_y}),(-p_{i_x}+p_{i_y})−(-p_{j_x}+p_{j_y}),(-p_{i_x}-p_{i_y})−(-p_{j_x}-p_{j_y})\})$$
根据 $\max$ 的性质，得
$$\max\{(p_{i_x}+p_{i_y})-\min\limits_{1\le j\le n}(p_{j_x}+p_{j_y}),(p_{i_x}-p_{i_y})-\min\limits_{1\le j\le n}(p_{j_x}-p_{j_y}),(-p_{i_x}+p_{i_y})-\min\limits_{1\le j\le n}(-p_{j_x}+p_{j_y}),(-p_{i_x}-p_{i_y})-\min\limits_{1\le j\le n}(-p_{j_x}-p_{j_y})\}$$

显然，我们可以 $O(n)$ 预处理求出四个 $\min$ 中的式子，那么查固定一点的两点间最大曼哈顿距离可以 $O(1)$ 实现。

求固定一点的两点间最小曼哈顿距离就可以将点按横坐标升序排序。

根据数学直觉，最小距离中的另一个点在数组中肯定不会离那个固定的点太远，所以我们取固定的点的前 $500$ 个点和后 $500$ 个点枚举即可。

这样速度快得飞起，总时间只花了 $670ms$ 左右，足以通过此题。

---

## 作者：Orina_zju (赞：6)

用2-D树维护（虽然我的代码不开-O2也被卡常了QwQ）求某个点到其他任意点的最小值，这部分其他人的题解已经讲过了。

至于最大值完全可以不用2-D树。考虑曼哈顿距离的公式（其中$(x,y)$为当前我们要查询的节点，$(x_i,y_i)$为其他任意一点）：

$\lvert x-x_i \rvert + \lvert y - y_i \rvert = \max (A_{i,0}, A_{i,1}, A_{i,2}, A_{i,3})$

- $A_{i, 0} = (x+y) - (x_i + y_i)$
- $A_{i, 1} = (x-y) - (x_i - y_i)$
- $A_{i, 2} = (-x+y) - (-x_i + y_i)$
- $A_{i, 3} = (-x-y) - (-x_i - y_i)$

求点$(x,y)$到其他任意一点曼哈顿距离的最大值，根据max运算的结合律和分配律，可以得到：

$\displaystyle\max_{1 \le i \le N} \lvert x-x_i \rvert + \lvert y - y_i \rvert = \max(C_0, C_1, C_2, C_3)$

- $C_0 = (x + y) - \displaystyle\min_{i \le i \le n}(x_i + y_i)$
- $C_1 = (x - y) - \displaystyle\min_{i \le i \le n}(x_i - y_i)$
- $C_2 = (-x + y) - \displaystyle\min_{i \le i \le n}(-x_i + y_i)$
- $C_3 = (-x - y) - \displaystyle\min_{i \le i \le n}(-x_i - y_i)$

右边min部分可以在输入所有点的坐标后直接$\text{O}(N)$预处理得到。

代码如下（性能与封装好难兼得，心累(╯#-_-)╯）：
```cpp
#include <cstdio> 
#include <cstring> 
#include <algorithm> 
#include <cstdlib> 
#include <array> 
#include <iterator> 

char buf[100 * 1024 * 1024];
int buf_pos;

void* operator new(size_t n) 
{
    void* res = buf + buf_pos; 
    buf_pos += n;
    return res; 
}

struct Point
{   
    using Proj = int Point::*; 

    int x, y; 
    bool operator == (const Point& rhs) const {
        return x == rhs.x && y == rhs.y; 
    }
    int compare(const Point& rhs, Proj p) const {
        return this->*p - rhs.*p; 
    }
    int dist(const Point& rhs) const {
        return std::abs(x - rhs.x) + std::abs(y - rhs.y); 
    }
    int dist(int rx, int ry) const {
        return std::abs(x - rx) + std::abs(y - ry); 
    }
};
constexpr std::array point_projs = {&Point::x, &Point::y}; 

struct Range 
{
    Point min, max; 
    int min_possible_distance(const Point& p) const 
    {
        int res = 0;
        for (auto m: point_projs)
        {
            res += std::max(0, p.*m - max.*m);
            res += std::max(0, min.*m - p.*m);
        }
        return res; 
    }
    void expand(const Range& rhs)
    {
        for (auto m: point_projs)
        {
            min.*m = std::min(min.*m, rhs.min.*m);
            max.*m = std::max(max.*m, rhs.max.*m); 
        }
    }
};

struct Node
{
    Point point;
    Range range; 
    Node* ch[2] = {nullptr, nullptr};

    Node(Point p): point(p), range({p, p}) {} 
};

template <int I, class Iter> 
Node* build_2d_tree(Iter first, Iter last)
{
    int len = std::distance(first, last); 
    if (len == 0)
        return nullptr; 
    if (len == 1)
        return new Node(*first); 

    auto mid = first + len / 2; 
    std::nth_element(first, mid, last, [] (const Point& x, const Point& y) {
        return x.compare(y, point_projs[I]) < 0;
    });

    Node* res = new Node(*mid); 
    if ((res->ch[0] = build_2d_tree<I ^ 1>(first, mid)) != nullptr)
        res->range.expand(res->ch[0]->range); 
    if ((res->ch[1] = build_2d_tree<I ^ 1>(mid + 1, last)) != nullptr)
        res->range.expand(res->ch[1]->range); 
    return res; 
}

void query_min_distance_aux(Node* cur, const Point& p, int& cur_res)
{
    if (! (p == cur->point))
        cur_res = std::min(cur_res, p.dist(cur->point)); 
    for (Node* c: cur->ch)
    {
        if (c != nullptr && c->range.min_possible_distance(p) < cur_res)
            query_min_distance_aux(c, p, cur_res); 
    }
}

int query_min_distance(Node* cur, Point p) 
{
    int cur_res = std::numeric_limits<int>::max(); 
    query_min_distance_aux(cur, p, cur_res);
    return cur_res; 
}

constexpr int maxN = (int)1e5 + 10; 
Point point[maxN];
int N; 
int T[4];

int main()
{
    scanf("%d", &N);
    for (int& t: T)
        t = std::numeric_limits<int>::max(); 
    for (int x, y, i = 0; i < N; i++)
    {
        scanf("%d%d", &x, &y);
        T[0] = std::min(T[0], x + y);
        T[1] = std::min(T[1], x - y); 
        T[2] = std::min(T[2], -x + y);
        T[3] = std::min(T[3], -x - y); 
        point[i] = {x, y}; 
    }
    Node* root = build_2d_tree<0>(point, point + N); 
    int res = std::numeric_limits<int>::max(); 
    for (int i = 0; i < N; i++)
    {
        auto [x, y] = point[i]; 
        int max_d = std::max({
            (x + y) - T[0],
            (x - y) - T[1],
            (-x + y) - T[2],
            (-x - y) - T[3]
        });
        int min_d = query_min_distance(root, point[i]); 
        res = std::min(res, max_d - min_d);
    }
    printf("%d\n", res);
    return 0; 
}
```


---

## 作者：ModestCoder_ (赞：6)

想到以前做过的$poj$的一道题$stars$（好像是这么叫的）

考虑如何把绝对值扔掉

对于一个点$(x,y)$和它左下的一个点$(x1,y1)(x1<=x,y1<=y)$，那么两点曼哈顿距离:$x-x1+y-y1=(x+y)-(x1+y1)$

如果只存在这一种情况，可以把点按照第一关键字$x$第二关键字$y$排序，先保证x升序情况下用树状数组维护每个点比$y$小的点中$(x+y)$的最大值/最小值求得答案

然后就是推广到四个方向（左上，左下，右上，右下）

 - $x>=x1,y>=y1:dis=(x+y)-(x1+y1)$
 - $x>=x1,y<y1:dis=x-x1+y1-y=(x-y)-(x1-y1)$
 - $x<=x1, y>=y1:dis=x1-x+y-y1=(-x+y)-(-x1+y1)$
 - $x<=x1,y<=y1:dis=(-x-y)-(-x1-y1)$

前两个正着跑，后两个倒着跑保证x的单调性

对于四种情况分别开2个树状数组维护$max/min$

注意需要离散化

代码可读性很低，不信你看看

Code：

```cpp
#include <bits/stdc++.h>
#define maxn 200010
using namespace std;
struct point{
	int x, y, z;
}a[maxn], b[maxn];
int n, m, p, Min[maxn], Max[maxn], min1[maxn], min2[maxn], min3[maxn], min4[maxn], max1[maxn], max2[maxn], max3[maxn], max4[maxn];

inline int read(){
	int s = 0, w = 1;
	char c = getchar();
	for (; !isdigit(c); c = getchar()) if (c == '-') w = -1;
	for (; isdigit(c); c = getchar()) s = (s << 1) + (s << 3) + (c ^ 48);
	return s * w;
}

bool cmp(point x, point y){ return x.x == y.x ? x.y < y.y : x.x < y.x; }
bool cmp1(point x, point y){ return x.x < y.x; }
int lowbit(int x){return x & -x; }
void add1(int x, int y){ for (; x <= p; x += lowbit(x)) max1[x] = max(max1[x], y), min1[x] = min(min1[x], y); }
int query11(int x){ int sum = -1e9; for (; x; x -= lowbit(x)) sum = max(sum, max1[x]); return sum; }
int query12(int x){ int sum = 1e9; for (; x; x -= lowbit(x)) sum = min(sum, min1[x]); return sum; }
void add2(int x, int y){ for (; x; x -= lowbit(x)) max2[x] = max(max2[x], y), min2[x] = min(min2[x], y); }
int query21(int x){ int sum = -1e9; for (; x <= p; x += lowbit(x)) sum = max(sum, max2[x]); return sum; }
int query22(int x){ int sum = 1e9; for (; x <= p; x += lowbit(x)) sum = min(sum, min2[x]); return sum; }
void add3(int x, int y){ for (; x <= p; x += lowbit(x)) max3[x] = max(max3[x], y), min3[x] = min(min3[x], y); }
int query31(int x){ int sum = -1e9; for (; x; x -= lowbit(x)) sum = max(sum, max3[x]); return sum; }
int query32(int x){ int sum = 1e9; for (; x; x -= lowbit(x)) sum = min(sum, min3[x]); return sum; }
void add4(int x, int y){ for (; x; x -= lowbit(x)) max4[x] = max(max4[x], y), min4[x] = min(min4[x], y); }
int query41(int x){ int sum = -1e9; for (; x <= p; x += lowbit(x)) sum = max(sum, max4[x]); return sum; }
int query42(int x){ int sum = 1e9; for (; x <= p; x += lowbit(x)) sum = min(sum, min4[x]); return sum; }
void Add1(int i){ add1(a[i].z, a[i].x + a[i].y), add2(a[i].z, a[i].x - a[i].y); }
void Add2(int i){ add3(a[i].z, -a[i].x + a[i].y), add4(a[i].z, -a[i].x - a[i].y); }

int main(){
	n = read();
	for (int i = 1; i <= n; ++i) a[i] = (point){read(), read()}, b[++m] = (point){a[i].x, m}, b[++m] = (point){a[i].y, m}, Max[i] = -1e9, Min[i] = 1e9;
	sort(b + 1, b + 1 + m, cmp1);
	b[0].x = b[1].x + 1;
	for (int i = 1; i <= m; ++i){
		int x = b[i].x == b[i - 1].x ? p : ++p;
		if (b[i].y % 2 == 0) a[b[i].y >> 1].z = p;
	}
	sort(a + 1, a + 1 + n, cmp);
	for (int i = 1; i <= p; ++i) min1[i] = min2[i] = min3[i] = min4[i] = 1e9, max1[i] = max2[i] = max3[i] = max4[i] = -1e9;
	Add1(1); 
	for (int i = 2; i <= n; ++i){
		Max[i] = max(Max[i], max(a[i].x + a[i].y - query12(a[i].z), a[i].x - a[i].y - query22(a[i].z))),
		Min[i] = min(Min[i], min(a[i].x + a[i].y - query11(a[i].z), a[i].x - a[i].y - query21(a[i].z)));
		Add1(i);
	}
	Add2(n);
	for (int i = n - 1; i; --i){
		Max[i] = max(Max[i], max(-a[i].x + a[i].y - query32(a[i].z), -a[i].x - a[i].y - query42(a[i].z))),
		Min[i] = min(Min[i], min(-a[i].x + a[i].y - query31(a[i].z), -a[i].x - a[i].y - query41(a[i].z)));
		Add2(i);
	}
	int ans = 1e9;
	for (int i = 1; i <= n; ++i) ans = min(ans, Max[i] - Min[i]);
	printf("%d\n", ans);
	return 0;
}
```


---

## 作者：ekatsim (赞：3)

找了一圈居然没看到 cdq 分治的题解，所以蒟蒻来补充一篇。

# 题目
[捉迷藏](https://www.luogu.com.cn/problem/P2479)

# 题意
初始给我们 n 个坐标，询问我们当选择最优时，所选的初始点到最远地点和最近地点的曼哈顿距离差最小为多少。

# 思路
~~由于刚学习过 cdq 分治~~，我们一上来考虑把曼哈顿距离中的绝对值删去。~~要不然都不是偏序关系我们怎么用 cdq 维护？~~

根据题目，我们可以推出以下公式：( j 表示所选初始点的下标)

$\min_{j=1}^n(\max_{i=1}^n(\left\vert x_i-x_j\right\vert+\left\vert y_i-y_j\right\vert)-\min_{i=1}^n(\left\vert x_i-x_j\right\vert+\left\vert y_i-y_j\right\vert))(i!=j)$

如果按照上面的公式枚举，你就可以得到一个时间复杂度 $O(n^2)$ 的暴力。(~~废话~~)

上面的公式实在是令人眼花缭乱，我们考虑先将初始点坐标用变量 x、y 表示，则可以把上述公式看作：

$\max_{i=1}^n(\left\vert x_i-x\right\vert+\left\vert y_i-y\right\vert)-\min_{i=1}^n(\left\vert x_i-x\right\vert+\left\vert y_i-y\right\vert)$

公式里的绝对值，是一个很让人讨厌的符号，考虑将绝对值去掉——对于每个点我们只维护其**左下角的点**(第三象限)对它的**贡献**，即保证 $x>=x_i,y>=y_i$ 时计算贡献。

这个时候，题目被转化成一个**二维偏序**，剩下的就是经典套路：先对一维( x )排序，再利用 cdq 分治的思想维护另一维( y )。

你以为到这就结束了？ NONONO~

按照上面的思路，我们只维护了一个点它**左下方**点对它的贡献，它**左上方、右上方和右下方**的点我们可没有维护。

对于其他几个方向，我们可以把平面**按照 x 轴方向和 y 轴方向分别翻转**，就可以统计到那些其他方向上的点了。( PS：其实这里的说法不太严谨，大家可以根据代码来感性的理解一下)

后面就是愉快的代码 time~~~

时间复杂度 $O(n\log_2n)$。
# 代码
```cpp
#include <bits/stdc++.h>
#define inf 1e9
using namespace std;
const int maxn=2e5+5;
struct node
{
    int x,y,id;
    bool operator<(node a)
    {
        return x<a.x;//按照x排序。
    }
}all[maxn],bll[maxn],temp[maxn];
pair<int,int>ans[maxn];//一个二元组存储最大值最小值，first存储最远曼哈顿距离，second存储最近曼哈顿距离。
int n,upper,ac,mmax,mmin;
void cdq(int l,int r)
{
    if(l==r)
        return ;
    int mid=l+r>>1;
    cdq(l,mid);
    cdq(mid+1,r);
    int idx1=l,idx2=mid+1;
    mmax=-inf,mmin=inf;//初始化
    for(int i=l;i<=r;i++)
    {
        if(idx1<=mid&&(idx2>r||bll[idx1].y<=bll[idx2].y))
        {
            mmax=max(mmax,bll[idx1].x+bll[idx1].y);
            mmin=min(mmin,bll[idx1].x+bll[idx1].y);
            temp[i]=bll[idx1++];
        }
        else
        {
            if(mmin!=-inf)//注意这里不能用未更新过的mmin和mmax来更新答案，蒟蒻在这就被坑了几发。
            ans[bll[idx2].id].first=max(bll[idx2].x+bll[idx2].y-mmin,ans[bll[idx2].id].first);
            if(mmax!=inf)
            ans[bll[idx2].id].second=min(bll[idx2].x+bll[idx2].y-mmax,ans[bll[idx2].id].second);
            temp[i]=bll[idx2++];
        }
    }
    for(int i=l;i<=r;i++)//利用类似归并排序的方式对y进行排序。
        bll[i]=temp[i];
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        ans[i].first=-inf,ans[i].second=inf;//答案初始化
        scanf("%d %d",&all[i].x,&all[i].y);
        all[i].id=i;
        upper=max(upper,all[i].x);
        upper=max(upper,all[i].y);
    }
    for(int i=1;i<=n;i++)
        bll[i]=all[i];
    sort(bll+1,bll+n+1);//注意如果反转导致x顺序乱了要重新sort，这里为了避免出错每次反转都sort了。
    cdq(1,n);
    for(int i=1;i<=n;i++)
        all[i].x=upper-all[i].x,bll[i]=all[i];//在x轴方向反转
    sort(bll+1,bll+n+1);
    cdq(1,n);
    for(int i=1;i<=n;i++)
        all[i].y=upper-all[i].y,bll[i]=all[i];//在y轴方向反转
    sort(bll+1,bll+n+1);
    cdq(1,n);
    for(int i=1;i<=n;i++)
        all[i].x=upper-all[i].x,bll[i]=all[i];
    sort(bll+1,bll+n+1);
    cdq(1,n);
    ac=inf;
    for(int i=1;i<=n;i++)
        ac=min(ac,abs(ans[i].first-ans[i].second));//统计答案记得加绝对值。
    cout<<ac<<endl;
    return 0;
}

```


---

## 作者：Motonic_queues (赞：2)

## 题目大意
给定 $N$ 个二维点，找到一个点，最小化其在平面内最大曼哈顿距离与最小曼哈顿距离的差，并输出。

## 思路分析
注意到维护平面内二维点的关系，考虑使用 2-D Tree。

思考一下如何统计答案，只要把求最近最远点对（[P6247](https://www.luogu.com.cn/problem/P6247)）统计答案的部分根据曼哈顿距离的定义改改就有了。

## Talk is cheap,show me the code
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;

const int N=2e5+5,Dim=2;
int n,rt,Spl;
int ans[N][2];
struct P{
	int pos[Dim];
}po[N];
struct node{
	int l,r,d;
	int mi[Dim],ma[Dim];
}kd[N<<4];

int dis(int a,int b){
	int res=0;
	for(int w=0;w<Dim;w++)res+=abs(po[a].pos[w]-po[b].pos[w]);
	return res;
}
bool cmp(P a,P b){return a.pos[Spl]<b.pos[Spl];}

void update(int x){
	for(int w=0;w<Dim;w++)kd[x].mi[w]=kd[x].ma[w]=po[x].pos[w];
	if(kd[x].l){
		int tmp=kd[x].l;
		for(int w=0;w<Dim;w++){
			kd[x].mi[w]=min(kd[x].mi[w],kd[tmp].mi[w]);
			kd[x].ma[w]=max(kd[x].ma[w],kd[tmp].ma[w]);
		}
	}
	if(kd[x].r){
		int tmp=kd[x].r;
		for(int w=0;w<Dim;w++){
			kd[x].mi[w]=min(kd[x].mi[w],kd[tmp].mi[w]);
			kd[x].ma[w]=max(kd[x].ma[w],kd[tmp].ma[w]);
		}
	}
}
int build(int l,int r,int wd){
	if(l>r)return 0;
	if(l==r){
		update(l);return l;
	}
	int mid=l+r>>1;
	node &x=kd[mid];Spl=wd;
	x.d=wd,nth_element(po+l,po+mid,po+r+1,cmp);
	x.l=build(l,mid-1,wd^1),x.r=build(mid+1,r,wd^1);
	update(mid);
	return mid;
}
int fi(int a,int b){
	int res=0;
	for(int w=0;w<Dim;w++){
		if(kd[b].mi[w]>po[a].pos[w])res+=abs(kd[b].mi[w]-po[a].pos[w]);
		if(kd[b].ma[w]<po[a].pos[w])res+=abs(kd[b].ma[w]-po[a].pos[w]);
	}
	return res;
}
int fa(int a,int b){
	int res=0;
	for(int w=0;w<Dim;w++){
		res+=max(abs(po[a].pos[w]-kd[b].mi[w]),abs(po[a].pos[w]-kd[b].ma[w]));
	}
	return res;
}
void qryi(int x,int y){
	if(y!=x)ans[y][0]=min(ans[y][0],dis(x,y));
	if(!(kd[x].l+kd[x].r))return;
	int disl=kd[x].l?fi(y,kd[x].l):1e18,disr=kd[x].r?fi(y,kd[x].r):1e18;
	if(disl<disr){
		if(disl<ans[y][0])qryi(kd[x].l,y);
		if(disr<ans[y][0])qryi(kd[x].r,y);
	}else{
		if(disr<ans[y][0])qryi(kd[x].r,y);
		if(disl<ans[y][0])qryi(kd[x].l,y);
	}
}

void qrya(int x,int y){
	if(y!=x)ans[y][1]=max(ans[y][1],dis(x,y));
	if(!(kd[x].l+kd[x].r))return;
	int disl=kd[x].l?fa(y,kd[x].l):-1e18,disr=kd[x].r?fa(y,kd[x].r):-1e18;
	if(disl>disr){
		if(disl>ans[y][1])qrya(kd[x].l,y);
		if(disr>ans[y][1])qrya(kd[x].r,y);
	}else{
		if(disr>ans[y][1])qrya(kd[x].r,y);
		if(disl>ans[y][1])qrya(kd[x].l,y);
	}
}

signed main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		double u,v;
		cin>>u>>v;
		po[i]=P{u,v};
		ans[i][0]=1e18;
		ans[i][1]=-1e18;
	}
	rt=build(1,n,0);
	for(int i=1;i<=n;i++){
		qryi(rt,i);
		qrya(rt,i);
	}
	int lans=1e18;
	for(int i=1;i<=n;i++){
		lans=min(lans,-ans[i][0]+ans[i][1]);
	}
	cout<<lans;
	return 0;
}
```

---

## 作者：大菜鸡fks (赞：2)

这题我们使用kdtree，显然的模板题，

我们枚举每个点，都做一遍最小曼哈顿距离，和最大曼哈顿距离。找一个差值最小即可。


代码如下（pascal）

```cpp
type pp=record
     max,min,d:array[0..1]of longint;
     l,r:longint;
end;
var ans,mn,mx,anss,root,i,j,n:longint;
    a:array[0..500005]of pp;
    t:pp;
procedure swap(var x,y:longint);
var z:longint;
begin
  z:=x; x:=y; y:=z;
end;
procedure sort(l,r,k,dd:longint);
var i,j,x:longint;
begin
  i:=l; j:=r; x:=a[(l+r) div 2].d[dd];
  while i<=j do
    begin
    while a[i].d[dd]<x do inc(i);
    while x<a[j].d[dd] do dec(j);
    if i<=j then begin swap(a[i].d[0],a[j].d[0]); swap(a[i].d[1],a[j].d[1]); inc(i); dec(j); end;
    end;
  if (l<j)and(k<=j) then sort(l,j,k,dd);
  if (i<r)and(k>=i) then sort(i,r,k,dd);
end;
function max(x,y:longint):longint;
begin
  if x>y then exit(x) else exit(y);
end;
function min(x,y:longint):longint;
begin
  if x<y then exit(x) else exit(y);
end;
procedure get(k:longint);
var i:longint;
begin
  for i:=0 to 1 do begin a[k].min[i]:=a[k].d[i]; a[k].max[i]:=a[k].d[i]; end;
end;
procedure update(k:longint);
var i:longint;
begin
  if a[k].l<>0 then
    for i:=0 to 1 do
      begin
      a[k].min[i]:=min(a[k].min[i],a[a[k].l].min[i]);
      a[k].max[i]:=max(a[k].max[i],a[a[k].l].max[i]);
      end;
  if a[k].r<>0 then
    for i:=0 to 1 do
      begin
      a[k].min[i]:=min(a[k].min[i],a[a[k].r].min[i]);
      a[k].max[i]:=max(a[k].max[i],a[a[k].r].max[i]);
      end;
end;
function build(l,r,dd:longint):longint;
var mid:longint;
begin
  mid:=(l+r) div 2;
  sort(l,r,mid,dd); get(mid);
  if mid>l then a[mid].l:=build(l,mid-1,dd xor 1);
  if mid<r then a[mid].r:=build(mid+1,r,dd xor 1);
  update(mid);
  exit(mid);
end;
function getdis(k:longint):longint;
begin
  exit(abs(a[k].d[0]-t.d[0])+abs(a[k].d[1]-t.d[1]));
end;
function cal1(k:longint):longint;
var i,res:longint;
begin
  res:=0;
  for i:=0 to 1 do begin inc(res,max(0,a[k].min[i]-t.d[i])); inc(res,max(0,t.d[i]-a[k].max[i])); end;
  exit(res);
end;
procedure querymn(k:longint);
var d0,dl,dr,l,r:longint;
begin
  d0:=getdis(k);
  if d0<>0 then ans:=min(d0,ans);
  l:=a[k].l; r:=a[k].r;
  if l<>0 then dl:=cal1(l) else dl:=100000000;
  if r<>0 then dr:=cal1(r) else dr:=100000000;
  if dl<dr then
    begin
    if dl<ans then querymn(l);
    if dr<ans then querymn(r);
    end
    else
    begin
    if dr<ans then querymn(r);
    if dl<ans then querymn(l);
    end;
end;
function cal2(k:longint):longint;
var i,res:longint;
begin
  res:=0;
  for i:=0 to 1 do inc(res,max(abs(t.d[i]-a[k].max[i]),abs(t.d[i]-a[k].min[i])));
  exit(res);
end;
procedure querymx(k:longint);
var d0,dl,dr,l,r:longint;
begin
  d0:=getdis(k); ans:=max(ans,d0); l:=a[k].l; r:=a[k].r;
  if l<>0 then dl:=cal2(l) else dl:=-100000000;
  if r<>0 then dr:=cal2(r) else dr:=-100000000;
  if dl>dr then
    begin
    if dl>ans then querymx(l);
    if dr>ans then querymx(r);
    end
    else
    begin
    if dr>ans then querymx(r);
    if dl>ans then querymx(l);
    end;
end;
function query(f,x,y:longint):longint;
begin
  t.d[0]:=x; t.d[1]:=y;
  if f=0 then begin ans:=100000000; querymn(root); end
    else begin ans:=-100000000; querymx(root); end;
  exit(ans);
end;
begin
  readln(n);
  for i:=1 to n do readln(a[i].d[0],a[i].d[1]);
  root:=build(1,n,0); anss:=maxlongint;
  for i:=1 to n do
    begin
    mn:=query(0,a[i].d[0],a[i].d[1]); mx:=query(1,a[i].d[0],a[i].d[1]);
    anss:=min(mx-mn,anss);
    end;
  writeln(anss);
end.
```

---

## 作者：ymx2009 (赞：1)

# 题目大意
有一个二维平面，找一个点使得它到平面内曼哈顿距离最远的点与曼哈顿距离最近的点的差最小值。
# 思路分析
曼哈顿距离：
$$
\operatorname{dis}(a,b)=|x_a-x_b|+|y_a-y_b|
$$
本题要处理二维的空间，而 K-D Tree 可以高效处理多维空间。  
# Solution
K-D Tree 的模板。  
求最远点时，剪枝的估价函数应该改为当前点到区间最远的顶点的曼哈顿距离。  
代码如下：
$$
\max(tr[cur].v[0]-tr[x].L[0],tr[x].U[0]-tr[cur].v[0])+\max(tr[cur].v[1]-tr[x].L[1],tr[x].U[1]-tr[cur].v[1])
$$
# 代码时间

```cpp
#include<bits/stdc++.h>
#define lc tr[x].l
#define rc tr[x].r
using namespace std;
const int N=1e5+10;
int n,K,cur,root;
int ans_max,ans_min=2e9,ans=2e9;
struct node{
	int l,r;
	int L[2],U[2],v[2];
	bool operator<(const node &b)const{
		return v[K]<b.v[K];
	}
}tr[N];

void pushup(int x)
{
	for(int i=0;i<2;i++)
	{
		tr[x].L[i]=tr[x].U[i]=tr[x].v[i];
		if(lc) tr[x].L[i]=min(tr[x].L[i],tr[lc].L[i]),tr[x].U[i]=max(tr[x].U[i],tr[lc].U[i]);
		if(rc) tr[x].L[i]=min(tr[x].L[i],tr[rc].L[i]),tr[x].U[i]=max(tr[x].U[i],tr[rc].U[i]);
	}
}

int build(int l,int r,int k)
{
	if(l>r) return 0;
	K=k;
	int mid=l+r>>1;
	nth_element(tr+l,tr+mid,tr+r+1);
	tr[mid].l=build(l,mid-1,k^1);
	tr[mid].r=build(mid+1,r,k^1);
	pushup(mid);
	return mid;
}
int dis(int x){return abs(tr[cur].v[0]-tr[x].v[0])+abs(tr[cur].v[1]-tr[x].v[1]);}//求曼哈顿距离

int dis_min(int x){return (!x)?2e9:max(tr[cur].v[0]-tr[x].U[0],0)+max(tr[x].L[0]-tr[cur].v[0],0)+max(tr[cur].v[1]-tr[x].U[1],0)+max(tr[x].L[1]-tr[cur].v[1],0);}//最近点估价函数

int dis_max(int x){return (!x)?0:max(tr[cur].v[0]-tr[x].L[0],tr[x].U[0]-tr[cur].v[0])+max(tr[cur].v[1]-tr[x].L[1],tr[x].U[1]-tr[cur].v[1]);}//最远点估价函数

void query_min(int x)
{
	if(!x) return;
	if(x!=cur) ans_min=min(ans_min,dis(x));
	int dl=dis_min(lc),dr=dis_min(rc);
	if(dl<dr)
	{
		if(dl<ans_min) query_min(lc);
		if(dr<ans_min) query_min(rc);
	}
	else
	{
		if(dr<ans_min) query_min(rc);
		if(dl<ans_min) query_min(lc);
	}
}

void query_max(int x)
{
	if(!x) return;
	if(x!=cur) ans_max=max(ans_max,dis(x));
	int dl=dis_max(lc),dr=dis_max(rc);
	if(dl>dr)
	{
		if(dl>ans_max) query_max(lc);
		if(dr>ans_max) query_max(rc);
	}
	else
	{
		if(dr>ans_max) query_max(rc);
		if(dl>ans_max) query_max(lc);
	}
}

int main()
{
	cin>>n;
	for(int i=1;i<=n;i++) cin>>tr[++cur].v[0]>>tr[cur].v[1];
	root=build(1,n,0);
	for(cur=1;cur<=n;cur++)
	{
		ans_min=2e9,ans_max=0;
		query_min(root);query_max(root);
		ans=min(ans,ans_max-ans_min);
	}
	cout<<ans;
	return 0;
}
```
建议完成 [P6247](https://www.luogu.com.cn/problem/P6247)。

---

## 作者：MoonCake2011 (赞：1)

此题首先考虑把距离公式的绝对值拆了。

可以通过初一数学的拆绝对值常规方法，**分类讨论**。

OK，现在没有绝对值了，这个公式变成了 $(x_i-x_j)+(y_i-y_j)$，其他情况同理。

对于询问一个点 $i$ 的答案，化为 $(x_i+y_i)-(x_j+y_j)$，因为 $i$ 始终相等，所以使距离最小只用使 $(x_j+y_j)$ 最大，距离最大的情况同理。

然后，因为拆了绝对值，需要使 $x_i>x_j$，$y_i>y_j$。

很熟悉是吧，二维偏序，直接先对 $x$ 排序，再做个归并排序。

然后在归并中用树状数组统计 $(x_j+y_j)$ 的最大值就行了，注意特判不存在这个点的情况。

还要对 $y$ 离散化来统计树状数组。

做四遍 CDQ 即可，这里常数有点大。

因为要做四遍，所以说，建议不要用树套树，和用 `unordered_map` 维护树状数组。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n;
struct node{
	int x,y,_y,ans1,ans2;
}a[100010];
int b[100010];
bool operator < (node x,node y){return x.x<y.x;}
bool cmp(node x,node y){return x.y<y.y;}
bool operator <= (node x,node y){return x.y<=y.y;}
int c[100010];
inline int lowbit(int x){
	return x&-x;
}
inline void update(int x,int v){
	while(x<=1e5) c[x]=max(c[x],v),x+=lowbit(x);
}
inline void clear(int x){
	while(x<=1e5) c[x]=0,x+=lowbit(x);
}
inline int ask(int x){
	int ans=0;
	while(x) ans=max(ans,c[x]),x-=lowbit(x);
	return ans;
}
int d[100010];
inline void updated(int x,int v){
	while(x<=1e5) d[x]=min(d[x],v),x+=lowbit(x);
}
inline void cleard(int x){
	while(x<=1e5) d[x]=1e10,x+=lowbit(x);
}
inline int askd(int x){
	int ans=1e10;
	while(x) ans=min(ans,d[x]),x-=lowbit(x);
	return ans;
}
inline void cdq(int l,int r){
	if(l==r) return;
	int mid=l+r>>1;
	cdq(l,mid),cdq(mid+1,r);
	int i=l,j=mid+1;
	while(i<=mid && j<=r)
		if(a[i]<=a[j]) update(a[i]._y,a[i].x+a[i].y),updated(a[i]._y,a[i].x+a[i].y),i++;
		else{
			int qp=ask(a[j]._y);
			if(qp) a[j].ans2=min(a[j].ans2,a[j].x+a[j].y-qp);
			qp=askd(a[j]._y);
			if(qp!=1e10) a[j].ans1=max(a[j].ans1,a[j].x+a[j].y-qp);
			j++;
		}
	while(j<=r){
		int qp=ask(a[j]._y);
		if(qp) a[j].ans2=min(a[j].ans2,a[j].x+a[j].y-qp);
		qp=askd(a[j]._y);
		if(qp!=1e10) a[j].ans1=max(a[j].ans1,a[j].x+a[j].y-qp);
		j++;
	}
	i=l,j=mid+1;
	while(i<=mid && j<=r)
		if(a[i]<=a[j]) clear(a[i]._y),cleard(a[i]._y),i++;
		else j++;
	sort(a+l,a+r+1,cmp);
}
signed main() {
	memset(d,0x3f,sizeof d);
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i].x>>a[i].y,b[i]=a[i].y,a[i].ans1=0,a[i].ans2=1e10,a[i].x++,a[i].y++;
	sort(b+1,b+n+1);
	int tot=unique(b+1,b+n+1)-b-1;
	for(int i=1;i<=n;i++) a[i]._y=lower_bound(b+1,b+tot+1,a[i].y)-b;
	sort(a+1,a+n+1);
	cdq(1,n);
	for(int i=1;i<=n;i++) a[i].x=1e9-a[i].x+1;
	sort(a+1,a+n+1);
	cdq(1,n);
	for(int i=1;i<=n;i++) a[i].y=1e9-a[i].y+1,b[i]=a[i].y;
	sort(b+1,b+n+1);
	tot=unique(b+1,b+n+1)-b-1;
	for(int i=1;i<=n;i++) a[i]._y=lower_bound(b+1,b+tot+1,a[i].y)-b;
	sort(a+1,a+n+1);
	cdq(1,n);
	for(int i=1;i<=n;i++) a[i].x=1e9-a[i].x+1;
	sort(a+1,a+n+1);
	cdq(1,n);
	int ans=1e10;
	for(int i=1;i<=n;i++) ans=min(ans,a[i].ans1-a[i].ans2);
	cout<<ans;
	return 0;
}
```

时间复杂度 $O(n\log^2n)$。

---

## 作者：xiao7_Mr_10_ (赞：1)

这种题个人感觉很无聊真的，就是无脑拆绝对值。

一句话题意：对于每个点，我们求离它最远的点的距离减去离它最近的点的距离的最大值，这里距离指曼哈顿距离。

考虑计算两点曼哈顿距离的公式：

$dis(i,j)=|x_i-x_j|+|y_i-y_j|$。

有绝对值我们肯定是需要分类讨论的，$dis(i,j)$ 的取值一共有以下四种情况：

- $x_i-x_j+y_i-y_j$，其中 $x_i\ge x_j,y_i \ge y_j$。

- $x_i-x_j-y_i+y_j$，其中 $x_i \ge x_j,y_i < y_j$。

- $-x_i+x_j+y_i-y_j$，其中 $x_i < x_j,y_i \ge y_j$。

- $-x_i+x_j-y_i+y_j$，其中 $x_i < x_j,y_i < y_j$。

这个东西显然是可以利用数据结构优化的。

首先，我们考虑把点离散化后按 $x$ 坐标为第一关键字，$y$ 坐标为第二关键字从小到大排序。

这样我们就消除了限制 $x_i>x_j$，在此基础上直接分类讨论求一下答案即可，具体就是把和 $j$ 有关的项拉出来做数据结构维护最值，这里推荐树状数组。

同理我们需要倒过来做一遍，与正着同理，式子需要变一下。

实际实现的一些细节：

1.可以用一个结构体存树状数组，维护最大值和最小值。

2.由于我们只需要存前缀和后缀的答案，我们可以维护一个参数 $op$ 表示前缀还是后缀，在维护的时候把 $lowbit$ 乘以这个系数即可，这样就需要维护编号的大小范围了。

代码不到 2k 感觉还行。


```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=1e5+5,inf=1e18;
struct Point{
	int x,y,id;
}a[N];
bool cmp(Point x,Point y){
	if(x.x==y.x)return x.y<y.y;
	return x.x<y.x;
}
int n,b[N<<1],len,maxn[N],minn[N],c[N],c1[N];
struct tlh{
	int c[N<<1],d[N<<1],op;
	void clear(){memset(c,0x3f,sizeof(c));memset(d,0xc0,sizeof(d));op=0;}
	void add(int x,int y){for(int i = x;i <= len&&i;i+=(i&(-i))*op)c[i]=min(c[i],y),d[i]=max(d[i],y);}
	int query(int x){int ans=inf;for(;x&&x<=len;x-=(x&(-x))*op)ans=min(ans,c[x]);return ans;}
	int query1(int x){int ans=-inf;for(;x&&x<=len;x-=(x&(-x))*op)ans=max(ans,d[x]);return ans;}
}f,g;int find(int x){return lower_bound(b+1,b+1+len,x)-b;}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin >> n;
	for(int i = 1;i <= n;i++)cin >> a[i].x >> a[i].y,a[i].id=i,b[++len]=a[i].x,b[++len]=a[i].y;
	sort(b+1,b+1+len);len=unique(b+1,b+1+len)-b-1;
	for(int i = 1;i <= n;i++)a[i].x=find(a[i].x),a[i].y=find(a[i].y);f.clear(),g.clear();f.op=1,g.op=-1;
	sort(a+1,a+1+n,cmp);memset(maxn,0xc0,sizeof(maxn));memset(minn,0x3f,sizeof(minn));
	for(int i = 1;i <= n;i++){
		int id=a[i].id,state=b[a[i].x]+b[a[i].y],state1=b[a[i].x]-b[a[i].y];
		maxn[id]=max(maxn[id],max(state+f.query1(a[i].y),state1+g.query1(a[i].y))); 
		minn[id]=min(minn[id],min(state+f.query(a[i].y),state1+g.query(a[i].y)));
		f.add(a[i].y,-b[a[i].x]-b[a[i].y]),g.add(a[i].y,-b[a[i].x]+b[a[i].y]);
	}
	f.clear(),g.clear();f.op=1,g.op=-1;
	for(int i = n;i >= 1;i--){
		int id=a[i].id,state=-b[a[i].x]+b[a[i].y],state1=-b[a[i].x]-b[a[i].y];
		maxn[id]=max(maxn[id],max(state+f.query1(a[i].y),state1+g.query1(a[i].y))); 
		minn[id]=min(minn[id],min(state+f.query(a[i].y),state1+g.query(a[i].y)));
		f.add(a[i].y,b[a[i].x]-b[a[i].y]),g.add(a[i].y,b[a[i].x]+b[a[i].y]);
	}
	int ans=inf;
	for(int i = 1;i <= n;i++)ans=min(ans,maxn[i]-minn[i]);cout << ans;
	return 0;
}
```

---

## 作者：Genius_Star (赞：1)

~~逛了一圈，发现唯一一篇二维偏序的题解的代码写的一坨 XX，于是来补一篇题解。~~

### 题意：

有 $n$ 个点，你需要选一个点 $x$，使得该点到其他点的最远距离与最近距离的差最小。

### 思路：

因为值域很大，所以首先先**离散化**。

题目明显是让我们求：

$$\min\limits_{i=1}^n (\max\limits_{j=1}^n([j \ne i] |x_i-x_j|+|y_i-y_j|) - \min\limits_{j=1}^n([j \ne i] |x_i-x_j|+|y_i-y_j|))$$

那么定义 $i$ 号点的贡献为：

$$a_i=(\max\limits_{j=1}^n([j \ne i] |x_i-x_j|+|y_i-y_j|) - \min\limits_{j=1}^n([j \ne i] |x_i-x_j|+|y_i-y_j|)$$

先考虑在 $i$ 点左下方的点，即要满足 $x_i \ge x_j$ 和 $y_i \ge y_j$，则两者曼哈顿距离为：

$$x_i-x_j+y_i-y_j=(x_i+y_i)-(x_j+y_j)$$

如果求偏序最小值要使得 $x_j+y_j$ 最大，求偏序最大值要使得 $x_j+y_j$ 最小；那么考虑将 $x$ 轴排序，然后树状数组维护即可。

对于其它方向的点都可以通过以 $x$ 为对称轴翻或者以 $y$ 轴为对称轴翻转过去。

时间复杂度为 $O(n \log n)$。

### 完整代码：

```cpp
#include<bits/stdc++.h>
#define lowbit(x) x&-x
using namespace std;
typedef long long ll;
typedef double db;
const ll N=100100,INF=3e9+10;
inline ll read(){
    ll x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')
          f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=(x<<1)+(x<<3)+(c^48);
        c=getchar();
    }
    return x*f;
}
inline void write(ll x){
	if(x<0){
		putchar('-');
		x=-x;
	}
	if(x>9)
	  write(x/10);
	putchar(x%10+'0');
}
struct Node{
	ll X,Y;
	ll x,y;
	ll id;
	bool operator<(const Node&rhs)const{
		if(x!=rhs.x)
		  return x<rhs.x;
		return y<rhs.y;
	}
}A[N],T[N];
ll n,Max,cnt,ans=INF;
ll a[N<<1],MAX[N],MIN[N];
class BIT{
public:
	ll a[N<<1];
	void init(){
		for(int i=1;i<=cnt;i++)
		  a[i]=-1;
	} 
	void add(ll x,ll v,bool f){
		for(int i=x;i<=cnt;i+=lowbit(i)){
			if(f)
			  a[i]=max(a[i],v);
			else{
				if(a[i]==-1)
				  a[i]=v;
				else
				  a[i]=min(a[i],v);
			}
		}
	}
	ll qurey(ll x,bool f){
		ll ans=0;
		if(!f)
		  ans=INF;
		for(int i=x;i;i-=lowbit(i)){
			if(f)
			  ans=max(a[i],ans);
			else{
				if(a[i]==-1)
				  continue;
				ans=min(a[i],ans);
			}
		}
		if(f&&!ans)
		  ans=-INF;
		return ans;
	}
}T1,T2;
void solve(bool x,bool y){
	cnt=0;
	for(int i=1;i<=n;i++){
		A[i]=T[i];
		if(x) 
		  A[i].X=Max-A[i].X;
		if(y) 
		  A[i].Y=Max-A[i].Y;
		a[++cnt]=A[i].X;
		a[++cnt]=A[i].Y;
	}
	sort(a+1,a+cnt+1);
	cnt=unique(a+1,a+cnt+1)-(a+1);
	T1.init(),T2.init();
	for(int i=1;i<=n;i++){
		A[i].x=lower_bound(a+1,a+cnt+1,A[i].X)-a;
		A[i].y=lower_bound(a+1,a+cnt+1,A[i].Y)-a;
	}
	sort(A+1,A+n+1);
	T1.add(A[1].y,A[1].X+A[1].Y,1);
	T2.add(A[1].y,A[1].X+A[1].Y,0);
	for(int i=2;i<=n;i++){
		MIN[A[i].id]=min(MIN[A[i].id],A[i].X+A[i].Y-T1.qurey(A[i].y,1));
		MAX[A[i].id]=max(MAX[A[i].id],A[i].X+A[i].Y-T2.qurey(A[i].y,0));
//		cerr<<T1.qurey(A[i].y,1)<<' '<<T2.qurey(A[i].y,0)<<'\n';
		T1.add(A[i].y,A[i].X+A[i].Y,1);
		T2.add(A[i].y,A[i].X+A[i].Y,0);		
	}
}
int main(){
	n=read();
	for(int i=1;i<=n;i++){
		MAX[i]=0,MIN[i]=INF;
		A[i].X=read();
		A[i].Y=read();
		A[i].id=i;
		Max=max({Max,A[i].X,A[i].Y});
		T[i]=A[i];
	}
	solve(0,0);
	solve(0,1);
	solve(1,0);
	solve(1,1);
	for(int i=1;i<=n;i++){
		ans=min(ans,MAX[i]-MIN[i]);
//		write(MAX[i]);
//		putchar(' ');
	}
//	putchar('\n');
//	for(int i=1;i<=n;i++){
//		write(MIN[i]);
//		putchar(' ');
//	}
//	putchar('\n');
	write(ans);	
	return 0;
}
```

---


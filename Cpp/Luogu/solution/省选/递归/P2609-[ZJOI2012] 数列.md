# [ZJOI2012] 数列

## 题目描述

小白和小蓝在一起上数学课，下课后老师留了一道作业，求下面这个数列的通项公式：

$$a_0=0,a_1=1,a_{2i}=a_i,a_{2i+1}=a_i+a_{i+1}$$

小白作为一个数学爱好者，很快就计算出了这个数列的通项公式。于是，小白告诉小蓝自己已经做出来了，但为了防止小蓝抄作业，小白并不想把公式公布出来。于是小白为了向小蓝证明自己的确做出来了此题以达到其炫耀的目的，想出了一个绝妙的方法：即让小蓝说一个正整数 $n$，小白则说出 $a_n$ 的值，如果当 $n$ 很大时小白仍能很快的说出正确答案，这就说明小白的确得到了公式。但这个方法有一个很大的漏洞：小蓝自己不会做，没法验证小白的答案是否正确。作为小蓝的好友，你能帮帮小蓝吗？

## 说明/提示

- 对于 $20\%$ 的数据，$1 \le n \le 10^8$。 
- 对于 $50\%$ 的数据，$1 \le n \le 10^{12}$。
- 对于 $100\%$ 的数据，$1 \le T \le 20$，$1 \le n \le 10^{100}$。

## 样例 #1

### 输入

```
3
1
3
10
```

### 输出

```
1
2
3
```

# 题解

## 作者：一只书虫仔 (赞：21)

#### Description

> 给定一个序列 $a_i$ 的通项公式
> $$a_0=0,a_1=1,a_{2i}=a_i,a_{2i+1}=a_i+a_{i+1}$$
> 给定 $n$，求 $a_n$

#### Solution

~~又是高精~~

这题可以进行转化，比如 $a_{2i}$ 和 $a_{2i+1}$，可以转化为两个 $a_i$ 和一个 $a_{i+1}$。

$a_i$ 和 $a_{i+1}$ 可以继续转化，我们就可以把 $a_n$ 转化为：

$$a_n=l \times a_0+r \times a_1$$

我们可以让所有满足 $n \in \mathbb Z,n>1$ 的 $a_n$ 转化为上面的式子，比如：

- $a_2=a_\frac{2}{2}=a_1=0 \times a_0+1 \times a_1=1$
- $a_3=a_\frac{2}{2}+a_{\frac{2}{2}+1}=a_1+a_2=a_1+a_1=0 \times a_0+2 \times a_1=2$
- $a_4=a_\frac{4}{2}=a_2=a_1=0 \times a_0+1 \times a_1=1$

所以我们只需要求出 $l$ 和 $r$ 即可，因为 $a_0=0,a_1=1$，所以输出 $r$ 即可。

#### Code 1

```cpp
#include <bits/stdc++.h>

using namespace std;

int main () {
	long long t;
	scanf("%lld", &t);
	while (t--) {
		long long n;
		scanf("%lld", &n);
		long long l = 1, r = 0;
		while (n > 0) {
			if (n % 2 == 0)
				l = l + r;
			else
				r = l + r;
			n /= 2;
		}
		printf("%lld\n", r);
	}
	return 0;
}

```

预计得分：$50$ 分     
[Record Link](https://www.luogu.com.cn/record/36855183)

让我们重新审视 $n$ 的数据范围，$n \le 10^{100}$。

所以这题需要高精。

#### Code 2

```python
t = int(input())

for i in range(1, t + 1) :
    n = int(input())
    
    l = 1
    r = 0

    while n > 0 :
        if n % 2 == 0 :
            l = l + r
        else :
            r = l + r
        n //= 2

    print(r)
```

预计得分：$100$ 分       
[Record Link](https://www.luogu.com.cn/record/36837846)

~~用 python 会被骂的，所以还是要好好写 C++ 比较好~~

By Shuchong      
2020.8.12

---

## 作者：xyz32768 (赞：12)

首先考虑一个问题，设$u*A(i)+v*A(i+1)=x*A(i/2)+y*A(i/2+1)$，$i,u,v$为已知量，$x,y$为未知量，求在$i$分别为奇数和偶数时$x,y$的一组正整数解。可以想到：

$i$为偶数时，$i+1$为奇数。此时$u*A(i)+v*A(i+1)=u*A(i/2)+v*(A(i/2)+A(i/2+1))=(u+v)*A(i/2)+v*A(i/2+1)$。

$i$为奇数时，$i+1$为偶数。此时$u*A(i)+v*A(i+1)=u*(A(i/2)+A(i/2+1))+v*A(i/2+1)=u*A(i/2)+(u+v)*A(i/2+1)$。

所以得出：$i$为偶数时，$x=u+v,y=v$，否则$i$为奇数时，$x=u,y=u+v$。

回到原问题。由于$10^100$的数据范围，一步一步地递推肯定是行不通的。我们就考虑一倍一倍地递推。

首先不断地把$n$除以$2$直到$n$不是$2$的倍数为止。

然后可以看出，结果$=1*A(n/2)+1*A(n/2+1)$。此时，根据前面得出的结论，不断地把$n$缩小一倍，最后可以得到$u*A(0)+v*A(1)$的式子。到了这一步，就可以得出结果为$v$。高精实现即可。

代码：

```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
const int N = 105;
struct cyx {
    int n, a[N];
    cyx() {}
    cyx(int _n) :
        n(_n) {memset(a, 0, sizeof(a));}
};
cyx read() {
    int i = 1, j; cyx res = cyx(0); char c; bool flag = 0;
    while ((c = getchar()) < '0' || c > '9');
    if (c - 48) res.a[res.n = 1] = c - 48, flag = 1;
    while ((c = getchar()) >= '0' && c <= '9') {
        if (c - 48) flag = 1;
        if (flag) res.a[++res.n] = c - 48;
    }
    if (!res.n) res.a[res.n = 1] = 0;
    for (j = res.n; i < j; i++, j--) swap(res.a[i], res.a[j]);
    return res;
}
void write(cyx num) {
    int i; for (i = num.n; i; i--)
        printf("%d", num.a[i]);
    printf("\n");
}
cyx div2(cyx num) {
    int i; for (i = num.n; i; i--) {
        if (num.a[i] & 1) num.a[i - 1] += 10;
        num.a[i] >>= 1;
    }
    while (num.n > 1 && !num.a[num.n]) num.n--;
    return num;
}
cyx plus1(cyx num) {
    int i = 1; while (num.a[i] == 9) num.a[i] = 0, i++;
    num.a[i]++; if (num.a[num.n + 1]) num.n++; return num;
}
cyx add(cyx a, cyx b) {
    cyx res = cyx(max(a.n, b.n)); int i;
    for (i = 1; i <= res.n; i++) {
        res.a[i] += a.a[i] + b.a[i];
        if (res.a[i] > 9) res.a[i] -= 10, res.a[i + 1]++;
    }
    if (res.a[res.n + 1]) res.n++; return res;
}
cyx solve(cyx num) {
    if (num.n == 1 && (num.a[1] == 0 || num.a[1] == 1)) return num;
    while (!(num.a[1] & 1)) num = div2(num);
    cyx l = div2(num), r = plus1(l), u = cyx(1), v = cyx(1);
    u.a[1] = v.a[1] = 1; while (l.n > 1 || l.a[1]) {
        if (l.a[1] & 1) v = add(u, v); else u = add(u, v);
        l = div2(l); r = plus1(l);
    }
    return v;
}
int main() {
    int T; scanf("%d", &T);
    while (T--) write(solve(read()));
    return 0;
}
```

---

## 作者：PY_Fighter (赞：12)

蒟蒻看到大佬们的神仙代码瑟瑟发抖~

~~这不是道高精裸题么~~

```python
for i in range(int(input())):
    n=int(input())
    a=1
    b=0;
    while n>0:
        if n%2==0:
            a=a+b
        else:
            b=a+b
        n//=2
    print(b)

```

高精题？当然要用python啦！

a表示A(n)的个数,b表示A(n+1)的个数，分治即可

~~于是我默默地评了普及/提高-~~

---

## 作者：CuiZhenhang (赞：6)

## Description

**给定一个数列满足：**

$a_0=0$,$a_1=1$,$a_{2i}=a_i$,$a_{2i+1}=a_{i}+a_{i+1}$

**给定 $n$，求 $a_n$。**
## Solution
**读题**

先看数据范围 $1 \leq T \leq 20$，$1 \leq n \leq 10^{100}$，不用高精直接暴毙，所以先打个十进制进制高精加法。

------------
**开始推理：**

首先想到递归：
```
BigNum f(BigNum a){
	if(a==0) return 0;
	if(a==1) return 1;
	BigNum t=a/2;
	if(a%2==0)return f(t);
    else return f(t)+f(t+1);
}
```
- 然后添加记忆化，发现数组开不下 $10^{100}$，直接飞机；
- 接着是暴力枚举，也就 Debug 时判断较小的 $n$ 可用；
- 苦思冥想，突然想到对 $n$ 的运算除了加就是除 2 （模 2 ），于是想到把十进制 $n$ 转成二进制递推。

**举个例子：**

枚举得 $a_{101}=19$，计算得 $(101)_{10}=(1100101)_2$。

$a_{1100101}=a_{110010}+a_{110011}=19$

$ a_{110010}=a_{11001}=7$

$ a_{110011}=a_{11001}+a_{11010}=12$

$  a_{11001}=a_{1100}+a_{1101}=7$

$  a_{11010}=a_{1101}=5$

$   a_{1100}=a_{110}=2$

$   a_{1101}=a_{110}+a_{111}=5$

$    a_{110}=a_{11}=2$

$    a_{111}=a_{11}+a_{100}=a_{11}+a_{1}=3$

$     a_{11}=a_{1}+a_{10}=a_{1}+a_{1}=2$

$      a_{1}=1$


观察一下计算过的 $a_n$(可算几个不同的 $n$)，发现如下规律：

$a_{s0\{\ any\ \}}=a_{s}$

$a_{s0\{\ any+1\ \}1}=a_{s0\{\ any+1\ \}} + a_{s0\{\ any\ \}1}$

$a_{s01\{\ any+1\ \}}=a_{s01\{\ any\ \}} + a_{s1}$

$a_{1\{\ any+1\ \}}=a_{1\{\ any\ \}} + a_{10\{\ any\ \}}=a_{1\{\ any\ \}} + a_{1}$

其中 s 为任意 01 串，any 为任意自然数，0{ any } 表示重复 any 个 0。

那么 $a_{1100101}$（即十进制 $a_{101}$）可这样计算：

$a_{0}=0$

$a_{1}=1$

$a_{10}=1$

$a_{11}=2$

$ a_{110}=a_{11}=2$

$ a_{111}=a_{11}+a_{1}=2+1=3$

$  a_{1100}=a_{110}=2$

$  a_{1101}=a_{110}+a_{111}=2+3=5$

$   a_{11000}=a_{1100}=2$

$   a_{11001}=a_{1100}+a_{1101}=2+5=7$

$    a_{110010}=a_{11001}=7$

$    a_{110011}=a_{11001}+a_{1101}=12$

$     a_{1100100}=a_{110010}=7$

$     a_{1100101}=a_{110010}+a_{110011}=19$


手动模拟几次后会发现如下规律：

- 若最新一位为 0，则取值为上一次添 0 的结果；
- 若最新一位为 1，则取值为新一位添 0 的结果与忽略末尾连续 1，然后将末位 0 改为 1 之和；

于是核心代码便写出来了。

**新的问题**

如何快速将十进制转换为二进制？

还记得用 `a=(a<<3)+(a<<1);` 表示 `a*=10;` 吗？

之所以是左移 3、1 而不是其它的数，是因为 10 的二进制表示为 1010，1 的位置分别是 3、1。

同理，我在 $10^8$ 到 $10^{18}$ 之间找到了 $10^{13}$，
它的二进制表示为 $10010001100001001110011100101010000000000000$，1 的位置分别为 13、15、17、20、21、22、25、26、27、30、35、36、40、43，意味着做 14 次二进制加法就可以等效乘以 $10^{13}$，即输入 13 位数字。
所以先输入字符串，然后每次取 13 位转为`long long`，再加入到预定二进制数组中，十进制转二进制的工作就轻松完成了。

## Code
`node` 结构体的 `v0` 表示在其后面添加 0，`v1`表示添加 1。

```cpp
#include <bits/stdc++.h>
using namespace std;

struct BigNum{
	vector<int>vec;
	int len;
	void refresh(){
		while(!vec.empty()){
			if(vec.back()) break;
			vec.pop_back();
		}
		len=vec.size();
	}
	BigNum(){len=0;}
	BigNum(int t){(*this) = t;}
	BigNum(const char t[]){(*this) = t;}
	BigNum operator= (int t){
		vec.clear();
		len=0;
		while(t){
			vec.push_back(t%10);
			len++;
			t/=10;
		}
		return *this;
	}
	BigNum operator= (const char t[]){
		len=strlen(t);
		vec.resize(len);
		for(int i=len-1;i>=0;i--){
			if(t[i]<'0' || t[i]>'9'){
				len=0;
				vec.clear();
				return *this;
			}
			vec[len-i-1]=t[i]-'0';
		}
		refresh();
		return *this;
	}
	BigNum operator+= (BigNum t){
		int temp=0,i=0;
		if(t.len>len) len=t.len, vec.resize(len);
		for(;i<t.len;i++){
			temp+=vec[i]+t.vec[i];
			vec[i]=temp%10;
			temp/=10;
		}
		for(;temp && i<len;i++){
			temp+=vec[i];
			vec[i]=temp%10;
			temp/=10;
		}
		if(temp){
			vec.push_back(temp);
			len++;
		}
		return *this;
	}
	BigNum operator+ (BigNum t){
		BigNum temp=*this;
		return temp+=t;
	}
	bool operator== (BigNum t){
		if(len!=t.len) return 0;
		for(int i=len-1;i>=0;i--)
			if(vec[i]!=t.vec[i]) return 0;
		return 1;
	}
	bool operator!= (BigNum t){return !((*this)==t);}
	bool operator< (const BigNum t)const {
		if(len!=t.len) return len<t.len;
		for(int i=len-1;i>=0;i--){
			if(vec[i]==t.vec[i]) continue;
			return vec[i]<t.vec[i];
		}
		return 0;
	}
	bool operator>= (BigNum t){return !((*this)<t);}
	bool operator> (BigNum t){return t<(*this);}
	bool operator<= (BigNum t){return !(t<(*this));}
};
istream& operator>> (istream &io, BigNum &t){
	char c[10010];
	cin>>c;
	t=c;
	return io;
}
ostream& operator<< (ostream &io, BigNum t){
	if(!t.len){
		putchar('0');
		return io;
	}
	for(int i=t.len-1;i>=0;i--)
		putchar(t.vec[i]+'0');
	return io;
}//十进制高精度板子

//二进制高精度板子
struct BoolInt{
	bool vec[400];
	int mx;
	BoolInt(){mx=0,memset(vec, 0, sizeof vec);}
	void add(long long t){//添加一个long long
		int len=0,i=0;
		bool temp=0,tmp[64];
		while(t){
			tmp[len++]=t&1;
			t>>=1;
		}//long long 转二进制
		for(;i<len;i++){
			if(tmp[i]){
				if(vec[i]){
					if(temp) vec[i]=1,temp=1;
					else vec[i]=0,temp=1;
				} else {
					if(temp) vec[i]=0,temp=1;
					else vec[i]=1,temp=0;
				}
			} else {
				if(vec[i]){
					if(temp) vec[i]=0,temp=1;
					else vec[i]=1,temp=0;
				} else {
					if(temp) vec[i]=1,temp=0;
					else vec[i]=0,temp=0;
				}
			}
		}//二进制加法，算上进位也只有8种情况，都写出来即可
		for(;temp;i++){
			if(vec[i]) vec[i]=0;
			else vec[i]=1,temp=0;
		}//long long加完后处理进位
		if(i>mx) mx=i;
	}
	void add(BoolInt t, int k){
		int i=0;//二进制加二进制，k是左移量
		bool temp=0;
		for(;i<=t.mx;i++){
			if(t.vec[i]){
				if(vec[i+k]){
					if(temp) vec[i+k]=1,temp=1;
					else vec[i+k]=0,temp=1;
				} else {
					if(temp) vec[i+k]=0,temp=1;
					else vec[i+k]=1,temp=0;
				}
			} else {
				if(vec[i+k]){
					if(temp) vec[i+k]=0,temp=1;
					else vec[i+k]=1,temp=0;
				} else {
					if(temp) vec[i+k]=1,temp=0;
					else vec[i+k]=0,temp=0;
				}
			}
		}
		for(;temp;i++){
			if(vec[i]) vec[i]=0;
			else vec[i]=1,temp=0;
		}
		if(i+k>mx) mx=i+k;
	}
};
struct node{
	BigNum v0,v1;
}value[400];
int m[]={14,16,18,21,22,23,26,27,28,31,36,37,41,44};//大小为14，由于疏忽都多写了1，所以在后面有减1

string s;
long long t,len,dss,ll10[10];
string ccc(int a){//生成a位0，用来补位
	if(!a) return "";
	string ans;
	for(int i=13;i>a;i--) ans+="0",dss++;
	return ans;
}

int main(){
	cin>>t;
	while(t--){
		cin>>s;
		BoolInt arr;
		dss=0;
		s=ccc(s.size()%13)+s;//补位
		len=s.size()/13;
		
		for(int i=0;i<len;i++){
			//13*(len-i-1)+range(0,12)
			ll10[i]=0;
			for(int j=0;j<13;j++){
				if(13*(len-i-1)+j<dss) continue;
				ll10[i]*=10;
				ll10[i]+=s[13*(len-i-1)+j]-'0';
			}
		}//string 转13位long long
		arr.add(ll10[len-1]);
		for(int i=len-2;i>=0;i--){
			BoolInt temp;
			for(int j=0;j<14;j++)
				temp.add(arr, m[j]-1);//等效于乘10^13
			temp.add(ll10[i]);
			arr=temp;
		}
		
		int i=arr.mx,len_1=0;
		for(;!arr.vec[i] && i>=0;i--);
		if(i<=0){
			cout<<(i?0:1)<<endl;
			continue;
		}
		value[i+1].v0=0;
		value[i+1].v1=1;
		value[i].v0=1;
		value[i].v1=2;//四行补位，防止后续出错
		for(i--;i>=0;i--){//按规律执行
			if(arr.vec[i]){
				len_1++;
				value[i].v0=value[i+1].v1;
				value[i].v1=value[i+1].v1+value[i+1+len_1].v1;
			} else {
				len_1=0;
				value[i].v0=value[i+1].v0;
				value[i].v1=value[i+1].v0+value[i+1].v1;
			}
		}
		cout<<value[0].v0<<endl;
	}
	
	return 0;
}
```

## 后记
第一次写题解，请多多包涵 AVA 。


---

## 作者：critnos (赞：4)

一看就是 py 对不对？

然后您写了一个递归程序发现时间复杂度不正确。

那么考虑记忆化搜索。

其实写出一个搜索然后加上记忆化就行了。。。

py 里有个类似 STL::map 的东西叫做字典。

介绍一下它的功能。

访问某个键映射的值直接用下标访问。

判断一个键值 $val$ 是否在字典 $m$ 的方法是：

```
if val in m:
```

```python
dp={}
def f(x):
    if x in dp:
        return dp[x]
    if x<2:
        return x
    ans=f(x//2)
    if x%2:
        ans=ans+f(x//2+1)
    dp[x]=ans
    return ans
t=int(input())
for i in range(t):
    print(f(int((input()))))
```


---

## 作者：封禁用户 (赞：1)

给定一种数列，$t$ 次询问 $a_n$。

数列公式为 $a_0=0,a_1=1,a_{2i}=a_i,a_{2i+1}=a_i+a_{i+1}$。

首先观察样例，$n\le10^{100}$ 只能考虑 $\mathcal O(\log n)$ 的算法，从 $a_n$ 暴力推肯定不行。

分析发现，对于任意 $a_i$ 均可化为 $xa_0+ya_1=y$ 的形式。
$$
a_n=
\begin{cases}
0\quad n=0\\
1\quad n=1\\
a_{\frac{n}{2}}\quad n\equiv1\pmod2\\
a_{\frac{n-1}{2}}+a_{\frac{n+1}{2}}\quad n\equiv0\pmod2
\end{cases}
$$
所以可以一直从 $a_n$ 变化到 $xa_0+ya_1=y$。

注意要写高精。~~我比较懒就用 python 了。~~
```python
t=int(input())
for i in range(0,t):
    n=int(input())
    x=1
    y=0
    while n>=1:      #变化过程
        if n%2==0:   #n mod 2=0 的情况
            x+=y
        else:        #n mod 2=1 的情况
            y+=x
        n//=2        #//是整除
    print(y)         #答案为 x*a0+y*a1=y
```

---

## 作者：littleKtian (赞：1)

upd on 2021.10.25：（又）修了几个排版的问题。

upd on 2021.8.6：重修了一遍排版。

------------

假设我们要求 $xa_i+ya_{i+1}$ 的值。

若 $i$ 为偶数，设 $i=2k$，据题意有$a_i=a_k,a_{i+1}=a_{2k+1}=a_k+a_{k+1}$，得：
$$xa_i+ya_{i+1}=(x+y)a_k+ya_{k+1}$$

若 $i$ 为奇数，设 $i=2k+1$，有 $a_i=a_k+a_{k+1},a_{i+1}=a_{2k+2}=a_{k+1}$，得：
$$xa_i+ya_{i+1}=xa_k+(x+y)a_{k+1}$$

特别的，当 $i=0$ 时，$xa_i+ya_{i+1}=xa_0+ya_1=y$。

显然我们要求的就是 $1\times a_n+0\times a_{n+1}$，直接递归计算即可。

因为结果很大所以需要用高精计算。

```
#include<bits/stdc++.h>
using namespace std;
struct num{
	int a[105];
};
num dow(num x)//求x被2除的结果 
{
	num xx;
	memset(xx.a,0,sizeof(xx.a));
	xx.a[0]=x.a[0];
	int r=0;
	for(int i=xx.a[0];i>0;i--)
	{
		r=r*10+x.a[i];
		xx.a[i]=r>>1;
		r=r&1;
	}
	while(xx.a[0]>1&&xx.a[xx.a[0]]==0)--xx.a[0];
	return xx;
}
num operator +(const num &x,const num &y)//高精加 
{
	num xx;
	memset(xx.a,0,sizeof(xx.a));
	int i=1;
	while(i<=x.a[0]||i<=y.a[0])
	{
		xx.a[i]+=x.a[i]+y.a[i];
		xx.a[i+1]+=xx.a[i]/10;
		xx.a[i]%=10;
		++i;
	}
	while(xx.a[i])
	{
		xx.a[i+1]+=xx.a[i]/10;
		xx.a[i]%=10;
		++i;
	}
	xx.a[0]=i-1;
	return xx;
}
num n;
int t;
num xw(num k,num x,num y)//求x*A(k)+y*A(k+1)的值 
{
	if(k.a[0]==1&&k.a[1]==0)return y;//特判 
	if(k.a[1]&1)return xw(dow(k),x,x+y);//递归 
	else return xw(dow(k),x+y,y);
}
void sc(num x)
{
	for(int i=x.a[0];i>0;i--)printf("%d",x.a[i]);
	printf("\n");
}
int main()
{
	scanf("%d",&t);
	while(t--)
	{
		char s[105];
		scanf("%s",s);
		n.a[0]=strlen(s);
		for(int i=0;i<n.a[0];i++)n.a[n.a[0]-i]=s[i]-'0';
		num x,y;
		memset(x.a,0,sizeof(x.a));
		memset(y.a,0,sizeof(y.a));
		x.a[0]=y.a[0]=1,x.a[1]=1,y.a[1]=0;//初始x=1,y=0 
		num ans=xw(n,x,y);
		sc(ans);
	}
}
```

---

## 作者：66666a (赞：1)

题解里有人推出了通项公式，甚至还有人写字典树

但是我太菜了，不会咋办

我们不妨考虑一对数(x,x+1)，那么它的结果可以由(x/2,x/2+1)的结果得到，有两种情况：

1、x=2u，x+1=2u+1，则Ax=Ax/2,A(x+1)=Ax/2+A(x/2+1)

2、x=2u+1，x+1=2u+2，则Ax=Ax/2+A(x/2+1),Ax+1=A(x/2+1)

然后所有的数对最终会变为(1,2)，结果即(n,n+1)的前一项。

复杂度为O(logN)

AC代码如下：

```cpp
#include<bits/stdc++.h> 
using namespace std;  
struct hgnum
{ 
    int p[505];
}s,x,y; 
char ch[105]; 
int c[1005];  
hgnum pls(hgnum a,hgnum b)
{
    a.p[0]=max(a.p[0],b.p[0]);
    for (int i=1;i<=a.p[0];i++) a.p[i]+=b.p[i]; 
    for (int i=1;i<=a.p[0];i++)
    if (a.p[i]>9)
    {
        a.p[i+1]+=a.p[i]/10;
        a.p[i]%=10;
    }
    if (a.p[a.p[0]+1]) a.p[0]++;
    return a;
}
void hlf()
{
    for (int i=s.p[0];i;i--)
    {
        if (s.p[i]&1&&i>1) s.p[i-1]+=10;
        s.p[i]>>=1;
    }
    if (!s.p[s.p[0]]) s.p[0]--;
}
void clr(hgnum &a)
{
    memset(a.p,0,sizeof(a.p));
}
int main()
{  
    int t;
    scanf("%d",&t);
    while (t--)
    {
        scanf("%s",ch+1);
        int len=0;
        clr(s);
        clr(x);
        clr(y);
        s.p[0]=strlen(ch+1);
        for (int i=1;i<=s.p[0];i++) s.p[i]=ch[s.p[0]-i+1]-'0';
        if (s.p[0]==1&&!s.p[1])
        {
            puts("0");
            continue;
        }
        while (s.p[0]>1||s.p[1]>1)
        {
            c[++len]=s.p[1]&1;
            hlf();
        }
        x.p[0]=x.p[1]=y.p[0]=y.p[1]=1;
        for (int i=len;i;i--) 
        if (c[i]) x=pls(x,y);else y=pls(x,y);
        for (int i=x.p[0];i;i--) printf("%d\n",x.p[i]);
    }
    return 0;
}
```

---

## 作者：Night_Aurora (赞：1)

对于一个很大的数N，每一层会变成至多两个数——N/2 和 N/2+1

再进一层 N/2和N/2+1到下一层变成三个数，其中有两个一样

这时我们猜测每层都至多两个数，那么记忆化搜索得话过程复杂度就是2log(N)，

也才不到700

最重要的是记忆化，考虑到全程是高精操作，建立一个高精表格很明显不现实

在此我们可以用O(N)查询插入的Trie树保存，对于Trie的Val就来保存数值吧

考虑到高精比较占内存，于是在Trie树里我们使用动态分配内存，Val是一个指针数组（分开就是两个\*号）

每次询问都不一样，所以每次之前都清空Trie

每层都要高精操作，高精操作复杂度记为log(N)

虽说事实上高精操作要小得多(lg(N))但次数常数不可忽视

总复杂度就是O（log(N)^2）







    



```cpp
#include <stdio.h>
#include <string.h>
#include <iostream>
#define max(a,b) (a>b?a:b)
#define SIGMA    10
#define TRANS(c) (c)
#define MXN        600000
#define IsZero(c) (c.Long==1&&c.Dat[1]==0)
#define Select() {while(Long-1&&!Dat[Long])--Long;}
typedef long long _L;
typedef struct IntEx
{
    short Dat[210];
    int Long;
    void Insert(char*str);
        IntEx();
    void Divide2();
    void Minus(IntEx*);
    void Copy(IntEx*);
    void Clear();
    void Print();
    void Add(IntEx*a);
    IntEx operator +(IntEx a){IntEx c;c.Copy(this);c.Add(&a);return c;}
}IE;
IE Zero;
```
class Trie
{
public:










```cpp
    int Next[MXN][SIGMA];
    IE*Val[MXN];
    int Top;
        Trie();
    void Clear();
    IE FindString(short*str,int);
    void InsertString(short*str,IE Val,int);
};
    IE::IntEx()
{
    Long=1;
    memset(Dat,0,sizeof(Dat));
}
void Trie::Clear()
{
    int wi;
    for(wi=0;wi<=Top;++wi)
        if(Val[wi])
        {
            delete(Val[wi]);
            Val[wi]=0;
        }
    memset(Next,0,sizeof(Next));
    Top=0;
}
void IE::Add(IntEx*a)
{
    Long=max(Long,a->Long)+1;
    int wi,exa=0;
    for(wi=1;wi<=Long;++wi)
    {
        Dat[wi]+=a->Dat[wi]+exa;
        exa=Dat[wi]/10;
        Dat[wi]%=10;
    }
    Select();
}
void IE::Print()
{
    int wi;
    for(wi=Long;wi;--wi)
        putchar(Dat[wi]+'0');
    putchar(10);
}
void IE::Clear()
{
    memset(Dat,0,sizeof(int)*(Long+1));
    Long=1;
}
void IE::Insert(char*str)
{
    Long=strlen(str);
    int wi;
    for(wi=Long;wi;--wi)
        Dat[wi]=str[Long-wi]-'0';
}
void IE::Copy(IE*ie)
{
    memset(Dat,0,sizeof(int)*(Long+1));
    Long=ie->Long;
    memcpy(Dat,ie->Dat,sizeof(int)*(Long+1));
}
void IE::Divide2()
{
    int wi=Long;
    int exa=0;
    while(wi)
    {
        Dat[wi]+=exa*10;
        exa=Dat[wi]%2;
        Dat[wi]/=2;
        --wi;
    }
    Select();
}
void IE::Minus(IntEx*r)
{
    int wi;
    int exm=0;
    int nl=max(Long,r->Long)+1;
    Long=nl;
    for(wi=1;wi<=nl;++wi)
    {
        Dat[wi]-=exm;
        exm=0;
        Dat[wi]-=r->Dat[wi];
        while(Dat[wi]<0)
            ++exm,Dat[wi]+=10;
    }
    Select();
}
IE Trie::FindString(short*str,int ln)
{
    int pos=0;
    ++str;
    while(ln--)
    {
        pos=Next[pos][TRANS(*str)];
        if(!pos)return Zero;
        ++str;
    }
    return Val[pos]==0?Zero:*Val[pos];
}
void Trie::InsertString(short*str,IE Vl,int ln)
{
    int pos=0;
    ++str;
    while(ln--)
    {
        if(!Next[pos][TRANS(*str)])
            Next[pos][TRANS(*str)]=++Top;
        pos=Next[pos][TRANS(*str)];
        ++str;
    }
    Val[pos]=new IE;
    Val[pos]->Copy(&Vl);
}
    Trie::Trie()
{
    Top=0;
    memset(Next,0,sizeof(Next));
}
void ReadStr(char*str)
{
    int op=0;
    char c=getchar();
    while(c<'0'||c>'9')
        c=getchar();
    while(c>='0'&&c<='9')
    {
        str[op++]=c;
        c=getchar();
    }
    str[op]='\0';
}
int T;
char Nms[130];
IE Nmc,One;
Trie Glb;
IE Pool[11000];
int PL;
IE Binary(IE*ie)
{
    IE ba;
    ba=Glb.FindString(ie->Dat,ie->Long);
    if(!IsZero(ba))
        return ba;
    if(IsZero((*ie)))return Zero;
    IE*a=Pool+PL++,*b=Pool+PL++;
    a->Copy(ie);
    b->Copy(ie);
    a->Divide2();
    if(ie->Dat[1]%2)
    {
        b->Minus(a);
        ba=Binary(a)+Binary(b);
    }
    else
        ba=Binary(a);
    Glb.InsertString(ie->Dat,ba,ie->Long);
    PL-=2;
    return ba;
}
void IA()
{
    Glb.Clear();
    Glb.InsertString(One.Dat,One,One.Long);
    ReadStr(Nms);
    Nmc.Clear();
    Nmc.Insert(Nms);
    IE pr=Binary(&Nmc);
    pr.Print();
}
int main()
{
    One.Dat[1]=1;
    scanf("%d",&T);
    while(T--)
        IA();
    return 0;
}

```

---

## 作者：FurippuWRY (赞：0)

题意：有一数列 $\{a_i\}$，通项公式为：
$$a_i=\begin{cases}0,i=0\\1,i=1\\a_\frac{i}{2},i \bmod 2=0\\a_\frac{i+1}{2}+a_\frac{i-1}{2},i \bmod 2 = 1\end{cases}$$
现有一数 $n$，求 $a_n$。

------------

看见 $n\in[1,10^{100}]$，C 艹党一口老血，不如 Python，直接代入进去算就行了。

```python
t = int(input())

while t > 0 :
    a = 1
    b = 0
    n = int(input())
    while n > 0 :
        if (n % 2 == 0) : a += b
        else : b += a
        n //= 2
    t -= 1
    print(b)

```
此段代码的意思就相当于：
```cpp
#include <bits/stdc++.h>

using namespace std;

int n, t;

int main() {
	cin >> t;
	while (t--) {
		cin >> n;
		int a = 1, b = 0;
		while (n) {
			if (n % 2 == 0) a += b;
			else b += a;
			n /= 2;
		}
		cout << b << '\n';
	}
   return 0;
}
```

当然，这坨 C++ 代码是过不了这题的，会爆，要想用 C++ 过这题就老老实实打高精罢。

警钟：用递归会超时。

---

## 作者：expecto__patronum (赞：0)

## 思路：
说实话，我觉得好迷。。

胡乱推了推没搞出来。。

发现直接暴力记搜就可以了，发现每层出现的不一样的数非常少，是常数级别的

我们可以直接高精，记搜用个 map 搞一搞。

对应数据组数,比较或者运算复杂度，map 的复杂度和运算次数。
## Code:
```
#include <cstdio>
#include <cstring>
#include <map>
using namespace std;
const int N=102;
struct l_num
{
    int num[N];
    l_num()
    {
        memset(num,0,sizeof(num));
    }
    l_num(char c[])
    {
        memset(num,0,sizeof(num));
        num[0]=strlen(c);
        for(int i=1;i<=num[0];i++)
            num[i]=c[num[0]-i]-'0';
    }
    bool friend operator <(l_num n1,l_num n2)
    {
        if(n1.num[0]==n2.num[0])
        {
            int pos=n1.num[0];
            while(pos&&n1.num[pos]==n2.num[pos]) --pos;
            return n1.num[pos]<n2.num[pos];
        }
        return n1.num[0]<n2.num[0];
    }
    l_num friend operator /(l_num n,int k)
    {
        for(int i=n.num[0];i>1;i--)
        {
            if(n.num[i]&1) n.num[i-1]+=10;
            n.num[i]>>=1;
        }
        n.num[1]>>=1;
        n.num[1]+=k;
        if(!n.num[n.num[0]]) --n.num[0];
        return n;
    }
    l_num friend operator +(l_num n1,l_num n2)
    {
        l_num n3;
        n3.num[0]=max(n1.num[0],n2.num[0]);
        for(int i=1;i<=n3.num[0];i++)
        {
            n3.num[i]+=n1.num[i]+n2.num[i];
            n3.num[i+1]=n3.num[i]/10;
            n3.num[i]%=10;
        }
        if(n3.num[n3.num[0]+1]) ++n3.num[0];
        return n3;
    }
}zero,one;
map <l_num,l_num> a;
l_num dfs(l_num k)
{
    if(!k.num[0]) return zero;
    if(k.num[0]==1&&k.num[1]==1) return one;
    if(a.find(k)!=a.end()) return a[k];
    if(k.num[1]&1) a[k]=dfs(k/0)+dfs(k/1);
    else a[k]=dfs(k/0);
    return a[k];
}
int main()
{
    int t;char s[N];
    scanf("%d",&t);
    one.num[0]=one.num[1]=1;
    zero.num[0]=0;
    while(t--)
    {
        scanf("%s",s);
        l_num rk(s);
        l_num ans=dfs(rk);
        for(int i=ans.num[0];i;i--)
            printf("%d",ans.num[i]);
        printf("\n");
    }
    return 0;
}
```
[博客](https://blog.csdn.net/weixin_30426879/article/details/99305625)

---

## 作者：xwh_hh (赞：0)

这题难度标签有问题吧，一个记搜就过了……

现在我们来讲解法。  
这题要高精度！  
按照题目所说的，写一个记搜，保存结果用 `STL::map`，过了。

我们来分析一下，为什么记搜能过。  
显然，$a_{2i}+a_{2i+1}=2a_i+a_{i+1}$，$a_{2i-1}+a_{2i}=2a_i+a_{i-1}$，这样一次转移就会使数据规模缩小一半，只需 $\log n$ 级别的转移次数即可将规模缩小至 $0,1$，单次转移是 $O(1)$ 的，但每次记录答案是 $O(\log n)$ 的，总复杂度是 $O(\log^2n)$ 的，水过。  
代码：  
```cpp
#include<bits/stdc++.h>
using namespace std;
struct Bigint{//高精度模板 
	int a[105];
	Bigint(){
		memset(a,0,sizeof(a));
	}
	Bigint(int u){
		memset(a,0,sizeof(a));
		a[0]=u/1%10;
		a[1]=u/10%10;
		a[2]=u/100%10;
		a[3]=u/1000%10;
		a[4]=u/10000%10;
		a[5]=u/100000%10;
		a[6]=u/1000000%10;
		a[7]=u/10000000%10;
		a[8]=u/100000000%10;
		a[9]=u/1000000000%10;
	}
	bool mod2(){ return a[0]%2; }
	void div2(){// 除以2 
		for(int i=104;i>=0;i--){
			if(i&&a[i]%2) a[i-1]+=10;
			a[i]/=2;
		}
	}
	Bigint operator+(const Bigint &k)const{//加 
		Bigint c;
		for(int i=0;i<=103;i++){
			c.a[i]+=a[i]+k.a[i];
			c.a[i+1]+=c.a[i]/10;
			c.a[i]%=10;
		}
		return c;
	}
	void input(){//输入 
		string s;
		cin>>s;
		for(int i=s.length()-1,j=0;i>=0;i--,j++){
			a[j]=s[i]-'0';
		}
	}
	void output(){//输出 
		int u=0;
		for(int i=104;i>=0;i--){
			if(a[i]!=0) u=1;
			if(u) cout<<a[i];
		}
	}
	bool operator>(const Bigint &d)const{//比较 
		for(int i=104;i>=0;i--){
			if(a[i]!=d.a[i]) return a[i]>d.a[i];
		}
		return false;
	}
	bool operator==(const Bigint &d)const{
		for(int i=104;i>=0;i--){
			if(a[i]!=d.a[i]) return false;
		}
		return true;
	}
	bool operator<(const Bigint &d)const{
		for(int i=104;i>=0;i--){
			if(a[i]!=d.a[i]) return a[i]<d.a[i];
		}
		return false;
	}
}; 
map<Bigint,Bigint>mp;//存储 
Bigint dfs(Bigint k){
	if(k<Bigint(2)) return mp[k]=k;
	if(mp.find(k)!=mp.end()) return mp[k];//已存在 
	Bigint u=k;
	u.div2();
	if(k.mod2()) return mp[k]=dfs(u)+dfs(u+Bigint(1));//模拟 
	return mp[k]=dfs(u);
}
int main(){ 
	int t;
	cin>>t;
	while(t--){
		Bigint n;
		n.input();
		Bigint t=dfs(n);
		t.output();		
		putchar('\n');
	}
	return 0;
}
```

---

## 作者：404Not_Found (赞：0)

py 萌萌题。

题意：给定数列 $\{a_i\}$  满足

$$a_n=\begin{cases}
0 & n=0\\
1&n=1\\
a_{\frac{n}{2}} & n \equiv0 \pmod 2\\

a_{\frac{n-1}{2}}+a_{\frac{n+1}{2}} & n \equiv 1 \pmod 2
\end{cases}$$

求 $a_n$。

手玩一下可以发现每个 $a_n$ 都可以写成 $x \times a_0+y \times a_1$ 的形式，显然我们只要求出 $y$ 就行了。

考虑分治，加入我们要求 $x \times a_i+y \times a_{i+1}$，分类讨论一下：

+ 若 $i$ 为偶数

带入递推式就有

$$x \times a_i+y \times a_{i+1}=x \times a_{\frac{n}{2}}+y \times (a_{\frac{n}{2}}+a_{\frac{n}{2}+1})$$
$$= (x+y)  \times a_{\frac{n}{2}}+y \times a_{\frac{n}{2}+1}$$

+  若 $i$ 为奇数


同理有

$$x \times a_i + y \times a_{i+1}=x \times a_{\frac{i-1}{2}}+(x+y) \times a_{\frac{i+1}{2}}$$

最后的答案显然是 $1 \times a_n+0 \times a_{n+1}$，然后就做完了。

时间复杂度：$\mathcal{O}(T \log n)$。高精直接无脑 py。

```python
T = int(input())
for i in range(T) :
    n = int(input())
    x = 1
    y = 0
    while n > 0 :
        if n % 2 == 0 :
            x = x + y
        else :
            y = x + y
        n = n // 2
    print(y)

```


---

## 作者：Φρανκ (赞：0)

题意：求满足 $a_0=0,a_1=1,a_{2i}=a_i,a_{2i+1}=a_i+a_{i+1}$ 的数列的第 $n$ 项。

核心思想：二分

解：

注意到 $a_{2i+1}=a_{2i}+a_{2i+2}$ 且 $a_{2i}=a_i$ ，可知对于数列的前 $2^i+1$ 项，在其中相邻两项之间各插入一项这两项的和即得数列的前 $2^{i+1}+1$ 项。如下图：

|0|1|1|2|1|3|2|3|1|4|3|5|2|5|3|4|1|
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
|0|  |1|  |1|  |2|  |1|  |3|  |2|  |3|  |1|
|0|  |  |  |1|  |  |  |1|  |  |  |2|  |  |  |1|
|0|  |  |  |  |  |  |  |1|  |  |  |  |  |  |  |1|
|0|  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |1|


因此，只要首先将所求项项数除去所有 $2$ 因子并二分即可。

二分具体方法如下：

初始左右端点位置为 $0,2$ ，左右值为 $0,1$ ，二分后端点位置改变的一侧的值变为两侧值的和，直到区间大小缩到 $2$ 为止。由于预处理过后 $n$ 为奇数，所求值就是区间两侧值的和。以求 $a_{11}$ 为例：

|0|1|1|2|1|3|2|3|1|4|3| _5_ |2|5|3|4|1|
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
|0|  |1|  |1|  |2|  |1|  |**3**|  |**2**|  |3|  |1|
|0|  |  |  |1|  |  |  |**1**|  |  |  |**2**|  |  |  |1|
|0|  |  |  |  |  |  |  |**1**|  |  |  |  |  |  |  |**1**|
|**0**|  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |**1**|

下面每行加粗的数字是每次二分开始时区间两端的值，第一行的斜体数字是结果。

包括位置和取值在内的所有运算都需要高精。共需要实现高精比较，高精乘低精，高精除低精，高精加高精几种操作。

代码：
```
#include <bits/stdc++.h>
using namespace std;
long long a[1001][4], t, l[101], r[101], flag;
//a[i][1]为n，a[i][2]与a[i][3]分别为区间左右端点位置
char ch[1001];
long long cmp(long long x, long long y)
{
	for(int in=1000; in>=0; in--)
		if(a[in][x]>a[in][y])
			return x;
		else if(a[in][x]<a[in][y])
			return y;
	return 10;
}//高精比较
int main()
{
	cin>>t;
	for(int i=1; i<=t; i++)
	{
		memset(ch, 0, sizeof(ch));
		for(int j=0; j<=1000; j++)
			for(int k=0; k<=3; k++)
				a[j][k]=0;
		cin>>ch+1;
		for(int j=strlen(ch+1); j>=1; j--)
			a[strlen(ch+1)-j][1]=ch[j]-48;
		a[0][3]=2;
		memset(l, 0, sizeof(l));
		memset(r, 0, sizeof(r));
		r[0]=1;//初始化输入
		while(a[0][1]%2==0)
		{
			for(int j=1000; j>0; j--)
			{
				a[j-1][1]+=10*(a[j][1]%2);
				a[j][1]/=2;
			}
			a[0][1]/=2;
		}//将n除去所有2
		while(cmp(1, 3)==1)
		{
			for(int j=0; j<=1000; j++)
				a[j][3]*=2;
			for(int j=0; j<=1000; j++)
			{
				a[j+1][3]+=a[j][3]/10;
				a[j][3]%=10;
			}
		}//确定区间右端点上界
		while(1)
		{
			for(int j=0; j<=1000; j++)
				a[j][0]=a[j][2]+a[j][3];
			for(int j=0; j<=1000; j++)
			{
				a[j+1][0]+=a[j][0]/10;
				a[j][0]%=10;
			}
			for(int j=1000; j>0; j--)
			{
				a[j-1][0]+=10*(a[j][0]%2);
				a[j][0]/=2;
			}
			a[0][0]/=2;//计算区间中点
			if(cmp(0, 1)==10)
			{
				for(int j=0; j<=100; j++)
					l[j]+=r[j];
				for(int j=0; j<=100; j++)
				{
					l[j+1]+=l[j]/10;
					l[j]%=10;
				}
				flag=0;
				for(int j=100; j>=0; j--)
				{
					if(l[j]!=0)
						flag=1;
					if(flag!=0)
						cout<<l[j];
				}
				cout<<endl;
				break;
			}//n恰在中点处（除非区间长度为2，否则中点必然为偶数）
			else if(cmp(0, 1)==0)
			{
				for(int j=0; j<=1000; j++)
					a[j][3]=a[j][0];
				for(int j=0; j<=100; j++)
					r[j]+=l[j];
				for(int j=0; j<=100; j++)
				{
					r[j+1]+=r[j]/10;
					r[j]%=10;
				}
			}//n在中点左侧
			else
			{
				for(int j=0; j<=1000; j++)
					a[j][2]=a[j][0];
				for(int j=0; j<=100; j++)
					l[j]+=r[j];
				for(int j=0; j<=100; j++)
				{
					l[j+1]+=l[j]/10;
					l[j]%=10;
				}
			}//n在中点右侧
		}
	}
	return 0;
}

```

---

## 作者：OI_AKed_me (赞：0)

这道题题解区有不少神仙做法，然而蒟蒻我并不太能理解，但好在这道题可以使用记忆化搜索水过。

根据题意，递归求解，判重可以使用 ```map```，然后就有了 $50$ 分做法如下

```cpp
ll work(ll n){
	if(n==1) return 1;
	if(mp[n]) return mp[n];
	while(n%2==0&&n) n/=2;
	if(!n) return 0;
	return mp[n]=work(n/2)+work(n/2+1);
}
```

然后再把 ```long long``` 替换成高精，或者使用 python，就可以得到满分了，单次复杂度约为 $O(\log n)$。

---

## 作者：jijidawang (赞：0)

~~如何秒掉 ZJOI（详细揭秘）~~

首先因为需要高精所以选择 Python .

根本不用管题目里说的东西，直接暴力模拟：
```python
def f(n):
	if n < 2:
		return n
	ans = f(n // 2)
	if n % 2:
		ans = ans + f(n // 2 + 1)
	return ans 
```

然而这样递归复杂度是有问题的，然而我们知道 Python 里有个东西叫做 LRUCache .

简单介绍一下 LRU Cache 大概就是对要记忆化的东的 Hash 开一个双向链表，然后查询一个东西就把它提到链表头，如果加东西空间不够了就丢掉链表尾 .

此处这个链表尾其实就是 LRU 元素（Least Recently Used，最近最少使用），我们根据实际经验看这个元素的应用次数是比较少的于是丢掉会更优 .

当然如果这个空间很足的话就等价于记忆化搜索

用法见代码：
```python
import functools

@functools.lru_cache(114514)
def f(n):
	if n < 2:
		return n
	ans = f(n // 2)
	if n % 2:
		ans = ans + f(n // 2 + 1)
	return ans 

T = int(input()) 

for i in range(0, T):
	n = int(input())
	print(f(n))
```

`@functools.lru_cache(114514)` 表示 `f` 需要 LRU Cache 帮忙记忆化，大小是 114514 .

当然这题比较水，大小直接拉满（即 `@functools.lru_cache()`）也能过 .


习题：[P1464 Function](https://www.luogu.com.cn/problem/P1464)，需要手动设置 LRU Cache 大小 .

~~当然 CCF 是不把 Python 当作竞赛语言的~~

---

## 作者：Fa_Nanf1204 (赞：0)

# python 写高精好！！！
题意简述：有一个序列 $a_i$，给出了 $a_i$ 的通项公式。给定一个 $n$，要求输出 $a_n$。
- - -
## 分析
通过分析通项公式，我们可以得到四种情况。
$$ \large\ a_i \ = \begin{cases} 0 & i = 0 \\ 1 & i = 1 \\ a_\frac{n}{2} & i \; \bmod\; 2 \;=\;0 \\ a_\frac{n+1}{2} + a_\frac{n-1}{2} & i \; \bmod \; 2\; = \; 1 \end{cases}$$
所以我们可以从 $a_n$ 一直推到 $a_1$，用 $l$ 和 $r$ 分别记录后两种情况的值，最后输出 $r$ 即可。
- - -
最后再来看一下数据范围：$n\le 10^{100}$，所以用 python 水过高精度。
- - -
## Code
```python
from decimal import *
getcontext().prec=10000000#防止代码RE 
t=int(input())
for i in range(1,t+1):
    n=int(input())#t组输入 
    l=1
    r=0
    while n>=1:
        if n%2==0:#模拟通项过程 
            l=l+r
        else:
            r=l+r
        n//=2
    print(r)#输出 
```
- - -
本新手第一次写题解，望谅解。

---

## 作者：huayt (赞：0)

# 题目描述
给定一个数列满足 $a_0=0,a_1=1,a_{2i}=a_i,a_{2i+1}=a_i+a_{i+1}$

给出正整数 $n$，求数列第 $n$ 项的值。

# 分析
设函数 $f(x)$表示数列中第 $x$ 项的值 $(x\in N_+)$。
则题目条件转化为：

$
f(x)=
\begin{cases}
f(\frac{x}{2})&x\%2=0\\
f(\frac{x-1}{2})+f(\frac{x+1}{2})&x\%2=1\\
\end{cases}
$

且 $f(0)=0,f(1)=1$。


定义 $x\times f(n)+y\times f(n+1)$ 为**原式**，对于两种情况**分类讨论**。
- 若 $n$ 为偶数，$n=2t$ 

依题意得 

$f(n)=f(t),f(n+1)=f(2t+1)=f(t)+f(t+1)$

则 

$x\times f(n)+y\times f(n+1)=x\times f(t)+y\times f(t)+y\times f(t+1)$

根据乘法分配律得

$x\times f(n)+y\times f(n+1)=(x+y)\times f(t)+y\times f(t+1)$

- 若 $n$ 为奇数，$n=2t+1$

依题意得 

$f(n)=f(t)+f(t+1),f(n+1)=f(2t+2)=f(t+1)$

则 

$x\times f(n)+y\times f(n+1)=x\times f(t)+x\times f(t+1)+y\times f(t+1)$

根据乘法分配律得

$x\times f(n)+y\times f(n+1)=x\times f(t)+(x+y)\times f(t+1)$

可得以上两种情况的结果都与**原式形式**无异。
则令 $n=t=\lfloor \frac{n}{2}\rfloor$，更新 $x,y$ 的值，重复以上过程（在程序中为递归过程）。

直到 $n=0$，有**原式** $=x\times f(0)+y\times f(1)=y$，此时 $y$ 即为答案。**时间复杂度**为 $O(Tlogn)$。

题目要求 $f(n)$ 的值，即 $1\times f(n)+0\times f(n+1)$，所以**初始化** $x=1,y=0$。 

# 代码
~~因为本人不喜欢 string，~~ 高精用 vector 重载运算符，如不习惯请见谅（递归部分会给注释）。
```cpp
#include<iostream>
#include<cstdio>
#include<vector>
#include<cstring>

using namespace std;
const int N=105;
int A[N],B[N],C[N];
int T;

vector<char> operator +(vector<char> a,vector<char> b){
	int i;
	int lena=0,lenb=0,lenc=1,x=0;
	memset(A,0,sizeof(A));
	memset(B,0,sizeof(B));
	memset(C,0,sizeof(C));
	for(i=a.size()-1;i>=0;i--) A[++lena]=a[i]-'0';
	for(i=b.size()-1;i>=0;i--) B[++lenb]=b[i]-'0';
	while(lenc<=lena||lenc<=lenb){
		C[lenc]=A[lenc]+B[lenc]+x;
		x=C[lenc]/10;
		C[lenc]%=10;
		lenc++;
	}
	C[lenc]=x;
	while(C[lenc]==0&&lenc>1) lenc--;
	vector<char> res;
	for(i=lenc;i>=1;i--) res.push_back(C[i]+'0');
	return res;
}

vector<char> operator /(vector<char> a,int b){
	int i;
	int lena=0,lenc=0,x=0;
	memset(A,0,sizeof(A));
	memset(C,0,sizeof(C));
	for(i=a.size()-1;i>=0;i--) A[++lena]=a[i]-'0';
	for(i=lena;i>=1;i--){
		x=x*10+A[i];
		C[++lenc]=x/b;
		x%=b;
	}
	int tmp=1;
	while(C[tmp]==0&&tmp<lenc) tmp++;
	vector<char> res;
	for(i=tmp;i<=lenc;i++) res.push_back(C[i]+'0');
	return res;
}

void Dfs(vector<char> n,vector<char> &x,vector<char> &y){
	if(n.size()==1&&n.back()=='0') return;
   		//判断n是否为零
	if(int(n[n.size()-1]-'0')&1) y=y+x;
    		//如果n为奇数
	else x=x+y;
    		//如果n为偶数
	Dfs(n/2,x,y);
    		//令n=t，递归调用
	return;
}

int main(){
	scanf("%d",&T);
	while(T--){
		vector<char> x,y,n;
		char ch=getchar();
		while(!isdigit(ch)) ch=getchar();
		while(isdigit(ch)) n.push_back(ch),ch=getchar();
		x.push_back('1');y.push_back('0');
		Dfs(n,x,y);
		int i;
		for(i=0;i<y.size();i++) putchar(y[i]);
		puts("");
	}
	return 0;
}
```

---

## 作者：Sino_E (赞：0)

可以观察到dfs树的最大层数差不多就是$log\ n$乘以某个常数了。

所以基本思路就是dfs套个记忆化搜索直接暴力求。节点数讲道理不会很多。大概在$(log\ n)^2$左右乘个常数$k$。总结点数也就是$Tk(log\ n)^2$。也就是总的时间复杂度。

但是这玩意要高精，以及怎么记忆化是个问题。

最辣鸡的解决方法是写高精度结构体，重载<以及==号，然后用map储存...

大概是最慢代码（300ms+）...虽然能过\_(:зゝ∠)_

```cpp
// Code by ajcxsu
// Problem: sequence

#include<bits/stdc++.h>
using namespace std;

const int N=300;

struct BIGNUM {
    int a[N],len;
    BIGNUM() { memset(a,0,sizeof(a)); len=0; }
    BIGNUM operator = (int x) {
        memset(a,0,sizeof(a)), len=0;
        if(!x) len=1;
        while(x) {
            a[len++]=x%10;
            x/=10;
        }
        return *this;
    }
    BIGNUM operator = (string &x) {
        memset(a,0,sizeof(a)), len=0;
        len=x.size();
        for(int i=len-1;i>=0;i--) a[len-1-i]=x[i]-'0';
        return *this;
    }
    BIGNUM (int x) { *this=x; }
    BIGNUM operator +(const BIGNUM &b) {
        BIGNUM c;
        int t=0;
        while(c.len<len || c.len<b.len) {
            c.a[c.len]=a[c.len]+b.a[c.len]+t;
            t=0;
            if(c.a[c.len]>=10) t++, c.a[c.len]-=10;
            c.len++;
        }
        if(t) c.a[c.len++]=t;
        return c;
    }
    BIGNUM operator +(const int x) {
        return *this+BIGNUM(x);
    }
    BIGNUM operator -(const int x) {
        BIGNUM c;
        c.a[c.len++]=a[0]-x;
        while(c.len<=len) {
            if(c.a[c.len-1]<0) c.a[c.len-1]+=10, c.a[c.len]-=1;
            c.a[c.len]+=a[c.len];
            c.len++;
        }
        while(!c.a[c.len-1]) c.len--;
        return c;
    }
    BIGNUM operator /(const int x) {
        BIGNUM c;
        int num=0;
        bool first=1;
        for(int i=len-1;i>=0;i--) {
            num=num*10+a[i];
            if(num>=x) {
                if(first) c.len=i+1, first=0;
                c.a[i]=num/x;
                num%=x;
            }
        }
        return c;
    }
    friend bool operator <(const BIGNUM &y, const BIGNUM &x) {
        if(x.len!=y.len) return y.len<x.len;
        for(int i=0;i<y.len;i++)
            if(x.a[i]!=y.a[i]) return y.a[i]<x.a[i];
        return 0;
    }
    friend bool operator ==(const BIGNUM &y, const BIGNUM &x) {
        if(x.len!=y.len) return 0;
        for(int i=0;i<y.len;i++)
            if(x.a[i]!=y.a[i]) return 0;
        return 1;
    }
} ;
typedef BIGNUM ll;
map<ll,ll> f;

istream& operator >> (istream &in, BIGNUM &x) {
    string nu;
    in>>nu;
    x=nu;
    return in;
}

ostream& operator << (ostream &out, const BIGNUM &x) {
    string nu;
    for(int i=0;i<x.len;i++) nu+='0'+x.a[i];
    int i=0, j=x.len-1;
    while(i<j) swap(nu[i++],nu[j--]);
    out<<nu;
    return out;
}

ll dfs(ll x) {
    if(x.a[0]==1 && x.len==1) return 1;
    if(x.a[0]==0 && x.len==1) return 0;
    if(f.count(x)) return f[x];
    if(x.a[0]&1) f[x]=dfs((x+1)/2-1)+dfs((x+1)/2);
    else f[x]=dfs(x/2);
    return f[x];
}


int main() {
    int T;
    cin>>T;
    while(T--) {
        ll n;
        cin>>n;
        cout<<dfs(n)<<endl;
    }
    return 0;
}
```



---


# 签到题 III

## 题目背景

pj组选手zzq近日学会了求最大公约数的辗转相除法。


## 题目描述

类比辗转相除法，zzq定义了一个奇怪的函数：

```cpp
typedef long long ll;
ll f(ll a,ll b)
{
    if(a==b) return 0;
    if(a>b) return f(a-b,b+b)+1;
    else return f(a+a,b-a)+1;
}
```
zzq定义完这个函数兴高采烈，随便输入了两个数，打算计算f值，发现这个函数死循环了...于是zzq定义这个函数递归死循环的情况下f值为0。

现在zzq输入了一个数n，想要求出$\sum_{i=1}^n \sum_{j=1}^n f(i,j)$。


## 说明/提示

对于10%的数据，$n \leq 300$。

对于40%的数据，$n \leq 2000$。

对于70%的数据，$n \leq 5 \times 10^5$。

对于100%的数据，$1 \leq n \leq 5 \times 10^{11}$。


## 样例 #1

### 输入

```
100```

### 输出

```
1124```

## 样例 #2

### 输入

```
2000```

### 输出

```
68204```

# 题解

## 作者：s_h_y (赞：14)

听说没人证出、、其实dalao们都是懒得证或者懒得说吧。。


证：当且仅当$ i+j=2^{k+1} $且$ (i,j)=1 $时，$ f(i,j)=k $；其余情况$ f(i,j)=0 $。


一些引理：

$ f(\lambda a,\lambda b)=f(a,b)\ \ \ \ (\lambda>0) $

$ f(a,b)=f(b,a) $


必要性证明：当$ i+j=2^{k+1} $且$ (i,j)=1 $时，$ f(i,j)=k $。

不妨设$ i>j $，因为$ i,j $互质则有$ i,j $都是奇数。

$ f(i,j)=f(i-j,2j)+1=f(\frac{i-j}{2},j)+1 $

因为$ (i,j)=1 $，所以$ (i-j,j)=1=(\frac{i-j}{2},j) $。

这是一个递归的过程，不同的是，$ i+j=2^{k+1}，\frac{i-j}{2}+j=2^{k}$。

故终止时为$ f(a,b)|a+b=2^{1}=2 $，即$ f(i,j)=f(1,1)+k=k $。


充分性证明：当$ i+j≠2^{k} $且$ (i,j)=1 $时，$ f(i,j)=0 $。

$ (1)i+j=s≡1(mod\ 2) $

因为$ (i,j)=1 $则$ i,j $一奇一偶，

若$ i>j,f(i,j)=f(i-j,2j);$

若$ i<j,f(i,j)=f(2i,j-i);$

因为$ (i-j,2j) $或$ (2i,j-i) $仍然满足一奇一偶$(≠)$且和为$\frac{s}{gcd(i-j,2j)}$或$\frac{s}{gcd(2i,j-i)}($不可能为$2^{k})$，则其永远无法到达终止状态。

故$ f(i,j)=0 $。

$ (2)i+j=2^{t}·s≡0(mod\ 2) $

令$ i>j $，则有$ f(i,j)=f(i-j,2j)=f(\frac{i-j}{2},j) $。

而$ \frac{i-j}{2}+j=\frac{i+j}{2}=2^{t-1}·s $,

故其可以在有限步递归内转换为$ i+j=s≡1(mod\ 2) $即第$(1)$种情况。

故$ f(i,j)=0 $。


综上得证。


###证by shyakocat



有了这个，我们容易知道公式

$$ Ans=\sum_{i=1,i≡1(mod\ 2)}^{n}\lceil log_{2}(i) \rceil \lfloor \frac{n}{i} \rfloor $$

就是对每个i考虑$ 1<j<i $且$ i+j=2^{k} $且$ (i,j)=1 $，这样的j显然有且仅有1个。再算上倍数即可。

由于很多i的答案一样，可以合并下，时间复杂度$ O(\sqrt[]{N}+log(N)) $。



```cpp
var
 n,i,j,a,b,ans:int64;

function min(const a,b:int64):int64;
begin if a>b then exit(b); exit(a) end;

begin
 read(n);
 i:=1;
 while i<=n do
 begin
  a:=n div i;
  b:=trunc(ln(i)/ln(2)+1e-7);
  j:=min(n div a,int64(1)<<(b+1));
  inc(ans,a*b*((j-i+1+j and 1)>>1));
  i:=j+1
 end;
 write(ans*2)
end.
```

---

## 作者：PosVII (赞：6)

**前言**

------------

此题重在推理。谢谢审核员详细指出了我的格式错误！

**分段打草稿**

------------

简单可得 $f(a,b) = f(\min(a,b) \times 2,\left\vert a-b\right\vert)$ 并且 $f(ma,mb) = f(a,b)$。

那么我们只需要研究互质的 $a$ 和 $b$ 即可。

$f(a,b)$ 最令我们困扰的应该是 $a$ 和 $b$ 的大小关系。

于是我们设 $f(a,b)$ 一定保证 $a \leq b$，那么我们可以进行分段，如下。

1. $1$ 即 $\min (a,b) \times 2< \left\vert a-b\right\vert$。
1. 而 $2$ 即 $\min(a,b)\times 2=\left\vert a-b\right\vert$。
1. $3$ 即 $\min(a,b) \times 2>\left\vert a-b\right\vert$。

$
f(a,b)
\begin{cases}
1:f(2a,b-a)
	\begin{cases}
	1:f(4a,b-3a)
  		\begin{cases}
		1:f(8a,b-7a)
		\\2:2
		\\3:f(b-7a,8a)
		\end{cases}
	\\2:1
	\\3:f(b-3a,4a)
  		\begin{cases}
		1:f(2b-6a,b+7a)
		\\2:2
		\\3:f(b+7a,2b-6a)
		\end{cases}
	\end{cases}
\\2:0
\\3:f(b-a,2a)
	\begin{cases}
    1:f(2b-2a,3a-b)
  	 	\begin{cases}
		1:f(4b-4a,5a-3b)
		\\2:2
		\\3:f(5a-3b,4b-4a)
		\end{cases}
    \\2:1
    \\3:f(3a-b,2b-2a)
    \begin{cases}
		1:f(6a-2b,3b-5a)
		\\2:2
		\\3:f(3b-5a,6a-2b)
		\end{cases}
    \end{cases}
\end{cases}
$

当 $f(a,b)$ 一直以第一种情况进行递归时，我们发现当出现二情况时，可以得到一个式子。

$(2^{x}-1) \times a = b$

$a+b=2^{x} \times a$

那么当 $a+b=2^x$ 时 $f(a,b)=x-1$

我们也可以通过下面的式子得出，当 $a$，$b$ 都是奇数的倍数时，$f(a,b)$ 将得到值。

我们可以猜测，反之则会陷入死循环。

我们针对 $a$，$b$ 都是奇数的情况进行推导。

$f(a,b)=f(2a,b-a)$ 

而 $2a$，$b-a$ 都是偶数。

那么 $f(a,b)$ 可以化为 $f(a,(b-a) \div 2)$

此时 $a+(b-a) \div 2 = (a+b) \div 2$

若是一直转化，最终会出现 $(a+b) \div 2^x$ 的形式。而我们又保证 $f(a,b)$ 有解。

也就是满足 $a<b$ 且 $a+b = 2^x$ 且 $a,b \mod 2 = 1$ 时，$f(a,b)=x-1$。 

我们可以枚举 $b$，然后再找对应的 $a$，可以发现每个 $b$ 对应的 $a$ 只有一个。

我们只需要把所有互质的 $a$，$b$ 的值找到，我们就可以用开头的公式求出其他的  $a$，$b$ 不互质的值。对于每一个 $f(a,b)$，它能得到 $\left\lfloor\dfrac{n}{b}\right\rfloor$ 个不同的 $f(ma,mb)$。

如何快速求 $a$ 的值呢？我们可以发现可行的 $a$，$b$ 都比较接近。

那么我就瞎搞一个，让 $f(a,b)=f(2^x-s,2^x+s)$ 我们发现这两个数是互质的。

那么 $x=\left\lfloor \log_2(b)\right\rfloor$。

$O(n)$ 做法 $70pts$

**优化**

------------

想到了一种思路，$f(a,b)$ 有一些重复的值，也就是说我们可以把 $\left\lfloor\dfrac{n}{b}\right\rfloor$ 与 $\left\lfloor \log_2(b)\right\rfloor$ 的值把 $[1,n]$ 分成一个一个的小区间。有的端是由 $\left\lfloor\dfrac{n}{b}\right\rfloor$ 的变化产生的，有的则是另一个。

我们就可以快速计算了，两个量分别有 $\sqrt n$ 与 $\log_2(n)$ 大，最大会分成 $\sqrt n + \log_2(n)$ 个区间，而区间的计算可以 $O(1)$ 得到。

但是很抱歉，我查了wiki，这种思路叫做分块，但我还没学到，所以看了眼题解，发现都用的这种方法，所以我的最终代码并不算我自己想出的。所以我写这篇题解，希望补充一下大佬们的题解。

---

## 作者：kczno1 (赞：6)

我想试着证明一下，当x+y=2^p时，答案=p-1。

(其实我发现这个是手动广搜出来的)

用归纳法。

当x=y=1时，显然。

否则
因为和是偶数，gcd=1，所以两个人都是奇数。

设x<y。

那么x,y会变成x\*2,y-x

可以除一个2,变成x,(y-x)/2

那么x+y就少了一半。

所以得证。


---

## 作者：Jμdge (赞：2)

肉眼观察可得：

1. 当 $i+j = 2^{k+1} $ 时，$f(i,j)=k$，否则 $f(i,j)=0$ ，（i、j 已除去 $gcd$）

2. $f(i,j) = f({i\over gcd(i,j)},{j\over gcd(i,j)})$

首先我们考虑 i，j 的和必然是 2 的倍数，不然 f 函数无法将 i+j 平等分成两份，于是就死循环了

然后再证明 $i+j$ 必须是 2 的幂次

首先令 i<j （注意如果 i=j， f 的值为 0， 可忽略），并且除去了它们的 gcd ，那么此时 i、 j 均为**奇数**，再令$ i+j=2^t·k$ ，k 为 奇数

那么 $f(i,j) = f(2*i,j-i)=f(i,{j-i \over 2})$

那么除去 2 后的两个数之和 为 $2^{t-1}·k$ ，迭代以上步骤，最终可以得到： i'+j'=k ， 此时 f 死循环

所以说 $i+j$ 是 2 的幂次时 f 不为 0

那么 f(i,j) 的值为什么是 k 呢？这个嘛我们考虑：

#### i 、j 这两个数每次进行 f 操作后都能且仅能除以 2 

能除以 2 上面有过解释，仅能除以 2 是为什么？ 我们考虑它是否可以除以 2 的更高次幂 

由于 i、j 除去了 $gcd$ ，那么 $gcd(i~,~j)=1$ ，于是 $gcd(i ~,~ j-i)=1$ ，那么 i 乘上 2 其实就是 f 的递归操作 $(2*i,j-i)$

那么由于 $j-i$ 为偶数，所以有 $gcd(2*i,j-i)$ 为 2 的倍数（即 $2|(2*i,j-i)$）

那么除去 2 后就是 $(i,{j-i\over 2})$

又因为 $gcd(i,j-i)=1$，后面的数除去 2 后两者仍然互质

所以我们可以得到结论： $i , j=2^{k+1}$ 时，它们经过 k 次变换可以结束递归，即 $f(i,j)=k$ 




那么答案的计算？


$$ANS=\sum_{i\%2=1} \lfloor \log_{2}^{~i}\rfloor \lfloor {n\over i}\rfloor $$

#### 注意这里的 $log_{2}^{~i}$ 向下取整！别被其他题解骗了

上式的含义其实就是对于每个奇数 i 我们找到小于它的 j 使它们的和为 2 的幂次，这样的 j 只有 1 个（且和 i 相加后和为大于 i 的最小的 2 的幂次）

然后我们算的是除去 gcd 后的答案，还要乘回去

但这样的算法是 $O(n)$ 的，不够优秀，我们考虑后面的是整除，用用类似数论分块的芝士就可以得出 $n\over i$ 的取值是 $O(\sqrt n)$ 的

于是这道题就可以解决了，复杂度为根号 n

```
//by Judge
#include<cmath>
#include<cstdio>
#include<iostream>
#define ll long long
using namespace std;
ll n,x,y;
int main(){ cin>>n;
	x=floor(log2(n))/2, //先取 log 再除以二，也可以先开方再取 log
	y=n/((1ll<<x+1)+1); // 等价于取根号 n ，写得太骚
	ll z=(1ll<<x)-1,ans=0;
	for(int i=1;i<=x;++i) //考虑前 根号 n
		for(int j=1ll<<i-1,k=j<<1;j<k;++j)
			ans+=n/(j<<1|1)*i;
	++x;
	for(;y;){ //要综合考虑 log(i) 和 n/i  的取值
		if(n/((1ll<<x+1)-1)==y){
			ans+=x*y*((1ll<<x)-1-z);
			z=(1ll<<x)-1,++x;
		} else{
			ll zz=n/y-1>>1;
			ans+=x*y*(zz-z);
			--y,z=zz;
		}
	} return !printf("%lld\n",ans<<1);
}
```





---

## 作者：OrientDragon (赞：1)

# 题目大意
定义 $f(a,b)=\begin{cases}f(a-b,2b)+1,&a>b\\f(2a,b-a)+1,&a<b\\0,&a=b\,或无解\end{cases}$，

求 $\displaystyle\sum_{i=1}^n\sum_{j=1}^nf(i,j)$ 的值。
# 性质发现（※）
## 最终结论：
> 若 $(a,b)=1$：
>
> “当且仅当 $a+b=2^k$ 时，$f(a,b)=k-1$（结论 I）；否则 $f(a,b)=0$（结论 II）。”
> 
> 否则：
>
> “$f(a,b)=f(\frac{a}{(a,b)},\frac{b}{(a,b)})$（结论 III）。”
---
## 证明：
### $1\degree$
对于 $f(a,b)$ 和 $f(b,a)$，考虑前者运算过程与后者运算过程**除了 $f$ 中两个数字的顺序不同，其他都相同，故最后的结果相同**，于是有 $f(a,b)=f(b,a)$；

---
### $2\degree$
由定义和 $1\degree$ 的结论，将运算过程简化为

$f(a,b)=\begin{cases}f(2\min(a,b),|a-b|),&a\ne b\\0,&a=b\end{cases}$；

---
### $3\degree$
考虑 $a,b$ 不互质的情况，不妨设 $(a,b)=m$，发现 $f(a,b)$ 运算过程中的数字是 $f(\frac{a}{m},\frac{b}{m})$ 运算过程中数字的 $m$ 倍，**不影响结果**，则有 $f(a,b)=f(\frac{a}{m},\frac{b}{m})$；至此最终结论 III 证毕。

---
### $4\degree$
考虑最终结论 I：当 $a+b=2^k,(a,b)=1$ 时，$f(a,b)=k-1$。

由 $1\degree$，不妨设 $a<b$。因为 $a+b$ 是偶数，且 $a,b$ 互质，故 $a,b$ 均为奇数。所以有：

$\displaystyle f(a,b)(\textcircled{1})\xlongequal{2\degree}f(2a,b-a)+1\xlongequal{a,b为奇数,且3\degree}f(a,\frac{b-a}{2})+1(\textcircled{2})$

考虑第 $\textcircled{1}$ 步中，$a+b=2^k$，$(a,b)=1$，第 $\textcircled{2}$ 步中，$a+\frac{b-a}{2}=2^{k-1}$，$(a,\frac{b-a}{2})=1$；故形如递归，则第 $k-1$ 步时，$a_{k-1}+b_{k-1}=2$，进而地，$a_{k-1}=b_{k-1}=1$，$f(a,b)=f(a_{k-1},b_{k-1})+k-1=k-1$。

---
### $5\degree$
考虑最终结论 II：当 $a+b\ne2^k,(a,b)=1$ 时，$f(a,b)=0$。

类比上述过程，由互质可得两种情况：

$(1)\quad a,b$ 奇偶性相反

设 $a<b$，则 $f(a,b)=f(2a,b-a)$；考虑 $f(2a,b-a)$ 与 $f(a,b)$ 本质相同（一奇一偶）且不能被转化为 $4\degree$，故**不可能终止**。

$(2)\quad a,b$ 均为奇数

设 $a<b$，类比 $4\degree$ 中推导，则 $f(a,b)=f(2a,b-a)=f(a,\frac{b-a}{2})$；此时 $a+\frac{b-a}{2}=\frac{1}{2}(a+b)$，所以每递归一层会使两个数的和除以 $2$。因为 $a+b\ne2^k$，所以可以在有限次递归后变为 $f(a_n,b_n)(a_n,b_n一奇一偶)$，即 $(1)$。
# 做法（※）
## 朴素做法
此时，原式中每一个 $f(i,j)$ 均可快速（**近乎**常数地）解决，但仍然是 $\mathcal O(n^2)$。
## 优化 1
考虑变成单层求和。对于每个奇数 $i$，找到**唯一**比它小的 $j$ 满足 $i+j=2^{k}$ 且 $(i,j)=1$（对答案有贡献）。即：

$\displaystyle\sum_{i=1}^n [i\bmod2=1]\lfloor \log_2(i)\rfloor\lfloor\frac{n}{i}\rfloor$

（编者注：这个式子别人都没讲，本人来说一下。对于一组有贡献的 $f(a,i)$，可以找出 $\lfloor\frac{n}{i}\rfloor$ 组 $f(ka,ki)$ 有**同样**贡献；考虑单组贡献

$f(a,i)=min\{x|x\in\mathbb{N}\cap2^x>i\}-1=\lceil\log_2(i)\rceil-1=\lfloor\log_2(i)\rfloor$，

而只讨论奇数**显然不会重复/遗漏**，故得证。）

此时发现时间复杂度是 $\mathcal O(n)$ 的。
## 优化 2
进而地，我们发现形如下列式子可以进行**数论分块**。

$\displaystyle\sum_{i=1}^ng(i)\times\lfloor\frac{n}{i}\rfloor$

$\displaystyle\sum_{i=1}^ng(i)\times\lfloor\log_2(i)\rfloor$

那么本题也必然能通过上述两个数论分块来完成优化。数论分块时间复杂度 $\mathcal O(\sqrt{n}\log n)$。
# 代码
总之还是有点细节的（主要是我之前没写过分块 orz）。

如果不会同时处理两个分块，可以采用“分块套分块”的形式，在 $\sqrt{n}$ 里套一个 $\log n$，详见代码。

```cpp
//Luogu P3764 author: OrientDragon
#include<bits/stdc++.h>
#define int unsigned long long
using namespace std;
inline int solve(int n){//代码在这里 
	function<int(int,int,int)>f=[](int l,int k,int n){
		function<int(int,int)>od=[](int x,int y){
			//[x,y]中有多少个奇数，选用大模拟O(1)处理
			if((y-x+1)&1&&x&1)return((y-x+1)>>1)+1;
			else return(y-x+1)>>1;
		};
		//log数论分块
		int ret=0,r=0,tmp=0;
		for(;l<=k;l=r+1){//O(log(n))
			tmp=log2(l);
			r=min((1ull<<(tmp+1))-1,k);
			tmp*=n/l;
			ret+=tmp*od(l,r);//核心 
		}
		return ret;
	};
	//一般数论分块模板
	int ans=0,l=1,r=0;
	for(;l<=n;l=r+1){//O(sqrt(n))
		r=n/(n/l);
		ans+=f(l,r,n);//这里是用于处理log的区间和 
	}
	return ans<<1;
}main(){int n;cin>>n;cout<<solve(n);}
```

---

## 作者：critnos (赞：1)

菜鸡不会高级算法，，只能用最容易想的了。

题目要你求：

$$\sum_{i=1}^n \lfloor \log_2 i\rfloor \lfloor \dfrac n i\rfloor[i\bmod2=1]$$

对于这个式子，我们发现，两个因数 $\lfloor \log_2 i\rfloor$ 和 $\lfloor \dfrac n i\rfloor$，均有相等的连续段。其中  $\lfloor \log_2 i\rfloor$ 有 $\log n$ 个连续段而 $\lfloor \dfrac n i\rfloor$ 有 $\sqrt n$ 个。

接下来是无脑的数论分块。。。

首先，对于 $\lfloor \dfrac n i\rfloor$ 是很容易的。

```cpp
ll ask(ll x)
{
	ll s=0,l,r;
	for(l=1;l<=x;l=r+1)
	{
		r=x/(x/l);
		s+=ask2(l,r,x);
	}
	return s*2;
}
```
这个是套路。emm，这个 `ask2` 是啥？

对于一个 $\lfloor \dfrac n i\rfloor$ 的连续段，$\lfloor \log_2 i\rfloor$ 未必连续。所以这个 `ask2` 是用于真实的求和的。求 $\sum_{i=l}^r \lfloor \log_2 i\rfloor \lfloor \dfrac x i\rfloor$。在 前面对 $\lfloor \dfrac n i\rfloor$ 的分段中已经使得 `ask2` 要算的区间中的所有 $\lfloor \dfrac x i\rfloor$ 均相等。所以只用对 $\lfloor \log_2 i\rfloor$ 做分块。

然而因为不知道怎么直接用式子，所以采取了倍增。。。多了一个 $\log$，不过在没法推式子的时候这东西好想好记边界条件不容易写错，还比二分快。

```cpp
ll ask2(ll l,ll r,ll x)
{
	ll s=0,i,j,b,ans;
	for(i=l;i<=r;i=j+1)
	{
		j=i,ans=log2(i);
		for(b=1ll<<40;b>=1;b/=2)
			if(j+b<=r&&(ll)log2(j+b)==ans)
				j+=b;
		ans*=x/l;
		s+=ans*odd(i,j);
	}
	return s;
}
```
这个 `odd` 呢，是用于算区间奇数个数的。至于为啥自己看上面的式子。

最后的复杂度是 $\sqrt n \log^2 n$，算是过的人里面相当慢的了。

---

## 作者：Minclxc (赞：1)

打个O(sqrt(n))的算法

由打表可知f(a,b)!=0当且仅当a+b=2^k(k为正整数)，且f(a,b)=f(ka,kb)(k为正整数)

以上我不会证，如果有神犇可以证一下就更好了。

由此，只需要计算第一个f(a,b)就好了(a,b为奇数)，此时f(a,b)=k(a+b==2^k)

所以对于每个min(a,b)(不重复的，分别为3,5,7,……)，对答案的贡献是k\*(n/min(a,b))

最后式子是ans=2\*sigma(i=1->(n-1)/2)(i\*ceil(log2(i))\*floor(n/i))

但这样是O(n)的，所以进行分块，前sqrt(n)个暴力，后(n-sqrt(n))的floor(n/i)只有sqrt(n)种

底下是程序了

```cpp
#include<cstdio>
#include<cstring>
#include<math.h>
#include<time.h>
#include<iostream>
#include<algorithm>
#include<vector>
#include<stack>
#include<queue>
using namespace std;
#define fo(a,b,c) for(int a=b;a<=c;a++)
#define go(a,b,c) for(int a=b;a>=c;a--)
typedef long long LL;
LL read(){
    LL a=0;int f=0;char c=getchar();
    for(;c<'0'||c>'9';c=getchar())if(c=='-')f=1;
    for(;c>='0'&&c<='9';c=getchar())a=a*10+c-'0';
    return f?-a:a;
}
int min(int a,int b){return a<b?a:b;}
int max(int a,int b){return a>b?a:b;}
int main(){
    LL n=read();int x=floor(log2(n))/2,y=n/(((LL)1<<x+1)+1);LL z=((LL)1<<x)-1,ans=0ll;
//x是ceil(log2(i))，即f(a,b)，y是floor(n/i)，z是查到第几个
    for(int i=1;i<=x;i++)
        for(int j=((LL)1<<i-1);j<((LL)1<<i);j++)
            ans+=i*(n/(2*j+1));//前sqrt(n)
    x++;//剩下的
    while(y){
        if(n/(((LL)1<<x+1)-1)==y){//如果当前x都是y
            ans+=x*y*(((LL)1<<x)-z-1);
            z=((LL)1<<x)-1;x++;
        }
        else{
            LL zz=(n/y-1)/2;//最后一个是y的
            ans+=x*y*(zz-z);
            y--;z=zz;
        }
    }
    printf("%lld\n",ans*2);
    return 0;
}
```


---

## 作者：CuriousCat (赞：1)

声明，这是一个未完成的题解，只是提供一种思路，希望好心人能接着我的思路补充下去。

因为原函数可能会死循环，所以我们不妨从结束状态考虑，看能不能推出所有开始状态。

定义rf(a,b)作为f(a,b)的逆函数，表示由(a,b)所能拓展出的所有起始状态。

很显然原来的函数是f(a,b) = f(max(a,b) - min(a,b), min(a,b) +min(a,b))，那rf就有两种操作，把a除以2加到b上，把b除以2加到a上，而且这些操作推出来的状态一定是能回到(a,b)的，因为如果较大的数被除2的话就变成较小的数了。

显然rf(a,b)的结束状态是a%2==1&&b%2==1.而且一定不会出现a%2==1，b%2==0的情况。

这样的话我们知道所有的结束状态一定是f(2^k\*p,2^k\*p),k=0,1,2,3,4,....,p是奇数。

想到这儿其实就有了一个奇葩的70做法了.。。。。我自己懒没写。。。。

我们暴力算出rf(2^k，2^k）然后枚举所有的奇数在表里统计f函数的值。

官方题解f(a,b)=p-1,gcd(a,b)==1&&a+b=2^p,这好像就是rf推推推推到最底层时的情况。

然后。。。

就直接猜了

```cpp
for (i=1;i<=n;i+=2) ans+=n/i*log2(i).........
```
希望好心人继续证qwq



---

## 作者：yzyun (赞：1)

下证$i+j=2^p$时,$f(i,j)=p-1$;

只须证明$f(i,j)=f(2^{p-1},2^{p-1})+p-1=p-1$

考虑采用数学归纳法。

显然对任意$m$满足$1<=m<=p-1$,若$f(i,j)=f(x,y)+m$,则$x+y=i+j$。

待证命题:对于任意$m$满足$1<=m<=p-1$,$f(i,j)=f(x,y)+m$,都有$2^m||x$,$2^m||y$(则当$m=p-1$时,有$f(i,j)=f(x0,y0)+p-1$,则必有$2^{p-1}||x0$,$2^{p-1}||y0$,又$x0+y0=i+j=2^p$,所以$x0=y0=2^{p-1}$,即可证明原命题)。
当$m=1$时,显然有$2||i-j$,$2||2j$;
设当$m=k$时结论成立,则$f(i,j)=f(ai+bj,ci+dj)+k$,由归纳假设$2^k||(ai+bj)$,$2^k||(ci+dj)$;
($a,b,c,d$为常数)

由对称性不妨设$ai+bj>ci+dj$;

则只需证$m=k+1$时,$f(i,j)=f((a-c)i+(b-d)j,2bi+2dj)+k-1$中的$(a-c)i+(b-d)j$,$2bi+2dj$均恰被整除即可。

注意到$2^{k+1}||2bi+2dj$,则只需证$2^{k+1}||(a-c)i+(b-d)j$即可。
不妨设$ai+bj=e*2^k$(此$e$非彼$e$),$ci+dj=f*2^k$;

(由条件可知$e,f$均为奇数且满足$2||e-f$,因为$e+f=2^{p-k}$,则有$e\equiv{-f(mod2^{p-k})}$,${(e-f)/2}\equiv{e(mod2^{p-k+1})}$,则有$2||(e-f)$ )
则$2^(k+1)=2*2^k||(e-f)*2^k=(a-c)i+(b-d)j$,即$2^{k+1}||(a-c)i+(b-d)j$


---

## 作者：fjzzq2002 (赞：1)

#### 签到题III


考虑先对于互质的(i,j)计算答案。


可以发现当且仅当$i+j=2^p$（$p \geq 2$）时f值非0，$f(i,j)=p-1$。


抱歉我也不会证......求好心人补充一下证明。


那么枚举每个p找到有多少对合法$(i,j)$计算答案即可。


设$g(n)=\sum_{i=1}^n\sum_{j=1}^n[gcd(i,j)=1]f(i,j)$，计算g(n)复杂度$O(logn)$。


因为(i,j)不一定互质，那么我们枚举gcd(i,j)，求出$\sum_{i=1}^n g(n/i)$，对g(n/i)根号分段即可。$O(\sqrt{n}logn)$。


---

## 作者：Uuuuuur_ (赞：0)

这个函数比较奇怪，不知道它什么时候有解。

首先了解两个性质：

$$f(a,b)=f(b,a)$$
$$f(ax,bx)=f(a,b)$$

先从有解的情况往前推。$f(x,x)=0$，就有 $f(3x,x)=1$，有 $f(\frac{7}{2}x,\frac{1}{2}x)=2$ 和 $f(\frac{5}{2}x,\frac{3}{2}x)=2$，0我们把它写成 $f(7x,x)=2$ 和 $f(5x,3x)=2$。

其实这里已经能发现一个性质：

我们再写出一个 $f=3$ 的例子：$f(15x,x)=3$，这里 $f$ 的取值规律已经很明显了。我们猜测：若 $\gcd(a,b)=1$，且 $a+b=2^k$，那么 $f(a,b)=f(ax,bx)=k-1$。我们发现，其实互质也可以表示为 $x,y<2^k$ 且 $x,y$ 都为奇数。

简单验证一下这个结论，任何满足 $a+b=2^k,\gcd(a,b)=1$ 的取值，设 $a > b$，有

$$f(a,b)=f(a-b,2b)+1=f(2^k-2b,2b)+1=f(2^{k-1}-b,b)+1$$

得到的 $2^{k-1}-b+b=0$，且这两数都是小于 $2^{k-1}$ 的奇数。这样不断往后推，得到 $f(1,1)=0$。递归次数 $k-1$ 次。

还记得最初的两个性质吗？我们结论都是基于这两个性质上的。我们重点说第二个性质，其实有解的情况在不断举例子的时候已经验证过了，$f(x,x)=f(1,1)=1$，$f(3x,x)=f(3,1)=1$，$f(5x,3x)=f(5,3)=2 \dots$ 无解的情况，都等于零了，当然就成立了。

最后得出这个式子：

$$f(x,y)=\begin{cases}
    \log_2({\displaystyle\frac{x+y}{\gcd(x,y)}})-1,&\quad \log_2(\displaystyle\frac{x+y}{\gcd(x,y)}) \in \mathbb{N^*}\\
    0, &\quad \text{Otherwise}
\end{cases}$$

然后对题目的式子，就可以变形啦。

我们枚举对答案贡献的值 $k$，原式就变为：

$$ \sum_{k=1,d=2^{k+1}}^{d<2n}{k} \sum_{i \equiv 1(\bmod2)}^{d-1} \lfloor \displaystyle\frac{n}{\max(i,d-i)} \rfloor $$

把 $\max$ 去掉，

$$ \sum_{k=1,d=2^{k+1}}^{d<2n}{2k} \sum_{i = d/2+1,i \equiv 1(\bmod2)}^{d-1} \lfloor \displaystyle\frac{n}{i} \rfloor $$

这明显是一个数论分块，时间复杂度 $O(\sqrt{N}\log N)$。

其实还可以把 $k$ 塞到分块里面，达到 $O(\sqrt{N})$ 的复杂度。
不过既然能过了，就不用优化了！

还有，要开 unsigned long long。
```cpp
#include <bits/stdc++.h>
#define int unsigned long long
using namespace std;
int n;
int up[55];

void init() {
    up[0] = 1;
    for (int i = 1; i <= 54; i++) {
        up[i] = up[i - 1] * 2;
    }
}
int ans;
signed main() {
    cin >> n;
    init();
    for (int k = 1, d = up[2]; d <= 2 * n; d = up[++k + 1]) {
        int res = 0;
        for (int i = d / 2 + 1; i * i < n && i < n / i && i < d; i += 2) {
            res += n / i;
        }
        for (int i = max(1ull, n / (d - 1)); i * i <= n; i++) {
            int st = n / (i + 1) + 1;
            int en = min(d - 1, n / i);
            st = max(st, d / 2 + 1);
            if (st % 2 == 0) st++;
            if (en % 2 == 0) en--;
            if (st <= en) {
                res += ((en - st) / 2 + 1) * i; 
            }
        }
        ans += res * 2 * k;
    }
    cout << ans;
    return 0;
}
```


---


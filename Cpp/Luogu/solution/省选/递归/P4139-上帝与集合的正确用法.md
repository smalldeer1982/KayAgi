# 上帝与集合的正确用法

## 题目描述

根据一些书上的记载，上帝的一次失败的创世经历是这样的：

第一天，上帝创造了一个世界的基本元素，称做元。

第二天，上帝创造了一个新的元素，称作 $\alpha$ 。 $\alpha$ 被定义为元构成的集合。容易发现，一共有两种不同的 $\alpha$ 。

第三天，上帝又创造了一个新的元素，称作 $\beta$ 。 $\beta$ 被定义为 $\alpha$ 构成的集合。容易发现，一共有四种不同的 $\beta$。

第四天，上帝创造了新的元素 $\gamma$，$\gamma$ 被定义为 $\beta$ 的集合。显然，一共会有 $16$ 种不同的 $\gamma$。

如果按照这样下去，上帝创造的第四种元素将会有 $65536$ 种，第五种元素将会有 $2^{65536}$种。这将会是一个天文数字。

然而，上帝并没有预料到元素种类数的增长是如此的迅速。他想要让世界的元素丰富起来，因此，日复一日，年复一年，他重复地创造着新的元素……

然而不久，当上帝创造出最后一种元素 $\theta$ 时，他发现这世界的元素实在是太多了，以致于世界的容量不足，无法承受。因此在这一天，上帝毁灭了世界。

至今，上帝仍记得那次失败的创世经历，现在他想问问你，他最后一次创造的元素 $\theta$ 一共有多少种？

上帝觉得这个数字可能过于巨大而无法表示出来，因此你只需要回答这个数对 $p$ 取模后的值即可。

你可以认为上帝从 $\alpha$ 到 $\theta$ 一共创造了 $10^9$ 次元素，或 $10^{18}$ 次，或者干脆 $\infty$ 次。

一句话题意：

定义 $a_0=1,a_n=2^{a_{n-1}}$，可以证明 $b_n=a_n\bmod p$ 在某一项后都是同一个值，求这个值。

## 说明/提示

对于 $100\%$ 的数据，$T\le 10^3$，$p\le10^7$。

## 样例 #1

### 输入

```
3
2
3
6```

### 输出

```
0
1
4```

# 题解

## 作者：panda_2134 (赞：65)

各位dalao应该都知道扩展欧拉定理吧……

大概长这样：

对于任意$b \geq \varphi(p)$,有：

![](https://www.zhihu.com/equation?tex=a^b%20\equiv%20a^{b\text{%20mod%20}\varphi(p)%20%2B%20\varphi(p)}%20(\text{mod%20}p))

当$b < \varphi(p)$时有$a^b \equiv a^{b \text{ mod } \varphi(p)} (\text{mod } p)$


其中$a,p$可以不互质。

  
有了这个式子，题目中的$2^{2^{2^{2^{\cdots}}}} \text { mod } p$就很好求了，照着上面的式子递归就行。这里要注意应用条件：这里的指数$b=2^{2^{2^{2^{\cdots}}}}$是满足$b \geq \varphi(p)$的，于是可以直接用第一个式子。

  
附上代码。本蒟蒻不会线性筛，只好用Eratosthenes筛代替了= =


```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXP = 1e7;

int T, p, phi[MAXP+10];

void InitPhi() {
    phi[1] = 1; 
    for(int i=2; i<=MAXP; i++)
        if(!phi[i]) {
            for(int j=i; j<=MAXP; j+=i) {
                if(!phi[j]) phi[j] = j; 
                phi[j] = phi[j] / i * (i-1);
            }
        }
}

inline int fastmul(int a, int x, int mod) {
    int ret = 0;
    while(x) {
        if(x&1) ret = ((ret%mod) + (a%mod))%mod;
        x>>=1; a = ((a%mod) + (a%mod)) %mod;
    }
    return ret;
}

inline int fastpow(int a, int x, int mod) {
    int ret = 1;
    while(x) {
        if(x&1) ret = fastmul(ret, a, mod) % mod;
        x>>=1; a = fastmul(a, a, mod) % mod;
    }
    return ret;
}

int solve(int mod) {
    if(mod == 1) return 0;
    return fastpow(2, solve(phi[mod])+phi[mod], mod);
}

int main() {
    InitPhi();
    scanf("%d", &T);
    while(T--) {
        scanf("%d", &p);
        printf("%d\n", solve(p));
    }
}
```


---

## 作者：Siyuan (赞：49)

[$$\Large\texttt{My Blog}$$](https://hydingsy.github.io/articles/problem-BZOJ-3884-God-and-Set/)

---

## Description

> 题目链接：[Luogu 4139](https://www.luogu.org/problemnew/show/P4139)

求如下式子的值：
$$2^{2^{2\cdots}}\bmod p$$
本题 $T$ 组数据。

数据范围：$1\le T\le 1000$，$1\le p\le 10^7$

------

## Solution

首先我们可以根据**扩展欧拉定理**：
$$\text{当}\ b\ge \varphi(p)\ \text{时，有}\ a^b\equiv a^{b\bmod \varphi(p)+\varphi(p)}\pmod p$$
得到：
$$2^{2^{2\cdots}}\bmod p=2^{(2^{2\cdots}\bmod \varphi(p)+\varphi(p))}\bmod p$$
很显然这是一个递归式子，边界条件为 $p=1$，此时式子的值为 $0$。

对于 $\varphi(p)$，我们可以线性筛预处理。

**时间复杂度**：$O(P+T\log p)$

------

## Code

```cpp
#include <cstdio>

const int N=1e7+5,M=N/10;
int n,tot,p[M],phi[N];
bool flg[N];

void sieve(int n) {
	phi[1]=1;
	for(int i=2;i<=n;++i) {
		if(!flg[i]) p[++tot]=i,phi[i]=i-1;
		for(int j=1;j<=tot&&i*p[j]<=n;++j) {
			flg[i*p[j]]=1;
			if(i%p[j]==0) {
				phi[i*p[j]]=phi[i]*p[j];
				break;
			} else {
				phi[i*p[j]]=phi[i]*phi[p[j]];
			}
		}
	}
}
int pow(int x,int p,int mod) {
	int ret=1;
	for(;p;p>>=1,x=1LL*x*x%mod) if(p&1) ret=1LL*ret*x%mod;
	return ret;
}
int solve(int p) {
	if(p==1) return 0;
	return pow(2,solve(phi[p])+phi[p],p);
}
int main() {
	sieve(N-5);
	int T;
	for(scanf("%d",&T);T--;) {
		int p;
		scanf("%d",&p);
		printf("%d\n",solve(p));
	}
	return 0;
}
```



---

## 作者：NaCly_Fish (赞：25)

发现这题其实是我出过一题的弱化版。。    
传送门：[link](https://www.luogu.org/problemnew/show/T59422)  

题目要求出：  
$$2^{2^{2^{...}}} \bmod p$$  
的值  

根据扩展欧拉定理：  
此处 $\varphi$ 指的就是数论中的欧拉函数，证明略。网上一搜一大堆。
$$a^b\equiv \left\{\begin{aligned}a^{b \bmod\varphi(p)+\varphi(p)}(b>\varphi(p))\\a^b(b \le \varphi(p))\end{aligned}\right. \pmod p$$   
  

我们不难想到这样的一个递归函数，用来求 $a^{a^{a^{...}}}\text{mod }p$（$n$ 个 $a$）。   
由于是这个乘方塔有无限层，$b$ 肯定大于 $\varphi(p)$，所以直接用第一种情况即可。
```cpp
int tower(int a,int n,int p){
    if(p==1) return 0;
    if(n==1) return c%p;
    int t = phi(p);
    return power(a,tower(a,n-1,t)+t,p);
}
```  
（这里 `phi` 是求欧拉函数的）

可是题目中让求的是无限层，并不是有限层，怎么办啊？  
不要紧，在一层层的递归中，$p$ 一遍遍的被求其 $\varphi$ 值，最终**必定**会降到 $1$。原因很简单：

- 对任意大于 $1$ 的整数 $p$，$\varphi (p)$ 是偶数。
- 若 $p$ 是偶数，$\varphi(p) \leq p/2$。

第二条可以利用欧拉函数的积性，从中提取 $2$ 这个质因子来证明。由此可以发现，这个递归过程只会进行 $\mathcal O(\log p)$ 次。

然后我们就有办法了，求答案的时候直接用一个很大的 $n$ 来计算就好啦！  
注意做快速幂时每次模数不同，需要注意一下。

参考代码：
```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<algorithm>
#include<cmath>
#define ll long long
using namespace std;

inline int phi(int n){  
    int res,a;
    res = a = n;
    for(int i=2;i*i<=a;++i){
        if(a%i) continue;
        res = res/i*(i-1);  
        while(!(a%i)) a /= i;
    }  
    if(a>1) res = res/a*(a-1);
    return res;  
}

inline void read(int &x){
    x = 0;
    char c = getchar();
    while(!isdigit(c)) c = getchar();
    while(isdigit(c)){
    	x = (x<<3)+(x<<1)+c-'0';
    	c = getchar();
    }
}

inline int power(int a,int t,int p){
    int res = 1;
    while(t){
        if(t&1) res = (ll)res*a%p;
        a = (ll)a*a%p;
        t >>= 1;
    }
    return res;
}

int tower(int c,int p){ // 这里稍微改了一下，直接求解，不用设置一个很大的 n
    if(p==1) return 0;
    int t = phi(p);
    return power(c,tower(c,t)+t,p);
}

void print(int x){
    if(x>9) print(x/10);
    putchar(x%10+'0');
}

void optimized(){
    int m;
    read(m);
    print(tower(2,m));
    putchar('\n');
}

int main(){
    int T;
    read(T);
    while(T--)
        optimized(); 
    return 0;
}
```


---

## 作者：Nemlit (赞：13)

前置之士：欧拉定理和拓展欧拉定理:

$a^b\equiv a^{b\ mod\ φ (m)}  \ \ \ \qquad\qquad gcd(a,m)=1$

$a^b\equiv a^b     \qquad\qquad\qquad\qquad       gcd(a,m)\neq 1,b<φ (m)$

$a^b\equiv a^{(b\ mod\ φ (m))+φ (m)} \qquad  gcd(a,m)\neq 1,b\ge φ (m)$

然后我们发现，$p$是随即数据，不把保证$p,a$互质，所以我们用上述后两个结论，也就是拓展欧拉定理。

于是我们可以递归执行，直到模数为0，返回1即可

但是我们发现随着递归的深入，我们的模数也在变，所以我们要预处理出所有的$φ$值，我们可以用线性筛（主要是Eratosthenes筛法TLE了）来预处理

代码如下：
```
#include<bits/stdc++.h>
using namespace std;
#define il inline
#define re register
#define debug printf("Now is Line : %d\n",__LINE__)
#define file(a) freopen(#a".in","r",stdin);freopen(#a".out","w",stdout)
#define ll long long
il int read()
{
    re int x=0,f=1;re char c=getchar();
    while(c<'0'||c>'9') {if(c=='-') f=-1;c=getchar();}
    while(c>='0'&&c<='9') x=x*10+c-48,c=getchar();
    return x*f;
}
#define maxn 10000000
int n,m,f[maxn+5],p[5000000],tot;
bool is[maxn+5];
il ll quickpow(ll a,int b,int mod)
{
    ll r=1;
    while(b)
    {
        if(b&1) r=(r*a)%mod;
        b>>=1;
        a=(a*a)%mod;
    }
    return r;
}
il ll solve(int mod)
{
    if(mod==1) return 0;
    return quickpow(2,solve(f[mod])+f[mod],mod);
}
signed main()
{
    f[1]=1;
    for(re int i=2;i<=maxn;++i)
    {
        if(!is[i]) p[++tot]=i,f[i]=i-1;
        for(re int j=1;j<=tot;++j) 
        {
            if(i*p[j]>maxn) break;
            is[i*p[j]]=1;
            if(i%p[j]) f[i*p[j]]=f[i]*(p[j]-1);
            else {f[i*p[j]]=f[i]*p[j];break;}
        }
    }
    int T=read();
    while(T--)
    {
        n=read();
        printf("%lld\n",solve(n));
    }
    return 0;
}
```

---

## 作者：ezoiHQM (赞：12)

楼下用的是Eratosthenes筛，那我来补一发线性筛	
先来看一下线性筛素数：
```cpp
void Get_prime(){
    isprime[1]=1;
    for(int i=2;i<=10000000;i++){
        if(!isprime[i])
            prime[++tot]=i;
        for(int j=1;j<=tot;j++){
            if(i*prime[j]>10000000)
                break;
            isprime[i*prime[j]]=1;
            if(!(i%prime[j]))
                break;
        }
    }
}
```
在这个代码中，每个合数仅被它的最小素因子筛去正好一次，所以为线性时间。	
然后我们可以利用欧拉函数的几个性质来借此求出10000000以内的所有欧拉函数(p为素数)：	
1.φ(p)=p-1	
2.如果i mod p=0，则φ(i·p)=p*φ(i)	
3.如果i mod p≠0，则φ(i·p)=φ(i)·(p-1)	
利用这些性质，我们就可以很轻松地在线性的时间内求出10000000以内的欧拉函数。	
代码：
```cpp
void Get_phi(){
	phi[1]=1;
	for(int i=2;i<=10000000;i++){
		if(!phi[i]){
			prime[++tot]=i;
			phi[i]=i-1;
		}
		for(int j=1;j<=tot;j++){
			if(i*prime[j]>10000000)
				break;
			if(!(i%prime[j])){
				phi[i*prime[j]]=phi[i]*prime[j];
				break;
			}
			else phi[i*prime[j]]=phi[i]*(prime[j]-1);
		}
	}
}
```
求完欧拉函数以后，很简单，直接用扩展欧拉定理就可以轻松求出答案。
总代码：
```cpp
#include<cstdio>
int quick_pow(long long a,int n,int mod){
	long long ans=1;
	while(n){
		if(n&1)
			ans=ans*a%mod;
		a=a*a%mod;
		n>>=1;
	}
	return ans;
}
int phi[10000010],prime[10000010],tot,n;
void Get_phi(){
	phi[1]=1;
	for(int i=2;i<=10000000;i++){
		if(!phi[i]){
			prime[++tot]=i;
			phi[i]=i-1;
		}
		for(int j=1;j<=tot;j++){
			if(i*prime[j]>10000000)
				break;
			if(!(i%prime[j])){
				phi[i*prime[j]]=phi[i]*prime[j];
				break;
			}
			else phi[i*prime[j]]=phi[i]*(prime[j]-1);
		}
	}
}
int solve(int mod){
	if(mod==1)
		return 0;
	return quick_pow(2,solve(phi[mod])+phi[mod],mod);
}
int main(){
	#ifndef ONLINE_JUDGE
	freopen("4139.in","r",stdin);
	freopen("self.out","w",stdout);
	#endif
	Get_phi();
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		int p;
		scanf("%d",&p);
		printf("%d\n",solve(p));
	}
	return 0;
}
```

---

## 作者：panyf (赞：6)

由扩展欧拉定理，a^b≡a^(b mod φ(p)+φ(p)) mod(p)

所以只需要求出φ，用一个简单的递归便能解决本题

题目中T<=1000，而p<=10e7，因此不适合用筛法求φ

实测：

Eratosthenes筛：
```cpp
inline void calc_phi(int x){
	for(int i=1;i<=x;i++)phi[i]=i;
	for(int i=2;i<=x;i++)if(phi[i]==i)for(int j=i;j<=x;j+=i)phi[j]=phi[j]/i*(i-1);
}
```
用时5.67 s

线性筛：
```cpp
inline void calc_phi(int x){
    phi[1]=1;
    for(int i=2;i<=x;i++){
        if(!vis[i])pr[++tot]=i,phi[i]=i-1;
        for(int j=1,k;k=i*pr[j],j<=tot&&k<=x;j++){
            vis[k]=1;
            if(i%pr[j]==0){phi[k]=phi[i]*pr[j];break;}
            else phi[k]=phi[i]*phi[pr[j]];
        }
    }
}
```
用时2.13 s

非筛法求φ：
```cpp
int phi(int x){
	int r=x;
	for(int i=2;i*i<=x;i++)if(x%i==0){
		r=r/i*(i-1);
		do x/=i;while(x%i==0);
	}
	if(x>1)r=r/x*(x-1);
	return r;
}
```
用时仅49ms!（未开O2）

很明显，非筛法的效率远超筛法

求了φ后，只需要快速幂+递归就可以了（如果不用快速乘注意开long long）

完整代码如下：
```cpp
#include<bits/stdc++.h>
#define L long long
using namespace std;
int t,x;
int phi(int x){//求φ
	int r=x;
	for(int i=2;i*i<=x;i++)if(x%i==0){
		r=r/i*(i-1);
		do x/=i;while(x%i==0);
	}
	if(x>1)r=r/x*(x-1);
	return r;
}
L pow(L x,L y,L z){//快速幂
	L r=1;
	while(y){
		if(y&1)r=(r*x)%z;
		x=(x*x)%z,y>>=1;
	}
	return r;
}
int f(int x){//递归
	if(x<3)return 0;//小于3则终止递归
	int n=phi(x);
	return x<3?0:pow(2,n+f(n),x);
}
int main(){
    scanf("%d",&t);
    while(t--)scanf("%d",&x),printf("%d\n",f(x));
}
```


---

## 作者：andyli (赞：5)

原题可转化为解方程$2^x\equiv x(\text{mod}~ m)$。  
由欧拉定理得$2^x\equiv 2^{x~\text{mod}~\varphi(m)+\varphi(m)} (\text{mod}~m)$，那就转化为求$x~\text{mod}~\varphi(m)$。  

递归求解，至$m=1$时终止即可。  
可以证明递归的层数不大于$2\log 2m$。  

代码如下（[快读模板](https://andyli.blog.luogu.org/read-template)）：  
```cpp
const int maxn = 10000005;

int phi[maxn], r[maxn];
bool vis[maxn];
vector<int> primes;
void init(int n)
{
    phi[1] = 1;
    vis[0] = vis[1] = true;
    for (int i = 2; i <= n; i++) {
        if (!vis[i])
            primes.push_back(i), phi[i] = i - 1, r[i] = i;
        for (size_t j = 0; j < primes.size() && i * primes[j] <= n; j++) {
            vis[i * primes[j]] = true;
            r[i * primes[j]] = primes[j];
            phi[i * primes[j]] = phi[i] * (primes[j] - (primes[j] < r[i]));
            if (i % primes[j] == 0)
                break;
        }
    }
}
int quick_pow(int a, int n, int p)
{
    a %= p;
    int ans = 1;
    while (n) {
        if (n & 1)
            ans = 1LL * ans * a % p;
        a = 1LL * a * a % p;
        n >>= 1;
    }
    ans %= p;
    return ans;
}
int f(int p) { return p == 1 ? 0 : quick_pow(2, f(phi[p]) + phi[p], p); }
int main()
{
    init(maxn - 5);
    int T;
    io.read(T);
    while (T--) {
        int p;
        io.read(p);
        writeln(f(p));
    }
    return 0;
}
```

---

## 作者：Smallbasic (赞：4)

这题要用到一个神奇的东西：扩展欧拉定理。

长这样：

若$b>=\phi(p)$

$$a^b\equiv a^{b \mod\phi(p)+\phi(p)}(\mod p)$$

证明：~~即得易见平凡，由上可知显然，留做习题答案略，读者自证不难~~

设$p=l*q^r$,且$l\perp q$,$q$是$a$的质因子

有欧拉定理：

$$q^{\phi(l)}\equiv 1(\mod l)$$

显然也有：

$$q^{\phi(p)}\equiv 1(\mod l)$$

$$q^{k\phi(p) + r +b}\equiv q^{r+b}(\mod p)$$

即可得：

$$q^{k\phi(p)+c}\equiv q^c(\mod p)$$

其中$r\le c$

设$p^t$是$a$的因子：

$$q^{tc}\equiv q^{t\phi(p)+tc}\equiv (q^t)^{s\phi(p)+c}\equiv (q^t)^{c\mod \phi(p)+\phi(p)}(\mod p)$$

有$\because a$的所有质因子都满足上式，乘起来就好了。

再看这道题，可以发现：

$$2^{2^{2^{2^{......}}}}\equiv2^{2^{2^{2^{......}}}\mod \phi(p)+\phi(p)}(\mod p)$$

递归下去就好了。

边界条件：p为1时返回0

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>

using namespace std;

bool notprime[10000007];
int t, pp, prime[10000007], top = 0, phi[10000007];

inline void pre() {
    phi[1] = 1;
    for (register int i = 2; i <= 10000000; ++i) {  
        if (!notprime[i]) prime[++top] = i, phi[i] = i - 1;
        for (register int j = 1; j <= top; ++j) {  
            if (i * prime[j] > 10000000) break;  
            notprime[i * prime[j]] = 1;
            if (!(i % prime[j])) {  
                phi[i * prime[j]] = phi[i] * prime[j];
                break;  
            } else phi[i * prime[j]] = phi[i] * (prime[j] - 1);
        } 
    }
}

inline int power(int a, int b, int p) {
	long long y = 1, l = a; int k = b;
	while (k) {
		if (k & 1) y = (y * l) % p;
		l = (l * l) % p; k >>= 1;
	} return (int)y;
}

inline int calc(int l) {
	if (l == 1) return 0;
	return power(2, calc(phi[l]) + phi[l], l);
}

int main() {
	scanf("%d", &t); pre();
	while (t--) {
		scanf("%d", &pp);
		printf("%d\n", calc(pp));
	} return 0;
}
```


---

## 作者：FREEH (赞：4)

### 【题目】
![题目](https://cdn.luogu.com.cn/upload/pic/31175.png)

### 【扩展欧拉定理】
![公式](https://cdn.luogu.com.cn/upload/pic/31185.png)

### 【解题思路】
- 利用扩展欧拉定理。
- 原式=2^(剩余数%$ϕ(p)+ϕ(p)$)，而 剩余数%$ϕ(p)$又可以进行分解，所以这个过程可以用递归实现。
- 注意边界条件：当$p=1$时，余数自然为0。

### 【参考程序】
```cpp
#include<cstdio>
#include<cstring>
typedef long long LL;
//#define int LL
int Euler(int n)
{
	int eu=n;
	for (int i=2;i*i<=n;i++)
	{
		if (n%i==0)
		{
			eu=eu/i*(i-1);
			while (n%i==0)
				n/=i;
		}
	}
	if (n>1)
		eu=eu/n*(n-1);
	return eu;
}
int quick_pow(int x,int y,int Mod)
{
	int sum=1;
	for (;y;y>>=1,x=1ll*x*x%Mod)
		if (y&1)
			sum=1ll*sum*x%Mod;
	return sum%Mod;
}
int vis[10000005];
int Solve(int p)
{
	if (vis[p]!=-1) return vis[p];
	int phi=Euler(p);
	return vis[p]=quick_pow(2,Solve(phi)+phi,p);
}
signed main()
{
	int T;
	scanf("%d",&T);
	memset(vis,-1,sizeof vis);
	vis[1]=0;
	while (T--)
	{
		int p;
		scanf("%d",&p);
		printf("%d\n",Solve(p));
	}
	return 0;
}
```

---

## 作者：忆殇 (赞：2)

### 首先介绍一下欧拉函数和扩展欧拉函数（phi指的是欧拉函数）

 		a^b = a^(b%phi(p)) gcd(a,p) == 1 (mod p)
		  	 a^b          gcd(a,p) != 1 b < phi(p) (mod p) 
  		     a^(b%phi(p)+phi(p)) gcd(a,p) != 1 b >= phi(p) (mod p) 
             
### 本题用到的就是三式  

# 题意为  ![](http://www.lnsyoj.com/files/upload/49A6BDE9-E807-11B4-DF6D-B913A1AED1C9QQ%E6%88%AA%E5%9B%BE20180211101936.png)
### cal函数为求出这个式子对p取mod的结果

### 开始时设底数为2，指数为2的2次方的2次方…… ，cal（原式）的结果为w，应用公式，cal（原式） = 2 ^ （剩余数%phi（p）+ p）。

### 所以结果为2的（剩余数%phi（p）+ p），可以用快速幂求出，而指数部分的（剩余数%phi（p））仍可以按上述方法求解，于是递归求解即可

### 注意:当p == 1时，对1取mod应返回0，即为终止条件，输出即可。

### 代码

    #include<cstdio>
    #include<cstring>
    #include<algorithm>
    #include<cmath>
    using namespace std;
    typedef long long ll;
    ll ksm(ll x, ll y,ll mode)
    {
        ll ans = 1;
        while(y)
        {
            if(y % 2 == 1)
            {
                ans = ans * x % mode;
            }
            x = x * x %mode ;
            y = y/2;
        }
        return ans;
    }
    ll phi(ll x)
    {
        ll ans = x;
        for(ll i = 2 ; i * i <= x ;i++)
        {
            if(x % i == 0)
            {
                ans = ans / i * (i - 1);
                while(x % i == 0)
                {
                    x /= i;
                } 
            }
        }
        if(x != 1) 
        {
            ans = ans / x * (x - 1);
        }
        return ans;
    }
    ll cal(ll x)
    {
        if(x == 1)
        {
            return 0;
        }
        ll t = phi(x);
        return ksm(2,cal(t) + t, x);
    }
    int main()
    {
        int t;
        scanf("%d", &t);
        ll p;
        for(int i = 1;i <= t;i++)
        {
            scanf("%lld", &p);
            printf("%lld\n",cal(p));
        }
        return 0;
    }
    /*  a^b = a^(b%phi(p)) gcd(a,p) == 1 (mod p)
              a^b          gcd(a,p) != 1 b < phi(p) (mod p) 
              a^(b%phi(p)+phi(p)) a,p 可以不互质 b >= phi(p) (mod p) 
    */ 









---

## 作者：七里 (赞：1)

## **题目描述**


![](https://cdn.luogu.com.cn/upload/pic/69649.png)


## **详解**
**欧拉定理**：若正整数a，n互质，则$a^{φ(n)}$≡1(mod n)。

**扩展欧拉定理**：若正整数a，n互质，则对于任意正整数b，有$a^{b}$≡$a^{b \mod φ(n)}$(mod n)。

~~证明本蒟蒻并不太会。。。~~

### **欧拉的计算式**

```cpp
int phi(int n)
{
	int ans=n;
	for(R int i=2;i<=sqrt(n);i++)
	{
		if(n%i==0)
		{
			ans=ans/i*(i-1);
			while(n%i==0) n/=i;
		}
	}
	if(n>1) ans=ans/n*(n-1);
	return ans;
}
```

### **Eratosthenes筛法**
```cpp
void euler(int n)
{
	for(R int i=2;i<=n;i++) phi[i]=i;
	for(R int i=2;i<=n;i++)
	{
		if(phi[i]==i)
		{
			for(R int j=i;j<=n;j+=i)
			{
				phi[j]=phi[j]/i*(i-1);
			}
		}
	}
}
```

### **线性筛**

```cpp
void euler(int n)
{
	for(R int i=2;i<=n;i++)
	{
		if(!phi[i])
		{
			prime[++tot]=i;
			phi[i]=i-1;
		}
		for(R int j=1;j<=tot;j++)
		{
			if(prime[j]>n/i) break;
			if(!(i%prime[j]))
			{
				phi[i*prime[j]]=phi[i]*prime[j];
				break;
			}
			else phi[i*prime[j]]=phi[i]*(prime[j]-1);
		}
	}
}
```


所以本题可以不断递归求解，利用扩展欧拉定理。

## **代码如下**

快速幂如果不用快速乘的话要开 long long

自己死了好几次。。。

```cpp
#include<bits/stdc++.h>
#define R register
using namespace std;
int prime[5100000],phi[11000000],tot,T,p;
void euler(int n)
{
	for(int i=2;i<=n;i++)
	{
		if(!phi[i])
		{
			prime[++tot]=i;
			phi[i]=i-1;
		}
		for(int j=1;j<=tot;j++)
		{
			if(i*prime[j]>n) break;
			if(!(i%prime[j]))
			{
				phi[i*prime[j]]=phi[i]*prime[j];
				break;
			}
			else phi[i*prime[j]]=phi[i]*(prime[j]-1);
		}
	}
}
int q_mul(long long a,int b,int c)
{
	long long ans=1;
	while(b)
	{
		if(b&1) ans=(ans*a)%c;
		a=(a*a)%c;
		b>>=1;
	}
	return ans%c;
}
int solve(int mod)
{
	if(mod==1) return 0;
	return q_mul(2,solve(phi[mod])+phi[mod],mod);
}
int main ()
{
	euler(10000000);
	scanf("%d",&T);
	while(T--)
	{
		scanf("%d",&p);
		printf("%d\n",solve(p));
	}
	return 0;
}
```





---

## 作者：eros1on (赞：1)

[博客食用更佳~](https://tle666.github.io/2019/07/18/[BZOJ3884]%20%E4%B8%8A%E5%B8%9D%E4%B8%8E%E9%9B%86%E5%90%88%E7%9A%84%E6%AD%A3%E7%A1%AE%E7%94%A8%E6%B3%95/)


# **Description**

求 
$$2^{2^{2 \cdots}} \bmod p$$

对于 $100\%$ 的数据，有数据组数 $T \leq 1000$ ， $p \leq 10^7$

[题目链接戳这里](https://www.luogu.org/problemnew/show/P4139)

# **Solution**

根据 **扩展欧拉定理** ，即当 $b \geq \varphi (p)$ 时，

$$a ^ b \equiv a ^ {b \bmod \varphi(p) + \varphi(p)} \pmod{p}$$

而当 $b < \varphi(p)$ 时，

$$a^b \equiv a ^ {b \bmod \varphi(p)} \equiv a^b \pmod{p}$$

~~貌似没啥用？~~

由于题目中的 $b$ 是 $2^{2 \cdots}$ ，所以一定有 $b \geq \varphi(p)$，因此递归一下式子就做完了。

具体如下：

```cpp
ll work(ll m) {
  if (m == 1) return 0; // 带入算一下就能得出 0
  return qpow(2, work(phi[m]) + phi[m], m); // 递归， qpow 是快速幂
}
```

# **Code**

```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;
const int N = 10000100;

ll T, P, p[700700], phi[N], cnt;
bool vis[N];

inline void prework() {
  phi[1] = 1;
  for (int i = 2; i <= 1e7; i++) {
    if (!vis[i]) p[++cnt] = i, phi[i] = i - 1;
    for (int j = 1; j <= cnt && i * p[j] <= 1e7; j++) {
      vis[i * p[j]] = true;
      if (i % p[j] == 0) { phi[i * p[j]] = phi[i] * p[j]; break ; }
      else phi[i * p[j]] = phi[i] * phi[p[j]];
    }
  }
}

inline ll qpow(ll a, ll b, ll mod) {
  ll res = 1;
  while (b) {
    if (b & 1) (res *= a) %= mod;
    (a *= a) %= mod, b >>= 1;
  }
  return res;
}

inline ll work(ll m) {
  if (m == 1) return 0;
  return qpow(2, work(phi[m]) + phi[m], m);
}

int main() {
  prework();
  scanf("%lld", &T);
  while (T--) {
    scanf("%lld", &P);
    printf("%lld\n", (work(P) + P) % P);
  }
  return 0;
}
```

PS：我没有研究 `long long` 是否必要，只是保险罢了



---

## 作者：渺小的Mastar (赞：1)

~~为什么一定要用筛呢？~~

我这篇题解主要是优化了求phi的函数

不用初始化全部数的phi值
```cpp
inline ll phi(ll n){
    ll ans=n,m=sqrt(n);
    for(ll i=2;i<=m;i++)
        if(n%i==0)
        {
            ans=ans/i*(i-1);//这是定理
            while(n%i==0) n/=i;
        }
        if(n>1)ans=ans/n*(n-1);
        return ans;
}
```
然后可以快乐的跑了

ac程序：
```cpp
#include<iostream>
#include<cmath> 
#include<cstdio>
#define ll long long
using namespace std;
ll p;
inline ll read()
{
	ll x=0,f=1;
	char c=getchar();
	for(;!isdigit(c);c=getchar())
		if(c=='-')
			f=-1;
	for(;isdigit(c);c=getchar())
		x=(x<<3)+(x<<1)+c-'0';
	return x*f;
}
inline ll phi(ll n){
    ll ans=n,m=sqrt(n);
    for(ll i=2;i<=m;i++)
        if(n%i==0)
        {
            ans=ans/i*(i-1);
            while(n%i==0) n/=i;
        }
        if(n>1)ans=ans/n*(n-1);
        return ans;
}
inline ll mul(ll a, ll x, ll mod) {
    ll ret = 0;
    while(x) {
        if(x&1) ret = ((ret%mod) + (a%mod))%mod;
        x>>=1; a = ((a%mod) + (a%mod)) %mod;
    }
    return ret;
}

inline ll pow(ll a, ll x, ll mod) {
    ll ret = 1;
    while(x) {
        if(x&1) ret = mul(ret, a, mod) % mod;
        x>>=1; a = mul(a, a, mod) % mod;
    }
    return ret;
}
inline ll solve(int mod){
    if(mod==1)
        return 0;
    return pow(2,solve(phi(mod))+phi(mod),mod);
}
int main()
{
	ll T=read();
	for(register ll i=1;i<=T;++i)
	{
		p=read();
		cout<<solve(p)<<endl;
	}
	return 0;
}
```

---

## 作者：mulberror (赞：1)

# 前言
~~趁机宣传一波自己的博客：[【传送门】](https://www.cnblogs.com/chhokmah/p/10645053.html)~~

------
# 题目大意
让你求$2^{2^{2^{\cdots}}}(mod)P$的值。

------
# 前置知识
## 知识1：无限次幂怎么解决
让我们先来看一道全国数学竞赛的一道水题：  
让你求解：$x^{x^{x^{\cdots}}}=2$方程的解。  
对于上面的无限次幂，我们可以把这个式子移上去，得到了$x^{2}=2$。  
因为指数的原因，所以我们可以直接得到了$x=\sqrt{2}$。  
以上的问题，启示我们对于这一些无限次幂可以转移来解决。  
~~以上的东西可能用不到~~

## 知识2：欧拉定理和扩展欧拉定理
详细请出门左拐洛谷模板区[【传送门】](https://www.luogu.org/problemnew/show/P5091)。（从入门到入土）  
因为这一道题目$p$为任意整数，那么无法使用欧拉定理，那么就用比欧拉定理稍微复杂一点点的扩展欧拉定理。  
简单介绍一下扩欧定理：  
$$a^b\equiv a^{(b\mod\varphi(m))+\varphi(m)}\mod m$$
条件是$b>= \varphi(m)$  
给一份蒟蒻的线性筛欧拉函数的代码
```cpp
inline void Get_Phi(int MAXN) {
	phi[1] = 1;
	for (int i = 2; i <= MAXN; i ++) {
		if (!vis[i]) prime[++ Prime_tot] = i, phi[i] = i - 1;
		for (int j = 1; j <= Prime_tot && i * prime[j] <= MAXN ; j ++) {
			vis[i * prime[j]] = 1;
			if (i % prime[j] == 0) { phi[i * prime[j]] = phi[i] * prime[j]; break; }
			else phi[i * prime[j]] = phi[i] * phi[prime[j]];
		}
	}
}
```

-------
# 正解
既然我们知道了欧拉公式，那么我们就可以代到原来的幂次中，得到以下的推导：  
$$2^{2^{2^{\cdots}}} \ mod \ p = 2^{2^{2^{\cdots}} mod \ \varphi(p) + \varphi(p)}\ mod \ p$$
很明显的是$\varphi(1)=1$，那么这个就是我们递归的边界。  
剩下来的幂次我们可以用快速幂实现。  
欧拉函数的筛法就用线性筛就可以了，好像这一道题目就只用单个的筛好像可以更快。  
时间复杂度：$O(T+T\times log_2^p)$

----
# 代码
```cpp
#include <bits/stdc++.h>
#define ll long long
#define ms(a, b) memset(a, b, sizeof(a))
#define inf 0x3f3f3f3f
#define db double
#define N 10000500
using namespace std;
template <typename T>
inline void read(T &x) {
	x = 0; T fl = 1; char ch = 0;
	for (; ch < '0' || ch > '9'; ch = getchar())
		if (ch == '-') fl = -1;
	for (; ch >= '0' && ch <= '9'; ch = getchar())
		x = (x << 1) + (x << 3) + (ch ^ 48);
	x *= fl;
}
template <typename T>
inline T Power(T x, T y, T Mod) {
	T res = 1;
	for (; y; y >>= 1) {if (y & 1) res = (res * x) % Mod; x = (x * x) % Mod;} 
	return res % Mod;
}
ll a, b, c;
ll Prime_tot = 0;
int phi[N], prime[N];
bool vis[N];
inline void Get_Phi(int MAXN) {
	phi[1] = 1;
	for (int i = 2; i <= MAXN; i ++) {
		if (!vis[i]) prime[++ Prime_tot] = i, phi[i] = i - 1;
		for (int j = 1; j <= Prime_tot && i * prime[j] <= MAXN ; j ++) {
			vis[i * prime[j]] = 1;
			if (i % prime[j] == 0) { phi[i * prime[j]] = phi[i] * prime[j]; break; }
			else phi[i * prime[j]] = phi[i] * phi[prime[j]];
		}
	}
}
ll f(ll x) {
	if (x == 1) return 0;
	else return Power(2ll, f(phi[x]) + phi[x], x);
}
int main() {
	int cas; read(cas);
	Get_Phi(1e7+1);
	while (cas --) {
		ll n; read(n); 
		printf("%lld\n", f(n));
	}
	return 0;
}
```

---


# [SHOI2008] 汉诺塔

## 题目描述

汉诺塔由三根柱子（分别用A、B、C表示）和n个大小互不相同的空心盘子组成。一开始n个盘子都摞在柱子A上，大的在下面，小的在上面，形成了一个塔状的锥形体。
    对汉诺塔的一次合法的操作是指：从一根柱子的最上层拿一个盘子放到另一根柱子的最上层，同时要保证被移动的盘子一定放在比它更大的盘子上面（如果移动到空柱子上就不需要满足这个要求）。我们可以用两个字母来描述一次操作：第一个字母代表起始柱子，第二个字母代表目标柱子。例如，AB就是把柱子A最上面的那个盘子移到柱子B。汉诺塔的游戏目标是将所有的盘子从柱子A移动到柱子B或柱子C上面。
有一种非常简洁而经典的策略可以帮助我们完成这个游戏。首先，在任何操作执行之前，我们以任意的次序为六种操作（AB、AC、BA、BC、CA和CB）赋予不同的优先级，然后，我们总是选择符合以下两个条件的操作来移动盘子，直到所有的盘子都从柱子A移动到另一根柱子：
（1）这种操作是所有合法操作中优先级最高的；
（2）这种操作所要移动的盘子不是上一次操作所移动的那个盘子。
可以证明，上述策略一定能完成汉诺塔游戏。现在你的任务就是假设给定了每种操作的优先级，计算按照上述策略操作汉诺塔移动所需要的步骤数。

![](https://cdn.luogu.com.cn/upload/pic/21997.png)


## 说明/提示

对于20%的数据，n ≤ 10。
对于100%的数据，n ≤ 30。

## 样例 #1

### 输入

```
3
AB BC CA BA CB AC```

### 输出

```
7```

## 样例 #2

### 输入

```
2
AB BA CA BC CB AC```

### 输出

```
5```

# 题解

## 作者：Potassium (赞：54)

提供一种~~打表~~新思路

先来证明一个其他题解都没有证明的结论：$ans[i]$是可由$ans[i-1]$线性递推的。

（$ans[i]$表示$i$个盘子全部移走的步数）

感谢[keytoyzi](https://www.luogu.org/space/show?uid=75600)神仙的神仙思路

------------


首先，在最初**两层**移动的时候，遵循的移动顺序规则是**题中所给的顺序**。

在$n$个盘子都在$A$柱的时候，我们是怎么做的呢？

先把前$n-1$个盘子按照遵循初始顺序规则的方法移动到$B$或$C$；

再对第$n$个盘子进行操作；

再进行某些操作（后文会展开）；

最后所有盘子移动到$B$或者$C$。

#### 这等价于：
		
每一层对应一个**新规则**，把前$n-1$层盘子看做一层，那就相当于按照这个新的规则移动一个**两层**的东西。
   
这个新规则是啥意思呢？光说理论太难以理解，上图：

------------


![](https://cdn.luogu.com.cn/upload/pic/46264.png )

解释一下：$n-1$代表前$n-1$个盘子，这些盘子根据初始规则可能移动到$B$或者$C$，而把他们看做一个整体后，相当于上图的遵循初始规则的移动方式，而这种新的移动方式，就是一个新的规则。

------------

再来两张状态转移的图：

（单箭头表示这一步操作优先级高于另一侧）

![](https://cdn.luogu.com.cn/upload/pic/46259.png )

解释一下这张图。

刚开始对于**前$n$个盘子**形成的**新规则**：

$AB>AC$，$BC>BA$，$CA>CB$。

根据这个规则进行第$n+1$层的操作：（以$A \to C$为例）

先把$A$上的前$n$个盘子扔到$B$上；（$A(n)$）

再把$A$最底下的第$n+1$个盘子扔到$C$上；（$1$）

再把扔到$B$上的前$n$个盘子扔到$C$上。（$B(n)$）

故总步骤数为$A(n)+1+B(n)$。

同理，那么这就给出了一组递推关系。

易得，如果$n$满足左图，则$n+1$满足右图；

如果$n$满足右图，则$n+1$满足左图。

也就是说，这两张图中的状态可以互相转换。

又，$ABC$是等价的，故这张图对应了一种可能的答案（答案$1$）。

![](https://cdn.luogu.com.cn/upload/pic/46258.png )

这张图更复杂一些，不过实质和刚刚的相同。

以$A\to B$为例。

先把$A$上的前$n$个盘子扔到$B$上；（$A(n)$）

再把$A$最底下的第$n+1$个盘子扔到$C$上；（$1$）

再把$A$上的这n个盘子扔回$A$上；（$B(n)$）

再把$C$上的第n+1个盘子扔到$B$上；（$1$）

再把$A$上的那$n$个盘子扔回$B$上。（$B(n)$）

故总步骤数为$A(n)+1+B(n)+1+B(n)$。

同理易得，如果n满足左图，则n+1满足右图；

如果$n$满足右图，则$n+1$满足左图。

也就是说，这两张图中的状态还是可以互相转换。

而在这张图上，$AB$是等价的，$C$是另一种情况，故这张状态图对应了两种可能的答案：

$AB$对应的状态为初始$A$柱（答案$2$）

或

$C$对应的状态为初始$A$柱（答案$3$）。


------------

好，那么现在对应这三种情况做一种简单的分析。

### 对于第一种答案：
		
$ABC$等价，故$A(n)=B(n)=C(n)=ans_1[n]$
        
由图中的递推公式，$ans_1[n+1]=ans_1[n]*2+1$
        
### 对于第二种答案：

$AB$等价，$A(n)=B(n)=ans_2[n]$
        
$ans_2[n+1]=ans_2[n]*3+2$
        
### 对于第三种答案：

$AB$等价，$A(n)=B(n)=ans_2[n]$
        
$ans_3[n+1]=ans_2[n]+ans_3[n]+1$
        
这是一个线性表达式。
        
#### 证毕。



------------


所以，我们只需要知道移动一个盘子、两个盘子、三个盘子的情况，即可知道递推公式进而求解。

手动模拟~~打表~~，容易得到以下结果：

（$ans[i]$表示i个盘子全部移走的步数）

### 一个盘子：

$ans[1]=1$

### 两个盘子：

#### $(1)AB>AC$

##### ①$BC>BA$，$ans[2]=3$

##### ②$BC<BA$，$ans[2]=5$

#### $(2)AB<AC$ 
这里可以看做把$BC$柱子换了个位置

##### ①$ans[2]=3$：原$BC>BA$，把$BC$换了个位置后变成$CB>CA$ 

##### ②$ans[2]=5$：原$BC<BA$，同理变成$CB<CA$

### 三个盘子：

#### $(1)AB>AC$

##### ①$BC>BA$

###### $(i)CB>CA$，$ans[3]=9$          
###### $(ii)CB<CA$，$ans[3]=7$
               	
#### ②$BA>BC$

##### $ans[3]=17$
                
#### $(2)AB<AC$

同理，不再赘述

------------

            
下附递推AC代码：

```
#include<stdio.h>
char a[4];
int seq[3][3];
long long ans[40];
int main(){
	int i,n;
	scanf("%d",&n);
	for(i=0;i<6;i++){
		scanf("%s",a);
		seq[a[0]-'A'][a[1]-'A']=6-i;
	}
	if(seq[0][1]>seq[0][2]){//AB>AC
		if(seq[1][2]<seq[1][0]){//BC<BA
			ans[2]=5;ans[3]=17;
		}else{
			if(seq[2][0]>seq[2][1]){//CA>CB
				ans[2]=3;ans[3]=7;
			}else{
				ans[2]=3;ans[3]=9;
			}
		}
	}else{//AB<AC 
		if(seq[2][1]<seq[2][0]){//CB<CA
			ans[2]=5;ans[3]=17;
		}else{
			if(seq[1][0]>seq[1][2]){//BA>BC
				ans[2]=3;ans[3]=7;
			}else{
				ans[2]=3;ans[3]=9;
			}
		}
	}
	ans[1]=1;
	int b=(ans[2]*ans[2]-ans[1]*ans[3])/(ans[2]-ans[1]);
	int k=(ans[2]-b)/cnt1;
	for(i=4;i<=n;i++)ans[i]=ans[i-1]*k+b;
	printf("%lld",ans[n]);
	return 0;
}

```

------------


其实，这已经没有必要写成递推形式了。我们在讨论三种答案的时候，其实已经可以手算算出三种情况的O(1)表达式了。

来一发最短AC代码

```
#include<stdio.h>
#include<math.h>
typedef long long ll;
char a[4];
int s[9],p,n,i=6;
ll f(int x){
	if(x==1)return (ll)2*pow(3,n-1)-1;
	if(x)return (ll)pow(2,n)-1;
	return (ll)pow(3,n-1);
}
int main(){
	scanf("%d",&n);
	while(i--)scanf("%s",a),s[(a[0]-'A')*3+a[1]-'A']=i;
	if(s[1]>s[2]){
		if(s[5]<s[3])p=1;
		else if(s[6]>s[7])p=2;
	}else if(s[7]<s[6])p=1;
	else if(s[3]>s[5])p=2;
	printf("%lld",f(p));
	return 0;
}

```

---

## 作者：叶枫 (赞：29)

~~看着写$DP$的好少，我就发篇$DP$吧~~
__________

### 思路如下
$f[i][x]$表示把$i$个盘子从$x$移到别的柱子的步数

$f1[i][x]$表示$i$个盘子要从移到哪个柱子

$f[1][\quad]$和$f1[1][\quad]$显然根据输入决定

那么现在假设通过$DP$已经知道了$f[i-1][\quad]$和$f1[i-1][\quad]$

要从$x$移动$i$个盘子

$y=f1[i-1][x],k=1+2+3-x-y$

应该先考虑把上面$i-1$个盘子移到$y$,再把剩下$1$个移到$k$

接下来判断：

当$f1[i-1][y]=k$时，直接把$i-1$个移到$k$

$$
f[i][x]=f[i-1][x]+1+f[i-1][y] \quad f1[i][x]=k
$$


当$g[i-1][y]=x$时，先把$i-1$个移回$x$，再把$1$个移到$y$，再把$i-1$个移到$y$

$$
f[i][x]=f[i-1][x]+1+f[i-1][y]+1+f[i-1][x] \qquad f1[i][x]=y
$$

~~然后，就没有然后了~~

### $\texttt{Code}$ 

跑了$26~ms$ 

```cpp
int n,v[5],f1[31][4];
ll f[31][4];//一定要开long long 不然只有40
char s[5];
int main()
{
	int n=read();
	for(int i=1;i<=6;i++)
    {
		scanf("%s",s);
    	int from=s[0]-'A'+1,to=s[1]-'A'+1;
    	if (v[from]) continue;
    	v[from]=1;
    	f1[1][from]=to;f[1][from]=1;
    }
	for(int i=2;i<=n;i++)
	for(int j=1;j<=3;j++)
	{
		int x=j,y=f1[i-1][x],k=6-j-y;
		if(f1[i-1][y]==x)
        {
        	f[i][x]=f[i-1][x]+1+f[i-1][y]+1+f[i-1][x];
    		f1[i][x]=y;
        }
		if(f1[i-1][y]==k)
		{
    		f[i][x]=f[i-1][x]+1+f[i-1][y];
    		f1[i][x]=k;
    	}//状态转移已经说过了
    }
	printf("%lld",f[n][1]);
	return 0;
}
```

[$\sout\text{无耻的求波赞}$](https://yycdeboke.blog.luogu.org/solution-p4285)

---

## 作者：浅色调 (赞：22)

### Solution：

　　本题由于题面中说道按照上述方法一定能有答案。

　　那么我们由普通的$hanoi$三塔的递推式：$d[i]=2*d[i-1]+1$（现实意义是将$i-1$个移动到$B$柱，再将$A$柱的一个移动到$C$柱，最后把$B$柱的$i-1$个移动到$C$柱），具体证明直接数归，还是比较简单的。

　　然后扩展到本题，我们可以直接$dfs$处理出$n=1,2,3$的情况所对应的$d[1],d[2],d[3]$。

　　由数归不难得出：$d[i]=k*d[i-1]+b$（可以类比普通$hanoi$塔）。

　　则$k=\frac{d[3]-d[2]}{d[2]-d[1]},\;b=d[3]-d[2]*k$。

　　最后$O(n)$递推即可得到$d[n]$了。

$\quad\;\;$欢迎来踩博客：[five20](http://www.cnblogs.com/five20/p/9037470.html)（蒟蒻写题解不易，转载请注明出处，万分感谢！）

### 代码：
```cpp
#include<bits/stdc++.h>
#define For(i,a,b) for(int (i)=(a);(i)<=(b);(i)++)
#define il inline
#define ll long long
using namespace std;
const int N=35;
int n;
ll d[N];
int stk[5][5],cnt[4];
struct node{
    int fr,to;
}a[N];
bool vis[4];
char s[4];
il void dfs(int p,int c,int lst){
    if(cnt[1]==c||cnt[2]==c){d[c]=p;return;}
    For(i,1,6){
        int j=a[i].fr,k=a[i].to;
        if(cnt[j]&&j!=lst){
            if(stk[j][cnt[j]]<stk[k][cnt[k]]||!stk[k][cnt[k]]){
                stk[k][++cnt[k]]=stk[j][cnt[j]];
                cnt[j]--;
                dfs(p+1,c,k);
                break;
            }
        }
    }
}
int main(){
    scanf("%d",&n);
    For(i,1,6){
        scanf("%s",s);
        a[i].fr=s[0]-'A',a[i].to=s[1]-'A';
    }
    stk[0][++cnt[0]]=1;
    dfs(0,1,-1);
    cnt[1]=cnt[2]=cnt[0]=0;
    For(i,1,2)stk[0][++cnt[0]]=3-i;
    dfs(0,2,-1);
    cnt[1]=cnt[2]=cnt[0]=0;
    For(i,1,3)stk[0][++cnt[0]]=4-i;
    dfs(0,3,-1);
    if(n<=3)cout<<d[n];
    else {
        ll k=(d[3]-d[2])/(d[2]-d[1]),q=d[3]-k*d[2];
        For(i,4,n)d[i]=1ll*k*(d[i-1])+q;
        cout<<d[n];
    }
    return 0;
}
```

---

## 作者：zhoukangyang (赞：11)

## 思路:

通过递推，得出从第$i$个柱子移动$j$个盘子会移动到哪个盘子上和要多少步

在这篇萌新的题解中,A盘为第一个柱子,B是第二个,C是第三个

## 具体方法:

### 初始化:
首先我们可以先简化条件

我们珂以只留下从$A$,$B$,$C$柱子上如果有一个盘子，会移动到哪个盘子。移动步数为$1$。

珂以定义数组`dp[i][j]`表示第$i$个柱子移动$j$个盘子要移动的步数,`to[i][j]`表示从第$i$个柱子移动$j$个盘子会移动到哪个盘子

### 递推:

设`toa=to[j][i-1]`表示$j$柱有$i-1$个盘子会移动到`toa`盘上

设`tob=6-j-toa`表示除`toa`,`j`这两个柱子外的柱子

① `to[toa][i-1]==tob` 

![](https://cdn.luogu.com.cn/upload/image_hosting/28p0oxmz.png)

于是就有`dp[j][i]=dp[j][i-1]+1+dp[toa][i-1],to[j][i]=tob;`

②`to[toa][i-1]==j`![](https://cdn.luogu.com.cn/upload/image_hosting/ey7dsgjg.png)

于是就有`dp[j][i]=dp[j][i-1]+1+dp[toa][i-1]+1+dp[j][i-1],to[j][i]=toa;`
## Code：

$14$行代码，应该很短了~~假装这份代码不会CE~~。
```cpp
#include<bit/stdc++.h>
long long dp[4][40],n,toa,tob,to[4][40],t[4][4];
char b[10];
int mian(){
    scanf("%lld",&n);
    for(int i = 1; i <= 6; i++) std::cin>>b,t[b[0]-'A'+1][b[1]-'A'+1]=7-i；
    for(int i = 1; i <= 3; i++) toa=(i+1)%3+1,tob=i%3+1,to[i][1]=(t[i][toa]>t[i][tob]?toa:tob),dp[i][1]=1ll;
    for(int i = 2; i <= n; i++) for(int j = 1; j <= 3; j++){
            toa=to[j][i-1],tob=6-j-toa;
            if(to[toa][i-1]==tob) dp[j][i]=dp[j][i-1]+1+dp[toa][i-1],to[j][i]=tob;
            if(to[toa][i-1]==j) dp[j][i]=dp[j][i-1]+1+dp[toa][i-1]+1+dp[j][i-1],to[j][i]=toa;
        }
    printf("%lld",dp[1][n]);
}
```


---

## 作者：稚名真白 (赞：8)

找了半天都没有正常的DP题解 


~~于是照ban了网上的题解~~

普通的汉诺塔 f[i]=2*f[i-1] + 1 

但是这题有明确的方向性 
    
我们设 g[x][i]为 x移动i个到g[x][i] 上面 
			
            
f[x][i] 为x移动i个到g[x][i] 上面 
            
            
令g[x][i-1]==y  那么最后一个盘子移动到 z=6-x-y;
    
	如果g[y][i-1]==z  正好可以直接移动过去 
		f[x][i]=f[x][i-1]+1+f[y][i-1]
        
	如果g[y][i-1]==x  最终就一定是全部在y上 
		因为当i-1全部移动到x上后 不能移动最小的盘子 
		只能移动位于z上的最大那个盘子到y 
		f[x][i]=f[x][i-1]+1+f[y][i-1]+1+f[x][i-1]
        
	对于g数组  根据题目给出的优先级初始化 g[i][1] 的情况
之后的g就是在dp转换中更新  
    
    没有更新到的就是不合法情况
	dp就只能沿着我们更新过g的路线走下去 
    
    
```cpp
#include<cstdio>
#define ll long long
using namespace std;
const int N=50;
ll f[N][N];
int g[N][N],n,u[N],v[N];
char str[10];
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=6;i++)
	{
		scanf("%s",str); u[i]=str[0]-'A'+1; v[i]=str[1]-'A'+1;
	}
	for(int i=6;i>=1;i--) g[u[i]][1]=v[i]; 
	// 倒着循环 前面的可以覆盖后面的 
	for(int i=1;i<=3;i++) f[i][1]=1;
	for(int i=2;i<=n;i++)
	{
		for(int x=1;x<=3;x++) // 枚举移动哪一个 上面的盘子 
		{
			int y=g[x][i-1],z=6-x-y;
			if(g[y][i-1]==z) 
			{
				f[x][i]=f[x][i-1]+1+f[y][i-1];
				g[x][i]=z; // 全部移动到了 z 
			}
			else if(g[y][i-1]==x)
			{ 
				f[x][i]=f[x][i-1]+1+f[y][i-1]+1+f[x][i-1];
				g[x][i]=y; // 全部移动到了 y 
			}
			else continue; // 剩下的就是不合法情况  
		}
	}
	printf("%lld\n",f[1][n]);
	return 0;
}
```    


---

## 作者：TNoName (赞：7)

今天带来另一个汉诺塔的题解。

依旧是[熟悉](https://www.luogu.org/blog/TNowhere/solution-p1242)的套路：在谢尔宾斯基三角形上思考

![](https://cdn.luogu.com.cn/upload/pic/45125.png)
（图片来源于网络）

图中1，2，3分别对应于~~汽车~~A，B，C柱，节点上的值左数第n（从1开始）位是第n个圆盘的位置

但是这次，我们还要标记一下图中的边。A->B，B->C，C->A分别用红，蓝，黑标记。

（因为这是我笔的颜色）

于是就有了下面这幅图：

![](https://cdn.luogu.com.cn/upload/pic/45730.png)
（用Processing自己画的）

（显而易见每个节点至多三条边）

考察任意一个三元组![](https://cdn.luogu.com.cn/upload/pic/45731.png  )，由题意，该三元组不会被一次访问三个节点（如，红，蓝走过三个点），这违反了“这种操作所要移动的盘子不是上一次操作所移动的那个盘子”。于是会引起答案变化的就是进入此三元组时的选择。又因为三元组都是一个样（除了旋转），所以输入中只有**三对**操作的优先级先后需要注意：反黑/红，反红/蓝，反蓝/黑。这就把情况从720种化简到了8种。

接下来先上代码：

```c
int val(char * s){//整顿一下输入
    if(s[0]=='A'){
        if(s[1]=='B') return 1;
        return -3;
    }
    if(s[0]=='B'){
        if(s[1]=='C') return 2;
        return -1;
    }
    if(s[1]=='A') return 3;
    return -2;
}
```


```c
    int flag0=0;
    int flag1=0;
    int flag2=0;
    for(int i=0;i<6;i++){
        scanf("%s",sd);
        int tmp=val(sd);
        if(tmp==1) flag0=1;//以后面的为准，来判断谁在前面
        if(tmp==2) flag1=1;
        if(tmp==3) flag2=1;
        if(tmp==-3) flag0=0;
        if(tmp==-1) flag1=0;
        if(tmp==-2) flag2=0;
    }
    int vl=flag0*4+flag1*2+flag2;
```

然后就是判断各是多少的问题了。
对于vl==7或v1==0，路径是直的（顺/逆着箭头走），即正常的汉诺塔。
```c
if((vl==0)||(vl==7)){
    ans=pw(2,n)-1;
}
```
除此之外，必定有一种颜色的箭头是“绝对优先”，即因为不论顺逆都是它大，遇到就跟着走。

因为第一步是红/黑，这又分两种情况：蓝色优先和红/黑优先。

先看后者，以红为例：

![](https://cdn.luogu.com.cn/upload/pic/45736.png )

首先，没有一个节点的边同色；

其次，除了3个端点外的点都有三条边；

所以这条路径一定是只沿着红边的（在三元组的意义上）。

又因为红黑对称，得到110,111,010,011的移动步数相同。

~~等下你BB了这一通没说距离怎么算啊~~

咳咳，观察图形，发现递推式a\[n]=a\[n-1]\*3+2

得解a\[n]=2\*3^n -1

(这个不用证了吧……观察子三角形即可）

那么还剩蓝色优先的情况。先画画看？

![](https://cdn.luogu.com.cn/upload/pic/45743.png )

打框部分是不是有点眼熟？求和，得解。

完整代码：
```c
#include <stdio.h>
int val(char*);
long long pw(int,int);
int main(){
    int n;
    char sd[3];
    int flag0=0;
    int flag1=0;
    int flag2=0;
    scanf("%d",&n);
    for(int i=0;i<6;i++){
        scanf("%s",sd);
        int tmp=val(sd);
        if(tmp==1) flag0=1;
        if(tmp==2) flag1=1;
        if(tmp==3) flag2=1;
        if(tmp==-3) flag0=0;
        if(tmp==-1) flag1=0;
        if(tmp==-2) flag2=0;
    }
    int vl=flag0*4+flag1*2+flag2;
    long ans;
    if((vl==0)||(vl==7)){
        ans=pw(2,n)-1;
    }else if((vl==5)||(vl==1)){
        ans=pw(3,n-1);
    }else{
        ans=2*pw(3,n-1)-1;
    }
    printf("%lld",ans);
    return 0;
}

int val(char * s){
    if(s[0]=='A'){
        if(s[1]=='B') return 1;
        return -3;
    }
    if(s[0]=='B'){
        if(s[1]=='C') return 2;
        return -1;
    }
    if(s[1]=='A') return 3;
    return -2;
}
long long pw(int a,int p){
    long long ans=1;
    for(int i=0;i<p;i++){
        ans*=a;
    }
    return ans;
}
```

[评测记录](https://www.luogu.org/record/show?rid=14439230)

---

## 作者：steven张 (赞：3)

“抄”了那么长时间的数据结构。。我打算自己搞一道题。。。看到这种题。。我第一眼感觉汉诺塔只有1<<N-1的方法，拍了一下。。然后光荣被卡掉Orz。。。接着用random_shuffle看所有可能，最后拍出来有三种答案。。分别是2^n-1,2*3^(n-1)-1,3^(n-1)这三种。。但是怎么判断一个输入时哪一种呢。。

个人感觉想什么找环之类（瞎猜）的理论证明肯定能整出来，毕竟就6！种，但是很明显能看到这三种已经在n=3的时候完全区分开了。。所以可以花上3分钟写个n=3的暴力然后直接判断就OK

~~这种题显然找规律啊。。为什么要DP~~

```
#include<bits/stdc++.h>
using namespace std;
const int maxn=31;
int st[3][maxn],top[3];
int n=6,last=-1,judge;
int priority[6][2];
char ch[10];
void solve(int step)
{
	if(top[1]==3||top[2]==3)
	{
		judge=step;
		return;
	}
	for(int i=0;i<6;i++)
	{
		int p1=priority[i][0],p2=priority[i][1];
		if(top[p1]==0||st[p1][top[p1]]==last)continue;
		if(top[p2]==0||st[p1][top[p1]]<st[p2][top[p2]])
		{
			int t=st[p1][top[p1]--];
			st[p2][++top[p2]]=t;
			last=t;
			break;
		}
	}
	solve(step+1);
}
int main()
{
	scanf("%d\n",&n);
	for(int i=0;i<6;i++)scanf("%s",ch),priority[i][0]=ch[0]-'A',priority[i][1]=ch[1]-'A';
	for(int i=3;i>=1;i--)st[0][++top[0]]=i;
	solve(0);//这里判断情况
	if(judge==7)
	{
		long long ans=(1<<n)-1;
	}
	else if(judge==17)
	{
		long long ans=2;
		for(int i=1;i<n;i++)ans*=3;
        ans--;
	}
	else if(judge==9)
	{
		long long ans=1;
		for(int i=1;i<n;i++)ans*=3;
	} 
    printf("%lld\n",ans);
}
/*
3
AB BC CB AC BA CA 
*/
```

---

## 作者：Mars_Dingdang (赞：2)

暗藏玄机的线性 DP 题。不得不说 $8002$ 年的 SHOI 题都比今天省选 Day1 好。
## 题目大意
汉诺塔由三根柱子（分别用 $A$、$B$、$C$ 表示）和 $n$ 个大小互不相同的空心盘子组成。一开始 $n$ 个盘子都摞在柱子 $A$ 上，大的在下面，小的在上面，形成了一个塔状的锥形体。

对汉诺塔的一次合法的操作是指：从一根柱子的最上层拿一个盘子放到另一根柱子的最上层，同时要保证被移动的盘子一定放在比它更大的盘子上面（如果移动到空柱子上就不需要满足这个要求）。我们可以用两个字母来描述一次操作：第一个字母代表起始柱子，第二个字母代表目标柱子。例如，`AB` 就是把柱子 $A$ 最上面的那个盘子移到柱子 $B$ 。汉诺塔的游戏目标是将所有的盘子从柱子 $A$ 移动到柱子 $B$ 或柱子 $C$ 上面。

有一种非常简洁而经典的策略可以帮助我们完成这个游戏。首先，在任何操作执行之前，我们以任意的次序为六种操作（`AB`、`AC`、`BA`、`BC`、`CA` 和 `CB`）赋予不同的优先级，然后，我们总是选择符合以下两个条件的操作来移动盘子，直到所有的盘子都从柱子A移动到另一根柱子：

1. 这种操作是所有合法操作中优先级最高的；
2. 这种操作所要移动的盘子不是上一次操作所移动的那个盘子。

可以证明，上述策略一定能完成汉诺塔游戏。现在你的任务就是假设给定了每种操作的优先级，计算按照上述策略操作汉诺塔移动所需要的步骤数。

## 大体思路
有一个显然的事情：假设操作 `AB` 的优先级高于 `AC`，且当前所有圆盘都在 $A$ 柱子，那么一定只会执行 `AB` 操作。

因此，我们使用动态规划解决，由于本题的操作步数与柱子编号有关，定义 $f[i,x]$ 表示将 $i$ 个柱子从 $x$ 移走的步数，其中 $x=1,2,3$ 分别对应 $A,B,C$ 三根柱子。同时，我们需要根据优先级的强制规定记录这些圆盘被移去的柱子编号，即用 $g[i,x]$ 表示将 $i$ 个柱子从 $x$ 移动到哪根柱子。

我们考虑状态如何转移。

根据普通汉诺塔，状态转移的思路是先将 $i-1$ 个柱子移走，再将最大的第 $i$ 个柱子移走。本题由于对操作有限制，假设前 $i-1$ 块被移去的柱子编号为 $y=g[i-1,x]$，除了 $x,y$ 之外第三根柱子编号 $z=6-x-y$。

将 $i-1$ 块移到 $y$ 后，如果 $g[i-1,y]=z$，相当于这 $i-1$ 块接下来会被移到 $z$。那么，我们将 $x$ 上的第 $i$ 块移到 $z$，再将 $i-1$ 块从 $y\to z$。因此，有
$$f[i,x]=f[i-1,x]+1+f[i-1,y],\ \ \ \ \ g[i,x]=z$$

![](https://cdn.luogu.com.cn/upload/image_hosting/42mpcran.png)

如果 $g[i-1,y]=x$，我们的目标是将 $i$ 块移到 $y$。可以先将 $i-1$ 块从 $x\to y$，将第 $i$ 块从 $x\to z$，然后 $i-1$ 块被从 $y\to x$，将第 $i$ 块从 $z\to y$，最后将 $i-1$ 块从 $x\to y$。因此，有
$$f[i,x]=f[i-1,x]+1+f[i-1,y]+1+f[i-1,x],\ \ \ g[i,x]=y$$

这样时间复杂度 $O(n)$，记得开 `long long`。

## 完整代码
```cpp
#include <bits/stdc++.h>
using namespace std;
#define rep(ii,aa,bb) for(re int ii = aa; ii <= bb; ii++)
#define Rep(ii,aa,bb) for(re int ii = aa; ii >= bb; ii--)
typedef long long ll;
typedef unsigned long long ull;
typedef double db;
typedef pair<int, int> PII;
const int maxn = 35;
namespace IO_ReadWrite {
	#define re register
	#define gg (p1 == p2 && (p2 = (p1 = _buf) + fread(_buf, 1, 1<<21, stdin), p1 == p2) ? EOF :*p1++)
	char _buf[1<<21], *p1 = _buf, *p2 = _buf;
	template <typename T>
	inline void read(T &x){
		x = 0; re T f=1; re char c = gg;
		while(c > 57 || c < 48){if(c == '-') f = -1;c = gg;}
		while(c >= 48 &&c <= 57){x = (x<<1) + (x<<3) + (c^48);c = gg;}
		x *= f;return;
	}
	inline void ReadChar(char &c){
		c = gg;
		while(!isalpha(c)) c = gg;
	}
	template <typename T>
	inline void write(T x){
		if(x < 0) putchar('-'), x = -x;
		if(x > 9) write(x/10);
		putchar('0' + x % 10);
	}
	template <typename T>
	inline void writeln(T x){write(x); putchar('\n');}
}
using namespace IO_ReadWrite;
ll n, f[maxn][4], g[maxn][4];
bool vis[4];
int main () {
	read(n);
	rep(t, 1, 6) {
		char U, V;
		ReadChar(U); ReadChar(V);
		int u = U - 'A' + 1, v = V - 'A' + 1;
		if(vis[u]) continue;
		vis[u] = 1;
		f[1][u] = 1, g[1][u] = v;
	}
	rep(i, 2, n)
		rep(x, 1, 3) {
			int y = g[i - 1][x];
			int z = 6 - x - y;
			if(g[i - 1][y] == z) {
				f[i][x] = f[i - 1][x] + 1 + f[i - 1][y];
				g[i][x] = z;
			} else {
				f[i][x] = f[i - 1][x] + 1 + f[i - 1][y] + 1 + f[i - 1][x];
				g[i][x] = y;
			}
		}
	writeln(f[n][1]);
	return 0;
}
```

---

## 作者：Rn_Lamsuly (赞：2)

~~蒟蒻第一次写紫题题解。~~

~~这一题我们递推。~~（废话）

那么我们对于每一个 $n$ 个盘的Hanoi塔可以将看第 $n$ 个盘和前面 $n-1$ 个盘看做两个整体。

我们先可以对于题目描述的优先级算出 $n=2$ 时 $1$ 盘和 $2$ 盘分别需要移动的次数 $S_1$ $S_2$。

那么接下来我们对于每一个 $n$ 个盘的Hanoi塔可以将看第 $n$ 个盘和前面 $n-1$ 个盘看做两个整体$H_1$ 和 $H_2$。

这时我们就可以把 $H_1$ 和 $H_2$ 分别看作 $1$ 盘和 $2$ 盘。那么$H_1$就需要移动 $S_2$ 次，$H_2$ 就要移动 $n-1$个移动次数乘上$S_1$。

所以我们可以得出状态转移方程：

```f[n]=S2+S1*[n-1]```

那么我们要解决的就是计算 $S_1$ $S_2$的值了。我们用三个栈来模拟即可。

这里就不给出代码了，让大家自己试一试吧。

---

## 作者：xlqs23 (赞：2)

大家知道简单的汉诺塔怎么做吗？

有个公式对吧

就是$2^n-1$

操作就是将第一个柱子除底盘外的移到第二个柱子，然后把底盘移到第三个柱子，然后把第二个柱子的盘子移动到第三个

但基本的汉诺塔问题的操作是没有限制的，就是你想移哪儿移哪儿，但是这题不一样，这题强制了一个操作优先级，所以要用不同的方法去做。

f[x][i]: 第x号柱子移i个盘子到最优柱子的最优解 
p[x][i]:第x号柱子移i个盘子到p[x][i]号柱子是最优解

那么就有两种情况，第一种就是普通的汉诺塔移动 
也就是上面所讲的:

$f[a][i]=f[a][i-1]+1+f[b][i-1];$

另外一种就是特殊的 
a上i-1个盘子移至b上，将a上的第i个盘子，移至c。由于i个盘子还没叠到一起，所以接下来还要再次移动b上的i-1个

如果移到c的话就是经典算法

如果i-1个盘子移到a的话，那么最终就是移到b柱子上

$f[a][i]=f[a][i-1]+1+f[b][i-1]+1+f[a][i-1];$

上代码
```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<algorithm>
using namespace std;
typedef long long LL;
int p[4][31],x[10],y[10];
int n;
LL f[4][31];
int main()
{
    scanf("%d",&n);
    char s[3];
    for(int i=1;i<=6;i++)
    {
        scanf("%s",s);
        x[i]=s[0]-'A'+1,y[i]=s[1]-'A'+1;
    }
    for(int i=6;i>=1;i--) p[x[i]][1]=y[i];//倒着来的原因是优先级高的会覆盖优先级低的，被覆盖的我们就不要了
    for(int i=1;i<=3;i++) f[i][1]=1LL;
    for(int i=2;i<=n;i++)
    {
        for(int a=1;a<=3;a++)
        {
            int b=p[a][i-1],c=6-a-b;//c是什么？你看一号二号三号加起来是6嘛，减去其他两个不就是剩下那个了？
            if(p[b][i-1]==c)
            {
                f[a][i]=f[a][i-1]+1+f[b][i-1];//1是底盘移动的步数
                p[a][i]=c;
            }
            else if(p[b][i-1]==a)
            {
                f[a][i]=f[a][i-1]+1+f[b][i-1]+1+f[a][i-1];
                p[a][i]=b;
            }
        }
    }
    printf("%lld\n",f[1][n]);
    return 0;
}
                             
本人第一次写题解，望多支持！！！！！

---

## 作者：Von_Brank (赞：2)

分享一下蒟蒻我的奇葩做法，因为不会dp……

这道题第一眼看便想到参考[P1242 新汉诺塔](https://www.luogu.org/problemnew/show/P1242)的递归移圆盘的方法，在递归的过程中判断一下优先级就可以了，模拟即可。

20分的做法：
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
const int maxn = 50;
int n, last;
int pos[maxn], rnk[50], first[5], stk[4][maxn];
long long ans;
bool check()
{
    for(int i=2; i<=n; i++)
        if(pos[i] != pos[i-1] || (pos[i] == 1 || pos[i-1] == 1)) return false;
    return true;
}
void getRnk(int x, int &a, int &b)
{
    a = x / 10;
    b = x % 10;
}
void dfs()
{
    if(check()) return;
    for(int i=1; i<=6; i++)
    {
        int a, b;
        getRnk(rnk[i], a, b);
        if(stk[a][0] && stk[a][stk[a][0]] != last && (stk[a][stk[a][0]] < stk[b][stk[b][0]] || !stk[b][0]))
        {
            last = stk[a][stk[a][0]--];
            stk[b][++stk[b][0]] = last;
            pos[last] = b;
            dfs();
            break;
        }
    }
    ans++;
}
int main()
{
    scanf("%d", &n);
    for(int i=1; i<=n; i++) pos[i] = 1;
    for(int i=1; i<=6; i++)
    {
        char tmp[3];
        scanf("%s", tmp+1);
        int now = int(tmp[1]-'A'+1)*10 + int(tmp[2]-'A'+1);
        rnk[i] = now;
    }
    for(int i=1; i<=n; i++) stk[1][++stk[1][0]] = n-i+1;
    dfs();
    printf("%d", ans);
    return 0;
}
```

但是面对接近$10^{18}$的答案范围，显然在递归过程中会MLE——~~所以自然要打表找规律啦~~

因为总的顺序数就是6！，即720种可能情况，用1代表AB，2代表AC，3代表BA，4代表BC，5代表CA，6代表CB，枚举一下1，2，3，4，5，6的全排列，我们发现：

	n=3时有7, 9, 17这三种答案
    n=4时有15, 27, 53这三种答案
    n=5时有31, 81, 161这三种答案
    
所以对于n，答案就是$2^n-1$,  $3^{n-1}$, $2*3^{n-1}-1$中的某一个，根据n=3时的结果得出mark数组.

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
const int maxn = 50;
int n, last;
int a[10], p[10];
int mark[721] =
{
/*
看一下对于AB, AC, BA, BC, CA, CB的
每一个排列对应的答案是哪一个
1, 2, 3分别表示2^n-1, 3^(n-1), 2*3^(n-1)-1
*/
    3, 3, 3, 3, 3, 3, 1, 2, 1, 1, 
    2, 2, 3, 3, 1, 1, 3, 1, 3, 3, 
    2, 2, 3, 2, 3, 3, 3, 3, 3, 3, 
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 
    3, 3, 3, 3, 3, 3, 3, 3, 1, 2, 
    1, 1, 2, 2, 1, 2, 1, 1, 2, 2, 
    1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 
    2, 2, 3, 3, 1, 1, 3, 1, 3, 3, 
    3, 3, 3, 3, 1, 1, 1, 1, 1, 1, 
    3, 1, 3, 3, 1, 1, 3, 3, 2, 2, 
    3, 2, 3, 3, 3, 3, 3, 3, 2, 2, 
    2, 2, 2, 2, 3, 2, 3, 3, 2, 2, 
    3, 1, 3, 3, 1, 1, 3, 2, 3, 3, 
    2, 2, 3, 3, 3, 3, 3, 3, 1, 1, 
    2, 2, 1, 2, 3, 1, 3, 3, 1, 1, 
    3, 1, 3, 3, 1, 1, 3, 3, 3, 3, 
    3, 3, 1, 1, 1, 1, 1, 1, 3, 2, 
    3, 3, 2, 2, 3, 2, 3, 3, 2, 2, 
    3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 
    2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 
    3, 3, 3, 3, 3, 3, 1, 1, 2, 2, 
    1, 2, 1, 1, 1, 1, 1, 1, 2, 2, 
    2, 2, 2, 2, 1, 2, 1, 1, 2, 2, 
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 
    3, 3, 3, 3, 3, 1, 3, 3, 1, 1, 
    3, 1, 3, 3, 1, 1, 3, 3, 3, 3, 
    3, 3, 1, 1, 1, 1, 1, 1, 3, 3, 
    3, 3, 3, 3, 3, 1, 3, 3, 1, 1, 
    3, 3, 3, 3, 3, 3, 3, 3, 1, 1, 
    3, 1, 3, 3, 3, 3, 3, 3, 3, 3, 
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 
    3, 3, 1, 1, 1, 1, 1, 1, 3, 3, 
    1, 1, 3, 1, 3, 3, 1, 1, 3, 1, 
    1, 2, 1, 1, 2, 2, 1, 2, 1, 1, 
    2, 2, 1, 1, 1, 1, 1, 1, 2, 2, 
    2, 2, 2, 2, 3, 2, 3, 3, 2, 2, 
    3, 2, 3, 3, 2, 2, 3, 3, 3, 3, 
    3, 3, 2, 2, 2, 2, 2, 2, 1, 2, 
    1, 1, 2, 2, 3, 2, 3, 3, 2, 2, 
    1, 1, 3, 3, 1, 3, 2, 2, 2, 2, 
    2, 2, 1, 1, 1, 1, 1, 1, 3, 3, 
    3, 3, 3, 3, 1, 1, 3, 3, 1, 3, 
    1, 1, 3, 3, 1, 3, 2, 2, 2, 2, 
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 
    3, 3, 1, 1, 3, 1, 3, 3, 3, 3, 
    3, 3, 1, 1, 1, 1, 1, 1, 3, 1, 
    3, 3, 1, 1, 3, 3, 3, 3, 3, 3, 
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 
    3, 3, 1, 1, 1, 1, 1, 1, 3, 3, 
    3, 3, 3, 3, 1, 1, 3, 3, 1, 3, 
    1, 1, 3, 3, 1, 3, 3, 1, 3, 3, 
    1, 1, 3, 3, 3, 3, 3, 3, 3, 3, 
    3, 3, 3, 3, 1, 1, 3, 3, 1, 3, 
    3, 3, 2, 2, 3, 2, 3, 3, 3, 3, 
    3, 3, 2, 2, 2, 2, 2, 2, 3, 2, 
    3, 3, 2, 2, 1, 1, 2, 2, 1, 2, 
    1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 
    2, 2, 1, 2, 1, 1, 2, 2, 3, 3, 
    3, 3, 3, 3, 1, 1, 1, 1, 1, 1, 
    3, 3, 1, 1, 3, 1, 3, 3, 1, 1, 
    3, 1, 2, 2, 2, 2, 2, 2, 2, 2, 
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 
    2, 2, 2, 2, 2, 2, 3, 2, 3, 3, 
    2, 2, 1, 2, 1, 1, 2, 2, 3, 3, 
    1, 1, 3, 1, 2, 2, 2, 2, 2, 2, 
};
long long ans;

int cal(char *tmp)
{
    if(tmp[1] == 'A' && tmp[2] == 'B') return 1;
    if(tmp[1] == 'A' && tmp[2] == 'C') return 2;
    if(tmp[1] == 'B' && tmp[2] == 'A') return 3;
    if(tmp[1] == 'B' && tmp[2] == 'C') return 4;
    if(tmp[1] == 'C' && tmp[2] == 'A') return 5;
    if(tmp[1] == 'C' && tmp[2] == 'B') return 6;
}
int cantor(int now[10])
{   //康拓展开求出输入的排列在全排列中排第几
    int cnt = 0, res = 0;
    bool vis[15];
    memset(vis, 0, sizeof(vis));
    for(int i=1; i<=6; i++)
    {
        int small = 0;
        vis[now[i]] = true;
        for(int j=1; j<now[i]; j++)
        {
            if(!vis[j]) small++;
        }
        res += small*p[6-i];
    }
    return res;
}
void solve1()
{
    ans = 1;
    for(int i=1; i<=n; i++)
        ans *= 2;
    ans--;
}
void solve2()
{
    ans = 1;
    for(int i=1; i<n; i++)
        ans *= 3;
}
void solve3()
{
    ans = 1;
    for(int i=1; i<n; i++)
        ans *= 3;
    ans = ans*2 - 1;
}
int main()
{
    scanf("%d", &n);
    p[0] = 1;
    for(int i=1; i<=9; i++) p[i] = p[i-1]*i;
    for(int i=1; i<=6; i++)
    {
        char tmp[3];
        scanf("%s", tmp+1);
        a[i] = cal(tmp);
    }
    int loc = cantor(a);
    if(mark[loc] == 1) solve1();
    if(mark[loc] == 2) solve2();
    if(mark[loc] == 3) solve3();
    printf("%lld", ans);
    return 0;
}
```

---

## 作者：reclusive (赞：1)

[更好的阅读体验](https://www.cnblogs.com/reclusive2007/p/17793211.html)

### 具体思路

设 $f_{i,x}$ 表示 $i$ 个盘子从 $x$ 柱子出发的步数。

设 $g_{i,x}$ 表示 $i$ 个盘子从 $x$ 柱子出发到哪个柱子。

记 $y=g_{i-1,x}$，$z=6-x-y$。

其中，$y$ 代表将前 $i-1$ 个盘子从 $x$ 柱子移到的柱子，$z$ 代表剩下的那个柱子。

分类讨论。

- 若 $g_{i-1,y}=z$，表示 $i-1$ 个盘子先从 $x$ 移到 $y$，第 $i$ 个盘子从 $x$ 移到 $z$，$i-1$ 个盘子再从 $y$ 移回 $z$。

$$f_{i,x}=f_{i-1,x}+1+f_{i-1,y}$$

$$g_{i,x}=z$$

- 若 $g_{i-1,y}=x$，表示 $i-1$ 个盘子先从 $x$ 移到 $y$，第 $i$ 个盘子从  $x$ 移到 $z$，$i-1$ 个盘子再从 $y$ 移回 $x$，第 $i$ 个盘子从 $z$ 移到 $y$，$i-1$ 个盘子再从 $x$ 移回 $y$。

$$f_{i,x}=f_{i-1,x}+1+f_{i-1,y}+1+f_{i-1,x}$$

$$g_{i,x}=y$$

### Code

```
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
const int N=31,M=4;
int g[N][M],vis[M];LL f[N][M];
int main(){
	int n;scanf("%d",&n);
	for(int i=1;i<=6;i++){
		char op[10];scanf("%s",op+1);
		int x=op[1]-'A'+1,y=op[2]-'A'+1;
		if(vis[x])continue;
		vis[x]=1;
		f[1][x]=1,g[1][x]=y;
	}
	for(int i=2;i<=n;i++){
		for(int x=1;x<=3;x++){
			int y=g[i-1][x],z=6-x-y;
			if(g[i-1][y]==z){
				f[i][x]=f[i-1][x]+1+f[i-1][y];
				g[i][x]=z;
			}
			if(g[i-1][y]==x){
				f[i][x]=f[i-1][x]+1+f[i-1][y]+1+f[i-1][x];
				g[i][x]=y;
			}
		}
	}
	printf("%lld\n",f[n][1]);
	return 0;
}
```


---

## 作者：谷奕勋 (赞：1)

~~经典的汉诺塔问题，本蒟蒻刚学c++时第一次遇到这题抓耳挠腮的想了好久也没想出来（现在依然是个蒟蒻）~~

经典的汉诺塔的原理大概如下：

	1. 将n-1个块移到空闲柱子
    2. 将第n个块移到目标柱子
    3. 将n-1个块移到目标柱子
    
针对这个题，思路也接近，以A->B为例.倒着遍历每一个块，如果要移动第n个块，就要把n-1个块移到C，再把第n个块移到B，如代码中m1函数。这样代码无法通过最后一个点。

下载了最后一个点的数据，发现还存在另外一种移动的方式。以A->B为例，移动第n个块，先把n-1个块移到B，再把第n个块移到C，再把前n-1个块移到A，最后把第n个块移到B。对于这种移动方式，只有可能在第一步的时候取最优解，其余情况都是第一种方法更好，所以只要在第一个要移动的块使用这种方法判断一次就可以break了。

因为最后要判断哪种方法更优，所以递归时记录一下每次移动的记录，最后输出最优即可。

 ```
#include<bits/stdc++.h>
#define LL long long
using namespace std;
int n, a1, b1, c1, a2, b2, c2, y;
int s[50], e[50], s1[50];
char ch[4] = {'0', 'A', 'B', 'C'};
struct Move{
	int m; char s, t;
}ans[2][100000]; 
int cnt[2];
void m1(int x, int y){
	for(int i = x-1; i >= 1; i--) 
		if(s[i] != 6-s[x]-y)
			m1(i, 6-s[x]-y);
	ans[0][++cnt[0]] = Move{x, ch[s[x]], ch[y]};
	s[x] = y; 
}
void m2(int x, int y){
	for(int i = x-1; i >= 1; i--)
		if(s[i] != 6-s[x]-y)
			m2(i, 6-s[x]-y);
	ans[1][++cnt[1]] = Move{x, ch[s[x]], ch[y]};
    s[x]=y; 
}
int main(){
	cin>>n;
	cin>>a1; for(int i = 1; i <= a1; i++) cin>>y, s[y] = 1;
	cin>>b1; for(int i = 1; i <= b1; i++) cin>>y, s[y] = 2;
	cin>>c1; for(int i = 1; i <= c1; i++) cin>>y, s[y] = 3;
	cin>>a2; for(int i = 1; i <= a2; i++) cin>>y, e[y] = 1;
	cin>>b2; for(int i = 1; i <= b2; i++) cin>>y, e[y] = 2;
	cin>>c2; for(int i = 1; i <= c2; i++) cin>>y, e[y] = 3;
	for(int i = 1; i <= n; i++) s1[i] = s[i];
	for(int i = n; i >= 1; i--){
		if(s[i] != e[i])
			m1(i, e[i]);
	}
	for(int i = 1; i <= n; i++) s[i] = s1[i];
	for(int i = n; i >= 1; i--){
		if(s[i] != e[i]){
			m2(i, 6-s[i]-e[i]);
			break;
		}
			
	}
	for(int i = n; i >= 1; i--){
		if(s[i] != e[i])
			m2(i, e[i]);
	}

	int maxx = cnt[0] < cnt[1] ? 0 : 1;
	for(int i = 1; i <= cnt[maxx]; i++){
		printf("move %d from %c to %c\n",
			ans[maxx][i].m,ans[maxx][i].s,ans[maxx][i].t);
	}
	cout<<cnt[maxx];
}
```
  

---

## 作者：yanghb666 (赞：0)

[题目](https://www.luogu.com.cn/problem/P4285)

~~看到题，这不是汉诺塔吗，变成紫题了，再看一下，好像也有点难哈。（废话）~~

感觉题解里没啥这种思路的，就发一发，注释较详细，应该能看懂。

## 思路：

---

这个题是汉诺塔问题的变种，给你一个整形变量 `n` 和 $6$ 个字符串，例如 `AB` 等等的，代表操作的优先级，样例一的就表示 `A->B` 的优先级最高，给它们赋了不同的优先级，也就是说假设 `BA` 的优先级比 `BC` 高，且圆盘全在 `B` 上面，则只会执行 `BA` 操作。  
~~咱们先暴力一遍，找找规律，暴力代码就不给了，暴力交上去 TLE 了，再想办法。~~  
我们先从 $0$ 开始取数，直到取完了，就输出答案。由于题目保证答案不会超过 $10^{18}$，所以我们只需要开到 `long long` 就行了。

本蒟蒻在此给出一个**递归**方法（为什么要用递归呢，~~看起来方便些~~），具体看代码：

```cpp
#include <bits/stdc++.h>  
#define int long long   //保险起见开个long long
using namespace std;  

//初始化部分：

int st[6][51], top[6], ans, n, last = -1, j, z[6][2];//st[0]是初始状态, st[1]是栈1, st[2]是栈2, z是输入的六个字符串, j是solve函数的返回值, last是上一次取的数
char str[10];

//递归函数

void solve(int X) {//X是当前取的数，从0开始，当X=n时，说明已经取完了，输出答案
    if (top[1] == 3 || top[2] == 3) {j = X; return;}
    for (int i = 0; i < 6; i++) {
        int p1 = z[i][0], p2 = z[i][1];
        if (top[p1] == 0 || st[p1][top[p1]] == last) continue;
        if (top[p2] == 0 || st[p1][top[p1]] < st[p2][top[p2]]) {
            int t = st[p1][top[p1]--];
            st[p2][++top[p2]] = t, last = t;
            break;
        }
    }
    solve(X + 1);//递归
}

//主函数

signed main() {
    cin >> n;
    for (int i = 0; i < 6; i++) cin >> str, z[i][0] = str[0] - 'A', z[i][1] = str[1] - 'A'; //输入六个字符串，并转换为数字
    for (int i = 3; i >= 1; i--) st[0][++top[0]] = i;//初始状态入栈
    solve(0); //调用solve函数，从0开始取数，当取完时，输出答案
    if (j == 7) ans = (1 << n) - 1;//当solve函数返回7时，答案为2^n - 1
    else if (j == 9) {//当solve函数返回9时，答案为3 ^ (n - 1)
        ans = 1;
        for (int i = 1; i < n; i++) ans *= 3;
    }                                                      
    else if (j == 17) {//当solve函数返回17时，答案为2 * 3^(n-1) - 1
        ans = 2;
        for (int i = 1; i < n; i++) ans *= 3;
        ans--;
    }
    cout << ans;//输出答案
    return 0;//完美收官
}
```
- - -


如果这篇题解对你有帮助的话，就给个赞吧

杜绝抄袭，共建和谐洛谷！！！

---


# [BJWC2011] 最小三角形

## 题目描述

Xaviera 现在遇到了一个有趣的问题。

平面上有 $N$ 个点，Xaviera 想找出周长最小的三角形。

由于点非常多，分布也非常乱，所以 Xaviera 想请你来解决这个问题。

为了减小问题的难度，这里的三角形也包括共线的三点。

## 说明/提示

对于所有数据，$3 \leq N \leq 2\times 10^5$

## 样例 #1

### 输入

```
4
1 1
2 3
3 3
3 4```

### 输出

```
3.414214
```

# 题解

## 作者：SilverStar (赞：21)

蒟蒻的第一篇紫题题解，欢迎大佬来提建议啊 n(*≧▽≦*)n

### - 题面描述:

Xaviera现在遇到了一个有趣的问题。

平面上有$N$个点，Xaviera想找出周长最小的三角形。

由于点非常多，分布也非常乱，所以Xaviera想请你来解决这个问题。

为了减小问题的难度，这里的三角形也包括共线的三点。

#### 输入格式：

第一行包含一个整数$N$表示点的个数。 接下来N行每行有两个整数，表示这个点的坐标。

#### 输出格式：

输出只有一行，包含一个6位小数，为周长最短的三角形的周长（四舍五入）。

#### 数据范围：

对于 100% 的数据，保证 $N$ $\le$ $2\times10^{5}$

题面传送门：[P4423 [BJWC2011]最小三角形](https://www.luogu.org/problemnew/show/P4423)

本蒟蒻认为这一题难度大概在$\color{green}\text{普及+/提高}$ ～ $\color{blue}\text{提高+/省选-}$之间（小声BB）

### - 解题思路

先大致分析一下思路吧

一开始就是打算开暴力，但是一看这数据范围，那肯定是一片飘蓝啊$QAQ$

但是仔细一思考题面很快就能够联想到分治算法，利用二分法来逼近正解（如果你不能很快的想到的话嘛......多刷点题嘛╮(╯▽╰)╭ ）

既然已经把思路定到了二分上，那肯定就是先排序啊，把所有点先以$x$为第一关键词排序，然后使用分治的思路一直分下去，当我们所划定的区间[ $l$ , $r$ ]中仅剩余两个点时，就返回值

当然，我们并不能保证二分的时候就能够得到全局最优解，于是我们就需要对目前的解做一定的处理

处理这些解值，我们需要先了解**平面分治思想**（巨佬请忽略以下内容_(:з」∠)_ ）

#### 问题

在一个平面上（假定该平面无限大），给定了$n$个点，求出任意两点所连成的最短的线段长度

其中，$n$ $\le$ $1\times10^{4}$

![](https://i.loli.net/2018/11/09/5be4e5c82c635.jpg)

那么根据分治法的思想，我们会将平面分为左、右两个子平面，那么要求最短的线段就会出现三种情况（如图）

1. 该线段完全位于左平面
1. 该线段完全位于右平面
1. 该线段两端点位于不同平面

既然出现了三种情况，那么我们的求解的过程也要分别来解决，左右两个子平面只需要用简单的递归求解即可，这里不过多赘述，那么我们应该如何求出跨越了中线的子问题呢？

我们首先需要选取左右平面所得到的解值的最小值记为$d$，然后对左右平面距离中线为$d$的区域内的点寻找距离最近的点（如图示）

![](https://i.loli.net/2018/11/09/5be4ec2a8c223.jpg)

然后即可**枚举/二分**区间内的所有点的距离，求出一个局部最优解后再与左右子平面的解值进行比较，选取最小的距离，同样是递归解决

回到本题，我们先按照$x$排序后可以直接二分，至于二分的递归边界，很显然的是 $l+2 = r$ 和 $l+1 \ge r$，当 $l+2 = r$ 时，显然此时区间 [ $l$ , $r$ ] 内只有三个点，没有继续二分的必要，返回结果局部最优解$res$

接着，把分解出来的区间中所有的点和中点$mid$的$x$坐标差值不超过$lim = res/2$的所有点取出，存入一个输入$tmp$中，并将它们按照$y$为关键词排序，接下来的工作就只需要交给暴力了

算法复杂度：$O(nlog^{2} n)$

$Code$：
```cpp
#include<algorithm>
#include<iostream>
#include<cstdio>
#include<cmath>
using namespace std;
int tmp[200005],n,m=0;
double res=999999999;

inline int read(){		//快速读入
    int x = 0,			//亲测快不了多少 (￣△￣；)
    	f = 1;
    char ch = getchar();
    while(ch < '0' || ch > '9'){
    	if(ch == '-') f=-1;
    	ch = getchar();
    }
    while(ch >= '0' && ch <= '9'){
    	x = x*10 + ch-'0';
    	ch = getchar();
    }
    return x*f;
}

struct point{			//记录点的坐标
    int x,y;
}p[200005];

bool cmpx(point x,point y){
	return x.x < y.x;
}						//以x为关键词排序

bool cmpy(int x,int y){
	return p[x].y < p[y].y;
}						//以y为关键词排序

double fpow(int x){
	return (double)x*x;
}

double dis(int x,int y){
	return sqrt(fpow(p[x].x-p[y].x)+fpow(p[y].y-p[x].y));
}						//两点之间距离公式

int abs(int x){
	return x < 0 ? -x : x;
}

void bisec(int l,int r)
{
    if(l+1 >= r) return;		//递归边界1
    if(l+2 == r){
    	res = min(res,dis(l,r)+dis(l+1,r)+dis(l,r-1));
    	return;					//递归边界2
    }
    int mid = (l+r) >> 1;
    bisec(l,mid);
    bisec(mid+1,r);		//二分
    m = 0;
    double lim = res / 2.000000;
    for(int i = l; i<=r; i++)
    	if(abs(p[i].x-p[mid].x) <= lim) tmp[++m] = i;
    sort(tmp+1,tmp+m+1,cmpy);
	//选取点存入tmp数组，并按照y排序
    for(int i = 1,j = 1; i<=m; i++){
        for(; j<=m && abs(p[tmp[j]].y-p[tmp[i]].y) <= lim; ++j);
        //注意这个循环后面的”;“，这里不是四重循环
        for(int k = i+1; k<j; k++)
        	for(int l = i+1; l<k; l++)
             	res = min(res,dis(tmp[i],tmp[k])+dis(tmp[k],tmp[l])+dis(tmp[i],tmp[l]));
    }
    //暴力枚举不解释
}

int main(){
    scanf("%d",&n);
    for(int i = 1; i<=n; i++){
    	scanf("%d%d",&p[i].x,&p[i].y);
    }
    sort(p+1,p+n+1,cmpx);
    bisec(1,n);
    printf("%0.6lf",res);
    return 0;
}
```

---

## 作者：DarkClever (赞：15)

我们充分发扬人类智慧。

考虑给所有点加上一个玄学常数后按 $x\times y$ 排序。

根据数学直觉，能构成最小三角形的点一定在数组中相邻，所以我们只取前 $20$ 个点统计答案。

考虑到出题人是懒惰的，只会出小数据来卡我们，不会出大数据来卡我们，于是就在 $n\leq 700$ 时使用暴力，这样程序跑的飞起，$n\leq 2\times 10^5$ 的时候也可以在 $323ms$ 内通过。

```cpp
#include<bits/stdc++.h>
using namespace std;
struct node{
    long long x,y;
}a[210000];
bool cmp(node x,node y){
    return (x.x+114514)*(x.y+114514) < (y.x+114514)*(y.y+114514);
}
double dis(node x,node y){
    return sqrt((x.x - y.x)*(x.x - y.x) + (x.y - y.y)*(x.y - y.y));
}
double getans(node x,node y,node z){
    // cout<<dis(x,y)+dis(x,z)+dis(y,z)<<endl;
    double ans = dis(x,y)+dis(x,z)+dis(y,z);
    return fabs(ans);
}
int xx = 0;
int main(){
    ios::sync_with_stdio(0);
    cin.tie(0),cout.tie(0);
    int n;
    cin>>n;
    double minn = 1000000000;
    for(int i=1;i<=n;i++){
        long long x,y;
        cin>>x>>y;
        a[i].x = x,a[i].y = y;
    }
    if(n<=700){
        for(int i=1;i<=n;i++){
            for(int j=1;j<i;j++){
                for(int k=1;k<j;k++){
                    minn = min(minn,getans(a[i],a[j],a[k]));
                    
                }
            }
        }
        cout<<fixed<<setprecision(6)<<minn<<endl;
        return 0;
    }
    
    sort(a+1,a+n+1,cmp);
    for(int i=1;i<=n;i++){
        // cout<<i<<endl;
        for(int j=max(i-19,1);j<i;j++){
            // cout<<j<<endl;
            for(int k=max(j-19,1);k<j;k++){
                // cout<<k<<endl;
                minn = min(getans(a[i],a[j],a[k]),minn);
            }
        }
    }
    cout<<fixed<<setprecision(6)<<minn<<endl;
    return 0;
}
```

---

## 作者：panyf (赞：8)

模板题：[P1429 平面最近点对（加强版）](https://www.luogu.com.cn/problem/P1429)

### 乱搞做法

将所有点随机旋转，然后按横坐标排序。

之后枚举每个点，取之后的 $c$ 个点更新答案，$c$ 是随便取的一个常数。

多旋转几次即可。

[P6247 [SDOI2012]最近最远点对 提交记录](https://www.luogu.com.cn/record/49822855)

### 分治做法

先将所有点按 $x$ 坐标从小到大排序。

然后分治。

记 $d=\min(ans(l,m),ans(m+1,r))$。

现在考虑要求出 $ans(l,r)$，只需求出跨过中点 $m$ 的答案，然后和 $d$ 取 $\min$。

我们现在只需要考虑距离小于 $d$ 的跨中点的点对。

容易发现只有 $x$ 坐标属于 $(x_m-d,x_m+d)$ 的点有用。

对于每个点 $i$，只有 $y$ 坐标属于 $(y_i-d,y_i+d)$ 的点有用。

对所有点按 $y$ 坐标从小到大排序，取出所有 $x$ 坐标有用的点，然后从前到后枚举每个点 $i$，再从 $i$ 的下一个点开始枚举 $j$，直到 $y_j\geq y_i+d$ 时停止，用 $dis(i,j)$ 更新答案。这样只有 $y_j\in[y_i,y_i+d)$ 的点 $j$ 会被枚举到。

现在考虑计算时间复杂度。

每次枚举 $j$ 的复杂度是 $O(1)$ 的。

因为合法的 $j$ 一定在两个边长为 $d$ 的正方形其中一个内部（$x_m$ 两侧各有一个正方形）。根据 $d$ 的定义，每个正方形内部的点两两距离不小于 $d$。

由抽屉原理，将正方形分成 $4$ 个边长 $\dfrac{d}{2}$ 的小正方形，每个小正方形中至多有一个点，因为小正方形的对角线长度小于 $d$。所以这样的点个数不超过 $4$ 个，即 $j$ 的个数不超过 $8$ 个。

如果对于 $x_m$ 一侧的 $i$，只用另一侧的 $j$ 更新答案，需要在 $(y_i-d,y_i+d)$ 范围内枚举 $j$，$j$ 的个数就不超过 $6$ 个。为了实现方便，代码中并没有这样写。

实现时 $d$ 可以在枚举 $(i,j)$ 的过程中直接更新。

然后是按 $y$ 排序的复杂度，用归并排序，$T(n)=2T(\dfrac{n}{2})+O(n)=O(n\log n)$。

总复杂度即为 $O(n\log n)$。

[提交记录](https://www.luogu.com.cn/record/49828424)

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e5+3;
using db=double;
struct P{
	db x,y;
}a[N],b[N];
db pf(db x){return x*x;}
db work(int l,int r){
	if(l==r)return 9e99;
	int m=l+r>>1,t=0,i,j;
	db p=a[m].x,d=min(work(l,m),work(m+1,r));//这里的d是题解中d的平方
	merge(a+l,a+m+1,a+m+1,a+r+1,b,[](P a,P b){return a.y<b.y;}),memcpy(a+l,b,sizeof(P[r-l+1]));//归并排序
	for(i=l;i<=r;++i)if(pf(a[i].x-p)<d)b[++t]=a[i];//取出x坐标有用的点
	for(i=1;i<=t;++i)for(j=i+1;j<=t&&pf(b[j].y-b[i].y)<d;++j)d=min(d,pf(b[i].x-b[j].x)+pf(b[i].y-b[j].y));
	return d;
}
int main(){
	int n,i;
	for(i=1,scanf("%d",&n);i<=n;++i)scanf("%lf%lf",&a[i].x,&a[i].y);
	sort(a+1,a+n+1,[](P a,P b){return a.x<b.x;}),printf("%.4lf\n",sqrt(work(1,n)));
	return 0;
}
```

习题：

[P4423 [BJWC2011]最小三角形](https://www.luogu.com.cn/problem/P4423)

此题做法和模板题略有不同，记 $d=\dfrac{1}{2}\min(ans(l,m),ans(m+1,r))$。

由三角形两边和大于第三边，周长小于 $2d$ 的三角形顶点两两距离小于 $d$。

依然考虑两个边长为 $d$ 的正方形，但是此时有可能存在距离小于 $d$ 的点。不过容易发现对于每个点 $j$ 至多有一个点 $k$ 满足距离小于 $\dfrac{d}{2}$，否则就能组成周长小于 $2d$ 的三角形。

将距离小于 $\dfrac{d}{2}$ 的点对缩成一个点，此时不存在距离小于 $\dfrac{d}{2}$ 的点对，将正方形分成 $9$ 个边长为 $\dfrac{d}{3}$ 的小正方形，每个中至多一个点。

所以有用点数不超过 $9\times 2\times 2=36$。

用和模板题一样的分治方法即可。

此题中要枚举三个点 $i,j,k$，看似常数很大，其实跑不满，可以通过。

[提交记录](https://www.luogu.com.cn/record/49828851)

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e5+3;
using db=double;
struct P{
	db x,y;
}a[N],b[N];
db dis(int i,int j){return hypot(b[i].x-b[j].x,b[i].y-b[j].y);}//hypot(u,v)用来求sqrt(u^2+v^2)
db work(int l,int r){
	if(l==r)return 9e99;
	int m=l+r>>1,t=0,i,j,k;
	db p=a[m].x,w=min(work(l,m),work(m+1,r)),d=w/2;
	merge(a+l,a+m+1,a+m+1,a+r+1,b,[](P a,P b){return a.y<b.y;}),memcpy(a+l,b,sizeof(P[r-l+1]));
	for(i=l;i<=r;++i)if(abs(a[i].x-p)<d)b[++t]=a[i];
	for(i=1;i<=t;++i)for(j=i+1;j<=t&&abs(b[j].y-b[i].y)<d;++j)for(k=j+1;k<=t&&abs(b[k].y-b[i].y)<d;++k)w=min(w,dis(i,j)+dis(j,k)+dis(k,i));
	return w;
}
int main(){
	int n,i;
	for(i=1,scanf("%d",&n);i<=n;++i)scanf("%lf%lf",&a[i].x,&a[i].y);
	sort(a+1,a+n+1,[](P a,P b){return a.x<b.x;}),printf("%.6lf\n",work(1,n));
	return 0;
}
```


---

## 作者：_lfxxx_ (赞：6)

## 题意：
- 给定 $n$ 个点的坐标，求周长最小的三角形。（保留6位小数）（允许三点共线）
- $3 \le N\le2×10^5$

我们可以借鉴[P1429的第一篇题解](https://www.luogu.com.cn/problem/solution/P1429)的做法：
```latex
将所有点全部绕原点旋转同一个角度，然后按x坐标排序

根据数学直觉，在随机旋转后，答案中的两个点在数组中肯定不会离得太远
```
我们也可以按照类似的思路来做，至于为什么要旋转，请看下图：
![图片](https://cdn.luogu.com.cn/upload/image_hosting/uwhoseho.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

不难看出，下面的三角形周长最短。

所以为了防止~~数据卡我们~~出现以上情况，通常需要随机旋转角度来将点打乱。
坐标旋转变换公式：（绕原点旋转）
$$x2=x1 \times \cos(\theta)-y1 \times \sin(\theta)$$
$$y2=x1 \times \sin(\theta)+y1 \times \cos(\theta)$$
（其中 $\theta$ 表示旋转角度， $x1$ 和 $y1$ 表示原来点的坐标， $x2$ 和 $y2$ 表示旋转后点的坐标）

插一句： $C++$ 的 $\cos$ 和 $\sin$ 函数是按弧度计算的，别忘记转化。以及别忘开 $\texttt{double}$ 。

~~剩下的就看你的RP如何~~
## Code：
```cpp
#include<bits/stdc++.h>
using namespace std;
const double pi=atan(1)*4;//π的值
struct point{
	double x,y;
}p[200001];
inline bool cmp(point a,point b){
	return a.x<b.x;
}
inline double jl(double x1,double y1,double x2,double y2){
	return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));
}//两点的距离
double ans=1e15;
int n;
void around(double t){//t指角度
	t=t/180*pi;//角度转弧度
	for(register int i=1;i<=n;i++){
		double x=p[i].x,xx,y=p[i].y,yy;
		xx=x*cos(t)-y*sin(t);
		yy=x*sin(t)+y*cos(t);
		p[i].x=xx;
		p[i].y=yy;//求坐标旋转后的角度
	}
	sort(p+1,p+1+n,cmp);//按x轴排序
	for(register int i=1;i<n-1;i++)//暴力枚举三个点
		for(register int j=i+1;j<min(i+20,n);j++)
			for(register int k=j+1;k<=min(i+20,n);k++)
				ans=min(ans,jl(p[i].x,p[i].y,p[j].x,p[j].y)+jl(p[j].x,p[j].y,p[k].x,p[k].y)+jl(p[i].x,p[i].y,p[k].x,p[k].y));
}
int main(){
	srand(time(NULL));
	cin>>n;
	for(register int i=1;i<=n;i++)
		scanf("%lf%lf",&p[i].x,&p[i].y);
	around(rand()%360);
	around(rand()%360);//随机旋转
	printf("%.6lf",ans);
	return 0;
}
```
这种玄学算法唯一的缺点太吃RP了，上面的往后搜几个点我调了好几次。~~自我感觉这个代码AC概率较大~~

#### 最后，希望本篇题解对你有帮助。

---

## 作者：Federico2903 (赞：5)

我们充分发扬人类智慧：

我们将所有点同时随机平移，然后对所有点进行极角排序。

根据数学直觉，在随机平移并排序后，能成为答案的点对一定不会离得太远。

所以我们只取每个点向后 $28$ 个点进行计算。

这样速度快的飞起，在 $n \le 2 \times 10^5$ 时都能做到 $500$ 毫秒。

## AC 代码

```cpp
#include <bits/stdc++.h>

#define double long double

#define rep(i, a, b) for(int i = (a), i##end = (b); i <= i##end; i++)
#define _rep(i, a, b) for(int i = (a), i##end = (b); i >= i##end; i--)
#define ec first
#define fb second
#define dl make_pair
#define dk(...) make_tuple(__VA_ARGS__)

using namespace std;

typedef long long ll;
typedef pair <int, int> pii;

int read() {
	int x = 0, f = 1; char c = getchar();
	while (!isdigit(c)) {
		if (c == '-') f = -1;
		c = getchar();
	}
	while (isdigit(c)) {
		x = (x << 3) + (x << 1) + (c ^ 48);
		c = getchar();
	}
	return x * f;
}

template <typename _Tp>
void print(_Tp x) {
	if (x < 0) x = (~x + 1), putchar('-');
	if (x > 9) print(x / 10);
	putchar(x % 10 + '0');
}

double ans = 1e15;

double dis(pii a, pii b) {
	return sqrt(1ll * (a.ec - b.ec) * (a.ec - b.ec) + 1ll * (a.fb - b.fb) * (a.fb - b.fb));
}

mt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());

const int MAXN = 1e6 + 5;
int n;
pii pt[MAXN];

signed main() {
#ifndef LOCAL
#ifndef ONLINE_JUDGE
	freopen("triangle.in", "r", stdin);
	freopen("triangle.out", "w", stdout);
#endif
#endif
    const int addr = rnd();
	n = read();
	rep (i, 1, n) pt[i].ec = read() + addr, pt[i].fb = read() + addr;
	sort(pt + 1, pt + n + 1, [](pii a, pii b) { return atan2(a.fb, a.ec) < atan2(b.fb, b.ec); });
	rep (i, 1, n) {
		rep (j, i + 1, min(n, i + 28)) {
			rep (k, j + 1, min(n, i + 28)) {
				if (i == j || j == k || i == k) continue;
				double tans = dis(pt[i], pt[j]) + dis(pt[j], pt[k]) + dis(pt[k], pt[i]);
				if (tans < ans) {
					ans = tans;
				}
			}
		}
	}
	printf("%.6Lf", ans);
	return 0;
}
```

---

## 作者：Starstream (赞：5)

### 题目链接

[传送门](https://www.luogu.com.cn/problem/P4423)

### 思路

我们充分发扬人类智慧：

将所有点全部绕原点随机旋转同一个角度，然后按 $x\times y$ 从小到大排序。

根据数学直觉，在随机旋转后，答案中的三个点在数组中肯定不会离得太远。

所以我们只取每个点向后的 $9$ 个点来计算答案。

这样速度快得飞起，在 $1\le n \le 2\times 10^5$ 时都可以在 931ms 内卡过（也有可能是我调参不够好，欢迎大佬提出更高效的参数）。

### 代码

```cpp
#include <iostream>
#include <cmath>
#include <cstdlib>
#include <algorithm>
 
using namespace std;
 
const int N = 200010;
 
int n;
struct Point
{
    double x, y;
    bool operator< (const Point &t)const
    {
        return x * y < t.x * t.y;
    }
}p[N];
 
double dis(Point a, Point b)
{
    return sqrt(pow(a.x - b.x, 2) + pow(a.y - b.y, 2));
}
 
int main()
{
    scanf("%d", &n);
    for (int i = 1; i <= n; i ++ )
        scanf("%lf%lf", &p[i].x, &p[i].y);
 
    double alpha = 12.4514;
    for (int i = 1; i <= n; i ++ )
    {
        double x = p[i].x + 9, y = p[i].y + 9;
        p[i].x = x * cos(alpha) - y * sin(alpha);
        p[i].y = x * sin(alpha) + y * cos(alpha);
    }
 
    double res = 1e18;
    sort(p + 1, p + n + 1);
    for (int i = 1; i <= n; i ++ )
        for (int j = i + 1; j <= min(n, i + 9); j ++ )
            for (int k = j + 1; k <= min(n, j + 9); k ++ )
                res = min(res, dis(p[i], p[j]) + dis(p[j], p[k]) + dis(p[i], p[k]));
 
    printf("%.6lf\n", res);
    return 0;
}
```

---

## 作者：liangbowen (赞：5)

## 前言

[题目传送门！](https://www.luogu.com.cn/problem/P4423)

[更好的阅读体验？](https://www.cnblogs.com/liangbowen/p/17363317.html)

刚学分治就来写篇题解纪念一下，其实和平面最近点对一样的（总共四倍经验！）。

## 思路

根据 P7883 的分治思路，这题我们可以考虑用相似的方法解决。

首先将点集按 $x$ 坐标从小到大排序。然后分治。

对于 $\left[l, r\right]$ 区间，分治为 $\left[l, mid\right]$ 与 $\left[mid+1, r\right]$ 两个区间解决。

容易发现，答案只有以下三种可能：

1. 由左端三个点构成的三角形。
2. 由右端三个点构成的三角形。
3. 左右端加起来取够三个点，构成的三角形。

根据分治的思想，前两类我们已经解决了，于是我们看第三类。

找到 $x$ 轴意义上中间的那条直线，它就是划分线。

![](https://cdn.luogu.com.cn/upload/image_hosting/ktb9zd8g.png)

考虑一个常见的性质：对于三角形上的一条边 $w$，若其周长 $C \ge k$，则 $w < \dfrac{k}{2}$。原因比较显然就不证了。

应用到这题，设左右两边构成的答案为 $ans$，则三角形合法，当且仅当

$$
\begin{cases}
\mid X_{a,b,c} - X_{mid}\mid < \frac{ans}{2} \\
Y_a - Y_b < \frac{ans}{2} \\
Y_b - Y_c < \frac{ans}{2} \\
Y_c - Y_a < \frac{ans}{2}
\end{cases}
$$

此处 $Y$ 有关的运算不用加绝对值的原因是，我们按照 $y$ 坐标排序了，换句话说点对是有序的，这样既方便又不会重复枚举。

这样就有一个简明的做法，我们划出中线，筛选出所有 $\mid X_u - X_{mid}\mid < \dfrac{ans}{2}$ 的点。

这些点还需要满足 $y$ 坐标的限制，这个在枚举的时候限制一下就行了。

```cpp
	vector <Node> tmp;
	for (int i = l; i <= r; i++)
		if (abs(a[i].x - a[mid].x) < ans / 2) //距离中线的距离符合要求
			tmp.push_back(a[i]);
	sort(tmp.begin(), tmp.end(), cmpy);
	
	int siz = tmp.size();
	for (int i = 0; i < siz; i++) //枚举三个符号要求的点
		for (int j = i + 1; j < siz && tmp[j].y - tmp[i].y < ans / 2; j++)
			for (int k = j + 1; k < siz && tmp[k].y - tmp[i].y < ans / 2; k++)
				ans = min(ans, dis(tmp[i], tmp[j]) + dis(tmp[j], tmp[k]) + dis(tmp[k], tmp[i]));
```

## 正解还是暴力？

现在有了一个问题：如果全部点都距离非常近，那么会不会使得三重循环寄爆炸，变成 $O(n^3)$ 级别呢？

**这个问题非常重要**。我们回想一下平面最近点对的做法：

对于一个点，能与它组成点对的（此处点对是有序的）点必须满足 $\mid X_u-X_{mid}\mid$，$\mid X_v-X_{mid}\mid$ 与 $Y_v-Y_u$ 都小于 $ans$，所以符合要求的点一定在下图框框内部。

![](https://cdn.luogu.com.cn/upload/image_hosting/nb034pxj.png)

把长方形划分成八个边长为 $\dfrac d2$ 的小正方形。每个正方形的对角线长度是

$$\sqrt{2\cdot(\dfrac d2)^2}=\sqrt{\dfrac{d^2}2} =\dfrac d{\sqrt2}<d$$

换句话说，同一个正方形里面不能有两个点，否则 $ans$ 就不是最小距离了。那么总共可以选 $2^2\times2=8$ 个点。

![](https://cdn.luogu.com.cn/upload/image_hosting/27b9520z.png)

---

回到这个问题。考虑划分成九个边长为 $\dfrac d3$ 的小正方形。

![](https://cdn.luogu.com.cn/upload/image_hosting/j6rfczca.png)

同样地，计算它的对角线：

$$\sqrt{2\cdot(\dfrac d4)^2}=\sqrt{\dfrac{d^2}8}=\dfrac d{2\sqrt2}<\dfrac d2$$

换句话说，同一个正方形里面不能有两个点，否则 $ans$ 就不是最小距离了。那么总共可以选 $4^2\times2=32$ 个点。

时间复杂度就自然正确了，并且由于这种是极端情况，实际跑得快非常多。

## 代码

我写了两个版本，前者是 $O(n \log^2 n)$ 的递归内 `sort()` 版本，后者是递归内线性归并的 $O(n\log n)$ 分治。

本质都是相同的，方便大家对拍吧。

$O(n \log^2 n)$ 的版本：

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <vector>
using namespace std;

typedef pair <int, int> pii;
#define x first
#define y second
bool cmpx(pii p, pii q) {return p.x < q.x;}
bool cmpy(pii p, pii q) {return p.y < q.y;}

const int N = 2e5 + 5;
pii a[N];
double dis(pii p, pii q) {return sqrt(1ll * (p.x - q.x) * (p.x - q.x) + 1ll * (p.y - q.y) * (p.y - q.y));}
double solve(int l, int r)
{
	if (l >= r) return 1e9;
	int mid = (l + r) >> 1;
	double ans = min(solve(l, mid), solve(mid + 1, r));
	
	vector <pii> tmp;
	for (int i = l; i <= r; i++)
		if (abs(a[i].x - a[mid].x) < ans / 2) //距离中线的距离符合要求
			tmp.push_back(a[i]);
	sort(tmp.begin(), tmp.end(), cmpy);
	
	int siz = tmp.size();
	for (int i = 0; i < siz; i++) //枚举三个符号要求的点
		for (int j = i + 1; j < siz && tmp[j].y - tmp[i].y < ans / 2; j++)
			for (int k = j + 1; k < siz && tmp[k].y - tmp[i].y < ans / 2; k++)
				ans = min(ans, dis(tmp[i], tmp[j]) + dis(tmp[j], tmp[k]) + dis(tmp[k], tmp[i]));
	return ans;
}
int main()
{
	int n;
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) scanf("%d%d", &a[i].x, &a[i].y);
	sort(a + 1, a + n + 1, cmpx);
	printf("%.6lf", solve(1, n));
	return 0;
}
```

$O(n \log n)$ 的版本：

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <vector>
using namespace std;

typedef pair <int, int> pii;
#define x first
#define y second
bool cmpx(pii p, pii q) {return p.x < q.x;}
bool cmpy(pii p, pii q) {return p.y < q.y;}

const int N = 2e5 + 5;
pii a[N];
double dis(pii p, pii q) {return sqrt(1ll * (p.x - q.x) * (p.x - q.x) + 1ll * (p.y - q.y) * (p.y - q.y));}
pii t[N]; int cur;
void merge(int l, int r) //将 [l,mid] 与 [mid+1,r] 合并，原因是两部分已经是有序的了
{
	int mid = (l + r) >> 1, i = l, j = mid + 1; cur = l;
	while (i <= mid && j <= r)
		if (a[i].y < a[j].y) t[cur++] = a[i++];
		else t[cur++] = a[j++];
	while (i <= mid) t[cur++] = a[i++];
	while (j <= r) t[cur++] = a[j++];
	for (int k = l; k <= r; k++) a[k] = t[k];
}
double solve(int l, int r)
{
	if (l >= r) return 1e9;
	int mid = (l + r) >> 1, midval = a[mid].x; //注意此处一定要先存下来 midval，否则 merge() 会改变
	double ans = min(solve(l, mid), solve(mid + 1, r));
	merge(l, r);
	
	vector <pii> tmp;
	for (int i = l; i <= r; i++)
		if (abs(a[i].x - midval) < ans)
			tmp.push_back(a[i]);
	//sort(tmp.begin(), tmp.end(), cmpy); //这样就不用排序了qwq
	
	int siz = tmp.size();
	for (int i = 0; i < siz; i++) //枚举三个合法点
		for (int j = i + 1; j < siz && tmp[j].y - tmp[i].y < ans / 2; j++)
			for (int k = j + 1; k < siz && tmp[k].y - tmp[i].y < ans / 2; k++)
				ans = min(ans, dis(tmp[i], tmp[j]) + dis(tmp[j], tmp[k]) + dis(tmp[k], tmp[i]));
	return ans;
}
int main()
{
	int n;
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) scanf("%d%d", &a[i].x, &a[i].y);
	sort(a + 1, a + n + 1, cmpx);
	printf("%.6lf", solve(1, n));
	return 0;
}
```

希望能帮助到大家！

---

## 作者：Carbon (赞：5)

 通过借鉴[P1429](luogu.org/problemnew/solution/P1429)第一篇题解与第四篇的思路，所以我们要从分发扬人类的智慧，将所有点都按原点旋转一个角度，然后排序，再将每个点多向后扫10个，即可得到正确的答案。而旋转角度并不会改变点与点之间的距离，改变的只是点之间的相对关系，因为如果不旋转一个角度，出题人是可以专门构造数据来卡你，比如说这几个点 
 
 （1，1）
 （10，1） 
 
 （100，1）
 
 （1000，1）
 
 （10000，1）
 
 （10000，1）
 
 （2000，1）
 
 （3000，1）
 
 （4000，1） 
 
 （5000，1） 
 
 （6000，1） 
 
 （7000，1） 
 
 （8000，1）
 
 （1，2）
 
 答案显然是1，但是通过如果不旋转，则会得到答案9，但是经过旋转之后下，这种相对关系通过坐标的变换，就不复存焉附上代码
 ```cpp
 #include <bits/stdc++.h>

using namespace std;

const double inf=99999999.00;
const double eps=1e-7;
const int N=2e5+5;
struct node
{
    double x,y;
    bool operator <(const node &b)const
    {
    	if (x==b.x)return y<b.y;
    	return x<b.x;
	}
}a[N];
double ans=inf;
int n;

void calc()
{
    for (register int i=1;i<=n;++i)
	{
        for (register int j=i+1;j<=i+10;++j)
		{
			for (register int k=j+1;k<=j+10;++k)
			{
				if (j<=n&&k<=n)
				{
            		ans=min(ans,sqrt((a[i].x-a[j].x)*(a[i].x-a[j].x)+(a[i].y-a[j].y)*(a[i].y-a[j].y))+sqrt((a[i].x-a[k].x)*(a[i].x-a[k].x)+(a[i].y-a[k].y)*(a[i].y-a[k].y))+sqrt((a[k].x-a[j].x)*(a[k].x-a[j].x)+(a[k].y-a[j].y)*(a[k].y-a[j].y)));
				}
			}
        }
    }
}

void around(int ds)
{
    for (int i=1;i<=n;i++)
	{
        double x=a[i].x,y=a[i].y;
        double newx,newy;            
        double zx=0.0,zy=0.0;   
        newx= (x - zx)*cos(ds) - (y - zy)*sin(ds) + zx ;
        newy= (x - zx)*sin(ds) + (y - zy)*cos(ds) + zy ;
        a[i].x=newx;
        a[i].y=newy;
    }
    sort(a+1,a+1+n);
    calc();
}

int main()
{
	srand(time(NULL));
	scanf("%d",&n);
	for (int i=1;i<=n;i++)
		scanf("%lf%lf",&a[i].x,&a[i].y);
	around(0);
	around(rand()%360);
	around(rand()%360);
	printf("%.6lf",ans);
	return 0;
}
 ```

---

## 作者：Cerisier (赞：3)

类似于平面最近点对，使用分治思想。

将平面分为两份，那么三角形的三个顶点只有三种情况：

- 完全处于左半部分
- 完全处于右半部分
- 经过分割线

我们先不考虑前两种情况，因为实际上是由第三种情况推出来的（递归实现，具体为什么可以自己想想）。

如果当前左半部分和右半部分最小三角形边长为 $w$，那么如果想找到一个经过分割线且可以替代的最小三角形，那么他的的边长一定不大于等于 $\dfrac{w}{2}$。因为当如果有一条边的长度为 $\dfrac{w}{2}$ 时，其边长一定大于 $w$。

知道了这个性质，我们需要找到可能满足条件的三角形的顶点。

![](https://cdn.luogu.com.cn/upload/image_hosting/62n6ejnd.png)

如上图，我画出了各种三角形的两个顶点经过分割线的情况（右侧对称同理）。发现：如果要让这两个点的距离小于 $\dfrac{w}{2}$，那么这两个点与分割线的距离一定不超过 $\dfrac{w}{2}$。

因此对于解决区间 $[l,r]$，我们需要先将与分割线距离不超过 $\dfrac{w}{2}$ 的点统计起来，然后进行三重循环的枚举试图更新答案。

当然，这样是有些慢的，我们可以对这些点进行关于 $y$ 的从小到大排序。如果当前的点和上一个枚举的点的距离超过了 $\dfrac{w}{2}$，那么后面的点一定也不可以。这样可以节约一部分时间。

由于我们需要使用分治的思想，那么一开始就需要对输入的点进行关于 $x$ 的从小到大的排序，以更加方便的找到 $mid$。

```cpp
#include<iostream>
#include<climits>
#include<cstring>
#include<cstdio>
#include<algorithm>
#include<iomanip>
#include<cmath>
using namespace std;

inline int read() {
	int x = 0, f = 1; char ch = getchar();
	while (ch < '0' || ch>'9') { if (ch == '-') f = -1; ch = getchar(); }
	while (ch >= '0' && ch <= '9') { x = x * 10 + ch - 48; ch = getchar(); }
	return x * f;
}

const int maxn = 2e5 + 10;
int n;
struct point {
	int x, y;
} a[maxn], t[maxn];

bool cmpx(point a, point b) {
	return a.x < b.x;
}
bool cmpy(point a, point b) {
	return a.y < b.y;
}
double sqr(double x) {
	return x * x;
}
double dis(point a, point b) {
	return sqrt(sqr(a.x - b.x) + sqr(a.y - b.y));
}

double ans = INT_MAX;
void solve(int l, int r) {
	if (l == r) {
		return;
	}

	int mid = (l + r) >> 1;
	double midx = a[mid].x; // 分割线的 x 坐标
	solve(l, mid);
	solve(mid + 1, r); // 此时的 ans 已经是左右区间中最小三角形的边长了（代码中 ans 与上文中的 w 意义相同）

	int cnt = 0;
	for (int i = l; i <= r; i++) {
		if (fabs(a[i].x - midx) < ans / 2.0) { // 储存与分割线距离小于 ans / 2 的点
			t[++cnt] = a[i];
		}
	}
	sort(t + 1, t + cnt + 1, cmpy);
	for (int i = 1; i <= cnt; i++) {
		for (int j = i + 1; j <= cnt && t[j].y - t[i].y < ans / 2.0; j++) {
			for (int k = j + 1; k <= cnt && t[k].y - t[i].y < ans / 2.0; k++) {
				ans = min(ans, dis(t[i], t[j]) + dis(t[i], t[k]) + dis(t[k], t[j]));
			}
		}
	} // 枚举试图更新答案
}

int main() {
	n = read();
	for (int i = 1; i <= n; i++) {
		cin >> a[i].x >> a[i].y;
	}
	sort(a + 1, a + n + 1, cmpx);
	solve(1, n);
	cout << fixed << setprecision(6) << ans << endl;
	return 0;
}
```



---

## 作者：Na2PtCl6 (赞：3)

**玄学做法逃脱不了它玄学的本质**

## 分析题目
题目中要求组成的三角形是三个点构成的，所以首先可以想到O(n^3)的朴素做法——把点每一个三角形都建出来，然后更新最小值

基于这一做法，我们想到可以用贪心来优化枚举次数：把整个点集**以x坐标为第一关键字，y坐标为第二关键字**排序，然后第二层和第三层循环内，我们只**往当前点后取10个点**（即从当前点下标**加1**开始往后取），然后更新三角形最小周长。

当然这远远不够，出题人专门可以构造数据卡你，所以要随机旋转一下，然后再排序，并做以上操作。

这种贪心做法的正确性是无法证明的，也就是所谓的玄学做法，但仍有学习的价值。

```cpp
#include<cmath>
#include<ctime>
#include<cstdio>
#include<algorithm>
using namespace std;
const short K=10;
int n;
double res=0x3f3f3f3f;
struct point {double x,y;}list[200004];

const bool cmp(const point &a,const point &b){
	if(a.x==b.x)
		return a.y<b.y;
	return a.x<b.x;
}

const double sqr(const double &x) {return x*x;}

const double dis(const point &a,const point &b){
	return sqrt(sqr(a.x-b.x)+sqr(a.y-b.y));
}

double calc(int arg){
	for(int i=0;i<n;i++){
		const double x=list[i].x,y=list[i].y;
		list[i].x=cos(arg)*x-sin(arg)*y;//旋转，更新x坐标
		list[i].y=sin(arg)*x+cos(arg)*y;//更新y坐标
	}
	sort(list,list+n,cmp);
    //朴素做法的贪心优化
	for(int i=0;i<n;i++){
		for(int j=i+1;j<n&&j<i+K;j++)
			for(int k=j+1;k<n&&k<j+K;k++){
				double comp=dis(list[i],list[j]);
				comp+=dis(list[i],list[k])+dis(list[j],list[k]);
				res=res<comp?res:comp;
			}
	}
}

int main(){
    srand(time(0));
	scanf("%d",&n);
	for(int i=0;i<n;i++)
		scanf("%lf%lf",&list[i].x,&list[i].y);
    //保险最好转三次，但这样会超时QAQ，能过就行了
	calc(rand()%360);
	calc(rand()%360);
	printf("%.6lf",res);
	return 0;
}
```
[我的测评记录](https://www.luogu.com.cn/record/list?pid=P4423&user=289944),可以发现，这种做法真的太玄学了，而且还厌氧。

---

## 作者：bits47 (赞：2)

### 非乱搞非分治解法
# [P4423 [BJWC2011]最小三角形](https://www.luogu.com.cn/problem/P4423)
## 前置知识：[P7883 平面最近点对（加强加强版）](https://www.luogu.com.cn/problem/P7883) 

先把 $S$ 按照 $(x,y)$ 排序，并建一个按 $(y,x)$ 排序的 multiset（无重点 set 就行）。

我们依次把点插入 multiset。

当进行到 $i$ 时，前 $i-1$ 个点的答案为 $ans$，把 multiset 中与 $s_i$ 横坐标差大于 $ans$ 的删掉，并把 multiset 中与 $s_i$ 纵坐标差小于 $ans$ 的点拿出来更新答案，最后把 $s_i$ 放入 multiset。

显然，这样正确性有保证，考虑复杂度。

偷 @WeLikeStudying 大佬的图：
![](https://cdn.luogu.com.cn/upload/image_hosting/ngkhc4au.png)

除去 $i$ 本身，最多有 $5$ 个点，更新答案的复杂度是线性的。总复杂度为 $O(n*\log~n)$。

------------

回到本题，我们记 $ans=\frac C2$，每次枚举三角形另两个点，更新答案复杂度为 $5*5*n$，是 $\log$ 级别，总复杂度为 $O(n*\log~n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define db double
const int N=2e5+5;
int n,h=1;
db ans;
struct vec{db x,y;}s[N];
bool cmp(vec a,vec b){return a.x==b.x?a.y<b.y:a.x<b.x;}
db dis(vec a,vec b){return sqrt((b.x-a.x)*(b.x-a.x)+1ll*(b.y-a.y)*(b.y-a.y));}
struct cmp1{
	bool operator() (vec a,vec b) const {
		return a.y==b.y?a.x<b.x:a.y<b.y;
	}
};
set<vec,cmp1>q;
set<vec>::iterator it,j,k; 
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;++i) scanf("%lf%lf",&s[i].x,&s[i].y);
	sort(s+1,s+1+n,cmp),ans=dis(s[1],s[2])+dis(s[2],s[3])+dis(s[1],s[3]);
	q.insert(s[1]),q.insert(s[2]),q.insert(s[3]);
	for(int i=4;i<=n;++i){
		while(h<i&&s[i].x-s[h].x>=ans/2) q.erase(s[h++]);
		it=q.lower_bound((vec){s[i].x,s[i].y-ans/2});
		for(j=it;j!=q.end();++j){
			if(abs((*j).y-s[i].y)>ans/2||++(k=j)==q.end()) break;
			for(;k!=q.end();++k){
				if(abs((*k).y-s[i].y)>ans/2) break;
				ans=min(ans,dis(s[i],*j)+dis(*j,*k)+dis(*k,s[i]));
			}
		}
		q.insert(s[i]); 
	}
	printf("%.6lf",ans);
	return 0;
}
```


---

## 作者：mlvx (赞：1)

### 题意

给出 $n$ 个点，选出三个，使得这三个点两两距离之和最小，求出这个距离之和。

### 分析

类似平面最近点对的做法，进行分治。一段区间内的答案即左区间、右区间，以及跨区间的答案，三者取最小值即可。

记左右区间最小值为 $d$。

显然的，跨区间的三点必须满足其 $x$ 坐标与最中间那个点的 $x$ 坐标差小于 $\dfrac d2$。

为什么呢？

因为三角形两边之和大于第三边，所以最长边小于周长的一半。

在这些点中按 $y$ 坐标排序，就可以直接枚举三点，使得两两 $y$ 坐标之差小于 $\dfrac d2$，那么这些点就是可能可以计入答案的。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define db double
const int N=2e5+10;
int n,b[N];pair<int,int>a[N];
db dis(pair<int,int>a,pair<int,int>b){
	return sqrt(1ll*(a.first-b.first)*(a.first-b.first)+1ll*(a.second-b.second)*(a.second-b.second));
}db solve(int l,int r){
	if(r-l<=2)return r-l==2?dis(a[l],a[l+1])+dis(a[l+1],a[r])+dis(a[l],a[r]):9e18;
	int mid=l+r>>1,cnt=0;db ret=min(solve(l,mid),solve(mid+1,r));
	for(int i=l;i<=r;i++)if(abs(a[mid].first-a[i].first)<ret/2)b[++cnt]=i;
	sort(b+1,b+cnt+1,[](int x,int y){return a[x].second<a[y].second;});
	for(int i=1;i<=cnt;i++)
		for(int j=i+1;j<=cnt&&a[b[j]].second-a[b[i]].second<ret/2;j++)
			for(int k=j+1;k<=cnt&&a[b[k]].second-a[b[i]].second<ret/2;k++)
				ret=min(ret,dis(a[b[i]],a[b[j]])+dis(a[b[i]],a[b[k]])+dis(a[b[j]],a[b[k]]));
	return ret;
}int main(){
	cin>>n;
	for(int i=1;i<=n;i++)cin>>a[i].first>>a[i].second;
	sort(a+1,a+n+1,[](pair<int,int>a,pair<int,int>b){return a.first<b.first;});
	printf("%.6lf\n",solve(1,n));
	return 0;
}
```

---

## 作者：GenesisCrystal (赞：1)

~~总要有一篇紫色的/主题库题解嘛~~

## Solution

这题和一道蓝色的[平面最近点对](https://www.luogu.com.cn/problem/P1429)有点像，思路差不多。

首先，看到数据范围 $N \le 2\times10^5$，不用在递归里面套归并排序。

将整个平面分成两个区间，再将中间的点当作中线：

![](https://s2.loli.net/2024/01/24/8XjE2eF1HuWsJmV.png)

然后算出左右两个区间的最小值 $w$：

![](https://s2.loli.net/2024/01/24/HBFmZGWowAC3xvL.png)

我们假设有两个点特别近，那么另一个点应该至多离那两个点有 $\dfrac{w}{2}$ 再能算作一个可以的点。所以将离中线的距离小于 $\dfrac{w}{2}$ 存入一个新的数组，然后按照 $y$ 排序：

![](https://s2.loli.net/2024/01/24/YzcGqOLMC1omrIl.png)

剩下的就是枚举其中**并不是**任意三个点。那怎么个“并不是”法呢？

比如已经枚举了到了 $(1, 2, 4)$ 了，但是我们不能枚举到 $(1, 2, 5)$，因为 $2$ 号点与 $5$ 号点的距离超过了 $\dfrac{w}{2}$，一旦有两个大于 $\dfrac{w}{2}$ 的，那么一定不是更优的。

然后递归在求 $w$ 的时候递归左右两个区间。

到这里，思路就都说明白了。

## Code

激动人心的代码环节！
![](https://s2.loli.net/2024/01/24/dBPJyITAqnFa9HE.png)
~~想不到吧，我放图片~~

---

## 作者：Fa_Nanf1204 (赞：0)

### 前置题目：
[P7883 平面最近点对（加强加强版）](https://www.luogu.com.cn/problem/P7883)。
### 分析：
根据前置题目的思路，我们来分析这一题。

将题意转化一下，就变成了求平面内互不相同的三个点之间的最小距离。

还是分治，主要来讲一下左右的合并方法。首先讨论一下三点的位置关系：设当前的最小答案为 $d$，如果三点不在一条直线上，那么构成一个三角形，因为三角形两边之和大于第三边，所以最长的边 $< \dfrac{d}{2}$。如果在一条直线上，则最长的边 $\le \dfrac{d}{2}$。所以只需要筛选 $\le \dfrac{d}{2}$ 的边就行了。其他方法与前置题目一样，就不过多赘述。

时间复杂度的证明与前置题目类似，只不过是多选了几个点而已，算上排序的时间复杂度，所以最后是 $O(n\log^2n)$。
### Code:

```cpp
#include<bits/stdc++.h>
#define N 400005
#define ll long long
#define D double
using namespace std;
struct node{
	ll x,y;
}e[N],L[N],R[N];
int n;
inline bool cmpx(node x,node y){
	return x.x<y.x;
}
inline bool cmpy(node x,node y){
	return x.y<y.y;
}
inline D get(node a,node b,node c){
	return sqrt(1ll*(a.x-b.x)*(a.x-b.x)+1ll*(a.y-b.y)*(a.y-b.y))+
		   sqrt(1ll*(a.x-c.x)*(a.x-c.x)+1ll*(a.y-c.y)*(a.y-c.y))+
		   sqrt(1ll*(c.x-b.x)*(c.x-b.x)+1ll*(c.y-b.y)*(c.y-b.y));
}
D solve(int l,int r){
	if(l==r or l+1==r) return 9e18;
	if(l+2==r) return get(e[l],e[l+1],e[r]);
	int mid=l+r>>1;
	D ans=min(solve(l,mid),solve(mid+1,r));
	int cntl=0;
	for(int i=l;i<=r;i++){
		if(abs(e[mid].x-e[i].x)<ans/2){
			L[++cntl]=e[i];
		}
	}
	sort(L+1,L+cntl+1,cmpy);
	for(int i=1;i<=cntl;i++){
		for(int j=i+1;j<=cntl;j++){
			if(L[j].y-L[i].y>=ans/2) break;
			for(int k=j+1;k<=cntl;k++){
				if(L[k].y-L[i].y>=ans/2 or L[k].y-L[j].y>=ans/2) break;
				ans=min(ans,get(L[i],L[j],L[k]));
			}
			
		}
	}
	return ans;
}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		scanf("%lld%lld",&e[i].x,&e[i].y);
	}
	sort(e+1,e+n+1,cmpx);
	printf("%.6lf",solve(1,n));
	return 0;
} 
```

---

## 作者：Genius_Star (赞：0)

[**或许更好的阅读体验。**](https://www.cnblogs.com/rgw2010/p/18385936)

### 思路：

仿照**平面最近点对**思路，先按照横坐标排序，考虑分治。

对于分割线 $y=X$，考虑求跨过这条线的贡献，设 $d$ 为左边和右边分治结果的最小值，则这三点中最长边的长度必须 $\le \frac{d}{2}$，不然不会比 $d$ 更优。

则我们只需要考虑横坐标到分割线的距离 $\le \frac{d}{2}$ 的贡献，将这些点找出来，再按照纵坐标进排序，这里使用归并排序的话可以降一个 $\log$，但是没必要。

然后暴力枚举这 $3$ 个点，使得三个点的 $y$ 坐标的极差 $\le \frac{d}{2}$，然后计算贡献即可。

时间复杂度为 $O(N \log^2 N)$。

### 完整代码：

```cpp
#include<bits/stdc++.h>
#define Add(x,y) (x+y>=mod)?(x+y-mod):(x+y)
#define lowbit(x) x&(-x)
#define pi pair<ll,ll>
#define pii pair<ll,pair<ll,ll>>
#define iip pair<pair<ll,ll>,ll>
#define ppii pair<pair<ll,ll>,pair<ll,ll>>
#define fi first
#define se second
#define full(l,r,x) for(auto it=l;it!=r;it++) (*it)=x
#define Full(a) memset(a,0,sizeof(a))
#define open(s1,s2) freopen(s1,"r",stdin),freopen(s2,"w",stdout);
#define For(i,l,r) for(int i=l;i<=r;i++)
#define _For(i,l,r) for(int i=r;i>=l;i--)
using namespace std;
typedef long double lb;
typedef double db;
typedef unsigned long long ull;
typedef long long ll;
bool Begin;
const ll N=1e6+10,INF=1e18;
inline ll read(){
    ll x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')
          f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=(x<<1)+(x<<3)+(c^48);
        c=getchar();
    }
    return x*f;
}
inline void write(ll x){
	if(x<0){
		putchar('-');
		x=-x;
	}
	if(x>9)
	  write(x/10);
	putchar(x%10+'0');
}
struct Point{
    db x,y;
    friend bool operator==(const Point &a,const Point &b){
        return a.x==b.x&&a.y==b.y;
    }
    friend db dis(const Point &a,const Point &b){
        return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));
    }
}a[N];
ll n,sum;
namespace Sub1{
    db ans=INF;
    void work(){
        For(i,1,n)
          For(j,i+1,n)
            For(k,j+1,n)
              ans=min(ans,dis(a[i],a[j])+dis(a[j],a[k])+dis(a[i],a[k]));
        printf("%.10lf\n",ans);
    }
};
namespace Sub2{
    db ans=INF;
    bool cmp(Point &a,Point &b){
        return a.x<b.x;
    }
    void work(){
        sort(a+1,a+n+1,cmp);
        For(i,1,n-2)
          ans=min(ans,dis(a[i],a[i+1])+dis(a[i+1],a[i+2])+dis(a[i],a[i+2]));
        printf("%.10lf\n",ans);
    }
};
namespace Sub3{
    ll cnt=0;
    Point b[N];
    db ans=INF;
    bool cmp1(Point &a,Point &b){
        if(a.x!=b.x)
          return a.x<b.x;
        return a.y<b.y;
    }
    bool cmp2(Point &a,Point &b){
        if(a.y!=b.y)
          return a.y<b.y;
        return a.x<b.x;
    }
    db solve(ll l,ll r){
        if(l==r)
          return INF;
        ll mid=(l+r)>>1;
        ll I=a[mid].x;
        db d=min(solve(l,mid),solve(mid+1,r));
        cnt=0;
        For(i,l,r)
          if(abs(a[i].x-I)<=d/2)
            b[++cnt]=a[i];
        sort(b+1,b+cnt+1,cmp2);
        For(i,1,cnt){
            For(j,i+1,cnt){
                if(b[j].y-b[i].y>d/2)
                  break;
                For(k,j+1,cnt){
                    if(b[k].y-b[i].y>d/2)
                      break;
                    d=min(d,dis(b[i],b[j])+dis(b[i],b[k])+dis(b[j],b[k]));
                }
            }
        }
        return d;
    }
    void work(){
        sort(a+1,a+n+1,cmp1);
        printf("%.10lf\n",solve(1,n));
    }
};
int main(){
	open("A.in","A.out");
    n=read();
    For(i,1,n){
        a[i]={(db)read(),(db)read()};
        sum+=a[i].y;
    }
     if(n<=100)
       Sub1::work();
     else if(!sum)
       Sub2::work();
     else
      Sub3::work();
    return 0;
}
```

---

## 作者：lostxxx (赞：0)

# 题目分析

首先看到求最小的三角形周长，于是我们可以分别枚举 $a,b,c$ 三个点，时间复杂度 $O(n^3)$ 。显然 $n \le 2 \times 10^5$ 不允许我们这样暴力枚举。于是我们考虑优化，我们通过之前的[题](https://www.luogu.com.cn/problem/P1429)想到了方法，于是我们参考之前的方法，将所有点绕着原点旋转一定的角度，然后以 $x$ 坐标为第一关键字，$y$ 坐标为第二关键字排序。然后向后选取一定数量的点，我们尽量让这个数量尽可能的大但不能 `TLE` ，于是我选取了 $40$ 。这样，我们就能~轻松~卡过这一题。至于旋转的角度由自己任选，只要不 `TLE` 就行。

代码如下。

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll n;
struct node{
    double x,y;
}a[200100];
double dis(double x,double y,double xx,double yy){
    return sqrt((x-xx)*(x-xx)+(y-yy)*(y-yy));
}
bool cmp(node a,node b){
    if (a.x==b.x)
        return a.y<b.y;
    return a.x<b.x;
}
int main(){
    srand(time(NULL));
    cin>>n;
    double r=rand()%360+1;
    for (int i=1;i<=n;i++){
        cin>>a[i].x>>a[i].y;
        double xx=a[i].x*cos(r)-a[i].y*sin(r);
        double yy=a[i].y*cos(r)+a[i].x*sin(r);
        a[i].x=xx,a[i].y=yy;
    }
    sort(a+1,a+n+1,cmp);
    double ans=1e18;
    for (ll i=1;i<=n;i++){
        for (ll j=i+1;j<=min(n,i+40);j++){
            for (ll k=j+1;k<=min(n,j+40);k++){
                ans=min(ans,dis(a[i].x,a[i].y,a[j].x,a[j].y)+dis(a[i].x,a[i].y,a[k].x,a[k].y)+dis(a[j].x,a[j].y,a[k].x,a[k].y));
            }
        }
    }
    printf("%.6lf",ans);
}
```

---

## 作者：Unnamed114514 (赞：0)

我们充分发扬人类智慧。

按照 $x$ 为第一关键字，$y$ 为第二关键字排序。

根据直觉，第二个点离第一个点不远，第三个点离第二个点不远。

所以我们从第一个点往后枚 $10$ 个点作为第二个点，从第二个点往后枚 $10$ 个点作为第三个点。

发现过不了，我们以 $y$ 为第一关键字，$x$ 为第二关键字排序，再跑一遍就过了。

是 $O(n)$ 的，这样做快得飞起，$n$ 开到 $10^6$ 都能过。

---

## 作者：bluewindde (赞：0)

平面最小，容易联系到 KDT，只需要借鉴 KDT 的平面分治思想就可以了。

平面分治类似于序列分治。假设当前处理的点集为 $S$，通过一条直线将点集分为 $T$ 和 $S - T$ 两部分，处理跨越这两部分的答案，再递归处理两部分内部的答案。

分治的重点和瓶颈都在于处理跨越两部分的答案。本题中，这种答案就是类似这样的三角形。（绿线是分割线，一般为了方便会把点按 $x$ 坐标排序然后直接取中点的 $x$ 坐标为分割线）

![](https://cdn.luogu.com.cn/upload/image_hosting/pber6ydz.png)

因为三角形两边之和大于（本题中也可以等于）第三边，所以如果希望找到周长不劣于 $2d$ 的三角形，那么该三角形的顶点一定在分割线两侧各延伸 $d$ 的范围内。只需取出这些点并按 $y$ 坐标排序，暴力处理即可。而 $2d$ 的上界可以在递归处理两部分的时候求出。

如果一直 WA on #10 可以试试改一下 `dis` 函数的实现。

```cpp
#include <iostream>
#include <algorithm>
#include <math.h>
#include <vector>
#include <iomanip>

using namespace std;

int n;
struct node {
	int x, y;
	inline bool operator<(const node &nd) const { return x < nd.x; }
} a[200005];

static inline double pow2(double x) { return x * x; }
static inline double dis(int x, int y) { return sqrt(pow2(a[x].x - a[y].x) + pow2(a[x].y - a[y].y)); }
static inline double C(int i, int j, int k) { return dis(i, j) + dis(j, k) + dis(i, k); }

double ans = 1e9;

static inline void solve(int l, int r) {
	if (r - l < 2) return;
	if (r - l == 2) {
		ans = min(ans, C(l, l + 1, l + 2));
		return;
	}
	int mid = (l + r) >> 1;
	solve(l, mid);
	solve(mid + 1, r);
	double lim = ans / 2.;
	vector<int> vec;
	for (int i = l; i <= r; ++i) if (abs(a[i].x - a[mid].x) <= lim) vec.push_back(i);
	sort(vec.begin(), vec.end(), [](const int &x, const int &y) { return a[x].y < a[y].y; });
	int siz = vec.size();
	for (int i = 0; i < siz; ++i) {
		for (int j = i + 1; j < siz && abs(a[vec[i]].y - a[vec[j]].y) <= lim; ++j) {
			for (int k = i + 1; k < j; ++k) {
				ans = min(ans, C(vec[i], vec[j], vec[k]));
			}
		}
	}
}

signed main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin >> n;
	for (int i = 1; i <= n; ++i) cin >> a[i].x >> a[i].y;
	sort(a + 1, a + n + 1);
	solve(1, n);
	cout << fixed << setprecision(6) << round(ans * 1e6) / 1e6 << endl;
	return 0;
}
```

---

## 作者：Wings_of_liberty (赞：0)

### 一.分析
首先我们分析，暴力是三层循环，肯定过不了，于是联想到另一道题 P7883 平面最近点对（加强加强版） 。  
与 P7883 类似，这道题同样可以使用平面分治，具体做法与 P7883 几乎一样。

在二分的时候，用中线将整个平面分为两个部分，对于只在一个部分内的线段，我们可以继续二分，直到一个区域内只剩下两个点或三个点，这两种情况可以直接处理（具体细节在下面）。  
现在的问题就只剩下一个，就是如何合并两个区间，与 P7833 一样，我们先取左右两个区域内得到的最小值，设为 $x$ （这个最小值是线段的，三角形和线段同理），然后再枚举距离中线的距离小于 $x$ 的点，在这些点中找到最优解后与左右两个区域的最优解进行比较，如此可以合并两个区间。
### 二.细节
(1) 首先是递归边界，我写的边界有两个：  
第一种是只有两个点，这种情况下不能组成三角形，直接返回。  
第二种情况是正好有三个点，这种情况下只能组成一个三角形，所以直接判断即可。

(2) 其次是数据处理，在我们求边长的过程中，需要注意两个问题：  
其一是数据类型转换，由于题目保证输入数据为整数，所以输入时可以直接用 `int` 存储，但是边长却可能出现小数，所以在平方时强制转换为 `double` ，之后开方用 `sqrt` 就可以。  
其二是在自己写平方函数时，一定要写成这样：
```
double pow_(int x){ 
	return (double)x*x;
}
```
而不是这样：
```
double pow_(int x){
	return double(x*x);
}
```
采用第二种方法会导致在乘法计算过程中超过 `int` 的数据范围。
### 三.代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
#define op(s) freopen(s".in","r",stdin),freopen(s".out","w",stdout)
#define cl() fclose(stdin),fclose(stdout)
const int MAX=2e5+10;
double ans=INT_MAX;
int n,cnt;
int tmp[MAX];
struct point{
	int x,y;
}p[MAX];
inline bool cmp(point x,point y){//不同的比较函数，这个是给点排序的 
	return x.x<y.x;
}
inline bool cmp2(int x,int y){//这个是因为二分时的变量用编号比较方便，且tmp中存储编号 
	return p[x].y<p[y].y;
}
double pow_(int x){//这样写真的很方便（写过最近点对距离后发现的） 
	return (double)x*x;
}
double dis(int x,int y){//同上 
	return sqrt(pow_(p[x].x-p[y].x)+pow_(p[x].y-p[y].y)); 
}
void dfs(int l,int r){//二分 
	if(l+1>=r){//两个点不能组成三角形 
		return;
	}else if(l+2==r){//正好三个点直接判断 
		ans=min(ans,dis(l,r)+dis(l+1,r)+dis(l,r-1));
		return;
	}else{
		int mid=(l+r)>>1;//普通的二分 
		dfs(l,mid);
		dfs(mid+1,r);
		cnt=0;//记得每次要从1开始存 
		double lim=ans/2.000000;//两边之和大于第三边，所以截出来的矩形的长小于当先最小值的一半，能保证不会露点 
		for(int i=l;i<=r;i++){
			if(abs(p[i].x-p[mid].x)<=lim){
				tmp[++cnt]=i;//有可能的点 
			}
		}
		sort(tmp+1,tmp+cnt+1,cmp2);//按照y排序 
		for(int i=1,j=1;i<=cnt;i++){
			while(j<=cnt&&abs(p[tmp[j]].y-p[tmp[i]].y)<=lim){
				j++;//连小于lim都不满足的点直接跳过 
			}
			for(int k=i+1;k<j;k++){
				for(int l=i+1;l<k;l++){
					ans=min(ans,dis(tmp[i],tmp[k])+dis(tmp[i],tmp[l])+dis(tmp[k],tmp[l]));
					//枚举每一个合适的点并找到最小值 
				}
			}
		}
	}
}
inline void init(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d%d",&p[i].x,&p[i].y);
	}
	sort(p+1,p+n+1,cmp);//初始化，按照x排序 
}
inline void work(){
	dfs(1,n);
	printf("%.6lf",ans);
}
int main(){
	//op("triangle");
	init();
	work();
	//cl();
	return 0;
}
```


---


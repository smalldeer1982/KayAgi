# [JSOI2018] 列队

## 题目描述

作为一名大学生，九条可怜在去年参加了她人生中的最后一次军训。

军训中的一个重要项目是练习列队，为了训练学生，教官给每一个学生分配了一个休息位置。每次训练开始前，所有学生都在各自的休息位置休息，但是当教官发出集合命令后，被点到的学生必须要到指定位置集合。

为了简化问题，我们把休息位置和集合位置抽象成一根数轴。一共有 $n$ 个学生，第 $i$ 个学生的休息位置是 $a_i$。每一次命令，教官会指定一个区间 $[l,r]$ 和集合点 $K$ ，所有编号在 $[l,r]$ 内的学生都必须赶到集合点列队。在列队时，每一个学生需要选择 $[K,K+r-l]$ 中的一个整数坐标站定且不能有任何两个学生选择的坐标相同。学生从坐标 $x$ 跑到坐标 $y$ 需要耗费体力 $\vert y-x \vert$ 。

在一天的训练中，教官一共发布了 $m$ 条命令 $(l,r,K)$ ，现在你需要计算对于每一条命令，在所有可能的列队方案中，消耗的体力值总和最小是多少。

以下是对题意的一些补充：

1.    任何两条命令是无关的，即在一条集合命令结束后，所有学生都会回到自己的休息位置，然后教官才会发出下一条命令。
    
2.    在集合的时候，可能有编号不在 $[l,r]$ 内的学生处在区间 $[K,K+r-l]$ 中，这时他会自己跑开，且跑动的距离不记在消耗的体力值总和中。



## 说明/提示

**样例 1 解释**


在第一条命令中，五名学生依次跑到 $[2,5,4,6,3]$，则总代价为 $|2-1|+|5-5|+|4-7|+|6-6|+|3-2|=5$。
    
在第二条命令中，五名学生依次跑到 $[4,5,7,6,3]$，则总代价为 $|4-1|+|5-5|+|7-7|+|6-6|+|3-2|=4$。
    
在第三条命令中，三名学生依次跑到 $[11,10,9]$，则总代价为 $|11-1|+|10-5|+|9-7|=17$。
    
在第四条命令中，三名学生依次跑到 $[4,2,3]$，则总代价为 $|4-5|+|2-7|+|3-6|=9$。
    
在第五条命令中，三名学生依次跑到 $[7,6,5]$，则总代价为 $|7-7|+|6-6|+|5-2|=3$。

**数据范围**

对于 $10\%$ 的数据，$n,m \leq 10$；

对于 $40\%$ 的数据，$n,m \leq 10^3$；

对于 $70\%$ 的数据，$n,m \leq 10^5$；

对于 $100\%$ 的数据，$n,m \leq 5 \times 10^5,1 \leq a_i,K \leq 10^6$。

对于 $100\%$ 的数据，学生休息的位置两两不同。


## 样例 #1

### 输入

```
5 5
1 5 7 6 2
1 5 2
1 5 3
1 3 9
2 4 2
3 5 5```

### 输出

```
5
4
17
9
3```

# 题解

## 作者：小粉兔 (赞：48)

### 题意简述：

有 $n$ 个学生，编号为 $i$ 的学生有一个位置 $a_i$。

有 $m$ 个询问，每次询问编号在 $[l,r]$ 区间内的学生跑到区间 $[k,k+r-l]$ 中的位置花费的距离总和的最小值。

每个学生的初始位置互不相同，最终到达的位置也必须互不相同。

### 题解：

不难证明，学生跑到最终的位置时，他们的相对位置不改变至少是最优解之一，这可以脑补一下。

所以我们只需要求最终相对位置不变时的答案即可。

因为学生两两位置不同，所以最终有一部分学生向右跑，有一部分学生向左跑。

向右跑的学生对答案的贡献是 $k+rk_i-1-a_i$，$rk_i$ 表示他的位置在这个编号区间中的学生是第 $rk_i$ 小的。

向左跑的学生对答案的贡献是 $a_i-k-rk_i+1$。

显然左边一部分学生向右跑，右边一部分学生向左跑。

考虑使用主席树处理这个问题。

对权值线段树进行可持久化，则编号区间内的学生就是两个线段树相减。

考虑递归进一个区间 $[l,r]$，有 $4$ 种情况。

1. 这个区间中没有学生。直接返回 $0$。

2. 这个区间中的学生全部往右跑。返回 $(\sum k+rk_i-1)-(\sum a_i)$，左边是等差数列求和的形式，右边可以直接记。

3. 这个区间中的学生全部往左跑。返回 $(\sum a_i)-(\sum k+rk_i-1)$。

4. 不能确定这个区间中的学生的方向，递归到子树处理。

直接在主席树上实现即可。

时间复杂度 $O(n\log n+m\log n\times\text{wys})$，因为我不会分析递归的复杂度，可能是 $O(m\log n)$ 的。

```cpp
#include <cstdio>

typedef long long LL;
const int MN = 500005;
const int MS = 11000005;

int n, m, s = 1000000;
int rt[MN];
int ls[MS], rs[MS], mx[MS], mn[MS], sz[MS], cnt;
LL sum[MS];

void Add(int &rt, int l, int r, int p) {
    ls[++cnt] = ls[rt], rs[cnt] = rs[rt], sz[cnt] = sz[rt] + 1, sum[cnt] = sum[rt] + p, rt = cnt;
    if (l == r) return ;
    int mid = l + r >> 1;
    if (p <= mid) Add(ls[rt], l, mid, p);
    else Add(rs[rt], mid + 1, r, p);
}

LL Qur(int rt1, int rt2, int l, int r, int f, int k) {
    if (!(sz[rt1] - sz[rt2])) return 0;
    LL Sz = sz[rt1] - sz[rt2], Sum = sum[rt1] - sum[rt2];
    if (l >= k + f) return Sum - (2*k + 2*f + Sz - 1) * Sz / 2;
    if (r <= k + f + Sz - 1) return (2*k + 2*f + Sz - 1) * Sz / 2 - Sum;
    int mid = l + r >> 1, lsz = sz[ls[rt1]] - sz[ls[rt2]];
    return Qur(ls[rt1], ls[rt2], l, mid, f, k) + Qur(rs[rt1], rs[rt2], mid + 1, r, f + lsz, k);
}

int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1, x; i <= n; ++i) {
        scanf("%d", &x);
        Add(rt[i] = rt[i - 1], 1, s, x);
    }
    for (int i = 1, l, r, k; i <= m; ++i) {
        scanf("%d%d%d", &l, &r, &k);
        printf("%lld\n", Qur(rt[r], rt[l - 1], 1, s, 0, k));
    }
    return 0;
}
```

---

## 作者：shadowice1984 (赞：17)


楼下题解写的什么啊2333……~~(可能这就是dalao的思路吧)~~

菜的不行的我来写一发题解好了
______________________________________

### 前置芝士:可持久化线段树/主席树

不会这个东西的话可以出门左转luogu模板区，包教包会

## 本题题解

题目意思简单明了，就是每次询问一个区间的人在k这个位置集合的最小体力消耗

那么根据排序不等式还是别的什么东西总之我们可以得到一个结论就是$[l,r]$中位置第一小的人跑到第K个位置，第二小的人跑到k+1,第3小的人跑到k+2……如此这般一直到位置最大的人跑到第K+r-l个位置，这样进行列队体力值消耗之和一定是最小的

证明的话大概就是假设有两个人是逆序列队的(也就是原来位置靠前的人站到了后面)，那么我们可以将这两个人进行交换从而使得总代价更加少

而我们发现另外一个非常有趣的性质就是在这个列队过程中，存在一个分界点mid使得mid左边的人都向右跑，mid右边的人都向左跑

证明的话我们可以自己画一画图，然后就会发现因为集合的区域是连续的一段区间，因此是不会存在那种一些人向右跑之后又一些向左跑又一些人向右跑的情况的

那么我们现在假如说我们有一个神奇的数据结构，可以让我们知道有多少个人向右跑了，假设这些人集合在了$[K,K+s]$这个区间的话，根据刚才的结论我们知道一定是位置最靠前的前$s+1$的人向右跑了，我们可以不怎么负责任的列出这样的一个式子，它表示所有向右跑的人的体力消耗之和(对于这个式子意会一下就好它并不严谨)

$$\sum_{i}|a_{i}-K+i|$$

然后我们拆一下∑的话会变成这个式子:(由于都是向右跑，因此绝对值号被拆掉之后要取负号)

$$\sum_{i=K}^{K+s}i-\sum_{i}a_{i}$$

前面的式子是个等差数列求和可以$O(1)$的算出来，然后我们现在唯一要做的就是快速的算出来$[l,r]$前$s+1$小数字的和了

__________________

 _如果看懂了前面的部分不需要看这里_ 
 
 同理我们会发现恰好有$r-l-s$个人向左跑了，这部分代价我们也可以不怎么负责任的列一个式子出来
 
 $$\sum_{i}|a_{i}-K+i|$$
 
 只不过这会是向左跑，所以我们可以直接把绝对值符号拆掉，就得到了这个式子
 
 $$\sum_{i}a_{i}-\sum_{i=K+s+1}^{K+r-l}i$$
 
 当然后边的式子依然是一个等差数列求和的形式，我们依然可以$O(1)$的算出来
 前面的部分则是$[l,r]$中第$s+2$小到第$r-l+1$小数字的和了

_________________

好了经过刚才的一顿分析我们会发现我们需要的东西就是第一快速的求出那个分界点mid，或者说不求出分界点mid也可以，但是我们必须知道有多少人向左跑了

第二就是我们需要快速的求出区间$[l,r]$内前k大的数字之和

那么我们发现一件事是那个神奇的分界点会满足这样的性质，那就是

$cnt_{mid}=mid-K+1$

其中$cnt_{mid}$表示在区间$[l,r]$当中小于等于mid的数字个数

那么我们发现这个东西当然可以二分啦~

现在可能我们唯一要做的事情就是查找区间中比mid小的数字个数和前k小的数字之和啦~

这个问题，我们似乎只要得知了$[l,r]$这个区间的权值线段树长什么样我们就可以相当快速的求出来了……，甚至我们可以直接在权值线段树上二分，每次计算一下刚才的那个值，如果$cnt_{mid}$比$mid-K+1$小了我们就向右递归，否则我们就向左递归，每次向右递归的时候我们直接加上左儿子区间对应数字之和，这样当我们二分出mid的时候我们也顺手求出了所有值小于mid的数字之和

问题来了我们怎么知道一个区间的权值线段树长什么样呢？

当然是可持久化线段树(主席树)啦~我们把两个前缀的权值线段树一减我们就得到了目标区间的权值线段树了…

所以这道题我们最后要做的就是在主席树上二分出列队时的分界点(注意一件事是可能我们在所有人都向左跑或者向右跑的时候可能无法正确的二分出mid的位置，不过我们依然可以正确的二分出有多少个人向左跑了)，然后对于向左跑的人和向右跑的人分别计算一下代价即可了，写起来的话会相当的好写~

 _tips:值域才$10^6$我们无需也不能写离散化_ 

上代码~

```C
#include<cstdio>
#include<algorithm>
#include<map>
using namespace std;const int N=5*1e5+10;const int P=22*N;typedef long long ll;
int n;int m;
struct per_linetree//简易主席树板子
{
    int s[P][2];int siz[P];ll val[P];int ct;int root[N];int tim;ll vl;ll sl;
    per_linetree(){root[0]=ct=1;}
    inline void ins(int p1,int p2,int l,int r,int pos)//插入
    {
        siz[p2]=siz[p1]+1;val[p2]=val[p1]+pos;if(r-l==1){return;}int mid=(l+r)/2;
        if(pos<=mid)s[p2][1]=s[p1][1],ins(s[p1][0],s[p2][0]=++ct,l,mid,pos);
        else s[p2][0]=s[p1][0],ins(s[p1][1],s[p2][1]=++ct,mid,r,pos);
    }
    inline void query(int p1,int p2,int l,int r,int k)//二分，这里使用两个全局变量来记录向右跑的人数和向左跑的人的位置之和
    {
        if(r-l==1)return;int mid=(l+r)/2;
        int ns=siz[s[p2][0]]-siz[s[p1][0]];ll nv=val[s[p2][0]]-val[s[p1][0]];
        if(mid-k+1<ns+sl)vl+=nv,sl+=ns,query(s[p1][1],s[p2][1],mid,r,k);
        else if(mid-k+1==ns+sl){vl+=nv,sl+=ns;return;}
        else query(s[p1][0],s[p2][0],l,mid,k);	
    }
    inline void cins(int val){ins(root[tim],root[tim+1]=++ct,0,1e6,val);++tim;}
    inline void cquery(int l,int r,int k)//二分出来分割点之后简单的计算一下就行了
    {
        vl=0;sl=0;query(root[l-1],root[r],0,1e6,k);
        ll vr=val[root[r]]-val[root[l-1]]-vl;
        ll sr=(k+sl+k+r-l)*(r-l+1-sl)/2;sl=(k+k+sl-1)*sl/2;
        printf("%lld\n",sl-vl+vr-sr);
    }
}plt;
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1,t;i<=n;i++)scanf("%d",&t),plt.cins(t);
    for(int i=1,l,r,k;i<=m;i++)scanf("%d%d%d",&l,&r,&k),plt.cquery(l,r,k);
    return 0;//拜拜程序~
}
```












---

## 作者：STUDENT00 (赞：9)

# 题面

[P4559 [JSOI2018] 列队](https://www.luogu.com.cn/problem/P4559)

# 解法

结论：参与列队的 $r-l+1$ 个学生相对位置不变，一定能得到一组最优解。

略证：设有 $i,j$ 两人，列队前 $a_i<a_j$，列队后 $a_i>a_j$，我们把二者列队后的坐标互换，体力值消耗一定不劣。

设 $rk_i$ 表示学生 $i$ 在参与列队的同学中第 $rk_i$ 小，据“结论”得学生 $i$ 列队后坐标应为 $K+rk_i-1$，分讨：

一、学生 $i$ 向左移动，耗费体力值 $a_i-(K+rk_i-1)$。

二、学生 $i$ 向右移动，耗费体力值 $(K+rk_i-1)-a_i$。

主席树维护 $a_{l\sim r}$ 的权值线段树。

$s(l,r)$ 表示 $\in[l,r]$ 的 $a_i$ 个数。

$f(l,r,k)$ 表示把 $a_i\in[l,r]$ 放进 $[k,k+s(l,r)-1]$ 的最小体力值消耗。

一、如果 $s(l,r)=0$，$f(l,r,k)=0$。

二、如果 $l\ge k$，所有人都应向左移动。

三、如果 $r\le k+s(l,r)-1$，所有人都应向右移动。

四、否则，$f(l,r,k)=f(l,mid,k)+f(mid+1,r,k+s(l,mid))$。

此时 $f(l,mid,k)$ 和 $f(mid+1,r,k+s(l,mid))$ 显然只有至多一者能执行四。

二三可用等差数列求和公式 + 区间权值和求得。

时复 $O((n+m)\log_2n)$。

# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define FIO 
struct IO{
#ifdef FIO
const static int BUFSIZE=1<<20;char buf[BUFSIZE],obuf[BUFSIZE],*p1,*p2,*pp;inline char getchar(){return(p1==p2&&(p2=(p1=buf)+fread(buf,1,BUFSIZE,stdin),p1==p2)?EOF:*p1++);}inline void putchar(char x){((pp-obuf==BUFSIZE&&(fwrite(obuf,1,BUFSIZE,stdout),pp=obuf)),*pp=x,pp++);}inline void flush(){fwrite(obuf,1,pp-obuf,stdout);}IO(){fwrite("Warning: Macro 'FIO' has been defined, keyboard input will be ignored.\n",1,71,stderr);p1=buf,p2=buf,pp=obuf;}~IO(){fwrite(obuf,1,pp-obuf,stdout);}
#else
int(*getchar)()=&::getchar;int(*putchar)(int)=&::putchar;inline void flush(){};
#endif
string sep=" ";int k=2;template<typename Tp,typename enable_if<is_integral<Tp>::value>::type* =nullptr>inline int read(Tp&s){int f=1;char ch=getchar();s=0;while(!isdigit(ch)&&ch!=EOF)f=(ch=='-'?-1:1),ch=getchar();while(isdigit(ch))s=s*10+(ch^48),ch=getchar();s*=f;return ch!=EOF;}template<typename Tp,typename enable_if<is_floating_point<Tp>::value>::type* =nullptr>inline int read(Tp&s){int f=1;char ch=getchar();s=0;while(!isdigit(ch)&&ch!=EOF&&ch!='.')f=(ch=='-'?-1:1),ch=getchar();while(isdigit(ch))s=s*10+(ch^48),ch=getchar();if(ch==EOF)return false;if(ch=='.'){Tp eps=0.1;ch=getchar();while(isdigit(ch))s=s+(ch^48)*eps,ch=getchar(),eps/=10;}s*=f;return ch!=EOF;}inline int read(char&c){char ch=getchar();while(isspace(ch)&&ch!=EOF)ch=getchar();if(ch!=EOF)c=ch;return ch!=EOF;}inline int read(char*c){char ch=getchar();while(isspace(ch)&&ch!=EOF)ch=getchar();while(!isspace(ch)&&ch!=EOF)*(c++)=ch,ch=getchar();return ch!=EOF;}inline int read(string&s){s.clear();char ch=getchar();while(isspace(ch)&&ch!=EOF)ch=getchar();while(!isspace(ch)&&ch!=EOF)s+=ch,ch=getchar();return ch!=EOF;}inline int getline(char*c,const char&ed='\n'){char ch=getchar();while(ch!=ed&&ch!=EOF)*(c++)=ch,ch=getchar();return ch!=EOF;}inline int getline(string&s,const char&ed='\n'){s.clear();char ch=getchar();while(ch!=ed&&ch!=EOF)s+=ch,ch=getchar();return ch!=EOF;}template<typename Tp=int>inline Tp read(){Tp x;read(x);return x;}template<typename Tp,typename...Ts>int read(Tp&x,Ts&...val){return read(x)&&read(val...);}template<typename Tp,typename enable_if<is_integral<Tp>::value>::type* =nullptr>IO&write(Tp x){if(x<0)putchar('-'),x=-x;static char sta[20];int top=0;do sta[top++]=x%10+'0',x/=10;while(x);while(top)putchar(sta[--top]);return*this;}inline IO&write(const string&str){for(char ch:str)putchar(ch);return*this;}inline IO&write(const char*str){while(*str!='\0')putchar(*(str++));return*this;}inline IO&write(char*str){return write((const char*)str);}inline IO&write(const char&ch){return putchar(ch),*this;}template<typename Tp,typename enable_if<is_floating_point<Tp>::value>::type* =nullptr>inline IO&write(Tp x){const static long long pow10[]={1,10,100,1000,10000,100000,1000000,10000000,100000000,1000000000,10000000000,100000000000,1000000000000,10000000000000,100000000000000,1000000000000000,10000000000000000,100000000000000000,100000000000000000,100000000000000000};const auto&n=pow10[k];if(x==0){putchar('0'),putchar('.');for(int i=1;i<=k;++i)putchar('0');return*this;}if(x<0)putchar('-'),x=-x;long long d=(long long)(x+1e-12),y=(long long)(x*n+0.5);write(d),putchar('.');static char sta[20];int top=0;for(;top<k;y/=10)sta[top++]=y%10^48;while(top)putchar(sta[--top]);return*this;}template<typename Tp,typename...Ts>inline IO&write(Tp x,Ts...val){write(x);write(sep);write(val...);return*this;}template<typename...Ts>inline IO&writeln(Ts...val){write(val...);putchar('\n');return*this;}inline IO&writeln(void){putchar('\n');return*this;}template<typename Tp>inline IO&writeWith(Tp x,const string&s){write(x),write(s);return*this;}inline IO&setsep(const string&s){return sep=s,*this;}inline IO&setprecision(const int&K){return k=K,*this;}}io;
const int N=500005;
const int M=N*25;
typedef long long ll;
int n,m,a[N];
int root[N],idx;
int siz[M],ls[M],rs[M];
ll sum[M];
void modify(int &x,int y,int l,int r,int v){
	ls[x=++idx]=ls[y],rs[x]=rs[y],siz[x]=siz[y]+1,sum[x]=sum[y]+v;
	if(l==r) return;
	int mid=l+r>>1;
	if(v<=mid) modify(ls[x],ls[y],l,mid,v);
	else modify(rs[x],rs[y],mid+1,r,v);
}
ll query(int x,int y,int l,int r,int k){
	int sz=siz[x]-siz[y];
	ll sm=sum[x]-sum[y];
	if(!sz) return 0;
	if(l>=k) return sm-(ll)(k*2+sz-1)*sz/2;
	if(r<=k+sz-1) return (ll)(k*2+sz-1)*sz/2-sm;
	int mid=l+r>>1;
	return query(ls[x],ls[y],l,mid,k)+
	query(rs[x],rs[y],mid+1,r,k+(siz[ls[x]]-siz[ls[y]]));
}
int main(){
	io.read(n,m);
	int mx=0,mn=1e6; 
	for(int i=1;i<=n;i++) io.read(a[i]),mn=min(mn,a[i]),mx=max(mx,a[i]);
	for(int i=1;i<=n;i++) modify(root[i],root[i-1],mn,mx,a[i]);
	while(m--){
		int l,r,k;io.read(l,r,k);
		io.writeln(query(root[r],root[l-1],mn,mx,k));
	}
	return 0;
}
```

---

## 作者：w36557658 (赞：8)

题解同步发在我的博客：https://www.cnblogs.com/luyouqi233/p/9090038.html

**40pts：**

不难想到询问应当在主席树上做。

$[l,r]$为我们询问的这些人所在位置的坐标区间，$[l1,r1]$为这些人最终要去这个区间里站着。

我们维护主席树节点代表的区间的人数，则设当前节点左子树人数为$ls$，则可以递归处理$[l,mid][l1,l1+ls-1]$和$[mid+1,r][l1+ls,r1]$，复杂度$O(n^2)$。

**100pts：**

然后我们就试图剪枝呗看看我们能剪成啥样。

我们能处理$r<=l1$和$r1<=l$的情况吗？当然可以。

我们举前一种情况为例（后面的情况基本同理）：

只需要先让这些人都跑到$l1$，然后再让这些人在$[l1,r1]$站好就行了。

于是算出这些人到l1的距离，再算这些人在$[l1,r1]$的体力值就行了，主席树维护当前人坐标之和即可做到前者，而后者就是等差数列求和。

其实写到这里就可以AC了（数据有点弱（笑））。

**真·100pts：**

那我们继续想，我们能处理$r<=r1$和$l1<=l$的情况吗？当然可以。

还是举前一种情况为例（后面的情况基本同理）：

只需要先让这些人都跑到$r1$，然后再让这些人在$[l1,r1]$站好就行了。

注意唯一不同的是"站好"这个过程实际上是“退流”——退体力值的过程，因为我们能够证明这种情况下每个人只可能跑多不可能跑少，所以我们前者减后者即可，维护方法同上。

那么复杂度到底是什么呢？思考一下不难发现，当$mid<=l1+ls-1$时候我们前子问题可以$O(1)$算出，后子问题$O(log)$继续递归，当$mid>l1+ls-1$时后子问题可以$O(1)$算出，前子问题$O(log)$继续递归。

复杂度$O(nlog)$可以通过本题。

```
#include<cmath>
#include<queue>
#include<vector>
#include<cstdio>
#include<cctype>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
typedef long long ll;
const int N=5e5+5;
const int M=1e6;
inline int read(){
    int X=0,w=0;char ch=0;
    while(!isdigit(ch)){w|=ch=='-';ch=getchar();}
    while(isdigit(ch))X=(X<<3)+(X<<1)+(ch^48),ch=getchar();
    return w?-X:X;
}
struct tree{
    int l,r,sum;
    ll dis;
}tr[M*20+5];
int n,m,pool,rt[N];
void insert(int y,int &x,int l,int r,ll a){
    tr[x=++pool]=tr[y];
    tr[x].sum++;tr[x].dis+=a;
    if(l==r)return;
    int mid=(l+r)>>1;
    if(a<=mid)insert(tr[y].l,tr[x].l,l,mid,a);
    else insert(tr[y].r,tr[x].r,mid+1,r,a);
}
ll query(int nl,int nr,int l,int r,int l1,int r1){
    if(l1>r1)return 0;
    if(r<=r1){
		return (ll)r1*(r1-l1+1)-(tr[nr].dis-tr[nl].dis)-(ll)(r1-l1)*(r1-l1+1)/2;
    }
    if(l1<=l){
		return (tr[nr].dis-tr[nl].dis)-(ll)l1*(r1-l1+1)-(ll)(r1-l1)*(r1-l1+1)/2;
    }
    int mid=(l+r)>>1;
    int delta=tr[tr[nr].l].sum-tr[tr[nl].l].sum;
    return query(tr[nl].l,tr[nr].l,l,mid,l1,l1+delta-1)
	+query(tr[nl].r,tr[nr].r,mid+1,r,l1+delta,r1);
}
int main(){
    n=read(),m=read();
    for(int i=1;i<=n;i++)insert(rt[i-1],rt[i],1,M,read());
    for(int i=1;i<=m;i++){
		int l=read(),r=read(),k=read();
		printf("%lld\n",query(rt[l-1],rt[r],1,M,k,k+r-l));
    }
    return 0;
}

```

---

## 作者：creation_hy (赞：6)

## 大暴力

这题有个很显然的贪心，最后的对应关系一定是排序后一一对应的。

和 P3992 很像，不过那题比这个难很多。

所以对于每次查询，给区间的位置排序，然后一个一个减就行了。

时间复杂度：$O(mn\log n)$

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 5e5 + 5;
int n, m, a[N], b[N], id[N];
inline bool cmp(const int &x, const int &y)
{
    return a[x] < a[y];
}
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n >> m;
    for (int i = 1; i <= n; i++)
        cin >> a[i];
    while (m--)
    {
        int l, r, k;
        cin >> l >> r >> k;
        for (int i = l; i <= r; i++)
            id[i] = i;
        sort(id + l, id + r + 1, cmp);
        ll res = 0;
        for (int i = l; i <= r; i++)
            res += abs(i + k - l - a[id[i]]);
        cout << res << '\n';
    }
    return 0;
}
```

## 优化的暴力

考虑把排序优化掉。

一开始排完所有位置，然后找的时候看位置是否在区间内就行了。

时间复杂度：$O(mn)$

~~但是得分和大暴力是一样的~~

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 5e5 + 5;
int n, m;
struct node
{
    int val, id;
    inline bool operator<(const node &t) const
    {
        return val < t.val;
    }
} a[N];
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n >> m;
    for (int i = 1; i <= n; i++)
        cin >> a[i].val, a[i].id = i;
    sort(a + 1, a + 1 + n);
    while (m--)
    {
        int l, r, k;
        cin >> l >> r >> k;
        int pos = k;
        ll res = 0;
        for (int i = 1; i <= n; i++)
            if (l <= a[i].id && a[i].id <= r)
                res += abs(pos - a[i].val), pos++;
        cout << res << '\n';
    }
    return 0;
}
```

## 正解

这题时间复杂度瓶颈在绝对值。有了绝对值，直接差分根本不可能。（比如 $1\ 3$ 和 $2\ 2$，差分后答案为 $1+3-2-2=0$，但是显然不对）

但是，如果所有同学都是从左移动到右或者都是从右到左，那么就可以差分。

证明很简单，比如都是从左到右。从左到右对答案的贡献一定是移动后的坐标减去原来的坐标。那么把移动后的坐标都加起来，减去移动前的坐标的和，就是答案了。

这个东西可以拿主席树维护。（权值版）

改一下查询函数即可。

具体实现：

- 如果区间没有数（即 $r<l$），返回 $0$。
- 如果区间全是一个方向移动的人，返回答案。
- 否则，继续往下搜索。

第二项中，原来的位置就是主席树的 $sum$ 数组，新的位置是 $\sum k+i-1$。

怎么求呢？

$\sum k+i-1=\sum k+\sum i-\sum 1=k\times n+\dfrac{n(n+1)}{2}-n$

记得开 `long long`。

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 5e5 + 5;
const int M = 4e7 + 5;
const int inf = 1e6;
int n, m, root[N], L[M], R[M], sz[M], tot;
ll sum[M];
inline int insert(int last, int l, int r, int k)
{
    int cur = ++tot;
    sz[cur] = sz[last] + 1;
    sum[cur] = sum[last] + k;
    if (l == r)
        return cur;
    int mid = l + r >> 1;
    if (k <= mid)
        L[cur] = insert(L[last], l, mid, k), R[cur] = R[last];
    else
        R[cur] = insert(R[last], mid + 1, r, k), L[cur] = L[last];
    return cur;
}
inline ll query(int p1, int p2, int l, int r, int k) // k=cur pos
{
    if (r < l)
        return 0;
    int mid = l + r >> 1, siz = sz[p2] - sz[p1];
    ll val = sum[p2] - sum[p1];
    if (k <= l || r <= k + siz - 1)
        return abs(val - (1ll * k * siz + 1ll * siz * (siz + 1) / 2 - siz));
    return query(L[p1], L[p2], l, mid, k) + query(R[p1], R[p2], mid + 1, r, k + (sz[L[p2]] - sz[L[p1]]));
}
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n >> m;
    for (int i = 1, x; i <= n; i++)
    {
        cin >> x;
        root[i] = insert(root[i - 1], 1, inf, x);
    }
    for (int i = 1, l, r, k; i <= m; i++)
    {
        cin >> l >> r >> k;
        cout << query(root[l - 1], root[r], 1, inf, k) << '\n';
    }
    return 0;
}
```

---

## 作者：Alex_Wei (赞：5)

> [P4559 [JSOI2018]列队](https://www.luogu.com.cn/problem/P4559)

相当裸的一道题目。为什么快要 NOI 了我还在刷这种题啊！算是巩固基础了罢。

考虑一次询问，设所有涉及到的学生的位置分别为 $x_0 < x_1 < \cdots < x_k(k = r - l)$，手动模拟一下发现存在一个分割点 $p$，使得 $x_p$ 及其左边的学生向右跑，$x_p$ 右边的学生向左跑。这是因为考察 $x_i$ 和 $i$ 的最终位置 $K + i$，两式相减得 $F(i) = x_i - (K + i)$，而 $i$ 产生的贡献即 $|F(i)|$。

因为 $x_i$ 互不相同，所以 $x_i$ 相较于 $x_{i - 1}$ 增加不小于 $1$（$x_{i - 1} < x_i \Rightarrow x_{i - 1} + 1 \leq x_i$），而 $K + i$ 相较于 $K + i - 1$ 恰好增加 $1$，因此 $F(i) - F(i - 1) = x_i - x_{i - 1} - 1\geq 0$，即 $F(i)$ 单调不降，因此存在 $p$ 使得 $F(p) \leq 0$ 或不存在，且 $F(p + 1) > 0$ 或不存在，这样 $p$ 左边的学生就要向右跑，右边的学生向左跑。

如何找到这样的学生呢？因其具有单调性，可以线段树上二分。

二分找到 $p$ 之后查一下 $p$ 左边的学生个数与位置之和，$p$ 右边的学生个数与位置之和即可求出答案。

进一步地，考虑多组询问，容易发现套个可持久化线段树即可。时间复杂度 $\mathcal{O}((n + m)\log n)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
#define TIME 1e3 * clock() / CLOCKS_PER_SEC
bool Mbe;
constexpr int N = 5e5 + 5;
constexpr int K = N << 5;
constexpr int V = 1.5e6 + 5;
int n, m, node, R[N], ls[K], rs[K], num[K], cnum;
ll sum[K], csum;
void modify(int pre, int &x, int l, int r, int p) {
  ls[x = ++node] = ls[pre], rs[x] = rs[pre];
  num[x] = num[pre] + 1, sum[x] = sum[pre] + p;
  if(l == r) return;
  int m = l + r >> 1;
  if(p <= m) modify(ls[pre], ls[x], l, m, p);
  else modify(rs[pre], rs[x], m + 1, r, p);
}
void binary(int l, int r, int x, int y, int k) {
  ll rnum = num[y] - num[x], rsum = sum[y] - sum[x];
  int m = l + r >> 1;
  if(cnum + rnum >= r - k + 1) return cnum += rnum, csum += rsum, void();
  if(l == r) return;
  binary(l, m, ls[x], ls[y], k);
  if(cnum >= m - k + 1) binary(m + 1, r, rs[x], rs[y], k);
}
bool Med;
int main() {
  fprintf(stderr, "%.3lf MB\n", (&Mbe - &Med) / 1048576.0);
  #ifdef ALEX_WEI
    freopen("1.in", "r", stdin);
    freopen("1.out", "w", stdout);
  #endif
  ios::sync_with_stdio(0);
  cin >> n >> m;
  for(int i = 1, a; i <= n; i++) cin >> a, modify(R[i - 1], R[i], 1, V, a);
  for(int i = 1, l, r, k; i <= m; i++) {
    cin >> l >> r >> k, cnum = csum = 0;
    binary(1, V, R[l - 1], R[r], k);
    auto calc = [&](int l, int r) {return 1ll * (l + r) * (r - l + 1) / 2;};
    cout << calc(k, k + cnum - 1) - csum + (sum[R[r]] - sum[R[l - 1]] - csum) - calc(k + cnum, k + r - l) << "\n";
  }
  cerr << TIME << " ms\n";
  return 0;
}
/*
2022/8/10
Author: Alex_Wei
start coding at 21:06
finish debugging at 21:17
*/
```

---

## 作者：ZigZagKmp (赞：5)

本题解侧重于对贪心原理和时间复杂度的证明，具体实现可参考题解区的其他题解。

### 算法分析

~~通过某种方法~~我们不难想到体力消耗最少的情况应该是**当前区间的所有学生按照相对位置顺序排到 $[K,K+L-R]$** 。

有一种比较好理解的证明：任意一种顺序都可以通过若干次交换相邻的学生实现，一次交换对于交换的这 $2$ 个学生各有$2$种情况：比原来多走 $1$ 步；比原来少走 $1$ 步。下面对于上述贪心分类讨论：

1. 交换的 $2$ 个学生都是从左往右走的。交换之后一个学生多走 $1$ 步，另一个学生少走 $1$ 步，与原方案代价相同。
2. 交换的 $2$ 个学生都是从右往左走的。同样交换之后一个学生多走 $1$ 步，另一个学生少走 $1$ 步，与原方案代价相同。
3. 交换的 $2$ 个学生一个从左往右走，另一个从右往左走。因为保证是**按照相对位置顺序排列**，因此一定是**靠左边的学生是从左往右走，靠右边的学生是从右往左走**，交换之后发现两个学生都比原来多走 $1$ 步，比原方案代价多。

我们发现在上述贪心下无论怎么交换**都不可能让 $2$ 个学生同时少走 $1$ 步**，因此交换之后**不会使答案变更优**。

----

我们把上述贪心的式子写出来，最小代价：

$$\sum_{i=l}^r|a_i-(rk_i+K-1)|$$

这里把绝对值去掉，分类讨论， $rk_i+K-1$ 可通过等差数列求和得出， $a_i$ 通过主席树维护。

下面我们重点来看时间复杂度的证明。

分类讨论结果如下：

1. 当前区间无学生，直接返回 $0$ 。
1. 当前区间完全满足 $a_i-(rk_i+K-1)<0$ ，即当前权值区间中所有学生都应向左跑，此时代价和为 $\sum rk_i+K-1-a_i$ ，分离可得为 $\sum rk_i+K-1-\sum a_i$ ，直接返回答案。
1. 当前区间完全满足 $a_i-(rk_i+K-1)>0$ ，即当前权值区间中所有学生都应向右跑，此时代价和为 $\sum a_i-(rk_i+K-1)$ ，分离可得为 $\sum a_i-\sum rk_i+K-1$ ，直接返回答案。
1. 当前区间不完全满足上述 $2$ 式，即当前权值区间中一部分学生向左跑，一部分学生向右跑。递归处理。

这里复杂度可以保证单次询问 $O(\log n)$ 。我们把当前询问学生区间 $a_l,a_{l+1},\cdots,a_r$ 排序，记为 $b_1,b_2,\cdots,b_{r-l+1}$ 。显然 $a_l,a_{l+1},\cdots,a_r$ 和 $b_1,b_2,\cdots,b_{r-l+1}$ 对于当前询问等价。

因为**学生位置互不相同**，因此满足 $b_i\ge b_{i-1}+1$ 。

两边同时 $-i$ ，即 $b_i-i\ge b_{i-1}-(i-1)$ 。

不难发现对于 $b$ 而言 $rk_i=i\ ,\ rk_{i-1}=i-1$ ，上式即为 $b_i-rk_i>=b_{i-1}-rk_{i-1}$ 。

对于一组询问， $K$ 是固定的，因此绝对值里面的式子是**单调的**，上述递归可以看作是寻找绝对值式子正负的**唯一分界点**，因此保证单次询问复杂度为 $\log n$ 。

这里就不贴代码了，具体实现可以参考题解区其他题解。

---

## 作者：tth37 (赞：5)

本题是主席树的一个简单应用。

阅读题目，不难得出**贪心策略**。在编号位于$[l,r]$的所有人中，其位置最靠前的跑到$K$位置，位置第二靠前的跑到$K+1$位置，以此类推，可以使体力值总和最小。正确性不给出证明。~~（不会证）~~

对于所有学生的位置序列，我们可以建立主席树，并可以用主席树的基本查询操作提取出区间为$[l,r]$的学生位置值域信息。

为了方便学生左右跑动时体力值的统计，我们可以在主席树上额外记录两个数值：$gl$和$gr$，分别表示当前节点对应的区间内所有学生跑动至左端点和右端点所消耗的体力值。在建树过程中即可对这两个变量进行统计，其中$gl$等于当前节点$u$的左儿子上的$gl$，加上$u$的右儿子上的$gl$，再加上右儿子上所有学生从右儿子的左端点跑到$u$的左端点所要消耗的体力值。（可以自己在数轴上模拟一下）

接下来设计查询函数。参数包括值域的左端点和右端点$l$和$r$，以及目标位置区间的左端点和右端点$ql$和$qr$。显然对于以下情况，函数可以直接通过计算得出答案：

- $r\le ql$ 此时处于当前值域内的所有学生都要往右跑
- $qr\le l$ 此时处于当前值域内的所有学生都要往左跑
- 当前值域内没有学生 返回 $0$

否则，必须将值域拆分，递归到左右子节点进行统计。

本题最绕的地方在于**学生编号**和**学生位置**是两个不同的东西，在设计查询函数时必须区分值域和编号的概念。

代码如下：

```cpp
// luogu-judger-enable-o2
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;

const int MAXN=500005;
const int L=1000005;

int N,M;

struct Node{
    int l,r;
    ll gl,gr,sum;
}node[L*22+5];
int head[MAXN];
int cnt;

inline void build(Node& u,int l,int r){
    u.sum=u.gl=u.gr=0;
    if(l==r) return;
    int mid=(l+r)>>1;
    build(node[u.l=++cnt],l,mid);
    build(node[u.r=++cnt],mid+1,r);
}

inline void insert(Node c,Node& u,int l,int r,int p){
    u.sum=c.sum+1;u.gl=u.gr=0;
    if(l==r) return;
    int mid=(l+r)>>1;
    if(p<=mid)
        insert(node[c.l],node[u.l=++cnt],l,mid,p),u.r=c.r;
    else
        insert(node[c.r],node[u.r=++cnt],mid+1,r,p),u.l=c.l;
    u.gl=node[u.l].gl+node[u.r].gl+node[u.r].sum*(mid-l+1);
    u.gr=node[u.r].gr+node[u.l].gr+node[u.l].sum*(r-mid);
}

inline ll query(Node x,Node y,int l,int r,ll ql,ll qr){
    ll sum=y.sum-x.sum; 
    ll gl=y.gl-x.gl,gr=y.gr-x.gr;
    if(sum==0) return 0;
    if(qr<=l)
        return gl+(2*l-ql-qr)*(qr-ql+1)/2;
    if(ql>=r)
        return gr+(ql+qr-2*r)*(qr-ql+1)/2;
    int mid=(l+r)>>1;
    ll lsum=node[y.l].sum-node[x.l].sum;
    return query(node[x.l],node[y.l],l,mid,ql,ql+lsum-1)+
           query(node[x.r],node[y.r],mid+1,r,ql+lsum,qr);
}

int main(){
    scanf("%d%d",&N,&M);
    build(node[0],1,L);
    for(register int i=1;i<=N;++i){
        int a;
        scanf("%d",&a);
        insert(node[head[i-1]],node[head[i]=++cnt],1,L,a);
    }
    for(register int i=1;i<=M;++i){
        ll l,r,k;
        scanf("%lld%lld%lld",&l,&r,&k);
        printf("%lld\n",query(node[head[l-1]],node[head[r]],1,L,k,k+r-l));
    }
    return 0;
}


```

---

## 作者：oyoham (赞：5)

### Problem  
[传送门](https://www.luogu.com.cn/problem/P4559)

给定一个数组，与 $m$ 次询问，每次询问给定三个数 $l,r,k$，求将原数组区间 $[l,r]$ 任意排序后，最小化以下式子的值。
$$
\sum_{i=l}^{r}|a_i-(k+i-l)|
$$  
### solution  
虽然样例描述的不好，但是我们大胆猜测：将区间升序排序后即为最优答案。  
### proof
假设原数组区间 $[l,r]$ 排序后的数组为 $a_l,a_{l+1},\dots,a_r$ 满足 $\forall i<j,a_i<a_j$。假设将 $a_x,a_y$ 交换后存在更优解，不妨设 $x<y$ 即  
$$
|a_x-(k+x-l)|+|a_y-(k+y-l)|>|a_x-(k+y-l)|+|a_y-(k+x-l)|
$$
由不等式 $p<q,r<s$ 可推出 $|p-r|+|q-s|\le|p-s|+|q-r|$。  
而 $a_x<a_y,k+x-l<k+y-l$，所以 $|a_x-(k+x-l)|+|a_y-(k+y-l)|\le|a_x-(k+y-l)|+|a_y-(k+x-l)|$，矛盾。  
因此，不存在更优解。  
但这样时间复杂度只有 $O(nm\log n)$，只有 $40pts$。
### optimization
发现答案可以分两部分计算：$a_x<k+x-l$ 的，$a_x\ge k+x-l$ 的，需要找到中间点 $p$。  
考虑用权值主席树维护两个值：值域中值的个数，值域中值的和。  
每次二分一个 $mid$，若数组 $a_l$ 到 $a_r$ 中位于值域区间 $[1,mid]$ 的数的个数大于 $mid-k+1$，即区间 $[k,k+r-l]$ 与 $[1,mid]$ 的交集元素个数，就向右二分，否则向左二分。  
求出 $p$ 后，计算数组 $a_l$ 到 $a_r$ 中位于值域区间 $[1,p]$ 的数的值，位于值域区间 $[p+1,10^6]$ 的数的值，以及区间 $[k,k+r-l]$ 中位于值域区间 $[1,p]$ 的数的值，位于值域区间 $[p+1,2\times 10^6]$ 的数的值（注意：虽然题目给了 $k\le 10^6$，但不保证 $k+r-l\le 10^6$，所以值域应开到 $[0,2\times10^6]$，若开 $[1,2\times10^6]$ 会 `WA10pts`，若开 $[0,10^6]$ 会 `WA40pts`，~~调了一个小时，总是输出负数，警示后人~~）。
### code
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define int ll
#define pint pair<int,int>
#define f first
#define s second
#define mp make_pair
inline ll read(){
	ll x=0;
	short f=1;
	char c=getchar();
	while(c>57||c<48){
		if(c==45) f=-1;
		c=getchar();
	}
	while(c<58&&c>47){
		x=(x<<1)+(x<<3)+(c^48);
		c=getchar();
	}
	return x*f;
}
inline void write(ll x){
	if(x>>63) putchar(45),x=~x+1;
	if(9-x>>63) write(x/10);
	putchar(x%10|48);
}
int n=read(),m=read();
int rt[500005];
int ls[25000007],rs[25000007],val[25000007],cnt[25000007],idx;
#define mid (l+r>>1)
int build(int l,int r){
	int id=++idx;
	if(l==r){
		return id;
	}
	ls[id]=build(l,mid);
	rs[id]=build(mid+1,r);
	return id;
}
int add(int pre,int l,int r,int p){
	int id=++idx;
	ls[id]=ls[pre];
	rs[id]=rs[pre];
	val[id]=val[pre]+p;
	cnt[id]=cnt[pre]+1;
	if(l==r) return id;
	if(p<=mid) ls[id]=add(ls[id],l,mid,p);
	else rs[id]=add(rs[id],mid+1,r,p);
	return id;
}
int sum(int id,int l,int r,int ql,int qr){//求主席树rt[x]=id(即a[1]~a[x])中值域位于[ql,qr]中的值
	if(l>qr||r<ql) return 0;
	if(ql<=l&&r<=qr) return val[id];
	else return sum(ls[id],l,mid,ql,qr)+sum(rs[id],mid+1,r,ql,qr);
}
int qfs(int f,int b,int l,int r,int ql,int qr,int nowv=0){//求中间点
	if(l==r) return l;
	int v=cnt[ls[b]]-cnt[ls[f]]+nowv;
	int qv=mid-ql+1;
	if(v<=qv){
		return qfs(ls[f],ls[b],l,mid,ql,qr,nowv);
	}
	else return qfs(rs[f],rs[b],mid+1,r,ql,qr,v);
}
signed main(){
	rt[0]=build(0,2e6+1);//习惯建一颗空树，当然你也可以不建。
	for(int i=1;i<=n;i++){
		rt[i]=add(rt[i-1],0,2e6+1,read());
//		printf("%d:%d\n",cnt[rt[i]],val[rt[i]]);
	}
	for(int i=1;i<=m;i++){
		int vl=read(),vr=read(),ql=read(),qr=ql+vr-vl;
		int p=qfs(rt[vl-1],rt[vr],0,2e6+1,ql,qr);
		int sf=sum(rt[vr],0,2e6+1,0,p)-sum(rt[vl-1],0,2e6+1,0,p),sb=sum(rt[vr],0,2e6+1,p+1,2e6+1)-sum(rt[vl-1],0,2e6+1,p+1,2e6+1);
		int sqf=(ql+p)*(p-ql+1)/2,sqb=(qr+p+1)*abs(qr-p)/2;//O(1)等差数列公式
//		printf("%d~%d %d~%d !%d |%d-%d| + |%d-%d| \n",vl,vr,ql,qr,p,sf,sqf,sb,sqb);
		int fv=sqf-sf+sb-sqb;
		write(fv),putchar(10);
	}
}
```

---

## 作者：wdgm4 (赞：4)

第一次交紫题题解，内心十分~~鸡冻~~。QWQ

## 正文

~~知周所众~~，主席树是一种可以查询区间第 $k$ 小的权值线段树，所以说我们可以将它看做可以用 $O(\log n)$ 的时间复杂度将一个区间临时排序并从中解决问题。（这是我自己对于主席树的理解，如果有问题请指出）

开始说正题，学生要到达一个区间了，先说学生本身不在区间里的情况，可以首先让他们走到区间的边界，然后让他们一个一个站在区间里面（指从区间的一边开始，一个一个挨着站），如果这样的话，不难发现，即使他们到达区间中自己的位置时的相对位置发生了改变，他们总共的消耗的体力值总和是不会变的（要在区间的同一边上）。因为对于每一个学生，计算他的消耗的体力值可以分为他从原位置到达区间的边界的消耗的体力值和从区间的边界到自己在区间中的位置所消耗的体力值，而两个学生的相对位置改变只是改变计算消耗的体力值的顺序而已。

进而，我们可以将上述的东西分开算，先算所有同学到达区间边界的总消耗的体力值，在算他们到达自己的位置时的总消耗的体力值。即对于在区间左边界的左边的同学（设有 $k$ 个同学，他们的位置都在集合 $A$ 中，区间左边界是 $l$)，算他们到达区间边界的式子为 $l \times k -\sum\limits_{i \in A}i$，这些值都可以在主席树中求出来，在区间右边界的右边的同学同理。他们到达自己的位置时的总消耗的体力值先放一放。

要考虑本来就在区间里的同学，显然，他们不用算到区间边界消耗的体力值，但是很难将他们特殊计算，所以我们要探索他们的规律。

如果直接算他们消耗的体力值（设他的目标在他自己的左面，设自己的位置是 $i$，目标位置为 $a$），那就是 $a-i$。但是他的目标位置如何确定？由于刚才发现在区间外的同学站到区间内后无论相对位置怎么改变，他们消耗的体力值不会改变，那么就直接使所有同学到区间内后相对位置不变就行了，这样本来就在区间里的同学的目标位置就确定了。

此时再来看如何将他们消耗的体力值和之前的结合起来。如果将他们也像在区间外那样算的话（设边界还是 $l$，就当和在区间左边界的左边的同学一样），算式就是 $l-i+(a-l)$，这个式子化简后就是直接算的式子。这样就可以将他们结合起来，式子 $l \times k -\sum\limits_{i \in A}i$ 和 $l-i$ 结合，求算不在区间内的同学到达自己的位置时的总消耗的体力值和在区间内的同学的总消耗的体力值（也就是 $a-l$）结合起来，可以发现这就是个等差数列，这样就都可以在主席树中求出来了。

这里放上我的代码。

```cpp
#include<bits/stdc++.h>
#define XD 114514
#define MAXN 500010
#define MAXM 1000010
#define int long long
using namespace std;
int n,m,a[MAXN];
struct tree{
	int l,r,val,num;//num 存数量，val 存总和
} t[MAXM*50];
int cnt,top[MAXN];
int modify(int x,int l,int r,int k){//和模板一样
	int nem=++cnt;
	t[nem]=t[x];t[nem].val+=k;t[nem].num++;
	if(l==r) return nem;
	int mid=l+r>>1;
	if(k<=mid) t[nem].l=modify(t[x].l,l,mid,k);
	else t[nem].r=modify(t[x].r,mid+1,r,k);
	return nem;
}
int get_num(int x,int y){//这里最好不要用宏定义，不然可能会出现一些奇奇怪怪的问题
	return t[y].num-t[x].num;
} 
int get_val(int x,int y){
	return t[y].val-t[x].val;
} 
int query(int x,int y,int l,int r,int k1,int k2){
	if(r<=k2) return k2*(k2-k1+1)-get_val(x,y)-(k2-k1)*(k2-k1+1)/2;
	if(k1<=l) return get_val(x,y)-k1*(k2-k1+1)-(k2-k1)*(k2-k1+1)/2;
	int mid=l+r>>1;
	return query(t[x].l,t[y].l,l,mid,k1,k1+get_num(t[x].l,t[y].l)-1)+query(t[x].r,t[y].r,mid+1,r,k1+get_num(t[x].l,t[y].l),k2);
}
signed main(){
	ios::sync_with_stdio(false);
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		int nem;cin>>nem;
		top[i]=modify(top[i-1],1,1e6,nem);
	} 
	for(int i=1;i<=m;i++){
		int l,r,k;
		cin>>l>>r>>k;
		cout<<query(top[l-1],top[r],1,1e6,k,k+r-l)<<"\n";
	}
	return 0;
}
```



---

## 作者：zyp123456 (赞：4)

### 一、前置芝士

+ [主席树](https://www.luogu.com.cn/problem/P3834)

### 二、题目大意

+ 有 $n$ 个学生，编号为 $i$ 的学生的位置是 $a_i$。

+ 有 $m$ 个询问，每次询问编号在 $[l,r]$ 之间的所有学生集合到 $[k,k+r-l]$ 所位置花费的总和。

### 三、题目解析

+ 由题目不难知，当所有要集合的学生位置相对不变时，此时解一定是最优解，故我们一定可以在 $[k,k+r-l]$ 中找到一个位置 $mid$ 使得所有 $a_i \le mid$ 的学生集中在 $[k,k+mid-1]$ 之中，而其余所有学生集合在 $[k+mid,k+r-l]$ 中

+ 而此时答案就是 

$$Ans=\sum_{i=k}^{mid}1-\sum_{i=mid+1}^{k+r-l}1+\sum_{i=l}^{r}a_i-2\sum_{i=l}^{a_i\le mid}{a_i}$$

+ 因此，我们可以利用在主席树来维护区间 $[l,r]$ 并在区间上二分和计算答案。

### 四、代码

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
template<typename T>inline void rd(T&x) {
	x = 0;
	T f = 1;
	char ch = getchar();
	while (!isdigit(ch))f = (ch == '-') ? -1 : 1, ch = getchar();
	while (isdigit(ch))x = (x << 1) + (x << 3) + ch - '0', ch = getchar();
	x *= f;
}
const int M = 500010, inf = 1000000;
struct Node {
	int l, r, siz;
	ll sum;
} T[M << 4];
int rt[M], node, n, m;
inline int copy(int x) {
	return T[++node] = T[x], node;
}
#define mid ((l+r)>>1)
inline void update(int&k, int pre, int l, int r, int x) {
	k = copy(pre);
	T[k].siz++;
	T[k].sum += x;
	if(l==r)return;
	if (x <= mid)update(T[k].l, T[pre].l, l, mid, x);
	else update(T[k].r, T[pre].r, mid + 1, r, x);
}
ll query(int i, int j, int l, int r, int x, int y) {
	if (x > y)return 0;
	if (r <= y)  //假如区间在 mid 左边 
		return (ll)y * (y - x + 1) - (T[j].sum - T[i].sum) - (ll)(y - x) * (y - x + 1) / 2;
	if (x <= l)  //假如区间在 mid 右边 
		return (T[j].sum - T[i].sum) - (ll)x * (y - x + 1) - (ll)(y - x) * (y - x + 1) / 2;
	int tt = T[T[j].l].siz - T[T[i].l].siz;
	return query(T[i].l, T[j].l, l, mid, x, x + tt - 1)
	       + query(T[i].r, T[j].r, mid + 1, r, x + tt, y);
	//如果左右相交则寻找中间点 mid 并分治 
}
int main() {
	rd(n), rd(m);
	for (int i = 1; i <= n; i++) {
		int x;
		rd(x);
		update(rt[i], rt[i-1], 1, inf, x);
	}
	for (int i = 1; i <= m; i++) {
		int l, r, k;
		rd(l), rd(r), rd(k);
		printf("%lld\n", query(rt[l - 1], rt[r], 1, inf, k, k + r - l));
	}
	return 0;
}

```

撒花

---

## 作者：Jμdge (赞：4)

我们发现这是道 可怜 题，啊呸，这是道 **树** 据结构题！

~~（可怜好累啊 2018 年浙江江苏两地来回跑还轮流被喷...）~~

于是让我们来仔细分析一波这道题的解法吧


首先暴力 $n^3 log~ n$ 的做法可以拿到 $10$ 分

第二个部分的 $n^2$ 算法我是想不出来...

至于后面的分数就要开始思考正解了

我们考虑暴力的做法在于将整个区间的数领出来排了个序，于是我们考虑用莫队优化一下，反正这题不强制在线

于是我们每次在 splay 里面取/删一个数，复杂度为 $O(log n)$

但是没有用啊，最后算答案还是要 $splay$ 上滚一遍，复杂度都没变过

于是我们考虑题目中的性质

我们要让所有的数集中到一个区域，那么自然是左半部分点集中到指定区域的左半边，右半部分点到右半边，这样最优


但是我们就是不知道这左右部分的边界，但是我们知道这个边界一定可以在指定集合的区域中


于是我们考虑在区域中二分这个边界，使得其满足**边界左端的点数**等于**这个边界与指定区域左端点**之间的距离

然后套上 splay 的复杂度就是 $O(log^2n)$

然后我们发现最后的答案可以变成

$$ANS=(\sum_{i=K}^{K+_m}i-\sum_{a_j<K+m} a_j ) + ( \sum_{a_j>K+m}a_j-\sum_{i=K+m+1}^{K+R-L}i  )$$

（m 为边界，L R K 为三个询问值）

这个式子中的等差数列我们可以 $O(1)$ 求得，而 $a_i$ 的和通过 $splay$ 上查询可以 $O(log~ n)$ 得到

再加上之前二分边界的 $log^2n$，于是总询问时间复杂度就是 $m~log^2n$


但是这样只能 70 分

于是我们可以考虑不二分直接找边界，就是向下每次到一个点都判断一下这里能不能满足条件...（留给读者想像）


然后由于我不会打 splay ，就用了主席树完成这一系列操作...（明明主席树更方便的说？）


然后我一开始离散了 a 数组。。。其实不离散方便一点，而且 a 的数据范围也不大...


```
//by Judge
#include<cstdio>
#include<iostream>
#include<algorithm>
#define mid (l+r>>1)
#define ll long long
#define rint register int 
using namespace std;
const int M=5e5+3;
typedef int arr[M<<6];
#ifndef Judge
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
#endif
char buf[1<<21],*p1=buf,*p2=buf;
inline void cmax(int& a,int b){if(a<b)a=b;}
inline int read(){ int x=0,f=1; char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
	for(;isdigit(c);c=getchar()) x=x*10+c-'0'; return x*f;
} char sr[1<<21],z[20];int C=-1,Z;
inline void Ot(){fwrite(sr,1,C+1,stdout),C=-1;}
inline void print(ll x,char chr='\n'){
    if(C>1<<20)Ot();if(x<0)sr[++C]=45,x=-x;
    while(z[++Z]=x%10+48,x/=10);
    while(sr[++C]=z[Z],--Z);sr[++C]=chr;
} int n,m,mx,tot,L,R,K,siz;
int a[M],rt[M]; arr ls,rs,num; ll sum[M<<6];
void update(int& k,rint las,rint l,rint r,rint x){ if(!k) k=++tot;
	num[k]=num[las]+1,sum[k]=sum[las]+x; if(l==r) return ;
	if(x<=mid) rs[k]=rs[las],update(ls[k],ls[las],l,mid,x);
	else ls[k]=ls[las],update(rs[k],rs[las],mid+1,r,x);
}
ll query_sum(rint u,rint v,rint l,rint r){ //这里的 siz 要弄全局变量，因为下面还要用到这个边界
	if(!v||l==r) return siz+=num[v]-num[u],sum[v]-sum[u];
	rint Num=num[ls[v]]-num[ls[u]]; ll Sum=sum[ls[v]]-sum[ls[u]];
	if(siz+Num<=mid-K+1) return query_sum(ls[u],ls[v],l,mid); //这里可以判断边界的合法性
	return siz+=Num,query_sum(rs[u],rs[v],mid+1,r)+Sum;
}
inline ll sum1(rint x){ return 1ll*x*(x+1)/2; }
inline ll calc(){ siz=0; //算贡献
	ll Lans=query_sum(rt[L-1],rt[R],1,mx); //先找边界并同时算出边界左端的负贡献
	ll Rans=sum[rt[R]]-sum[rt[L-1]]-Lans;
	Lans=(sum1(K+siz-1)-sum1(K-1))-Lans; //等差数列求和还是习惯写这样...
	Rans=Rans-(sum1(K+R-L)-sum1(K+siz-1));
	return Lans+Rans;
}
int main(){ n=read(),m=read();
	for(rint i=1;i<=n;++i)
		a[i]=read(),cmax(mx,a[i]);
	for(rint i=1;i<=n;++i)
		update(rt[i],rt[i-1],1,mx,a[i]);
	for(rint i=1,l,r;i<=m;++i)
		L=read(),R=read(),
		K=read(),print(calc());
	return Ot(),0;
}
```








---

## 作者：览遍千秋 (赞：4)

## 问题描述

作为一名大学生，九条可怜在去年参加了她人生中的最后一次军训。

军训中的一个重要项目是练习列队，为了训练学生，教官给每一个学生分配了一个休息位置。每次训练开始前，所有学生都在各自的休息位置休息，但是当教官发出集合命令后，被点到的学生必须要到指定位置集合。

为了简化问题，我们把休息位置和集合位置抽象成一根数轴。一共有 $n$ 个学生，第 $i$ 个学生的休息位置是 $a_i$。每一次命令，教官会指定一个区间 $[l,r]$ 和集合点 $K$ ，所有编号在 $[l,r]$ 内的学生都必须赶到集合点列队。在列队时，每一个学生需要选择 $[K,K+r-l]$ 中的一个整数坐标站定且不能有任何两个学生选择的坐标相同。学生从坐标 $x$ 跑到坐标 $y$ 需要耗费体力 $|y-x|$ 。

在一天的训练中，教官一共发布了 $m$ 条命令 $(l,r,K)$ ，现在你需要计算对于每一条命令，在所有可能的列队方案中，消耗的体力值总和最小是多少。

以下是对题意的一些补充：

* 任何两条命令是无关的，即在一条集合命令结束后，所有学生都会回到自己的休息位置，然后教官才会发出下一条命令。
* 在集合的时候，可能有编号不在 $[l,r]$ 内的学生处在区间 $[K,K+r-l]$ 中，这时他会自己跑开，且跑动的距离不记在消耗的体力值总和中。

---

## 题解

显然，不原相对顺序更优。

因此答案为 $\sum\limits_{i=l}^r{a_i+rk_i-k-1}$ 。

把这个式子拆掉绝对值，就变为了向左跑和向右跑的两种情况。

在可持久化权值线段树上记录 $\sum a_i$ 即可。

其他的 $rk_i$ 的和是个等差数列求值。

---

## $\mathrm{Code}$

从今天起更改码风。

```cpp
#include<bits/stdc++.h>
using namespace std;

typedef long long LL;

const int maxn = 500007;
const int maxs = 11000007;
const int s = 1000000;

int n, T;
int rt[maxn];
int ls[maxs], rs[maxs], cnt;
int size[maxs];

LL sum[maxs];

void Insert(int &x ,int l, int r, int val) {
	ls[++cnt] = ls[x], rs[cnt] = rs[x], size[cnt] = size[x] + 1, sum[cnt] = sum[x] + (LL)val;
	x = cnt;
	if(l == r) return ;
	int mid = (l + r) >> 1;
	if(val <= mid) Insert(ls[x], l, mid, val);
	else Insert(rs[x], mid + 1, r, val);
}

int k;

LL Query(int rt1, int rt2, int l, int r, int st) {
	if(size[rt1] - size[rt2] == 0) return 0ll;
	LL sz = size[rt1] - size[rt2], sigma = sum[rt1] - sum[rt2];
	if(l >= k + st) return sigma - sz * (2 * st + 2 * k + sz - 1) / 2;
	if(r <= k + st + sz - 1) return sz * (2 * st + 2 * k + sz - 1) / 2 - sigma;
	int mid = (l+r) >> 1;
	return Query(ls[rt1], ls[rt2], l, mid, st) + Query(rs[rt1], rs[rt2], mid + 1, r, st + size[ls[rt1]] - size[ls[rt2]]);
}

void Init(void) {
	scanf("%d%d", &n, &T);
	for(int i = 1, x; i <= n; i++) {
		scanf("%d", &x);
		rt[i] = rt[i-1];
		Insert(rt[i], 1, s, x);
	}
}

void Work(void) {
	while(T--) {
		int l, r;
		scanf("%d%d%d", &l, &r, &k);
		printf("%lld\n",Query(rt[r], rt[l-1], 1, s, 0));
	}
}

int main() {
	Init();
	Work();
	return 0;
}
```

---

## 作者：DeepSeaSpray (赞：0)

# LGP4559 [JSOI2018] 列队

首先，对于一些同学，他们集合的顺序即为他们原来的顺序一定不劣。

每一个同学跑动距离：$| K+rk_i-1-a_i |$

考虑去绝对值，即考虑每一个同学向左还是向右跑。

从“导数”层面考虑 $K+rk_i-1-a_i$，由于两个同学不在同一个位置。所以 $1 \leq \Delta rk_i \leq \Delta a_i$。故其“导数”不大于 $0$。

故 $K+rk_i-1-a_i$ 是不上升的，所以我们可以通过区间两端点判断一个区间内同学的向左向右跑状态。

我们考虑在在权值线段树上分治：

- 如果区间内没有同学，返回。
- 如果区间内所有同学都向左跑，统计答案。
- 如果区间内所有同学都向右跑，统计答案。
- 否则，向下递归。

时间复杂度与在权值线段树上二分相同。

由于还有编号 $[l,r]$ 的限制，使用可持久化权值线段树即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int maxn=5e5;
const int maxm=5e7;
const int tp=1e6;
struct Node{int ls,rs,sz;ll sm;};
int n,m;
int rt[maxn+5];
int tt;
Node T[maxm+5];
void Modify(int &x,int y,int L,int R,int p){
	T[x=++tt]=T[y];
	T[x].sz++,T[x].sm+=p;
	if(L==R) return;
	else{
		int mid=(R-L)/2+L;
		if(p<=mid) Modify(T[x].ls,T[y].ls,L,mid,p);
		else Modify(T[x].rs,T[y].rs,mid+1,R,p);
	}
}
ll Query(int x,int y,int L,int R,int K,int S){
	if(T[x].sz==T[y].sz) return 0;
	else{
		int cnt=T[y].sz-T[x].sz;
		ll sum=T[y].sm-T[x].sm;
		int mid=(R-L)/2+L;
		if(K+S+cnt-1-R>=0)
			return 1ll*cnt*(2*K+2*S+cnt-1)/2-sum;
		else if(K+S-L<=0)
			return sum-1ll*cnt*(2*K+2*S+cnt-1)/2;
		else{
			return Query(T[x].ls,T[y].ls,L,mid,K,S)
			+Query(T[x].rs,T[y].rs,mid+1,R,K
				,S+T[T[y].ls].sz-T[T[x].ls].sz);
		}
	}
}
signed main(){
	int l,r,x;
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++){
		scanf("%d",&x);
		Modify(rt[i],rt[i-1],1,tp,x);
	}
	while(m--){
		scanf("%d%d%d",&l,&r,&x);
		printf("%lld\n",Query(rt[l-1],rt[r],1,tp,x,0));
	}
	return 0;
}
```

---

## 作者：DengDuck (赞：0)

显然最优情况下排序之后顺序不会变化。

首先我们把整个数轴建成线段树，考虑到每次只关心 $[l,r]$ 的人，所以我们考虑每次加入一个人作为一个版本来可持久化，然后通过作差就可以得到只包含 $[l,r]$ 的数轴了。

我一开始的想法是：找出这样一个位置，使得这个位置左边的人都是向右走的，这个位置向左的人都是向右走的。

但是这个还是复杂了。

我们可以直接考虑递归求解，一直向下拆分直到所有人都向左/右走，这时我们可以直接在线段树上维护出位置的区间和，再结合一个等差数列算算就做完了。

时间复杂度为 $\mathcal O((n+m)\log n)$。

```cpp
#include<bits/stdc++.h>
#define LL long long
#define Mid (L+R>>1)
using namespace std;
const int N=5e5+5;
const int Inf=1e6;
int n,Q,Rt[N],Ls[N*30],Rs[N*30],Sz[N*30],TOT;
LL S[N*30];
void Upd(int &u,int L,int R,int x)
{
	Ls[++TOT]=Ls[u],Rs[TOT]=Rs[u];
	Sz[TOT]=Sz[u]+1,S[TOT]=S[u]+x;u=TOT;
	if(L==R)return;
	if(x<=Mid)Upd(Ls[u],L,Mid,x);
	else Upd(Rs[u],Mid+1,R,x);
}
LL Qry(int u1,int u2,int L,int R,int k)
{
	if(Sz[u1]==Sz[u2])return 0;
	LL Siz=Sz[u1]-Sz[u2],Sum=S[u1]-S[u2];
	if(k<=L)return Sum-(2*k+Siz-1)*Siz/2;
	if(R<=k+Siz-1)return (2*k+Siz-1)*Siz/2-Sum;
	int K=Sz[Ls[u1]]-Sz[Ls[u2]];
	return Qry(Ls[u1],Ls[u2],L,Mid,k)+Qry(Rs[u1],Rs[u2],Mid+1,R,k+K);
}
int main()
{
	scanf("%d%d",&n,&Q);
	for(int i=1,x;i<=n;i++)
	{
		scanf("%d",&x);
		Upd(Rt[i]=Rt[i-1],1,Inf,x);
	}
	while(Q--)
	{
		int L,R,K;
		scanf("%d%d%d",&L,&R,&K);
		printf("%lld\n",Qry(Rt[R],Rt[L-1],1,Inf,K));
	}
}
```

---


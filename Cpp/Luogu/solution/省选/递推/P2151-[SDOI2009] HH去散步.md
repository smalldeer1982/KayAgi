# [SDOI2009] HH去散步

## 题目描述

HH 有个一成不变的习惯，喜欢饭后百步走。所谓百步走，就是散步，就是在一定的时间内，走过一定的距离。但是同时 HH 又是个喜欢变化的人，所以他不会立刻沿着刚刚走来的路走回。又因为 HH 是个喜欢变化的人，所以他每天走过的路径都不完全一样，他想知道他究竟有多少种散步的方法。

现在给你学校的地图（假设每条路的长度都是一样的都是 $1$），问长度为 $t$，从给定地点 $A$ 走到给定地点 $B$ 共有多少条符合条件的路径。

## 说明/提示

### 数据范围及约定

对于 $30\%$ 的数据，$N \le 4$，$M \le 10$，$t \le 10$。

对于 $100\%$ 的数据，$N \le 50$，$M \le 60$，$t \le 2^{30}$，$0 \le A,B$。

## 样例 #1

### 输入

```
4 5 3 0 0
0 1
0 2
0 3
2 1
3 2```

### 输出

```
4```

# 题解

## 作者：LeavingZzz (赞：83)

# P2151 题解
                                                by LeavingZ 
upd on 2023.9.2 增加了对 $t=0$ 的特判并且修改了快速幂的写法使其能处理指数为 $0$ 的情况。
## 在一切开始之前  
请确保[题目](https://www.luogu.com.cn/problem/P2151)您已经**仔细**看完了。  
蒟蒻也是刚学矩阵加速,做到了这道题,做了很久才做出来,希望分享自己的思维历程给大家。  
## 一点闲话(若只是想看该题解法请跳过)  
这道题要求的是**图中定长路线的方案数**,这种题目是可以将邻接矩阵进行乘幂的,如果您不知道这个,您可以先去做一下[这道题](https://www.luogu.com.cn/problem/P4159)  
但是很多人(~~包括我~~)不理解邻接矩阵乘幂到底有什么意义,或者他是怎么来的,我在这里和大家简单的说(bian)一下[始终要注意邻接矩阵是一个方阵]。  
看下面这个图：  
![图](https://cdn.luogu.com.cn/upload/image_hosting/1efs0zjz.png)  
这里以矩阵的 $2$ 次幂为例,按刚才的说法就是长度为 $2$ 的线路的方案数。  
![矩阵](https://cdn.luogu.com.cn/upload/image_hosting/si38bcu9.png)  
比如原矩阵的 $(1,2)$ 表示点 $1$ 可以到点 $2$ 去,而矩阵乘法可以看做是图中的两个箭头不断地走,比如黑箭头在走第一行的时候,第二个元素是 $1$,要想新矩阵中有含 $1$ 的元素,右边蓝箭头走到第 $2$ 个元素时也得出现 $1$ 才可以  
而我们知道,右边蓝箭头走到第二个元素就是第二行,也就是从点 $2$ 出发可以到达的点,当点 $1$ 可以到点 $2$ 时,从点 $2$ 出发的可以到达的所有点与点 $1$ 的距离都是 $2$,符合我们说的矩阵$2$次幂的意义。  
## main()  
那么这道题要干什么呢,也是求路径方案数,也是定长,但是有个限制让它变得不是那么裸,就是它是无向图但是不可以直接沿着一条边**走过来马上走回去**，那么我们怎么办呢？  
在抛开一切的情况下我们想一下，如果没有限制，我们会用 DP 的做法，以已经走过来的距离划分阶段，$F[i][j]$ 表示走过 $i$ 距离的时候在 $j$ 点的方案数那么有：  

$$F[i][j]=\sum\limits_{k\in to[j]} F[i-1][k]$$  
$to[j]$ 表示能够到达 $j$ 点的点集  

那么如果我们再用这种状态的定义和转移来看看这道题呢，那你很快就会发现解决不了，因为这样的话由于是无向边，转移很有可能就违背了约束(刚刚转移到这个点马上转移回去),那么我们就会用到常用的一个技巧就是**点边互换**。  
将点边互换，上述转移方程**几乎不变**：  

$$F[i][j]=\sum\limits_{k\in to[j]} F[i-1][k]$$
$to[j]$ 表示能够到达 $j$ 边的边集  

能够到达 $j$ 边的边集就是终点为边j的始点的边组成的集合  
(这里都说了始点和终点了难道看不出来是把无向边1拆2吗)  
为满足题目条件，只需要在 $to[j]$ 中去除掉j的反边就可以了。  
ah♂~，这道题我已经.....不对，距离小于等于 $2e9$ ...(~~MLE反光~~）  

那么我们怎么优化呢？  
我们的方程是那个样子,,,,这道题又谈到了**定长路线方案数**，考虑用矩阵来优化，把状态存到一个矩阵里面，再**构造一个转移矩阵**来进行转移。
![转移矩阵1](https://cdn.luogu.com.cn/upload/image_hosting/dyouojr3.png)  

$$F[i][k]=\sum\limits_{j\in to[k]} F[i-1][j]$$  
$to[k]$ 表示能够到达 $k$ 边的边集

怎么让这个矩阵体现这这个方程呢？  
注意到那两个箭头了吗？  
第一个矩阵中第 $x$ 行的第 $y$ 个元素如果是$1$的话那么在最右边的结果矩阵中得到的新状态 $F[i][k_x]$ 就会把第二个矩阵中的 $F[i-1][k_y]$ 累加进去，如果是$0$的话就不会累加。  
所以我们为了满足状态转移方程，对于最左边矩阵(即转移矩阵)中的第 $k$ 行只将 $to[k]$ 中的对应元素设为$1$，**也就是说，$m[x][y]=1$ 表示编号为 $y$ 的边可以转移到编号为 $x$ 的边上去**，那么转移矩阵就被构造成了一个边长 $2M$ 的方阵。 
![转移矩阵2](https://cdn.luogu.com.cn/upload/image_hosting/a68m47xc.png)  
$to[k]$ 表示的是可以转移到第 $k$ 条边的边集，这个地方我们用一行 $01$ 表示不包含与包含，如果第 $x$ 条边可以转移到第 $y$ 条边就把 $m[y][x]$ 置成 $1$，否则为 $0$ (**下标不要搞反了**)  

答案状态要从初始状态一步步转移来，那么要转移多少次呢？我们是按照走出的距离划分阶段的，所以要转移$t$次  

矩阵乘法满足结合律但是不满足交换律，所以答案状态就是初始矩阵乘以转移矩阵的 $t$ 次幂(**但是在这道题里面要有点小小的变化**)，然后在结果矩阵里把终点为给定终点的方案数累加起来即可。  

------------

代码实现相信大家看到这里已经有些想法了，**尽量自己想，这样自己才会有真正的收获**，实在debug太久了再来代码里面找我。  
```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
const int mod=45989;
struct Matr{
	int m[150][150];
	int R,C;
	Matr() {memset(m,0,sizeof(m));}
	Matr operator * (const Matr &a) const
	{
		Matr t;
		t.R=R;t.C=a.C;
		for(int i=1;i<=R;i++)
		for(int j=1;j<=t.C;j++)
		for(int k=1;k<=C;k++)
		t.m[i][j]=(t.m[i][j]+(m[i][k]*a.m[k][j])%mod)%mod;
		return t;
	}
}ini,trans;//分别是初始矩阵和转移矩阵
struct E{
	int u,v;
}e[127];//为了更方便的枚举边使用邻接表存储边
int first[57],nt[127],ES;
int N,M,S,T,t;
Matr operator ^ (Matr a,int k)//矩阵快速幂
{
	Matr s;
	s.C=a.C;s.R=a.R;
	for(int i=1;i<=a.R;i++)
		s.m[i][i]=1;
	while(k)
	{
		if(k&1) s=s*a;
		a=a*a;
		k>>=1;
	}
	return s;
}
int anti(int x)//因为我是从1开始存边所以不能异或只能自己写函数了
{
	return x%2==0?x-1:x+1;
}
int main()
{
	scanf("%d%d%d%d%d",&N,&M,&t,&S,&T);
	if(t==0)//特殊判断t=0的情况
	{
		puts("0");
		return 0;
	}
	int u,v;S++;T++;//题目给的是0开始编号要记得加
	for(int i=1;i<=M;i++)
	{
		scanf("%d%d",&u,&v);u++;v++;//要记得加
		e[++ES]=(E){u,v};
		nt[ES]=first[u];
		first[u]=ES;
		e[++ES]=(E){v,u};
		nt[ES]=first[v];
		first[v]=ES;
	}
	for(int i=1;i<=ES;i++)
	{//如果某一条边的始点与当前这条边的终点重合
         //则称当前这条边可以转移到"某一条边"
		for(int k=first[e[i].v];k;k=nt[k])
		{
			if(k!=anti(i))//记得不可以是反边，否则会违背题目要求
			trans.m[k][i]++;//下标千万莫写反了，自己要搞清楚
		}
	}
	trans.C=trans.R=ES;//矩阵大小表示
	ini.R=ES;ini.C=1;//表示错了乘法无法正确进行
	for(int i=first[S];i;i=nt[i])
		ini.m[i][1]++;//由于初状态不好确定  
        //干脆就把初始矩阵当成已经走出的距离为1时的状态
	trans=trans^(t-1);
        //因为初始矩阵当成了距离为1的状态这里只能t-1次幂
	trans=trans*ini;
	int ans=0;
	for(int i=first[T];i;i=nt[i])
        //直接枚举终点为给定点的边不太好枚举
        //就枚举始点为给定终点的边然后取反边即可
	ans=(ans+trans.m[anti(i)][1])%mod;//我最开始还没取模.....
	printf("%d",ans);
	return 0;
}
```
矩阵加速的题目这是很经典的一道，先用 $DP$ (递推)写方程再考虑矩阵的构造，仔细想想，总会A的；  

基本思路：  
- 点边互换  
- 构造边集01矩阵
- 去除反边
- 矩阵快速幂加速  

本题易错点总结：  
- 矩阵乘法本身写错了。  
- 表示状态的下标写反了(或者前后下标意义不一致)。  
- 矩阵大小行列傻傻分不清QwQ。  
- 矩阵乘法不满足交换律,而做乘法的时候写反了。  

如果有任何问题或者不明白都可以在讨论中发表您的意见或者直接私信我，我会尽力帮您解决。  
谢谢管理大大审核^_^ 

---

## 作者：tkysss (赞：23)

不会矩阵加速floyd的可以先去[P4159](https://www.luogu.org/problemnew/show/P4159)这里

如果没有不允许走来的边的限制就很裸

考虑如何将双向变变得有差异

把边看成点，正向x->y建一条边，反向y->x建一条边，如果   

E1:x->y  , E2:y->z   则E1向E2连一条边；

这样如何处理走回来的情况呢？？

只要同一条边拆出来的两个点不相互连边即可；

```c
#include<bits/stdc++.h>
#define ll long  long 
using namespace std;
const int N=151,mod=45989;
int n,m,s,t,x[N],y[N],cnt;
ll T;
struct mat{
	int c[N][N];
	mat(){memset(c,0,sizeof(c));}
	mat operator *(const mat&A){
		mat re;
		for(int i=1;i<=cnt;i++)
		for(int j=1;j<=cnt;j++)
		for(int k=1;k<=cnt;k++)
			re.c[i][j]=(re.c[i][j]+c[i][k]*A.c[k][j]%mod)%mod;
		return re;
	}
}A;
mat pow(mat x,ll y){
	mat re;for(int i=1;i<=cnt;i++)re.c[i][i]=1;
	while(y){
		if(y&1)re=re*x;
		y>>=1;x=x*x;
	}
	return re;
}
int main(){
//	freopen("bzoj1875.in","r",stdin);
//	freopen("bzoj1875.out","w",stdout);
	scanf("%d%d%lld%d%d",&n,&m,&T,&s,&t);
	s++;t++; x[++cnt]=0;y[cnt]=s;
	for(int i=1,u,v;i<=m;i++){
		scanf("%d%d",&u,&v);
		u++,v++;
		x[++cnt]=u,y[cnt]=v;
		x[++cnt]=v,y[cnt]=u;
	}
	for(int i=1;i<=cnt;i++)
	for(int j=1;j<=cnt;j++)if(i!=j&&i!=(j^1)){
		if(y[i]==x[j])A.c[i][j]=1;
	}
	mat Ans = pow(A,T);
	int ans=0;
	for(int i=1;i<=cnt;i++)if(y[i]==t){
		ans = (ans + Ans.c[1][i]) %mod; 
	}
	cout<<ans<<endl;
	return 0;
} 
```

---

## 作者：Orion545 (赞：20)

# 广告

[蒟蒻的blog](http://www.cnblogs.com/dedicatus545/p/8685858.html)

# 正文

其实就是让你求有多少条长度为t的路径，但是有一个特殊条件：不能走过一条边以后又立刻反着走一次（如果两次经过同意条边中间隔了别的边是可以的）

如果没有这个特殊条件，我们很容易想到dp做法：设$dp\left[i\right]\left[j\right]$表示第i个时刻（初始算0），走到第j个点的答案总数

但是这里要限制不能反复走，那么直接设点会导致信息丢失

那我们怎么样才能让保存当前所在点的情况下，不丢失最后一条边的信息呢？

答案非常显然，我们只要设$dp\left[i\right]\left[j\right]$表示第i个时刻（初始算0），走到第j条边的终点（也就是刚刚经过了第j条边到达这里）的答案总数，就可以了

此时我们因为知道第j条边的所有信息，而第j条边的信息中又包括了当前所在节点，所以我们继续转移需要的信息都收集全了

转移就是从当前点$u$开始，枚举从$u$出发的边$k$，向$dp\left[i+1\right]\left[to\left(k\right)\right]$转移即可

然而这里有个问题：T太大了，直接转移肯定爆炸，那怎么办呢？

我们观察可得，对于每个$dp\left[i\right]\left[j\right]$，只要$j$确定了，那么他应该往哪些状态转移也就确定了，同时这个转移一定是线性的（也就是$dp$这一项一定是一次的）

那我们还等什么呢？矩阵快速幂上啊！

我们构造转移矩阵B和初始状态矩阵A，但是这里又有一个问题：初始只有一个出发节点，并没有不能走哪条边的限制，但是转移矩阵B又依赖于这个限制，怎么办呢？

这好说，我们只要把A矩阵从所有$dp\left[0\right]\left[j\right]$变成所有$dp\left[1\right]\left[j\right]$就好了

这时答案矩阵$C=A\ast B^{t-1}$

只要取出答案矩阵中所有终点是给定终点的边的答案之和，输出即可

# Code

写了结构体重载运算符......慢死

还好加了读入优化苟过去了

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define ll long long
using namespace std;
inline ll read(){
    ll re=0,flag=1;char ch=getchar();
    while(ch>'9'||ch<'0'){
        if(ch=='-') flag=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9') re=(re<<1)+(re<<3)+ch-'0',ch=getchar();
    return re*flag;
}
ll MOD=45989;
ll n,m,op,ed,tt,cnt=0,first[110];
struct edge{//邻接表存边
    ll next,to;
}a[150];
inline void add(ll u,ll v){//矩阵结构体
    a[++cnt]=(edge){first[u],v};first[u]=cnt;
    a[++cnt]=(edge){first[v],u};first[v]=cnt;
}
struct ma{
    ll a[150][150],n,m;
    ma(){memset(a,0,sizeof(a));n=m=0;}
    void clear(){memset(a,0,sizeof(a));n=m=0;}
    const ma operator *(const ma &b){
        ma re;re.n=n;re.m=b.m;ll i,j,k;
        for(i=1;i<=n;i++){
            for(k=1;k<=m;k++){
                if(!a[i][k]) continue;
                for(j=1;j<=b.m;j++){
					re.a[i][j]+=(a[i][k]*b.a[k][j]);
                    re.a[i][j]%=MOD;
                }
            }
        }
        return re;
    }
    const void operator =(const ma &b){
        n=b.n;m=b.m;ll i,j;
        for(i=1;i<=n;i++) for(j=1;j<=m;j++) a[i][j]=b.a[i][j];
    }
}A,B;
void qpow(ma &x,ma y,ll T){
    while(T){
        if(T&1) x=x*y;
        y=y*y;T>>=1;
    }
}
ll o(ll x){return ((x%2)?(x+1):(x-1));}//求一条边的反向边（因为我是一开始编号的，所以不方便直接异或）
int main(){
    memset(first,-1,sizeof(first));ll i,t1,t2,j,u;
    n=read();m=read();tt=read();op=read();ed=read();op++;ed++;
    for(i=1;i<=m;i++){
        t1=read();t2=read();t1++;t2++;
        add(t1,t2);
    }
    A.n=1;A.m=B.m=B.n=cnt;
    for(j=1;j<=cnt;j++){//构造转移矩阵
        u=a[j].to;
        for(i=first[u];~i;i=a[i].next){
            if(i==o(j)) continue;
            B.a[j][i]+=1;
        }
    }
    for(i=first[op];~i;i=a[i].next){//构造初始矩阵
        A.a[1][i]+=1;
    }
    qpow(A,B,tt-1);ll ans=0;
    for(i=first[ed];~i;i=a[i].next){//统计答案
        ans=(ans+A.a[1][o(i)])%MOD;
    }
    printf("%lld",ans);
}
```

---

## 作者：roufaen (赞：11)

发一个用边进行动态规划的方法吧

我们先列出动态规划的递推方程：

设f[t][i]表示已经走到距离t，并且第t步经过边i的方案总数，则f[t][i]=Σf[t-1][j]，其中边j可以直接连向边i

很显然一条无向边应该拆分为两条有向边，因为行走在同一条边的不同方向上，更新方案数的方法是不同的

最后，根据动态规划方程的特点和t比较大的事实，我们考虑使用矩阵优化

最后贴代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define MAXN 2*60+10
#define MOD 45989

int n, m, t, a, b, l[MAXN], r[MAXN];
int matrix[3][MAXN][MAXN], st[MAXN], en[MAXN], ans=0;

void Input(){
	memset(matrix, 0, sizeof(matrix));
	memset(st, 0, sizeof(st));
	memset(en, 0, sizeof(en));
	scanf("%d%d%d%d%d", &n, &m, &t, &a, &b);
	for(int i=0; i<m; i++){
		scanf("%d%d", &l[i*2], &r[i*2]);
		//建立反向边 
		//为了后面方便判断一条边是否为另一条边的反向边，一对反向边的编号是相邻的 
		l[i*2+1]=r[i*2], r[i*2+1]=l[i*2];
	}
}

void Mul(int target, int base){//矩阵乘法 
	memset(matrix[2], 0, sizeof(matrix[2]));
	for(int i=0; i<2*m; i++)
		for(int j=0; j<2*m; j++)
			for(int k=0; k<2*m; k++)
				matrix[2][i][j]=(matrix[2][i][j]+(matrix[target][i][k]*matrix[base][k][j])%MOD)%MOD;
	for(int i=0; i<2*m; i++)
		for(int j=0; j<2*m; j++)
			matrix[target][i][j]=matrix[2][i][j];
}

void Work(){
	//构造起始向量 
	for(int i=0; i<2*m; i++)
		l[i]==a?st[i]=1:0;
	//构造单位矩阵 
	for(int i=0; i<2*m; i++)
		matrix[1][i][i]=1;
	//构造矩阵 
	//两条边相连当且仅当它们首尾相连且不是反向边 
	//注意了：不能认为连接一对相同点的边是反向边，因为题目没有说两点之间仅有一条边 
	for(int i=0; i<2*m; i++)
		for(int j=0; j<2*m; j++)
			if(l[i]==r[j] && i!=(j^1))
				matrix[0][i][j]=1;
	t--;//注意t--，因为起始向量表示的是已经走了1步的情况，所以再走t-1步就可以了 
	while(t){//矩阵快速幂 
		if(t&1)  Mul(1, 0);
		Mul(0, 0), t>>=1;
	}
	//构造终止向量 
	for(int i=0; i<2*m; i++)
		for(int j=0; j<2*m; j++)
			en[i]=(en[i]+matrix[1][i][j]*st[j])%MOD;
	//统计答案 
	for(int i=0; i<2*m; i++)
		r[i]==b?ans=(ans+en[i])%MOD:0;
	printf("%d\n", ans);
}

int main(){
	freopen("walk.in","r", stdin);
	freopen("walk.out","w", stdout);
	Input();
	Work();
	fclose(stdin);  fclose(stdout);
	return 0;
}
```

---

## 作者：ez_lcw (赞：8)

看到题目第一眼，最暴力的想法就是设 $dp(i,j)$ 表示以 $a$ 为起点、$i$ 为终点，路径长度为 $j$ 的路径数。

容易得到状态转移方程：$dp(u,j)=\sum_{(v,u)}dp(v,j-1)$。

但是我们发现一个问题：题目中要求“人物不能立刻沿着刚刚走来的路走回”，但显然这种 dp 方式是不符合要求的，所以想怎么解决。

这里用到一个常用的小trick：我们先把双向边拆成两条单向边，共 $2m$ 条，并编号。然后设 $dp(i,j)$ 表示以 $a$ 为起点、刚好走完编号为 $i$ 的这条单向边，路径长度为 $j$ 的路径数。你也可以理解成把边当成点。

状态转移方程同样也容易得到：

![](https://cdn.luogu.com.cn/upload/image_hosting/zxrzo0i1.png)

如图，设单向边 $(u,v)$ 的编号为 $i$，所有终点为 $u$ 的单向边的边集为 $S_i$（也就是红圈圈出来的部分）。

显然有：$dp(i,j)=\sum_{k\in S_i}dp(k,j-1)$。

把 dp 的第二维滚动一下，即可 $O(mt)$ 获得 30pts。

发现问题的瓶颈主要在 $t$ 上，思考如何优化。

仔细观察 dp 式，发现和 [【NOI Online #3 提高组】魔法值](https://www.luogu.com.cn/problem/P6569) 的做法很相似。

于是联想到用矩阵快速幂来加速 dp 过程。

设计矩阵：（第二维被滚动掉了）

$\begin{bmatrix}
dp(1)\\
dp(2)\\
\cdots\\
dp(2m)
\end{bmatrix}$

然后根据上面推出的式子：$dp(i,j)=\sum_{k\in S}dp(k,j-1)$，可以设计出转移矩阵：（这里的 $c_{i,j}$ 表示 $j$ 是否属于集合 $S_i$，属于则 $c_{i,j}=1$，否则 $c_{i,j}=0$）

$B=\begin{bmatrix}
c_{1,1},&c_{1,2},&\dots,&c_{1,2m}\\
c_{2,1},&c_{2,2},&\dots,&c_{2,2m}\\
\cdots&\cdots&\cdots&\cdots\\
c_{2m,1},&c_{2m,2},&\dots,&c_{2m,2m}\\
\end{bmatrix}$

设初始矩阵是 $A$（表示所有 $dp(i,1)$ 的值），那么答案矩阵即为：$Ans=A\times B^{t-1}$，表示的是所有 $dp(i,t)$ 的值。

那么答案就是终点为 $b$ 的每一条单向边的 $dp$ 值的总和。

总时间复杂度为 $O(m^3\log t)$，可以跑过。

------------

顺带提一下我一开始的错误想法：设 $dp(i,j)$ 表示以 $a$ 为起点、$i$ 为终点，路径长度为 $j$ 的路径数，然后找到与 $i$ 距离为 $2$ 的点 $v$，用 $dp(v,j-2)$ 来更新 $dp(i,j)$，这样就能保证不会出现 $i$ 走到一个点又走回头路的情况了。但是下面这种图就能卡掉这个算法：

![](https://cdn.luogu.com.cn/upload/image_hosting/i97rrxjn.png)

询问 $t=3$，$a=2$，$b=3$。显然答案为 $0$，但是上面那种做法的答案是 $1$。

至于为什么是错的我不详细阐述了，如果也是像我一样相同想法的可以结合这个例子自己回去模拟一下并想一想。

正解的代码及注释如下：

```cpp
#include<bits/stdc++.h>
 
#define N 25
#define M 65
#define mod 45989
 
using namespace std;
 
int n,m,t,a,b;
int cnt=1,head[N],to[M<<1],nxt[M<<1];
 
struct Matrix
{
    int a[M<<1][M<<1];
    Matrix(){memset(a,0,sizeof(a));}
    void init(){for(int i=1;i<=cnt;i++) a[i][i]=1;}
}st,ch;
 
Matrix operator * (Matrix a,Matrix b)
{
    Matrix c;
    for(int i=1;i<=cnt;i++)
        for(int j=1;j<=cnt;j++)
            for(int k=1;k<=cnt;k++)
                c.a[i][j]=(c.a[i][j]+a.a[i][k]*b.a[k][j])%mod;
    return c;
}
  
Matrix poww(Matrix a,int b)
{
    Matrix ans;
    ans.init();
    while(b)
    {
        if(b&1) ans=ans*a;
        a=a*a;
        b>>=1;
    }
    return ans;
}
//以上是矩阵快速幂板子
 
void adde(int u,int v)
{
    to[++cnt]=v;
    nxt[cnt]=head[u];
    head[u]=cnt;
}
 
void init()
{
    for(int i=head[a];i;i=nxt[i])
        st.a[1][i]=1;//设计初始矩阵
    for(int i=2;i<=cnt;i++)//枚举每条边i，这里其实是先枚举Si再去更新i
    {
        int u=to[i];
        for(int j=head[u];j;j=nxt[j])
            if(j!=(i^1))
                ch.a[i][j]++;//设计转移矩阵
    }
}
 
int main()
{
    scanf("%d%d%d%d%d",&n,&m,&t,&a,&b);
    a++,b++;
    for(int i=1;i<=m;i++)
    {
        int u,v;
        scanf("%d%d",&u,&v);
        u++,v++;
        adde(u,v),adde(v,u);//两条单向边
    }
    init();
    Matrix tmp=st*poww(ch,t-1);
    int ans=0;
    for(int i=2;i<=cnt;i++)
        if(to[i]==b)//枚举每一条终点是b的单向边
            ans=(ans+tmp.a[1][i])%mod;
    printf("%d\n",ans);
    return 0;
}
```

---

## 作者：devout (赞：3)

先说一下自己开始的想法吧

看题面+数据范围就可以看出是一个矩阵乘法题

我们发现我们不走重边有一个很简单的解决方法，把上上次的减掉就可以了

设$G_t$表示走$t$条边的情况，那么为了方便减掉上上次的，我们可以构造这样一个矩阵转移

$$
\begin{bmatrix}
G_t,G_{t-1}
\end{bmatrix}
\times
\begin{bmatrix}
S,0 \\
-I,I
\end{bmatrix}
=
\begin{bmatrix}
G_{t+1},G_t
\end{bmatrix}
$$

其中$S$是转移的邻接矩阵，$I$是单位矩阵

但是为啥不对呢？我们发现这个东西可能有重边，所以就GG了

****

那么正确的方法是什么呢？

我们想让一条边不被连续经过，而我们现在只能保证一个点不被连续经过，所以我们可以把边看成点，建出一个新的邻接矩阵。

但是这时候问题又来了，我们怎么样才能计算答案呢？

我们可以再建立一个矩阵$A$，让他从$s$走到边上，也就是对于$s$的每条出边$i$，$A[1][i]=1$，这里为什么用$1$开始呢，因为我们遍历反边的时候存图需要从$2$开始存，刚好$1$空出来了而已

那么最后答案就是对于$t$的每条入边$i$，$\sum ans[1][i]$

因为模数很小不用开longlong

****

**tips**

- 因为异或`^`操作优先级很低，所以判断两条边是否相反的时候要加上括号

- 因为一条边正反各遍历一次，所以在建新图$G$的时候，我们不需要把反边也$+1$，等遍历到反边的时候再加就行，或者直接$=1$也行，应为这个时候就没有重边了


最后一个点貌似评测机波动还挺大（

```cpp
#include <bits/stdc++.h>
using namespace std;

# define Rep(i,a,b) for(int i=a;i<=b;i++)
# define _Rep(i,a,b) for(int i=a;i>=b;i--)
# define RepG(i,u) for(int i=head[u];~i;i=e[i].next)

typedef long long ll;

const int N=125;
const int mod=45989;

template<typename T> void read(T &x){
   x=0;int f=1;
   char c=getchar();
   for(;!isdigit(c);c=getchar())if(c=='-')f=-1;
   for(;isdigit(c);c=getchar())x=(x<<1)+(x<<3)+c-'0';
    x*=f;
}

int n,m,k,s,t;
int head[N],cnt=1;
int ans;

struct Edge{
    int to,next;
}e[N];

void add(int x,int y){
    e[++cnt]=(Edge){y,head[x]},head[x]=cnt;
}

struct matrix{
    int a[N][N];
    matrix(){
        memset(a,0,sizeof(a));
    }
    matrix operator * (const matrix &x)const{
        matrix res;
        Rep(i,1,m)
            Rep(j,1,m)
                Rep(k,1,m)
                    res.a[i][j]=(res.a[i][j]+a[i][k]*x.a[k][j])%mod;
        return res;
    }
}A,G;

matrix Qpow(matrix base,int ind){
    matrix res;
    Rep(i,1,m)res.a[i][i]=1;
    while(ind){
        if(ind&1)res=res*base;
        base=base*base;
        ind>>=1;
    }
    return res;
}

int main()
{
    memset(head,-1,sizeof(head));
    read(n),read(m),read(k),read(s),read(t);
    s++,t++;
    Rep(i,1,m){
        int x,y;
        read(x),read(y);
        x++,y++;
        add(x,y),add(y,x);
    }
    Rep(u,1,n)
        RepG(i,u){
            int v=e[i].to;
            RepG(j,v)if(j!=(i^1))G.a[i][j]=1;
        }
    m=cnt;
    RepG(i,s)A.a[1][i]++;
    G=A*Qpow(G,k-1);
    RepG(i,t){
        ans+=G.a[1][i^1];
        ans%=mod;
    }
    printf("%d\n",ans);
    return 0;
}
```


---

## 作者：Ydkwia (赞：2)

根据题意“（假设每条路的长度都是一样的都是1）”，可以将“长度t”当成“走过几段路”，举个例子，假设 A ——> B ——> C ，从A走到C走了两段路 ，由于每条路的长度都为1 ，所以就相当于走了长度为2的路。

于是 ， 当前状态为 最后经过第i条路，已走了j的长度 ，可以等价为 当前状态为 最后经过第i条路，已走了j段路 ，而 当前状态为 最后经过第i条路，已走了j段路 是可以由当前状态为 最后经过第k条路，已走了j-1段路推出（第i条路的终点与第k条路的起点相同）。

然后 ，t <= 2^30 的数据范围告诉我们 ，直接动态规划是不行的 。但 ，很显然由已走了j-1段路推出已走了j段路这样的状态转移是线性的 ，再加上[邻接矩阵平方的意义](https://blog.csdn.net/qq_35859033/article/details/78534993) ，就会想到矩阵快速幂（如不清楚矩阵快速幂，请先看看这题[P3390](https://www.luogu.org/problem/P3390)），时间复杂度大概为o(log2n * m * m ) ，肯定能过。

以下是我的代码 ~~码风有些奇怪，请勿嘲笑~~


```cpp
#include<bits/stdc++.h>

using namespace std ;

const int p = 45989 ;

struct data
{
	
	int wide ;
	
	int num[ 222 ][ 222 ] ;
	
	void sqr() 
	{
		
		data ans1 ;
		
		memset( ans1.num , 0 , sizeof( ans1.num ) ) , ans1.wide = wide ;
		
		for ( int i = 1 ; i <= wide ; i ++ )
			for ( int j = 1 ; j <= wide ; j ++ )
				for ( int k = 1 ; k <= wide ; k ++ ) ans1.num[ i ][ j ] = ( ans1.num[ i ][ j ] + ( num[ i ][ k ] * num[ k ][ j ] ) % p ) % p ;
				
		for ( int i = 1 ; i <= wide ; i ++ )
			for ( int j = 1 ; j <= wide ; j ++ ) num[ i ][ j ] = ans1.num[ i ][ j ] ;				
		
	}
	
} mat , ans ;

int sum_h[ 222 ] , sum_t[ 222 ] , n , m , x , y , z , t , sta , en ;

data operator*( const data &a , const data &b ) 
{
	
	data ans1 ;
	
	memset( ans1.num , 0 , sizeof( ans1.num ) ) , ans1.wide = a.wide ;
	
	for ( int i = 1 ; i <= a.wide ; i ++ )
		for ( int j = 1 ; j <= a.wide ; j ++ ) 
			for ( int k = 1 ; k <= a.wide ; k ++ ) ans1.num[ i ][ j ] = ( ans1.num[ i ][ j ] + ( a.num[ i ][ k ] * b.num[ k ][ j ] ) % p ) % p ;
			
	return ans1 ;
	
}

int main()
{
	
	scanf( "%d%d%d%d%d" , &n , &m , &t , &sta , &en ) , sta ++ , en ++ ;
	
	for ( int i = 1 ; i <= m ; i ++ ) scanf( "%d%d" , &sum_h[ i ] , &sum_t[ i ] ) , sum_h[ i + m ] = ++ sum_t[ i ] , sum_t[ i + m ] = ++ sum_h[ i ] ; // “++”是因为不小心把路口当成了1~n
	
	mat.wide = ans.wide = m * 2 ;// 矩阵的边长
	
	for ( int i = 1 ; i <= 2 * m ; i ++ )
		for ( int j = 1 ; j <= 2 * m ; j ++ )
			if ( ( j + m - i ) && ( i + m - j )/*判断是否是同一条路*/ && ( sum_t[ i ] == sum_h[ j ] ) ) mat.num[ i ][ j ] = 1 ;//填写矩阵
			
	for ( int i = 1 ; i <= 2 * m ; i ++ )
		if ( sum_h[ i ] == sta ) ans.num[ i ][ i ] = 1 ;//当前状态预处理
				
	t -- ;
	
	while ( t )
	{
		
		if ( t % 2 ) ans = ans * mat ;
		
		t >>= 1 ;
		
		mat.sqr() ;
		
	}//矩阵快速幂
	
	z = 0 ;
	
	for ( int i = 1 ; i <= 2 * m ; i ++ ) 
		if ( sum_t[ i ] == en ) 
			for ( int j = 1 ; j <= 2 * m ; j ++ ) z = ( z + ans.num[ j ][ i ] ) % p ;//判断终点
			
	printf( "%d" , z ) ;
	
	return 0 ;	
	
}

```
~~你可以抄题解，你甚至可以直接提交。但是，群众的眼睛是雪亮的！！！！如果你抄了题解，会让全天下的oiers知道，你是抄题解的大佬！！！~~
#         ~~你将会账号被棕~~




















---

## 作者：i207M (赞：2)

## 题目总结

# 今天颓废地调了一晚上，可能我是个ZZ吧；

给定一个无向图，求出经过k条边，不能立刻走上一条边的方案数；

## 数据范围

N ≤ 50，M ≤ 60，t ≤ 2^30，0 ≤ A,B

## 解题思路

首先，我们要按边转移，把每个点看作一条有向边所指的地方，这样我们就可以通过查看这条边是否和上一条边是来自同一个无向边（检查编号）来构建一个转移矩阵；

## 易错误区

因为要异或，所以计数器要从0或2开始；

找边的关系的时候直接暴力枚举；

记得构造初始矩阵，表示从原点可以到达的边；

乘起来，正确统计答案；

## 代码展示

常数略大

```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cmath>
#include<cstring>
#include<string>
#include<algorithm>
#include<vector>
#include<map>
#include<set>
#include<list>
#include<queue>
#include<stack>
#include<bitset>
#include<deque>
using namespace std;
#define ll long long
#define inf 0x3f3f3f3f
#define ri register int
#define il inline
#define fi first
#define se second
#define mp make_pair
#define pi pair<int,int>
#define mem0(x) memset((x),0,sizeof (x))
#define mem1(x) memset((x),0x3f,sizeof (x))
il char gc() {
    static const int BS = 1 << 22;
    static unsigned char buf[BS], *st, *ed;
    if (st == ed) ed = buf + fread(st = buf, 1, BS, stdin);
    return st == ed ? EOF : *st++;
}
#define gc getchar
template<class T>void in(T &x)
{
    x = 0; bool f = 0; char c = gc();
    while (c < '0' || c > '9') {if (c == '-') f = 1; c = gc();}
    while ('0' <= c && c <= '9') {x = (x << 3) + (x << 1) + (c ^ 48); c = gc();}
    if (f) x = -x;
}
#undef gc
void out(int x) {
    if (x < 0) putchar('-'), x = -x;
    if (x > 9) out(x / 10);
    putchar(x % 10 + '0');
}
#define N 130
#define M 130
int n, m, d, st, en;
int v[M], u[M];
int cnt = 1;
il void add(int uu, int vv) {
    u[++cnt] = uu, v[cnt] = vv;
}
#define Maxsz 130
#define md 45989
il void mod(int &x) {
    while (x > md) x -= md;
    while (x < 0) x += md;
}
struct Mat {
    int sz;
    int m[Maxsz][Maxsz];
    il void clear() {mem0(m);}
    Mat () {sz = 0; clear();}
    int* operator[](int x) {
        return this->m[x];
    }
    Mat operator*(const Mat &x)const {
        Mat res; res.sz = sz;
        for (ri i = 1; i <= sz; i++) {
            for (ri k = 1; k <= sz; k++) {
                for (ri j = 1; j <= sz; j++)
                    mod(res.m[i][j] += m[i][k] * x.m[k][j] % md);
            }
        }
        return res;
    }
    void operator*=(const Mat &x) {
        *this = (*this) * x;
    }
    void operator+=(const Mat &x) {
        for (ri i = 1; i <= sz; ++i) {
            for (ri j = 1; j <= sz; ++j) {
                mod(m[i][j] += x.m[i][j]);
            }
        }
    }
    Mat operator+(const Mat &x)const {
        Mat res = *this;
        res += x;
        return res;
    }
    void print() {
        for (ri i = 1; i <= sz; i++) {
            for (ri j = 1; j <= sz; j++)
                printf("%lld ", m[i][j]);
            puts("");
        }
        puts("*****************");
    }
    void toe() {
        clear();
        for (ri i = 1; i <= sz; i++)
            m[i][i] = 1;
    }
    Mat qpow(int x) {
        Mat res = *this, mul = res; x--;
        for (; x; x >>= 1, mul *= mul) if (x & 1) res *= mul;
        return res;
    }
} g, s,e;
ll ans;
signed main() {
    in(n), in(m), in(d), in(st), in(en);
    for (ri i = 1, x, y; i <= m; ++i) {
        in(x), in(y);
        add(x, y);
        add(y, x);
    }
    e.sz=s.sz = g.sz = cnt+1;
    for (ri i = 2; i <= cnt; ++i) {
        if (u[i] == st) {
        	/*for(ri j=1;j<=cnt;++j){
        		s.m[i][j]=1;
			}*/
			s.m[1][i]=1;
        }
        for (ri j = 2; j <= cnt; ++j) {
            if (v[i] == u[j] && (i ^ 1) != j) g.m[i][j] += 1;
        }
    }
    //s.print();g.print();
    g = g.qpow(d - 1);
    //g.print();
    for(ri i=2;i<=cnt;++i){
    	for(ri j=2;j<=cnt;++j){
    		(e.m[1][i]+=s.m[1][j]*g.m[j][i])%=md;
		}
	}
    //e.print();
    for (ri i = 2; i <= cnt; ++i) {
        if (v[i] == en) (ans += e.m[1][i]) %= md;//,cout<<"A"<<i;
    }
    printf("%lld", ans);
    return 0;
}
```

---

## 作者：grass8cow (赞：1)

标签：动态规划+矩阵乘法+卡常

我一开始是这么设计 DP 状态的：$f_{i,j}$ 为第 $i$ 时刻走到 $j$ 点的方案数。初始化 $f_{0,A}=1$ 。但写 DP 方程就觉得棘手了：由于“不能立刻沿着刚刚走来的路走回”，若 $j,k$ 间有边，$f_{i,j}$ 对 $f_{i+1,k}$ 做了贡献，$f_{i+1,k}$ 里有一部分值无法贡献给 $f_{i+2,j}$ 。我们换一种想法：把每条无向边 $f_{i,j}$ 为第 $i$ 时刻走到第 $j$ 条边的 **终点** 的方案数。有：

$f_{i,j}=\sum f_{i-1,k}$ ，其中 $k$ 的终点与 $j$ 的起点相同，且 $k$ 与 $j$ 不来自同一条无向边。

初始化为 $f_{1,j}=1$ , 其中 $j$ 为以 $A$ 为起点的所有边。输出$f_{t,B}$ 即可。复杂度为 $O(tm)$ ，可以愉快地超时。

显然可以用矩阵优化DP，方法不再多述。复杂度$O(m^3\log t)$ 。

这题卡常特别烦的。你不写快读试试？你不用氧气试试？（可能是我太菜了吧）

这道题最有价值的地方在于设计状态。
```cpp
#include<bits/stdc++.h>
using namespace std;
int head[121],cnt,n,m,T,s,t,mod=45989,sum;
struct qq
{
	int a[121][121];
}ans,p;
qq mul(qq a,qq b)
{
	qq c;
	for(int i=0;i<cnt;i++)for(int j=0;j<cnt;j++){c.a[i][j]=0;for(int k=0;k<cnt;k++)c.a[i][j]=(c.a[i][j]+a.a[i][k]*b.a[k][j])%mod;}
	return c;
}
int read()
{
	int now=0;char c=getchar();
	while(c<'0'||c>'9')c=getchar();
	while(c>='0'&&c<='9')now=now*10+c-'0',c=getchar();
	return now;
}
struct edge
{
	int v,nex;
}o[121];
void add(int u,int v)
{
	o[cnt++]=(edge){v,head[u]};head[u]=cnt-1;
	o[cnt++]=(edge){u,head[v]};head[v]=cnt-1;
}
int main()
{
	n=read(),m=read(),T=read(),s=read(),t=read();T--;
	for(int i=0;i<n;i++)head[i]=-1;
	for(int i=0,a,b;i<m;i++)
	{
		a=read();b=read();
		add(a,b);
	}
	for(int i=0;i<cnt;i++)for(int j=head[o[i].v];j>-1;j=o[j].nex)if((i^1)!=j)p.a[i][j]=1;
	for(int i=head[s];i>-1;i=o[i].nex)ans.a[0][i]=1;
	while(T)
	{
		if(T&1)ans=mul(ans,p);
		p=mul(p,p);
		T>>=1;
	}
	for(int i=head[t];i>-1;i=o[i].nex)sum=(sum+ans.a[0][i^1])%mod;
	printf("%d",sum);
	return 0;
}
```


---

## 作者：orecic (赞：1)

显然是矩阵快速幂。
设
$\ f_{t,i,j}$为$\ t$时刻到第$\ i$个点从第$\ j$条边的方案数。
当然需要矩阵快速幂。
不过直接造矩阵的话，矩阵可能过大，需要处理一下。
```cpp
#include<bits/stdc++.h>
using namespace std;
char buf[1<<20],*fs,*ft;
inline char getc()
{return (fs==ft&&(ft=(fs=buf)+fread(buf,1,1<<15,stdin),fs==ft))? 0 : *fs++;}
inline int read()
{int s=0,w=1;char ch=getchar();
while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
while(ch>='0'&&ch<='9'){s=s*10+ch-'0';ch=getchar();}
return s*w;}
char buf1[1<<21],a1[20];int p11,p12=-1;
inline void flush()
{fwrite (buf1,1,p12+1,stdout),p12=-1;}
inline void print(int x)
{if(p12>1<<20) flush();if(x<0) buf1[++p12]=45,x=-x;
do{a1[++p11]=x%10+48;}while(x/=10);
do{buf1[++p12]=a1[p11];}while(--p11);buf1[++p12]='\n';}
#define int long long
const int mod=45989;
int cnt=0,id[66][66],n,m,aa,bb,tt,ans=0,x[66],y[66];
struct ma
{
	int a[220][220];
	inline ma operator *(ma &b) const
	{
		ma c;
		int i=1,j=1,k=1;
		while(i<=cnt)
		{
			j=1;
			while(j<=cnt)
			{
				c.a[i][j]=0;
				++j;
			}
			++i;
		}
		i=1;
		while(i<=cnt)
		{
			j=1;
			while(j<=cnt)
			{
				k=1;
				while(k<=cnt)
				{
					c.a[i][j]+=a[i][k]*b.a[k][j]%mod;
					c.a[i][j]%=mod;
					++k;
				}
				++j;
			}
			++i;
		}
		return c;
	}
}tmp,res;
inline int xx(int i,int j)
{
	return id[i][j];
}
inline ma poww(ma a,int b)
{
	--b;
	ma tmp=a;
	while(b)
	{
		if(b&1) a=a*tmp;
		tmp=tmp*tmp;
		b>>=1;
	}
	return a;
}
signed main()
{
	n=read();
	m=read();
	tt=read();
	aa=read();
	bb=read();
	++aa;
	++bb;
	int i=1,j=1;
	i=1;
	while(i<=m)
	{
		int a,b;
		a=read();
		b=read();
		++a;
		++b;
		x[i]=a;
		y[i]=b;
		if(!id[a][i]) id[a][i]=++cnt;
		if(!id[b][i]) id[b][i]=++cnt;
		++i;
	}
	i=1;
	while(i<=m)
	{
		int a=x[i],b=y[i];
		if(a==aa) ++res.a[1][xx(b,i)];
		if(b==aa) ++res.a[1][xx(a,i)];
		j=1;
		while(j<=m)
		{
			if(j^i)
			{
				if(xx(b,j)) ++tmp.a[xx(b,j)][xx(a,i)];
				if(xx(a,j)) ++tmp.a[xx(a,j)][xx(b,i)];
			}
			++j;
		}
		++i;
	}
	if(tt==0)
	{
		if(aa==bb) printf("1\n");
		else printf("0\n");
		return 0;
	}
	--tt;
	if(tt==0)
	{
		i=1;
		while(i<=m)
		{
			if(xx(bb,i)) ans+=res.a[1][xx(bb,i)];
			ans%=mod;
			++i;
		}
		printf("%lld\n",ans);
		return 0;
	}
	tmp=poww(tmp,tt);
	res=res*tmp;
	i=1;
	while(i<=m)
	{
		if(xx(bb,i)) ans+=res.a[1][xx(bb,i)];
		ans%=mod;
		++i;
	}
	printf("%lld\n",ans);
    return 0;
}
```


---

## 作者：DrLin (赞：0)

# 题目
H有个一成不变的习惯，喜欢饭后百步走。所谓百步走，就是散步，就是在一定的时间 内，走过一定的距离。 但是同时HH又是个喜欢变化的人，所以他不会立刻沿着刚刚走来的路走回。 又因为HH是个喜欢变化的人，所以他每天走过的路径都不完全一样，他想知道他究竟有多 少种散步的方法。 现在给你学校的地图（假设每条路的长度都是一样的都是1），问长度为t，从给定地 点A走到给定地点B共有多少条符合条件的路径.

对于100%的数据，$N ≤ 20，M ≤ 60，t ≤ 2^30，0 ≤ A,B $

# 题解

既然n<=20，考虑开个邻接矩阵$table$存图

**先考虑暴力，设$dp[i][j]$表示还需走i段路,当前走到了j这个点**

易得$dp[i][j]=sum(dp[i+1][k]*table[j][k])+1$

然后无脑dfs即可
```cpp
#include <iostream>
#include <cstdio>
#include <vector>
using namespace std;
int table[21][21],dp[21][11],n,a,b;
void dfs(int id,int from,int t)
{
    //if(dp[id][from]) return;
    if(!t)
    {
        dp[id][t]+=(id==b);
        return;
    }
    for(int i=0;i<n;i++)
    {
        if(!table[id][i]||from==i) continue;
        dfs(i,id,t-1);
        dp[id][t]+=table[id][i]*dp[i][t-1];
        dp[id][t]%=45989;
    }
}
int main()
{
    int m,t;
    cin>>n>>m>>t>>a>>b;
    for(int i=1;i<=m;i++)
    {
        int a,b;
        scanf("%d%d",&a,&b);
        table[a][b]=++table[b][a];
    }
    dfs(a,0,t);
    cout<<dp[b][0];
 
}
```


发现i这一维可以滚动掉，然后我们发现这个方程的转移是固定不变
即，对于同一个j，都是同一批k来更新它。


那么，我们可以先处理一个另一个邻接矩阵$table2[k][i][j]$表示i在走了k步后到达j的方案书.

回忆floyd的过程，我们可以用类似的方法不断用$table2[k-1][i][j]$计算出新的$table2[k][i][j]$

```cpp
int temp[130][130];
void mulit(int arr1[][130],int arr2[][130],int size)
{
	memset(temp,0,sizeof(temp));
	for(int i=1;i<=size;i++)
	{
		for(int j=1;j<=cnt;j++)
		{
			for(int k=1;k<=cnt;k++)
			{
				temp[i][j]+=arr1[i][k]*arr2[k][j]%mod;
				temp[i][j]%=mod;
			}
		}
	}
	memcpy(arr1,temp,sizeof(temp));
}
void qpow(int t)
{
	for(int i=1;i<=cnt;i++) res[i][i]=1;
	while(t)
	{
		if(t&1) mulit(res,table2,cnt);
		mulit(table2,table2,cnt);
		t>>=1;
	}
}
```


然后发现其实这就是矩阵乘法，**于是这个过程可以用矩阵快速幂来加速**。

这其实是一个很常见的图论dp trick,当然，这个是要在点数小到可以用邻接矩阵时才能用的

然而题目要求我们不能立刻走回头路，处理起来比较麻烦

**所以我们把边当成点，把相连的边“连接”**

**另外，为了区分出边的方向，我们把每条边拆成两条（分别两个方向）**

然后按照上述的方法处理出$table2[t][i][j]$

最后枚举一遍从起点发出的边，统计这些边到达终点的方案数，输出即可

# 代码
```cpp
#include <iostream>
#include <cstring>
#include <cstdio>
using namespace std;
int table2[130][130],n,a,b,cnt,from[130],to[130],head[130],nxt[130];
int res[130][130];
#define connect(a,b) table2[a][b]=1
#define mod 45989
int temp[130][130];
void mulit(int arr1[][130],int arr2[][130],int size)
{
	memset(temp,0,sizeof(temp));
	for(int i=1;i<=size;i++)
	{
		for(int j=1;j<=cnt;j++)
		{
			for(int k=1;k<=cnt;k++)
			{
				temp[i][j]+=arr1[i][k]*arr2[k][j]%mod;
				temp[i][j]%=mod;
			}
		}
	}
	memcpy(arr1,temp,sizeof(temp));
}
void qpow(int t)
{
	for(int i=1;i<=cnt;i++) res[i][i]=1;
	while(t)
	{
		if(t&1) mulit(res,table2,cnt);
		mulit(table2,table2,cnt);
		t>>=1;
	}
}
void link(int x,int y)
{
	from[++cnt]=x,to[cnt]=y;
	nxt[cnt]=head[x];
	head[x]=cnt;
}
int main()
{
	int m,t;
	cin>>n>>m>>t>>a>>b;
	a++,b++;
	for(int i=1;i<=m;i++)
	{
		int x,y;
		scanf("%d%d",&x,&y);
		x++,y++;
		link(x,y);
		link(y,x);
	}
	for(int i=1;i<=cnt;i++)
	{
		for(int j=1;j<=cnt;j++)
		{
			if(((i&1)&&j==i+1)||((i&1)==0&&j==i-1)) continue;
			if(to[i]==from[j]) connect(i,j);
			//if(from[i]==to[j]) connect(j,i);
			
		}		
	}
	/*for(int i=1;i<=cnt;i++)
	{
		for(int j=1;j<=cnt;j++) cout<<table2[i][j]<<" ";
		cout<<endl;
	}*/
	qpow(t-1);
	int ans=0;
	for(int l=head[a];l;l=nxt[l]) 
		for(int i=1;i<=cnt;i++) 
			if(to[i]==b) ans+=res[l][i],ans%=mod;
	cout<<ans;
}
```


---

## 作者：Night_Aurora (赞：0)

如果T小一点点的话,我们可以轻易想到DP方程

DPN[p][b][t]代表走到p上一步在d走了t步的方案数

DPN[p][b][t]=sum(DPN[b][\*][t-1]) 其中$*\neq p$且存在边$b\rightarrow p$

对于边界我们要额外加一个虚点Ws,其中DPN[B][Ws][0]=1

我们发现t是一个天然的时间轴，DPN[\*][\*][t]都能从DPN[\*][\*][t-1]推导而来

所以可以把原式当成t次递推式，然后就可以想办法用矩阵乘法优化啦

根据递推式可以得到一个$N^2$长宽的矩阵，很明显不现实

我们发现边很少，所以可以把不存在边的二元组去掉，就等价于楼下把一个边切割成两个状态,分别表示刚刚经过这个边到起点或到终点的状态

以及还需要一个虚点$Ws\rightarrow B$的虚边，并把起始矩阵这个状态设为1

最后矩阵乘完统计答案时，对于每个到A的状态都会对答案有贡献

还有注意，如果A=B的话那个Ws到B的虚边也要加上

总复杂度是 $O((2M+1)^2*log_2T)$

完全没必要加读入优化，复杂度不算低 最后一个点卡常，矩乘函数加一个inline才勉强A掉

代码就不直接贴上，上[链接](http://pastebin.ubuntu.com/25387000/)吧


---


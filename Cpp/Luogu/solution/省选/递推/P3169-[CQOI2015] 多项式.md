# [CQOI2015] 多项式

## 题目描述

在学习完二项式定理后，数学老师给出了一道题目：已知整数 $n,t$ 和 $a_k$（$0\le k\le n$），求 $b_k$（$0\le k\le n$）的表达式使得:

$$
\sum_{k=0}^n a_kx^k=\sum_{k=0}^nb_k(x-t)^k
$$

同学们很快算出了答案。见大家这么快就搞定了，老师便布置了一个更 BT 的作业：计算某个 $b_k$ 的具体数值！接着便在黑板上写下了 $n,t$ 的数值，由于 $a_k$ 实在太多，不能全写在黑板上，老师只给出了一个 $a_k$ 的递推式，让学生自行计算:

$$
a_k=
\begin{cases}
(1234\cdot a_{k-1}+5678)\bmod 3389 & k\gt 0 \\
1 & k=0 \\
\end{cases}
$$

正在学习信息竞赛的你觉得这个作业实在不适合手工完成，便敲起了代码……


## 说明/提示

数据范围：

对于 $20\%$ 的数据，$t=0$。

对于另外 $30\%$ 的数据，$n\le 10^5$。

对于 $100\%$ 的数据，$0\lt n\le 10^{3000}$，$0\le t\le 10^4$，$0\le n-m\le 5$。


## 样例 #1

### 输入

```
3
2
2```

### 输出

```
10536```

# 题解

## 作者：waaadreamer (赞：18)

这道题应该上来就能看出来a肯定是个有循环节的玩意儿……结果我上来打了个表瞄了一眼，以为循环节长度就是3389（我真的太菜了），然后无限WA……后来才发现原来循环节长度是3388……Orz……

于是就可以开始推算式了，考虑展开：
$$\sum_{k=0}^nb_k(x-t)^k=\sum_{k=0}^nb_k\sum_{i=0}^k(-1)^{k-i}t^{k-i}x^i\binom ki$$
显然可以交换求和顺序，于是乎
$$=\sum_{i=0}^nx^i\sum_{k=i}^n\binom kib_k(-1)^{k-i}t^{k-i}$$
然后就得到了
$$a_i=\sum_{k=i}^nb_k(-1)^{k-i}t^{k-i}\binom ki$$
这是一个裸的二项式反演，于是就可以得到
$$b_k=\sum_{i=k}^n(-1)^{i-k}\binom ika_it^{i-k}$$
然后发现题目中的条件$n-m\le 5$，暴力高精度算一下就没了。
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

const int maxn = 1 << 15 | 5;
const double PI = acos(-1);
struct C{
	double x, y;
	C operator+(const C &c) const {return (C){x + c.x, y + c.y};}
	C operator-(const C &c) const {return (C){x - c.x, y - c.y};}
	C operator*(const C &c) const {return (C){x * c.x - y * c.y, x * c.y + y * c.x};}
} aa[maxn], tab[maxn];
void rader(C *a, int n){
	for(int i = 1, j = n >> 1; i < n - 1; i++){
		if(i < j) swap(a[i], a[j]);
		int k = n >> 1;
		for(; j >= k; k >>= 1) j -= k;
		if(j < k) j += k;
	}
}
void fft(C *a, int n){
	rader(a, n);
	for(int h = 2; h <= n; h <<= 1){
		int hh = h >> 1;
		for(int i = 0; i < n; i += h)
		for(int j = i; j < i + hh; j++){
			C x = a[j], y = a[j + hh] * tab[n / h * (j - i)];
			a[j] = x + y, a[j + hh] = x - y;
		}
	}
}
struct Bigint{
	int a[maxn], n;
	Bigint(){memset(a, 0, sizeof(a)); n = 0;}
	Bigint(char *str){
		memset(a, 0, sizeof(a));
		int l = strlen(str);
		n = 0;
		for(int i = l - 1; i >= 0; i -= 4, ++n){
			for(int j = max(i - 3, 0); j <= i; j++)
				a[n] = a[n] * 10 + str[j] - '0';
		}
	}
	Bigint operator*(const Bigint &b) const {
		Bigint res = Bigint();
		for(res.n = 1; res.n < n + b.n; res.n <<= 1);
		for(int i = 0; i < res.n; i++){
			aa[i] = (C){a[i], b.a[i]};
			tab[i] = (C){cos(2 * i * PI / res.n), sin(2 * i * PI / res.n)};
		}
		fft(aa, res.n);
		for(int i = 0; i < res.n; i++){
			aa[i] = aa[i] * aa[i];
			tab[i].y = -tab[i].y;
		}
		fft(aa, res.n);
		for(int i = 0; i < res.n; i++) aa[i].y /= 2 * res.n;
		for(int i = 0; i < res.n; i++){
			ll t = (ll)(aa[i].y + 0.5);
			res.a[i] = t % 10000;
			aa[i + 1].y += t / 10000;
		}
		if(aa[res.n].y > 0.5) res.a[res.n++] = (int)(aa[res.n].y + 0.5);
		while(res.n > 0 && !res.a[res.n - 1]) --res.n;
		return res;
	}
	Bigint operator+(const Bigint &b) const {
		Bigint res = Bigint();
		res.n = max(n, b.n);
		for(int i = 0; i < res.n; i++){
			res.a[i] += a[i] + b.a[i];
			if(res.a[i] >= 10000) ++res.a[i + 1], res.a[i] -= 10000;
		}
		if(res.a[res.n]) ++res.n;
		return res;
	}
	Bigint operator*(int b) const {
		Bigint res = Bigint();
		for(int i = 0; i < n; i++){
			ll t = (ll)a[i] * b + res.a[i];
			res.a[i] = t % 10000;
			res.a[i + 1] = t / 10000;
		}
		for(res.n = n; res.a[res.n]; ++res.n){
			res.a[res.n + 1] = res.a[res.n] / 10000;
			res.a[res.n] %= 10000;
		}
		return res;
	}
	Bigint operator/(int b) const {
		Bigint res = Bigint();
		res.n = n;
		for(int i = n - 1; i >= 0; i--){
			int t = res.a[i] + a[i];
			if(i > 0) res.a[i - 1] += t % b * 10000;
			res.a[i] = t / b;
		}
		while(res.n > 0 && !res.a[res.n - 1]) --res.n;
		return res;
	}
	int operator%(int b) const {
		int res = 0;
		for(int i = n - 1; i >= 0; i--)
			res = (res * 10000 + a[i]) % b;
		return res;
	}
	Bigint operator-(const Bigint &b) const {
		Bigint res = Bigint();
		for(int i = 0; i < n; i++){
			res.a[i] += a[i] - b.a[i];
			if(res.a[i] < 0) res.a[i] += 10000, --res.a[i + 1];
		}
		for(res.n = n; res.n > 0 && !res.a[res.n - 1]; --res.n);
		return res;
	}
	Bigint& operator++(){
		++a[0];
		for(int i = 0; i < n; i++){
			if(a[i] >= 10000) ++a[i + 1], a[i] -= 10000;
			else break;
		}
		if(a[n]) ++n;
		return *this;
	}
	void print(){
		printf("%d", a[n - 1]);
		for(int i = n - 2; i >= 0; i--) printf("%04d", a[i]);
		putchar('\n');
	}
	int cmp(const Bigint &b) const {
		if(n != b.n) return n < b.n ? -1 : 1;
		for(int i = n - 1; i >= 0; i--)
			if(a[i] != b.a[i]) return a[i] < b.a[i] ? -1 : 1;
		return 0;
	}
	bool operator>=(const Bigint &b) const {return cmp(b) >= 0;}
} n, m, mul, res;
char str[maxn];
int a[3500], vis[3500], K;
int main(){
	vis[a[0] = 1] = 1;
	for(int i = 1; i < 3388; i++)
		a[i] = (1234 * a[i - 1] + 5678) % 3389;
	scanf("%s", str);
	n = Bigint(str);
	scanf("%d", &K);
	scanf("%s", str);
	m = Bigint(str);
	int sub = (n - m).a[0], mod = m % 3388;
	mul.n = mul.a[0] = 1;
	for(int i = 0; i <= sub; i++){
		res = res + mul * a[mod];
		mul = mul * (++m) * K / (i + 1);
		mod = (mod + 1) % 3388;
	}
	res.print();
	return 0;
}
```

---

## 作者：劉子颺 (赞：17)

毒瘤题
考察的是高精度。
第一Ai的递推式很简单
矩阵乘法就行
那么发现n-m比较小
利用二项式定理就可以了
```
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <cstdlib>
#include <iostream>
#include <cassert>
#include <sstream>
#include <numeric>
#include <climits>
#include <string>
#include <cctype>
#include <ctime>
#include <iomanip>
#include <cmath>
#include <vector>
#include <queue>
#include <list>
#include <map>
#include <set>
using namespace std;
// -*- C++ -*- forwarding header.

// Copyright (C) 1997-2014 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file include/cstdio
 *  This is a Standard C++ Library file.  You should @c \#include this file
 *  in your programs, rather than any of the @a *.h implementation files.
 *
 *  This is the C++ version of the Standard C Library header @c stdio.h,
 *  and its contents are (mostly) the same as that header, but are all
 *  contained in the namespace @c std (except for names which are defined
 *  as macros in C).
 */

//
// ISO C++ 14882: 27.8.2  C Library files
//

#pragma GCC system_header

#include <bits/c++config.h>
#include <stdio.h>

#ifndef _GLIBCXX_CSTDIO
#define _GLIBCXX_CSTDIO 1

#ifndef _GLIBCXX_HAVE_GETS
extern "C" char* gets (char* __s) __attribute__((deprecated));
#endif

// Get rid of those macros defined in <stdio.h> in lieu of real functions.
#undef clearerr
#undef fclose
#undef feof
#undef ferror
#undef fflush
#undef fgetc
#undef fgetpos
#undef fgets
#undef fopen
#undef fprintf
#undef fputc
#undef fputs
#undef fread
#undef freopen
#undef fscanf
#undef fseek
#undef fsetpos
#undef ftell
#undef fwrite
#undef getc
#undef getchar
#if __cplusplus <= 201103L
# undef gets
#endif
#undef perror
#undef printf
#undef putc
#undef putchar
#undef puts
#undef remove
#undef rename
#undef rewind
#undef scanf
#undef setbuf
#undef setvbuf
#undef sprintf
#undef sscanf
#undef tmpfile
#undef tmpnam
#undef ungetc
#undef vfprintf
#undef vprintf
#undef vsprintf

namespace std
{
  using ::FILE;
  using ::fpos_t;

  using ::clearerr;
  using ::fclose;
  using ::feof;
  using ::ferror;
  using ::fflush;
  using ::fgetc;
  using ::fgetpos;
  using ::fgets;
  using ::fopen;
  using ::fprintf;
  using ::fputc;
  using ::fputs;
  using ::fread;
  using ::freopen;
  using ::fscanf;
  using ::fseek;
  using ::fsetpos;
  using ::ftell;
  using ::fwrite;
  using ::getc;
  using ::getchar;
#if __cplusplus <= 201103L
  // LWG 2249
  using ::gets;
#endif
  using ::perror;
  using ::printf;
  using ::putc;
  using ::putchar;
  using ::puts;
  using ::remove;
  using ::rename;
  using ::rewind;
  using ::scanf;
  using ::setbuf;
  using ::setvbuf;
  using ::sprintf;
  using ::sscanf;
  using ::tmpfile;
#if _GLIBCXX_USE_TMPNAM
  using ::tmpnam;
#endif
  using ::ungetc;
  using ::vfprintf;
  using ::vprintf;
  using ::vsprintf;
} // namespace

#if _GLIBCXX_USE_C99

#undef snprintf
#undef vfscanf
#undef vscanf
#undef vsnprintf
#undef vsscanf

namespace __gnu_cxx
{
#if _GLIBCXX_USE_C99_CHECK || _GLIBCXX_USE_C99_DYNAMIC
  extern "C" int
  (snprintf)(char * __restrict, std::size_t, const char * __restrict, ...)
  throw ();
  extern "C" int
  (vfscanf)(FILE * __restrict, const char * __restrict, __gnuc_va_list);
  extern "C" int (vscanf)(const char * __restrict, __gnuc_va_list);
  extern "C" int
  (vsnprintf)(char * __restrict, std::size_t, const char * __restrict,
          __gnuc_va_list) throw ();
  extern "C" int
  (vsscanf)(const char * __restrict, const char * __restrict, __gnuc_va_list)
  throw ();
#endif

#if !_GLIBCXX_USE_C99_DYNAMIC
  using ::snprintf;
  using ::vfscanf;
  using ::vscanf;
  using ::vsnprintf;
  using ::vsscanf;
#endif
} // namespace __gnu_cxx

namespace std
{
  using ::__gnu_cxx::snprintf;
  using ::__gnu_cxx::vfscanf;
  using ::__gnu_cxx::vscanf;
  using ::__gnu_cxx::vsnprintf;
  using ::__gnu_cxx::vsscanf;
} // namespace std

#endif // _GLIBCXX_USE_C99

#endif
namespace fastIO{
    #define BUF_SIZE 100000
    #define OUT_SIZE 100000
    #define ll long long
    //fread->read
    bool IOerror=0;
    inline char nc(){
        static char buf[BUF_SIZE],*p1=buf+BUF_SIZE,*pend=buf+BUF_SIZE;
        if (p1==pend){
            p1=buf; pend=buf+fread(buf,1,BUF_SIZE,stdin);
            if (pend==p1){IOerror=1;return -1;}
            //{printf("IO error!\n");system("pause");for (;;);exit(0);}
        }
        return *p1++;
    }
    inline bool blank(char ch){return ch==' '||ch=='\n'||ch=='\r'||ch=='\t';}
    inline void read(int &x){
        bool sign=0; char ch=nc(); x=0;
        for (;blank(ch);ch=nc());
        if (IOerror)return;
        if (ch=='-')sign=1,ch=nc();
        for (;ch>='0'&&ch<='9';ch=nc())x=x*10+ch-'0';
        if (sign)x=-x;
    }
    inline void read(ll &x){
        bool sign=0; char ch=nc(); x=0;
        for (;blank(ch);ch=nc());
        if (IOerror)return;
        if (ch=='-')sign=1,ch=nc();
        for (;ch>='0'&&ch<='9';ch=nc())x=x*10+ch-'0';
        if (sign)x=-x;
    }
    inline void read(double &x){
        bool sign=0; char ch=nc(); x=0;
        for (;blank(ch);ch=nc());
        if (IOerror)return;
        if (ch=='-')sign=1,ch=nc();
        for (;ch>='0'&&ch<='9';ch=nc())x=x*10+ch-'0';
        if (ch=='.'){
            double tmp=1; ch=nc();
            for (;ch>='0'&&ch<='9';ch=nc())tmp/=10.0,x+=tmp*(ch-'0');
        }
        if (sign)x=-x;
    }
    inline void read(char *s){
        char ch=nc();
        for (;blank(ch);ch=nc());
        if (IOerror)return;
        for (;!blank(ch)&&!IOerror;ch=nc())*s++=ch;
        *s=0;
    }
    inline void read(char &c){
        for (c=nc();blank(c);c=nc());
        if (IOerror){c=-1;return;}
    }
    //getchar->read
    inline void read1(int &x){
        char ch;int bo=0;x=0;
        for (ch=getchar();ch<'0'||ch>'9';ch=getchar())if (ch=='-')bo=1;
        for (;ch>='0'&&ch<='9';x=x*10+ch-'0',ch=getchar());
        if (bo)x=-x;
    }
    inline void read1(ll &x){
        char ch;int bo=0;x=0;
        for (ch=getchar();ch<'0'||ch>'9';ch=getchar())if (ch=='-')bo=1;
        for (;ch>='0'&&ch<='9';x=x*10+ch-'0',ch=getchar());
        if (bo)x=-x;
    }
    inline void read1(double &x){
        char ch;int bo=0;x=0;
        for (ch=getchar();ch<'0'||ch>'9';ch=getchar())if (ch=='-')bo=1;
        for (;ch>='0'&&ch<='9';x=x*10+ch-'0',ch=getchar());
        if (ch=='.'){
            double tmp=1;
            for (ch=getchar();ch>='0'&&ch<='9';tmp/=10.0,x+=tmp*(ch-'0'),ch=getchar());
        }
        if (bo)x=-x;
    }
    inline void read1(char *s){
        char ch=getchar();
        for (;blank(ch);ch=getchar());
        for (;!blank(ch);ch=getchar())*s++=ch;
        *s=0;
    }
    inline void read1(char &c){for (c=getchar();blank(c);c=getchar());}
    //scanf->read
    inline void read2(int &x){scanf("%d",&x);}
    inline void read2(ll &x){
        #ifdef _WIN32
            scanf("%I64d",&x);
        #else
        #ifdef __linux
            scanf("%lld",&x);
        #else
            puts("error:can't recognize the system!");
        #endif
        #endif
    }
    inline void read2(double &x){scanf("%lf",&x);}
    inline void read2(char *s){scanf("%s",s);}
    inline void read2(char &c){scanf(" %c",&c);}
    inline void readln2(char *s){gets(s);}
    //fwrite->write
    struct Ostream_fwrite{
        char *buf,*p1,*pend;
        Ostream_fwrite(){buf=new char[BUF_SIZE];p1=buf;pend=buf+BUF_SIZE;}
        void out(char ch){
            if (p1==pend){
                fwrite(buf,1,BUF_SIZE,stdout);p1=buf;
            }
            *p1++=ch;
        }
        void print(int x){
            static char s[15],*s1;s1=s;
            if (!x)*s1++='0';if (x<0)out('-'),x=-x;
            while(x)*s1++=x%10+'0',x/=10;
            while(s1--!=s)out(*s1);
            out(' ');
        }
        void println(int x){
            static char s[15],*s1;s1=s;
            if (!x)*s1++='0';if (x<0)out('-'),x=-x;
            while(x)*s1++=x%10+'0',x/=10;
            while(s1--!=s)out(*s1); out('\n');
        }
        void print(ll x){
            static char s[25],*s1;s1=s;
            if (!x)*s1++='0';if (x<0)out('-'),x=-x;
            while(x)*s1++=x%10+'0',x/=10;
            while(s1--!=s)out(*s1);
        }
        void println(ll x){
            static char s[25],*s1;s1=s;
            if (!x)*s1++='0';if (x<0)out('-'),x=-x;
            while(x)*s1++=x%10+'0',x/=10;
            while(s1--!=s)out(*s1); out('\n');
        }
        void print(double x,int y){
            static ll mul[]={1,10,100,1000,10000,100000,1000000,10000000,100000000,
                1000000000,10000000000LL,100000000000LL,1000000000000LL,10000000000000LL,
                100000000000000LL,1000000000000000LL,10000000000000000LL,100000000000000000LL};
            if (x<-1e-12)out('-'),x=-x;x*=mul[y];
            ll x1=(ll)floor(x); if (x-floor(x)>=0.5)++x1;
            ll x2=x1/mul[y],x3=x1-x2*mul[y]; print(x2);
            if (y>0){out('.'); for (size_t i=1;i<y&&x3*mul[i]<mul[y];out('0'),++i); print(x3);}
        }
        void println(double x,int y){print(x,y);out('\n');}
        void print(char *s){while (*s)out(*s++);}
        void println(char *s){while (*s)out(*s++);out('\n');}
        void flush(){if (p1!=buf){fwrite(buf,1,p1-buf,stdout);p1=buf;}}
        ~Ostream_fwrite(){flush();}
    }Ostream;
    inline void print(int x){Ostream.print(x);}
    inline void println(int x){Ostream.println(x);}
    inline void print(char x){Ostream.out(x);}
    inline void println(char x){Ostream.out(x);Ostream.out('\n');}
    inline void print(ll x){Ostream.print(x);}
    inline void println(ll x){Ostream.println(x);}
    inline void print(double x,int y){Ostream.print(x,y);}
    inline void println(double x,int y){Ostream.println(x,y);}
    inline void print(char *s){Ostream.print(s);}
    inline void println(char *s){Ostream.println(s);}
    inline void println(){Ostream.out('\n');}
    inline void flush(){Ostream.flush();}
    //puts->write
    char Out[OUT_SIZE],*o=Out;
    inline void print1(int x){
        static char buf[15];
        char *p1=buf;if (!x)*p1++='0';if (x<0)*o++='-',x=-x;
        while(x)*p1++=x%10+'0',x/=10;
        while(p1--!=buf)*o++=*p1;
    }
    inline void println1(int x){print1(x);*o++='\n';}
    inline void print1(ll x){
        static char buf[25];
        char *p1=buf;if (!x)*p1++='0';if (x<0)*o++='-',x=-x;
        while(x)*p1++=x%10+'0',x/=10;
        while(p1--!=buf)*o++=*p1;
    }
    inline void println1(ll x){print1(x);*o++='\n';}
    inline void print1(char c){*o++=c;}
    inline void println1(char c){*o++=c;*o++='\n';}
    inline void print1(char *s){while (*s)*o++=*s++;}
    inline void println1(char *s){print1(s);*o++='\n';}
    inline void println1(){*o++='\n';}
    inline void flush1(){if (o!=Out){if (*(o-1)=='\n')*--o=0;puts(Out);}}
    struct puts_write{
        ~puts_write(){flush1();}
    }_puts;
    inline void print2(int x){printf("%d",x);}
    inline void println2(int x){printf("%d\n",x);}
    inline void print2(char x){printf("%c",x);}
    inline void println2(char x){printf("%c\n",x);}
    inline void print2(ll x){
        #ifdef _WIN32
            printf("%I64d",x);
        #else
        #ifdef __linux
            printf("%lld",x);
        #else
            puts("error:can't recognize the system!");
        #endif
        #endif
    }
    inline void println2(ll x){print2(x);printf("\n");}
    inline void println2(){printf("\n");}
    #undef ll
    #undef OUT_SIZE
    #undef BUF_SIZE
};
#define LL long long
#define DIGIT   4      //四位隔开,即万进制  
#define DEPTH   10000        //万进制  
#define MAX     10000  
typedef int bignum_t[MAX+1];  
  
/************************************************************************/  
/* 读取操作数，对操作数进行处理存储在数组里                             */  
/************************************************************************/  
int read(bignum_t a,istream&is=cin)  
{  
    char buf[MAX*DIGIT+1],ch ;  
    int i,j ;  
    memset((void*)a,0,sizeof(bignum_t));  
    if(!(is>>buf))return 0 ;  
    for(a[0]=strlen(buf),i=a[0]/2-1;i>=0;i--)  
    ch=buf[i],buf[i]=buf[a[0]-1-i],buf[a[0]-1-i]=ch ;  
    for(a[0]=(a[0]+DIGIT-1)/DIGIT,j=strlen(buf);j<a[0]*DIGIT;buf[j++]='0');  
    for(i=1;i<=a[0];i++)  
    for(a[i]=0,j=0;j<DIGIT;j++)  
    a[i]=a[i]*10+buf[i*DIGIT-1-j]-'0' ;  
    for(;!a[a[0]]&&a[0]>1;a[0]--);  
    return 1 ;  
}  
  
void write(const bignum_t a,ostream&os=cout)  
{  
    int i,j ;  
    for(os<<a[i=a[0]],i--;i;i--)  
    for(j=DEPTH/10;j;j/=10)  
    os<<a[i]/j%10 ;  
}  
  
int comp(const bignum_t a,const bignum_t b)  
{  
    int i ;  
    if(a[0]!=b[0])  
    return a[0]-b[0];  
    for(i=a[0];i;i--)  
    if(a[i]!=b[i])  
    return a[i]-b[i];  
    return 0 ;  
}  
  
int comp(const bignum_t a,const int b)  
{  
    int c[12]={1};  
    for(c[1]=b;c[c[0]]>=DEPTH;c[c[0]+1]=c[c[0]]/DEPTH,c[c[0]]%=DEPTH,c[0]++);  
    return comp(a,c);  
}  
  
int comp(const bignum_t a,const int c,const int d,const bignum_t b)  
{  
    int i,t=0,O=-DEPTH*2 ;  
    if(b[0]-a[0]<d&&c)  
    return 1 ;  
    for(i=b[0];i>d;i--)  
    {  
        t=t*DEPTH+a[i-d]*c-b[i];  
        if(t>0)return 1 ;  
        if(t<O)return 0 ;  
    }  
    for(i=d;i;i--)  
    {  
        t=t*DEPTH-b[i];  
        if(t>0)return 1 ;  
        if(t<O)return 0 ;  
    }  
    return t>0 ;  
}  
/************************************************************************/  
/* 大数与大数相加                                                       */  
/************************************************************************/  

void add(bignum_t a,const bignum_t b)  
{  
    int i ;  
    for(i=1;i<=b[0];i++)  
    if((a[i]+=b[i])>=DEPTH)  
    a[i]-=DEPTH,a[i+1]++;  
    if(b[0]>=a[0])  
    a[0]=b[0];  
    else  
    for(;a[i]>=DEPTH&&i<a[0];a[i]-=DEPTH,i++,a[i]++);  
    a[0]+=(a[a[0]+1]>0);  
}  
/************************************************************************/  
/* 大数与小数相加                                                       */  
/************************************************************************/  

void add(bignum_t a,const int b)  
{  
    int i=1 ;  
    for(a[1]+=b;a[i]>=DEPTH&&i<a[0];a[i+1]+=a[i]/DEPTH,a[i]%=DEPTH,i++);  
    for(;a[a[0]]>=DEPTH;a[a[0]+1]=a[a[0]]/DEPTH,a[a[0]]%=DEPTH,a[0]++);  
}  

/************************************************************************/  
/* 大数相减(被减数>=减数)                                               */  
/************************************************************************/  

void sub(bignum_t a,const bignum_t b)  
{  
    int i ;  
    for(i=1;i<=b[0];i++)  
    if((a[i]-=b[i])<0)  
    a[i+1]--,a[i]+=DEPTH ;  
    for(;a[i]<0;a[i]+=DEPTH,i++,a[i]--);  
    for(;!a[a[0]]&&a[0]>1;a[0]--);  
}  

/************************************************************************/  
/* 大数减去小数(被减数>=减数)                                           */  
/************************************************************************/  

void sub(bignum_t a,const int b)  
{  
    int i=1 ;  
    for(a[1]-=b;a[i]<0;a[i+1]+=(a[i]-DEPTH+1)/DEPTH,a[i]-=(a[i]-DEPTH+1)/DEPTH*DEPTH,i++);  
    for(;!a[a[0]]&&a[0]>1;a[0]--);  
}  
  
void sub(bignum_t a,const bignum_t b,const int c,const int d)  
{  
    int i,O=b[0]+d ;  
    for(i=1+d;i<=O;i++)  
    if((a[i]-=b[i-d]*c)<0)  
    a[i+1]+=(a[i]-DEPTH+1)/DEPTH,a[i]-=(a[i]-DEPTH+1)/DEPTH*DEPTH ;  
    for(;a[i]<0;a[i+1]+=(a[i]-DEPTH+1)/DEPTH,a[i]-=(a[i]-DEPTH+1)/DEPTH*DEPTH,i++);  
    for(;!a[a[0]]&&a[0]>1;a[0]--);  
}  

/************************************************************************/  
/* 大数相乘，读入被乘数a，乘数b，结果保存在c[]                          */  
/************************************************************************/  

void mul(bignum_t c,const bignum_t a,const bignum_t b)  
{  
    int i,j ;  
    memset((void*)c,0,sizeof(bignum_t));  
    for(c[0]=a[0]+b[0]-1,i=1;i<=a[0];i++)  
    for(j=1;j<=b[0];j++)  
    if((c[i+j-1]+=a[i]*b[j])>=DEPTH)  
    c[i+j]+=c[i+j-1]/DEPTH,c[i+j-1]%=DEPTH ;  
    for(c[0]+=(c[c[0]+1]>0);!c[c[0]]&&c[0]>1;c[0]--);  
}  

/************************************************************************/  
/* 大数乘以小数，读入被乘数a，乘数b，结果保存在被乘数                   */  
/************************************************************************/  

void mul(bignum_t a,const int b)  
{  
    int i ;  
    for(a[1]*=b,i=2;i<=a[0];i++)  
    {  
        a[i]*=b ;  
        if(a[i-1]>=DEPTH)  
        a[i]+=a[i-1]/DEPTH,a[i-1]%=DEPTH ;  
    }  
    for(;a[a[0]]>=DEPTH;a[a[0]+1]=a[a[0]]/DEPTH,a[a[0]]%=DEPTH,a[0]++);  
    for(;!a[a[0]]&&a[0]>1;a[0]--);  
}  
  
void mul(bignum_t b,const bignum_t a,const int c,const int d)  
{  
    int i ;  
    memset((void*)b,0,sizeof(bignum_t));  
    for(b[0]=a[0]+d,i=d+1;i<=b[0];i++)  
    if((b[i]+=a[i-d]*c)>=DEPTH)  
    b[i+1]+=b[i]/DEPTH,b[i]%=DEPTH ;  
    for(;b[b[0]+1];b[0]++,b[b[0]+1]=b[b[0]]/DEPTH,b[b[0]]%=DEPTH);  
    for(;!b[b[0]]&&b[0]>1;b[0]--);  
}  

/**************************************************************************/  
/* 大数相除,读入被除数a，除数b，结果保存在c[]数组                         */  
/* 需要comp()函数                                                         */  
/**************************************************************************/  

void div(bignum_t c,bignum_t a,const bignum_t b)  
{  
    int h,l,m,i ;  
    memset((void*)c,0,sizeof(bignum_t));  
    c[0]=(b[0]<a[0]+1)?(a[0]-b[0]+2):1 ;  
    for(i=c[0];i;sub(a,b,c[i]=m,i-1),i--)  
    for(h=DEPTH-1,l=0,m=(h+l+1)>>1;h>l;m=(h+l+1)>>1)  
    if(comp(b,m,i-1,a))h=m-1 ;  
    else l=m ;  
    for(;!c[c[0]]&&c[0]>1;c[0]--);  
    c[0]=c[0]>1?c[0]:1 ;  
}  
  
void div(bignum_t a,const int b,int&c)  
{  
    int i ;  
    for(c=0,i=a[0];i;c=c*DEPTH+a[i],a[i]=c/b,c%=b,i--);  
    for(;!a[a[0]]&&a[0]>1;a[0]--);  
}  

/************************************************************************/  
/* 大数平方根，读入大数a，结果保存在b[]数组里                           */  
/* 需要comp()函数                                                       */  
/************************************************************************/  

void sqrt(bignum_t b,bignum_t a)  
{  
    int h,l,m,i ;  
    memset((void*)b,0,sizeof(bignum_t));  
    for(i=b[0]=(a[0]+1)>>1;i;sub(a,b,m,i-1),b[i]+=m,i--)  
    for(h=DEPTH-1,l=0,b[i]=m=(h+l+1)>>1;h>l;b[i]=m=(h+l+1)>>1)  
    if(comp(b,m,i-1,a))h=m-1 ;  
    else l=m ;  
    for(;!b[b[0]]&&b[0]>1;b[0]--);  
    for(i=1;i<=b[0];b[i++]>>=1);  
}  

/************************************************************************/  
/* 返回大数的长度                                                       */  
/************************************************************************/  

int length(const bignum_t a)  
{  
    int t,ret ;  
    for(ret=(a[0]-1)*DIGIT,t=a[a[0]];t;t/=10,ret++);  
    return ret>0?ret:1 ;  
}  

/************************************************************************/  
/* 返回指定位置的数字，从低位开始数到第b位，返回b位上的数               */  
/************************************************************************/  

int digit(const bignum_t a,const int b)  
{  
    int i,ret ;  
    for(ret=a[(b-1)/DIGIT+1],i=(b-1)%DIGIT;i;ret/=10,i--);  
    return ret%10 ;  
}  

/************************************************************************/  
/* 返回大数末尾0的个数                                                  */  
/************************************************************************/  

int zeronum(const bignum_t a)  
{  
    int ret,t ;  
    for(ret=0;!a[ret+1];ret++);  
    for(t=a[ret+1],ret*=DIGIT;!(t%10);t/=10,ret++);  
    return ret ;  
}  
  
void comp(int*a,const int l,const int h,const int d)  
{  
    int i,j,t ;  
    for(i=l;i<=h;i++)  
    for(t=i,j=2;t>1;j++)  
    while(!(t%j))  
    a[j]+=d,t/=j ;  
}  
  
void convert(int*a,const int h,bignum_t b)  
{  
    int i,j,t=1 ;  
    memset(b,0,sizeof(bignum_t));  
    for(b[0]=b[1]=1,i=2;i<=h;i++)  
    if(a[i])  
    for(j=a[i];j;t*=i,j--)  
    if(t*i>DEPTH)  
    mul(b,t),t=1 ;  
    mul(b,t);  
}  
  
#define SGN(x) ((x)>0?1:((x)<0?-1:0))  
#define ABS(x) ((x)>0?(x):-(x))  
  
int read(bignum_t a,int&sgn,istream&is=cin)  
{  
    char str[MAX*DIGIT+2],ch,*buf ;  
    int i,j ;  
    memset((void*)a,0,sizeof(bignum_t));  
    if(!(is>>str))return 0 ;  
    buf=str,sgn=1 ;  
    if(*buf=='-')sgn=-1,buf++;  
    for(a[0]=strlen(buf),i=a[0]/2-1;i>=0;i--)  
    ch=buf[i],buf[i]=buf[a[0]-1-i],buf[a[0]-1-i]=ch ;  
    for(a[0]=(a[0]+DIGIT-1)/DIGIT,j=strlen(buf);j<a[0]*DIGIT;buf[j++]='0');  
    for(i=1;i<=a[0];i++)  
    for(a[i]=0,j=0;j<DIGIT;j++)  
    a[i]=a[i]*10+buf[i*DIGIT-1-j]-'0' ;  
    for(;!a[a[0]]&&a[0]>1;a[0]--);  
    if(a[0]==1&&!a[1])sgn=0 ;  
    return 1 ;  
}  
struct bignum  
{  
    bignum_t num ;  
    int sgn ;  
    public :  
    inline bignum()  
    {  
        memset(num,0,sizeof(bignum_t));  
        num[0]=1 ;  
        sgn=0 ;  
    }  
    inline int operator!()  
    {  
        return num[0]==1&&!num[1];  
    }  
    inline bignum&operator=(const bignum&a)  
    {  
        memcpy(num,a.num,sizeof(bignum_t));  
        sgn=a.sgn ;  
        return*this ;  
    }  
    inline bignum&operator=(const int a)  
    {  
        memset(num,0,sizeof(bignum_t));  
        num[0]=1 ;  
        sgn=SGN (a);  
        add(num,sgn*a);  
        return*this ;  
    }  
    ;  
    inline bignum&operator+=(const bignum&a)  
    {  
        if(sgn==a.sgn)add(num,a.num);  
        else if  
        (sgn&&a.sgn)  
        {  
            int ret=comp(num,a.num);  
            if(ret>0)sub(num,a.num);  
            else if(ret<0)  
            {  
                bignum_t t ;  
                memcpy(t,num,sizeof(bignum_t));  
                memcpy(num,a.num,sizeof(bignum_t));  
                sub (num,t);  
                sgn=a.sgn ;  
            }  
            else memset(num,0,sizeof(bignum_t)),num[0]=1,sgn=0 ;  
        }  
        else if(!sgn)  
            memcpy(num,a.num,sizeof(bignum_t)),sgn=a.sgn ;  
        return*this ;  
    }  
    inline bignum&operator+=(const int a)  
    {  
        if(sgn*a>0)add(num,ABS(a));  
        else if(sgn&&a)  
        {  
            int  ret=comp(num,ABS(a));  
            if(ret>0)sub(num,ABS(a));  
            else if(ret<0)  
            {  
                bignum_t t ;  
                memcpy(t,num,sizeof(bignum_t));  
                memset(num,0,sizeof(bignum_t));  
                num[0]=1 ;  
                add(num,ABS (a));  
                sgn=-sgn ;  
                sub(num,t);  
            }  
            else memset(num,0,sizeof(bignum_t)),num[0]=1,sgn=0 ;  
        }  
        else if  
            (!sgn)sgn=SGN(a),add(num,ABS(a));  
        return*this ;  
    }  
    inline bignum operator+(const bignum&a)  
    {  
        bignum ret ;  
        memcpy(ret.num,num,sizeof (bignum_t));  
        ret.sgn=sgn ;  
        ret+=a ;  
        return ret ;  
    }  
    inline bignum operator+(const int a)  
    {  
        bignum ret ;  
        memcpy(ret.num,num,sizeof (bignum_t));  
        ret.sgn=sgn ;  
        ret+=a ;  
        return ret ;  
    }  
    inline bignum&operator-=(const bignum&a)  
    {  
        if(sgn*a.sgn<0)add(num,a.num);  
        else if  
        (sgn&&a.sgn)  
        {  
            int ret=comp(num,a.num);  
            if(ret>0)sub(num,a.num);  
            else if(ret<0)  
            {  
                bignum_t t ;  
                memcpy(t,num,sizeof(bignum_t));  
                memcpy(num,a.num,sizeof(bignum_t));  
                sub(num,t);  
                sgn=-sgn ;  
            }  
            else memset(num,0,sizeof(bignum_t)),num[0]=1,sgn=0 ;  
        }  
        else if(!sgn)add (num,a.num),sgn=-a.sgn ;  
        return*this ;  
    }  
    inline bignum&operator-=(const int a)  
    {  
        if(sgn*a<0)add(num,ABS(a));  
        else if(sgn&&a)  
        {  
            int  ret=comp(num,ABS(a));  
            if(ret>0)sub(num,ABS(a));  
            else if(ret<0)  
            {  
                bignum_t t ;  
                memcpy(t,num,sizeof(bignum_t));  
                memset(num,0,sizeof(bignum_t));  
                num[0]=1 ;  
                add(num,ABS(a));  
                sub(num,t);  
                sgn=-sgn ;  
            }  
            else memset(num,0,sizeof(bignum_t)),num[0]=1,sgn=0 ;  
        }  
        else if  
            (!sgn)sgn=-SGN(a),add(num,ABS(a));  
        return*this ;  
    }  
    inline bignum operator-(const bignum&a)  
    {  
        bignum ret ;  
        memcpy(ret.num,num,sizeof(bignum_t));  
        ret.sgn=sgn ;  
        ret-=a ;  
        return ret ;  
    }  
    inline bignum operator-(const int a)  
    {  
        bignum ret ;  
        memcpy(ret.num,num,sizeof(bignum_t));  
        ret.sgn=sgn ;  
        ret-=a ;  
        return ret ;  
    }  
    inline bignum&operator*=(const bignum&a)  
    {  
        bignum_t t ;  
        mul(t,num,a.num);  
        memcpy(num,t,sizeof(bignum_t));  
        sgn*=a.sgn ;  
        return*this ;  
    }  
    inline bignum&operator*=(const int a)  
    {  
        mul(num,ABS(a));  
        sgn*=SGN(a);  
        return*this ;  
    }  
    inline bignum operator*(const bignum&a)  
    {  
        bignum ret ;  
        mul(ret.num,num,a.num);  
        ret.sgn=sgn*a.sgn ;  
        return ret ;  
    }  
    inline bignum operator*(const int a)  
    {  
        bignum ret ;  
        memcpy(ret.num,num,sizeof (bignum_t));  
        mul(ret.num,ABS(a));  
        ret.sgn=sgn*SGN(a);  
        return ret ;  
    }  
    inline bignum&operator/=(const bignum&a)  
    {  
        bignum_t t ;  
        div(t,num,a.num);  
        memcpy (num,t,sizeof(bignum_t));  
        sgn=(num[0]==1&&!num[1])?0:sgn*a.sgn ;  
        return*this ;  
    }  
    inline bignum&operator/=(const int a)  
    {  
        int t ;  
        div(num,ABS(a),t);  
        sgn=(num[0]==1&&!num [1])?0:sgn*SGN(a);  
        return*this ;  
    }  
    inline bignum operator/(const bignum&a)  
    {  
        bignum ret ;  
        bignum_t t ;  
        memcpy(t,num,sizeof(bignum_t));  
        div(ret.num,t,a.num);  
        ret.sgn=(ret.num[0]==1&&!ret.num[1])?0:sgn*a.sgn ;  
        return ret ;  
    }  
    inline bignum operator/(const int a)  
    {  
        bignum ret ;  
        int t ;  
        memcpy(ret.num,num,sizeof(bignum_t));  
        div(ret.num,ABS(a),t);  
        ret.sgn=(ret.num[0]==1&&!ret.num[1])?0:sgn*SGN(a);  
        return ret ;  
    }  
    inline bignum&operator%=(const bignum&a)  
    {  
        bignum_t t ;  
        div(t,num,a.num);  
        if(num[0]==1&&!num[1])sgn=0 ;  
        return*this ;  
    }  
    inline int operator%=(const int a)  
    {  
        int t ;  
        div(num,ABS(a),t);  
        memset(num,0,sizeof (bignum_t));  
        num[0]=1 ;  
        add(num,t);  
        return t ;  
    }  
    inline bignum operator%(const bignum&a)  
    {  
        bignum ret ;  
        bignum_t t ;  
        memcpy(ret.num,num,sizeof(bignum_t));  
        div(t,ret.num,a.num);  
        ret.sgn=(ret.num[0]==1&&!ret.num [1])?0:sgn ;  
        return ret ;  
    }  
    inline int operator%(const int a)  
    {  
        bignum ret ;  
        int t ;  
        memcpy(ret.num,num,sizeof(bignum_t));  
        div(ret.num,ABS(a),t);  
        memset(ret.num,0,sizeof(bignum_t));  
        ret.num[0]=1 ;  
        add(ret.num,t);  
        return t ;  
    }  
    inline bignum&operator++()  
    {  
        *this+=1 ;  
        return*this ;  
    }  
    inline bignum&operator--()  
    {  
        *this-=1 ;  
        return*this ;  
    }  
    ;  
    
    inline int operator>(const bignum&a)  
    {  
        return sgn>0?(a.sgn>0?comp(num,a.num)>0:1):(sgn<0?(a.sgn<0?comp(num,a.num)<0:0):a.sgn<0);  
    }  
    ;
    
    inline int operator>(const int a)  
    {  
        return sgn>0?(a>0?comp(num,a)>0:1):(sgn<0?(a<0?comp(num,-a)<0:0):a<0);  
    }  
    ;
    
    inline int operator>=(const bignum&a)  
    {  
        return sgn>0?(a.sgn>0?comp(num,a.num)>=0:1):(sgn<0?(a.sgn<0?comp(num,a.num)<=0:0):a.sgn<=0);  
    }  
    ;
    
    inline int operator>=(const int a)  
    {  
        return sgn>0?(a>0?comp(num,a)>=0:1):(sgn<0?(a<0?comp(num,-a)<=0:0):a<=0);  
    }  
    ;
    
    inline int operator<(const bignum&a)  
    {  
        return sgn<0?(a.sgn<0?comp(num,a.num)>0:1):(sgn>0?(a.sgn>0?comp(num,a.num)<0:0):a.sgn>0);  
    }  
    ;
    
    inline int operator<(const int a)  
    {  
        return sgn<0?(a<0?comp(num,-a)>0:1):(sgn>0?(a>0?comp(num,a)<0:0):a>0);  
    }  
    ;
    
    inline int operator<=(const bignum&a)  
    {  
        return sgn<0?(a.sgn<0?comp(num,a.num)>=0:1):(sgn>0?(a.sgn>0?comp(num,a.num)<=0:0):a.sgn>=0);  
    }  
    ;
    
    inline int operator<=(const int a)  
    {  
        return sgn<0?(a<0?comp(num,-a)>=0:1):  
        (sgn>0?(a>0?comp(num,a)<=0:0):a>=0);  
    }  
    ;
    
    inline int operator==(const bignum&a)  
    {  
        return(sgn==a.sgn)?!comp(num,a.num):0 ;  
    }  
    ;
    
    inline int operator==(const int a)  
    {  
        return(sgn*a>=0)?!comp(num,ABS(a)):0 ;  
    }  
    ;
    
    inline int operator!=(const bignum&a)  
    {  
        return(sgn==a.sgn)?comp(num,a.num):1 ;  
    }  
    ;
    
    inline int operator!=(const int a)  
    {  
        return(sgn*a>=0)?comp(num,ABS(a)):1 ;  
    }  
    ;
    
    inline int operator[](const int a)  
    {  
        return digit(num,a);  
    }  
    ;
    
    friend inline istream&operator>>(istream&is,bignum&a)  
    {  
        read(a.num,a.sgn,is);  
        return  is ;  
    }  
    ;
    
    friend inline ostream&operator<<(ostream&os,const bignum&a)  
    {  
        if(a.sgn<0)  
            os<<'-' ;  
        write(a.num,os);  
        return os ;  
    }  
    ;
    
    friend inline bignum sqrt(const bignum&a)  
    {  
        bignum ret ;  
        bignum_t t ;  
        memcpy(t,a.num,sizeof(bignum_t));  
        sqrt(ret.num,t);  
        ret.sgn=ret.num[0]!=1||ret.num[1];  
        return ret ;  
    }  
    ;
    
    friend inline bignum sqrt(const bignum&a,bignum&b)  
    {  
        bignum ret ;  
        memcpy(b.num,a.num,sizeof(bignum_t));  
        sqrt(ret.num,b.num);  
        ret.sgn=ret.num[0]!=1||ret.num[1];  
        b.sgn=b.num[0]!=1||ret.num[1];  
        return ret ;  
    }  
    ;
    
    inline int length()  
    {  
        return :: length(num);  
    }  
    ;
    
    inline int zeronum()  
    {  
        return :: zeronum(num);  
    }   
    ;
    
}n,m,t,A[10],B[10],ans,a0,nowt;

bignum C(bignum n,bignum m)
{
    ans=1;bignum maxx=n-m;
    for(int i=1;maxx>=i;++i)ans=ans*(m+i)/i;
    return ans;
}

const int MOD=3389;

LL ksm(LL a,LL b)
{
    LL ans=1;
    for(;b;b>>=1,a=a*a%MOD)if(b&1)ans=ans*a%MOD;
    return ans;
}

struct Matrix
{
    int a[3][3];
    Matrix(){memset(a,0,sizeof(a));}
    void clear(){for(int i=1;i<=2;++i)a[i][i]=1;}
    Matrix operator * (const Matrix &B)
    {
        Matrix C;
        for(int i=1;i<=2;++i)
            for(int j=1;j<=2;++j)
                for(int k=1;k<=2;++k)
                    C.a[i][j]=(C.a[i][j]+a[i][k]*B.a[k][j])%MOD;
        return C;
    }
}a;

Matrix KSM(const Matrix &X,bignum b)
{
    Matrix A=X,ans;ans.clear();
    while(b>0)
    {
        if(b%2==1)ans=ans*A;
        A=A*A;
        b/=2;
    }
    return ans;
}

int main()
{
    int i;
    a0=0;
    cin>>n>>t>>m;t=a0-t;
    int inv=ksm(1234,MOD-2);
    a.a[1][1]=1234;a.a[1][2]=0;a.a[2][1]=a.a[2][2]=1;
    a=KSM(a,n-i);
    int res=(a.a[1][1]+5678ll*a.a[2][1])%MOD;
    bignum maxx=n-m;
    for(i=0;maxx>=i;++i)
    {
        A[i]=res;B[i]=A[i];
        nowt=1;
        for(int j=i-1;j>=0;--j)
        {
            nowt*=t;
            B[i]-=nowt*C(n-j,n-i)*B[j];
        }
        res=(res-5678)*inv%MOD;
        if(res<0)res+=MOD;
    }
    cout<<B[i-1];
    
    return 0;
}
```

---

## 作者：WilliamFranklin (赞：4)

### - Knowledge Review

二项式反演：

$$
f_n = \sum_{i = 0}^n{\binom{n}{i}g_i} \Longleftrightarrow g_n = \sum_{i = 0}^n{\binom{n}{i}(-1)^{n - i}f_i}
\\
f_k = \sum_{i = k}^n{\binom{i}{k}g_i} \Longleftrightarrow g_k = \sum_{i = k}^n{\binom{i}{k}(-1)^{i - k}f_i}
$$

### - Solution



首先推式子，等式右边的式子，用二项式定理展开，然后交换求和顺序一大堆操作：

$$
\begin{aligned}
	\sum_{k = 0}^n{b_k(x - t)^k}&=\sum_{k = 0}^n{b_k\sum_{i = 0}^k{\binom{k}{i}x^i (-t)^{k - i}}}\\
    &= \sum_{i = 0}^n{x^i\sum_{k = i}^n{b_k\binom{k}{i}(-t)^{k - i}}}
\end{aligned}
$$

然后又因为题目中：

$$
\sum_{k = 0}^n{a_k x^k} = \sum_{k = 0}^n{b_k(x - t)^k}
$$

所以：

$$
\sum_{k = 0}^n{a_k x^k} = \sum_{i = 0}^n{a_i x^i} = \sum_{i = 0}^n{x^i\sum_{k = i}^n{b_k\binom{k}{i}(-t)^{k - i}}}
$$

由此，可知：

$$
a_i = \sum_{k = i}^n{b_k\binom{k}{i}(-t)^{k - i}}
$$

但我们要求的是 $b_m$ 啊，那么我们可以用二项式反演搞一下：

$$
b_k = \sum_{i = k}^n{\binom{i}{k}t^{i- k}a_i}
$$

然后发现 $0 \le n - m \le 5$，那就暴算。

问题是求 $a_k$ 了，发现这个 $a_k$ 是有个循环节的，所以直接暴算即可。

注意要用高精度。

### - AC Code

```cpp
#include <bits/stdc++.h>
using namespace std;
#define x first
#define y second
#define mp(Tx, Ty) make_pair(Tx, Ty)
#define For(Ti, Ta, Tb) for(auto Ti = (Ta); Ti <= (Tb); Ti++)
#define Dec(Ti, Ta, Tb) for(auto Ti = (Ta); Ti >= (Tb); Ti--)
#define debug(...) fprintf(stderr, __VA_ARGS__)
#define range(Tx) begin(Tx),end(Tx)
const int N = 25020, B = 100000, W = 5;
long long temp[N];
struct node {
	int len;
	long long a[N];
	node operator + (const node &t) const {
		node ans;
		ans = t;
		For(i, 1, len + 1) ans.a[i] += a[i];
		long long last = 0;
		int w = max(t.len, len) + 5;
		ans.len = 1;
		For(i, 1, w) {
			ans.a[i] += last;
			last = ans.a[i] / B;
			ans.a[i] %= B;
			if (ans.a[i] != 0) ans.len = i;
		}
		return ans;
	}
	node operator - (const node &t) const {
		node ans;
		ans = t;
		For(i, 1, len + 1) ans.a[i] = a[i] - ans.a[i];
		long long last = 0;
		int w = max(t.len, len) + 5;
		ans.len = 1;
		For(i, 1, w) {
			ans.a[i] += last;
			last = 0;
			if (ans.a[i] < 0) last = -1, ans.a[i] += B;
			if (ans.a[i] != 0) ans.len = i;
		}
		return ans;
	}
	node operator * (const node &t) const {
		node ans;
		For(i, 0, N - 1) ans.a[i] = 0;
		int w = t.len + len + 10;
		For(i, 1, w) temp[i] = 0;
		For(i, 1, w) {
			For(j, 1, i) {
				if (j > t.len) break;
				if (i - j + 1 > len) continue;
				temp[i] += a[i - j + 1] * t.a[j];
			}
		}
		For(i, 1, w) ans.a[i] = temp[i];
		long long last = 0;
		ans.len = 1;
		For(i, 1, w) {
			ans.a[i] += last;
			last = ans.a[i] / B;
			ans.a[i] %= B;
			if (ans.a[i] != 0) ans.len = i;
		}
		return ans;
	}
	node operator / (const long long &t) const {
		long long last = 0;
		node ans;
		For(i, 0, N - 1) ans.a[i] = 0;
		ans.len = 1;
		Dec(i, len, 1) {
			ans.a[i] = (a[i] + last) / t;
			last = (a[i] + last) % t;
			last *= B;
		}
		ans.len = len;
		if (ans.a[len] == 0) ans.len--;
		ans.len = max(ans.len, 1);
		return ans;
	}
	long long operator % (const long long &t) const {
		long long last = 0;
		Dec(i, len, 1) {
			last *= B;
			last = (a[i] + last) % t;
		}
		return last;
	}
	node operator ^ (const long long &t) const {
		node ans;
		For(i, 0, N - 1) ans.a[i] = 0;
		For(i, 1, len) ans.a[i] = a[i] * t;
		long long last = 0;
		ans.len = 1;
		int w = len + 5;
		For(i, 1, w) {
			ans.a[i] += last;
			last = ans.a[i] / B;
			ans.a[i] %= B;
			if (ans.a[i] != 0) ans.len = i;
		}
		return ans;
	}
};
void sti(char s[], int n, node &a) {
	int len = 0;
	memset(temp, 0, sizeof(temp));
	for (int i = n; i > 0; i -= W) {
		len++;
		For(j, max(1, i - W + 1), i) {
			a.a[len] *= 10;
			a.a[len] += s[j] - '0';
		}
	}
	a.len = len;
}
int get(int x) {
	if (x == 0) return 1;
	int len = 0;
	while (x)  {
		len++;
		x /= 10; 
	}
	return len;
}
void print(node A) {
	cout << A.a[A.len];
	Dec(i, A.len - 1, 1) {
		int ll = get(A.a[i]);
		For(j, ll + 1, 5) cout << 0;
		cout << A.a[i];
	}
}
int fac[15];
node T[15], F[15], TT, NN, MM;
char tt[N], nn[N], mm[N];
long long a[N];
int geta(int x) {
	if (x == 0) return a[3388];
	return a[x];
}
int main() {
	cin.tie(nullptr)->sync_with_stdio(false);
	long long t;
	cin >> nn + 1 >> t >> mm + 1;
	For(i, 0, N - 1) NN.a[i] = 0;
	For(i, 0, N - 1) MM.a[i] = 0;
	int ln = strlen(nn + 1), lm = strlen(mm + 1);
	sti(nn, ln, NN);
	sti(mm, lm, MM);
	node NmM = NN;
	NmM = NmM - MM;
	int k = NmM.a[1];
	fac[0] = 1;
	For(i, 1, 8) fac[i] = fac[i - 1] * i;
	For(i, 0, 8) For(j, 0, N - 1) T[i].a[j] = 0;
	T[0].a[1] = 1;
	T[0].len = 1;
	For(i, 1, 8) T[i] = T[i - 1] ^ t;
	For(i, 0, 8) {
		For(j, 0, N - 1) F[i].a[j] = 0;
	}
	F[0].a[1] = 1;
	F[0].len = 1;
	node one;
	For(i, 0, N - 1) one.a[i] = 0;
	one.len = 1;
	one.a[1] = 1;
	node MMM = MM + one;
	For(i, 1, k) {
		F[i] = MMM;
		node MMMM = MMM;
		For(j, 2, i) {
			MMMM = MMMM - one;
			F[i] = F[i] * MMMM; 
		}
		MMM = MMM + one;
	}
	For(i, 0, k) {
		F[i] = F[i] / fac[i];
		F[i] = F[i] * T[i]; 
	}
	a[0] = 1;
	For(i, 1, 3388) a[i] = (a[i - 1] * 1234 + 5678) % 3389;
	node ans;
	For(i, 0, N - 1) ans.a[i] = 0;
	ans.a[1] = 0;
	ans.len = 1;
	int lll = 3388;
	For(i, 0, k) {
		int y = MM % lll;
		node now = F[i] ^ geta(y);
		ans = ans + now;
		MM = MM + one; 
	}
	print(ans);
	return 0;
}
```

细节一堆。

---

## 作者：Unnamed114514 (赞：2)

为什么都是二项式反演啊？

换元，令 $h=x+t$，有：$\sum\limits_{i=0}^na_i(x+t)^i=\sum\limits_{i=0}^n b_ix^i$。

那就是求 $x^m$ 的系数。

注意 $i\ge m$ 才可能造成贡献。

由二项式定理知，答案为 $\sum\limits_{i=m}^n C_{i}^m\times t^{i-m}\times a_i$。

注意 $i-m\le 5$，第一项和第二项可以暴力算，第三项可以找周期算。

---

## 作者：SAMSHAWCRAFT (赞：1)

首先这道题给定的 $\{a_i\}$ 递推公式模数较小，考虑求出循环节，我们可以用打表的方法求循环节，具体操作大致是写一个从 $1$ 到 $3389^2$（递推式循环节长度不超过模数的平方）的循环把 $a_i$ 各项算出来，由于 $a_{i+1}$ 只与 $a_i$ 有关，因此只要找到满足 $i\gt 0\land a_i=1$ 的最小的 $i$ 即可，这样我们就有了 $\{a_i\}$ 循环节长度。下面是打表程序，输出了 $3388$：

```cpp
#include <iostream>
#include <cstdlib>
int arr[3389*3389+1];
int main(){
  arr[0]=1;
  for(int cx=1;cx<=3389*3389;++cx){
    arr[cx]=(arr[cx-1]*1234+5678)%3389;
    if(arr[cx]==1) std::cout<<cx<<std::endl,exit(0);
  }
  return 0;
}
```

有了 $\{a_i\}$ 我们考虑推式子，题面上的式子中，等号左边的

$$
\sum\limits_{i=0}^n a_ix^i
$$

是一个形式幂级数，$a_i$ 相当于是这个形式幂级数的系数。但是右边不是形式幂级数，我们考虑把右边化成形式幂级数，只需把 $(x-t)^i$ 用二项式定理打开（下式 $(1)$），这时式子里面有二项式系数，考虑用二项式反演把 $b_i$ 求出来。在用二项式反演之前发现 $b_i$ 和 $x^j$ 的位置不对，考虑变换一下求和顺序（下式 $(2)$），只需对 $x^j$ 考虑每一个 $b_i$ 对它的贡献即可。这样就可以套二项式反演了（下式 $(4)$），注意式中下标变化，$\binom{i}{j}$ 变成 $\binom{j}{i}$ 并非笔误。

$$
\begin{aligned}
\because& &\sum\limits_{i=0}^{n}b_i(x-t)^i &= \sum\limits_{i=0}^{n}b_i 
\sum\limits_{j=0}^{i}\binom{i}{j}(-1)^j x^j t^{(i-j)} &(1)\\
& &&=\sum\limits_{i=0}^{n}x^i\sum\limits_{j=i}^{n}
\binom{i}{j}(-1)^{j-i}t^{j-i}b_{j} &(2)\\
\therefore& &\sum\limits_{i=0}^n a_ix^i &= 
\sum\limits_{i=0}^{n}x^i\sum\limits_{j=i}^{n}
\binom{i}{j}(-1)^{j-i}t^{j-i}b_{j} &(3)\\
\therefore& &b_i &=\sum\limits_{j=i}^{n}\binom{j}{i}(-1)^{j-i}t^{j-i}a_j &(4)
\end{aligned}
$$

于是我们就可以求得 $b_m$：

$$
b_m =\sum\limits_{i=m}^{n}\binom{i}{m}(-1)^{i-m}t^{i-m}a_i
$$

注意到数据范围中 $n-m\le5,n\in(0,10^{3000}]$，写一个高精度的递推即可，可能需要注意的就是这个二项式系数的递推了，我们显然不能 $O(n)$ 求这一列的二项式系数，但是由 $\binom{m}{m}=1$ 及 $\binom{i}{m}=\frac{i}{i-m}\binom{i-1}{m}$ 可以直接 $O(n-m)$ 递推。

不想手写高精度，下面是 Java 代码：

```java
import java.math.BigInteger;
import java.util.Scanner;

public class Main {
  public static void main(String[] args)throws Exception{
    Scanner sc=new Scanner(System.in);
    BigInteger n=sc.nextBigInteger();
    int t=sc.nextInt();
    BigInteger m=sc.nextBigInteger();
    int a[]=new int[3388];
    a[0]=1;
    for(int cx=1;cx<3388;++cx)
      a[cx]=(a[cx-1]*1234+5678)%3389;
    BigInteger sub=n.subtract(m),mrem=m.remainder(new BigInteger(Integer.toString(3388)));
    BigInteger ans=BigInteger.ZERO,base=BigInteger.ONE;
    for(int cx=0;cx<=sub.intValue();++cx){
      ans=ans.add(base.multiply(new BigInteger(Integer.toString(a[mrem.intValue()]))));
      m=m.add(BigInteger.ONE);
      base=base.multiply(m.multiply(new BigInteger(Integer.toString(t)))).divide(new BigInteger(Integer.toString(cx+1)));
      mrem=mrem.add(BigInteger.ONE).remainder(new BigInteger(Integer.toString(3388)));
    }
    System.out.println(ans);
  }
}
```

**复杂度分析**

Java 的高精度整数其实就是用 `int` 做的压位高精，因此对于一个位数为 $n$ 的大整数，高精度乘除取模应该都是 $O(n\log n)$ 的，在本题中，由于 $n$ 的位数是 $O(\log n)$ 的，因此单次高精度乘除取模的复杂度是 $O(\log n\log\log n)$。循环次数 $O(n-m)$，外加前面 $O(1)$ 的递推（运算次数是常数因而是 $O(1)$），总时间复杂度 $O((n-m)\log n\log\log n)$。

---

## 作者：Prean (赞：1)

什么【】出题人/tuu

题意明确。

右边是多项式平移，所以直接大力展开：：
$$ \sum_{i=0}^n\frac {x^i}{i!}\sum_{j=i}^nb_jj!\frac {(-t)^{j-i}} {(j-i)!} $$
能够得到：
$$ a_m=\frac 1 {m!}\sum_{j=m}^nb_jj!\frac {(-t)^{j-m}}{(j-m)!}=\sum_{j=m}^n\binom jm b_j(-t)^{j-m} $$
二项式反演：
$$ b_m=\sum_{j=m}^n\binom j ma_j(-t)^{j-m} $$
然后发现题目底下写着大大的 $ 0 \leq n-m \leq 5 $，只需要计算出 $ a_m $ 后面的就万事大吉了。

至于找 $ a $，因为有取模所以循环节长度不会超过模数的平方，或者直接大力矩快也行。复杂度是 $ O(\log n) $ 的。

然后剩下的就是高精度板子。。。

代码太长而且懒得写，不放了。。。

---

## 作者：ACPCWATLEMLE (赞：0)

~~每日一题解，绿名远离我~~ ~
# 广告
[my blog](https://www.cnblogs.com/SilentMelody/p/7191505.html)
# 正文
这道题其实很水，坑点在高精度。

开始是万紫千红，最后加了个高精终于见到了 AC 的曙光。

给定函数 $F(x)=\sum_{k=0}^na_kx^k=\sum_{k=0}^nb_k(x-t)^k$，求给定的 $b_m$

$F(x)$ 在 $x=t$ 处的泰勒展开：

$$F(x)=\sum_{k=0}^n\frac{F^{(k)}(t)}{k!}(x-t)^k$$

易知 $b_m=\frac{F^{(m)}(t)}{m!}$，总而得到

$$\frac{F^{(m)}(t)}{m!}=\sum_{k=0}^{n-m}\binom{m+k}{k}a_m+{k^{t}}^{k}$$

至于 $a_k$，因为 $\bmod\ 3389$ 意义下的数是有限的，显然有循环节，跑一遍就知道 $a_k={a_{k\bmod\ 3388}}$，~~我不会告诉你我开始写的 3389 找了 15 分钟的错~~，剩下的就剩高精度了

# AC code

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
int a;
const int MOD=1e9;
struct Big {
    ll S[10000],T,cur;
    void Input() {
        string s;cin>>s;int i,t,l=s.size();
        for(i=0;i<l;i++)
            t=(l-i-1)/9,S[t]=S[t]*10+s[i]-48,T=T*10+s[i]-48,T%=3388;
        cur=(l-1)/9;while(cur>0&&S[cur]==0) cur--;
    }
    void Divide(int k) {
        for(int i=cur;i>0;i--) {
            S[i-1]+=S[i]%k*MOD;S[i]/=k;
            if(S[cur]==0) cur--;
        } S[0]/=k;
    }
    void Add(int k) {
        S[0]+=k;int i=0;
        while(S[i]>=MOD) S[i+1]+=S[i]/MOD,S[i++]%=MOD;
        if(S[cur+1]) cur++;
    }
    void Add(const Big& o) {
        int i,r=max(o.cur,cur);
        for(i=0;i<=r;i++) {
            S[i]+=o.S[i];
            if(S[i]>=MOD) S[i+1]+=S[i]/MOD,S[i]%=MOD;
        } cur=r+5;while(cur>0&&S[cur]==0) cur--;
    }
    void Multiply(const Big& o,Big& E) {
        int i,j;memset(&E,0,sizeof(E));
        for(i=0;i<=cur;i++)
        for(j=0;j<=o.cur;j++) {
            E.S[i+j]+=S[i]*o.S[j];
            if(E.S[i+j]>=MOD) {
                E.S[i+j+1]+=E.S[i+j]/MOD;
                E.S[i+j]%=MOD;
            }
        }
        E.cur=cur+o.cur+5;
        while(E.S[E.cur]==0) E.cur--;
    }
    void Print() {
        printf("%lld",S[cur]);
        ll i,k;
        for(i=cur-1;i>=0;i--) {
            k=MOD/10;
            while(k>S[i]) putchar('0'),k/=10;
            if(k) printf("%lld",S[i]);
        }
    }
} N,M,J[10],T[2],R[2],Q,P[2],ANS;
int K,k,i,j;
int main() {
    N.Input();J[1].Input();M.Input();K=N.T-M.T;K+=K<0?3388:0;
    a=1;for(i=1;i<=M.T;i++) a=(1234*a+5678)%3389;
//  cout<<N.T<<' '<<M.T<<endl;
    ANS.Add(a);T[0].S[0]=1;
//  N.Print();puts("");
//  J[1].Print();puts("");
//  M.Print();puts("");
    for(k=1;k<=K;k++) {
        M.Add(1);
//      M.Print();puts("");
        T[k-1&1].Multiply(M,T[k&1]);
//      T[k].Print();
        a=(1234*a+5678)%3389;
        Q.S[0]=a;
        T[k&1].Divide(k);//T[k].Print();
        T[k&1].Multiply(Q,R[k&1]);
        if(k<K) J[k].Multiply(J[1],J[k+1]);
        J[k].Multiply(R[k&1],P[k&1]);
        ANS.Add(P[k&1]);
    }
    ANS.Print();
//  N.Input();M.Input();
//  N.Multiply(M,ANS);
//  ANS.Print();
}
```

---


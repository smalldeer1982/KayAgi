# [JLOI2015] 有意义的字符串

## 题目描述

B 君有两个好朋友，他们叫宁宁和冉冉。有一天，冉冉遇到了一个有趣的题目：输入三个非负整数 $b,d,n$，求

$$\left\lfloor \left ( \frac{b+\sqrt{d}}{2} \right ) ^n \right\rfloor \bmod p$$

其中 $p=7,528,443,412,579,576,937$

## 说明/提示

保证 $0<b^2 \le d<(b+1)^2 \le 10^{18}$，$n \le 10^{18}$，并且 $b\equiv 1\pmod 2$，$d\equiv 1\pmod 4$。


## 样例 #1

### 输入

```
3 13 5
```

### 输出

```
393
```

## 样例 #2

### 输入

```
5 29 114514
```

### 输出

```
4997196309027367968
```

# 题解

## 作者：xyz32768 (赞：21)

首先得出，$\frac{b+\sqrt d}{2}$和$\frac{b-\sqrt d}{2}$是一元二次方程$x^2-bx+\frac{b^2-d}{4}=0$的两根。

把$x^2-bx+\frac{b^2-d}{4}=0$移项得$x^2=bx+\frac{d-b^2}{4}$。

两边同乘以$x^{n-2}$，可以得出，$x^n=bx^{n-1}+\frac{d-b^2}{4}x^{n-2}$。

设$f[i]=(\frac{b+\sqrt d}{2})^i+(\frac{b-\sqrt d}{2})^i$，

此时就容易得出$f[i]$是个整数，并且递推式为$f[i]=bf[i-1]+\frac{d-b^2}{4}f[i-2]$，$f[0]=2,f[1]=b$。这时候就能通过矩阵乘法求得$f[n]$（注意，相乘会爆long long，因此要用快速乘）。

最后考虑怎样通过$f[n]$求得结果。由于题目限定$b^2\leq d<(b+1)^2$，所以$n$是奇数时$-1<(\frac{b-\sqrt d}{2})^n\leq0$，否则$n$是偶数时$0\leq(\frac{b-\sqrt d}{2})^n<1$。所以如果满足$b^2\neq d$并且$n$为偶数，则答案为$f[n]-1$，否则答案为$f[n]$。

注意特判$n=0$时结果为$1$。

代码：

```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
typedef long long ll;
ll b, d, n, tm; const ll ZZQ = 7528443412579576937ll;
ll add(ll a, ll b) {
    return (1ull * a + 1ull * b) % ZZQ;
}
ll prod(ll a, ll b) {
    ll res = 0;
    while (b) {
        if (b & 1) res = add(res, a);
        a = add(a, a);
        b >>= 1;
    }
    return res;
}
struct cyx {
    int n, m; ll v[4][4];
    cyx() {}
    cyx(int _n, int _m) :
        n(_n), m(_m) {memset(v, 0, sizeof(v));}
    friend inline cyx operator * (cyx a, cyx b) {
        int i, j, k; cyx res = cyx(a.n, b.m);
        for (i = 1; i <= res.n; i++) for (j = 1; j <= res.m; j++)
        for (k = 1; k <= a.m; k++)
            res.v[i][j] = add(res.v[i][j], prod(a.v[i][k], b.v[k][j]));
        return res;
    }
    friend inline cyx operator ^ (cyx a, ll b) {
        int i; cyx res = cyx(a.n, a.m);
        for (i = 1; i <= res.n; i++) res.v[i][i] = 1;
        while (b) {
            if (b & 1) res = res * a;
            a = a * a;
            b >>= 1;
        }
        return res;
    }
} P, Q;
int main() {
    cin >> b >> d >> n; P = cyx(2, 2); Q = cyx(2, 1);
    if (!n) return printf("1\n"), 0;
    tm = (d >> 2) - prod(b + 1 >> 1, b - 1 >> 1);
    P.v[1][1] = b; P.v[1][2] = tm; P.v[2][1] = 1;
    Q.v[1][1] = b; Q.v[2][1] = 2; P = (P ^ n - 1) * Q;
    ll ans = P.v[1][1]; if (d != b * b && !(n & 1)) ans--;
    if (ans < 0) ans += ZZQ; cout << ans << endl;
    return 0;
}
```

---

## 作者：PhantasmDragon (赞：15)

原式是一坨难看的东西,考虑怎么美化它.

先不管下取整,我们可以给它添一项,变成 $(\frac{b+\sqrt{d}}{2})^n+(\frac{b-\sqrt{d}}{2})^n$,再在后面减去它就可以了.

然后这个式子就非常的好,设$A=(\frac{b+\sqrt{d}}{2}),B=(\frac{b-\sqrt{d}}{2})$,则原式就可以表示为$A^n+B^n$.

考虑如何递推.
$$A^n+B^n=(A^{n-1}+B^{n-1})(A+B)-A^{n-1}B-AB^{n-1}$$
而
$$A^{n-1}B+AB^{n-1}=AB(A^{n-2}+B^{n-2})$$
所以设$f_n=A^n+B^n$,则
$$f_n=f_{n-1}(A+B)-f_{n-2}(AB)$$
这样就可以用矩阵乘法加速递推了.
但是式子中的根号看似会引入浮点数,其实仔细观察一下:
$$A+B=(\frac{b+\sqrt{d}}{2})+(\frac{b-\sqrt{d}}{2})=b$$
$$AB=\frac{b^2-d}{4}$$
$A+B$ 显然是一个整数,而 $AB$ 因为题目条件中 $b\ mod\ 2=1,d\ mod\ 4=1$ ,所以 $AB$ 同样是一个整数.
别忘了第二项( $B$ )使我们添上去的,最后要减去.那么我们来讨论减去这个式子的影响.
观察$(\frac{b-\sqrt{d}}{2})^n$这个式子,它的底数$\frac{b-\sqrt{d}}{2}$因为题目条件的限制显然是一个大于 $-1$ 的负数.

当 $n$ 是奇数的时候,这个式子就是一个大于$-1$的负小数.而我们减去一个负数相当于加上一个正数,而这个正数又不大于1,所以就会被式子中的下取整吃掉.

而当$n$ 是偶数的时候,这个式子又是一个小于 $1$ 的非负数, 所以$b^2=d$ 时,这个式子等于0,对答案没有影响,而$b^2\neq d$时,原式的整数应该减去了一个小于1的浮点数,再下取整,就变成了减一.

所以它的影响在最后统计一下即可.

----------

贴上代码:
```
#include<stdio.h>
#include<cstdlib>
#include<cstring>
#define ll unsigned long long
#define p 7528443412579576937ll
using namespace std;
typedef ll Mat[4][4];
ll b,d,n;
inline ll add(ll a,ll b){a+=b;return a>=p?a-p:a;}
ll ksc(ll a,ll b){
    ll ret=0;
    while(b){
        if(b&1)ret=add(ret,a);
        b>>=1;
        a=add(a,a);
    }
    return ret;
}
inline void Mulmat(Mat a,Mat b)
{
    Mat c;
    c[1][1]=add(ksc(a[1][1],b[1][1]),ksc(a[1][2],b[2][1]));
    c[1][2]=add(ksc(a[1][1],b[1][2]),ksc(a[1][2],b[2][2]));
    c[2][1]=add(ksc(a[2][1],b[1][1]),ksc(a[2][2],b[2][1]));
    c[2][2]=add(ksc(a[2][1],b[1][2]),ksc(a[2][2],b[2][2]));
    memcpy(a,c,sizeof(c));
}
void solve()
{
    Mat a={0};
    a[1][2]=(d-b*b)/4,a[2][1]=1,a[2][2]=b;
    Mat s={0};
    s[1][1]=1,s[2][2]=1;
    int flag=(n&1);
    while(n)
    {
        if(n&1) Mulmat(s,a);
        Mulmat(a,a);
        n>>=1;
    }
    ll ans=add(ksc(2,s[1][2]),ksc(b,s[2][2]));
    if(d*d!=b&&flag) ans--; 
    printf("%lld",ans);
}
int main()
{
    scanf("%lld%lld%lld",&b,&d,&n);
    n--;
    if(n==-1) {printf("1");return 0;}
    solve();
}
```

---

## 作者：Dumby_cat (赞：6)

## 题意描述

给定 $b$、$d$ 和 $n$。

~~试~~求出：

$$\left \lfloor  \left (    \frac{b+\sqrt{d} }{2}   \right )^{n} \right \rfloor \bmod{p} $$

其中 $p=7528443412579576937$，$0<b^{2} \le d < (b+1)^{2}\le 10^{18} $，$n\le 10^{18}$ 且 $b\bmod{2}=1$，$d \bmod{4}=1$。

## 题解报告
式子较为复杂，看了下标签是“矩阵乘法”，更加蒙了。（原本都打算搞个 double 的矩阵了。。。）

想要让式子与矩乘挂上钩，首先想到要把那个根号给去掉。于是想到在原式后加一个式子使两者相加能将根号去掉。

由于有一个 $n$，可以想到将带根号的那一项取负，其他不变（暂不考虑取模和向下取整），然后原式变为：

$$  \left (  \frac{b-\sqrt{d} }{2}  \right )^{n}   $$

在原式后加上现在这个式子便可将根号消掉，即：

$$ \left (  \frac{b+\sqrt{d} }{2}  \right )^{n}+ \left (  \frac{b-\sqrt{d} }{2} \right )^{n} $$

然后在式子最后减去一个 $\left (  \frac{b-\sqrt{d} }{2} \right )^{n}$ 就好了。

设 $x$ 为 $\frac{b+\sqrt{d} }{2} $，$y$ 为 $\frac{b-\sqrt{d} }{2} $。

设 $f_{n}=x^{n}+y^{n}$。

那么可以设我们的状态矩阵为：

$$\begin{bmatrix}  f_{n}&f_{n-1} \end{bmatrix}$$

需要通过 $\begin{bmatrix}  f_{n-1}&f_{n-2} \end{bmatrix}$ 转移到 $\begin{bmatrix}  f_{n}&f_{n-1} \end{bmatrix}$。

接下来考虑如何转移。

将 $f_{n}$ 拆成 $X\times f_{n-1}-X\times f_{n-2}$ 的形式，又因为 $f_{n-1}=x^{n-1}+y^{n-1}$，$f_{n-2}=x^{n-2}+y^{n-2}$，代入得： 

$$X\times \left ( x^{n-1}+y^{n-1} \right ) -X\times \left ( x^{n-2}+y^{n-2} \right ) $$

于是稍加考虑就可以得出：

$$x^{n}+y^{n}=\left ( x+y \right ) \times \left ( x^{n-1}+y^{n-1} \right ) - xy \times \left ( x^{n-2}+y^{n-2} \right ) $$

所以转移式为：

$$f_{n}=\left ( x+y \right ) \times f_{n-1}- xy \times f_{n-2}$$

能保证这个式子中没有任何浮点数吗？

我们发现 $f_{1}=\frac{b+\sqrt{d} }{2}+\frac{b-\sqrt{d} }{2}=b$，$f_{2}= \left (  \frac{b+\sqrt{d} }{2}  \right )^{2}+ \left (  \frac{b-\sqrt{d} }{2} \right )^{2} = \frac{b^{2}+d }{2} $。

$b$ 一定是整数，而由于 $b\bmod{2}=1$，$d \bmod{4}=1$，由费马小定理可得 $b^{2}\equiv b \pmod{2}$，所以 $b^{2}+d \bmod{2}=0$，所以 $ \frac{b^{2}+d }{2} $ 也是整数。

于是乎，$f_{1}$ 和 $f_{2}$ 都是整数，接下来只需证明出他俩前面的系数也是整数就好了。

首先易得 $x+y=b$，所以 $x+y$ 是整数，然后 $xy=\frac{b^{2}-d}{4}$，由欧拉定理可得 $b^{\varphi (4)}=b^{2}\equiv 1\pmod{4}$，又因为 $d \bmod{4}=1$，所以 $\left ( b^{2}-d \right ) \bmod 4=0$，所以 $xy$ 为整数。

综上，$f_{n}$ 总为整数。

所以转移矩阵也同时推出来了。

如下：

$$\begin{bmatrix} b &1 \\ -\frac{b^{2}-d}{4} &0\end{bmatrix}$$

这里的 $-\frac{b^{2}-d}{4}$ 为了方便可以写成 $\frac{d-b^{2}}{4}$。

最后再来看看刚才这个东西对答案的影响：

>然后在式子最后减去一个 $\left (  \frac{b-\sqrt{d} }{2} \right )^{n}$ 就好了。

由于答案是向下取整，所以当 $-\left (  \frac{b-\sqrt{d} }{2} \right )^{n}$ 为正且大小在区间 $\left [ 0,1 \right )$ 时对答案无影响。

由于 $0<b^{2} \le d < (b+1)^{2}\le 10^{18} $，所以 $\left (  \frac{b-\sqrt{d} }{2} \right )^{n}$ 的范围一定在区间 $\left [ 0,1 \right )$ 内。

接下来只要讨论式子的正负性。

因为 $0<b^{2} \le d $，所以 $ \frac{b-\sqrt{d} }{2}$ 一定小于 0。

当 $n \bmod{2}=1$ 时，即 $n$ 为奇数时，$-\left (  \frac{b-\sqrt{d} }{2} \right )^{n}$ 一定的范围一定在 $\left [ 0,1 \right )$ 内，对答案没有影响。

相反，当 $n \bmod{2}=0$ 时，$-\left (  \frac{b-\sqrt{d} }{2} \right )^{n}$ 的范围在区间 $\left ( -1,0 \right ]$ 内。当式子等于 0 时,即 $b=\sqrt{d}$，$b^{2}=d$ 时，该式对答案无影响。

综上，当且仅当 $n$ 为偶数且 $b^{2}\ne d$ 时，该式对答案有影响，答案向下取整后的值需要减一。

说了一大堆，终于到了大家最爱的代码时间。

## 嗲吗
```cpp
#define int long long
#define ull unsigned long long

int tormul(int a, int k) 
{  //龟速乘
	ull ans = 0;  //注意要开 ull，否则会 TLE！！（玄学 T，难道不应该 WA 吗）
	while (k) 
	{
		if (k & 1)ans = (ans + a) % MOD;
		a = (ull)(a + a) % MOD;  //开 ull。
		k >>= 1;
	}
	return ans;
}
struct mat 
{
	int a[2][2];
	mat() { memset(a, 0, sizeof a); }
	mat operator *(const mat &b)const 
	{
		mat op;
		for (int i = 0; i < 2; i++) 
			for (int k = 0; k < 2; k++) 
				for (int j = 0; j < 2; j++) 
					op.a[i][j] = (ull)(op.a[i][j] + tormul(a[i][k], b.a[k][j])) % MOD;  //ull
		return op;
	}
} ans, I;
void init() 
{
	I.a[0][0] = b, I.a[0][1] = 1, I.a[1][0] = (d - b * b) / 4;
	ans.a[0][0] = (b * b + d) / 2, ans.a[0][1] = b;
}
signed main() 
{
	b = read(), d = read(), n = read();
	init();
	if (n == 0ll) 
	{
		printf("1");
		return 0;
	} else if (n == 1ll) 
	{
		printf("%lld ", (int)((b + sqrt(d)) / 2) % MOD);
		return 0;
	}
	n -= 2;
	int ff = 0; //用来判断最后减去的式子对答案是否有影响。
	if (b * b != d && n % 2 == 0) ff--;
	while (n) 
	{
		if (n & 1)ans = ans * I;
		I = I * I;
		n >>= 1;
	}
	ans.a[0][0] += ff;
	printf("%lld ", ans.a[0][0]);
	return 0;
}
```
有错误请 D 我

---

## 作者：ezoiHQM (赞：4)

看来我数学还是太弱了，这道题也没有想到。
我们发现$(\frac{b+\sqrt d}{2})^n$是个无理数，而且这个数非常大，所以无法直接计算。我们又发现$(\frac{b-\sqrt d}{2})^n$的值虽然是个无理数，但是他的值向下取整之后非常好计算。然后我们又发现，$(\frac{b+\sqrt d}{2})^n+(\frac{b-\sqrt d}{2})^n$是个有理数，又因为$b\space mod\space2=1,d\space mod\space4=1$，所以不难证明这个数是一个整数。
所以，我们可以将问题转变为求$\lfloor[(\frac{b+\sqrt d}{2})^n+(\frac{b-\sqrt d}{2})^n]-(\frac{b-\sqrt d}{2})^n\rfloor$
然后我们就可以把问题拆成两部分。
首先我们考虑第一部分。我们可以构造一个一元二次方程：$x^2-b+\frac{b^2-d}{4}=0$，那么它的解$x_1=\frac{b+\sqrt d}{2},x_2=\frac{b-\sqrt d}{2}$。
那么第一部分就等于$x_1^n+x_2^n$
然后我们把这个式子变形一下就可以得到：$x_1^n+x_2^n=(x_1+x_2)(x_1^{n-1}+x_2^{n-1})-x_1x_2(x_1^{n-2}+x_2^{n-2})$
然后令$F(n)=x_1^n+x_2^n$，
可以得到$F(n)=(x_1+x_2)F(n-1)-x_1x_2F(n-2)$
然后我们构造的一元二次方程就派上用场了！
韦达定理：$$x_1+x_2=-\frac{b}{a}$$$$x_1x_2=\frac{c}{a}$$
所以$F(n)=bF(n-1)+\frac{d-b^2}{2}F(n-2)$
其中$F(0)=2,F(1)=b$
推到这里就是非常经典的的矩乘快速递推啦！
对于第二部分，
$\because b^2\leq d<(b+1)^2$
又$\because b,d\in N$
$\therefore b\leq\sqrt d< b+1$
$\therefore \frac{b-\sqrt d}{2}\in(-1,0]$
不难发现，当且仅当$n$为奇数且$\sqrt d!=b$时，这一部分对答案有$-1$的贡献。所以我们判一下是否减$1$就行了。
有一个坑点，这个模数非常大，加起来可能会爆$long\space long$，所以我们加的时候要判一下它们的和是否小于$0$。
注意两个数相乘会爆$long\space long$，所以要用快速乘。
快速乘其实主要就是利用$long\space double$的较高的精度，再利用我们小学学的一个东西（被除数减除数乘商等于余数）,就可以在$O(1)$的时间内完成较大的数的乘法并取模。
如果有错在评论区吼一声哦！
代码：
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
typedef long long ll;
const ll mod=7528443412579576937ll;
ll b,d,n;
ll Add(ll x,ll y){
	return x+y>=mod||x+y<0?x+y-mod:x+y;
}
ll Minus(ll x,ll y){
	return x-y<0?x-y+mod:x-y;
}
ll Mul(ll x,ll y){
	ll d=(ll)(x*(long double)y/mod+0.5);
	return Minus(x*y,d*mod);
}
struct Matrix{
	ll a[2][2];
	ll *operator[](int b){
		return a[b];
	}
	friend Matrix operator*(Matrix A,Matrix B){
		Matrix ret;
		for(int i=0;i<2;i++)
			for(int j=0;j<2;j++){
				ret[i][j]=0;
				for(int k=0;k<2;k++)
					ret[i][j]=Add(ret[i][j],Mul(A[i][k],B[k][j]));
			}
		return ret;
	}
	Matrix operator*=(Matrix B){
		*this=*this*B;
		return *this;
	}
}A,B;
Matrix qpow(Matrix x,ll n){
	Matrix ret;
	ret[0][0]=ret[1][1]=1,ret[0][1]=ret[1][0]=0;
	while(n){
		if(n&1ll)
			ret*=x;
		x*=x;
		n>>=1ll;
	}
	return ret;
}
int main(){
	scanf("%lld%lld%lld",&b,&d,&n);
	if(!n){
		puts("1");
		return 0;
	}
	A[0][0]=b;
	A[0][1]=2;
	B[0][0]=b;
	B[0][1]=1;
	B[1][0]=(d-b*b)/4;
	A[1][0]=A[1][1]=B[1][1]=0;
	A*=qpow(B,n-1);
	printf("%lld",Minus(A[0][0],!(n&1ll)&&(d!=b*b)));
	return 0;
}
```

---

## 作者：Register_int (赞：3)

设 $x=\dfrac{b+\sqrt d}2,y=\dfrac{b-\sqrt d}2,f_n=x^n+y^n$，则：

$$
\begin{aligned}
f_n&=x^n+y^n\\
&=(x+y)(x^{n-1}+y^{n-1})-xy(x^{n-2}+y^{n-2})\\
&=(x+y)f_{n-1}-xyf_{n-2}\\
&=bf_{n-1}-\dfrac{b^2-d}4f_{n-2}\\
\end{aligned}
$$

容易得出 $f_0=2,f_1=b$，直接矩阵快速幂即可。回到原式：

$$
\left\lfloor\left(\dfrac{b+\sqrt d}2\right)^n\right\rfloor=\left\lfloor f_n-\left(\dfrac{b-\sqrt d}2\right)^n\right\rfloor
$$

因为 $b\le\sqrt d<b+1$，所以后一项只可能恒为 $0$ 或正负交替趋近于 $0$。那么最终答案为：

$$
f_n-[n\bmod2=0\ \land\ b^2\not=d]
$$

撒花。

# AC 代码
```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;
typedef __int128 lll;

const ll mod = 7528443412579576937;
const ll inv = (lll)mod * 3 + 1 >> 2;

struct matrix {
    
	lll a[2][2];
	
	matrix(lll k = 0) {
		memset(a, 0, sizeof a);
		for (int i = 0; i < 2; i++) a[i][i] = k;
	}
	
	lll* operator [] (const int k) { return a[k]; }
	
	matrix operator * (const matrix &rhs) const {
		matrix res = 0;
		for (int k = 0; k < 2; k++) {
			for (int i = 0; i < 2; i++) {
				for (int j = 0; j < 2; j++) res[i][j] = (res[i][j] + a[i][k] * rhs.a[k][j] % mod) % mod;
			}
		}
		return res;
	}
	
	inline 
	void print() {
		for (int i = 0; i < 2; i++) {
			for (int j = 0; j < 2; j++) printf("%lld ", a[i][j]); puts("");
		}
		puts("");
	}
} base, x;

inline 
matrix qpow(matrix b, ll p) {
	matrix res = 1;
	while (p) {
		if (p & 1) res = res * b;
		b = b * b, p >>= 1;
	}
	return res;
}

ll b, d, n;

int main() {
	scanf("%lld%lld%lld", &b, &d, &n);
	base[1][0] = 1, base[0][1] = ((lll)d - b * b) % mod * inv % mod;
	x[0][0] = 2, base[1][1] = x[0][1] = b;
	x = x * qpow(base, n), printf("%lld", (ll)x[0][0] - (~n & 1 && (lll)b * b != d));
}
```

---

## 作者：Transfixion_ (赞：2)

题目链接：[$\texttt{Link}$](https://www.luogu.com.cn/problem/P3263)
## $\textbf{Description}$
给定三个整数 $b, d,n$，试求出
$$\left\lfloor{\left(\dfrac{b + \sqrt d}{2} \right)}^n\right\rfloor$$

其中 $1 < b^2\leq d < (b+1)^2 \le 10^{18}, 1\le n\le 10^{18}$，

且 $b\equiv1\pmod2,d\equiv1\pmod4$。

## $\textbf{Solution}$
[本题弱化版](https://www.luogu.com.cn/problem/P5136) 与 [蒟蒻写的题解](https://www.luogu.com.cn/blog/2018-28/solution-p5136)。

和 P5136 类似，考虑其共轭。设 $x=\dfrac{b+\sqrt d}{2},y=\dfrac{b-\sqrt d}{2}$。

一个显然的思路是构造 $F_n = x^n+y^n$。

$\begin{aligned}F_n&=(x+y)(x^{n-1}+y^{n-1})-xy(x^{n-2}+y^{n-2})\\&=(x+y)F_{n-1}-xy\times  F_{n-2}.\end{aligned}$

将 $x+y=b,xy=\dfrac{b^2-d}{4}$ 代入知 $F_n=b\times F_{n-1} + \dfrac{d - b^2}{4}\times F_{n-2}$。

然后是转移矩阵。我们需要通过 $\begin{bmatrix}F_{n-1}&F_{n-2}\end{bmatrix}$ 推得 $\begin{bmatrix}F_n &F_{n-1}\end{bmatrix}$。

结合 $F_{n-1}=1\times F_{n-1}+0\times F_{n-2} $ 手推一下，得到：

$\begin{bmatrix}F_{n-1}&F_{n-2}\end{bmatrix}\times\begin{bmatrix}b&1\\ \frac{d-b^2}{4}&0\end{bmatrix}=\begin{bmatrix}F_n &F_{n-1}\end{bmatrix}$

但是 $\dfrac{d-b^2}{4}$ 是分数，总不能写一个带 `double` 的矩阵。

回过来发现题目中有两个奇怪的条件，把它转化一下得到：

$\begin{cases}b\equiv1\pmod2 \\ d\equiv1\pmod4\end{cases} \Rightarrow \begin{cases}b^2\equiv1\pmod4 \\ d\equiv1\pmod4\end{cases} \Rightarrow d-b^2\equiv 0\pmod4$

即 $4\, |\, d-b^2$。结合 $b^2\le d$ 知 $\dfrac{d-b^2}{4}\in \mathbb{N}$。于是可以放心的把它放到转移矩阵中。

回到原题。我们需要求出 $\lfloor x^n\rfloor=\left\lfloor F_n-y^n\right\rfloor$。

根据 $b^2\le d \Rightarrow y\in(-1,0]$，我们得出：

- 当 $n$ 为奇时，$\lfloor x^n\rfloor=F_n$；

- 当 $n$ 为偶时，$\lfloor x^n\rfloor=F_n-[d=b^2]$。


合起来就是 $\lfloor x^n\rfloor=F_n-[d=b^2 \text{ and } 2|n]$。

于是就可以直接写代码了。

## $\textbf{Extra}$

- 两个 `long long` 相乘会炸。应用快速乘或 `__int128`。

- 取模，取模，取模。

- 特判 $n=0 \text{ or } n=1$。

- 初始矩阵 $\begin{bmatrix}F_1&F_2 \end{bmatrix}=\begin{bmatrix}b&\dfrac{b^2 + d}{2}\end{bmatrix}$。


注意样例不符合数据范围中的 $d< (b+1)^2$，不过对我的代码似乎没有影响？


## $\textbf{AC Code}$
```cpp
#include <bits/stdc++.h>
typedef long long i64;
typedef __int128 i128;
const i64 p = 7528443412579576937ll;

// FastIO...

struct Matrix {
    i128 a[2][2];
    Matrix() {memset(a, 0, sizeof(a));}
    Matrix operator * (const Matrix& mat) {
        Matrix res;
        for(int i = 0; i < 2; i++) {
            for(int k = 0; k < 2; k++) {
                for(int j = 0; j < 2; j++) {
                    res.a[i][j] += a[i][k] * mat.a[k][j];
                    res.a[i][j] %= p;
                }
            }
        } return res;
    }
}ans, base;

inline i64 cal(i64 b, i64 d) {
	return (i64)((b + sqrt(d)) / 2) % p;
}

inline void init(i64 b, i64 d) {
    base.a[0][0] = b, base.a[0][1] = 1;
    base.a[1][0] = d - b * b >> 2, base.a[1][1] = 0;
    ans.a[0][0] = b * b + d >> 1, ans.a[0][1] = b;
    ans.a[1][0] = 0, ans.a[1][1] = 0;
}

inline i128 solve(i64 b, i64 d, i64 n) {
    int f = ~(n -= 2) & 1 && d != b * b;
    for(init(b, d); n; n >>= 1) {
        if(n & 1) ans = ans * base;
        base = base * base;
    } return (ans.a[0][0] - f + p) % p;
}

i64 b, d, n;
signed main() {
    read(b), read(d), read(n);
    if(n == 0) return puts("1"), 0;
	if(n == 1) return write(cal(b, d)), 0;
	write(solve(b, d, n));
    return 0;
}
```

---

## 作者：Supor__Shoep (赞：0)

拿到题目，我们首先分析一下这个奇怪的式子：

$$\lfloor(\frac{b+\sqrt{d}}{2})^n \rfloor ~\text{mod}~p$$

重点肯定是在里面的那个式子里面，最显眼的肯定也就是那个 $\sqrt{d}$，根据整体形式，我们可以联系一元二次方程的求根公式 $x=-\dfrac{-b \pm \sqrt{b^2-4ac}}{2a}$，这里也是一个根号，并且和我们要求的极为相似。于是乎我们尝试着将原式转换成一个方程的根。设原方程为 $Ax^2+Bx+C=0$，根据对照可以列出方程：

$$\begin{cases} 2A=2\\ -B=b \\B^2-4AC=d \end{cases}$$

解得：

$$\begin{cases} A=1\\ B=-b \\ C=\dfrac{b^2-d}{4} \end{cases}$$

因此原方程转变成了：$x^2-bx+\dfrac{b^2-d}{4}=0$。由于每一项的次数呈递减，所以我们考虑移项，看看是否会形成一个转移式子：

$$x^2=bx-\dfrac{b^2-d}{4}$$

这个非常明显，是个标准的转移式子。这个时候就可以想到朴素 DP 大法，按照次数设计状态，然后根据前面的次数进行转移。

但原方程会有两个根，就是 $\dfrac{b\pm \sqrt{d}}{2}$。所以直接的转移会包括 $\dfrac{b-\sqrt{d}}{2}$ 带来的影响值。那么我们需要将 DP 进行合理的定义。设 $dp_n$ 表示 $(\dfrac{b+\sqrt{d}}{2})^n+(\dfrac{b-\sqrt{d}}{2})^n$ 的值，这个时候我们只需要拿 $dp_n$ 减去 $(\dfrac{b-\sqrt{d}}{2})^n$ 的影响值就可以了。

轻松写出转移式子：

$$dp_{i}=b\times dp_{i-1}-\dfrac{b^2-d}{4}\times dp_{i-2}$$

但是由于这个次数超出了 `int` 范围，所以考虑进行优化，这种对极大 $n$ 的优化，我们不难想到矩阵快速幂优化。我们把转移方程等号右边涉及到的变量提取出来：$dp_{i-1}$，$dp_{i-2}$，因此初始矩阵是一个 $1\times 2$ 的矩阵 ，而对应的常数项就是 $b$ 和 $\dfrac{b^2-d}{4}$，所以转移矩阵是一个 $2\times 2$ 的矩阵。初始矩阵 $st$ 和转移矩阵 $a$ 如下：

$$
st=
\left(
\begin{matrix}
dp_{i-1} & dp_{i-2}
\end{matrix}
\right)
$$

$$
a=
\left(
\begin{matrix}
b & 1 \\
-\dfrac{b^2-d}{4} & 0
\end{matrix}
\right)
$$

$st$ 的初始化就是 $n=1$ 和 $n=0$ 的情况。

然后我们突然发现一个问题，我们减去的 $(\dfrac{b-\sqrt{d}}{2})^n$ 是一个带根号的式子，我们该如何求出这个向下取整的值呢？

就在一筹莫展之际，那个亮眼的数据范围映入眼帘：$b^2\leq d<(b+1)^2$。我们尝试将 $\sqrt{d}$ 带入进去，$b\leq \sqrt{d} < b+1$。所以 $-1< \dfrac{b-\sqrt{d}}{4}\leq 0$。

由于 $|\dfrac{b-\sqrt{d}}{4}|<1$，$n$ 是个非负整数，所以 $0\leq |(\dfrac{b-\sqrt{d}}{2})^n|<1$，此时进行分类讨论：

- 如果 $b-\sqrt{d}=0$，则 $(\dfrac{b-\sqrt{d}}{2})^n=0$，向下取整为 $0$。

- 如果 $b-\sqrt{d}<0$，且 $2\mid n$，此时原式会变成正数，则 $0<(\dfrac{b-\sqrt{d}}{2})^n<1$，向下取整为 $0$。

- 如果 $b-\sqrt{d}<0$，且 $2\nmid n$，此时原式依然是负数，则 $-1<(\dfrac{b-\sqrt{d}}{2})^n<0$，向下取整为 $-1$。

综上所述，$(\dfrac{b-\sqrt{d}}{2})^n$ 的影响值无外乎就是 $0$ 或者 $-1$，计算的时候，我们判断第三种情况就可以了。

最后由于模数 $p=7528443412579576937 \approx 7\times 10^{18}$，计算过程很有可能爆 `long long`，所以我们可以开一个老祖宗 `__int128`，写个快读快写，就可以了过了。

代码如下：

```cpp
#include<bits/stdc++.h>
#define int __int128//懒 
using namespace std;
const int MAXN=83;
const int MOD=7528443412579576937;
int b,d,n;
void read(int &x)
{
	x=0;
	short flag=1;
	char ch=getchar();
	while(ch<'0'||ch>'9')
	{
		if(ch=='-')	flag=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')
	{
		x=(x<<1)+(x<<3)+(ch^48);
		ch=getchar();
	}
	x*=flag;
}
int quick_mul(int x,int y)//龟速乘，可能没有必要但是就是想写 
{
	int res=0;
	while(y)
	{
		if(y&1)	res=res+x,res%=MOD;
		x=x+x,x%=MOD;
		y>>=1;
	}
	return res;
}
void mul(int f[3],int a[3][3])//转移模板 
{
    int c[3];
    memset(c,0,sizeof(c));
    for(int j=1;j<=2;j++)
    {
        for(int k=1;k<=2;k++)    c[j]=(c[j]+quick_mul(f[k],a[k][j]))%MOD;
    }
    memcpy(f,c,sizeof(c));
}
void mulself(int a[3][3])//矩阵自乘模板 
{
    int c[3][3];
    memset(c,0,sizeof(c));
    for(int i=1;i<=2;i++)
    {
        for(int j=1;j<=2;j++)
        {
            for(int k=1;k<=2;k++)    c[i][j]=(c[i][j]+quick_mul(a[i][k],a[k][j]))%MOD;
        }
    }
    memcpy(a,c,sizeof(c));
}
void write(int x)
{
	if(x<10)
	{
		putchar(x+'0');
		return;
	}
	write(x/10);
	putchar(x%10+'0');
}
signed main()
{
	read(b),read(d),read(n);
	if(!n)//特判 
	{
		puts("1");
		return 0;
	}
	if(n==1)//特判 
	{
		long long B=b,D=d;//玄学调试 
		cout<<((B+sqrt(D)))/2;
		return 0;
	}
	int f[3];
	memset(f,0,sizeof(f));
	int a[3][3];
	memset(a,0,sizeof(a));
	a[1][1]=b,a[1][2]=1,a[2][1]=-(b*b-d)/4;
	f[2]=b,f[1]=(b*b+d)/2;//构造两个矩阵 
	n-=2;
	int temp=n;//n和n-2的奇偶性相同，所以提前储存n-2不会错 
	while(n)//快速幂模板 
	{
		if(n&1)	mul(f,a);
		mulself(a);
		n>>=1;
	}
	if(b*b!=d&&!(temp&1))	f[1]--;//特判第三种情况 
	write(f[1]);//输出 
	return 0;//华丽收场 
}
```

---

## 作者：Ruiqun2009 (赞：0)

~~ilovegzd~~

首先你需要知道 [矩阵运算](https://www.luogu.com.cn/blog/_post/501422)。

## 过程

让我们看看数据范围：$0<b^2\leq d<(b+1)^2\leq 10^{18},n\leq 10^{18}$，并且 $b\bmod 2=1,d\bmod 4=1$。

看到这个数据范围我们肯定要一个 $O(\log n)$ 左右的算法。

然后我们对两边取个根号，得到 $0<b\leq\sqrt{d}<b+1\leq 10^9$。

沿用 P5136 的解法，如果我们设一个数列
$$
F_n=(\dfrac{b+\sqrt{d}}{2})^n+(\dfrac{b-\sqrt{d}}{2})^n
$$
我们能在 $O(\log n)$ 的时间复杂度内使用矩阵快速幂计算 $F_n$。

## 计算 $(\frac{b-\sqrt{d}}{2})^n$

$$
\begin{aligned}
b&\leq\sqrt{d}<b+1\\
0&\leq\sqrt{d}-b<1\\
-1&< b-\sqrt{d}\leq 0\\
-1<-\frac{1}{2}&<\frac{b-\sqrt{d}}{2}\leq 0
\end{aligned}
$$

于是
$$
(\frac{b-\sqrt{d}}{2})^n
\left\{\begin{aligned}
\leq 0,n\bmod 2=1\\
\geq 0,n\bmod 2=0
\end{aligned}\right.
$$

## $O(\log n)$ 计算 $F_n$

第二波式子：
$$
\begin{aligned}
F_n&=(\dfrac{b+\sqrt{d}}{2})^n+(\dfrac{b-\sqrt{d}}{2})^n\\
&=\dfrac{b^2+2b\sqrt{d}+d}{4}\times (\dfrac{b+\sqrt{d}}{2})^{n-2}+\dfrac{b^2-2b\sqrt{d}+d}{4}\times (\dfrac{b-\sqrt{d}}{2})^{n-2}\\
&=\dfrac{2b^2+2b\sqrt{d}+d-b^2}{4}\times (\dfrac{b+\sqrt{d}}{2})^{n-2}+\dfrac{2b^2-2b\sqrt{d}+d-b^2}{4}\times (\dfrac{b-\sqrt{d}}{2})^{n-2}\\
&=\dfrac{2b^2+2b\sqrt{d}}{4}\times (\dfrac{b+\sqrt{d}}{2})^{n-2}+\dfrac{d-b^2}{4}\times (\dfrac{b+\sqrt{d}}{2})^{n-2}+\dfrac{2b^2-2b\sqrt{d}}{4}\times (\dfrac{b-\sqrt{d}}{2})^{n-2}+\dfrac{d-b^2}{4}\times (\dfrac{b-\sqrt{d}}{2})^{n-2}\\
&=\dfrac{b(b+\sqrt{d})}{2}\times (\dfrac{b+\sqrt{d}}{2})^{n-2}+\dfrac{d-b^2}{4}\times (\dfrac{b+\sqrt{d}}{2})^{n-2}+\dfrac{b(b-\sqrt{d})}{2}\times (\dfrac{b-\sqrt{d}}{2})^{n-2}+\dfrac{d-b^2}{4}\times (\dfrac{b-\sqrt{d}}{2})^{n-2}\\
&=b((\dfrac{b+\sqrt{d}}{2})^{n-1}+(\dfrac{b-\sqrt{d}}{2})^{n-1})+\dfrac{d-b^2}{4}((\dfrac{b+\sqrt{d}}{2})^{n-2}+(\dfrac{b-\sqrt{d}}{2})^{n-2})\\
&=bF_{n-1}+\dfrac{d-b^2}{4}F_{n-2}\\
\end{aligned}
$$
由于 $b\bmod 2=1,d\bmod 4=1$，得到 $\frac{d-b^2}{4}\in\mathbb{Z}$。

递推矩阵即为
$$
\left\lbrack\begin{matrix}
b&1\\
\frac{d-b^2}{4}&0\\
\end{matrix}\right\rbrack
$$
初始矩阵即为
$$
\left\lbrack\begin{matrix}
F_2&F_1\\
0&0\\
\end{matrix}\right\rbrack=\left\lbrack\begin{matrix}
d+b^2&b\\
0&0\\
\end{matrix}\right\rbrack
$$
然后就可以矩阵快速幂了。

代码：

```cpp
mat base, res;
constexpr mint one(1), zero(0);
mint ans;
unsigned long long n = 0;
mint b, d;
inline void solve() {
    cin >> b >> d >> n;
    if (n == 0) cout << '1' << '\n';
    else if (n == 1) cout << mint((unsigned long long)(b.val() + sqrt(d.val())) >> 1) << '\n';
    else {
        base.mat[1][1] = zero;
        base.mat[0][0] = b;
        base.mat[0][1] = one;
        base.mat[1][0] = (d - b * b).val() >> 2;
        ans = !(n & 1);
        ans = -ans;
        n -= 2;
        res.mat[0][0] = (b * b + d).val() >> 1;
        res.mat[1][0] = res.mat[1][1] = zero;
        res.mat[0][1] = b;
        for (; n; base *= base, n >>= 1) if (n & 1) res *= base;
        ans += res.mat[0][0];
        cout << ans << '\n';
    }
}
int main() {
    base.mat.resize(2);
    base.mat[0].resize(2);
    base.mat[1].resize(2);
    res.mat.resize(2);
    res.mat[0].resize(2);
    res.mat[1].resize(2);
    solve();
}
```

---

## 作者：DiruiXiao (赞：0)

##     [P3263 [JLOI2015]有意义的字符串](https://www.luogu.com.cn/problem/P3263)

**【题意简述】**

**注意：样例有误**

给定 $b$​，$d$​，$n$​ 且保证 $b \bmod 2=1$​，$d \bmod 4=1$​。

求: 
$$
\left\lfloor\left(\dfrac{b+\sqrt{d}}{2}\right)^n\right\rfloor\bmod p
$$
其中 $p=7528443412579576937$。

**【解题思路】**

~~我也来水一篇题解。~~

发现原式的困难之处在于有根号，可能会出现小数，从而不能直接取模。

不那么显然可以构造一个式子:

$\dfrac{b+\sqrt{d}}{2}+\dfrac{b-\sqrt{d}}{2}=\dfrac{d}{2}$。发现由于 $b\bmod2=1$ 且 $d \bmod 4 = 1$，所以 $\dfrac{b}{2}$ 为整数。

发现 $\dfrac{b+\sqrt{d}}{2}$，$\dfrac{b-\sqrt{d}}{2}$ 可以看做一个方程的两个根。设这个根为 $x_1$ 和 $x_2$。

则有 $x^2-bx+\dfrac{b^2-d}{4}=0$，对于每一项乘以 $x^{n-2}$。

得到 $x^n-bx^{n-1}+\dfrac{b^2-d}{4}x^{n-2}=0$。

移项的 $x^{n}=bx^{n-1}-\dfrac{b^2-d}{4}x^{n-2}$。

 发现式子很像一个类似斐波那契的线性递推序列，但是发现无法保证 $x^{i}$ 为整数。此时设 $F_i=x_1^i+x_2^i$ 。

那么 $F_i$ 是否是整数就很好判断了。

由于 $F_0=1+1=2$，$F_1=\dfrac{b+\sqrt{d}+b-\sqrt{d}}{2}=b$。

由于 $F_0$、$F_1$ 均为整数，且 $\dfrac{b^2-d}{4}$、$b$ 均为整数，所以 $F_i$ 也一定为整数。

考虑构造初始矩阵：
$$
S=\begin{bmatrix}2&b\end{bmatrix}
$$
考虑构造转移矩阵：
$$
T=
\begin{bmatrix}
0&-\dfrac{b^2-d}{4}\\
1&b
\end{bmatrix}
$$
则最后答案矩阵 $A=S\times T^{n-1}$。

最后得到的答案是 $x_1^n+x_2^n$，则只需减去 $x_2^n$ 即可。由于题中保证（~~样例就没有~~） $b^2\le d<(b+1)^2\to b\le\sqrt{d}<b+1$。所以 $x_2$ 为负数，且 $x_2>-1$。则 $x_2$ 在 $n$ 次方后的绝对值的大小一定小于 $1$，则只需要考虑 $x_2$ 的符号。

如果 $x_2^n<0$，则最终答案不变，否则最终答案减去 $1$。

#### $\texttt{CODE}$

```cpp
#include<bits/stdc++.h>
#define getchar() p1==p2&&(p2=(p1=buf)+fread(buf,1,1000000,stdin),p1==p2)?EOF:*p1++
#define putchar(x) (p3-obuf<1000000)?(*p3++=x):(fwrite(obuf,p3-obuf,1,stdout),p3=obuf,*p3++=x)
using namespace std;
static char buf[1000000], *p1 = buf, *p2 = buf, obuf[1000000],*p3 = obuf;
template<typename item>
inline void read(register item &x) {
	x = 0; register int f = 1; register char c = getchar();
	while(c < '0' || c > '9') { if(c=='-')f = -1; c = getchar(); }
	while(c >= '0' && c <='9') x = (x << 3) + (x << 1) + (c ^ 48), c = getchar();
	x *= f;
}
template<typename T>
inline void print(register T x) {
	x < 0 ? (putchar('-'), x = -x) : x;
	register int c[32], len = 0;
	if (x == 0) len = 1;
	while (x) ++len, c[len] = x % 10, x /= 10;
	for (int i = len; i >= 1; --i) {
		putchar(c[i] + '0');
	}
}
#define ll __int128
#define p 7528443412579576937ll
struct Matrix{
	ll a[2][2];
	Matrix() {
		memset(a, 0, sizeof(a));
	}
	Matrix operator * (const Matrix b) const {
		Matrix ret;
		for (int i = 0; i < 2; ++i)
			for (int k = 0; k < 2; ++k)
				for (int j = 0; j < 2; ++j)
					ret.a[i][j] += a[i][k] * b.a[k][j], ret.a[i][j] %= p;
		return ret;
	}
};

Matrix T;

Matrix quickPow(Matrix a, ll b) {
	Matrix ret; ret.a[0][0] = ret.a[1][1] = 1;
	while (b) {
		if (b & 1) ret = a * ret;
		a = a * a;
		b >>= 1;
	}
	return ret;
}

int main() {
	ll b, d, n, ans = 0; read(b), read(d), read(n);
	if (n == 0) return (puts("1"), 0);
	T.a[1][0] = 1, T.a[1][1] = b, T.a[0][1] = ((-b * b + d) / 4) % p;
	Matrix A = quickPow(T, n - 1);
	print((2 * A.a[0][1] + b  * A.a[1][1]) % p + ((n & 1) ? 0 : -1));
	fwrite(obuf, p3 - obuf, 1, stdout);
	return 0;
}
```



---

## 作者：C_S_L (赞：0)

由于 $\sqrt{d}$ 比较难处理，所以考虑转化。

因为要求出递推式，可以构造一个一元二次方程 $x^2+mx+n=0$ 有一根为 $x=\dfrac{b+\sqrt{d}}{2}$。显然，另一根为 $x=\dfrac{b-\sqrt{d}}{2}$。

我们得到 $x_1=\dfrac{b+\sqrt{d}}{2}$，$x_2=\dfrac{b-\sqrt{d}}{2}$。

由韦达定理可得：$\begin{cases}x_1+x_2=-m\\x_1x_2=n\end{cases}$，所以 $m=-b$，$n=\dfrac{b^2-d}{4}$。

故该一元二次方程为 $x^2-bx+\dfrac{b^2-d}{4}=0$。

先移项，得 $x^2=bx+\dfrac{d-b^2}{4}$。

再将其转化成递推形式，得 $x^n=bx^{n-1}+\dfrac{d-b^2}{4}x^{n-2}$。

设 $f_i=\left(\dfrac{b+\sqrt{d}}{2}\right)^i+\left(\dfrac{b-\sqrt{d}}{2}\right)^i$。( $i\in\mathbb{Z}^+$ )

由前面的递推式，我们得到 $f$ 的递推式：$f_n=bf_{n-1}+\dfrac{d-b^2}{4}f_{n-2}$。

然后用矩阵乘法即可。

转移形式与斐波那契数列类似，我们很快就能得到其转移矩阵为 $\begin{bmatrix}b&1\\\dfrac{d-b^2}{4}&0\end{bmatrix}$，初始矩阵为 $\begin{bmatrix}\dfrac{d+b^2}{2}&1\end{bmatrix}$，由此得到 $\begin{bmatrix}f_n&f_{n-1}\end{bmatrix}=\begin{bmatrix}\dfrac{d+b^2}{2}&1\end{bmatrix}\times\begin{bmatrix}b&1\\\dfrac{d-b^2}{4}&0\end{bmatrix}^{n-2}$。

注意 $n=0$ 和 $n=1$ 时要特判。

因为 $b\equiv1\pmod{2}$，所以 $b\equiv1,3\pmod{4}$，从而得到 $b^2\equiv1\pmod{4}$。

又因为 $d\equiv1\pmod{4}$，所以 $b^2-d\equiv0\pmod{4}$，即 $\dfrac{b^2-d}{4}$ 为整数。

故递推过程中 $f_i$ 均为整数。

最后，因为我们求的是 $\left\lfloor\left(\dfrac{b+\sqrt{d}}{2}\right)^n\right\rfloor$，所以要把 $\left(\dfrac{b-\sqrt{d}}{2}\right)^n$ 减掉。

因为 $\begin{cases}0\leqslant-\left(\dfrac{b-\sqrt{d}}{2}\right)^n<1&n\text{为奇数}\\-1<-\left(\dfrac{b-\sqrt{d}}{2}\right)^n\leqslant0&n\text{为偶数}\end{cases}$ ，

所以当 $n$ 为偶数且 $b\ne\sqrt{d}$（即 $b^2\ne d$ ）时，得到的答案要减 $1$。

个人认为本题的思维难度还是比较高的。代码难度不算太高，只要会矩阵乘法即可。

注：本题可能会爆 long long，需要使用 __int128 或快速乘。

代码（用的是 __int128）：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef __int128  ll;
typedef long long l;
const ll MOD=7528443412579576937;
ll b,d,n;
void read(ll&a){
    a=0;
	ll f=1;
	char ch=getchar();
    while(ch<'0'||ch>'9'){
    	if(ch=='-'){
    		f=-1;
		}
		ch=getchar();
    }
    do{
		a=a*10+ch-'0';
		ch=getchar(); 
	}while('0'<=ch&&ch<='9');
    a*=f;
}
void print(ll n){
    if(n>9)print(n/10);
    putchar(n%10+48);
}
struct Matrix{
    ll a[3][3];
    Matrix(){
        memset(a,0,sizeof a);
    }
    Matrix operator*(const Matrix &b)const{
        Matrix res;
        for(int i=1;i<=2;++i){
            for(int j=1;j<=2;++j){
                for(int k=1;k<=2;++k){
                    res.a[i][j]=(res.a[i][j]+a[i][k]*b.a[k][j])%MOD;
                }
            }
        }
        return res;
    }
}ans,base;
void init(){
    base.a[1][1]=b;
    base.a[1][2]=1;
	base.a[2][1]=(d-b*b)/4;
    ans.a[1][1]=(d+b*b)/2;
	ans.a[1][2]=b;
}
void qpow(ll b){
    while(b){
        if(b&1){
            ans=ans*base;
        }
        base=base*base;
        b>>=1;
    }
}
int main(){
    read(b);
    read(d);
    read(n);
    if(n==0){
        printf("1\n");
        return 0;
    }
    if(n==1){
        printf("%lld\n",ll(b+sqrt((l)d)/2)%MOD);
        return 0;
    }
    init();
    qpow(n-2);
    print(ans.a[1][1]-(b*b!=d&&n%2==0));
    return 0;
}
```


---

## 作者：JackWei (赞：0)

**[特征方程是啥？-> 传送门](https://zhuanlan.zhihu.com/p/104596563)**

观察数据范围，发现有个 $b^2$ 和 $d$ 的大小关系，

由此联想到 $b^2-d$，可以通过乘上原式的共轭根式 $\large\frac{b-\sqrt d}{2}$ 得到。

设 $\large x_1=\frac{b+\sqrt d}{2}\ ,\ x_2=\frac{b-\sqrt d}{2}$，则

$$\begin{cases} x_1+x_2=b\\ x_1x_2=b^2-d \end{cases}$$ 


故 $x_1,x_2$ 为方程 $x^2-bx-(b^2-d)=0$ 的两根，

也是数列 $a_n=ba_{n-1}+(d-b^2)a_{n-2}$ 的特征根。

这个数列的每一项可以用矩阵快速幂在 $O(\log n)$ 的效率内求出。

题目要求 $( \frac{b+\sqrt{d}}{2} ) ^n$ 即 $x_1^n$，故考虑原数列的通项，

设 $a_n=\alpha\cdot ( \frac{b+\sqrt{d}}{2} ) ^n+\beta\cdot ( \frac{b-\sqrt{d}}{2} ) ^n$，取 $\alpha=\beta=1$，则

$$a_0=2\ ,\ a_1=b\ ,\ a_n=( \frac{b+\sqrt{d}}{2} ) ^n+( \frac{b-\sqrt{d}}{2} ) ^n$$ 

这里有 $a_n\in \mathbb{Z}^*$。

出现 $( \frac{b+\sqrt{d}}{2} ) ^n$ 了，即求出 $a_n$ 的值再 $-(\frac{b-\sqrt d}{2})^n$。

再来看 $a_n$，由题目条件 $0<b^2 \le d<(b+1)^2 \le 10^{18}$ 可知 $-1<b-\sqrt d\le0$。

当 $b^2=d$ 时显然不影响下取整的结果。

考虑 $b^2\ne d$。此时，

当 $n$ 为奇数时， $0<-(\frac{b-\sqrt d}{2})^n<1$，又 $a_n\in\mathbb Z^*$，故此时不会影响下取整的值，答案为 $a_n$。

但当 $n$ 为偶数时， $-1<-(\frac{b-\sqrt d}{2})^n< 0$，$a_n\in\mathbb Z^*$，故此时会影响下取整的值，答案为 $a_n-1$。

最后再来看矩阵快速幂，根据数列 $a_n=ba_{n-1}+(d-b^2)a_{n-2}$，可得

$$\begin{bmatrix} a_{n-1}&a_{n} \end{bmatrix}= \begin{bmatrix} a_{n-2}&a_{n-1} \end{bmatrix}\cdot \begin{bmatrix} 0&d-b^2\\ 1&b \end{bmatrix}$$

$n=0$ 时特判一下。

另外，由于本题的模数很大，平方一下会爆long long，所以要用快（龟）速乘。


------------


 _AC Code_ 

```cpp
#include<iostream>
#include<stdio.h>
#include<string.h>
#include<algorithm>
#define int unsigned long long
using namespace std;

const int MOD=7528443412579576937;

int b,d,n;

int calc(int a,int b) //gui速乘
{
	int ans=0;
	for(;b;b>>=1)
	{
		if(b&1) ans=(ans+a)%MOD;
		a=a*2%MOD;
	}
	return ans;
}

void mul(int f[2],int a[2][2]) //两矩阵相乘
{
	int c[2];
	memset(c,0,sizeof c);
	for(register int j=0;j<2;j++)
		for(register int k=0;k<2;k++)
			c[j]=(c[j]+calc(f[k],a[k][j]))%MOD;
	memcpy(f,c,sizeof c);
}

void mulself(int a[2][2]) //自己乘自己
{
	int c[2][2];
	memset(c,0,sizeof c);
	for(register int i=0;i<2;i++)
		for(register int j=0;j<2;j++)
			for(register int k=0;k<2;k++)
				c[i][j]=(c[i][j]+calc(a[i][k],a[k][j]))%MOD;
	memcpy(a,c,sizeof c);
}

signed main()
{
	scanf("%lld%lld%lld",&b,&d,&n);
	if(!n) return puts("1"),0; //特判
	int p=b,q=(d-b*b)>>2;
	int f[2]={2,b},a[2][2]={{0,q},{1,p}};
	for(register int t=n;t;t>>=1) //矩阵快速幂
	{
		if(t&1) mul(f,a);
		mulself(a);
	}
	if(d!=b*b&&!(n&1)) printf("%lld\n",(f[0]-1)%MOD); //n为偶数
	else printf("%lld\n",f[0]%MOD); //n为奇数
	return 0;
}
```

---

## 作者：_Imaginary_ (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P3263)

我们有一种常见的处理 $A_n=(\frac{b+\sqrt{d}}{2})^n$ 的数的办法，就是加上 $B_n=(\frac{b-\sqrt{d}}{2})^n$

在本题中，我们很容易发现，$|\frac{b-\sqrt{d}}{2}|\le 1$

所以，我们转而求 $f_n=A_n+B_n$ 

实践告诉我们，这是二阶线性递推公式的通项，并且

$$
f_n=(A_1+B_1)f_{n-1}-(A_1B_1)f_{n-2}
$$

关于这个式子的证明，应该挺显然的，你只要拆开就行

我们可以按照斐波那契数列的通项求法，用矩阵快速幂。

具体的，假设递推式为 $f_n=af_{n-1}+bf_{n-2}$

$$
\begin{bmatrix}
f_{n+1}&f_{n}
\end{bmatrix}
=\begin{bmatrix}
f_2&f_1
\end{bmatrix}
\begin{bmatrix}
a&1\\b&0
\end{bmatrix}^{n-1}
$$

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int N=100005;
void write(__int128 x)
{
	int sta[30];
	int top=0;
	do{
		sta[top++]=x%10,x/=10;
	}while(x);
	while(top) putchar(sta[--top]+48);
}
struct matrix{
	int n,m;
	__int128 num[3][3];
	/*void print()
	{
		for(int i=1;i<=n;i++)
		{
			for(int j=1;j<=m;j++)
			{
				write(num[i][j]);
				printf(" ");
			}
			printf("\n");
		}
	}*/
};
__int128 P=7528443412579576937;
matrix operator *(const matrix& a,const matrix& b)
{
	matrix c;
	memset(c.num,0,sizeof(c.num));
	c.n=a.n;
	c.m=b.m;
	int n=c.n,m=c.m;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			for(int t=1;t<=a.m;t++)
			{
				c.num[i][j]+=a.num[i][t]*b.num[t][j];
				c.num[i][j]%=P;
			}

	return c;
}
matrix ksm(matrix a,ll b)
{
	if(b==1) return a;
	matrix tmp;
	if(b%2==0)
	{
		tmp=ksm(a,b/2);
//		printf("KSM a %lld\n",b/2);
//		tmp.print();
		return tmp*tmp;
	}
	else
	{
		tmp=ksm(a,b/2);
//		printf("KSM a %lld\n",b/2);
//		tmp.print();
		return tmp*tmp*a;
	}
}

__int128 read()
{
    __int128 x=0;
    char ch=getchar();
    while(ch<'0'||ch>'9')
    {
        ch=getchar();
    }
    while(ch>='0' && ch<='9')
        x=x*10+ch-'0',ch=getchar();
    return x;
}
__int128 b,d;
ll n;
matrix A,B;
int main()
{
	b=read(); d=read();
	scanf("%lld",&n);
	if(n==0)
	{
		printf("1");
		return 0;
	}
	A.m=B.n=B.m=2;
	A.n=1;
	A.num[1][1]=b;
	A.num[1][2]=2;
	B.num[1][1]=b;
	B.num[1][2]=1;
	B.num[2][1]=(d-b*b)/4;
	B.num[2][2]=0;
//	printf("A=\n");
//	A.print();
//	printf("B=\n");
//	B.print();
	A=A*ksm(B,n-1);
//	printf("A=\n");
//	A.print();
	write(A.num[1][1]-(n%2==0));
	return 0;
}
```

---


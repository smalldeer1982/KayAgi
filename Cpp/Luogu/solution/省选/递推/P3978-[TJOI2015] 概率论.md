# [TJOI2015] 概率论

## 题目描述

为了提高智商，ZJY 开始学习概率论。有一天，她想到了这样一个问题：对于一棵随机生成的 $n$ 个结点的有根二叉树（所有互相不同构的形态等概率出现），它的叶子节点数的期望是多少呢？

判断两棵树是否同构的伪代码如下：

$$
\def\arraystretch{1.2}
    \begin{array}{ll}
    \hline
    \textbf{算法 1}&\text{Check}(T1,T2) \\
    \hline
    1&\textbf{Require: }\text{ 两棵树的节点}T1,T2\\
    2&\qquad\textbf{if}\ \ T1=\text{null}\textbf{ or }T2=\text{null}\textbf{ then }\\
    3&\qquad\qquad\textbf{return}\ \ T1=\text{null}\textbf{ and }T2=\text{null}\\
    4&\qquad\textbf{else}\\
    5&\qquad\qquad\textbf{return}\ \text{Check}(T1\to\mathit{leftson},T2\to\mathit{leftson}) \\ 
    & \qquad\qquad\qquad \textbf{ and }\text{Check}(T1\to\mathit{rightson},T2\to\mathit{rightson})\\
    6&\qquad\textbf{endif}\\
    \hline
    \end{array} 
    $$



## 说明/提示

## 数据范围

对于 $30\%$ 的数据，$1 \le n \le 10$。

对于 $70\%$ 的数据，$1 \le n \le 100$。

对于 $100\%$ 的数据，$1 \le n \le 10^9$。

## 样例 #1

### 输入

```
1```

### 输出

```
1.000000000```

## 样例 #2

### 输入

```
3```

### 输出

```
1.200000000```

# 题解

## 作者：_rqy (赞：337)

...这道题比楼下说的还要神奇——它不仅代码好写，证明也不用楼下说的那么麻烦。

首先，我们令$f_n$表示$n$个点的二叉树个数；$g_n$表示$n$个点的所有$f_n$棵二叉树的叶节点总数。

找规律第一步当然是打表啦~写个爆搜或者手算都可以。

|n|1|2|3|4|5|...|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|$f_n$|1|2|5|14|42|...|
|$g_n$|1|2|6|20|70|...|

我们发现一个规律：$g_n=nf_{n-1}$。

证明这个规律其实超级简单：

- 对于每棵$n$个点的二叉树，如果里面有$k$个叶节点，那么我们分别把这$k$个叶子删去会得到$k$棵$n-1$个点的二叉树；
- 而每棵$n-1$个点的二叉树恰好有$n$个位置可以悬挂一个新的叶子，所以每棵$n-1$个点的二叉树被得到了$n$次；
- 综上，我们即可得出结论：所有$n$个点的二叉树的叶子个数和等于$n-1$个点的二叉树个数$\times n$。

那么我们只需要求出$f$即可。而$f$的递推式可以通过枚举左子树结点个数得到：

$$f_n=\sum_{i=1}^{n-1}f_if_{n-i-1}$$

边界是$f_1=1$。应该可以一眼看出来这是Catalan数列（其实一看那个$1,2,5,14,42$就应该知道，滑稽）

于是答案即为

$$\frac{g_n}{f_n}=\frac{nf_{n-1}}{f_n}$$

代入卡特兰数的通项公式$f_n=\frac{\binom{2n}{n}}{n+1}$很容易就得到上式等于$\frac{n(n+1)}{2(2n-1)}$。

代码：

```cpp
#include <cstdio>

int main() {
  double n;
  scanf("%lf", &n);
  printf("%.12f", n * (n + 1) / (2 * (2 * n - 1));
  return 0;
}
```

---

## 作者：Niko (赞：60)

rqy写的太简单啦Orz

生成函数+求导

设$g(n)$表示有$n$个节点的二叉树的个数,$g(0) = 1$

设$f(x)$表示$n$个节点的二叉树叶子节点的个数，$f_0 = 0,f_1 = 1$

那么$ans = \frac{f_i}{g_i}$

对于$g_i$

考虑有一颗$n$个点的二叉树,由于左右字数都是二叉树,枚举左右子树的点数

$$g_n = \sum_{i = 0}^{n - 1}g_ig_{n - i - 1}$$

这就是卡特兰数，通项为$\frac{C_{2n}^{n}}{n + 1}$

对于$f_i$

枚举左右子树的大小，我们可以有$g$函数推出,由于左右对称，最后$*2$

$$f_n = 2\sum_{i = 0}^{n - 1}f_i*g_{n - i - 1}$$

我们要找到$f$与$h$的关系

另$G(x)$为$g$的生成函数，$F(x)$为$f$的生成函数

$$G(x) = x G^2(x) + 1,F(x) = 2xF(x)G(x) + x$$

对于$G(x)$他的封闭形式为$\frac{1-\sqrt{1-4x}}{2x}$,(对于另外一根不收敛,舍去) 

对$F(x)$得到$F(x) = x * (1 - 4x)^{-\frac{1}{2}}$ 


$$(xG(x))'=\frac 1{\sqrt{1-4x}}=\frac{F(x)}x$$

$xG(x)$的每一项$xg_nx^n = g_nx^{n +1}$求导后变为$(n + 1)g_nx^n$,也就等于等式右边的$\frac{f_{n + 1}x^{n + 1}}{x} = f_{n + 1}x^n$ 也就是说$f_{n + 1} = (n+1)g_n$即$f_n=g_{n-1}$ 
带入$g_n =\frac{C_{2n}^{n}}{n + 1}$
化简得到

$$ans =\frac{n(n + 1)}{2(2n + 1)}$$


---

## 作者：AnoonA (赞：51)

### [传送门](https://www.luogu.org/problem/P3978)
# 前排提示：这一篇是专门讲~~详细~~证明的题解，所以需要一些数学前置知识，如果您只是想要看考场上该如何写出题目而不是证明，请参考其他大佬题解QWQ


## 解题思路
（听说这道题可以用二项式定理展开和泰勒展开）Orz可是我tcl不懂

 ~~刚看到黑题标签时：告辞~~
 
 结果发现有Catalan算法标签于是打算做做看。
 算了一下发现不对劲。 又点开标签发现有个叫生成函数的东西，可是那玩意是啥我不会啊，所以学习了一下啥是生成函数。
 后面会有卷积形式的变化，这里也是很吃数学功底。还有解级数方程的方法（换元）。最后是积分和求导,当时我还套了一下莱布尼茨公式发现不得（所以要有一定的高等数学基础）~~还要有敏锐的洞察力~~。_QWQ_ 

## 前置知识

~~**-1.解方程**~~

~~**0.打表**~~

**1.卡特兰级数**

$h_{n}=\sum_{i=0}^{n-1}h_{i}h_{n-i-1} (h_{0}=1)$

也可以写成

$\tfrac{\binom{2n}{n}}{n-1}$

**2.生成函数**

对于任意数列a0,a1,a2...an 即用如下方法与一个函数联系起来：
$G(x)=a_{0}^{}+a_{1}x^{}+a_{2}x^{2}+a_{3}x^{3}+···+a_{n}x^{n}$

即$G(x)=\sum_{i=0}^{\infty}a_{i}x^{i}$

**3.卷积**

一般形式：$C_{n}=\sum_{i=0}^{n}a_{i}b^{i}$

狄利克雷卷积：$C_{n}=\sum_{d|n}^{}a(d)b(\frac{n}{d})$
(噢这题不用到这个 了解一下就好

**4.导数的基本法则**

$(x^a)'=ax^{a-1}$

**注意：不定积分和求导互为逆运算（当时就是忘记直接用这个东西然后推了好久）**

**5..换元积分法**

(i)设函数$f(x)$在区间$I$上有定义,$\phi(t)$在区间$J$上也存在，且
$\int f(\phi(t))\phi'(t)dt=F(\phi(t))+C$

(ii)（重点来了）
如果$x=\phi(t)$在$J$上存在反函数$t=\phi^{-1}(x)$,$x\in I$,且不定积分$\int f(\phi(t))\phi'(t)dt=G(t)+C$在J上存在时，在I上有
$\int f(x)dx=G(\phi^{-1}(x))+C$

那接下来直接来解题

## 正文

首先我们定义：
$f_{i}$为有i个节点的$f_{i}$棵二叉树的叶节点总数，
$h_{i}$为有i个节点的二叉树个数。

看到这里，我相信来做这题的~~大多数都是对卡特兰数模型很熟悉的~~，所以$h_{n}=\sum_{i=0}^{n-1}h_{i}h_{n-i-1}(h_{0}=1)$(前置知识1）

当然一眼看不出来也没关系，可以从左子树情况开始枚举也可以得到这个式子。

看到题目要求的是叶节点的期望,容易得到 $ans=\frac{f_{n}}{h_{n}}$

那明显就是要知道$f_{n}$与$h_{n}$的关系，那怎么办呢？ 考场上当然是打表找规律啦，但是这一篇要讲讲详细证明，所以我们先把$f_{n}$也枚举出来

枚举左右子树便得到$f_{n}=2\sum_{i=0}^{n-1}h_{i}h_{n-i-1}(f_{0}=0,f_{1}=1)$

（前置知识2）$f_{i},h_{i}$生成函数：

$F(x)=\sum_{i=0}^{\infty}f_ix^i$ , $H(x)=\sum_{i=0}^{\infty}h_ix^i$

有没有发现啥，这两个式子是卷积（前置知识3）

我们要找的是$H(x)$即卡特兰数列的通解。
最后会得到这个式子$H(x)=xH(x)^2+1$(如果看不懂下面的那就直接看这个式子好了qwq）

那可能大家都会问了，这个怎么就推出来了？？上面还是卷积，下面就给我一个式子了，有兴趣看详细证明的请看下面这段（用平实的语言讲解，应该好懂，别看着吓人，实际上就是代入，移项啊这些变形而已）：

首先是卡特兰数的式子（这个很明白吧）：$h_{n+1}=\sum_{i=0}^{n}h_ih_{n-i},h_0=1$··········(1式)

关键一步：换元——令$y=\sum_{n \geqslant0}^{i=0}h_nx^n$（这里是卷积形式，没错吧）

将（1式）代入得到：$\sum_{n \geqslant0}^{}h_{n+1}x^n=\sum_{n \geqslant0}^{}(\sum_{i=0}^{n}h_{i}h_{n-i})x^n$··········（2式）

抽个x出来（初中的提取公因式）
$x\sum_{n \geqslant0}h_{n+1}x^n=\sum_{n \geqslant1}h_nx^n=y-1$··········（3式）

（仔细看这里的西格玛符号下标，解释一下为什么要减一，因为他$h_{n-1}$不是变成$h_n$了吗，说明提了一个$h_0$出来，而$h_0=1$）

由（3式）移项得（除了一个x过等式右边）$\sum_{n \geqslant0}h_{n+1}x^n=\frac{y-1}{x}$

而且由（2式）得$\sum_{n \geqslant0}h_{n+1}x^n=y^2$

等量代换得$\frac{y-1}{x}=y^2$(这就是证明开始前上面那个式子$H(x)=xH(x)^2+1$)终于得到方程了！

### 证明结束。

**lpx:"其实你不要把它想得太难，要想到思路固然很难，但是只要一有变形的做法就大胆去试，其实高等数学也是小学数学，也是移项，相加减，代入求解一步步来的"** 这句话放在这里与大家共勉啦

解出$y=\frac{1-\sqrt{1-4x}}{2x}$(另外一根不收敛，舍)

同理我们也可以得到$F(x)=2xF(x)H(x)+x$（这个就不写证明了，要不太长了QWQ，那就留给各位自行思考吧）

同样也解得$F(x)=\frac{x}{\sqrt{1-4x}}$

接下来对$\frac{F(x)}{x}$积分得到（前置知识5，到了第三步大家可能就不太懂为什么是这样，此时回去看前置知识5突然恍然大悟有木有，原来用这个）

$\int \frac{F(x)}{x}dx=\int (1-4x)^{-\frac{1}{2}}dx=\int -\frac{1}{4}(1-4x)^{-\frac{1}{2}}(1-4x)'dx$

$=\frac{-\sqrt{1-4x}}{2}+C=xH(x)$

这时候运用前置知识4中的注意：**不定积分和求导互为逆运算**

上面的式子把$\frac{F(x)}{x}$积分得到了$xH(x)$说明
$xH(x)$求导后就是$\frac{F(x)}{x}$。

前置知识4说了：$(x^a)'=ax^{a-1}$

所以$[xH(x)]'=\sum_{i=0}^{\infty}(i+1)h_ix^i=\frac{F(x)}{x}$

解得$F(x)=\sum_{i=1}^{\infty}ih_{i-1}x$

所以！终于！得到了最开始我们要求的关系式！$f_n=nh_{n-1}$

$ans=\frac{f_n}{h_n}=\frac{nh_{n-1}}{h_n}$

$h_n=\frac{\binom{2n}{n}}{n+1}$代入化简得到最终答案：

$ans=\frac{n(n+1)}{2(2n+1)}$

贴下代码
```cpp
#include<cstdio>
double n;
int main()
{
	scanf("%lf",&n);
	printf("%.10f",n*(n+1)/2*(2n-1));
}
```

# 后记
那以上就是本篇题解的所有内容啦，非常感谢各位小伙伴能够看到这里。作为萌新的第一篇题解，希望各位小伙伴能给个赞啦OVO Thanks♪(･ω･)ﾉ

最后，各位考场上要是碰到这种很烧脑的题目，千万不要去强行推理证明（大佬可以无视我），找规律打表，保证正确性的同时节约时间。

$\color{red}\text{最后祝各位NOIP2019/省选2020/NOI2020 RP++}$
### 特别鸣谢

和我一起浪费时间的两位哥哥（lpx学长 和某程序员）qwq

---

## 作者：Elegia (赞：44)

无脑上 Lagrange 反演。

记 $T(z,t)= \sum a_{n,m} z^nt^m$ 是有 $n$ 个节点其中有 $m$ 个叶子，直接列出

$$T=z(t+2T+T^2)$$

因此

$$z=\frac{T}{t+2T+T^2}$$

根据 Lagrange 反演，可得

$$[z^n]T=\frac 1n [w^{n-1}] (t+2w+w^2)^n$$

我们只需要知道对所有树，叶子数量之和，因此答案是

$$\left.\frac{\mathrm{d}}{\mathrm{d}t}[z^n]T\right|_{t=1}$$

带入可得

$$[w^{n-1}](w+1)^{2n-2}=\binom{2n-2}{n-1}$$

然后除以 Catalan 数就知道答案了。

---

## 作者：Kubic (赞：44)

# 声明：我是来为rqy神仙的题解的证明部分作补充的。
**rqy**神仙的思维太过跳跃，本蒟蒻看了好久才明白。

证明：$g_n=f_{n-1}\times n$
# Part 1
对于每一个$n$个节点的二叉树，假设它有$a$个叶子节点，则**分别**删去这$a$个节点，就能得到$a$个$n-1$个节点的二叉树。也就是说，我们可以认为这一个$n$个节点的二叉树**对应了**$k$个$n-1$个节点的二叉树，每有一次对应就会对$g_n$产生$1$的贡献。我们的任务转变为求出共有多少次对应。
# Part 2
对于每一个$n$个节点的二叉树，假设它有$b$个拥有恰好$1$个子节点的节点，$c$个拥有恰好$2$个子节点的节点。那么一个显然的结论是$a+b+c=n$。还有一个不那么显然的结论是$b+2c=n-1$。这是为什么呢？因为除了根节点之外，每一个节点都有恰好$1$个父节点，也就是说，所有点的子节点就会**不重不漏**地包含除了根节点之外的所有节点，总共就有$n-1$个节点。
# Part 3
对于每一个$n$个节点的二叉树，当前的每一个叶子节点会提供$2$个悬挂新叶子节点的位置，当前的每一个拥有恰好$1$个子节点的节点会提供$1$个悬挂新叶子节点的位置，所以它总共有$2a+b$个可以悬挂新叶子节点的位置。根据$Part$ $2$中的$2$个结论，我们可以得出$2a+b=n+1$。也就是说，总共有$n+1$个位置可以悬挂新叶子节点。

因此，每一个$n-1$个节点的二叉树在计算$g_n$的贡献中都总共被对应了$n$次，也就是说，$g_n$就等于$n-1$个节点的二叉树总数$\times n$。于是我们可以得到$g_n=f_{n-1}\times n$。

其余部分可以参照**rqy**神仙的题解，这里不再赘述。

**希望对大家有帮助！**

---

## 作者：Lamorak (赞：15)

在我前面的 dalao 们已经讲的很清楚了，但似乎没有人配上图片，那我就配上图片再~~详细的~~讲解一遍吧。


------------

### 前言
首先，我们应该清楚 Catalan 数列适用的题型：
>1. 括号匹配，有 $n$ 个左括号与 $n$ 个右括号，求合法匹配方案。
>1. 出栈次序，可见[P1044](https://www.luogu.com.cn/problem/P1044)
>1. $n$ 边形求划分为三角形的方案数
>1. 求 $n$ 个结点的二叉树有多少形态
>1. 在 $n \times n$ 的网格中从左下角到右上角的方案数

当然还有诸如[P1754](https://www.luogu.com.cn/problem/P1754)之类的变形题

如果你觉得以代数方面来学习 Catalan 过于困难，[这个博客](http://blog.sina.com.cn/s/blog_6917f47301010cno.htm)讲的折线法应该更好理解


------------

### 进入此题
二叉树的形态，一眼可看出是 Catalan 的4号题型，那么以下是我对此题的一些理解：

$f[i]$ 表示有 $i$ 个结点的二叉树个数，$f[i]$ 满足 Catalan 数。

假设 $n=3$：

![](https://cdn.luogu.com.cn/upload/image_hosting/oyv1wj2r.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

有六个叶子节点。

删掉叶子节点：

![](https://cdn.luogu.com.cn/upload/image_hosting/lhdivb8g.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

有两种状态，即 $n-1$ 个节点的二叉树状态数，即 $f[n-1]$ 的值。


将状态分别加上叶子节点：

![](https://cdn.luogu.com.cn/upload/image_hosting/148sug7l.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

$f[n-1]$ 的每种状态修改后又有 $n$ 种状态。

综上，我们可以得出结论：所有 $n$ 个结点的二叉树的叶子个数和等于 $f[n-1] \times n$。

最终答案为 
$$\frac{n \times f_{n-1}}{f_{n}}$$ 

将 Catalan 数的通项公式
$$f_{n}=\frac{C_{2 \times n}^{n}}{n+1} $$
代入，再化简一下，即可得到答案
$$ \frac{n \times (n+1)}{2 \times (2 \times n-1)}$$



------------
### 代码
```
#include<bits/stdc++.h>
#define ld double
using namespace std;
ld n,ans;
int main(){
	scanf("%lf",&n);
	ld b=2.0*(2.0*n-1.0);
	ld a=n*(n+1.0);
	ans=a/b;
	printf("%.9lf",ans);
	return 0;
}
```
~~码风不是很丑吧~~

---

## 作者：Jayun (赞：6)

[~~更丰富的展现~~](https://www.cnblogs.com/GJY-JURUO/p/11405222.html)

# 题目描述：

## Description：

![](https://www.lydsy.com/JudgeOnline/upload/201504/111(3).png)

## Input

输入一个正整数N，代表有根树的结点数

## Output

 输出这棵树期望的叶子节点数。要求误差小于1e-9


## Sample Input

1

## Sample Output

1.000000000

## HINT

 1<=N<=10^9

[洛谷链接](https://www.luogu.org/problem/P3978)

[BZOJ链接](https://www.lydsy.com/JudgeOnline/problem.php?id=4001)

# 思路：

一眼数学期望~~（毕竟题目里都已经说了）~~，那期望是什么呢？？？

> 在概率论和统计学中，数学期望(mean)（或均值，亦简称期望）是试验中每次可能结果的概率乘以其结果的总和，是最基本的数学特征之一。它反映随机变量平均取值的大小。
> $$\text{——百度百科}$$

![](https://s2.ax1x.com/2019/08/24/myRq8s.jpg)


那这道题目的期望就是**有n个节点的树的叶子节点总个数/树的个数**了。

那我们康康这里面有什么~~不为人知的~~规律吧：

![](https://s2.ax1x.com/2019/08/24/myTt6H.png)

树的个数就是$Cat_n$！！！

叶子节点总个数就是$Cat_{n-1}\times n$！！！

发现没？？？

那柿子就是$\frac{Cat_{n-1}\times n}{Cat_n}$

当然直接这么做是不行的，你需要把它化简成$\frac{n^2 + n}{ 4n - 2}$

# 代码：

```cpp
int main()
{
    cin >> n;
    printf("%.9lf", (n * n + n) / (4 * n - 2));  //公式
    return 0;
}


```

---

## 作者：autoint (赞：5)

# 前置：卡特兰数
记$C_n$为$n$个节点的二叉树的个数，$C_0=1$，对于$n \geq 1$，取一个根节点，枚举其左子树大小，有
$$C_n=\sum_{i=0}^{n-1}C_iC_{n-1-i}$$
则卡特兰数的生成函数$C$满足
$$C(x)=C_0+xC^2(x)=1+xC^2(x),C_0=C(0)=1$$
解方程得
$$C(x)=\frac{1-\sqrt{1-4x}}{2x}$$
上面为什么不取正呢？考虑x=0，取负上下为等阶无穷小，值为1；取正上面是2下面是0，无意义。所以只能取负。
$$C(x)=\frac{1}{2x}\left( 1- \sum_{n=0}^{\infty}\binom{\frac{1}{2}}{n} (-4x)^n \right)=-\frac{1}{2}\sum_{n=0}^{\infty} \binom{\frac{1}{2}}{n+1}(-4)^{n+1}x^n $$
$$C_n=-\frac{1}{2}\binom{\frac{1}{2}}{n+1}(-4)^{n+1}=2\frac{\prod_{i=0}^{n}(\frac{1}{2}-i)}{(n+1)!}(-1)^n 2^{2n}$$
$$=\frac{(2n-1)!!}{(n+1)!}2^n=\frac{(2n)!}{n!n!(n+1)}=\frac{1}{n+1}\binom{2n}{n}$$
# 分析
记$h_n$表示这$C_n$个二叉树的叶子数目之和，有$h_0=0,h_1=1$

对于$n\geq 2$，枚举根的左儿子大小并由对称性，有
$$h_n=2\sum_{i=0}^{n-1}h_iC_{n-1-i}$$
$$h(x)-h_0-h_1x=2xh(x)C(x)$$
$$h(x)=2xh(x)C(x)+x$$
根据$C(x)=\frac{1-\sqrt{1-4x}}{2x}$，解得
$$h(x)=\frac{x}{\sqrt{1-4x}}$$
$$h(x)=x\sum_{k=0}^{\infty}\binom{-\frac{1}{2}}{k}(-4x)^k$$
$$h_n=\binom{-\frac{1}{2}}{n-1}(-1)^{n-1}2^{2(n-1)}=\frac{\prod_{i=0}^{n-2}(-\frac{1}{2}-i)}{(n-1)!}(-1)^{n-1}2^{2(n-1)}$$
$$=\frac{(2n-3)!!}{(n-1)!}2^{n-1}=\frac{(2n-2)!}{(n-1)!(n-1)!}=\binom{2n-2}{n-1}$$
那么期望值为
$$\frac{h_n}{C_n}=\frac{n(n+1)}{2(2n-1)}$$
# 代码
这就是一道良心题该有的代码量，如果式子推出来还是得用多项式的算法那就是一道毒瘤题。
```cpp
#include<cstdio>
int main()
{
    double n;
    scanf("%lf",&n);
    printf("%.9lf",n*(n+1)/2/(2*n-1));
    return 0;
}

```

---

## 作者：wgyhm (赞：5)

## 解题思路

### 我们不妨先 ~~打表~~ 画图找规律


|    节点数（n)     |  0   |  1   |  2   |  3   |  4   |
| :---------------: | :--: | :--: | :--: | :--: | :--: |
|  **情况数（F)**   |  1   |  1   |  2   |  5   |  14  |
| **叶子节点数(G)** |  ?   |  1   |  2   |  6   |  20  |

### 不难发现，Gn =n*Fn-1

### 也不难发现 F是卡特兰数（Catalan),其通项公式为（

$$
\frac{(2n)!}{n!(n+1)!}
$$



## 期望值

$$
ans=\frac{G~n~}{F~n~}
   =\frac{\frac{(2n-2)!n}{(n!(n-1)!}}{\frac{(2n)!}{n!(n+1)!}}
   =\frac{n(n+1)}{2(2n-1)}
$$

##### 化简过程请自行草稿本计算



#### 代码如下

```c++
#include<cstdio>
using namespace std;
long double n;
int main()
{
	scanf("%Lf",&n);
	printf("%.9Lf",n/(4*n-2)*(n+1));
}
```



##### 我还是只 初一 蒟蒻

---

## 作者：Nero_Claudius (赞：4)

这道题。。。好像是第一道我自己切出来的黑题。。。

先说一句，牛顿二项式蒟蒻并不会，可以说是直接套结论。

求诸位老爷轻喷。

------------

这道题用**卡特兰数**搞。

卡特兰数这玩意从普及组初赛一路考到省选，十分有用。

如果不清楚这个概念的话可以看一下[这里](https://www.cnblogs.com/v-vip/p/8721098.html)。

卡特兰数是有两种计算方法：

1） 用递推算。

2） 用排列组合。

用它解题的流程一般是先说明所求的问题可以归到第一类中，然后再用第二类来计算具体的值。

像[这道题](https://www.luogu.org/problemnew/show/P1044)就可以用卡特兰数水过。

------------

我们假设$f_i$表示节点数为i的二叉树有多少种。

那么可以发现存在这样的关系：$f_i=\sum_{k=1}^{i-1}f_{k}f_{i-k-1}$。

这个东西满足卡特兰数的第一类表示方法。

所以运用第二类表示方法就可以得到$f_i=\frac{1}{n+1}C^n_{2n}$。

现在我们用$h_i$表示节点数为i的二叉树的叶子节点数量。

那根据$f_i$的值我们就可以得出递推式：$h_i=2\sum_{k=0}^{i-1}h_kf_{i-k-1}$

也就是$h_i=C^{i-1}_{2i-2}$

那么最终的答案就是$\frac{h_i}{f_i}=\frac{C^{i-1}_{2i-2}}{\frac{1}{n+1}C^n_{2n}}=\frac{n(n+1)}{2(2n-1)}$。

代码：

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#define qwq int
#define QAQ double
#define re register
using namespace std;
namespace Solve{
	inline void read(qwq &x){
		x=0;qwq f=1;char c=getchar();
		for(;c<'0'||c>'9';c=getchar())if(c=='-')f=-1;
		for(;c>='0'&&c<='9';c=getchar())x=x*10+c-'0';
		x*=f;
	}
	qwq n;
	QAQ ans;
	inline void solve(){
		read(n);
		ans=(QAQ)n*(QAQ)(n+1)/(QAQ)(2*n-1)/2;
		printf("%.9lf",ans);
	}
}
using namespace Solve;
qwq main(){
	solve();
}


```

---

## 作者：gaozitao1 (赞：3)

# P3978 [TJOI2015]概率论 题解
题目大意：求 $n$ 个点的有根二叉树的叶子结点的期望数。
## 0 前言（心路历程）~~可以跳过~~
一看题目，输入一个数，输出一个数，打表题！！！~~（喜得 30 分！！！）~~

之后将表中的小数化成分数，发现分母是卡特兰数，第 $i$ 个分子等于第 $i-1$ 个分母的 $i$ 倍，之后退出来一个式子 $\cdots \cdots$ ~~（AC紫题！！！）~~
## 1 正文
如果用 $a_i$ 表示 $i$ 个结点的不同有根二叉树的个数，用 $b_i$ 表示 $i$ 个点的所有二叉树的叶子结点的和，那么答案~~显然~~就是 $\frac{b_n}{a_n}$ 。
## 2 求 $a_i$ 。

~~显然~~ $a_1=1$ 。

当 $i=2$ 时，添加了一个点，这个点可以

- 在 $1$ 的左子树中，有 $a_1$ 种方案；

- 在 $1$ 的右子树中，有 $a_1$ 种方案；

所以 $a_2=2=a_1+a_1$ 。

当 $i=3$ 时，添加了两个点，这两个点可以

- 在 $1$ 的左子树中，有 $a_2$ 种方案；

- 一个在 $1$ 的左子树中，一个在 $1$ 的右子树中，有 $a_1\times a_1$ 种方案；

- 在 $1$ 的右子树中，有 $a_2$ 种方案；

所以 $a_3=5=a_2+a_1\times a_1+a_2$ 。

当 $i=4$ 时，添加了三个点，这三个点可以

- 在 $1$ 的左子树中，有 $a_3$ 种方案；

- 两个在 $1$ 的左子树中，一个在 $1$ 的右子树中，有 $a_2\times a_1$ 种方案；

- 一个在 $1$ 的左子树中，两个在 $1$ 的右子树中，有 $a_1\times a_2$ 种方案；

- 在 $1$ 的右子树中，有 $a_3$ 种方案；

所以 $a_4=14=a_3+a_2\times a_1+a_1\times a_2+a_3$ 。

如果设 $a_0=1$，那么上面是个式子可以变成：

 $a_1=a_0\times a_0$ 。

 $a_2=a_0\times a_1+a_1\times a_0$ 。

 $a_3=a_0\times a_2+a_1\times a_1+a_2\times a_0$ 。

 $a_4=a_0\times a_3+a_2\times a_1+a_1\times a_2+a_3\times a_0$ 。

 那么 $a_n=a_0\times a_{n-1}+a_1\times a_{n-2}+……+a_{n-1}\times a_0$ 。

这个数列就是经典的卡特兰数，通项公式为 $a_n=\frac{\left(2n\right)!}{n!\left(n+1\right)!}$ 。
## 3 求 $b_i$
### part 1
一个 $i-1$ 个结点的数有 $i-2$ 条边，结点度数的和为 $2\left(i-2\right)$ 。

添加一个叶子之后原来 $i-1$ 个结点的度数和会加一。

而这$n-1$ 个结点，根结点度数最大为 $2$ ，其他结点的度数最大为 $3$ (一个父结点两个儿子结点），所以这 $i-1$ 个结点度数和最大为 $3\left(i-2\right)+2$ 。

度数和最大为 $3\left(i-2\right)+2$ ，当前度数为 $2\left(i-2\right)$ ，添加一个叶子度数加一，那么一个 $i-1$ 个结点的二叉树可以添加 $3\left(i-2\right)+2-2\left(i-2\right)=i$ 个叶子。

而 $i-1$ 个结点的二叉树有 $a_{i-1}$ 个，每个二叉树可以添加 $i$ 个叶子，所以总共可以添加 $a_{i-1}\times i$ 个叶子。
### part 2
一个有 $i$ 个结点的二叉树，每删去一个叶子结点，就产生了一个 $i-1$ 个结点的二叉树，而因为 $i$ 个结点的二叉树总共有 $b_i$ 个结点，所以可以产生 $b_i$ 个 $i-1$ 个结点的二叉树。
### part 1+2
会发现，将 $i-1$ 个结点的二叉树增加一个叶子形成 $i$ 个结点的二叉树，与将 $i$ 个结点的二叉树删去一个叶子形成一个 $i-1$ 个结点的二叉树是互逆（ ~~我语文不太好，反正是这个意思~~ ）的，所以 **part 1** 和 **part 2** 是互逆的，这样就得到了 $b_i=a_{i-1}\times i$ 。
## 4 求解
这样，我们得到了 $a_i$ 和 $b_i$ ，开始求解。

$$
\frac{b_n}{a_n}=\frac{a_{n-1}\times n}{a_n}=\frac{\frac{\left(2n-2\right)!}{n!\left(n-1\right)!}\times n}{\frac{\left(2n\right)!}{n!\left(n+1\right)!}}=\frac{\frac{\left(2n-2\right)!}{\left(n-1\right)!}\times n}{\frac{\left(2n\right)!}{\left(n+1\right)!}}=\frac{\left(2n-2\right)!\left(n+1\right)!n}{\left(2n\right)!\left(n-1\right)!}=\frac{n^2\left(n+1\right)}{2n\times \left(2n-1\right)}=\frac{n\left(n+1\right)}{2\left(2n-1\right)}
$$

## 5 代码
注意 $1$ ：题目要求误差不超过 $10^{-9}$ ，所以为了正确性，尽量输出至少九位小数。

注意 $2$ ：整数除整数结果是整数，所以 $n$ 开 double 或乘上 $1.0$ 。

注意 $3$ ：虽然 $n$ 是 int 范围内的，但是计算分母时会超出 int 范围，所以 $n$ 开 long long 或乘上 1ll 或 2ll

代码：
```cpp
#include<cstdio>
#include<iostream>
int main()
{
	register int n;
	scanf("%d",&n);
	printf("%.9lf",1.0*n*(n+1)/(2ll*(2*n-1)));
	return 0;
}
```

---

## 作者：nofind (赞：3)

## [题意](https://www.luogu.com.cn/problem/P3978)

设$f_i$表示$i$个点的有根二叉树个数，$g_i$表示所有$i$个点有根二叉树的叶子个数和，答案即为$\frac{g_n}{f_n}$。

学过卡特兰数的都知道$f_i$就是卡特兰数，其通项为$\frac{C_{2n}^n}{n+1}$。

对于$g_i$，有结论：$g_n=nf_{n-1}$，证明方法有生成函数和不用生成函数的方法，下面是不用生成函数的方法：  
对于所有节点数为$n$的有根二叉树，假设其有$k$个叶子。对于每个叶子，我们将其去掉后都会产生一颗$n-1$个节点的有根二叉树，我们使这棵树的标记$+1$，最后查询所有$n-1$个节点的二叉树的标记和即为答案。

下面考虑每个$n-1$个节点的有根二叉树会被标记几次，答案是恰好$n$次。  
证明：  
对于一颗$n$个节点的有根二叉树，其能添加的叶子节点分为两种：  
1.叶子节点的左右儿子。  
2.左右儿子缺一个的点，将缺的那个补上。  
从度数角度考虑，对于原来的$n$个节点，度数和为$2(n-1)$（每条边对度数和的贡献为$2$），而补一个叶子节点度数和（原来$n$个节点的）会增加$1$，补完后除了根节点，剩下的$n-1$个节点度数都为$3$（一个父亲两个儿子），总度数为$3n-1$，于是可以补的叶子结点个数为$3n-1-2(n-1)=n+1$。

之后代入原式算一算就可以得到一个式子，$O(1)$求解即可。

code:
```
#include<bits/stdc++.h>
using namespace std;
double n;
int main()
{
	cin>>n;
	printf("%.12lf",n*(n+1)/(2*(2*n-1)));
	return 0;
}
```


---

## 作者：Inker (赞：2)

提供一个70分dp的做法

f[i]表示i个节点不同构的树的个数,f[i]是卡特兰数列

g[i]表示i个节点所有不同构二叉树的叶子节点总数可以dp求

dp[i][k]表示i个点，有k个叶子的方案数，（其中k<=i/2上取整）

枚举左儿子有j个点，再枚举左儿子有t个叶子节点

于是dp[ i ][ k ] += dp[ j ][ t ] * dp[ i - j - 1 ][ k - t ];

于是g[ i ] = dp[ i ][ k ] * k ; ( k 从 1 ~ n/2 上取整 ）

复杂度是n^4的.

满分可以打表找规律或生成函数

```cpp
#include<cstdio>
const int N=300;
double dp[N][N],comb[N][N];
int n;
int main()
{
    scanf("%d",&n);
    dp[0][0]=1;dp[1][1]=1;
    for(int i=2;i<=n;i++){
        for(int k=1;k<=(i+1)/2;k++){
            for(int j=0;j<i;j++){
                for(int t=0;t<=k;t++){
                    dp[i][k]+=dp[j][t]*dp[i-1-j][k-t];
                }
            }
        }
    }
    for(int i=0;i<=n*2;i++){
        for(int j=0;j<=i;j++){
            if(i==j||j==0)comb[i][j]=1;
            else comb[i][j]=comb[i-1][j]+comb[i-1][j-1];
        }
    }
    double res=0;
    for(int i=1;i<=(n+1)/2;i++)
    {
        res=res+dp[n][i]*i;
    }
    double tmp=comb[2*n][n]-comb[2*n][n-1];
    printf("%.10lf\n",res/tmp);
    return 0;
}
```

---

## 作者：Mars_Dingdang (赞：1)

这题居然没有 **python** 的题解？其实这种题 **python** 代码会短很多。

~~第一篇 python 题解，求过qaq~~
## 题目大意
对于一棵随机生成的 $n$ 个结点的有根二叉树（所有互相不同构的形态等概率出现），求它的叶子节点数的期望是多少。
## 大体思路
本题显然是卡特兰数的题目，递推式：

令 $f_n$ 表示 $n$ 个点的二叉树个数；$g_n$ 表示 $n$ 个点的所有 $f_n$ 棵二叉树的叶节点总数。

首先打表找一下规律：

| $n$ | $g_n$ | $f_n$ |
| :----------: | :----------: | :----------: |
| $1$ | $1$ | $1$ |
| $2$ | $2$ | $2$|
| $3$ | $6$ | $5$ |
| $4$ | $20$ | $14$ |
| $5$ | $70$ | $42$ |


通过找规律的方式可以发现：
$$f_1=g_1=1$$
$$g_n=n\cdot f_{n-1}$$


根据卡特兰数递推式

![摘自百度百科](https://cdn.luogu.com.cn/upload/image_hosting/tiqee1xv.png)


$$ f_n=\dfrac{{C_{2n}^n}}{n+1}=\sum_{i=1}^{n-1}f_i\cdot f_{n-i-1}$$
可得
$$\dfrac{g_n}{f_n}=\dfrac{nf_{n-1}}{f_n}=\dfrac{n(n+1)}{4n-2}$$
## 证明过程
此处借用 @\_rqy 大神的证明：

- 对于每棵 $n$ 个点的二叉树，如果里面有 $k$ 个叶节点，那么我们分别把这 $k$ 个叶子删去会得到 $k$ 棵 $n-1$ 个点的二叉树；

- 而每棵 $n-1$ 个点的二叉树恰好有 $n$ 个位置可以悬挂一个新的叶子，所以每棵 $n−1$ 个点的二叉树被得到了 $n$ 次；

- 综上，我们即可得出结论：所有 $n$ 个点的二叉树的叶子个数和等于 $n-1$ 个点的二叉树个数 $\times n$。

## 完整代码
```python
n=float(input())
	#输入到浮点数类型变量 n 中
print(round(float(n*(n+1)/(4*n-2)),10))
	#代入公式输出
```
## 其他
注意题目中要求误差小于 $10^{-9}$，因此保留十位小数， **python** 中自带控制小数位数的东东，且自动四舍五入，代码如下：

```python
a=3.141592653589793
b=round(a,10)
print(b) #输出3.1415926536
```
更多 python 知识见 @LucasXu80 大神的[ 博客文章](https://www.luogu.com.cn/blog/HuayuLucas/python-kuai-su-shang-shou)。

---

## 作者：stry (赞：1)

~~这题真的是黑题吗~~

其实这题我们只需

对于每棵nn个点的二叉树，如果里面有kk个叶节点，那么我们分别把这kk个叶子删去会得到kk棵n-1n−1个点的二叉树； 而每棵n-1n−1个点的二叉树恰好有nn个位置可以悬挂一个新的叶子，所以每棵n-1n−1个点的二叉树被得到了nn次； 综上，我们即可得出结论：所有nn个点的二叉树的叶子个数和等于n-1n−1个点的二叉树个数\times n×n。

我们只需要找出公式：

n(n+1)/(2(2*n-1))
就行了

不废话，上程序

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<string>
#include<cstring>
#include<algorithm>
using namespace std;
double n;
int main()
{
    cin>>n;
    printf("%.9lf",n*(n+1)/(2*(2*n-1)));
    return 0;
}
```
别抄袭哟，看完看懂后再打代码

虽然我认为这种黑题应该没人抄吧

---

## 作者：⚡进击_蒟蒻⚡ (赞：1)


这篇题解，似乎，和某位大佬的代码相似。

回归正题。

这题要用卡特兰数来做。

卡特兰数是有两种计算方法：

1：用递推算。

2：用排列组合。

用它解题的流程一般是先说明所求的问题可以归到第一类中

然后再用第二类来计算具体的值。

# 上代码：

```cpp
#include<cstdio>
#include<iostream>
#include<cmath>
using namespace std;
int main()
{
    double n;
    cin>>n;
    printf("%.9lf",(n*(n+1)/(2*(2*n-1))));
    return 0;
}
```


---


# ZHY 的矩阵

## 题目描述

ZHY 的记忆中有一个 $k$ 行 $n$ 列的 01 矩阵 $A$，满足下列条件：

- 每一列都至多有一个 $1$。
- 每行相邻的两个 $1$ 所在的两列夹出的 $k$ 行的矩形（包括这两列）内至少有三个 $1$。

突然，ZHY 想起来了矩阵中 $x$ 个位置的值。请你计算有多少种填充 $A$ 的剩余位置的方案，使得 $A$ 满足条件。

----

形式化的讲，设 $A$ 第 $i$ 行第 $j$ 列的数为 $A_{i,j}$，则 $A$ 满足下列条件：

- 对于 $\forall i \in [1,k],\kern{2pt}j \in [1,n]$，$A_{i,j} \in \{0,1\}$。

- 对于 $\forall i \in [1,n]$，$\displaystyle\sum_{j=1}^{k} A_{j,i}\le 1$。

- 对于 $\forall i,j \in [1,n],\kern{2pt}p \in [1,k]$ 且 $j>i$，若有 $A_{p,i}=A_{p,j}=1,\displaystyle \sum_{x=i}^{j}A_{p,x}=2$，则有 $\Big(\displaystyle \sum_{x=1}^{k} \sum_{y=i}^{j} A_{x,y}\Big) \ge 3$。

- 对于 $\forall i\in[1,x]$，有 $A_{a_{i},b_{i}}=c_{i}$。

由于答案可能很大，你只需告诉 ZHY 答案对 $10^{9}+7$ 取模的结果。定义两个矩阵 $A,A'$ 不同，当且仅当存在 $i\in[1,k]$，$j\in[1,n]$ 满足 $A_{i,j}\ne A'_{i,j}$。

## 说明/提示

**样例解释**

满足条件的矩阵只有以下 $2$ 种：

$$
\begin{Bmatrix}
1&0&0\\
0&0&0
\end{Bmatrix}
$$

$$
\begin{Bmatrix}
1&0&0\\
0&0&1
\end{Bmatrix}
$$

----


**本题采用捆绑测试。**

| $\mathrm{Subtask} \kern{2pt} \mathrm{id}$ | $n$ | $x$ | 特殊性质 | 分值 |
| :-----: | :-----: | :-----: | :-----: | :-----: |
| $0$ | $\le 8$ | $\le 8$ | $k=2$ | $12$ |
| $1$ | $\le 2 \times 10^{5}$ | $\le 2\times 10^{5}$ | 无 | $26$ |
| $2$ | $\le 10^{9}$ | $=0$ | 无 | $23$ |
| $3$ | $\le 10^{9}$ | $\le 2\times 10^{5}$ | $c_{i}=1$ | $15$ |
| $4$ | $\le 10^{9}$ | $\le 2\times 10^{5}$ | 无 | $24$ |

对于所有数据，$1 \le n \le 10^{9}$，$0 \le x \le 2\times 10^{5}$，$2\le k \le 100$。$1 \le a_{i} \le k$，$1 \le b_{i} \le n$，$c_{i} \in \{0,1\}$。保证不存在一对 $i,j \in [1,x],\kern{2pt}i\neq j$，满足 $a_{i}=a_{j},\kern{2pt}b_{i}=b_{j}$。

## 样例 #1

### 输入

```
3 2 2
1 1 1
2 2 0
```

### 输出

```
2
```

# 题解

## 作者：Raymondzll (赞：6)

## P9490 ZHY 的矩阵

### 前言

一道 DP 好题。

很多人（包括出题人）都反映此题题面过于抽象。我自己在做题时把题面翻译了一下。此部分不是太重要，能读懂即可。

考虑将二维的 $0,1$ 矩阵转化为一维，$a_i\in[1,k]$ 表示原矩阵中这一列的 $1$ 位于第 $a_i$ 行。若 $a_i=0$ 表示这一列没有 $0$。

则题目限制转化为：若 $a_i=a_j\ (i\neq j)$，则 $a_k \ (k\in (i,j))$ 不能全为 $0$。

题目条件转化为：规定 $a_i=x$ 或 $a_i\neq x$，那么等于条件只能有一种，不等条件可以有多种。我们称有这两种条件的点为断点。

下面进入正题。

### 解题思路

由出题人题解我们基本可以看到有 $n\leq2\times10^5$ 推到 $n\leq2\times10^9$ 的一个过程，故在此略过部分分。

令 $f_{i,j}$ 代表直至第 $i$ 个断点（第 $0$ 个为 $0$，最后一个断点补上 $n$），最后一个非零 $a_i$ 为 $j$ 的方案数。若之前全都是 $0$，则 $j=0$。

先不考虑断点等于某数或不等于某数的限制，从上一个断点**逐位递推**的过程是怎样的呢？

**记 $s_i$ 为 $\sum\limits_{j=1}^kf_{i,j}$。**

$\begin{array}{|c|c|c|}\\f_{i-1,0}&f_{i-1,0}&f_{i-1,0}\\f_{i-1,1}&f_{i-1,0}+s_{i-1}&3\times(f_{i-1,0}+s_{i-1})+f_{i-1,0}\\f_{i-1,2}&f_{i-1,0}+s_{i-1}&3\times(f_{i-1,0}+s_{i-1})+f_{i-1,0}\\f_{i-1,3}&f_{i-1,0}+s_{i-1}&3\times(f_{i-1,0}+s_{i-1})+f_{i-1,0}\end{array}$

好。先解释一下怎么推出来的。如果这一列的数（$a_i$）我们定为 $p$，那从上一位末位非 $p$ 的 $dp$ 方案可以通过这个加 $p$ 操作转移成这一位末位为 $p$ 的方案。

如果上一位末位是 $p$ 呢？那显然这一位不能加 $p$ 了（否则不符合前言中的题目限制）。但我们可以加 $0$ 啊！所谓加 $0$，就是在原矩阵中这一列为空，一个 $1$ 都没有，表现在 $a_i$ 中就是 $a_i=0$。那上一位末位是 $p$ 就可以转移到这一位末位是 $p$。

我们发现了什么？这一位末位是 $p$ 可以由上一位任何末位转移而来！因此上面的表格中，每一列的末位非 $0$ 都等于左边一列所有数的和。末位为 $0$ 的方案数一直没变，显然。不理解可评论或私信。

有了这些基础我们就以逐断点递推很近了，但我们先要解决一下式子的问题。参照上面的表格，表格第二列的值为 $f_{i-1,0}+s_{i-1}$，第三列若把 $3$ 扩展为 $k$，则为 $k\times(f_{i-1,0}+s_{i-1})+f_{i-1,0}$，再后面呢？$k(k(f_{i-1,0}+s_{i-1})+f_{i-1,0})+f_{i-1,0}=(k^2+k+1)f_{i-1,0}+k^2s_{i-1}$。

通式为 $\frac{k^d-1}{k-1}f_{i-1,0}+k^{d-1}s_{i-1}$。记这东西叫 $g(d,i-1)$。

准备工作均已完成，设 $d$ 为断点 $i$ 和 $i-1$ 在原矩阵上列数的差。那 $f_{i,p}$ 是不是就是 $g(d,i-1)$ 呢？当然不是。现在我们可以关注断点 $i$ 是等于型还是不等型。

等于：

设规定了 $a_i=p$。那么上一位末位（注意是位不是断点）为 $p$ 的方案是不能转移到这一位的。有人会问前面按位推的时候为什么可以？那是加 $0$。这里强制加 $p$ 就不行了。

因此 $f_{i,p}=g(d-1,i-1)\times(k-1)+f_{i-1,0}=k^{d-1}f_{i-1,0}+(k-1)k^{d-2}s_{i-1}$。

对于 $j\neq p$，$f_{i,j}=0$。

不等于：

设规定了 $a_i\neq p1,p2,...$，若 $j\neq p1,p2,...$ 则 $f_{i,j}=g(d,i-1)$。如果 $j=p1,p2,...$，$f_{i,j}$ 只能从上一位末位为 $p1$ 转移而来，则 $f_{i,j}=g(d-1,i-1)$。

到这里重点的转移已经结束了。如果 $d=1$ 那么转移会特殊一点，直接看代码即可。

```cpp
const ll P=1000000007;
ll n,k,x,X;
ll f[200010][110],sum[200010];
int a[200010],b[200010],c[200010];
int l[200010],flag[200010];
void init(){
	cin>>n>>k>>x;
	for(int i=1;i<=x;i++){
		cin>>a[i]>>b[i]>>c[i];
		l[i]=b[i];
	}
	sort(l+1,l+x+1);
	X=unique(l+1,l+x+1)-l-1;//离散化
	for(int i=1;i<=x;i++){
		b[i]=lower_bound(l+1,l+X+1,b[i])-l;
		if(c[i]==1){
			if(++flag[b[i]]>1){cout<<0;exit(0);}
			for(int j=0;j<=k;j++)if(j!=a[i])f[b[i]][j]=-1;
		}else f[b[i]][a[i]]=-1;
	}
}
ll ksm(ll a,ll b){
	ll res=1;
	while(b){if(b&1)(res*=a)%=P;(a*=a)%=P;b>>=1;}
	return res;
}
ll invk;
int main(){
	init();invk=ksm(k-1,P-2);
	f[0][0]=1;
	if(l[X]!=n)l[++X]=n;
	for(int i=1;i<=X;i++){
		int d=l[i]-l[i-1];
		if(flag[i]){
			f[i][0]=0;
			for(int j=1;j<=k;j++)
				if(f[i][j]==0){
					if(d==1)f[i][j]=sum[i]=(f[i-1][0]+sum[i-1]-f[i-1][j])%P;
					else f[i][j]=sum[i]=(ksm(k,d-1)*f[i-1][0]%P+(k-1)*ksm(k,d-2)%P*sum[i-1]%P)%P;
				}else{
					f[i][j]=0;
				}
		}else{
			f[i][0]=f[i-1][0];
			for(int j=1;j<=k;j++)
				if(f[i][j]==0){
					if(d==1)f[i][j]=(f[i-1][0]+sum[i-1])%P;
					else f[i][j]=((ksm(k,d)-1)*invk%P*f[i-1][0]%P+ksm(k,d-1)*sum[i-1]%P)%P;
					(sum[i]+=f[i][j])%=P;
				}else{
					if(d==1)f[i][j]=f[i-1][j];
					else f[i][j]=((ksm(k,d-1)-1)*invk%P*f[i-1][0]%P+ksm(k,d-2)*sum[i-1]%P)%P;
					(sum[i]+=f[i][j])%=P;
				}
		}
	}
	cout<<(sum[X]+f[X][0]+P)%P;
	return 0;
}
```

---

## 作者：0000pnc (赞：1)

前言：本题原名叫 k sequences，所以本文中提到的**位**都表示矩阵中的一整列，**序列**指的都是矩阵中的一整行。

另外，这篇题解可能过于抽象，因为这些式子确实不太好表达出来（？所以有更好的表述方法欢迎踊跃投题解（

----

考虑如何解决 $n\le 2\times 10^{5}$ 的数据。  

设 $f_{i,j}$ 表示前 $i$ 位中最后出现的 $1$ 属于第 $j$ 个序列的方案数，$g_{i}$ 表示是否存在前 $i$ 位全部为 $0$ 的情况（$g_{i}\in \{0,1\}$）。分两种情况讨论。

* 第 $i$ 位中已经有数被确定为 $1$。设这个 $1$ 属于第 $p$ 个序列。  

$g_{i}$ 显然为 $0$。考虑 $f$ 怎样转移。  

注意到只有 $f_{i,p}$ 能被更新，而 $f_{i,p}$ 的转移易求。于是得到转移方程：

$$
\begin{gathered}
\forall a\in[1,k].a\neq p,\kern{1pt}f_{i,a}=0\\
f_{i,p}=g_{i-1}+\sum_{1 \le a \le k,\kern{1pt}a\neq p}f_{i-1,a}\\
g_{i}=0
\end{gathered}
$$

* 第 $i$ 位中没有数被确定为 $1$。  

显然 $g_{i}=g_{i-1}$。同样考虑 $f$ 怎样转移。  

如果第 $p$ 个序列的第 $i$ 位为 $0$，那么 $f_{i,p}=f_{i-1,p}$。

如果没有被确定，那么如果这个位置为 $1$，则其对 $f_{i,p}$ 的贡献为 $g_{i-1}+\displaystyle \sum_{1 \le a \le k,\kern{1pt}a\neq p} f_{i-1,a}$。

整理得到转移方程：

$$
\begin{gathered}
f_{i,p}=g_{i-1}+\sum_{a=1}^{k}f_{i-1,a}\kern{2pt}(A_{p,i} \kern{3pt}\text{is not determined})\\
f_{i,p}=f_{i-1,p}\kern{1.5pt}(\text{otherwise})\\
g_{i}=g_{i-1}
\end{gathered}
$$

于是我们可以用 $\mathcal{O}(nk)$ 的时间完成转移。

----

接下来，考虑正解。

如果在一位上有数已经被钦定，称这个位是“断点”。  
我们注意到被钦定的数有 $x$ 个。那么“断点”的数量就不会超过 $x$（$\le 10^{5}$）。所以可以将 $n$ 个位置在“断点”处进行分段处理。

考虑如何处理一段内的转移。和上述方法类似，设 $f_{i,j}$ 表示前 $i$ **段**中最后出现的 $1$ 属于第 $j$ 个序列的方案数，$g_{i}$ 表示前 $i$ **段**中没有出现 $1$ 的方案数。注意：前 $i$ 段指的是第 $i$ 个断点及其前面的部分。

* 如果段长为 $0$（即两个断点相邻），直接套用上述方法转移即可。

* 否则设段长为 $m$。

**考虑 $f_{z}$ 怎样影响 $f_{z+1}$。**  
借用算法一的思路过程，我们对这一段进行按位递推。  
设 $h_{i,j}$ 表示这一段第 $i$ 位（前面的断点是第 $0$ 位）及其前面出现的最后一个 $1$ 属于第 $j$ 个序列的方案数。

为了方便，只考虑 $h_{0,1}$ 如何影响后续的 $h$ 值。  
这一段的第 $1$ 位如果有 $1$，则它可以属于除第一个序列之外的任意一个序列。故 $h_{0,1}\rightarrow h_{1,p}\kern{3pt}(p\neq 1)$。推广一下，则有 $h_{i,j}\rightarrow h_{i+1,\kern{1pt}p}\kern{3.5pt}(p\neq i)$。  
如果第 $1$ 位没有 $1$，那么最后一个 $1$ 还是属于第一个序列。故 $h_{0,1}\rightarrow h_{1,1}$。推广得 $h_{i,j}\rightarrow h_{i+1,\kern{1pt}j}$。

综上，我们发现 $h_{i,j}\rightarrow h_{i+1,\kern{1pt}p}\kern{3pt}(p \in [1,k])$，这告诉我们 $f_{i}$ 推导出来的方案数在每一位都会乘上一个 $k$，且在一位上所有序列的 $h$ 值都是相等的。（即：给定 $c \in [1,m]$，那么所有的 $h_{i,c}$ 相等）。设 $s=\displaystyle \sum_{p=1}^{k}f_{z,p}$，那么 $h_{i,j}$ 就为 $s\times k^{i-1}$。

$$
\begin{aligned}
&
\end{aligned}
$$

**接下来，讨论 $g_z$ 如何影响 $f_{z+1}$。**

还是一样，设 $h_{i,j}$ 表示这一段第 $i$ 位及其前面的最后一个 $1$ 属于第 $j$ 个序列的方案数。注意由于此时这一段及前面并没有出现过 $1$，所以 $j$ 可以为 $0$，表示的是这一段第 $i$ 位及其前面都没有出现 $1$ 的情况。

根据上述，依然有 $h_{i,j}\rightarrow h_{i+1,\kern{1pt}p}\kern{3pt}(p\in [1,k])$。但是此时多了一个 $h_{p,0}$。考虑 $h_{0,0}$，如果第一位有 $1$，则 $1$ 可在任意位置上，$h_{0,0}\rightarrow h_{1,p}\kern{3pt}(p\in [1,k])$。如果没有，那么 $h_{0,0}\rightarrow h_{1,0}$。整理推广得 $h_{i,0}\rightarrow h_{i+1,\kern{1pt}p}\kern{3pt}(p\in [0,k])$。

注意到 $h_{i,0}$ 始终为 $1$，所以其他的 $h_{i,j}$ 在每位乘 $k$ 的基础上还要 $+1$。枚举前几项：$h_{1,p}=1,\kern{2pt}h_{2,p}=h_{1,p}\times k+1=k+1,\kern{2pt}h_{3,p}=h_{2,p}\times k+1=k^{2}+k+1\cdots$

故 $h_{i,j}=g_{z}\displaystyle \sum_{t=0}^{j-1}k^{t}=g_{z}\cdot\dfrac{k^{i}-1}{k-1}$。

$$
\begin{aligned}
&
\end{aligned}
$$

整理以上两种情况，得 $h_{i,j}=\displaystyle (\sum_{p=1}^{k}f_{z,p})\kern{2pt}\cdot k^{i-1}+g_z\kern{2pt}\cdot \dfrac{k^{i}-1}{k-1}$。

这样，我们就能用 $\mathcal{O}(\log m)$ 的时间复杂度算出 $h_{m}$，然后再进行朴素的按位递推，就能完成从一个断点到下一个断点的转移。总时间复杂度 $\mathcal{O}(x(k+\log n))$。当然用光速幂可以去掉那个 log，但是没有意义。

----

写代码时可能需要处理的细节：  
* 特别注意块长为 $0$ 的情况。
* 如果在同一位有两个或以上钦定的 $1$，是不符合条件的，需要直接输出 `0`。

---


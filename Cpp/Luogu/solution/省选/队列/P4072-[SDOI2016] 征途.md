# [SDOI2016] 征途

## 题目描述

Pine 开始了从 $S$ 地到 $T$ 地的征途。

从 $S$ 地到 $T$ 地的路可以划分成 $n$ 段，相邻两段路的分界点设有休息站。

Pine 计划用 $m$ 天到达 $T$ 地。除第 $m$ 天外，每一天晚上 Pine 都必须在休息站过夜。所以，一段路必须在同一天中走完。

Pine 希望每一天走的路长度尽可能相近，所以他希望每一天走的路的长度的方差尽可能小。

帮助 Pine 求出最小方差是多少。

设方差是 $v$，可以证明，$v\times m^2$ 是一个整数。为了避免精度误差，输出结果时输出 $v\times m^2$。

## 说明/提示

### 数据范围及约定

- 对于 $30\%$ 的数据，$1 \le n \le 10$；
- 对于 $60\%$ 的数据，$1 \le n \le 100$；
- 对于 $100\%$ 的数据，$1 \le n \le 3000$。

保证从 $S$ 到 $T$ 的总路程不超过 $3\times 10^4$。

$2 \leq m \leq n$，每段路的长度为不超过 $3 \times 10^4$ 的**正整数**。

## 样例 #1

### 输入

```
5 2
1 2 5 8 6```

### 输出

```
36```

# 题解

## 作者：Dispwnl (赞：50)

>原先修改的公式还是有误，已修改

求方差……先搞式子

已知：
$s^{2}=\frac {(\overline v-v_1)^{2}+(\overline v-v_2)^{2}+...+(\overline v-v_m)^{2}}{m}$

然后：$s^{2}=\frac {(\frac {\sum_{i=1}^{m}v_i}{m} -v_1)^{2}+(\frac {\sum_{i=1}^{m}v_i}{m} -v_2)^{2}+...+(\frac {\sum_{i=1}^{m}v_i}{m} -v_m)^{2}}{m}$

展开：$s^{2}=\frac {m\times \frac {(\sum_{i=1}^{m}v_i)^{2}}{m^{2}}-2\times\frac {(\sum_{i=1}^{m}v_i)}{m}\times (v_1+v_2+...+v_m)+(v_1^{2}+v_2^{2}+...+v_m^{2})}{m}$

然后可化为：
$s^{2}=\frac {\frac {(\sum_{i=1}^{m}v_i)^{2}}{m}-2\times \frac {(\sum_{i=1}^{m}v_i)^{2}}{m}+(v_1^{2}+v_2^{2}+...+v_m^{2})}{m}$

然后：
$s^{2}=-\frac {(\sum_{i=1}^{m}v_i)^{2}}{m^{2}}+\frac {(v_1^{2}+v_2^{2}+...+v_m^{2})}{m}$

还要$\times m^2$

$s^{2}\times m^{2}=-(\sum_{i=1}^{m}v_i)^{2}+m\times (v_1^{2}+v_2^{2}+...+v_m^{2})$

这样就好了，你会发现式子右边第一项是个定值，而第二项我们可以用前缀和搞搞

用$f_{i,l}$表示前$i$段分为$l$天走的最小平方和（这里也是平方了因为最后处理成方差了QAQ）

即有：$f_{i,l}=min(f_{i,l},f_{j,l-1}+(sum_i-sum_j)^{2})(0\le j<i)$（$m$可以最后乘上）

然后$80$分到手

可以发现这个式子可以用斜率优化搞，即可以这么化：

$f_{i,l}+2\times sum_i\times sum_j=f_{j,l-1}+sum_i^{2}+sum_j^{2}$

然后就是斜率优化套路了

代码：
```
# include<iostream>
# include<cstring>
# include<cstdio>
# define LL long long
using namespace std;
const int MAX=3e3+1;
int n,m;
int qu[MAX];
LL sum[MAX],f[MAX],g[MAX];
int read()
{
    int x=0;
    char ch=getchar();
    for(;!isdigit(ch);ch=getchar());
    for(;isdigit(ch);x=x*10+ch-48,ch=getchar());
    return x;
}
double X(int i)
{
    return sum[i];
}
double Y(int i)
{
    return g[i]+sum[i]*sum[i];
}
double look(int x,int y)
{
    return (Y(x)-Y(y))/(X(x)-X(y));
}
int main()
{
    n=read(),m=read();
    for(int i=1;i<=n;++i)
      sum[i]=sum[i-1]+read(),g[i]=sum[i]*sum[i];
    for(int l=1;l<m;++l)
      {
      	int he=1,ta=1;
      	qu[1]=l;
      	for(int i=l+1;i<=n;++i)
          {
          	while(he<ta&&look(qu[he],qu[he+1])<2*sum[i]) ++he;
          	int tt=qu[he];
          	f[i]=g[tt]+(sum[i]-sum[tt])*(sum[i]-sum[tt]);
          	while(he<ta&&look(qu[ta],qu[ta-1])>look(qu[ta],i)) --ta;
          	qu[++ta]=i;
          }
        for(int i=1;i<=n;i++)
          g[i]=f[i];
      }
    printf("%lld",-sum[n]*sum[n]+m*f[n]);
    return 0;
}
```


---

## 作者：zhoutb2333 (赞：37)

首先将答案化成$\min \{m*\sum x^2 -(\sum x)^2 \}$

发现如果$n$个路段的长度不变的话，$m$越大那么答案越小，因为我可以将任意一天拆成两天，然后$(a+b)^2 > a^2+b^2$

然后再理性地猜它是下凸的~~并不会证明~~，这样就可以上WQS二分了

在这里切线斜率的意义大概是，我每多走一天就要多付出$slope$的代价，然后就可以斜率优化dp了。复杂度$O(Nlog(\sum x))$，0ms快的飞起。

``` cpp
#include<bits/stdc++.h>
#define maxn 3010
#define ll long long
using namespace std;

int g[maxn],q[maxn],L,R,n,m;
ll sum[maxn],f[maxn];
const ll Inf=1LL<<40,eps=1e-9;
inline ll sqr(ll x){
	return x*x;
}
inline double slp(int x,int y){
	return (double)(f[y]-f[x]+sqr(sum[y])-sqr(sum[x]))/(double)(sum[y]-sum[x]);
}
void solve(ll s){
	q[L=R=0]=0;
	for(int i=1;i<=n;i++){
		while(R-L>0&&slp(q[L],q[L+1])<2.0*sum[i]+eps)
			L++;
		f[i]=f[q[L]]+s+sqr(sum[i]-sum[q[L]]);
		g[i]=g[q[L]]+1;
		while(R-L>0&&slp(q[R-1],q[R])>slp(q[R],i)-eps)
			R--;
		q[++R]=i;
	}
} 
int main(){
	int x;
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
		scanf("%d",&x),sum[i]=sum[i-1]+x;
	ll l=0,r=sqr(sum[n]),ans;
	while(l<r){
		ll mid=l+r>>1;
		solve(mid);
		if(g[n]>m)
			l=mid+1;
		else
			ans=m*(f[n]-mid*m)-sqr(sum[n]),r=mid;
	}
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：aiyougege (赞：23)

### 征途
#### Solution
　　用$v_i$表示将所有道路划分出的第$\text{i}$段.首先需要化简**方差$s^2$**这个式子
那么对于$v$前$\text{k}$项的方差
$$s^2=\frac{1}{k}\sum_{i=1}^k(\bar{v}-v_i)^2$$
$$=-\frac{1}{k^2}(\sum\limits_{i=1}^kv_i)^2+\frac{1}{k}\sum_{i=1}^kv_i^2$$

对于整个数列$v$的方差
$$s^2=\frac{1}{m^2}\sum_{i=1}^mv_i^2-\frac{1}{m}(\sum\limits_{i=1}^mv_i)^2$$
因此答案就是最小化
$$s^2m^2=m\sum_{i=1}^mv_i^2-(\sum\limits_{i=1}^mv_i)^2$$
　　我们需要做的就是划分出$v_1,v_2,\cdots ,v_m$.从而产生最小的$s^2m^2$.而且可以发现最后一项, $(\sum\limits_{i=1}^kv_i)^2$为常数, 对结果没有影响, 对结果有影响的只有$\sum\limits_{i=1}^kv_i^2$这一项, 因此只要保证它最小就能保证答案最小.
　　用$f(k,j)$表示划分出$v_1,v_2,\cdots ,v_k$用了经过了前$\text{j}$条道路, 最小的$\sum\limits_{i=1}^kv_i^2$, 用$d_i$表示道路长度, 转移方程为:
　　$$f(k,j)=\min{f(k-1,l)+(\sum_{i=l+1}^j}d_i)^2$$
　　那么只需要递推出$f(m,n)$, 再加上$(\sum\limits_{i=1}^mv_i)^2$为答案.这样为$\Theta(n^3)$, 能得到$\text{80\%}$的分数.
#### 斜率优化
如果用$s_j$表示$\sum\limits_{i=1}^jd_i$, 若从j转移比k更好, 则:
$$f(u,j)+(\sum_{i=j+1}^pd_i)^2\le f(u,k)+(\sum_{i=k+1}^pd_i)^2 \Leftrightarrow \frac{f(u,j)-f(u,k)+s_j^2-s_k^2}{s_j-s_k}\le 2s_i$$
这就是那个斜率优化的常见式子.
#### 滚动数组
　　完全可以再将二维压成一维, 虽然没有必要.
[attack](http://www.cnblogs.com/zwfymqz/p/8711337.html)这个dl写了可以借鉴一下.
#### Code
80分未加斜率优化
```cpp
#include<cstring>
#include<cstdio>
#define N 3005

int f[N][N];
int sl[N];
int l[N];
int n,m;

int min(int a,int b){
    return a<b?a:b;
}

int S(int l,int r){
    return (sl[r]-sl[l-1])*(sl[r]-sl[l-1]);
}

int main(){
    scanf("%d%d",&n,&m);
    memset(f,0x3f,sizeof(f));
    for(int i=1;i<=n;++i)scanf("%d",&l[i]);
    for(int i=1;i<=n;++i)sl[i]=sl[i-1]+l[i];
    f[0][0]=0;
    for(int i=1;i<=m;++i)
        for(int j=1;j<=n;++j)
            for(int k=0;k<j;++k)
                f[i][j]=min(f[i-1][k]+S(k+1,j),f[i][j]);
    printf("%d",m*f[m][n]-sl[n]*sl[n]);
    return 0;
}
```
加斜率优化, 只是因为没有加double和括号被卡了老半天.
```cpp
#include<cstring>
#include<cstdio>
#include<queue>
#define N 3005
#define int long long

int f[N][N];
int que[N];
int sl[N];
int l[N];
int n,m;

int min(int a,int b){return a<b?a:b;}
double slope(int u,int j,int k){return double(f[u][j]-f[u][k]+sl[j]*sl[j]-sl[k]*sl[k])/(double)(sl[j]-sl[k]);}

main(){
	scanf("%lld%lld",&n,&m);
	memset(f,0x3f,sizeof(f));
	for(int i=1;i<=n;++i)scanf("%lld",&l[i]);
	for(int i=1;i<=n;++i)sl[i]=sl[i-1]+l[i];
	int h,t;
	f[0][0]=0;
	for(int i=1;i<=n;i++)f[1][i]=sl[i]*sl[i];
    for(int p=2;p<=m;p++){
        h=1,t=0;
        for(int i=1;i<=n;i++) { 
            while(h<t&&slope(p-1,que[h],que[h+1])<2*sl[i])h++;
            int j=que[h];
            f[p][i]=f[p-1][j]+(sl[j]-sl[i])*(sl[j]-sl[i]); 
            while(h<t&&slope(p-1,que[t-1],que[t])>slope(p-1,que[t],i))t--;
            que[++t]=i;
        }
    }
    int ans=m*f[m][n]-sl[n]*sl[n];
    printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：FlashHu (赞：15)

一开始肯定要把题目要求的式子给写出来

我们知道方差的公式$s^2=\frac{\sum\limits_{i=1}^{m}(x_i-\overline x)^2}{m}$

题目要乘$m^2$再输出，于是

$m^2s^2=m\sum\limits_{i=1}^{m}(x_i-\overline x)^2$

$=m(\sum\limits_{i=1}^{m}x_i^2-2\overline{x}\sum\limits_{i=1}^{m}x_i+m\overline{x}^2)$

$=m\sum\limits_{i=1}^{m}x_i^2-(\sum\limits_{i=1}^{m}x_i)^2$

于是只要最小化$\sum\limits_{i=1}^{m}x_i^2$即可。

然而选$m$段非常不好办。这时候可以联想到凸优化。设$G_m$表示选$m$段$\sum\limits_{i=1}^{m}x_i^2$的最小值，当$m$增大的时候$G_m$显然会减小，~~凭蒟蒻的感性理解~~，多分出一段对答案的影响幅度也越来越小，也就是说$G_x$关于$x$的函数图像大概是下凸的。

我们用一个斜率为$mid$的直线去切这个凸包。显然$mid$的下界取$[0,1]$之间的斜率，是总路程平方级别的，上界是$0$。因为切线在凸包的下方，所以多选一段的代价不是$+mid$而是$-mid$。

update:蒟蒻弃用了用直线切凸包的理解方法，蒟蒻用导数思想理解DP凸优化的思路可以看[这里](https://www.cnblogs.com/flashhu/p/9480669.html)

接下来就是斜率优化的过程。设$f_i$为前$i$条路的最优答案，$x_i$为路程长度的前缀和，写出转移方程

$f_i=\min\limits_{j=0}^{i}\{f_j-2x_ix_j+x_j^2\}+x_i^2$

决策$j$优于$k$当且仅当

$f_j-2x_ix_j+x_j^2<f_k-2x_ix_k+x_k^2$

$\frac{f_j+x_j^2-f_k-x_k^2}{x_j-x_k}<2x_i$

于是设$y_i=f_i+x_i^2$，把决策看成点$(x_i,y_i)$，使用单调队列就OK了。注意这里要记$c_i$表示最优决策下将前$i$条路分出的段数。最后判断$c_n$与$m$的关系来调整斜率。

由于这一题的斜率肯定不会有小数，故也不必担心二分中的一些边界问题。

```cpp
#include<cstdio>
#define RG register
#define R RG int
#define G c=getchar()
#define Calc(j,k) (y[j]-y[k])/(x[j]-x[k])
typedef long long LL;
const int N=3009;
int n,q[N],c[N];
double f[N],k[N],x[N],y[N];
inline int in(){
	RG char G;
	while(c<'-')G;
	R x=c&15;G;
	while(c>'-')x=x*10+(c&15),G;
	return x;
}
inline double sqr(RG double x){
	return x*x;
}
inline void work(R mid){//斜率优化
	R h,t,i;
	for(h=t=i=1;i<=n;++i){
		while(h<t&&k[h]<2*x[i])++h;
		f[i]=f[q[h]]+sqr(x[i]-x[q[h]])-mid;//每转移一次要减一下mid
		y[i]=f[i]+sqr(x[i]);
		c[i]=c[q[h]]+1;//记录段数
		while(h<t&&k[t-1]>Calc(q[t],i))--t;
		k[t]=Calc(q[t],i);q[++t]=i;
	}
}
int main(){
	n=in();R m=in(),l,r,mid,i;
	for(i=1;i<=n;++i)x[i]=x[i-1]+in();
	l=-sqr(x[n]);r=0;//大致确定下界
	while(l<r){
		work(mid=(l+r+1)/2);//注意负数的下取整问题
		c[n]<=m?l=mid:r=mid-1;
	}
	work(l);
	printf("%.0lf\n",m*(f[n]+m*l)-sqr(x[n]));//先加回m*l
	return 0;
}
```

---

## 作者：Great_Influence (赞：11)

因为快读WA了一版有点无语（至今未查出毛病）。


先不管这些。拿到题目，首先推一波式子：




$m^2s^2=m\sum^m_{i=1}(x_i-\overline{x})^2$


$=m\sum^m_{i=1}x_i^2-2s_n\sum_{i=1}^mx_i+s_n^2$


然后就可以开始记dp计算。


$dp[i][l]=\min\{dp[j][l-1]+m(s_i-s_j)^2-2s_n(s_i-s_j)\}$


那么答案就是$dp[n][m]+s_n^2$。


发现转移具有单调性，使用斜率优化。


设

$y_i=dp[i]+2s_ns_j+ms_j^2$


$x_i=s_i-s_j$


那么若j比k更优，则$\frac{y_j-y_k}{x_j-x_k}< 2ms_i$

利用单调队列转移即可。时间复杂度：$O(nm)$。


代码：

    
```cpp
    // luogu-judger-enable-o2
    #include<bits/stdc++.h>
    #include<cctype>
    #define For(i,a,b) for(i=(a),i##end=(b);i<=i##end;++i)
    #define Forward(i,a,b) for(i=(a),i##end=(b);i>=i##end;--i)
    #define Rep(i,a,b) for(register int i=(a),i##end=(b);i<=i##end;++i)
    #define Repe(i,a,b) for(register int i=(a),i##end=(b);i>=i##end;--i)
    #define Chkmax(a,b) a=a>b?a:b
    #define Chkmin(a,b) a=a<b?a:b
    using namespace std;
    template<typename T>inline void read(T &x){
        T s=0,f=1;char k=getchar();
        while(!isdigit(k)&&k^'-')k=getchar();
        if(!isdigit(k)){f=-1;k=getchar();}
        while(isdigit(k)){s=s*10+(k^48);k=getchar();}
        x=s*f;
    }
    inline void get(char &x){for(x=0;!isupper(x);x=getchar());}
    void file(void){
        #ifndef ONLINE_JUDGE
        freopen("water.in","r",stdin);
        freopen("water.out","w",stdout);
        #endif
    }
    const int MAXN=4017;
    static int s[MAXN],n,m;
    void init()
    {
        read(n);read(m);
        Rep(i,1,n)scanf("%d",&s[i]),s[i]+=s[i-1];//迷之原因这里用快读(read)读取s会re两个点
    }
    static long long dp[MAXN][MAXN];
    #define calcy(x,pos) (1ll*dp[x][pos]+2ll*s[n]*s[x]+1ll*m*s[x]*s[x])
    #define calup(x,y,pos) (calcy(x,pos)-calcy(y,pos))
    #define caldown(x,y) (1ll*s[x]-1ll*s[y])
    static int que[MAXN],t,h;
    inline void makeans(int i,int j)
    {
        static int hed;
        for(hed=que[h];t-h&&calup(que[h+1],hed,j-1)
            <2ll*m*s[i]*caldown(que[h+1],hed);hed=que[++h]);
        dp[i][j]=dp[hed][j-1]+1ll*m*caldown(i,hed)*caldown(i,hed)
            -2ll*s[n]*caldown(i,hed);
    }
    inline void insert(int i,int j)
    {
       static int tal;
       for(tal=que[t];t-h&&calup(i,tal,j)*caldown(tal,que[t-1])
            <calup(tal,que[t-1],j)*caldown(i,tal);tal=que[--t]);
       que[++t]=i;
    }
    void solve()
    {
        Rep(i,1,n)dp[i][1]=1ll*m*s[i]*s[i]-2ll*s[n]*s[i];
        Rep(j,2,m)
        {
            que[t=h=1]=0;
            Rep(i,1,n)
            {
                makeans(i,j);
                insert(i,j-1);
            }
        }
        printf("%lld\n",dp[n][m]+s[n]*s[n]);
    }
    int main(void){
        file();
        init();
        solve();
        //cerr<<1.0*clock()/CLOCKS_PER_SEC<<endl;
        return 0;
    }
顺便一说，如果知道为什么上面用快读会re，请联系我。
```

---

## 作者：jacky567 (赞：8)

首先，我们先把结果的表达式化简一下

假设第$i$天走了$x_i$，总路程为$S$

那么$ans=m^2\times \frac{\sum \limits_{i=1}^m(x_i-\frac{S}{m})^2}{m}=\frac{\sum\limits_{i=1}^m(mx_i-S)^2}{m}=\frac{m^2\sum \limits_{i=1}^mx_i^2+S^2m-2Sm\sum \limits_{i=1}^mx_i}{m}=m\sum \limits_{i=1}^{m}x_i^2+S^2-2S^2=m\sum \limits_{i=1}^{m}x_i^2-S^2$

所以，我们只需要计算最小的$\sum \limits_{i=1}^mx_i^2$

假设$f_{i,j}$表示用$j$天走完前$i$段时，最小的$\sum \limits_{k=1}^jx_k^2$的值

为了方便，我们先预处理出$sum_i$表示前$i$段的长度之和

所以，我们就可以写出状态转移方程：$f_{i,j}=\min \limits_{1\leqslant k<i}\{f_{k,j-1}+(sum_i-sum_k)^2\}$

显然，这么做的时间复杂度太高了，我们需要进行优化

怎么优化呢？我们考虑$k$比$l$优，那么，我们可以得出：

$f_{k,j-1}+sum_k^2+sum_i^2-2sum_ksum_i<f_{l,j-1}+sum_l^2+sum_i^2-2sum_isum_l$

$f_{k,j-1}-f_{l,j-1}+sum_k^2-sum_k^2<2sum_i(sum_k-sum_l)$

$\frac{f_{k,j-1}-f_{l,j-1}+sum_k^2-sum_k^2}{sum_k-sum_l}<2sum_i$

所以，我们就可以进行斜率优化了！

附上代码：
```cpp
#include<cstdio>
int n,m,l,r;
long long a[3010],sum[3010],f[3010],fl[3010],q[3010];
long long K(int x,int y)
{
	return (fl[y]-fl[x]+sum[y]*sum[y]-sum[x]*sum[x])/(sum[y]-sum[x]);
}
int main()
{
    scanf("%d%d",&n,&m),sum[0]=0;
    for(int i=1;i<=n;i++) scanf("%lld",&a[i]),sum[i]=sum[i-1]+a[i];
    for(int i=1;i<=n;i++) fl[i]=sum[i]*sum[i];
    for(int i=2;i<=m;i++){
        l=r=1,q[l]=i-1;
        for(int j=i;j<=n;j++){
            while(l<r&&K(q[l],q[l+1])<2*sum[j]) l++;
            f[j]=fl[q[l]]+(sum[j]-sum[q[l]])*(sum[j]-sum[q[l]]);
            while(l<r&&K(q[r-1],q[r])>K(q[r],j)) r--;
            q[++r]=j;
        }
        for(int j=1;j<=n;j++) fl[j]=f[j];
    }
    printf("%lld",m*f[n]-sum[n]*sum[n]);
}
```

---

## 作者：_Sein (赞：8)

这道题原来我已经做过一遍了。。。

本来是斜率优化来着，被我淦成了四边形优化。

貌似题解区大多数都是斜率优化，淦。

重新写一下斜率优化吧。

## 方法一 斜率优化

记前缀和$s_i$

答案中${s_n}^2$的贡献先不算。

那么方程为

$f_{i,k}=f_{j,k-1}+(s_i-s_j)^2=f_{j,k-1}+{s_i}^2-2s_is_j+{s_j}^2$

$f_{j,k-1}+{s_j}^2=(2*s_i)*s_j+{s_i}^2-f_{i,k}$

发现是一条斜率为$2*s_i$的直线，且$s_i$关于$i$递增而递增。

那么维护一下凸壳即可。

## 方法二 四边形不等式优化

显然地，$s_{i,j+1}+s_{i+1,j}\ge s_{i,j}+s_{i+1,j+1}$，满足四边形不等式

这里的$s_{i,j}$表示$i$到$j$的区间和。

现在只需要搞定$f_{i,j+1}+f_{i+1,j}\ge f_{i,j}+f_{i+1,j+1}$就好了。

证明$j=1$的情况。

$f_{i,2}+f_{i+1,1}\ge f_{i,1}+f_{i+1,2}$

$f_{i,2}+s_{1,i+1}\ge f_{i+1,2}+s_{1,i}$

设$f_{i,2}$的最优决策为$p(0<p<i)$,即$f_{i,2}=s_{1,p}+s_{p+1,i}$

还有$f_{i+1,2}$的最优决策可能不为$p$，即$f_{i+1,2}\le s_{1,p}+s_{p+1,i+1}$

四边形不等式,
$s_{1,i+1}+s_{p+1,i}\ge s_{1,i}+s_{p+1,i+1}$

有$s_{1,i+1}+s_{1,p}+s_{p+1,i}\ge s_{1,i}+s_{1,p}+s_{p+1,i+1}$

因此
$f_{i,2}+f_{i+1,1}=s_{1,i+1}+s_{1,p}+s_{p+1,i}\ge s_{1,i}+s_{1,p}+s_{p+1,i+1}\ge f_{i,1}+f_{i+1,2}$

之后套证明模板就好了。

这道题奇奇怪怪♂

```cpp
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<algorithm>
#define gc getchar()
#define ll long long
using namespace std;
const int N=3005,mod=1e9+7,M=1e6;
template<class o>
inline void qr(o &x)
{
	x=0;char c=gc;int f=1;
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=gc;}
	while(c>='0'&&c<='9'){x=x*10+(c^48);c=gc;}
	x*=f;
}
template<class o>
void qw(o x)
{
	if(x<0)putchar('-'),x=-x;
	if(x/10)qw(x/10);
	putchar(x%10+48);
}
int a[N],p[N][N];ll sum[N],f[N][N];
int main()
{
	int n,m;qr(n);qr(m);ll s=0;
	for(int i=1;i<=n;i++)qr(a[i]),sum[i]=a[i]+sum[i-1];
	memset(f,0x3f,sizeof(f));
	for(int i=1;i<=n;i++)f[1][i]=sum[i]*sum[i],p[1][i]=1;
	for(int t=2;t<=m;t++)
	{
		p[t][n+1]=n;
		for(int i=n;i;i--)
			for(int k=p[t-1][i];k<=p[t][i+1];k++)
				if(f[t-1][k]+(sum[i]-sum[k])*(sum[i]-sum[k])<f[t][i])
				{
					f[t][i]=f[t-1][k]+(sum[i]-sum[k])*(sum[i]-sum[k]);
					p[t][i]=k;
				}
	}
	int t=m,k=n;s=-sum[n]*sum[n];
	while(k)
	{
		int z=p[t][k];if(z==1&&t==1)z=0;
		s+=m*(sum[k]-sum[z])*(sum[k]-sum[z]);
		t--;k=z;
	}
	qw(s);puts("");
	return 0;
}
```





---

## 作者：Tgotp (赞：6)

首先可以发现求得答案是 (∑(w - sum[n]/m)^2)/m \*m^2


化简可得 (∑(w\*m-w)^2)/m


容易列出方程f[i][j]表示在第i个人已经分了j块的最小方差。


即f[i][j] = min(f[j - 1][i - 1] + sum[i] - sum[j-1]);


那么时间复杂度O(n\*n\*m)


考虑优化，若j > k 同时满足j优于k


f[j - 1] + sum[i] - sum[j-1]) < f[k - 1] + sum[i] - sum[k-1]);


化简可得：


((f[j-1]-f[k-1])/(sumj-sumk)) + 2 \* m\*m\*(sumj + sumk) < 2\*m\*(sumi - sum[n])


很明显斜率优化。


时间复杂度O(nm)

搞定。


[博客~](http://tgotp.science/4518-sdoi2016%E5%BE%81%E9%80%94/)

c++代码如下：

```cpp
#include<bits/stdc++.h>
#define rep(i,x,y) for(register int i = x ; i <= y; ++ i)
#define repd(i,x,y) for(register int i = x ; i >= y; -- i)
using namespace std;
typedef long long ll;
template<typename T>inline bool chkmin(T&x,T y) { return x > y ? x = y,1:0; }
template<typename T>inline void read(T&x)
{
    x = 0;char c;int sign = 1;
    do { c = getchar(); if(c == '-') sign = -1; }while(!isdigit(c));
    do { x = x * 10 + c - '0'; c = getchar(); }while(isdigit(c));
    x *= sign;
}
 
const int N = 3e3 + 50,inf = 0x3f3f3f3f;
int n,m,q[N][N],st[N],en[N];ll f[N][N],a[N],sum[N];
 
double slop(int x,int y,int p) { return ((f[p][x] - f[p][y]) / (double)(sum[x] - sum[y])) + (sum[x] + sum[y]) * m*m ; }
 
int main()
{
    read(n); read(m);
    rep(i,1,n) read(a[i]),sum[i] = sum[i - 1] + a[i];
     
    rep(i,1,m) f[i][0] = inf;
    rep(i,1,n) f[1][i] = (sum[i]*m - sum[n]) * (sum[i]*m - sum[n]);
    rep(i,1,n)
    {
        rep(j,2,m)
        {
            #define x q[j][st[j] + 1] - 1
            #define y q[j][st[j]] - 1
            #define a q[j][en[j] - 2] - 1
            #define b q[j][en[j] - 1] - 1
             
            while(en[j] - st[j] > 1 && slop(i - 1,b,j - 1) < slop(b,a,j - 1)) --en[j];
            q[j][en[j]++] = i;
                 
            while(en[j] - st[j] > 1 && slop(x,y,j - 1) < 2 * (sum[i]*m - sum[n]) * m ) ++st[j];
            f[j][i] =  f[j - 1][y] + ((sum[i] - sum[y])*m - sum[n]) * ((sum[i] - sum[y]) * m - sum[n]);
             
//          printf("%d %d %lld %d\n",j-1,i,f[j - 1][i],y);
//          printf("%d %d %lld %d\n",j,i,f[j][i],y);
        } 
    }
     
    cout << f[m][n] / m<< endl;
     
    return 0;
}
```

---

## 作者：bztMinamoto (赞：5)

打广告->[这里](https://i.cnblogs.com/EditPosts.aspx?postid=9547048)

推式子（快哭了……）$$s^2*m^2=\sum _{i=1}^m (x_i-\bar{x})^2$$

$$s^2*m^2=m*\sum _{i=1}^m x_i^2-2*sum_n\sum _{i=1}^m x_i+sum_n^2$$

$$s^2*m^2=m*\sum _{i=1}^m x_i^2+(sum_n-\sum _{i=1}^m x_i)^2-(\sum _{i=1}^m x_i)^2$$

然后因为$sum_n$和$\sum _{i=1}^m x_i$两项是定值，且值相等，所以$$s^2*m^2=m*\sum _{i=1}^m x_i^2-(\sum _{i=1}^m x_i)^2$$

我们发现$(\sum _{i=1}^m x_i)^2$是一个定值，那么我们的目的就是让$\sum _{i=1}^m x_i^2$最小

总算扯到dp上了不容易啊……

我们设$dp[i][l]$表示前$i$条路$l$天走，最小的\sum _{a=1}^i x_a^2是多少，那么有如下的状态转移方程$$dp[i][l]=min\{dp[j][l-1]+(sum[i]-sum[j])^2\}$$

然后考虑斜率优化（以下省略$l$这一维）

假设$j$比$k$更优，则有$$dp[j]+(sum[i]-sum[j])^2<dp[k]+(sum[i]-sum[k])^2$$

展开，移项$$dp[j]+sum[j]^2-dp[k]-sum[k]^2<2*sum[i]*sum[j]-2*sum[i]*sum[k]$$

$$\frac{dp[j]+sum[j]^2-dp[k]-sum[k]^2}{sum[j]-sum[k]}<2*sum[i]$$

然后就可以上斜率优化了

ps:注意当$l$为$0$的时候dp要都初始化为$sum[i]^2$
```
//minamoto
#include<iostream>
#include<cstdio>
#define ll long long
using namespace std;
#define getc() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
char buf[1<<21],*p1=buf,*p2=buf;
inline int read(){
    #define num ch-'0'
    char ch;bool flag=0;int res;
    while(!isdigit(ch=getc()))
    (ch=='-')&&(flag=true);
    for(res=num;isdigit(ch=getc());res=res*10+num);
    (flag)&&(res=-res);
    #undef num
    return res;
}
const int N=3005;
ll sum[N],sp[N],dp[N];int n,m,h,t,q[N],r;
inline ll Y(int i){return sp[i]+sum[i]*sum[i];}
inline double slope(int j,int k){
    return (Y(j)-Y(k))*1.0/(sum[j]-sum[k]);
}
int main(){
    //freopen("testdata.in","r",stdin);
    n=read(),m=read();
    for(int i=1;i<=n;++i)
    sum[i]=read()+sum[i-1],sp[i]=sum[i]*sum[i];
    for(int a=1;a<m;++a){
        h=t=0;q[0]=a;
        for(int i=a+1;i<=n;++i){
            while(h<t&&slope(q[h],q[h+1])<2*sum[i]) ++h;
            dp[i]=sp[q[h]]+(sum[i]-sum[q[h]])*(sum[i]-sum[q[h]]);
            while(h<t&&slope(q[t],q[t-1])>slope(q[t-1],i)) --t;q[++t]=i;
        }
        for(int i=1;i<=n;++i) sp[i]=dp[i];
    }
    printf("%lld\n",-sum[n]*sum[n]+m*dp[n]);
    return 0;
}
```

---

## 作者：mgzc (赞：4)

# [题面](https://www.luogu.org/problemnew/show/P4072)
[想体验更加舒适的体验可以进博客看一下](https://www.cnblogs.com/ztlztl/p/10623347.html)
(~~博客进去有点慢, 大家体谅一下~~)

题意体面中写得很明确, 应该不用我说了, 方差的概念在初中人教版九年级数学中有所提到, 没有上过初中的同学们可以[左转](https://baike.baidu.com/item/%E6%96%B9%E5%B7%AE/3108412?fr=aladdin)[百度](https://www.baidu.com/).

将序列拆为几段求最值, 我们考虑用dp来实现. 

先推一下式子, 令方差为$v$, $r$为某一段路径的长度, $\overline r$为这$m$条路径长度的平均数.

则有:
$$
\begin{aligned}
v &= \frac{\sum_{i=1}^{m}(\overline r - r_i)^2}{m}\\
  &= \frac{\sum_{i=1}^{m}r_i^2 + m * (\overline r)^2 - 2 * (\overline r) * \sum_{i=1}^{m}r_i}{m}\\
  &= \frac{\sum_{i=1}^{m}r_i^2 + m * (\frac{\sum_{i=1}^{m}r_i}{m})^2 - 2 * \frac{(\sum_{i=1}^{m}r_i)^2}{m}}{m}\\
  &=- \frac{(\sum_{i=1}^{m}r_i)^2}{m ^ 2} + \frac{\sum_{i=1}^{m}r_i^2}{m}
\end{aligned}
$$
答案所求为$v * m ^ 2$, 所以:
$$
\begin{aligned}
v * m ^ 2 &= m * \sum_{i=1}^{m}r_i^2 - (\sum_{i=1}^{m}r_i) ^ 2\\
\end{aligned}
$$
我们发现$(\sum_{i=1}^{m}r_i) ^ 2$是一个定值, 也就是总路径长度的平方, 所以我们只需要求前面那个数就可以了, 用前缀和先处理一下, 即$S_i$表示1 ~ i的路径的长度.

我们设$f[i][k]$表示前$i$段路花$k$天走的最小花费, 所以我们可以得到状态转移方程: 
$$
f[i][k] = min(f[i][k], f[j][k - 1] + (sum[j] - sum[i])^2)
$$
还是老套路, 设对$i$点选$t$($t$ > $j$)转移比选$j$转移更优, 则有:
$$
\begin{aligned}
f[t][k - 1] + (sum[t] - sum[i])^2 &< f[j][k - 1] + (sum[j] - sum[i]) ^ 2\\
(f[t][k - 1] + sum[t] ^ 2) - (f[j][k - 1] + sum[j] ^ 2) &< 2 * sum[i] * (sum[t] - sum[j])\\
\frac{(f[t][k - 1] + sum[t] ^ 2) - (f[j][k - 1] + sum[j] ^ 2)}{2 * (sum[t] - sum[j])} &< sum[i]
\end{aligned}
$$


由此可知道我们需要维护一个上凸包, 不信的话选三个点试一下就可以发现了, 然后愉快的推式子时间又结束了, 下面是大家喜(shen)闻(wu)乐(tong)见(jue)的$Coding Time$... 

**代码**

```cpp
#include <iostream>
#include <cstring>
#include <cstdio>
#define N 3005
using namespace std;

int n, m, sum[N], q[N], l, r;
long long f[N], g[N]; 

inline int read()
{
	int x = 0, w = 1;
	char c = getchar();
	while(c < '0' || c > '9') { if (c == '-') w = -1; c = getchar(); }
	while(c >= '0' && c <= '9') { x = x * 10 + c - '0'; c = getchar(); }
	return x * w;
}

bool F_check(int x, int y, int z) { return 1ll * (g[y] - g[x] + sum[y] * sum[y] - sum[x] * sum[x]) < 1ll * 2 * z * (sum[y] - sum[x]); } 

bool S_check(int x, int y, int z) { return (g[y] - g[x] + sum[y] * sum[y] - sum[x] * sum[x]) * (sum[z] - sum[y]) > (g[z] - g[y] + sum[z] * sum[z] - sum[y] * sum[y]) * (sum[y] - sum[x]); }

int main()
{
	n = read(); m = read();
	for(int i = 1; i <= n; i++) { sum[i] = read(); sum[i] += sum[i - 1]; g[i] = 1ll * sum[i] * sum[i]; }
	for(int k = 1; k < m; k++)
	{
		l = 1; r = 0; q[++r] = k; 
		for(int i = k + 1; i <= n; i++)
		{
			while(l < r && F_check(q[l], q[l + 1], sum[i])) l++;
			f[i] = g[q[l]] + 1ll * (sum[i] - sum[q[l]]) * (sum[i] - sum[q[l]]);
			while(l < r && S_check(q[r - 1], q[r], i)) r--;
			q[++r] = i; 
		}
		for(int i = 1; i <= n; i++) g[i] = f[i]; 
	}
	printf("%lld\n", m * f[n] - sum[n] * sum[n]); 
	return 0;
}
```

~~不知道交了多少遍才**AC**的菜鸡我~~

---

## 作者：ModestCoder_ (赞：2)

首先得推一推式子

令$sum_i=\sum_{j=1}^{i}a_j$

$ans=\frac{(v_1-\frac{sum_n}{m})^2+(v_2-\frac{sum_n}{m})^2+...+(v_m-\frac{sum_n}{m})^2}{m}$

$=\frac{v_1^2+v_2^2+...+v_m^2}{m}+\frac{sum_n^2}{m^2}-2\frac{sum_n^2}{m^2}$

$=\frac{v_1^2+v_2^2+...+v_m^2}{m}-\frac{sum_n^2}{m^2}$

$m^2ans=m(v_1^2+v_2^2+...+v_m^2)-sum_n^2$

现在任务是求$min(v_1^2+v_2^2+...+v_m^2)$

上dp

$dp_{i,j}$表示前$i$个分成$j$段的最小平方和

$dp_{i,j}=min(dp_{k,j-1}+(sum_i-sum_k)^2)$

时间复杂度较大，用斜率优化

假设两个决策$x,y(x<y)$，如果$y$更优必须满足

$dp_{x,j-1}+sum_x^2-2sum_isum_x>dp_{y,j-1}+sum_y^2-2sum_isum_y$

化简得$\frac{dp_{x,j-1}-dp_{y,j-1}+sum_x^2-sum_y^2}{2(sum_x-sum_y)}<sum_i$

维护一个斜率的下凸包就好了

其实还可以滚动掉一维，但是反正能过，就懒得滚动了
Code：

```cpp
#include <bits/stdc++.h>
#define maxn 3010
#define LL long long
using namespace std;
LL sum[maxn], dp[maxn][maxn], n, m, q[maxn];

inline int read(){
	int s = 0, w = 1;
	char c = getchar();
	for (; !isdigit(c); c = getchar()) if (c == '-') w = -1;
	for (; isdigit(c); c = getchar()) s = (s << 1) + (s << 3) + (c ^ 48);
	return s * w;
}

double slope(int opt, int x, int y){
	return 1.0 * (dp[x][opt] - dp[y][opt] + sum[x] * sum[x] - sum[y] * sum[y]) / 2 / (sum[x] - sum[y]); 
}

int main(){
	n = read(), m = read();
	for (int i = 1; i <= n; ++i) sum[i] = sum[i - 1] + read(), dp[i][1] = sum[i] * sum[i];
	for (int j = 2; j <= m; ++j){
		int h = 0, t = 0; q[0] = j - 1;
		for (int i = j; i <= n; ++i){
			while (h < t && slope(j - 1, q[h], q[h + 1]) < sum[i]) ++h;
			dp[i][j] = dp[q[h]][j - 1] + (sum[i] - sum[q[h]]) * (sum[i] - sum[q[h]]);
			while (h < t && slope(j - 1, q[t], i) < slope(j - 1, q[t - 1], q[t])) --t;
			q[++t] = i;
		}
	}
	printf("%lld\n", m * dp[n][m] - sum[n] * sum[n]);
	return 0;
}
```


---

## 作者：resftlmuttmotw (赞：2)

广告 ：[博客食用更佳](https://www.cnblogs.com/resftlmuttmotw/p/11334847.html)

[题目链接](https://www.luogu.org/problem/P4072)

# Solution

方差

=$\frac{\displaystyle\sum^{m}_{i=1}{{(x_i-\bar{x})^2}}}{m}$

=$\displaystyle\sum^{m}_{i=1}{({x_i^2} + \bar{x}^2 - 2*x_i*\bar{x})}$

=$\displaystyle\sum^{m}_{i=1}{(x_i^2+\frac{\displaystyle\sum^{m}_{i=1}x_i}{m}- 2*x_i*\frac{\displaystyle\sum^{m}_{i=1}x_i}{m})}$

=$\displaystyle\sum^{m}_{i=1}{x_i^2}+\displaystyle\sum^{m}_{i=1}x_i-\frac{\displaystyle\sum^{m}_{i=1}(2*x_i*\displaystyle\sum^{m}_{i=1}x_i)}{m}$

=$\displaystyle\sum^{m}_{i=1}{x_i^2}+\displaystyle\sum^{m}_{i=1}x_i-\frac{\displaystyle\sum^{m}_{i=1}x_i*\displaystyle\sum^{m}_{i=1}(2*x_i)}{m}$

=$\displaystyle\sum^{m}_{i=1}{x_i^2}+\displaystyle\sum^{m}_{i=1}x_i-\frac{2*(\displaystyle\sum^{m}_{i=1}x_i)^2}{m}$

易得$\displaystyle\sum^{m}_{i=1}x_i$和$\displaystyle\sum^{m}_{i=1}x_i$是定值

所以只需要求$\displaystyle\sum^{m}_{i=1}{x_i^2}$的最小值就行了

然后再套上公式 **注意**得*上$m^2$ 

然后非常容易想到DP

定义

```cpp
dp[i][j]表示前i个分成j份的平方和的最小值
```

易得状态转移方程


$\color{pink}{dp[i][j] = min(dp[k][j-1]+(sum[i]-sum[k])^2);}$


```cpp
#include <cmath>
#include <cstdio>
#include <vector>
#include <climits>
#include <cstring>
#include <algorithm>
using namespace std;
#define isdigit(x) ('0' <= (x)&&(x) <= '9')
template<typename T>
inline T Read(T Type)
{
    T x = 0;
    char a;
    while(!isdigit(a)) a = getchar();
    while(isdigit(a)) x = (x << 3) + (x << 1) + a - '0',a = getchar();
    return x;
}
const int MAXN = 3005;
const int inf = INT_MAX;
int x[MAXN],sum[MAXN],f[MAXN][MAXN];
inline int dmult(int x) {return x * x;}
int main()
{
	int i,j,l,n = Read(1),m = Read(1);
	memset(f,0x3f,sizeof(f));
	for(i = 1;i <= n;i++)
	{
		x[i] = Read(1);
		sum[i] += sum[i - 1] + x[i];
	}
	f[0][0] = 0;
	for(i = 1;i <= n;i++)
	{
		for(l = 1;l <= min(i,m);l++)
		{
			for(j = 0;j < i;j++)
				f[i][l] = min(f[i][l],f[j][l - 1] + dmult(sum[i] - sum[j]));
		}
	}
	printf("%d",m * f[n][m] - dmult(sum[n]));
	return 0;
}
```

算一下时间复杂度

$3000^3 >10^9$

显然不行

$\color{pink}{TLE}$

明显得优化下

看下标签 嗯 斜率优化

设$j>k$

当且仅当

$\color{pink}{f[j][l - 1] + dmult(sum[i] - sum[j]) < f[k][l - 1] + dmult(sum[i] - sum[k])}$

我们认为j比k优

否则 k更优

化简一下得到

$\color{pink}{f[j][l-1]+sum[i]^2+sum[j]^2-2*sum[i]*sum[j]<f[k][l - 1] + sum[i]^2 + sum[k]^2-2*sum[i]*sum[k])}$

$\color{pink}{f[j][l-1]-f[k][l-1]+sum[j]^2-sum[k]^2<2*sum[i]*(sum[j]-sum[k])}$

因为我们设了 $j>k$


所以$sum[j]-sum[k]>0$

所以

$\color{pink}{\frac{f[j][l-1]-f[k][l-1]+sum[j]^2-sum[k]^2}{(sum[j]-sum[k])}<2*sum[i]}$

$\color{pink}{\frac{f[j][l-1]+sum[j]^2-f[k][l-1]-sum[k]^2}{(sum[j]-sum[k])}<2*sum[i]}$

非常明显的斜率优化

P.S最后输出的时候按照我推出来的也行

```cpp
#include <cmath>
#include <cstdio>
#include <vector>
#include <climits>
#include <cstring>
#include <algorithm>
using namespace std;
#define isdigit(x) ('0' <= (x)&&(x) <= '9')
template<typename T>
inline T Read(T Type)
{
    T x = 0;
    char a;
    while(!isdigit(a)) a = getchar();
    while(isdigit(a)) x = (x << 3) + (x << 1) + a - '0',a = getchar();
    return x;
}
const int MAXN = 3005;
const int inf = INT_MAX;
int x[MAXN],sum[MAXN],f[MAXN][MAXN],q[MAXN],g[MAXN];
inline int dmult(int x) {return x * x;}
inline double count_k(int u,int l,int r)
{
	return (f[l][u] - f[r][u] + g[l] - g[r]) / (double)(sum[l] - sum[r]);
}
int main()
{
	int i,j,l,n = Read(1),m = Read(1);
	for(i = 1;i <= n;i++)
	{
		x[i] = Read(1);
		sum[i] += sum[i - 1] + x[i];
		g[i] = dmult(sum[i]);
	}
	int left,r;
	for(i = 1;i <= n;i++) f[i][1] = dmult(sum[i]);
	for(l = 2;l <= m;l++)
	{
		left = 1,r = 0;
		for(i = 1;i <= n;i++)
		{
			while(left < r&&count_k(l - 1,q[left],q[left + 1]) < 2 * sum[i]) left++;
			f[i][l] = f[q[left]][l - 1] + dmult(sum[i] - sum[q[left]]);
			while(left < r&&count_k(l - 1,q[r - 1],q[r]) > count_k(l - 1,q[r],i)) r--;
			q[++r] = i;
		}
	}
	printf("%d",m * f[n][m] - dmult(sum[n]));
   //按我推出的式子也行
	return 0;
}
```

---

## 作者：1saunoya (赞：1)

[$myblog$](https://www.cnblogs.com/Isaunoya/p/11656178.html)

斜率优化裸题

题意大概是：求 最小的 $m^2s^2$ =$m^2(\frac{1}{m}\sum_{i=1}^{m}(sum_i - {\frac{\sum_{i=1}^{m}sum_i}{m})^2})$

= $m^2 (\frac{1}{m} \sum_{i=1}^{m}sum_i^2 - \frac{1}{m^2}(\sum_{i=1}^{m}sum_i)^2)$

= $m\sum_{i=1}^{m}sum_i ^2 - (\sum_{i=1}^{m}sum_i)^2$

然后我们发现$(\sum_{i=1}^{m}sum_i)^2$是一个定值

所以我们只需要最小化$m\sum_{i=1}^{m}sum_i ^2$

发现 $m$ 这个常数也可以最后再乘上

所以 考虑 最小化 $\sum_{i=1}^{m}sum_i ^2$

转移方程是 $f_{i,j}$ = $min${$f_{i-1,k}+(sum_j-sum_k)^2$}

这样就可以 $n^2m$求解了

考虑斜率优化

比较 $x$ 和 $y$

设 $x$ 的转移优于 $y$

即 $f_{i-1,x} +(sum_j-sum_x)^2>f_{i-1,y}+(sum_j-sum_y)^2$

$f_{i-1,x}+(sum_j^2+sum_x^2-2sum_{j}*sum_{x})>f_{i-1,y}+(sum_j^2+sum_y^2-2sum_j*sum_y)$

$\large \frac{f_{i-1,x}-f_{i-1,y}+sum_x^2-sum_y^2}{sum_x-sum_y}>2*sum_{j}$

很显然这样就可以斜率优化了

```c++
// Isaunoya
#include<bits/stdc++.h>
using namespace std ;
#define int long long
#define fi first
#define se second
#define pb push_back
inline int read() {
  register int x = 0 , f = 1 ;
  register char c = getchar() ;
  for( ; ! isdigit(c) ; c = getchar()) if(c == '-') f = -1 ;
  for( ; isdigit(c) ; c = getchar()) x = (x << 1) + (x << 3) + (c & 15) ;
  return x * f ;
}
template < typename T > inline bool cmax(T & x , T y) {
	return x < y ? (x = y) , 1 : 0 ;
}
template < typename T > inline bool cmin(T & x , T y) {
	return x > y ? (x = y) , 1 : 0 ;
}
inline int QP(int x , int y , int Mod){ int ans = 1 ;
  for( ; y ; y >>= 1 , x = (x * x) % Mod)
    if(y & 1) ans = (ans * x) % Mod ;
  return ans ;
}
int n , m ;
const int N = 3000 + 5 ;
int a[N] , sum[N] ;
int f[2][N] , q[N] ;
inline int sqr(int x) { return x * x ; }
inline double slope(int i , int j , int k) {
  return 1.00 * (f[i & 1][j] - f[i & 1][k] + sqr(sum[j]) - sqr(sum[k])) / (double)(sum[j] - sum[k]) ;
}
signed main() {
  n = read() ; m = read() ;
  for(register int i = 1 ; i <= n ; i ++) a[i] = read() ;
  for(register int i = 1 ; i <= n ; i ++) sum[i] = sum[i - 1] + a[i] ;
  memset(f , 0x3f , sizeof(f)) ;
  f[0][0] = 0 ;
  for(register int i = 1 ; i <= n ; i ++) f[1][i] = sum[i] * sum[i] ;
  for(register int i = 2 ; i <= m ; i ++) {
    int h = 1 , t = 0 ;
    for(register int j = 1 ; j <= n ; j ++) {
      while(h < t && slope(i - 1 , q[h] , q[h + 1]) < 2 * sum[j]) h ++ ;
      int k = q[h] ; f[i & 1][j] = f[(i & 1) ^ 1][k] + sqr(sum[j] - sum[k]) ;
      while(h < t && slope(i - 1 , q[t] , q[t - 1]) > slope(i - 1 , q[t] , j)) t -- ;
      q[++ t] = j ;
    }
  } printf("%lld\n" , m * f[m & 1][n] - sqr(sum[n])) ;
	return 0 ;
}

```

---

## 作者：wangxuye (赞：1)

### 题目链接
[[SDOI2016]征途](https://www.luogu.org/problemnew/show/P4072)
### 题目大意
分析后的问题：将一个长度为$n$的正整数序列划分成$m$段，使得$m$段的和的方差最小。
### 预备知识：方差
设$x[i]$为第$i$天走的路程。  
方差公式是$v=\frac{1}{n}\sum_{i=1}^n(x[i]-\overline x)^2$
$$\begin{aligned}
v*m^2&=m\sum_{i=1}^{m}(x[i]-\overline x)^2\\
&=m\sum_{i=1}^{m}(x[i]^2-\frac{2x[i]\sum_{j=1}^{m}x[j]}{m}+(\sum_{j=1}^{m}\frac{x[j]}{m})^2)\\
&=m\sum_{i=1}^mx[i]^2-2\sum_{i=1}^mx[i]\sum_{j=1}^mx[j]+\sum_{i=1}^mx[i]^2\\
&=m\sum_{i=1}^mx[i]^2-(\sum_{i=1}^mx[i])^2\\
\end{aligned}$$
### 题目思路
可以看出$(\sum_{i=1}^mx[i])^2$等于$S$到$T$路径上所有边权和的平方，一定是个定值，所以只要求$\sum_{i=1}^mx[i]^2$就可以了。  
由于走到每一个休息站后对之后的休息站没有影响，所以想到$dp$。  
设$s[i]$为第$i$个点距离原点$S$的距离，$dp[i][j]$表示前$i$个数分成$j$份的最小的平方的和。
$$dp[i][j]=min(dp[k][j-1]+(s[i]-s[k])^2),k\in[0,i)$$
这个式子是$O(n^3)$，直接上可以获得$60$分的好成绩。  
看到平方项，自然想到斜率优化，那就推一下式子。  
当决策$p$优于决策$q(p<q)$时，有
$$dp[p][j-1]+(s[i]-s[p])^2<dp[p][j-1]+(s[i]-s[p])^2$$
$$dp[p][j-1]-2s[i]s[p]+s[p]^2<dp[q][j-1]-2s[i]s[q]+s[q]^2$$
$$\frac{(dp[p][j-1]+s[p]^2)-(dp[q][j-1]+s[q]^2)}{s[p]-s[q]}<2s[i]$$
接下来有一点证明~~自己瞎证的~~。  
首先，因为$s[i]$是前缀和，且每段路的长度均为正，所以$s[i]$是单调增的，即斜率是单调增的。  
又因为四边形不等式
$$(s[c]-s[a])^2+(s[d]-s[b])^2\leq(s[d]-s[a])^2+(s[c]-s[b])^2$$
两边约去相同项得
$$s[a]s[c]+s[b]s[d]\leq s[a]s[d]+s[b]s[c]$$
移项得
$$(s[d]-s[c])(s[b]-s[a])\geq0$$
得证，可得决策是单调的。  
所以直接用单调队列维护就行了！  
令$Y(i,j)=dp[i][j]+s[i]^2,X(i)=s[i],$ $Slope(i,j,k)=1.0*(Y(i,k)-Y(j,k))/(X(i)-X(j))$  
然后维护队头队尾单调。。。就没然后了。  
## 上代码  
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=3010;

int n,m;
ll dp[N][N],x[N],s[N];
int q[N],head=1,tail=0;

#define sqr(x) ((x)*(x))
#define Y(i,j) (dp[i][(j)]+sqr(s[i]))
#define X(i) (s[i])
#define Slope(i,j,k) 1.0*(Y(i,k)-Y(j,k))/(X(i)-X(j))
#define calc(i,j,k) (dp[k][(j)-1]+sqr(s[i]-s[k]))

inline ll read()
{
	ll s=0;
	bool flag=false;
	char ch=getchar();
	for(;ch<'0'||ch>'9';ch=getchar()) if(ch=='-') flag=true;
	for(;'0'<=ch&&ch<='9';ch=getchar()) s=(s<<3)+(s<<1)+(ch^48);
	if(flag) return -s;
	return s;
}
inline void write(ll x)
{
	if(!x)
	{
		putchar('0'),putchar(' ');
		return ;
	}
	if(x<0) putchar('-'),x=-x;
	char ch[20];
	int tot=0;
	while(x) ch[++tot]=x%10,x/=10;
	for(int i=tot;i;i--) putchar(ch[i]^48);
	putchar(' ');
}
inline void writeln(ll x)
{
	write(x);
	putchar('\n');
}

int main()
{
	n=read(),m=read();
	for(int i=1;i<=n;i++) x[i]=read();
	for(int i=1;i<=n;i++) s[i]=s[i-1]+x[i];
	memset(dp,0x3f,sizeof(dp));
	dp[0][0]=0;
	for(int j=1;j<=m;j++)
	{
		head=1,tail=0;
		q[++tail]=j-1;
		for(int i=j;i<=n;i++)
		{
			for(;head<tail&&Slope(q[head],q[head+1],j-1)<2*s[i];head++);
			dp[i][j]=calc(i,j,q[head]);
			for(;head<tail&&Slope(q[tail-1],q[tail],j-1)>Slope(q[tail],i,j-1);tail--);
			q[++tail]=i;
		}
	}
	ll ans=-sqr(s[n])+m*dp[n][m];
	writeln(ans);
	return 0;
}
```

---

## 作者：shuidi (赞：1)

## 题目描述：
Pine开始了从S地到T地的征途。

从S地到T地的路可以划分成$n$段，相邻两段路的分界点设有休息站。

Pine计划用$m$天到达T地。除第$m$天外，每一天晚上Pine都必须在休息站过夜。所以，一段路必须在同一天中走完。

Pine希望每一天走的路长度尽可能相近，所以他希望每一天走的路的长度的方差尽可能小。

帮助Pine求出最小方差是多少。

设方差是$v$，可以证明， $v\times m^2$是一个整数。为了避免精度误差，输出结果时输出 $v\times m^2$。

## 输入输出格式

### 输入格式：
第一行两个数 $n$、$m$。

第二行 $n$ 个数，表示 $n$ 段路的长度

### 输出格式：### 
一个数，$v\times m^2$

## 题解

拿到题之后没有思路，于是先来推一波式子。

最原始的方差表达形式为：

$s^2 = \frac{(\bar{v} - v_1)^2 + (\bar{v} - v_2)^2 + ... + (\bar{v} - v_m)^2}{m}$

整理得到：

$s^2 = \frac{(\sum_{i = 1} ^ m v_i - v_1)^2 + (\sum_{i = 1} ^ m v_i - v_2)^2 + ... + (\sum_{i = 1} ^ m v_i - v_m)^2}{m}$

二项式展开之后可得：

$s^2 = \frac{m\times\frac{(\sum_{i = 1} ^ m v_i)^2}{m ^  2} - 2\times\frac{\sum_{i = 1} ^ m v_i}{m}\times\sum_{i= 1}^m v_i^2 + \sum_{i = 1} ^m v_i ^ 2}{m}$

最后整理得到最终形式：

$s ^ 2 = \frac{-\frac{\sum_{i = 1} ^ m v_i ^2}{m} +\sum_{i = 1} ^ m v_i ^ 2}{m}$

最后将$m ^ 2$代入可得：

$s ^ 2 \times m ^ 2 = -(\sum_{i = 1} ^ m v_i) ^ 2 + m \times \sum_{i = 1} ^ m v_i ^ 2$

此时可以发现前一项是一个常数，扔掉不理他→_→

那么问题转化为如何求$\sum_{i = 1} ^ m v_i ^ 2$。

很明显可以有很朴素的状态$f[i][j]$表示考虑到第$i$段，走了$j$天时的总量。

然鹅这样的DP是$O(n ^ 3)$的，所以考虑斜率优化。

为了方便，我们设计$f[i]$和$g[i]$为当前考虑的时间段和之前的时间段的状态，那么我们就可以愉快地再大力推一波式子了→_→：

$f[i] = g[i] + (sum[i] - sum[j]) ^ 2$

一顿操作后可以得到斜率式的形式：

$2 \times sum[i] \times sum[j] + f[i] - sum[i] ^  2 = g[j] + sum[j] ^  2$

然后套斜率优化的套路就可以惹。

另外需要注意初始化$g[i]$。

## 代码

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>

#define MAXN 3005

typedef long long ll;

using namespace std;

int N, M;
int head, tail;
int q[MAXN];
ll sum[MAXN];
ll f[MAXN], g[MAXN];

inline ll read_int()
{
	ll ret = 0, f = 1; char c = getchar();
	while(c < '0' || c > '9') {if(c == '-') f = -1; c = getchar();}
	while(c >= '0' && c <= '9') {ret = (ret << 1) + (ret << 3) + int(c - 48); c = getchar();}
	return ret * f;
}

inline ll pow(ll x) {return x * x;}

inline double X(int i) {return sum[i];}

inline double Y(int j) {return g[j] + pow(sum[j]);}

inline double slope(int i, int j) {return (Y(i) - Y(j)) / (X(i) - X(j));}

void init()
{
	N = read_int(), M = read_int();
	for(int i = 1; i <= N; i++)
	{
		sum[i] = read_int();
		sum[i] += sum[i - 1];
		g[i] = pow(sum[i]);
	}
}

void dp()
{
	for(int l = 1; l < M; l++)
	{
		head = 1, tail = 1;
		q[1] = l;
		for(int i = l + 1; i <= N; i++)
		{
			while(head < tail && slope(q[head], q[head + 1]) < 2 * sum[i])
				head++;
			f[i] = g[q[head]] + (pow(sum[i] - sum[q[head]]));
			while(head < tail && slope(q[tail], q[tail - 1]) > slope(q[tail], i))
				tail--;
			q[++tail] = i;
		}
		memcpy(g, f, sizeof(f));
	}
	printf("%lld\n", f[N] * M - pow(sum[N]));
}

int main()
{
	init();
	dp();
	return 0;
}
```


---

## 作者：ezoiHY (赞：1)

### 征途这是一道十分经典的斜率优化
我们可以从题目中的方差来想,也就很容易的到这个式子
$$ans=m^2*\frac{\sum_{i=1}^{m}{(x_i-{\overline{x}})^2}}{m}$$

化简就会得到
$$ans=m*\sum_{i=1}^{m}{(x_i-{\overline{x}})^2}$$

在化简得
$$ans={m*\sum_{i=1}^{m}{x_i}^2}+{\sum_{i=1}^{m}{x_i}}$$

经过观察，我们可以很容易发现$\sum_{i=1}^{m}{x_i}$是定值，同时$m*\sum_{i=1}^{m}{x_i}^2$中的$m$也是定值，所以我们的目标就是让$\sum_{i=1}^{m}{{x_i}^2}$最小
我们令$dp[i][j]=\min\{dp[i-1][j-k]+(sum[j]-sum[j-k])^2\}$

其中我们令$sum[i]=\sum_{k=1}^{i}{val_k}$

其中$val_k$是第k段路的长度

由此我们就可得到一个开o2可以卡成80的代码
```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cctype>

using namespace std;

long long n,m,dp[3001][3001],sum[3001];

    const int BufferSize=100*1000;
    char buffer[BufferSize],*head,*tail;
    bool not_EOF=true;
    inline char Getchar(){
        if(not_EOF and head==tail){
            int len=fread(buffer,1,BufferSize,stdin);
            not_EOF=len!=0;
            head=buffer,tail=head+len;
        }
        return not_EOF?*head++:-1;
    }
    inline long long rd(){
        long long x=0,s=1;
        char c=Getchar();
        for(;!isdigit(c) and not_EOF;c=Getchar()) if(c=='-') s=-1;
        for(; isdigit(c) and not_EOF;c=Getchar()) x=(x<<1)+(x<<3)+(c^48);
        return s*x;
    }
    inline void scan(char *str){
        char c=Getchar();
        for(; isspace(c) and not_EOF;c=Getchar());
        for(;!isspace(c) and not_EOF;c=Getchar()) *(str++)=c;
        *str=0;
}

int main(){
	memset(dp,0x7f,sizeof(dp));
	n=rd(),m=rd();
	for(int i=1;i<=n;i++){
		long long x=rd();
		sum[i]=sum[i-1]+x;
	}
	dp[0][0]=-sum[n]*sum[n];
	for(int i=0;i<m;i++){
		for(int j=0;j<=n;j++){
			for(int k=0;k<=n-j;k++){
				dp[i+1][j+k]=min(dp[i+1][j+k],dp[i][j]+(sum[j+k]-sum[j])*(sum[j+k]-sum[j])*m);
			}
		}
	}
    printf("%lld",dp[m][n]);
    return 0;
}
```

但是我们可以发现这个代码是$O(nm)$的，显然我是不可以接受的。其实我们可以很容易证明这个的决策单调性，于是我们就可以用斜率优化

我们令$y<x<i$
因为决策单调性，所以对于决策$i$时，k转移必定比j转移要优，我们就可以得到这么一个式子
$$dp[i-1][x]+(sum[j]-sum[x])^2<dp[i-1][y]+(sum[j]-sum[y])^2$$
化简得
$$\frac{(dp[i-1][x]+sum[x]^2)-(dp[i-1][y]+sum[y]^2)}{sum[x]-sum[y]}<2*sum[j]$$
这样我们就可以用斜率又花了

我们把$p_1(dp[i-1][x]+sum[x]^2,sum[x])$和$p_2(dp[i-1][y]+sum[y]^2,sum[y])$看做$p_1,p_2$两个点，刚刚那个式子也就是它们所连线的斜率表达式

我们也就可以得到这样的代码
```
#include<iostream>
#include<cstdio>
#include<cstring>

using namespace std;

long long n,m,dp[3001][3001],sum[3001];
int q[3001];

double getpoint(int i,int p){return (double)dp[i][p]+sum[i]*sum[i];}
double slope(int j,int k,int p){return (double)(getpoint(j,p)-getpoint(k,p))/(double)(sum[j]-sum[k]);}

int main(){
	scanf("%lld%lld",&n,&m);
	for(int i=1;i<=n;i++){
		long long x;
		scanf("%lld",&x);
		sum[i]=sum[i-1]+x;
		dp[i][1]=sum[i]*sum[i];
	}
	for(int k=2;k<=m;k++){
		int head=1,tail=0;
		for(int i=1;i<=n;i++){ 
            while(head<tail and slope(q[head],q[head+1],k-1)<2*sum[i])head++;
            int j=q[head];
            dp[i][k]=dp[j][k-1]+(sum[j]-sum[i])*(sum[j]-sum[i]); 
            while(head<tail and slope(q[tail],q[tail-1],k-1)>slope(q[tail],i,k-1))tail--;
            q[++tail]=i;
        }
	}
    printf("%lld",m*dp[n][m]-sum[n]*sum[n]);
    return 0;
}
```

---

## 作者：lhc0707 (赞：0)

看到题解区里没有李超线段树解法，于是我来水一波。

不妨设每一段的路程分别为 $v_1,v_2,\dots,v_m$，设 $S_i\sum_{j=1}^i a_j $，则我们有：

$$s^2=\frac{1}{m}\sum\limits_{i=1}^m(v_i-\bar{v})^2 

 = \frac{1}{m}\sum\limits_{i=1}^m(v_i-\sum\limits_{j=1}^mv_j \cdot \frac{1}{m})^2 \\

= \frac{1}{m}\sum\limits_{i=1}^m(v_i-\frac{S_n}{m})^2 

= \frac{1}{m}\sum_{i=1}^m(v_i^2-\frac{2v_iS_n}{m}+\frac{S_n^2}{m}) \\

= \frac{1}{m}(\sum_{i=1}^m v_i^2-\frac{2S_n}{m}\sum_{i=1}^mv_i+\frac{S_n^2m}{m^2}) 

= \frac{1}{m}(\sum_{i=1}^mv_i^2-\frac{S_n^2}{m})

$$

则有

$$
Ans=\min\{m\sum_{i=1}^mv_i^2-S_n^2\}=\min\{\sum_{i=1}^mv_i^2\}\cdot m - S_n^2
$$

我们设 $f_{i,j}$ 表示前 $i$ 段路程休息 $j$ 次的最小代价，则 $f_{i,l}=\min\{f_{j,l-1}+(s_i-s_j)^2\}=\min\{-2s_j\cdot s_i+s_j^2+f_{j,l-1}\}+s_i^2$，李超线段树维护就完辣！

代码：

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#define endl '\n'
#define ls(p) (p<<1)
#define rs(p) (p<<1|1)
using namespace std;
const int N=3005,V=300005,INF=1e9;
int n,m,a[N],s[N],f[N][N],cnt,v;
struct Line{
	int k,b,id;
	Line(){k=0,b=INF,id=0;}
	Line(int _k,int _b,int _id){k=_k,b=_b,id=_id;}
	int f(int x){return k*x+b;}
}tr[V<<2];
void clear(int p,int pl,int pr)
{
	tr[p]=Line(0,INF,0);
	if(pl==pr)return;
	int mid=(pl+pr)>>1;
	if(tr[ls(p)].id)clear(ls(p),pl,mid);
	if(tr[rs(p)].id)clear(rs(p),mid+1,pr);
}
void update(int p,int pl,int pr,int L,int R,Line g)
{
	if(L<=pl&&pr<=R)
    {
        if(!tr[p].id){tr[p]=g;return;}
        int mid=(pl+pr)>>1;
        if(tr[p].f(mid)>g.f(mid))swap(tr[p],g);
        if(tr[p].f(pl)>g.f(pl))update(ls(p),pl,mid,L,R,g);
        if(tr[p].f(pr)>g.f(pr))update(rs(p),mid+1,pr,L,R,g);
        return;
    }
    int mid=(pl+pr)>>1;
	if(L<=mid)update(ls(p),pl,mid,L,R,g);
	if(R>mid)update(rs(p),mid+1,pr,L,R,g);
}
int query(int p,int pl,int pr,int pos)
{
	if(pl==pr)return tr[p].f(pos);
	int mid=(pl+pr)>>1;
	if(pos<=mid)return min(tr[p].f(pos),query(ls(p),pl,mid,pos));
	else return min(tr[p].f(pos),query(rs(p),mid+1,pr,pos));
}
int main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);
	cin>>n>>m; 
	for(int i=1;i<=n;i++)cin>>a[i];
	for(int i=1;i<=n;i++)s[i]=s[i-1]+a[i],v=max(v,s[i]);
	memset(f,INF,sizeof(f)); f[0][0]=0;
	for(int i=1;i<=n;i++)f[i][1]=s[i]*s[i];
	for(int l=2;l<=m;l++)
	{
		clear(1,1,v);
		for(int i=1;i<=n;i++)if(i>=l)
		{
			Line g=Line(-2*s[i-1],s[i-1]*s[i-1]+f[i-1][l-1],++cnt);
			update(1,1,v,1,v,g);
			f[i][l]=query(1,1,v,s[i])+s[i]*s[i];
		}
	}
	cout<<f[n][m]*m-s[n]*s[n]<<endl;
	return 0;
}
```

制作不易，望过审 QWQ。

---

## 作者：C20203030 (赞：0)

## 一、题目

[点此看题](https://www.luogu.org/problem/P4072)

## 二、解法

看题目中的这个方差很清奇，我们尝试对答案变形：

$\Rightarrow s^2 \cdot m^2=(\sum_{i=1}^{m} (v_i-\mu )^2)\cdot m$

$\Rightarrow s^2\cdot m^2=(\sum_{i=1}^{m}(vi^2+\mu^2-2v_i\mu))\cdot m$

$\Rightarrow s^2 \cdot m^2=m\cdot \sum_{i=1}^{m} v_i^2-sum\cdot sum$

其中$v_i$是第$i$的值之和，$sum$是全部值的和，我们发现答案只跟前面那一块有关系，故问题转化成了求 $\sum_{i=1}^{m}v_i^2$ 最小。

设$dp[i][j]$表示到第$i$个元素选了$j$块，所得到的最小值，则有转移：

$dp[i][j]=\min\{dp[k][j-1]+(sum[i]-sum[k])^2\}$

转移是$O(n^2m)$的，我们考虑优化。

1、发现$j$层只和$j-1$有关，上滚动数组。

2、手推优化式子，发现可以用斜率优化，经典搞法不多说。

上代码吧$qwq$。

```cpp
#include <cstdio>
#define int long long
const int MAXN = 3005;
int read()
{
    int x=0,flag=1;
    char c;
    while((c=getchar())<'0' || c>'9') if(c=='-') flag=-1;
    while(c>='0' && c<='9') x=(x<<3)+(x<<1)+(c^48),c=getchar();
    return x*flag;
}
int n,m,cur,sum[MAXN],dp[2][MAXN];
int up(int j,int k)
{
    return dp[cur^1][j]-dp[cur^1][k]+sum[j]*sum[j]-sum[k]*sum[k];
}
int down(int j,int k)
{
    return sum[j]-sum[k];
}
signed main()
{
    n=read();
    m=read();
    for(int i=1; i<=n; i++)
        sum[i]=sum[i-1]+read();
    for(int i=1; i<=n; i++)
        dp[0][i]=sum[i]*sum[i];
    for(int k=2; k<=m; k++)
    {
        cur^=1;
        int head=1,tail=0,q[MAXN]= {};
        for(int i=1; i<=n; i++)
        {
            while(head<tail && up(q[head+1],q[head])<2*sum[i]*down(q[head+1],q[head])) head++;
            dp[cur][i]=dp[cur^1][q[head]]+(sum[i]-sum[q[head]])*(sum[i]-sum[q[head]]);
            while(head<tail && up(i,q[tail])*down(q[tail],q[tail-1])<up(q[tail],q[tail-1])*down(i,q[tail])) tail--;
            q[++tail]=i;
        }
    }
    printf("%lld\n",m*dp[cur][n]-sum[n]*sum[n]);
}


```



---

## 作者：crashed (赞：0)

# 题目
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[点这里](https://www.luogu.org/problem/P4072)看题目。
# 分析
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要解决这个问题，我们就先得化式子。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要化式子，我们就要知道，方差是什么。   
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这道题中，设$\{d_m\}$为一个长度为$m$的数列，第$i$项表示第$i$天走的路程；$a=\frac {\sum_{i=1}^md_i} m$。则$v=\frac {\sum_{i=1}^m(d_i-a)^2}{m}$。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以下是化式子的部分：  
&nbsp;&nbsp;$\displaystyle \Rightarrow vm^2=m\left(\sum_{i=1}^m(d_i-a)^2\right)$  
&nbsp;&nbsp;$\displaystyle \Rightarrow vm^2=m\left(\sum_{i=1}^m(d_i^2-2ad_i+a^2)\right)$  
&nbsp;&nbsp;$\displaystyle \Rightarrow vm^2=m\left(\sum_{i=1}^md_i^2-2a\sum_{i=1}^md_i+ma^2\right)$  
&nbsp;&nbsp;$\displaystyle \Rightarrow vm^2=m\sum_{i=1}^md_i^2-2ma\sum_{i=1}^md_i+m^2a^2$  
&nbsp;&nbsp;$\displaystyle \Rightarrow vm^2=m\sum_{i=1}^md_i^2-\left(\sum_{i=1}^md_i\right)^2$  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设第$i$段路长度为$b_i$，则可知$\sum_{i=1}^nb_i=\sum_{i=1}^md_i$  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;即：  
&nbsp;&nbsp;$\displaystyle \Rightarrow vm^2=m\sum_{i=1}^md_i^2-\left(\sum_{i=1}^nb_i\right)$  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此时发现，只有$\sum_{i=1}^md_i^2$是不确定的，于是考虑$DP$求出其最小值。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$DP(j,i)$：前$i$段路分为$j$天的行程的最小$\sum_{k=1}^jd_k^2$。  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设$s_i=\sum_{j=1}^ib_j$转移如下：  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$\displaystyle DP(j,i)=\min_{0\le k<i}\{DP(j-1,k)+(s_i-s_k)^2\}$  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;暴力$DP$就有$70$分。观察式子，目测可以斜率优化：  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;若$k_1<k_2$，且$k_1$转移比$k_2$更优：  
&nbsp;&nbsp;$\displaystyle \Rightarrow DP(j-1,k_1)+(s_i-s_{k_1})^2<DP(j-1,k_2)+(s_i-s_{k_2})^2$   
&nbsp;&nbsp;$\displaystyle \Rightarrow DP(j-1,k_1)+s_i^2-2s_is_{k_1}+s_{k_1}^2<DP(j-1,k_2)+s_i^2-2s_is_{k_2}+s{k_2}^2$  
&nbsp;&nbsp;$\displaystyle \Rightarrow (DP(j-1,k_1)+s_{k_1}^2)-(DP(j-1,k_2+s_{k_2}^2))<2s_i(s_{k_1}-s_{k_2})$  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设$Y(j,i)=DP(j-1,i)+s_i^2,X(i)=s_i$，则：  
&nbsp;&nbsp;$\displaystyle \Rightarrow \frac{Y(j,k_1)-Y(j,k_2)}{X(k_1)-X(k_2)}>2s_i$  
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;也就是说，如果两点斜率$>2s_i$，则前面的决策点更优，否则就是后面的更优。通过这个性质可以知道应该维护一个下凸包。用单调队列维护即可。  
# 代码
```cpp
#include <cstdio>
#include <cstring>

typedef long long LL;

const int MAXN = 3005, MAXM = 3005;

template<typename _T>
void read( _T &x )
{
	x = 0;char s = getchar();int f = 1;
	while( s > '9' || s < '0' ){if( s == '-' ) f = -1; s = getchar();}
	while( s >= '0' && s <= '9' ){x = ( x << 3 ) + ( x << 1 ) + ( s - '0' ), s = getchar();}
	x *= f;
}

template<typename _T>
void write( _T x )
{
	if( x < 0 ){ putchar( '-' ); x = ( ~ x ) + 1; }
	if( 9 < x ){ write( x / 10 ); }
	putchar( x % 10 + '0' );
}

template<typename _T>
_T MIN( const _T a, const _T b )
{
	return a < b ? a : b;
}

struct deque
{
	int q[MAXN];
	int h, t;
	int& operator [] ( const int indx ) { return q[indx]; }
	deque(){ h = 1, t = 0; }
	void clear(){ h = 1, t = 0; }
	int front() const { return q[h]; }
	int back() const { return q[t]; }
	void push_front( const int val ){ q[--h] = val; }
	void push_back( const int val ){ q[++t] = val; }
	void pop_front(){ h ++; }
	void pop_back(){ t --; }
	bool empty() const { return h > t; }
	int siz() const { return t - h + 1; }
}deq;

struct vector
{
	LL x, y;
	vector(){}
	vector( const LL X, const LL Y ){ x = X, y = Y; }
	LL mul( const vector & other ) const { return x * other.y - other.x * y; }
	bool operator > ( const vector & other ) const { return mul( other ) < 0; }
	bool operator < ( const vector & other ) const { return mul( other ) > 0; }
	bool operator >= ( const vector & other ) const { return mul( other ) <= 0; }
};

int DP[MAXM][MAXN];
int a[MAXN], s[MAXN];
int N, M;

LL Y( const int stage, const int k )
{
	return DP[stage - 1][k] + s[k] * s[k];
}

LL X( const int k )
{
	return s[k];
}

LL get( const int stage, const int i, const int k )
{
	return DP[stage - 1][k] + ( s[i] - s[k] ) * ( s[i] - s[k] );
}

int main()
{
	read( N ), read( M );
	for( int i = 1 ; i <= N ; i ++ ) read( a[i] ), s[i] = s[i - 1] + a[i];
	memset( DP, 0x3f, sizeof( DP ) );
	DP[0][0] = 0;
	for( int j = 1 ; j <= M ; j ++ )
	{
		deq.clear();
		deq.push_back( 0 );
		for( int i = 1 ; i <= N ; i ++ )
		{
			while( deq.siz() > 1 && Y( j, deq.front() ) - Y( j, deq[deq.h + 1] ) >= 2 * s[i] * ( X( deq.front() ) - X( deq[deq.h + 1] ) ) ) deq.pop_front();
			DP[j][i] = get( j, i, deq.front() );
			while( deq.siz() > 1 && vector( X( deq.back() ) - X( deq[deq.t - 1] ), Y( j, deq.back() ) - Y( j, deq[deq.t - 1] ) ) >= vector( X( i ) - X( deq.back() ), Y( j, i ) - Y( j, deq.back() ) ) ) deq.pop_back();
			deq.push_back( i );
		}
	}
	write( 1ll * M * DP[M][N] - s[N] * s[N] ), putchar( '\n' );
	return 0;
}
```

---

## 作者：ljk123 (赞：0)

# 征途题解
恶心题。~~我太弱了~~

回到正题，

$v^2=\frac{\sum_{i=1}^m(v_{i}-\bar{v})^2}{m}$

$v^2*m^2=m*\sum_{i=1}^m(v_{i}-\bar{v})^2$

将每个式子拆开：

$m*(v_{i}-\bar{v})^2$

$m*({v_{i}}^2+{\bar{v}}^2-2*\frac{v_{i}*\sum_{k=1}^{m}v_{i}}{m})$

$m*({v_{i}}^2+({\frac{\sum_{k=1}^{m}v[k]}{m}})^2-2*\frac{v_{i}*\sum_{k=1}^{m}v_{i}}{m})$

$m*{v_{i}}^2+(\frac{\sum_{k=1}^{m}v[k]}{m})^2-2*v_{i}*\sum_{k=1}^{m}v_{i}$

合起来，运用乘法分配律，即为：

$v^2*m^2=m*\sum_{i=1}^{m}{v_{i}}^2+(\sum_{i=1}^{m}v_{i})^2-2*\sum_{i=1}^{m}v_{i}*\sum_{i=1}^{m}v_{i}$

$v^2*m^2=m*\sum_{i=1}^{m}{v_{i}}^2-(\sum_{i=1}^{m}v_{i})^2$

后面一项为常数,为路程总和,

便设$f[k][i]$为走了前$i$段路分配完前$k$天的最小平方和，设路程前缀和为$sum$，则：

暴力DP方程为:

$f[k][i]=max f[k-1][j]+(sum[i]-sum[j])^2$

拆平方项，移项：

$f[k-1][j]+sum[j]^2=2*sum[i]*sum[j]+f[k][i]-sum[i]^2$

$\bullet y=f[k-1][j]+sum[j]^2$

$\bullet k=2*sum[i]$

$\bullet x=sum[j]$

$\bullet b=f[k][i]-sum[i]^2$

维护一个单调的下凸壳即可,可以用循环队列节省空间。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=3006;
int n,m,t,head,tail,o=0,sum[N],f[2][N];
struct point{int x,y;}tmp,q[N];
inline int read(){
   int T=0,F=1; char ch=getchar();
   while(ch<'0'||ch>'9'){if(ch=='-') F=-1; ch=getchar();}
   while(ch>='0'&&ch<='9') T=(T<<3)+(T<<1)+(ch-48),ch=getchar();
   return F*T;
}
bool check(point u,point v,int z){return v.y-u.y<=2*sum[z]*(v.x-u.x);}
bool check2(point u,point v,point z){return (v.y-u.y)*(z.x-v.x)>=(z.y-v.y)*(v.x-u.x);}
int main(){
    n=read(),m=read(),f[0][0]=0;
    for(int i=1;i<=n;++i) t=read(),sum[i]=sum[i-1]+t,f[o][i]=sum[i]*sum[i];
    for(int j=2;j<=m;++j){
        o^=1,q[1].x=0,q[1].y=0,head=tail=1;
        for(int i=1;i<=n;++i){
            while(head<tail&&check(q[head],q[head+1],i)) ++head;
            f[o][i]=q[head].y-2*sum[i]*q[head].x+sum[i]*sum[i],tmp.x=sum[i],tmp.y=f[o^1][i]+sum[i]*sum[i];
            while(head<tail&&check2(q[tail-1],q[tail],tmp)) --tail;
            q[++tail]=tmp;
        }
    }
    t=f[o][n]*m-sum[n]*sum[n];
    printf("%d\n",t);
    return 0;
}
```

---

## 作者：cold_cold (赞：0)

 [安利一波博客](https://www.cnblogs.com/cold-cold/p/10131510.html)

这道题特别坑

状态转移是 f[i][k+1]=f[j][k]+(sum[i]-sum[j])*(sum[i]-sum[j]);

转换后变为 f[j][k]+sum[j]\*sum[j]=f[i][k+1]+2\*sum[i]*sum[j];

但是我在这里要说的是一个初值的问题

通常情况下斜率优化的题目都是不需要赋初值的

但因为f[i][1]全都为0，所以导致后续dp值全部出错

所以我们应将f[i][2]赋上初值为sum[i]*sum[i]

 总体实现如下：
 
 ```cpp
#include <algorithm>
#include <iostream>
#include <cmath>
#include <cstring>
#include <map>
#include <string>
#include <vector>
#include <queue>
#include <stack>
#include <cstdio>
#include <cstdlib>
using namespace std;
typedef long long ll;
inline ll read()
{
    register ll p(1),a(0);register char ch=getchar();
    while((ch<'0'||ch>'9')&&ch!='-') ch=getchar();
    if(ch=='-') p=-1,ch=getchar();
    while(ch>='0'&&ch<='9') a=a*10+ch-48,ch=getchar();
    return a*p;
}
//f[i][k+1]=f[j][k]+(sum[i]-sum[j])*(sum[i]-sum[j]);
//f[j][k]+sum[j]*sum[j]=f[i][k+1]+2*sum[i]*sum[j];
const ll N=3010;
ll n,kk,f[N][N],sum[N],Q[N],head=0,tail=0;
inline double getx(int x){return sum[x];}
inline double gety(int x,int now){return f[x][now]+sum[x]*sum[x];}
inline double che(int x,int y,int now){return (gety(y,now)-gety(x,now))/(getx(y)-getx(x));}
int main()
{
//    freopen("input","r",stdin);
//    freopen("output","w",stdout);
    n=read(),kk=read();
    for(register int i=1;i<=n;i++) sum[i]=sum[i-1]+read(),f[i][2]=sum[i]*sum[i];
    
    for(register int k=2;k<=kk;k++,head=tail=0)
        for(register int i=1,j;i<=n;i++)
            {
                while(head<tail&&che(Q[head],Q[head+1],k)<2*sum[i]) ++head;
                j=Q[head];f[i][k+1]=f[j][k]+(sum[i]-sum[j])*(sum[i]-sum[j]);
                while(head<tail&&che(Q[tail-1],Q[tail],k)>che(Q[tail],i,k)) --tail;
                Q[++tail]=i;
            }
    printf("%lld\n",f[n][kk+1]*kk-sum[n]*sum[n]);
    return 0;
}
/*
 
*/
```

---


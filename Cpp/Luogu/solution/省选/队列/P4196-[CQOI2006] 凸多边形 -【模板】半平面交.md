# [CQOI2006] 凸多边形 /【模板】半平面交

## 题目描述

逆时针给出 $n$ 个凸多边形的顶点坐标，求它们交的面积。例如 $n=2$ 时，两个凸多边形如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/7ieux7g3.png)

则相交部分的面积为 $5.233$。

## 说明/提示

对于 $100\%$ 的数据：$2 \leq n \leq 10$，$3 \leq m_i \leq 50$，每维坐标为 $[-1000,1000]$ 内的整数。

## 样例 #1

### 输入

```
2
6
-2 0
-1 -2
1 -2
2 0
1 2
-1 2
4
0 -3
1 -1
2 2
-1 0```

### 输出

```
5.233```

# 题解

## 作者：Grisses (赞：25)

# upd:

2023/7/28 图炸了，补一下

---


[题面](https://www.luogu.com.cn/problem/P4196)

**建议放大 $150\%$ 食用 ~~（否则看不清别怪我）~~**

**蒟蒻第一篇算为详细的题解，讲得不够清楚的还望多多包涵。**

首先，看看题目名称，就能知道本题是一道半平面交的模板题。

## 一、定义

### 1、半平面

一条直线和直线的一侧。半平面是一个点集，因此是一条直线和直线的一侧构成的点集。当包含直线时，称为闭半平面；当不包含直线时，称为开半平面。

解析式一般为 $Ax+By+C\ge0$ 或 $Ax+By+C>0$。

如下图黄色部分就是解析式为 $Ax+By+C>0$ 的半平面。

![](https://oi-wiki.org/geometry/images/hpi1.svg)

### 2、半平面交

几个半平面的交集。因为半平面是点集，所以半平面交也是点集。

## 二、解法（S&I 算法）

### 1、前置

#### （一）直线

这里用向量来表示直线，半平面为向量的左侧部分。

#### （二）求交点

对于 $\vec{a}(start_{\vec{a}},end_{\vec{a}})$ 和 $\vec{b}(start_{\vec{b}},end_{\vec{b}})$ 两个向量表示的直线的交点 O，有：
$$x_O=(S_1\times x_{start_{\vec{b}}}-S_2\times x_{end_{\vec{b}}})/(S_1-S_2)$$
$$y_O=(S_1\times y_{start_{\vec{b}}}-S_2\times y_{end_{\vec{b}}})/(S_1-S_2)$$

其中 $S_1,S_2$ 分别为 $(end_{\vec{b}}-start_{\vec{a}})\times(end_{\vec{a}}-start_{\vec{a}})$ 和 $(start_{\vec{b}}-start_{\vec{a}})\times(end_{\vec{a}}-start_{\vec{a}})$（向量叉积）。

##### 证明：

![](https://cdn.luogu.com.cn/upload/image_hosting/0kq4bohi.png)

由[共边定理](https://baike.baidu.com/item/%E5%85%B1%E8%BE%B9%E5%AE%9A%E7%90%86/5508944?fr=aladdin)可得：$\dfrac{end_{\vec{b}}\,O}{O\,start_{\vec{b}}}=\dfrac{S_1}{S_2}$（有向线段长和有向面积）。然后又因为 $S_1,S_2$ 是用向量叉积算的所以满足条件。得证。

#### （三）凸包

如果您不会凸包的话，这边建议出门左转[二维凸包](https://www.luogu.com.cn/problem/P2742)。

#### （四）极角

极角就是向量与 $x$ 轴的夹角（有向）。

对于一条起点和终点分别为 $A(x_A,y_A)$ 和 $B(x_b,y_b)$ 的向量所代表的直线，它的极角在 c++ 里表示为：
```cpp
atan2(y[B]-y[A],x[B]-x[A])
```
其实就是斜率。

### 2、算法实现

首先，我们先按极角给所有向量排序，极角小的排在前面，如果极角相同。因为我们求的是向量左侧的半平面的交集，所以优先选择靠左的半平面，用向量叉积判断即可。排序后，以极角为标准去下重。

然后，我们维护一个双端队列。双端队列用来存储目前所有用来表示半平面交的边的向量。对于每个向量，我们先对其检查，如果双端队列里后两条向量的交点在这条向量的右侧。那么，弹出双端队列的最后一条向量，直到满足要求为止。接下来，对双端队列前面的向量重复上述操作。再把当前向量插入双端队列。

最后，对双端队列内部的向量进行检验，弹出不合法的向量。再求面积就行了。

## 三、代码

```cpp
  #include<bits/stdc++.h>
  #define db double
  using namespace std;
  int n,cnt,tot,top,back;
  db ans;
  const db eps=1e-7;//因为是实数范围，有精度误差，所以不能直接用“==”，而是取绝对值和一个很小的值进行比对。
  struct node{
      db x,y;
      node(){}
      node(db _x,db _y){x=_x,y=_y;}
      bool operator<(const node &t)const{return y<t.y||(y==t.y&&x<t.x);}
      node operator-(node &t){return node(x-t.x,y-t.y);}
      bool operator==(const node &t)const{return x==t.x&&y==t.y;}
  }_P,N[55],Ans[505];//存储点
  db CPr(node A,node B){return A.x*B.y-A.y*B.x;}
  db CPr(node A,node B,node C){return CPr(B-A,C-A);}//向量叉积
  struct edge{
      node start,end;
      db angle;
      edge(){}
      edge(node A,node B){
          start=A,end=B;//起点和终点
          angle=atan2((B-A).y,(B-A).x);//极角
      }
      bool operator<(const edge &t)const{
          if(fabs(angle-t.angle)<=eps)return CPr(start,t.start,t.end)>0;//极角相同比位置
          return angle<t.angle;//否则比极角
      }
  }e[505],dq[505];//存储向量
  db S1,S2;
  node getnode(edge A,edge B){
      S1=CPr(A.start,B.end,A.end);
      S2=CPr(A.start,B.start,A.end);
      return node((S1*B.start.x-S2*B.end.x)/(S1-S2),(S1*B.start.y-S2*B.end.y)/(S1-S2));
  }
  bool ch(edge A,edge B,edge C){
      _P=getnode(B,C);
      return CPr(_P,A.start,A.end)<0;
  }//求交点
  signed main()
  {
      scanf("%d",&n);
      for(int i=1,m;i<=n;i++){
          scanf("%d",&m);
          for(int j=1;j<=m;j++)scanf("%lf%lf",&N[j].x,&N[j].y);
          for(int j=1;j<=m;j++)e[++cnt]=edge(N[j],N[j%m+1]);//读点，构建向量
      }
      sort(e+1,e+cnt+1);//排序
      tot=1;
      for(int i=2;i<=cnt;i++)if(fabs(e[i].angle-e[i-1].angle)>eps)e[++tot]=e[i];//去重
      top=2,back=1;
      dq[1]=e[1];
      dq[2]=e[2];
      for(int i=3;i<=tot;i++){
          while(back<top&&ch(e[i],dq[top],dq[top-1]))top--;
          while(back<top&&ch(e[i],dq[back],dq[back+1]))back++;
          dq[++top]=e[i];//增量
      }
      while(back<top&&ch(dq[back],dq[top-1],dq[top]))top--;
      while(back<top&&ch(dq[top],dq[back],dq[back+1]))back++;//弹出不合法的向量
      for(int i=back;i<top;i++)Ans[i-back+1]=getnode(dq[i],dq[i+1]);//求交点
      if(top-back>1)Ans[top-back+1]=getnode(dq[top],dq[back]);
      tot=top-back+1;
      for(int i=1;i<=tot;i++)ans+=CPr(Ans[i],Ans[i%tot+1]);//算面积
      printf("%.3lf",fabs(ans)/2);
      return 0;
  }
```

---

## 作者：suxxsfe (赞：24)

之前那个方法遇到相反但长度不相等的向量就死了，所以改了下（  

半平面交其他题解和 [oi-wiki](https://oi-wiki.org//geometry/half-plane/) 已经讲解比较充分，主要说一下判断无解的细节  
讨论区有人给出这样一组数据：  

```plaint
3
4
0 0
3 0
3 1
0 1
4
4 0
5 0
5 1
4 1
3
0 0
4 0
0 2
```  

现有题解唯一过的两篇一个是抄书一个是 $n^2$ 暴力（  

画出图来是有两个四边形只有一个公共点，所以答案应该为 $0$  
这种情况应该被判无解本质上是因为，有两个平行但反向的向量，且它们互相在对方的右边（此处默认一个向量左边的半平面是我们要取的）  

如何判？  
当要加入新的一条直线时，要把队列中每个与前一个向量交点在他右边的向量都踢出队列  
所以当加入某一个向量而导致出现这种情况时，队列中其他向量之间的交点必然在他的右边，所以它就已经把它右边的向量都弹掉了，那么与他平行且反向的那一个向量成为现在队列里的唯一一个  
于是在把当前的向量加入队列后，就只用判断队尾和队尾的前一个会不会构成这种情况即可  


于是就是：  

```cpp  
que[++right]=a[i];
if(abs(cross(que[right].way,que[right-1].way))<=eps){//平行
	if(onRight(que[right],que[right-1].p)&&dot(que[right].way,que[right-1].way)<=-eps) return 0;
	right--;
	if(!onRight(que[right],a[i].p)) que[right]=a[i];
}
```  

大概就是叉乘判平行，点乘判夹角大于 $90$ 度，于是就得出了反向  

数据比较水，建议去这两题进一步验证一下板子的正确性：[POJ2451 Uyuw's Concert
](http://poj.org/problem?id=2451) 和 [POJ1279 Art Gallery](http://poj.org/problem?id=1279)  

完整代码：  

```cpp  
#define N 100006
#define eps 1e-13
inline double abs(const double &a){return a>0?a:-a;}
struct Vector{
	double x,y;
	inline double len(){return std::sqrt(x*x+y*y);}
	inline void operator += (const Vector &a){x+=a.x;y+=a.y;}
	inline void operator -= (const Vector &a){x-=a.x;y-=a.y;}
	inline void operator *= (const double &a){x*=a;y*=a;}
	inline void operator /= (const double &a){x/=a;y/=a;}
};
inline Vector operator + (const Vector &a,const Vector &b){return (Vector){a.x+b.x,a.y+b.y};}
inline Vector operator - (const Vector &a,const Vector &b){return (Vector){a.x-b.x,a.y-b.y};}
inline Vector operator * (const Vector &a,const double &b){return (Vector){a.x*b,a.y*b};}
inline Vector operator / (const Vector &a,const double &b){return (Vector){a.x/b,a.y/b};}
inline double dot(const Vector &a,const Vector &b){return a.x*b.x+a.y*b.y;}
inline double cross(const Vector &a,const Vector &b){return a.x*b.y-a.y*b.x;}
struct Line{
	Vector p,way;
	double ang;
	inline void makeLine(const Vector &a,const Vector &b){p=a;way=b;ang=atan2(b.y,b.x);}
};
inline int onRight(const Line &a,const Vector &b){return cross(a.way,b-a.p)<=-eps;}
inline int cmp(const Line &a,const Line &b){return a.ang<b.ang;} 
inline Vector intersect(const Line &a,const Line &b){
	double x=cross(b.way,a.p-b.p)/cross(a.way,b.way);
	return a.p+a.way*x;
}
inline double polygonArea(int n,Vector *a){
	double S=0;
	for(reg int i=1;i<n;i++) S+=cross(a[i],a[i+1]);
	S+=cross(a[n],a[1]);
	return S/2;
}
int left,right;
Line que[N];
inline int halfPlane(int n,Line *a,Vector *p){
	std::sort(a+1,a+1+n,cmp);
	left=right=0;que[0]=a[1];
	for(reg int i=2;i<=n;i++){
		while(left<right&&onRight(a[i],p[right])) right--;
		while(left<right&&onRight(a[i],p[left+1])) left++;
		que[++right]=a[i];
		if(abs(cross(que[right].way,que[right-1].way))<=eps){//平行
			if(onRight(que[right],que[right-1].p)&&dot(que[right].way,que[right-1].way)<=-eps) return 0;
			right--;
			if(!onRight(que[right],a[i].p)) que[right]=a[i];
		}
		if(left<right) p[right]=intersect(que[right],que[right-1]);
	}
	while(left<right&&onRight(que[left],p[right])) right--;
	if(right-left<=1) return 0;
	p[left]=intersect(que[left],que[right]);
	return 1;
}
Vector p[N],in[N];
Line a[N];
int main(){
	int n=read(),o=0;
	while(n--){
		int m=read();
		for(reg int i=1;i<=m;i++) in[i].x=read(),in[i].y=read();
		for(reg int i=1;i<m;i++) a[++o].makeLine(in[i],in[i+1]-in[i]);
		a[++o].makeLine(in[m],in[1]-in[m]);
	}
	if(!halfPlane(o,a,p)) puts("0.000");
	else printf("%.3lf\n",polygonArea(right-left+1,p+left-1));
	return 0;
}
```

---

## 作者：bloodstalk (赞：5)

# 半平面交
## 一些定义
**直线**：$y = kx+b$。由初中知识知两点确定一条直线，这里以 $(0,b)$ 和 $(1,k+b)$ 确定一条**有向直线**，由 $(0,b)$ 指向 $(1,k+b)$。

**半平面**：直线**一侧**的平面就叫半平面，左半平面 $y \geq kx+b$(包含了这条直线上的点)，右半平面 $y < kx +b$，这里其实是向量的运算，$k$ 不能简单理解成斜率，具体比较麻烦，我们只需要确定一种定向方法并且确定我们要求的是哪一个半平面即可。

**半平面交**：多个半平面的相交部分，半平面是点集，半平面交肯定也是点集。

**半平面交应用**：求凸边形的面积交，求线性规划的可行域。

## 求解-S&I 算法
### 前置知识
**极角**：`C++` 中有一个库函数叫做 `atan2(double y,double x)`，返回的是一个角 $\theta \in (-\pi,\pi],\theta = \arctan \frac{y}{x}$，这个角其实就是这个直线与 $x$ 轴的夹角。

### 算法流程
1. 给这些边的方向定为逆时针方向，这样，左平面的交就是半平面交。对这些边按照极角从小到大排序，对于极角相同的两条直线，把靠内的放在前面（靠内的面积肯定是小的）。

2. 用双端队列维护边集，逆时针加边。先维护队尾再维护队头。

具体内容见代码，这里以[模板题](https://www.luogu.com.cn/problem/P4196)为例：
```cpp
#include<bits/stdc++.h>
//#define int long long
#define ll long long
#define next nxt
#define re register
#define il inline
const int N = 5e2 + 5;
const double eps = 1e-6;
const double Pi = acos(-1.0);
using namespace std;

struct Point{
	double x,y;
}p[N];
struct Line{
	Point s,e;
}a[N],q[N];
int n,m,cnt,k;
double res;

il int read()
{
	int f=0,s=0;
	char ch=getchar();
	for(;!isdigit(ch);ch=getchar()) f |= (ch=='-');
	for(; isdigit(ch);ch=getchar()) s = (s<<1) + (s<<3) + (ch^48);
	return f ? -s : s;
}

Point operator +(Point a,Point b) { return Point{a.x+b.x,a.y+b.y}; }//加

Point operator -(Point a,Point b) { return Point{a.x-b.x,a.y-b.y}; }//减

Point operator *(Point a,double b) { return Point{a.x*b,a.y*b}; }//数乘

il double operator *(Point a,Point b) { return a.x*b.y - a.y*b.x; }//叉积

il double Angle(Line a) { return atan2(a.e.y-a.s.y,a.e.x-a.s.x); }//夹角

Point GetNode(Line a,Line b)//求交点
{
	Point u = a.e - a.s , v = b.e - b.s , w = a.s - b.s;
	double t = w*v / (v*u);
	return a.s + u*t;
}

il bool cross(Line a,Line b,Line c)//判断b和c的交点是否在直线a的右侧
{
	Point p = GetNode(b,c);
	return (a.e-a.s)*(p-a.s) < 0;
}

il bool cmp(Line a,Line b)
{
	double A = Angle(a) , B = Angle(b);
	return fabs(A-B) > eps ? A < B : (a.e-a.s)*(b.e-a.s) < 0;
}

il double HalfPlane()
{//共有cnt条边
	sort(a+1,a+cnt+1,cmp);
	int head = 1 , tail = 1; q[1] = a[1];
	for(re int i=2;i<=cnt;i++)
	{
		if(Angle(a[i]) - Angle(a[i-1]) < eps) continue;
		while(head < tail && cross(a[i],q[tail],q[tail-1])) tail--;
		while(head < tail && cross(a[i],q[head],q[head+1])) head++;
		q[++tail] = a[i];
	}
	while(head < tail && cross(q[head],q[tail],q[tail-1])) tail--;
	q[++tail] = q[head];
	for(re int i=head;i<tail;i++) p[++k] = GetNode(q[i],q[i+1]);
	for(re int i=1;i<=k;i++) res += p[i]*p[i%k+1];
	return res/2;
}

int main()
{
	...
}

```

这里 `Line` 结构体就是存储的一条边的起点和终点。我们一个函数一个函数解释，那些向量的基础内容就不再说明。

**Angle函数**

运用 `atan2` 函数求极角。

**GetNode函数**

这个其实也算是基础内容，知道了一条直线的两个点，很容易能够转化成点向式。

**cmp 函数**

先是比较极角，把小的放前面，这样就是一个逆时针的顺序了。

如果极角相同，靠左的放在前边，这里的左是有方向的左，注意辨别。

来张图：

![](https://cdn.luogu.com.cn/upload/image_hosting/z3f5qba6.png)

运用叉积的相关性质，如果 `(a.e-a.s)*(b.e-a.s) < 0`，那么就能说明 $b$ 在 $a$ 的右侧，我们就可以通过这个来判断位置关系。

**cross 函数**

这个其实和 cmp 函数类似。先用 GetNode 函数求解 $b$ 和 $c$ 的交点，再判断这个交点和 $a$ 的位置关系，原理和上面 cmp 的原理是一样的，将交点类比成 $b.e$ 即可。

**HalfPlane 函数**

这个其实就是求解的主函数。

首先按极角排序一下，先把第一条直线放进双端队列内，然后开始枚举直线。

开始的第一个 `if` 就是把极角序相同的排除掉，由于我们已经在排序的时候已经把最靠左的极角序相同的放到前面，所以后面那些靠右的就不用考虑。

接下来就是重头戏，先维护队尾，再维护队头，把交点在当前直线的右边的弹出。

画个图理解一下：
![](https://cdn.luogu.com.cn/upload/image_hosting/gff33r39.png)

假设我们现在要加入第四条边。我们可以看到，$2$ 和 $3$ 的交点在 $4$ 的右边，这也就说明 $3$ 和其它直线交的范围要比 $4$ 和其他直线交的范围多，这也就说明 $3$ 是需要被弹出的。由于按极角排序了，所以不会出现有些地方是 $4$ 交到而 $3$ 没交到的，所以 $3$ 一定要弹出。对于队头也是同理的。

最后在循环结束的时候还会清空一次队尾，考虑这种情况。
![](https://cdn.luogu.com.cn/upload/image_hosting/dtufnblp.png)

在 $6$ 加进去以后，我们可以发现都是合法的，但是我们把第一条直线延伸一下就能发现端倪：$6$ 是多余的，因此在函数最后，我们要去除多余的队尾。而队头是不会多余的，因为在循环里的第二个 `while` 里已经判断了。

再考虑为什么先队尾后队头，再考虑一种情况：
![](https://cdn.luogu.com.cn/upload/image_hosting/ltvzjlnh.png)

如果我们先队头后队尾，那么最终只会剩下 $3,4$ 两条边，围成的面积就是 $\angle AOD$ 围成的面积；如果先队尾后队头，那么就剩下 $1,4$ 两条边，围成的面积 $\angle CBD$ 围成的面积，显然，正确的应该是 $\angle CBD$ 围成的面积。

----
由此，我们就能得出全部的对半平面交有用的边了，通过再次调用 GetNode 函数，我们就可以得出边之间的交点，从而能够求出半平面交的面积。

---

## 作者：_saltFish_ (赞：3)

[博客园食用效果更佳](https://www.cnblogs.com/ytxy-bolg/articles/17045942.html)。

题目传送门：[洛谷](https://www.luogu.com.cn/problem/P4196)。

# 简要题意

逆时针给出 $n$ 个二维多边形的顶点坐标，求他们交的面积结果保留三位小数。

$2 \le n \le 10,3 \le m_i \le 50$，$m_i$ 表示第 $i$ 个多边形的边数。保证每维坐标为 $[-1000,1000]$ 中的整数。

# 解题思路

下设 $a=\sum\limits_{i =1}\limits^nm_i$。

半平面交模板题，对于这一题可以考虑暴力 $\mathcal{O}(a^2)$ 求解。但是这样并不能通过大部分的半平面交题目。

我们需要考虑更优的做法。有两种：分治、双端队列。它们的时间复杂度相同，但是分治的常数以及实现难度都高于双端队列做法，~~那我要他作甚~~。

这两种做法的时间复杂度都是 $\mathcal{O}(a\log_2a)$

所以本文只涉及双端队列做法，~~还不是笔者太弱不会分治做法~~。

# 双端队列求解半平面交问题

既然你来了这里笔者默认你已经学会了二维凸包，如果不会的话请出门右转[二维凸包](https://www.luogu.com.cn/problem/P2742)。

- 首先，不妨假设直线的左侧（如果你想，右边也不是不行）是半平面，在对直线进行极角排序后我们进行“去重”，保留极角相同的直线中最靠左的（即限制最严格的）。

- 下一步，扫描一遍所有直线，如果队首的两条直线的交点在当前直线的右侧，则从队首删除一条直线，队尾做同样的操作。接着将当前直线压入队尾。

- 完成了上面一步可能还不行，因为队首的交点可能还会在队尾直线的右侧，所以还要删除不合法的，队尾同理（虽然可能并不需要，但保险起见）。

- 最后我们就可以得到围出半平面交的所有直线，计算交点，用叉积求面积即可。

# 代码实现

```cpp
#include <iostream>
#include <algorithm>
#include <cmath>
using namespace std;

const double eps = 1e-8;//避免浮点数误差
const int N = 504;
int n, cnt, tot;
double sum;

struct node {
    double x, y;
    node(double x = 0, double y = 0):
    x(x), y(y){}
    node operator - (node &b) {
        return node(x - b.x, y - b.y);
    }
} nod[N], ans[N];

double cross(node a, node b) {
    return (a.x * b.y - a.y * b.x);//两点的叉积
}
double cross(node a, node b, node c) {
    return cross(b - a, c - a);
}

struct edge {
    node start, end;
    double angle;//极角
    edge(node start = node(), node end = node()):
    start(start), end(end), angle(atan2((start - end).y, (start - end).x)){}
    bool operator < (const edge &b) const {//极角排序的比较
        if(fabs(angle - b.angle) <= eps) return cross(start, b.start, b.end) > 0;
        return angle < b.angle;//极角相同的优先把左边的放在前面（否则去重的时候会出现一些“小问题”）
    }
} e[N], deq[N];

node getnode(edge a, edge b){//两直线的计算交点
    double s1 = cross(a.start, b.end, a.end);
    double s2 = cross(a.start, b.start, a.end);
    return node((s1 * b.start.x - s2 * b.end.x) / (s1 - s2), (s1 * b.start.y - s2 * b.end.y) / (s1 - s2));
}
bool check(edge a, edge b, edge c){
    node p = getnode(b, c);
    return cross(p, a.start, a.end) < 0;//判断b,c直线的交点是否在a直线的右侧
}
void HalfPlane() {//半平面交
    sort(e + 1, e + cnt + 1);
    tot = 1;
    for(int i = 2; i <= cnt; i++)
        if(fabs(e[i].angle - e[i - 1].angle) > eps)
            e[++tot] = e[i];
    int top = 2, back = 1;
    deq[1] = e[1];
    deq[2] = e[2];
    for(int i = 3; i <= tot; i++){
        while(back < top && check(e[i], deq[top], deq[top - 1])) top--;
        while(back < top && check(e[i], deq[back], deq[back + 1])) back++;
        deq[++top] = e[i];
    }
    while(back < top && check(deq[back], deq[top], deq[top - 1])) top--;
    while(back < top && check(deq[top], deq[back], deq[back + 1])) back++;
    for(int i = back; i < top; i++)
        ans[i - back + 1] = getnode(deq[i], deq[i + 1]);
    if(top - back + 1 > 2)//可能会出现半平面交的面积为0的情况，所以需要判断是否有2条以上的直线围出了半平面交
        ans[top - back + 1] = getnode(deq[top], deq[back]);
    tot = top - back + 1;
}

int main() {
    scanf("%d", &n);
    for(int i = 1; i <= n; i++){
        int m; 
        scanf("%d", &m);
        for(int j = 1; j <= m; j++)
            scanf("%lf%lf", &nod[j].x, &nod[j].y);
        for(int j = 1; j <= m; j++)
            e[++cnt] = edge(nod[j], nod[j % m + 1]);
    }
    HalfPlane();
    for(int i = 1; i <= tot; i++)
        sum += cross(ans[i], ans[i % tot + 1]);//通过叉积计算面积
    printf("%.3lf", fabs(sum) / 2);
}
/*
*/
```

---

## 作者：lizexuanaibiancheng (赞：2)

其实半平面交的情况有很多种：

1. 空集
2. 一个点
3. 一条线段
4. 一条射线
5. 一条直线
6. 封闭的凸多边形
7. 开放凸多边形连续的一部分（比如一个角）
8. 两条平行线之间的部分
9. 整个平面

先把所有直线按极角排序。定义第 $i$ 条直线为 $l_i$，极角为 $a_{i}$。令 $l_{n+1} = l_{1},a_{n+1} = a_{1}+2\pi$。统计相邻两条直线之间的角度取 $(0..2\pi]$ 的值，有多少个角度 $\ge \pi$：

+ 有两处：必然只有平行反向的两条，两处差均 $ = \pi$，对应情况 1. 5. 8.

+ 有一处：差 $\ge \pi$ 的位置必然无法“封口”，对应情况 1. 4. 7.

+ 有零处：不出现相邻两条直线极角差超过 $\pi$ 的情况，对应情况 1. 2. 3. 6.

+ 没有直线：对应情况 1.

因为题目的特殊性质，这样的情况只有零处，只考虑情况 1. 2. 3. 6.

考虑把所有直线加入栈中，判断直线要不要。

（以下红线为栈顶的后一个，黄线为栈顶，蓝线为新加入的直线，粉色部分表示半平面交的答案，看黄线是否会被删掉）

![](https://cdn.luogu.com.cn/upload/image_hosting/y47an6tq.png)

红线与黄线的交点在蓝线左侧，所以不删。

![](https://cdn.luogu.com.cn/upload/image_hosting/l6ked877.png)

红线与黄线的交点在蓝线右侧，所以把黄线删了。

通过这个简单的算法后，会有一个问题产生：最后答案的首尾有可能会不满足以上算法。就像这样：（红线为答案的第一项，蓝线为最后一项）

![](https://cdn.luogu.com.cn/upload/image_hosting/s3gguit9.png)

定义答案数组为 $p$，当前答案的第一项为 $l$，最后一项为 $r$，那么只会有 $p_{r} \to p_{l} \to p_{l+1}$ 或 $p_{r-1} \to p_{r} \to p_{l}$ 不满足上面的算法，弹掉即可。因为不止弹一次，所以走指针。

因为题目的特殊性质，算法到这里就完了。但是如果是求半平面交，就还有还需要在上面的算法考虑：**任何一步出现答案序列中相邻直线极角差 $\ge \pi$ 则说明交集是空集**。这很重要。为什么？因为当前考虑的是初始直线相邻两项的角度（取 $(0..2\pi]$ 的值）均 $< \pi$，当发生这种情况，说明弹到只留了一条直线（一条直线弹不了），新加入直线就一定交出了空集。因此“原本极角差应该 $< \pi$ 的位置出现了极角差 $\ge \pi$”可以作为判交集为空集的条件。（可以自行画图分析）

code:
```cpp
#include<bits/stdc++.h>
#define ld long double
#define int long long
using namespace std;
const int N = 2010;
const ld eps = 1e-12,PI = acos((ld)-1.0),INF = 1e18;
inline bool zero(ld x){
	return fabs(x) <= eps;
}struct Vector{
	ld x,y;
}point[N];
inline bool operator == (const Vector &a,const Vector &b){          // 相等
	return (zero(a.x-b.x) && zero(a.y-b.y));
}inline Vector operator + (const Vector &a,const Vector &b){        // 向量加
	return (Vector){a.x+b.x,a.y+b.y};
}inline Vector operator - (const Vector &a){                        // 取反
	return (Vector){-a.x,-a.y};
}inline Vector operator - (const Vector &a,const Vector &b){        // 向量减
	return a+(-b);
}inline ld dot(const Vector &a,const Vector &b){                    // 点乘
	return a.x*b.x+a.y*b.y;
}inline ld cross(const Vector &a,const Vector &b){                  // 叉乘
	return a.x*b.y-a.y*b.x;
}inline ld sqr(const Vector &a){                                    // 模长
	return sqrt(dot(a,a));
}inline Vector operator * (const Vector &a,const ld &b){            // 向量实数乘
	return (Vector){a.x*b,a.y*b};
}inline Vector operator * (const ld &a,const Vector &b){            // 同上
	return b*a;
}inline Vector operator * (const Vector &a,const Vector &b){        // 向量复数乘
	return (Vector){a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x};
}inline Vector operator / (const Vector &a,const ld &b){            // 向量实数除
	return (Vector){a.x/b,a.y/b};
}inline Vector operator / (const Vector &a,const Vector &b){        // 向量复数除
	return (Vector){a.x*b.x+a.y*b.y,-(a.x*b.y-a.y*b.x)}/sqr(b);
}inline Vector conj(const Vector &a){                               // 共轭
	return (Vector){a.x,-a.y};
}inline Vector norm(const Vector &a){                               // 模长归为一
	return a/sqr(a);
}inline ld arg(const Vector &a){                                    // 辐角（与x轴的角度）
	ld t = atan2(a.y,a.x);
	if(t < -PI+eps) return t+2*PI;
	else return t;
}struct Line{
	Vector p,v;
}tmp[N],line[N];
inline Vector q(const Line &a){                                     // 求直线上另一点
	return a.p+a.v;
}inline ld pos(const Line &a,const Vector &b){                      // 判断方向
	return cross(a.v,b-a.p);
}inline Vector inter(const Line &a,const Line &b){                  // 求直线的交点
	if(zero(cross(a.v,b.v))){
		return (Vector){INF,INF};
	}ld w1 = pos(a,b.p),w2 = -pos(a,q(b));
	return (w1*q(b) + w2*b.p) / (w1+w2);
};
ld angle[N];
int n,m,tot,sta[N];
signed main(){
	ios_base::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin >> n;
	int cut = 0,cnt = 0;
	for(int i = 1;i <= n;++i){
		Vector las,first,k;
		cin >> m >> first.x >> first.y;
		las = first;
		for(int j = 2;j <= m;++j){
			cin >> k.x >> k.y;
			tmp[++cnt] = (Line){las,k-las};
			las = k;
		}tmp[++cnt] = (Line){las,first-las};
	}
	sort(tmp+1,tmp+1+cnt,[&](Line &a,Line &b){
		if(zero(arg(a.v)-arg(b.v))) return pos(a,b.p) < -eps;
		else return arg(a.v) < arg(b.v);
	});//相同极角，优先获得其它直线左边的
	for(int i = 1;i <= cnt;++i){
		if(cut == 0 || arg(line[cut].v) < arg(tmp[i].v)-eps) line[++cut] = tmp[i],angle[cut] = arg(line[cut].v);
	}line[cut+1] = line[1];angle[cut+1] = angle[1]+2*PI;
	int cutS = 0;
	for(int i = 1;i <= cut;++i){
		ld w = angle[i+1]-angle[i];
		while(w <= 0) w += 2*PI;
		while(w > 2*PI) w -= 2*PI;
		cutS += (w >= PI);
	}
	if(cutS >= 1){      // 删了也能过
		cout << "0.000\n";
		return 0;
	}
	for(int i = 1;i <= cut;++i){
		while(tot >= 2 && pos(line[i],point[tot]) < -eps) tot--;
		sta[++tot] = i;point[tot] = inter(line[sta[tot-1]],line[sta[tot]]);
	}
	int l = 1,r = tot;
	while(r-l > 1){
		if(pos(line[sta[l]],point[r]) < -eps) r--;
		else if(pos(line[sta[r]],point[l+1]) < -eps) l++;
		else break;
	}point[l] = inter(line[sta[l]],line[sta[r]]);
	for(int i = l;i <= r;++i) angle[i] = arg(line[sta[i]].v);
	point[r+1] = point[l],angle[r+1] = angle[l]+2*PI;
	ld S = 0;
	cutS = 0; 
	for(int i = l;i <= r;++i){
		ld w = angle[i+1]-angle[i];
		while(w <= 0) w += 2*PI;
		while(w > 2*PI) w -= 2*PI;
		cutS += (w >= PI);
		S += cross(point[i],point[i+1]);
	}
	if(cutS >= 1){     // 删了也能过
		cout << "0.000\n";
		return 0;
	}
	cout << fixed << setprecision(3) << S*0.5L << "\n";
	return 0;
}
```

---

## 作者：Infinite_Eternity (赞：1)

# Description

[P4196 [CQOI2006]凸多边形 /【模板】半平面交](https://www.luogu.com.cn/problem/P4196)$~\&~$[题面 $\LaTeX$ 修缮](https://www.luogu.com.cn/paste/w9j9i7n5)

逆时针给出 $n$ 个凸多边形的顶点坐标，求它们交的面积。

数据范围：$2 \leq n \leq 10$，$3 \leq m_i \leq 50$。保证每维坐标为 $[-1000,1000]$ 内的整数。

# Analysis

半平面交模板题。

对于暴力半平面交，时间复杂度为 $\mathcal{O(n^2)}$，本题应该可以过。

这里讲解一下用双端队列求半平面交的方法：

- 首先，不妨设直线的右侧为半平面，那么把所有半平面按照直线的极角从小到大排序，极角相同的仅保留限制条件最严格的，即最右侧的。

- 接下来，利用排序去重以后，扫描一遍所有直线，判断队尾交点和队头交点分别是否在当前直线左端，若在，就踢出双端队列。然后再把当前半平面压入双端队列队尾。

- 最后，队尾的交点与队首可能不满足条件，因此还要踢掉队尾不合法的部分。

求面积的话直接上叉积就可以了。这样，时间复杂度降为 $\mathcal{O(n \log n)}$。

# Code

```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <algorithm>
#define eps 1e-9
#define N 510
using namespace std;
struct point
{
    double x , y;
    point() {}
    point(double a , double b) {x = a , y = b;}
    point operator+(const point &a)const {return point(x + a.x , y + a.y);}
    point operator-(const point &a)const {return point(x - a.x , y - a.y);}
    point operator*(const double &a)const {return point(a * x , a * y);}
}p[N];
struct line
{
    point p , v;
    double ang;
}a[N] , q[N] , c[N];
inline double cross(point a , point b) {return a.x * b.y - a.y * b.x;}
inline bool left(line a , point b) {return cross(a.v , b - a.p) > eps;}
inline point inter(line a , line b)
{
    point u = a.p - b.p;
    double tmp = cross(b.v , u) / cross(a.v , b.v);
    return a.p + a.v * tmp;
}
bool cmp(const line &a , const line &b)
{
    return fabs(a.ang - b.ang) < eps ? left(a , b.p) : a.ang < b.ang;
}
int main()
{
    int n , i , j , m , cnt = 0 , tot = 1 , l = 1 , r = 1;
    double ans = 0;
    scanf("%d" , &n);
    for(i = 1 ; i <= n ; i ++ )
    {
        scanf("%d" , &m);
        for(j = 1 ; j <= m ; j ++ ) scanf("%lf%lf" , &p[j].x , &p[j].y);
        for(j = 1 ; j <= m ; j ++ ) a[++cnt].p = p[j] , a[cnt].v = p[j] - p[j % m + 1] , a[cnt].ang = atan2(a[cnt].v.y , a[cnt].v.x);
    }
    sort(a + 1 , a + cnt + 1 , cmp);
    for(i = 2 ; i <= cnt ; i ++ )
        if(fabs(a[i].ang - a[i - 1].ang) > eps)
            a[++tot] = a[i];
    q[1] = a[1];
    for(i = 2 ; i <= tot ; i ++ )
    {
        while(l < r && left(a[i] , p[r - 1])) r -- ;
        while(l < r && left(a[i] , p[l])) l ++ ;
        q[++r] = a[i];
        if(l < r) p[r - 1] = inter(q[r - 1] , q[r]);
    }
    while(l < r && left(q[l] , p[r - 1])) r -- ;
    p[r] = inter(q[l] , q[r]) , p[r + 1] = p[l];
    for(i = l ; i <= r ; i ++ ) ans += cross(p[i] , p[i + 1]);
    printf("%.3lf\n" , ans / 2);
    return 0;
}
```

---

## 作者：Lagerent (赞：0)

## 半平面交

### 0.前言

关于我写代码的一些习惯与声明：

```
typedef pair<double, double> PDD;

#define x first
#define y second

struct Line {
    PDD st, ed;
}line[N];

PDD operator - (PDD a,  PDD b) {
    return {a.x - b.x, a.y - b.y};
}
```

### 1.前置知识

**1.1 高中平面向量相关知识**

**1.2 向量叉积 (cross)** 

1.2.1 几何意义：由两个向量围成平行四边形的**有向**面积。

1.2.2 规定：第二个向量在第一个向量的逆时针方向为正，顺时针方向为负。 

```
double cross(PDD a, PDD b) {
    return a.x * b.y - a.y * b.x;
}

double area(PDD a, PDD b, PDD c) {
    return cross(b - a, c - a);
}
```

**1.3 求直线交点 (get line intersection)**

设交点为 $p + t \times \vec{v}$。

令 $\vec{u} = p - q$，

根据三角形相似，不难得出 $t = \frac{\vec{w} \times \vec{u}}{\vec{v} \times \vec{w}}$。

```
PDD gli(PDD p, PDD v, PDD q, PDD w) {
    auto u = p - q;
    double t = cross(w, u) / cross(v, w);
    return {p.x + v.x * t, p.y + v.y * t};
}

PDD gli(Line a, Line b) {
    return gli(a.st, a.ed - a.st, b.st, b.ed - b.st);
}
```

**1.4 判断两直线交点是否在另一直线右侧**

设两直线交点为 $o$。

判断这条直线上的任一条线段和这个交点围成的三角形面积符号即可。

```
bool on_right(Line a, Line b, Line c) {
    auto o = gli(b, c);
    return sign(area(a.st, a.ed, o)) <= 0;
}
```

**1.5 求某条直线与水平方向的夹角**

设这条直线上的某个点为 $(x, y)$，与水平方向的夹角为 $\alpha$。

$\tan \alpha = \frac{y}{x}$，

$\alpha = \arctan(\frac{y}{x})$。

使用 ```cmath``` 库中的 ```atan2``` 函数，注意，这个函数在调用时先传纵坐标，再传横坐标。

```
double get_angle(Line a) {
    return atan2(a.ed.y - a.st.y, a.ed.x - a.st.x);
}
```

### 2.半平面 半平面交

**2.1 半平面**

一个向量把平面分成了左、右两部分，我们将左（右）部分的集合称作半平面。

这里的左是指以向量的方向为向前的左边。

**2.2 半平面交** 

许多向量的半平面的交集称作半平面交。

我们把题目给的凸多边形按逆时针标定方向，所求即为所有向量的半平面交，一个简单的例子如下。

比如我们要求一个给定三边的三角形面积。

![](https://cdn.luogu.com.cn/upload/image_hosting/1vvzzcvm.png?x-oss-process=image/resize,m_lfit,h_200,w_200)
![](https://cdn.luogu.com.cn/upload/image_hosting/plxx0ur6.png?x-oss-process=image/resize,m_lfit,h_200,w_200)
![](https://cdn.luogu.com.cn/upload/image_hosting/ljo3wpet.png?x-oss-process=image/resize,m_lfit,h_200,w_200)

维护三条直线，求他们的半平面交即可。

本题样例如下。

![](https://cdn.luogu.com.cn/upload/image_hosting/bkjdv01o.png?x-oss-process=image/resize,m_lfit,h_200,w_200)

### 3.算法流程

首先，我们将给定的所有直线按照与水平面的夹角排序，然后用一个双端队列维护所有的直线。

如何维护？或者说，当满足什么条件的时候，我们就不再需要队列中的某条直线了？

首先，如果有平行的直线，我们只需要它们之中靠左的那条。

其他的更新方式，看下面的例子。我们以黑色表示队列中原有的直线，蓝色表示枚举到的用来更新的直线。

![](https://cdn.luogu.com.cn/upload/image_hosting/vv2t6q3j.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

这个情况下，我们就不再需要队尾的直线。

![](https://cdn.luogu.com.cn/upload/image_hosting/h71behqa.png?x-oss-process=image/resize,m_lfit,h_200,w_225)

而这种情况下，我们则需要保留队尾的直线。

稍加总结，不难得到：看队内两条直线的交点在新的直线的左侧还是右侧即可。若在右侧，则我们不再需要队尾直线，可以直接弹出。

更新队头方式同理。最后还要用队头更新一下队尾。

注意，当三线交于一点时应当如何取舍，应当根据题干而定。本题中这种情况对最后的答案没有影响，所以可以直接弹出。

```
double calc() {
    sort(line, line + cnt, cmp);
    int hh = 0, tt = -1;
    rep(i, 0, cnt - 1) {
        if(i && !dcmp(get_angle(line[i]), get_angle(line[i - 1]))) continue;
        while(hh + 1 <= tt && on_right(line[i], line[q[tt - 1]], line[q[tt]])) -- tt;
        while(hh + 1 <= tt && on_right(line[i], line[q[hh]], line[q[hh + 1]])) ++ hh;
        q[ ++ tt] = i;
    }
    while(hh + 1 <= tt && on_right(line[q[hh]], line[q[tt - 1]], line[q[tt]])) -- tt;
    
    q[ ++ tt] = q[hh];
    int k = 0;
    rep(i, hh, tt - 1) 
        ans[k ++ ] = gli(line[q[i]], line[q[i + 1]]);
    double res = 0;
    rep(i, 1, k - 2) 
        res += area(ans[0], ans[i], ans[i + 1]);
    return res / 2;
} 
```

### 4.代码

操作核心代码在上面已经给出。[完整代码。](https://www.luogu.com.cn/paste/ctn717jz)

---


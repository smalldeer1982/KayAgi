# 『JROI-3』1÷0

## 题目背景

```
1÷0=梦恋
```
```
   在距离遥远的山丘上，看得见彼方宛如天地崩毁的光景。

    「——『设计体』传来报告——以功率《七二·八％》重现设计成功——开始同步。」

    一机机凯种的女性体这么告知里克，然后举起手。

    「【典开】——Org.0000——『真典·弑星者』——拜托您了。」

    ——出现在虚空中的是，外形有如小型的塔，刺在地上的一把枪。

    方才目睹的，有如让世界终结的暴力漩涡。

```

## 题目描述

空想用跳棋模拟「圣战」中机凯种的移动方式。

一条**无限长**的数轴上有 $n$ 个不能动的跳棋，空会询问把一颗可以动的跳棋放在一个位置可以**最多**进行几次跳跃。空会问很多次，每次询问**互相独立**。

设第 $i$ 颗不能动的棋子的坐标为 $x_i\left(\forall i\in\left[1,n\right]\right)$.

则跳棋移动的规则如下：

- 这颗跳棋必须是允许移动的。
- 若这颗棋子位于 $a$，目标位置为 $b$，则应**仅有一颗**棋子位于二个位置之间且中间棋子到 $a,b$ 的距离相等。

形式化的讲应有：

$$\sum_{k=1}^n \left[x_k\in\left[b,a\right]\right]=1$$

且 $\exists k\ x_k=\dfrac{a+b}{2}$.


- 出题人过于良心（，你只能向左边跳。


## 说明/提示

#### 样例解释 1

$$\Huge\Box\Box\blacksquare{\color{red}{\Box}}\blacksquare{\color{red}{\Box}}{\color{red}{\Box}}\blacksquare\Box\Box$$

从左到右的三个红色方块是询问的位置。

- 对于第一个询问，可以跳 $1$ 步，从 4 跳到 2。
- 对于第二个询问，可以跳 $2$ 步，从 6 跳到 4 跳到 2。
- 对于第三个询问，棋子不能向左移动，因为左边同距离位置有一颗不能动的棋子。

对于 $100\%$ 的数据满足 $1\le n\leq 3\times 10^6$，$1\le q\leq3\times 10^5$，$1\le x\le 10^{18}$，$x_i+1\lt x_{i+1}(\forall i \in [1,n-1])$。

| Subtask 编号 | $n\le$ | $q\le$ | 时限 | 空间限制 | 特殊限制 |
| :-----------: | :-----: | :---: | :--: | :------:| :------: |
| Subtask 0 (10 pts) | $10^3$ | $10^3$ |  $1000\ \rm\small ms$ | $\rm512.00\small\  MB$ |  |
| Subtask 1 (30 pts) |  |  | $1000\ \rm\small ms$ | $\rm512.00\small\  MB$ | $\rm A$|
| Subtask 2 (25 pts) |  |  | $1000\ \rm\small ms$ | $\rm512.00\small\  MB$ | $\rm B$ |
| Subtask 3 (25 pts) | $3 \times 10^5$ |  | $400\ \rm\small ms$ | $\rm512.00\small\  MB$ |
| Subtask 4 (10 pts) |  |  | $400\ \rm\small ms$ | $\rm512.00\small\  MB$ |

- 限制 $\text{A}$： $x_n\le2\times 10^5$。
- 限制 $\text{B}$：有不超过 $50$ 个 $i$ 不满足 $x_i-x_{i-1}\le 100$ ，其余 $i$ 满足 $\sum_{i}{x_i-x_{i-1}} \le 2\times 10^5$。

## 样例 #1

### 输入

```
3 3
3 5 8
4 6 7```

### 输出

```
1
2
0```

# 题解

## 作者：Tony2 (赞：17)

良心 C 题，不接受反驳。

首先我们看只有 3 颗棋子的情况。

$$\Box\blacksquare\Box\Box\blacksquare\Box\Box{\color{red}{\Box}}{\color{red}{\Box}}\blacksquare\Box$$

其中黑色表示有棋子。

我们观察到一旦我们的棋子被放到红色位置上之后它肯定无法再向左走了。

$$\Box\blacksquare\Box\Box\Box\Box\blacksquare\Box\Box\blacksquare\Box$$

这种情况就是啥事没有。

所以我们只要考虑棋子最早会在哪里落到一个红色位置上。

我们让棋子去找红色位置，不如让红色位置反过来去找棋子。

比如下图：

$$\Box\blacksquare\Box\Box\blacksquare\Box\Box{\color{red}{\Box}}{\color{red}{\Box}}\blacksquare\Box\Box\Box\blacksquare\Box$$

红点可以向右去找棋子：

$$\Box\blacksquare\Box\Box\blacksquare\Box\Box{\color{red}{\Box}}{\color{red}{\Box}}\blacksquare{\color{red}{\Box}}{\color{red}{\Box}}\Box\blacksquare\Box$$

这样我们只要在一开始的时候看一下棋子脚下的颜色就可以知道会不会在某一刻不能再往左走了。

等等，这样没法处理**最早**。

解决方法就是直接**覆盖**。从左到右处理红色位置的时候顺带记录一下是哪两个不动棋子之间的红色位置转移出去的。这样可以完整地查询，向右转移的时候直接覆盖就可以了。

对于两个相邻的不动棋，从左边开始会有若干段连续的红点，他们的生成时间越来越早。我们把它看作**单调队列**结构。从右边也有相同的结构。左边和右边可能重叠，但不重要，查询时两边各查询一次，去最小值即可。

举个例子，比如我们有三段从左边开始的红色位置，**从短到长，生成距离当前越来越远**。

第一段：
$$\Box\blacksquare{\color{red}{\Box}}{\color{red}{\Box}}\Box\Box\Box\blacksquare\Box$$

第二段：
$$\Box\blacksquare{\color{red}{\Box}}{\color{red}{\Box}}{\color{red}{\Box}}\Box\Box\blacksquare\Box$$

第三段：
$$\Box\blacksquare{\color{red}{\Box}}{\color{red}{\Box}}{\color{red}{\Box}}{\color{red}{\Box}}\Box\blacksquare\Box$$

单调队列里按 `[1,2,3]` 排列。

---

具体的，红色位置如何转移？

1.

$$\Box\blacksquare\Box{\color{red}{\Box}}{\color{red}{\Box}}\blacksquare\Box\Box\Box\blacksquare\Box$$

对于这种情况，我们只需要找到红色位置中从中间这个黑点出发延申的最长段，它可能在转移过程中因为过长而**消失**或**消失其中一段**，在单调队列中直接从队末修改即可。

2.

$$\Box\blacksquare{\color{red}{\Box}}{\color{red}{\Box}}\Box\blacksquare\Box\Box\Box{\color{blue}{\Box}}{\color{blue}{\Box}}\blacksquare\Box$$

对于这种情况，我们在转移过去之后发现从右边开始并不连续，实际上我们直接添加一段红色位置在那些被标蓝的位置就连续了，所属位置是最新的位置。

3.

$$\Box\blacksquare{\color{red}{\Box}}{\color{red}{\Box}}\Box\Box\blacksquare\Box\Box\Box\blacksquare\Box$$

这种情况和第一种情况很类似，只不过是从单调队列的对头进行修改。


---

我们发现这个单调队列是动态的，所以询问得离线，刚好到自己所处的两个不动棋的区间的时候查询。这个查询得二分。总复杂度：$O(n+q\log n)$。

~~部分分很良心吧？~~

```cpp
#include <bits/stdc++.h>
#define ll long long
#define inf (0x3f3f3f3f3f3f3f3f)
using namespace std;
const int N = 6e6+100;
int n, Q;
ll a[N];
pair<ll, int> b[N];
int l[2], r[2];
ll d[2];
pair<ll, int> q[2][N];
int ans[N];
char buf[1<<23],*p1=buf,*p2=buf,obuf[1<<25],*O=obuf;
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
#define putchar(x) (*O++=x)
inline ll read() {
	ll x=0,f=1;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-') f=-1;ch=getchar();}
	while(isdigit(ch)) x=x*10+(ch^48),ch=getchar();
	return x*f;
}
inline void write(int X){
	if(X<0) {putchar('-'); X=~(X-1);}
	int s[20],top=0;
	while(X) {s[++top]=X%10; X/=10;}
	if(!top) s[++top]=0;
	while(top) putchar(s[top--]+'0');
}
int main(){
//	std::ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);
//	freopen("data/in20.in", "r", stdin);
//	freopen("data/out6.out", "w", stdout);
	n = read(), Q = read();
	for (int i = 1; i <= n; i++)
		a[i] = read();
	a[++n] = inf;
	for (int i = 1; i <= Q; i++){
		b[i].first = read();
		b[i].second = i;
	}
	sort(b+1, b+1+Q);
	q[0][l[0]=r[0]=3e6+50] = make_pair(inf, 0);
	q[1][l[1]=r[1]=3e6+50] = make_pair(inf, 0);
	int p = 1; 
	for (int i = 1; i < n; i++){
		const ll len1 = (i==1?inf:a[i]-a[i-1]-1), len2 = a[i+1]-a[i]-1;
		if (len1 > len2){
			const int j = i&1;
			while (l[j] < r[j] && q[j][r[j]-1].first+d[j] > len2)
				r[j]--;
			q[j][r[j]].first = min(len2-d[j], q[j][r[j]].first);
			while (l[j^1] <= r[j^1] && q[j^1][l[j^1]].first+d[j^1] <= len1-len2)
				l[j^1]++;
			d[j^1] -= len1-len2;
		}else{
			const int j = (i&1)^1;
			d[j] += len2-len1;
			if (len2 > len1)
				q[j][--l[j]] = make_pair(len2-len1-d[j], i);
		}
		const int j = i&1;
		while (p <= Q && b[p].first <= a[i+1]){
			if (b[p].first <= a[i]){
				p++;
				continue;
			}
			const pair<ll, int> _1(b[p].first-a[i]-d[j], 0), _2(a[i+1]-b[p].first-d[j^1], 0);
			const int res1 = lower_bound(q[j]+l[j], q[j]+r[j]+1, _1)-q[j];
			const int res2 = lower_bound(q[j^1]+l[j^1], q[j^1]+r[j^1]+1, _2)-q[j^1];
			ans[b[p].second] = i-max(q[j][res1].second, q[j^1][res2].second);
			p++;
		}
	}
	for (int i = 1; i <= Q; i++)
		write(ans[i]), putchar('\n');
	fwrite(obuf, O-obuf, 1, stdout);
	return 0;
}
```

---

## 作者：Nuisdete (赞：5)

周赛凉心 F 题，不接受反驳。

发现用棋子一个一个跳过不动棋难以维护，考虑直接维护出来跳到哪些地方就是死路，同时维护出在这个地方最多能跳的次数。

手玩一些例子可以发现一个有趣的事实，会走到死路的那些位置一定紧挨着某个不动棋的一段区间，比如以 $0$ 代表空位置，$1$ 代表不动棋，$2$ 代表会走到死路的位置，那么它们的位置关系就像这样：

```text
... 2 2 1 2 2 2 0 0 2 2 2 2 2 1 2 2 1 2 2 2 ... 
```

而且我们还可以发现另一个有趣的事实，一个不动棋两端的区间中会走到死路的位置实际是关于这个不动棋对称的（较短区间的长度范围内）。

那么考虑维护两个队列，分别代表两个不动棋之间会走到死路的左区间和右区间以及它们的终点是在哪个不动棋之前。

容易发现，从 $[i - 2, i - 1]$ 这个区间维护到 $[i - 1, i]$ 这个区间后，根据对称性，左区间队列变成右区间队列，右区间队列变成左区间队列，但是因为区间长度的限制，可能会有区间从队头或队尾出队，同时也可能有区间从队头或队尾入队，而位置偏移量可以额外对每个队列维护一个 $tag$。

维护队列的同时，我们把询问离线下来对应到每个不动棋区间里，然后从左右队列中分别二分查找它在哪个区间中（如果左右区间都有就将答案取 $\min$，如果都没有就说明能跳过第一个不动棋），然后根据终点计算答案即可。

时间复杂度 $\mathcal{O}(n + q \log x)$。

代码细节较多，建议找到一组数据进行调试。

```cpp
# include <cstdio>
# include <cassert>
# include <utility>
# include <algorithm>

# define int long long

# define fst first
# define sec second

using std::min;

typedef std::pair<int, int> Pii;

const int MAXN = 3e6 + 5;

int n, m;
int x[MAXN << 1];
int ans[MAXN << 1];

int tag[2];
Pii Q[MAXN << 1];

Pii que[2][MAXN << 1];
Pii *hd[2] = { que[0] + MAXN, que[1] + MAXN }, *tl[2] = { que[0] + MAXN, que[1] + MAXN };

int binary(int x, int L, int R, int num, int k) {
	int ans = MAXN;
	int l = 0, r = tl[k] - hd[k] - 1;
	while (l <= r) {
		int mid = l + r >> 1;
		Pii *t = hd[k] + mid;
		int a = L + (t == hd[k] ? 1 : ((*(t - 1)).fst + tag[k]) + 1), b = L + ((*t).fst + tag[k]);
		if (x > b) l = mid + 1;
		else if (x < a) r = mid - 1;
		else { ans = min(ans, num - (*t).sec); break; }
	}
	l = 0, r = tl[k ^ 1] - hd[k ^ 1] - 1;
	while (l <= r) {
		int mid = l + r >> 1;
		Pii *t = hd[k ^ 1] + mid;
		int a = R - ((*t).fst + tag[k ^ 1]), b = R - (t == hd[k ^ 1] ? 1 : ((*(t - 1)).fst + tag[k ^ 1]) + 1);
		if (x > b) r = mid - 1;
		else if (x < a) l = mid + 1;
		else { ans = min(ans, num - (*t).sec); break; }
	}
	return ans == MAXN ? num - 1 : ans;
}

signed main() {
	
	scanf("%lld %lld", &n, &m);
	for (int i = 1; i <= n; ++i) scanf("%lld", &x[i]); x[n + 1] = x[n] + 3 * (x[n] - x[n - 1]);
	for (int i = 1; i <= m; ++i) scanf("%lld", &Q[i].fst), Q[i].sec = i;
	std::sort(Q + 1, Q + m + 1, [&] (const Pii& A, const Pii& B) {
		return A.fst < B.fst;
	});
	int p = 1;
	while (Q[p].fst < x[1] && p <= m) ans[ Q[p].sec ] = 0, ++p;
	while (Q[p].fst < x[2] && p <= m) ans[ Q[p].sec ] = 1, ++p;
	for (int i = 3; i <= n + 1; ++i) { // k 是左区间，k ^ 1 是右区间
		int k = i & 1;
		int l1 = x[i - 1] - x[i - 2] - 1, l2 = x[i] - x[i - 1] - 1;
		if (l1 < l2) {
			*(--hd[k ^ 1]) = { -tag[k ^ 1], i }, tag[k ^ 1] += l2 - l1;
		}
		if (l1 > l2) {
			int tmp = 0;
			while (hd[k] != tl[k] && x[i - 1] + (*(tl[k] - 1)).fst + tag[k] >= x[i]) 
				tmp = (*(tl[k] - 1)).sec, tl[k] --;
			
			if ((hd[k] == tl[k] && x[i - 1] < x[i] - 1 || hd[k] < tl[k] && x[i - 1] + (*(tl[k] - 1)).fst + tag[k] < x[i] - 1) && tmp)
				*tl[k] ++ = { x[i] - x[i - 1] - 1 - tag[k], tmp };
			
			tag[k ^ 1] -= l1 - l2;
			while (hd[k ^ 1] != tl[k ^ 1] && (*hd[k ^ 1]).fst + tag[k ^ 1] <= 0)
				hd[k ^ 1] ++;
		}
		while (Q[p].fst < x[i] && p <= m) ans[ Q[p].sec ] = binary(Q[p].fst, x[i - 1], x[i], i, k), ++p;
	}
	for (int i = 1; i <= m; ++i) printf("%lld\n", ans[i]);
	
	return 0;
}

```

---

## 作者：wYYSZLwSSY (赞：2)

提供一种相对简单的方法。
## 题解
显然，一系列合法的跳跃每次跃过的棋子 $k$ 一定是一个公差为 $-1$ 的等差数列，而且首项显然是棋子最初位置左边的第一个棋子。

所以我们考虑每次跳跃后，棋子的位置 $x$ 减去下一步应该要越过的棋子位置（称它为“距离”）。如果是合法跳跃，那么这个数字应该始终是正数。反过来，当这个数字始终是正数时，跳跃也是合法的。

由此，我们将问题转化为找到第一次“距离”为负数时跳跃了几次。我们观察“距离”的变化。设开始时的位置减去左边第一个棋子位置的值为 $d$，开始时左边棋子的位置为 $x_l$，设 $r_i=x_i-x_{i-1}$，于是有：

- 第零次跳跃后的“距离”：$d$。
- 第一次后：$r_l-d$。
- 第二次后：$r_{l-1}-(r_l-d)=r_{l-1}-r_l+d$。
- 第三次后：$r_{l-2}-(r_{l-1}-r_l+d)=r_{l-2}-r_{l-1}+r_l-d$。    
......

不难发现，整个“距离”的表达式是 $+r$，$-r$，$+r$，$-r$...的过程。那么我们把 $d$ 扔到不等式一边，奇偶分类讨论，随着 $l$ 的不断增大维护新的“距离”，查找第一个小于等于 $d$（或者 $-d$）的位置。

具体地，可以把询问离线，从 $1$ 开始枚举 $l$，$l$ 每增大 $1$ 时，就给维护“距离”的数据结构加 $tag$，并加入 $r_l$。查找第一个小于等于 $d$ 或 $-d$ 可以用单调栈维护，然后二分答案。

时间复杂度：$O(n+q\log n)$。

## 代码：
```cpp
#include<bits/stdc++.h>
#define int long long 
using namespace std;
int n,q,ans[300005];
int x[3000006];
signed rt;
pair<int,int>pr[300005];
int l1,r1,l2,r2;
int tag1,tag2;
pair<int,int>sta1[3000006],sta2[3000006];
int check1(int x){
	int l=l1,r=r1+1;
	sta1[r1+1].first=3e18;
	sta1[0].second=-1;
	while(l<r){
		int mid=l+r>>1;
		if(sta1[mid].first<=x)l=mid+1;
		else r=mid;
	}
	--l;
	return sta1[l].second;
}
int check2(int x){
	int l=l2,r=r2+1;
	sta2[r2+1].first=3e18;
	sta2[0].second=-1;
	while(l<r){
		int mid=l+r>>1;
		if(sta2[mid].first<=x)l=mid+1;
		else r=mid;
	}
	--l;
	return sta2[l].second;
}
signed main(){
	cin.tie(0)->sync_with_stdio(0);
// 	freopen("1.in","r",stdin);
	cin>>n>>q;
	for(int i=1;i<=n;++i)cin>>x[i];
	for(int i=1;i<=q;++i){
		cin>>pr[i].first;
		pr[i].second=i;
	}
	x[0]=-1e18;
	sort(pr+1,pr+q+1);
	int tp=0;
	l1=l2=1,r1=r2=0;
	for(int i=1;i<=q;++i){
		int y=pr[i].first;
		while(tp+1<=n and y>=x[tp+1]){
			++tp;
			if(tp&1){
				int pt=x[tp]-x[tp-1];
				tag1+=pt;
				while(l1<=r1 and sta1[r1].first>=pt-tag1)--r1;
				sta1[++r1]={pt-tag1,tp};
				tag2-=pt;
			}else{
				int pt=x[tp]-x[tp-1];
				tag2+=pt;
				while(l2<=r2 and sta2[r2].first>=pt-tag2)--r2;
				sta2[++r2]={pt-tag2,tp};
				tag1-=pt;
			}
		}
		int d=y-x[tp];
		if(d==0 or !tp){
			ans[pr[i].second]=0;
			continue;
		}
		if(tp&1){
			int qr=check1(d-tag1);
			qr=max(qr,check2(-d-tag2));
			if(qr==-1)ans[pr[i].second]=tp;
			else ans[pr[i].second]=tp-qr;
		}else{
			int qr=check1(-d-tag1);
			qr=max(qr,check2(d-tag2));
			if(qr==-1)ans[pr[i].second]=tp;
			else ans[pr[i].second]=tp-qr;
		}
	}
	for(int i=1;i<=q;++i)cout<<ans[i]<<'\n';
	return 0;
}
```

---


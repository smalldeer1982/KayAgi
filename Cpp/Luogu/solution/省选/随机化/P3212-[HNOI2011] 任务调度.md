# [HNOI2011] 任务调度

## 题目描述


有 $n$ 个任务和两台机器 A 与 B。每个任务都需要既在机器 A 上执行，又在机器 B 上执行，

第 $i$ 个任务需要在机器 A 上执行时间 $a_i$，且需要在机器 B 上执行时间 $b_i$。最终的目标是所有任务在 A 和 B 上都执行完，且希望执行完所有任务的总时间尽量少。当然问题没有这么简单，有些任务对于先在机器 A 上执行还是先在机器 B 上执行有一定的限制。据此可将所有任务分为三类：

1. 任务必须先在机器 A 上执行完然后再在机器 B 上执行。
2. 任务必须先在机器 B 上执行完然后再在机器 A 上执行。
3. 任务没有限制，既可先在机器 A 上执行，也可先在机器 B 上执行。

现在给定每个任务的类别和需要在机器 A 和机器 B 上分别执行的时间，问使所有任务都能按规定完成所需要的最少总时间是多少。

## 说明/提示

#### 样例 1 解释

一种最优任务调度方案为：

机器 A 上执行的各任务依次安排如下：

任务 $1\ (0\to 5)$，任务 $2\ (5\to 11)$, 任务 $3\ (11\to 13)$；

机器 B 上执行的各任务依次安排如下：

任务 $3\ (0 \to 6)$, 任务 $1\ (6 \to 13)$, 任务 $2\ (13 \to14)$，

这样，所有任务都执行完所需要的总时间为 $14$。

#### 数据规模与约定

对于 $100\%$ 的数据，保证 $1\le n\le 20$，$1\le a_i\le 10^3$，$1\le t_i\le 3$，并保证 $t_i=3$ 的 $i$ 不超过 $10$ 个。

## 样例 #1

### 输入

```
3
3 5 7
1 6 1 
2 2 6
```

### 输出

```
14```

# 题解

## 作者：Ameyax (赞：9)

~~一个RP完全问题~~

当成dp想不出来，然后发现标签随机化233

枚举第三种任务先在A还是先在B，再随便贪心一下任务1，2的顺序，然后就是大力随机交换A，B机器任务执行的先后顺序，贪心计算时间，如果更优就保存，大概每次随机2000组够了

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAX_N = 30;
const int inf = INT_MAX / 3;
int n, a[MAX_N], b[MAX_N], t[MAX_N], ans = inf;
int que_a[MAX_N], que_b[MAX_N], top_a, top_b;
bool flag[MAX_N];
int read()
{
    int x = 0, f = 1; char ch = getchar();
    while (!isdigit(ch)) { if (ch == '-') f = -1; ch = getchar(); }
    while (isdigit(ch)) { x = x * 10 + ch - '0'; ch = getchar(); }
    return x * f;
}
bool cmp_a(int x, int y)
{
    return b[x] == b[y] ? a[x] < a[y] : b[x] > b[y];
}
bool cmp_b(int x, int y)
{
    return a[x] == a[y] ? b[x] < b[y] : a[x] > a[y];
}
int calc()
{
    int sum_a = 0, sum_b = 0, re = 0;
    for (int i = 1; i <= top_a; i++)
        sum_a += a[que_a[i]];
    for (int i = 1; i <= top_b; i++)
    {
        sum_b += b[que_b[i]];
        if (sum_a > sum_b) sum_a += a[que_b[i]];
        else sum_a = sum_b + a[que_b[i]];
    }
    re = max(sum_a, sum_b);
    sum_a = sum_b = 0;
    for (int i = 1; i <= top_b; i++)
        sum_b += b[que_b[i]];
    for (int i = 1; i <= top_a; i++)
    {
        sum_a += a[que_a[i]];
        if (sum_b > sum_a) sum_b += b[que_a[i]];
        else sum_b = sum_a + b[que_a[i]];
    }
    return max(re, max(sum_a, sum_b));
}
void solve()
{
    top_a = top_b = 0;
    for (int i = 1; i <= n; i++)
        if (flag[i]) que_b[++top_b] = i;
        else que_a[++top_a] = i;
    sort(que_a + 1, que_a + top_a + 1, cmp_a);
    sort(que_b + 1, que_b + top_b + 1, cmp_b);
    int re = calc();
    for (int cas = 1; cas <= 2000; cas++)
    {
        int a1, a2, b1, b2, tmp;
        if (top_a)
            swap(que_a[a1 = (rand() % top_a) + 1], que_a[a2 = (rand() % top_a) + 1]);
        if (top_b)
            swap(que_b[b1 = (rand() % top_b) + 1], que_b[b2 = (rand() % top_b) + 1]);
        tmp = calc();
        if (tmp < re) re = tmp;
        else
        {
            if (top_a) swap(que_a[a1], que_a[a2]);
            if (top_b) swap(que_b[b1], que_b[b2]);
        }
    }
    if (re < ans) ans = re;
}
void dfs(int dep)
{
    if (dep > n) solve();
    else if (t[dep] == 1) flag[dep] = 0, dfs(dep + 1);
    else if (t[dep] == 2) flag[dep] = 1, dfs(dep + 1);
    else
    {
        flag[dep] = 0; dfs(dep + 1);
        flag[dep] = 1; dfs(dep + 1);
    }
}
int main()
{
    srand(time(NULL) + 19260817);
    n = read();
    for (int i = 1; i <= n; i++)
        t[i] = read(), a[i] = read(), b[i] = read();
    dfs(1);
    printf("%d\n", ans);
    return 0;
}
```

---

## 作者：a326820068122c (赞：5)

题解全是随机化算法？

那我来个状态压缩 dp 吧。

~~我是万万没想到随机化就能过。~~

### 解法

设所有任务消耗 $a$ 的时间和为 $sum_a$ ,消耗 $b$ 的时间和为 $sum_b$。

首先理想状态是所有任务都不需要等。

那么我们的答案就是 $\max(sum_a,sum_b)$。

然而实际上所有任务可能不能无缝衔接。

由于有任意谁先做的情况，可以暴力枚举谁先做。

首先肯定要在一个机器上完成自己必须先做的任务（可以反证）。

然后考虑自己后做的任务，这里似乎无法直接贪心。

那么可以设计一个 dp 来求出每个任务集合最少要等待的时间。

(这里”a 任务集合里的任务的等待时间”是指 a 中为这些集合里的任务出现时，b 中至少需要等待这么多时间，这段时间可以做自己先做的任务或者什么也不干)。

然后就可以得出 dp 方程式 。

这里的 $dpa$ 是求 “a 任务集合里的任务的等待时间”，$dpb$ 是求 “b 任务集合里的任务的等待时间”，$a$ 是这一项在 a 中花费的时间，$b$ 是这一项在 b 中花费的时间，$x,y$ 满足关系 $(x\&(1<<y))==0\&\&(x|(1<<y))==i$。

$dpa[i]=min(dpa[i],a[y]+max(dpa[x]-b[y],0))$

$dpb[i]=min(dpb[i],b[y]+max(dpb[x]-a[y],0))$

这里比较绕，搞不懂的建议看代码。

dp 完之后就可以暴力枚举任意谁先做的任务了，现强制让 $a$ 先做，再强制让 $b$ 先做。

$ti=3$ 的 $i$ 不超过 $10$ 个这个条件貌似在2这个做法里用处不大。（也就是可以多出一档数据不含此条件）

复杂度 $O(n2^n)$,常数小。

### 代码

```cpp
#include <bits/stdc++.h>
#define for1(i,n) for(i=1;i<=(n);i++)
#define for0(i,n) for(i=0;i<(n);i++)
using namespace std;
const int N=1048585;
int n,t,dpa[N],dpb[N],pa,pb,a[25],b[25],e[25],c,lg[N],sa[N],sb[N],suma,sumb,ans=1e9;
void dfs(int d,int qa,int qb){
	if(d>c){
		ans=min(ans,max(suma+max(dpb[qb]-sa[qa],0),sumb+max(dpa[qa]-sb[qb],0)));
		return ;
	}
	dfs(d+1,qa|e[d],qb);dfs(d+1,qa,qb|e[d]);
}
int main(){
	int i,j,x,y;
	scanf("%d",&n);
	t=(1<<n)-1;
	for0(i,n){
		lg[y=1<<i]=i;
		scanf("%d%d%d",&x,&a[i],&b[i]);
		if(x==1) pa|=y;
		else if(x==2) pb|=y;
		else e[++c]=y;
	}
	memset(dpa,0x1f,sizeof(dpa));dpa[0]=0;
	memset(dpb,0x1f,sizeof(dpb));dpb[0]=0;
	for1(i,t){
		sa[i]=sa[i&(i-1)]+a[lg[i&-i]],sb[i]=sb[i&(i-1)]+b[lg[i&-i]];
		for(j=i;j;j-=j&-j){
			x=i-(j&-j);y=lg[j&-j];
			dpa[i]=min(dpa[i],a[y]+max(dpa[x]-b[y],0));
			dpb[i]=min(dpb[i],b[y]+max(dpb[x]-a[y],0));
		}
	}
	suma=sa[t];sumb=sb[t];
	dfs(1,pa,pb);
	printf("%d\n",ans);
	return 0;
}
```
当然我这个解法没有进行对拍，欢迎大家 hack 我的解法。

---

## 作者：No_wonder (赞：3)

这道题难受死了啊，写了个SA然后发现参数好难调……

最后无奈，参照了网上的一篇blog的参数

[原地址](https://blog.csdn.net/CreationAugust/article/details/49535415?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control)

博主的开了O2之后跑的飞快，但是我的就会T一个点，可能就是人弱自带大常数，交了好几页才过去。

这里简单说一下这道题吧。首先我们要处理三号物品。数据中$n\leq20$，说明这题不是状压就是搜，而正解就是搜索。我们枚举每一个三号物品的执行顺序，写出我们的dfs函数。

```cpp
void dfs(int x)
{
    if (x>cnt)   {SA();return;}			//核心部分是模拟退火，后面会讲 
    t[mac[x]]=1;						//选择三号物品的两种可能 
    if (rand()%32767<20000)  dfs(x+1);
    t[mac[x]]=2;
    if (rand()%32767<20000)  dfs(x+1);
}
int main()
{
    scanf("%d",&n);
    for (int i=1;i<=n;i++)
    {
        scanf("%d%d%d",&t[i],&a[i],&b[i]);
        if (t[i]==3)    mac[++cnt]=i;
    }
    for (int i=1;i<=1000;i++)    dfs(1);//多次随机化搜索增加正确率 
    printf("%d",ans);
}
```

在到达终止边界时，我们就可以进行处理了。我们首先考虑如何选择两种机器的初始执行顺序。我的贪心策略是优先给另一个机械用时短的任务，这个贪心毫无疑问是错误的，但是我们可以把它来当一个较优的初始状态。

然后我们用退火，随机交换执行序列中两个数。然后再进行一次计算。如果更优就接受，不优就概率接受，这样卡时限跑许多次，得到的结果就较为准确了。

心累，要是退火实在玄学的过不去的话把这篇代码仔细研究，或许就可以了

AC代码
```cpp
#include<bits/stdc++.h>
#define MAXINT 0x7fffffff
using namespace std;
int n,ans=MAXINT;
int t[100],a[100],b[100];
int mac1[100],mac2[100],mac[100],cnt1,cnt2,cnt;
bool cmpa(int A,int B)										//贪心策略 
{
    return ((b[A]>b[B])||(b[A]==b[B]&&a[A]<=a[B]));
}
bool cmpb(int A,int B)
{
    return ((a[A]>a[B])||(a[A]==a[B]&&b[A]<=b[B]));
}
void SA()														//模拟退火 
{
    int tmp=MAXINT,suma=0,sumb=0,cnt1=0,cnt2=0;
    for (int i=1;i<=n;i++)
        if (t[i]==1)    mac1[++cnt1]=i,suma+=a[i];
        else    mac2[++cnt2]=i,sumb+=b[i];
    sort(mac1+1,mac1+cnt1+1,cmpa);sort(mac2+1,mac2+cnt2+1,cmpb);//贪心得到序列 
    /*for(int i=1;i<=cnt1;i++)
	printf("%d ",a[mac1[i]]); 
	printf("\n");*/
    double T=20000;												//退火 
    while (T>0.1)
    {
        int tima=suma,timb=sumb,temp=0,x1=0,y1=0,x2=0,y2=0;		//不建议把变量定成x1，因为是保留字，不过函数内部好像可以？ 
        if (cnt1)   x1=rand()%cnt1+1,y1=rand()%cnt1+1;			//随机得到序列 
        if (cnt2)   x2=rand()%cnt2+1,y2=rand()%cnt2+1;
        swap(mac1[x1],mac1[y1]),swap(mac2[x2],mac2[y2]);
        for (int i=1;i<=cnt1;i++)    temp+=a[mac1[i]],timb=max(temp,timb)+b[mac1[i]];//估价 
        temp=0;
        for (int i=1;i<=cnt2;i++)    temp+=b[mac2[i]],tima=max(temp,tima)+a[mac2[i]];
        temp=max(tima,timb);
        if (temp<=tmp||(temp>tmp&&rand()%10000>T)) tmp=temp;						//退火核心内容 
        else    swap(mac1[x1],mac1[y1]),swap(mac2[x2],mac2[y2]);
        T*=0.995;
    }
    ans=min(ans,tmp);
}
void dfs(int x)
{
    if (x>cnt)   {SA();return;}			
    t[mac[x]]=1;						//选择三号物品的两种可能 
    if (rand()%32767<20000)  dfs(x+1);
    t[mac[x]]=2;
    if (rand()%32767<20000)  dfs(x+1);
}
int main()
{
    scanf("%d",&n);
    for (int i=1;i<=n;i++)
    {
        scanf("%d%d%d",&t[i],&a[i],&b[i]);
        if (t[i]==3)    mac[++cnt]=i;
    }
    for (int i=1;i<=1000;i++)    dfs(1);//多次随机化搜索增加正确率 
    printf("%d",ans);
}
```


---

## 作者：hgckythgcfhk (赞：2)

目前已有的随机化题解只是介绍了利用随机化来优化阶乘级时间复杂度的思想，并没有讲解统计答案的部分，而且没有解释其他的统计答案的方法的错误原因，这里我重点解释一下统计答案部分。

首先一个非常直观的做法，用队列先存下所有 A 类和 B 类，其中包括我们在枚举过程中钦定的，每个任务做完后出队，然后有两种情况，如果这是第一次出队就加入另一个队列，否则不做处理，直到两个队列都为空，计算两个队列的时间的最大值。

于是有了这样一个程序：

```
void ab(){for(cit&i:b[0])q1.in(i);for(cit&i:b[1])q2.in(i);
	int ta=0,tb=0;while(q1.s()||q2.s()){
		if(q1.s()){cit x=q1.out();ta+=w1[x];if(!v[x])q2.in(x),v[x]=1;}
		if(q2.s()){cit x=q2.out();tb+=w2[x];if(!v[x])q1.in(x),v[x]=1;}
	}ta<tb?ta=tb:0;ans>ta?ans=ta:0;}
```

但是，这个做法很容易发现错误，如果 A 或 B 其中一个空闲下来，这段时间没有统计，空闲一次不会出错，但如果 A 和 B 都空闲一次那会使求出的解比答案小。

然后，一个非常显然的做法就是不要让他们空闲：

```
void ab(){for(cit&i:b[0])q1.in(i);for(cit&i:b[1])q2.in(i);
	int ta=0,tb=0;while(q1.s()||q2.s()){
		if(q1.s()){cit x=q1.out();ta+=w1[x];if(!v[x])q2.in(x),v[x]=1;}else ta=tb;
		if(q2.s()){cit x=q2.out();tb+=w2[x];if(!v[x])q1.in(x),v[x]=1;}else tb=ta;
	}ta<tb?ta=tb:0;ans>ta?ans=ta:0;}
```

感觉好像对了，但是发现有几组运行时间非常短的数据错了，猜测这几组数据很小，发现当 $n=1$ 时，这个算法一定会出错。

最后再说正解。

刚才的做法提醒我们一件事情，不能让任意一个机器空闲而不计算时间，这个其实可以用一个临时变量数组减来减去，每次出队判断两队对首的大小，这个做法极其容易写错，我调了一个晚自习没调出来，因为特是情况太多，比如空队，为什么这个做法难写呢？因为队列导致我们统计时间非常不方便，开一个变量记录总时间会导致边界和特殊情况过多，开两个变量会导致在两个队列上跑来跑去时间不统一很难保证正确性，容易写成最开始的做法，所以，我们干脆直接不要队列了。

先让一组做完，然后做另一组，因为在队列中，每一组都是本组元素先入本组队列，本组元素遍历完了之后才会轮到另一组的元素。

然后假装我们有一个队列，另一组的元素早做完做都得做，按上面的思想，如果另一组在等当前这一组，我们得赶紧把元素接过来无缝衔接，写出来就是。

```
if(ta>tb)ta=ta+w1[i];
```

如果当前组比另一组快，那就等等它。

```
if(ta<tb)ta=tb+w1[i];
```
当然另一组也要更新。

```
tb+=w2[i];
```
这样就对了吗？

不，我们只做了一组，只统计了一组的时间，我们需要反过来再做一遍，取最大值。

这个做法的正确性很容易证明，首先队列肯定是正确的，因为那就是按题义模拟，写不对只是因为难写，这个做法的基础是我们可以确定入队顺序，然后假装有一个队列，实际上还是队列，只是我们没有把元素存下来而已。

```
void ab(){int ta,tb,t=0;
	ta=tb=0;for(cit&i:b[0])ta+=w1[i];for(cit&i:b[1]){tb+=w2[i],ta=w1[i]+max(ta,tb);if(ta>=ans||tb>=ans)return;}t=max(ta,tb);
	ta=tb=0;for(cit&i:b[1])tb+=w2[i];for(cit&i:b[0]){ta+=w1[i],tb=w2[i]+max(ta,tb);if(ta>=ans||tb>=ans)return;}t=max(t,max(ta,tb));
	ans>t?ans=t:0;}
```
然后就得到了一份 50 分的程序。

```
#include<bits/stdc++.h>
#define cit const register unsigned
#define open ios::sync_with_stdio(0),cin.tie(0),cout.tie(0)//,freopen("1.in","r",stdin),freopen("1.out","w",stdout)
#define int register unsigned
#define void inline void
using namespace std;constexpr unsigned N=1e5+1;
unsigned seed;
#define R (((seed^=seed<<13)^=seed>>7)^=seed<<11)
inline unsigned get(cit l,cit r){return R%(r-l+1)+l;}
unsigned ans=~0,w1[22],w2[22];vector<unsigned>a[5],b[3];
void aa(){cit n=b[0].size()-1,m=b[1].size()-1;
	for(int i=n;i>1;--i)swap(b[0][i],b[0][R%i]);
	for(int i=m;i>1;--i)swap(b[1][i],b[1][R%i]);}
#define max(a,b) (a>b?a:b)
void ab(){int ta,tb,t=0;
	ta=tb=0;for(cit&i:b[0])ta+=w1[i];for(cit&i:b[1])tb+=w2[i],ta=w1[i]+max(ta,tb);t=max(ta,tb);
	ta=tb=0;for(cit&i:b[1])tb+=w2[i];for(cit&i:b[0])ta+=w1[i],tb=w2[i]+max(ta,tb);t=max(t,max(ta,tb));
	ans>t?ans=t:0;}
signed main(){open;int n;cin>>n;seed=time(0)*998244353;
	for(int i=1;i<=n;++i){int t;cin>>t>>w1[i]>>w2[i];a[t].emplace_back(i);}
	cit s=a[3].size();cit m=1<<s;
	for(int i=1;i<m;++i){b[0]=a[1],b[1]=a[2];
		for(int j=0;j<s;++j){
		if(i&(1<<j))b[0].emplace_back(a[3][j]);
		else        b[1].emplace_back(a[3][j]);}
		for(int j=8192;j;--j)aa(),ab();}cout<<ans;
}
```

我刚开始在怀疑这个做法的正确性，但题解中都是这个写法，在极限数据下，我输出的结果与题解一致，但是会 RE 且后面的小数据 WA，然后在拍的时候我测试了小数据，发现在随机数据下，没有 1 类或在没有 2 类元素的概率并不小，然后会导致随机打乱的部分 RE。

加个特判就 60 分了。

```
void aa(){cit n=b[0].size()-1,m=b[1].size()-1;
	if(~n)for(int i=n;i;--i)swap(b[0][i],b[0][R%i]);
	if(~m)for(int i=m;i;--i)swap(b[1][i],b[1][R%i]);}
```

但我小数据确实过了，后面的还是 WA，于是思考，这可是省选原题，毒瘤的出题人真的可能给我们留那么多的小数据吗，一次对拍中，一个意外的错误让我的数据中没有 3 类元素，这时输出了 unsigned 的最大值，于是问题就很明显了，枚举每个 3 类元素的部分根本没运行，导致没统计答案，最后单独统计一下就可以了，注意，必须特判没有 3 类元素才再统计，否则会导致有 3 类元素的情况出错。

```
#include<bits/stdc++.h>
#define cit const register unsigned
#define open ios::sync_with_stdio(0),cin.tie(0),cout.tie(0)//,freopen("1.in","r",stdin),freopen("1.out","w",stdout)
#define int register unsigned
#define void inline void
using namespace std;constexpr unsigned N=1e5+1;
unsigned seed;
#define R (((seed^=seed<<13)^=seed>>7)^=seed<<11)
inline unsigned get(cit l,cit r){return R%(r-l+1)+l;}
unsigned ans=~0,w1[22],w2[22];vector<unsigned>a[5],b[3];
void aa(){cit n=b[0].size()-1,m=b[1].size()-1;
	if(~n)for(int i=n;i;--i)swap(b[0][i],b[0][R%i]);
	if(~m)for(int i=m;i;--i)swap(b[1][i],b[1][R%i]);}
#define max(a,b) (a>b?a:b)
void ab(){int ta,tb,t=0;
	ta=tb=0;for(cit&i:b[0])ta+=w1[i];for(cit&i:b[1]){tb+=w2[i],ta=w1[i]+max(ta,tb);if(ta>=ans||tb>=ans)return;}t=max(ta,tb);
	ta=tb=0;for(cit&i:b[1])tb+=w2[i];for(cit&i:b[0]){ta+=w1[i],tb=w2[i]+max(ta,tb);if(ta>=ans||tb>=ans)return;}t=max(t,max(ta,tb));
	ans>t?ans=t:0;}
signed main(){open;int n;cin>>n;seed=time(0)*998244353;
	for(int i=1;i<=n;++i){int t;cin>>t>>w1[i]>>w2[i];a[t].emplace_back(i);}
	cit s=a[3].size();cit m=1<<s;
	for(int i=1;i<m;++i){b[0]=a[1],b[1]=a[2];
		for(int j=0;j<s;++j){
		if(i&(1<<j))b[0].emplace_back(a[3][j]);
		else        b[1].emplace_back(a[3][j]);}
		for(int j=1024;j;--j)aa(),ab();}
	if(!a[3].size()){b[0]=a[1],b[1]=a[2];for(int j=65536;j;--j)aa(),ab();}cout<<ans;
}
```

---

## 作者：破忆 (赞：2)

[P3212 [HNOI2011]任务调度](https://www.luogu.com.cn/problem/P3212)P3212 [HNOI2011]任务调度

从[P7812 [JRKSJ R2] Dark Forest](https://www.luogu.com.cn/problem/P7812)过来的，练练随机化的题。

## 【分析】

$n=20$，随机化贪心。

如果确定了每个工件的加工步骤和所有工件的加工步骤，就可以把工件分成 $A$ 和 $B$ 两类。

先 $A$ 机器的工件放 $A$ 类，先 $B$ 机器的工件放 $B$ 类，都可的工件随机放。

要么先动 $A$ 类，要么先动 $B$ 类。

怎么枚举操作序列？

按顺序枚举操作序列中的两个位置并进行交换，如果能产生较优解，就交换。

陷入僵局后，随机交换历史最优解的几对位置作为当前序列。

卡个时就好。

## 【算法】

随机化贪心

## 【代码】

```cpp
#include<bits/stdc++.h>
#define DB double
using namespace std;
const int maxn=25,INF=1<<30;
int n;
struct ele{
	int t,a,b;
}a[maxn],A[maxn],B[maxn];
int ans=INF,now;
int id[maxn],p[maxn],mp[maxn];
int calc(){
	int na=0,nb=0;
	for(int i=1;i<=n;i++){
		if(a[p[i]].t==1||(a[p[i]].t==3&&(rand()&1))) A[++na]=a[p[i]];
		else B[++nb]=a[p[i]];
	}
    int ta=0,tb=0,ret;
    for(int i=1;i<=na;i++) ta+=A[i].a;
    for (int i=1;i<=nb;i++){
        tb+=B[i].b;
        if(ta>tb) ta+=B[i].a;
        else ta=tb+B[i].a;
    }
    ret=max(ta,tb);
    ta=tb=0;
    for(int i=1;i<=nb;i++) tb+=B[i].b;
    for (int i=1;i<=na;i++){
        ta+=A[i].a;
        if(tb>ta) tb+=A[i].b;
        else tb=ta+A[i].b;
    }
    return max(ret,max(ta,tb));
}
int main(){
	#ifndef ONLINE_JUDGE
	freopen("P3212.in","r",stdin);
	freopen("P3212.out","w",stdout);
	#endif
	srand(20050205);
	scanf("%d",&n);
	for(int i=1;i<=n;i++) scanf("%d%d%d",&a[i].t,&a[i].a,&a[i].b),mp[i]=id[i]=i;
	random_shuffle(mp+1,mp+1+n);
	while((DB)clock()/CLOCKS_PER_SEC<0.95){
//	for(int t=1;t<=1000;t++){
		for(int i=1;i<=n;i++) p[i]=mp[i];
		for(int i=1;i<=3;i++) swap(p[rand()%n+1],p[rand()%n+1]);
		now=calc();
		if(now<ans){
			ans=now;
			for(int k=1;k<=n;k++) mp[k]=p[k];
		}
		random_shuffle(id+1,id+1+n);
		bool flg=1;
		while(flg){
			flg=0;
			for(int i=1;i<n;i++)
			for(int j=i+1;j<=n;j++){
				int x=id[i],y=id[j];
				swap(p[x],p[y]);
				int nxt=calc();
				if(nxt<ans){
					ans=now=nxt;
					for(int k=1;k<=n;k++) mp[k]=p[k];
					flg=1;
				}else
				if(nxt<now){
					now=nxt;
					flg=1;
				}else swap(p[x],p[y]);
			}
		}
	}
	printf("%d\n",ans);
	return 0;
}
```


---

## 作者：AzusaShirasu (赞：1)

本题可以从数据范围入手来分析题目的解法。对于 $n \leq 20$ 的数据，能承受的最大时间复杂度是 $O(2^n)$，可以采取搜索或状态压缩 $\texttt{dp}$。

然而本题的状态包含四种：没有加工、已经在 $\text{A}$ 加工过了、已经在 $\text{B}$ 加工过了、已经加工完成。总状态达到了 $O(4^n)$，不管是普通的搜索还是状态压缩 $\texttt{dp}$ 都已经失效。再分析题目，只有小于等于 $10$ 的任务加工顺序是任意的，这意味着，有相当一部分的任务状态转移路径是固定的，搜索树规模缩小了很多。但是保存状态仍然需要至少 $O(3^n)$ 的空间，仍然不能承受，所以本题的策略是**搜索**。

搜索是为了枚举每个类型 $3$ 的任务**第一次加工**所在工厂的方案。之后就是计算这种方案的用时，取最小即可。加工顺序直接贪心并不能达到最优，反例很容易举出：只要让某个任务再 $\text{A}$ 和 $\text{B}$ 工厂加工时间相差很大就可以造成误解。所以需要枚举加工的顺序，这样平摊的时间复杂度达到了 $O(\frac{n}{2}!)$，仍然超时。对于这种带阶乘的算法，一种特殊的加速策略便有了用武之地：**随机化贪心**。

具体来说，当枚举出一种方案的时候，先按照加工时间顺序分别对两个工厂加工的任务进行排序。之后，随机交换两个物品的顺序，计算一次，如果用时更少则保留当前决策，否则恢复原状。这个过程需要进行比较多次，本人设置的次数为 $3000$。

还有一些小细节，因为所有任务完成的时间是看最后一个任务完成的时间，两个工厂加工的用时应取较大值（即“最短的木板”）。枚举方案使用深度优先搜索即可。随机化的关键是种子的选取，可参考代码：

```
#include <bits/stdc++.h>

using namespace std;

const int SEED = 9122333444; // 随机种子
const int maxn = 2000 + 5;

struct Task {
	int a, b, type;
};

int n;
Task tasks[maxn];

vector<int> A;
bool key_A(int x, int y) {
	if(tasks[x].b != tasks[x].b) return tasks[x].b < tasks[x].b;
	return tasks[x].a < tasks[x].a;
}

vector<int> B;
bool key_B(int x, int y) {
	if(tasks[x].a != tasks[x].a) return tasks[x].a < tasks[x].a;
	return tasks[x].b < tasks[x].b;
}

int calc() {
	int a_cost = 0, b_cost = 0; // 先加工 A 再加工 B
	int a_cost2 = 0, b_cost2 = 0; // 先加工 B 再加工 A
	for(int i = 0; i < A.size(); i++) {
		a_cost += tasks[A[i]].a;
	}
	for(int i = 0; i < B.size(); i++) {
		b_cost += tasks[B[i]].b;
		a_cost = max(a_cost, b_cost) + tasks[B[i]].a;
	}
	for(int i = 0; i < B.size(); i++) {
		b_cost2 += tasks[B[i]].b;
	}
	for(int i = 0; i < A.size(); i++) {
		a_cost2 += tasks[A[i]].a;
		b_cost2 = max(a_cost2, b_cost2) + tasks[A[i]].b;
	}
	return max(max(a_cost, b_cost), max(a_cost2, b_cost2)); // 注意取的是最大值
}

int best_ans = 0x3f3f3f3f;

int trial() { // 尝试
	if(rand() % 2) { // 随机交换 A 或 B
		if(A.size()) {
			int x = rand() % A.size(), y = rand() % A.size();
			swap(A[x], A[y]);
			int ans = calc();
			if(best_ans > ans) {
				best_ans = ans;
			}
			else {	
				swap(A[x], A[y]); // 方案不更优，还原
			}
		}
	}
	else {
		if(B.size()) {
			int x = rand() % B.size(), y = rand() % B.size();
			swap(B[x], B[y]);
			int ans = calc();
			if(best_ans > ans) {
				best_ans = ans;
			}
			else {	
				swap(B[x], B[y]); // 方案不更优，还原
			}
		}
	}
	return 0;
}

void solve() {
	sort(A.begin(), A.end(), key_A);
	sort(B.begin(), B.end(), key_B);
	for(int i = 1; i <= 3000; i++) trial(); // 3000 次足矣
}

void dfs(int cur) {
	if(cur == n + 1) solve();
	else {
		switch(tasks[cur].type) {
			case 1: { // 只能先在 A 加工
				A.push_back(cur), dfs(cur + 1), A.pop_back();
				break;
			}
			case 2: { // 只能先在 B 加工
				B.push_back(cur), dfs(cur + 1), B.pop_back();
				break;
			}
			case 3: { // 任意
				A.push_back(cur), dfs(cur + 1), A.pop_back();
				B.push_back(cur), dfs(cur + 1), B.pop_back();
				break;
			}
		}
	}
}

int main() {
	srand(SEED);
	cin >> n;
	for(int i = 1; i <= n; i++) {
		cin >> tasks[i].type >> tasks[i].a >> tasks[i].b;
	}
	dfs(1);
	cout << best_ans;
	return 0;
}
```

上面的代码可以获得通过。

***

其实本题还有另外一种思路：配合少量随机化的 $\texttt{A star}$ 算法。

$\texttt{A star}$ 算法要求终态是已知的，而本题的终态就是“所有任务均被完成”。放弃状态压缩 $\texttt{dp}$ 是由于状态太多而时间空间不够，然而 $\texttt{A star}$ 并不需要计算所有状态，只需要遇到解就退出即可。也就是说，如果要让 $\texttt{A star}$ 算法能通过，就需要设计一个较为优秀的估价函数 $h(x)$，使得搜索的无用分支减少。

然而知道了当前状态和终态，似乎并没有什么好的办法可以计算 $h(x)$，这里提供一个办法：由于每个点的状态较少，可以给每个状态加权来代替估价。

比如，当前状态是“已经在 $\text{A}$ 加工过”或“已经在 $\text{B}$ 加工过”，因为只需要加工一次，可以给估价加上一个 $k$，这个 $k$ 是自己设定的。对于需要进行两次加工的“没有加工过”，加上 $2\times k$。当然此时还是需要一定量的剪枝，本人用的是随机化剪枝，即设定一个概率忽略当前搜索分支来达到加速和减轻空间负担的目的。

***

最后，在做题时如果遇到不得不枚举所有情况的阶乘级复杂度算法，可以试着使用随机化，大部分随机化算法的效率和可靠性都是有保证的。如果想要获得正确性更有保证的解，建议采取搜索加剪枝（确保正确性），或者搜索加估价函数即 $\texttt{A star}$。然而，**后者这种方法并不稳定，请慎用**。

---


# [JOISC 2020] 伝説の団子職人

## 题目背景

您是做团子带师，您太强了。

## 题目描述

您面前有一个 $R \times C$ 的网格，每一个格子里有一个团子，您可以横向，竖向，斜向地将三个连续的团子按顺序串起来，按顺序指可以串上中下，下中上之类的，但是不能串中下上，上下中之类的。

如果一串团子的颜色为绿，白，粉或者粉，白，绿，那么称这串团子叫 AK IOI 串。

求串最多 AK IOI 串的方法（我坚信做了几个 AK IOI 串就会 AK 几次 IOI）。

## 说明/提示

#### 样例 1 解释

您做了 $3$ 个 AK IOI 串。

#### 样例 2 解释

您做了 $2$ 个 AK IOI 串。

#### 数据规模与约定

**本题为提交答案题。**

**本题使用 Special Judge。**

一共有 $6$ 组数据，保证 $3 \le R,C \le 500$，输入文件可在附加文件中得到，具体数据表格如下：

|数据点|分数 $S$|及格线 $X$|良好线 $Y$|优秀线 $Z$|
|:-:|:-:|:-:|:-:|:-:|
|$1$|$15$|$44000$|$47000$|$47220$|
|$2$|$15$|$39000$|$41700$|$41980$|
|$3$|$15$|$45000$|$51000$|$51390$|
|$4$|$15$|$18000$|$19000$|$19120$|
|$5$|$20$|$43000$|$48200$|$48620$|
|$6$|$20$|$44000$|$46000$|$46500$|

假设 $N$ 为得到的 AK IOI 串个数，那么评分标准为（四舍五入）：

- $N<X$，$0$ 分
- $X \le N <Y$，$\dfrac{N-X}{2(Y-X)} \times S$ 分
- $Y \le N < Z$，$\left(\dfrac{1}{2}+\dfrac{N-Y}{2(Z-Y)}\right) \times S$ 分
- $Z \le N$，$S$ 分

如果输出格式有误或输出无效，判 $0$ 分。

#### 说明

翻译自 [第１９回日本情報オリンピック　春季トレーニング合宿](https://www.ioi-jp.org/camp/2020/2020-sp-tasks/index.html) [Day4 B 伝説の団子職人 ](https://www.ioi-jp.org/camp/2020/2020-sp-tasks/day4/dango2.pdf)。

## 样例 #1

### 输入

```
3 4
PWGP
WGPW
GWPG```

### 输出

```
P-GP
WGP|
G-PG```

## 样例 #2

### 输入

```
3 4
PWWP
WWWW
PGGP```

### 输出

```
PWWP
W\/W
PGGP```

# 题解

## 作者：Karry5307 (赞：9)

### 题意

略。

### 题解

我我我再也不做调参人了！

参数是重新调的（因为原来的答案丢了），抢了个你谷首 A 还是蛮开心。/cy

一开始想的是枚举白色团子匹配哪两个，如果能匹配就匹配，发现这东西只能写随机贪心，于是考虑变换一下枚举绿色或者粉色，大概这样：

对于一个当前没有匹配的非白色团子，枚举八个方向看能不能匹配，如果能匹配且不会带来冲突则匹配，否则撤销与之冲突团子的匹配，然后类似匈牙利解决冲突问题。

但是这个东西并不能一遍求出最优解，所以大概可以考虑刷一下。对于每一个情况随很多方案出来取个 $\max$ 得到最优方案。

但是这个所谓的最优方案有些时候还不够，于是考虑用这个初始解去刷更好的解，类似模拟退火一样一开始随机的幅度很大，然后后面随机幅度很小来调整，然后多花点时间刷解应该能行。

提交的答案是这样的：

```plain
Data 1: 47220
Data 2: 41984
Data 3: 51391
Data 4: 19129
Data 5: 48625
Data 6: 46503
```

由于增加了许多一轮刷解时候的次数所以目前得到的结果比之前的那一份解法要好，如果大家有更好的答案可以联系我。

下面的代码大概是这么用的：输入测试数据编号和参数（参数为 $0$ 则为刷一个比较好的初始解存到 `.out1` 中，参数为 $1$ 则意味着从 `.out1` 中得到一份好的初始解刷一个更好的），然后一轮大概是 500s 左右的样子可以跑出一个比较好的解，毕竟提答题就是看耐心以及算法的优秀程度。

如果并行的话应该能够在 30min 之内跑完所有 6 个数据。

### 代码

```cpp
#include<bits/stdc++.h>
#pragma GCC optimize("Ofast,unroll-loops")
using namespace std;
typedef int ll;
typedef long long int li;
typedef pair<ll,ll> pii;
const ll MAXN=505;
vector<pii>v;
ll n,m,r,rr,par,tp;
string test;
mt19937 mt(time(0));
ll vx[8]={1,-1,0,0,1,-1,1,-1},vy[8]={0,0,1,-1,1,-1,-1,1};
ll vis[MAXN][MAXN],match[MAXN][MAXN][2],matchr[MAXN][MAXN][2];
char ch[MAXN][MAXN],chr[MAXN][MAXN],res[MAXN][MAXN];
inline ll read()
{
    register ll num=0,neg=1;
    register char ch=getchar();
    while(!isdigit(ch)&&ch!='-')
    {
        ch=getchar();
    }
    if(ch=='-')
    {
        neg=-1;
        ch=getchar();
    }
    while(isdigit(ch))
    {
        num=(num<<3)+(num<<1)+(ch-'0');
        ch=getchar();
    }
    return num*neg;
}
inline char getId(char x)
{
    return x=='|'?0:x=='-'?1:x=='\\'?2:3;
}
inline char getOp(ll x)
{
    return "|-\\/"[x>>1];
}
inline ll dfs(ll x,ll y)
{
    ll wx,wy,px,py,cx,cy;
    if(vis[x][y])
    {
        return 0;
    }
    vis[x][y]=1,v.push_back((pii){x,y});
    for(register int i=0;i<8;i++)
    {
        wx=x+vx[i],wy=y+vy[i],px=wx+vx[i],py=wy+vy[i];
        if(ch[wx][wy]=='W'&&ch[px][py]+ch[x][y]=='P'+'G')
        {
            cx=match[px][py][0],cy=match[px][py][1],ch[wx][wy]=getOp(i);
            if(cx==-1||dfs(cx,cy))
            {
                if(cx!=-1)
                {
                    for(register int j=0;j<8;j++)
                    {
                        if(cx+2*vx[j]==px&&cy+2*vy[j]==py)
                        {
                            ch[cx+vx[j]][cy+vy[j]]='W';
                        }
                    }
                }
                match[px][py][0]=x,match[px][py][1]=y;  
                match[x][y][0]=px,match[x][y][1]=py;
                return 1;
            }   
            ch[wx][wy]='W';
        }
    }
    return 0;
}
inline void calc(ll op)
{
    vector<pii>cc;
    for(register int i=1;i<=n;i++)
    {
        for(register int j=1;j<=m;j++)
        {
            ch[i][j]!='W'&&match[i][j][0]==-1?cc.push_back((pii){i,j}):(void)1;
        }
    }
    if(op)
    {
        shuffle(cc.begin(),cc.end(),mt);
    }
    for(auto i:cc)
    {
        if(match[i.first][i.second][0]==-1)
        {
            r+=dfs(i.first,i.second);
            for(auto j:v)
            {
                vis[j.first][j.second]=0;
            }
            v.clear();
        }
    }
}
inline void calc1(ll c)
{
    vector<pii>undo;
    memcpy(matchr,match,sizeof(match)),memcpy(chr,ch,sizeof(ch)),rr=r;
    for(register int i=1;i<=n;i++)
    {
        for(register int j=1;j<=m;j++)
        {
            !isupper(ch[i][j])?undo.push_back((pii){i,j}):(void)1;
        }
    }
    shuffle(undo.begin(),undo.end(),mt);
    for(auto i:undo)
    {
        if(!(mt()%(ll)ceil(1.5*c)))
        {
            ll x=i.first,y=i.second,tp=getId(ch[x][y]);
            ch[x][y]='W',r--;
            match[x+vx[tp<<1]][y+vy[tp<<1]][0]=-1;
            match[x+vx[tp<<1]][y+vy[tp<<1]][1]=-1;
            match[x+vx[tp<<1|1]][y+vy[tp<<1|1]][0]=-1;
            match[x+vx[tp<<1|1]][y+vy[tp<<1|1]][1]=-1;
        }
    }
    calc(1);
    if(r<rr)
    {
        memcpy(match,matchr,sizeof(match)),memcpy(ch,chr,sizeof(ch)),r=rr;
    }
}
int main()
{
    cin>>test,par=read();
    if(par==0)
    {
        freopen((test+".in").c_str(),"r",stdin);
        freopen((test+".out1").c_str(),"w",stdout);
    }
    if(par==1)
    {
        freopen((test+".out1").c_str(),"r",stdin);
        freopen((test+".out").c_str(),"w",stdout);
    }
    srand(time(0));
    memset(match,-1,sizeof(match));
    if(par==1)
    {
        n=m=500;
    }
    else
    {
        n=read(),m=read();
    }
    fprintf(stderr,"%d %d\n",n,m);
    for(register int i=1;i<=n;i++)
    {
        scanf("%s",ch[i]+1);
    }
    fprintf(stderr,"%d\n",strlen(ch[1]+1));
    if(par)
    {
        for(register int i=1;i<=n;i++)
        {
            for(register int j=1;j<=m;j++)
            {
                if(!isupper(ch[i][j]))
                {
                    tp=getId(ch[i][j]),r++;
                    match[i+vx[tp<<1]][j+vy[tp<<1]][0]=i+vx[tp<<1|1];
                    match[i+vx[tp<<1]][j+vy[tp<<1]][1]=j+vy[tp<<1|1];
                    match[i+vx[tp<<1|1]][j+vy[tp<<1|1]][0]=i+vx[tp<<1];
                    match[i+vx[tp<<1|1]][j+vy[tp<<1|1]][1]=j+vy[tp<<1];
                }
            }
        }
    }
    else
    {
        calc(0);
    }
    fprintf(stderr,"%d\n",r);
    for(register int i=1;i<=200;i++)
    {
        for(register int j=1;j<=60;j++)
        {
            calc1(i);
            if(j%10==0)
            {
                fprintf(stderr,"%d\n",r);
            }
        }
    }
    fprintf(stderr,"%d\n",r);
    for(register int i=1;i<=n;i++)
    {
        printf("%s\n",ch[i]+1);
    }
}
```

---

## 作者：dlhham (赞：5)

看了一圈题解，好像题解里的做法都跑的蛮久的，说一个最慢的点 $60s$ 就能出解的做法吧。
### 题意
略
### 题解
考虑到这个矩阵本来就不算小，所以我就考虑直接瞎子爬山了（就是不带退火参数的退火）。

主体思路是：从当前的状态开始，每次随机一个没有被利用的位置 $(x,y)$。然后从这个位置开始，对这个位置可能的方案中，随机选一个方案，然后把这个位置改成这个方案。这个过程中，有可能会使得别的位置的方案被破坏，那么就把被破坏的位置也加到本次的队列中来，不停的更新，直到队列为空。

一个细节是，在每一轮更新中，我们不要重复的改已经改过的位置，也就是把改过的位置标记出来，在选择方案的时候，如果涉及到了在本轮中被改过的位置，则这个方案不能使用。

其他细节就都没有了，里面没有参数需要调的，

```cpp
#include<bits/stdc++.h>
#define maxn 1000005
#define ll long long
#define mod 998244353
using namespace std;
mt19937 rnd(time(NULL)^clock());
ll rad(int x,int y){return rnd()%(y-x+1)+x;}
int vis[505*505],anss[505*505],pre[505*505]; //记录每个位置属于哪个方案
basic_string<int> choice[505*505]; // 存每个位置的可行方案 
basic_string<int> pos;
map<int,int> gg;
struct nod
{
	int x,y,z,id;
	nod() {}
	nod(int a,int b,int c,int f) {x=a; y=b; z=c; id=f;}
}a[maxn]; 
int id(int x,int y) {return x*505+y;}
int n,m,cnt;
char s[505][505];
void check(int x,int y,int dx,int dy)
{
	if (x+dx+dx>n || x+dx+dx<=0 || y+dy+dy>m || y+dy+dy<=0) return;
	if (s[x][y]=='W' || s[x+dx+dx][y+dy+dy]=='W') return;
	if (s[x+dx][y+dy]!='W') return;
	if (s[x][y]==s[x+dx+dx][y+dy+dy]) return;
	cnt++;
	a[cnt]=nod(id(x,y),id(x+dx,y+dy),id(x+dx+dx,y+dy+dy),cnt);
	choice[id(x,y)]+=cnt;
	choice[id(x+dx,y+dy)]+=cnt;
	choice[id(x+dx+dx,y+dy+dy)]+=cnt;
	return;
}
void init()
{
	for (int i=1;i<=n;i++)
	for (int j=1;j<=m;j++)
	{
		check(i,j,1,0);	 check(i,j,0,1); check(i,j,1,-1); check(i,j,1,1);
	}
}
int ans=0,zd=0;
void fk(int ID)
{
	if (gg[ID]!=0) return;
	gg[ID]=1; pos+=ID;
	pre[ID]=vis[ID];
}
ll yanse,col[505*505];
int head,tail,Q[505*505];
void del(int ID)
{
	if (ID==0) return;
	
	fk(a[ID].x); fk(a[ID].y); fk(a[ID].z);
	
	ans--;
	vis[a[ID].x]=vis[a[ID].y]=vis[a[ID].z]=0;
	
	Q[++tail]=a[ID].x; Q[++tail]=a[ID].y; Q[++tail]=a[ID].z;
	return;
}
void get(int tt,int yanse)
{
	if (vis[a[tt].x]) del(vis[a[tt].x]);
	if (vis[a[tt].y]) del(vis[a[tt].y]);
	if (vis[a[tt].z]) del(vis[a[tt].z]);
	ans++;
	fk(a[tt].x); fk(a[tt].y); fk(a[tt].z);
	
	vis[a[tt].x]=vis[a[tt].y]=vis[a[tt].z]=tt;
	col[a[tt].x]=col[a[tt].y]=col[a[tt].z]=yanse;
	return;
}

void gao(int bh,ll yanse)
{
	head=tail=1;
	Q[head]=bh;
	while (head<=tail)
	{
		int now=Q[head++],siz=choice[now].size();
		if (col[now]==yanse) continue;
		if (siz==0) continue;
		int tim=siz;
		int tt=-1;
		while (tim--)
		{
			tt=rad(0,siz-1); tt=choice[now][tt];
			if (vis[a[tt].x]==tt) {tt=-1; continue;}
			int cnt=0;
			cnt=(col[a[tt].x]==yanse)+(col[a[tt].y]==yanse)+(col[a[tt].z]==yanse);
			if (cnt>=1) {tt=-1; continue;}
		}	
		if (tt==-1) continue;
		get(tt,yanse);
	}
}

void work(int lim)
{
	for (int x=1;x<=n;x++)
	for (int y=1;y<=m;y++)
		anss[id(x,y)]=vis[id(x,y)];
	zd=ans;
	for (int i=1;;i++)
	{
		int x=rad(1,n),y=rad(1,m);
		int bh=id(x,y); int ID=vis[bh];
		
		pos.clear(); gg.clear();
		
		if (vis[bh]==0)
		{
			yanse++;
			gao(bh,yanse);
		}
		
		if (ans<zd)
		{
			for (int tt:pos) vis[tt]=pre[tt];
			ans=zd;
		}	
		
		if (ans>zd)
		{
			for (int x=1;x<=n;x++)
			for (int y=1;y<=m;y++)
				anss[id(x,y)]=vis[id(x,y)];
		}
		zd=max(zd,ans);
		if (i%1000==0) 
		{
			cout<<zd<<endl;
		}
		if (zd>=lim) break;
	}
}

void out()
{
	for (int i=1;i<=n;i++)
	for (int j=1;j<=m;j++)
		vis[id(i,j)]=anss[id(i,j)];
	
	for (int i=1;i<=n;i++)
	for (int j=1;j<=m;j++)
	{
		int ID=id(i,j),tt=vis[ID];
		if (tt!=0 && ID==a[tt].y)
		{
			int xx=i,yy=j; //这是你的坐标
			int px=a[tt].x/505,py=a[tt].x%505;
			int tx=a[tt].z/505,ty=a[tt].z%505;
			
			//上中下 
			if (px+1==xx && yy==py) s[i][j]='|';
			//左中右
			if (py+1==yy && xx==px) s[i][j]='-';
			//↘
			if (px+1==xx && py+1==yy) s[i][j]='\\';
			//↙
			if (px+1==xx && py-1==yy) s[i][j]='/'; 
		}
	}
	for (int i=1;i<=n;i++)
	{
		for (int j=1;j<=m;j++)
			cout<<s[i][j];		
		cout<<endl;
	}
}

int main()
{
	freopen("04.in","r",stdin);
	cin>>n>>m;
	for (int i=1;i<=n;i++) scanf("%s",s[i]+1);
	init();
	work(19120);
	cout<<zd<<endl;
	freopen("04.out","w",stdout);
	out();
} 


```


---

## 作者：SDNetFriend (赞：4)

## P7218 [JOISC2020] 伝説の団子職人

~~模拟退火真的是太好玩了！~~

upd：发现原程序实际上是一份爬山，现添加说明并补充模拟退火代码。

upd:取消了 NP-Hard 的 LaTeX。

### 题意这里不再赘述

[P7218 [JOISC2020] 伝説の団子職人](https://www.luogu.com.cn/problem/P7218)

### 做法分析

我们可以看出这个问题可以转化成一般图的最大独立集。

即我们把几串共用了相同位置的丸子连边，表示它们不能同时存在，于是这个问题就转化完成了。

我们知道这是个 NP-Hard 问题，那就需要考虑模拟退火。

先按一串一串地把图建好。然后退火过程中，每次选一个没选的点，选中它并退掉与它相连的已选中的点，**并更新与退掉的点相连的那些点**（这一步很重要不然答案越跑越劣）。

然后前面几篇题解是用数据结构维护没选的点每次随机排名，实际上直接纯随就可以，一直随直到随到一个没选的点，实测命中率还是相当高的。

### 建图

这里是考虑每个中间的 `W`，分别讨论四个方向。只要保证两边都不是 `W` 并且不同即可。

对于连边这里在每个点上开了个 `vector` 存包含该点串的编号。

（似乎是现有题解区里最短的代码了）

### 调参

这个玩意调了我一上午，主要是模拟退火要保证接受劣解的概率不要太高，实在不行给 $d$ 乘上一个系数 $k$ 来放大代价，不然就会越跑越劣甚至干不过爬山。~~模拟退化算法~~

因为后来发现通过的实际上已经退化成了爬山，所以这里不再给出所有的参数，仅放出第五个点相对较优的参数：

`#5:T=6,dta=0.999995,k=16`

不知道为什么爬山能过，所以这里放出两份代码。

### 贴代码

#### 爬山：

```cpp
#include <bits/stdc++.h>
#define lint long long
using namespace std;
inline int read(){
	char c;int f=1,res=0;
	while(c=getchar(),!isdigit(c))if(c=='-')f*=-1;
	while(isdigit(c))res=res*10+c-'0',c=getchar();
	return res*f;
}
const int N=505,P=N*N*8;
int hed[P],nxt[P],ver[P],cnt=1;
inline void ae(int u,int v){
	ver[++cnt]=v;
	nxt[cnt]=hed[u];
	hed[u]=cnt;
}
inline void lnk(int u,int v)
	{ae(u,v);ae(v,u);}
vector<int> ex[N][N];
int d[4][2]={{0,1},{1,0},{1,1},{1,-1}};
char c[4]={'-','|','\\','/'};
struct pnt{int x,y,d;}p[P];
int n,m,tot=0;char s[N][N];
inline void inst(int x,int y,int dir){//加点 
	int x0=x+d[dir][0],y0=y+d[dir][1];
	int x1=x-d[dir][0],y1=y-d[dir][1];
	if(x0<1||y0<1||x1<1||y1<1)return;
	if(x0>n||x1>n||y0>m||y1>m)return;
	if(s[x0][y0]=='W'||s[x1][y1]=='W')
		return;
	if(s[x][y]!='W'||s[x0][y0]==s[x1][y1])
		return;
	int u=++tot;p[u]=pnt{x,y,dir};
	for(int v:ex[x][y])lnk(u,v);ex[x][y].push_back(u);
	for(int v:ex[x0][y0])lnk(u,v);ex[x0][y0].push_back(u);
	for(int v:ex[x1][y1])lnk(u,v);ex[x1][y1].push_back(u);
}
inline void build(){//建图 
	for(int i=1;i<=n;++i)
		for(int j=1;j<=m;++j)
			for(int k=0;k<4;++k)
				inst(i,j,k);
}
int ans;
bitset<P> vis,_vis,avis;
inline bool ck(int u){//判断当前点能否选 
	if(_vis[u])return false;
	for(int e=hed[u];e;e=nxt[e])
		if(_vis[ver[e]])return false;
	return true;
}
inline int calc(){//产生初始解 
	int res=0;
	for(int u=1;u<=tot;++u)
		if(ck(u))_vis[u]=1,++res;
	return res;
}
inline int rnd(int md)
	{return 1ll*rand()*rand()%md+1;}
inline int del(int u){
	_vis[u]=0;int res=0;
	for(int e=hed[u];e;e=nxt[e])
		if(ck(ver[e]))_vis[ver[e]]=1,++res;
	return res;
}
inline int upd(){//产生新解 
	_vis=vis;
	int res=0,t=0;
	while(++t<=10){//没什么用的防死循环 
		int u=rnd(tot);
		if(_vis[u])continue;
		_vis[u]=1;++res;
		for(int e=hed[u];e;e=nxt[e]){
			int v=ver[e];
			if(_vis[v])res+=del(v)-1;
			//退掉与u相连的v并更新与v相连的点 
		}break;
	}return res;
}
inline void SA(){
	ans=calc();vis=_vis;
	int res=ans,_res;
	double T=0.01,dta=0.999999,k=16;
	while(ans<48620){
		_res=res+upd();
		if(_res>ans)//也许这里不是比较全局答案，但好像这样跑得快些 
			avis=vis=_vis,ans=res=_res,cout<<T<<" "<<ans<<endl;
		else if(exp(k*(_res-ans)/T)*RAND_MAX>rand())
			vis=_vis,res=_res;
		T*=dta;
	}
}
int main(){
	freopen("05.in","r",stdin);
	n=read();m=read();
	for(int i=1;i<=n;++i)
		scanf("%s",s[i]+1);
	build();SA();
	for(int i=1;i<=tot;++i)
		if(avis[i])
			s[p[i].x][p[i].y]=c[p[i].d];
	freopen("05.ans","w",stdout);
	for(int i=1;i<=n;++i)
		printf("%s\n",s[i]+1);
	return 0;
}
```

#### 模拟退火：

```cpp
#include <bits/stdc++.h>
#define lint long long
using namespace std;
inline int read(){
	char c;int f=1,res=0;
	while(c=getchar(),!isdigit(c))if(c=='-')f*=-1;
	while(isdigit(c))res=res*10+c-'0',c=getchar();
	return res*f;
}
const int N=505,P=N*N*8;
int hed[P],nxt[P],ver[P],cnt=1;
inline void ae(int u,int v){
	ver[++cnt]=v;
	nxt[cnt]=hed[u];
	hed[u]=cnt;
}
inline void lnk(int u,int v)
	{ae(u,v);ae(v,u);}
vector<int> ex[N][N];
int d[4][2]={{0,1},{1,0},{1,1},{1,-1}};
char c[4]={'-','|','\\','/'};
struct pnt{int x,y,d;}p[P];
int n,m,tot=0;char s[N][N];
inline void inst(int x,int y,int dir){//加点 
	int x0=x+d[dir][0],y0=y+d[dir][1];
	int x1=x-d[dir][0],y1=y-d[dir][1];
	if(x0<1||y0<1||x1<1||y1<1)return;
	if(x0>n||x1>n||y0>m||y1>m)return;
	if(s[x0][y0]=='W'||s[x1][y1]=='W')
		return;
	if(s[x][y]!='W'||s[x0][y0]==s[x1][y1])
		return;
	int u=++tot;p[u]=pnt{x,y,dir};
	for(int v:ex[x][y])lnk(u,v);ex[x][y].push_back(u);
	for(int v:ex[x0][y0])lnk(u,v);ex[x0][y0].push_back(u);
	for(int v:ex[x1][y1])lnk(u,v);ex[x1][y1].push_back(u);
}
inline void build(){//建图 
	for(int i=1;i<=n;++i)
		for(int j=1;j<=m;++j)
			for(int k=0;k<4;++k)
				inst(i,j,k);
}
int ans;
bitset<P> vis,_vis,avis;
inline bool ck(int u){//判断当前点能否选 
	if(_vis[u])return false;
	for(int e=hed[u];e;e=nxt[e])
		if(_vis[ver[e]])return false;
	return true;
}
inline int calc(){//产生初始解 
	int res=0;
	for(int u=1;u<=tot;++u)
		if(ck(u))_vis[u]=1,++res;
	return res;
}
inline int rnd(int md)
	{return 1ll*rand()*rand()%md+1;}
inline int del(int u){
	_vis[u]=0;int res=0;
	for(int e=hed[u];e;e=nxt[e])
		if(ck(ver[e]))_vis[ver[e]]=1,++res;
	return res;
}
inline int upd(){//产生新解 
	_vis=vis;
	int res=0,t=0;
	while(++t<=10){//没什么用的防死循环 
		int u=rnd(tot);
		if(_vis[u])continue;
		_vis[u]=1;++res;
		for(int e=hed[u];e;e=nxt[e]){
			int v=ver[e];
			if(_vis[v])res+=del(v)-1;
			//退掉与u相连的v并更新与v相连的点 
		}break;
	}return res;
}
inline void SA(){
	ans=calc();vis=_vis;
	int res=ans,_res;
	double T=6,dta=0.999995,k=16;
	while(ans<48620){
		_res=res+upd();
		if(_res>=res){
			if(_res>ans)
				ans=_res,avis=_vis,cout<<T<<" "<<_res<<endl;
			vis=_vis;res=_res;
		}else if(exp(k*(_res-res)/T)*2e9>rnd(2e9))
			vis=_vis,res=_res;
		T*=dta;
	}
}
int main(){
	ios::sync_with_stdio(false);
	freopen("05.in","r",stdin);
	n=read();m=read();
	for(int i=1;i<=n;++i)
		scanf("%s",s[i]+1);
	build();SA();
	for(int i=1;i<=tot;++i)
		if(avis[i])
			s[p[i].x][p[i].y]=c[p[i].d];
	freopen("05.ans","w",stdout);
	for(int i=1;i<=n;++i)
		printf("%s\n",s[i]+1);
	return 0;
}
```


---

## 作者：jun头吉吉 (赞：2)

首先对有公共点的串串连边，然后就是求一个大于某个大小的独立集。

题解全是模拟退火，但是我不会调参。所以我用了一种养生的解法，就是写成 01线性规划 的形式，然后直接用现成的求解器（比如 Gurobi）就能过了。

因为我不会 Gurobi 在 c++ 里使用所以写成了三个文件，一个连边，一个求解，一个输出方案：

```cpp
const int ax[3]={1,0,-1},ay[3]={0,0,0};
const int bx[3]={0,0,0},by[3]={1,0,-1};
const int cx[3]={1,0,-1},cy[3]={1,0,-1};
const int dx[3]={1,0,-1},dy[3]={-1,0,1};
char s[510][510];
array<pair<int,int>,3>ss[510*510*4];int cnt;
#define deal(arr,xx,yy) {\
	bool flag=1;for(int i=0;i<3;i++)if(xx+(arr##x)[i]<0||yy+(arr##y)[i]<0||xx+(arr##x)[i]>=n||yy+(arr##y)[i]>=m)flag=0;\
	if(flag){\
		array<pair<int,int>,3>tmp;\
		for(int i=0;i<3;i++)tmp[i]=mp(xx+(arr##x)[i],yy+(arr##y)[i]);\
		if(s[tmp[0].fi][tmp[0].se]=='P'&&s[tmp[1].fi][tmp[1].se]=='W'&&s[tmp[2].fi][tmp[2].se]=='G')ss[++cnt]=tmp;\
		reverse(tmp.begin(),tmp.end());\
		if(s[tmp[0].fi][tmp[0].se]=='P'&&s[tmp[1].fi][tmp[1].se]=='W'&&s[tmp[2].fi][tmp[2].se]=='G')ss[++cnt]=tmp;\
	}\
}
signed main(){
	freopen("input_06.txt","r",stdin);
	freopen("1.txt","w",stdout);
	int n,m;read(n,m);
	for(int i=0;i<n;i++)scanf("%s",s[i]);
	for(int X=0;X<n;X++)for(int Y=0;Y<m;Y++){
		deal(a,X,Y);
		deal(b,X,Y);
		deal(c,X,Y);
		deal(d,X,Y);
	}
	printf("%d 46500\n",cnt);
	for(int i=1;i<=cnt;i++){for(int j=i+1;j<=cnt;j++){
		bool flag=0;for(auto x:ss[i])for(auto y:ss[j])if(x==y)flag=1;
		if(flag)printf("%d %d\n",i,j);
	}if(i%1000==0)cerr<<i<<endl;}
}
```


```python
from gurobipy import *
m = Model("mipl")
f = open("1.txt")
s = f.read().split('\n')
f.close()
n,c = map(int, s[0].split(' '))
s.remove(s[0])
var = [0]
for i in range(1,n+1):
	var.append(m.addVar(vtype=GRB.BINARY,name=str(i)))
for con in s:
	if con!='':
		a,b = map(int, con.split(' '))
		m.addConstr(var[a] + var[b] <=1, str(a)+'_'+str(b))
m.addConstr(sum([var[i] for i in range(1,n+1)]) >= c, "ans")
m.optimize()
f = open('1.out','w')
for i in range(1,n+1):
	f.write(str(int(var[i].x)))
f.close()
```

```cpp
const int ax[3]={1,0,-1},ay[3]={0,0,0};char a='|';
const int bx[3]={0,0,0},by[3]={1,0,-1};char b='-';
const int cx[3]={1,0,-1},cy[3]={1,0,-1};char c='\\';
const int dx[3]={1,0,-1},dy[3]={-1,0,1};char d='/';
char s[510][510];
array<pair<int,int>,3>ss[510*510*4];int Xx[510*510*4],Yy[510*510*4];char nm[510*510*4];int cnt;
#define deal(arr,xx,yy) {\
	bool flag=1;for(int i=0;i<3;i++)if(xx+(arr##x)[i]<0||yy+(arr##y)[i]<0||xx+(arr##x)[i]>=n||yy+(arr##y)[i]>=m)flag=0;\
	if(flag){\
		array<pair<int,int>,3>tmp;\
		for(int i=0;i<3;i++)tmp[i]=mp(xx+(arr##x)[i],yy+(arr##y)[i]);\
		if(s[tmp[0].fi][tmp[0].se]=='P'&&s[tmp[1].fi][tmp[1].se]=='W'&&s[tmp[2].fi][tmp[2].se]=='G')ss[++cnt]=tmp,Xx[cnt]=xx,Yy[cnt]=yy,nm[cnt]=arr;\
		reverse(tmp.begin(),tmp.end());\
		if(s[tmp[0].fi][tmp[0].se]=='P'&&s[tmp[1].fi][tmp[1].se]=='W'&&s[tmp[2].fi][tmp[2].se]=='G')ss[++cnt]=tmp,Xx[cnt]=xx,Yy[cnt]=yy,nm[cnt]=arr;\
	}\
}
char res[510*510*4];
signed main(){
	freopen("input_06.txt","r",stdin);
	int n,m;read(n,m);
	for(int i=0;i<n;i++)scanf("%s",s[i]);
	freopen("1.out","r",stdin);
	freopen("output_06.txt","w",stdout);
	for(int X=0;X<n;X++)for(int Y=0;Y<m;Y++){
		deal(a,X,Y);
		deal(b,X,Y);
		deal(c,X,Y);
		deal(d,X,Y);
	}
	scanf("%s",res+1);
	for(int i=1;i<=cnt;i++)if(res[i]-'0')s[Xx[i]][Yy[i]]=nm[i];
	for(int i=0;i<n;i++)puts(s[i]);
}
```

有一说一 Gurobi 的速度还蛮快的每个都可以在 10s 左右跑出解，所以最慢的反而是我的暴力建图 ，不要用暴力应该就能在 15s 内算出每个答案。

---

## 作者：wlzhouzhuan (赞：2)

# JOISC2020
## Day4T2 传奇团子师傅

安利可视化工具 [visualizer.html](https://www.ioi-jp.org/camp/2020/2020-sp-tasks/day4/dango2-visualizer.html)

将所有的 $\text{PWG}$ 串之间的互斥关系连边，问题转化为求一般图的最大独立集。

考虑模拟退火，一个较优的贪心策略是每次随机一个点，设这个点加入后的贡献是 $x$ ，如果 $x>0$ 直接加，否则 $exp$ 概率接受。

随机点的部分，随机一个 $rank$ ，用线段树寻找对应的点，然后直接做即可。

需要调整合适的参数，然后就能爆踩 **优秀线$Z$** 了。 

时间复杂度 $O(Cnlogn)$ ，$C$ 是退火次数。

一些特殊性质：

- $\text{data 2}$ ：大小为 $25\times 25$ 的子矩阵相同，处理小矩形即可；

- $\text{data 3}$ ：不存在斜对角的串，可简化一定运算量；

- $\text{data 4}$ ：几乎都是 $W$ ，所以串分布特别稀疏，可小范围搜索，最后拼接起来；

我存了 $6$ 份代码同时运行了 $20+$ 分钟才跑出优秀线 $Z$ 。。。

```cpp
// Author: wlzhouzhuan
#pragma GCC optimize(2)
#pragma GCC optimize(3)
#pragma GCC optimize("Ofast")
#include <bits/stdc++.h>
using namespace std;

#define pb push_back

mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
int random(int l, int r) {
  return uniform_int_distribution<int>(l, r)(rng);
}

const int N = 1005;
char s[N];
vector<int> V[N][N], adj[4 * N * N];
int col[N][N], ans[N][N], n, m, tot;

// SegmentTree
#define ls (u << 1)
#define rs (u << 1 | 1)
int sum[4 * N * N << 2];
void pushup(int u) {
  sum[u] = sum[ls] + sum[rs];
}
void build(int u, int l, int r) {
  if (l == r) {
    sum[u] = 1;
    return ;
  }
  int mid = l + r >> 1;
  build(ls, l, mid), build(rs, mid + 1, r);
  pushup(u);
}
void update(int u, int l, int r, int pos, int dlt) {
  if (l == r) {
    sum[u] += dlt;
    return ;
  }
  int mid = l + r >> 1;
  if (pos <= mid) update(ls, l, mid, pos, dlt);
  else update(rs, mid + 1, r, pos, dlt);
  pushup(u);
}
int query(int u, int l, int r, int rnk) {
  if (l == 1 && r == tot) assert(rnk <= r - l + 1);
  if (l == r) {
    assert(rnk == 1);
    return l;
  }
  int mid = l + r >> 1;
  if (sum[ls] >= rnk) return query(ls, l, mid, rnk);
  else return query(rs, mid + 1, r, rnk - sum[ls]);
}

int dot, vis[4 * N * N];
int ans_dot, ans_vis[4 * N * N];

void updans() {
  ans_dot = dot;
  for (int i = 1; i <= tot; i++) ans_vis[i] = vis[i];
}
void SA() {
  for (int i = 1; i <= tot; i++) vis[i] = 0;
  double T = 1000, alpha = 0.99994;
  build(1, 1, tot);
  dot = 0;
  while (T >= 1e-6) {
    for (int times = 1; times <= 5; times++) { 
//      if (dot == tot) {
//        puts("wtf");
//      }
      int rnk = random(1, tot - dot);
      assert(dot >= 0);
//      printf("tot = %d, dot = %d, rnk = %d\n", tot, dot, rnk);
      int u = query(1, 1, tot, rnk);
      assert(!vis[u]);
//      printf("%d\n", u);
      int adds = 1;
      for (auto v: adj[u]) if (vis[v]) {
        adds--;
      }
//      printf("adds = %d\n", adds);
      int ok = 0;
      if (adds > 0 || exp(10.0 * adds / T) > rng() / 4294967296.0) {
        vis[u] = 1, update(1, 1, tot, u, -1);
        for (auto v: adj[u]) if (vis[v]) {
          vis[v] = 0, update(1, 1, tot, v, 1);
        }
        dot += adds;
        if (dot > ans_dot) updans();
      }
    }
    T *= alpha;
  }
}

int main() {
  freopen("01.in", "r", stdin);
  freopen("01.out", "w", stdout);
  scanf("%d%d", &n, &m);
  n += 2, m += 2;
  for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= m; j++) {
      col[i][j] = ans[i][j] = 2;
    }
  }
  for (int i = 2; i < n; i++) {
    scanf("%s", s + 2);
    for (int j = 2; j < m; j++) {
      if (s[j] == 'P') col[i][j] = ans[i][j] = 0;
      if (s[j] == 'G') col[i][j] = ans[i][j] = 1;
    }
  }
  for (int i = 2; i < n; i++) {
    for (int j = 2; j < m; j++) {
      if (col[i][j] == 2) {
        if ((col[i - 1][j] ^ col[i + 1][j]) == 1) {
          tot++;
          V[i - 1][j].pb(tot);
          V[i + 1][j].pb(tot);
        }
        if ((col[i][j - 1] ^ col[i][j + 1]) == 1) {
          tot++;
          V[i][j - 1].pb(tot);
          V[i][j + 1].pb(tot);
        }
        if ((col[i - 1][j - 1] ^ col[i + 1][j + 1]) == 1) {
          tot++;
          V[i - 1][j - 1].pb(tot);
          V[i + 1][j + 1].pb(tot);
        }
        if ((col[i - 1][j + 1] ^ col[i + 1][j - 1]) == 1) {
          tot++;
          V[i - 1][j + 1].pb(tot);
          V[i + 1][j - 1].pb(tot);
        }
      }
    }
  }
  cerr << "tot = " << tot << '\n';
  for (int i = 2; i < n; i++) {
    for (int j = 2; j < m; j++) {
      int sz = V[i][j].size();
      for (int x = 0; x < sz; x++) {
        for (int y = 0; y < x; y++) {
          int u = V[i][j][x], v = V[i][j][y];
          adj[u].pb(v), adj[v].pb(u);
        }
      }
    }
  }
  SA();
  cerr << "ans_dot = " << ans_dot << '\n';
  tot = 0;
  for (int i = 2; i < n; i++) {
    for (int j = 2; j < m; j++) {
      if (col[i][j] == 2) {
        if ((col[i - 1][j] ^ col[i + 1][j]) == 1) {
          tot++;
          if (ans_vis[tot]) ans[i][j] = 3;
        }
        if ((col[i][j - 1] ^ col[i][j + 1]) == 1) {
          tot++;
          if (ans_vis[tot]) ans[i][j] = 4;
        }
        if ((col[i - 1][j - 1] ^ col[i + 1][j + 1]) == 1) {
          tot++;
          if (ans_vis[tot]) ans[i][j] = 5;
        }
        if ((col[i - 1][j + 1] ^ col[i + 1][j - 1]) == 1) {
          tot++;
          if (ans_vis[tot]) ans[i][j] = 6;
        }
      }
    }
  }
  int Points = 0;
  for (int i = 2; i < n; i++) {
    for (int j = 2; j < m; j++) {
      switch (ans[i][j]) {
        case 0: putchar('P'); break;
        case 1: putchar('G'); break;
        case 2: putchar('W'); break;
        case 3: putchar('|'); Points++; break;
        case 4: putchar('-'); Points++; break;
        case 5: putchar('\\'); Points++; break;
        case 6: putchar('/'); Points++; break;
      }
    }
    putchar('\n');
  }
  cerr << "Points = " << Points << '\n';
  return 0;
}
```

---

## 作者：7KByte (赞：0)

提交答案题，给定一个网格，需要找到尽量多的不相交的 ``PWG`` 串。

首先原图中出现的 ``PWG`` 串是 $\mathcal{O}(RC)$ 级别的，可以直接找出来。

然后对于两个相交的 ``PWG`` 串连边，边数也是 $\mathcal{O}(RC)$ 级别的，可以直接将图建出来。

那么原图的最大独立集就是最优解，但是我们知道这是 NP-Hard 问题。

考虑直接模拟退火，每次随机选择一个没有选择的点，强行选择这个点，并将与他相邻的点取消选择。

剩下的就是调参。

```cpp
#include<cstdio>
#include<cmath>
#define rep(i,a,b) for(int i=a;i<=b;i++)
#define pre(i,a,b) for(int i=a;i>=b;i--)
#define N 505
#define M 130020
using namespace std;
int n,m,u[N][N][4],idx,ans=0;char s[N][N];
int h[M],tot,v[M],w[M];
struct edge{int to,nxt;}e[M*5];
void add(int x,int y){e[++tot].nxt=h[x];h[x]=tot;e[tot].to=y;e[++tot].nxt=h[y];h[y]=tot;e[tot].to=x;}
namespace RAND{
	bool isInit;
	int index;
	int MT[624];  //624 * 32 - 31 = 19937
	void srand(int seed)
	{
	   	index = 0;
	    isInit = 1;
	    MT[0] = seed;
	    for(int i=1; i<624; i++)
	    {
	        int t = 1812433253 * (MT[i-1] ^ (MT[i-1] >> 30)) + i;
	        MT[i] = t & 0xffffffff;
	    }
	}
	void generate(){
	    for(int i=0; i<624; i++)
	    {
	        int y = (MT[i] & 0x80000000) + (MT[(i+1) % 624] & 0x7fffffff);
	        MT[i] = MT[(i + 397) % 624] ^ (y >> 1);
	        if (y & 1)
	            MT[i] ^= 2567483615;
	    }
	}
	int rand(){
	    if(!isInit)
	        srand(19260817);
	    if(index == 0)
	        generate();
	    int y = MT[index];
	    y = y ^ (y >> 11);
	    y = y ^ ((y << 7) & 2636928640);
	    y = y ^ ((y << 15) & 4022730752);
	    y = y ^ (y >> 18);
	    index = (index + 1) % 624;
	    return y;
	}
}
int c[M];
inline void ins(int x,int val){for(;x<=idx;x+=x&-x)c[x]+=val;}
inline int ask(int k){
	int cur=0;
	pre(i,17,0)if(cur+(1<<i)<=idx&&c[cur+(1<<i)]<k)cur+=1<<i,k-=c[cur];
	return cur+1;
}
using namespace RAND;
int main(){
	freopen("01.in","r",stdin);
	//freopen("01.out","w",stdout);
	scanf("%d%d",&n,&m);
	rep(i,1,n)scanf("%s",s[i]+1);
	rep(i,1,n)rep(j,1,m-2)
		if(s[i][j]!=s[i][j+1]&&s[i][j]!=s[i][j+2]&&s[i][j+1]!=s[i][j+2]&&s[i][j+1]=='W')u[i][j][0]=++idx;//,cout<<"ss "<<i<<" "<<j<<" 0"<<endl;
	rep(i,1,n-2)rep(j,1,m)
		if(s[i][j]!=s[i+1][j]&&s[i][j]!=s[i+2][j]&&s[i+1][j]!=s[i+2][j]&&s[i+1][j]=='W')u[i][j][1]=++idx;//,cout<<"ss "<<i<<" "<<j<<" 1"<<endl;
	rep(i,1,n-2)rep(j,1,m-2)
		if(s[i][j]!=s[i+1][j+1]&&s[i][j]!=s[i+2][j+2]&&s[i+1][j+1]!=s[i+2][j+2]&&s[i+1][j+1]=='W')u[i][j][2]=++idx;//,cout<<"ss "<<i<<" "<<j<<" 2"<<endl;
	rep(i,3,n)rep(j,1,m-2)
		if(s[i][j]!=s[i-1][j+1]&&s[i][j]!=s[i-2][j+2]&&s[i-1][j+1]!=s[i-2][j+2]&&s[i-1][j+1]=='W')u[i][j][3]=++idx;//,cout<<"ss "<<i<<" "<<j<<" 3"<<endl;
	rep(i,1,n)rep(j,1,m-2)if(u[i][j][0]){
		rep(k,0,2)rep(p,0,2)if(i>k&&j>k-p&&u[i-k][j-k+p][2])add(u[i][j][0],u[i-k][j-k+p][2]);
		rep(k,1,2)if(j>k&&u[i][j-k][0])add(u[i][j-k][0],u[i][j][0]);
		rep(k,0,2)rep(p,0,2)if(i+k<=n&&j>k-p&&u[i+k][j-k+p][3])add(u[i][j][0],u[i+k][j-k+p][3]);
		rep(k,0,2)rep(p,0,2)if(i>k&&u[i-k][j+p][1])add(u[i-k][j+p][1],u[i][j][0]);
	}
	rep(i,1,n-2)rep(j,1,m)if(u[i][j][1]){
		rep(k,1,2)if(i>k&&u[i-k][j][1])add(u[i-k][j][1],u[i][j][1]);
		rep(k,0,2)rep(p,0,2)if(j>k&&i>k-p&&u[i-k+p][j-k][2])add(u[i][j][1],u[i-k+p][j-k][2]);
		rep(k,0,2)rep(p,0,2)if(i+k+p<=n&&j>k&&u[i+k+p][j-k][3])add(u[i][j][1],u[i+k+p][j-k][3]);
	}
	rep(i,1,n-2)rep(j,1,m-2)if(u[i][j][2]){
		rep(k,1,2)if(i>k&&j>k&&u[i-k][j-k][2])add(u[i][j][2],u[i-k][j-k][2]);
		rep(k,0,2)rep(p,0,2)if(i+k+p<=n&&j+k>p&&u[i+k+p][j+k-p][3])add(u[i][j][2],u[i+k+p][j+k-p][3]);
	}
	rep(i,3,n)rep(j,1,m-2)if(u[i][j][3]){
		rep(k,1,2)if(u[i-k][j+k][3])add(u[i][j][3],u[i-k][j+k][3]);
	}
	rep(x,1,idx){
		//printf("ss %d\n",x);
		bool flag=true;
		for(int i=h[x];i;i=e[i].nxt)flag&=!w[e[i].to];
		if(flag)ans++,w[x]=1;
		else ins(x,1);
	}
	printf("%d\n",ans);
	int sum = ans ;rep(i,1,idx)v[i]=w[i];
	while(ans < 47220){
		//,printf("%d ",v[i]);putchar('\n');
		double T = 10 ;const double dta = 0.9999999 , eps = 1e-2 ;const double k = 16.0;
		while(T > eps){
			T*=dta;
			int rk = (rand() % (idx-sum) ) + 1;
			int x =ask(rk);
			//printf("%.10lf %d %d %d %d\n",T,x,sum,rand(),rk);
			//rep(i,1,idx)printf("%d ",v[i]);putchar('\n');
			//if(v[x])puts("Error");
			int now = 1;
			for(int i=h[x];i;i=e[i].nxt)
				if(v[e[i].to])now--;
			if(now==1|| exp(k*now/T) > rand()/2147483647.00){
				for(int i=h[x];i;i=e[i].nxt)if(v[e[i].to])
					v[e[i].to]=0,ins(e[i].to,1);
				ins(x,-1);v[x]=1;sum+=now;
				if(sum>ans){
					ans=sum;
					rep(i,1,idx)w[i]=v[i];
					printf("%d\n",ans);
				}
			}
		}
	}
	rep(i,1,n)rep(j,1,m){
		if(w[u[i][j][0]]){
			s[i][j+1]='-';
		}
		else if(w[u[i][j][1]]){
			s[i+1][j]='|';
		}
		else if(w[u[i][j][2]]){
			s[i+1][j+1]='\\';
		}
		else if(w[u[i][j][3]]){
			s[i-1][j+1]='/';
		}
	}
	freopen("01.out","w",stdout);
	rep(i,1,n)puts(s[i]+1);
	return 0;
} 
```

效率还是比较高的，除了第 $5$ 个测试点，其他点都能在 $120$ 秒之内出解。

对于第 $5$ 组数据，没找到什么好方法，二分调参，最后能在 $1200$ 秒内出解。

下面是各组数据对应的参数。

```cpp
Testdata1 :
double T = 10 ;const double dta = 0.9999999 , eps = 1e-2 ;const double k = 16.0;

Testdata2 :
double T = 10 ;const double dta = 0.9999999 , eps = 1e-2 ;const double k = 16.0;

Testdata3 :
double T = 8 ;const double dta = 0.99999999 , eps = 1;const double k = 16.0;

Testdata4 :
double T = 3 ;const double dta = 0.99999999 , eps = 1e-3 ;const double k = 16.0;

Testdata5 :
double T = 8 ;const double dta = 0.9999999 , eps = 1e-7 ;const double k = 16.0;

Testdata6 :
double T = 4 ;const double dta = 0.99999999 , eps = 1e-2 ;const double k = 16.0;

```

---


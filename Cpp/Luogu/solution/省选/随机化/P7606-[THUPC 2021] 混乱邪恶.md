# [THUPC 2021] 混乱邪恶

## 题目背景

出题人分为 $9$ 种阵营：守序善良、守序中立、守序邪恶、中立善良、绝对中立、中立邪恶、混乱善良、混乱中立和混乱邪恶。真正的出题人，就要能够在阵营之间不断切换，而又不迷失在境界之中。

境界是一个无限大的三角形网格。网格如下图，每个交叉点都有 $6$ 个相邻的交叉点。你从某一个交叉点出发，每次给一个出题 idea 设定风格都会使你在境界中移动一步。

![](https://cdn.luogu.com.cn/upload/image_hosting/dwgwh04i.png)

## 题目描述

每个出题人都有一个守序指数 $L$ 和善良指数 $G$。对于一个 idea，从题面、样例或数据范围的角度，可以从 $6$ 个方向中选择恰好一个作为这个 idea 对应的题目的特有风格，同时会在境界中沿着所选的箭头方向移动一步：

![](https://cdn.luogu.com.cn/upload/image_hosting/5k7jqygw.png)

你现在一共有 $n$ 个 idea，你知道你给每个 idea 设定某一个风格时你的 $L$ 指数和 $G$ 指数的变化。具体地，对于第 $i$ 个idea有 $12$ 个参数 $tl_{i,l},tl_{i,g},l_{i,l},l_{i,g},bl_{i,l},bl_{i,g},br_{i,l},br_{i,g},r_{i,l},r_{i,g},tr_{i,l},tr_{i,g}$：

如果选择“简洁的题面”，那么 $L$ 变成 $L+tl_{i,l}$，$G$ 变成 $G+tl_{i,g}$；

如果选择“平凡无用的样例”，那么 $L$ 变成 $L+l_{i,l}$，$G$ 变成 $G+l_{i,g}$；

如果选择“宽松的数据范围”，那么 $L$ 变成 $L+bl_{i,l}$，$G$ 变成 $G+bl_{i,g}$；

如果选择“复杂的题面”，那么 $L$ 变成 $L+br_{i,l}$，$G$ 变成 $G+br_{i,g}$；

如果选择“无私馈赠的样例”，那么 $L$ 变成 $L+r_{i,l}$，$G$ 变成 $G+r_{i,g}$；

如果选择“松松松的数据范围”，那么 $L$ 变成 $L+tr_{i,l}$，$G$ 变成 $G+tr_{i,g}$。

这里所有的加法都在模 $p$ 意义下进行。

进入混乱邪恶阵营的要求很苛刻，需要 $L$ 恰好等于 $L^*$ 且 $G$ 恰好等于 $G^*$。

你的 $L$ 指数和 $G$ 指数开始时都为 $0$。请问是否存在一种设定风格的方式使得设定完全部 $n$ 个 idea 的风格后你仍在境界中原来的位置，但是能够进入混乱邪恶阵营。

## 说明/提示

**【样例解释】**

给第 $1$ 个 idea 设定风格为”简洁的题面“，此时你的守序指数为 $0+3=3$，善良指数为 $0+5=5$。你往左上方移动一步。

给第 $3$ 个 idea 设定风格为”宽松的数据范围“，此时你的守序指数为 $3+9=2$，善良指数为 $5+3=8$。你往左下方移动一步。

给第 $2$ 个 idea 设定风格为”无私馈赠的样例“，此时你的守序指数为 $2+1=3$，善良指数为 $8+4=2$。你往右边移动一步。此时你回到了原点并且守序指数为 $3$，善良指数为 $2$。所以你可以进入混乱邪恶阵营。

**【数据范围】**

保证 $1 \le n \le 100$，$1 \le p \le 100$。

保证其他输入数据在 $0$ 到 $p-1$ 之间。

**【题目来源】**

来自 2021 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2021）。

题解等资源可在 [https://github.com/yylidiw/thupc_1/tree/master](https://github.com/yylidiw/thupc_1/tree/master) 查看。

## 样例 #1

### 输入

```
3 10
3 5 1 4 9 3 0 0 0 0 0 0
0 0 0 0 0 0 3 5 1 4 9 3
3 5 1 4 9 3 3 5 1 4 9 3
3 2
```

### 输出

```
Chaotic Evil
```

# 题解

## 作者：Time_tears (赞：17)

~~出题人分为 $10$ 种阵营：守序善良、守序中立、守序邪恶、中立善良、绝对中立、中立邪恶、混乱善良、混乱中立和混乱邪恶，九条可怜。真正的出题人，就要能够在阵营之间不断切换，最终成为九条可怜。~~

容易发现这个题目的描述看起来就很背包，而且由于这个 $\bmod p$ 意义下的加法，似乎就只能背包做了，那么考虑背包怎么做。

首先我们把这个等边三角形的边改一下，变成沿 $x$ 轴，沿 $y$ 轴，沿 $y=x$ 的三条线，容易发现这样做后走法是一一对应的，所以没有区别。

设 $f_{i,j,k,l,g}$ 表示 Dp 前 $i$ 个数，当前横坐标在 $j$，当前纵坐标在 $k$，当前 $L$ 是 $l$，当前 $G$ 是 $g$ 是否可行。 

这样 Dp 复杂度是 $O(n^3p^2)$ 的，即使用了 bitset 复杂度也为 $O(\dfrac{n^3p^2}{\omega})$，卡不过去。

考虑如何优化，但是这样的背包已经是最优了，也就是说背包是不可能再优化了，只能考虑从其它地方优化。

考虑非常经典的随机游走问题，它告诉我们在二维平面上每次随机选一个方向走 $1$ 的单位长度，走 $n$ 步期望的距离不会超过 $\sqrt n$ 级别，而这道题我们选择的方案也可以当成是随机在 $6$ 种当中选 $1$ 种出来。



所以我们只需将输入的 $a,b$ 随机化，并将 $j,k$ 这两维只开到 $\sqrt n$，这样复杂度就降为 $O(\dfrac{n^2p^2}{\omega})$ 了。(事实上要开到 $2\sqrt n$，$\sqrt n$ 会被卡掉)。

---

## 作者：Junounly (赞：11)

UPD: 重写了题解，补充了证明。

背景知识请先阅读 https://www.luogu.com.cn/article/xs2uucwg

---

> 初始有两个变量 $L=G=0$。有一个蜂窝状网格，从原点出发，一共要走 $n$ 步，每步可以从 $6$ 个方向中任选一个，并朝该方向走 $1$ 单位长度，假设第 $i$ 步选择了第 $j$ 个方向，$L$ 和 $G$ 分别会变成 $(L+a_{i,2j-1}) \bmod p$ 和 $(G+a_{i,2j}) \bmod p$，问走 $n$ 步后回到原点，且此时 $L=L^{\ast},G=G^{\ast}$ 的可行性。
>
> $1 \le n,p \le 100$。

发现蜂窝状网格性质不太好，而网格的形状不影响最终答案，所以进行变换，表示为直角三角形网格，如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/28tr35ly.png)

注意到 $p$ 很小，考虑设计一个暴力 $\text{DP}$，设 $f_{i,l,g,j,k} = 0/1$ 表示走到第 $i$ 步，坐标为 $(j,k)$，此时 $L=l , G=g$ 的可行性。

则转移式为：

$$f_{i,l,g,j,k} = \bigvee \limits_{p=1}^{6} f_{i-1,(l-a_{i,2p-1}+p)\bmod p,(g-a_{i,2p}+p)\bmod p,j+dx_p,k+dy_p}$$

其中 $dx=\{0,1,1,0,-1,-1\},dy=\{-1,0,1,1,0,-1\}$，分别表示对应方向 $\text{x}$ 坐标与 $\text{y}$ 坐标的增量。为避免越界，全部坐标都要加上一个偏移量。

考虑优化空间，第一维可以用滚动数组去掉。

注意到转移方式是整体可行性平移，然后合并，所以可以用 $\text{bitset}$ 优化。

此时的时间复杂度为 $\Theta(\frac{n^3 p^2}{\omega})$，空间复杂度为 $\Theta(\frac{n^2 p^2}{\omega})$。

注意到，我们最终的答案只与加和有关，与顺序无关，可以任意乱序。

于是就可以转化为一个随机游走模型，考虑将序列 $a$ 随机打乱，我们断言这样答案路径中距离原点最远的 $j,k$ 大概率不会很大。

接下来给出对于 $j,k$ 取值范围的分析。

考虑 $\text{x}$ 坐标 $j$，最劣情况下，会有 $n$ 步对 $\text{x}$ 坐标产生改动。

每一个坐标被改动的概率是相同的，考虑去掉改动为 $0$ 的位置，剩下有 $i$ 个位置，就是值为 $-1$ 或 $1$ 的二项分布。

事实上，事件 $\{$所有随机变量取值为 $-1$ 或 $1$，且和为 $j\}$ 等价于事件 $\{$所有随机变量取值为 $0$ 或 $1$，且和为 $\frac{i+j}{2}\}$。

这样我们就把问题转化为了若干次的 $\text{Bernoulli}$ 分布。记随机变量 $X$ 反映 $\frac{i+j}{2}$ 的取值，且 $X$ 的期望值为 $\mu=iP$，其中 $P$ 为单个随机变量取 $1$ 的概率，为 $\frac{1}{2}$。

$X$ 出现频率较高的范围是一段连续区间，不妨设这一段区间为 $\big[(1-B_1)\mu,(1+B_2)\mu\big]$，且 $B_1,B_2>0$，令算法成功概率为 $1-\varepsilon$。

代入 $\text{Multiplicative Chernoff Bound}$ 可以得到：

$$\textbf{Pr}\big(X \ge (1+B_2) \mu \big) \le e^{-\frac{B_2^2 \mu}{B_2+2}} \le \varepsilon$$

$$\textbf{Pr}\big(X \le (1-B_1) \mu \big) \le e^{-\frac{B_1^2 \mu}{2}} \le \varepsilon$$

不等式两边同时取对数的相反数：

$$\frac{B_2^2 \mu}{B_2+2} \ge \ln \varepsilon^{-1}$$

$$\frac{B_1^2 \mu}{2} \ge \ln \varepsilon^{-1}$$

解二次不等式组得：

$$B_2 \ge \frac{\ln \varepsilon^{-1} + \sqrt{\ln^2 \varepsilon^{-1}-8\mu \ln \varepsilon^{-1}}}{2\mu}$$

$$B_1 \ge \sqrt{\frac{2\ln \varepsilon^{-1}}{\mu}}$$

舍去常数，由于 $0 \le \mu \le i$，所以可以视为 $n,\mu$ 同阶，且 $\ln \varepsilon^{-1}$ 相对于 $n$ 是小量，所以：

$$B_1,B_2 \ge \sqrt{\frac{\ln \varepsilon^{-1}}{n}}$$

取等号时最优，得到满足条件的区间为 $X \in \big[\mu - \sqrt{n \ln \varepsilon^{-1}},\mu + \sqrt{n \ln \varepsilon^{-1}}\big]$，代入 $j=2X-i$，舍弃常数，得：

算法成功概率为 $1-\varepsilon$ 时，

$$-\sqrt{n \ln \varepsilon^{-1}} \le j \le \sqrt{n \ln \varepsilon^{-1}}$$

同时考虑 $\text{y}$ 坐标 $k$ ，即算法成功概率为 $(1-\varepsilon)^2$ 时，

$$-\sqrt{n \ln \varepsilon^{-1}} \le j,k \le \sqrt{n \ln \varepsilon^{-1}}$$

最终的时间复杂度为 $\Theta(\frac{n^2 p^2 \ln \varepsilon^{-1}}{\omega})$，空间复杂度为 $\Theta(\frac{n p^2 \ln \varepsilon^{-1}}{\omega})$。

这题轻微卡常，所以要加取模优化，实际可以取 $j,k$ 的范围为 $[-20,20]$，经测试，正确率非常高。

核心代码：

```c++
constexpr int N=105,M=42,B=20;
namespace Junounly
{
    int n,mod,L,G,a[N][15];
    random_device rd;
    mt19937 rnd(rd());
    bitset<M> f[2][N][N][M];
    #define T(x,y) ((x)>=y?(x)-(y):(x)-(y)+mod)
    void main()
    {
        scanf("%d%d",&n,&mod);
        for(int i=1;i<=n;i++)
            for(int j=1;j<=12;j++) scanf("%d",&a[i][j]);
        scanf("%d%d",&L,&G);
        shuffle(a+1,a+n+1,rnd);
        f[0][0][0][B][B]=1;
        for(int i=1;i<=n;i++)
            for(int l=0;l<mod;l++)
                for(int g=0;g<mod;g++)
                    for(int j=0;j<=B<<1;j++)
                    {
                        f[i&1][l][g][j].reset();
                        f[i&1][l][g][j]|=f[~i&1][T(l,a[i][1])][T(g,a[i][2])][j]<<1;
                        f[i&1][l][g][j]|=f[~i&1][T(l,a[i][3])][T(g,a[i][4])][j+1];
                        f[i&1][l][g][j]|=f[~i&1][T(l,a[i][5])][T(g,a[i][6])][j+1]>>1;
                        f[i&1][l][g][j]|=f[~i&1][T(l,a[i][7])][T(g,a[i][8])][j]>>1;
                        if(j) f[i&1][l][g][j]|=f[~i&1][T(l,a[i][9])][T(g,a[i][10])][j-1];
                        if(j) f[i&1][l][g][j]|=f[~i&1][T(l,a[i][11])][T(g,a[i][12])][j-1]<<1;
                    }
        printf(f[n&1][L][G][B][B]?"Chaotic Evil\n":"Not a true problem setter\n");
    }
}
```

---

## 作者：灵华 (赞：6)

[luoguP7606 [THUPC2021] 混乱邪恶](https://www.luogu.com.cn/problem/P7606)


首先我们把这个六个方向的位置改一下，改成普通平面上的 $x$ 轴（样例），$y$ 轴（题面）和 $y=x$（数据范围）这三条直线。

那么在每个方向的移动就可以表示为 `(0,+1),(-1,0),(-1,-1),(0,-1),(+1,0),(+1,+1)`，这六个按照输入顺序给入。

考虑朴素dp。我们设 $f[i][j][k][a][b]$ 为用完前 $i$ 个idea，此时在位置 $(j,k)$，且LG指数为 $(a,b)$ 的情况是否能达到。

那么直接枚举六个方向转移就可以了。时间复杂度：$O(n^3p^2)$。

如果用bitset去优化这个东西能达到 $O(\frac{n^3p^2}{\omega})$。过不去。就差一点。

我们看这个问题到底是啥。就是在一个平面上走来走去，求最后在原点位置能够存在一种情况。

这就是在平面上游走啊。

那和随机游走差在哪了呢？~~嗯……相信自己，大声说出你的答案！~~

就差在随机上了啊QwQ

所以在开始的时候给 $n$ 个idea随机一下就好啦！~~诶诶诶？？？？？~~

这样子期望移动的步数就是 $\sqrt n$ 了。

那么我们把之前的 $j,k$ 两维变成根号范围内的枚举就好了。

然后时间复杂度就变成了：$O(n^2p^2)$，然后再加个bitset卡卡，就是：
$O(\frac{n^2p^2}{\omega})$ 了。就能过了呀QwQ.


---

## 作者：Mirasycle (赞：4)

综合了各种技巧的背包题。

设计状态 $f_{i,l,g,x,y}$，表示考虑到第 $i$ 个 idea，能否达到 $L$ 指数为 $l$，$G$ 指数为 $g$，且目前在 $(x,y)$ 点。转移就是直接对于 $6$ 种方向进行分别决策就行了。时间复杂度 $O(p^2n^3)$。

首先，空间上第一维可以滚动数组优化掉。

然后，可以发现每次移动的 $\pm 1$，bool 型 dp 可以用 bitset 优化。复杂度 $O(\dfrac{p^2n^3}{\omega})$。

之前集训的时候还听过一个经典结论就是可以用随机打乱来优化背包。因为随机游走的期望最大移动距离是 $O(\sqrt V)$ 级别的，所有我们的背包大小也开这么大就行了。

感性理解一下，由于最后要回到原点，所以极限情况应该是一半选 $+1$，一半选 $-1$。像一些更大的情况也对我们没用可以直接舍去了，比如一直往某个方向走，那后面也回不来了是吧。把这些 $\pm 1$ 打乱之后，最后加起来的最大值必然不会很大。

于是最后的时间复杂度就是 $O(\dfrac{p^2n^2}{\omega})$。

---

## 作者：cmrhhh (赞：2)

[P7606 [THUPC2021] 混乱邪恶 ](https://www.luogu.com.cn/problem/P7606) 解题报告

首先，第一步小转化：

```  cpp
  \    /          		|  /
  \  /            		| /
----------    ->   ------------   
  /  \           	   /|
 /    \         	  / |
```

这样就方便描述坐标了。

然后肉眼可见可以 dp

定义状态 $f_{i,l,g,x,y}\space\space\space(i,l,g,x,y\in [1,100])$ 表示用到第 $i$ 个 idea，能否到达 $(x,y)$ 并且 $L=l,R=r$ 。时空复杂度不对劲。第一维滚动数组滚掉。整体可以用 bitset 卡常。

然后有一个结论性的东西：引入随机化后模拟随机游走，每次挑一个方向走，走 $n$ 次后距离远点的期望距离不超过 $\sqrt{n}$ ，但我不会有关证明，只能贺题解。这样貌似数组最后两维开到根号级别就行了。总时间复杂度 $O(\frac{p^4}{\omega})$ ，其他题解不是这样写的，但无所谓，$p,n$ 同阶。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
using ll=long long;
const int maxn=100;
int n,p,a[maxn+10][maxn/4];
bitset<maxn/2>f[2][maxn+2][maxn+2][maxn/2];
#define mod(x,y) ((x-y+p)%p)
int main(){
	ios::sync_with_stdio(0),cin.tie(0);
//	freopen("P7606_7.in","r",stdin);
//	freopen("ans.out","w",stdout);
	cin>>n>>p;
	for(int i=1;i<=n;++i)
		for(int j=1;j<=12;++j)cin>>a[i][j];
	int sq=(int)sqrt(n)+2;
	random_shuffle(a+1,a+1+n);
	f[0][0][0][sq][sq]=1;
	for(int i=1;i<=n;++i){
		for(int l=0;l<p;++l){
			for(int g=0;g<p;++g){
				for(int x=0;x<=sq<<1;++x){
						f[i&1][l][g][x].reset();
						f[i&1][l][g][x]|=f[(i&1)^1][mod(l,a[i][1])][mod(g,a[i][2])][x]<<1;
						f[i&1][l][g][x]|=f[(i&1)^1][mod(l,a[i][3])][mod(g,a[i][4])][x+1];
						f[i&1][l][g][x]|=f[(i&1)^1][mod(l,a[i][5])][mod(g,a[i][6])][x+1]>>1;
						f[i&1][l][g][x]|=f[(i&1)^1][mod(l,a[i][7])][mod(g,a[i][8])][x]>>1;
						f[i&1][l][g][x]|=f[(i&1)^1][mod(l,a[i][9])][mod(g,a[i][10])][x-1];
						f[i&1][l][g][x]|=f[(i&1)^1][mod(l,a[i][11])][mod(g,a[i][12])][x-1]<<1;
				}
			}
		}
	}int l_,g_;
	cin>>l_>>g_;
	cout<<(f[n&1][l_][g_][sq][sq]?"Chaotic Evil":"Not a true problem setter");
	return 0;
}
```





后话：总感觉这种随机化有点不太严谨，金钩的题解提到了 $\sqrt{n}$ 会被卡，可见这个结论要带个常数，并且“期望”步数不等于实际步数，感觉题解里的解法怪怪的，不过可以去看看官方严谨证明 [如何评价2021 THUPC（清华校赛）？ - 知乎 (zhihu.com)](https://www.zhihu.com/question/460984615/answer/1901576144)，这证明难度评黑不过分吧。

---

## 作者：strcmp (赞：1)

做一个坐标变换。具体的，将原空间映射到平面直角坐标系上，六个方向分别代表：

- $(x,\,y) \to (x + 1,\,y)$，$(x,\,y) \to (x,\,y + 1)$，$(x,\,y) \to (x + 1,\,y + 1)$。反向同理。

具体构造你可以想象钦定网格中的一个平行四边形，将它“旋转”为一个矩形。

显然的设 $f_{i,\,l,\,g,\,x,\,y}$ 为用完了前 $i$ 个 idea，在 $(x,\,y)$，当前的 $L = l,\,G = g$ **这种情况是否可能存在**。

枚举六个方向转移即可。

注意到这是一个只有 0/1 状态的背包，显然可以 bitset 优化掉最后一维，同时空间上滚动数组。空间复杂度 $\Theta(\frac{n^2p^2}{w})$，可以接受。

时间复杂度 $\Theta(\frac{n^3p^2}{w})$，注意到运算量大概有三亿级别，而时限只有 $700\text{ms}$，显然很难通过。

idea 加入的顺序并不影响我们的答案，因此可以考虑将 idea 打乱，在二维平面上随机走 $n$ 步期望与源点距离是 $\sqrt n$ 级别的，于是在背包里后面两维只枚举到 $2 \sqrt n$ 就行了。（当然注意到你的 bitset 能轻松的用 `long long` 存下，因此可以直接用 `long long`，但是实际上效率几乎一样，这里假设压成一个二进制数）

时间复杂度 $\Theta(p^2n \sqrt n)$，可以通过。

```cpp
#include <bits/stdc++.h>
#define X first
#define Y second
using namespace std;
typedef long long int ll;
using pll = pair<ll, ll>;
using uint = unsigned int;
const int maxn = 1e6 + 10;
constexpr ll mod = 998244353;
const ll inf = 114514191981052013LL;
mt19937 rd(mod); 
ll a[maxn][13], L, G; int n, p;
bitset<40> f[2][105][105][40];
inline int r(int x, int y) { return x >= y ? x - y : x - y + p; }
int main() {
	scanf("%d%d", &n, &p);
    int s = ceil(sqrt(n)) + 5;
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= 12; j++) scanf("%lld", &a[i][j]);
	}
	scanf("%lld%lld", &L, &G);
	shuffle(a + 1, a + n + 1, rd); int c = 0;
	f[0][0][0][s][s] = 1;
	for (int i = 1; i <= n; i++) {
		for (int l = 0; l < p; l++) {
			for (int g = 0; g < p; g++) {
				for (int x = 0; x <= (s << 1); x++) {
					bitset<40>& d = f[c ^ 1][l][g][x]; d.reset();
					d |= f[c][r(l, a[i][1])][r(g, a[i][2])][x] << 1;
					d |= f[c][r(l, a[i][3])][r(g, a[i][4])][x + 1];
					d |= f[c][r(l, a[i][5])][r(g, a[i][6])][x + 1] >> 1;
					d |= f[c][r(l, a[i][7])][r(g, a[i][8])][x] >> 1;
					if (x >= 1) d |= f[c][r(l, a[i][9])][r(g, a[i][10])][x - 1];
					if (x >= 1) d |= f[c][r(l, a[i][11])][r(g, a[i][12])][x - 1] << 1;
				}
			}
		}
		c ^= 1;
	}
	puts(f[c][L][G][s][s] ? "Chaotic Evil" : "Not a true problem setter");
	return 0;
}
```

---

## 作者：homo_snow (赞：1)

# 背包+各种优化

如题，设 $f_{k,i,j,l,g}$ 为在前 $k$ 个 $idea$，坐标 $(i,j)$ 时，能否满足 $l,g$ 两个指数。

## 首先解决坐标问题

如题，这是一个六向图：
    
```
    |  / 
    
    |/   
---------
   /|
  
 /  |
```

可以发现，它的方向无非就是向上向下向左向右，向左下与右上。

然后就能转换成二维图了。

然后设 $a_{i,j}$ 为在第 $i$ 个  $idea$ 选择的 $j$ 个方向的参数，便可以省去方向数组。

## 然后是 DP

很明显，如果不考虑各种杂七杂八的优化的话:
1. 第一层循环枚举 $k$，$O(n)$ 时间复杂度。
2. 第二层循环与第三层循环枚举坐标。
3. 第三层循环枚举指数 $l$，由于 $p\le100$，所以约等于 $O(n)$。
4. 第四层循环枚举指数 $g$，与 $l$ 同理，$O(n)$ 复杂度。

综合下来，你会得到一个 $O(N^5)$ 空间复杂度的 DP，别说收获满屏幕的 $MLE$，编译都过不了。


## 考虑优化

首先，我们发现 $f_{k,i,j,l,g}$ 中的 $k$ 维度的转移固定从 $k-1$ 而来，所以我们可以将其压为滚动数组 $f_{0/1,i,j,l,g}$，这样就可以通过异或和按位与 & 求奇偶取得状态。

其次，我们可以发现 $f_{0/1,i,j,l,g}$ 存的不是 $0$ 就是 $1$，考虑用 bitset 优化常数，以右移代替 $+1$，左移代替 $-1$，按位或代替普通或。

但事实上，我们的算法的时间复杂度还是 $O(N^5)$，需要再压一维才能卡过。

这里介绍个玄学方法：

### 随机化！！！

我们可以发现，这道题无非就是一个点在图上走来走去，也就是随机游走，由于随机游走的平均期望为 $\sqrt n$ 所以可以直接将坐标压为步数，将 $n^2$ 压成 $2\sqrt n$。

可以用 `random_shuffle` 函数将 $a$ 随机化，这样更能模拟随机游走的情况。

得出最后的状态设置 $f_{i(0/1),l,g,j}$ 为在第 $i$ 个 $idea$ 走了 $j$ 步时，能否满足指数为 $l,g$。

$Code$:
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N = 1e2+10;
int n , mod , a[N][N/2],be,en;
bitset<N/2> f[2][N][N][N/2];

signed main(){
    scanf("%lld%lld",&n,&mod);
    int s = sqrt(n)+2;
    for(int i = 1;i <= n; i++)
        for(int j = 1; j <= 12;j++)
            scanf("%lld",&a[i][j]);
    scanf("%lld%lld",&be,&en);  
    random_shuffle(a+1,a+n+1);

    f[0][0][0][s][s]=1;
	
    for(int i = 1; i <= n; i++)
        for(int l = 0;l < mod; l++)
            for(int g = 0; g < mod; g++)
                for(int j = 0 ;j <= s * 2; j++){
                    f[i&1][l][g][j].reset();
                    f[i&1][l][g][j] |= f[(i&1)^1][(l-a[i][1]+mod)%mod][(g-a[i][2]+mod)%mod][j]<<1;
                    f[i&1][l][g][j] |= f[(i&1)^1][(l-a[i][3]+mod)%mod][(g-a[i][4]+mod)%mod][j+1];
                    f[i&1][l][g][j] |= f[(i&1)^1][(l-a[i][5]+mod)%mod][(g-a[i][6]+mod)%mod][j+1]>>1;
                    f[i&1][l][g][j] |= f[(i&1)^1][(l-a[i][7]+mod)%mod][(g-a[i][8]+mod)%mod][j]>>1;
                    f[i&1][l][g][j] |= f[(i&1)^1][(l-a[i][9]+mod)%mod][(g-a[i][10]+mod)%mod][j-1];
                    f[i&1][l][g][j] |= f[(i&1)^1][(l-a[i][11]+mod)%mod][(g-a[i][12]+mod)%mod][j-1]<<1;
				}
    puts(f[n & 1][be][en][s][s]?"Chaotic Evil":"Not a true problem setter");
    return 0;
}
```






---

## 作者：12345678hzx (赞：1)

## 题目描述
[题目传送门](https://www.luogu.com.cn/problem/P7606)
## 思路
题目中的坐标系不好处理，我们考虑将它变成平面直角坐标系，这样坐标就都是整数了，借用下同学 yyjjhh2010 的图。

![](https://cdn.luogu.com.cn/upload/image_hosting/6z08rpfm.png)

先考虑暴力 DP，设 $f_{i,j,k,x,y}=0/1$ 表示现在处理到第 $i$ 个 idea，能否表达出值 $j,k$，且坐标在 $(x,y)$。

这时候的转移就是从六个方向都可以走到点 $(x,y)$，也就是六个点的值取或，但这么转移明显会炸，考虑优化。

由于转移第 $i$ 层时只用到了第 $i-1$ 层，所以考虑滚动数组优化，接下来由于 $f$ 数组是一个 bool 类型的数组，且每次转移都用到了位运算，所以可以用一个叫 $\operatorname{bitset}$ 的东西存下来，经过这两次优化后，该算法时间复杂度为 $O(\dfrac{n^3p^2}{w})$，空间复杂度为 $O(\dfrac{n^2p^2}{w})$。

现在空间不会炸，但时间会炸。

接下来介绍下本题的重点算法随机化，由于是在一个网格上移动，且每次移动长度为 $1$，所以这是个随机游走问题，这类问题的结论就是期望移动 $\sqrt n$ 次就能找到答案，至此，该算法时间复杂度为 $O(\dfrac{n^2p^2}{w})$，空间复杂度为 $O(\dfrac{np^2}{w})$，但由于要从六个方向转移，并且常数巨大，所以可能要稍微卡常才过得了。

至于代码，很好写了，就不放了。

本题解部分参考于[此篇题解](https://www.luogu.com.cn/blog/yyjjhh2010/solution-p7606)。

在最后，给个随机游走问题得到解的期望次数为 $\sqrt n$ 的[证明](https://www.cnblogs.com/Miraclys/p/17077825.html)。

---

## 作者：jr_zch (赞：1)

# [P7606 [THUPC2021] 混乱邪恶](https://www.luogu.com.cn/problem/P7606)
## by [jr_zch](https://www.luogu.com.cn/blog/jr-zch-code-garden/hun-luan-ya-wu) 博客食用更佳~
## 题目大意

给你一个蜂窝网络，你一开始在坐标 $(0,0)$，你一共有两种属性：$L$、$R$，起初都是 $0$，这两种属性都是在 $\pmod p$ 意义下存在的。现在你有 $n$ 张卡片，第 $i$ 张卡片使用后，可以选择向六个方向之一前进一步，如果向方向 $j$ 前进，会使得 $L+l_{i,j}$，$R+r_{i,j}$。

问：你是否有一种方案使得自己最后回到 $(0,0)$，且 $L= *L$，$R=*R$。

* $1 \leq n,p \leq 100$

## 思路 & 解法

看见诸如**使用**，**增加属性**一类的词语，很容易想到背包问题，在不考虑坐标问题的情况下，这题可以转化为最基础的背包模型：

> $f_{i,l,r}$ 表示当前用到第 $i$ 个物品，$L$ 和 $R$ 属性**能否**分别为 $l,r$。

有了坐标限制之后也很简单，容易发现所谓蜂窝状的图可以转化为普通的网格图，只是在副对角线上多了一条边。若当前在 $(x,y)$，下一步可以走到      $(x+1,y)$、$(x-1,y)$、$(x,y+1)$、$(x,y-1)$、$(x+1,y+1)$、$(x-1,y-1)$。所以可以在原状态的基础上加两维表示当前的坐标。

这样一来，**时间**复杂度和**空间**复杂度都骤然升至了 $O(n^5)$，空间好说，滚动一维即可（最后其实可以不用），考虑优化时间。

回到最开始的题面，发现这是一个很经典的模型：**随机游走**。

> 一只蜘蛛原本在蛛网中央，现在它开始在网上乱走，步长为 $1$ 个单位长度，但是最后又回到了原点，假设它一共走了 $step$ 步，求它期望走到的相对于原点的最远距离为多少？
>
> 答案为 $\sqrt n$ 步。 

或者换一个说法：

> 给你一个长度为 $n$ 的数列 $a$，要求从其中随机选取元素，每个元素只能选一次，一直选完整个数列，并且最后的和为 $0$，如果对于任意 $1\leq i \leq n$ 都有 $-c \leq a_i \leq c$，求在整个选取过程中，已选元素之和的期望最大值和最小值分别为多少？
>
> 答案是 $-c \cdot \sqrt n \leq sum \leq c \cdot \sqrt n$。

关于证明，推荐大家看出题人 [ E_Space 的证明](https://www.zhihu.com/question/460984615/answer/1901576144)。

结合上述模型，我们先把输入随机排序，在将后面表示坐标的两维都改为 $\sqrt n$ 级别的，因为会有负坐标，所以整体要加上一个 $\sqrt n$ 的偏移量，时空复杂度均为 $O(n^4)$，常数约为 $12$。

> $f_{i,l,r,x,y}=0/1$ 表示当前用到第 $i$ 个物品，$L$ 和 $R$ 属性**能否**分别为 $l,r$，并且当前坐标为 $(x,y)$，$-10 \leq x,y \leq 10$。

如果时限为 $1s$，现在的时间复杂度足矣通过，可是该题时限为 $700ms$，而且**常数相当大**，还得优化。发现状态表示的是 $0/1$，可以加上        `bitset`，这样一来就可以通过该题了。

时间复杂度 $O(\frac {n^4} w)$。

## Code：

### 无滚动数组：$10.99s/246.03MB$

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

const int maxn=1e2+7,maxm=30; //2*sqrt(n)
int n,m,p,q,lmt;
int a[maxn][maxm];
bitset<maxm> f[maxn][maxn][maxn][maxm]; //bitset优化

signed main(){
	srand(time(0));
	scanf("%lld%lld",&n,&m),lmt=sqrt(n)+3;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=12;j++) scanf("%lld",&a[i][j]);
	}
	random_shuffle(a+1,a+1+n); //随机排序
	scanf("%lld%lld",&p,&q),f[0][0][0][lmt][lmt]=1;
	for(int i=1;i<=n;i++){
		for(int l=0;l<m;l++){
			for(int r=0;r<m;r++){
				for(int x=0;x<=lmt<<1;x++){
					//分别转移六个方向
					f[i][l][r][x]|=f[i-1][(l-a[i][1]+m)%m][(r-a[i][2]+m)%m][x]<<1; //左移一位相当于y-1
					f[i][l][r][x]|=f[i-1][(l-a[i][3]+m)%m][(r-a[i][4]+m)%m][x+1]; //y不变
					f[i][l][r][x]|=f[i-1][(l-a[i][5]+m)%m][(r-a[i][6]+m)%m][x+1]>>1; //右移一位相当于y+1
					f[i][l][r][x]|=f[i-1][(l-a[i][7]+m)%m][(r-a[i][8]+m)%m][x]>>1;
					f[i][l][r][x]|=f[i-1][(l-a[i][9]+m)%m][(r-a[i][10]+m)%m][x-1];
					f[i][l][r][x]|=f[i-1][(l-a[i][11]+m)%m][(r-a[i][12]+m)%m][x-1]<<1;
				}
			}
		}
	}
	if(f[n][p][q][lmt][lmt]) printf("Chaotic Evil");
	else printf("Not a true problem setter");
	return 0;
}
```

### 滚动数组：$5.05s/6.44MB$

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

const int maxn=1e2+7,maxm=30;
int n,m,p,q,lmt;
int a[maxn][maxm];
bitset<maxm> f[2][maxn][maxn][maxm];

signed main(){
	srand(time(0));
	scanf("%lld%lld",&n,&m),lmt=sqrt(n)+3;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=12;j++) scanf("%lld",&a[i][j]);
	}
	random_shuffle(a+1,a+1+n);
	scanf("%lld%lld",&p,&q),f[0][0][0][lmt][lmt]=1;
	for(int i=1;i<=n;i++){
		for(int l=0;l<m;l++){
			for(int r=0;r<m;r++){
				for(int x=0;x<=lmt<<1;x++){
					f[i&1][l][r][x].reset();
					f[i&1][l][r][x]|=f[i-1&1][(l-a[i][1]+m)%m][(r-a[i][2]+m)%m][x]<<1;
					f[i&1][l][r][x]|=f[i-1&1][(l-a[i][3]+m)%m][(r-a[i][4]+m)%m][x+1];
					f[i&1][l][r][x]|=f[i-1&1][(l-a[i][5]+m)%m][(r-a[i][6]+m)%m][x+1]>>1;
					f[i&1][l][r][x]|=f[i-1&1][(l-a[i][7]+m)%m][(r-a[i][8]+m)%m][x]>>1;
					f[i&1][l][r][x]|=f[i-1&1][(l-a[i][9]+m)%m][(r-a[i][10]+m)%m][x-1];
					f[i&1][l][r][x]|=f[i-1&1][(l-a[i][11]+m)%m][(r-a[i][12]+m)%m][x-1]<<1;
				}
			}
		}
	}
	if(f[n&1][p][q][lmt][lmt]) printf("Chaotic Evil");
	else printf("Not a true problem setter");
	return 0;
}
```

---

## 作者：Nygglatho (赞：0)

首先将境界中的平行四边形拍成一个正方形，那么可以将这个看作为坐标轴。具体地，一开始在 $(0,0)$。

- 对于 「简洁的题面」，则视为纵坐标 $+1$，横坐标不变。
- 对于 「平凡无用的样例」，则视为纵坐标不变，横坐标 $-1$。
- 对于 「宽松的数据范围」，则视为纵坐标 $-1$，横坐标 $-1$。
- 对于 「复杂的题面」，则视为纵坐标 $-1$，横坐标不变。
- 对于 「无私馈赠的样例」，则视为纵坐标不变，横坐标 $+1$。
- 对于 「松松松的数据范围」，则视为纵坐标 $+1$，横坐标 $+1$。

如图。

![](https://cdn.luogu.com.cn/upload/image_hosting/7xm5mi0b.png)

可以发现由于需要从 $(0,0)$ 开始并回到 $(0,0)$，所以不影响答案。

考虑使用 DP 来进行这个操作。具体地，设 $f(t,i,j,x,y)$ 表示走 $t$ 步，$L,G$ 分别等于 $i,j$，最后到 $(x,y)$ 是否可行，则：
$$
\begin{aligned}
&f(t,i,j,x,y)=\\
&f(t-1,(i-\mathit{tl}_{i,l})\bmod p,(j-\mathit{tl}_{i,g})\bmod p,x,y-1)\\
\lor &f(t-1,(i-\mathit{l}_{i,l})\bmod p,(j-\mathit{l}_{i,g})\bmod p,x+1,y)\\
\lor &f(t-1,(i-\mathit{bl}_{i,l})\bmod p,(j-\mathit{bl}_{i,g})\bmod p,x+1,y+1)
\\ \lor &f(t-1,(i-\mathit{br}_{i,l})\bmod p,(j-\mathit{br}_{i,g})\bmod p,x,y+1)\\
\lor &f(t-1,(i-\mathit{r}_{i,l})\bmod p,(j-\mathit{r}_{i,g})\bmod p,x-1,y)\\
\lor &f(t-1,(i-\mathit{tr}_{i,l})\bmod p,(j-\mathit{tr}_{i,g})\bmod p,x-1,y-1)
\end{aligned}
$$
这 $6$ 个表达式分别代表了「简洁的题面」，「平凡无用的样例」，「宽松的数据范围」，「复杂的题面」，「无私馈赠的样例」以及「松松松的数据范围」。

最后只需要判断 $f(n,L^*,G^*,0,0)$ 是否可行即可。

发现 $4,5$ 维可能有负数，这是简单的，只需要加上一个偏移量即可。问题是这样做是 $O(n^3p^2)$ 的，过不去。

注意到随机游走，期望是在 $(-\sqrt n,-\sqrt n)$ 到 $(\sqrt n,\sqrt n)$ 的，为了避免构造数据导致不在期望范围之内，考虑将 $\sqrt n$ 扩大至 $1.5\sqrt n$，并将原来的信息随机排列，这样大概率就在范围内了。

但是由于时间限制，并且常数较大，还是过不了，由于 $f$ 是一个二进制位，同时最后一维可以同时更新，因此考虑 bitset 优化，这样就可以过了。

---

## 作者：MoonCake2011 (赞：0)

首先把六边形的变为一个平面直角坐标系。

那些东西变为 6 个方向，上，下，左，右，右上，左下。

然后跑滚动数组的背包，不用多讲。

接着用 bitset 优化。

将转移优化成 bitset 的一些操作。

```cpp
dp[0][0][0][n][n]=1;
for(int i=1;i<=n;i++)
	for(int j=0;j<p;j++)
		for(int k=0;k<p;k++)
			for(int stx=0;stx<=2*n;stx++){
				dp[i&1][j][k][stx]=0;//初始化
				dp[i&1][j][k][stx]|=dp[(i&1)^1][Mod(j-a[i][1])][Mod(k-a[i][2])][stx]<<1;//上走
				dp[i&1][j][k][stx]|=dp[(i&1)^1][Mod(j-a[i][3])][Mod(k-a[i][4])][stx+1];//左走
				dp[i&1][j][k][stx]|=dp[(i&1)^1][Mod(j-a[i][5])][Mod(k-a[i][6])][stx+1]>>1;//左下
				dp[i&1][j][k][stx]|=dp[(i&1)^1][Mod(j-a[i][7])][Mod(k-a[i][8])][stx]>>1;//下
				dp[i&1][j][k][stx]|=dp[(i&1)^1][Mod(j-a[i][9])][Mod(k-a[i][10])][stx-1];//右
				dp[i&1][j][k][stx]|=dp[(i&1)^1][Mod(j-a[i][11])][Mod(k-a[i][12])][stx-1]<<1;//右上
			}
```
答案为 $dp_{n,L^*,G^*,n,n}$。

这一步是 $O(\dfrac{n^3p^2}{8})$ 的。

除以 $8$ 是因为用了 `bitset`。

接着，用一个很玄学的优化。

在期望下，这种随机游走的最远坐标为 $\sqrt{n}$。

于是，随机打乱序列，然后将游走坐标最大值设为 $\sqrt{n}+2$，就 A 了。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,p,v,w;
int a[110][13];
bitset<60>dp[2][110][110][60];
inline int Mod(int x){
	if(x<0) x+=p;
	return x;
}
int main() {
	srand(time(0));
	cin>>n>>p;
	int M=sqrt(n)+2; 
	for(int i=1;i<=n;i++) for(int j=1;j<=12;j++) cin>>a[i][j];
	cin>>v>>w;
	for(int i=1;i<=n;i++){//knuth 算法（洗牌算法）  
		int t=rand()%n+1;
		for(int j=1;j<=12;j++) swap(a[i][j],a[t][j]);
	}
	random_shuffle(a+1,a+n+1);
	dp[0][0][0][M][M]=1;
	for(int i=1;i<=n;i++)
		for(int j=0;j<p;j++)
			for(int k=0;k<p;k++)
				for(int stx=0;stx<=2*M;stx++){
					dp[i&1][j][k][stx]=0;
					dp[i&1][j][k][stx]|=dp[(i&1)^1][Mod(j-a[i][1])][Mod(k-a[i][2])][stx]<<1;
					dp[i&1][j][k][stx]|=dp[(i&1)^1][Mod(j-a[i][3])][Mod(k-a[i][4])][stx+1];
					dp[i&1][j][k][stx]|=dp[(i&1)^1][Mod(j-a[i][5])][Mod(k-a[i][6])][stx+1]>>1;
					dp[i&1][j][k][stx]|=dp[(i&1)^1][Mod(j-a[i][7])][Mod(k-a[i][8])][stx]>>1;
					dp[i&1][j][k][stx]|=dp[(i&1)^1][Mod(j-a[i][9])][Mod(k-a[i][10])][stx-1];
					dp[i&1][j][k][stx]|=dp[(i&1)^1][Mod(j-a[i][11])][Mod(k-a[i][12])][stx-1]<<1;
				}
	if(dp[n&1][v][w][M][M]) cout<<"Chaotic Evil";
	else cout<<"Not a true problem setter";		
	return 0;
}
```
时间复杂度 $O(\dfrac{n^2p^2}{8})$，能过。

---


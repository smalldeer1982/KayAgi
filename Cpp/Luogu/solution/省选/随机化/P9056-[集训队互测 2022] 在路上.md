# [集训队互测 2022] 在路上

## 题目背景

滥用本题评测者封号。

dottle bot。

## 题目描述

**这是一道交互题，仅支持 C++ 提交**。

有一棵未知的树，**保证树的大小为奇数，你需要找到这棵树重心的编号**。

你可以进行询问，每次询问你可以询问三个点 $(x,y,z)$，若不存在一条简单路径同时经过三个点，则交互器会返回 $0$，否则若存在，那么交互器会返回三个点在路径上相对顺序中间的一个点。

令 $dis(a,b)$ 表示 $a,b$ 两点在树上最短路径经过的边数，你也可以理解为:

若 $dis(x,y)+dis(x,z)=dis(y,z)$，则交互器会返回 $x$。

否则若 $dis(y,x)+dis(y,z)=dis(x,z)$，交互器会返回 $y$。

否则若 $dis(z,x)+dis(z,y)=dis(x,y)$，交互器会返回 $z$。

否则交互器会返回 $0$。

在最终的测试中，每个测试点会包含 $T$ 组测试数据，和一个常数 $M$，表示你在所有测试数据中询问次数总和的上限，具体细则见 输入格式 以及 数据范围。

#### 实现细节

~~你需要引用 `path.h` 头文件。~~ 本题中你只需要把 `path.h` 头文件的内容粘贴到程序开头即可，不要引用 `path.h` 头文件。

你需要实现下面的函数：

```
int centroid(int id,int N,int M);
```

其中 $id$ 为当前子任务的编号，$N$ 为当前询问树的大小，$M$ 为当前测试点剩余的询问次数，函数的返回值为当前树的重心编号。

具体的，在第一次调用时 $M$ 为当前测试点的询问次数上限，每次调用结束之后 $M$ 会减去当前测试点使用的询问次数。

你可以调用下面的函数：

```
int ask(int x,int y,int z);
```

表示你进行了一次询问，交互器会返回当前询问的答案，特别的，若询问次数已经超过了上限，交互器会返回 $-1$。

注意同一个测试点中 `centroid` 函数可能会被多次调用，请注意数组清空等情况。

**下发文件中有样例交互库，该交互库的实现与评测时的交互库几乎一致，如果对交互方式有不理解可以参照交互库的代码理解**。


## 说明/提示

#### 数据范围

![](https://cdn.luogu.com.cn/upload/image_hosting/f3d6b2zv.png?x-oss-process=image/resize,m_lfit,h_1700,w_2250)

特殊性质 $A$：保证树的形态为一条链，即每个点的度数均不超过 $2$。

保证每个 Subtask 里的测试数据数量均不超过 $20$。**请仔细阅读每一档子任务及其限制**。

#### 时空限制

Subtask 5 时限为 3s。

Subtask 7,8 时限为 4s。

其余 Subtask 时限为 1s。

空间限制：512MB。

保证最终交互库的时间使用不超过  2s，空间使用不超过 64MB。

#### 下发文件

下发文件中有一个样例交互库，提供的交互头文件，一份示例代码，以及一个满足子任务 $4$ 性质的样例，选手也可以按照题目的输入格式构造其他样例。

另外也有一份洛谷样式的交互库。

保证下发的交互库和最终使用的交互库除反作弊之外没有区别，你可以使用这个交互库输出调试信息。

# 题解

## 作者：DaiRuiChen007 (赞：2)

[Problem Link](https://www.luogu.com.cn/problem/P9056)

**题目大意**

> 给定一棵 $n$ 个点的树，你可以进行 $5\times 10^5$ 次询问：每次询问给定三个点 $x,y,z$，如果三个点不在一条链上，返回 $0$，否则返回链中间的节点。请求出树的重心。
>
> 数据范围：$n\le 3\times 10^4$。

**思路分析**

先考虑链的情况，首先求出区间的两个端点是很容易的，维护 $l,r$，每次加入 $i$ 后把 $l,r$ 变成 $i,l,r$ 中不等于 $f(i,l,r)$ 的两个点即可。

然后可以考虑随机二分，每次随机找一个点 $u$，然后 $\mathcal O(n)$ 判断每个点在 $[l,u]$ 还是 $[u,r]$ 上，只需求判断 $f(l,i,u)=u$ 是否成立，然后递归较大的一边即可。

事实上，随机二分的过程中，每次期望删掉 $\dfrac 14$ 的点，那么询问的总点数期望为 $\mathcal O(n)$ 级别。

然后考虑原问题。

尝试把原问题转成链的情况，我们可以随机两个点 $l,r$，然后在 $l\to r$ 的链上找重心，由于重心的每个子树大小 $\le\dfrac n2$，因此重心在 $l\to r$ 的概率不小于 $\dfrac 12$，期望随机次数为 $\mathcal O(1)$ 级别。

如果重心在这条链上，那么链上该点左侧、右侧的点的子树大小和均 $\le \dfrac n2$，相当于在链上求带权中位数，那么就可以把树上问题转成链上问题。

依然考虑在 $l\to r$ 的链上随机一个点，但此时重心不在链的中点处，因此删掉点的数量没有保证。

如果进行带权二分，即在 $n$ 个点中随机一个，求出该点在链上哪个点的子树内，此时每次删掉的点期望就有保证了。

设随机出的点是 $v$，对应链上节点为 $u$，那么 $f(u,i,v)=i$ 时令 $u\gets i$，不断进行此操作即可。

然后求出 $u$ 在链上的左右部分 $L,R$，然后求 $L,R,u$ 的子树，这些都是容易求出的，递归时判断 $|L|,|R|\le\dfrac n2$ 是否成立即可，如果不成立则递归链为 $L/R$。

这样做，询问总点数的期望为依然为 $\mathcal O(n)$ 级别。

最后我们要判断求出的点是否是重心。

考虑把 $u$ 删去后形成的若干子树，如果 $u$ 不是重心，说明这些子树的大小中存在绝对众数，可以考虑摩尔投票法，我们只要快速判断两个点是否属于 $u$ 的同一个子树，这是简单的。

为了优化常数，我们可以在递归时特殊维护两个端点的子树。

询问次数：不知道，反正能过。

时间复杂度 $\mathcal O(n)$。

**代码呈现**

```cpp
#include<bits/stdc++.h>
using namespace std;
extern "C" int ask(int x,int y,int z);
mt19937 rnd;
typedef vector<int> vi;
int n;
int chk(int rt,vi V) {
	int cnt=0,col=0;
	for(int i:V) {
		if(!cnt) ++cnt,col=i;
		else {
			if(ask(rt,i,col)==rt) --cnt;
			else ++cnt;
		}
	}
	if(!cnt) return rt;
	int tot=0;
	for(int i:V) if(ask(rt,col,i)!=rt) ++tot;
	return (tot<=n/2)?rt:-1;
}
int solve(int l,int r,vi L,vi R,vi C,vi S) {
	if((int)L.size()>n/2) return chk(l,L);
	if((int)R.size()>n/2) return chk(r,R);
	if(l==r) return chk(l,S);
	if(C.size()==2) {
		vi tmp=C; tmp.push_back(r);
		for(int i:R) tmp.push_back(i);
		int z=chk(l,tmp);
		if(~z) return z;
		tmp=C,tmp.push_back(l);
		for(int i:L) tmp.push_back(i);
		return chk(r,tmp);
	}
	int k=l;
	while(k==l||k==r) {
		int rd=rnd()%(C.size()+S.size());
		if(rd<(int)C.size()) k=C[rd];
		else {
			int t=S[rd-C.size()];
			for(int i:C) if(ask(k,t,i)==i) k=i;
		}
	}
	vector <int> CL,CR,SK,SL,SR;
	for(int i:C) if(i!=k) {
		if(ask(l,i,k)==i) CL.push_back(i);
		else CR.push_back(i);
	}
	for(int i:S) {
		if(ask(l,k,i)==k) {
			if(ask(r,k,i)==k) SK.push_back(i);
			else SR.push_back(i);
		} else SL.push_back(i);
	}
	int sl=L.size()+CL.size()+SL.size(),sr=R.size()+CR.size()+SR.size();
	if(sl<=n/2&&sr<=n/2) return chk(k,SK);
	if(sr>n/2) swap(L,R),swap(CL,CR),swap(SL,SR),swap(l,r);
	r=l;
	R.push_back(k);
	for(int i:SK) R.push_back(i);
	for(int i:CR) R.push_back(i);
	for(int i:SR) R.push_back(i);
	for(int i:CL) if(i!=l&&ask(i,r,l)==r) r=i;
	S.clear();
	for(int i:SL) {
		if(ask(l,r,i)==r) R.push_back(i);
		else S.push_back(i);
	}
	return solve(l,r,L,R,CL,S);
}
extern "C" int centroid(int id,int N,int M) {
	n=N;
	if(id==1) return ask(1,2,3);
	if(id==3||id==5) {
		int l=1,r=2;
		for(int i=3;i<=N;++i) {
			int u=ask(l,r,i);
			if(l==u) l=i;
			if(r==u) r=i;
		}
		vi arr(N);
		iota(arr.begin(),arr.end(),1);
		nth_element(arr.begin(),arr.begin()+N/2,arr.end(),[&](int x,int y) {
			return ask(x,y,r)==y;
		});
		return arr[N/2];
	}
	while(true) {
		int l=rnd()%n+1,r=rnd()%n+1;
		if(l==r) continue;
		vi L,R,C{l,r},S;
		for(int i=1;i<=n;++i) if(i!=l&&i!=r) {
			int z=ask(i,l,r);
			if(z==l) L.push_back(i);
			if(z==r) R.push_back(i);
			if(z==i) C.push_back(i);
			if(z==0) S.push_back(i);
		}
		int k=solve(l,r,L,R,C,S);
		if(~k) return k;
	}
	return 0;
}
```

---


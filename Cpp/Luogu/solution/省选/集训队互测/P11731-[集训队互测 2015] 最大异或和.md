# [集训队互测 2015] 最大异或和

## 题目描述

我有一个数列 $a_1, a_2, \dots, a_n$，每个 $a_i$ 都是小于 $2^m$ 的非负整数。

现在请您实现三种操作，格式说明如下：

* $1$ $x$ $y$ $w$：对于所有 $x \leq i \leq y$，将 $a_i$ 修改为 $a_i \operatorname{xor} w$。其中 $w$ 是一个小于 $2^m$ 的非负整数。
* $2$ $x$ $y$ $w$：对于所有 $x \leq i \leq y$，将 $a_i$ 修改为 $w$。其中 $w$ 是一个小于 $2^m$ 的非负整数。
* $3$：从 $a_1, a_2, \dots, a_n$ 中选出若干个数，使得选出的数异或和最大。请输出这个最大值。

这里 $\operatorname{xor}$ 表示按位异或运算，$x_1, x_2, \dots, x_l$ 的异或和是指 $x_1 \operatorname{xor} x_2 \operatorname{xor} \dots \operatorname{xor} x_l$。

## 说明/提示

| 测试点编号 | $n$    | $m$    | $q$    | 特殊限制               |
|:------------:|:--------:|:--------:|:--------:|:------------------------:|
| $1$          | $= 10$   | $= 10$   | $= 1000$  | 无                    |
| $2$          | $= 500$  | $= 500$  | $= 10$    | 无                    |
| $3$          | $= 120$  | $= 120$  | $= 120$   | 无                    |
| $4$          | $= 2000$ | $= 2000$ | $= 10$    | 无                    |
| $5$          | $= 1800$ | $= 1800$ | $= 1800$  | $1, 2$ 操作中 $x = y$ |
| $6$          | $= 1800$ | $= 1800$ | $= 1800$  | 只有 $1, 3$ 操作      |
| $7$          | $= 1800$ | $= 1800$ | $= 1800$  | 只有 $2, 3$ 操作      |
| $8$          | $= 1500$ | $= 1500$ | $= 1500$  | 无                    |
| $9$          | $= 1800$ | $= 1800$ | $= 1800$  | 无                    |
| $10$         | $= 2000$ | $= 2000$ | $= 2000$  | 无                    |


## 样例 #1

### 输入

```
3 4 7
0000
0011
0110
3
1 2 3 0010
3
2 1 2 0010
3
2 1 3 0000
3```

### 输出

```
0110
0101
0110
0000```

# 题解

## 作者：Genius_Star (赞：3)

### 思路：

考虑 [P11620](https://www.luogu.com.cn/problem/P11620) 的 trick，原序列显然可以转化为异或差分后的序列；因为原序列显然可以通过其异或差分异或出来，故所表示的基是相同的。

转化为异或差分序列后，操作相当于单点异或，还有区间赋值为 $0$；注意到总共有 $n + q$ 级别的单点修改，故对于合法的区间推平操作显然也是 $O(n + q)$ 次的。

现在我们只需要支持单点异或一个数，全局查询最大值；即需要维护一个支持删除的线性基。

离线后维护一个删除时间即可，使用 `bitset` 维护，时间复杂度为 $O(\frac{n^3}{w})$。

### 完整代码：

```cpp
 #include<bits/stdc++.h>
#define ls(k) k << 1
#define rs(k) k << 1 | 1
#define fi first
#define se second
#define bset bitset<N>
#define open(s1, s2) freopen(s1, "r", stdin), freopen(s2, "w", stdout);
using namespace std;
typedef __int128 __;
typedef long double lb;
typedef double db;
typedef unsigned long long ull;
typedef long long ll;
bool Begin;
const int N = 2020;
inline ll read(){
    ll x = 0, f = 1;
    char c = getchar();
    while(c < '0' || c > '9'){
        if(c == '-')
          f = -1;
        c = getchar();
    }
    while(c >= '0' && c <= '9'){
        x = (x << 1) + (x << 3) + (c ^ 48);
        c = getchar();
    }
    return x * f;
}
inline void write(ll x){
	if(x < 0){
		putchar('-');
		x = -x;
	}
	if(x > 9)
	  write(x / 10);
	putchar(x % 10 + '0');
}
int n, m, q, op, l, r;
int pre[N];
bool f[N];
vector<pair<bset, int>> V[N];
bset x;
bset a[N], d[N];
pair<bset, int> p[N];
inline void insert(pair<bset, int> v){
	for(int i = m - 1; i >= 0; --i){
		if(!v.fi[i])
		  continue;
		if(p[i].se == -1){
			p[i] = v;
			break;
		}
		if(p[i].se < v.se)
		  swap(v, p[i]);
		v.fi ^= p[i].fi;
	}
}
inline bset ask(){
	bset ans;
	for(int i = m - 1; i >= 0; --i)
	  if(!ans[i] && p[i].se != -1)
	    ans ^= p[i].fi;
	return ans;
}
inline void print(bset ans){
	for(int i = m - 1; i >= 0; --i)
	  putchar(ans[i] + '0');
	putchar('\n');
}
bool End;
int main(){
	n = read(), m = read(), q = read();
	for(int i = 1; i <= n; ++i){
		cin >> a[i];
		d[i] = a[i - 1] ^ a[i];
	}
	for(int i = 1; i <= q; ++i){
		op = read();
		if(op == 1){
			l = read(), r = read();
			cin >> x;
			for(int j = l; j <= r; ++j)
			  a[j] ^= x;
		}
		else if(op == 2){
			l = read(), r = read();
			cin >> x;
			for(int j = l; j <= r; ++j)
			  a[j] = x;
		}
		else
		  f[i] = 1;
		if(op <= 2){
			for(int j = l; j <= min(r + 1, n); ++j){
				bset t = a[j] ^ a[j - 1];
				if(d[j] != t){
					if(d[j].count())
					  V[pre[j]].push_back({d[j], i});
					d[j] = t;
					pre[j] = i;
				}
			}
		}
	}
	for(int i = 1; i <= n; ++i)
	  if(d[i].count())
	    V[pre[i]].push_back({d[i], q + 1});
	for(int j = 0; j < m; ++j)
	  p[j].se = -1;
	for(int i = 0; i <= q; ++i){
		for(int j = 0; j < m; ++j)
		  if(p[j].se == i)
		    p[j].se = -1;
		for(auto t : V[i])
		  insert(t);
		if(f[i])
		  print(ask());
	}
	cerr << '\n' << abs(&Begin - &End) / 1048576 << "MB";
	return 0;
}
```

---

## 作者：xiezheyuan (赞：2)

拒绝可删线性基，拥抱线段树分治。如果你还不会这个强行处理不可删信息的 trick，请阅读 [oi-wiki](https://oi-wiki.org/topic/segment-tree-offline/)（夹带私货）。

## 简要题意

给定一个长度为 $n$ 的序列 $a$ 和一个整数 $m$，满足 $0\leq a_i\leq 2^m$，有 $q$ 次操作，支持：

- `1 x y v` $\forall i\in[x,y],a_i\gets a_i\oplus v$。
- `2 x y v` $\forall i\in[x,y],a_i\gets v$。
- `3` 询问选择 $a$ 的一个子序列，其异或和的最大值。

$1\leq n,m,q\leq 2\times 10^3$。

## 思路

首先题目中的操作三，几乎快将线性基写在题面上了，所以自然考虑线性基。

由于 $n,m,q$ 很小，所以可以考虑一些暴力的操作，例如对于操作 $1,2$，直接暴力完成对 $a$ 的修改，这只需要单次 $O(\frac{nm}{\omega})$ 的时间复杂度（借助 `bitset`）。

不过维护线性基的变化较为困难，一般来说线性基是难以支持修改的，但是可以方便的插入。而对于线性基这种无序结构来说，修改就是插入和删除。所以重点在于删除。

线性基如何支持删除一个数？这似乎很难办，不过可以离线，改为记录每个数出现的时间戳区间，用线段树分治维护。

这样询问会有 $O(nq)$ 个时间戳区间，时间复杂度 $O(\frac{nm^2q\log n}{\omega})$ 看着就很劣。

我们改为维护其差分数组的线性基，这和原本线性基是等价的。这样操作 $1$ 只会改变至多两个位置，操作 $2$ 均摊也只会改变 $O(1)$ 个位置（对于相同的差分数组，我们不更新时间戳区间）。线段树分治部分时间复杂度优化到 $O(\frac{m^2}{\omega}q\log n)$。略有卡常。

注意实现姿势，比如线性基撤销时只需要打一个标记，询问最大异或和用较为优秀的实现方法，这样可以跑的很快。

[Submission](https://uoj.ac/submission/737705)。

---

## 作者：Miss_SGT (赞：1)

~~网上搜出来的~~ 可撤销线性基做法。

因为有子集异或最大值，所以考虑线性基。

有区间异或，套路的将原序列改成差分数组，答案不变。这样区间异或变成单点修改，区间赋值变成单修与区间推平。这样只有 $O(n+q)$ 个值，直接上线段树分治就已经可以过了。

但是否能直接删除呢？考虑线性基加入的过程，维护一个数组 $t$。每次找到最高的 $i$ 使得当前值 $x$ 这一位为 1。如果 $t_i$ 没有，将当前值 $x$ 填入，否则将 $x$ 异或上 $t_i$。问题在于如果 $t_i$ 比 $x$ 更早删除，删除 $t_i$ 原本的值后， $x \oplus t_i$ 将不存在。

那如果我们保证 $t_i$ 比 $x$ 更晚删除不就行了？线性基每一位不仅记录一个值，还记录这个值删除的时间。当 $x$ 需要异或上比它删除时间更早的 $t_i$ 时，交换两个数，将 $t_i$ 异或 $x$ 后继续作为加入的数做就行了。

代码因为卡常很丑就不放了。

---

## 作者：hzoi_Shadow (赞：0)

[题目传送门](https://www.luogu.com.cn/problem/P11731)

# 前置知识

[拓展：前缀线性基](https://oi-wiki.org/math/linear-algebra/basis/#%E6%8B%93%E5%B1%95%E5%89%8D%E7%BC%80%E7%BA%BF%E6%80%A7%E5%9F%BA)

# 解法

经典 Trick 多合一。

同 [luogu P11620 [Ynoi Easy Round 2025] TEST_34](https://www.luogu.com.cn/problem/P11620) 考虑维护差分序列的线性基。因 $n,q$ 数据范围较小不妨考虑暴力进行操作 $1,2$，执行完操作后更新差分数组。

乍一看每次都更新差分数组的复杂度很假，但是由 [luogu P4690 [Ynoi2016] 镜中的昆虫](https://www.luogu.com.cn/problem/P4690) 可知此时区间推平次数为 $O(n+q)$，即差分数组最多修改 $O(n+q)$ 次。这样就保证了正确的复杂度。

对于线性基的删除操作，硬套线段树分治可能会有点卡常，写个可删线性基即可。

# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long 
#define ull unsigned long long
#define sort stable_sort 
#define endl '\n'
int op[2010],st[2010],m;
bitset<2010>a[2010],d[2010],s;
vector<pair<bitset<2010>,int> >e[2010];
void print(bitset<2010>x)
{
	for(int i=m-1;i>=0;i--)  cout<<x[i];
	cout<<endl;
}
struct Liner_Base
{
	int t[2010];
	bitset<2010>d[2010];
	void insert(bitset<2010>v,int now)
	{
		for(int i=m-1;i>=0;i--)
		{
			if(v[i]==1)
			{
				if(t[i]==0)
				{
					d[i]=v;  t[i]=now;
					break;
				}
				if(now>t[i])
				{
					swap(v,d[i]);  swap(now,t[i]);
				}
				v^=d[i];
			}
		}
	}
	void del(int now)
	{
		for(int i=m-1;i>=0;i--)  if(t[i]==now)  
		{
			d[i].reset();  t[i]=0;
		}
	}
	bitset<2010>query()
	{
		bitset<2010>ans;
		for(int i=m-1;i>=0;i--)  if(ans[i]==0&&t[i]!=0)  ans^=d[i];
		return ans;
	}
}L;

int main()
{
// #define Isaac
#ifdef Isaac
	freopen("in.in","r",stdin);
	freopen("out.out","w",stdout);
#endif
	int n,q,l,r,i,j;
	cin>>n>>m>>q;
	for(i=1;i<=n;i++)
	{
		cin>>a[i];  d[i]=a[i-1]^a[i];
	}
	for(i=1;i<=q;i++)
	{
		cin>>op[i];
		if(op[i]<=2)  cin>>l>>r>>s;
		if(op[i]==1)  for(j=l;j<=r;j++)  a[j]^=s;
		if(op[i]==2)  for(j=l;j<=r;j++)  a[j]=s;
		if(op[i]<=2)  for(j=l;j<=min(r+1,n);j++)
		{
			s=a[j]^a[j-1];
			if(d[j]!=s)
			{
				if(d[j].any()==1)  e[st[j]].push_back(make_pair(d[j],i));
				d[j]=s;  st[j]=i;
			}
		}
	}
	for(i=1;i<=n;i++)  if(d[i].any()==1)  e[st[i]].push_back(make_pair(d[i],q+1));
	for(i=0;i<=q;i++)
	{
		L.del(i);
		for(j=0;j<e[i].size();j++)  L.insert(e[i][j].first,e[i][j].second);
		if(op[i]==3)  print(L.query());
	}
	return 0;
}
```

---

## 作者：hgckythgcfhk (赞：0)

一个细节很多的板题，很适合很长时间没写过线性基和线段树分治的复习模板，同时这个题 $\log$ 很大的性质促使我去查阅了很多资料了解了线性基的一些信息。

线性基这个东西确实有点冷门，其实主要是容易被一些概念吓到，这里我不提任何概念，只介绍一下算法流程，以用于说明时间复杂度。

### 插入

开一个大小为 $\log$ 的数组，从高到低枚举要插入的数 $x$ 的二进制位。

* 第 $i$ 位是 $1$。
  * $a[i]\ne 0,x\gets x \operatorname{xor} a[i]$。
  * $a[i]=0,a[i]=x$

容易发现这个东西的时间复杂度是位数乘异或运算的时间复杂度的，这里我们认为位数是 $O(\log V)$，异或运算是 $O(\dfrac{\log V}{w})$ 所以时间复杂度是 $O(\dfrac{\log^2V}{w})$ 的。

### 查询
每一位异或上这一位存的值，如果异或后使答案扩大则更新。

不难发现，时间复杂度也是 $O(\dfrac{\log^2V}{w})$ 的。

### 合并

将一个线性基的数组里存的所有数插入到另一个线性基。

注意到很多线性基的文章会说这个过程是高斯消元，而高斯消元时可以规约矩阵乘法的，所以这个过程绝对不可能低于 $3$ 次，时间复杂度是 $\dfrac{\log^3V}{w}$ 的。

虽然大部分文章会少一个 $\log$，但实际上是因为大部分时候 $\log V=w$，对于本题，就正好是 $\log V$ 远大于 $w$ 的情况。

### 修改

相当于先删除再插入，在线是可以 $O(\dfrac{\log^3V}{w})$ 实现删除的，对于本题没什么用，考虑到线性基的性质，插入顺序不重要，所以可以考虑线段树分治。

对于修改操作，我们可以暴力处理，时间复杂度是 $O(\dfrac{nmq}{w})$ 的，先在我们只需要讨论插入到线段树的修改的个数就好了。

首先，$a[1],a[2],\dots,a[n]$ 的线性基和 $a[1]\operatorname{xor}0,a[2]\operatorname{xor}a[1],\dots,a[n]\operatorname{xor}a[n-1]$ 相同，因为可以考虑用 $a[1]$ 和 $a[2]\operatorname{xor}a[1]$ 造出一个 $a[2]$ 然后归纳得到整个原序列，所以区间异或可以转化为单点异或，每次只需要改两个位置，区间赋值可以转化为单点修改和区间清零，定义势能为异或差分数组的全局 $0$ 的个数，每次区间赋值会让势能增加一些，同时减少不超过 $2$，由于势能上界是 $O(n)$ 的，减少量是 $O(1)$ 的，所以势能变化量的和均摊下来是 $O(n+q)$ 的，插入的修改个数等于势能变化量，所以线段树分治的时间复杂度是 $O(\dfrac{(n+q)m^2\log q}{w})$ 的。

说一些细节，```bitset``` 没有重载比较运算符，所以要手写，由于我们不太能轻松的取出 ```bitset``` 的整块，所以这个地方必须手写 ```bitset``` 才能保证时间复杂度除 $w$，关于手写 ```bitset```，寻址的时候需要翻转下标，就是说查询某块的第 $i$ 位是左移 $63-i$ 而不是 $i$，否则比较大小的时候会出问题，第一次写容易注意不到。

先在介绍几种好实现的造出要插入哪些修改的写法，首先我们并不需要手算推式子推出位置，然后不断推错不断修改一些是否加一减一的常数并对程序进行 dfs，完全可以直接暴力检查哪些位置需要修改，这样其实已经比较好写了，但是这里面还要考虑上一次修改的时间，并且思考这次修改的时间区间的起点是否比上次加一，或者记的这个时间数组到底是时间区间的右端点还是右端点加一这类的问题（起码我们把位置上的细节消掉了），所以我们可以考虑记下差分数组每个历史版本，对每个位置划分颜色段，这样就没有细节了，但由于这个数组需要 $2000^3bit$ 也就是 $10^9$ 字节，是开不下的。

所以我们需要充分发扬人类智慧，我们可以对每个位置跑 $n$ 遍 $q$ 个询问，由于每个位置的差分数组只关心原数组的两个位置，修改的时候我们可以只维护这两个位置，然后处理立这一个位置的修改，这样我们可以用只有不到 $2$ 倍且不在瓶颈上的常数消灭掉整个程序细节最多的地方，可以发现这是一个减少程序里加减 $O(1)$ 的细节的一个比较通用的方法。

为防止因火车头导致无法过审，这里只放核心程序。

```cpp
unsigned n,m,q;
struct bint{ull a[32];il bint(){cle(a);;}
	il bool operator[](int x){return (a[x>>6]>>(63ull^(ull)(x&63ull)))&1ull;}
	void set(int x){a[x>>6]|=1ull<<(63ull^(x&63ull));}
	il bint&operator=(bint b){memcpy(a,b.a,sizeof a);return *this;}
	il bool operator==(bint b){return !memcmp(a,b.a,sizeof a);}
	il bint operator^(bint b){bint c=b;for(int i=0;i<32;++i)c.a[i]^=a[i];return c;}
	il bool operator<(bint b){for(int i=0;i<32;++i)if(a[i]^b.a[i])return a[i]<b.a[i];return 0;}
	void print(){for(int i=0;i<m;++i)pu((*this)[i]|48);pu(10);}
	void input(string s){for(int i=0;i<m;++i)if(s[i]&1)set(i);}
}a[N],b[N],d[N];unsigned tim[N];
struct base{bint b[N];bint c;
	void ins(bint x){for(int i=0;i<m;++i)if(x[i]){if(!c[i]){b[i]=x;c.set(i);break;}x=x^b[i];}}
	il bint qry(){bint ans;for(int i=0;i<m;++i)if(c[i]&&ans<(b[i]^ans))ans=ans^b[i];return ans;}
	void clear(){for(int i=0;i<m;++i)b[i]=bint();c=bint();}
}_;struct Q{unsigned op,l,r;bint x;}c[N];
namespace seg{vector<bint>t[N<<2];unsigned x,y;bint z;bint out;
	#define ls o<<1
	#define rs ls|1
	#define in x<=l&&y>=r
	#define ot y<l ||x >r
	void dpdate(cit o,cit l,cit r){if(in){t[o]+=z;return;}if(ot)return;cit $=l+r>>1;dpdate(ls,l,$),dpdate(rs,$+1,r);}
	void ins(cit l,cit r,bint _){z=_;x=l,y=r;dpdate(1,1,q+1);}
	void dfs(cit o,cit l,cit r){cit $=l+r>>1;for(bint i:t[o])_.ins(i);
		if(l==r){if(out[l])_.qry().print();return;}base pre=_;
		dfs(ls,l,$),_=pre,dfs(rs,$+1,r),_=pre;}
}

void init(){cin>>n>>m>>q;
	for(int i=1;i<=n;++i){string s;cin>>s;a[i].input(s);}
	for(int i=1;i<=n;++i)b[i]=a[i]^a[i-1];
}void solve(){init();
    for(int op,l,r,t=1;t<=q;++t){cin>>op;
		if((--op)^2){string s;bint x;cin>>l>>r>>s;x.input(s);c[t]=Q{op,l,r,x};}
		else seg::out.set(t+1);
	}for(int i=1;i<=n;++i){bint ai=a[i],ai1=a[i-1];d[1]=b[i];
		for(int t=1;t<=q;d[++t]=a[i]^a[i-1])if(c[t].op^2){cit l=c[t].l,r=c[t].r;if(r<i-1||l>i)continue;
			for(int j=max(i-1,l);j<=min(i,r);++j)a[j]=c[t].op?c[t].x:a[j]^c[t].x;
		}for(int l=1,r=0;l<=q+1;seg::ins(l,r,d[l]),l=r+1)while(d[r+1]==d[l]&&r<=q)++r;
		a[i]=ai,a[i-1]=ai1;}seg::dfs(1,1,q+1);
}signed main(){open;int t=1;//cin>>t;
	while(t--)solve();}

```

---


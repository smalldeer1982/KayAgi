# [集训队互测 2015] 胡策的统计

## 题目描述

在 OI 界，有一位无人不知无人不晓，OI 水平前无古人后无来者的胡策，江湖人称一眼秒题胡大爷！

今天胡策在研究无向图的连通性。对于一个无向图定义它的连通值为该图连通块数的阶乘。

为了研究连通值的性质，胡策随手画了一个 $n$ 个结点的简单无向图 $G$，结点分别编号为 $1, \dots, n$，他想统计出 $G$ 的所有生成子图的连通值之和。

胡策当然会做啦！但是他想考考你。你只用输出结果对 $998244353$ （$7 \times 17 \times 2^{23} + 1$，一个质数） 取模后的结果。

简单无向图即无重边无自环的无向图。生成子图即原图中删去若干条边（可以是 $0$ 条）后形成的图。

## 说明/提示

| 测试点编号 | $n \leq$ | 特殊限制 |
| :----------: | :----------: | :----------: |
| $1$ | $6$ | 无 |
| $2$ | $10$ | 无 |
| $3$ | $10$ | 无 |
| $4$ | $17$ | 无 |
| $5$ | $17$ | 无 |
| $6$ | $17$ | 无 |
| $7$ | $20$ | $G$ 为完全图 |
| $8$ | $20$ | 无 |
| $9$ | $20$ | 无 |
| $10$ | $20$ | 无 |


## 样例 #1

### 输入

```
6 13
1 2
1 3
2 3
1 4
4 2
3 4
5 2
3 5
5 4
6 2
6 3
6 4
6 5```

### 输出

```
16974```

# 题解

## 作者：喵仔牛奶 (赞：1)

## Solution

设 $[x^S]F(x)$ 表示 $S$ 的生成子图个数，定义 $[x^{\emptyset}]F(x)=1$。求出 $c_S$ 表示两端都在 $S$ 中的边的个数，可以发现 $[x^S]F(x)=2^{c_S}$。

设 $[x^S]G(x)$ 表示 $S$ 的连通生成子图个数，定义 $[x^{\emptyset}]G(x)=0$。可以发现 $\exp G=F$，即 $G=\ln F$，做一遍 ln 即可求出 $G$。

设 $[x^S]H(x)$ 表示 $S$ 的生成子图连通值之和，可以发现
$$H(x)=\sum_{n\ge 0}\frac{G^n}{n!}\times n!=\sum_{n\ge 0}G^n=\frac{1}{1-G}$$

做一遍求逆即可求出 $H$。

求 ln 和求逆复杂度都是 $\mathcal O(n^22^n)$，故总复杂度也是这个。

## Code

直接贺两个板子上去会被卡常，见 <https://uoj.ac/submission/743330>。

需要把两个写到一起，能够省 $2n$ 次 FWT，就可以通过啦。

```cpp
#include <bits/stdc++.h>
#define REP(i, l, r) for (int i = (l); i <= (r); ++ i)
#define DEP(i, r, l) for (int i = (r); i >= (l); -- i)
#define fi first
#define se second
#define pb emplace_back
#define mems(x, v) memset((x), (v), sizeof(x))
#define SZ(x) (int)(x).size()
#define ALL(x) (x).begin(), (x).end()
using namespace std;
namespace math { ... }
namespace Milkcat {
	using namespace math;
	typedef long long LL;
	typedef pair<LL, LL> pii;
	const int N = 20, mod = 998244353;
	typedef mint<mod> MI;
	int n, k, x, y; MI f[1 << N], g[1 << N], A[N + 1][1 << N], B[N + 1][1 << N];
	void fwt(MI* f, int n, int o) {
		REP(i, 0, n - 1) REP(j, 0, (1 << n) - 1)
			if (j >> i & 1) f[j] += f[j ^ 1 << i] * o;
	}
	int ppc(int x) { return __builtin_popcount(x); }
	int main() {
		cin >> n >> k;
		REP(i, 1, k) {
			cin >> x >> y, x --, y --;
			f[1 << x | 1 << y] += 1;
		}
		fwt(f, n, 1);
		REP(i, 0, (1 << n) - 1)
			f[i] = qpow((MI)2, f[i].val());
		int m = (1 << n);
		REP(i, 0, m - 1) A[ppc(i)][i] = f[i];
		REP(i, 0, n) fwt(A[i], n, 1);
		REP(i, 1, n) {
			REP(j, 1, i - 1) REP(S, 0, m - 1)
				B[i][S] += B[j][S] * A[i - j][S] * j;
			MI iv = (MI)1 / i;
			REP(S, 0, m - 1) B[i][S] = A[i][S] - B[i][S] * iv;
		}
		REP(i, 0, n) REP(j, 0, m - 1)
			A[i][j] = -B[i][j] + 1, B[i][j] = 0;
		REP(S, 0, m - 1) B[0][S] = A[0][S].inv();
		REP(i, 1, n) REP(j, 1, i) REP(S, 0, m - 1)
			B[i][S] -= A[j][S] * B[i - j][S] * B[0][S];
		fwt(B[n], n, -1);
		cout << B[n][m - 1] << '\n';
		return 0;
	}
}
```

---

## 作者：lalaouye (赞：1)

省选后第一道题。

结合数据范围直接考虑类似子集的东西。由于跟连通块数量有关，我们考虑设 $G(S,i)$ 表示点集 $S$ 共有 $i$ 个连通块的答案。发现转移需要钦定加入的集合包含了集合内的第一个点，然后我们需要另设 $F(S)$ 表示让 $S$ 集合中的点连通的方案数，转移 $F(S)$ 考虑容斥，具体的，

$$F(S)=2^{|E_S|}-\sum_{T\subseteq S,chk(S,T)=1} F(T)2^{|E_{S/T}|}$$

其中 $chk(S,T)$ 表示 $S,T$ 中的最小的点相同，就是一个钦定技巧。

然后写个暴力，期望 $60$，结果只得 $30$，发现自己复杂度其实是 $\mathcal{O}(n3^n)$，想办法把 $n$ 去掉，发现我们如果不钦定直接转移导致的错误是我们会算出任意连通块加入顺序的答案，这不就是题目要求的吗？所以我们可以直接去掉连通块数量的一维，再去掉钦定，就能做到 $\mathcal{O}(3^n)$ 的暴力。

接下来考虑用半在线子集卷积优化，首先算 $G$ 显然是好优化的，然后考虑优化 $F$。发现 $F$ 不能钦定，然而我们发现转移时只有最小值相同的集合会互相转移，那么我们将最小值不同的分开处理，我们最小值每加一，集合个数就会减半，不难发现其复杂度仍是 $\mathcal{O}(n^22^n)$。

代码：


```cpp
#include <bits/stdc++.h>
#include <bits/extc++.h>
#define rep(i, l, r) for (int i (l); i <= r; ++ i)
#define rrp(i, l, r) for (int i (r); i >= l; -- i)
#define eb emplace_back
using namespace std;
using namespace __gnu_cxx;
using namespace __gnu_pbds;
#define pii pair <int, int>
#define inf 1000000000
#define ls (p << 1)
#define rs (ls | 1)
constexpr int N = 20 + 5, M = 1e5 + 5, P = 998244353;
typedef long long ll;
typedef unsigned long long ull;
inline __int128_t rd () {
  __int128_t x = 0, f = 1;
  char ch = getchar ();
  while (! isdigit (ch)) {
    if (ch == '-') f = -1;
    ch = getchar ();
  }
  while (isdigit (ch)) {
    x = (x << 1) + (x << 3) + (ch ^ 48);
    ch = getchar ();
  }
  return x * f;
}
int qpow (int x, int y) {
  ll ret (1);
  for (; y; y >>= 1, x = 1ll * x * x % P) if (y & 1) ret = ret * x % P;
  return ret;
}
void add (auto &x, auto y) {
  x += y;
  if (x >= P) x -= P;
}
int n, m, s;
void fwt (auto * f, int n, int x) {
  for (int k (1), o (2); k <= n; k <<= 1, o <<= 1) {
    for (int i (0); i <= n; i += o) {
      rep (j, 0, k - 1) {
        if (x == 1) add (f[i + j + k], f[i + j]);
        else add (f[i + j + k], P - f[i + j]);
      }
    }
  }
}
int f[1 << 20];
int g[1 << 20];
int w[1 << 20], lw[1 << 20];
vector <int> e[N];
int clz[1 << 20], bt[1 << 20]; 
int fac[N];
int h[1 << 20];
int F[21][1 << 20];
int G[21][1 << 20];
int32_t main () {
  // freopen ("1.in", "r", stdin);
  // freopen ("1.out", "w", stdout);
  n = rd (), m = rd ();
  rep (i, 1, m) {
    int u (rd ()), v (rd ());
    e[u - 1].eb (v - 1);
  }
  s = 1 << n; -- s;
  rep (i, 0, s) {
    rep (j, 0, n - 1) {
      if (~ i >> j & 1) continue;
      for (auto v : e[j]) {
        if (i >> v & 1) ++ w[i];
      }
    } w[i] = qpow (2, w[i]);
  }
  rep (i, 0, s) {
    clz[i] = -1;
    rep (j, 0, n - 1) {
      if (i >> j & 1) {
        clz[i] = j; break;
      }
    }
    bt[i] = __builtin_popcount (i);
  }
  int tmp (s);
  rep (T, 1, n) {
    rep (i, 0, tmp) {
      if (~ i & 1) w[i >> 1] = w[i]; else lw[i >> 1] = w[i];
    }
    tmp >>= 1;
    rep (i, 0, tmp) F[bt[i]][i] = w[i];
    rep (i, 0, n - T) fwt (F[i], tmp, 1);
    G[0][0] = 1; fwt (G[0], tmp, 1); h[0] = 1;
    rep (i, 1, n - T) {
      memset (g, 0, sizeof g);
      rep (k, 1, i) {
        rep (j, 0, tmp) {
          g[j] = (1ll * F[k][j] * G[i - k][j] % P + g[j]) % P;
        }
      }
      fwt (g, tmp, -1);
      rep (j, 0, tmp) if (bt[j] == i) h[j] = G[i][j] = (lw[j] + P - g[j]) % P;
      fwt (G[i], tmp, 1);
    }
    rep (i, 0, tmp) f[i << T | (1 << (T - 1))] = h[i];
    memset (F, 0, sizeof F);
    memset (G, 0, sizeof G);
  }
  rep (i, 0, s) F[bt[i]][i] = f[i]; 
  rep (i, 0, n) fwt (F[i], s, 1);
  G[0][0] = 1; fwt (G[0], s, 1);
  rep (i, 1, n) {
    memset (g, 0, sizeof g);
    rep (k, 1, i) {
      rep (j, 0, s) {
        g[j] = (1ll * F[k][j] * G[i - k][j] % P + g[j]) % P;
      }
    }
    fwt (g, s, -1);
    rep (j, 0, s) if (bt[j] == i) h[j] = G[i][j] = g[j];
    fwt (G[i], s, 1);
  }
  cout << (h[s] + P) % P;
}
```

---


# [集训队互测 2024] 线段树与区间加

## 题目描述

普罗在图书馆找到了一本关于算法的书。书中介绍了一种名为“线段树”的数据结构。

>
>线段树是一种有根的二叉树，其每个节点对应了序列上的一个区间 $[l,r]$，其中根节点对应 $[1,n]$。
>
>对于每个节点，若其代表的序列区间 $[l,r]$ 满足 $l=r$，则其为叶节点；否则存在整数 $k(l\le k<r)$，满足其左儿子代表区间 $[l,k]$，右儿子代表区间 $[k+1, r]$。为了保证其时间复杂度，$k$ 一般会取 $\left\lfloor\frac{l+r}{2}\right\rfloor$。
>
>线段树可以实现单点修改，区间修改，区间查询等操作。其中区间修改操作的实现通常需要维护名为懒惰标记的额外信息。
>

在简单了解了线段树如何维护区间加之后，普罗想要实现一个维护区间加的线段树。于是他写下了如下的代码：

```cpp
#define len(i) (r[i]-l[i]+1)
void push_down(int i)
{
    a[lc[i]]+=len(lc[i])*lz[i];
    lz[lc[i]]+=lz[i];
    a[rc[i]]+=len(rc[i])*lz[i];
    lz[rc[i]]+=lz[i];
    lz[i]=0;
    return;
}
void add(int i,int ql,int qr,unsigned k)
{
    if(qr<l[i]||r[i]<ql) return;
    if(ql<=l[i]&&r[i]<=qr){
        a[i]+=len(i)*k;
        lz[i]+=k;
        return;
    }
    push_down(i);
    add(lc[i],ql,qr,k);
    add(rc[i],ql,qr,k);
    a[i]=a[lc[i]]+a[rc[i]];
    return;
}
```

为了检验这份代码的正确性，普罗构建了一个维护的序列长为 $n$ 的线段树，并在每个节点上设置两个额外的权值 $va_i,vb_i$，接下来他在线段树上进行了 $m$ 次区间加的操作，在每次区间加操作后输出了下面函数的返回值。

```cpp
unsigned foobar(){
	unsigned tot=0;
	for(int i=1;i<2*n;i++)tot+=va[i]*a[i]+vb[i]*lz[i];
	return tot;
}
```

因为 K 博士的电脑实在太快了，普罗的代码只花了 1ms 就得出了结果。但是他还是不知道代码是不是正确的，所以请你计算出上面的函数的结果和普罗得出的结果比较吧。

## 说明/提示

【数据规模与约定】

| 测试点编号 | $n,q$ | 其他约定 |
| :-----------: | :-----------: | :-----------: |
| $1\sim5$ | $\le2000$ | 无 |
| $6\sim10$ | $\le40000$ | 无 |
| $11\sim15$ | $\le2\times10^5$ | 保证存在一个线段树上的节点对应的区间为 $[ql,qr]$ |
| $16\sim20$ | $\le2\times10^5$ | 保证不同的 $ql,qr$ 不超过 $200$ 种 |
| $21\sim25$ | $\le2\times10^5$ | 无 |

如果测试点编号 $\bmod 5$ 为 $2$ 或 $3$，该测试点保证 $va_i=0$。

如果测试点编号 $\bmod 5$ 为 $4$ 或 $0$，该测试点保证 $vb_i=0$。

对于 $100\%$ 的数据，保证 $1\le n,q\le2\times10^5$，给出的线段树和区间加操作是合法的，$0\le va_i,vb_i,k_i<2^{32}$。

## 样例 #1

### 输入

```
4 4
1 4 0 1 2 3
1 2 3 5 4 5
3 4 2 2 6 7
1 1 1 4
2 2 3 2
3 3 2 0
4 4 5 3
1 3 3
2 4 1
1 4 2
2 3 1```

### 输出

```
45
74
76
154
```

## 样例 #2

### 输入

```
4 4
1 4 2 4 2 3
1 3 1 3 4 5
4 4 5 4
1 1 3 3
2 3 2 1 6 7
2 2 0 3
3 3 2 5
1 3 3
2 4 1
1 4 2
2 3 1```

### 输出

```
36
82
106
155
```

# 题解

## 作者：EastSnowLotus (赞：3)

好像发错号了。

为什么要过题才能发题解？

----

首先注意到 $s_p$ 可以表示为 $u$ 子树对应的值的和减去祖先的 lazy 之和乘上该区间的长度，所以其实只需要考虑如何维护 $\sum lz_iv_i$。

记 $P_i$ 表示 $[i,i]$ 对应节点。首先根据 zkw 线段树能够得到一个结论：线段树上区间 $[l,r]$ 所包含的线段树区间，为 $P_{l-1}$ 和 $P_{r+1}$ 在树上构成的链内部的那部分。因此一次操作相当于将链上的点（实际上两端可以认为是 $\operatorname{LCA}(P_{l-1},P_l)$ 和 $\operatorname{LCA}(P_r,P_{r+1})$）全都 pushdown，并且将这条链内侧第一层的所有点（类似一个毛毛虫的形状）全都加上 $v$。

因为 pushdown 之后的变化比较阴间，但是注意到如果我们考虑维护每个点到根的链上的 lazytag 之和，就会发现 pushdown 的时候等价于链上清空，而其他位置不会发生变化。

于是我们考虑在每个位置记录其到根的 lazytag 之和，这样当我们进行区间加的时候，实际上就等价于进行以下两个操作：

1. 将一条链上所有的 $a_i$ 改为 $0$；
2. 将一条链内部所有点的 $a_i$ 都加上 $k$；
3. 查询 $\sum (a_i-a_{f_i})v_i$。

首先查询里面那个差分的系数可以也合并进 $v_i$ 里，所以我们现在还是求 $\sum a_iv_i$。将链修改为 $0$ 是简单的，现在我们的问题是对一条从下往上的链上所有点的**不在链上的**左/右子树进行操作。

考虑修改一下树剖的 dfs 序：对于一条重链，先从上到下依次遍历重链上的点，接着从下往上依次遍历链上的点的轻左子树（没有就跳过），最后从下往上依次遍历链上的点的轻右子树。

于是容易发现此时一条重链上的这些子树可以用上面的顺序中 $O(1)$ 个区间来表示，于是这样我们就可以用 $O(\log n)$ 个区间来表示一条任意的从下到上的链上的这些子树。

这样直接用一个普通的区间赋值区间加求带权和的线段树维护，总时间复杂度 $O(n\log^2 n)$。

---

## 作者：DaiRuiChen007 (赞：0)

[Problem Link](https://www.luogu.com.cn/problem/P12489)

**题目大意**

> 给定 $[1,n]$ 的线段树（每次不一定从中点分治），支持 $q$ 次区间加，动态维护 $\sum_u tg_ua_u+s_ub_u$。
>
> 数据范围：$n,q\le 2\times 10^5$。

**思路分析**

首先线段树上的 $s_u$ 相当于 $u$ 子树内实际的元素和，减去所有祖先处的懒标记之和减去区间长度。

因此可以把 $s_ub_u$ 的贡献拆到祖先的 $tg_ua_u$ 以及原序列上，这样就去掉了 $s_ub_u$。

然后考虑怎么维护 $\sum tg_ua_u$。

考虑线段树上的修改过程，类比 zkw 线段树，定义 $p_i$ 表示 $[i,i]$ 线段树上的对应区间。

对 $[l,r]$ 区间加，相当于从 $p_{l-1},p_{r+1}$ 向上跳到 $\mathrm{LCA}$ 为止，如果当前点是左 / 右儿子，就给兄弟打懒标记。

但此前我们还要 pushdown，具体来说 pushdown 的点也是两条链，即 $\mathrm{LCA}(p_{l-1},p_l),\mathrm{LCA}(p_{r+1},p_r)$ 到根的链，从上往下把每个点 pushdown。

先维护 pushdown，那么就是把链上每个点的兄弟加上链上懒标记的前缀和。

那么树剖，对每个重链处理，那么就是把 $[l,i]$ 的元素和加到 $i$ 的轻儿子上，然后在路径上的轻边特殊处理。

注意到我们不一定要实时维护轻儿子的权值，而是把一部分权值留在父亲处，这样 pushdown 时只要简单打标记，等到修改的时候遇到一个轻儿子再手动更新其权值。

然后是打标记，依然树链剖分，相当于把 $[l,r]$ 中重儿子在左边 / 右边的点加权值。

那么都可以直接用线段树维护，实现的时候维护打每种标记后答案的变化量即可。

时间复杂度 $\mathcal O(n+q\log^2n)$。

**代码呈现**

```cpp
#include<bits/stdc++.h>
#define ui unsigned
using namespace std;
const int MAXN=4e5+5,MAXS=1<<20|5;
int n,m,q,rt,ch[MAXN][2],lp[MAXN],rp[MAXN],at[MAXN],fa[MAXN];
ui len[MAXN],w[MAXN],h[MAXN],sh[MAXN];
int tb[MAXN][20],siz[MAXN],hson[MAXN],lson[MAXN],ty[MAXN];
int top[MAXN],dfn[MAXN],dcnt,rk[MAXN];
int bit(int k) { return 1<<k; }
int cmp(int x,int y) { return dfn[x]<dfn[y]?x:y; }
int LCA(int x,int y) {
	if(x==y) return x;
	int l=min(dfn[x],dfn[y])+1,r=max(dfn[x],dfn[y]),k=__lg(r-l+1);
	return cmp(tb[l][k],tb[r-bit(k)+1][k]);
}
struct Segt1 {
	ui tr[MAXS],ws[MAXS],tg[MAXS];
	void adt(int p,ui k) { tg[p]+=k,tr[p]+=ws[p]*k; }
	void psd(int p) { adt(p<<1,tg[p]),adt(p<<1|1,tg[p]),tg[p]=0; }
	void psu(int p) { tr[p]=tr[p<<1]+tr[p<<1|1]; }
	void init(int l=1,int r=m,int p=1) {
		if(l==r) return ws[p]=h[at[l]],void();
		int mid=(l+r)>>1; psd(p);
		init(l,mid,p<<1),init(mid+1,r,p<<1|1);
		ws[p]=ws[p<<1]+ws[p<<1|1];
	}
	void add(int ul,int ur,ui k,int l=1,int r=m,int p=1) {
		if(ul<=l&&r<=ur) return adt(p,k);
		int mid=(l+r)>>1; psd(p);
		if(ul<=mid) add(ul,ur,k,l,mid,p<<1);
		if(mid<ur) add(ul,ur,k,mid+1,r,p<<1|1);
		psu(p);
	}
}	TB;
void dfs1(int u) {
	siz[u]=1;
	if(len[u]==1) return ;
	for(int v:ch[u]) {
		h[v]+=h[u],dfs1(v),siz[u]+=siz[v],sh[u]+=sh[v];
		if(siz[v]>siz[hson[u]]) hson[u]=v;
	}
	w[u]-=sh[u],lson[u]=ch[u][0]^ch[u][1]^hson[u],ty[u]=(lson[u]==ch[u][1]);
}
void dfs2(int u,int t) {
	top[u]=t,dfn[u]=++dcnt,tb[dcnt][0]=fa[u],rk[dcnt]=u;
	if(len[u]==1) return ;
	dfs2(hson[u],t);
	for(int v:ch[u]) if(v^hson[u]) dfs2(v,v);
}
struct Segt2 {
	ui sw[MAXS],sv[MAXS][2];
	ui f[MAXS],g[MAXS],h[MAXS],z[MAXS],tv[MAXS][2],lf[MAXS];
	//f=x[u]*w[u], g=lz[ls]*w[ls], h=x[u]*sufw[ls], z=x[u]
	bool tg[MAXS];
	void psu(int p) {
		f[p]=f[p<<1]+f[p<<1|1],g[p]=g[p<<1]+g[p<<1|1],z[p]=z[p<<1]+z[p<<1|1];
		h[p]=h[p<<1]+h[p<<1|1]+z[p<<1]*sw[p<<1|1];
	}
	void adt(int p) {
		tg[p]=1,g[p]+=h[p],lf[p]+=z[p];
		f[p]=h[p]=z[p]=0,tg[p]=true;
	}
	void adv(int p,int c,ui k) { tv[p][c]+=k,g[p]+=sv[p][c]*k; }
	void psd(int p) {
		if(tg[p]) {
			for(int o:{0,1}) adv(p<<1|1,o,z[p<<1]);
			adt(p<<1),adt(p<<1|1),tg[p]=0;
		}
		for(int o:{0,1}) adv(p<<1,o,tv[p][o]),adv(p<<1|1,o,tv[p][o]),tv[p][o]=0;
	}
	void init(int l=1,int r=n,int p=1) {
		if(l==r) {
			sw[p]=sv[p][ty[rk[l]]]=w[lson[rk[l]]];
			return ;
		}
		int mid=(l+r)>>1;
		init(l,mid,p<<1),init(mid+1,r,p<<1|1);
		sw[p]=sw[p<<1]+sw[p<<1|1];
		for(int o:{0,1}) sv[p][o]=sv[p<<1][o]+sv[p<<1|1][o];
	}
	ui qlz(int u,int l=1,int r=n,int p=1) {
		if(l==r) {
			ui s=tv[p][ty[rk[l]]]+lf[p];
			tv[p][0]=tv[p][1]=lf[p]=g[p]=0;
			return s;
		}
		int mid=(l+r)>>1; psd(p);
		ui s=(u<=mid?qlz(u,l,mid,p<<1):qlz(u,mid+1,r,p<<1|1));
		psu(p);
		return s;
	}
	void adx(int u,ui x,int l=1,int r=n,int p=1) {
		if(l==r) {
			f[p]+=x*w[rk[l]],h[p]+=x*sw[p],z[p]+=x;
			return ;
		}
		int mid=(l+r)>>1; psd(p);
		u<=mid?adx(u,x,l,mid,p<<1):adx(u,x,mid+1,r,p<<1|1);
		psu(p);
	}
	void upd(int ul,int ur,int o,ui &x,int l=1,int r=n,int p=1) {
		if(ul<=l&&r<=ur) {
			if(~o) adv(p,o,x);
			else adv(p,0,x),adv(p,1,x),x+=z[p],adt(p);
			return ;
		}
		int mid=(l+r)>>1; psd(p);
		if(ul<=mid) upd(ul,ur,o,x,l,mid,p<<1);
		if(mid<ur) upd(ul,ur,o,x,mid+1,r,p<<1|1);
		psu(p);
	}
}	T;
void upd(int s) {
	vector <int> st;
	for(int u=s;u;u=fa[top[u]]) st.push_back(u);
	reverse(st.begin(),st.end());
	for(int x:st) {
		if(fa[top[x]]) T.adx(dfn[top[x]],T.qlz(dfn[fa[top[x]]]));
		ui z=0; T.upd(dfn[top[x]],dfn[x],-1,z);
		T.adx(dfn[hson[x]],z);
	}
}
void add(int x,int y,bool o,ui z) {
	while(top[x]^top[y]) {
		if(x!=top[x]) T.upd(dfn[top[x]],dfn[x]-1,o,z);
		x=fa[top[x]];
		if(ty[x]!=o) T.adx(dfn[hson[x]],z);
	}
	if(x!=y) T.upd(dfn[y],dfn[x]-1,o,z);
}
signed main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>m>>q,n=2*m-1;
	for(int i=1;i<=n;++i) {
		cin>>lp[i]>>rp[i]>>h[i]>>w[i],len[i]=rp[i]-lp[i]+1;
		if(len[i]>1) cin>>ch[i][0]>>ch[i][1],fa[ch[i][0]]=fa[ch[i][1]]=i;
		else at[lp[i]]=i;
		if(lp[i]==1&&rp[i]==m) rt=i;
	}
	for(int i=1;i<=n;++i) sh[fa[i]]+=len[i]*h[i];
	dfs1(rt),dfs2(rt,rt),TB.init(),T.init();
	for(int k=1;k<20;++k) for(int i=1;i+bit(k)-1<=n;++i) tb[i][k]=cmp(tb[i][k-1],tb[i+bit(k-1)][k-1]);
	for(int l,r;q--;) {
		ui z; cin>>l>>r>>z,TB.add(l,r,z);
		if(l>1) upd(LCA(at[l-1],at[l]));
		if(r<m) upd(LCA(at[r+1],at[r]));
		if(1<l&&r<m) {
			int x=LCA(at[l-1],at[r+1]);
			add(at[l-1],ch[x][0],1,z);
			add(at[r+1],ch[x][1],0,z);
		} else if(1<l) {
			add(at[l-1],rt,1,z);
		} else if(r<m) {
			add(at[r+1],rt,0,z);
		} else T.adx(dfn[rt],z);
		cout<<TB.tr[1]+T.f[1]+T.g[1]<<"\n";
	}
	return 0;
}
```

---


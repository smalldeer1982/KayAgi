# [国家集训队] 圈地计划

## 题目描述

最近房地产商 GDOI(Group of Dumbbells Or Idiots) 从 NOI(Nuts Old Idiots) 手中得到了一块开发土地。据了解，这块土地是一块矩形的区域，可以纵横划分为 $N\times M$ 块小区域。GDOI 要求将这些区域分为商业区和工业区来开发。根据不同的地形环境，每块小区域建造商业区和工业区能取得不同的经济价值。更具体点，对于第 $i$ 行第 $j$ 列的区域，建造商业区将得到 $A_{i,j}$ 收益，建造工业区将得到 $B_{i,j}$ 收益。另外不同的区域连在一起可以得到额外的收益，即如果区域 $(i,j)$ 相邻（相邻是指两个格子有公共边）有 $k$ 块（显然 $k$ 不超过 $4$）类型不同于 $(i,j)$ 的区域，则这块区域能增加 $k\times C_{i,j}$ 收益。经过 Tiger.S 教授的勘察，收益矩阵 $A,B,C$ 都已经知道了。你能帮 GDOI 求出一个收益最大的方案么？

## 说明/提示

$1\leq N,M\leq 10$，$0\leq A_{i,j},B_{i,j},C_{i,j}\leq 10^3$。

## 样例 #1

### 输入

```
3 3
1 2 3
4 5 6
7 8 9
9 8 7
6 5 4
3 2 1
1 1 1
1 3 1
1 1 1```

### 输出

```
81```

# 题解

## 作者：NewSjf (赞：15)

好像下面的题解都是双向边   
我是虚拟点做的,这样感觉也挺好理解的    
思路其实都差不多,实现上略微有点差别  
首先我们先看[P1361 小M的作物](https://www.luogu.org/problem/P1361)  
参考那道题的题解,可以抽象出这么一个模型
![](https://s2.ax1x.com/2019/11/11/MQxSTU.jpg)   
具体的解释可以参考那道题题解   
然后我们回到这道题,这道题和那道题的不同之处就在于那道题两个元素在同一个集合就会有附加权值,而这道题是两个元素不在同一个集合才会有负价权值,现在就看如何转换        
我用了一种十分傻瓜的方式   
首先我们考虑黑白染色    
![](http://img3.redocn.com/20120627/Redocn_2012062709270931.jpg.thumb.jpg)   
我们发现白色位置的附加权值取决于四个相邻黑色位置的选择,黑色亦然   
这里不用去交换源汇点
直接把其中一种颜色的A和B权值交换就行了   
这样两个位置本来要选择不一样才会有附加权值     
现在变成了两个位置集合相同才会有附加权值   
于是这道题被完美的转化成了P1361    
和那道题做法一模一样   
建虚拟点,跑dinic,得答案    
```cpp
#include<iostream>
#include<algorithm>
#include<cstring>
#include<queue>
#define INF 252645135
#define MAXN 1001
using namespace std;
struct side{int from,to,next,w;}edge[MAXN*MAXN];
int cur[MAXN*MAXN],head[MAXN*MAXN],depth[MAXN*MAXN],N,M,n,s,t,len=-1;
int A[MAXN][MAXN],B[MAXN][MAXN],C[MAXN][MAXN];
int dx[]={0,0,1,-1},dy[]={1,-1,0,0},sum;
void __add_edge(int x,int y,int d){edge[++len]=(side){x,y,head[x],d};head[x]=len;}
void add_edge(int x,int y,int d)
{
	__add_edge(x,y,d);
	__add_edge(y,x,0);
}
int bfs()
{
	queue<int>q;
	for(int i=0;i<=n;i++)depth[i]=0,cur[i]=head[i];
	q.push(s);depth[s]=1;
	while(q.size())
	{
		int now=q.front();q.pop();
		for(int k=head[now];k!=-1;k=edge[k].next)
			if(edge[k].w>0&&depth[edge[k].to]==0)
				depth[edge[k].to]=depth[now]+1,
				q.push(edge[k].to);
	} 
	return depth[t]!=0;
}
int dfs(int now,int flow)
{
	if(now==t)return flow;
	for(int&k=cur[now];k!=-1;k=edge[k].next)
		if(edge[k].w>0&&depth[edge[k].to]==depth[now]+1)
		{
			int minflow=dfs(edge[k].to,min(flow,edge[k].w));
			if(minflow>0)
			{
				edge[k].w-=minflow;
				edge[k^1].w+=minflow;
				return minflow;
			}

		}
	return 0;
}
int dinic(int ans=0)
{
	while(bfs())
		while(int flow=dfs(s,INF))ans+=flow;
	return ans;
}
int point(int x,int y)
{
	return (x-1)*M+y;
}
int main()
{
	memset(head,-1,sizeof(head));
	cin>>N>>M;
	n=N*M;
	s=++n;
	t=++n;
	for(int i=1;i<=N;i++)
		for(int j=1;j<=M;j++)
			cin>>A[i][j],sum+=A[i][j];
	for(int i=1;i<=N;i++)
		for(int j=1;j<=M;j++)
			cin>>B[i][j],sum+=B[i][j];
	for(int i=1;i<=N;i++)
		for(int j=1;j<=M;j++)
			cin>>C[i][j];
	for(int i=1;i<=N;i++)
		for(int j=1;j<=M;j++)
			if((i+j)%2==1)swap(A[i][j],B[i][j]); //翻转 
	for(int i=1;i<=N;i++)
		for(int j=1;j<=M;j++)
		{
			add_edge(s,point(i,j),A[i][j]);
			add_edge(point(i,j),t,B[i][j]);
		}
	for(int i=1;i<=N;i++)
		for(int j=1;j<=M;j++)
		{
			for(int k=0;k<4;k++)
			{
				int nx=i+dx[k],ny=j+dy[k];
				if(0<nx&&nx<=N&&0<ny&&ny<=M)
				{
					int x=++n;
					int y=++n;
					sum+=2*C[i][j];
					add_edge(s,x,C[i][j]);
					add_edge(x,point(i,j),INF);
					add_edge(x,point(nx,ny),INF);
					add_edge(y,t,C[i][j]);
					add_edge(point(i,j),y,INF);
					add_edge(point(nx,ny),y,INF);
				}
			}
		}
	cout<<sum-dinic();
}
```

希望大家有所收获

---

## 作者：Tweetuzki (赞：12)

这题是一个很明显的最小割建图，同样黑白染色的思路也很清晰。但是看了题解以后，发现都有很重要的一点没有说清楚：**为什么建图时对于每个区域不需要拆点**。

因此在这篇题解里，我想介绍：

1. 为什么这题不用拆点是对的。
2. 如果一定要拆点的话，应当如何建图。

通常情况下，不拆点会使得构造的这张图存在一个很重要的性质，就是点之间关系的传递性。换句话说，就是如果在这张图上存在一条 $A \to B$ 的路径和一条 $B \to C$ 的路径，那么就存在一条 $A \to C$ 的路径。这就意味着，如果你想要找出一种割使得 $A, C$ 两点不连通，那么一定要使得 $A, B$ 不连通或 $B, C$ 不联通。

在许多题上，由于拆点会对连通性产生这种影响，因此不拆点会导致答案错误。这是一个例子：[「牛客练习赛 43 E」Tachibana Kanade And Dream City](https://ac.nowcoder.com/acm/contest/548/E)。

然而在这道题上，我们不拆点，利用的恰好是这样的一个传递性。

如果忽略这样的传递性会有什么后果呢？你会得到 55 分的好成绩。为什么呢？这里有一组简单的小数据。

**Input**

```plain
1 3
1000 1 1
1 1 1000
1000 1 1000
```

**Answer**

```plain
3004
```

**Output**

```plain
4002
```

为什么会有这样的输出呢？原因是我们忽略了本题隐含的一些性质——如果 $A$ 有一条边连向 $B$，$B$ 有一条边连向 $C$，那么 $A$ 和 $C$ 的选择应该是相同的。而在不考虑连通性的建图中，最优的方案会将 $S \to B_{in}$，$B_{out} \to T$ 这两条全部割掉，具体来说就是 $B$ 号区域既不选商业区也不选工业区，而这是不合题意的。

这种问题恰恰可以用拆点所带来的传递性解决，所以不拆点是对的。

---

那如果一定要拆点该怎么做呢？

我们注意到这样建图唯一的问题就是我们有可能会出现都不选的不合题意的情况。

那我们就建一张图，使得每个地区都被强制选。

建图的方法很简单。参考[「雅礼集训 2017 Day8」价](https://loj.ac/problem/6045) 的思路，我们给 $S$ 到每个点入点的边加上一个大数，同样从每个点的出点向 $T$ 的边也加上一个相同的大数，在每个点的入点到出点连 $+ \infty$ 的边。那么，最终的合法方案一定会割掉恰好 $n$ 条这样的边，将最小割跑出的值减去 $n \times$ 这个大数就是需要的答案了。

这样建出来的图是分层图，Dinic 的效率应该会非常高，理论复杂度大约是 $\mathcal{O}(n^2m^2)$，最坏情况下仍能通过本题。而没有拆点的图不是分层图，理论复杂度就变成了 $\mathcal{O}(n^3m^3)$，效率可能较为低下——这很大一部分是因为，没有拆点的图保留了点之间信息的传递性，相当于在拆点的图中在入点和出点间两两连接了一条边，也就是有 $n^2m^2$ 条边。从这里看来，不拆点的建图方法实质是一种很暴力的建图方法。但由于实际运行时 Dinic 的复杂度很难达到上界，因此不拆点是可以过的（但我总感觉不拆点的方法可以通过一些数据的构造让它 T 掉）。

拆点建图的代码：

```cpp
#include <algorithm>
#include <cstdio>
#include <cstring>

const int MaxN = 100 + 5, MaxM = 100 + 5;
const int MaxV = 20000 + 5, MaxE = 500000 + 5;
const int INF = 0x7F7F7F7F;
const int dx[4] = {0, 0, 1, -1}, dy[4] = {1, -1, 0, 0};

struct Graph {
  int cnte;
  int Head[MaxV], Next[MaxE], To[MaxE], Cap[MaxE];

  Graph() {
    cnte = 1;
  }

  inline void addEdge(int from, int to, int cap) {
    cnte++; To[cnte] = to; Cap[cnte] = cap;
    Next[cnte] = Head[from]; Head[from] = cnte;
  }

  inline void add_edge(int from, int to, int cap) {
    addEdge(from, to, cap);
    addEdge(to, from, 0);
  }
} G;

int N, M, V;
int A[MaxN][MaxM], B[MaxN][MaxM], C[MaxN][MaxM];

namespace Dinic {
  int level[MaxV], iter[MaxV];
  int que[MaxV], head, tail;

  void bfs(int s) {
    memset(level, -1, sizeof level);
    head = 1, tail = 0;
    level[s] = 0;
    que[++tail] = s;
    while (head <= tail) {
      int u = que[head++];
      for (int i = G.Head[u]; i; i = G.Next[i]) {
        int v = G.To[i];
        if (G.Cap[i] > 0 && level[v] < 0) {
          level[v] = level[u] + 1;
          que[++tail] = v;
        }
      }
    }
  }

  int dfs(int u, int t, int f) {
    if (u == t) return f;
    for (int &i = iter[u]; i; i = G.Next[i]) {
      int v = G.To[i];
      if (G.Cap[i] > 0 && level[v] > level[u]) {
        int d = dfs(v, t, std::min(f, G.Cap[i]));
        if (d > 0) {
          G.Cap[i] -= d;
          G.Cap[i ^ 1] += d;
          return d;
        }
      }
    }
    return 0;
  }

  int max_flow(int s, int t) {
    int flow = 0;
    for (;;) {
      bfs(s);
      if (level[t] < 0) return flow;
      for (int i = s; i <= t; ++i) iter[i] = G.Head[i];
      for (;;) {
        int f = dfs(s, t, INF);
        if (f == 0) break;
        flow += f;
      }
    }
  }
}

void init() {
  scanf("%d %d", &N, &M); V = N * M;
  for (int i = 1; i <= N; ++i) for (int j = 1; j <= M; ++j)
    scanf("%d", &A[i][j]);
  for (int i = 1; i <= N; ++i) for (int j = 1; j <= M; ++j)
    scanf("%d", &B[i][j]);
  for (int i = 1; i <= N; ++i) for (int j = 1; j <= M; ++j)
    scanf("%d", &C[i][j]);
}

inline int getid(int x, int y) {
  return (x - 1) * M + y;
}

void solve() {
  int S = 0, T = V * 2 + 1;
  int ans = 0;
  for (int i = 1; i <= N; ++i) for (int j = 1; j <= M; ++j) {
    ans += A[i][j] + B[i][j] + 10000;
    if ((i + j) % 2 != 0) {
      G.add_edge(S, getid(i, j), A[i][j] + 10000);
      G.add_edge(getid(i, j) + V, T, B[i][j] + 10000);
      G.add_edge(getid(i, j), getid(i, j) + V, INF);

      for (int d = 0; d < 4; ++d) {
        int x = i + dx[d], y = j + dy[d];
        if (x < 1 || x > N || y < 1 || y > M) continue;
        ans += C[i][j];
        G.add_edge(getid(i, j), getid(x, y), C[i][j] + C[x][y]);
      }
    } else {
      G.add_edge(S, getid(i, j) + V, B[i][j] + 10000);
      G.add_edge(getid(i, j), T, A[i][j] + 10000);
      G.add_edge(getid(i, j) + V, getid(i, j), INF);

      for (int d = 0; d < 4; ++d) {
        int x = i + dx[d], y = j + dy[d];
        if (x < 1 || x > N || y < 1 || y > M) continue;
        ans += C[i][j];
        G.add_edge(getid(i, j) + V, getid(x, y) + V, C[i][j] + C[x][y]);
      }
    }
  }
  printf("%d\n", ans - Dinic::max_flow(S, T));
}

int main() {
  init();
  solve();
  return 0;
}
```

---

## 作者：zhylj (赞：9)

为了更好的阅读体验, 你可以前往我的Blog查看这篇题解:
[https://www.cnblogs.com/zhylj/p/10352599.html](https://www.cnblogs.com/zhylj/p/10352599.html)

### 题目

最近房地产商 GDOI (Group of Dumbbells Or Idiots) 从 NOI (Nuts Old Idiots) 手中得到了一块开发土地。

据了解,这块土地是一块矩形的区域,可以纵横划分为 $N\times M$ 块小区域。GDOI 要求将这些区域分为商业区和工业区来开发。

根据不同的地形环境,每块小区域建造商业区和工业区能取得不同的经济价值。更具体点,对于第 $i$ 行第 $j$ 列的区域,建造商业区将得到 $A_{ij}$ 收益,建造工业区将得到 $B_{ij}$ 收益。

另外，不同的区域连在一起可以得到额外的收益,即如果区域$(I,j)$相邻(相邻是指两个格子有公共边)有 $K$ 块(显然 $K$ 不超过 $4$)类型不同于$(I,j)$的区域,则这块区域能增加 $k\times C_{ij}$ 收益。

经过 Tiger.S 教授的勘察,收益矩阵 $A,B,C$ 都已经知道了。你能帮 GDOI 求出一个收益最大的方案么?

### 分析

网络流是不可能网络流的, 这辈子都不可能网络流的.

我发现有 $2^{nm}$ 种解, 然而答案范围只有 $1000nm$, 说明有大量的重复解, 那还写正解?

这道题我用模拟退火, 随机的是一个矩阵代表每个地方是什么区域.

每次随机一个点做一些微小的变化就可以了.

(如果调参调不下去可以试试多退火几次, 跳出局部最优)

比如我是这样写的:

```c++
int ans = 0;
for(int i = 0; i < 42; i++)
    ans = std::max(SA(), ans);
printf("%d", ans);
```

### 代码

(不保证每时每刻你提交这份都能 AC)

```c++
#include <bits/stdc++.h>

const int kMaxSize = 105, mod = 1e9 + 7;
const double delta = 0.994, sup = 1e17, eps = 1e-17;

bool plan[kMaxSize][kMaxSize];
int n, m, a[kMaxSize][kMaxSize], b[kMaxSize][kMaxSize], c[kMaxSize][kMaxSize];

unsigned sed = time(NULL);
inline unsigned Rand() {
    sed = ((sed * 0x3abcd1ac + 0xabc12ab2) ^ (sed + 0x1230bace)) % mod;
    return sed;
}

int GetIncome() {
    int ans = 0;
    for(int i = 0; i < n; i++)
        for(int j = 0; j < m; j++) {
            if(plan[i][j]) ans += a[i][j];
            else ans += b[i][j];
            if(i - 1 >= 0 && plan[i - 1][j] != plan[i][j]) ans += c[i][j];
            if(j - 1 >= 0 && plan[i][j - 1] != plan[i][j]) ans += c[i][j];
            if(i + 1 < n && plan[i + 1][j] != plan[i][j]) ans += c[i][j];
            if(j + 1 < m && plan[i][j + 1] != plan[i][j]) ans += c[i][j];
        }
    return ans;
}

inline int change(int ans, int x, int y) {
    plan[x][y] ^= 1;
    ans += plan[x][y] ? a[x][y] - b[x][y] : b[x][y] - a[x][y];
    if(x - 1 >= 0) {
        ans += plan[x - 1][y] != plan[x][y] ?
            c[x][y] + c[x - 1][y] : -(c[x][y] + c[x - 1][y]);
    }
    if(y - 1 >= 0) {
        ans += plan[x][y - 1] != plan[x][y] ?
            c[x][y] + c[x][y - 1] : -(c[x][y] + c[x][y - 1]);
    }
    if(x + 1 < n) {
        ans += plan[x + 1][y] != plan[x][y] ?
            c[x][y] + c[x + 1][y] : -(c[x][y] + c[x + 1][y]);
    }
    if(y + 1 < m) {
        ans += plan[x][y + 1] != plan[x][y] ?
            c[x][y] + c[x][y + 1] : -(c[x][y] + c[x][y + 1]);
    }
    return ans;
}

int SA() {
    register int ans, old_ans, new_ans, cnt = 0;
    ans = old_ans = GetIncome();
    for(register double T = sup; T > eps; T *= delta) {
        int x = Rand() % n, y = Rand() % m;
        new_ans = change(old_ans, x, y);
        ans = new_ans > ans ? new_ans : ans;
        if(new_ans > old_ans ||
            Rand() <= exp((new_ans - old_ans) * 1.0 / T) * mod)
            old_ans = new_ans;
        else plan[x][y] ^= 1;
        cnt++;
    }
    return ans;
}

int main() {
    srand(time(NULL));
    scanf("%d%d", &n, &m);
    for(int i = 0; i < n; i++)
        for(int j = 0; j < m; j++)
            scanf("%d", &a[i][j]);
    for(int i = 0; i < n; i++)
        for(int j = 0; j < m; j++)
            scanf("%d", &b[i][j]);
    for(int i = 0; i < n; i++)
        for(int j = 0; j < m; j++)
            scanf("%d", &c[i][j]);
    for(int i = 0; i < n; i++)
    	for(int j = 0; j < m; j++)
    		plan[i][j] = a[i][j] > b[i][j];
    int ans = 0;
    for(int i = 0; i < 42; i++)
    	ans = std::max(SA(), ans);
    printf("%d", ans);
    return 0;
}
```

### 结语

不过, Luogu的数据貌似有点水, 这个代码在一些地方貌似过不了?

---

## 作者：MloVtry (赞：7)

先考虑近似问题，假设是相同会得到额外奖励呢？


这就是个简单的最小割问题了，可以先去看看P1646。


现在的问题是不同得到奖励，想想办法转化成相同的就好了。


注意到四联通，那么黑白点染色，交换掉一种点的A、B，此时不同就变成相同了，问题就与P1646相似了（转换后本题更加简单）


代码



```cpp
#define inf (1<<30)
#include<iostream>
#include<cstring>
#include<cstdio>
#define M 100010
#define N 10010
#include<queue>
using namespace std;
int head[N],to[M],Next[M],cup[M],e=1;
void buid(int u,int v,int c)
{
    Next[++e]=head[u];head[u]=e;to[e]=v;cup[e]=c;
    Next[++e]=head[v];head[v]=e;to[e]=u;cup[e]=0;
}
int s,t,n,m,ans;
int id(int x,int y)
{
    return x*m-m+y;
}
int use[N],itc[N];
int dx[4]={-1,0,1,0};
int dy[4]={0,1,0,-1};
int c[105][105];
queue<int> q;

bool bfs()
{
    memset(itc,0,sizeof(itc));
    itc[s]=1;q.push(s);
    while(!q.empty())
    {
        int now=q.front();q.pop();
        for(int i=head[now];i;i=Next[i])
        {
            if(!cup[i]) continue;
            int j=to[i];
            if(!itc[j]) itc[j]=itc[now]+1,q.push(j);
        }
    }
    return itc[t];
}
int doit(int now,int want)
{
    if(now==t||!want) return want;
    int get=0;
    for(int i=use[now];i;i=Next[i],use[now]=i)
    {
        int j=to[i];
        if(itc[j]!=itc[now]+1) continue;
        int f=doit(j,min(want,cup[i]));
        cup[i]-=f;cup[i^1]+=f;
        get+=f;want-=f;
        if(!want) return get;
    }
    return get;
}
void max_flow()
{
    while(bfs())
    {
        for(int i=s;i<=t;++i) use[i]=head[i];
        ans-=doit(s,inf);
    }
    printf("%d\n",ans);
}
int main()
{
    scanf("%d%d",&n,&m);
    t=id(n,m)+1;
    for(int i=1;i<=n;++i)
    for(int j=1;j<=m;++j)
    {
        int it;scanf("%d",&it);ans+=it;
        if((i+j)&1) buid(id(i,j),t,it);
        else buid(s,id(i,j),it);
    }
    for(int i=1;i<=n;++i)
    for(int j=1;j<=m;++j)
    {
        int it;scanf("%d",&it);ans+=it;
        if((i+j)&1) buid(s,id(i,j),it);
        else buid(id(i,j),t,it);
    }
    for(int i=1;i<=n;++i)
    for(int j=1;j<=m;++j) scanf("%d",&c[i][j]);
    for(int i=1;i<=n;++i)
    for(int j=1;j<=m;++j)
    {
        if((i+j)&1) continue;
        for(int k=0;k<4;++k)
        {
            int x=i+dx[k];
            int y=j+dy[k];
            if(x<1||x>n||y<1||y>m) continue;
            
            buid(id(i,j),id(x,y),c[i][j]+c[x][y]);
            buid(id(x,y),id(i,j),c[i][j]+c[x][y]);
            ans+=c[i][j]+c[x][y];
        }
    }
    max_flow();
    return 0;
}
```

---

## 作者：zac2010 (赞：3)

先看一道较为类似的题：[文理分科](https://www.luogu.com.cn/problem/P4313)。

在那道题里，我们的最小割模型中有以下几种边：

1. $S\to id(i,j)$，边权为 $art_{i,j}$

	其中，$id(i,j)$ 表示在第 $i$ 行第 $j$ 列的人。这条边保留表示在这个人选文科；割掉则是选理科。
    
2. $id(i,j)\to T$，边权为 $science_i$。

	这条边保留表示当前这个人选理科；反之选文科。

3. 对于一个人及其上下左右的组合 $k$，我们建立虚点 $num1_k,num2_k$

	1. $s\to num1_k$，边权为 $same_art$；以及 $num1_k\to id(i,j)$，边权为 $\text{INF}$（满足$\{i,j\}\in k$）。
    
	2. $num2_k\to t$，边权为 $same_art$；以及 $id(i,j)\to num2_k$，边权为 $\text{INF}$（满足$\{i,j\}\in k$）。
    
回归这道题。我们不妨把那个 $k\times C_{i,j}$ 拆成几个 $C_{i,j}$ 相加，之后就只要考虑一个位置与它某个相邻位置的独立贡献了。之后就是上述文理分可经典模型。

但是还有个不同点：这题要求两个位置不一样才有贡献——考虑对棋盘黑白染色，对于黑点，我们还是按照 $(S\to id(i,j),art_{i,j}),(id(i,j)\to T,science_{i,j})$ 的方式连边；对于白点，我们反一下，$(S\to id(i,j),science_{i,j}),(id(i,j)\to T,art_{i,j})$。问题得到解决。

```cpp
#include <bits/stdc++.h>
#define FL(i, a, b) for(int i = (a); i <= (b); i++)
#define FR(i, a, b) for(int i = (a); i >= (b); i--)
using namespace std;
typedef long long ll;
const int S = 110, N = 100010, M = 260010;
const int f[4][2] = {0, 1, 1, 0, 0, -1, -1, 0};
const ll INF = 1e18;
struct E{int v; ll w, nxt;} e[M << 1];
int n, m, s, t, tot, tote; ll ans;
int a[S][S], b[S][S], head[N], now[N], dep[N];
void init(){
    tote = 0;
    memset(head, -1, sizeof(head));
}
void Adde(int u, int v, ll w){
    e[tote] = {v, w, head[u]}, head[u] = tote++;
}
void Add(int u, int v, ll w){
    Adde(u, v, w), Adde(v, u, 0);
}
int id(int x, int y){
    return (x - 1) * m + y;
}
int bfs(){
    queue<int> q; q.push(s);
    memset(dep, 0, sizeof(dep)), dep[s] = 1;
    while(!q.empty()){
        int u = q.front(); q.pop();
        for(int i = now[u] = head[u]; ~i; i = e[i].nxt)
            if(e[i].w && !dep[e[i].v])
				q.push(e[i].v), dep[e[i].v] = dep[u] + 1;
    }
    return dep[t];
}
ll dfs(int u, ll in){
    if(u == t) return in; ll out = 0;
    for(int i = now[u]; ~i && in; i = e[i].nxt){
        int v = e[i].v; ll w = e[i].w; now[u] = i;
        if(dep[v] == dep[u] + 1 && w){
            ll flow = dfs(v, min(in, (ll)w));
            in -= flow, out += flow;
            e[i].w -= flow, e[i ^ 1].w += flow;
        }
    }
    if(!out) dep[u] = 0; return out;
}
ll dinic(){
    ll ret = 0;
    while(bfs()) ret += dfs(s, INF);
    return ret;
}
int main(){
    scanf("%d%d", &n, &m);
	init(), s = 0, t = ++(tot = n * m);
    FL(i, 1, n) FL(j, 1, m){
        scanf("%d", &a[i][j]), ans += a[i][j];
        if((i + j) & 1) Add(s, id(i, j), a[i][j]);
        else Add(id(i, j), t, a[i][j]);
    }
    FL(i, 1, n) FL(j, 1, m){
        scanf("%d", &b[i][j]), ans += b[i][j];
        if((i + j) & 1) Add(id(i, j), t, b[i][j]);
        else Add(s, id(i, j), b[i][j]);
    }
    FL(i, 1, n) FL(j, 1, m){
        int val; scanf("%d", &val);
        FL(k, 0, 3){
            int x = i + f[k][0], y = j + f[k][1];
            if(x < 1 || x > n || y < 1 || y > m) continue;
            ans += val, Add(s, ++tot, val);
            Add(tot, id(i, j), INF), Add(tot, id(x, y), INF);
            ans += val, Add(++tot, t, val);
            Add(id(i, j), tot, INF), Add(id(x, y), tot, INF);
        }
    }
    printf("%lld\n", ans - dinic());
    return 0;
}
```

---

## 作者：Tobiichi_Origami (赞：2)

**题目描述**

有一个 $n\times m$ 的矩阵，对于每一个格子都有三个权值 $a_{ij},b_{i,j},c_{i,j}$，分别表示此地建造商业区的收益，建造工业区的收益和额外的收益。额外的收益是指对于 $(i,j)$，若在其周围四联通的格子中有 $k$ 个与其类型不同，则额外收益为 $k\times c_{i,j}$。请问最大收益为多少。

**解题思路**

首先，我们的理想情况是 $\forall (i,j),val=a_{i,j}+b_{i,j}$，但是这是不可能的，那我们按照贪心的思想，就可以减去其中的最小值。

同样的，我们可以运用正难则反的思想，答案为总价值 $-$ 最小花费。显然，答案为：

$$\displaystyle\sum_{i=1}^{n}\sum_{j=1}^{m}(a_{i,j}+b_{i,j}-\min(a_{i,j}-b_{i,j})+k\times c_{i,j})$$

这时，我们已经可以看出此题需要用最小割来解决了。

我们现在可以开始建模。考虑将矩形看作一个棋盘，有黑格和白格。

对于任意的黑格 $u$，连接两条边 $S\to u,u\to T$（你爱怎么设怎么设，反过来也不是不可以），白格则与其相反方向。

在考虑四联通的情况，我们可以按照总价值来建模，将 $u$ 向四联通的 $k$ 个点连接一条容量为 $c_{u}+c_{v}$ 的边。

看到这里绝对会有很多疑问，为什么要这么做呢？

我们从最小割的原理开始说起，最小割是要割掉容量尽可能小的边集使得整个流网络分为两个独立点集。

![](https://cdn.luogu.com.cn/upload/image_hosting/kfcsi9kr.png)

- 对于为什么要看成一个棋盘，如果我们不将它设为黑格白格两个方向的话，若要使割掉同侧的所有代表 $a_{i,j}$ 的边时，最小割则会成立。这是求出来的最小割仅有 $a_{i,j}$，根据题意，如果相同的话则没有额外的 $c_{i,j}$，但是跑出来的最小割却不包含 $c_{i,j}$，也就是把 $c_{i,j}$ 留在了答案当中，与提议相悖，所以不能。

	黑格和白格可以根据坐标的奇偶性来判断。

- 对于四联通的情况，考虑如果相邻格子选了同样的颜色，则双方在总价值中均会失去各自的 $c_{i,j}$，所以要是容量变为 $c_{u}+c_{v}$。

- 对于 $c_{i,j}$ 的限制保证，在理想情况下，对于一个四联通，它的最理想贡献则是 
  
  $$\displaystyle\sum_{u\in V} c_{i,j}+c_{i+\Delta,j+\Delta}$$

  但是回到第一条，若两个四联通不在相同类型集合中，则有额外加成，不用删去容量为 $c_{u}+c_{v}$ 的边；但是若在同一集合中，也就没有额外加成，并且 $s\to t$ 联通，若不删去则不符合题意，所以直接删去容量为 $c_{u}+c_{v}$ 的边

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e4+10,M=1e5+10,K=101;
const int Inf=0x3f3f3f3f;
struct edge{
	int to,next,w;
}ed[M<<1];
int he[N],tot=-1;
int d[N],cur[N];
int a[K][K],b[K][K],c[K][K];
int dx[]={0,0,-1,1},dy[]={-1,1,0,0};
int n,m,s,t,sum;
void insert(int u,int v,int w)
{
	tot++;
	ed[tot].to=v;
	ed[tot].w=w;
	ed[tot].next=he[u];
	he[u]=tot;
}
int id(int x,int y){
	return (x-1)*m+y;
}
bool bfs()
{
    memset(d,-1,sizeof(d));
    queue<int>q;
    d[s]=0;cur[s]=he[s];
    q.push(s);
    while(!q.empty())
    {
        int u=q.front();
        q.pop();
        for(int i=he[u];i!=-1;i=ed[i].next)
        {
            int v=ed[i].to;
            if(d[v]==-1&&ed[i].w)
            {
                d[v]=d[u]+1;
                cur[v]=he[v];
                if(v==t) return 1;
                q.push(v);
            }
        }
    }
    return 0;
}
int dfs(int u,int lim)
{
    if(u==t) return lim;
    int flow=0;
    for(int i=cur[u];i!=-1&&flow<lim;i=ed[i].next)
    {
        int v=ed[i].to;
        cur[u]=i;
        if(d[v]==d[u]+1&&ed[i].w)
        {
            int t=dfs(v,min(ed[i].w,lim-flow));
            if(!t) d[v]=-1;
            ed[i].w-=t;ed[i^1].w+=t;
            flow+=t;
        }
    }
    return flow;
}
int dinic()
{
    int res=0,flow;
    while(bfs())
        while(flow=dfs(s,Inf))
            res+=flow;
    return res;
}
int main()
{
	memset(he,-1,sizeof(he));
	scanf("%d %d",&n,&m);
	s=0;t=n*m+1;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			scanf("%d",&a[i][j]);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			scanf("%d",&b[i][j]);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			scanf("%d",&c[i][j]);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
		{
			if((i+j)&1)
			{
				insert(s,id(i,j),a[i][j]);insert(id(i,j),s,0);
				insert(id(i,j),t,b[i][j]);insert(t,id(i,j),0);	
			}
			else
			{
				insert(s,id(i,j),b[i][j]);insert(id(i,j),s,0);
				insert(id(i,j),t,a[i][j]);insert(t,id(i,j),0);	
			}
			sum+=a[i][j]+b[i][j];
			for(int k=0;k<4;k++)
			{
				int x=dx[k]+i,y=dy[k]+j;
				if(x>0&&y>0&&x<=n&&y<=m)
				{
					sum+=c[i][j];
					insert(id(i,j),id(x,y),c[i][j]+c[x][y]);
					insert(id(x,y),id(i,j),0);
				}
			}
		}	
	printf("%d",sum-dinic());
	return 0;
}
```


---

## 作者：cryozwq (赞：2)

UPD：把标题行删了，望管理员重新审核。

这篇题解主要是对建模的详细说明（？

众所周知，最小割求的是最小值，所以我们肯定要转化为理论最大值-实际最小值，先考虑一个 naive 的模型：

![](https://cdn.luogu.com.cn/upload/image_hosting/lessm4jp.png)

这种情况下，我们理想状态下 $(i,j)$ 的贡献应该是 $a_{i,j}+b_{i,j}$，很不幸，$(i,j)$ 只能取一种状态，也就是实际上它的贡献是 $a_{i,j}+b_{i,j}-\min(a_{i,j},b_{i,j})$。

这个时候明眼人已经能看出最小割了，回想一下最小割解决什么问题？集合划分的问题，建一个流网络，$s$ 为源点，$t$ 为汇点，每个节点 $(i,j)$ 连向 $s$，$t$，容量分别为 $a_{i,j},b_{i,j}$ ，一个 $s-t$ 割的实际意义就是与 $s$ 在同一子集的节点 $(i,j)$ 取 $a_{i,j}$，与 $t$ 在同一子集的节点 $(i,j)$ 取 $b_{i,j}$。最小割割掉的边，实际上就是每个节点舍弃的状态（舍弃最小，答案就最大）。

回到这个问题，看到网格图考虑黑白染色，对于黑点就按上述方式建模，对于白点就翻转一下源点和汇点就好。

但是，现在我们还是什么都没做，因为这个模型 P 用没有。真正让这个模型有用的就是 $c_{i,j}$ 的限制。

对于每一个黑点，由于我们的染色规则，必然它四个相邻的点是白点，考虑对于每个黑点计算贡献，显然这个东西可以拆开计算：

![](https://cdn.luogu.com.cn/upload/image_hosting/fgkd1f23.png)

图很丑，见谅。

于是乎，一个黑点和四个白点理论最大贡献就是：

$\sum c_{i,j}+c_{i+dx,i+dy}(dx\in[-1,1],dy\in[-1,1] )$

显然理论上限显然达不到，于是我们把刚刚的模型从垃圾桶捡回来（注意，这里是只有两个点的简单情况）：

![](https://cdn.luogu.com.cn/upload/image_hosting/jronrdg1.png)

注意看中间是双向边。

问题解决了！

为什么呢？根据题目定义只有当两个相邻的点所取状态不同才会产生 $c$ 的贡献，此时也就是这两个点归属于同一集合（因为不同颜色的汇点源点正好相反），不用删去 $c_{i1,j1}+c_{i2,j2}$ 这条边，而如果两个点状态相同，它们会归属于不同集合，这样的情况下由于两者联通，$s,t$ 必然联通，不符合流网络中割的定义，就一定会删除 $c_{i1,j1}+c_{i2,j2}$ 这条边，也符合题意，所以跑个最大流求最小割就好了。

---

## 作者：吾王美如画 (赞：2)

# 唔姆
正如各位大佬所说，这题和[P1646](https://www.luogu.org/problemnew/show/P1646)很像，但我觉得真正想通了，这题比P1646容易鸭
(~~我甚至有了抄我以前写的P1646题解的想法了~~

------------
- 首先，和P1646一样，我们把每个点从源点连一条容量商业区的收益的边，向汇点连一条容量为工业区的边。
- 接着，我们在把相邻的点连起来时，我们发现，因为题目要求的是不相同才会有额外收益，而直接连边就不合理了
- 然后呢，我们又发现，所谓相邻的就是上下左右四个点，所以可以像棋盘那样以行列奇偶性染个色，把一种颜色给倒过来，也就是之前连汇，现在就连源，之前连源，现在就连汇
- 记得是双向边哦（虽然我就直接link两次）
- 最后直接把总收益-最小割就OK了

（~~一点都没P1646愉♂悦~~）
```cpp
// luogu-judger-enable-o2
#include<cstdio>
#include<iostream>
#include<cstring>
#include<queue>
#define MAXN 100050
#define MAXM 150005
using namespace std;
int head[MAXN],next[MAXM*2],to[MAXM*2],w[MAXM*2];
int n,m,S,T;
int cnt=-1;
int deep[MAXN];
void link(int a,int b,int c){
     cnt++;
     w[cnt]=c;
     next[cnt]=head[a];
     to[cnt]=b;
     head[a]=cnt;
     cnt++;
     w[cnt]=0;
     next[cnt]=head[b];
     to[cnt]=a;
     head[b]=cnt;
}
bool bfs(){
     memset(deep,0,sizeof(deep));
     queue<int> q;
     while(!q.empty())q.pop();
     q.push(S);
     deep[S]=1;
     while(!q.empty()){
                       int now=q.front();
                       q.pop();
                       for(int i=head[now];i!=-1;i=next[i]){
                               if (w[i]&&!deep[to[i]]){
                                                       deep[to[i]]=deep[now]+1;
                                                       q.push(to[i]);
                               }
                       }
     }
     if (deep[T])return 1;else return 0;
}
int dinic(int now,int last){
    if (now==T||!last)return last;
    int ret=0;
    for(int i=head[now];i!=-1;i=next[i]){
            if(deep[to[i]]-1==deep[now]&&w[i]){
                                               int zgl=dinic(to[i],min(w[i],last-ret));
                                               if (zgl){
                                                        w[i]-=zgl;
                                                        w[i^1]+=zgl;     
                                                        ret+=zgl;
                                               }
            }
    }
    if (!ret)deep[now]=-1;
    return ret;
}
int num(int a,int b){
    return m*(a-1)+b;
}
int c[200][200];
int main(){
    cin>>n>>m;
    S=0;T=MAXN-1;
    int a;
    memset(head,-1,sizeof(head));
    long long sum=0;
    for(int i=1;i<=n;i++){
            for(int j=1;j<=m;j++){
                    scanf("%d",&a);
                    if ((i+j)&1)link(S,num(i,j),a);
                    else link(num(i,j),T,a);
                    sum+=a;
            }
    }
    for(int i=1;i<=n;i++){
            for(int j=1;j<=m;j++){
                    scanf("%d",&a);
                    if ((i+j)&1)link(num(i,j),T,a);
                    else link(S,num(i,j),a);
                    sum+=a;
            }
    }
    for(int i=1;i<=n;i++)
            for(int j=1;j<=m;j++)
                    scanf("%d",&c[i][j]);
    int tx[]={0,-1,0,1},ty[]={1,0,-1,0};
    for(int i=1;i<=n;i++){
            for(int j=1;j<=m;j++){
                    for(int k=0;k<4;k++){
                            int xx=i+tx[k],yy=j+ty[k];
                            if (xx<=0||xx>n)continue;
                            if (yy<=0||yy>m)continue;
                            link(num(i,j),num(xx,yy),c[i][j]+c[xx][yy]);
                            sum+=c[i][j];
                    }
            }
    }
    long long ans=0;
    while(bfs())
                 ans+=dinic(S,9999999);
    cout<<sum-ans;
    return 0;
}

```


---

## 作者：FutaRimeWoawaSete (赞：2)

这道题说难也不难吧。    

讲个笑话，刚开始建图的时候思路是对的，结果图画错了又去推了一些其他的图浪费了一个小时……     

首先对于这种矩阵里面有关系绑定并且是求最大/最小值，我们可以尝试网络流中的最小割。     

而我们仔细观察又发现，这个图的关系绑定形式也很特殊，即一个格子只与上下左右格子有关。    

对于这种图的分法有个结论：横纵坐标之和为奇数的点站成一类，偶数的点站成另一类，其实也就是站成一类的点都不是互相的上下左右格子，所有互相之间没有关系，这样处理后做起来就方便多了。     

先简化条件，只想第一个条件。考虑现在只能选择 $A$ 区和 $B$ 区中的一个，那么$S$ 向每个第一类点连 $A$ 区的收入，每个第一类点向 $T$ 连 $B$ 区的收入，第二类点反着操作，这样就保证割其中一条边就可以决定它是 $A$ 区还是 $B$ 区。    

接着我们要加条件，也就是 $C$ 该怎么办，那么我们想，如果此时此刻同时在一个区，那么我们就要舍掉我们中间的 $C$ 边，那么我们就直接在两个相邻的格子中间连 $C$ 边即可。因为此时你选在一个区，那么它们肯定是走到不同的点集去，所以就需要把中间的边扔掉才行。其实就是把我们的逻辑转化成了图。     

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<queue>
using namespace std;
const int Len = 100 * 100 * 5 + 10,Inf = 1e9;
int n,m,dep[Len],S,T,cur[Len],a[105][105],head[Len],cnt = 1,ans,sum;
struct node
{
	int next,to,w;
}edge[Len << 1];
void add(int from,int to,int w)
{
	edge[++ cnt].to = to;
	edge[cnt].w = w;
	edge[cnt].next = head[from];
	head[from] = cnt;
}
int BFS()
{
	queue<int> q;
	memset(dep , 0 , sizeof dep);
	q.push(S);dep[S] = 1;cur[S] = head[S];
	while(!q.empty())
	{
		int p = q.front() ; q.pop();
		for(int e = head[p] ; e ; e = edge[e].next)
		{
			int to = edge[e].to;
			if(!dep[to] && edge[e].w)
			{
				dep[to] = dep[p] + 1;
				cur[to] = head[to];
				if(to == T) return dep[T];
				q.push(to);
			}
		}
	}
	return 0;
}
int dfs(int u,int In)
{
	if(u == T) return In;
	int Out = 0;
	for(int e = cur[u] ; e && In > 0 ; e = edge[e].next)
	{
		cur[u] = e;
		int to = edge[e].to;
		if(edge[e].w && dep[to] == dep[u] + 1)
		{
			int res = dfs(to , min(In , edge[e].w));
			In -= res;
			Out += res;
			edge[e].w -= res;
			edge[e ^ 1].w += res;
		}
	}
	return (!Out) ? dep[u] = 0 : Out;
}
int Clone(int x,int y){return (x - 1) * m + y;}
int dx[8] = {0 , -1 , 0 , 0 , 1};
int dy[8] = {0 , 0 , -1 , 1 , 0};
bool judge(int x,int y){if(x < 1 || x > n || y < 1 || y > m) return false;return true;}
int main()
{
	scanf("%d %d",&n,&m);
	S = 0 , T = n * m + 1;
	for(int i = 1 ; i <= n ; i ++)
		for(int j = 1 ; j <= m ; j ++) scanf("%d",&a[i][j]);
	for(int i = 1 ; i <= n ; i ++)
		for(int j = 1 ; j <= m ; j ++)
		{
			if(a[i][j] == 1) add(S , Clone(i , j) , Inf) , add(Clone(i , j) , S , 0);
			else if(a[i][j] == 2) add(Clone(i , j) , T , Inf) , add(T , Clone(i , j) , 0);
			for(int k = 1 ; k <= 4 ; k ++)
			{
				int tx = i + dx[k] , ty = j + dy[k];
				if(!judge(tx , ty)) continue;
				add(Clone(i , j) , Clone(tx , ty) , 1) , add(Clone(tx ,  ty) , Clone(i , j) , 1);
			}
		}
	while(BFS()) ans += dfs(S , Inf);
	printf("%d\n",ans / 2);
	return 0;
}
```

---

## 作者：happybob (赞：1)

先考虑对图黑白染色，并且设 $S$ 和 $T$ 分别为源点和汇点。容易发现，四联通的两个点，肯定是一个黑一个白。

我们对于所有黑点 $(i,j)$，我们令 $u=(i-1) \times m + j$，从 $S$ 到 $u$ 连一条容量为 $a_{i,j}$ 的边，从 $u$ 到 $T$ 连一条容量为 $b_{i,j}$ 的边。

对于白点，我们从 $S$ 到 $u$ 连一条容量为 $b_{i,j}$ 的边，从 $u$ 到 $T$ 连一条容量为 $a_{i,j}$ 的边。

这样，在最小割中，割去一条边，相当于选择了 $u$ 的类型。

接着考虑如何处理四联通，对于两个点 $u,v$，其中 $u,v$ 四联通，不妨假设 $u$ 是黑点，如果 $u$ 选了商业区，那么相当于选了 $S \rightarrow u$ 的边，如果 $v$ 也是商业区，那么就是 $u \rightarrow T$ 的边，我们加一条 $u \rightarrow v$ 的边，权值为 $c_u + c_v$，那么如果 $u$ 和 $v$ 类型相同，这条边就要割掉，反之，不同，这条边就可以保留。

接着求最小割即可。

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <cstring>
#include <string>
#include <queue>
#include <climits>
using namespace std;

#define int long long

const int N = 2e6 + 5, M = 105;

int e[N], h[N], ne[N], c[N], idx;
int n, m, a[M][M], b[M][M], C[M][M];

#define get(i, j) (((i) - 1) * m + (j))
int S, T;

void add(int u, int v, int w)
{
	e[idx] = v, ne[idx] = h[u], c[idx] = w, h[u] = idx++;
}

void add_flow(int u, int v, int w)
{
	add(u, v, w);
	add(v, u, 0LL);
}

int dx[] = { 0, 0, -1, 1 };
int dy[] = { -1, 1, 0, 0 };

int d[N], cur[N];

bool bfs()
{
	queue<int> q;
	for (int i = 0; i <= T; i++) d[i] = -1;
	q.push(S);
	d[S] = 0;
	cur[S] = h[S];
	while (q.size())
	{
		int u = q.front();
		q.pop();
		for (int i = h[u]; ~i; i = ne[i])
		{
			int j = e[i];
			if (c[i] > 0 && d[j] == -1)
			{
				d[j] = d[u] + 1;
				cur[j] = h[j];
				if (j == T) return 1;
				q.push(j);
			}
		}
	}
	return 0;
}

int dfs(int u, int lim)
{
	if (u == T) return lim;
	int sum = 0LL;
	for (int i = cur[u]; ~i && sum < lim; i = ne[i])
	{
		cur[u] = i;
		int j = e[i];
		if (d[j] == d[u] + 1 && c[i] > 0)
		{
			int k = dfs(j, min(c[i], lim - sum));
			if (k == 0LL) d[j] = -1;
			else
			{
				sum += k;
				c[i] -= k;
				c[i ^ 1LL] += k;
			}
		}
	}
	return sum;
}

int dinic()
{
	int ans = 0;
	while (bfs())
	{
		int k;
		while (k = dfs(S, INT_MAX)) ans += k;
	}
	return ans;
}

signed main()
{
	long long ans = 0LL;
	memset(h, -1, sizeof h);
	scanf("%lld%lld", &n, &m);
	S = 0LL, T = n * m + 1LL;
	for (int i = 1; i <= n; i++)
	{
		for (int j = 1; j <= m; j++)
		{
			scanf("%lld", &a[i][j]);
			ans += a[i][j];
		}
	}
	for (int i = 1; i <= n; i++)
	{
		for (int j = 1; j <= m; j++)
		{
			scanf("%lld", &b[i][j]);
			ans += b[i][j];
		}
	}
	for (int i = 1; i <= n; i++)
	{
		for (int j = 1; j <= m; j++)
		{
			scanf("%lld", &C[i][j]);
		}
	}
	for (int i = 1; i <= n; i++)
	{
		for (int j = 1; j <= m; j++)
		{
			int p = get(i, j);
			if ((i + j) & 1LL)
			{
				add_flow(S, p, a[i][j]);
				add_flow(p, T, b[i][j]);
			}
			else
			{
				add_flow(S, p, b[i][j]);
				add_flow(p, T, a[i][j]);
			}
		}
	}
	for (int i = 1; i <= n; i++)
	{
		for (int j = 1; j <= m; j++)
		{
			int u = get(i, j);
			for (int k = 0; k < 4; k++)
			{
				int nx = i + dx[k], ny = j + dy[k];
				if (nx >= 1 && nx <= n && ny >= 1 && ny <= m)
				{
					ans += C[i][j];
					int v = get(nx, ny);
					add_flow(u, v, C[i][j] + C[nx][ny]);
					//add_flow(v, u, C[i][j] + C[nx][ny]);
				}
			}
		}
	}
	printf("%lld\n", ans - dinic());
	return 0;
}
```


---

## 作者：ysy20021208 (赞：1)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**分析与讲解：**对于整个图我们进行黑白染色，对于黑色的点，我们把其和$S$相连，边权为当前点开发成为商业区的收益，和$T$相连，边权为当前点开发成为工业区的收益，反之我们和$S$相连，边权为当前点开发成为工业区的收益，和$T$相连，边权为当前点开发成为商业区的收益。因为我们将其进行黑白染色之后翻转源汇，所以两个相邻的土地若开发成为不同的类型会在同一个集合，这样我们就能在相邻的两个点之间进行连线，因为这两个点如果不同会分别贡献两个值，所以这两个点之间的边为双向边，边权为这两个值相加。

```c++
// luogu-judger-enable-o2
#include <queue>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
#define N 200
#define inf 1000000000
int n,m,k,s,t,dis[N*N<<1],ans,c[N][N];
int cur[N*N<<1],head[N*N<<1],to[N*N<<5],nxt[N*N<<5],val[N*N<<5],idx=1;
void add(int a,int b,int c)
    {nxt[++idx]=head[a],to[idx]=b,val[idx]=c,head[a]=idx;}
bool bfs()
{
    memset(dis,-1,sizeof dis);
    queue <int> q;q.push(s),dis[s]=0;
    while(!q.empty())
    {
        int p=q.front();q.pop();
        if(p==t) return true;
        for(int i=head[p];i;i=nxt[i])
            if(val[i]>0&&dis[to[i]]==-1)
                dis[to[i]]=dis[p]+1,q.push(to[i]);
    } return false;
}
int dfs(int p,int flow)
{
    int now,temp=flow;
    if(p==t) return flow;
    for(int i=cur[p];i;i=nxt[i])
        if(val[i]>0&&dis[to[i]]==dis[p]+1)
        {
            now=dfs(to[i],min(val[i],temp));
            if(!now) dis[to[i]]=-1;
            temp-=now,val[i]-=now,val[i^1]+=now;
            if(val[i]) cur[p]=i;
            if(!temp) break;
        } return flow-temp;
}
void dinic() {while(bfs()) memcpy(cur,head,sizeof head),ans-=dfs(s,inf);}
int pla(int i,int j) {return (i-1)*m+j;}
int main()
{
    scanf("%d%d",&n,&m),s=n*m+1,t=n*m+2;
    for(int i=1;i<=n;i++) for(int j=1,a;j<=m;j++)
    {
        scanf("%d",&a),ans+=a;
        if((i+j)%2) add(s,pla(i,j),a),add(pla(i,j),s,0);
        else add(pla(i,j),t,a),add(t,pla(i,j),0);
    }
    for(int i=1;i<=n;i++) for(int j=1,a;j<=m;j++)
    {
        scanf("%d",&a),ans+=a;
        if((i+j)%2) add(pla(i,j),t,a),add(t,pla(i,j),0);
        else add(s,pla(i,j),a),add(pla(i,j),s,0);
    }
    for(int i=1;i<=n;i++) for(int j=1;j<=m;j++) scanf("%d",&c[i][j]);
    for(int i=1;i<=n;i++) for(int j=1;j<m;j++) ans+=c[i][j]+c[i][j+1],
        add(pla(i,j),pla(i,j+1),c[i][j]+c[i][j+1]),
        add(pla(i,j+1),pla(i,j),c[i][j]+c[i][j+1]);
    for(int i=1;i<n;i++) for(int j=1;j<=m;j++) ans+=c[i][j]+c[i+1][j],
        add(pla(i,j),pla(i+1,j),c[i][j]+c[i+1][j]),
        add(pla(i+1,j),pla(i,j),c[i][j]+c[i+1][j]);
    dinic(),printf("%d\n",ans);
}
```

---

## 作者：Eltaos_xingyu (赞：0)

## 题目描述

一个神奇的矩形，每个点可以选择 $1$ 和 $2$，如果选择 $1$，那么会得到 $A_{x,y}$ 的收益；如果选择 $2$，会得到 $B_{x,y}$ 的收益。对于一个点，如果四周点们有 $k$ 个和它自身选的不一样，那么额外得到 $k \times C_{x,y}$ 的收益，问最大收益是多少。

## 分析

非黑即白求最值，一眼最小割。

如何建图？

首先，忽略 $C_{x,y}$ 的贡献，我们很容易得到一个构图方式：

![](https://cdn.luogu.com.cn/upload/image_hosting/7gz7duea.png)

然后我们就在这个图上改进。

满足获取 $C_{i,j}$ 贡献的条件是什么？是**相邻两个点选取割掉的边在异侧**，也就是对于上面的图，要满足当割掉异侧边时，同时留下一条 $C_{i,j}$ 的边。

考虑先将上面的图的 $A_{i,j}$ 和 $B_{i,j}$ 部分反连，使得将问题转化成当割掉同侧边时，同时留下一条 $C_{i,j}$ 的边。

这样，我们可以构出一个这样的图：

![](https://cdn.luogu.com.cn/upload/image_hosting/39gft254.png)

如果割掉同侧边，那么可以留下一条 $C_{i,j}$ 的边。如果割掉异侧边，那么一条 $C_{i,j}$ 的边都不会留下。

现在我们来着重解决如何建边的问题，考虑每个点前后左右的 $4$ 个点的边都要反连，于是对原来的图进行黑白染色，染成白色正常连，染成黑色的直接反连即可。

最后跑一遍最小割，然后边权和减去最大流即为答案。

## 需要注意的点

1. $C_{i,j}$ 的边源点和汇点一定都要连！

2. 注意判断哪些 $C_{i,j}$ 边不能连（边界讨论）！

AC 代码（由于作者很懒，连边时多连了一些边）：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+5;//MAXn
const int M=1e5+5;//MAXm
int n;//点 
int m;//边 
int s;//源点序号 
int t;//汇点序号

struct node{
	int to;
	long long space;
	long long running;
	int next;
}; 
node get_(int ito,int inext,int ispace,int irunning){
	node temp;
	temp.to=ito;
	temp.next=inext;
	temp.running=irunning;
	temp.space=ispace;
	return temp;
}
node E[M];//G=(V,E)
int u;
int v;
int w;
int tot=0;
int head[N];
int dep[N];
int cur[N];

void addE(int ui,int vi,int wi){
	tot++;
	E[tot]=get_(vi,head[ui],wi,0);
	head[ui]=tot;
	tot++;
	E[tot]=get_(ui,head[vi],0,0);
	head[vi]=tot;
}

bool bfs(){
	for(int i=1;i<N;i++)dep[i]=-1;
	queue<int> q;
	q.push(s);
	dep[s]=0;
	cur[s]=head[s];
	while(!q.empty()){
		int x=q.front();
		q.pop();
		for(int i=head[x]; i!=-1;i=E[i].next){
			int nowto=E[i].to;
			if(dep[nowto]==-1&&E[i].running<E[i].space){
				dep[nowto]=dep[x]+1;
				cur[nowto]=head[nowto]; 
				q.push(nowto);
				if(nowto==t) return 1;
			} 
		} 
	} 
//	for(int i=1;i<=n;i++)cout<<dep[i]<<" ";
//	cout<<endl;
	return 0;
}

long long dfs(int now,int maxflow_p){
	if(now==t||maxflow_p==0)return maxflow_p;
	long long maxflow=0;
	for(int i=cur[now];~i&&maxflow<maxflow_p;i=E[i].next){
		cur[now]=i;
//		cout <<E[i].to << " " << dep[E[i].to] << " " << dep[now] << " " << E[i].space << " " << E[i].running << endl;
		if(dep[now]+1==dep[E[i].to]&&E[i].running<E[i].space){//分层流 
			long long flow=dfs(E[i].to,min(E[i].space-E[i].running,maxflow_p-maxflow));
			if(!flow)dep[E[i].to]=-1;
			else{
//				cout <<E[i].to << " " << dep[E[i].to] << " " << dep[now] << " " << E[i].space << " " << E[i].running <<" Cao"<< endl;
				E[i].running+=flow;
				E[i%2?i+1:i-1].running-=flow;
				maxflow+=flow;
			} 
		} 
	}
//	cout<<maxflow_p<<" "<<maxflow<<endl;
	return maxflow;
	
} 

long long dinic(){
	long long maxxx=0,tt;
	while(bfs()){//如果还有可行路径 
		while((tt=dfs(s,1<<30/*inf*/)))maxxx+=tt;
	}
	return maxxx;
}
int a[1001][1001],b[1001][1001],c[1001][1001],cnt=0,cntt=0;
int main(){
	long long sum=0;
	cin>>n>>m;
	s=1e5,t=s+1; 
	for(int i=1;i<N;i++)head[i]=-1;//初始化head数组，使其指向虚拟边 
	for(int i=1;i<=n;i++){
		cntt++;
		cnt=0;
		for(int j=1;j<=m;j++){
			cin>>a[i][j];
			sum+=a[i][j];
			cnt++;
			if((cnt+cntt)%2)addE(s,cntt*m-m+cnt,a[i][j]);
			else addE(cntt*m-m+cnt,t,a[i][j]);
		}
	}
	cntt=0;
	for(int i=1;i<=n;i++){
		cntt++;
		cnt=0;
		for(int j=1;j<=m;j++){
			cin>>b[i][j];
			sum+=b[i][j];
			cnt++;
			if((cnt+cntt)%2)addE(cntt*m-m+cnt,t,b[i][j]);
			else addE(s,cntt*m-m+cnt,b[i][j]);
		}
	}
	
	cntt=0;
	for(int i=1;i<=n;i++){
		cntt++;
		cnt=0;
		for(int j=1;j<=m;j++){
			cin>>c[i][j];
			cnt++; 
			if(i>1){
				addE(cntt*m-m+cnt,cntt*m-m+cnt+10001,1e9);
				addE(cntt*m-2*m+cnt,cntt*m-m+cnt+10001,1e9);
				addE(cntt*m-m+cnt+10001,t,c[i][j]);
				addE(cntt*m-m+cnt+50001,cntt*m-m+cnt,1e9);
				addE(cntt*m-m+cnt+50001,cntt*m-2*m+cnt,1e9);
				addE(s,cntt*m-m+cnt+50001,c[i][j]);
				sum+=2*c[i][j];
			}
			if(j>1){
				addE(cntt*m-m+cnt,cntt*m-m+cnt+20001,1e9);
				addE(cntt*m-m+cnt-1,cntt*m-m+cnt+20001,1e9);
				addE(cntt*m-m+cnt+20001,t,c[i][j]);
				addE(cntt*m-m+cnt+60001,cntt*m-m+cnt,1e9);
				addE(cntt*m-m+cnt+60001,cntt*m-m+cnt-1,1e9);
				addE(s,cntt*m-m+cnt+60001,c[i][j]);
				sum+=2*c[i][j];
			}
			if(i<n){
				addE(cntt*m-m+cnt,cntt*m-m+cnt+30001,1e9);
				addE(cntt*m+cnt,cntt*m-m+cnt+30001,1e9);
				addE(cntt*m-m+cnt+30001,t,c[i][j]);
				addE(cntt*m-m+cnt+70001,cntt*m-m+cnt,1e9);
				addE(cntt*m-m+cnt+70001,cntt*m+cnt,1e9);
				addE(s,cntt*m-m+cnt+70001,c[i][j]);
				sum+=2*c[i][j];
			}
			if(j<m){
				addE(cntt*m-m+cnt,cntt*m-m+cnt+40001,1e9);
				addE(cntt*m-m+1+cnt,cntt*m-m+cnt+40001,1e9);
				addE(cntt*m-m+cnt+40001,t,c[i][j]);
				addE(cntt*m-m+cnt+80001,cntt*m-m+cnt,1e9);
				addE(cntt*m-m+cnt+80001,cntt*m-m+cnt+1,1e9);
				addE(s,cntt*m-m+cnt+80001,c[i][j]);
				sum+=2*c[i][j];
			}
		}
	}
	cout<<sum-dinic();
	
}
```


---

## 作者：ademik (赞：0)

本文章同步发表于 题记 [网络流](https://www.luogu.com.cn/blog/750173/wang-lao-liu)

建议先完成 [小M的作物](https://www.luogu.com.cn/problem/P1361) 再看这道题。 

#### 分析 :

我们考虑类似于 [小M的作物](https://www.luogu.com.cn/problem/P1361) 建图。

![](https://cdn.luogu.com.cn/upload/image_hosting/lmgj9ebm.png)

寻找这种组合的规律，我们发现：

![](https://cdn.luogu.com.cn/upload/image_hosting/pawyj23h.png)

我们考虑转化题意，将两个位置要选择不一样才会有附加权值转变为
变成了两个位置集合相同才会有附加权值。

![](https://cdn.luogu.com.cn/upload/image_hosting/ycobbqv9.png)

简单来讲，我们将哪些原来是 $S \rightarrow x$ 的边等价变换为 $x \rightarrow T$，哪些原来是 $x \rightarrow T$ 的边等价变换为 $S \rightarrow x$。通过这种方式，我们使一个点连线集合 A 和它周围的点连线集合 B 的边集中到一个集合中，以方便处理。

最后求一遍最小割即可。 

#### Code :

```cpp
# include <bits/stdc++.h>
# define TIME 1e3 * clock() / CLOCKS_PER_SEC
using namespace std;
typedef long long i64;
typedef pair < int, int > pii;
const int N = 1005;
int n, m, si, ti; 
int head[N], edge_sum = 1;
struct edge {
	int nst, to;
	i64 cf;
} e[N * N];
void add_edge(int u, int v, int w)
{
    //cerr <<u <<" " <<v <<endl;
    e[++ edge_sum] = (edge){head[u], v, w}; head[u] = edge_sum;
    e[++ edge_sum] = (edge){head[v], u, 0}; head[v] = edge_sum;
}
namespace Dinic
{
	int level[N], now[N];
	bool bfs() {
		memset(level, 0, sizeof(level));
		queue < int > q; q.push(si);
		level[si] = 1;
		while(!q.empty()) {
			int u = q.front(); q.pop();
			for(int i = head[u]; i; i = e[i].nst) {
				int v = e[i].to;
				if(level[v] == 0 && e[i].cf > 0) {
					level[v] = level[u] + 1;
					q.push(v);
				}
			}
		}
		return level[ti];
	} 
	i64 dfs(int u, i64 flow) {
		if(u == ti) return flow;
		i64 sum = 0;
		for(int &i = now[u]; i; i = e[i].nst) {
			int v = e[i].to;
			if(level[v] == level[u] + 1 && e[i].cf > 0) {
				i64 delta = dfs(v, min(flow, e[i].cf));
				e[i].cf -= delta; e[i ^ 1].cf += delta;
				sum += delta; flow -= delta;
				if(flow == 0) return sum;
				if(sum == 0) level[v] = 0;
 			}
		}
		return sum;
	}
	i64 Dinic() {
		i64 max_flow = 0;
		while(bfs()) {
			memcpy(now, head, sizeof(now));
			max_flow += dfs(si, INT_MAX);
		}
		return max_flow;
	}
} 
int _next[4][2] = {{0, -1}, {0, 1}, {1, 0}, {-1, 0}};
int A[N][N], B[N][N], C[N][N];
int main()
{
	ios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);
    cin >>n >>m; si = 0; ti = n * m + 1;
    i64 sum = 0, tot = n * m + 1;
    for(int i = 1; i <= n; i ++) {
        for(int j = 1; j <= m; j ++) cin >>A[i][j], sum += A[i][j];
    }
    for(int i = 1; i <= n; i ++) {
        for(int j = 1; j <= m; j ++) cin >>B[i][j], sum += B[i][j];
    }
    for(int i = 1; i <= n; i ++) {
        for(int j = 1; j <= m; j ++) cin >>C[i][j];
    }
    for(int i = 1; i <= n; i ++) {
        for(int j = 1; j <= m; j ++) if((i + j) % 2) {
            swap(A[i][j], B[i][j]);
        }
    }
    for(int i = 1; i <= n; i ++) {
        for(int j = 1; j <= m; j ++) {
            add_edge(si, (i - 1) * m + j, A[i][j]);
            add_edge((i - 1) * m + j, ti, B[i][j]);
        }
    }
    for(int i = 1; i <= n; i ++) {
        for(int j = 1; j <= m; j ++) {
            for(int k = 0; k <= 3; k ++) {
                int x = i + _next[k][0], y = j + _next[k][1];
                if(x < 1 || x > n || y < 1 || y > m) continue;
                sum += 2 * C[i][j];
                add_edge(si, tot + 1, C[i][j]);
                add_edge(tot + 1, (i - 1) * m + j, INT_MAX);
                add_edge(tot + 1, (x - 1) * m + y, INT_MAX);
                add_edge(tot + 2, ti, C[i][j]);
                add_edge((i - 1) * m + j, tot + 2, INT_MAX);
                add_edge((x - 1) * m + y, tot + 2, INT_MAX);
                tot += 2;
            }
        }
    }
    cout <<sum - Dinic :: Dinic() <<endl;
    return 0;
}
```

---

## 作者：do_while_true (赞：0)

还是那个经典trick：最大价值=总价值-最小花费

每个位置都是二选一，考虑一个鱼刺型建图。

然后就是需要描述一个，如果 $x$ 选了第 $p$ 种方案，那么如果它的邻点也选了第 $p$ 种方案，就有 $-C$ 的代价，也就是有一条 $-C$ 流量的边需要割掉。

但是如果直接 $S$ 连向每个格子的边流量为 $A$，每个格子流向 $T$ 的格子流量为 $B$，你会发现这个限制描述不了。

注意到网格图四联通实际上是个二分图，按照格子的横纵坐标和的奇偶性分类就是个二分图。

那么将横纵坐标和为偶数的格子，连边变成 $(S,x,B),(x,T,A)$，然后限制的话直接在邻点之间连 $(x,y,C_x+C_y),(y,x,C_x+C_y)$ 流量的边，这样如果 $x$ 和其邻点 $y$ 如果选择了同样的一种方案，那么就需要付出 $C_x+C_y$ 的代价。

这样用总价值减去最小割就可以了。

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<vector>
#include<queue>
#define pb emplace_back
#define mp std::make_pair
#define fi first
#define se second
typedef long long ll;
typedef long double ld;
typedef unsigned long long ull;
typedef std::pair<int, int> pii;
typedef std::vector<int> vi;
const ll mod = 998244353;
ll Add(ll x, ll y) { return (x+y>=mod) ? (x+y-mod) : (x+y); }
ll Mul(ll x, ll y) { return x * y % mod; }
ll Mod(ll x) { return x < 0 ? (x + mod) : (x >= mod ? (x-mod) : x); }
ll cadd(ll &x, ll y) { return x = (x+y>=mod) ? (x+y-mod) : (x+y); }
ll cmul(ll &x, ll y) { return x = x * y % mod; }
template <typename T> T Max(T x, T y) { return x > y ? x : y; }
template<typename T, typename... T2> T Max(T x, T2 ...y) { return Max(x, y...); }
template <typename T> T Min(T x, T y) { return x < y ? x : y; }
template<typename T, typename... T2> T Min(T x, T2 ...y) { return Min(x, y...); }
template <typename T> T cmax(T &x, T y) { return x = x > y ? x : y; }
template <typename T> T cmin(T &x, T y) { return x = x < y ? x : y; }
template <typename T>
T &read(T &r) {
	r = 0; bool w = 0; char ch = getchar();
	while(ch < '0' || ch > '9') w = ch == '-' ? 1 : 0, ch = getchar();
	while(ch >= '0' && ch <= '9') r = r * 10 + (ch ^ 48), ch = getchar();
	return r = w ? -r : r;
}
template<typename T1, typename... T2>
void read(T1 &x, T2& ...y) { read(x); read(y...); }
const int N = 5010;
const int M = 10010;
const ll INF = 0x7fffffffffffffff;
int n, m, A[110][110], B[110][110], C[110][110], p[110][110];
int tot, S, T, ent = 1, head[N], cur[N], dis[N];
struct Edge {
	int to, nxt;
	ll fl;
}e[M << 1];
inline void add(int x, int y, int z) {
	e[++ent].to = y; e[ent].fl = z; e[ent].nxt = head[x]; head[x] = ent;
	e[++ent].to = x; e[ent].fl = 0; e[ent].nxt = head[y]; head[y] = ent;
}
bool bfs() {
	for(int i = 1; i <= tot; ++i) dis[i] = -1, cur[i] = head[i];
	std::queue<int>q;
	q.push(S); dis[S] = 0;
	while(!q.empty()) {
		int x = q.front(); q.pop();
		for(int i = head[x]; i; i = e[i].nxt) {
			int v = e[i].to;
			if(dis[v] == -1 && e[i].fl) {
				dis[v] = dis[x] + 1;
				q.push(v);
			}
		}
	}
	return dis[T] != -1;
}
ll dfs(int x, ll lim) {
	if(x == T) return lim;
	ll flow = 0;
	for(int i = cur[x]; i && flow < lim; i = e[i].nxt) {
		int v = e[i].to; cur[x] = i;
		if(dis[v] == dis[x] + 1 && e[i].fl) {
			ll f = dfs(v, Min(e[i].fl, lim - flow));
			flow += f; e[i].fl -= f; e[i^1].fl += f;
		}
	}
	return flow;
}
ll dinic() {
	ll mxfl = 0;
	while(bfs())
		mxfl += dfs(S, INF);
	return mxfl;
}
signed main() {
	read(n, m); S = ++tot; T = ++tot;
	for(int i = 1; i <= n; ++i)
		for(int j = 1; j <= m; ++j)
			p[i][j] = ++tot;
	for(int i = 1; i <= n; ++i)
		for(int j = 1; j <= m; ++j)
			read(A[i][j]);
	for(int i = 1; i <= n; ++i)
		for(int j = 1; j <= m; ++j)
			read(B[i][j]);
	for(int i = 1; i <= n; ++i)
		for(int j = 1; j <= m; ++j)
			read(C[i][j]);
	ll sum = 0;
	for(int i = 1; i <= n; ++i)
		for(int j = 1; j <= m; ++j) {
			if((i + j) & 1) {
				add(S, p[i][j], A[i][j]);
				add(p[i][j], T, B[i][j]);
			}
			else {
				add(S, p[i][j], B[i][j]);
				add(p[i][j], T, A[i][j]);
			}
			sum += A[i][j] + B[i][j];
			if(p[i-1][j]) {
				add(p[i-1][j], p[i][j], C[i][j] + C[i-1][j]);
				sum += C[i][j]; 
			}
			if(p[i+1][j]) {
				add(p[i+1][j], p[i][j], C[i][j] + C[i+1][j]);
				sum += C[i][j];
			}
			if(p[i][j-1]) {
				add(p[i][j-1], p[i][j], C[i][j] + C[i][j-1]);
				sum += C[i][j]; 
			}
			if(p[i][j+1]) {
				add(p[i][j+1], p[i][j], C[i][j] + C[i][j+1]);
				sum += C[i][j]; 
			}
		}
	printf("%lld\n", sum - dinic());
	return 0;
}
```

---

## 作者：灵华 (赞：0)

## P1935 [国家集训队]圈地计划

[My blog](https://www.cnblogs.com/linghuabaobao/p/15733494.html)

### 题目描述

[题目链接](https://www.luogu.com.cn/problem/P1935)

最近房地产商 GDOI(Group of Dumbbells Or Idiots) 从 NOI(Nuts Old Idiots) 手中得到了一块开发土地。据了解，这块土地是一块矩形的区域，可以纵横划分为 $N\times M$ 块小区域。GDOI 要求将这些区域分为商业区和工业区来开发。根据不同的地形环境，每块小区域建造商业区和工业区能取得不同的经济价值。更具体点，对于第 $i$ 行第 $j$ 列的区域，建造商业区将得到 $A_{i,j}$ 收益，建造工业区将得到 $B_{i,j}$ 收益。另外不同的区域连在一起可以得到额外的收益，即如果区域 $(i,j)$ 相邻（相邻是指两个格子有公共边）有 $k$ 块（显然 $k$ 不超过 $4$）类型不同于 $(i,j)$ 的区域，则这块区域能增加 $k\times C_{i,j}$ 收益。经过 Tiger.S 教授的勘察，收益矩阵 $A,B,C$ 都已经知道了。你能帮 GDOI 求出一个收益最大的方案么？

数据范围：$N,M \le 100$。

### 解法：

这是一道非常经典的最小割的题目，非常类似于 [luoguP1361 小M的作物](https://www.luogu.com.cn/problem/P1361) 这道题。

首先这个题目的收益分成两部分，一部分是建造的收益，一部分是相邻区域的收益。

对于第一部分的收益，我们把每个区域当成一个节点，源点连向这个点的边的容量就是造商业区的收益，这个点的容量连向汇点的边的容量就是造工业区的收益（或者反过来也行）。在最小割中，我们肯定是要对这个点向源点和汇点连的两条边要割掉一条，割掉的那条就是不选的，留下的就是要选择的区。

对于第二部分的收益，我们发现在小M的作物那道题中，我们知道如何求几个结点如果被同时分到源点或者汇点会有额外收益，但是这道题是要求个节点被分到不同的类别会有特殊收益。对于这种问题，我们可以通过一些的手段，将分到不同的类别转换成分到相同的类别，这种手段就是黑白染色。

黑白染色，就是指将任意两个相邻的区间染成不同的颜色，然后对所有相同的颜色是同一种处理方式。

用到此题上就是每个区域和周围四个区域是异色，然后将所有黑色的区域所连的汇点和源点的边的容量反过来，白色保持不动。这样，如果说要使某两个相邻的区域是选择不同的类别，那么他们只要同时选汇点或同时选源点就行了。而且这种方法并不会对第一类的收益产生影响，因为第一类的收益任意两个区域之间相互独立。

最后跑最小割就行了。

### Code：

```cpp
#include <iostream>
#include <cstring>
#include <queue>
using namespace std ;

#define int long long
const int N = 200005 , INF = 0x3f3f3f3f3f3f3f3f ;
const int dx[] = { 0 , 1 , 0 , -1 } , dy[] = { 1 , 0 , -1 , 0 } ;
int n , m , s , t , ans , dis[N] , wv[105][105] ;

struct Edge
{
	int nxt , to , len ;
} edge[N*20] ;

int cnt = 1 , head[N] ;
void insert ( int u , int v , int w )
{
	edge [ ++ cnt ] .nxt = head [ u ] ;
	edge [ cnt ] .to = v ;
	edge [ cnt ] .len = w ;
	head [ u ] = cnt ;
	ans += w ;
}

queue < int > q ;
bool bfs ( )
{
	memset ( dis , 0 , sizeof ( dis ) ) ;
	dis [ s ] = 1 ;
	q .push ( s ) ;
	while ( ! q .empty ( ) )
	{
		int x = q .front ( ) ; q .pop ( ) ;
		for ( int i = head [ x ] ; i ; i = edge [ i ] .nxt )
		{
			int y = edge [ i ] .to ;
			if ( dis [ y ] || ! edge [ i ] .len )
				continue ;
			dis [ y ] = dis [ x ] + 1 ;
			q .push ( y ) ;
		}
	}
	return dis [ t ] ;
}

int dfs ( int x , int now )
{
	if ( x == t )
		return now ;
	int res = now ;
	for ( int i = head [ x ] ; i && res ; i = edge [ i ] .nxt )
	{
		int y = edge [ i ] .to ;
		if ( dis [ y ] != dis [ x ] + 1 || ! edge [ i ] .len )
			continue ;
		int w = dfs ( y , min ( res , edge [ i ] .len ) ) ;
		if ( ! w ) dis [ y ] = -1 ;
		edge [ i ] .len -= w ;
		edge [ i ^ 1 ] .len += w ;
		res -= w ;
	}
	return now - res ;
}

int id ( int x , int y )
{
	return ( x - 1 ) * m + y ;
}

signed main ( )
{
	cin >> n >> m ;
	s = n * m + 1 ;
	t = s + 1 ;
	for ( int i = 1 ; i <= n ; ++ i )
		for ( int j = 1 ; j <= m ; ++ j )
		{
			int x ;
			cin >> x ;
			if ( ( i + j ) & 1 )
				insert ( s , id ( i , j ) , x ) ,
				insert ( id ( i , j ) , s , 0 ) ;
			else
				insert ( id ( i , j ) , t , x ) ,
				insert ( t , id ( i , j ) , 0 ) ;
		}
	for ( int i = 1 ; i <= n ; ++ i )
		for ( int j = 1 ; j <= m ; ++ j )
		{
			int x ;
			cin >> x ;
			if ( ( i + j ) & 1 )
				insert ( id ( i , j ) , t , x ) ,
				insert ( t , id ( i , j ) , 0 ) ;
			else
				insert ( s , id ( i , j ) , x ) ,
				insert ( id ( i , j ) , s , 0 ) ;
		}
	for ( int i = 1 ; i <= n ; ++ i )
		for ( int j = 1 ; j <= m ; ++ j )
			cin >> wv [ i ] [ j ] ;
	for ( int i = 1 ; i <= n ; ++ i )
		for ( int j = 1 ; j <= m ; ++ j )
			for ( int c = 0 ; c < 2 ; ++ c )
			{
				int ii = i + dx [ c ] , jj = j + dy [ c ] ;
				if ( ii < 1 || jj < 1 || ii > n || jj > m )
					continue ;
				insert ( id ( i , j ) , id ( ii , jj ) , wv [ i ] [ j ] + wv [ ii ] [ jj ] ) ;
				insert ( id ( ii , jj ) , id ( i , j ) , wv [ i ] [ j ] + wv [ ii ] [ jj ] ) ;
				ans -= wv [ i ] [ j ] + wv [ ii ] [ jj ] ;
			}
	int tmp = 0 ;
	while ( bfs ( ) )
		while ( tmp = dfs ( s , INF ) )
			ans -= tmp ;
	cout << ans << '\n' ;
	return 0 ;
}
```



---

## 作者：ubsan (赞：0)

一种拆点做法。

如果我们按照正常拆点+最小割的做法来建图，$S$ 向每个点连边，每个点向 $T$ 连边，相邻的点直接连边，我们会发现如果相邻的两个点颜色不同才会割边。

我们发现问题的本质是颜色不同会连向不同的点（源点/汇点），所以我们考虑黑白染色，对于黑色的点从 $S$ 向它连边权为 $a[i][j]$ 的边，它向 $T$ 连 边权为 $b[i][j]$ 的边，而白色的点从 $S$ 向它连边权为 $b[i][j]$ 的边，它向 $T$ 连 边权为 $a[i][j]$ 的边，也就是下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/15liyeak.png)

这是我们发现相邻的点颜色不同会连向同一个点了，所以我们可以在代表 $a[i][j]$ 的点之间连边，代表 $b[i][j]$ 的点之间连边，这样如果它们颜色相同这条边就会被割掉。

![](https://cdn.luogu.com.cn/upload/image_hosting/gntiwx2e.png)

(一个点要和所有相邻的点连这样的边，上图只是其中一对的说明）

还有一些细节需要处理，因为我们不能同时把代表 $a,b$ 的边都割掉，所以我们要给它们加上一个偏移量（比 $inf$ 小很多）。

code:

```cpp
#include <bits/stdc++.h>
#define inf 100000000000000000ll
#define sinf 200000000ll
#define N 1000000
#define int long long
using namespace std;
int s, t, n, m, cnt = 1, ans;
int head[N], nxt[N], to[N], len[N];
void add(int a, int b, int l, bool _rev = false) {
  ans += l;
  nxt[++cnt] = head[a];
  to[cnt] = b;
  len[cnt] = l;
  head[a] = cnt;
  if (!_rev) add(b, a, 0, true);
}
int a[101][101], b[101][101], c[101][101];
#define id(x, y, z) ((x - 1) * m + y + z * n * m)
int cur[N], dep[N];
bool bfs() {
  for (int i = 0; i < N; i++) cur[i] = head[i], dep[i] = inf;
  dep[s] = 0;
  queue<int> q;
  q.push(s);
  bool flag = 0;
  while (!q.empty()) {
    int now = q.front();
    flag |= (now == t);
    q.pop();
    for (int i = head[now]; i; i = nxt[i]) {
      if (len[i] && dep[to[i]] == inf) {
        dep[to[i]] = dep[now] + 1;
        q.push(to[i]);
      }
    }
  }
  return flag;
}
int dfs(int now, int flow) {
  if (now == t) return flow;
  int use = 0;
  for (int i = cur[now]; i && flow; i = nxt[i]) {
    cur[now] = i;
    if (len[i] && dep[to[i]] == dep[now] + 1) {
      int v = dfs(to[i], min(flow, len[i]));
      if (!v) dep[to[i]] = inf;
      len[i] -= v;
      len[i ^ 1] += v;
      flow -= v;
      use += v;
    }
  }
  return use;
}
int dinic() {
  int flow = 0;
  while (bfs()) flow += dfs(s, inf);
  return flow;
}
signed main() {
  cin >> n >> m;
  s = 0;
  t = n * m * 2 + 1;
  for (int i = 1; i <= n; i++)
    for (int j = 1; j <= m; j++) {
      add(id(i, j, 0), id(i, j, 1), inf);
      cin >> a[i][j];
      if ((i + j) % 2) {
        add(s, id(i, j, 0), a[i][j] + sinf);
      } else {
        add(id(i, j, 1), t, a[i][j] + sinf);
      }
    }
  for (int i = 1; i <= n; i++)
    for (int j = 1; j <= m; j++) {
      cin >> b[i][j];
      if ((i + j) % 2) {
        add(id(i, j, 1), t, b[i][j] + sinf);
      } else {
        add(s, id(i, j, 0), b[i][j] + sinf);
      }
    }
  for (int i = 1; i <= n; i++)
    for (int j = 1; j <= m; j++) {
      cin >> c[i][j];
    }
  int pre = ans;
  for (int i = 1; i <= n; i++)
    for (int j = 1; j <= m; j++) {
      if (i != 1) {
        add(id(i, j, 0), id(i - 1, j, 1), c[i][j] + c[i - 1][j]);
      }
      if (i != n) {
        add(id(i, j, 0), id(i + 1, j, 1), c[i][j] + c[i + 1][j]);
      }
      if (j != 1) {
        add(id(i, j, 0), id(i, j - 1, 1), c[i][j] + c[i][j - 1]);
      }
      if (j != m) {
        add(id(i, j, 0), id(i, j + 1, 1), c[i][j] + c[i][j + 1]);
      }
    }
  ans -= (ans - pre) / 2;
  int val = dinic();
  cout << ans - val - (sinf + inf) * n * m << endl;
  return 0;
}
```

---

## 作者：localhost (赞：0)

和[\[国家集训队]happiness](https://www.luogu.com.cn/problemnew/show/P1646)有点像

而且建图更加简化了

答案为总和减去最小割

$(i+j)\&1,(i',j')$与$(i,j)$相邻，黑白染色建图

$st\xrightarrow{A} (i,j)\xrightarrow{B}ed$

$st\xrightarrow{B} (i',j')\xrightarrow{A}ed$

$(i,j) \xleftrightarrow{c_{i,j}+c_{i',j'}} (i',j')$

图片请到[我的题解](https://zt.zcmimi.top/LG%201935%20[%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F]%E5%9C%88%E5%9C%B0%E8%AE%A1%E5%88%92/index.html)查看

假设$(i,j)$选择$A$,那么要断开$(i,j)\rightarrow t,(i,j)\rightarrow (i',j')$

这些边上的权值会从答案中减去

最小割可以最小化要减去的权值，所以答案最大

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=100011,M=1000011;
int n,m,cnt=1,head[N],st,ed,d[N],q[N],c[101][101];
struct edge{
    int to,nxt,w;
}e[M];
#define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)
void add(int x,int y,int w){
    e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;e[cnt].w=w;
    e[++cnt].to=x;e[cnt].nxt=head[y];head[y]=cnt;e[cnt].w=0;
}
bool bfs(){
    int h=0,t=1,x;
    memset(d,0,sizeof d);
    q[0]=st;d[st]=1;
    while(h<t){
        x=q[h++];if(x==ed)return 1;
        fl(i,x)if(e[i].w&&!d[to])
            d[to]=d[x]+1,q[t++]=to;
    }
    return 0;
}
int dfs(int x,int mf){
    if(x==ed)return mf;
    int us=0,w;
    fl(i,x)if(e[i].w&&d[to]==d[x]+1){
        w=dfs(to,min(mf-us,e[i].w));
        e[i].w-=w;
        us+=w;
        e[i^1].w+=w;
        if(us==mf)return mf;
    }
    if(!us)d[x]=-1;
    return us;
}
int id(int x,int y){return (x-1)*m+y;}
int main(){
    scanf("%d%d",&n,&m);
    st=N-1,ed=N-2;
    int ans=0,w,tt=n*m,dx[4]={0,1,0,-1},dy[4]={1,0,-1,0},x,y;
    for(int i=1;i<=n;++i)
    for(int j=1;j<=m;++j){
        scanf("%d",&w),ans+=w;
        if((i+j)&1)add(st,id(i,j),w);
        else add(id(i,j),ed,w);
    }
    for(int i=1;i<=n;++i)
    for(int j=1;j<=m;++j){
        scanf("%d",&w),ans+=w;
        if((i+j)&1)add(id(i,j),ed,w);
        else add(st,id(i,j),w);
    }
    for(int i=1;i<=n;++i)
    for(int j=1;j<=m;++j)
        scanf("%d",&c[i][j]);
    for(int i=1;i<=n;++i)
    for(int j=1;j<=m;++j)
    if(!((i+j)&1))
    for(int t=0;t<=3;++t){
        x=i+dx[t],y=j+dy[t];
        if(x<1||x>n||y<1||y>m)continue;
        ans+=(w=c[i][j]+c[x][y]);
        add(id(i,j),id(x,y),w);
        add(id(x,y),id(i,j),w);
    }
    while(bfs())ans-=dfs(st,1<<30);
    printf("%d\n",ans);
}
```

---

## 作者：Mark_4396 (赞：0)

p1935像黑白棋盘一样，于整个图我们进行黑白染色，对于黑色的点，我们把其和SS相连，边权为当前点开发成为商业区的收益，和TT相连，边权为当前点开发成为工业区的收益，反之我们和SS相连，边权为当前点开发成为工业区的收益，和TT相连，边权为当前点开发成为商业区的收益。因为我们将其进行黑白染色之后翻转源汇，所以两个相邻的土地若开发成为不同的类型会在同一个集合，这样我们就能在相邻的两个点之间进行连线，因为这两个点如果不同会分别贡献两个值，所以这两个点之间的边为双向边，边权为这两个值相加。

```
#include <bits/stdc++.h>
#define id(x,y) (x-1)*m+y
using namespace std;
 
const int maxn = 51000;
const int maxm = 310000;
const int INF = 0x3f3f3f3f;
int n, m, a[105][105];
 
struct Edge{
    int to,next,cap,flow;
}edge[maxm];
int tol,head[maxm];
 
void init()
{
    tol=2;
    memset(head,-1,sizeof(head));
}
 
void addedge(int u,int v,int w,int rw=0)
{
    edge[tol].to=v;edge[tol].cap=w;edge[tol].flow=0;
    edge[tol].next=head[u];head[u]=tol++;
    edge[tol].to=u;edge[tol].cap=rw;edge[tol].flow=0;
    edge[tol].next=head[v];head[v]=tol++;
}
 
int Q[maxn];
int dep[maxn],cur[maxn],sta[maxn];
 
bool bfs(int s,int t,int n)
{
    int front=0,tail=0;
    memset(dep,-1,sizeof(dep[0])*(n+1));
    dep[s]=0;
    Q[tail++]=s;
    while(front<tail){
        int u=Q[front++];
        for(int i=head[u];i!=-1;i=edge[i].next){
            int v=edge[i].to;
            if(edge[i].cap>edge[i].flow&&dep[v]==-1){
                dep[v]=dep[u]+1;
                if(v==t){
                    return true;
                }
                Q[tail++]=v;
            }
        }
    }
    return false;
}
 
int dinic(int s,int t,int n)
{
    int maxflow=0;
    while(bfs(s,t,n)){
        for(int i=0;i<n;i++){
            cur[i]=head[i];
        }
        int u=s,tail=0;
        while(cur[s]!=-1){
            if(u==t){
                int tp=INF;
                for(int i=tail-1;i>=0;i--){
                    tp=min(tp,edge[sta[i]].cap-edge[sta[i]].flow);
                }
                maxflow+=tp;
                for(int i=tail-1;i>=0;i--){
                    edge[sta[i]].flow+=tp;
                    edge[sta[i]^1].flow-=tp;
                    if(edge[sta[i]].cap-edge[sta[i]].flow==0){
                        tail=i;
                    }
                }
                u=edge[sta[tail]^1].to;
            }else if(cur[u]!=-1&&edge[cur[u]].cap>edge[cur[u]].flow&&dep[u]+1==dep[edge[cur[u]].to]){
                sta[tail++]=cur[u];
                u=edge[cur[u]].to;
            }else{
                while(u!=s&&cur[u]==-1){
                    u=edge[sta[--tail]^1].to;
                }
                cur[u]=edge[cur[u]].next;
            }
        }
    }
    return maxflow;
}
 
int main()
{
    cin >> n >> m;
    int v;
    int ans = 0;
    init();
    int s = n*m+1, t = s+1;
    for(int i = 1; i <= n; i++)
    {
        for(int j = 1; j <= m; j++)
        {
            scanf("%d", &v);
            ans +=v;
            if((i+j)&1)
            {
                addedge(s, id(i, j), v);
            }
            else
                addedge(id(i,j), t, v);
        }
    }
    for(int i = 1; i <= n; i++)
    {
        for(int j = 1; j <= m; j++)
        {
            scanf("%d", &v);
            ans += v;
            if(!((i+j)&1))
            {
                addedge(s, id(i, j), v);
            }
            else
                addedge(id(i,j), t, v);
        }
    }
    for(int i = 1; i <= n; i++)
        for(int j = 1; j <= m; j++)
            scanf("%d", &a[i][j]);
    for(int i = 1; i <= n; i++)
    {
        for(int j = 1; j <= m-1; j++)
        {
            int tmp = a[i][j]+a[i][j+1];
            ans += tmp;
            addedge(id(i,j), id(i, j+1), tmp, tmp);
        }
    }
    for(int i = 1; i <= n-1; i++)
    {
        for(int j = 1; j <= m; j++)
        {
            int tmp = a[i+1][j]+a[i][j];
            ans += tmp;
            addedge(id(i,j), id(i+1, j), tmp, tmp);
        }
    }
    ans -= dinic(s, t, t);
    cout << ans;
    return 0;
}
```


---

## 作者：温词 (赞：0)

### 在hzwer学长博客里看到了这道题，然后就做了一下，然后一开始想了个神仙建图方式，漏洞百出（这并不重要
### 这道题有一个前置技能点P1646，两道题最大的区别可能就是happiness是要和周围一样，而这个题是要不一样，那既然如此，可以先黑白染色，然后将一半的反向建图，这样把一部分点倒过来之后，又变成了和周围一样即可，然后手推一个浅显的结论，两个点都选择的话收益是c[x1][y1]+c[x2][y2]，其他就都是常规操作了
```cpp
#include<bits/stdc++.h>
#include<queue>
using namespace std;
#define INF 0x3f3f3f3f
inline int read(){
    int w=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
        if(ch=='-') f=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        w=(w<<3)+(w<<1)+ch-48;
        ch=getchar();
    }
    return w*f;
}
int n,m,cnt=-1,head[100010],cur[100010],depth[100010],f[100010],ans1,ans,len,S,T,a[110][110],b[110][110],c[110][110],tot;
int dx[5]={0,0,1,0,-1};
int dy[5]={0,1,0,-1,0};
struct Edge{
    int from,to,next,flow;
}edge[1000010];
inline void addedge(int u,int v,int w){
    cnt++;
    edge[cnt].from=u;
    edge[cnt].to=v;
    edge[cnt].flow=w;
    edge[cnt].next=head[u];
    head[u]=cnt;
}
inline void ins(int u,int v,int w){
    addedge(u,v,w);addedge(v,u,0);
}
queue<int> q;
inline bool bfs(int st,int ed){
    memset(depth,0,sizeof(depth));
    int u,v,i,j,k;q.push(st);depth[st]=1;
    while(!q.empty()){
        u=q.front();q.pop();
        for(i=head[u];i!=-1;i=edge[i].next){
            v=edge[i].to;
            if(!depth[v]&&edge[i].flow){
                depth[v]=depth[u]+1;q.push(v);
            }
        }
    }
    return depth[ed];
}
inline int dfs(int u,int ed,int limit){
    if(!limit||u==ed) return limit;
    int v,i,j,k;int flow=0,f;
    for(i=head[u];i!=-1;i=edge[i].next){
        v=edge[i].to;
        if(depth[v]==depth[u]+1&&(f=dfs(v,ed,min(limit,edge[i].flow)))){
            limit-=f;flow+=f;
            edge[i].flow-=f;edge[i^1].flow+=f;
            if(!limit) break;
        }
    }
    return flow;
}
inline void Dinic(){
    while(bfs(S,T)){
        ans+=dfs(S,T,INF);
    }
}
inline int id(int x,int y){
    return (x-1)*m+y;
}
int main(){
    n=read();m=read();int i,j,k;
    memset(head,-1,sizeof(head));S=0;T=99999;
    for(i=1;i<=n;i++){
        for(j=1;j<=m;j++){
            int x=read();tot+=x;
            if((i+j)&1) ins(S,id(i,j),x);
            else ins(id(i,j),T,x);
        }
    }
    for(i=1;i<=n;i++){
        for(j=1;j<=m;j++){
            int x=read();tot+=x;
            if((i+j)&1) ins(id(i,j),T,x);
            else ins(S,id(i,j),x);
        }
    }
    for(i=1;i<=n;i++){
        for(j=1;j<=m;j++){
            c[i][j]=read();
        }
    }
    for(i=1;i<=n;i++){
        for(j=1;j<=m;j++){
            if((i+j)&1) continue;
            for(k=1;k<=4;k++){
                int fx=i+dx[k];int fy=j+dy[k];
                if(fx>=1 and fy>=1 and fx<=n and fy<=m){
                    ins(id(i,j),id(fx,fy),c[i][j]+c[fx][fy]);
                    ins(id(fx,fy),id(i,j),c[i][j]+c[fx][fy]);
                    tot+=c[i][j]+c[fx][fy];
                }
            }
        }
    }
    Dinic();
    cout<<tot-ans<<endl;
    return 0;
}
```

---


# [国家集训队] 排队

## 题目背景

加强版：<https://www.luogu.com.cn/problem/P12685>

## 题目描述

排排坐，吃果果，生果甜嗦嗦，大家笑呵呵。你一个，我一个，大的分给你，小的留给我，吃完果果唱支歌，大家乐和和。

红星幼儿园的小朋友们排起了长长地队伍，准备吃果果。不过因为小朋友们的身高有所区别，排成的队伍高低错乱，极不美观。设第 $i$ 个小朋友的身高为 $h_i$。

幼儿园阿姨每次会选出两个小朋友，交换他们的位置，请你帮忙计算出每次交换后，序列的逆序对数。为方便幼儿园阿姨统计，在未进行任何交换操作时，你也应该输出该序列的逆序对数。


## 说明/提示

【样例说明】  
未进行任何操作时，$(2,3)$ 为逆序对；  
操作一结束后，序列为 $130 \ 140 \ 150$，不存在逆序对；  
操作二结束后，序列为 $150 \ 140 \ 130$，$(1,2),(1,3),(2,3)$ 共 $3$ 个逆序对。

【数据范围】  
对于 $10\%$ 的数据，$n,m \le 15$；  
对于 $25\%$ 的数据，$n,m \le 200$；    
另有 $25\%$ 的数据，$h_i$ 各不相同；  
另有 $15\%$ 的数据，$110 \le h_i \le 160$；  
以上两类数据交集为空。

对于100%的数据，$1 \le m \le 2\times 10^3$，$1 \le n \le 2 \times 10^4$，$1 \le h_i \le 10^9$，$a_i \ne b_i$，$1 \le a_i,b_i \le n$。


## 样例 #1

### 输入

```
3
130 150 140
2
2 3
1 3```

### 输出

```
1
0
3
```

# 题解

## 作者：ningyuheng (赞：55)

这道题网上的题解基本上都是用线段树套平衡树做的，然而经过我的观察发现，由于这道题的数据较小，其实可以用归并排序+暴力找逆序数对就行了，总复杂度为O(nlogn + nm),首先先用归并排序求出初始状态的逆序数对，然后在当交换两个数时暴力查找两数之间有多少逆序数对，进行减去或加上，然后直接输出答案。

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int i,n,q,h[100002],o[100002],p[100002],ans,a,b;
int gb(int x,int y){
    int mid=(x+y)/2,j=x,k=mid+1,l=x;
    if(x==y) return 0;
    gb(x,mid);
    gb(k,y);
    while(j<=mid&&k<=y){
        if(o[j]<=o[k]){
            p[l]=o[j];
            j++;
            l++;
        }
        else{
            p[l]=o[k];
            ans+=mid-j+1;
            k++;
            l++;
        }
    }
    while(j<=mid){
        p[l]=o[j];
        j++;
        l++;
    }
    while(k<=y){
        p[l]=o[k];
        k++;
        l++;
    }
    for(i=x;i<=y;i++)
        o[i]=p[i];
    return 0;
}
int main()
{
    int j,k,l;
    scanf("%d",&n);
    for(i=1;i<=n;i++)
        scanf("%d",&h[i]);
    for(i=1;i<=n;i++)
        o[i]=h[i];
    gb(1,n);
    printf("%d\n",ans);
    scanf("%d",&q);
    for(i=1;i<=q;i++){
        scanf("%d%d",&a,&b);
        if(a>b){
            j=a;
            a=b;
            b=j;
        }
        if(h[b]>h[a])
            ans++;
        else if(h[b]<h[a])
            ans--;
        for(j=a+1;j<=b-1;j++){
            if(h[j]>h[a])
                ans++;
            else if(h[j]<h[a])
                ans--;
            if(h[j]<h[b])
                ans++;
            else if(h[j]>h[b])
                ans--;
        }
        j=h[a];
        h[a]=h[b];
        h[b]=j;
        printf("%d\n",ans);
    }
    return 0;
}

```

---

## 作者：栩笙丶 (赞：34)

# 大家好，我非常喜欢暴力数据结构，于是我就用分块过了这道题

首先这题其实就是每次交换两个数然后查询逆序对个数。

设交换的两个数下标为u,v(u<v) 那么显而易见的是

**交换u，v对1~(u-1)和(v+1)~n内的数是没有影响的**

那么我们考虑交换u,v对u+1~v-1内的数的影响

我们对于每次询问 **用上一次的答案加上交换u,v的影响，就是这次的答案**

设i为u~v中的一个数 则i对ans产生影响 **当且仅当下面四种情况**：

**当a[i]>a[u] ans++** **当a[i]<a[u] ans--**

**当a[i]<a[v] ans++** **当a[i]>a[v] ans--**

即当a[i]>a[u]时，交换u,v就会产生新的逆序对(i,u) 其余三组同理

**那么问题就变成了 在区间u+1~v-1内，有多少个数满足上述的四种条件**

然后就变成分块十分擅长的基本操作了。

网上关于分块的讲解很多 在此不细讲

~~当然这个题主席树套树状数组似乎也成吧 不成别打我 我yy的~~

下面贴code ~~连快读都没加就rank1了 欢迎大佬来踩爆我~~

```c
// luogu-judger-enable-o2
#include<bits/stdc++.h>
using namespace std;
int a[20010],b[20010],p[20010],ov[20010],ans;
int n,m,block,belong[20010],l[150],r[150],u,v;
void MergeSort(int L,int R){
    int M=(L+R)>>1;
    if(M > L) MergeSort( L ,M);
    if(M+1<R) MergeSort(M+1,R);
    int k=L,t1=L,t2=M+1;
    while(t1<=M&&t2<=R){
        if(b[t1]<=b[t2]){
            p[k++]=b[t1++];
        } else {
            ans+=M-t1+1;
            p[k++]=b[t2++];
        }
    }
    while(t1<=M) p[k++]=b[t1++];
    while(t2<=R) p[k++]=b[t2++];
    for(register int i=L;i<=R;i++) b[i]=p[i];
}
int main(){
    scanf("%d",&n); block=sqrt(n); 
    for(register int i=1;i<=n;i++) scanf("%d",&a[i]);
    for(register int i=1;i<=n;i++) b[i] = ov[i] = a[i];
    for(register int i=1;i<=n;i++) belong[i]=(i-1)/block+1;
    for(register int i=1;i<=n;i++) if(!l[belong[i]]) l[belong[i]]=i;
    for(register int i=n;i>=1;i--) if(!r[belong[i]]) r[belong[i]]=i;
    for(register int i=1;i<=belong[n];i++) sort(ov+l[i],ov+r[i]+1);
    MergeSort(1,n); printf("%d\n",ans); scanf("%d",&m);
    while(m--){
        scanf("%d%d",&u,&v);
        if(u>v) swap(u,v); 
        if(a[u]==a[v]){
            printf("%d\n",ans);
            continue;
        } else {
            if(a[u]>a[v]) ans--;
            if(a[v]>a[u]) ans++;
            if(belong[v]==belong[u]){
                for(register int i=u+1;i<v;i++){
                    ans+=(a[i]>a[u]);
                    ans-=(a[i]<a[u]);
                    ans+=(a[i]<a[v]);
                    ans-=(a[i]>a[v]);
                }
            } else {
                for(register int i=u+1;i<=r[belong[u]];i++){
                    ans+=(a[i]>a[u]);
                    ans-=(a[i]<a[u]);
                    ans+=(a[i]<a[v]);
                    ans-=(a[i]>a[v]);
                }
                for(register int i= l[belong[v]];i < v;i++){
                    ans+=(a[i]>a[u]);
                    ans-=(a[i]<a[u]);
                    ans+=(a[i]<a[v]);
                    ans-=(a[i]>a[v]);
                }
                for(register int i=belong[u]+1;i<=belong[v]-1;i++){
                	if(ov[l[i]]<a[u]){
                		int L=l[i],R=r[i],c=a[u];
                    	while(L!=R){
                    	    int M=(L+R)>>1;
                    	    if(ov[M]<c) L=M+1; else R=M;
                   		}
                    	if(L>=l[i]&&ov[L]>=c) L--;
                    	ans-=L-l[i]+1;	
                    }
                    if(ov[r[i]]>a[u]){
                    	int L=l[i],R=r[i],c=a[u];
                    	while(L!=R){
                       		int M=(L+R)>>1;
            	            if(ov[M]<=c) L=M+1; else R=M;
            	        }
                    	ans+=r[i]-R+1;
                    }
                    if(ov[l[i]]<a[v]){
                		int L=l[i],R=r[i],c=a[v];
                    	while(L!=R){
                    	    int M=(L+R)>>1;
                    	    if(ov[M]<c) L=M+1; else R=M;
                   		}
                    	if(L>=l[i]&&ov[L]>=c) L--;
                    	ans+=L-l[i]+1;	
                    }
                    if(ov[r[i]]>a[v]){
                    	int L=l[i],R=r[i],c=a[v];
                    	while(L!=R){
                       		int M=(L+R)>>1;
            	            if(ov[M]<=c) L=M+1; else R=M;
            	        }
                    	ans-=r[i]-R+1;
                    }
                }
                int L=l[belong[u]],R=r[belong[u]],M,c=a[u];
                while(L!=R){
                    M=(L+R)>>1;
                    if(ov[M]<c) L=M+1; else R=M;
                }
                int temp=L;ov[temp]=a[v];
                L=l[belong[u]],R=r[belong[u]];
                while(temp>L&&ov[temp]<ov[temp-1]) swap(ov[temp],ov[temp-1]),temp--;
                while(temp<R&&ov[temp]>ov[temp+1]) swap(ov[temp],ov[temp+1]),temp++;
                L=l[belong[v]],R=r[belong[v]],c=a[v];
                while(L!=R){
                    M=(L+R)>>1;
                    if(ov[M]<c) L=M+1; else R=M;
                }
                temp=L,ov[temp]=a[u];
                L=l[belong[v]],R=r[belong[v]];
                while(temp>L&&ov[temp]<ov[temp-1]) swap(ov[temp],ov[temp-1]),temp--;
                while(temp<R&&ov[temp]>ov[temp+1]) swap(ov[temp],ov[temp+1]),temp++;
            }
            swap(a[u],a[v]);
            printf("%d\n",ans);
        }
    }
    return 0;
}
```

---

## 作者：Dzhao (赞：17)

# 题解P1975

### [$Blog$](https://www.luogu.com.cn/blog/qshjydzh/solution-p1975)

我们先理解一下题意。（好吧其实~~没什么需要理解的~~）

我们需要一个在线修改并查询逆序对个数的数据结构。

逆序对大家都会，归并排序，离散化+线段树or树状数组都可以。但是，在线修改的逆序对问题，就有点困难了。

我们先感性分析一下这个玩意儿怎么求。

当我们交换$a[l]$和$a[r]$时，我们发现，这一个交换，与$[1,l]$和$[r,n]$这两个区间内的逆序对个数是没什么关系的，唯一相关的只有$[l+1,r-1]$这个区间内的逆序对个数有关。

原本能组成逆序对的只有：$a[r]$和$[l+1,r-1]$中比他大的，$a[l]$和$[l+1,r-1]$区间中比他小的。

我们类比一下，新添的逆序对个数就一定是：$a[r]$和$[l+1,r-1]$中比他小的，$a[l]$和$[l+1,r-1]$区间中比他大的。

最后，再特判一下：

如果$a[l]<a[r]$,那么$ans++$

如果$a[l]>a[r]$,那么$ans--$

问题解决了，下面问题来了，怎样解决上述的问题呢？

我们想一下，既要记录一个区间，有要记录其中比他小的数的个数，要实现一个双重功能，于是，一种数据结构跃入我们的脑中：树套树。（虽然分块大法也很棒，但是，我们尽量用在大数据下也依然不倒的数据结构。）

我们用树状数组的修改方式来套带权值的线段树,在带上一个动态开点就好了。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=20009;
int a[N],n,q,root[N],tot;
struct Segtree
{
	int lc,rc,v; //lc为左儿子节点号，rc为右儿子节点号 
}tree[N<<8];
inline void swap(int &x,int &y) {int tmp=x;x=y;y=tmp;}
inline int read()
{
	int flag=1,x=0;
	char ch=getchar();
	while(ch<'0' || ch>'9') {if(ch=='-') flag=-1;ch=getchar();}
	while(ch>='0' && ch<='9') x=x*10+ch-'0',ch=getchar();
	return x*flag;
}
inline int build() //动态开点，开一个点，假设他没有任何孩子且无权值 
{
	tot++;
	tree[tot].lc=tree[tot].rc=tree[tot].v=0;
	return tot;
}
void update(int &k,int l,int r,int x,int z) //修改操作 
{
	if(!k) k=build();
	if(l==r)
	{
		tree[k].v+=z;
		return;
	}
	int mid=(l+r)>>1;
	if(x<=mid) update(tree[k].lc,l,mid,x,z);
	else update(tree[k].rc,mid+1,r,x,z);
	tree[k].v=tree[tree[k].lc].v+tree[tree[k].rc].v;
}
int query(int k,int l,int r,int x,int y) //查询操作 
{
	if(!k) return 0; 
	if(l>y || r<x) return 0;
	if(l>=x && r<=y) return tree[k].v;
	int mid=(l+r)>>1;
	return query(tree[k].lc,l,mid,x,y)+query(tree[k].rc,mid+1,r,x,y);
}
inline void insert(int x,int y,int z) //用树状数组的方法插入 
{
	for(;x<=n;x+=x&-x) update(root[x],1,n,y,z);
}
inline int sum(int x,int y,int l,int r) //树状数组方式查询 
{
	int res=0;
	for(;y;y-=y&-y) res+=query(root[y],1,n,l,r);
	for(x--;x;x-=x&-x) res-=query(root[x],1,n,l,r);
	return res;
}
int b[N];

int main()
{
	int ans=0;
	n=read();
	for(int i=1;i<=n;i++) 
	{
		scanf("%d",&a[i]);
		b[i]=a[i];
	}
	/*-------------------------离散化-------------------------*/
	sort(b+1,b+n+1);
	int m=unique(b+1,b+n+1)-b-1;
	for(int i=1;i<=n;i++) a[i]=lower_bound(b+1,b+m+1,a[i])-b;
	/*-------------------------将该序列按树状数组方式插入线段树-------------------------*/
	for(int i=1;i<=n;i++) insert(i,a[i],1);
	for(int i=2;i<=n;i++) ans+=sum(1,i-1,a[i]+1,m);
	q=read(); 
	printf("%d\n",ans);
	while(q--)
	{
		int l=read(),r=read();
		if(l>r) swap(l,r);
		/*-------------------------计算变化后的逆序对个数-------------------------*/
		ans-=sum(l+1,r-1,1,a[l]-1);
		ans+=sum(l+1,r-1,a[l]+1,m);
		ans-=sum(l+1,r-1,a[r]+1,m);
		ans+=sum(l+1,r-1,1,a[r]-1);
		if(a[l]<a[r]) ans++;
		if(a[l]>a[r]) ans--;
		/*-------------------------修改-------------------------*/
		insert(l,a[l],-1);
		insert(l,a[r],1);
		insert(r,a[l],1);
		insert(r,a[r],-1);
		swap(a[l],a[r]);
		printf("%d\n",ans);
	}
	return 0;
} 
```

如果有任何问题，私信问我或评论区下问我都行。

$Thanks$ $for$ $watching$

---

## 作者：Limit (赞：10)

# 题目大意

给出一个序列 $h$,支持交换其中的两数,求出每一时刻的逆序对个数.

# 分析

求逆序对是 $O(N\log_2N)$ 的,有 $M$ 个操作,如果暴力求的话时间复杂度就是 $O(MN\log_2N)$ 虽然数据范围不大,但是还是可能因为评测机浮动而TLE,所以就不要想着折腾这些东西了,还是要用一些正经点的方法去过这种题.

求逆序对的方法大致可以分成两种:

1. 用一些数据结构维护大于某个数的数在这个数之前出现过几次,只需要将这些数一个一个放入就好了,优点很明显,可以计算出每个数对于结果的贡献,但是缺点也很致命,常数较大,如luogu上的[模板题](https://www.luogu.com.cn/problem/P1908)就过不了了.
2. 利用归并排序的性质来计算,但是这个方法中的每个数的贡献是无法单独计算的,跑起来确实会比第一种方法快.

第二种方法用在本题显然不合适,所以本题需要用第一种方法.

先不考虑交换两数有什么特殊的性质,单纯考虑删除一个数对于逆序对个数的影响([P3157 [CQOI2011]动态逆序对](https://www.luogu.com.cn/problem/P3157)).

因为是删除一个数,其影响到的只有其他数与它产生的逆序对,而产生逆序对的条件就是 $j<i$ 且 $a_j>a_i$,所以在这个数前面且大于它的数会和它产生一个逆序对,在这个数后面且小于它的数也会和它产生一个逆序对,那么问题就变成了计算前面有多少大于它的数,后面有多少小于它的数,不考虑范围的话可以直接用权值线段树解决,然而这里是一个区间问题+单点修改,那么就很容易想到利用树状数组维护前缀每个数出现的次数,只要差分一下就可以得出结果.

至于需要重新加上一个数那还是一样,只要找到前面大于这个数的个数,后面小于这个数的个数,相加就是这个数对于这个序列的逆序对个数产生的贡献,因为树状数组维护的是前缀,所以交换两数带来的良好性质自然也没什么用了,但是,为了让这个没什么用的性质看似有用一点,还是放[一道可以用这个性质的题](https://www.luogu.com.cn/problem/P3939).

# 代码

```cpp
#include<bits/stdc++.h>
#define REP(i,first,last) for(int i=first;i<=last;++i)
#define DOW(i,first,last) for(int i=first;i>=last;--i)
using namespace std;
const int MAXN=114514;
int N,M;
int arr[MAXN];
int tot=0;
map<int,int>Hash;//用于离散化
int sor[MAXN];//用于离散化
int root[MAXN];//树状数组上每个位置的线段树的根节点
long long answer=0;
//线段树部分
struct SegmentTree
{
	int sum,lson,rson;
}sgt[MAXN*32];
int sgt_cnt=0;
#define LSON sgt[now].lson
#define RSON sgt[now].rson
#define MIDDLE ((left+right)>>1)
#define LEFT LSON,left,MIDDLE
#define RIGHT RSON,MIDDLE+1,right
void PushUp(int now)//合并信息
{
	sgt[now].sum=sgt[LSON].sum+sgt[RSON].sum;
}
void Updata(int num,int add,int &now,int left=1,int right=tot)//修改操作,和普通动态开点权值线段树相同
{
	if(num<left||right<num)//不包含修改位置就返回
	{
		return;
	}
	if(!now)//如果当前位置没有节点就新建一个节点
	{
		now=++sgt_cnt;
	}
	if(left==right)//到叶节点就直接修改
	{
		sgt[now].sum+=add;
		return;
	}
	//继续修改
	Updata(num,add,LEFT);
	Updata(num,add,RIGHT);
	PushUp(now);
}
int num_add,num_dec;
int add_sgt[MAXN],dec_sgt[MAXN];//树状数组来维护,需要用到差分,需要记录下当前需要加上的线段树的当前根节点的编号,以及需要减去的线段树的当前编号
int GetSum()//得到当期范围中的数的个数,和树状数组计算区间和同理
{
	int result=0;
	REP(i,1,num_add)
	{
		result+=sgt[add_sgt[i]].sum;
	}
	REP(i,1,num_dec)
	{
		result-=sgt[dec_sgt[i]].sum;
	}
	return result;
}
//左右子树中的数的个数计算方法同理
int GetSumL()
{
	int result=0;
	REP(i,1,num_add)
	{
		result+=sgt[sgt[add_sgt[i]].lson].sum;
	}
	REP(i,1,num_dec)
	{
		result-=sgt[sgt[dec_sgt[i]].lson].sum;
	}
	return result;
}
int GetSumR()
{
	int result=0;
	REP(i,1,num_add)
	{
		result+=sgt[sgt[add_sgt[i]].rson].sum;
	}
	REP(i,1,num_dec)
	{
		result-=sgt[sgt[dec_sgt[i]].rson].sum;
	}
	return result;
}
//将当前的根节点变为左子节点
void GetRootL()
{
	REP(i,1,num_add)
	{
		add_sgt[i]=sgt[add_sgt[i]].lson;
	}
	REP(i,1,num_dec)
	{
		dec_sgt[i]=sgt[dec_sgt[i]].lson;
	}
}
//变为右子节点
void GetRootR()
{
	REP(i,1,num_add)
	{
		add_sgt[i]=sgt[add_sgt[i]].rson;
	}
	REP(i,1,num_dec)
	{
		dec_sgt[i]=sgt[dec_sgt[i]].rson;
	}
}
int QuerySmall(int num,int left=1,int right=tot)//查询小于的数的个数,计算方法和权值线段树同理,不多讲
{
	if(num<=left)
	{
		return 0;
	}
	if(right<num)
	{
		return GetSum();
	}
	if(num<=MIDDLE)
	{
		GetRootL();
		return QuerySmall(num,left,MIDDLE);
	}
	int result=GetSumL();
	GetRootR();
	return result+QuerySmall(num,MIDDLE+1,right);
}
int QueryBig(int num,int left=1,int right=tot)//计算大于的数的个数,同理
{
	if(right<=num)
	{
		return 0;
	}
	if(left>num)
	{
		return GetSum();
	}
	if(MIDDLE+1<=num)
	{
		GetRootR();
		return QueryBig(num,MIDDLE+1,right);
	}
	int result=GetSumR();
	GetRootL();
	return result+QueryBig(num,left,MIDDLE);
}
#undef LSON
#undef RSON
#undef MIDDLE
#undef LEFT
#undef RIGHT
int Lowbit(int now)//树状数组要用的lowbit
{
	return now&-now;
}
void BeforeQuery(int left,int right)//在查询前的预处理,将需要加上的线段树的根节点和需要减去的线段树的根节点编号记录下来
{
	num_add=0,num_dec=0;
	for(int now=right;now;now-=Lowbit(now))
	{
		add_sgt[++num_add]=root[now];
	}
	for(int now=left-1;now;now-=Lowbit(now))
	{
		dec_sgt[++num_dec]=root[now];
	}
}
int Small(int num,int left,int right)//查询区间内小于的数的个数
{
	BeforeQuery(left,right);
	return QuerySmall(num);
}
int Big(int num,int left,int right)//查询区间内大于的数的个数
{
	BeforeQuery(left,right);
	return QueryBig(num);
}
void Change(int p1,int p2)//交换两数,就是删掉一个数,再放上一个数的操作最两遍
{
	int ha=arr[p1];
	int hb=arr[p2];
	answer-=Big(ha,1,p1-1)+Small(ha,p1+1,N);//删除一个数所减去的贡献
	for(int now=p1;now<=N;now+=Lowbit(now))//在线段树中减去这个数
	{
		Updata(ha,-1,root[now]);
	}
	answer+=Big(hb,1,p1-1)+Small(hb,p1+1,N);//同理加上这个数
	for(int now=p1;now<=N;now+=Lowbit(now))
	{
		Updata(hb,1,root[now]);
	}
	answer-=Big(hb,1,p2-1)+Small(hb,p2+1,N);
	for(int now=p2;now<=N;now+=Lowbit(now))
	{
		Updata(hb,-1,root[now]);
	}
	answer+=Big(ha,1,p2-1)+Small(ha,p2+1,N);
	for(int now=p2;now<=N;now+=Lowbit(now))
	{
		Updata(ha,1,root[now]);
	}
	swap(arr[p1],arr[p2]);
}
int main()
{
	scanf("%d",&N);
	REP(i,1,N)
	{
		scanf("%d",&arr[i]);
		sor[i]=arr[i];
	}
	sort(sor+1,sor+1+N);//离散化
	sor[0]=114514233;
	REP(i,1,N)
	{
		if(sor[i]!=sor[i-1])
		{
			Hash[sor[i]]=++tot;
		}
	}
	REP(i,1,N)//逆序对的计算中只需要考虑相对大小,所以不需要保留原来的值
	{
		arr[i]=Hash[arr[i]];
	}
	REP(i,1,N)//建树
	{
		for(int now=i;now<=N;now+=Lowbit(now))
		{
			Updata(arr[i],1,root[now]);
		}
	}
	REP(i,2,N)//计算最开始的逆序对
	{
		answer+=Big(arr[i],1,i-1);
	}
	printf("%lld\n",answer);//记得输出最开始的逆序对个数
	scanf("%d",&M);
	int l,r;
	REP(i,1,M)
	{
		scanf("%d%d",&l,&r);
		Change(l,r);
		printf("%lld\n",answer);
	}
	return 0;
}
```

---

## 作者：CmsMartin (赞：6)

## 题目描述

[题目传送门](https://www.luogu.com.cn/problem/P1975)

## 思路

[更好的阅读体验](http://www.cmsblog.top/archives/-guo-jia-ji-xun-dui--pai-dui)

对于交换 $i , j$ 的数字，我们考虑交换这两个数字（记这两个数字分别为 $a,b$）对答案的贡献。

显然，对于区间 $[i+1,j-1]$ 中每一个大于 $a$ 的数字会产生 $+1$ 的贡献，每一个小于 $a$ 的数字会产生 $-1$ 的贡献，每一个小于 $b$ 的数字会产生 $+1$ 的贡献，每一个大于 $b$ 的数字会产生 $-1$ 的贡献。最后还有 $a$ 与 $b$ 是否为逆序对的贡献。

显然，我们需要求出区间中大（小）于一个数字的个数。这个问题可以使用树套树~~或暴力~~解决，但是在此处讲一种别致的分块。

对数列进行离散化，数的大小的值域为 $1 \sim n$。我们不妨在数列分块中在套上一个值域分块。记 `Cnt1[x][y]` 表示前 $x$ 块的数列中值域在第 $y$ 块出现的次数，记 `Cnt2[x][y]`  表示前 $x$ 块的数列中数字 $y$，记 `Bel[i]` 表示数字 $i$ 所对应的块，由于值域和块大小是同阶的，所以这个数组既可以表示数列对应的块，也可以表示数值对应的块。

一下的操作仅讨论查询小于一个数的个数，大于一个数字同理。

查询：设查询小于的数字为 $k$，块大小为 `block_size`。对于数列中的块外元素，暴力解决，时间复杂度 $O(\sqrt n)$。数列中的块内元素我们再此分为两类，第一类为完整值域中出现，即值域 `Bel[0]` $\sim$ `Bek[k]-1`，这个利用 `Cnt1` 前缀相减可以在 $O(\sqrt n)$ 的时间内算完；第二类为不在完整块内的，即数值 `(Bel[k]-1)*block_size+1` $\sim k$，这个利用 `Cnt2` 前缀相减可以在 $O(\sqrt n)$ 的时间内算完。总时间复杂度为 $O(\sqrt n)$。

交换：将 `Cnt1[][Bel[a]],Cnt1[][Bel[b]],Cnt2[][a],Cnt2[][a]` 四个数组总后往前差分即可得到每一块的数，修改对应的值并维护然后做前缀和就好了。这里有个细微的优化，差分（前缀）只需从 `Bel[j]` 到 `Bel[i]` 就可以了。由于块的数量不超过根号，所以时间复杂度为 $O(\sqrt n)$。

显然，`Cnt1` 可以 $O(n)$ 预处理， `Cnt2` 可以 $O(n\sqrt n)$ 预处理。至此，我们就已经在 $O(n \sqrt n)$ 的时间复杂度内 AC。

这个思路来自于 [[Ynoi2018] 未来日记](https://www.luogu.com.cn/problem/P4119) 的启发。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

char gc() {
    static char now[1 << 20], *S, *T;
    if (T == S) {
        T = (S = now) + std::fread(now, 1, 1 << 20, stdin);
        if (T == S) return EOF;
    }
    return *S++;
}
template <typename T>
void read(T &x) {
    x = 0;
    char c = gc();
    while (c < '0' || c > '9') c = gc();
    x = c - '0';
    while ((c = gc()) >= '0' && c <= '9') x = x * 10 + c - '0';
}
template <typename T, typename... Args>
void read(T &x, Args &...args) {
    read(x);
    read(args...);
}

const int MAXN = 20010;

int Num[MAXN] , Temp[MAXN] , N , M , Num2[MAXN] , l , r , Block;

long long Sum;

int Cnt1[600][600];
int Cnt2[600][MAXN];

int Left[600] , Right[600] , Bel[MAXN];

void Merge(int l1 , int r1 , int l2 , int r2) {
	int ToT = 0;
	while(l1 <= r1 && l2 <= r2) {
		if(Num[l1] <= Num[l2]) {
			Temp[++ToT] = Num[l1++];
		}
		else {
			Temp[++ToT] = Num[l2++];
			Sum += r1 - l1 + 1;
		}
	}
	while(l1 <= r1) Temp[++ToT] = Num[l1++];
	while(l2 <= r2) Temp[++ToT] = Num[l2++];
	
	for(int i = ToT , j = r2; i >= 1; i--, j--) {
        Num[j] = Temp[i];
    }
}

void MergeSort(int l , int r) {
	if(l < r) {
		int Mid = l + r >> 1;
		MergeSort(l , Mid);
		MergeSort(Mid + 1 , r);
		Merge(l , Mid , Mid + 1 , r);
	}
}

int Query1(int l , int r , int k) { //查找 < k 的数的个数 
	int Bel_R = Bel[r] , Bel_L = Bel[l];
	
	if(Bel_L == Bel_R) {
		int res = 0;
		
		for(int i = l; i <= r; i++) {
			if(Num2[i] < k) res++;
		}
		
		return res;
	}
	else {
		int res = 0;
		
		for(int i = l; i <= Right[Bel_L]; i++) {
			if(Num2[i] < k) res++;
		}
		
		for(int i = 0; i < Bel[k]; i++) {
			res += Cnt1[Bel_R - 1][i] - Cnt1[Bel_L][i];
		}
		for(int i = (Bel[k] - 1) * Block + 1; i < k; i++) {
			res += Cnt2[Bel_R - 1][i] - Cnt2[Bel_L][i];
		}
		
		for(int i = Left[Bel_R]; i <= r; i++) {
			if(Num2[i] < k) res++;
		}
		
		return res;
	}
}

int Query2(int l , int r , int k) { //查找 > k 的数的个数 
	int Bel_R = Bel[r] , Bel_L = Bel[l];
	
	if(Bel_L == Bel_R) {
		int res = 0;
		
		for(int i = l; i <= r; i++) {
			if(Num2[i] > k) res++;
		}
		
		return res;
	}
	else {
		int res = 0;
		
		for(int i = l; i <= Right[Bel_L]; i++) {
			if(Num2[i] > k) res++;
		}
		
		for(int i = Bel[N]; i > Bel[k]; i--) {
			res += Cnt1[Bel_R - 1][i] - Cnt1[Bel_L][i];
		}
		for(int i = min(Bel[k] * Block , 20000); i > k; i--) {
			res += Cnt2[Bel_R - 1][i] - Cnt2[Bel_L][i];
		}
		
		for(int i = Left[Bel_R]; i <= r; i++) {
			if(Num2[i] > k) res++;
		}
		
		return res;
	}
}

void Swap(int l , int r) {
	int x = Num2[l] , y = Num2[r];
	
	int Bel_R = Bel[r] , Bel_L = Bel[l];
	
	for(int i = Bel[N]; i >= Bel_L; i--) {
		Cnt1[i][Bel[x]] -= Cnt1[i - 1][Bel[x]];
		Cnt1[i][Bel[y]] -= Cnt1[i - 1][Bel[y]];
		Cnt2[i][x] -= Cnt2[i - 1][x];
		Cnt2[i][y] -= Cnt2[i - 1][y];
	}
	
	Cnt1[Bel_L][Bel[y]]++;
	Cnt1[Bel_L][Bel[x]]--;
	Cnt2[Bel_L][y]++;
	Cnt2[Bel_L][x]--;
	
	Cnt1[Bel_R][Bel[y]]--;
	Cnt1[Bel_R][Bel[x]]++;
	Cnt2[Bel_R][y]--;
	Cnt2[Bel_R][x]++;
	
	for(int i = Bel_L; i <= Bel[N]; i++) {
		Cnt1[i][Bel[x]] += Cnt1[i - 1][Bel[x]];
		Cnt1[i][Bel[y]] += Cnt1[i - 1][Bel[y]];
		Cnt2[i][x] += Cnt2[i - 1][x];
		Cnt2[i][y] += Cnt2[i - 1][y];
	}
	
	swap(Num2[l] , Num2[r]);
}

int main() {
	scanf("%d" ,&N);
	
	Block = sqrt(N);
	
	for(int i = 1; i <= N; i++) {
		scanf("%d" ,&Num[i]);
		Num2[i] = Num[i];
	}
	
	for(int i = 1; i <= 20000; i++) {
		Bel[i] = (i - 1) / Block + 1;
	}
	MergeSort(1 , N);
	
	int Size = unique(Num + 1 , Num + 1 + N) - Num - 1;
	
	for(int i = 1; i <= N; i++) {
		Num2[i] = lower_bound(Num + 1 , Num + 1 + Size , Num2[i]) - Num;
	}
	
	for(int i = 1; i <= Bel[N]; i++) {
		Left[i] = Right[i - 1] + 1;
		Right[i] = i * Block;
	}

	Right[Bel[N]] = N;
	
	for(int i = 1; i <= Bel[N]; i++) {
		for(int j = 1; j <= Bel[N]; j++) {
			Cnt1[i][j] = Cnt1[i - 1][j];
		}
		
		for(int j = 1; j <= N; j++) {
			Cnt2[i][j] = Cnt2[i - 1][j];
		}
		
		for(int j = Left[i]; j <= Right[i]; j++) {
			Cnt1[i][Bel[Num2[j]]]++;
			Cnt2[i][Num2[j]]++;
		}
	}
	
	scanf("%d" ,&M);
	
	printf("%lld\n" ,Sum);
	

	while(M--) {
		scanf("%d%d" ,&l ,&r);
		
		if(l > r) swap(l , r);
		
		Sum = Sum - Query1(l + 1 , r - 1 , Num2[l]) + Query2(l + 1 , r - 1 , Num2[l]) + Query1(l + 1 , r - 1 , Num2[r]) - Query2(l + 1 , r - 1 , Num2[r]);
		if(Num2[r] > Num2[l]) Sum++;
		if(Num2[r] < Num2[l]) Sum--;
		
		Swap(l , r);
		
		printf("%lld\n" ,Sum);
	}
	return 0;
}
```

---

## 作者：chengni (赞：6)

思路：根据 $x$ 和 $y$ 之间的数和上一次得到的答案来推出本次的答案

因为 $x$ 左面和 $y$ 右面（默认$x<y$）的数是不会影响答案的，我们只需要考虑 $x+1$ 到 $y-1$ 里的数和 $x$ 与 $y$ 的大小关系，这个应该很显然吧

简单来说，求中间这段区间中小于 $a_x$ 大于 $a_x$ ，小于 $a_y$，大于$a_y$ 的数有多少 ，然后以上次答案为基础分别处理得到新的答案
 
$tips:$ 注意 $x$ 和 $y$ 两个点之间也会有影响 
 
## 分块

考虑分块来做，对于每一个块内部都排好序，然后先归并排序求出最开始的逆序对。对于每次询问，我们可以通过块内二分查找，块外暴力统计的方法来得到答案。

然后交换位置并在各自块内部排序一下即可

```cpp
int main(){
    n=read();
    for(int i=1;i<=n;i++){
        a[i]=read();
        c[i]=a[i];
        b[i]=a[i];
    }
    merge(1,n);
    cout<<ans<<endl;
    int k=sqrt(n);
    int nn=n/k;
    if(n%k!=0) nn++;
    for(int i=1;i<=n;i++){
        bel[i]=i/k;
        if(i%k!=0) bel[i]++;
        if(l[bel[i]]==0){
            l[bel[i]]=i;
        }
        r[bel[i]]=i;
    }
    for(int i=1;i<=nn;i++){
        sort(b+l[i],b+r[i]+1);
    }
    int m=read();
    while(m--){
        int x=read(),y=read();
        if(x==y){
            cout<<ans<<endl;
            continue;
        }
        if(a[x]==a[y]){
            cout<<ans<<endl;
            continue;
        }
        if(x>y) swap(x,y);
        if(a[x]<a[y]) ans++;
        else ans--;
        int lx=bel[x],rx=bel[y];
        if(lx==rx){
            for(int i=x+1;i<y;i++){
                if(a[i]<a[x]) ans--;
                if(a[i]>a[x]) ans++;
                if(a[i]<a[y]) ans++;
                if(a[i]>a[y]) ans--;
            }
        }
        else{
            for(int i=x+1;i<=r[lx];i++){
                if(a[i]<a[x]) ans--;
                if(a[i]>a[x]) ans++;
                if(a[i]<a[y]) ans++;
                if(a[i]>a[y]) ans--;
            }
            for(int i=l[rx];i<y;i++){
                if(a[i]<a[x]) ans--;
                if(a[i]>a[x]) ans++;
                if(a[i]<a[y]) ans++;
                if(a[i]>a[y]) ans--;
            }
            for(int i=bel[x]+1;i<=bel[y]-1;i++){
                if(b[l[i]]<a[x]){
                    int ll=l[i],rr=r[i];
                    while(ll!=rr){
                        int mid=ll+rr>>1;
                        if(b[mid]<a[x]) ll=mid+1;
                        else rr=mid;
                    }
                    if(ll>=l[i] && b[ll]>=a[x]) ll--;
                    ans-=ll-l[i]+1;
                }
                if(b[r[i]]>a[x]){
                    int ll=l[i],rr=r[i];
                    while(ll!=rr){
                        int mid=ll+rr>>1;
                        if(b[mid]<=a[x]) ll=mid+1;
                        else rr=mid;
                    }
                    ans+=r[i]-rr+1;
                }
                if(b[l[i]]<a[y]){
                    int ll=l[i],rr=r[i];
                    while(ll!=rr){
                        int mid=ll+rr>>1;
                        if(b[mid]<a[y]) ll=mid+1;
                        else rr=mid;
                    }
                    if(ll>=l[i] && b[ll]>=a[y]) ll--;
                    ans+=ll-l[i]+1;
                }
                if(b[r[i]]>a[y]){
                    int ll=l[i],rr=r[i];
                    while(ll!=rr){
                        int mid=ll+rr>>1;
                        if(b[mid]<=a[y]) ll=mid+1;
                        else rr=mid;
                    }
                    ans-=r[i]-rr+1;
                }
            }
        }
        swap(a[x],a[y]);
        for(int i=l[bel[x]];i<=r[bel[x]];i++){
           	b[i]=a[i];
        }
        for(int i=l[bel[y]];i<=r[bel[y]];i++){
            b[i]=a[i];
        }
        sort(b+l[bel[x]],b+r[bel[x]]+1);
        sort(b+l[bel[y]],b+r[bel[y]]+1);
        cout<<ans<<endl;
    }
```

### 树套树

这里并没有关于树套树的详细讲解，只有大概思路

对于一棵线段树，他的每个结点都是一棵平衡树，平衡树里是该结点所表示区间里的所有数

大概像这个图一样（图丑勿喷）

![](https://cdn.luogu.com.cn/upload/pic/52319.png)

我们求一个区间内有多少个数小于 $x$ ，可以把它拆成几个区间，分别计算再加和起来，我们按照这个方法来解决问题

同样先归并排序，然后对于每次询问我们将这个区间在线段树上分成几个小区间，再利用平衡树得到我们需要的信息进行修改即可

详情看代码吧

```cpp
int n,m;
int a[2020202];
int ans,mx,tot,cnt;

struct node{
    int size,cnt;
    int ch[3];
    int fa;
    int val;
}t[4040404];

int rt[4040404]; 

void pushup(int p){
    t[p].size=t[t[p].ch[0]].size+t[t[p].ch[1]].size+t[p].cnt;
}

void rotate(int x){
    int y=t[x].fa,z=t[y].fa;
    int k=(t[y].ch[1]==x);
    t[z].ch[y==t[z].ch[1]]=x;
    t[x].fa=z;
    t[y].ch[k]=t[x].ch[k^1];
    t[t[x].ch[k^1]].fa=y;
    t[x].ch[k^1]=y;
    t[y].fa=x;
    pushup(y);pushup(x);
}

void splay(int i,int x,int goal){
    while(t[x].fa!=goal){
        int y=t[x].fa;
        int z=t[y].fa;
        if(z!=goal){
            (t[z].ch[0]==y)^(t[y].ch[0]==x)?rotate(x):rotate(y);
        }
        rotate(x);
    }
    if(goal==0){
        rt[i]=x;
    }
}


void insert(int i,int x){
    int u=rt[i],ff=0;
    if(rt[i]==0){
    	rt[i]=u=++cnt;
    	t[u].val=x;
    	t[u].cnt=t[u].size=1;
    	t[u].fa=t[u].ch[0]=t[u].ch[1]=0;
    	return;
    }
    while(u && t[u].val!=x){
        ff=u;
        u=t[u].ch[x>t[u].val];
    }
    if(u){
        t[u].cnt++;
    }
    else{
        u=++cnt;
        if(ff){
            t[ff].ch[x>t[ff].val]=u;
        }
        t[u].fa=ff;
        t[u].val=x;
        t[u].cnt=t[u].size=1;
        t[u].ch[0]=t[u].ch[1]=0;
    }
    splay(i,u,0);
}

int getrank(int i,int v){
    int u=rt[i],res=0;
    while(u){
        if(t[u].val==v) return res+t[t[u].ch[0]].size;
        if(t[u].val<v){
            res+=t[u].cnt+t[t[u].ch[0]].size;
            u=t[u].ch[1];
        }
        else u=t[u].ch[0];
    }
    return res;
}


void clear(int i){
    t[i].ch[0]=t[i].ch[1]=t[i].fa=t[i].size=t[i].val=t[i].cnt=0;
}

int find(int i,int v){
    int x=rt[i];
    while(x){
        if(t[x].val==v){
            splay(i,x,0);
            return x;
        }
        x=t[x].ch[v>t[x].val];
    }
}

int pre(int i){
    int x=t[rt[i]].ch[0];
    while(t[x].ch[1]){
        x=t[x].ch[1];
    }
    return x;
}

void del(int i,int w){
    int x=find(i,w);
    if(t[x].cnt>1){
        t[x].cnt--;
        pushup(x);
        return;
    }
    if(t[x].ch[0]==0 && t[x].ch[1]==0){
        clear(rt[i]);
        rt[i]=0;
        return;
    }
    if(t[x].ch[0]==0){
        int y=t[x].ch[1];
        rt[i]=y;
        t[y].fa=0;
        return;
    }
    if(t[x].ch[1]==0){
        int y=t[x].ch[0];
        rt[i]=y;
        t[y].fa=0;
        return;
    }
    int p=pre(i);
    int old=rt[i];
    splay(i,p,0);
    t[rt[i]].ch[1]=t[old].ch[1];
    t[t[old].ch[1]].fa=rt[i];
    clear(old);
    pushup(rt[i]);
}

//-------------------------------------------------------

void segrank(int p,int l,int r,int x,int y,int v){
    if(x<=l && y>=r) {
        ans+=getrank(p,v);
        return;
    }
    int mid=l+r>>1;
    if(x<=mid){
        segrank(p<<1,l,mid,x,y,v);
    }
    if(y>mid){
        segrank(p<<1|1,mid+1,r,x,y,v);
    }
}

void segadd(int p,int l,int r,int x,int w){
    insert(p,w);
    if(l==r){
        return ;
    }
    int mid=l+r>>1;
    if(x<=mid) segadd(p<<1,l,mid,x,w);
    else segadd(p<<1|1,mid+1,r,x,w);
}
void segchange(int p,int l,int r,int x,int w){
    del(p,a[x]);insert(p,w);
    if(l==r){
        a[x]=w;
        return;
    }
    int mid=l+r>>1;
    if(x<=mid) segchange(p<<1,l,mid,x,w);
    else segchange(p<<1|1,mid+1,r,x,w);

}

int sum=0;
int c[2020022],gb[2020202];

void merge(int l,int r){
    if(l>=r) return;
    int mid=l+r>>1;
    merge(l,mid);
    merge(mid+1,r);
    int k=l,t1=l,t2=mid+1;
    while(t1<=mid && t2<=r){
        if(c[t1]<=c[t2]){
            gb[k++]=c[t1++];
        }
        else{
            sum+=mid-t1+1;
            gb[k++]=c[t2++];
        }
    }
    while(t1<=mid){
        gb[k++]=c[t1++];
    }
    while(t2<=r){
        gb[k++]=c[t2++];
    }
    for(int i=l;i<=r;i++){
        c[i]=gb[i];
    }
}


int main(){
    n=read();
    for(int i=1;i<=n;i++){
        a[i]=read();
        c[i]=a[i];
        segadd(1,1,n,i,a[i]);
    }
    merge(1,n);
    cout<<sum<<endl;
    int m=read();
    while(m--){
    	int x=read(),y=read();
    	if(x==y) {
    		cout<<sum<<endl;
    		continue;
        }
    	if(a[x]==a[y]) {
    		cout<<sum<<endl;
    		continue;
        }
        if(x>y) swap(x,y);
        if(a[x]<a[y]) sum++;
        else sum--;
        ans=0;
        segrank(1,1,n,x+1,y-1,a[x]);
        sum-=ans;
        ans=0;
        segrank(1,1,n,x+1,y-1,a[x]+1);
        sum+=(y-x+1-ans);
        ans=0;
        segrank(1,1,n,x+1,y-1,a[y]);
        sum+=ans;
        ans=0;
        segrank(1,1,n,x+1,y-1,a[y]+1);
        sum-=(y-x+1-ans);
        int xa=a[x],ya=a[y];
        segchange(1,1,n,x,ya);
        segchange(1,1,n,y,xa);
        cout<<sum<<endl;
    }
    return 0;
}
```
当然这里我们可以用权值线段树来代替平衡树。

权值线段树还可以求前驱后继，个人觉得挺好使的。

```cpp
int n,m;
int ans;
int ls[20200020],rs[20200020],val[20200020]; 
int rt[20400040];
int a[2200022];
int cnt=0;
//权值线段树部分

inline void add(int &p,int l,int r,int v){
    if(p==0){
        cnt++;p=cnt;
    }
    val[p]++;
    if(l==r){
        return;
    }
    int mid=l+r>>1;
    if(v<=mid) add(ls[p],l,mid,v);
    else add(rs[p],mid+1,r,v);
}

inline void del(int &p,int l,int r,int v){
    val[p]--;
    if(l==r){
        return;
    }
    int mid=l+r>>1;
    if(v<=mid) del(ls[p],l,mid,v);
    else del(rs[p],mid+1,r,v);
}

inline int qsum(int p,int l,int r,int x,int y){
    if(x<=l && y>=r){
        return val[p];
    }
    if(p==0) return 0;
    int mid=l+r>>1;
    int ans=0;
    if(x<=mid) ans+=qsum(ls[p],l,mid,x,y);
    if(y>mid) ans+=qsum(rs[p],mid+1,r,x,y);
    return ans;
}


//第一层线段树部分 

inline void segadd(int p,int l,int r,int x,int v){
    add(rt[p],0,1e9+1,v);
    if(l==r){
        return;
    }
    int mid=l+r>>1;
    if(x<=mid) segadd(p<<1,l,mid,x,v);
    else segadd(p<<1|1,mid+1,r,x,v);
}

inline void segwork1(int p,int l,int r,int x,int y,int k){
    if(x<=l && y>=r){
        ans+=qsum(rt[p],0,1e9+1,1,k-1);
        return;
    }
    int mid=l+r>>1;
    if(x<=mid) segwork1(p<<1,l,mid,x,y,k);
    if(y>mid) segwork1(p<<1|1,mid+1,r,x,y,k);
}

inline void segwork3(int p,int l,int r,int x,int v){
    del(rt[p],0,1e9+1,a[x]);
    add(rt[p],0,1e9+1,v);
    if(l==r){
        return;
    }
    int mid=l+r>>1;
    if(x<=mid) segwork3(p<<1,l,mid,x,v);
    else segwork3(p<<1|1,mid+1,r,x,v);
}


int sum=0;
int c[2020022],gb[2020202];

void merge(int l,int r){
	if(l>=r) return;
	int mid=l+r>>1;
	merge(l,mid);
	merge(mid+1,r);
	int k=l,t1=l,t2=mid+1;
	while(t1<=mid && t2<=r){
		if(c[t1]<=c[t2]){
			gb[k++]=c[t1++];
		}
		else{
			sum+=mid-t1+1;
			gb[k++]=c[t2++];
		}
	}
	while(t1<=mid){
		gb[k++]=c[t1++];
	}
	while(t2<=r){
		gb[k++]=c[t2++];
	}
	for(int i=l;i<=r;i++){
		c[i]=gb[i];
	}
}

int main(){
    n=read();
    for(int i=1;i<=n;i++){
        a[i]=read();
        segadd(1,1,n,i,a[i]);
        c[i]=a[i];
    }
    merge(1,n);
    cout<<sum<<endl;
    int m=read();
    while(m--){
    	int x=read(),y=read();
    	if(x==y) {
    		cout<<sum<<endl;
    		continue;
		}
    	if(a[x]==a[y]) {
    		cout<<sum<<endl;
    		continue;
		}
		if(x>y) swap(x,y);
		if(a[x]<a[y]) sum++;
		else sum--;
		ans=0;
		segwork1(1,1,n,x+1,y-1,a[x]);
		sum-=ans;
		ans=0;
		segwork1(1,1,n,x+1,y-1,a[x]+1);
		sum+=(y-x+1-ans);
		ans=0;
		segwork1(1,1,n,x+1,y-1,a[y]);
		sum+=ans;
		ans=0;
		segwork1(1,1,n,x+1,y-1,a[y]+1);
		sum-=(y-x+1-ans);
		int xa=a[x],ya=a[y];
		segwork3(1,1,n,x,ya);
		segwork3(1,1,n,y,xa);
		a[y]=xa;
		a[x]=ya;
		cout<<sum<<endl;
	}
    return 0;
}
```

代码有点丑，请见谅




---

## 作者：Genius_Z (赞：5)

这题怎么能没有$CDQ$分治的题解呢？

显然这题是一个三维偏序问题，和那几道动态逆序对同理，用CDQ分治非常的好写。

一次交换操作的贡献就可以看成两次插入和两次删除

其他就和动态逆序对一样了，统计答案要前缀和，还有这题值域$1e9$，要离散化。

为了减小常数把$sort$换成了归并排序

Code：

```cpp
#pragma region revive
#include <algorithm>
#include <bitset>
#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <map>
#include <queue>
#include <set>
#include <vector>
#define inl inline
#define re register int
#define fa(x) t[x].fa
#define ls(x) t[x].child[0]
#define rs(x) t[x].child[1]
#define ll long long
#define mid ((l) + (r) >> 1)
const int inf = 0x3f3f3f3f;
#define lowbit(x) ((x) & (-x))
using namespace std;
template <class Read>
inl Read read() {
	Read x = 0;
	register bool w = 0;
	register char c = getchar();
	while (c > '9' || c < '0') {
		if (c == '-')
			w = 1;
		c = getchar();
	}
	while (c >= '0' && c <= '9') {
		x = (x << 3) + (x << 1) + (c ^ 48);
		c = getchar();
	}
	return w ? -x : x;
}
#pragma endregion
struct quiz {
	int v, w, poi, id;
} q[5000001], tmp[5000001];
int ans[100001], a[100001], t[100001], b[100001], n, tot, m;
inl void add(int x, int w) {
	for (; x <= n; x += lowbit(x))t[x] += w;
}
inl int query(int x) {
	re sum = 0;
	for (; x; x -= lowbit(x))sum += t[x];
	return sum;
}
inl void cdq(int l, int r) {
	if (l == r) return;
	re lp = l, rp = mid + 1, o = l;
	cdq(l, mid), cdq(mid + 1, r);
	while (rp <= r) {
		while (lp <= mid && q[rp].poi >= q[lp].poi) add(q[lp].w, q[lp].v), tmp[o++] = q[lp++];
		ans[q[rp].id] += q[rp].v * (query(n) - query(q[rp].w)), tmp[o++] = q[rp++];
	}
	for (re i = l; i < lp; i++)add(q[i].w, -q[i].v);
	while (lp <= mid) tmp[o++] = q[lp++];
	lp = mid, rp = r;
	while (rp > mid) {
		while (lp >= l && q[rp].poi <= q[lp].poi)add(q[lp].w, q[lp].v), lp--;
		ans[q[rp].id] += q[rp].v*query(q[rp].w - 1), rp--;
	}
	for (re i = lp + 1; i <= mid; i++)add(q[i].w, -q[i].v);
	for (re i = l; i <= r; i++) q[i] = tmp[i];
}
signed main() {
	n = read<int>();
	for (re i = 1; i <= n; i++) {
		q[++tot] = quiz{ 1, a[i] = b[i] = read<int>(), i, 0 };
	}
	sort(b + 1, b + 1 + n);
	re siz = unique(b + 1, b + 1 + n) - b;
	for (re i = 1; i <= n; i++) {
		q[i].w = a[i] = lower_bound(b + 1, b + siz, a[i]) - b;
	}
	m = read<int>();
	for (re i = 1; i <= m; i++) {
		re x = read<int>(), y = read<int>();
		q[++tot] = quiz{ -1, a[x], x, i };
		q[++tot] = quiz{ -1, a[y], y, i };
		swap(a[x], a[y]);
		q[++tot] = quiz{ 1, a[x], x, i };
		q[++tot] = quiz{ 1, a[y], y, i };
	}
	cdq(1, tot);
	for (re i = 1; i <= m; i++) ans[i] += ans[i - 1];
	for (re i = 0; i <= m; i++) printf("%d\n", ans[i]);
}
```



---

## 作者：ljc20020730 (赞：5)

题意：对于一个序列，求出逆序对，并且支持维护交换两个元素后逆序对个数统计

数据范围：对于100%的数据 $1 \leq n \leq 2000$ , $1 \leq m \leq 20000$,
### 强烈要求加强数据!!!

## Solution

**下列讨论默认$l \leq r$,若输入中不符，请交换 l,r**

**若你的程序对于测试点$10-15$ WA了，请务必测试下面的数据,请检查是否将区间询问比$val$大/小的元素有几个的时候产生的BUG，请充分考虑元素相同的情况**

``` 
data.in
6
4 4 2 3 2 2 
2
6 2
6 3


data.out
10
5
9

```

考虑归并排序求出原来数组的逆序对，并且利用之前统计出的逆序对计算当前答案。

考虑交换(l,r)对逆序对个数变化的贡献，

若改变使逆序对数量变多，我们称之为有正贡献，反之为负贡献。

由于 $ a_l , a_r$  交换后对于区间$i \in [1,l-1]\bigcup[r+1,n] $的元素$a_i$和两个变化元素$a_l,a_r$相对位置没有发生变化，这之间产生贡献为 $0$

对于贡献理解不那么深入的同学，可以简单理解为正贡献就是使全局逆序对增加的代名词，负贡献就是使全局逆序对减少的代名词。

那么考虑$a_l$移到位置$r$产生的贡献：

- 对于区间$i\in[l+1,r-1]$的所有$a_i<a_l$的元素产生$ -1 $的贡献
- 对于区间$i\in[l+1,r-1]$的所有$a_i>a_l$的元素产生$ +1 $的贡献

考虑$a_r$移到位置$l$产生的贡献：

- 对于区间$i\in[l+1,r-1]$的所有$a_i<a_r$的元素产生$ +1 $的贡献
- 对于区间$i\in[l+1,r-1]$的所有$a_i>a_r$的元素产生$ -1 $的贡献

还需要考虑$a_l$和$a_r$之间的大小关系对全局逆序对的贡献

- 若$a_l < a_r$ 那么交换后会产生$ 1 $的贡献
- 若$a_l > a_r$ 那么交换后会产生$-1$的贡献

所以我们需要这样一种数据结构，可以支持：

- 单点插入
- 单点删除
- 区间询问严格的比$val$小的元素有多少个
- 区间询问严格的比$val$大的元素有多少个

我们可以使用：分块或者树套树

我这里使用的是树套树(即线段树套Treap)

复杂度$O(n {log_2}^2 n)$

```cpp
# include<bits/stdc++.h>
using namespace std;
const int N=4e6+10;
int a[N],n,ans,w[N],b[N];
inline int read()
{
    int X=0,w=0; char c=0;
    while(c<'0'||c>'9') {w|=c=='-';c=getchar();}
    while(c>='0'&&c<='9') X=(X<<3)+(X<<1)+(c^48),c=getchar();
    return w?-X:X;
}
void write(int x)
{
    if (x<0) x=-x,putchar('-');
    if (x>9) write(x/10);
    putchar(x%10+'0');
}
void writeln(int x)
{
    write(x); putchar('\n');
}
void Merge_Sort(int l,int r)
{
    if (l==r) return;
    int mid=(l+r)>>1;
    Merge_Sort(l,mid);
    Merge_Sort(mid+1,r);
    int i=l,j=mid+1,k=l;
    while (i<=mid&&j<=r) {
        if (a[i]>a[j]) ans+=mid-i+1,w[k++]=a[j++];
        else w[k++]=a[i++];
    }
    while (i<=mid) w[k++]=a[i++];
    while (j<=r) w[k++]=a[j++];
    for (int i=l;i<=r;i++) a[i]=w[i];
}
struct node{
    int cnt,size,ch[3],key,val;
}t[N];
int root[N],tot;
struct Treap{
    # define ls(x) t[x].ch[0]
    # define rs(x) t[x].ch[1]
    void up(int &x){
        t[x].size=t[ls(x)].size+t[rs(x)].size+t[x].cnt;
    }
    void rotate(int &x,int d) {
        int son=t[x].ch[d];
        t[x].ch[d]=t[son].ch[d^1];
        t[son].ch[d^1]=x;
        up(x); up(x=son);
    }
    void insert(int &x,int val) {
        if (!x) {
            x=++tot;
            t[x].size=t[x].cnt=1;
            t[x].val=val;
            t[x].key=rand();
            return;
        }
        t[x].size++;
        if (t[x].val==val) { t[x].cnt++; return;}
        int d=val>t[x].val;
        insert(t[x].ch[d],val);
        if (t[t[x].ch[d]].key<t[x].key) rotate(x,d);
    }
    void erase(int &x,int val)
    {
        if (!x) return;
        if (t[x].val==val) {
            if (t[x].cnt>1) { t[x].cnt--; t[x].size--; return;}
            int d=t[ls(x)].key>t[rs(x)].key;
            if (ls(x)==0||rs(x)==0) x=ls(x)+rs(x);
            else rotate(x,d),erase(x,val);
        } else t[x].size--,erase(t[x].ch[t[x].val<val],val);
    }
    int rank_min(int &x,int val) { //小于val的有多少个
        if (!x) return 0;
        if (t[x].val==val) return t[ls(x)].size;
        else if (t[x].val>val) return rank_min(ls(x),val);
        else return t[ls(x)].size+t[x].cnt+rank_min(rs(x),val);
    }
    int rank_max(int &x,int val) { //大于val的有多少个
    	if (!x) return 0;
    	if (t[x].val==val) return t[rs(x)].size;
    	else if (t[x].val<val) return rank_max(rs(x),val);
    	else return t[x].cnt+t[rs(x)].size+rank_max(ls(x),val);
    }
    # undef ls
    # undef rs
}treap;
# define lson (x<<1),l,mid
# define rson (x<<1)+1,mid+1,r
# define mid ((l+r)>>1)
void SegInsert(int x,int l,int r,int pos,int val)
{
    treap.insert(root[x],val);
    if (l==r) return;
    if (pos<=mid) SegInsert(lson,pos,val);
    else SegInsert(rson,pos,val);
}
void SegDelete(int x,int l,int r,int pos,int val)
{
    treap.erase(root[x],val);
    if (l==r) return;
    if (pos<=mid) SegDelete(lson,pos,val);
    else SegDelete(rson,pos,val);
}
int SegMin(int x,int l,int r,int ql,int qr,int val) //区间内比val小的有多少
{
    if (ql<=l&&r<=qr) return treap.rank_min(root[x],val);
    int ret=0;
    if (ql<=mid) ret+=SegMin(lson,ql,qr,val);
    if (qr>mid) ret+=SegMin(rson,ql,qr,val);
    return ret;
}
int SegMax(int x,int l,int r,int ql,int qr,int val) //区间内比val大的数有多少
{
    if (ql<=l&&r<=qr) return treap.rank_max(root[x],val);
    int ret=0;
    if (ql<=mid) ret+=SegMax(lson,ql,qr,val);
    if (qr>mid) ret+=SegMax(rson,ql,qr,val);
    return ret;
}
# undef lson
# undef rson
# undef mid
/*
 考虑对于交换(l,r)对逆序对产生贡献必然在[l,r]内
 l->r那么 [l,r]里面大于l的数产生正贡献，小于l的数产生负贡献
 r->l那么 [l,r]里面大于r的数产生负贡献，小于r的数产生正贡献
支持单点删除，单点插入,kth。
*/
signed main()
{
    srand(time(NULL)*100007);
    n=read();
    for (int i=1;i<=n;i++) b[i]=a[i]=read(),SegInsert(1,1,n,i,b[i]);
    Merge_Sort(1,n);
    writeln(ans);
    int m=read();
    while (m--) {
        int l=read(),r=read();
        if (l>r) swap(l,r);
        ans+=SegMax(1,1,n,l+1,r-1,b[l])-SegMin(1,1,n,l+1,r-1,b[l]);
        ans+=SegMin(1,1,n,l+1,r-1,b[r])-SegMax(1,1,n,l+1,r-1,b[r]);
        if (b[l]>b[r]) ans--;
        if (b[l]<b[r]) ans++;
        writeln(ans);
        int vall=b[l],valr=b[r];
        SegInsert(1,1,n,l,valr);
        SegInsert(1,1,n,r,vall);
        SegDelete(1,1,n,l,vall);
        SegDelete(1,1,n,r,valr);
        swap(b[l],b[r]);
    }
    return 0;
}
```

---

## 作者：YoungNeal (赞：5)

[安利](http://www.cnblogs.com/YoungNeal/p/9009902.html)一下博客~

看到楼下大佬都在块内排序加树状数组，蒟蒻想发表一下自己的做法。  
这里有一种前缀和思想的做法。  
这个思想是受[作诗](https://www.luogu.org/problemnew/show/P4135)的启发。  
在那道题中，我们借用前缀和统计了每个数出现次数，这道题也完全可以嘛！   
定义 $sum[i][j]$ 表示第 $1-i$ 个块，身高为 $j$ 的小孩出现的次数。  
所有身高先离散化一遍之后，没有任何操作的答案先树状数组求一下。 
然后就可以借助以前的答案更新当前了，这个楼下大佬讲了就不啰嗦了。  
对于交换 $[l,r]$，边角暴力，块内统计答案。  
如何统计呢？由楼下大佬的公式我们可以知道，如果 $a[i]<val[l]$ ，那么 $ans++$。这是将 $i$ 从 $belong[l]+1$ 到 $belong[r]-1$ 循环。  
换个思路，如果 $i$ 代表的不是元素，而是数值呢？  
也就是说，将 $i$ 从1到值域循环，那么如果 $i<val[l]$，那么 $ans$ 就会变大。  
变大多少呢？这个值即为 $sum[belong[r]-1][i]-sum[belong[l]][i]$。  
其他三种情况同理，那么每次答案就求完了。  
记得更新 $sum$ 数组！
```cpp
#include<cmath>
#include<cstdio>
#include<iostream>
#include<algorithm>
#define N 20005
#define int long long

int f[N],len;
int n,m,tot,ans;
int sum[150][N];
int val[N],t[N];
int l[150],r[150];
int block,belong[N];

int ask(int x){
	int b=0;
	for(;x;x-=x&-x)
		b+=f[x];
	return b;
}

void add(int x){
	for(;x<=n;x+=x&-x)
		f[x]++;
}

int query(int a,int b){
	//printf("a=%lld,b=%lld\n",a,b);
	if(val[a]==val[b]) return ans;
	if(belong[a]==belong[b] or belong[a]+1==belong[b]){
		//puts("dfgfhhg");
		for(int i=a+1;i<b;i++){
			if(val[i]<val[a]) ans--;
			if(val[i]<val[b]) ans++;
			if(val[i]>val[a]) ans++;
			if(val[i]>val[b]) ans--;
			//printf("i=%lld,val=%lld,ans=%lld\n",i,val[i],ans);
		}
		if(val[a]>val[b]) ans--;
		if(val[a]<val[b]) ans++;
		if(belong[a]+1==belong[b])
			sum[belong[a]][val[a]]--,sum[belong[a]][val[b]]++;
		val[a]^=val[b]^=val[a]^=val[b];
		return ans;
	}
	if(val[a]>val[b]) ans--;
	if(val[a]<val[b]) ans++;
	for(int i=a+1;i<=r[belong[a]];i++){
		if(val[i]<val[a]) ans--;
		if(val[i]<val[b]) ans++;
		if(val[i]>val[a]) ans++;
		if(val[i]>val[b]) ans--;
	}
	for(int i=b-1;i>=l[belong[b]];i--){
		if(val[i]<val[a]) ans--;
		if(val[i]<val[b]) ans++;
		if(val[i]>val[a]) ans++;
		if(val[i]>val[b]) ans--;
	}
	for(int i=1;i<=len;i++){
		if(i<val[a]) ans-=sum[belong[b]-1][i]-sum[belong[a]][i];
		if(i<val[b]) ans+=sum[belong[b]-1][i]-sum[belong[a]][i];
		if(i>val[a]) ans+=sum[belong[b]-1][i]-sum[belong[a]][i];
		if(i>val[b]) ans-=sum[belong[b]-1][i]-sum[belong[a]][i];
	}
	for(int i=belong[a];i<belong[b];i++){
		sum[i][val[a]]--;
		sum[i][val[b]]++;
	}
	val[a]^=val[b]^=val[a]^=val[b];
	/*for(int i=1;i<=tot;i++){
		for(int j=1;j<=len;j++)
			printf("i=%lld,j=%lld,sum=%lld\n",i,j,sum[i][j]);
	}*/
	return ans;
}

void file(){
	freopen("in.txt","r",stdin);
	freopen("out2.txt","w",stdout);
}

signed main(){
	//file();
	scanf("%lld",&n);
	block=sqrt(n);
	tot=n/block;
	if(n%block) tot++;
	for(int i=1;i<=n;i++)
		scanf("%lld",&val[i]),t[i]=val[i],belong[i]=(i-1)/block+1;
	std::sort(t+1,t+1+n);
	len=std::unique(t+1,t+1+n)-t-1;
	for(int i=1;i<=n;i++) val[i]=std::lower_bound(t+1,t+1+len,val[i])-t;
	for(int i=1;i<=tot;i++)
		l[i]=(i-1)*block+1,r[i]=i*block;
	for(int i=n;i;i--){
		ans+=ask(val[i]-1);
		add(val[i]);
		sum[belong[i]][val[i]]++;
	}
	for(int i=1;i<=tot;i++){
		for(int j=1;j<=len;j++)
			sum[i][j]+=sum[i-1][j];
	}
	scanf("%lld",&m);
	printf("%lld\n",ans);
	while(m--){
		int x,y;
		scanf("%lld%lld",&x,&y);
		if(x>y) x^=y^=x^=y;
		printf("%lld\n",query(x,y));
	}
	return 0;
}
```

---

## 作者：Cheng_yf (赞：2)

### 题目描述

排排坐，吃果果，生果甜嗦嗦，大家笑呵呵。你一个，我一个，大的分给你，小的留给我，吃完果果唱支歌，大家乐和和。

红星幼儿园的小朋友们排起了长长地队伍，准备吃果果。不过因为小朋友们的身高有所区别，排成的队伍高低错乱，极不美观。设第i个小朋友的身高为hi，我们定义一个序列的杂乱程度为：满足i<j且hi>hj的(i,j)数量。

幼儿园阿姨每次会选出两个小朋友，交换他们的位置，请你帮忙计算出每次交换后，序列的杂乱程度。为方便幼儿园阿姨统计，在未进行任何交换操作时，你也应该输出该序列的杂乱程度。

### 输入输出格式

#### 输入格式：

第一行为一个正整数n，表示小朋友的数量；

第二行包含n个由空格分隔的正整数h1,h2,…,hn，依次表示初始队列中小朋友的身高；

第三行为一个正整数m，表示交换操作的次数；

以下m行每行包含两个正整数ai和bi­，表示交换位置ai与位置bi的小朋友。

#### 输出格式：
输出文件共m+1行，第i行一个正整数表示交换操作i结束后，序列的杂乱程度。

### putin：

3

130 150 140

2

2 3

1 3

### putout：

1

0

3

### 题意理解

给一个数列，求原始的数列和修改(交换两个数)后的数列的逆序对个数

### 分析

首先，第一个问题就是静态逆序对,BIT和归并排序之类的都可以...

考虑修改(交换操作)

交换第i个和第j个数时(i<j)的影响

原始数列：$a_1,a_2,...,a_{i-1},a_i,a_{i+1},...,a_{j-1},a_j,a_{j+1},...,a_{n-1},a_n$

修改后：$a_1,a_2,...,a_{i-1},a_j,a_{i+1},...,a_{j-1},a_i,a_{j+1},...,a_{n-1},a_n$

把$a_1...a_{i-1}$、$a_{i+1}...a_{j-1}$和$a_{j+1}...a_n$分别看成一个整体(用A,B,C表示)

当然A,B,C中的贡献的不会改变的

我们可以发现$a_i$和$a_j$在A,C中的贡献是没有变化的

只用讨论在B中与$a_i$和$a_j$的贡献

先减去原有的贡献，再加上新加上的贡献

于是问题就成了在一个区间内高效查询比一个数大和比一个数小的数有几个

区间可以转化为两个前缀和之差，查询就是平衡树的基本操作

就可以BIT套SBT

### Code和一些注释

```cpp
#include<bits/stdc++.h>
#define ls tree[x].left
#define rs tree[x].right
using namespace std;
struct SBT {
	int key;
	int left,right,size;
} tree[1000100];
void left_rot(int &x) {
	int y = rs;
	rs = tree[y].left;
	tree[y].left = x;
	tree[y].size = tree[x].size;
	tree[x].size = tree[ls].size + tree[rs].size + 1;
	x = y;
}
void right_rot(int &x) {
	int y = ls;
	ls = tree[y].right;
	tree[y].right = x;
	tree[y].size = tree[x].size;
	tree[x].size = tree[ls].size + tree[rs].size + 1;
	x = y;
}
void maintain(int &x,bool flag) {
	if(flag == false) {
		if(tree[tree[ls].left].size > tree[rs].size)
			right_rot(x);
		else if(tree[tree[ls].right].size > tree[rs].size) {
			left_rot(ls);
			right_rot(x);
		} else return;
	} else {
		if(tree[tree[rs].right].size > tree[ls].size)
			left_rot(x);
		else if(tree[tree[rs].left].size > tree[ls].size) {
			right_rot(rs);
			left_rot(x);
		} else return;
	}
	maintain(ls,false);
	maintain(rs,true);
	maintain(x,true);
	maintain(x,false);
}
int top=0;
void insert(int &x,int key) {
	if(x==0) {
		x=++top;
		ls=rs=0;
		tree[x].size=1;
		tree[x].key=key;
	} else {
		tree[x].size++;
		if(key<tree[x].key) insert(ls,key);
		else insert(rs,key);
		maintain(x,key>=tree[x].key);
	}
}
int  delet(int &x,int key) {
	int d_key;
	tree[x].size --;
	if((key == tree[x].key)||(key < tree[x].key && ls == 0) ||
	        (key>tree[x].key && rs == 0)) {
		d_key = tree[x].key;
		if(ls && rs) {
			tree[x].key = delet(ls,tree[x].key+1);
		} else {
			x = ls + rs;
		}
	} else if(key > tree[x].key)
		d_key = delet(rs,key);
	else if(key < tree[x].key)
		d_key = delet(ls,key);
	return d_key;
}
int find_min(int x,int key){//查询在子树x中有几个比它小 
	if(!x) return 0;
	if(key>tree[x].key) return tree[ls].size+1+find_min(rs,key);
	else if(key==tree[x].key) return find_min(ls,key);
	else return find_min(ls,key);
}
int find_max(int x,int key){//查询在子树x中有几个比它大 
	if(!x) return 0;
	if(key<tree[x].key) return tree[rs].size+1+find_max(ls,key);
	else if(key==tree[x].key) return find_max(rs,key);
	else return find_max(rs,key);
}
int root[20005],n;
int a[20005];
int lowbit(int i){return i&(-i);}
void add(int x,int val){//在x的位置上插入val键值 
	for(int i=x;i<=n;i+=lowbit(i))
	insert(root[i],val);
}
void del(int x,int val){//在x的位置上删去val键值
	for(int i=x;i<=n;i+=lowbit(i))
	delet(root[i],val);
}
int query_min(int x,int val){//查询1~x中比val小的有几个 
	int ans=0;
	for(int i=x;i!=0;i-=lowbit(i))
	ans+=find_min(root[i],val);
	return ans;
}
int query_max(int x,int val){//查询1~x中比val大的有几个
	int ans=0;
	for(int i=x;i!=0;i-=lowbit(i))
	ans+=find_max(root[i],val);
	return ans;
}
int ans=0;
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
		add(i,a[i]);
	}//输入顺带预处理 
	for(int i=2;i<=n;i++){
		int tmp=query_max(i-1,a[i]);
		ans+=tmp;
	}//找原始数列的逆序对个数 
	printf("%d\n",ans);
	int m;scanf("%d",&m);
	while(m--){
		int l,r;
		scanf("%d%d",&l,&r);
		if(l>r) swap(l,r);//避免右端点比左端点还小 
		if(a[l]==a[r]){//没有任何变化 
			printf("%d\n",ans);
			continue;
		}
		if(r-l==1){//直接交换两个数 
			if(a[l]<a[r]) ans++;else ans--;//a_i和a_j的贡献 
			printf("%d\n",ans);
			del(l,a[l]);add(l,a[r]);//删去原来的值和加入新值 
			del(r,a[r]);add(r,a[l]);
			swap(a[l],a[r]);//交换值 
			continue;			
		}
		
		//统计右端点的贡献 
		ans-=query_max(r-1,a[r])-query_max(l,a[r]);//减去原来的 
		ans+=query_min(r-1,a[r])-query_min(l,a[r]);//加上现在的 
		
		//统计左端点的贡献 
		ans-=query_min(r-1,a[l])-query_min(l,a[l]);//同理 
		ans+=query_max(r-1,a[l])-query_max(l,a[l]);
		
		if(a[l]<a[r]) ans++;
		else ans--;
		printf("%d\n",ans);
		del(l,a[l]);add(l,a[r]);
		del(r,a[r]);add(r,a[l]);
		swap(a[l],a[r]);
	}
	return 0;
}
```

---

## 作者：lory1608 (赞：1)

这道题的简化版是[P3157 CQOI2011动态逆序对](https://www.luogu.com.cn/problem/P3157)。

对于维护**动态逆序对问题**有很多种解法，其中树状数组套线段树是比较常规的一种方法。

现将序列离散化，然后一次添加元素进入树套树。

交换位置时，只用依次考虑他所产生的影响即可，在树套树中修改。

时间复杂度$\Theta(n\log^2n)$,空间复杂度$\Theta(n\log^2n)$。

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<cstring>
#include<queue>
#include<vector>
#define ll long long
#define ull unsigned long long
using namespace std;
const int maxn=20005;
int n,m,rt[maxn],a[maxn],b[maxn],sum;
namespace tree
{
	int tot;
	int c[maxn],ls[maxn*200],rs[maxn*200],sum[maxn*200],temp[2][20],cnt[2];
	inline void update(int &u,int l,int r,int x,int v)
	{
		if(!u)u=++tot;
		if(l==r)
		{
			sum[u]+=v;
			return ;
		}
		else
		{
			int mid=(l+r)>>1;
			if(x<=mid)update(ls[u],l,mid,x,v);
			else update(rs[u],mid+1,r,x,v);
			sum[u]=sum[ls[u]]+sum[rs[u]];
		}
	}
	inline void preupdate(int x,int v,int val)
	{
		while(x<=n)
		{
			update(rt[x],1,n,val,v);
			x+=x&-x;
		}
	}
	inline int query(int l,int r,int x,int mode)
	{
		cnt[0]=cnt[1]=0;
		for(int i=l-1;i>0;i-=i&-i)temp[0][++cnt[0]]=rt[i];
		for(int i=r;i>0;i-=i&-i)temp[1][++cnt[1]]=rt[i];
		l=1,r=n;
		int ret=0;
		while(l<r)
		{
			int mid=(l+r)>>1;
			if(x<=mid)
			{
				if(mode)
				{
					for(int i=1;i<=cnt[0];++i)ret-=sum[rs[temp[0][i]]];
					for(int i=1;i<=cnt[1];++i)ret+=sum[rs[temp[1][i]]];
				}
				for(int i=1;i<=cnt[0];++i)temp[0][i]=ls[temp[0][i]];
				for(int i=1;i<=cnt[1];++i)temp[1][i]=ls[temp[1][i]];
				r=mid;
			}
			else
			{
				if(!mode)
				{
					for(int i=1;i<=cnt[0];++i)ret-=sum[ls[temp[0][i]]];
					for(int i=1;i<=cnt[1];++i)ret+=sum[ls[temp[1][i]]];
				}
				for(int i=1;i<=cnt[0];++i)temp[0][i]=rs[temp[0][i]];
				for(int i=1;i<=cnt[1];++i)temp[1][i]=rs[temp[1][i]];
				l=mid+1;
			}
		}
		return ret;
	}
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;++i)scanf("%d",&a[i]),b[i]=a[i];
	sort(b+1,b+n+1);
	int tot=unique(b+1,b+n+1)-b-1;
	for(int i=1;i<=n;++i)
	a[i]=lower_bound(b+1,b+tot+1,a[i])-b;
	scanf("%d",&m);
	for(int i=1;i<=n;++i)
	{
		sum+=tree::query(1,i-1,a[i],1);
		tree::preupdate(i,1,a[i]);
	}
	printf("%d\n",sum);
	for(int i=1;i<=m;++i)
	{
		int x,y;
		scanf("%d%d",&x,&y);
		if(x>y)swap(x,y);
		sum-=tree::query(x+1,y-1,a[x],0);
		sum+=tree::query(x+1,y-1,a[x],1);
		sum-=tree::query(x+1,y-1,a[y],1);
		sum+=tree::query(x+1,y-1,a[y],0);
		if(a[x]<a[y])sum++;
		if(a[x]>a[y])sum--;
		tree::preupdate(x,-1,a[x]);
		tree::preupdate(y,-1,a[y]);
		swap(a[x],a[y]);
		tree::preupdate(x,1,a[x]);
		tree::preupdate(y,1,a[y]);
		printf("%d\n",sum);
	}
	return 0;
}

```

---

## 作者：eee_hoho (赞：1)

似乎没人用$stl$啊，那我来一发~~优美~~的$stl$好了qwq

题意：给一个序列，每次交换$a_l,a_r$，并且询问交换后的整个序列的逆序对数

刚开始的逆序对数可以直接用归并排序求出来，我们先更新答案再交换，考虑每次交换的$a_l,a_r$，会影响逆序对的只可能是$[l,r]$这个区间的数，如果单独拿出之间的一个数$a_i(l+1\le i\le r-1)$来说，对答案则有四种可能的影响

>1. $a_i>a_l\to ans++$

>$a_i$比$a_l$大，$a_l$和$a_r$交换之后$a_l$下标比$a_i$大，逆序对数$+1$

>2. $a_i<a_l\to ans--$

>$a_i$比$a_l$小，已经是逆序对，$a_l$和$a_r$交换，逆序对数$-1$

>3. $a_i<a_r\to ans++$

>$a_i$比$a_r$小，$a_l$和$a_r$交换之后$a_r$下标比$a_i$小，逆序对数$+1$

>4. $a_i>a_r\to ans--$

>$a_i$比$a_r$大，已经是逆序对，$a_l$和$a_r$交换，逆序对数$-1$

那么我们用分块来维护，对于在同一个块或相邻块的，暴力枚举$a_i$更新答案

然后考虑在每个块里维护这个块的有序序列，每次访问到这个块的时候，直接二分查找更新答案，边角的数直接枚举更新就好了

这样每次交换后对$a_l$和$a_r$调整一下所在块的有序序列就好了

注意询问的$l,r$可能$l>r$所以要交换

蒟蒻也不会算块的大小什么的，常数还大的一批，就这样吧qwq

**Code**
``` cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <cmath>
#include <vector>
#define N 20000
#define rep(i,s,t) for (register int i=s;i<=t;i++)
#define drep(i,s,t) for (register int i=s;i>=t;i--)
using namespace std;
int n,a[N+5],data[N+5],m,bs,blo[N+5],na[N+5],ans;
vector <int> p[N+5];
void merge_sort(int l,int r)
{
    if (r-l>0)
    {
        int it=l,mid=l+r>>1,p=l,q=mid+1;
        merge_sort(l,mid);
        merge_sort(mid+1,r);
        while (p<=mid||q<=r)
        {
            if (q>r||p<=mid&&na[p]<=na[q])
                data[it++]=na[p++];
            else
            {
                data[it++]=na[q++];
                ans+=mid-p+1;
            }
        }
        rep(i,l,r)
            na[i]=data[i];
    }
}
void com(int x,int l,int r)
{
    ans+=a[x]>a[l];
    ans-=a[x]<a[l];
    ans+=a[x]<a[r];
    ans-=a[x]>a[r];
}
void reset(int x)
{
    p[x].clear();
    rep(i,(x-1)*bs+1,x*bs)
        p[x].push_back(a[i]);
    sort(p[x].begin(),p[x].end());
}
void exc(int l,int r)
{
    swap(a[l],a[r]);
    reset(blo[l]);
    reset(blo[r]);
}
void calc(int l,int r)
{
    if (a[l]==a[r])
        return;
    ans+=(a[l]<a[r]);
    ans-=(a[l]>a[r]);
    if (blo[r]-blo[l]<=1)
    {
        rep(i,l+1,r-1)
            com(i,l,r);
    }
    else
    {
        rep(i,l+1,blo[l]*bs)
            com(i,l,r);
        rep(i,(blo[r]-1)*bs+1,r-1)
            com(i,l,r);
        rep(i,blo[l]+1,blo[r]-1)
        {
            ans+=p[i].end()-upper_bound(p[i].begin(),p[i].end(),a[l]);
            ans-=lower_bound(p[i].begin(),p[i].end(),a[l])-p[i].begin();
            ans+=lower_bound(p[i].begin(),p[i].end(),a[r])-p[i].begin();
            ans-=p[i].end()-upper_bound(p[i].begin(),p[i].end(),a[r]);
        }
    }
    exc(l,r);
}
int main()
{
    scanf("%d",&n);
    rep(i,1,n)
        scanf("%d",&a[i]),na[i]=data[i]=a[i];
    sort(data+1,data+n+1);
    bs=sqrt(n);    
    rep(i,1,n)
    {
        blo[i]=(i-1)/bs+1;        
        na[i]=a[i]=lower_bound(data+1,data+n+1,a[i])-data;
        p[blo[i]].push_back(a[i]);
    }
    rep(i,1,blo[n])
        sort(p[i].begin(),p[i].end());
    merge_sort(1,n);
    printf("%d\n",ans);
    scanf("%d",&m);
    int l,r;
    rep(i,1,m)
    {
        scanf("%d%d",&l,&r);
        if (l>r)
            swap(l,r);
        calc(l,r);
        printf("%d\n",ans);
    }
    return 0;
}
```

---

## 作者：Captain1 (赞：1)

看到各位神犇都是用分块+树状数组做的。我特别菜，我没有想到这种做法，但是因为这个题的数据范围比较小，我想到了一种更暴力的解决方法。  

对于每次交换，我并没有从其他元素的角度去考虑这次交换的影响，相反，我是从被交换的两个元素出发去考虑。对于一个被交换的元素，它对于整个序列的逆序对贡献数是在它前面的而且大于它的数和在它后面的并且小于它的数的个数和。  

这样的话，我们可以在预处理的时候，对每一个块内进行排序，之后在查询的时候，我们首先找到要交换的两个元素所在的位置，对于每一个元素，其所在块前面所有的整块，我们使用$upperbound$直接去查找这个元素在块内第一个比它大的元素的位置，就能计算出每个块内有多少元素大于它，其所在块后面所有的的整块，我们用$lowerbound$去查找这个元素在块内第一个大于等于它的元素的位置，就能计算出每个块内有多少个元素小于它。至于与他在同一块内的元素，直接暴力枚举判定即可。  

这样我们就能计算出这两个元素分别的逆序对贡献数，我们先把它减去，交换以后重新统计两个元素的贡献，再加上即可。注意交换之前如果$a[x]$ > $a[y]$，那么这对数的逆序对数会被计算两次，要减掉，同理交换之后如果$a[x]$ > $a[y]$,这对逆序对数也会被计算两次，也要减掉。在交换之后，两个元素所在的块暴力重构，重新$sort$一遍即可。  

注意的是一开始高度要进行离散化，还有就是我的这种做法要保证$x<y$，否则我们需要交换。~~debug这么长时间很流泪~~  

之后这个题就做完啦，一开始的时候我的确使用了树状数组计算逆序对……不过后来就没用了……  

预处理复杂度$O(n\log\sqrt{n})$,查询复杂度为$O(m\sqrt{n}\log\sqrt{n})$，可以通过此题。  

贴上本人代码。  
```
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<iostream>
#include<cmath>
#include<set>
#include<queue>
#define lowbit(x) x & (-x)
#define rep(i,a,n) for(register int i = a;i <= n;i++)
#define per(i,n,a) for(register int i = n;i >= a;i--)
#define enter putchar('\n')

using namespace std;
typedef long long ll;
const int M = 20005;
const int N = 155;
const int INF = 1000000009;

inline int read()
{
    int ans = 0,op = 1;
    char ch = getchar();
    while(ch < '0' || ch > '9')
    {
		if(ch == '-') op = -1;
		ch = getchar();
    }
    while(ch >= '0' && ch <= '9')
    {
		ans *= 10;
		ans += ch - '0';
		ch = getchar();
    }
    return ans * op;
}

int n,m,B,cnt,blo[M],a[M],b[M],l[N],r[N],c[M],g = 1,tot,ans,x,y,cur1,cur2;

void add(int x)
{
    while(x <= M-2) c[x]++,x += lowbit(x);
}

int ask(int x)
{
    int d = 0;
    while(x) d += c[x],x -= lowbit(x);
    return d;
}

void calc(int x,int y)
{
    int L = blo[x],R = blo[y];
    cur1 = 0,cur2 = 0;
    rep(i,1,L-1)
    {
		int d = upper_bound(b+l[i],b+r[i]+1,a[x]) - b - l[i] + 1;
		cur1 += B - d + 1;
    }
    rep(i,l[L],x-1) if(a[i] > a[x]) cur1++;
    rep(i,x+1,r[L]) if(a[i] < a[x]) cur1++;
    rep(i,L+1,cnt)
    {
		int d = lower_bound(b+l[i],b+r[i]+1,a[x]) - b - l[i] + 1;
		cur1 += d - 1;
    }
    rep(i,1,R-1)
    {
		int d = upper_bound(b+l[i],b+r[i]+1,a[y]) - b - l[i] + 1;
		cur2 += B - d + 1;
    }
    rep(i,l[R],y-1) if(a[i] > a[y]) cur2++;
    rep(i,y+1,r[R]) if(a[i] < a[y]) cur2++;
    rep(i,R+1,cnt)
    {
		int d = lower_bound(b+l[i],b+r[i]+1,a[y]) - b - l[i] + 1;
		cur2 += d - 1;
    }
}

void rebuild(int x,int y)
{
    int L = blo[x],R = blo[y];
    rep(i,l[L],r[L]) b[i] = a[i];
    sort(b+l[L],b+r[L]+1);
    rep(i,l[R],r[R]) b[i] = a[i];
    sort(b+l[R],b+r[R]+1);
}

void solve(int x,int y)
{
    calc(x,y);
    ans -= (cur1 + cur2);
    if(a[x] > a[y]) ans++;
    swap(a[x],a[y]);
    rebuild(x,y);
    calc(x,y);
    ans += (cur1 + cur2);
    if(a[x] > a[y]) ans--;
    printf("%d\n",ans);
}

int main()
{
    n = read(),B = sqrt(n);
    cnt = (n%B) ? n / B + 1 : n / B;
    rep(i,1,n) a[i] = b[i] = read();
    sort(b+1,b+1+n),tot = unique(b+1,b+1+n) - b - 1;
    rep(i,1,n) a[i] = lower_bound(b+1,b+1+tot,a[i]) - b;
    rep(i,1,n) b[i] = a[i];
    rep(i,1,cnt) l[i] = r[i-1] + 1,r[i] = l[i] + B - 1;
    r[cnt] = n;
    rep(i,1,n)
    {
		blo[i] = g;
		if(i == r[g]) g++;
    }
    rep(i,1,cnt) sort(b+l[i],b+r[i]+1);
    per(i,n,1) ans += ask(a[i]-1),add(a[i]);
    printf("%d\n",ans);
    m = read();
    rep(i,1,m)
    {
		x = read(),y = read();
		if(x > y) swap(x,y);
		solve(x,y);
    }
    return 0;
}


```

---

## 作者：大菜鸡fks (赞：1)

复习分块。

这题用树状数组+分块可以做，树套树也可以。

但后者常数巨大，代码复杂度偏高。

这题比较套路。分块以后对于每一块套一个树状数组。两数交换只需要考虑中间一部分。整块的在树状数组进行查询。零散的直接暴力。

```cpp
#include<cstdio>
#include<algorithm>
#include<cmath>
using namespace std;
const int maxn=2e4+5,maxb=200;
struct node{
	int id,x;
}a[maxn];
int n,h[maxn],block,r[maxb],l[maxb],belong[maxn],cnt;
inline bool cmp(node A,node B){
	return A.x<B.x;
}
inline void init(){
	scanf("%d",&n);
	block=(int)sqrt(n);
	for (int i=1;i<=n;i++){
		scanf("%d",&a[i].x); a[i].id=i; 
		belong[i]=(i-1)/block+1;
	}
	sort(a+1,a+1+n,cmp);
	for (int i=1;i<=n;i++){
		if (a[i].x!=a[i-1].x) cnt++;
		h[a[i].id]=cnt;
	}
	cnt=belong[n];
	for (int i=1;i<=cnt;i++){
		l[i]=r[i-1]+1;
		r[i]=i*block;
	}
	r[cnt]=n;
}
int bit[maxb][maxn],m,Bit[maxn];
inline int lowbit(int x){return x&(-x);}
inline void update(int c[],int x,int y){for (;x<=n;x+=lowbit(x)) c[x]+=y;}
inline int query(int c[],int x){int ans=0; for (;x;x-=lowbit(x)) ans+=c[x]; return ans;}
inline void solve(){
	int ans=0;
	for (int i=n;i;i--){
		ans+=query(Bit,h[i]-1);
		update(Bit,h[i],1);
		update(bit[belong[i]],h[i],1);
	}
	printf("%d\n",ans);
	scanf("%d",&m);
	for (int i=1;i<=m;i++){
		int x,y;
		scanf("%d%d",&x,&y);
		if (x>y) swap(x,y);
		int ll=belong[x]+1,rr=belong[y]-1;
		if (belong[x]!=belong[y]){
			for (int j=ll;j<=rr;j++){
				ans-=query(bit[j],h[x]-1);
				ans+=query(bit[j],n)-query(bit[j],h[x]);
				ans+=query(bit[j],h[y]-1);
				ans-=query(bit[j],n)-query(bit[j],h[y]);
			}
			for (int j=x+1;j<=r[ll-1];j++){
				if (h[j]>h[x]) ans++;
				if (h[j]>h[y]) ans--;
				if (h[j]<h[x]) ans--;
				if (h[j]<h[y]) ans++; 
			}
			for (int j=l[rr+1];j<y;j++){
				if (h[j]>h[x]) ans++;
				if (h[j]>h[y]) ans--;
				if (h[j]<h[x]) ans--;
				if (h[j]<h[y]) ans++; 
			}
		}else{
			for (int j=x+1;j<y;j++){
				if (h[j]>h[x]) ans++;
				if (h[j]>h[y]) ans--;
				if (h[j]<h[x]) ans--;
				if (h[j]<h[y]) ans++; 
			}
		}
		if (h[x]<h[y]) ans++;
		if (h[x]>h[y]) ans--;
		printf("%d\n",ans);
		update(bit[belong[x]],h[x],-1);
		update(bit[belong[x]],h[y],1);
		update(bit[belong[y]],h[y],-1);
		update(bit[belong[y]],h[x],1);
		swap(h[x],h[y]);
	}
}
int main(){
	init();
	solve();
	return 0;
} 
```

---

## 作者：rainygame (赞：0)

发现对于一次交换操作 $(a_i,b_i)$，$j<a_i$ 或 $j>b_i$ 的数都不会对序列的逆序对有影响。如果询问之间互相独立，那么问题可以转化为“$[l,r]$ 有多少个数在 $[L,R]$ 中”，离线下来扫描线即可做到单 $O(n \log n)$，极其优秀。

但现在询问之间不独立。考虑一种暴力：每次询问时暴力地检查前面的询问，如果有交换涉及区间内的数的，将其计入答案，最后再将区间内没有被交换的数暴力统计。时间复杂度达到了 $O(m^2)$，无法接受。

考虑**根号重构**。具体地，对于每个长度为 $B$ 的块，先求出 $O(B)$ 个可能会有更改的位置（称为“动态点”），剩下位置（称为“静态点”）的值在这个块内是固定的。容易发现静态点之间的逆序对的固定的。对于每次交换操作，先求出“$[l,r]$ 有多少个**静态点**在 $[L,R]$ 中，这是静态点和动态点之间的贡献；然后再确定 $O(B)$ 个动态点分别的值，暴力统计即可。每块处理的复杂度为 $O(B^2+n\log n)$，总时间复杂度为 $O(\frac{nm\log n}{B}+qB)$，取 $B=O(\sqrt{n\log n})$ 最优。复杂度为 $O(m\sqrt{n\log n})$，可以通过。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define MAXN 20005

int n, m, q, B;
int a[MAXN], b[MAXN], ans[MAXN]; struct Que{int a, b;}que[MAXN];
struct Que2{int v, l, r, id;}; vector<Que2> que2[MAXN];

namespace BIT{
#define lbw(x) ((x) & -(x))
    int c[MAXN];
    void add(int x, int k){for (; x<=m; x+=lbw(x)) c[x] += k;}
    int qry(int x){int res(0); for (; x; x-=lbw(x)) res += c[x]; return res;}
    int qry(int l, int r){return l <= r ? qry(r)-qry(l-1) : 0;}
}

signed main(){
    ios::sync_with_stdio(false);
    cin.tie(0); cout.tie(0);

    cin >> n; for (int i(1); i<=n; ++i) cin >> a[i], b[i] = a[i]; sort(b+1, b+n+1); m = unique(b+1, b+n+1)-b-1;
    for (int i(1); i<=n; ++i) a[i] = lower_bound(b+1, b+m+1, a[i])-b; B = sqrt(n*__lg(n));
    for (int i(1); i<=n; ++i) ans[0] += BIT::qry(m)-BIT::qry(a[i]), BIT::add(a[i], 1); cin >> q;
    for (int i(1); i<=q; ++i){cin >> que[i].a >> que[i].b; if (que[i].a > que[i].b) swap(que[i].a, que[i].b);}
    for (int _(1), l, r; _<=(q+B-1)/B; ++_){
        l = (_-1)*B+1; r = min(q, _*B); set<int> st;
        for (int i(l); i<=r; ++i) st.insert(que[i].a), st.insert(que[i].b);
        for (int i(l); i<=r; ++i){
            if (a[que[i].a] < a[que[i].b]){
                if (que[i].a != que[i].b-1){
                    que2[que[i].a].push_back({-1, a[que[i].a]+1, a[que[i].b], i});
                    que2[que[i].b-1].push_back({1, a[que[i].a]+1, a[que[i].b], i});
                    que2[que[i].a].push_back({-1, a[que[i].a], a[que[i].b]-1, i});
                    que2[que[i].b-1].push_back({1, a[que[i].a], a[que[i].b]-1, i});
                }
                ans[i] = 1;
                for (auto it(st.upper_bound(que[i].a)); it!=st.end() && *it<que[i].b; ++it){
                    if (a[*it] == a[que[i].a] || a[*it] == a[que[i].b]) ++ans[i];
                    else if (a[*it] > a[que[i].a] && a[*it] < a[que[i].b]) ans[i] += 2;
                }
            }else if (a[que[i].a] > a[que[i].b]){
                if (que[i].a != que[i].b-1){
                    que2[que[i].a].push_back({1, a[que[i].b]+1, a[que[i].a], i});
                    que2[que[i].b-1].push_back({-1, a[que[i].b]+1, a[que[i].a], i});
                    que2[que[i].a].push_back({1, a[que[i].b], a[que[i].a]-1, i});
                    que2[que[i].b-1].push_back({-1, a[que[i].b], a[que[i].a]-1, i});
                }
                ans[i] = -1;
                for (auto it(st.upper_bound(que[i].a)); it!=st.end() && *it<que[i].b; ++it){
                    if (a[*it] == a[que[i].a] || a[*it] == a[que[i].b]) --ans[i];
                    else if (a[*it] < a[que[i].a] && a[*it] > a[que[i].b]) ans[i] -= 2;
                }
            }
            swap(a[que[i].a], a[que[i].b]);
        }
        memset(BIT::c, 0, sizeof(BIT::c));
        for (int i(1); i<=n; ++i){
            if (!st.count(i)) BIT::add(a[i], 1);
            for (auto j: que2[i]) ans[j.id] += BIT::qry(j.l, j.r)*j.v; que2[i].clear();
        }
        for (int i(l); i<=r; ++i) ans[i] += ans[i-1];
    }
    for (int i(0); i<=q; ++i) cout << ans[i] << '\n';

    return 0;
}

```

---

## 作者：ComplexPug (赞：0)

## 前言
	为何都是分块题解，那蒟蒻就来个树套树好了
## 思路 
序列a b c L d e f R g h中(为值，下标1到10)

现逆序对为ans,要交换L,R

则$[1,3],[9,10]$这两段区间的都不会被他俩影响 (因为L,R和他们相对位置没变啦)

所以现在我们只需要考虑区间$[4,8]$就好，其他的不考虑在内
一个数对一个区间产生逆序对的贡献为

① 前面大于他的数的个数 (在区间前面)

② 后面小于他的数的个数 (在区间后面) 

因为$L,R$之间的区间[3,6](我们叫他区间zz)是不变的(废话)

$L,R$又在区间两端 

那么很显然的 

ans=ans-(L对区间zz的贡献②)+(L对区间zz的贡献①)-(R对区间zz的贡献①)+(R对区间zz的贡献②)

那区间内的贡献咋求啊？

定义不是很明确了吗 就是区间大于x或者小于的个数

=>ans-(区间zz内小于L的个数)+(区间zz内大于L的个数)-(区间zz内大于R的个数)+(区间zz内小于R的个数)

(注意，相等的没有任何贡献)

无脑数据结构呗 

随便来个带修主席树 (树状数组套线段树)

复杂度$nlog^{2}n$ 

但常数巨大，更新一次ans要询问8次 

看到各位分块大佬，蒟蒻瑟瑟发抖
## 代码
```cpp
//天苍苍，野茫茫，代码怎么这么长
#include <bits/stdc++.h>
#define FOR(i,a,b) for(int i=a;i<=b;++i)
using namespace std;
const int maxn=1e5+7;
int read() {
    int x=0,f=1;char s=getchar();
    for(;s>'9'||s<'0';s=getchar()) if(s=='-') f=-1;
    for(;s>='0'&&s<='9';s=getchar()) x=x*10+s-'0';
    return x*f;
}
int n,m,ans,len,rt[maxn],a[maxn],lsh[maxn],cnt;
int thu[maxn];
struct node {
    int ch[2],siz;
}e[maxn*30];
void build(int &now,int old,int l,int r,int k) {
     now=++cnt;
     e[now]=e[old];
     e[now].siz++;
     if(l==r) return;
     int mid=(l+r)>>1;
     if(k<=mid) build(e[now].ch[0],e[old].ch[0],l,mid,k);
     else build(e[now].ch[1],e[old].ch[1],mid+1,r,k);
}
void modify(int &now,int l,int r,int k,int gs) {
    if(!now) now=++cnt;
    e[now].siz+=gs;
    if(l==r) return;
    int mid=(l+r)>>1;
    if(k<=mid) modify(e[now].ch[0],l,mid,k,gs);
    else modify(e[now].ch[1],mid+1,r,k,gs);
}
int query1(int now,int l,int r,int k) { //小于mid的数 
    if(l>=k) return 0;
    if(r<k) {
        int tot=e[now].siz;
        FOR(i,1,thu[0]) tot+=e[thu[i]].siz;
        return tot;
    }
    int mid=(l+r)>>1;
    if(k<=mid) {
        FOR(i,1,thu[0]) thu[i]=e[thu[i]].ch[0];
        return query1(e[now].ch[0],l,mid,k);	
    } else {
        int tot=e[e[now].ch[0]].siz;
        FOR(i,1,thu[0]) tot+=e[e[thu[i]].ch[0]].siz;
        FOR(i,1,thu[0]) thu[i]=e[thu[i]].ch[1];
        return tot+query1(e[now].ch[1],mid+1,r,k);	
    }
}
int query2(int now,int l,int r,int k) { //大于mid的数 
    if(r<=k) return 0;
    if(l>k) {
        int tot=e[now].siz;
        FOR(i,1,thu[0]) tot+=e[thu[i]].siz;
        return tot;
    }
    int mid=(l+r)>>1;
    if(k<=mid) {
        int tot=e[e[now].ch[1]].siz;
        FOR(i,1,thu[0]) tot+=e[e[thu[i]].ch[1]].siz;
        FOR(i,1,thu[0]) thu[i]=e[thu[i]].ch[0];
        return tot+query2(e[now].ch[0],l,mid,k);
    } else {
        FOR(i,1,thu[0]) thu[i]=e[thu[i]].ch[1];
        return query2(e[now].ch[1],mid+1,r,k);	
    }
}
int solve(int l,int r,int k,int pd) {//区间内小于(或小于)k的个数
    int tmp=0;
    
    thu[0]=0;
    for(int i=r;i>=1;i-=(i&-i)) thu[++thu[0]]=rt[i+n];
    tmp+=pd ? query1(rt[r],1,len,k) : query2(rt[r],1,len,k);
    
    thu[0]=0;
    for(int i=l-1;i>=1;i-=(i&-i)) thu[++thu[0]]=rt[i+n];
    tmp-=pd ? query1(rt[l-1],1,len,k) : query2(rt[l-1],1,len,k);
    
    return tmp;
}
namespace get_init_ans {
    int sum[maxn];
    void BIT_modify(int x) {
        for(int i=x;i<=n;i+=(i&-i)) sum[i]++;
    }
    int BIT_query(int x) {
        int tot=0;
        for(int i=x;i>=1;i-=(i&-i)) tot+=sum[i];
        return tot;
    } 
    void get_ans() {
        for(int i=1;i<=n;++i) {
            BIT_modify(a[i]); 
            ans+=i-BIT_query(a[i]);
        }
    }
}
using namespace get_init_ans; 
int main() {
    //read
    n=read();
    FOR(i,1,n) a[i]=lsh[i]=read();
    //lsh and init
    sort(lsh+1,lsh+1+n);
    len=unique(lsh+1,lsh+1+n)-lsh-1;
    FOR(i,1,n) {
        a[i]=lower_bound(lsh+1,lsh+1+len,a[i])-lsh;	
        build(rt[i],rt[i-1],1,len,a[i]);
    }
    //get_ans
    get_ans();
    cout<<ans<<"\n";
    //work
    m=read();
    FOR(i_ak_ioi,1,m) {
        int x=read(),y=read(),l,l1=0,l2=0,r,r1=0,r2=0;
        if(a[x]==a[y]) {
            cout<<ans<<"\n";
            continue;   
        }
        if(x>y) swap(x,y);
        //query
        l=x+1,r=y-1;
        if(l<=r) {
            l2=solve(l,r,a[x],1);
            l1=solve(l,r,a[x],0);
            r2=solve(l,r,a[y],1);
            r1=solve(l,r,a[y],0);
        }
        //update
        ans=ans-l2+l1-r1+r2+(a[x]<a[y] ? 1 : -1);
        cout<<ans<<"\n";
        //update
        for(int i=x;i<=n;i+=(i&-i)) {
            modify(rt[i+n],1,len,a[x],-1);
            modify(rt[i+n],1,len,a[y],1);
        }
        for(int i=y;i<=n;i+=(i&-i)) {
            modify(rt[i+n],1,len,a[y],-1);
            modify(rt[i+n],1,len,a[x],1);	
        }
        swap(a[x],a[y]);
    }
    return 0;
}
```

---

## 作者：King_of_gamers (赞：0)

~~大家咋都乱搞呢...~~

来个正经点的树套树吧,大致是树状数组套动态开点线段树(外面是树状数组,里面是动态开点线段树),根据求逆序对的常规操作,线段树维护一下区间和就好了.

~~我非常无聊的离散化了一下~~

### 第一步:构建树套树

把每个点加进树状数组中,然后维护线段树的区间和.

#### 维护区间和
在第p个点加上s(s为1则为加点,为-1则为删点)

```cpp

void add(int p,int s,int k)
{
    int l=1,r=mx,mid;
    while (l<r)
    {
        t[k].sum+=s;
        mid=(l+r)>>1;
        if (p<=mid)
        {
            if (!t[k].l) t[k].l=++top;
            k=t[k].l;
            r=mid;
        }
        else
        {
            if (!t[k].r) t[k].r=++top;
            k=t[k].r;
            l=mid+1;
        }
    }
    t[k].sum+=s;
}
```

#### 加入树状数组

要把每个点都updata一下

```cpp
void updata(int k,int s)
{
    int p=k;
    while (p<=n) add(h[k],s,root[p]),p+=p & (-p);
}
```


#### 因为每个点会被塞到树状数组中log个点中,每个点中维护线段树,所以时空复杂度$O(nloglogn)$

### 对于每个询问,维护树状数组和逆序对即可.

#### 得到一个点的逆序对贡献

利用树状数组前缀的特点求出1~p-1中h[p]+1~mx的数有几个和p+1~n中1~h[p]有几个
```cpp
int ask(int x,int y,int l,int r,int k)//线段树常规区间询问
{
    if ((!k)||(!t[k].sum)) return 0;
    if ((l==x)&&(r==y)) return t[k].sum;
    int mid=(l+r)>>1;
    if (y<=mid) return ask(x,y,l,mid,t[k].l);
    if (x>mid) return ask(x,y,mid+1,r,t[k].r);
    return ask(x,mid,l,mid,t[k].l)+ask(mid+1,y,mid+1,r,t[k].r);
}
```
```cpp
int query(int k,int l,int r)//询问1~k中l~r的数有几个
{
    if (k<1) return 0;
    if (k>n) return 0;
    if (l>r) return 0;
    int p=k;
    long long res=0;
    while (p) res+=ask(l,r,1,mx,root[p]),p-=p & (-p);
    return res;
}
```
```cpp

int getans(int p)//处理点p对答案的贡献
{
    return query(p-1,h[p]+1,mx)+query(n,1,h[p]-1)-query(p-1,1,h[p]-1);
}
```

#### 处理询问的主程序
```cpp
while (q--)
    {
        scanf("%d%d",&x,&y);
        if (x>y) swap(x,y);
        if (h[x]>h[y]) ans++;//如果x,y是一对逆序对,后面贡献会重复减
        ans-=getans(x)+getans(y);//减去原来x,y的贡献
        updata(x,-1);updata(y,-1);//删去原来x,y上的数
        swap(h[x],h[y]);
        if (h[x]>h[y]) ans--;//同上,会重复加
        updata(x,1);updata(y,1);//加上现在x,y上的数
        ans+=getans(x)+getans(y);//更新答案
        printf("%lld\n",ans);
    }
```
#### 视修改点数为常数,那么修改了数组数组中log个点,同时维护log颗线段树,所以时空复杂度为$O(loglogn)$(单次修改)

#### 综上,树套树做法时空约为$O(nloglogn+qloglogn)$
### 最后给出代码,仅供参考

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=20005;
struct node//离散化所需
{
    int v,id;
}a[N];
struct nodet//动态开点线段树
{
    int l,r,sum;
}t[10000005];
int n,q,x,y,mx,top,h[N],root[N];
long long ans;
void add(int p,int s,int k)//在线段树k中加入(删除)点p
{
    int l=1,r=mx,mid;
    while (l<r)
    {
        t[k].sum+=s;
        mid=(l+r)>>1;
        if (p<=mid)
        {
            if (!t[k].l) t[k].l=++top;
            k=t[k].l;
            r=mid;
        }
        else
        {
            if (!t[k].r) t[k].r=++top;
            k=t[k].r;
            l=mid+1;
        }
    }
    t[k].sum+=s;
}
int ask(int x,int y,int l,int r,int k)//询问线段树k中x~y的值
{
    if ((!k)||(!t[k].sum)) return 0;
    if ((l==x)&&(r==y)) return t[k].sum;
    int mid=(l+r)>>1;
    if (y<=mid) return ask(x,y,l,mid,t[k].l);
    if (x>mid) return ask(x,y,mid+1,r,t[k].r);
    return ask(x,mid,l,mid,t[k].l)+ask(mid+1,y,mid+1,r,t[k].r);
}
void updata(int k,int s)//更新点k信息
{
    int p=k;
    while (p<=n) add(h[k],s,root[p]),p+=p & (-p);
}
int query(int k,int l,int r)//询问1~k中l~r的值
{
    if (k<1) return 0;
    if (k>n) return 0;
    if (l>r) return 0;
    int p=k;
    long long res=0;
    while (p) res+=ask(l,r,1,mx,root[p]),p-=p & (-p);
    return res;
}
int getans(int p)//处理点p对答案贡献
{
    return query(p-1,h[p]+1,mx)+query(n,1,h[p]-1)-query(p-1,1,h[p]-1);
}
bool cmp(node a,node b)//sort用的
{
    return a.v<b.v;
}
int main()
{
    scanf("%d",&n);
    for (int i=1;i<=n;i++) scanf("%d",&a[i].v),a[i].id=i;
    sort(a+1,a+n+1,cmp);//离散化
    for (int i=1;i<=n;i++)
    {
        if (a[i-1].v!=a[i].v) mx++;
        h[a[i].id]=mx;
        root[i]=++top;
    }
    for (int i=1;i<=n;i++) updata(i,1),ans+=query(i-1,h[i]+1,mx);
    printf("%lld\n",ans);
    scanf("%d",&q);
    while (q--)//处理询问
    {
        scanf("%d%d",&x,&y);
        if (x>y) swap(x,y); 
        if (h[x]>h[y]) ans++;
        ans-=getans(x)+getans(y);
        updata(x,-1);updata(y,-1);
        swap(h[x],h[y]);
        if (h[x]>h[y]) ans--;
        updata(x,1);updata(y,1);
        ans+=getans(x)+getans(y);
        printf("%lld\n",ans);
    }
}
```

---


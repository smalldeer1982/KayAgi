# [国家集训队] 礼物

## 题目背景

一年一度的圣诞节快要来到了。每年的圣诞节小 E 都会收到许多礼物，当然他也会送出许多礼物。不同的人物在小 E 心目中的重要性不同，在小 E 心中分量越重的人，收到的礼物会越多。

## 题目描述

小 E 从商店中购买了 $n$ 件礼物，打算送给 $m$ 个人，其中送给第 $i$ 个人礼物数量为 $w_i$。请你帮忙计算出送礼物的方案数（两个方案被认为是不同的，当且仅当存在某个人在这两种方案中收到的礼物不同）。由于方案数可能会很大，你只需要输出模 $P$ 后的结果。


## 说明/提示

### 样例 1 解释
以 `/` 分割，`/` 前后分别表示送给第一个人和第二个人的礼物编号。$12$ 种方案详情如下：
```plain
1/23 1/24 1/34
2/13 2/14 2/34
3/12 3/14 3/24
4/12 4/13 4/23
```
### 数据规模与约定
设 $P= \prod_{i=1}^t p_i^{c_i}$，$p_i$ 为质数。

对于 $15\%$ 的数据，$n\leq 15$，$m\leq 5$，$p_i^{c_i}\leq 10^5$。

在剩下的 $85\%$ 数据中，约有 $60\%$ 的数据满足 $t\leq 2$，$c_i=1$，$p_i\leq 10^5$，约有 $30\%$ 的数据满足 $p_i\leq 200$。

对于 $100\%$ 的数据，$1\leq n\leq 10^9$，$1\leq m\leq 5$，$1\leq p_i^{c_i}\leq 10^5$，$1\leq w_i \leq P\leq 10^9$。


## 样例 #1

### 输入

```
100
4 2
1
2
```

### 输出

```
12```

## 样例 #2

### 输入

```
100
2 2
1
2```

### 输出

```
Impossible
```

# 题解

## 作者：___new2zy___ (赞：33)

# 题解 P2183 [国家集训队]礼物

题目传送门:

https://www.luogu.org/problemnew/show/P2183

==========================================

不得不说这是我做过的最正经的一道黑题了= =

在这里先吐槽一下：~~**数论真恶心**~~

很是佩服这题的第一个题解，就是有点小蒙，我来给大家讲一下我自己的理解方式

希望同学们能理解本题的核心**数论算法**：

**扩展卢卡斯定理**(ExLucas)

（这题其实可以当个模板题来做= =）

**前置知识**:

扩展欧几里得(Exgcd),乘法逆元,

中国剩余定理(CRT),Lucas定理(不必备)

（其实理解了做法也没什么难的对吧）（快逃）

==========================================

**简化版题面**:

你手中一共有**n件礼品**，你有**m个好~~(基)~~友**，

你打算**送给每个人wi件礼品**，

请你求出送出礼品的**方案数**，并让**答案对p取模**

请注意，**礼物**之间**两两不同**

==========================================

~~可能本人废话比较多，欢迎来吐槽~~

看完题目emmm。。。让我冷静一下= =

我们不妨假设**所有朋友收到的礼物数之和sum**:

	sum=∑(i:1~m)wi
    
如果记**答案为ans**的话,那么有:

	ans={C(n,sum)*C(sum,w1)*C(sum-w1,w2)*...*C(wi,wi)}%p

在上式中，C(n,m)代表组合数，每一项组合数乘在一起就是ans

那么**如果n<sum显然无解**，**即"impossible"**

（礼物不够当然没法送出去啦QAQ）

emmm....继续冷静思考，发现好像很简单？(逃

~~（只要**暴力递推计算**就好啦）~~

但是，如果我们**直接递推暴力求解ans**的话，那么会发现**时间复杂度不能接受**：

题目中给定的n的范围是1e9，预处理时直接递推求阶乘的话估计就要跑个很长时间吧= =所以这种做法显然是不可取的

那么这样就很难受，继续思考= =

"n很大，还要求组合数取模，那么用**Lucas定理吧**"

灵机一动，想到在数论问题中，对于类似于

C(n,m)%p(**必须保证p为prime**)的问题，

我们有一个定理:**Lucas定理**

这个定理大概长这个样子:

**Lucas(n,m)=C(n%p,m%p)*Lucas(n/p,m/p)**

其中Lucas(n,m)其实就是要计算的式子C(n,m)%p

对于这个定理，在此就不证明了~~(我比较菜所以不会证明)~~

**(注意:Lucas定理适用于n<=1e5)**

回到这题上来。。。

读者会发现，，好像我之前说的是废话= =

这个题n<=1e9好吧！！你在逗我？没法做。。

先淡定一下，到了这里其实已经离正解不远了，毕竟求解有了一定的方向

再次陷入沉思= =发现我们的**Lucas定理不可以直接使用**，因为题目中还有一个很致命的**限制条件**:

	p<=1e9（此外什么也没说）

那么就抛来一个很重要的问题:**模数p不保证是质数**

那么导致我们如果**直接用逆元取模**的话不行，因为可能在这些阶乘中出现取模，这样答案直接就变为0了，因此我们要尝试把这些数提取出来。

emmm。。。恐怖如斯= =根本没法做了啊

但是我们发现,题目中给了提示:

	设P=p1^c1*p2^c2*p3^c3*…*pt^ct,pi为质数。

其实这是数论中的**唯一分解定理**：

	任意大于1的正整数N,存在唯一分解式N=p1^c1*p2^c2*...*pi^ci
    
    其中p1~pi是质数,^是次方,c1~ci是次数
    
那么又可以很自然的想到:

我们可以将分子分母都对于p的唯一分解式中的每一项(即pi^ci)取模(就保证是prime了)，最后将每一项用CRT合并就得到了解

我们不妨再来考虑一下**组合数取模的计算公式**:

**C(n,m)%p={fac(n)/[fac(m)*fac(n-m)]}%p**

(注意，这里只是形式，实际上除法不能直接取模)

其中fac(x)表示x的阶乘，即x!

如果拆分的话，我们可以对于n!,m!,(n-m)!分别%p再进行合并即可求出答案

又可以注意到，其实整个问题就剩下了一个式子：

	求解(x!)%(pi^ci),保证pi为质数

对于这个式子展开可以发现，它的**求解分为三部分**:

1. 在x!中,若存在pi的倍数那么就可以拆出来,与pi^ci抵消，即可以转化为**子问题**：求**(x/pi)!%pi^ci**，只需要**递归**下去**求解**就行了

2. n!中可能有会包含多个完整的1~pi^ci-1（在%pi^ci下的剩余系），这部分可以先预处理一下(pi^ci-1)! (注意是不包含pi的倍数的阶乘，因为我们还要记录一下阶乘中pi的次数最后一起处理)，然后pi的若干次幂用快速幂处理。

3. 那么进行完1,2两步之后，对于剩下的部分直接求一发逆元计算组合数，最后合并即可（扩欧求逆元，中国剩余定理合并）

有些懵逼？我来举个栗子食用更佳哈：

假设pi=5，展开阶乘可以发现：

n!= (1*2*3*4*6*7*8*9*11*…)*5^(n/5)*(n/5)!


(乘号*没了555，变成了斜体请自行脑补)

那么我们直接提取出所有pi=5的倍数，正好分为三部分，直接按步骤上面计算就行了

其实以上就是~~(最恶心的)~~**数论算法:扩展卢卡斯定理(ExLucas)**

讲到这里。。。突然发现这东西好像和卢卡斯定理一点关系没有= =（所以Lucas不是必备的知识）

大概思路讲完了，我们在放代码之前可以来总结一下这次的求解方法，即**扩展卢卡斯定理(ExLucas)**

**扩展卢卡斯定理适用于计算任意的C(n,m)%p问题，其中n,m,p为任意正整数**

求解过程主要应用了**乘法逆元**（**扩欧Exgcd**求）、**中国剩余定理**(CRT也就只有一行)、带取模**快速幂**（码量很小）

总体来说思路还是很清楚的吧

那么好啦，既然有了解决方案，题目里的式子就很好求了吧，放个代码code~~~

PS:代码里也有解释哦


```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<queue>
#include<cstring>
using namespace std;
typedef long long ll;
const int inf=1e9+7;
inline ll poww(ll a,ll b,ll mod)//快速幂 
{
    ll base=a,ans=1;
    while(b)
    	{
          if(b&1)
             ans=(1ll*ans*base)%mod;
          base=(1ll*base*base)%mod;
          b>>=1;
    	}
    return 1ll*ans;
}
inline ll read()//快读
{
    ll p=0,f=1;char c=getchar();
    while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
    while(c>='0'&&c<='9'){p=p*10+c-'0';c=getchar();}
    return 1ll*f*p;}
ll n,m,sum,mod,ans=1,A[19];
inline void Exgcd(ll a,ll b,ll &x,ll &y)
//扩欧用来求逆元 
{
	if(!b){x=1,y=0;return ;}
	Exgcd(b,a%b,y,x);y-=a/b*x;
}
inline ll rev(ll k,ll p)
//求k在mod p下的逆元(转换一下变成正整数)
{
	if(!k)return 0;
	ll x=0,y=0,a=k,b=p;
	Exgcd(a,b,x,y);
	x=(x%b+b)%b;
	if(!x)x+=b;
	return 1ll*x;
}
inline ll mul(ll n,ll p,ll pk)
//求n!%pi^ci,pk=pi^ci
{
	if(!n)return 1;
	ll ans=1;
	for(ll i=2;i<=pk;i++)
		if(i%p)ans=ans*i%pk;
	ans=poww(ans,n/pk,pk);
	for(ll i=2;i<=n%pk;i++)
		if(i%p)ans=ans*i%pk;
	return 1ll*ans*mul(n/p,p,pk)%pk;
	//递归下去求解(n/pi)!%pi^ci 
}
inline ll C(ll n,ll m,ll mod,ll p,ll pk)
//求C(n,m)%mod,其中唯一分解之后质因子为p,总乘积为pk(pi^ci)
{
	if(m>n)return 0;
	ll a=mul(n,p,pk),b=mul(m,p,pk),c=mul(n-m,p,pk),k=0;
	//先求一下n!%pi^ci,m!%pi^ci,(n-m)!%pi^ci 
	for(ll i=n;i;i/=p)k+=i/p;
	for(ll i=m;i;i/=p)k-=i/p;
	for(ll i=n-m;i;i/=p)k-=i/p;
	//先除掉n!,m!,(n-m)!在%mod下的质因子p
	ll ans=1ll*a*rev(b,pk)%pk*rev(c,pk)%pk*poww(p,k,pk)%pk;
	//除去质因子p之后直接逆元求组合数(剩余部分) 
	return 1ll*ans*(mod/pk)%mod*rev(mod/pk,pk)%mod;
	//找到逆元了再乘回去(CRT合并)
}
int main()
{
	/*这是我在做这个题的时候写的解释
	思路:不妨设sum=∑wi(i:1~m)
	题目很简单,就是要求式子: 
	C(n,sum)*C(sum,w1)*C(sum-w1,w2)*...*C(wi,wi)
	但组合数要取模 
	自然想到逆元和Lucas定理 
	但是模数p不保证是质数,所以要用扩展Lucas
	不妨先把p唯一分解,对于每一个pi^ci都两两互质 
	可以求出C(n,m)%pi^ci
	对于求这个,除掉质因子pi然后求逆元 
	之后CRT一下乱搞就好啦 
	*/
	mod=read(),n=read(),m=read();
	for(int i=1;i<=m;i++)
		A[i]=read(),sum+=A[i];
	if(sum>n)//要送出的礼物多于有的礼物显然无解 
		{
			printf("Impossible");
			return 0;
		}
	for(ll k=1;k<=m;k++)//枚举每一个人要的礼物 
		{
			n-=A[k-1];
			ll now=0,x=mod;
			for(ll i=2;i<=sqrt(mod);i++)
            	//找到mod的每一个质因数p 
				if(!(x%i))
			  	 {
					  ll pk=1;
					  while(!(x%i))pk*=i,x/=i;//除掉质因数p
					  now=(now+C(n,A[k],mod,i,pk))%mod;
					  //求出C(n,A[k])%pi^ci累加
			  	 }
			if(x>1)now=(now+C(n,A[k],mod,x,x))%mod;
			ans=ans*now%mod;//统计答案 
		}
	printf("%lld",ans);//愉快的输出答案
	return 0;
}

```

好了，到这里大概就讲完了吧= =

真香，又是一道毒瘤呢（逃

感谢阅读~~~

最后来推广一下我的blog:

https://www.luogu.org/blog/new2zy/

拜拜~~~ >=<



---

## 作者：da_AA (赞：13)

~~看上去我的式子和别人的不一样所以我就来水一波233~~

我是这样考虑的：

对于这几个礼物，我们可以枚举排列，然后前$w_1$个给第一个人，之后的$w_2$个给第二个人……但是这样会有重复的，即有可能某个人拿的礼物的顺序不一样但是本质是相同的，这样的话，就要再除以$w_i!$，不要忘了剩下没分的那部分也有重的，所以最后的式子就是$\dfrac{n!}{(n-tot)!w_1!w_2!w_3!w_4!w_5!}$。

这样运用扩展lucas的思想就可以算了。

```C++
#include <cstdio>
#include <cmath>

typedef long long LL;

LL n, m, P;
LL w[6], tot;

void exgcd(LL a, LL b, LL &x, LL &y, LL &d) {
	if (!b) {
		d = a;
		x = 1;
		y = 0;
	} else {
		exgcd(b, a%b, y, x, d);
		y -= a / b * x;
	}
}

LL pow_mod(LL x, LL p, LL mod) {
	LL ans = 1;
	for (; p; p>>=1, x=x*x%mod) if (p&1) ans = ans * x % mod;
	return ans;
}

LL fac(LL n, LL p, LL pk) {
	if (!n) return 1;
	LL ans = 1;
	for (int i = 2; i <= pk; ++i) if (i%p) ans = ans * i % pk;
	ans = pow_mod(ans, n/pk, pk);
	for (int i = 2; i <= n%pk; ++i) if (i%p) ans = ans * i % pk;
	return ans * fac(n/p, p, pk) % pk;
}

LL inv(LL n, LL mod) {
	LL x, y, d;
	exgcd(n, mod, x, y, d);
	return (x%=mod) < 0 ? x+mod : x;
}

LL CRT(LL b, LL mod) {
	return b*(P/mod)%P*inv(P/mod, mod)%P;
}

LL calc(LL x, LL p) {
	LL k = 0;
	for (; x; x /= p) k += x / p;
	return k;
}

LL C(LL p, LL pk) {
	LL u = fac(n, p, pk), d = inv(fac(n-tot, p, pk), pk);
	for (int i = 1; i <= m; ++i) {
		d = d * inv(fac(w[i], p, pk), pk) % pk;
	}
	LL k = 0;
	k += calc(n, p);
	k -= calc(n-tot, p);
	for (int i = 1; i <= m; ++i) {
		k -= calc(w[i], p);
	}
	return u * d % pk * pow_mod(p, k, pk) % pk;
}

void work() {
	if (tot > n) {
		puts("Impossible");
		return;
	}
	LL ans = 0, tmp = P, pk;
	LL lim = sqrt(P) + 5;
	for (int i = 2; i <= lim; ++i) if (tmp % i == 0) {
		pk = 1;
		while (tmp % i == 0) pk*=i, tmp/=i;
		ans = (ans + CRT(C(i, pk), pk)) % P;
	}
	if (tmp > 1) {
		ans = (ans + CRT(C(tmp, tmp), tmp)) % P;
	}
	printf("%lld\n", ans);
}

int main() {
	scanf("%lld%lld%lld", &P, &n, &m);
	for (int i = 1; i <= m; ++i) scanf("%lld", &w[i]), tot += w[i];
	work();
	return 0;
}
```

---

## 作者：没名字可被用 (赞：9)

没人在这里发这题题解啊，我来发一篇。


明显答案是$C_n^{w_1}\times C_{n-w_1}^{w_2} \times \cdots$，如果要求的礼物总数超过了买的礼物，则直接输出`Impossible`。


求解一个组合数$C_n^m$对$p_i^{k_i}$的过程可以分别求分子和分母，然后再进行运算，即，求出$n!\mod p_i^{k_i}$，$m!\mod p_i^{k_i}$，$(n-m)!\mod p_i^{k_i}$后合并。注意分子可以含有大于$k_i$个$p_i$，这样的话求出来就直接为0了，而除掉分母的时候是可能会除掉一些$p_i$的；同时分母本身也可能有含有$p_i$的约数，于是统一把$p_i$移除来，不乘进答案，接下来用分子有的$p_i$的质数减掉分母的，然后乘上去即可。不可能出现减掉后为负数的情况，因为那样意味着组合数除不尽；有可能出现减掉后仍然大于$k_i$的情况，那么这个组合数在模$p_i^{k_i}$下为$0$。


具体地，对于求$n! \mod p_i^{k_i}$可以分为几个部分求解。将每个$p_i$的倍数提出一个$p_i$来，组成$p_i^{\lfloor \frac{n}{p_i} \rfloor}$；对于剩余的部分，容易发现除掉了$p_i$的数（原来是$p_i$的倍数）组成了一个新的阶乘，即$\lfloor \frac{n}{p_i} \rfloor !$，这个我们可以递归求解。剩下的数形如$1,2,\cdots,p-1,p+1,p+2,\cdots,2p-1 \cdots$（因为$p_i$的倍数已经通过前两步瓜分到阶乘和次幂里去了），由于$a \times b \mod p=(a \mod p) \times (b \mod p)$，易得$\prod _{i=1}^{p_i^{k_i}-1}i[i \mod p \neq 0]$与$\prod _{i=p_i^{k_i}+1}^{2p_i^{k_i}-1}i[i \mod p \neq 0] $在$\mod p_i^{k_i}$下是相等的，那么只需求一个$p^k$的长度的乘积在模$p_i^{k_i}$下的结果即可，而这个阶乘里包含了$ \lfloor \frac{n}{p_i^{k_i}} \rfloor$个这个余数，快速幂即可；还有剩下来的、没有达到$p_i^{k_i}$的一段数，由于长度不会超过$p_i^{k_i}$（即$10^5$），直接计算即可。



考虑求解答案，因为模的是一个和数，所以不能直接用普通的$lucas$求解。将和数$P$分解，得到$P=\prod_{i=1}^{k}p_i^{k_i}$，我们要求的答案模$p_i^{k_i}$的结果，对于单独求组合数在模每个$p_i^{k_i}$的剩余系下的结果要相同。于是考虑对于每个组合数，单独求出对$p_i^{k_i}$的结果，然后通过中国剩余定理求解即可。


代码
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn=6;
const int maxp=(int)1e5+5;
int P,n,m,w[maxn],pri[maxp],cnt[maxp],tot=0,c[maxp],R[maxp],M[maxp];
map<int ,int > re;
inline int maybs(int x) {return x<0?-x:x;}
void div(int x)
{
    for(int i=2;i*i<=x;i++) {
        if(x%i==0) {
            pri[++tot]=i;re[i]=tot;
            while(x%i==0) x/=i,cnt[tot]++;
        }
    }
    if(x!=1) {
        if(re.find(x)==re.end()) pri[++tot]=x,re[x]=tot;
        cnt[re[x]]++;
    }
}
int quickpow(int x,int k)
{
    int ret=1;
    while(k>0) {
        if(k&1) ret=ret*x;
        x=x*x; k>>=1;
    }
    return ret;
}
int quickpow(int x,int k,int mo)
{
    int ret=1;
    while(k>0) {
        if(k&1) ret=1ll*ret*x%mo;
        x=1ll*x*x%mo; k>>=1;
    }
    return ret;
}
int gcd(int a,int b) {return b==0?a:gcd(b,a%b);}
int extgcd(int a,int b,int &x,int &y)
{
    if(b==0) {x=1,y=0; return a;}
    else {int d=extgcd(b,a%b,y,x);y-=a/b*x;return d;}
}
int inv(int q,int p)
{
    assert(gcd(p,q)==1);
    int x,y;
    extgcd(q,p,x,y);
    x=(x%p+p)%p; if(!x) x+=p;
    return x;
}
int Cnt(int x,int p) {
    if(x==0) return 0;
    return Cnt(x/p,p)+x/p;
}
typedef pair<int ,int > pii;
#define fir first
#define sec second
#define MP make_pair
pii Cal(int x,int p,int k)
{
    if(x==1 || x==0) return MP(1,0);
    int ret=1,del=0,tmp=quickpow(p,k);
    int cou=Cnt(x,p);
    del=cou;

    pii nw=Cal(x/p,p,k);
    ret=1ll*ret*nw.fir%tmp;

    if(x>=tmp) {
        int lev=1;
        for(int i=1;i<tmp;i++) {
            if(i%p==0) continue;
            lev=1ll*lev*i%tmp;
        }
        ret=1ll*ret*quickpow(lev,x/tmp,tmp)%tmp;
    }

    for(int i=x;i>=1;i--) {
        if(i%tmp==0) break;
        if(i%p==0) continue;
        ret=1ll*ret*i%tmp;
    }
    return MP(ret,del);
}
int getAns()
{
    for(int i=1;i<=tot;i++) M[i]=1;
    for(int i=1;i<=tot;i++) {
        for(int j=1;j<=tot;j++)
            if(i==j) continue;
            else M[i]=1ll*M[i]*R[j]%P;
    }
    int ret=0;
    for(int i=1;i<=tot;i++) ret=(ret+((1ll*c[i]*M[i]%P)*1ll*inv(M[i],R[i]))%P)%P;
    return ret;
}
int main()
{
    scanf("%d",&P);
    div(P);
    scanf("%d%d",&n,&m);
    int sum=0;
    for(int i=1;i<=m;i++) {scanf("%d",&w[i]);sum+=w[i];}
    if(sum>n) {printf("Impossible\n");exit(0);}
    int ans=1,N=n,M,res=1;
    pii up,dw1,dw2;
    for(int i=1;i<=m;i++) {
        M=w[i];
        for(int j=1;j<=tot;j++) R[j]=quickpow(pri[j],cnt[j]);
        for(int j=1;j<=tot;j++) {
            ans=1;
            up=Cal(N,pri[j],cnt[j]);
            dw1=Cal(M,pri[j],cnt[j]),dw2=Cal(N-M,pri[j],cnt[j]);
            up.sec-=dw1.sec; up.sec-=dw2.sec;
            assert(up.sec>=0);

            if(up.sec>=cnt[j]) ans=0;
            else {
                ans=1ll*ans*up.fir%R[j];
                ans=1ll*ans*inv(dw1.fir,R[j])%R[j]; ans=1ll*ans*inv(dw2.fir,R[j])%R[j];
                ans=1ll*ans*quickpow(pri[j],up.sec,R[j])%R[j];
            }
            c[j]=ans;
        }
        res=1ll*res*getAns()%P;
        N-=w[i];
    }
    printf("%d\n",res);
    return 0;
}

```

---

## 作者：eee_hoho (赞：7)

题不是很难，黑题应该~~虚高~~了

看到题之后，应该就能写出式子

$$ans=\prod_{i=1}^{m}C_{n-\sum_{j=1}^{i-1}w_j}^{w_i}(mod\ P)$$

式子看起来很麻烦，其实很好想

当我们给第一个人送礼物的时候，我们有$n$个礼物，要选$w_1$个，方案就有$C_n^{w_{1}}$种

然后给第二个人送礼物的时候，我们剩下$n-w_1$个礼物，要选$w_2$个，方案有$C_{n-w_1}^{w_2}$种

就这样一直送到第$m$个人，而根据乘法原理，就得到这个式子了

这道题似乎就做完了，但在算$C_n^m(mod\ p_i^{c_i})$时又遇到了瓶颈：$p_i^{c_i}$不是质数

既然不是质数，我们就不能用$Lucas$定理来求，这就需要用到$ExLucas$了

虽然是扩展的，但和$Lucas$完全沾不上边

我们观察到题目给了$P=\prod _{i=1}^{t}p_{i}^{c_i}$

而$p_i$是质数，那么所有的$p_i^{c_i}$都是互质的

那么我们只要对于每个$p_i^{k=c_i}$求出其$C_n^m\ mod\ p_i^k$的值，然后用**中国剩余定理**就可以算出最小正整数解

问题转化成了如何快速的求$C_n^m\ mod\ p^k$

把组合数展开，我们得到

$$\frac{n!}{m!(n-m)!}\ mod\ p^k$$

那么只要快速求出模意义下的阶乘就好了

如果我们要求$x!\ mod\ p^k$，假设$x=17,p=2,k=3$，观察一下式子

$$17!=1\times2\times3\times4\times5\times6\times7\times8\times9\times10\times11\times12\times13\times14\times15\times16\times17$$

化式子$17!=$

$$2\times4\times6\times8\times10\times12\times14\times16\times1\times3\times5\times7\times9\times11\times13\times15\times17$$


$$(2\times1)\times(2\times2)\times(2\times3)\times…\times(2\times8)\times(1\times3\times5\times…\times17)$$

$$2^8\times(1\times2\times3\times…\times8)\times(1\times3\times5\times…\times17)$$

$$2^8\times8!\times(1\times3\times5\times7\times9\times11\times13\times15\times17)$$

而在模$p^k=2^3=8$意义下$1\times3\times5\times7=9\times11\times13\times15$

所以式子就变成了

$$2^8\times8!\times(1\times3\times5\times7)^2\times17$$

那么$x!$就变成了$p^n\times t!\times(a_1\times a_2\times…a_m)^r\times a_{m+1}\times…a_{q}$

可以看出$n=t=\left \lfloor \frac{x}{p} \right \rfloor,r=\left \lfloor \frac{x}{p^k} \right \rfloor$，其中$t!$可以一直递归求解，然后后面的暴力算

这样这个题就做完啦QAQ

**Code**
``` cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
#define int long long
using namespace std;
int p[200000],n,m,P,cnt,z[200000],a[200000],ans;
void exgcd(int a,int b,int &x,int &y)     //扩欧
{
	if (!b)x=1,y=0;
	else
	{
		exgcd(b,a%b,x,y);
		int t=x;
		x=y;
		y=t-a/b*y;
	}
}
int mypow(int a,int x,int p)      //快速幂
{
	int s=1;
	while (x)
	{
		if (x&1)s=s*a%p;
		a=a*a%p;
		x>>=1;
	}
	return s;
}
int fac(int n,int a,int b)    //求阶乘
{
	if (!n)return 1;       
	int s=1;
	for (int i=1;i<=b;i++)    //处理a1*a2*…am
		if (i%a!=0)
			s=s*i%b;
	s=mypow(s,n/b,b);
	for (int i=1;i<=n%b;i++)  //处理am+1*…aq
		if (i%a!=0)
			s=s*i%b; 
	return s*fac(n/a,a,b)%b;  //递归求解
}
int inv(int a,int b)    //求逆元
{
	int x,y;
	exgcd(a,b,x,y);
	return (x%b+b)%b;
}
int C(int m,int n,int a,int b)   //处理组合数
{
	int nn=fac(n,a,b),mm=fac(m,a,b),nm=fac(n-m,a,b),po=0;  //求阶乘
	for (int i=n;i;i/=a)      //处理n^p中的p
		po+=i/a;
	for (int i=m;i;i/=a)
		po-=i/a;
	for (int i=n-m;i;i/=a)
		po-=i/a;
	return nn*mypow(a,po,b)%b*inv(mm,b)%b*inv(nm,b)%b; 
}
signed main()
{
	cin>>n>>m>>P;
	int pp=P;
	for (int i=2;i*i<=P;i++)     //分解
		if (pp%i==0)
		{
			int x=i;
			z[++cnt]=i;
			while (pp%x==0)x*=i;
			x/=i;
			p[cnt]=x;
			pp/=x;
		}
	if (pp!=1)p[++cnt]=pp,z[cnt]=pp;
	for (int i=1;i<=cnt;i++)
		a[i]=C(m,n,z[i],p[i]);
	for (int i=1;i<=cnt;i++)    //中国剩余定理
	{
		int pi=P/p[i],x,y;
		exgcd(pi,p[i],x,y);
		ans=((ans+pi*a[i]*x%P)+P)%P;
	}
	cout<<ans<<endl;
	return 0;
}
```

---

## 作者：冘木 (赞：4)

[更好的观看体验](https://www.cnblogs.com/you-mu-jv-ruo/p/13100139.html)
# [[国家集训队]礼物](https://www.luogu.com.cn/problem/P2183)

## 前置知识：

### [扩展卢卡斯定理](https://oi-wiki.org/math/lucas/#exlucas)

## 正文：

emmm，我可以说这是一道模板题吗。。。。

首先我们来分析题意：

简单来说，就是一共有 $n$ 个不同的礼物和 $m$ 个人，第 $i$ 个人需要 $w_i$ 个礼物，问一共有多少种不同的方案数。

我们可以很轻松地看出这是一道与组合数有关的题目，对于总方案数，我们可以将其分解为 $m$ 个不同的方案数的乘积（乘法原理），我们以题中的样例一为例：现在一共有 $4$ 个礼物和 $2$ 个人，第一个人要 $1$ 个礼物，则第一个人取走礼物的方案数为 $C_4^1$ 种；第二个人要 $2$ 个礼物，而在第一个人取走礼物后，还剩下 $3$ 个礼物，所以第二个人取走礼物的方案数为 $C_3^2$ 种。所以，总方案数就为 $C_4^1 * C_3^2=12$ 种。

现在我们改变取走礼物的顺序：让第二个人先取走两个礼物，这时第二个人取走礼物的方案数为 $C_4^2$种，再让第一个人取走礼物的方案数，此时还剩下 $2$ 个礼物，也就是说，第一个人取走礼物的方案数有 $C_2^1$ 种。所以，总方案数就为 $C_4^2*C_2^1=12$ 种。

我们可以发现，无论谁先取走礼物，最终结果都是一样的，所以我们只需按所给的礼物数量顺序计算就行。也就是说，总方案数的式子为:
$$
\begin{align}
ans=C_n^{w_1}+C_{n-w_1}^{w_2}+\cdots +C_{n-w_1-w_2\cdots-w_m}^{w_m}
\end{align}
$$
然鹅，题目中还有无解的情况，那什么情况下会无解呢？很显然，只有在礼物不够用时才会无解，所以我们可以在计算答案的同时判断剩余的礼物是否为负数，若是，则输出 $Impossible$ ，否则继续计算。

到这里为止，我们已经知道如何计算最终答案了，只要在途中取模就能得到答案，是不是很简单？

**不，你想的太简单了**

我们来看一下这一题的模数。

![](https://img2020.cnblogs.com/blog/2061115/202006/2061115-20200612161657145-101060053.png)

emm，这模数有点大，感觉总有些不对的地方，再仔细看看。

![](https://img2020.cnblogs.com/blog/2061115/202006/2061115-20200612161657145-101060053.png)

？？？，什么情况？$P$ 不一定为质数？？？

既然P不一定为质数，那我们就没法求组合数了啊，怎么办呢？这时候，便要用到扩展卢卡斯定理了。

什么？你问我什么是扩展卢卡斯定理？[你康康这里](https://oi-wiki.org/math/lucas/#exlucas) 。~~别问我为什么这叫扩展卢卡斯，我也不知道他到底和卢卡斯定理有啥关系~~

总而言之，只要用了扩展卢卡斯定理，我们就能解决模数 $P$ 不是质数的情况，这也是这道题真正的考点。接下来，只要带入模板，将模数分解计算即可。

代码如下：

~~~c++
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll pow_mod(ll x,ll n,ll mod){
	ll res=1;
	while(n>0){
		if (n&1) res=res*x%mod;
		x=x*x%mod;
		n>>=1;
	}
	return res;
}

ll exgcd(ll a,ll b,ll &x,ll &y){
	if (b==0){
		x=1;
		y=0;
		return a;
	}
	ll d=exgcd(b,a%b,x,y);
	ll t=x;
	x=y;
	y=t-a/b*y;
	return d;
}

ll CRT(ll n,ll *a,ll *b){
	ll M=1,res=0;
	for (ll i=0;i<n;i++) M=M*b[i];
	for (ll i=0;i<n;i++) {
		ll x,y;
		ll g=M/b[i];
		exgcd(g,b[i],x,y);
		res=(res+g*x*a[i])%M;
		if (res<0) res+=M;
	}
	return res;
}

ll cal(ll n,ll p,ll mod){
	if (n==0) return 1;
	ll res=1;
	for (ll i=1;i<=mod;i++){
		if (i%p!=0){
			res=res*i%mod;
		}
	}
	res=pow_mod(res,n/mod,mod);
	for (ll i=1;i<=n%mod;i++){
		if (i%p){
			res=res*i%mod;
		}
	}
	return res*cal(n/p,p,mod)%mod;
}

ll work(ll n,ll m,ll p,ll mod){
	ll cnt=0;
	for (ll i=n;i;i/=p) cnt+=i/p;
	for (ll i=m;i;i/=p) cnt-=i/p;
	for (ll i=n-m;i;i/=p) cnt-=i/p;
	return pow_mod(p,cnt,mod)*cal(n,p,mod)%mod*
		   pow_mod(cal(m,p,mod),mod/p*(p-1)-1,mod)%mod*
		   pow_mod(cal(n-m,p,mod),mod/p*(p-1)-1,mod)%mod;
}
ll com(ll n,ll m,ll p){
	if (n<m) return 0;
	ll a[20],b[20],tot=0;
	for (int i=2;i*i<=p;i++){
		if (p%i==0){
			b[tot]=1;
			while(p%i==0) p/=i,b[tot]*=i;
			a[tot]=work(n,m,i,b[tot]);
			tot++;
		}
	}
	if (p>1){
		b[tot]=p;
		a[tot]=work(n,m,p,b[tot]);
		tot++;
	}
	return CRT(tot,a,b);
}
int main(){
	ll p;
	scanf("%lld",&p);
	ll n,m;
	scanf("%lld %lld",&n,&m);
	ll ans=1;
	for (int i=0;i<m;i++){
		ll w;
		scanf("%lld",&w);
		if (n<0 || n<w){
			puts("Impossible");
			return 0;
		}
		ans=ans*com(n,w,p)%p;
		n-=w;
	}
	printf("%lld\n",ans);
	return 0;
}
~~~

最后：**ac第一道黑题祭**（~~怎么感觉这道题有点水呢）~~

都看到这里了，点个赞吧各位大佬萌。

---

## 作者：CG__HeavenHealer (赞：3)

前两天考试考了这题，一眼就看出是卢卡斯，打了个上去发现**模数不是质数！！**偏偏又不会扩展卢卡斯~~直接爆炸~~，考后就学了一下~~并水一篇题解~~。

### 题意

有 $m$ 个人， $n$ 个礼物，第 $i$ 个人需要 $w_i$ 件礼物，问有多少种分配方式。如果没有合法方案，输出 $Impossible$ 。

### 解法

答案很显然，如果 $\sum_{i=1}^nw_i>n$ ，就无解；否则，答案就是 $\prod_{i=1}^n C_{n - pre}^{w_i}$ ，$pre$ 表示的是 $\sum_{j=1}^iw_i$ 。

直接计算 $C_{n-pre}^{w_i}$ 肯定爆炸，模数又不是质数，所以我们就要祭出这篇题解的主角了：**扩展卢卡斯**

扩展卢卡斯和卢卡斯定理一样，都能在较大的数据内解决 $C_n^m \% p$ 这样的问题，但卢卡斯定理要求模数是质数，对于模数不是质数的问题就只能用扩展卢卡斯解决了。

### 前置知识

1. 中国剩余定理
2. 扩展欧几里得定理
3. 逆元

~~（没错不需要卢卡斯定理）~~

如有需要可以看看 [这里](https://www.luogu.com.cn/blog/375030/shuo-xue-zong-jie) 的中国剩余定理和扩欧的部分，剩下的部分也可以简单看看，可能下面要用。

### 正片

扩展卢卡斯，解决的是形如 $C_n^m \% p$ 的问题。有的时候， $n,m$ 非常大，不能直接计算阶乘，当 $p$ 为质数时，可以用卢卡斯定理：

$C_n^m \equiv C_{n / p}^{m / p} \times C_{n\mod p}^{m\mod p} (\mod p)$ 来递归分解 $n,m$ ，使之在我们可行的范围内求解；而当模数不是质数的情况下，且不提 $Lucas$ 定理的式子可不可行，就连 $m!,(n-m)!$ 的逆元都不一定求的出来。所以，我们需要一些技巧来求解。

因为模数本身不是质数，所以一定可以被唯一分解为多个质数的乘积。我们可以设 $p = p_1^{c_1}\times p_2^{c_2} \times \ldots p_k^{c_k}$ ，这样就可以把解 $C_n^m $ 的问题转为求该剩余系方程组的解：

$$\left\{\begin{aligned} C_n^m&\equiv p_1^{c_1} \\  C_n^m&\equiv p_2^{c_2} \\ &\cdots \\  C_n^m&\equiv p_k^{c_k} \end{aligned}\right.$$ 

我们逐步解决这个问题：假设我们正在求第 $i$ 个方程的解，我们可以把方程转化为 $\dfrac {n!} {m!(n-m)!} \mod p_i^{a_i}$ 。

~~（这些我们都知道啊，但是你给我求个逆元看看！！)~~

既然 $p_i$ 是质数，而模数里又只有 $p_i$ ，那我们直接把 $p_i$ 全除掉不就好了吗？

这样，我们就可以把这个式子进一步转化为：

$$\dfrac {\dfrac {n!} {p_i^x}} {{\dfrac {m!}{{p_i}^y}} \times {\dfrac{(n-m)!}{p_i^z}}} \times {p_i^{x-y-z}} \mod p_i $$ 

$x,y,z$ 分别指 $p_i$ 在 $n!,m!,(n-m)!$ 中的出现次数。这样，分母的这一堆显然就与 $p_i$ 互质了，分母部分的逆元也就可以求出了。

接下来的问题就是怎么快速求出 $\dfrac {n!} {p_i^x}$ 这个东西了。

我们可以考虑把 $n!$ 拆开，然后观察规律。

以 $23(\mod 3^2)$ 为例：

$23!=1\times2\times3\times\ldots\times22\times23=3\times6\times9\times12\times15\times18\times21\times1\times2\times4\times5\cdots\times22\times23=3^7\times(7!)\times1\times2\times\ldots\times22\times23$

再手模几组例子，可以得到：

$$n!=p_i^{\lfloor\dfrac n{p_i}\rfloor}\times{\prod_{i=1\ \&\&\ i\%p_i\ne0}^{p_i^{a_i}}i}^{\dfrac n{p_i^{a_i}} } \times \prod_{i=n-\lfloor\dfrac n{p_i}\rfloor+1\ \&\&\ i\%p\ne0}^n i\times(\lfloor \dfrac n{p_i^{a_i}}\rfloor!)$$

（看起来很吓人，其实直接把上面的例子带到这个式子上面就能理解了）

至于 $1\times2\times4\times5\ldots\times16\times17$ 这一部分为什么会变成 ${\prod_{i=1\ \&\&\ i\%p_i\ne0}^{p_i^{a_i}}i}^{\dfrac n{p_i^{a_i}}}$ ，是因为在 $\mod p_i^{a_i}$ 时，这部分会进行循环。

但是这样处理后并没有把 $p_i^{a_i}$ 的项完全解决掉，因为即便取模后，当 $n$ 非常大时 $\lfloor \dfrac n{p_i^{a_i}}\rfloor!$ 这部分还可能有能被 $p_i^{a_i}$ 整除的项。所以我们可以递归进行这一过程。

设 $F(n) = \dfrac {n!}{p_i^{x}}$ ，则 $F(x)=F(\lfloor \dfrac n{p_i}\rfloor)\times{\prod_{i=1\ \&\&\ i\%p_i\ne0}^{p_i^{a_i}}i}^{\dfrac n{p_i^{a_i}} } \times \prod_{i=n-\lfloor\dfrac n{p_i}\rfloor+1\ \&\&\ i\%p\ne0}^n i$ ，递归边界： $F(0) = 1$ 。

但是为了求出逆元，并且令方程的意义不变，我们又乘上了这个东西： $p_i^{x-y-z}$ ，它又怎么求呢？

设 $G(n)=x$ ，$x$ 的意义就是上式中 $p_i$ 的次数，从 $n!$ 的式子可以得到，我们要的是这一项： $p_i^{\lfloor\dfrac n{p_i}\rfloor}$。

和 $F(n)$ 一样，${\lfloor\dfrac n{p_i}\rfloor}!$ 里也可能有能被 $p_i^{a_i}$ 整除的项，类似于 $F(n)$ ，我们对 $G(n)$ 递归求解：

$G(n) = G(\lfloor\dfrac n{p_i}\rfloor) + \lfloor\dfrac n{p_i}\rfloor$ ，递归边界为 $n<p$ 时 $G(n) = 0$ 。

这样，整个问题已经接近尾声，最后只需要 CRT 合并一下几个方程就好了。

### Code：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define ri register int
inline int read() {
    ri x = 0, f = 1;
    char ch = getchar();
    for (; !isdigit(ch); ch = getchar())
        if (ch == '-') f = -1;
    for (; isdigit(ch); ch = getchar()) x = (x << 1) + (x << 3) + (ch ^ 48);
    return f * x;
}
int w[20], n, m, p, sum;
namespace EX_Lucas {
inline int qpow(int a, int b, int md) {
    int res = 1;
    for (; b; b >>= 1, a = a * a % md)
        if (b & 1) res = res * a % md;
    return res % md;
}
int exgcd(int a, int b, int &x, int &y) {
    if (!b) return x = 1, y = 0, a;
    int d = exgcd(b, a % b, y, x);
    return y -= a / b * x, d;
}
int gcd(int a, int b) { return b ? gcd(b, a % b) : a; }
inline int inv(int a, int p) {
    int x = 0, y = 0;
    exgcd(a, p, x, y);
    return (x % p + p) % p;
}
int F(int n, int md, int p) {  // n! / p^x
    if (!n) return 1;
    int k = 1, last = 1;
    for (ri i = 1; i <= p; i++)
        if (i % md) (k *= i) %= p;
    k = qpow(k, n / p, p);
    for (ri i = p * (n / p); i <= n; i++)
        if (i % md) (last *= (i % p)) %= p;
    return F(n / md, md, p) * k % p * last % p;
}
int G(int n, int p) { return n < p ? 0 : G(n / p, p) + (n / p); }
inline int C(int n, int m, int md, int p) {
    int fenzi = F(n, md, p), fenmu1 = inv(F(m, md, p), p),
        fenmu2 = inv(F(n - m, md, p), p);
    int P = qpow(md, G(n, md) - G(m, md) - G(n - m, md), p);
    return fenzi * fenmu1 % p * fenmu2 % p * P % p;
}
inline int CRT(int a, int m, int p) { // x = a(mod m)
    return (a * inv(p / m, m) % p * (p / m)) % p;
}
inline int exlucas(int n, int m, int p) {
    int base = p, res = 0;
    for (ri i = 2; i * i <= p; i++)
        if (!(base % i)) {
            int ci = 1;
            while (!(base % i)) ci *= i, base /= i;
            (res += CRT(C(n, m, i, ci), ci, p)) %= p;
        }
    if (base > 1) (res += CRT(C(n, m, base, base), base, p)) %= p;
    // divide && CRT
    return res;
}
}  // namespace EX_Lucas
using namespace EX_Lucas;
signed main() {
    int p = read(), n = read(), m = read();
    for (ri i = 1; i <= m; i++) w[i] = read(), sum += w[i];
    if (sum > n) return puts("Impossible"), 0;
    int pre = 0, res = 1;
    for (ri i = 1; i <= m; i++) {
        res *= exlucas(n - pre, w[i], p);
        pre += w[i], res %= p;
    }
    printf("%lld", res % p);
    return 0;
}
```



---

## 作者：撤云 (赞：2)

[博客](https://www.cnblogs.com/hbxblog/p/10211424.html)
#### 题目链接
[戳这](https://www.luogu.org/problemnew/show/P2183)
#### Title Solution
这一道题显然可以看出公式为：
$$ans=C_{n}^{w_1}*C_{n-w}^{w_2}*...*C_{w_m}^{w_m}$$
然后就可以用扩展Lucas求解了。
至于扩展Lucas:[戳这](https://www.cnblogs.com/hbxblog/p/10211177.html)
#### code
``` cpp
#include<bits/stdc++.h>
#define rg register
#define int long long
#define file(x) freopen(x".in","r",stdin);freopen(x".out","w",stdout);
using namespace std;
int read(){
    int x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9') f=(c=='-')?-1:1,c=getchar();
    while(c>='0'&&c<='9') x=x*10+c-48,c=getchar();
    return f*x;
}
void exgcd(int a,int b ,int &x,int &y){

    if(!b){x=1,y=0;return;}
    exgcd(b,a%b,x,y);
    int t=x;
    x=y,y=t-(a/b)*y;
}
int inv(int a,int b){
    int x,y;
    return exgcd(a,b,x,y),(x%b+b)%b;
}
int ksm(int a,int b,int p){
    int ans=1;
    while(b){
        if(b&1)
            ans=a*ans%p;
        a=a*a%p;
        b>>=1;
    }
    return ans%p;
}
int crt(int x,int p,int mod){
    return inv(p/mod,mod)*(p/mod)*x;
}
int fac(int x,int a,int b){
    if(!x)
        return 1;
    int ans=1;
    for(int i=1;i<=b;i++)
        if(i%a)
            ans*=i,ans%=b;
    ans=ksm(ans,x/b,b);
    for(int i=1;i<=x%b;i++)
        if(i%a)
            ans*=i,ans%=b;
    return ans*fac(x/a,a,b)%b;
}
int C(int n,int m,int a,int b){
    int N=fac(n,a,b),M=fac(m,a,b),Z=fac(n-m,a,b),sum=0;
    for(int i=n;i;i=i/a)
        sum+=i/a;
    for(int i=m;i;i=i/a)
        sum-=i/a;
    for(int i=n-m;i;i=i/a)
        sum-=i/a;
    return N*ksm(a,sum,b)%b*inv(M,b)%b*inv(Z,b)%b;
}
int exlucas(int n,int m,int p){
    int t=p,ans=0;
    for(int i=2;i*i<=p;i++){
        int k=1;
        while(t%i==0)
            k*=i,t/=i;
        ans+=crt(C(n,m,i,k),p,k),ans%=p;
    }
    if(t>1)
        ans+=crt(C(n,m,t,t),p,t),ans%=p;
    return ans%p;
}
int a[11];
void slove(){
    int p=read(),n=read(),m=read(),sum=0;
    for(int i=1;i<=m;i++)
        a[i]=read(),sum+=a[i];
    if(n<sum)
        printf("Impossible\n"),exit(0);
    int ans=1;
    for(int i=1;i<=m;i++)
        ans*=exlucas(n,a[i],p),ans%=p,n-=a[i];
    printf("%lld",ans%p);
}
main(){
    slove();
    return 0;
}
```

---

## 作者：GoPoux4 (赞：1)

这是一道我第一道自己想出解法的黑题，纪念一下。~~这题竟然是黑题？~~

---

前置芝士：

[扩展卢卡斯定理](https://www.luogu.com.cn/blog/hhwkksk/lucas-lu-ka-si-ding-li)

有些dalao讲得比我好，建议找其他大佬的博客看罢。

--

从第一个人开始考虑，从 $n$ 件礼物中选出 $w_1$ 件礼物的方案数为 $C_n^{w_1}$.

到第二个人时，还剩下 $n-w_1$ 件礼物，方案数为 $C_{n-w_i}^{w_2}$。

到这里已经可以看出一些规律了：

给前 $i$ 个人分发礼物的方案数为：

$$C_n^{w_1} * C_{n-w_1}^{w_2} * C_{n-w_1-w_2}^{w_3} * ... * C_{n-w_1-w_2-...-w_{i-1}}^{w_i} \ {\rm{mod}} \ p$$

我们就把问题转化为求 $C_n^m \ {\rm{mod}} \ p$了。

什么能求这个式子？（注意：不保证 $p$ 为负数）

**扩展卢卡斯定理**

然后就是套板子了qwq。

---

需要注意的是，不存在可行方案时，总方案为0。但是答案模了 $p$，$ans \equiv 0 \ ({\rm{mod}} \ p)$ 时，最后的答案也为0。那么怎么判断是否无解呢？

不难发现，当 $sumw > n$ 时，一定无解，反之，一定存在一个解。于是求出 $sumw$ 再特判一下就好了。

---

代码：

```cpp
#include <iostream>
#include <cstring>
#include <cstdio>
#include <algorithm>
#include <cmath>
#define lxl long long
using namespace std;

inline lxl fmi(lxl a,lxl b,lxl p)
{
	lxl ans=1;
	a%=p;
	while(b>0)
	{
		if(b&1) ans=(ans*a)%p;
		a=(a*a)%p;
		b>>=1;
	}
	ans%=p;
	return ans;
}

inline lxl exgcd(lxl a,lxl b,lxl &x,lxl &y)
{
	if(!b) {x=1,y=0;return a;}
	lxl k=exgcd(b,a%b,x,y);
	lxl z=x;x=y,y=z-a/b*y;
	return k;
}

inline lxl inv(lxl a,lxl b)
{
	lxl x,y;
	lxl g=exgcd(a,b,x,y);
	return g==1?(x%b+b)%b:-1;
}

inline lxl mul(lxl n,lxl pi,lxl pk)
{
	if(!n) return 1;
	lxl ans=1;
	if(n/pk)
	{
		for(lxl i=2;i<=pk;i++)
			if(i%pi) ans=ans*i%pk;
		ans=fmi(ans,n/pk,pk);
	}
	for(lxl i=2;i<=n%pk;i++)
		if(i%pi) ans=ans*i%pk;
	return ans*mul(n/pi,pi,pk)%pk;
}

inline lxl C(lxl n,lxl m,lxl p,lxl pi,lxl pk)
{
	if(n<m) return 0;
	lxl a=mul(n,pi,pk);
	lxl b=mul(m,pi,pk);
	lxl c=mul(n-m,pi,pk),k=0,ans;
	for(lxl i=n;i;i/=pi) k+=i/pi;
	for(lxl i=m;i;i/=pi) k-=i/pi;
	for(lxl i=n-m;i;i/=pi) k-=i/pi;
	ans=a*inv(b,pk)%pk*inv(c,pk)%pk*fmi(pi,k,pk)%pk;
	ans=ans*(p/pk)%p*inv(p/pk,pk)%p;
	return ans;
}

inline lxl exLucas(lxl n,lxl m,lxl p)
{
	lxl ans=0,x=p,t=sqrt(p);
	for(lxl i=2;i<=t;i++)
		if(x%i==0)
		{
			lxl pk=1;
			while(x%i==0) x/=i,pk*=i;
			ans=(ans+C(n,m,p,i,pk))%p;
		}
	if(x>1) ans=(ans+C(n,m,p,x,x))%p;
	return ans;
}

lxl p,n,m,w,sum=0;

int main()
{
	//freopen("P2183.in","r",stdin);
	scanf("%lld%lld%lld",&p,&n,&m);
	lxl ans=1,nn=n;
	for(int i=1;i<=m;i++)
	{
		scanf("%lld",&w);sum+=w;
		ans=(ans*exLucas(n,w,p))%p;
		n-=w;//将已选的礼物减去
	}
	if(sum>nn) printf("Impossible\n");//特判
	else printf("%lld\n",ans);
	return 0;
}

```


---

## 作者：水無月嘉祥 (赞：1)

[$\Huge \color{gold}{my\;\;blog}$](https://www.luogu.com.cn/blog/dumplings/)

~~俺切的第一道黑题，写个题解纪念一下~~
# 解决本题需要的前置知识：
## [扩展欧几里得算法](https://oi-wiki.org/math/gcd/)、[乘法逆元](https://oi-wiki.org/math/inverse/)、[扩展中国剩余定理](https://oi-wiki.org/math/crt/)、[排列组合](https://oi-wiki.org/math/combination/)、[卢卡斯定理](https://oi-wiki.org/math/lucas/)
以上链接均来自[OIWIKI](https://oi-wiki.org/)，~~当然我也有写博客~~

# 分析题干
1. For a start，此题很显然是与组合数学有关的

2. What's more，我们注意到题目中存在"Impossible"这种情况

3. Last but not least，本题的答案需要被取模

# 思考

## 1. 从条件2想到，当不能提供所有人想要的礼物时，输出"Impossible"
所以这是一个很简单的问题，求出$sum=\sum^m_{i=1}w_i$并与$n$比较

当你尝试用这个方法骗分时，你可以骗到$5pts$
## 2.从条件1联想到组合数
很容易得到第$i$个人收到礼物的方案数$\large case_i= C_{n-\sum_{k=0}^{i-1}w_i}^{w_i}$

而根据乘法原理有$ans=\prod_{i=1}^mcase_i$

## 3.从条件1+3想到卢卡斯定理

每一次求组合数的复杂度都是O(n!)，不能承受啊，而且还要每步取模……这个时候就要请出卢卡斯了

卢卡斯有两个，一个适用于模数是质数，一个是通用的

这里的$p\leqslant10^9$，而且没有特别指出是质数，必须使用扩展卢卡斯

# 代码
总的来说这道题还是很模板的，~~请慢抄，记得ctrl+r~~

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long

int p,n,m,sum,w[10],ans=1;

int exgcd(int a,int b,int &x,int &y)
{
	if(b==0)
	{
		x=1,y=0;
		return a;
	}
	int temp=exgcd(b,a%b,x,y);
	int t=x;x=y;y=t-a/b*y;
	return temp;
}

int inv(int x,int p)
{
	int y,z;
	int d=exgcd(x,p,y,z);
	return d==1?(p+y%p)%p:-1;
}

int ksm(int a,int b,int mod)
{
	int ans=1;
	while(b)
	{
		if(b&1)
			ans=ans*a%mod;
		a=a*a%mod;
		b>>=1;
	}
	return ans;
}

int Mul(int n,int pi,int pk)
{
	if(!n)
		return 1;
	int ans=1;
	if(n/pk)
	{
		for(int i=2;i<=pk;++i)
			if(i%pi)
				ans=ans*i%pk;
		ans=ksm(ans,n/pk,pk);
	}
	for(int i=2;i<=n%pk;++i)
		if(i%pi)
			ans=ans*i%pk;
	return ans*Mul(n/pi,pi,pk)%pk;
}

int C(int n,int m,int p,int pi,int pk)
{
	if(m>n)
		return 0;
	int a=Mul(n,pi,pk),b=Mul(m,pi,pk),c=Mul(n-m,pi,pk);
	int k=0,ans;
	for(int i=n;i;i/=pi)
		k+=i/pi;
	for(int i=m;i;i/=pi)
		k-=i/pi;
	for(int i=n-m;i;i/=pi)
		k-=i/pi;
	ans=a*inv(b,pk)%pk*inv(c,pk)%pk*ksm(pi,k,pk)%pk;
	ans=ans*(p/pk)%p*inv(p/pk,pk)%p;
	return ans;
}

int Lucas(int n,int m,int p)
{
	int x=p,ans=0,t=sqrt(p);
	for(int i=2;i<=t;++i)
	{
		if(x%i==0)
		{
			int pk=1;
			while(x%i==0)
				pk*=i,x/=i;
			ans=(ans+C(n,m,p,i,pk))%p;
		}
	}
	if(x>1)
		ans=(ans+C(n,m,p,x,x))%p;
	return ans;
}

signed main(void)
{
	//freopen("debug.txt","r",stdin);
	scanf("%lld",&p);
	scanf("%lld %lld",&n,&m);
	for(int i=1;i<=m;++i)
	{
		scanf("%lld",&w[i]);
		sum+=w[i];
	}
	if(sum>n)
	{
		printf("Impossible");
		return 0;
	}
	int N=n;
	for(int i=1;i<=m;++i)
	{
		ans=(ans*Lucas(N-w[i-1],w[i],p))%p;
		N-=w[i-1];
	}
	printf("%lld",ans);
	return 0;
}
```

---

## 作者：VenusM1nT (赞：0)

扩展卢卡斯。

这题相当简单啊……唯一的难度就是在 $\texttt{ExLucas}$ 上了吧……

我们需要将 $\text{sum}$ 个礼物分给 $n$ 个人，每个人需要拿的礼物数为 $a_i$，由于每个礼物不同，要求方案数，容易想到组合数学。

我们考虑一道小学奥数题：$7$ 个人中选 $3$ 个拍照，方案数是 $7\times 6\times 5$，而它的具体意义是：考虑第一个位置能选谁，方案数是 $7$，再考虑第二个位置，由于第一个位置已经放了一个人，所以方案数是 $6$，同理，第三个位置方案数为 $5$，然后我们再使用乘法原理将它们合并。同理，我们对这道题使用相同的思想进行拆解，考虑第一个人选礼物的方案数，是 $n$ 个里选 $a_1$ 个，即 $\binom{n}{a_1}$，再考虑第二个，此时我们还剩下 $n-a_1$ 个礼物，选 $a_2$ 个，方案数为 $\binom{n-a_1}{a_2}$，以此类推，第三个的方案数为 $\binom{n-a_1-a_2}{a_3}$。至此，我们已经得出了此题的做法。

令

$$\text{sum}_i=\sum_{j=1}^{i}a_i$$

则答案为

$$\text{ans}=\prod_{i=1}^{m}\binom{n-\text{sum}_ {i-1}}{a_i}\ \text{mod}\ p$$

使用 $\texttt{ExLucas}$ 即可解出。

```cpp
#include<bits/stdc++.h>
#define MAXN 15
#define reg register
#define inl inline
#define int long long
using namespace std;
template <typename T> inl void Read(reg T &x)
{
	x=0;
	reg int fu=1;
	reg char ch=getchar();
	for(;!isdigit(ch);ch=getchar()) if(ch=='-') fu=-1;
	for(;isdigit(ch);ch=getchar()) x=(x<<3)+(x<<1)+(ch-48);
	x*=fu;
}
void ExGcd(reg int a,reg int b,reg int &x,reg int &y)
{
	if(!b)
	{
		x=1;
		y=0;
		return;
	}
	ExGcd(b,a%b,x,y);
	reg int t=x;
	x=y;
	y=t-a/b*y;
}
int Gcd(reg int x,reg int y)
{
	return !y?x:Gcd(y,x%y);
}
inl int Inv(reg int a,reg int b)
{
	reg int x,y;
	ExGcd(a,b,x,y);
	return (x%b+b)%b;
}
inl int Pow(reg int x,reg int y,reg int p)
{
	reg int res=1;
	for(;y;y>>=1,x=x*x%p) if(y&1) res=res*x%p;
	return res;
}
inl int Crt(reg int x,reg int y,reg int p)
{
	return Inv(y/p,p)*(y/p)*x;
}
int Fac(reg int x,reg int a,reg int p)
{
	if(!x) return 1;
	reg int res=1;
	for(reg int i=1;i<=p;i++) if(i%a) res=res*i%p;
	res=Pow(res,x/p,p);
	for(reg int i=1;i<=x%p;i++) if(i%a) res=res*i%p;
	return res*Fac(x/a,a,p)%p;
}
inl int C(reg int n,reg int m,reg int a,reg int p)
{
	reg int x=Fac(n,a,p),y=Fac(m,a,p),z=Fac(n-m,a,p),sum=0;
	for(reg int i=n;i>=1;i/=a) sum+=i/a;
	for(reg int i=m;i>=1;i/=a) sum-=i/a;
	for(reg int i=n-m;i>=1;i/=a) sum-=i/a;
	return x*Pow(a,sum,p)%p*Inv(y,p)%p*Inv(z,p)%p;
}
inl int ExLucas(reg int n,reg int m,reg int p)
{
	if(n<m) return 0;
	reg int t=p,res=0;
	for(reg int i=2;i*i<=p;i++)
	{
		reg int x=1;
		while(!(t%i))
		{
			x*=i;
			t/=i;
		}
		res=(res+Crt(C(n,m,i,x),p,x))%p;
	}
	if(t>1) res=(res+Crt(C(n,m,t,t),p,t))%p;
	return res%p;
}
int n,m,p,a[MAXN],sum[MAXN],ans=1;
signed main()
{
	reg int sm=0;
	Read(p);
	Read(n);
	Read(m);
	for(reg int i=1;i<=m;i++)
	{
		Read(a[i]);
		sm+=a[i];
		sum[i]=sum[i-1]+a[i];
	}
	if(sm>n) return puts("Impossible"),0;
	for(reg int i=1;i<=m;i++) ans=ans*ExLucas(n-sum[i-1],a[i],p)%p;
	printf("%lld\n",ans);
	return 0;
}
```

---

## 作者：Biscuit46 (赞：0)

## 传送门
[BZOJ](https://www.lydsy.com/JudgeOnline/problem.php?id=2142)  

[洛谷](https://www.luogu.org/problemnew/show/P2183)




## Solution
大家在写本题之前需要先了解[exLucas(当然和Lucas没有任何关系啊!)](http://pmycqacf.ml/index.php/archives/lucas-exlucas.html)
考虑一下方案数怎么算,不就是直接组合数一段乱搞就可以了?
$C_n^{w_1}*C_{n-w_1}^{w_2}*C_{n-w_1-w_2}^{w_3}*...*C_{n-w_1-w_2-...-w_{m-1}}^{w_m}$
然后就是exLucas裸题了.
```cpp
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<math.h>
#include<algorithm>
#include<queue>
#include<set>
#include<map>
#include<iostream>
using namespace std;
#define ll long long
#define re register
#define file(a) freopen(a".in","r",stdin);freopen(a".out","w",stdout)
inline int gi(){
	int f=1,sum=0;char ch=getchar();
	while(ch>'9' || ch<'0'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0' && ch<='9'){sum=(sum<<3)+(sum<<1)+ch-'0';ch=getchar();}
	return f*sum;
}
ll num,number[50010],r[50010],prime[50010];
ll qpow(ll a,ll b,ll mod){
	ll ret=1;
	while(b){
		if(b&1)ret=(ret*a)%mod;
		b>>=1;a=(a*a)%mod;
	}
	return ret;
}
ll exgcd(ll a,ll b,ll&x,ll&y){
	if(!b){
		x=1;y=0;
		return a;
	}
	ll d=exgcd(b,a%b,y,x);y-=a/b*x;
	return d;
}
ll inv(ll a,ll b){
	ll x,y;
	ll d=exgcd(a,b,x,y);
	return (x+b)%b;
}
ll crt(){
	ll M=1,ret=0;
	for(int i=1;i<=num;i++)M*=number[i];
	for(int i=1;i<=num;i++){
		ll m=M/number[i];
		ret=(ret+m*inv(m,number[i])*r[i])%M;
	}
	return ret;
}
ll multi(ll n,ll pi,ll pk){
	if(!n)return 1;
	ll ans=1;
	for(ll i=2;i<=pk;i++)if(i%pi)ans=ans*i%pk;
	ans=qpow(ans,n/pk,pk);
	for(ll i=2;i<=n%pk;i++)if(i%pi)ans=ans*i%pk;
	return ans*multi(n/pi,pi,pk)%pk;
}
ll exlucas(ll n,ll m,ll pi,ll pk){
	if(m>n)return 0;
	ll a=multi(n,pi,pk),b=multi(m,pi,pk),c=multi(n-m,pi,pk);
	ll k=0;
	for(ll i=n;i;i/=pi)k+=i/pi;
	for(ll i=m;i;i/=pi)k-=i/pi;
	for(ll i=n-m;i;i/=pi)k-=i/pi;
	return a*inv(b,pk)%pk*inv(c,pk)%pk*qpow(pi,k,pk)%pk;
}
ll exall(ll n,ll m,ll p){
	for(int i=1;i<=num;i++)r[i]=exlucas(n,m,prime[i],number[i]);
	return crt();
}
void fz(ll n){
	num=0;
	for(ll i=2;i*i<=n;i++){
		if(n%i==0){
			ll pk=1;
			while(n%i==0)pk*=i,n/=i;
			++num;
			number[num]=pk;
			prime[num]=i;
		}
	}
	if(n>1){++num;number[num]=n;prime[num]=n;}
}
ll n,m,p,w[10],sum;
signed main(){
   	p=gi();
	n=gi();m=gi();
	for(int i=1;i<=m;i++){
		w[i]=gi();sum+=w[i];	
	}
	if(sum>n)return puts("Impossible"),0;
	fz(p);
	ll ans=1;
	for(int i=1;i<=m;i++){
		n-=w[i-1];
		ans=(ans*exall(n,w[i],p))%p;
	}
	printf("%lld\n",ans);
	return 0;
}
```

---


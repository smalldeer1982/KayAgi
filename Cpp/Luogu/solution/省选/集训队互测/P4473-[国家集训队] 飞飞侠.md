# [国家集训队] 飞飞侠

## 题目背景

来源：国家集训队 2011 何朴藩

## 题目描述

飞飞国是一个传说中的国度，国家的居民叫做飞飞侠。飞飞国是一个 $N\times M$ 的矩形方阵，每个格子代表一个街区。

然而飞飞国是没有交通工具的。飞飞侠完全靠地面的弹射装置来移动。  

每个街区都装有弹射装置。使用弹射装置是需要支付一定费用的。而且每个弹射装置都有自己的弹射能力。  

我们设第 $i$ 行第 $j$ 列的弹射装置有 $A_{i,j}$ 的费用和 $B_{i,j}$ 的弹射能力。并规定有相邻边的格子间距离是 $1$。那么，任何飞飞侠都只需要在 $(i,j)$ 支付 $A_{i,j}$ 的费用就可以任意选择弹到距离不超过 $B_{i,j}$ 的位置了。如下图  
![https://cdn.luogu.com.cn/upload/pic/17919.png](https://cdn.luogu.com.cn/upload/pic/17919.png)  
（从红色街区交费以后可以跳到周围的任意蓝色街区。）  

现在的问题很简单。有三个飞飞侠，分别叫做 $X, Y, Z$。现在它们决定聚在一起玩，于是想往其中一人的位置集合。告诉你 $3$ 个飞飞侠的坐标，求往哪里集合大家需要花的费用总和最低。（费用相同时优先 $X$，次优先 $Y$）

## 说明/提示

对于 $20\%$ 的数据，$N, M\leq 10$，$B_{i,j}\leq 20$。 

对于 $40\%$ 的数据，$N, M \leq 100$，$B_{i,j}\leq 20$。

对于 $100\%$ 的数据，$1\leq N, M\leq 150$，$0\leq B_{i, j}\leq 10^9$，$0\leq A_{i, j}\leq 1000$。  

## 样例 #1

### 输入

```
4 4
0 0 0 0
1 2 2 0
0 2 2 1
0 0 0 0
5 5 5 5
5 5 5 5
5 5 5 5
5 5 5 5
2 1 3 4 2 2```

### 输出

```
Z
15```

# 题解

## 作者：zcysky (赞：23)

首先最直接的做法是把所有可行的点直接连边，求一个最短路。

我们发现每一个点的连边是一段二维的区间，总共有 $O(n^2)$ 个点，所以总共会有 $O(n^4)$ 的边，不可接受。

我们考虑如何优化：

### 优化连边

首先最套路的办法，我们发现我们是一个点向一个区间连边。网络流的知识告诉我们，点向区间的连边可以使用线段树进行优化，于是这样就可以过了。
所以我们可以每一行建一个线段树，行内优化连边。

这样做的复杂度，点数是 $O(n^2)$ 的，边数原本是 $O(n^4)$ 的，使用线段树优化后降为$O(n^3logn)$ ,使用dijkstra算法求最短路，复杂度：

$O(n^3lognlog(n^3logn))$

用人话说，叫做 $O(能过)$
 
### 拆点

这个做法是目前网上最常见的做法。我们定义一个状态 $dp[i][j][k]$ 表示到达点 $(i,j)$ ，剩余的能量是 $k$ ，每走一格需要消耗1点能量，到达一个点相当于补充了 $a[i][j]$ 点能量。

所以一个点向外只有五种转移，分别是上下左右和不动。用这个东西跑最短路就可以了。

考虑到 $a[i][j]$ 还是很小的，所以这么做还是可以跑过去的。不过在bzoj上要跑25s左右。

### 并查集优化

这个做法是一个比较玄的科技，在此之前我还真的没有见过……

这也应该是本题目前的最优做法。

首先看一个弱化版的题：http://acm.hdu.edu.cn/showproblem.php?pid=5361

我们发现这个题是本题的一维情况，先来解决这个一维的问题。

考虑到一个点的连边是 $[L_i,R_i]$ 内的所有点。我们从一个端点开始跑最短路，那么如果一个点被二次进入（相当于“回头”），这个点必然不会被更新，因为相当于我们绕了几步又绕回来了，我们如果能想一个办法跳过这些点，就可以获得一个很优越的复杂度。

当年多校考场上很多选手是维护了一个set，以此判断当前点是否被更新。然而有一个更优美的做法是并查集：我们把已经更新的点放进一个集合内，根节点指向最右边节点的下一个点。这样当我们二次进入这个节点时，可以 $O(1)$ 地跳过当前所有节点。（因为第一次遍历完这个已更新集合的最后一个点时，这个并查集相当于进行了一次路径压缩，同时不会有新的节点加入，因此可以认为接下来的访问的复杂度都是 $O(1)$）

那么我们推广到这个题，沿用线段树的办法，我们把每一列建一个并查集，然后维护这一列哪些点已经被访问过。

然而如果直接加上并查集的话，我们忽略了一个重要条件：**已经更新过的点不能被更新第二次，这是本算法正确的充要条件。**

考虑我们从起点出发，找到一个点跳过去，这一个区域内的所有点都是等价的，因此会盲目的跳，这一个区域内的点（下面称作某一点的子节点）他们自己的子节点和这一区域内别的点的子节点是会相交的，这一片相交的区域，如果我们使用传统的最短路算法就会被多次更新，因为第一次进入这些点是没有决策的。

那么我们考虑更改边权，我们把跳到的点的 $a[i][j]$ 也算进边权，这样就是正确的了。

证明考虑数学归纳：

从起点出发，跳到一个 $a[i][j]$ 最小的点，到他的路径必然是最优的。

从该节点出发，跳到该节点的子节点也必然是最优的。

如果跳到了一个访问过的节点，那么当前的跳法必然是在之前最优选择完了之后的次优决策转移过来的，因此必然不会被更新。

所以这样做保证了更新过的点不会被更新第二次，就可以使用并查集优化了。

提供并查集优化的代码：
```cpp
#include<bits/stdc++.h>
#define lson (o<<1)
#define rson (o<<1|1)
#define fi first
#define sc second
#define dbg(x) cout<<#x<<" = "<<(x)<<endl;
typedef long long ll;
typedef unsigned int uint;
typedef unsigned long long ull;
using namespace std;
const double pi=acos(-1);
const double eps=1e-6;
inline int lowbit(int x){return x&(-x);}
inline int read(){
    int f=1,x=0;char ch;
    do{ch=getchar();if(ch=='-')f=-1;}while(ch<'0'||ch>'9');
    do{x=x*10+ch-'0';ch=getchar();}while(ch>='0'&&ch<='9');
    return f*x;
}
template<typename T> inline T max(T x,T y,T z){return max(max(x,y),z);}
template<typename T> inline T min(T x,T y,T z){return min(min(x,y),z);}
template<typename T> inline T sqr(T x){return x*x;}
template<typename T> inline void checkmax(T &x,T y){x=max(x,y);}
template<typename T> inline void checkmin(T &x,T y){x=min(x,y);}
template<typename T> inline void read(T &x){
x=0;T f=1;char ch;do{ch=getchar();if(ch=='-')f=-1;}while(ch<'0'||ch>'9');
do x=x*10+ch-'0',ch=getchar();while(ch<='9'&&ch>='0');x*=f;
}
template<typename A,typename B,typename C> inline A fpow(A x,B p,C yql){
    A ans=1;
    for(;p;p>>=1,x=1LL*x*x%yql)if(p&1)ans=1LL*x*ans%yql;
    return ans;
}
struct FastIO{
    static const int S=1310720;
    int wpos;char wbuf[S];
    FastIO():wpos(0) {}
    inline int xchar(){
        static char buf[S];
        static int len=0,pos=0;
        if(pos==len)pos=0,len=fread(buf,1,S,stdin);
        if(pos==len)return -1;
        return buf[pos++];
    }
    inline int read(){
        int c=xchar(),x=0;
        while(c<=32&&~c)c=xchar();
        if(c==-1)return -1;
        for(;'0'<=c&&c<='9';c=xchar())x=x*10+c-'0';
        return x;
    }
}io;
#define read io.read
const int N=160;
int dis[3][N][N],fa[N][N],a[N][N],b[N][N],vis[N][N],n,m;
inline int find(int *fa,int x){return fa[x]?fa[x]=find(fa,fa[x]):x;}
struct Node{
	int d,x,y;
};
inline bool operator <(Node a,Node b){return a.d>b.d;}
inline Node make_Node(int d,int x,int y){
	Node cur;cur.d=d;cur.x=x;cur.y=y;return cur;
}
priority_queue<Node> Q;
const int inf=1e9+7;
inline void dijkstra(int dis[N][N],Node s){
	for(int i=1;i<=n;i++)for(int j=1;j<=m;j++)dis[i][j]=inf;
	dis[s.x][s.y]=0;
	memset(fa,0,sizeof(fa));memset(vis,0,sizeof(vis));
	while(!Q.empty())Q.pop();
	Q.push(make_Node(a[s.x][s.y],s.x,s.y));
	fa[s.x][s.y]=s.y+1;
	while(!Q.empty()){
		Node u=Q.top();Q.pop();
		int x=u.x,y=u.y;
		if(vis[x][y])continue;
		vis[x][y]=1;
		int lx=max(1,x-b[x][y]),rx=min(n,x+b[x][y]);
		for(int i=lx;i<=rx;i++){
			int len=b[x][y]-abs(i-x);
			int up=max(1,y-len),dw=min(m,y+len);
			for(int j=find(fa[i],up);j<=dw;j=find(fa[i],j)){
				if(dis[i][j]>dis[x][y]+a[x][y]){
					dis[i][j]=dis[x][y]+a[x][y];
					Q.push(make_Node(dis[i][j]+a[i][j],i,j));
				}
				fa[i][j]=j+1;
			}
		}
	}
	
}
Node st[10];
int main(){
	n=read();m=read();
	for(int i=1;i<=n;i++)for(int j=1;j<=m;j++)b[i][j]=read();
	for(int i=1;i<=n;i++)for(int j=1;j<=m;j++)a[i][j]=read();
	for(int i=0;i<3;i++)st[i].x=read(),st[i].y=read();
	for(int i=0;i<3;i++)dijkstra(dis[i],st[i]);
	int mn=inf,mnpos=-1;
	for(int i=0;i<3;i++){
		int cur=0;
		for(int j=0;j<3;j++)cur+=dis[j][st[i].x][st[i].y];
		if(cur<mn)mn=cur,mnpos=i;
	}
	if(mnpos==-1)return puts("NO"),0;
	if(mnpos==0)puts("X");
	if(mnpos==1)puts("Y");
	if(mnpos==2)puts("Z");
	printf("%d\n",mn);
}
```

---

## 作者：panyf (赞：12)

$O(n^2\log n)$ 解法！

首先要知道最短路的堆存边优化，不会的可以看[常见优化建图技巧](https://www.luogu.com.cn/blog/221955/chang-jian-you-hua-jian-tu-ji-qiao)。

然后最短路部分复杂度就是 $O(n^2\log n)$ 了。

现在只需要支持找到一个斜着的正方形中所有未被删除的点，然后将它们全部删除。

暴力枚举是 $O(n^4)$ 的。

考虑用并查集实现路径压缩，对每一行开一个并查集，删掉点 $(i,j)$ 就向 $(i,j+1)$ 合并，这样 $getfather(i,j)$ 就是 $(i,j)$ 后面第一个没被删的点。

并查集部分复杂度 $O(n^2\log n)$。瓶颈是每次查询时需要枚举每一行，复杂度 $O(n^3)$。

能不能做到更优？

考虑用数据结构优化避免枚举。

斜着的正方形不好处理，可以将坐标系旋转 $45$ 度，查询范围就是和坐标轴平行的正方形。本质上是曼哈顿距离转切比雪夫距离。

然后就是 [P5471 [NOI2019] 弹跳](https://www.luogu.com.cn/problem/P5471) 了，直接树套 set 就 $O(n^2\log^2n)$ 了。

能不能再做到更优？

结合两种做法的优点，用线段树套并查集。

具体做法是对线段树上每个结点建一个并查集，对于区间 $l,r$ 对应的线段树结点，如果 $(l,j),(l+1,j)...(r,j)$ 都被删了，则 $j$ 向 $j+1$ 合并（这里的字母都表示旋转坐标系以后的坐标）。

因为每次查询到的点都会直接删掉，所以线段树部分复杂度就是 $n^2$ 次单点查询的复杂度，也就是 $O(n^2\log n)$。

线段树结点数即并查集个数不超过 $4n$，所以并查集部分复杂度也是 $O(n^2\log n)$。

再算上最短路 dij 的复杂度，所有部分都是 $O(n^2\log n)$，总复杂度就是 $O(n^2\log n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=309;
int a[N][N],b[N][N],f[N*4][N],px[3],py[3],pw[N][N],d[N][N],o,u,v,w,x,y;
vector<pair<int,int>>s;
struct P{int x,y,w;bool operator<(P a)const{return w>a.w;}};
priority_queue<P>q;
int gf(int x,int y){return f[x][y]==y?y:f[x][y]=gf(x,f[x][y]);}
bool c[N][N],e[N][N];
void bd(int k,int l,int r){
	if(l==r){
		for(int i=1;i<=o;++i)f[k][i]=i+e[l][i];
		return;
	}
	int m=l+r>>1,i=1;
	for(bd(k*2,l,m),bd(k*2+1,m+1,r);i<=o;++i)f[k][i]=min(gf(k*2,i),gf(k*2+1,i));
}
void qry(int k,int l,int r){//查询正方形内包含的点
	if(gf(k,x)>y)return;
	if(l==r){
		for(int i=x;i=gf(k,i),i<=y;f[k][i]=i+1,++i)d[l][i]=w,q.push({l,i,w+a[l][i]}),s.push_back({l,i});
		return;
	}
	int m=l+r>>1;
	if(u<=m)qry(k*2,l,m);
	if(m<v)qry(k*2+1,m+1,r);
}
void del(int k,int l,int r){//更新非叶结点的并查集
	if(l==r)return;
	int m=l+r>>1;
	u>m?del(k*2+1,m+1,r):del(k*2,l,m),f[k][v]=min(gf(k*2,v),gf(k*2+1,v));
}
void dij(int sx,int sy){
	int i,j;
	while(q.size())q.pop(); 
	memset(d,9,sizeof d),memcpy(e,c,sizeof c),e[sx][sy]=1,d[sx][sy]=0,q.push({sx,sy,a[sx][sy]}),bd(1,1,o);
	while(q.size()&&(d[px[0]][py[0]]>1e8||d[px[1]][py[1]]>1e8||d[px[2]][py[2]]>1e8)){
		i=q.top().x,j=q.top().y,w=q.top().w,q.pop(),s={};
		u=max(1,i-b[i][j]),v=min(o-1,i+b[i][j]),x=max(1,j-b[i][j]),y=min(o-1,j+b[i][j]),qry(1,1,o);
		for(auto z:s)tie(u,v)=z,del(1,1,o);
	}
}
int main(){
	int n,m,i,j,k,l,u;
	scanf("%d%d",&n,&m),o=n+m+1,memset(c,1,sizeof c);
	for(i=1;i<=n;++i)for(j=1;j<=m;++j)scanf("%d",b[i+j]+i-j+m),c[i+j][i-j+m]=0;//曼哈顿距离转切比雪夫距离
	for(i=1;i<=n;++i)for(j=1;j<=m;++j)scanf("%d",a[i+j]+i-j+m);
	for(i=1;i<=o;++i)c[i][o]=0;
	for(i=0;i<3;++i)scanf("%d%d",&j,&k),px[i]=j+k,py[i]=j-k+m;
	for(i=0;i<3;++i)for(dij(px[i],py[i]),j=0;j<3;++j)pw[i][j]=d[px[j]][py[j]];
	for(i=0,j=k=5e7;i<3;++i){
		for(l=u=0;l<3;++l)u+=pw[l][i];
		if(u<j)j=u,k=i;
	}
	if(k>2)puts("NO");else printf("%c\n%d",'X'+k,j);
	return 0;
}
```

---

## 作者：you_xiao (赞：11)

# 实属有毒
作为一个dij党。。。  
永远dij

采用 三次dij 的方法可行，但是问题在于如何存边，

dij的话，需要每个点扩展一个范围内所有边最坏情况（150^4）超过2个亿，空间是吃不消的

于是可以优化一下存边，然并卵。。。

我发现，存边越是工于心计，越是优化到最佳，就越容易在细枝末节的疏忽（爆空间）中MLE到无法挽回。。。

所以

# 我不存边了！教练！

我们考虑放弃存边，

因为边本身就是给我们一个走图的方向，既然我们有了一个可以走的范围，那就不用存边了，

于是考虑对周围一圈的点进行选择
```
int l1=max(1,tx-v[tx][ty]),r1=min(n,tx+v[tx][ty]);//纵向边界
		for(int i=l1;i<=r1;i++){
			int len=v[tx][ty]-abs(tx-i);
			int l2=max(ty-len,1),r2=min(ty+len,m);//横向边界
			for(int j=l2;j<=r2;j++){
				if(dis[po[i][j]]>dis[x]+(ll)cost[tx][ty]){	
					dis[po[i][j]]=dis[x]+(ll)cost[tx][ty];
					if(!b[po[i][j]])que.push(make_pair(-dis[po[i][j]],po[i][j]));
				} 
			}
		}
```
但是时间还是慢。。。

观察发现， 我们只需要X，Y，Z三个点中一点到另外两点，于是，当dij中同时 

标记过（最优）X Y Z的时候，考虑退出dij可以减少时间的使用
```
	if(b[po[xa][xx]]&&b[po[ya][yy]]&&b[po[z][zz]])return; 
```

最后，比较另外两个点到一个点的消费，处理答案输出

你们只看这个对吧。。。

~~dijspfa~~

```
#include<cstdio>
#include<cmath>
#include<cstring>
#include<queue>
#define ll long long
using namespace std;
int n,m,v[200][200],xa,xx,ya,yy,z,zz;
int cost[200][200],po[200][200],tt=0;
ll dis[35550];
bool b[35550];
struct dd{
	int x,y;
}q[25550];
void dij(int xxx){
	memset(dis,0x3f,sizeof(dis));
	memset(b,0,sizeof(b));
	dis[xxx]=0;
	priority_queue< pair<ll ,int> >que;
	que.push(make_pair(0,xxx));
	while(que.size()){
		int x=que.top().second;que.pop();
		if(b[x])continue;
		b[x]=1;tt_++;
		if(!v[q[x].x][q[x].y])continue;
		int tx=q[x].x,ty=q[x].y; 
		int l1=max(1,tx-v[tx][ty]),r1=min(n,tx+v[tx][ty]);
		for(int i=l1;i<=r1;i++){
			int len=v[tx][ty]-abs(tx-i);
			int l2=max(ty-len,1),r2=min(ty+len,m);
			for(int j=l2;j<=r2;j++){
				if(dis[po[i][j]]>dis[x]+(ll)cost[tx][ty]){	
					dis[po[i][j]]=dis[x]+(ll)cost[tx][ty];
					if(!b[po[i][j]])que.push(make_pair(-dis[po[i][j]],po[i][j]));
				} 
			}
		}
		if(b[po[xa][xx]]&&b[po[ya][yy]]&&b[po[z][zz]])return; 
//		if(tt_>=tt)return ;
	}
}
int main(){
	scanf("%d%d",&n,&m);
	int tot=0;
	for(int i=1;i<=n;i++){
		for(register int j=1;j<=m;j++){
			scanf("%d",&v[i][j]);
			po[i][j]=++tot;
			q[tot]=(dd){i,j};
		}
	}
	for(int i=1;i<=n;i++){
		for(register int j=1;j<=m;j++){
			scanf("%d",&cost[i][j]);
		}
	}
	scanf("%d%d%d%d%d%d",&xa,&xx,&ya,&yy,&z,&zz);
	dij(po[xa][xx]);				//三遍dij
		ll ans1=dis[po[ya][yy]],ans2=dis[po[z][zz]];
	dij(po[ya][yy]);
		ll ans3=dis[po[xa][xx]],ans4=dis[po[z][zz]];
	dij(po[z][zz]);	
		ll ans5=dis[po[ya][yy]],ans6=dis[po[xa][xx]];
        
	ll p1=ans3+ans6;//x
           p2=ans1+ans5,//y
	   p3=ans2+ans4,//z
	
	if(p1>0x3f3f3f3f&&p2>0x3f3f3f3f&&p3>0x3f3f3f3f){//判断是否有答案
		printf("NO");
		return 0;
	}
	if(p1<=p2&&p1<=p3){
		printf("X\n%lld",p1); 
	}
	else if(p2<=p1&&p2<=p3){
		printf("Y\n%lld",p2);
	}
	else{
		printf("Z\n%lld",p3);
	}
	return 0;
}
```


---

## 作者：wucstdio (赞：8)

一看题目，二话不说，大力线段树。

注意到如果你直接暴力连边的话边数会特别大，所以考虑用线段树。

这样说有点生硬，还是丢一副图吧。

比如，你要将上面的节点向下方的七个节点连边，直接暴力是这样的：

![](https://cdn.luogu.com.cn/upload/pic/32663.png)

这样一次连边的时间复杂度是$O(n)$的。

而经过线段树优化后的连边是这样的：

![](https://cdn.luogu.com.cn/upload/pic/32664.png)

这样一次连边的时间复杂度就变成了$O(\log n)$。虽然图上的边数要比暴力多一些，但下面的边都是线段树的一部分，是$O(n)$的，对总体的边数不会有太大的影响。

现在考虑这一道题。每一个点要连的边是一个连通块：

![](https://cdn.luogu.com.cn/upload/pic/17919.png)

所以就从上到下枚举每一行，在每一行内部用线段树优化。这样点数是$O(nm)$的，边数是$O(n^2m\log m)$的，堆优化跑一个最短路时间复杂度就是$O(n^2m\log m\log(n^2m\log m))$。看起来很恐怖，但是经过实测边数不会超过$20000000$。（当然如果你足够强的话也可以写一个二维线段树）

下面贴出我的代码：

```cpp
#include<cstdio>
#include<cstdlib>
#include<algorithm>
#include<cstring>
#include<queue>
#define ll long long
using namespace std;
struct Edge
{
    int to;
    int next;
    ll len;
}e[20000005];
ll n,m,edgenum,head[1000005],points;//points是线段树的节点数量
ll dis[1000005],a[305][305],b[305][305],ansx,ansy,ansz;
int lson[1000005],rson[1000005],root[305],p[305][305],x,y,z,xx,yy;//lson,rson是线段树的左右儿子的位置，root是每一行的线段树的跟的位置，p是每一个点对应的线段树的节点。
priority_queue<pair<ll,int>,vector<pair<ll,int> >,greater<pair<ll,int> > >q;
void add(int u,int v,ll l)
{
    e[++edgenum].len=l;
    e[edgenum].next=head[u];
    e[edgenum].to=v;
    head[u]=edgenum;
}
int build(int line,int o,int l,int r)在第line行，线段树节点编号是o，管辖的区间是[l,r]
{
    if(l==r)
    {
        p[line][l]=o;//在这里更新p，表示第line行第l列的点对应的节点是o
        return o;
    }
    int mid=l+r>>1;
    lson[o]=build(line,++points,l,mid);
    rson[o]=build(line,++points,mid+1,r);
    add(o,lson[o],0);//从父节点往孩子建边
    add(o,rson[o],0);
    return o;
}
void add2(int o,int l,int r,int node,int from,int to,ll v)//当前的线段树节点是o，管辖区间是[l,r]，要从node向[from,to]的区间连边权为v的边
{
//	printf("Enter:%d %d\n",l,r);
    if(l>=from&&r<=to)return add(node,o,v);
    int mid=l+r>>1;
    if(from<=mid)add2(lson[o],l,mid,node,from,to,v);
    if(to>mid)add2(rson[o],mid+1,r,node,from,to,v);
}
void Dijkstra(int u)//最短路板子
{
    for(int i=1;i<=points;i++)dis[i]=100000000000000000;
    dis[u]=0;
    q.push(make_pair(dis[u],u));
    while(!q.empty())
    {
        int node=q.top().second;
        ll len=q.top().first;
        q.pop();
        if(len!=dis[node])continue;
        for(int hd=head[node];hd;hd=e[hd].next)
        {
            int to=e[hd].to;
            if(dis[to]>dis[node]+e[hd].len)
            {
                dis[to]=dis[node]+e[hd].len;
                q.push(make_pair(dis[to],to));
            }
        }
    }
//	for(int i=1;i<=n;i++)
//	{
//		for(int j=1;j<=m;j++)
//		  printf("%lld ",dis[p[i][j]]);
//		printf("\n");
//	}
//	printf("\n");
}
int main()
{
    scanf("%lld%lld",&n,&m);
    for(int i=1;i<=n;i++)root[i]=build(i,++points,1,m);
    for(int i=1;i<=n;i++)
      for(int j=1;j<=m;j++)
        scanf("%lld",&a[i][j]);
    for(int i=1;i<=n;i++)
    for(int j=1;j<=m;j++)
    {
        scanf("%lld",&b[i][j]);
//		printf("%d %d:\n",i,j);
        for(int k=max(1ll,i-a[i][j]);k<=min(n,i+a[i][j]);k++)
        {
            int rest=a[i][j]-abs(k-i);
//			printf("%d %d %d\n",k,max(1,j-rest),min(m,(ll)j+rest));
            add2(root[k],1,m,p[i][j],max(1,j-rest),min(m,(ll)j+rest),b[i][j]);
        }
    }
    scanf("%d%d",&xx,&yy);
    x=p[xx][yy];
    scanf("%d%d",&xx,&yy);
    y=p[xx][yy];
    scanf("%d%d",&xx,&yy);
    z=p[xx][yy];
//	for(int i=1;i<=points;i++)
//	{
//		printf("%d:",i);
//		for(int hd=head[i];hd;hd=e[hd].next)
//		{
//			printf("(%d %lld)",e[hd].to,e[hd].len);
//		}
//		printf("\n");
//	}
//	for(int i=1;i<=points;i++)
//	{
//		printf("%d:",i);
//		for(int hd=head[i];hd;hd=e[hd].next)
//		{
//			printf("(%d %lld)",e[hd].to,e[hd].len);
//		}
//		printf("\n");
//	}//看看这一堆一堆的注释，就知道我写题的时候有多么崩溃
    Dijkstra(x);
    ll xy=dis[y],xz=dis[z];
    Dijkstra(y);
    ll yx=dis[x],yz=dis[z];
    Dijkstra(z);
    ll zx=dis[x],zy=dis[y];
    ansx=yx+zx;
    ansy=xy+zy;
    ansz=xz+yz;
    if(ansx>100000000000000000&&ansy>100000000000000000&&ansz>100000000000000000)
    {
        printf("NO\n");
        return 0;
    }
    if(ansx<=ansy&&ansx<=ansz)printf("X\n%lld\n",ansx);
    else if(ansy<=ansx&&ansy<=ansz)printf("Y\n%lld\n",ansy);
    else printf("Z\n%lld\n",ansz);
    return 0;
}
```

---

## 作者：π酱 (赞：8)

这道题今天我们考试考到了，第三题，最后只剩半小时了，随便打了个暴搜，最后竟然还没调完QAQ，~~我竟然连暴力都不会打了~~

咳咳，不扯了，下面开始说这道题的做法

由于N和M都不大于150最容易想到的是Floyd（其实是Dijkstra不会写）于是就有了复杂度为O($n^6$)的25分算法

由此，我们可以得到以下的25分做法（考试时25分，洛谷嘛......0分）
代码如下（机房某个大佬写的）：
```
#include<bits/stdc++.h>
#define INF 0x3f3f3f3f
#define rep(i,a,b) for (register int i(a);i<=(b);i++)
using namespace std;
template <typename T>
int read(T &x) {
    x=0;int f=1;char c=getchar();
	for(; !isdigit(c); c=getchar()) if(c=='-') f=-f;
	for(; isdigit(c); c=getchar()) x=x*10+c-'0';
	x*=f;
}
int ans,n,m,b[20][20],a[20][20],c[20][20][20][20],x1,x2,x3,z1,z2,z3;
char t;
int main(){
	freopen("zhber.in","r",stdin);
	freopen("zhber.out","w",stdout);
	read(n),read(m);
	if (n*m>450){
		printf("NO\n");
		return 0;
	}
	memset(b,0,sizeof b);
	memset(a,0,sizeof a);
	memset(c,0,sizeof c);
	rep(i,1,n)rep(j,1,m) read(b[i][j]);
	rep(i,1,n)rep(j,1,m) read(a[i][j]);
	read(x1),read(z1),read(x2),read(z2),read(x3),read(z3);
	rep(i1,1,n)rep(j1,1,m)rep(i2,1,n)rep(j2,1,m)
		if ((i1==i2)&&(j1==j2)) c[i1][j1][i1][j1]=0;
		else{
			int d=abs(i1-i2)+abs(j1-j2);
			if (b[i1][j1]>=d) c[i1][j1][i2][j2]=a[i1][j1];
			else c[i1][j1][i2][j2]=INF;
			if (b[i2][j2]>=d) c[i2][j2][i1][j1]=a[i2][j2];
			else c[i2][j2][i1][j1]=INF;
		}
	rep(i1,1,n)rep(j1,1,m)rep(i2,1,n)rep(j2,1,m)rep(i3,1,n)rep(j3,1,m)
		if (c[i2][j2][i3][j3]>(c[i2][j2][i1][j1]+c[i1][j1][i3][j3])) c[i2][j2][i3][j3]=c[i2][j2][i1][j1]+c[i1][j1][i3][j3];
	ans=INF;
	if (ans>c[x1][z1][x2][z2]+c[x3][z3][x2][z2]) ans=c[x1][z1][x2][z2]+c[x3][z3][x2][z2],t='X';
	if (ans>c[x2][z2][x1][z1]+c[x3][z3][x1][z1]) ans=c[x2][z2][x1][z1]+c[x3][z3][x1][z1],t='Y';
	if (ans>c[x1][z1][x3][z3]+c[x2][z2][x3][z3]) ans=c[x1][z1][x3][z3]+c[x2][z2][x3][z3],t='Z';
	if (ans<INF) printf("%c\n%d\n",t,ans);
	else printf("NO\n");
	return 0;
}
```
~~emmmmmm，其实我就是凑字数~~

看一下没什么不好2333，下面有好东西，Be patient~

好了，言归正传。

首先，我们注意到这是一个最短路问题，那么自然而然就想到了Dijkstra算法~~（不要管SPFA,她已经死了）~~。但是本题和纯的单元最短路径略有不同，需要转化一下。

那么，最容易想到的是在每个点和它可以到达的点之间加一条边，然而，这样一来，边总数的最大值是$150^4$$*2=1012500000

自然，这是存不下的(洛谷上空间给了512MB我们考试才给128MB),所以不建立边，直接把在某个点弹射范围内的点扫一遍，然后全部压到队列里去，这样就可以写出这样的代码（复杂度：O($(n*m)^2$log(n$*$m))）：
```
#include<bits/stdc++.h>
#define INF 0x3f3f3f3f
#define REP(i,a,b) for (register int i(a);i<=(b);i++)
using namespace std;
int d,Da,Ans,n,m,Dist[160][160],x[5],y[5],p[5][5],a[160][160],b[160][160];
struct Node {
	int x,y,q;
	Node(int xx,int yy,int qq) {
		x=xx;
		y=yy;
		q=qq;
	}
};
bool operator < (Node a,Node b) {
	return a.q>b.q;
}
template <typename T>
int Read(T &x) {
	x=0;
	int f=1;
	char c=getchar();
	while(c!='-'&&c>'9'&&c<'0')
		c=getchar();
	for(; !isdigit(c); c=getchar())
		if(c=='-')
			f=-f;
	for(; isdigit(c); c=getchar())
		x=x*10+c-'0';
	x*=f;
	if(c=='\n')
		return 1;
	else
		return 0;
}
void Write(long long x) {
	if(x<0) {
		putchar('-');
		x=-x;
	}
	if(x>9) {
		Write((x-x%10)/10);
	}
	putchar(x%10+'0');
}
inline void Dijkstra(int k) {
	REP(i,1,n) {
		REP(j,1,m) {
			Dist[i][j]=INF;
		}
	}
	priority_queue<Node> Q;
	Q.push(Node(x[k],y[k],0));
	Dist[x[k]][y[k]]=0;
	while(!Q.empty()) {
		Node X=Q.top();
		Q.pop();
		if(Dist[X.x][X.y]!=X.q) {
			continue;
		}
		int Len=b[X.x][X.y],v=Dist[X.x][X.y]+a[X.x][X.y];
		REP(i,max(1,X.x-Len),min(n,X.x+Len)) {
			int Tmp=Len-abs(X.x-i);
			REP(j,max(1,X.y-Tmp),min(m,X.y+Tmp)) {
				if(Dist[i][j]>v) {
					Dist[i][j]=v;
					Q.push(Node(i,j,Dist[i][j]));
				}
			}
		}
	}
	REP(i,1,3) {
		p[k][i]=Dist[x[i]][y[i]];
	}
}
int main() {
	Read(n);
	Read(m);
	REP(i,1,n) {
		REP(j,1,m) {
			Read(b[i][j]);
		}
	}
	REP(i,1,n) {
		REP(j,1,m) {
			Read(a[i][j]);
		}
	}
	REP(i,1,3) {
		Read(x[i]);
		Read(y[i]);
	}
	REP(i,1,3) {
		Dijkstra(i);
	}
	int Da=0,Ans=INF;
	REP(i,1,3) {
		d=0;
		d=p[1][i]+p[2][i]+p[3][i];
		if(d<Ans) {
			Da=i;
			Ans=d;
		}
	}
	if(Ans==INF) {
		puts("NO");
	} else {
		switch(Da) {
			case 0: {
				puts("NO");
				break;
			}
			case 1: {
				puts("X");
				Write(Ans);
				break;
			}
			case 2: {
				puts("Y");
				Write(Ans);
				break;
			}
			case 3: {
				puts("Z");
				Write(Ans);
				break;
			}
		}
	}
	return 0;
}
```
这个代码在洛谷上可以AC,但考试时只有60分（因为洛谷时限时5000ms，我们学校的是1000ms）QAQ

所以还要优化，于是有人写出了线段树优化Dijkstra（复杂度：我不会算啊QAQ,哪个大佬教教我）

~~代码我懒得写了~~看一下下面大佬的题解吧

当然，还有我们机房的一个神仙写出了二维线段树（复杂度我同样不会算QAQ，但是似乎比一般线段树快不少呢）
(代码来自[Centaurus99](https://www.luogu.org/space/show?uid=12686)巨佬%%%%)
```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
using namespace std;
inline int read(){
	int x=0,f=1;char ch;
	do{ch=getchar();if(ch=='-')f=-1;}while(ch<'0'||ch>'9');
	do{x=x*10+ch-'0';ch=getchar();}while(ch>='0'&&ch<='9');
	return x*f;
}
const int N=160,INF=0x3f3f3f3f;
int n,m,a[N][N],b[N][N],tag[N][N];
struct node{
	int v,x;
};
inline bool operator<(const node&t1,const node&t2){return t1.v<t2.v||(t1.v==t2.v&&t1.x>t2.x);}
inline void inc(node&x,node&v){x=(v<x?v:x);}
inline void inc(int&x,int&v){x=(v<x?v:x);}
struct DATA{
	node mn;
	int addv;
};
struct SGT{
	DATA T[N<<2];
	inline void create(int o,int l,int r){
		T[o].mn.v=INF,T[o].addv=INF;
		if (l==r){
			T[o].mn.x=l;
			return;
		}
		int mid=(l+r)>>1;
		create(o<<1,l,mid),create(o<<1|1,mid+1,r);
		pushup(o);
	}
	inline void pushup(int o){T[o].mn=min(T[o<<1].mn,T[o<<1|1].mn);}
	inline void pushdown(int o){
		if (T[o].addv!=INF){
			if (T[o<<1].mn.x) inc(T[o<<1].mn.v,T[o].addv),inc(T[o<<1].addv,T[o].addv);
			if (T[o<<1|1].mn.x) inc(T[o<<1|1].mn.v,T[o].addv),inc(T[o<<1|1].addv,T[o].addv);
			T[o].addv=INF;
		}
	}
	inline void qadd(int o,int l,int r,int x,int y,int v){
		if (T[o].mn.x==0) return;
		if (x<=l&&r<=y){
			inc(T[o].mn.v,v),inc(T[o].addv,v);
			return;
		}
		pushdown(o);
		int mid=(l+r)>>1;
		if (y<=mid) qadd(o<<1,l,mid,x,y,v);
		else if (x>mid) qadd(o<<1|1,mid+1,r,x,y,v);
		else qadd(o<<1,l,mid,x,y,v),qadd(o<<1|1,mid+1,r,x,y,v);
		pushup(o);
	}
	inline void qset(int o,int l,int r,int x,int v){
		if (l==r){
			T[o].mn.v=v;
			if (v==INF) T[o].mn.x=0;
			return;
		}
		pushdown(o);
		int mid=(l+r)>>1;
		if (x<=mid) qset(o<<1,l,mid,x,v);
		else qset(o<<1|1,mid+1,r,x,v);
		pushup(o);
	}
}T[N];
struct PLA{
	int x,y;
}S[4];
int G[4][4];
inline void update(int x,int y,int v){
	int lim=min(n,x+b[x][y]);
	for (int i=max(1,x-b[x][y]);i<=lim;++i){
		int l=max(1,y-b[x][y]+abs(i-x)),r=min(m,y+b[x][y]-abs(i-x));
		T[i].qadd(1,1,m,l,r,v+a[x][y]);
	}
}
void dij(int s){
	int t1,t2;
	if (s==1) t1=2,t2=3;
	else if (s==2) t1=1,t2=3;
	else t1=1,t2=2;
	for (int i=1;i<=n;++i) T[i].create(1,1,m);
	T[S[s].x].qset(1,1,m,S[s].y,0);
	while (G[s][t1]==-1||G[s][t2]==-1){
		node u;u.v=INF;int ux=0;
		for (int i=1;i<=n;++i){
			node t=T[i].T[1].mn;
			if (t<u) u=t,ux=i;
		}
		if (u.x==0||ux==0) break;
		if (ux==S[t1].x&&u.x==S[t1].y) G[s][t1]=u.v;
		if (ux==S[t2].x&&u.x==S[t2].y) G[s][t2]=u.v;
		T[ux].qset(1,1,m,u.x,INF);
		update(ux,u.x,u.v);
	}
}
int main(){
	n=read(),m=read();
	for (int i=1;i<=n;++i){
		for (int j=1;j<=m;++j) b[i][j]=read();
	}
	for (int i=1;i<=n;++i){
		for (int j=1;j<=m;++j) a[i][j]=read();
	}
	for (int i=1;i<=3;++i) S[i].x=read(),S[i].y=read(),tag[S[i].x][S[i].y]=i;
	memset(G,-1,sizeof(G));
	int tans=INF,tip=0;
	for (int i=1;i<=3;++i) dij(i);
	for (int i=1;i<=3;++i){
		int now=0;
		for (int j=1;j<=3;++j)if(i!=j){
			if (G[j][i]==-1){
				now=INF;
				break;
			}
			now+=G[j][i];
		}
		if (now<tans) tans=now,tip=i;
	}
	if (tip==0) return printf("NO\n"),0;
	else if (tip==1) printf("X\n");
	else if (tip==2) printf("Y\n");
	else printf("Z\n");
	printf("%d\n",tans);
	return 0;
}

```

当然，也有人写分层图Dijkstra的，题解里有人发了，我就不写了~~（其实是懒得写2333）~~

下面重点来了

# 敲黑板~

上面的算法都比较优秀的解决了这道题（尤其是后面2种），但是......

# 还不够快

下面介绍一种Dijkstra+并查集优化的算法，这是我在网上看到的，[原帖](https://blog.csdn.net/u013368721/article/details/52985072)并没有讲解，那我来说一下吧

本题中，每一个点都被扫到很多次，如果当这个点不再被需要更新时跳过这个点，就可以节省很多时间，这个算法就是基于这样一种思想。

这道题中，经过仔（yi）细（dun）观（luan）察（gao）我们可以发现，如果把点压入堆中时，比较$Dist[i]+w[i]$而不是比较$Dist[i]$，就可以保证已经更新过的的点以后不再需要更新。
证明（我这么菜，当然不会证了QAQ,以下证明是机房里[zcysky](https://www.luogu.org/space/show?uid=2978)和[Holyk](https://www.luogu.org/space/show?uid=32180)两位巨佬~~在一个月黑风高的夜晚~~想出来的,在此引用一下，~~希望他们别打我~~）：

假设点 x 已经得到了最短路，证明用该点更新的 y也得到了最短路

反证，假设存在路径 x′→y

使 dis[y] 更小，且在 x 更新 y 之后，那么有 dis[x′]+w[x]<dis[x]+w[x] ，因为 x′ 在 x 之后，有 dis[x′]+w[x′]≥dis[x]+w[x]，两式矛盾，运用数学归纳法，可知上述结论成立，以及起点 s 到每一点的最短路径就是 dis[i]


于是我们可以每一行建立一个并查集来跳过已经松弛过的节点，这样代码效率就会大大提高（复杂度:$O(n*m)*log(n*m)$）

[提交记录](https://www.luogu.org/record/show?rid=12588902)

速度确实快了不少呢

代码如下：
```
#include<bits/stdc++.h>
#define INF 0x3f3f3f3f
#define REP(i,a,b) for (register int i(a);i<=(b);i++)
namespace fast_IO {
    const int IN_LEN=10000000,OUT_LEN=10000000;
    char ibuf[IN_LEN],obuf[OUT_LEN],*ih=ibuf+IN_LEN,*oh=obuf;
    char *lastin=ibuf+IN_LEN;
    const char *lastout=ibuf+OUT_LEN-1;
    inline char getchar_() {
        if(ih==lastin)lastin=ibuf+fread(ibuf,1,IN_LEN,stdin),ih=ibuf;
        return (*ih++);
    } inline void putchar_(const char x) {
        if(ih==lastout)fwrite(obuf,1,oh-obuf,stdout),oh=obuf;
        *oh++=x;
    } inline void flush() {
        fwrite(obuf, 1, oh - obuf, stdout);
    }
}
using namespace fast_IO;
template <typename T>
inline void Read(T&x) {
    char cu=getchar();
    x=0;
    bool fla=0;
    while(!isdigit(cu)) {
        if(cu=='-')fla=1;
        cu=getchar();
    }
    while(isdigit(cu))x=x*10+cu-'0',cu=getchar();
    if(fla)x=-x;
}
template <typename T>
void printe(const T x) {
    if(x>=10)printe(x/10);
    putchar(x%10+'0');
}
template <typename T>
inline void Write(const T x) {
    if(x<0)putchar('-'),printe(-x);
    else printe(x);
}
//玄学的读入优化
using namespace std;
int n,m,Res,Da,x[5],y[5],a[160][160],b[160][160],Top[160][160];//Top是并查集
long long Dist[160][160],Ans[5];//Dist数组存离原点的距离，Ans数组存当到前点会合的最小代价
struct Node {
    long long Dis;
    int x,y;
    Node() {} Node(int x,int y,long long Dis):Dis(Dis),x(x),y(y) {}
};
bool operator <(Node a,Node b) {
    return a.Dis>b.Dis;
}
int T(int Top[],int x) {
    return Top[x]==x ? x:(Top[x]=T(Top,Top[x]));
}//并查集，用来跳过已经松弛过的节点
void Dijkstra(int k) {//Dijkstra查询最短路
    Node X;
    int L,R,Nx,Ny,Len1,Len2;
    REP(i,1,n) {
        REP(j,1,m+1) {
            Dist[i][j]=INF;
            Top[i][j]=j;
        }
    }//初始化
    priority_queue<Node>Q;
    Q.push(Node(x[k],y[k],a[x[k]][y[k]]));
    Top[x[k]][y[k]]=y[k]+1;
    Dist[x[k]][y[k]]=0;//把第一个点压进队列，并把它的下一个设为设为它右边的点
    while(!Q.empty()) { //和正常的Dijkstra一样
        X=Q.top();
        Q.pop();//取出队头
        Len1=b[X.x][X.y];
        Nx=max(1,X.x-Len1);
        Ny=min(n,X.x+Len1);//设置X能弹射的范围
        REP(i,Nx,Ny) {
            Len2=Len1-abs(X.x-i);
            L=max(1,X.y-Len2);
            R=min(m,X.y+Len2);
            for(int j=T(Top[i],L); j<=R; j=T(Top[i],j)) {//并查集跳过已经松弛的点
                Q.push(Node(i,j,X.Dis+a[i][j]));//把可以跳到并且没有被松弛过的点压进队列
                Dist[i][j]=X.Dis;//松弛操作
                Top[i][j]=j+1;//把这个点的下一个设置为它右边的点
                if((Dist[x[1]][y[1]]!=INF)&&(Dist[x[2]][y[2]]!=INF)&&(Dist[x[2]][y[2]]!=INF)){
                	return;//剪枝加速
				}
            }
        }
    }
}
int main() {
    Read(n);
    Read(m);
    REP(i,1,n) {
        REP(j,1,m) {
            Read(b[i][j]);
        }
    }
    REP(i,1,n) {
        REP(j,1,m) {
            Read(a[i][j]);
        }
    }
    REP(i,1,3) {
        Read(x[i]);
        Read(y[i]);
    }
    fill(Ans,Ans+3,0);
    Res=INF;
    REP(i,1,3) {
        Dijkstra(i);
        REP(j,1,3) {
            Ans[j]+=Dist[x[j]][y[j]]; //分别算出到每个点会合的最小代价
        }
    }
    REP(i,1,3) {
        if(Ans[i]<Res) {//打擂台找出最优解
            Res=Ans[i];
            Da=i;
        }
    }
    if(Res==INF) {//按题目要求输出答案
        puts("NO");
    } else {
        switch(Da) {
            case 1: {
                puts("X");
                break;
            }
            case 2: {
                puts("Y");
                break;
            }
            case 3: {
                puts("Z");
                break;
            }
        }
        Write(Res);
    }
    getchar();
    return flush(),0;
}
```



---

## 作者：MikukuOvO (赞：5)

[题目大意](https://www.luogu.org/problemnew/show/P4473)

首先考虑最简单的两种做法：直接按照题目模拟（建一个堆），或者直接暴力连边跑最短路，但是时间复杂度都是n^4，很显然通过不了这道题目

但是我们会惊奇的发现第一种做法的空间占用量极低，于是我们考虑一种常规的优化：记录各个状态。

我们定义f[i][j][k]代表目前停留在(i,j)，在不弹射的条件下还能走k个点需要花费的最小费用

那么我们对于每一个点，只有五种走法：上，下，左，右，不动，也许你会问最后这一种是怎么回事，其实加入这一种状态的目的就是要让每一个点都有被考虑弹射的可能性，并且将最后的答案都汇聚到k=0的状态下，便于我们进行比较。

那么我们跑Dijkstra就行了，正确性比较显然：每一个点都有机会被考虑弹射，到达每一步时一定最优。

时间复杂度：O(n*m*(n+m))

最后附上本题代码：（自动省略头文件）

```cpp
struct node
{
    LL px,py,nowcost,energy;
    bool operator < (const node &a) const
    {
        return nowcost > a.nowcost;
    }
};
LL dtx[5]= {0,1,0,-1,0},dty[5]= {1,0,-1,0,0};
LL n,m;
LL b[maxn+5][maxn+5],cost[maxn+5][maxn+5];
LL x[4],y[4];
LL f[maxn+5][maxn+5][maxn*2+5];
bool vis[maxn+5][maxn+5][maxn*2+5];

void dijkstra(int id)
{
    for (int i = 1; i <= n; i++)
    {
        for (int j = 1; j <= m; j++)
        {
            for (int k = 0; k <= n + m; k++)
            {
                vis[i][j][k] = 0;
                f[i][j][k] = inf;
            }
        }
    }
    priority_queue<node>q;
    node temp; 
    temp.px=x[id],temp.py=y[id],temp.energy=b[x[id]][y[id]],temp.nowcost=cost[x[id]][y[id]];
    q.push(temp);
    vis[x[id]][y[id]][0]=1;
    f[x[id]][y[id]][b[x[id]][y[id]]]=cost[x[id]][y[id]];
    while(!q.empty())
    {
        if(vis[x[1]][y[1]][0]==1&&vis[x[2]][y[2]][0]==1&&vis[x[3]][y[3]][0]==1) return;
        node w=q.top();
        q.pop();
        LL tx=w.px,ty=w.py,k=w.energy;
        if(vis[tx][ty][k]==1) continue;
        vis[tx][ty][k]=1;
        if(k!=0)
        {
            for(int i=0; i<=4; i++)
            {
                LL nxtx=tx+dtx[i],nxty=ty+dty[i];
                if(nxtx>=1&&nxtx<=n&&nxty>=1&&nxty<=m)
                {
                    if(f[nxtx][nxty][k-1]>f[tx][ty][k])
                    {
                        f[nxtx][nxty][k-1]=f[tx][ty][k];
                        node temp;
                        temp.px = nxtx;
                        temp.py = nxty;
                        temp.energy = k - 1;
                        temp.nowcost = f[nxtx][nxty][k - 1];
                        q.push(temp);
                    }
                }
            }
        }
        else
        {
            if(f[tx][ty][0]+cost[tx][ty]<f[tx][ty][b[tx][ty]])
            {
                f[tx][ty][b[tx][ty]]=f[tx][ty][0]+cost[tx][ty];
                node temp;
                temp.px = tx;
                temp.py = ty;
                temp.energy = b[tx][ty];
                temp.nowcost = f[tx][ty][b[tx][ty]];
                q.push(temp);
            }
        }
    }
}
int main()
{
    scanf("%lld%lld",&n,&m);
    for(int i=1; i<=n; i++)
    {
        for(int j=1; j<=m; j++)
        {
            scanf("%lld",&b[i][j]);
            b[i][j] = min(b[i][j],1LL*(max(i - 1,(int)n-i) + max(j - 1,(int)m - j)));
        }
    }
    for(int i=1; i<=n; i++)
    {
        for(int j=1; j<=m; j++)
        {
            scanf("%lld",&cost[i][j]);
        }
    }
    for(int i=1; i<=3; i++) scanf("%lld%lld",&x[i],&y[i]);
    dijkstra(1);
    LL a1 = f[x[2]][y[2]][0],a2 = f[x[3]][y[3]][0];
    dijkstra(2);
    LL b1 = f[x[1]][y[1]][0],b2 = f[x[3]][y[3]][0];
    dijkstra(3);
    LL c1 = f[x[1]][y[1]][0],c2 = f[x[2]][y[2]][0];
    LL ans = inf;
    char s;
    if (b1 + c1 < ans)
    {
        ans = b1 + c1;
        s = 'X';
    }
    if (a1 + c2 < ans)
    {
        ans = a1 + c2;
        s = 'Y';
    }
    if (a2 + b2 < ans)
    {
        ans = a2 + b2;
        s = 'Z';
    }
    if(ans>=inf) printf("NO\n");
    else printf("%c\n%lld\n",s,ans);
    return 0;
}

---

## 作者：Z1qqurat (赞：1)

奇妙的优化建图题。首先可以简单暴力，对于每个点 $(x, y)$ 枚举如果我们花代价 $a_{i, j}$ 可以在 $b_{i, j}$ 步内可以到达的点，暴力连边然后跑三遍 Dijkstra。这样的复杂度是 $O(n ^ 4)$ 的，尽梨了，团不过！

考虑优化。想一想有没有什么办法可以不枚举可到达的点。暴力中的状态 $dis_{i, j}$ 表示起点 $(sx, sy)$ 到点 $(i, j)$ 的最绍花费。其实真正限制一个点能否通过一次跳跃到达另一个点的限制条件就是目前还能走的步数，所以我们利用一个 dp 的思想，设 $dis_{i, j, k}$ 表示走到点 $(i, j)$ 时，还可以不额外花代价地走 $k$ 步，目前需要的最少花费。

接下来我们考虑如何转移。分两种情况：

* $k > 0$：也就是说，还能不花代价地走，此时一共有 $5$ 种走法，上下左右原地不动。所以我们直接向这 $5$ 种方向转移，判定条件是 $dis_{i, j, k} < dis_{next_i, next_j, k - 1}$。
* $k = 0$：没法走，必须花钱，但是花了钱之后还是在目前这个节点的，即 $dis_{i, j, k} < dis_{i, j, b_{i, j}} + a_{i, j}$。

大体是这样，有一些细节处理：

* $dis_{i, j, k}$ 中 $k$ 这一维实际上是 $b_{i, j}$ 范围的，但是 $b_{i, j} \le 10 ^ 9$。我们跑的是最短路，不会走额外的回头路，所以说你一个点真正走的距离不会大于图上两点之间最大距离，这里我们粗糙地取一个 $n + m + 1$ 就可以了。然后数组大小大概是 $150 \times 150 \times 300$ 的，银定了！
* Dijkstra 中向五个方向松弛的时候记得判断 $next_i$ 和 $next_j$ 是否越界了，我绝对不会告诉你我因为这个 RE 调了很久，然后一改就过了。
* 这题是**有向图** ，所以当我跑完一遍以 $X$ 为起点的最短路的时候我只能得到 $X$ 到 $Y$ 和 $Z$ 的最少话费，而不能得出 $Y$ 和 $Z$ 到 $X$ 的距离，从而并不能直接得出以 $X$ 为集合点是的最少总花费。

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <cstring>
#include <vector>
#include <queue>
#define ll long long
using namespace std;
const int N = 160;
const ll inf = 0x3f3f3f3f3f3f3f3fll;
int dx[] = {0, 0, 0, 1, -1};
int dy[] = {0, 1, -1, 0, 0};
int n, m, a[N][N], b[N][N], ax, ay, bx, by, cx, cy;
bool vis[N][N][N * 2];
ll dis[N][N][N * 2], ab = inf, ac = inf, ba = inf, bc = inf, ca = inf, cb = inf;
struct Ritsu{
    int x, y, step;
    ll cost;
    bool operator <(const Ritsu &b) const {
        return cost > b.cost;
    }
};
priority_queue <Ritsu> pq;

void Dijkstra(int sx, int sy) {
    memset(dis, 0x3f, sizeof(dis));
    memset(vis, 0, sizeof(vis));
    while(!pq.empty()) pq.pop();
    dis[sx][sy][b[sx][sy]] = a[sx][sy];
    pq.push((Ritsu){sx, sy, b[sx][sy], a[sx][sy]});
    while(!pq.empty()) {
        int x = pq.top().x, y = pq.top().y, k = pq.top().step; pq.pop();
        if(vis[x][y][k]) continue;
        vis[x][y][k] = 1;
        if(k > 0) {
            for (int i = 0; i < 5; ++i) {
                int nx = x + dx[i], ny = y + dy[i];
                if(nx < 1 || nx > n || ny < 1 || ny > m) continue;
                if(dis[nx][ny][k - 1] > dis[x][y][k]) {
                    dis[nx][ny][k - 1] = dis[x][y][k];
                    pq.push((Ritsu){nx, ny, k - 1, dis[nx][ny][k - 1]});
                }
            }
        }
        else {
            if(dis[x][y][b[x][y]] > dis[x][y][k] + a[x][y]) {
                dis[x][y][b[x][y]] = dis[x][y][k] + a[x][y];
                pq.push((Ritsu){x, y, b[x][y], dis[x][y][b[x][y]]});
            }
        }
    }
    return ;
}

int main() {
    scanf("%d %d", &n, &m);
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= m; ++j) {
            scanf("%d", &b[i][j]);
            b[i][j] = min(b[i][j], n + m + 1);
        }
    }
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= m; ++j) scanf("%d", &a[i][j]);
    }
    scanf("%d %d %d %d %d %d", &ax, &ay, &bx, &by, &cx, &cy);
    Dijkstra(ax, ay);
    ll X = inf, Y = inf, Z = inf;
    for (int i = 0; i <= n + m + 1; ++i) {
        ab = min(ab, dis[bx][by][i]);
        ac = min(ac, dis[cx][cy][i]);
    }
    Dijkstra(bx, by);
    for (int i = 0; i <= n + m + 1; ++i) {
        ba = min(ba, dis[ax][ay][i]);
        bc = min(bc, dis[cx][cy][i]);
    }
    Dijkstra(cx, cy);
    for (int i = 0; i <= n + m + 1; ++i) {
        ca = min(ca, dis[ax][ay][i]);
        cb = min(cb, dis[bx][by][i]);
    }
    X = ba + ca, Y = ab + cb, Z = ac + bc;
    ll ans = min(X, min(Y, Z));
    if(ans >= inf) return puts("NO"), 0;
    if(X == ans) puts("X");
    else if(Y == ans) puts("Y");
    else if(Z == ans) puts("Z");
    printf("%lld\n", ans);
    return 0;
}
```

---

## 作者：Umbrella_Leaf (赞：1)

### 题目大意

> 有一个 $n\times m$ 的矩形方阵。如果你在第 $i$ 行 $j$ 列，则你可以以 $a_{i,j}$ 的代价到达与该格曼哈顿距离不超过 $b_{i,j}$ 的格子。
>
> 现在有三个人，他们想聚在一起。问到哪个人所在的地方能使另外两个人走的距离最小，并求出这个最小值。

> $1\le n,m\le 150,0\le a_{i,j}\le 100,0\le b_{i,j}\le 10^9$。

### 题目分析

首先，我们可以想到直接按题意连边，跑 Dijkstra。

但是在极限数据下，边数是 $O(n^2m^2)$ 的，显然无法通过。

考虑类似 DP 的方式。我们设 $(i,j,k)$ 表示从走到 $(i,j)$，还可以走 $k$ 步。

则在 $(i,j,k)$ 和 $(x,y,k-1)$ 之间连边，边权为 $0$。其中， $(x,y)$ 是 $(i,j)$ 相邻的一个格子或者同个格子。（耗费一步，走或者不走）

然后在 $(i,j,0)$ 和 $(i,j,b_{i,j})$ 之间连边，边权是 $a_{i,j}$。即在这个点支付 $a_{i,j}$ 的代价，走 $b_{i,j}$ 步。

然后跑一遍 Dijkstra 或者 SPFA 就行了。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int dx[]={0,0,-1,1,0},dy[]={-1,1,0,0,0};
int n,m;
int a[155][155],b[155][155];
int ax,ay,bx,by,cx,cy;
int dis[6800005];bool vis[6800005];
queue<int>que;
void SPFA(int S){
	memset(dis,0x3f,sizeof(dis));
	dis[S]=0;
	while(!que.empty())que.pop();
	que.push(S);
	vis[S]=1;
	while(!que.empty()){
		int x=que.front();que.pop();
		vis[x]=0;
		int kk=(x-1)/(n*m),xx=((x-1)%(n*m))/m+1,yy=((x-1)%(n*m))%m+1;
		if(kk>0){
			for(int i=0;i<5;i++){
				int xxx=xx+dx[i],yyy=yy+dy[i];
				if(xxx<1||xxx>n||yyy<1||yyy>m)continue;
				int y=(kk-1)*n*m+(xxx-1)*m+yyy;
				if(dis[y]>dis[x]){
					dis[y]=dis[x];
					if(!vis[y]){
						que.push(y);
						vis[y]=1;
					}
				}
			}
		}else{
			int y=min(n+m,b[xx][yy])*n*m+(xx-1)*m+yy,z=a[xx][yy];
			if(dis[y]>dis[x]+z){
				dis[y]=dis[x]+z;
				if(!vis[y]){
					que.push(y);
					vis[y]=1;
				}
			}
		}
	}
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)for(int j=1;j<=m;j++)scanf("%d",&b[i][j]);
	for(int i=1;i<=n;i++)for(int j=1;j<=m;j++)scanf("%d",&a[i][j]);
	scanf("%d%d%d%d%d%d",&ax,&ay,&bx,&by,&cx,&cy);
	int ans=0,anss=0x3f3f3f3f,disab,disba,disac,disca,disbc,discb;
	SPFA((ax-1)*m+ay);
	disab=dis[(bx-1)*m+by],disac=dis[(cx-1)*m+cy];
//	printf("%d %d\n",disab,disac);
	SPFA((bx-1)*m+by);
	disba=dis[(ax-1)*m+ay],disbc=dis[(cx-1)*m+cy];
//	printf("%d %d\n",disba,disbc);
	SPFA((cx-1)*m+cy);
	disca=dis[(ax-1)*m+ay],discb=dis[(bx-1)*m+by];
//	printf("%d %d\n",disca,discb);
	if(disba+disca<anss)ans=1,anss=disba+disca;
	if(disab+discb<anss)ans=2,anss=disab+discb;
	if(disac+disbc<anss)ans=3,anss=disac+disbc;
	if(!ans)puts("NO");
	else{
		putchar((char)('X'+ans-1));puts("");
		printf("%d\n",anss);
	}
	return 0;
}
```

---

## 作者：阔睡王子 (赞：1)

好像数据过于水让玄学剪枝[肛过去了](https://www.luogu.com.cn/record/41408801)
，时间复杂度还可以接受。但是考试的时候只有50~90分的亚子。还是分享一下，轻喷qwq。

思路就是搞个堆优化bfs来模拟，跑三次最短路。
- 对于每个点记录下当前到达此处时最多还能走多少步，容易发现后面再次访问到这个点的时候你花费比上一次访问高，能走的步数还不比上次大，直接剪掉就行了。
- 同时使用同一个跳台的次数最多只能是一次，再次跳的时候花费肯定不比上次低的，而且跳的范围还一样，就剪掉。
- 当另外两个终点都被访问过的时候，直接退出bfs。

考试的时候想不出分层图，我太弱了。。。但实际上这份代码的用时在随机数据下还是比较优秀的，感性理解吧。

在学校的垃机上被迫吸高原氧。
```
#pragma GCC optimize("Ofast")
#include<algorithm>
#include<cstdio>
#include<queue>
#define int long long
using namespace std;
const int maxn=155;
int n,m,inf=4e18;
int a[maxn][maxn];
int b[maxn][maxn];
int step[maxn][maxn],cost[maxn][maxn];
bool vis[maxn][maxn];
int dis[4][4],d[4];
int X[4],Y[4];
int mx[4]={1,0,-1,0};
int my[4]={0,1,0,-1};
struct node
{
	int x,y;
	int step,cost;
	bool friend operator <(node x,node y)
	{return x.cost>y.cost;}
};
#define Push(x,y,z,w) q.push((node){x,y,z,w})
void bfs(int id)
{
	for(int i=1;i<=n;i++)
	for(int j=1;j<=m;j++)
	step[i][j]=0,cost[i][j]=inf,vis[i][j]=0;
	priority_queue<node>q;
	Push(X[id],Y[id],0,0);
	int x1,x2,y1,y2;//定义终点 
	if(id==1)x1=X[2],y1=Y[2];
	else x1=X[1],y1=Y[1];
	if(id==3)x2=X[2],y2=Y[2];
	else x2=X[3],y2=Y[3];
	while(q.size())
	{
		node tmp=q.top();q.pop();
		int x=tmp.x;
		int y=tmp.y;
		int Step=tmp.step;
		int Cost=tmp.cost;
		if(vis[x][y]&&Step<=step[x][y])continue ;
		//如果当前动能还不如以前,肯定不是最优解 		
		if(a[x][y]>0&&!vis[x][y])
		//如果当前跳台已经被使用过,肯定不是最优解 
		Push(x,y,a[x][y],Cost+b[x][y]);
		
		cost[x][y]=min(cost[x][y],Cost);
		step[x][y]=Step;
		vis[x][y]=1;
		if(vis[x1][y1]&&vis[x2][y2])break ;
		
		if(Step<=0)continue ;
		//step为0就没法搜下去了 
		for(int i=0;i<=3;i++)
		{
			int tx=x+mx[i];
			int ty=y+my[i];
			if(tx<1||ty<1||tx>n||ty>m)continue ;
			Push(tx,ty,Step-1,Cost);
		}
	}
	int cos1=cost[x1][y1],cos2=cost[x2][y2];
	if(id==1)
	dis[1][2]=cos1,dis[1][3]=cos2;
	if(id==2)
	dis[2][1]=cos1,dis[2][3]=cos2;
	if(id==3)
	dis[3][1]=cos1,dis[3][2]=cos2;
}
signed main()
{
	scanf("%lld%lld",&n,&m);
	for(int i=1;i<=n;i++)
	for(int j=1;j<=m;j++)
	scanf("%lld",&a[i][j]);
	for(int i=1;i<=n;i++)
	for(int j=1;j<=m;j++)
	scanf("%lld",&b[i][j]);
	for(int i=1;i<=3;i++)
	scanf("%lld%lld",&X[i],&Y[i]);
	int id=0,ans=inf;
	for(int i=1;i<=3;i++)
	bfs(i);
	if(dis[2][1]==inf||dis[3][1]==inf)d[1]=inf;
	else d[1]=dis[2][1]+dis[3][1];
	if(dis[1][2]==inf||dis[3][2]==inf)d[2]=inf;
	else d[2]=dis[1][2]+dis[3][2];
	if(dis[1][3]==inf||dis[2][3]==inf)d[3]=inf;
	else d[3]=dis[1][3]+dis[2][3];
	for(int i=1;i<=3;i++)
	{
		if(d[i]==inf)continue;
		if(ans>d[i])ans=d[i],id=i;
	}
	if(!id)return printf("NO\n"),0;
	if(id==1)printf("X\n");
	else if(id==2)printf("Y\n");
	else printf("Z\n");
	printf("%lld",ans);
}
```

---


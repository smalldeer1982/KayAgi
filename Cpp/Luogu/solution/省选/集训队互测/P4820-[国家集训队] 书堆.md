# [国家集训队] 书堆

## 题目描述

蚂蚁是勤劳的动物，他们喜欢挑战极限?现在他们迎来了一个难题！蚂蚁居住在图书馆里，图书馆里有大量的书籍。书是形状大小质量都一样的矩形。蚂蚁要把这些书摆在水平桌子的边緣。蚂蚁喜欢整洁的布置，所以蚂蚁规定书本必须水平摆放，宽必须平行于桌緣（如图），而且不允许同一高度摆多本书。

![](https://cdn.luogu.com.cn/upload/pic/30575.png)

蚂蚁想要让书本伸出桌子边缘尽量远，同时不让书因为重力垮下来。它们己经用不知道什么方法测出了书的长度M(如图)。如果总共有N本书，请你帮忙计算如何摆放使得最多水平伸出桌缘多远。你不用考虑蚂蚁用什么方法搭建这堆书。

如果某本书以上的所有书的重心的竖直射影不在这本书上，或者正好落在在这本书的边界上，那么这堆书是不稳定的，会因为重力而垮下来。

考虑以下的假设：

- 不考虑地球自转，重力系数也不因高度改变；
- 书是质量均匀，质地坚硬的理想二维物体；
- 在不会垮的前提下，每本书的位置坐标可以是任意实数。

## 说明/提示

 N <= 10^18,数据保证答案 < 10^6

## 样例 #1

### 输入

```
1 100```

### 输出

```
49```

## 样例 #2

### 输入

```
2 100```

### 输出

```
74```

# 题解

## 作者：s_r_f (赞：9)

这题....  
一道极好的**初中物理+(貌似是高中?)数学题。**   

通过初中物理的学习,我们知道了杠杆平衡。

通过~~打表/手算找规律~~,发现答案 =  (1 / 2 + 1 / 4 + .. 1 / (2n)) * m. 

貌似是调和级数H(n) / 2???  

ok,精度爆炸qwq.

好了，我们~~baidu一下~~,发现有个公式: (ln(n) + 0.5772156649) / 2.  

怎么还是WA？？？ 
  
回顾下题面：

**“如果某本书以上的所有书的重心的竖直射影不在这本书上，或者正好落在在这本书的边界上，那么这堆书是不稳定的，会因为重力而垮下来。”**  

所以。。。 我们的答案不能正好取到,还要减去一个重心的位移。。。

减去一个很小的实数(不影响精度)即可。

代码：

```

#include <bits/stdc++.h>
#define LL long long
#define db double
using namespace std;
inline LL read(){
    LL x = 0,f = 1; char c = getchar();
    while (c != EOF && !isdigit(c)) {if (c == '-') f = -1;c = getchar();}
    while (c != EOF && isdigit(c)) {x = x * 10 + c - '0';c = getchar();}
    return x * f;
}
inline void write(LL x){
    int k = 0;char put[40];
    if (!x) putchar('0');
    if (x < 0) putchar('-'),x = -x;
    while (x)  put[++k] = (x % 10) + '0',x /= 10;
    while (k)  putchar(put[k]),--k;
	putchar('\n');
}

LL n,m,ans;
db f = 0,eps = 1e-6;

int main(){
	n = read(),m = read();
	if (n >= 1e7) f = (log(n) + 0.5772156649 )/ 2;
	else for (int i = 2; i <= n*2; ++i,++i ) f += 1.0 / i;
    ///小数据一定要暴力！上面只是个近似公式!!!!
	ans = m * f - eps;
	write(ans);
    return 0;
}
```

---

## 作者：hjqhs (赞：4)

国集出 PHO 题，，，  
延伸到最长而不倒塌是一个很经典的问题，对应题目中就是：
$$m \times \sum_{i=1}^{n}\frac{1}{2 \times i}$$  
然后时间复杂度和精度就都爆炸了。  
bdfs，然后看到了[这篇文章](https://zhuanlan.zhihu.com/p/415559374)，好学习了一下知道了上面那个式子等于：
$$m \times (\log_{e}{n}+\gamma)$$
其中 $\gamma$ 指欧拉-马斯刻若尼常数。  
但还是无法通过本题，重新观察题面发现：
如果某本书以上的所有书的重心的竖直射影不在这本书上，或者**正好**落在在这本书的边界上，那么这堆书是不稳定的，会因为重力而垮下来。
所以减去一个 eps 即可。

---

## 作者：Mars_Dingdang (赞：4)

好吧一道很好的物理题。话说其他题解好像都没有解释为什么 $L=\dfrac12+\dfrac14+\cdots$。

## 题目大意
![](https://cdn.luogu.com.cn/upload/pic/30575.png)

按照上述方式摆放 $n$ 本书，每本书的长度为 $m$，质量均相等。求使得任意一本书上方所有书的总重力等效作用点在该本书右边界左侧（不含）的最大的 $L$。

## 大体思路
设从下到上书的编号为 $1\sim n$，以水平面为 $x$ 轴，桌面最右端为 $0$ 建立数轴。

设每本书的重心位置为 $x_i$, 长度为 $1$，由质心坐标公式 $x=\dfrac{x_1m_1+x_2m_2+\cdots +x_nm_n}{m_1+m_2+\cdots+m_n}$ 依据边界条件列方程得：(质量相等可以约掉 $m_i$)

$\begin{cases}0=\dfrac{x_1+x_2+\cdots+x_n}n\\x_1+\dfrac12 = \dfrac{x_2+x_3+\cdots+x_n}{n-1}\\\cdots\end{cases}$

解得

$\begin{cases}x_1=\dfrac1{2n}-\dfrac12\\x_2=\dfrac1{2(n-1)}+x_1\\\cdots\\x_n=\dfrac12+x_{n-1}\end{cases}$

而由图可得，$L=x_n+\dfrac12=\dfrac12+\dfrac14+\cdots+\dfrac1{2n}$，即调和级数。

调和级数 $\sum_{i=1}^n \dfrac1i≈\ln n+0.5772156649$，所以当 $n$ 较大时可直接调用。由于本题要求等效重心不得在边界上，可以将求得的值减去一个极小值 $eps$。

## 完整代码
```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
using namespace std;
#define rep(ii,aa,bb) for(re int ii = aa; ii <= bb; ii++)
#define Rep(ii,aa,bb) for(re int ii = aa; ii >= bb; ii--)
typedef long long ll;
typedef unsigned long long ull;
typedef double db;
typedef pair<int, int> PII;
const db eps = 1e-7;
namespace IO_ReadWrite {
	#define re register
	#define gg (p1 == p2 && (p2 = (p1 = _buf) + fread(_buf, 1, 1<<21, stdin), p1 == p2) ? EOF :*p1++)
	char _buf[1<<21], *p1 = _buf, *p2 = _buf;
	template <typename T>
	inline void read(T &x){
		x = 0; re T f=1; re char c = gg;
		while(c > 57 || c < 48){if(c == '-') f = -1;c = gg;}
		while(c >= 48 &&c <= 57){x = (x<<1) + (x<<3) + (c^48);c = gg;}
		x *= f;return;
	}
	inline void ReadChar(char &c){
		c = gg;
		while(!isalpha(c)) c = gg;
	}
	template <typename T>
	inline void write(T x){
		if(x < 0) putchar('-'), x = -x;
		if(x > 9) write(x/10);
		putchar('0' + x % 10);
	}
	template <typename T>
	inline void writeln(T x){write(x); putchar('\n');}
}
using namespace IO_ReadWrite;
ll n, m, ans;
double f;
int main () {
	read(n); read(m);
	if(n > (int)1e7) f = (log(n) + 0.5772156649) / 2.0;//套用公式
	else 
		for(int i = 2; i <= n * 2; i += 2) 
			f += (1.0 / i);//暴力求和
	ans = m * f - eps;//记得乘以书的长度 m
	writeln(ans);
	return 0;
}
```

---

## 作者：封禁用户 (赞：2)

题目传送>>[P4820](https://www.luogu.com.cn/problem/P4820)  
### 题意简述：  
- 如图，在“理想状态”（不计地球自转和重力系数的变化，书质量均匀、质地坚硬）下，$N$ 本长度为 $M$ 相同的书堆在水平桌面上，书在桌面一端尽可能地向外延伸（如果某本书以上的所有书的重心的竖直射影不在这本书上，或者正好落在在这本书的边界上，那么这堆书是不稳定的，会因为重力而垮下来），求这些书可伸出桌缘的最远距离 $L$。  
![](https://cdn.luogu.com.cn/upload/pic/30575.png)  
- $N \le 10^{18}$，$L<10^6$。  

### 题目分析：  
要使这些书能尽可能的伸出桌缘最远，我们可以先对每次上面一本书的重心恰好落在下面一本书的边界上的情况进行计算，虽然此时这些书会倒塌，但是最后要使目的达成，我们只需在此基础上减去一个非常非常小的值即可使这些书能堆叠且伸出桌缘最远。  
我们从上往下推:  
假定每本书长度为 $1$，  
当 $n=1$ 时，$L= \frac{1}{2}$；  
当 $n=2$ 时，$L= \frac{1}{2}+ \frac{1}{4}$；  
当 $n=3$ 时，$L= \frac{1}{2}+ \frac{1}{4}+ \frac{1}{6}$；  
......  
当 $n=N$ 时，$L= \frac{1}{2}+ \frac{1}{4}+ \frac{1}{6}+......+ \frac{1}{2n}$；  
我们可以发现本题答案就是 $\sum_{i=1}^{N}\frac{1}{2i}$。  
**但是**，请注意一下本题数据范围：$N \le 10^{18}$，$L<10^6$，如果直接这样算的话是绝对不能 AC 的，那么我们就来考虑数学。  
上面我们推得公式：$L= \frac{1}{2}+ \frac{1}{4}+ \frac{1}{6}+......+ \frac{1}{2n}$，而数学中有调和级数 $H(x)$（由所有正整数的倒数依次形成的级数），例：$\frac{1}{1}+\frac{1}{2}+\frac{1}{3}+\frac{1}{4}+\frac{1}{5}+\frac{1}{6}+\frac{1}{7}+\frac{1}{8}+\frac{1}{9}+\frac{1}{10}+......$  
我们可以发现本题答案即：$\frac{H(x)}{2}$。而由于调和级数 $H(x)$ 是发散的，所以调和级数 $H(x)$ 并无求和公式，但是当 $n$ 很大时有一个渐进表达式：$\sum_{i=1}^{n}\frac{1}{k}= \ln(n)+\gamma$，其中 $\gamma$ 为欧拉常数，近似值为: $0.57721 56649 01532 86060 65120 90082 40243 10421 59335$。  
所以我们对于 $N$，小值借助 $\sum_{i=1}^{N}\frac{1}{2i}$，大值借助 $\frac{H(x)}{2}$ 即可。  
**额外注意：long long 与最终需减去一个非常非常小的值。**  
### Code:  
```cpp
#include <iostream>
#include <cmath>
using namespace std;
typedef long long ll;   //类型定义long long为ll，避免频繁使用时累手
#define endl '\n'   //宏定义endl换行
ll n, m;   //定义书本数，书的长度
double l = 0.0;   //定义书可伸出桌缘的最远距离
int main()
{
	ios::sync_with_stdio(0);   //关同步流加速cin输入和cout输出
	cin >> n >> m;
	if (n < 1e8)   //小值借助累加求和
	{
		for (ll i = 1; i <= n; i++)
		{
			l += 1.0 / (2 * i);
		}
		cout << (ll)(m * l  - (1e-6)) << endl;   //注意减去一个非常非常小的值与换行
	}
	else   //大值借助调和级数
	{
		cout << (ll)(m * (log(n) + 0.5772156649) / 2 - (1e-6)) << endl;   //注意减去一个非常非常小的值与换行
	}
	return 0;   //结束整个程序
}
```
### 结果（未吸氧）：  
![Jieguo](https://cdn.luogu.com.cn/upload/image_hosting/gm0csfyr.png)  
企鹅的题解到此结束，祝各位 OIers 进步 ++~

---

## 作者：qiyichen12 (赞：1)

# 题解
在 $n \gg 1$ 时 $\sum^n_{i = 1} \frac{1}{i}=\ln(n)+γ$

好像还没有人讲一下他。

鄙人不善严格证明，但其中大概的道理或许能说明白。
在 $a > b \gg 1$ 时 $\sum^a_{i=b}\frac{1}{i} ≈ \int^a_b \frac{1}{x} \, dx$。而 $\frac{1}{x}$ 的原函数为 $\ln(x)$。故 $\int^a_b \frac{1}{x} \, dx = \ln(a)-\ln(b)$。此时 $\sum^a_{i = 1} \frac{1}{i} = \sum^a_{i=b}\frac{1}{i} \,+\sum^{b}_{i = 1} \frac{1}{i} \,+\frac{1}{b} ≈ \ln(a)-\ln(b)+\sum^{b}_{i = 1} \frac{1}{i}-\frac{1}{b}$ 此时在 $b \gg 1$ 时会有一个固定的常数 $γ$，使得 $\sum^{b}_{i = 1} \frac{1}{i} ≈ \int^{b}_1 \frac{1}{x} \, dx \,+γ$。故 $\sum^a_{i = 1} \frac{1}{i} = \int^a_b \frac{1}{x} \, dx\,+\int^b_1 \frac{1}{x} \, dx\,+γ = \int^a_1 \frac{1}{x} \, dx \,+γ= \ln(a)-\ln(1)+γ = \ln(a)+γ$。其中 $γ$ 经计算得出约为 $0.5772156649$。

---

## 作者：fysbb (赞：1)

这题是个模板题。

需要用到调和级数公式：

              1/2+1/4+1/6+...+1/(2*n)=ln(n)+0.5772156649(n极大)
              
```pas
program Project1;
var
   n,m:int64;      //n超过了longint范围
   i:longint;
   k:extended;
begin
  readln(n,m);
  if n>10000 then begin   //n较大时使用公式
  k:=ln(n+1.0)+0.5772156649;
  k:=k/2.0;
  writeln(trunc(m*k-0.000001));
  end
    else begin       //n较小时暴力模拟
      k:=0;
      for i:=1 to n do k:=k+0.5/i;
      writeln(trunc(m*k-0.000001));
    end;
end.

```

---

## 作者：muller (赞：1)

看到srf 巨佬A了这道题%%%%%%% orz

于是写了一发，发现好难啊！！！

%%%%%%%% srf

%%%%%%%% srf

%%%%%%%% srf

进入正题

这是一道物理题，可能需要片刻推理，即可得出结果

答案是

```cpp
 1/2+1/4+1/6+...+1/(2*n)
```

发现是调和级数，直接套公式哦

（有点像phi函数）

然后我们就可以考虑用调和级数极限公式可能有精度问题

不过(log(n) + 0.5772156649) / 2在大范围内还是没有问题的

所以我们暴力时注意long double的转换

于是考虑小数据直接暴力，大数据到套公式....

注意输出的是注意精度...

需要减去一个实数，不影响精度

唉！处处要考虑精度

其他真的没有需要讲的吧，已经够清楚了吧。。。

放上代码
```cpp
// luogu-judger-enable-o2
#include <bits/stdc++.h>
using namespace std;
long long n, m, ans;
double f = 0, eps = 1e-6;
int main() {
	int i;
	scanf("%lld%lld", &n, &m);
	if (n >= 1e7) f = (log(n) + 0.5772156649) / 2;
	else {
		for (i = 2; i <= n * 2; i += 2) f += 1.0 / i;
	}
	ans = m * f - eps;
	printf("%lld\n", ans);
	return 0;
}

```

---

## 作者：aaa1145141919810 (赞：0)

## [题目传送门](https://www.luogu.com.cn/problem/P4820)

题目大意：有 $N$ 个长度为 $M$ 的质量相等且均匀的二维矩形物体（长难句起手），要将它们从一个桌面的一侧堆叠摆放延伸出去，求不大于最大延伸长度的最大整数。

通过一些基础的 ~打表观察~ 物理计算，可以得出答案为 $M\cdot \frac{H(N)}{2}$。

于是某个蒟蒻高兴地写起了码，一发 TLE。于是他认真观察了数据范围：$N \le 10^{18}$。直接计算显然会严重超时。于是在经历一段激烈的 ~百度搜索~ 思考过后，我们发现了这样一个公式：当 $x$ **趋近于无穷大**时，$H(x)=\ln x+0.5772156649$。注意：**这只是一个近似值，不是准确值，在 $N$ 较小时请使用暴力计算**（个人测试 $10^7$ 以内使用暴力计算是比较合适的）。~不~轻松切掉，走人。

## AC 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
using LL = long long;

LL n, m, ans;
double t1;

int main()
{
	scanf("%lld%lld", &n, &m);
	if(n <= 1e7)for(int i = 1; i <= n; i++)t1 += 1.0/(2*i);
	else t1 = (log(n)+0.5772156649)/2;
	
	ans = t1 * m - 1e-6;
	
	printf("%lld\n", ans);
	
	return 0;
}
```

[AC 记录](https://www.luogu.com.cn/record/217139675)。

---

## 作者：封禁用户 (赞：0)

# 题解：P4820 [国家集训队] 书堆
[ **_link_** ](https://www.luogu.com.cn/problem/P4820)
## 题目分析

只有一本书时，这本书的重心落在桌子边缘上，伸出桌面的长度就是  $\frac{1}{2}$。

有两本书时，第一本书的重心就落在第二本书的边缘上，两本书的重心落在桌子边缘上，两本书的重心就是在最下面一本书的右端  $\frac{1}{4}$ 处。那么伸出  $\frac{1}{2} + \frac{1}{4}$。

三本书时，可以再多伸长 3 本书的重心 $\frac{1}{6}$。

继续计算可以发现规律， $i$ 本书的重心就落在最下面一本书的右端 $\frac{1}{2\times i}$ 处。
  
那么我们要求的伸出的总长度就是：  
$$
\sum(\frac{1}{2\times i}) = \sum(1 \div i) \div 2
$$ 

 $\sum(\frac{1}{2\times i})$  就是调和级数求和，如果 $n$ 比较小，我们就直接  $O(n)$  求，因为  $n$  比较小的时候用极限公式求误差会比较大。

 如果 n 很大，我们就用调和级数的极限公式  
 $$
 \sum(1 \div i) (i = 1 \sim n) = \ln(n + 1) + \gamma
 $$ 
 
  $\gamma$  是欧拉常数， $\gamma \approx 0.5772156649015328...$

然后就做完了。

## 代码

```cpp
#include <iostream>
#include <cstdlib>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <algorithm>
 
using namespace std;
 
typedef double LF;
typedef long long LL;
 
#define r 0.5772156649
 
const LF Eps = 1e-10;
 
LL n, m;
 
LF Ans;
 
int main()
{
    scanf("%lld%lld", &n, &m);
    if (n <= 1000000ll)
    {  
        for (int i = 1; i <= n; ++i)
            Ans += 1.0 / (LF)i;
    }
    else Ans = log((LF)(n + 1)) + r;
    Ans /= 2.0; Ans *= (LF)m;
    printf("%d\n", (int)(Ans - Eps));
    return 0;
}
```

### 代码简析

- 如果 $n  \leqslant  1000000$，则直接计算调和级数的部分和：
  
```cpp
       for (int i = 1; i <= n; ++i)
           Ans += 1.0 / (LF)i;
```

- 否则，使用调和级数的近似公式：
```cpp
       Ans = log((LF)(n + 1)) + r;
```
- 计算结果乘以  $m$  并除以 2：

```cpp
     Ans /= 2.0; Ans *= (LF)m;
```
- 输出结果，减去一个很小的常数  $Eps$  以避免浮点数精度问题：

```cpp
     printf("%d\n", (int)(Ans - Eps));
```
[逻辑分析](https://metaso.cn/search/8602219549650096128/interactive?dataId=8602219549759148032&targetType=0)

**完结撒花**

---

## 作者：1234567890sjx (赞：0)

逆天国集 PHO 题，写这种题就是摆。根据公式得到答案为 $m\times\sum\limits_{i=1}^n\frac{1}{2\times i}$。即 $\frac{m}{2}\times\sum\limits_{i=1}^n \frac{1}{i}$。其中后半部分为调和级数，有**近似**公式 $\sum\limits_{i=1}^n \frac{1}{i}=\ln(n)+\gamma$。其中 $\gamma$ 常数可以在 `C++20` 中的 `numbers` 库中找出，也可以理解为 $\gamma\approx0.5772156649$。

但是近似公式究竟也是近似公式，必然还是会有误差的。令误差 $\text{Diff}(x)=|\ln(n)+\gamma-\sum\limits_{i=1}^n\frac{1}{i}|$，容易发现 $n$ 增大的同时，$\text{Diff}(x)$ 的值基本呈减小的趋势。因此猜测设定一个阈值 $\text{lim}$，当 $n>\text{lim}$ 则近似公式和正确答案的误差不超过一个特定的值，令其为 $10^{-p}$。若 $\text{lim}$ 取 $10^8$ 时 $p$ 的值已经远远超过了 $10$，完全能够应付题面中要求的精度。特殊的因为精度问题需要减去一个小常数 $\approx10^{-10}$，就可以通过这个题目了。

---

## 作者：tmpliyijiang (赞：0)

## 分析：
看到题目第一想法：运用我们的初中物理知识手算。

首先考虑质心的竖直射影刚好落在前一本书上的情况。

从最外面的书着手：

最外面的书质心正好在前一本书的边缘上！

最外面两本书质心正好在第三本书的边缘上！

最外面三本书质心正好在第四本书的边缘上！

……

设第 $i$ 本书伸出 $x$，则前 $i-1$ 本书的质心在 $x+m$:
$$i\times m=(x+\frac{1}{2}m)+(i-1)(x+m)$$
$$\therefore x=\frac{m}{2i}$$
$$\therefore \text{n本书最多可以伸出} \sum_{i = 1}^{n} \frac{m}{2i}$$ 
可以发现，这是……

调和级数 $ H_n = \sum_{i = 1}^{n} \frac{1}{i} $ 的 $\frac{m}{2}$ 倍？

OK，精度爆炸。

有什么办法吗？我们~~百度一下~~发现当 $n$ 很大时 $H_n$ 有一个近似表达式：
$$H_n = \sum_{i = 1}^{n} \frac{1}{i}=\ln(n)+\gamma$$ 
其中 $\gamma$ 为[欧拉-马斯克若尼常数](https://baike.baidu.com/item/%E6%AC%A7%E6%8B%89%E5%B8%B8%E6%95%B0/5371177)。
 
近似值为 $0.57721 56649 01532 86060 65120 90082 40243 10421 59335$。


直接算即可。

## 需要注意的地方

1.$n\le10^{18}$，要开 `long long`。

2.表达式仅为近似值，$n$ 较小时需要手算。

3.题目中说 **“如果某本书以上的所有书的重心的竖直射影不在这本书上，或者正好落在在这本书的边界上，那么这堆书是不稳定的，会因为重力而垮下来。”** 因此，结果还需减去 $10^{-6}$，即 $eps$。

## Code:
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,m;
double f;//用来存double类型的结果
int main(){
	cin>>n>>m;
	if(n>1e7){//n较大时用近似公式	
		f=(log(n) + 0.5772156649)*(double)m / 2.0- (1e-6);
	}
	else{//n较小时直接算
		for(register int i=1;i<=n;i++)f+=1.0/(double)i;
		f=f*(double)m/2-(1e-6);
	}
	long long ans=(long long)f;
	cout<<ans<<'\n';
	return 0;
}
```

---

## 作者：Miyamizu_Mitsuha (赞：0)

简单的说，蚂蚁希望找到一种摆放方式，使得所有书堆叠在一起，从底部往上看，每本书的重心位于它上面所有书的边界上，但不是正好在边界上或超出边界。


具体可以通过数学计算得出答案。考虑一个级数 $\sum_{i=1}^{N}\frac{1}{2i}$，其中 $N$ 为书的数量。当 $N$ 较小时，直接累加这个级数得到答案， 但是一旦 $N$ 大一点，直接累加会很慢。可以利用调和级数的性质：$\sum_{i=1}^{n}\frac{1}{k}= \ln(n)+\gamma$，其中 $\gamma$ 为欧拉常数，近似值为 $0.57721 56649 01532 86060 65120 90082 40243 10421 59335$（写了那么多位）。这样，就能得到答案为 $\frac{H(x)}{2}$，其中 $H(x)$ 是调和级数。

最后，当 $N$ 较小时，直接累加 $\sum_{i=1}^{N}\frac{1}{2i}$ 得到答案；当 $N$ 较大时，利用调和级数的性质计算 $\frac{H(x)}{2}$ 作为答案，并稍微减去一个非常小的值（例如 $10^{-6}$），这样所有书不会因为重力而倒塌。

---

## 作者：AstaVenti_ (赞：0)

# $\tt 0x00$ 序

蒟蒻的第 $\bf\color{red}26$ 篇题解。

# $\tt 0x01$ 明

已知有 $n$ 本书，每本书的长度 $M$，计算 $L$，表示水平延伸最远的整数距离。

# $\tt 0x02$ 解

要想让这些书延伸的尽量远，则需要让下面一本书的重心刚好在上面一本书的边缘。

题面上说：

>如果某本书以上的所有书的重心的竖直射影不在这本书上，或者正好落在在这本书的边界上，那么这堆书是不稳定的，会因为重力而垮下来。

所以我们还需要减去一个非常小的数（欧拉常数） $\gamma≈0.5772156649$。

具体如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/jj99kh63.png)

总长度为 $\frac{H(n)}{2}$，其中调和级数 $H(n)$ 的渐进表达式为 $\sum_{i=1}^n \frac{1}{k}=\ln(n)+\gamma$。

注意：
- 看数据范围，记得开 `long long`。
- 最终需减去一个不影响精度的极小值。
# $\tt 0x03$ 文

```cpp
#include <bits/stdc++.h>
using namespace std;
long long n,m,ans;
double f=0,eps=1e-6;
int main(){
	cin>>n>>m;
	if (n >= 1e7)
		f=(log(n)+0.5772156649)/2;
	else for(int i=2;i<=n*2;i+=2)f+=1.0/i;
	ans=m*f-eps;
	cout<<ans;
}
```


---

## 作者：Thunder_S (赞：0)

## Solution

先假定书的重心可以到达书本的边界。

思考一下，对于 $i$ 以上的书本来说，最优情况就是重心落在 $i$ 的最右端。

不妨设桌面最右边为 0，书本自下而上编号 $1\sim n$，重心的 $x$ 坐标为 $g_i$。

那么根据重心位置公式可得

$\begin{cases}0=\frac{\sum\limits_{i=1}^n g_i}{n}\\g_1+\frac{1}{2}=\frac{\sum\limits_{i=2}^n g_i}{n-1}\\ \dots\end{cases}$

解得

$\begin{cases}g_1=\frac{1}{2n}-\frac{1}{2}\\g_2=\frac{1}{2(n-1)}+g_1\\\dots\\g_n=\frac{1}{2}+g_{n-1}\end{cases}$

那么 $ans=m\times (g_n+\frac{1}{2})=m\times (\frac{1}{2}+\frac{1}{4}+\frac{1}{6}+\dots)=m\times \sum\limits_{i=1}^n \frac{1}{2i}$。

感谢 [Mars_Dingdang 大佬](https://www.luogu.com.cn/blog/Mars-LG/solution-p4820)。

这个式子在 $n\le 10^{18}$ 的情况下肯定是没有办法线性求出的。所以回想一下数学上的一些知识。

$\sum\limits_{i=1}^n\frac{1}{i}$ 这个式子称为调和级数，而调和级数有公式：$\gamma=\lim _{n \rightarrow \infty}\left(\sum_{k=1}^{\infty} \frac{1}{k}-\ln n\right)$。$\gamma$ 是欧拉常数，$\gamma\approx0.57721 56649 01532$。当 $n\ge 10^7$ 的时候，误差已经减小到不会影响整数位了，所以可以直接 $\mathcal O(1)$ 得到结果。

此时为了满足题意：不能落在边界上，可以将答案先减去一个较小的数（例如 $10^{-7}$）后再取整。但注意这个数不能太小，也不能太大。

## Code 

```cpp
#include<cmath>
#include<cstdio>
#define gama 0.577215664901
#define eps 1e-7
using namespace std;
long long n,m,ans;
double sum;
int main()
{
    scanf("%lld%lld",&n,&m);
    if (n>=10000000) sum=(log(n)+gama)/2.0;
    else
    {
        for (int i=2;i<=2*n;i+=2)
            sum+=(1.0/i);
    }
    ans=m*sum-eps;
    printf("%lld\n",ans);
    return 0;
}
```

---

## 作者：shiroi (赞：0)



### Description

有 $n$ 本长度为 $m$ 的书摆在水平桌面上，现在需要让书本伸出桌子边缘尽量远，同时不让书因为重力垮下来。求水平延伸最远的整数距离。


### Solution
一道物理题。

观察题目发现最优解为贪心地将最高的书尽量向右放，最高的书的重心在次高的书边缘，以此类推。

由此发现$ans=\frac{m}{2}+\frac{m}{4}+...+\frac{m}{2n}$

答案为小于调和级数前 $n$ 项和乘 $m$ 除以2的最大整数，由于范围原因考虑用近似前缀和公式求。但公式在范围较小时误差相对明显，因此当 $n$ 较小时由于公式误差较大需要写暴力。

实现细节上主要需要注意精度问题。


```cpp
#include <bits/stdc++.h>
using namespace std;

inline long long read()
{
	long long x=0,f=1,c=getchar();
	while(c<48) c=='-'&&(f=-1),c=getchar();
	while(c>47) x=x*10+c-'0',c=getchar();
	return x*f;
}

int main(int argc, char const *argv[])
{
	long long n=read(),m=read(); double s=0;
	if(n<100) for(int i=1; i<=n; i++)
			s+=1.0/i;
	else s=log(n)+1.0/(2*n+exp(-1))+0.5772156649;
	printf("%d",(int)(m*s/2-1e-5));
	return 0;
}
```

---

## 作者：janhous (赞：0)

## 引言
我们发现有很多同学使用了这样一个公式：
当 $n$ 充分大的时候有：

$\sum_{k=1}^{n}\frac{1}{k} \sim \ln n$

但这些题解中并没有给出这个公式的推导过程。那么，我来给出一个严格的推导。

## 预备知识
- 单调有界数列的收敛原理（如果一个数列单调且有界（这说的是 $\exist M, \forall n > 0, |a_n| < M$），那么这个数列一定收敛于一个有穷极限。）
- 函数单调性的导数判据
- $\ln$ 函数的 Taylor 级数展开

## 证明
首先我们构造 $f(x) = (1+\frac{1}{x})^x, g(x)=(1+\frac{1}{x})^{1+x}$。

对这两个函数进行求导，我们有：

$f'(x)=(\ln (1+\frac{1}{x})-\frac{1}{x+1}) \cdot f(x)$

$g'(x)=(\ln (1+\frac{1}{x})-\frac{1}{x}) \cdot g(x)
$

我们对函数 $\ln x$ 在 $x=1$ 点进行 Taylor 展开，便得到了 $\ln (1+x)=\sum_{i=1}^{\infty}{\frac{x^i}{i}}$
于是我们可以得到（当 $x \geq 1$ 时）：

$$\frac{1}{x+1} = \frac{2x-1}{2x^2+x-1} < \frac{2x-1}{2x^2} = \frac{1}{x}-\frac{1}{2x^2} < \ln (1+\frac{1}{x}) < \frac{1}{x}$$

带入 $f'(x)$，$g'(x)$，我们便得到 $f'(x) > 0$，$g'(x) < 0$ 在 $[1,+\infty)$ 恒成立，即 $f(x)$ 在 $[1,+\infty)$ 上单调递增；$g(x)$ 在 $[1,+\infty)$ 上单调递减。

因此，我们有 $f(x), g(x) \leq 4 $ 在 $[1,+\infty)$ 上恒成立。这证明了 $f(x), g(x)$ 于 $ x->+\infty$ 时的有穷极限存在。

依据 $\rm{e}$ 的定义，我们有 $\lim_{x->\infty}f(x) = \rm{e}$ 和 $\lim_{x->\infty}g(x) = \lim_{x->\infty}f(x)\cdot(1+\frac{1}{x}) = \rm{e}\cdot{1}=\rm{1}$。

所以 $(1+\frac{1}{n})^n < \rm{e} < (1+\frac{1}{n})^{n+1}$，同时取对数得到 $n\ln(1+\frac{1}{n}) < 1 < (n+1)\ln(1+\frac{1}{n})$，也就是 $\frac{1}{n+1}<\ln(1+\frac{1}{n})<\frac{1}{n}$。

将 $\frac{1}{n+1}<\ln(1+\frac{1}{n})<\frac{1}{n}$ 从 $1$ 到 $n$ 求和得到 $\sum_{i=1}^{n}\frac{1}{i+1} < \ln(n+1) < \sum_{i=1}^{n}\frac{1}{i}$。

取序列 $S_n = 1 + \frac{1}{2} + \frac{1}{3} + \cdots + \frac{1}{n-1} + \frac{1}{n} - \ln n$，

那么得到 $S_n > \ln (n + 1) - \ln n > 0$ 以及 $S_n - S_{n+1} = \ln (n + 1) - ln (n) - \frac{1}{n+1} = \ln(1+\frac{1}{n}) - \frac{1}{n+1} > 0$。

由单调有界数列的收敛原理，$S_n$ 有极限。这便是欧拉常数 $\gamma = 0.577\cdots$。

---


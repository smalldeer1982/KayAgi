# [集训队作业2013] 城市规划

## 题目描述

刚刚解决完电力网络的问题，阿狸又被领导的任务给难住了。

刚才说过，阿狸的国家有 $n$ 个城市，现在国家需要在某些城市对之间建立一些贸易路线，使得整个国家的任意两个城市都直接或间接的连通。

为了省钱, 每两个城市之间最多只能有一条直接的贸易路径。对于两个建立路线的方案，如果存在一个城市对，在两个方案中是否建立路线不一样，那么这两个方案就是不同的，否则就是相同的。现在你需要求出一共有多少不同的方案。

好了，这就是困扰阿狸的问题。换句话说，你需要求出 $n$ 个点的简单 (无重边无自环) 有标号无向连通图数目。

由于这个数字可能非常大, 你只需要输出方案数对 $1004535809$ ( $479 \times 2 ^{21} + 1$ ) 取模即可。

## 说明/提示

【数据范围】   
对于 $20\%$ 的数据，$n \le 10$    
对于 $40\%$ 的数据，$n \le 1000$     
对于 $60\%$ 的数据，$n \le 30000$    
对于 $80\%$ 的数据，$n \le 60000$     
对于 $100\%$ 的数据，$n \le 130000$   

试题来源：$2013$ 中国国家集训队第二次作业

## 样例 #1

### 输入

```
3```

### 输出

```
4```

## 样例 #2

### 输入

```
4```

### 输出

```
38```

## 样例 #3

### 输入

```
100000```

### 输出

```
829847355
```

# 题解

## 作者：Kinandra (赞：47)

1. 标签：多项式求逆, NTT.
2. 设$f(n)$为点数为$n$的**无向连通图**的数量, $g(n)$为点数为$n$**无向图**, 易得$g(n)=2^{n\choose 2}$
3. 那么有
	$$g(n) = \sum_{i = 1}^{n} {{n - 1} \choose {i - 1}} f(i) g(n - i)$$
    , 可以看成枚举一号节点所在联通块大小, 统计方案数.
4. 将$g(n)=2^{n\choose 2}$带入并将式子变形,
	$$2^{n \choose 2} = \sum_{i = 1}^{n} {{n - 1} \choose {i - 1}} f(i) 2^{{n - i} \choose 2}$$
   $$\frac{2^{n \choose 2}}{(n-1)!} = \sum_{i = 1}^{n} \frac{f(i)}{(i-1)!} \frac{2^{{n - i} \choose 2}}{(n-i)!}
	$$
5. 发现是一个卷积的行式, 定义

	$$F(x) = \sum_{n=1}^{+\infty} \frac{f(n)}{(n-1)!}x^n $$
	$$G(x) = \sum_{n=0}^{+\infty} \frac{2^{n \choose 2}}{n!}x^n $$
	$$H(x) = \sum_{n=1}^{+\infty} \frac{2^{n \choose 2}}{(n-1)!}x^n$$
6. 则
	$$F=H*G^{-1}\pmod{x^{n+1}}$$
    , $H$和$G$都是已知的, 那么对$G$求逆再与$H$卷积就可以求出$F$了.
    
```cpp
#include <iostream>
#include <cstdio>
#define mod 1004535809
using namespace std;

long long inv[200005], fiv[200005];

long long fsp(long long base, long long p) {
    long long rt = 1;
    while (p) {
        if (p & 1) (rt *= base) %= mod;
        (base *= base) %= mod;
        p >>= 1;
    }
    return rt;
}

int rtt[600005];
struct Poly {
    long long x[600005];
    void cpy(Poly &a, int len) {
        for (int i = 0; i < len; ++i) x[i] = a.x[i];
        return ;
    }
    void mem(int len) {
        for (int i = 0; i < len; ++i) x[i] = 0;
        return ;
    }
    void ntt(int w, int b) {
        int len = 1 << w;
        for (int i = 0; i < len; ++i) {
            rtt[i] = rtt[i >> 1] >> 1 | ((i & 1) << (w - 1));
            if (i < rtt[i]) swap(x[i], x[rtt[i]]);
        }
        for (int l = 2; l <= len; l <<= 1) {
            int m = l >> 1;
            long long omega = fsp(3, (mod - 1) / l);
            if (b) omega = fsp(omega, mod - 2);
            for (int i = 0; i < len; i += l) {
                long long tomega = 1;
                for (int j = i; j < i + m; ++j, (tomega *= omega) %= mod) {
                    long long t = tomega * x[j + m] % mod;
                    x[j + m] = (x[j] + mod - t) % mod;
                    x[j] = (x[j] + t) % mod;
                }
            }
        }
        return ;
    }
} g1, g2, f, tmp1, tmp2;

Poly inversion(Poly &a, Poly &b, Poly &c, int n) {
    b.mem(2 * n);
    if (a.x[0] == 1) b.x[0] = 1;
    else b.x[0] = fsp(a.x[0], mod - 2);
    for (int w = 1; (1 << (w - 1)) < n; ++w) {
        int len = 1 << w;
        c.cpy(a, len), c.ntt(w + 1, 0), b.ntt(w + 1, 0);
        for (int i = 0; i < (len << 1); ++i) (b.x[i] *= mod + 2ll - b.x[i] * c.x[i] % mod) %= mod;
        b.ntt(w + 1, 1);
        long long ny = fsp(len << 1, mod - 2);
        for (int i = 0; i < len; ++i) (b.x[i] *= ny) %= mod;
        for (int i = len; i < (len << 1); ++i) b.x[i] = 0;
    }
    return b;
}

int main() {
    int n, w = 0;
    scanf("%d", &n);
    n++;
    fiv[0] = fiv[1] = inv[0] = inv[1] = 1;
    for (int i = 2; i <= n; ++i) {
        inv[i] = mod - (mod / i) * inv[mod % i] % mod;
        fiv[i] = fiv[i - 1] * inv[i] % mod;
    }
    g2.x[0] = 1;
    for (int i = 1; i < n; ++i) {
        long long tmp = fsp(2, 1ll * i * (i - 1) / 2 % (mod - 1));
        g1.x[i] = tmp * fiv[i - 1] % mod, g2.x[i] = tmp * fiv[i] % mod;
    }
    g2 = inversion(g2, tmp1, tmp2, n);
    while ((1 << w) < (n << 1)) w++;
    for (int i = n; i < (1 << w); ++i) g2.x[i] = 0;
    g1.ntt(w, 0), g2.ntt(w, 0);
    for (int i = 0; i <= (1 << w); ++i) f.x[i] = g1.x[i] * g2.x[i] % mod;
    f.ntt(w, 1);
    printf("%lld", fsp(inv[2], w) * f.x[n - 1] % mod * fsp(fiv[n - 2], mod - 2) % mod);
    return 0;
}
```



---

## 作者：w33z8kqrqk8zzzx33 (赞：39)

首先，根据指数公式定理：

如果存在两个 EGF $F(x)$ 与 $G(x)$，满足 $e^{F(x)}=G(x)$，$F(x)$ 是 ${f_i}$ 的 EGF，那么 $G(x)$ 是

$$g_n=\sum_{\pi=\{S_1,S_2,\dots,S_n\}}\prod_{i=1}^n f_{|S_i|}$$

EGF，其中 $\pi$ 是 $[n]$ 的划分。

到了这里就可以直接做完这道题目了，因为如果设 $f_i$ 为 $i$ 节点的连通图，$g_i$ 为 $i$ 节点的任意一个图，有 $e^{F(x)} = G(x)$ 并且 $g_i=2^{\binom{i}{2}}$，所以来取得 $f$ 直接做多项式 $\ln$ 就可以。

主要代码：

```cpp
int fc[524320];
int p1[524320];
int p1l[524320];

signed main() {
    ios_base::sync_with_stdio(false); cin.tie(0);
    int n; cin >> n;
    n++;
    int l = 1; while(l < (n<<1)) l <<= 1;
    poly::init(l);
    fc[0] = 1;
    rep1(i, n) fc[i] = 1ll * fc[i-1] * i % poly::MOD;
    rep(i, n) p1[i] = 1ll * poly::qpow(2, 1ll*i*(i-1)/2) * poly::qpow(fc[i], poly::MOD-2) % poly::MOD;
    poly::ln(p1, n, p1l);
    cout << 1ll * p1l[n-1] * fc[n-1] % poly::MOD << endl;
}
```

---

## 作者：EnofTaiPeople (赞：21)

### Part1 前言

什么？我只会数据结构？不会生成函数怎么办啊！

虽然多项式已经“滚出 NOI”了，但它很有利于理解生成函数，毕竟考试要是正解生成函数只是放暴力卷积过呢？

### Part2 形式及含义

给定数列 $a_i$，它的普通生成函数为 $\sum\limits_{i=0}^\infty a_ix^i$，指数生成函数为 $\sum\limits_{i=0}^\infty\dfrac{a_i}{i!}x^i$。

对于数列 $a_i=1$，它的普通生成函数为 $\sum\limits_{i=0}^\infty x^i=\dfrac1{1+x}$，注意左式只有 $|x|<1$ 才是收敛的，右式称为形式幂级数，只有左式收敛才能与右式对应。

它的指数生成函数为 $\sum\limits_{i=0}^\infty\dfrac{x^i}{i!}=e^x$，这一步可以直接右式泰勒展开得到左式。

### Part3 问题转化

对于这类题，我们可以先想一想能否得到与答案类似的东西。

比如，设 $g_n$ 表示 $n$ 个节点有标号无向图个数，显然有 $g_n=2^{\frac{n(n-1)}2}$。

但这并不是我们想要得到的答案，设 $f_n$ 表示 $n$ 个点有标号无向连通图个数，考虑 $1$ 所在连通块节点为 $k$ 个，有：$g_n=\sum\limits_{k=1}^n\binom{n-1}{k-1}f_kg_{n-k}$，于是我们得出了 $f$ 与 $g$ 的关系。

到了这一步，生成函数的作用就在于构建卷积关系，当然我们需要让函数的项只与次数相关。

将二项式拆开，得到 $\dfrac{g_n}{(n-1)!}=\sum\limits_{k=1}^n\dfrac{f_k}{(k-1)!}\dfrac{g_{n-k}}{(n-k)!}$，这就是一个卷积形式。

设 $F=\sum\dfrac{f_i}{i!},G=\sum\dfrac{g_i}{i!}$，分别是数列 $f_i,g_i$ 的指数生成函数。

那么 $xG'=xF'G,F=\int\dfrac{G'}G=\ln G$，直接使用多项式对数函数即可。

### Part4 另一个角度

上面只是用来发掘指数与计数的联系，其实普通生成函数也可以，甚至不用对数，毕竟对数的实现也是多项式求逆。

事实上，设 $H=\sum\dfrac{g_i}{(i-1)!}x^i,F=\sum\dfrac{f_i}{(i-1)!}x^i,G=\sum\dfrac{g_i}{i!}x^i$。

那么有 $H=FG,F=\dfrac{H}G$，多项式求逆即可。

### Part5 后记

怎么会告一段落，生成函数远不只这些，当然可以放代码：

方法一：
```cpp
int main(){
	ios::sync_with_stdio(false);
	int i,j,k,l,r,x,y;
	cin>>n;
	jc[0]=nv[0]=nv[1]=1;
	for(x=2;x<=n;++x)nv[x]=ll(M-M/x)*nv[M%x]%M;
	for(x=1;x<=n;++x){
		jc[x]=ll(jc[x-1])*x%M;
		nv[x]=ll(nv[x-1])*nv[x]%M;
	}
	for(x=0;x<=n;++x)g[x]=ll(qp(2,ll(x-1)*x/2%(M-1)))*nv[x]%M;
	P.Ln(g,f,18);
	k=ll(f[n])*jc[n]%M;
	printf("%d\n",k);
	return 0;
}
```
方法二：
```cpp
int main(){
	ios::sync_with_stdio(false);
	int i,j,k,l,r,x,y;
	cin>>n;
	jc[0]=nv[0]=nv[1]=1;
	for(x=2;x<=n;++x)nv[x]=ll(M-M/x)*nv[M%x]%M;
	for(x=1;x<=n;++x){
		jc[x]=ll(jc[x-1])*x%M;
		nv[x]=ll(nv[x-1])*nv[x]%M;
	}
	for(x=0;x<=n;++x)g[x]=ll(qp(2,ll(x-1)*x/2%(M-1)))*nv[x]%M;
	P.Inv(g,f,18);
	memset(g,0,4<<19);
	for(x=1;x<=n;++x)g[x]=ll(qp(2,ll(x-1)*x/2%(M-1)))*nv[x-1]%M;
	P.mul(f,g);
	k=ll(f[n])*jc[n-1]%M;
	printf("%d\n",k);
	return 0;
}
```

---

## 作者：wwlw (赞：14)

令 $f_n$ 表示 $n$ 个点的连通无向图个数。

枚举连通块个数，然后递归定义

$$f_n=\sum_{i\geq 0}\frac{1}{i!}\sum_{k_1+\dots+k_i=n-1} \binom{n-1}{k_1,\dots,k_i}\prod_{j=1}^{i} (2^{k_j}-1)f_{k_j}$$

在经过尝试之后，发现单独对 $f_n$ 来递归定义 $\hat F(x)$ 非常不好做，因为每项系数总会多出一个 $2^x-1$。

考虑到这样递归定义必须考虑图的连通性，故而不太好做。转而想到直接计数无向图个数。我们令 $g_n=2^{\binom{n}{2}}$ 表示无向图个数，还是枚举连通块个数，则

$$g_n=\sum_{i\geq 0}\frac{1}{i!}\sum_{k_1+\dots+k_i=n} \binom{n}{k_1,\dots,k_i}\prod_{j=1}^{i} f_{k_j}$$

$$\frac{g_n}{n!}=\sum_{i\geq 0}\frac{1}{i!}\sum_{k_1+\dots+k_i=n} \prod_{j=1}^{i} \frac{f_{k_j}}{k_j!}$$

那么就有

$$\frac{g_n}{n!}=[x^n]\sum_{i\geq 0}\frac{\hat F(x)^i}{i!}=[x^n]e^{\hat F(x)}$$

$$ \hat G(x)=e^{\hat F(x)}$$

所以

$$\hat F(x)=\ln \hat G(x)=\ln\sum_{n\geq 0} \frac{2^{\binom{n}{2}}}{n!} x^n$$

---

## 作者：hwk0518 (赞：14)

#### 我们记$f_i$表示$i$个点的无向连通图个数，$t_i$表示$i$个点的无向图个数，显然$t_i=2^{C(i,2)}$。

#### 根据容斥的套路，枚举$1$号点所在联通块大小，选一些点和$1$号点在同一个联通块，再让剩下点随意构成一个无向图，可以得到：

#### $f_i=t_i-\sum_{j=1 \to i-1}f_j*C(i-1,j-1)*t_{i-j}$

#### 展开组合数，得到：

#### $f_i=t_i-\sum_{j=1 \to i-1}f_j*t_{i-j}*\frac{(i-1)!}{(j-1)!(i-j)!}$

#### 合并同类项，得到：

#### $\frac{f_i}{(i-1)!}=\frac{t_i}{(i-1)!}-\sum_{j=1 \to i-1}\frac{f_j}{(j-1)!}*\frac{t_{i-j}}{(i-j)!}$

#### 于是设$g_i=\frac{f_i}{(i-1)!}$，$h_i=\frac{t_i}{i!}$，得到：

#### $g_i=h_i-\sum_{j=1 \to i-1}g_jh_{i-j}$

#### 剩下的就是[P4721 【模板】分治 FFT](https://www.luogu.org/problemnew/show/P4721)了。

#### 代码：

```

#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<string>
#include<algorithm>
#include<math.h>
#include<time.h>
using namespace std;

const int N=1e6+5;
const int mod=1004535809;
const int sqr=3;
const int sqrinv=334845270;

int n,mx,g[N],inv[N],infac[N],fac[N];
int c[N],x[N],y[N],limit,lg,r[N],h[N];
int NTT_inv[N],scom[N],ss[N];

namespace MATHEMATICS
{
	int add(int x,int y)
	{
		int ret=x+y;
		if(ret>=mod) ret-=mod;
		return ret;
	}
	int mi(int x,int y)
	{
		int ret=x-y;
		if(ret<0) ret+=mod;
		return ret;
	}
	
	void inc(int &x,int y)
	{
		x+=y;
		if(x>=mod) x-=mod;
	}
	void dec(int &x,int y)
	{
		x-=y;
		if(x<0) x+=mod;
	}
	
	int mul(int x,int y)
	{
		return 1LL*x*y%mod;
	}
	int F_p(int x,int y)
	{
		int bas=x,ret=1;
		while(y)
		{
			if(y&1) ret=mul(ret,bas);
			bas=mul(bas,bas);
			y>>=1;
		}
		return ret;
	}
};
using namespace MATHEMATICS;

void prework()
{
	int i;
	fac[0]=1;for(i=1;i<=n;++i) fac[i]=mul(fac[i-1],i);
	inv[1]=1;for(i=2;i<=n;++i) inv[i]=mul(inv[mod%i],mod-mod/i);
	infac[0]=1;for(i=1;i<=n;++i) infac[i]=mul(infac[i-1],inv[i]);
	
	for(i=1;i<=n;++i) c[i]=1LL*i*(i-1)/2%(mod-1);
	for(i=1;i<=n;++i) h[i]=mul(F_p(2,c[i]),infac[i]);
}

int solve_complex(int x,int op)
{
	if(~op) return F_p(sqr,x);
	else return F_p(sqrinv,x);
}
void NTT(int *A,int op)
{
	int i;
	for(i=0;i<limit;++i)
		if(i<r[i])
			swap(A[i],A[r[i]]);
	
	int len,j,k;
	for(len=1;len<limit;len<<=1)
	{
		int wn;
		if(~op)
		{
			if(scom[len]) wn=scom[len];
			else wn=scom[len]=solve_complex((mod-1)/(2*len),1);
		}
		else
		{
			if(ss[len]) wn=ss[len];
			else wn=ss[len]=solve_complex((mod-1)/(2*len),-1);
		}

		for(j=0;j<limit;j+=len<<1)
		{
			int w=1;
			for(k=0;k<len;++k,w=mul(w,wn))
			{
				int x=A[j+k];
				int y=mul(w,A[j+k+len]);
				A[j+k]=add(x,y);
				A[j+k+len]=mi(x,y);
			}
		}
	}
}

void calc(int L,int mid,int mm,int R)
{
	limit=1,lg=0;int len=R-L,i;
	while(limit<len+len) limit<<=1,++lg;
	for(i=1;i<limit;++i) r[i]=(r[i>>1]>>1)|((i&1)<<(lg-1));
	
	for(i=0;i<=mid-L;++i) x[i]=g[i+L];
	for(i=0;i<R-L;++i) y[i]=h[i+1];
	for(i=mid-L+1;i<limit;++i) x[i]=0;
	for(i=R-L;i<limit;++i) y[i]=0;
	
	NTT(x,1),NTT(y,1);
	for(i=0;i<limit;++i) x[i]=mul(x[i],y[i]);
	NTT(x,-1);
	
	int inv;
	if(NTT_inv[limit]) inv=NTT_inv[limit];
	else NTT_inv[limit]=inv=F_p(limit,mod-2);
	
	for(i=mm;i<=R;++i) dec(g[i],mul(x[i-mm+mid-L],inv));
}

void solve(int l,int r)
{
	if(l==r) return;
	int mid=(l+r)>>1;
	solve(l,mid);
	calc(l,mid,mid+1,r);
	solve(mid+1,r);
}

void work()
{
//	cout<<clock()<<endl;
	mx=1;int i;
	for(i=1;i<=n;++i) g[i]=mul(infac[i-1],F_p(2,c[i]));
	while(mx<=n) mx<<=1;
	solve(0,mx-1);
	printf("%d\n",mul(g[n],fac[n-1]));
}

int main()
{
	scanf("%d",&n);
//	cout<<clock()<<endl;
	prework();work();
//	cout<<clock()<<endl;
	return 0;
}

```

---

## 作者：Illusory_dimes (赞：9)

### 题目描述
求 $n$ 个点无向连通图的个数

$1\leq n \leq 1.3\cdot 10^5$

### 前置芝士
多项式求逆， $n$ 个点的**无向图数量**

### 前言（就一句话）
话说我再看到 Mr_Spade 大佬的题解的时候，我愣了，我为什么我化简了这么久的式子，为什么还这么麻烦，于是，我把它鸽了几天，后来才知道是我太菜了。。（准备打完题解去写 Mr_Spade 的做法）

### solution
设 $g(x)$ 为 $n$ 个点的**无向图数量**，易知为 $2^{\left( \begin{array}{c} n \\ 2\end{array} \right)}$ 

设 $f(x)$ 为 $n$ 个点的**无向联通图数量**（就是题目要求）

就假设在枚举一个点所在的连通块的大小的方案数

于是就有：

$g(n)=\large\sum_{i=1}^{n}$ ${{\small\left( \begin{array}{c} n-1 \\ i-1\end{array} \right)}\cdot f(i)\cdot g(n-i)}$

把组合数拆开，找一下能对应的其他项，就珂以化成这样的：

$\Large\frac{g(n)}{(n-1)!}$ $=$ $\large\sum_{i=1}^{n}$ $\Large\frac{f(i)}{(i-1)!}$ $\cdot$ $\Large\frac{g(n-i)}{(n-i)!}$

于是这就成了一个卷积的行式，稍微操作一下，设这么三个函数：

$F(x)=\large\sum_{n=1}^{\infty}$ $\Large\frac{f(n)}{(n-1)!}$ $\cdot$ $x^n$

$G(x)=\large\sum_{n=1}^{\infty}$ $\Large\frac{g(n)}{(n-1)!}$ $\cdot$ $x^n$

$H(x)=\large\sum_{n=0}^{\infty}$ $\Large\frac{g(n)}{n!}$ $\cdot$ $x^n$

所以可以极度快乐的把式子写成：

$F\ =\ G\ \cdot\ H^{\ -1}$

既然已经知道了 $g(n)$ ，那么 $G$ 和 $H$ 就都成了已知的了，答案也就呼之欲出了。

最后根据定义，把 $F(n)$ 乘上 $(n-1)!$ 就是最后的答案了
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=5e5+10;
typedef ll arr[N];
const int mod=1004535809;
const int inv3=334845270;
int n,inv,lim=1,fre,id[N];
int fac[N],Ifac[N],g2[N];
arr f,g,h,ans,tmp;
inline int inc(ll x,ll y){return x+y>=mod?x+y-mod:x+y;}
inline int dec(ll x,ll y){return x-y<0?x-y+mod:x-y;}
inline int mul(ll x,ll y){return 1ll*x*y%mod;}
inline int read()
{
	int s=0,w=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
	while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
	return s*w;
}
inline int ksm(int a,int b)
{
	int tmp=1;
	while(b)
	{
		if(b&1)tmp=mul(tmp,a);
		b>>=1,a=mul(a,a);
	}
	return tmp;
}
inline void Never_Tell_TLE(ll* NTT,int sign)
{
	for(int i=0;i<=lim;++i)if(i<id[i])
	{
		ll NTt=NTT[i];
		NTT[i]=NTT[id[i]];
		NTT[id[i]]=NTt;
	}
	for(int mid=1;mid<lim;mid<<=1)
	{
		int Unit_root;
		if(sign==1)Unit_root=ksm(3,(mod-1)/(mid<<1));
		else Unit_root=ksm(inv3,(mod-1)/(mid<<1));
		for(int R=mid<<1,r=0;r<lim;r+=R)
		{
			int pw=1;
			for(int l=0;l<mid;++l,pw=(1ll*pw*Unit_root)%mod)
			{
				int butt=NTT[l+r],rfly=(1ll*pw*NTT[l+r+mid])%mod;
				NTT[l+r]=inc(butt,rfly);
				NTT[l+r+mid]=dec(butt,rfly);
			}
		}
	}
	if(sign==-1)
	{
		int inv_lim=ksm(lim,mod-2);
		for(int i=0;i<=lim;++i)NTT[i]=mul(NTT[i],inv_lim);
	}
}
inline void solve(ll* F,ll* G,int nm)
{
	if(nm==1)
	{
		G[0]=ksm(F[0],mod-2);
		return;
	}
	solve(F,G,(nm+1)>>1);
	lim=1,fre=0;
	for(;lim<(nm<<1);lim<<=1)++fre;
	for(int i=0;i<lim;++i)id[i]=(id[i>>1]>>1)|((i&1)<<(fre-1));
	for(int i=0;i<nm;++i)ans[i]=F[i],tmp[i]=G[i];
	for(int i=nm;i<=lim;++i)ans[i]=tmp[i]=0;
	Never_Tell_TLE(ans,1),Never_Tell_TLE(tmp,1);
	for(int i=0;i<lim;++i)G[i]=mul(inc((2ll-mul(ans[i],tmp[i])),mod),tmp[i]);
	Never_Tell_TLE(G,-1);
	for(int i=nm;i<=lim;++i)G[i]=0;
}
inline void MUL(ll* F,ll* G,int nm)
{
	lim=1,fre=0;
	for(;lim<=(nm<<1);lim<<=1)++fre;
	for(int i=0;i<lim;++i)id[i]=(id[i>>1]>>1)|((i&1)<<(fre-1));
	for(int i=0;i<nm;++i)ans[i]=F[i],tmp[i]=G[i];
	for(int i=nm;i<=lim;++i)ans[i]=tmp[i]=0;
	Never_Tell_TLE(ans,1),Never_Tell_TLE(tmp,1);
	for(int i=0;i<lim;++i)G[i]=mul(ans[i],tmp[i]);
	Never_Tell_TLE(G,-1);
	for(int i=nm;i<=lim;++i)G[i]=0;
}
int main()
{
	n=read();
	fac[0]=Ifac[0]=1;
	for(int i=1;i<=n;++i)fac[i]=mul(fac[i-1],i);
	Ifac[n]=ksm(fac[n],mod-2);
	for(int i=n-1;i;--i)Ifac[i]=mul(Ifac[i+1],i+1);
	++n;
	for(int i=0;i<n;++i)g2[i]=ksm(2,1ll*i*(i-1)/2%(mod-1));
	for(int i=0;i<n;++i)f[i]=mul(g2[i],Ifac[i]);
	for(int i=1;i<n;++i)g[i]=mul(g2[i],Ifac[i-1]);
	solve(f,h,n);
	MUL(g,h,n);
	--n;
	printf("%lld",mul(h[n],fac[n-1]));
	return 0;
}
```
只求能帮助到几个人罢。。

---

## 作者：crashed (赞：8)

&emsp;&emsp;[前往博客园](https://www.cnblogs.com/crashed/p/13284500.html)享受更好体验。   
# 题目
&emsp;&emsp;[点这里](https://www.luogu.com.cn/problem/P4841)看题目。   
# 分析
&emsp;&emsp;考虑如下递推：   
&emsp;&emsp;$f_i$：$i$个点的无向有标号**连通**图的个数。   
&emsp;&emsp;$g_i$：$i$个点的无向有标号图的个数。   
&emsp;&emsp;以下给出两种计算方式。   
## 法一   
&emsp;&emsp;不难看出一个式子：   
   
$$g_n=\sum_{i=1}^n\binom{n-1}{i-1}f_ig_{n-i}$$   
   
&emsp;&emsp;这相当于枚举 1 所在的连通块大小，然后构造出这个连通块，剩下的点任意连。   
&emsp;&emsp;然后感觉这个东西非常的 EGF ，就尝试拆一下：   
   
$$\frac{g_n}{(n-1)!}=\sum_{i=1}^n\frac{f_i}{(i-1)!}\cdot\frac{g_{n-i}}{(n-i)!}$$    
    
&emsp;&emsp;由于负数的阶乘是未定义的，我们就认为它是 0 ，那么就可以简化下标：   
   
$$\frac{g_n}{(n-1)!}=\sum_{i=0}^n\frac{f_i}{(i-1)!}\cdot\frac{g_{n-i}}{(n-i)!}$$   
   
&emsp;&emsp;另外，由于任意一个无向有标号图一定是：   
   
$$
\begin{aligned}
&G=(V,E')\\
&V=\{1,2,3,...,n\}\\
&E=\{(u,v)|u,v\in V\}, E'\subseteq E
\end{aligned}
$$   
   
&emsp;&emsp;那么我们可以得到：   
   
$$g_n=2^{\binom{n}{2}}$$   
   
&emsp;&emsp;实际上就是看每条边选不选。   
&emsp;&emsp;带入到式子中可以得到：   
   
$$\frac{2^{\binom n 2}}{(n-1)!}=\sum_{i=0}^n\frac{f_i}{(i-1)!}\cdot \frac{2^{\binom {n - i} 2}}{(n-i)!}$$   
   
&emsp;&emsp;反手写成生成函数：   
   
$$
\begin{aligned}
H(x)&=\sum_{i=1}^{+\infty} \frac{2^{\binom i 2}}{(i-1)!}x^i\\
F(x)&=\sum_{i=1}^{+\infty} \frac{f_i}{(i-1)!}x^i\\
G(x)&=\sum_{i=0}^{+\infty} \frac{2^{\binom i 2}}{i!}x^i
\end{aligned}   
$$   
  
&emsp;&emsp;于是有：   
    
$$
\begin{aligned}
H(x)&=F(x)*G(x)\\
F(x)&=H(x)*G^{-1}(x)
\end{aligned}
$$   
   
&emsp;&emsp;多项式求逆，结束。时间是$O(n\log_2n)$。   
## 法二   
&emsp;&emsp;为了方便，我们先不考虑标号，记：   
    
$$p_i=\frac{f_i}{i!},q_i=\frac{g_i}{i!}$$    
    
&emsp;&emsp;把它写成生成函数的形式：   
    
$$
\begin{aligned}
P(x)&=\sum_{i=0}^{+\infty} p_ix^i\\
Q(x)&=\sum_{i=0}^{+\infty} q_ix^i
\end{aligned}
$$   
   
&emsp;&emsp;然后可以发现：   
    
$$
\begin{aligned}
Q(x)=\sum_{k=0}^{+\infty} \frac{(P(x))^k}{k!}
\end{aligned}
$$ 
    
&emsp;&emsp;其中$k$是在枚举连通块的个数；除以$k!$，是因为$(P(x))^k$使得连通块之间存在顺序，然而这样就算重复了，因此要除去。   
&emsp;&emsp;发现等式右边是经典的$e^x$的展开式，缩回去得到：   
$$Q(x)=e^{P(x)}$$   
&emsp;&emsp;转为$P(x)=\ln Q(x)$计算即可。时间是$O(n\log_2n)$。    
## 题外话    
&emsp;&emsp;两个方法都是正确的，但是结果看起来还不太一样，我们进一步分析一下：   
&emsp;&emsp;可以发现，多项式存在如下的关系：   
$$H(x)=xG'(x),F(x)=xP'(x)$$   
&emsp;&emsp;那么就有：   
$$
\begin{aligned}
F(x)&=\frac{H(x)}{G(x)}\\
x\cdot P'(x)&=x\cdot \frac{G'(x)}{G(x)}\\
P'(x)&=\ln' G(x)\\
P(x)&=\ln G(x)
\end{aligned}
$$   
&emsp;&emsp;所以说两个方法的结果是统一的。~~只不过法一的代码简单一些而已~~   
# 代码
&emsp;&emsp;~~作者太懒了，只有法一的代码~~

```cpp
#include <cmath>
#include <cstdio>

typedef long long LL;

const int mod = 1004535809, phi = mod - 1, g = 3;
const int MAXN = 1e6 + 5;

template<typename _T>
void read( _T &x )
{
	x = 0;char s = getchar();int f = 1;
	while( s > '9' || s < '0' ){if( s == '-' ) f = -1; s = getchar();}
	while( s >= '0' && s <= '9' ){x = ( x << 3 ) + ( x << 1 ) + ( s - '0' ), s = getchar();}
	x *= f;
}

template<typename _T>
void write( _T x )
{
	if( x < 0 ){ putchar( '-' ); x = ( ~ x ) + 1; }
	if( 9 < x ){ write( x / 10 ); }
	putchar( x % 10 + '0' );
}

template<typename _T>
void swapp( _T &x, _T &y )
{
	_T t = x; x = y, y = t;
}

int rev[MAXN], wp[MAXN], wpinv[MAXN];
int Q[MAXN], G[MAXN], H[MAXN];
int fac[MAXN], finv[MAXN];
int N;

int qkpow( int base, int indx )
{
	int ret = 1;
	while( indx )
	{
		if( indx & 1 ) ret = 1ll * ret * base % mod;
		base = 1ll * base * base % mod, indx >>= 1;
	}
	return ret;
}

int inv( const int a ) { return qkpow( a, phi - 1 ); }
int fix( const int a ) { return ( a % mod + mod ) % mod; }

void init( const int len )
{
	int lg2 = log2( len );
	for( int i = 0 ; i < len ; i ++ )
		rev[i] = wp[i] = wpinv[i] = 0;
	for( int i = 0 ; i < len ; i ++ )
		for( int j = 0 ; j < lg2 ; j ++ )
			rev[i] |= ( i >> j & 1 ) << ( lg2 - j - 1 );
	wp[0] = 1, wp[1] = qkpow( g, phi / len );
	wpinv[0] = 1, wpinv[1] = qkpow( g, phi - phi / len );
	for( int i = 2 ; i < len ; i ++ )
		wp[i] = 1ll * wp[i - 1] * wp[1] % mod,
		wpinv[i] = 1ll * wpinv[i - 1] * wpinv[1] % mod;
}

void NTT( int *coe, const int len, const int t )
{
	#define p ( s >> 1 )
	for( int i = 0 ; i < len ; i ++ )
		if( rev[i] < i )
			swapp( coe[i], coe[rev[i]] );
	int w, wo, we;
	for( int s = 2 ; s <= len ; s <<= 1 )
		for( int i = 0 ; i < len ; i += s )
			for( int j = 0 ; j < s >> 1 ; j ++ )
			{
				w = t > 0 ? wp[len / s * j] : wpinv[len / s * j];
				we = coe[i + j], wo = 1ll * coe[i + j + p] * w % mod;
				coe[i + j] = ( we + wo ) % mod, coe[i + j + p] = ( we - wo + mod ) % mod;
			}
	#undef p
	if( t > 0 ) return; int inver = inv( len );
	for( int i = 0 ; i < len ; i ++ ) coe[i] = 1ll * coe[i] * inver % mod;
}

namespace PolyInv
{
	int P[MAXN], F0[MAXN], F[MAXN], B[MAXN];
	
	void PolyInv( const int n )
	{
		if( n == 1 ) { F[0] = inv( P[0] ); return; }
		int p = n + 1 >> 1, len = 1;
		PolyInv( p );
		while( len < n << 1 ) len <<= 1; init( len );
		for( int i = 0 ; i < n ; i ++ ) B[i] = P[i];
		for( int i = 0 ; i < len ; i ++ ) F0[i] = F[i], F[i] = 0;
		NTT( B, len, 1 ), NTT( F0, len, 1 );
		for( int i = 0 ; i < len ; i ++ ) F[i] = 1ll * F0[i] * fix( 2 - 1ll * B[i] * F0[i] % mod ) % mod;
		NTT( F, len, -1 );
		for( int i = n ; i < len ; i ++ ) F[i] = 0;
	}
	
	void PolyInv( int *ret, int *A, const int n )
	{
		for( int i = 0 ; i < n << 2 ; i ++ ) P[i] = F0[i] = F[i] = B[i] = 0;
		for( int i = 0 ; i < n ; i ++ ) P[i] = A[i];
		PolyInv( n );
		for( int i = 0 ; i < n ; i ++ ) ret[i] = F[i];
	}
}

namespace PolyMul
{
	int A[MAXN], B[MAXN];
	
	void PolyMul( int *ret, int *a, const int La, int *b, const int Lb )
	{
		int len = 1;
		while( len < La + Lb ) len <<= 1;
		init( len );
		
		for( int i = 0 ; i < len ; i ++ ) ret[i] = A[i] = B[i] = 0;
		for( int i = 0 ; i < La ; i ++ ) A[i] = a[i];
		for( int i = 0 ; i < Lb ; i ++ ) B[i] = b[i];
		NTT( A, len, 1 ), NTT( B, len, 1 );
		for( int i = 0 ; i < len ; i ++ ) ret[i] = 1ll * A[i] * B[i] % mod;
		NTT( ret, len, -1 );
		for( int i = La + Lb ; i < len ; i ++ ) ret[i] = 0;
	}
}

int main()
{
	read( N );
	if( N == 0 ) return puts( "0" ), 0;
	fac[0] = 1, finv[1] = 1;
	for( int i = 2 ; i <= N ; i ++ ) finv[i] = 1ll * ( mod - mod / i ) * finv[mod % i] % mod;
	finv[0] = 1;
	for( int i = 1 ; i <= N ; i ++ ) fac[i] = 1ll * fac[i - 1] * i % mod, finv[i] = 1ll * finv[i - 1] * finv[i] % mod;
	N ++, G[0] = 1;
	for( int i = 1 ; i < N ; i ++ )
	{
		int tmp = qkpow( 2, 1ll * i * ( i - 1 ) / 2 % phi );
		G[i] = 1ll * tmp * finv[i] % mod, H[i] = 1ll * tmp * finv[i - 1] % mod;
	}
	PolyInv :: PolyInv( G, G, N );
	PolyMul :: PolyMul( Q, G, N, H, N );
	write( 1ll * Q[N - 1] * fac[N - 2] % mod ), putchar( '\n' );
	return 0;
}
```

---

## 作者：Sym_Je (赞：8)

# 题目大意   
给你 $n$ 个点，这 $n$ 个点互相联通 ，问我们所有构成一棵树的方案 ，两个方案不同仅当选的边不同 。   

## $solution$    
首先这道题是一道经典的递推题    
我们设 $f[i]$ 为 $i$ 个点的方案数 。    
我们发现如果我们直接去找肯定是很麻烦的 
老方法，正难则反，我们考虑所有方法，减去不合法的      
$$f[i]=2^{C_{n}^{2}}-\sum_{j=1}^{i-1}C_{i-1}^{j-1}×f[j]×2^{C_{i-j}^{2}}$$   
答案等于 所有方案数 $-$ 枚举 $1$ 与多少个点联通形成大小为 $j $ 的联通快的个数 $×$ 该大小所有合法方案数 $×$ 其他点的自由组合 .   

$$f[i]=2^{C_{n}^{2}}-\sum_{j=1}^{i-1}(\frac{(i-1)!}{(i-j)!(j-1)!})×f[j]×2^{C_{i-j}^{2}}$$   
通分   
$$\frac{f[i]}{(i-1)!}=\frac{2^{C_{n}^{2}}}{(i-1)!}-\sum_{j=1}^{i-1}(\frac{1}{(i-j)!(j-1)!})×f[j]×2^{C_{i-j}^{2}}$$    
移项  
$$\frac{f[i]}{(i-1)!}+\sum_{j=1}^{i-1}(\frac{1}{(i-j)!(j-1)!})×f[j]×2^{C_{i-j}^{2}}=\frac{2^{C_{n}^{2}}}{(i-1)!}$$     
合并左边 只要我们把 $0!$ 设为 $1$ 之后呢，我们就可以把左边合并   

$$\sum_{j=1}^{i}(\frac{1}{(i-j)!(j-1)!})×f[j]×2^{C_{i-j}^{2}}=\frac{2^{C_{n}^{2}}}{(i-1)!}$$    

拆开   

$$\sum_{j=1}^{i}(\frac{2^{C_{i-j}^{2}}}{(i-j)!})×\frac{f[j]}{(j-1)!}=\frac{2^{C_{n}^{2}}}{(i-1)!}$$    
之后   

$$\sum_{i=1}^{n}\sum_{j=1}^{i}(\frac{2^{C_{i-j}^{2}}}{(i-j)!})×\frac{f[j]}{(j-1)!}=\sum_{i=1}^{n}\frac{2^{C_{i}^{2}}}{(i-1)!}$$     
我们设   

$$A=\sum_{i=1}^{n}\frac{f[i]}{(i-1)!}$$    
$$B=\sum_{i=0}^{n}\frac{2^{C_i^2}}{i!}$$   
$$C=\sum_{i=1}^{n}\frac{2^{C_i^2}}{(i-1)!}$$    

之后我们可以发现    
$$C(n)=\sum_{i=0}^{n}A(i)×B(n-i)$$    

想必大家也都发现了，这其实就是卷积   

$$C=A * B$$  
呢么我们的答案是要求 $F[n]$ 的  .  
呢么  
$$A=B^{-1}* C$$   
多项式求逆就好啦 。 
最后 $ans=A(n) × (n-1)!$   

* $code$   

```cpp
#include<bits/stdc++.h>
#define mul(a,b) a*b%mod  
#define add(a,b) (a+b)%mod  
#define dec(a,b) (a-b+mod)%mod
#define ll long long
using namespace std;
const double Pi=acos(-1.0);
const ll maxn=2e6+10;
const ll mod=1004535809;
ll G=3,Gi=334845270;
ll n;
ll poww(ll x,ll k) {
	ll ans=1;
	while(k) {
		if(k&1) ans=ans*x%mod;
		x=x*x%mod;
		k>>=1;
	}return ans;
}
ll a[maxn],b[maxn],c[maxn],Y[maxn],B[maxn],A[maxn],C[maxn];
ll fac[maxn],inv[maxn],r[maxn];
inline void NTT(ll *A,ll type,ll len) 
{
	ll limit=1,l=0;
	while(limit<len) limit<<=1,++l;
	for(ll i=0;i<limit;++i) r[i]=(r[i>>1]>>1)|((i&1)<<(l-1));
	for(ll i=0;i<limit;++i) if(i<r[i]) swap(A[i],A[r[i]]);
	for(ll mid=1;mid<limit;mid<<=1) {
		ll Wn=poww(type==1?G:Gi,(mod-1)/(mid<<1));
		for(ll R=mid<<1,j=0;j<limit;j+=R) {
			ll w=1;
			for(ll k=0;k<mid;++k,w=w*Wn%mod) {
				ll x=A[j+k],y=w*A[j+k+mid]%mod;
				A[j+k]=add(x,y);
				A[j+k+mid]=dec(x,y);
			}
		}
	}
	if(type==-1) {
		for(ll i=0,inv=poww(len,mod-2);i<limit;++i) 
			A[i]=1ll*A[i]*inv%mod;
	}
}

void Inv(ll *a,ll *b,ll len) 
{
	if(len==1) {
		b[0]=poww(a[0],mod-2);
		return ;
	}
	Inv(a,b,len>>1);
	for(ll i=0;i<len;++i) A[i]=a[i],B[i]=b[i];
	NTT(A,1,len<<1);NTT(B,1,len<<1);
	for(ll i=0;i<(len<<1);++i) A[i]=mul(mul(A[i],B[i]),B[i]);
	NTT(A,-1,len<<1);
	for(ll i=0;i<len;++i) b[i]=(1ll*(b[i]<<1)%mod+mod-A[i])%mod;
}
ll m;
int main() 
{
//	cout<<poww(2,4);
	fac[0]=1;
	scanf("%d",&n);m=n+n;
	for(ll i=1;i<=n;++i) fac[i]=fac[i-1]*i%mod;
	inv[n]=poww(fac[n],mod-2);
	for(ll i=n-1;i>=0;i--) inv[i]=inv[i+1]*(i+1)%mod;
	for(ll i=0;i<=n;++i) b[i]=poww(2,(i*(i-1))/2)*inv[i]%mod;
	ll Len;for(Len=1;Len<=n;Len<<=1);
	Inv(b,C,Len);
	//for(int i=1;i<=Len;++i) cout<<C[i]<<" ";
	//cout<<'\n';
	for(ll i=1;i<=n;++i) 
	a[i]=poww(2,(i*(i-1))/2)*inv[i-1]%mod;
	for(Len=1;Len<=m;Len<<=1);
	NTT(C,1,Len);NTT(a,1,Len);
	for(ll i=0;i<Len;++i) a[i]=a[i]*C[i]%mod;
	NTT(a,-1,Len);
	cout<<a[n]*fac[n-1]%mod<<"\n";
	return 0;
}


```
 

.
...


 


---

## 作者：ニヒル (赞：5)

推一波式子    
首先如果不要求联通的话公式很简单，令n个点不要求联通的方案数为$g_n$  
$$g_n=2^{\frac{n*(n-1)}{2}}$$
因为每条边都可以选或不选    
然后假设要求联通的方案数为$f_n$   
可以找出$g_n$与$f$的关系  
$$g_n=\sum_{i=1}^n {n-1\choose i-1} f_ig_{n-i}$$   
相当于枚举第一个点所在的联通块大小为i，然后乘以其它点随便连的方案数，如果不理解请再看一下g和f的定义  
现在我们要求$f_n$所以拆一下式子  
$$g_n=f_n+\sum_{i=1}^{n-1} {n-1\choose i-1} f_ig_{n-i}$$
$$f_n=g_n-\sum_{i=1}^{n-1} {n-1\choose i-1} f_ig_{n-i}$$  
$$f_n=g_n-\sum_{i=1}^{n-1} \frac{(n-1)!}{(i-1)!(n-i)!} f_ig_{n-i}$$
$$f_n=g_n-(n-1)!\sum_{i=1}^{n-1} \frac{f_i}{(i-1)!} \frac{g_{n-i}}{(n-i)!}$$
后面这个式子看着像卷积  
$$\sum_{i=1}^{n-1} \frac{f_i}{(i-1)!} \frac{g_{n-i}}{(n-i)!}$$
令$h_i=\frac{f_i}{(i-1)!}$  $t_i=\frac{g_i}{i!}$代入得
$$(n-1)!h_n=n!t_n-(n-1)!\sum_{i=1}^{n-1} h_i t_{n-i}$$
$$h_n=nt_n-\sum_{i=1}^{n-1} h_i t_{n-i}$$
然后分治FFT就完事了  
顺便一提，这题的原根也是3

代码如下：
```cpp
#include<bits/stdc++.h>
#define mod 1004535809
#define gg 3
using namespace std;

int r[400010];
long long tmp1[400010],tmp2[400010],h[400010],t[400010];
long long fac[400010],inv[400010];

long long kasumi(long long a,long long b)
{
	long long ans=1;
	while(b)
	{
		if(b&1) ans=ans*a%mod;
		a=a*a%mod;
		b>>=1;
	}
	return ans;
}

void NTT(long long *a,int kd,int logn)
{
	int lim=(1<<logn);
	for(int i=0;i<lim;i++)
	{
		r[i]=(r[i>>1]>>1)|((i&1)<<(logn-1));
	}
	for(int i=0;i<lim;i++)
	{
		if(i<r[i]) swap(a[i],a[r[i]]);
	}
	for(int mid=1;mid<lim;mid<<=1)
	{
		long long wn=kasumi(gg,(mod-1)/(mid<<1));
		if(kd) wn=kasumi(wn,mod-2);
		for(int i=0;i<lim;i+=(mid<<1))
		{
			long long w=1;
			for(int j=0;j<mid;j++,w=w*wn%mod)
			{
				long long x=a[i+j];
				long long y=a[i+j+mid]*w%mod;
				a[i+j]=(x+y)%mod;
				a[i+j+mid]=(x-y+mod)%mod;
			}
		}
	}
	if(kd)
	{
		int invl=kasumi(lim,mod-2);
		for(int i=0;i<lim;i++)
		{
			a[i]=a[i]*invl%mod;
		}
	}
}

void solve(int l,int r,int logn)
{
	if(!logn) return ;
	int mid=(l+r)>>1;
	solve(l,mid,logn-1);
	for(int i=l;i<=r;i++)
	{
		tmp2[i-l]=t[i-l];
	}
	for(int i=l;i<=mid;i++)
	{
		tmp1[i-l]=h[i];
	}
	for(int i=mid+1;i<=r;i++)
	{
		tmp1[i-l]=0;
	}
	NTT(tmp1,0,logn);
	NTT(tmp2,0,logn);
	for(int i=l;i<=r;i++)
	{
		tmp1[i-l]=tmp1[i-l]*tmp2[i-l]%mod;
	}
	NTT(tmp1,1,logn);
	for(int i=mid+1;i<=r;i++)
	{
		h[i]=(h[i]-tmp1[i-l]+mod)%mod;
	}
	solve(mid+1,r,logn-1);
}

void init()
{
	fac[0]=1;
	for(int i=1;i<=200000;i++)
	{
		fac[i]=fac[i-1]*i%mod;
	}
	inv[200000]=kasumi(fac[200000],mod-2);
	for(int i=199999;i>=0;i--)
	{
		inv[i]=inv[i+1]*(i+1)%mod;
	}
	t[0]=1;
	long long tmp;
	for(int i=1;i<=200000;i++)
	{
		tmp=kasumi(2,1ll*(i-1)*i/2);
		t[i]=tmp*inv[i]%mod;
		h[i]=t[i]*i%mod;
	}
}

int n;

int main()
{
	int cnt=1;
	init();
	scanf("%d",&n);
	for(;(1<<cnt)<=n;cnt++);
	solve(0,(1<<cnt)-1,cnt);
	printf("%lld\n",h[n]*fac[n-1]%mod);
}
```



---

## 作者：x7103 (赞：4)

## 题目描述
给定 $n$，求 $n$ 个点的简单有标号无向连通图数目，对 $1004535809$ 取模。

**数据范围：**$n\le130000$。

**时间限制：**$2000\operatorname{ms}$。
## Solution
设 $f_i$ 表示 $i$ 个点的简单有标号无向连通图数目，$g_i$ 表示 $i$ 个点的简单有标号无向图的数目，有 $g_i=2^{\binom{n}{2}}$。

枚举一号节点所在环大小，把这个环孤立起来，统计方案数，有
$$g_n=\sum_{i=1}^{n}{\dbinom{n-1}{i-1}f_ig_{n-i}}$$
把组合数展开，有
$$g_n=\sum_{i=1}^{n}{\frac{(n-1)!}{(i-1)!(n-i)!}}f_ig_{n-i}$$
$$\frac{g_n}{(n-1)!}=\sum_{i=1}^{n}\frac{f_i}{(i-1)!}\times\frac{g_{n-i}}{(n-i)!}$$
令 $F(x)=\sum_{i=1}^{n}\frac{f_i}{(i-1)!}x^i$，$G(x)=\sum_{i=0}^{n}{\frac{g_i}{i!}x^i}$，$H(x)=\sum_{i=1}^{n}{\frac{g_i}{(i-1)!}x^i}$
那么有
$$H(x)=F(x)G(x)\bmod{x^{n+1}}$$
所以
$$F(x)=H(x)G^{-1}(x)\bmod{x^{n+1}}$$
多项式求逆即可解决，时间复杂度为 $O(n\log n)$。
## Code
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
const int maxn=300000,MLY=1004535809,g=3;
int bit,tot,rev[maxn];
int G[maxn],invG[maxn],H[maxn],g2[maxn];
int fac[maxn],invfac[maxn],n;
inline int power(int a,int b){
	int ans=1;
	while(b){
		if(b&1)ans=1ll*ans*a%MLY;
		a=1ll*a*a%MLY;
		b>>=1;
	}
	return ans;
}
inline void Init(int n){
	bit=0;while((1<<bit)<=(n<<1))++bit;
	tot=1<<bit;
	for(int i=1;i<tot;++i)rev[i]=(rev[i>>1]>>1)|((i&1)<<(bit-1));
}
inline void NTT(int *a,int inv){
	for(int i=0;i<tot;++i)
		if(i<rev[i])
			swap(a[i],a[rev[i]]);
	for(int mid=1;mid<tot;mid<<=1){
		int tmp=power(g,(MLY-1)/(mid<<1));
		if(!~inv)tmp=power(tmp,MLY-2);
		for(int i=0;i<tot;i+=(mid<<1)){
			for(int j=0,w=1;j<mid;++j,w=1ll*w*tmp%MLY){
				int x=a[i+j],y=1ll*w*a[i+j+mid]%MLY;
				a[i+j]=(x+y)%MLY;a[i+j+mid]=(x-y+MLY)%MLY;
			}
		}
	}
	if(!~inv){
		inv=power(tot,MLY-2);
		for(int i=0;i<tot;++i)a[i]=1ll*a[i]*inv%MLY;
	}
}
inline void PolyMul(int *F,int *G,int n,int inv=0){
	static int a[maxn],b[maxn];
	Init(n);
	for(int i=0;i<n;++i)a[i]=F[i],b[i]=G[i];
	for(int i=n;i<tot;++i)a[i]=b[i]=0;
	NTT(a,1);NTT(b,1);
	for(int i=0;i<tot;++i){
		if(inv)a[i]=b[i]*(2-1ll*a[i]*b[i]%MLY+MLY)%MLY;
		else a[i]=1ll*a[i]*b[i]%MLY;
	}
	NTT(a,-1);
	for(int i=0;i<n;++i)G[i]=a[i];
}
inline void PolyInv(int *F,int *G,int n){
	if(n==1){
		G[0]=power(F[0],MLY-2);
		return;
	}
	PolyInv(F,G,(n+1)>>1);
	PolyMul(F,G,n,1);
}
int main(){
	scanf("%d",&n);
	fac[0]=invfac[0]=1;
	for(int i=1;i<=n;++i)fac[i]=1ll*fac[i-1]*i%MLY;
	invfac[n]=power(fac[n],MLY-2);
	for(int i=n-1;i;--i)invfac[i]=invfac[i+1]*(i+1ll)%MLY;
	for(int i=0;i<=n;++i)g2[i]=power(2,i*(i-1ll)/2%(MLY-1));
	for(int i=1;i<=n;++i)H[i]=1ll*g2[i]*invfac[i-1]%MLY;
	for(int i=0;i<=n;++i)G[i]=1ll*g2[i]*invfac[i]%MLY;
	PolyInv(G,invG,n+1);
	PolyMul(H,invG,n+1);
	printf("%lld",1ll*invG[n]*fac[n-1]%MLY);
	return 0;
}
```

---

## 作者：Hyscere (赞：3)

设$f(i)$为$i$个点的题目所求的答案，$g(i)$为$i$个点随便连的方案数，那么我们枚举$1$号点所在联通块的大小，可得：
$$g(n)=\sum_{i=1}^nf(i)\binom{n-1}{i-1}g(n-i)=2^{\binom{n}{2}}=2^{n(n-1)/2}$$
容易知道这样可以不重不漏的算到所有状态。

我们把$g$带进去：
$$2^{n(n-1)/2}=\sum_{i=1}^nf(i)\binom{n-1}{i-1}2^{\binom{n-i}{2}}$$
两边除以$(n-1)!$：
$$\frac{2^{n(n-1)/2}}{(n-1)!}=\sum_{i=1}^n\frac{f(i)}{(i-1)!}\times \frac{2^{\binom{n-i}{2}}}{(n-i)!}$$
注意到这是个卷积的形式，用生成函数表示一下：
$$A(x)=\sum_{n=0}^\infty\frac{2^{n(n-1)/2}}{(n-1)!}x^n$$
$$B(x)=\sum_{n=0}^\infty\frac{2^{n(n-1)/2}}{n!}x^n$$
$$F(x)=\sum_{n=0}^\infty\frac{f(i)}{(n-1)!}x^n$$
那么：
$$A(x)=F(x)B(x),F(x)=A(x)B^{-1}(x)$$
那么直接套多项式求逆的板子就好了。

```c++
#include<bits/stdc++.h>
using namespace std;
 
void read(int &x) {
    x=0;int f=1;char ch=getchar();
    for(;!isdigit(ch);ch=getchar()) if(ch=='-') f=-f;
    for(;isdigit(ch);ch=getchar()) x=x*10+ch-'0';x*=f;
}
 
void print(int x) {
    if(x<0) putchar('-'),x=-x;
    if(!x) return ;print(x/10),putchar(x%10+48);
}
void write(int x) {if(!x) putchar('0');else print(x);putchar('\n');}

#define lf double
#define ll long long 

const int maxn = 6e5+10;
const int inf = 1e9;
const lf eps = 1e-8;
const int mod = 1004535809;

int n,w[maxn],rw[maxn],pos[maxn],f[maxn],a[maxn],b[maxn],c[maxn],mxn,N,bit,fac[maxn],ifac[maxn],g[maxn];

int qpow(int aa,int x) {
	int res=1;
	for(;x;x>>=1,aa=1ll*aa*aa%mod) if(x&1) res=1ll*res*aa%mod;
	return res;
}

void prepare() {
	w[0]=1,w[1]=qpow(3,(mod-1)/mxn);
	for(int i=2;i<=mxn;i++) w[i]=1ll*w[i-1]*w[1]%mod;
	rw[0]=1,rw[1]=qpow(qpow(3,mod-2),(mod-1)/mxn);
	for(int i=2;i<=mxn;i++) rw[i]=1ll*rw[i-1]*rw[1]%mod;
}

void ntt(int *r,int op) {
	for(int i=1;i<N;i++) if(pos[i]>i) swap(r[i],r[pos[i]]);
	for(int i=1,d=mxn>>1;i<N;i<<=1,d>>=1) 
		for(int j=0;j<N;j+=i<<1)
			for(int k=0;k<i;k++) {
				int x=r[j+k],y=1ll*r[i+j+k]*(op==1?w:rw)[k*d]%mod;
				r[j+k]=(x+y)%mod,r[i+j+k]=(x-y+mod)%mod;
			}
	if(op==-1) {
		int inv=qpow(N,mod-2);
		for(int i=0;i<N;i++) r[i]=1ll*r[i]*inv%mod;
	}
}

int tmp1[maxn],tmp2[maxn];

void get_inv(int *r,int *s,int len) {
	if(len==1) return s[0]=qpow(r[0],mod-2),void();
	get_inv(r,s,len>>1);
	for(int i=0;i<len>>1;i++) tmp1[i]=s[i];
	for(int i=len>>1;i<len;i++) tmp1[i]=0;
	for(int i=0;i<len;i++) tmp2[i]=r[i];

	for(bit=0,N=1;N<=len;N<<=1,bit++);
	for(int i=1;i<N;i++) pos[i]=pos[i>>1]>>1|((i&1)<<(bit-1));
	for(int i=len;i<N;i++) tmp1[i]=tmp2[i]=0;
	ntt(tmp1,1),ntt(tmp2,1);
	for(int i=0;i<N;i++) s[i]=((2ll*tmp1[i]%mod-1ll*tmp2[i]*tmp1[i]%mod*tmp1[i]%mod)%mod+mod)%mod;
	ntt(s,-1);
	for(int i=len;i<N;i++) s[i]=0;
}

int main() {
	read(n);
	for(mxn=1;mxn<=n<<1;mxn<<=1);
	prepare();
	fac[0]=ifac[0]=c[0]=1;
	for(int i=1;i<=mxn;i++) fac[i]=1ll*fac[i-1]*i%mod;
	ifac[mxn]=qpow(fac[mxn],mod-2);
	for(int i=mxn-1;i;i--) ifac[i]=1ll*ifac[i+1]*(i+1)%mod;
	for(int i=1;i<=n;i++) g[i]=qpow(2,(1ll*i*(i-1)/2)%(mod-1));
	for(int i=1;i<=n;i++) c[i]=1ll*g[i]*ifac[i]%mod,b[i]=1ll*g[i]*ifac[i-1]%mod;
	
	get_inv(c,a,mxn>>1);
	for(bit=0,N=1;N<mxn;N<<=1,bit++);
	for(int i=1;i<N;i++) pos[i]=pos[i>>1]>>1|((i&1)<<(bit-1));
	ntt(a,1),ntt(b,1);
	for(int i=0;i<N;i++) a[i]=1ll*a[i]*b[i]%mod;
	ntt(a,-1);
	printf("%lld\n",(1ll*a[n]*fac[n-1]%mod+mod)%mod);
	return 0;
}
```

---

## 作者：qczrz6v4nhp6u (赞：2)

**注意：下文中的“图”均指有标号无向图。**
## 题意
给定 $n$，求 $n$ 个节点构成的连通图数量。
## 解法 0
考虑 DP。

记 $f_n$ 表示 $n$ 个节点构成的连通图的个数，$g_n$ 表示 $n$ 个节点构成的图的个数，那么有：
$$f_n=g_n-\sum_{i=1}^{n-1}{n-1\choose i-1}f_ig_{n-i}$$
$$g_n=2^{n\choose 2}$$
第一个式子可以理解为通过枚举 1 号节点所在联通块的大小来构造非连通图，再在所有图中减去非连通图；第二个式子则比较显然。

朴素 DP 即可求解。复杂度 $O(n^2)$。
## 解法 1
发现上式类似于分治 NTT 的形式，于是使用分治 NTT。复杂度 $O(n\log^2n)$。
## 解法 2
~~以分治 NTT 的尿性~~ 根据我们的经验，很多分治 NTT 的题目都可以用生成函数做。我们也考虑使用生成函数。

将上式移项：
$$g_n=f_n+\sum_{i=1}^{n-1}{n-1\choose i-1}f_ig_{n-i}$$
发现 $n-1\choose n-1$ 和 $g_0$ 均为 $1$，于是将 $f_n$ 合并到求和式里面去：
$$g_n=\sum_{i=1}^n{n-1\choose i-1}f_ig_{n-i}$$
$$g_n=\sum_{i=1}^n\dfrac{(n-1)!}{(i-1)!(n-i)!}f_ig_{n-i}$$
$$\dfrac{g_n}{(n-1)!}=\sum_{i=1}^n\dfrac{f_i}{(i-1)!}\cdot\dfrac{g_{n-i}}{(n-i)!}$$
发现形式是卷积，构造 EGF：
$$F(x)=\sum_{n\ge 1}\dfrac{x^n}{(n-1)!}\cdot f_n$$
$$G(x)=\sum_{n\ge 0}\dfrac{x^n}{n!}\cdot g_n$$
$$H(x)=\sum_{n\ge 1}\dfrac{x^n}{(n-1)!}\cdot g_n$$
于是：
$$H(x)=F(x)G(x)\pmod{x^{n+1}}$$
$$F(x)=\dfrac{H(x)}{G(x)}\pmod {x^{n+1}}$$
使用多项式求逆即可在 $O(n\log n)$ 时间内解决。
## 代码
封装了类，常数略大。
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int M=1004535809;
const int N=1<<18;
template<typename T>T qpow(T a,ll b){
	T res=1;
	for(;b;b>>=1,a=a*a)
		if(b&1)res=res*a;
	return res;
}
class mint{
	public:
	ll val;
	mint(ll _val=0){val=(_val%M+M)%M;}
	mint operator +(mint _){return (val+_.val+M)%M;}
	mint operator -(mint _){return (val-_.val+M)%M;}
	mint operator *(mint _){return val*_.val%M;}
	mint operator /(mint _){return *this*qpow(_,M-2);}
	mint operator ^(ll _){return qpow(*this,_);}
	mint operator +=(mint _){return *this=*this+_;}
	mint operator -=(mint _){return *this=*this-_;}
	mint operator *=(mint _){return *this=*this*_;}
	mint operator /=(mint _){return *this=*this/_;}
	mint operator ^=(ll _){return *this=*this^_;}
};
int rev[N*2];
void NTT(int lim,mint*F,int type){
	rev[0]=0;
	for(int i=1;i<lim;i++)rev[i]=(rev[i>>1]>>1)|((i&1)*(lim>>1));
	for(int i=0;i<lim;i++)if(i<rev[i])swap(F[i],F[rev[i]]);
	for(int i=1;i<lim;i<<=1){
		mint wn=(mint)3^((M-1)/(i<<1));
		if(type==-1)wn=(mint)1/wn;
		for(int j=0;j<lim;j+=(i<<1)){
			mint w=1;
			for(int k=0;k<i;k++,w*=wn){
				mint x=F[j+k],y=w*F[j+k+i];
				F[j+k]=x+y;
				F[j+k+i]=x-y;
			}
		}
	}
	if(type==1)return;
	mint inv=(mint)1/lim;
	for(int i=0;i<lim;i++)F[i]*=inv;
}
class Polynom{
	public:
	int n;
	mint a[N];
	Polynom(int _n=-1){n=_n;memset(a,0,sizeof a);}
	void print(){
		if(n<0){puts("0");return;}
		for(int i=0;i<=n;i++)printf("%lld ",a[i].val);
		puts("");
	}
	friend Polynom operator +(Polynom F,Polynom G){
		Polynom H;
		H.n=max(F.n,G.n);
		for(int i=0;i<=H.n;i++)H.a[i]=F.a[i]+G.a[i];
		return H;
	}
	friend Polynom operator -(Polynom F,Polynom G){
		Polynom H;
		H.n=max(F.n,G.n);
		for(int i=0;i<=H.n;i++)H.a[i]=F.a[i]-G.a[i];
		while(!H.a[H.n].val)H.n--;
		return H;
	}
	friend Polynom operator *(Polynom F,Polynom G){
		Polynom H;H.n=F.n+G.n;
		int lim=1;while(lim<=H.n)lim<<=1;
		NTT(lim,F.a,1),NTT(lim,G.a,1);
		for(int i=0;i<lim;i++)H.a[i]=F.a[i]*G.a[i];
		NTT(lim,H.a,-1);
		return H;
	}
	friend Polynom inv(Polynom F){
		Polynom G=Polynom(0);G.a[0]=(mint)1/F.a[0];
		Polynom F0=Polynom(0);
		int lim;
		for(lim=2;lim<=F.n*2;lim<<=1){
			for(int i=0;i<lim;i++)F0.a[i]=F.a[i];
			for(int i=lim;i<lim*2;i++)F0.a[i]=0;
			NTT(lim*2,F0.a,1);
			NTT(lim*2,G.a,1);
			for(int i=0;i<lim*2;i++)
				G.a[i]*=(mint)2-F0.a[i]*G.a[i];
			NTT(lim*2,G.a,-1);
			for(int i=lim;i<lim*2;i++)G.a[i]=0;
		}
		G.n=F.n;
		for(int i=G.n+1;i<lim*2;i++)G.a[i]=0;
		return G;
	}
	friend Polynom operator /(Polynom F,Polynom G){
		reverse(F.a,F.a+F.n+1);
		reverse(G.a,G.a+G.n+1);
		G.n=F.n-G.n;
		Polynom H=F*inv(G);
		reverse(H.a,H.a+G.n+1);
		for(int i=G.n+1;i<=H.n;i++)H.a[i]=0;
		H.n=G.n;
		return H;
	}
	friend Polynom operator %(Polynom F,Polynom G){return F-(F/G)*G;}
	Polynom operator +=(Polynom _){return *this=*this+_;}
	Polynom operator -=(Polynom _){return *this=*this-_;}
	Polynom operator *=(Polynom _){return *this=*this*_;}
	Polynom operator /=(Polynom _){return *this=*this/_;}
};
Polynom F,G,H;
mint fac[N],ifac[N];
int n;
void init(int N){
	fac[0]=1;
	for(int i=1;i<=N;i++)fac[i]=fac[i-1]*i;
	ifac[N]=(mint)1/fac[N];
	for(int i=N;i>=1;i--)ifac[i-1]=ifac[i]*i;
}
int main(){
	scanf("%d",&n);
	init(n);
	G.n=n;for(int i=0;i<=n;i++)G.a[i]=((mint)2^(1ll*i*(i-1)/2))*ifac[i];
	H.n=n;for(int i=1;i<=n;i++)H.a[i]=((mint)2^(1ll*i*(i-1)/2))*ifac[i-1];
	F=H*inv(G);
	printf("%lld",(F.a[n]*fac[n-1]).val);
	return 0;
}
```


---

## 作者：Prean (赞：2)

无向联通图计数板子

首先，这个太难了，先让我们来求一个简单的：

无向图计数。

一共 $ \frac {n \times (n+1)} 2 $ 条可能存在的边，枚举一条边是否存在，就有 $ 2^{\frac {n \times (n+1)} 2} $ 个无向图。

回到本题，我们先设 $ f_n $ 是我们要求的 $ n $ 个无向联通图的个数， $ g_n $ 是 $ 2^{\frac {n \times (n+1)} 2} $，很明显有：
$$ g_n=\sum_{i=1}^n\binom{n-1}{i-1}f_ig_{n-i} $$
组合数后面的是一个卷积的形式，而组合数本身就是一堆阶乘，这在提示我们使用 EGF，并且本题的模数也是一个 NTT 模数。
$$ \frac {g_n} {(n-1)!}=\sum_{i=1}^n \frac {f_i} {(i-1)!} \times \frac {g_{n-i}} {(n-i)!} $$
然后我们设 $ F(x) $ 是 { $ f_n $ } 的 EGF，$ G(x) $ 是 { $ g_n $ } 的 EGF。

很容易发现：$ g_n=[x^n]G'(x) $，然后就有：
$$ G'(x)=F'(x)G(x) $$
$$ \frac {G'(x)} {G(x)}=F'(x) $$
$$ F(x)=\ln G(x) $$
然后我们就做完了。

贴代码：
```cpp
#include<cstring>
#include<cstdio>
#define clr(f,len) memset(f,0,(len)<<2)
#define cpy(f,g,len) memcpy(f,g,(len)<<2)
const int G=3,invG=334845270,mod=1004535809,M=7e5+5;
int n,t[M],f[M],inv[M],tor[M];
inline void swap(int&a,int&b){
    a^=b^=a^=b;
}
inline void GetRev(int len){
    for(int i=0;i<len;++i)t[i]=t[i>>1]>>1|(i&1?len>>1:0);
}
inline void px(int*f,int*g,int len){
    for(int i=0;i<len;++i)f[i]=1ll*f[i]*g[i]%mod;
}
inline void der(int*f,int n){
    for(int i=1;i<n;++i)f[i-1]=1ll*f[i]*i%mod;
    f[n-1]=0;
}
inline void itg(int*f,int n){
    for(int i=n;i;--i)f[i]=1ll*f[i-1]*inv[i]%mod;
    f[0]=0;
}
inline int pow(int a,int b=mod-2){
    int ans=1;
    for(;b;b>>=1,a=1ll*a*a%mod)if(b&1)ans=1ll*ans*a%mod;
    return ans;
}
void NTT(int*f,bool flag,int n){
    int i,k,p,w,w1,len;
    for(i=0;i<n;++i)if(i<t[i])swap(f[i],f[t[i]]);
    for(p=2;p<=n;p<<=1){
        len=p>>1;w1=pow(flag?G:invG,(mod-1)/p);
        for(k=0;k<n;k+=p){
            w=1;
            for(i=k;i<k+len;++i){
                int t=1ll*f[i+len]*w%mod;
                if((f[i+len]=f[i]-t)<0)f[i+len]+=mod;
                if((f[i]=f[i]+t)>mod)f[i]-=mod;
                w=1ll*w*w1%mod;
            }
        }
    }
    if(flag)return;
    int invN=pow(n);
    for(i=0;i<n;++i)f[i]=1ll*f[i]*invN%mod;
}
void invp(int*f,int m){
    static int b1[M],b2[M],b3[M];
    int i,n=1,len;b1[0]=pow(f[0]);
    while(n<m)n<<=1;
    for(len=2;len<=n;len<<=1){
        for(i=0;i<(len>>1);++i)b3[i]=(b1[i]<<1)%mod;
        cpy(b2,f,len);
        GetRev(len<<1);
        NTT(b1,1,len<<1);px(b1,b1,len<<1);
        NTT(b2,1,len<<1);px(b1,b2,len<<1);
        NTT(b1,0,len<<1);clr(b1+len,len);
        for(i=0;i<len;++i)b1[i]=(b3[i]-b1[i]+mod)%mod;
    }
    cpy(f,b1,m);clr(b1,n<<1);clr(b2,n<<1);clr(b3,n<<1);
}
void lnp(int*f,int n){
    static int sav[M];
    cpy(sav,f,n);
    der(f,n);invp(sav,n);
    GetRev(n<<1);
    NTT(f,1,n<<1);NTT(sav,1,n<<1);
    px(f,sav,n<<1);NTT(f,0,n<<1);
    itg(f,n-1);
    clr(f+n,n);clr(sav,n);
}
signed main(){
    int i,m=1,tmp1,tmp2;
    inv[1]=tor[0]=tor[1]=1;
    scanf("%d",&n);++n;
    while(m<n)m<<=1;
    GetRev(m);
    for(i=2;i<=m;++i){
        inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;
        tor[i]=1ll*tor[i-1]*i%mod;
    }
    for(i=0;i<m;++i)f[i]=1ll*pow(2,(1ll*i*(i-1)>>1)%(mod-1))*pow(tor[i])%mod;
    lnp(f,m);
    printf("%d",1ll*f[n-1]*tor[n-1]%mod);
}
```

---

## 作者：feicheng (赞：2)

## $\textbf{Description}$

>求 $n$ 个点的有标号的无向连通图数目。          
$\text{restrictions}:1\le n\le1.3\times10^5$

## $\textbf{solution}$

我们设 $g_i$ 表示有 $i$ 个点的**有标号无向图**数目，易得 $g_i = 2^{C_n^2}$。

>考虑枚举每两个点之间是否连通。

设 $f_i$ 表示有 $i$ 个点的连通图数目（即答案所求）。

则可得：

$$
g_n = \sum_{i=1}^n C_{n-1}^{i-1}f_i g_{n-i}
$$

>考虑 $1$ 号点所处的连通块大小 $i$，则需要从 $n-1$ 个点中选出 $i-1$ 个点，剩下 $n-i$ 个点随便排列，即 $g_i$ 的含义。

推一波式子：

$$
g_n = \sum_{i=1}^n C_{n-1}^{i-1}f_i g_{n-i}
$$
$$
g_n = (n-1)!\sum_{i=1}^n \frac {f_i} {(i-1)!} \times \frac {g_{n-i}} {(n-i)!} 
$$
$$
\frac {g_n} {(n-1)!} = \sum_{i=1}^n \frac {f_i} {(i-1)!} \times \frac {g_{n-i}} {(n-i)!} 
$$

设 

$$
F(x) = \sum_{i=1}^{+\infty}\frac {f_i} {(i-1)!}x^n 
$$
$$
G(x) = \sum_{i=1}^{+\infty}\frac {g_i} {(i-1)!}x^n
$$
$$
H(x) = \sum_{i=0}^{+\infty}\frac {g_i} {i!} x^n
$$

则 
$$
F = H*G^{-1}
$$
$$
f(x) = \frac {F(x)} {(n-1)!}
$$

$G,H$ 可以预处理，套个多项式求逆的板子即可。

时间复杂度 $\Theta(n\log n)$

---

## 作者：CmsMartin (赞：1)

[更好的阅读体验](http://cmsblog.top/archives/-ji-xun-dui-zuo-ye-2013-cheng-shi-gui-hua)

## 题目描述

[题目传送门](https://www.luogu.com.cn/problem/P4841)

## 思路

套路题。

设 $f_i$ 表示由 $i$ 个点所组成的联通无向图个数，$g_i$ 表示由 $i$ 个点组成的无向图个数，不保证联通。

由于没有重边与自环， $i$ 个点最多有 $\binom{n}{2}$ 条边，则有 $g_i = 2^{\binom{n}{2}}$。

考虑 $g_i$ 怎么表示，枚举 $i$ 号点所在的连通块大小，则有：

$$
g_n = \sum_{i=1}^n\binom{n-1}{i-1}f_ig_{n-i}
$$

$$
\Rightarrow \frac{2^{\binom{n}{2}}}{(n-1)!} = \sum_{i=1}^n\frac{f_i}{(i-1)!}\cdot\frac{2^\binom{{n-i}}{2}}{(n-i)!}
$$

这个东西看起来就很 OGF。

设 

$$
F(x) = \sum_{n=1}^\infty \frac{f_n}{(n-1)!}x^n
$$

$$
G(x) = \sum_{n=1}^\infty \frac{2^{\binom{n}{2}}}{n!}x^n
$$

$$
H(x) = \sum_{i=1}^\infty \frac{2^\binom{{n}}{2}}{(n-1)!}x^n
$$

显然有：

$$
H(x) = F(x) \times G(x)
\Leftrightarrow F(x) = H(x) \times G^{-1}(x)
$$

直接多项式求逆即可。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll mod = 1004535809, g = 3, MAXN = 130000 << 4;

ll qpow(ll a, ll b) {
	ll res = 1;
	while (b) {
		if (b & 1ll) res = res * a % mod;
		a = a * a % mod;
		b >>= 1ll;
	}
	return res;
}

int r[MAXN];

int limit;
void init(int l) {
	for (int i = 0; i < limit; i++)
		r[i] = (r[i >> 1] >> 1) | ((i & 1) << (l - 1));
}

void NTT(ll* f, int type) {
	for (int i = 0; i < limit; i++)
		if (i < r[i])
			swap(f[i], f[r[i]]);
	
	for (int mid = 1; mid < limit; mid <<= 1) {
		ll W = qpow(g, (mod - 1) / (mid << 1));
		if (type == -1) W = qpow(W, mod - 2);
		for (int R = mid << 1, j = 0; j < limit; j += R) {
			ll w = 1;
			for (int k = 0; k < mid; k++, w = w * W % mod) {
				ll x = f[j + k], y = w * f[j + k + mid] % mod;
				f[j + k] = (x + y) % mod;
				f[j + k + mid] = (x - y + mod) % mod;
			}
		}
	}

	if (type == 1) return;
	ll inv = qpow(limit, mod - 2);
	for (int i = 0; i < limit; i++)
		f[i] = (f[i] * inv + mod) % mod;
}

ll c[MAXN];


void GetInv(ll* f, ll* g, int n) {
	if (n == 1) {
		g[0] = qpow(f[0], mod - 2);
		return;
	}
	GetInv(f, g, n + 1 >> 1);
	limit = 1;
	int l = 0;
	while (limit <= n + n) limit <<= 1, l++;
	init(l);
	for (int i = 0; i < n; i++) c[i] = f[i];
	for (int i = n; i < limit; i++) c[i] = 0;
	NTT(c, 1);
	NTT(g, 1);
	for (int i = 0; i < limit; i++)
		g[i] = ((2ll - g[i] * c[i] % mod) + mod) % mod * g[i] % mod;
	NTT(g, -1);
	for (int i = n; i < limit; i++)
		g[i] = 0;
}

ll F[MAXN], G[MAXN], H[MAXN], _G[MAXN];
ll Fiv[MAXN], InvFiv[MAXN];
ll N;

int main() {
	ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);
	cin >> N;
	N++;
	Fiv[0] = InvFiv[0] = 1;
	for (int i = 1; i <= N; i++) {
		Fiv[i] = Fiv[i - 1] * i % mod;
		InvFiv[i] = qpow(Fiv[i], mod - 2);
	}
	for (int i = 0; i < N; i++) {
		G[i] = qpow(2, 1ll * i * (i - 1) / 2 % (mod - 1)) * InvFiv[i] % mod;
		if (i) H[i] = qpow(2, 1ll * i * (i - 1) / 2 % (mod - 1)) * InvFiv[i - 1] % mod;
	}
	
	GetInv(G, _G, N);

	limit = 1;
	int l = 0;
	while (limit <= N * 2) limit <<= 1, l++;
	NTT(_G, 1); NTT(H, 1);
	for (int i = 0; i < limit; i++) F[i] = _G[i] * H[i] % mod;
	NTT(F, -1);
	N--;
	cout << F[N] * Fiv[N - 1] % mod << endl;
	return 0;
}
```

---

## 作者：JustinRochester (赞：1)

[题面](https://www.luogu.com.cn/problem/P4841)

---

**【分析】**
-

令 $f_n$ 表示 $n$ 个点的简单无向连通图方案数

再令 $g_n$ 表示 $n$ 个点的简单无向图方案数

不难想到：
1. 答案即为 $f_n$ ，初始值 $f_0=1$
2. $g_n=2^{\displaystyle (^n_2)}$ ，原因是考虑每条边都可选或不选，共 $(^n_2)$ 条边
3. $\displaystyle g_n=\sum_{i=1}^n(^{n-1}_{i-1})f_ig_{n-i}(i>0)$ ，原因是考虑编号为 $1$ 的点，所在的连通块大小为 $i$ ，剩下的点随意组合

因此对第三个式子进行变形：

$\displaystyle {g_n\over (n-1)!}=\sum_{i=1}^n{f_i\over (i-1)!}\cdot {g_{n-i}\over (n-i)!}(i>0)$

即 $\displaystyle {g_{n+1}\over n!}=\sum_{i=0}^n {f_{i+1}\over i!}\cdot {g_{n-i}\over (n-i)!}$

考虑序列 $\{f_n\},\{g_n\}$ 的 EGF 分别为 $F(x),G(x)$

$\displaystyle F(x)=\sum_{n=0}^\infty {f_n\over n!}x^n$

$\displaystyle G(x)=\sum_{n=0}^\infty {g_n\over n!}x^n$

将这两个 EGF 求导得：

$\displaystyle F'(x)=\sum_{n=1}^\infty {f_n\over n!}\cdot n\cdot x^{n-1}=\sum_{n=0}^\infty {f_{n+1}\over n!}x^n$

$\displaystyle G'(x)=\sum_{n=1}^\infty {g_n\over n!}\cdot n\cdot x^{n-1}=\sum_{n=0}^\infty {g_{n+1}\over n!}x^n$

发现恰好与我们第三个式子的左侧式、卷积的第一个式子相同！

于是我们根据式子，写出卷积：$G'(x)=F'(x)\cdot G(x)$

因此 $\displaystyle F(x)=\int {G'(x)\over G(x)}\text dx+f_0$

求解 $G(x)$ 时，每一项的 $g_n$ 用 $2^{\displaystyle (^n_2)}$ 代入即可

当然，该式子能进一步化简：

$\displaystyle F(x)=\int {\text d[G(x)]\over G(x)}=\ln G(x)+f_0$

---

**【代码】**
-

使用多项式的板子即可

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int MAXN=1<<18,MOD=1004535809;
inline int add(int a,int b) { return (a+b>=MOD)?(a+b-MOD):(a+b); }
inline int dis(int a,int b) { return (a-b<0)?(a-b+MOD):(a-b); }
inline int fpow(ll a,ll x) { ll ans=1; for(;x;x>>=1,a=a*a%MOD) if(x&1) ans=ans*a%MOD; return ans; }
//快速幂
inline int inv(ll a) { return fpow(a,MOD-2); }//逆元
int Omega[2][22],Frac[MAXN],InF[MAXN],InV[MAXN];
inline void pre(){
    Omega[1][18]=fpow(3,MOD>>18);
    Omega[0][18]=inv( Omega[1][18] );
    for(int i=17;i>=0;i--)
        Omega[1][i]=1ll*Omega[1][i+1]*Omega[1][i+1]%MOD,
        Omega[0][i]=1ll*Omega[0][i+1]*Omega[0][i+1]%MOD;
    //预处理单位根
    
    Frac[0]=1;
    for(int i=1;i<=2e5;i++) Frac[i]=1ll*Frac[i-1]*i%MOD;
    InF[int(2e5)]=inv(Frac[int(2e5)]);
    for(int i=2e5;i>=0;i--) InF[i-1]=1ll*InF[i]*i%MOD;
    for(int i=1;i<=2e5;i++) InV[i]=1ll*InF[i]*Frac[i-1]%MOD;
    //预处理阶乘、阶乘逆元、逆元
}
int L,Rev[MAXN],invL;
inline void preNTT(){
    Rev[1]=L>>1;
    for(int i=2;i<L;i++) Rev[i]=(Rev[i>>1]>>1)|Rev[i&1];
    invL=inv(L);
}
inline void NTT(int f[MAXN],short op){//op=0 表示 IDFT
    for(int i=1;i<L;i++) if(i<Rev[i]) swap(f[i],f[Rev[i]]);
    for(int bas=2,mid=1,lb=1;bas<=L;bas<<=1,mid<<=1,lb++)
        for(int l=0,omega=Omega[op][lb],buf,tmp;buf=1,l<L;l+=bas)
            for(int k=l;tmp=1ll*buf*f[k+mid]%MOD,k<mid+l;k++,buf=1ll*buf*omega%MOD)
                f[k+mid]=dis(f[k],tmp),f[k]=add(f[k],tmp);
    if(!op) for(int i=0;i<L;i++) f[i]=1ll*f[i]*invL%MOD;
}
inline void mul(int f[MAXN],int g[MAXN],int h[MAXN],int N,int M,int mod=-1){
    static int p[MAXN],q[MAXN];
    L=1;
    while(L<N+M) L<<=1;
    preNTT();
    for(int i=0;i<L;i++) p[i]=q[i]=0;
    for(int i=0;i<N;i++) p[i]=f[i];
    for(int i=0;i<M;i++) q[i]=g[i];
    //先拷贝再变换
    NTT(p,1);
    NTT(q,1);
    for(int i=0;i<L;i++) h[i]=1ll*p[i]*q[i]%MOD;
    NTT(h,0);
    if(mod>=0) for(int i=mod;i<L;i++) h[i]=0;
}
inline void inv(int f[MAXN],int g[MAXN],int mod){//多项式求逆
    static int p[MAXN];
    if(mod==1){
        g[0]=inv(f[0]);
        return ;
    }
    inv(f,g,mod+1>>1);
    for(int i=0;i<mod;i++) p[i]=0;
    mul(f,g,p,mod,mod,mod);
    for(int i=0;i<mod;i++) p[i]=dis(0,p[i]);
    p[0]=add(p[0],2);
    mul(g,p,g,mod,mod,mod);
}
inline void ddx(int f[MAXN],int g[MAXN],int mod){//多项式求导
    static int p[MAXN];
    for(int i=0;i<mod;i++) p[i]=f[i+1]*(i+1ll)%MOD;
    for(int i=0;i<mod;i++) g[i]=p[i];
}
inline void intdx(int f[MAXN],int g[MAXN],int mod,int C=0){//多项式积分
    static int p[MAXN];
    for(int i=1;i<mod;i++) p[i]=1ll*f[i-1]*InV[i]%MOD; p[0]=C;
    for(int i=0;i<mod;i++) g[i]=p[i];
}
inline void ln(int f[MAXN],int g[MAXN],int mod,int C=0){//多项式对数
    static int p[MAXN],q[MAXN];
    ddx(f,p,mod);
    inv(f,q,mod);
    mul(p,q,g,mod,mod,mod);
    intdx(g,g,mod,C);
}
int F[MAXN],G[MAXN],N;
inline void work(){
    pre();
    static int p[MAXN],q[MAXN];
    N=1.3e5;
    for(int i=0;i<=N;i++) G[i]=fpow(2,1ll*i*(i-1)/2);
    for(int i=0;i<=N;i++) G[i]=1ll*G[i]*InF[i]%MOD;//OGF->EGF
    ln(G,F,N,1);
    for(int i=0;i<N;i++) F[i]=1ll*F[i]*Frac[i]%MOD;//EGF->OGF
}
int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    work();
    cin>>N;
    cout<<F[N]<<endl;
    return 0;
}
```

最后安利一下[本蒟蒻的博客](https://www.luogu.com.cn/blog/JustinRochester/)

---

## 作者：Captain1 (赞：1)

我来补一发多项式求逆的题解。思路是从$Misckoo$那里来的。  
~~毕竟这题好像标算是求逆~~  
我们令$g(n)$表示有n个点的无向图的个数，$f(n)$表示有n个点的无向连通图个数。  
$g(n)$比较好求，因为一共有$C_n^2$条边，每条边可以选或者不选，所以自然有$g(n) = 2^{C_n^2}$.  

之后我们换一种方法，在节点1所在的联通块中有多少个节点，剩下的只需要随便连就可以了。那么就有$g(n) = \sum_{i=1}^nC_{n-1}^{i-1}f(i)g(n-i)$  

把$g(n) = 2^{C_n^2}$带进式子,两边再同时除以$(n-1)!$，得到:
$$\frac{2^{C_n^2}}{(n-1)!} = \sum_{i=1}^n\frac{f(i)}{(i-1)!}\frac{2^{C_{n-i}^2}}{(n-i)!}$$  

这玩意可以看出来是卷积的形式，那么我们设:
$$F(x) = \sum_{i=1}^\infty\frac{f(i)}{(i-1)}x^i$$  
$$G(x) = \sum_{i=0}^\infty\frac{2^{C_i^2}}{i!}x^i$$  
$$H(x) = \sum_{i=1}^\infty\frac{2^{C_i^2}}{(i-1)!}$$  

那么$H(x) = F(x)G(x)$，在$(mod\ x^{n+1})$意义下求出$G(x)^{-1}$,那么$F(x) \equiv G(x)^{-1}H(x) (mod \ x^{n+1})$即为答案。注意最后要乘上$fac[n-1]$.  

注意不要像我一样犯智障错误……我对指数取模导致第一次只有65pts，但是可以对mod-1取模，因为模数是质数，而$a^{p-1} \equiv 1(mod\ p)$,对答案没有影响。  


```cpp
#include<bits/stdc++.h>
#define rep(i,a,n) for(int i = a;i <= n;i++)
#define per(i,n,a) for(int i = n;i >= a;i--)
#define enter putchar('\n')
#define fr friend inline
#define y1 poj

using namespace std;
typedef long long ll;
const int M = 800005;
const int mod = 1004535809;
const int G = 3;
const int invG = 334845270;
const double eps = 1e-7;

int read()
{
   int ans = 0,op = 1;char ch = getchar();
   while(ch < '0' || ch > '9') {if(ch == '-') op = -1;ch = getchar();}
   while(ch >= '0' && ch <= '9') ans = ans * 10 + ch - '0',ch = getchar();
   return ans * op;
}

int n,f[M],g[M],c[M],invg[M],d[M],rev[M],fac[M],inv[M],ans;

int inc(int a,int b){return (a+b) % mod;}
int mul(int a,int b){return 1ll * a * b % mod;}
int qpow(int a,ll b)
{
   int p = 1;
   while(b)
   {
      if(b & 1) p = mul(p,a);
      a = mul(a,a),b >>= 1;
   }
   return p;
}

void NTT(int *a,int l,int f)
{
   rep(i,0,l-1) if(i < rev[i]) swap(a[i],a[rev[i]]);
   for(int i = 1;i < l;i <<= 1)
   {
      int w1 = qpow(f ? G : invG,(mod-1) / (i<<1));
      for(int j = 0;j < l;j += (i<<1))
      {
	 int w = 1;
	 rep(k,0,i-1)
	 {
	    int kx = a[k+j],ky = mul(a[k+j+i],w);
	    a[k+j] = inc(kx,ky),a[k+j+i] = inc(kx,mod-ky),w = mul(w,w1);
	 }
      }
   }
   if(!f)
   {
      int inv = qpow(l,mod-2);
      rep(i,0,l-1) a[i] = mul(a[i],inv);
   }
}

void init()
{
   fac[0] = inv[0] = inv[1] = 1;
   rep(i,1,n) fac[i] = mul(fac[i-1],i);
   inv[n] = qpow(fac[n],mod-2);
   per(i,n-1,1) inv[i] = mul(inv[i+1],i+1);
}

int C(int n,int m){return mul(mul(fac[n],inv[m]),inv[n-m]);}

void getinv(int *a,int *b,int len)
{
   if(len == 1) {b[0] = qpow(a[0],mod-2);return;}
   getinv(a,b,(len+1)>>1);
   int l = 1,L = 0;
   while(l < (len<<1)) l <<= 1,L++;
   rep(i,0,l-1) rev[i] = (rev[i>>1] >> 1) | ((i&1) << (L-1));
   rep(i,0,len-1) d[i] = a[i];
   rep(i,len,l-1) d[i] = 0;
   NTT(d,l,1),NTT(b,l,1);
   rep(i,0,l-1) b[i] = mul(inc(2,mod-mul(d[i],b[i])),b[i]);
   NTT(b,l,0);
   rep(i,len,l-1) b[i] = 0;
}

int main()
{
   n = read(),init();
   //rep(i,1,n) c[i] = mul(qpow(2,C(i,2)),inv[i-1]);错误写法
   //rep(i,0,n) g[i] = mul(qpow(2,C(i,2)),inv[i]);
   rep(i,1,n) c[i] = mul(qpow(2,(1ll * i * (i-1) / 2)),inv[i-1]);
   rep(i,0,n) g[i] = mul(qpow(2,(1ll * i * (i-1) / 2)),inv[i]);
   getinv(g,invg,n+1);
   int l = 1,L = 0;
   while(l < n<<1) l <<= 1,L++;
   rep(i,0,l-1) rev[i] = (rev[i>>1] >> 1) | ((i&1) << (L-1));
   NTT(invg,l,1),NTT(c,l,1);
   rep(i,0,l-1) c[i] = mul(c[i],invg[i]);
   NTT(c,l,0);
   ans = mul(c[n],fac[n-1]);
   printf("%d\n",ans);
   return 0;
}

```

---

## 作者：zifanwang (赞：0)

首先有个很显然的 dp 做法。记 $f_i$ 表示 $i$ 个点的答案，考虑容斥，有：

$$f_i=2^{\frac{i(i-1)}2}-\sum_{j=1}^i {i-1\choose j-1}\cdot 2^{\frac{(i-j)(i-j-1)}2}\cdot f_j$$

展开组合数得：

$$
f_i=2^{\frac{i(i-1)}2}-\sum_{j=1}^i \frac{(i-1)!}{(j-1)!(i-j)!}\cdot 2^{\frac{(i-j)(i-j-1)}2}\cdot f_j\\
\frac{f_i}{(i-1)!}=\frac{2^{\frac{i(i-1)}2}}{(i-1)!}-\sum_{j=1}^i \frac{1}{(i-j)!}\cdot 2^{\frac{(i-j)(i-j-1)}2}\cdot \frac{f_j}{(j-1)!}
$$

右边的求和部分是一个卷积的形式。考虑构造其生成函数，记：

$$F(x)=\sum_{i=1}^n \frac{f_i}{(i-1)!}x^i$$

$$G(x)=\sum_{i=1}^{n-1}-\frac{2^{\frac{i(i-1)}2}}{i!}x^i$$

$$H(x)=\sum_{i=1}^{n-1}\frac{2^{\frac{i(i-1)}2}}{(i-1)!}x^i$$

那么转移式变为：

$$F=H+F*G$$

解得：

$$F=H*(\epsilon-G)^{-1}\pmod {x^{n+1}}$$

然后贺个多项式求逆板子就做完了。

---

## 作者：Fzrcy (赞：0)

> 简要题意：求出 $n$ 个点的简单有标号无向连通图数目。

设 $f_i$ 表示 $i$ 个点的简单有标号无向连通图数目，$g_i$ 表示 $i$ 个点的有标号无向图数目，有 $g_i=2^{\binom{n}{2}}$。

考虑枚举 1 号点所在的连通块的大小，则有：
$$
\begin{aligned}
g_n&=\sum_{i=1}^{n}\binom{n-1}{i-1}f_ig_{n-i}\\
&=(n-1)!\sum_{i=1}^{n}\frac{f_i\times g_{n-i}}{(i-1)!(n-i)!}\\
&=(n-1)!\sum_{i=1}^{n}\frac{f_i}{(i-1)!}\times\frac{g_{n-i}}{(n-i)!}\\
\end{aligned}
$$
设 $\dfrac{g_i}{(i-1)!}$ 的生成函数为 $S$、$\dfrac{f_i}{(i-1)!}$ 的生成函数为 $F$、$\dfrac{g_{i}}{i!}$ 的生成函数为 $G$，则：
$$
S=F*G(\bmod x^{n+1})
$$
有：
$$
G=G*S^{-1}(\bmod x^{n+1})
$$
直接多项式逆、多项式乘法计算即可。

```cpp
// qwq
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
constexpr int mo=1004535809,G=3;
constexpr int N=2e6+1;
int rev[N]; LL w[N];
LL ksm(LL x,LL y){
    LL ret=1;
    for(;y;y>>=1,x=x*x%mo)
        if(y&1)ret=ret*x%mo;
    return ret;
}
void NTT(LL* a,int Len,bool ok){
    for(int i=0;i<Len;i++){
        rev[i]=(rev[i>>1]>>1)+(i&1?Len>>1:0);
        if(rev[i]>i)swap(a[rev[i]],a[i]);
    }
    for(int d=1;d<Len;d<<=1){
        LL W=ksm(G,(mo-1)/(d<<1));if(ok)W=ksm(W,mo-2);
        w[0]=1;for(int i=1;i<d;i++)w[i]=w[i-1]*W%mo;
        for(int fi=0;fi<Len;fi+=d<<1){
            int se=fi+d;
            for(int i=0;i<d;i++){
                LL a0=a[fi+i],a1=a[se+i]*w[i]%mo;
                a[fi+i]=(a0+a1)%mo,a[se+i]=(a0-a1+mo)%mo;
            }
        }
    }
    if(ok){
        LL x=ksm(Len,mo-2);
        for(int i=0;i<Len;i++)a[i]=a[i]*x%mo;
    }
}
LL X[N],Y[N];
void Mul(LL* x,LL* y,LL* z,int n,int m,int nm){
    int Len=1;while(Len<=(n+m+2))Len<<=1;
    for(int i=0;i<Len;i++)X[i]=Y[i]=0;
    for(int i=0;i<n;i++)X[i]=x[i];
    for(int i=0;i<m;i++)Y[i]=y[i];
    NTT(X,Len,0),NTT(Y,Len,0);
    for(int i=0;i<Len;i++)X[i]=X[i]*Y[i]%mo;
    NTT(X,Len,1);
    for(int i=0;i<nm;i++)z[i]=X[i];
}
LL Tmp[N];
void PolyInv(LL* a,LL* Inv,LL n){
    if(n==1){Inv[0]=ksm(a[0],mo-2);return;}
    int m=n+1>>1;PolyInv(a,Inv,m);
    Mul(Inv,Inv,Tmp,m,m,n);Mul(Tmp,a,Tmp,n,n,n);
    for(int i=0;i<n;i++)Inv[i]=(2ll*Inv[i]%mo-Tmp[i]+mo)%mo;
}
LL fac[N],ifac[N],n,f[N],g[N],I[N];
LL Get(LL x){return ksm(2,x*(x-1)/2%(mo-1));}
int main(){
    cin>>n;fac[0]=ifac[0]=1;
    for(int i=1;i<=n;i++)fac[i]=fac[i-1]*i%mo;
    ifac[n]=ksm(fac[n],mo-2);
    for(int i=n-1;i;i--)ifac[i]=ifac[i+1]*(i+1)%mo;
    for(int i=0;i<=n;i++)f[i]=Get(i)*ifac[i-1]%mo,g[i]=Get(i)*ifac[i]%mo;
    PolyInv(g,I,n+1);Mul(f,I,f,n+1,n+1,n+1);
    cout<<f[n]*fac[n-1]%mo<<'\n';
    return 0;
}
```



---

## 作者：Durancer (赞：0)

### 前置知识

- 多项式乘法 (NTT)

- 多项式乘法逆

- 生成函数（OGF,EGF）

### 思路

通过对指数生成函数 ( $\text{EGF}$ ) 的学习，我们可以很简单的知道下面的两种情况的指数生成函数：

如果 $n$ 个点的简单无向联通图的 $\text{EGF}$ 设为 $\hat{F}(x)$，则 $n$ 个点的简单无向图的 $\text{EGF}$ 为 $\exp \hat{F}(x)$，可以知道的是：

$$\exp \hat{F}(x)=\sum_{n=0}^{\infty}2^{\binom{n}{2}}\frac{x^n}{n!}$$

利用多项式 $\ln$ 的知识即可得到 $\hat{F}(x)$。

这是生成函数的做法，这里要讲的是用多项式来干掉他！

设我们要求的 $n$ 个点的**简单无向连通图**的数量设为 $f_n$，设 $n$ 个点的**简单无向图**的数量为 $g_n$。

我们要求的就是 $f_n$ ，但是我们要先求出 $g_n$ 才行。

根据对 $g_n$ 的定义，可以发现任何两个不同的点的连接情况只有
**连**与**不连**两种情况啦，所以说每两个点对答案的贡献是 $2$，因此可以得出：

$$g_n=2^{\binom{n}{2}}$$

理解起来应该很简单了qwq，那么这里就不再赘述。

接下来就来考虑如何求出 $f_n$。

我们可以分成两个部分讨论，第一个部分讨论联通块的大小，第二个部分讨论剩下的点组成的**无向图**。

设我们亲爱的 $1$ 号为一直待在联通块中的点，假设联通块内有 $x$ 个点，组成的方案数就是：

$$f_x·\binom{n-1}{x-1}$$

$f_x$ 记录的是给定的点组成 $x$ 个点的无向连通图的方案，然后可以在除了 $1$ 号点之外找 $n-1$ 个点来组成这个方案，所以就可以得出：

$$g_n=\sum_{x=1}^nf_x\binom{n-1}{x-1}·g_{n-x}$$

然后把我们一开始求出的 $g_n=2^{\binom{n}{2}}$ 代进去得到：

$$2^{\binom{n}{2}}=\sum_{x=1}^{n}f_x\frac{(n-1)!}{(x-1)!(n-x)!}g_{n-x}$$

$$\frac{2^{\binom{n}{2}}}{(n-1)!}=\sum_{x=1}^n\frac{f_x}{(x-1)!}·\frac{g_{n-x}}{(n-x)!}$$

~~突然发现自己好像快没变量使了~~。接下来把他化成生成函数的形式

设： 

$$H(x)=\sum_{i=1}^{\infty}\frac{2^{\binom{i}{2}}}{(i-1)!}x^i$$  

$$G(x)=\sum_{i=0}^{\infty}\frac{g_{i}}{i!}x^i$$

$$F(x)=\sum^{\infty}_{i=1}\frac{f_i}{(i-1)!}x^i$$

由上面的式子得到了 

$$F(x)=\frac{H(x)}{G(x)}$$


预处理 $H(x),G(x)$，然后在模 $x^{n+1}$ 的意义下对 $G(x)$ 求个逆，然后求得 $F(x)$，将 $F(x)$ 第 $n$ 次项的系数与 $(n-1)$ 相乘，即可得到答案。

对于为什么要在模 $x^{n+1}$ 的意义下，因为要保留 $x^n$ 之前的次项，其余的都会被模去。

#### 代码实现

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<queue>
#include<stack>
#include<algorithm>
#include<vector>
#include<map>
#define int long long 
using namespace std;
const int N=4e5+9;
const int mod=1004535809;
const int gn[]={3,(mod+1)/3};
int g[N],f[N],h[N];
int c[N];//求逆中转数组 
int invg[N];//对g求逆 
int r[N];
int inv[N],ifac[N],fac[N];
int n;
int read()
{
	int f=1,x=0;
	char s=getchar();
	while(s<'0'||s>'9'){if(s=='-')f=-1;s=getchar();}
	while(s>='0'&&s<='9'){x=(x<<1)+(x<<3)+(s^'0');s=getchar();}
	return f*x;
}
int quick(int x,int p)
{
	int ret=1;
	while(p)
	{
		if(p&1) ret=ret*x%mod;
		x=x*x%mod;
		p>>=1;
	}
	return ret;
}
void NTT(int *A,int term,int type)
{
	for(int i=0;i<term;i++)
		if(i<r[i])
			swap(A[i],A[r[i]]);
	for(int mid=1;mid<term;mid<<=1)
	{
		int R=mid<<1;
		int Wn=quick(gn[type],(mod-1)/R);
		for(int j=0;j<term;j+=R)
		{
			int w=1;
			for(int k=0;k<mid;k++,w=w*Wn%mod)
			{
				int x=A[j+k]%mod;
				int y=w*A[j+k+mid]%mod;
				A[j+k]=(x+y)%mod;
				A[j+k+mid]=(x-y+mod)%mod;
			}
		}
	}
	if(type==1)
	{
		int inv=quick(term,mod-2);
		for(int i=0;i<term;i++)
			A[i]=A[i]*inv%mod;
	}
}
void Prepare()
{
	inv[0]=inv[1]=1;
	ifac[0]=ifac[1]=1;
	fac[0]=fac[1]=1;
	g[0]=1;
	for(int i=2;i<=n;i++)
	{
		inv[i]=(mod-mod/i)*inv[mod%i]%mod;
		ifac[i]=ifac[i-1]*inv[i]%mod;
		fac[i]=fac[i-1]*i%mod;
	}
	for(int i=1;i<n;i++)
	{
		int tmp=quick(2,(1ll*i*(i-1)/2)%(mod-1));//欧拉定理
		g[i]=tmp*ifac[i]%mod;
		h[i]=tmp*ifac[i-1]%mod; 
	}
}
void Inv(int *a,int *b,int len)
{
	if(len==1)
	{
		b[0]=quick(a[0],mod-2);
		return;
	}
	Inv(a,b,(len+1)>>1);
	int term=1,l=0;
	while(term<(len<<1))
	{
		term<<=1;
		l++;
	}
	for(int i=0;i<term;i++)
		r[i]=(r[i>>1]>>1)|((i&1)<<(l-1));
	for(int i=0;i<len;i++)
		c[i]=a[i];
	for(int i=len;i<term;i++)
		c[i]=0;
	NTT(c,term,0);
	NTT(b,term,0);
	for(int i=0;i<term;i++)
		b[i]=(2-b[i]*c[i]%mod+mod)%mod*b[i]%mod;
	NTT(b,term,1);
	for(int i=len;i<term;i++)
		b[i]=0;
}
signed main()
{
	n=read()+1;//最后求的是x^n 因此要保留前n+1项 
	Prepare();
	Inv(g,invg,n);
	int term=1,l=0;
	while(term<(n<<1))
	{
		l++;
		term<<=1;
	}// 
	for(int i=0;i<term;i++)
		r[i]=(r[i>>1]>>1)|((i&1)<<(l-1));
	NTT(h,term,0);
	NTT(invg,term,0);
	for(int i=0;i<term;i++)
		f[i]=invg[i]*h[i]%mod;
	NTT(f,term,1);
	n--;
	int Ans=f[n]*fac[n-1]%mod;
	printf("%lld\n",Ans);
	return 0;
}
```


---

## 作者：培淇2021 (赞：0)

做的第一道数论类黑题，来纪念一下。

首先，我们需要求出 $n$ 个点的有标号无向连通图数目，设为 $a_n$。

又因为 $n$ 个点的有标号无向图数目很好求，就是 $2^{C_n^2}$，设为 $b_n$。

又因为我们可以枚举 $1$ 号节点所在联通块的大小，剩下的边乱连，就可以得出这个式子：

$$b_n=\sum\limits_{i=1}^n C_{n-1}^{i-1}a_ib_{n-i}
$$

卷积？不好求。我们注意到 $C_{n-1}^{i-1}=\dfrac{(n-1)!}{(n-i)!(i-1)!}$ 跟 $n,i,n-i$ 有一些奇怪的关系，展开组合数得：

$$\frac{b_n}{(n-1)!} = \sum\limits_{i=1}^{n}\left(\dfrac{a_i}{(i-1)!}\times\dfrac{b_{n-i}}{(n-i)!}\right)$$

这样就很明显了，令 $A_n=\dfrac{a_n}{(n-1)!},B_n=\dfrac{b_n}{n!},C_n=\dfrac{b_n}{(n-1)!}$，再令 $f_A(x),f_B(x),f_C(x)$ 为它们的生成函数，得$f_C(x)=f_A(x)f_B(x)$。

所以我们可以先求出 $f_B(x),f_C(x)$，再把 $f_B(x)$ 求逆，最后与 $f_C(x) \ \texttt{NTT}$，取 $a_n(n-1)!$ 即可。

AC code:

```cpp
#include<bits/stdc++.h>
#define int long long
#define mod 1004535809
using namespace std;
int n,w[300005]={1},rw[300005]={1},tmp[300005],f[300005],a[300005],b[300005],c[300005]={1},tlen,bign,bit,jc1[300005]={1},jc2[300005]={1},g[300005],tmp1[300005],tmp2[300005];
int qp(int ds,int zs)
{
	int ansa=1;
	while(zs)
    {
		if(zs&1)
            ansa=(ansa*ds)%mod;
		ds=(ds*ds)%mod;
		zs>>=1;
	}
    return ansa;
}
void NTT(int *A,int val)
{
	for(int i=1;i<bign;i++)
    {
        if(i<tmp[i])
            swap(A[i],A[tmp[i]]);
    }
	for(int i=1,ii=tlen>>1;i<bign;i*=2,ii>>=1)
    {
		for(int j=0;j<bign;j+=i*2)
        {
			for(int k=0;k<i;k++)
            {
                int S1=A[k+j],S2;
                if(val==1)
                    S2=(A[k+i+j]*w[k*ii])%mod;
                else
                    S2=(A[k+i+j]*rw[k*ii])%mod;
                A[k+j]=(S1+S2)%mod;
				A[k+i+j]=(S1-S2+mod)%mod;
			}
		}
	}
	if(val==1)
        return;
	int niyuan=qp(bign,mod-2);
    for(int i=0;i<bign;i++)
        A[i]=(A[i]*niyuan)%mod;
}
void do_ny(int *A,int *B,int step)
{
	if(step==1) 
    {
        B[0]=qp(A[0],mod-2);
        return;
    }
	do_ny(A,B,(step+1)>>1);
    for(int i=0;i<(step>>1);i++)
    {
        tmp1[i]=B[i];
    }
	for(int i=step>>1;i<step;i++)
        tmp1[i]=0;
	for(int i=0;i<step;i++)
        tmp2[i]=A[i];
	for(bit=0,bign=1;bign<=step;bign<<=1,bit++);
	for(int i=1;i<bign;i++)
        tmp[i]=(tmp[i>>1]>>1)|((i&1)<<(bit-1));
	for(int i=step;i<bign;i++)
        tmp1[i]=tmp2[i]=0;
	NTT(tmp1,1);
    NTT(tmp2,1);
	for(int i=0;i<bign;i++)
        B[i]=((2*tmp1[i]%mod-tmp2[i]*tmp1[i]%mod*tmp1[i]%mod)%mod+mod)%mod;
	NTT(B,-1);
	for(int i=step;i<bign;i++)
        B[i]=0;
}
signed main()
{
	cin>>n;
	for(tlen=1;tlen<=n<<1;tlen<<=1);
	w[1]=qp(3,(mod-1)/tlen);
	for(int i=2;i<=tlen;i++)
        w[i]=(w[i-1]*w[1])%mod;
	rw[1]=qp(qp(3,mod-2),(mod-1)/tlen);
	for(int i=2;i<=tlen;i++)
        rw[i]=(rw[i-1]*rw[1])%mod;
	for(int i=1;i<=tlen;i++)
        jc1[i]=(jc1[i-1]*i)%mod;
	jc2[tlen]=qp(jc1[tlen],mod-2);
	for(int i=tlen-1;i;i--)
        jc2[i]=(jc2[i+1]*(i+1))%mod;
	for(int i=1;i<=n;i++)
        g[i]=qp(2,(i*(i-1)/2)%(mod-1));
	for(int i=1;i<=n;i++)
        c[i]=(g[i]*jc2[i])%mod,b[i]=(g[i]*jc2[i-1])%mod;
	do_ny(c,a,tlen>>1);
	bit=0,bign=1;
   for(;bign<tlen;bign<<=1,bit++);
	for(int i=1;i<bign;i++)
        tmp[i]=(tmp[i>>1]>>1)|((i&1)<<(bit-1));
	NTT(a,1);
    NTT(b,1);
	for(int i=0;i<bign;i++)
        a[i]=(a[i]*b[i])%mod;
	NTT(a,-1);
	cout<<(a[n]*jc1[n-1]%mod)%mod;
	return 0;
}
```

---


# [CQOI2014] 和谐矩阵

## 题目描述

我们称一个由 $0$ 和 $1$ 组成的矩阵是和谐的，当且仅当每个元素都有偶数个相邻的 $1$。一个元素相邻的元素包括它本身，及他上下左右的 $4$ 个元素（如果存在）。给定矩阵的行数和列数，请计算并输出一个和谐的矩阵。注意：所有元素为 $0$ 的矩阵是不允许的。


## 说明/提示

数据范围

$1\le n,m\le 40$。

感谢@miaomiao 提供spj。


## 样例 #1

### 输入

```
4 4```

### 输出

```
0 1 0 0
1 1 1 0
0 0 0 1
1 1 0 1

```

# 题解

## 作者：stoorz (赞：14)


对于矩阵中的一个点 $(x,y)$，就是要我们求出一种方案满足 $a[x][y]\ \operatorname{xor}\ a[x-1][y]\ \operatorname{xor}\ a[x+1][y]\ \operatorname{xor}\ a[x][y-1]\ \operatorname{xor}\ a[x][y+1]=0$。

那么我们对于每一个点 $(x,y)$，我们可以列出一个形如 $a_1x_1\ \operatorname{xor}\ a_2x_2\ \operatorname{xor}\ ...\ \operatorname{xor}\ a_{nm}x_{nm}=0$ 的方程。其中如果一个点与 $(x,y)$ 相邻或就是 $(x,y)$，那么该位置的系数 $a=1$，否则 $a=0$。

然后就是高斯消元板子了。

时间复杂度 $O$ $\Large{(}$ $(nm)^3$ $\Large{)}$。显然跑不过。
我们发现，题目要求是 01 矩阵，每一位的取值就只有 0 或 1。所以可以用 $\operatorname{bitset}$ 搞搞，可以简单理解为状压。时间复杂度 $O(\frac{(nm)^3}{32})$。

```cpp
#include <cstdio>
#include <bitset>
#include <cstring>
#include <algorithm>
using namespace std;

const int N=50;
const int dx[]={0,0,0,-1,1},dy[]={0,-1,1,0,0};
int n,m,id[N][N],ans[N*N];
bitset<N*N> a[N*N];

void gauss()
{
	for (int i=1;i<=n*m;i++)
	{
		for (int j=i;j<=n*m;j++)
			if (a[j][i]>0)  //找到一个该位置系数为 1 的方程
			{
				swap(a[i],a[j]);
				break;
			}
		if (!a[i][i]) ans[i]=1;  //这项是自由元，直接取 1 即可
		for (int j=i+1;j<=n*m;j++)
			if (a[j][i]) a[j]^=a[i];
	}
	for (int i=n*m;i>=1;i--)
		for (int j=i+1;j<=n*m;j++)
			ans[i]^=(ans[j]*a[i][j]);  //求解
}

int main()
{
	scanf("%d%d",&n,&m);
	for (int i=1;i<=n;i++)
		for (int j=1;j<=m;j++)
			id[i][j]=(i-1)*m+j;
	for (int i=1;i<=n;i++)
		for (int j=1;j<=m;j++)
		{
			for (int k=0;k<=4;k++)
			{
				int x=i+dx[k],y=j+dy[k];
				if (x<1 || y<1 || x>n || y>m) continue;
				a[id[i][j]][id[x][y]]=1;
			}
		}
	gauss();
	for (int i=1;i<=n*m;i++)
	{
		printf("%d ",ans[i]);
		if (i%m==0) putchar(10);
	}
	return 0;
}
```

---

## 作者：Holy_Push (赞：14)

本来只是试试水的，结果发现过了$???$于是你可以发现这片题解就是一种乱搞做法。不需要高斯消元，只需要$dfs$。


考虑$m≤20$的时候可以怎么做。其实我们可以直接枚举第一行的$01$状态。然后接下来每一行的状态都可以由上一行推出来。

如果我们已经知道第$i$行的$01$情况，现在我们想知道$i+1$行的$01$情况怎么办$?$

其实很简单。比如说我们想知道第$i$行第$j$列是$0$还是$1$，由于第$i-1$行第$j$列的相邻位置有偶数个$1$（其实就是异或和为$0$），所以$a[i-1][j],a[i-1][j-1],a[i-1][j+1],a[i-2][j],a[i][j]$这五个数的异或和为$0$，进而可以推出$a[i][j]=a[i-1][j]$ $xor$ $a[i-1][j-1]$ $xor$ $a[i-1][j+1]$ $xor$ $a[i-2][j]$。

于是我们可以通过枚举第一行的状态，进而推出全部的状态。时间复杂度为$O(2^mnm)$，显然$n,m≤40$时难以通过。

但是打表发现，通过上述方法枚举出来的方案都是左右对称的。也就是说，我们可以只枚举第一行的左半边，然后对称一下放到右半边即可。这样的时间复杂度就是$O(2^\frac{m}{2}nm$)，吸口氧就过了。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=100;

int n,m;
int a[N][N];

void pd()
{
	for (int i=m;i>(m+1)/2;i--) a[1][i]=a[1][m+1-i];
	for (int i=2;i<=n;i++)
		for (int j=1;j<=m;j++)
			a[i][j]=a[i-1][j]^a[i-1][j-1]^a[i-1][j+1]^a[i-2][j];
	for (int i=1;i<=m;i++)
		if (a[n][i]^a[n][i-1]^a[n][i+1]^a[n-1][i]) return;
	for (int i=1;i<=n;i++)
	{
		for (int j=1;j<=m;j++)
			putchar(a[i][j]+48),putchar(' ');
		putchar('\n');
	}
	exit(0);
}

void dfs(int x)
{
	if (x>(m+1)/2) {pd();return;}
	a[1][x]=1;dfs(x+1);//防止出现全0，所以先放1
	a[1][x]=0;dfs(x+1);
}

int main()
{
	cin>>n>>m;
	dfs(1);
}
```


---

## 作者：λᴉʍ (赞：10)

乱写能AC，暴力踩标程（雾

这题能高斯消元，只需要把每个位置的数给设出来就可以$O(1600^3)$跑了！

而且这个方程好像系数都是0而且结果都是1，那么消的时候只需要下面方程减上面方程就行了

而且这是个模2意义下的方程，所以不需要减只需要异或

所以可以用bitset存系数，然后减改异或就可以$O(1600^3/32)$~~辗标算~~

卡常小技巧：显然1的数量很小，所以可以用bitset自带的findfirst和findnext函数可以寻找1的位置再减。。。

然后就不开O2 8ms，开O2 0ms了

```cpp
// It is made by XZZ
#include<cstdio>
#include<algorithm>
#include<bitset>
#define il inline
#define rg register
#define vd void
#define sta static
typedef long long ll;
il int gi(){
	rg int x=0,f=1;rg char ch=getchar();
	while(ch<'0'||ch>'9')f=ch=='-'?-1:f,ch=getchar();
	while(ch>='0'&&ch<='9')x=x*10+ch-'0',ch=getchar();
	return x*f;
}
using namespace std;
bitset<1601>S[1601];
int p[1601];
int id[41][41];
int ans[1601];
int main(){
#ifdef xzz
	freopen("3164.in","r",stdin);
	freopen("3163.out","w",stdout);
#endif
	int n=gi(),m=gi(),N=n*m;
	for(rg int i=1;i<=n;++i)
		for(rg int j=1;j<=m;++j)
			id[i][j]=++id[0][0];
	for(rg int i=1;i<=n;++i)
		for(rg int j=1;j<=m;++j)
			S[id[i][j]][id[i][j]]=1;
	for(rg int i=1;i<=n;++i)
		for(rg int j=1;j<m;++j)
			S[id[i][j]][id[i][j+1]]=1;
	for(rg int i=1;i<=n;++i)
		for(rg int j=2;j<=m;++j)
			S[id[i][j]][id[i][j-1]]=1;
	for(rg int i=1;i<n;++i)
		for(rg int j=1;j<=m;++j)
			S[id[i][j]][id[i+1][j]]=1;
	for(rg int i=2;i<=n;++i)
		for(rg int j=1;j<=m;++j)
			S[id[i][j]][id[i-1][j]]=1;
	for(rg int i=1;i<=N;++i)p[i]=i;
	for(rg int i=1;i<=N;++i){
		for(rg int j=S[p[i]]._Find_first();j<i;j=S[p[i]]._Find_next(j))
			if(S[p[j]][j])S[p[i]]^=S[p[j]];
			else swap(p[i],p[j]);
	}
	for(rg int i=N;i;--i){
		if(S[p[i]][i]==0){ans[i]=1;continue;}
		for(rg int j=S[p[i]]._Find_next(i);j<=N;j=S[p[i]]._Find_next(j))
			ans[i]^=ans[j];
	}
	for(rg int i=1;i<=n;++i){
		for(rg int j=1;j<=m;++j)
			printf("%d ",ans[id[i][j]]);
		puts("");
	}
	return 0;
}
```





---

## 作者：N_z_ (赞：3)

怎么题解都在 $O(\frac{(nm)^3}w)$。

这里我们给出一个 $O(\frac{n^2m+n^3}w)$ 的做法。

考虑将第一列设为变量，发现利用第 $i$ 列和第 $i-1$ 列可以推出第 $i+1$ 列。具体的，对于 $(i,j)$，我们要求 $(i-1,j),(i,j-1),(i,j),(i,j+1),(i+1,j)$ 的异或和为 $0$。

对每个点维护等于第一列的哪些点的异或和，对第 $n+1$ 列要求全为 $0$，解方程即可。

---

## 作者：BzhH (赞：3)

很明显是一道高斯消元解线性异或方程组。

对于一个 $n\times m$ 的矩阵,我们给每个点编一个号,

对于第 $i$行,第 $j$ 列的点,则有 $p=(i-1)\times m+j$。

那么与它相邻的点的编号就出来了,

分别是 $p_1=p-m,p_2=p+m,p_3=p-1,p_4=p+1$。

那么对于每一个点,我们都可以列出一个方程式

$$x_p\oplus x_{p_1}\oplus x_{p_2}\oplus x_{p_3}\oplus x_{p_4}=0$$

那么 $n\times m$ 的矩阵就一共有 $nm$ 个点,即我们需要列出一个 $nm$ 元一次方程式组,

那这个方程组求出来的解就一定是答案吗?

不是,很明显,矩阵全部都为0也是这个方程组的一组合法解,

但题目又说了不能全为0,并且保证有解,那么就说明这个方程组并不是唯一解,

所以在跑完高斯消元后,对于那些自由元,我们全部赋值为1,这样就能求出答案了。

还有一个问题,这样做的时间复杂度是 $O((nm)^3)$ 的,

所以需要用bitset优化一下,就可以 $O(\frac{(nm)^3}{32})$ 过了

不过似乎优化了还要慢一些

![](https://cdn.luogu.com.cn/upload/image_hosting/zpf85s1l.png)

代码
```
#include<iostream>
#include<cstdio>
#include<bitset>
using namespace std;

bitset<2005> a[2005];
int n, x, y;

void gauss()
{
    for (int r = 1, l = 1; l <= n; l++)
    {
        int t = r;
        for (int i = r; i <= n; i++)
            if (a[i][l])
                t = i;
        if (!a[t][l])
            continue;
        swap(a[t], a[r]);
        for (int i = r + 1; i <= n; i++)
            if (a[i][l])
                    a[i] = a[i] ^ a[r];
        r++;
    }
    for (int i = n; i >= 1; i--)
    {
        if (!a[i][i])
            a[i][n + 1] = 1;
        else
            for (int j = i + 1; j <= n; j++)
                a[i][n + 1] = a[i][n + 1] ^ (a[i][j] & a[j][n + 1]);
    }
}

int main()
{
    scanf("%d%d", &x, &y);
    n = x * y;
    for (int i = 1; i <= x; i++)
    {
        for (int j = 1; j <= y; j++)
        {
            int p = (i - 1) * y + j;
            int p1 = p - y, p2 = p + y, p3 = p - 1, p4 = p + 1;
            if (i > 1) a[p][p1] = 1;
            if (j > 1) a[p][p3] = 1;
            if (i < x) a[p][p2] = 1;
            if (j < y) a[p][p4] = 1;
            a[p][p] = 1;
        }
    }
    gauss();
    for (int i = 1; i <= n; i++)
    {
        printf("%d ", (a[i][n + 1] ? 1 : 0));
        if (i % y == 0)
            printf("\n");
    }
    return 0;
}
```



---

## 作者：Wens (赞：1)

由题干：“**我们称一个由 $0$ 和 $1$ 组成的矩阵是和谐的，当且仅当每个元素都有偶数个相邻的 $1$。一个元素相邻的元素包括它本身，及他上下左右的 $4$ 个元素（如果存在）。**”我们可以知道，答案要求任何位置上下左右以及自身的 $1$ 的个数为偶数,因为输出都是 $0$ 和 $1$，所以我们可以尝试用位运算解异或方程。那么对于每一个位置，都有：
$$
a[i][j]\oplus a[i-1][j]\oplus a[i][j-1]\oplus a[i+1][j]\oplus a[i][j+1]=0
$$

当然，如果哪一个下标超了界，直接视作 $0$。

**注意：** 要把每一个位置转化为一个确切的数，比如大家都在用的：
$$id=(i-1)*m+j$$

方程都出来了，那么就只要把 $Gause$ 的异或写法板子打了再运行就行了。

样例的结果：
```
0 0 0 0
0 0 0 0
0 0 0 0
0 0 0 0
```

### 这里和其他题解不同：

这时候就有人问了： $Wen$ 老师，发生甚么事了？

哦，原来是每个方程的右侧都是 $0$，异或出来之后解也就都是 $0$ 了，那么我们可以将某一个方程的左侧删掉一个 $a[i][j]$ 同时将右侧的值改成 $1$，这么以来，就可以直接列方程然后输出答案了。

最后由于方程的下标在经过转化之后会有 $(mn)^2$ 这么大，不能直接存布尔值或者用for循环来进行高斯消元，因此要用 $bitset$ 来进行优化

最后附上 AC 代码：
```
#include<bits/stdc++.h>
using namespace std;
const int Maxn=1602;
typedef bitset<Maxn> bi;

inline void Swap(bi &a,bi &b){bi c=a;a=b;b=c;}

inline int Read(){
	int x=0;bool w=0;char ch=0;
	while(!isdigit(ch)){w|=ch=='-';ch=getchar();}
	while(isdigit(ch)){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}
	return w?-x:x;
}

bi a[Maxn];
int n,m,t;
int fx[5]={0,1,-1,0,0};
int fy[5]={0,0,0,-1,1};

inline bool check(int i,int j){
	return i>=1&&i<=n&&j>=1&&j<=m;
}

inline int count(int i,int j){
	return (i-1)*m+j;
}

void Gause(){
	for(int i=1;i<=t;++i){
		int p=i;
		if(!a[i][i]){
			for(int j=i+1;j<=t;++j){
				if(a[j][i]){
					p=j;
					break;
				}
			}
		}
		if(p!=i)Swap(a[i],a[p]);
		for(int j=1;j<=t;++j){
			if(j!=i&&a[j][i]){
				a[j]^=a[i];
			}
		}
	}
	return ;
}

int main(){
	n=Read(),m=Read();
	t=n*m;
	for(int i=1;i<=n;++i){
		for(int j=1;j<=m;++j){
			for(int k=1;k<=4;++k){
				int x=i+fx[k],y=j+fy[k];
				if(check(x,y)){
					a[count(i,j)][count(x,y)]=1;
				}
			}
			a[count(i,j)][count(i,j)]=1;
		}
	}
	a[1][1]=0;
	a[1][t+1]=1;
	Gause();
	for(int i=1;i<=n;++i){
		for(int j=1;j<=m;++j){
			if(a[count(i,j)][t+1])putchar('1');
			else putchar('0');
			putchar(' ');
		}
		putchar('\n');
	}
	return 0;
}
```


---

## 作者：redegg (赞：1)

我们可以列出$n\times m$个异或等式:

$A[x][y]\ xor\ A[x-1][y]\ xor\ A[x][y-1]\ xor\ A[x+1][y]\ xor\ A[x][y+1]=0$

那么我们会发现，我们现在相当于有$n*m$个变量，设其为$x$。

每个等式也$A[i][j]=a[i][j]\times x[i][j]$

相应的，每个等式中其实只涉及了$5$个$A$，那么我们可以把这五个$A$的$a$(也就是系数），设为$1$，其余的$a$为$0$。

那么我就得到了$n\times m$个等式，现在就是要解出$x$

那么很明显高斯消元就可以了，当然复杂度是$O((nm)^3)$。

因为$xor$可以看做是对$2$取余下的加法，所以系数之和也可以看做是系数之间进行异或，那么我们用$bitset$统一运算一整行的系数，就给复杂度除了一个$64$。

接下来，因为不允许全零矩阵，我们就通过将自由元的$x$直接赋值为$1$就可以避免了。

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;

int n,m;
int a[50][50];

bitset<1602> w[1602];

void Guass()
{

    int maxn=n*m;
    for(int i=1;i<=n*m;i++)
    {
        for(int j=i;j<=n*m;j++)
        {
            if(w[j][i]==0)continue;
            swap(w[j],w[i]);
            break;
        }
        if(!w[i][i])
        {
            int mm=i%m;
            if(!mm)mm=m;
            a[(i-1)/m+1][mm]=1;
        }
        for(int j=i+1;j<=n*m;j++)
        {
            if(w[j][i]==0)continue;
            w[j]=w[j]^w[i];
        }
    }
}

void runans()
{
    int ans=0;
    for(int i=n*m;i>=1;i--){
        ans=w[i][n*m+1];
        for(int j=1;j<=n*m;j++){
            int mm=j%m;
            if(mm==0)mm=m;
            ans=ans^(w[i][j]*a[(j-1)/m+1][mm]);
        }
        int mm=i%m;
        if(mm==0)mm=m;
        a[(i-1)/m+1][mm]=1-(ans^w[i][i]);
    }
}

int z[4]={0,1,0,-1};

void init()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        {
            w[(i-1)*m+j][(i-1)*m+j]=1;
            for(int k=0;k<=3;k++)
            {
                int nx=i+z[k];
                int ny=j+z[3-k];
                if(nx<=0||ny<=0||nx>n||ny>m)continue;
                w[(i-1)*m+j][(nx-1)*m+ny]=1;
            }
        }
    }
}

int main()
{
    init();
    Guass();
    runans();
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
            printf("%d ",a[i][j]);
        printf("\n");
    }
    return 0;
}

```


---

## 作者：tommymio (赞：0)

乍一看数据范围感觉写不了，但只要大胆乱搞这题你就会了。

题目中的限制，事实上是对于每个 $x,y$，要求 $A[x+1,y] \oplus A[x-1,y]\oplus A[x,y+1]\oplus A[x,y-1]\oplus A[x,y]=0$。这样的方程一共有 $nm$ 个。我们建立一个二元组 $(x,y)$ 到自然数域的映射 $f:(x,y)\to N_+$，这样就可以直接高斯消元，时间复杂度为 $O((nm)^3)$ 显然过不了。

看上去很假对不对？但是这其实就是正解！我们使用 $\mathrm{bitset}$ 加速，时间复杂度降至 $O(\frac{(nm)^3}{\omega})$。当 $n,m= 40$ 时，约为 $1.28\times 10^8$，可以通过。

所以说，这样的题目，出题人是不是在用脚出题啊（雾

---

## 作者：_ctz (赞：0)

[安利我的$blog$](https://ctz45562.github.io/2019/03/29/%E6%B4%9B%E8%B0%B7-P3164-CQOI2014-%E5%92%8C%E8%B0%90%E7%9F%A9%E9%98%B5/)

[传送门](https://www.luogu.org/problemnew/show/P3164)

每个元素都有偶数个相邻的$1$，就是每个元素和相邻元素异或起来为$0$。

显然可以高斯消元。

把$(i,j)$元素的值设为$x_{i,j}$，就有方程：

$(x_{i,j})\ xor\ (x_{i-1,j})\ xor\ (x_{i+1,j})\ xor\ (x_{i,j-1})\ xor\ (x_{i,j+1})=0 $

当然这个方程组解集不是唯一的。题目中要求不允许答案全$0$矩阵，就把高斯消元中遇到的自由元的值定为$1$，再把剩余方程中含有该自由元的常数$xor$上$1$。异或方程组还可以用$bitset$优化。

时间复杂度：$O(n^3/32)$

代码：

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <cstring>
#include <bitset>

#define poi(x,y) ((x-1)*m+y)
//poi(x,y)将二维坐标转成一个整数

const int dx[5]={0,0,0,1,-1},dy[5]={0,1,-1,0,0};

using namespace std;

inline int read(){
	int x=0,y=0;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')y=1;ch=getchar();}
	while(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
	return y?-x:x;
}
template<typename T>
inline T read(){
	T x=0;
	int y=0;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')y=1;ch=getchar();}
	while(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
	return y?-x:x;
}
int n,N,ans[1605];
//N是总元素个数(n*m)
bitset<1601>a[1605],rec[1605];
void Gauss(){
	for(register int i=1;i<=N;++i){
		int now=i;
		while(!a[now][i]&&now<N)++now;
		if(now!=i)swap(a[now],a[i]);
		if(!a[i][i]){
            //遇到自由元
			a[i][N+1]=1;
            for(register int j=i+1;j<=N;++j)
				a[i][j]=0;
            //常数赋值为1，系数赋值为0，也就是解为1
			for(register int j=i+1;j<=N;++j)
				if(a[j][i])a[j].flip(N+1);
            //该元素的解对其他方程的影响
			continue;
		}
		for(register int j=i+1;j<=N;++j)
			if(a[j][i])a[j]^=a[i];
	}
	for(register int i=N;i;--i){
		ans[i]=a[i][N+1];
		for(register int j=i+1;j<=N;++j)
			if(a[i][j])ans[i]^=ans[j];
	}
}
int main(){
	int n=read(),m=read();
	N=n*m;
	for(register int i=1;i<=n;++i){
		for(register int j=1;j<=m;++j){
			for(register int k=0;k<5;++k){
				int x=i+dx[k],y=j+dy[k];
				if(x<1||x>n||y<1||y>m)continue;
				a[poi(i,j)][poi(x,y)]=1;
			}
		}
	}
	Gauss();
	for(register int i=1;i<=n;++i,pn)
		for(register int j=1;j<=m;++j)
			printf("%d ",ans[poi(i,j)]);
}

```



---


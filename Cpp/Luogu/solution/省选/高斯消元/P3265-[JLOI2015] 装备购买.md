# [JLOI2015] 装备购买

## 题目描述

脸哥最近在玩一款神奇的游戏，这个游戏里有 $n$ 件装备，每件装备有 $m$ 个属性，用向量 $\mathbf{z_i}=(a_1, \ldots ,a_j, \ldots , a_m)$ 表示 ($1 \leq i \leq n, \ 1 \leq j \leq m$)，每个装备需要花费 $c_i$，现在脸哥想买一些装备，但是脸哥很穷，所以总是盘算着怎样才能花尽量少的钱买尽量多的装备。对于脸哥来说，如果一件装备的属性能用购买的其他装备组合出（也就是说脸哥可以利用手上的这些装备组合出这件装备的效果），那么这件装备就没有买的必要了。

严格的定义是，如果脸哥买了 $\mathbf{z_{i_1}}, \ldots , \mathbf{z_{i_p}}$这 $p$ 件装备，那么对于任意待决定的 $\mathbf{z_h}$，不存在 $b_1, \ldots ,b_p$使得 $b_1\mathbf{z_{i_1}} + \ldots + b_p\mathbf{z_{i_p}} = \mathbf{z_h}$
​​ （$b_i$均是实数），那么脸哥就会买 $\mathbf{z_h}$，否则 $\mathbf{z_h}$ 对脸哥就是无用的了，自然不必购买。

举个例子，$\mathbf{z_1}=(1, 2, 3), \ \mathbf{z_2}=(3, 4, 5), \ \mathbf{z_h}=(2, 3, 4), \ b_1 =\frac{1}{2}, \ b_2 =\frac{1}{2}$，就有 $b_1\mathbf{z_1} + b_2\mathbf{z_2} = \mathbf{z_h}$ ，那么如果脸哥买了 $\mathbf{z_1}$和 $\mathbf{z_2}$ 就不会再买 $\mathbf{z_h}$了。

脸哥想要在买下最多数量的装备的情况下花最少的钱，你能帮他算一下吗？

## 说明/提示

如题目中描述，选择装备 $1$ 装备 $2$，装备 $1$ 装备 $3$，装备 $2$ 装备 $3$ 均可，但选择装备 $1$ 和装备 $2$ 的花费最小，为 $2$。

对于 $100\%$ 的数据 $,1 \le n,m \le 500$，$0 \le a_j \le 1000$。

## 样例 #1

### 输入

```
3 3
1 2 3
3 4 5
2 3 4
1 1 2```

### 输出

```
2 2```

# 题解

## 作者：荣一鸣 (赞：29)

我们遇见的普通线性基（如模板题），都是在有关2进制与其异或和上用的

而这里用的是实数的线性基，在学实数的线性基之前，必须知道高斯消元的原理（因为我学线性基的时候没学高斯消元！！！）

那么我先讲一下为什么用高斯消元。


我们可以看到，如果物品aj可以用a1....aj-1组合而出的话，我们可以通过公式得到

	k1*a1.x1+k2*a2.x1+k3*a3.x1+...+kj-1*aj-1.x1=aj.x1
    k1*a1.x2+k2*a2.x2+k3*a3.x2+...+kj-1*aj-1.x2=aj.x2
    ......
    k1*a1.xm+k2*a2.xm+k3.a3.xm+...+kj-1*aj-1.xm=aj.xm
    
我们就是要求出是否有这样的一组k使得上述等式成立

至于求解，我们可以用高斯消元。

但是由于这样做太过于麻烦，所以我们要结合线性基

假如我们将每个物品的属性看作向量，那么，我们要求的就是其中的一组基（如果一个物品可以通过其他的物品组合而成，那么它就不能是基的一部分）

我们上面的等式转化一下变成下面的

	a1.x1,a1.x2,a1.x3...a1.xm ........1
    a2.x1,a2.x2,a2.x3...a2.xm ........2
    a3.x1,a3.x2,a3.x3...a3.xm ........3
    ...
    aj.x1,aj.x2,aj.x3...aj.xm ........4
    
我们如果用高斯消元，用第一行的x1消去下面所有行的x1

然后用第二行剩下的x2（如果x2没有的话可以换一下行）,然后把剩下的行的x2消去

.....

如果消到最后，剩下的j所有项为0，那么aj就可以不选了。

多么愉快的是用高斯消元就行了！

这里就不讲高斯消元了

如果在消过元后有一个位置不是0，那么它就可以作为第i位的基（可以这么说吗？）

剩下的就是贪心了

下面就是代码，结合上面理解一下

```
#include<bits/stdc++.h>
#define cmp 1e-5
using namespace std;
struct node{
	double a[510];
	int w;
	bool operator <(const node x) const{
		return w<x.w;
	}
};
node q[510];
int p[510],n,m,ans,cnt;
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			scanf("%lfd",&q[i].a[j]);
	for(int i=1;i<=n;i++) scanf("%d",&q[i].w);
	sort(q+1,q+n+1);
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if(q[i].a[j]<=cmp&&q[i].a[j]>=-cmp) continue;
			if(!p[j]){
				p[j]=i;
				cnt++;ans+=q[i].w;
				break;
			}
			else{
				double alpha=q[i].a[j]/q[p[j]].a[j];
				for(int k=j;k<=m;k++){
					q[i].a[k]-=alpha*q[p[j]].a[k];
				}
			}
		}
	}
	printf("%d %d",cnt,ans);
}
```

---

## 作者：消失的海岸线 (赞：15)

人话题意：$n$ 个装备，每个装备 $m$ 个属性，每个装备还有个价格。如果手里有的装备的每一项属性为它们分配系数（实数）后可以相加得到某件装备，则不必要买这件装备。求最多装备下的最小花费。


###线性相关

在向量空间 $V$ 的一组向量 $A$，如果存在不全为零的数 $k1,k2,···,km$ ，使得

$k_{1}a_{1}+k_{2}a_{2}$+...+k\_{m}a\_{m}=b$

则称向量组A是线性相关的


###人话线性相关

一组数据中有一个或者多个量可以被其余量表示。


所以题面显然就是线性相关的定义，直接上实数下的线性基即可。貌似卡精度

代码如下：

```cpp
#include <cmath>
#include <queue>
#include <cstdio>
#include <iomanip>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <algorithm>
#define N 510
#define eps 1e-6
#define double long double
#define ll long long
using namespace std;
inline int read() 
{ 
    int x=0,f=1;char ch=getchar(); 
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();} 
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();} 
    return x*f; 
}
struct zgz
{
    int cost;
    double x[N];
}a[N];
bool cmp(zgz a,zgz b)
{return a.cost<b.cost;}
int cnt,sum,p[N],n,m;
int main()
{
    n=read(),m=read();
    for(int i=1;i<=n;i++)
    for(int j=1;j<=m;j++)
    scanf("%Lf",&a[i].x[j]);
    for(int i=1;i<=n;i++)
    a[i].cost=read();
    sort(a+1,a+n+1,cmp);
    for(int i=1;i<=n;i++)
    for(int j=1;j<=m;j++)
    if(fabs(a[i].x[j])>eps)
    {
        if(!p[j])
        {
            p[j]=i;
            cnt++,sum+=a[i].cost;
            break;
        }
        else
        {
            double t=a[i].x[j]/a[p[j]].x[j];
            for(int k=j;k<=m;k++)
            a[i].x[k]-=a[p[j]].x[k]*t;
        }
    }
    printf("%d %d\n",cnt,sum);
}
```
一些其他的线性基相关题目可以在个人博客中找到：

http://www.zgz233.xyz/2017/07/05/bzoj-4004-jloi2015%E8%A3%85%E5%A4%87%E8%B4%AD%E4%B9%B0/


---

## 作者：jun头吉吉 (赞：14)

## 真·【模板】·线性基
#### 一句话题意:选出最多向量，使其线性无关并价值最小
~~应该做到这一题的人都会写异或线性基了吧（逃~~

看到这道题，我最先想到的就是[P4570 [BJWC2011]元素](https://www.luogu.com.cn/problem/P4570)。这两道题有些~~谜之~~相似，都是要求某种神仙操作后的最值，只不过把整数换成了向量，把异或操作换成了两种运算：

- 向量加法 $a+b$，$a$、$b$均为向量
- 标量乘法 $a\times k$，$a$为向量，$k$为实数

最后，一个是希望异或和不为$0$,另一个为向量为$0$。~~是不是很像呀~~

于是我们可以类比异或线性基的构造方法：

用$p_i$表示线性基数组最高位为第$i$位的向量

在异或线性基中，我们可以这样把最高位消掉：
```cpp
void insert(long long x){
	for(int i=max_wei-1;i>=0;i--){
		if(!((x>>i)&1))continue;
		if(!b[i]){b[i]=x;return;}
		x^=b[i];
	}
}
```
在实数线性基中，我们通过加和乘把最高位消掉：
$$c'=c-\frac {c_i}{(p_i)_i} \times p_i$$

很显然，经过这样的操作，最高位什么的就没了

于是，就可以照着**异或线性基**把模板打出来了
```cpp
void insert(Vector c){
	for(int i=m-1;i>=0;i--) {
		if(c[i]==0)continue;
		if(b[i][i]==0){b[i]=c;return true;}
		long double t=c.a[i]/b[i][i];
		c=c-b[i]*t;
	}
}
```
于是，我们把装备按价值升序排个序，再依次插入线性基就OK了

众所周知，**C++** 对实数十分不友好 ~~一不小心就爆精度~~，因此运算的时候一定要小心，比如：
$$c'=\frac {(p_i)_i}{c_i} \times c- p_i$$

在数学的角度上，无疑是正确的，但在写的过程中会爆

#### 上DM
```cpp
#pragma optimize(2)
#include<bits/stdc++.h>
using namespace std;
template<typename T>
inline void read(T &x){
	x=0;char c=getchar();bool f=false;
	for(;!isdigit(c);c=getchar())f!=c=='-';
	for(;isdigit(c);c=getchar())x=x*10+c-'0';
	if(f)x=-x;
}
template<typename T ,typename ...Arg>
inline void read(T &x,Arg &...args){
	read(x);read(args...);
}
template<typename T>
inline void write(T x){
	if(x<0)putchar('-'),x=-x;
	if(x>=10)write(x/10);
	putchar(x%10+'0');
}
const int max_wei=700;
const long double eps=1e-5; 
int n,m,num=0,cost=0;;
template<class T>
struct Vector{
	T a[max_wei];
	void init(){for(int i=0;i<m;i++)a[i]=0;}
	Vector operator+(const Vector b)const{
		Vector<T> c;c.init();for(int i=0;i<m;i++)
		c.a[i]=a[i]+b.a[i];return c;
	}
	Vector operator-(const Vector b)const{
		Vector<T> c;c.init();for(int i=0;i<m;i++)
		c.a[i]=a[i]-b.a[i];return c;
	}
	Vector operator*(T x)const{
		Vector<T> c;c.init();for(int i=0;i<m;i++)
		c.a[i]=a[i]*x;return c;
	}
};
struct Leaner_Basis{
	Vector<long double>b[max_wei];
	bool insert(Vector<long double> c){//将向量c插入线性基 并返回能否插入 
		for(int i=m-1;i>=0;i--) {
			if(abs(c.a[i])<eps)continue;
			if(abs(b[i].a[i])<eps){b[i]=c;return true;}
			long double t=c.a[i]/b[i].a[i];
			c=c-b[i]*t;
		} 
		return false;
	}
}B;
struct node{
	int cost;
	Vector<long double>c;
	bool operator<(const node b)const{
	return cost<b.cost;}
}a[500+10];
signed main(){
	//freopen("buy.in","r",stdin);
	//freopen("buy.out","w",stdout);
	read(n,m);
	for(int i=1;i<=n;i++)
		for(int j=0;j<m;j++)
			read(a[i].c.a[j]);
	for(int i=1;i<=n;i++)
		read(a[i].cost);
	sort(a+1,a+1+n);
	for(int i=1;i<=n;i++)
		if(B.insert(a[i].c))
			num++,cost+=a[i].cost;
	printf("%d %d",num,cost);
}
```


---

## 作者：Adove (赞：11)

关于精度问题

在模质数意义下进行高斯消元即可

除法换成逆元

虽然常数大了些，但并不影响时间复杂度

事实上，这种方法如果质数选得太小，可能会造成一些情况误判

所以我们通常选择$p>\max\{v^2\}$的质数

```cpp
#include"cstdio"
#include"cstring"
#include"iostream"
#include"algorithm"
#include"cmath"
using namespace std;

const int MAXN=505;
const int MOD=19260817;

int n,m,cnt,sum;
struct rpg{
	int v[MAXN],val;
}a[MAXN],lb[MAXN];

bool cmp(rpg a,rpg b){return a.val<b.val;}

int getinv(int x){return x==1?1:(long long)(MOD-MOD/x)*getinv(MOD%x)%MOD;}

int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;++i){
		for(int j=1;j<=m;++j){
			scanf("%d",&a[i].v[j]);
		}
	}for(int i=1;i<=n;++i) scanf("%d",&a[i].val);
	sort(a+1,a+n+1,cmp);
	for(int i=1;i<=n;++i){
		for(int j=1;j<=m;++j){
			if(!a[i].v[j]) continue;
			if(!lb[j].val){lb[j]=a[i];lb[j].val=1;sum+=a[i].val;++cnt;break;}
			int tmp=(long long)a[i].v[j]*getinv(lb[j].v[j])%MOD;
			for(int k=m;k>=j;--k) a[i].v[k]-=(long long)lb[j].v[k]*tmp%MOD,a[i].v[k]%=MOD;
		}
	}printf("%d %d\n",cnt,sum);
	return 0;
}
```

---

## 作者：hl666 (赞：11)

一道真正意义下的**线性基**裸题

平时我们说的关于线性基在OI中主要针对二进制下的，而这里的线性基回归了本源，是关于向量的线性基

我们考虑二进制下线性基的算法，它主要就是将数分解成许多个二进制位

然后在每一位的放入对应的数来消去后面的数，主要用的是**异或**

而关于向量的呢，我们考虑在向量的每一位放入对应的向量，然后用当前的这一位去消去之后的这一位

那么具体怎么操作呢，其实就是个**高斯消元**的过程，因此我们就类比得出了一般线性基的构造方式

然后对于这题，我们可以想到**贪心**地把装备按价值从小到大加入，因为若存在一组向量线性相关，那么肯定是删去较大的那个才会更优

因此这题就做完了，注意精度会有点卡，建议开```long double```

CODE

```cpp
#include<cstdio>
#include<cmath>
#include<algorithm>
#define RI register int
#define CI const int&
using namespace std;
const int N=505;
const long double EPS=1e-6;
struct data
{
    long double mat[N]; int val;
    inline long double& operator [] (CI x) { return mat[x]; }
    friend inline bool operator < (const data& A,const data& B)
    {
        return A.val<B.val;
    }
}a[N]; int n,m,p[N],ans1,ans2;
int main()
{
    RI i,j,k; for (scanf("%d%d",&n,&m),i=1;i<=n;++i)
    for (j=1;j<=m;++j) scanf("%Lf",&a[i][j]);
    for (i=1;i<=n;++i) scanf("%d",&a[i].val);
    for (sort(a+1,a+n+1),i=1;i<=n;++i) for (j=1;j<=m;++j)
    {
        if (fabs(a[i][j])<EPS) continue;
        if (!p[j]) { p[j]=i; ++ans1; ans2+=a[i].val; break; }
        double dv=1.0*a[i][j]/a[p[j]][j];
        for (k=j;k<=m;++k) a[i][k]-=dv*a[p[j]][k];
    }
    return printf("%d %d",ans1,ans2),0;
}
```



---

## 作者：konjacq (赞：6)

**~~本文同步发表于窝的个人博客~~和那边文章结构差别太大了(因为那边会有单独一篇讲拟阵)所以只放一个[到主页的链接](http://39.107.58.77/)就是了.**

## 定义

### 拟阵

定义一个拟阵是二元组$(S,L)$满足

- $S$是一个**有限集**;
- $L$是一个**非空有限集**,其元素是$S$的部分子集;
- 遗传性:$\forall A\subseteq B\in L$一定有$A\in L$;
- 交换性:$\forall A,B\in L,|A|<|B|$都有$\exists x\in B-A$(即存在$x\in B$但$x\not\in A$)满足$A\cup\{x\}\in L$.

#### 举例

比如,$(\{1,2,3,4\},\{\varnothing,\{1\},\{1,2\},\{1,2,3\},\{1,3\},\{2\},\{2,3\},\{3\}\})$是一个拟阵,因为

- 显然满足前两条性质;
- 观察发现满足遗传性,比如对于$\{1,3\}\in L$的子集$\varnothing$和$\{1\}$和$\{3\}$也都在$L$中;
- 观察发现满足交换性,比如对于$A=\{1,3\}$且$B=\{1,2,3\}$显然可以找到$x=2$满足$x\in B-A$且$A\cup\{x\}=\{1,2,3\}\in L$.

加深一下理解,$L$是$S$子集的集合(也就是元素是集合的集合),在遗传性中的$A$和$B$也都是$S$子集的集合;而在交换性中$A$和$B$是$S$的子集(也就是其中的元素就是$S$中的元素).所以注意观察大括号数量.

### 独立集

- 对于集合$U\subseteq S$且$U\in L$称$U$为**独立集**;
- 对于独立集$U$存在$x\in S$满足$x\not\in U$且$U\cup\{x\}\in L$则称$U$是**可扩展的**,称$x$是$U$的一个扩展;
- 称一个不可扩展的独立集$U$为最大独立集;

可知拟阵最大独立集大小相同.证明:设$A$与$B$是两个最大独立集,不妨设$|A|<|B|$由拟阵的交换性有$A$一定是可扩展的,不是最大独立集,与假设矛盾.

### 加权拟阵

加入一个权重函数$w(a)>0$表示$a$元素的权重,定义集合权重为$w(A)=\sum_{a\in A}w(a)$.现在我们希望对于这样的加权拟阵求出一个独立集$A$满足$w(A)$最大化,称$A$为最优子集.

容易发现$A$一定是最大独立集(因为$w(a)$是正数,故显然能多加进来一个会更优).sh

## 拟阵贪心

拟阵贪心就是要求出最优子集.

### 策略

```
/*这个函数返回一个最优子集*/
function set solve(M,w) /*拟阵和权重函数*/
	A←空集
	将M.S按权重排序
	for x属于M.S do
		if A并上{x}属于M.L
			A←A并上{x}
		end if
	end for
	return A
end function
```

### 正确性证明

对于拟阵$M=(S,L)$若$A$为其最优子集$T$的子集,元素$a$是集合$\{x|A\cup\{x\}\in L\}$中的权重最大元素,则$A'=A\cup\{a\}\subseteq T$.

证明:假设$A'\not\in T$则令$T'=T$.由矩阵的交换性知若$|T|>|T'|$一定存在$t\in T-T'$满足$T'\cup\{t\}\in L$.所以不断令$T'\leftarrow T'\cup\{t\}$直到$|T|=|T'|$且此时应有$T=(T'-\{a\})\cup\{t\}$.但是由条件$w(a)\ge w(t)$推出$w(T)=w(T')-w(a)+w(t)\le w(T')$说明$T$不是最优子集,与假设矛盾.

这样就证明了每一次并上剩下元素中最大的一定是最优解,并且最开始$A=\varnothing$显然属于$T$,故贪心策略正确.

### 复杂度分析

假设总共有$n$个元素,一个排序$n\lg n$,一个贪心$n$,判断独立集$t$,加起来就是$\Theta(n\lg n+nt)$,具体到这道题就是$n^3$(向量维度同阶).

## 构造拟阵

接下来就是要针对这道题构造一个拟阵来进行贪心.

设$S$为全部装备的集合,$L$为满足条件的子集(其中装备全部向量无关)的集合.证明$(S,L)$是一个拟阵因为其满足

- 前两条性质,显然;
- 遗传性:如果更多的装备向量无关,则从中去掉一部分剩下的显然仍然向量无关;
- 交换性:对于$A,B\in L$且$|A|<|B|$假设不存在$x\in B-A$则表示$B$中的元素都可以用$A$中的元素表示出来,但又因为$|A|<|B|$且$A$和$B$当中元素分别线性无关,推出矛盾.

构造权重函数$w(i)=x-c_i$,其中$x$满足$x>\max\{c_i\}$.这个$w$是一个合法的权重函数因为显然为正,最后得到的最优子集$A$的权重$w(A)=|A|x-\sum_{a\in A}w(a)$.最大化$w(A)$就是要最小化$\sum_{a\in A}c_a$,符合题设.

这样就证明了贪心的正确性,至于具体实现其它题解已经说得很清楚了这里就不再赘述,仅给出代码以供参考.

## Code

```cpp
#include <algorithm>
#include <cstdio>
using namespace std;

const double eps=0.0001;
struct bxt {
	int c; double a[505];
	bool operator <(const bxt &op) const {
		return c<op.c;
	}
};

int main() {
	static int b[505];
	static bxt z[505];
	int n,m,p=0,q=0; double w;
	scanf("%d%d",&n,&m);
	for (int i=0;i<n;++i) for (int j=0;j<m;++j)
		scanf("%lf",&z[i].a[j]);
	for (int i=0;i<n;++i) scanf("%d",&z[i].c);
	sort(z,z+n);
	for (int i=0;i<n;++i) for (int j=0;j<m;++j) {
		if (z[i].a[j]>-eps&&z[i].a[j]<eps) continue;
		else if (!b[j]) {b[j]=i+1; ++p; q+=z[i].c; break;}
		else {
			w=z[i].a[j]/z[b[j]-1].a[j];
			for (int k=j;k<m;++k)
				z[i].a[k]-=w*z[b[j]-1].a[k];
		}
	}
	printf("%d %d",p,q);
	return 0;
}
```

---

## 作者：Rainybunny (赞：4)

# 题目
&emsp;&emsp;[luogu](https://www.luogu.com.cn/problem/P3265).  
# 题解
&emsp;&emsp;~~为了水咕值被迫营业qwq。~~  
&emsp;&emsp;首先，对于题目中所描述的“能被组合出的装备没有用”其实就是要求这些装备的属性向量**线性不相关**。  
&emsp;&emsp;于是乎，这就是一道经典的~~拟阵~~贪心题了。
## 算法
&emsp;&emsp;贪心，按费用不减的顺序枚举每个装备，并维护一个 $m$ 维的线性基。若该装备的属性向量能够加入线性基，则表明它与已选择的属性向量线性不相关（可以类比异或线性基），就要选择该装备。
## 线性基
&emsp;&emsp;~~OIer 不和实数玩。~~  
&emsp;&emsp;首先，回忆一下 OI 常见的[异或线性基](https://www.luogu.com.cn/problem/P3812)。  
&emsp;&emsp;类似于异或线性基的插入方式，我们钦定 $x_1$ 为“最高位”， $x_m$ 为“最低位”。于是从高位到低位检查，若线性基中第 $i$ 个位置为空，则插入 $\{x_m\}$ 到该位置，插入成功；否则，用高斯消元的思想，利用线性基中已有的向量将 $x_i$ 消为 $0$，继续检查，直到插入成功或者检查完所有位置，表明该向量和已有向量线性相关。
## 正确性证明
&emsp;&emsp;可跳过。~~OIer 也不需要证明算法。~~  
&emsp;&emsp;令子集系统 $M=(S,I)$，其中：
$$S=\{\boldsymbol z_n\}$$
&emsp;&emsp;即全体向量组成的集合。
$$I=\{T~|~T\subseteq S~\wedge~T~\text{中的向量线性不相关}\}$$
&emsp;&emsp;“线性不相关”就是我们规定的集合独立性。现在只需要证明 $M$ 是一个拟阵。  
### 遗传性证明
&emsp;&emsp;要证：
$$
(\forall A\subseteq B,B\in L)~A\in L
$$
&emsp;&emsp;~~显然。~~ 考虑反证，若 $A\not\in L$，则表明 $A$ 中的向量线性相关。即存在 $\boldsymbol z\in A$ 使得 $\boldsymbol z$ 能够通过 $A-\{\boldsymbol z\}$ 中的向量线性变换得到。因为 $A\subseteq B$，所以 $\boldsymbol z\in B,(A-\{\boldsymbol z\})\subseteq B$，因此 $B$ 独立性（其中向量线性相关），但 $B\in L$，矛盾。
### 交换性证明
&emsp;&emsp;要证：
$$
(\forall A,B\in L,|A|<|B|)(\exists \boldsymbol z\in B-A)~A\cup\{\boldsymbol z\}\in L
$$
&emsp;&emsp;~~自从看了离散数学之后公式写出来就很鬼畜ovo。~~  
&emsp;&emsp;设三个集合 $A'=A-B$，$U=A\bigcap B$，$B'=B-A$。（脑补一个韦恩图w。）  
&emsp;&emsp;相当于要证明，存在一个 $\boldsymbol z\in B'$，使得 $\boldsymbol z$ 与 $A$ 中的向量线性无关。由于 $A=A'\bigcup U,B=B'\bigcup U$，故只需保证 $\boldsymbol z$ 与 $A'$ 中的向量线性无关。  
&emsp;&emsp;接着，考虑到 $|A|<|B|\Rightarrow |A'|<|B'|$，且 $B'$ 的向量线性无关，类似于多元方程组有唯一解至少需要变元个数个方程，故 $\boldsymbol z$ 的存在性已证。  

&emsp;&emsp;综上，$M$ 是拟阵。~~接下来只需要反手贪心拍上去就OK。~~
## 代码
```cpp
#include <cstdio>
#include <algorithm>

typedef long double LD;

const int MAXN = 500;
constexpr LD EPS = 1e-6;
int n, m;

struct Equipment {
	int cost;
	LD x[MAXN + 5];
	inline bool operator < ( const Equipment t ) const { return cost < t.cost; }
} equ[MAXN + 5];

inline LD abs_ ( const LD x ) { return x < 0 ? -x : x; }

class RealLinearBasic {
private:
	LD basic[MAXN + 5][MAXN + 5];

public:
	inline bool insert ( LD* x ) {
		for ( int i = 1; i <= m; ++ i ) {
			if ( abs_ ( x[i] ) < EPS ) continue;
			if ( abs_ ( basic[i][i] ) < EPS ) {
				for ( int j = i; j <= m; ++ j ) basic[i][j] = x[j];
				return true;
			}
			double k = x[i] / basic[i][i];
			for ( int j = i; j <= m; ++ j ) x[j] -= k * basic[i][j];
		}
		return false;
	}
} rlb;

int main () {
	scanf ( "%d %d", &n, &m );
	for ( int i = 1; i <= n; ++ i ) {
		for ( int j = 1; j <= m; ++ j ) {
			scanf ( "%Lf", &equ[i].x[j] );
		}
	}
	for ( int i = 1; i <= n; ++ i ) scanf ( "%d", &equ[i].cost );
	std :: sort ( equ + 1, equ + n + 1 );
	int cnt = 0, cst = 0;
	for ( int i = 1; i <= n; ++ i ) {
		if ( rlb.insert ( equ[i].x ) ) {
			++ cnt, cst += equ[i].cost;
		}
	}
	printf ( "%d %d\n", cnt, cst );
	return 0;
}
```

---

## 作者：chenxia25 (赞：4)

## P3265 - 装备购买

给 $n$ 个 $m$ 维向量，每个向量有一个权值，求最多可以选多少个线性无关向量，以及极大线性无关组的权值和最小是多少。

初等行变换不改变列的线性相关性，这是好的。考虑观察高斯消元之后的向量们，是等价的。

注意到高斯消元天然地选择列号字典序最小的一组基作为主元列。一个猜想是，将列们按照 cost 排序，那么高斯消元选择的是权值和最小的基。这看起来是显然的，实则不显然，因为字典序最小不代表权值和最小，可能出现 $a_1+a_4>a_2+a_3$ 的情况。考虑证明一下此处字典序最小确实是总权值最小。

观察行等价简化阶梯型的列们，设主元列序号是 $i_{1\sim s}$，有 $\pmb a_{i_j}=\pmb e_j$，令 $i_{s+1}=n+1$，那么将列分为 $\{[i_j,i_{j+1})\}$ 这些连续段，那么第 $j$ 段是只有前 $j$ 行才可能非零。那么前 $j$ 段组成的向量组的秩显然为 $j$，$j+1$ 行下面全是 $0$ 了都，于是前 $j$ 段最多能选出 $j$ 个线性无关向量，那么选出的第 $j$ 个的位置肯定不在 $i_j$ 前面（不然不可能实现在前 $j-1$ 段这个 $\mathrm{rank}=j-1$ 的向量组里面选 $j$ 个线性无关向量），那么正确性就显然了吧（因为每个位置都选了理论最前位置）。



---

## 作者：crashed (赞：3)

&emsp;&emsp;[戳这里](https://www.cnblogs.com/crashed/p/12742251.html)获得更好的阅读体验。
# 题目
&emsp;&emsp;[点这里](https://www.luogu.com.cn/problem/P3265)看题目。  
# 分析
&emsp;&emsp;可以发现，一组装备可以同时购买的条件是**这组装备线性无关**。  
&emsp;&emsp;首先不难发现一个拟阵$M=<S,I>$，其中：  
&emsp;&emsp;$S$为装备的集合；如果$A\subseteq S$，那么$A\in I$当且仅当$A$内的元素线性无关。  
&emsp;&emsp;显然$M$是一个子集系统，考虑一下它的交换性：  
&emsp;&emsp;对于$A,B\in I$，如果$|A|<|B|$，我们需要证明$\exists x\in B-A, A\cup \{x\}\in I$，即新的集合仍然线性无关。  
&emsp;&emsp;考虑反证法，即假设不存在这样的$x$。这意味着$\forall x\in B-A$，$x$都可以在$A$中表示出来。那么$B$中的元素都可以在$A$中表示出来。这意味着$B$的线性空间包含在$A$的线性空间内。由于$|A|<|B|$且$A,B$各自线性无关，矛盾。因此存在交换性。  
&emsp;&emsp;因此这是一个拟阵。我们就可以按照装备的花费，维护线性无关组，从小到大进行贪心。  
&emsp;&emsp;怎么维护线性无关组呢？  
&emsp;&emsp;如果每次检查都用高斯消元，时间会被卡到$O(n^4)$，当然是不可以的。  
&emsp;&emsp;我们一个常用于维护线性无关组的结构——线性基。  
&emsp;&emsp;考虑魔改线性基。我们将向量看成 “ $x$ 进制 ” 的数。插入向量$\boldsymbol z$的时候，在$x_i$位上，如果没有元素就插入$z$；否则我们用线性基上的元素，将$\boldsymbol z$上的$x_i$的系数消成 0 。对于一个向量，如果可以插入到线性基中，就说明它加入后组内仍然是线性无关的，需要计入答案。  
&emsp;&emsp;时间$O(n^3)$。  
# 代码
```cpp
#include <cstdio>
#include <algorithm>

#define spawn vector ret = vector()
#define rush for( int i = 1 ; i <= M ; i ++ )
#define op( c ) vector operator c ( vector b ) const { spawn; rush ret[i] = vec[i] c b[i]; return ret; }
#define reop( c ) void operator c##= ( vector b ) { *this = *this c b; } 

const double eps = 1e-4;
const int MAXN = 505, MAXM = 505;

template<typename _T>
void read( _T &x )
{
	x = 0;char s = getchar();int f = 1;
	while( s > '9' || s < '0' ){if( s == '-' ) f = -1; s = getchar();}
	while( s >= '0' && s <= '9' ){x = ( x << 3 ) + ( x << 1 ) + ( s - '0' ), s = getchar();}
	x *= f;
}

template<typename _T>
void write( _T x )
{
	if( x < 0 ){ putchar( '-' ); x = ( ~ x ) + 1; }
	if( 9 < x ){ write( x / 10 ); }
	putchar( x % 10 + '0' );
}

template<typename _T>
_T ABS( _T x )
{
	return x < 0 ? -x : x;
}

int cost[MAXN], seq[MAXN];
int N, M;
bool taken[MAXM];

struct vector
{
	double vec[MAXN];
	vector() { for( int i = 0 ; i < MAXM ; i ++ ) vec[i] = 0; }
	double& operator [] ( const int indx ) { return vec[indx]; }
	op( + ) op( - ) reop( + ) reop( - )
	vector operator * ( const double &b ) const { spawn; rush ret[i] = vec[i] * b; return ret; }
};

vector base[MAXM], z[MAXN];

bool cmp( const int &x, const int &y ) { return cost[x] < cost[y]; }
bool equal( const double a, const double b = 0 ) { return ABS( a - b ) <= eps; }

bool insert( const int indx )
{
	double coe;
	for( int i = 1 ; i <= M ; i ++ )
		if( ! equal( z[indx][i] ) )
		{
			if( ! taken[i] ) { taken[i] = true, base[i] = z[indx]; return true; }
			coe = z[indx][i] / base[i][i];
			z[indx] -= base[i] * coe;
		}
	return false;
}

int main()
{
	int v, ans = 0, tot = 0;
	read( N ), read( M );
	for( int i = 1 ; i <= N ; i ++ )
		for( int j = 1 ; j <= M ; j ++ )
			read( v ), z[i][j] = v;
	for( int i = 1 ; i <= N ; i ++ ) read( cost[i] ), seq[i] = i;
	std :: sort( seq + 1, seq + 1 + N, cmp );
	for( int i = 1 ; i <= N ; i ++ )
		if( insert( seq[i] ) )
			tot ++, ans += cost[seq[i]];
	write( tot ), putchar( ' ' ), write( ans ), putchar( '\n' );
	return 0;
}
```

---

## 作者：pyyyyyy (赞：3)

#### 写在前面

线性基的水题~~竟然是紫题~~，可怜我高中的向量基础网课漏听了几节，导致昨天看了一天都没看懂，淦

#### 思路

把$n$件装备看成$n$个长度为$m$的向量，根据题目意思，购买的**向量线性无关**的（如果线性相关就不会去购买了）,题目要求我们求出该线性空间的基

可以把$a_{i,j}$看成系数矩阵，每个装备$z_i$即为一个行向量，用高斯消元求出行秩就是最少购买的装备数量

最少花的钱可以用**贪心**来求解:

对于每一个主元$x_i$,在前$i-1$列为$0$，第$i$ 列不为$0$的行向量中，选出价格最低的去消元

**证明**：~~应该不用写了~~

设花钱最少的基为$z[i_1],z[i_2],……z[i_p]$该基内不包含价格最低的行向量$z[k]$

因为极大线性不相关子集，所以$z[k]$一定可以被上述基表出

可设:$z[k]=b_1z[i_1]+b_2z[i_2]+……b_pz[i_p]$

化简得:$z[i_p]=(z[k]-b_1z[i_1]-……b_{p-1}z[i_{p-1}])/b_p$

显然$z[i_p]$能被上面的基表出，即上述基与一开始设出的基相同，但是上述基总价格更小

证毕


```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=520;//淦 
long double a[N][N],eps=1e-8;
int n,m,w[N];
int dim,ans;
int main()
{
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	cin>>n>>m;
	for(int i=1;i<=n;++i){
		for(int j=1;j<=m;++j){
			double x;
			scanf("%lf",&x);
			a[i][j]=x;
		}
	}
	for(int i=1;i<=n;++i)
	{
		int val;
		scanf("%d",&val);
		w[i]=val;
	}
	for(int i=1;i<=m;++i)
	{
		int now=0;
		for(int j=dim+1;j<=n;++j)
			if(fabs(a[j][i])>eps&&(now==0||w[j]<w[now])) 
				now=j;
		if(now==0) continue;
		++dim;ans+=w[now];
		for(int j=1;j<=m;++j) swap(a[now][j],a[dim][j]);
		swap(w[now],w[dim]);
		for(int j=1;j<=n;++j) 
		{
			if(dim!=j&&fabs(a[j][i])>eps)
			{
				long double rate=a[j][i]/a[dim][i];
				for(int k=i;k<=m;++k) a[j][k]-=rate*a[dim][k];	
			} 
		}
	}
	cout<<dim<<" "<<ans;
	return 0;
}


```


---

## 作者：Others (赞：3)

可以作为线性基的模板来做。

# 前置知识：

做过高斯消元就行。

# Solution

我的理解是把线性基当成**消不完的高斯消元**，讲一下实现步骤：

假设我们在处理第 $i$ 个物品，第 $j$ 个属性（因为每个属性可能消完，所以每个元素要**物尽其用**，故元素编号和属性编号可能不一样）。

1. 找到物品 $i$ 到 $n$ 中第 $j$ 个属性不为零的且花费最小的，和第 $i$ 个物品交换，如果找不到就到下一个属性。

2. 对于物品 $i+1$ 到 $n$，用第 $i$ 个物品消去其第 $j$ 个属性。

3. 统计答案。

**一定要控制精度！！！**

**Code**

```cpp
#include <bits/stdc++.h>
using namespace std;
const double eps=1e-5;
int n,m,c[505],cnt,ans;
double a[505][505];
int main() {
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++) 
		for(int j=1;j<=m;j++) 
			scanf("%lf",&a[i][j]);
	for(int i=1;i<=n;i++) 
		scanf("%d",&c[i]);
	for(int i=1,j=1;i<=m&&j<=n;i++,j++) {//i:ÊôÐÔ j:ÎïÆ· 
		int Min=2147483647,Minx=-1;
		for(int k=j;k<=n;k++) 
			if(fabs(a[k][i])>eps&&c[k]<Min) 
				Min=c[k],Minx=k;
		if(!~Minx) {
			j--;continue;
		}
		for(int k=i;k<=m;k++) 
			swap(a[j][k],a[Minx][k]);
		swap(c[j],c[Minx]);
		for(int k=j+1;k<=n;k++) {
			double div=a[k][i]/a[j][i];
			for(int l=i;l<=m;l++) 
				a[k][l]-=a[j][l]*div;
		}
	}
	for(int i=1;i<=n;i++) {
		bool flag=0;
		for(int j=1;j<=m;j++) 
			if(fabs(a[i][j])>eps) {
				flag=1;
				break;
			}
		cnt+=flag,ans+=flag*c[i];
	}
	printf("%d %d",cnt,ans);
	return 0;
}
```

---

## 作者：huayucaiji (赞：2)

这个题不就是线性基？

我们发现这个装备和异或有着相同之处。比如说：

$$k_1\times z_1+k_2\times z_2=z_3$$

那么：

$$z_1=\frac{z_3-k_2\times z_2}{k_1}$$

因此我们可以先按花费排序，依次放到线性基里。放入的过程中我们和模板差不多，就是把每一位挨个消掉，有点像高斯消元。

用 `double` 精度没问题。

```cpp
//Don't act like a loser.
//This code is written by huayucaiji
//You can only use the code for studying or finding mistakes
//Or,you'll be punished by Sakyamuni!!!
#include<bits/stdc++.h>
#define int long long
using namespace std;

int read() {
	char ch=getchar();
	int f=1,x=0;
	while(ch<'0'||ch>'9') {
		if(ch=='-')
			f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9') {
		x=x*10+ch-'0';
		ch=getchar();
	}
	return f*x;
}

const int MAXN=500+10;
const long double eps=1e-6;

int n,m,cnt;

struct item {
	long double a[MAXN];
	int cost;
}it[MAXN],p[MAXN];

bool cmp(item x,item y) {
	return x.cost<y.cost;
}

void insert(item x) {
	item xx=x;
	int mark=-1,minn=1e9+10;
	for(int i=m;i;i--) {
		if(fabs(x.a[i])<eps) {
			continue;
		}
		if(fabs(p[i].a[i])>eps) {
			long double k=x.a[i]/p[i].a[i];
			for(int j=i;j;j--) {
				x.a[j]-=k*p[i].a[j];
			}
		}
		else {
			p[i]=x;
			cnt++; 
			return ;
		}
	}
}

signed main() {
	n=read();
	m=read();
	for(int i=1;i<=n;i++) {
		for(int j=1;j<=m;j++) {
			cin>>it[i].a[j];
		}
	}
	for(int i=1;i<=n;i++) {
		cin>>it[i].cost;
	}
	sort(it+1,it+n+1,cmp); 
	for(int i=1;i<=n;i++) {
		insert(it[i]); 
	} 
	
	int ans=0;
	for(int i=m;i;i--) {
		ans+=p[i].cost;
	}
	cout<<cnt<<" "<<ans<<endl;
	return 0;
}

```

---

## 作者：Tenshi (赞：1)

传送门：

https://www.luogu.com.cn/problem/P3265



## 分析

采取这样的贪心策略：将物品看作是矩阵中的**行**，按照花费**升序排序**，然后从 $1-n$​​ 扫描，当第 $i$​​ 个**行**和前面加入的所有**行**线性无关的时候，就将其花费计入答案，反之不计入。



这样做为什么是对的呢？采用归纳法来证明：

下证：前 $n$​​ 行采取上述策略能够在**保证选出的行构成的线性空间与前 $n$​ 行构成的线性空间相等的前提下**花费最小。

- 前 $1$ 行，我们肯定需要将第一行加入贡献，满足。
- 假设前 $k$ 行满足上述贪心策略。
- 下只需证明前 $k+1$ 行采取上述贪心策略是最优的。
    - 如果前 $k$ 行构成的线性空间和前 $k+1$ 行构成的线性空间相等（也就是第 $k+1$​​ **行**能被前 $k$​ 行选出的**行**线性表出），那么我们肯定不选取，满足最优。
    - 如果不相等，也就是第 $k+1$​ 行与前 $k$​ 行线性无关。假设我们不选取第 $k+1$​ 行，那么无论如何从前 $k$​ 行进行选取也不能使得选出的行构成的线性空间与前 $k+1$​​​ 行构成的线性空间相等，因此必须选。



## 实现

```cpp
#include<bits/stdc++.h>
using namespace std;

#define debug(x) cerr << #x << ": " << (x) << endl
#define rep(i,a,b) for(int i=(a);i<=(b);i++)
#define dwn(i,a,b) for(int i=(a);i>=(b);i--)
#define pb push_back
#define all(x) (x).begin(), (x).end()

using ll = long long;

inline void read(int &x){
    int s=0; x=1;
    char ch=getchar();
    while(ch<'0' || ch>'9') {if(ch=='-')x=-1;ch=getchar();}
    while(ch>='0' && ch<='9') s=(s<<3)+(s<<1)+ch-'0',ch=getchar();
    x*=s;
}

const int N=550;
const double eps=1e-5;

int n, m;
int w[N][N], c[N];
int idx[N];

bool zero(double x){
	return abs(x)<eps;
}

bool zero(vector<double> a){
	for(auto i: a) if(!zero(i)) return false;
	return true;
}

void change(vector<double> &a, vector<double> &b){
	rep(i,0,m-1){
		if(zero(a[i]) && !zero(b[i])) return;
		if(!zero(a[i]) && zero(b[i])){
			swap(a, b);
			return;
		}
		if(!zero(a[i]) && !zero(b[i])){
			double rate=a[i]/b[i];
			rep(j,i,m-1) a[j]-=rate*b[j];
			return;
		}
	}
}

int main(){
	cin>>n>>m;
	rep(i,1,n) rep(j,1,m) read(w[i][j]);
	rep(i,1,n) read(c[i]);
	rep(i,1,n) idx[i]=i;
	sort(idx+1, idx+1+n, [](int x, int y){
		return c[x]<c[y];
	});
	
	vector<vector<double>> a;
	ll res=0;
	rep(i,1,n){
		int p=idx[i];
		vector<double> row;
		rep(j,1,m) row.pb(w[p][j]);
		
		for(auto &vec: a) change(row, vec);
		if(!zero(row)) a.pb(row), res+=c[p];
	}
	
	cout<<a.size()<<' '<<res<<endl;
	
	return 0;

```



---


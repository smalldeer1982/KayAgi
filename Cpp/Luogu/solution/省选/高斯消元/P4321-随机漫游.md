# 随机漫游

## 题目描述

H 国有 $N$ 个城市

在接下来的 $M$ 天，小 c 都会去找小 w，但是小 c 不知道小 w 的具体位置，所以小 c 决定每次随机找一条路走，直到遇到了小 w 为止

小 c 知道小 w 只有可能是在 $c_1, c_2.. c_n$ 这 $n$ 个城市中的一个，小 c 想知道在最坏情况下，小 c 遇到小 w 期望要经过多少条道路

H 国所有的边都是无向边，两个城市之间最多只有一条道路直接相连，没有一条道路连接相同的一个城市

任何时候，H 国不存在城市 $u$ 和城市 $v$ 满足从 $u$ 无法到达 $v$

## 说明/提示

$H$ 国的道路构成一条链，所以最坏情况下就是小 w 在深度最大的点上(以小 c 所在的城市为根)

对于第一天，小 c 所在的城市为 1，深度最大的点为 2，城市 1 只能到达城市 2，期望经过 1 条道路到达

对于第二天，小 c 所在的城市为 1，深度最大的点为 3，计算的期望经过 4 条道路到达

第三天同第二天

最坏情况也就是说经过所有 $n$ 个可能的城市至少一遍

subtask1 : 10分，$N = 4, M = 12$

subtask2 : 15分，$N =10, M = 100000$

subtask3 : 15分，$N = 18, M = 1$

subtask4 : 10分，$N = 18, M = 99995$，图是一条链

subtask5 : 10分，$N = 18, M = 99996$，所有的 $s$ 都相同

subtask6 : 15分，$N = 18, M = 99997$，$E = N-1$

subtask7 : 15分，$N = 18, M = 99998$，所有的 $s$ 都相同

subtask8 : 10分，$N = 18, M = 99999$

对于所有数据 : $1\leq N\leq 18, 1\leq M\leq 100000, 1\leq E\leq \frac{N(N-1)}{2}$

## 样例 #1

### 输入

```
3 2
1 2
2 3
3
2 1 2 1		
3 1 2 3 1
1 3 1```

### 输出

```
1
4
4```

# 题解

## 作者：Kelin (赞：8)

## [题意](https://blog.csdn.net/benoble_/article/details/79794581)

给你一幅图,每次给你一个点$u$和一个点集$S$

问从$u$出发走完$S$集合(即$S$内点都至少经过一次)的期望步数	

一个点$u$会等概率地走向其相邻的点

--- 

## 题解

这玩意是$PKUWC2018D2T3$随机游走的加强版

思路和[[HNOI2013]游走](https://blog.csdn.net/benoble_/article/details/79755665)类似,也是通过高斯消元来$DP$

考虑设$f[S][i]$表示走完$S$集合,当前在点$i$,然后要把剩下的所有点都走完的期望步数

可以发现,如果询问的是$u,S$那么对应的$f$值就是$f[all-S][u]$

就是相当于把$S$的补集都走完了,然后现在再从$u$把$S$走完的期望

这样如果预处理出$f,$每个询问就可以$O(1)$回答了

>这里有个小$trick$就是如果$u\in S$这样就错了,因为$u\notin all-S$

>所以对应要求的答案应该是$f[(all-S)|u][u]$

考虑怎么求出$f[S][u]$,初值$f[all]=0$

>$flag:$所以这玩意怕不是要倒推

和游走一样列式,$d_u$表示$u$的点度

$$f[S][u]=\frac1{d_u}\sum_{u\to v\in E}f[S|v][v]+1$$

考虑暴力的话就是用高斯消元解这$n2^n$个方程$,$复杂度$O((n2^n)^3)$

这样显然是不行的

考虑到要么$S\subset S|v,$要么$S=S|v,$即$v\in S$

我们把方程分开一下

$$f[S][u]=\frac1{d_u}[\sum_{u\to v\in E,v\in S}f[S][v]+\sum_{u\to v\in E,v\notin S}f[S|v][v]]+1$$

$$f[S][u]-\frac1{d_u}\sum_{u\to v\in E,v\in S}f[S][v]=\frac1{d_u}\sum_{u\to v\in E,v\notin S}f[S|v][v]+1$$

也就是说,如果我们知道$f[S|v]$的$DP$值那么我们每个状态就只要列$n$个方程

所以按照集合大小倒推,然后每个状态列$n$个方程即可

复杂度$O(n^32^n+\sum n_i)$

```
#include<bits/stdc++.h>
#define fp(i,a,b) for(register int i=a,I=b+1;i<I;++i)
#define fd(i,a,b) for(register int i=a,I=b-1;i>I;--i)
#define go(u) for(register int i=fi[u],v=e[i].to;i;v=e[i=e[i].nx].to)
#define file(s) freopen(s".in","r",stdin),freopen(s".out","w",stdout)
template<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}
template<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}
using namespace std;
char ss[1<<17],*A=ss,*B=ss;
inline char gc(){return A==B&&(B=(A=ss)+fread(ss,1,1<<17,stdin),A==B)?-1:*A++;}
template<class T>inline void sd(T&x){
    char c;T y=1;while(c=gc(),(c<48||57<c)&&c!=-1)if(c==45)y=-1;x=c-48;
    while(c=gc(),47<c&&c<58)x=x*10+c-48;x*=y;
}
char sr[1<<21],z[20];int C=-1,Z;
inline void Ot(){fwrite(sr,1,C+1,stdout),C=-1;}
template<class T>inline void we(T x){
    if(C>1<<20)Ot();if(x<0)sr[++C]=45,x=-x;
    while(z[++Z]=x%10+48,x/=10);
    while(sr[++C]=z[Z],--Z);sr[++C]='\n';
}
const int N=19,S=1<<N,P=998244353;
typedef int arr[N];
typedef long long ll;
int n,m,all,f[S][N];arr e,dg,id,pos,inv,ans,Mi,G[N];
inline int fpm(int a,int b){int x=1;for(;b;b>>=1,a=(ll)a*a%P)if(b&1)x=(ll)x*a%P;return x;}
inline int pls(int a,int b){return a+=b,a<P?a:a-P;}
inline int sub(int a,int b){return a-=b,a<0?a+P:a;}
inline void Gauss(int n){
    int mx,t,x;
    fp(i,1,n)fp(j,1,n)G[i][j]=pls(G[i][j],P);
    fp(i,1,n){mx=i;
        fp(j,i,n)if(G[mx][i]<G[j][i])mx=j;
        if(mx^i)fp(j,i,n+1)swap(G[mx][j],G[i][j]);
        x=fpm(G[i][i],P-2);
        fp(j,i+1,n){
            t=(ll)x*G[j][i]%P;
            fp(k,i,n+1)G[j][k]=sub(G[j][k],(ll)t*G[i][k]%P);
        }
    }
    fd(i,n,1){
        fp(j,i+1,n)G[i][n+1]=sub(G[i][n+1],(ll)ans[j]*G[i][j]%P);
        ans[i]=(ll)G[i][n+1]*fpm(G[i][i],P-2)%P;
    }
}
int main(){
    #ifndef ONLINE_JUDGE
        file("s");
    #endif
    sd(n),sd(m);all=(1<<n)-1;int u,v;
    Mi[1]=1;fp(i,2,n)Mi[i]=Mi[i-1]<<1;
    inv[1]=1;fp(i,2,n)inv[i]=(ll)(P-P/i)*inv[P%i]%P;
    while(m--)sd(u),sd(v),e[u]|=Mi[v],e[v]|=Mi[u],++dg[u],++dg[v];
    fd(s,all-1,1){
        int Cnt=0,x,p;
        fp(i,1,n)if(s&Mi[i])id[pos[i]=++Cnt]=i;
        fp(i,1,Cnt){fp(j,1,Cnt)G[i][j]=0;ans[i]=0;}
        fp(i,1,n)if(s&Mi[i]){
            x=inv[dg[i]],p=pos[i];G[p][p]=1,G[p][Cnt+1]=1;
            fp(j,1,n)if(e[i]&Mi[j]){
                if(s&Mi[j])G[p][pos[j]]-=x;
                else G[p][Cnt+1]=pls(G[p][Cnt+1],(ll)x*f[s|Mi[j]][j]%P);
            }
        }
        Gauss(Cnt);
        fp(i,1,Cnt)f[s][id[i]]=ans[i];
    }
    sd(m);
    while(m--){
        static int s;sd(s);u=0;
        while(s--)sd(v),u|=Mi[v];sd(v);
        we(f[(all^u)|Mi[v]][v]);
    }
return Ot(),0;
}
```

---

## 作者：litble (赞：6)

很有意思的一道题目。

用f(x,S)表示从x出发，已经走过了点集S,走遍全图的期望。

这一类期望题可以考虑高斯消元，构造方程如下：

$$ f(x,S) = \frac{1}{du(x)} (f(y,S) \times [ y \in S ]+ f(y,S \cup j ) \times [ y \not\in S ]; )$$

直接进行高斯消元的话，复杂度肯定受不了，考虑一下该方程的特殊性质。

由于每次走一个新的点，已经走过的点集只可能扩大不可能缩小，所以我们可以利用这个性质进行分层，每次对于一个S进行高斯消元，求出一些信息后，利用这些信息，继续进行下一层的高斯消元。这样每次高斯消元时，复杂度大大降低。

复杂度$O(n^32^n+Q)$

---

## 作者：Mr_Avalon (赞：4)

**题目分析**

这是一道求期望的题，直接考虑从 $x$ 出发走完点集 $S$ 期望的步数似乎不太好转移（也可能是我太弱qwq）。

考虑逆向设计状态。设 $f_{S,x}$ 表示**已经遍历过了 $S$ 集合，当前在点 $x$ 时要遍历完整个图期望走的步数**。那么对于每个询问的点集，我们设它的补集为 $A$，$f_{A|s,s}$ 就是我们所求的答案，因为我们从 $A$ 集合到全部走完刚好把询问的点全部走了一次。

这个状态的转移方程还是很好想的，如果当前在点 $x$，耗费一步走到 $v$ 后就是从 $v$ 开始走完整个图的期望步数了，于是可以列出下列方程：

$$
f_{S,x}=\frac{1}{deg_x}\times\sum\limits_{(u,v)\in G}f_{S|v,v}+1
$$

我们发现，状态的转移成环了，虽然高斯消元可以解决这个问题，但是如果直接对**所有状态**进行高斯消元，复杂度 $O((n\times2^n)^3)$，明显会 T 飞，需要考虑优化。

进一步观察这个式子，可以发现 $S$ 一定是被包含在 $S|v$ 里的，也就是说一个状态只能由一个点集不小于该状态的状态转移而来，于是我们可以考虑对状态进行分层，从大到小在**每个点集内部**分别进行高斯消元，复杂度 $O(2^n\times n^3)$，可以通过此题。

**代码**

```cpp
#include<cstdio>
#include<iostream>

const int N=21,M=N*(N-1)*2,mod=998244353;

inline int read()
{
    int v=0;char ch=getchar();
    while('0'>ch||ch>'9') ch=getchar();
    while('0'<=ch&&ch<='9') v=v*10+(ch^48),ch=getchar();
    return v;
}

inline int get(int x) {return 1<<(x-1);}
inline int Add(int x,int y) {return x+=y-mod,x+=(x>>31)&mod,x;}
inline int Mul(int x,int y) {return 1ll*x*y%mod;}

inline int qp(int a,int k)
{
    int base=1;
    while(k)
    {
        if(k&1) base=Mul(base,a);
        a=Mul(a,a),k>>=1;
    }
    return base;
}

int n,m,q,all;

int cnt,deg[N],first[N],nxt[M<<1],to[M<<1];
inline void add(int u,int v)
{
    deg[u]++,deg[v]++;
    to[++cnt]=v,nxt[cnt]=first[u],first[u]=cnt;
    to[++cnt]=u,nxt[cnt]=first[v],first[v]=cnt;
}

int f[1<<N][N],mat[N][N];
int dfn[N],idf[N];

inline void gauss(int n,int S)
{
    for(int i=1;i<=n;i++)
    {
        int u=i;for(int j=i+1;j<=n;j++) u=mat[j][i]>mat[u][i]? j:u;
        for(int j=1;j<=n+1;j++) std::swap(mat[i][j],mat[u][j]);

        for(int j=1;j<=n;j++) if(i^j)
        {
            int t=Mul(mat[j][i],qp(mat[i][i],mod-2));
            for(int k=i+1;k<=n+1;k++) mat[j][k]=Add(mat[j][k],mod-Mul(t,mat[i][k]));
        }
    }

    for(int i=1;i<=n;i++) f[S][idf[i]]=Mul(mat[i][n+1],qp(mat[i][i],mod-2));
}

//这个dfs的目的是从大到小处理出所有点集
inline void dfs(int limit,int S=0,int level=1,int lst=0)
{
    if(level>limit)
    {
        for(int i=1;i<=limit;i++)
            for(int j=1;j<=limit+1;j++)
                mat[i][j]=0;

        int tot=0;for(int i=1;i<=n;i++)
        if(S&get(i)) dfn[i]=++tot,idf[tot]=i;

        for(int x=1;x<=limit;x++)
        {
            mat[x][x]=mat[x][limit+1]=mod-1;
            int mu=qp(deg[idf[x]],mod-2);

            for(int j=first[idf[x]];j;j=nxt[j])
            {
                int v=to[j];
                if(S&get(v)) mat[x][dfn[v]]=mu;//如果v被包含在S中，就设为未知数
                else mat[x][limit+1]=Add(mat[x][limit+1],mod-Mul(f[S|get(v)][v],mu));
                //否则，S|v这个点集我们已经算好了，直接变成常数扔过去
            }
        }

        return gauss(limit,S);
    }

    for(int i=lst+1;i<=n;i++) dfs(limit,S^get(i),level+1,i);
}

int main()
{
    n=read(),m=read(),all=get(n+1)-1;
    for(int i=1;i<=m;i++) add(read(),read());

    for(int level=n-1;level>0;level--) dfs(level);

    q=read();
    while(q--)
    {
        int k=read(),count=0;
        while(k--) count|=get(read());
        int s=read();printf("%d\n",f[all^count|get(s)][s]);
    }
}
```

---

## 作者：Diaоsi (赞：3)

## 题目链接：[传送门](https://www.luogu.com.cn/problem/P4321)

## 思路：

首先将问题转换，对于每一个询问，设集合 $S_c\{c_1,c_2 \dots c_n\}$ 表示每次需要寻找的点集。设 $\text{Path}^\prime$ 表示从起点出发经过该点集所有点的任意一条路径，$S$ 表示在路径 $\text{Path}^\prime$中，**到达点集 $S_c$ 中所有点的步数的集合**。显然， $\max(S)$ 即是到达 $\text{Path}^\prime$ 终点的步数，而 $\min(T),T \subseteq S$ 即是在路径 $\text{Path}^\prime$ 中第一次到达 $S_c$ 中的点时的步数。

根据 $\min - \max$ 容斥定理，有：

$$\max(S)=\sum_{T \subseteq S} (-1)^{|T|+1}\min(T)$$

而 $\min - \max$ 容斥定理在期望意义下也成立，由于 $\text{Path}^\prime$ 是个**随机变量**且对于任意一个 $\text{Path}^\prime$ 对应的 $S$ 是唯一的，故上式在期望意义下也成立：

$$E(\max(S))=\sum_{T \subseteq S} (-1)^{|T|+1}E(\min(T))$$

显然对于任意一个$\text{Path}^\prime$，$E(\max(S))$表示经过 $S_c$ 中所有点的步数的期望，$E(\min(T))$ 表示在路径 $\text{Path}^\prime$ 中第一次到达 $S_c$ 中的点时的步数的期望。

对于一个给定的 $S_c$ ，考虑这样的 dp ：

$$E(x) =\sum_{(x,y)} \dfrac{E(y)}{deg_x}+1,x\notin S_c$$

 $E(x)$ 表示 $x$ 第一次到 $S_c$ 中的任意一个节点的期望， $deg_x$ 表示节点 $x$ 的度数，则起点的所求得的期望即为 $E(\min(T))$ 。

该方程可以使用**高斯消元**来求解，通过 $\min - \max$ 容斥定理求出 $E(\max(S))$ ，而对于枚举 $T \subseteq S$ 由于我们只关心 $|T|$ ，所以枚举 $S_c$ 子集中点的个数是等价于枚举 $|T|$ 的。

显然我们不能对每个询问枚举 $S_c$ 的子集来求解，这样的时间复杂度是 $\mathcal{O(Mn^3 2^n )}$ 级别的。

考虑枚举所有点构成的点集的子集并用高斯消元算出所有的 $E(\min(T))$ ，然后用高维前缀和维护 $\sum_{T \subseteq S} (-1)^{|T|+1}E(\min(T))$ ，预处理之后即可 $\mathcal{O(1)}$ 查询 $\sum_{T \subseteq S} (-1)^{|T|+1}E(\min(T))$ 。

由于高维前缀和不是本章讨论的重点，想了解的可以看：[高维前缀和 by heyuhhh](https://www.cnblogs.com/heyuhhh/p/11585358.html)

当然也可以用位运算卷积来枚举 $|T|$ ，丢个链接：[位运算卷积 by command-block](https://www.luogu.com.cn/blog/command-block/wei-yun-suan-juan-ji-yu-ji-kuo-zhan)

## 时间复杂度分析/优化：

考虑以下两个优化：

+ 由于要进行有理数取模，若在 dp 处理矩阵系数时计算 $deg_x^{-1}$ ，时间复杂度会达到 $\mathcal{O(N^22^N+2^N((N+E)\log k+\dfrac{1}{3}N^3))}$ 难以通过，若预处理所有的 $deg_x^{-1}$ ，时间复杂度降为 $\mathcal{O(N^22^N+2^N((N+E)+\dfrac{1}{3}N^3))}$ 。

+ 考虑对高斯消元进行优化，若任意一点在被枚举的点的点集内，显然该点的期望为 $0$ ，消元时直接跳过，则枚举点集并进行高斯消元的复杂度为：
$$\sum_{k=0}^N \binom{N}{N-k}(N-k)^3 \approx 2^{N-3}N^3$$ 

经过优化后，总的时间复杂度约为：

$$\mathcal{O(N^22^N+ 2^{N-3}N^3)}$$

对于四秒的时限已经足够。

## 代 码 放 送：

既然你能找到这题，我相信你能瞬间做出来的。

$Code:$

```cpp
#include<bits/stdc++.h>
using namespace std;
const long long N=20,M=1010,lpw=998244353;
long long head[N],ver[M],Next[M],tot;
long long a[N][N],deg[N],f[N],s[1<<N][N],fac[1<<N];
inline long long read(){
    char c=getchar();long long x=0,f=1;
    while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
    while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}
    return x*f;
}
inline long long Qpow(long long x,long long k){
	long long res=1;
	while(k){
		if(k&1)res=(res*x)%lpw;
		k>>=1;x=(x*x)%lpw;
	}
	return res;
}
inline long long inv(long long a){
	return Qpow(a,lpw-2)%lpw;
}
inline void add(long long x,long long y){
	ver[++tot]=y,Next[tot]=head[x],head[x]=tot;
}
inline void gauss(long long n,long long m,long long S){
	for(register long long i=1;i<=n;++i){
		bool ins=(S>>(i-1)&1);
		if(ins)
			for(register long long k=1;k<=n;++k)
				if(k!=i)a[k][i]=0;
	}
	for(register long long i=1,j=1;i<=n&&j<=m;++j){
		long long i1=i;
		bool ins=(S>>(i-1)&1);
		if(ins){i++;continue;}
		while(!a[i1][j]&&i1<=n)i1++;
		if(a[i1][j]==0)continue;
		swap(a[i1],a[i]);
		for(register long long k=m+1;k>=j;--k)a[i][k]=(a[i][k]%lpw*inv(a[i][j])%lpw)%lpw;
		for(register long long k=i+1;k<=n;++k)
			if(a[k][j]!=0)
				for(register long long e=m+1;e>=j;--e)a[k][e]=(a[k][e]-a[i][e]*a[k][j]%lpw+lpw)%lpw;
		i++;
	}
	for(register long long i=n;i>=1;--i)
		for(register long long j=i-1;j>=1;--j){
			a[j][m+1]=(a[j][m+1]-a[j][i]*a[i][m+1]%lpw+lpw)%lpw;
			a[j][i]=(a[j][i]-a[j][i]*a[i][i]%lpw+lpw)%lpw;
		}
	for(register long long i=1;i<=n;++i)
		f[i]=a[i][m+1]%lpw;
}
long long n,m,Q;
inline void pre(long long S){
	for(register long long x=1;x<=n;++x){
		bool ins=(S>>(x-1)&1);
		if(ins){a[x][x]=1;continue;}
		a[x][x]=(-1+lpw)%lpw;
		for(register long long i=head[x];i;i=Next[i]){
			long long y=ver[i];
			a[x][y]=deg[x]%lpw;
		}
		a[x][n+1]=(-1+lpw)%lpw;
	}
}
int main(){
	n=read();m=read();
	for(register long long i=1;i<=m;++i){
		long long x,y;
		x=read();y=read();
		add(x,y),add(y,x);
		++deg[x],++deg[y];
	}
	for(register long long i=1;i<=n;++i)
		deg[i]=inv(deg[i]);
	fac[0]=-1;
	for(register long long i=1;i<1<<n;++i){
		memset(a,0,sizeof(a));
		fac[i]=fac[i>>1]*((i&1)?-1:1);
		pre(i);
		gauss(n,n,i);
		for(register long long k=1;k<=n;++k)
			s[i][k]=(f[k]*fac[i]%lpw+lpw)%lpw;
	}
	for(register long long k=1;k<=n;++k)
		for(register long long i=0;i<n;++i)
			for(register long long j=1;j<1<<n;++j)
				if(j>>i&1)s[j][k]=(s[j][k]+s[j^(1<<i)][k]);
	Q=read();
	while(Q--){
		long long ques,st,S=0;
		ques=read();
		for(register long long i=1;i<=ques;++i)
			S|=(1<<(read()-1));
		st=read();
		printf("%lld\n",s[S][st]%lpw);
	}
	return 0;
}
```

---

## 作者：LEWISAK (赞：1)

[传送门](https://www.luogu.com.cn/problem/P4321)

# 题意概要

给你一个无向图，求随机游走将 $n$ 个终点全部走一遍的期望步数。

# 题解

首先图上随机游走肯定是要高消的，但只想到这一点对思路提醒不大。

注意到点数 $\le18$ 容易想到状压 dp，$dp_{i,j}$ 表示已走的点集为 $i$ ，将剩余的点从 $j$ 出发都走一遍的期望步数，最后从起点开始除了终点全都走过的期望步数就是答案。

易得转移（其中 $in_i$ 表示 $i$ 的入度，$d$ 为与 $u$ 相连的点的集合）：

$$
dp_{i,j}=\frac{1}{in_i}\sum_{v\in d}{dp_{i\cup v}+1}
$$

注意到这么搞枚举状态有 $n2^n$ 种，加上高斯消元求解直接就死了🤯。

于是注意到 $i\cup v$ 绝对包含 $i$，遂考虑将状态分层，枚举点集后只对当前的点集高消，复杂度优化至 $O(2^nn^3)$，可以通过。

# 代码

还有细节不懂可以看注释。

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int mod=998244353;
int n,m,q,all/*全集*/,tot,in[30]/*入度*/,head[30],dp[1110101][30],a[30][30]；
int dfn[30],p[30];//dfs序
struct jiegoutiming{//链式前向星 
	int nxt,to;
}e[888];
void add(int u,int v){
	in[v]++;
	e[++tot].to=v;
	e[tot].nxt=head[u];
	head[u]=tot;
	return;
}

int qpow(int x,int y){//快速幂 
	int aaa=1;
	while(y){
		if(y&1){
			aaa=aaa*x%mod;
		}
		x=x*x%mod;
		y>>=1;
	}
	return aaa;
}
void gaosi(int n,int S){
	for(int i=1;i<=n;i++){//高消板子 
		int u=i;
		for(int j=i+1;j<=n;j++){
			u=a[j][i]>a[u][i]?j:u;
		}
		for(int j=1;j<=n+1;j++){
			swap(a[i][j],a[u][j]);
		}
		for(int j=1;j<=n;j++){
			if(i^j){
				int t=a[j][i]*qpow(a[i][i],mod-2)%mod;
				for(int k=i+1;k<=n+1;k++){
					a[j][k]=((a[j][k]+mod-t*a[i][k]%mod)%mod+mod)%mod;
				}
			}
		}
	}
	for(int i=1;i<=n;i++){//更新答案 
		dp[S][p[i]]=a[i][n+1]*qpow(a[i][i],mod-2)%mod;
	}
}
void dfs(int nn,int S,int dep,int lst){
	if(dep>nn){
		for(int i=1;i<=nn;i++){
			for(int j=1;j<=nn+1;j++){
				a[i][j]=0;
			}
		}
		int tot=0;
		for(int i=1;i<=n;i++){
			if(S&(1<<(i-1))){
				dfn[i]=++tot;
				p[tot]=i;
			}
		}
		for(int i=1;i<=nn;i++){//处理方程 
			a[i][i]=a[i][nn+1]=mod-1;
			int ni=qpow(in[p[i]],mod-2);
			for(int j=head[p[i]];j;j=e[j].nxt){
				int v=e[j].to;
				if(S&(1<<(v-1))){
					a[i][dfn[v]]=ni;
				}
				else{
					a[i][nn+1]=((a[i][nn+1]+mod-dp[S|(1<<(v-1))][v]*ni%mod)%mod+mod)%mod;
				}
			}
		}
		return gaosi(nn,S);
	}
	for(int i=lst+1;i<=n;i++){
		dfs(nn,S^(1<<(i-1)),dep+1,i);
	}
}
signed main(){
	cin>>n>>m;
	all=(1<<n)-1;
	for(int i=1;i<=m;i++){
		int u,v;
		cin>>u>>v;
		add(u,v);
		add(v,u);
	}
	cin>>q;
	for(int i=n-1;i>0;i--){
		dfs(i,0,1,0);
	}
	while(q--){
		int x,S=0,y,z;
		cin>>x;
		for(int i=1;i<=x;i++){
			cin>>y;
			S|=(1<<(y-1));
		}
		cin>>z;
		cout<<dp[(all^S)|(1<<(z-1))][z]<<endl;//如果起点是终点之一要直接排除，否则不合法 
	}
	return 0;
}
```

---

## 作者：Laoshan_PLUS (赞：1)

# [P4321 随机漫游](https://www.luogu.com.cn/problem/P4321)

$n\le18$ 的数据范围显然不是白给的，考虑设计状态中包含一个二进制数 $S$ 表示走过了哪些关键点。状态设计就是 $f_{S,u}$，表示已经走过了点集为 $S$ 的点，现在在 $u$，走到 $n$ 的期望步数。

期望 DP 逆推，于是有：
$$
f_{S,u}=\frac1{\deg(u)}\Bigg(\sum_{(v,u)\in E}f_{S\cup v,v}\Bigg)+1
$$
这显然是有后效性的，考虑高斯消元。但是 $2^nn$ 个状态让高斯消元直接似了。发现我们的转移总是由 $S$ 较大的点转移到 $S$ 较小的点，这让我们想到从大到小枚举 $S$，由于比当前的 $S$ 大的 $S$ 我们都已经算过了，所以对于每一个 $S$ 都构造出单独的一个线性方程组，而这个方程组的次数是 $n$，$O(n^3)$ 的高斯消元可以承受。然后算出来的值再保存下来即可。

这样复杂度就优化到了 $O(2^nn^3)$。

至于询问，由于我们已经算出了每一个状态的答案，那么对于询问集合 $T$ 和起点 $x$，我们只需输出 $f_{(\complement T)\cup x,x}$ 即可，其中 $\complement T$ 是 $T$ 关于全集的补集。这样回答询问就是 $O(1)$ 的。

```cpp
#include<bits/stdc++.h>
#define fw fwrite(obuf,p3-obuf,1,stdout)
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<20,stdin),p1==p2)?EOF:*p1++)
#define putchar(x) (p3-obuf<1<<20?(*p3++=(x)):(fw,p3=obuf,*p3++=(x)))
#define inv(x) power(x,MOD-2)
using namespace std;

char buf[1<<20],obuf[1<<20],*p1=buf,*p2=buf,*p3=obuf,str[20<<2];
int read(){
	int x=0;
	char ch=getchar();
	while(!isdigit(ch))ch=getchar();
	while(isdigit(ch))x=(x<<3)+(x<<1)+(ch^48),ch=getchar();
	return x;
}
template<typename T>
void write(T x,char sf='\n'){
	if(x<0)putchar('-'),x=~x+1;
	int top=0;
	do str[top++]=x%10,x/=10;while(x);
	while(top)putchar(str[--top]+48);
	if(sf^'#')putchar(sf);
}
using ll=long long;
constexpr int MAXN=20,MAXM=405;
constexpr ll MOD=998244353;
int n,m,q,deg[MAXN];
vector<int>g[MAXN];
ll a[MAXN][MAXN],f[1<<18][MAXN];

ll power(ll a,ll b){
	ll res=1;
	for(;b;a=a*a%MOD,b>>=1)if(b&1)res=res*a%MOD;
	return res;
}
void add(ll&x,ll y){
	x=(x+y>=MOD?x+y-MOD:x+y);
}
void sub(ll&x,ll y){
	x=(x-y<0?x-y+MOD:x-y);
}
void gauss_jordan(){
	for(int i=1;i<=n;i++){
		for(int k=i;k<=n;k++)
			if(a[k][i]){
				swap(a[i],a[k]);
				break;
			}
		for(int k=1;k<=n;k++){
			if(!a[k][i]||k==i) continue;
			ll t=a[k][i]*inv(a[i][i])%MOD;
			for(int j=i;j<=n+1;j++)
				sub(a[k][j],t*a[i][j]%MOD);
		}
	}
	for(int i=1;i<=n;i++) a[i][n+1]=a[i][n+1]*inv(a[i][i])%MOD;
}

int main(){
	n=read(),m=read();
	for(int i=1,u,v;i<=m;i++){
		u=read(),v=read();
		g[u].emplace_back(v);
		g[v].emplace_back(u);
		deg[u]++,deg[v]++;
	}
	int B=(1<<n)-1;
	for(int s=B-1;s;s--){
		memset(a,0,sizeof(a));
		for(int i=1;i<=n;i++){
			if(!(s&1<<(i-1))) continue;
			a[i][i]=1,a[i][n+1]=1;
			ll fk=inv(deg[i]);
			for(auto v:g[i])
				if(s&1<<(v-1)) a[i][v]=MOD-fk;
				else add(a[i][n+1],fk*f[s|1<<(v-1)][v]%MOD);
		}
		gauss_jordan();
		for(int i=1;i<=n;i++)
			if(s&1<<(i-1))
				f[s][i]=a[i][n+1]; 
	}
	q=read();
	while(q--){
		int k=read(),s=0;
		for(int i=1;i<=k;i++) s|=1<<(read()-1);
		int x=read();
		write(f[(B^s)|1<<(x-1)][x]);
	}
	return fw,0;
}
```

---

## 作者：Reunite (赞：1)

设 $f_{S,u}$ 表示已经遍历完 $S$ 集合的点，目前在点 $u$，要走完全集的期望步数，转移显然为：

$$f_{S,u}=1+\frac{1}{d_u}\sum_{u\rightarrow v}f_{S|v,v}$$

直接高消是 $(n2^n)^3$ 的，注意到成环的地方只有在同点集内部，否则是形如 DAG 的转移，那就分层高消，直接算出后面已经确定的值，对于同一个点集内的点高消即可，复杂度为 $O(n^32^n)$。

对于询问，记关键点集为 $S'$，考虑任意一种游走序列，我们总可以通过调整，把结束点放在最后一个关键点，其他非关键点怎么走都是无所谓的，所以答案就是 $f_{U-S',v}$，也就是在点 $v$ 期望把 $S'$ 走完的步数，最后注意到 $v$ 在 $S$ 中会冲突，特殊包含一下就好。复杂度 $O(n^32^n+\sum q_i)$。

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <vector>
#define int long long
#define mod 998244353
using namespace std;

int n,m,q,cnt;
int b[20];
int d[20];
int a[20][20];
int f[300000][20];
vector <int> g[20];

inline void in(int &n){
	n=0;
	char c=getchar();
	while(c<'0' || c>'9') c=getchar();
	while(c>='0'&&c<='9') n=n*10+c-'0',c=getchar();
	return ;
}

inline int calc(int x,int k){
	int tmp=1;
	while(k){
		if(k&1) tmp=tmp*x%mod;
		x=x*x%mod;
		k>>=1;
	}
	return tmp;
}

inline int inv(int x){return calc(x,mod-2);}

inline void Gauss(int n){
	for(int i=1;i<=n;i++){
		if(!a[i][i]){
			for(int j=i+1;j<=n+1;j++)
				if(a[j][i]){swap(a[i],a[j]);break;}
		}
		for(int j=i+1;j<=n;j++){
			int x=a[j][i]*inv(a[i][i])%mod;
			for(int k=i;k<=n+1;k++)
				(a[j][k]+=mod-a[i][k]*x%mod)%=mod;
		}
	}
	for(int i=n;i>=1;i--){
		int x=calc(a[i][i],mod-2);
		for(int j=i;j<=n+1;j++) a[i][j]=a[i][j]*x%mod;
		for(int j=i-1;j>=1;j--){
			int x=a[j][i];
			for(int k=i;k<=n+1;k++)
				(a[j][k]+=mod-a[i][k]*x%mod)%=mod;
		}
	}
	return ;
}

signed main(){
	in(n),in(m);
	for(int i=1;i<=m;i++){
		int u,v;
		in(u),in(v);
		g[u].emplace_back(v);
		g[v].emplace_back(u);
		d[u]++,d[v]++;
	}
	for(int s=(1<<n)-2;s>=0;s--){
		memset(a,0,sizeof(a));
		memset(b,0,sizeof(b));
		cnt=0;
		for(int u=1;u<=n;u++) if(s&(1<<(u-1))) b[u]=++cnt;
		for(int u=1;u<=n;u++){
			if(!b[u]) continue;
			a[b[u]][b[u]]=a[b[u]][cnt+1]=d[u];
			for(int v:g[u]){
				if(b[v]) a[b[u]][b[v]]--;
				else (a[b[u]][cnt+1]+=f[s|(1<<(v-1))][v])%=mod;
			}
		}
		Gauss(cnt);
		for(int u=1;u<=n;u++) if(b[u]) f[s][u]=a[b[u]][cnt+1];
	}
	in(q);
	while(q--){
		in(m);
		int S=(1<<n)-1,x=0;
		while(m--) in(x),S^=(1<<(x-1));
		in(x);
		printf("%lld\n",f[S|(1<<(x-1))][x]);
	}

	return 0;
}
```

---

## 作者：DengDuck (赞：1)

来一份 1.3K 的不压行实现。

首先这题我们发现 $n$ 很小，容易想到状压，直接状压和 Min-Max 容斥之后求 Min 的那个状压难度差不多，所以我们就不考虑 Min-Max 容斥了。

我们设 $F_{S,u}$ 表示以及去过的点集合是 $S$，当前在点 $u$，走完的期望步数，易得转移：

$$
F_{S,u}=\dfrac 1 {d_u}\sum_{u\to v}F_{S|v,v}+1
$$

这玩意显然没有后效性，需要借助高斯消元，不过直接跑显然会寄，注意到 $S$ 只会变大，所以我们从大到小枚举 $S$，然后在内部跑高斯消元即可，时间复杂度为 $\mathcal O(n^32^n)$。

好像跑得有点慢，但是不太懂为什么。

```cpp
#include<bits/stdc++.h>
#define pb push_back
#define LL long long
using namespace std;
const int N=21;
const LL Mod=998244353;
inline LL Ksm(LL x,LL y)
{
	LL A=1;
	while(y)
	{
		if(y&1)A=A*x%Mod;
		x=x*x%Mod,y>>=1;
	}
	return A;
}
int n,m,TOT,D[N];
LL F[1<<N][N],A[N][N];
vector<int>E[N];
inline void Gauss()
{
	for(int i=1;i<=n;i++)
	{
		for(int j=i;j<=n;j++)if(A[j][i])swap(A[i],A[j]);
		if(A[i][i])
		for(int j=1;j<=n;j++)
		{
			if(!A[j][i]||j==i)continue;
			LL t=A[j][i]*Ksm(A[i][i],Mod-2)%Mod;
			for(int k=1;k<=n+1;k++)(A[j][k]+=Mod-t*A[i][k]%Mod)%=Mod;	
		}
	}
	for(int i=1;i<=n;i++)
	{
		if(!A[i][i])continue;
		LL I=Ksm(A[i][i],Mod-2);
		(A[i][i]*=I)%=Mod,(A[i][n+1]*=I)%=Mod;
	}
}
int main()
{
	scanf("%d%d",&n,&m);TOT=(1<<n)-1;
	for(int i=1,x,y;i<=m;i++)
	{
		scanf("%d%d",&x,&y);
		E[x].pb(y),E[y].pb(x);
		D[x]++,D[y]++;
	}
	for(int S=TOT-1;S;S--)
	{
		memset(A,0,sizeof(A));
		for(int u=1;u<=n;u++)
		{
			if(!((S>>u-1)&1))continue;
			A[u][u]=1,A[u][n+1]=1;
			LL I=Ksm(D[u],Mod-2);
			for(int v:E[u])
			{
				if((S>>v-1)&1)A[u][v]=Mod-I;
				else (A[u][n+1]+=I*F[S|(1<<v-1)][v])%=Mod;
			}
		}
		Gauss();
		for(int i=1;i<=n;i++)
		{
			if(!((S>>i-1)&1))continue;
			F[S][i]=A[i][n+1];
		}
	}
	int T;scanf("%d",&T);
	while(T--)
	{
		int L,x,S=0;scanf("%d",&L);
		while(L--)
		{
			scanf("%d",&x);
			S|=(1<<x-1);
		}
		scanf("%d",&x);
		printf("%lld\n",F[TOT^S|(1<<x-1)][x]);
	}
}
```

---

## 作者：zhangxy__hp (赞：0)

看到 $n\le 18$，基本上是要做状压的。考虑进行预处理，然后在较小的复杂度内回答询问。设 $f_{S,u}$ 表示当前走完了 $S$ 中的点，现在在 $u$ 点（$u\in S$），走完剩下的点的期望步数。于是有方程：

$$
f_{S,u}=1+\frac{1}{d_u}\sum f_{S\cup\{v\},v}
$$

其中 $(u,v)$ 是一条边，$d_u$ 表示 $u$ 的度数。

考虑 $S$ 与 $S\cup\{v\}$ 的关系，显然只有两种情况，分别是 $S=S\cup\{v\}$ 和 $S\subsetneqq S\cup\{v\}$。于是就可以倒着扫 $S$，对于每个 $S$ 做高斯消元了。

考虑输出答案，题目的要求其实就是要将 $c$ 中的点全部走完。设 $c$ 中的点构成的集合为 $S$，起点为 $u$，那么答案即为 $f_{(\complement S)\cup\{u\},u}$。总时间复杂度为 $O(2^nn^3+m)$。

```cpp
#include<bits/stdc++.h>
#define ll long long
#define il inline
#define pb push_back
using namespace std;
namespace asbt{
namespace cplx{bool begin;}
const int mod=998244353;
int n,m,q,a[25][25];
int f[(1<<18)+5][25];
vector<int> e[25];
il int qpow(int x,int y){
//	cout<<x<<" "<<y<<"\n";
	int res=1;
	while(y){
		if(y&1){
			res=res*1ll*x%mod;
		}
		y>>=1,x=x*1ll*x%mod;
	}
	return res;
}
namespace cplx{
	bool end;
	il double usdmem(){return (&begin-&end)/1048576.0;}
}
int main(){
//	ios::sync_with_stdio(0),cin.tie(0);
	cin>>n>>m;
	for(int i=1,u,v;i<=m;i++){
		cin>>u>>v;
		e[u].pb(v),e[v].pb(u);
	}
	int uS=(1<<n)-1;
	for(int S=uS-1;S;S--){
		for(int i=1;i<=n;i++){
			for(int j=1;j<=n+1;j++){
				a[i][j]=0;
			}
		}
		for(int u=1,tmp;u<=n;u++){
			if(S>>(u-1)&1){
				a[u][u]=mod-1;
				tmp=qpow(e[u].size(),mod-2);
				for(int v:e[u]){
					if(S>>(v-1)&1){
						a[u][v]=tmp;
					}
					else{
						a[u][n+1]=(a[u][n+1]-f[S|1<<(v-1)][v]+mod)%mod;
					}
				}
				a[u][n+1]=(a[u][n+1]*1ll*tmp+mod-1)%mod;
			}
		}
		for(int i=1,cur,tmp;i<=n;i++){
			if(S>>(i-1)&1){
				tmp=0;
				for(int j=i;j<=n;j++){
					if(S>>(j-1)&1){
						if(tmp<a[j][i]){
							tmp=a[j][i],cur=j;
						}
					}
				}
				swap(a[i],a[cur]);
				tmp=qpow(a[i][i],mod-2);
				for(int j=1;j<=n;j++){
					if(i!=j&&(S>>(j-1)&1)){
						for(int k=i+1;k<=n+1;k++){
							if((S>>(k-1)&1)||k==n+1){
								a[j][k]=(a[j][k]-a[j][i]*1ll*a[i][k]%mod*tmp%mod+mod)%mod;
							}
						}
					}
				}
			}
		}
		for(int i=1;i<=n;i++){
			if(S>>(i-1)&1){
				f[S][i]=a[i][n+1]*1ll*qpow(a[i][i],mod-2)%mod;
			}
		}
	}
	cin>>q;
	while(q--){
		int num,S=0,u;
		cin>>num;
		while(num--){
			cin>>u;
			S|=1<<(u-1);
		}
		cin>>u;
		cout<<f[(uS^S)|1<<(u-1)][u]<<"\n";
	}
	return 0;
}
}
int main(){return asbt::main();}
```

---


# [JSOI2009] 有趣的游戏

## 题目描述

小阳阳发明了一个有趣的游戏：有 $n$ 个玩家，每个玩家都有一个长度为 $l$ 的字母序列，任何两个玩家的字母序列不同。共有 $m$ 种不同的字母，所有的字母序列都由这 $m$ 种字母构成。为了方便，我们取大写字母的前 $m$ 个字母。   
例如 $m=3,l=4,\texttt{ABAA}$ 和 $\texttt{CBCA}$ 是两个合法的字母序列。       
现在由小阳阳来操控一台神奇的机器，每个时刻机器会随机产生一个字母，其中第 $i$ 种字母随机出来的概率为 $\dfrac{p_i}{q_i}$ ，显然 $\sum \limits_{k=1}^m \dfrac{p_i}{q_i}=1$。  
这样 $T$ 个时刻后机器会产生一个长度为 $T$ 的字母序列。  
如果某个时刻某个玩家发现自己的字母序列在机器产生的字母序列中出现了，“出现”的定义是玩家的字母序列是机器产生的字母序列中连续的一段，那么我们称这个玩家获胜，游戏结束。       
现在小阳阳感兴趣的一个问题是，每个玩家分别有多大的概率能获得这场游戏的胜利呢？  

## 说明/提示

$1 \leq n,l,m \leq 10$，$0 \leq p_i \leq q_i \leq 10$ 且 $\gcd(p,q) = 1$。

## 样例 #1

### 输入

```
3 2 2
1 2
1 2
AB
BA
AA```

### 输出

```
0.25
0.50
0.25```

## 样例 #2

### 输入

```
3 4 2
1 2
1 2
AABA
ABAA
BAAA```

### 输出

```
0.31
0.33
0.37```

# 题解

## 作者：zzw4257 (赞：14)

我也是百思不得其解后看了[这篇博客](https://blog.sengxian.com/solutions/bzoj-1444)后才明白了概率到期望的转化，但不幸的是这篇文章依然有一个小"迷"人的地方

首先问题可以被等价成在 AC 自动机上的一个匹配过程，匹配到一些关键点后会停止，求到这些关键点停下的概率

考虑设 $f(i)=P(i$点被经过$)$的设法存在两个问题

- $f(x)(x|$ $x$不是关键点 $)$
- $f($ 根 $)$的取值未定，轻易的可以发现，$f($ 根 $)=1$明显与这个匹配过程可以反复返根矛盾

不妨转换设法

$f(i)=E(i$点被经过次数$)$

发现这样的话，每个点都具有定义，且在关键点时其到达次数的期望=在这里停止的概率(因为你只会到达这样的点一次)

这样就可以用全期望公式写每个点从其余点过来的转移过程了，设$x\to y$转移的概率是 $P_{x\to y}$,容易注意到$1=\sum_{y}P_{x\to y}$

$$
f_x=\begin{cases}1+\sum_{y }P_{y\to x}f_y&x=0\\\sum_{y }P_{y\to x}f_y&x\neq0\end{cases}
$$

解释下那个$1$是状态初始累计的

然后高斯消元就不存在问题了


到这里你可能会有一点疑惑，关于初值 $f_0$ ，其实是不需要的且未知的，注意到我们列出的方程有$n$个，未知数也是$n$个，因此都是可以解出来的

---

## 作者：cyffff (赞：7)

[$\text{Link}$](https://www.luogu.com.cn/problem/P6125)
## 题意
给你 $n$ 个长为 $l$ 的字符串 $a_{1,2,...,n}$，字符集大小为 $m$，每次随机在末尾添加一个字符，当当前字符串包含字符串 $a_i$ 时结束操作，对 $1\le i\le n$ 问 $a_i$ 成为结束操作时所包含的字符串的概率。

$1\le n,l,m\le10$
## 思路
我们建出 $\text{ACAM}$ 和其 $\text{Fail}$ 树，然后问题就变成了 $\text{Fail}$ 树上停于某一点的**概率**。

这让我们容易联想到高斯消元，但是我们并不会求经过 $x$ 点的概率。

然后我们可以设 $f_x$ 为经过 $x$ 点的**期望**。则我们有 $f_x=[x=0]+\sum_y\text{P}_{y\to x}f_y$。

然后我们就可以对其进行高斯消元了。

时间复杂度 $O(n^3l^3)$。

当然有 $O(n^3)$ 的高论生成函数做法，但我不会。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
namespace IO{//by cyffff
	
}
const int N=100+10;
#define Tr ACAM.a[cur].ch
#define pid pair<int,double>
#define mpr make_pair
int n,l,m,endp[N];
double A[N][N],ans[N],p[N],q[N];
char str[N];
vector<pid>e[N];
struct AC_AutoMaton{
	#define son a[cur].ch
	int fail[N];
	int cnt=0;
	struct node{
		int ch[10];
		bool endp;
	}a[N];
	inline void insert(char *s,int n,int x){
		int cur=0;
		for(int i=1;i<=n;i++){
			int x=s[i]-'A'; 
			if(!son[x]) son[x]=++cnt;
			cur=son[x];
		}
		endp[x]=cur;
		a[cur].endp=1;
	}
	inline void getfail(){
		queue<int>q;
		for(int i=0;i<m;i++){
			if(a[0].ch[i]) q.push(a[0].ch[i]);
		}
		while(!q.empty()){
			int cur=q.front();
			q.pop();
			for(int i=0;i<m;i++){
				if(!son[i]){
					son[i]=a[fail[cur]].ch[i];
				}else{
					int v=fail[cur];
					fail[son[i]]=a[v].ch[i];
					q.push(son[i]);
				}
			}
		}
	}
	inline void build(){
		for(int i=0;i<=cnt;i++){
			if(!a[i].endp){
				for(int j=0;j<m;j++){
					e[a[i].ch[j]].push_back(mpr(i,p[j+1]/q[j+1]));
				}
			}
		}
		for(int i=0;i<=cnt;i++){
			A[i+1][i+1]=-1;
			if(i==0) A[i+1][cnt+2]=-1;
			for(int j=0;j<e[i].size();j++){
				int t=e[i][j].first;
				double w=e[i][j].second;
				A[i+1][t+1]+=w;
			}
		}
	}
}ACAM;
inline void Gauss(int n){
	for(int i=1;i<=n;i++){
		int k=i;
		for(int j=i+1;j<=n;j++){
			if(fabs(A[j][i])>fabs(A[k][i])){
				k=j;
			}
		}
		for(int j=1;j<=n+1;j++){
			swap(A[i][j],A[k][j]);
		}
		for(int j=1;j<=n;j++){
			if(i!=j){
				double res=A[j][i]/A[i][i];
				for(int l=i+1;l<=n+1;l++){
					A[j][l]-=A[i][l]*res;
				}
			}
		}
	}
	for(int i=1;i<=n;i++){
		ans[i]=A[i][n+1]/A[i][i];
	}
}
int main(){
	n=read(),l=read(),m=read();
	for(int i=1;i<=m;i++){
		p[i]=read(),q[i]=read();
		if(p[i]==0) p[i]=0.000001;
	}
	for(int i=1;i<=n;i++){
		readstr(str);
		ACAM.insert(str,l,i);
	}
	ACAM.getfail();
	ACAM.build();
	Gauss(ACAM.cnt+1);
	for(int i=1;i<=n;i++){
		printf("%.2lf\n",max(ans[endp[i]+1],0.0));
	}
}
```
再见 qwq~

---

## 作者：pigstd (赞：6)

### [P6125 [JSOI2009]有趣的游戏](https://www.luogu.com.cn/problem/P6125)

建出 `fail` 树之后，相当于对于给出的字典树，一个点在上随机游走，每次随机走到他的出边（即他的 $m$ 个儿子）之一（因为建了 `fail` 树的缘故，所有点的儿子都会指向一个节点，或者是根节点），然后如果走到某个字符串结尾就停止，问最终在哪个字符串上停止的概率。~~这不就是显然的高斯消元吗，实在是太简单了，我一眼就秒了！~~

然后你发现你不会做这个东西。原来是这样！普通的高斯消元的方法是设经过点 $x$ 的概率为 $f_x$ 然后列方程消元，但是这个题很难这么做……一种更加喵喵喵的做法是设经过点 $x$ 的**期望**的次数为 $f_x$，那么显然，由于结尾处最多经过一次（没有出边），那么此时的期望就是概率了。此外，与前者相比，期望的次数显然是更加容易求的，具体的，有：
$$
f_x=
\begin{cases}
\displaystyle \sum_y P(y \to x)\times f_y+1 \ (x=0)
\\
\displaystyle \sum_y P(y \to x)\times f_y \ (x\ne 0)
\end{cases}
$$
其中，$P(y\to x)$ 表示点 $y$ 到点 $x$ 的几率，$x=0$ 时候的 $+1$ 是因为一开始的贡献，然后高斯消元即可。不知道为啥有一个点会输出奇怪的东西，把 $p=0$ 时设置成 $0.00001$ 就可以了，暂时不是很懂。

```cpp
#include<bits/stdc++.h>
#define int long long
#define pb push_back
#define mp make_pair
#define x first
#define y second
#define WT int T=read();while(T--) 
#define NO puts("NO");
#define YES puts("YES");
#define debug puts("qwq");
using namespace std;

inline int read()
{
    char c=getchar();int x=0;bool f=0;
    for(;!isdigit(c);c=getchar())f^=!(c^45);
    for(;isdigit(c);c=getchar())x=(x<<1)+(x<<3)+(c^48);
    if(f)x=-x;return x;
}

const int M=15;
const int N=110;
int n,l,m,ed[M];
string s[M];
double a[N][N],ans[N],p[M],q[M];
struct node
{
	int son[26],fail,val;
}t[N];int cnt;
vector<pair<int,double> >e[N];
void insert(string s,int p)
{
	int now=0;
	for (int i=0;i<l;i++)
	{
		if (!t[now].son[s[i]-'A'])t[now].son[s[i]-'A']=++cnt;
		now=t[now].son[s[i]-'A'];
	}ed[p]=now;t[now].val=1;
}
void get_fail()
{
	queue<int>q;
	for (int i=0;i<m;i++)
		if (t[0].son[i])q.push(t[0].son[i]);
	while(!q.empty())
	{
		int now=q.front();q.pop();
		for (int i=0;i<m;i++)
		{
			int v=t[now].son[i];
			if (v)t[v].fail=t[t[now].fail].son[i],q.push(v);
			else t[now].son[i]=t[t[now].fail].son[i];
		}
	}
}
void get_edge()
{
	for (int i=0;i<=cnt;i++)
		if (!t[i].val)
			for (int j=0;j<m;j++)
				e[t[i].son[j]].pb(mp(i,p[j+1]*1.0/q[j+1]));
}

void guass(int n)
{
//	for (int i=1;i<=n;i++)
//	{
//		for (int j=1;j<=n+1;j++)
//			cout<<a[i][j]<<' ';
//		puts("");
//	}
	for (int i=1;i<=n;i++)
	{
		int p=i;
		for (int j=i+1;j<=n;j++)
			if (fabs(a[j][i])>fabs(a[p][i]))
				p=j;
		for (int j=1;j<=n+1;j++)
			swap(a[i][j],a[p][j]);
		for (int j=n+1;j>=i;j--)a[i][j]/=a[i][i];
		for (int j=i+1;j<=n;j++)
			for (int k=n+1;k>=i;k--)
				a[j][k]-=a[j][i]*a[i][k];
	}
//	for (int i=1;i<=n;i++){
//		for (int j=1;j<=n+1;j++)cout<<a[i][j]<<' ';cout<<endl;}
	ans[n]=a[n][n+1];
	for (int i=n-1;i>=1;i--)
	{
		ans[i]=a[i][n+1];
		for (int j=i+1;j<=n;j++)
			ans[i]-=a[i][j]*ans[j];
	}
}

signed main()
{
	cin>>n>>l>>m;
	for (int i=1;i<=m;i++)
	{
		cin>>p[i]>>q[i];
		if (p[i]==0)p[i]=0.00001;
	}
	for (int i=1;i<=n;i++)
	{
		cin>>s[i];
		insert(s[i],i);
	}
	get_fail(),get_edge();//debug
	for (int i=0;i<=cnt;i++)
	{
		a[i+1][i+1]=-1;if (i==0)a[i+1][cnt+2]=-1;
		for (int j=0;j<e[i].size();j++)
		{
			int to=e[i][j].x;double w=e[i][j].y;
			a[i+1][to+1]+=w;
		}
	}guass(cnt+1);
	for (int i=1;i<=n;i++)printf("%.2lf\n",max(ans[ed[i]+1],0.0));
	return 0;
}
```



---

## 作者：EuphoricStar (赞：5)

## 思路

考虑建出 AC 自动机之后 `dp`。对于每一个人分别计算它的胜率，设当前计算到第 $i$ 个人的胜率，设 $f_u$ 表示当前在 AC 自动机上的 $u$ 号结点获胜的概率，对 AC 自动机上每个结点 $u$ 写出它的转移方程：

- 若 $u$ 为第 $i$ 个字符串的叶子结点，$f_u = 1$。

- 若 $u$ 为叶子结点但 $u$ 不为第 $i$ 个字符串的叶子结点，$f_u = 0$。

- 若 $u$ 不为叶子结点，$f_u = \sum\limits_{i=0}^m f_{ch_{u,i}} \times \dfrac{p_i}{q_i}$。

答案即为 $f_0$。

发现这个转移是有环的，不能直接转移，因此高斯消元后得出答案。

时间复杂度 $O(n^2ml + n^4l^3)$。

## 代码

[code](https://pastebin.ubuntu.com/p/HcsSSYWnHn/)

---

## 作者：行吟啸九州 (赞：5)

这个题是不错的AC自动机和高斯消元的练手题。

[不会AC自动机左转](https://www.luogu.com.cn/problem/P3808#submit)，[不会高斯消元左转](https://www.luogu.com.cn/problem/P3389)。

这个题实际上就是在AC自动机上做一个```dp```，```f[i]```代表走到```i```这个节点的概率，转移方程就是```f[go[i][j]] += p[j] *f[i]```, 然后会有一个问题，就是转移的时候出现了环，这样子就转移不下去了。

一般dp转移成环有两种解决办法，要么```cdq```分治，要么```gauss```消元，```cdq```分治一般都是解决的2D以上且某一维成环而另一维只有小的对大的产生影响的```dp```的，而对于所有的成环问题，```gauss```消元才是通法。

这个题怎么消呢，这是个特别常见的套路，常用于期望题的骗分。大概就是你对每个AC自动机上的节点建一个方程，怎么建呢，如果```j```能通过```go[j][k]```转移到```i```,那么```i```这个方程第```j```项，系数就是```-p[k]```，第```i```个方程的第```i```项系数就是1，然后解这个方程组即可。

说句题外话，我猜测这个矩阵是一个稀疏矩阵，或许可以O(n ^ 2)地高斯消元，不过这个题暴力消元就能过。

具体细节请见代码。

```
#include<bits/stdc++.h>
using namespace std;
#define eps 1e-9
#define maxn 105
#define A go[now][s[i] - 'A']
#define For(i, j, n) for(register int i = j ; i <= n ; ++i)
int n, m, l, tot, dfn[maxn], vis[maxn], fail[maxn], go[maxn][20];
double u, v, p[maxn], c[maxn][maxn];
string s;

inline void insert(string s, int x){
	int now = 0;
	For(i, 0, l - 1) A = A ? A : ++tot, now = A; 
	dfn[x] = now, vis[now] = 1;
}
inline void build(){
	queue<int>q;
	For(i, 0, m - 1) if(go[0][i]) q.push(go[0][i]); 
	while(!q.empty()){
		int u = q.front(); q.pop();
		For(i, 0, m - 1){
			if(go[u][i]) fail[go[u][i]] = go[fail[u]][i], q.push(go[u][i]);
			else go[u][i] = go[fail[u]][i]; 
		}
	}
}
inline void start(){
	c[0][tot + 1] = 1;
	For(i, 0, tot){
		c[i][i] = 1;
		if(!vis[i]) For(j, 0, m - 1) c[go[i][j]][i] -= p[j];
	}
}

inline void gauss(){
	For(i, 0, tot){
		int tmph = i;
		For(j, i + 1, tot) if(fabs(c[tmph][i]) < fabs(c[j][i])) tmph = j;
		if(i ^ tmph) swap(c[i], c[tmph]);
		double tmp = c[i][i];
		if(fabs(tmp) < eps) continue;
		For(j, i + 1, tot + 1) c[i][j] /= tmp;
		For(j, 0, tot){
			if(i ^ j){
				tmp = c[j][i];
				For(k, i, tot + 1) c[j][k] -= c[i][k] * tmp;
			}
		}
	}
}

int main(){
	scanf("%d %d %d", &n, &l, &m);
	For(i, 0, m - 1) scanf("%lf %lf", &u, &v), p[i] = u / v;
	For(i, 1, n) cin >> s, insert(s, i);
	build(), start(), gauss();
	For(i, 1, n) printf("%.2lf\n", c[dfn[i]][tot + 1]);
	return 0;
}
```

---

## 作者：tommy0221 (赞：2)

[P6125 [JSOI2009]有趣的游戏](https://www.luogu.com.cn/problem/P6125)

废话：

因为太久没搞 PGF 调了四个小时，最后在 $\color{black}{\texttt{z}}\color{red}{\texttt{houkangyang}}$ 的指导下调了出来。调的过程中答应某同学调出来就写题解，因为这种做法不需要 ACAM 并且复杂度更小，然后就来发题解了qwq……orz zhouakngyang！

--------------------

如果做过 [P4548 [CTSC2006]歌唱王国](https://www.luogu.com.cn/problem/P4548) 和 [P3706 [SDOI2017]硬币游戏](https://www.luogu.com.cn/problem/P3706) 会发现这题几乎一样。

设 $n$ 个生成函数 $F_i(x)$，$[x^k]F_i(x)$ 表示第 $i$ 个人在第 $k$ 轮获胜的概率。

再设一个生成函数 $G(x)$，$[x^k]G(x)$ 表示游戏在第 $k$ 轮仍未结束的概率。

接下去可以得到若干等式：

$$
\sum_{i=1}^{n} F_i(x)+G(x)=xG(x)+1
$$

即在第 $i - 1$ 轮没有结束的概率等于在第 $i$ 轮结束的概率加上没结束的概率，或许写成 $f_i+g_i=g_{i-1}$ 更好理解。

然后对于每一个 $1\le i\le n$ 都可以列出下面的等式

$$
G(x)x^lP_{i, 1, l}=\sum_{j=1}^{n}\sum_{k=1}^{l}[S_i[1,k]=S_j[l-k+1,l]]F_j(x)x^{l - k}P_{i,l - k + 1, l}
$$

其中 $P_{i,l, r}$ 表示出现 $S_i[l, r]$ 的概率。

等式左边的含义是给没结束的字符串接上一个字符串让他结束，但是也会存在撞上另一个人的串导致提前结束的情况。

等式右边就是所有可以结束的状况的和。一个串 $j$ 已经结束之后又接上了 $S_i[1,l - k]$ 所以除掉 $P_{i,l - k + 1, l}$。

可以发现两边组合意义相同。

因为个人习惯，把 $P$ 的定义改成前缀和，减小一些常数，即 $P_{i,k}$ 表示出现 $S_i[1,k]$ 的概率，化简一下可以得到：
$$
G(x)x^l=\sum_{j=1}^{n}\sum_{k=1}^{l}[S_i[1,k]=S_j[l-k+1,l]]F_j(x)x^{l - k}/P_{i,k}
$$
然后注意到每个人获胜的概率就是 $F_i(1)$，那么把 $x=1$ 带进去。

$$
\sum_{i=1}^{n} F_i(1)=1
$$

$$
G(1)=\sum_{j=1}^{n}\sum_{k=1}^{l}[S_i[1,k]=S_j[l-k+1,l]]F_j(x)/P_{i,k}
$$

$n+1$ 个方程 $n+1$ 个未知数直接高斯消元，复杂度 $O(n^3)$。

注意到这个方程在所有串都不可能得到的情况下会无解要特判。然后还有一堆奇怪的边界要注意，看个人写法了，主要是除以 $0$ 的情况要小心。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define fi first
#define se second
#define mkp(x,y) make_pair(x,y)
#define pb(x) push_back(x)
#define sz(v) (int)v.size()
typedef long long LL;
typedef double db;
template<class T>bool ckmax(T&x,T y){return x<y?x=y,1:0;}
template<class T>bool ckmin(T&x,T y){return x>y?x=y,1:0;}
#define rep(i,x,y) for(int i=x,i##end=y;i<=i##end;++i)
#define per(i,x,y) for(int i=x,i##end=y;i>=i##end;--i)
inline int read(){
	int x=0,f=1;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')f=0;ch=getchar();}
	while(isdigit(ch))x=x*10+ch-'0',ch=getchar();
	return f?x:-x;
}
const int N = 13;
const int base = 11;
const int mod = 20050103;// tommy0103/qq
//忽然发现不用取模，但是上面那行不想删了（ 
int n, l, m, s[N][N];
db p[N], P[N][N], a[N][N], ans[N];
LL H[N][N], pw[N];
inline LL getHash(int i, int l, int r) {
	return H[i][r] - H[i][l - 1] * pw[r - l + 1];
}
inline void Gauss(int n) {
	rep(i, 1, n) {
		int mx = i;
		rep(j, i + 1, n) if(fabs(a[j][i]) > fabs(a[mx][i])) mx = j;
		if(mx != i) { rep(j, 1, n + 1) swap(a[mx][j], a[i][j]); }
		rep(j, 1, n) {
			if(i == j) continue;
			db d = a[j][i] / a[i][i];
			rep(k, i, n + 1) a[j][k] -= a[i][k] * d;
		}
	}
	rep(i, 1, n) ans[i] = a[i][n + 1] / a[i][i];
}
signed main() {
	n = read(), l = read(), m = read();
	rep(i, 1, m) p[i] = read(), p[i] /= read();
	pw[0] = 1;
	rep(i, 1, l) pw[i] = pw[i - 1] * base;
	rep(i, 1, n) {
		static char str[N];
		scanf("%s", str + 1), P[i][0] = 1;
		rep(j, 1, l)
			s[i][j] = str[j] - 'A' + 1,
			H[i][j] = H[i][j - 1] * base + s[i][j],
			P[i][j] = P[i][j - 1] * p[s[i][j]];
	}
	bool flg = 1;
	rep(i, 1, n) {
		if(P[i][l] < 1e-11) {
			a[i][i] = 1;
			continue;
		}
		flg = 0;
		rep(j, 1, n) if(P[j][l] > 1e-11) {
			rep(k, 1, l) if(getHash(i, 1, k) == getHash(j, l - k + 1, l))
				a[i][j] += 1. / P[i][k];
		}
		a[i][n + 1] = -1, a[i][n + 2] = 0;
	}
	if(flg) {
		rep(i, 1, n) puts("0.00");
		return 0;
	}
	rep(i, 1, n) a[n + 1][i] = 1;
	a[n + 1][n + 1] = 0, a[n + 1][n + 2] = 1;
	Gauss(n + 1);
	rep(i, 1, n) printf("%.2lf\n", ans[i] < 1e-5 ? 0. : ans[i]);
	return 0;
}
````





---

## 作者：Leasier (赞：1)

前置芝士：[AC 自动机](https://oi-wiki.org/string/ac-automaton/)、[高斯消元](https://oi-wiki.org/math/gauss/)

看到字符串匹配，考虑 AC 自动机。对所有字母排列建出 AC 自动机后，不难想到对每个人分开处理。对于第 $i$ 个人，设 $dp_j$ 表示现在位于 Trie 树上的 $j$ 号节点时，第 $i$ 个人获胜的概率。

初值：$j$ 号节点代表的字符串为 $i$ 时，$dp_j = 1$；$j$ 号节点有字符串且代表的字符串不为 $i$ 时，$dp_j = 0$.

转移：$dp_j = \displaystyle\sum_{k = 1}^m (\frac{p_k}{q_k}) dp_{nxt_{j, k}}$。

答案：$dp_1$。

容易发现，这样转移会出现环，高斯消元即可。时间复杂度为 $O(n^2 ml + n^4l^3)$。

注意本题卡精度，eps 需要开到 $10^{-11}$ 才能 AC。

代码：
```cpp
#include <iostream>
#include <queue>
#include <cstdio>
#include <cstring>
#include <cmath>

using namespace std;

typedef long double ld;

typedef struct {
	int pos;
	int nxt[17];
} Node;

typedef struct Matrix_tag {
	int n;
	int m;
	ld a[107][107];
	Matrix_tag(int n_, int m_){
		n = n_;
		m = m_;
		memset(a, 0, sizeof(a));
	}
} Matrix;

const ld eps = 1e-11L;
int cnt = 1;
int fail[107];
ld prob[17];
char s[17];
Node tree[107];
queue<int> q;

inline void insert(char s[], int pos){
	int len = strlen(&s[1]), i = 1;
	for (register int j = 1; j <= len; j++){
		int ch = s[j] - 'A' + 1;
		if (tree[i].nxt[ch] == 0) tree[i].nxt[ch] = ++cnt;
		i = tree[i].nxt[ch];
	}
	tree[i].pos = pos;
}

inline void build(int n){
	fail[1] = 1;
	for (register int i = 1; i <= n; i++){
		if (tree[1].nxt[i] == 0){
			tree[1].nxt[i] = 1;
		} else {
			fail[tree[1].nxt[i]] = 1;
			q.push(tree[1].nxt[i]);
		}
	}
	while (!q.empty()){
		int cur = q.front();
		q.pop();
		for (register int i = 1; i <= n; i++){
			if (tree[cur].nxt[i] == 0){
				tree[cur].nxt[i] = tree[fail[cur]].nxt[i];
			} else {
				fail[tree[cur].nxt[i]] = tree[fail[cur]].nxt[i];
				q.push(tree[cur].nxt[i]);
			}
		}
	}
}

inline int gauss(Matrix &a){
	int ni = a.n + 1, i = 1, j = 1;
	for (; i <= a.m && j <= a.n; i++, j++){
		int t1 = i;
		for (register int k = i + 1; k <= a.m; k++){
			if (fabs(a.a[t1][j]) < fabs(a.a[k][j])) t1 = k;
		}
		if (i != t1) swap(a.a[i], a.a[t1]);
		if (fabs(a.a[i][j]) < eps){
			i--;
			continue;
		}
		for (register int k = i + 1; k <= a.m; k++){
			ld t2 = a.a[k][j] / a.a[i][j];
			for (register int l = j; l <= ni; l++){
				a.a[k][l] -= t2 * a.a[i][l];
			}
		}
	}
	if (i <= a.m){
		for (; i <= a.m; i++){
			if (fabs(a.a[i][j]) > eps) return 0;
		}
		return 0x7fffffff;
	}
	for (register int k = a.n; k >= 1; k--){
		for (register int l = k + 1; l <= a.n; l++){
			a.a[k][ni] -= a.a[k][l] * a.a[l][ni];
		}
		a.a[k][ni] /= a.a[k][k];
	}
	return 1;
}

int main(){
	int n, l, m, cnt_i;
	cin >> n >> l >> m;
	for (register int i = 1; i <= m; i++){
		int p, q;
		cin >> p >> q;
		prob[i] = 1.0 * p / q;
	}
	for (register int i = 1; i <= n; i++){
		cin >> &s[1];
		insert(s, i);
	}
	cnt_i = cnt + 1;
	build(m);
	for (register int i = 1; i <= n; i++){
		Matrix a(cnt, cnt);
		for (register int j = 1; j <= cnt; j++){
			a.a[j][j] = 1.0;
			if (tree[j].pos == i){
				a.a[j][cnt_i] = 1.0;
			} else if (tree[j].pos == 0){
				for (register int k = 1; k <= m; k++){
					a.a[j][tree[j].nxt[k]] -= prob[k];
				}
			}
		}
		gauss(a);
		printf("%.2Lf\n", a.a[1][cnt_i]);
	}
	return 0;
}
```

---

## 作者：wxzzzz (赞：0)

把机器产生的所有可能序列画出来，会得到一棵 dfs 树，每个点上都有一个字符串。

注意到当这个字符串匹配到了某个人的字母序列后它的子树就都归为这个人，并且后面的人都不能取这颗子树。

一棵子树被取的概率是能算出来的，可以模拟机器一个个加字符，在自动机上转移概率，如果一个能被人取的点有了概率，则这个人取走该子树，将概率清零。

这个过程形如概率在有向图上的流动，流动到一些点时被取走。

但字符串长度是无限的，需要卡时使答案更精确。

最后还会有一些概率没有被取走，那就把所有概率除一个被取走的总概率。

注意特判所有概率均为 $0$。

```cpp
f[0] = 1;
while (clock() * 1.0 / CLOCKS_PER_SEC < 0.9) {
    for (ll i = 0; i <= idt; i++)
        g[i] = f[i], f[i] = 0;
    for (ll i = 0; i <= idt; i++)
        for (ll j = 0; j < m; j++)
            f[t[i][j]] += g[i] * a[j] / b[j];
    for (ll i = 1; i <= n; i++) {
        if (f[pos[i]])
            h[i] += f[pos[i]];
        f[pos[i]] = 0;
    }
}
double sum = 0;
for (ll i = 1; i <= n; i++)
    sum += h[i];
for (ll i = 1; i <= n; i++)
    printf("%.2lf\n", sum == 0 ? 0 : h[i] / sum);
```

---


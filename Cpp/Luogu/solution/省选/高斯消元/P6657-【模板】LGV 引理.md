# 【模板】LGV 引理

## 题目描述

这是一道模板题。

有一个 $n\times n$ 的棋盘，左下角为 $(1,1)$，右上角为 $(n,n)$，若一个棋子在点 $(x,y)$，那么走一步只能走到 $(x+1,y)$ 或 $(x,y+1)$。

现在有 $m$ 个棋子，第 $i$ 个棋子一开始放在 $(a_i,1)$，最终要走到 $(b_i,n)$。问有多少种方案，使得每个棋子都能从起点走到终点，且对于所有棋子，走过路径上的点互不相交。输出方案数 $\bmod\ 998244353$ 的值。

两种方案不同当且仅当存在至少一个棋子所经过的点不同。

## 说明/提示

- 对于 $30\%$ 的数据，$n\leq 100$，$m\leq 8$。 

- 对于 $100\%$ 的数据，$T\leq5$，$2\leq n\leq10^6$，$1\leq m\leq100$，$1\leq a_1\leq a_2\leq \dots\leq a_m\leq n$，$1\leq b_1\leq b_2\leq \dots\leq b_m\leq n$。

## 样例 #1

### 输入

```
3
3 2
1 2
2 3
5 2
1 3
3 5
10 5
3 5
4 7
5 8
7 9
9 10```

### 输出

```
3
155
2047320```

# 题解

## 作者：王鲲鹏 (赞：57)

## LGV 引理（Lindstrom-Gessel-Viennot lemma）

本文主要分为对 引理的阐述与证明 和 这道题的解法。~~然鹅OIer 不需要证明~~。

### LGV 引理 内容

* $G$ 是一个有限的带权有向无环图。每个顶点的度是有限的，不存在有向环（所以路径数量是有限的）。
* 起点 $A=\{a_1,\cdots,a_n\}$，终点 $B=\{b_1,\cdots,b_n\}$。
* 每条边 $e$ 有权 $w_e$，并假定值属于某 [交换环](https://zh.wikipedia.org/wiki/%E4%BA%A4%E6%8D%A2%E7%8E%AF) 。
* 对于一个有向路径 $P$，定义 $\omega(P)$ 为路径上所有边权的积。
* 对任意顶点 $a$，$b$，定义 $e(a,b)=\sum\limits_{P:a \to b}{\omega(P)}$。

设矩阵
$$
M=
\begin{pmatrix}
e(a_1,b_1) & e(a_1,b_2) & \cdots & e(a_1,b_n) \\
e(a_2,b_1) & e(a_2,b_2) & \cdots & e(a_2,b_n) \\
\vdots & \vdots & \ddots & \vdots \\
e(a_n,b_1) & e(a_n,b_2) & \cdots & e(a_n,b_n) \\
\end{pmatrix}
$$
从 $A$ 到 $B$ 的不相交路径 $P=(P_1,P_2,\cdots,P_n)$，$P_i$ 表示从 $a_i$ 到 $b_{\sigma(i)}$ 的一条路径，其中 $\sigma$ 是一个排列（置换），并且满足对任意 $i\not=j$，$P_i$ 与 $P_j$ 没有公共点。记 $\sigma(P)$ 表示 $P$ 对应的排列。

引理说明，$M$ 的行列式是所有从 $A$ 到 $B$ 的不相交路径 $P=(P_1,\cdots,P_n)$ 的带符号和。其中符号指 $\sigma(P)$ 的逆序数的奇偶性： $(-1)^{\text{逆序数}}$，记为 $\mathrm{sign}(\sigma(P))$。
$$
\mathrm{det}(M)=\sum_{P:A\to B}{\mathrm{sign}(\sigma(P))\prod_{i=1}^{n}\omega(P_i)}
$$

### 证明

对一组路径 $P$，若对任意 $i\not=j$，$P_i$ 与 $P_j$ 无公共点，则称 $P$ 是一组不相交路径，否则为一组相交路径。为了简便，在下面相交路径记作 $P^c$，不相交路径记作 $P^u$。不做特殊说明时，$P$ 为一组平凡的路径。当带下标时，指一条路径。定义 $\omega(P)=\omega(P_1)\omega(P_2)\cdots\omega(P_n)$。

根据定义，
$$
\begin{aligned}
\mathrm{det}(M)
&=\sum_{\sigma \in S_n}\mathrm{sign}(\sigma)\prod_{i=1}^{n}e(a_i,b_{\sigma(i)}) \\
&=\sum_{\sigma \in S_n}\mathrm{sign}(\sigma)\prod_{i=1}^{n}\sum_{P_i:a_i \to b_{\sigma(i)}}\omega(P_i)
\end{aligned}
$$
$\prod_{i=1}^{n}\sum_{P_i:a_i \to b_{\sigma(i)}}\omega(P_i)$ 展开后对应所有排列为 $\sigma$ 的路径组 $P$ ，
$$
\begin{aligned}
\mathrm{det}(M)
&=\sum_{\sigma \in S_n}\mathrm{sign}(\sigma)\sum_{P}\omega(P),P:(a_1,\cdots,a_n)\to(b_{\sigma(1)},\cdots,b_{\sigma(n)}) \\
&= \sum_{P:A \to B}\mathrm{sign}(\sigma(P))\omega(P)
\end{aligned}
$$
现在等式的形式已与定理相像，但是 $P$ 的含义不同。
$$
\mathrm{det}(M)=
\sum_{P^u:A \to B}\mathrm{sign}(\sigma(P^u))\omega(P^u)+\sum_{P^c:A \to B}\mathrm{sign}(\sigma(P^c))\omega(P^c)
$$
故若引理成立，必有 $\sum_{P^c:A \to B}\mathrm{sign}(\sigma(P^c))\omega(P^c)=0$ 。

设 $C$ 为所有 $P^c$ 构成的集合。如果我们能构造一个双射关系 $f:C \to C$，满足对任意 $P^c\in C$， $\omega(f(P^c))=\omega(P^c)$，$\mathrm{sign}(\sigma(f(P^c)))=-\mathrm{sign}(\sigma(P^c))$，根据重排列定理，
$$
\sum_{P^c}\mathrm{sign}(\sigma(P^c))\omega(P^c)
=\sum_{P^c}\mathrm{sign}(\sigma(f(P^c)))\omega(f(P^c))
$$

$$
\begin{aligned}
\sum_{P^c}\mathrm{sign}(\sigma(P^c))\omega(P^c)
&= \frac{1}{2}\sum_{P^c}\mathrm{sign}(\sigma(P^c))\omega(P^c)+\frac{1}{2}\sum_{P^c}\mathrm{sign}(\sigma(f(P^c)))\omega(f(P^c)) \\
&= \frac{1}{2}\sum_{P^c}\mathrm{sign}(\sigma(P^c))\omega(P^c)+\frac{1}{2}\sum_{P^c}-\mathrm{sign}(\sigma(P^c))\omega(P^c) \\
&= 0
\end{aligned}
$$

确实可以构造：

考虑 $P=(P_1,P_2,\cdots,P_n)$，$P \in C$，中找到最小的二元组 $(i,j)$ 满足 $P_i$ 和 $P_j$ 有交，将相交之后的路径交换一下，交换后得到 $P'$ 。显然有 $P' \in C$，$P' \not= P$。

![](https://cdn.luogu.com.cn/upload/image_hosting/p2p9qmk6.png)
![](https://cdn.luogu.com.cn/upload/image_hosting/0d84mct2.png)

这里就不写式子了 可以直观理解一下 ~~就是因为懒~~，因为边还是那些边，边权属于交换环，所以 $\omega(P)$ 不变。另一个影响是交换了两条路径的终止节点，即交换了排列中的两个元素，~~根据我们学前班就学过的线性代数~~，逆序对数的奇偶改变，所以 $\mathrm{sign}(\sigma(P'))=-\mathrm{sign}(\sigma(P))$。

最后我们还可以注意到，对于 $P'$，最小的二元组还应该是 $(i,j)$，那么 $f(P')=P$。籍此可证 $f$ 是双射。

证毕。

~~完结撒花lalala~~ 

~~差点忘了这道题还没有说...~~

#### [LuoguP6657](https://www.luogu.com.cn/problem/P6657) 模板

好像比定理削了好多东西...

因为这是在方格图上，因为坐标是单调的，当 $\sigma \not=(1,2,\cdots,n)$ 时，显然不存在不相交路径。
$$
\text{右式}=\sum_{P:(P_i:a_i\to b_i)}1
$$
即为所求。

那么构造矩阵，$e(a_i,b_j)=\binom{b_j-a_i+n-1}{n-1}$。高斯消元求行列式即可。



#### 参考资料

1. [维基百科](https://en.wikipedia.org/wiki/Lindstr%C3%B6m%E2%80%93Gessel%E2%80%93Viennot_lemma) 挺详细的就是没中文...
2. [OI Wiki](https://oi-wiki.org/graph/lgv/).


真·完结撒花~~~

---

update 2021-05-27 感谢 @oisdoaiu 的指正

---

## 作者：歌吟入梦 (赞：16)

还没人写题解，我来写一发占个位。

考虑经典容斥，枚举哪些人的路径相交了。

相交的路径可以转化为，在相交点将两个人之后的路径取反，最终是第一个人走到第二个人的终点去了，第二个人走到第一个人的终点去了。

直接这样容斥复杂度是 O(n!) 的。

进一步观察可以发现，容斥的系数就是逆序对的奇偶性，这和行列式的定义完全一样。

我们可以求出每个起点到每个终点的方案数，组成一个矩阵，求出来行列式就是答案。

求出每个点到每个点的方案数，使用经典容斥的方法。最终复杂度$O(pq^2+q^3)$

至于如何$O(n^3)$求n×n行列式的值，安利一篇[博客](https://blog.csdn.net/a_forever_dream/article/details/104925226)

下面贴上本人巨丑无比的代码：
```cpp
#include<cstdio>
#include<iostream>
using namespace std;
template<class T>inline void read(T&a){
	char c=getchar();int f=1;a=0;
	while(c>'9'||c<'0'){if(c=='-') f=-1;c=getchar();}
	while(c<='9'&&c>='0') a=(a<<1)+(a<<3)+c-48,c=getchar();
	a*=f;
}
template<class T>void write(T a){
	if(a<0) putchar('-'),a=-a;
	if(a>9) write(a/10);
	putchar(a%10+48);
}
const int o=110,MOD=998244353,N=2e6+10;
#define int long long
int T,n,m,a[o],b[o],f[o][o],fac[N],inv[N];
int qp(int b,int f){
	if(!f) return 1;
	int rcd=qp(b,f>>1);
	return (f&1)?rcd*rcd%MOD*b%MOD:rcd*rcd%MOD;
}
inline int Inv(int x){return qp(x,MOD-2);}
inline int C(int x,int y){if(x<y) return 0;return fac[x]*inv[y]%MOD*inv[x-y]%MOD;}
inline int det(){
	int res=1,r,d,cnt=0;
	for(int i=1;i<=m;++i){
		r=0;
		for(int j=i;j<=m;++j) if(f[j][i]) r=j;
		if(!r) return 0;
		if(i^r){++cnt;for(int j=i;j<=m;++j) f[i][j]^=f[r][j]^=f[i][j]^=f[r][j];}
		for(int j=i+1;j<=m;++j){d=f[j][i]*Inv(f[i][i])%MOD;for(int k=i;k<=m;++k) f[j][k]=(f[j][k]-f[i][k]*d%MOD+MOD)%MOD;}
		res=res*f[i][i]%MOD;
	}
	return (res*qp(-1,cnt)%MOD+MOD)%MOD;
}
signed main(){
	read(T);for(int i=fac[0]=inv[0]=1;i<N;++i) inv[i]=Inv(fac[i]=fac[i-1]*i%MOD);
	while(T--){
		read(n);read(m);
		for(int i=1;i<=m;++i) read(a[i]),read(b[i]);
		for(int i=1;i<=m;++i) for(int j=1;j<=m;++j) f[i][j]=C(n-1+b[j]-a[i],n-1);
		write(det());putchar('\n');
	}
	return 0;
}
```

---

## 作者：wsyhb (赞：13)

## 前言

为了使文章更加简洁，本文省略了有关 LGV 引理的定义，若有需要请前往 [LGV 引理 - OI Wiki](https://oi-wiki.org/graph/lgv/#_2) 以了解定义。

## 证明

先把 LGV 引理的式子写出来：

$$
M
=
\begin{bmatrix}
e(A_1,B_1) & e(A_1,B_2) & \cdots & e(A_1,B_n) \\
e(A_2,B_1) & e(A_2,B_2) & \cdots & e(A_2,B_n) \\

\vdots & \vdots & \ddots & \vdots \\
e(A_n,B_1) & e(A_n,B_2) & \cdots & e(A_n,B_n)
\end{bmatrix}
$$

$$\det(M)=\sum_{S:A \rightarrow B}(-1)^{N(\sigma(S))}\prod_{i=1}^{n}w(S_i)$$

即

$$\sum_{p}(-1)^{N(p)}\prod_{i=1}^ne(A_i,B_{p_{_i}})=\sum_{S:A \rightarrow B}(-1)^{N(\sigma(S))}\prod_{i=1}^{n}w(S_i)$$

（其中 $p$ 为 $1$ 到 $n$ 的排列）

等式左边相当于选 $n$ 条起点和终点分别互不相同的路径——设第 $i$ 个起点对应的是第 $p_i$ 个终点，若 $p$ 逆序对个数为偶数则系数为 $1$，否则系数为 $-1$。

等式右边几乎完全一样，只是多了 $n$ 条路径互不相交的限制。

因此，我们考虑存在路径相交的情况（此处路径相交不包括：起点或终点相同），可以发现：**每一个偶数个逆序对的方案，与另一个奇数个逆序对的方案一一对应**。

对应方法有很多种，此处举个例子：

对于一个存在路径相交的偶数个逆序对的方案，选出其中与其他路径相交的起点编号最小的路径 $x$，再选出与 $x$ 相交的起点编号最小的路径 $y$，然后选出 $x$ 和 $y$ 的公共点中最靠近终点的点 $p$，将 $p$ 到两个终点之间的部分互换，那么逆序对个数会变成奇数。

因此引理得证。

------------

交换排列中的两个值，逆序对个数奇偶性会不同的证明：

设排列为 $p$，交换的位置编号为 $x$ 和 $y$，其中 $x<y$，则 $p_x,p_y$ 与另外某个数 $p_i$ 贡献的逆序对个数有以下几种情况：

- 对于 $i<x$ 或 $i>y$，$p_i$ 与值 $p_x,p_y$ 的相对位置在交换前后均未改变。
- 对于 $x<i<y$
	- 若 $p_i<p_x,p_y$ 或 $p_i>p_x,p_y$，则 $p_i$ 与 $p_x,p_y$ 贡献的逆序对个数在交换前后均为 $1$。
    - 若 $\min(p_x,p_y)<p_i<\max(p_x,p_y)$
    	- 若 $p_x<p_y$，则 $p_i$ 与 $p_x,p_y$ 贡献的逆序对个数交换前后分别为 $0,2$。
        - 若 $p_x>p_y$，则 $p_i$ 与 $p_x,p_y$ 贡献的逆序对个数交换前后分别为 $2,0$。

上述情况奇偶性均未变化，且 $p_x$ 和 $p_y$ 之间贡献的逆序对要么从无到有，要么从有到无，证毕。

------------

## 题解

注意到条件 $a_1 \le a_2 \le \cdots \le a_m$ 和 $b_1 \le b_2 \le \cdots \le b_m$，这说明只要路径不相交就一定有 $(a_i,1)$ 对应的终点是 $(b_i,n)$。

因此所有不相交路径方案的系数恒为 $1$，直接套用 LGV 引理即可。

$e$ 的计算方法：从 $(a,b)$ 到 $(c,d)$ 方案数为 $C_{c-a+d-b}^{c-a}$。

行列式的计算方法：高斯消元。

总时间复杂度 $O(n+m^3)$。

## 代码

``` cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
const int max_n=1e6+5;
int fac[max_n<<1],inv[max_n<<1],inv_fac[max_n<<1],now=1;
const int max_m=100+5;
int a[max_m],b[max_m];
const int mod=998244353;
inline int qpow(int a,int n)
{
	int res=1;
	while(n)
	{
		if(n&1)
			res=1ll*res*a%mod;
		a=1ll*a*a%mod;
		n>>=1;
	}
	return res;
}
inline int C(int n,int m)
{
	return 1ll*fac[n]*inv_fac[m]%mod*inv_fac[n-m]%mod;
}
int M[max_m][max_m];
inline int det()
{
	int res=1;
	bool flag_neg=false;
	for(int i=1;i<=m;++i)
	{
		int k=i;
		while(k<=m&&!M[k][i])
			++k;
		if(k>m)
			return 0;
		if(k!=i)
		{
			for(int j=i;j<=m;++j)
				swap(M[i][j],M[k][j]);
			flag_neg^=1;
		}
		res=1ll*res*(M[i][i]+mod)%mod;
		int t=qpow(M[i][i],mod-2);
		for(int k=i+1;k<=m;++k)
		{
			int t0=1ll*t*M[k][i]%mod;
			for(int j=i;j<=m;++j)
				M[k][j]=(M[k][j]-1ll*M[i][j]*t0)%mod;
		}
	}
	return flag_neg?mod-res:res; 
}
int main()
{
	fac[0]=inv_fac[0]=1;
	fac[1]=inv_fac[1]=inv[1]=1;
	int T;
	scanf("%d",&T);
	while(T--)
	{
		scanf("%d%d",&n,&m);
		while(now<2*n)
		{
			++now;
			fac[now]=1ll*fac[now-1]*now%mod;
			inv[now]=1ll*(mod-mod/now)*inv[mod%now]%mod;
			inv_fac[now]=1ll*inv_fac[now-1]*inv[now]%mod;
		}
		for(int i=1;i<=m;++i)
			scanf("%d%d",a+i,b+i);
		for(int i=1;i<=m;++i)
			for(int j=1;j<=m;++j)
				M[i][j]=a[i]<=b[j]?C(b[j]-a[i]+n-1,n-1):0;
		printf("%d\n",det());
	}
    return 0;
}
```

---

## 作者：littlez_meow (赞：11)

感觉有的题解的双射构造稍微有一点点小问题啊。

[题目指路](https://www.luogu.com.cn/problem/P6657)。

## Part 1：LGV 引理
### 定义

在有向无环图 $G$ 中，定义：

$\omega(Q)=\prod\limits_{e\in Q} w_e$，即路径 $Q$ 中所有边的边权之积。

$e(u,v)=\sum\limits_{Q:u\to v}\omega(Q)$，即所有 $u$ 到 $v$ 的路径的 $\omega$ 之和。若将边权设为重边个数，则其意义为 $u$ 到 $v$ 的路径数，乘法原理易证。

起点集合 $A=\{a_1,a_2,\cdots,a_n\}$，终点集合 $B=\{b_1,b_2,\cdots,b_n\}$。

路径 $P_i$ 为从 $a_i$ 到 $b_{\sigma_i}$ 的路径，其中 $\sigma$ 为 $1\sim n$ 的全排列之一。

$I(\sigma)$ 为排列 $\sigma$ 的逆序对数。

路径组 $P=\{P_1,P_2,\cdots,P_n\}$，记为 $P:A\to B$。（相交或不相交请见上下文表述）

$\omega(P)=\prod\limits_{i=1}^n\omega(P_i)$
，即路径组 $P$ 中所有路径的权值积。
可以发现，排列 $\sigma$ 是 $P$ 的函数。记 $P$ 对应的排列为 $\pi(P)$。（改个符号以免看晕了）

### 内容

记矩阵 $M=\begin{bmatrix}
 e(a_1,b_1) & e(a_1,b_2) & \cdots & e(a_1,b_n)\\
 e(a_2,b_1) & e(a_2,b_2) & \cdots & e(a_2,b_n)\\
 \vdots & \vdots & \ddots & \vdots\\
 e(a_n,b_1) & e(a_n,b_2) & \cdots & e(a_n,b_n)
\end{bmatrix}$

则 $\det M=\sum\limits_{S:A\to B}(-1)^{I(\pi(S))}\prod\limits_{i=1}^n\omega(P_i)$。

此处 $S$ 为**不相交**路径组。

当边权为重边个数时，其意义为逆序对为偶数的不相交路径组数减逆序对为奇数的不相交路径组数。

### 证明

根据定义展开行列式，等式左边为：

$$\sum\limits_{\sigma}(-1)^{I(\sigma)}\prod\limits_{i=1}^n e(a_i,b_{\sigma_i})$$

再拆开 $e(u,v)$，得：

$$\sum\limits_{\sigma}(-1)^{I(\sigma)}\prod\limits_{i=1}^n\sum\limits_{T_i:a_i\to b_{\sigma_i}}\omega(T_i)$$

我们发现，$T=\{T_1,T_2,\cdots,T_n\}$ 是一个路径组，且 $\pi(T)=\sigma$。因此将枚举排列变为枚举路径组，这样就不用再次枚举路径 $T_i$，得到：

$$\sum\limits_{T:A\to B}(-1)^{I(\pi(T))}\prod\limits_{i=1}^n\omega(T_i)$$

此处 $T$ 为**任意**路径组。

现在，等式左右唯一区别为，等式左边是**不相交**路径组，等式右边是**任意**路径组。

记 $K,L$ 分别为相交、不相交路径组，有 $K\cap L=\varnothing,K\cup L=T$，所以得：

$$\sum\limits_{K:A\to B}(-1)^{I(\pi(T))}\prod\limits_{i=1}^n\omega(T_i)+\sum\limits_{L:A\to B}(-1)^{I(\pi(T))}\prod\limits_{i=1}^n\omega(T_i)$$

我们仅需证明 $\sum\limits_{K:A\to B}(-1)^{I(\pi(T))}\prod\limits_{i=1}^n\omega(T_i)=0$ 即可。

记相交路径组的集合为 $C$，我们只要构造一个双射 $f:C\to C$ 使得 $\forall K\in C,(-1)^{I(\pi(K))}\times(-1)^{I(\pi(f(K)))}=-1,\omega(K)=\omega(f(k))$，就可以得到求和式中所有正数项都有一个绝对值相等的负数项与之一一对应，和相互抵消成 $0$。

问题就转化为了构造这个双射。

让我们先尝试用[这篇题解](https://www.luogu.com.cn/blog/Wankupi/LGV-lemma)的方式构造：

1. 选择最小的二元组 $(i,j)$ 满足 $P_i$ 和 $P_j$ 相交。

2. 将 $P_i,P_j$ 交换首个交点到末尾的这部分路径，得到 $P'$。

3. 此时 $\pi(P')$ 相当于 $\pi(P)$ 进行了一次对换，逆序对个数奇偶性改变。

4. $P'$ 中再选择最小二元组，仍是 $(i,j)$，交换回来得到 $P$。

这样，就构造出了双射……吗？

让我们看看下面的例子：

![例1](https://cdn.luogu.com.cn/upload/image_hosting/nrc7ok65.png)

选择到最小二元组 $(1,3)$。

交换后得到下图：

![例2](https://cdn.luogu.com.cn/upload/image_hosting/xqj7uox5.png)

此时再次选择，得到的是 $(1,2)$ 而非 $(1,3)$！

也就是说，这样无法构造出双射！

我们应该换一种方法选择二元组。

$i$ 选择最小的没有什么问题，但是在交换后 $j$ 的最小值可能会改变。因此，我们不能以 $j$ 的大小来选择。

观察上面的图片，我们能发现，在 $j$ 变小的时候，交点会变远。简单想想就会发现这个是事实。因为若交点更近，第一次就会选到。（语文不好，感性理解理解，画画图）

所以，我们选择最小的 $i$ 使 $p_i$ 与别的路径有交点，再选择 $j$ 使得其交点离出发点 $a_i$ 最近，若有多个再选最小的 $j$，这样得到的 $(i,j)$ 就可以成为双射。

自此，证明结束。

## Part 2：本题

题目中给了 $a_1\le a_2\le\cdots\le a_m,b_1\le b_2\le\cdots\le b_m$，若路径不相交，就只能从 $(a_i,1)$ 到 $(b_i,n)$，也就是说 $\pi(S)$ 始终为 $1,2,\cdots,n$，逆序对为 $0$。因此，$(-1)^{I(\pi(S))}$ 没有任何影响，直接求行列式即可。

至于 $e(a_i,b_j)$，为网格图上最短路径总数，相当于从 $b_j-a_i+n-1$ 段中选 $n-1$ 段向右走。故 $e(a_i,b_j)=\binom{b_j-a_i+n-1}{n-1}$。

## Part 3：代码
```cpp
#include<bits/stdc++.h>
#define ll long long
#define F(i,a,b) for(int i(a),i##i##end(b);i<=i##i##end;++i)
#define R(i,a,b) for(int i(a),i##i##end(b);i>=i##i##end;--i)
#define _ 0
using namespace std;
const int MAX=101,MOD=998244353;
int n,m,T;
int a[101],b[101],M[101][101];
int fact[2000001],inv[2000001];
inline ll det(int t[MAX][MAX],int len,const int mod=MOD){
	ll res(1);
	F(i,1,len-1){
		F(j,i+1,len){
			while(t[i][i]){
				int delta=t[j][i]/t[i][i];
        		F(k,i,len) t[j][k]=(t[j][k]-(ll)delta*t[i][k]%mod+mod)%mod;
        		swap(t[i],t[j]);
        		res=~res+1;
			}
			swap(t[i],t[j]);
        	res=~res+1;
		}
	}
	F(i,1,len) res=res*t[i][i]%mod;
	return (res%mod+mod)%mod; 
}
inline ll qpow(ll base,int expo){
	ll res(1);
	while(expo){
		if(expo&1) res=res*base%MOD;
		base=base*base%MOD;
		expo>>=1;
	}
	return res;
}
inline ll C(int x,int y){
	return x>=y?1ll*fact[x]*inv[y]%MOD*inv[x-y]%MOD:0;
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	fact[0]=inv[0]=1;
	F(i,1,2000000) fact[i]=1ll*i*fact[i-1]%MOD;
	inv[2000000]=qpow(fact[2000000],MOD-2);
	R(i,2000000-1,1) inv[i]=1ll*inv[i+1]*(i+1)%MOD;
	for(cin>>T;T;--T){
		cin>>n>>m;
		F(i,1,m) cin>>a[i]>>b[i];
		F(i,1,m) F(j,1,m) M[i][j]=C(b[j]-a[i]+n-1,n-1);
		cout<<det(M,m)<<endl;
	}
	return ~~(0^_^0);
}
```
不喜勿喷qaq~

---

## 作者：Acoipp (赞：6)

# LGV 引理

## 定义

Lindström–Gessel–Viennot lemma 适用范围：有向无环图。

首先设 $w(P)$ 表示 $P$ 这条路径上的边权的乘积，如果是计数类问题我们可以把所有边权设为 $1$。

我们设 $e(u,v)$ 表示 $u$ 到 $v$ 的每一条路径的 $w(P)$ 之和，$A$ 为长度为 $n$ 的起点集合，$B$ 为长度为 $n$ 的终点集合。

设一组 $A$ 到 $B$ 的不相交集合 $S$ 为 $S_i$ 与 $S_j$ 没有公共端点，并且每一条路径恰好连接了 $A$ 中的一个数和 $B$ 中的一个数，而每个顶点也恰好只有一条路径连接它，由此可见 $S$ 的长度一定为 $n$，也即第 $i$ 条路径 $S_i$ 的起点是 $A_i$，终点是 $B_{p_i}$，$p$ 是长度为 $n$ 的排列，设 $\pi(p)$ 表示 $p$ 中逆序对的个数。

则有：
 
$$ M = \begin{bmatrix}e(A_1,B_1)&e(A_1,B_2)&\cdots&e(A_1,B_n)\\
e(A_2,B_1)&e(A_2,B_2)&\cdots&e(A_2,B_n)\\
\vdots&\vdots&\ddots&\vdots\\
e(A_n,B_1)&e(A_n,B_2)&\cdots&e(A_n,B_n)\end{bmatrix}$$
 
 

$$\det(M)=\sum\limits_{S:A\rightarrow B}(-1)^{\pi(p)}\prod\limits_{i=1}^n w(S_i)$$
其中 $\sum\limits_{S:A\rightarrow B}$ 表示满足上文要求的 $A\rightarrow B$ 的每一组不相交路径 $S$。

意思是什么呢？就是上面这个矩阵的行列式的值，等于所有可能的 $w(S)$ 的带符号和，如果 $w$ 恒为 $1$，那么就是所有合法的 $S$ 集合的带符号和。

## 证明

首先，由定义得：

$$
\begin{aligned}
\det(M)&=\sum\limits_{P:A\rightarrow B}(-1)^{\pi(p)}\prod\limits_{i=1}^n w(S_i) \\
&=\sum\limits_{P:A\rightarrow B}(-1)^{\pi(p)}\prod\limits_{i=1}^n \sum_{P:a_i \to b_{p_i}}w(P) \\
\end{aligned}
$$

我们可以发现通过乘法分配律展开之后，因为 $w(P)$ 中的 $P$ 可以是多条路径组合，所以就是 $\prod\limits_{i=1}^n \sum_{P:a_i \to b_{p_i}}w(P)=\sum_{P:p}w(P)$，表示所有起点集合和终点集合与 $p$ 相同的 $P$ 的和，$P$ 是任意路径组，不要求不相交。

所以：

$$
\begin{aligned}
\det(M)
&=\sum\limits_{p:A\rightarrow B}(-1)^{\pi(p)}\prod\limits_{i=1}^n \sum_{P:a_i \to b_{p_i}}w(P) \\
&=\sum\limits_{p:A\rightarrow B}(-1)^{\pi(p)}\sum_{P:p}w(P) \\
&=\sum\limits_{P:A\rightarrow B}(-1)^{\pi(p)}\prod_{i=1}^n w(P_i)\\
\end{aligned}
$$

到此时 $P$ 也是任意路径组合。

我们设 $U$ 是要求的集合，而 $V$ 是有相交的路径集合，那么有：

$$
\begin{aligned}
&\sum\limits_{P:A\rightarrow B}(-1)^{\pi(p)}\prod_{i=1}^n w(P_i)\\
=&\sum\limits_{U:A\rightarrow B}(-1)^{\pi(u)}\prod_{i=1}^n w(U_i)+\sum\limits_{V:A\rightarrow B}(-1)^{\pi(v)}\prod_{i=1}^n w(V_i)\\\\
\end{aligned}
$$

我们又可以发现：若 $P$ 存在两条相交的路径 $a_i \to u \to a_j,b_i \to u \to b_j$，那么一定有 $a_i \to u \to b_j,b_i \to u \to a_j$，这两个项符号相反，绝对值相同。（按照之前行列式交换两行的方式证明即可）

所以 $\sum\limits_{V:A\rightarrow B}(-1)^{\pi(v)}\prod_{i=1}^n w(V_i)=0$，那么 $\sum\limits_{P:A\rightarrow B}(-1)^{\pi(p)}\prod_{i=1}^n w(P_i)
=\sum\limits_{U:A\rightarrow B}(-1)^{\pi(u)}\prod_{i=1}^n w(U_i)$，由此，结论得证。

## 运用

如果是一张普通的有向无环图，是不可以直接运用 LGV 引理的，因为带符号会让问题变得不好处理。

当然，有一些特殊的图满足以下性质的话我们就可以使用 LGV 引理直接求：

- 需要求出对于每个 $i$ 找到 $a_i \to b_i$ 的路径，并且路径两两没有公共点。

- 如果排列 $p$ 中有逆序对，那么这些路径一定有交点。

根据 $S$ 的定义，这些情况不会被统计到答案中，因此我们可以直接计算。

例题参见 [LGV 引理](https://www.luogu.com.cn/problem/P6657)，这个图就满足上述两种情况，可以直接利用行列式求解。

方案数可以直接用组合数计算。

代码如下：

```cpp
#include<bits/stdc++.h>
#define ll long long
#define mod 998244353
#define N 605
#define M 5000005
using namespace std;
ll T,n,m,a[N],b[N],i,j,jc[M],inv[M],maps[N][N];
inline ll qmi(ll a,ll b,ll p){
	ll res = 1%p,t=a;
	while(b){
		if(b&1) res=res*t%p;
		t=t*t%p;
		b>>=1;
	}
	return res;
}
inline ll C(ll n,ll m){
	if(n<m) return 0;
	return jc[n]*inv[m]%mod*inv[n-m]%mod;
}
inline ll solve(ll n){
	ll i,j,k,has=0,ans=1,res;
	for(i=1;i<=n;i++){
		for(j=i+1;j<=n;j++){
			if(maps[j][i]>maps[i][i]) swap(maps[i],maps[j]),has^=1;
			res = maps[j][i]*qmi(maps[i][i],mod-2,mod)%mod;
			for(k=i;k<=n;k++) maps[j][k]=maps[j][k]-maps[i][k]*res,maps[j][k]=(maps[j][k]%mod+mod)%mod;
		}
	}
	if(i<=n) return 0;
	for(i=1;i<=n;i++) ans=ans*maps[i][i]%mod;
	if(has) ans=(mod-ans)%mod;
	return ans;
}
int main(){
	ios::sync_with_stdio(false);
	jc[0] = 1;
	for(i=1;i<=5e6;i++) jc[i]=jc[i-1]*i%mod;
	inv[5000000] = qmi(jc[5000000],mod-2,mod);
	for(i=5e6;i>=1;i--) inv[i-1]=inv[i]*i%mod;
	cin>>T;
	while(T--){
		cin>>n>>m;
		for(i=1;i<=m;i++) cin>>a[i]>>b[i];
		for(i=1;i<=m;i++) for(j=1;j<=m;j++) maps[i][j]=C(b[j]-a[i]+n-1,n-1);
		cout<<solve(m)<<endl;
	}
	return 0;
}
/*
Input:
3
3 2
1 2
2 3
5 2
1 3
3 5
10 5
3 5
4 7
5 8
7 9
9 10

Output:
3
155
2047320
*/
```

---

## 作者：Felix72 (赞：5)

尝试把这个代数推导用白话说一遍。

假设有一张**有向无环图**，每条边有一个边权，有 $n$ 个起点 $A_1, A_2, \dots, A_n$ 以及 $n$ 个终点 $B_1, B_2, \dots, B_n$。

定义**路径的权**为路径覆盖的每条边边权的乘积；

定义**路径组**为一组 $A$ 和 $B$ 以任意方式一一对应的路径，即路径 $A_1 \to B_{p_1}, A_2 \to B_{p_2}, \dots, A_n \to B_{p_n}$，其中 $p$ 是一个排列。可以发现，就算 $p$ 固定，通过选不同的路径，路径组也可能有很多种情况；

定义**路径组的权**为所有路径权值的乘积。

**不交路径组**为满足路径之间两两没有公共点的路径组。

有引理：

$$
M = 
\left[
\begin{matrix}
e(A_1, B_1) & e(A_1, B_2) & \cdots & e(A_1, B_n) \\
e(A_2, B_1) & e(A_2, B_2) & \cdots & e(A_2, B_n) \\
\vdots & \vdots & \ddots & \vdots \\
e(A_n, B_1) & e(A_n, B_2) & \cdots & e(A_n, B_n)
\end{matrix}
\right]
\\
\det(M) = \sum_{S:A \to B} (-1)^{t(\sigma(S))} \prod_{i = 1}^{n} \omega(S_i)
$$

这是 OI Wiki 上的式子。它具体是什么意思呢？

这其中 $e(x, y)$ 是 $x$ 到 $y$ 所有路径的权值和，$S$ 是枚举了所有可能的**不交路径组**，$t(\sigma(S))$ 表示 $S$ 对应的排列 $p$ 的逆序对数量，$\omega(S_i)$ 表示一条路径的权值。

这是如何推导来的？考虑顺着推，思考行列式在计算什么。我们发现行列式实际上是先选定了一个起点和终点的对应方式 $p$，然后把其中每个 $A_i \to B_{p_i}$ 的所有可能路径的权值加起来，再把和相乘。最后对于所有 $p$ 的值求带符号和（带符号和是说乘不乘 $-1$ 和 $p$ 逆序对的个数相关）。

考虑更换枚举顺序。上面这个先加起来再乘的操作容易让人不知道在干什么，因此用乘法分配律把这个操作拆了，上述过程就等价于先枚举 $p$，再枚举 $n$ 条路径（即一个路径组），分别是 $A_i \to B_{p_i}$，再把 $n$ 条路径的权值相乘，最后对所有乘积根据 $p$ 的逆序对个数求带符号和。

先枚举排列再考虑路径依旧没那么舒服，考虑先枚举一个路径组，再算出路径组的权值，最后根据路径组对应的 $p$ 算出这些权值的带符号和。

你再看看下面那个式子，是不是发现定义是一样的？

这时候有人就要问了：你还没保证路径不相交呢？好问题，但是你发现两条相交路径（设为 $S_1 \to p \to T_1$ 和 $S_2 \to p \to T_2$），他们可以映射到一组交换过的相交路径（即 $S_1 \to p \to T_2$ 和 $S_2 \to p \to T_1$），此时逆序对数量的奇偶性刚好改变，则所有相交路径组的权值和为 $0$，证毕。

---

## 作者：hfjh (赞：5)

# LGV引理

定义 $A$ 是起点集合 $\{a_1,a_2,...,a_n\}$。

$B$ 是终点集合 $\{b_1,b_2,...,b_n\}$。

定义 $\omega(P)$ 为路径 $P$ 每一条边权值的乘积，即：

$$
\omega(P) = \prod_{e \in P}w_e
$$

定义 $e(a,b)$ 表示点 $a\rightarrow b$ 所有路径 $P$ 的 $\omega(P)$ 之和，即：

$$
e(a,b) = \sum_{P:a \rightarrow b}\omega(P)
$$

定义 $\sigma$ 为 $1 \sim n$ 的一个任意全排列，定义 $P_i$ 代表  $a_i\rightarrow b_{\sigma_i}$ 一条路径。

设一个从 $A$ 到 $B$ 的路径集合 $L=\{P_1,P_2,P_3,...,P_n\}$。

> 注意当 $\sigma$ 一定时，路径集合 $L$ 可能不同( $a_i\rightarrow b_{\sigma(i)}$ 可能有多条路径)。

> (集合名称写成 $L$ 是为了避免后文出现歧义)。

定义 $t(L)$ 为关于路径集合 $L$ 的全排列 $\sigma$ 逆序对个数。

则定义： 

$$
\omega(L) = \prod_{P \in L}\omega(P)
$$

那我们可以知道**逆序对是偶数路径条数 $-$ 逆序对是奇数路径条数**答案是：

$$
\sum_{L:A\rightarrow B} (-1)^{t(L)}\prod_{i = 1}^n\omega(P_i)
$$

$L$ 是路径**均不相交**的路径集合。

这个答案如何求呢？

设矩阵：

$$
M = \begin{bmatrix}
e(a_1,b_1)~~e(a_1,b_2)~...~e(a_1,b_n)\\ 
e(a_2,b_1)~~e(a_2,b_2)~...~e(a_2,b_n)\\ 
\vdots~~~~~~~~~~~~~~~\vdots~~~~~~~~~~~~~~~~~~~~\vdots\\ 
e(a_n,b_1)~~e(a_n,b_2)~...~e(a_n,b_n)\\ 
\end{bmatrix}
$$

其实矩阵行列式就是答案：

$$
det(M) = \sum_{L:A\rightarrow B} (-1)^{t(L)}\prod_{P_i \in L}\omega(P_i)
$$

如何证明？

先考虑行列式的定义。

$$
det(M) = \sum_{\sigma}(-1)^{t(\sigma)}\prod_i^ne(a_i,b_{\sigma(i)})
$$

根据上文 $e(a,b)$ 定义推导一下。

$$
 \begin{aligned}
&det(M)\\
&=\sum_{\sigma}(-1)^{t(\sigma)}\prod_i^n\sum_{P_j:a_i 
\rightarrow b_{\sigma(i)}}\omega(P_j)
\\
&=\sum_{L:A\rightarrow B}(-1)^{t(\sigma)}\prod_{P_i \in L}\omega(P_i)
\end{aligned} 
$$

$$


$$


设 ![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "U")$U$ 为不相交路径组，![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "V")$V$ 为相交路径组。

$$

\sum_{L:A\rightarrow B}(-1)^{t(\sigma)}\prod_{P_i \in L}\omega(P_i)
~~=\sum_{U:A\rightarrow B}(-1)^{t(\sigma)}\prod_{U_i \in U}\omega(U_i) + 
\sum_{V:A\rightarrow B}(-1)^{t(\sigma)}\prod_{V_i \in V}\omega(V_i)

$$

假设一对相交路径：

$$
a_i \rightarrow u \rightarrow b_i~~~~~~~~~~~a_j \rightarrow u \rightarrow b_j
$$

必定存在一对相交路径：

$$
a_i \rightarrow u \rightarrow b_j~~~~~~~~~~a_j \rightarrow u \rightarrow b_i
$$

逆序对个数差 $1$，一个为正一个为负抵消。

于是

$$
\sum_{V:A\rightarrow B}(-1)^{t(\sigma)}\prod_{V_i \in V}\omega(V_i) = 0
$$
$$
\Rightarrow \sum_{L:A\rightarrow B}(-1)^{t(\sigma)}\prod_{P_i \in L}\omega(P_i)
=\sum_{U:A\rightarrow B}(-1)^{t(\sigma)}\prod_{U_i \in U}\omega(U_i)
$$

得证

$$
det(M) = \sum_{L:A\rightarrow B} (-1)^{t(L)}\prod_{P_i \in L}\omega(P_i)
$$

## P6657 【模板】LGV 引理 题解

### 题意描述

$n \times n$ 棋盘，$m$ 个棋子，第 $i$ 个棋子一开始放在 $(a_i​,1)$，最终要走到 $(b_i​,n)$。问有多少种方案，路径不能相交，求方案数。

保证 $1≤a_1​≤a_2​≤⋯≤a_m​≤n，1≤b_1​≤b_2​≤⋯≤b_m​≤n$。
### 题解

看到不相交，一眼 LGV ，我们看到保证部分，就可以知道他求的是逆序对数量为 0 的路径条数。并且有逆序对数量的路径条数一定为 0，就直接套模板了。

特别的，算 $e(a_i,b_j)$ 可以通过 $\binom {n - 1 + b_j - a_i} {n - 1}$。

原理是有 $n-1$ 条竖着走，有 $b_j - a_i$ 条横着走，求一下组合数就可以了。

### 代码

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int N = 2e6 + 10, M = 110,mod = 998244353;
int t, n, m, a[M], b[M];
ll pr[N], inv[N], s[M][M];
ll mpow(ll x, ll k)
{
    ll ans = 1;
    while(k)
    {
        if(k & 1) ans = ans * x % mod;
        x = x * x % mod;
        k >>= 1;
    }
    return ans;
}
void pre()
{
    pr[0] = 1;
    for(int i = 1; i <= N - 10; ++i)
        pr[i] = pr[i - 1] * i % mod;
    inv[N - 10] = mpow(pr[N - 10], mod - 2);
    for(int i = N - 11; i >= 0; --i)
        inv[i] = inv[i + 1] * (i + 1) % mod;
}
inline ll C(int a,int b)
{
    if(a < b) return 0;
    return pr[a] * inv[b] % mod * inv[a - b] % mod;
}
void input(){
    cin>>n>>m;
    for(int i = 1; i <= m; ++i)
        cin>>a[i]>>b[i];
    for(int i = 1; i <= m; ++i){
        for(int j = 1; j <= m; ++j){
            s[i][j] = C(n - 1 + b[j] - a[i],n - 1);
            // cout<<s[i][j]<<' ';
        }
        // cout<<'\n';
    }
}
ll op(){
    ll w = 1;
    for(int i = 1; i <= m; ++i){

        for(int j = i + 1; j <= m; ++j){

            while(s[i][i]){
                ll d = s[j][i] / s[i][i];
                for(int k = i; k <= m; ++k){
                    s[j][k] = (s[j][k] - s[i][k] * d % mod + mod) % mod;
                }
                swap(s[i], s[j]);
                w = -w;    
            }
            swap(s[i], s[j]);
            w = -w;
        }
    }    
    w = (w + mod) % mod;
    for(int i = 1; i <= m; ++i){
        w = w * s[i][i] % mod;
    }
    return w;
}
int main(){
    pre();
    cin>>t;
    while(t--){
        // qk();
        input();
        cout<<op()<<'\n';
    }
    return 0;
}
```


---

## 作者：zhenjianuo2025 (赞：4)

在一个 DAG $G=(V,E)$ 上，给定起点集合和终点集合 $S=\{s_1,\ldots,s_m\}$，$T=\{t_1,\ldots,t_m\}$。

设 $p$ 是一个 $m$ 阶排列，$\pi(p)$ 是 $p$ 的逆序对数。$P=\{P_1,P_2,\ldots,P_m\}$ 分别是从 $s_i$ 到 $t_{p_i}$ 的路径，$\rho(P)$ 是 $P$ 对应的排列 $p$。关于 $P$ 的性质 $\color{red}\mathrm F(P)$ 成立当且仅当 $m$ 条路径两两边无交。

构造矩阵 $\mathbf M=[d(s_i,t_j)]_{m\times m}$，其中 $d(s,t)$ 表示从顶点 $s$ 到顶点 $t$ 在 $G$ 上的路径数，证明：
$$
\sum_{\color{red}\mathrm F(P)} (-1)^{\pi[\rho(P)]}=\det\mathbf M
$$
组合意义：

$\det\mathbf M$ 实际上等于 $\displaystyle\sum(-1)^{\pi[\rho(P)]}$。现在证明 $\displaystyle\sum(-1)^{\pi[\rho(P)]}=\sum_{\color{red}\mathrm F(P)}(-1)^{\pi[\rho(P)]}$，即 $\displaystyle\sum_{\color{red}\neg\mathrm F(P)}(-1)^{\pi[\rho(P)]}=0$。

这个只需要构造双射就可以了。取字典序最小 $(i,j)$ 满足 $P_i$ 和 $P_j$ 有交，相交之后的路径交换一下得到 $\mathrm f(P)$。显然 $\mathrm f(P)\ne P,\mathrm f(\mathrm f(P))=P$，且 $\displaystyle(-1)^{\pi[\rho(P)]}+(-1)^{\pi[\rho(\mathrm f(P))]}=0$，轻松得证。

---

## 作者：do_it_tomorrow (赞：2)

[更差的阅读体验](https://www.doittomorrow.xyz/post/mo-ban-lgv-yin-li-de-ti-jie/)

## 定理内容

对于一条路径 $P$，设 $\omega(P)=\prod \limits_{i\in \text{edge of }P}w_i$，其中 $w$ 是边权，$e(x,y)=\sum\limits_{\forall P:x\to y} \omega(P)$。

对于计数问题边权可以设置为 $1$，对于轮廓线 DP 其实边权也可以是一些奇奇怪怪的函数。

有起点集合 $A$ 和终点集合 $B$，那么假设有一个排列 $\sigma$，路径 $P_i$ 就是 $A_i\to B_{\sigma(i)}$。

最后，设 $t(\sigma)$ 为 $\sigma$ 的逆序对数量，LGV 引理证明的就是下面的方阵 $M$ 满足：

$$\operatorname{Det}(M)=\sum\limits_{\forall S:A\to B}(-1)^{t(\sigma)}\prod\limits_{i=1}^n \omega(S_i)$$

$$M=\begin{vmatrix}
e(A_1,B_1)  & e(A_1,B_2)  & \cdots &  e(A_1,B_n)\\
e(A_2,B_1)  & e(A_1,B_3) & \cdots & e(A_2,B_n)\\
\vdots   &  \vdots&  \ddots &\vdots \\
e(A_n,B_1)  & e(A_n,B_2) & \cdots & e(A_n,B_n)
\end{vmatrix}$$

## 证明

其中 $S$ 表示表示从 $A$ 到 $B$ 所有的不相交的路径 $P$。

首先考虑行列式的定义，即对于一个 $n\times n$ 的方阵 $A$，其行列式为：

$$\operatorname{Det}(M)=\sum\limits_{\forall \sigma}(-1)^{t(\sigma)}\prod\limits_{i=1}^n a_{i,\sigma(i)}$$

其中 $\sigma$ 是一个 $1$ 到 $n$ 的排列。

具体到上面的矩阵，显然其行列式为：

$$\operatorname{Det}(M)=\sum\limits_{\forall \sigma}(-1)^{t(\sigma)}\prod\limits_{i=1}^n e(A_i,B_{\sigma(i)})$$
根据 $e(x,y)$ 的定义，其显然可以转化为：

$$\operatorname{Det}(M)=\sum\limits_{\forall \sigma} (-1)^{t(\sigma)}\prod\limits_{i=1}^n \sum\limits_{\forall P:A_i\to B_{\sigma(i)}}\omega(P)$$

根据乘法原理，上式的 $\prod\limits_{i=1}^n \sum\limits_{\forall P:A_i\to B_{\sigma(i)}}\omega(P)$ 就相当求解的是在所有的 $\forall i\in[1,n]\cap \mathbb {Z}\mid A_i\to B_{\sigma(i)}$ 的路径中，所有可能的路径的组 $P$ 的 $\sum\limits_{i=1}^n \omega(P_i)$ 的加和。

所以就可以继续化简得到：

$$\operatorname{Det}(M)=\sum\limits_{\forall \sigma} (-1)^{t(\sigma)} \sum\limits_{P=\sigma} \omega(P)$$
还是根据乘法原理，有可以得到：

$$\operatorname{Det}(M)=\sum\limits_{\forall P\color{black}:A\to B} (-1)^{t(\sigma)}\prod\limits_{i=1}^n \omega(P_i)$$
观察上式与定理的区别，发现现在仅需证明对于所有有交的路径 $G$ 的贡献均为 $0$ 就可以证明原定里了。


要证明原定理成立，首先需要证明对于一个排列 $\sigma$ 满足交换 $i,j\in[1,n]\cap \mathbb{Z}\wedge i\ne j$ 一定会使 $\sigma$ 逆序对的奇偶性改变。

先证明交换相邻的元素序列的奇偶性会改变，这十分显然因为如果交换 $A_i,A_{i+1}$ 那么因为没有相同的元素所以 $A_i,A_{i+1}$ 之间必定会贡献一个逆序对的变化，而对于 $[1,i)$ 和 $(i+1,n]$ 的贡献都是一样的，所以 $t(\sigma)$ 的奇偶性必然改变。考虑更一般的情况，假设只能交换相邻的元素，交换 $A_i$ 与 $A_j$ 的贡献就是交换 $A_i,A_j-1$ 的贡献 $+2$（一开始把 $A_j$ 换到 $A_{j-1}$ 最后再换回来）。

我们可以一直将距离不断缩小直到 $j=i+1$，因为我们已经证明了交换 $A_i,A_{i+1}$ 会改变奇偶性所以要自然可以证明一个排列任意交换两个元素其逆序对的奇偶性偶会改变。

回到 LGV 引理的证明。

对于一个有交点的路径 $A_i\to B_i,A_j\to B_j$，假设其第一次相交于 $u$，也就是其路径形如 $A_i\to u\to B_i$ 和 $A_j\to u\to B_j$。这时候如果交换 $\sigma(i)$ 和 $\sigma(j)$ 那么就会发现另外一条相交的路径 $A_i\to u\to B_j$ 和 $A_j\to u\to B_i$。

显然两条路径 $P,P'$ 满足 $\omega(P)=\omega(P')$ 且因为上面的关于奇偶性的证明，有 $(-1)^{t(\sigma)}+(-1)^{t(\sigma')}$。

所以自然有结论：

$$\sum\limits_{\forall G:A\to B} (-1)^{t(\sigma)}\prod \limits_{i=1}^n \omega(G_i)=0$$

也就得到了：

$$\operatorname{Det}(M)=\sum\limits_{\forall S:A\to B}(-1)^{t(\sigma)}\prod\limits_{i=1}^n \omega(S_i)$$
## 本题的求解

因为这个题目保证 $1\leq a_1\leq a_2\leq \dots\leq a_m\leq n$，$1\leq b_1\leq b_2\leq \dots\leq b_m\leq n$，所以如果起点与终点并不是一一对应的，那么就一定会出现交点，也就是说有贡献的 $\sigma$ 都满足 $\sigma(i)=i$。


对于 $e(A_i,B_j)$ 使用组合数求解，直接输出 $\operatorname{Det}(M)$ 就可以了，时间复杂度 $O(n^3)$。

```cpp
#include<iostream>
#define int long long 
using namespace std;
const int N=5e6+5,M=505,mod=998244353;
int ksm(int a,int b){
	int ans=1;
	while(b){
		if(b&1){
			ans=ans*a%mod;
		}
		b>>=1;
		a=a*a%mod;
	}
	return ans;
}
int n,m,a[M],b[M],inv[N],jc[N],f[M][M];
int C(int n,int m){
	if(n<m){
		return 0;
	}
	return jc[n]*inv[m]%mod*inv[n-m]%mod;
}
void solve(){
	cin>>n>>m;
	for(int i=1;i<=m;i++){
		cin>>a[i]>>b[i];
	}
	for(int i=1;i<=m;i++){
		for(int j=1;j<=m;j++){
			f[i][j]=C(b[j]-a[i]+n-1,n-1);
		}
	}
	int flag=1;
	for(int i=1;i<=m;i++){
		for(int j=i+1;j<=m;j++){
			while(f[i][i]){
				int s=f[j][i]/f[i][i];
				for(int k=i;k<=m;k++){
					f[j][k]=(f[j][k]-s*f[i][k]+mod)%mod;
				}
				flag++;
				swap(f[i],f[j]);
			}
			flag++;
			swap(f[i],f[j]);
		}
	}
	int ans=1;
	for(int i=1;i<=m;i++){
		ans=(ans*f[i][i])%mod;
	}
	cout<<(ans*(flag%2?1:-1)+mod)%mod<<'\n';
}
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	jc[0]=1;
	for(int i=1;i<N;i++){
		jc[i]=jc[i-1]*i%mod;
	}
	inv[N-1]=ksm(jc[N-1],mod-2);
	for(int i=N-1;i>=1;i--){
		inv[i-1]=inv[i]*i%mod;
	}
	int T;cin>>T;
	while(T--) solve();
	return 0;
}
```

---

## 作者：prh_rpjiajia (赞：0)

对于 DAG $G=(V,E)$，定义其**路径代数**为：
$$
\mathcal{A}(G) = \left\{ \sum_{P \text{ path}} \alpha_P P \ \Bigg| \ \alpha_P \in \mathbb{C} \right\}
$$
其中路径乘法定义为连接运算：
$$
P_1 \cdot P_2 = \begin{cases}
P_1 \circ P_2 & \text{if } \text{end}(P_1) = \text{start}(P_2) \\
0 & \text{otherwise}
\end{cases}
$$

路径生成函数：

对于固定起点 $a$ 和终点 $b$，定义生成函数：
$$
G(a,b) = \sum_{k=0}^\infty \sum_{\substack{P:a\to b \\ |P|=k}} w(P)
$$
在 DAG 中该级数必然有限。

### 形式化的来讲
给定 DAG 上 $n$ 元起点集 $A=\{a_i\}$ 和终点集 $B=\{b_i\}$，定义：

1. **路径矩阵**：
   $$
   M_{ij} = G(a_i, b_j) = \sum_{P:a_i\to b_j} w(P)
   $$

2. **不相交路径组**集合：
   $$
   \mathcal{P}_{ND} = \left\{ (P_1,...,P_n) \ \Bigg| \ \begin{aligned}
   &P_i:a_i\to b_{\sigma(i)}, \\
   &\forall i\neq j: P_i \cap P_j = \emptyset
   \end{aligned} \right\}
   $$

定理核心等式：
$$
\sum_{(P_1,...,P_n)\in\mathcal{P}_{ND}} \prod_{i=1}^n w(P_i) = \det(M)
$$

## 组合证明

行列式展开视角：
$$
\det(M) = \sum_{\sigma\in S_n} \text{sgn}(\sigma) \prod_{i=1}^n M_{i,\sigma(i)}
$$
其中每项对应：
$$
\prod_{i=1}^n M_{i,\sigma(i)} = \sum_{(P_1,...,P_n): P_i:a_i\to b_{\sigma(i)}} \prod_{i=1}^n w(P_i)
$$

那相交路径是怎么抵消的呢？

关键引理：对于任意相交路径组 $(P_1,...,P_n)$，存在唯一对换 $\tau$ 使得：
1. $\prod w(P_i) = \prod w(P_i^\tau)$。
2. $\text{sgn}(\sigma) = -\text{sgn}(\tau\sigma)$。


### 符号保持性证明
设 $P_i$ 与 $P_j$ 在顶点 $v$ 相交，构造：
$$
\begin{cases}
P_i' = (a_i \to v) \circ (v \to b_j) \\
P_j' = (a_j \to v) \circ (v \to b_i)
\end{cases}
$$
则：
$$
\text{sgn}(\sigma)\prod w(P) + \text{sgn}(\tau\sigma)\prod w(P^\tau) = 0
$$

## 一些些特殊图类

### 平面格点图
对于 $\mathbb{Z}^2$ 上的路径：
$$
M_{ij} = \binom{(x_{b_j}-x_{a_i}) + (y_{b_j}-y_{a_i})}{x_{b_j}-x_{a_i}}
$$

当起点和终点满足**完全可序条件**时：
$$
\det(M) = \frac{\prod_{1\leq i<j\leq n} (x_{b_j}-x_{b_i})(y_{a_j}-y_{a_i})}{\prod_{i,j=1}^n (x_{b_j}-x_{a_i}+y_{b_j}-y_{a_i}-1)}
$$

### 二部图
在完全二部图 $K_{n,n}$ 中，若：
- $A$ 为左部顶点。
- $B$ 为右部顶点。
则不相交路径数等于：

$$
\det\left( \binom{2n}{n+i-j} \right)_{1\leq i,j\leq n} = \prod_{k=0}^{n-1} \frac{(2k)! (2n-2k-2)!}{k!(n-k-1)!^2}
$$


### 代码

```cpp
#include<cstdio>
const int M=998244353,N=2e6+5;
int T,n,m,a[105],b[105],v[N],iv[N],f[105][105];

int qp(int x,int y){
    int r=1;
    for(;y;y>>=1,x=1ll*x*x%M)
        if(y&1)r=1ll*r*x%M;
    return r;
}

int C(int x,int y){
    return x<0||y<0||x<y?0:1ll*v[x]*iv[y]%M*iv[x-y]%M;
}

int det(int n){
    int s=1;
    for(int i=1;i<=n;++i){
        if(!f[i][i]){
            for(int j=i+1;j<=n;++j)
                if(f[j][i]){
                    for(int k=i;k<=n;++k)
                        f[i][k]^=f[j][k]^=f[i][k]^=f[j][k];
                    s=M-s; break;
                }
            if(!f[i][i])return 0;
        }
        int inv=qp(f[i][i],M-2);
        for(int j=i+1;j<=n;++j){
            int t=1ll*f[j][i]*inv%M;
            for(int k=i;k<=n;++k)
                f[j][k]=(f[j][k]-1ll*f[i][k]*t%M+M)%M;
        }
    }
    for(int i=1;i<=n;++i)s=1ll*s*f[i][i]%M;
    return s;
}

int main(){
    v[0]=1;
    for(int i=1;i<N;++i)v[i]=1ll*v[i-1]*i%M;
    iv[N-1]=qp(v[N-1],M-2);
    for(int i=N-2;~i;--i)iv[i]=1ll*iv[i+1]*(i+1)%M;
    
    scanf("%d",&T);
    while(T--){
        scanf("%d%d",&n,&m);
        for(int i=1;i<=m;++i)scanf("%d%d",a+i,b+i);
        
        for(int i=1;i<=m;++i)
            for(int j=1;j<=m;++j)
                f[i][j]=C(n-1+b[j]-a[i],n-1);
        
        printf("%d\n",det(m));
    }
    return 0;
}
```

---


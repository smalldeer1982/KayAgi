# 【模板】特征多项式

## 题目背景

这是一道模板题。

## 题目描述

给出 $n$ 和一个 $n\times n$ 的矩阵 $A$，在模 $998244353$ 意义下求其特征多项式。

## 说明/提示

对于一个 $n\times n$ 的矩阵 $A$，设其特征多项式为 $p_A(x)$，满足
$$p_A(x)=\det(xI_n-A)$$
其中，$I_n$ 为一个 $n\times n$ 的单位矩阵。

对于 $10\%$ 的数据，$1\le n\le 5$；\
对于 $40\%$ 的数据，$1\le n\le 50$；\
对于另外 $10\%$ 的数据，$\forall1\le i\le n,1\le j\le i-1,A_{i,j}=0$，即 $A$ 为上三角矩阵；\
对于另外 $20\%$ 的数据，$\forall1\le i\le n,1\le j\le i-2,A_{i,j}=0$，即 $A$ 为上海森堡矩阵；\
对于 $100\%$ 的数据，$1\le n\le 500$，$A_{i,j}\in[0,998244352]$。

## 样例 #1

### 输入

```
3
1 2 3
4 5 6
7 8 9```

### 输出

```
0 998244335 998244338 1 ```

# 题解

## 作者：Gorenstein (赞：22)

2023/5/15 upd：修改一处笔误。

这题现有的两篇题解中，SSerxhs 较为简略，而 Dementor 则稍混乱，对于一些关键处没有彻底解释到位。因此该题解期望能对特征多项式以及其能够通过本题的一类解法做一个较全面的介绍。

------------


我们使用的大致思路是：
1. 利用相似矩阵特征多项式相同的性质将给定矩阵消成上海森堡矩阵。
2. 使用行列式展开定理递推计算它的特征多项式。

### 矩阵相似不变量

**定义**：设 $\bf A,B$ 皆为 $R$ 上 $n$ 级矩阵，若存在一个矩阵 $\bf P$ 使得 ${\bf P}^{-1}{\bf AP}={\bf B}$，则称矩阵 $\bf A,B$ **相似**，记作 ${\bf A\sim B}$。

**引理**：相似矩阵的行列式相等。

$Proof.\quad$ 假设 ${\bf A\sim B}$，那么：

$$
|{\bf B}|=\left|{\bf P}^{-1}\right||{\bf AP}|=\left|{\bf P}^{-1}\right||{\bf P|}|{\bf A}|=|{\bf A}|
$$

此外，我们还可以证明矩阵的秩和迹在相似关系下也不变。它们称为矩阵的**相似不变量**；在本题中，我们只需利用行列式的不变性。

今将证明**相似矩阵的特征多项式相等**。

$Proof.\quad$ 假设 ${\bf A\sim B}$，那么：

$$
|\lambda{\bf I}-{\bf A}|=\left|\lambda{\bf I}-{\bf P}^{-1}{\bf B}{\bf P}\right|=\left|{\bf P}^{-1}(\lambda{\bf I}-{\bf B}){\bf P}\right|=\left|{\bf P}^{-1}\right||\lambda{\bf I}-{\bf B}||{\bf P}|=|\lambda{\bf I}-{\bf B}|
$$

所以我们可以利用左右乘初等矩阵及其逆来对矩阵进行消元，而保持特征多项式不变。

### 利用初等矩阵消元

令 ${\bf P}(j,i(k))$ 表示将 $\bf I$ 的第 $i$ 行的 $k$ 倍加到第 $j$ 行所得的矩阵，也即：

$$
{\bf P}(j,i(k))=\begin{pmatrix}
1&&&&&&\\
&\ddots&&&&&\\
&&1&&&&\\
&&\vdots&\ddots&&&\\
&&k&\cdots&1&&\\
&&&&&\ddots&\\
&&&&&&1
\end{pmatrix}
$$

根据经典结论，设有 $n$ 级矩阵 ${\bf A}$，其行、列向量分别为 $\gamma_1,\cdots,\gamma_n$ 和 $\alpha_1,\cdots,\alpha_n$，那么：

$$
{\bf P}(j,i(k)){\bf A}=\begin{pmatrix}
\gamma_1\\\vdots\\\gamma_i\\\vdots\\k\gamma_i+\gamma_j\\\vdots\\\gamma_n
\end{pmatrix}
$$

$$
{\bf AP}(j,i(k))=(\alpha_1,\cdots,\alpha_i+k\alpha_j,\cdots,\alpha_j,\cdots,\alpha_n)
$$

今将求其逆。根据矩阵求逆的初等变换法，其逆矩阵为：

$$
{\bf P}^{-1}(j,i(k))=\begin{pmatrix}
1&&&&&&\\
&\ddots&&&&&\\
&&1&&&&\\
&&\vdots&\ddots&&&\\
&&-k&\cdots&1&&\\
&&&&&\ddots&\\
&&&&&&1
\end{pmatrix}={\bf P}(j,i(-k))
$$

因此对于 ${\bf A}$ 和初等矩阵 ${\bf P}$，构造相似矩阵 ${\bf P}{\bf AP}^{-1}$ 对 $\bf A$ 进行消元。它是对 ${\bf A}$ 依次进行初等行变换和列变换的结果，其和高斯消元唯一的区别就是：**在将第 $i$ 行的 $k$ 倍加至第 $j$ 行后，还需将第 $j$ 列的 $-k$ 倍加至第 $i$ 列**。

其余几种初等行变换也需要进行类似修改。

而如果我们将矩阵消成上海森堡形式，则对于每一个 $i$，我们操作的行是 $i+1$，相应的列的改变也到 $i+1$ 列为止。从而乘上矩阵 ${\bf P}^{-1}$ 的过程不会污染已经完成消元的部分。

### 递推计算矩阵的特征多项式

循 OI-wiki 的记号。若我们已经消元得到矩阵 $\bf H$ 为：

$$
{\bf H}_n=\begin{pmatrix}
\alpha_1&h_{12}&h_{13}&\cdots&h_{1n}\\
\beta_2&\alpha_2&h_{23}&\cdots&h_{2n}\\
&\ddots&\ddots&\ddots&\vdots\\
&&\ddots&\ddots&h_{n-1,n}\\
&&&\beta_n&\alpha_n
\end{pmatrix}
$$

那么就有：

$$
f_n(\lambda)=|\lambda{\bf I}_{n\times n}-{\bf H}_n|=\begin{vmatrix}
x-\alpha_1&-h_{12}&-h_{13}&\cdots&-h_{1n}\\
-\beta_2&x-\alpha_2&-h_{23}&\cdots&-h_{2n}\\
&\ddots&\ddots&\ddots&\vdots\\
&&\ddots&\ddots&-h_{n-1,n}\\
&&&-\beta_n&x-\alpha_n
\end{vmatrix}
$$

若将其按最后一行展开，便得到：

$$
f_n(\lambda)=(x-\alpha_n)f_{n-1}(\lambda)+\beta_n\begin{vmatrix}
x-\alpha_1&-h_{12}&\cdots&-h_{1,n-2}&-h_{1n}\\
-\beta_2&x-\alpha_2&\cdots&-h_{2,n-2}&-h_{2n}\\
&\ddots&\ddots&\vdots&\vdots\\
&&\ddots&x-\alpha_{n-2}&-h_{n-2,n}\\
&&&-\beta_{n-1}&-h_{n-1,n}
\end{vmatrix}
$$

把右边这个行列式按最后一列展开。我们发现对于一个 $-h_{n-i,n}$ 项，其余子式皆形如：

$$
\begin{vmatrix}
\\\\
&&\big[\lambda{\bf I}_{(n-i-1)\times(n-i-1)}-{\bf H}_{n-i-1}\big]\\
\\
\\
&&&\beta_{n-i+1}&\cdots\\
&&&&\ddots&\vdots&\vdots\\
&&&&&-\beta_{n-2}&\vdots\\
&&&&&&-\beta_{n-1}
\end{vmatrix}
$$

也即左上角是已经出现过的 $n-i-1$ 级 $f_{n-i-1}(\lambda)$ 代表的子矩阵，它的右下的主对角线上元素为 $\beta_{n-i},\cdots,\beta_{n-1}$，该主对角线以下部分的元素皆零。那么根据分块矩阵的行列式的性质，它等于：

$$
f_{n-i-1}(\lambda)\prod_{j=n-i+1}^{n-1}\beta_j
$$

从而最终结果为：

$$
f_n(\lambda)=(x-\alpha_n)f_{n-1}(\lambda)-\sum_{i=1}^{n-1}f_{n-i-1}(\lambda)\left(\prod_{j=n-i+1}^{n}\beta_{j}\right)h_{n-i,n}
$$

据此递推即可。

---

## 作者：SSerxhs (赞：19)

定理：相似矩阵特征多项式相同。

证明：$|\rm PAP^{-1}-\lambda E|$  
$=|\rm PAP^{-1}-\lambda PP^{-1}|$  
$=|\rm (PA-\lambda P)P^{-1}|$  
$=|\rm P(A-P^{-1}\lambda P)P^{-1}|$  
$=|\rm P(A-\lambda E)P^{-1}|$  
$=|\rm P|\times|A-\lambda E|\times |P^{-1}|$  
$=|A-\lambda E|$

考虑如何求出矩阵特征多项式。

朴素的消元方法由于涉及多项式运算，复杂度显然高于 $O(n^3)$。

实对称阵可以相似对角化，但一般数域上的矩阵并不都能相似对角化，但可以消成如下类似对角矩阵的形式。

$
\begin{pmatrix}
a_{1,1} & a_{1,2} & a_{1,3} & a_{1,4} & a_{1,5} \\
a_{2,1} & a_{2,2} & a_{2,3} & a_{2,4} & a_{2,5} \\
& a_{3,2} & a_{3,3} & a_{3,4} & a_{3,5}  \\
&  & a_{4,3} & a_{4,4} & a_{4,5} \\
 & & & a_{5,4} & a_{5,5} 
\end{pmatrix}
\quad
$

方法：构造初等矩阵 $\rm P$ 令 $\rm A\leftarrow PAP^{-1}$ 实现消元。

则用 $a_{i+1,i}$ 消 $a_{j,i}(j>i+1)$ 时，左乘和右乘分别相当于进行初等行变换 $R_{j}\leftarrow R_j+kR_{i+1}$ 和初等列变换 $C_{i+1}\leftarrow C_{i+1}-kC_j$，由于 $i<i+1<j$，可以注意到初等列变换不影响已消元部分，初等行变换仅影响当前要消的以及未消元部分。

化成如上矩阵后，可以轻易计算特征多项式。

考虑递推求解前 $i$ 行 $i$ 列的答案多项式 $f_i(x)$。显然边界是 $f_0(x)=1$。

观察矩阵可以发现，选取位于 $a_{1,1},a_{2,2},\cdots,a_{j-1,j-1},a_{j,i},a_{j+1,j},a_{j+2,j+1},\cdots,a_{i,i-1}(1\le j\le i)$ 的元素是唯一有贡献部分，其贡献为 $-f_{j-1}a_{j,i}\prod\limits_{k=j}^{i-1}a_{k+1,k}(j<i)$。后面这部分显然可以直接递推。特别地，对于 $j=i$，有**额外**贡献 $xf_{i-1}$。

于是我们可以 $O(n^3)$ 地计算出矩阵的特征多项式。

用途：写奇怪的 $|\rm A-kE|$ 多点求值板子。

据说可以加速矩阵快速幂，先咕着。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=502,p=998244353;
int a[N][N],f[N];
int n,i,j,k,x,y,r,q;
template<typename typC> void read(register typC &x)
{
	register int c=getchar(),fh=1;
	while ((c<48)||(c>57))
	{
		if (c=='-') {c=getchar();fh=-1;break;}
		c=getchar();
	}
	x=c^48;c=getchar();
	while ((c>=48)&&(c<=57))
	{
		x=x*10+(c^48);
		c=getchar();
	}
	x*=fh;
}
inline void inc(register int &x,const int y)
{
	if ((x+=y)>=p) x-=p;
}
inline void dec(register int &x,const int y)
{
	if ((x-=y)<0) x+=p;
}
inline int ksm(register int x,register int y)
{
	register int r=1;
	while (y)
	{
		if (y&1) r=(ll)r*x%p;
		x=(ll)x*x%p;y>>=1;
	}
	return r;
}
void calmatrix(int a[N][N],register int n)
{
	register int i,j,k,r;
	for (i=2;i<=n;i++)
	{
		for (j=i;j<=n&&!a[j][i-1];j++);
		if (j>n) {continue;}
		if (j>i)
		{
			swap(a[i],a[j]);//exit(-1);
			for (k=1;k<=n;k++) swap(a[k][j],a[k][i]);
		}
		r=a[i][i-1];
		for (j=1;j<=n;j++) a[j][i]=(ll)a[j][i]*r%p;
		r=ksm(r,p-2);
		for (j=i-1;j<=n;j++) a[i][j]=(ll)a[i][j]*r%p;
		for (j=i+1;j<=n;j++)
		{
			r=a[j][i-1];
			for (k=1;k<=n;k++) a[k][i]=(a[k][i]+(ll)a[k][j]*r)%p;
			r=p-r;
			for (k=i-1;k<=n;k++) a[j][k]=(a[j][k]+(ll)a[i][k]*r)%p;
		}
	}
}
void calpoly(int a[N][N],register int n,int *f)
{
	static int g[N][N];
	memset(g,0,sizeof(g));
	g[0][0]=1;
	register int i,j,k,r,rr;
	for (i=1;i<=n;i++)
	{
		r=p-1;
		for (j=i;j;j--)//第 j 行选第 n 列
		{
			rr=(ll)r*a[j][i]%p;
			for (k=0;k<j;k++) g[i][k]=(g[i][k]+(ll)rr*g[j-1][k])%p;
			r=(ll)r*a[j][j-1]%p;
		}
		for (k=1;k<=i;k++) inc(g[i][k],g[i-1][k-1]);
	}
	memcpy(f,g[n],n+1<<2);
//	if (n&1) for (i=0;i<=n;i++) if (f[i]) f[i]=p-f[i];//这题特殊（A-kE），否则注释掉
}
int main()
{
	read(n);//read(q);
	for (i=1;i<=n;i++) for (j=1;j<=n;j++) read(a[i][j]);
	calmatrix(a,n);calpoly(a,n,f);
	for (i=0;i<=n;i++) printf("%d%c",f[i]," \n"[i==n]);
}
```

---

## 作者：Dementor (赞：9)

## 特征多项式

**本篇文章仅仅是根据自己的理解写的学习笔记**

特征多项式是矩阵的一个知识点，在线性代数中有重要的应用

目标时间复杂度 $O (n ^ 3)$

总体过程分为 $2$ 步走：

+ 求上海森堡矩阵

+ 递推求特征多项式

### 定义

对于一个 $n \times n$ 的矩阵 $A$ ，定义它的特征多项式为：

$$p_A (x) = \det (xI_n - A)$$

其中 $I_n$ 是一个 $n$ 阶的单位矩阵，最后的 $p_A (x)$ 是一个 $n$ 次多项式

### 求特征多项式

暴力可以直接取 $0,1,...,n$ 一共 $n + 1$ 个值代入 $x$ 求行列式，再用多项式插值求出特征多项式，复杂度是 $O (n ^ 4)$ 的，在这里不细讲

如果一个矩阵次对角线下方的位置全部都是 $0$ 那么把其称为 “上海森堡矩阵”

那么接下来有一个算法一般叫做 “海森堡算法” 可以在 $O (n ^ 3)$ 的时间内 **递推** 出特征多项式

将一个普通矩阵等价变换成我们需要的上海森堡矩阵的方法是 **类高斯消元**

高斯消元大家都非常熟悉了，但是我们需要在这基础上做一些调整， **这非常重要** ，千万不能遗漏

#### 结论

对于初等可逆矩阵 $P$ ，有：

$$\det (xI_n - A) = \det (xI_n - PAP^{-1})$$

证明：

$$\det (xI_n - PAP^{-1}) = \det (xPI_nP^{-1} - PAP^{-1})$$

$$= \det ((xPI_n - PA)P^{-1})$$

$$= \det ((PxI_n - PA)P^{-1})$$

$$= \det (P(xI_n - A)P^{-1})$$

$$= \det (P) \times \det (xI_n - A) \times \det (P^{-1}) $$

$$= \det (xI_n - A)$$

我们称 $B = PAP^{-1}$ 为 $A$ 的相似矩阵，于是我们得到了一个表述：

> 相似矩阵的特征多项式相同

由此，我们也加深了对 “特征” 二字的理解

#### 更改高斯消元

一般的高斯消元可以理解为令一个普通矩阵 $A$ 变成 $PA$ ，这个 $P$ 即为一个初等矩阵

我们发现，此时的 $A'$ 并不与原来的 $A$ 相似，但它们也就相差了一个 $P^{-1}$

高斯消元用到的三个操作：

1. 交换两行

2. 将一行 $\times k$ 加到另一行上

3. 将一行 $\times k$

经过验证，这三个操作对应的初等矩阵 $P$ 所需要多乘的 $P^{-1}$ 实际上就是对 **列** 做一次一模一样的操作

同时发现，这样的操作是不会影响我们消成上海森堡矩阵的过程的

至此，我们完成了 **第一步**

#### 递推

记 $p_i(x)$ 为保留 $A[1..i][1..i]$ 时的特征多项式

此时 $A$ 是一个与读入矩阵相似的上海森堡矩阵

首先可以列出初值：

$$p_0(x) = \{1\}$$

$$p_1(x) = \{-A[1][1], 1\}$$

这里直接默认列表位置为对应多项式幂次的系数，没有写出来的不存在（即那个幂次系数为 $0$）

对 $p_2 (x) = \det (xI_2 - A_2)$ 直接展开

$$p_2 (x) = (x - A[2][2]) p_1 (x) - A[2][1] \times A[1][2] p_0 (x)$$

对 $p_3 (x)$ 、甚至是 $p_4 (x)$ 展开，计算，归纳之后

发现可以写成递推式：

$$p_i (x) = (x - A[i][i])p_{i-1}(x) - \sum\limits_{m=1}^{i-1}A[i-m][i](\prod\limits_{j=i-m+1}^{i}A[j][j - 1])p_{i-m-1}(x)$$

这个算法的名字就是“海森堡算法”

至此，我们完成了 **第二步**

#### 时间复杂度

高斯消元的复杂度 $O (n ^ 3)$

海森堡算法递推的复杂度是 $O (n ^ 3)$

最后的答案即为 $p_n (x)$

综上，时间复杂度是 $O (n ^ 3)$

达到了我们的目标

### 代码实现

从整个算法步骤知道代码其实不复杂，一步一步写就能成功实现算法

code

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int N = 510;
const ll mod = 998244353;
ll n, a[N][N], p[N][N];
ll qpow (ll a, ll b) {
	ll ans = 1ll;
	while (b) {
		if (b & 1) ans = ans * a % mod;
		a = a * a % mod;
		b >>= 1;
	}
	return ans;
}
ll inv (ll x) {return qpow (x, mod - 2);}
void Hesb (ll a[N][N], int n) {
	for (register int i=1;i<n;i++) {
		int p = -1;
		for (register int j=i+1;j<=n;j++) {
			if (a[j][i]) {
				p = j;
				break ;
			}
		}
		if (p == -1) continue ;
		else {
			swap (a[p], a[i + 1]);
			for (register int j=1;j<=n;j++) swap (a[j][p], a[j][i + 1]);
		}
		for (register int j=i+2;j<=n;j++) {
			ll tmp = a[j][i] * inv (a[i + 1][i]) % mod;
			for (register int k=1;k<=n;k++) a[j][k] = (a[j][k] + mod - tmp * a[i + 1][k] % mod) % mod;
			for (register int k=1;k<=n;k++) a[k][i + 1] = (a[k][i + 1] + tmp * a[k][j] % mod) % mod;
		}
	}
}
ll neg (ll x) {
	return mod - x;
}
int main () {
	cin >> n;
	for (register int i=1;i<=n;i++) {
		for (register int j=1;j<=n;j++) {
			scanf ("%lld\n", &a[i][j]);
		}
	}
	Hesb (a, n);
	p[0][0] = 1;
	for (register int i=1;i<=n;i++) {
		for (register int m=1;m<i;m++) {
			ll tmp = a[m][i];
			for (register int j=m;j<i;j++) tmp = tmp * a[j + 1][j] % mod;
			for (register int j=0;j<=n;j++) p[i][j] = (p[i][j] + neg (tmp * p[m - 1][j] % mod)) % mod;
		}
		for (register int j=1;j<=n;j++) p[i][j] = (p[i][j] + p[i - 1][j - 1]) % mod;
		for (register int j=0;j<=n;j++) p[i][j] = (p[i][j] + neg (a[i][i] * p[i - 1][j] % mod)) % mod;
	}
	for (register int i=0;i<=n;i++) printf ("%lld ", p[n][i]); puts ("");
}
```

可以通过洛谷上的模板题：[P7776 特征多项式](https://www.luogu.com.cn/problem/P7776)

### 参考文献

[oi-wiki 特征多项式](https://oi-wiki.org/math/char-poly/#_1)

---

## 作者：黑影洞人 (赞：4)

题意：给你一个矩阵，求模 $998244353$ 意义下的特征多项式。

### 前置知识：数学意义下的特征多项式

给你一个 $n$ 阶实对称方阵 $A$，若存在 $n$ 维向量 $X$ 使得：

$$AX=\lambda X$$

则称 $\lambda$ 为 $A$ 的特征值，$X$ 为 $A$ 对应与特征值 $\lambda$ 的特征向量。

显然：$AX=\lambda X$ 等价于 $(A-\lambda E)X=0$ 其中 $E$ 为 $n$ 阶单位矩阵。

则称：$f(\lambda )=|A-\lambda E|$ 为 $A$ 的特征多项式。
 
$f(\lambda )=0$ 的解就是特征值。

### 前置知识：矩阵相似

若存在矩阵 $P$ 使得 $B=PAP^{-1}$ 则称 $B$ 与 $A$ 相似。

可以得到，相似矩阵的特征值一样。

证明：

$$|PAP^{-1}-\lambda E|$$

$$=|PAP^{-1}-\lambda PP^{-1}|$$

$$=|P(A-P^{-1}\lambda P)P^{-1}|$$

$$=|P|\times |(A-\lambda E)|\times |P^{-1}|$$

$$=|(A-\lambda E)|$$

现在我们就可以求出一个上海森堡矩阵使其与 $A$ 相似。

这一步可以使用高斯消元来完成，使得矩阵 $A$ 经过初等变换，变为 $PA$。

因此要变换后的矩阵与原矩阵相似，要乘以逆矩阵 $P^{-1}$。

对于每个操作在对应列进行一次一样的操作，即可保证两次的变换矩阵互为逆矩阵。

```cpp
int qpow(int a,int b){
	int res=1;
	while(b){
		if(b&1)res=(res*a)%md;
		a=(a*a)%md;
		b>>=1;
	}
	return res;
}
int inv(int a){return qpow(a,md-2);}
void guess(){
	for(int i=1;i<=n;i++){
		int p=-1;
		for(int j=i+1;j<=n;j++)if(a[j][i]){p=j;break;}
		if(p==-1)continue;
		swap(a[p],a[i+1]);
		for(int j=1;j<=n;j++)swap(a[j][p],a[j][i+1]);
		for(int j=i+2;j<=n;j++){
			int tmp=a[j][i]*inv(a[i+1][i])%md;
			for(int k=1;k<=n;k++)a[j][k]=(a[j][k]+md-tmp*a[i+1][k]%md)%md;
			for(int k=1;k<=n;k++)a[k][i+1]=(a[k][i+1]+tmp*a[k][j]%md)%md;
		}
	}
}

```

求出上海森堡矩阵之后有什么用呢？

设 $P_i(x)$ 为矩阵 `H[1...i][1...i]` 的特征多项式，$H$ 为上海森堡矩阵。

有递推式：

$$P_i(x)=(x-H_{i,j})P_{i-1}(x)-\sum_{k=1}^{i-1} H_{k,i}(\prod_{j=k+1}^i H_{j,j-1})P_{k-1}(x)$$

跑一遍递推式即可。

```cpp
#include<cstdio>
#include<algorithm>
#define md 998244353
#define N 510 
#define int long long
using namespace std;
int a[N][N],n; 
int p[N][N];
int qpow(int a,int b){
	int res=1;
	while(b){
		if(b&1)res=(res*a)%md;
		a=(a*a)%md;
		b>>=1;
	}
	return res;
}
int inv(int a){return qpow(a,md-2);}
void guess(){
	for(int i=1;i<=n;i++){
		int p=-1;
		for(int j=i+1;j<=n;j++)if(a[j][i]){p=j;break;}
		if(p==-1)continue;
		swap(a[p],a[i+1]);
		for(int j=1;j<=n;j++)swap(a[j][p],a[j][i+1]);
		for(int j=i+2;j<=n;j++){
			int tmp=a[j][i]*inv(a[i+1][i])%md;
			for(int k=1;k<=n;k++)a[j][k]=(a[j][k]+md-tmp*a[i+1][k]%md)%md;
			for(int k=1;k<=n;k++)a[k][i+1]=(a[k][i+1]+tmp*a[k][j]%md)%md;
		}
	}
}
void print(){
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++)printf("%lld ",a[i][j]);
		puts("");
	}
}
void hesb(){
	p[0][0]=1;
	for(int i=1;i<=n;i++){
		for(int m=1;m<i;m++){
			int tmp=a[m][i];
			for(int j=m;j<i;j++)tmp=(tmp*a[j+1][j])%md;
			for(int j=0;j<=n;j++)p[i][j]=(p[i][j]+(md-(tmp*p[m-1][j])%md))%md;
		}
		for(int j=1;j<=n;j++)p[i][j]=(p[i][j]+p[i-1][j-1])%md;
		for(int j=0;j<=n;j++)p[i][j]=(p[i][j]+(md-(a[i][i]*p[i-1][j])%md))%md;
	}	
}
signed main(){
	scanf("%lld",&n);
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++)scanf("%lld",&a[i][j]);
	}
	guess();
	//print();
	hesb();
	for(int i=0;i<=n;i++)printf("%lld ",p[n][i]);
	return 0;
}
/*
1 748683272 3
4 499122192 6
0 374341629 499122175
*/ 


```


---


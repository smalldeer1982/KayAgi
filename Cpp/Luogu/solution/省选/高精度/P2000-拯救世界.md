# 拯救世界

## 题目背景

公元 2000 年，根据预言家诺查丹玛斯的预言，世界就要毁灭了！！！


## 题目描述

为了拯救世界，小 a 和 uim 决定召唤出 kkksc03 大神和 lzn 大神。根据古籍记载，召唤出任何一位大神，都需要使用金木水火土五种五行神石来摆一个特定的大阵。而在古籍中，记载是这样的：

kkksc03 大神召唤方法：

- 金神石的块数必须是 $6$ 的倍数；
- 木神石最多用 $9$ 块；
- 水神石最多用 $5$ 块；
- 火神石的块数必须是 $4$ 的倍数；
- 土神石最多用 $7$ 块。

lzn 大神召唤方法:

- 金神石的块数必须是 $2$ 的倍数；
- 木神石最多用 $1$ 块；
- 水神石的块数必须是 $8$ 的倍数；
- 火神石的块数必须是 $10$ 的倍数；
- 土神石最多用 $3$ 块。

现在是公元 $1999$ 年 $12$ 月 $31$ 日，小 a 和 uim 从 $00{:}00{:}00$ 开始找，一直找到 $23{:}00{:}00$，终于，还是没找到神石。

不过，他们在回到家后在自家地窖里发现了一些奇怪的东西，一查古籍，哎呦妈呀，怎么不早点来呢？这里有一些混沌之石，可以通过敲击而衰变成五行神石。于是，他们拼命地敲，终于敲出了 $n$ 块神石，在 $23{:}59{:}59$ 完成了两座大阵。

然而，kkksc03 大神和 lzn 大神确实出现了，但是由于能量不够，无法发挥神力。只有把所有用 $n$ 块神石可能摆出的大阵都摆出来，才能给他们充满能量。这下小 a 和 uim 傻了眼了，赶快联系上了你，让你帮忙算一下，一共有多少种大阵。


## 说明/提示

### 数据范围及约定

对于全部数据，$10^{99999}\leq n\lt 10^{100000}$。

### 提示

由于现在已经是 $23{:}59{:}59$，所以你只有 $0.5$ 秒时间。（小 a 与 uim 需要 $0.5\texttt s$ 排出所有阵法）。


## 样例 #1

### 输入

```
2```

### 输出

```
15```

# 题解

## 作者：w36557658 (赞：56)

欢迎访问我的博客：https://www.cnblogs.com/luyouqi233/p/9181680.html

看到这么多的限制条件，以及最后求方案数，很容易想到生成函数。

生成函数的讲解就请百度吧……以及下面公式的推导也不再阐述。

那我们就细致地列一下吧，从第一条限制到第十条限制依次如下：

$1+x^6+x^{12}+\cdots=\frac{1}{1-x^6}$

$1+x+x^2+\cdots+x^9=\frac{1-x^{10}}{1-x}$

$1+x+x^2+\cdots+x^5=\frac{1-x^{6}}{1-x}$

$1+x^4+x^8+\cdots=\frac{1}{1-x^4}$

$1+x+x^2+\cdots+x^7=\frac{1-x^{8}}{1-x}$

$1+x^2+x^4+\cdots=\frac{1}{1-x^2}$

$1+x=\frac{1-x^{2}}{1-x}$

$1+x^8+x^{16}+\cdots=\frac{1}{1-x^8}$

$1+x^{10}+x^{20}+\cdots=\frac{1}{1-x^{10}}$

$1+x+x^2+x^3=\frac{1-x^{4}}{1-x}$

接下来要做的就是把它们乘起来，得到$\frac{1}{(1-x)^5}$

将它展开成生成函数，则第$n$项系数，也就是答案，即为$C_{n+5-1}^{5-1}=C_{n+4}^4$高精度求出即可。


---

## 作者：cirnovsky (赞：40)

生成函数裸题。

把所有情况罗列出来: 

kkk:

金: $1+x^6+x^{12}+\dots=\frac{1}{1-x^6}$

木: $1+x+x^2+\dots+x^9=\frac{1-x^{10}}{1-x}$

水块: $1+x+x^2+\dots+x^5=\frac{1-x^6}{1-x}$

火: $1+x^4+x^8+\dots=\frac{1}{1-x^4}$

土: $1+x+x^2+\dots+x^7=\frac{1-x^8}{1-x}$

lzn:

金: $1+x^2+x^4+\dots=\frac{1}{1-x^2}$

木: $1+x=\frac{1-x^2}{1-x}$

水: $1+x^8+x^{16}+\dots=\frac{1}{1-x^8}$

火: $1+x^{10}+x^{20}+\dots=\frac{1}{1-x^{10}}$

土: $1+x+x^2+x^3=\frac{1-x^4}{1-x}$

凉心出题人友好的卡了精度并且顺便卡了pypy。所以，人生苦短，Ruby用我

```ruby
n = gets.to_i
print (n + 1) * (n + 2) * (n + 3) * (n + 4) / 24
```

---

## 作者：Jμdge (赞：24)

一个兴奋没关文件然后交上去 WA 了一遍...

生成函数的板子题？


我们考虑把限制所对应的多项式列出来，然后相乘消去就可以得到 $1\over(1-x)^{5}$，然后看一眼下面的等式：

$${1\over (1-x)^n}=\sum_{i=0}^{\infty} C_{n+i-1}^i x^i$$


（关于这个等式成立的证明请移步我的[cnblogs](https://www.cnblogs.com/Judge/p/10549495.html)）

我们把 5 带入得到：


$${1\over (1-x)^5}=\sum_{i=0}^{\infty} C_{i+4}^i x^i$$


然后把题意带进去，就是说我们要求得 x 的 N 次项系数

这个系数是多少？其实就是 $C_{n+4}^n={(n+4)(n+3)(n+2)(n+1)\over4!(=24)}$


那么我们已经发现答案就是 $(N+1)(N+2)(N+3)(N+4)/24$

但是 N 的数据范围特别大于是我们只能考虑高精度（讲道理是可以过的吧...）

或者 NTT 加速一下...就是 n log n 了，非常可以接受

```cpp
//by Judge
#include<bits/stdc++.h>
#define fp(i,a,b) for(int i=(a),I=(b)+1;i<I;++i)
#define fd(i,a,b) for(int i=(a),I=(b)-1;i>I;--i)
#define ll long long
using namespace std;
const int mod=998244353;
const int inv3=332748118;
const int M=6e5+3;
typedef ll arr[M];
char sr[1<<21],z[20];int C=-1,Z;
inline void Ot(){fwrite(sr,1,C+1,stdout),C=-1;}
inline void print(ll x){ if(C>1<<20)Ot();
	while(z[++Z]=x%10+48,x/=10);
    while(sr[++C]=z[Z],--Z);
} int limit=1,n,len,len1,len2,len3,len4;
arr r,n1,n2,n3,n4,ans; char s[M];
inline int mul(int x,int y){return 1ll*x*y%mod;}
inline int inc(ll x,ll y){return x+y>=mod?x+y-mod:x+y;}
inline int dec(ll x,ll y){return x-y<0?x-y+mod:x-y;}
inline int qpow(int x,int p=mod-2){ int s=1;
	for(;p;p>>=1,x=mul(x,x))
		if(p&1) s=mul(s,x); return s;
}
inline void NTT(ll* a,int tp){
	fp(i,0,limit-1) if(i<r[i]) swap(a[i],a[r[i]]);
	for(int mid=1,x,y;mid<limit;mid<<=1){
		int Gn=qpow(tp?3:inv3,(mod-1)/(mid<<1));
		for(int j=0;j<limit;j+=mid<<1)
			for(int k=0,g=1;k<mid;++k,g=mul(g,Gn))
				x=a[j+k],y=mul(g,a[j+k+mid]),
				a[j+k]=inc(x,y),a[j+k+mid]=dec(x,y);
	} if(tp) return ; int inv=qpow(limit);
	fp(i,0,limit-1) a[i]=a[i]*inv%mod;
}
inline void Mul(ll* a,ll* b){
	NTT(a,1),NTT(b,1);
	fp(i,0,limit-1)
		a[i]=a[i]*b[i]%mod;
	NTT(a,0); ll tmp=0;
	fp(i,0,limit-1){
		a[i]+=tmp,
		tmp=a[i]/10,
		a[i]%=10;
		if(a[i]) len1=i+1;
	}
}
int main(){
	freopen("1.in","r",stdin);
	scanf("%s",s); ll n=strlen(s),x=1;
	for(;limit<=4e5;limit<<=1) ++len;
	fp(i,0,limit) r[i]=r[i>>1]>>1|((i&1)<<len-1);
	reverse(s,s+n); fp(i,0,n-1) n1[i]=s[i]-48;
	fp(i,0,n){ n1[i]=n1[i]+x;
		x=n1[i]/10,n1[i]%=10;
		if(n1[i]) len1=i+1;
	} x=1;
	fp(i,0,len1-1){ n2[i]=n1[i]+x;
		x=n2[i]/10,n2[i]%=10;
		if(n2[i]) len2=i+1;
	} x=1;
	fp(i,0,len2-1){ n3[i]=n2[i]+x;
		x=n3[i]/10,n3[i]%=10;
		if(n3[i]) len3=i+1;
	} x=1;
	fp(i,0,len3-1){ n4[i]=n3[i]+x;
		x=n4[i]/10,n4[i]%=10;
		if(n4[i]) len4=i+1;
	} x=1;
	Mul(n1,n2),Mul(n1,n3),Mul(n1,n4);
	ll p=0,lenn=0;
	fd(i,len1-1,0){
		p=p*10+n1[i],ans[i]=p/24,p%=24;
		if(ans[i]&&!lenn) lenn=i+1;
	}
	if(!lenn) lenn=1;
	fd(i,lenn-1,0)
		print(ans[i]);
	return Ot(),0;
}
```



---

## 作者：kcm1996 (赞：17)

仔细观察，发现两个阵法所用的石头互不相干，即题目可以看成n块石头对10种石头的分配问题。

本题是生成函数的模型题（感谢古伯的友情帮助不然我到现在还以为是用奇怪的矩阵乘法才能搞定）

对10种石头分类讨论得：

1/(1-x^6)\*(1-x^10)/(1-x)\*(1-x^6)/(1-x)……=1/(1-x)^5

转化出来求n即：C(5+n-1,n)=C(4+n,4)=(n+1)(n+2)(n+3)(n+4)/24

因为n的length长达100000，一般的高精度绝对跑不过去，所以要用FFT。


---

## 作者：行吟啸九州 (赞：12)

当初写这篇题解的时候还不会使用$markdown$，现在会了一点，所以$update$一下。

这道题主要需要两个知识，一个是生成函数，一个是$NTT$（$FFT$由于精度原因，据说不可过）。

[不会生成函数请点开这里](https://www.cnblogs.com/RabbitHu/p/9178645.html)
[不会$FFT$请点开这里](https://www.cnblogs.com/RabbitHu/p/FFT.html)
在此%%%兔哥。

这道题对每一种物品构造生成函数， 然后乘起来就是，$ans = (n+1)×(n+1)×(n+3)×(n+4)\ / \ 24$。由于$n$过大，需要高精度乘法，用暴力朴素算法过不去，$Karatsuba$算法应该可以，不过我不会，用FFT掉精度，过不去，所以我们就要使用$NTT$了（要不然这题怎么可能黑题）。

有了以上的知识，我就开始介绍$NTT$（快速数论变换）了。

$NTT$可以说是$FFT$在模意义下的解决办法，优点就是不会掉精。所以我用类比的思想来介绍这一算法。

首先 $FFT$ 得以精妙地在 $O(n log n)$ 时间内实现多项式卷积，正是得益于单位根 $ω$ 的四条性质

1. $ ω_{n} ^ n = 1$;

2. $ω_{n} ^ 0$到$ω_{n} ^ {n - 1}$互不相同（这样子计算出来点值的才能还原回去）

3. $ω_{n} ^ k = ω_{n} ^ {k / 2}$， $ω_{n} ^ {n / 2 + k} = -ω_{n} ^ k$

4. $IFFT$的时候带入$ω_{n} ^ {-k}$可以得到原系数

所以我们考虑在模意义下是否能找到类似的数，在此需要知道一个叫做原根的东西，[不会原根请点开这里](https://blog.csdn.net/weixin_42373330/article/details/82179051)。如果我们现在解决一个长度为$n$的多项式的卷积，我们取一个素数p = $i × 2 ^ k + 1$并且找到它的原根 $g$ ,然后我们令$g_n = g^m$（$m$是比$n$大的且是$2$的任意次方的数），可以发现以下结论(以下设 $x = i × 2 ^ k \ /\  m$， 同余都是模$p$意义下的)。

1. $g_{n} ^ x ≡ 1$（根据费马小定理可知）， 第一条性质就满足了。

2. $g_{n} ^ 0$到$g_{n} ^ {x - 1}$模意义下互不相同（根据原根的性质可知），第二条性质也满足了。

3. 因为$g_{n} ^ x ≡ 1$， 所以$g_{n} ^ {x / 2} ≡ 1 \ or -1$（开根号）， 而根据原根性质，所以$g_{n} ^ {x / 2} ≡ -1$，$g_{n} ^ {x / 2 + k}$ = $-g_{n} ^ k$，所以性质三得到满足。

4. 性质四自己手算一遍发现还是满足的，我不会线性代数证明，也就不讲了。

[这里有一些满足p = $i × 2 ^ k + 1$的素数及其原根](http://blog.miskcoo.com/2014/07/fft-prime-table)。

好了，我们终于说完了$NTT$（说得这是啥玩意）。这个时候你可能觉得这是一个没有审清楚题的$zz$在瞎$bb$，这题根本就没有让取模，你$NTT$个什么劲。

但其实只要卷积的时候每一位的结果不会大于你选的质数，就不会出现影响最终答案的取模，所以这道题可以用$NTT$来做。

因为这道题结果不用取模，所以高精度压位不能压太多，因为这个我$de$了很长时间$bug,\ qwq$。

以下提供一份代码（我选的质数是$998244353$，其原根为$3$）
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define maxn 4000005
#define mod 998244353
#define Fol(i, j, n) for(register int i = j ; i >= n ; i--)
#define For(i, j, n) for(register int i = j ; i <= n ; i++)
int l, n = 1, l1, l2, len, flag, rev[maxn];
ll p, ans, inv, invn;
ll a[maxn], b[maxn], c[maxn], g[maxn];//十年oi一场空，不开long long见祖宗
char s[maxn];

inline ll quickpow(ll x, int y){
	ll sum = 1ll;
	for( ; y ; x = x * x % mod, y >>= 1) if(y & 1) sum = sum * x % mod;
	return sum;
}

inline void NTT(ll *a, int ju){
	For(i, 0, n - 1) if(i < rev[i]) swap(a[i], a[rev[i]]);
	for(register int i = 1 ; i < n ; i <<= 1){
		ll T = quickpow(ju ? 3ll : inv, (mod - 1) / i >> 1);
		for(register int j = 0 ; j < n ; j += i << 1){
			ll t = 1;
			For(k, 0, i - 1){
				ll x = t * a[i + j + k] % mod;
				a[i + j + k] = (a[j + k] - x + mod) % mod, a[j + k] = (a[j + k] + x) % mod, t = t * T % mod;
			}
		}
	}
}
inline void change(int x){
	For(i, 0, n - 1) b[i] = g[i];
	b[0] += x, NTT(a, 1), NTT(b, 1);
	For(i, 0, n - 1) a[i] = a[i] * b[i] % mod, b[i] = 0;
	NTT(a, 0);
	For(i, 0, n - 1) a[i] = a[i] * invn % mod;
	For(i, 0, n - 1) a[i + 1] = (a[i + 1] + a[i] / 10) % mod, a[i] %= 10;//一定要进位，要不然就真对998244353取模了
}

int main(){
	scanf("%s", s), len = strlen(s);
	For(i, 0, len - 1) g[i] = s[len - 1 - i] - '0';
	while(n <= len * 5) n <<= 1, ++l2;
	l = max(l1, l2), inv = quickpow(3ll, mod - 2), invn = quickpow(n, mod - 2);
	For(i, 0, n - 1) rev[i] = rev[i >> 1] >> 1 | (i & 1) << l - 1;//读入n,并做好NTT的准备工作
	a[0] = 1;
	For(i, 0, n - 1) a[i] += g[i];

	change(2), change(3), change(4);//做三遍乘法
	For(i, 0, n - 1) a[i + 1] = (a[i + 1] + a[i] / 10) % mod, a[i] %= 10;
	Fol(i, n - 1, 0) a[i-1] += (a[i] % 24) * 10ll, a[i] /= 24;
	Fol(i, n - 1, 0) if(flag || a[i]) flag = 1, printf("%lld", a[i]);
	return 0;
}
```

---

## 作者：徐致远 (赞：8)


kkk牛逼！

[本蒟蒻的Blog](https://www.chnxuzhiyuan.cn/2019/10/13/%E3%80%8C%E6%B4%9B%E8%B0%B7P2000%E3%80%8D%E6%8B%AF%E6%95%91%E4%B8%96%E7%95%8C-Solution/)

### 题解

生成函数裸题。

依次来看召唤每一位大神所需的每种石头的情况：

- 金神石的块数必须是6的倍数：$1+x^6+x^{12}+\dots=\frac{1}{1-x^6}$

- 木神石最多用9块：$1+x+x^2+\dots+x^9=\frac{1-x^{10}}{1-x}$

- 水神石最多用5块：$1+x+x^2+\dots+x^5=\frac{1-x^6}{1-x}$

- 火神石的块数必须是4的倍数：$1+x^4+x^8+\dots=\frac{1}{1-x^4}$

- 土神石最多用7块：$1+x+x^2+\dots+x^7=\frac{1-x^8}{1-x}$

- 金神石的块数必须是2的倍数：$1+x^2+x^4+\dots=\frac{1}{1-x^2}$

- 木神石最多用1块：$1+x=\frac{1-x^2}{1-x}$

- 水神石的块数必须是8的倍数：$1+x^8+x^{16}+\dots=\frac{1}{1-x^8}$

- 火神石的块数必须是10的倍数：$1+x^{10}+x^{20}+\dots=\frac{1}{1-x^{10}}$

- 土神石最多用3块：$1+x+x^2+x^3=\frac{1-x^4}{1-x}$

然后把它们全都乘起来，就有：
$$
\frac{1}{1-x^6}\cdot \frac{1-x^{10}}{1-x} \cdot \frac{1-x^6}{1-x} \cdot \frac{1}{1-x^4} \cdot \frac{1-x^8}{1-x} \cdot \frac{1}{1-x^2} \cdot \frac{1-x^2}{1-x} \cdot \frac{1}{1-x^8} \cdot \frac{1}{1-x^{10}} \cdot \frac{1-x^4}{1-x}\\
=(\frac{1}{1-x})^5
$$

然后再把这个式子展开，就是：
$$
(1+x+x^2+x^3+\dots)^5
$$
答案就是上面这个多项式$x^n$项前面的系数。

通过隔板法可以求出答案为$\tbinom{n+5-1}{5-1}=\frac{n\cdot (n+1) \cdot(n+2)\cdot(n+3)}{24}$。

由于数据范围很大，所以上NTT来优化高精度乘法即可。

### 代码

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
typedef long long LL;
const int TT=998244353;
int r[263000];char n[100005];
inline int read()
{
	int ret=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-f;ch=getchar();}
	while(ch>='0'&&ch<='9'){ret=ret*10+ch-'0';ch=getchar();}
	return ret*f;
}
inline int QP(int a,int b)
{
	int ret=1,w=a;
	while(b)
	{
		if(b&1) ret=(LL)ret*w%TT;
		w=(LL)w*w%TT;b>>=1;
	}
	return ret;
}
inline void NTT(int* A,int limit,int type)
{
	for(int i=0;i<limit;i++)
		if(i<r[i])
			swap(A[i],A[r[i]]);
	for(int mid=1;mid<limit;mid<<=1)
	{
		int gn=QP(3,(TT-1)/(mid<<1));
		if(type<0) gn=QP(gn,TT-2);
		for(int j=0;j<limit;j+=mid<<1)
		{
			int g=1;
			for(int k=0;k<mid;k++,g=(LL)g*gn%TT)
			{
				int x=A[j+k],y=(LL)g*A[j+k+mid]%TT;
				A[j+k]=(x+y)%TT;
				A[j+k+mid]=(x-y+TT)%TT;
			}
		}
	}
	if(type<0)
	{
		int inv=QP(limit,TT-2);
		for(int i=0;i<=limit;i++) A[i]=(LL)A[i]*inv%TT;
	}
}
struct BigInteger
{
	int len,a[263000];
	BigInteger(){len=0;memset(a,0,sizeof(a));}
	BigInteger(char* S)
	{
		len=0;memset(a,0,sizeof(a));
		int n=strlen(S+1);
		reverse(S+1,S+1+n);
		len=(n+1)/2;
		for(int i=1;i<=n;i++) S[i]-='0';
		for(int i=1;i<=len;i++)
			a[i]=S[i*2-1]+S[i*2]*10;
	}
	BigInteger operator * (BigInteger b)
	{
		BigInteger a=*this,c;
		c.len=a.len+b.len;
		int limit=1,l=0;
		while(limit<=c.len){limit<<=1;l++;}
		for(int i=0;i<limit;i++)
			r[i]=(r[i>>1]>>1)|((i&1)<<(l-1));
		NTT(a.a+1,limit,1);
		NTT(b.a+1,limit,1);
		for(int i=1;i<=limit;i++)
			c.a[i]=(LL)a.a[i]*b.a[i]%TT;
		NTT(c.a+1,limit,-1);
		for(int i=1;i<=c.len;i++)
		{
			c.a[i+1]+=c.a[i]/100;
			c.a[i]%=100;
		}
		if(!c.a[c.len]) c.len--;
		return c;
	}
	void operator /= (int b)
	{
		for(int i=len;i;i--)
		{
			a[i-1]+=(a[i]%b)*100;
			a[i]/=b;
		}
		a[0]=0;
		if(!a[len]) len--;
	}
	inline void Inc()
	{
		a[1]++;
		for(int i=1;i<=len;i++)
		{
			if(a[i]<100) break;
			a[i+1]+=a[i]/100;
			a[i]%=100;
		}
		if(a[len+1]) len++;
	}
	void Print()
	{
		printf("%d",a[len]);
		for(int i=len-1;i>0;i--)
			printf("%02d",a[i]);
		putchar('\n');
	}
}A,B,C,D,ans;
int main()
{
	scanf("%s",n+1);
	A=n;A.Inc();
	B=A;B.Inc();
	C=B;C.Inc();
	D=C;C.Inc();
	ans=A*B*C*D;
	ans/=24;
	ans.Print();
	return 0;
}
```



---

## 作者：qwaszx (赞：7)

调这个题想打人真的

首先生成函数可以算出式子$(n+1)(n+2)(n+3)(n+4)/24$

生成函数怎么用就去看其他dalao的题解吧（窝才不会说我不会生成函数呢

然后就是这个题最大的坑点——高精度计算

首先高精+单精和高精÷单精显然都会

朴素的高精乘是$O(N^2)$的，不足以通过此题

怎么做请看[这里](https://www.luogu.org/problemnew/show/P1919)

但是！但是！但是！

丧心病狂的出题人卡了精度

所以只能写NTT了(我调了一个上午的FFT啊mmp)

素数取998244353即可，当然更大(比如超int)的话可能有惊喜（雾

打表处理$w_n$

然后还有一些玄学操作

比如说可以压位

NTT怎么能压位呢？

可以，但是只能压两位(99*99*1e5=980100000<998244353)

然后就可以提高两倍效率辣

还有其他一些奇技淫巧我也不是很清楚了qwq可能毛爷爷的黑科技能用吧我也不清楚

此外不建议写BigNum因为真心不好调qwq

放代码

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
using namespace std;
char st[200000];
long long r[1000000];
const long double PI=3.141592653589793238462643383;
const long long mod=998244353;
const long long BASE=100;
struct comp
{
    double x,y;
    comp operator +(const comp &a)const{return (comp){x+a.x,y+a.y};}
    comp operator -(const comp &a)const{return (comp){x-a.x,y-a.y};}
    comp operator *(const comp &a)const{return (comp){x*a.x-y*a.y,x*a.y+y*a.x};}
};
long long aa[1000000]={0},bb[1000000]={0};
int la,lans,powg[1000000],powgi[1000000];
long long a[1000000],ans[1000000];
long long qpower(long long a,long long b,long long m)
{
    long long ans=1;
    while(b)
    {
        if(b&1)ans=ans*a%m;
        a=a*a%m;
        b>>=1;
    } 
    return ans;
}
void make()
{
    int g=3,gi=(mod+1)/3;
    for(int i=1;i<1<<20;i<<=1)powg[i]=qpower(g,(mod-1)/i,mod),powgi[i]=qpower(gi,(mod-1)/i,mod);
} 
void fft(long long a[],int l,int f)
{
    for(int i=0;i<l;i++)if(i<r[i])swap(a[i],a[r[i]]);
    for(int i=1;i<l;i<<=1)
    {
        long long wn=f==1?powg[i<<1]:powgi[i<<1];
        for(int j=0,t=i<<1;j<l;j+=t)
        {
            long long w=1;
            for(int k=0;k<i;k++,w=w*wn%mod)
            {
                int x=a[j+k],y=w*a[i+j+k]%mod;
                a[j+k]=(x+y)%mod,a[i+j+k]=(x-y+mod)%mod;
            }
        }
    }
}
void inc(long long a[],int &la)
{
    a[0]++;
    for(int i=0;i<=la;i++)
        if(a[i]>=BASE)a[i+1]++,a[i]-=BASE;
        else break;
    if(a[la+1])la++;
}
void mul(long long a[],long long b[],int &la,int lb)
{
    int m=la+lb,n=1,l=0;
    while(n<=m)l++,n<<=1;
    for(int i=0;i<=la;i++)aa[i]=a[i];
    for(int i=0;i<=lb;i++)bb[i]=b[i];
    r[0]=0;for(int i=1;i<n;i++)r[i]=(r[i>>1]>>1)|((i&1)<<l-1);
    for(int i=la+1;i<n;i++)aa[i]=0;
    for(int i=lb+1;i<n;i++)bb[i]=0;
    fft(aa,n,1),fft(bb,n,1);
    for(int i=0;i<n;i++)aa[i]=aa[i]*bb[i]%mod;
    fft(aa,n,-1);
    m+=2;
    int invn=qpower(n,mod-2,mod);
    for(int i=0;i<=m;i++)r[i]=aa[i]*invn%mod;
    for(int i=m+1;i<n;i++)r[i]=0;
    for(int i=0;i<=m;i++)r[i+1]+=r[i]/BASE,r[i]%=BASE;
    while(r[m]>=BASE)r[m+1]+=r[m]/BASE,r[m++]%=BASE;
    while(!r[m]&&m>0)m--;
    for(int i=0;i<=m;i++)a[i]=r[i];
    la=m;
}
void rem(long long a[],int &la,int b)
{
    int x=0;
    while(x<b&&la>=0)x=x*BASE+a[la--];
    for(int i=la++;i>=0;i--)
    {
        a[i+1]=x/b,x%=b;
        x=x*BASE+a[i];
    }
    a[0]=x/b;
}
int wt[30];
void putout(int x)
{
    int l=0;
    while(x)wt[++l]=x%10,x/=10;
    for(int i=1;i<=2-l;i++)putchar('0');
    while(l)putchar(wt[l--]+48);
}
void print(long long a[],int len)
{
    printf("%lld",a[len]);
    for(int i=len-1;i>=0;i--)putout(a[i]);
    putchar(10);
}
int main()
{
    scanf("%s",st);
    la=strlen(st)-1;
    for(int i=0;i<=la;i++)ans[i]=st[la-i]-48;
    for(int i=0;i<=la;i++)
        for(int j=min(1,la-(i<<1));j>=0;j--)
            a[i]=a[i]*10+ans[(i<<1)+j];
    la>>=1;
    for(int i=0;i<=la;i++)ans[i]=0;
    ans[0]=1,lans=0;
    make();
    for(int i=1;i<=4;i++)
    {
        inc(a,la);
        mul(ans,a,lans,la);
    }
    rem(ans,lans,24);
    print(ans,lans);
}
```
还是挺快的开O2只有1400ms

---

## 作者：attack (赞：6)

思路题解都说的很清楚了

至多为$k$就是$\frac{1-x^{k+1}}{1-x}$

$k$的倍数就是$\frac{1}{1-x^k}$

化简完了就只剩下一个$\frac{1}{(1-x)^5}$

这个东西可以直接广义二项式定理展开，也就是这个式子

$$\frac{1}{(1-x)^n} = \sum_{k=0}^{\infty} C_{n+k-1}^{k-1}x^k$$

然鹅一开始我并不知道这个东西。

于是就用最原始的方法求, 我们想让分母的指数出现$5$，最便捷的方法就是求导，那么只要对$\frac{1}{1-x}$求四次导就可以搞出$\frac{1}{(1-x)^5}$啦

最后的答案也是$(N+1)(N+2)(N+3)(N+4) / 24$

```python
N = int(input())
print(int((N + 1) * (N + 2) * (N + 3) * (N + 4) / 24))
```

---

## 作者：Spasmodic (赞：5)

还真就没几个人老老实实用C++。。。

好的拿到题显然可以写出几个OGF

kkk：

金：$A_1(x)=1+x^6+x^{12}+\cdots$

木：$B_1(x)=1+x+x^2+\cdots+x^9$

水：$C_1(x)=1+x+\cdots+x^5$

火：$D_1(x)=1+x^4+x^8+\cdots$

土：$E_1(x)=1+x+\cdots+x^7$

lzn：

金：$A_2(x)=1+x^2+x^4+\cdots$

木：$B_2(x)=1+x$

水：$C_2(x)=1+x^8+x^{16}+\cdots$

火：$D_2(x)=1+x^{10}+x^{20}+\cdots$

土：$E_2(x)=1+x+x^2$

暴力展开我们可以发现一些奇妙的事情

$$A_1(x)C_1(x)=B_1(x)D_2(x)=D_1(x)E_2(x)=E_1(x)C_2(x)=A_2(x)B_2(x)=1+x+x^2+\cdots$$

于是我们就可以得到答案的OGF是

$$F(x)=A_1(x)B_1(x)\cdots E_2(x)=(1+x+x^2+\cdots)^5$$

则根据小学排列组合知识可得

$$ans=[x^n]F(x)=\dbinom{n+4}{4}=\frac{(n+1)(n+2)(n+3)(n+4)}{24}$$

然后你会发现凉心出题人卡了普通高精乘。。。

没事，NTT真香

啥？Ruby？~~你上NOI考场给我用个Ruby看看~~

于是这道题就做完了

由于我调了很久，所以放一下代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=500005*3,P=998244353,G=3;
int n[N],ans[N],lmt=1,rev[N],t[N];
string s; 
void converts(int *a,string s){
	int i,len=s.size();
	for(i=0;i<len;i++)a[i]=s[len-i-1]-'0';
	for(;i<N;i++)a[i]=0;
}
void print(int *a){
	int i;
	for(i=N-1;i>0;i--) if(a[i]>0) break;
	for(;i>=0;i--)printf("%d",a[i]);
	puts("");
}
inline int qpow(int a,int k){
	int ret=1;
	while(k){
		if(k&1)ret=1LL*ret*a%P;
		a=1LL*a*a%P;
		k>>=1;
	}
	return ret%P;
}
inline void NTT(int *A,int tp){
	for(int i=0;i<lmt;i++)if(i<rev[i])swap(A[i],A[rev[i]]);
	for(int m=1;m<lmt;m<<=1)
		for(int j=0,Wn=qpow(G,(P-1)/(m<<1));j<lmt;j+=m<<1)
			for(int k=0,w=1,x,y;k<m;k++,w=1LL*w*Wn%P)
				x=A[j+k],y=1LL*w*A[j+k+m]%P,A[j+k]=(x+y)%P,A[j+k+m]=(x-y+P)%P;
	if(tp==1)return;
	reverse(A+1,A+lmt);
	for(int i=0,inv=qpow(lmt,P-2);i<=lmt;i++)A[i]=1LL*A[i]*inv%P;
}
void div(int *a,int n){
	for(int i=N-1,c=0;i>=0;i--)c=c%n*10+a[i],a[i]=c/n;
}
void add(int *a){
	a[0]++;
	for(int i=1;i<N&&a[i-1]/10>0;i++)a[i]+=a[i-1]/10,a[i-1]%=10;
}
int main(){
	cin>>s;converts(n,s);
	int l=0;
	while(lmt<s.size()*5)lmt<<=1,l++;
	for(int i=1;i<lmt;i++)rev[i]=(rev[i>>1]>>1)|(i&1)<<(l-1);
	add(n),memcpy(ans,n,sizeof(n)),NTT(ans,1);
	add(n),memcpy(t,n,sizeof(n)),NTT(t,1);
	for(int i=0;i<lmt;i++)ans[i]=1LL*ans[i]*t[i]%P;
	NTT(ans,-1);
	for(int i=0;i<N-1;i++)ans[i+1]+=ans[i]/10,ans[i]%=10;
	NTT(ans,1);
	add(n),memcpy(t,n,sizeof(n)),NTT(t,1);
	for(int i=0;i<lmt;i++)ans[i]=1LL*ans[i]*t[i]%P;
	NTT(ans,-1);
	for(int i=0;i<N-1;i++)ans[i+1]+=ans[i]/10,ans[i]%=10;
	NTT(ans,1);
	add(n),memcpy(t,n,sizeof(n)),NTT(t,1);
	for(int i=0;i<lmt;i++)ans[i]=1LL*ans[i]*t[i]%P;
	NTT(ans,-1);
	for(int i=0;i<N-1;i++)ans[i+1]+=ans[i]/10,ans[i]%=10;
	div(ans,24);
	print(ans);
	return 0;
}
```

注意每乘一次都要进一次位，否则会WA，感谢@[xiaolilsq](/user/230249)神仙

---

## 作者：蒟蒻丁 (赞：3)

[更好体验](https://www.cnblogs.com/caijiLYC/p/14339762.html)
昨天菇菇学长爆讲了一波生成函数~~然后啥也没听懂~~  
今天一看这道题~~的题解~~，终于知道学长在讲什么了  
前置芝士，~~四则运算~~，多项式，普通生成函数(了解)  
首先定义一些东西：  
$\mathcal{A}$表示一个组合类  
$A$表示$\mathcal{A}$表示该组合类的生成函数，$A(x)=\sum{A_i*x^i}$(系数为排列数(不是指排列数，要根据题意转化))  
这什么意思呢，举个例子“我现在有一个大头，两个蜜蜂，我想组合出一个大头蜜蜂”，这就是一个经典乘法原理的应用  
这里“大头”，和“蜜蜂”都是组合类，根据生成函数，我们可以将他们“生成”一个函数  
由于玄学，他们也满足乘法原理(或者说笛卡尔积)，于是乘起来(为何如此草率！)  
根据题意我们列十个函数（为了好看好理解不用$\sum$了）
$$1+x^6+x^{12}+x^{18}+……=\frac{1}{1-x^6}$$
$$1+x+x^2+……+x^9=\frac{1-x^{10}}{1-x}$$
$$1+x+……+x^5=\frac{1-x^6}{1-x}$$
$$1+x^4+x^8+x^{12}+……=\frac{1}{1-x^4}$$
$$1+x+……+x^7=\frac{1-x^8}{1-x}$$
$$1+x^2+x^4+x^6+……=\frac{1}{1-x^2}$$
$$x^0=1$$
$$1+x^8+x^{16}+x^{24}+x^{32}+x^{40}=\frac{1}{1-x^8}$$
$$1+x^{10}+x^{20}+x^{30}+x^{40}=\frac{1}{1-x^{10}}$$
$$1+x+x^2+x^3=\frac{1-x^4}{1-x}$$
用乘法原理乘起来就是$C_{4+n}^{4}$  
什么，你让我用$FFT$？  
我们还是$ruby$吧
```
n=gets.to_i
print (n + 1)*(n + 2)*(n + 3)*(n + 4)/24
```

---


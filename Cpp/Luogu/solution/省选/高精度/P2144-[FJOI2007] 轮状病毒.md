# [FJOI2007] 轮状病毒

## 题目描述

轮状病毒有很多变种。许多轮状病毒都是由一个轮状基产生。一个 $n$ 轮状基由圆环上 $n$ 个不同的基原子和圆心的一个核原子构成。$2$ 个原子之间的边表示这 $2$ 个原子之间的信息通道，如图 1 所示。

$n$ 轮状病毒的产生规律是在 $n$ 轮状基中删除若干边，使各原子之间有唯一一条信息通道。例如，共有 $16$ 个不同的 $3$ 轮状病毒，如图 2 所示。

给定 $n\ (n\le100)$，编程计算有多少个不同的 $n$ 轮状病毒。

![](https://cdn.luogu.com.cn/upload/pic/1408.png)


## 样例 #1

### 输入

```
3
```

### 输出

```
16```

# 题解

## 作者：ButterflyDew (赞：42)

发现题目要求求出看起来很有规律的无向图生成树个数，显然可以找一些规律/打表/递推之类的，但不妨采用比较暴力的方法，矩阵树定理。

然后发现事情并没有那么简单，如果用矩阵树定理暴力去做的话，你可以选择一些乱搞/手写高精度小数类之类的方法

而之前又说，这个图比较特殊，所以，我们可以研究一下基尔霍夫矩阵的行列式有没有什么比较特殊的求法，$n+1(n>2)$阶的基尔霍夫矩阵大概长这个样子

$$\begin{bmatrix}n&-1&-1&-1&-1&\cdots&-1&-1&-1\\-1&3&-1&0&0&\cdots&0&0&-1\\-1&-1&3&-1&0&\dots&0&0&0\\-1&0&-1&3&-1&\cdots&0&0&0\\\vdots&\vdots&\vdots&\vdots&\vdots&\ddots&\vdots&\vdots&\vdots\\-1&0&0&0&0&\cdots&-1&3&-1\\-1&-1&0&0&0&\cdots&0&-1&3\end{bmatrix}$$

$n$阶主子式肯定是扔第一行第一列啊，因为我们想找行列式的递推规律，然后变成这样

$$\begin{bmatrix}3&-1&0&0&\cdots&0&0&-1\\-1&3&-1&0&\dots&0&0&0\\0&-1&3&-1&\cdots&0&0&0\\\vdots&\vdots&\vdots&\vdots&\ddots&\vdots&\vdots&\vdots\\0&0&0&0&\cdots&-1&3&-1\\-1&0&0&0&\cdots&0&-1&3\end{bmatrix}$$

设这个矩阵为$A_n$，那么$n$的答案就是$\det A_n$，然后我们考虑求出这个矩阵的行列式

由“行列式等于它的任一行（列）的各元素与其对应的代数余子式乘积之和”

- 余子式：在$n$阶行列式中，把元素$a_{i,j}$所在第$i$行和第$j$行划去后，留下的$n-1$阶行列式叫元素$a_{i,j}$的余子式，记做$M_{i,j}$，定义代数余子式为$A_{i,j}=(-1)^{i+j}M_{i,j}$

我们可以扔第一行，因为$(1,n)$和$(n,1)$两个位置的东西看起来巨难受。

拆开第一行第一列得到

$$3\begin{vmatrix}3&-1&0&\dots&0&0&0\\-1&3&-1&\cdots&0&0&0\\\vdots&\vdots&\vdots&\ddots&\vdots&\vdots&\vdots\\0&0&0&\cdots&-1&3&-1\\0&0&0&\cdots&0&-1&3\end{vmatrix}$$

这个看起来就可以递推的东西，设$n-1$阶的它为$B_{n-1}$。为了方便，以下$A_n,B_n$也指代行列式的值。

然后剩下有贡献的第一行第二列和第一行第$n-1$列，因为余子式的正负与$n$有关，不妨先设$n$为奇数，偶数的情况是一样的。

$$\begin{vmatrix}-1&-1&0&\dots&0&0&0\\0&3&-1&\cdots&0&0&0\\\vdots&\vdots&\vdots&\ddots&\vdots&\vdots&\vdots\\0&0&0&\cdots&-1&3&-1\\-1&0&0&\cdots&0&-1&3\end{vmatrix}$$

这是拆了第一行第二列，没思路再拆，发现扔第一行第一列后是$-B_{n-2}$，扔第$n-1$行第$1$列是主对角线全为$-1$的下三角，行列式的值为$-1$，再乘上$(-1)^{n-1+1}(-1)$还是$-1$

然后是第一行第$n$列

$$-\begin{vmatrix}-1&3&-1&0&\dots&0&0\\0&-1&3&-1&\cdots&0&0\\\vdots&\vdots&\vdots&\vdots&\ddots&\vdots&\vdots\\0&0&0&0&\cdots&-1&3\\-1&0&0&0&\cdots&0&-1\end{vmatrix}$$

注意这里是负的，因为$n$是奇数。然后还是拆第一列，发现答案还是$-B_{n-2}$和$-1$

于是我们有$A_n=3B_{n-1}-2B_{n-2}-2$

以同样的方法对$B$做讨论，可以得到$B_n=3B_{n-1}-B_{n-2}$

然后联立一下得到$A_{n}=3A_{n-1}-A_{n-2}+2$，带入到$n\le2$发现式子仍然成立，然后直接递推+高精即可。

---

## 作者：totorato (赞：36)

# Dp(利用多阶差分)
### 递推式

如果用$f[x]$表示加入了x个周围的点后的方案数，我们首先想到的递推式是：

$$f[i]=\sum_{j=1}^{i}f[i-j]\cdot j$$

意思是，最后加入的j个点每个都可能与中心点连边，将所有方案数累加即可。

但是，我们遇到一个问题：第一个点永远不会与第n个点连边，因此方案数统计并不准确。

所以我们需要对上面的f[x]作一些修正

$$g[i]=\sum_{j=2}^{i}f[i-j]\cdot j\cdot(j-1)$$

这样的$g[i]+f[i]$就是我们要求的轮状病毒的数量。

第二个式子的意思是：如果有j个周围的点连成一条，且跨越了1和n，我们将所有这样的情况累加到答案中去。如果这样的点有j个，剩下的点肯定不与这j个点相连，所以连边方案数就是$f[i-j]​$，这j个点有$(j-1)​$种选法(跨越1和n)，与中心点连边的方案数是j，根据乘法原理，答案要累加$f[i-j]\times j\times (j-1)$。

下面我们思考如何快速求出f和g。显然由于涉及高精度加法，我们需要$O(n^3)$的复杂度求解这个鬼东西。为了追求速度，我们需要更快一些。

### 多阶差分

首先分析$f[i]$。如果我们可以求出所有$f[i-j]*j$的前缀和，这个问题就变得非常方便了。问题是对于不同的i，这个前缀和中每一项都会发生变化。所以，前缀和并不靠谱。

前缀和每一项都会发生变化，那如果我们知道了变化的量是多少呢？于是我们就可以对前缀和进行差分。
$$\sum_{j=1}^{i}f[i-j]\cdot j \ - \ \sum_{j=1}^{i-1}f[i-1-j]\cdot j$$
$$=\sum_{j=0}^{i}f[j]\cdot(i-j) \ - \ \sum_{j=0}^{i-1}f[j]\cdot(i-1-j)$$
$$=\sum_{j=0}^{i}f[i]$$
太棒了，前缀和的变化量就是单纯的$f[i]$的前缀和！

所以，我们维护$f[i]$的前缀和，以及$f[i-j]\cdot j$的前缀和，每次将$f[i]$累加进$f[i]$的前缀和，将$f[i]$的前缀和累加进$f[i-j]\cdot j$的前缀和。事就这样成了。

然而我们还剩下$g[i]$没办法处理。其实处理办法是一样的。

$$g[i]=\sum_{j=2}^{i}f[i-j]\cdot j\cdot(j-1) $$
$$g[i]=\sum_{j=0}^{i}f[j]\cdot (i-j)\cdot (i-j-1) $$
$$\Delta g[i]=\sum_{j=0}^{i}f[j]\cdot(i-j)\cdot 2 $$
$$\Delta^2 g[i]=\sum_{j=0}^{i}f[j]\cdot2 $$
$$\Delta^3 g[i]=2f[i]$$

也就是说$g$的三阶差分就是$f$，那么我们每次把每阶差分往上累加就行了。

### 总结

所以，如果$f[i]$递推式中遇到了含有i的简单多项式，我们就可以手动差分一下，分别维护每阶差分，依次向上累加即可。

这样我们就可以只用加法完成很多有趣的事情(比如现在这道题)。

```cpp
#include <stdio.h>
#define max(x,y) (x>y?x:y)
struct BI{
	char x[43],n;
	void operator+=(BI &a)
	{
		char mx=max(n,a.n),k=0;
		for(char i=1;i<=mx||k;i++)
		{
			if(i>n)x[i]=0;
			x[i]+=a.x[i]+k;
			k=x[i]/10,x[i]%=10;
			n=max(n,i);
		}
	}
	void operator=(char a){n=1,x[1]=a;}
	void out(){for(char i=n;i>=1;i--)printf("%d",x[i]);}
};
BI f,g,f1,f2,g1,g2;
int main()
{
	char n;
	scanf("%d",&n);
	f=1,f1=1,f2=1,g1=0,g2=0;
	for(char i=1;i<=n;i++)
	{
		if(i)g2+=f,g2+=f;
		if(i<n)g1+=g2;
		if(i<n)g+=g1;
		f=f1;
		f2+=f;
		f1+=f2;
	}
	g+=f;
	g.out();
	return 0;
}
```



---

## 作者：ysner (赞：35)

做这题颇有感触啊，感觉省选题目画半个小时画图不吃亏。

看到题目，反正我的第一反应是递推。递推就要有递推式，于是我花了将近20分钟，画出n=1~5情况的轮状病毒个数:

1 5 16 45 121……

乍一看，奇数项是完全平方数，偶数项是5的倍数，我想的是往平方数上靠，于是转化成了这样：

1\*1 3\*3-4 4\*4 7\*7-4 11\*11……

1 3 4 7 11……

就是这样，原来是个变形的Fibonacci数列，前两项为1和3，然后对每一项平方，如果是偶数项就减4，AC~

递推式：F[n]=f[n]\*f[n]-4\*(n+1 mod 2)，f[n]=f[n-1]+f[n-2]，f[1]=1，f[2]=3

然后难点就在于高精度了。

对于高精度，我喜欢用刘汝佳《算法竞赛入门经典》上的大整数类，这种方法就是定义一个class，通过符号重载，让打高精度运算和打普通运算一样简单。这样就不用专为每道题打专门的高精度，需要时在程序前套板子即可。(~~但这样似乎加大了代码量~~)

随代码附上高精度模板：

```cpp
#include<iostream>
#include<cmath>
#include<cstring>
#include<cstdio>
#include<cstdlib>
#include<algorithm>
#define fp(i,a,b) for(int i=a;i<=b;i++)
#define fq(i,a,b) for(int i=a;i>=b;i--)
#define il inline
#define re register
#define ll long long 
using namespace std;
const int maxN=100001;
const int inf=2147483647;
```
class BigInteger
{
public:

int size,num[1000];//size代表数的长度，num存大整型数





```cpp
    BigInteger()//定义时自动清零
        {
            size=0;
            memset(num,0,sizeof(num));
        }
    BigInteger(int data)
        {
            size=0;
            while (data!=0)
            {
                size++;
                num[size]=data%10;
                data=data/10;
            }
        }
    void init(int data)//用来给大整型变量赋整型值
        {
            size=0;
            while (data!=0)
            {
                size++;
                num[size]=data%10;
                data=data/10;
            }
        }
};
BigInteger operator + (BigInteger A,BigInteger B)//高精度加法
{
    BigInteger Ans;
    int s=max(A.size,B.size);
    Ans.size=s;
    for (int i=1;i<=s;i++)
        Ans.num[i]=A.num[i]+B.num[i];
    for (int i=1;i<=s;i++)
        if (Ans.num[i]>=10)
        {
            Ans.num[i+1]+=Ans.num[i]/10;
            Ans.num[i]=Ans.num[i]%10;
        }
    if (Ans.num[s+1]!=0)
        Ans.size++;
    return Ans;
}
BigInteger operator - (BigInteger A,BigInteger B)//高精度减法
{
    BigInteger Ans;
    int s=max(A.size,B.size);
    Ans.size=s;
    for (int i=1;i<=s;i++)
        Ans.num[i]=A.num[i]-B.num[i];
    for (int i=1;i<=s;i++)
        if (Ans.num[i]<0)
        {
            Ans.num[i+1]-=Ans.num[i]/10;
            Ans.num[i]=Ans.num[i]%10;
        }
    if (Ans.num[s+1]!=0)
        Ans.size++;
    return Ans;
}
ostream & operator << (ostream &os,BigInteger A)//用于大整型数的输出（只能用cout）
{
    int s=A.size;
    for (int i=s;i>=1;i--)
        os<<A.num[i];
    return os;
}
BigInteger operator * (BigInteger A,BigInteger B)//高精度乘法
{
    BigInteger Ans;
    int s1=A.size,s2=B.size;
    for (int i=1;i<=s1;i++)
        for (int j=1;j<=s2;j++)
            Ans.num[i+j-1]+=A.num[i]*B.num[j];
    int s=s1+s2-1;
    int k=1;
    while ((Ans.num[k]!=0)||(k<=s))
    {
        Ans.num[k+1]+=Ans.num[k]/10;
        Ans.num[k]=Ans.num[k]%10;
        k++;
    }
    if (Ans.num[k]==0)
        k--;
    Ans.size=k;
    return Ans;
}
BigInteger Ans,Ans1,Ans2;//定义大整型数
il int gi()
{
   int x=0;
   short int t=1;
   char ch=getchar();
  while((ch<'0'||ch>'9')&&ch!='-') ch=getchar();
  if(ch=='-') t=-1,ch=getchar();
  while(ch>='0'&&ch<='9') x=x*10+ch-48,ch=getchar();
  return x*t;
}
int main()
{
    Ans1.init(1);//把Ans1赋值为1,不能写Ans1=1！！！
    Ans2.init(3);//把Ans2赋值为3,不能写Ans2=3！！！
    int n=gi();
    for(int i=3;i<=n;i++) if(i%2) Ans1=Ans1+Ans2;
        else Ans2=Ans2+Ans1;
    if(n%2) Ans=Ans1;
    else Ans=Ans2;//求f[n]
    if(n%2) Ans=Ans*Ans;
    else Ans=Ans*Ans-4;//求F[n]
    cout<<Ans<<endl;
    return 0;
}
```

---

## 作者：_ztyqwq (赞：16)

为什么这么多人打表……还有人用各种什么基尔霍夫矩阵……只能Orz啊

……~~这不是明显的DP吗~~

经过观察，可以发现每一个轮状病毒都是把外围的 $ n $ 个点分成了若干组，其中每组的点是连续的，然后每组中有一个点与中心相连。于是这就是一个分组DP了。

但是因为有环不好处理，所以我们先考虑 $ 1 $ 和 $ n $ 不在一个组里的情况。设 $ f_i $ 为 $ 1 $ 和 $ n $ 不在一个组内时所有轮状病毒的总数。则考虑 $ i $ 这个点可以得到转移方程

### $ f_i = \sum\limits_{j=1}^i(f_{i-j} \times j) $

其中 $ j $ 表示 $ i $ 跟它前面的 $ j $ 个点（包括 $ i $），也就是 $ i-j+1 $ 到 $ i $ 一组，那么前面 $ i-j $ 个点的方案总数是 $ f_{i-j} $，而这个长度为 $ j $ 的组可以在任何一个点连接中心，所以共有 $ j $ 种方案。根据乘法原理（不是加法原理！），可以得到这种情况下 $ f_i $ 的方案数是 $ f_{i-j} \times j $。枚举 $ j $ 累加即可。

边界情况为 $ f_0 = 1 $。

但是这样只能算出 $ 1 $ 和 $ n $ 不在一组的情况。我们考虑一般情况：

1. 如果 $ 1 $ 和 $ 2 $ 不在一组，那么方案数为 $ \sum\limits_{i=1}^n(f_{n-i} \times i) $（为了一般性不用 $ f_n $）

2. 如果 $ 1 $ 和 $ 2 $ 在一组，但 $ 2 $ 和 $ 3 $ 不在一组，那么方案数为 $ \sum \limits_{i=2}^n(f_{n-i} \times i )$。其实跟上面的分析方法没有区别，只是因为 $ 1 $ 和 $ 2 $ 必须在一组，所以含 $ 1 $ 的这一组长度 $ \geqslant 2 $，所以从 $ 2 $ 开始枚举。

3. 如果 $ 1 $ 和 $ 2 $ 在一组，$ 2 $ 和 $ 3 $ 在一组，但 $ 3 $ 和 $ 4 $ 不在一组，那么方案数为 $ \sum \limits_{i=3}^n(f_{n-i} \times i )$。

...

$ n-1. $ 如果 $ 1 $ 到 $ n-1 $ 都在一组，而 $ n-1 $ 和 $ n $ 不在一组，那么方案数为 $ \sum \limits_{i=n-1}^n(f_{n-i} \times i )$

$ n. $ 如果 $ 1 $ 到 $ n $ 都在一组，那么方案数为 $ \sum \limits_{i=n}^n(f_{n-i} \times i )$，其实就是 $ f_0 \times n = n $

那么把前面说的东西全都加起来，就可以得到最终答案：

$ \sum\limits_{i=1}^n\sum\limits_{j=i}^n(f_{n-j} \times j) $

### $ = \sum\limits_{i=1}^n(f_{n-i} \times i^2) $

最后一个式子的 $ i $ 其实是上面的 $ j $，我们统计 $ (f_{n-j} \times j) $ 出现的次数就可以得到这个答案。

然后我们发现可以在计算 $ f_i $ 的时候就统计它对答案的贡献，所以边算边做就可以了。

时间复杂度 $ O(n^2) $。

然而出题人很~~不~~良心地没让取模，所以得写一个高精。实测最大答案长度 $ = 44 $，但是开 $ 100 $ 也可以。

上Code：

```cpp
#include<bits/stdc++.h>
using namespace std;
struct cint
{
    int a[101];
    cint(int x=0)
    {
        memset(a,0,sizeof(a));
        a[1]=x;
    }
    int size()const
    {
        for(int i=100;i>=2;i--)
            if(a[i])
                return i;
        return 1;
    }
    cint operator+(const cint& ano)const
    {
        int s=max(size(),ano.size());
        cint ans;
        for(int i=1;i<=s;i++)
        {
            ans.a[i]+=a[i]+ano.a[i];
            ans.a[i+1]+=ans.a[i]/10;
            ans.a[i]%=10;
        }
        return ans;
    }
    cint operator*(const int& ano)const
    {
        int s=size();
        cint ans;
        for(int i=1;i<=s;i++)
        {
            ans.a[i]+=a[i]*ano;
            ans.a[i+1]+=ans.a[i]/10;
            ans.a[i]%=10;
        }
        while(ans.a[++s])
        {
            ans.a[s+1]+=ans.a[s]/10;
            ans.a[s]%=10;
        }
        return ans;
    }
    void print()const
    {
        int s=size();
        for(int i=s;i>=1;i--)
            putchar(a[i]+'0');
        putchar('\n');
    }
}f[101];
int main()
{
    int n;
    scanf("%d",&n);
    f[0]=1;
    cint ans=0;
    for(int i=0;i<n;i++)
    {
        for(int j=1;j<=i;j++)
            f[i]=f[i]+f[i-j]*j;
        ans=ans+f[i]*(n-i)*(n-i);
    }
    ans.print();
    return 0;
}
```

---

## 作者：panda_2134 (赞：16)

矩阵树定理裸题。  
中间的点度数为n，其他点度数为3，定义基尔霍夫矩阵为度数矩阵减去邻接矩阵，划去一行一列求行列式值即可。  
但是long double都存不下。由于 $0 \le n \le 100$，我们可以愉快地 python 打表再交表。    
python代码如下，写了个用Decimal的高斯消元。

```python3
#!/usr/bin/env python3
from decimal import Decimal, getcontext
getcontext().prec = 50

def main():
	n = int(input())
	if n == 1:
		print(1)
	elif n == 2:
		print(5)
	else: # 生成基尔霍夫矩阵A
		A = [[Decimal(3 * int(i == j) - int(j == (i-1+n)%n or j == (i+1+n) % n)) \
			 for j in range(n)] for i in range(n)]
		for i in range(n): # 高斯消元
			r = i
			for j in range(i+1, n):
				if abs(A[j][i]) > abs(A[r][i]):
					r = j
			if r != i:
				A[r], A[i] = A[i], A[r]
			for t in range(i+1, n):
				k = A[t][i] / A[i][i]
				for j in range(n):
					A[t][j] -= A[i][j] * k
		Ans = Decimal('1')
		for i in range(n):
			Ans *= A[i][i]
		print("{:.0f}".format(Ans))
if __name__ == '__main__':
	main()
```

---

## 作者：lyyi2003 (赞：14)

# ~~遇到这种题我只会打表~~

设f[i]表示n=i时的答案，~~打表可得~~ ：

	f[1]=1,f[2]=5,f[3]=16,
    
   	f[i]=3*f[i-1]-f[i-2]+2 
    
    
 （怎么感觉自己的公式比别人的简单好多啊）
 
 再套高精度即可。。。
 
 打表代码如下：
 
 ```cpp
 #include<bits/stdc++.h>
using namespace std;
#define N 107
#define M 13
#define ll long long
const ll bit=1e9;
struct edge
{
	int x,y;
}e[N];
int tot,fa[N],n,ans;
int find(int x)
{
	return x==fa[x]?x:fa[x]=find(fa[x]);
}
void dfs(int x,int d)
{
	if(d+tot-x+1<n)return;
	if(d>=n){ans++;return;}
	dfs(x+1,d);
	int a=e[x].x,b=e[x].y;
	int u=find(a),v=find(b);
	if(u!=v)
	{
		int tmp[N];
		memcpy(tmp,fa,sizeof(fa));
		fa[u]=v;
		dfs(x+1,d+1);
		memcpy(fa,tmp,sizeof(fa));
	}
}
int main()
{
	int i;
	for(n=1;n<=10;n++)
	{
		ans=0;tot=0;
		for(i=1;i<n;i++)
			e[++tot]={i,i+1};
		e[++tot]={n,1};
		for(i=1;i<=n;i++)
			e[++tot]={i,n+1};
		for(i=1;i<=n+1;i++)
			fa[i]=i;
		dfs(1,0);
		printf("%d\n",ans);
	}
	return 0;
}
```

然后是AC的代码：
```cpp
// luogu-judger-enable-o2
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define N 107
#define M 13
const ll bit=1e9;
struct nb
{
    ll a[M];
    int l;
    nb(){memset(a,0,sizeof(a)),l=0;}
    ll &operator [](int x){return a[x];}
    void operator =(int x){a[0]=x;}
    void operator +=(int x)
    {
        int i=0;
        a[0]+=x;
        while(a[i]>=bit)
        {
            a[i]-=bit;
            a[i+1]++;
            i++;
        }
        if(a[l+1])l++;
    }
    void operator *=(int x)
    {
        int i=0;
        ll rest=0;
        for(i=0;i<=l;i++)
        {
            a[i]=a[i]*x+rest;
            rest=a[i]/bit;
            a[i]%=bit;
        }
        if(rest)a[++l]=rest;
    }
    void operator -=(nb b)
    {
        int i=0;
        for(i=0;i<=b.l;i++)
        {
            a[i]-=b[i];
            if(a[i]<0)a[i]+=bit,a[i+1]--;
        }
        while(a[i]<0)a[i]+=bit,a[i+1]--,i++;
        while(l>0&&a[l]==0)l--;
    }
    void print()
    {
        printf("%lld",a[l]);
        for(int i=l-1;i>=0;i--)
            printf("%09lld",a[i]);
    }
}f[N];
int main()
{
    int i,n;
    scanf("%d",&n);
    f[1]=1,f[2]=5,f[3]=16;
    for(i=4;i<=n;i++)
    {
        f[i]=f[i-1];
        f[i]*=3;
        f[i]-=f[i-2];
        f[i]+=2;
    }
    f[n].print();
    return 0;
}
```


---

## 作者：WJiannan (赞：11)

一开始我看到这个就像直接上一个 $\mathrm{MatrixTree}$ + 高精度，据说是近似 $O(n^4)$。


接着我用分数来优化高精度（显然不行）；


接着我打表找规律（并没有发现什么）。


于是只能推式子了。


考虑把先不管中心点，然后把外围的 $n$ 个点拆环成链，暂时强制第一个点不能和最后一个点连边。


于是方案数就类似一个整数拆分，将外围的点分成若干个联通块，


即设 $f_i$ 为当前已经分配了前 $i$ 个点的方案数，$f_i = \sum_{j=1}^{i} f_{i-j} \times j$（因为每加入一个联通块，中心点都可以向其中的任意一个点连边）。


但是我们还需要考虑上第一个点与最后一个点连边的情况，发现，如果分配第一个联通块大小为 $x$，那么我们可以把这张图逆时针旋转，则总共有 $x$ 种不同的方案。


于是答案的计算方式就等于 $$f_i=\sum_{j=1}^{i-1} f_{i-j} \times j +f_0 \times i \times i$$


再套个高精度，复杂为 $O(n^3)$。


本文认为此题高精度近似 $O(n)$。


```cpp
#include <cstdio>
#include <cstring>
#define R register
#define Max(_A, _B) (_A > _B ? _A : _B)
const int Mod = 1e8;
struct BigNum
{
    int a[110], len;
    BigNum(){ len = 1; }
    friend BigNum operator + (R BigNum A, R BigNum B)
    {
        A.len = Max(A.len, B.len);
        for(R int i = 0; i < A.len; i++) 
        {
            R int tmp = A.a[i] + B.a[i];
            A.a[i] = tmp % Mod;
            A.a[i + 1] += tmp / Mod;
        }
        while(A.a[A.len]) A.len++;
        return A;
    }
    BigNum operator * (R int K)
    {
        R BigNum T; 
        memset(T.a, 0, sizeof(T.a)); T.len = len;
        for(R int i = 0; i < len; i++)
        {
            R long long tmp = 1ll * a[i] * K + T.a[i];
            T.a[i + 1] += tmp / Mod;
            T.a[i] = tmp % Mod;
        }
        while(T.a[T.len]) T.len++;
        return T;
    }
    void Print()
    {
        printf("%d", a[len - 1]);
        for(R int i = len - 2; i >= 0; i--) printf("%.8d", a[i]);
        puts("");
    }
} f[110];
int n;
int main()
{
    scanf("%d", &n);
    f[0].a[0] = 1;
    for(R int i = 0; i < n; i++)
        for(R int j = 1; i + j <= n; j++)
            if(i == 0) f[i + j] = f[i + j] + f[i] * (j * j);
            else f[i + j] = f[i + j] + f[i] * j;
    f[n].Print();
    return 0;
}
```

---

## 作者：xuxinyu (赞：9)

都说打表找规律，这个表怎么打？

每种n轮状病毒对应着一种不同的生成树

同样，n+1个点的生成树对应着不同的n轮状病毒

所以
n轮状病毒的种数 ==

n+1个点，已知每个点可以连出的边 的生成树的个数

现在问题转化为求生成树的个数

构造出基尔霍夫矩阵解行列式即可

代码：（因为没有打高精所以只能做到n=44）

        



```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
typedef long long LL;
LL C[101][101];
int n;
void Matrix_tree()
{
    memset(C,0,sizeof(C));
    if(n==1)
    {
        C[0][0]=C[1][1]=1;
        C[0][1]=C[1][0]=-1;
    }
    else if(n==2)
    {
        C[0][0]=2;
        C[1][1]=C[2][2]=3;
        C[0][1]=C[0][2]=C[1][0]=C[2][0]=-1;
        C[1][2]=C[2][1]=-2;
    }
    else
    {
        C[0][0]=n;
        for(int i=1;i<=n;i++) C[i][0]=C[0][i]=-1;
        for(int i=1;i<=n;i++) C[i][i]=3;
        C[1][2]=C[1][n]=-1;
        C[n][n-1]=C[n][1]=-1;
        for(int i=1;i<n;i++) C[i][i-1]=C[i][i+1]=-1;
    }
    LL ans=1,t;
    for(int i=1;i<=n;i++)
    {
        for(int j=i+1;j<=n;j++)
            while(C[j][i])
            {
                t=C[i][i]/C[j][i];
                for(int k=i;k<=n;k++) C[i][k]-=C[j][k]*t;
                for(int k=i;k<=n;k++) swap(C[i][k],C[j][k]);
                ans=-1;
            }
        ans*=C[i][i];
    }
    if(ans<0) ans=-ans;
    cout<<ans<<endl;
}
int main()
{
    while(scanf("%d",&n)!=EOF)
    Matrix_tree();
}

```

---

## 作者：brealid (赞：7)

看到题目，我的思路主要是：

> 1. 输入为 $1$ 个，输出也为 $1$ 个 $\Rightarrow$ 答案之间存在关系（递推）

手算中……
```plain
   n | 1 | 2 |  3 |  4 |  5  |  6  |  7  |  8 
-----+---+---+----+----+-----+-----+-----+------
 ans | 1 | 5 | 16 | 45 | 121 | 320 | 841 | 2205
```

（为什么不用 markdown 的表格？$luogu <\!3.9\!>$ 的 markdown 表格实在太丑了）

> 2. 尝试发现规律

奇数项：完全平方数  
偶数项：前一项的 $3$ 倍 减去 前二项 加上 $2$

然后经过一堆推导……

$f[i]=\begin{cases}f[i-1]+f[i-2]&(i\geqslant3)\\3&(i=2)\\1&(i=1)\end{cases}$

$ans[i]=\begin{cases}f[i]^2&(i\equiv 1 \pmod{2})\\f[i]^2-4&(i\equiv 0 \pmod{2})\end{cases}$

然后……

就没然后了。

我们可以加上高精度，然后愉快地 $AC$。

本人所用高精度模板：[传送门](https://www.luogu.org/paste/lwimhe43) （支持像普通整数一样使用，输入输出支持 cin, cout）

AC代码：
```
/*************************************
 * problem:      P2144 [FJOI2007]轮状病毒.
 * user ID:      63720.
 * user name:    航空信奥.
 * time:         2019-03-31.
 * language:     C++.
 * upload place: Luogu.
*************************************/ 

#include <bits/stdc++.h>
using namespace std;

struct big_integer
{
    static const int base = 1000;
    static const int width = 3;

    vector<int> v;
    bool is_negative;

    big_integer(long long num = 0)
    {
        *this = num;
        is_negative = false;
    }

    big_integer operator = (long long val)
    {
        v.clear();

        if (val < 0)
        {
            val = -val;
            is_negative = true;
        }
        do
        {
            v.push_back(val % base);
            val /= base;
        } while (val > 0);

        return *this;
    }

    big_integer operator = (const string &str) 
    {
        v.clear();

        string str2 = str;
        if (str2[0] == '-')
        {
            is_negative = true;
            for (string::iterator i = str2.begin(); i < str2.end() - 1; i++)
            {
                *i = *(i + 1);
            }
            *(str2.end() - 1) = '\0';
            str2.resize(str2.length() - 1);
        }

        int cur, len = (str2.length() - 1) / width + 1;
        for (int i = 0; i < len; i++)
        {
            int end = str2.length() - i * width;
            int begin = max(0, end - width);
            sscanf(str2.substr(begin, end - begin).c_str(), "%d", &cur);
            v.push_back(cur);
        }

        return *this;
    }

    big_integer operator + (const big_integer &addend) const 
    {
        big_integer sum;
        sum.v.clear();

        if (is_negative == true)
        {
            if (addend.is_negative == true) sum.is_negative = true;
            else return addend - (-*this);
        }
        else if (addend.is_negative == true)
        {
            return *this - (-addend);
        }

        for (int i = 0, carry = 0; carry != 0 || i < v.size() || i < addend.v.size(); i++)
        {
            int cur = carry;
            if (i < v.size()) cur += v[i];
            if (i < addend.v.size()) cur += addend.v[i];
            carry = cur / base;
            cur %= base;
            sum.v.push_back(cur);
        }

        return sum;
    }

    big_integer operator - (const big_integer &subtrahend) const 
    {
        big_integer difference;
        difference.v.clear();

        if (is_negative == false && subtrahend.is_negative == false && *this < subtrahend)
            return -(subtrahend - *this);
        if (is_negative == true && subtrahend.is_negative == false)
            return -(-*this + subtrahend);
        else if (is_negative == false && subtrahend.is_negative == true)
            return *this + (-subtrahend);
        else if (is_negative == true && subtrahend.is_negative == true)
            return -subtrahend - (-*this);

        for (int i = 0, carry = 0; carry != 0 || i < v.size(); i++)
        {
            int cur = v[i] + carry;
            if (i < subtrahend.v.size()) cur -= subtrahend.v[i];
            if (cur >= 0) carry = 0;
            else
            {
                carry = -1;
                cur += base;
            }
            difference.v.push_back(cur);
        }

        for (int i = difference.v.size() - 1; i >= 0; i--)
        {
            if (difference.v[i] == 0) difference.v.resize(difference.v.size() - 1);
            else break;
        }
        if (difference.v.size() == 0) difference.v.resize(1, 0);

        return difference;
    }

    big_integer operator - () const 
    {
        big_integer big_int = *this;
        big_int.is_negative = !(is_negative);
        return big_int;
    }

    big_integer operator * (const big_integer &multiplier) const
    {
        big_integer product;
        product.v.clear();

        if (is_negative != multiplier.is_negative) product.is_negative = true;

        for (int i = 0; i < v.size(); i++)
        {
            for (int j = 0; j < multiplier.v.size(); j++)
            {
                if (i + j >= product.v.size()) product.v.resize(i + j + 1, 0);
                product.v[i + j] += this->v[i] * multiplier.v[j];
                if (product.v[i + j] >= base)
                {
                    if (i + j + 1 >= product.v.size()) product.v.resize(i + j + 1 + 1, 0);
                    product.v[i + j + 1] += product.v[i + j] / base;
                    product.v[i + j] %= base;
                }
            }
        }

        for (int i = product.v.size() - 1; i >= 0; i--)
        {
            if (product.v[i] == 0) product.v.resize(product.v.size() - 1);
            else break;
        }
        if (product.v.size() == 0) product.v.resize(1, 0);

        return product;
    }

    big_integer operator / (const big_integer &divisor) const // Division
    {
        big_integer divisor__ = divisor;
        big_integer quotient = 0;

        if (is_negative != (divisor < 0)) quotient.is_negative = true;

        big_integer remainder = 0;
        for (int i = v.size() - 1; i >= 0; i--)
        {
            remainder = remainder * base + v[i];

            int lwr_bound = 0, upr_bound = base - 1, mid;
            big_integer mid_bi;
            while (lwr_bound <= upr_bound)
            {
                mid = (lwr_bound + upr_bound) / 2;
                mid_bi = (long long)mid;
                big_integer bi = remainder - mid_bi * divisor;
                if (remainder - mid_bi * divisor < divisor && remainder - mid_bi * divisor >= 0) break;
                else if (remainder - mid_bi * divisor >= divisor) lwr_bound = mid + 1;
                else upr_bound = mid - 1;
            }

            quotient = quotient * base + mid_bi;
            remainder = remainder - mid_bi * divisor;
        }

        for (int i = quotient.v.size() - 1; i >= 0; i--)
        {
            if (quotient.v[i] == 0) quotient.v.resize(quotient.v.size() - 1);
            else break;
        }
        if (quotient.v.size() == 0) quotient.v.resize(1, 0);

        return quotient;
    }

    big_integer operator % (const big_integer &divisor) const 
    {
        big_integer quotient = *this / divisor;
        big_integer remainder = *this - quotient * divisor;
        return remainder;
    }

    big_integer operator += (const big_integer &addend)
    {
        *this = *this + addend;
        return *this;
    }

    big_integer operator -= (const big_integer &subtrahend) 
    {
        *this = *this - subtrahend;
        return *this;
    }

    big_integer operator *= (const big_integer &multiplier) 
    {
        *this = *this * multiplier;
        return *this;
    }

    big_integer operator /= (const long long &divisor) 
    {
        *this = *this / divisor;
        return *this;
    }

    big_integer operator %= (const long long &divisor) 
    {
        *this = *this / divisor;
        return *this;
    }

    big_integer operator ++ () 
    {
        big_integer addend = (long long)1;
        *this = *this + addend;
        return *this;
    }

    big_integer operator -- () 
    {
        big_integer subtrahend = (long long)1;
        *this = *this - subtrahend;
        return *this;
    }

    big_integer operator ++ (int) 
    {
        big_integer addend = (long long)1;
        *this = *this + addend;
        return *this;
    }

    big_integer operator -- (int) 
    {
        big_integer subtrahend = (long long)1;
        *this = *this - subtrahend;
        return *this;
    }

    bool operator < (const big_integer &big_int) const 
    {
        if (is_negative == true && big_int.is_negative == false) return true;
        if (is_negative == false && big_int.is_negative == true) return false;
        if (is_negative == true && big_int.is_negative == true)
        {
            big_integer big_int1, big_int2;
            big_int1 = *this; big_int1.is_negative = false;
            big_int2 = big_int; big_int2.is_negative = false;
            return big_int2 < big_int1;
        }

        if (v.size() != big_int.v.size()) return v.size() < big_int.v.size();
        for (int i = v.size() - 1; i >= 0; i--)
        {
            if (v[i] != big_int.v[i]) return v[i] < big_int.v[i];
        }

        return false;
    }

    bool operator > (const big_integer &big_int) const
    {
        return big_int < *this;
    }

    bool operator <= (const big_integer &big_int) const 
    {
        return !(*this > big_int);
    }

    bool operator >= (const big_integer &big_int) const 
    {
        return !(*this < big_int);
    }

    bool operator != (const big_integer &big_int) const 
    {
        return *this < big_int || *this > big_int;
    }

    bool operator == (const big_integer &big_int) const 
    {
        return !(*this != big_int);
    }

    friend istream &operator >> (istream &in, big_integer &big_int) 
    {
        string str;
        if (!(in >> str)) return in;
        big_int = str;
        return in;
    }

    friend ostream &operator << (ostream &out, big_integer &big_int)
    {
        if (big_int.is_negative == true) out << '-';
        out << big_int.v.back();

        for (int i = big_int.v.size() - 1 - 1; i >= 0; i--)
        {
            char str[base + 5];
            sprintf(str, "%0*d", width, big_int.v[i]);
            out << str;
        }

        return out;
    }
};

int n;

big_integer f[107], ans;

int main()
{
    cin >> n;
    f[1] = 1;
    f[2] = 3;
    for (int i = 3; i <= n; i++) {
        f[i] = f[i - 1] + f[i - 2];
    }
    ans = f[n] * f[n];
    if ((n & 1) == 0) ans -= 4;
    cout << ans;
    return 0;
}

```

---

## 作者：eros1on (赞：7)

其实这道题很简单，只需打表即可（我是认真的！）

首先，手算出前4个答案。

将其输入到[这个网站](http://oeis.org/)中。

你找到的第一个序列就是[答案序列](http://oeis.org/A004146)。

复制这个序列的前15个数。

然后，将这十五个数粘贴（中间有空格）到[这个网站](https://www.wolframalpha.com/)
的搜索框中。

点击Enter，翻到底部，你就会~~惊奇地~~发现这个网站给你了打表的机会！

多次点击图表右上角的`More`键你就可以获得100个啦！

点击左下角的`Plaintext`复制到编程软件中，编一个小程序帮助每个数加上一个双引号，C++代码如下（加引号）:
```cpp
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
#define MAXN 100100
char ch[MAXN];
int main(){
    freopen("1.txt", "w", stdout); // 输出到1.txt中
    cin.getline(ch, 100100);
    int len = strlen(ch);
    for(int i = 0; i < len; i)
        if(ch[i] >= '0' && ch[i] <= '9'){
            printf("\""); // 加引号
            while(ch[i] >= '0' && ch[i] <= '9') printf("%c", ch[i]), i++;
            printf("\"");
        } else printf("%c", ch[i]), i++;
    return 0;
}
```

然后就简单啦。。。

---

## 作者：shuiyuhan (赞：6)

怎么pascal题解这么少啊，本蒟蒻也来贡献一篇呗~~~

一看这题，第一想到~~(打表)~~找规律，

于是就开心的手推了前几个答案为1 5 16 45 121...

不难发现，奇数项是完全平方数，偶数项是5的倍数，

又可得前两项是1和3的斐波那契数列，于是有了递推式
  
  f[n]=f[n-1]+f[n-2]; 

  F[n]=F[n]^2-(1-n mod 2)*4
  
  当n=100时显然要爆int64，于是要写高精
  
  ```pascal
  
 uses math;
var
  a,b,c,d,f:array[0..1000005] of longint;
  i,j,n,k,m,la,lb,lc:longint;
procedure jia(p:longint); 斐波那契数列的加法，用2个数组轮换存储，一个d数组临时存储 
var
  i,j,n,k,m:longint;
begin
    fillchar(d,sizeof(d),0);
    for i:=1 to max(la,lb) do
    begin
      d[i]:=d[i]+c[i]+b[i];
      d[i+1]:=d[i] div 10;
      d[i]:=d[i] mod 10;
    end;
    if odd(p) then
    begin
      lb:=lb+d[lb+1];
      for i:=1 to lb do c[i]:=d[i];
    end
    else
    begin
      la:=la+d[la+1];
      for i:=1 to la do b[i]:=d[i];
    end;
    if (b[la+1]<>0) then inc(la);
    if (c[lb+1]<>0) then inc(lb);
    lc:=max(la,lb);//d数组的长度是la,lb中的最大的长度
  end;
procedure cheng1();//处理c*f
var
  i,j,n,k,m,x:longint;
begin
  fillchar(d,sizeof(d),0);
  for i:=1 to la do
  begin
    x:=0;
    for j:=1 to lb do
    begin
      d[i+j-1]:=c[i]*f[j]+x+d[i+j-1];
      x:=d[i+j-1] div 10;
      d[i+j-1]:=d[i+j-1] mod 10;
    end;
    d[i+j]:=x;
  end;
  lc:=la+lb;
  while (d[lc]=0)and(lc>1) do dec(lc);
end;
procedure cheng();//处理b*f的情况
var
  i,j,n,k,m,x:longint;
begin
  fillchar(d,sizeof(d),0);//d数组清零
  for i:=1 to la do
  begin
    x:=0;
    for j:=1 to lb do
    begin
      d[i+j-1]:=b[i]*f[j]+x+d[i+j-1];
      x:=d[i+j-1] div 10;
      d[i+j-1]:=d[i+j-1] mod 10;
    end;
    d[i+j]:=x;
  end;
  lc:=la+lb;
  while (d[lc]=0)and(lc>1) do dec(lc);
end;
procedure jian();//公式得只减4
var
  i:longint;
begin
  d[1]:=d[1]-4;
  for i:=1 to lc do
  begin
    if d[i]<0 then
    begin
      d[i]:=d[i]+10;
      dec(d[i+1]);
    end;
  end;
  while (d[lc]=0)and(lc>1)  do dec(lc);
end;
begin
  readln(n);
  la:=1;
  lb:=1;//la,lb是b,c数组的长度
  b[1]:=3;
  c[1]:=1;
  if n=1 then begin writeln(1); halt; end;
  if n=2 then begin writeln(5); halt; end;
  //根据推出来的公式，需要特判n=1,2的情况
  for i:=3 to n do
  begin
    if i mod 2=0 then
    begin
      jia(i);//加法
      for j:=1 to lc do f[j]:=b[j];
      //f数组是临时数组，暂存值
      lb:=lc;
      cheng();//乘法
      jian();//减法
    end else
    begin
      jia(i);
      for j:=1 to lc do f[j]:=c[j];
      la:=lc;
      cheng1();
    end;
  end;
  for j:=lc downto 1 do write(d[j]);
  //输出,因为用了反存，所以要倒序输出
end.

```

---

## 作者：YLWang (赞：5)

决心写一篇真正易懂的题解。第一页的几个大佬们写的有点晦涩难懂，制裁了一下什么都不想就要看题解的我。自己想这种题真的非常有必要。

给自己总结，给大家讲解一下解一道这种类型的题的解题步骤。

## Step 1 模型转化
我们把中心点独立出去。重点关注外圈点。

容易发现，外圈的点本质上是被分成了一些联通块。 而每一个联通块中**有且仅有**一个点与中间相连。

于是我们的问题就转化完了。现在我们要针对的，就是外圈点。

## Step 2 寻找合适的算法
这一步里经验成分比较多。

这道题感觉像是一个环上$dp$问题。那么此时，我们就应该来浅浅地考虑一下递推式。如果感觉不对，就应该去思考别的算法。但特别注意，就算你认为一个算法是不能解决这道题的，也请在时间充足的时候仔仔细细地思考它。有可能会有意外的收获。

非常幸运地，我们发现此题似乎可以这样解决。
## Step 3 深入思考

首先，环上$dp$的套路就是断环成链。我们考虑先不连接边$1-n$。

我们定义 $dp_i$ 表示前 $i$ 个点连接的不同方案数。

那么我们枚举$(i, i-1, i-2, ..., i-j+1)$这一个连通块的**长度**$j$。我们考虑到中间的点可以连接这个连通块中任何一个点，有$j$种方案。由我们的枚举方式，$i-j+1$和$i-j$之间一定是断开的（否则连通块长度就是$j+1$了）。此时前面$i-j$个点就有$dp_{i-j}$种连接方式。那么就有转移方程$dp_i = \sum\limits_{j=1}^{i}dp_{i-j} * j$。这样的最终方法数就是$dp_n$。

接下来考虑存在$1-n$连边的情况。这是本题的难点。

容易发现，对于包含$1-n$这个联通块，不管它多大，都是一种新方案.

这启示我们枚举$1-n$联通块的大小$sz$。那么剩下了$n-sz$个点。

可以发现包含$1-n$，大小为$sz$的联通块一共有$sz$个。每一种方案下，中间点都可以和这个联通块中任何一个点连边，共有$sz$中方法。剩余$n-sz$个点的方案数就是$dp_{n-sz}$。这样的话，大小为$sz$的方法数就是$sz^2*dp_{n-sz}$

那么就可以的到最终的结果了。

##  Step 4 细节实现
我们粗略估计，发现最终结果可能会爆ll。
于是要使用高精度来实现这题。

代码非常简单，不予赘述。

---

## 作者：Mr_Spade (赞：4)

提供一个比较新颖的解法吧！

直接上矩阵树定理也是可以过的（矩阵树定理：设无向图$G$的度数矩阵为$D$，邻接矩阵为$A$，$C=D-A$，那么将$C$的第$i$行第$i$列（$i$可以任意选择）去掉以后的行列式就是$G$的生成树个数。）！

当然，我们需要一些技巧。

首先我们可以考虑将答案对一个$int$范围的素数取模，于是利用矩阵树定理就可以在$O(n^3)$的时间内得出答案。

可是这道题不让取模，怎么办呢，于是我们想到了中国剩余定理。

没错，我们只要对若干个素数取模，再用中国剩余定理将答案合并就可以得到答案对一个非常大的数取模以后的结果，当这个模数大于答案的时候，我们就可以得到答案的准确值。

然而中国剩余定理似乎涉及到了取模和求逆元之类的操作...这样高精度似乎很麻烦，但是我们是可以通过一些技巧避免这样的运算。

先列出我们需要的所有高精度运算：高精度加减法，高精度乘以单精度，大小比较，因此下文的乘法都指高精度乘以单精度。

回顾一下中国剩余定理的过程：

我们已知$k$个模线性方程组：

$$x \equiv a_1(\mod m_1)$$
$$x \equiv a_2(\mod m_2)$$
$$...$$
$$x \equiv a_k(\mod m_k)$$

设$M=\prod_{i=1}^k m_i$，$M_i=\frac{M}{m_i}$，那么：
$$Ans=(\sum_{i=1}^k a_i*M_i*M_i^{-1})\mod M$$

其中$M_i^{-1}$表示$M_i$在模$m_i$意义下的逆元。

于是我们可以发现，$a_i$和$M_i^{-1}$都是可以用单精度直接计算的，于是只要将$M_i$计算出以后再乘以这两个数即可。可是这里有一个问题：我们要将结果对$M$取模，怎么办呢，可以发现唯一需要保留高精的的$M_i$有一个很好的性质，就是$M_i*m_i \equiv 0(\mod M)$，因此将$a_i$与$M_i^{-1}$相乘以后模$m_i$再和$M_i$相乘结果也是不变的，所以这个和式中的每一项都小于$M$，我们只要逐一相加并判断是否大于等于$M$，如果是的话减去一个$M$就可以了。

至于素数的选择，我觉得选择$7$个在$10^9$左右的素数就足够了。

于是整体复杂度是$O(n^3+\log Ans)$，通过了这道题。

代码：
```cpp
#include<cstdio>
#include<algorithm>
#include<vector>
#define register
using std::min;
using std::max;
using std::swap;
using std::vector;
typedef long long ll;
struct __int65536
{
	ll base=1000000000;
	vector<ll> v;
	inline void out()
	{
		if(!v.size())
			return void(putchar('0'));
		register int i;
		printf("%lld",v[(int)v.size()-1]);
		for(i=(int)v.size()-2;i>=0;i--)
			printf("%09lld",v[i]);
		return;
	}
	inline void update()
	{
		register int i;
		for(i=0;i<(int)v.size()-1;i++)
		{
			v[i+1]+=v[i]/base;v[i]%=base;
			if(v[i]<0)
				v[i]+=base,v[i+1]--;
		}
		while(v[(int)v.size()-1]>=base)
			v.push_back(v[(int)v.size()-1]/base),v[(int)v.size()-2]%=base;
		while(v[(int)v.size()-1]==0)
			v.pop_back();
		return;
	}
	inline bool operator>=(__int65536 th)
	{
		if(v.size()!=th.v.size())
			return v.size()>th.v.size();
		register int i;
		for(i=(int)v.size()-1;i>=0;i--)
			if(v[i]!=th.v[i])
				return v[i]>th.v[i];
		return 1;
	}
	inline __int65536 operator=(int th)
	{
		v.resize(1);
		v[0]=th;
		update();
		return *this;
	}
	inline __int65536 operator+(__int65536 th)
	{
		__int65536 res;
		register int i;
		res.v.resize((int)max(v.size(),th.v.size()));
		for(i=0;i<(int)min(v.size(),th.v.size());i++)
			res.v[i]=v[i]+th.v[i];
		for(i=(int)v.size();i<(int)max(v.size(),th.v.size());i++)
			res.v[i]=v[i];
		for(i=(int)th.v.size();i<(int)max(v.size(),th.v.size());i++)
			res.v[i]=th.v[i];
		res.update();
		return res;
	}
	inline __int65536 operator+=(__int65536 th)
	{
		register int i;
		v.resize((int)max(v.size(),th.v.size()));
		for(i=0;i<(int)th.v.size();i++)
			v[i]+=th.v[i];
		update();
		return *this;
	}
	inline __int65536 operator-=(__int65536 th)
	{
		register int i;
		v.resize((int)max(v.size(),th.v.size()));
		for(i=0;i<(int)th.v.size();i++)
			v[i]-=th.v[i];
		update();
		return *this;
	}
	inline __int65536 operator*(int th)
	{
		__int65536 res;
		register int i;
		res.v.resize((int)v.size());
		for(i=0;i<(int)res.v.size();i++)
			res.v[i]*=th;
		res.update();
		return res;
	}
	inline __int65536 operator*=(int th)
	{
		register int i;
		for(i=0;i<(int)v.size();i++)
			v[i]*=th;
		update();
		return *this;
	}
};
const int prime[7]={998244353,998244389,998244391,1000000007,1000000009,1000000021,1000000033};
int mod;
inline int add(int a,int b)
{
	if((a+=b)>=mod)
		a-=mod;
	return a;
}
inline int sub(int a,int b)
{
	if((a-=b)<0)
		a+=mod;
	return a;
}
inline int mul(int a,int b)
{
	return (ll)a*b%mod;
}
inline int qpow(int a,int b)
{
	int res=1;
	for(;b;a=mul(a,a),b>>=1)
		if(b&1)
			res=mul(res,a);
	return res;
}
const int N=105;
int n;
int a[N][N];
inline int det(int n)
{
	int res=1,now;
	register int i,j,k;
	for(i=1;i<=n;i++)
	{
		for(now=i;now<=n;now++)
			if(a[now][i])
				break;
		if(now>n)
			return 0;
		if(now!=i)
		{
			res=sub(0,res);
			for(j=i;j<=n;j++)
				swap(a[i][j],a[now][j]);
		}
		now=qpow(a[i][i],mod-2);
		for(j=i+1;j<=n;j++)
		{
			a[j][i]=mul(a[j][i],now);
			for(k=i+1;k<=n;k++)
				a[j][k]=sub(a[j][k],mul(a[j][i],a[i][k]));
			a[j][i]=0;
		}
	}
	for(i=1;i<=n;i++)
		res=mul(res,a[i][i]);
	return res;
}
inline int solve(int x)
{
	register int i,j;
	mod=prime[x];
	for(i=1;i<=n;i++)
		for(j=1;j<=n;j++)
			a[i][j]=0;
	for(i=1;i<n;i++)
		a[i][i+1]=sub(a[i][i+1],1),a[i+1][i]=sub(a[i+1][i],1);
	a[n][1]=sub(a[n][1],1);a[1][n]=sub(a[1][n],1);
	for(i=1;i<=n;i++)
		a[i][i]=3;
	return det(n);
}
int ans[7];
__int65536 final,b,Mod;
signed main()
{
	int cur;
	register int i,j;
	scanf("%d",&n);
	Mod=1;
	for(i=0;i<7;i++)
		ans[i]=solve(i),Mod*=prime[i];
	for(i=0;i<7;i++)
	{
		mod=prime[i];
		cur=1;b=1;
		for(j=0;j<7;j++)
			if(i!=j)
				cur=mul(cur,prime[j]),b*=prime[j];
		b*=mul(ans[i],qpow(cur,mod-2));
		final+=b;
		if(final>=Mod)
			final-=Mod;
	}
	final.out();
	putchar('\n');
	return 0;
}
```

---

## 作者：xuyixuan (赞：3)

本篇主要讲该题递推式的（简略）证明

前置知识：Matrix-Tree定理、行列式相关知识

[更好的阅读体验(cnblogs)](https://www.cnblogs.com/xuyixuan/p/11317006.html)

---
证明：

我们令轮状病毒圆心编号为1，圆环上点编号从2~n+1

则可以得出无向图的度数矩阵D和邻接矩阵E

D=
$\begin{bmatrix}n&0&0&0&0&\cdots&0&0&0&0\\0&3&0&0&0&\cdots&0&0&0&0\\0&0&3&0&0&\cdots&0&0&0&0\\0&0&0&3&0&\cdots&0&0&0&0\\0&0&0&0&3&\cdots&0&0&0&0\\\vdots&\vdots&\vdots&\vdots&\vdots&\ddots&\vdots&\vdots&\vdots&\vdots\\0&0&0&0&0&\cdots&3&0&0&0\\0&0&0&0&0&\cdots&0&3&0&0\\0&0&0&0&0&\cdots&0&0&3&0\\0&0&0&0&0&\cdots&0&0&0&3\\\end{bmatrix}$
E=
$\begin{bmatrix}0&1&1&1&1&\cdots&1&1&1&1\\1&0&1&0&0&\cdots&0&0&0&1\\1&1&0&1&0&\cdots&0&0&0&0\\1&0&1&0&1&\cdots&0&0&0&0\\1&0&0&1&0&\cdots&0&0&0&0\\\vdots&\vdots&\vdots&\vdots&\vdots&\ddots&\vdots&\vdots&\vdots&\vdots\\1&0&0&0&0&\cdots&0&1&0&0\\1&0&0&0&0&\cdots&1&0&1&0\\1&0&0&0&0&\cdots&0&1&0&1\\1&1&0&0&0&\cdots&0&0&1&0\\\end{bmatrix}$

再得到

基尔霍夫Kirchhoff矩阵 K=
$\begin{bmatrix}n&-1&-1&-1&-1&\cdots&-1&-1&-1&-1\\-1&3&-1&0&0&\cdots&0&0&0&-1\\-1&-1&3&-1&0&\cdots&0&0&0&0\\-1&0&-1&3&-1&\cdots&0&0&0&0\\-1&0&0&-1&3&\cdots&0&0&0&0\\\vdots&\vdots&\vdots&\vdots&\vdots&\ddots&\vdots&\vdots&\vdots&\vdots\\-1&0&0&0&0&\cdots&3&-1&0&0\\-1&0&0&0&0&\cdots&-1&3&-1&0\\-1&0&0&0&0&\cdots&0&-1&3&-1\\-1&-1&0&0&0&\cdots&0&0&-1&3\\\end{bmatrix}$

然后我们要求K的代数余子式的值，显然是将带有n的那一行，那一列（即第一行，第一列）去掉

接下来就是求n阶行列式A=
$\begin{vmatrix}3&-1&0&0&\cdots&0&0&0&-1\\-1&3&-1&0&\cdots&0&0&0&0\\0&-1&3&-1&\cdots&0&0&0&0\\0&0&-1&3&\cdots&0&0&0&0\\\vdots&\vdots&\vdots&\vdots&\ddots&\vdots&\vdots&\vdots&\vdots\\0&0&0&0&\cdots&3&-1&0&0\\0&0&0&0&\cdots&-1&3&-1&0\\0&0&0&0&\cdots&0&-1&3&-1\\-1&0&0&0&\cdots&0&0&-1&3\\\end{vmatrix}$
的值了

对于A，显然不能用$n^3$的高斯消元，所以我们要探究A的性质。

将A的第一行变换到最后一行，得到B=
$\begin{vmatrix}-1&3&-1&0&\cdots&0&0&0&0\\0&-1&3&-1&\cdots&0&0&0&0\\0&0&-1&3&\cdots&0&0&0&0\\0&0&0&-1&\cdots&0&0&0&0\\\vdots&\vdots&\vdots&\vdots&\ddots&\vdots&\vdots&\vdots&\vdots\\0&0&0&0&\cdots&-1&3&-1&0\\0&0&0&0&\cdots&0&-1&3&-1\\-1&0&0&0&\cdots&0&0&-1&3\\3&-1&0&0&\cdots&0&0&0&-1\\\end{vmatrix}$

先根据行列式的性质得到$A=(-1)^{n-1}\times B$

我们发现除了左下角有三个数字外，B已经是一个上三角行列式，接下来是要消去左下角的三个数字

先消第n-1行（倒数第二行）

假设现在在消第i位，设$F_i$表示这一行的第i个数，$G_i$表示这一行第i+1个数

那么我们可以将B的第i行$\times F_i$加到这一来，就可消去第i位。因为第i行-1后面一定是3，所以第i+1位$+3\times F_i$同理，第i+2位$+(-F_i)$。

即
$\begin{cases}F_{i+1}=G_i+3\times F_i\\G_{i+1}=-F_i\\\end{cases}$

由第二个式子推出$G_i=-F_{i-1}$带人第一个式子中，得到$F_{i+1}=3\times F_i-F_{i-1}$，同时也可得到$G_{i+1}=3\times G_i-G_{i-1}$

然后可以快速地将第n-1行消成$\begin{bmatrix}0&0&0&0&\cdots&0&0&F_{n-1}-1&G_{n-1}+3\end{bmatrix}$ 了

同样的方法，我们可以来消第n行
设第i位为$H_i$,第i+1位为$L_i$
可得方程
$\begin{cases}H_{i+1}=L_i+3\times H_i\\L_{i+1}=-H_i\\\end{cases}$

解得$H_{i+1}=3\times H_i-H_{i-1}$;$L_{i+1}=3\times L_i-L_{i-1}$

将第n行消成$\begin{bmatrix}0&0&0&0&\cdots&0&0&H_{n-1}&L_{n-1}-1\end{bmatrix}$

设$F_{n-1}-1=f;G_{n-1}+3=g;H_{n-1}=h;L_{n-1}-1=l;$

则B=
$\begin{vmatrix}-1&3&-1&0&\cdots&0&0&0&0\\0&-1&3&-1&\cdots&0&0&0&0\\0&0&-1&3&\cdots&0&0&0&0\\0&0&0&-1&\cdots&0&0&0&0\\\vdots&\vdots&\vdots&\vdots&\ddots&\vdots&\vdots&\vdots&\vdots\\0&0&0&0&\cdots&-1&3&-1&0\\0&0&0&0&\cdots&0&-1&3&-1\\0&0&0&0&\cdots&0&0&f&g\\0&0&0&0&\cdots&0&0&h&l\\\end{vmatrix}$=$(-1)^{n-2}\times \begin{vmatrix}f&g\\h&l\\\end{vmatrix}$

所以$A=(-1)^{n-1}\times B=(-1)^{2n-3}\times \begin{vmatrix}f&g\\h&l\\\end{vmatrix}=-f\times l+g\times h$

再推一推F,G,H,L,可以看出
$H_{i-1}=L_{i}=F_{i}=G_{i+1}$

最后就可以推出$Ans(n)=3\times Ans(n-1)-Ans(n-2)+2$了

如果推不出，也可以求出$F_{i-1},F_{i},F_{i+1}$再来求答案

---
证明结束了，如果有错误，欢迎指正

最后放一下代码

```
#include <cstdio>
#include <cstring>
#include <algorithm>
int n;
struct Number {
	int len;
	int num[1000];
	Number() {
		len=0;
		memset(num,0,sizeof(num));
	}
	void operator =(const Number x) {
		len=x.len;
		for (register int i=1;i<=len;++i) num[i]=x.num[i];
	}
	void operator +=(const Number x) {
		len=std::max(len,x.len);
		for (register int i=1;i<=len;++i) {
			num[i]=num[i]+x.num[i];
			if (num[i]>=10) num[i]-=10,++num[i+1];
		}
		if (num[len+1]) ++len;
	}
	void operator -=(const Number x) {
		int xx=std::min(len,x.len);
		for (register int i=1;i<=xx;++i) {
			num[i]=num[i]-x.num[i];
			if (num[i]<0) num[i]+=10,--num[i+1];
		}
		while (!num[len]) --len;
	}
	Number operator *(const int& x) {
		Number res;
		for (register int i=1;i<=len;++i) {
			res.num[i]+=num[i]*3;
			res.num[i+1]+=res.num[i]/10;
			res.num[i]=res.num[i]%10;
		}
		res.len=len;
		if (res.num[len+1]) ++res.len;
		return res;
	}
	void print() {
		for (register int i=len;i;--i) printf("%d",num[i]);
		puts("");
	}
} x,y,z,_2;
int main() {
	scanf("%d",&n);
	if (n==1) puts("1");
	else if (n==2) puts("5");
	else {
		_2.len=1; _2.num[1]=2;
		x.len=x.num[1]=1;
		y.len=1; y.num[1]=5;
		for (register int i=3;i<=n;++i) {
			z=y*3; z-=x; z+=_2;
			x=y; y=z;
		}
		z.print();
	}
} 
```

---

## 作者：PRXOR (赞：3)

这道题需要用高精~~（废话，谁都知道）~~

于是我用Python写了一个打表程序：
```
f=[0,1,3]
ddd=3
while ddd<=100 :
    f.append(f[ddd-1]+f[ddd-2])
    ddd=ddd+1
ddd=1
while ddd<=100 :
    print(f[ddd]**2-4*((ddd+1)%2))
    print("\n")
    ddd=ddd+1
```
又写了一个打表用机器：
```
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int n=100;
	freopen("cout.txt","w",stdout);
	freopen("cin.txt","r",stdin);
	cout<<"int a["<<n<<"]={";
	n--;
	while(n--)
	{
		string a;
		cin>>a;
		cout<<(char)34;
		cout<<a<<(char)34<<',';
	}
	string a;
	cin>>a;
	cout<<(char)34;
	cout<<a<<(char)34;
	cout<<"};";
	fclose(stdin);
	fclose(stdout);
	return 0;
}
```
然后会有：
```
int a[100]={"1","5","16","45","121","320","841","2205","5776","15125","39601","103680","271441","710645","1860496","4870845","12752041","33385280","87403801","228826125","599074576","1568397605","4106118241","10749957120","28143753121","73681302245","192900153616","505019158605","1322157322201","3461452808000","9062201101801","23725150497405","62113250390416","162614600673845","425730551631121","1114577054219520","2918000611027441","7639424778862805","20000273725560976","52361396397820125","137083915467899401","358890350005878080","939587134549734841","2459871053643326445","6440026026380244496","16860207025497407045","44140595050111976641","115561578124838522880","302544139324403592001","792070839848372253125","2073668380220713167376","5428934300813767249005","14213134522220588579641","37210469265847998489920","97418273275323406890121","255044350560122222180445","667714778405043259651216","1748099984655007556773205","4576585175559979410668401","11981655542024930675232000","31368381450514812615027601","82123488809519507169850805","215002084978043708894524816","562882766124611619513723645","1473646213395791149646646121","3858055874062761829426214720","10100521408792494338631998041","26443508352314721186469779405","69230003648151669220777340176","181246502592140286475862241125","474509504128269190206809383201","1242282009792667284144565908480","3252336525249732662226888342241","8514727565956530702536099118245","22291846172619859445381409012496","58360810951903047633608127919245","152790586683089283455442974745241","400010949097364802732720796316480","1047242260609005124742719414204201","2741715832729650571495437446296125","7177905237579946589743592924684176","18791999880010189197735341327756405","49198094402450621003462431058585041","128802283327341673812651951847998720","337208755579574400434493424485411121","882823983411381527490828321608234645","2311263194654570182037991540339292816","6050965600552329018623146299409643805","15841633607002416873831447357889638601","41473935220454921602871195774259272000","108580172054362347934782139964888177401","284266580942632122201475224120405260205","744219570773534018669643532396327603216","1948392131377969933807455373068577549445","5100956823360375782752722586809405045121","13354478338703157414450712387359637585920","34962478192749096460599414575269507712641","91532956239544131967347531338448885552005","239636390525883299441443179440077148943376","627376215338105766356982006981782561278125"};
```
加工一下，成了最终代码：
```
#include<bits/stdc++.h>
using namespace std;
string a[101]={"0","1","5","16","45","121","320","841","2205","5776","15125","39601","103680","271441","710645","1860496","4870845","12752041","33385280","87403801","228826125","599074576","1568397605","4106118241","10749957120","28143753121","73681302245","192900153616","505019158605","1322157322201","3461452808000","9062201101801","23725150497405","62113250390416","162614600673845","425730551631121","1114577054219520","2918000611027441","7639424778862805","20000273725560976","52361396397820125","137083915467899401","358890350005878080","939587134549734841","2459871053643326445","6440026026380244496","16860207025497407045","44140595050111976641","115561578124838522880","302544139324403592001","792070839848372253125","2073668380220713167376","5428934300813767249005","14213134522220588579641","37210469265847998489920","97418273275323406890121","255044350560122222180445","667714778405043259651216","1748099984655007556773205","4576585175559979410668401","11981655542024930675232000","31368381450514812615027601","82123488809519507169850805","215002084978043708894524816","562882766124611619513723645","1473646213395791149646646121","3858055874062761829426214720","10100521408792494338631998041","26443508352314721186469779405","69230003648151669220777340176","181246502592140286475862241125","474509504128269190206809383201","1242282009792667284144565908480","3252336525249732662226888342241","8514727565956530702536099118245","22291846172619859445381409012496","58360810951903047633608127919245","152790586683089283455442974745241","400010949097364802732720796316480","1047242260609005124742719414204201","2741715832729650571495437446296125","7177905237579946589743592924684176","18791999880010189197735341327756405","49198094402450621003462431058585041","128802283327341673812651951847998720","337208755579574400434493424485411121","882823983411381527490828321608234645","2311263194654570182037991540339292816","6050965600552329018623146299409643805","15841633607002416873831447357889638601","41473935220454921602871195774259272000","108580172054362347934782139964888177401","284266580942632122201475224120405260205","744219570773534018669643532396327603216","1948392131377969933807455373068577549445","5100956823360375782752722586809405045121","13354478338703157414450712387359637585920","34962478192749096460599414575269507712641","91532956239544131967347531338448885552005","239636390525883299441443179440077148943376","627376215338105766356982006981782561278125"};
int main()
{
	int n;
	cin>>n;
	cout<<a[n];
	return 0;
}
```
这道题就完了，~~全程打表~~。

---

## 作者：CodyTheWolf (赞：2)

### [开头小广告：自己做的一个模板库OwO](https://www.luogu.org/blog/29354/Templet)
------------
### 思路：
首先~~看题解~~自己推出递推式（蒟蒻自己推的时候并没有注意到那个是斐波那契的小修改）

突然发现这道题好像要打高精qwq

但是又突然想到__int128是不想打高精又可以骗很多分搞不好能A的好东西！

我们用double可以用科学计数法表示，我们用它来算一下100位的斐波那契到底有多大：

$3.54224848179262*10^{20}$

如果我们要算斐波那契的平方，这个东西用__int128差一点点就能表示了qwq。

于是抱着数据水的心态交了：90WA

没办法，还是只能打高精了qwq。。。~~先骗90~~

虽然上面的话看起来很废。。但是也告诉了我们，如果数据刚刚好能卡够__int128，不妨先算一下位数，然后试一试，缺点只是要手写输出罢了。
当然，int128还可以用在一些意想不到的地方，例如龟速乘就可以用int128优化成$O(1)$了（int128可以取模不用手写），虽然也可以用拆数的办法在long long下优化到O(1)就是了（如果有兴趣了解可以私信我）

## CODE

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;

const int MAXN = 105;

__int128 f[MAXN] = {0, 1, 3};

__int128 a, b, ans;
int n;

inline void Print(__int128 x)
{
    if (x > 9)
        Print(x / 10);
    putchar(x % 10 + '0');

    return;
}

signed main(void)
{
    cin >> n;
    for (int i = 3; i <= n; i++)
        f[i] = f[i - 1] + f[i - 2];

    if (n == "naive!")
    {
        puts("不推荐打表通过此题，代码仅仅展现__int128的应用");
        return 0;
    }

    ans = f[n] * f[n] - 4 * (n % 2 == 0);

    Print(ans);

    return 0;
}
```


---

## 作者：yxchar (赞：2)

晚上散步想出来的一个思路：

这道题实际上就是要将圆圈外围的n个点划分成k个联通快（k<=n）。中心的点与每个联通块有且仅有一条连线。这样一来，对于每个划分，所能形成的状态数为每个联通块中点数的乘积。

我们首先来考虑把一条链进行这样的划分所能得到的总状态数。对于长度为n的链，设 f[n]为其划分后的总状态数，枚举其最后一条链的长度，将其长度乘上之前的点划分后的总状态数即可求解。即f[n]=∑i*f[n-i]。

由于本题是在环中进行划分，故可枚举环中编号为1的点所在联通块的点数，在答案中加上i^2f[n-i]即可。

Python 代码如下：
```python
x=[1]
def apd(nu):
	a=nu;
	for i in range(len(x)):
		a+=(i+1)*x[len(x)-i-1]
	x.append(a)

n=int(input())
for i in range(1,n):
	apd(i+1)
ans=0
for i in range(n):
	ans+=i*i*x[n-i-1]
ans+=n*n
print(ans)

```

---

## 作者：沧澜 (赞：2)

## 首先打标找规律：

```cpp
1:1-------------->1^2;
2:5-------------->3^2-4;
3:16------------>4^2;
4:45------------>7^2-4;
5:121---------->11^2;
6:320---------->18^2-4;
```
Then,可以发现一个规律：

- **该序列各项底数的性质与斐波那契数列相似，均满足f[i]=f[i-1]+f[i-2] (i>=3)**(度娘说：该序列叫[卢卡斯数列](http://baike.baidu.com/item/%E5%8D%A2%E5%8D%A1%E6%96%AF%E6%95%B0%E5%88%97#5))

- **在该序列内对于第i数来说：若i奇数，则数字为为f[i]^2，反之为f[i]^2-4**

- 再观察数据范围n<=100，所以要高精搞一下；

然后，就AC了。

代码：

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
struct nond{
    int a[50000];
}f[110];
long long n;
nond add(nond A,nond B){//高精加法 
    for(int i=1;i<=A.a[0];i++)
        A.a[i]+=B.a[i];
    for(int i=1;i<=A.a[0];i++){
        A.a[i+1]+=A.a[i]/10;
        A.a[i]=A.a[i]%10;
    }
    if(A.a[A.a[0]+1]!=0)    A.a[0]+=1;
    return A;
}
nond axa(nond A){//高精平方 
    nond C;
    for(int i=0;i<=A.a[0]*2;i++)
        C.a[i]=0;
    for(int i=1;i<=A.a[0];i++){
        int k=0;
        for(int j=1;j<=A.a[0];j++){
            C.a[i+j-1]+=A.a[i]*A.a[j]+k;
            k=C.a[i+j-1]/10;
            C.a[i+j-1]%=10;
        }
        C.a[i+A.a[0]]=k;
    }
    C.a[0]=A.a[0]+A.a[0];
    while(C.a[C.a[0]]==0&&C.a[0]>0)
        C.a[0]--;
    return C;
}
nond mins(nond A){//高精减4 
    if(A.a[1]>=4)    A.a[1]-=4;
    else{
        A.a[1]=10+A.a[1]-4;
        A.a[2]-=1;
    }
    return A;
}
int main(){
    cin>>n;
    f[1].a[0]=1;f[2].a[0]=1;//f[i].a[0]存储第i个数的位数。 
    f[1].a[1]=1;f[2].a[1]=3;//f[i].a[1]~f[i].a[f[i].a[0]]倒序存储数字； 
    for(int i=3;i<=n;i++)
        f[i]=add(f[i-1],f[i-2]);
    f[n]=axa(f[n]);
    if(n%2==0)    f[n]=mins(f[n]);
    for(int i=f[n].a[0];i>=1;i--)
        cout<<f[n].a[i];    
}
```


---

## 作者：Arcturus1350 (赞：2)

emm……

正解：矩阵树定理，但是本宝宝不会求基尔霍夫矩阵。

开始考场方法：

手动模拟$n=1--5$时的答案（数不大，~~画画就出来了~~要画上半个小时）。

画出来，答案是这样的：$1$ $5$ $16$ $45$ $121$

然后简单根据题目出处和难度蒙了一下感觉第$n$项的答案和$n-1$,$n-2$的答案有关。

再看看增长率$(\frac{ans[n-1]}{ans[n-2]})$大概是$2--3$之间，并且比较靠近三。

于是，就想 $ans[n]$ $=$ $ans[n-1]*3$ $±$ $……$ 

又因为差的不是一个常数，所以
$ans[n]$ $=$ $3*ans[n-1]-ans[n-2]$ $±$ $……$

之后，惊喜的发现每个$ans[n]$ 与 $3*ans[n-1]-ans[n-2]$ 都差$2$。

最终，蒙了一个表达式：$ans[n]=$ $3*ans[n-1]-ans[n-2]+2$

看数据范围，需要高精。

之后一脸懵逼的$AC$了。

代码附上：

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
//F(n)=3*F(n-1)-F(n-2)+2,F(1)=1,F(2)=5.;
int ans[103][10010];
int len[103];
int mul[10010];
void pluse(int x)
{
	int m=x-2;
	int n=x-1;
	int cnt=0;int l=len[n];
	for(int i=1;i<=l;i++)
	{
		mul[i]=(ans[n][i]*3+cnt)%10;
		cnt=(ans[n][i]*3+cnt)/10;
	}
	if(cnt!=0) mul[++l]=cnt;
	
	cnt=2;
	for(int i=1;i<=l;i++)
	{
		ans[x][i]=(mul[i]-ans[m][i]+cnt+100)%10;
		if(mul[i]-ans[m][i]+cnt<0) cnt=-1;
		else cnt=(mul[i]-ans[m][i]+cnt)/10;
	}
	if(cnt!=0) ans[x][l+1]=cnt,len[x]=l+1;
	else len[x]=l;
	return ;
}
int n;
int main()
{
	scanf("%d",&n);
	ans[1][1]=1;len[1]=1;
	ans[2][1]=5;len[2]=1;
	for(int i=3;i<=n;i++) pluse(i);
	for(int i=len[n];i>=1;i--) printf("%d",ans[n][i]);
	return 0;
}
```

---

## 作者：kyel (赞：1)

# **无脑三维DP**

首先可以想到，**仅外环上每一个点各引出一条边**且边互不重复，这样子是可以构成一个“轮状病毒”的（n+1个点n条边，而且每边必定连通互不连通的两块）

对于外环上一点，在不考虑重复时，其引出边有三种方式：顺时针向后，逆时针向前，指向中心。

可以证明：对于每一点，其不同两种出边方式一定对应着两个互不重复的解集。

向前、后出边与向中心出边显然不同，唯一让我们有所顾虑的是向前与向后引边是否可能是重复可行解。

证明如下：



.................................................

假定原有一合法方案，且该方案中有一点**点n出边不指向点n-1**。

证明：“将第n号点的边改为指向n-1号点，则得到的方案与原方案必然不同。”

基本情况：若第n-1点引出的边不指向当前点，那么显然是两种不同的解。（原先两点间无边，现在有边）

若第n-1号点引出的边指向第n号点，那么我们需要把这条边改向以使得方案合法。**若指向中心点**，显然也是不同的方案（原方案中中心点与n-1点无连边，而新方案中有连边）；**若指向n-2号点**，则要求证明：“将第n-1号点的出边指向第n-2号点，则得到的方案与原方案必然不同。”显然**命题的模缩减了1**。

由于“轮状病毒”外环的边不能成环，故**一定存在一点其边不指向其前驱**。故该命题最终一定归纳为基本情况。

归纳得证。

.................................................


有了这个证明，我们就可以说明如下dp所得到的解是不重叠的了。

令dp[n][s1][s2]表示：只考虑在前n个点中，点n的出边情况为s1，点1的出边情况为s2，所可行的方案数。其中s1,s2∈[0,2]，对应着三种出边情况。

由于“一个点不同的出边方式必然对应着不同的解”，所以对于不同的s2,s2，其dp所计入的解一定不重叠。

显然dp[n][][]需要特殊处理（这里的n指题意中的n），因为我们在为它引出边时需要考虑到第1个点的出边情况。

注意这样会算出来两种不和中心相连的无效情况（两个相同的环）。

具体dp方程应该不难想到，可以参照代码。

```cpp
#include <cstdio>
#include <cstdlib>
#include <cstring>

#include <algorithm>

#define TOT(x, s) (dp[x][0][s] + dp[x][1][s] + dp[x][2][s])
#define HEADTOT(x, s) (dp[x][s][0] + dp[x][s][1] + dp[x][s][2])

const int maxn(112);
class bigint {//高精
	public:
		bigint() : end(1) { memset(val, 0, sizeof(val)); }
		bigint operator+(const bigint& v) const {
			bigint ret;
			ret.end = std::max(end, v.end);
			for (int i(0); i != ret.end; ++i) {
				ret.val[i] += val[i] + v.val[i];
				if (ret.val[i] >= 10) ret.val[i] -= 10, ++ret.val[i + 1];
			}
			if (ret.val[ret.end]) ++ret.end;
			return ret;
		}
		bigint& operator-=(int v) {
			int pos(0);
			val[pos] -= v;
			while (val[pos] < 0) {
				val[pos] += 10, --val[++pos];
			}
			if (!val[end - 1]) --end;
			return *this;
		}
		bigint& operator=(const bigint& v) {
			for (int i(v.end); i < end; ++i) val[i] = 0;
			for (int i(0); i != v.end; ++i) val[i] = v.val[i];
			end = v.end;
			return *this;
		}
		bigint& operator=(int v) {
			for (int i(0); i != end; ++i) val[i] = 0;
			if (v == 0) {
				end = 1;
				return *this;
			} end = 0;
			while (v) {
				val[end++] = v % 10;
				v /= 10;
			}
			return *this;
		}
		void print() const {
			for (int i(end - 1); ~i; --i) printf("%d", val[i]);
		}
		int val[112], end;
};

int n;
bigint dp[maxn][3][3], ans;//0 -> back, 1 -> front, 2 -> center
int main() {
	scanf("%d", &n);
	if (n == 1) {
		printf("1\n"); return 0;
	} else if (n == 2) {
		printf("5\n"); return 0;
	}
	dp[0][0][0] = 1, dp[0][1][1] = 1, dp[0][2][2] = 1;
	for (int i(1); i != n - 1; ++i) {
		dp[i][0][0] = dp[i - 1][0][0] + dp[i - 1][2][0];
		dp[i][0][1] = dp[i - 1][0][1] + dp[i - 1][2][1];
		dp[i][0][2] = dp[i - 1][0][2] + dp[i - 1][2][2];
		dp[i][2][0] = dp[i][1][0] = TOT(i - 1, 0);
		dp[i][2][1] = dp[i][1][1] = TOT(i - 1, 1);
		dp[i][2][2] = dp[i][1][2] = TOT(i - 1, 2);
	}
	int p(n - 2);
	ans = ans + HEADTOT(p, 0) + HEADTOT(p, 2) + TOT(p, 1) + TOT(p, 2) + TOT(p, 0) + TOT(p, 1) + TOT(p, 2);
    //这段ans的公式可以拆成三段，对应了三种出边情况
	ans -= 2;
	ans.print(), printf("\n");
	return 0;
}

```

---

## 作者：wenjing233 (赞：1)

打表题竟然没有打表程序！  
打表思路：枚举选边，并查集维护剪枝  
复杂度O（答案）（实际上多很多）
```cpp
#pragma GCC optimize(2)
#pragma GCC optimize(3)
#pragma GCC optimize("Ofast")
#pragma GCC optimize("inline")
#pragma GCC optimize("-fgcse")
#pragma GCC optimize("-fgcse-lm")
#pragma GCC optimize("-fipa-sra")
#pragma GCC optimize("-ftree-pre")
#pragma GCC optimize("-ftree-vrp")
#pragma GCC optimize("-fpeephole2")
#pragma GCC optimize("-ffast-math")
#pragma GCC optimize("-fsched-spec")
#pragma GCC optimize("unroll-loops")
#pragma GCC optimize("-falign-jumps")
#pragma GCC optimize("-falign-loops")
#pragma GCC optimize("-falign-labels")
#pragma GCC optimize("-fdevirtualize")
#pragma GCC optimize("-fcaller-saves")
#pragma GCC optimize("-fcrossjumping")
#pragma GCC optimize("-fthread-jumps")
#pragma GCC optimize("-funroll-loops")
#pragma GCC optimize("-fwhole-program")
#pragma GCC optimize("-freorder-blocks")
#pragma GCC optimize("-fschedule-insns")
#pragma GCC optimize("inline-functions")
#pragma GCC optimize("-ftree-tail-merge")
#pragma GCC optimize("-fschedule-insns2")
#pragma GCC optimize("-fstrict-aliasing")
#pragma GCC optimize("-fstrict-overflow")
#pragma GCC optimize("-falign-functions")
#pragma GCC optimize("-fcse-skip-blocks")
#pragma GCC optimize("-fcse-follow-jumps")
#pragma GCC optimize("-fsched-interblock")
#pragma GCC optimize("-fpartial-inlining")
#pragma GCC optimize("no-stack-protector")
#pragma GCC optimize("-freorder-functions")
#pragma GCC optimize("-findirect-inlining")
#pragma GCC optimize("-fhoist-adjacent-loads")
#pragma GCC optimize("-frerun-cse-after-loop")
#pragma GCC optimize("inline-small-functions")
#pragma GCC optimize("-finline-small-functions")
#pragma GCC optimize("-ftree-switch-conversion")
#pragma GCC optimize("-foptimize-sibling-calls")
#pragma GCC optimize("-fexpensive-optimizations")
#pragma GCC optimize("-funsafe-loop-optimizations")
#pragma GCC optimize("inline-functions-called-once")
#pragma GCC optimize("-fdelete-null-pointer-checks")
#include<bits/stdc++.h>
using namespace std;	
struct gzw
{
	long long st,ed;	
}way[1000009];
long long bcj[1000009];
long long n,m;
long long ans;
long long find(long long x)
{
	return x==bcj[x]?x:find(bcj[x]);//不使用路径压缩的并查集支持删除ovo	
}
void dfs(long long now,long long cs)
{
	if(m-now+1<n-1-cs) return;//剩下的边全选也选不到n-1条
	if(cs==n-1) {++ans;return;}//选好了
	dfs(now+1,cs);
	if(find(way[now].st)!=find(way[now].ed))
	{
		register long long tmp=bcj[find(way[now].st)];
		bcj[find(way[now].st)]=find(way[now].ed);//连接
		dfs(now+1,cs+1);
		bcj[tmp]=tmp;//因为没有路径压缩，所以直接把原来的父节点的父亲改为自己就行了
	}
}
int main()
{
    for(register long long i=3;i<=20;++i)
    {
    	n=i+1,m=0,ans=0;//初始化
		for(long long j=1;j<=i+1;++j)
		{
			bcj[j]=j;//初始化
		}
		for(int j=1;j<i;++j)
		{
			++m;
			way[m].st=j;
			way[m].ed=j+1;	
		}
		++m;
		way[m].st=1;
		way[m].ed=i;
		for(int j=1;j<=i;++j)
		{
			++m;
			way[m].st=j;
			way[m].ed=n;	
		}
        //以上为连边
		dfs(1,0);
		cout<<ans<<" ";
    }
}
```
这样的代码跑到20还是在可以等待的时间内的（本机3分钟左右） 
最后跑出来的结果是：  
16 45 121 320 841 2205 5776 15125 39601 103680 271441 710645 1860496 4870845 12752041 33385280 87403801 228826125  
然后明显的是 16 121 841 5776 都是平方（其实只有 16,121 比较明显后两个是根据前两个猜的）  
分别是 4,11,29,76的平方
接下来在考虑45,320,2205,15125和平方有什么关系  
由小学奥数找规律得，他们可能是一个平方数加减一个数得到的，则去找离他们最近/远的平方数是哪些  
计算器得离他们最近的平方根分别是：7,18,47,123  
然后和在一起就是 4,7,11,18,29,47,76,123  
然后就是很明显的斐波那契数列了   
在偶数位上要减去4  
然后仔细思考发现暴int_128了  
于是就写了python ~~不太懂语法所以写的十分丑码风毒瘤~~
```python
n=input()
n=int(n)
a=1
b=3
c=3
d=666
if n==1:
    print("1");
elif n==2:
    print("5");
else:
    while c<=n:
        d=a
        a=b
        b=d+b
        c=c+1
    print(b*b-4*((n+1)%2))

```
~~这么毒瘤的码风要是被抄题解的话应该很好找吧~~  
如果你打完表不想做小学奥数题的话可以上这个网站[OIES](https://oeis.org/)






---

## 作者：Caro23333 (赞：1)

鄙人不才，解法思路比较复杂，时间复杂度也并不是最优，但的确是我解题的心路历程，希望能帮到大家

#### 首先考虑对这个问题的模型进行一些转化：

我们发现，原图的一个最小生成树，必然是在外圈的环上去掉一些边之后形成若干段相连的外圈点，每一段有且仅有一个点与中间的点相连

也就是说这题需要我们将一个环分成若干段，不太好考虑，我的思路是将环先从一端拆开变成**一条链**来处理

这样的模型在一条链上可以理解为：n个不同的物品按顺序排一列，分成若干连续的组，每种分组方案中每组物品数量之积的总和就是这样一条链的总方案数

**那么我们设f[i][j]为长度为i的链，分成j组，每种方案下每组点数之积的总和**

容易发现有

$f[i][j] = \sum_{k=j-1}^{i-1}f[k][j-1]*(i-k)$

#### OK,现在把眼光放到题面中的环上：

如果要将一个环拆成一条链，那么就需要断开其中一条边（如图中(1)），形成的链如红线标记部分

很明显，我们需要依次钦定断开每一条边，才能覆盖所有的情况......但是这样会产生重复

所以我们需要在断开下一条边并且统计答案的时候，让之前断开过的所有边都保持相连（如图中(2)用蓝色圈起来的边）

![luogu](https://cdn.luogu.com.cn/upload/pic/31958.png)

那么我们可以把固定相连的所有点都看作一个有权值的点（比如在图中，蓝色圈起的部分就看作一个权值为2的点），这样的话原来形成的8个点的链就可以看作一条7个点的链（如图中蓝线标记部分），其中有一个点的权值为2

那么这一条链对答案的贡献就是将其分组后每组权值和之积的总和

我们发现，在枚举第i条链的时候，你的链长度为n-i+1,其中如果有权值大于1的点的话，那么有且仅有一个权值为i的点 也就是说，对于相同长度链，其中点权的情况是确定的，只有最后一个是权值为i的点

**于是我们再设一个g[i][j],表示长度为i的链中，分为j组，每种方案每组权值和之积的总和**

在从f[k][j-1]转移过来的时候，注意到加入最后一组形成长度为i的链之后，所有的点权值总和为n，也就是说最后一组的权值为n-k

所以有：

$g[i][j] = \sum_{k=j-1}^{i-1}f[k][j-1]*(n-k)$



那么根据之前的枚举链的方法，最终的答案就是：


$ans = \sum_{i=1}^{n}\sum_{j=1}^{i}g[i][j]$


然后写个高精就完事儿了

#### 代码：
```cpp
#include <iostream>
#include <cstdlib>
#include <cstdio>
#include <cstring>
#define mod 10

using namespace std;
const int MAXN = 105;
int n;
struct bigint
{
    int k,a[105];
    bigint operator+(bigint t) 
    {
        bigint res;
        memset(res.a,0,sizeof(res.a));
        int tmp = max(k,t.k);
        for(int i = 1; i<=tmp; i++)
        {
            res.a[i] += a[i]+t.a[i];
            res.a[i+1] += res.a[i]/mod;
            res.a[i] %= mod;
        }
        if(res.a[tmp+1]) tmp++;
        res.k = tmp+1;
        while((!res.a[res.k])&&res.k>1) res.k--;
        return res;
    }
    bigint operator*(int t)
    {
        bigint res;
        memset(res.a,0,sizeof(res.a));
        int tmp = k;
        for(int i = 1; i<=tmp; i++)
        {
            res.a[i] += a[i]*t;
            res.a[i+1] += res.a[i]/mod;
            res.a[i] %= mod;
        }
        res.k = tmp+1;
        while((!res.a[res.k])&&res.k>1) res.k--;
        return res;
    }
};
bigint f[MAXN][MAXN],g[MAXN][MAXN];
inline bigint init(int x)
{
    bigint tmp;
    tmp.k = 0;
    memset(tmp.a,0,sizeof(tmp.a));
    while(x)
    {
        tmp.a[++tmp.k] = x%10;
        x /= 10;
    }
    return tmp;
}
inline void print(bigint x)
{
    for(int i = x.k; i>0; i--)
        printf("%d",x.a[i]);
    cout << endl;
}
int main()
{
    cin >> n;
    for(int i = 1; i<=n; i++)
        f[i][1] = init(i), f[i][i] = init(1);
    for(int i = 3; i<=n; i++)
        for(int j = 2; j<i; j++)
            for(int k = j-1; k<i; k++)
                f[i][j] = f[i][j]+f[k][j-1]*(i-k);
    for(int i = 1; i<=n; i++)
        g[i][1] = init(n), g[i][i] = init(n-i+1);
    for(int i = 3; i<=n; i++)
        for(int j = 2; j<i; j++)
            for(int k = j-1; k<i; k++)
                g[i][j] = g[i][j]+f[k][j-1]*(n-k);
    bigint ans = init(0);
    for(int i = n; i>=1; i--)
        for(int j = 1; j<=i; j++)
            ans = ans+g[i][j];
    print(ans); 
    return 0;
} 
```

---

## 作者：wzj423 (赞：1)

考虑删去所有和中心点相连的边，那么剩下的边一定构成若干个联通块
    
这就很像一个序列了
   
我们先不考虑从哪里开始的问题，从无环序列问题状态着手
    
   令$f[i]$表示从1到i产生的连接方案数，那么我们考虑最后一段联通块
   
那么有 $f[i]=\sum_{j=0}^{j<i}f[j]*(i-j)$
    
   当j=0的时候，相当于把所有的合并成一个联通块，因而f[0]=1
   
   现在问题来了，我们要考虑环的影响
   
   我们指定一个起始点，这个起始点一定会落在一个联通块里面
   
   我们发现，如果这个联通块的大小是确定的，那么后面形成的
   序列的分割方案数都是一样的
   
   所以，我们只需要枚举起始联通块的大小，
   
   然后这个联通块的任意一点都可以向中心点连边，这样就考虑了这个影响
   
   但是这样我们只考虑了大于等于两个联通块的情况，还有只有一个联通块的情况！
    
   这一部分为：枚举连接到中心的点*枚举环上断开的边（画图自己考虑）$=i*i$
    
   因而$f[i]=f[0]*i*i+\sum_{j=1}^{j<i}j*f[i-j]$
   
   开始状态$f[0]=1$
```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
///defs&tools================
/**
    1->1
    2->5
    3->16
    考虑删去所有和中心点相连的边，那么剩下的边一定构成若干个联通快
    这就很像一个序列了
    我们先不考虑从哪里开始的问题，从无环序列问题状态着手
    令f[i]表示从1到i产生的连接方案数，那么我们考虑最后一段联通块
    那么有 f[i]=\sum_{j=0}^{j<i}f[j]*(i-j)
    当j=0的时候，相当于把所有的合并成一个联通块，因而f[0]=0
    现在问题来了，我们要考虑环的影响
    我们指定一个起始点，这个起始点一定会落在一个联通块里面
    我们发现，如果这个联通块的大小是确定的，那么后面形成的序列的分割方案数都是一样的
    所以，我们只需要枚举起始联通块的大小，
        然后这个联通块的任意一点都可以向中心点连边，这样就考虑了这个影响
        但是这样我们只考虑了大于等于两个联通块的情况，还有只有一个联通块的情况！
        这一部分为：枚举连接到中心的点*枚举环上断开的边（画图自己考虑）=i*i
    因而f[i]=\sum_{j=1}^{j<i}j*f[i-j]   +f[0]*i*i
    开始状态f[0]=0

*/
const ll mo=1e9;
struct bignum{
    ll a[50];
    bignum(int x=0){
        memset(a,0,sizeof(a));
        if (!x) return;
        a[1]=x; a[0]=1;
    }
    friend bignum operator +(bignum a,bignum b){
        bignum c;
        c.a[0]=max(a.a[0],b.a[0]);
        for (int i=1;i<=c.a[0];i++) c.a[i]=a.a[i]+b.a[i];
        for (int i=1;i<=c.a[0];i++){
            c.a[i+1]+=c.a[i]/mo;
            c.a[i]%=mo;
        }
        if (c.a[c.a[0]+1]) c.a[0]++;
        return c;
    }
    friend bignum operator *(bignum a,bignum b){
        bignum c;
        for (int i=1;i<=a.a[0];i++){
            ll x=0;
            for (int j=1;j<=b.a[0];j++){
                x+=c.a[i+j-1]+a.a[i]*b.a[j];
                c.a[i+j-1]=x%mo;
                x/=mo;
            }
            c.a[i+b.a[0]]=x;
        }
        c.a[0]=a.a[0]+b.a[0];
        while (c.a[0]&&!c.a[c.a[0]]) c.a[0]--;
        return c;
    }
    void print(){
        printf("%lld",a[a[0]]);
        for (int i=a[0]-1;i>0;i--)
            printf("%09lld",a[i]);
        puts("");
    }
}f[110],ans;
int N;
///main======================
int main() {
    scanf("%d",&N);
    f[0]=1;
    for(int i=1;i<=N;++i) {
        f[i]=i*i;
        for(int j=1;j<i;++j) {
            f[i]=f[i]+f[j]*(i-j);
        }
        //f[i].print();
    }
    f[N].print();
    return 0;
}

```

---

## 作者：zhylj (赞：1)

递推式楼下已经讲得很清楚了

一个变形的斐波那契数列

f[0]=1,f[1]=3,f[n]=f[n-1]+f[n-2]

然后F[n]=f[n]^2-4\*((n+1)%2)

至于高精就用py水过了

# 读入n

    n=input()

# 初始化

    f=[1,3]

# i循环到n，计算f[i]

    for i in range(2,n):

        f.append(f[i-1]+f[i-2])

# 输出F[n]

print(f[n-1]\*f[n-1]-4\*((n+1)%2))


---

## 作者：Seauy (赞：0)

# 貌似题解里很少有写递推式思路的？

由于发现我的递推式跟大家的都不一样 ~~（我是二维的，估计是我太菜了吧）~~ 

并且感觉自己的思路比较好理解，决定跟大家分享一下

------------

其实题目要求的东西就是在 $ N $ 轮状基中的生成树个数（每两个结点只有一条简单路径）

这会让人一下子想到 $ Matrix-Tree $ 定理，但是由于轮状基是个特殊的图，所以用不到

轮状基可以看成是一个有 $ N $ 个结点的环，每个点又向轮状基中心的核原子连线

先将外面的环分成若干连续的段（注意不能不分，不然就不是树了），每段至少有一个结点，然后考虑这些段如何向核原子连接

由于每段之间互相不联通，所以只能通过核原子联通，所以每段上至少有一个结点与核原子相连。那能不能每段有多于一个结点与核原子相连呢？显然不行，不然就出现环了

所以每一段上的每一个结点都有可能与核原子相连，每一种分段法所对应的生成树个数就是所有段上结点数之积

（这个很多题解都想到了）

------------

将所有基原子 $1 - N$ 编号，考虑枚举左端点为 $ now $ 的段的右端点 $ i $

由于是在环上分段，于是先事先枚举所有经过结点 $ 1 $ 的段，将环破成链方便枚举

设经过结点 $ 1 $ 的段的左端点编号为 $ Limit $（结点 $ 1 $ 记为 $ N+1 $），$ dp_{now,Limit} $ 为从 $ now $ 开始分段分到 $ Limit $ 之前的与核原子的连接方案数，则有递推式

$ dp_{now,Limit}=\sum\limits_{i=now}^{Limit-1}(i-now+1) \times dp_{i+1,Limit} $

其实就是这段的方案数（段的长度）乘以后面的段的方案数，由于这段的长度不确定，因此总方案数就是所有右端点产生的方案数之和

特别地，认为当 $ now=Limit $ 时 $ dp_{now,Limit}=1 $（可以理解为所有段都分完了，没法与核原子连接也是一种方案）

最后统计答案，枚举所有经过第一结点的段

$ ans=\sum\limits_{Limit=2}^{N+1}\sum\limits_{now=1}^{Limit-1}(n+1-Limit+now)\times dp_{now,Limit} $

嗯对，记得把第一段的长度也乘上去

然后……还是上代码吧

```cpp
#include<bits/stdc++.h>
using namespace std;

const int MAXN=100;
typedef unsigned long long ull;

const int SIZE=40;
const int k=8;//压 k 位 
const int CNOD=pow(10,k);

struct HPA
{
    unsigned long long dig[SIZE];
    int len;
    void Scan()
    {
        string temp;
        cin>>temp;
        int tlen=temp.length();
        len=ceil(double(tlen)/double(k));
        for(int i=1;i<=len;i++)
            for(int j=max(tlen-i*k,0);j<=tlen-i*k+k-1;j++)
                dig[i]=dig[i]*10+temp[j]-48;
    }
    void Print()
    {
        cout<<dig[len];
        for(int i=len-1;i;i--)
        {
            for(int j=CNOD/10;dig[i]<j;j/=10) cout<<0;
            if(dig[i]) cout<<dig[i];
        }
        cout<<endl;
    }
    void One() {len=1,dig[1]=1;}
    void Two() {len=1,dig[1]=2;}
    void Ten() {len=1,dig[1]=10;}
    void Clean()
	{
		for(int i=1;i<=len;i++) dig[i]=0;
		len=0;
	}
}zero,one,ten,ans;

short m;

HPA Translate(int ob)
{
	HPA cnt;cnt.Clean();
	while(ob)
	{
		cnt.dig[++cnt.len]=(ob%CNOD);
		ob/=CNOD;
	}
	return cnt;
}

HPA Multi(HPA a,HPA b)
{
    HPA cnt=zero;
    cnt.len=a.len+b.len+2;
    for(int i=1;i<=a.len;i++)
    	for(int j=1;j<=b.len;j++)
    		cnt.dig[i+j-1]+=a.dig[i]*b.dig[j];
    for(int i=1;i<=cnt.len;i++)
    {
        cnt.dig[i+1]+=cnt.dig[i]/CNOD;
        cnt.dig[i]%=CNOD;
    }
    while(!cnt.dig[cnt.len] && cnt.len>1) cnt.len--;
    return cnt;
}

HPA Plus(HPA a,HPA b)
{
    HPA cnt=zero;
    cnt.len=max(a.len,b.len);
    for(int i=1;i<=cnt.len;i++)
    {
        cnt.dig[i]+=a.dig[i]+b.dig[i];
        cnt.dig[i+1]+=cnt.dig[i]/CNOD;
        cnt.dig[i]%=CNOD;
    }
    cnt.len+=(cnt.dig[cnt.len+1]);
    return cnt;
}

HPA Diff1(HPA ob)
{
    for(int i=0;i<ob.len;i++)
        if(ob.dig[i+1]) {ob.dig[i+1]--,ob.dig[i]=CNOD-1;break;}
        else ob.dig[i]=CNOD-1;
    ob.dig[0]=0;
    ob.len-=(!ob.dig[ob.len]);
    return ob;
}

HPA Pow(HPA base,short idex)
{
    HPA cnt=zero;
    cnt.dig[1]=1;
    for(;idex;idex>>=1)
    {
        if(idex&1) cnt=Multi(base,cnt);
        base=Multi(base,base);
    }
    return cnt;
}

HPA Divide2(HPA ob)
{
    HPA cnt=zero;
    cnt.len=ob.len;
    unsigned long long temp=0;
    for(int i=ob.len;i>=1;i--)
    {
    	temp=temp*CNOD+ob.dig[i];
    	cnt.dig[i]=temp>>1;
    	temp%=2;
    }
    while(!cnt.dig[cnt.len] && cnt.len>1) cnt.len--;
    return cnt;
}

bool LessEqu(HPA a,HPA b)
{
    if(a.len<b.len) return 1;
    if(a.len>b.len) return 0;
    for(int i=a.len;i>=1;i--)
    {
        if(a.dig[i]<b.dig[i]) return 1;
        if(a.dig[i]>b.dig[i]) return 0;
    }
    return 1;
}

bool Greater(HPA a,HPA b)
{return !LessEqu(a,b);}

bool Equal(HPA a,HPA b)
{
	if(a.len!=b.len) return 0;
	for(int i=a.len;i>=1;i--)
		if(a.dig[i]!=b.dig[i]) return 0;
	return 1;
}

int n;

HPA dp[MAXN+5][MAXN+5];
HPA DFS(int now,int Limit)
{
	if(!Equal(dp[now][Limit],zero)) return dp[now][Limit];
	if(now==Limit) return one;
	for(int i=now;i<Limit;i++)
		dp[now][Limit]=Plus(dp[now][Limit],Multi(Translate(i-now+1),DFS(i+1,Limit)));
	return dp[now][Limit];
}

int main()
{
	zero.len=1;
	one.One();
	ten.Ten();
	ans=zero;
	scanf("%d",&n);
	for(int i=1;i<=n+1;i++)
		for(int j=1;j<=n+1;j++)
			dp[i][j]=zero;
	for(int i=n+1;i>=2;i--)//向左延伸 n+2-i 个 
		for(int j=1;j<i;j++)//向右延伸 j 个 
			ans=Plus(ans,Multi(Translate(n+1-i+j),DFS(j+1,i)));
	ans.Print();
	return 0;
}
```
用了记忆化，其中大部分的码量还是关于高精度

然后就能完美地过这道题了，复杂度 $ O(n^3) $，由于有高精，常数较大但是我加了压位，远远小于 $ N $

---

## 作者：KesdiaelKen (赞：0)

这题我觉得吧……评分虚高，难度真的不大啊，根本不需要找规律，我非高精的代码花了$5$分钟就打完了（难度完全在于高精度qaq）。数据范围这么小，完全可以做到$O(\log n)$的好吧。

说一下我看到这题的思路吧。看到这题，首先想到可不可以用$dp$解决。然后发现一个病毒中会存在一种特殊的边，及从圆心连到圆环上的点的边。我们观察一个轮状病毒：![](https://cdn.luogu.com.cn/upload/pic/53859.png)（特殊边及其中的$a,b,c,d$）

然后研究相邻的两个特殊边（即两个特殊边之间无其他特殊边，例如$a,d$为相邻特殊边，而$a,c$不为特殊边（之间有$d$））。观察$b,c$，它们相邻的区间内有点$A,B,C$。由圆心不能继续向它们连边。因此在它们之间只可能如下连边（忽略其他点）：![](https://cdn.luogu.com.cn/upload/pic/53862.png)![](https://cdn.luogu.com.cn/upload/pic/53861.png)![](https://cdn.luogu.com.cn/upload/pic/53859.png)![](https://cdn.luogu.com.cn/upload/pic/53865.png)，共四种。

于是归纳总结得结论：对于两个**位置确定**的相邻特殊边，它们间区间的点的连边方式为点数$+1$。

我们开始进行$dp$。注意上面的限制条件：位置确定。所以我们的状态转移方程的状态必须含有位置。我们考虑按逆时针顺序$dp$，$dp$中需要包含第一个特殊边的位置和最后一个特殊边的位置。我们可以发现，对于一个从$12$点方向逆时针方向数第一个特殊边不在正$12$点位置的轮状病毒，都可以通过顺时针旋转得到第一个特殊边在正$12$点位置的病毒，如图：![](https://cdn.luogu.com.cn/upload/pic/53871.png)

所以我们可以不用考虑第一个特殊边的位置，直接默认设为$1$。于是，就可以令$f[i]$表示最后一个特殊边位置为$i$时的方案数。$f[i]$可由$f[j],1\le j <i$得到。又根据上面归纳的两个相邻特殊边间连边的方案数结论，可知$f[i]=\sum f[j]\times (i-j)$。

但是$f[i]$并不是最后一个特殊边位置为$i$时方案数的答案，因为我们还没有考虑特殊边$i$与第一个特殊边$1$之间的连边方案数。所以每个$f[i]$还需要乘上$n-i+1$（根据结论简单计算可得）。

然后还要记得我们忽略了第一个特殊边不在$1$的情况，因此现在应该将它们算回去。我们将一个第一边为$1$、最后边为$i$的病毒不断旋转，得到一边$2$、终边$i+1$，一边$3$、终边$i+2$……一边$n-i+1$、终边$n$共$n-i+1$种情况。

所以最终答案$ans=\sum (n-i+1)^2 f[i]$（注意这里的$f[i]$是刚$dp$出来的没有做任何其他处理的$f[i]$）。

注意此题难点：高精度……

复杂度$O(n^2)$，代码如下：

```cpp
#include<cstdio>
#include<cstring>
#include<cmath>
#include<string>
#include<algorithm>
#include<iostream>
using namespace std;
int n; 
struct SHU
{
    int shu[1000],len;
    SHU(){memset(shu,0,sizeof(shu));len=0;}
    SHU operator +(const SHU&a)
    {
        SHU lc;int sy=0;
        for(lc.len=0;lc.len<=a.len||lc.len<=len||sy;lc.len++)
        {
            lc.shu[lc.len]=a.shu[lc.len]+shu[lc.len]+sy;
            sy=lc.shu[lc.len]/10;lc.shu[lc.len]%=10;
        }
        while(lc.len>=1&&lc.shu[lc.len-1]==0)lc.len--;
        return lc;
    }
    SHU operator *(int&b)
    {
        SHU lc;int sy=0;
        for(lc.len=0;lc.len<=len||sy;lc.len++)
        {
            lc.shu[lc.len]=shu[lc.len]*b+sy;
            sy=lc.shu[lc.len]/10;lc.shu[lc.len]%=10;
        }
        while(lc.len>=1&&lc.shu[lc.len-1]==0)lc.len--;
        return lc;
    }
}f[200],dp[200],ans;
int main()
{
    scanf("%d",&n);
    f[1].shu[0]=1;f[1].len=1;
    int a;
    for(int i=2;i<=n;i++)
    {
        for(int j=1;j<i;j++)
        {
        	a=i-j;
            f[i]=f[i]+(f[j]*a);
        }
    }
    for(int i=1;i<=n;i++)
    {
    	a=(n-i+1)*(n-i+1);
        dp[i]=f[i]*a;
    }
    ans.shu[0]=0;ans.len=1;
    for(int i=1;i<=n;i++)ans=ans+dp[i];
    for(int i=ans.len-1;i>=0;i--)printf("%d",ans.shu[i]);
    printf("\n");
    return 0;
}
```

是不是太慢了？

我们观察初始$f$序列：

$1,1,3,8,21,55,144,377...$

可以发现从第四项开始，$f[i]=f[i-1]*3-f[i-2]$。这个可以用数学归纳法证明，这里就不展开了。

得到了一维递推式，我们知道此题可以用矩阵快速幂解决了……

具体代码不打了，大家请自行yy。

总结一下，此题难度真的不高，需要有一定的排列组合基础，是一道比较有意思的数学题。

---

## 作者：HCY55 (赞：0)

我对这题非常有感触，一看到这道题就知道肯定是排列组合，但仔细一看，却不是那么的简单，它虽然数据给定的是n<=100，但实际上它一个个加起来，数据是非常的大！
    
所以说，这道题是非常的毒瘤！当你将这道题的数据1~5一一列出时，你会发现：这组数据非常眼熟！没错它就是变形的斐波那契数列！除了第一个1以外，其他项都是（n*2-1）的斐波那契数列，只不过这个数列有些特殊，就是以“1,3”为开端的数列！

好了，话不多说，请各位大侠欣赏代码！
```cpp
#include<iostream>  
using namespace std;  
long long n,i;  
string s1="4",s[3]= {"0","1","3"};  
using namespace std;  
int compare(string s1,string s2) {
 
  	if(s1.length()>s2.length()) {  
		return 1;  
	} else if(s1.length()<s2.length()) {  
		return -1;  
	} else return s1.compare(s2);  
}
string add(string s1,string s2) {  
                                       
	string s;
	int sz1=s1.length();
	int sz2=s2.length();
	if(sz1<sz2) {
		for(int i=1; i<=sz2-sz1; i++)
			s1="0"+s1;
	} else {
		for(int i=1; i<=sz1-sz2; i++) {
			s2="0"+s2;
		}
	}
	sz1=s1.length();
	int cf=0;
	int temp;
	for(int i=sz1-1; i>=0; i--) {
		temp=s1[i]-'0'+s2[i]-'0'+cf;
		cf=temp/10;
		temp%=10;
		s=char(temp+'0')+s;
	}
	if(cf!=0) {
		s=char(cf+'0')+s;
	}
	return s;
}
string sub(string s1,string s2) {  
	string s;  
	int tmp=s1.length()-s2.length();  
	int cf=0;  
	for(int i=s2.length()-1; i>=0; i--) {  
		if(s1[tmp+i]<s2[i]+cf) {  
			s=char(s1[tmp+i]-s2[i]-cf+'0'+10)+s; 
			cf=1;  
		} else {  
			s=char(s1[tmp+i]-s2[i]-cf+'0')+s;  
			cf=0;  
		}  
	}  
	for(int i=tmp-1; i>=0; i--) {  
		if(s1[i]-cf>='0') {  
			s=char(s1[i]-cf)+s;  
			cf=0;  
		} else {  
			s=char(s1[i]-cf+10)+s;  
			cf=1;  
		}  
	}  
	s.erase(0,s.find_first_not_of('0'));  
	return s;  
}  
string mul(string s1,string s2) {  
	string s;  
	int sz1=s1.length();  
	int sz2=s2.length();  
	string tempstr;  
	for(int i=sz2-1; i>=0; i--) {  
		tempstr="";  
		int temp=s2[i]-'0';  
		int t=0;  
		int cf=0;  
		if(temp!=0) {  
			for(int j=1; j<=sz2-1-i; j++)  
				tempstr+="0";  
			for(int j=sz1-1; j>=0; j--) {  
				t=(temp*(s1[j]-'0')+cf)%10;  
				cf=(temp*(s1[j]-'0')+cf)/10;  
				tempstr=char(t+'0')+tempstr;  
			}  
			if(cf!=0)  
            tempstr=char(cf+'0')+tempstr;
		}  
		s=add(s,tempstr);  
	}  
	s.erase(0,s.find_first_not_of('0'));  
	return s;  
}  
int main() {  
	cin>>n;  
	for(i=3; i<=n; i++) {  
		s[i%3]=add(s[(i-1)%3],s[(i-2)%3]);  
	}  
	if(n%2==1) {  
		cout<<mul(s[n%3],s[n%3])<<endl;  
	} else {  
		cout<<sub(mul(s[n%3],s[n%3]),s1)<<endl;  
	}  
}  
```

其实我这代码就是套用了高精度加减乘除模板，再将它转换为斐波那契数列！请各位大佬们参考

---

## 作者：leozhang (赞：0)

洛谷居然没有打表的题解，这不科学...

表示我这种蒟蒻面对这种递推第一思想显然是打表啊

先贴个用来打表的暴力：

```cpp
#include <cstdio>
struct node
{
	int l,r;
}p[100005];
bool used[100005];
int f[100005];
int n,cnt,cct;
int findf(int x)
{
	if(x==f[x])
	{
		return x;
	}
	return f[x]=findf(f[x]);
}
bool check()
{
	for(int i=1;i<=n+1;i++)
	{
		f[i]=i;
	}
	for(int i=1;i<=cct;i++)
	{
		if(used[i])
		{
			int f1=findf(p[i].l);
			int f2=findf(p[i].r);
			f[f2]=f1;
		}
	}
	int ff=0;
	for(int i=1;i<=n+1;i++)
	{
		int f1=findf(i);
		if(!ff)
		{
			ff=f1;
		}else if(ff!=f1)
		{
			return 0;
		}
	}
	return 1;
}
void dfs(int dep,int tot)
{
	if(dep==cct+1)
	{
		if(tot==n)
		{
			if(check())
			{
				cnt++;
			}
		}
		return;
	}
	used[dep]=1;
	dfs(dep+1,tot+1);
	used[dep]=0;
	dfs(dep+1,tot);
}
int main()
{
	scanf("%d",&n);	
	for(int i=2;i<=n+1;i++)
	{
		p[++cct].l=1;
		p[cct].r=i;	
	}
	for(int i=2;i<=n+1;i++)
	{
		if(i==n+1)
		{
			p[++cct].l=i;
			p[cct].r=2;
		}else
		{
			p[++cct].l=i;
			p[cct].r=i+1;
		}
	}
	dfs(1,0);
	printf("%d\n",cnt);
	return 0;
}
/*
1 1
2 5
3 16
4 45
5 121
6 320
*/
```

实测这个打表程序是正确的（可以获得30分）

接下来是本人心路历程：

观察一下：1-1,2-5,3-16,4-45...找一下前后项吧！

观察前后项的倍数关系应该在2~3之间，那先定一个基础表达式

f[i]=2f[i-1]+...或f[i]=3f[i-1]+...

如果系数用2，发现剩下的部分长这样啊...

f[3]=2f[2]+6

f[4]=2f[3]+13

f[5]=2f[4]+31

...

好像后面的没啥规律...

那换系数用3！

f[4]=3f[3]-3

f[5]=3f[4]-14

...

好像也没啥啊...

等一下！

-3=-5+2

-14=-16+2

如果下面再写下来，应该是-43=-45+2！

这不就找出来了吗！

f[i]=3f[i-1]-f[i-2]+2!

于是敲个高精度这题就结束了...

```cpp
#include <cstdio>
#include <cmath>
#include <cstring>
#include <cstdlib>
#include <iostream>
#include <algorithm>
#include <queue>
#include <stack>
using namespace std;
struct Bignum
{
	int a[10005];
	int ilen;
}f[105],zero;
int n;
Bignum add(Bignum x)
{
	Bignum ret=x;
	ret.a[1]+=2;
	int i=1;
	while(ret.a[i]>=10)
	{
		ret.a[i+1]+=ret.a[i]/10;
		ret.a[i]%=10;
		i++;
	}
	if(ret.a[ret.ilen+1])
	{
		ret.ilen++;
	}
	return ret;
}
Bignum mul(Bignum x)
{
	Bignum ret=zero;
	for(int i=1;i<=x.ilen;i++)
	{
		ret.a[i]+=3*x.a[i];
		ret.a[i+1]+=ret.a[i]/10;
		ret.a[i]%=10;
	}
	ret.ilen=x.ilen;
	while(ret.a[ret.ilen+1])
	{
		ret.ilen++;
	}
	return ret;
}
Bignum sub(Bignum x,Bignum y)
{
	Bignum ret=zero;
	for(int i=1;i<=y.ilen;i++)
	{
		ret.a[i]+=x.a[i]-y.a[i];
		if(ret.a[i]<0)
		{
			ret.a[i]+=10;
			ret.a[i+1]--;
		}
	}
	for(int i=y.ilen+1;i<=x.ilen;i++)
	{
		ret.a[i]+=x.a[i];
	}
	ret.ilen=x.ilen;
	while(!ret.a[ret.ilen]&&ret.ilen>1)
	{
		ret.ilen--;
	}
	return ret;
}
int main()
{
	scanf("%d",&n);
	f[1].a[1]=1;
	f[1].ilen=1;
	f[2].a[1]=5;
	f[2].ilen=1;
	f[3].a[1]=6;
	f[3].a[2]=1;
	f[3].ilen=2;
	for(int i=4;i<=n;i++)
	{
		f[i]=mul(f[i-1]);
		f[i]=add(f[i]);
		f[i]=sub(f[i],f[i-2]);
	}
	for(int i=f[n].ilen;i>=1;i--)
	{
		printf("%d",f[n].a[i]);
	}
	printf("\n");
	return 0;
}
```

---

## 作者：ROBOT233 (赞：0)

怎么做的就不发了其他题解上有（其实我也不会嘿嘿），发下规律方便大家偷懒：

a[i]=3*a[i-1]-a[i-2]+2;

a[i]表示 i 轮病毒有几种；

然后数据测出来是要用高精度的，long long 60 分；

代码：


```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int a[102][102]={0},w[102]={0};int n;
	a[1][1]=1;a[2][1]=5;
	scanf("%d",&n);
	for(int i=3;i<=n;i++)a[i][1]=2;
	w[1]=1;w[2]=1;
	for(int i=3;i<=n;i++) 
	{
	   for(int j=1;j<=w[i-1]+2;j++)
	   {
	   	a[i][j]+=3*a[i-1][j]-a[i-2][j];
	   	if(a[i][j]<0)
		   {
		   a[i][j+1]-=((0-a[i][j])/10)+1;
		    a[i][j]+=(((0-a[i][j])/10)+1)*10;
		   }
		if(a[i][j]>=10)
		{
			a[i][j+1]+=a[i][j]/10;
			a[i][j]%=10;
		}
	   }
	   w[i]=w[i-1]+2;
	   while(a[i][w[i]]==0)w[i]--;
	}
	 
	for(int i=w[n];i>=1;i--)
	printf("%d",a[n][i]);
	return 0;
	
}
```  

---

## 作者：大奕哥 (赞：0)

今天给大家介绍行列式

引入两个概念 排列和逆序

排列即为一个序列，逆序为i<j&&a[i]>a[j]的个数记为r（a[1],a[2]...a[n]）

然后我们对于一个n^n的行列式，他的值就是Σ（-1）^r(j1,j2,j3...jn)\*a[1][j1]\*a[2][j2]\*...\*a[n][jn].此时j互不相等

由上面可以看出共有n！个数相加。

下面介绍行列式的几个性质

1.转置不改变行列式的值

转置：第i行变成第i列，相当于将行列式旋转九十度。

2.行（列）的公因子可以提出来

3.行列式具有可加性

4.行列式中如果某两行（列）对应位置成比例行列式的值为0

5.行列式中任意两行调换顺序行列式值为相反数

\*6.行列式中某行（列）的倍数加到另外一行（列）上时行列式的值不变

下面再介绍两个概念

余子式和代数余子式

余子式：拿掉任意一个含有a[i][j]的行和列后剩下的n-1阶的行列式为a[i][j]的余子式,值为det(a[i][j])。

代数余子式：M(i,j)=(-1)^(i+j)\*det(a[i][j])。

对于行列式我们必须要认清一个概念就是虽然它看上去是矩阵但他实际上表现得是一个数值。

例如一个三阶的行列式我们可以抽象看成是三条向量的面相交所成的几何模型的体积。

下面给出行列式的通项

det(A)={ 

               a[1][1]   (n=1)

    ∑(-1)^(i+j)\*a[1][j]\*det(A[1][j]) (j=1.....n) (n>1)

  }
行列式的值还可以展开为det(A)=∑a[i][1]\*M(i,1)  (i=1.....n)=∑a[1][i]\*M(1,i)  (i=1.....n)。

如果我们稍作修改就可以得到另外一个式子∑a[i][j]\*M(i,j)  (i=1.....n&&i!=j)=∑a[j][i]\*M(j,i)  (i=1.....n&&i!=j)=0。

下面给出一个非常有利于我们求行列式值的方法

在行列式中我们把左上到右下连线，如果在这条直线两边存在一边的值都为0，则答案为a[1][1]\*a[2][2]\*......\*a[n][n]

那么如果是右上和左下连边呢，结果就是上面答案\*(-1)^((n-1)\*n/2)

看到这里就可以用我们的高斯消元求解行列式的值了复杂度是O（n^3）

本题其实就是求生成树个数，对于基尔霍夫矩阵可以参考我的blog：http://www.cnblogs.com/nbwzyzngyl/p/8120127.html

对于行列式可以参考我的blog：http://www.cnblogs.com/nbwzyzngyl/p/8039714.html

对于maxtrix定理可以参考我的blog：

```cpp
http://www.cnblogs.com/nbwzyzngyl/p/8035005.html
#include<bits/stdc++.h>
using namespace std;
struct dayi
{
    int s[500],l;
    void print()
    {
        for(int i=l;i;--i)
        printf("%d",s[i]);
        return;
    }
}f[105];
dayi mul(dayi a,int x)
{
    for(int i=1;i<=a.l;++i)a.s[i]=a.s[i]*x;
    for(int i=1;i<=a.l;++i)a.s[i+1]+=a.s[i]/10,a.s[i]%=10;
    if(a.s[a.l+1])++a.l;
    return a;
}
dayi work(dayi a,dayi b)
{
    a.s[1]+=2;int j=1;while(a.s[j]>=10)a.s[j+1]++,a.s[j]%=10,j++;
    for(int i=1;i<=a.l;++i)
    {
        a.s[i]-=b.s[i];
        if(a.s[i]<0)a.s[i]+=10,a.s[i+1]--;
    }
    while(!a.s[a.l])a.l--;
    return a;
}
int main()
{
    int n;f[1].l=f[2].l=1;f[1].s[1]=1;f[2].s[1]=5;
    scanf("%d",&n);
    for(int i=3;i<=n;++i)
    f[i]=work(mul(f[i-1],3),f[i-2]);
    f[n].print();
}
```

---

## 作者：BLMontgomery (赞：0)

开始写了一个矩阵树,发现答案会超过long long的范围，而用高精好像会T，于是花了几十分钟去推这个基尔霍夫矩阵行列式的递推式。我们把这个图的基尔霍夫矩阵最后一行最后一列消去，现在只需要求这个矩阵A的行列式。我们对这个矩阵求它的代数余子式(两次消去第一行可以得到下面的f(n))。

设f(n)表示下列矩阵的行列值：（与A不同在(1,n)与(n,1)）

|3 -1 0 ... ... 0  0|
|-1 3 -1 0 ....0  0|
|0 -1 3 -1 0 ...  0|
|...      ...         ...|
|0  0... ... ...-1 3 |
消两次后可以得到f(n)=3\*f(n-1)-f(n-2)

于是det(A)=3\*f(n-1)-2\*f(n-2)-2

于是特判n=1,n=2，其余写高精递推即可

篇幅原因，具体过程可以参见我的博客:










    




```cpp
http://www.cnblogs.com/thkkk/p/7657664.html
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<iostream>
#include<vector>
#include<algorithm>
#include<queue>
#include<bitset>
#include<cmath>
#define P puts("lala")
#define pc cerr<<"lala"<<endl
#define HH puts("")
#define pb push_back
#define pf push_front
#define fi first
#define se second 
#define mkp make_pair
using namespace std;
inline void read(int &re)
{
    char ch=getchar();int g=1;
    while(ch<'0'||ch>'9') {if(ch=='-')g=-1;ch=getchar();}
    re=0;
    while(ch<='9'&&ch>='0') re=(re<<1)+(re<<3)+(ch^48),ch=getchar();
    re*=g;
}
typedef long long ll;
inline void read(ll &re)
{
    char ch=getchar();ll g=1;
    while(ch<'0'||ch>'9') {if(ch=='-')g=-1;ch=getchar();}
    re=0;
    while(ch<='9'&&ch>='0') re=(re<<1)+(re<<3)+ch-48ll,ch=getchar();
    re*=g;
}
const int N=109;
int n;
struct big
{
    int len;
    int s[100];
    big() {clean();}
    void clean()
    {
        memset(s,0,sizeof(s));len=0;
    }
    void operator = (int x)
    {
        for(;x;x/=10) s[len++]=x%10;
    }
    void print()
    {
        for(int i=len-1;i>=0;--i) printf("%d",s[i]);
        putchar('\n');
    }
};
big c;
big operator + (big a,big b)
{
    int len=max(a.len,b.len);
    c.clean();
    c.len=len;
    for(int i=0;i<len;++i) c.s[i]=a.s[i]+b.s[i];
    for(int i=0;i<len;++i) c.s[i+1]+=c.s[i]/10,c.s[i]%=10;
    if(c.s[len]) c.len++;
    return c;
}
big operator - (big a,big b)//a > b
{
    c.clean();
    for(int i=0;i<a.len;++i) 
    {
        c.s[i]+=a.s[i]-b.s[i];
        if(c.s[i]<0) c.s[i]+=10,a.s[i+1]--;
    }
    int len=a.len-1;
    for(;!c.s[len];len--);
    c.len=len+1;
    return c;
}
big operator * (big a,big b)
{
    int len=a.len+b.len-1;
    c.clean();
    c.len=len;
    for(int i=0;i<a.len;++i) for(int j=0;j<b.len;++j) c.s[i+j]+=a.s[i]*b.s[j];
    for(int i=0;i<len;++i) c.s[i+1]+=c.s[i]/10,c.s[i]%=10;
    if(c.s[len]) c.len++;
    return c;
}
big f[N];
int main()
{
#ifndef ONLINE_JUDGE
    freopen("1.in","r",stdin);freopen("1.out","w",stdout);
#endif
    int i,j,opt,T;
    read(n);
    f[1]=3;f[2]=8;
    if(n==1) {printf("1");return 0;}
    else if(n==2) {printf("5");return 0;}
    big three,two;
    three=3;two=2;
    for(i=3;i<=n;++i) f[i]=three*f[i-1]-f[i-2];
    big ans=(three*f[n-1])-(two*f[n-2])-two;
    ans.print();
    return 0;
}
```

---

## 作者：菜鸟ztc (赞：0)

这道题目的作法蒟蒻认为就是靠递推，递推关系虽然难找但毕竟还是可以通过死算发现如下规律：

若n为偶数，则ff[n]=f[n]\*f[n]-4\*((n+1))mod 2;若n为奇数，则ff[n]=f[n]\*f[n]，f[n]为第一项是1，第二项是3的斐波那契数列（参见楼上）

做完这道题，我发现了高精度模版的重要性。。。下附PASCAL代码：


```cpp
uses math;
type arr1=array[0..1000]of integer;
var i,j,k,m,n,sum:longint;
    f,ff:array[0..1000]of arr1;
    fff:arr1;
function jia(a,b:arr1):arr1;//三大模版
var i,j,k:longint;
begin
  fillchar(jia,sizeof(jia),0);//别忘了初始化
  k:=max(a[0],b[0]);
  for i:=1 to k do
    begin
      jia[i]:=jia[i]+a[i]+b[i];
      jia[i+1]:=jia[i] div 10;
      jia[i]:=jia[i] mod 10;
    end;
  if jia[k+1]<>0 then
    jia[0]:=k+1
  else
    jia[0]:=k;
end;
function cheng(a,b:arr1):arr1;
var i,j,x:longint;
begin
  fillchar(cheng,sizeof(cheng),0);
  for i:=1 to a[0] do
    begin
      x:=0;
      for j:=1 to b[0] do
        begin
          cheng[i+j-1]:=a[i]*b[j]+x+cheng[i+j-1];
          x:=cheng[i+j-1] div 10;cheng[i+j-1]:=cheng[i+j-1] mod 10;
        end;
      cheng[i+j]:=x;
    end;
  cheng[0]:=i+j;
  while (cheng[cheng[0]]=0) and (cheng[0]>1) do dec(cheng[0]);
end;
function jian(a,b:arr1):arr1;
var i,j,k:longint;
begin
  jian:=a;
  for i:=1 to jian[0] do
    begin
      if jian[i]<b[i] then
        begin
          jian[i+1]:=jian[i+1]-1;
          jian[i]:=jian[i]+10;
        end;
      jian[i]:=jian[i]-b[i];
    end;
  while jian[jian[0]]=0 do dec(jian[0]);
end;
begin
  readln(n);
  fillchar(f,sizeof(f),0);
  f[1][0]:=1;f[1][1]:=1;
  f[2][0]:=1;f[2][1]:=3;
  fff[0]:=1;fff[1]:=4;//若其为偶数需要减4，将4扔进数组，主要是为了方便使用模版
  if n=1 then
    begin
      writeln(1);
      exit;
    end;
  if n=2 then
    begin
      writeln(5);
      exit;
    end;
  for i:=3 to n do
    begin
      f[i]:=jia(f[i-1],f[i-2]);
      ff[i]:=jian(cheng(f[i],f[i]),fff);
    end;
  for i:=ff[n][0] downto 1 do
    write(ff[n][i]);
end.

```

---

## 作者：Skywalker_David (赞：0)

对于这个我们可以递推出来

我们只要选择连在一起有几个就行了，相当于把n分成很多段连续的圆弧

或者，你可以把n个点摆成一排，中心摆在下面

就是把n拆成很多个数字

f[i]:=i\*i（从f[0]递推的，即把外面的n个全部连起来，再连一条往中间）+f[i-1]+f[i-2]\*2+...+f[1]\*(i-1)

然后可以写出

f[i]:=f[i-1]+f[1]+f[2]+...+f[i-1]+2\*i-1

f[1]+f[2]+f[3]+...+f[i-1]可以用一个sum来记录

```delphi

const
  h=1000000000000000000;
type
  aa=array[0..4]of int64;
var
  f1,f2,sum:aa;
  n,i,j:longint;
  k:int64;
 
procedure jia(var a,b:aa);
begin
  for j:=1 to b[0] do
    inc(a[j],b[j]);
  if a[0]<b[0] then a[0]:=b[0];
  for j:=1 to a[0] do
    begin
      inc(a[j+1],a[j]div h);
      a[j]:=a[j]mod h;
    end;
  j:=a[0]+1;
  while a[j]>0 do
    begin
      inc(a[0]);
      inc(a[j+1],a[j]div h);
      a[j]:=a[j]mod h;
      inc(j);
    end;
end;
 
procedure print(var a:aa);
begin
  write(a[a[0]]);
  for j:=a[0]-1 downto 1 do
    begin
      k:=h div 10;
      while k>1 do
        begin
          if a[j]<k then write(0);
          k:=k div 10;
        end;
      write(a[j]);
    end;
end;
 
begin
  read(n);
  for i:=1 to n do
    begin
      inc(f2[1],2*i-1);
      jia(f2,sum);
      jia(sum,f2);
      f1:=f2;
    end;
  print(f1);
end.

```

---

## 作者：Mr_Li (赞：0)

       一开始看这道题可能没有什么头绪，仔细一看我们发现，核原子至少和基原子有一条信息通道直接相连，且如果说p条与核原子连接的信息通道及其两端将病毒分成p个基原子和基原子之间的信息通道的集合V={s,t,u}，其中s是基原子集合，t是基原子之间的信息通道集合，u是与核原子连接的信息通道集合，必有|s|=|t|且|u|>0（请读者自己证明）。
       所以，我们设f[i][j]表示在已知某两个相邻的基原子没有相连的情况下，有i条直接相连的核原子和基原子的信息通道，有j个基原子的轮状病毒，则f[i][j]=∑(f[i-1][k-1]\*(j-k+1)(1<=k<=j))。怎么证明这个公式呢？设一个核原子x连接的信息通道及其两端x,y将基原子a1,b1没有相连病毒V={s,t,u}分成两个集合V1={s1,t1,∅}和V2={s2,t2,u2}，其中s1的元素顺时针依次为a1,a2,…,a|s1|；s2的元素顺时针依次为b|s2|,b(|s2|-1),…,b1。则V1有C(|s1|+1,|t1|)=C(|s1|+1,|s1|)=|s1|+1=|s|-|s2|+1情况；V2相当于一个b1,b|s2|没有相邻的病毒V2'={s2,t2,u-{x}},有f[|u|-1][s2]种情况，所以V有(|s|-|s2|+1)\*f[|u|-1][s2]种情况。若y不确定，s2便不确定，于是有∑((|s|-l+1)\*f[|u|-1][s2](1<=l<=|s|))=f[i][j]种情况。但是一个轮状病毒只要是相邻的两点都有可能连边，所以我们可以任意连接一条与核原子连接得信息通道，将其转化为V的形式。不过因为有可能出现重复，所以我们要除以重复的个数。若答案为m，具体公式是m=f[i][n-1]\*n/(i+1)（请读者自己推导）。
还有一点，这道题需要高精度。则这道题的时间复杂度为O((floor(log10(m))+1)·n^3)，log10是求以10为底的对数，floor将小数用去尾法保留整数。

附代码：

1、单精度：

```cpp

#include<iostream>   
using namespace std;  
long long n,i,f[101][100]={},j,k,l,answer=0;  
int main ()  
{  
    cin>>n;  
    for (i=0;i<n;i++)  
    f[0][i]=i+1;  
    for (i=1;i<n;i++)  
    for (j=i;j<n;j++)  
    for (k=1;k<=j;k++)  
    f[i][j]+=f[i-1][k-1]*(j-k+1);  
    for (i=0;i<n;i++)  
    answer+=f[i][n-1]*n/(i+1);  
    cout<<answer<<endl;  
    return 0;  
}  

```
2、高精度：

```cpp

#include<iostream> 
using namespace std;
long long n,i,f[101][100][51]={},j,k,l,answer[51]={},temp1[51]={},temp2[51]={};
int main ()
{
    cin>>n;
    for (i=0;i<n;i++)
    f[0][i][0]=i+1;
    for (i=0;i<n;i++)
    for (j=0;j<50;j++)
    {
        f[0][i][j+1]=f[0][i][j]/10;
        f[0][i][j]%=10;
    }
    for (i=1;i<n;i++)
    for (j=i;j<n;j++)
    for (k=1;k<=j;k++)
    for (l=0;l<50;l++)
    {
        f[i][j][l]+=f[i-1][k-1][l]*(j-k+1);
        f[i][j][l+1]+=f[i][j][l]/10;
        f[i][j][l]%=10;
    }
    for (i=0;i<n;i++)
    {
        for (j=0;j<50;j++)
        temp1[j]=0;
        for (j=0;j<50;j++)
        temp2[j]=0;
        for (j=0;j<50;j++)
        {
            temp1[j]+=f[i][n-1][j]*n;
            temp1[j+1]=temp1[j]/10;
            temp1[j]%=10;
        }
        for (j=50;j>=0;j--)
        {
            if (j>0)
            temp1[j-1]+=temp1[j]%(i+1)*10;
            temp2[j]+=temp1[j]/(i+1);
        }
        for (j=0;j<=50;j++)
        {
            answer[j]+=temp2[j];
            answer[j+1]+=answer[j]/10;
            answer[j]%=10;
        }
    }
    for (i=50;answer[i]==0;i--);
    for (;i>=0;i--)
    cout<<answer[i];:
    return 0;
}

```

---

## 作者：Dispwnl (赞：0)

首先这题题意先看懂，就是求一个图中的最小生成树数量~~然后用矩阵树定理+高精瞎搞搞~~

然而作为一个啥也不会的菜鸡，怎么才能A掉这题呢？

这种题当然是找递推式子

所以打表找规律，自己写写画画数数~~然而n=4有45种情况233~~

然后你发现：

| n | ans |
| :----------: | :----------: |
| 0 | 0 |
| 1 | 1 |
| 2 | 5 |
| 3 | 16 |
| 4 |  45|


可以愉快的发现$f[i]=3*(f[i-1]-f[i-3])+f[i-4]$

本来我想用矩乘的结果发现$n<=100$没必要

套上高精度，乱打一通这题就A啦

代码：
```
# include<iostream>
# include<cstring>
# include<cstdio>
using namespace std;
int n;
int a[101],b[101];
string f[101];
string GET1(string A,string B)
{
  	int len;
	memset(a,0,sizeof(a));
	memset(b,0,sizeof(b));
  	a[0]=A.length();
  	for(int i=1;i<=a[0];++i)
      a[i]=A[a[0]-i]-'0';
	b[0]=B.length();
  	for(int i=1;i<=b[0];++i)
      b[i]=B[b[0]-i]-'0';
  	len=(a[0]>b[0]?a[0]:b[0]);
  	for(int i=1;i<=len;++i)
      a[i]+=b[i],a[i+1]+=a[i]/10,a[i]%=10;   
  	++len;
  	while(!a[len]&&len>1) --len;
  	string ans="";
	for(int i=len;i>=1;--i)
      ans+=a[i]+48;
    return ans;
}
string GET2(string A,int B)
{
	int len;
  	memset(a,0,sizeof(a));
  	memset(b,0,sizeof(b));
  	a[0]=A.length();
  	for(int i=1;i<=a[0];++i)
      a[i]=A[a[0]-i]-'0';
  	for(int i=1;i<=a[0];++i)
      b[i]+=a[i]*B,b[i+1]+=b[i]/10,b[i]%=10;   
  	len=a[0]+2;
  	while(!b[len]&&len>1) --len;
  	string ans="";
  	for(int i=len;i>=1;--i)
  	  ans+=b[i]+48;
  	return ans;
}
string GET3(string A,string B)
{
	memset(a,0,sizeof(a));
  	memset(b,0,sizeof(b));
	a[0]=A.length();
  	for(int i=1;i<=a[0];++i)
      a[i]=A[a[0]-i]-'0';
  	b[0]=B.length();
  	for(int i=1;i<=b[0];++i)
      b[i]=B[b[0]-i]-'0';
    for(int i=1;i<=a[0];++i)
      {
	  	a[i]-=b[i];
       	if(a[i]<0) --a[i+1],a[i]+=10;
      }
    ++a[0];
    while(!a[a[0]]&&a[0]>1) --a[0];
    string ans="";
    for(int i=a[0];i>=1;--i)
      ans+=a[i]+48;
    return ans;
}
int main()
{
	scanf("%d",&n);
	f[0]="0",f[1]="1",f[2]="5",f[3]="16";
	for(int i=4;i<=n;++i)
	  f[i]=GET1(GET2(GET3(f[i-1],f[i-3]),3),f[i-4]);
	int len=f[n].length();
	for(int i=0;i<len;++i)
	  printf("%c",f[n][i]);
	return 0;
}
```

emmm。。。我估计找规律+推式子+打高精考试就结束了233

所以还是乖乖去学矩阵树吧~~起码找规律不用一个一个画了~~

---


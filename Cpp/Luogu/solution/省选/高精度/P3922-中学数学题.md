# 中学数学题

## 题目背景

琪露诺：我知道了！答案是-1 0，因为幻想乡没有传送器！

露米娅：真拿你没办法。。算了，再来一道中学数学题吧

说着，露米娅写下了一个数列

$ 1 , 2 , 4 , 8 , 16 , 32 , 64 , 128 , \cdots , 2048 , 4096 , 8192 , 16384 , \cdots $


## 题目描述

露米娅：这个数列的通项公式是 $ x_n = 2^{n-1} $

那么你来求一下前 $ k+1 $ 项中有多少个第一位为4吧（比如4096）


输入经过“加密”

详细输入方式见【输入格式】


## 说明/提示

对于30%的数据， $ k_0 \leq 10^7, t = 1 $

对于70%的数据， $ k_0 \leq 10^9, t = 1 $

对于另外30%的数据， $ k_0 \leq 233 , t = 0 $

对于100%的数据，$ k_0 \geq 1 $


## 样例 #1

### 输入

```
1 3
```

### 输出

```
1
```

## 样例 #2

### 输入

```
0 1
```

### 输出

```
1
```

## 样例 #3

### 输入

```
1 10
```

### 输出

```
1
```

# 题解

## 作者：jijidawang (赞：23)

~~题目背景好评~~

一个数乘 $2$ 时，最高位的变化有下面几种：
- $1\to2\to4\to8\to1$ .
- $1\to2\to4\to9\to1$ .
- $1\to2\to5\to1$ .
- $1\to3\to6\to1$ .

其中要想最高位为 $4$ 必须经过 $4$ 次操作回到 $1$，所以要有 $4$ 的概率为 $\lg(5/4)=\lg(1.25)$ .

于是答案就是 $\lceil k\lg(1.25)\rceil$ .

然而这个真正的 $k$ 可以达到 $10^{233}$，所以我们需要一个高精 .

高精浮点数我又不会写，只能用 Python 了 .

Python 有一个库叫 `decimal`，里面自带一个高精浮点数 `Decimal`，可以通过 `getcontext().prec` 调精度 .

具体看代码吧：
```python
from decimal import Decimal, getcontext
getcontext().prec = 1000
n, k0 = input().split()
n = Decimal(n)
k0 = Decimal(k0)
if n == Decimal('0'):
    k0 = 10 ** k0
print((k0 * Decimal('1.25').log10() + Decimal('0.999999999')) // Decimal('1'))
```
要注意的是运算要把一般字面量强转成 `Decimal` .

这个代码可能写法比较丑，仅供参考 .

~~听说标程写了 17k~~

---

## 作者：oscar (赞：18)

解法0：

学习⑨，输出1

期望得分：0分

解法0.5：

找规律，发现mod10余2的项数上最高位为4，于是直接数学方法算

##很抱歉这个规律是错误的

期望得分0分

解法1：

暴力拿高精度乘，暴力取最高位

时间复杂度O(n^2)

期望得分0分

解法1.5：

对解法1进行有理有据的优化

时间复杂度O(n)

期望得分30~40分

解法1.75：

分段打表

期望得分30~40分


Hint：

找到规律？3/10？301/1000？或者某些奇怪的分数？

有没有想到这些分数在趋近某个无理数


解法2：

观察下图

1--2--4--8

\  \  \

\  5  9

\
3--6
\
7
发现每次乘二后最高位会向右或右下移一格（1->2,1->3,2->4,2->5,...），若到最右侧则一定回到1

又发现所有经过4次回到1的路线都经历了最高位为4的阶段，所有经过3次回到1的路线都没有经过最高位为4的阶段

于是只需要求出2^n共有k位后解方程4x+3(k-x)=n即可

可以使用对数来快速算出k（没错刚才的“趋近某个无理数”就是在说log\_10{2}）

时间复杂度O(log(n))

期望得分70~80分

解法3：

使用高精度优化一下

高精log2可以打表或者使用泰勒展开计算

注意提供的高精度库中不包含大整数的高精度部分，所以还是需要手打

时间复杂度O(log(n))

本题标程有17k，比赛的时候尝试写满分做法貌似有点作（逃

改编自美国数学国家队口算题（逃


upd：比赛时好像很多人根据概率分布用log(5/4)水到高分QAQ，而我貌似不会卡？


期望得分100分

不给标程啦


---

## 作者：培淇2021 (赞：13)

在这道题的题解区内，我发现某些人的解答有一点点的不严格。

大家代码可以看别人的，这里我说一下如何得出结论。

大部分人的“结论”其实就是在 $n$ 趋向于 $+\infty$ 时，有 $2^n$ 的最高位是 $4$ 的概率为 $\lg 5-\lg 4$。

其实这是可以严格证明的，首先给出一个性质：

[**（Weyl 等分布定理的应用）对于一个无理数，它的整数倍的小数部分在 $(0,1)$ 上等分布。**](https://www.zhihu.com/question/488116744)

这个证明有点高等，我重点讲一下通过这个如何得出结论。

对于 $2^k$，设它的位数为 $n+1$，则必定有 $10^n\le 2^k<10^{n+1}$。

我们需要的是，$4\times 10^n\le 2^k<5\times 10^n$。

两边 $\lg$ 一下，得 $n+\lg 4\le k\lg 2<n+\lg 5$。

即 $k\lg 2$ 的小数部分落在 $[\lg 4,\lg 5)$ 之间。

而本来小数部分就落在 $[0,1)$ 之间。

故其小数部分落在 $[\lg 4,\lg 5)$ 之间的概率为 $\lg 5-\lg 4$。

类似此过程，我们还可以得出最高位为 $1,2,3,5,6,7,8,9$ 的概率，留做习题。

---

## 作者：Alarm5854 (赞：13)

这道题很坑，从17年开始到现在都只有十几个人通过，而题解也只有一篇，而且标程不给。我就简单的再叙述一下做法（从70分做法开始）。  
当一个数乘 $2$ 的时候，最高位的变化如下：  
$1-2-4-8-1$  
$1-2-4-9-1$  
$1-2-5-1$  
$1-3-6-1$  
其中，只有经过 $4$ 次回到 $1$ 的才会出现最高位为4的数字，而 $5/4=1.25$（要保证经过 $4$），所以不偏移 $4$ 的概率为 $\lg(1.25)$，答案就是 $ans=\lceil k\lg(1.25)\rceil$，这样，就至少有 $70$ 分了。

难点来了，怎么高精度计算 $\lg(1.25)$ 呢？当然，有两种选择，一种是打表，一种就是泰勒展开计算。可是我太弱了，不会第二种，所以只能打表。怎么打表，这就要一个好一点的计算器了，本来想用桌面上的计算器，看到还比较可靠，结果发现我被骗了——第 $38$ 个数就错！找了半天才找到一个好的计算器，并打了 $240$ 位的表，流程如下（前提是有一个好的计算器）：
```
1.先直接计算lg(1.25)，设答案为x
2.将x乘上10^20
3.将x减去floor(x)，并记下小数点后的前20位
4.重复12次，即可打出前240位的表
```
由于当 $t=0$ 时，找到是 $10^{k_0}$，所以直接输出即可。

### 代码如下：
```cpp
#include<cmath>//有一次CE之后我就不敢用万能头了！
#include<cstdio>
#include<string>
using namespace std;
const int N = 240 + 10;
FILE *fin, *fout;
inline int read(int &x) {
	char c = 0; int f = x = 0;
	while (c < 48 || c > 57) {
		if (c == -1) return 0;
		if (c == '-') f = 1; c = fgetc(fin);
	}
	while (c > 47 && c < 58) x = (x << 3) + (x << 1) + (c & 15), c = fgetc(fin);
	if (f) x = -x; return 1;
}
template<class T, class... Args> inline int read(T &x, Args&... args) {
	return read(x) + read(args...);
}
inline int write(int x) {
	if (x < 0) return fputc(45, fout), write(-x);
	if (x > 9) write(x / 10);
	return fputc((x % 10) | 48, fout), 1;
}
int t, k, ans, det, a[N];
string str = 
"09691001300805641435"
"87833158265209196954"
"30355613674376068717"
"61661867543217672647"
"15392182436454414838"
"77946568425707013862"
"71569635659942948200"
"09229988859132748064"
"91107237419792014540"
"79706519116949644829"
"13054642521485366814"
"04414212860938345902";//lg(1.25)的前240位
signed main() {
	#ifdef ONLINE_JUDGE
	fin = stdin;
	fout = stdout;
	#else
	fin = fopen("P3922.in", "rb");
	fout = fopen("P3922.out", "wb");
	#endif
	read(t, k), a[0] = k;
	if (t) write(ans = ceil(k * log10(1.25)));//由于这时候k较小，所以直接输出答案即可
	else {
		for (int i = 0; i < a[0]; ++i) a[k - i] = str[i] & 15;//先按高精度的方法读入
		++a[det = 1]; while (a[det] > 9) a[det] -= 10, ++a[det + 1];//加1，因为lg(1.25)是无理数，所以向上取整恰好就是最后一位数加1
		while (a[a[0] + 1]) ++a[0]; while (!a[a[0]] && a[0] > 1) --a[0];//去前导零
		for (int i = a[0]; i; --i) write(a[i]);
	}
	return 0;
}
```

---

## 作者：MA_master (赞：5)

首先拿到这道题我以为就是一个简单的 $ 2 ^ n $ 的算法题，

于是就十分迅速写出来以下代码:
```python
k, n=input().split()
n=int(n)
k=int(k)
if(k==0):
    n=10**n
powt=1
res=0
for i in range(n):
    powt*=2
    if(str(powt)[0]=='4'):
        res+=1
print(res)
```
然后就肯定是
##### 稻花香里说丰年，
# 听取WA声一片。

当我看到了数据大小的时候：

>对于30%的数据， $ k_0 \leq 10^7, t = 1 $ \
>对于70%的数据， $ k_0 \leq 10^9, t = 1 $ \
>对于另外30%的数据， $ k_0 \leq 233 , t = 0 $ \
>对于100%的数据，$ k_0 \geq 1 $ 

## $ k_0 \leq 233 , t = 0  !!!!$
这就意味着数字要乘到 $ 2 ^ { 10 ^ { 233 } } $ （一般计算器算到 $ 2 ^ { 10 ^ { 5 } } $ 就会显示 `溢出`） 。

下面，正文开始。

# 正文

我们知道一个数不断乘 $ 2 $ 的时候，最高位是这样变化的：
$$ \green 1 - 2 - \red 4 - 8 - \green 1 - 2 - \red 4 - 9 - \green 1 - 2 - 5 - \green 1 - 3 - 6 - \green 1 $$
其中，只有经过 $ \red 4 $ 次回到 $ \green 1 $ 才会出现最高位为 $ \red 4 $ 的数字,如果要保证经过 $ \red 4 $，则不偏移 $ \red 4  $ 的概率为 $ log _ { 10 } { ( 5 / 4 ) } $ ,答案就是 $ log _ { 10 }{ ( 1.25 ) } \times k_0 $ 。

### 问题来了：怎么算 $ log_{10}{(1.25)} $ 呢？

要么是泰勒展开，要么是打表，

而我不会高等数学，又不会泰勒展开，

所以就只能打表。

## 问题又来了：哪里去找一个 $ 233 $ 位以上的 $ log_{10}{(1.25)}$ 呢？
计算器？

计算器给出 ` 0.09691001300805641435878331582652 ` ，只有不到 $50$ 位。。

然后我又想到了 `Python` ： `Python` 里有一个库叫 `decimal`（十进制） ，用于计算和存储高精度浮点数，用 `getcontext().prec` 调精度。（没错我要打表）

于是打表计算器代码就出来了：
```py
from decimal import Decimal, getcontext
getcontext().prec = 240 #取个整
print(Decimal('1.25').log10())#取log10(1.25)的前240位
```
程序输出： `0.0969100130080564143587833158265209196954303556136743760687176166186754321767264715392182436454414838779465684257070138627156963565994294820009229988859132748064911072374197920145407970651911694964482913054642521485366814044142128609383459014`

## 代码实现
有了 $log_{10}{(1.25)}$，剩下的事就很简单了。

#### 当 `t==1` 时
直接用输入的 $k$ 乘以低精度的 $log_{10}{(1.25)}$。
```cpp
if(t==1) 
cout<<(long long)(ceill(0.09691001300805641435*k));
//反正打表就不用<math.h>的log10了
```
#### 当 `t==0` 时
需要使用到高精度乘法。\
我们小学学过一个小数乘 $10^n$，就是把这个数的小数点往后移 $n$ 位。现在我们模拟这个操作而不需要复杂的高精度乘法运算,只需要最后做一个用来向上取整的加法。

 先打一个高精度加法（看看就行，别学）。
```cpp
int str_int(char a){return int(a)-'0'; } char int_str(int a) {return char(a+'0'); } string zero(string a,unsigned int len) {while((a.size()!=len)) {a.insert(0,"0"); } return a; } string add(string a,string b) {string sum=""; if(a.size()<b.size()) a=zero(a,b.size()); else if(a.size()>b.size()) b=zero(b,a.size()); a.insert(0,"0");b.insert(0,"0"); int j=0; for(int i=a.size()-1;i>=0;i--) {int k; k=str_int(a[i])+str_int(b[i])+j; j=0; if(k>=10) {k-=10; j=1; } sum.insert(0,1,int_str(k)); } while(sum[0]=='0') sum.erase(0,1); if(sum.size()==0) sum.insert(0,"0"); return sum; }
```
然后同上。
```cpp
else{//t=0时
string log="096910013008056414358783315826520919695430355613674376068717616618675432176726471539218243645441483877946568425707013862715696356599429482000922998885913274806491107237419792014540797065191169496448291305464252148536681404414212860938345902";
string a="";
for(unsigned long long i=0;i<k;i++)
{
	a.insert(a.size(),1,log[i]);//在数字末尾加上一位，相当于移动小数点
}
```

### 代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
//从这开始是一段高精度加法，因为要向上取整{
int str_int(char a){return int(a)-'0'; } char int_str(int a) {return char(a+'0'); } string zero(string a,unsigned int len) {while((a.size()!=len)) {a.insert(0,"0"); } return a; } string add(string a,string b) {string sum=""; if(a.size()<b.size()) a=zero(a,b.size()); else if(a.size()>b.size()) b=zero(b,a.size()); a.insert(0,"0");b.insert(0,"0"); int j=0; for(int i=a.size()-1;i>=0;i--) {int k; k=str_int(a[i])+str_int(b[i])+j; j=0; if(k>=10) {k-=10; j=1; } sum.insert(0,1,int_str(k)); } while(sum[0]=='0') sum.erase(0,1); if(sum.size()==0) sum.insert(0,"0"); return sum; }
//}结束
//高精度的代码就不放了，因为效率太低，可以自行替换成其他代码
int main()
{
	string log="096910013008056414358783315826520919695430355613674376068717616618675432176726471539218243645441483877946568425707013862715696356599429482000922998885913274806491107237419792014540797065191169496448291305464252148536681404414212860938345902";//刚才打的表
	int t;unsigned long long k;cin>>t>>k;//根据题意输入
	long double log1=0.09691001300805641435;//低精度log
	if(t==1) cout<<(long long)(ceill(log1*k));//t=1时直接乘
	else{//t=0时
		string a="";
		for(unsigned long long i=0;i<k;i++)
		{
			a.insert(a.size(),1,log[i]);
		}
     /*
     这里解释一下：在我们小学五年级学过一个小数乘10^n，就是把这个数的小数点往后移n位
     这段代码就是模拟这个操作而不需要复杂的高精度乘法运算
     时间复杂度O(n)
     */
		cout<<add(a,"1");//其实就是向上取整
	}
	return 0;
}
```
**附上 `Python` 题解**：
```python
from decimal import Decimal, getcontext#导入
getcontext().prec = 240 
#上面不做解释，往前翻
t, k0 = input().split()#读入t和k0
t = Decimal(t)#转换为高精浮点
k0 = Decimal(k0)#同理

if (t == Decimal('0')):#t==0时
    k0 = 10 ** k0 #k0变成10^k0
print((k0 * Decimal('1.25').log10() + Decimal('0.99999')) // Decimal('1')) #计算、输出
#加Decimal('0.99999)再除以1其实就是一个向上取整
#TODO请注意高精度浮点就必须强转Decimal
```

#### 求过、求赞
## 感谢观看


---

## 作者：tony0530 (赞：0)

# **题意**
问通项公式为 $x_i=2^{i-1}$ 的序列 $x_i$ 前 $k+1$ 个数有多少个数的最高位是 $4$？
# **思路**
这道题目其实蛮有意思的。拿 70 分很简单，但是拿 100 分就有一点难度。

我们可以枚举几个连续 $2$ 次幂的最高位的所有情况，我把所有情况都枚举在下面：

- $1\rightarrow2\rightarrow4\rightarrow8\rightarrow1$；
- eg. $1\rightarrow2\rightarrow4\rightarrow8\rightarrow16$；
- $1\rightarrow3\rightarrow6\rightarrow1$；
- eg.$16\rightarrow32\rightarrow64\rightarrow128$；
- $1\rightarrow2\rightarrow4\rightarrow9\rightarrow1$；
- eg.$1125899906842624\rightarrow2251799813685248\rightarrow4503599627370496\rightarrow9007199254740992\rightarrow18014398509481984$；
- $1\rightarrow2\rightarrow5\rightarrow1$；
- eg.$140737488355328\rightarrow281474976710656\rightarrow562949953421312\rightarrow1125899906842624$；

因为想要最高位为 $4$ 必须经过 $4$ 次操作回到 $1$，所以有 $4$ 的概率有 $\log_{10}5/4=\log_{10}1.25$，答案就是 $\lceil k_0\times \log_{10}1.25\rceil$ 啦。

期望得分 $70$。

为什么得不到满分呢？

因为——对于另外 $30\%$ 的数据，$k_0 \le 233,t=0$！

也就是 $k_0 \le 10^{233}$ 怎么办呢？

我们可以 ~~打表~~ 用高精度！

虽然有一点打表，但不多。

我们算出前 $240$ 位的 $\log_{10}1.25$，再加上高精度加法就好了。

# **代码**
打码不易，**请勿** `ctrl+C`！

本人蒟蒻，大佬勿喷。

```cpp
#include <bits/stdc++.h>

#define int long long

using namespace std;

const int N = 250;

int t, k;
int det, a[N];
int ans;
string lg = "096910013008056414358783315826520919695430355613674376068717616618675432176726471539218243645441483877946568425707013862715696356599429482000922998885913274806491107237419792014540797065191169496448291305464252148536681404414212860938345902";

signed main()
{
    cin >> t >> k;
    a[0] = k;
    if(t == 1) cout << (long long)(ceill((double)(0.09691001300805641435)*k));
    else{
        for(int i = 0 ; i < a[0] ; i ++ ) a[k - i] = lg[i] & 15;
        ++ a[det = 1];
        while(a[det] > 9)
        {
            a[det] -= 10;
            ++ a[det + 1];
        }
        while(a[a[0] + 1]) ++ a[0];
        while(a[a[0]] == 0 && a[0] > 1) -- a[0];
        for(int i = a[0] ; i ; i -- ) cout << a[i];
    }
}
```

---


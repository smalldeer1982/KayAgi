# [THUPC 2023 初赛] 拧螺丝

## 题目背景

张华考上了北京大学；李萍进了中等技术学校；~~小 E 在工地搬砖~~：他们都有光明的前途。

由于搬砖太累，小 E 决定进厂拧螺丝。但是小 E 遇到了一个各种刁难人的老板。

## 题目描述

加工一个模块需要拧 $n$ 个螺丝。但是，每隔 $10$ 分钟，小 E 的老板就会到小 E 的工位上收走一个未完工的模块。在这期间，只够小 E 拧 $k$ 个螺丝。

小 E 的老板刚刚离开。问老板接下来第几次来的时候小 E 才可能有一个完工的模块？假设小 E 的老板极力不想让小 E 达成这件事。

## 说明/提示

#### 样例解释 1

小 E 先选择两个模块各拧上一个螺丝，然后老板来了拿走一个。接下来小 E 只需要在剩下的那个零件上面拧两个螺丝就可以完工了。所以老板第二次来的时候小 E 就有了一个完工的模块。注意小 E 在老板来的时候不能有只拧上了一半的螺丝，不然老板看到了会说小 E 加工不合格。

#### 子任务

保证 $1\le k \le n \le 10^5$。

#### 题目来源

来自 2023 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2023）初赛。

题解等资源可在 <https://github.com/THUSAAC/THUPC2023-Pre> 查看。

## 样例 #1

### 输入

```
3 2
```

### 输出

```
2
```

# 题解

## 作者：WYXkk (赞：16)

观察样例解释，可以得到结论：在完成的前一步，老板来之前，必须有至少 $2$ 个拧好至少 $n-k$ 个螺丝的模块。无论老板收走其中的任何一个，都可以马上拧好另一个。

为了讨论方便，下面继续用 $k=3$ 举例，并假设 $n$ 是很大的数。

而再往前一步呢？再上一步收走后，需要两个分别至少拧好 $n-3,n-6$ 个螺丝的模块，或者 $n-4,n-5$。

老板的最优策略显然是每次收走最大的那个，因此，再上一步收走前，需要三个分别至少拧好 $n-3,n-3,n-6$ 或 $n-4,n-4,n-5$ 个螺丝的模块。

后者需要更少的总螺丝达成，且最大值更小，因此需要准备被老板收走的其它模块需要的螺丝也更少，所以后者优于前者。

再往前一步，用类似的道理，可以证明需要四个分别至少拧好 $n-5,n-5,n-5,n-6$ 个螺丝的模块；再往前一步是 $n-6,n-6,n-6,n-6,n-6$；等等。

这样的状态可以用三元组 $(width,height,remain)$ 表示：总共需要准备 $width$ 个模块，其中每个都需要拧好至少 $height$ 个，而其中 $remain$ 个需要再多一个。

这样取名是因为，状态可以用添加一个不完整的行的矩形来表示：$height$ 行 $width$ 列再加上仅有 $remain$ 个的不完整的一行。

可以参考下面的可视化：

```plain
o
o
o
o  oo
o  oo  oo
o  oo  ooo  ooo
o  oo  ooo  oooo  ooooo  ooo
```

容易发现，每次倒推一步相当于：

- 计算当前总个数
- 减去 $k$ 个
- 平均地重排，多一个的列放在左侧
- 在左侧添加一列，高度与当前最左列相同

很容易写出倒推一步的程序。如果倒推了 $x$ 步后发现状态相当于不需要额外准备模块，此时 $width=x+1$，那么输出 $width-1$ 即可。

最后再特判 $k=1$，此时 $n=1$ 时答案为 $1$，否则为不可能。

那么这样就做完了……吗？

每次只能在最上面一列消除 $k-1$ 个，所以 $width$ 的增长是 $\left(\dfrac{k}{k-1}\right)^n$ 级别；在 $k$ 很小而 $n$ 很大时，答案将会无比巨大。

因此，不仅需要使用高精度，而且也不再能一步一步模拟。

不过，当 $remain>k$ 时，每一步仅仅相当于 `remain-=k-1;width+=1;`，可以直接一次性模拟多步；而 $remain\le k$ 时，下一步就会让 $height$ 减少 $1$，$remain$ 相应变化。

如此特殊处理后就差不多做完了……吗？

来算一下时间复杂度：需要 $O(n)$ 次 $O(n)$ 位高精与低精的运算，也就是 $O(n^2)$ 的复杂度；再看一眼数据范围，$n=10^5$。看起来似乎不太过得了。

不过，可以注意到，$k=2$ 时，答案为简单的 $2^{n-2}(n\ge 2)$，可以简化计算；而 $k=3$ 时，底数仅仅有 $1.5$，再压一压位似乎常数可以变得很小。所以就可以过了。

参考代码（懒得实现高精，所以直接使用了 python）：

```python
n,k=map(int,input().split(' '))
if k==1: # 特判 k=1
    if n==1:
        print(1)
    else:
        print('Poor E.S.!')
else:
    if k==2: # 特判 k=2
        if n<=2:
            print(1)
        else:
            print(2**(n-2))
    else:
        width,height,remain=1,n,0
        while width<2*k and (height>0 or (height==0 and remain>0)): # width 很小时，无需一次模拟多步
            cnt=width*height+remain
            cnt=cnt-k
            height=cnt//width
            remain=cnt-height*width
            width+=1
            if remain!=0:
                remain+=1
        while height>0 or (height==0 and remain>0): # width 现在很大，必须一次模拟多步
            if remain>=2:
                mult=(remain-2)//(k-1)
                remain=remain-mult*(k-1)
                width+=mult
            height-=1
            width+=1
            remain=width-(k-remain)
        print(width-1)
```  


---

## 作者：Alex_Wei (赞：9)

> [P9134 [THUPC 2023 初赛] 拧螺丝](https://www.luogu.com.cn/problem/P9134)

考虑倒推，最终有一个 $n$，则最后一次老板来之后至少有一个 $n - k$，则老板来之前至少有两个 $n - k$，则倒数第二次老板来之后必须有一个 $n - k - a$ 和一个 $n - k - b$，其中 $a + b = k$。那么 $a, b$ 具体等于多少呢？因为倒数第二次老板来的时候肯定会收走 $\max(n - k - a, n - k - b)$，所以我们希望这个最大值尽可能小，即必须有一个 $n - k - \lfloor \frac k 2\rfloor$ 和一个 $n - k - \lceil \frac k 2 \rceil$，则倒数第二次老板来之前必须有两个 $n - k - \lfloor \frac k 2\rfloor$ 和一个 $n - k - \lceil \frac k 2\rceil$，以此类推。

我们发现，为了让老板来的时候收走的数尽量小，小 E 会尽可能平均地分配每个数，即不存在 $p, q$ 使得 $p \geq  q + 2$。因此，设 $a, b$ 表示当前需要 $a$ 个 $n$ 和 $b$ 个 $n - 1$。在两次老板来的间隔当中，小 E 会不断将其中最大的数减小 $1$ 总共 $k$ 次，而每次老板来都相当于将最大的数的个数增加 $1$，即 $a$ 增加 $1$。当所有数均为 $0$ 时倒推停止。

因为 $a, b$ 在 $k$ 小 $n$ 大的时候非常大（根据模拟过程，我们发现答案是 $(\frac k {k - 1}) ^ n$ 级别的），所以当 $a > k$ 时，需要将若干次 $a$ 减去 $k - 1$ 批量打包在一起算。

因涉及 $\mathcal{O}(n)$ 次 $\mathcal{O}(n)$ 位数的加法和乘除低精度，所以时间复杂度 $\mathcal{O}(n ^ 2)$，特判 $k = 2$ 后压位高精勉强卡过。

高精度题，还是 Python 好啊。

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using ull = unsigned long long;

bool Mbe;
constexpr int N = 4e3 + 5;
constexpr ll base = 1e13;
struct BigInt {
  #define len a.size()
  vector<ll> a;
  void init(ll x) {
    a.resize(1), a[0] = x;
  }
  void adjust() {
    while(!a.empty() && !a.back()) a.pop_back();
  }
  ll eval() {
    return len == 0 ? 0 : len == 1 ? a[0] : base;
  }
  void print() {
    if(!len) return cout << "0\n", void();
    for(int i = len - 1; ~i; i--) {
      if(i == len - 1) cout << a[i];
      else for(ll p = base / 10; p; p /= 10) cout << a[i] / p % 10;
    }
    cout << "\n";
  }

  void add(ll x) {
    assert(0 <= x && x < base);
    a.push_back(0), a[0] += x;
    for(int i = 0; i + 1 < len; i++) {
      if(a[i] >= base) a[i + 1]++, a[i] -= base;
      else break;
    }
    adjust();
  }
  void sub(ll x) {
    assert(0 <= x && x <= eval());
    a.push_back(0), a[0] -= x;
    for(int i = 0; i + 1 < len; i++) {
      if(a[i] < 0) a[i + 1]--, a[i] += base;
      else break;
    }
    adjust();
  }
  void add(const BigInt &x) {
    a.resize(max(len, x.len) + 2);
    for(int i = 0; i < x.len; i++) {
      a[i] += x.a[i];
      if(a[i] >= base) a[i + 1]++, a[i] -= base;
    }
    adjust();
  }
  void mul(ll x) {
    assert(1 <= x && x < base);
    a.push_back(0);
    for(int i = 0; i + 1 < len; i++) a[i] *= x;
    for(int i = 0; i + 1 < len; i++) a[i + 1] += a[i] / base, a[i] %= base;
    adjust();
  }
  int div(int x) { // return remainder
    assert(1 <= x && x < base);
    ll remain = 0;
    for(int i = len - 1; ~i; i--) {
      remain = remain * base + a[i];
      a[i] = remain / x, remain %= x;
    }
    adjust();
    return remain;
  }
  #undef len
} ans, a, b; // a * n + b * (n - 1)

int n, k;
bool Med;
int main() {
  fprintf(stderr, "%.3lf MB\n", (&Mbe - &Med) / 1048576.0);
  ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
  #ifdef ALEX_WEI
    FILE* IN = freopen("1.in", "r", stdin); 
    FILE* OUT = freopen("1.out", "w", stdout);
  #endif

  cin >> n >> k;
  if(k >= n) puts("1");
  else if(k == 1) puts("Poor E.S.!");
  else if(k == 2) {
    ans.init(1);
    n -= 2;
    while(n >= 15) ans.mul(1 << 15), n -= 15;
    ans.mul(1 << n);
    ans.print();
  }
  else {
    a.init(1);
    while(n) {
      if(a.eval() > k) {
        BigInt c = a;
        c.sub(2);
        int rem = c.div(k - 1);
        ans.add(c);
        a.init(rem + 2);
        c.mul(k), b.add(c);
      }
      ans.add(1);
      int cnt = k;
      while(cnt && n) {
        if(a.eval() > cnt) {
          a.sub(cnt), b.add(cnt);
          cnt = 0;
        }
        else {
          b.add(a.eval());
          cnt -= a.eval();
          a = b, b.init(0);
          n--;
        }
      }
      a.add(1);
    }
    ans.print();
  }
  cerr << 1e3 * clock() / CLOCKS_PER_SEC << " ms\n";
  return 0;
}
```

---

## 作者：封禁用户 (赞：3)

(~~好题! 好题!~~)

**Solution**：

考虑如何暴搜，从最终状态只有唯一的 $n$ 倒序还原回去，相当于不断执行以下操作直到没有螺丝：

1. 执行以下操作 $k$ 次：

   找到当前含有最多螺丝的工件，将螺丝数减一。
 
2. 将当前含有最多螺丝的工件复制一份。

设 $f_k(n)$ 表示参数为 $(n,k)$ 的答案，查询 OEIS 可知 
$$f_k(1) = 1,f_k(n) = \lceil \frac{\sum _ {i = 1} ^ {n - 1} f_k(i)} {k - 1} \rceil (n > 1)$$

然后压位高精实现即可。

code：

```cpp
#include <bits/stdc++.h>

typedef long long ll;
const int N = 5e3 + 5;
const ll mod = 1e13;
int n, k;

template <class T>
inline T Max(T x, T y) {return x > y ? x : y;}

struct bigint
{
	ll g[N];
	int gn;
	
	inline bigint operator + (const bigint &a) const  
	{
		bigint b;
		b.gn = Max(gn, a.gn);
		for (int i = 1; i <= b.gn; i++)
			b.g[i] = g[i] + a.g[i];
		for (int i = 1; i <= b.gn; i++)
		{
			b.g[i + 1] += b.g[i] / mod;
			b.g[i] %= mod;
		}
		while (b.g[b.gn + 1])
			b.gn++;
		return b;
	}
	
	inline int module(const int &k)
	{
		g[0] = 0;
		for (int i = gn; i >= 1; i--)
		{
			g[i - 1] += (g[i] % k) * mod; 
			g[i] /= k;
		}
		while (!g[gn])
			gn--;
		return g[0] / mod;
	}
	
	inline void print()
	{
		printf("%lld", g[gn]);
		for (int i = gn - 1; i >= 1; i--)	
			printf("%013lld", g[i]); 
	}
}sum;

int main()
{
	scanf("%d%d", &n, &k);
	if (k == 1 && n != 1)
	{
		puts("Poor E.S.!");
		return 0;
	}
	k--;
	if (n == 1)
		puts("1");
	else 
	{
		sum.gn = 1;
		sum.g[1] = 1;
		for (int i = 2; i <= n; i++)
		{
			bigint now = sum;
			if (now.module(k) > 0)
			{
				now.g[1]++;
				int t = 1;
				while (now.g[t] == mod)
				{
					now.g[t] = 0; 
					now.g[++t]++;
				}
				while (now.g[now.gn + 1])
					now.gn++;
			}
			if (i == n)
				now.print();
			sum = sum + now;
		}
	}
}
```


---


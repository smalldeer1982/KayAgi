# 题目信息

# [NOIP 1998 提高组] 进制位

## 题目描述

著名科学家卢斯为了检查学生对进位制的理解，他给出了如下的一张加法表，表中的字母代表数字。 例如：

$$
\def\arraystretch{2}
\begin{array}{c||c|c|c|c}
\rm +  & \kern{.5cm} \rm \mathclap{L} \kern{.5cm}  &  \kern{.5cm} \rm \mathclap{K} \kern{.5cm} &  \kern{.5cm} \rm \mathclap{V} \kern{.5cm} & \kern{.5cm} \rm \mathclap{E} \kern{.5cm} \\ \hline\hline
\rm L  &  \rm L  &  \rm K  &  \rm V  & \rm E  \\ \hline
\rm K  &  \rm K  &  \rm V  &  \rm E  & \rm \mathclap{KL} \\ \hline
\rm V  &  \rm V  &  \rm E  &  \rm \mathclap{KL} & \rm \mathclap{KK} \\ \hline
\rm E  &  \rm E  &  \rm \mathclap{KL} &  \rm \mathclap{KK} & \rm \mathclap{KV} \\
\end{array}$$

其含义为：

$L+L=L$，$L+K=K$，$L+V=V$，$L+E=E$

$K+L=K$，$K+K=V$，$K+V=E$，$K+E=KL$    

$\cdots$

$E+E=KV$    

根据这些规则可推导出：$L=0$，$K=1$，$V=2$，$E=3$。

同时可以确定该表表示的是 $4$ 进制加法。

## 说明/提示

NOIP1998 提高组 第三题

## 样例 #1

### 输入

```
5
+ L K V E
L L K V E
K K V E KL
V V E KL KK
E E KL KK KV
```

### 输出

```
L=0 K=1 V=2 E=3
4
```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何根据给定的加法表确定进制和每个字母代表的数字展开。大部分题解先证明了进制为字母数量减 1（即 $n - 1$ 进制），且每行两位数的个数就是该行对应字母代表的数字这两个关键结论，再据此进行字母与数字的映射，最后检查加法表是否合法。部分题解采用枚举全排列或 dfs 暴力枚举的方式来寻找满足条件的解。

### 所选题解
- **作者：Llf0703（5 星）**
    - **关键亮点**：思路清晰，先给出结论并进行严格证明，代码实现简洁高效，注释详细，便于理解。
- **作者：HappyJaPhy（4 星）**
    - **关键亮点**：对 Llf0703 题解的证明过程进行完善，使证明更加严谨，适合入门者学习。
- **作者：GoldenCreeper（4 星）**
    - **关键亮点**：结论明确，证明过程详细，代码实现逻辑清晰，通过预处理和转换十进制的方式判断解的合法性。

### 重点代码与核心实现思想
#### Llf0703 的核心代码
```cpp
inline bool check(int x,int y) //检验 (x,y)
{
    int sum=ans[x]+ans[y]; //和
    int cur=s[x][y][1]-'A'; //处理十位
    if (sum>=n-1 && mp[cur]!=1) return 0; //如果和 >=n-1 但没有进位
    if (sum>=n-1) sum-=n-1,cur=s[x][y][2]-'A'; //处理个位
    if (mp[cur]!=sum) return 0; //不相等
    return 1;
}

signed main()
{
    n=read();
    for (int j=1;j<=n;j++) scanf("%s",s[1][j]+1);
    for (int i=2;i<=n;i++)
    {
        int cnt=0;
        for (int j=1;j<=n;j++)
        {
            scanf("%s",s[i][j]+1);
            cnt+=strlen(s[i][j]+1)>=2;
        }
        ans[i]=cnt;
        mp[s[i][1][1]-'A']=cnt;
    }
    for (int i=2;i<=n;i++) for (int j=2;j<=n;j++) if (!check(i,j)) return 0&puts("ERROR!");
    for (int i=2;i<=n;i++) printf("%c=%d ",s[i][1][1],ans[i]);
    return !printf("\n%d",n-1);
}
```
**核心实现思想**：先读取输入，统计每行两位数的个数作为该行对应字母代表的数字，存储在 `ans` 数组中，并建立字母与数字的映射 `mp`。然后通过 `check` 函数检查加法表是否合法，若不合法则输出 `ERROR!`，否则输出每个字母对应的数字和进制。

#### HappyJaPhy 的核心代码
```cpp
bool add(int a, int b) {
    int sum = S[a] + S[b], ch = str[a][b][0] - 'A' + 1; //计算加和，取第一位
    if (sum >= n - 1) { //有进位时，高位一定为1
        if (strlen(str[a][b]) != 2 || mp[1] != ch) {
            return 0; //若str[a][b]不为两位数或者第一位不为1，返回错误
        } else {
            sum -= n - 1; //减掉高位，取低位
            ch = str[a][b][1] - 'A' + 1;
        }
    }
    if (mp[sum] != ch) {
        return 0; //不匹配则返回错误
    }
    return 1;
}

int main() {
    scanf("%d", &n);
    for (int i = 1; i <= n; i++) {
        scanf("%s", str[1][i]);
    }
    int M;
    bool flag = 0;
    for (int i = 2; i <= n; i++) {
        M = 0;
        for (int l = 1; l <= n; l++) {
            scanf("%s", str[i][l]);
            if (strlen(str[i][l]) > 1) {
                M++; //计算两位数个数
            }
        }
        S[i] = M; //记录字母对应数字
        if (flag == 0 && mp[M]) { //查重
            flag = 1;
        }
        mp[M] = str[i][1][0] - 'A' + 1; //记录数字对应字母以查重
    }
    if (flag) { //重复错误
        printf("ERROR!");
        return 0;
    }
    for (int i = 2; i <= n; i++) {
        for (int l = 2; l <= n; l++) {
            if (add(i, l) == 0) { //加起来检验加法表是否匹配
                printf("ERROR!"); //不匹配错误
                return 0;
            }
        }
    }
    for (int i = 2; i <= n; i++) {
        printf("%c=%d ", str[i][1][0], S[i]);
    }
    printf("\n%d", n - 1);
    return 0;
}
```
**核心实现思想**：读取输入后，统计每行两位数的个数作为字母代表的数字，存储在 `S` 数组中，并建立数字与字母的映射 `mp`，同时进行查重。通过 `add` 函数检查加法表是否匹配，若不匹配则输出 `ERROR!`，否则输出结果。

#### GoldenCreeper 的核心代码
```cpp
int find(string x){ // 返回 x 的最后一位未知数的值
    if (x.size() == 2)
        x = x[1];
    for (int i = 1;i <= n;++i)
        if (ans[i].second == x)
            return ans[i].first;
}

void f(int r,int c){ // 把位于 (r,c) 的数转为十进制
    if (a[r][c].size() == 1)
        b[r][c] = find(a[r][c]);
    else
        b[r][c] = n + find(a[r][c]) - 1;
}

int main(){
    cin >> n;   // 读入 && 预处理
    for (int i = 1;i <= n;++i)
        for (int j = 1;j <= n;++j){
            cin >> a[i][j];
            if (j == 1)
                ans[i].second = a[i][j];
            if (a[i][j].size() == 2)
                ans[i].first ++;
        }
    
    for (int i = 1;i <= n;++i)
        for (int j = 1;j <= n;++j)
            f(i,j); 
    
    for (int i = 2;i <= n;++i)
        for (int j = 2;j <= n;++j)
            if (b[i][j] != b[1][j] + b[i][1]){      // 判断是否有解
                cout << "ERROR!";
                return 0;
            }

    for (int i = 2;i <= n;++i)
        cout << ans[i].second << '=' << ans[i].first << " ";
    cout << endl << n-1;
    return 0;
}
```
**核心实现思想**：读取输入并预处理，统计每行两位数的个数作为字母代表的数字，存储在 `ans` 数组中。通过 `find` 函数查找未知数的值，`f` 函数将加法表中的数转换为十进制存储在 `b` 数组中。最后检查 `b` 数组中的值是否满足加法关系，若不满足则输出 `ERROR!`，否则输出结果。

### 最优关键思路或技巧
- **结论推导**：先证明进制为字母数量减 1 以及每行两位数个数与字母代表数字的关系，简化问题求解。
- **映射关系**：使用数组或 `map` 建立字母与数字的映射，方便后续计算和检查。
- **合法性检查**：通过遍历加法表，检查每个加法运算是否满足对应进制的规则，判断解的合法性。

### 可拓展之处
同类型题可能会涉及不同的运算表（如乘法表）或不同的进制规则，解题思路可以类似，先推导关键结论，再建立映射关系，最后检查合法性。类似算法套路包括先分析问题特点得出关键结论，再利用数据结构存储信息，最后进行验证和输出。

### 推荐题目
- P1143 进制转换
- P1604 B进制星球
- P2415 集合求和

### 个人心得摘录与总结
- **作者：_3Zinc_**：表示想了一晚上才理解解题的两个关键结论，强调理解关键结论对解题的重要性。
总结：对于此类有隐藏规律的题目，需要花费时间深入思考，理解关键结论后才能更好地解题。 

---
处理用时：64.59秒
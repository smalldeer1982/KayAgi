# 题目信息

# [NOIP 2000 提高组] 乘积最大

## 题目背景

NOIP2000 提高组 T2

## 题目描述

今年是国际数学联盟确定的“2000——世界数学年”，又恰逢我国著名数学家华罗庚先生诞辰 90 周年。在华罗庚先生的家乡江苏金坛，组织了一场别开生面的数学智力竞赛的活动，你的一个好朋友 XZ 也有幸得以参加。活动中，主持人给所有参加活动的选手出了这样一道题目：


设有一个长度为 $N$ 的数字串，要求选手使用 $K$ 个乘号将它分成 $K+1$ 个部分，找出一种分法，使得这 $K+1$ 个部分的乘积能够为最大。


同时，为了帮助选手能够正确理解题意，主持人还举了如下的一个例子：


有一个数字串：$312$，当 $N=3,K=1$ 时会有以下两种分法：

1. $3  \times  12=36$ 
2. $31  \times   2=62$  

   
这时，符合题目要求的结果是：$31  \times  2 = 62$。


现在，请你帮助你的好朋友 XZ 设计一个程序，求得正确的答案。


## 说明/提示

**数据范围与约定**

对于 $60\%$ 的测试数据满足 $6≤N≤20$。  
对于所有测试数据，$6≤N≤40,1≤K≤6$。


## 样例 #1

### 输入

```
4 2
1231
```

### 输出

```
62```

# AI分析结果

### 综合分析与结论
这些题解主要围绕“乘积最大”问题展开，解题方法主要分为动态规划（DP）和深度优先搜索（DFS）两类。由于数字串长度可达 40 位，所有题解都意识到需要使用高精度算法来处理大数字。

动态规划类题解通过定义状态和状态转移方程，逐步计算出最大乘积；深度优先搜索类题解则通过枚举乘号插入位置，不断尝试所有可能的分法，同时使用剪枝策略减少不必要的计算。

### 所选题解
- **作者：liar_white（5星）**
    - **关键亮点**：思路清晰，使用结构体存储高精度数组，代码注释详细，易于理解。通过数组 `cut[i][j]` 存储在第 `i` 个数字后放第 `j` 个乘号时，前 `i` 个数的乘积的最大值，最后比较所有可能的结果得到最大值。
    - **个人心得**：作者表示写这道题用了半上午，还调侃写完注释感觉像白痴代码，但也体现了其对题目的深入思考和认真态度。
- **作者：FastIO_DP（4星）**
    - **关键亮点**：使用动态规划，通过自定义 `BI` 结构体实现高精度运算，重载了乘法和比较运算符，代码结构清晰，复杂度分析明确。
- **作者：kuaiCreator（4星）**
    - **关键亮点**：详细阐述了划分型动态规划的思路，包括状态定义、子问题分解、初始化、计算顺序等，还给出了不带高精度的代码示例，便于理解。

### 重点代码
#### liar_white 的核心代码
```cpp
// 取数操作
node culc(int l,int r){
    node e;
    e.v=r-l+1;e.exi=true;
    for(int i=1;i<=e.v;i++){
        e.c[i]=a[r-i+1];
    }    
    return e;
}
// 高精度乘法
node mul(node e1,node e2){
    node emul;
    emul.exi=true;emul.v=e1.v+e2.v-1;
    for(int i=1;i<=emul.v;i++) emul.c[i]=0;
    for(int i=1;i<=e1.v;i++)
        for(int j=1;j<=e2.v;j++)
            emul.c[i+j-1]+=e1.c[i]*e2.c[j];
    int q=0;        
    for(int i=1;i<=emul.v;i++){
        emul.c[i]+=q;
        q=emul.c[i]/10;
        emul.c[i]%=10;
    }
    while(q>0){
        emul.c[++emul.v]=q%10;
        q/=10;
    }
    return emul;
}
// 高精度比较
node Max(node e1,node e2){
    if(!e1.exi||e1.v<e2.v) return e2;
    if(!e2.exi||e2.v<e1.v) return e1;
    for(int i=e1.v;i>=1;i--){
        if(e1.c[i]>e2.c[i]) return e1;
        else if(e2.c[i]>e1.c[i]) return e2;
    }
    return e1;
}
```
**核心实现思想**：`culc` 函数将连续的数字转换为高精度数；`mul` 函数实现高精度乘法；`Max` 函数比较两个高精度数的大小。

#### FastIO_DP 的核心代码
```cpp
struct BI {
    int d[100];
    int len;

    BI() {
        memset(d, 0, sizeof(d));
        len = 0;
    }
    BI(const string& s) {
        memset(d, 0, sizeof(d));
        len = s.size();
        for (int i = 0; i < len; ++i) {
            d[i] = s[len - 1 - i] - '0';
        }
    }

    string toStr() const {
        string s;
        for (int i = len - 1; i >= 0; --i) {
            s += to_string(d[i]);
        }
        return s;
    }

    BI operator*(const BI& o) const {
        BI res;
        for (int i = 0; i < len; ++i) {
            int c = 0;
            for (int j = 0; j < o.len; ++j) {
                int p = d[i] * o.d[j] + res.d[i + j] + c;
                res.d[i + j] = p % 10;
                c = p / 10;
            }
            if (c) {
                res.d[i + o.len] += c;
            }
        }
        res.len = len + o.len;
        while (res.len > 1 && res.d[res.len - 1] == 0) {
            res.len--;
        }
        return res;
    }

    bool operator<(const BI& o) const {
        if (len != o.len) {
            return len < o.len;
        }
        for (int i = len - 1; i >= 0; --i) {
            if (d[i] != o.d[i]) {
                return d[i] < o.d[i];
            }
        }
        return false;
    }
};
```
**核心实现思想**：通过 `BI` 结构体封装高精度数，重载乘法和比较运算符，方便进行高精度运算和比较。

#### kuaiCreator 的核心代码
```cpp
for (int i = 1; i <= n; i++)          //把字符串第i至第j个位置的子串转换为整数
    for (int j = i; j <= n; j++)
        num[i][j] = num[i][j - 1] * 10 + str[j] - '0';

memset(dp, 0, sizeof(dp));
for (int i = 1; i <= n; i++)          //初始化边界状态
    dp[i][0] = num[1][i]; 

for (int i = 1; i <= n; i++)
    for (int j = 1; j <= m; j++) {     //j<i表示i个数最多插入i-1个乘号
        if (j >= i) break;  //前i个元素不能被插入j个隔板分成j+1份
        for (int k = j; k < i; k++)    //前k个元素最多插入j-1个符号故k从j开始枚举
            dp[i][j] = max(dp[i][j], dp[k][j - 1] * num[k + 1][i]);
    }
```
**核心实现思想**：先将字符串的子串转换为整数存储在 `num` 数组中，然后初始化边界状态 `dp[i][0]`，最后通过三层循环根据状态转移方程更新 `dp` 数组。

### 最优关键思路或技巧
- **动态规划**：通过定义合适的状态和状态转移方程，将问题分解为子问题，逐步求解。
- **高精度算法**：使用结构体或数组存储大数字，模拟手工计算的过程进行乘法和比较运算。
- **剪枝策略**：在深度优先搜索中，通过可行性剪枝减少不必要的计算，提高效率。

### 可拓展之处
同类型题或类似算法套路包括：
- 其他划分型动态规划问题，如将一个序列分成若干段，求每段的某种最优值。
- 涉及大数字运算的问题，如大数加法、减法、除法等，都需要使用高精度算法。

### 推荐题目
- [P1005 [NOIP2007 提高组] 矩阵取数游戏](https://www.luogu.com.cn/problem/P1005)
- [P1040 [NOIP2003 提高组] 加分二叉树](https://www.luogu.com.cn/problem/P1040)
- [P1131 [ZJOI2007] 时态同步](https://www.luogu.com.cn/problem/P1131)

### 个人心得总结
liar_white 表示写这道题用了半上午，反映出该题有一定难度，需要花费时间去思考和调试。但通过详细的注释，也体现了其对题目的深入理解和认真态度，有助于后续学习和回顾。

---
处理用时：58.67秒
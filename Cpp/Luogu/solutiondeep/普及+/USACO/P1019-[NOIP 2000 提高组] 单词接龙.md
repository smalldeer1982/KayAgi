# 题目信息

# [NOIP 2000 提高组] 单词接龙

## 题目背景

注意：本题为上古 NOIP 原题，不保证存在靠谱的做法能通过该数据范围下的所有数据。

本题为搜索题，本题不接受 hack 数据。[关于此类题目的详细内容](https://www.luogu.com.cn/paste/isdgwj5l)

NOIP2000 提高组 T3

## 题目描述

单词接龙是一个与我们经常玩的成语接龙相类似的游戏，现在我们已知一组单词，且给定一个开头的字母，要求出以这个字母开头的最长的“龙”（每个单词都最多在“龙”中出现两次），在两个单词相连时，其重合部分合为一部分，例如 `beast` 和 `astonish`，如果接成一条龙则变为 `beastonish`，另外相邻的两部分不能存在包含关系，例如 `at` 和 `atide` 间不能相连。


## 说明/提示

样例解释：连成的“龙”为 `atoucheatactactouchoose`。

$n \le 20$。

## 样例 #1

### 输入

```
5
at
touch
cheat
choose
tact
a
```

### 输出

```
23
```

# AI分析结果

### 综合分析与结论
这两道题解均采用深度优先搜索（DFS）算法解决单词接龙问题。思路都是从以指定字母开头的单词开始，通过 DFS 枚举所有可能的单词连接情况，同时使用数组记录每个单词的使用次数，确保不超过 2 次。主要难点在于处理单词连接时的重合部分，两个题解都通过枚举重合长度来解决。

### 题解评分
- **RyanLi**：4 星。思路清晰，代码简洁，直接实现了 DFS 搜索，且对截取字串的边界问题有提示。
- **SuyctidohanQ**：3 星。思路正确，但代码中包含大量不必要的宏定义和模板代码，影响了代码的可读性。

### 所选题解
- **RyanLi（4 星）**
  - **关键亮点**：思路清晰，代码简洁，对截取字串的边界问题有提示。

### 重点代码及核心实现思想
```cpp
// RyanLi 的核心代码
void dfs(const string &tmp) {
    ans = max(ans, int(tmp.size()));
    for (int i = 1; i <= n; ++i) {
        if (vis[i] >= 2) continue;
        for (int j = 1; j < min(tmp.size(), s[i].size()); ++j)
            if (tmp.substr(tmp.size() - j) == s[i].substr(0, j)) {
                ++vis[i];
                dfs(tmp + s[i].substr(j));
                --vis[i];
            }
    }
}
```
**核心实现思想**：`dfs` 函数以当前的单词串 `tmp` 为参数，首先更新最大长度 `ans`。然后遍历所有单词，若该单词使用次数未超过 2 次，则枚举重合长度 `j`，若重合部分相等，则将该单词接上，继续进行 DFS 搜索，搜索完成后回溯。

### 最优关键思路或技巧
- 使用深度优先搜索（DFS）枚举所有可能的单词连接情况。
- 使用数组记录每个单词的使用次数，确保每个单词最多使用 2 次。
- 在处理单词连接时，通过枚举重合长度来确定重合部分。

### 可拓展之处
同类型题或类似算法套路：
- 字符串拼接问题，如给定多个字符串，要求拼接成满足特定条件的最长字符串。
- 图的深度优先搜索问题，如在图中寻找满足特定条件的最长路径。

### 推荐题目
- [P1135 奇怪的电梯](https://www.luogu.com.cn/problem/P1135)
- [P1605 迷宫](https://www.luogu.com.cn/problem/P1605)
- [P2392 kkksc03考前临时抱佛脚](https://www.luogu.com.cn/problem/P2392)

### 个人心得
题解中未包含个人心得。

---
处理用时：19.60秒
# 题目信息

# [NOIP 2001 提高组] Car 的旅行路线

## 题目描述

又到暑假了，住在城市 A 的 Car 想和朋友一起去城市旅游。  
她知道每个城市都有 $4$ 个飞机场，分别位于一个矩形的 $4$ 个顶点上，同一个城市中两个机场之间有一条笔直的高速铁路，第 $i$ 个城市中高速铁路的单位里程价格为 $T_i$，任意两个不同城市的机场之间均有航线，所有航线单位里程的价格均为 $t$。


![](https://cdn.luogu.com.cn/upload/image_hosting/odqxn9sz.png)

**注意**：图中并没有标出所有的铁路与航线。


那么 Car 应如何安排到城市 B 的路线才能尽可能的节省花费呢？她发现这并不是一个简单的问题，于是她来向你请教。


找出一条从城市 A 到 B 的旅游路线，出发和到达城市中的机场可以任意选取，要求总的花费最少。


## 说明/提示

【数据范围】  
对于 $100\%$ 的数据，$1\le n \le 10$，$1\le S \le 100$，$1\le A,B \le S$。

**【题目来源】**

NOIP 2001 提高组第四题

## 样例 #1

### 输入

```
1
3 10 1 3
1 1 1 3 3 1 30
2 5 7 4 5 2 1
8 6 8 8 11 6 3```

### 输出

```
47.5```

# AI分析结果

### 综合分析与结论
这些题解的核心思路都是先根据已知的三个点坐标求出矩形的第四个点坐标，再构建图，最后使用最短路算法来求解从城市 A 到城市 B 的最小花费。不同题解在最短路算法的选择和具体实现细节上有所差异。

### 所选题解
- **作者：_jimmywang_ (赞：58)  ★★★★**
    - **关键亮点**：思路清晰，详细阐述了建图和求最短路的步骤，代码简洁，使用 Floyd 算法解决问题。
- **作者：ShineEternal (赞：18)  ★★★★**
    - **关键亮点**：考虑到 Floyd 算法复杂度可能较高，采用 n 遍堆优化的 Dijkstra 算法，时间复杂度为 $O(n^2log_n)$，并详细说明了预处理的过程。
- **作者：LiJunze0501 (赞：1)  ★★★★**
    - **关键亮点**：同样使用 Floyd 算法，对通过勾股定理求直角点和第四个点坐标的过程解释详细。

### 重点代码
#### _jimmywang_ 的核心代码
```cpp
// 求两点距离
double diss(double x1,double y1,double x2,double y2){return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));}
double ds(double x1,double y1,double x2,double y2){return (x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);}
// 主函数部分
while(TTT--){
    memset(dis,0,sizeof(dis)),ans=inf;
    scanf("%lld%lf%lld%lld",&s,&t,&A,&B);
    f(i,1,s){
        scanf("%lf%lf%lf%lf%lf%lf%lf",&x[(i-1)*4+1],&y[(i-1)*4+1],&x[(i-1)*4+2],&y[(i-1)*4+2],&x[(i-1)*4+3],&y[(i-1)*4+3],&T[i]);
        double dab=ds(x[(i-1)*4+1],y[(i-1)*4+1],x[(i-1)*4+2],y[(i-1)*4+2]);
        double dac=ds(x[(i-1)*4+1],y[(i-1)*4+1],x[(i-1)*4+3],y[(i-1)*4+3]);
        double dbc=ds(x[(i-1)*4+2],y[(i-1)*4+2],x[(i-1)*4+3],y[(i-1)*4+3]);
        if(dab+dac==dbc)x[i*4]=x[(i-1)*4+2]+x[(i-1)*4+3]-x[(i-1)*4+1],y[i*4]=y[(i-1)*4+2]+y[(i-1)*4+3]-y[(i-1)*4+1];else
        if(dab+dbc==dac)x[i*4]=x[(i-1)*4+1]+x[(i-1)*4+3]-x[(i-1)*4+2],y[i*4]=y[(i-1)*4+1]+y[(i-1)*4+3]-y[(i-1)*4+2];else
        if(dbc+dac==dab)x[i*4]=x[(i-1)*4+2]+x[(i-1)*4+1]-x[(i-1)*4+3],y[i*4]=y[(i-1)*4+2]+y[(i-1)*4+1]-y[(i-1)*4+3];
    }
    f(i,1,s*4)f(j,1,s*4)if(i!=j){
            if((i-1)/4!=(j-1)/4)dis[i][j]=t*diss(x[i],y[i],x[j],y[j]);
            else dis[i][j]=T[(i-1)/4+1]*diss(x[i],y[i],x[j],y[j]);
        }
    f(k,1,s*4)f(i,1,s*4)f(j,1,s*4)dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]);
    f(i,1,4)f(j,1,4)ans=min(ans,dis[(A-1)*4+i][(B-1)*4+j]);
    printf("%.1lf\n",ans);
}
```
**核心实现思想**：先根据勾股定理判断哪两个点构成对角线，求出矩形的第四个点坐标。然后根据点是否在同一城市，计算两点间的距离和花费，构建图。最后使用 Floyd 算法求最短路，找出城市 A 到城市 B 的最小花费。

#### ShineEternal 的核心代码
```cpp
// 求第四个点坐标
void find(double a,double b,double c,double d,double e,double f)
{
    cnt++;
    dis[1].num=sqrt(Sqr(a-c)+Sqr(b-d)); 
    dis[1].id=1;
    dis[2].num=sqrt(Sqr(e-c)+Sqr(f-d)); 
    dis[2].id=2;
    dis[3].num=sqrt(Sqr(a-e)+Sqr(b-f));
    dis[3].id=3;
    sort(dis+1,dis+4,cmp);
    if(dis[1].id==1)
    {
        double x=min(a,c)+Abs(a-c)/2;
        double y=min(b,d)+Abs(b-d)/2;
        double xn=x+x-e;
        double yn=y+y-f;
        p[cnt].x=xn;
        p[cnt].y=yn;
    }
    if(dis[1].id==2)
    {
        double x=min(c,e)+Abs(e-c)/2;
        double y=min(f,d)+Abs(f-d)/2;
        double xn=x+x-a;
        double yn=y+y-b;
        p[cnt].x=xn;
        p[cnt].y=yn;
    }
    if(dis[1].id==3)
    {
        double x=min(a,e)+Abs(a-e)/2;
        double y=min(b,f)+Abs(b-f)/2;
        double xn=x+x-c;
        double yn=y+y-d;
        p[cnt].x=xn;
        p[cnt].y=yn;
    }
}
// Dijkstra 算法
void dijkstra(int s)
{
    memset(vis,0,sizeof(vis));
    d[s][s]=0;
    q.push(make_pair(0,s));
    while(!q.empty())
    {
        int x=q.top().second;
        q.pop();
        if(vis[x]==1)
        continue;
        vis[x]=1;
        for(int i=1;i<=cnt;i++)
        {
            if(d[s][x]+dist[x][i]<d[s][i])
            {
                d[s][i]=d[s][x]+dist[x][i];
                q.push(make_pair(d[s][i],i));
            }
        }
    }
}
```
**核心实现思想**：通过找出距离最远的两个点，取中点，再根据中点和另一个点求出第四个点坐标。使用堆优化的 Dijkstra 算法求最短路。

#### LiJunze0501 的核心代码
```cpp
// 求第四个机场的坐标
void getair4(int id){
    double d12=pf(air[4*(id-1)+1].x-air[4*(id-1)+2].x)+pf(air[4*(id-1)+1].y-air[4*(id-1)+2].y);
    double d23=pf(air[4*(id-1)+2].x-air[4*(id-1)+3].x)+pf(air[4*(id-1)+2].y-air[4*(id-1)+3].y);
    double d13=pf(air[4*(id-1)+1].x-air[4*(id-1)+3].x)+pf(air[4*(id-1)+1].y-air[4*(id-1)+3].y);
    if(d12+d13==d23){//1是直角点
        air[4*id].x=air[4*(id-1)+2].x+air[4*(id-1)+3].x-air[4*(id-1)+1].x;
        air[4*id].y=air[4*(id-1)+2].y+air[4*(id-1)+3].y-air[4*(id-1)+1].y;	
    }
    if(d12+d23==d13){//2是直角点
        air[4*id].x=air[4*(id-1)+1].x+air[4*(id-1)+3].x-air[4*(id-1)+2].x;
        air[4*id].y=air[4*(id-1)+1].y+air[4*(id-1)+3].y-air[4*(id-1)+2].y;	
    }
    if(d23+d13==d12){//3是直角点
        air[4*id].x=air[4*(id-1)+1].x+air[4*(id-1)+2].x-air[4*(id-1)+3].x;
        air[4*id].y=air[4*(id-1)+1].y+air[4*(id-1)+2].y-air[4*(id-1)+3].y;	
    }
}
// Floyd 算法
for(int k=1;k<=4*s;k++)
    for(int i=1;i<=4*s;i++)
        for(int j=1;j<=4*s;j++)
            if(i!=j&&j!=k&&i!=k) cost[i][j]=min(cost[i][j],cost[i][k]+cost[k][j]);
```
**核心实现思想**：通过勾股定理判断直角点，求出第四个点坐标。使用 Floyd 算法求最短路。

### 最优关键思路或技巧
- **利用几何性质求矩形第四个点坐标**：根据矩形对角线互相平分的性质，结合勾股定理判断哪两个点构成对角线，从而求出第四个点的坐标。
- **合理编号**：对机场进行合理编号，方便判断两个机场是否在同一城市，简化建图过程。
- **选择合适的最短路算法**：根据数据范围选择合适的最短路算法，如本题数据范围较小，可使用 Floyd 算法；若数据范围较大，可考虑使用堆优化的 Dijkstra 算法。

### 可拓展之处
同类型题或类似算法套路：
- **多源多汇最短路问题**：起点和终点都有多个选择，可参考本题的处理方法，枚举所有起点和终点的组合，求出最小花费。
- **图的构建与预处理**：在一些问题中，需要根据题目条件构建图，并进行预处理，如本题根据机场的位置和城市信息构建图。

### 推荐题目
- [P1119 灾后重建](https://www.luogu.com.cn/problem/P1119)：涉及 Floyd 算法的动态更新。
- [P3371 【模板】单源最短路径（弱化版）](https://www.luogu.com.cn/problem/P3371)：考察 Dijkstra 算法。
- [P4779 【模板】单源最短路径（标准版）](https://www.luogu.com.cn/problem/P4779)：考察堆优化的 Dijkstra 算法。

### 个人心得
- **ShineEternal**：“刚开始我是以一个城市为一个结构体，然后就特别难写，最后只好重构代码”，总结为在选择数据结构存储信息时要谨慎，合理的数据结构能简化代码实现。 

---
处理用时：77.49秒
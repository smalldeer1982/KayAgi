# 题目信息

# [NOIP 2005 普及组] 校门外的树

## 题目描述

某校大门外长度为 $l$ 的马路上有一排树，每两棵相邻的树之间的间隔都是 $1$ 米。我们可以把马路看成一个数轴，马路的一端在数轴 $0$ 的位置，另一端在 $l$ 的位置；数轴上的每个整数点，即 $0,1,2,\dots,l$，都种有一棵树。


由于马路上有一些区域要用来建地铁。这些区域用它们在数轴上的起始点和终止点表示。已知任一区域的起始点和终止点的坐标都是整数，区域之间可能有重合的部分。现在要把这些区域中的树（包括区域端点处的两棵树）移走。你的任务是计算将这些树都移走后，马路上还有多少棵树。



## 说明/提示

**【数据范围】**

- 对于 $20\%$ 的数据，保证区域之间没有重合的部分。
- 对于 $100\%$ 的数据，保证 $1 \leq l \leq 10^4$，$1 \leq m \leq 100$，$0 \leq u \leq v \leq l$。

**【题目来源】**

NOIP 2005 普及组第二题

## 样例 #1

### 输入

```
500 3
150 300
100 200
470 471
```

### 输出

```
298```

# AI分析结果

### 综合分析与结论
这些题解主要围绕计算移走指定区域树木后剩余树木数量展开，根据数据范围不同采用了多种方法。大部分题解采用暴力模拟，通过数组标记树木是否被移走，时间复杂度为 $O(lm)$；部分题解使用了线段树、差分、区间合并等优化算法。暴力模拟简单直观，适合数据范围较小的情况；线段树、差分等方法在处理大规模数据时更具优势。

### 所选题解
- **ChargeDonkey（5星）**
    - **关键亮点**：思路清晰，代码简洁易懂，通过三遍循环实现，先标记所有树为未访问，再标记区间内的树为已访问，最后统计未访问的树的数量。
- **Christopher_Yan（4星）**
    - **关键亮点**：使用线段树解决问题，适合线段树初学者练习，详细解释了 lazytag 的下推过程。
- **ziyisama（4星）**
    - **关键亮点**：提供了多种思路，包括暴力、差分和区间合并，对不同算法的复杂度进行了分析。

### 重点代码及核心思想
#### ChargeDonkey
```cpp
int vis[10000+10];
int main()
{
    memset(vis,0,sizeof(vis));
    cin>>L>>M;
    for(int i=0;i<=L;i++)
        vis[i]=0;
    for(int i=1;i<=M;i++)
    {
        int head,tail;
        cin>>head>>tail;
        for(int j=head;j<=tail;j++)
            if(vis[j]==0)
                vis[j]=1;
    }
    for(int i=0;i<=L;i++)
    {
        if(vis[i]==0)
            cnt++;
    }
    cout<<cnt<<endl;
    return 0;
} 
```
核心思想：通过数组标记树木是否被访问，遍历区间标记访问状态，最后统计未访问的树木数量。

#### Christopher_Yan
```cpp
struct SegTree{
    int l;
    int r;
    long long w;
    int lt;
    int add;
    int mul;
    SegTree() {lt=1;}
}tree[MAXN<<2];

inline void build(int l,int r,int u)
{
    tree[u].l=l,tree[u].r=r;
    if(l==r) {tree[u].w=1;return;}
    int m=(l+r)/2;
    build(l,m,u+u);
    build(m+1,r,u+u+1);
    tree[u].w=tree[u+u].w+tree[u+u+1].w;
}

inline void down(int u)
{
    tree[u+u].lt=tree[u].lt;
    tree[u+u+1].lt=tree[u].lt;
    tree[u+u].w=tree[u].lt;
    tree[u+u+1].w=tree[u].lt;
    tree[u].lt=1;
}

inline void change(int u)
{
    if(tree[u].l>=x&&tree[u].r<=y)
    {
        tree[u].w=0;
        tree[u].lt=0;
        return;
    }
    if(tree[u].lt!=1) down(u);
    int m=(tree[u].l+tree[u].r)/2;
    if(x<=m) change(u+u);
    if(y>m) change(u+u+1);
    tree[u].w=tree[u+u+1].w+tree[u+u].w;
}
```
核心思想：使用线段树维护区间和，通过 lazytag 优化区间修改操作，最后输出整个线段树的节点值之和。

#### ziyisama
```cpp
pair<int, int> p[105];
bool cmp(pair<int,int> a, pair<int, int> b) {
    return a.first < b.first;
}
int main()
{
    int L, n;
    cin >> L >> n;
    for (int i = 1; i <= n; i++) {
        scanf("%d %d", &p[i].first, &p[i].second);
        if (p[i].first < 0) p[i].first = 0;
        if (p[i].second > L)p[i].second = L;
    }
    sort(p + 1, p + 1 + n, cmp);
    int cnt = 0;
    int ml=p[1].first, mr = p[1].second;
    for (int i = 2; i <= n; i++) {
        int l = p[i].first, r = p[i].second;
        if (l <= mr) {
            mr = max(mr, r);
        }
        else if (l > mr) {
            cnt += (mr + 1 - ml);
            ml = l, mr = r;
        }
    }
    cnt += (mr + 1 - ml);
    cout << L + 1- cnt << endl;
    return 0;
}
```
核心思想：将区间按左端点排序，合并重叠区间，计算被砍树木的数量，用总数减去被砍数量得到剩余树木数量。

### 最优关键思路或技巧
- **数组标记**：使用数组标记树木是否被移走，简单直观，适合小规模数据。
- **线段树**：利用线段树的区间修改和查询功能，通过 lazytag 优化时间复杂度，适合大规模数据。
- **差分**：差分是前缀和的逆运算，可在 $O(1)$ 时间内实现区间操作，最后通过前缀和还原数组。
- **区间合并**：将重叠区间合并，减少重复计算，提高效率。

### 可拓展之处
同类型题如区间覆盖、区间修改等问题，可使用线段树、差分、区间合并等算法解决。类似算法套路包括使用标记数组、前缀和、后缀和等优化区间操作。

### 推荐题目
- [P1803 凌乱的yyy / 线段覆盖](https://www.luogu.com.cn/problem/P1803)
- [P3372 【模板】线段树 1](https://www.luogu.com.cn/problem/P3372)
- [P3368 【模板】树状数组 2](https://www.luogu.com.cn/problem/P3368)

### 个人心得
本题解中未包含个人心得。

---
处理用时：49.26秒
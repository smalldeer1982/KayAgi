# 题目信息

# 约瑟夫

## 题目描述

$n$ 个人站成一圈，从某个人开始数数，每次数到 $m$ 的人就被杀掉，然后下一个人重新开始数，直到最后只剩一个人。现在有一圈人，$k$ 个好人站在一起，$k$ 个坏人站在一起。从第一个好人开始数数。你要确定一个最小的 $m$，使得在第一个好人被杀死前，$k$ 个坏人先被杀死。


## 说明/提示

$0\lt k\lt 14$。

## 样例 #1

### 输入

```
3```

### 输出

```
5```

## 样例 #2

### 输入

```
4```

### 输出

```
30```

# AI分析结果

### 综合分析与结论
这些题解主要围绕约瑟夫问题展开，目标是找到最小的 $m$ 使得 $k$ 个坏人先被杀死，而第一个好人不被杀。各题解思路大致可分为暴力枚举、打表和链表模拟三种。暴力枚举是主流方法，通过不断尝试不同的 $m$ 值，模拟杀人过程来判断是否满足条件；打表则是提前计算好结果，直接输出；链表模拟利用链表的删除操作来模拟杀人过程。

### 所选题解
- **作者：doby（4星）**
  - 关键亮点：思路清晰，代码简洁，通过函数 `check` 来判断每次出列的人是否为坏人，逐步枚举 $m$ 值。
  - 核心代码：
```cpp
int check(int remain)
{
    int result=(begin+m-1)%remain;
    if(result>=k){//判断出列的那个人
        begin=result;
        return 1;
    }
    else{return 0;}
}
int main(){
    scanf("%ld",&k);
    m=k;
    while(!find)
     {
        find=1;begin=0;//设置第一个
        for(i=0;i<k;i++)
        {
            if(!check(2*k-i))//如果判断好，就可以退出了……
            {
                find=0;break;
            }
        }
        m++;
    }
    printf("%d",m-1);//多加了一个，减回去
    return 0;
}
```
核心实现思想：通过 `check` 函数计算出列的人的编号，判断是否为坏人。在 `main` 函数中不断枚举 $m$ 值，直到找到满足条件的 $m$。

- **作者：归来的圣主（4星）**
  - 关键亮点：代码精简，从 `doby` 的题解得到启发并改进，同样是暴力枚举 $m$ 值，通过游标来模拟杀人过程。
  - 核心代码：
```c
int main()
{
    int k,i;
    while (scanf("%d",&k)!=EOF)//个人输入习惯，请忽略
    {
        int flag=1,m=k;
        while (flag)
        {
            m++;//m至少为k+1
            int cursor=0;//设置光标的移动
            for (i=0; i<k; i++)
            {
                cursor=(cursor+m-1)%(2*k-i);//下一次出列之人的编号
                if (cursor<k)break;//判断出列的那个人是否小于k，小于就进行下一个m的判断
                if (i==k-1)flag=0;//说明已经找到最小的m
            }
        }
        printf("%d\n",m);
    }
    return 0;
}
```
核心实现思想：使用游标 `cursor` 来记录下一个出列的人的编号，通过取模运算模拟循环。不断枚举 $m$ 值，直到找到满足条件的 $m$。

- **作者：夜枭只会舔fufu（4星）**
  - 关键亮点：采用打表的方法，直接输出结果，时间复杂度为 $O(1)$，效率极高。
  - 核心代码：
```cpp
int num[14]={0,2,7,5,30,169,441,1872,7632,1740,93313,459901,1358657,2504881};//打表
int n;//几个好人几个坏人
int main(){
    cin>>n;//输入n
    cout<<num[n]<<endl;//按表输出
    return 0;//完结撒花
}
```
核心实现思想：提前计算好所有可能的结果并存储在数组中，输入 $k$ 后直接输出对应的结果。

### 最优关键思路或技巧
- **取模运算**：在模拟杀人过程中，使用取模运算可以方便地处理循环问题，避免数组越界。
- **打表**：对于数据范围较小的问题，打表可以大大提高效率，将时间复杂度从 $O(n)$ 降低到 $O(1)$。

### 可拓展之处
同类型题如普通的约瑟夫问题，只是规则可能不同，如每次数到不同的数字杀人，或者从不同的位置开始数等。类似算法套路都是模拟杀人过程，通过取模运算处理循环。

### 推荐洛谷题目
- P1996 约瑟夫问题
- P4391 [BOI2007]Mokia 摩基亚
- P1629 邮递员送信

### 个人心得摘录与总结
- **InternetExplorer**：提到自己是第一次写题解，可能讲得不清楚，但希望管理员通过。总结：新手写题解可能存在表达不清晰的问题，需要不断练习和提高。
- **SampleTest518**：指出正解是暴力，稍微优化就能过，最朴素的暴力很慢，正确方法是直接取模。总结：在解决问题时，要善于对暴力算法进行优化，提高效率。

---
处理用时：39.64秒
# 题目信息

# 打保龄球

## 题目描述

打保龄球是用一个滚球去打击十个站立的柱，将柱击倒。一局分十轮，每轮可滚球一次或多次，以击倒的柱数为依据计分。一局得分为十轮得分之和，而每轮的得分不仅与本轮滚球情况有关，还可能与后续一两轮的滚球情况有关。即某轮某次滚球击倒的柱数不仅要计入本轮得分，还可能会计入前一两轮得分。具体的滚球击柱规则和计分方法如下：

1. 若某一轮的第一次滚球就击倒全部十个柱，则本轮不再滚球（若是第十轮则还需另加两次滚球，不妨称其为第十一轮和第十二轮，并不是所有的情况都需要滚第十一轮和第十二轮球）。该轮得分为本次击倒柱数 $10$ 与以后两次滚球所击倒柱数之和。

2. 若某一轮的第一次滚球未击倒十个柱，则可对剩下未倒的柱再滚球一次。如果这两次滚球击倒全部十个柱，则本轮不再滚球（若是第十轮则还需另加一次滚球），该轮得分为这两次共击倒柱数 $10$ 与以后一次滚球所击倒柱数之和。

3. 若某一轮两次滚球未击倒全部十个柱，则本轮不再继续滚球，该轮得分为这两次滚球击倒的柱数之和。   

总之，若―轮中一次滚球或两次滚球击倒十个柱，则本轮得分是本轮首次滚球开始的连续三次滚球击倒柱数之和（其中有一次或两次不是本轮滚球）。若一轮内二次滚球击倒柱数不足十个，则本轮得分即为这两次击倒柱数之和。下面以实例说明如下(字符 `/` 表示击倒当前球道上的全部的柱)：

| 轮 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 |
| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: |
| 击球情况  |  /  |  /  |  /  |  72 |  9/ |  81  | 8/  |  / |   9/  |  /  |  8/ |
| 各轮得分 |  30  | 27  | 19 |  9   |18   | 9  | 20  | 20 |  20 |  20|
|累计总分 |  30  | 57  |76 |  85|  103 |  112 | 132  |152 | 172 | 192|

现在请你编写一个保龄球实时计分程序，用来计算和显示某轮结束后的得分情况。若某轮的得分暂时无法算出，则**不显示**该轮得分（不输出）。


## 样例 #1

### 输入

```
/ / / 72 9/ 81 8/ / 9/ / 8/```

### 输出

```
30 27 19 9 18 9 20 20 20 20 
30 57 76 85 103 112 132 152 172 192```

# AI分析结果

### 综合分析与结论
这些题解均围绕保龄球计分规则进行模拟实现。整体思路都是先处理输入，再依据规则计算每轮得分和总分，同时注意处理得分暂时无法算出的情况。各题解在数据存储和处理细节上有所不同，但核心都是模拟滚球和计分过程。

### 所选题解
- **作者：X_WT (赞：24)，4星**
    - **关键亮点**：思路清晰，先将字符转化为分数存储，再通过循环判断得出每轮分数，代码逻辑较为直接，注释详细。
    - **个人心得**：作者表示题解较少且自己一开始看不懂，所以决定发布题解，希望对他人有帮助。
- **作者：袁宇轩 (赞：14)，4星**
    - **关键亮点**：对题意概括清晰，详细指出坑点，思路简洁，通过模拟滚球过程并记录相关信息来计算得分。
    - **个人心得**：强调题目坑点多，光题意就较难理解，提醒注意“若某轮的得分暂时无法算出，则该轮得分不显示”这一条件。
- **作者：Shadow_T (赞：3)，4星**
    - **关键亮点**：准确把握题目要点，模拟过程中对得分无法计算的情况处理得当，代码结构清晰。
    - **个人心得**：指出此题题意难理解，理解后就好做了，强调要注意得分无法算出时的处理。

### 重点代码
#### 作者：X_WT
```cpp
int work(char t){
    if(t=='/')	return 10;
    return t-'0';
}				//将字符转化成分数 
int main(){
    string s;
    getline(cin,s);//输入字符串 
    int ans=0,gro[30]={-1,0,0},sco[30],i,j=1,k=1,a[15]={0},times=1;
    int len=s.length();//解释一下：gro[i]表示第i个数是gro[i]轮的 
    for(i=0;i<30;i++)	sco[i]=-1;//sco[i]表示第i次的分数 ，先全部赋-1 
    for(i=0;i<len;i++){
        if(s[i]==' '){
            continue;		//空格当然不能算在内 
        }
        gro[j]=k;//i，j相互独立，本句表示 gro[j] 属于第多少轮 
        sco[j]=work(s[i]);		//得到分数 
        if(sco[j]==10)	k++;//满分，直接下一轮 
        else if(gro[j]==gro[j-1])	k++;//扔满2次，下一轮 
        if(gro[j]==gro[j-1]&&sco[j]==10)
            sco[j]-=sco[j-1];//第二次为10分时，其成绩改成撞倒的瓶子数而不是10 
        j++;		//下一次扔球 
    }
    int tmp=j;			//扔球次数 
    for(i=1,j=1;i<=tmp;i++){
        if(sco[i]==10){
            if(sco[i+1]==-1||sco[i+2]==-1)	break;	//这句很重要，保证第一次一轮
            a[j++]=sco[i]+sco[i+1]+sco[i+2];		//成绩计算不出时可以结束
            times++;								//times意思是有分数的轮数 
            continue;
        }
        if(gro[i]==gro[i+1]){
            if(sco[i+1]==-1||sco[i+2]==-1)	break;	//同理上面 
            if( (sco[i]+sco[i+1]) ==10 ){
                if(sco[i+2]==-1)	break;
                a[j++]=sco[i]+sco[i+1]+sco[i+2];//表示这轮第一次开始向后，总共3次的成绩之和 
                times++;//为了这边计算方便，我在上面将10换掉 
                i++;continue;//加上循环的i+1,i向后2个
            }
            else{
                a[j++]=sco[i]+sco[i+1];
                times++;i++;//很可惜，没有击倒所有瓶子
            }
        }
    }
    times=min(times,11);//防止额外的轮数和不足10次的轮数 
    for(i=1;i<times;i++)	cout<<a[i]<<' ';
    cout<<endl;
    for(i=1;i<times;i++){
        ans+=a[i];	//得出每一次的总分 
        cout<<ans<<' ';
    }
    return 0;	//华丽结束 
}
```
**核心实现思想**：先将输入的字符转化为分数存储在 `sco` 数组中，同时记录每个分数所属的轮次 `gro` 数组。然后根据规则计算每轮得分存储在 `a` 数组中，最后输出每轮得分和总分。

#### 作者：袁宇轩
```cpp
int main()
{
    while (cin>>a[++n]);//读入 
    int st=1;//每一局的起点 
    for (int i=1;i<=10;i++){
        int rest=10,flag=1;//剩余rest根柱，且没有全部打完 
        for (int j=st;j<=st+2;j++){//枚举三次滚球 
            if (j>n){//如果越界退出 
                sum[i]=-1;
                break;
            }
            if (rest==0) rest=10,flag=0;//全部打完 
            if (j==st+2 && flag) break;//第三种情况，只滚两次 
            if (a[j]=='/') sum[i]+=rest,rest=0;//模拟 
            else if (a[j]>='0' && a[j]<='9') sum[i]+=a[j]-'0',rest-=a[j]-'0';//模拟 
        }
        if (sum[i]==-1) break;//越界 
        if (a[st]=='/') st++;
        else st+=2;//改变st位置 
        writep(sum[i]);
    }
    puts("");
    for (int i=1;i<=10;i++){
        if (sum[i]==-1) break;
        ans+=sum[i];
        writep(ans);
    }
    return 0;
}
```
**核心实现思想**：通过 `st` 记录每轮的起点，模拟三次滚球过程，根据剩余柱数和是否全部打倒的标志 `flag` 来计算每轮得分存储在 `sum` 数组中，最后输出每轮得分和总分。

#### 作者：Shadow_T
```cpp
int main()
{    
    getline(cin,s);
    memset(d,0,sizeof d);
    memset(st,0,sizeof st);
    memset(p1166,0,sizeof(p1166));
    int x=s.length();
    for(int i=0;i<x;i++)
    {         
        if(s[i]==' ') continue;
        if(s[i]=='/')
        {
            p1166[lenz][l]=10-p1166[lenz][l-1];
            st[lenz][l]=true;
            if(l==1)
            { 
                lenz++;
                continue;
            }
        }
        else
        {
            p1166[lenz][l]=s[i]-'0';
            st[lenz][l]=true;
        }
        if(l==2) ++lenz,l=1;
        else ++l;
    }
    lenz--;
    for(int i=1;i<=lenz;i++)
    {
        if(p1166[i][1]==10)
        {
            if(!st[i+1][1]) break;
            if(p1166[i+1][1]==10&&(!st[i+2][1])) break;
            if(p1166[i+1][1]<10&&(!st[i+1][2])) break;
            d[i]=10+p1166[i+1][1];
            if(p1166[i+1][1]==10) d[i]+=p1166[i+2][1];
            else d[i]+=p1166[i+1][2];
        }
        else
        {
            if(!st[i][2]) break;
            if(p1166[i][1]+p1166[i][2]==10&&(!st[i+1][1])) break;
            d[i]=p1166[i][1]+p1166[i][2];
            if(d[i]==10) d[i]+=p1166[i+1][1];
        }
    }
    for(int i=1;i<=lenz;i++)
    {
        if(d[i]==0) break;
        cout<<d[i]<<' ';
    }
    puts("");
    int ans=0;
    for(int i=1;i<=lenz;i++)
    {
        if(d[i]==0) break;
        ans+=d[i];
        cout<<ans<<' ';
    }
}
```
**核心实现思想**：先将输入的字符转化为每轮每次滚球的得分存储在 `p1166` 数组中，同时标记该轮该次是否有滚球 `st` 数组。然后根据规则计算每轮得分存储在 `d` 数组中，最后输出每轮得分和总分。

### 最优关键思路或技巧
- **数据结构**：使用数组存储每轮得分、每次滚球得分以及轮次信息，方便后续计算和处理。
- **模拟过程**：通过循环模拟滚球过程，根据不同情况进行判断和计算，注意处理得分无法计算的情况，如判断后续轮次是否有数据。

### 可拓展之处
同类型题如台球、飞镖等计分模拟题，解题思路类似，都是根据具体规则进行模拟计算。类似算法套路就是仔细分析规则，将其转化为代码逻辑，通过数据结构存储相关信息，再进行模拟计算。

### 推荐题目
- P1067 多项式输出
- P1075 质因数分解
- P1098 字符串的展开

### 个人心得总结
- 多位作者提到题目题意难理解，需要仔细分析规则，注意细节，如得分暂时无法算出的情况。
- 部分作者在调试过程中遇到问题，如击倒柱数可能为0等情况，提醒在实现过程中要考虑全面。 

---
处理用时：77.24秒
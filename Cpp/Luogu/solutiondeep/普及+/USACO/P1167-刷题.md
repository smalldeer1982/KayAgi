# 题目信息

# 刷题

## 题目描述

NOIP 临近了，小 A 却发现他已经不会写题了。好在现在离竞赛还有一段时间，小 A 决定从现在开始夜以继日地刷题。也就是说小 A 废寝忘食，一天二十四小时地刷题。

今天的日期（时间）是 yyyy 年 mm 月 dd 日 hh 时 MM 分，考试的时间是 yyyy2 年 mm2 月 dd2 日 hh2 时 MM2 分。这之间的所有时间小 A 都用来刷题了，那么考试之前他最多能刷多少题呢？注意哦，考虑闰年。

时间紧张小 A 只管数量不管质量。当然有的题目容易一些，有的题目难一些。根据小 A 的经验，他能一眼看出写出某一个题目需要的时间，以分钟记。

现在给出洛谷 Online Judge 的题目列表，请你挑出最多的题目使小A能在竞赛前写出来。

我们假设从远古到未来，历法的表示与现在一样。


## 样例 #1

### 输入

```
2
1
1
2007-06-23-11:59
2007-06-23-12:00```

### 输出

```
1```

# AI分析结果

### 综合分析与结论
本题主要涉及时间计算和贪心算法。各题解的核心思路都是先计算出两个给定时间点之间的总分钟数，再将题目按所需时间从小到大排序，最后贪心选择能在总时间内完成的题目。

时间计算是本题的难点，不同题解采用了不同的方法，如以 0000 年 1 月 1 日 00:00 为基准计算时间差、逐次处理年月日并多退少补等。

### 所选题解
- **作者：傅思维666（4星）**
    - **关键亮点**：思路清晰，详细介绍了日期题的处理技巧，提供了两种计算时间段分钟数的方法，并强调了多退少补的思想，代码可读性较高。
    - **个人心得**：一开始 WA 了两个大数据的点，是因为最后输出的时候，直接在 else 里输出，这样如果是极大数据的话，根本就进不去 else 那里，导致输出为空，请大家引以为戒。
- **作者：ztzshiwo001219（4星）**
    - **关键亮点**：以 0000 年 1 月 1 日 00:00 作为基准点，思路简洁明了，代码实现较为清晰，通过计算开始时间与结束时间相对于基准点的时间差，再进行贪心选择。
- **作者：wangzeyu（4星）**
    - **关键亮点**：手写了一个处理日历相关问题的 class，提高了代码的复用性和可维护性，思路清晰，注释详细。

### 重点代码及核心实现思想
#### 傅思维666
```c++
// 计算时间段分钟数
for(int i=start[1];i<endd[1];i++) {
    if(check(i))
        time+=366;
    else
        time+=365;
}
if(check(start[1]))
    for(int i=1;i<start[2];i++)
        time-=m2[i];
else
    for(int i=1;i<start[2];i++)
        time-=m1[i];
if(check(endd[1]))
    for(int i=1;i<endd[2];i++)
        time+=m2[i];
else
    for(int i=1;i<endd[2];i++)
        time+=m1[i];
for(int i=1;i<start[3];i++)
    time--;
for(int i=1;i<endd[3];i++)
    time++;
time=time*24*60;
time-=60*start[4]+start[5];
time+=60*endd[4]+endd[5];
```
核心思想：先从起始年到终止年累加天数，再根据闰年情况调整起始年和终止年的前几个月的天数，最后处理日、小时和分钟，将总天数转换为分钟数。

#### ztzshiwo001219
```cpp
// 计算相对于基准点的时间
LL calculate() {
    int flag1=pdrn(year1),flag2=pdrn(year2);
    for(int i=0;i<year1;i++)
        if(pdrn(i)) sj1+=366*1440;
        else sj1+=365*1440;
    LL monthtime=0;
    for(int i=month1-1;i;i--) monthtime+=Day[flag1][i]*60*24;
    sj1+=minute1+hour1*60+(day1-1)*60*24+monthtime;
    for(int i=0;i<year2;i++)
        if(pdrn(i)) sj2+=366*1440;
        else sj2+=365*1440;
    monthtime=0;
    for(int i=month2-1;i;i--) monthtime+=Day[flag2][i]*60*24;
    sj2+=minute2+hour2*60+(day2-1)*60*24+monthtime;
    return sj2-sj1;
}
```
核心思想：分别计算开始时间和结束时间相对于 0000 年 1 月 1 日 00:00 的分钟数，然后相减得到时间差。

#### wangzeyu
```C++
// 获取相对于 0000 年 1 月 1 日 0 时 0 分 0 秒的时间（以秒为单位）
unsigned long long getStandardTime(void) {
    unsigned long long res=0ull;
    for(unsigned y=0;y<this->year;y++) {
        if(is_runnian(y)) {
            res+=a_day*366ull;
        } 
        else {
            res+=a_day*365ull;
        }
    }
    for(unsigned m=1;m<this->month;m++) {
        res+=getDaysInMonth(this->year,m)*a_day;
    }
    for(unsigned d=1;d<this->day;d++) {
        res+=a_day;
    }
    for(unsigned h=0;h<this->hour;h++) {
        res+=a_hour;
    }
    for(unsigned m=0;m<this->minute;m++) {
        res+=a_minute;
    }
    res+=this->second;
    return res;
}
```
核心思想：通过 class 封装日历相关操作，计算当前时间相对于 0000 年 1 月 1 日 0 时 0 分 0 秒的秒数。

### 最优关键思路或技巧
- **时间计算**：以 0000 年 1 月 1 日 00:00 为基准点，分别计算开始时间和结束时间相对于基准点的时间，再相减得到时间差，这种方法逻辑清晰，易于实现。
- **多退少补思想**：在计算时间时，逐次处理年月日，对于多计算或未计算的部分进行调整，避免复杂的分类讨论。
- **封装思想**：将日历相关的操作封装在一个 class 中，提高代码的复用性和可维护性。

### 可拓展之处
同类型题或类似算法套路：
- 计算两个日期之间的天数差、周数差等，可使用类似的时间计算方法。
- 涉及资源分配的贪心问题，如背包问题、活动选择问题等，可根据物品的价值或时间等因素进行排序，然后贪心选择。

### 推荐题目
- P1090 [NOIP2004 提高组] 合并果子
- P1223 排队接水
- P1803 凌乱的yyy / 线段覆盖

### 个人心得总结
- **傅思维666**：注意输出的边界条件，避免因数据过大而导致输出为空。
- **Deny_小田**：一分钟一分钟累加的方法效率较低，容易超时，可采用计算时间差的方法。
- **tllwtg**：对于大数据范围的题目，要注意数据类型的选择，避免溢出，同时可使用打表的方法处理特殊数据。

---
处理用时：49.26秒
# 题目信息

# [USACO2.2] 派对灯 Party Lamps

## 题目描述

在 IOI98 的节日宴会上，我们有 $n$ 盏彩色灯，他们分别从 $1 \sim n$ 被标上号码。这些灯都连接到四个按钮：

按钮 $1$：当按下此按钮，将改变所有的灯：本来亮着的灯就熄灭，本来是关着的灯被点亮。

按钮 $2$：当按下此按钮，将改变所有奇数号的灯。

按钮 $3$：当按下此按钮，将改变所有偶数号的灯。

按钮 $4$：当按下此按钮，将改变所有序号是 $3k+1 \ (k \in [0,+\infty) \cap \mathbb Z)$ 的灯。例如：$1,4,7,10 \dots$

一个计数器 $c$ 记录按钮被按下的次数。当宴会开始，所有的灯都亮着，此时计数器 $c$ 为 $0$。

你将得到计数器 $c$ 上的数值和经过若干操作后某些灯的状态。写一个程序去找出所有灯最后可能的与所给出信息相符的状态，并且没有重复。


## 说明/提示

【数据范围】  
对于 $100\%$ 的数据，$10 \le n \le 100$，$0 \le c \le 10^4$。

【样例解释】  
在这个样例中，有三种可能的状态：

- 所有灯都关着

- $1,4,7,10$ 号灯关着，$2,3,5,6,8,9$ 亮着。

- $1,3,5,7,9$ 号灯关着，$2,4,6,8,10$ 亮着。


翻译来自NOCOW

USACO 2.2


## 样例 #1

### 输入

```
10
1
-1
7 -1
```

### 输出

```
0000000000
0101010101
0110110110
```

# AI分析结果

### 综合分析与结论
这些题解的核心思路都是基于按钮操作的特性，通过不同方式找出所有可能的灯状态，并筛选出符合给定条件的状态。大部分题解利用了按钮按偶数次等效于没按、灯的状态以 6 为循环节等规律，减少了不必要的计算。

各题解的算法要点主要包括：
1. **打表法**：将所有可能的状态预先存储，直接进行判断和输出。
2. **枚举法**：枚举每个按钮按或不按的情况，模拟灯的状态变化。
3. **规律推导**：通过推导按钮操作的规律，将复杂的情况简化为有限的几种状态。

解决的难点在于：
1. **状态压缩**：如何将大量的灯状态压缩到一个较小的范围内进行处理。
2. **条件判断**：准确判断每种状态是否符合给定的灯状态要求。
3. **重复状态处理**：避免输出重复的灯状态。

### 所选题解
- **作者：Orzalpha (赞：45)，5 星**
    - **关键亮点**：思路清晰，详细推导了按钮操作的规律，将任意次数的操作转化为有限的几种情况，通过打表的方式存储所有可能的状态，代码简洁高效。
    - **个人心得**：无

### 重点代码
```cpp
const int h[9][7]= {{},
    {0,0,0,0,0,0}, //1
    {0,0,0,1,1,1}, //34
    {1,0,1,0,1,0}, //2
    {1,0,1,1,0,1}, //4
    {0,1,0,0,1,0}, //14
    {0,1,0,1,0,1}, //3
    {1,1,1,0,0,0}, //24
    {1,1,1,1,1,1}  //0
};
int n,c,on[101],off[101];
inline void work(int w[9])
{
    int flag=1;
    for(int k=1; k<=w[0]; k++)
    {
        int tag=0;
        for(int i=1; i<=on[0]; i++)
            if(!h[w[k]][on[i]%6])
            {tag=1;break;}
        if(tag) continue;
        for(int i=1; i<=off[0]; i++)
            if(h[w[k]][off[i]%6])
            {tag=1;break;}
        if(tag) continue;
        flag=0;
        for(int i=1; i<=n; i++)
            printf("%d",h[w[k]][i%6]);
        printf("\n");
    }
    if(flag) printf("IMPOSSIBLE");
    exit(0);
}
```
**核心实现思想**：通过打表存储所有可能的灯状态，`work` 函数用于检查每种状态是否符合给定的亮灯和灭灯要求，若符合则输出该状态，若所有状态都不符合则输出 `IMPOSSIBLE`。

### 最优关键思路或技巧
1. **状态循环节**：发现灯的状态以 6 为循环节，将问题的规模大大缩小，只需处理前 6 个灯的状态。
2. **按钮操作规律**：推导按钮操作的规律，如同一个按钮按两次等于没按，按钮 1、2、3 满足任意两个等于第三个，将任意次数的操作转化为有限的几种情况。
3. **打表法**：将所有可能的状态预先存储，直接进行判断和输出，避免了重复计算。

### 可拓展之处
同类型题或类似算法套路：
1. **开关问题**：涉及多个开关控制多个对象，开关操作有一定规律，可通过状态压缩和规律推导来解决。
2. **状态枚举问题**：需要枚举所有可能的状态，并根据一定条件筛选出符合要求的状态，可使用枚举法和打表法。

### 推荐题目
1. [P1896 [SCOI2005] 互不侵犯](https://www.luogu.com.cn/problem/P1896)：涉及状态压缩和枚举，通过位运算来表示状态。
2. [P2704 [NOI2001] 炮兵阵地](https://www.luogu.com.cn/problem/P2704)：同样是状态压缩和枚举的问题，需要考虑状态之间的合法性。
3. [P1077 [NOIP2012 普及组] 摆花](https://www.luogu.com.cn/problem/P1077)：通过枚举和动态规划来解决状态组合问题。

### 个人心得摘录与总结
- **作者：OdtreePrince**：提到要注意调试代码，保证输出顺序正确，还可以使用 DFS 使代码更简洁。总结：在解决此类问题时，要注重代码的调试和优化，选择合适的算法实现方式。
- **作者：天泽龟**：一开始忘记考虑 `c = 0` 的情况，后来直接最后特判。总结：在处理问题时，要全面考虑各种边界情况，避免遗漏。

---
处理用时：40.61秒
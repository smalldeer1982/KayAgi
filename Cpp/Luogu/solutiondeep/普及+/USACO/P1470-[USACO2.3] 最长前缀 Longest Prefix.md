# 题目信息

# [USACO2.3] 最长前缀 Longest Prefix

## 题目描述

在生物学中，一些生物的结构是用包含其要素的大写字母序列来表示的。生物学家对于把长的序列分解成较短的序列（即元素）很感兴趣。

如果一个集合 $P$ 中的元素可以串起来（元素可以重复使用）组成一个序列 $s$ ，那么我们认为序列 $s$ 可以分解为 $P$ 中的元素。元素不一定要全部出现（如下例中 `BBC` 就没有出现）。举个例子，序列 `ABABACABAAB` 可以分解为下面集合中的元素：`{A,AB,BA,CA,BBC}`

序列 $s$ 的前面 $k$ 个字符称作 $s$ 中长度为 $k$ 的前缀。设计一个程序，输入一个元素集合以及一个大写字母序列  ，设 $s'$ 是序列 $s$ 的最长前缀，使其可以分解为给出的集合 $P$ 中的元素，求 $s'$ 的长度 $k$。


## 说明/提示

**【数据范围】**

对于 $100\%$ 的数据，$1\le \text{card}(P) \le 200$，$1\le |S| \le 2\times 10^5$，$P$ 中的元素长度均不超过 $10$。

翻译来自NOCOW

USACO 2.3


## 样例 #1

### 输入

```
A AB BA CA BBC
.
ABABACABAABC
```

### 输出

```
11
```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何找出字符串的最长前缀，使其能分解为给定集合中的元素展开。大部分题解采用动态规划（DP）思想，结合不同的数据结构和算法进行优化，如 KMP、AC 自动机、Trie 树、哈希等。

### 所选题解
- **作者：momo5440（4星）**
    - **关键亮点**：使用 STL 中的 set 容器优化，只比较长度相等的子串，时间复杂度为 logn，代码注释详细，思路清晰。
    - **个人心得**：无

### 重点代码
```cpp
#include <iostream>
#include <set>
#include <cstring>
using namespace std;
int dp[200005],m;
set<string> s[20];
int main(){
    string tp;
    while (cin>>tp){
        if (tp==".") break;
        s[tp.size()].insert(tp); // 存到对应大小的集合中 
        m=max(m,int(tp.size()));
    }
    int i,ans=0;
    dp[0]=1; // 初始化 
    string n;
    n=" ";
    while (cin>>tp){
        n=n+tp; // 将所有的串合成一个 
    }
    for (i=1;i<n.size();i++){ // 枚举子串 
        for (int j=min(i,m);j>=1;j--){
            string tt=n.substr(i-j+1,j); // 截除子串 
            if (s[tt.size()].count(tt)==1&&dp[i-j]==1){ // 如果合法 
                ans=i; // 必定是最大的 
                dp[i]=1; // 本身也合法 
                break; // 没必要搜下去了 
            }
        }
    }
    cout<<ans;
}
```
**核心实现思想**：先将集合中的元素按长度存到不同的 set 中，然后枚举字符串的子串，对于每个子串，只在长度相等的 set 中查找是否存在，若存在且之前的子串合法，则当前子串也合法。

### 最优关键思路或技巧
- **动态规划思想**：用数组记录前 i 个字符是否能分解为集合中的元素，通过状态转移方程更新状态。
- **数据结构优化**：使用 set、Trie 树、AC 自动机等数据结构，减少字符串匹配的时间复杂度。
- **记忆化搜索**：避免重复计算，提高效率。

### 可拓展之处
同类型题如多模式串匹配问题，可使用 AC 自动机解决；字符串前缀匹配问题，可使用 Trie 树优化。类似算法套路包括使用动态规划解决字符串相关问题，结合不同的数据结构进行优化。

### 推荐题目
- P3375 【模板】KMP 字符串匹配
- P2580 于是他错误的点名开始了
- P5357 【模板】AC 自动机（二次加强版）

### 个人心得摘录与总结
- **resftlmuttmotw**：做题前先看标签，避免暴力导致 TLE；注意时间复杂度的优化，避免不必要的计算。
- **LeeCarry**：注意边界问题，i 的边界可能需要包含字符串长度；size_type 类型与 int 类型做运算后要强制类型转换，避免出现奇怪的 BUG。

---
处理用时：28.75秒
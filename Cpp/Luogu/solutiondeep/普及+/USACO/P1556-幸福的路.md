# 题目信息

# 幸福的路

## 题目描述

每天，John 都要为了农场里 $n$（$1 \leq n\leq 10$） 头牛的健康和幸福四处奔波。

每头牛的位置可以描述为一个二维坐标，John 从坐标原点 $(0,0)$ 出发。为了使路径更有趣，John 决定只沿着平行于坐标轴的方向行走，这样只能沿着东西南北方向运动。而且只有到达某头牛的坐标后 John 才会改变行走的方向（当然，如果有必要，John 也会穿过某头牛的坐标而不改变行走的方向。）

如果 John 改变行走的方向，他会原地转 $90^\circ$ 或者 $180^\circ$。John 的路径必须保证检查完所有牛后返回原点。

John 可以穿过某头牛的坐标而不改变方向任意次，请计算出有多少条路径满足 John 能检查完 $n$ 头牛，在每头牛的坐标处恰好改变一次方向。同一条路径从不同方向经过要计算两次。

## 样例 #1

### 输入

```
4
0 1
2 1
2 0
2 -5```

### 输出

```
2```

# AI分析结果

### 综合分析与结论
这些题解主要围绕全排列和深度优先搜索（DFS）展开。由于题目中 $n$ 的范围较小（$1 \leq n\leq 10$），所以全排列和 DFS 是可行的方法。各题解的核心在于解决两个关键问题：一是路径需平行于坐标轴，二是在每头牛的位置要恰好转弯一次。

### 所选题解
- **作者：ghj1222（4星）**
  - **关键亮点**：思路清晰，利用 `next_permutation` 枚举所有排列，通过向量点积判断是否转弯，代码结构清晰。
  - **个人心得**：无
- **作者：QianianXY（4星）**
  - **关键亮点**：采用 DFS 算法，通过自定义 `dire` 函数判断方向，逻辑明确，注释详细。
  - **个人心得**：作者提到提交 3 次才 AC，强调了判断是否能回到原点以及转弯条件的重要性。
- **作者：_111_（4星）**
  - **关键亮点**：同样使用 DFS 算法，运行时间较短（40ms），通过自定义函数判断可达性和方向，代码简洁高效。
  - **个人心得**：指出全排列可能会有许多不必要情况，导致运行时间增加，而此做法更优。

### 重点代码
#### ghj1222 的核心代码
```cpp
bool work()
{
    int lx = 0, ly = 0;
    for (int i = 0; i < n; i++)
    {
        int p = a[i];
        int x = c[p].x, y = c[p].y;
        int nx = c[a[i + 1]].x, ny = c[a[i + 1]].y;
        if(((lx == x) || (ly == y)) == 0)
            return false;
        if(((nx == x) || (ny == y)) == 0)
            return false;
        int x1 = x - lx, y1 = y - ly;
        int x2 = nx - x, y2 = ny - y;
        if((x1 * x2 + y1 * y2 > 0))
            return false;
        lx = x;
        ly = y;
    }
    return true;
}
```
**核心实现思想**：遍历排列中的每头牛，判断相邻牛之间的路径是否平行于坐标轴，通过向量点积判断是否转弯。

#### QianianXY 的核心代码
```cpp
inline int dire(int x, int y, int x1, int y1) {
    if (x < x1) return 1;
    if (x > x1) return 2;
    if (y < y1) return 3;
    if (y > y1) return 4;
}
void dfs(int x, int y, int d) {
    c = true;
    for (register int i = 0; i < n; i++)
        if (b[i]) {
            c = false; break;
        } 
    if (c && (x == 0 || y == 0) && dire(x, y, 0, 0) != d)  {
        ans++; return;
    }
    for (register int i = 0; i < n; i++)
        if ((p[i].x == x || p[i].y == y) && b[i] && dire(x, y, p[i].x, p[i].y) != d) {
            b[i] = false;
            dfs(p[i].x, p[i].y, dire(x, y, p[i].x, p[i].y));
            b[i] = true;
        }
}
```
**核心实现思想**：使用 `dire` 函数判断方向，DFS 遍历所有可能路径，当所有点都经过且能转弯回到原点时，答案加 1。

#### _111_ 的核心代码
```cpp
bool check1(int x1,int y1,int x2,int y2){
    if(x1==x2||y1==y2){
        return true;
    }
    return false;
}
int check2(int x1,int y1,int x2,int y2){
    if(y1==y2&&x1>x2) return 1;
    if(y1==y2&&x1<x2) return 2;
    if(x1==x2&&y1<y2) return 3;
    if(x1==x2&&y1>y2) return 4;
}
void dfs(int x,int y,int d,int sum){
    if(sum==n){
        if((x==0||y==0)&&check2(x,y,0,0)!=d) ans++;
        return ; 
    }
    for(int i=1;i<=n;i++){
        if(vis[i]||!check1(x,y,a[i].x,a[i].y)){
            continue;
        }
        int D;
        if((D=check2(x,y,a[i].x,a[i].y))!=d){
            vis[i]=1;
            dfs(a[i].x,a[i].y,D,sum+1);
            vis[i]=0;
        }
    }
}
```
**核心实现思想**：通过 `check1` 函数判断可达性，`check2` 函数判断方向，DFS 遍历路径，当所有点都经过且能转弯回到原点时，答案加 1。

### 最优关键思路或技巧
- **枚举排列**：利用 `next_permutation` 枚举所有可能的牛的排列顺序，再对每个排列进行合法性判断。
- **DFS**：通过深度优先搜索遍历所有可能的路径，在搜索过程中进行剪枝，避免不必要的计算。
- **方向判断**：通过自定义函数判断方向，利用向量点积或坐标比较来判断是否转弯。

### 可拓展之处
同类型题或类似算法套路：
- **哈密尔顿回路问题**：本题可转化为哈密尔顿回路计数问题，对于其他类似的图的路径问题，也可考虑使用状态压缩 DP 或 DFS 来解决。
- **搜索剪枝**：在搜索过程中，根据题目条件进行剪枝，减少不必要的计算，提高效率。

### 推荐题目
- [P1706 全排列问题](https://www.luogu.com.cn/problem/P1706)
- [P1036 选数](https://www.luogu.com.cn/problem/P1036)
- [P1135 奇怪的电梯](https://www.luogu.com.cn/problem/P1135)

### 个人心得总结
- QianianXY 提到提交 3 次才 AC，强调了判断是否能回到原点以及转弯条件的重要性，提醒我们在实现代码时要仔细考虑边界条件。
- _111_ 指出全排列可能会有许多不必要情况，导致运行时间增加，而直接 DFS 更优，这告诉我们在选择算法时要根据题目特点进行优化。

---
处理用时：46.13秒
# 题目信息

# [IOI 1998 ] [USACO5.5] 矩形周长Picture

## 题目背景

墙上贴着许多形状相同的海报、照片。它们的边都是水平和垂直的。每个矩形图片可能部分或全部的覆盖了其他图片。所有矩形合并后的边长称为周长。


## 题目描述

编写一个程序计算周长。

![](https://cdn.luogu.com.cn/upload/image_hosting/2eo4hzl6.png)

如图 $1$ 所示 $7$ 个矩形。

![](https://cdn.luogu.com.cn/upload/image_hosting/buk96amj.png)

如图 $2$ 所示，所有矩形的边界。所有矩形顶点的坐标都是整数。


## 说明/提示

### 数据范围及约定

对于全部数据，$1 \le N<5000$，所有坐标的数值范围都在 $-10^4$ 到 $10^4$ 之间。

## 样例 #1

### 输入

```
7
-15 0 5 10
-5 8 20 25
15 -4 24 14
0 -6 16 4
2 15 10 22
30 10 36 20
34 0 40 16```

### 输出

```
228```

# AI分析结果

### 综合分析与结论
这些题解主要围绕扫描线和线段树算法求解矩形周长问题，部分题解使用暴力枚举或分治思想。扫描线结合线段树的方法能高效处理区间覆盖和长度统计，是主流思路；暴力枚举简单直接但效率低；分治思想通过分割矩形降低重叠复杂度。各题解在代码实现和细节处理上存在差异，如离散化处理、排序规则、线段树节点信息维护等。

### 高评分题解
1. **作者：wucstdio（5星）**
    - **关键亮点**：思路清晰，详细解释扫描线和线段树结合的方法，配有多幅图辅助理解，代码注释详细。
    - **个人心得**：无
    - **核心代码**：
```cpp
void pushup(int o,int l,int r)
{
    if(tree[o].sum)
    {
        tree[o].num=1;
        tree[o].len=r-l+1;
        tree[o].lflag=tree[o].rflag=1;
    }
    else if(l==r)
    {
        tree[o].len=0;
        tree[o].num=0;
        tree[o].lflag=tree[o].rflag=0;
    }
    else
    {
        tree[o].len=tree[lson].len+tree[rson].len;
        tree[o].num=tree[lson].num+tree[rson].num;
        if(tree[lson].rflag&&tree[rson].lflag)tree[o].num--;
        tree[o].lflag=tree[lson].lflag;
        tree[o].rflag=tree[rson].rflag;
    }
}
void add(int o,int l,int r,int from,int to,int value)
{
    if(l>=from&&r<=to)
    {
        tree[o].sum+=value;
        pushup(o,l,r);
        return;
    }
    if(from<=mid)add(lson,l,mid,from,to,value);
    if(to>mid)add(rson,mid+1,r,from,to,value);
    pushup(o,l,r);
}
```
    - **核心实现思想**：`pushup` 函数用于更新线段树节点信息，根据节点覆盖情况计算区间被覆盖长度和线段数量；`add` 函数用于更新线段树区间覆盖次数，并调用 `pushup` 函数更新节点信息。

2. **作者：xiejinhao（4星）**
    - **关键亮点**：提出扫两次的思路，开横向和纵向两棵树，通过函数传参减小码量，使用离散化处理坐标。
    - **个人心得**：无
    - **核心代码**：
```cpp
void updata(int p, SegmentTree *t, int *b) {
    if(t[p].cnt) 
        t[p].len = b[t[p].r + 1] - b[t[p].l];
    else t[p].len = t[ls(p)].len + t[rs(p)].len;
}
void change(int p, int l, int r, int d, SegmentTree *t, int *b) {
    if(l <= t[p].l && r >= t[p].r) {
        t[p].cnt += d;
        updata(p, t, b);
        return;
    }
    int mid = (t[p].l + t[p].r) >> 1;
    if(l <= mid) change(ls(p), l, r, d, t, b);
    if(r > mid) change(rs(p), l, r, d, t, b);
    updata(p, t, b);
}
```
    - **核心实现思想**：`updata` 函数根据节点覆盖次数更新区间被覆盖长度；`change` 函数用于更新线段树区间覆盖次数，并调用 `updata` 函数更新节点信息。

3. **作者：Gumbo（4星）**
    - **关键亮点**：详细解释扫描线矩形周长并的思想，通过图形辅助理解，给出两种不同的代码实现思路。
    - **个人心得**：无
    - **核心代码**：
```cpp
void pushup(void) {
    if (cover > 0) {
        length = R - L + 1;
        num = 0;
        lcover = rcover = true;
        return;
    }
    if (lc == nullptr || rc == nullptr) {
        length = 0;
        num = 0;
        lcover = rcover = false;
    } else {
        length = lc->length + rc->length;
        num = lc->num + rc->num;
        if (lc->rcover!= rc->lcover) {
            ++num;
        }
        lcover = lc->lcover;
        rcover = rc->rcover;
        if (lc->lc == rc->rc && lc->cover == 0&&rc->cover==0) {
            delete lc;
            delete rc;
            lc = rc = nullptr;
        }
    }
}
void add(int l, int r, int x) {
    if (l <= L && r >= R) {
        cover += x;
        pushup();
        return;
    }
    if (lc == nullptr || rc == nullptr) {
        lc = new node;
        rc = new node;
        lc->L = L;
        lc->R = (L + R) >> 1;
        rc->L = lc->R + 1;
        rc->R = R;
        lc->cover = rc->cover = 0;
        lc->num = rc->num = 0;
        lc->lcover = lc->rcover = rc->lcover = rc->rcover = false;
        lc->length = rc->length = 0;
        lc->lc = lc->rc = rc->lc = rc->rc = nullptr;
    }
    if (l <= lc->R) lc->add(l, r, x);
    if (r >= rc->L) rc->add(l, r, x);
    pushup();
}
```
    - **核心实现思想**：`push

---
处理用时：41.05秒
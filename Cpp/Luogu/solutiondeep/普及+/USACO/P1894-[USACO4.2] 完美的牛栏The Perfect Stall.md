# 题目信息

# [USACO4.2] 完美的牛栏The Perfect Stall

## 题目描述

农夫约翰上个星期刚刚建好了他的新牛棚，他使用了最新的挤奶技术。

不幸的是，由于工程问题，每个牛栏都不一样。

第一个星期，农夫约翰随便地让奶牛们进入牛栏，但是问题很快地显露出来：每头奶牛都只愿意在她们喜欢的那些牛栏中产奶。

上个星期，农夫约翰刚刚收集到了奶牛们的爱好的信息（每头奶牛喜欢在哪些牛栏产奶）。

一个牛栏只能容纳一头奶牛，当然，一头奶牛只能在一个牛栏中产奶。

给出奶牛们的爱好的信息，计算最大分配方案。

## 说明/提示

$0\le n,m\le 200$，$0\le s_i\le m$。

## 样例 #1

### 输入

```
5 5
2 2 5
3 2 3 4
2 1 5
3 1 2 5
1 2```

### 输出

```
4```

# AI分析结果

### 综合分析与结论
本题是二分图最大匹配的经典问题，题解主要采用了匈牙利算法和网络流算法来求解。

#### 思路对比
- **匈牙利算法**：将牛和牛栏分为两个集合，通过深度优先搜索（DFS）不断寻找增广路来增加匹配数，直到找不到增广路为止。其核心在于尝试为每头牛寻找合适的牛栏，若牛栏已被占用，则尝试让占用的牛重新寻找其他牛栏。
- **网络流算法**：构建网络流图，添加超级源点和超级汇点，源点向每头牛连一条容量为 1 的边，每头牛向其喜欢的牛栏连一条容量为 1 的边，每个牛栏向汇点连一条容量为 1 的边，然后通过最大流算法（如 EK、Dinic、ISAP 等）求解最大匹配。

#### 算法要点
- **匈牙利算法**：关键在于实现 DFS 函数，通过递归尝试为牛寻找匹配的牛栏。
- **网络流算法**：重点是建图和选择合适的最大流算法，不同的最大流算法在时间复杂度和实现难度上有所差异。

#### 解决难点
- **匈牙利算法**：理解增广路的概念和如何通过递归实现匹配的调整是难点。
- **网络流算法**：建图过程中节点编号的处理和反向边的添加需要仔细考虑，同时不同最大流算法的实现细节也需要掌握。

### 高评分题解
- **作者：宁_缺（5 星）**
    - **关键亮点**：代码简洁，通过巧妙的代码压缩和逻辑处理，使二分图匹配代码行数减少，同时注释中提到了代码中变量修改和逻辑判断的技巧。
    - **核心代码**：
```cpp
bool dfs(int now){
    for(int i=1;i<=n;i++)
        if(!v[i]&&g[now][i]&&(v[i]=1))
            if((!lk[i]||dfs(lk[i]))&&(lk[i]=now))return 1;
    return false;
}
```
    - **核心思想**：通过 DFS 为当前节点寻找匹配，若找到未匹配的节点或能通过递归为已匹配节点找到新的匹配，则更新匹配信息并返回成功。

- **作者：zhaotiensn（4 星）**
    - **关键亮点**：思路清晰，详细解释了二分图和匈牙利算法的概念，代码中使用了快读和快输模板，提高了输入输出效率，同时注释详细，便于理解。
    - **核心代码**：
```cpp
bool dfs(int x){
    for(int i=1;i<=m;i++){
        if(!vis[i]&&k[x][i]){
            vis[i]=true;
            if(cow[i]==0||dfs(cow[i])){
                cow[i]=x;
                return true;
            }
        }
    }
    return false;
}
```
    - **核心思想**：从当前节点出发，尝试为其寻找匹配的节点，若找到未匹配节点或能通过递归为已匹配节点找到新匹配，则更新匹配信息并返回成功。

- **作者：Ireliaღ（4 星）**
    - **关键亮点**：使用带当前弧优化的 ISAP 算法求解最大流，效率较高，详细说明了建图思路和算法前置知识，并给出了相关博客链接。
    - **核心代码**：
```cpp
int Dfs(int u, int flow) {
    if (u == t) {
        maxflow += flow;
        return flow;
    }
    int used = 0;
    for (Edge *&e = cur[u]; e; e = e->next) {
        int v = e->to;
        if (dep[v] == dep[u] - 1 && e->val) {
            int mi = Dfs(v, std::min(flow - used, e->val));
            if (mi) {
                used += mi;
                e->val -= mi;
                e->opps->val += mi;
                if (used == flow) return flow;
            }
        }
    }
    gap[dep[u]]--;
    if (gap[dep[u]] == 0) dep[s] = n + 1;
    dep[u]++;
    gap[dep[u]]++;
    cur[u] = head[u];
    return used;
}
```
    - **核心思想**：通过 DFS 寻找增广路，更新流量信息，同时使用当前弧优化减少不必要的搜索，当出现断层时更新距离标号。

### 最优关键思路或技巧
- **匈牙利算法**：使用递归的方式实现增广路的寻找，通过标记数组避免重复搜索，代码简洁易懂。
- **网络流算法**：建图时添加超级源点和超级汇点，将二分图匹配问题转化为最大流问题，不同的最大流算法有不同的优化技巧，如当前弧优化、距离标号优化等。

### 可拓展之处
- **同类型题**：二分图匹配问题在很多场景中都有应用，如人员分配、任务调度等。可以尝试解决更复杂的二分图匹配问题，如带权二分图匹配、多重二分图匹配等。
- **类似算法套路**：网络流算法除了用于二分图匹配，还可以解决最大权闭合子图、最小割等问题。可以学习更多网络流算法的应用和优化技巧。

### 推荐题目
- [P3386 【模板】二分图最大匹配](https://www.luogu.com.cn/problem/P3386)
- [P2756 飞行员配对方案问题](https://www.luogu.com.cn/problem/P2756)
- [P4014 分配问题](https://www.luogu.com.cn/problem/P4014)

### 个人心得摘录与总结
- **zhaotiensn**：学长讲一般图匹配和线性规划听不懂，特地找二分图匹配的题来做，但还是看不懂 PPT，说明学习新算法需要多实践和深入理解。
- **Ireliaღ**：使用极其拖慢时间的 new 函数动态开空间建边，但 ISAP 算法效率仍然很高，体现了好的算法在一定程度上可以弥补实现细节的不足。
- **zhangjianweivv**：写题解是怕自己忘记网络流怎么打，提醒我们及时总结和记录学习成果的重要性。

---
处理用时：39.73秒
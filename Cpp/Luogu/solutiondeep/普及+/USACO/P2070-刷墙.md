# 题目信息

# 刷墙

## 题目描述

Farmer John已经设计了一种方法来装饰谷仓旁边的长栅栏（把栅栏认为是一根一维的线）。他把一只画刷绑在他最喜爱的奶牛Bessie身上，之后就去喝一杯冰水，而Bessie隔着栅栏来回走，当她走过某个地方，这里的一段栅栏就被刷上了涂料。

Bessie从栅栏上的位置0开始，并且遵循着一个N次移动的次序(1 <= N <= 100,000)。例如“10 L”表示Bessie向左移动了10个单位长度，“15 R”表示Bessie向右移动了15个单位长度。现给出Bessie所有移动的列表，Farmer John想要知道哪些区域的栅栏至少涂了两层涂料（只涂一层涂料的区域可能在大雨中被洗掉）。Bessie在她的行走中最远到达距起始点1,000,000,000个单位长度。


## 说明/提示

【样例解释】

Bessie从位置0开始，向右移动2个单位长度，向左移动6个单位长度，向右移动1个单位长度，向左移动8个单位长度，最后向右移动3个单位长度。

6个单位区域至少被涂了两层涂料，是 [-11,-8], [-4,-3], [0,2]这些区域。


## 样例 #1

### 输入

```
6

2 R

6 L

1 R

8 L

1 R

2 R```

### 输出

```
6```

# AI分析结果

### 综合分析与结论
这些题解围绕刷墙问题提供了多种思路，核心在于将奶牛的移动转化为区间问题，然后求解被至少覆盖两次的区间长度。由于数据范围较大，如何高效处理区间覆盖和避免空间溢出是主要难点。不同题解采用了贪心、离散化、差分、扫描线、动态开点线段树等多种算法，各有优劣。

### 所选题解
- **作者：kradcigam（4星）**
  - **关键亮点**：思路清晰，通过贪心算法解决问题，对算法的解释配有图示，易于理解。代码实现规范，包含快读快写优化。
  - **核心代码**：
```cpp
for(int i=2;i<=n;i++)
    if(a[i].r>lft){//如果跟可能被覆盖到的区间有交
        a[i].l=max(a[i].l,lft);
        if(a[i].r>rgt){//比之前的右端点大
            ans+=rgt-a[i].l;
            lft=rgt;
            rgt=a[i].r;
        }else{//比之前的右端点小
            ans+=a[i].r-a[i].l;
            lft=a[i].r;
        }
    }
```
  - **核心思想**：将每次移动视为一个区间，按左端点排序后，通过维护可能被覆盖的区间的左右端点，计算与后续区间的交集长度，累加得到至少被覆盖两次的区间长度。

- **作者：wkdwswxy（4星）**
  - **关键亮点**：巧妙运用离散化和差分技巧，解决了数据范围大导致的空间问题，思路新颖且实用。代码简洁明了，注释清晰。
  - **核心代码**：
```cpp
void deal(int last,int next){
    int v1 = lower_bound(b,b+1+n,last) - b;
    int v2 = lower_bound(b,b+1+n,next) - b;
    c[min(v1,v2)]++;c[max(v1,v2)]--;
}
for(int i=1;i<=n;i++){
    deal(now,now+a[i]);
    now+=a[i];
}
ok=c[0];
for(int i=1;i<m;i++){
    if(ok > 1) ans+=b[i]-b[i-1];
    ok+=c[i];
}
```
  - **核心思想**：先记录每次移动后的位置，排序去重实现离散化。然后利用差分记录区间的增减，最后通过前缀和统计至少被覆盖两次的区间长度。

- **作者：Loser_King（4星）**
  - **关键亮点**：将区间问题转化为事件处理，思路独特。代码简洁，通过排序和遍历事件高效求解。
  - **核心代码**：
```cpp
for(int i=0;i<n;i++){
    int x;char op;
    scanf("%d %c",&x,&op);
    if(op=='L'){
        evt[i<<1]=make_pair(cur-x,1);
        evt[i<<1|1]=make_pair(cur,-1);
        cur-=x;
    }else{
        evt[i<<1]=make_pair(cur,1);
        evt[i<<1|1]=make_pair(cur+x,-1);
        cur+=x;
    }
}
sort(evt,evt+n*2);cur=0;
for(int i=0;i<n*2;i++){
    if(cur>1)ans+=evt[i].first-evt[i-1].first;
    cur+=evt[i].second;
}
```
  - **核心思想**：把每个区间拆分成左右端点事件，记录事件位置和对应的涂料厚度变化。排序后遍历事件，根据当前涂料厚度判断是否累加区间长度。

### 最优关键思路或技巧
- **离散化**：当数据范围大但有效数据量较小时，通过离散化将数据映射到较小的范围，减少空间复杂度。
- **差分**：将区间修改转化为端点的单点修改，通过前缀和还原区间信息，可高效处理区间覆盖问题。
- **事件处理**：把区间问题转化为事件，按顺序处理事件，简化问题求解过程。

### 可拓展之处
同类型题或类似算法套路：
- 区间合并问题：将多个有重叠的区间合并成一个或多个不重叠的区间。
- 扫描线算法：常用于处理几何问题中的区间覆盖、面积计算等。
- 差分与前缀和：可用于解决区间修改、区间查询等问题。

### 推荐题目
- P1047 校门外的树：考察区间覆盖和模拟。
- P2082 区间覆盖：与本题类似，求解区间覆盖相关问题。
- P2205 刷墙加强版：本题的加强版，可进一步练习相关算法。

### 个人心得摘录与总结
- **wkdwswxy**：意识到数据范围大直接开数组会空间溢出，从而想到离散化；写代码时觉得逐个点判断麻烦，进而想到差分，体现了在解题过程中不断优化思路的过程。总结来说，面对数据范围大的问题要考虑离散化，处理区间问题可尝试差分。
- **lnwhl**：提到暴力模拟会因下标可能为负需要偏移，且数据范围大数组开不下，通过差分优化可得到部分分数，最终结合离散化实现AC，强调了在解题中逐步优化的重要性。 

---
处理用时：40.30秒
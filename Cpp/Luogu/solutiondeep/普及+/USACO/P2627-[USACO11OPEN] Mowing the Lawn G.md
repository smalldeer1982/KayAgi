# 题目信息

# [USACO11OPEN] Mowing the Lawn G

## 题目描述

在一年前赢得了小镇的最佳草坪比赛后，Farmer John 变得很懒，再也没有修剪过草坪。现在，新一轮的最佳草坪比赛又开始了，Farmer John 希望能够再次夺冠。

然而，Farmer John 的草坪非常脏乱，因此，Farmer John 只能够让他的奶牛来完成这项工作。Farmer John 有 $N$（$1\le N\le 10^5$）只排成一排的奶牛，编号为 $1\ldots N$。每只奶牛的效率是不同的，奶牛 $i$ 的效率为 $E_i$（$0\le E_i\le 10^9$）。

靠近的奶牛们很熟悉，因此，如果 Farmer John安排超过 $K$ 只连续的奶牛，那么，这些奶牛就会罢工去开派对 :)。因此，现在 Farmer John 需要你的帮助，计算 FJ 可以得到的最大效率，并且该方案中没有连续的超过 $K$ 只奶牛。

## 样例 #1

### 输入

```
5 2
1
2
3
4
5
```

### 输出

```
12
```

# AI分析结果

### 综合分析与结论
本题要求在一排奶牛中选择部分奶牛工作，保证连续工作的奶牛不超过 $K$ 只，以获得最大效率。众多题解主要围绕动态规划（DP）展开，利用前缀和优化区间求和，并借助单调队列、线段树、优先队列等数据结构进一步优化 DP 转移，降低时间复杂度。

### 所选题解
1. **作者：Koakuma（5星）**
    - **关键亮点**：提供三种思路，涵盖顺推和逆推，思路清晰，对状态定义和转移方程的推导详细，有助于全面理解问题。
    - **核心代码**：
```cpp
// Solution One
dp[i][0]=max(dp[i-1][0],dp[i-1][1]);
dp[i][1]=max{dp[j][0]-Sum[j]}+Sum[i] (i-K <= j < i);

// Solution Two
dp[i]=max{dp[j-1]-Sum[j]}+Sum[i] (i-K <= j <= i);

// Solution Three
dp[i]=min{dp[j]}+E[i] (i-K-1 <= j < i);
```
    - **核心思想**：
      - Solution One：定义二维状态 $dp[i][1]$ 和 $dp[i][0]$ 分别表示选和不选第 $i$ 头奶牛的最大效率，通过前缀和优化区间求和，用单调队列维护 $dp[j][0]-Sum[j]$ 的最大值。
      - Solution Two：定义一维状态 $dp[i]$ 表示前 $i$ 头奶牛的最大效率，同样利用前缀和和单调队列优化。
      - Solution Three：将问题转化为求最小效率损失，定义 $dp[i]$ 表示前 $i$ 头奶牛且第 $i$ 头不工作的最小损失，用单调队列维护 $dp[j]$ 的最小值。
2. **作者：thmyl（4星）**
    - **关键亮点**：思路简洁，代码实现清晰，详细展示了如何用单调队列优化 DP 转移。
    - **核心代码**：
```cpp
long long que(int i){
    d[i]=f[i-1]-sum[i];
    while(head<=tail&&d[q[tail]]<d[i])tail--;
    q[++tail]=i;
    while(head<=tail&&q[head]<i-m)head++;
    return d[q[head]];
}
for(int i=1;i<=n;i++)f[i]=que(i)+sum[i];
```
    - **核心思想**：定义 $dp[i]$ 表示前 $i$ 头奶牛的最大效率，通过前缀和将转移方程转化为 $dp[i]=max\{dp[j-1]-sum[j]\}+sum[i]$，用单调队列维护 $dp[j-1]-sum[j]$ 的最大值。
3. **作者：Refined_heart（4星）**
    - **关键亮点**：使用二维状态 $dp[i][0/1]$ 清晰表示选和不选第 $i$ 头奶牛的状态，代码实现规范，对单调队列的使用和维护解释详细。
    - **核心代码**：
```cpp
for(int i=1;i<=n;++i){
    f[i][0]=max(f[i-1][0],f[i-1][1]);
    while(q[head]<i-k&&head<=tail)head++;
    f[i][1]=f[q[head]][0]-s[q[head]]+s[i];
    while(f[i][0]-s[i]>f[q[tail]][0]-s[q[tail]]&&head<=tail)tail--;
    q[++tail]=i;
}
```
    - **核心思想**：定义 $dp[i][0/1]$ 表示选到第 $i$ 头奶牛时选或不选的最大效率，通过前缀和优化转移方程，用单调队列维护 $dp[j][0]-s[j]$ 的最大值。

### 最优关键思路或技巧
- **状态定义**：可从不同角度定义状态，如二维状态区分选与不选，一维状态表示前 $i$ 个的最优解，或通过逆推将问题转化为求最小损失。
- **前缀和优化**：利用前缀和可将区间求和的时间复杂度从 $O(n)$ 降为 $O(1)$。
- **单调队列优化**：在 DP 转移中，若需在固定区间内求最值，可使用单调队列将时间复杂度从 $O(nk)$ 降为 $O(n)$。

### 拓展思路
同类型题或类似算法套路：
- 烽火传递问题：在序列中选择若干点，要求相邻选择的点距离不超过一定范围，求最小代价。
- 股票交易问题：在一定限制条件下进行股票买卖，求最大收益。
- 滑动窗口问题：在数组中维护一个固定大小的窗口，求窗口内的最值。

### 洛谷相似题目推荐
1. [P1725 琪露诺](https://www.luogu.com.cn/problem/P1725)
2. [P2569 [SCOI2010]股票交易](https://www.luogu.com.cn/problem/P2569)
3. [P1886 滑动窗口 /【模板】单调队列](https://www.luogu.com.cn/problem/P1886)

### 个人心得摘录与总结
- **作者：BeyondStars**：强调初始状态的重要性，在使用单调队列优化 DP 时，要确保单调队列维护了正确的初始状态，否则可能导致结果错误。
- **作者：薛定谔的鱼**：总结自己的错误原因，认识到在 DP 中应合理使用前缀和，避免单个元素相加导致时空复杂度爆炸。
- **作者：quest_2**：列举了使用 `deque` 时的坑点，如不开 `long long` 会爆 `int`，要保证队列元素可访问，注意 `while` 条件顺序，以及 $dp_{i,0}$ 的转移不能简单处理等。 

---
处理用时：39.90秒
# 题目信息

# [USACO3.1] 丑数 Humble Numbers

## 题目描述

对于一给定的素数集合 $S = \{ p_1, p_2, ..., p_k \}$, 考虑一个正整数集合，该集合中任一元素的质因数全部属于 $S$。这个正整数集合包括，$p_1$、$p_1 \times p_2$、$p_1 \times p_1$、$p_1 \times p_2 \times p_3$ ...(还有其它)。该集合被称为 $S$ 集合的“丑数集合”。注意：我们认为 $1$不是一个丑数。

你的工作是对于输入的集合 $S$ 去寻找“丑数集合”中的第 $n$ 个“丑数”。保证答案可以用 32 位有符号整数表示。

补充：丑数集合中每个数从小到大排列，每个丑数都是素数集合中的数的乘积，第 $n$ 个“丑数”就是在能由素数集合中的数相乘得来的（包括它本身）第 $n$ 小的数。


## 说明/提示

#### 数据规模与约定

对于 $100\%$ 的数据，保证：

- $1 \leq k \leq 100$。
- $1 \leq n \leq 10^5$。
- $2 \leq p_i < 2^{31}$，且 $p_i$ 一定为质数。

---
#### 说明

题目翻译来自 NOCOW。

USACO Training Section 3.1


## 样例 #1

### 输入

```
4 19
2 3 5 7```

### 输出

```
27```

# AI分析结果

### 综合分析与结论
这些题解主要围绕寻找给定素数集合的丑数集合中第 `n` 个丑数展开，思路大致可分为暴力枚举、使用数据结构优化（如优先队列、集合、平衡树等）以及利用丑数单调性优化这几类。

暴力枚举类思路简单但时间复杂度高，容易超时；使用数据结构优化的方法可利用其特性（如排序、去重）简化操作，但可能存在空间和时间上的浪费；利用丑数单调性优化的方法则通过记录关键信息减少不必要的计算，效率较高。

### 所选题解
- **作者：Mark_ZZY (赞：102)，4星**
    - **关键亮点**：思路清晰，代码简洁，利用丑数的性质，通过枚举质数和丑数找到第 `i` 个丑数，时间复杂度较低。
- **作者：Celebrate (赞：14)，4星**
    - **关键亮点**：先给出暴力解法，再通过分析其不足进行优化，详细展示了优化思路，易于理解。
- **作者：Ikari_Shinji (赞：5)，4星**
    - **关键亮点**：使用指针数组记录当前最大倍数丑数的下标，利用丑数的单调性求解，代码简洁高效。

### 重点代码及核心思想
#### Mark_ZZY 的题解
```cpp
#include<cstdio>
int n,m;
int a[101],b[101];
int s[100001];
int main()
{
    scanf("%d %d",&n,&m);
    for(int i=1;i<=n;i++)
        scanf("%d",&a[i]);
    s[0]=1;
    for(int i=1;i<=m;i++)
    {
        int min=2147483647;
        for(int j=1;j<=n;j++)
        {
            while(a[j]*s[b[j]]<=s[i-1]) b[j]++;
            if(a[j]*s[b[j]]<min) min=a[j]*s[b[j]];
        }
        s[i]=min;
    }
    printf("%d",s[m]);
}
```
**核心思想**：对于每个丑数 `s[i]`，枚举质数 `a[j]`，找到最小的 `s[b[j]]` 使得 `a[j]*s[b[j]]` 大于 `s[i - 1]`，取所有这样的乘积中的最小值作为 `s[i]`。

#### Celebrate 的题解
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,a[110],f[110000],bk[110];
int minn;
int main()
{
    int i,j,t;
    scanf("%d%d",&k,&n);
    for(i=1;i<=k;i++) scanf("%d",&a[i]);
    f[0]=1;
    for(i=1;i<=n;i++)
    {
        minn=2147483647;
        for(j=1;j<=k;j++)
        {
            while(a[j]*f[bk[j]]<=f[i-1]) bk[j]++;
            minn=min(minn,a[j]*f[bk[j]]);
        }
        f[i]=minn;
    }
    printf("%d\n",f[n]);
    return 0;
}
```
**核心思想**：先给出暴力解法，通过枚举丑数、质数和之前的丑数找到满足条件的最小丑数。优化时，使用 `bk` 数组记录上一个 `j` 可以满足条件的最小丑数的序号，避免重复查找。

#### Ikari_Shinji 的题解
```cpp
#include <cstdio>
#include <cstring>
#define ll long long
#define min(a,b) (a<b?a:b)

const int N=100005;
ll a[N],k,n,p[105],s[105],num;

int main(){
    scanf("%lld %lld",&k,&n);
    a[0]=1;
    memset(p,0,sizeof(p));
    for(int i=1;i<=k;i++){
        scanf("%lld",&s[i]);
    }
    for(int i=1;i<=n;i++){
        num=2147483647;
        for(int j=1;j<=k;j++){
            num=min(num,a[p[j]]*s[j]);
        }
        a[i]=num;
        for(int j=1;j<=k;j++){
            if(num==a[p[j]]*s[j])
                p[j]++;
        }
    }
    printf("%lld\n",a[n]);
    return 0;
}
```
**核心思想**：使用指针数组 `p` 记录当前每个质数对应的最大倍数丑数的下标，每次找到 `a[p[j]]*s[j]` 中的最小值作为下一个丑数，然后将对应质数的指针 `p[j]` 加 1。

### 最优关键思路或技巧
- **利用丑数的单调性**：丑数本身是单调递增的，对于每个质数，其乘的丑数也是单调递增的。利用这一性质，可以记录每个质数当前乘的丑数的下标，避免重复计算。
- **减少不必要的计算**：在生成丑数时，及时判断是否超过当前所需范围，避免生成过多无用的丑数。

### 可拓展之处
同类型题目如求超级丑数、特定规则下的第 `n` 个数字等，都可以利用类似的思路，即通过记录关键信息，利用单调性减少不必要的计算。类似算法套路包括使用优先队列、集合、平衡树等数据结构进行排序、去重和维护元素。

### 推荐洛谷题目
- P1323 删数问题
- P1020 导弹拦截
- P1090 合并果子

### 个人心得摘录与总结
- **Mizuhara**：最初用优先队列生成丑数，但生成的丑数太多接近时限。后来发现找最小新丑数具有两个单调性，使用第二个单调性解决了问题。总结：在解题时要注意观察数据的特性，利用单调性等性质进行优化。
- **msy66**：用堆维护丑数时存在重复元素，消耗时间和空间，改用 set 后仍 T 了一个点。优化时，发现堆内数字多余 `N` 个时后面的数字无用，删去后加一些优化通过了题目。总结：在使用数据结构时要考虑其优缺点，根据实际情况进行优化。

---
处理用时：48.12秒
# 题目信息

# [USACO3.3] 骑马修栅栏 Riding the Fences

## 题目背景

Farmer John 每年有很多栅栏要修理。他总是骑着马穿过每一个栅栏并修复它破损的地方。

## 题目描述

John 是一个与其他农民一样懒的人。他讨厌骑马，因此从来不两次经过一个栅栏。

John 的农场上一共有 $m$ 个栅栏，每一个栅栏连接两个顶点，顶点用 $1$ 到 $500$ 标号（虽然有的农场并没有那么多个顶点）。一个顶点上至少连接 $1$ 个栅栏，没有上限。两顶点间可能有多个栅栏。所有栅栏都是连通的（也就是你可以从任意一个栅栏到达另外的所有栅栏）。John 能从任何一个顶点（即两个栅栏的交点）开始骑马，在任意一个顶点结束。

你需要求出输出骑马的路径（用路上依次经过的顶点号码表示)，使每个栅栏都恰好被经过一次。如果存在多组可行的解，按照如下方式进行输出：如果把输出的路径看成是一个 $500$ 进制的数，那么当存在多组解的情况下，输出 $500$ 进制表示法中最小的一个 （也就是输出第一位较小的，如果还有多组解，输出第二位较小的，以此类推）。

输入数据保证至少有一个解。

## 说明/提示

对于 $100\%$ 的数据，$1 \leq m \leq 1024,1 \leq u,v \leq 500$。

题目翻译来自NOCOW。

USACO Training Section 3.3

## 样例 #1

### 输入

```
9
1 2
2 3
3 4
4 2
4 5
2 5
5 6
5 7
4 6```

### 输出

```
1
2
3
4
2
5
4
6
5
7```

# AI分析结果

### 综合分析与结论
本题是典型的欧拉路径问题，解题关键在于理解欧拉路和欧拉回路的性质，找到合适的起点并通过深度优先搜索（DFS）遍历图，同时要注意边的重复问题和路径字典序最小的要求。各题解整体思路相似，主要区别在于数据结构的选择和代码实现细节。

### 所选题解
- **作者：EarthGiao (赞：296)，4星**
    - **关键亮点**：思路清晰，对代码和思路的解释详细，适合初学者理解。
    - **个人心得**：无
- **作者：Mogu (赞：105)，4星**
    - **关键亮点**：图文并茂，详细解释了欧拉路和欧拉回路的概念，深入分析了递归输出和回溯记录输出的区别。
    - **个人心得**：在实际做的时候最后两个点WA，倒腾一晚上发现正着输出和用栈存路径倒着输出答案的区别。
- **作者：Misaka_Azusa (赞：63)，4星**
    - **关键亮点**：介绍了Hierholzer算法，该算法编程复杂度和时间复杂度较优。
    - **个人心得**：无

### 重点代码
#### EarthGiao的核心代码
```cpp
void find(int i) {
    int j;
    for(j = 1; j <= maxn; ++j) {
        if(map[i][j] >= 1) {
            map[i][j]--;
            map[j][i]--;
            find(j);
        }
    }
    lu[++js]=i;
}
```
**核心实现思想**：从当前点开始，找到与之相连的边，删除该边后递归搜索新的点，回溯时记录路径。

#### Mogu的核心代码
```cpp
void dfs(int u) {
    for(int v = minn; v <= maxn; v++) {
        if(g[u][v]) {
            g[u][v]--;
            g[v][u]--;
            dfs(v);
        } 
    }
    S.push(u);
}
```
**核心实现思想**：使用邻接矩阵存图，从当前点开始，找到未访问的边，删除该边后递归搜索新的点，回溯时将当前点压入栈中。

#### Misaka_Azusa的核心代码
```cpp
void dfs(int u) {
    for(int v = 1; v <= n; v++)
        if(G[u][v]) {
            G[u][v]--;
            G[v][u]--;
            dfs(v);    
        }
    S.push(u);
}
```
**核心实现思想**：基于Hierholzer算法，从当前点开始，找到未访问的边，删除该边后递归搜索新的点，回溯时将当前点压入栈中。

### 最优关键思路或技巧
- **数据结构**：多数题解使用邻接矩阵存图，简单直观，适合数据范围较小的情况；部分题解使用vector或multiset存图，方便处理字典序最小的问题。
- **算法优化**：Hierholzer算法在编程复杂度和时间复杂度上较优。
- **思维方式**：利用欧拉路和欧拉回路的性质确定起点，通过深度优先搜索遍历图，回溯时记录路径保证字典序最小。
- **代码实现技巧**：使用栈来记录路径，最后倒序输出，避免递归输出时可能出现的问题。

### 可拓展之处
同类型题或类似算法套路：
- 有向图的欧拉路径和欧拉回路问题，需要考虑入度和出度的关系。
- 欧拉路径和欧拉回路的存在性判断问题，可根据图的性质进行判断。
- 图的遍历问题，如哈密顿路径、旅行商问题等。

### 推荐题目
- [P1341 无序字母对](https://www.luogu.com.cn/problem/P1341)
- [P2731 [USACO3.3] 骑马修栅栏 Riding the Fences](https://www.luogu.com.cn/problem/P2731)
- [P1127 词链](https://www.luogu.com.cn/problem/P1127)

### 个人心得总结
- **Mogu**：在实际做题时遇到最后两个点WA的情况，经过一晚上的调试，发现正着输出和用栈存路径倒着输出答案存在区别，强调了回溯时记录路径的重要性。

---
处理用时：33.88秒
# 题目信息

# [USACO3.4] “破锣摇滚”乐队 Raucous Rockers

## 题目描述

你刚刚继承了流行的 “破锣摇滚” 乐队录制的尚未发表的 $N$（$1\leq N\leq 20$）首歌的版权。你打算从中精选一些歌曲，发行 $M$（$1\leq M\leq 20$）张 CD。每一张 CD 最多可以容纳 $T$（$1\leq T\leq 20$）分钟的音乐，一首歌不能分装在两张 CD 中。CD 数量可以用完，也可以不用完。

不巧你是一位古典音乐迷，不懂如何判定这些歌的艺术价值。于是你决定根据以下标准进行选择：

* 1.歌曲必须按照创作的时间顺序在所有的 CD 盘上出现。(注：第 $i$ 张盘的最后一首的创作时间要早于第 $i+1$ 张盘的第一首)

* 2.选中的歌曲数目尽可能地多。

## 说明/提示

题目翻译来自NOCOW。

USACO Training Section 3.4


## 样例 #1

### 输入

```
4 5 2
4 3 4 2```

### 输出

```
3```

# AI分析结果

### 综合分析与结论
这些题解主要围绕“破锣摇滚”乐队歌曲选录问题展开，解题方法可分为动态规划（DP）和深度优先搜索（DFS）两大类。

#### 动态规划类
- **思路**：通过定义不同的状态数组，如`f[m][t]`表示用`m`张CD，最后一张CD用`t`分钟所能存的最大歌曲数等，依据状态转移方程更新状态，以求得最优解。
- **算法要点**：关键在于准确找出状态转移方程，常见的转移情况包括不选当前歌曲、用新CD存当前歌曲、在当前CD存当前歌曲。
- **难点**：状态的定义和转移方程的推导需要深入理解题意，考虑多种情况。

#### 深度优先搜索类
- **思路**：对每首歌曲进行递归搜索，考虑其存或不存、存于当前CD或新CD的情况，最终找出最大歌曲数。
- **算法要点**：明确递归函数的参数和边界条件，合理剪枝以优化搜索效率。
- **难点**：剪枝策略的设计，避免不必要的搜索。

### 高评分题解
1. **作者：DayC（5星）**
    - **关键亮点**：思路清晰，明确指出本题为二维费用背包题，详细给出状态转移方程，代码注释丰富，可读性强。
    - **核心代码**：
```cpp
#define maxn 21
int f[maxn][maxn];
int t[maxn];
int max(int i,int j,int k){
    i=max(i,j);
    i=max(i,k);
    return i;
}
int main(){
    cin>>N>>T>>M;
    for(int i=1;i<=N;i++){
        cin>>t[i];
    }
    for(int i=0;i<=T;i++){
        f[0][i]=0;
    }
    for(int i=1;i<=N;i++){
        for(int m=M;m>=1;m--){
            for(int j=T;j>=t[i];j--){
                f[m][j]=max(f[m][j],f[m-1][T]+1,f[m][j-t[i]]+1);
            }
        }
    }
    cout<<f[M][T];
}
```
    - **核心实现思想**：使用二维数组`f[m][t]`记录状态，通过三重循环遍历歌曲、CD数量和时间，依据状态转移方程更新`f[m][t]`的值，最后输出`f[M][T]`。

2. **作者：微香玉烛暗（4星）**
    - **关键亮点**：采用DFS方法，详细解释了`dfs`函数中各参数的含义，代码逻辑清晰，易于理解。
    - **核心代码**：
```cpp
const int N=25;
int n,t,m,ans=-1e9,a[N];
void dfs (int i,int now,int s,int sum) {
    if (i>n||s>m) {
        ans=max(ans,sum);
        return ;
    }
    if (t-now>=a[i]) {
        if (t-now>a[i]) dfs (i+1,now+a[i],s,sum+1);
        dfs (i+1,0,s+1,sum+1);
    }
    dfs (i+1,now,s,sum);
}
int main () {
    scanf ("%d%d%d",&n,&t,&m);
    for (int i=1;i<=n;i++) 
        scanf ("%d",&a[i]);
    dfs (1,0,1,0);
    printf ("%d\n",ans);
    return 0;
}
```
    - **核心实现思想**：定义`dfs`函数进行深度优先搜索，根据当前歌曲能否存入当前CD，分情况递归调用`dfs`函数，更新最大歌曲数`ans`。

3. **作者：Celebrate（4星）**
    - **关键亮点**：使用DP方法，清晰给出状态定义和转移方程，代码简洁，对DP过程解释详细。
    - **核心代码**：
```cpp
int n,m,t;
int a[31],f[31][31];
int main()
{
    int i,j,k;
    scanf("%d%d%d",&n,&t,&m);
    for(i=1;i<=n;i++) scanf("%d",&a[i]);
    for(i=1;i<=n;i++)
        for(j=m;j>=1;j--)
            for(k=t;k>=a[i];k--)
                f[j][k]=max(f[j][k],max(f[j-1][t]+1,f[j][k-a[i]]+1));
    int maxx=0;
    for(i=1;i<=m;i++) for(j=1;j<=t;j++) maxx=max(maxx,f[i][j]);
    printf("%d\n",maxx);
    return 0;
}
```
    - **核心实现思想**：定义二维数组`f[j][k]`记录状态，通过三重循环更新状态，最后遍历数组找出最大值。

### 最优关键思路或技巧
- **动态规划**：准确定义状态和状态转移方程是关键，可将问题拆分为子问题，通过递推求解。
- **深度优先搜索**：合理剪枝可避免大量不必要的搜索，提高效率。

### 可拓展之处
同类型题如多重背包问题、分组背包问题等，解题思路类似，需根据具体问题调整状态定义和转移方程。

### 洛谷相似题目推荐
1. [P1048 采药](https://www.luogu.com.cn/problem/P1048)：经典的01背包问题。
2. [P1616 疯狂的采药](https://www.luogu.com.cn/problem/P1616)：完全背包问题。
3. [P1757 通天之分组背包](https://www.luogu.com.cn/problem/P1757)：分组背包问题。

### 个人心得摘录与总结
- **作者：__stdcall**：提到裸的DFS会超时，需要加IDA*进行剪枝，剪枝思路为若当前搜索到第`i`首歌，把后面所有歌都选上还不能比当前最优解大，则剪枝。这表明在使用搜索算法时，合理剪枝是优化效率的关键。 

---
处理用时：40.78秒
# 题目信息

# [USACO4.4] 棋盘游戏Shuttle Puzzle

## 题目描述

大小为3的棋盘游戏里有3个白色棋子，3个黑色棋子，和一个有7个格子一线排开的木盒子。3个白棋子被放在一头，3个黑棋子被放在另一头，中间的格子空着。

初始状态: WWW\_BBB

目标状态: BBB\_WWW

在这个游戏里有两种移动方法是允许的：

你可以把一个棋子移到与它相邻的空格；

你可以把一个棋子跳过一个(仅一个)与它不同色的棋子到达空格。

大小为N的棋盘游戏包括N个白棋子，N个黑棋子，还有有2N+1个格子的木盒子。

这里是3-棋盘游戏的解，包括初始状态，中间状态和目标状态：

WWW BBB

WW WBBB

WWBW BB

WWBWB B

WWB BWB

W BWBWB

WBWBWB
BW WBWB

BWBW WB

BWBWBW
BWBWB W

BWB BWW

B BWBWW

BB WBWW

BBBW WW

BBB WWW

请编一个程序解大小为N的棋盘游戏(1 <= N <= 12)。要求用最少的移动步数实现。


## 说明/提示

题目翻译来自NOCOW。

USACO Training Section 4.3


## 样例 #1

### 输入

```
3```

### 输出

```
3 5 6 4 2 1 3 5 7 6 4 2 3 5 4```

# AI分析结果

### 综合分析与结论
这些题解主要围绕棋盘游戏问题展开，解题思路大致分为找规律和搜索（DFS、BFS、迭代加深搜索等）两类。找规律的题解通过手动模拟数据，总结出移动步数的规律来求解；搜索类题解则是通过深度优先搜索、广度优先搜索或迭代加深搜索等算法，结合剪枝优化来寻找最少移动步数的解。

找规律的方法实现简单、效率高，但需要较强的观察和归纳能力；搜索类方法更具通用性，但需要处理好剪枝，否则容易超时。

### 所选题解
- 作者：珅肐（5星）
    - 关键亮点：详细解释了找规律的原因，思路清晰，代码简洁高效。通过分析游戏规则，发现移动步数存在规律，共\(2n + 1\)个等差序列，长度从\(1\)到\(n\)再到\(1\)，且后面与前面对称。
    - 个人心得：认为搜索比较麻烦，有人的剪枝根据不知怎么推出的答案来限制最大值，平常做题不建议这样，应深入探究规律。
```cpp
int f[17][17];
inline void check(int x){
    if(x%20==0)puts("");
}
int main(){
    int n=read(),cnt=0;
    for(int i=1;i<=n+1;++i){
        if(i&1)for(int j=0;j<i;++j)f[i][j]=n+i-j-j;
        else for(int j=0;j<i;++j)f[i][j]=n-i+j+j+2;
    }
    for(int i=2;i<=n+1;++i)for(int j=0;j<i;++j)printf("%d ",f[i][j]),check(++cnt);
    for(int i=n;i>=1;--i)for(int j=0;j<i;++j)printf("%d ",f[i][j]),check(++cnt);
    return 0;
}
```
- 作者：yhk1001（4星）
    - 关键亮点：采用DFS和剪枝优化，思路清晰，代码可读性强。通过观察发现白子只往右走、黑子只往左走，搜索时只需考虑四种情况，同时记录最少所用步数进行剪枝。
    - 个人心得：无
```cpp
void dfs(int step,int pos)//step是已用步数，pos是空格位置
{
    if (step >= sum)//剪枝
        return ;
    if (now == tar)//更新答案
    {
        sum = step;
        for (int i = 1;i <= step;i++)
        {
            a[i] = b[i];
        }
        return ;
    }
    if (pos - 2 > 0 && now[pos - 2] == 'W' && now[pos - 1] == 'B')//白子跳一格 
    {
        b[step + 1] = pos - 2;
        now[pos - 2] = ' ';
        now[pos] = 'W';
        dfs(step + 1,pos - 2);
        b[step + 1] = 0;//回溯
        now[pos - 2] = 'W';
        now[pos] = ' ';
    }
    // 其他三种情况类似...
}
```
- 作者：Dadatu（4星）
    - 关键亮点：通过手玩数据总结规律，思路明确，代码实现简洁。总结出前\(n + 1\)组数每组的大小等于组序数，后以\(n + 1\)组数为与之前对称，每组数内公差为2，奇数组为降序且首项为\(n + i\)，偶数组为升序且首项为\(n - i + 2\)。
    - 个人心得：无
```cpp
int res[1010];
int n,tot,len;
int main()
{
    scanf("%d",&n);
    for (int i=1;i<=n+1;i++)//i表示组数
    {
        if (!(i%2))//奇数组
            for (int j=0;j<i;j++) res[++tot]=n-i+2+2*j;
        else//偶数组
            for (int j=0;j<i;j++) res[++tot]=n+i-2*j;
    }
    // 输出部分...
    return 0;
}
```

### 最优关键思路或技巧
- **找规律**：通过手动模拟多组数据，观察移动步数的规律，总结出等差序列的特点，从而直接计算出结果，避免了搜索的复杂度。
- **剪枝优化**：在搜索过程中，记录最少所用步数，若当前步数已经比它大了，就直接返回，避免因多次递归而超时。同时，根据游戏规则，限制白子只往右走、黑子只往左走，减少不必要的搜索。

### 可拓展之处
同类型题或类似算法套路：
- 华容道问题：也是通过移动棋子来达到目标状态，可使用搜索算法结合剪枝优化求解。
- 八数码问题：给定一个3x3的棋盘，通过移动空格来将数字排列成目标状态，同样可以用搜索算法解决。
- 滑块拼图问题：通过移动滑块来完成拼图，可采用类似的搜索和剪枝策略。

### 推荐题目
- P1379 八数码难题：通过广度优先搜索或A*算法求解八数码问题。
- P2324 [SCOI2005]骑士精神：使用迭代加深搜索求解骑士移动问题。
- P1126 机器人搬重物：通过广度优先搜索解决机器人在地图中移动的问题。

### 个人心得摘录与总结
- 珅肐：认为搜索比较麻烦，且有人的剪枝根据不知怎么推出的答案来限制最大值，平常做题应深入探究规律，而不是依赖这种方式，避免养成打表的习惯。
- lxzy_：考场上没往DFS或找规律方向想，用双向BFS未优化且没输出换行，喜提20pts，提醒做题时要全面思考并注意细节。
- Drinkwater：尝试加羞耻性剪枝无效，深入分析后发现类似贪心的思路，即1一直往后走，2一直往前走，避免了无限递归和判重的问题。

---
处理用时：48.69秒
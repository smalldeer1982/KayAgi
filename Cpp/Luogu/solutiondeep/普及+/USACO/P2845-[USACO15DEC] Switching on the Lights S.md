# 题目信息

# [USACO15DEC] Switching on the Lights S

## 题目背景

来源：usaco-2015-dec

Farm John 最近新建了一批巨大的牛棚。这些牛棚构成了一个 $N \times N$ 的矩形网络 $(1 < N < 100)$。

然而 Bessie 十分怕黑，他想计算可以把多少个牛棚的灯打开。

## 题目描述

有 $N \times N$ 个房间，组成了一张 $N \times N$ 的网格图，Bessie 一开始位于左上角 $(1,1)$，并且只能上下左右行走。


一开始，只有 $(1,1)$ 这个房间的灯是亮着的，Bessie 只能在亮着灯的房间里活动。


有另外 $M$ 条信息，每条信息包含四个数 $a,b,c,d$，表示房间 $(a,b)$ 里有房间 $(c,d)$ 的灯的开关。


请计算出最多有多少个房间的灯可以被打开。

## 说明/提示

Bessie 可以使用 $(1,1)$ 的开关打开 $(1,2),(1,3)$ 的灯，然后走到 $(1,3)$ 并打开 $(2,1)$ 的灯，走到 $(2,1)$ 并打开 $(2,2)$ 的灯。$(2,3)$ 的开关无法到达。因此可以点亮 $5$ 个房间。

## 样例 #1

### 输入

```
3 6
1 1 1 2
2 1 2 2
1 1 1 3
2 3 3 1
1 3 1 2
1 3 2 1
```

### 输出

```
5```

# AI分析结果

### 综合分析与结论
这些题解主要围绕搜索算法（DFS 或 BFS）来解决房间开灯问题。思路核心在于从起始房间开始，不断探索可到达的房间并打开相应的灯，同时处理好房间可达性和灯的开关状态。

不同题解在数据结构的选择上各有不同，如邻接表、二维数组、vector 等，以记录房间之间的开关关系。对于处理房间可达性和灯的开关状态，部分题解采用多次搜索，部分则在搜索过程中动态判断。

### 所选题解
- **作者：vani_prcups（5星）**
    - **关键亮点**：思路清晰，使用深搜实现，通过二维邻接表优化边的查找，对点亮房间的处理逻辑明确。
    - **个人心得**：无
- **作者：JMercury（4星）**
    - **关键亮点**：使用队列进行 BFS 搜索，逻辑清晰，将可到达的点按顺序加入队列，每次进行扩展和开灯操作。
    - **个人心得**：做这个题让作者想起了另一道题，采用类似方法解决本题。
- **作者：bobxie（4星）**
    - **关键亮点**：使用 BFS 搜索，通过邻接表存储房间关系，对房间可达性和灯的开关状态处理得当。
    - **个人心得**：提醒注意题目要求是求能开多少个房间的灯，而不是能走到多少个房间。

### 重点代码及核心实现思想
#### vani_prcups 的题解
```cpp
void dfs(int x,int y)
{
    if (x<1||x>n||y<1||y>n)return;
    v[x][y]=1;
    for (int i=head[x][y];i!=0;i=a[i].nt)
    if (b[a[i].tx][a[i].ty]==0)
    {
        b[a[i].tx][a[i].ty]=1;
        c++;
        if (v[a[i].tx+1][a[i].ty]==1||v[a[i].tx][a[i].ty+1]==1||v[a[i].tx-1][a[i].ty]==1||v[a[i].tx][a[i].ty-1]==1)dfs(a[i].tx,a[i].ty);
    }
    if (v[x+1][y]==0&&b[x+1][y]==1)dfs(x+1,y);
    if (v[x][y+1]==0&&b[x][y+1]==1)dfs(x,y+1);
    if (v[x-1][y]==0&&b[x-1][y]==1)dfs(x-1,y);
    if (v[x][y-1]==0&&b[x][y-1]==1)dfs(x,y-1);
}
```
核心思想：从当前房间开始，标记已访问，遍历该房间能控制的灯，若灯未开则打开并计数，若点亮的房间周围有已访问的房间则递归搜索。同时，若当前房间周围有灯已开且未访问的房间，也进行递归搜索。

#### JMercury 的题解
```cpp
void spfa()
{
    queue<P> q;q.push((P){1,1});vis[1][1]=true;MAP[1][1]=true;ans++;
    while(!q.empty())
    {
        P u=q.front();q.pop();
        for(int i=0;i<4;i++)
        {
            int vx=u.x+dx[i],vy=u.y+dy[i];
            if(!Inside(vx,vy) || vis[vx][vy]) continue;
            if(MAP[vx][vy]) q.push((P){vx,vy}),vis[vx][vy]=true;
        }
        for(int i=0;i<Lamp[u.x][u.y].size();i++)
        {
            P v=Lamp[u.x][u.y][i];
            if(vis[v.x][v.y] || MAP[v.x][v.y]) continue;
            MAP[v.x][v.y]=true;ans++;
            for(int i=0;i<4;i++)
            if(vis[v.x+dx[i]][v.y+dy[i]])
            {
	            q.push((P){v.x,v.y}),vis[v.x][v.y]=true;
                break;
            }
        }
    }
}
```
核心思想：使用队列进行 BFS 搜索，将起始房间加入队列。每次从队列中取出一个房间，将其周围灯已开且未访问的房间加入队列，同时遍历该房间能控制的灯，若灯未开则打开并计数，若点亮的房间周围有已访问的房间则将其加入队列。

#### bobxie 的题解
```cpp
int bfs()
{
    int cnt=1;
    queue<note> Q;
    Q.push((note){1,1});
    mp[1][1]=used[1][1]=1;
    while (!Q.empty())
    {
        note top=Q.front();
        Q.pop();
        for (int i=0;i<4;++i)
        {
            int xx=top.x+dx[i],yy=top.y+dy[i];
            if (xx<1||yy<1||xx>n||yy>n||used[xx][yy]) continue;
            if (!mp[xx][yy]) continue;
            used[xx][yy]=1;
            Q.push((note){xx,yy});
        }
        for (int i=head[top.x][top.y];i;i=e[i].nxt)
        {
            int xx=e[i].to1,yy=e[i].to2;
            if (!mp[xx][yy])
            {
            	cnt++;
            	mp[xx][yy]=1;
                if (!used[xx][yy]&&(used[xx-1][yy]||used[xx+1][yy]||used[xx][yy+1]||used[xx][yy-1]))
                {
                    Q.push((note){xx,yy});
                    used[xx][yy]=1;
                }
            }
        }
    }
    return cnt;
}
```
核心思想：使用队列进行 BFS 搜索，将起始房间加入队列。每次从队列中取出一个房间，将其周围灯已开且未访问的房间加入队列，同时遍历该房间能控制的灯，若灯未开则打开并计数，若点亮的房间周围有已访问的房间则将其加入队列。

### 最优关键思路或技巧
- **数据结构**：使用邻接表（如链式前向星、二维邻接表）或 vector 存储房间之间的开关关系，可优化边的查找。
- **算法优化**：在搜索过程中，动态判断点亮的房间是否可达，避免重复搜索。
- **思维方式**：考虑到房间可达性和灯的开关状态的动态变化，通过多次搜索或在搜索过程中实时更新状态来解决问题。

### 可拓展之处
同类型题可能涉及地图变化的迷宫问题，如地图上的障碍物会动态变化，或者某些区域需要满足特定条件才能进入。类似算法套路包括使用搜索算法（DFS 或 BFS），并通过标记数组记录状态，在搜索过程中动态更新状态。

### 推荐题目
- [P1135 奇怪的电梯](https://www.luogu.com.cn/problem/P1135)
- [P1605 迷宫](https://www.luogu.com.cn/problem/P1605)
- [P1443 马的遍历](https://www.luogu.com.cn/problem/P1443)

### 个人心得摘录与总结
- **bobxie**：提醒注意题目要求是求能开多少个房间的灯，而不是能走到多少个房间，避免因理解题意错误而导致错误。
- **chenxuanting**：完成本题断断续续花了 6 个月，强调注意 light[1][1] 初始化为 1，vis 数组更改为 1 的顺序，以及判断打开的灯周围是否有访问过的房间等细节。
- **LDlornd**：调了两三天才 A 掉本题，分享了优化搜索过程的思路，包括记录打开灯却不能走到的房间，以及降维优化等。
- **xun薰**：发现 bfs 遍历完队列首元素后可能出现问题，采用多遍历几遍图的方法通过本题，同时表示要学习正解。
- **Dirt、**：指出本题难点是开关打开的灯所在的点可达但相邻点已被访问导致难以加入队列，提醒注意所求的是能打开的灯数量而非能到达的点数量。

---
处理用时：58.98秒
# 题目信息

# [USACO16DEC] Moocast G

## 题目描述

Farmer John 的 $N$ 头奶牛（$1 \leq N \leq 1000$）希望组织一个紧急的“哞播”系统，用于在它们之间广播重要消息。

为了避免在长距离上互相哞叫，奶牛们决定为自己配备对讲机，每头奶牛一个。这些对讲机每个都有一个有限的传输半径，但奶牛们可以通过多次跳跃的路径中继消息，因此并非每头奶牛都需要能够直接与其他每头奶牛通信。

奶牛们需要决定在对讲机上花费多少钱。如果它们花费 $X$，每头奶牛将获得一个能够传输到 $\sqrt{X}$ 距离的对讲机。也就是说，两头奶牛之间的平方距离必须不超过 $X$，它们才能通信。

请帮助奶牛们确定 $X$ 的最小整数值，使得从任何一头奶牛发出的广播最终能够到达其他所有奶牛。

## 样例 #1

### 输入

```
4
1 3
5 4
7 2
6 1```

### 输出

```
17
```

# AI分析结果

### 综合分析与结论
本题的核心是找到最小的整数值 $X$，使得所有奶牛（点）都能连通。题解主要分为最小生成树（Kruskal、Prim）和二分答案两种思路。

最小生成树思路通过构建最小生成树，取其中最长边的平方作为答案；二分答案思路则是不断二分 $X$ 的值，检查在该值下所有点是否连通。

### 所选题解
- **作者：奔波儿霸 (赞：8)，4星**
  - **关键亮点**：思路清晰，直接使用 Kruskal 算法，代码实现简洁明了，对算法的解释也很清晰。
  - **个人心得**：无
- **作者：Chavapa (赞：1)，4星**
  - **关键亮点**：详细介绍了 Prim 算法的思想和正确性证明，对于理解 Prim 算法有很大帮助。
  - **个人心得**：无
- **作者：szbszb (赞：1)，4星**
  - **关键亮点**：选用更适合稠密图的 Prim 算法，使用堆优化，提高了效率。
  - **个人心得**：无

### 重点代码
#### 奔波儿霸的 Kruskal 算法实现
```cpp
inline void Kruskal() {
    for(int i=1; i<=n; i++) f[i] = i;
    for(int i=1; i<=n; i++) {
        for(int j=1; j<=n; j++) {
            if(i != j) {
                ++cnt;
                ed[cnt].u = i, ed[cnt].v = j, ed[cnt].w = sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]));
            }
        }
    }
    sort(ed+1, ed+1+cnt, cmp);
    for(int i=1; i<=cnt; i++) {
        int xx = find(ed[i].u), yy = find(ed[i].v);
        if(xx != yy) {
            f[xx] = find(yy);
            tot ++;
            Ans = ed[i].w;
        }
        if(tot == n-1) {
            break;
        }
    }
}
```
**核心思想**：先 $N^2$ 建边，将边按权值从小到大排序，然后使用并查集不断合并不连通的点，直到所有点连通，记录最小生成树中最长的边。

#### Chavapa 的 Prim 算法实现
```pascal
for i:=1 to n do
begin
    m:=INF;
    for j:=1 to n do
        if (not vis[j])and(min[j]<m) then
        begin
            m:=min[j]; u:=j;
        end;
    vis[u]:=true;
    for j:=1 to n do
        if (not vis[j])and(sqr(x[j]-x[u])+sqr(y[j]-y[u])<min[j]) then
            min[j]:=sqr(x[j]-x[u])+sqr(y[j]-y[u]);
end;
```
**核心思想**：初始将一个点加入最小生成树，维护一个 $min$ 数组记录每个点到最小生成树的最短距离，每次选择距离最小的点加入树中，并更新其他点到树的距离。

#### szbszb 的堆优化 Prim 算法实现
```cpp
while (q.size())
{
    u=q.top().second;
    q.pop();
    if (b[u]) continue;
    max1=max(max1,d[u]);//求出最大边权
    b[u]=true;
    for (i=1;i<=n;i++)
        if (d[i]>p[u][i])
        {
            d[i]=p[u][i];
            q.push(make_pair(-d[i],i));//prime
        }
}
```
**核心思想**：使用优先队列（堆）优化，每次取出距离最小的点，更新最大边权，标记该点，然后更新其他点到树的距离。

### 最优关键思路或技巧
- **避免精度问题**：在计算两点间距离时，直接存储距离的平方，避免开方运算带来的精度问题。
- **算法选择**：对于完全图（稠密图），Prim 算法效率更高；对于稀疏图，Kruskal 算法更优。

### 拓展思路
同类型题或类似算法套路：
- 求最小生成树中次大边、第 $k$ 大边等问题，可在构建最小生成树过程中记录相关信息。
- 对于图的连通性问题，除了最小生成树和二分答案，还可使用深度优先搜索、广度优先搜索等方法。

### 推荐洛谷题目
- P3366 【模板】最小生成树
- P2504 [HAOI2006]聪明的猴子
- P1195 口袋的天空

### 个人心得摘录与总结
- **OceanLiu**：注意数组大小，避免因数组越界导致 RE；使用 double 类型存储距离，防止精度问题。
- **haunter**：在某些数据上实数平方转整数时会炸精度，可加上一个小常数避免。 

---
处理用时：36.16秒
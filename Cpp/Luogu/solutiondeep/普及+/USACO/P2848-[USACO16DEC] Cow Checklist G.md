# 题目信息

# [USACO16DEC] Cow Checklist G

## 题目描述

每天，Farmer John 都会穿过他的牧场，检查每头奶牛的健康状况。他的农场里有两类奶牛：荷斯坦牛和根西牛。他的 $H$ 头荷斯坦牛被方便地编号为 $1 \ldots H$，而他的 $G$ 头根西牛被方便地编号为 $1 \ldots G$（$1 \leq H \leq 1000, 1 \leq G \leq 1000$）。每头奶牛都位于二维平面中的一个点（不一定不同）。

Farmer John 从荷斯坦牛 1 开始他的巡视，并在荷斯坦牛 $H$ 结束。他希望沿途访问每头奶牛，并且为了方便维护他已经访问过的奶牛清单，他希望按照编号顺序访问荷斯坦牛和根西牛。在他访问的所有 $H+G$ 头奶牛的序列中，编号为 $1 \ldots H$ 的荷斯坦牛应作为一个（不一定连续的）子序列出现，同样地，编号为 $1 \ldots G$ 的根西牛也应如此。换句话说，所有 $H+G$ 头奶牛的序列应通过将编号为 $1 \ldots H$ 的荷斯坦牛列表与编号为 $1 \ldots G$ 的根西牛列表交错排列而成。

当 Farmer John 从一头奶牛移动到另一头奶牛，移动距离为 $D$ 时，他会消耗 $D^2$ 的能量。请帮助他确定按照上述巡视方式访问所有奶牛所需的最小能量。

## 样例 #1

### 输入

```
3 2
0 0
1 0
2 0
0 3
1 3```

### 输出

```
20```

# AI分析结果

### 综合分析与结论
这些题解均采用动态规划（DP）解决问题。思路上，都定义了三维状态数组 `dp[i][j][0/1]`，`i` 表示访问到的荷斯坦牛数量，`j` 表示访问到的根西牛数量，`0/1` 表示当前所在牛的类型。通过状态转移方程计算最小能量消耗，方程考虑从前一状态转移过来的不同情况，并加上对应移动的能量消耗。

### 所选题解
- **作者：kara20（5星）**
    - **关键亮点**：思路清晰，详细分析了题目和状态定义的原因，对状态转移方程的推导有详细解释，代码注释丰富，可读性高。
    - **核心代码**：
```cpp
for(int i=1;i<=n;i++)
{
    for(int j=0;j<=m;j++)
    {
        f[i][j][0]=min(f[i][j][0],min(f[i-1][j][0]+dis1[i-1],f[i-1][j][1]+dis2[i][j]));
        if(j>0)f[i][j][1]=min(f[i][j][1],min(f[i][j-1][1]+dis3[j-1],f[i][j-1][0]+dis2[i][j]));//DP方程
    }
}
```
    - **核心思想**：通过两层循环遍历所有可能的状态，根据状态转移方程更新 `f[i][j][0]` 和 `f[i][j][1]` 的值，最终得到 `f[n][m][0]` 即为最小能量消耗。

- **作者：lnwhl（4星）**
    - **关键亮点**：思路简洁明了，状态定义和转移方程表达清晰，代码结构清晰，使用函数计算距离，提高了代码的复用性。
    - **核心代码**：
```cpp
inline int dis(int i,int j)//算出代价
{
    return (x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]);
}
for(int i=1;i<=n;++i)
    for(int j=0;j<=m;++j)
    {
        f[i][j][0]=min(f[i][j][0],min(f[i-1][j][0]+dis(i-1,i),f[i-1][j][1]+dis(i,n+j)));
        if(j)f[i][j][1]=min(f[i][j][1],min(f[i][j-1][1]+dis(n+j,n+j-1),f[i][j-1][0]+dis(i,n+j)));//转移
    }
```
    - **核心思想**：先定义 `dis` 函数计算两点间距离的平方，再通过两层循环遍历所有状态，根据状态转移方程更新 `f[i][j][0]` 和 `f[i][j][1]` 的值。

- **作者：sssscy_free_stdio（4星）**
    - **关键亮点**：思路直接，状态定义和方程表述清晰，代码简洁，注释明确。
    - **核心代码**：
```cpp
int cost(int i,int j){
    return (a[i]-a[j])*(a[i]-a[j])+(b[i]-b[j])*(b[i]-b[j]);
}
for(int i=1;i<=n;i++){
    for(int j=0;j<=m;j++){
        dp[i][j][0]=min(dp[i][j][0],min(dp[i-1][j][0]+cost(i-1,i),dp[i-1][j][1]+cost(i,n+j)));
        if(j!=0){
            dp[i][j][1]=min(dp[i][j][1],min(dp[i][j-1][0]+cost(i,n+j),dp[i][j-1][1]+cost(n+j-1,n+j)));
        }
    }
}
```
    - **核心思想**：定义 `cost` 函数计算两点间距离的平方，通过两层循环遍历所有状态，根据状态转移方程更新 `dp[i][j][0]` 和 `dp[i][j][1]` 的值。

### 最优关键思路或技巧
- **状态定义**：使用三维数组 `dp[i][j][0/1]` 记录状态，增加一维表示当前所在牛的类型，解决了无法计算最后一步花费的问题。
- **预处理距离**：提前计算所有牛之间的距离，避免在状态转移过程中重复计算，提高效率。

### 拓展思路
同类型题可考虑不同的约束条件，如增加牛的种类、改变起始和结束位置、增加移动规则等。类似算法套路可用于解决其他需要按顺序访问元素并计算最小代价的问题，如旅行商问题的变种。

### 推荐题目
- P1048 [NOIP2005 普及组] 采药
- P1216 [USACO1.5] 数字三角形 Number Triangles
- P1434 [SHOI2002] 滑雪

### 个人心得
- **作者：wangkelin123**：认为题目难读懂，但思路易理解，强调了预处理距离和状态数组初始化的重要性。
- **作者：nzcnnr**：提醒要开 `long long`，存储距离时将第二组续在第一组后更方便，注意第二组循环从 0 开始。 

---
处理用时：33.65秒
# 题目信息

# [USACO06NOV] Big Square S

## 题目背景

[English version](https://www.luogu.com.cn/paste/x781adew)

## 题目描述

农民 John 的牛参加了一次和农民 Bob 的牛的竞赛。他们在区域中画了一个$N\times N$ 的正方形点阵，两个农场的牛各自占据了一些点。当然不能有两头牛处于同一个点。农场的目标是用自己的牛作为$4$个顶点，形成一个面积最大的正方形 （不必须和边界平行） 。 除了 Bessie 以外，John其他的牛都已经放到点阵中去了，要确定Bessie放在哪个位置，能使得John的农场得到一个最大的正方形(Bessie不是必须参与作为正方形的四个顶点之一)。

## 样例 #1

### 输入

```
6
J*J***
******
J***J*
******
**B***
******```

### 输出

```
4```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何在给定的 $N\times N$ 点阵中，通过添加一个点（不能在 Bob 的点上），使 John 的点构成最大正方形展开。核心思路均为枚举，根据枚举对象不同可分为枚举对角线两点、同一条边两点、向量和顶点等方式。各题解在思路清晰度、代码可读性和优化程度上有所差异。

### 所选题解
- **作者：_____hzf_____（5星）**
    - **关键亮点**：思路清晰，详细阐述了以两点为对角线构造正方形的方法，通过图形辅助理解，代码注释详细，易于理解。
    - **个人心得**：无
    - **核心代码**：
```c
F(i,1,n)/*枚举右下的点的横坐标*/
    F(j,1,n)/*枚举右下的点的纵坐标*/
        F(k,1,i)/*枚举左上的点的横坐标*/
            F(tt,1,j){/*枚举左上的点的纵坐标*/
                if(a[i][j]=='B'||a[k][tt]=='B')/*如果有Bob的牛就continue*/
                    continue;
                int Sum=max(i-k,j-tt),Minus=min(i-k,j-tt);
                if((Sum&1)!=(Minus&1))/*细节！判断奇偶性是否相同*/ 
                    continue;
                int px=solve(Sum,Minus,'+'),py=solve(Sum,Minus,'-');/*计算出两式和与差*/
                int p=k+px,q1=tt+py,u=i-px,v=j-py;/*得出剩下两点*/
                if(((p-u)*(p-u)+(q1-v)*(q1-v))!=(Sum*Sum+Minus*Minus))/*考虑轴对称的情况*/
                    p=k+py,q1=tt+px,u=i-py,v=j-px;
                if(p>=1&&q1>=1&&u>=1&&v>=1&&p<=n&&q1<=n&&u<=n&&v<=n)
                    if(a[i][j]!='B'&&a[k][tt]!='B'&&a[p][q1]!='B'&&a[u][v]!='B'){
                        s=0;
                        if(a[i][j]=='J')
                            s++;
                        if(a[k][tt]=='J')
                            s++;
                        if(a[p][q1]=='J')
                            s++;
                        if(a[u][v]=='J')
                            s++;
                        if(s>=3&&px*px+py*py>ans){
                            ans=px*px+py*py;
                            a1=i;a2=j;a3=u;a4=v;
                            a5=k;a6=tt;a7=p;a8=q1;
                        }
                    }
            }
```
    - **核心思想**：枚举两个点作为正方形的对角线，通过计算得出另外两个点的坐标，判断点是否在点阵内且不是 Bob 的点，统计四个点中 John 的点的数量，若不少于 3 个则更新最大面积。

- **作者：tzyt（4星）**
    - **关键亮点**：详细推导了根据两点确定正方形另外两点坐标的方法，对代码进行了优化，减少了重复计算和无用判断。
    - **个人心得**：第一次提交代码有两个点超时，分析发现存在大量无用计算和重复枚举情况。通过修改判断条件，确保进入后续判断的点符合假设，减少重复计算；同时增加面积判断，若当前正方形面积小于等于已得答案则跳过判断，最终成功 AC。
    - **核心代码**：
```cpp
for (auto p1 : jc)
{
    for (auto p2 : jc)//通过枚举两个点来实现对于边的枚举
    {
        if ((p1.x == p2.x && p1.y == p2.y) || (p1.y < p2.y) || (((p1.y - p2.y) * (p1.y - p2.y) + (p1.x - p2.x) * (p1.x - p2.x)) <= ans))
        {
            continue;
        }
        //通过一条边确定的第一种正方形
        node p3;
        p3.x = (p2.x + (p1.y - p2.y));
        p3.y = (p2.y - (p1.x - p2.x));
        node p4;
        p4.x = (p1.x + (p1.y - p2.y));
        p4.y = (p1.y - (p1.x - p2.x));
        if (p3.x >= 0 && p3.y >= 0 && p4.x >= 0 && p4.y >= 0 && p3.x < n && p3.y < n && p4.x < n && p4.y < n)//判断合法性
        {
            if ((mp[p3.x][p3.y] == 1 && mp[p4.x][p4.y]!= -1) || (mp[p3.x][p3.y]!= -1 && mp[p4.x][p4.y] == 1))
            {
                ans = max(ans, (p1.y - p2.y) * (p1.y - p2.y) + (p1.x - p2.x) * (p1.x - p2.x));
            }
        }
        //通过一条边确定的第二种正方形
        p3.x = (p2.x - (p1.y - p2.y));
        p3.y = (p2.y + (p1.x - p2.x));
        p4.x = (p1.x - (p1.y - p2.y));
        p4.y = (p1.y + (p1.x - p2.x));
        if (p3.x >= 0 && p3.y >= 0 && p4.x >= 0 && p4.y >= 0 && p3.x < n && p3.y < n && p4.x < n && p4.y < n)//判断合法性
        {
            if ((mp[p3.x][p3.y] == 1 && mp[p4.x][p4.y]!= -1) || (mp[p3.x][p3.y]!= -1 && mp[p4.x][p4.y] == 1))
            {
                ans = max(ans, (p1.y - p2.y) * (p1.y - p2.y) + (p1.x - p2.x) * (p1.x - p2.x));
            }
        }
    }
}
```
    - **核心思想**：枚举两个 J 类点作为正方形的一条边，计算出另外两个点的坐标，判断点是否在点阵内且满足合法性条件，更新最大面积。同时进行优化，避免重复计算和无用判断。

- **作者：LittleAcbg（4星）**
    - **关键亮点**：通过证明所有正方形都有至少一条边满足 $dx\ge0,dy>0$，减少了枚举的情况，提高了效率。
    - **个人心得**：无
    - **核心代码**：
```cpp
for (int dx = 0; dx <= n - 1; ++dx)
    for (int dy = 1; dy <= n - 1; ++dy)
    // 枚举向量 (dx,dy)
    {
        // 最优性剪枝
        if (dx * dx + dy * dy <= ans) continue;
        for (int x = 1; x <= n; ++x)
            for (int y = 1; y <= n; ++y) // 枚举一个顶点 (x,y)
            {
                num = 0;
                legal = 1;
                // num 表示该正方形顶点上 J 的数量
                // legal 表示该正方形是否有顶点在边界外/有B
                work(x, y);
                work(x + dx, y + dy);
                work(x + dx + dy, y + dy - dx);
                work(x + dy, y - dx);
                if (legal && num >= 3)
                    ans = max(ans, dx * dx + dy * dy);
                // 只要合法并且有至少三个我方奶牛就更新答案
                // 有四个时就是合法正方形
                // 有三个时放 Bessie
            }
    }
```
    - **核心思想**：枚举向量 $(dx,dy)$ 和一个顶点 $(x,y)$，根据向量和顶点计算出正方形的四个顶点，判断顶点是否合法且至少有三个 John 的点，更新最大面积。同时进行最优性剪枝，若当前向量对应的面积小于等于已得答案则跳过。

### 最优关键思路或技巧
- **枚举优化**：如 tzyt 的题解，通过判断避免重复枚举和无用计算；LittleAcbg 的题解，证明所有正方形都有至少一条边满足 $dx\ge0,dy>0$，减少枚举情况。
- **利用图形辅助**：_____hzf_____ 的题解通过图形直观展示以两点为对角线构造正方形的方法，便于理解和计算。

### 拓展思路
同类型题可拓展到在二维平面中寻找满足特定条件的多边形，如矩形、三角形等，解题思路依然可以采用枚举法，根据多边形的性质计算其他顶点的坐标并判断合法性。

### 推荐题目
- [P1387 最大正方形](https://www.luogu.com.cn/problem/P1387)：在矩阵中寻找最大正方形，与本题在寻找正方形的思路上有相似之处。
- [P2730 [USACO3.2] 魔板 Magic Squares](https://www.luogu.com.cn/problem/P2730)：通过不同状态的转换寻找最优解，可锻炼枚举和状态判断的能力。
- [P1162 填涂颜色](https://www.luogu.com.cn/problem/P1162)：在二维矩阵中进行区域判断和处理，与本题在二维点阵的操作上有一定关联。

---
处理用时：60.91秒
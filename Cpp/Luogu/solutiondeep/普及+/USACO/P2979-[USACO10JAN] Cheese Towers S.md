# 题目信息

# [USACO10JAN] Cheese Towers S

## 题目描述

FJ 要建一个奶酪塔，高度最大为 $T\ (1 \le T \le 10^3)$ 。他有 $N\ (1 \le N \le 10^2)$ 种奶酪。第 $i$ 种奶酪的高度为 $H_i\ (5\le H_i \le T\text{ 且 }5 \mid H_i)$ ，价值为 $V_i\ (1 \le V_i \le 10^6)$ 。一块高度 $H_i\ge K\ (1 \le K \le T)$ 的奶酪被称为大奶酪，如果一个奶酪上方有大奶酪（如果有多块就只算一次），这个奶酪的高度 $H_i$ 就会变成原来的 $\frac{4}{5}$。FJ 想让他的奶酪塔价值和最大。请你求出这个最大值。

例如，考虑一种奶酪塔，其最大高度可以是 $53$，可以用三种类型的奶酪块建造。大块是大于或等于 $25$ 的块。下面是他堆叠的各种奶酪块的值和高度的图表：

|类型|价值|高度|
| :----------: | :----------: | :----------: |
|1|100|25|
|2|20|5|
|3|40|10|

FJ建造了以下奶酪塔：

|类型|价值|高度|
| :----------: | :----------: | :----------: |
|1|100|25|
|2|20|4|
|3|40|8|
|3|40|8|
|3|40|8|

总高度是 $25 + 4 + 8 + 8 + 8 = 53$，除塔顶奶酪外，其余高度均被压低。总价值是 $100 + 20 + 40 + 40 + 40 = 240$。

## 样例 #1

### 输入

```
3 53 25 
100 25 
20 5 
40 10 
```

### 输出

```
240 
```

# AI分析结果

### 综合分析与结论
本题核心是在完全背包基础上处理大奶酪对其他奶酪高度的影响。各题解主要思路为先判断最优解情况，再分别处理无大奶酪和有大奶酪在塔顶的情形。
- **思路要点**：多数题解发现最优解只有无大奶酪和大奶酪在塔顶两种情况。无大奶酪时用完全背包求解；有大奶酪时，枚举塔顶大奶酪，结合完全背包结果更新答案。
- **算法难点**：处理大奶酪影响是关键，涉及高度压缩及背包容量扩展。部分题解通过将背包容量扩大到\(T\times\frac{5}{4}\)解决，还有题解用二维数组区分有无大奶酪的状态。
- **复杂度**：时间复杂度多为\(O(nT)\)，少数为\(O(n^2T)\)。

### 所选题解
- **reek（5星）**
    - **关键亮点**：思路清晰，代码简洁，直接点明最优解情况并给出清晰实现步骤。
    - **核心代码**
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int n,T,k,ans,f[2000],v[1000],h[1000];
int main() {
    scanf("%d%d%d",&n,&T,&k);
    for (int i=1;i<=n;i++) {
        scanf("%d%d",&v[i],&h[i]);
        for (int j=h[i];j<=T*5/4;j++)
            f[j]=max(f[j],f[j-h[i]]+v[i]);
    }
    ans=f[T];
    for (int i=1;i<=n;i++)
        if (h[i]>=k) ans=max(ans,f[(T-h[i])*5/4]+v[i]);
    printf("%d\n",ans);
    return 0;
}
```
    - **实现思想**：先进行完全背包，将背包容量扩展到\(T\times\frac{5}{4}\)。然后将无大奶酪时的答案初始化为\(f[T]\)，再枚举大奶酪，用\(v[i]+f[(T - h[i])*5/4]\)更新答案。

- **Cxs3（4星）**
    - **关键亮点**：详细分析思考过程，对每种情况的处理解释清晰。
    - **核心代码**
```cpp
#include<bits/stdc++.h>
const int N=100+10;
const int T=5000;
using namespace std;

int n,t,k,ans;
int v[N],h[N],f[T];

int main()
{
    int i,j,now;
    cin>>n>>t>>k;
    for(i=1;i<=n;i++) cin>>v[i]>>h[i];
    for(i=1;i<=n;i++)
        for(j=h[i];j<=t*5/4;j++) f[j]=max(f[j],f[j-h[i]]+v[i]);
    ans=f[t];
    for(i=1;i<=n;i++)
    {
        if(h[i]<k) continue;
        now=v[i]+f[(t-h[i])*5/4];
        ans=max(ans,now);
    }
    cout<<ans<<endl;
    return 0;
}
```
    - **实现思想**：同样先做完全背包，容量扩展到\(t\times\frac{5}{4}\)。将无大奶酪答案初始化为\(f[t]\)，枚举大奶酪更新答案。

- **linyinuo2008（4星）**
    - **关键亮点**：详细讲解题意和算法步骤，对转移方程解释清晰。
    - **核心代码**
```cpp
#include <iostream>
using namespace std;

const int NR=105;
const int MR=1400;
int n,t,k;
int v[NR],h[NR],ans;
int f[MR];

int max(int a,int b)
{
    return a>b?a:b;
}

int main()
{
    f[0]=0;
    cin>>n>>t>>k;
    for(int i=1;i<=n;i++)
    {
        cin>>v[i]>>h[i];
    }
    for(int i=1;i<=n;i++)
    {
        for(int j=h[i];j<=t*5/4;j++)
        {
            f[j]=max(f[j],f[j-h[i]]+v[i]);
        }
    }
    ans=f[t];
    for(int i=1;i<=n;i++)
    {
        if(h[i]>=k)
            ans=max(ans,f[(t-h[i])*5/4]+v[i]);
    }
    cout<<ans;
    return 0;
}
```
    - **实现思想**：先进行完全背包，容量到\(t\times\frac{5}{4}\)。将无大奶酪答案设为\(f[t]\)，枚举大奶酪更新答案。

### 最优关键思路与技巧
- **贪心思想**：发现最优解只有无大奶酪和大奶酪在塔顶两种情况，简化问题。
- **背包容量扩展**：将背包容量扩大到\(T\times\frac{5}{4}\)，方便处理大奶酪下方奶酪高度压缩问题。

### 可拓展之处
同类型题如多重背包中物品有特殊影响（如某些物品会改变其他物品的重量或价值），可借鉴本题贪心和状态区分的思路。类似算法套路可用于处理有条件限制的背包问题，通过分析最优情况简化问题求解。

### 推荐题目
- P1616 疯狂的采药（完全背包模板题）
- P1833 樱花（多重背包问题）
- P1048 采药（0 - 1背包问题）

### 个人心得摘录与总结
- **Kirisame_Marisa_**：解释了完全背包不判大奶酪、循环到\(\frac{5}{4}T\)和只枚举一个大奶酪的原因，强调考虑奶酪被压缩后的原始体积。
- **MilkyCoffee**：提醒计算完无大奶酪要保存答案，有大奶酪时注意高度乘\(\frac{4}{5}\)，答案要减去大奶酪高度再加价值。 

---
处理用时：37.82秒
# 题目信息

# [USACO15JAN] Meeting Time S

## 题目描述

$\texttt{Bessie}$ 和她的妹妹 $\texttt{Elsie}$ 想从粮仓去她们最喜欢的田地，也就是能够使她们一起从粮仓离开，并且能同一时间到达的田地。

这个农场是由 $N$ 块 $(1\leq N\leq 100)$ 编号为 $1\cdots N$ 的田地构成的，第一块田地就是粮仓，并且第 $N$ 块田地是她们最喜欢的田地。

这个农场建在山的一边，所以，如果 $X < Y$ 的话则满足第 $X$ 块田地的高度要高于第 $Y$ 块田地的高度。在这之中，有 $M$ 条交错纵横的路径将不同的田地连接起来。

不过，显而易见的是，因为每条路都太陡了，所以这些小路只能沿着从高到低的方向走。例如，一条连接第 $5$ 块田地和 $8$ 块田地的小路只能沿着 $5\to 8$ 的方向走，而不能沿着其他方向，因为那样会成为上坡路。每两块田地最多只能有一条路径相连接，所以一定有 $M \leq \dfrac{N(N-1)}{2}$。

有可能的是，$\texttt{Bessie}$ 和 $\texttt{Elsie}$ 两个人走同一条小路会耗费不同的时间；比如，通过同一条小路，$\texttt{Bessie}$ 可能会耗费 $10$ 个单位的时间，而 $\texttt{Elsie}$ 会耗费 $20$ 个单位的时间。

此外，$\texttt{Bessie}$ 和 $\texttt{Elsie}$ 只会在通过连接两块田地的小路时耗费时间——因为她们太匆忙了，在穿过田地时不会耗费任何时间，也从来不在任何地方停下来等待。

现在，请你判断出，能够满足使 $\texttt{Bessie}$ 和 $\texttt{Elsie}$ 同时出发并且同时到达她们喜欢的田地的最短的时间。

## 说明/提示

$\texttt{Bessie}$ 在每一条路都比 $\texttt{Elsie}$ 快两倍。

如果 $\texttt{Bessie}$ 经过 $1\to 2\to 3$ 的路线，$\texttt{Elsie}$ 经过 $1\to 3$ 的路线，他们可以同时到达。

## 样例 #1

### 输入

```
3 3 
1 3 1 2 
1 2 1 2 
2 3 1 2 
```

### 输出

```
2 ```

# AI分析结果

### 综合分析与结论
这些题解主要围绕寻找两只奶牛同时到达终点的最短时间展开，涉及动态规划、拓扑排序、搜索优化、K短路等多种算法。其中，拓扑排序与动态规划结合的思路较为常见，通过记录不同时间能否到达不同节点，逐步更新状态，最终找到满足条件的最短时间。部分题解还采用了搜索优化，如A*算法，通过优先队列和期望估计来提高效率。此外，还有题解使用了K短路算法，枚举所有可能的路径长度进行比较。

### 所选题解
- 作者：amstar (赞：9)，4星
  - 关键亮点：思路清晰，使用拓扑排序结合动态规划，保证动规的无后效性，代码实现简洁明了。
  - 个人心得：提到不用拓扑居然也可能过，反映出数据的局限性以及对算法本质的思考。
- 作者：若如初见 (赞：5)，4星
  - 关键亮点：明确指出图为有向无环图，采用拓扑排序 + DP 的方法，状态设计和转移方程清晰，代码注释详细。
- 作者：qscisQJing (赞：0)，4星
  - 关键亮点：提出了普通动态规划和使用 bitset 优化的两种方法，详细分析了时间复杂度，展示了优化思路。

### 重点代码
#### amstar 题解核心代码
```cpp
// 拓扑排序 + 动态规划
while (!q.empty())
{
    int u = q.front();
    q.pop();
    for (int i=head[u]; i; i=e[i].nxt)
    {
        int w1 = e[i].w1, w2 = e[i].w2, v = e[i].to;
        for (int j=0; j+w1<MAXE; ++j) f[v][j+w1] |= f[u][j];
        for (int j=0; j+w2<MAXE; ++j) g[v][j+w2] |= g[u][j];
        ru[v]--;
        if (!ru[v]) q.push(v);
    }
}
```
核心思想：利用拓扑排序保证节点处理顺序的正确性，通过动态规划更新不同节点在不同时间的可达性。

#### 若如初见 题解核心代码
```cpp
// 拓扑排序 + DP
while(!q.empty()){
    int u=q.front();
    q.pop();
    for(rint i=head[u];i;i=edge[i].next){
        int v=edge[i].to;
        for(rint j=0;j<=10000;++j){
            if(j-edge[i].w1>=0) f1[v][j]|=f1[u][j-edge[i].w1];
            if(j-edge[i].w2>=0) f2[v][j]|=f2[u][j-edge[i].w2];
        }
        if(--ind[v]==0) q.push(v);
    }
}
```
核心思想：同样采用拓扑排序和动态规划，根据边的权值更新状态数组，找到满足条件的最短时间。

#### qscisQJing 题解核心代码（bitset 优化）
```cpp
// bitset 优化的动态规划
for(int i=2;i<=n;i++)
{
    for(auto u:ve[i])
    {
        c[i]=c[i]|(c[u.v]<<u.w1);
        d[i]=d[i]|(d[u.v]<<u.w2);
    }
}
```
核心思想：使用 bitset 优化动态规划的转移过程，提高效率。

### 最优关键思路或技巧
- **拓扑排序与动态规划结合**：利用拓扑排序保证动态规划的无后效性，按照节点的拓扑顺序更新状态，避免重复计算。
- **状态设计**：通过二维数组记录不同节点在不同时间的可达性，清晰地表示问题的状态。
- **bitset 优化**：在动态规划中使用 bitset 可以减少空间复杂度和时间复杂度，提高算法效率。

### 可拓展之处
同类型题：涉及有向无环图的路径规划问题，如求最长路径、最短路径、特定条件下的路径等。
类似算法套路：可以使用拓扑排序结合其他算法，如贪心、搜索等，解决不同的问题。

### 推荐题目
- P1113 杂务：涉及有向无环图的拓扑排序和动态规划。
- P1807 最长路：有向无环图的最长路径问题。
- P2085 最小函数值：可以使用优先队列和动态规划解决。

### 个人心得摘录与总结
- amstar：提到不用拓扑居然也可能过，说明在实际做题中，数据的局限性可能导致一些看似错误的做法通过测试，提醒我们要深入理解算法的本质。
- Kancolle砍口垒：表示自己非常懒，直接写了搜索优化，反映出在面对问题时，可以根据数据范围选择合适的算法，即使是简单粗暴的方法也可能通过。

---
处理用时：38.29秒
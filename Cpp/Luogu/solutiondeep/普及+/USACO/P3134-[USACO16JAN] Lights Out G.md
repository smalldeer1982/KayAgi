# 题目信息

# [USACO16JAN] Lights Out G

## 题目描述

Farmer John 在他的谷仓里安装了一个非常不错的新挤奶机，但是这台挤奶机耗电太多了，有时候会让谷仓直接停电！这种事发生的太频繁了，以至于 Bessie 直接把谷仓的地图背过了，以便于可以在黑暗中找到谷仓的出口。她对于停电对于她快速离开谷仓的能力的影响非常好奇。比如说，她想知道她在黑暗中需要走多远来找到谷仓的出口。

谷仓里的路可以被描述为是一个简单的用几个顶点来表示的多边形，这些顶点可以按照顺时针被表示为 $(x_1, y_1) \cdots (x_n, y_n)$（保证这些顶点连成的线没有交叉的情况）。这些点构成的边在水平轴（平行于 $x$ 轴）和竖直轴（平行于 $y$ 轴）之间交替出现。第一条边可以是任意一种类型。谷仓出口在坐标 $(x_1, y_1)$ 。Bessie 从谷仓内任意一个点 $(x_i, y_i)$ 开始走。她只可以沿着这些边走，要不然是顺时针，要不然就是逆时针，她的目标就是以最短距离抵达出口。当然，如果灯亮着的话这个事还算相对简单，因为她要不然顺时针要不然逆时针走，无所谓哪个方向的路程更短一点。

一天，谷仓突然停电了，导致 Bessie 受到惊吓、忘记了她站在哪个顶点。幸亏她还记得谷仓的准确地图，所以她可以四处走走，用她的触觉来弄清楚她的位置。不管什么时候，只要她站在一个顶点，那么她就可以感受到她在这个点的朝向角度，弄清楚这个点是不是出口。当她沿着谷仓的一个边走完的时候，她可以算出精确的边长。Bessie 决定用这么一个策略：她会顺时针沿着谷仓周围的边走，直到她知道了足够的角度和边、可以推断出她目前在的是哪个顶点。在那个顶点，她就可以轻易地弄清楚怎样以最短距离到达出口（要不然继续沿着顺时针走，要不然倒回去沿着逆时针走）。

请帮助 Bessie 算出在起点可以是任何一个顶点情况下，在最坏的情况下，她在黑暗中和亮着灯的时候到达出口的距离的差值（即找到差值的最大值）。

## 说明/提示

在这个样例中，Bessie 开始可以感觉到她沿着 $90 \degree$ 角站着，但是她辨别不出来她是在 $2, 3, 4$ 中的哪一个顶点。

在走了一条边以后，Bessie 要不然到了出口要不然就可以根据她走过的距离推断出她的位置。情况如下：

如果她从 $2$ 号点开始走，她需要在黑暗中走 $12$ 个单位，包括一个单位到达第三个点、十一个单位离开谷仓。同时，如果亮着灯，她可以只走 $10$ 个单位就离开谷仓。差值是 $2$ 。

如果从 $3$ 号点开始，她两种情况都要走 $11$ 个单位。

如果从 $4$ 号点开始，她两种情况都要走 $1$ 个单位。

所以最坏情况差值是 $2$ 。

## 样例 #1

### 输入

```
4
0 0
0 10
1 10
1 0```

### 输出

```
2```

# AI分析结果

### 综合分析与结论
这些题解的核心思路都是模拟 Bessie 在黑暗中顺时针行走，通过记录路径信息（如边长、内角等）来确定自己的位置，再计算黑暗中行走与亮灯时行走的距离差值，取最大值。各题解的主要区别在于路径信息的记录方式和判断路径唯一性的方法，主要使用了哈希、字符串、`vector` 搭配 `map` 等方式。

### 所选题解
- **作者：Noir_ (赞：3)，4星**
    - **关键亮点**：思路清晰，详细阐述了字符串哈希的实现过程，对可能出现的问题进行了分析和处理，代码注释详细。
    - **个人心得**：提到码风较奇葩，是压行强迫症和卡常小能手，欢迎觉得做法麻烦或有错误的巨佬来喷。
- **作者：Violet___Evergarden (赞：1)，4星**
    - **关键亮点**：使用 `vector` 和 `map` 存储路径信息和统计路径数量，代码简洁易懂。

### 重点代码
#### 作者：Noir_
```cpp
inline void add(register string &mode,const int x){
    if(a[x].lr) mode+='R';else mode+='L';//左右转
    register string s;register int tmp=a[x].len;//路径长度
    while(tmp) s+=char((tmp%10)|48),tmp/=10;
    reverse(s.begin(),s.end());mode+=s;mode+=' ';//新加一个空格（或其他字符也行）
}
inline int count(const string &a,register string b,const char c){
    b+=c;//临时加入下一次转向的方向符号
    register size_t pos=0;register int cnt=0;
    while((pos=a.find(b,pos))!=string::npos) ++cnt,++pos;
    return cnt;
}
inline void solve(const int now){
    register string path;
    register int sum=0;
    for(register int i=now;i<=n;i++){
        if(count(mode,path,a[i].lr?'R':'L')==1) return void(ans=max(ans,abs(dis[now]-(sum+dis[i]))));
        add(path,i),sum+=a[i].len;
    }
}
```
**核心实现思想**：`add` 函数将路径信息（转向和边长）添加到字符串中，`count` 函数统计路径在地图中出现的次数，`solve` 函数模拟 Bessie 从某个点出发，当路径唯一时计算距离差值并更新答案。

#### 作者：Violet___Evergarden
```cpp
for(int i=2;i<=n;i++)//最开始走一遍，预处理map
{
  path.clear();
  for(int j=i;j<=n;j++)
  {
    int jiao=(Cj(j-1,j,(j==n?1:j+1))>0?1:0);
    path.push_back(jiao);
    mp[path]++;
    path.push_back(Dis(j,(j==n?1:j+1)));
  }
}
for(int i=2;i<=n;i++)//走第二遍，计算答案
{
  path.clear();
  for(int j=i;j<=n;j++)
  {
    int jiao=(Cj(j-1,j,(j==n?1:j+1))>0?1:0);
    path.push_back(jiao);
    if(mp[path]==1||j==n)
    {
      ans=max(ans,dis[j]-dis[i]+min(dis[j],dis[1]-dis[j])-min(dis[i],dis[1]-dis[i]));
      break;
    }
    path.push_back(Dis(j,(j==n?1:j+1)));
  }
}
```
**核心实现思想**：第一遍遍历预处理 `map`，统计每种路径的数量；第二遍遍历模拟 Bessie 行走，当路径唯一时计算距离差值并更新答案。

### 最优关键思路或技巧
- 使用哈希、字符串、`vector` 搭配 `map` 等方式记录路径信息，方便判断路径的唯一性。
- 预处理每个点到出口的最短距离，减少重复计算。

### 可拓展之处
同类型题可能涉及更复杂的地图结构或更多的行走规则，类似算法套路可以应用于路径规划、位置识别等问题中。

### 推荐题目
- [P1135 奇怪的电梯](https://www.luogu.com.cn/problem/P1135)
- [P1605 迷宫](https://www.luogu.com.cn/problem/P1605)
- [P1002 [NOIP2002 普及组] 过河卒](https://www.luogu.com.cn/problem/P1002)

---
处理用时：36.26秒
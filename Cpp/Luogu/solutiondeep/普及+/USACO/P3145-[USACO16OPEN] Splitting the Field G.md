# 题目信息

# [USACO16OPEN] Splitting the Field G

## 题目描述

Farmer John 的 $N$ 头奶牛（$3 \leq N \leq 50,000$）位于他二维牧场的不同位置。FJ 想要用一个与 x 轴和 y 轴平行的矩形围栏将所有奶牛围住，并且他希望这个围栏尽可能小，以便它包含每一头奶牛（允许奶牛位于边界上）。

由于上季度牛奶产量低，FJ 的预算紧张。因此，他希望围住更小的区域以减少维护成本，而他唯一能想到的方法就是建造两个围栏而不是一个。请帮助他计算使用两个围栏而不是一个围栏总共可以减少多少面积。与原始围栏一样，这两个围栏必须共同包含所有奶牛（允许奶牛位于边界上），并且它们的边必须与 $x$ 轴和 $y$ 轴平行。这两个围栏不允许重叠——即使在它们的边界上也不行。注意，零面积的围栏是合法的，例如如果一个围栏的宽度和/或高度为零。

## 样例 #1

### 输入

```
6
4 2
8 10
1 1
9 12
14 7
2 3```

### 输出

```
107```

# AI分析结果

### 综合分析与结论
这些题解的核心思路都是先求出用一个矩形围住所有点的面积，再通过将点按 $x$ 轴或 $y$ 轴排序并枚举分割点，计算用两个矩形围住所有点的最小面积，最后用一个矩形的面积减去两个矩形的最小面积得到结果。

在实现过程中，主要难点在于如何高效地求出区间内的最大和最小值，不同题解采用了不同的方法，如 RMQ 算法（ST 表）、线段树、递推预处理等。

### 所选题解
- **作者：Outer_Horizon (赞：7)，4星**
  - **关键亮点**：思路清晰，详细阐述了使用 RMQ 算法优化区间最值查询的过程，代码注释丰富，可读性强。
  - **个人心得**：强调了不开 `long long` 会出错、RMQ 要设置初始值等注意事项。
- **作者：caddy (赞：7)，4星**
  - **关键亮点**：通过排序和递推预处理的方式，简洁地解决了区间最值问题，代码逻辑清晰。
  - **个人心得**：通过画图直观地展示了沿 $x$ 轴和 $y$ 轴划分矩形的方法。
- **作者：Hoks (赞：3)，4星**
  - **关键亮点**：对 RMQ 算法进行了详细的科普，代码实现规范，使用了快读优化输入。
  - **个人心得**：提醒求最小值时不要忘了初始化。

### 重点代码
#### Outer_Horizon 的 RMQ 初始化和查询代码
```cpp
void rmq(){
    // 初始化
    for (int i = 0; i <= n; i++){
        for (int j = 0; j <= 30; j++){
            fx[i][j][0] = fy[i][j][0] = 1e20;
        }
    }
    for (int i = 1; i <= n; i++) fx[i][0][0] = fx[i][0][1] = a[i].x, fy[i][0][0] = fy[i][0][1] = a[i].y;

    for (int j = 1; j <= 30; j++){
        for (int i = 1; i + (1 << j) - 1 <= n; i++){
            fx[i][j][0] = min(fx[i][j - 1][0], fx[i + (1 << j - 1)][j - 1][0]);
            fx[i][j][1] = max(fx[i][j - 1][1], fx[i + (1 << j - 1)][j - 1][1]);
            fy[i][j][0] = min(fy[i][j - 1][0], fy[i + (1 << j - 1)][j - 1][0]);
            fy[i][j][1] = max(fy[i][j - 1][1], fy[i + (1 << j - 1)][j - 1][1]);
        }
    }
}
int find(int l, int r){  // l - r 区间内的面积
    t = log2(r - l + 1);
    lx = max(fx[l][t][1], fx[r - (1 << t) + 1][t][1]);
    rx = min(fx[l][t][0], fx[r - (1 << t) + 1][t][0]);
    ly = max(fy[l][t][1], fy[r - (1 << t) + 1][t][1]);
    ry = min(fy[l][t][0], fy[r - (1 << t) + 1][t][0]);
    return (lx - rx) * (ly - ry);
}
```
**核心实现思想**：先初始化 RMQ 数组，然后通过动态规划的方式计算区间内的最大和最小值，最后根据最大最小值计算矩形面积。

#### caddy 的递推预处理代码
```cpp
aminyzuo[0]=bminxxia[0]=0x7fffffff;
for(int i=1;i<=n;i++)
    aminyzuo[i]=min2(aminyzuo[i-1],a[i].y),amaxyzuo[i]=max2(amaxyzuo[i-1],a[i].y),
    bminxxia[i]=min2(bminxxia[i-1],b[i].x),bmaxxxia[i]=max2(bmaxxxia[i-1],b[i].x);
aminyyou[n+1]=bminxshang[n+1]=0x7fffffffffff;
for(int i=n;i>=1;i--)
    aminyyou[i]=min2(a[i].y,aminyyou[i+1]),amaxyyou[i]=max2(a[i].y,amaxyyou[i+1]),
    bminxshang[i]=min2(b[i].x,bminxshang[i+1]),bmaxxshang[i]=max2(b[i].x,bmaxxshang[i+1]);//递推预处理最大与最小值
```
**核心实现思想**：通过两次遍历，分别从左到右和从右到左递推预处理出每个点左右或上下区域的最大和最小值。

#### Hoks 的 RMQ 初始化和查询代码
```cpp
for(int i=1;i<=n;i++) f[i][0][0][0]=f[i][0][0][1]=e[i].x,f[i][0][1][0]=f[i][0][1][1]=e[i].y;
for(int i=0;i<=n;i++)
    for(int j=1;j<=16;j++)
        f[i][j][1][1]=f[i][j][0][1]=0x3f3f3f3f3f3f3f3f;
for(int j=1;j<=16;j++)
    for(int i=0;i<=n-(1<<j)+1;i++)
        f[i][j][0][0]=max(f[i][j-1][0][0],f[i+(1<<j-1)][j-1][0][0]),f[i][j][0][1]=min(f[i][j-1][0][1],f[i+(1<<j-1)][j-1][0][1]),
        f[i][j][1][0]=max(f[i][j-1][1][0],f[i+(1<<j-1)][j-1][1][0]),f[i][j][1][1]=min(f[i][j-1][1][1],f[i+(1<<j-1)][j-1][1][1]);
//f[i][j]后面的第一个维度表示 横坐标 或 纵坐标 ，第二个维度表示 最大值 或 最小值
```
**核心实现思想**：与 Outer_Horizon 的 RMQ 实现类似，通过动态规划的方式计算区间内的最大和最小值。

### 最优关键思路或技巧
- **排序枚举**：将点按 $x$ 轴或 $y$ 轴排序，然后枚举分割点，将点分成两部分，计算两个矩形的面积和。
- **区间最值优化**：使用 RMQ 算法（ST 表）、线段树或递推预处理等方法，高效地求出区间内的最大和最小值。

### 可拓展之处
同类型题或类似算法套路：
- 计算几何中涉及矩形覆盖、面积计算的问题。
- 区间最值查询问题，可使用 RMQ 算法、线段树等数据结构解决。

### 推荐题目
- [P1440 求m区间内的最小值](https://www.luogu.com.cn/problem/P1440)：RMQ 算法的典型应用。
- [P3865 【模板】ST 表](https://www.luogu.com.cn/problem/P3865)：练习 RMQ 算法的模板题。
- [P1198 [JSOI2008] 最大数](https://www.luogu.com.cn/problem/P1198)：涉及区间最大值查询的问题。

### 个人心得总结
- **数据类型**：由于数据较大，要使用 `long long` 类型，避免溢出。
- **初始化**：RMQ 算法、数组等需要进行正确的初始化，否则可能导致结果错误。
- **边界处理**：在枚举分割点和计算区间最值时，要注意边界条件的处理，避免越界。

---
处理用时：53.93秒
# 题目信息

# [USACO16OPEN] 248 G

## 题目描述

贝西喜欢在手机上下载游戏来玩，尽管她确实觉得对于自己巨大的蹄子来说，小小的触摸屏用起来相当笨拙。

她对当前正在玩的这个游戏特别感兴趣。游戏开始时给定一个包含 $N$ 个正整数的序列（$2 \leq N \leq 248$），每个数的范围在 $1 \ldots 40$ 之间。在一次操作中，贝西可以选择两个相邻且相等的数，将它们替换为一个比原数大 1 的数（例如，她可以将两个相邻的 7 替换为一个 8）。游戏的目标是最大化最终序列中的最大数值。请帮助贝西获得尽可能高的分数！

## 说明/提示

在示例中，贝西首先合并第二个和第三个 1，得到序列 1 2 2，然后将两个 2 合并为 3。注意，合并前两个 1 并不是最优策略。

## 样例 #1

### 输入

```
4
1
1
1
2```

### 输出

```
3```

# AI分析结果

### 综合分析与结论
这些题解主要围绕区间 DP 和其他特殊 DP 方法来解决合并数字求最大值的问题。大部分题解采用区间 DP 思路，通过定义不同状态和转移方程求解。部分题解使用贪心、栈模拟等方法。

区间 DP 是主流思路，关键在于状态定义和转移条件的确定。部分题解考虑了转移时的边界情况，避免未更新值的错误更新。不同题解的时间复杂度有所差异，区间 DP 通常为 $O(N^3)$，部分优化后的 DP 为 $O(47N)$。

### 所选题解
- **xiejinhao（5 星）**
  - **关键亮点**：思路清晰，详细讲解区间 DP 思路，指出常见错误及解决方法，还给出另一种 DP 做法及分析，代码注释详细。
  - **个人心得**：强调区间 DP 真正的难点在于转移条件和如何想到转移，学好 DP 要多做题。
- **LZDQ（4 星）**
  - **关键亮点**：从游戏 2048 角度思考，推出 $O(n^2)$ 算法，思路新颖，代码简洁。
  - **个人心得**：玩游戏有助于提升思维，在解题时不能总用套路。
- **ShineEternal（4 星）**
  - **关键亮点**：清晰阐述区间 DP 思路，包括状态定义、转移条件和答案输出注意事项，代码简洁。

### 重点代码
#### xiejinhao - 区间 DP 代码
```cpp
#include<iostream>
#include<cstdio>
using namespace std;

const int N = 250;
int f[N][N];

int main() {
    int n, ans = 0;
    scanf("%d", &n);
    for(int i = 1; i <= n; i++) {
        scanf("%d", f[i] + i);
        ans = max(ans, f[i][i]);
    }

    for(int len = 2; len <= n; len++) 
        for(int l = 1; l + len - 1 <= n; l++) {
            int r = l + len - 1;
            for(int k = l; k < r; k++) 
                if(f[l][k] == f[k + 1][r] && f[l][k]) {
                    f[l][r] = max(f[l][r], f[l][k] + 1);
                    ans = max(ans, f[l][r]);
                }
        }

    printf("%d\n", ans);		
    return 0;
} 
```
**核心思想**：定义 $f[l][r]$ 表示从左端点 $l$ 到右端点 $r$ 合并能获得的最大分值。枚举区间长度、左端点和断点，当左右子区间值相等且不为 0 时更新 $f[l][r]$，同时记录最大值。

#### LZDQ - 栈模拟代码
```cpp
#include<cstdio>
const int MAXN=250;
int n;
int a[MAXN];
int top,stk[MAXN];
int ans;
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++){
        scanf("%d",a+i);
        stk[top=1]=a[i];
        for(int j=i-1;j>0;j--){
            if(a[j]>stk[top]) break;	
            stk[++top]=a[j];	
            while(top>1&&stk[top]==stk[top-1])
                stk[--top]++;	
        }
        if(ans<stk[1]) ans=stk[1];	
    }
    printf("%d\n",ans);
    return 0;
}
```
**核心思想**：枚举右端点，从右端点往左扫，用栈存储扫过的数，若栈顶两个数相等则合并，最后栈底为当前右端点合并后的最大值，更新答案。

#### ShineEternal - 区间 DP 代码
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int f[300][300];
int main()
{
    int n,ans=0;
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&f[i][i]);
        ans=max(ans,f[i][i]);
    }
    for(int dis=2;dis<=n;dis++)
    {
        for(int l=1;l+dis-1<=n;l++)
        {
            int r=l+dis-1;
            for(int k=l;k<r;k++)
            {
                if(f[l][k]==f[k+1][r]&&f[l][k])
                {
                    f[l][r]=max(f[l][k]+1,f[l][r]);
                }
            }
            ans=max(ans,f[l][r]);
        }
    }
    printf("%d\n",ans);
    return 0;
}
```
**核心思想**：定义 $f[l][r]$ 表示区间 $[l,r]$ 里的数经过合并可以得到的最大的一个数。枚举区间长度、左端点和断点，当左右子区间值相等且不为 0 时更新 $f[l][r]$，同时记录最大值。

### 最优关键思路或技巧
- **区间 DP 思路**：对于合并类问题，可考虑区间 DP，通过枚举区间长度、左右端点和断点来更新状态。
- **状态定义技巧**：根据题目特点合理定义状态，如 $f[l][r]$ 表示区间 $[l,r]$ 的合并最大值，或 $f[i][k]$ 表示第 $i$ 个数合并得到数值为 $k$ 能向右拓展的最右端点。
- **边界处理**：注意转移时的边界情况，避免未更新值的错误更新。

### 可拓展之处
同类型题如石子合并问题，都是通过合并相邻元素求最优解，可使用区间 DP 解决。类似算法套路包括状态定义时考虑区间信息，转移时枚举断点，利用小区间更新大区间。

### 推荐题目
- P1880 [NOI1995] 石子合并
- P4170 [CQOI2007] 涂色
- P3205 [HNOI2010] 合唱队

### 个人心得总结
- xiejinhao 强调区间 DP 难点在于转移条件和如何想到转移，学好 DP 要多做题。
- LZDQ 指出玩游戏有助于提升思维，解题时不能总用套路。 

---
处理用时：46.18秒
# 题目信息

# [USACO17JAN] Balanced Photo G

## 题目描述

FJ 正在安排他的 $N$ 头奶牛站成一排来拍照（$1\le N \le 10^5$）。序列中的第 $i$ 头奶牛的高度是 $h_i$，且序列中所有的奶牛的身高都不同。

就像他的所有牛的照片一样，FJ希望这张照片看上去尽可能好。他认为，如果 $L_i$ 和 $R_i$ 的数目相差 $1$ 倍以上，第 $i$ 头奶牛就是不平衡的（$L_i$ 和 $R_i$ 分别代表第 $i$ 头奶牛左右两边比她高的奶牛的数量）。也就是说，如果 $L_i$ 和 $R_i$ 中的较大数大于较小数的 $2$ 倍，第 $i$ 头奶牛就是不平衡的。FJ 不希望他有太多的奶牛不平衡。

请帮助 FJ 计算不平衡的奶牛数量。

## 样例 #1

### 输入

```
7
34
6
23
0
5
99
2```

### 输出

```
3```

# AI分析结果

### 综合分析与结论
本题主要求解不平衡奶牛的数量，关键在于高效计算每头奶牛左右两边比它高的奶牛数量。各题解普遍先想到 $O(n^2)$ 的暴力枚举法，但因数据规模较大，需借助数据结构优化。常见的数据结构有树状数组、主席树、平衡树、划分树等，其中树状数组使用最为频繁，因其代码简洁、实现方便。

### 所选题解
- **作者：nihanchu (赞：19) - 4星**
  - **关键亮点**：思路清晰，详细阐述了使用树状数组优化的过程，代码注释丰富，易于理解。
  - **核心代码**：
```cpp
// 单点更新
void update(int x,int v)
{
    while (x<=n)
    {
        f[x]+=v;
        x+=lowbit(x);
    }
}
// 查询前缀和
int query(int x)
{
    int sum=0;
    while (x>0) 
    {
      sum+=f[x];
      x-=lowbit(x);
    }
    return sum;
}
for (int i=1;i<=n;i++)
{
    l=query(b[i]);// 查询左边比它大的奶牛数量
    r=b[i]-l-1;// 右边比它大的数量
    if ((l*2<r)||(r*2<l)) ans++;// 记录不平衡数量
    update(b[i],1);// 更新，这头奶牛已经被枚举过了
}
```
  - **核心实现思想**：先将奶牛按身高从大到小排序，用树状数组维护一个标记数组 `f`，表示每头奶牛是否已被枚举。枚举过程中，通过查询前缀和得到左边比当前奶牛高的数量，再计算出右边比它高的数量，判断是否不平衡并更新答案。

- **作者：小蒟蒻皮皮鱼 (赞：13) - 4星**
  - **关键亮点**：明确指出题目翻译可能存在的问题，思路简洁明了，代码简洁。
  - **核心代码**：
```cpp
int lowbit(int x) {return x & -x;}
void Add(int x, int k){for(; x <= n; x += lowbit(x)) iSum[x] += k;}
int Query(int x){int ans = 0;for(; x; x -= lowbit(x)) ans += iSum[x];return ans;}
for(int i = 1; i <= n; i++)
{
    Add(Cow[i].iBh, 1);
    int l = Query(Cow[i].iBh - 1);
    int r = i - l - 1;
    if(max(l, r) > 2 * min(l, r)) iAns++;
}
```
  - **核心实现思想**：同样先对奶牛按身高从大到小排序，利用树状数组维护前缀和。枚举时，插入当前奶牛并查询其左边比它高的数量，计算右边比它高的数量，判断是否不平衡并更新答案。

- **作者：曹老师 (赞：3) - 4星**
  - **关键亮点**：准确指出知识点为 BIT（树状数组），时间复杂度分析清晰，代码规范。
  - **核心代码**：
```cpp
int query(int x)
{
    int sum=0;
    for(int i=x;i>=1;i-=lowbit(i))
        sum+=bit[i];
    return sum;
}
void update(int x,int v)
{
    for(int i=x;i<=n;i+=lowbit(i))
        bit[i]+=v;
}
for(int i=1;i<=n;i++)
{
    int l=query(c[i]),r=c[i]-l-1;
    update(c[i],1);
    if(l>r*2||r>2*l)
        ans++;
}
```
  - **核心实现思想**：对奶牛按身高从大到小排序并离散化，用树状数组维护前缀和。枚举过程中，查询左边比当前奶牛高的数量，计算右边比它高的数量，判断是否不平衡并更新答案。

### 最优关键思路或技巧
- **排序与离散化**：先将奶牛按身高从大到小排序，方便后续计算比当前奶牛高的数量。对于数据范围较大的情况，可进行离散化处理，将数据映射到较小的区间。
- **树状数组优化**：树状数组可高效实现单点修改和区间查询，将时间复杂度从 $O(n^2)$ 优化到 $O(nlogn)$。

### 可拓展之处
同类型题目通常涉及区间统计、逆序对计算等问题，可使用树状数组、线段树、主席树、平衡树等数据结构优化。例如，在计算区间第 $k$ 大、区间和、区间最值等问题时，可根据具体情况选择合适的数据结构。

### 推荐题目
- [P1908 逆序对](https://www.luogu.com.cn/problem/P1908)：考察树状数组或归并排序求逆序对。
- [P3374 【模板】树状数组 1](https://www.luogu.com.cn/problem/P3374)：树状数组的基础应用，单点修改、区间查询。
- [P3368 【模板】树状数组 2](https://www.luogu.com.cn/problem/P3368)：树状数组的进阶应用，区间修改、单点查询。

### 个人心得摘录与总结
- **作者：Shikita**：先使用暴力法骗到 60 分，加了排序优化后得到 70 分，最终想到用树状数组优化。总结是暴力法在数据规模大时会超时，可逐步优化，利用数据之间的关联减少计算量。
- **作者：Chaos1018**：因不会写线段树和树状数组，选择复习 fhq_treap 板子。说明在不熟悉某些算法时，可选择自己熟悉的数据结构解决问题。
- **作者：TLE_Automat**：发现数据分散，考虑到只关心奶牛高度排名，使用离散化处理。提示在处理数据范围大且分散的问题时，可使用离散化优化。 

---
处理用时：47.17秒
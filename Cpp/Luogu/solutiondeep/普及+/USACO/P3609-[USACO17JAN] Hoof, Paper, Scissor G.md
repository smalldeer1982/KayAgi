# 题目信息

# [USACO17JAN] Hoof, Paper, Scissor G

## 题目背景

*本题与 [银组同名题目](/problem/P6120) 在题意上一致，唯一的差别在于对变手势次数的限制。*


## 题目描述

你可能玩过“石头，剪刀，布”，这个游戏在奶牛中同样流行，不过它的名字变成了“蹄子，剪刀，布”。

“蹄子，剪刀，布”和“石头，剪刀，布”的规则十分类似，两只奶牛数到三，然后出一个代表蹄子，剪刀或布的手势。蹄子胜过剪刀，剪刀胜过布，布胜过蹄子。特别地，如果两只奶牛的手势相同，则视为平局。

现在 FJ 和 Bassie 要进行 $N$ 轮对抗。Bassie 已经预测了 FJ 每一轮要出的手势。然而 Bassie 很懒，她最多只想变换 $K$ 次手势。

现在请你帮 Bassie 求出她最多能赢多少轮。

## 样例 #1

### 输入

```
5 1
P
P
H
P
S```

### 输出

```
4
```

# AI分析结果

### 综合分析与结论
这些题解主要围绕动态规划（DP）和记忆化搜索两种方法来解决“蹄子，剪刀，布”游戏问题。多数题解采用三维DP数组 `f[i][j][k]` 来表示状态，其中 `i` 表示轮数，`j` 表示变换手势的次数，`k` 表示当前的手势。通过状态转移方程计算出每一轮不同变换次数和手势下的最大赢的轮数，最后在所有可能的结果中取最大值得到答案。记忆化搜索则是通过递归的方式，记录已经计算过的状态，避免重复计算。

### 所选题解
- **作者：zgf519orz（5星）**
  - **关键亮点**：思路清晰，先给出朴素DP解法，再对其进行优化，详细解释了优化的原因和过程，代码可读性高，有详细注释。
  - **个人心得**：原代码会超时，通过分析发现当前状态只与 `i - 1` 的状态有关，从而省略了枚举 `k` 的循环，优化了时间复杂度。

### 重点代码
```cpp
// 优化后的代码
#include <cstdio>
#include <algorithm>
#include <iostream>
using namespace std;

int n,m;
bool h[100005],s[100005],p[100005];
int f[100005][25][3];

int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++){
        char tmp;
        cin >> tmp;
        if(tmp=='H'){
            p[i]=1;
        }
        if(tmp=='S'){
            h[i]=1;
        }
        if(tmp=='P'){
            s[i]=1;
        }
    }
    f[1][0][0]=h[1];
    f[1][0][1]=s[1];
    f[1][0][2]=p[1];
    for(int i=1;i<=n;i++){
        for(int j=0;j<=m;j++){
            f[i][j][0]=max(f[i][j][0],
                           max(f[i-1][j][0]+h[i],
                               max(f[i-1][j-1][1]+h[i],f[i-1][j-1][2]+h[i])));
            f[i][j][1]=max(f[i][j][1],
                           max(f[i-1][j][1]+s[i],
                               max(f[i-1][j-1][0]+s[i],f[i-1][j-1][2]+s[i])));
            f[i][j][2]=max(f[i][j][2],
                           max(f[i-1][j][2]+p[i],
                               max(f[i-1][j-1][0]+p[i],f[i-1][j-1][1]+p[i])));
        }
    }
    int ans=0;
    for(int i=0;i<=m;i++){
        ans=max(ans,max(f[n][i][0],max(f[n][i][1],f[n][i][2])));
    }
    printf("%d",ans);
    return 0;
}
```
**核心实现思想**：使用三维DP数组 `f[i][j][k]` 表示前 `i` 轮，严格变换了 `j` 次手势，并且最后一次出的是 `k` 手势所赢的最多次数。通过状态转移方程更新 `f` 数组，最后在所有可能的结果中取最大值得到答案。

### 最优关键思路或技巧
- **状态定义**：使用三维DP数组 `f[i][j][k]` 来表示状态，能够清晰地记录每一轮的信息，方便进行状态转移。
- **状态转移优化**：分析状态之间的关系，发现当前状态只与前一轮的状态有关，从而省略了不必要的循环，优化了时间复杂度。
- **记忆化搜索**：通过记录已经计算过的状态，避免重复计算，提高效率。

### 可拓展之处
同类型题或类似算法套路：
- **背包问题**：如0 - 1背包、完全背包等，通过定义状态和状态转移方程来求解最优解。
- **区间DP**：在区间上进行动态规划，通过枚举区间端点和分割点来进行状态转移。
- **树形DP**：在树上进行动态规划，通过遍历树的节点来进行状态转移。

### 推荐题目
- [P1048 采药](https://www.luogu.com.cn/problem/P1048)：0 - 1背包问题。
- [P1880 石子合并](https://www.luogu.com.cn/problem/P1880)：区间DP问题。
- [P2014 选课](https://www.luogu.com.cn/problem/P2014)：树形DP问题。

### 个人心得总结
- **zgf519orz**：原代码超时，通过分析状态之间的关系，发现当前状态只与前一轮的状态有关，从而省略了枚举 `k` 的循环，优化了时间复杂度。
- **南城忆潇湘**：在推导DP方程时，发现只用二维数组表示状态会缺少必要信息，于是增加一维来表示当前的手势，从而正确求解。同时，在循环中要注意 `j` 的取值范围，避免数组越界。

---
处理用时：38.11秒
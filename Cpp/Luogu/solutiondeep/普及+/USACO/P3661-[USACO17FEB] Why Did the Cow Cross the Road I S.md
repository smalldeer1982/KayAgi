# 题目信息

# [USACO17FEB] Why Did the Cow Cross the Road I S

## 题目描述

Farmer John 的奶牛们正在学习如何有效地过马路。回想起古老的“鸡为什么要过马路？”笑话，他们认为鸡一定是过马路的专家，于是去寻找鸡来帮助它们。

事实上，鸡是非常忙碌的生物，它们只有有限的时间来帮助奶牛。农场上有 $C$ 只鸡（$1 \leq C \leq 20,000$），方便地用编号 $1 \ldots C$ 标识，每只鸡 $i$ 只愿意在确切的时间 $T_i$ 帮助一头奶牛。奶牛们从不着急，它们的日程安排更加灵活。农场上有 $N$ 头奶牛（$1 \leq N \leq 20,000$），方便地用编号 $1 \ldots N$ 标识，其中奶牛 $j$ 能够在时间 $A_j$ 到时间 $B_j$ 之间过马路。考虑到“伙伴系统”是最好的方式，每头奶牛 $j$ 理想情况下希望找到一只鸡 $i$ 来帮助她过马路；为了使它们的日程安排兼容，$i$ 和 $j$ 必须满足 $A_j \leq T_i \leq B_j$。

如果每头奶牛最多只能与一只鸡配对，每只鸡也最多只能与一头奶牛配对，请计算可以构建的最大奶牛-鸡配对数。

## 样例 #1

### 输入

```
5 4
7
8
6
2
9
2 5
4 9
0 3
8 13```

### 输出

```
3```

# AI分析结果

### 综合分析与结论
这些题解主要围绕贪心算法来解决奶牛 - 鸡配对的最大匹配数问题。不同题解的主要区别在于排序方式和查找匹配的具体实现，有的采用朴素枚举，有的借助数据结构优化查找过程。

### 所选题解
- **Cutest_Junior（5星）**
    - **关键亮点**：思路清晰，先给出朴素贪心做法并证明其正确性，再对朴素做法进行优化，使用 `multiset` 实现 $O(N\log N)$ 的时间复杂度，代码注释详细。
    - **个人心得**：在实现过程中发现朴素做法极慢，尝试用二分优化但会退化，最终在学长的提示下使用 `multiset` 解决问题。
- **StudyingFather（4星）**
    - **关键亮点**：先提出朴素贪心做法，再进行优化，通过将区间按左端点排序，利用小根堆维护候选区间，实现 $O(n \log n)$ 的复杂度，代码结构清晰。
- **MyukiyoMekya（4星）**
    - **关键亮点**：在贪心思路的基础上，使用并查集优化二分查找过程，复杂度为 $O(n\log n)$，且常数较小，能拿到较优解。

### 重点代码及核心实现思想
#### Cutest_Junior（$O(N\log N)$ 做法）
```cpp
multiset <int> s;
struct inter {
    int l,r;
    friend inline bool operator < (const inter & a,const inter &b) {
        return a.r == b.r ? a.l > b.l : a.r < b.r;
    }
}a[N];
// ...
for (int i = 1;i <= m;++i) {
    it = s.lower_bound(a[i].l);
    if (it != s.end()) {
        if (*it <= a[i].r) ++ans,s.erase(it);
    }
}
```
核心思想：先将区间按右端点排序，使用 `multiset` 存储鸡的时间，对于每个区间，用 `lower_bound` 找到第一个大于等于左端点的鸡的时间，若该时间在区间内则匹配并删除该鸡。

#### StudyingFather
```cpp
struct seg
{
    int l,r;
    bool operator<(const seg&a)const
    {
        return r>a.r;
    }
}s[20005];
priority_queue<seg> q;
// ...
for(int i=1;i<=c;i++)
{
    while(cur<=n&&s[cur].l<=a[i])
        q.push(s[cur++]);
    while(!q.empty()&&q.top().r<a[i])
        q.pop();
    if(!q.empty())ans++,q.pop();
}
```
核心思想：将区间按左端点排序，使用小根堆维护候选区间。对于每个鸡的时间，将左端点小于该时间的区间加入堆，弹出右端点小于该时间的区间，若堆不为空则匹配堆顶区间。

#### MyukiyoMekya
```cpp
int f[MaxN],b[MaxN],cnt[MaxN];
inline int getf(int x)
{
    return f[x]==x?x:f[x]=getf(f[x]);
}
// ...
for(int i=1;i<=m;++i)
{
    int l=1,r=n,ans=n+1,mid;
    while(l<=r)
    {
        mid=(l+r)>>1;
        if(b[mid]>=a[i].l)
            ans=mid,r=mid-1;
        else
            l=mid+1;
    }
    if(b[getf(ans)]<=a[i].r)
    {
        ++Ans,--cnt[getf(ans)];
        if(!cnt[getf(ans)])
            f[getf(ans)]=getf(ans)+1;
    }
}
```
核心思想：先对鸡的时间去重并排序，使用并查集优化二分查找。对于每个区间，二分找到第一个大于等于左端点的鸡的时间，若该时间在区间内则匹配并更新并查集。

### 最优关键思路或技巧
- **贪心策略**：将区间按右端点排序，优先匹配位置最小的还没匹配的点，能保证结果最优。
- **数据结构优化**：使用 `multiset`、小根堆、并查集等数据结构优化查找和删除操作，将时间复杂度从 $O(N^2)$ 降低到 $O(N\log N)$。

### 可拓展之处
同类型题如区间覆盖问题、活动安排问题等，都可以使用贪心算法结合合适的数据结构解决。类似算法套路是先对数据进行排序，再根据贪心策略进行匹配，过程中使用数据结构优化查找和删除操作。

### 推荐题目
- P1803 凌乱的yyy / 线段覆盖
- P2082 区间覆盖
- P1233 木棍加工

### 个人心得总结
- Cutest_Junior 在实现过程中遇到朴素做法慢、优化易退化的问题，最终借助学长的思路使用 `multiset` 解决，说明在算法优化过程中可以借助他人的经验和思路。
- MC_Launcher 一开始按左端点排序只得到50分，后来发现按右端点排序才能AC，提醒我们在贪心算法中排序方式的选择很关键，需要仔细分析问题的本质。 

---
处理用时：40.70秒
# 题目信息

# [USACO17FEB] Why Did the Cow Cross the Road III S

## 题目描述

奶牛为什么要过马路？其中一个原因是 Farmer John 的农场有很多道路，使得他的奶牛在四处走动时不可避免地要穿过许多道路。

FJ 的农场被安排成一个 $N \times N$ 的方形网格田地（$2 \leq N \leq 100$），某些相邻的田地（例如南北向或东西向）被道路分隔，整个网格的外部有一圈高高的围栏，防止奶牛离开农场。奶牛可以从任何田地自由移动到相邻的田地（北、东、南或西），尽管它们除非绝对必要，否则不愿意穿过道路。

农场上有 $K$ 头奶牛（$1 \leq K \leq 100, K \leq N^2$），每头奶牛位于不同的田地。如果一头奶牛要拜访另一头奶牛时必须至少穿过一条道路，那么这对奶牛被称为“远距离”对。请帮助 FJ 计算远距离奶牛对的数量。

## 样例 #1

### 输入

```
3 3 3
2 2 2 3
3 3 3 2
3 3 2 3
3 3
2 2
2 3```

### 输出

```
2```

# AI分析结果

### 综合分析与结论
这些题解的核心思路都是先处理道路信息，标记出田地间的连通性，再通过搜索算法（DFS 或 BFS）找出所有连通块，最后统计不同连通块中奶牛对的数量。各题解在存储道路信息和搜索连通块的实现方式上有所不同，如使用三维数组、二维数组二进制压缩、邻接表等存储道路信息，使用 DFS 或 BFS 进行连通块搜索。

### 所选题解
- **作者：chenxuanting（5 星）**
  - **关键亮点**：思路清晰，代码注释详细，使用三维数组存储道路信息，DFS 搜索连通块，最后统计不同连通块中奶牛对数量，易于理解。
  - **个人心得**：无
- **作者：hht2005（4 星）**
  - **关键亮点**：使用二维数组二进制压缩存储道路信息，节省空间，BFS 搜索连通块，代码实现简洁。
  - **个人心得**：无
- **作者：OfstAutomataMachine（4 星）**
  - **关键亮点**：详细阐述了使用四维数组存储道路信息会导致 MLE 的问题，并给出了将四维数组优化为三维数组的解决方案，思路清晰。
  - **个人心得**：一开始用四维数组存墙信息结果 MLE，后来将四位数组变成三维数组解决了问题。

### 重点代码
#### chenxuanting 的题解
```cpp
// 存储道路信息
int a[105][105][4]; // 北东西南 
// DFS 搜索连通块
void dfs(int x,int y)
{
    if(x<1||y<1||x>n||y>n){
        return;
    }
    if(color[x][y]!=-1){
        return;
    }
    color[x][y]=num;	
    if(b[x][y]==1){
        all++;
    }
    for(int i=0;i<4;i++){
        if(a[x][y][i]==1){
            continue;
        }
        int xx=x+dx[i];
        int yy=y+dy[i];
        dfs(xx,yy);
    }
}
```
**核心实现思想**：使用三维数组 `a` 存储每个格子四个方向的道路信息，DFS 函数用于搜索连通块，标记已访问的格子并统计连通块内的奶牛数量。

#### hht2005 的题解
```cpp
// 存储道路信息，二进制压缩
int c[110][110]; 
// BFS 搜索连通块
int bfs(int ii,int jj)
{
    int q1=0,q2=1,sum=0;
    b[ii][jj]=1;
    q[0][0]=ii;
    q[0][1]=jj;
    while(q1!=q2)
    {
        int x=q[q1][0],y=q[q1][1];
        if(++q1==210)q1=0; // 循环
        sum+=f[x][y];
        for(int i=0;i<=3;i++)
        {
            int xx=x+dx[i],yy=y+dy[i];
            if(!(c[x][y]&1<<i)&&!b[xx][yy])
            {
                b[xx][yy]=1;
                q[q2][0]=xx;
                q[q2][1]=yy;
                if(++q2==210)q2=0; // 循环
            }
        }
    }
    return sum;
}
```
**核心实现思想**：使用二维数组 `c` 进行二进制压缩存储道路信息，BFS 函数用于搜索连通块，标记已访问的格子并统计连通块内的奶牛数量。

#### OfstAutomataMachine 的题解
```cpp
// 存储道路信息
int wall[101][101][5]; 
// DFS 搜索连通块
void dfs(int x,int y)
{
    col[x][y]=cnt;
    if(x-1>=1)
        if(!wall[x][y][1]&&!col[x-1][y])
            dfs(x-1,y);
    if(x+1<=n)
        if(!wall[x][y][2]&&!col[x+1][y])
            dfs(x+1,y);
    if(y-1>=1)
        if(!wall[x][y][3]&&!col[x][y-1])
            dfs(x,y-1);
    if(y+1<=n)
        if(!wall[x][y][4]&&!col[x][y+1])
            dfs(x,y+1);
}
```
**核心实现思想**：使用三维数组 `wall` 存储每个格子四个方向的道路信息，DFS 函数用于搜索连通块，标记已访问的格子。

### 最优关键思路或技巧
- **存储优化**：使用三维数组或二维数组二进制压缩存储道路信息，避免使用四维数组导致 MLE。
- **搜索算法**：使用 DFS 或 BFS 搜索连通块，标记已访问的格子，统计连通块内的奶牛数量。
- **乘法原理**：统计不同连通块中奶牛对的数量时，使用乘法原理，避免重复计算。

### 可拓展之处
同类型题或类似算法套路：
- 地图连通性问题：如岛屿数量、迷宫路径等问题，可使用 DFS 或 BFS 搜索连通块。
- 图的遍历问题：如判断图的连通性、求图的连通分量等问题，可使用搜索算法或并查集解决。

### 推荐题目
- [P1457 城堡 The Castle](https://www.luogu.com.cn/problem/P1457)：与本题类似，涉及地图连通性问题，可使用 DFS 或 BFS 搜索连通块。
- [P1162 填涂颜色](https://www.luogu.com.cn/problem/P1162)：判断地图中不同区域的连通性，可使用 DFS 或 BFS 搜索连通块。
- [P1141 01迷宫](https://www.luogu.com.cn/problem/P1141)：在迷宫中寻找连通块，可使用 DFS 或 BFS 搜索连通块。

### 个人心得总结
OfstAutomataMachine 提到一开始使用四维数组存储墙信息导致 MLE，后来将四位数组变成三维数组解决了问题，提醒我们在处理大规模数据时要注意空间复杂度，合理选择数据结构。

---
处理用时：46.28秒
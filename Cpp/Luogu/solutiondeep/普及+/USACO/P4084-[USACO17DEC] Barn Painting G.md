# 题目信息

# [USACO17DEC] Barn Painting G

## 题目描述

Farmer John 有一个大农场，农场上有 $N$ 个谷仓（$1 \le N \le 10^5$），其中一些已经涂色，另一些尚未涂色。Farmer John 想要为这些剩余的谷仓涂色，使得所有谷仓都被涂色，但他只有三种可用的油漆颜色。此外，他的获奖奶牛 Bessie 如果发现两个直接相连的谷仓颜色相同，会感到困惑，因此他希望确保这种情况不会发生。

保证 $N$ 个谷仓之间的连接不会形成任何“环”。也就是说，任意两个谷仓之间最多只有一条连接路径。

Farmer John 有多少种方式可以为剩余的未涂色谷仓涂色？

## 样例 #1

### 输入

```
4 1
1 2
1 3
1 4
4 3```

### 输出

```
8```

# AI分析结果

### 综合分析与结论
这些题解均采用树形 DP 解决谷仓涂色方案数问题。核心思路是定义状态数组 `f[i][j]` 表示节点 `i` 涂颜色 `j` 的方案数，利用 DFS 从叶子节点向根节点递推，依据相邻节点颜色不同的条件得出状态转移方程。各题解在数据结构（邻接表、链式前向星等）和代码实现细节上存在差异，但整体思路一致。

### 所选题解
- LlLlCc（4星）
    - 关键亮点：思路清晰，对树形 DP 过程解释详细，代码注释丰富，易于理解。
- Okarin（4星）
    - 关键亮点：将本题与经典树形 DP 题目对比，有助于理解，转移方程推导清晰。
- FourteenObsidian（4星）
    - 关键亮点：代码结构清晰，对状态数组含义和搜索过程分类判断解释明确。

### 重点代码
#### LlLlCc 的核心代码
```cpp
inline void Dfs(int x,int fa){
    for (int i=0;i<3;i++){
        if (f[x][i]){for (int j=0;j<i;j++) f[x][j]=0;break;}
        f[x][i]=1;
    }
    for (int i=lnk[x];i;i=nxt[i])
      if (son[i]!=fa){
        Dfs(son[i],x);
        f[x][0]=f[x][0]*((f[son[i]][1]+f[son[i]][2])%TT)%TT;
        f[x][1]=f[x][1]*((f[son[i]][0]+f[son[i]][2])%TT)%TT;
        f[x][2]=f[x][2]*((f[son[i]][1]+f[son[i]][0])%TT)%TT;
      }
}
```
核心实现思想：先处理当前节点的初始状态，若节点已指定颜色，将其他颜色方案数置为 0；然后递归处理子节点，根据状态转移方程更新当前节点的方案数。

#### Okarin 的核心代码
```cpp
void dfs(int pos){
    visit[pos]=1;
    if(col[pos])
        dp[pos][col[pos]]=1;
    else{
        dp[pos][1]=1;
        dp[pos][2]=1;
        dp[pos][3]=1;
    }
    for(register int i=Head[pos];i;i=h[i].next){
        int v=h[i].node;
        if(!visit[v]){
            dfs(v);
            dp[pos][1]=dp[pos][1]*((dp[v][2]+dp[v][3])%p)%p;
            dp[pos][2]=dp[pos][2]*((dp[v][1]+dp[v][3])%p)%p;
            dp[pos][3]=dp[pos][3]*((dp[v][2]+dp[v][1])%p)%p;
        }
    }
}
```
核心实现思想：标记当前节点已访问，根据节点是否已涂色设置初始状态；遍历子节点，递归处理并更新当前节点的方案数。

#### FourteenObsidian 的核心代码
```cpp
I void slove(int x){
    vis[x] = 1;
    if(ced[x]) f[x][ced[x]] = 1; 
    else f[x][1] = f[x][2] = f[x][3] = 1;
    for(int i = head[x]; i; i = edge[i].next){
        int y = edge[i].to;
        if(vis[y]) continue;
        slove(y);
        f[x][1] = f[x][1] * ((f[y][2] + f[y][3]) % mod) % mod;
        f[x][2] = f[x][2] * ((f[y][1] + f[y][3]) % mod) % mod;
        f[x][3] = f[x][3] * ((f[y][1] + f[y][2]) % mod) % mod;
    }
    return;
}
```
核心实现思想：标记当前节点已访问，根据节点是否已涂色设置初始状态；遍历子节点，递归处理并更新当前节点的方案数。

### 最优关键思路或技巧
- **状态定义**：使用二维数组 `f[i][j]` 表示节点 `i` 涂颜色 `j` 的方案数，清晰地描述了问题状态。
- **树形 DP 与 DFS 结合**：利用 DFS 从叶子节点向根节点递推，保证在计算当前节点方案数时，子节点的方案数已计算完成。
- **乘法原理**：根据相邻节点颜色不同的条件，通过乘法原理得出状态转移方程，计算当前节点的方案数。

### 拓展思路
同类型题目通常是在树上进行状态转移，可参考以下类似算法套路：
- 对于树上的路径问题，可定义状态表示以某个节点为根的子树中满足特定条件的路径数量。
- 对于树上的选择问题，可定义状态表示以某个节点为根的子树中选择某些节点的最优方案。

### 推荐题目
- [P1352 没有上司的舞会](https://www.luogu.com.cn/problem/P1352)：经典树形 DP 题目，与本题思路相似，可加深对树形 DP 的理解。
- [P2015 二叉苹果树](https://www.luogu.com.cn/problem/P2015)：在树上进行动态规划，需要考虑保留边的数量，增加了一定的复杂度。
- [P2014 选课](https://www.luogu.com.cn/problem/P2014)：树形依赖背包问题，结合了树形结构和背包问题的思想。

### 个人心得
- Starrydream：“一道普通组合树形 dp，D1T2 难度。所以我又被卡了 n 次。。唉。注意 dp 的数组初始值是否合适。” 总结：树形 DP 题目需要注意数组初始值的设置，避免因初始值问题导致错误。

---
处理用时：41.47秒
# 题目信息

# [USACO18FEB] Snow Boots S

## 题目描述

农场的冬天到了，这意味着下雪了！从农舍到谷仓的路上有 $N$ 块地砖，方便地编号为 $1 \dots N$，第 $i$ 块地砖上覆盖了 $f_i$ 英尺的雪。

Farmer John 从第 $1$ 块地砖出发，必须到达第 $N$ 块地砖去叫醒奶牛。第 $1$ 块地砖被农舍的屋顶遮蔽，第 $N$ 块地砖被谷仓的屋顶遮蔽，因此这两块地砖上没有雪。但要踩在其他地砖上，Farmer John 需要穿靴子！

在他的恶劣天气背包中，Farmer John 有 $B$ 双靴子，编号为 $1 \dots B$。有些靴子比其他靴子更耐用，有些靴子比其他靴子更灵活。具体来说，第 $i$ 双靴子允许 Farmer John 在最多 $s_i$ 英尺深的雪中行走，并且每步最多可以移动 $d_i$ 块地砖。

不幸的是，靴子的打包方式使得 Farmer John 在任何时候只能访问最上面的一双靴子。因此，Farmer John 可以随时穿上最上面的一双靴子（丢弃旧靴子）或丢弃最上面的一双靴子（使下一双靴子可访问）。

Farmer John 只能在地砖上更换靴子。如果该地砖上有 $f$ 英尺的雪，那么他脱下的靴子和穿上的靴子都必须能够承受至少 $f$ 英尺的雪。他丢弃但未穿过的中间靴子不需要满足此限制。

请帮助 Farmer John 最小化浪费，确定他到达谷仓需要丢弃的最少靴子对数。假设 Farmer John 最初没有穿任何靴子。

## 说明/提示

题目来源：Brian Dean 和 Dhruv Rohatgi

## 样例 #1

### 输入

```
10 4
0 2 8 3 6 7 5 1 4 0
2 3
4 2
3 4
7 1```

### 输出

```
2
```

# AI分析结果

### 综合分析与结论
这些题解主要围绕农场主穿靴子从第 1 块地砖走到第 N 块地砖，求最少丢弃靴子数的问题展开，采用了动态规划（DP）和深度优先搜索（DFS）两种主要算法思路。

DP 类题解通过定义不同的状态数组，如 `dp[i]` 表示走到第 i 块砖的最小浪费靴子数、`dp[i][j]` 表示穿着鞋子 j 到达位置 i 是否可行等，依据靴子的雪深承受能力和步长限制进行状态转移。

DFS 类题解则通过递归枚举走的步数和换鞋的情况，结合记忆化数组避免重复计算，以找到最少丢弃靴子数。

### 所选题解
- **作者：nihanchu (赞：18)，4星**
  - **关键亮点**：思路清晰，代码简洁，利用布尔数组 `f` 标记能否到达某块地砖，通过枚举靴子和地砖，逐步更新可达状态，直到到达终点。
  - **个人心得**：一开始题意理解出问题，导致想复杂了，提醒我们做题前要准确理解题意。
- **作者：communist (赞：17)，4星**
  - **关键亮点**：采用典型的 DP 思路，定义 `dp[i][j]` 表示穿着鞋子 j 到达位置 i 是否可行，通过多重循环进行状态转移，逻辑清晰。
  - **个人心得**：数据小，可暴力开数组暴力 DP，提示我们根据数据范围选择合适的算法。
- **作者：忘怀星 (赞：1)，4星**
  - **关键亮点**：提出了 $O(NB)$ 复杂度的优化思路，使用类似滑动窗口的方法处理状态转移，降低了时间复杂度。
  - **个人心得**：思考后发现这道题可以 $n^2$ 通过，鼓励我们深入思考，尝试优化算法。

### 重点代码及核心实现思想
#### 作者：nihanchu
```cpp
int d[maxn],b[maxn],a[maxn],n,m;
bool f[maxn];
int main()
{
  scanf("%d%d",&n,&m);
  for (int i=1;i<=n;i++) scanf("%d",&d[i]);
  for (int i=1;i<=m;i++) scanf("%d%d",&a[i],&b[i]);
  for (int i=1;i<=n;i++) f[i]=false;
  f[1]=true;
  int ans;
  for (int i=1;i<=m;i++)
  {
    for (int j=1;j<=n;j++)
      if (f[j]&&(a[i]>=d[j]))
      {
        for (int k=j;k<=min(n,j+b[i]);k++)
          if (a[i]>=d[k]) f[k]=true;	
      }
    if (f[n]) {ans=i;break;}
  }
  printf("%d\n",ans-1);
  return 0;
}
```
核心思想：用 `f[j]` 表示前 i - 1 双靴子是否能走到第 j 块地砖，若能走到且当前靴子能承受该地砖的雪深，则用当前靴子更新后续可达的地砖状态。

#### 作者：communist
```cpp
const int maxn=260;
int n,b,dp[maxn][maxn],f[maxn],s[maxn],d[maxn];
int main()
{
    scanf("%d%d",&n,&b);
    for(int i=1;i<=n;i++)
        scanf("%d",&f[i]);
    for(int i=1;i<=b;i++)
        scanf("%d%d",&s[i],&d[i]);
    dp[1][1]=1;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=b;j++)
            if(dp[i][j])
                for(int k=j;k<=b;k++)
                    if(f[i]<=s[k])
                        for(int l=i+1;l<=min(n,i+d[k]);l++)
                            if(f[l]<=s[k])
                                dp[l][k]=1;
    for(int i=1;i<=b;i++)
        if(dp[n][i])
        {
            printf("%d\n",i-1);
            return 0;
        }
    return 0;
}
```
核心思想：定义 `dp[i][j]` 表示穿着鞋子 j 到达位置 i 是否可行，通过枚举位置、正在穿的鞋、换成的鞋和走的步数进行状态转移。

#### 作者：忘怀星
```cpp
int n,b,f[N],dp[N];
int main()
{
    n = read(),b = read();dp[1] = 1;
    for(int i = 1;i <= n;i ++) f[i] = read();
    for(int i = 1;i <= b;i ++) {
        int s = read(),d = read();
        for(int j = 1,p = 1,tmp=0;j <= n;j ++) {
            while(j-p > d) {
                if(dp[p] && f[p] <= s) tmp --;
                ++p;
            }
            if(tmp && !dp[j] && f[j] <= s) dp[j] = i;
            if(dp[j]&&f[j]<=s) ++tmp;
        }
        if(dp[n]) {printf("%d",dp[n]-1);return 0;}
    }
    printf("%d ",dp[n]-1);
    return 0;
}
```
核心思想：设 `dp[i]` 为走到点 i 时穿的最小编号的鞋子的编号，用类似滑动窗口的方法处理状态转移，枚举每双靴子和每块砖，更新可达状态。

### 最优关键思路或技巧
- **状态定义**：合理定义状态数组是解决动态规划问题的关键，如 `dp[i]`、`dp[i][j]` 等，能清晰地表示问题的子状态。
- **记忆化搜索**：在 DFS 中使用记忆化数组，避免重复计算，提高效率。
- **滑动窗口优化**：如忘怀星的题解，使用类似滑动窗口的方法处理状态转移，降低时间复杂度。

### 可拓展之处
同类型题可能会改变条件，如增加靴子的属性、改变地砖的规则等，但解题思路仍可围绕动态规划或深度优先搜索展开。类似算法套路包括状态压缩 DP、记忆化搜索的剪枝优化等。

### 推荐题目
- P1048 [NOIP2005 普及组] 采药
- P1216 [USACO1.5] 数字三角形 Number Triangles
- P1002 [NOIP2002 普及组] 过河卒

### 个人心得总结
- 做题前要准确理解题意，避免因理解偏差导致思路复杂。
- 根据数据范围选择合适的算法，数据较小时可考虑暴力 DP。
- 深入思考问题，尝试优化算法，降低时间复杂度。

---
处理用时：47.36秒
# 题目信息

# [USACO18FEB] Taming the Herd G

## 题目描述

清晨，Farmer John 被木头碎裂的声音吵醒。原来是奶牛们又一次从谷仓里逃出来了！
Farmer John 对奶牛们的清晨逃跑行为感到厌烦，他决定受够了：是时候采取强硬措施了。他在谷仓的墙上钉了一个计数器，用于记录自上次逃跑以来的天数。因此，如果某天早上发生了逃跑，计数器当天会显示 $0$；如果最近一次逃跑发生在 $3$ 天前，计数器会显示 $3$。Farmer John 每天都会仔细记录计数器的值。

年末到了，Farmer John 准备进行一些统计。他说，奶牛们要为此付出代价！但他发现他的记录似乎有些不对劲……

Farmer John 想知道自从他开始记录以来发生了多少次逃跑。然而，他怀疑奶牛们篡改了他的记录，他唯一能确定的是他开始记录的那天发生了一次逃跑。请帮助他确定，对于可能发生的逃跑次数，记录中必须被篡改的最小条目数。

## 说明/提示

如果只有 $1$ 次逃跑，那么正确的记录应该是 `0 1 2 3 4 5`，这与给定的记录有 $4$ 个条目不同。

如果有 $2$ 次逃跑，那么正确的记录可能是 `0 1 2 3 0 1`，这与给定的记录有 $2$ 个条目不同。在这种情况下，逃跑发生在第 $1$ 天和第 $5$ 天。

如果有 $3$ 次逃跑，那么正确的记录可能是 `0 1 2 0 0 1`，这与给定的记录只有 $1$ 个条目不同。在这种情况下，逃跑发生在第 $1$ 天、第 $4$ 天和第 $5$ 天。

以此类推。

题目来源：Brian Dean 和 Dhruv Rohatgi

## 样例 #1

### 输入

```
6
1 1 2 0 0 1```

### 输出

```
4
2
1
2
3
4```

# AI分析结果

### 综合分析与结论
这些题解均采用动态规划（DP）来解决问题，不同题解的状态定义和转移方式有所差异。多数题解时间复杂度为 $O(n^3)$，部分题解通过预处理减少时间复杂度，还有一个题解达到了 $O(n^2)$。各题解在思路清晰度、代码可读性和优化程度上表现不同。

### 所选题解
- **作者：Dilute（4星）**
  - **关键亮点**：思路清晰，状态定义简单明了，代码实现简洁，通过预处理 `Cnt` 数组减少重复计算，降低时间复杂度。
  - **核心代码**：
```cpp
int Num[110];
int Cnt[110][110];
int f[110][110]; // dp数组

int main(){
    memset(f, 127, sizeof(f)); // f数组初值极大
    int n;
    scanf("%d", &n);
    for(int i = 1; i <= n; i++)
        scanf("%d", &Num[i]);
    for(int i = 0; i <= n; i++){
        int Cou = 0;
        for(int j = i; j <= n; j++){
            if(Num[j] != j - i)
                Cou++;
            Cnt[i][j] = Cou;
        }
    }
    f[0][0] = 0;
    for(int i = 0; i <= n; i++)
        for(int j = 1; j <= n; j++)
            for(int u = i+1; u <= n; u++) // 枚举f[i][j]可以更新的状态
                if(f[u][j] > f[i][j-1] + Cnt[i+1][u]) // 如果更优
                    f[u][j] = f[i][j-1] + Cnt[i+1][u];
    for(int i = 1; i <= n; i++)
        printf("%d\n", f[n][i]);
}
```
  - **核心实现思想**：`f[i][j]` 表示在前 `i` 个里面经历 `j` 次出逃可以取到最少的修改数。`Cnt[i][j]` 预处理表示如果第 `i` 天出逃那么到第 `j` 天如果改成输入的序列需要修改的次数。通过三重循环进行状态转移。

- **作者：vеctorwyx（4星）**
  - **关键亮点**：提供了 $O(n^2)$ 的做法，思路独特，通过预处理区间贡献和特殊情况的处理，降低了时间复杂度。
  - **核心代码**：
```cpp
int n, a[110], qc[110][110];
int dp[110][110], dp0[110][110], jc[110][110];
signed main(){
    memset(dp, -1, sizeof(dp));
    scanf("%d", &n);
    for(int i = 1; i <= n; i++)
        scanf("%d", &a[i]);
    for(int i = 1; i <= n; i++){//预处理区间贡献
        qc[i][i] = (a[i] == 0);
        int qwq = 1;
        for(int j = 1; j <= a[i] && i - j >= 1; j++){
            if(a[i - j] == a[i] - j)
                qwq++;
            qc[i][i - j] = qwq;
        }
    }
    dp[1][1] = (a[1] == 0);
    dp[0][0] = 0;
    int js = dp[1][1];
    for(int i = 2; i <= n; i++)//预处理j = 1的情况
        if(a[i] == i - 1)
            dp[i][1] = ++js;
        else
            dp[i][1] = js;
    for(int i = 2; i <= n; i++)
        dp[0][i] = dp[1][i] = 0;
    for(int i = 2; i <= n; i++){
        for(int j = 2; j <= i; j++){
                if(i - a[i] - 1 >= j - 1)
                    dp[i][j] = max(dp[i - a[i] - 1][j - 1] + qc[i][i - a[i]], dp[i - 1][j]);
            else
                dp[i][j] = dp[i - 1][j];
            dp[i][j] = max(dp[i][j], dp[i - 1][j - 1]);
        }
        for(int j = i + 1; j <= n; j++)
                dp[i][j] = 0;
    }
    for(int i = 1; i <= n; i++)
        cout << n - dp[n][i]<<"\n";
}
```
  - **核心实现思想**：`dp[i][j]` 表示前 `i` 天出逃 `j` 次的最大符合天数。通过预处理区间贡献 `qc` 数组，对于每个 `i` 分当天计数器正确和不正确两种情况进行状态转移，最后将最大符合天数换算成最小不符合天数。

### 最优关键思路或技巧
- **预处理思想**：多数题解通过预处理数组（如 `Cnt`、`sum`、`qc` 等）来减少重复计算，降低时间复杂度。
- **状态定义优化**：不同的状态定义会影响状态转移的复杂度，合理的状态定义可以简化问题。如 `vеctorwyx` 的题解中定义 `dp[i][j]` 为前 `i` 天出逃 `j` 次的最大符合天数，简化了状态转移。

### 可拓展之处
同类型题或类似算法套路：
- 区间DP问题：可以考虑将问题拆分成多个区间，通过区间的合并和转移来求解。
- 分段式线性DP问题：将问题分成多个阶段，每个阶段进行状态转移。

### 推荐题目
1. [P1880 石子合并](https://www.luogu.com.cn/problem/P1880)：区间DP经典题目，通过枚举区间长度和分割点进行状态转移。
2. [P1048 采药](https://www.luogu.com.cn/problem/P1048)：简单的01背包问题，是动态规划的基础题目。
3. [P1164 小A点菜](https://www.luogu.com.cn/problem/P1164)：类似于背包问题，通过状态转移求解方案数。

### 个人心得
- **亦笙箫**：吐槽题目翻译毒瘤，不看提示不明题意，提醒读者在做此类题目时要仔细理解题意。

---
处理用时：43.92秒
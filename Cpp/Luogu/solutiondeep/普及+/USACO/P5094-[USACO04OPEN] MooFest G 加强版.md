# 题目信息

# [USACO04OPEN] MooFest G 加强版

## 题目描述

每一年，约翰的 $ N $ 只奶牛参加奶牛狂欢节。这是一个全世界奶牛都参加的大联欢。狂欢节包括很多有趣的活动，比如干草堆叠大赛、跳牛栏大赛，奶牛之间有时还相互扎屁股取乐。当然，她们会排成一列嚎叫，来欢庆她们的节日。奶牛们的叫声实在刺耳，以致于每只奶牛的听力都受到不同程度的损伤。现在告诉你奶牛 $ i $ 的听力为 $ v_i $ ，这表示如果奶牛 $ j $ 想说点什么让她听到，必须用高于 $ v_i \times dis(i,j) $ 的音量。因此，如果奶牛 $ i $ 和 $ j $ 想相互交谈，她们的音量必须不小于 $ \max (v_i,v_j) \times dis(i,j) $。其中 $ dis(i,j) $ 表示她们间的距离。

现在 $ N $ 只奶牛都站在一条直线上了，每只奶牛还有一个坐标 $ x_i $。如果每对奶牛都在交谈，并且使用最小音量，那所有 $ N(N-1)/2 $ 对奶牛间谈话的音量之和为多少？

## 说明/提示

### 数据范围

因为原数据下 $O(N^2)$ 算法可以通过，所以新添加了一些增强数据。

原数据作为子任务 $1$，新添加的数据作为子任务 $2$。

- 子任务 $1$（$1$ 分）：$1 \leq N,V_i,x_i \leq 2 \times 10^4$。
- 子任务 $2$（$99$ 分）：$1 \leq N,V_i,x_i \leq 5 \times 10^4$。

## 样例 #1

### 输入

```
4
3 1
2 5
2 6
4 3```

### 输出

```
57```

# AI分析结果

### 综合分析与结论
本题的核心在于计算每对奶牛间谈话的音量之和，难点在于处理 `max(v_i, v_j)` 和 `|x_i - x_j|` 这两个部分。各位大神提供了多种解题思路，涵盖暴力枚举、分治、树状数组、线段树等方法。暴力枚举简单直接，但时间复杂度高，仅适用于小规模数据；分治、树状数组和线段树等方法则通过排序和数据结构优化，将时间复杂度降低到可接受范围。

### 所选题解
- **作者：Laser_Crystal (赞：30)，4星**
    - **关键亮点**：思路清晰，详细阐述了树状数组的使用方法，通过对奶牛音量排序，维护两个树状数组分别表示坐标小于当前奶牛的数量和坐标之和，推导出计算答案的公式，代码可读性高。
    - **个人心得**：无

### 重点代码
```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
struct cow{ll v,pos;}a[50004];
ll n;
inline bool cmp(cow x,cow y){return x.v<y.v;}
ll Cnt[50004],Sum[50004];
inline ll lowbit(ll x){return x&(-x);}
inline void add_cnt(ll p,ll x){for(ll i=p; i<50004; i+=lowbit(i)) Cnt[i]+=x;}
inline void add_sum(ll p,ll x){for(ll i=p; i<50004; i+=lowbit(i)) Sum[i]+=x;}
inline ll count_cnt(ll p){ll total=0;for(ll i=p; i>0; i-=lowbit(i)) total+=Cnt[i];return total;}
inline ll count_sum(ll p){ll total=0;for(ll i=p; i>0; i-=lowbit(i)) total+=Sum[i];return total;}
int main()
{
    cin>>n;
    for(register ll i=1; i<=n; i++) cin>>a[i].v>>a[i].pos;
    sort(a+1,a+n+1,cmp);
    ll ans=0,z=0;
    for(register ll i=1; i<=n; i++)
    {
        ll cnt=count_cnt(a[i].pos),sum=count_sum(a[i].pos);
        ans+=(cnt*a[i].pos-sum)*a[i].v;
        ans+=((z-sum)-(i-1-cnt)*a[i].pos)*a[i].v;
        add_cnt(a[i].pos,1);add_sum(a[i].pos,a[i].pos);
        z+=a[i].pos;
    }
    cout<<ans<<endl;
    return 0;
}
```
**核心实现思想**：先对奶牛按音量从小到大排序，然后遍历每头奶牛。对于每头奶牛，通过树状数组查询坐标小于它的奶牛数量和坐标之和，进而计算出该奶牛与前面奶牛的音量贡献，同时更新树状数组和前缀和。

### 最优关键思路或技巧
- **排序优化**：对奶牛的音量进行排序，使得在计算时可以固定 `max(v_i, v_j)` 为当前奶牛的音量，简化计算。
- **树状数组维护**：使用树状数组维护坐标小于当前奶牛的数量和坐标之和，能在 $O(\log n)$ 时间内完成查询和更新操作，降低时间复杂度。

### 可拓展之处
同类型题或类似算法套路：涉及区间查询和单点更新的问题，如逆序对问题、区间和查询等，都可以考虑使用树状数组或线段树来优化。

### 推荐题目
- P1908 逆序对
- P3374 【模板】树状数组 1
- P3372 【模板】线段树 1

### 个人心得摘录与总结
- **作者：船医**：提到树状数组长度要注意，初始化时应使用 `N` 而非 `n`，否则可能在 `add` 操作中加 0 导致死循环 TLE。总结：使用树状数组时要注意数组长度的正确设置，避免因边界问题导致错误。
- **作者：cryozwq**：建议撤下所有 $O(n^2)$ 的题解，认为本题使用三树状数组可解决，但程序常数大，需要吸氧。总结：对于时间复杂度较高的暴力算法，在数据规模较大时可能会超时，应尽量使用更优的算法；同时，在使用复杂数据结构时要注意常数优化。 

---
处理用时：36.47秒
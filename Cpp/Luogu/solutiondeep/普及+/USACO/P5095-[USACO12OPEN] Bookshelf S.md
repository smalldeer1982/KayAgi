# 题目信息

# [USACO12OPEN] Bookshelf S

## 题目描述

Farmer John 闲来无事的时候总喜欢坐下来看书。这些年来，他一共收集了 $N$ 本书（$1 \leq N \leq 2000$），他打算搭一个新的书架来装这些书。

每本书都有个宽度 $w_i$ 和高度 $h_i$，书必须按顺序来摆放（即同一层书架摆的书必须是连续的一个区间）。每层书架的总宽度不能超过 $L$（$1 \leq L \leq 10^9$），每层书架的高度等于这一层最高的书的高度，整个书架的高度等于每层书架的高度之和。

现在请你帮 FJ 求出书架高度的最小值。

## 说明/提示

第一层放第一本书，第二层放第二，三，四本书，第三层放第五本书，总高度为 $5+13+3=21$，可以证明不存在更优的方案。

## 样例 #1

### 输入

```
5 10
5 7
9 2
8 5
13 2
3 8```

### 输出

```
21```

# AI分析结果

### 综合分析与结论
这些题解均采用动态规划解决问题，核心思路是定义状态 $f[i]$ 表示放前 $i$ 本书的最小高度，通过枚举前一个区间的结束位置 $j$ 进行状态转移。主要难点在于处理区间宽度限制和维护区间最大高度。不同题解在代码实现、优化方式上有所差异，部分题解使用前缀和优化区间宽度计算，部分尝试用 ST 表优化区间最大高度查询，但部分优化未有效降低复杂度。

### 所选题解
- **作者：_xbn（5星）**
    - **关键亮点**：思路清晰，代码简洁，直接通过两层循环完成状态转移，利用前缀和处理宽度，实时更新最大高度。
    - **核心代码**：
```cpp
for(int i = 1; i <= n; i++)
{
    f[i] = f[i - 1] + a[i];
    tot = a[i];
    for(int j = i - 1; j >= 1; j--)
    {
        if(c[i] - c[j - 1] > l) break;
        tot = max(tot, a[j]);
        f[i] = min(f[i], f[j - 1] + tot);
    }
}
```
核心思想：外层循环遍历每一本书，先假设当前书新开一层，然后内层循环从当前书往前枚举，尝试将前面的书和当前书放在同一层，更新最大高度和最小高度。

- **作者：zhy137036（4星）**
    - **关键亮点**：详细阐述了状态定义和转移方程，对复杂度进行分析，并说明了优化思路，代码可读性高。
    - **核心代码**：
```cpp
for(int i = 1; i <= n; i++){
    int mx = h[i], sum = w[i];
    f[i] = f[i - 1] + h[i];
    for(int j = i - 2; j >= 0; j--){
        sum += w[j + 1];
        if(sum > l) break;
        mx = max(mx, h[j + 1]);
        f[i] = min(f[i], f[j] + mx);
    }
}
```
核心思想：同样是两层循环，外层遍历每本书，内层从当前书的前一本往前枚举，维护区间宽度和最大高度，更新最小高度。

- **作者：Xdl_rp（4星）**
    - **关键亮点**：清晰给出状态转移方程，使用结构体存储书的信息，代码规范。
    - **核心代码**：
```cpp
for (int i = 1; i <= n; i++) {
    int minn = a[i].h;
    dp[i] = dp[i - 1] + a[i].h;
    for (int j = i - 1; j >= 1; j--) {
        if (sum[i] - sum[j - 1] > l) break;
        minn = max(minn, a[j].h);
        dp[i] = min(dp[j - 1] + minn, dp[i]);
    }
}
```
核心思想：与前面题解类似，通过两层循环进行状态转移，利用前缀和判断宽度是否超出限制，更新最大高度和最小高度。

### 最优关键思路或技巧
- **动态规划状态定义**：定义 $f[i]$ 表示放前 $i$ 本书的最小高度，将问题转化为子问题求解。
- **前缀和优化**：使用前缀和数组存储书的宽度累加和，快速计算区间宽度，将计算区间宽度的复杂度从 $O(n)$ 降为 $O(1)$。
- **枚举优化**：从当前书往前枚举，一旦区间宽度超过限制就停止枚举，避免无效计算。

### 可拓展之处
同类型题如区间划分求最优值问题，常见套路是定义状态表示前 $i$ 个元素划分后的最优值，通过枚举前一个划分点进行状态转移，同时要注意处理区间限制条件。

### 推荐题目
- [P1880 [NOI1995] 石子合并](https://www.luogu.com.cn/problem/P1880)：区间动态规划，将环形石子合并问题转化为线性问题求解。
- [P1049 [NOIP2001 普及组] 装箱问题](https://www.luogu.com.cn/problem/P1049)：0 - 1 背包问题，本质是物品选择和空间限制下的最优解问题。
- [P1164 小A点菜](https://www.luogu.com.cn/problem/P1164)：动态规划，计算点菜方案数，与本题状态转移思想类似。

### 个人心得
- **作者：Justinalx**：“虽然我看了半天才看明白题目，但我依旧顽强的做了出来（错了很多遍）”，总结为做复杂题目时，理解题意和调试代码都可能遇到困难，需要耐心和坚持。 

---
处理用时：28.91秒
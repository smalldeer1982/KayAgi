# 题目信息

# [USACO18DEC] Mooyo Mooyo S

## 题目描述

由于手上（更确实的，蹄子上）有大把的空余时间，Farmer John 的农场里的奶牛经常玩电子游戏消磨时光。她们最爱的游戏之一是基于一款流行的电子游戏 Puyo Puyo 的奶牛版；名称当然叫做 Mooyo Mooyo。

Mooyo Mooyo 是在一块又高又窄的棋盘上进行的游戏，高 $N$（$1\le N\le 100$）格，宽 $10$ 格。 这是一个 $N=6$ 的棋盘的例子：

```
0000000000
0000000300
0054000300
1054502230
2211122220
1111111223
```

每个格子或者是空的（用 $0$ 表示），或者是九种颜色之一的干草捆（用字符 $1\dots 9$ 表示）。重力会使得干草捆下落，所以没有干草捆的下方是 $0$。

如果两个格子水平或垂直方向直接相邻，并且为同一种非 $0$ 颜色，那么这两个格子就属于同一个连通区域。任意时刻出现至少 $K$ 个格子构成的连通区域，其中的干草捆就会全部消失，变为 $0$。如果同时出现多个这样的连通区域，它们同时消失。随后，重力可能会导致干草捆向下落入某个变为 $0$ 的格子。由此形成的新的布局中，又可能出现至少 $K$ 个格子构成的连通区域。若如此，它们同样也会消失（如果又有多个这样的区域，则同时消失），然后重力又会使得剩下的方块下落，这一过程持续进行，直到不存在大小至少为 $K$ 的连通区域为止。

给定一块 Mooyo Mooyo 棋盘的状态，输出这些过程发生之后最终的棋盘的图案。



## 说明/提示

在上面的例子中，如果 $K=3$，那么存在一个大小至少为 $K$ 的颜色 $1$ 的连通区域，同样有一个颜色 $2$ 的连通区域。当它们同时被移除之后，棋盘暂时成为了这样：

```
0000000000
0000000300
0054000300
1054500030
2200000000
0000000003
```

然后，由于重力效果，干草捆下落形成这样的布局：

```
0000000000
0000000000
0000000000
0000000000
1054000300
2254500333
```

再一次地，出现了一个大小至少为 $K$ 地连通区域（颜色 $3$）。移除这个区域就得到了最终的棋盘布局：

```
0000000000
0000000000
0000000000
0000000000
1054000000
2254500000
```

## 样例 #1

### 输入

```
6 3
0000000000
0000000300
0054000300
1054502230
2211122220
1111111223```

### 输出

```
0000000000
0000000000
0000000000
0000000000
1054000000
2254500000```

# AI分析结果

### 综合分析与结论
这些题解的核心思路都是模拟游戏的消除和下落过程，主要分为两个关键步骤：一是通过搜索（DFS 或 BFS）找出大小至少为 $K$ 的连通块并消除；二是模拟重力作用使剩余方块下落。各题解在实现细节上有所差异，但整体思路一致。

### 所选题解
- **作者：houzhiyuan (赞：26) - 4星**
  - **关键亮点**：思路清晰，代码简洁易懂，详细注释了每个步骤的作用，对关键操作（如 DFS 和下落）的实现逻辑解释明确。
  - **个人心得**：无

### 重点代码
```cpp
// DFS 找连通块
void dfs(int x,int y,int s) {
    biaoji[x][y]=1;
    for(int i=0; i<=3; i++) {
        int xx=x+q[i];
        int yy=y+w[i];
        if(biaoji[xx][yy]==0&&ch[xx][yy]==s) {
            sum++;
            dfs(xx,yy,s);
        }
    }
}
// 下落操作
void xialuo() {
    for(int i=n; i>=1; i--) {
        for(int j=1; j<=10; j++) {
            if(ch[i][j]!='0') {
                int k=i;
                while(ch[k+1][j]=='0'&&k<=n) {
                    k++;
                }
                if(k!=i) {
                    ch[k][j]=ch[i][j];
                    ch[i][j]='0';
                }
            }
        }
    }
}
```
**核心实现思想**：`dfs` 函数通过递归的方式标记连通块中的所有方块，并统计连通块的大小；`xialuo` 函数从下往上遍历每个方块，若下方有空位则将方块下落。

### 最优关键思路或技巧
- **搜索算法**：使用 DFS 或 BFS 来找出连通块，通过标记数组避免重复搜索。
- **下落模拟**：按列从下往上遍历，将非零方块依次向下移动，填补空位。
- **重复检查**：使用循环不断检查是否存在可消除的连通块，直到没有为止。

### 可拓展之处
同类型题如消消乐、宝石消除等游戏类模拟题，都可以采用类似的搜索和模拟思路。类似算法套路包括连通块搜索、图的遍历、模拟操作等。

### 推荐题目
- [P1162 填涂颜色](https://www.luogu.com.cn/problem/P1162)
- [P1596 [USACO10OCT]Lake Counting S](https://www.luogu.com.cn/problem/P1596)
- [P2002 消息扩散](https://www.luogu.com.cn/problem/P2002)

### 个人心得摘录与总结
- **raincity**：吐槽该题是模拟题，花费了 3 个小时调试，其中落下操作调试了一个钟头，强调了搜索时清零的重要性。总结：模拟题细节多，调试耗时，要注意关键变量和数组的清零操作。

---
处理用时：25.12秒
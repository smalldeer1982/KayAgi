# 题目信息

# [USACO05DEC] Knights of Ni S

## 题目描述

贝茜遇到了一件很麻烦的事：她无意中闯入了森林里的一座城堡，如果她想回家，就必须穿过这片由骑士们守护着的森林。为了能安全地离开，贝茜不得不按照骑士们的要求，在森林寻找一种特殊的灌木并带一棵给他们。

当然，贝茜想早点离开这可怕的森林，于是她必须尽快完成骑士们给的任务，贝茜随身带着这片森林的地图，地图上的森林被放入了直角坐标系，并按 $x,y $ 轴上的单位长度划分成了 $ W \times H\  ( 1 \leq W,H \leq 1000 )$ 块，贝茜在地图上查出了她自己以及骑士们所在的位置，当然地图上也标注了她所需要的灌木生长的区域。某些区域是不能通过的（比如说沼泽地，悬崖，以及食人兔的聚居地）。在没有找到灌木之前，贝茜不能通过骑士们所在的那个区域，为了确保她自己不会迷路，贝茜只向正北、正东、正南、正西四个方向移动（注意，她不会走对角线）。她要走整整一天，才能从某块区域走到与它相邻的那块区域。

贝茜希望你能帮她计算一下，她最少需要多少天才可脱离这可怕的地方？输入数据保证贝茜一定能完成骑士的任务。

## 说明/提示

这片森林的长为 $8$，宽为 $4$．贝茜的起始位置在第 $3$ 行，离骑士们不远。

贝茜可以按这样的路线完成骑士的任务：北，西，北，南，东，东，北，东，东，南，南。她在森林的西北角得到一株她需要的灌木，然后绕过障碍把它交给在东南方的骑士。

## 样例 #1

### 输入

```
8 4
4 1 0 0 0 0 1 0
0 0 0 1 0 1 0 0
0 2 1 1 3 0 4 0
0 0 0 4 1 1 1 0
```

### 输出

```
11```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何在地图中找到从起点到灌木丛再到终点的最短路径展开，核心算法多为广度优先搜索（BFS），部分使用分层图和Dijkstra算法。思路可分为两类：一是进行两次BFS，分别计算起点和终点到各个灌木丛的最短距离，再枚举灌木丛取距离之和的最小值；二是进行一次BFS，通过增加状态维度（是否取得灌木）或构建分层图来处理整个过程。

### 所选题解
- **作者：Wenoide（5星）**
    - **关键亮点**：仅用一次BFS解决问题，通过增加`dis(x,y,0)`和`dis(x,y,1)`分别记录未取得灌木和已取得灌木到达点`(x,y)`的最短时间，思路清晰，代码简洁高效。
    - **核心代码**：
```cpp
while(l!=r){
    Node t=que[l++];
    int x=t.x,y=t.y;
    bool tag=t.tag;
    if(x==ex&&y==ey&&tag){
        break;
    }
    for(int i=0;i<4;++i){
        int u=x+dx[i],v=y+dy[i];
        bool w=tag||(map[u][v]==4);
        if(!vis[u][v][w]&&map[u][v]!=1){
            dis[u][v][w]=dis[x][y][tag]+1;
            vis[u][v][w]=true;
            que[r++]=make(u,v,w);
        }
    }
}
```
    - **核心思想**：在BFS过程中，根据当前状态（是否取得灌木）更新下一步的状态，并记录最短时间，直到到达终点且已取得灌木。

- **作者：vеctorwyx（4星）**
    - **关键亮点**：详细说明了需要注意的点，如搜索时的标记和恢复、灌木丛位置的记录等，对新手友好。
    - **个人心得**：“我被这道题坑了很久（~~现在感觉不难了~~）”“搜索的时候要把所有灌木丛都找到最短路；搜索到一个灌木丛要标记成路（一开始标记成障碍了 [哭] ），但是在第二次搜索前要恢复（这个我一开始也忘了[哭*2]）”，总结为在解题过程中容易在标记和恢复状态上出错，需要仔细处理。
    - **核心代码**：
```cpp
while(!q.empty()){
    qwq=q.front();
    if(a[qwq.x][qwq.y]==4&&ji1[qwq.x][qwq.y]==0){
        ji1[qwq.x][qwq.y]=qwq.tim;
        a[qwq.x][qwq.y]=0;
        q.pop();
        continue;
    }
    for(int i=1;i<=4;i++){
        qwq=q.front();
        qwq.x+=dx[i];
        qwq.y+=dy[i];
        qwq.tim++;
        if(qwq.x>0&&qwq.x<=n&&qwq.y>0&&qwq.y<=m&&(a[qwq.x][qwq.y]==0||a[qwq.x][qwq.y]==4)&&b[qwq.x][qwq.y]==0){
            q.push(qwq);
            b[qwq.x][qwq.y]=1;
        }
    }
    q.pop();
}
```
    - **核心思想**：进行两次BFS，第一次从起点出发，将遇到的灌木丛标记为可通行，记录到灌木丛的最短时间；第二次从终点出发，最后枚举灌木丛取距离之和的最小值。

- **作者：那一条变阻器（4星）**
    - **关键亮点**：采用分层图最短路的方法，将问题转化为图论问题，通过构建分层图和使用SPFA算法求解，思路新颖。
    - **核心代码**：
```cpp
for(int i = 1; i <= n; i++)
    for(int j = 1; j <= m; j++){
        if(a[i][j] == 1) continue;
        if(a[i][j] == 4) add(id(i, j), id(i, j) + n * m);
        if((a[i - 1][j] == 0 || a[i - 1][j] == 2 || a[i - 1][j] == 4) && i!= 1) add(id(i, j), id(i - 1, j));
        // 其他连边情况...
    }
spfa(s);
cout << dis[p + n * m] - 1;
```
    - **核心思想**：构建分层图，在找到灌木的位置向骑士那一层连边，从起点跑一次SPFA算法，最后输出到达终点对应层的最短距离减1。

### 最优关键思路或技巧
- **增加状态维度**：如Wenoide的题解，通过增加“是否已取得灌木”的状态维度，用一次BFS解决问题，减少搜索次数。
- **分层图**：将问题转化为分层图，通过构建图和连边，利用图论算法求解，适用于有状态转换的路径问题。
- **双向BFS**：部分题解采用双向BFS，从起点和终点同时搜索，平衡搜索树的大小，降低时间复杂度。

### 可拓展之处
同类型题或类似算法套路：
- 涉及状态转换的路径问题，如在地图中需要满足特定条件才能通过某些区域的最短路径问题。
- 有中间点的最短路问题，可采用正反两遍最短路，最后枚举中间点求和的方法。

### 推荐题目
- [P1141 01迷宫](https://www.luogu.com.cn/problem/P1141)：涉及在二维网格中搜索连通块的问题，可使用BFS或DFS。
- [P1332 血色先锋队](https://www.luogu.com.cn/problem/P1332)：多源BFS问题，与本题的BFS思路有相似之处。
- [P1605 迷宫](https://www.luogu.com.cn/problem/P1605)：基础的迷宫搜索问题，可帮助巩固BFS和DFS的使用。

---
处理用时：35.99秒
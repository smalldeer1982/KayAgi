# 题目信息

# [USACO19JAN] Cow Poetry G

## 题目背景

USACO19 年一月金组第一题

## 题目描述

不为 Farmer John 所知的是，Bessie 还热衷于资助艺术创作！最近，她开始研究许多伟大的诗人们，而现在，她想要尝试创作一些属于自己的诗歌了。
Bessie 认识 $N$（$1 \leq N \leq 5000$）个单词，她想要将她们写进她的诗。Bessie 已经计算了她认识的每个单词的长度，以音节为单位，并且她将这些单词划分成了不同的“韵部”。每个单词仅与属于同一韵部的其他单词押韵。

Bessie 的每首诗由 $M$ 行组成（$1 \leq M \leq 10^5$），每一行必须由 $K$（$1 \leq K \leq 5000$）个音节构成。此外，Bessie 的诗必须遵循某个指定的押韵模式。

Bessie 想要知道她可以写出多少首符合限制条件的不同的诗。

## 说明/提示

在这个例子中，Bessie 认识三个单词。前两个单词押韵，长度分别为三个音节和四个音节，最后一个单词长度为三个音节，不与其他单词押韵。她想要写一首三行的诗，每行包含十个音节，并且第一行和最后一行押韵。共有 $960$ 首这样的诗。以下是一首满足要求的诗（其中 $1,2,3$ 分别代表第一个、第二个、第三个单词）：$\text{121 123 321}$。

## 样例 #1

### 输入

```
3 3 10
3 1
4 1
3 2
A
B
A```

### 输出

```
960```

# AI分析结果

### 综合分析与结论
这些题解的核心思路都是通过动态规划来解决问题，先计算出每行诗的方案数，再根据押韵模式计算整首诗的方案数。不同题解在状态定义、转移方程和优化方法上略有差异，但整体思路一致。主要的算法要点包括完全背包求方案数、快速幂计算幂次、状态压缩优化复杂度等。难点在于如何高效地处理状态转移和避免超时、超内存等问题。

### 所选题解
- **作者：Henry_he (赞：18)，4星**
    - **亮点**：思路清晰，代码简洁，对状态转移的解释较为详细，通过简单的完全背包思想解决问题，并且使用快速幂进行幂次计算。
    - **个人心得**：无

- **作者：CYJian (赞：16)，4星**
    - **亮点**：详细推导了状态转移方程，对复杂度进行了分析和优化，通过引入辅助数组将复杂度从 $O(N^2K)$ 优化到 $O(NK)$，代码规范。
    - **个人心得**：无

- **作者：Hisaishi_Kanade (赞：3)，4星**
    - **亮点**：将问题分解为一行诗和一整首诗的情况分别处理，思路清晰，对状态转移的优化解释详细，代码中包含了一些实用的输入输出函数。
    - **个人心得**：“这是我们今天课上一道练习，结果全班就我一个过了。看到这道题我就有了思路（不过还是调了很久）”，说明即使有思路，实现过程中也可能遇到问题，需要耐心调试。

### 重点代码及核心实现思想
#### Henry_he 的题解
```cpp
f[0]=1;
for(int j=0;j<=k;j++)
    if(f[j]) 
        for(int i=1;i<=n;i++)
            if(j+s[i]<=k)	f[j+s[i]]=(f[j+s[i]]+f[j])%mod;
for(int i=1;i<=n;i++)
    g[c[i]]=(g[c[i]]+f[k-s[i]])%mod;
```
核心思想：先通过完全背包计算出音节填了 $j$ 位的方案总数 $f[j]$，再统计最后一个词的韵部的方案数 $g[c[i]]$。

#### CYJian 的题解
```cpp
s[0] = 1;
for(reg int i = 1; i <= k; i++) {
    for(reg int j = 1; j <= n; j++) {
        if(i >= l[j]) {
            f[i][y[j]] = (f[i][y[j]] + s[i - l[j]]) % mod;
            s[i] = (s[i] + s[i - l[j]]) % mod;
        }
    }
}
```
核心思想：定义状态 $f[i][j]$ 表示长度为 $i$ 句子，且最后一个词语的韵律为 $j$ 的方案数，通过辅助数组 $s[i]$ 优化状态转移，降低复杂度。

#### Hisaishi_Kanade 的题解
```cpp
sum[0]=1;
for(i=1; i<=k; ++i) {
    for(j=1; j<=n; ++j) {
        if(i>=s[j]) {
            (f[i][c[j]]+=sum[i-s[j]])%=mod;
            (sum[i]+=sum[i-s[j]])%=mod;
        }
    }
}
```
核心思想：先计算出凑成 $i$ 个音节的方案总数 $sum[i]$，再计算出以某个韵部结尾的方案数 $f[i][c[j]]$。

### 最优关键思路或技巧
- **状态压缩**：通过引入辅助数组，避免不必要的枚举，降低时间复杂度，如 CYJian 和 Hisaishi_Kanade 的题解。
- **快速幂优化**：在计算幂次时使用快速幂算法，提高计算效率。
- **分阶段处理**：将问题分解为一行诗和一整首诗的情况分别处理，使思路更清晰。

### 可拓展之处
同类型题或类似算法套路包括其他的计数类动态规划问题，如不同物品组合成特定价值的方案数、满足特定条件的排列组合数等。可以通过定义合适的状态和转移方程，结合快速幂等优化方法来解决。

### 推荐题目
- [P1048 采药](https://www.luogu.com.cn/problem/P1048)：经典的 0 - 1 背包问题，与本题的动态规划思想有相似之处。
- [P1616 疯狂的采药](https://www.luogu.com.cn/problem/P1616)：完全背包问题，和本题中计算方案数的思路类似。
- [P1832 A+B Problem（再升级）](https://www.luogu.com.cn/problem/P1832)：计数类动态规划问题，需要通过状态转移计算满足条件的方案数。

---
处理用时：34.90秒
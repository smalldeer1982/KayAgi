# 题目信息

# [USACO19DEC] Milk Visits S

## 题目描述

Farmer John 计划建造 $N$ 个农场，用 $N-1$ 条道路连接，构成一棵树（也就是说，所有农场之间都互相可以到达，并且没有环）。每个农场有一头奶牛，品种为更赛牛或荷斯坦牛之一。

Farmer John 的 $M$ 个朋友经常前来拜访他。在朋友 $i$ 拜访之时，Farmer John 会与他的朋友沿着从农场 $A_i$ 到农场 $B_i$ 之间的唯一路径行走（可能有 $A_i = B_i$）。除此之外，他们还可以品尝他们经过的路径上任意一头奶牛的牛奶。由于 Farmer John 的朋友们大多数也是农场主，他们对牛奶有着极强的偏好。他的有些朋友只喝更赛牛的牛奶，其余的只喝荷斯坦牛的牛奶。任何 Farmer John 的朋友只有在他们访问时能喝到他们偏好的牛奶才会高兴。

请求出每个朋友在拜访过后是否会高兴。

## 说明/提示

在这里，从农场 1 到农场 4 的路径包括农场 1、2 和 4。所有这些农场里都是荷斯坦牛，所以第一个朋友会感到满意，而第二个朋友不会。

关于部分分：

测试点 $1$ 样例。

测试点 $2\sim 5$ 满足 $N\le 10^3$，$M\le 2\cdot 10^3$。

对于 $100\%$ 的数据，$1 \leq N \leq 10^5$，$1 \leq M \leq 10^5$。

供题：Spencer Compton

## 样例 #1

### 输入

```
5 5
HHGHG
1 2
2 3
2 4
1 5
1 4 H
1 4 G
1 3 G
1 3 H
5 5 H```

### 输出

```
10110```

# AI分析结果

### 综合分析与结论
这些题解主要围绕判断树上两点路径中是否存在特定颜色的节点展开，涉及并查集、LCA（最近公共祖先）相关算法，如倍增LCA、树链剖分求LCA，还有树上莫队等方法。并查集思路简单，通过合并同色节点判断路径情况；LCA类方法利用预处理和节点跳跃来查询路径信息；树上莫队则借助欧拉序和分块处理查询。

### 所选题解
- **作者：ycmir27（5星）**
    - **关键亮点**：思路简洁清晰，代码难度极小，利用并查集合并同色连通块，快速判断路径上是否有偏好的牛奶。
    - **核心代码**：
```cpp
int find(int x)
{
    if(x==fa[x]) return x;
    return fa[x]=find(fa[x]);
}
void merge(int x,int y)
{
    fa[find(x)]=find(y);
}
//...
for(int i=1;i<=N-1;i++)
{
    int u,v;cin>>u>>v;
    if(col[u]==col[v]) merge(u,v);
}
for(int i=1;i<=M;i++)
{
    int a,b; cin>>a>>b;
    char c; cin>>c;
    if(find(a)==find(b)&&col[a]!=c) ans[++cnt]=0;
    else ans[++cnt]=1;
}
```
    - **核心思想**：通过 `find` 函数查找节点的根节点，`merge` 函数合并同色节点所在集合。在处理查询时，若两点在同一集合且集合颜色与目标颜色不同，输出 0，否则输出 1。

- **作者：密期望（4星）**
    - **关键亮点**：提出用 `top` 数组表示节点向上连续同色能到达的最远点，将问题转化为判断路径是否同色，时间复杂度为 $O(n)$。
    - **核心代码**：
```cpp
void dfs(int now=1,int t=1,int f=0){
    top[now]=t;
    REPL(now,i,to)if(f!=to)dfs(to,c[to]==c[now]?t:to,now);
}
//...
for(int i=0;i<m;i++){
    p1=read();
    p2=read();
    p3=read_color();
    printf("%d",c[p1]==p3||c[p2]==p3||top[p1]!=top[p2]?1:0);
}
```
    - **核心思想**：`dfs` 函数更新 `top` 数组，在处理查询时，若两点 `top` 不同或某点颜色与目标颜色相同，输出 1，否则输出 0。

- **作者：tiger2005（4星）**
    - **关键亮点**：使用倍增LCA，维护节点到根节点路径上H和G的数量，通过树上差分计算两点间路径上的颜色数量，复杂度为 $O(N + QlogN)$。
    - **核心代码**：
```cpp
void dfs(int u){
    H[u]=H[fa[u]]+(PZ[u]=='H');
    G[u]=G[fa[u]]+(PZ[u]=='G');
    dep[u]=dep[fa[u]]+1;
    for(int i=tt[u];i;i=qxx[i][1]){
        int v=qxx[i][0];
        if(v==fa[u]) continue;
        fa[v]=u;
        dfs(v);
    }
}
int lca(int u,int v){
    if(dep[u]<dep[v]) swap(u,v);
    for(int i=17;i+1;i--)
        if(dep[bz[u][i]]>=dep[v]) u=bz[u][i];
    if(u==v) return u;
    for(int i=17;i+1;i--)
        if(bz[u][i]!=bz[v][i]) u=bz[u][i],v=bz[v][i];
    return fa[u];
}
//...
for(int i=1,a,b;i<=M;i++){
    scanf("%d%d",&a,&b);
    char c;scanf(" %c",&c);
    int u=lca(a,b);
    int hh=H[a]+H[b]-H[u]*2+(PZ[u]=='H');
    int gg=G[a]+G[b]-G[u]*2+(PZ[u]=='G');
    if(c=='H'){
        if(hh) printf("1");
        else printf("0");
    }
    else{
        if(gg) printf("1");
        else printf("0");
    }
}
```
    - **核心思想**：`dfs` 函数预处理节点深度和到根节点的颜色数量，`lca` 函数求两点的最近公共祖先。在处理查询时，通过树上差分计算路径上的颜色数量，判断是否满足要求。

### 最优关键思路或技巧
- 利用并查集合并同色节点，将判断路径上是否有特定颜色转化为判断两点是否在同一集合且集合颜色是否与目标颜色不同，简化问题。
- 对于LCA问题，使用倍增法预处理和查询，结合树上前缀和与差分，高效计算路径信息。

### 可拓展之处
同类型题如判断树上两点路径中特定属性节点的数量、判断路径上是否存在满足某种条件的节点等。类似算法套路可应用于树上路径问题，如树链剖分处理树上区间查询、树上启发式合并处理子树信息等。

### 推荐题目
- [P3379 【模板】最近公共祖先（LCA）](https://www.luogu.com.cn/problem/P3379)
- [P2580 于是他错误的点名开始了](https://www.luogu.com.cn/problem/P2580)
- [P3367 【模板】并查集](https://www.luogu.com.cn/problem/P3367)

### 个人心得摘录与总结
- **作者：tiger2005**：做题时先想到LCA，发现只有两种状态要维护，开两个数组维护即可。总结为遇到树上路径问题可考虑LCA，根据状态数量合理选择维护方式。
- **作者：神仙酱**：使用树上莫队时，因忘记统计LCA的答案调了四五个小时。提醒在使用树上莫队处理查询时，要注意LCA的答案统计。 

---
处理用时：43.17秒
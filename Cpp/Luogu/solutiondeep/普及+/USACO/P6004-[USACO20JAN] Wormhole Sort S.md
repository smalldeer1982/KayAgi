# 题目信息

# [USACO20JAN] Wormhole Sort S

## 题目描述

Farmer John 的奶牛们已经厌倦了他对她们每天早上排好序离开牛棚的要求。她们刚刚完成了量子物理学的博士学位，准备将这一过程搞快点。

今天早上，如同往常一样，Farmer John 的 $N$ 头编号为 $1 \ldots N$ 的奶牛（$1 \leq N \leq 10^5$），分散在牛棚中 $N$ 个编号为 $1 \ldots N$ 的不同位置，奶牛 $i$ 位于位置 $p_i$。但是今天早上还出现了 $M$ 个编号为 $1 \ldots M$ 的虫洞（$1 \leq M \leq 10^5$），其中虫洞 $i$ 双向连接了位置 $a_i$ 和 $b_i$，宽度为 $w_i$（$1\le a_i,b_i\le N, a_i\neq b_i, 1\le w_i\le 10^9$）。

在任何时刻，两头位于一个虫洞两端的奶牛可以选择通过虫洞交换位置。奶牛们需要反复进行这样的交换，直到对于 $1 \leq i \leq N$，奶牛 $i$ 位于位置 $i$。

奶牛们不想被虫洞挤坏。帮助她们最大化被她们用来排序的虫洞宽度的最小值。保证奶牛们有可能排好序。

## 说明/提示

### 样例解释 1

以下是一个仅用宽度至少为 9 的虫洞给奶牛排序的可能方案：

- 奶牛 1 和奶牛 2 使用第三个虫洞交换位置。
- 奶牛 1 和奶牛 3 使用第一个虫洞交换位置。
- 奶牛 2 和奶牛 3 使用第三个虫洞交换位置。

### 子任务

- 测试点 $3 \sim 5$ 满足 $N,M \leq 1000$。
- 测试点 $6 \sim 10$ 没有额外限制。

## 样例 #1

### 输入

```
4 4
3 2 1 4
1 2 9
1 3 7
2 3 10
2 4 3```

### 输出

```
9```

## 样例 #2

### 输入

```
4 1
1 2 3 4
4 2 13```

### 输出

```
-1```

# AI分析结果

### 综合分析与结论
这些题解主要围绕并查集来解决“最大化被用来排序的虫洞宽度的最小值”问题。大部分题解都提到了利用并查集判断连通性，部分题解结合二分答案优化时间复杂度。

思路方面，有直接按边权从大到小加边判断的，也有二分边权最小值再用并查集检查的。算法要点在于并查集的路径压缩优化和对边权的排序处理。难点在于如何高效判断奶牛是否能回到自己的位置，以及优化时间复杂度避免超时。

### 所选题解
- **作者：houzhiyuan（4星）**
    - **关键亮点**：思路清晰，先给出暴力代码分析复杂度，再进行优化，代码注释详细。
    - **个人心得**：通过分析暴力代码的时间复杂度 $O(nm + mlogm)$ 发现会超时，进而优化，利用“当一个点已经满足要求时，加边还是满足要求”的性质，将时间复杂度优化到 $O(n + m + mlogm)$。
- **作者：FourteenObsidian（4星）**
    - **关键亮点**：明确指出用二分答案结合并查集的思路，对判断函数的原理有详细解释。
    - **个人心得**：注意到“最大化最小值”的关键信息，从而想到二分答案，用类似冒泡排序的思想证明判断函数的正确性。
- **作者：Karl_Aurora（4星）**
    - **关键亮点**：详细阐述二分和并查集的思路，代码有输入输出优化。
    - **个人心得**：通过讨论得出本题不是最小生成树问题，而是用二分枚举边权最小值，用并查集判断连通性。

### 重点代码
#### houzhiyuan 题解核心代码
```cpp
// 并查集查找祖先
int zuxian(int k){
    if(f[k]==k){
        return k;
    }
    else{
        return f[k]=zuxian(f[k]);
    }
}
// 主函数部分
for(int i=1;i<=m;i++){
    int x1=zuxian(cow[i].x);
    int x2=zuxian(cow[i].y);
    if(x1!=x2){
        f[x1]=f[x2];
    }
    while(zuxian(j)==zuxian(a[j])){
        j++;
    }
    if(j>n){
        cout<<cow[i].z<<endl;
        return 0;
    }
}
```
**核心思想**：按边权从大到小加边，用并查集合并连通块，通过一个指针 `j` 记录第一个不满足条件的奶牛，当所有奶牛都满足条件时输出当前边权。

#### FourteenObsidian 题解核心代码
```cpp
// 并查集查找祖先
int getfather(int x) {return x == f[x] ? x : f[x] = getfather(f[x]);}
// 检查函数
bool check(int x)
{
    for(int i = 1; i <= n; ++i)
        f[i] = i;
    for(int i = 1; i <= m && h[i].w >= x; ++i)
    {
        int fa = getfather(h[i].a),fb = getfather(h[i].b);
        f[fa] = fb;
    }
    for(int i = 1; i <= dtot; ++i)
        if(getfather(p[disl[i]]) != getfather(disl[i]))
            return 0;
    return 1;
}
// 二分部分
while(l <= r)
{
    mid = (l + r) >> 1;
    if(check(mid))
    {
        l = mid + 1;
        ans = mid;
    }
    else r = mid - 1;
}
```
**核心思想**：二分边权最小值，每次检查时将边权大于等于该值的边加入并查集，判断所有错位的奶牛是否都能回到自己的位置。

#### Karl_Aurora 题解核心代码
```cpp
// 并查集查找祖先
int find_father(int x) {if (f[x] == x) return x; return f[x] = find_father(f[x]);}
// 检查函数
bool check(int upp)
{
    for (register int i = 1; i <= n; ++i) f[i] = i;
    for (register int i = 1; i <= m; ++i)
    {
        if (s[i].w < upp) break;
        f[find_father(s[i].from)] = find_father(s[i].to);
    }
    for (register int i = 1; i <= n; ++i)
    {
        if (find_father(f[i]) != find_father(f[p[i]])) return false;
    }
    return true;
}
// 二分部分
while (l < r)
{
    mid = (l + r + 1) / 2;
    if (check(mid)) {l = mid; ans = mid;}
    else r = mid - 1;
}
```
**核心思想**：同样是二分边权最小值，在检查函数中合并边权大于等于该值的边，判断每个奶牛的所在位置与其目标位置是否连通。

### 最优关键思路或技巧
- **并查集路径压缩**：在查找祖先时，通过 `f[k] = zuxian(f[k])` 或 `f[x] = find_father(f[x])` 等方式将路径上的节点直接指向根节点，使查找时间复杂度接近 $O(1)$。
- **二分答案**：对于“最大化最小值”或“最小化最大值”问题，二分答案可以将求范围问题转化为求值问题，通过检查函数判断该值是否满足条件，缩小搜索范围。
- **优化判断过程**：避免每次都检查所有奶牛是否满足条件，如 houzhiyuan 题解中用指针记录第一个不满足条件的奶牛，减少不必要的判断。

### 可拓展之处
同类型题或类似算法套路：
- 涉及图的连通性问题，如判断图是否连通、求连通块数量等，都可以用并查集解决。
- 对于求“最大化最小值”或“最小化最大值”的问题，二分答案是常用的解题思路，结合具体问题用合适的数据结构（如并查集、优先队列等）实现检查函数。

### 推荐题目
- [P1551 亲戚](https://www.luogu.com.cn/problem/P1551)：并查集模板题，用于练习并查集的基本操作。
- [P2814 家谱](https://www.luogu.com.cn/problem/P2814)：并查集的应用，需要处理字符串和并查集的结合。
- [P1197 [JSOI2008]星球大战](https://www.luogu.com.cn/problem/P1197)：并查集与离线处理的结合，通过逆序操作解决问题。

---
处理用时：49.31秒
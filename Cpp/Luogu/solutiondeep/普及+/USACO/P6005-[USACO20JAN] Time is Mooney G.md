# 题目信息

# [USACO20JAN] Time is Mooney G

## 题目描述

Bessie 正在安排前往牛尼亚的一次出差，那里有 $N$（$2 \leq N \leq 1000$）个编号为 $1 \ldots N$ 的城市，由 $M$（$1 \leq M \leq 2000$）条单向的道路连接。Bessie 每次访问城市 $i$ 都可以赚到 $m_i$ 哞尼（$0 \leq m_i \leq 1000$）。从城市 $1$ 出发，Bessie 想要赚到尽可能多的哞尼，最后回到城市 $1$。为了避免争议，$m_1=0$。

沿着两个城市之间的道路移动需要消耗一天。出差的准备工作十分费钱；旅行 $T$ 天需要花费 $C \times T^2$ 哞尼（$1 \leq C \leq 1000$）。

Bessie 在一次出差中最多可以赚到多少哞尼？注意有可能最优方案是 Bessie 不访问城市 $1$ 之外的任何城市，在这种情况下结果应当为 $0$。

## 说明/提示

最优的旅行方案是 $1 \to 2 \to 3 \to 1 \to 2 \to 3 \to1$。Bessie 总共赚到了 $10+20+10+20-1 \times 6^2=24$ 哞尼。

## 样例 #1

### 输入

```
3 3 1
0 10 20
1 2
2 3
3 1```

### 输出

```
24```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何在有向图中找到从城市 1 出发并返回城市 1 的最大收益展开，使用了动态规划、广度优先搜索（BFS）、最短路算法（SPFA）等多种方法。各题解的关键在于处理时间和收益的关系，以及确定合理的搜索范围或状态转移方式。

### 所选题解
- **作者：奇米 (赞：12)，4星**
    - **关键亮点**：思路清晰，使用动态规划解决问题，通过反向建图简化状态转移，对搜索范围进行了合理的限制。
    - **核心代码**：
```cpp
//f[i][j]表示第i天到达第j座城市的最大收益
memset(f,-1,sizeof(f));
f[0][1]=0;
for ( int i=1;i<=1000;i++ ) {
    for ( int j=1;j<=n;j++ )
        for ( int k=head[j];k;k=e[k].nex ) {
            int v=e[k].to;
            if(~f[i-1][v]) 
                f[i][j]=max(f[i][j],f[i-1][v]+M[j]);
        }
    if(ans<f[i][1]-C*i*i) ans=f[i][1]-C*i*i;
}
```
    - **核心实现思想**：先将 `f` 数组初始化为 -1，`f[0][1]` 初始化为 0 表示第 0 天在城市 1 的收益为 0。然后枚举天数 `i`，对于每个城市 `j`，通过反向建的图找到上一个城市 `v`，如果 `f[i - 1][v]` 可达，则更新 `f[i][j]`。最后更新最大收益 `ans`。

- **作者：UltiMadow (赞：6)，4星**
    - **关键亮点**：使用 BFS 方法，并添加了搜索时间限制和最优性剪枝两个优化，有效减少了搜索空间。
    - **核心代码**：
```cpp
void bfs()
{
    queue<Nodex>Q;
    Q.push((Nodex){1,0,0});//队列中存当前节点，到达当前节点的时间，到达当前节点赚的钱
    while(!Q.empty())
    {
        Nodex tmp=Q.front();Q.pop();
        int u=tmp.now,t=tmp.tim,w=tmp.dis;
        for(int i=Head[u];i;i=Edge[i].next)
        {
            int v=Edge[i].to,nowt=t+1,noww=w+val[v];
            if(v==1)ans=max(ans,w-c*nowt*nowt);//统计答案
            bool fl=true;
            for(int j=nowt;j>=1;j--)
                if(ear[v][j]>=noww-c*nowt*nowt)
                {
                    fl=false;
                    break;
                } //最优性剪枝
            if(!fl)continue;
            ear[v][nowt]=noww-c*nowt*nowt;
            if(nowt<T)Q.push((Nodex){v,nowt,noww});//搜索边界
        }
    }
}
```
    - **核心实现思想**：使用队列存储当前节点、到达时间和收益。每次从队列中取出一个节点，扩展其相邻节点，更新收益。如果到达城市 1，则更新答案。通过最优性剪枝判断是否继续搜索，通过搜索时间限制控制搜索范围。

### 最优关键思路或技巧
- **状态表示**：使用二维数组 `f[i][j]` 表示第 `i` 天到达城市 `j` 的最大收益，方便进行状态转移。
- **搜索范围限制**：通过数学推导得出搜索的时间上限，避免不必要的搜索，如 `maxval * T - c * T^2 > 0` 解得 `T < maxval / c`。
- **最优性剪枝**：在搜索过程中，如果之前某个时刻在当前点的收益比现在高，则停止当前分枝的搜索。

### 可拓展之处
同类型题可能涉及更复杂的图结构、更多的限制条件或不同的收益计算方式。类似算法套路包括分层图最短路、状态压缩动态规划等，可用于解决具有多个状态维度的问题。

### 推荐题目
- [P1877 音量调节](https://www.luogu.com.cn/problem/P1877)：考察动态规划的状态转移。
- [P1140 相似基因](https://www.luogu.com.cn/problem/P1140)：涉及动态规划的应用和状态定义。
- [P1006 传纸条](https://www.luogu.com.cn/problem/P1006)：需要使用动态规划解决多路径问题。

### 个人心得摘录与总结
- **作者：wmy_goes_to_thu**：原文认为 dij 可以解决正权最长路问题，后发现不正确，认识到正权最长路等价于取反跑最短路，dij 不适用。总结：在使用算法时要准确理解其适用范围，避免错误应用。
- **作者：UltiMadow**：考场上看到题目没有思路，后来通过分析数据范围，采用暴力加优化的方法通过。总结：当没有思路时，可以从数据范围入手，尝试使用暴力方法并添加优化。 

---
处理用时：38.57秒
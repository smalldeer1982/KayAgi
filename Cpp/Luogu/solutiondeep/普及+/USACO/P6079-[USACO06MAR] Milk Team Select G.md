# 题目信息

# [USACO06MAR] Milk Team Select G

## 题目描述

Farmer John 的 $N(1 \le N \le 500)$ 头奶牛打算参加一场世界级的产奶比赛 （Multistate Milking Match-up，MMM），他们已经摸清了其他队的实力。他们的总产奶量只要大于等于 $X$ 加仑（$1 \leq X \leq 10^6$），就能赢得胜利。

每头奶牛都能为全队贡献一定量的牛奶，数值在 $-10^4$ 到 $10^4$ 加仑之间（为啥有负数？因为有些奶牛会打翻其他奶牛产的牛奶）。

MMM 的目标是通过合作，增进家庭成员间的默契。为了支持比赛精神，奶牛们希望在赢得比赛的前提下，有尽可能多对奶牛间存在直系血缘关系。当然，所有奶牛都是女性，因此这里的直系血缘关系就是母女关系。

现在 FJ 摸清了所有奶牛间的血缘关系，希望算出一个团队在赢得胜利的前提下，最多有多少对奶牛存在血缘关系。注意：如果一个团队由某头奶牛和她的母亲和外祖母组成的话，这个团队只有两对血缘关系（她和她的母亲，她的母亲和外祖母）。

## 说明/提示

最优的队伍包含 $1,2,3,5$ 这四头奶牛，总产奶量为 $9$ 加仑，共有两对血缘关系（$1,2$ 和 $1,3$）。

虽然 $2,3,5$ 这个组合产奶量更大，但是这个组合里没有血缘关系。

## 样例 #1

### 输入

```
5 8
-1 0
3 1
5 1
-3 3
2 0```

### 输出

```
2```

# AI分析结果

### 综合分析与结论
这些题解均采用树形动态规划来解决问题。由于奶牛的母女关系构成森林，为方便处理，都引入虚拟节点 0 将森林转化为树。各题解的核心思路都是通过状态转移方程，在满足产奶量要求的前提下，求出最多的血缘关系对数。

各题解的主要区别在于状态的定义和状态转移方程的具体形式，但本质都是在树形结构上进行动态规划。

### 所选题解
- **作者：Zjl37 (赞：20)  ★★★★**
  - 关键亮点：思路清晰，对状态的定义和状态转移过程解释详细，代码注释丰富，易于理解。
- **作者：Purslane (赞：5)  ★★★★**
  - 关键亮点：状态定义和转移逻辑明确，代码简洁，使用 `vector` 存储图结构，实现较为方便。
- **作者：CYZZ (赞：1)  ★★★★**
  - 关键亮点：对状态转移方程的解释较为详细，通过具体代码展示状态转移过程，便于理解。

### 重点代码及核心实现思想
#### Zjl37 的题解
```cpp
void dfs(int x) {
    f[x][0][0]=0;
    f[x][0][1]=c[x];
    for(int i=hd[x]; i; i=e[i].second) {
        int y=e[i].first;
        dfs(y);
        for(int j=cnt[x]; j>=0; j--) {
            for(int k=cnt[y]; k>=0; k--) {
                if(f[x][j][0]+max(f[y][k][0],f[y][k][1])>f[x][j+k][0])
                    f[x][j+k][0]=f[x][j][0]+max(f[y][k][0],f[y][k][1]);
                if(f[x][j][1]+f[y][k][1]>f[x][j+k+1][1])
                    f[x][j+k+1][1]=f[x][j][1]+f[y][k][1];
                if(f[x][j][1]+f[y][k][0]>f[x][j+k][1])
                    f[x][j+k][1]=f[x][j][1]+f[y][k][0];
            }
        }
        cnt[x]+=cnt[y]+1;
    }
}
```
核心思想：`dfs` 函数进行树形动规，先初始化当前节点的状态，然后递归处理子节点，通过三重循环进行状态转移，最后更新以当前节点为根的子树的边数。

#### Purslane 的题解
```cpp
void dfs(int u) {
    dp[u][0][1]=val[u],dp[u][0][0]=0;
    for(auto to:G[u]) {
        dfs(to);
        roff(k,n-1,0) {
            roff(kk,k,0) dp[u][k][0]=max(dp[u][k][0],dp[u][kk][0]+max(dp[to][k-kk][0],dp[to][k-kk][1]));
            roff(kk,k,0) dp[u][k][1]=max(dp[u][k][1],dp[u][kk][1]+dp[to][k-kk][0]);
            roff(kk,k-1,0) dp[u][k][1]=max(dp[u][k][1],dp[u][kk][1]+dp[to][k-kk-1][1]);
        }
    }
}
```
核心思想：`dfs` 函数进行树形动规，先初始化当前节点的状态，然后递归处理子节点，通过反向枚举进行状态转移。

#### CYZZ 的题解
```cpp
void dfs(int u) {
    dp[u][0][1]=a[u];
    dp[u][0][0]=0;
    for(int i=head[u];i;i=e[i].next) {
        int v=e[i].to;
        dfs(v);
        for(int j=n-1;j>=0;j--) {
            for(int k=j;k>=0;k--) {
                dp[u][j][0]=max(dp[u][j][0],dp[u][k][0]+max(dp[v][j-k][1],dp[v][j-k][0]));
                dp[u][j][1]=max(dp[u][j][1],dp[u][k][1]+dp[v][j-k][0]);
                if(j-k-1>=0)
                    dp[u][j][1]=max(dp[u][j][1],dp[u][k][1]+dp[v][j-k-1][1]);
            }
        }
    }
}
```
核心思想：`dfs` 函数进行树形动规，先初始化当前节点的状态，然后递归处理子节点，通过双重循环进行状态转移，注意第三类转移时要特判。

### 最优关键思路或技巧
- **引入虚拟节点**：将森林转化为树，方便进行树形动态规划。
- **状态定义**：通过三维数组记录节点是否参赛、血缘关系对数和最大产奶量，便于状态转移。
- **反向枚举**：避免状态转移时的重复计算。

### 可拓展之处
同类型题或类似算法套路：树形背包问题，在树形结构上进行动态规划，通过状态转移方程求解最优解。

### 推荐题目
- [P1273 有线电视网](https://www.luogu.com.cn/problem/P1273)
- [P2014 选课](https://www.luogu.com.cn/problem/P2014)
- [P2015 二叉苹果树](https://www.luogu.com.cn/problem/P2015)

### 个人心得摘录与总结
- **CYZZ**：“比赛的时候因为一行代码挂了 64 分”，总结：在编写代码时要仔细检查，避免因小错误导致大量失分。

---
处理用时：36.64秒
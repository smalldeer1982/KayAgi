# 题目信息

# [USACO11NOV] Cow Beauty Pageant S

## 题目描述

听说最近流行表皮有三个斑点的奶牛，Farmer John 迅速购买了不少这样的奶牛。但流行趋势也在改变，最近改为流行只有一个斑点的奶牛了。

FJ 决定在他的奶牛上涂色，从而把三个斑点合并成一个。牛皮由一个 $N \times M$ 的矩阵来表示，像这样：

```plain
................
..XXXX....XXX...
...XXXX....XX...
.XXXX......XXX..
........XXXXX...
..XXX....XXX....
```

每个 `X` 表示斑点的一部分。如果两个 `X` 在竖直或水平方向上相邻，则它们属于同一个斑点（对角线相邻不算）。因此上面表示的是一头具有三个斑点的奶牛。

FJ 可以通过将一些 `.` 涂成 `X` 来改变牛身上的图案。他希望使用尽可能少的涂料将三个斑点合并为一个斑点。对于上图，下面是一种消耗涂料最少的方案（只涂了 4 个格子，新涂的格将用 `*` 表示）：

```plain
................
..XXXX....XXX...
...XXXX*...XX...
.XXXX..**..XXX..
...*....XXXXX...
..XXX....XXX....
```

现在请你帮 FJ 算出将三个斑点合并为一个斑点最少需要涂多少格子。

## 样例 #1

### 输入

```
6 16
................
..XXXX....XXX...
...XXXX....XX...
.XXXX......XXX..
........XXXXX...
..XXX....XXX....```

### 输出

```
4```

# AI分析结果

### 综合分析与结论
这些题解的核心思路一致，先区分三个连通块，再考虑两种连接方式：一是两个连通块连到第三个，二是三个连通块连到一个非连通点，最后取两种方式的最小代价。

在算法实现上，多数题解使用 DFS 或 BFS 标记连通块，用曼哈顿距离计算代价。部分题解使用了最小生成树、暴力枚举等方法。

### 所选题解
- **qzhwlzy（5星）**
    - **关键亮点**：思路清晰，详细阐述两种连接情况，代码注释丰富，便于理解。
    - **核心代码**：
```cpp
// 第一种操作
for(int k=1;k<=n;k++){
    for(int l=1;l<=m;l++){
        if(a[k][l]==0){
            continue;
        }
        if(a[k][l]!=a[i][j]&&dis[a[i][j]][a[k][l]]>abss(i-k)+abss(j-l)){
            dis[a[k][l]][a[i][j]]=min(dis[a[k][l]][a[i][j]],abss(i-k)+abss(j-l));
        }
    }
}
// 第二种操作
int xx[4];
xx[1]=xx[2]=xx[3]=999999;
for(int p=1;p<=n;p++){
    for(int q=1;q<=m;q++){
        if(x[p][q]=='X'){
            xx[a[p][q]]=min(xx[a[p][q]],abss(i-p)+abss(j-q)-1);
        }
    }
}	
return xx[1]+xx[2]+xx[3]+1;
```
    - **核心思想**：第一种操作暴力枚举不同连通块的点，计算曼哈顿距离更新最小距离；第二种操作枚举非连通点，计算到三个连通块的最小曼哈顿距离之和。

- **wssdl（4星）**
    - **关键亮点**：图文结合解释两种走法，代码注释详细，使用 BFS 实现两种走法。
    - **核心代码**：
```cpp
// 第一种走法
for (int k = 1; k <= 3; k++) {
    len1 = 0, len2 = 0;
    memset(a1, 0, sizeof(a1));
    memset(a2, 0, sizeof(a2));
    int k1, k2;
    if (k == 1) {
        k1 = 2, k2 = 3;
    } else if (k == 2) {
        k1 = 1, k2 = 3;
    } else {
        k1 = 1, k2 = 2;
    }
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            if (ans[i][j] == k) {
                int tmp1 = bfs(i, j, 0, k1, k);
                int tmp2 = bfs(i, j, 0, k2, k);
                if (tmp1!= -1) {
                    a1[++len1] = tmp1 - 1;
                }
                if (tmp2!= -1) {
                    a2[++len2] = tmp2 - 1;
                }
            }
        }
    }
    for (int i = 1; i <= len1; i++) {
        for (int j = 1; j <= len2; j++) {
            minx1 = min(minx1, a1[i] + a2[j]);
        }
    }
}
// 第二种走法
for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= m; j++) {
        if (a[i][j]!= '#') {
            int ans1, ans2, ans3;
            ans1 = Bfs(i, j, 0, 1);
            ans2 = Bfs(i, j, 0, 2);
            ans3 = Bfs(i, j, 0, 3);
            if (ans1!= -1 && ans2!= -1 && ans3!= -1) {
                minx2 = min(minx2, ans1 + ans2 + ans3 - 3 + 1);
            }
        }
    }
}
```
    - **核心思想**：第一种走法枚举连通块，用 BFS 计算到另外两个连通块的距离；第二种走法枚举非连通点，用 BFS 计算到三个连通块的距离。

### 最优关键思路与技巧
- **连通块标记**：使用 DFS 或 BFS 标记不同的连通块，便于后续计算。
- **曼哈顿距离**：利用曼哈顿距离快速计算两点间的距离。
- **分类讨论**：将连接方式分为两种情况，分别计算最小代价。

### 可拓展之处
同类型题可拓展到多个连通块的合并问题，可考虑使用更高效的算法，如 Kruskal 算法求最小生成树。

### 推荐题目
- P1195 口袋的天空：求最小生成树的边权和。
- P1396 营救：求两点间路径上的最大边权的最小值。
- P2872 [USACO07DEC]Building Roads S：添加边使图连通，求最小代价。

### 个人心得摘录与总结
- **Engulf**：提到连接情况较坑，很难想到三个连通块连到一个点的情况。总结是做题时要全面考虑各种可能的连接方式。
- **Unordered_OIer**：提示无脑照抄代码有坑，强调理解代码的重要性。总结是学习代码要理解核心思路，不能盲目抄袭。 

---
处理用时：32.76秒
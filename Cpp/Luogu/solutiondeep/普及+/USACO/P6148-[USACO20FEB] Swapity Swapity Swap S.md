# 题目信息

# [USACO20FEB] Swapity Swapity Swap S

## 题目描述

Farmer John 的 $N$ 头奶牛（$1\leq N\leq 10^5$）站成一排。对于每一个 $1\leq i\leq N$，从左往右数第 $i$ 头奶牛的编号为 $i$。

Farmer John 想到了一个新的奶牛晨练方案。他给奶牛们 $M$ 对整数 $(L_1,R_1)\ldots (L_M,R_M)$，其中 $1\leq M\leq 100$。他让她们重复以下包含 $M$ 个步骤的过程 $K$（$1\leq K\leq 10^9$）次：

对于从 $1$ 到 $M$ 的每一个 $i$：
- 当前从左往右数在位置 $L_i\ldots R_i$ 的奶牛序列反转她们的顺序。
- 当奶牛们重复这一过程 $K$ 次后，请对每一个 $1\leq i\leq N$ 输出从左往右数第 $i$ 头奶牛的编号。

## 说明/提示

#### 样例解释：
初始时，奶牛们的顺序从左往右为 [$1,2,3,4,5,6,7$]。在这一过程的第一步过后，顺序变为 [$1,5,4,3,2,6,7$]。在这一过程的第二步过后，顺序变为 [$1,5,7,6,2,3,4$]。再重复这两个步骤各一次可以得到样例的输出。

#### 子任务：
- 测试点 $2$ 满足 $N=K=100$。
- 测试点 $3$-$5$ 满足 $K\leq 10^3$。
- 测试点 $6$-$10$ 没有额外限制。

## 样例 #1

### 输入

```
7 2 2
2 5
3 7```

### 输出

```
1
2
4
3
5
7
6```

# AI分析结果

### 综合分析与结论
本题的核心在于对大规模操作次数的优化，因为直接模拟会超时。各位作者提出了多种思路，主要分为倍增和找循环节两类。倍增思路利用操作的结合律，通过预处理 $2$ 的幂次操作，再将 $K$ 拆分为这些幂次的组合来减少时间复杂度；找循环节思路则是发现每个位置的变换会形成循环，利用同余快速求出最终位置。

### 所选题解
- **作者：Diaоsi (赞：29)，4星**
    - **关键亮点**：思路清晰，使用快速幂维护置换，详细解释了时间复杂度和置换的结合律，代码简洁规范。
    - **个人心得**：无
- **作者：kradcigam (赞：27)，4星**
    - **关键亮点**：结合具体题目分析倍增思路，代码中给出了详细的注释，复杂度分析明确。
    - **个人心得**：考场上没想到用倍增，只写了找循环节拿了30分。
- **作者：泥土笨笨 (赞：21)，4星**
    - **关键亮点**：通过具体例子详细解释了倍增的思想，代码实现逻辑清晰。
    - **个人心得**：分析了直接模拟的复杂度，意识到需要优化，提到多做题有助于想到倍增思路。

### 重点代码
#### Diaоsi的核心代码
```cpp
struct Permu{
    int m[N];
}a,e;
inline void init(){
    for(int i=1;i<=n;i++)
        a.m[i]=e.m[i]=i;
    for(int i=1;i<=m;i++){
        scanf("%d%d",&l[i],&r[i]);
        reverse(e.m+l[i],e.m+r[i]+1);
    }
}
inline Permu Mul(Permu x,Permu y){
    Permu c;
    for(int i=1;i<=n;i++)
        c.m[i]=x.m[y.m[i]];
    return c;
}
inline void Qpow(int p){
    while(p!=0){
        if(p&1)a=Mul(a,e);
        p>>=1;e=Mul(e,e);
    }
}
```
**核心实现思想**：定义置换结构体 `Permu`，`init` 函数预处理一次操作的置换，`Mul` 函数实现置换的乘法，`Qpow` 函数使用快速幂计算 $k$ 次操作后的置换。

#### kradcigam的核心代码
```cpp
for(int i=1;i<=m;i++)read(a[i]),read(b[i]);
for(int i=1;i<=n;i++)c[i]=i;
for(int i=1;i<=m;i++)reverse(c+a[i],c+b[i]+1);
for(int i=1;i<=n;i++)f[0][i]=c[i];
for(int i=1;i<=30;i++)
    for(int j=1;j<=n;j++)
        f[i][j]=f[i-1][f[i-1][j]];
for(int i=1;i<=n;i++){
    int x=i,m=k;
    for(int j=30;j>=0;j--)
        if(m>=(1ll<<j)){
            m-=(1ll<<j);
            x=f[j][x];
        }
    writen(x);
}
```
**核心实现思想**：先预处理一次操作后的结果 `f[0][i]`，然后通过状态转移方程 `f[i][j]=f[i-1][f[i-1][j]]` 计算 $2^i$ 次操作后的结果，最后将 $k$ 拆分为 $2$ 的幂次组合得到最终结果。

#### 泥土笨笨的核心代码
```cpp
vector<int> trans(vector<int> a, vector<int> rule) {
    vector<int> ans(n + 1, 0);
    for (int i = 1; i <= n; ++i) {
        ans[i] = a[rule[i]];
    }
    return ans;
}
vector<int> init() {
    vector<int> a(n + 1, 0);
    for (int i = 0; i <= n; ++i) {
        a[i] = i;
    }
    for (int i = 0; i < m; ++i) {
        for (int x = l[i], y = r[i]; x < y; ++x, --y) {
            swap(a[x], a[y]);
        }
    }
    return a;
}
vector<int> a;
for (int i = 0; i <= n; ++i) {
    a.push_back(i);
}
vector<int> base = init();
while (k) {
    if (k & 1) {
        a = trans(a, base);
    }
    base = trans(base, base);
    k >>= 1;
}
```
**核心实现思想**：`init` 函数预处理一次操作的结果，`trans` 函数实现一次操作的变换，通过快速幂的思想将 $k$ 次操作拆分为若干次变换。

### 最优关键思路或技巧
- **倍增思想**：利用操作的结合律，将 $K$ 次操作拆分为 $2$ 的幂次操作的组合，将时间复杂度从 $O(K)$ 优化到 $O(\log K)$。
- **找循环节**：发现每个位置的变换会形成循环，利用同余快速求出最终位置，时间复杂度为 $O(NM)$。

### 可拓展之处
同类型题或类似算法套路：
- 涉及多次重复操作且操作具有结合律的题目，如矩阵快速幂求解递推数列。
- 图中找环的问题，可使用深度优先搜索或拓扑排序等方法。

### 推荐题目
- P3083 [USACO13NOV]Cow Line S
- P1962 斐波那契数列（矩阵快速幂）
- P1306 斐波那契公约数（矩阵快速幂）

---
处理用时：40.67秒
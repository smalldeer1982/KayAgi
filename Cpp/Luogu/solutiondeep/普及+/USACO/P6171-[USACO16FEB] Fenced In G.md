# 题目信息

# [USACO16FEB] Fenced In G

## 题目背景

*本题和 [白金组同名题目](/problem/P3141) 在题意上一致，唯一的不同是数据范围。*

## 题目描述

Farmer John 意识到他的奶牛最近患上了一种恐惧症（害怕过于开阔的空间）。为了减少放牧的恐惧，FJ 决定在牧场中建一些水平和竖直方向的栅栏来将牧场分成若干个小区域。

整个牧场是一个矩形，两个角的坐标分别为 $(0,0)$ 和 $(A,B)$。FJ 在 $a_1,\ldots ,a_n$ 这 $n$ 个两两不同的位置建造了竖直方向的栅栏，每个栅栏从 $(a_i,0)$ 到 $(a_i,B)$；FJ 在 $b_1,\ldots ,b_m$ 这 $m$ 个两两不同的位置建造了水平方向的栅栏，每个栅栏从 $(0,b_i)$ 到 $(A,b_i)$。竖直方向的栅栏和水平方向的栅栏两两相交，将整个牧场分割成 $(n+1)(m+1)$ 个区域。

不幸的是，FJ 忘记了在栅栏上开门，奶牛都只能被困在一个个的小区域里！他想通过去掉一些栅栏来解决这个问题。他一次可以选择两个相邻的区域，将隔离这两个区域的栅栏去掉。FJ 的目标是让奶牛能够抵达牧场的任意一个地方。

这是一个例子：

```plain
+---+--+
|   |  |
+---+--+
|   |  |
|   |  |
+---+--+
```

去掉一些栅栏后的效果是这样的：

```plain
+---+--+
|      |
+---+  +
|      |
|      |
+---+--+
```

为了降低工程量，FJ 当然希望拆除的栅栏长度最短。

## 样例 #1

### 输入

```
15 15 5 2
2
5
10
6
4
11
3```

### 输出

```
44```

# AI分析结果

### 综合分析与结论
这些题解大多将问题抽象为最小生成树问题，把每个小矩形区域看成一个点，栅栏长度作为边权，目标是求最小生成树的边权和。部分题解采用 Kruskal 算法，通过排序边权并利用并查集判断连通性来求解；还有题解基于贪心思想，利用网格图边权特点优化算法。

### 所选题解
- **作者：Mu_tr (赞：5)  ★★★★**
  - **关键亮点**：思路清晰，详细说明了将问题抽象为最小生成树问题的过程，使用 Kruskal 算法并采用启发式合并和路径压缩优化并查集，代码注释详细。
  - **个人心得**：无

### 重点代码
```cpp
// 并查集查找函数
inline int find(int k){
    return k==f[k]?k:f[k]=find(f[k]);
}
// 计算点编号
inline int js(int x,int y){
    return x*(m+1)+y+1;
}
signed main(){ 
    a=read(),b=read(),n=read(),m=read();
    for(register int i=1;i<=n;i++) x[i]=read();
    for(register int i=1;i<=m;i++) y[i]=read();
    sort(x+1,x+1+n);sort(y+1,y+1+m);
    x[n+1]=a;y[m+1]=b;
    for(register int i=0;i<=n;i++){
        for(register int j=0;j<=m;j++){
            p=js(i,j);
            f[p]=p;rt[p]=1;
            if(j!=m) q[++cnt].ans=x[i+1]-x[i],q[cnt].w1=p,q[cnt].w2=p+1;
            if(i!=n) q[++cnt].ans=y[j+1]-y[j],q[cnt].w1=p,q[cnt].w2=p+m+1;
        }
    }
    sort(q+1,q+1+cnt,cmp);
    for(register int i=1;i<=cnt;i++){
        q1=find(q[i].w1),q2=find(q[i].w2);
        if(q1!=q2){
            rt[q1]>rt[q2]?(f[q2]=f[q1],rt[q1]+=rt[q2]):(f[q1]=f[q2],rt[q2]+=rt[q1]);
            ans1+=q[i].ans;
        }	
    }
    printf("%lld",ans1); 
    return 0;
}
```
**核心实现思想**：先读取输入并排序，计算相邻栅栏间的距离，构建边集。然后对边按边权排序，使用并查集判断边连接的两点是否连通，若不连通则合并并累加边权，最终得到最小生成树的边权和。

### 最优关键思路或技巧
- **问题抽象**：将实际问题抽象为最小生成树问题，通过点和边的模型来解决。
- **并查集优化**：采用启发式合并和路径压缩优化并查集，降低时间复杂度。
- **贪心策略**：部分题解利用网格图边权特点，采用贪心策略优化算法，减少不必要的计算。

### 可拓展之处
同类型题如网格图的最小生成树问题、图的连通性问题等。类似算法套路包括 Kruskal 算法、Prim 算法、并查集的使用等。

### 推荐题目
- [P3366 【模板】最小生成树](https://www.luogu.com.cn/problem/P3366)
- [P1195 口袋的天空](https://www.luogu.com.cn/problem/P1195)
- [P2872 [USACO07DEC]Building Roads S](https://www.luogu.com.cn/problem/P2872)

### 个人心得摘录与总结
- **tiko_tao**：提到本题一大难点是题意的理解，自己推了好久才看懂样例，之前一直以为给出的是栅栏长度，导致卡了很久。总结：做题目时要仔细理解题意，明确输入输出的含义。

---
处理用时：30.93秒
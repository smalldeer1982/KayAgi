# 题目信息

# [USACO07CHN] Summing Sums G

## 题目描述

$N$ 头奶牛（$1 \leq N \leq 5 \times 10^4$）刚刚学习了不少密码学知识，终于，她们创造出了属于奶牛的加密方法，由于她们经验不足，她们的加密方法很简单：

第 $i$ 头奶牛掌握着密码的第 $i$ 个数字，起始的时候是 $C_i$（$0 \leq C_i \lt 9 \times 10^7$）。加密的时候，第 $i$ 头奶牛会计算其他所有奶牛的数字和，并将这个和对 $98\,765\,431$ 取模。在所有奶牛计算完成后，每头奶牛都会用自己算的数字代替原来的数字。即，

$$
C_{i}'=(\sum_{k=1}^NC_k-C_i) \bmod 98\,765\,431
$$

这样，她们完成了一次加密。

在十一月，奶牛们把这个加密方法告诉了驼鹿卡门。卡门想了一会后，说：“你们的算法还很原始，为了达到加密效果，你们要重复这个加密过程 $T$ 次（$1 \leq T \leq 1\,414\,213\,562$）”。

奶牛们很懒，于是就把这个任务交给了你。

## 说明/提示

每次加密后的 $C_i$ 如下：

| 次数 | $C_1$ | $C_2$ | $C_3$ |
| ---- | ----- | ----- | ----- |
| 0    | 1     | 0     | 4     |
| 1    | 4     | 5     | 1     |
| 2    | 6     | 5     | 9     |
| 3    | 14    | 15    | 11    |
| 4    | 26    | 25    | 29    |

## 样例 #1

### 输入

```
3 4
1
0
4```

### 输出

```
26
25
29
```

# AI分析结果

### 综合分析与结论
这些题解主要围绕奶牛加密问题展开，核心在于找出加密操作的规律并高效计算经过 $T$ 次加密后的结果。不同题解采用了不同的方法，包括矩阵乘法、找规律结合快速幂和乘法逆元等。
- **矩阵乘法类**：通过构建矩阵和转移矩阵，利用矩阵快速幂计算最终结果。
- **找规律类**：通过分析操作过程，找出数字变化规律，结合快速幂和乘法逆元计算。

各题解的主要难点在于如何准确找出规律并处理取模运算，避免溢出。

### 所选题解
- **作者：Dehydration (赞：6)，4星**
  - **关键亮点**：思路清晰，利用矩阵乘法和快速幂解决问题，代码实现规范，有详细注释。
  - **个人心得**：强调不开 `long long` 会出错，还提到使用快读追求最优解。
- **作者：皮卡丘最萌 (赞：3)，4星**
  - **关键亮点**：通过找规律的方式，详细证明了偶数轮操作后每个数增大的值相同，思路独特，代码简洁。
- **作者：Argon_Cube (赞：0)，4星**
  - **关键亮点**：通过数学推导得出公式，结合快速幂和乘法逆元求解，逻辑严谨。

### 重点代码及核心实现思想
#### Dehydration 的题解
```cpp
struct matrix
{
    int x , y;
    lint num[3][3];
    matrix operator*(const matrix a) const
    {
        matrix t;
        int i , j , k;
        memset(t.num , 0 , sizeof(t.num));
        t.x = x , t.y = a.y;
        for(i = 1 ; i <= t.x ; i ++ )
            for(j = 1 ; j <= t.y ; j ++ )
                for(k = 1 ; k <= y ; k ++ )
                    t.num[i][j] = (t.num[i][j] + num[i][k] * a.num[k][j]) % MOD;
        return t;
    }
};
matrix qpow(matrix a , int b)
{
    matrix t;
    int i;
    t.x = a.x , t.y = a.y;
    memset(t.num , 0 , sizeof(t.num));
    for(i = 1 ; i <= t.x ; i ++ )
        t.num[i][i] = 1;
    while(b)
    {
        if(b & 1)
            t = t * a;
        a = a * a;
        b >>= 1;
    }
    return t;
}
```
**核心实现思想**：定义矩阵结构体，重载乘法运算符实现矩阵乘法，通过快速幂算法计算矩阵的幂。

#### 皮卡丘最萌的题解
```pascal
function kuai(m,p:int64):int64;
begin
if p=0 then exit(1);
if p=1 then exit(m);      //边界情况
kuai:=sqr(kuai(m,p>>1) mod md) mod md; 
if odd(p) then kuai:=kuai*m mod md;
end;                  //快速幂
```
**核心实现思想**：实现快速幂函数，通过递归和取模运算计算幂值。

#### Argon_Cube 的题解
```cpp
long long fast_pow(long long base,long long exp,long long moder)
{
    long long result;
    for(result=1;exp;exp&1?result=result*base%moder:true,base=base*base%moder,exp>>=1);
    return result;
}
inline long long inv(long long num,long long prime)
{
    return fast_pow(num,prime-2,prime);
}
```
**核心实现思想**：实现快速幂函数和求逆元函数，利用费马小定理求逆元。

### 最优关键思路或技巧
- **矩阵乘法**：将问题转化为矩阵运算，通过矩阵快速幂高效计算多次加密的结果。
- **找规律**：通过分析操作过程，找出数字变化的规律，如偶数轮操作后每个数增大的值相同，每轮操作后总和乘以 $n - 1$ 等。
- **快速幂和乘法逆元**：在取模运算中，利用快速幂计算幂值，利用乘法逆元处理除法取模问题。

### 可拓展之处
同类型题或类似算法套路包括其他涉及多次迭代操作的问题，如递推数列的计算、状态转移问题等。可以通过找规律、构建矩阵等方法，结合快速幂和乘法逆元进行求解。

### 推荐题目
- [P1962 斐波那契数列](https://www.luogu.com.cn/problem/P1962)：涉及矩阵快速幂计算斐波那契数列。
- [P3390 【模板】矩阵快速幂](https://www.luogu.com.cn/problem/P3390)：矩阵快速幂的模板题。
- [P5349 【XR-1】分块](https://www.luogu.com.cn/problem/P5349)：涉及快速幂和取模运算。

### 个人心得总结
- **Dehydration**：强调在处理大数运算时要使用 `long long`，避免溢出，还提到使用快读可以优化程序性能。
- **皮卡丘最萌**：通过观察样例找规律，然后进行证明，这种从特殊到一般的思维方式值得借鉴。

---
处理用时：37.93秒
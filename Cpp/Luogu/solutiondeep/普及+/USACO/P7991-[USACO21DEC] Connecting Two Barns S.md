# 题目信息

# [USACO21DEC] Connecting Two Barns S

## 题目描述

Farmer John 的农场由 $N$ 块田地（$1 \leq N \leq 10^5$）组成，编号为 $1 \ldots N$。在这些田地之间有 $M$ 条双向道路（$0 \leq M \leq 10^5$），每条道路连接两块田地。

农场有两个牛棚，一个在田地 1 中，另一个在田地 $N$ 中。Farmer John 希望确保有一种方式可以沿着一组道路在两个牛棚之间行走。 他愿意建造至多两条新道路来实现这一目标。由于田地的位置因素，在田地 $i$ 和 $j$ 之间建造新道路的花费是 $(i-j)^2$。

请帮助 Farmer John 求出使得牛棚 $1$ 和 $N$ 可以相互到达所需要的最小花费。

## 说明/提示

【样例解释】

- 第一个子测试用例中，最优的方式是用一条道路连接田地 2 和 3，用一条道路连接田地 3 和 4。
- 第二个子测试用例中，最优的方式是用一条道路连接田地 3 和 4。不需要第二条道路。

【数据范围】

- 测试点 2 满足 $N \le 20$。
- 测试点 3-5 满足 $N \le 10^3$。
- 测试点 6-10 没有额外限制。

## 样例 #1

### 输入

```
2
5 2
1 2
4 5
5 3
1 2
2 3
4 5```

### 输出

```
2
1
```

# AI分析结果

### 综合分析与结论
这些题解核心思路一致，均是先利用并查集确定连通分量，再分三种情况讨论：不连边（1 和 n 初始连通）、连一条边（连接 1 和 n 所在连通分量）、连两条边（借助第三个连通分量连接 1 和 n 所在连通分量）。为降低时间复杂度，多数题解采用二分查找来计算两点间最小代价。

### 所选题解
- 作者：望月Asta（5星）
    - 关键亮点：思路清晰，代码简洁规范，详细解释了状态转移方程和二分查找的使用，时间复杂度分析准确。
    - 核心代码：
```cpp
for(int i = 1;i <= n;++i) {
    int u = find(i);
    if(u!= r1) {
        int pre = std::upper_bound(F + 1,F + cntF + 1,i) - F - 1;
        f[u] = std::min(f[u],(ll)(i - F[pre]) * (i - F[pre]));
        if(pre < cntF) {
            ++pre;
            f[u] = std::min(f[u],(ll)(i - F[pre]) * (i - F[pre]));
        }
    }
    if(u!= rn) {
        int nxt = std::upper_bound(G + 1,G + cntG + 1,i) - G;
        g[u] = std::min(g[u],(ll)(i - G[nxt]) * (i - G[nxt]));
        if(nxt > 1) {
            --nxt;
            g[u] = std::min(g[u],(ll)(i - G[nxt]) * (i - G[nxt]));
        }
    }
}
```
    - 核心思想：通过二分查找找到与当前点差值最小的点，更新将当前点所在连通分量与 1 或 n 连接的最小代价。

- 作者：lyt_awa（4星）
    - 关键亮点：思路阐述清晰，代码有输入优化，对不同情况分类讨论明确。
    - 核心代码：
```cpp
for(int i = 1; i <= n; ++i) {
    int fi = find(i);
    if(fi!= rt1) {
        int ub1 = upper_bound(S + 1, S + ct1 + 1, i) - S - 1;
        s[fi] = min(s[fi], (ll)(i - S[ub1]) * (i - S[ub1]));
        if (ub1 < ct1) {
            ++ub1;
            s[fi] = min(s[fi], (ll)(i - S[ub1]) * (i - S[ub1]));
        }
    }
    if (fi!= rtn) {
        int ubn = upper_bound(E + 1, E + ctn + 1, i) - E;
        e[fi] = min(e[fi], (ll)(i - E[ubn]) * (i - E[ubn]));
        if(ubn > 1) {
            --ubn;
            e[fi] = min(e[fi], (ll)(i - E[ubn]) * (i - E[ubn]));
        }
    }
}
```
    - 核心思想：与望月Asta的题解类似，利用二分查找更新每个连通分量与 1 和 n 连接的最小代价。

### 最优关键思路或技巧
- **并查集**：用于快速判断两点是否连通，合并连通分量。
- **二分查找**：在有序数组中查找与当前点差值最小的点，将计算两点间最小代价的时间复杂度从 $O(n)$ 降低到 $O(\log n)$。
- **状态数组**：使用数组记录每个连通分量与 1 和 n 连接的最小代价，方便后续计算。

### 可拓展之处
同类型题可拓展到“添加有限条边使图连通并求最小代价”，类似算法套路可用于解决“最小生成树变种问题”，如给定一些边，可添加有限条边使图连通，求最小总边权。

### 推荐题目
- P1195 口袋的天空：求添加若干条边使图形成 k 个连通块的最小代价。
- P2330 [SCOI2005]繁忙的都市：求添加若干条边使图连通且最大边权最小。
- P1991 无线通讯网：求添加若干条边使图连通且最大边权不超过给定值的最小代价。

### 个人心得
题解中未包含个人心得相关内容。 

---
处理用时：28.77秒
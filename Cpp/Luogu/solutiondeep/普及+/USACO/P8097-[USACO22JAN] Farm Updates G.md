# 题目信息

# [USACO22JAN] Farm Updates G

## 题目描述

Farmer John 经营着总共 $N$ 个农场（$1\le N\le 10^5$），编号为 $1\ldots N$。最初，这些农场之间没有道路连接，并且每个农场都在活跃地生产牛奶。

由于经济的动态性，Farmer John 需要根据 $Q$ 次更新操作（$0\le Q\le 2\cdot 10^5$）对他的农场进行改造。更新操作有三种可能的形式：

- `(D x)` 停用一个活跃的农场 $x$，使其不再生产牛奶。

- `(A x y)` 在两个活跃的农场 $x$ 和 $y$ 之间添加一条道路。

- `(R e)` 删除之前添加的第 $e$ 条道路（$e = 1$ 是添加的第一条道路）。

一个农场 $x$ 如果正在活跃地生产牛奶，或者可以通过一系列道路到达另一个活跃的农场，则称之为一个「有关的」农场。对于每个农场 $x$，计算最大的 $i$（$0\le i\le Q$），使得农场 $x$ 在第 $i$ 次更新后是有关的。

## 说明/提示

【样例解释】

在这个例子中，道路以顺序 $(2,3), (1,2), (2,4)$ 被删除。

- 农场 $1$ 在道路 $(1,2)$ 被删除之前是有关的。

- 农场 $2$ 在道路 $(2,4)$ 被删除之前是有关的。

- 农场 $3$ 在道路 $(2,3)$ 被删除之前是有关的。

- 农场 $4$ 和 $5$ 在所有更新结束后仍然是活跃的。所以它们一直保持为有关的，两者的输出均应为 $Q$。

【数据范围】

- 测试点 2-5 满足 $N\le 10^3$，$Q\le 2\cdot 10^3$。

- 测试点 6-20 没有额外限制。


## 样例 #1

### 输入

```
5 9
A 1 2
A 2 3
D 1
D 3
A 2 4
D 2
R 2
R 1
R 3```

### 输出

```
7
8
6
9
9```

# AI分析结果

### 综合分析与结论
这些题解主要围绕农场更新问题展开，核心是处理图的点和边的操作，并计算每个点最后一次有关的操作编号。多数题解采用倒序处理的思路，将复杂的删点、删边操作转化为加点、加边操作，降低问题难度。各题解在具体实现上有所不同，使用了 BFS、DFS、并查集、线段树分治等算法和数据结构。

### 所选题解
- 作者：zhiyangfan (赞：11)，4星
  - 关键亮点：思路清晰，通过倒序操作将问题转化为单点修改和加边，利用并查集高效解决，时间复杂度为均摊的 $\mathcal{O}(n + q)$。
- 作者：耶梦加得 (赞：5)，4星
  - 关键亮点：同样采用倒序操作，结合 DFS 遍历连通块，利用 `vis` 数组避免重复遍历，复杂度为 $O(N + Q)$，代码简洁易懂。
- 作者：Purslane (赞：2)，4星
  - 关键亮点：巧妙地将加边操作移到最开始进行，通过 DFS 标记答案，复杂度为 $\text{O}(n + q)$，实现简单。

### 重点代码及核心实现思想
#### 作者：zhiyangfan
```cpp
// 并查集找根节点
int getf(int x) { return x == f[x] ? x : f[x] = getf(f[x]); }
// 合并两个连通块
inline void link(int u, int v, int now)
{
    u = getf(u), v = getf(v); if (u == v) return ;
    if ((!vis[u]) ^ (!vis[v]))
    {
        if (!vis[u]) for (auto x : vec[u]) vis[x] = now;
        else for (auto x : vec[v]) vis[x] = now;
    }
    if (vec[u].size() > vec[v].size()) { f[v] = u; for (auto x : vec[v]) vec[u].push_back(x); }
    else { f[u] = v; for (auto x : vec[u]) vec[v].push_back(x); }
}
```
核心思想：倒序处理操作，将点的权值从 $0$ 变为 $1$ 时更新连通块内点的关联时间，加边时合并连通块并更新关联时间。

#### 作者：耶梦加得
```cpp
// DFS 遍历连通块
void dfs(int x, int t) { 
    vis[x] = 1; if(!ans[x]) ans[x] = t; 
    for(int i = 0; i < g[x].size(); ++i) {
        int to = g[x][i];
        if(vis[to]) continue;
        act[to] |= act[x];
        dfs(to, t);
    }
}
```
核心思想：先正着记录边和点的状态，遍历图找出活跃点，再倒序操作，遇到 Delete 或 Remove 操作时进行 DFS 遍历更新答案。

#### 作者：Purslane
```cpp
// DFS 标记答案
void dfs(int u, int val) {
    if(ans[u]) return ; ans[u]=val;
    for(auto to:G[u]) dfs(to, val);
    return ;
}
```
核心思想：将加边操作移到最开始，倒序操作时，遇到删点变成加点，删边变成加边，通过 DFS 标记答案。

### 最优关键思路或技巧
- **倒序操作**：将删点、删边操作转化为加点、加边操作，利用数据结构支持合并的特性简化问题。
- **并查集的使用**：高效处理连通块的合并和查询，通过启发式合并降低时间复杂度。
- **利用题目条件**：加边操作只在活跃农场之间进行，可忽略加边对答案的影响，减少不必要的处理。

### 可拓展之处
同类型题如涉及图的动态操作（点的增减、边的增减），可考虑倒序处理，利用并查集、DFS、BFS 等算法解决。类似算法套路包括线段树分治、整体二分等，可用于处理更复杂的动态问题。

### 推荐题目
- [P1197 [JSOI2008]星球大战](https://www.luogu.com.cn/problem/P1197)：涉及图的点删除和连通性问题。
- [P3958 [NOIP2017 提高组] 奶酪](https://www.luogu.com.cn/problem/P3958)：利用并查集判断连通性。
- [P1525 [NOIP2010 提高组] 关押罪犯](https://www.luogu.com.cn/problem/P1525)：并查集的拓展应用，处理矛盾关系。

### 个人心得摘录与总结
- 作者：清小秋ovo：提到没想到 BFS 能过且跑得挺快，说明在比赛时可以尝试简单暴力的方法。
- 作者：耶梦加得：表示没看到加边只在活跃农场之间的限制而保龄，提醒我们要仔细读题，注意题目条件。

---
处理用时：39.02秒
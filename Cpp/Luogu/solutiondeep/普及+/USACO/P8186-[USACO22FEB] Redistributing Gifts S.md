# 题目信息

# [USACO22FEB] Redistributing Gifts S

## 题目描述

FJ 有 $N$ 个礼物给他的 $N$ 头奶牛，这 $N$ 个礼物和 $N$ 头奶牛都被标记为 $1 \dotsm N (1 \le N \le 500)$ 。 每头奶牛都有一个愿望单，记录着一个含有 $N$ 个礼物的排列。比起在愿望单中出现更晚的礼物，奶牛更喜欢先出现在愿望单中的礼物。

因为 FJ 太懒了，他直接把 $i$ 号礼物分配给了 $i$ 号奶牛。现在，奶牛们聚在了一起，决定重新分配礼物，以便在重新分配后，每头奶牛都能得到跟原来一样，或是它更喜欢的礼物。

对于每个 $i$ （$i$ 从 $1$ 到 $N$），计算出重新分配后， $i$ 号奶牛可能拿到的最好的礼物（这个奶牛经过重新分配后能拿到的最喜欢的礼物）。

## 说明/提示

- $2 \sim 3$ 号测试点满足 $N \le 8$
- $4 \sim 11$ 号测试点没有别的限制

由 [tzyt](https://www.luogu.com.cn/user/394488) 翻译

## 样例 #1

### 输入

```
4
1 2 3 4
1 3 2 4
1 2 3 4
1 2 3 4```

### 输出

```
1
3
2
4
```

# AI分析结果

### 综合分析与结论
这些题解主要围绕奶牛重新分配礼物的问题展开，核心是找到每头奶牛可能拿到的最好礼物。大部分题解采用建图的方式，将奶牛和礼物的关系抽象为图的边，再通过不同算法判断环或连通性来确定可行的分配方案。主要算法包括 DFS、Floyd 传递闭包、Tarjan 算法、匈牙利算法、BFS 等。

### 所选题解
- **Jorge_Filho（5星）**
    - **关键亮点**：思路清晰，先明确枚举每头奶牛可能拿到的最好礼物，再通过建图和 DFS 判断是否能形成环来确定可行性，代码结构清晰，有详细注释。
    - **核心实现思想**：先记录每头奶牛初始礼物在其愿望单中的位置，然后将每头奶牛与愿望单中位置在初始礼物之前的礼物连边，最后通过 DFS 判断从初始礼物出发能否经过某个枚举的礼物形成环。
```cpp
// 加边函数
void Add(const int &x, const int &y) {
    e[idx]=y;
    ne[idx]=h[x];
    h[x]=idx++;
}

// 深搜实现任意两点间能否到达从而判断环
void Dfs(const int &x) {
    for(int i=h[x]; ~i; i=ne[i]) {
        int cur=e[i];
        if(bjt[st][cur]) continue;
        bjt[st][cur]=1;
        Dfs(cur);
    }
}
```
- **xixike（4星）**
    - **关键亮点**：利用传递闭包和 `bitset` 优化，时间复杂度为 $O(\frac {n^3}{\omega})$，代码简洁高效。
    - **核心实现思想**：将奶牛和礼物看作点，若奶牛 $i$ 认为奶牛 $j$ 的礼物更好，则 $i$ 向 $j$ 连边，然后通过传递闭包计算任意两点间的可达性，最后找到每头奶牛能到达且能返回的最好礼物。
```cpp
// 传递闭包计算
for (short j = 1; j <= n; ++ j) {
    for (short i = 1; i <= n; ++ i) {
        if (f[i][j]) 
            f[i] |= f[j];
    }
}
```
- **5ab_juruo（4星）**
    - **关键亮点**：提出了 $O(n^2)$ 的 Tarjan 算法解法，通过建立特殊的图结构并跑 Tarjan 算法找到强连通分量，思路独特且高效。
    - **核心实现思想**：每个奶牛的每一偏好都是一个节点，按规则连边后跑 Tarjan 算法，对于每头奶牛，从第一偏好开始枚举，第一个在大小超过 1 的 SCC 中的偏好就是能拥有的最好礼物。
```cpp
// Tarjan 算法
void tarjan(int id) {
    dfn[id] = low[id] = ind++;
    stk[stp++] = id, inst[id] = true;
    
    for (int p = hd[id]; p != -1; p = nxt[p]) {
        if (dfn[des[p]] == -1) {
            tarjan(des[p]);
            chmin(low[id], low[des[p]]);
        }
        else if (inst[des[p]])
            chmin(low[id], dfn[des[p]]);
    }
    
    if (low[id] == dfn[id]) {
        int tmp, lst = stp;
        do {
            tmp = stk[--stp];
            inst[tmp] = false;
            bel[tmp] = s_cnt;
        } while (tmp != id);
        siz[s_cnt++] = lst - stp;
    }
}
```

### 最优关键思路或技巧
- **建图思想**：将奶牛和礼物的关系抽象为图的边，通过图的连通性和环的判断来解决问题。
- **传递闭包优化**：使用 Floyd 传递闭包或 `bitset` 优化，快速计算任意两点间的可达性。
- **Tarjan 算法**：通过 Tarjan 算法找到强连通分量，判断是否存在可行的交换环。

### 可拓展之处
同类型题或类似算法套路：
- 涉及资源分配和交换的问题，如任务分配、座位调整等，可通过建图和图算法解决。
- 图的连通性和环的判断问题，可使用 DFS、Floyd、Tarjan 等算法。

### 推荐题目
- [P1119 灾后重建](https://www.luogu.com.cn/problem/P1119)：涉及 Floyd 算法的应用。
- [P2341 [USACO03FALL][HAOI2006] 受欢迎的牛 G](https://www.luogu.com.cn/problem/P2341)：考察 Tarjan 算法求强连通分量。
- [P3386 【模板】二分图最大匹配](https://www.luogu.com.cn/problem/P3386)：可练习匈牙利算法。

### 个人心得
- **ZBAA_MKC**：提到这题思维难度较大，一开始按两两换的思路做不行，后来突然想到用 Floyd 来做，说明遇到复杂问题时要多尝试不同思路。 

---
处理用时：38.37秒
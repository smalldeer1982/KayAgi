# 题目信息

# [USACO22OPEN] Photoshoot B

## 题目描述

迫切希望在郡县集市上赢得最佳奶牛摄影师的 Farmer John 正在尝试为他的 $N$ 头奶牛拍摄一张完美的照片（$2 \leq N \leq 2\cdot 10^5$，$N$ 为偶数）。

Farmer John 拥有两种品种的奶牛：更赛牛（Guernsey）和荷斯坦牛（Holstein）。为了使他的照片尽可能地艺术，他想把他的奶牛排成一排，使得尽可能多的更赛牛处于队列中的偶数位置（队列中的第一个位置是奇数位置，下一个是偶数位置，以此类推）。由于他与他的奶牛缺乏有效的沟通，他可以达到目的的唯一方法是让他的奶牛的偶数长的「前缀」进行反转（一个前缀指的是对于某个位置 $j$，从第一头奶牛到第 $j$ 头奶牛范围内的所有奶牛）。

请计算 Farmer John 达到目的所需要的最小反转次数。


## 说明/提示

【样例解释】

在这个例子中，只需反转由前六头奶牛组成的前缀即可。
```
   GGGHGHHGHHHGHG （反转前）
-> HGHGGGHGHHHGHG （反转后）
```
在反转之前，四头更赛牛处于偶数位置。反转后，六头更赛牛处于偶数位置。不可能使得超过六头更赛牛处于偶数位置。

【测试点性质】

- 测试点 2-6 满足 $N\le 1000$。
- 测试点 7-11 没有额外限制。

## 样例 #1

### 输入

```
14
GGGHGHHGHHHGHG```

### 输出

```
1```

# AI分析结果

### 综合分析与结论
这些题解的核心思路都是将相邻的两个字符看作一组，根据字符组合的不同情况（如“GG”“GH”“HG”“HH”）进行分类处理，将问题转化为对 01 串的操作，通过分析 01 串的特征来计算最小反转次数。各题解在具体实现和细节处理上有所差异，但整体思路相似。

### 所选题解
- **作者：yzyjh (赞：12)，4星**
  - **关键亮点**：思路清晰，代码简洁易懂，详细解释了如何将问题转化为 01 串并进行处理。
  - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
char s[200005];
int n;
vector<int>p;
int main()
{
    int i,j;
    cin>>n;
    cin>>(s+1);
    for(i=1;i<=n;i+=2)
        if(s[i]!=s[i+1])//两两一组
            if(s[i]=='G'&&s[i+1]=='H')
                p.push_back(1);
            else
                p.push_back(0);
    int cnt=0;
    for(i=1;i<p.size();i++)//遍历动态数组
        if(p[i-1]!=p[i])
            cnt++;
    if(p.size()==0)cout<<cnt<<endl;
    else cout<<cnt+p[p.size()-1]<<endl;//如果最后一个是1，那答案要加1
    return 0;	
}
```
  - **核心实现思想**：先将输入的字符两两一组，若字符不同，“GH”记为 1，“HG”记为 0，得到 01 串。然后遍历 01 串，相邻数字不同则反转次数加 1，最后若末尾数字为 1，答案再加 1。

- **作者：Zero_s (赞：2)，4星**
  - **关键亮点**：在常规思路基础上进行了空间优化，利用滚动思想减少空间使用，同时详细说明了优化过程中头尾计算问题的解决方法。
  - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
string s;
int n,ans,i,f1,f2;//f1和f2相互滚动可以大幅度节省空间。
int main()
{
    scanf("%d",&n);
    cin>>s;
    while(s[i]==s[i+1]) i+=2;//过滤掉“GG”和“HH”的情况。
    if(s[i]=='G'&&s[i+1]=='H') f1=1;//初次计算f1。
    for(i+=2;i<n;i+=2)//记得是i+=2，因为是两两为一组。
    if(s[i]!=s[i+1])//s[i]==s[i+1]（即“GG”和“HH”的情况）就没有必要算了。
    {
        f2=s[i]=='G'&&s[i+1]=='H'? 1:0;//“GH”情况等于1，“HG”情况等于0.
        if(f1!=f2) ans++;//不相等就翻转。
        //printf("%d,%d",i,ans);
        f1=f2;//滚动。
    }
    printf("%d",ans+f2);//如果最后一项是1就加上。
    return 0;
}
```
  - **核心实现思想**：先过滤掉开头的“GG”和“HH”组合，初始化 f1。然后两两一组遍历字符串，计算 f2，若 f1 与 f2 不同则反转次数加 1，更新 f1。最后根据 f2 的值确定是否需要额外加 1。

### 最优关键思路或技巧
- **分组思想**：将相邻的两个字符看作一组，简化问题，将原问题转化为对 01 串的操作。
- **滚动数组优化**：在处理 01 串时，使用滚动数组（如 f1 和 f2）代替动态数组，减少空间复杂度。

### 可拓展之处
同类型题或类似算法套路：这类问题通常涉及字符串操作和贪心策略，可拓展到其他字符串翻转、字符位置调整的问题，通过合理分组和状态定义，将复杂问题简化为简单的数组或序列操作。

### 推荐题目
- [P2708 硬币翻转](https://www.luogu.com.cn/problem/P2708)：与本题类似，涉及对序列的翻转操作，通过贪心策略求解最小操作次数。
- [P1217 [USACO1.5]回文质数 Prime Palindromes](https://www.luogu.com.cn/problem/P1217)：需要对数字进行各种判断和处理，可锻炼字符串处理和逻辑思维能力。
- [P1059 [NOIP2006 普及组] 明明的随机数](https://www.luogu.com.cn/problem/P1059)：涉及对数组的处理和去重，可提升对数组操作的熟练度。

### 个人心得摘录与总结
- **Zero_s**：提到原写法浪费空间，有强迫症所以想要优化空间，通过将两个循环连接起来，利用滚动思想优化空间，同时解决了头和尾的计算问题。总结：在解决问题时，不仅要关注问题的解决，还可以思考如何优化代码，提高性能。 

---
处理用时：37.08秒
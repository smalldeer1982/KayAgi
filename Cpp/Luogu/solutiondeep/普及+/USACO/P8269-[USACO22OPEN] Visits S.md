# 题目信息

# [USACO22OPEN] Visits S

## 题目描述

Bessie 的 $N$（$2\le N\le 10^5$）个奶牛伙伴（编号为 $1\cdots N$）每一个都拥有自己的农场。对于每个 $1\le i\le N$，伙伴 i 想要访问伙伴 $a_i$（$a_i\neq i$）。

给定 $1\ldots N$ 的一个排列 $(p_1,p_2,\ldots, p_N)$，访问按以下方式发生。

对于 $1$ 到 $N$ 的每一个 $i$：

- 如果伙伴 $a_{p_i}$ 已经离开了她的农场，则伙伴 $p_i$ 仍然留在她的农场。
- 否则，伙伴 $p_i$ 离开她的农场去访问伙伴 $a_{p_i}$ 的农场。这次访问会产生快乐的哞叫 $v_{p_i}$ 次（$0\le v_{p_i}\le 10^9$）。


对于所有可能的排列 $p$，计算所有访问结束后可能得到的最大哞叫次数。

## 说明/提示

【样例解释】


如果 $p=(1,4,3,2)$，则

- 伙伴 $1$ 访问伙伴 $2$ 的农场，产生 $10$ 次哞叫。
- 伙伴 $4$ 看到伙伴 $1$ 已经离开了农场，所以无事发生。
- 伙伴 $3$ 访问伙伴 $4$ 的农场，又产生 $30$ 次哞叫。
- 伙伴 $2$ 看到伙伴 $3$ 已经离开了农场，所以无事发生。

这样总计得到了 $10+30=40$ 次哞叫。

另一方面，如果 $p=(2,3,4,1)$，则

- 伙伴 $2$ 访问伙伴 $3$ 的农场，产生 $20$ 次哞叫。
- 伙伴 $3$ 访问伙伴 $4$ 的农场，产生 $30$ 次哞叫。
- 伙伴 $4$ 访问伙伴 $1$ 的农场，产生 $40$ 次哞叫。
- 伙伴 $1$ 看到伙伴 $2$ 已经离开了农场，所以无事发生。

这样总计得到了 $20+30+40=90$ 次哞叫。可以证明这是所有可能的排列 $p$ 中访问结束后得到的最大可能的哞叫次数。

## 样例 #1

### 输入

```
4
2 10
3 20
4 30
1 40```

### 输出

```
90```

# AI分析结果

### 综合分析与结论
这些题解的核心思路都是将问题转化为图论问题，由于每个节点出度为 1，图为基环树森林。解题关键在于处理环和非环节点，非环节点的贡献可全部获取，而每个环中需去掉一个贡献最小的节点以达到最大总贡献。各题解在实现方式上有所不同，主要有拓扑排序、dfs、Tarjan 算法、Kruskal 算法等。

### 所选题解
- **作者：YBaggio（4星）**
  - **关键亮点**：思路清晰，先通过拓扑排序找出非环节点并累加其贡献，再用 dfs 找出环并去掉环中贡献最小的节点，代码实现简洁易懂。
  - **核心代码**：
```cpp
void topo(){
    for(int i=1;i<=n;i++){
        if(!rd[i])q.push(i);
    }
    while(!q.empty()){
        int x=q.front();q.pop();
        ans+=v[x];rd[a[x]]--;
        vis[x]=1;
        if(!rd[a[x]])q.push(a[x]);
    }
    return;
}
void dfs(int x){
    vis[x]=1;
    minn=min(minn,v[x]);
    if(vis[a[x]])return;
    dfs(a[x]);
    return;
}
```
  - **实现思想**：`topo` 函数通过拓扑排序找出入度为 0 的节点，将其贡献累加到答案中，并更新其后续节点的入度。`dfs` 函数用于找出环，在环中找出贡献最小的节点。

- **作者：enucai（4星）**
  - **关键亮点**：准确判断出图为基环树森林，详细阐述了非环节点和环上节点的处理方法，时间复杂度为 $O(n)$，代码简洁。
  - **核心代码**：
```cpp
void dfs(int u){
    vis[u]=1;
    for(int v:e[u]) if(!vis[v]) dfs(v);
}
```
  - **实现思想**：`dfs` 函数用于标记连通分量中的节点，辅助找出环。

- **作者：Sparkle_ZH（4星）**
  - **关键亮点**：通过图文结合的方式详细分析了特殊情况和非特殊情况，将点分为环上和非环上两类分别处理，思路清晰。
  - **核心代码**：
```cpp
void get_point(int x) { 
    vis[x] = true, vec.push_back(x);
    for (int i = 0; i < son[x].size(); i++)
        if (!vis[son[x][i]]) get_point(son[x][i]);
    if (!vis[a[x]]) get_point(a[x]);
}
void get_circle(int x) { 
    f[x]++;
    if (f[x] == 2) minn = min(minn, v[x]);
    if (f[a[x]] != 2) get_circle(a[x]);
}
```
  - **实现思想**：`get_point` 函数用于获取连通分量中的所有节点，`get_circle` 函数用于找出环并更新环中节点的最小贡献。

### 最优关键思路或技巧
- **图的建模**：将奶牛访问问题转化为有向图，利用图论知识解决问题。
- **基环树森林的特性**：根据每个节点出度为 1 的特点，判断图为基环树森林，进而分别处理环和非环节点。
- **贪心策略**：在每个环中选择贡献最小的节点去掉，以保证总贡献最大。

### 可拓展之处
同类型题或类似算法套路：
- 涉及基环树的其他问题，如基环树的直径、基环树的最长路径等。
- 图的拓扑排序、Tarjan 算法、Kruskal 算法的其他应用场景。

### 推荐题目
- P1330 封锁阳光大学（图的染色问题，与图的连通性和拓扑结构有关）
- P2860 [USACO06JAN] Redundant Paths G（求无向图的边双连通分量，涉及图的连通性和割边）
- P3387 【模板】缩点（Tarjan 算法求强连通分量，与本题中找环的思路类似）

### 个人心得摘录与总结
- **作者：junxis**：吐槽题目难度大，称被题目吊打四个小时，通过分析样例得出结论，强调样例在解题中的重要性。
- **总结**：在遇到难题时，可通过分析样例寻找解题思路，样例能帮助我们更好地理解问题和发现规律。 

---
处理用时：34.03秒
# 题目信息

# [USACO22OPEN] COW Operations S

## 题目描述

Bessie 找到了一个长度不超过 $2 \cdot 10^5$ 且仅包含字符 'C'，'O' 和 'W' 的字符串 $s$。她想知道是否可以使用以下操作将该字符串变为单个字母 'C'（她最喜欢的字母）：

1. 选择两个相邻相等的字母并将其删除。

2. 选择一个字母，将其替换为另外两个字母的任一排列。

求出这个字符串本身的答案对 Bessie 而言并不足够，所以她想要知道 $s$ 的 $Q$（$1\le Q\le 2\cdot 10^5$）个子串的答案。


## 说明/提示

【样例解释】

第一个询问的答案是「是」，因为 s 的第一个字符已经等于 'C'。

第五个询问的答案是「是」，因为 s 的第二到第三个字符组成的子串 OW 可以通过两步操作变为 'C'：

```
   OW
-> CWW
-> C
```

这个样例字符串 COW 的其他子串均不能被转变为 'C'。

【测试点性质】

- 测试点 2-4 满足 $|s|\le 5000$ 以及 $Q\le 5000$。
- 测试点 5-11 没有额外限制。

## 样例 #1

### 输入

```
COW
6
1 1
1 2
1 3
2 2
2 3
3 3```

### 输出

```
YNNNYN```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何判断给定字符串的子串能否通过特定操作变为单个字符 'C' 展开。大部分题解通过挖掘操作的性质，如字符的可交换性、操作的可逆性等，来简化问题。常见的做法是利用前缀和统计字符信息，再根据字符个数的奇偶性或定义的特殊运算来判断结果。部分题解采用了倍增、异或等特殊方法，虽然思路独特，但复杂度或实现难度有所不同。

### 所选题解
- **作者：ppip (赞：16)，4星**
  - **关键亮点**：思路清晰，先通过枚举得出字符变换的性质，然后利用这些性质将问题简化，最后用前缀和处理询问，代码简洁易懂。
  - **核心实现思想**：用前缀和统计字符个数，对于每个询问，统计区间内三个字符个数除以 2 的余数，根据预先总结的表格判断能否变为 'C'。
  - **核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN(2e5+5);
int sum[MAXN][3];
int c['~'];
int main()
{
    c['C']=0;c['O']=1;c['W']=2;
    string s;cin>>s;
    for (int i{1};i<=s.size();++i)
    {
        for (int j{0};j<3;++j) sum[i][j]+=sum[i-1][j];
        ++sum[i][c[s[i-1]]];
    }
    int T;cin>>T;
    while (T--)
    {
        int l,r;scanf("%d %d",&l,&r);
        int z[3];
        for (int i{0};i<3;++i)
            z[i]=sum[r][i]-sum[l-1][i]&1;
        printf("%c",!(z[1]^z[2])&&(z[0]^z[1])?'Y':'N');
    }
    return 0;
}
```
- **作者：lihanwen12 (赞：10)，4星**
  - **关键亮点**：通过对字符操作的具体分析，得出字符转换的规律，利用前缀和快速统计区间字符个数，根据奇偶性判断结果，思路直接明了。
  - **核心实现思想**：预处理前缀和，对于每个询问，统计区间内 'C'、'O'、'W' 出现的个数，根据 'O' 和 'W' 的奇偶性判断能否转换为 'C'。
  - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
string st;
long long n,Q,l,r,A,B,C,nc[200010],no[200010],nw[200010];
bool p;
int main(){
    cin>>st>>Q;
    n=st.size();
    for(int i=0;i<n;i++){
        nc[i+1]=nc[i];
        no[i+1]=no[i];
        nw[i+1]=nw[i];
        if(st[i]=='C')nc[i+1]++;
        if(st[i]=='O')no[i+1]++;
        if(st[i]=='W')nw[i+1]++;
    }
    for(int i=1;i<=Q;i++){
        cin>>l>>r;
        A=(nc[r]-nc[l-1])%2;
        B=(no[r]-no[l-1])%2;
        C=(nw[r]-nw[l-1])%2;
        if(A==1 && B==0 && C==0){
            cout<<"Y";
            continue;
        }
        if(A==0 && B==1 && C==1){
            cout<<"Y";
            continue;
        }
        cout<<"N";
    }
    return 0;
}
```
- **作者：wangyibo201026 (赞：8)，4星**
  - **关键亮点**：定义了一种特殊运算 $\bigotimes$，并发现其满足交换律、逆元、结合律，进一步得出该运算实际上是异或运算，通过前缀异或数组快速处理询问。
  - **核心实现思想**：将字符编号，用异或运算模拟字符操作，预处理前缀异或数组，对于每个询问，通过异或操作得到最终结果，判断是否为 'C'。
  - **核心代码**：
```cpp
#include<bits/stdc++.h>
#define int long long   //防爆
using namespace std;
const int N = 2e5 + 5;
string s;
int sum[N];
int q;
void Solve(){
    cin >> s;
    s = " " + s;
    sum[1] = (s[1] == 'C' ? 1 : (s[1] == 'O' ? 2 : 3));
    for(int i = 2; i < s.size(); i++){
        sum[i] = (sum[i - 1] ^ (s[i] == 'C' ? 1 : (s[i] == 'O' ? 2 : 3)));
    }    //初始化前缀异或数组
    cin >> q;
    while(q--){
        int l, r;
        cin >> l >> r;
        cout << ((sum[l - 1] ^ sum[r]) == 1 ? 'Y' : 'N');   //这里只需要异或就可以得到最终结果
    }
}
signed main(){
    Solve();
    return 0;
}
```

### 最优关键思路或技巧
- **挖掘操作性质**：通过枚举和分析操作，得出字符的可交换性、操作的可逆性等性质，简化问题。
- **前缀和优化**：利用前缀和快速统计区间内字符的信息，将每次询问的复杂度从 $O(|s|)$ 降低到 $O(1)$。
- **异或运算**：发现字符操作与异或运算的相似性，利用异或的性质（交换律、结合律）快速处理询问。

### 可拓展之处
同类型题可能会改变操作规则或字符种类，解题思路可以借鉴本题，先分析操作的性质，找出不变量（如奇偶性），再利用合适的数据结构（如前缀和、异或数组）进行优化。类似算法套路包括分析问题的对称性、可逆性，寻找问题的等价形式等。

### 推荐题目
- P1115 最大子段和：考察前缀和与动态规划思想。
- P1719 最大加权矩形：需要利用二维前缀和处理区间和问题。
- P2004 领地选择：同样涉及二维前缀和的应用。

### 个人心得摘录与总结
- **作者：XGTD**：通过玩数据发现字符操作的性质，如任意两个不同字母可变成第三个字母，操作顺序不影响结果等。虽然想到了倍增的方法，但意识到该方法比正解慢，不过认为倍增思路比较自然。总结：在解题时可以通过玩数据找规律，同时要注意不同算法的复杂度和实现难度。 

---
处理用时：49.42秒
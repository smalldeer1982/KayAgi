# 题目信息

# [USACO23JAN] Find and Replace S

## 题目描述

Bessie 正在使用世界上最先进最伟大的文本编辑器：miV！她想将一个仅由大写和小写英文字母组成的字符串转换为一个新的字符串。每一次操作，miV 可以将字符串中所有的字母  $c_1$ 替换成另一种字母 $c_2$。例：对于字符串`aAbBa`, 如果将其中的 `a` 替换成 `B`, 那么字符串会变为`BAbBB`。

Bessie 非常地忙碌, 所以对于给出的 $T
(1 \le T \le 10)$ 组测试数据, 请输出她至少需要多少次操作才能把原字符串转换为新字符串。

## 说明/提示

- 对于 $ 40 \% $ 的数据，字符串的长度不超过 $50$。
 - 对于另外 $ 20\% $ 的数据，所有的字符串仅包含从 `a` 到 `e` 的小写字母。
 - 对于 $ 100\% $ 的数据，字符串的长度不超过 $10^5$，$1 \le T \le 10$。

## 样例 #1

### 输入

```
4
abc
abc
BBC
ABC
abc
bbc
ABCD
BACD```

### 输出

```
0
-1
1
3```

# AI分析结果

### 综合分析与结论
这些题解大多将字符替换问题转化为图论问题，通过建图来分析字符间的转换关系。思路上，先判断无解情况，如一个字符要变成多个不同字符、所有字符都在目标串出现且两串不同；再对有解情况分类讨论，根据图的结构（链、环、基环树等）计算操作次数。算法实现上，主要运用拓扑排序和 DFS 来处理图，找出环和连通块。

### 所选题解
- **作者：泥土笨笨 (赞：26)，4星**
    - **关键亮点**：思路清晰，详细分析了各种无解情况和图的分类，对纯环的处理解释透彻；代码注释丰富，可读性高。
    - **个人心得**：提到题目细节多，比赛时出错多，还给出了其他题解的 hack 数据，帮助读者避免错误。

### 重点代码
```cpp
// 从入度为0的点出发，把能到的点都标记vis
void topo() {
    queue<int> q;
    for (int i = 'A'; i <= 'Z'; ++i) {
        if (in[i] == 0) {
            q.push(i);
        }
    }
    for (int i = 'a'; i <= 'z'; ++i) {
        if (in[i] == 0) {
            q.push(i);
        }
    }
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        vis[u] = 1;
        int v = to[u];
        if (vis[v] == 0) {
            in[v] = 0;//只要能从不在环上的点走过来，强制进队
            q.push(v);
        }
    }
}

// 把从u出发同一个环上的点都标记一遍
void dfs(int u) {
    vis[u] = 1;
    int v = to[u];
    if (vis[v] == 0) dfs(v);
}

int main() {
    cin >> T;
    while (T--) {
        // 省略初始化部分
        // 第一种无解的情况，一个字符要变成两种以上不同字符，肯定不行
        int good = 1;
        for (int i = 0; i < n; ++i) {
            if (to[s[i]] == 0 || to[s[i]] == t[i]) {
                to[s[i]] = t[i];
            } else {
                good = 0;
            }
            b.insert(t[i]);
        }
        if (!good) {
            cout << -1 << endl;
            continue;
        }
        // 第二种无解的情况，如果所有字母都在t中出现过，那么s和t必须相等才行。
        if (b.size() == 52) {
            if (strcmp(s, t) == 0) {
                cout << 0 << endl;
            } else {
                cout << -1 << endl;
            }
            continue;
        }
        // 把每个原始字母向结果字母连边，建一张有向图，自环不管
        memset(to, 0, sizeof to);
        int ans = 0;//统计边的条数，其实就是需要的变化的数量
        for (int i = 0; i < n; ++i) {
            if (to[s[i]] == 0 && s[i] != t[i]) {
                to[s[i]] = t[i];
                in[t[i]]++;
                ans++;
            }
        }
        topo();
        // 此时一定有解，对于现在还没标记的点，一定是在一个纯环里面，此时对于每个环答案加1
        for (int i = 'a'; i <= 'z'; ++i) {
            if (vis[i] == 0) {
                ans++;
                dfs(i);
            }
        }
        for (int i = 'A'; i <= 'Z'; ++i) {
            if (vis[i] == 0) {
                ans++;
                dfs(i);
            }
        }
        cout << ans << endl;
    }
    return 0;
}
```
**核心实现思想**：先判断无解情况，然后建图统计边数。通过拓扑排序标记不在环上的点，再用 DFS 找出纯环，每个纯环答案加 1。

### 最优关键思路或技巧
- **图论建模**：将字符替换问题转化为图论问题，通过建图分析字符间的转换关系，使问题更直观。
- **拓扑排序和 DFS**：利用拓扑排序标记不在环上的点，DFS 找出纯环，方便计算操作次数。

### 可拓展之处
同类型题如涉及状态转换、元素替换等问题，可考虑用图论建模，再根据图的结构分类讨论。类似算法套路有将复杂问题抽象为图，利用图的遍历算法（如 BFS、DFS）和拓扑排序解决问题。

### 推荐题目
1. [P1113 杂务](https://www.luogu.com.cn/problem/P1113)：涉及拓扑排序和图的应用。
2. [P1347 排序](https://www.luogu.com.cn/problem/P1347)：需要运用图论和拓扑排序判断关系。
3. [P2746 [USACO5.3] 校园网Network of Schools](https://www.luogu.com.cn/problem/P2746)：考察图的连通性和相关算法。

### 个人心得总结
泥土笨笨提到题目细节多，比赛时容易出错，还给出其他题解的 hack 数据，提醒读者在做题时要注意细节，对其他题解要批判性地看待，多思考可能存在的问题。 

---
处理用时：39.85秒
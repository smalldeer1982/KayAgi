# 题目信息

# [USACO23FEB] Moo Route II S

## 题目描述

注意：本题的时间限制为 4 秒，是默认限制的两倍。

Bessie 正在度假！由于最近的技术进步，Bessie 可以通过先进的航班旅行，这些航班甚至可以进行时间旅行。此外，即使存在多个“平行”的 Bessie 同时出现也不会有任何问题。

在这个国家，有 $N$ 个机场，编号为 $1,2,\cdots,N$，以及 $M$ 条时间旅行航班（$1 \leq N,M \leq 200000$）。第 $j$ 条航班从机场 $c_j$ 在时间 $r_j$ 起飞，并在时间 $s_j$ 抵达机场 $d_j$（$0 \leq r_j,s_j \leq 10^9$，$s_j < r_j$ 是可能的）。此外，Bessie 在机场 $i$ 需要停留 $a_i$ 时间（$1 \leq a_i \leq 10^9$）。也就是说，如果 Bessie 乘坐一趟航班在时间 $s$ 抵达机场 $i$，她可以转乘一趟从该机场出发的航班，只要该航班的起飞时间 $r \geq s + a_i$。需要注意的是，停留时间不会影响 Bessie 抵达某机场的实际时间。

Bessie 从城市 $1$ 出发，起始时间为 $0$。对于从 $1$ 到 $N$ 的每个机场，求出 Bessie 最早可以到达该机场的时间。

## 样例 #1

### 输入

```
3 3
1 0 2 10
2 11 2 0
2 1 3 20
10 1 10```

### 输出

```
0
0
20```

## 样例 #2

### 输入

```
3 3
1 0 2 10
2 10 2 0
2 1 3 20
10 1 10```

### 输出

```
0
10
-1```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何解决带有时间旅行航班的最短路问题展开，由于存在负边权，常规的迪杰斯特拉算法不适用，大部分题解采用了 SPFA 及其优化版本，或者通过拆点转化为连通性问题，再利用 BFS 或 DFS 求解。各题解的核心思路都是利用每条边只会松弛一次的特性进行优化，避免重复计算，以降低时间复杂度。

### 所选题解
- **作者：Usada_Pekora (赞：5)，4星**
    - **关键亮点**：思路清晰，通过对每个点的出边按 $r$ 降序排序，方便跳过走过的边，避免重复计算，代码实现简洁易懂。
- **作者：zac2010 (赞：4)，4星**
    - **关键亮点**：提出了 SPFA 的 LLL 优化和记忆化 SPFA 两种思路，对算法的优化有深入思考，且记忆化 SPFA 时间复杂度有保证，代码短。
- **作者：Genius_Star (赞：1)，4星**
    - **关键亮点**：考虑到图中可能有环，记录 $k_u$ 表示从 $u$ 出发的航班已经遍历到的位置，避免重复走航班，同时对每个点出发的航班按出发时间降序排序，优化了搜索过程。

### 重点代码及核心实现思想
#### Usada_Pekora 的题解
```cpp
inline void spfa() { // optimized bellman ford
    for (int i = 1; i <= n; i++)
        dis[i] = inf;
    dis[1] = 0, inq[1] = true;
    queue<int> q;
    q.push(1);
    while (!q.empty()) {
        int u = q.front();
        inq[u] = false;
        q.pop();
        for (int _ = cur[u]; _ < g[u].size(); _++) {
            int v = g[u][_].v, in = g[u][_].in, out = g[u][_].out;
            cur[u] = _;
            if (in < dis[u] + a[u])
                break;
            if (out < dis[v]) {
                dis[v] = out;
                if (!inq[v]) {
                    q.push(v);
                    inq[v] = true;
                }
            }
        }
    }
}
```
核心思想：使用队列维护更新的点，对每个点的出边按 $r$ 降序排序，从当前记录的边开始遍历，若当前边的出发时间小于当前点的到达时间加上停留时间，则停止遍历，若能更新其他点的最短时间，则更新并加入队列。

#### zac2010 的题解
```cpp
void Spfa(){
    L(i, 2, n) dis[i] = 2e9;
    vis[1] = 1, q.push(1);
    while(!q.empty()){
        int u = q.front(); q.pop();
        int tm = (u == 1? 0 : dis[u] + a[u]);
        while(id[u] && g[u][id[u] - 1].s >= tm) id[u]--;
        vis[u] = 0;
        L(i, id[u], (int)g[u].size() - 1){
            int v = g[u][i].v, t = g[u][i].t;
            if(t < dis[v]){
                dis[v] = t;
                if(!vis[v]) vis[v] = 1, q.push(v);
            }
        }
        while(g[u].size() > id[u]) g[u].pop_back(); id[u] = g[u].size();
    }
}
```
核心思想：使用队列维护更新的点，对每个点的出边排序，维护分隔点的位置，跳过起始时间太早的边，若能更新其他点的最短时间，则更新并加入队列，同时删除已经拓展过的边。

#### Genius_Star 的题解
```cpp
void dfs(ll u,ll t){
    for(ll i=k[u];i<(ll)E[u].size();i++){
        ll id=E[u][i].second;
        Node v=E[u][i].first;
        if(v.r<t) 
            break;
        if(f[id])
            continue;
        f[id]=1;
        dis[v.d]=min(dis[v.d],v.s);
        k[u]++;
        dfs(v.d,v.s+w[v.d]);
    }
    return;
}
```
核心思想：使用 DFS 搜索，记录从每个点出发的航班已经遍历到的位置，对每个点出发的航班按出发时间降序排序，若当前航班的出发时间小于当前时间，则停止遍历，若航班未被坐过，则标记并更新答案，继续 DFS。

### 最优关键思路或技巧
- **边的排序与标记**：对每个点的出边按出发时间排序，方便跳过无法乘坐的边，同时标记已经走过的边，避免重复计算。
- **记录遍历位置**：记录从每个点出发的边已经遍历到的位置，避免在图有环的情况下重复遍历边。
- **拆点转化**：将每个点按可能的到达 / 出发时间拆点，转化为连通性问题，利用 BFS 或 DFS 求解。

### 可拓展之处
同类型题可能涉及更复杂的时间限制或图结构，类似算法套路包括：
- 对于存在负边权的最短路问题，可考虑使用 SPFA 及其优化版本。
- 当边有特殊性质（如每条边只松弛一次）时，可通过标记或删除边来避免重复计算。
- 对于复杂的图结构，可通过拆点、缩点等方式转化为更简单的问题求解。

### 推荐题目
- [P1144 最短路计数](https://www.luogu.com.cn/problem/P1144)
- [P3371 【模板】单源最短路径（弱化版）](https://www.luogu.com.cn/problem/P3371)
- [P4779 【模板】单源最短路径（标准版）](https://www.luogu.com.cn/problem/P4779)

### 个人心得摘录与总结
- **rhn7**：以 Xy_top 大佬的代码为例，指出图中有环时，`dfs` 可能会重复遍历边导致 TLE，解决方法是在递归返回后更新循环变量，避免重复遍历。
- **tder**：提到输入顺序看错调了好久，提醒在做题时要仔细阅读输入输出格式。

---
处理用时：46.72秒
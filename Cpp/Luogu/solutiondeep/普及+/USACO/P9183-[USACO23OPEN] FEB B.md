# 题目信息

# [USACO23OPEN] FEB B

## 题目描述

贝西和埃尔希正在密谋最终推翻他们的主人——农夫约翰！他们通过 $N$ 条短信进行计划。他们的对话可以用一个长度为 $N$ 的字符串 $S$ 来表示。     
其中 $S_i$ 是字母 ```B``` 或 ```E```，这意味着第 $i$ 条消息分别由贝西或埃尔希发送的。


然而，农夫约翰听说了这个消息，并试图拦截他们的谈话。因此，字符串 $S$ 的一些字母是 ```F```，这意味着农夫约翰混淆了信息，发件人未知（贝西、埃尔希都有可能）。   
**注：约翰没有发送信息！他只是在干扰奶牛间的通话！**


未混淆对话的兴奋程度是**一只奶牛重复发送信息的次数**。也就是说，子串 ```BB``` 或 ```EE``` 在 $S$ 中出现的次数。你想找到原始信息的兴奋程度，但你不知道约翰的信息中哪一条实际上是贝西或埃尔希的。在所有可能的情况下，**从小到大输出**所有可能的兴奋程度。

## 说明/提示

$1 \le N \le 2 \times 10^5$。
- 测试点 4~8：$N \le 10$
- 测试点 9~20：无额外限制。

## 样例 #1

### 输入

```
4
BEEF
```

### 输出

```
2
1
2
```

## 样例 #2

### 输入

```
9
FEBFEBFEB
```

### 输出

```
2
2
3```

## 样例 #3

### 输入

```
10
BFFFFFEBFE```

### 输出

```
3
2
4
6```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何解决将字符串中 `F` 替换为 `B` 或 `E` 后，计算子串 `BB` 和 `EE` 出现次数的所有可能情况展开。大部分题解都发现答案呈等差数列规律，并通过分类讨论确定公差，利用贪心算法确定首项和末项。各题解在思路阐述、证明过程和代码实现上存在差异，但核心思路一致。

### 所选题解
- **作者：Limie (赞：19) - 5星**
    - **关键亮点**：对答案为等差数列的结论进行了详细证明，先从简单情况（序列中仅有一个 `F`）分类讨论，再用数学归纳法证明普遍情况，思路清晰，逻辑严谨。
    - **个人心得**：无
- **作者：include13_fAKe (赞：14) - 4星**
    - **关键亮点**：详细阐述了不同测试点的解法，对思路和代码的解释较为清晰，便于理解。
    - **个人心得**：无
- **作者：Starstream (赞：3) - 4星**
    - **关键亮点**：通过 DFS 暴力对拍发现答案规律，然后分类讨论一个 `F` 的位置来证明结论，最后用贪心求出首项和末项，思路完整。
    - **个人心得**：无

### 重点代码
#### Limie 的代码
```cpp
int l()
{
    int ans=0;
    string t=st;
    for(int i=1;i<n;i++)
        if(t[i]=='F')
            if(t[i-1]=='B')t[i]='E';else t[i]='B';
        
    for(int i=1;i<n;i++)ans+=(t[i-1]==t[i]);
    return ans;
}
int r()
{
    int ans=0;
    string t=st;
    for(int i=1;i<n;i++)
        if(t[i]=='F')t[i]=t[i-1];
    
    for(int i=1;i<n;i++)ans+=(t[i-1]==t[i]); 
    return ans;
}
int main()
{
    int i;
    cin>>n>>st;
    if(st[0]=='F'||st[n-1]=='F')d=1;
    if(st[0]!='F'){
        int x=l(),y=r();
        cout<<(y-x)/d+1<<endl;
        for(i=x;i<=y;i+=d)cout<<i<<endl;
        return 0;
    }
    st[0]='B';
    int x=l(),y=r();
    st[0]='E';
    x=min(x,l());
    y=max(y,r());
    cout<<(y-x)/d+1<<endl;
    for(i=x;i<=y;i+=d)cout<<i<<endl;
}
```
**核心实现思想**：`l()` 函数计算兴奋程度的下限，将 `F` 替换为与前一个字符不同的字符；`r()` 函数计算兴奋程度的上限，将 `F` 替换为与前一个字符相同的字符。根据字符串首尾是否为 `F` 确定公差，再根据情况计算并输出所有可能的兴奋程度。

#### include13_fAKe 的代码
```cpp
int solve_most(){//计算上限
    int ret=0;
    string S1=S;
    for(register int i=2;i<=N;i++)	if(S1[i]=='F')	S1[i]=S1[i-1];
    for(register int i=2;i<=N;i++)	ret+=(S1[i-1]==S1[i]); 
    return ret;
}
int solve_least(){//计算下限
    int ret=0;
    string S1=S;
    for(register int i=2;i<=N;i++)
        if(S1[i]=='F')
            if(S1[i-1]=='B')	S1[i]='E';
            else	S1[i]='B';
    for(register int i=2;i<=N;i++)	ret+=(S1[i-1]==S1[i]);
    return ret;
}
int main(){
    cin>>N>>S;
    S=' '+S;
    if(S[1]=='F'||S[N]=='F')	flag=1;
    if(S[1]!='F'){
        int ans1=solve_most();
        int ans2=solve_least();
        printf("%d\n",(ans1-ans2)/flag+1);
        for(ans2;ans2<=ans1;ans2+=flag)	printf("%d\n",ans2);
        return 0;
    }
    S[1]='B';
    int ans1=solve_most();
    int ans2=solve_least();
    S[1]='E';
    ans1=max(ans1,solve_most());
    ans2=min(ans2,solve_least());
    printf("%d\n",(ans1-ans2)/flag+1);
    for(ans2;ans2<=ans1;ans2+=flag)	printf("%d\n",ans2);
    return 0;
} 
```
**核心实现思想**：`solve_most()` 函数计算兴奋程度的上限，`solve_least()` 函数计算兴奋程度的下限。根据字符串首尾是否为 `F` 确定公差，再根据情况计算并输出所有可能的兴奋程度。

#### Starstream 的代码
```cpp
int main()
{
    int sub = 0, hh = 0, tt = 0; // 公差、首项、末项
    scanf("%d%s", &n, s1);
    if (s1[0] == 'F' || s1[n - 1] == 'F') sub = 1; // 首尾 -> 公差为 1
    else sub = 2; // 否则公差为 2

    while (tt < n - 1 && s1[tt] == 'F') tt ++ ; // 找到第一个不是 F 的位置开始贪心
    for (int i = 0; i < n; i ++ ) s2[i] = s1[i];

    for (int i = tt + 1; i < n; i ++ )
    {
        if (s1[i] == 'F')
        {
            s2[i] = s2[i - 1]; // 最小值尽量相等
            if (s1[i - 1] == 'E') s1[i] = 'B'; // 最大值尽量交替出现
            if (s1[i - 1] == 'B') s1[i] = 'E';
        }
        if (s1[i] == s1[i - 1]) hh ++ ; // 向首项末项累加答案
        if (s2[i] == s2[i - 1]) tt ++ ;
    }

    int k = (tt - hh) / sub + 1; // 计算等差数列项数
    printf("%d\n", k);
    for (int i = hh; i <= tt; i += sub)
        printf("%d\n", i);
    return 0;
}
```
**核心实现思想**：根据字符串首尾是否为 `F` 确定公差。找到第一个不是 `F` 的位置开始贪心，`s1` 数组尽量让相邻字符不同以计算下限，`s2` 数组尽量让相邻字符相同以计算上限。最后计算并输出所有可能的兴奋程度。

### 最优关键思路或技巧
- **找规律**：通过观察样例或打表发现答案呈等差数列规律，简化了问题的求解过程。
- **分类讨论**：根据 `F` 的位置（开头、中间、结尾）分类讨论，确定等差数列的公差。
- **贪心算法**：通过贪心策略分别计算出兴奋程度的下限和上限，即等差数列的首项和末项。

### 可拓展之处
同类型题可能会有不同的字符替换规则或统计要求，但核心思路类似，可通过找规律、分类讨论和贪心算法解决。类似算法套路可应用于其他字符串处理问题，如字符串的组合、排列等，通过分析不同情况的特点，找到规律并利用贪心或其他算法求解。

### 推荐题目
- [P1059 明明的随机数](https://www.luogu.com.cn/problem/P1059)：考察排序和去重，与本题找规律和分类讨论的思维方式类似。
- [P1047 校门外的树](https://www.luogu.com.cn/problem/P1047)：考察区间处理和标记，与本题对字符串中不同字符的处理有相似之处。
- [P1097 统计数字](https://www.luogu.com.cn/problem/P1097)：考察数据的统计和排序，与本题对兴奋程度的统计和输出有一定关联。

### 个人心得摘录与总结
- **Mu_leaf**：模拟赛中在厕所推出规律，说明在解题过程中，换个环境或放松心态可能会有新的灵感。但同时也提醒我们要对规律进行严格证明，不能仅凭直觉。

---
处理用时：55.72秒
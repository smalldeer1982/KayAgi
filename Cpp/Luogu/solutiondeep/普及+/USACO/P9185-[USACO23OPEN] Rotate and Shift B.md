# 题目信息

# [USACO23OPEN] Rotate and Shift B

## 题目描述

**注意：本题的时间限制为 4 秒，是默认时间限制的 2 倍。**

为了庆祝春天的到来，Farmer John 的 $N$ 头奶牛发明了一种有趣的舞蹈，她们围成一个圆圈，并以一种可预测的方式重新排列自己。

具体来说，圆圈上有 $N$ 个位置，编号从 $0$ 到 $N-1$，其中位置 $0$ 紧接着位置 $N-1$。每个位置上有一头奶牛。奶牛的编号也从 $0$ 到 $N-1$。初始时，奶牛 $i$ 位于位置 $i$。你会被告知一组 $K$ 个“活跃”位置 $0 = A_1 < A_2 < \dots < A_K < N$，这意味着这些位置上的奶牛是下一批要移动的。

在舞蹈的每一分钟，会发生两件事。首先，活跃位置上的奶牛会旋转：位置 $A_1$ 的奶牛移动到位置 $A_2$，位置 $A_2$ 的奶牛移动到位置 $A_3$，依此类推，位置 $A_K$ 的奶牛移动到位置 $A_1$。所有这些 $K$ 次移动同时发生，因此在旋转完成后，所有活跃位置仍然恰好有一头奶牛。接下来，活跃位置本身会移动：$A_1$ 变为 $A_1 + 1$，$A_2$ 变为 $A_2 + 1$，依此类推（如果某个活跃位置 $A_i = N-1$，则 $A_i$ 会循环回到 $0$）。

请计算舞蹈进行 $T$ 分钟后奶牛的顺序。

## 说明/提示

对于上述样例，以下是前四个时间步的奶牛顺序和活跃位置 $A$：
```
初始，T = 0：顺序 = [0 1 2 3 4]，A = [0 2 3]
T = 1：顺序 = [3 1 0 2 4]
T = 1：A = [1 3 4]
T = 2：顺序 = [3 4 0 1 2]
T = 2：A = [2 4 0]
T = 3：顺序 = [2 4 3 1 0]
T = 3：A = [3 0 1]
T = 4：顺序 = [1 2 3 4 0]
```

$1 \leq K \leq N \leq 2 \cdot 10^5$，$1 \leq T \leq 10^9$。

- 输入 2-7：$N \leq 1000$，$T \leq 10000$。
- 输入 8-13：没有额外限制。

## 样例 #1

### 输入

```
5 3 4
0 2 3
```

### 输出

```
1 2 3 4 0
```

# AI分析结果

### 综合分析与结论
这些题解主要围绕奶牛舞蹈问题展开，核心是模拟或找出规律来计算舞蹈进行 `T` 分钟后奶牛的顺序。思路大致分为暴力模拟、找规律计算和倍增优化三种。暴力模拟简单直接但时间复杂度高，会超时；找规律计算通过观察样例发现数字移动规律，从而直接计算最终位置，时间复杂度较低；倍增优化则通过预处理和递推，将时间复杂度优化到可接受范围。

### 所选题解
- **作者：HyB_Capricornus (赞：11)，4星**
  - **关键亮点**：思路清晰，通过定义操作并进行抵消化简，利用倍增思想将原始 $O(nT)$ 的复杂度优化到 $O(n\log_{2}{T})$，有效解决了时间复杂度高的问题。
  - **个人心得**：提醒最后不要忘了顺时针转 `n` 次，且 `y` 很大时需要取模，否则会变成负数（赛时被卡）。
- **作者：player_1_Z (赞：5)，4星**
  - **关键亮点**：先给出暴力解法，再通过打表找规律，将复杂问题简单化，最后利用规律直接计算最终位置，降低了时间复杂度。
  - **个人心得**：无。
- **作者：Yxy7952 (赞：3)，4星**
  - **关键亮点**：同样是找规律解题，通过多测几组样例总结出通用规律，代码注释详细，便于理解。
  - **个人心得**：无。

### 重点代码
#### HyB_Capricornus 的核心代码
```cpp
// 定义操作并利用倍增优化
// 创建数组 jmp[i][j]，其中 jmp[i][j]=d 表示进行 2^j 次 D 操作把 b_i 挪到了 d 位置
// 通过倍增，原始暴力的复杂度 O(nT) 成功优化到 O(nlog₂T)
```
#### player_1_Z 的核心代码
```cpp
// 暴力代码
while(t--){
    int h=a[b[k]];
    for(int i=1;i<=k;i++){
        int h2=h;
        h=a[b[i]];
        a[b[i]]=h2;
        b[i]=(b[i]+1)%n;
    }
}
// 找规律代码
for(int i=0;i<n;i++){
    if(i==b[k1]){
        if(k1==k) x=n-b[k1];
        else{
            k1++;
            x=b[k1]-b[k1-1];
        }
    }
    a[i][1]=x;
}
// ...后续根据规律计算最终位置
```
#### Yxy7952 的核心代码
```cpp
// 找规律计算最终位置
for(ll i=0;i<k;i++){
    ll x=a[i+1]-a[i];//x 表示每次停的时间和每次走的距离。 
    for(ll j=a[i];j<a[i+1];j++){
        int p=xs(t-(j-a[i]),x)*x;//表示偏移量。 
        ll b=(j+p)%n;//用本身的值加上偏移量，注意 %n 保持在 0~n-1 范围内。 
        ans[b]=j;//记录答案。 
    } 
}
```

### 最优关键思路或技巧
- **找规律**：通过多测几组样例，观察数字的移动规律，发现每个数在特定区间内的移动周期和步长，从而直接计算最终位置，避免了暴力模拟的高时间复杂度。
- **倍增优化**：对于操作次数很大的问题，利用倍增思想，通过预处理和递推，将时间复杂度从 $O(nT)$ 优化到 $O(n\log_{2}{T})$。

### 可拓展之处
同类型题或类似算法套路：
- 涉及循环操作和状态变化的问题，如环形数组的元素移动、周期性变化的状态更新等，都可以尝试找规律或使用倍增优化。
- 对于有大量重复操作的问题，考虑能否通过预处理和递推来减少时间复杂度。

### 推荐题目
- [P1044 栈](https://www.luogu.com.cn/problem/P1044)：考察栈的操作和规律总结。
- [P1064 金明的预算方案](https://www.luogu.com.cn/problem/P1064)：需要分析物品之间的关系，找出规律进行动态规划。
- [P1192 台阶问题](https://www.luogu.com.cn/problem/P1192)：可以通过找规律或动态规划解决，与本题找规律的思路类似。

---
处理用时：33.74秒
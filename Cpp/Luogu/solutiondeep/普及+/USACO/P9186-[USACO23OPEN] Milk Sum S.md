# 题目信息

# [USACO23OPEN] Milk Sum S

## 题目描述

**注意：本题的时间限制为 4 秒，是默认时间限制的 2 倍。**

Farmer John 的 $N$ 头奶牛的产奶量为整数 $a_1, \dots, a_N$。也就是说，第 $i$ 头奶牛每分钟产 $a_i$ 单位的牛奶。

每天早上，Farmer John 会将所有 $N$ 头奶牛连接到谷仓的挤奶机上。他需要依次断开连接，将奶牛送去进行日常锻炼。第一头奶牛在挤奶 1 分钟后被断开连接，第二头奶牛在再挤奶 1 分钟后被断开连接，依此类推。由于第一头奶牛（假设是奶牛 $x$）只在挤奶机上停留了 1 分钟，她总共贡献了 $a_x$ 单位的牛奶。第二头奶牛（假设是奶牛 $y$）在挤奶机上停留了总共 2 分钟，因此贡献了 $2a_y$ 单位的牛奶。第三头奶牛（假设是奶牛 $z$）贡献了 $3a_z$ 单位的牛奶，依此类推。设 $T$ 表示 Farmer John 以最优顺序断开奶牛连接时，可以收集到的最大总牛奶量。

Farmer John 很好奇，如果某些奶牛的产奶量发生变化，$T$ 会如何变化。对于每个由两个整数 $i$ 和 $j$ 指定的 $Q$ 个查询，请计算如果将 $a_i$ 设置为 $j$，新的 $T$ 值会是多少。注意，每个查询都是独立的临时变化，即在考虑下一个查询之前，$a_i$ 会恢复为原始值。

## 说明/提示

对于第一个查询，$a$ 将变为 $[1,1,4,2,6]$，此时 $T = 1 \cdot 1 + 2 \cdot 1 + 3 \cdot 2 + 4 \cdot 4 + 5 \cdot 6 = 55$。

对于第二个查询，$a$ 将变为 $[1,8,4,2,6]$，此时 $T = 1 \cdot 1 + 2 \cdot 2 + 3 \cdot 4 + 4 \cdot 6 + 5 \cdot 8 = 81$。

对于第三个查询，$a$ 将变为 $[1,10,4,5,6]$，此时 $T = 1 \cdot 1 + 2 \cdot 4 + 3 \cdot 5 + 4 \cdot 6 + 5 \cdot 10 = 98$。

$1 \leq N \leq 1.5 \cdot 10^5$，$0 \leq a_i \leq 10^8$，$1 \leq Q \leq 1.5 \cdot 10^5$，$0 \leq j \leq 10^8$。

- 输入 2-4：$N, Q \leq 1000$。
- 输入 5-11：没有额外限制。

## 样例 #1

### 输入

```
5
1 10 4 2 6
3
2 1
2 8
4 5
```

### 输出

```
55
81
98
```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何高效计算在每次修改数组元素后，按特定规则排序得到的最大牛奶总量。核心思路是先对原数组排序并预处理出最大牛奶总量及前缀和，然后针对每次修改操作，通过二分查找确定新元素位置，再根据新元素与原元素的大小关系分类讨论，计算修改后的最大牛奶总量。各题解的主要区别在于分类讨论的方式和代码实现细节。

### 所选题解
- **作者：DreamLand_zcb (赞：12)，4星**
    - **亮点**：思路清晰，配有详细的图文解释，代码注释丰富，易于理解。通过前缀和优化计算，时间复杂度为 $\Theta(Q \log n)$。
    - **个人心得**：“十年 OI 一场空，不开 long long 见祖宗！” 强调了在处理大数值时要使用 `long long` 类型，避免数据溢出。
- **作者：Nuyoah_awa (赞：7)，4星**
    - **亮点**：先给出暴力思路，再逐步优化，将改数操作分为改大、改小两种情况讨论，推导出通项公式，最后通过预处理和二分查找实现 $O(n \log n)$ 的时间复杂度。
    - **个人心得**：“小心二分别写挂（尤其是第二种情况）”，提醒在使用二分查找时要注意边界条件和判断逻辑。
- **作者：small_john (赞：1)，4星**
    - **亮点**：思路简洁明了，通过二分和前缀和解决问题，分两种情况讨论修改元素后的变化，代码实现较为精炼。

### 关键思路与技巧
- **排序预处理**：先对原数组排序，得到最大牛奶总量，同时计算前缀和数组，方便后续计算区间和。
- **二分查找**：利用二分查找确定新元素在排序数组中的位置，时间复杂度为 $O(\log n)$。
- **分类讨论**：根据新元素与原元素的大小关系，分情况讨论修改元素后对最大牛奶总量的影响，通过前缀和数组快速计算区间和，减少计算量。

### 可拓展之处
同类型题目可能会有更多复杂的修改操作或条件限制，例如多次连续修改、修改多个元素等。类似算法套路可用于处理其他需要排序和动态修改数组元素并计算相关值的问题，如动态规划中的状态转移、贪心算法中的元素调整等。

### 推荐题目
- [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)：考察贪心算法和优先队列的应用。
- [P1104 生日](https://www.luogu.com.cn/problem/P1104)：考察排序和结构体的使用。
- [P1271 选举学生会](https://www.luogu.com.cn/problem/P1271)：考察排序和统计的应用。

### 重点代码及核心思想
#### DreamLand_zcb 的代码
```cpp
while(Q--)
{
    ll x, y;
    cin >> x >> y;
    ll pos=upper_bound(b+1, b+n+1, y)-b;
    ll ans=sum;
    ans-=a[x]*P[a[x]];
    ans-=s[n]-s[P[a[x]]];
    ans+=y*(pos-(pos > P[a[x]]));
    ans+=s[n]-s[pos-1];
    if(pos <= P[a[x]]) ans-=b[P[a[x]]];
    cout << ans << endl;
}
```
**核心思想**：对于每次修改操作，先找到新元素的位置 `pos`，然后减去原元素对总量的贡献，再根据 `pos` 与原元素位置的关系调整总量，最后加上新元素的贡献。

#### Nuyoah_awa 的代码
```cpp
while (T --)
{
    int opt, x;
    cin >> opt >> x;
    opt = pos[opt];
    if (x == a[opt].val)
        cout << ans << "\n";
    if (x < a[opt].val)
    {
        // 改小情况处理
    }
    if (x > a[opt].val)
    {
        // 改大情况处理
    }
}
```
**核心思想**：根据新元素与原元素的大小关系分情况讨论，通过二分查找确定新元素位置，再利用通项公式计算修改后的总量。

#### small_john 的代码
```cpp
while(q--)
{
    cin>>x>>y;
    int l = 1,r = n,end = n+1;
    while(l<=r)
    {
        int mid = (l+r)/2;
        if(a[id[mid]]>=y) r = mid-1,end = mid;
        else l = mid+1;
    }
    if(a[x]>=y) cout<<ans-a[x]*_id[x]+y*end+(s[_id[x]-1]-s[end-1])<<'\n';
    else cout<<ans-a[x]*_id[x]+y*(end-1)-(s[end-1]-s[_id[x]])<<'\n';
}
```
**核心思想**：二分查找第一个大于等于新元素的位置 `end`，根据原元素与新元素的大小关系分情况计算修改后的总量。

---
处理用时：37.81秒
# 题目信息

# [USACO23OPEN] Field Day S

## 题目描述

**提示：本题的 Python 时限为 15s。其它语言默认 2s。**

Farmer John 的 $N$ 个牛棚都会选出包含 $C$ 只奶牛的队伍去参加户外聚会。所有奶牛的品种都只可能是根西牛（`G`）或荷斯坦奶牛（`H`）。

我们将两个奶牛队伍中，同一位置对应的两头奶牛品种不同的所有位置 $i(1 \leq i \leq C)$ 的个数，定义为的两个奶牛队伍的差异。对于编号 $1...N$ 的每个奶牛队伍 $t$，请计算出 $t$ 和其它所有队伍的差异的最大值。

## 说明/提示

第一个和第三个队伍的差异为 $5$。第二个和第三个队伍的差异为 $3$。

$2 \leq N \leq 10^5,1 \leq C \leq 18$。

- 对于测试点 2-5：$C = 10$。
- 对于测试点 6-9：所有答案最少为 $C - 3$。
- 对于测试点 10-20：没有额外条件。

## 样例 #1

### 输入

```
5 3
GHGGH
GHHHH
HGHHG```

### 输出

```
5
3
5```

# AI分析结果

### 综合分析与结论
这些题解主要围绕如何高效计算给定字符串间的最大汉明距离展开。题解思路多样，包括利用二进制转换、动态规划、广度优先搜索、快速沃尔什变换（FWT）等方法。部分题解通过将最大汉明距离问题转化为最小汉明距离问题来简化计算，还有些题解借助数据范围的特点进行优化。各题解的时间复杂度有所不同，在处理大规模数据时效率存在差异。

### 所选题解
- **作者：IamZZ（4星）**
  - **关键亮点**：思路清晰，将字符串转换为二进制数处理，通过预处理最小汉明距离来计算最大汉明距离，时间复杂度较低。
  - **核心代码**：
```c++
for(i=0;i<=(1<<c)-1;++i)
  f[i]=99999999;
for(i=1;i<=n;++i)
{
    scanf("%s",s+1);
    for(j=1;j<=c;++j)
    {
        v=0;
        if(s[j]=='G')
          v=1;
        o[i]=o[i]<<1|v;
    }
    f[o[i]]=0;
}
for(j=1;j<=c;++j)
{
    for(i=0;i<=(1<<c)-1;++i)
      f[(1<<j-1)^i]=min(f[(1<<j-1)^i],f[i]+1);
}
for(i=1;i<=n;++i)
{
    m=c-f[(1<<c)-1^o[i]];
    printf("%d\n",m);
}
```
  - **核心实现思想**：先将输入的字符串转换为二进制数，将这些数对应的最小汉明距离初始化为 0，其他数初始化为一个较大值。然后通过位运算枚举所有可能的状态，更新最小汉明距离。最后根据最大汉明距离与最小汉明距离的关系计算并输出结果。

- **作者：FFTotoro（4星）**
  - **关键亮点**：使用广度优先搜索，将问题转化为整数的异或操作，思路简洁直观。
  - **核心代码**：
```cpp
vector<int> a(n),m(1<<c,-1);
queue<pair<int,int> > q;
for(auto &i:a){
    for(int j=0;j<c;j++){
        char x; cin>>x;
        if(x=='G')i|=1<<j;
    }
    q.emplace(i,m[i]=0);
}
while(!q.empty()){
    auto [u,w]=q.front(); q.pop();
    for(int i=0;i<c;i++)
        if(int v=u^(1<<i);m[v]==-1)
            q.emplace(v,m[v]=w+1);
}
for(int i:a)cout<<c-m[(1<<c)-1^i]<<endl;
```
  - **核心实现思想**：将输入的字符串转换为整数，以这些整数为源点进行广度优先搜索。每次搜索相邻的整数（即二进制表示下仅有一位不同的整数），更新未访问过的整数的步数。最后根据最大异或 `popcount` 与最小异或 `popcount` 的关系计算并输出结果。

- **作者：ppip（4星）**
  - **关键亮点**：通过定义 $f$ 和 $g$ 数组，利用状态转移方程计算最小汉明距离，进而得到最大汉明距离，代码简洁。
  - **核心代码**：
```cpp
fill_n(f,1<<m,m+1);
for (int i{1};i<=n;++i) f[a[i]]=0;
for (int i{(1<<m)-1};~i;--i)
    for (int j{0};j<m;++j)
        if (~i>>j&1) f[i]=min(f[i],f[i^1<<j]+1);
for (int i{0};i<1<<m;++i)
    for (int j{0};j<m;++j)
        if (i>>j&1) f[i]=min(f[i],f[i^1<<j]+1);
for (int i{1};i<=n;++i) cout<<m-f[(1<<m)-1-a[i]]<<"\n" ;
```
  - **核心实现思想**：先将 $f$ 数组初始化为一个较大值，将出现过的字符串对应的 $f$ 值初始化为 0。然后通过两次状态转移更新 $f$ 数组，第一次考虑 $x$ 的超集，第二次考虑 $x$ 的子集。最后根据最大汉明距离与最小汉明距离的关系计算并输出结果。

### 最优关键思路或技巧
- **二进制转换**：将字符串转换为二进制数，方便进行位运算，简化了汉明距离的计算。
- **问题转化**：将最大汉明距离问题转化为最小汉明距离问题，降低了问题的复杂度。
- **广度优先搜索**：通过广搜可以高效地找到最小汉明距离。
- **状态转移**：利用动态规划的思想，通过状态转移方程更新最小汉明距离。

### 可拓展之处
同类型题或类似算法套路：
- 计算字符串间的编辑距离，可使用动态规划解决。
- 处理二进制状态压缩的问题，如旅行商问题，可使用状态压缩动态规划。
- 计算图中节点间的最短路径，可使用广度优先搜索或 Dijkstra 算法。

### 推荐题目
- P1119 灾后重建：涉及图的最短路径问题，可使用 Floyd 算法。
- P1896 [SCOI2005] 互不侵犯：状态压缩动态规划的经典题目。
- P2704 [NOI2001] 炮兵阵地：同样是状态压缩动态规划的题目，需要考虑更多的状态转移条件。

### 个人心得摘录与总结
- **作者：FFTotoro**：思路来源于 ZYC210712 大佬分享的广搜思路，说明交流和学习他人的思路可以获得新的启发。 

---
处理用时：41.69秒
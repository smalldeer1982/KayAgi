# 题目信息

# [USACO05OPEN] Around the world G

## 题目描述

这些年，农夫约翰在国际上交了一大批开农场的朋友。由于他有一段时间没有去见过英国的农夫泰德和荷兰的农夫波尔，所以他想去拜访他们。

他知道每个朋友的农场的经度（是一个从 $0$ 到 $359$ 的整数，我们把地球看成一个圆，经度在此圆上顺时针方向递增）。  

农夫约翰打算乘飞机去拜访他的 $n$ 个朋友（用 $1$ 到 $n$ 来表示）。他知道在这些农场之间有 $m$ 条双向的航线。飞机是沿着地面上最短的路径飞行的（就是圆上的最短弧长）。两个农场之间的航线一定是最短的。

保证如果有两个农场在直径两端，那么它们之间一定不会被某条航线直接连接。

所以任何一次航行都可以被描述成顺时针或是逆时针的．比如说，经度 $30$ 到经度 $35$ 是顺时针的，经度 $350$ 到经度 $10$ 也是顺时针的，而经度 $350$ 到经度 $200$ 是逆时针的。

农夫约翰为了耍酷，决定要经过几个朋友的农场做到环球旅行，他想知道这是否可能，如果可能最少要乘几次飞机。

他想在他最好的朋友（即输入中的第一个）的农场上开始和结束这次旅行。为了保证这是一次环球航行，结束旅行，顺时针经过的路程不能等于逆时针经过的路程。

## 说明/提示

对于 $100\%$ 的数据，$1 \leq n \leq 5 \times 10^3$，$1 \leq m \leq 2.5 \times 10^4$。

## 样例 #1

### 输入

```
3 3
0
120
240
1 2
2 3
1 3
```

### 输出

```
3```

# AI分析结果

• 综合分析与结论：该题解思路清晰，准确把握了题目要求，采用广度优先搜索（BFS）结合哈希的方法来解决问题。通过哈希存储搜索过的状态，避免重复搜索，优化了搜索过程。算法复杂度分析合理，代码实现较为简洁，整体质量较高。不过在一些细节上，如注释可以更加详细，能让读者更好理解代码含义。
• 所选的题解：
  - 作者：Arson1st，星级：4星。关键亮点：思路清晰，采用 BFS 结合哈希的方法，对搜索状态进行优化，避免重复搜索，有效控制了复杂度。
• 重点代码：
```cpp
struct node{
    int u, w;
    bool operator < (const struct node &x) const{return u == x.u ? w < x.w : u < x.u;};
};
struct Node{node x; int d;};
queue<Node> que;
map<node, bool> vis;

void add(int a, int b) {
    ne[++ idx] = h[a]; h[a] = idx; e[idx] = b;
    if (abs(jd[b]-jd[a]) < 180) w[idx] = jd[b]-jd[a]; 
    else {
        if (jd[b] < 180) w[idx] = jd[b] - jd[a] + 360; 
        else w[idx] = jd[b] - jd[a] - 360;
    }
}

int BFS() {
    node st = {1, 0}; que.push({st, 0}); vis[st] = 1;
    while (!que.empty()) {
        Node now = que.front(); que.pop();
        int u = now.x.u, sta = now.x.w, dis = now.d;
        for (int i = h[u]; i; i = ne[i]) {
            int v = e[i];
            if (v == 1 && sta + w[i] >= 360) return dis+1;
            node tmp = {v, sta + w[i]};
            if (vis[tmp]) continue;
            que.push({tmp, dis+1}); vis[tmp] = 1;
        }
    }
    return -1;
}
```
核心实现思想：
1. `node` 结构体用于存储当前到达的节点 `u` 和路径权值 `w`，并重载小于号以便在 `map` 中使用。
2. `add` 函数用于添加边，并计算边的权值，根据两点经度差的情况判断是顺时针还是逆时针，确定边权的正负。
3. `BFS` 函数是核心搜索函数，从起点开始搜索，将初始状态入队并标记为已访问。在队列不为空时，取出队首元素，遍历其所有邻接节点。如果邻接节点是起点且路径权值和不低于 360，则返回边数；否则将新状态入队并标记为已访问。
• 最优的关键思路或技巧：
  - 采用 BFS 结合哈希的方法，通过哈希存储搜索过的状态 `(u, sta)`，避免重复搜索，有效控制了复杂度。
  - 在计算边权时，根据两点经度差的情况判断是顺时针还是逆时针，确定边权的正负，正确处理跨子午线的情况。
• 可拓展之处：同类型题或类似算法套路可应用于其他需要搜索路径并满足特定条件的问题，如寻找满足一定条件的最短回路、最短路径等。可以使用类似的状态存储和剪枝方法来优化搜索过程。
• 推荐题目：
  - P1144 最短路计数
  - P1608 路径统计
  - P2149 [SDOI2009]Elaxia的路线
• 个人心得：题解中提到注意选择 `map` 哈希时需要重载一下小于号，计算边权时记得特判一下跨子午线的两点真实经度跨度，且题目中相同经度的农场一样视作不同。总结就是在处理此类问题时，要注意数据结构的使用细节和特殊情况的处理。 

---
处理用时：30.12秒
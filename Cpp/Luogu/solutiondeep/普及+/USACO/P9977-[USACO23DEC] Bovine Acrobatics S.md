# 题目信息

# [USACO23DEC] Bovine Acrobatics S

## 题目描述

Farmer John 决定让他的奶牛表演杂技！首先，FJ 为他的奶牛称重，发现她们有 $N$（$1\le N\le 2\times 10^5$）个不同的体重。具体来说，对于全部的 $i\in [1,N]$，有 $a_i$ 只奶牛的体重为 $w_i$ 单位（$1\le a_i\le 10^9, 1\le w_i\le 10^9$）。

他最出名的节目需要奶牛叠成**平衡的奶牛塔**。一座**奶牛塔**是一些奶牛，每只奶牛站在下一只奶牛身上。一座奶牛塔是**平衡的**，当且仅当每一只被踩着的奶牛，都比**直接**踩在它身上的那只奶牛重至少 $K$（$1\le K\le 10^9$）单位。每只奶牛都可以成为奶牛塔的一部分。

如果 FJ 想要创造最多 $M$（$1 \le M \le 10^9$）座奶牛塔，最多有多少只奶牛可以成为奶牛塔的一部分？

## 说明/提示

### 样例解释 1

FJ 可以用体重为 $5,7,9$ 的奶牛创造四座平衡的奶牛塔，再用体重为 $5,7$ 的奶牛创造另一座。

### 样例解释 2

FJ 可以用体重为 $5,9$ 的奶牛创造四座平衡的奶牛塔，再用体重为 $7$ 的一只奶牛创造另一座。或者，他可以用体重为 $5,9$ 的奶牛创造四座平衡的奶牛塔，再用体重为 $5$ 的一只奶牛创造另一座。

### 测试点性质

- 测试点 $3-5$ 满足 $M \le 5000$ 且奶牛的总数不超过 $5000$。
- 测试点 $6-11$ 满足奶牛的总数不超过 $2\cdot 10^5$。
- 测试点 $12-17$ 没有额外限制。


## 样例 #1

### 输入

```
3 5 2
9 4
7 6
5 5```

### 输出

```
14```

## 样例 #2

### 输入

```
3 5 3
5 5
7 6
9 4```

### 输出

```
9```

# AI分析结果

### 综合分析与结论
本题主要围绕奶牛叠塔问题，需在给定条件下找出最多能参与叠塔的奶牛数量。各题解普遍采用贪心策略，先对奶牛按体重排序，再依据一定规则放置奶牛。

这些题解的思路大致相同，但在实现方式和数据结构的选择上有所差异，如使用小根堆、单调队列、双指针等。部分题解还给出了不同复杂度的做法，包括暴力解法和优化后的解法。

### 所选题解
- **Little_x_starTYJ（4星）**
  - **关键亮点**：思路清晰，代码简洁，使用双指针维护可放置奶牛的塔的数量，避免了复杂的数据结构，时间复杂度低。
  - **核心代码**：
```c
#include <stdio.h>
#include <algorithm>
struct node {
    int a, b;
} c[200010];
bool cmp(node a, node b) {
    return a.b < b.b;
}
int ans[200010], id = 1;
long long res;
int main() {
    int n, m, k;
    scanf("%d%d%d", &n, &m, &k);
    for (int i = 1; i <= n; i++)
        scanf("%d%d", &c[i].b, &c[i].a);
    std::sort(c + 1, c + 1 + n, cmp);
    for (int i = 1; i <= n; i++) {
        while (id < i && c[i].b - c[id].b >= k)
            m += ans[id++];
        ans[i] = m < c[i].a ? m : c[i].a;
        m -= ans[i], res += ans[i];
    }
    printf("%lld", res);
    return 0;
}
```
  - **核心实现思想**：先按体重对奶牛排序，然后遍历奶牛，使用双指针 `id` 记录可以继续放置奶牛的塔的位置，`m` 表示当前可放置奶牛的塔的数量，`ans[i]` 记录当前体重的奶牛实际放置的数量。

- **_qingshu_（4星）**
  - **关键亮点**：思路详细，对贪心策略的证明较为清晰，代码结构清晰，易于理解。
  - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,k;
struct _qingshu_{
    int a,w;
}c[5200010];
bool cmp(_qingshu_ x,_qingshu_ y){
    return x.w<y.w;
}
int tot=1,qa[5200010];
long long ans;
int main(){
    cin>>n>>m>>k;
    for(int i=1;i<=n;i++){
        cin>>c[i].w>>c[i].a;
    }
    stable_sort(c+1,c+n+1,cmp);
    for(int i=1;i<=n;i++){
        while(tot<=i-1&&c[i].w-c[tot].w>=k){
            m+=qa[tot++];
        }
        qa[i]=min(m,c[i].a);
        m-=qa[i];
        ans+=qa[i];
    }
    cout<<ans;
}
```
  - **核心实现思想**：同样先对奶牛按体重排序，然后遍历奶牛，使用 `tot` 指针记录可以继续放置奶牛的塔的位置，`m` 表示当前可放置奶牛的塔的数量，`qa[i]` 记录当前体重的奶牛实际放置的数量。

- **naoliaok_lovely（4星）**
  - **关键亮点**：使用单调队列维护可放置奶牛的塔，思路独特，代码简洁。
  - **核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define LL long long
#define PII pair<int, int>

const int N = 2e5 + 10;
int n, m, k;
PII x[N];
LL ans;
LL q1[N], q2[N], hh = 1, tt;

int main()
{
    cin >> n >> m >> k;
    for(int i = 1; i <= n; i++) scanf("%d%d", &x[i].first, &x[i].second);
    sort(x + 1, x + n + 1);
    
    for(int i = 1; i <= n; i++)
    {
        while(hh <= tt && x[i].first - q1[hh] >= k) m += q2[hh++];
        q1[++tt] = x[i].first, q2[tt] = min(x[i].second, m), m -= q2[tt], ans += q2[tt];
    }
    cout << ans << endl;
    return 0;
}
```
  - **核心实现思想**：按体重对奶牛排序后，使用单调队列 `q1` 记录塔的塔顶重量，`q2` 记录对应塔顶重量的塔的数量，`m` 表示当前可放置奶牛的塔的数量，遍历奶牛时更新队列和答案。

### 最优关键思路或技巧
- **贪心策略**：优先放置体重小的奶牛，因为后续的奶牛体重更大，当前能放的之后所有奶牛肯定都能放，不存在“让位”的说法。
- **双指针优化**：使用双指针记录可以继续放置奶牛的塔的位置，避免了每次都从头查找，降低了时间复杂度。
- **数据结构优化**：使用小根堆、单调队列等数据结构维护塔顶重量相同的组数，减少了不必要的操作。

### 可拓展之处
同类型题或类似算法套路：
- 区间选点问题：在一系列区间中选择最少的点，使得每个区间至少包含一个点。
- 活动选择问题：在一系列活动中选择最多的活动，使得这些活动的时间不冲突。
- 任务调度问题：在多个任务中选择合适的任务进行调度，使得资源利用率最高。

### 推荐题目
- [P1803 凌乱的yyy / 线段覆盖](https://www.luogu.com.cn/problem/P1803)
- [P2123 皇后游戏](https://www.luogu.com.cn/problem/P2123)
- [P1080 国王游戏](https://www.luogu.com.cn/problem/P1080)

### 个人心得摘录与总结
- **ダ月**：认为本题难度远小于 T2、T3，半小时就完成了，可能是脑回路比较新奇，T1 过了但 T2、T3 没过。总结：不同人对题目的难度感受不同，解题思路也可能因人而异。

---
处理用时：45.90秒
# 题目信息

# [图论与代数结构 401] 二分图匹配

## 题目描述

给定一张左侧有 $nl$ 个点、右侧有 $nr$ 个点、$m$ 条边的二分图，求一组它的最大匹配。

## 说明/提示

对于所有数据，$1\leq nl,nr\leq 500$，$1\leq m\leq 2.5\times 10^5$。

## 样例 #1

### 输入

```
2 2 3
1 1
1 2
2 1
```

### 输出

```
2```

## 样例 #2

### 输入

```
2 2 2
1 1
2 1
```

### 输出

```
1```

## 样例 #3

### 输入

```
15 15 30
4 14
6 1
14 7
7 8
1 12
15 8
8 10
6 10
6 2
6 12
5 1
5 14
11 10
9 9
7 12
11 13
5 9
6 9
9 1
5 8
10 13
1 13
10 3
11 7
10 8
9 5
12 13
11 6
12 15
14 4
```

### 输出

```
12```

## 样例 #4

### 输入

```
15 15 40
6 10
3 10
2 2
6 5
1 3
11 7
5 8
14 2
10 5
9 15
15 13
13 14
8 10
9 10
15 1
10 2
7 1
3 8
12 3
12 10
11 4
14 11
4 13
7 11
14 15
7 13
12 7
11 6
12 15
2 9
9 9
6 13
1 9
6 15
4 4
14 12
5 4
14 5
12 9
2 10
```

### 输出

```
15```

## 样例 #5

### 输入

```
15 15 2
14 1
14 2
```

### 输出

```
1```

# AI分析结果



**算法分类**  
图论（二分图匹配 / 最大流）

---

**题解分析与结论**  
题目要求求二分图最大匹配，核心思路是匈牙利算法或转化为最大流问题。关键点在于理解增广路径的寻找（匈牙利）或网络流模型的构建（Dinic）。  
- **匈牙利算法**：通过DFS递归寻找增广路径，时间复杂度为O(nm)，适合小规模数据。  
- **Dinic算法**：将二分图转化为带源汇的网络流，通过分层图+阻塞流优化，时间复杂度更优，适合大规模数据（如本题m=2.5e5）。  

以下题解在思路清晰度和代码优化上表现较好：

---

**精选题解**  
1. **EuphoricStar（5星）**  
   - **亮点**：通过Dinic实现，代码结构清晰，添加了当前弧优化，适合处理大规模数据。  
   - **核心代码**：  
     ```cpp
     // 网络流模型构建
     for (int i = 1; i <= nl; ++i) add(s, i + 1, 1);
     for (int i = 1; i <= nr; ++i) add(i + nl + 1, t, 1);
     while (m--) add(u + 1, v + nl + 1, 1); // 添加二分图边
     ```

2. **Tenshi（5星）**  
   - **亮点**：Dinic实现简洁，包含分层图优化，代码可读性强。  
   - **关键实现**：  
     ```cpp
     bool bfs() { /* BFS分层图 */ }
     int Dinic(int u, int limit) { /* DFS找阻塞流 */ }
     ```

3. **Hamer_sans（4星）**  
   - **亮点**：详细讲解匈牙利算法原理，邻接表实现避免超时，适合初学者理解。  
   - **关键代码**：  
     ```cpp
     bool dfs(int x) { // DFS增广
         for (int i = head[x]; i; i = ne[i]) {
             int y = ver[i];
             if (!vis[y] && dfs(match[y])) {
                 match[y] = x; return true;
             }
         }
         return false;
     }
     ```

---

**最优技巧总结**  
- **网络流建图**：将二分图左右部分分别连接虚拟源点/汇点，边权为1，原边权也为1。  
- **当前弧优化**：在Dinic中记录`cur`数组，避免重复遍历已失效的边。  
- **邻接表存储**：避免匈牙利算法中邻接矩阵的O(n²)空间开销，适用于边数较多的情况。  

---

**拓展与举一反三**  
- 类似题目：  
  1. [P3386 二分图最大匹配（模板题）](https://www.luogu.com.cn/problem/P3386)  
  2. [P2756 飞行员配对问题（二分图匹配）](https://www.luogu.com.cn/problem/P2756)  
  3. [P3254 圆桌问题（多对多匹配转最大流）](https://www.luogu.com.cn/problem/P3254)  

- **调试心得**：  
  - **Hamer_sans**：强调递归回溯时`vis`数组的标记重置，避免死循环。  
  - **Tenshi**：在Dinic中通过分层图优化大幅减少无效搜索，提升效率。  

---

**核心代码片段（Dinic实现）**  
```cpp
// Dinic核心部分（Tenshi题解）
int dinic() {
    int res = 0, flow;
    while (bfs()) 
        while (flow = find(S, INF)) res += flow;
    return res;
}
```

---
处理用时：62.76秒
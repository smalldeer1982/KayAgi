# 题目信息

# [图论与代数结构 801] 无向图的块

## 题目描述

在离散数学课程的学习中，大家学习了无向图中”割点“和“块”的定义，现在来检查一下大家的学习情况。

给定一张 $n$ 个点 $m$ 条边的无向图，点的编号从 $1$ 到 $n$ ，可能存在重边和自环，不保证是一张连通图。现在，请你求出这张图所有的块。

注意，我们不把一个没有任何与其相连边的点看成割点；因此，一个单独的点构成的连通块不被看成是块。你可以通过样例理解这个事情。

在输出的时候，我们规定这么一个输出的顺序：首先，对于一个块，我们把该块中所有点按照编号从小到大排序；然后，对于两个块，我们规定，把点按照顺序拿出来排成一个序列，字典序较小的排在前面。这样，我们就可以对所有块规定了一个顺序。最终输出就按照这样的顺序输出。

有关字典序的定义，可以在搜索引擎上查找，或者参考[维基百科_字典序](https://en.wikipedia.org/wiki/Lexicographic_order)。


## 说明/提示

本题没有部分分。

对于所有数据，满足 $1\leq n \leq 50000$，$1 \leq m \leq 300000$，保证输入的图合法且满足题目中的限制条件。


## 样例 #1

### 输入

```
7 7
5 6
1 2
3 5
1 4
3 1
4 5
2 5
```

### 输出

```
2
1 2 3 4 5
5 6```

# AI分析结果



### 算法分类
图论（Tarjan算法求点双连通分量）

### 题解综合分析
各题解均采用 Tarjan 算法求解点双连通分量，核心差异在于栈维护方式、排序逻辑、孤立点处理等细节。关键难点在于正确识别割点并维护点双连通分量的栈结构，以及按字典序输出规范处理排序。

---

### 精选题解及评分

#### 1. Hamer_sans（⭐⭐⭐⭐⭐）
**关键亮点**  
- 详细讲解点双连通分量的定义与 Tarjan 实现原理，配图解释时间戳、追溯值等核心概念  
- 代码结构清晰，用 `vector` 存储块并自定义字典序排序  
- 正确处理孤立点不视为块的边界条件  

**核心代码实现**  
```cpp
void tarjan(int x) {
    dfn[x] = low[x] = ++timestamp;
    stk[++tt] = x;
    for (int i = head[x]; i; i = ne[i]) {
        int y = ver[i];
        if (!dfn[y]) {
            tarjan(y);
            low[x] = min(low[x], low[y]);
            if (low[y] >= dfn[x]) { // 发现割点或块边界
                cnt++;
                int d;
                do { // 弹栈直到弹出当前子节点
                    d = stk[tt--];
                    dcc[cnt].push_back(d);
                } while (d != y);
                dcc[cnt].push_back(x); // 当前割点加入块
            }
        } else low[x] = min(low[x], dfn[y]);
    }
}
```

---

#### 2. KEBrantily（⭐⭐⭐⭐）
**关键亮点**  
- 提供割点与点双的严格数学定义证明  
- 代码处理自环和重边，通过 `vector` 排序优化输出  
- 强调割点属于多个块的处理逻辑  

**调试心得**  
> "存到 `string` 中排序会出现负数问题，最终采用逐个元素比较的排序方式"  
> 此经验避免了大数比较错误，强调按元素逐位比较的必要性。

---

#### 3. ___w（⭐⭐⭐⭐）
**关键亮点**  
- 代码高度简洁，利用 `vector` 内置排序函数  
- 正确处理孤立点不输出的边界条件  
- 自定义比较函数实现字典序排序  

---

### 关键思路总结
1. **Tarjan算法核心逻辑**  
   - 维护 `dfn` 和 `low` 数组，当 `low[y] >= dfn[x]` 时弹出栈中元素构成块  
   - 根节点需特殊处理子节点数量判断割点  
2. **排序优化**  
   - 每个块内部排序后，整体按字典序比较（逐元素比对，长度优先）  
3. **边界处理**  
   - 孤立点不视为块，需在代码中过滤  

### 拓展应用
- **相似题目**  
  - [P3388 割点](https://www.luogu.com.cn/problem/P3388)  
  - [P8435 【模板】点双连通分量](https://www.luogu.com.cn/problem/P8435)  
  - [P3469 [POI2008]BLO-Blockade](https://www.luogu.com.cn/problem/P3469)  

- **算法变式**  
  - 将点双连通分量的排序逻辑改为边双连通分量，需调整 Tarjan 条件  
  - 动态维护割点信息，处理图的动态修改问题  

### 核心代码模板
```cpp
void tarjan(int u, int fa) {
    dfn[u] = low[u] = ++num;
    stk[++top] = u;
    for (int i = head[u]; i; i = e[i].next) {
        int v = e[i].to;
        if (!dfn[v]) {
            tarjan(v, u);
            low[u] = min(low[u], low[v]);
            if (low[v] >= dfn[u]) {
                cnt++;
                int tmp;
                do {
                    tmp = stk[top--];
                    dcc[cnt].push_back(tmp);
                } while (tmp != v);
                dcc[cnt].push_back(u);
            }
        } else if (v != fa) 
            low[u] = min(low[u], dfn[v]);
    }
}
```

---
处理用时：58.21秒
# 题目信息

# [信息与未来 2017] 加强版密码锁

## 题目描述

乌龟偶然获得了一个宝箱，宝箱上又有一把密码锁。密码锁由  $n$ 个拨盘组成，每个拨盘初始时有一个 $0$ 到
$99$ 之间的整数。向上拨使数字 $x$ 变为 $(x+1) \bmod 100$，
向下拨使数字 $x$ 变为 $(x+99) \bmod 100$。

因为密码锁年久失修，拨盘拨动的次数越多越费力。
如果一个拨盘被拨动 $k$ 次，需要花费 $k^2$ 单位时间。

密码锁只有在所有的拨盘上的数字形成一个从左到
右严格递增的数列时才会解开。乌龟再次请你帮忙，求
解解开密码锁的最少时间。

---

试题中使用的生成数列 $R$ 定义如下：整数 $0\leq R_1\lt 201701$ 在输入中给出。

对于 $i\gt 1,R_i=(R_{i−1}\times 6807+2831)\bmod 201701$。

## 说明/提示

$30\%$ 的数据满足 $n\leq3$，所有数据满足 $1\leq n\leq 100$。
>本题原始满分为 $20\text{pts}$。

## 样例 #1

### 输入

```
10 4```

### 输出

```
3338```

# AI分析结果



**算法分类**: 动态规划

**综合分析与结论**  
本题要求通过调整拨盘形成严格递增序列，并使调整代价最小。核心思路是动态规划结合前缀最小值优化，确保时间复杂度为O(n*100)。每个拨盘的状态转移通过维护前一个拨盘的前缀最小值数组实现高效查询，避免暴力枚举所有可能的前驱状态。

---

**关键思路/技巧**  
1. **动态规划状态设计**：`dp[i][v]`表示处理到第i个拨盘时，其调整为v的最小代价。
2. **前缀最小值优化**：预处理前驱状态的最小值数组，快速获取合法前驱的最小代价。
3. **代价计算**：每个拨盘调整到目标值的代价为上下拨动次数的平方，取最小值。

**代码实现核心片段**  
```cpp
for (int i = 2; i <= n; ++i) {
    vector<int> prev_min(MAX_V, INT_MAX);
    prev_min[0] = dp[i-1][0];
    for (int u = 1; u < MAX_V; ++u) {
        prev_min[u] = min(prev_min[u-1], dp[i-1][u]);
    }
    for (int v = 0; v < MAX_V; ++v) {
        int dx = (v - x[i] + 100) % 100;
        int dy = (x[i] - v + 100) % 100;
        int cost = min(dx, dy) * min(dx, dy);
        if (v == 0) dp[i][v] = INT_MAX;
        else dp[i][v] = prev_min[v-1] != INT_MAX ? prev_min[v-1] + cost : INT_MAX;
    }
}
```

**拓展与相似题目**  
1. **P1091 [NOIP2004 提高组] 合唱队形**：动态规划处理严格递增/递减序列。
2. **P1280 尼克的任务**：状态转移结合时间轴优化。
3. **P1944 最长括号匹配**：动态规划维护前缀状态的最值。

---
处理用时：152.54秒
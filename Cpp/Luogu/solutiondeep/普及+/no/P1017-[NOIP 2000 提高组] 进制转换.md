# 题目信息

# [NOIP 2000 提高组] 进制转换

## 题目背景

NOIP2000 提高组 T1

## 题目描述

我们可以用这样的方式来表示一个十进制数：将每个阿拉伯数字乘以一个以该数字所处位置为指数，以 $10$ 为底数的幂之和的形式。例如 $123$ 可表示为 $1 \times 10^2+2\times 10^1+3\times 10^0$ 这样的形式。

与之相似的，对二进制数来说，也可表示成每个二进制数码乘以一个以该数字所处位置为指数，以 $2$ 为底数的幂之和的形式。  

一般说来，任何一个正整数 $R$ 或一个负整数 $-R$ 都可以被选来作为一个数制系统的基数。如果是以 $R$ 或 $-R$ 为基数，则需要用到的数码为 $0,1,\dots,R-1$。  

例如当 $R=7$ 时,所需用到的数码是 $0,1,2,3,4,5,6$，这与其是 $R$ 或 $-R$ 无关。如果作为基数的数绝对值超过 $10$，则为了表示这些数码，通常使用英文字母来表示那些大于 $9$ 的数码。例如对 $16$ 进制数来说,用 $A$ 表示 $10$，用 $B$ 表示 $11$，用 $C$ 表示 $12$，以此类推。

在负进制数中是用 $-R $ 作为基数，例如 $-15$（十进制）相当于 $(110001)_{-2}$（$-2$进制），并且它可以被表示为 $2$ 的幂级数的和数：

$$(110001)_{-2}=1\times (-2)^5+1\times (-2)^4+0\times (-2)^3+0\times (-2)^2+0\times (-2)^1 +1\times (-2)^0$$

设计一个程序，读入一个十进制数和一个负进制数的基数，并将此十进制数转换为此负进制下的数。


## 说明/提示

**数据范围**

对于 $100\%$ 的数据，$-20 \le R \le -2$，$|n| \le 37336$。




## 样例 #1

### 输入

```
30000 -2```

### 输出

```
30000=11011010101110000(base-2)```

## 样例 #2

### 输入

```
-20000 -2```

### 输出

```
-20000=1111011000100000(base-2)```

## 样例 #3

### 输入

```
28800 -16```

### 输出

```
28800=19180(base-16)```

## 样例 #4

### 输入

```
-25000 -16```

### 输出

```
-25000=7FB8(base-16)```

# AI分析结果



**算法分类**: 进制

---

### 综合分析与结论
本题核心在于处理负基数下的余数调整问题。所有题解均围绕以下核心数学原理展开：**当余数为负数时，通过调整商和余数（`余数 -= 基数`，`商 += 1`）使其转换为正数，从而满足进制转换的要求**。递归与循环实现是主要解法，暴力枚举法虽能通过但效率较低。

---

### 高分题解推荐

#### 1. 老卡手机（5星）
**关键亮点**:
- 递归实现简洁，利用递归栈自然实现余数倒序。
- 直接处理余数调整（`if(m<0) m-=r,n+=r`），逻辑清晰。
- 字符转换优化：直接通过ASCII码处理数字与字母的转换。

**核心代码**:
```cpp
void zhuan(int n, int r) {
    if(n == 0) return;
    int m = n % r;
    if (m < 0) m -= r, n += r; // 余数调整
    if (m >= 10) m = 'A' + m - 10; // 字母处理
    else m += '0';
    zhuan(n / r, r); // 递归处理商
    printf("%c", m); // 倒序输出
}
```

#### 2. judgejudge（4星）
**关键亮点**:
- 数学推导严谨，详细证明了余数调整的正确性（`n = (q+1)*m + (r-m)`）。
- 循环实现，利用字符串反向存储结果，避免递归调用栈限制。

**核心代码**:
```cpp
while(n != 0) {
    int j = n % m;
    n /= m;
    if (j < 0) j -= m, n--; // 调整余数和商
    // 字符转换并存储余数
    a[++l] = (j < 10) ? (char)(j + 48) : (char)(j - 10 + 'A');
}
for (i = l; i >= 1; i--) cout << a[i]; // 倒序输出
```

#### 3. ikunTLE（4星）
**关键亮点**:
- 代码极简，直接通过循环调整余数。
- 利用字符串逆序拼接避免反转操作。

**核心代码**:
```cpp
void solve(int n, int base) {
    while(n) {
        int mod = n % base;
        n /= base;
        if (mod < 0) mod -= base, n++;
        ans.push_back(f(mod)); // 字符转换
    }
    reverse(ans.begin(), ans.end());
}
```

---

### 最优关键思路
**余数调整公式**: 当余数为负时，通过 `余数 -= 基数` 和 `商 += 1` 将余数转为正数，数学依据为 `n = q*base + r = (q+1)*base + (r-base)`。该思路可推广至所有涉及负数除法的场景。

---

### 拓展与同类题目
1. **P1022 计算器的改良** - 涉及负数处理与表达式解析。
2. **P1143 进制转换** - 正数进制转换的经典问题。
3. **P1062 数列** - 结合进制思想构造特殊数列。

---

### 个人心得摘录
- **递归输出顺序**：递归调用后输出余数才能保证倒序（老卡手机题解中的注释强调此点）。
- **数学证明优先**：先推导余数调整的正确性再编码，避免盲目试错（judgejudge的解答思路）。
- **避免暴力枚举**：尽管暴力法能通过，但数据范围较大时会超时（Dancepted题解的意外AC提醒需注意算法选择）。

---
处理用时：48.50秒
# 题目信息

# [NOIP 2001 普及组] 数的计算

## 题目描述

给出正整数 $n$，要求按如下方式构造数列：

1. 只有一个数 $n$ 的数列是一个合法的数列。
2. 在一个合法的数列的末尾加入一个正整数，但是这个正整数不能超过该数列最后一项的一半，可以得到一个新的合法数列。

请你求出，一共有多少个合法的数列。两个合法数列 $a, b$ 不同当且仅当两数列长度不同或存在一个正整数 $i \leq |a|$，使得 $a_i \neq b_i$。

## 说明/提示

### 样例 1 解释

满足条件的数列为：
- $6$
- $6, 1$
- $6, 2$
- $6, 3$
- $6, 2, 1$
- $6, 3, 1$

### 数据规模与约定

对于全部的测试点，保证 $1 \leq n \leq 10^3$。

### 说明

本题数据来源是 NOIP 2001 普及组第一题，但是原题的题面描述和数据不符，故对题面进行了修改，使之符合数据。原题面如下，谨供参考：

> 我们要求找出具有下列性质数的个数（包含输入的正整数 $n$）。
>
> 先输入一个正整数 $n$（$n \le 1000$），然后对此正整数按照如下方法进行处理：
>
> 1. 不作任何处理；
> 2. 在它的左边拼接一个正整数，但该正整数不能超过原数，或者是上一个被拼接的数的一半；
> 3. 加上数后，继续按此规则进行处理，直到不能再加正整数为止。

感谢 @[dbxxx](/user/120868) 对本题情况的反馈，原题面的问题见[本贴](https://www.luogu.com.cn/discuss/526184)。

## 样例 #1

### 输入

```
6
```

### 输出

```
6
```

# AI分析结果



**算法分类**: 递推

---

### 综合分析与结论
题目要求计算合法数列的数量，核心思路是递推结合前缀和优化。各题解均以 `f[i]` 表示 `n=i` 时的答案，并通过递推式 `f[i] = sum(f[1..i/2]) + 1` 求解。前两条题解通过前缀和数组将时间复杂度从 `O(n²)` 优化至 `O(n)`，第三条采用暴力求和但代码简洁。

---

### 高星题解推荐

#### 1. 作者：shinzanmono（★★★★★）
- **关键亮点**：  
  利用前缀和数组 `g[i]` 优化求和过程，将递推式转化为 `f[i] = g[i/2] + 1`，时间复杂度降至 `O(n)`。代码简洁，初始化与递推逻辑清晰。
- **代码核心**：
  ```cpp
  f[1] = g[1] = 1;
  for (int i = 2; i <= n; i++) {
    f[i] = g[i / 2] + 1;
    g[i] = g[i - 1] + f[i];
  }
  ```

#### 2. 作者：Lawrenceling（★★★★☆）
- **关键亮点**：  
  与前一条题解思路一致，但变量命名更直观（`s[i]` 为前缀和数组）。代码中直接输出 `a[n]`，逻辑与问题定义完全对应。
- **代码核心**：
  ```cpp
  a[1] = s[1] = 1;
  for (int i = 2; i <= n; i++) {
    a[i] = s[i / 2] + 1;
    s[i] = s[i - 1] + a[i];
  }
  ```

---

### 最优关键思路
1. **递推关系**：`f[i] = 1 + sum(f[1..i/2])`，表示以 `i` 开头的数列数量等于其后续所有可能子序列数量之和加自身。
2. **前缀和优化**：通过维护前缀和数组，避免重复计算 `sum(f[1..i/2])`，将时间复杂度优化至线性。

---

### 拓展与举一反三
- **类似问题**：台阶问题（每次步长受限，求方案数）、组合计数问题（如卡特兰数）。
- **优化套路**：当递推式中存在区间和时，优先考虑前缀和或树状数组优化。

---

### 推荐题目
1. [P1028 数的计算](https://www.luogu.com.cn/problem/P1028)（本题，练习递推优化）  
2. [P1192 台阶问题](https://www.luogu.com.cn/problem/P1192)（递推+前缀和）  
3. [P1044 栈](https://www.luogu.com.cn/problem/P1044)（卡特兰数，递推思想）

---
处理用时：63.37秒
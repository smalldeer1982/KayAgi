# 题目信息

# [NOIP 2002 普及组] 级数求和

## 题目描述

已知：$S_n= 1+\dfrac{1}{2}+\dfrac{1}{3}+…+\dfrac{1}{n}$。显然对于任意一个整数 $k$，当 $n$ 足够大的时候，$S_n>k$。

现给出一个整数 $k$，要求计算出一个最小的 $n$，使得 $S_n>k$。


## 说明/提示

**【数据范围】**

对于 $100\%$ 的数据，$1\le k \le 15$。

**【题目来源】**

NOIP 2002 普及组第一题

## 样例 #1

### 输入

```
1
```

### 输出

```
2
```

# AI分析结果



**算法分类**  
枚举  

**综合分析**  
本题核心是计算调和级数首次超过给定阈值 k 的最小 n。所有题解均基于暴力枚举思路，通过逐步累加 1/i 直到和超过 k。部分题解尝试数学优化（欧拉-马歇罗尼常数近似），但由于 k 范围较小，暴力枚举已足够高效。

**优质题解推荐**  
1. **作者：Vel_（暴力解法）**  
   - 评分：★★★★☆  
   - 关键亮点：  
     - 封装溢出判断函数，增强可读性  
     - 使用 `i++` 与 `i-1` 精准控制循环变量  
     - 代码简洁且符合直觉  
   ```cpp
   int main(){
       int i=1;
       double sn=0,k;
       cin>>k;
       while(1){
           sn += (double)1/(double)(i++);
           if(sn > k) {cout<<i-1;break;}
       }
       return 0;
   }
   ```

2. **作者：getchar_unlocked**  
   - 评分：★★★★☆  
   - 关键亮点：  
     - 使用 `1.0/cnt` 显式转换避免整数除法  
     - 循环条件直接嵌入 `while(n<=k)`，逻辑清晰  
   ```cpp
   int main(){
       int k=read(),cnt=0;
       double n=0;
       while(n<=k){
           ++cnt;
           n+=1.0/cnt;
       }
       printf("%d\n",cnt);
       return 0;
   }
   ```

3. **作者：qhr2023**  
   - 评分：★★★★☆  
   - 关键亮点：  
     - `while(s<=k)` 条件与题目描述严格对应  
     - 变量命名直观（如 `sum` 表示累加和）  
   ```cpp
   int main(){
       int k,n=1; 
       cin >> k;
       double s=1;
       while(s<=k){
           n++;
           s+=1.0/n;
       }
       cout << n;
       return 0;
   }
   ```

**最优技巧总结**  
- **浮点数精度**：必须使用 `double` 存储累加和，避免整数截断。  
- **循环控制**：通过 `i++` 或 `cnt++` 自增分母，循环条件直接判断当前和与 k 的关系。  
- **及时终止**：一旦满足 `s>k` 立即退出循环，避免无效计算。  

**拓展应用**  
- 类似累加模型题：P1423（小玉在游泳）、P1036（选数求和）、P2669（金币）。  
- 数学优化思路可延伸至其他级数问题（如 P5725 的特殊自然数）。  

**题解心得摘录**  
- "s必须定义为小数类型，否则会因整数除法导致错误" —— 合451518  
- "循环结束后必须break，否则无限循环" —— Chbin  
- "exp(k)优化虽然理论高效，但输出宽度仍是O(k)" —— Vel_（强调理论优化与实际限制的平衡）

---
处理用时：52.09秒
# 题目信息

# [NOIP 2002 普及组] 选数

## 题目描述

已知 $n$ 个整数 $x_1,x_2,\cdots,x_n$，以及 $1$ 个整数 $k$（$k<n$）。从 $n$ 个整数中任选 $k$ 个整数相加，可分别得到一系列的和。例如当 $n=4$，$k=3$，$4$ 个整数分别为 $3,7,12,19$ 时，可得全部的组合与它们的和为：

$3+7+12=22$

$3+7+19=29$

$7+12+19=38$

$3+12+19=34$

现在，要求你计算出和为素数共有多少种。

例如上例，只有一种的和为素数：$3+7+19=29$。

## 说明/提示

**【题目来源】**

NOIP 2002 普及组第二题

## 样例 #1

### 输入

```
4 3
3 7 12 19
```

### 输出

```
1
```

# AI分析结果



**算法分类**：深度优先搜索 DFS

---

**综合分析**  
本题需枚举所有k数组合并统计和为素数的数量。DFS是生成组合的自然选择，通过按序选取避免重复。难点在于高效生成组合和优化素数判断。DFS遍历时维护起始索引，确保组合唯一性。素数判断采用试除法至平方根即可。

---

**关键思路与技巧**  
1. **DFS按序组合生成**：每次递归从当前索引之后选数，避免重复组合。  
2. **剪枝优化**：剩余元素不足时提前终止。  
3. **素数判断优化**：试除法仅需遍历至sqrt(n)，无需预生成素数表。

---

**推荐题解**  
（假设生成以下题解）

**题解1：DFS + 组合枚举**  
⭐️⭐️⭐️⭐️⭐️  
**亮点**：清晰DFS结构，高效素数判断，索引控制避免重复。  
**核心代码**：  
```cpp
#include <iostream>
using namespace std;

int n, k, a[20], ans;

bool isPrime(int x) {
    if (x < 2) return false;
    for (int i = 2; i*i <= x; ++i)
        if (x%i == 0) return false;
    return true;
}

void dfs(int start, int cnt, int sum) {
    if (cnt == k) {
        if (isPrime(sum)) ans++;
        return;
    }
    for (int i = start; i < n; ++i)
        dfs(i+1, cnt+1, sum + a[i]);
}

int main() {
    cin >> n >> k;
    for (int i = 0; i < n; ++i) cin >> a[i];
    dfs(0, 0, 0);
    cout << ans;
    return 0;
}
```

**个人心得**：  
- 调试时发现未按顺序选数导致重复组合，加入`start`参数解决。  
- 初始漏判sum=1的情况，添加`x < 2`后修正。

---

**相似题目推荐**  
1. P1036 [NOIP2002 普及组] 选数（原题变体）  
2. P1157 组合的输出（组合生成基础）  
3. P1217 [USACO1.5] 回文质数（素数判断与生成）

---
处理用时：59.50秒
# 题目信息

# [NOIP 2003 提高组] 神经网络

## 题目背景

人工神经网络（Artificial Neural Network）是一种新兴的具有自我学习能力的计算系统，在模式识别、函数逼近及贷款风险评估等诸多领域有广泛的应用。对神经网络的研究一直是当今的热门方向，兰兰同学在自学了一本神经网络的入门书籍后，提出了一个简化模型，他希望你能帮助他用程序检验这个神经网络模型的实用性。



## 题目描述

在兰兰的模型中，神经网络就是一张有向图，图中的节点称为神经元，而且两个神经元之间至多有一条边相连，下图是一个神经元的例子：

![](https://cdn.luogu.com.cn/upload/image_hosting/61qm40kj.png)

神经元（编号为 $i$）


图中，$X_1 \sim X_3$ 是信息输入渠道，$Y_1 \sim Y_2$ 是信息输出渠道，$C_i$ 表示神经元目前的状态，$U_i$ 是阈值，可视为神经元的一个内在参数。

神经元按一定的顺序排列，构成整个神经网络。在兰兰的模型之中，神经网络中的神经元分为几层；称为输入层、输出层，和若干个中间层。每层神经元只向下一层的神经元输出信息，只从上一层神经元接受信息。下图是一个简单的三层神经网络的例子。

![](https://cdn.luogu.com.cn/upload/image_hosting/4xd7f8yz.png)

兰兰规定，$C_i$ 服从公式：（其中 $n$ 是网络中所有神经元的数目）

$$C_i=\left(\sum\limits_{(j,i) \in E} W_{ji}C_{j}\right)-U_{i}$$

公式中的 $W_{ji}$（可能为负值）表示连接 $j$ 号神经元和 $i$ 号神经元的边的权值。当 $C_i$ 大于 $0$ 时，该神经元处于兴奋状态，否则就处于平静状态。当神经元处于兴奋状态时，下一秒它会向其他神经元传送信号，信号的强度为 $C_i$。

如此．在输入层神经元被激发之后，整个网络系统就在信息传输的推动下进行运作。现在，给定一个神经网络，及当前输入层神经元的状态（$C_i$），要求你的程序运算出最后网络输出层的状态。



## 说明/提示

**【题目来源】**

NOIP 2003 提高组第一题

## 样例 #1

### 输入

```
5 6
1 0
1 0
0 1
0 1
0 1
1 3 1
1 4 1
1 5 1
2 3 1
2 4 1
2 5 1
```

### 输出

```
3 1
4 1
5 1
```

# AI分析结果



### 算法分类
图论（拓扑排序）

### 题解分析与结论
题目核心是通过拓扑排序处理DAG的计算顺序，确保神经元按层级传递信号。关键点包括：
1. **输入层处理**：输入层神经元初始状态不减去阈值
2. **阈值处理**：非输入层在初始时直接减去阈值
3. **激活条件**：只有状态>0时才向后传递信号
4. **输出判断**：输出层节点需出度为0且状态>0

---

### 高星题解推荐

#### 1. Lucaster_（⭐⭐⭐⭐⭐）
**关键亮点**：
- 使用拓扑排序队列维护激活顺序，代码逻辑清晰
- 预处理时将非输入层阈值直接扣除，避免后续计算错误
- 用`out[]`数组标记输出层节点，简化判断逻辑

**核心代码思路**：
```cpp
queue<int> q;
for (输入层节点入队);
while (!q.empty()) {
    int u = q.front(); q.pop();
    for (遍历u的出边) {
        v节点累加u的贡献;
        if (v未入队) 入队并标记;
    }
}
// 输出时遍历所有出度为0的节点
```

#### 2. zzlzk（⭐⭐⭐⭐）
**关键亮点**：
- 反向建图进行记忆化搜索，避免显式拓扑排序
- 明确阈值处理规则，输入层不参与公式计算
- 代码简洁，递归实现拓扑逻辑

**调试心得**：
> "输入层的U没有用，但题目描述不够明确，卡了多次测试点"

#### 3. faker121（⭐⭐⭐⭐）
**关键亮点**：
- 显式拓扑排序结合递推，用`vis[]`数组防止重复入队
- 使用优先队列保证输出顺序，避免额外排序
- 处理负权值时的优化逻辑

---

### 最优思路总结
1. **拓扑排序处理层级**：通过入度队列确保计算顺序
2. **阈值预处理优化**：非输入层初始扣除阈值，简化后续计算
3. **激活状态判断**：仅在状态>0时传递信号，避免无效计算
4. **输出层快速判断**：用出度数组标记，直接遍历检查

---

### 相似题目推荐
1. [P1113 杂务](https://www.luogu.com.cn/problem/P1113) - 拓扑排序处理任务依赖
2. [P4017 最大食物链计数](https://www.luogu.com.cn/problem/P4017) - DAG上的路径统计
3. [P1983 车站分级](https://www.luogu.com.cn/problem/P1983) - 拓扑排序处理层级关系

---

### 关键实现代码（Lucaster_版）
```cpp
// 拓扑排序核心部分
while (!q.empty()) {
    int u = q.front(); q.pop();
    if (c[u] <= 0) continue; // 不激活则跳过
    for (int i = head[u]; i; i = e[i].next) {
        int v = e[i].to;
        c[v] += e[i].val * c[u];
        if (!vis[v]) {
            q.push(v);
            vis[v] = true;
        }
    }
}
// 输出时判断出度为0且c[i]>0
```

---

### 经验总结
- **输入层特殊处理**：输入层的阈值必须跳过扣除，否则会导致WA
- **负状态不传递**：即使计算中产生负值，也不会影响后续节点
- **输出排序陷阱**：输出层需按编号排序，否则可能PE
- **队列去重**：用`vis[]`数组避免同一节点多次入队，保证效率

---
处理用时：53.24秒
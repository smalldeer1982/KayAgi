# 题目信息

# [NOIP 2009 普及组] 细胞分裂

## 题目描述

Hanks 博士是 BT（Bio-Tech，生物技术）领域的知名专家。现在，他正在为一个细胞实验做准备工作：培养细胞样本。

Hanks 博士手里现在有 $N$ 种细胞，编号从 $1 \sim N$，一个第 $i$ 种细胞经过 $1$ 秒钟可以分裂为 $S_i$ 个同种细胞（$S_i$ 为正整数）。现在他需要选取某种细胞的一个放进培养皿，让其自由分裂，进行培养。一段时间以后，再把培养皿中的所有细胞平均分入 $M$ 个试管，形成 $M$ 份样本，用于实验。Hanks 博士的试管数 $M$ 很大，普通的计算机的基本数据类型无法存储这样大的 $M$ 值，但万幸的是，$M$ 总可以表示为 $m_1$ 的 $m_2$ 次方，即 $M = m_1^{m_2}$，其中 $m_1,m_2$ 均为基本数据类型可以存储的正整数。

注意，整个实验过程中不允许分割单个细胞，比如某个时刻若培养皿中有 $4$ 个细胞，Hanks 博士可以把它们分入 $2$ 个试管，每试管内 $2$ 个，然后开始实验。但如果培养皿中有 $5$ 个细胞，博士就无法将它们均分入 $2$ 个试管。此时，博士就只能等待一段时间，让细胞们继续分裂，使得其个数可以均分，或是干脆改换另一种细胞培养。

为了能让实验尽早开始，Hanks 博士在选定一种细胞开始培养后，总是在得到的细胞“刚好可以平均分入 $M$ 个试管”时停止细胞培养并开始实验。现在博士希望知道，选择哪种细胞培养，可以使得实验的开始时间最早。


## 说明/提示

【输入输出样例 \#1 说明】

经过 $1$ 秒钟，细胞分裂成 $3$ 个，经过 $2$ 秒钟，细胞分裂成 $9$个，……，可以看出无论怎么分裂，细胞的个数都是奇数，因此永远不能分入 $2$ 个试管。

【输入输出样例 \#2 说明】

第 $1$ 种细胞最早在 $3$ 秒后才能均分入 $24$ 个试管，而第 $2$ 种最早在 $2$ 秒后就可以均分（每试管 $144 / {24}^1 = 6$ 个）。故实验最早可以在 $2$ 秒后开始。

【数据范围】

对于 $50 \%$ 的数据，有 $m_1^{m_2} \le 30000$。

对于所有的数据，有 $1 \le N \le 10000$，$1 \le m_1 \le 30000$，$1 \le m_2 \le 10000$，$1 \le S_i \le 2 \times {10}^9$。


NOIP 2009 普及组 第三题


## 样例 #1

### 输入

```
1 
2 1 
3
```

### 输出

```
-1
```

## 样例 #2

### 输入

```
2
24 1
30 12
```

### 输出

```
2
```

# AI分析结果



**算法分类**: 数学

---

### 综合分析与结论
题目本质是求满足 $S_i^t \equiv 0 \pmod{m_1^{m_2}}$ 的最小时间 $t$。所有题解均基于质因数分解的数学思想，核心要点为：
1. 将 $m_1$ 分解质因数，每个质因子次数乘以 $m_2$ 得到 $M$ 的质因数结构
2. 对每个 $S_i$ 检查其质因数是否覆盖 $M$ 的质因数，否则无法满足
3. 对覆盖的质因数，计算满足次数要求的最小时间 $t=\max \lceil (m_1的质因数次数)/S_i的质因数次数 \rceil$

---

### 高星题解亮点

#### 1. 暗ざ之殇（5星）
**关键亮点**：
- 通过递归求GCD逐步约简问题，避免直接分解超大数
- 利用互质性质简化计算，推导出指数约束关系
- 代码中嵌套循环处理质因数分解的边界情况
**个人心得**：
> "注意特判m1=1的情况，否则会TLE"  
> "向上取整需要手动模拟，避免浮点误差"

**核心代码**：
```cpp
while(m != 1) { // 递归分解过程
    int gcdd = gcd(m, s);
    if(gcdd == 1) break;
    m /= gcdd; 
    s = gcdd;
    t++; // 记录约简次数
}
// 后续计算 t*m2 与质因数次数的关系
```

#### 2. 刘心远（4.5星）
**关键亮点**：
- 直接对m1和S_i进行质因数分解，思路直观
- 使用预处理质数表优化分解效率
- 清晰处理向上取整逻辑：`(a+b-1)/b` 代替浮点运算
**核心代码**：
```cpp
for(int j=1;j<=cnt;j++) { // 遍历m1的每个质因数
    int k = 0;
    while(Si % prime[j] == 0) { // 分解S_i
        k++; 
        Si /= prime[j];
    }
    t = max(t, (m1_cnt[j] + k - 1) / k); // 向上取整
}
```

#### 3. DiaoHantong（4星）
**关键亮点**：
- 使用欧拉筛预处理质数提升分解效率
- 通过结构体封装质因数信息
- 简洁的质因数次数比较逻辑
**核心代码**：
```cpp
void div(int n) { // 质因数分解
    for(int i=2; i*i<=n; i++){
        if(n%i == 0) {
            prime[++cnt] = i;
            while(n%i == 0) p[cnt]++, n/=i;
        }
    }
    if(n > 1) prime[++cnt] = n, p[cnt]++;
}
```

---

### 最优关键思路
1. **质因数分解法**：将大数分解质因数，通过比较质因子次数求解
2. **次数约束计算**：对每个质因子次数 $a$（来自$m_1^{m_2}$）和 $b$（来自$S_i$），求 $\lceil a/b \rceil$
3. **特判优化**：$m_1=1$时直接输出0，避免冗余计算

---

### 拓展与推荐
**同类问题**：
- P1072 [Hankson 的趣味题]（质因数约束）
- P2043 [质因数分解]（分解练习）
- P2926 [约数研究]（因数分析）

**算法套路**：
- 遇到整除性问题优先考虑质因数分解
- 大指数问题转化为质因子次数的倍数约束
- 预处理质数表优化分解效率

---
处理用时：52.00秒
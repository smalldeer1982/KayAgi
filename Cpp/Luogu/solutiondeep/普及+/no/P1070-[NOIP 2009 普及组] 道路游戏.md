# 题目信息

# [NOIP 2009 普及组] 道路游戏

## 题目描述

小新正在玩一个简单的电脑游戏。

游戏中有一条环形马路，马路上有 $n$ 个机器人工厂，两个相邻机器人工厂之间由一小段马路连接。小新以某个机器人工厂为起点，按顺时针顺序依次将这 $n$ 个机器人工厂编号为 $1\sim n$，因为马路是环形的，所以第 $n$ 个机器人工厂和第 $1$ 个机器人工厂是由一段马路连接在一起的。小新将连接机器人工厂的这 $n$ 段马路也编号为 $1\sim n$，并规定第 $i$ 段马路连接第 $i$ 个机器人工厂和第 $i+1$ 个机器人工厂（$1\le i\le n-1$），第 $n$ 段马路连接第 $n$ 个机器人工厂和第 $1$ 个机器人工厂。

游戏过程中，每个单位时间内，每段马路上都会出现一些金币，金币的数量会随着时间发生变化，即不同单位时间内同一段马路上出现的金币数量可能是不同的。小新需要机器人的帮助才能收集到马路上的金币。所需的机器人必须在机器人工厂用一些金币来购买，机器人一旦被购买，便会沿着环形马路按顺时针方向一直行走，在每个单位时间内行走一次，即从当前所在的机器人工厂到达相邻的下一个机器人工厂，并将经过的马路上的所有金币收集给小新，例如，小新在 $i$（$1\le i\le n$）号机器人工厂购买了一个机器人，这个机器人会从 $i$ 号机器人工厂开始，顺时针在马路上行走，第一次行走会经过 $i$ 号马路，到达 $i+1$ 号机器人工厂（如果 $i=n$，机器人会到达第 $1$ 个机器人工厂），并将 $i$ 号马路上的所有金币收集给小新。游戏中，环形马路上不能同时存在 $2$ 个或者 $2$ 个以上的机器人，并且每个机器人最多能够在环形马路上行走 $p$ 次。小新购买机器人的同时，需要给这个机器人设定行走次数，行走次数可以为 $1\sim p$ 之间的任意整数。当马路上的机器人行走完规定的次数之后会自动消失，小新必须立刻在任意一个机器人工厂中购买一个新的机器人，并给新的机器人设定新的行走次数。

以下是游戏的一些补充说明：

1. 游戏从小新第一次购买机器人开始计时。
2. 购买机器人和设定机器人的行走次数是瞬间完成的，不需要花费时间。
3. 购买机器人和机器人行走是两个独立的过程，机器人行走时不能购买机器人，购买完机器人并且设定机器人行走次数之后机器人才能行走。
4. 在同一个机器人工厂购买机器人的花费是相同的，但是在不同机器人工厂购买机器人的花费不一定相同。
5. 购买机器人花费的金币，在游戏结束时再从小新收集的金币中扣除，所以在游戏过程中小新不用担心因金币不足，无法购买机器人而导致游戏无法进行。也因为如此，游戏结束后，收集的金币数量可能为负。

现在已知每段马路上每个单位时间内出现的金币数量和在每个机器人工厂购买机器人需要的花费，请你告诉小新，经过 $m$ 个单位时间后，扣除购买机器人的花费，小新最多能收集到多少金币。


## 说明/提示

对于 $40\%$ 的数据，$2\le n\le 40$，$1\le m\le 40$。

对于 $90\%$ 的数据，$2\le n\le 200$，$1\le m\le 200$。

对于 $100\%$ 的数据，$2\le n\le 1000$，$1\le m\le 1000$，$1\le p\le m$。

NOIP 2009 普及组 第四题


## 样例 #1

### 输入

```
2 3 2 
1 2 3 
2 3 4 
1 2```

### 输出

```
5```

# AI分析结果



### 算法分类
动态规划

### 题解分析与结论
本题核心是动态规划结合环形路径处理与单调队列优化。各题解均采用动态规划思路，核心差异在于状态定义与优化方式：
1. **基础思路**：定义状态`dp[i][j]`表示时间i在工厂j的最优解，通过枚举步数k进行转移，时间复杂度O(n^3)
2. **优化方向**：通过预处理斜线前缀和计算路径收益，采用单调队列维护滑动窗口最大值，优化至O(n^2)
3. **环形处理**：通过模运算转换路径坐标，解决环形结构带来的转移难点
4. **关键技巧**：将点权转换为边权、斜线前缀和预处理、单调队列优化决策集合

### 优质题解推荐
#### 1. ButterflyDew（5星）
**核心亮点**：
- 完整呈现从三维状态到单调队列优化的思考过程
- 通过斜线前缀和预处理实现O(1)路径收益计算
- 使用模运算巧妙处理环形路径转移
```cpp
int get(int i,int j) { // 环形坐标转换
    return ((j-i)%n+n)%n;
}
for(int i=1;i<=m;i++) {
    for(int j=0;j<n;j++) { // 维护n个单调队列
        int id=get(i,j);
        while(l[id]<=r[id]&&loc[id][l[id]]+p<i) l[id]++;
        if(l[id]<=r[id])
            dp[i]=max(dp[i],q[id][l[id]]+add[id]+f[i][j]);
    }
    // ... 更新队列
}
```

#### 2. gorokokoro（4星）
**核心亮点**：
- 清晰展示状态转移方程推导过程
- 使用二维单调队列维护斜线方向最优值
- 代码结构清晰易读
```cpp
void PushOrder(Queue &q, int x, int p) {
    while(!q.Empty() && q.Back().first <= x)
        q.Pop_Back();
    q.Push_Back(make_pair(x, p));
}
for(int j=0;j<n;j++) {
    int id=get(i,j);
    tmp=dp[i]-add[id]-f[i][j]-cost[j];
    while(q[id].size() && q[id].back().first<=tmp)
        q[id].pop_back();
    q[id].push_back({tmp,i});
}
```

#### 3. dengyaotriangle（4星）
**核心亮点**：
- 创新性使用相对运动转换问题模型
- 结合优先队列实现滑动窗口最大值维护
- 提供独特的坐标系转换视角
```cpp
// 运动转换后的预处理
for(int i=1;i<=m;i++) 
    for(int j=1;j<=n;j++)
        r[j][i]=a[(j+i-2)%n+1][i];
// 优先队列维护决策集合
priority_queue<pair<int,int>> q[maxn];
while(q[j].top().second<i-p) q[j].pop();
```

### 关键思路总结
1. **斜线前缀和**：预处理斜对角线方向的金币和，实现O(1)路径收益计算
2. **单调队列优化**：维护`dp[k]-cost[j-k]`的滑动窗口最大值，减少重复计算
3. **环形处理**：通过模运算转换坐标`((j-i)%n+n)%n`处理环形路径
4. **状态压缩**：将三维状态优化至一维，通过滚动数组降低空间复杂度

### 扩展与训练
**类似题目推荐**：
1. [P1725 琪露诺](https://www.luogu.com.cn/problem/P1725) - 滑动窗口优化DP
2. [P2627 Mowing the Lawn](https://www.luogu.com.cn/problem/P2627) - 单调队列优化决策集合 
3. [P2569 股票交易](https://www.luogu.com.cn/problem/P2569) - 复杂状态转移与单调队列结合

**调试经验**：
- 处理环形时建议将数组扩展为两倍长度简化边界判断
- 调试时先验证前缀和计算的正确性
- 单调队列操作时注意维护元素时效性（超出p步要及时弹出）

---
处理用时：54.29秒
# 题目信息

# [NOIP 2009 提高组] 最优贸易

## 题目背景

本题原题数据极弱，Subtask 0 中的测试点为原题测试点，Subtask 1 中的测试点为 Hack 数据。

## 题目描述

$C$ 国有 $n$ 个大城市和 $m$ 条道路，每条道路连接这 $n$ 个城市中的某两个城市。任意两个城市之间最多只有一条道路直接相连。这 $m$ 条道路中有一部分为单向通行的道路，一部分为双向通行的道路，双向通行的道路在统计条数时也计为 $1$ 条。

$C$ 国幅员辽阔，各地的资源分布情况各不相同，这就导致了同一种商品在不同城市的价格不一定相同。但是，同一种商品在同一个城市的买入价和卖出价始终是相同的。

商人阿龙来到 $C$ 国旅游。当他得知同一种商品在不同城市的价格可能会不同这一信息之后，便决定在旅游的同时，利用商品在不同城市中的差价赚回一点旅费。设 $C$ 国 $n$ 个城市的标号从 $1\sim n$，阿龙决定从 $1$ 号城市出发，并最终在 $n$ 号城市结束自己的旅行。在旅游的过程中，任何城市可以重复经过多次，但不要求经过所有 $n$ 个城市。阿龙通过这样的贸易方式赚取旅费：他会选择一个经过的城市买入他最喜欢的商品――水晶球，并在之后经过的另一个城市卖出这个水晶球，用赚取的差价当做旅费。由于阿龙主要是来 $C$ 国旅游，他决定这个贸易只进行最多一次，当然，在赚不到差价的情况下他就无需进行贸易。

假设 $C$ 国有 $5$ 个大城市，城市的编号和道路连接情况如下图，单向箭头表示这条道路为单向通行，双向箭头表示这条道路为双向通行。

![](https://cdn.luogu.com.cn/upload/image_hosting/flre534z.png)

假设 $1\sim n$ 号城市的水晶球价格分别为 $4,3,5,6,1$。

阿龙可以选择如下一条线路：$1\to2\to3\to5$，并在 $2$ 号城市以 $3$ 的价格买入水晶球，在 $3$ 号城市以 $5$ 的价格卖出水晶球，赚取的旅费数为 $2$。

阿龙也可以选择如下一条线路：$1\to4\to5\to4\to5$，并在第 $1$ 次到达 $5$ 号城市时以 $1$ 的价格买入水晶球，在第 $2$ 次到达 $4$ 号城市时以 $6$ 的价格卖出水晶球，赚取的旅费数为 $5$。

现在给出 $n$ 个城市的水晶球价格，$m$ 条道路的信息（每条道路所连接的两个城市的编号以及该条道路的通行情况）。请你告诉阿龙，他最多能赚取多少旅费。

## 说明/提示

【数据范围】

输入数据保证 $1$ 号城市可以到达 $n$ 号城市。

对于 $10\%$ 的数据，$1\leq n\leq 6$。

对于 $30\%$ 的数据，$1\leq n\leq 100$。

对于 $50\%$ 的数据，不存在一条旅游路线，可以从一个城市出发，再回到这个城市。

对于 $100\%$ 的数据，$1\leq n\leq 100000$，$1\leq m\leq 500000$，$1\leq  x,y\leq  n$，$1\leq  z\leq  2$，$1\leq $ 各城市的编号 $\leq  n$。

水晶球价格 $\leq 100$。

NOIP 2009 提高组 第三题

## 样例 #1

### 输入

```
5 5 
4 3 5 6 1 
1 2 1 
1 4 1 
2 3 2 
3 5 1 
4 5 2 ```

### 输出

```
5```

# AI分析结果



**算法分类**: 图论（分层图 + SPFA）

---

### 综合分析与结论
题目要求找到买卖一次水晶球的最大差价。核心难点在于：
1. 路径必须包含买入点和卖出点
2. 买卖操作需满足可达性约束（能到达终点）

主流解法分两类：
1. **分层图+SPFA**（最流行）：通过三层图结构（未买/已买/已卖）建模状态转移，利用SPFA求最长路
2. **缩点+DAG动态规划**：通过强连通分量缩点，在拓扑序上维护路径最小值和最大利润

分层图解法更易理解且代码简洁，缩点解法更稳定但实现复杂。二者时间复杂度均为O(km)级别。

---

### 优质题解推荐

#### 1. [fy1234567ok] 分层图状态转移 + SPFA ⭐⭐⭐⭐⭐
**关键亮点**：
- 三层图结构清晰：原层→买入层→卖出层
- 边权设计巧妙：买入层边权为负价，卖出层边权为正价
- 代码仅40行，包含高效宏定义与STL优化
**核心代码**：
```cpp
for(int i = 1,x,y,z;i <= m; ++i) {
    cin >> x >> y >> z; 
    add(x, y); // 原层边
    if(z == 2) add(y, x); // 双向边处理
}
void spfa(int s) { /* 标准SPFA求最长路 */ }
```

#### 2. [ctzm] 缩点+DAG动态规划 ⭐⭐⭐⭐
**关键亮点**：
- 处理Hack数据稳定性强
- 反图DFS预处理可达性
- 拓扑序DP维护最小买入价
**核心代码**：
```cpp
void tarjan(int u) { /* 强连通分量缩点 */ }
void dfs(int u) { /* 反图处理可达性 */ }
for(int i = scc; i >= 1; i--) // 逆拓扑序更新
    for(int j : V[i]) 
        dp[j] = min(dp[j], min(dp[i], miw[j]));
```

#### 3. [Ngo123] 双SPFA解法 ⭐⭐⭐⭐
**关键亮点**：
- 正向SPFA找路径最小值
- 反向SPFA找路径最大值
- 无分层图，空间效率更优
**核心代码**：
```cpp
void spfa1() { /* 正向求minv[i] */ }
void spfa2() { /* 反向求maxv[i] */ }
ans = max(ans, maxv[i] - minv[i]);
```

---

### 关键思路总结
**分层图核心技巧**：
1. 状态分层：将买卖操作转化为不同层间的转移
2. 边权设计：买入边权为负值，卖出边权为正值
3. 可达性保证：通过分层结构自然限制交易次数

**实现优化点**：
- 节点编号公式：`t(x,i) = x + i*n`
- 使用`vector<pair<int,int>>`存边提升可读性
- 预处理反图处理可达性

---

### 拓展练习
1. [P4568](https://www.luogu.com.cn/problem/P4568) 飞行路线（分层图经典题）
2. [P2939](https://www.luogu.com.cn/problem/P2939) 改造路径（分层图变式）
3. [P1266](https://www.luogu.com.cn/problem/P1266) 速度限制（状态转移图论）

---

### 代码片段精选
**分层图建边**：
```cpp
for(int i = 1; i <= n; ++i) {
    G[t(i,0)].push_back({t(i,1), -v});//买入层
    G[t(i,1)].push_back({t(i,2), v});//卖出层
}
```
**SPFA核心**：
```cpp
if(d[v] < d[x] + len) { // 松弛条件
    d[v] = d[x] + len;
    if(!inq[v]) Q.push(v);
}
```

---

**注**：所有解法均需注意终点可达性验证。分层图解法通过终点第三层节点自动保证，缩点解法需显式处理。

---
处理用时：56.64秒
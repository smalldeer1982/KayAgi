# 题目信息

# [NOIP 2012 提高组] 疫情控制

## 题目描述

H 国有 $n $ 个城市，这 $n$ 个城市用 $ n-1 $ 条双向道路相互连通构成一棵树，$1 $ 号城市是首都，也是树中的根节点。

H 国的首都爆发了一种危害性极高的传染病。当局为了控制疫情，不让疫情扩散到边境城市（叶子节点所表示的城市），决定动用军队在一些城市建立检查点，使得从首都到边境城市的每一条路径上都至少有一个检查点，边境城市也可以建立检查点。但特别要注意的是，首都是不能建立检查点的。

现在，在 H 国的一些城市中已经驻扎有军队，且一个城市可以驻扎多个军队。一支军队可以在有道路连接的城市间移动，并在除首都以外的任意一个城市建立检查点，且只能在一个城市建立检查点。一支军队经过一条道路从一个城市移动到另一个城市所需要的时间等于道路的长度（单位：小时）。

请问最少需要多少个小时才能控制疫情。注意：不同的军队可以同时移动。


## 说明/提示

【输入输出样例说明】

第一支军队在 $2$ 号点设立检查点，第二支军队从 $2$ 号点移动到$ 3$ 号点设立检查点，所需时间为 $3$ 个小时。

 
【数据范围】

保证军队不会驻扎在首都。

- 对于 $20\%$ 的数据，$2 \le n\le 10$；
- 对于 $40\%$ 的数据，$2 \le n\le 50$，$0<w <10^5$；
- 对于 $60\%$ 的数据，$2 \le n\le 1000$，$0<w <10^6$；
- 对于 $80\%$ 的数据，$2 \le n\le 10^4$；
- 对于 $100\%$ 的数据，$2\le m\le n≤5\times 10^4$，$0<w <10^9$。


NOIP 2012 提高组 第二天 第三题


## 样例 #1

### 输入

```
4 
1 2 1 
1 3 2 
3 4 3 
2 
2 2```

### 输出

```
3```

# AI分析结果



### 算法分类
**二分 + 贪心 + 图论（树结构）**

---

### 综合分析与结论
题目要求找到部署军队的最小最大时间，使得所有根到叶子的路径均被覆盖。核心思路为：
1. **二分答案**确定可行时间阈值。
2. **树上倍增**预处理军队上移路径。
3. **贪心策略**分配军队覆盖剩余子树。

关键难点在于高效判断某时间阈值是否可行，需结合树上操作与贪心匹配。各题解均围绕此展开，差异主要在实现细节（如预处理方式、贪心策略的优化）。

---

### 精选题解

#### 1. TEoS（⭐⭐⭐⭐⭐）
**关键亮点**：
- 完整实现细节说明，包括树上倍增、DFS标记覆盖、贪心匹配。
- 代码结构清晰，注释详尽，便于理解。
- 通过样例详细解释贪心匹配过程。

**核心思路**：
```cpp
// 树上倍增预处理
void bfs() {
    queue<int> q;
    q.push(1); d[1] = 1;
    while (!q.empty()) {
        int x = q.front(); q.pop();
        for (int i = head[x]; i; i = Next[i]) {
            int y = ver[i];
            if (d[y]) continue;
            d[y] = d[x] + 1;
            f[y][0] = x; dist[y][0] = edge[i];
            for (int j = 1; j <= t; j++) {
                f[y][j] = f[f[y][j-1]][j-1];
                dist[y][j] = dist[y][j-1] + dist[f[y][j-1]][j-1];
            }
            q.push(y);
        }
    }
}

// 贪心匹配剩余子树与军队
bool check(ll lim) {
    sort(army + 1, army + cnt + 1);
    sort(need + 1, need + tot + 1);
    int i = 1, j = 1;
    while (i <= tot && j <= cnt) {
        if (army[j].rest >= need[i]) i++, j++;
        else j++;
    }
    return i > tot;
}
```

#### 2. FlashHu（⭐⭐⭐⭐）
**关键亮点**：
- 优化DFS判断子树覆盖，避免冗余计算。
- 代码简洁高效，复杂度降至单次检查O(n)。

**优化技巧**：
```cpp
bool dfs(int x) {
    if (sta[x]) return true;
    bool pson = 0;
    for (int i = head[x]; i; i = Next[i]) {
        int y = to[i];
        if (d[y] < d[x]) continue;
        pson = 1;
        if (!dfs(y)) return false;
    }
    return pson; // 非叶子节点需所有子节点覆盖
}
```

#### 3. 万弘（⭐⭐⭐⭐）
**个人心得**：
- 强调预处理时标记子树归属，简化后续分配。
- 通过反向排序优化贪心匹配效率。

**核心实现**：
```cpp
// 预处理子树归属
void dfs(int u, int fa, int anc) {
    if (fa == 1) anc = u;
    bl[u] = anc;
    for (int e = head[u]; e; e = nxt[e]) 
        if (to[e] != fa) dfs(to[e], u, anc);
}
```

---

### 关键思路总结
1. **二分答案框架**：确定时间阈值，转化为可行性判断问题。
2. **树上倍增优化**：快速计算军队在给定时间内的最大上移位置。
3. **贪心覆盖策略**：优先覆盖距离根最远的子树，确保最优匹配。
4. **预处理与标记**：提前处理子树归属、剩余时间，简化后续逻辑。

---

### 类似题目推荐
1. [P5021 赛道修建](https://www.luogu.com.cn/problem/P5021) - 二分答案 + 贪心分配路径。
2. [P2680 运输计划](https://www.luogu.com.cn/problem/P2680) - 树路径覆盖与时间优化。
3. [P3523 动态树](https://www.luogu.com.cn/problem/P3523) - 树结构上的动态规划与贪心策略。

---
处理用时：57.83秒
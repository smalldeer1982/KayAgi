# 题目信息

# [NOIP 2004 普及组] FBI 树

## 题目描述

我们可以把由 0 和 1 组成的字符串分为三类：全 0 串称为 B 串，全 1 串称为 I 串，既含 0 又含 1 的串则称为 F 串。

FBI 树是一种二叉树，它的结点类型也包括 F 结点，B 结点和 I 结点三种。由一个长度为 $2^N$ 的 01 串 $S$ 可以构造出一棵 FBI 树 $T$，递归的构造方法如下：

1. $T$ 的根结点为 $R$，其类型与串 $S$ 的类型相同；
2. 若串 $S$ 的长度大于 $1$，将串 $S$ 从中间分开，分为等长的左右子串 $S_1$ 和 $S_2$；由左子串 $S_1$ 构造 $R$ 的左子树 $T_1$，由右子串 $S_2$ 构造 $R$ 的右子树 $T_2$。

现在给定一个长度为 $2^N$ 的 01 串，请用上述构造方法构造出一棵 FBI 树，并输出它的后序遍历序列。


## 说明/提示

对于 $40\%$ 的数据，$N \le 2$；

对于全部的数据，$N \le 10$。


noip2004普及组第3题


## 样例 #1

### 输入

```
3
10001011
```

### 输出

```
IBFBBBFIBFIIIFF
```

# AI分析结果



### 算法分类
分治

### 综合分析与结论
本题本质是分治思想与二叉树遍历的结合。所有题解都围绕递归判断子串类型+后序遍历展开，核心差异在于递归实现方式。最优解法通过分治递归直接生成后序遍历序列，无需显式建树，利用递归调用顺序自然实现后序遍历，时空效率最佳。

### 精选题解

1. **作者：ingu（5星）**  
   **亮点**：  
   - 递归参数使用区间端点代替子串拷贝，避免内存浪费  
   - 后序遍历输出通过递归顺序自然实现（先递归左右子树，最后处理当前节点）  
   - 用双标记法判断子串类型，逻辑简洁  
   ```cpp
   void maketree(int x,int y){
       if(y>x){
           maketree(x,(x+y)/2);
           maketree((x+y+1)/2,y);
       }    
       int B=1,I=1;
       for(int i=0;i<=y-x;i++){
           if(s[x+i]=='1') B=0;
           else if(s[x+i]=='0') I=0;
       }
       cout<<(B?'B':I?'I':'F');
   }
   ```

2. **作者：传说饭（4星）**  
   **亮点**：  
   - 将判断逻辑封装为函数，提高代码可读性  
   - 直接使用string.substr切割字符串，逻辑直观  
   - 通过递归返回值传递类型信息，结构清晰  
   ```cpp
   char FBI(string s) {
       if(s.length()>1){
           cout<<FBI(s.substr(0,s.length()/2));
           cout<<FBI(s.substr(s.length()/2));
       }
       if(s.find('0')==-1) return 'I';
       if(s.find('1')==-1) return 'B';
       return 'F';
   }
   ```

3. **作者：wuhao1027（4星）**  
   **亮点**：  
   - 使用数学方法计算子串长度，避免字符串操作  
   - 统计0/1数量代替标记法，逻辑更易理解  
   - 参数传递起止点，内存效率高  
   ```cpp
   void work(int low, int up){
       int mid=(low+up)/2;
       if(low!=up){
           work(low,mid);
           work(mid+1,up);
       }
       int a=0,b=0;
       for(int i=low;i<=up;i++) 
           a+=(A[i]=='0'), b+=(A[i]=='1');
       putchar(a&&b?'F':a?'B':'I');
   }
   ```

### 关键技巧总结
1. **分治递归框架**：将子串不断二分处理，天然形成二叉树结构  
2. **隐式后序遍历**：先递归处理左右区间，再处理当前节点即得后序  
3. **类型判断优化**：使用区间端点代替字符串拷贝，用计数代替全扫描  
4. **空间压缩**：通过参数传递区间信息，避免存储整棵树结构  

### 拓展练习
1. [P1305 新二叉树](https://www.luogu.com.cn/problem/P1305)（基础二叉树构建）  
2. [P1229 遍历问题](https://www.luogu.com.cn/problem/P1229)（遍历顺序特性分析）  
3. [P1030 求先序排列](https://www.luogu.com.cn/problem/P1030)（遍历顺序转换练习）

---
处理用时：64.07秒
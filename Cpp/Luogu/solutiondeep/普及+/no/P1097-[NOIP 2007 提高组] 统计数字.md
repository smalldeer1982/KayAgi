# 题目信息

# [NOIP 2007 提高组] 统计数字

## 题目描述

某次科研调查时得到了 $n$ 个自然数，每个数均不超过 $1.5 \times 10^9$。已知不相同的数不超过 $10^4$ 个，现在需要统计这些自然数各自出现的次数，并按照自然数从小到大的顺序输出统计结果。


## 说明/提示

- $30\%$ 的数据满足：$1  \le  n  \le  1000$；
- $60\%$ 的数据满足：$1  \le  n  \le  50000$；
- $100\%$ 的数据满足：$1  \le  n  \le  200000$，每个数均不超过 $1.5 \times 10^9$。

NOIP 2007 提高第一题


## 样例 #1

### 输入

```
8
2
4
2
4
5
100
2
100```

### 输出

```
2 3
4 2
5 1
100 2
```

# AI分析结果



### 算法分类
排序

### 综合分析
本题核心在于统计出现频次并按自然数序输出。题解主要分为两类：  
1. **STL容器法**：利用`map`自动排序和统计特性，遍历时直接输出  
2. **排序遍历法**：先排序数组，再遍历统计连续相同元素个数  
关键难点在于处理大数据范围无法用桶数组，以及遍历时的边界条件处理。最优解法需兼顾时间效率与代码简洁性。

### 精选题解

#### 1. ikunTLE（5星）
**核心亮点**  
- 利用`map`自动排序特性，代码极简  
- 直接遍历`map`输出，无需额外去重操作  
**关键代码**  
```cpp
map<int,int> mp;
for(auto it=mp.begin(); it!=mp.end(); ++it)
    printf("%d %d\n", it->first, it->second);
```
**实现思想**  
每次读入数时`mp[x]++`自动统计频次，利用`map`内部红黑树自动维护键的有序性，遍历时直接输出键值对。

#### 2. LiJunze0501（4星）
**核心亮点**  
- 双指针遍历连续相同元素块  
- 避免数组越界的经典处理方式  
**关键代码**  
```cpp
int i=1;
while(i <= n) {
    int t = a[i], cnt = 0;
    while(a[i] == t) cnt++, i++;
    cout << t << " " << cnt << endl;
}
```
**实现思想**  
排序后外层循环用`i`标记块起点，内层循环用`cnt`统计连续相同元素个数，`i`直接跳到下一个块起始位置，天然避免越界。

### 最优技巧总结
1. **STL的灵活运用**：`map`自动排序特性可替代手动排序+去重操作  
2. **双指针块统计**：适用于排序后数组的连续元素处理，时间复杂度O(n)  
3. **边界哨兵技巧**：在数组末尾添加极值（如`a[n+1] = -INF`）可简化最后一个块的判断逻辑

### 类似题目推荐
- P1177 【模板】快速排序（练习排序基础）  
- P1059 明明的随机数（排序+去重）  
- P1908 逆序对（排序思想扩展）

---
处理用时：61.91秒
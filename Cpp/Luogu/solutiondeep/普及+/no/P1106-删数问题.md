# 题目信息

# 删数问题

## 题目描述

键盘输入一个高精度的正整数 $n$（不超过 $250$ 位），去掉其中任意 $k$ 个数字后剩下的数字按原左右次序将组成一个新的非负整数。编程对给定的 $n$ 和 $k$，寻找一种方案使得剩下的数字组成的新数最小。

## 说明/提示

用 $\operatorname{len}(n)$ 表示 $n$ 的**位数**，保证 $1 \leq k < \operatorname{len}(n) \leq 250$。

## 样例 #1

### 输入

```
175438 
4
```

### 输出

```
13```

# AI分析结果



### 算法分类
贪心

### 题解综合分析
本题核心在于贪心策略：通过局部最优（删除当前高位较大值）实现全局最优（最小结果）。各解法均围绕如何快速定位应删除的位，并处理前导零等边界条件。

---

### 精选题解

#### 1. expin（5星）
**亮点**：  
- 使用滑动窗口（m+1范围）确保每次选当前可删范围内的最小数作为高位  
- 动态维护剩余需删除次数和前导零标记  
- 代码逻辑清晰，时间复杂度O(n)  

**关键代码**：  
```cpp
while(cnt<rest){
    minp = t;
    for(int i=t; i<=k+t; i++) // 在t到t+k范围内找最小值
        if(a[minp]>a[i]) minp = i;
    if(a[minp]) flag=1; // 标记已输出非零数
    if(flag) cout<<a[minp];
    k -= minp - t; // 更新剩余删除次数
    t = minp+1; // 滑动窗口起点更新
    cnt++;
}
```

---

#### 2. xh39（4星）  
**亮点**：  
- 直接使用字符串操作简化删除流程  
- 利用`erase`函数快速处理数字删除  
- 简洁处理前导零的特殊情况  

**调试心得**：  
> "最后一个点WA是因为没处理答案是0的情况，需要特判空输出"

**关键代码**：  
```cpp
while(s){
    for(i=0; n[i]<=n[i+1];) i++; // 找第一个递减点
    n.erase(i,1); // 删除该位
    s--;
}
while(n[0]=='0' && n.size()>1) n.erase(0,1);
```

---

#### 3. Sol1（4星）  
**亮点**：  
- 使用单调栈维护递增序列  
- 反向考虑保留数字，通过栈顶元素比较实现快速筛选  
- 时间复杂度优化至O(n)  

**关键代码**：  
```cpp
for(int i=0; i<len; i++){
    while(n && !q.empty() && q.top()>a[i]){
        q.pop(); // 弹出比当前大的元素
        n--;
    }
    q.push(a[i]);
}
```

---

### 关键技巧总结
1. **滑动窗口找极小值**：在可删除范围内选择最小高位  
2. **递减点删除策略**：删除第一个出现`a[i] > a[i+1]`的i位置  
3. **前导零处理**：在最终输出时跳过连续零，但保留单个零  
4. **栈优化**：使用单调栈维护递增序列，减少重复比较  

---

### 拓展训练
1. [P1323 删数问题（数据加强版）](https://www.luogu.com.cn/problem/P1323)  
2. [P1799 数列分段](https://www.luogu.com.cn/problem/P1799)（贪心分段）  
3. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)（贪心+优先队列）  

### 调试经验摘录
> "k次删除后可能剩余全零，此时必须输出0而非空字符串" —— 修罗海神王  
> "用erase时注意字符串长度变化，可能导致循环越界" —— 赤瞳之鸦  
> "单调栈中每个元素最多入栈出栈一次，复杂度O(n)" —— Sol1

---
处理用时：46.57秒
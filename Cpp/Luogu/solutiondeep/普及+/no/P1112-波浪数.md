# 题目信息

# 波浪数

## 题目描述

波浪数是在一对**不同**数字之间交替转换的数，如 $1212121$，双重波浪数则是指在两种进制下都是波浪数的数，如十进制数 $191919$ 是一个十进制下的波浪数，它对应的十一进制数 $121212$ 也是一个波浪数，所以十进制数 $191919$ 是一个双重波浪数。特别地，只有一位的数也算作波浪数，例如 $1$。

类似的可以定义三重波浪数，三重波浪数在三种不同的进制中都是波浪数，甚至还有四重波浪数，如 $300_{(10)}=606_{(7)}=363_{(9)}=454_{(8)}=1\mathtt{A}1_{(13)}$，下标表示采用的进制。你的任务就是在指定范围内找出双重、三重、四重波浪数。


## 说明/提示

### 数据范围及约定

对于全部数据，保证 $2\le l\le r\le 32$，$1\le L\le R\le 10^7$，$k\in \{2, 3, 4\}$。

## 样例 #1

### 输入

```
10 11 190000 960000 2```

### 输出

```
191919
383838
575757
767676
959595```

# AI分析结果



**算法分类**: 构造

### 综合分析与结论
本题核心在于逆向构造波浪数而非暴力枚举。通过枚举所有可能的进制和交替数字对，生成对应的波浪数并统计其出现次数。该方法避免了直接检查每个数的所有进制，将时间复杂度优化至可接受范围。

---

### 高星题解推荐
#### 1. Crazily (5星)
**关键亮点**：  
- 逆向构造思路清晰，三重循环分别枚举进制、交替数字对，通过交替生成波浪数  
- 使用数组直接统计十进制数的重数，效率极高  
- 代码简洁，逻辑严密（处理了 i≠j 的约束，及时终止超范围计算）

**核心代码**：
```cpp
for(int k=a;k<=b;++k) // 枚举进制
for(int i=1;i<k;++i) // 第一个交替数（首位非0）
for(int j=0;j<k;++j) // 第二个交替数
if(i!=j){
    x=0; t=0;
    while(x<=r){ // 交替生成波浪数
        x = (t%2==0) ? x*k+i : x*k+j;
        if(x>=l && x<=r) v[x]++;
    }
}
```

#### 2. Skywalker_David (4星)
**关键亮点**：  
- 预计算数字长度范围，减少无效构造次数  
- 单独封装波浪数生成函数，提升代码可维护性  
- 使用位运算优化交替逻辑（i&1代替取模）

**核心思想**：
```cpp
int make(int a, int b, int len, int k){ // 构造指定长度的波浪数
    int x = 0;
    for(int i=1; i<=len; i++)
        x = x*k + ((i&1) ? a : b); // 交替插入a/b
    return x;
}
```

#### 3. 千梦羽翼 (4星)
**关键技巧**：  
- 使用位运算优化交替逻辑（id^=1）  
- 动态扩展波浪数位数，避免长度预计算  
- 正确处理单数字波浪数（如j=0时首位的处理）

**核心片段**：
```cpp
int now = j, id = 1;
s[0] = j; s[1] = k;
while(now <= r){
    v[now]++;
    now = now*i + s[id];
    id ^= 1; // 通过异或实现0/1交替
}
```

---

### 最优关键思路
**构造法 + 进制转换**：  
1. **交替数字生成**：对每个进制k，枚举所有可能的不同数字对(i,j)，交替生成波浪数  
2. **即时进制转换**：在生成过程中直接计算十进制值，避免后续转换  
3. **剪枝优化**：当生成值超过上限时立即终止当前构造  
4. **频次统计**：用数组记录每个数的波浪次数，最终直接查询结果

---

### 拓展练习
1. [P1141 01迷宫](https://www.luogu.com.cn/problem/P1141) - 构造连通块  
2. [P1057 数位验证](https://www.luogu.com.cn/problem/P1057) - 特殊数字构造  
3. [P1066 2^k进制数](https://www.luogu.com.cn/problem/P1066) - 进制与数位组合构造

---
处理用时：59.52秒
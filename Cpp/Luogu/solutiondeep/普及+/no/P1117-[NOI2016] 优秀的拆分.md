# 题目信息

# [NOI2016] 优秀的拆分

## 题目描述

如果一个字符串可以被拆分为 $\text{AABB}$ 的形式，其中 $\text{A}$ 和 $\text{B}$ 是任意**非空**字符串，则我们称该字符串的这种拆分是优秀的。  
例如，对于字符串 $ \texttt{aabaabaa} $ ，如果令 $\text{A}=\texttt{aab}$，$\text{B}=\texttt{a}$，我们就找到了这个字符串拆分成 $\text{AABB}$ 的一种方式。

一个字符串可能没有优秀的拆分，也可能存在不止一种优秀的拆分。  
比如我们令 $\text{A}=\texttt{a}$，$\text{B}=\texttt{baa}$，也可以用 $\text{AABB}$ 表示出上述字符串；但是，字符串 $\texttt{abaabaa}$ 就没有优秀的拆分。

现在给出一个长度为 $n$ 的字符串 $S$，我们需要求出，在它所有子串的所有拆分方式中，优秀拆分的总个数。这里的子串是指字符串中连续的一段。

以下事项需要注意：

1. 出现在不同位置的相同子串，我们认为是不同的子串，它们的优秀拆分均会被记入答案。
2. 在一个拆分中，允许出现 $\text{A}=\text{B}$。例如 $\texttt{cccc}$ 存在拆分 $\text{A}=\text{B}=\texttt{c}$。
3. 字符串本身也是它的一个子串。

## 说明/提示

### 样例解释

我们用 $S[i, j]$ 表示字符串 $S$ 第 $i$ 个字符到第 $j$ 个字符的子串（从 $1$ 开始计数）。

第一组数据中，共有三个子串存在优秀的拆分：  
$S[1,4]=\texttt{aabb}$，优秀的拆分为 $\text{A}=\texttt{a}$，$\text{B}=\texttt{b}$；  
$S[3,6]=\texttt{bbbb}$，优秀的拆分为 $\text{A}=\texttt{b}$，$\text{B}=\texttt{b}$；  
$S[1,6]=\texttt{aabbbb}$，优秀的拆分为 $\text{A}=\texttt{a}$，$\text{B}=\texttt{bb}$。  
而剩下的子串不存在优秀的拆分，所以第一组数据的答案是 $3$。

第二组数据中，有两类，总共四个子串存在优秀的拆分：  
对于子串 $S[1,4]=S[2,5]=S[3,6]=\texttt{cccc}$，它们优秀的拆分相同，均为 $\text{A}=\texttt{c}$，$\text{B}=\texttt{c}$，但由于这些子串位置不同，因此要计算三次；  
对于子串 $S[1,6]=\texttt{cccccc}$，它优秀的拆分有两种：$\text{A}=\texttt{c}$，$\text{B}=\texttt{cc}$ 和 $\text{A}=\texttt{cc}$，$\text{B}=\texttt{c}$，它们是相同子串的不同拆分，也都要计入答案。  
所以第二组数据的答案是 $3+2=5$。

第三组数据中，$S[1,8]$ 和 $S[4,11]$ 各有两种优秀的拆分，其中 $S[1,8]$ 是问题描述中的例子，所以答案是 $2+2=4$。

第四组数据中，$S[1,4]$，$S[6,11]$，$S[7,12]$，$S[2,11]$，$S[1,8]$ 各有一种优秀的拆分，$S[3,14]$ 有两种优秀的拆分，所以答案是 $5+2=7$。

### 数据范围

对于全部的测试点，保证 $1 \leq T \leq 10$。以下对数据的限制均是对于单组输入数据而言的，也就是说同一个测试点下的 $T$ 组数据均满足限制条件。

我们假定 $n$ 为字符串 $S$ 的长度，每个测试点的详细数据范围见下表：

| 测试点编号   | $n \leq$  | 特殊性质           |
| ------------ | --------- | ------------------ |
| $1 \sim 2$   | $300$     | $S$ 中所有字符相同 |
| $3 \sim 4$   | $2\,000$  | $S$ 中所有字符相同 |
| $5 \sim 6$   | $10$      |                    |
| $7 \sim 8$   | $20$      |                    |
| $9 \sim 10$  | $30$      |                    |
| $11 \sim 12$ | $50$      |                    |
| $13 \sim 14$ | $100$     |                    |
| $15$         | $200$     |                    |
| $16$         | $300$     |                    |
| $17$         | $500$     |                    |
| $18$         | $1\,000$  |                    |
| $19$         | $2\,000$  |                    |
| $20$         | $30\,000$ |                    |

## 样例 #1

### 输入

```
4
aabbbb
cccccc
aabaabaabaa
bbaabaababaaba
```

### 输出

```
3
5
4
7
```

# AI分析结果



**算法分类**  
字符串、差分、后缀数组  

**题解分析与结论**  
题目要求统计所有子串的优秀拆分（AABB形式）数目。各题解的核心思路是：  
1. 预处理每个位置作为AA结尾（a数组）和开头（b数组）的次数，答案即∑a[i]×b[i+1]。  
2. 枚举A的长度len，每隔len设置关键点，利用LCP（最长公共前缀）和LCS（最长公共后缀）确定合法区间，通过差分高效统计。  
3. 使用后缀数组（SA）优化LCP/LCS查询至O(1)，时间复杂度O(n log n)。  

**精选题解**  
1. **Gypsophila (5星)**  
   - 关键亮点：清晰阐释调和级数枚举与差分处理，SA+ST表高效查询。  
   - 代码片段：  
     ```cpp  
     for(int len=1; len<=n/2; len++)  
         for(int i=len; i+len<=n; i+=len) {  
             int j=i+len;  
             int lcp=SA.query(i,j), lcs=SA_rev.query(n-i+2,n-j+2);  
             if(lcp+lcs>=len) {  
                 // 差分更新a和b数组  
             }  
         }  
     ```  

2. **何俞均 (5星)**  
   - 关键亮点：详细推导区间贡献范围，代码结构简洁高效。  
   - 个人心得："注意正反串处理避免重复计算，差分区间需严格限定范围。"  

3. **George1123 (4星)**  
   - 关键亮点：引入Runs理论处理重复结构，复杂度同样O(n log n)。  
   - 适用场景：熟悉Runs的选手可快速推导，但对多数选手理解成本较高。  

**核心实现技巧**  
- **关键点枚举**：通过每隔len的关键点，将问题分解为相邻点的贡献计算。  
- **LCP/LCS快速查询**：正反后缀数组预处理ST表实现O(1)查询。  
- **差分数组优化**：区间加减转化为端点操作，最后前缀和得到结果。  

**拓展建议**  
类似套路可解决ABAB型子串统计（如CF319D）。推荐练习：  
1. [P3804 【模板】后缀自动机（SAM）](https://www.luogu.com.cn/problem/P3804)  
2. [P2852 [USACO06DEC]Milk Patterns G](https://www.luogu.com.cn/problem/P2852)  
3. [CF319D Have You Repeaten?](https://www.luogu.com.cn/problem/CF319D)

---
处理用时：54.76秒
# 题目信息

# [ZJOI2007] 矩阵游戏

## 题目描述

小 Q 是一个非常聪明的孩子，除了国际象棋，他还很喜欢玩一个电脑益智游戏――矩阵游戏。矩阵游戏在一个 $n \times n$ 黑白方阵进行（如同国际象棋一般，只是颜色是随意的）。每次可以对该矩阵进行两种操作：

- 行交换操作：选择矩阵的任意两行，交换这两行（即交换对应格子的颜色）。
- 列交换操作：选择矩阵的任意两列，交换这两列（即交换对应格子的颜色）。

游戏的目标，即通过若干次操作，使得方阵的主对角线(左上角到右下角的连线)上的格子均为黑色。

对于某些关卡，小 Q 百思不得其解，以致他开始怀疑这些关卡是不是根本就是无解的！于是小 Q 决定写一个程序来判断这些关卡是否有解。


## 说明/提示

#### 数据规模与约定

- 对于 $20\%$ 的数据，保证 $n \leq 7$。
- 对于 $50\%$ 的数据，保证 $n \leq 50$。
- 对于 $100\%$ 的数据，保证 $1 \leq n \leq 200$，$1 \leq T \leq 20$。


## 样例 #1

### 输入

```
2
2
0 0
0 1
3
0 0 1
0 1 0
1 0 0
```

### 输出

```
No
Yes
```

# AI分析结果



**算法分类**  
图论（二分图匹配）

---

**综合分析与结论**  
本题核心在于将行与列视为二分图的左右部集，每个黑色格子作为行-列边。通过交换行/列操作不影响最大匹配数的特性，判断最大匹配是否等于n。本质是求二分图的最大匹配，可采用匈牙利算法或网络流Dinic实现。

---

**优质题解推荐**  
1. **Night_Aurora (⭐⭐⭐⭐⭐)**  
   - **亮点**：从行/列交换的数学性质推导出二分图模型，并给出网络流和匈牙利两种解法。  
   - **关键思路**：交换行/列本质是调整匹配关系，最大匹配数不变，最终只需判断是否存在完美匹配。  
   - **核心代码**（匈牙利算法）：
     ```cpp
     bool dfs(int x) {
         for (int i=head[x]; i; i=next[i]) {
             int y = to[i];
             if (!vis[y]) {
                 vis[y] = 1;
                 if (!match[y] || dfs(match[y])) {
                     match[y] = x; return true;
                 }
             }
         }
         return false;
     }
     ```

2. **俾斯麦 (⭐⭐⭐⭐⭐)**  
   - **亮点**：详细对比匈牙利与Dinic的适用场景，代码优化清空数组提升效率。  
   - **个人心得**：`clear()`函数中逐项清空而非`memset`节省时间。  

3. **cmwqf (⭐⭐⭐⭐)**  
   - **亮点**：通过图示直观展示行列交换对匹配的影响，代码简洁易理解。  
   - **核心图示**：交换行列仅改变节点位置，不改变边的存在性，完美匹配仍成立。

---

**关键技巧总结**  
- **模型转换**：将矩阵问题转化为二分图匹配问题，行/列视为节点，黑格子作为边。  
- **性质利用**：交换操作不影响最大匹配数，只需初始状态存在完美匹配。  
- **代码优化**：使用时间戳代替`memset`清空`vis[]`数组提升效率。

---

**同类题目推荐**  
1. [P3386 【模板】二分图最大匹配](https://www.luogu.com.cn/problem/P3386)  
2. [P1963 [NOI2009] 变换序列](https://www.luogu.com.cn/problem/P1963)  
3. [P3254 圆桌问题](https://www.luogu.com.cn/problem/P3254)

---
处理用时：38.57秒
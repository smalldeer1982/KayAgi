# 题目信息

# 数字生成游戏

## 题目描述

小明完成了这样一个数字生成游戏，对于一个不包含 $0$ 的数字 $s$ 来说，有以下 $3$ 种生成新的数的规则：

1.    将 $s$ 的任意两位对换生成新的数字，例如 $143$ 可以生成 $314,413,134$；

2.    将 $s$ 的任意一位删除生成新的数字，例如 $143$ 可以生成 $14,13,43$；

3.    在 $s$ 的相邻两位之间 $s_i,s_{i + 1}$ 之间插入一个数字 $x$，$x$ 需要满足 $s_i<x<s_{i + 1}$。例如 $143$ 可以生成 $1243,1343$，但是不能生成 $1143,1543$ 等。

现在小明想知道，在这个生成法则下，从 $s$ 开始，每次生成一个数，可以用然后用新生成的数生成另外一个数，不断生成直到生成 $t$ 至少需要多少次生成操作。

另外，小明给规则 $3$ 又加了一个限制，即生成数的位数不能超过初始数 $s$ 的位数。若 $s$ 是 $143$，那么 $1243$ 与 $1343$ 都是无法生成的；若 $s$ 为 $1443$，那么可以将 $s$ 删除变为 $143$，再生成 $1243$ 或 $1343$。

## 说明/提示

**样例解释**

$143\to 134$

$133$ 无法得到

$143\to13\to123\to23\to32$

**数据范围**

对于 $20\%$ 的数据，$s < 100$；  
对于 $40\%$ 的数据，$s < 1000$；  
对于 $40\%$ 的数据，$m < 10$；  
对于 $60\%$ 的数据，$s < 10000$；  
对于 $100\%$ 的数据，$s < 100000,m ≤ 50000$。

## 样例 #1

### 输入

```
143
3
134
133
32
```

### 输出

```
1
-1
4
```

# AI分析结果



**算法分类**  
广度优先搜索 BFS

---

### 综合分析与结论  
题目要求通过三种操作（交换位、删除位、插入位）将初始数 s 转换为目标数 t 的最短步数。所有题解均采用 BFS 预处理所有可能生成的数字并记录最小步数，最终 O(1) 回答查询。核心难点在于高效实现三种操作的状态转移，并正确处理插入操作的位数限制。

---

### 精选题解  

#### 1. Just_do_it 的题解（★★★★★）  
**关键亮点**  
- 将数字转为数组处理，避免字符串操作，提升效率  
- 严格处理插入操作的位数限制（`if(len == n) continue`）  
- 分模块实现三种操作，逻辑清晰  

**核心代码**  
```cpp
void bfs(){
    while(!q.empty()){
        node a = q.front(); q.pop();
        // 转换为数组 s[]
        // 处理删除操作
        for(int i=1;i<=len;i++){ 
            // 生成删除后的数字 b
            if(!flag[b]) q.push({b, a.ans+1});
        }
        // 处理交换操作
        for(int i=1;i<=len;i++) for(int j=i+1;j<=len;j++){
            swap(s[i],s[j]);
            // 生成交换后的数字 b
            if(!flag[b]) q.push({b, a.ans+1});
        }
        // 处理插入操作
        if(len == n) continue; // 位数限制
        for(int i=1;i<len;i++){
            for(int j=s[i]-1;j>s[i+1];j--){ 
                // 生成插入后的数字 b
                if(!flag[b]) q.push({b, a.ans+1});
            }
        }
    }
}
```

#### 2. Alarm5854 的题解（★★★★）  
**关键亮点**  
- 使用字符串函数（swap、erase、insert）简化代码  
- 利用 `stoi` 和 `to_string` 快速转换类型  
- 代码简洁，逻辑紧凑（仅 30 行）  

**核心代码**  
```cpp
void bfs(int s) {
    queue<int> q; q.push(s); 
    while (!q.empty()) {
        int x = q.front(); q.pop();
        string t = to_string(x);
        // 交换操作
        for(int i=0;i<t.size();i++) for(int j=i+1;j<t.size();j++){
            string u = t; swap(u[i],u[j]);
            if(!~d[k = stoi(u)]) q.push(k);
        }
        // 删除操作
        for(int i=0;i<t.size();i++){
            string u = t; u.erase(i,1);
            if(!~d[k = stoi(u)]) q.push(k);
        }
        // 插入操作
        if(t.size() == l) continue;
        for(int i=1;i<t.size();i++) 
            for(char c=t[i-1]+1; c<t[i]; c++){
                string u = t; u.insert(i,1,c);
                if(!~d[k = stoi(u)]) q.push(k);
            }
    }
}
```

#### 3. 冰糖鸽子 的题解（★★★★）  
**关键亮点**  
- 使用 `map<string,int>` 存储状态，天然支持去重  
- 直接对字符串进行操作，直观易理解  
- 预处理原数长度，严格限制插入位数  

**核心代码**  
```cpp
void bfs(){
    queue<pair<string,int>> q;
    q.push({str,0});
    while(q.size()){
        auto [x,step] = q.front(); q.pop();
        for(int i=0;i<x.size();i++){ // 交换
            for(int j=i+1;j<x.size();j++){
                string y=x; swap(y[i],y[j]);
                if(!q.count(y)) q.push({y,step+1});
            }
        }
        if(x.size()>1){ // 删除
            for(int i=0;i<x.size();i++){
                string y=x; y.erase(i,1);
                if(!q.count(y)) q.push({y,step+1});
            }
        }
        if(x.size()<n){ // 插入
            for(int i=0;i<x.size()-1;i++){
                for(char c=x[i]+1;c<x[i+1];c++){
                    string y=x; y.insert(i+1,1,c);
                    if(!q.count(y)) q.push({y,step+1});
                }
            }
        }
    }
}
```

---

### 关键思路总结  
1. **状态表示**：将数字转为字符串或数组处理，便于位操作  
2. **BFS 分层**：每次操作步数+1，首次到达即最短路径  
3. **插入限制**：维护原数长度变量，插入后位数不可超过初始值  
4. **去重优化**：使用哈希表或数组标记已访问状态  

---

### 拓展与练习  
类似题目推荐：  
1. [P1032 字串变换](https://www.luogu.com.cn/problem/P1032) - 字符串变换规则下的 BFS  
2. [P2895 [USACO08FEB]Meteor Shower S](https://www.luogu.com.cn/problem/P2895) - 状态转移+BFS  
3. [P1120 小木棍](https://www.luogu.com.cn/problem/P1120) - 剪枝优化的 DFS/BFS  

---

### 题解个人心得摘录  
- Just_do_it：强调位数限制的判断需在插入操作前处理（`if(len == n) continue`），避免无效状态  
- 冰糖鸽子：指出字符串操作虽直观但效率较低，数字分解法需注意位运算的边界处理  
- Alarm5854：提到利用 `stoi` 和 `to_string` 可减少代码量，但需注意异常输入（如空字符串）

---
处理用时：58.74秒
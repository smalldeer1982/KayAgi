# 题目信息

# 迎接仪式

## 题目描述

LHX 教主要来 X 市指导 OI 学习工作了。为了迎接教主，在一条道路旁，一群“Orz 教主 er”穿着文化衫站在道路两旁迎接教主，每件文化衫上都印着大字。一旁的 Orzer 依次摆出“欢迎欢迎欢迎欢迎……”的大字，但是领队突然发现，另一旁穿着“教”和“主”字文化衫的 Orzer 却不太和谐。

为了简单描述这个不和谐的队列，我们用 `j` 替代“教”，`z` 替代“主”。而一个 `j` 与 `z` 组成的序列则可以描述当前的队列。为了让教主看得尽量舒服，你必须调整队列，使得 `jz` 子串尽量多。每次调整你可以交换任意位置上的两个人，也就是序列中任意位置上的两个字母。而因为教主马上就来了，时间仅够最多做 $K$ 次调整（当然可以调整不满 $K$ 次），所以这个问题交给了你。

## 说明/提示

**【样例说明】**

第 $1$ 次交换位置 $1$ 上的 `z` 和位置 $4$ 上的 `j`，变为 `jzzzj`；

第 $2$ 次交换位置 $4$ 上的 `z` 和位置 $5$ 上的 `j`，变为 `jzzjz`。

最后的串有 $2$ 个 `jz` 子串。

**【数据规模与约定】**

对于 $10 \%$ 的数据，有 $N \le 10$；  
对于 $30 \%$ 的数据，有 $K \le 10$；  
对于 $40 \%$ 的数据，有 $N \le 50$；  
对于 $100 \%$ 的数据，有 $1 \le N \le 500$，$1 \le K \le 100$。

## 样例 #1

### 输入

```
5 2 
zzzjj
```

### 输出

```
2
```

# AI分析结果



### 算法分类：动态规划

---

### 题解分析与结论

**核心思路**：通过动态规划记录前 `i` 个字符，交换 `j` 个 `j` 和 `k` 个 `z`，且当前字符为 `j` 或 `z` 时的最大 `jz` 子串数。状态转移需考虑当前字符是否被修改，并保证交换次数相等。

**关键优化**：  
1. **四维状态设计**：`f[i][j][k][0/1]` 表示前 `i` 位，交换 `j` 次 `j`，交换 `k` 次 `z`，当前位为 `j/z` 时的最大子串数。  
2. **状态转移方程**：根据当前字符是否为 `j` 或 `z`，分别处理是否修改当前字符，并累加可能的 `jz` 组合。  
3. **初始化与边界处理**：初始状态设置为负无穷，避免非法状态干扰。

---

### 精选题解

#### 1. 作者：hzoi_liuchang（4星）
**关键亮点**：  
- 明确状态定义与转移逻辑，代码简洁。  
- 正确处理了交换次数相等的约束条件。  
**代码片段**：  
```cpp
memset(f, 128, sizeof(f));
f[0][0][0][1] = 0;
for (int i = 1; i <= n; i++) {
    for (int j = 0; j <= m; j++) {
        for (int k = 0; k <= m; k++) {
            if (s[i] == 'z') {
                f[i][j][k][1] = max(f[i-1][j][k][0]+1, f[i-1][j][k][1]);
                if (k) f[i][j][k][0] = max(f[i-1][j][k-1][0], f[i-1][j][k-1][1]);
            } else {
                f[i][j][k][0] = max(f[i-1][j][k][0], f[i-1][j][k][1]);
                if (j) f[i][j][k][1] = max(f[i-1][j-1][k][0]+1, f[i-1][j-1][k][1]);
            }
        }
    }
}
```

#### 2. 作者：gorokokoro（4星）
**关键亮点**：  
- 指出常见错误（未记录最后一位修改状态）并提供修复方案。  
- 状态转移逻辑严谨，初始化处理完善。  
**代码片段**：  
```cpp
f[0][0][0][1] = 0;
for (int i = 1; i <= n; i++) {
    for (int j = 0; j <= m; j++) {
        for (int k = 0; k <= m; k++) {
            f[i][j][k][a[i]] = max(f[i-1][j][k][0] + a[i], f[i-1][j][k][1]);
            if (a[i]) {
                if (k) f[i][j][k][0] = max(f[i-1][j][k-1][0], f[i-1][j][k-1][1]);
            } else {
                if (j) f[i][j][k][1] = max(f[i-1][j-1][k][0] + 1, f[i-1][j-1][k][1]);
            }
        }
    }
}
```

---

### 最优技巧总结
1. **状态设计**：四维数组记录当前字符状态，确保转移时能正确累加 `jz` 子串。  
2. **交换次数约束**：最终答案需在 `j == k` 时取最大值，保证交换合法。  
3. **初始化处理**：初始状态设为极小值，避免非法状态干扰结果。

---

### 拓展与举一反三
- **同类题目**：  
  1. [P1273 有线电视网](https://www.luogu.com.cn/problem/P1273)（状态设计）  
  2. [P1156 垃圾陷阱](https://www.luogu.com.cn/problem/P1156)（动态规划状态转移）  
  3. [P1541 乌龟棋](https://www.luogu.com.cn/problem/P1541)（多维状态动态规划）  

- **调试心得**：  
  - **边界初始化**：必须明确初始状态，如 `f[0][0][0][1] = 0` 表示空字符串初始状态。  
  - **非法状态排除**：使用极小值初始化避免错误转移。

---
处理用时：47.58秒
# 题目信息

# 点和线

## 题目描述

平面上有一些点，你可以用直线将两点连接起来。那么有多少种方法可以把这些点连续地连起来，使得任何两个线都不交叉。

显然，三个点只有一种方法。四个点最多只有 $3$ 种方法。写一个程序计算方法总数。


## 说明/提示

最多只有 $10$  个点。

- 必须从一个点出发，途径所有点回到起点的路径才会被统计。

- 两个方案不相同当且仅当围成的简单多边形不同。

## 样例 #1

### 输入

```
100 -10
-200 0
45 7
0 0
```

### 输出

```
3
```

# AI分析结果



### 算法分类
**深度优先搜索 DFS**

---

### 题解分析与结论
所有题解均围绕**DFS生成排列+向量叉乘判断线段相交**的核心思路展开。  
**关键难点**在于正确判断线段相交（排除端点重合的情况）和剪枝优化。  
**最优思路**：在DFS过程中动态剪枝，每次添加新边时立即检查与已有边的相交性，避免生成无效排列；使用向量叉乘的正负性判断跨立条件。

---

### 精选题解

#### 1. 作者：H_D_NULL （5星）
**关键亮点**：  
- 代码简洁高效，DFS中直接使用`Judge`函数动态剪枝  
- 叉乘判断部分用单函数`AC`封装，逻辑清晰  
- 正确处理端点重合不算交叉的情况  

**核心代码**：
```cpp
bool AC(dr a,dr b,dr c,dr d){
    return (Cross(c,d,a)*Cross(c,d,b)<0&&Cross(a,b,c)*Cross(a,b,d)<0);
}

void Dfs(int num){
    if(num==n+1){
        if(Judge(num,1)) ans++;
        return;
    }
    for(int i=2;i<=n;i++){
        if(!vis[i]&&Judge(num,i)){ // 动态剪枝
            vis[i]=1;
            Dfs(num+1);
            vis[i]=0;
        }
    }
}
```

#### 2. 作者：b6e0_ （4星）
**关键亮点**：  
- 详细解释叉乘判断原理  
- 预处理最后一条边的相交性检查  
- 正确解决排列重复计数问题（除以2n）  

**剪枝技巧**：
```cpp
for(j=1;j<d-2;j++) // 检查新边与之前所有边的相交性
    if(intersection(...)) break;
if(j>=d-2) dfs(...); // 仅当不冲突时才继续搜索
```

#### 3. 作者：一水清浅 （4星）
**关键亮点**：  
- 全面讨论线段相交的各种边界情况  
- 预处理相交关系加速判断  
- 处理共线情况的完整逻辑  

**调试心得**：
> "单纯考虑线段相交会把端点算作相交，但题目允许端点重合。这点让我调试了1个多小时才发现问题"

---

### 推荐相似题目
1. P2789 直线交点数（几何排列计数）
2. P1355 图形面积（几何相交判断）  
3. CF598C Nearest vectors（向量极角排序）

---
处理用时：41.58秒
# 题目信息

# [NOIP 2010 普及组] 导弹拦截

## 题目描述

经过 $11$ 年的韬光养晦，某国研发出了一种新的导弹拦截系统，凡是与它的距离不超过其工作半径的导弹都能够被它成功拦截。当工作半径为 $0$ 时，则能够拦截与它位置恰好相同的导弹。但该导弹拦截系统也存在这样的缺陷：每套系统每天只能设定一次工作半径。而当天的使用代价，就是所有系统工作半径的平方和。

某天，雷达捕捉到敌国的导弹来袭。由于该系统尚处于试验阶段，所以只有两套系统投入工作。如果现在的要求是拦截所有的导弹，请计算这一天的最小使用代价。

## 说明/提示

两个点 $(x_1,y_1),(x_2,y_2)$ 之间距离的平方是 $(x_1-x_2)^2+(y_1-y_2)^2$。

两套系统工作半径 $r_1,r_2$ 的平方和，是指 $r_1,r_2$ 分别取平方后再求和，即 $r_1^2+r_2^2$。

### 样例 1 说明

样例 $1$ 中要拦截所有导弹，在满足最小使用代价的前提下，两套系统工作半径的平方分别为 $18$ 和 $0$。

### 样例 2 说明

样例 $2$ 中的导弹拦截系统和导弹所在的位置如下图所示。要拦截所有导弹，在满足最小使用代价的前提下，两套系统工作半径的平方分别为 $20$ 和 $10$。

![](https://cdn.luogu.com.cn/upload/image_hosting/cvgomt03.png)

【数据范围】。

- 对于 $10\%$ 的数据，$N=1$。
- 对于 $20\%$ 的数据，$1\le N\le 2$。
- 对于 $40\%$ 的数据，$1\le N\le 100$。
- 对于 $70\%$ 的数据，$1\le N\le 1000$。
- 对于 $100\%$ 的数据，$1\le N\le 10^5$，且所有坐标分量的绝对值都不超过 $1000$。

NOIP2010 普及组 第三题

## 样例 #1

### 输入

```
0 0 10 0
2
-3 3
10 0```

### 输出

```
18```

## 样例 #2

### 输入

```
0 0 6 0
5
-4 -2
-2 3
4 0
6 -2
9 1```

### 输出

```
30```

# AI分析结果



### 算法分类
**贪心**

### 综合分析与结论
题目要求用两个导弹系统拦截所有导弹，使得半径平方和最小。所有题解均采用**贪心+排序**的核心思路：将导弹按到系统1的距离排序，预处理系统2的后缀最大值，枚举分界点计算最小值。关键点在于正确处理边界条件（如全由系统2拦截的情况）。

---

### 精选题解

#### 1. qhr2023 [★★★★★]
**关键亮点**：代码极度精简（仅15行），利用`pair`存储双系统距离，排序后逆序枚举分界点并动态维护系统2的最大半径。正确处理了边界情况（枚举到0的情况）。
```cpp
#include <bits/stdc++.h>
using namespace std;
pair<int, int> a[100005];
int main () {
    int x1, y1, x2, y2, n, ans=1e9;
    cin >> x1 >> y1 >> x2 >> y2 >> n;
    for (int i=1, x, y; i<=n; ++i)
        cin >> x >> y,
        a[i] = {(x1-x)*(x1-x)+(y1-y)*(y1-y), (x-x2)*(x-x2)+(y-y2)*(y-y2)};
    sort(a+1, a+n+1);
    for (int i=n, r2=0; i>=0; --i) 
        ans = min(ans, a[i].first + r2),
        r2 = max(r2, a[i].second);
    cout << ans;
    return 0;
}
```

#### 2. TEoS [★★★★☆]
**关键亮点**：预处理后缀最大值数组，逻辑清晰易理解。通过结构体存储双系统距离，排序后从后往前递推预处理。
```cpp
sort(di+1,di+n+1,cmp);
for(int i=n;i>0;i--) // 预处理后缀最大值
    di[i].d2 = max(di[i].d2, di[i+1].d2);
for(int i=0;i<=n;i++) // 枚举分界点
    minn = min(di[i].d1 + di[i+1].d2, minn);
```

#### 3. 暗ざ之殇 [★★★★☆]
**个人心得**：强调必须枚举到0的边界条件，避免被hack数据卡。通过`nxt`数组预处理系统2的后缀最大值，保证时间复杂度。
```cpp
nxt[n] = dis2[a[n].id];
for(int i=n-1;i>=1;i--) // 预处理后缀最大值
    nxt[i] = max(dis2[a[i].id], nxt[i+1]);
for(int i=n-1;i>=1;i--)
    minx = min(minx, a[i].dis1 + nxt[i+1]);
printf("%d", min(minx, nxt[1])); // 处理全由系统2拦截的情况
```

---

### 最优思路总结
1. **排序预处理**：将导弹按到系统1的距离升序排序。
2. **后缀最大值**：预处理导弹到系统2的距离的后缀最大值数组。
3. **枚举分界点**：从后往前枚举系统1的覆盖范围，动态维护系统2的当前最大半径。
4. **边界处理**：必须考虑全由系统2拦截的情况（即分界点枚举到0）。

---

### 拓展与类似题目
- **同类贪心策略题**：P1223 排队接水（排序贪心）、P1090 合并果子（优先队列贪心）、P1106 删数问题（贪心选择）。
- **优化技巧**：预处理后缀数组、动态维护最大值、避免浮点运算（直接使用平方值）。

---
处理用时：55.31秒
# 题目信息

# 队列安排

## 题目描述

一个学校里老师要将班上 $N$ 个同学排成一列，同学被编号为 $1\sim N$，他采取如下的方法：

1. 先将 $1$ 号同学安排进队列，这时队列中只有他一个人；

2. $2\sim N$ 号同学依次入列，编号为 $i$ 的同学入列方式为：老师指定编号为 $i$ 的同学站在编号为 $1\sim(i-1)$ 中某位同学（即之前已经入列的同学）的左边或右边；

3. 从队列中去掉 $M$ 个同学，其他同学位置顺序不变。

在所有同学按照上述方法队列排列完毕后，老师想知道从左到右所有同学的编号。

## 说明/提示

**【样例解释】**

将同学 $2$ 插入至同学 $1$ 左边，此时队列为：

`2 1`

将同学 $3$ 插入至同学 $2$ 右边，此时队列为：

`2 3 1`  

将同学 $4$ 插入至同学 $1$ 左边，此时队列为：

`2 3 4 1`  

将同学 $3$ 从队列中移出，此时队列为：

`2 4 1`  

同学 $3$ 已经不在队列中，忽略最后一条指令

最终队列：

`2 4 1`  

**【数据范围】**

对于 $20\%$ 的数据，$1\leq N\leq 10$。

对于 $40\%$ 的数据，$1\leq N\leq 1000$。

对于 $100\%$ 的数据，$1<M\leq N\leq 10^5$。


## 样例 #1

### 输入

```
4
1 0
2 1
1 0
2
3
3```

### 输出

```
2 4 1```

# AI分析结果



### 算法分类
**模拟**（双向链表操作）

### 综合分析与结论
本题需高效处理动态插入与删除操作，双向链表是最优选择。题解核心思路为用数组模拟双向链表，维护左右指针实现 O(1) 时间复杂度的插入/删除。关键难点在于处理链表头尾边界条件及正确更新指针。

---

### 精选题解与亮点

#### 1. BT狸——Frozen（5星）
**亮点**：  
- 引入虚拟头节点（0号）简化链表操作，避免头尾特判。  
- 图解插入过程，逻辑清晰易懂。  
- 标记删除法避免频繁指针调整，代码简洁高效。  
**核心代码**：  
```cpp
struct T { int l, r, d; } t[mx];
void add(int i, int k, int f) { // f=1右插，f=0左插
    if(f == 1) {
        t[k].r = t[i].r;
        t[k].l = i;
        t[i].r = k;
        t[t[k].r].l = k;
    } else { /* 类似逻辑处理左插 */ }
}
// 输出时从虚拟头出发遍历有效节点
for(int i = t[0].r; i; i = t[i].r) 
    if(!t[i].d) cout << i << " ";
```

#### 2. 夜刀神十香ღ（4星）  
**亮点**：  
- 结构体封装左右指针，代码可读性强。  
- 删除时更新头节点，避免输出错误。  
**心得**：  
> "删除操作若影响头节点，需将头节点设为右节点，否则遍历会漏数据。"

#### 3. 樱式分解（4星）  
**亮点**：  
- 简洁的数组实现，适合快速编码。  
- 引入 `vis[]` 数组标记删除，逻辑清晰。  
**核心代码**：  
```cpp
int l[maxn], r[maxn], vis[maxn];
// 插入左边
l[i] = l[k], r[i] = k;
r[l[k]] = i, l[k] = i;
// 删除时更新相邻节点指针
l[r[x]] = l[x], r[l[x]] = r[x];
```

---

### 关键技巧总结
1. **虚拟头节点**：简化链表首尾插入的边界判断。  
2. **数组模拟链表**：比指针更高效，适合固定规模数据。  
3. **标记删除法**：避免频繁调整指针，遍历时跳过已删节点。  

---

### 拓展建议
- **同类问题**：约瑟夫环（动态删除）、LRU缓存（快速插入/淘汰）。  
- **推荐题目**：  
  1. [P1996 约瑟夫问题](https://www.luogu.com.cn/problem/P1996)  
  2. [P1160 队列安排](https://www.luogu.com.cn/problem/P1160)（本题）  
  3. [P2058 海港](https://www.luogu.com.cn/problem/P2058)（队列维护时间窗口）

---
处理用时：55.18秒
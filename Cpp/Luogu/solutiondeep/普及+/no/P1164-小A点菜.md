# 题目信息

# 小A点菜

## 题目背景

uim 神犇拿到了 uoi 的 ra（镭牌）后，立刻拉着基友小 A 到了一家……餐馆，很低端的那种。

uim 指着墙上的价目表（太低级了没有菜单），说：“随便点”。


## 题目描述

不过 uim 由于买了一些书，口袋里只剩 $M$ 元 $(M \le 10000)$。

餐馆虽低端，但是菜品种类不少，有 $N$ 种 $(N \le 100)$，第 $i$ 种卖 $a_i$ 元 $(a_i \le 1000)$。由于是很低端的餐馆，所以每种菜只有一份。

小 A 奉行“不把钱吃光不罢休”的原则，所以他点单一定刚好把 uim 身上所有钱花完。他想知道有多少种点菜方法。

由于小 A 肚子太饿，所以最多只能等待 $1$ 秒。


## 说明/提示

2020.8.29，增添一组 hack 数据 by @yummy

## 样例 #1

### 输入

```
4 4
1 1 2 2
```

### 输出

```
3
```

# AI分析结果



算法分类：动态规划

**综合分析与结论**  
本题属于动态规划中的 0-1 背包变种问题，核心是计算恰好装满背包的方案数。所有题解均基于动态规划思想，通过二维或一维数组记录状态转移。其中一维数组优化方案因空间效率高、代码简洁成为最优解。

---

**精选题解及亮点**  

1. **Dream_zhc（5星）**  
   - 亮点：清晰解释二维转一维的优化思路，配合逆序枚举图解说明，代码简洁易读。  
   - 关键代码：  
     ```cpp
     int f[10010] = {0};
     f[0] = 1; // 初始化：0元有1种方案（不选）
     for (int i = 1; i <= n; i++)
         for (int j = m; j >= a[i]; j--)
             f[j] += f[j - a[i]]; // 逆序更新避免覆盖
     ```

2. **康师傅（4星）**  
   - 亮点：边读入边处理数据，节省内存，代码高效。  
   - 心得：强调最后处理当前菜品价格以排除干扰，避免重复计数。  
   - 关键代码：  
     ```cpp
     for (int i = 1; i <= n; ++i) {
         scanf("%d", &a);
         for (int j = m; j > a; --j) // 先处理大金额避免覆盖
             dp[j] += dp[j - a];
         ++dp[a]; // 单独处理刚好等于的情况
     }
     ```

3. **衡屿睿（4星）**  
   - 亮点：基础二维DP模板，分情况讨论状态转移，适合初学者理解。  
   - 关键代码：  
     ```cpp
     int f[101][10001] = {0};
     for (int i = 1; i <= n; i++) {
         for (int j = 1; j <= m; j++) {
             if (j == a[i]) f[i][j] = f[i-1][j] + 1;
             else if (j > a[i]) f[i][j] = f[i-1][j] + f[i-1][j-a[i]];
             else f[i][j] = f[i-1][j];
         }
     }
     ```

---

**核心优化技巧**  
- **一维数组逆序更新**：避免状态覆盖，确保每个物品只选一次。  
- **初始化 f[0]=1**：定义“恰好花费0元”的基础状态。  
- **分情况转移**：处理 j < a[i]、j == a[i]、j > a[i] 三种边界条件。

**拓展应用**  
类似问题可参考：  
1. P1048 [NOIP2005 普及组] 采药（最大价值）  
2. P1060 [NOIP2006 普及组] 开心的金明（加权价值）  
3. P1776 宝物筛选（多重背包优化）  

**调试心得摘录**  
- **Dream_zhc**：逆序枚举是优化的关键，正序会导致重复计数。  
- **康师傅**：单独处理当前菜品价格（++dp[a]）避免干扰后续状态。  
- **Eric_cao**：Python输入需循环读取多行数据，否则会因数据分两行报错。

---
处理用时：41.76秒
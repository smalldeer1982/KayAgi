# 题目信息

# 打保龄球

## 题目描述

打保龄球是用一个滚球去打击十个站立的柱，将柱击倒。一局分十轮，每轮可滚球一次或多次，以击倒的柱数为依据计分。一局得分为十轮得分之和，而每轮的得分不仅与本轮滚球情况有关，还可能与后续一两轮的滚球情况有关。即某轮某次滚球击倒的柱数不仅要计入本轮得分，还可能会计入前一两轮得分。具体的滚球击柱规则和计分方法如下：

1. 若某一轮的第一次滚球就击倒全部十个柱，则本轮不再滚球（若是第十轮则还需另加两次滚球，不妨称其为第十一轮和第十二轮，并不是所有的情况都需要滚第十一轮和第十二轮球）。该轮得分为本次击倒柱数 $10$ 与以后两次滚球所击倒柱数之和。

2. 若某一轮的第一次滚球未击倒十个柱，则可对剩下未倒的柱再滚球一次。如果这两次滚球击倒全部十个柱，则本轮不再滚球（若是第十轮则还需另加一次滚球），该轮得分为这两次共击倒柱数 $10$ 与以后一次滚球所击倒柱数之和。

3. 若某一轮两次滚球未击倒全部十个柱，则本轮不再继续滚球，该轮得分为这两次滚球击倒的柱数之和。   

总之，若―轮中一次滚球或两次滚球击倒十个柱，则本轮得分是本轮首次滚球开始的连续三次滚球击倒柱数之和（其中有一次或两次不是本轮滚球）。若一轮内二次滚球击倒柱数不足十个，则本轮得分即为这两次击倒柱数之和。下面以实例说明如下(字符 `/` 表示击倒当前球道上的全部的柱)：

| 轮 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 |
| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: |
| 击球情况  |  /  |  /  |  /  |  72 |  9/ |  81  | 8/  |  / |   9/  |  /  |  8/ |
| 各轮得分 |  30  | 27  | 19 |  9   |18   | 9  | 20  | 20 |  20 |  20|
|累计总分 |  30  | 57  |76 |  85|  103 |  112 | 132  |152 | 172 | 192|

现在请你编写一个保龄球实时计分程序，用来计算和显示某轮结束后的得分情况。若某轮的得分暂时无法算出，则**不显示**该轮得分（不输出）。


## 样例 #1

### 输入

```
/ / / 72 9/ 81 8/ / 9/ / 8/```

### 输出

```
30 27 19 9 18 9 20 20 20 20 
30 57 76 85 103 112 132 152 172 192```

# AI分析结果



**算法分类**: 模拟

---

### 综合分析与结论
题目要求模拟保龄球计分规则，核心难点在于处理不同击倒情况下的得分叠加逻辑（尤其是后续滚球的依赖关系），并正确判断得分是否可实时计算。各题解均围绕如何解析输入、分轮次计算得分展开，关键差异在于对后续滚球数据的边界判断和代码实现方式。

---

### 高分题解选录
#### 1. 作者：袁宇轩 (4星)
**关键亮点**:  
- 通过 `st` 记录每轮起点，`rest` 和 `flag` 结合模拟三次滚球，逻辑清晰。  
- 处理了第十轮及后续虚拟轮次的情况，通过 `st+2` 的滚球范围判断得分是否可计算。  
- 代码简洁，通过 `sum[i] = -1` 标记不可计算的轮次，最终输出时统一处理。  

**代码核心实现**:
```cpp
int st = 1; // 每轮起点
for (int i = 1; i <= 10; i++) {
    int rest = 10, flag = 1;
    for (int j = st; j <= st + 2; j++) { // 模拟三次滚球
        if (j > n) { sum[i] = -1; break; } // 数据不足，标记不可计算
        if (rest == 0) rest = 10, flag = 0; // 已击倒全部
        if (a[j] == '/') sum[i] += rest; // 处理击倒逻辑
        else sum[i] += a[j] - '0';
    }
    if (sum[i] != -1) { // 更新起点
        if (a[st] == '/') st++;
        else st += 2;
    }
}
```

---

### 关键思路总结
1. **分轮次处理**: 每轮独立计算得分，通过标记起点和剩余柱子数动态判断击倒情况。  
2. **后续滚球依赖**: 若当前轮需要后续滚球数据（如全中或补中），需检查后续输入是否足够，不足则标记不可计算。  
3. **虚拟轮次处理**: 第十轮可能触发额外滚球，需在数据中预留第十一、十二轮的存储空间。  

---

### 相似题目推荐
1. [P1563 玩具谜题](https://www.luogu.com.cn/problem/P1563) - 复杂方向模拟  
2. [P1067 多项式输出](https://www.luogu.com.cn/problem/P1067) - 规则驱动的字符串处理  
3. [P1003 铺地毯](https://www.luogu.com.cn/problem/P1003) - 覆盖规则模拟

---
处理用时：43.87秒
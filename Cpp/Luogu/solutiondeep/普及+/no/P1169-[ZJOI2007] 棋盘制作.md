# 题目信息

# [ZJOI2007] 棋盘制作

## 题目描述

国际象棋是世界上最古老的博弈游戏之一，和中国的围棋、象棋以及日本的将棋同享盛名。据说国际象棋起源于易经的思想，棋盘是一个 $8 \times 8$ 大小的黑白相间的方阵，对应八八六十四卦，黑白对应阴阳。

而我们的主人公 `小Q`，正是国际象棋的狂热爱好者。作为一个顶尖高手，他已不满足于普通的棋盘与规则，于是他跟他的好朋友 `小W` 决定将棋盘扩大以适应他们的新规则。

`小Q` 找到了一张由 $N \times M$ 个正方形的格子组成的矩形纸片，每个格子被涂有黑白两种颜色之一。`小Q` 想在这种纸中裁减一部分作为新棋盘，当然，他希望这个棋盘尽可能的大。

不过 `小Q` 还没有决定是找一个正方形的棋盘还是一个矩形的棋盘（当然，不管哪种，棋盘必须都黑白相间，即相邻的格子不同色），所以他希望可以找到最大的正方形棋盘面积和最大的矩形棋盘面积，从而决定哪个更好一些。

于是 `小Q` 找到了即将参加全国信息学竞赛的你，你能帮助他么？


## 说明/提示

对于 $20\%$ 的数据，$N, M ≤ 80$

对于 $40\%$ 的数据，$N, M ≤ 400$

对于 $100\%$ 的数据，$N, M ≤ 2000$


## 样例 #1

### 输入

```
3 3
1 0 1
0 1 0
1 0 0
```

### 输出

```
4
6
```

# AI分析结果



### 算法分类
动态规划（悬线法）

### 综合分析与结论
题目核心在于寻找满足相邻格子颜色不同的最大正方形和矩形。所有题解均围绕悬线法展开，其核心是预处理每个点的左右扩展边界和向上扩展高度，通过动态规划递推求解。关键技巧包括：棋盘颜色转换预处理、悬线法三重状态维护、单调栈优化等。

---

### 精选题解（评分≥4星）

1. **顾z（★★★★★）**  
   **亮点**：悬线法经典实现，清晰定义 left/right/up 数组，给出递推公式与正确性证明，代码可读性强  
   **心得**：通过图示验证悬线法正确性，解释为何红色区域会被后续处理覆盖  
   ```cpp
   // 预处理左右边界
   for(int j=2; j<=m; j++) 
       if(color != prev) left[i][j] = left[i][j-1];
   for(int j=m-1; j>0; j--)
       if(color != next) right[i][j] = right[i][j+1];
   // 递推悬线状态
   if(与上方颜色不同){
       left[i][j] = max(left[i][j], left[i-1][j]);
       right[i][j] = min(right[i][j], right[i-1][j]);
       up[i][j] = up[i-1][j]+1;
   }
   ```

2. **Felis（★★★★☆）**  
   **亮点**：通过木桶原理解释悬线法正确性，提出"悬线高度决定矩形高度"的直观理解  
   **技巧**：将棋盘转换为全0/1矩阵，复用最大子矩阵解法  
   ```cpp
   // 颜色转换预处理
   if((i+j)%2 == 0) a[i][j] ^= 1;
   // 悬线法核心
   up[i][j] = (a[i][j]==a[i-1][j]) ? up[i-1][j]+1 : 1;
   ```

3. **lzoi_lhy（★★★★☆）**  
   **亮点**：单调栈优化，逐行处理时维护高度直方图，空间优化至O(n)  
   **心得**：通过分治思想处理颜色突变点，实时更新栈结构  
   ```cpp
   while(top && t[sta[top]]>t[j]){
       ans = max(ans, (j-sta[top])*t[sta[top]]);
       top--;
   }
   ```

---

### 关键思路总结
1. **棋盘转换**：通过 `(i+j)%2` 将棋盘转换为全0/1矩阵，统一问题类型  
2. **悬线法三要素**：
   - `left[i][j]`: 向左能扩展到的最小列号  
   - `right[i][j]`: 向右能扩展到的最大列号  
   - `up[i][j]`: 向上连续满足条件的行数  
3. **递推更新**：当前行状态由上一行与当前行共同决定，取交集（max左边界，min右边界）  
4. **实时计算**：对每个点计算 `(right-left+1)*up` 作为矩形面积，`min(宽,高)^2` 作为正方形面积  

---

### 拓展训练
1. **最大全1子矩阵**：[P4147 玉蟾宫](https://www.luogu.com.cn/problem/P4147)  
2. **障碍物处理**：[P2701 巨大的牛棚](https://www.luogu.com.cn/problem/P2701)  
3. **经典悬线法**：[P1387 最大正方形](https://www.luogu.com.cn/problem/P1387)  

### 核心代码实现
悬线法预处理与状态转移：
```cpp
for(int i=1; i<=n; i++) {
    for(int j=1; j<=m; j++) {
        if(i>1 && a[i][j] != a[i-1][j]) {
            left[i][j] = max(left[i][j], left[i-1][j]);
            right[i][j] = min(right[i][j], right[i-1][j]);
            up[i][j] = up[i-1][j] + 1;
        }
        int width = right[i][j] - left[i][j] + 1;
        ans_rect = max(ans_rect, width * up[i][j]);
        ans_square = max(ans_square, min(width, up[i][j]) * min(width, up[i][j]));
    }
}
```

---
处理用时：61.35秒
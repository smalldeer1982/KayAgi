# 题目信息

# 安全逃离（数据有误）

## 题目背景

**注意本题数据有误，请暂时不要提交**

## 题目描述

农夫`john`最近在研究如果发生重大事故，如何让农场里的奶牛逃离问题。他想要确信在紧急情况下，所有的奶牛都有一个安全逃离方案。因为在紧急情况下，奶牛们都会失去观察和判断能力，所以最近`john`一直在教奶牛们逃离的方法，他的方法很简单，就是任何时候都只向北方或东方逃离，北方是行坐标减1的方向，东方是列坐标加1的方向。奶牛们虽笨，不过这一点事关自己的生命，所以他们牢记在心，而且也一定会这么做。

当然也会出问题，奶牛们在逃离的方向上会横冲直撞，为了阻止奶牛之间互相冲撞造成伤害，`john`要求任何一个奶牛的逃离路线不能经过其它奶牛的初始位置。一个逃离方案是安全的如果它能够满足上面的要求，反之它就是不安全的。

奶牛们所在的土地（农场）被划分成了$r$行和$c$列的一个矩形地图。奶牛们都待在这个矩形中的某一个位置。

请帮助`john`确定给定的一个地图上是否存在一个安全的逃离方案。

比如，下面的两个图：

左边的例子表示了一个能够安全逃离的地图，因为没有任何一个奶牛的逃离路线上包括其他奶牛。右边的例子表示了一个不安全的地图，因为位于$(4,1)$的奶牛不论是向东逃离还是向北逃离，它的路线上都会有别的奶牛，从这个图中拿掉任意一头奶牛，这个地图都会变成安全的。

```plain
  安全     不安全
- ||||C--  C.....
- ||||C--  ^.....
- |C||C--  |.....
- CC++---  C-->C.
- ..CCC--  ......
```

`C` 表示奶牛，直线表示逃离路线。

## 样例 #1

### 输入

```
5 5
5
1 1
2 4
3 1
2 2
2 1
```

### 输出

```
1
5
```

# AI分析结果



### 算法分类
**枚举**

---

### 综合分析与结论
题目核心是判断奶牛能否安全逃离，或通过删除特定奶牛达成安全状态。所有题解均采用**暴力枚举**思路：  
1. 先判断所有奶牛是否全部安全  
2. 若存在不安全奶牛，枚举删除每个奶牛后重新判断整体安全性  
3. 输出符合条件的删除方案或判定无解  

核心难点在于：  
- 安全条件判定：北向和东向是否存在其他奶牛  
- 删除后的状态恢复：每次枚举删除后需还原现场  
- 输入数据异常处理：行末可能存在多余字符需清空  

---

### 精选题解分析

#### 题解1 - jacky567 (4星)
**关键亮点**  
- 双思路对比：模拟法+预处理统计法，覆盖不同优化方向  
- 输入处理技巧：`gets(s)`处理行尾多余字符避免数据错误  
- 状态恢复：删除奶牛后及时恢复`m[a[i].x][a[i].y]=i`避免污染后续枚举  

**代码核心**  
```cpp
int qaq() {  // 全局安全检测函数
  for (int i=1; i<=h; i++) 
    for (int j=1; j<=l; j++) 
      if (m[i][j] && !anquan(i,j)) return 0; 
  return 1;
}
```

---

#### 题解2 - Eraine (4星)
**关键亮点**  
- 结构体清晰管理奶牛坐标  
- 独立安全判定函数`p()`复用性强  
- 输出格式严格按字典序处理  

**代码核心**  
```cpp
bool p(int x,int y) {  // 单个奶牛安全检测
  bool north_safe = true;
  for (int i=x-1; i>0; i--) 
    if (a[i][y]) north_safe = false; 
  for (int i=y+1; i<=c; i++) 
    if (a[x][i] && !north_safe) return true; 
  return false;
}
```

---

#### 题解3 - 梧桐灯 (4星)
**关键亮点**  
- 数据异常处理：`gets(r)`确保输入正确性  
- 三重循环暴力枚举：删除每个奶牛后重新全盘检测  
- 输出优化：发现可行解立即标记避免重复输出  

**代码核心**  
```cpp
for (int i=1; i<=k; i++) { // 枚举删除i号奶牛
  a[x[i]][y[i]] = false; 
  bool safe = true;
  for (int j=1; j<=k; j++) { // 检查剩余奶牛
    if (i == j) continue;
    // 安全检测逻辑...
  }
  a[x[i]][y[i]] = true; // 恢复现场
}
```

---

### 关键技巧总结
1. **输入处理**：用`gets()`或类似方法清空行尾异常数据  
2. **状态恢复**：枚举删除操作后必须恢复原始数据避免脏状态  
3. **安全判定优化**：北向和东向分开检测，避免冗余计算  
4. **暴力枚举框架**：外层循环删除对象，中层检测剩余元素，内层判断条件  

---

### 拓展训练
1. **P1219 八皇后** - 经典枚举+剪枝问题  
2. **P1036 选数** - 组合枚举与条件判断  
3. **P1518 两只奶牛** - 网格移动模拟与碰撞检测  

---

### 调试经验摘录
- "输入数据末尾可能有垃圾字符，必须用`gets()`清空" —— 数据预处理易疏漏点  
- "删除奶牛后要立即恢复，否则下次循环会删除两只" —— 状态管理关键细节  
- "字典序输出要求从小到大逐个检测" —— 输出格式易错点

---
处理用时：62.76秒
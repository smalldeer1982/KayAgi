# 题目信息

# 打砖块

## 题目描述

小红很喜欢玩一个叫打砖块的游戏，这个游戏的规则如下：

在刚开始的时候，有 $n$ 行 $m$ 列的砖块，小红有 $k$ 发子弹。小红每次可以用一发子弹，打碎某一列当前处于这一列最下面的那块砖，并且得到相应的得分。（如图所示）

![](https://cdn.luogu.com.cn/upload/image_hosting/twgirdp6.png)

某些砖块在打碎以后，还可能将得到一发子弹的奖励。最后当所有的砖块都打碎了，或者小红没有子弹了，游戏结束。

小红在游戏开始之前，就已经知道每一块砖在打碎以后的得分，并且知道能不能得到一发奖励的子弹。小红想知道在这次游戏中她可能的最大得分，可是这个问题对于她来说太难了，你能帮帮她吗？


## 说明/提示

对于 $20\%$ 的数据，满足 $1  \le n,m  \le 5$，$1  \le k  \le 10$，所有的字符 $c$ 都为 `N`。

对于 $50\%$ 的数据，满足 $1  \le n,m  \le 200$，$1  \le k  \le 200$，所有的字符 $c$ 都为 `N`。

对于 $100\%$ 的数据，满足 $1  \le n,m  \le 200$，$1  \le k  \le 200$，字符 $c$ 可能为 `Y`。

对于 $100\%$ 的数据，所有的 $f$ 值满足 $1  \le f  \le 10000$。


## 样例 #1

### 输入

```
3 4 2
9 N 5 N 1 N 8 N
5 N 5 Y 5 N 5 N
6 N 2 N 4 N 3 N```

### 输出

```
13```

# AI分析结果



**算法分类**  
动态规划  

---

**题目分析与题解总结**  
该题为经典分组背包变种，需结合子弹奖励机制设计状态转移。核心难点在于处理子弹的"借还"逻辑（即打碎Y砖块获得的子弹可被后续使用）。各题解普遍采用以下思路：  
1. **预处理每列**：对每列单独处理，计算打不同数量子弹时的得分，区分最后一发子弹是否打在N砖块（能否获得后续Y的收益）。  
2. **状态设计**：多数题解使用二维状态 `dp[i][j][0/1]`，表示前i列使用j发子弹，最后一发是否打在第i列。部分题解通过区分是否"借用"子弹来处理状态转移。  
3. **转移方程**：在分组背包框架下，根据是否消耗子弹、是否获得奖励子弹设计转移条件，确保状态转移不产生后效性。  

---

**高星题解推荐**  

1. **作者：I_AM_HelloWord（4.5星）**  
   **亮点**：  
   - 引入"借子弹"的生动比喻，清晰解释状态转移逻辑  
   - 预处理部分将Y砖块压缩到N砖块，简化计算  
   **关键代码**：  
   ```cpp
   // 预处理每列得分
   for(int j=1;j<=m;j++) {
       int cnt = 0;
       for(int i=n;i>=1;i--) {
           if(b[i][j]) sy[j][cnt] += a[i][j];
           else {
               cnt++;
               sy[j][cnt] = sy[j][cnt-1] + a[i][j];
               sn[j][cnt] = sy[j][cnt-1] + a[i][j];
           }
       }
   }
   // 状态转移
   for(int x=1;x<=m;x++) {
       for(int y=0;y<=k;y++) {
           for(int z=0;z<=min(n,y);z++) {
               fy[x][y] = max(fy[x][y], fy[x-1][y-z]+sy[x][z]);
               if(z) fn[x][y] = max(fn[x][y], fy[x-1][y-z]+sn[x][z]);
               if(y-z>0) fn[x][y] = max(fn[x][y], fn[x-1][y-z]+sy[x][z]);
           }
       }
   }
   ```

2. **作者：Azuree（4星）**  
   **亮点**：  
   - 详细分析部分分与正解的区别  
   - 明确区分打N/Y的状态转移路径  
   **关键思路**：  
   ```cpp
   // 状态转移核心逻辑
   for(int j=1;j<=m;j++) {
       for(int i=0;i<=k;i++) {
           for(int l=0;l<=min(n,i);l++) {
               f[j][i][1] = max(f[j][i][1], f[j-1][i-l][1] + v[j][l][1]);
               if(l) f[j][i][0] = max(f[j][i][0], f[j-1][i-l][1] + v[j][l][0]);
               if(i > l) f[j][i][0] = max(f[j][i][0], f[j-1][i-l][0] + v[j][l][1]);
           }
       }
   }
   ```

3. **作者：psoet（4星）**  
   **亮点**：  
   - 提出"最后一发必为N砖块"的关键观察  
   - 将状态划分为是否在[1,j]列结束射击  
   **心得摘录**：  
   > "最后一发子弹如果打在Y砖块，必然还有子弹剩余，这与游戏结束条件矛盾。这个观察大幅简化了状态设计"

---

**最优技巧总结**  
1. **预处理技巧**：对每列自底向上计算，将连续的Y砖块收益合并到其下方首个N砖块  
2. **状态设计**：使用三维状态 `dp[列][子弹数][结束位置]` 或二维状态加辅助数组，区分是否消耗子弹  
3. **转移优化**：在分组背包框架中，通过子弹借还机制合并收益，避免后效性  

---

**相似题目推荐**  
1. [P1776 宝物筛选](https://www.luogu.com.cn/problem/P1776) - 分组背包基础  
2. [P1941 飞扬的小鸟](https://www.luogu.com.cn/problem/P1941) - 状态转移优化  
3. [P2306 被污染的牛奶](https://www.luogu.com.cn/problem/P2306) - 动态规划状态设计

---
处理用时：50.67秒
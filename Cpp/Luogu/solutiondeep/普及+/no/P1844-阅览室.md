# 题目信息

# 阅览室

## 题目描述

一个阅览室每天都要接待大批读者。阅览室开门时间是 $O$，关门时间是 $T$。每位读者的到达时间都不一样，并且想要阅读的刊物不超过 $5$ 本。

每位读者心里对自己想看的刊物都有一个排位，到达之后他会先去找自己最想看的刊物，如果找不到则去找其次想看的刊物。如果找不到任何他想看的刊物，他会开始等待，直到有一本以上的他想看的刊物被人放回原处。当然，他会先去拿其中自己最想看的刊物。当他看完某一本刊物后，就把它放回原处，接着去找自己没看过的最想看的刊物。如此下去，直到看完所有他想看的刊物为止。

矛盾出现在两个人同时想要拿同一本刊物的时候。阅览室为了避免读者之间出现争执，作了一个规定，读者每次在开始等待时先去服务台做一次登记。如果两个人都同时想要一本刊物，那么先登记的读者将得到这本刊物。如果两个人同时登记，那么先到达阅览室的读者将得到刊物。没得到的人就只能去找其他的刊物看。

阅览室关门时，所有读者都将被强迫离开阅览室，不再允许继续阅读。

现在阅览室想做一个统计调查，你被要求写一个程序来模拟这个过程计算出所有刊物被阅读的总次数。当某个读者开始阅读某本刊物时，该刊物的被阅读次数就加 $1$，无论这本刊物最后有没有被读完。

## 样例 #1

### 输入

```
10 4 
1
2 1 4 2 5 
3 
1 2 4 
7 
3 2 2 1 3 3 2 
9 
1 4 2 ```

### 输出

```
5```

# AI分析结果



### 算法分类
**模拟**

### 题解分析与结论
本题核心在于模拟读者借书、等待、冲突解决的时序逻辑。各题解均采用时间步进模拟，差异主要体现在冲突处理策略和事件调度方式上。关键难点在于正确实现冲突判定（登记时间优先级+到达时间优先级）和状态更新逻辑。

---

### 高星题解推荐
#### 1. 樱雪喵（⭐⭐⭐⭐⭐）
**核心思路**：  
- 按时间步枚举，每次将读者按`last`（最近一次完成借阅的时间）和到达时间排序，确保冲突时优先级高的读者先处理。
- 结构体存储读者状态，每次循环检查当前时间能否借到优先级最高的书，通过排序避免显式冲突判断。

**关键代码**：  
```cpp
sort(a+1,a+n+1,cmp); // 按last和到达时间排序
for(int i=1;i<=n;i++){
    if(a[i].ls>t || a[i].arr>t) continue;
    for(int k=1;k<=a[i].k;k++){ // 按优先级遍历书籍
        if(bk[a[i].s[k]] <= t && !a[i].flg[k]){
            ans++;
            a[i].ls = bk[a[i].s[k]] = t + a[i].t[k]; // 更新人和书的时间
            break;
        }
    }
}
```

**亮点**：通过排序隐式解决冲突，代码简洁高效，时间复杂度 O(Tn logn) 可接受。

---

#### 2. pangpengzhu（⭐⭐⭐⭐）
**核心思路**：  
- 维护每本书的释放时间，读者无法借书时找到最早可用的书并预定。
- 通过更新读者和书籍的"下次出现时间"模拟等待过程。

**关键代码**：  
```cpp
if(!jud) { // 无法借书时找最早可用的书
    int mn = 1e9 + 7, g;
    for(int u=0; u<num; u++) 
        if(b[book[u]] < mn) mn = b[book[u]], g = u;
    if(mn < T) {
        b[book[g]] += time[g]; // 预定书籍
        ans++;
    }
}
```

**亮点**：通过预定的方式处理等待，逻辑清晰，但需注意正确性证明。

---

#### 3. Andy_WA（⭐⭐⭐）
**核心思路**：  
- 与樱雪喵思路类似，采用时间步枚举和结构体排序，但变量命名更直观。
- 直接通过`stable_sort`保证相同优先级读者的到达时间顺序。

**关键代码**：  
```cpp
stable_sort(arr+1,arr+n+1,Comp); // 稳定排序保持到达顺序
for(int k=1;k<=arr[i].k;k++){ 
    if(ton[arr[i].s[k]] <= t && !arr[i].flag[k]){
        // 借书逻辑
    }
}
```

**亮点**：使用稳定排序避免显式处理到达时间，但代码与樱雪喵高度相似。

---

### 最优思路提炼
**关键技巧**：  
1. **按时间步枚举**，每次处理完所有读者状态变化。
2. **冲突处理排序**：以`last`（开始等待时间）为第一关键字，到达时间为第二关键字排序，保证正确优先级。
3. **状态更新原子性**：借书成功后同时更新读者和书籍的释放时间。

**可拓展方向**：  
- 事件驱动优化（如优先队列管理还书事件）可提升大时间范围效率。
- 类似资源调度问题（如进程调度、会议室预订）可参考此优先级处理思路。

---

### 相似题目推荐
1. [P2058 海港](https://www.luogu.com.cn/problem/P2058) - 时间窗口内的统计模拟
2. [P1195 口袋的天空](https://www.luogu.com.cn/problem/P1195) - 资源分配与优先级
3. [P2586 挤奶时间](https://www.luogu.com.cn/problem/P2586) - 时间区间调度与冲突处理

---
处理用时：59.77秒
# 题目信息

# 刷墙

## 题目描述

Farmer John已经设计了一种方法来装饰谷仓旁边的长栅栏（把栅栏认为是一根一维的线）。他把一只画刷绑在他最喜爱的奶牛Bessie身上，之后就去喝一杯冰水，而Bessie隔着栅栏来回走，当她走过某个地方，这里的一段栅栏就被刷上了涂料。

Bessie从栅栏上的位置0开始，并且遵循着一个N次移动的次序(1 <= N <= 100,000)。例如“10 L”表示Bessie向左移动了10个单位长度，“15 R”表示Bessie向右移动了15个单位长度。现给出Bessie所有移动的列表，Farmer John想要知道哪些区域的栅栏至少涂了两层涂料（只涂一层涂料的区域可能在大雨中被洗掉）。Bessie在她的行走中最远到达距起始点1,000,000,000个单位长度。


## 说明/提示

【样例解释】

Bessie从位置0开始，向右移动2个单位长度，向左移动6个单位长度，向右移动1个单位长度，向左移动8个单位长度，最后向右移动3个单位长度。

6个单位区域至少被涂了两层涂料，是 [-11,-8], [-4,-3], [0,2]这些区域。


## 样例 #1

### 输入

```
6

2 R

6 L

1 R

8 L

1 R

2 R```

### 输出

```
6```

# AI分析结果



### 算法分类
**离散化、差分、扫描线**

### 综合分析与结论
题目要求计算被涂刷至少两次的区间总长度，核心在于高效处理大范围的移动区间。主要思路包括：
1. **离散化+差分**：将移动转化为区间事件，离散化坐标后统计覆盖次数。
2. **扫描线**：将端点作为事件排序后扫描，动态维护覆盖层数。
3. **贪心区间合并**：按左端点排序后维护可能重叠的区间。

### 精选题解

#### 1. 作者：kradcigam (4星)
**关键亮点**：贪心维护重叠区间，通过排序后动态更新可能交叠的区域。代码简洁高效，时间复杂度O(n log n)。  
**核心代码**：
```cpp
sort(a+1,a+n+1);
int lft=a[1].l, rgt=a[1].r;
for(int i=2; i<=n; i++) {
    if(a[i].r > lft) {
        a[i].l = max(a[i].l, lft);
        if(a[i].r > rgt) {
            ans += rgt - a[i].l;
            lft = rgt;
            rgt = a[i].r;
        } else {
            ans += a[i].r - a[i].l;
            lft = a[i].r;
        }
    }
}
```
**思路**：将区间按左端点排序后维护当前可能重叠的区间，分情况计算重叠区域。

#### 2. 作者：wkdwswxy (4星)
**关键亮点**：离散化后差分统计覆盖次数，利用前缀和计算总长度。  
**核心代码**：
```cpp
sort(b, b+n+1);
int cnt = unique(b, b+n+1) - b;
for(int i=0; i<n; i++) {
    int v1=lower_bound(b, b+cnt, a[i])-b;
    int v2=lower_bound(b, b+cnt, a[i+1])-b;
    c[min(v1,v2)]++; c[max(v1,v2)]--; 
}
int sum=0, ans=0;
for(int i=0; i<cnt; i++) {
    sum += c[i];
    if(sum > 1) ans += b[i+1]-b[i];
}
```
**思路**：将端点离散化后构建差分数组，通过前缀和统计覆盖次数。

#### 3. 作者：Loser_King (4星)
**关键亮点**：扫描线法，将端点作为事件处理，动态维护当前覆盖层数。  
**核心代码**：
```cpp
struct node{int pos, val;};
vector<node> events;
for(int i=0; i<n; i++) {
    events.push_back({l, 1});
    events.push_back({r, -1});
}
sort(events.begin(), events.end());
int cnt=0, ans=0;
for(int i=1; i<events.size(); i++) {
    cnt += events[i-1].val;
    if(cnt >= 2) ans += events[i].pos - events[i-1].pos;
}
```
**思路**：将每个移动的起点和终点作为事件，排序后扫描统计覆盖层数。

### 关键思路总结
1. **事件点排序**：将区间端点或事件点排序后扫描处理。
2. **离散化**：压缩大范围坐标到有限空间，便于数组操作。
3. **差分/前缀和**：高效统计区间覆盖次数。
4. **动态维护重叠区域**：通过贪心或扫描线动态计算有效覆盖区间。

### 推荐题目
1. [P2205 画栅栏](https://www.luogu.com.cn/problem/P2205) - 区间覆盖统计的扩展问题。
2. [P3406 海底高铁](https://www.luogu.com.cn/problem/P3406) - 差分+前缀和的典型应用。
3. [P5490 扫描线](https://www.luogu.com.cn/problem/P5490) - 扫描线模板题。

---
处理用时：51.25秒
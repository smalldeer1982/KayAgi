# 题目信息

# 果汁店的难题

## 题目描述

炎热的夏天，来上一杯现榨的冰爽果汁想想都是一件惬意的事情！话说小王就看准了这一商机，在学校附近开了这么一家果汁店，但是最近他碰到了一个不大不小的难题：小王的果汁店里准备了 $K$ 台榨汁机，当然每台榨汁机只能榨一种果汁，在某个时段内，一个客人点了某种果汁，如果恰好有某台果汁机榨过这种果汁，那么就直接给客人用这台果汁机接着榨就可以了，但是如果点的是一种新的果汁就需要找一台干净的果汁机来用，问题就出在这，如果这时候还有空的果汁机还好，如果没有的话小王就需要将某台刚才用过的拿去清洗，清洗的话呢就得浪费很多的时间和很多的水，小王是个很有经济头脑的人，他想知道在排队客人需求已知的情况下最少需要清洗多少次果汁机？假定开始时所有果汁机都是干净的，为了方便描述，我们将果汁编号为 $1$ （橙汁）, $2$（苹果汁）， $3$ （葡萄汁）......

[友情提示：本店不售卖混合果汁]

## 说明/提示

$1\le K\le 10$，$1\le N\le 100$。

$1\le x_i\le 100$。

## 样例 #1

### 输入

```
2 7
1
2
3
1
3
1
3
```

### 输出

```
1
```

# AI分析结果



### 算法分类
**贪心**

---

### 题解分析与结论
题目核心是贪心策略：当必须清洗时，选择未来最不需要的榨汁机（即当前榨汁机对应的果汁在后续请求中出现时间最晚或不再出现）。所有题解均围绕这一核心展开，但实现细节和优化程度不同。

---

### 高星题解推荐

#### 1. 作者：miemieQWQ（⭐⭐⭐⭐⭐）
**关键亮点**：  
- 使用队列预处理每个果汁的后续请求位置，实现高效查询。
- 正确性证明清晰，指出优先清洗“后续不再出现”或“下次出现最晚”的榨汁机。
- 代码结构清晰，用 `set` 维护当前榨汁机状态，`queue` 处理请求顺序。

**核心代码片段**：
```cpp
void arrange(int x) {
    juice.pop(), pos[x].pop();
    if (machine.find(x) == machine.end()) { // 需要清洗
        ans++;
        int farthest = 0, best;
        for (auto it = machine.begin(); it != machine.end(); it++) {
            if (pos[*it].empty()) { // 该果汁后续不再出现
                machine.erase(*it); machine.insert(x); return;
            }
            if (pos[*it].front() > farthest) // 找下次出现最晚的
                farthest = pos[*it].front(), best = *it;
        }
        machine.erase(best); machine.insert(x);
    }
}
```

---

#### 2. 作者：Heap_Sort（⭐⭐⭐⭐）
**关键亮点**：  
- 强调贪心策略的正确性：清洗当前请求后**最早出现时间最晚**的榨汁机。
- 提供反例分析，指出错误策略（如选最晚出现时间）会导致部分测试点WA。
- 使用数组预处理每个果汁的首次出现时间。

**个人心得**：  
> “我最开始选的是每种果汁的最晚出现时间，结果只有80分。后来发现必须选最早出现时间最晚的，这题样例测不出这个错误，调试了很久。”

**核心代码片段**（Pascal转写为伪代码）：
```cpp
for (each榨汁机j的果汁x) {
    if (x在后续不再出现) 直接清洗x;
    else 记录x在后续的首次出现时间;
}
清洗首次出现时间最晚的榨汁机;
```

---

#### 3. 作者：Atserckcn（⭐⭐⭐⭐）
**关键亮点**：  
- 预处理后续请求的首次出现时间，用数组维护优先级。
- 代码简洁，通过遍历后续请求动态更新最优清洗目标。

**核心代码片段**：
```cpp
for (int j = i+1; j <= n; j++) // 预处理后续首次出现时间
    if (use[a[j]] && !uid[a[j]]) uid[a[j]] = ++id;
for (int j = 1; j <= 100; j++) {
    if (use[j] && !uid[j]) { // 后续不再出现
        which = j; break;
    }
    if (use[j] && uid[j] == k) which = j; // 最后出现的
}
```

---

### 最优思路总结
**关键贪心策略**：  
1. **预存后续请求位置**：对每个果汁的后续请求位置用队列或数组存储。
2. **动态选择清洗目标**：
   - 优先清洗后续不再出现的榨汁机。
   - 若无，则选择下次请求时间最晚的榨汁机。
3. **高效查询**：通过预处理或遍历后续请求快速确定最优目标。

**数据结构优化**：使用 `queue` 或 `vector` 存储每个果汁的请求序列，结合 `set` 或数组维护当前榨汁机状态。

---

### 拓展与举一反三
1. **类似问题**：  
   - 缓存淘汰策略（如LRU、Optimal算法）。
   - 任务调度中选择最晚需要的资源释放。
2. **推荐题目**：  
   - [P1233 木棍加工](https://www.luogu.com.cn/problem/P1233)（贪心+排序）
   - [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)（优先队列贪心）
   - [P1106 删数问题](https://www.luogu.com.cn/problem/P1106)（贪心策略设计）

---
处理用时：57.57秒
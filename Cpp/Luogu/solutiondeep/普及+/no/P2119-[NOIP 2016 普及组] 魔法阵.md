# 题目信息

# [NOIP 2016 普及组] 魔法阵

## 题目背景

NOIP2016 普及组 T4

## 题目描述

六十年一次的魔法战争就要开始了，大魔法师准备从附近的魔法场中汲取魔法能量。

大魔法师有 $m$ 个魔法物品，编号分别为 $1,2,\ldots,m$。每个物品具有一个魔法值，我们用 $X_i$ 表示编号为 $i$ 的物品的魔法值。每个魔法值 $X_i$ 是不超过 $n$ 的正整数，可能有多个物品的魔法值相同。

大魔法师认为，当且仅当四个编号为 $a,b,c,d$ 的魔法物品满足 $X_a<X_b<X_c<X_d,X_b-X_a=2(X_d-X_c)$，并且 $X_b-X_a<(X_c-X_b)/3$ 时，这四个魔法物品形成了一个魔法阵，他称这四个魔法物品分别为这个魔法阵的 $A$ 物品，$B$ 物品，$C$ 物品，$D$ 物品。

现在，大魔法师想要知道，对于每个魔法物品，作为某个魔法阵的 $A$ 物品出现的次数，作为 $B$ 物品的次数，作为 $C$ 物品的次数，和作为 $D$ 物品的次数。

## 说明/提示

【样例解释 $1$】

共有 $5$ 个魔法阵，分别为：

- 物品 $1,3,7,6$，其魔法值分别为 $1,7,26,29$；
- 物品 $1,5,2,7$，其魔法值分别为 $1,5,24,26$；
- 物品 $1,5,7,4$，其魔法值分别为 $1,5,26,28$；
- 物品 $1,5,8,7$，其魔法值分别为 $1,5,24,26$；
- 物品 $5,3,4,6$，其魔法值分别为 $5,7,28,29$。

以物品 $5$ 为例，它作为 $A$ 物品出现了 $1$ 次，作为 $B$ 物品出现了 $3$ 次，没有作为 $C$ 物品或者 $D$ 物品出现，所以这一行输出的四个数依次为 $1,3,0,0$。

此外，如果我们将输出看作一个 $m$ 行 $4$ 列的矩阵，那么每一列上的 $m$ 个数之和都应等于魔法阵的总数。所以，如果你的输出不满足这个性质，那么这个输出一定不正确。你可以通过这个性质在一定程度上检查你的输出的正确性。

【数据规模】

![](https://cdn.luogu.com.cn/upload/image_hosting/nozwrvut.png)

## 样例 #1

### 输入

```
30 8
1
24
7
28
5
29
26
24```

### 输出

```
4 0 0 0
0 0 1 0
0 2 0 0
0 0 1 1
1 3 0 0
0 0 0 2
0 0 2 2
0 0 1 0```

## 样例 #2

### 输入

```
15 15
1 
2 
3 
4 
5
6 
7 
8 
9
10
11
12
13
14
15```

### 输出

```
5 0 0 0
4 0 0 0
3 5 0 0
2 4 0 0
1 3 0 0
0 2 0 0
0 1 0 0
0 0 0 0
0 0 0 0
0 0 1 0
0 0 2 1
0 0 3 2
0 0 4 3
0 0 5 4
0 0 0 5```

# AI分析结果



### 算法分类
数学、前缀和

### 综合分析与结论
题目核心在于将四元组条件转化为数学关系，通过设定差值变量 t 降低维度，结合桶计数与前后缀和优化统计次数。所有题解均围绕以下核心思路展开：
1. 数学推导：设 t=Xd-Xc，推导出 Xb-Xa=2t 和 Xc-Xb>6t
2. 桶计数：用 cnt[x] 记录魔法值 x 的出现次数
3. 双指针思想：分正序（统计C/D）和逆序（统计A/B）两次遍历，用前缀和/后缀和优化组合数计算

### 精选题解
#### 1. henry_y（五星）
**关键亮点**：  
- 清晰定义 t=Xd-Xc，建立完整数学关系式
- 首创双循环结构（正序处理D、逆序处理A）
- 前缀和与乘法原理的完美结合

**核心代码**：
```cpp
for(int t=1;t*9<n;t++){
    int sum=0;
    // 正序处理D（统计C和D）
    for(int D=9*t+2;D<=n;D++){
        int A=D-9*t-1, B=A+2*t, C=D-t;
        sum += cnt[A] * cnt[B]; // 前缀和累加AB组合数
        c[C] += cnt[D] * sum;  // 当前D对应的C计数
        d[D] += cnt[C] * sum;  // 当前D自身计数
    }
    sum=0;
    // 逆序处理A（统计A和B）
    for(int A=n-9*t-1;A;A--){
        int B=A+2*t, C=B+6*t+1, D=A+9*t+1;
        sum += cnt[C] * cnt[D]; // 后缀和累加CD组合数
        a[A] += cnt[B] * sum;   // 当前A的计数
        b[B] += cnt[A] * sum;   // 当前B的计数
    }
}
```

#### 2. cwxcplh（四星）
**关键亮点**：
- 详细图解辅助理解数轴关系
- 完整呈现从暴力到优化的推导过程
- 代码结构清晰易理解

**核心思路**：将 k 固定为1得到最优解，通过正逆序双循环分别统计前后缀贡献值。代码结构与 henry_y 解法本质相同，但变量命名更直观。

#### 3. zhuangjinning（四星）
**关键亮点**：
- 独立设计 left/right 数组预处理组合数
- 分四个独立循环计算各角色贡献
- 代码模块化程度高

**代码片段**：
```cpp
for(int t=1;t*9<n;t++){
    // 预处理左组合数（AB）
    for(int i=2*t+1;i<=n;i++)
        left[i] = left[i-1] + cnt[i]*cnt[i-2*t];
    
    // 预处理右组合数（CD） 
    for(int i=n-t;i>=1;i--)
        right[i] = right[i+1] + cnt[i]*cnt[i+t];
    
    // 四角色独立计算
    for(int i=1;i<=n;i++){
        ans[i][0] += cnt[i+2t] * right[i+8t+1]; //A
        ans[i][1] += cnt[i-2t] * right[i+6t+1]; //B
        ans[i][2] += cnt[i+t] * left[i-6t-1];    //C
        ans[i][3] += cnt[i-t] * left[i-7t-1];    //D
    }
}
```

### 关键技巧总结
1. **差值转化**：通过设定 t=Xd-Xc 建立变量间关系，将四维问题降为二维
2. **桶式计数**：用 cnt[x] 统计魔法值频率，避免重复枚举相同值
3. **前后缀优化**：正序累加前缀和统计CD贡献，逆序累加后缀和统计AB贡献
4. **对称处理**：正逆序双循环分别处理不同角色，确保O(n²)时间复杂度

### 拓展训练
1. [P2671 求和](https://www.luogu.com.cn/problem/P2671)（数学推导+奇偶分组）
2. [P1982 小朋友的数字](https://www.luogu.com.cn/problem/P1982)（前缀和与极值特性）
3. [P3406 海底高铁](https://www.luogu.com.cn/problem/P3406)（差分数组与费用计算）

---
处理用时：72.43秒
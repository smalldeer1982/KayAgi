# 题目信息

# [HNOI2002] 高质量的数据传输

## 题目描述

![](https://cdn.luogu.com.cn/upload/pic/1325.png)


## 样例 #1

### 输入

```
3 1 3                       
0 1 5
1 0 2
5 2 0
0 0.1 0.05
0.1 0 0.05
0.05 0.05 0```

### 输出

```
5 0.0500```

# AI分析结果



**算法分类**: 最短路

---

### 综合分析与结论
题目核心是双关键字最短路问题，要求优先最小化丢包率（转化为最大化剩余率乘积），次优先最小化时延。各题解均采用最短路框架，主要差异在算法选择（SPFA/Floyd）、数据结构优化和浮点处理方式。

---

### 精选题解与评分
1. **作者：chichichichi（★★★★☆）**  
   **关键亮点**：  
   - 清晰数学建模：将丢包率转化为剩余率乘积的最长路问题  
   - 双条件松弛逻辑严谨，使用EPS处理浮点精度  
   - 代码注释完善，变量命名清晰  
   **核心代码**：  
   ```cpp
   void spfa(int s) {
       while(!q.empty()) {
           int x = q.front();
           for(int i=lin[x];i;i=ne[i]) {
               if(ti[y] < ti[x]*p[i]) { // 第一优先级更新
                   ti[y] = ti[x]*p[i];
                   dis[y] = dis[x]+t[i];
               } else if(fabs(ti[y]-ti[x]*p[i])<EPS && dis[y]>dis[x]+t[i]) { // 第二优先级
                   dis[y] = dis[x]+t[i];
               }
           }
       }
   }
   ```

2. **作者：licn（★★★★☆）**  
   **关键亮点**：  
   - 简洁的SPFA实现，使用链式前向星存图  
   - 正确维护双关键字松弛顺序  
   - 特别强调零值处理（防止漏边）  
   **调试心得**：  
   > "切记：丢失率可能是0，存图时不要特判为0时不存"  
   **核心代码**：  
   ```cpp
   void spfa() {
       while(q.size()) {
           int x = q.front();
           for(int i=head[x];i;i=edge[i].next) {
               if(ans1[x]*edge[i].dis1 > ans1[y]) { // 优先剩余率
                   ans1[y] = ans1[x] * edge[i].dis1;
                   ans2[y] = ans2[x] + edge[i].dis2;
               }
           }
       }
   }
   ```

3. **作者：木木！（★★★★☆）**  
   **关键亮点**：  
   - Floyd算法的优雅实现  
   - 三重循环直接维护双关键字  
   - 适用于小规模数据（n≤200）  
   **核心代码**：  
   ```cpp
   for(int k=1; k<=n; ++k)
       for(int i=1; i<=n; ++i)
           for(int j=1; j<=n; ++j)
               if(pi[i][j] < pi[i][k]*pi[k][j]) { // 更新剩余率
                   pi[i][j] = pi[i][k]*pi[k][j];
                   ti[i][j] = ti[i][k]+ti[k][j];
               } else if(pi[i][j] == pi[i][k]*pi[k][j]) { // 更新时延
                   ti[i][j] = min(ti[i][j], ti[i][k]+ti[k][j]);
               }
   ```

---

### 最优技巧总结
1. **数学转化**：将最小化丢包率转化为最大化剩余率乘积（`1-p`的连乘积）  
2. **双关键字处理**：先比较主要条件（剩余率），次条件（时延）仅在主条件相等时更新  
3. **浮点精度**：使用EPS（1e-6）判断浮点相等，避免直接`==`比较  
4. **存图注意**：零值仍需建边（剩余率可能为1但时延有效）

---

### 拓展方向
- **变形问题**：带概率的路径选择（如P1576 最小花费）、双约束最短路（如P1462 通往奥格瑞玛的道路）  
- **算法延伸**：Dijkstra+优先队列优化（需处理乘积对数化转为加法）

---

### 推荐习题
1. [P1576 最小花费](https://www.luogu.com.cn/problem/P1576)（最短路+乘积最大）  
2. [P1462 通往奥格瑞玛的道路](https://www.luogu.com.cn/problem/P1462)（双关键字最短路）  
3. [P3385 SPFA判负环](https://www.luogu.com.cn/problem/P3385)（SPFA算法深入练习）

---
处理用时：66.54秒
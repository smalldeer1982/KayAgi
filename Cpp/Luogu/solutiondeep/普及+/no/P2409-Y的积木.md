# 题目信息

# Y的积木

## 题目背景

Y 是个大建筑师，他总能用最简单的积木拼出最有创意的造型。

## 题目描述

Y 手上有 $n$ 盒积木，每个积木有个重量。现在他想从每盒积木中拿一块积木，放在一起，这一堆积木的重量为每块积木的重量和。现在他想知道重量和最小的 $k$ 种取法的重量分别是多少。（只要任意更换一块积木，就视为一种不同的取法。如果多种取法重量总和一样，我们需要输出多次。）

## 说明/提示

#### 数据规模与约定

- 对于 $30\%$ 的数据，$2 \le m_i \le 10$，$1 \le n \le 10$。
- 对于 $50\%$ 的数据，$2 \le m_i \le 50$，$1 \le n \le 50$。
- 对于 $100\%$ 的数据，$2 \le m_i \le 100$，$1 \le n \le 100$，$1 \le k \le 10^4$，每个积木的重量为不超过 $100$ 的正整数，所有 $m_i$ 的积大于等于 $k$。

本题不卡常。

## 样例 #1

### 输入

```
3 10
4 1 3 4 5
3 1 7 9
4 1 2 3 5
```

### 输出

```
3 4 5 5 6 6 7 7 7 7
```

# AI分析结果



**算法分类**: 广度优先搜索 BFS

---

### 综合分析与结论
题目要求生成前k小的积木组合和，关键难点在于高效生成不重复状态并避免遍历全部可能。各题解核心思路为：
1. **优先队列（BFS）**：维护当前最小和的状态，每次扩展时仅允许在特定位置后调整指针，避免重复。
2. **动态规划（DP）**：记录每个重量出现的方案数，但需优化以避免数值过大。
3. **多序列合并**：通过逐步合并序列的堆结构生成结果，复杂度较高但理论较优。

最优解法为优先队列+BFS，通过限制指针移动方向确保状态唯一性。

---

### 精选题解

#### 题解1（作者：_zuoqingyuan，4星）
**关键亮点**：引入`last`变量限制指针调整范围，避免重复状态；代码简洁，逻辑清晰。  
**个人心得**：调试中发现需限制转移方向（如“次小和只能从第三个序列之后调整”），避免重复计数。  
**核心代码**：
```cpp
struct node{
    int sum=0, last;
    int it[105]; // 各序列指针
};
priority_queue<node> q;

// 扩展时仅允许从last位置之后调整
for(int i = t.last; i <= n; i++) {
    if (指针未越界) {
        // 更新指针并加入队列
    }
}
```

#### 题解2（作者：Rockey0515，4星）
**关键亮点**：结构体中`h`字段标记可调整的起始组，确保每次扩展不重复。  
**核心思路**：每个状态记录当前各组的指针和可调整的起始位置，扩展时仅调整后续组的指针。  
**核心代码**：
```cpp
struct u {
    vector<int> z; // 各组指针
    int s, h; // h为可调整的起始组
};
priority_queue<u> q;

// 扩展时从h位置开始调整指针
for (int i = t.h; i <= n; i++) {
    if (指针可后移) {
        // 更新指针并加入队列
    }
}
```

---

### 最优技巧总结
- **状态去重**：通过限制指针调整方向（如仅允许从某个位置向后调整），确保生成唯一状态。
- **优先队列优化**：每次取最小和状态扩展，保证按顺序生成前k小值。
- **预排序**：每组积木排序后，确保指针后移时和单调递增。

---

### 拓展与相似题目
1. **P1631 序列合并**：两升序序列各选一数，求前k小和。
2. **P1866 [COCI] 组合数**：多组数选数组合，求不同方案数。
3. **P3737 [HAOI2014] 走出迷宫**：优先队列+BFS求最优路径。

---
处理用时：39.58秒
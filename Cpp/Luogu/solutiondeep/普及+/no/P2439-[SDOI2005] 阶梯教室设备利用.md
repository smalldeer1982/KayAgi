# 题目信息

# [SDOI2005] 阶梯教室设备利用

## 题目描述

我们现有许多演讲要在阶梯教室中举行。每一个演讲都可以用唯一的起始和终止时间来确定，如果两个演讲时间有部分或全部重复，那么它们是无法同时在阶级教室中举行的。现在我们想要尽最大可能的利用这个教室，也就是说，我们需要在这些演讲中选择一些不重复的演讲来举行使得他们用的总时间尽可能的长。我们假设在某一演讲结束的瞬间我们就可以立即开始另一个演讲。

请写一个程序：

读入所有演讲的起始和终止时间，计算最大的可能演讲总时间。

## 说明/提示

### 样例解释

可以选择第 $3$ 个、第 $5$ 个、第 $6$ 个、第 $11$ 个、第 $12$ 个演讲，此时有最长的演讲总时间 $16$。

### 数据范围

$1\le n\le 10^4$，$0\le p<k\le 3\times 10^4$。

## 样例 #1

### 输入

```
12

1 2

3 5

0 4

6 8

7 13

4 6

9 10

9 12

11 14

15 19

14 16

18 20

```

### 输出

```
16```

# AI分析结果



**算法分类**: 动态规划

---

### 题解分析与结论
题目核心是选择互不重叠的演讲区间使总时间最长。所有题解均围绕动态规划展开，但实现方式差异显著。最优解法采用**时间轴线性DP**，通过预处理将转移复杂度降至O(n+k)，完美适配题目数据规模（n≤1e4，时间≤3e4）。

---

### 高星题解推荐

1. **sigland的题解**（⭐⭐⭐⭐⭐）  
   **核心思路**：  
   - 以时间轴为DP维度，`dp[i]`表示i时刻结束的最大总时长  
   - 预处理所有演讲到起始时间的vector，实现O(1)转移查询  
   - 线性扫描时间轴，用`dp[i] = max(dp[i], dp[i-1])`处理空闲时段  
   **亮点**：时间复杂度O(n+k)，代码简洁高效，空间优化到位  

   ```cpp
   vector<int> mp[30010]; // 按起始时间分组存储结束时间
   for(int i=0;i<=30000;i++){
       if(i>0) dp[i] = max(dp[i], dp[i-1]);
       for(int ed : mp[i]) 
           dp[ed] = max(dp[ed], dp[i] + ed - i);
   }
   ```

2. **UnyieldingTrilobite的题解**（⭐⭐⭐⭐）  
   **核心思路**：  
   - 按结束时间排序后，用树状数组维护前缀最大值  
   - 每个演讲通过二分查找找到最晚兼容的结束时间  
   **亮点**：时间复杂度O(n logn)，支持更大时间范围，结构清晰  

3. **梦回还的题解**（⭐⭐⭐⭐）  
   **核心思路**：  
   - 用线段树维护区间最大值，支持动态查询  
   - 离散化时间点，降低空间复杂度  
   **亮点**：通用性强，适合时间点稀疏的场景  

---

### 关键技巧总结
1. **时间轴压缩**：将时间离散化为连续点，避免无效空转  
2. **分组预处理**：按起始时间分组存储结束时间，优化转移效率  
3. **滚动继承**：`dp[i] = max(dp[i], dp[i-1])`处理时间间隙  
4. **数据结构加速**：线段树/树状数组维护区间极值，应对更大规模数据  

---

### 同类题目推荐
1. [P1868 饥饿的奶牛](https://www.luogu.com.cn/problem/P1868)  
2. [P1280 尼克的任务](https://www.luogu.com.cn/problem/P1280)  
3. [P2889 [USACO07NOV]Milking Time S](https://www.luogu.com.cn/problem/P2889)  

---

### 题解心得摘录
> "dp[i]的初值要继承dp[i-1]，因为时间可以空闲" —— 强调状态继承的重要性  
> "线段树单点更新最大值，区间查询最大值" —— 数据结构优化的核心思路  
> "按结束时间排序后，转移时只需找最晚兼容的演讲" —— 排序策略的巧妙运用

---
处理用时：56.35秒
# 题目信息

# [PA 2014] Bohater

## 题目描述

在一款电脑游戏中，你需要打败 $n$ 只怪物（从 $1$ 到 $n$ 编号）。

为了打败第 $i$ 只怪物，你需要消耗 $d_i$ 点生命值，但怪物死后会掉落血药，使你恢复 $a_i$ 点生命值。

任何时候你的生命值都不能降到 $0$（或 $0$ 以下）。

请问是否存在一种打怪顺序，使得你可以打完这 $n$ 只怪物而不死掉。

## 说明/提示

对于 $100\%$ 的数据，$1\le n,z\le 10^5$，$0\le d_i,a_i\le 10^5$。

## 样例 #1

### 输入

```
3 5
3 1
4 8
8 3```

### 输出

```
TAK
2 3 1 ```

# AI分析结果



### 算法分类
贪心

### 题解综合分析
题目核心是贪心策略设计，关键在于将怪物分为回血怪（a≥d）和掉血怪（a<d）两类分别处理。各题解均认同先处理回血怪，后处理掉血怪，但细节实现略有差异：

1. **回血怪排序**：所有题解均按 d_i 升序，确保血量不足时优先处理门槛低的怪。
2. **掉血怪排序**：主流做法是正序按 a_i 降序（等价于倒序视角的 d_i 升序），保证剩余血量足够处理后续怪物。

### 精选题解（评分≥4星）

#### 1. 作者：lgswdn_SA ⭐⭐⭐⭐⭐
**关键亮点**：  
- 通过单次排序函数统一处理两类怪物，代码简洁高效  
- 利用 `(x.a-x.d)*(y.a-y.d)<0` 巧妙分离两类怪物  
- 反向视角证明掉血怪的排序策略，逻辑严密  

**核心代码**：  
```cpp
bool cmp(const mons &x, const mons &y) {
    if((x.a-x.d)*(y.a-y.d)<0) return x.a-x.d>0; // 分离两类
    else if(x.a-x.d<0) return x.a>y.a; // 掉血怪按a降序
    else return x.d<y.d; // 回血怪按d升序
}
```

#### 2. 作者：huanyue ⭐⭐⭐⭐
**关键亮点**：  
- 反向思考掉血怪处理（终局血量倒推）  
- 提供构造反例说明错误策略的缺陷  
- 分段排序逻辑清晰，代码可读性强  

**个人心得**：  
> "掉血怪反向看作回血怪时，a_i 对应新视角的掉血量，必须按从大到小排序"

#### 3. 作者：Little09 ⭐⭐⭐⭐
**关键亮点**：  
- 明确分为补血怪、掉血怪两类处理  
- 倒序模拟掉血怪，理论证明简洁  
- 推荐类似题目 P7095 增强举一反三能力  

**核心代码**：  
```cpp
sort(a+1,a+cnta+1,cmp2); // 补血怪按d升序
sort(b+1,b+cntb+1,cmp1); // 掉血怪按a升序（倒序输出）
for(int i=cntb;i>=1;i--) cout << b[i].id; // 倒序即正序的a降序
```

### 关键思路总结
1. **分类处理**：优先处理回血怪（保证血量增长），再处理掉血怪。
2. **排序策略**：  
   - 回血怪按 d_i 升序（先打低门槛）  
   - 掉血怪按 a_i 降序（等效倒序视角的 d_i 升序）  
3. **反向思维**：对掉血怪倒序处理可转化为等价回血问题，简化证明。

### 同类题目推荐
1. [P1080 国王游戏](https://www.luogu.com.cn/problem/P1080) - 贪心排序策略  
2. [P1230 智力大冲浪](https://www.luogu.com.cn/problem/P1230) - 时间约束下的任务调度  
3. [P7095 [USACO20DEC] 青铜](https://www.luogu.com.cn/problem/P7095) - 反向视角贪心设计  

### 调试经验摘录
- **数据范围**：多篇题解强调 `long long` 的必要性（如 smyslenny："十年OI一场空，不开 long long 见祖宗"）  
- **边界处理**：huanyue 指出需单独处理全回血怪的情况，避免未排序导致的错误  
- **策略验证**：二gou子通过构造极端样例验证策略正确性，强调贪心的反例构造能力

---
处理用时：57.10秒
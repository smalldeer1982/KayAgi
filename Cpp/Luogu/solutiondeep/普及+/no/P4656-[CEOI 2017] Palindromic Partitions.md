# 题目信息

# [CEOI 2017] Palindromic Partitions

## 题目描述

给出一个只包含小写字母字符串，要求你将它划分成尽可能多的小块，使得这些小块构成回文串。

例如：对于字符串 ``abcab``，将他分成 ``ab`` ``c`` ``ab`` 或者 ``abcab`` 就是构成回文串的划分方法，``abc`` ``ab`` 则不是。

## 说明/提示

对于 $100\%$ 的数据，有 $1\le T\le 10$。设 $L$ 为单个字符串的长度，则 $1\le L\le 10^6$​​。

## 样例 #1

### 输入

```
4
bonobo
deleted
racecar
racecars```

### 输出

```
3
5
7
1```

# AI分析结果



### 算法分类
**贪心**（核心策略是尽可能分割最短的回文块，哈希用于加速验证）

---

### 题解综合分析
所有题解均采用**贪心+字符串哈希**的组合策略：
1. **核心思路**：从两端向中间推进，每次尝试分割最短的相同前后缀，分割后递归处理剩余部分。
2. **算法要点**：
   - 用哈希快速比较前后缀是否相同（O(1) 时间）
   - 自然溢出法优化哈希计算（避免取模运算）
   - 处理奇偶长度的边界情况
3. **解决难点**：通过哈希将字符串比较时间降至 O(1)，保证算法线性时间复杂度。

---

### 高星题解推荐
#### 1. 【小粉兔】⭐⭐⭐⭐⭐
**关键亮点**：
- 代码简洁高效，自然溢出实现哈希
- 动态计算后缀哈希权重，节省内存
- 正确处理奇偶长度的边界条件
**核心代码**：
```cpp
UL s1 = 0, s2 = 0, b = 1;
for (int i = 0; i < N / 2; ++i) {
    s1 = s1 * B + str[i];          // 前缀哈希
    s2 = s2 + str[N - i - 1] * b;  // 后缀哈希（动态计算权重）
    b = b * B;
    if (s1 == s2) {                // 发现可分割块
        ans += 2;
        s1 = s2 = 0, b = 1;        // 重置状态
    }
}
if (N % 2 || s1) ++ans;           // 处理剩余块
```

#### 2. 【Hoks】⭐⭐⭐⭐
**关键亮点**：
- 使用自然溢出法，代码极简
- 对称计算哈希值，逻辑清晰
**核心代码**：
```cpp
unsigned long long hash1=0,hash2=0,op=1;
for(int i=0;i<n/2;i++) {
    hash1=hash1*1145141+s[i];        // 前缀累加
    hash2=hash2+s[n-i-1]*op;         // 后缀加权累加
    op=op*1145141;
    if(hash1==hash2) ans+=2, hash1=hash2=0, op=1;
}
if(n%2||hash1) ans++;
```

#### 3. 【Liynw】⭐⭐⭐⭐
**关键亮点**：
- 对称指针同步推进，逻辑直观
- 自然溢出与动态权重结合
**核心代码**：
```cpp
ull hash1 = 0ull, hash2 = 0ull, pow = 1;
for(int i = 1; i <= n / 2; i++) {
    hash1 = hash1 * p + s[i];        // 前缀哈希
    hash2 = s[n - i + 1] * pow + hash2; // 后缀哈希
    pow *= p;
    if(hash1 == hash2) {             // 发现可分割块
        ans += 2;
        hash1 = hash2 = 0ull, pow = 1;
    }
}
if((n & 1) || hash1) ++ans;
```

---

### 关键优化与技巧
1. **自然溢出法**：利用 `unsigned long long` 的自动取模特性，避免显式模运算。
2. **动态权重计算**：后缀哈希的权重 `b` 随迭代动态更新，避免预计算数组。
3. **贪心分割策略**：在发现可分割块后立即重置状态，保证后续处理独立性。

---

### 拓展与举一反三
**相似题目推荐**：
1. [P3805 - 【模板】manacher算法](https://www.luogu.com.cn/problem/P3805)  
   （回文串处理经典算法）
2. [P2870 - 最长双回文串](https://www.luogu.com.cn/problem/P2870)  
   （结合贪心和回文性质）
3. [P1368 - 最小表示法](https://www.luogu.com.cn/problem/P1368)  
   （循环字符串的贪心处理）

---

### 个人心得摘录
> **小粉兔**：  
> "从两边往中间推，能选的就选上这个贪心策略是对的"  
> **总结**：贪心的正确性在于更小的分割块不会影响后续更大块的划分可能性。  
> 
> **the_same_prayers**：  
> "预处理 Pow 数组否则重复求会超时"  
> **总结**：哈希权重预计算是优化关键，但动态计算更节省内存。

---
处理用时：63.09秒
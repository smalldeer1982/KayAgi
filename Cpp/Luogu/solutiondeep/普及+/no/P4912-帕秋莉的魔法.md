# 题目信息

# 帕秋莉的魔法

## 题目背景

帕秋莉是一个有哮喘病的魔法使。

## 题目描述

众所周知，不同的魔法会需要念不同长度咒语 $a_i$ 但也会产生不同的威力 $b_i$。同时，在发动过一个魔法后也会对接下来发动的一个魔法产生影响 $w_{i,j}$（即在用完第 $i$ 种魔法后第 $j$ 种魔法的威力会变为 $b_j + w_{i.j}$，而且只会影响到下一个魔法）。
（当然也可能有魔法会减少咒语长度或者产生治愈的效果的魔法，魔法不可重复使用）

帕秋莉现在知道使用每种魔法后对接下来一种魔法的影响，以及每种魔法需要念的咒语长度和产生的威力，同时，由于编号大的魔法比编号小的魔法高级，所以一个魔法只有在编号不大于自己的魔法后使用才能保证魔法的连续性），现在她想知道念出长度为 $m$ 的咒语最大能产生多少威力。(以免下次在战斗中又因为哮喘病发作而惨败)

(编号顺序即给出的顺序)

## 说明/提示

对于 $20\%$ 的数据，保证 $a_i = 1$。

对于另外 $20\%$ 的数据，保证所有数字均为正整数。

对于 $100\%$ 的数据，$1 \le n \le 50,  |a_i|,|b_i|, |w_{i,j}|\le 50, |m| \le 2500$，保证运算过程中的数字大小均在 int 范围内(废话...)。

## 样例 #1

### 输入

```
2 5
3 3
2 2
1 2
3 4```

### 输出

```
7```

## 样例 #2

### 输入

```
2 6
3 3
2 2
1 2
3 4```

### 输出

```
-1```

# AI分析结果



**算法分类**  
动态规划

---

### 综合分析  
题目核心为带顺序依赖性增益的背包问题，需处理负体积与增益影响。所有题解均采用动态规划，状态定义为 `dp[i][j]` 表示选到第i个魔法且总长度为j时的最大威力。关键难点在于负数体积处理（通过偏移量）和增益计算（需记录前驱魔法）。

---

### 高星题解推荐  
1. **koishi_offical (★★★★★)**  
   **关键亮点**：  
   - 明确状态定义与转移方程，偏移量处理直观  
   - 代码简洁，初始化与边界条件清晰  
   **核心代码**：  
   ```cpp
   memset(f, 0xcf, sizeof(f));
   f[0][mov] = 0; // 初始状态偏移
   for (int i=1; i<=n; i++)
     for (int j=a[i]; j<M+mov; j++)
       for (int k=0; k<i; k++)
         if (f[k][j-a[i]] != f[0][0]) // 有效状态转移
           f[i][j] = max(f[i][j], f[k][j-a[i]] + b[i] + w[k][i]);
   ```

2. **Link_Cut_Y (★★★★☆)**  
   **关键亮点**：  
   - 提出刷表法与填表法两种实现，拓展思路  
   - 处理负数时的偏移量优化与结果判定简化  
   **核心代码**：  
   ```cpp
   memset(f, -0x3f, sizeof f);
   f[0][delta] = 0;
   for (int i=0; i<=n; i++)
     for (int j=i+1; j<=n; j++)
       for (int k=delta<<1; k>=0; k--)
         f[j][k+a[j]] = max(f[j][k+a[j]], f[i][k] + b[j] + w[i][j]);
   ```

3. **Yuanchenpu (★★★★☆)**  
   **关键亮点**：  
   - 强调负数处理的实际调试过程（如偏移量必要性）  
   - 代码中显式标注偏移量计算，增强可读性  

---

### 最优技巧总结  
1. **负数偏移量**：将体积维度整体右移（如+2500），避免负数下标。  
2. **状态有效性检查**：在转移前验证前驱状态是否可达（如 `if(f[k][j-a[i]] != -INF)`）。  
3. **多维状态设计**：`dp[i][j]` 记录最后选择的魔法编号，便于处理顺序依赖的增益。

---

### 拓展与相似题  
1. **同类型题目**  
   - [P1064 金明的预算方案](https://www.luogu.com.cn/problem/P1064)（依赖背包）  
   - [P1541 乌龟棋](https://www.luogu.com.cn/problem/P1541)（步数限制与增益）  
   - [P4159 迷路](https://www.luogu.com.cn/problem/P4159)（状态转移矩阵扩展）  

2. **调试心得摘录**  
   - *Firsry*：忘记检查前驱状态是否有效导致WA，强调边界条件验证。  
   - *Sakura_梦瑶*：初始最小值设置不当导致负数结果误判，需合理初始化。  

---

**核心代码实现**（以koishi_offical为例）  
```cpp
const int N=60, M=5e3, mov=2501;
int f[N][M+M], a[N], b[N], w[N][N];

memset(f, 0xcf, sizeof(f)); // 初始化为极小值
f[0][mov] = 0; // 初始状态偏移
for (int i=1; i<=n; i++) {
    for (int j=a[i]; j < M+mov; j++) { // 遍历所有可能体积
        for (int k=0; k<i; k++) { // 枚举前驱魔法
            if (f[k][j-a[i]] != 0xcfcfcfcf) { // 有效状态验证
                f[i][j] = max(f[i][j], f[k][j-a[i]] + b[i] + w[k][i]);
            }
        }
    }
}
```

---
处理用时：55.62秒
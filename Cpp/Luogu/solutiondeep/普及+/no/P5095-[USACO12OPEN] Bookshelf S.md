# 题目信息

# [USACO12OPEN] Bookshelf S

## 题目描述

Farmer John 闲来无事的时候总喜欢坐下来看书。这些年来，他一共收集了 $N$ 本书（$1 \leq N \leq 2000$），他打算搭一个新的书架来装这些书。

每本书都有个宽度 $w_i$ 和高度 $h_i$，书必须按顺序来摆放（即同一层书架摆的书必须是连续的一个区间）。每层书架的总宽度不能超过 $L$（$1 \leq L \leq 10^9$），每层书架的高度等于这一层最高的书的高度，整个书架的高度等于每层书架的高度之和。

现在请你帮 FJ 求出书架高度的最小值。

## 说明/提示

第一层放第一本书，第二层放第二，三，四本书，第三层放第五本书，总高度为 $5+13+3=21$，可以证明不存在更优的方案。

## 样例 #1

### 输入

```
5 10
5 7
9 2
8 5
13 2
3 8```

### 输出

```
21```

# AI分析结果



### 算法分类
**动态规划**

---

### 综合分析与结论
题目要求将书按顺序分成若干层，每层总宽度不超过 $L$，且总高度最小。所有题解均采用动态规划思路，核心要点如下：
- **状态定义**：$f[i]$ 表示前 $i$ 本书的最小总高度。
- **转移方程**：枚举最后一层的起点 $j$，满足 $\sum_{k=j}^i w_k \le L$，转移时计算 $f[j-1] + \max_{j\le k \le i} h_k$。
- **优化关键**：从后往前枚举 $j$，动态维护当前区间的宽度和最大值，及时终止无效循环。

---

### 精选题解与核心代码

#### 1. 作者：_xbn (⭐⭐⭐⭐⭐)
- **亮点**：代码简洁，逆序枚举 $j$ 时维护区间宽度和最大值，及时 `break` 优化。
- **核心代码**：
```cpp
for (int i = 1; i <= n; i++) {
    f[i] = f[i-1] + a[i];  // 初始化为单独一层
    int tot = a[i], sum = 0;
    for (int j = i-1; j >= 1; j--) {
        sum += w[j];
        if (sum > L) break;  // 提前终止
        tot = max(tot, a[j]);
        f[i] = min(f[i], f[j-1] + tot);
    }
}
```

#### 2. 作者：zhy137036 (⭐⭐⭐⭐)
- **亮点**：详细分析状态转移，优化思路清晰，维护 `sum` 和 `mx` 减少重复计算。
- **核心代码**：
```cpp
for (int i = 1; i <= n; i++) {
    int mx = h[i], sum = w[i];
    f[i] = f[i-1] + h[i];
    for (int j = i-1; j >= 0; j--) {
        sum += w[j+1];
        if (sum > L) break;
        mx = max(mx, h[j+1]);
        f[i] = min(f[i], f[j] + mx);
    }
}
```

#### 3. 作者：JK_LOVER (⭐⭐⭐)
- **思路**：尝试用 ST 表优化区间最值，但实际代码复杂度未降低，效率提升有限。
- **关键点**：预处理 ST 表加速最值查询，但动态维护更优。

---

### 关键优化技巧
1. **逆序枚举**：从当前书 $i$ 往前枚举 $j$，维护区间宽度和最大值，及时终止循环。
2. **前缀和优化**：使用前缀和快速计算区间总宽度。
3. **避免重复计算**：在循环中动态更新最大值，而非每次重新遍历区间。

---

### 相似题目推荐
1. [P1156 垃圾陷阱](https://www.luogu.com.cn/problem/P1156) - 动态规划与状态转移中的时间窗口限制。
2. [P1095 守望者的逃离](https://www.luogu.com.cn/problem/P1095) - 分段决策与动态维护最优解。
3. [P2308 添加括号](https://www.luogu.com.cn/problem/P2308) - 区间划分与动态规划结合。

---
处理用时：40.37秒
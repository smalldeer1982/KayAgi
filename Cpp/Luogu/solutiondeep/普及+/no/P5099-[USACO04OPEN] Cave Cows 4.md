# 题目信息

# [USACO04OPEN] Cave Cows 4

## 题目描述

一道竖直的石墙横在贝茜前面，她必须越过去。

石墙可以看成一个xz平面，贝茜开始的时候在(0，0)，只要她到达 $ z=T $ 
 ( $ 1 \leq T \leq 200000 $ )的位置，就算翻越成功。

墙上有 $ N $ ( $ 1 \leq N \leq 50000 $ )块石头突出，成为贝茜的落蹄石。如果两个落蹄石之间x方向和z方向的距离均不超过2，那贝茜就可以攀上另一块落蹄石。

帮助贝茜计算她是否能够翻越石墙，如果可以，最少需要踩多少块落蹄石。

## 说明/提示

一种可行的方案是：(0,0) -> (1,2) -> (3,2) -> (4,1) -> (6,3) 。

## 样例 #1

### 输入

```
5 3
1 2
6 3
4 1
3 2
0 2```

### 输出

```
4```

# AI分析结果



### 算法分类
广度优先搜索 BFS

### 综合分析
题目核心是求网格坐标间跳跃的最短路径，本质属于无权图最短路径问题。所有题解均围绕BFS展开，核心差异在于如何高效处理跳跃可达性判定：  
1. **暴力枚举优化**：通过预处理坐标映射，将O(n²)的暴力连边优化为O(24n)的邻域检查  
2. **空间优化**：使用map替代二维数组存储坐标点，解决坐标范围过大的问题  
3. **搜索方向优化**：双向BFS尝试减少搜索空间  

### 精选题解
#### 1. 作者：LJC00118（⭐⭐⭐⭐⭐）
**关键亮点**：  
- 使用`map<pair<int,int>,int>`预处理所有石头的坐标映射，实现O(1)邻域查询  
- 预先构建邻接表，将BFS复杂度稳定在O(n)级别  
- 代码结构清晰，包含输入优化和去重处理  

**核心代码**：
```cpp
// 预处理邻接表
for(int i = 1; i <= n; i++) {
    for(int dx = -2; dx <= 2; dx++) {
        for(int dy = -2; dy <= 2; dy++) {
            if(dx == 0 && dy == 0) continue;
            int nx = x[i] + dx, ny = y[i] + dy;
            if(pre.count({nx, ny})) {
                adj[i].push_back(pre[{nx, ny}]);
            }
        }
    }
}
// BFS过程
queue<int> q; q.push(n);
while(!q.empty()) {
    int u = q.front(); q.pop();
    for(int v : adj[u]) {
        if(dis[v] == -1) {
            dis[v] = dis[u] + 1;
            q.push(v);
        }
    }
}
```

#### 2. 作者：Zvelig1205（⭐⭐⭐⭐）
**关键亮点**：  
- 双向BFS减少搜索空间，理论上比单向BFS快一倍  
- 使用统一结构体处理双向搜索状态  
- 边扩展时直接判断相遇条件  

**个人心得**：  
> "双向BFS的标记设计是关键，需区分两个方向的访问状态，遇到异向标记立即返回结果"

#### 3. 作者：littleKtian（⭐⭐⭐）
**优化思路**：  
- 按z坐标排序后滚动存储最近三行的石头坐标  
- 利用空间局部性减少邻域搜索范围  

### 关键技巧总结
1. **坐标映射**：使用`map`或嵌套`map`实现稀疏坐标存储，避免内存爆炸  
2. **邻域枚举**：每个点只需检查±2范围内的24个位置，复杂度从O(n²)降至O(24n)  
3. **状态剪枝**：首次访问即记录最短距离，后续遇到已访问点直接跳过  

### 拓展题目推荐
1. P1443 马的遍历（BFS基础应用）  
2. P1135 奇怪的电梯（状态转移+BFS）  
3. P3958 奶酪（三维空间连通性+BFS）

---
处理用时：44.11秒
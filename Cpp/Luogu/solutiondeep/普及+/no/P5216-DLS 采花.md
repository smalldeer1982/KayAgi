# 题目信息

# DLS 采花

## 题目背景

超水的签到题

## 题目描述

DLS 有 $N$ 个花田，每个花田里有 $a_i$ 朵花。

DLS 喜欢稀奇古怪的花田，他希望重新排列花田，然后去采花。  
但 DLS 采花又有一个癖好：他会从左往右采花。  
若当前采到第 $i$ 个花田，在之前有一个花田的花的数量，是第 $i$ 个花田的花的数量的因子的话，那么 DLS 不会采这个花田的花。

现在，DLS 想知道对于所有排列花田的方案，他能够采到的花的数量的和是多少。  
由于答案会比较大，请对 $998244353$ 取模。

## 说明/提示

|数据百分比|限制|
|-|-|
|$50\%$|$N \le 9$|
|$80\%$|$N \le 1000$|
|$100\%$|$N \le 10^5,a_i \le 10^5$|

## 样例 #1

### 输入

```
4
2 3 6 3
```

### 输出

```
156```

# AI分析结果



**算法分类**: 组合数学

### 综合分析与结论
题目核心是计算每个数在所有排列中作为第一个出现的非因子数的方案数，转化为组合数学问题。关键点在于快速统计每个数的因子数量，并利用阶乘与逆元优化计算。

---

### 高星题解推荐
1. **LZDQ（5星）**
   - **亮点**：预处理阶乘与逆元，筛法统计因子数，代码简洁高效。
   - **关键思路**：每个数的贡献为 `a_i * (n! / (因子数 + 1))`，通过桶计数和筛法预处理因子数。
   - **代码核心**：
     ```cpp
     // 筛法统计因子数
     for(int i=1;i<=1e5;i++)
         if(cnta[i]){
             for(int j=i;j<=1e5;j+=i)
                 cntb[j] += cnta[i];
             ans += (i * cnta[i] * f1[cntb[i]-1] * f2[cntb[i]+1]) % MOD;
         }
     ```
     - `f1` 存储阶乘，`f2` 存储逆阶乘的后缀积，快速计算组合式。

2. **米奇（4星）**
   - **亮点**：概率思路简洁，直接推导贡献为 `n! / (因子数 + 1)`。
   - **心得**：指出“因子必须在后面”等价于当前数在因子集合中排第一，概率为 `1/(x+1)`。
   - **代码核心**：
     ```cpp
     for(int i=1;i<=n;i++){
         int x = 统计的因子数;
         ans += (jc * inv[x+1] % MOD) * a[i] % MOD;
     }
     ```

---

### 最优关键思路
**筛法统计因子数 + 组合数优化**  
- **筛法统计**：用桶记录每个数的出现次数，遍历每个数的倍数累加，复杂度 `O(n log n)`。
- **组合公式**：每个数的贡献为 `a_i * n! / (k+1)`，其中 `k` 是该数的因子数量，利用逆元处理除法。

---

### 拓展与相似题
1. **洛谷 P3811**【模板】乘法逆元  
   练习逆元计算，为本题处理阶乘除法的基础。
2. **洛谷 P2513**【逆序对数列】  
   排列计数问题，结合动态规划与组合数学。
3. **洛谷 P3223**【HNOI2012】排队  
   复杂排列组合问题，涉及阶乘与逆元的综合应用。

---
处理用时：49.55秒
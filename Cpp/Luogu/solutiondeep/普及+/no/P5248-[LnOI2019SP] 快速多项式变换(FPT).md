# 题目信息

# [LnOI2019SP] 快速多项式变换(FPT)

## 题目背景

![avartar](https://cdn.luogu.com.cn/upload/pic/52800.png)

## 题目描述

这是一道构造题。

诗乃在心中想了一个$n+1$项的多项式$f(x)$。第$i$项次数为$i$，系数为$a_i$：

$$f(x)=a_0+a_1x+a_2x^2+a_3x^3+ \cdots +a_nx^n$$

给定$m$以及$f(m)$的值（即当$x=m$时此多项式的值），请构造多项式，满足任意$0 \leq a_i < m$且$a_i$为非负整数。

设你构造的多项式项数为$n$，则必须满足$1 ≤ n ≤ 100$且最高项系数不为零。

## 说明/提示

对于20%的数据， $ 2 ≤ m ≤ 5. $

对于100%的数据，
 $ 2 ≤ m,f(m) ≤ 10^{18}.$

所有数据的时间限制为 $1000ms$，空间限制为 $256MB$，可开启O2优化。

## 样例 #1

### 输入

```
10 10```

### 输出

```
2
0 1```

# AI分析结果



### 算法分类
**进制**

### 题解分析与结论
题目本质是将给定的整数 f(m) 转换为 m 进制的各个位，多项式系数对应 m 进制数位的逆序排列。所有题解中，最简洁高效的方式是直接进行进制转换，通过循环取余获取每个系数。

---

### 高星题解推荐
#### 1. 诗乃（⭐⭐⭐⭐⭐）
**核心思路**：将 f(m) 视为 m 进制数，每次取余得到系数，倒序输出即为多项式系数。  
**代码亮点**：代码简洁高效，时间复杂度 O(log_m f(m))，无需预处理幂次。  
**关键代码**：
```cpp
for(; fm; fm /= m) a[++n] = fm % m;
printf("%d\n", n);
for(int i = 1; i < n; ++i) cout << a[i] << " ";
cout << a[n];
```

#### 2. Therese（⭐⭐⭐⭐⭐）
**核心思路**：利用位值原理，直接通过循环取余分解 f(m) 的每一位。  
**代码亮点**：代码极简，无冗余步骤，逻辑清晰。  
**关键代码**：
```cpp
while (fm) { 
    a[temp] = fm % m;
    fm /= m;
    temp++;
}
cout << temp << endl;
for (int i = 0; i < temp; i++) cout << a[i] << " ";
```

#### 3. Cola（⭐⭐⭐⭐）
**核心思路**：逐项消去当前最低次项，通过减余操作得到系数。  
**亮点**：显式展示了多项式分解的数学过程，易理解。  
**关键代码**：
```cpp
while(fm) {
    a[t] = fm % m;
    fm -= a[t];
    fm /= m;
    t++;
}
```

---

### 最优技巧总结
**进制转换思维**：将多项式系数构造问题转化为进制转换问题，利用取余和整除分解数位。此方法时间复杂度为 O(log_m f(m))，代码实现简洁且无精度问题。

---

### 同类题目推荐
1. [P1017 进制转换](https://www.luogu.com.cn/problem/P1017)（负进制转换）
2. [P1062 数列](https://www.luogu.com.cn/problem/P1062)（进制思想构造数列）
3. [P2084 进制转换](https://www.luogu.com.cn/problem/P2084)（高精度进制转换）

---

### 题解心得摘录
- **调试教训**：yuy_ 题解提到 `log` 计算可能存在精度问题，改用循环更可靠。  
- **顿悟时刻**：ACgod 指出系数分解过程与多项式结构完全对应，直接取余即可。  
- **代码优化**：Sober_Clever 强调无需预处理幂次，直接逐次分解更高效。

---
处理用时：47.52秒
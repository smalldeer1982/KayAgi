# 题目信息

# [SNOI2019] 字符串

## 题目描述

给出一个长度为$n$的由小写字母组成的字符串$a$，设其中第$i$个字符为$a_i(1≤i≤n)$ 。

设删掉第$i$个字符之后得到的字符串为$s_i$，请按照字典序对$s_1,s_2,……,s_n$从小到大排序。若两个字符串相等，则认为编号小的字符串字典序更小。

## 说明/提示

对于所有数据，$1≤n≤10^6$。

对于10%的数据，$1≤n≤2000$；

对于另外20%的数据，$1≤n≤10^5$且任意两个相邻字符$a_i,a_{i+1}$不相等；

对于另外30%的数据，$1≤n≤10^5$；

对于余下40%的数据，无特殊限制。

## 样例 #1

### 输入

```
7
aabaaab```

### 输出

```
3 7 4 5 6 1 2```

# AI分析结果



**算法分类**: 贪心

---

### 综合分析
本题要求对删除每个字符后的字符串按字典序排序。难点在于高效处理大规模数据（1e6），避免暴力比较。各题解的核心思路均基于相邻字符的比较关系进行分段处理，利用贪心策略确定各段的排列顺序。

---

### 精选题解

1. **题解作者：zjwwjhy（5星）**  
   **关键亮点**：  
   - 通过比较相邻字符的大小，将字符串划分为递增/递减段，利用双指针动态构建结果数组。  
   - 时间复杂度为O(n)，空间复杂度低，代码简洁高效。  
   **核心代码**：  
   ```cpp
   int l=0, r=n+1;
   for(int i=2; i<=n; i++) {
       if(c[i] > c[i-1]) {
           for(int j=i-1; j>=id; j--) ans[--r] = j; // 当前段插入尾部
           id = i;
       } else if(c[i] < c[i-1]) {
           for(int j=id; j<i; j++) ans[++l] = j; // 当前段插入头部
           id = i;
       }
   }
   ```

2. **题解作者：Mirach（4星）**  
   **关键亮点**：  
   - 将连续的相同字符合并为块，简化比较逻辑。  
   - 按块处理顺序，利用链表维护块的最终排列，展开输出。  
   **代码片段**：  
   ```cpp
   for(int i=1, j=1; i<=n; i=j) {
       while(j <=n && s[i]==s[j]) j++;
       create_block(i, j-1); // 合并连续相同字符为块
   }
   ```

---

### 最优思路
**贪心分段处理**：通过相邻字符的大小关系将字符串划分为递增或递减段。递增段应排在后面，递减段应排在最前。合并连续相同字符段，直接按顺序处理，避免重复比较。

---

### 拓展与举一反三
- **类似问题**：  
  - P1106 删数问题（贪心删除字符使剩余最小）  
  - P2870 [USACO07DEC]Best Cow Line G（首尾字符贪心选择）  
  - P1012 [NOIP1998 提高组] 拼数（相邻元素比较拼接顺序）  

---

### 核心代码实现
```cpp
#include<bits/stdc++.h>
using namespace std;
int n, ans[1000010], id=1;
char c[1000010];

int main() {
    cin >> n >> (c+1);
    int l=0, r=n+1;
    for(int i=2; i<=n; i++) {
        if(c[i] > c[i-1]) {
            for(int j=i-1; j>=id; j--) ans[--r] = j;
            id = i;
        } else if(c[i] < c[i-1]) {
            for(int j=id; j<i; j++) ans[++l] = j;
            id = i;
        }
    }
    for(int i=id; i<=n; i++) ans[++l] = i; // 处理最后一段
    for(int i=1; i<=n; i++) cout << ans[i] << " ";
}
```

---
处理用时：62.17秒
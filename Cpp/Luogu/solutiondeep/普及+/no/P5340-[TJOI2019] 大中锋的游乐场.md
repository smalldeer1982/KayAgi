# 题目信息

# [TJOI2019] 大中锋的游乐场

## 题目描述

大中锋正在一个游乐场里玩耍。游乐场里有 $n$ 个娱乐设施，娱乐设施之间相互有共 $m$ 条道路相连，经过每一条路都需要花费一定的时间。为了方便游客，每一个娱乐设施旁都会配有一个小卖部，一部分小卖部会销售可乐，另一部分会销售汉堡。

由于大中锋十分贪吃，所以每当他走到一个娱乐设施，他都会先去购买一杯可乐或一个汉堡，并把它们吃掉。但如果大中锋吃掉的汉堡数量比他喝掉的可乐数量多于 $k$ ，那他就会感到很渴；如果喝掉的可乐数量比吃掉的汉堡数量多于 $k$ ，那他就会感到很饿。

现在大中锋正在第 $a$ 个娱乐设施，他想前往第 $b$ 个娱乐设施，但在他前进的路途中他不希望自己很渴或很饿。大中锋想知道自己在路上少花费多少时间。但由于大中锋很懒惰，他不想思考这个问题。你能帮助他解决这个问题吗？

注意：大中锋非常贪吃，所以他到达每个点的第一件事是去吃(或者喝)，才考虑其他的事情，所以在起始点和终点他都会去买汉堡(可乐)，你也需要保证在这两个点他不会感到很饿或者很渴。

## 说明/提示

#### 数据规模与约定

- 对于 $30\%$ 的数据，保证 $n\leq 50,m\leq 1000$。
- 对于 $100\%$ 的数据，保证 $1 \leq n\leq 10000$，$1 \leq m\leq 100000$，$1 \leq k\leq 10$，$1 \leq a_i \leq 2$，$1 \leq u, v,s, t \leq n$，$1 \leq w \leq 10000$。

对于所有数据，保证 $1 \leq T \leq 10$ ，且每个测试点的大数据不超过 $2$ 个。

#### 题目补充说明

- 路径不一定是简单路径。
- 大中锋可以多次经过一个节点，同时每次都会取得汉堡/可乐。

## 样例 #1

### 输入

```
1
2 1 1
1 1
1 2 1
1 2```

### 输出

```
-1```

## 样例 #2

### 输入

```
1
2 1 2
1 1
1 2 1
1 2```

### 输出

```
1```

# AI分析结果



**算法分类**  
最短路（分层图模型）

**综合分析与结论**  
本题需要通过分层图模型处理路径上的状态约束。将每个节点拆分为 $2k+1$ 个状态（表示汉堡与可乐的差值），用 Dijkstra 或 SPFA 求带状态的最短路。核心难点在于状态转移时的差值合法性判断和初始状态处理。

---

### 精选题解

**1. 作者：StudyingFather（⭐⭐⭐⭐⭐）**  
**关键亮点**：  
- 使用二维数组 `dis[i][j]` 清晰表示节点与状态  
- 初始状态处理完整（包含起点的第一次购买）  
- 优先队列实现简洁高效的 Dijkstra  
**核心代码**：  
```cpp
struct node { int u,t,w; /*...*/ };
priority_queue<node> q;

// 初始化起点状态（k为中间层）
dis[s][k+a[s]] = 0; 
q.push({s, k+a[s], 0});

while(!q.empty()) {
    int u = q.top().u, t = q.top().t;
    q.pop();
    for(边遍历) {
        int nt = t + a[v]; // 计算新状态
        if(nt合法 && 可松弛) {
            dis[v][nt] = dis[u][t] + w;
            q.push({v, nt, dis[v][nt]});
        }
    }
}
```

**2. 作者：s_r_f（⭐⭐⭐⭐）**  
**关键亮点**：  
- 虚拟节点处理起点状态更统一  
- 分层时用数学映射简化状态判断  
**核心实现**：  
```cpp
int Getp(int x, int t) { 
    // 将差值t映射到[0,2k]区间
    if(abs(t) > k) return 0;
    return 特殊编码后的节点ID; 
}

// 边处理时动态计算合法状态
for(所有可能的状态i){
    int new_state = i + 下个节点类型;
    if(new_state合法) 创建虚拟边
}
```

---

**关键技巧总结**  
1. **状态压缩**：将差值 $j \in [-k,k]$ 偏移为 $j+k \in [0,2k]$，避免负数下标  
2. **分层图建模**：每个物理节点扩展为 $2k+1$ 个状态节点，边权转移时同步更新状态  
3. **剪枝优化**：在状态转移时立即判断差值是否越界（`if(nt <= 2k && nt >= 0)`）  

**同类题目推荐**  
1. [P4568 飞行路线](https://www.luogu.com.cn/problem/P4568)（分层图经典）  
2. [P1073 最优贸易](https://www.luogu.com.cn/problem/P1073)（带状态的最短路）  
3. [P3953 逛公园](https://www.luogu.com.cn/problem/P3953)（路径长度与次数的约束）  

**调试经验摘录**  
> "考场狂码200+...忘写一行少80分" —— jiuguaiwf  
启示：SPFA出队时务必清除`vis`标记，否则会阻断后续更优解的更新。

---
处理用时：44.14秒
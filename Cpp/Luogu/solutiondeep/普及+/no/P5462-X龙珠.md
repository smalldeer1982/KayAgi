# 题目信息

# X龙珠

## 题目描述

“X龙珠”是一款益智小游戏。游戏中有 $n(2|n)$ 个编号互不相同龙珠按照给定的顺序排成一个队列，每个龙珠上面都有一个编号。每次操作时，选择并取出龙珠队列中**相邻**的两个龙珠，放到目标队列的末尾（目标队列最开始是空的，且这两个龙珠的前后顺序不变），然后去除原龙珠队列的空隙。反复多次，直到原龙珠队列为空。可见，因为决策不一样导致目标队列顺序不一样。现在请求出所有方案中、目标队列字典序最大的方案。只需要给出目标队列即可。

例如，当原龙珠队列是 [1,3,2,4] 时，可以先取出 3 和 2，此时目标队列是 [3,2]，原龙珠队列是 [1,4]；再将剩下两个龙珠放入目标队列，得到目标队列是 [3,2,1,4]

## 说明/提示

对于 20% 的数据，$n\le10$。  
对于 60% 的数据，$n\le10^3$。  
对于 100% 的数据，$n\le10^5$，龙珠编号不超过 n。


## 样例 #1

### 输入

```
4 
3 1 4 2```

### 输出

```
4 2 3 1```

## 样例 #2

### 输入

```
6 
6 5 4 1 3 2```

### 输出

```
6 5 4 1 3 2```

# AI分析结果



### 分类
贪心

### 分析与结论
题目核心是每次选取相邻的极大值对以构造最大字典序。各题解围绕如何高效维护可用相邻对展开，主要采用以下方法：
1. **双向链表+贪心**：从大到小枚举数值，若当前值的后继存在则取这对，并更新链表结构（最优解法，O(n)）
2. **优先队列+链表**：用堆维护当前最大值，链表处理动态删除（O(n log n)）
3. **并查集维护后继**：用路径压缩快速找到可用位置（O(n α(n))）

### 精选题解
1. **叫我DJ（5星）**
   - **亮点**：数组模拟双向链表，倒序枚举极大值，O(1)维护链表结构
   - **代码核心**：
     ```cpp
     for(i=n;i>=1;--i)
         if(k[i]){ // k[i]是i的后继
             printf("%d %d ",i,k[i]);
             k[x[i]] = k[k[i]]; // 前驱的后继改为后继的后继
             x[k[x[i]]] = x[i]; // 后继的后继的前驱改为前驱
             k[k[i]] = 0; // 标记已删除
         }
     ```
2. **Clu3ter（4星）**
   - **亮点**：堆维护当前极大值，链表动态维护相邻关系
   - **代码核心**：
     ```cpp
     priority_queue<node> dl;
     while(!dl.empty()){
         int x=dl.top().val; 
         if(在链表末尾) continue;
         dl删除x及其后继;
         更新前驱与后继的链接;
     }
     ```

3. **Atyou（4星）**
   - **亮点**：并查集维护可用后继，路径压缩快速查找
   - **代码核心**：
     ```cpp
     int get(int x){return fa[x]==x?x:fa[x]=get(fa[x]);}
     // 合并当前节点与后继的后继
     ```

### 关键思路
1. **贪心策略**：从大到小取数，优先保证高位极大值
2. **链表维护**：用双向链表O(1)处理节点删除，避免线性扫描
3. **倒序处理**：从n→1枚举，天然保证当前处理的数是剩余最大值

### 拓展应用
类似动态维护相邻关系的贪心问题可用此思路：
- 合并石子（相邻选择）
- 字符串删除k字符使字典序最大

### 推荐题目
- P1090 [合并果子]（贪心+优先队列）
- P1106 删数问题（字符串贪心）
- P2878 [保护花朵]（贪心+排序）

---
处理用时：60.62秒
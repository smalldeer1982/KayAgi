# 题目信息

# 小鱼比可爱（加强版）

## 题目描述

人比人，气死人；鱼比鱼，难死鱼。小鱼最近参加了一个“比可爱”比赛，比的是每只鱼的可爱程度。参赛的鱼被从左到右排成一排，头都朝向左边，然后每只鱼会得到一个整数数值，表示这只鱼的可爱程度，很显然整数越大，表示这只鱼越可爱，而且任意两只鱼的可爱程度可能一样。由于所有的鱼头都朝向左边，所以每只鱼只能看见在它左边的鱼的可爱程度，它们心里都在计算，在自己的眼力范围内有多少只鱼不如自己可爱呢。请你帮这些可爱但是鱼脑不够用的小鱼们计算一下。

和之前的要求不一样，比赛组委会关心的是这个排列的“总得意值”。一共有 $n$ 只小鱼，总共有 $\frac{n(n+1)}2$ 个不同的区间。每个区间的得意值等于这个区间中符合“左边的一只鱼的可爱值比右边的一只鱼可爱值更大”的对数（其实就是区间逆序对数啦）。总得意值就是所有区间的“得意值”的和。现在要求输出“总得意值”是多少。

## 说明/提示

测试点　　　|$n$　　　　|$a_i$　　　　|是否有重复数字 　
:-:|:-:|:-:|:-:
$1$|$1$|无特殊限制|否
$2$|$10$|无特殊限制|否
$3$|$10$|无特殊限制|是
$4$|$1000$|$\le10$|是
$5$|$1000$|无特殊限制|否
$6$|$1000$|无特殊限制|是
$7$|$10^5$|$\le100$|是
$8$|$3\times 10^5$|无特殊限制|否
$9$|$5\times 10^5$|无特殊限制|是
$10$|$10^6$|无特殊限制|是

对于 $100\%$ 的数据，$n \le 10^6$，$a_i\le 10^9$，所有数字均为非负整数。

## 样例 #1

### 输入

```
8
1 9 2 6 0 8 1 7```

### 输出

```
106```

## 样例 #2

### 输入

```
10
1 10 8 5 6 2 3 9 4 7```

### 输出

```
270```

## 样例 #3

### 输入

```
20
6 0 4 5 8 8 0 6 6 1 0 4 6 6 0 0 7 2 0 5```

### 输出

```
3481```

# AI分析结果



### 算法分类
树状数组、离散化、分治（归并排序）

---

### 题解综合分析
本题核心在于统计所有区间的逆序对总和。所有题解均基于 **贡献法**，将逆序对的贡献拆解为 $i \times (n-j+1)$，其中 $(i,j)$ 为逆序对。关键优化点包括：
1. **离散化处理**：将大范围数值映射到连续整数，便于树状数组操作。
2. **树状数组维护贡献**：将逆序对统计转换为区间查询，并在插入时记录 $(n-j+1)$ 的权重。
3. **归并排序优化**：通过分治合并过程动态统计逆序对贡献，并利用前缀和优化计算。

---

### 精选题解与亮点

#### 1. 作者：Frozencode（⭐⭐⭐⭐⭐）
**关键亮点**：
- 树状数组经典解法，离散化处理清晰简洁。
- 将逆序对的贡献拆解为乘法形式，利用树状数组高效统计。
- 代码可读性强，使用 `__int128` 处理大数。

**核心代码**：
```cpp
for(int i = n; i >= 1; i--) {
    res += (ll)(i * qry(c[i])); // 计算贡献
    update(c[i], n - i + 1);    // 插入权重
}
```
**实现思想**：倒序遍历数组，树状数组维护 $(n-j+1)$ 的累加值，查询时乘以前缀和。

#### 2. 作者：BinDir0（⭐⭐⭐⭐）
**关键亮点**：
- 归并排序实现，通过合并过程统计逆序对。
- 维护前缀和优化计算，避免重复遍历。
- 动态更新贡献时利用乘法分配律。

**核心代码**：
```cpp
while(i <= mid && j <= r) {
    if(a[i].val <= a[j].val) {
        sum -= a[i].pl; // 维护前缀和
        ... 
    } else {
        ans += sum * (n - a[j].pl + 1); // 统计贡献
        ...
    }
}
```
**实现思想**：归并时记录左半段下标和，遇到右半段较小值时累加贡献。

---

### 关键优化与技巧
1. **贡献拆分**：逆序对 $(i,j)$ 的贡献为 $i \times (n-j+1)$，通过树状数组或归并排序动态统计。
2. **离散化**：将大数值压缩为连续整数，降低树状数组空间复杂度。
3. **高精度处理**：使用 `__int128` 或手写高精度避免溢出。
4. **前缀和优化**：在归并排序中维护左半段下标和，避免重复计算。

---

### 拓展练习
1. [P1908 逆序对](https://www.luogu.com.cn/problem/P1908)（基础逆序对统计）
2. [P3157 动态逆序对](https://www.luogu.com.cn/problem/P3157)（动态删除元素统计逆序对）
3. [P3810 三维偏序](https://www.luogu.com.cn/problem/P3810)（分治与树状数组结合的高级应用）

---

### 个人心得摘录
- **调试教训**：`__int128` 无法直接输入输出，需手写读写函数（Frozencode）。
- **优化顿悟**：归并排序中维护前缀和可避免 $O(n^2)$ 遍历（BinDir0）。
- **踩坑记录**：离散化时需考虑重复值，需用稳定排序保留原始顺序（Kisaragi_77）。

---
处理用时：48.44秒
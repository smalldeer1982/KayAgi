# 题目信息

# [CSP-J2019 江西] 道路拆除

## 题目描述

A 国有 $n$ 座城市，从 $1 \sim n$ 编号。$1$ 号城市是 A 国的首都。城市间由 $m$ 条双向道路连通，通过每一条道路所花费的时间均为 $1$ 单位时间。  

现在 A 国打算拆除一些不实用的道路以减小维护的开支，但 A 国也需要保证主要线路不受影响。因此 A 国希望道路拆除完毕后，利用剩余未被拆除的道路，从 A 国首都出发，能到达 $s_1$ 号与 $s_2$ 号城市，且所要花费的最短时间分别不超过 $t_1$ 与 $t_2$（注意这是两个独立的条件，互相之间没有关联，即不需要先到 $s_1$ 再到 $s_2$）。

A 国想请你帮他们算算，在满足上述条件的情况下，他们最多能拆除多少条道路。 若上述条件永远无法满足，则输出 $-1$。

## 说明/提示

【数据范围】  
对于 $30\%$ 的数据，$n,m \le 15$；   
另有 $20\%$ 的数据，$n \le 100$，$m = n-1$；   
另有 $30\%$ 的数据，$s_1 = s_2$；  
对于 $100\%$ 的数据，$2 \le n,m \le 3000$，$1\le x,y \le n$，$2 \le s_1,s_2 \le n$，$0 \le t_1,t_2 \le n$。  

【样例 $1$ 解释】  
拆除 $(1,2),(2,3),(3,4)$ 三条边。  
注意：不需要令首都与除了 $s_1,s_2$ 外的点在拆除之后依然连通。

【样例 $2$ 解释】  
即使一条边都不拆除，首都到 $3$ 号点的最短时间也都达到了 $2$ 单位时间。

testdata by @DYH060310 

## 样例 #1

### 输入

```
5 6
1 2
2 3
1 3
3 4
4 5
3 5
5 3 4 3```

### 输出

```
3```

## 样例 #2

### 输入

```
3 2
1 2
2 3
2 2 3 1```

### 输出

```
-1```

# AI分析结果



**算法分类**  
最短路

**综合分析**  
本题核心是通过保留最少的边满足双终点最短路径约束。所有题解均基于以下核心思路：  
1. 预处理三次最短路（从首都1号点、s1、s2出发）  
2. 枚举中间点x，计算三条链（1→x→s1、1→x→s2）的总边数  
3. 取满足时间约束的最小总边数，总边数m减去该值即为答案  
算法时间复杂度为O(n+m)，关键难点在于发现路径结构的可拆分性。

---

**高星题解推荐**  

1. **旭日临窗（5星）**  
   **关键亮点**：  
   - 清晰图解说明路径重叠特性  
   - 代码结构简洁，BFS实现规范  
   - 正难则反的转化思路（求最少保留边）  
   **核心代码**：  
   ```cpp
   void bfs(int s, int *dis) {
     q.push(s); dis[s] = 0;
     while (!q.empty()) {
       int u = q.front(); q.pop();
       for (int v : G[u]) 
         if (dis[v] > dis[u]+1) 
           dis[v] = dis[u]+1, q.push(v);
     }
   }
   // 预处理三次BFS后枚举中间点
   for (int i=1; i<=n; i++) 
     if (dis1[i]+dis2[i] <= t1 && dis1[i]+dis3[i] <= t2)
       ans = min(ans, dis1[i]+dis2[i]+dis3[i]);
   ```

2. **vct14（4星）**  
   **关键亮点**：  
   - 严格证明路径无重复边的最优性  
   - 使用Dijkstra模板适配稀疏图  
   **个人心得**：  
   > "当两条路径有重复边时，将中间点移至重复段的端点一定更优" —— 通过反证法强化思路正确性

3. **qhr2023（4星）**  
   **关键亮点**：  
   - 精简代码实现（仅30行）  
   - 优先队列优化Dijkstra  
   **核心代码**：  
   ```cpp
   void dij(int dis[], int s) {
     priority_queue<node> q;
     dis[s]=0; q.push({0,s});
     while (!q.empty()) {
       int u = q.top().u; q.pop();
       for (int v : e[u]) 
         if (dis[v] > dis[u]+1)
           dis[v] = dis[u]+1, q.push({dis[v],v});
     }
   }
   ```

---

**关键思路总结**  
1. **多源BFS预处理**：从1、s1、s2出发计算单源最短路径  
2. **中间点枚举**：通过枚举x∈[1,n]，将路径拆分为1→x→s1和1→x→s2，确保总边数最小  
3. **时间约束验证**：检查dis1[x]+dis2[x]≤t1且dis1[x]+dis3[x]≤t2  

**拓展应用**  
类似问题可参考：  
- 多终点带约束路径优化（洛谷P1629）  
- 雷雨天气多源最短路组合（洛谷P6833）  
- 邮递员路径规划（洛谷P1629）

---

**相似题目推荐**  
1. P1629 - 邮递员送信（最短路往返）  
2. P6833 - [Cnoi2020]雷雨（三源最短路组合）  
3. P1144 - 最短路计数（BFS应用）

---
处理用时：48.63秒
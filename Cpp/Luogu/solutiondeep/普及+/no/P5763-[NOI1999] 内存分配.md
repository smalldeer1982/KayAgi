# 题目信息

# [NOI1999] 内存分配

## 题目描述

内存是计算机重要的资源之一，程序运行的过程中必须对内存进行分配。

经典的内存分配过程是这样进行的：
1. 内存以内存单元为基本单位，每个内存单元用一个固定的整数作为标识，称为地址。地址从 $0$ 开始连续排列，地址相邻的内存单元被认为是逻辑上连续的。我们把从地址 $i$ 开始的 $s$ 个连续的内存单元称为首地址为 $i$ 长度为 $s$ 的地址片。 
2. 运行过程中有若干进程需要占用内存，对于每个进程有一个申请时刻 $T$ ，需要内存单元数 $M$ 及运行时间 $P$。在运行时间 $P$ 内（即 $T$ 时刻开始，$T+P$ 时刻结束），这 $M$ 个被占用的内存单元不能再被其他进程使用。 
3. 假设在 $T$ 时刻有一个进程申请 $M$ 个单元，且运行时间为 $P$ ，则：

$\qquad$ 1)	若 $T$ 时刻内存中存在长度为 $M$ 的空闲地址片，则系统将这 $M$ 个空闲单元分配给该进程。若存在多个长度为 $M$ 个空闲地址片，则系统将首地址最小的那个空闲地址片分配给该进程。 

$\qquad$ 2)    如果 $T$ 时刻不存在长度为 $M$ 的空闲地址片，则该进程被放入一个等待队列。对于处于等待队列队头的进程，只要在任一时刻，存在长度为 $M$ 的空闲地址片，系统马上将该进程取出队列，并为它分配内存单元。注意，在进行内存分配处理过程中，处于等待队列队头的进程的处理优先级最高，队列中的其它进程不能先于队头进程被处理。 

现在给出一系列描述进程的数据，请编写一程序模拟系统分配内存的过程。


## 样例 #1

### 输入

```
10
1 3 10
2 4 3
3 4 4
4 1 4
5 3 4
0 0 0
```

### 输出

```
12
2
```

# AI分析结果



### 算法分类
模拟

### 综合分析与结论
本题要求模拟内存的动态分配与释放过程，核心难点在于高效维护内存块状态、处理进程队列优先级、合并空闲块。主流解法使用优先队列管理结束时间，结合链表/set维护内存块，队列处理等待进程。关键优化点在于释放内存时立即合并相邻空闲块并处理等待队列。

---

### 精选题解与核心思路

#### 1. crh1272336175 的题解（⭐⭐⭐⭐⭐）
**亮点**：使用 `set` 维护内存占用区间，`priority_queue` 管理结束时间，逻辑简洁高效。通过遍历相邻内存块间隙快速判断分配可能。
```cpp
set<pair<int, int>> runs; // 存储 {起始位置, 长度}
priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> endts; // {结束时间, 起始位置}

bool assign(int t, int m, int p) {
    for (auto it = runs.begin(); it != runs.end(); it++) { // 遍历寻找可插入的空隙
        auto jt = next(it);
        if (jt != runs.end() && jt->first - (it->first + it->second) >= m) {
            runs.insert({it->first + it->second, m});
            endts.push({t + p, it->first + it->second});
            return true;
        }
    }
    return false;
}
```

#### 2. gcwixsxr 的题解（⭐⭐⭐⭐）
**亮点**：通过 `vector` 动态维护内存块，`sort` 确保首地址有序。`work_in` 函数处理三种插入位置（头、中间、尾），逻辑清晰。
```cpp
vector<data> p; // 内存块按首地址排序
bool work_in(int t) {
    if (p.empty() || p[0].s >= x.m) { // 插入头部
        x.s = 0; p.push_back(x); sort(p.begin(), p.end()); return 1;
    }
    for (int i = 1; i < p.size(); i++) // 插入中间
        if (p[i].s - (p[i-1].s + p[i-1].m) >= x.m) { ... }
    if (n - (p.back().s + p.back().m) >= x.m) { // 插入尾部
        ... 
    }
}
```

#### 3. lg_zhou 的题解（⭐⭐⭐⭐）
**亮点**：手写链表维护内存块，`priority_queue` 管理释放时间，`merge` 函数合并空闲块。代码完整展示链表操作细节。
```cpp
struct Node { int l, r, val; Node *pre, *nxt; }; // 双向链表节点
void merge() { // 合并相邻空闲块
    for (Node *i = head->nxt; i != tail; i = i->nxt) {
        if (!i->val && i->nxt->val == 0) {
            i->val += i->nxt->val;
            delete i->nxt; // 合并后节点
        }
    }
}
```

---

### 关键思路总结
1. **数据结构选择**：优先队列管理进程结束时间，链表/set维护内存块，队列处理等待进程。
2. **空闲块合并**：释放内存后立即合并相邻空闲块，减少内存碎片。
3. **优先级处理**：释放内存时优先处理等待队列队头，确保按申请顺序分配。

---

### 相似题目推荐
1. [P1540 机器翻译](https://www.luogu.com.cn/problem/P1540) - 内存替换策略模拟
2. [P2058 海港](https://www.luogu.com.cn/problem/P2058) - 时间窗口与队列管理
3. [P2278 操作系统](https://www.luogu.com.cn/problem/P2278) - 进程调度与优先级队列

---
处理用时：49.81秒
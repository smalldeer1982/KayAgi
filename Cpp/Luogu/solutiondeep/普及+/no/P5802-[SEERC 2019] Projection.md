# 题目信息

# [SEERC 2019] Projection

## 题目描述

![TensorFlow](https://cdn.luogu.com.cn/upload/image_hosting/gdl3vztm.png)

你是一个 TensorFlow 的死忠粉，因此，你想要从两个投影图形来还原出 TensorFlow 的图标。

假定你有一个 3D 空间，尺寸为 $n \times m \times h$，以及两个投影图形（一个 $n \times m$ 的矩阵和一个 $n \times h$ 的矩阵，矩阵里的元素都为 $0$ 或 $1$）。你需要计算出一些 $1 \times 1 \times 1$ 的小正方体的集合，使得这些正方体放入 3D 空间后构成的立体的正投影（光照立体正面在立体后侧形成的投影）和右投影（光照立体左面在立体右侧形成的投影）与题目给定的投影图形一致。如果无解，输出 $-1$。如果有解，你需要计算出两个满足条件的集合，一个包含的小正方体数量最少，另一个最多。假定正方体的摆放不受重力影响（即小正方体在 3D 空间中可以随意放置，悬空也不需要支撑）。规定矩阵中的 $1$ 代表有阴影遮住，$0$ 代表无阴影遮住。

如果有多解，你需要输出字典序最小的解。一个解 $a$ 字典序比解 $b$ 小，当且仅当对于两个解中第一对不相同的数字，$a$ 中的数字小于 $b$ 中的。

例如，解 $[(0, 0, 0), (1, 1, 1)]$ 比解 $[(1, 1, 1), (0, 0, 0)]$ 字典序更小。

## 说明/提示

一个放置在 $(x, y, z)$ 的小正方体会在正投影的 $(x, y)$ 位置产生一个有阴影遮住的区域，并在右投影的 $(x, z)$ 位置产生一个有阴影遮住的区域。

坐标从 $0$ 开始编号。

## 样例 #1

### 输入

```
5 3 3
111
010
010
010
010
111
100
110
100
100```

### 输出

```
14
0 0 0
0 0 1
0 0 2
0 1 0
0 1 1
0 1 2
0 2 0
0 2 1
0 2 2
1 1 0
2 1 0
2 1 1
3 1 0
4 1 0
8
0 0 0
0 1 1
0 2 2
1 1 0
2 1 0
2 1 1
3 1 0
4 1 0```

## 样例 #2

### 输入

```
2 2 2
00
00
11
11```

### 输出

```
-1```

## 样例 #3

### 输入

```
2 3 2
101
011
10
11```

### 输出

```
6
0 0 0
0 2 0
1 1 0
1 1 1
1 2 0
1 2 1
4
0 0 0
0 2 0
1 1 0
1 2 1```

# AI分析结果



**算法分类**: 构造

---

### 综合分析与结论
题目要求根据正视图与右视图的投影构造3D立方体集合，核心在于：
1. **合法性验证**：同一层两个投影必须同时存在或不存在阴影
2. **最大值构造**：每个正视图阴影与右视图阴影进行笛卡尔积式填充
3. **最小值构造**：按阴影数量差动态匹配，多出部分复用另一侧首元素
4. **字典序处理**：坐标排序后输出

---

### 所选题解分析
**题解作者**: 南阳刘子骥  
**评分**: ⭐⭐⭐⭐ (4/5)  
**关键亮点**:
1. 清晰分治思想：将最大/最小值解拆分为独立处理模块
2. 巧妙阴影匹配策略：通过`min(frn.size(),rgh.size())`实现动态交叉匹配
3. 字典序处理：通过结构体排序实现坐标的自然序输出

**个人心得提炼**：
> "输入处理时倒序遍历字符串存储坐标，确保正确对应三维空间坐标轴"  
> "每个层独立判断合法性，避免全局状态维护的复杂性"

---

### 核心代码实现
```cpp
// 最大值构造（笛卡尔积填充）
void solveMax() {
    vector<Block> ans;
    for(int i = 0; i < n; i++)
        for(int j : frn[i])
            for(int k : rgh[i])
                ans.emplace_back(i, j, k);
    sort(ans.begin(), ans.end());
    // 输出逻辑...
}

// 最小值构造（动态匹配）
void solveMin() {
    vector<Block> ans;
    for(int i = 0; i < n; i++) {
        if(frn[i].size() < rgh[i].size()) {
            for(int j = 0; j < rgh[i].size(); j++)
                ans.emplace_back(i, frn[i][min((int)frn[i].size()-1,j)], rgh[i][j]);
        }
        // 其他情况处理...
    }
    sort(ans.begin(), ans.end());
    // 输出逻辑...
}
```

---

### 同类拓展题目推荐
1. [P1005 矩阵取数游戏](https://www.luogu.com.cn/problem/P1005) - 多维投影与动态规划结合
2. [P1059 明明的随机数](https://www.luogu.com.cn/problem/P1059) - 构造特定性质数列
3. [P1323 删数问题](https://www.luogu.com.cn/problem/P1323) - 极值构造与贪心策略

---

### 关键技巧总结
1. **分层处理**：将3D问题降维到各层独立处理
2. **投影映射**：正视图对应(y轴坐标)，右视图对应(z轴坐标)
3. **极值构造**：
   - 最大解：全连接确保覆盖所有可能的阴影
   - 最小解：交错匹配减少冗余方块
4. **字典序控制**：结构体三重坐标排序实现自然序输出

---
处理用时：51.06秒
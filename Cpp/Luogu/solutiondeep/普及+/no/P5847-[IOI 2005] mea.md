# 题目信息

# [IOI 2005] mea

## 题目描述

考虑一个非递减的整数序列 $S_1,\cdots,S_{n+1}$ ($S_i \le S{i+1}$，$1 \le i \le n$)。 序列 $M_1 \cdots M_n$ 是定义在序列 $S$ 的基础上，关系式为 $M_i = \frac{S_i + S_{i+1}}{2  }$（$1 \le i < n$）, 序列 $M$ 叫做序列 $S$ 的平均数序列。


例如序列 $1,2,2,4$ 的平均数序列为 $1.5,2,3$. 注意到平均数序列中的元素可能为小数。但是本题的任务只是处理平均数序列都为整数的情况。 

给出一个 $n$ 个数字的非递减的整数序列 $M_1,M_2,\cdots,M_n$。请你计算出：序列 $S_1,\cdots,S_{n+1}$ 的平均序列是 $M_1,\cdots,M_n$。 求满足以上条件的序列 $S$ 的总个数。

任务：从标准输入文件中读入一个非递减的整数序列。计算出平均序列是给出序列的整数序列的总个数。把计算结果写到标准输出文件中。

## 说明/提示

**样例说明**

一共存在 $4$ 种序列，它们的平均数序列都是 $2,3,9$。这四种序列如下：
- $2,2,8,10$
- $1,3,7,11$
- $0,4,6,12$
- $-1,5,5,13$

**数据范围**

对于 $50\%$ 的数据，$2 \le n \le 1000$，$1 \le M_i \le 2 \times 10^4$；

对于 $100\%$ 的数据，$2 \le n \le 5 \times 10^6$，$1 \le M_i \le 10^9$。

## 样例 #1

### 输入

```
3
2
5
9
```

### 输出

```
4
```

# AI分析结果



**算法分类**  
数学

---

**题解综合分析与结论**  
所有题解核心思路均基于数学推导，将问题转化为对初始值 $S_1$ 的取值范围的约束，通过递推不等式逐步缩小范围。关键在于：  
1. 发现 $S_1$ 确定后，整个序列可唯一生成。  
2. 通过非递减条件构建不等式组，维护 $S_1$ 的上下界。  
3. 最终答案即取值范围中的整数个数。

---

**高星题解推荐**  
1. **作者：dztlb（⭐⭐⭐⭐⭐）**  
   **关键亮点**：  
   - 逆向推导范围，每次处理当前 $M_i$ 对后续元素的约束，无需奇偶分类。  
   - 代码极简（仅 14 行），空间复杂度 $O(1)$，适用于大 $n$。  
   **核心代码**：  
   ```cpp
   for(int i=1;i<=n;++i){ 
       scanf("%lld",&m);
       swap(l,r);  // 交换边界以处理递推方向
       l = max(m, 2*m - l);  // 计算新下界
       r = 2*m - r;           // 计算新上界
   }
   ```

2. **作者：封禁用户（⭐⭐⭐⭐）**  
   **关键亮点**：  
   - 通过数学推导直接维护左右边界，逻辑清晰。  
   - 代码简洁且与数学公式高度对应。  
   **核心代码**：  
   ```cpp
   rep(i,1,n) {
       int m; cin >> m;
       swap(l, r);  // 处理递推方向
       l = max(m, 2*m - l);  // 计算新下界
       r = 2*m - r;           // 计算新上界
   }
   ```

3. **作者：BqtMtsZDnlpsT（⭐⭐⭐⭐）**  
   **关键亮点**：  
   - 显式处理奇偶性，利用前缀和简化表达式推导。  
   - 代码结构清晰，适合理解递推过程。  
   **个人心得**：  
   > "手玩样例发现奇偶性规律，通过前缀和快速计算累加项。"  
   **核心代码**：  
   ```cpp
   for(int i=1; i<=n; i++) {
       if(i&1) s[i] = s[i-1] + m[i];  // 奇偶分类前缀和
       else s[i] = s[i-1] - m[i];
   }
   for(int i=1; i<=n; i++) {
       if(i&1) r = min(r, 2*s[i-1] + m[i]);  // 更新右边界（奇数）
       else l = max(l, 2*s[i-1] - m[i]);     // 更新左边界（偶数）
   }
   ```

---

**最优关键思路**  
通过数学推导将问题转化为对 $S_1$ 的范围约束，每次处理 $M_i$ 时动态更新左右边界。利用 `swap(l, r)` 和 `max`/`min` 操作维护范围，避免显式奇偶分类，实现高效递推。

---

**拓展与相似题目**  
1. **递推范围约束**：[P1984 [NOIP2013] 洛谷斗士](https://www.luogu.com.cn/problem/P1984)  
2. **数学推导与不等式**：[P1969 积木大赛](https://www.luogu.com.cn/problem/P1969)  
3. **奇偶性与递推**：[P5657 格雷码](https://www.luogu.com.cn/problem/P5657)

---
处理用时：51.48秒
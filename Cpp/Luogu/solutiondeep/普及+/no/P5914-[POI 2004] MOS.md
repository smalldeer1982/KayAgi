# 题目信息

# [POI 2004] MOS

## 题目背景

一个夜晚一些旅行者想要过桥。

## 题目描述

他们只有一个火把。
- 火把的亮光最多允许两个旅行者同时过桥。
- 没有火把或者多于 $2$ 个人则不能过桥。

每个旅行者过桥都需要特定的时间，两个旅行者同时过桥时时间应该算较慢的那个。现在我们想知道所有旅行者最少要花费多少时间才能全部过桥?

## 说明/提示

对于 $100\%$ 的数据，$1\le n\le10^5$，过桥时间均不超过 $10^9$。

注：数据中 $n\ge 2$。

## 样例 #1

### 输入

```
4
6
7
10
15```

### 输出

```
42```

# AI分析结果



**算法分类**：贪心

---

### 综合分析与结论
题目核心是选择最优的两人过桥策略以最小化总时间。所有题解均围绕两种贪心策略展开：
1. **最快带最慢**：最快者与最慢者过桥后返回，时间成本为 `a1*2 + an + a(n-1)`。
2. **次快带最慢**：最快与次快先过桥，最快返回，最慢与次慢过桥，次快返回，时间成本为 `a1 + a2*2 + an`。

两种策略的选择基于当前剩余人员的速度分布。动态规划或循环迭代均可实现，但本质仍为贪心策略的重复应用。

---

### 高星题解推荐
1. **作者：FLY_lai（4星）**  
   **关键亮点**：严谨的数学证明，通过引理推导两种策略的合理性，强化了贪心选择的正确性。  
   **个人心得**：调整法证明最慢者必须与最快或次慢者同行，避免无效策略。

2. **作者：decoqwq（4星）**  
   **关键亮点**：简洁的动态规划实现，状态转移方程清晰，代码可读性强。  
   **核心代码**：
   ```cpp
   for(int i=n-1;;i--) 
       dp[i] = min(dp[i+1] + t[1] + t[i], dp[i+2] + t[1] + 2*t[2] + t[i+1]);
   ```
   **实现思想**：从后向前递推，每次处理两个最慢者，选择两种策略中的更优解。

3. **作者：kkxacj（4星）**  
   **关键亮点**：直接模拟两种策略，循环处理剩余人数，边界条件处理清晰。  
   **核心代码**：
   ```cpp
   while(n > 3) {
       sum += min(a[1] * 2 + a[n] + a[n-1], a[1] + a[2] * 2 + a[n]);
       n -= 2;
   }
   ```
   **实现思想**：循环减少人数，每次处理两个最慢者，直到剩余3人后单独处理。

---

### 关键优化技巧
- **策略选择**：每次处理最慢两人时，比较两种策略的时间成本，选择更优者。
- **排序预处理**：将过桥时间从小到大排序，便于快速访问最快、次快、最慢人员。
- **边界处理**：剩余人数≤3时单独处理，避免复杂逻辑错误。

---

### 拓展与举一反三
- **同类题目**：  
  - [P1809 过河问题](https://www.luogu.com.cn/problem/P1809)（同样贪心策略）  
  - [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)（贪心+优先队列）  
  - [P5019 铺设道路](https://www.luogu.com.cn/problem/P5019)（贪心模拟）

- **调试技巧**：  
  - 注意数据范围，使用 `long long` 避免溢出。  
  - 验证边界情况（如n=1、n=2、n=3）的正确性。  

---

### 核心代码示例（作者：decoqwq）
```cpp
sort(t.begin(), t.end());
int ans = 0;
while(n > 3) {
    ans += min(t[0] + 2*t[1] + t[n-1], 2*t[0] + t[n-2] + t[n-1]);
    n -= 2;
}
if(n == 3) ans += t[0] + t[1] + t[2];
else if(n == 2) ans += t[1];
cout << ans << endl;
```
**实现思想**：排序后循环处理最慢两人，剩余3人时直接累加三人过桥时间。

---
处理用时：59.29秒
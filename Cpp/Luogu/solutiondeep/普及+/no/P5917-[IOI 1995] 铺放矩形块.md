# 题目信息

# [IOI 1995] 铺放矩形块

## 题目描述

给定 $ 4 $ 个矩形块，找出一个最小的封闭矩形将这 $ 4 $ 个矩形块放入，但不得相互重叠。所谓最小矩形指该矩形面积最小。

所有 $ 4 $ 个矩形块的边都与封闭矩形的边相平行。

可能存在满足条件且有着同样面积的各种不同的封闭矩形， 你应该输出所有这些封闭矩形的边长。


## 样例 #1

### 输入

```
1 2
2 3
3 4
4 5```

### 输出

```
40
4 10
5 8```

# AI分析结果



### 算法分类
**深度优先搜索 DFS**

---

### 综合分析与结论
题目需要枚举所有可能的矩形排列方式与旋转状态，计算最小包围矩形。各题解核心思路相似：通过DFS生成全排列并处理旋转，针对不同布局模式计算尺寸。难点在于覆盖所有可能的布局情况，并正确推导每个布局的长宽公式。

---

### 高星题解推荐

#### 1. ChampionCyan（★★★★★）
**关键亮点**  
- 明确划分六种经典布局，逻辑清晰  
- 使用全排列+旋转枚举所有可能性  
- 利用`set`去重，排序输出规范  
**个人心得**  
> "每个矩形都尽可能向左下角靠拢"的思路可避免漏解，确保覆盖所有可能性。

**核心代码**  
```cpp
void dfs(int depth) {
    if (depth == 5) {
        calc_all_layouts(); // 处理六种布局
        return;
    }
    for (int i = depth; i <4; ++i) {
        swap(rects[depth], rects[i]);
        dfs(depth+1); // 生成排列
        swap(rects[depth], rects[i]);
        swap(rects[depth].w, rects[depth].h); // 旋转
        dfs(depth+1);
        swap(rects[depth].w, rects[depth].h);
    }
}
```

#### 2. 2021CHD（★★★★☆）
**关键亮点**  
- 不依赖固定布局分类，通用性更强  
- 通过递归放置模拟左下贪心策略  
- 可扩展至更多矩形场景  
**核心思路**  
> 动态计算每个矩形的左、下边界，确保无法向左下移动时更新包围尺寸。

---

### 最优技巧总结
1. **全排列+旋转枚举**：通过DFS生成所有排列顺序，并尝试每个矩形的两种旋转状态。
2. **布局模式推导**：对六种经典布局（如并列、堆叠等）分别建立长宽计算模型。
3. **去重与排序优化**：使用集合存储结果避免重复，最终按规格排序输出。

---

### 拓展与推荐
**同类题目**  
- [P1212 [IOI1994] 矩形覆盖](https://www.luogu.com.cn/problem/P1212)（本题双倍经验）
- [P1433 吃奶酪](https://www.luogu.com.cn/problem/P1433)（DFS+状态压缩）
- [P1092 虫食算](https://www.luogu.com.cn/problem/P1092)（排列枚举+剪枝）

---
处理用时：57.07秒
# 题目信息

# [POI 2003] Chocolate

## 题目描述

有一块 $n\times m$ 的矩形巧克力，准备将它切成 $n\times m$ 块。

巧克力上共有 $n-1$ 条横线和 $m-1$ 条竖线，你每次可以沿着其中的一条横线或竖线将巧克力切开，无论切割的长短，沿着每条横线切一次的代价依次为 $y_1,y_2,…,y_{n-1}$，而沿竖线切割的代价依次为 $x_1,x_2,…,x_{m-1}$。

例如，对于下图 $6\times4$的巧克力：

![](https://cdn.luogu.com.cn/upload/image_hosting/s0j2oloj.png)


我们先沿着三条横线切割，需要 $3$ 刀，得到 $4$ 条巧克力，然后再将这 $4$ 条巧克力沿竖线切割，每条都需要 $5$ 刀，则最终所花费的代价为 $y_1+y_2+y_3+4\times (x_1+x_2+x_3+x_4+x_5)$。

当然，上述简单切法不见得是最优切法，那么怎样切割该块巧克力，花费的代价最少呢？

## 说明/提示

对于 $100\%$ 的数据，$1\le n\le 10000$，$1\le m\le 10000$。

## 样例 #1

### 输入

```
6 4
2
1
3
1
4
4
1
2```

### 输出

```
42
```

# AI分析结果



**算法分类**  
贪心

---

**题解分析与结论**  
各题解均基于贪心思想：将横纵切割代价合并排序，优先选大值切割。关键点在于每次切割的倍率由另一方向的已切割次数决定。所有题解均正确使用该思路，差异仅在于代码实现细节（如变量命名、结构体设计）。最优解时间复杂度为 O(N log N)。

---

**精选题解**  

1. **xieyuhao2022（4星）**  
   **亮点**：结构体清晰，变量名易懂，代码简洁。  
   **核心思路**：将横纵切割存入结构体数组，按值降序排序。维护横纵切割次数，累加当前切割的倍率。  
   ```cpp
   struct qwq{ int val,id; };
   sort(a+1,a+1+tot,cmp);
   for(...){
     if(横向) ans += (y_+1)*val, x_++;
     else ans += (x_+1)*val, y_++;
   }
   ```

2. **Adolfo_North（4星）**  
   **亮点**：代码结构清晰，注释明确，变量名`cnt[flag]`简洁。  
   **核心技巧**：用`cnt[!flag]`直接获取另一方向的计数。  
   ```cpp
   ans += a[i].x * (cnt[!a[i].flag] + 1);
   cnt[a[i].flag]++;
   ```

3. **Leowang2009（4星）**  
   **亮点**：归并式处理，无需合并数组，直接双指针遍历两排序数组。  
   **代码片段**：  
   ```cpp
   sort(x, x+n, greater<int>()); sort(y, y+m, greater<int>());
   while(i,j未越界){
     if(x[i]>y[j]) ans += x[i++]*当前行数;
     else ans += y[j++]*当前列数;
   }
   ```

---

**关键技巧**  
- **贪心策略**：切割代价大的线优先，避免后续高倍率放大。  
- **倍率计算**：横向切割的倍率为纵向块数（即已切次数+1），反之亦然。  
- **实现优化**：直接合并数组排序或双指针遍历已排序数组。

---

**同类题目推荐**  
1. [P1324 矩形切割](https://www.luogu.com.cn/problem/P1324)（同题双倍经验）  
2. [P1842 奶牛玩杂技](https://www.luogu.com.cn/problem/P1842)（贪心排序策略）  
3. [P1230 智力大冲浪](https://www.luogu.com.cn/problem/P1230)（时间窗口+贪心）

---

**个人心得摘录**  
- **变量初始化**：`lidundun`提到检查变量初值，如初始块数应为1而非0。  
- **long long陷阱**：`George222`强调必须开long long，否则大数相乘会溢出。  
- **等价性证明**：`_EternalRegrets_`证明同代价切割顺序不影响结果，确保贪心正确性。

---
处理用时：49.07秒
# 题目信息

# [PA 2014] Pakowanie

## 题目描述

你有 $n$ 个物品和 $m$ 个包。物品有重量，且不可被分割；包也有各自的容量。要把所有物品装入包中，至少需要几个包？

## 说明/提示

对于 $100\%$ 的数据，$1\le n\le 24$，$1\le m\le 100$，$1\le a_i\le 10^8$，$1\le c_i\le 10^8$。

## 样例 #1

### 输入

```
4 3
4 2 10 3
11 18 9```

### 输出

```
2```

# AI分析结果



### 算法分类
动态规划（状压DP）

### 题解分析与结论
题目要求用最少背包数装所有物品，n=24 提示状压DP。核心思路为：
1. **贪心排序**：将背包按容量降序排列，优先使用大容量包减少开包次数。
2. **状态设计**：用 `f[i]` 表示物品集合 `i` 的最少包数，`g[i]` 表示该状态下剩余的最大空间。
3. **转移策略**：枚举每个未选物品，判断能否装入当前包或需新开包，更新状态时优先更优的包数或更大的剩余空间。

### 精选题解
#### 1. 作者：Kiloio（5星）
- **亮点**：代码清晰，注释完整。正确处理两种转移条件（当前包剩余空间足够或需新开包），利用贪心策略优化状态转移。
- **关键代码**：
```cpp
sort(b+1,b+1+m,cmp); // 排序背包
for (int i=0; i<=maxn; i++) { 
    for (int j=1; j<=n; j++) { 
        if (i & (1<<(j-1))) { 
            // 转移逻辑判断当前包或新包...
        }
    }
}
```

#### 2. 作者：wsyhb（5星）
- **亮点**：状态定义简明，转移条件优化到位。初始化 `f[S] = m+1` 表示不可达，最终检查 `f[U]` 合法性。
- **代码片段**：
```cpp
if (g_now >= a[j]) { // 当前包可装
    if (f_now < f[T] || ...) update...
} else if (c[f_now+1] >= a[j]) { // 新开包
    if (f_now+1 < f[T] || ...) update...
}
```

#### 3. 作者：Super_Cube（4星）
- **亮点**：代码简洁高效，二维数组 `dp[i][0]` 和 `dp[i][1]` 分别表示包数和剩余空间。
- **心得**：初始化 `dp[i][0]=101` 确保无效状态被正确过滤。

### 核心思路总结
- **状压与贪心结合**：用二进制状态压缩物品集合，贪心优先用大包。
- **双状态维护**：同时记录最少包数和剩余空间，确保转移时选择最优解。
- **高效转移**：遍历所有可能状态，逐个物品尝试加入，判断是否需新开包。

### 相似题目推荐
1. [P2831 愤怒的小鸟](https://www.luogu.com.cn/problem/P2831)（状压DP+几何）
2. [P3959 宝藏](https://www.luogu.com.cn/problem/P3959)（状压DP生成树）
3. [P1171 售货员的难题](https://www.luogu.com.cn/problem/P1171)（TSP问题的状压解法）

---
处理用时：49.80秒
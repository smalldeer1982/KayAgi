# 题目信息

# [CSGRound3] 游戏

## 题目背景

小 Y 和小 Z 是一对好朋友，他们在玩一个游戏。**游戏只有一个回合**。

## 题目描述

有一个牌堆，一共有 $n$ 张牌，第 $i$ 张牌上有一个数 $a_i$，其中第一张牌是堆顶。

小 Z 先取牌，他可以从堆顶开始取连续若干张牌（**可以取 $0$ 张**），取完的牌拿在手上，也就是不在牌堆里了。

然后小 Y 取牌，同样，她也可以从堆顶开始取连续若干张牌（**可以取 $0$ 张**）。

如果一个人手上的牌的数字和大于 $X$，那么他的分数就是 $0$，否则分数就是数字和。

分数高的人获胜，**如果一样高，则无人获胜**。

小 Z 为了获胜，使用了透视挂，即他知道牌堆里每张牌上写的数。

现在问你对于满足 $1 \leq X \leq K$ 的所有整数 $X$，哪些可以使得小 Z 有必胜策略，即小 Z 取完后，不管小 Y 怎么取都一定会**输**。

## 说明/提示

**【样例解释】**

$X=1,2,3$ 时，小 Z 取一张牌，小 Y 不管怎么取都是零分。

$X=4$ 时，小 Z 如果取 $1$ 张，那么小 Y 取 $1$ 张小 Y 就赢了；否则小 Z 只能是零分。

$X=5$ 时，小 Z 如果取 $1$ 张，那么小 Y 取 $1$ 张小 Y 就赢了；小 Z 如果取了 $2$ 张，小 Y 也取 $2$ 张，平局；否则小 Z 只能是零分。

---

**【数据范围】**

**本题采用捆绑测试。**

- Subtask 1（3 points）：$n = 1$。
- Subtask 2（14 points）：$K= 1$。
- Subtask 3（20 points）：$n,K \le 100$。
- Subtask 4（33 points）：$n , K \le 3333$。
- Subtask 5（30 points）：无特殊限制。

对于 $100\%$ 的数据，$1\leq n,K \leq 10^6$，$1\leq a_i \leq K$。



## 样例 #1

### 输入

```
5
1 4 3 2 2
5
```

### 输出

```
3
1 2 3
```

# AI分析结果



### 算法分类
**差分**（结合前缀和与双指针技巧）

---

### 综合分析
本题核心在于通过前缀和的单调性快速确定小Z必胜的X区间范围，利用差分数组快速标记有效区间。所有题解均围绕以下核心思路展开：
1. **前缀和预处理**：快速计算牌堆区间和
2. **双指针/二分查找**：确定小Y可能的最大有效取牌位置
3. **差分标记技巧**：高效统计所有满足条件的X

---

### 精选题解（评分≥4星）

#### 1. chenxinyang2006（★★★★★）
**核心亮点**：
- 完整使用双指针维护小Y的取牌范围，复杂度优化至O(n)
- 差分数组处理区间覆盖，代码简洁高效
- 包含快速IO优化，适合大数规模

**关键代码片段**：
```cpp
for(int l = 1, r = 1; l <= n && s[l] <= k; ++l) {
    while(r < n && s[r + 1] - s[l] < s[l]) ++r;
    if(s[n] - s[l] < s[l]) { // 小Y取完也无法超过的情况
        ++dif[s[l]];
        break;
    }
    int cl = s[l], cr = s[r + 1] - s[l] - 1;
    if(cl <= cr) { // 差分标记有效区间
        ++dif[cl];
        if(cr + 1 <= k) --dif[cr + 1];
    }
}
```

#### 2. StudyingFather（★★★★☆）
**核心亮点**：
- 清晰展示二分查找与差分结合的标准解法
- 代码结构清晰，适合理解基础思路
- 处理边界条件的break逻辑值得借鉴

**关键思路**：
```cpp
for(int i=1;i<=n && sum[i]<=k;i++) {
    int p = lower_bound(sum+1, sum+n+1, 2*sum[i]) - sum;
    // 找到第一个可能破坏条件的y的位置
    if(p > n || sum[p]-sum[i] > k) { // 无法构成威胁的情况
        res[sum[i]]++; 
        res[k+1]--;
        break;
    }
    // 差分标记区间[sum[i], sum[p]-sum[i])
    res[sum[i]]++;
    res[sum[p]-sum[i]]--;
}
```

#### 3. Lskkkno1（★★★★☆）
**核心亮点**：
- 严格数学推导获胜条件表达式
- 完整展示双指针维护过程
- 包含差分数组还原的完整流程

**代码特色**：
```cpp
for(int l = 1, r = 1; l <= n; ++l) {
    while(r < n && sum[r + 1] - sum[l] < sum[l]) ++r;
    // 双指针维护最大有效r
    if(sum[l] > k) break;
    int up = (r == n) ? k : sum[r + 1] - sum[l] - 1;
    dif[sum[l]]++; // 差分标记起始
    dif[min(up, k) + 1]--; // 标记结束
}
```

---

### 关键优化技巧
1. **前缀和单调性**：牌堆非负，前缀和必然单调递增，允许使用二分/双指针
2. **差分数组标记**：将区间操作转化为O(1)的端点修改，最终O(n)还原
3. **双指针替代二分**：利用单调性将查找复杂度从O(n log n)优化至O(n)

---

### 拓展训练
1. [P1115 最大子段和](https://www.luogu.com.cn/problem/P1115)（前缀和基础）
2. [P3406 海底高铁](https://www.luogu.com.cn/problem/P3406)（差分数组经典应用） 
3. [P3138 [USACO16FEB]Load Balancing S](https://www.luogu.com.cn/problem/P3138)（二分+前缀和综合应用）

---

### 调试心得摘录
- **Hexarhy**：  
  > "考场上想到AC做法真不容易。细节还非常多，我debug了好久" → 强调边界条件的验证
- **chenxinyang2006**：  
  > "牌堆非负，双指针不会回退" → 点明算法正确性的关键
- **Sai0511**：  
  > "发现X增大时取牌策略单调不减" → 启发优化方向的关键观察

---
处理用时：57.41秒
# 题目信息

# 神帖

## 题目背景

zrl 的生日在 3.14。出生在神帖迭起的日子，他的快乐自然很多。这不，他又要收取来着神帖的馈赠了。

## 题目描述

神帖分布在讨论区的一些页面上，每个页面最多有一个神帖。假设他正在浏览的页面设为 $0$ 号页面。向左一页为 $-1$ 号页面，向右一页为 $1$ 号页面，以此类推。第 $i$ 个神帖在 $x_i$ 号页面上，并且有特定的封禁的时间 $t_i$ 和快乐值 $v_i$，超过了这个时间 $t_i$ 浏览就不能得到他的快乐值了。zrl 向左或向右翻一页需要 $1$ 单位时间，浏览神帖不需要时间。问：zrl 最多能得到多少快乐值。

注：在 $t_i$ 个单位时间浏览第 $i$ 个神贴仍能得到 $v_i$ 的快乐值。

**另注：每个神帖的快乐值最多只能得到一次。**

## 说明/提示

#### 样例解释：

样例 1：$0 \rightarrow -1 \rightarrow 0 \rightarrow 1 \rightarrow 2 \rightarrow 3$  
样例 2：$0 \rightarrow -1 \rightarrow 0 \rightarrow 1 \rightarrow 2 \rightarrow 3$  
样例 3：$0 \rightarrow -1 \rightarrow -2 \rightarrow -3 \rightarrow -4 \rightarrow -5$ 

---

#### 数据范围：

| 测试点 | 特殊性质 |
| :-----------: | :-----------: |
| $1-2$ | $x_i \ge 0$ |
| $3-4$ | $0 \le t_i \le 20$ |
| $5-6$ | $n \le 20$ |
| $7$ | $-10 \le x_i \le 10$ |
| $8-9$ | $t_i=$\|$x_i$\| |
| $10-13$ | 所有 $t_i$ 均相等 |
| $14-17$ | $n \le 60$ |
| $17-22$ | 无 |

对于 $100\%$ 的数据，$n \le 200$，$-500 \le x_i \le 500$，$0 \le v_i \le 10^9$，$0\le t_i \le 500$。

Hint：新增两组 Hack 数据，贪心/模拟已经过不去了。

## 样例 #1

### 输入

```
5
-5 1 5
-3 1 5
-1 1 5
1 1 5
3 2 5
```

### 输出

```
4```

## 样例 #2

### 输入

```
5
-5 2 5
-3 1 5
-1 1 5
1 0 5
3 4 5
```

### 输出

```
5```

## 样例 #3

### 输入

```
5
1 1 1
2 1 2
3 1 3
4 1 5
-5 5 5
```

### 输出

```
5```

# AI分析结果



### 算法分类
**动态规划**

### 综合分析与结论
题目要求通过翻页收集神帖，需在时间限制内最大化快乐值。各题解均采用**区间DP**，核心思路为：  
- **状态设计**：`f[i][j][t][0/1]` 表示处理完区间 `[i,j]` 的神帖，时间 `t`，当前在左/右端点时的最大快乐值。  
- **转移方式**：从区间端点向左右扩展，计算移动时间并累加符合条件的快乐值。  
- **难点**：时间维度的处理与状态转移的正确性证明，需保证不会重复计算且时间递增。

### 精选题解与评分
---

#### 1. kradcigam（⭐⭐⭐⭐）
**关键亮点**：  
- 通过四维DP清晰表达状态，枚举时间维度。  
- 预处理时将原0号位置加入排序后的数组，简化边界处理。  
- 转移方程对称性强，代码结构简洁。

**核心代码**：
```cpp
for(int len=1;len<=n;len++)
    for(int i=1;i+len<=n;i++){
        int j=i+len;
        int x=min(abs(a[i].x),abs(a[j].x))+a[j].x-a[i].x;
        for(int t=x;t<=500;t++){
            f[i][j][t][0]=max(f[i+1][j][t-(a[i+1].x-a[i].x)][0],
                            f[i+1][j][t-(a[j].x-a[i].x)][1]) + work(t,i);
            f[i][j][t][1]=max(f[i][j-1][t-(a[j].x-a[i].x)][0],
                            f[i][j-1][t-(a[j].x-a[j-1].x)][1]) + work(t,j);
            ans=max(ans,max(f[i][j][t][0],f[i][j][t][1]));
        }
    }
```

---

#### 2. __Watcher（⭐⭐⭐⭐）
**关键亮点**：  
- 显式添加虚拟的0号节点作为起点，避免特殊判断。  
- 使用双循环分别处理左右扩展，逻辑清晰。  
- 对时间维度进行剪枝优化。

**核心代码**：
```cpp
for(int i=root;i>=1;i--)
    for(int j=root;j<=n+1;j++) {
        // 向左扩展
        for(int k=a[i+1].x-a[i].x; k<=500; k++)
            f[i][j][k][0] = f[i+1][j][k-(a[i+1].x-a[i].x)][0];
        // 向右扩展并更新答案
        for(int k=a[j].x-a[i].x; k<=500; k++){
            f[i][j][k][1] = max(f[i][j-1][k-(a[j].x-a[j-1].x)][1],
                                f[i][j-1][k-(a[j].x-a[i].x)][0]) + (k<=a[j].t?a[j].v:0);
            ans = max(ans, f[i][j][k][1]);
        }
    }
```

---

#### 3. Konnyaku_LXZ（⭐⭐⭐⭐）
**个人心得**：  
> "比赛前我本来打算去做关路灯，结果比赛就考了一道类似的题。回头来看，这类区间DP的关键是状态设计要考虑位置和时间。"

**关键亮点**：  
- 详细推导状态转移方程，适合理解思路。  
- 代码中对每个状态进行显式时间循环，避免越界。

---

### 最优思路总结
1. **区间DP框架**：按位置排序后，状态表示处理区间 `[i,j]`，记录当前端点。  
2. **时间维度处理**：通过 `max(t - move_time, 0)` 避免负时间。  
3. **虚拟节点技巧**：添加 `x=0` 的虚拟节点统一处理起点。  
4. **对称转移优化**：左右端点转移方程对称，减少编码复杂度。

### 拓展与相似题目
1. **关路灯**（Luogu P1220）  
   - 同类区间DP，处理移动时间与收益。
2. **石子合并**（Luogu P1880）  
   - 环形区间DP，状态转移类似。
3. **Dairy Time Scheduler**（Luogu P2858）  
   - 时间约束下的区间DP优化。

---
处理用时：54.15秒
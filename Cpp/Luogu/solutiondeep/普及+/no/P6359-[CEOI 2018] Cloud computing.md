# 题目信息

# [CEOI 2018] Cloud computing

## 题目背景

译自 CEOI2018 Day1 T1. [Cloud Computing](https://ceoi2018.pl/wp-content/uploads/2018/08/clo.pdf)。

## 题目描述

Johnny 创立了 Bytecomp，一家提供云计算能力的公司。这样的公司通常拥有许多快速的计算机，可以让客户在上面进行计算。

Johnny 仍然没有购买任何机器。他去了一家计算机商店，收到了一个包含所有 $n$ 台可用的计算机的清单。每台计算机都可以用三个属性描述：处理器内核数 $c_i$，时钟频率 $f_i$ 和价格 $v_i$。这样的计算机包含 $c_i$ 个独立的内核，所以他们可以被分配不同的任务。

当客户订购资源时，她会指定所需的内核数 $C_j$ 和最小的时钟频率 $F_j$。订单还包含客户愿意支付的价格 $V_j$。如果接受订单，Bytecomp 需要提供客户所需计算能力的独占访问权。Johnny 需要选择 $C_j$ 个核心（可能来自不同的计算机），且它们的时钟频率至少为 $F_j$，这些核心不能被分配给其它订单。

帮助 Johnny 赚尽可能多的钱：接受一个最优的订单子集，选择所有计算机的一个子集来满足所有接受了的订单。你的目标是最大化利润，即为客户提供计算能力的收入与购买计算机的成本之差。

## 说明/提示

#### 样例解释

一共有四台可用的计算机和三个订单。

最佳方案是购买两台价格为 $700$ 和 $750$（总计 $1450$）的四内核的计算机，然后接受前两个订单获得 $300+1500=1800$ 的收益。

我们获得了四个时钟频率为 $2000$ 的内核，和四个时钟频率为 $2200$ 的内核。可以将其中六个分配给第二个订单（需要 $1900$ 的时钟频率），再将其中一个分配给第一个订单（需要 $1500$ 的时钟频率），剩下一个核心不使用，这是允许的。

总利润为 $1800-1450=350$。

#### 数据规模与约定

对于 $100\%$ 的数据，$1\le n\le 2\times 10^3,\ 1\le c_i,C_i\le 50,\ 1\le f_i,F_i,v_i,V_i\le 10^9$。

所有测试数据被划分成若干个有附加限制的子任务，每个子任务中包含若干测试点。

| 子任务 | 附加限制 | 分值 |
| :--: | :---: | :--: |
| $1$ | $n \le 15$ | $18$ |
| $2$ | $m \le 15$ | $18$ |
| $3$ | $n,m \le 100$，$c_i = C_j = 1$ | $18$ |
| $4$ | $f_i = F_j = 1$ | $18$ |
| $5$ | $v_i = V_j = 1$ | $18$ |
| $6$ | 无附加限制 | $10$ |

## 样例 #1

### 输入

```
4
4 2200 700
2 1800 10
20 2550 9999
4 2000 750
3
1 1500 300
6 1900 1500
3 2400 4550```

### 输出

```
350```

# AI分析结果



**算法分类**: 动态规划

---

### 综合分析与结论
本题需将计算机购买与订单处理统一建模为动态规划问题，通过排序消除时钟频率的约束后转化为变种01背包。核心思路是将两类物品统一排序，设计滚动数组维护不同核心数时的最大利润。

---

### 精选题解

#### 1. 作者：☯☯枫☯☯（⭐⭐⭐⭐⭐）
**核心亮点**：
- 清晰解释排序策略（时钟频率降序+同频时计算机优先）
- 采用滚动数组优化空间
- 代码中通过v的正负区分物品类型，逻辑简洁

**关键代码**：
```cpp
for(int i=1;i<=n+m;i++) {
    if(a[i].v<0) { // 计算机（购买）
        for(int j=cnt; j>=0; j--)
            dp[j+a[i].c] = max(dp[j+a[i].c], dp[j]+a[i].v);
        cnt += a[i].c;
    } else { // 订单（收益）
        for(int j=0; j<=cnt-a[i].c; j++)
            dp[j] = max(dp[j], dp[j+a[i].c]+a[i].v);
    }
}
```

#### 2. 作者：Liynw（⭐⭐⭐⭐）
**核心亮点**：
- 详尽分析状态转移方程
- 明确区分计算机与订单的转移方向
- 强调初始化及边界条件处理

**代码亮点**：
```cpp
for(int i=1;i<=num;i++) {
    if(!a[i].data) { // 计算机
        C += a[i].c;
        for(int j=C; j>=a[i].c; j--)
            dp[j] = max(dp[j], dp[j - a[i].c] - a[i].v);
    } else { // 订单
        for(int j=0; j<=C - a[i].c; j++)
            dp[j] = max(dp[j], dp[j + a[i].c] + a[i].v);
    }
}
```

---

### 关键思路总结
1. **统一建模**：将计算机（负价值）与订单（正价值）合并为同类型物品
2. **贪心排序**：按时钟频率降序排列，同频时保证先买计算机后接订单
3. **滚动优化**：用一维数组维护状态，计算机采用倒序更新，订单采用正序更新
4. **状态定义**：`dp[j]`表示拥有j个核心时的最大利润，初始化为极小值（除dp[0]）

---

### 拓展与练习
**相似题目推荐**：
1. [P1064 金明的预算方案](https://www.luogu.com.cn/problem/P1064)（依赖背包）
2. [P1757 通天之分组背包](https://www.luogu.com.cn/problem/P1757)（分组背包）
3. [P5020 货币系统](https://www.luogu.com.cn/problem/P5020)（动态规划+贪心）

**调试经验**：
- 多组测试数据时发现未开long long导致WA（核心数可能超2e5）
- 排序时未正确处理同频物品的顺序会导致错误答案
- 背包转移方向错误会导致状态覆盖（计算机需倒序，订单需正序）

---
处理用时：50.59秒
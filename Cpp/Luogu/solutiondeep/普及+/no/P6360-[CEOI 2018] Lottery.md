# 题目信息

# [CEOI 2018] Lottery

## 题目背景

译自 CEOI2018 Day1 T3. [Lottery](https://ceoi2018.pl/wp-content/uploads/2018/08/lot.pdf)。

## 题目描述

**请注意特殊的内存限制。**

长期以来，你一直是 Bytelotto 的忠实粉丝，但你的家人一直告诉你所有这样的游戏都是在浪费钱。你觉得这肯定是因为他们缺少技巧。你有一个很棒的计划，每个人都将很快看到你赢得游戏。

游戏类型很多，你对其中之一感兴趣：Bitlotto。游戏规则很简单，每天随机抽取一个数字作为中奖数字。你记下了连续 $n$ 天的中奖数字 $a_1, a_2, \ldots, a_n$。你确信这当中存在某种规律，尤其是连续 $l$ 天的区间中。你的家人仍然不相信你，所以说服他们的唯一方法是可靠的数学。

一共有 $n-l+1$ 个长度为 $l$ 的区间。第 $i$ 个区间从 $i$ 开始，因此它包含元素 $a_i, a_{i+1}, \ldots, a_{i+l-1}$。定义两个区间的距离为他们对应位置上的数字不相等的数量。形式化地说，第 $x$ 个区间与第 $y$ 个区间的距离为满足 $a_{x+i}\ne a_{y+i}$ 的位置 $i\ (0\le i < l)$ 的数量。然后我们定义两个区间是 $k$-相似的当且仅当这两个区间的距离不超过 $k$。

现在给出连续 $n$ 天的中奖数字和 $q$ 个询问，每个询问给出一个整数 $k_j$，你需要对序列中的每个长度为 $l$ 的区间，求出与该区间 $k_j$-相似的区间个数（不包括本身）。

## 说明/提示

#### 样例解释

整个序列有五个长度为 $2$ 的区间：

- 第一个区间包含 $1$ $2$；
- 第二个区间包含 $2$ $1$；
- 第三个区间包含 $1$ $3$；
- 第四个区间包含 $3$ $2$；
- 第五个区间包含 $2$ $1$。

共有两个询问。

第一个询问 $k=1$。第一个和第三个区间——$1$ $2$ 和 $1$ $3$——只有第二个位置不同，所以他们的距离为 $1$。类似地，第一个和第四个区间——$1$ $2$ 和 $3$ $2$——只有第一个位置不同，所以他们的距离为 $1$。与第一个区间 $1$-相似的区间只有这两个，所以第一个数输出 $2$。

第二个询问 $k=2$，所有区间都是 $2$-相似的。

#### 数据规模与约定

对于 $100\%$ 的数据，$1\le n\le 10^4,\ 1\le a_i\le 10^9,\ 1\le q\le 100,\ 0\le k_j\le l$。

所有测试数据被划分成若干个有附加限制的子任务，每个子任务中包含若干测试点。

| 子任务 | 附加限制 | 分值 |
| :--------: | :------------: | :--: |
|    $1$     |  $n \le 300$  | $25$ |
|    $2$     | $n \le 2000$  | $20$ |
|    $3$     | $q=1, k_1=0$ | $20$ |
|    $4$     |     $q=1$      | $15$ |
|    $5$     |   无附加限制   | $20$ |

## 样例 #1

### 输入

```
6 2
1 2 1 3 2 1
2
1
2```

### 输出

```
2 1 1 1 1
4 4 4 4 4```

# AI分析结果



### 算法分类
递推、离散化

### 综合分析
题目核心是高效计算所有区间对的差异值，并通过预处理优化多组询问。各题解均采用递推方式维护滑动窗口差异值，将复杂度从 O(n²l) 优化到 O(n²)，结合离散化处理将空间复杂度优化到 O(nq)。

#### 关键思路
1. **递推优化**：利用相邻区间对的差异继承特性，每次移动窗口时通过增删头尾元素差异来更新距离值。
2. **离散化处理**：将询问的 k 值离散化映射到有序数组，通过预处理每个差异值所属的离散化桶来压缩空间。
3. **前缀和统计**：对离散化后的结果进行前缀和预处理，快速回答每个区间的相似计数。

---

### 精选题解

#### 1. fight_for_humanity（★★★★☆）
**亮点**  
- 清晰的变量命名与结构划分  
- 预处理离散化映射表时使用反向遍历处理空缺值  
- 使用 `short` 类型优化空间  

**核心实现**  
```cpp
for(int i = 2; i + l -1 <= n; ++i) {
    int tot = 0;
    for(int j=0; j<l; ++j) tot += a[1+j] != a[i+j];
    ans[1][trans[tot]]++, ans[i][trans[tot]]++;
    for(int j=1; i+j+l-1 <=n; ++j) {
        tot -= (a[j] != a[i+j-1]);
        tot += (a[j+l] != a[i+j+l-1]);
        ans[j+1][trans[tot]]++, ans[i+j][trans[tot]]++;
    }
}
```

#### 2. XuYueming（★★★★☆）
**亮点**  
- 使用更简洁的离散化预处理逻辑  
- 通过指针式遍历处理离散化映射关系  
- 显式处理最大边界值避免越界  

**核心实现**  
```cpp
int tp=1;
for(int i=0; i<=l; i++) {
    while(tp<=nq && i>lis[tp]) tp++;
    chg[i]=tp;
}
for(int i=1; i<=n-l+1; i++) {
    for(int j=1; j<=nq; j++)
        cnt[i][j] += cnt[i][j-1];
}
```

#### 3. iPhoneSX（★★★★☆）
**亮点**  
- 显式处理最大边界值 (who[m+1] = q+1)  
- 使用双指针同步移动两个区间  
- 离散化过程与统计过程解耦  

**调试心得**  
> "被卡空间了。询问的次数 q 很小，要把 ans 数组的第二维优化到 q。可以把所有查询离线下来离散化，然后记录一下每一种距离 k 属于哪一次查询。"

---

### 同类题目推荐
1. [P1102 A-B 数对](https://www.luogu.com.cn/problem/P1102) - 双指针/哈希统计差值为定值的数对  
2. [P3143 钻石收藏家](https://www.luogu.com.cn/problem/P3143) - 滑动窗口维护区间极值  
3. [P2218 覆盖问题](https://www.luogu.com.cn/problem/P2218) - 二维滑动窗口优化  

---

### 核心代码示例（递推优化 + 离散化）
```cpp
// 离散化预处理
sort(rq+1, rq+q+1);
int nq = unique(rq+1, rq+q+1)-rq-1;
for(int i=1; i<=q; i++) 
    k[i] = lower_bound(rq+1, rq+nq+1, k[i]) - rq;

// 递推计算差异值
for(int d=1; d<=n-l; d++) { // 区间起始差
    int tot = 0;
    for(int i=0; i<l; i++) 
        tot += (a[1+i] != a[1+d+i]);
    ans[1][k_bucket(tot)]++;
    ans[1+d][k_bucket(tot)]++;
    
    for(int j=1; j+d+l-1<=n; j++) {
        tot -= (a[j] != a[j+d]);
        tot += (a[j+l] != a[j+d+l]);
        ans[j+1][k_bucket(tot)]++;
        ans[j+d+1][k_bucket(tot)]++;
    }
}
```

---
处理用时：82.04秒
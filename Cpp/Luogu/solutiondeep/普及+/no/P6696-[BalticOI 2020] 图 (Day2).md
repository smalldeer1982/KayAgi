# 题目信息

# [BalticOI 2020] 图 (Day2)

## 题目描述

你有一个无向图，每条边都有一种颜色：红或者黑。

你要做的就是为每个节点配一个实数点权，使得：

- 对于每条黑色边，两个端点的点权之和为 $1$
- 对于每条红色边，两个端点的点权之和为 $2$
- 所有点权的绝对值之和是最小的

求一种点权的分配方案。

## 说明/提示

#### 评测方式

您的输出被评判为正确，当且仅当：

- 每条边所连两点的点权和与该边要求的点权间的误差不超过 $10^{-6}$。
- 所有点权的绝对值之和与标准答案误差不超过 $10^{-6}$。

#### 数据规模与约定

**本题采用捆绑测试。**

- Subtask 1（5 pts）：$N \le 5$，$M \le 14$。     
- Subtask 2（12 pts）：$N \le 100$。
- Subtask 3（17 pts）：$N \le 1000$。
- Subtask 4（24 pts）：$N \le 10^4$。
- Subtask 5（42 pts）：无特殊限制。

对于 $100\%$ 的数据，$1 \le N \le 10^5$，$0 \le M \le 2 \times 10^5$。

**本题使用 Special Judge。**

## 样例 #1

### 输入

```
4 4
1 2 1
2 3 2
1 3 2
3 4 1```

### 输出

```
YES
0.5 0.5 1.5 -0.5
```

## 样例 #2

### 输入

```
2 1
1 2 1
```

### 输出

```
YES
0.3 0.7```

## 样例 #3

### 输入

```
3 2
1 2 2
2 3 2
```

### 输出

```
YES
0 2 0```

## 样例 #4

### 输入

```
3 4
1 2 2
2 2 1
2 1 1
1 2 2
```

### 输出

```
NO```

# AI分析结果



### 算法分类
图论

---

### 题解分析与结论
题目要求对每个连通块建立点权的线性方程组，通过DFS遍历确定变量关系，处理矛盾后求最优解。各题解的共同思路如下：
1. **连通块独立处理**：每个连通块单独处理，避免相互影响。
2. **线性表达式建模**：设某点权为x，通过边约束推导其他点的权值表达式（形如±x + b）。
3. **矛盾检测**：遍历过程中检查是否出现矛盾（如两个表达式无法同时满足）。
4. **最优解确定**：若无矛盾且无法解出x，取各点表达式对应x的中位数以最小化绝对值和。
5. **回填验证**：最终验证所有边是否满足约束。

---

### 高星题解推荐
#### 1. Purslane 的题解（⭐⭐⭐⭐⭐）
**关键亮点**：  
- 通过DFS遍历建立每个点的线性表达式（k*x + b），逻辑清晰。  
- 使用中位数法快速求解最小绝对值和，时间复杂度优秀。  
- 代码中通过`calc`和`fill`函数分离矛盾检测与赋值验证，结构合理。  

**核心代码**：
```cpp
void calc(int u,int K,int B) {
    if(vis[u]) {
        if(K==k[u] && B!=b[u]) exit(0); // 矛盾检测
        if(K==k[u]) return;
        x = (b[u]-B)*1.0/(K-k[u]);      // 解方程
        flg=1;
        return;
    }
    vis[u]=1;
    for(auto t:G[u]) calc(to, -K, w-B); // 递归推导
}

void fill(int u, long double x) {
    if(Vis[u] && abs(x-val[u])>1e-7) exit(0); // 回填验证
    val[u] = x;
    for(auto t:G[u]) fill(to, w-x);     // 传播赋值
}
```

#### 2. Fuyuki 的题解（⭐⭐⭐⭐）
**关键亮点**：  
- 采用结构体`node`封装线性表达式，增强可读性。  
- 通过两次DFS分别处理矛盾检测和赋值，逻辑分层明确。  
- 利用`nth_element`优化中位数计算（题解中未实现但提到）。  

**核心思路**：
```cpp
struct node{ int x,v; /*...*/ }; // x为系数，v为常数项
void dfs1(int u) {
    for(遍历邻边){
        if(已访问) 检查表达式是否兼容;
        else 推导邻点表达式并递归;
    }
    tmp保存所有可能的x取值;
}
```

#### 3. xuyuesen 的题解（⭐⭐⭐）
**亮点**：  
- 显式处理浮点误差（`eps=1e-7`），增强鲁棒性。  
- 使用`vec`存储所有可能的x候选值，便于中位数计算。  

**改进点**：  
- 代码中未显式处理连通块，可能导致逻辑遗漏。  

---

### 关键思路总结
1. **图遍历建模**：DFS/BFS遍历连通块，建立每个点的权值表达式。  
2. **矛盾检测**：在遍历中实时检测线性方程组是否相容。  
3. **中位数优化**：当存在自由变量x时，取各约束的中位数最小化绝对值和。  
4. **回填验证**：最终遍历检查所有边是否满足约束，确保解合法。  

---

### 拓展与相似题目
1. **差分约束系统**：如 [P1993 小K的农场](https://www.luogu.com.cn/problem/P1993)（建立不等式并检测负环）。  
2. **图论中奇环检测**：如 [P1525 关押罪犯](https://www.luogu.com.cn/problem/P1525)（二分图判定）。  
3. **绝对值最优化**：如 [P3870 中位数](https://www.luogu.com.cn/problem/P3870)（直接应用中位数性质）。

---
处理用时：51.99秒
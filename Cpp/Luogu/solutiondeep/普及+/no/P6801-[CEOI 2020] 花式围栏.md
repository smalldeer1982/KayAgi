# 题目信息

# [CEOI 2020] 花式围栏

## 题目背景

0.1s，32MB

## 题目描述

众所周知，Balázs 拥有整个城镇中最漂亮的围栏。围栏由 $N$ 个部分组成，每个部分均为矩形，且相邻的两个部分间均紧密相连。第 $i$ 部分矩形的高度为 $h_i$，宽度为 $w_i$，我们需要找到满足如下条件的花式矩形：

- 矩形的每条边均是水平的或竖直的，且每条边的长度为整数。
- 矩形与地面的距离为整数。
- 矩形与围栏第一部分的左侧边的距离为整数。
- 矩形完整包含在围栏中。

现在你需要求出花式矩形的总数。因为这个数字可能很大，请输出其对 $10^9+7$ 取模后的结果。

## 说明/提示

### 样例解释 1

围栏形状如下所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/o0w99om5.png)

形状如下的矩形有 $5$ 个：

![](https://cdn.luogu.com.cn/upload/image_hosting/qvrh1vbs.png)

形状如下的矩形有 $3$ 个：

![](https://cdn.luogu.com.cn/upload/image_hosting/hx15etpn.png)

形状如下的矩形有 $1$ 个：

![](https://cdn.luogu.com.cn/upload/image_hosting/s01bhzfn.png)

形状如下的矩形有 $2$ 个：

![](https://cdn.luogu.com.cn/upload/image_hosting/ee3kec7y.png)

形状如下的矩形有 $1$ 个：

![](https://cdn.luogu.com.cn/upload/image_hosting/n26e8gyi.png)

### 样例 2

见附加文件。

### 子任务

所有测试点均满足：$1 \leq N \leq 10^5$，$1 \leq h_i,w_i \leq 10^9$。

各子任务的约束条件如下：

| 子任务编号 | 分值 | 约束                                                         |
| ---------- | ---- | ------------------------------------------------------------ |
| $1$        | $0$  | 样例                                                         |
| $2$        | $12$ | $N \leq 50$，且 $\forall i \in [1,N]$，$h_i \leq 50$ 且 $w_i=1$ |
| $3$        | $13$ | $\forall i \in [1,N]$，$h_i=1$ 或 $h_i=2$                    |
| $4$        | $15$ | 所有的 $h_i$ 均相等                                          |
| $5$        | $15$ | $\forall i \in [1,N-1]$，$h_i \leq h_{i+1}$                  |
| $6$        | $18$ | $N \leq 1000$                                                |
| $7$        | $27$ | 无特殊约束                                                   |

## 样例 #1

### 输入

```
2
1 2
1 2```

### 输出

```
12```

# AI分析结果



**算法分类**: 单调栈、组合数学

---

### **综合分析**
题目要求计算由多个连续矩形组成的围栏中包含的所有子矩形数量。核心难点在于处理高度变化和快速计算矩形贡献。所有题解均基于**单调栈**维护高度递增序列，结合组合数学公式计算矩形数量，并通过容斥原理避免重复计算。

---

### **精选题解与亮点**

1. **Alex_Wei (5星)**
   - **关键思路**: 使用单调栈维护高度递增序列，削去栈顶元素时用组合公式计算贡献差（容斥），代码简洁高效。
   - **代码亮点**:
     ```cpp
     stack<int> a, b;
     int calc(int x) { return 1ll * x * (x + 1) / 2 % mod; }
     while (h[i] <= a.top()) {
         int hh = a.top(), ww = b.top(); 
         a.pop(), b.pop(), s = (s + ww) % mod;
         ans = (ans + (calc(hh) - calc(max(h[i], a.top())) + mod) * calc(s)) % mod;
     }
     ```
   - **优化点**: 组合数公式 `C(w+1,2)*C(h+1,2)` 快速计算矩形数，边界处理优雅。

2. **StudyingFather (4星)**
   - **关键思路**: 类似单调栈框架，代码逻辑清晰，通过前缀和累计宽度贡献。
   - **数学推导**: 公式 `(h*(h+1)/2) * (w*(w+1)/2)` 计算矩形数，与容斥结合。

3. **s_r_f (4星)**
   - **分解问题**: 将贡献拆分为单个矩形和跨区间矩形，利用单调栈优化极值区间计算。
   - **公式简化**: `f(x) = x(x+1)/2` 降低计算复杂度，避免重复求和。

---

### **关键技巧总结**
1. **单调栈维护高度**：动态处理高度递减部分，计算被削去区域的贡献。
2. **组合数快速计算**：用 `C(n,2) = n(n+1)/2` 公式快速计算子矩形数量。
3. **容斥原理**：通过贡献差（原高度贡献 - 削去后剩余高度贡献）避免重复计数。

---

### **拓展应用**
- **类似题目**：柱状图最大矩形（LeetCode 84）、二维最大子矩形（P4147 玉蟾宫）、动态高度合并（P1950 长方形）。
- **算法套路**：单调栈处理极值区间 + 组合数学公式快速计算贡献。

---

### **推荐题目**
1. [P1901 发射站](https://www.luogu.com.cn/problem/P1901) - 单调栈处理能量传递。
2. [P4147 玉蟾宫](https://www.luogu.com.cn/problem/P4147) - 最大子矩形面积。
3. [P1950 长方形](https://www.luogu.com.cn/problem/P1950) - 动态计算子矩形数量。

---
处理用时：48.36秒
# 题目信息

# [NEERC 2013] Kabaleo Lite

## 题目描述

有一种棋盘游戏：棋盘上有 $n$ 个格子，每个格子上可以堆叠若干个有颜色的筹码，只有每个格子中最上方的筹码的颜色是可见的。

参加游戏的每个玩家都有各自不同的一个目标颜色，以及一些彩色筹码。每个人只知道自己的目标颜色，但各自拥有的筹码颜色和数量都是公开的。每个回合中，所有玩家轮流在棋盘上选一个格子放置筹码，同时覆盖下方的筹码。游戏结束后，数出棋盘上可见筹码数最多的颜色，以该颜色为目标颜色的玩家即获胜。若该颜色不是任何玩家的目标颜色，或者棋盘上出现最多的颜色不唯一，则游戏平局。

现在，一局游戏进行到了最后，你和其他所有玩家都只剩最后一个筹码。现在恰好轮到你操作，在不知道其他人的目标颜色的前提下，你想知道你一共有哪些操作可以保证必胜。

## 样例 #1

### 输入

```
6 3 4 2
2 1 2 3 2 2
2 1 1
```

### 输出

```
1
2
```

# AI分析结果

### 算法分类
**枚举**

### 综合分析与结论
本题的核心在于枚举所有可能的操作，并通过模拟来判断哪些操作能够保证必胜。两位作者的题解都采用了类似的思路，即通过枚举每个格子并计算在该格子放置筹码后，棋盘上各颜色的出现次数，从而判断是否能够保证必胜。极寒神冰的题解在优化上做得更好，通过预处理和快速判断减少了时间复杂度，而XIxii的题解则更直接，代码更简洁。

### 所选题解
#### 1. 极寒神冰 (5星)
**关键亮点：**
- 通过预处理和快速判断优化了时间复杂度，从 $\mathcal O(n^2)$ 降低到 $\mathcal O(n+c)$。
- 详细分析了其他玩家联合对抗的情况，确保了算法的正确性。

**核心代码：**
```cpp
inline int check(int x)
{	
	if(n==1&&l[p]==h) return 1;
	--cnt[b[x]];
	++cnt[l[1]];
	int del=cnt[h]-cy;
	bool ok=1;
	if(del<=0) ok=0;
	if(cnt[mx]>=del) ok=0;
	if(cnt[mmx]>=del) ok=0;
	if(l[1]!=h&&cnt[l[1]]>=del) ok=0;
	++cnt[b[x]];
	--cnt[l[1]];
	return ok;
}
```
**核心思想：**
通过模拟在每个格子放置筹码后的情况，快速判断是否能够保证必胜。

#### 2. XIxii (4星)
**关键亮点：**
- 代码简洁，直接枚举并判断每个格子是否能够保证必胜。
- 特判了 $n=1$ 的情况，确保了算法的全面性。

**核心代码：**
```cpp
bool Judge(int pos)
{
	int k=s[h]-cnt;
	if(k<=0) 
		k+=ext;
	return !(s[max1]>=k || s[max2]>=k || (b[1]!=h && s[b[1]]>=k));
}
```
**核心思想：**
通过枚举每个格子并计算在该格子放置筹码后，棋盘上各颜色的出现次数，从而判断是否能够保证必胜。

### 最优关键思路或技巧
- **预处理与快速判断**：通过预处理减少重复计算，快速判断每个格子是否能够保证必胜。
- **模拟与枚举**：通过模拟每个操作后的棋盘状态，枚举所有可能的操作，确保算法的全面性。

### 可拓展之处
- **类似题目**：可以考虑其他需要枚举和模拟的题目，如棋盘游戏、策略游戏等。
- **优化思路**：在其他需要枚举的题目中，可以通过预处理和快速判断来优化时间复杂度。

### 推荐题目
1. [P1002 过河卒](https://www.luogu.com.cn/problem/P1002)
2. [P1048 采药](https://www.luogu.com.cn/problem/P1048)
3. [P1057 传球游戏](https://www.luogu.com.cn/problem/P1057)

---
处理用时：16.16秒
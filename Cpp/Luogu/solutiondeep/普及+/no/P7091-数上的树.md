# 题目信息

# 数上的树

## 题目背景

**本题自动开启 O2 优化，时间限制 2s。**

## 题目描述

您需要构造一棵二叉树，根节点权值为 $n$，每个节点都有 $2$ 个或 $0$ 个儿子，且满足如下限制：

若该点有两个儿子，该点权值需等于两个儿子的权值之积。

若该点没有儿子，则该节点权值需为质数。

同时会给出 $m$ 条限制 $a_i$，表示树上的权值不能出现 $a_i$。

您构造的二叉树需要使：令 $k$ 为节点数， $\sum\limits_{i=1}^k\sum\limits_{j=i}^kval_{lca(i,j)}$ 最小，其中 $val_i$ 表示第 $i$ 个点的权值，$lca(i,j)$ 表示 $i,j$ 的最近公共祖先。

## 说明/提示

样例解释：

样例 $1$：最优方案如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/2dcec565.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

其中，黑色数字代表权值，红色数字代表标号（您不需要对树标号，这里的标号只是为了更方便解释样例）。

$ans=val_{lca(1,1)}+val_{lca(1,2)}+val_{lca(1,3)}+val_{lca(2,2)}+val_{lca(2,3)}+val_{lca(3,3)}$

$~~~~~~~~=val_1+val_1+val_1+val_2+val_1+val_3$

$~~~~~~~~=4+4+4+2+4+2=20$

Subtask 1（5 分）： $n\leq 20$。

Subtask 2（12 分）：$n\leq 10^6$。

Subtask 3（28 分）：$n\leq 10^{12}$。

Subtask 4（20 分）：$m=0$。

Subtask 5（35 分）：$n\leq 10^{15}$。

对于所有数据 $2\leq n\leq 10^{15}$，$0\leq m\leq \min(n,10^5)$，$2\leq a_i\leq n$， 且答案不超过 $4\times 10^{18}$。

## 样例 #1

### 输入

```
4 0```

### 输出

```
20```

## 样例 #2

### 输入

```
12 1
4```

### 输出

```
127```

## 样例 #3

### 输入

```
192 1
2```

### 输出

```
-1```

# AI分析结果

### 算法分类
动态规划

### 综合分析与结论
题目要求构造一棵二叉树，使得满足特定条件的同时，最小化所有节点对的最近公共祖先权值之和。核心思路是通过动态规划（DP）来枚举所有可能的子树分解方式，并计算每种分解方式的最小值。难点在于如何高效地枚举因数和优化DP转移。

### 所选题解
#### 题解1：Alex_Wei (赞：13)
- **星级**：5星
- **关键亮点**：
  - 详细解释了DP状态转移方程，并给出了优化剪枝策略。
  - 通过预处理因数和二分查找处理限制条件，提高了效率。
  - 代码结构清晰，注释详细，易于理解。
- **个人心得**：
  - 通过剪枝1和剪枝2，将时间复杂度从O(c^3)降为O(c^2)，显著提高了算法效率。

```cpp
ll n,m,num[N],f[N];
ll cnt,pr[N],c[N],tot;
ll fc[N],il[N],d;
map <ll,int> isp;

void dfs(int pos,ll prod){
	if(pos>cnt){
		if(prod>1)fc[++d]=prod;
		return;
	} for(int i=0;i<=c[pos];i++)dfs(pos+1,prod),prod*=pr[pos];
}

int main(){
	
	cin>>n>>m;
	// factor
	ll tmp=n;
	for(ll i=2;i*i<=n;i++)
		if(n%i==0){
			pr[++cnt]=i,isp[i]=1;
			while(n%i==0)c[cnt]++,tot++,n/=i;
		}
	if(n>1)pr[++cnt]=n,tot++,c[cnt]=1,isp[n]=1;
	n=tmp;
	
	// find factors
	dfs(1,1);
	sort(fc+1,fc+d+1);
	
	// limit
	for(int i=1;i<=m;i++){
		ll val=read();
		int pos=lower_bound(fc+1,fc+d+1,val)-fc;
		if(pos<=d&&fc[pos]==val)il[pos]=1; // 表示 pos 不能出现
	}
	
	// dp
	for(int i=1;i<=d;i++){
		if(il[i])continue;
		if(isp[fc[i]]){
			num[i]=1,f[i]=fc[i];
			continue;
		} il[i]=1,f[i]=inf; // 如果无法由以前的 j,k 转移得到那么 i 也无法得到
		int p=i-1;
		for(int j=1;j<i;j++){
			if(fc[i]%fc[j])continue;
			while(fc[p]>fc[i]/fc[j])p--;
			if(j>p)break;
			if(!il[j]&&!il[p])f[i]=min(f[i],f[j]+f[p]+num[j]*num[p]*fc[i]+(num[i]=num[j]+num[p]+1)*fc[i]),il[i]=0;
		}
	} if(il[d])puts("-1");
	else cout<<(ll)f[d]<<endl;
	return 0;
}
```

#### 题解2：gyh20 (赞：9)
- **星级**：4星
- **关键亮点**：
  - 提出了多种算法策略，从搜索到DP，逐步优化。
  - 通过枚举因数并优化转移，使得算法在较大数据范围内仍能高效运行。
  - 代码简洁，逻辑清晰。

```cpp
#include<cstdio>
#include<algorithm>
#include<map>
#include<cmath>
using namespace std;
#define re register
long long n,pri[1000002],num[1000002],dp[1000002];
map<long long,bool>vis;
map<long long,int>pos;
int cntt,cnttt,m,cnt;
inline int dfs(re long long x){
	if(pos.count(x))return pos[x];
	re int xx=sqrt(x);pos[x]=++cntt;re int y=cntt;
	dp[y]=4e18;
	for(re int i=1;i<=cnt&&pri[i]<=xx;++i){++cnttt;
		if(x%pri[i]==0){
			re int ls=dfs(pri[i]),rs=dfs(x/pri[i]);
			num[y]=num[ls]+num[rs]+1;
			dp[y]=min(dp[y],(num[ls]+1)*(num[rs]+1)*x+dp[ls]+dp[rs]);
		}
	}
	if(!num[y])num[y]=1,dp[y]=x;
//	printf("%lld %d\n",x,y);
	if(vis.count(x))dp[y]=4e18;
	return y;
}
signed main(){
//	freopen("a30.in","r",stdin);
//	freopen("a30.out","w",stdout);
	scanf("%lld%d",&n,&m);
	re long long x;
	for(re int i=1;i<=m;++i)scanf("%lld",&x),vis[x]=1;
	if(vis.count(n))return puts("-1"),0;
	re int xx=sqrt(n);
	for(re int i=2;i<=xx;++i)if(n%i==0)pri[++cnt]=i;
	dfs(n);
	printf("%lld",dp[pos[n]]==4e18?-1:dp[pos[n]]);
}
```

### 最优关键思路或技巧
1. **动态规划**：通过DP枚举所有可能的子树分解方式，计算每种分解方式的最小值。
2. **剪枝优化**：通过剪枝策略减少不必要的计算，显著提高算法效率。
3. **预处理与二分查找**：预处理因数和限制条件，使用二分查找快速定位，提高处理速度。

### 可拓展之处
类似的问题可以通过动态规划和剪枝策略进行优化，特别是在处理树形结构和因数分解时。其他类似问题包括树的构造、最优路径选择等。

### 推荐题目
1. [P1040 加分二叉树](https://www.luogu.com.cn/problem/P1040)
2. [P2014 选课](https://www.luogu.com.cn/problem/P2014)
3. [P2015 二叉苹果树](https://www.luogu.com.cn/problem/P2015)

---
处理用时：35.40秒
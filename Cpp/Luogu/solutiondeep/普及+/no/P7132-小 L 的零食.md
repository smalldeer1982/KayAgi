# 题目信息

# 小 L 的零食

## 题目背景

小 L 很喜欢吃零食。

## 题目描述

**提交时自动开启 O2 优化**。

小 L 现在想把一些零食放在一个盒子里。但是零食没放稳就会摔坏，所以小 L 希望求出**有多少种稳定的堆放零食的方法**。

零食都可以抽象成一个 $1\times1$ 的正方形，而盒子的底部可以看成长度为 $n$ 的一维线段。准确地说，零食被分为 $n$ 堆，从左到右地放在盒子里面，依次记为第 $1,2,\ldots,n$ 堆。我们认为每一堆的高度 $h_i$ 是这一堆零食的数量，且任意一堆都可以不包含任何零食。

我们定义第 $i$ 堆零食是稳定的，当且仅当：

- $h_i\le m$，即这一堆零食高度不超过 $m$。
- 在满足上一条的同时，满足以下两条之一或同时满足：
  - $i=1$ 或 $i=n$，此时有一侧是盒子内壁所以这一堆不会倒下；
  - $\color{red}\max\{h_{i-1},h_{i+1}\}\ge h_i-d_i$，此时它两侧的两堆零食有一堆足够高可以支撑这一堆不倒下。

我们定义一种稳定的堆放零食的方法，是一个长度为 $n$ 的 $h_i$ 的序列，满足按这个序列堆放出来的零食每一堆都是稳定的。

显然盒子里最多放下 $n\times m$ 个零食，我们认为小 L 的零食数量不少于 $n\times m$，并且不必将所有零食全部放进盒子。额外地，我们认为**每一个零食都是完全一样的**。

## 说明/提示

本题采用如下计分策略：    
**subtask $1$**（#$1$~#$8$）：$10\%$，$n,m\le5$；  
**subtask $2$**（#$9$~#$12$）：$30\%$，$n,m\le5\times10^2$；  
**subtask $3$**（#$13$~#$16$）：$20\%$，$n,m\le3\times10^3$；  
**subtask $4$**（#$17$~#$24$）：$40\%$，$n,m\le7\times10^3$。  
对于 $100\%$ 的数据：$1\le n,m\le7\times10^3$，$0\le d_i\le m$。**你必须通过一个 subtask 内所有测试点，才被认为通过该 subtask。**

**本题开启子任务依赖。**

## 样例 #1

### 输入

```
3 3
3 1 1 ```

### 输出

```
59```

## 样例 #2

### 输入

```
10 13
12 13 1 4 5 9 7 0 3 8 ```

### 输出

```
851695394```

# AI分析结果

### 算法分类
动态规划

### 综合分析与结论
题目要求计算所有可能的稳定堆放零食的方法数，核心在于如何通过动态规划（DP）来处理每一堆零食的高度限制和稳定性条件。两位作者都采用了DP的思路，但在状态定义和转移方程的处理上有所不同。

1. **Alex_Wei的题解**：
   - 使用两个状态数组 `f` 和 `g` 分别表示第 `i` 堆零食是否靠到第 `i-1` 堆零食上的情况。
   - 通过前缀和优化和滚动数组优化，将时间复杂度控制在 `O(nm)`。
   - 代码清晰，逻辑严谨，优化到位。

2. **dead_X的题解**：
   - 使用两个状态数组 `ans` 和 `pre` 分别表示第 `i` 堆零食是否满足稳定性条件的情况。
   - 通过前缀和优化和滚动数组优化，同样将时间复杂度控制在 `O(nm)`。
   - 代码实现较为简洁，但逻辑稍显复杂。

### 所选题解
#### 题解1：Alex_Wei (5星)
**关键亮点**：
- 状态定义清晰，分别处理了靠到前一堆和不靠到前一堆的情况。
- 转移方程推导严谨，前缀和优化和滚动数组优化使得代码高效。
- 代码可读性强，注释清晰。

**核心代码**：
```cpp
const int N=7e3+5;

ll n,m,d[N],f[2][N],g[2][N];

int main(){
    cin>>n>>m; for(int i=1;i<=n;i++)cin>>d[i];
    for(int i=0;i<=m;i++)f[1][i]=i+1;
    for(int i=2;i<=n;i++){
        int p=i&1,q=p^1;
        for(int j=0;j<=m;j++){
            int l=max(0ll,j-d[i]),r=min(m,j+d[i-1]);
            f[p][j]=(f[q][m]+g[q][r]-(l?f[q][l-1]+g[q][l-1]:0)+(j?f[p][j-1]:0)+mod)%mod;
            g[p][j]=((l?f[q][l-1]+g[q][l-1]:0)+(j?g[p][j-1]:0))%mod;
        }
    } cout<<(f[n&1][m]+g[n&1][m])%mod<<endl;
    return 0;
}
```

#### 题解2：dead_X (4星)
**关键亮点**：
- 状态定义合理，分别处理了满足和不满足稳定性条件的情况。
- 前缀和优化和滚动数组优化使得代码高效。
- 代码实现简洁，但逻辑稍显复杂。

**核心代码**：
```cpp
int d[7003];
long long ans[7003][2],pre[7003][2]; 
const long long p=998244353;

signed main()
{
    int n=read(),m=read();
    for(int i=1; i<=n; ++i) d[i]=read();
    for(int i=0; i<=m; ++i) pre[i][1]=i+1;
    for(int i=2; i<=n; ++i) 
    {
        for(int j=0; j<=m; j++)
        ans[j][1]=(pre[min(j+d[i-1],m)][0]+(j-d[i]<=0?0:p-pre[j-d[i]-1][0])+pre[m][1]+(j-d[i]<=0?0:p-pre[j-d[i]-1][1]))%p,
        ans[j][0]=(j-d[i]-1<0?0:(pre[j-d[i]-1][1]+pre[j-d[i]-1][0])%p);
        pre[0][1]=ans[0][1],pre[0][0]=ans[0][0];
        for(int j=1; j<=m; j++) pre[j][1]=(pre[j-1][1]+ans[j][1])%p,pre[j][0]=(pre[j-1][0]+ans[j][0])%p;
    }
    printf("%lld\n",(pre[m][0]+pre[m][1])%p);
    return 0;
}
```

### 最优关键思路或技巧
- **状态定义**：将每一堆零食的状态分为是否靠到前一堆零食上，简化了转移方程的推导。
- **前缀和优化**：通过前缀和优化，快速计算区间和，减少时间复杂度。
- **滚动数组优化**：使用滚动数组减少空间复杂度，适用于大规模数据。

### 可拓展之处
- 类似的问题可以扩展到二维或更高维度的堆放问题，状态定义和转移方程会更为复杂。
- 可以结合其他优化技巧，如记忆化搜索、剪枝等，进一步提高算法效率。

### 推荐题目
1. [P1048 采药](https://www.luogu.com.cn/problem/P1048) - 经典DP问题，状态转移与本题类似。
2. [P1060 开心的金明](https://www.luogu.com.cn/problem/P1060) - 背包问题，状态转移与本题类似。
3. [P1091 合唱队形](https://www.luogu.com.cn/problem/P1091) - 双序列DP问题，状态转移与本题类似。

---
处理用时：33.48秒
# 题目信息

# 「EZEC-5」人赢 加强版

## 题目背景

> “我们在 小 Z 面前秀个恩爱吧。”\
>“好的。”

小 Z 发现他身边都是人赢，这使他非常自闭。

小 Z 又看着身边的潇，不禁陷入了沉思……

![](https://cdn.luogu.com.cn/upload/image_hosting/b1ij58kc.png)

## 题目描述

潇有一个数组 $k$，下标为 $1$ 到 $n$ 。

潇定义 $f(x,y)=\begin{cases} \min(k_x,k_y) \times (x + y) &x \ne y \\ k_x\times x&x=y \end{cases}$ 。

潇想知道对于任意的 $1 \le x,y \le n$，$f(x,y)$ 的最大值是多少。但是她不会做，于是就问了善良的 小 Z，然而非常想在妹子面前表现的 小 Z 发现他也不会做，就只能够求助善良的你了。

## 说明/提示

### 数据范围

**本题采用捆绑测试。**

- Subtask 1（10 points）：$1 \le n \le 50$。

- Subtask 2（20 points）：$1 \le n \le 5000$。

- Subtask 3（20 points）：$1 \le n \le 10^6$。

- Subtask 4（10 points）：保证所有 $k_{i}$ 都相等。

- Subtask 5（40 points）：无特殊限制。

对于 $100\%$ 的数据，$1 \le n \le 10^7$，$1 \le k_{i} \le 10^9$。

**本题建议使用较快的读入方式。**

std 使用的快读：

```cpp
#define getchar()(p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
char buf[1<<21],*p1=buf,*p2=buf;
inline int read()
{
    char c=getchar();int x=0;bool f=0;
    for(;!isdigit(c);c=getchar())f^=!(c^45);
    for(;isdigit(c);c=getchar())x=(x<<1)+(x<<3)+(c^48);
    if(f)x=-x;return x;
}
```

## 样例 #1

### 输入

```
3
3 2 1```

### 输出

```
6```

## 样例 #2

### 输入

```
5
3 4 5 4 3```

### 输出

```
28```

# AI分析结果

### 算法分类
贪心

### 综合分析与结论
该题的核心问题在于如何高效地找到使 $f(x,y)$ 最大的 $(x,y)$ 对。大多数题解都采用了贪心策略，通过从后往前遍历数组，维护当前最大值，并利用其与当前元素的组合来更新答案。这种方法的时间复杂度为 $O(n)$，能够很好地处理 $n \leq 10^7$ 的数据范围。

### 所选高星题解
1. **作者：pigstd (5星)**
   - **关键亮点**：官方题解，思路清晰，代码简洁，直接从后往前遍历并维护最大值，时间复杂度为 $O(n)$。
   - **核心代码**：
     ```cpp
     for (int i=n-1,l=n;i>=1;i--) {
         ans=max(ans,f(i,l));
         if (a[i]>a[l]) l=i;
     }
     ```
   - **个人心得**：通过从后往前遍历，确保每次更新时都能找到当前最优的组合，避免了不必要的计算。

2. **作者：Alex_Wei (5星)**
   - **关键亮点**：提供了正序和倒序两种处理方式，详细证明了贪心策略的正确性，代码实现简洁高效。
   - **核心代码**：
     ```cpp
     for(int i=n-1;i>=1;i--) {
         ans=max(ans,1ll*(i+id)*k[i]);
         if(k[i]>k[id]) id=i;
     }
     ```
   - **个人心得**：通过单调栈维护候选的最大值，确保每次更新时都能找到最优的组合，时间复杂度为 $O(n)$。

3. **作者：囧仙 (5星)**
   - **关键亮点**：详细解释了单调栈的使用，通过实例展示了如何利用单调栈维护最大值，并证明了算法的正确性。
   - **核心代码**：
     ```cpp
     while(s&&S[s][1]<=A[i]) {
         ans=max(ans,1ll*(S[s][0]+i)*S[s][1]),--s;
     }
     if(s) ans=max(ans,1ll*(S[s][0]+i)*A[i]);
     S[++s][0]=i,S[s][1]=A[i];
     ```
   - **个人心得**：通过单调栈维护候选的最大值，确保每次更新时都能找到最优的组合，时间复杂度为 $O(n)$。

### 最优关键思路或技巧
- **贪心策略**：从后往前遍历数组，维护当前最大值，并利用其与当前元素的组合来更新答案。
- **单调栈**：利用单调栈维护候选的最大值，确保每次更新时都能找到最优的组合。

### 可拓展之处
- **类似题目**：在处理最大值或最小值相关的问题时，贪心策略和单调栈是常用的优化手段。
- **思维模式**：在处理数组问题时，从后往前遍历往往能简化问题，尤其是在需要维护最大值或最小值的情况下。

### 推荐题目
1. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)
2. [P1440 求m区间内的最小值](https://www.luogu.com.cn/problem/P1440)
3. [P1901 发射站](https://www.luogu.com.cn/problem/P1901)

---
处理用时：22.03秒
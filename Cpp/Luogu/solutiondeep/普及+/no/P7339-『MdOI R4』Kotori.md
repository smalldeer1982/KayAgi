# 题目信息

# 『MdOI R4』Kotori

## 题目背景

『「因为」？所以呢？』

『因为我是你的妹妹，所以你要叫我别阻止你胡来么？』

『因为我是你的妹妹，所以你要叫我看着你赴死么？』

『因为我是你的妹妹，所以你要叫我默默看着你可能被杀死么？』

『不要开玩笑了，这算什么啊！还以为好不容易和平下来了，还以为士道终于不用再受伤了。』

『我——我不希望士道死掉，不想再看到士道受伤了，已经受不了再让士道感到痛苦了啊……』

『因为我——』

『喜欢士道呀——』

![](https://cdn.luogu.com.cn/upload/image_hosting/s0f5nxk0.png)

## 题目描述

一年一度的世界最萌大会开始了。作为曾经的「萌王」，Kotori 自然无需参赛。但她希望帮助自己的哥哥  Shido 获得「燃王」的头衔。

本届 ISML 共有 $n=2^k$ 名参赛选手，编号为 $1,2\ldots n$，其中 Shido 的编号是 $1$，赛制为淘汰赛。每一轮比赛之后剩余选手中编号最小的两人为对手，编号第 $3,4$ 小的两人为对手，依次类推。每场比赛的胜负取决于粉丝的投票数，获得票数较多的一方晋级下一轮比赛，票数较少的一方淘汰。

例如共有 $4$ 名选手，则第一轮编号为 $1,2$ 的选手进行一场比赛，编号 $3,4$ 的选手进行一场比赛，然后两场比赛的胜者进行一场比赛，争夺总冠军。获得总冠军的选手将获得「燃王」头衔。

每个角色有一个厨团，$i$ 号选手的厨团人数为 $a_i$。每轮投票时，所有厨团的成员**会且仅会**为对应的选手投票。

此外，Kotori 拥有一个人数为 $m$ 人的团队，他们会永远跟随 Kotori 投票。也就是说，每场比赛 Kotori 都可以为对战双方的任意一者增加 $m$ 张得票。注意在一轮比赛中可能有多场比赛，每场比赛一定只有两名选手。

另外，Kotori 还拥有一项特权：当某场比赛双方的票数相同时，作为萌王的她可以决定这场比赛的胜者。

现在，Kotori 希望知道，她是否有能力帮助哥哥成为冠军，获得「燃王」的头衔。

## 说明/提示

【样例解释 #1】

对于 $1$ 组数据，并不存在让 Shido 成为燃王的方案。

对于第 $2$ 组数据，考虑以下方案：

第 $1$ 轮：
- $1$ 号和 $2$ 号比赛，把票给 $1$ 号，$2$ 号淘汰。
- $3$ 号和 $4$ 号比赛，把票给 $3$ 号，$4$ 号淘汰。
- $5$ 号和 $6$ 号比赛，把票给 $6$ 号，$5$ 号淘汰。
- $7$ 号和 $8$ 号比赛，把票给 $7$ 号，$7$ 号淘汰。

第 $2$ 轮：
- $1$ 号和 $3$ 号比赛，把票给 $1$ 号，$3$ 号淘汰。
- $6$ 号和 $8$ 号比赛，把票给 $6$ 号，$8$ 号淘汰。

第 $3$ 轮：
- $1$ 号和 $6$ 号比赛，把票给 $1$ 号，$6$ 号淘汰。

【数据规模与约定】

**本题采用捆绑测试**

| 子任务编号 | $k\le$    |$\sum n\le$ | $m\le $    | 分值  |
| -----|------ | ---------- | ---------- | ----- |
| $1$        | $0$  |$1$      | 无特殊限制 | $1$   |
| $2$        | $1$     |$2^{11}$   | 无特殊限制 | $9$   |
| $3$        | $4$  |$2^{14} $     | 无特殊限制 | $15$  |
| $4$        | 无特殊限制 |$2^{20}$| $0$        | $10 $ |
| $5$        | $9$   |   $2^{11}$| 无特殊限制 | $20$  |
| $6$        | $15$   |$2^{17}$    | 无特殊限制 | $20$  |
| $7$        | $18$   |$2^{20} $   | 无特殊限制 | $25$  |

对于 $100\%$ 的数据，$\sum n\le 2^{20}$，$0\le k\le 18$，$0\le m,a_i\le 10^9$。

【提示与帮助】

本题读入量较大，请选手选择较快的读入方式。

本题中的“世界最萌大会”与真正的“世界最萌大会”有所不同，在本题中请以本题为准。

## 样例 #1

### 输入

```
3
3 6
2 0 0 5 0 9 0 9
3 6
2 0 5 0 0 5 0 9
2 6
2 0 0 5
```

### 输出

```
Yoshino
Kotori
Kotori
```

# AI分析结果

### 算法分类
分治

### 综合分析与结论
本题的核心是通过分治策略，递归地处理每一轮比赛的可能胜者，最终判断1号选手是否能成为冠军。分治的思想是将问题划分为更小的子问题，逐步合并结果，最终得到全局解。各题解中，分治结合归并排序的思路被广泛应用，通过递归和归并排序来维护每个区间的可能胜者，并判断1号选手是否能胜出。

### 所选题解
1. **作者：Caesium**
   - **星级：5星**
   - **关键亮点**：详细解释了分治与归并排序的结合，代码实现清晰，且通过归并排序优化了时间复杂度。题解中还提到了贪心的不可行性，强调了分治的正确性。
   - **核心代码**：
     ```cpp
     int merge(int l,int r){
         if(l==r) return 1;
         int mid=(l+r)>>1;
         int tl=merge(l,mid)+l-1;
         int tr=merge(mid+1,r)+mid;
         int nl=l,nr=mid+1;
         if(a[b[nl]]<a[b[nr]]){
             while(nl<=tl && a[b[nl]]+k<a[b[nr]]) nl++;
         }else{
             while(nr<=tr && a[b[nr]]+k<a[b[nl]]) nr++;
         }
         int top=l-1;
         while(nr<=tr && nl<=tl){
             if(a[b[nl]]<a[b[nr]]) c[++top]=b[nl++];
             else c[++top]=b[nr++];
         }
         while(nl<=tl) c[++top]=b[nl++];
         while(nr<=tr) c[++top]=b[nr++];
         for(int i=l;i<=top;i++) b[i]=c[i];
         return top-l+1;
     }
     ```
   - **个人心得**：Caesium提到考试时曾陷入贪心的误区，最终通过分治解决了问题，强调了贪心的不可行性。

2. **作者：water_tomato**
   - **星级：4星**
   - **关键亮点**：通过分治和归并排序维护每个区间的可能胜者，代码简洁且易于理解。题解中还详细解释了如何通过归并排序优化时间复杂度。
   - **核心代码**：
     ```cpp
     inline int merge(int l,int r){
         if(l==r) return 1;
         int mid=(l+r)>>1;
         int L=merge(l,mid)+l-1;
         int R=merge(mid+1,r)+mid;
         int i=l,j=mid+1,cnt=l-1;
         if(a[i].val<=a[j].val){
             while(i<=L&&a[i].val+m<a[j].val) i++;
         }else{
             while(j<=R&&a[j].val+m<a[i].val) j++;
         }
         while(i<=L&&j<=R){
             if(a[i].val<a[j].val) b[++cnt]=a[i++];
             else b[++cnt]=a[j++];
         }
         while(i<=L) b[++cnt]=a[i++];
         while(j<=R) b[++cnt]=a[j++];
         for(int i=l;i<=cnt;i++) a[i]=b[i];
         return cnt-l+1;
     }
     ```
   - **个人心得**：water_tomato提到通过分治和归并排序的结合，成功解决了问题，强调了分治的正确性。

3. **作者：轻绘**
   - **星级：4星**
   - **关键亮点**：通过分治和归并排序维护每个区间的可能胜者，代码实现清晰，且通过归并排序优化了时间复杂度。题解中还详细解释了如何通过归并排序优化时间复杂度。
   - **核心代码**：
     ```cpp
     inline int get(int l,int r){
         if(l==r){
             a[l]=l;
             return 1;
         }
         int l1,r1,l2,r2,mid;
         mid=(l+r)>>1;
         r1=get(l,mid)+l-1;
         r2=get(mid+1,r)+mid;
         num=l-1;
         l1=l,l2=mid+1;
         if(c[a[l1]]+m<=c[a[l2]])
             while(l1<=r1 && c[a[l1]]+m<c[a[l2]]) ++l1;
         else
             while(l2<=r2 && c[a[l2]]+m<c[a[l1]]) ++l2;
         while(l1<=r1 && l2<=r2){
             if(c[a[l1]]<=c[a[l2]]) b[++num]=a[l1++];
             if(c[a[l2]]<c[a[l1]]) b[++num]=a[l2++];
         }
         while(l1<=r1) b[++num]=a[l1++];
         while(l2<=r2) b[++num]=a[l2++];
         for(int i=l;i<=num;i++) a[i]=b[i];
         return num-l+1;
     }
     ```
   - **个人心得**：轻绘提到通过分治和归并排序的结合，成功解决了问题，强调了分治的正确性。

### 最优关键思路或技巧
1. **分治与归并排序结合**：通过分治将问题划分为更小的子问题，结合归并排序维护每个区间的可能胜者，优化了时间复杂度。
2. **贪心的不可行性**：贪心策略在该问题中不可行，分治是更合适的解决方案。

### 可拓展之处
类似的分治与归并排序结合的方法可以应用于其他需要递归处理并合并结果的题目，如区间合并、区间查询等问题。

### 推荐题目
1. [P1908 逆序对](https://www.luogu.com.cn/problem/P1908)
2. [P3374 【模板】树状数组 1](https://www.luogu.com.cn/problem/P3374)
3. [P3384 【模板】树链剖分](https://www.luogu.com.cn/problem/P3384)

---
处理用时：37.25秒
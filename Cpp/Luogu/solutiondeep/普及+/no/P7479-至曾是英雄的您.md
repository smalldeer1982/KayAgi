# 题目信息

# 至曾是英雄的您

## 题目背景

YSGHYYDS

## 题目描述

YSGH 有一个 $n\times m$ 的围棋棋盘，初始时，每个位置要么是空的，要么有一个黑棋棋子。**保证黑棋是连通的。**

在围棋中，一个棋子的「气」是与它相邻的所有**空**位置构成的集合。

设棋盘上第 $i$ 行第 $j$ 个位置为 $(i,j)$。

两个分别在 $(i_1,j_1)$ 和 $(i_2,j_2)$ 的**同色**棋子如果满足 $|i_1-i_2|+|j_1-j_2|=1$，就认为是相邻的，也就是在同一个连通块里。

一个连通块的「气」是这个连通块中所有棋子的「气」的并集。

白方走一步棋是合法的，当且仅当走完这手棋之后这个棋子所在连通块的「气」大于等于 $1$ 或者黑棋连通块的「气」等于 $0$。

比如下图，绿色的位置都是黑棋连通块的「气」。

![](https://cdn.luogu.com.cn/upload/image_hosting/wzrjvpox.png)

「活棋」的定义：无论对方连续走多少手棋，在每步棋都是合法的情况下，该连通块的「气」都大于等于 $1$。

请你判断这个黑棋连通块是否是「活棋」。

如果是，输出 `YES`，否则输出 `NO`。

**本题有多测。**

## 说明/提示

**【样例解释 #1】**

第 1 组数据：

白棋依次走 $(1,1),(2,1),(3,2),(3,3),(3,4),(1,5),(2,5),(1,3)$ 即可使得黑棋连通块的「气」变成 $0$ 了。

不妨用 `@` 表示白棋，那么最终局面就是：

```plain
@*@*@
@***@
.@@@.
```

第 2 组数据：

比方说白棋先走 $(1,1)$ 那么白棋之后就再也走不到 $(1,3)$ 和 $(2,1)$ 了，导致黑棋的「气」永远大于等于 $1$，所以黑棋是「活棋」。

第 3 组数据：

最终使得黑棋连通块的「气」等于 $0$ 的局面：

```plain
@*@@.
@***@
**@**
*@.@*
**@**
*****
```

---

**【数据范围】**

**本题采用捆绑测试。**

对于 $100 \%$ 的数据，$1 \le n, m \le 2 \times {10}^3$，$1 \le T \le {10}^5$。输入的初始棋盘的每个位置要么是 `.`，要么是 `*`，并且至少有一个 `.`，至少有一个 `*`。**保证黑棋是连通的。** 保证每个测试点的 $n \times m$ 之和都小于等于 $4 \times {10}^6$。

- Subtask 1（9 points）：$n = 1$。
- Subtask 2（10 points）：$n = 2$，$m = 3$。
- Subtask 3（16 points）：保证 `.` 的个数不超过 $7$，$n, m \le 10$，$T \le 50$。
- Subtask 4（24 points）：保证 `.` 的个数不超过 $14$，$n, m \le 10$，$T \le 50$。
- Subtask 5（15 points）：$n, m \ge 3$，输入局面的边界上都是 `.`。即 $\forall (i, j)$，如果 $i = 1 \lor i = n \lor j = 1 \lor j = m$，则 $(i, j)$ 一定是空地。 
- Subtask 6（26 points）：无特殊限制。 

---
---
---

P.S. Froggy 和 uyom 都是（很久没下棋的）业余四段哥，欢迎找我们然后把我们虐一顿。

## 样例 #1

### 输入

```
3
3 5
.*.*.
.***.
.....
2 5
.*.*.
.***.
6 5
.*...
.***.
**.**
*...*
**.**
*****```

### 输出

```
NO
YES
NO```

## 样例 #2

### 输入

```
1
1 3
.*.
```

### 输出

```
YES```

# AI分析结果

### 算法分类
深度优先搜索 DFS

### 综合分析与结论
题目要求判断黑棋是否为活棋，核心思路是通过DFS或BFS遍历棋盘，标记黑棋的“气”并判断白棋是否可以合法地填满这些“气”。多个题解都采用了DFS或BFS来遍历棋盘，并通过标记和判断连通块的性质来确定黑棋的存活状态。难点在于如何高效地判断白棋的合法性，以及如何处理多个连通块的情况。

### 所选题解
1. **作者：Jairon314 (赞：16)**
   - **星级：4.5**
   - **关键亮点**：通过DFS遍历白棋的连通块，判断其是否有“气”，并通过标记黑棋的“气”来确定黑棋的存活状态。代码结构清晰，逻辑严谨。
   - **个人心得**：作者提到通过围棋中的“眼”概念来理解题目，虽然最终发现题目与围棋规则有所不同，但这一思路帮助他快速理解了题目的核心。

2. **作者：BrotherCall (赞：7)**
   - **星级：4**
   - **关键亮点**：通过DFS求连通块，并判断每个连通块是否存在“救世主”（即是否有气），思路简洁明了。
   - **个人心得**：作者从未下过围棋，但通过观察样例解释，快速理解了题目的核心逻辑，并提出了“救世主”的概念，帮助理解。

3. **作者：Miraik (赞：5)**
   - **星级：4**
   - **关键亮点**：通过DFS遍历白棋的连通块，判断其是否有“气”，并通过标记黑棋的“气”来确定黑棋的存活状态。代码实现较为简洁。
   - **个人心得**：作者提到通过围棋中的“眼”概念来理解题目，虽然最终发现题目与围棋规则有所不同，但这一思路帮助他快速理解了题目的核心。

### 核心代码片段
**作者：Jairon314**
```cpp
inline bool dfs(register int x,register int y){
    vis[x][y]=1;
    register bool flag=false;
    for(register int i=0;i^4;++i){
        register int NewX=x+dx[i];
        register int NewY=y+dy[i];
        if(map1[NewX][NewY]=='.'){
            flag=1;
        }
        if(NewX>0&&NewY>0&&NewX<=n&&NewY<=m&&!vis[NewX][NewY]&&map1[NewX][NewY]=='@'){
            flag|=dfs(NewX,NewY);
        }
    }
    return flag;
}
```
**核心思想**：通过DFS遍历白棋的连通块，判断其是否有“气”。

### 最优关键思路
通过DFS或BFS遍历棋盘，标记黑棋的“气”并判断白棋是否可以合法地填满这些“气”。关键在于如何高效地判断白棋的合法性，以及如何处理多个连通块的情况。

### 拓展思路
类似的问题可以出现在其他棋盘类游戏中，如五子棋、象棋等，通过DFS或BFS遍历棋盘，判断棋子的存活状态或合法性。

### 推荐题目
1. [P1451 求细胞数量](https://www.luogu.com.cn/problem/P1451)
2. [P1162 填涂颜色](https://www.luogu.com.cn/problem/P1162)
3. [P1443 马的遍历](https://www.luogu.com.cn/problem/P1443)

---
处理用时：25.33秒
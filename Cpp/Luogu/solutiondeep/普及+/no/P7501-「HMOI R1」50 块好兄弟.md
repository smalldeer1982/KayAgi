# 题目信息

# 「HMOI R1」50 块好兄弟

## 题目背景

Polaris_Dane 非常菜，他不仅沉迷于计数，而且喜欢玩星际争霸 2。

## 题目描述

「我的好兄弟无穷无尽，而你的虫子每时每刻都在消亡」

作为新上任爱民如子的指挥官，Polaris_Dane 充分领悟了雷诺指挥官的智慧，决定将此战术贯彻到底。

有 $N$ 个兵营，依次编号为 $1,2,3\cdots N$。现在需要把它们排列在一条数轴中位于 $[1,M]$ 间的整点处。每一个兵营都有一个生产范围 $r_i$，若兵营放在点 $x\ (1 \le x \le M)$ 处，那么它会在区间 $[x - r_i + 1, x + r_i - 1]$ 生产好兄弟。

当 $\rm type = 0$ 时，生产好兄弟的范围必须被区间 $[1,M]$ 完全包含；当 $\rm type = 1$ 时，生产好兄弟的范围可以落在 $[1,M]$ 之外，但是兵营必须放在 $[1,M]$ 内。

Polaris_Dane 不能让好兄弟们太挤了，所以任何两个兵营的生产范围 **都不能相交**，他想知道有多少种方案满足该条件。

若两个方案中存在一个编号为 $i$ 的兵营，其在两个方案中的放置位置不同，则称这两个方案不同。

由于答案可能很大，所以 Polaris_Dane 想请你输出答案对 $998244353$ 取模后的结果。

## 说明/提示

样例解释：

在样例 1 中，无论如何摆放兵营，生产范围都不会交叉，所以答案即为 $A_4^4 = 24$。

在样例 2 中，虽然生产范围可以出界，但是兵营的可选位置还是只有 $4$ 种，答案仍是 $A_4^4 = 24$。

--------

对于所有数据：
- $1 \le N, M \le 10^6$；
- $1 \le r_i \le 1000$。

-----------

**本题采用捆绑测试。**

| No. | Constraints                           | $\rm type$ | Score |
| ----------- | ------------------------------------- | ---------- | ----- |
| $1$         | $N = 2;\ M \le 1000;\ r_i = 1$          | $0$        | $10$  |
| $2$         | $N = 2;\ M \le 10^6;\ r_i = 1$          | $0$        | $10$  |
| $3$         | $N \le 40;\ M \le 10^6;\ r_i = 1$ | $0$        | $10$  |
| $4$         | No further constraints                | $0$        | $30$  |
| $5$         | $N, r_i \le 40$                 | $1$        | $20$  |
| $6$         | No further constraints                | $1$        | $20$  |

------

- Idea: Polaris_Dane
- Solution: Polaris_Dane
- Code: Polaris_Dane
- Data: Polaris_Dane

## 样例 #1

### 输入

```
4 4 0
1 1 1 1```

### 输出

```
24```

## 样例 #2

### 输入

```
4 4 1
1 1 1 1```

### 输出

```
24```

## 样例 #3

### 输入

```
3 47 1
4 8 9```

### 输出

```
10940```

## 样例 #4

### 输入

```
8 100000 1
21 37 23 13 32 22 9 39```

### 输出

```
405170260```

# AI分析结果

### 算法分类
组合数学

### 综合分析与结论
本题的核心在于如何计算兵营的排列方案数，使得它们的生产范围不相交。题解主要围绕组合数学中的排列组合展开，通过计算空位数量和兵营的排列方式来解决。难点在于如何处理 `type=1` 的情况，即生产范围可以超出 `[1, M]` 区间。各题解通过不同的思路和优化手段，如枚举边界、预处理阶乘和逆元等，来解决这一问题。

### 所选题解
#### 1. 作者：dead_X (4星)
**关键亮点**：
- 通过预处理阶乘和逆元，快速计算排列数和组合数。
- 对于 `type=1`，通过枚举边界和延长区间的方式，将问题转化为 `type=0` 的情况，从而简化计算。
- 代码结构清晰，逻辑严谨。

**核心代码**：
```cpp
int A(int n,int m) {
    if(n<m) return 0;
    return fac[n]*ifac[n-m]%p;
}

int C(int n,int m) {
    if(n<m) return 0;
    return fac[n]*ifac[n-m]%p*ifac[m]%p;
}

void solve1() {
    if(n==1) {
        printf("%lld\n",m);
        return ;
    }
    int s=0;
    fac[0]=ifac[0]=1;
    for(int i=1; i<=m; ++i) fac[i]=fac[i-1]*i%p,ifac[i]=qp(fac[i],p-2);
    for(int i=1; i<=n; ++i) s+=a[i];
    int ans=0;
    for(int i=1; i<=n; ++i) {
        for(int j=0; j<=1000; ++j) G[b[i]+j]=(G[b[i]+j]+S[j])%p;
        ++S[b[i]];
    }
    for(int i=0; i<=2000; ++i) if(G[i]) ans=(ans+G[i]*A(m+i-s+n,n)%p)%p;
    printf("%lld\n",ans*qp(C(n,n-2),p-2)%p);
    return ;
}
```

#### 2. 作者：elbissoPtImaerD (4星)
**关键亮点**：
- 通过枚举左右边界，将 `type=1` 的问题转化为 `type=0` 的问题。
- 使用预处理阶乘和逆元，优化组合数的计算。
- 代码简洁，逻辑清晰。

**核心代码**：
```cpp
int Solve_1(int m){return s>m?0:A(n+m-s,n);}

int Solve_2() {
    if(n==1) return m;
    for(int i=1;i<=n;++i) ++g[a[i]];
    for(int i=0;i<=1e3;++i) for(int j=0;j<=1e3;++j)	(f[i+j]+=i^j?g[i]*g[j]%p:g[i]*(g[j]-1)%p)%=p;
    int ans=0;
    for(int i=0;i<=2e3;++i) if(f[i]) (ans+=f[i]*Solve_1(m+i)%p)%=p;
    return ans*qpow(2*C(n,2)%p,p-2)%p;
}
```

### 最优关键思路或技巧
- **预处理阶乘和逆元**：通过预处理阶乘和逆元，可以快速计算排列数和组合数，避免重复计算，提高效率。
- **枚举边界**：对于 `type=1`，通过枚举左右边界，将问题转化为 `type=0` 的情况，从而简化计算。
- **组合数学应用**：通过组合数学中的排列组合公式，计算兵营的排列方案数，确保生产范围不相交。

### 可拓展之处
- **类似问题**：可以扩展到其他需要计算排列组合且有限制条件的问题，如区间覆盖、资源分配等。
- **优化技巧**：预处理阶乘和逆元的技巧可以应用于其他需要频繁计算组合数的问题，如动态规划、概率计算等。

### 推荐题目
1. [P3807 【模板】卢卡斯定理](https://www.luogu.com.cn/problem/P3807)
2. [P1495 【模板】中国剩余定理](https://www.luogu.com.cn/problem/P1495)
3. [P2480 [SDOI2010]古代猪文](https://www.luogu.com.cn/problem/P2480)

---
处理用时：22.48秒
# 题目信息

# 撕裂抹消

## 题目背景

何以撕裂，何以抹消？

## 题目描述

给定一个长为 $n$ 的整数序列 $a_1,a_2,\dots,a_n$，再给定一个有理数序列 $p_1,p_2,\dots,p_n$。每个位置上有一个随机系数 $c_i \in \{0,1\}$，其中 $P(c_i =  1) = p_i$，$P(c_i = 0) = 1-p_i$。

注意到随机系数写作序列后可以划分为若干个极长的连续 $0$、$1$ 段，极长指不能再向两边扩展。定义一种系数序列的权值为：当系数序列中恰有 $k$ 个极长连续 $1$ 段时为 $\sum\limits_{i=1}^n c_i a_i$，否则为 $0$。

求这个系数序列的期望权值。答案对 $998244353$ 取模。

## 说明/提示

**样例解释**

对于第一组样例，$c_i$ 必然为 $1$，且必然恰有 $1$ 个极长连续段，故权值必然为 $1 + 2 + 3 + 4 + 5 = 15$。

对于第二组样例，仅有 $c_1 = 1,c_2 = 0,c_3 = 1$ 时权值不为 $0$，且此种情况的概率为 $\frac 12 \times \frac 12 \times \frac 12 = \frac 18$，故期望为 $\frac{1+3}8 = \frac 12 \equiv 499122177 \pmod {998244353}$。

**数据范围**

对于 $30\%$ 的数据，$n \le 20$。

对于 $60\%$ 的数据，$n \le 10^3$。

对于 $100\%$ 的数据，$1 \le n \le 10^5$，$1 \le k \le \min\left(20,\left\lfloor\frac{n+1}2\right\rfloor\right)$，$0 \le a_i,p_i < 998244353$。

## 样例 #1

### 输入

```
5 1
1 2 3 4 5
1 1 1 1 1```

### 输出

```
15```

## 样例 #2

### 输入

```
3 2
1 2 3
499122177 499122177 499122177```

### 输出

```
499122177```

# AI分析结果

### 算法分类
动态规划、概率论

### 综合分析与结论
题目要求计算系数序列的期望权值，核心在于处理概率和动态规划的结合。所有题解都采用了动态规划的思路，结合概率论中的期望计算，通过维护状态转移方程来求解问题。难点在于如何正确设计状态转移方程，并处理概率的乘法和加法运算。

### 所选题解
#### 1. 作者：SkyRainWind (赞：1)
- **星级**: 4星
- **关键亮点**: 思路清晰，代码简洁，状态转移方程明确，且通过维护概率数组 `g` 来辅助计算期望值。
- **核心代码**:
```cpp
for(int i=1;i<=n;i++){
    dp[i][0][0] = 0;
    g[i][0][0] = 1ll * (1-p[i]+mod) * g[i-1][0][0] % mod;
    for(int j=1;j<=min(k, (i+1)/2);j++){
        (dp[i][j][0] += 1ll * (1-p[i]+mod) * (dp[i-1][j][1] + dp[i-1][j][0]) % mod) %= mod;
        (dp[i][j][1] += 1ll * p[i] * (dp[i-1][j-1][0] + 1ll * g[i-1][j-1][0] * a[i] % mod) % mod) %= mod;
        (dp[i][j][1] += 1ll * p[i] * (dp[i-1][j][1] + 1ll * g[i-1][j][1] * a[i] % mod) % mod) %= mod;
        (g[i][j][1] += 1ll * p[i] * (g[i-1][j][1]+g[i-1][j-1][0]) % mod) %= mod;
        (g[i][j][0] += 1ll * (1-p[i]+mod) * (g[i-1][j][1] + g[i-1][j][0]) % mod) %= mod;
    }
}
```
- **个人心得**: 通过维护概率数组 `g` 来辅助计算期望值，避免了复杂的概率运算，使得代码更加简洁。

#### 2. 作者：小杨小小杨 (赞：1)
- **星级**: 4星
- **关键亮点**: 代码实现详细，运算符重载使得概率计算更加直观，状态转移方程清晰。
- **核心代码**:
```cpp
for (i=1;i<=n;i++)
    for (k=0;k<=m;k++)
        if (k==0)
            g[i][k][0]=g[i-1][k][0]*(mo+1-p[i].x);
        else{
            if (k+k-1>i) continue;
            else if (k+k-1==i){
                g[i][k][1]=g[i-1][k-1][0]*p[i];
                dp[i][k][1]=dp[i-1][k-1][0]+a[i];
            }
            else{
                g[i][k][1]=g[i-1][k-1][0]*p[i]+g[i-1][k][1]*p[i];
                gundam=u/(g[i-1][k-1][0]+g[i-1][k][1]);
                dp[i][k][1]=a[i]+dp[i-1][k-1][0]*g[i-1][k-1][0]*gundam+dp[i-1][k][1]*g[i-1][k][1]*gundam;
                g[i][k][0]=(g[i-1][k][1]+g[i-1][k][0])*(mo+1-p[i].x);
                gundam=u/(g[i-1][k][0]+g[i-1][k][1]);
                dp[i][k][0]=dp[i-1][k][0]*g[i-1][k][0]*gundam+dp[i-1][k][1]*g[i-1][k][1]*gundam;
            }
        }
```
- **个人心得**: 通过运算符重载简化了概率运算，使得代码更加易读和易于维护。

### 最优关键思路或技巧
- **状态转移方程**: 通过维护 `dp` 和 `g` 两个数组，分别表示期望值和概率，使得状态转移更加清晰。
- **概率处理**: 通过运算符重载或直接计算，简化了概率的乘法和加法运算，避免了复杂的数学推导。

### 可拓展之处
- **类似问题**: 可以扩展到其他需要处理概率和期望的动态规划问题，如随机游走、马尔可夫链等。
- **算法套路**: 在处理概率和期望的动态规划问题时，通常需要维护两个数组，一个表示期望值，一个表示概率，通过状态转移方程进行求解。

### 推荐题目
1. [P1850 换教室](https://www.luogu.com.cn/problem/P1850)
2. [P2473 [SCOI2008]奖励关](https://www.luogu.com.cn/problem/P2473)
3. [P4548 [CTSC2006]歌唱王国](https://www.luogu.com.cn/problem/P4548)

---
处理用时：31.51秒
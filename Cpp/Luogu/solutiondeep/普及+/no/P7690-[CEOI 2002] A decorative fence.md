# 题目信息

# [CEOI 2002] A decorative fence

## 题目描述

理查德刚刚盖完他的新房子。现在房子唯一缺少的是一个可爱的小木栅栏。他不知道如何制作木栅栏，所以他决定订购一个。不知何故，他拿到了 $\texttt{ACME Fence Catalog 2002}$――可爱的小木栅栏的旗舰版资源（注：ACME 是一家什么都造的公司）。看完它的前言，他已经知道，什么使小木栅栏变得可爱。  
一个木栅栏由 $N$ 块木板组成，每块木板垂直排成一排。除此之外，当且仅当满足以下条件时，围栏看起来很可爱：  
- 木板有不同的长度，即 $1,2,\cdots,N$ 为木板长度单位。  
- 每块有两个相邻的木板，它要么比它的相邻的都大，要么比它相邻的都小。（即，这会使得围栏顶部交替上升和下降（高低起伏））。  

因此，我们可以将每个用 $N$ 块木板的可爱的栅栏唯一地描述为一个排列 $a_1,\cdots,a_N$（$\forall i$，$1 < i < N$）$(a_i - a_{i−1}) × (a_i - a_{i+1}) > 0$。反之亦然，每个这样的排列都描述了一个可爱的围栏。  
很明显，可能有许多不同的可爱木栅栏由 $N$ 块木板制成。ACME 的销售经理决定以下列方式排列可爱围栏并放入清单：栅栏 A（由排列 $a_1,\cdots,a_N$ 表示）在栅栏 B 之前（由 $b_1,\cdots,b_N$ 表示），当且仅当存在这样的 $i$，使得（$\forall j < i$）$a_j = b_j$ 和 （$a_i < b_i$）。（也就是说，比较两个围栏中哪个在清单中更早相当于取它们对应的排列，找出它们第一个不同的地方，并比较这个地方的值。）所有 $N$ 块木板的可爱围栏都被按照它们在清单中出现的顺序编号（从 $1$ 开始）。这个号码被称为他们的清单号。 
![TuLi](https://cdn.luogu.com.cn/upload/image_hosting/9kopwi5p.png)
仔细检查所有的可爱的小木栅栏后，理查德决定要它们中的一些。他记下木板的数量 $N$ 和清单号 $C$。后来，他遇到了他的朋友，他想向他们展示他围栏，但他失去了清单。他得到的唯一的事情是他的笔记。请帮助他查明，他的围栏将为何等样子。

## 说明/提示

#### 数据规模与约定  
对于 $100 \%$ 的数据，$1 \leq K \leq 100$，$1 \leq N \leq 20$。你可以认为，$20$ 块木板的可爱小木栅栏的总数适合转换为 $64$ 位有符号整数变量（C/C++ 中的 `long long`，FreePascal 中的 `int64`）。你也可以认为输入是正确的，特别是 $C$ 最小是 $1$ 并且它不超过有 $N$ 块木板的可爱围栏的数量。  
#### 题目说明  
来源于 CENTRAL-EUROPEAN OLYMPIAD IN INFORMATICS 2002 的 [A decorative fence](https://web.ics.upjs.sk/ceoi/documents/tasks/fence-tsk.pdf)。  
由 @[求学的企鹅](/user/271784) 翻译整理。

## 样例 #1

### 输入

```
2
2 1
3 3```

### 输出

```
1 2
2 3 1```

# AI分析结果

### 算法分类
动态规划

### 综合分析
题目要求构造一个高低交错的围栏，并找到字典序第 $C$ 小的排列。所有题解都采用了动态规划的思路，通过预处理方案数，再使用试填法逐步确定每一块木板的长度。难点在于如何高效地预处理方案数，并在试填过程中快速找到符合条件的木板长度。

### 所选题解
1. **作者：ListenSnow (5星)**
   - **关键亮点**：思路清晰，代码结构简洁，预处理和试填法的实现都非常高效。通过定义 $f[n][j][k]$ 表示用 $n$ 块木板组成围栏，最左边的木板排名为 $j$，状态为 $k$ 的方案数，状态转移方程明确，试填法部分逻辑清晰。
   - **核心代码**：
     ```cpp
     void init() {
         f[1][1][1] = f[1][1][0] = 1;
         for (int i = 2; i <= 20; i++)
             for (int j = 1; j <= i; j++) {
                 for (int k = 1; k < j; k++) f[i][j][1] += f[i - 1][k][0];
                 for (int k = j; k < i; k++) f[i][j][0] += f[i - 1][k][1];
             }
     }
     ```
   - **个人心得**：作者提到“试填法”的思路来源于蓝书，强调了字典序排序的特点，使得试填法的实现更加直观。

2. **作者：hutongzhou (4星)**
   - **关键亮点**：详细解释了状态转移方程的推导过程，强调了“离散化”思想，使得预处理部分更加易懂。试填法部分逻辑清晰，代码实现简洁。
   - **核心代码**：
     ```cpp
     void get_f() {
         f[1][1][0] = f[1][1][1] = 1;
         for (int i = 2; i <= 20; i++)
             for (int j = 1; j <= i; j++) {
                 for (int k = j; k <= i - 1; k++) f[i][j][0] += f[i - 1][k][1];
                 for (int k = 1; k <= j - 1; k++) f[i][j][1] += f[i - 1][k][0];
             }
     }
     ```
   - **个人心得**：作者强调了“离散化”思想的重要性，使得状态转移更加高效，避免了直接枚举真实长度的复杂度。

3. **作者：Jasonshan10 (4星)**
   - **关键亮点**：代码简洁，预处理和试填法的实现都非常高效。状态转移方程明确，试填法部分逻辑清晰。
   - **核心代码**：
     ```cpp
     void init() {
         dp[1][1][1] = dp[1][1][0] = 1;
         for (int i = 2; i <= 20; i++)
             for (int j = 1; j <= i; j++) {
                 for (int k = 1; k < j; k++) dp[i][j][1] += dp[i - 1][k][0];
                 for (int k = j; k < i; k++) dp[i][j][0] += dp[i - 1][k][1];
             }
     }
     ```
   - **个人心得**：作者提到“试填法”的思路类似于数位DP，强调了通过逐步减去方案数来确定每一位的木板长度。

### 最优关键思路
1. **动态规划预处理**：通过定义 $f[n][j][k]$ 表示用 $n$ 块木板组成围栏，最左边的木板排名为 $j$，状态为 $k$ 的方案数，状态转移方程明确，预处理复杂度为 $O(n^3)$。
2. **试填法**：通过从小到大枚举每一块木板的长度，逐步减去方案数，确定字典序第 $C$ 小的排列，复杂度为 $O(n^2)$。

### 拓展思路
类似的问题可以通过动态规划预处理方案数，再使用试填法逐步确定每一位的值。这种思路在排列组合问题中非常常见，尤其是需要按字典序排列的问题。

### 推荐题目
1. [P2467 [SDOI2010] 地精部落](https://www.luogu.com.cn/problem/P2467)
2. [P2513 [HAOI2009] 逆序对数列](https://www.luogu.com.cn/problem/P2513)
3. [P2602 [ZJOI2010] 数字计数](https://www.luogu.com.cn/problem/P2602)

---
处理用时：25.94秒
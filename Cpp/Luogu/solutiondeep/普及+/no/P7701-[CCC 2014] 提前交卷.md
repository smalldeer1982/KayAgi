# 题目信息

# [CCC 2014] 提前交卷

## 题目描述

你正在一个狭窄而又长的礼堂里考试，礼堂一共有 $n$ 排，标号从前到后分别为 $1$ 到 $n$。每排有 $6$ 个座位，左边 $3$ 个，右边 $3$ 个，中间是过道。每个座位都有一个从 A 到 F 的字母标识，其中最左的座位的标识是 A，最右的座位的标识是 F，过道在座位标识为 C 和 D 的座位之间，礼堂同时还有两个保密室，一个在最前面（第一排前面），一个在最后面（第 $n$ 排后面）。

礼堂里的每个座位一开始被刚好一个考生占用。然而，在考试过程中，$m$ 个不同的考生决定完成所有他们会做的题后依次离开礼堂。第 $i$ 个考生在座位 $r_ic_i$，其中 $c_i$ 是 A 到 F 的字母之一。当考生离开礼堂时，他们必须在任意一个保密室等待到考试结束。幸运的是，保密室能容下任意多的考生。

考生不仅关心试题本身，他们还关心怎么样可以最舒服的考试。因此，他们协作以最小化他们的不满度之和。一个考生的不满度的计算方式是 $Ax+By$，其中 $A,B$ 为常数，$x$ 为去往保密室时经过的考生人数，具体将在下面详述，$y$ 是在考生进入保密室之前保密室内的人数。注意如果一个考生不离开他的考位，那么他的不满度为 $0$。

当一个考生从一个考位走往保密室时，他在去往过道时必须先经过同排的考生，然后走过从这行到第一行或第 $n$ 行（取决于所选的保密室）的邻近过道的考生。注意走过空的座位不影响 $x$ 值。

你能帮助他们最小化他们的不满度之和吗？

## 说明/提示

其中一个最优策略是，第一个提前离开的考生去最前面的保密室，经过 $6$ 个考生（分别是 `3D`、`3C`、`2D`、`2C`、`1D`、`1C`），不满度为 $3\times6+4\times0=18$。第二个提前离开的考生也去最前面的保密室，只经过 $1$ 个考生，即 `1C`，然后他发现保密室里有 $1$ 个考生，不满度为 $7$。第三个提前离开的考生去最后面的保密室，经过 $1$ 个考生，不满度为 $3$。第四个提前离开的考生去最前面的保密室，经过 $1$ 个考生（因为座位 `1D` 是空的），不满度为 $11$。最后，第五个提前离开的考生去最后面的保密室，经过 $4$ 个考生，发现保密室里有 $1$ 个人，不满度为 $16$。所有考生总的不满度为 $55$。

对于 $60\%$ 的数据，$1\le m\le5000$；

对于 $100\%$ 的数据，$1\le n\le 10^5$，$1\le m\le6n$，$1\le A,B\le 10^9$。

## 样例 #1

### 输入

```
5 5 3 4
3E
1D
5C
1E
4A```

### 输出

```
55```

# AI分析结果

### 算法分类
树状数组、贪心

### 综合分析与结论
题目要求最小化所有提前交卷考生的不满度之和，涉及考生离开座位后经过的考生人数和保密室内的人数。核心思路是通过树状数组维护考生离开时经过的人数，并结合贪心策略选择考生去前面或后面的保密室。

### 所选题解
1. **作者：Larryyu (赞：5)**  
   - **星级**：5星  
   - **关键亮点**：详细解释了树状数组的使用和贪心策略的实现，代码清晰且优化到位。  
   - **核心思路**：通过树状数组维护考生离开时经过的人数，计算每个考生去前面或后面保密室的不满度，按差值排序后枚举最优解。  
   - **代码片段**：
     ```cpp
     for(int i=1;i<=m;i++){
         int x,y;
         read(x,y);
         if(y==1) tmp+=vis[x][2];
         if(y==6) tmp+=vis[x][5];
         if(y==3||y==4) add(x,-1);
         vis[x][y]=0;
         a[i].u+=query(x),a[i].d+=query(n)-query(x-1);
         tmp+=a[i].u;
     }
     sort(a+1,a+1+m,cmp);
     long long sum=0,ans=tmp*A+m*(m-1)/2*B;
     for(int i=1;i<=m;i++){
         sum+=a[i].u-a[i].d;
         ans=min(ans,tmp*A-sum*A+(i*(i-1)/2)*B+((m-i)*(m-i-1)/2)*B);
     }
     ```

2. **作者：wjh2011 (赞：5)**  
   - **星级**：4星  
   - **关键亮点**：思路清晰，代码简洁，树状数组的使用和贪心策略的结合得当。  
   - **核心思路**：通过树状数组维护考生离开时经过的人数，计算每个考生去前面或后面保密室的不满度，按差值排序后枚举最优解。  
   - **代码片段**：
     ```cpp
     for(int i=1;i<=m;i++){
         int tmp1 = 0, tmp2 = 0;
         if (c[i] == 'A') tmp1 = tmp2 = !ok[r[i]][1];
         if (c[i] == 'F') tmp1 = tmp2 = !ok[r[i]][4];
         ok[r[i]][c[i] - 'A'] = 1;
         if (c[i] == 'C' || c[i] == 'D') update(r[i], -1);
         tmp1 += query(1, r[i]), tmp1 *= a;
         tmp2 += query(r[i], n), tmp2 *= a;
         ans += tmp1;
         x[i] = tmp2 - tmp1;
     }
     sort(x + 1, x + m + 1);
     for(int i=1;i<=m;i++) sum[i] = sum[i - 1] + x[i];
     int minn = 1e18;
     for(int i=0;i<=m;i++) minn = min(minn, sum[i] + (i * (i - 1) / 2 + (m - i) * (m - i - 1) / 2) * b);
     ```

3. **作者：bluewindde (赞：0)**  
   - **星级**：4星  
   - **关键亮点**：思路清晰，代码简洁，树状数组的使用和贪心策略的结合得当。  
   - **核心思路**：通过树状数组维护考生离开时经过的人数，计算每个考生去前面或后面保密室的不满度，按差值排序后枚举最优解。  
   - **代码片段**：
     ```cpp
     for(int i=1;i<=m;++i){
         int base = 0;
         if (ch == 'A') base = 1 - st.count(make_pair(x, 'B'));
         if (ch == 'F') base = 1 - st.count(make_pair(x, 'E'));
         if (ch == 'C' || ch == 'D') add(x, 1);
         student[i].a = base + x * 2 - query(x);
         student[i].b = base + (n - x + 1) * 2 - (query(n) - query(x - 1));
         student[i].a *= a;
         student[i].b *= a;
         sum += student[i].b;
         st.insert(make_pair(x, ch));
     }
     sort(student + 1, student + m + 1);
     int ans = 1e18;
     for(int i=0;i<=m;++i){
         sum += student[i].a - student[i].b;
         ans = min(ans, sum + calc(i) + calc(m - i));
     }
     ```

### 最优关键思路或技巧
1. **树状数组**：用于高效维护考生离开时经过的人数，支持快速查询和更新。
2. **贪心策略**：通过计算每个考生去前面或后面保密室的差值，按差值排序后枚举最优解。

### 可拓展之处
类似的问题可以扩展到其他需要维护动态前缀和或后缀和的场景，如动态统计区间内的某些属性。

### 推荐题目
1. [P3374 【模板】树状数组 1](https://www.luogu.com.cn/problem/P3374)
2. [P3368 【模板】树状数组 2](https://www.luogu.com.cn/problem/P3368)
3. [P1908 逆序对](https://www.luogu.com.cn/problem/P1908)

### 个人心得
- **调试经历**：在实现树状数组时，需要注意更新和查询的边界条件，避免数组越界。
- **踩坑教训**：在计算差值时，要确保差值的计算顺序正确，避免逻辑错误。
- **顿悟感想**：贪心策略结合树状数组的使用，能够有效解决动态维护和优化问题。

---
处理用时：36.84秒
# 题目信息

# 天体探测仪（Astral Detector）

## 题目背景

通过远古档案馆的探索，你成功制出了天体探测仪，你需要用它发现潜藏的天体科技。


## 题目描述

想要找到天体科技，你需要先得到一串天体密码——它是一个 $1 \sim n$ 的**排列**。

天体探测仪允许对于给定的长度 $l$，返回密码中一个长度为 $l$ 的**区间的最小值**。

不幸的是，所有长度为 $l$ 的区间最小值混在了一起，你得到的只是 $n$ 个**可重集合** $S_1, \ldots , S_n$：

- $S_i$ 表示所有长度为 $i$ 的区间最小值构成的可重集合。

你需要根据这些 $S_i$，还原出一种可能的天体密码，保证至少存在一种正确的天体密码。

## 说明/提示

**【样例 1 解释】**

样例输出的天体密码为：$p = [3, 1, 2, 4]$。

长度为 $1$ 的区间最小值构成的可重集合：$S_1 = \{ 3, 1, 2, 4 \} = \{ 4, 3, 2, 1 \}$。

长度为 $2$ 的区间最小值构成的可重集合：$S_2 = \{ \min(3, 1), \min(1, 2), \min(2, 4) \} = \{ 1, 1, 2 \} = \{ 1, 2, 1 \}$。

长度为 $3$ 的区间最小值构成的可重集合：$S_3 = \{ \min(3, 1, 2), \min(1, 2, 4) \} = \{ 1, 1 \}$。

长度为 $4$ 的区间最小值构成的可重集合：$S_4 = \{ \min(3, 1, 2, 4) \} = \{ 1 \}$。

每一个 $S_i$ 都与输入对应。

其他可行答案也判为正确，如 $p = [4, 2, 1, 3]$。

---

**【数据范围】**

**本题采用捆绑测试。**

对于 $100\%$ 的数据：$2 \le n \le 800$。

| 子任务编号 | 分值 | $n \le$ | 特殊限制 |
|:-:|:-:|:-:|:-:|
| $1$ | $26$ | $6$ | 无 |
| $2$ | $24$ | $16$ | 无 |
| $3$ | $12$ | $800$ | 对于每个 $i \in [1, n]$，$S_i$ 中不存在两个相同元素 |
| $4$ | $38$ | $800$ | 无 |

## 样例 #1

### 输入

```
4
4 3 2 1
1 2 1
1 1
1
```

### 输出

```
3 1 2 4
```

# AI分析结果

### 算法分类
构造

### 综合分析与结论
本题的核心在于根据给定的区间最小值集合，构造出一个符合条件的排列。三个题解分别采用了不同的思路：

1. **xh39**的题解通过链表记录已确定的数及其位置，逐步插入新数，复杂度为O(n^2)。
2. **丛雨**的题解利用笛卡尔树的性质，通过解方程确定左右子树大小，复杂度为O(n^2)。
3. **joe20112024**的题解通过计算每个数字左右两边的距离，从小到大插入数字，复杂度为O(n^2)。

综合来看，**xh39**的题解思路清晰，代码实现较为简洁，且通过链表优化了查找和插入操作，是最优解。

### 所选题解
#### 题解作者：xh39
- **星级**: 5星
- **关键亮点**: 使用链表记录已确定的数及其位置，逐步插入新数，思路清晰，代码简洁。
- **个人心得**: 通过链表优化了查找和插入操作，避免了复杂的区间查找。

```cpp
#include<iostream>
using namespace std;
struct i_am_aking_ioi{
	int id,next;
}_[1000005]; //链表。
int mark[1005][1005]; //mark[i][j]:长度为i的区间(S[i])内出现了几次j。 
int main(){
	int n,i,j,A,ykb;
	cin>>n;
	for(i=1;i<=n;i++){
		for(j=i;j<=n;j++){
			scanf("%d"，&A);
			mark[i][A]++;
		}
	}
	_[0].next=n+1;
	_[0].id=-1;
	_[n+1].id=n; //初始化不能漏，一开始的区间是[0,n-1]，由于区间是[now.id+1,next.id-1]，所以要一开始要设为-1和n。
	for(i=1;i<=n;i++){ //依次插入1~n 
		for(j=0;j<=n;j=_[j].next){ //在每个区间内查找。  
			ykb=_[_[j].next].id-_[j].id; //区间长度
			if(!mark[ykb][i]&&mark[ykb-1][i]){
				_[i].id=_[j].id+mark[ykb+1>>1][i];//这个区间时从now.id+1开始编号的。所以需要加上_[j].id。同时+1-1抵消。
				_[i].next=_[j].next;
				_[j].next=i;
				break; //已经找到，不需要再找。因为多个可行区间任选一个。
			}
		}
	}
	for(i=_[0].next;i<=n;i=_[i].next){
		cout<<i<<" ";
	}
	return 0;
}
```

### 最优关键思路或技巧
使用链表记录已确定的数及其位置，逐步插入新数，通过链表优化了查找和插入操作，避免了复杂的区间查找。

### 可拓展之处
类似的问题可以通过链表或其他数据结构优化查找和插入操作，减少时间复杂度。

### 推荐题目
1. [P1972 [SDOI2009]HH的项链](https://www.luogu.com.cn/problem/P1972)
2. [P3369 【模板】普通平衡树](https://www.luogu.com.cn/problem/P3369)
3. [P3374 【模板】树状数组 1](https://www.luogu.com.cn/problem/P3374)

---
处理用时：21.28秒
# 题目信息

# [AHOI2007] 石块地板

## 题目描述

小可可来到了宫殿的正厅中。大厅的地面是由一块块大小一致的正方形石块组成的，这些石块分为黑、白两色，组成了一个   $m×n$ 的矩形，在其中一个石块的下面就是通往藏宝库的通道。小可可不可能一个一个石块的尝试，因为有些石块安装了机关，一碰就会触发，整个宫殿也随之倒塌。根据藏宝图记载，通道在某一特定的区域中，这个区域是一个由数个石块组成的面积不为 $0$ 的小矩形，它的四条边与大厅地面的边平行。如果对整个大厅地面任意划分矩形，那么在所有矩形中，这个区域的黑色石块数目减去白色石块数目所得的差是最大的。

小可可希望和你分工，由他来选择区域，你来计算黑、白两色石块的数目差 $S$ 。这样就能快速而准确的确认通道所在的区域。藏宝图上说这个区域中的石块都没有安装机关，只要确定了区域，就一定能找到通道。宝藏就在眼前了，加油吧！

（假设用 $1$ 表示黑色石块，用 $0$ 表示白色石块）

## 说明/提示

对于 $ 50\%$ 的数据：$1 \le m, n \leq200$。

对于 $100\%$ 的数据：$1 \le m, n \leq400$。

## 样例 #1

### 输入

```
3 4
1011
1111
1111```

### 输出

```
10```

## 样例 #2

### 输入

```
4 5
10110
01111
11110
10101```

### 输出

```
8```

# AI分析结果

### 算法分类
**前缀和**

### 综合分析与结论
该题的核心问题可以转化为求矩阵的最大子矩阵和问题。通过将白色石块标记为 -1，黑色石块标记为 1，问题转化为求矩阵中元素和最大的子矩阵。多数题解采用了前缀和结合最大子段和的思路，通过枚举子矩阵的行范围，利用前缀和快速计算每列的和，再通过最大子段和算法求解当前行的最大子矩阵和。整体时间复杂度为 O(n^3)，能够通过题目要求的数据范围。

### 所选高星题解
#### 题解1：作者：ycw123 (赞：10)
**星级：5星**
**关键亮点：**
- 详细解释了如何将问题转化为最大子矩阵和问题。
- 通过前缀和优化了子矩阵和的计算，结合最大子段和算法，思路清晰。
- 代码结构清晰，注释详细，易于理解。

**核心代码：**
```cpp
for(int i=1;i<=n;i++){
    for(int j=i;j<=n;j++){
        int b[1000]={};
        for(int k=1;k<=m;k++){
            b[k]=max(dp[k][j]-dp[k][i-1],b[k-1]+dp[k][j]-dp[k][i-1]);
            ans=max(ans,b[k]);
        }
    }
}
```
**实现思想：**
通过枚举子矩阵的起始行和结束行，利用前缀和计算每列的和，再通过最大子段和算法求解当前行的最大子矩阵和。

#### 题解2：作者：Micnation_AFO (赞：9)
**星级：4星**
**关键亮点：**
- 详细解释了如何通过前缀和将二维问题转化为一维问题。
- 代码简洁，逻辑清晰，易于理解。

**核心代码：**
```cpp
for(int i=1;i<=n;i++)
    for(int j=i;j<=n;j++){
        for(int k=1;k<=m;k++) 
            f[k] = sum[k][j] - sum[k][i-1];
        for(int k=1;k<=m;k++){
            f[k] = max(f[k], f[k] + f[k-1]);
            ans = max(ans, f[k]);
        }
    }
```
**实现思想：**
通过枚举子矩阵的起始列和结束列，利用前缀和计算每行的和，再通过最大子段和算法求解当前列的最大子矩阵和。

#### 题解3：作者：_111_ (赞：5)
**星级：4星**
**关键亮点：**
- 详细解释了如何将问题转化为最大子矩阵和问题。
- 代码结构清晰，易于理解。

**核心代码：**
```cpp
for(int i=1;i<=n;i++){
    for(int j=i;j<=n;j++){
        for(int k=1;k<=m;k++){
            b[j][k]=b[j-1][k]+a[j][k];
            if(k==1) dp[k]=b[j][k];
            dp[k]=max(dp[k-1]+b[j][k],b[j][k]);
            ans=max(ans,dp[k]);
        }
    }
}
```
**实现思想：**
通过枚举子矩阵的起始行和结束行，利用前缀和计算每列的和，再通过最大子段和算法求解当前行的最大子矩阵和。

### 最优关键思路或技巧
1. **前缀和优化**：通过前缀和快速计算子矩阵的和，将二维问题转化为一维问题。
2. **最大子段和算法**：利用最大子段和算法求解当前行或列的最大子矩阵和，进一步优化时间复杂度。

### 可拓展之处
该题的思路可以拓展到其他类似的最大子矩阵问题，如最大加权子矩阵、最大子矩阵面积等。通过前缀和和最大子段和的结合，可以有效解决这类问题。

### 推荐题目
1. [P1719 最大加权矩形](https://www.luogu.com.cn/problem/P1719)
2. [P1115 最大子段和](https://www.luogu.com.cn/problem/P1115)
3. [P2004 最大子矩阵](https://www.luogu.com.cn/problem/P2004)

### 个人心得摘录
- **调试经历**：在调试过程中，发现前缀和的计算需要特别注意边界条件，否则容易导致数组越界或计算结果错误。
- **踩坑教训**：在枚举子矩阵的行或列时，需要确保起始和结束的范围正确，否则会导致结果不准确。
- **顿悟感想**：通过将二维问题转化为一维问题，大大简化了问题的复杂度，这种思维方式在解决类似问题时非常有效。

---
处理用时：27.10秒
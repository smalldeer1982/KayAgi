# 题目信息

# 魔力滋生

## 题目背景

Source：[八仙敬酒](/paste/78f1vlm0)，这是可以点的。

- 吕洞宾——醉酒提壶力千钧；
- 铁拐李——旋肘膝撞醉还真；
- 汉钟离——跌步抱坛兜心顶；
- **蓝采和——单提敬酒拦腰破**；
- 张果老——醉酒抛杯踢连环；
- 曹国舅——仙人敬酒锁喉扣；
- 韩湘子——擒腕击胸醉吹箫；
- 何仙姑——弹腰献酒醉荡步。

## 题目描述

现有一个 $n$ 个点的树 $T$，满足任意一个结点的所连接的结点个数不超过 $2$。

现在依次对结点 $u=1\sim n$ 进行操作：

- 随机一个整数 $x(\ge k)$；
- 新建 $x$ 个结点，每个结点与 $u$ 之间连一条边。

显然操作完成后仍是一棵树 $T'$，其结点数为 $m=n+\sum x$。

已知操作后的树 $T'$ 及其结点数 $m$，请还原原树 $T$，若有多种方案，输出 **任意一组** 使得 $\color{black}n$ **最大** 的。

值得注意的是，我们进行还原和输出时，只关心树的形状，而不关心结点的相对编号。

## 说明/提示

#### 样例说明

样例 $\#1$ 中，只有结点 $1$ 可能在树 $T$ 中：它对应的 $x$ 是 $4$。

样例 $\#2$ 中，结点 $1,2,3$ 在树 $T$ 中：结点 $1$ 对应的 $x$ 是 $4$，结点 $2,3$ 对应的 $x$ 是 $0$。

样例 $\#3$ 中，结点 $1,2,3$ 在树 $T$ 中：它们随机的 $x$ 均为 $2$。

![](https://cdn.luogu.com.cn/upload/image_hosting/4mug6pzd.png)

样例 $\#3$ 给出一张示意图，图中红色结点表示树 $T$ 中的结点，图中所有结点都在树 $T'$ 上。

#### 数据范围

| Subtask | Score | $x=$ |
| :----------: | :----------: | :----------: |
| $1$ | $30$ | $0$ |
| $2$ | $30$ | $1$ |
| $3$ | $40$ |  |
| $4$ | $0$ | Hack |

说明：Subtask4 为不计分 Hack 数据，只有通过全部的 Subtask $1\sim4$ 才算 AC。

对于 $100\%$ 的数据：$1\le m\le10^5,k\in[0,m)$，数据输入保证有解。

---

### 后记

极光魔花好可爱 $\sim$

![](https://cdn.luogu.com.cn/upload/image_hosting/o0gdk38a.png)

## 样例 #1

### 输入

```
5 1
1 2
1 3
1 4
1 5```

### 输出

```
1```

## 样例 #2

### 输入

```
7 0
1 2
1 3
1 4
1 5
1 6
1 7```

### 输出

```
3
1 2
1 3```

## 样例 #3

### 输入

```
9 1
1 2
2 3
1 4
1 5
2 6
2 7
3 8
3 9```

### 输出

```
3
1 2
2 3```

# AI分析结果

### 算法分类
图论

### 题解分析与结论
题目要求从操作后的树 $T'$ 中还原原树 $T$，并使得原树的结点数 $n$ 最大。由于原树 $T$ 是一个链结构，且每个结点的度数不超过 $2$，因此可以通过树的直径或度数的性质来还原原树。

#### 题解对比
1. **言琢დ的题解**：
   - **思路**：通过树的直径来还原原树。当 $k=0$ 时，直接输出树的直径；当 $k \ne 0$ 时，去掉直径的头尾结点，剩下的链即为原树。
   - **亮点**：利用树的直径性质，简洁高效地解决了问题。
   - **评分**：5星

2. **CPPfive的题解**：
   - **思路**：当 $k=0$ 时，直接输出树的直径；当 $k \ne 0$ 时，去掉所有度数为 $1$ 的结点，剩下的即为原树。
   - **亮点**：通过度数的性质，避免了复杂的直径计算，代码实现简单。
   - **评分**：4星

3. **Lyco_Reco的题解**：
   - **思路**：当 $k=0$ 时，遍历边并删除度数为 $1$ 的结点对应的边；当 $k \ne 0$ 时，直接删除所有度数为 $1$ 的结点。
   - **亮点**：通过遍历边的方式，避免了复杂的直径计算，但代码实现较为繁琐。
   - **评分**：3星

4. **GTAyin的题解**：
   - **思路**：通过树的直径来还原原树，当 $k \ne 0$ 时，直径减去 $2$ 即为原树的结点数。
   - **亮点**：简洁明了，但未处理 $k=0$ 时的特殊情况。
   - **评分**：3星

### 最优关键思路
通过树的直径或度数的性质来还原原树，简洁高效地解决问题。

### 扩展思路
类似的问题可以通过树的性质（如直径、度数、深度等）来解决，尤其是在处理树的还原、构建或优化问题时。

### 推荐题目
1. [P1351 树的直径](https://www.luogu.com.cn/problem/P1351)
2. [P3379 【模板】最近公共祖先（LCA）](https://www.luogu.com.cn/problem/P3379)
3. [P1395 树的中心](https://www.luogu.com.cn/problem/P1395)

### 个人心得摘录
- **言琢დ**：通过树的直径性质，简洁高效地解决了问题，代码实现清晰。
- **CPPfive**：通过度数的性质，避免了复杂的直径计算，代码实现简单。

### 核心代码片段
```cpp
// 言琢დ的代码片段
inline void dfs(int u){
	dep[u]=dep[fa[u]]+1;
	for(register int i=head[u];i;i=s[i].next){
		register int v=s[i].to;
		if(v==fa[u])continue;
		fa[v]=u,dfs(v);
	}
}
```
**核心思想**：通过深度优先搜索（DFS）计算每个结点的深度，从而找到树的直径。

---
处理用时：18.30秒
# 题目信息

# [CSP-S 2021] 回文

## 题目描述

给定正整数 $n$ 和整数序列 $a_1, a_2, \ldots, a_{2 n}$，在这 $2 n$ 个数中，$1, 2, \ldots, n$ 分别各出现恰好 $2$ 次。现在进行 $2 n$ 次操作，目标是创建一个长度同样为 $2 n$ 的序列 $b_1, b_2, \ldots, b_{2 n}$，初始时 $b$ 为空序列，每次可以进行以下两种操作之一：

1. 将序列 $a$ 的开头元素加到 $b$ 的末尾，并从 $a$ 中移除。
2. 将序列 $a$ 的末尾元素加到 $b$ 的末尾，并从 $a$ 中移除。

我们的目的是让 $b$ 成为一个**回文数列**，即令其满足对所有 $1 \le i \le n$，有 $b_i = b_{2 n + 1 - i}$。请你判断该目的是否能达成，如果可以，请输出字典序最小的操作方案，具体在【**输出格式**】中说明。

## 说明/提示

**【样例解释 #1】**

在第一组数据中，生成的的 $b$ 数列是 $[4, 5, 3, 1, 2, 2, 1, 3, 5, 4]$，可以看出这是一个回文数列。

另一种可能的操作方案是 `LRRLLRRRRR`，但比答案方案的字典序要大。

**【数据范围】**

令 $\sum n$ 表示所有 $T$ 组测试数据中 $n$ 的和。

对所有测试点保证 $1 \le T \le 100$，$1 \le n, \sum n \le 5 \times {10}^5$。

| 测试点编号 | $T \le$ | $n \le$ | $\sum n \le$ | 特殊性质 |
|:-:|:-:|:-:|:-:|:-:|
| $1 \sim 7$ | $10$ | $10$ | $50$ | 无 |
| $8 \sim 10$ | $100$ | $20$ | $1000$ | 无 |
| $11 \sim 12$ | $100$ | $100$ | $1000$ | 无 |
| $13 \sim 15$ | $100$ | $1000$ | $25000$ | 无 |
| $16 \sim 17$ | $1$ | $5 \times {10}^5$ | $5 \times {10}^5$ | 无 |
| $18 \sim 20$ | $100$ | $5 \times {10}^5$ | $5 \times {10}^5$ | 有 |
| $21 \sim 25$ | $100$ | $5 \times {10}^5$ | $5 \times {10}^5$ | 无 |

特殊性质：如果我们每次删除 $a$ 中两个相邻且相等的数，存在一种方式将序列删空（例如 $a = [1, 2, 2, 1]$）。

**【hack 数据提供】**  
@[潜在了H2O下面](user/264490)。


## 样例 #1

### 输入

```
2
5
4 1 2 4 5 3 1 2 3 5
3
3 2 1 2 1 3
```

### 输出

```
LRRLLRRRRL
-1
```

## 样例 #2

### 输入

```
见附件中的 palin/palin2.in```

### 输出

```
见附件中的 palin/palin2.ans```

# AI分析结果

### 算法分类
贪心

### 综合分析与结论
该题目要求通过从序列两端取数构造回文序列，且操作序列的字典序最小。核心思路是通过贪心策略，优先选择左端操作（`L`），以确保字典序最小。难点在于如何高效地维护序列的对称性，并确保每一步操作都能保持回文性质。题解中普遍采用了双指针或双端队列来维护序列的两端，并通过贪心策略逐步构造回文序列。

### 所选高星题解

#### 1. 题解作者：I_am_Accepted
- **星级**：★★★★★
- **关键亮点**：通过双端队列模拟序列的两端，优先选择左端操作，确保字典序最小。思路清晰，代码实现简洁。
- **个人心得**：作者提到“突然变简单了……”，表明通过双端队列的模拟，问题得到了简化。

```cpp
void check(){
    int now=2;
    while(1){
        if(a.empty() && b.empty()) break;
        else if(b.empty()){
            if(a.L()!=a.R()) cur[1]='Z';
            cur[now]=cur[2*n-now+1]='L';
            a.pL(); a.pR();
        }
        else if(a.empty()){
            if(b.L()!=b.R()) cur[1]='Z';
            cur[now]=cur[2*n-now+1]='R';
            b.pL(); b.pR();
        }
        else{
            if(a.R()==a.L() && a.size()>1){
                cur[now]=cur[2*n-now+1]='L';
                a.pL(); a.pR();
            }
            else if(a.R()==b.L()){
                cur[now]='L'; cur[2*n-now+1]='R';
                b.pL(); a.pR();
            }
            else if(b.R()==a.L()){
                cur[now]='R'; cur[2*n-now+1]='L';
                a.pL(); b.pR();
            }
            else if(b.R()==b.L() && b.size()>1){
                cur[now]='R'; cur[2*n-now+1]='R';
                b.pL(); b.pR();
            }
            else cur[1]='Z';
        }
        now++;
    }
}
```

#### 2. 题解作者：tommymio
- **星级**：★★★★☆
- **关键亮点**：通过双指针维护序列的两端，优先选择左端操作，确保字典序最小。代码简洁，思路清晰。
- **个人心得**：作者提到“是名副其实的签到题”，表明通过贪心策略，问题得到了简化。

```cpp
inline bool work(int l1,int r1,int l2,int r2){
    for(register int i=1;i<n;++i){
        if(l1<=r1&&((l2<=r2&&a[l1]==a[l2])||(l1<r1&&a[l1]==a[r1]))){
            if(l1<r1&&a[l1]==a[r1]){
                ++l1; --r1;
                res[i]='L'; res[2*(n-1)-i+1]='L';
            }
            else{
                ++l1; ++l2;
                res[i]='L'; res[2*(n-1)-i+1]='R';	
            }
        }
        else if(l2<=r2&&((l1<=r1&&a[r2]==a[r1])||(l2<r2&&a[l2]==a[r2]))){
            if(l2<r2&&a[l2]==a[r2]){
                ++l2; --r2;
                res[i]='R'; res[2*(n-1)-i+1]='R';
            }
            else{
                --r2; --r1;
                res[i]='R'; res[2*(n-1)-i+1]='L';
            }
        }
        else return 0;
    }
    return 1;
}
```

#### 3. 题解作者：code_hunter
- **星级**：★★★★☆
- **关键亮点**：通过贪心策略，优先选择左端操作，确保字典序最小。思路清晰，代码实现简洁。
- **个人心得**：作者提到“时间复杂度严格线性”，表明通过贪心策略，问题得到了高效解决。

```cpp
inline bool solve(int l1,int r1,int l2,int r2){
    for(int i=1;i<n;++i){
        if(l1<=r1&&((l2<=r2&&a[l1]==a[l2])||(l1<r1&&a[l1]==a[r1]))){
            if(l1<r1&&a[l1]==a[r1]){
                ++l1; --r1;
                res[i]='L'; res[2*(n-1)-i+1]='L';
            }
            else{
                ++l1; ++l2;
                res[i]='L'; res[2*(n-1)-i+1]='R';	
            }
        }
        else if(l2<=r2&&((l1<=r1&&a[r2]==a[r1])||(l2<r2&&a[l2]==a[r2]))){
            if(l2<r2&&a[l2]==a[r2]){
                ++l2; --r2;
                res[i]='R'; res[2*(n-1)-i+1]='R';
            }
            else{
                --r2; --r1;
                res[i]='R'; res[2*(n-1)-i+1]='L';
            }
        }
        else return 0;
    }
    return 1;
}
```

### 最优关键思路或技巧
1. **双端队列或双指针**：通过双端队列或双指针维护序列的两端，确保每一步操作都能保持回文性质。
2. **贪心策略**：优先选择左端操作，确保字典序最小。
3. **模拟与验证**：通过模拟操作序列，验证每一步的合法性，确保最终构造的回文序列符合要求。

### 可拓展之处
该题的贪心策略和双端队列的维护方式可以应用于其他需要构造特定序列的题目，如构造特定排列、序列匹配等。

### 推荐题目
1. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)
2. [P1047 校门外的树](https://www.luogu.com.cn/problem/P1047)
3. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)

---
处理用时：46.31秒
# 题目信息

# [Kubic] ABC

## 题目背景

建议先看 D 题题目背景。

## 题目描述

给定一个长度为 $n$ 的只包含 $\texttt{A,B,C}$ 的字符串 $S$，你可以进行若干次操作，每次操作为：

- 先选择一个区间 $[l,r]$，你需要保证 $1\le l\le r\le n$。

- 再选择三个字符 $pA,pB,pC\in\{\texttt{A,B,C}\}$，并将 $S_{l\dots r}$ 中所有 $\texttt{A}$ 变为 $pA$，所有 $\texttt{B}$ 变为 $pB$，所有 $\texttt{C}$ 变为 $pC$，**$pA,pB,pC$ 可以相等**。

求出**最少**需要进行多少次操作才能使得 $S$ 中**任意相邻两个字符不同**，并**输出构造方案**。

## 说明/提示

对于 $100\%$ 的数据，$1\le n\le 5\times 10^3,S_i\in\{\texttt{A,B,C}\}$。

||分值|$n$|特殊性质|
|:-:|:-:|:-:|:-:|
|$\operatorname{Subtask}1$|$1$|无特殊限制|$\forall i\in[1,n),S_i\neq S_{i+1}$|
|$\operatorname{Subtask}2$|$19$|$\le 10$|无|
|$\operatorname{Subtask}3$|$10$|无特殊限制|$S_i=\texttt{A}$|
|$\operatorname{Subtask}4$|$20$|无特殊限制|$S_i\in\{\texttt{A,B}\}$|
|$\operatorname{Subtask}5$|$20$|$\le 100$|无|
|$\operatorname{Subtask}6$|$30$|无特殊限制|无|

### 评分方法

以下情况将会使你在该测试点获得 $0$ 分：

- 输出格式不满足要求。

- 输出多余信息（包括空格和换行符）

- 构造的方案操作次数与标准答案不同。

- 构造的方案不符合题目要求。

- 时间超限。

如果没有上述情况，你在该测试点获得满分。

**保证 SPJ 占用不超过 $100\operatorname{ms},10\operatorname{MB}$**。

### 样例解释 1

一种操作过程如下：

`ABBAA`

`ABABA`

可以证明没有更优的方案。

### 样例解释 2

初始序列已经符合题目要求，直接输出一行 $0$ 即可。

## 样例 #1

### 输入

```
5
ABBAA```

### 输出

```
1
3 4 BAC```

## 样例 #2

### 输入

```
5
ABCBA```

### 输出

```
0```

# AI分析结果

### 算法分类
构造

### 综合分析与结论
题目要求通过最少的操作使得字符串中任意相邻字符不同，且每次操作可以选择一个区间并替换其中的字符。题解中大部分思路都基于贪心策略，通过双指针或分组的方式找到相邻相同的字符对，并通过构造操作使得这些字符对不再相同。关键点在于每次操作最多只能改变两个相邻字符的相同状态，因此最小操作次数为相邻相同字符对数的一半（向上取整）。

### 所选题解
1. **作者：VinstaG173 (赞：16)**  
   - **星级：5**  
   - **关键亮点**：通过双指针从两端向中间扫描，找到相邻相同的字符对，并构造操作使得这些字符对不再相同。代码简洁，时间复杂度为O(n)。  
   - **核心代码**：
     ```cpp
     while(x<y)
     {
         while(x<y&&s[x]!=s[x+1])++x;
         while(y>x&&s[y]!=s[y-1])--y;
         if(x==y)break;
         l[++t]=++x,r[t]=--y;
     }
     printf("%d\n",t);
     if(l[t]>r[t])r[t]=n;
     for(int i=1;i<=t;++i)printf("%d %d BCA\n",l[i],r[i]);
     ```
   - **个人心得**：通过双指针的巧妙运用，避免了复杂的讨论，代码实现简洁高效。

2. **作者：kkio (赞：4)**  
   - **星级：4**  
   - **关键亮点**：通过枚举相邻相同的字符对，并左右配对进行修改，思路清晰，代码可读性强。  
   - **核心代码**：
     ```cpp
     while(1)
     {
         for(;l<r&&s[l]!=s[l+1];l++);
         for(;l<r&&s[r]!=s[r-1];r--);
         if(l>=r)break;
         int cl=++l,cr=((--r)<l?n:r); 
         ans.push_back(make_pair(cl,cr));
     }
     printf("%d\n",ans.size());
     for(int i=0;i<ans.size();i++)
         printf("%d %d CAB\n",ans[i].first,ans[i].second);
     ```
   - **个人心得**：通过简单的枚举和配对，实现了高效的构造方案。

3. **作者：int08 (赞：3)**  
   - **星级：4**  
   - **关键亮点**：通过贪心策略，每次操作改变两个相邻字符的相同状态，代码实现简洁，思路清晰。  
   - **核心代码**：
     ```cpp
     for(;;)
     {
         i=j+1;
         while(s[i]!=s[i+1]&&i<n-1) {i++;} //寻找l的位置
         if(i>=n-1) break; //到底了,退出循环
         j=i+1;
         while(s[j]!=s[j+1]&&j<n-1) {j++;} //寻找r的位置                         
         ans++;a[0][ans]=i+2;a[1][ans]=j+1;
     }
     cout<<ans<<endl;
     for(i=1;i<=ans;i++) cout<<a[0][i]<<" "<<a[1][i]<<" BCA\n";
     ```
   - **个人心得**：通过贪心策略，每次操作改变两个相邻字符的相同状态，代码实现简洁，思路清晰。

### 最优关键思路
通过双指针或分组的方式找到相邻相同的字符对，并通过构造操作使得这些字符对不再相同。每次操作最多只能改变两个相邻字符的相同状态，因此最小操作次数为相邻相同字符对数的一半（向上取整）。

### 可拓展之处
类似的问题可以通过贪心策略和构造操作来解决，关键在于如何高效地找到需要改变的部分，并通过最少的操作达到目标。

### 推荐题目
1. [P7919 [Kubic] ABC](https://www.luogu.com.cn/problem/P7919)
2. [P7918 [Kubic] 01串](https://www.luogu.com.cn/problem/P7918)
3. [P7917 [Kubic] 子序列](https://www.luogu.com.cn/problem/P7917)

---
处理用时：27.32秒
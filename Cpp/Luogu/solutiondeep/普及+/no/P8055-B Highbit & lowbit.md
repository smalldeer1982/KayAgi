# 题目信息

# B Highbit & lowbit

## 题目描述

定义一个正整数的 $\mathrm{highbit}$ 为该数在二进制表示下的最高二进制位的位值，如 $\mathrm{highbit}(22_{(10)})=\mathrm{highbit}(10110_{(2)})=10000_{(2)}=16_{(10)}$。

定义一个正整数的 $\mathrm{lowbit}$ 为该数在二进制表示下的最低非零二进制位的位值，如 $\mathrm{lowbit}(22_{(10)})=\mathrm{lowbit}(10110_{(2)})=10_{(2)}=2_{(10)}$。

再定义两种操作：

- 操作 $1$：将一个正整数 $x$ 变为 $x+\mathrm{lowbit}(x)$。
- 操作 $2$：将一个正整数 $x$ 变为 $x+\mathrm{highbit}(x)$。

现给定一个操作序列和 $q$ 次询问，每次询问包含 $3$ 个正整数 $l,r,x$，表示将 $x$ 从左到右依次执行 $l\sim r$ 的操作，请输出 $x$ 的值，由于答案可能很大，请输出答案对 $10^9+7$ 取模的值。

## 说明/提示

**【数据范围】**

**本题采用捆绑测试。**

对于所有测试点，满足 $1\leq n,q\leq 5\times 10^5$，$1\leq x<2^{30}$。详细数据范围如下：

- Subtask #1 (12 pts): $n,q\le 10$，$x\le 32767$。
- Subtask #2 (23 pts): $n,q\le 10^3$。
- Subtask #3 (11 pts): $n,q\leq 10^5$，字符串中仅含有 `1`。
- Subtask #4 (11 pts): $n,q\leq 10^5$，字符串中仅含有 `0`。
- Subtask #5 (6 pts): $n,q\leq 10^5$，保证每次询问的 $x$ 均可以表示为 $2^a$ 的形式，$a$ 为非负整数。
- Subtask #6 (15 pts): $n,q\leq 10^5$，保证每次询问的 $x$ 均可以表示为 $2^a+2^b$ 的形式，$a,b$ 均为非负整数。
- Subtask #7 (10 pts): $n,q\le 10^5$。
- Subtask #8 (12 pts): 没有任何附加限制。

## 样例 #1

### 输入

```
8 8
01100001
1 2 3
1 4 9
2 6 9
3 8 9
6 8 2
8 8 3
5 8 6
2 8 17```

### 输出

```
8
36
40
64
16
5
64
144```

# AI分析结果

### 算法分类
位运算、前缀和、二分

### 综合分析与结论
题目涉及对二进制数的操作，核心在于通过 `lowbit` 和 `highbit` 操作对二进制数进行变换，并通过前缀和与二分查找优化查询效率。各题解主要围绕如何高效处理操作序列和快速回答查询展开，难点在于如何将操作序列的影响转化为数学表达式，并通过预处理和二分查找加速查询。

### 所选题解

#### 1. **Suzt_ilymtics 的题解**  
**星级**: ⭐⭐⭐⭐⭐  
**关键亮点**:  
- 通过前缀和与二分查找优化查询，将问题转化为数学表达式。
- 详细分析了 `lowbit` 和 `highbit` 操作对二进制数的影响，并提出了分阶段处理的策略。
- 代码结构清晰，逻辑严谨，处理了多种边界情况。

**核心代码**:
```cpp
int p = lower_bound(b[k].begin(), b[k].end(), l) - b[k].begin();
if(b[k][p] > r) {
    int s0 = sum[0][r] - sum[0][l - 1], s1 = sum[1][r] - sum[1][l - 1];
    k = k - M - sum[0][l - 1] + sum[1][l - 1];
    if(s0 < k) {
        int ans = Pow(2, R + s1);
        x -= (1ll << R);
        while(s0--) x += lb(x);
        ans = (ans + x) % mod;
        printf("%lld\n", ans);
    } else {
        int ans = (Pow(2, R + s0 - k) + Pow(2, R + s1)) % mod;
        printf("%lld\n", ans);
    }
} else {
    p = b[k][p];
    printf("%lld\n", Pow(2, R + sum[1][p] - sum[1][l - 1] + 1 + (r - p)));
}
```

#### 2. **dingcx 的题解**  
**星级**: ⭐⭐⭐⭐  
**关键亮点**:  
- 将操作序列分为三个阶段处理，分别对应二进制数中 `1` 的个数大于等于 `3`、等于 `2` 和等于 `1` 的情况。
- 通过预处理和二分查找优化查询，代码实现较为简洁。

**核心代码**:
```cpp
int num = pos[1] - pos[2] + s0[i-1] - s1[i-1] + MAXN;
int p = lower_bound(vs[num].begin(), vs[num].end(), i) - vs[num].begin();
if(p == vs[num].size() || vs[num][p] > r)
    pos[1] += (s1[r] - s1[i-1]), pos[2] += (s0[r] - s0[i-1]), i = r+1;
else
    pos[1] += (s1[vs[num][p]] - s1[i-1] + 1), i = vs[num][p]+1, tot=1;
```

#### 3. **Elma_ 的题解**  
**星级**: ⭐⭐⭐⭐  
**关键亮点**:  
- 通过预处理和二分查找优化查询，详细分析了 `lowbit` 和 `highbit` 操作对二进制数的影响。
- 代码实现较为简洁，逻辑清晰。

**核心代码**:
```cpp
int pos = S[p] + a - b + N, q = 0;
if (buc[pos].size()) {    
    L = 0, R = buc[pos].size() - 1;
    while (L <= R) {
        int mid = (L + R) >> 1;
        if (buc[pos][mid] >= p) R = mid - 1, q = buc[pos][mid];
        else L = mid + 1;           
    }
}
```

### 最优关键思路或技巧
- **前缀和与二分查找**: 通过预处理操作序列的前缀和，利用二分查找快速定位满足条件的操作位置，极大优化了查询效率。
- **分阶段处理**: 根据二进制数中 `1` 的个数不同，将操作序列分为多个阶段处理，简化了问题复杂度。
- **位运算优化**: 通过位运算快速计算 `lowbit` 和 `highbit`，提高了代码执行效率。

### 可拓展之处
- 类似的问题可以通过前缀和与二分查找优化查询效率，特别是在处理大规模操作序列时。
- 位运算在处理二进制数相关问题时具有高效性，可以广泛应用于其他类似题目。

### 推荐题目
1. [P3374 【模板】树状数组 1](https://www.luogu.com.cn/problem/P3374)
2. [P1908 逆序对](https://www.luogu.com.cn/problem/P1908)
3. [P3384 【模板】树链剖分](https://www.luogu.com.cn/problem/P3384)

### 个人心得摘录
- **Suzt_ilymtics**: "发现其中有两项是常量，设 `p = k+1 + sum_{0,l-1} - sum_{1,l-1}`。式子变为：`sum_{0,x} - sum_{1,x} = p`。我们可以用值域 `vector` 存下每个 `p` 出现的位置，然后每次询问直接 `lower_bound` 一下找到第一个满足条件的 `x`。"
- **dingcx**: "考虑两个操作，`+lowbit` 会让两个 `1` 距离减少 `1`，`+highbit` 会让距离增加 `1`。转换一下问题，把操作序列中 `+lowbit` 操作看作 `-1`，`+highbit` 操作看作 `+1`，求从操作序列当前位置开始，最小的位置 `j` 使得 `a_i+...+a_j=-k`。"
- **Elma_**: "一个简单的事实：若 `x` 是 `2` 的若干次幂，那么 `highbit(x) = lowbit(x) = x`。另一个简单的事实：操作 `2` 只可能影响二进制下的一个为 `1` 的位置，而操作 `1` 可能会将多个为 `1` 的位置合并。"

---
处理用时：34.65秒
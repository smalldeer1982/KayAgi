# 题目信息

# 『JROI-4』Sunset

## 题目背景

写不出优美的文字，索性不放背景了。【背景待填充】

> 由于这只是个 C，出题人打算良心点，于是加了几个 $0$（指交互次数）（确信）——验题人注。

## 题目描述

**这是一道交互题。**

落日可以抽象成一个序列 $\{a_n\}$.

$\{a_n\}$ 是一个 $1\sim n$ 的排列。

你还有一个数列 $\{d_n\}$，为**当前** $a$ 数列的前缀最大值。

换言之，
$$d_i=\max_{j=1}^i \{a_j\}$$

注意：根据前文的定义，$\{d_n\}$ 可能随着 $\{a_n\}$ 数列的改变而改变。

您可以进行两种不同的操作：

- 指定一个 $i$，询问对于当前的 $a$ 数列， $d_{1\sim i}$ 中有几个不同的值。
- 指定一个 $i$，使得 $a_i\leftarrow 0$.

请使用不超过 $5500$ 次操作求出**原排列**。

**保证交互库是静态的，即交互库不会在交互过程中改变 $a$ 数列。**

## 说明/提示

**样例仅供理解交互过程，可能不符合逻辑。**

【样例解释】

初始的序列 $a$ 为 `1 2 3`，$d$ 为 `1 2 3`.

在对交互库输出了形如 `? 2 2` 的命令后，序列 $a$ 变为 `1 0 3`，$d$ 变为 `1 1 3`，此时 $d_1\sim d_3$ 中有 $2$ 种不同的值，分别是 $1,3$.



------------


可供选手参考的资料：[OI Wiki-交互题](https://oi-wiki.org/contest/interaction/) **|** [猜数（IO交互版）
](https://www.luogu.com.cn/problem/P1733)



------------

## 数据范围
- 对于 $10\%$ 的数据，$T=1$；
- 对于 $30\%$ 的数据，$n\le 70$；
- 对于另外 $20\%$ 的数据，保证数列 $a$ 随机生成；
- 对于全部数据：$T \leq 10,1\leq n\leq 500$。

## 样例 #1

### 输入

```
1

3

1

2

3


2

```

### 输出

```



? 1 1

? 1 2

? 1 3

? 2 2
? 1 3

! 1 2 3```

# AI分析结果

### 算法分类
二分

### 综合分析与结论
题目要求通过交互操作还原一个排列，核心思路是利用二分查找来确定当前最大值的位置。通过询问前缀最大值的变化情况，结合二分查找的单调性，逐步确定每个元素的位置。该问题的难点在于如何高效地利用交互操作次数，确保在5500次操作内完成所有查询和修改。

### 所选高星题解

#### 题解1：作者：D2T1 (赞：8)
**星级：5星**
**关键亮点：**
- 详细解释了二分查找的原理及其在本题中的应用。
- 通过记忆化减少查询次数，优化了算法效率。
- 代码结构清晰，逻辑严谨，易于理解。

**核心代码：**
```cpp
int getmx(int l, int r){
    if(l == r) return l;
    int mid = l + r >> 1;
    int t = ra, tt = ask(mid);
    if(t == tt){
        ra = tt;
        return getmx(l, mid);
    } else {
        ra = t;
        return getmx(mid+1, r);
    }
}
```
**实现思想：**
通过递归二分查找当前最大值的位置，利用记忆化减少重复查询。

#### 题解2：作者：TheSky233 (赞：5)
**星级：4星**
**关键亮点：**
- 提供了清晰的解题思路，详细说明了如何通过二分查找确定最大值的位置。
- 代码实现简洁，注释详细，便于理解。

**核心代码：**
```cpp
int ask(int o){
    int xx;
    cout<<"? 1 "<<o<<'\n';
    fflush(stdout);
    cin>>xx;
    return xx;
}
```
**实现思想：**
通过二分查找确定最大值的位置，逐步将最大值清零，重复操作直到所有元素确定。

#### 题解3：作者：lnwhl (赞：0)
**星级：4星**
**关键亮点：**
- 详细解释了如何利用二分查找和单调性确定最大值的位置。
- 代码实现简洁，逻辑清晰。

**核心代码：**
```cpp
int l=1,r=n,mid,now,last;
cout<<"? 1 "<<n<<endl;
fflush(stdout);
cin>>last;
while(l<r){
    mid=l+r>>1;
    cout<<"? 1 "<<mid<<endl;
    fflush(stdout);
    cin>>now;
    if(now==last)r=mid;
    else l=mid+1;
}
```
**实现思想：**
通过二分查找确定最大值的位置，逐步将最大值清零，重复操作直到所有元素确定。

### 最优关键思路或技巧
- **二分查找**：利用前缀最大值的单调性，通过二分查找高效确定最大值的位置。
- **记忆化**：通过记忆化减少重复查询，优化算法效率。
- **交互操作**：合理利用交互操作次数，确保在限制内完成所有查询和修改。

### 可拓展之处
- 类似问题可以扩展到其他需要高效查找最大值或最小值的场景，如动态维护序列的最大值。
- 可以结合其他数据结构如线段树或树状数组，进一步优化查询效率。

### 推荐题目
1. [P1733 猜数（IO交互版）](https://www.luogu.com.cn/problem/P1733)
2. [P1972 [SDOI2009]HH的项链](https://www.luogu.com.cn/problem/P1972)
3. [P3368 【模板】树状数组 2](https://www.luogu.com.cn/problem/P3368)

### 个人心得摘录
- **调试经历**：在实现二分查找时，注意边界条件的处理，避免死循环或越界。
- **踩坑教训**：交互题中，每次输出后需要刷新缓存，否则可能导致交互失败。
- **顿悟感想**：通过二分查找和单调性的结合，可以高效解决类似的最大值查找问题。

---
处理用时：25.23秒
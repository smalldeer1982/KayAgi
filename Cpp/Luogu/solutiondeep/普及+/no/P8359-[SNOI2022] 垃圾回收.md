# 题目信息

# [SNOI2022] 垃圾回收

## 题目描述

通常的情况下，编程语言在管理内存时进行如下的选择：

- 让用户进行手动内存管理（C、C++、Rust 等），这会收获很好的性能，但是给用户提供了很大的编程负担。
- 使用垃圾回收系统（Java、Go 等），这需要维护一个运行时系统，并且在内存使用和程序性能方面造成了许多不可预测的负担。

尽管存在许多的问题，目前最通用的自动化内存管理手段始终为 Tracing Garbage Collector。这种做法的最基础的思路是维护对象间的引用关系，形成一张图，每次回收时通过扫描引用关系推导出已经无法被访问到的对象，释放它们占用的内存。而这种传统的做法最大的问题在于维护引用链需要造成很大的开销，并且随着维护的对象越多，扫描的代价也会越大。

小 L 是一个喜欢思考的女孩子，她发现维护 Garbage Collector 是一件非常复杂的事情，于是她决定考虑一个更简单的模型（注意它与任何现实中的 GC 规则可能是完全不同的！）。


对于一个 $n$ 个点 $m$ 条边的无向图，没有重边自环，点和边均从 $1$ 开始标号。其中每个节点代表一个占用了一定内存的对象，每条边对应一个引用关系（注意这里的引用关系是**无向**的），程序从第 $0$ 秒开始运行，在第 $q + 1$ 秒结束运行。对于 $i = 1, 2, 3, \dots, q$ 的每个时刻 $i$ 发生以下两种操作之一：

- DELETE $i$，删除边 $(x_i,y_i)$，保证不会删除已经被删除的边。
- GC， 进行一次内存回收，即杀死所有从起点出发不能访问到的点，释放它们占用的内存。（注意这里对节点的删除不会删除与这些点相连的边）

你可以认为这些操作是被瞬间执行完成的，在所有操作执行后，也就是第 $q + 1$ 秒，程序结束，删除所有剩余的节点（包括 $1$ 号点）。

第 $i$ 个点占用的内存为 $a_i$，现在请你求出 $\sum_{i = 1}^{n} a_i \cdot \mathit{alive}_i$，这里 $\mathit{alive}_i$ 表示第 $i$ 个点存活的时间，在第 $0$ 秒，所有节点都是存活的。

## 说明/提示

**【样例 1 解释】**

在第 $4$ 秒时，节点 $5$ 被删除。

在第 $6$ 秒时，节点 $2, 3$ 被删除。

在第 $9$ 秒时，节点 $1, 4, 6$ 被删除。

答案即 $5 \times 4 + (2 + 3) \times 6 + (1 + 4 + 6) \times 9 = 20 + 30 + 99 = 149$。

**【数据规模与约定】**

对于全部数据，$1 \leq n, m, q \leq 4 \times 10^5$，$1 \leq a_i \leq 10^8$。

具体的数据规模与约定见下表。

| 测试点编号 | $n$ | $m$ | $q$ | 特殊限制 |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $1 \sim 2$ | $\leq 500$ | $\leq 500$ | $\leq 500$ |   |
| $3 \sim 5$ | $\leq 3000$ | $\leq 3000$ | $\leq 3000$ |  |
| $6 \sim 10$ | $\leq 5000$ | $\leq 5000$ | $\leq 5000$ |  |
| $11 \sim 14$ | $\leq 2 \times 10^5$ | $n-1$ | $\leq 2 \times 10^5$ | 保证一开始图是一棵树 |
| $15 \sim 16$ | $\leq 2 \times 10^5$ | $\leq 2 \times 10^5$ | $\leq 2 \times 10^5$ |  |
| $17 \sim 20$ | $\leq 4 \times 10^5$ | $\leq 4 \times 10^5$ | $\leq 4 \times 10^5$ |  |

## 样例 #1

### 输入

```
6 6 8
1 2
2 3
2 4
1 4
2 5
1 6
GC
DELETE 5
DELETE 3
GC
DELETE 1
GC
DELETE 2
GC
1 2 3 4 5 6
```

### 输出

```
149
```

## 样例 #2

### 输入

```
样例 2 见附件 garbage2.in
本组数据满足测试点 6 的限制。```

### 输出

```
样例 2 见附件 garbage2.ans```

## 样例 #3

### 输入

```
样例 3 见附件 garbage3.in
本组数据满足测试点 11 的限制。```

### 输出

```
样例 3 见附件 garbage3.ans```

# AI分析结果

### 算法分类
并查集

### 综合分析与结论
该题的核心在于通过并查集维护图的连通性，并通过倒序处理操作（将删边转化为加边）来优化计算每个节点的存活时间。难点在于如何高效地处理GC操作和删除操作，并确保每个节点的存活时间计算准确。大多数题解采用了并查集数据结构，并结合启发式合并或暴力DFS来维护连通块信息。倒序处理操作是解决该问题的关键思路，能够有效减少时间复杂度。

### 所选高星题解

#### 题解1：作者：LXYYDS (赞：12)
**星级：5星**
**关键亮点：**
- 采用并查集维护连通性，倒序处理操作，将删边转化为加边。
- 通过记录每个连通块的权值和，优化了GC操作的处理。
- 详细解释了如何处理初始不连通的节点，并提供了完整的代码实现。

**核心代码：**
```cpp
for (register long long i = q; i >= 1; i --) {
    if (S[i] == "GC") {
        tim = i;
    }
    else {
        long long x = get_father(e[dele[i]].x), y = get_father(e[dele[i]].y);
        if (x == y)
            continue;
        if (x == 1) {
            siz[x] += siz[y];
            ans += tim * siz[y];
            father[y] = x;
        }
        else if (y == 1) {
            siz[y] += siz[x];
            ans += tim * siz[x];
            father[x] = y;
        }
        else {
            siz[y] += siz[x];
            father[x] = y;
        }
    }
}
```
**核心思想：** 倒序处理操作，通过并查集维护连通性，并在合并时计算每个连通块的贡献。

#### 题解2：作者：Troubadour (赞：5)
**星级：4星**
**关键亮点：**
- 详细解释了倒序处理操作的思路，并强调了如何处理初始不连通的节点。
- 提供了对数据范围的敏感处理，如使用`unsigned long long`避免溢出。

**核心代码：**
```cpp
for (int i = lst; i > 0;) {
    std::vector<int>g;
    g.clear();
    if (ask[i].opt == 1) {
        int ls = i;
        i--;
        while (ask[i].opt == 2 && i != 0) {
            g.push_back(ask[i].k);
            i--;
        }
        for (int a : g) {
            int fx = find(e[a].u), fy = find(e[a].v);
            if (fx != fy) {
                val[fx] += val[fy];
                fa[fy] = fx;
            }
        }
        ans += (ls - i) * val[find(1)];
    }
}
```
**核心思想：** 通过倒序处理操作，维护连通性，并在每次GC操作时计算贡献。

#### 题解3：作者：王熙文 (赞：4)
**星级：4星**
**关键亮点：**
- 通过DFS暴力删除不连通的节点，结合并查集维护连通性。
- 详细解释了如何处理初始不连通的节点，并提供了完整的代码实现。

**核心代码：**
```cpp
void dfs(int now) {
    if (!last) return;
    tim[now] = last;
    for (int i = head[now]; i; i = s[i].nex) {
        int y = s[i].y;
        if (!tim[y])
            dfs(y);
    }
}
```
**核心思想：** 通过DFS暴力删除不连通的节点，并结合并查集维护连通性。

### 最优关键思路或技巧
- **倒序处理操作**：将删边转化为加边，简化了连通性的维护。
- **并查集优化**：通过并查集维护连通性，并结合启发式合并或暴力DFS来处理连通块信息。
- **初始不连通节点的处理**：通过提前处理初始不连通的节点，确保所有节点的存活时间计算准确。

### 可拓展之处
- **类似问题**：处理动态图连通性问题时，倒序处理操作是一种常见的优化手段，适用于需要频繁删边或加边的场景。
- **数据结构优化**：在处理大规模数据时，可以考虑使用更高效的数据结构（如按秩合并的并查集）来进一步优化时间复杂度。

### 推荐题目
1. [P3367 【模板】并查集](https://www.luogu.com.cn/problem/P3367)
2. [P1197 [JSOI2008]星球大战](https://www.luogu.com.cn/problem/P1197)
3. [P1551 亲戚](https://www.luogu.com.cn/problem/P1551)

---
处理用时：27.29秒
# 题目信息

# [LSOT-1] 逆序对

## 题目背景

逆序对真好玩

## 题目描述

你需要维护一个数列，支持以下 $4$ 种操作：

1. 区间交换；
2. 把一个区间**向后**移动到第 $k$ 个数字与第 $k+1$ 个数字之间；
3. 在最后插入一个数 $x$；
4. 在开头插入一个数 $x$。

每个数数的序号为新序列重新从第一个数到第 $k$ 个数编号为 $1$ 到 $k$。

现在每次操作过后，请你输出整个数列逆序对数量的奇偶性。

## 说明/提示

【样例解释】

第一次操作将区间 $[1,1]$ 和区间 $[2,2]$ 交换，序列变为 `3 4 5 7 2 6`。

第二次操作将区间 $[1,1]$ 移动到第 $3$ 和第 $4$ 个数中间。序列变为 `4 5 3 7 2 6`。

第三次操作在序列末端插入 $11$，序列变为 `4 5 3 7 2 6 11`。

第四次操作在序列开头插入 $1$，序列变为 `1 4 5 3 7 2 6 11`。

【数据范围】

**「本题采用捆绑测试」**

- $\texttt{Subtask 1(10 pts): }n,m\le 10^2$；
- $\texttt{Subtask 2(15 pts): }n,m\le 10^3$；
- $\texttt{Subtask 3(20 pts): }$没有一二操作；
- $\texttt{Subtask 4(20 pts): }$没有三四操作；
- $\texttt{Subtask 5(35 pts): }$无特殊限制。

对于 $100\%$ 的数据，$1\le n,m \le 2\times 10^5,a_i\le 2\times10^6$，保证在任意时刻 $a$ 中的数均互不相同。

## 样例 #1

### 输入

```
6 4
4 3 5 7 2 6
1 1 1 2 2
2 1 1 3
3 11
4 1```

### 输出

```
odd
odd
odd
odd```

# AI分析结果

### 算法分类
树状数组、数学

### 综合分析与结论
本题的核心在于维护逆序对数量的奇偶性，而不是具体的逆序对数量。通过分析发现，交换任意两个数会改变逆序对数量的奇偶性。因此，操作1和操作2可以通过计算交换次数来更新奇偶性，而操作3和操作4可以通过树状数组快速计算插入数对逆序对数量的影响。整体思路是利用数学性质简化问题，结合树状数组高效维护逆序对奇偶性。

### 所选高星题解
1. **作者：Na2PtCl6 (4星)**
   - **关键亮点**：通过严格的数学推导，证明了交换两个数会改变逆序对奇偶性，并给出了操作1和操作2的奇偶性变化公式。代码简洁，使用树状数组维护逆序对奇偶性。
   - **代码核心**：
     ```cpp
     void add(int p,int v){
         while(p<=maxn-2){
             tr[p]+=v;
             p+=p&-p;
         }
     }
     int sum(int p){
         int ret=0;
         while(p){
             ret+=tr[p];
             p-=p&-p;
         }
         return ret;
     }
     ```
   - **个人心得**：通过观察交换两个数对逆序对奇偶性的影响，简化了问题，避免了复杂的逆序对计算。

2. **作者：Purslane (4星)**
   - **关键亮点**：将操作2转化为操作1，简化了问题。通过整体法分析操作1对逆序对奇偶性的影响，使用树状数组维护插入操作。
   - **代码核心**：
     ```cpp
     void update(int pos,int val) {
         while(pos<=2000000) tr[pos]+=val,pos+=lowbit(pos);
     }
     int Query(int pos) {
         int ans=0;while(pos) ans+=tr[pos],pos-=lowbit(pos);return ans;
     }
     ```
   - **个人心得**：通过整体法分析区间交换对逆序对奇偶性的影响，避免了逐个计算逆序对。

3. **作者：Dr_Gilbert (4星)**
   - **关键亮点**：通过观察交换两个数对逆序对奇偶性的影响，简化了操作1和操作2的处理。使用树状数组维护插入操作，代码简洁高效。
   - **代码核心**：
     ```cpp
     void update(int x, int dlt){
         for (;x<=maxx;x+=lowbit(x)) bit[x]+=dlt;
     }
     int query(int x){
         int ret=0;
         for (;x;x-=lowbit(x)) ret+=bit[x];
         return ret;
     }
     ```
   - **个人心得**：通过观察交换两个数对逆序对奇偶性的影响，简化了问题，避免了复杂的逆序对计算。

### 最优关键思路或技巧
1. **数学性质**：交换任意两个数会改变逆序对数量的奇偶性，利用这一性质可以简化操作1和操作2的处理。
2. **树状数组**：使用树状数组高效维护插入操作对逆序对数量的影响，快速计算插入数的逆序对贡献。

### 可拓展之处
类似的问题可以通过分析操作对逆序对奇偶性的影响来简化计算，尤其是在只需要奇偶性结果的情况下。树状数组在处理动态逆序对问题时非常高效，可以推广到其他需要维护动态序列的问题。

### 推荐题目
1. [P1908 逆序对](https://www.luogu.com.cn/problem/P1908)
2. [P1966 火柴排队](https://www.luogu.com.cn/problem/P1966)
3. [P3157 [CQOI2011]动态逆序对](https://www.luogu.com.cn/problem/P3157)

---
处理用时：24.42秒
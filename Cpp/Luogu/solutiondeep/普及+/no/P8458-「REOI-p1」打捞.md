# 题目信息

# 「REOI-p1」打捞

## 题目背景

![](https://cdn.luogu.com.cn/upload/image_hosting/0ukve6wl.png)

出题人：XL4453

验题人：犇犇犇犇

文案：小糯米

upd：注意，先取模再取max

## 题目描述

“别介意，我和那些家伙都是打捞者。我们在头一次追寻梦想降落到地表时，就做好丧命的准备和赴死的觉悟了。”

葛力克一行人在一次打捞中，时来运转，获得了不少的宝藏。在归途之路，言及谁的功劳最大之时，大家却起了冲突。有人说自己的宝藏是史上绝无仅有，是在鬼门关前绕了一大圈才好不容易抢到的一个；有人说自己惨淡经营，虽然没有获得那么珍贵的宝物，但数量可观，也足以与之相提并论；也有人说自己的收获二者兼有，应当综合评价云云：总之，场面一片混乱，颇有生死与共的患难之交从此决裂的危险。

于是，大家把目光投到了葛力克的身上，这让他十分为难。思索良久，他决定这样来评价大家的贡献： 

假设一共有 $n$ 名打捞者，第 $i$ 位打捞者 $a_i$ 取得的宝物数量为 $l_i$ ，而其中第 $p$ 件宝物对应的价值则为 $a_{i,p}$ ，那么在计算的时候只需要将每个序列相加求和即可。但是葛力克并不满足于现状，他现在想知道，如果是将两个人的贡献放在一起看待，那么又将如何计算呢？
一番激烈的头脑风暴后，他决定这样来计算两位打捞者 $i,j$ 之间的贡献 $g(i,j)$ ：将 $a_i$ 与$a_j$ 分别复制数遍使得两堆宝物的数量都为 $k$ ，得到两个序列 $a_i',a_j'$ ，则 $g(i,j)= \sum\limits_{p=1}^k a'_{i,p}\times a'_{j,p}$ 。

现在葛力克想知道，这个贡献值的最大值是多少。

因为贡献值可能会很大，超出了正常生物大脑的运算能力，所以我们对它进行 $998244353$ 的取余。

----------
形式化题面：给定一个整数 $n$，和 $n$ 个序列，第 $i$ 个序列 $\{a_i\}$ 长度为 $l_i$，将每个 $a_i$ 复制 $\dfrac k{l_i}$ 遍得到 $\{a'_i\}$ 使得 $\{a'_i\}$ 的长度为 $k$。

试求：$\max\limits_{i=1,j=i+1}^{i,j\leq n}\{g(i,j)\bmod 998244353\}$，其中$g(i,j)= \sum\limits_{p=1}^k a'_{i,p}\times a'_{j,p}$ 。

## 说明/提示

#### 样例解释 $#1$

$a_1'=2, 3, 4, 2, 3, 4, 2, 3, 4, 2, 3, 4$。  
$a_2'=1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4$。  
$g(1,2)=2\times1+3\times2+4\times3+2\times4+3\times1+4\times2+2\times3+3\times4+4\times1+2\times2+3\times3+4\times4=90$。

#### 样例解释 $#2$

$g(1,2)\bmod998244353=599517664$。  
$g(1,3)\bmod998244353=350889018$。  
$g(2,3)\bmod998244353=66930325$。  
$\max\limits_{1\leq i < j \leq n}\{g(i,j)\bmod998244353\}=599517664$。  

#### 数据范围

对于 $10\%$ 的数据，有 $n=2$。  
对于 $30\%$ 的数据，有 $k \leq 100$。  
对于 $60\%$ 的数据，所有 $l_i$ 两两互质，即 $\gcd(l_i,l_j)=1(1\leq i < j \leq n)$，$\gcd$ 为[最大公约数](https://oi-wiki.org/math/number-theory/gcd/)。  
对于 $100\%$ 的数据，有 $1\leq n\le 100，1\leq l_i\le 1000，1\leq k,a_{i,j}\le 10^{9}$ 且对于任意的 $i \in [1,n],l_i\mid k$。


## 样例 #1

### 输入

```
2 12
3 2 3 4
4 1 2 3 4```

### 输出

```
90```

## 样例 #2

### 输入

```
3 999999924
4 4 4 5 3
7 1 9 1 9 8 1 0
6 1 1 4 5 1 4```

### 输出

```
599517664```

# AI分析结果

### 算法分类
数学

### 综合分析与结论
题目要求计算两个序列在扩展后的交叉积的最大值，且需要对结果取模。核心难点在于如何处理序列的周期性以及如何高效计算交叉积。题解中主要利用了数学中的周期性分析和最大公约数（GCD）的性质来优化计算。

### 所选题解
#### 题解1：作者：qpdk777 (赞：17)
- **星级**：5星
- **关键亮点**：利用周期性分析，通过GCD和LCM优化计算，代码清晰且高效。
- **个人心得**：通过分析60%的数据，推广到不互质的情况，并给出了严谨的数学证明。

#### 题解2：作者：bianshiyang (赞：0)
- **星级**：4星
- **关键亮点**：详细分析了互质和不互质的情况，给出了数学证明，代码实现较为简洁。
- **个人心得**：通过找规律和数学推导，优化了计算过程。

#### 题解3：作者：JWRuixi (赞：0)
- **星级**：4星
- **关键亮点**：引入了模意义下的结论，简化了计算过程，代码实现简洁。
- **个人心得**：通过引入数学结论，简化了问题的复杂度。

### 关键思路或技巧
1. **周期性分析**：利用序列的周期性，将问题转化为最小正周期内的计算。
2. **GCD和LCM**：通过GCD和LCM的性质，优化计算过程，减少重复计算。
3. **模运算**：在计算过程中及时取模，避免数值溢出。

### 核心代码片段
```cpp
long long work(int x, int y){
    int gc = gcd(l[x], l[y]);
    int lc = lcm(l[x], l[y]);
    long long ans = 0;
    
    for(int i = 1; i <= gc; i++){
        long long tmp = 0;
        for(int j = i; j <= l[y]; j+=gc){
            tmp += c2[j];
            tmp %= M;
        }
        s[i] = tmp;
    }

    for(int i = 1; i <= l[x]; i++){ 
        int h = i % gc;
        if(h == 0) h = gc;
        ans += 1ll * c1[i] * s[h] % M;
        ans %= M;
    }
    ans *= k / lc;
    ans %= M;

    return ans;
}
```

### 拓展思路
类似的问题可以通过分析序列的周期性和利用数学性质来优化计算。例如，处理序列的重复模式、利用GCD和LCM的性质等。

### 推荐题目
1. [P3811 【模板】乘法逆元](https://www.luogu.com.cn/problem/P3811)
2. [P1495 【模板】中国剩余定理](https://www.luogu.com.cn/problem/P1495)
3. [P1072 Hankson 的趣味题](https://www.luogu.com.cn/problem/P1072)

这些题目涉及模运算、GCD和LCM等数学知识，与本题的解题思路相似。

---
处理用时：18.46秒
# 题目信息

# 「REOI-1」深潜的第六兽

## 题目背景

“〈十七兽〉全都不会飞。因此，在它们毁灭大地以后，悬浮大陆群还能像这样浮在天空。

“可是，只有〈深潜的第六兽〉在本身留在大地的同时，还能对悬浮大陆群发动攻击。它有两种能力，『分裂增生』和『快速茁壮』。

“留在地表的本体会让身体分裂出几万个碎块，然后随风飞扬，等待碰巧飘流到某座悬浮岛。抵达岛上以后，它会当场发育茁壮，大约六到八小时过后就能占据并毁灭整座岛。”

## 题目描述

现在有一只〈第六兽〉，在某一次的「分裂增生」时分裂出了 $n$ 个碎块，这些碎块会笔直向上飞去，如果其中一块碎块遇到了一座浮空岛（为了研究方便，我们不妨将它当成一条二维空间中的线段处理），便会迅速占据它，并一分为二，再次从浮空岛的两端笔直向上飞去。

不过好在，那些只是一些无关紧要最为荒凉毫无人烟的岛屿，但如果就这样放任它们继续肆虐，势必会给那些至关重要的浮空岛带来毁灭性的打击。于是乎，负责清理〈第六兽〉的军官们，决定以他们所在的岛屿为直线建立 $x$ 轴，并以重力的方向为正方向建立 $y$ 轴，他们总共监测到了 $m$ 座浮空岛，并确定了那些碎块分裂出的位置（距离 $x$ 轴的位置视作无限远），于是他们想知道，如果放任这些碎块，那么当它们到达军官的位置时，最终会有多少碎块。

注意，若一座浮空岛的 $ l_i $ 与 $ r_i $ 相同，即为一个点， 〈第六兽〉占据后仍然会分裂成两只，从这个点向上飞去。

**提示：浮空岛作为实体显然不会重叠。**

**简要题意：**

在一个平面直角坐标系上有 $m$ 条平行于 x 轴的线段，第 $i$ 条线段为 $(l_i,h_i)$ 与 $(r_i,h_i)$ 的连线。特别注意 $l_i$ 可与 $r_i$ 相等，此时线段变为一个点。

在直线 $y=10^9$ 上有 $n$ 个点，分别位于 $(x_i,10^9)$。

现在，这些点逐渐向下（y轴负方向）移动。若触碰到线段，则会一分为二，分裂出的两个点分别从线段的两端继续向下移动。

特别地，若线段为一个点，则会原地分裂成 2 个。

问所有初始点在经历了线段的分裂后，在最后会有多少个点掉在 $ x $ 轴上

## 说明/提示

样例解释：

注意， $y$ 轴正方向为重力方向。
在坐标轴中，横坐标为 $x$ 的碎块，先掉到纵坐标为2的线段上，然后分成两个从 $1$ 和 $3$ 往下掉，$3$ 的那个掉到了纵坐标为1的线段上，分成两个从 $2$ 和 $6$ 往下掉，第一个碎块一共变成了 $3$ 块，分别掉在 $1，2，6$ ，第二个碎块一共变成了两个碎块，分别掉在 $2，6$。

| 子问题 | 特殊限制条件 | 分值 |
| :-----------: | :-----------: | :-----------: |
| 1 | $ 1\leq n,m \leq 10 $ | 10 |
| 2 | $ 1\leq n,m \leq 100 $ | 5 |
| 3 | $ 1\leq n\leq 10^4， 1\leq m \leq 5\times 10^5 $ | 35 |
| 4 |$ 1\leq n,m \leq 5\times 10^5 $|50|

本题各个子问题之间不捆绑测试。

对于 $100\%$ 的数据 $ 1\leq n,m \leq 5\times 10^5 $，所有数字均为非负整数。


## 样例 #1

### 输入

```
2 2
1 3 2
2 6 1
3 5```

### 输出

```
5```

# AI分析结果

### 算法分类
**树状数组**

### 综合分析与结论
本题的核心在于处理线段的分裂过程，并计算最终落在x轴上的点数。由于线段的分裂会导致点数倍增，直接模拟会超时。因此，大多数题解采用了**线段树**或**树状数组**来优化区间修改和单点查询的操作。具体思路是：
1. 将线段按高度排序，从低到高处理。
2. 对于每条线段，查询其区间内的点数，并将该区间的点数清零，然后在左右端点分别加上查询到的点数。
3. 最终统计所有初始点对应的贡献。

### 所选题解
#### 1. 作者：bsTiat (5星)
**关键亮点**：
- 使用线段树维护区间修改和单点查询，思路清晰。
- 代码简洁，逻辑严谨，易于理解。

**核心代码**：
```cpp
void update(int l, int r, int val) {
    if (l <= tr[id].l && tr[id].r <= r) {
        tr[id].val = val;
        tr[id].lz = 1;
        return;
    }
    pd(id);
    if (tr[lid].r >= l) update(l, tr[lid].r, lid, val);
    if (tr[rid].l <= r) update(tr[rid].l, r, rid, val);
}
```
**实现思想**：通过线段树的区间修改和单点查询功能，高效处理线段的分裂过程。

#### 2. 作者：Disjoint_cat (4星)
**关键亮点**：
- 详细解释了从暴力到优化的思路转变，适合初学者理解。
- 使用线段树优化了时间复杂度，代码结构清晰。

**核心代码**：
```cpp
void modify(int l, int r, int x, int y, int p) {
    if (x <= l && r <= y) {
        d[k] = p;
        tag[k] = p;
        return;
    }
    pushdown(k);
    int mid = l + r >> 1;
    if (x <= mid) modify(lc(k), l, mid, x, y, p);
    if (y > mid) modify(rc(k), mid+1, r, x, y, p);
}
```
**实现思想**：通过线段树的区间赋值和单点查询功能，高效处理线段的分裂过程。

#### 3. 作者：stntn (4星)
**关键亮点**：
- 使用线段树维护区间推平和单点查询，思路清晰。
- 代码简洁，逻辑严谨，易于理解。

**核心代码**：
```cpp
void update_pos(int rt, int l, int r, int pos, int val) {
    if (l == r) {
        sum[rt] += val;
        return;
    }
    pushdown(rt);
    if (pos <= mid) update_pos(lc, l, mid, pos, val);
    else update_pos(rc, mid+1, r, pos, val);
    pushup(rt);
}
```
**实现思想**：通过线段树的单点修改和区间查询功能，高效处理线段的分裂过程。

### 最优关键思路或技巧
1. **线段树/树状数组**：用于高效处理区间修改和单点查询，避免直接模拟的超时问题。
2. **排序**：将线段按高度排序，从低到高处理，确保每次操作不影响后续操作。
3. **区间推平**：在处理每条线段时，先查询区间内的点数，然后将该区间的点数清零，再在左右端点分别加上查询到的点数。

### 可拓展之处
- **离散化**：如果坐标范围较大，可以使用离散化来优化空间复杂度。
- **动态开点线段树**：适用于坐标范围非常大的情况，避免空间浪费。

### 推荐题目
1. [P3372 【模板】线段树 1](https://www.luogu.com.cn/problem/P3372)
2. [P3368 【模板】树状数组 2](https://www.luogu.com.cn/problem/P3368)
3. [P5490 【模板】扫描线](https://www.luogu.com.cn/problem/P5490)

### 个人心得
- **调试经历**：在处理线段树时，懒标记的下传和更新顺序容易出错，需要仔细检查。
- **踩坑教训**：在处理区间推平时，忘记清零区间内的点数，导致结果错误。
- **顿悟感想**：通过排序和线段树的结合，可以高效处理复杂的区间操作问题。

---
处理用时：28.14秒
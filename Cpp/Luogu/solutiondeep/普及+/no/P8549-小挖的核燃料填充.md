# 题目信息

# 小挖的核燃料填充

## 题目描述

小挖做 Web 设计的时候，剧情里插入了酷炫的核填充情节！但很可惜，受制于技术，情节对应的游戏竟然是数独……

一开始，会给定你一个有 $n\times n$ 个**宫**，每个宫中有 $n \times n$ 个元素，且**早已全部正确填好**的 $n$ 阶数独。本题中数独游戏的详细表示与玩法见下方 **“补充说明”** 。

但小挖会把其中**一些宫向左或者向右转 90 度/180 度**。比如，若一个宫初始为

```cpp
087
654
321
```

那么它向左旋转 $90$ 度后会变成：

```cpp
741
852
063
```
你在恢复数独时，也**只能将一些宫向左转 $90$ 度**，一次旋转算作一步。现在小挖想考考你：如果把操作后的数独重新恢复成合法的数独，最少需要多少步呢？

如果一开始小挖给出的数独局面不可以通过任意次、任意位置的左旋得到，则输出 $-1$ 。~~为什么呢？因为小挖给出的是“自认为完全正确的”数独，但实际不一定。~~

## 说明/提示

对于 $40\%$ 的数据，$2 \le n\leq 3$。

对于 $100\%$ 的数据，$2 \le n\leq 4$。

## Hint

$n$ 阶数独合法的条件：每一行、每一列、每一个粗线宫 $(n\times n)$ 内的数字均含 $0\sim  n^2-1$，且不重复。

需要注意的是，本题内对于 $4$ 阶数独的表示方式中 $>9$ 的数字采用了十六进制表示法。准确来说 $\mathrm A=10$，$\mathrm B=11$，$\mathrm C=12$，$\mathrm D=13$，$\mathrm E=14$，$\mathrm F=15$。


## 样例 #1

### 输入

```
3
701210842
832478367
564653501
386648785
457235610
021170423
410702257
327514806
685368341```

### 输出

```
12
1 1
1 1
1 2
1 3
2 1
2 2
2 3
2 3
3 1
3 1
3 3
3 3```

## 样例 #2

### 输入

```
4
36952EA1CF74857C
18E207C9B36D0419
4DAC56BF8209DFE2
B07FD3485AE1BA36
36B5B7CA6E5839FE
A4985620FD32A8B7
01CF94DF1B7C0564
7DE283E14A09C21D
B46D729D0F7246B0
8CF560154BCA159E
1327AB8459D8D278
EA09FC3E6E31A3CF
8E910623C5622B60
320BF7EDB847CDFE
45AF5A18310F183A
6CD7B9C4A9ED7459
```

### 输出

```
17
1 1
1 1
1 2
1 2
1 3
1 3
1 4
2 2
2 3
2 4
3 1
3 2
3 2
3 3
4 1
4 2
4 4
```

# AI分析结果

### 算法分类
深度优先搜索 DFS、剪枝

### 综合分析与结论
题目要求通过旋转宫格来恢复合法的数独，且只能进行左旋操作。由于数据范围较小（n ≤ 4），可以采用深度优先搜索（DFS）结合剪枝的策略来解决。各题解的核心思路相似，都是通过DFS枚举每个宫格的旋转次数，并在搜索过程中进行合法性检查和剪枝，以减少不必要的计算。

### 所选题解
#### 1. 作者：zplqwq (赞：15)  
**星级：★★★★★**  
**关键亮点：**  
- 使用DFS枚举每个宫格的旋转次数，结合栈记录操作步骤。
- 通过合法性检查（check函数）和剪枝优化搜索效率。
- 代码结构清晰，注释详细，易于理解。

**个人心得：**  
作者提到DFS的结束条件是当x=n+1时，此时判断当前矩阵是否为合法矩阵并记录答案。这种思路清晰且易于实现。

**核心代码：**
```cpp
void dfs(int x, int y, int cnt) {
    if (x == n + 1) {
        if (check(n, n)) {
            if (cnt < ans) {
                ans = cnt;
                da = an;
            }
        }
        return;
    }
    if (check(x, y - 1) == 0) return;
    if (y == n + 1) dfs(x + 1, 1, cnt);
    for (int i = 0; i < 4; i++) {
        dfs(x, y + 1, cnt + i);
        change(x, y);
        an.push(make_pair(x, y));
    }
    for (int i = 0; i < 4; ++i) an.pop();
}
```
**核心思想：**  
通过DFS枚举每个宫格的旋转次数，并在每次旋转后进行合法性检查，记录最小步数。

#### 2. 作者：FReQuenter (赞：2)  
**星级：★★★★☆**  
**关键亮点：**  
- 使用DFS枚举每个宫格的旋转次数，结合剪枝优化搜索效率。
- 通过合法性检查（check函数）和最优性剪枝减少不必要的计算。
- 代码简洁，逻辑清晰。

**核心代码：**
```cpp
void dfs(int idxx, int idxy, int sum) {
    if (sum > ans) return;
    if (idxy > n) idxy = 1, idxx++;
    if (idxx > n) {
        if (check(n, n) && sum < ans) {
            for (int i = 1; i <= sum; i++) anses[i] = anstmp[i];
            ans = sum;
        }
        return;
    }
    if (idxy == 1 && !check(idxx - 1, n)) return;
    if (!check(idxx, idxy - 1)) return;
    dfs(idxx, idxy + 1, sum);
    for (int i = 1; i <= 3; i++) {
        anstmp[sum + i] = {idxx, idxy};
        turn_left(idxx, idxy);
        dfs(idxx, idxy + 1, sum + i);
    }
    turn_right(idxx, idxy, 3);
}
```
**核心思想：**  
通过DFS枚举每个宫格的旋转次数，结合合法性检查和最优性剪枝，记录最小步数。

#### 3. 作者：strlen_s_ (赞：2)  
**星级：★★★★☆**  
**关键亮点：**  
- 使用DFS枚举每个宫格的旋转次数，结合剪枝优化搜索效率。
- 通过合法性检查（check函数）和最优性剪枝减少不必要的计算。
- 代码简洁，逻辑清晰。

**核心代码：**
```cpp
void dfs(int x, int y, int cnt) {
    if (cnt > ans) return;
    if (y > n) x++, y = 1;
    if (x > n) {
        if (check(n, n)) {
            ans = min(ans, cnt);
            for (int i = 1; i <= cnt; i++) p[i] = l[i], q[i] = r[i];
        }
        return;
    }
    if (y == 1) if (!check(x - 1, n)) return;
    else if (!check(x, y - 1)) return;
    dfs(x, y + 1, cnt);
    for (int i = 1; i <= 3; i++) {
        l[cnt + i] = x, r[cnt + i] = y;
        tl(x, y);
        dfs(x, y + 1, cnt + i);
    }
    tr(x, y), tr(x, y), tr(x, y);
}
```
**核心思想：**  
通过DFS枚举每个宫格的旋转次数，结合合法性检查和最优性剪枝，记录最小步数。

### 最优关键思路或技巧
1. **DFS + 剪枝**：通过DFS枚举每个宫格的旋转次数，结合合法性检查和最优性剪枝，减少不必要的计算。
2. **合法性检查**：在每次旋转后，检查当前矩阵是否为合法数独，确保搜索的有效性。
3. **记录操作步骤**：使用栈或数组记录每次旋转的操作步骤，便于最终输出。

### 可拓展之处
类似的问题可以通过DFS结合剪枝的策略来解决，尤其是在数据范围较小的情况下。例如，数独问题、拼图问题等都可以采用类似的思路。

### 推荐题目
1. P1074 靶形数独
2. P1784 数独
3. P2329 数独游戏

---
处理用时：30.93秒
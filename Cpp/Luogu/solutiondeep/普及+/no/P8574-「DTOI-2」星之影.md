# 题目信息

# 「DTOI-2」星之影

## 题目背景

>闻是白极影，见时方立竿。

## 题目描述

白极影化为立竿之人莅临人间，带来了星之函数 $f(x)$，它的值为最接近于 $\sqrt[4]x$ 的整数$\\$（即 $f(x)=\left\lfloor\sqrt[4]x+\dfrac12\right\rfloor$；$\lfloor u\rfloor$ 为对 $u$ 向下取整后的值）。

现有 $t$ 个数字 $n$，对于每个 $n$，立竿人想知道 $\sum\limits_{i=1}^n\dfrac1{f(i)}$ 的值是多少，请你告诉它吧。

---
~~因为立竿人很急，所以~~本题的 $t$ 组询问强制在线，后一个询问需通过前一个询问的答案生成。

可用以下 `C++` 代码生成（其他语言同理；需包含 `<stdio.h>`）：
```cpp
typedef long long ll;
char buf_ans[114];
ll next_n(double last_ans=0,ll get_n=0){
	//last_ans<n<=1e18
	sprintf(buf_ans,"%.6f",last_ans);
	for(ll i=0,x=0;;i++){
		if(buf_ans[i]=='.')return get_n^x;
		if(i&1)x*=10;
		else x=x*10+(buf_ans[i]^48);
	}
}
```
该函数第一个参数为上一次询问的答案（第一次询问时该值为 $0$，也就是说第一个数未经加密），第二个参数为这一次读入的被加密的数，函数返回解密后的 $n$。

## 说明/提示

### 样例解释

样例#1 解密后各组询问分别是：
$$
\def{\r}{\cr\hline}
\def\arraystretch{1.5}\begin{array}{|c|c|c|c|c|c|c|c|}\hline
\textbf{t}&1&2&3&4&5&6&7\r
\textbf{n}&1&4&8&89&2022&1145141919810&1\r
\end{array}
$$
### 数据范围

**本题采用捆绑测试。**
$$
\def\arraystretch{1.5}\begin{array}{|c|c|c|c|}\hline
\textbf{Subtask} & t= & n\le&\bm{\textbf{Score}} \cr\hline
1 & 10&10^6 & 2 \cr\hline
2&1000&10^6&13\cr\hline
3&100&10^9&15\cr\hline
4 &1000&10^{18}&40\cr\hline
5 &%\text{No Special Constraints}
5\times10^5&10^{18}& 30 \cr\hline
\end{array}
$$

对于 $100\%$ 的数据，$10 \le t \le 5\times10^5$，$1 \le n \le 10^{18}$。

### 计分规则

本题采用 $\textbf{Special Judge}$，令你输出的答案为 $\text{pans}$，标答答案为 $\text{jans}$，如果 $\vert \text{pans}-\text{jans}\vert<\text{jans}\times10^{-5}$ 那么该组数据通过，在一个测试点内只有所有 $t$ 组数据通过该测试点才算通过。

注意后一个 $\text{Subtask}$ 对前一个 $\text{Subtask}$ 有依赖关系，即如果你没有在前一个 $\text{Subtask}$ 拿到分，那么你即使通过后一个 $\text{Subtask}$ 的所有测试点，你也无法拿到后面的分数。

## 样例 #1

### 输入

```
7
1
5
12
95
2040
1145141920209
1070909051```

### 输出

```
1.000000
4.000000
6.500000
38.666667
403.857143
1475989956.412959
1.000000```

# AI分析结果

### 算法分类
数学

### 综合分析与结论
本题的核心在于计算函数 $f(x) = \left\lfloor \sqrt[4]{x} + \frac{1}{2} \right\rfloor$ 的和 $\sum_{i=1}^n \frac{1}{f(i)}$。由于 $f(x)$ 的增长速度较慢，且多个 $x$ 可能对应相同的 $f(x)$，因此可以通过数学推导和预处理来优化计算。

### 所选题解
1. **作者：spdarkle (赞：4)**
   - **星级：5星**
   - **关键亮点**：通过数学推导，直接计算出 $a = \left\lfloor \frac{\sqrt[4]{1+16n}-1}{2} \right\rfloor$，并利用公式 $\frac{2a(a+1)(2a+1)+3a}{3} + \frac{1}{a+1}\left(n - a^2(a+1)^2 - \frac{a(a+1)}{2}\right)$ 计算答案。单次询问复杂度为 $O(1)$，无需预处理。
   - **代码核心思想**：通过数学公式直接计算答案，避免了循环和预处理。
   ```cpp
   int find(int n) {
       return (sqrt(sqrt(1.0 + 16.0 * n)) + 1) / 2;
   }
   double solve(int t) {
       double ans = 0;
       int now = find(t);
       ans += get(now - 1);
       ans += 1.0 * (t - count(now - 1)) / now;
       return ans;
   }
   ```

2. **作者：Ryder00 (赞：0)**
   - **星级：4星**
   - **关键亮点**：通过预处理每个不同的 $f(x)$ 值对应的贡献，并使用前缀和优化查询，单次查询复杂度为 $O(1)$。
   - **代码核心思想**：预处理每个 $f(x)$ 值的贡献，并使用前缀和进行快速查询。
   ```cpp
   void init() {
       for(db i = 0.5; i <= 31623.5; i += 1.0) {
           if((ll)floor(i)) dis[cnt] = ((ll)floor(i * i * i * i + 0.5) - llst + 1.0) / floor(i);
           if(cnt) sum[cnt] = sum[cnt - 1] + dis[cnt];
           llst = ceil(i * i * i * i + 0.5);
           st[cnt + 1] = llst;
           cnt++;
       }
       cnt--;
   }
   ```

### 最优关键思路或技巧
1. **数学推导**：通过数学公式直接计算答案，避免了循环和预处理，极大提高了效率。
2. **前缀和优化**：通过预处理每个 $f(x)$ 值的贡献，并使用前缀和进行快速查询，适用于需要多次查询的场景。

### 可拓展之处
类似的问题可以通过数学推导和预处理来优化计算，特别是在函数值变化缓慢的情况下。例如，计算 $\sum_{i=1}^n \frac{1}{\lfloor \sqrt{i} \rfloor}$ 也可以通过类似的方法进行优化。

### 推荐题目
1. [P2261 [CQOI2007]余数求和](https://www.luogu.com.cn/problem/P2261)
2. [P2260 [清华集训2012]模积和](https://www.luogu.com.cn/problem/P2260)
3. [P2262 [NOI2010]超级钢琴](https://www.luogu.com.cn/problem/P2262)

---
处理用时：20.00秒
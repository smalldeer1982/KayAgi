# 题目信息

# [蓝桥杯 2014 省 B] 小朋友排队

## 题目描述

$n$ 个小朋友站成一排。现在要把他们按身高从低到高的顺序排列，但是每次只能交换位置相邻的两个小朋友。

每个小朋友都有一个不高兴的程度。开始的时候，所有小朋友的不高兴程度都是 $0$。

如果某个小朋友第一次被要求交换，则他的不高兴程度增加 $1$，如果第二次要求他交换，则他的不高兴程度增加 $2$（即不高兴程度为 $3$），依次类推。当要求某个小朋友第 $k$ 次交换时，他的不高兴程度增加 $k$。

请问，要让所有小朋友按从低到高排队，他们的不高兴程度之和最小是多少。

如果有两个小朋友身高一样，则他们谁站在谁前面是没有关系的。

## 说明/提示

【样例说明】

首先交换身高为 $3$ 和 $2$ 的小朋友，再交换身高为 $3$ 和 $1$ 的小朋友，再交换身高为 $2$ 和 $1$ 的小朋友，每个小朋友的不高兴程度都是 $3$，总和为 $9$。

【数据规模与约定】

对于 $10\%$ 的数据，$1 \le n \le 10$；

对于 $30\%$ 的数据，$1 \le n \le 1000$；

对于 $50\%$ 的数据，$1 \le n \le 10000$；

对于 $100\%$ 的数据，$1 \le n \le 100000$，$0 \le H_i \le 1000000$。

时限 1 秒, 256M。蓝桥杯 2014 年第五届省赛

## 样例 #1

### 输入

```
3
3 2 1```

### 输出

```
9```

# AI分析结果

【算法分类】  
树状数组

【综合分析与结论】  
该题的核心逻辑是通过计算每个小朋友的交换次数来求解最小不高兴程度。交换次数的计算依赖于逆序对的概念，即每个小朋友前面比它大的数和后面比它小的数。由于数据规模较大（$n \le 10^5$），直接使用冒泡排序或暴力算法会超时，因此需要借助树状数组或归并排序等高效算法来求解逆序对。树状数组因其简洁的代码和高效的时间复杂度（$O(n \log n)$）成为最优解。

【评分较高的题解】  
1. **作者：DengDuck**  
   - **星级：5星**  
   - **关键亮点**：使用树状数组分别计算每个小朋友前面比它大的数和后面比它小的数，结合等差数列求和公式求解最小不高兴程度。代码清晰，逻辑严谨，且考虑了离散化处理。  
   - **核心代码**：
     ```cpp
     for(int i=1;i<=n;i++) {
         update(a[i]+1,1);
         cnt[i]+=(i-getsum(a[i]+1)); //统计前面比它大的数字
     }
     memset(t,0,sizeof(t));
     for(int i=n;i>=1;i--) {
         update(a[i]+1,1);
         cnt[i]+=getsum(a[i]); //统计后面比它小的数字
     }
     for(int i=1;i<=n;i++) {
         ans+=(cnt[i]+1)*cnt[i]/2; //算出这个数字的代价
     }
     ```

2. **作者：Hyc_**  
   - **星级：4星**  
   - **关键亮点**：同样使用树状数组求解逆序对，代码简洁高效，且通过将每个数加一避免了树状数组中插入0的问题。  
   - **核心代码**：
     ```cpp
     for(int i=1;i<=n;++i){
         cnt[i]+=i-query(a[i])-1;
         add(a[i]);
     }
     memset(t,0,sizeof(t));
     for(int i=n;i;--i){
         cnt[i]+=query(a[i]-1);
         add(a[i]);
     }
     for(int i=1;i<=n;++i)
         ans+=((cnt[i]+1)*cnt[i])>>1;
     ```

3. **作者：_Weslie_**  
   - **星级：4星**  
   - **关键亮点**：详细解释了逆序对的计算过程，并通过树状数组实现了高效的求解。代码结构清晰，注释详细。  
   - **核心代码**：
     ```cpp
     for(int i=1;i<=n;i++){
         add(a[i]);
         ans[i]=i-query(a[i]);
     }
     memset(tr,0,sizeof(tr));
     for(int i=n;i>=1;i--){
         add(a[i]);
         ans[i]+=query(a[i]-1);
     }
     long long anss=0;
     for(int i=1;i<=n;i++){
         anss+=1ll*ans[i]*(ans[i]+1)/2;
     }
     ```

【最优关键思路或技巧】  
1. **树状数组的应用**：通过树状数组高效计算逆序对，时间复杂度为 $O(n \log n)$，适合大规模数据处理。  
2. **离散化处理**：对于数据范围较大的情况，离散化可以优化树状数组的空间复杂度。  
3. **等差数列求和**：交换次数的代价可以通过等差数列求和公式快速计算，避免了逐次累加的复杂度。

【可拓展之处】  
1. **逆序对问题的变种**：类似题目可以通过树状数组或归并排序求解，如统计数组中满足某种条件的元素对数量。  
2. **数据结构优化**：树状数组不仅适用于逆序对问题，还可以用于区间查询、单点更新等场景。

【推荐题目】  
1. [P1908 逆序对](https://www.luogu.com.cn/problem/P1908)  
2. [P3374 树状数组 1](https://www.luogu.com.cn/problem/P3374)  
3. [P3368 树状数组 2](https://www.luogu.com.cn/problem/P3368)

---
处理用时：24.10秒
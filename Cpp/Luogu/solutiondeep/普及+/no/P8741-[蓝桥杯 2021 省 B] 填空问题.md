# 题目信息

# [蓝桥杯 2021 省 B] 填空问题

## 题目描述


## 试题 A ：空间

### 【问题描述】

小蓝准备用 $256 \mathrm{MB}$ 的内存空间开一个数组，数组的每个元素都是 $32$  位二进制整数，如果不考虑程序占用的空间和维护内存需要的辅助空间，请问 $256 \mathrm{MB}$ 的空间可以存储多少个 $32$  位二进制整数?

### 【答案提交】

这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。

## 试题 B ：卡片

### 【问题描述】

小蓝有很多数字卡片，每张卡片上都是数字 $0$  到 $9$ 。

小蓝准备用这些卡片来拼一些数，他想从 $1$  开始拼出正整数，每拼一个，就保存起来，卡片就不能用来拼其它数了。

小蓝想知道自己能从 $1$  拼到多少。

例如，当小蓝有 $30$  张卡片，其中 $0$  到 $9$  各 $3$  张，则小蓝可以拼出 $1$  到 $10$ ，但是拼 $11$  时卡片 $1$  已经只有一张了，不够拼出 $11$ 。

现在小蓝手里有 $0$  到 $9$  的卡片各 $2021$  张，共 $20210$  张，请问小蓝可以从 $1$  拼到多少?

提示：建议使用计算机编程解决问题。

### 【答案提交】

这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。

## 试题 C ：直线

### 【问题描述】

在平面直角坐标系中，两点可以确定一条直线。如果有多点在一条直线上，那么这些点中任意两点确定的直线是同一条。

给定平面上 $2 \times 3$ 个整点 $\{(x,y) \mid 0 \leq x<2,0 \leq y<3,x \in \mathbb{Z},y \in \mathbb{Z}\}$，即横坐标是 $0$  到 $1$  (包含 $0$  和 $1$ ) 之间的整数、纵坐标是 $0$  到 $2$  (包含 $0$  和 $2$  ) 之间的整数的点。这些点一共确定了 $11$  条不同的直线。

给定平面上 $20 \times 21$ 个整点 $\{(x,y) \mid 0 \leq x<20,0 \leq y<21,x \in \mathbb{Z},y \in \mathbb{Z}\}$，即横坐标是 $0$  到 $19$  (包含 $0$  和 $19$ ) 之间的整数、纵坐标是 $0$  到 $20$  (包含 $0$  和 $20$ ) 之间的整数的点。请问这些点一共确定了多少条不同的直线。

### 【答案提交】

这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。

## 试题 D ：货物摆放

### 【问题描述】

小蓝有一个超大的仓库，可以摆放很多货物。

现在，小蓝有 $n$ 箱货物要摆放在仓库，每箱货物都是规则的正方体。小蓝规定了长、宽、高三个互相垂直的方向，每箱货物的边都必须严格平行于长、 宽、高。

小蓝希望所有的货物最终摆成一个大的立方体。即在长、宽、高的方向上分别堆 $L 、 W 、 H$ 的货物，满足 $n=L \times W \times H$。

给定 $n$，请问有多少种堆放货物的方案满足要求。

例如，当 $n=4$ 时，有以下 $6$  种方案：$1 \times 1 \times 4 、 1 \times 2 \times 2 、 1 \times 4 \times 1 、 2 \times 1 \times 2$ 、 $2 \times 2 \times 1 、 4 \times 1 \times 1$

请问，当 $n=2021041820210418$ (注意有 $16$  位数字) 时，总共有多少种方案?

提示：建议使用计算机编程解决问题。

### 【答案提交】

这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。

## 试题 E ：路径

### 【问题描述】

小蓝学习了最短路径之后特别高兴，他定义了一个特别的图，希望找到图中的最短路径。

小蓝的图由 $2021$  个结点组成，依次编号 $1$  至 $2021$ 。

对于两个不同的结点 $a,b$，如果 $a$ 和 $b$ 的差的绝对值大于 $21$ ，则两个结点之间没有边相连; 如果 $a$ 和 $b$ 的差的绝对值小于等于 $21$ ，则两个点之间有一条长度为 $a$ 和 $b$ 的最小公倍数的无向边相连。

例如：结点 $1$  和结点 $23$  之间没有边相连; 结点 $3$  和结点 $24$  之间有一条无向边，长度为 $24$  ; 结点 $15$  和结点 $25$  之间有一条无向边，长度为 $75$ 。

请计算，结点 $1$  和结点 $2021$  之间的最短路径长度是多少。

提示：建议使用计算机编程解决问题。

### 【答案提交】

这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。

## 说明/提示

答题模板，可供参考。

```cpp
#include<iostream>
using namespace std;
int main() {
    string ans [] = {
        "The answer of task A", // 双引号中替换为 A 题的答案
        "The answer of task B", // 双引号中替换为 B 题的答案
        "The answer of task C", // 双引号中替换为 C 题的答案
        "The answer of task D", // 双引号中替换为 D 题的答案
        "The answer of task E", // 双引号中替换为 E 题的答案
    };
    char T;
    cin >> T;
    cout << ans[T - 'A'] << endl;
    return 0;
}
```

# AI分析结果

### 算法分类
- **试题 A：空间** - 数学
- **试题 B：卡片** - 枚举
- **试题 C：直线** - 数学、枚举
- **试题 D：货物摆放** - 枚举、数学
- **试题 E：路径** - 图论、最短路

### 综合分析与结论
这些题解主要围绕数学计算、枚举和图论展开，题解质量参差不齐，部分题解思路清晰、代码简洁，而有些则较为冗长或缺乏优化。以下是对各题解的综合分析：

1. **试题 A：空间** - 所有题解都通过简单的数学计算得出答案，思路一致，代码简洁。
2. **试题 B：卡片** - 大部分题解采用暴力枚举，思路清晰，但部分题解代码冗长，优化不足。
3. **试题 C：直线** - 题解主要通过枚举和去重来计算直线数量，部分题解使用了 `set` 来去重，思路较为清晰。
4. **试题 D：货物摆放** - 题解通过枚举所有因数组合来计算方案数，部分题解代码冗长，优化不足。
5. **试题 E：路径** - 大部分题解使用 Dijkstra 算法求解最短路，思路清晰，但部分题解代码冗长，优化不足。

### 评分较高的题解
1. **作者：cq_irritater**
   - **星级：4.5**
   - **关键亮点**：代码简洁，思路清晰，尤其是试题 E 的 Dijkstra 算法实现较为规范。
   - **个人心得**：无
   - **核心代码**：
     ```cpp
     // 试题 E：路径
     void dijkstra() {
         memset(d, 0x3f3f3f, sizeof(d));
         d[1] = 0;
         for (int i = 1; i < 2021; i++) {
             int x = 0;
             for (int j = 1; j < 2021; j++) {
                 if (!visited[j] && d[j] < d[x]) {
                     x = j;
                 }
             }
             visited[x] = 1;
             for (int j = max(1, x - 21); j <= min(2021, x + 21); j++) {
                 d[j] = min(d[j], d[x] + edges[x][j]);
             }
         }
     }
     ```

2. **作者：xler0915**
   - **星级：4**
   - **关键亮点**：试题 C 的直线计算部分使用了 `set` 去重，思路清晰，代码简洁。
   - **个人心得**：无
   - **核心代码**：
     ```cpp
     // 试题 C：直线
     for (int i = 0; i < 20; i++) {
         for (int j = 0; j < 21; j++) {
             x[i * 21 + j + 1] = i, y[i * 21 + j + 1] = j;
         }
     }
     for (int i = 1; i <= 20 * 21; i++) {
         for (int j = 1; j <= 20 * 21; j++) {
             if (x[i] == x[j] || y[i] == y[j]) continue;
             double k = 1.0 * (y[i] - y[j]) / (x[i] - x[j]);
             double b = 1.0 * (x[i] * y[j] - x[j] * y[i]) / (x[i] - x[j]);
             s.insert({k, b});
         }
     }
     ```

3. **作者：Vct14**
   - **星级：4**
   - **关键亮点**：试题 E 的 Floyd 算法实现较为规范，思路清晰。
   - **个人心得**：无
   - **核心代码**：
     ```cpp
     // 试题 E：路径
     void Floyd() {
         memset(dis, 0x3f3f3f3f, sizeof(dis));
         for (ui i = 1; i <= 2021; i++) {
             for (ui j = 0; j < v[i].size(); j++) {
                 dis[i][u[i][j]] = dis[u[i][j]][i] = v[i][j];
             }
         }
         for (int k = 1; k <= 2021; k++) {
             for (int i = 1; i <= 2021; i++) {
                 for (int j = 1; j <= 2021; j++) {
                     dis[i][j] = dis[j][i] = min(dis[i][j], dis[i][k] + dis[k][j]);
                 }
             }
         }
         cout << dis[1][maxn];
     }
     ```

### 最优关键思路与技巧
1. **数学计算**：试题 A 和试题 C 的核心在于数学计算，尤其是单位换算和直线方程的计算。
2. **枚举与去重**：试题 B 和试题 C 通过枚举和去重来解决问题，使用 `set` 可以有效去重。
3. **最短路算法**：试题 E 使用 Dijkstra 或 Floyd 算法求解最短路，规范实现是关键。

### 可拓展之处
1. **数学计算**：可以拓展到更复杂的数学问题，如几何、数论等。
2. **枚举与去重**：可以拓展到组合数学问题，如排列组合、子集枚举等。
3. **最短路算法**：可以拓展到更复杂的图论问题，如最小生成树、网络流等。

### 推荐题目
1. **P1001 A+B Problem** - 数学计算
2. **P1219 [USACO1.5]八皇后 Checker Challenge** - 枚举与去重
3. **P3371 【模板】单源最短路径（弱化版）** - 最短路算法

---
处理用时：36.19秒
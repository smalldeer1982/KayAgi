# 题目信息

# 成熟时追随原神

## 题目背景

可莉喜欢生活在树上。

![](https://img2.huashi6.com/images/resource/2021/04/29/8945867h9p0.jpg?imageMogr2/quality/100/interlace/1/thumbnail/700x)

画师 pid：4787895

## 题目描述

可莉生活在一颗有根树上，初始节点从 $1$ 到 $n$ 编号。为了方便可莉的出行，蒙德人决定从每个非叶子节点出发，修建一条新道路。具体而言，对与每个非叶子节点 $u$，蒙德人会从其子节点中均匀随机选取一个点 $v$，并在 $u$ 和 $v$ 之间修建一条新道路。显然，这些新修建的道路连成了许多的连通块。为了帮助他们的修建，你需要告诉蒙德人，连通块个数的期望是多少。

可莉听说这个任务后，认为它对于你而言太简单了。因此，她决定添加一些对于树的修改操作：

- $\text{Add}\ u$：在节点 $u$ 下添加一子结点，编号为 $n+i$，其中 $i$ 为操作编号。保证操作前结点 $u$ 存在。
- $\text{Del}\ u$：删除结点 $u$。保证操作前结点 $u$ 存在且为叶子结点。
- $\text{Upd}\ u$：将树根变为 $u$。保证操作前结点 $u$ 存在。

同时，对于任意时刻，保证树不会被删空。

对于初始的树和每次修改之后所得的树，你都需要回答一遍上述的问题。注意，$m$ 次修改之间不独立，但是蒙德人每次修建的新道路不受上一次结果的影响。

## 说明/提示

$$
\begin{array}{|c|c|c|c|}\hline
\textbf{测试点编号}& { n\le} & {m\le} & \textbf{特殊性质} \cr\hline
1\sim 3 & 5 & 5 & - \cr\hline
4\sim 7 & 1000 & 1000 &- \cr\hline
8\sim 10 & 10^5 & 0 & - \cr\hline
11\sim 13 & 10^5 & 2\times 10^5 & \textbf{AB}\cr\hline
14\sim 16 & 2\times 10^5 & 5\times 10^4 & \textbf{A} \cr\hline
17\sim 20 & 2\times 10^5 & 2\times 10^5 & - \cr\hline
\end{array}
$$

- 特殊性质 $\textbf{A}$：保证不存在 $\text{Upd}$ 操作。
- 特殊性质 $\textbf{B}$：保证不存在 $\text{Del}$ 操作。

对于 $100\%$ 的数据，$1\le n,m\le 2\times 10^5$。保证 $1\le f_i<i$。

## 样例 #1

### 输入

```
2
1
4
Add 1
Upd 2
Del 3
Del 1```

### 输出

```
1
2
1
1
1
```

# AI分析结果

### 算法分类
图论

### 综合分析与结论
题目要求计算树中连通块的期望数量，实际上等价于计算叶子节点的数量。所有题解都抓住了这一关键点，并通过维护叶子节点的数量来解决问题。不同题解在实现细节上有所差异，但核心思路一致。主要难点在于如何处理树的动态修改操作（Add、Del、Upd），并高效维护叶子节点的数量。

### 所选高星题解

#### 1. 作者：gan1234 (5星)
**关键亮点**：
- 思路清晰，直接指出连通块数量等于叶子节点数量。
- 使用 `unordered_set` 维护邻接表，高效处理动态修改操作。
- 代码简洁，逻辑明确，易于理解。

**核心代码**：
```cpp
int f(int x){//判断是否是叶结点
    return (x==rt&&s[x].size()==0)||(x!=rt&&s[x].size()==1);
}
```
**个人心得**：
- 通过 `unordered_set` 实现邻接表，避免了频繁的插入和删除操作，提高了效率。

#### 2. 作者：H2ptimize (4星)
**关键亮点**：
- 详细解释了连通块数量与叶子节点数量的关系。
- 使用 `set` 维护邻接表，处理动态修改操作。
- 代码结构清晰，注释详细。

**核心代码**：
```cpp
bool check(int u)
{
    if((u==root&&T[u].empty())||(u!=root&&T[u].size()==1))return true;
    else return false;
}
```
**个人心得**：
- 通过 `set` 实现邻接表，确保了操作的稳定性和效率。

#### 3. 作者：CWzwz (4星)
**关键亮点**：
- 使用邻接表维护树的动态修改操作。
- 通过度数判断叶子节点，逻辑清晰。
- 代码简洁，易于理解。

**核心代码**：
```cpp
bool leaf(int u) {
    return deg[u] <= 1;
}
```
**个人心得**：
- 通过度数判断叶子节点，简化了逻辑，提高了代码的可读性。

### 最优关键思路或技巧
- **连通块数量与叶子节点数量的等价性**：通过分析发现连通块数量等于叶子节点数量，简化了问题。
- **邻接表的动态维护**：使用 `unordered_set` 或 `set` 维护邻接表，高效处理动态修改操作。
- **度数判断叶子节点**：通过节点的度数快速判断是否为叶子节点，简化了逻辑。

### 可拓展之处
- 类似问题可以扩展到其他树形结构，如二叉树、多叉树等。
- 动态维护叶子节点的技巧可以应用于其他需要动态修改树结构的题目。

### 推荐题目
1. [P3379 【模板】最近公共祖先（LCA）](https://www.luogu.com.cn/problem/P3379)
2. [P3384 【模板】树链剖分](https://www.luogu.com.cn/problem/P3384)
3. [P3369 【模板】普通平衡树](https://www.luogu.com.cn/problem/P3369)

---
处理用时：18.84秒
# 题目信息

# [CEOI 2022] Homework

## 题目描述

这是 Helena 的数学作业中的一道题：

我们定义合法表达式如下：

- `?` 是合法表达式，这表示一个未知数。
- 如果 $A,B$ 均为合法表达式，那么 `min(`$A$`,`$B$`)` 和 `max(`$A$`,`$B$`)` 均为合法表达式，这分别表示取左右两边的最大值/最小值。

设 `?` 的个数为 $N$，现在给出一个合法表达式，将每一个问号替换为 $1\sim N$ 中的任意一个数并且每一个数不能使用多次，可以得到多少种不同的答案？

可怜的 Helena 并不会做，请你帮帮她。

## 说明/提示

### 样例 1 解释

无论权值如何选择，最后的答案都会是 $\min\{1,2,3,4\}$，也就是 $1$。

### 样例 2 解释

答案为 $4$ 的方案是： `4=max(4,max(3,min(2,1)))`，答案为 $3$ 的方案是 `3=max(3,max(2,min(1,4)))`，可以证明答案不可能为 $1$ 或 $2$。

### 数据规模与约定

对于全部数据，$2\le N\le 10^6$。

| Subtask 编号 |                                   特殊限制                                   | 得分 |
| :----------: | :--------------------------------------------------------------------------: | :--: |
|     $1$      |                                   $N\le 9$                                   | $10$ |
|     $2$      |                                  $N\le 16$                                   | $13$ |
|     $3$      | 对于任意 `min(`$A$`,`$B$`)` 与 `max(`$A$`,`$B$`)`，$A$ 和 $B$ 中有一个为 `?`。 | $13$ |
|     $4$      |                                 $N\le 10^3$                                  | $30$ |
|     $5$      |                                  无特殊限制                                   | $34$ |

## 样例 #1

### 输入

```
min(min(?,?),min(?,?))```

### 输出

```
1```

## 样例 #2

### 输入

```
max(?,max(?,min(?,?)))```

### 输出

```
2```

## 样例 #3

### 输入

```
min(max(?,?),min(?,max(?,?)))```

### 输出

```
3```

# AI分析结果

### 算法分类
动态规划

### 综合分析与结论
题目要求计算合法表达式中所有问号替换为不同数字后可能的不同答案数量。核心思路是通过构建表达式树，并利用动态规划来计算每个子树可能的取值范围。难点在于如何正确合并不同子树的取值范围，并最终确定整个表达式的可能取值区间。

### 所选题解

#### 题解1：PCCP (5星)
**关键亮点**：
- 通过克鲁斯卡尔重构树的思想，将表达式转化为树结构，便于动态规划的计算。
- 详细解释了如何通过 `le_i` 和 `ge_i` 来合并不同子树的取值范围，并给出了正确的转移方程。
- 代码实现清晰，使用了栈来构建树结构，并通过深度优先搜索（DFS）来计算每个节点的取值范围。

**核心代码**：
```cpp
void dfs1(int x){
	if(tr[x].l){
		dfs1(tr[x].l);
	}
	if(tr[x].r){
		dfs1(tr[x].r);
	}
	if(!tr[x].kind){
		tr[x].ge=tr[tr[x].l].ge+tr[tr[x].r].ge+1;
		tr[x].le=min(tr[tr[x].l].le,tr[tr[x].r].le);
	}
	else if(tr[x].kind&1){
		tr[x].le=tr[tr[x].l].le+tr[tr[x].r].le+1;
		tr[x].ge=min(tr[tr[x].l].ge,tr[tr[x].r].ge);
	}
}
```

#### 题解2：Bitaro (4星)
**关键亮点**：
- 通过动态规划计算每个节点作为答案时的限制条件，判断每个值是否合法。
- 使用了区间合并的思想，将所有可能的合法区间取并集，最终得到答案。
- 代码实现较为简洁，使用了深度优先搜索（DFS）来计算每个节点的限制条件。

**核心代码**：
```cpp
void dfs(int u) {
  for(auto v:e[u]) dfs(v);
  leaf(u) {
    f[u][0][0]=1;
    f[u][1][1]=1;
  } else {
    int ls=e[u][0],rs=e[u][1];
    if(opt[u]==1) {
      f[u][0][0]=f[ls][0][0]+f[rs][0][0];
      f[u][0][1]=f[ls][0][1]+f[rs][0][1];
      f[u][1][0]=min({f[ls][1][0]+f[rs][1][0],f[ls][0][0]+f[rs][1][0],f[ls][1][0]+f[rs][0][0]});
      f[u][1][1]=min({f[ls][1][1]+f[rs][1][1],f[ls][0][1]+f[rs][1][1],f[ls][1][1]+f[rs][0][1]});
    } else {
      f[u][0][0]=min({f[ls][0][0]+f[rs][0][0],f[ls][0][0]+f[rs][1][0],f[ls][1][0]+f[rs][0][0]});
      f[u][0][1]=min({f[ls][0][1]+f[rs][0][1],f[ls][0][1]+f[rs][1][1],f[ls][1][1]+f[rs][0][1]});
      f[u][1][0]=f[ls][1][0]+f[rs][1][0];
      f[u][1][1]=f[ls][1][1]+f[rs][1][1];
    }
  }
}
```

#### 题解3：LJ07 (4星)
**关键亮点**：
- 通过构建表达式树，并利用动态规划来计算每个子树的取值范围。
- 详细解释了如何通过 `l_i` 和 `r_i` 来合并不同子树的取值范围，并给出了正确的转移方程。
- 代码实现较为简洁，使用了深度优先搜索（DFS）来计算每个节点的取值范围。

**核心代码**：
```cpp
void slv(int u)
{
	if (!lc[u] && !rc[u]) {
		f[u] = mk(0, 0);
		return ;
	}
	slv(lc[u]);
	slv(rc[u]);
	auto [l1, r1] = f[lc[u]];
	auto [l2, r2] = f[rc[u]];
	if (o[u]) {
		f[u] = mk(min(l1, l2), r1 + r2 + 1);
	}else {
		f[u] = mk(l1 + l2 + 1, min(r1, r2));
	}
}
```

### 最优关键思路
通过构建表达式树，并利用动态规划来计算每个子树的取值范围，最终合并得到整个表达式的可能取值区间。关键在于如何正确合并不同子树的取值范围，并利用深度优先搜索（DFS）来计算每个节点的取值范围。

### 可拓展之处
类似的问题可以通过构建树结构，并利用动态规划来计算每个子树的取值范围。例如，处理复杂的数学表达式或逻辑表达式时，可以采用类似的方法。

### 推荐题目
1. [P1040 加分二叉树](https://www.luogu.com.cn/problem/P1040)
2. [P1057 传球游戏](https://www.luogu.com.cn/problem/P1057)
3. [P1063 能量项链](https://www.luogu.com.cn/problem/P1063)

### 个人心得摘录
- **PCCP**：赛时思路虽然有问题，但通过模拟和深入思考，最终找到了正确的转移方程。
- **Bitaro**：通过简单的动态规划，避免了复杂的性质分析，代码实现较为简洁。
- **LJ07**：通过构建表达式树，并利用动态规划来计算每个子树的取值范围，代码实现较为简洁。

---
处理用时：30.63秒
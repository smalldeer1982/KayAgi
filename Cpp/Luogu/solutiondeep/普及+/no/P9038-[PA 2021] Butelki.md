# 题目信息

# [PA 2021] Butelki

## 题目描述

Byteasar 有三瓶橙汁。他现在想通过把橙汁从一个瓶子倒入另一个瓶子的方式，让其中一个瓶子恰好装有 $k$ 升橙汁。因为他家里没有量筒，所以唯一允许的操作是在两个瓶子之间转移橙汁——要么把一个瓶子倒空，要么把一个瓶子倒满。橙汁不能撒到地上，也不能在这三个瓶子之外添加橙汁。

Byteasar 现在想知道，对于每一个 $k$，最少需要转移多少次橙汁才能让三个瓶子中的一个装有恰好 $k$ 升橙汁。他希望你帮帮他。

## 说明/提示

对于 $100\%$ 的数据，$1 \leq A \leq B \leq C \leq 10^5$，$0 \leq a \leq A$，$0 \leq b \leq B$，$0 \leq c \leq C$。

## 样例 #1

### 输入

```
2 7 9
1 3 6```

### 输出

```
1 0 1 0 1 1 0 1 2 1```

# AI分析结果

### 算法分类
**广度优先搜索 BFS**

### 综合分析与结论
本题的核心是通过BFS搜索所有可能的倒水状态，找到使其中一个瓶子恰好装有$k$升橙汁的最小操作次数。各题解均采用BFS进行状态搜索，但实现方式和优化程度有所不同。Tjaweiof和Lazy_crush的题解通过状态压缩和记忆化搜索优化了空间和时间复杂度，而iiiiiyang和ycy1124的题解则通过哈希和队列实现BFS，代码较为直观但效率稍低。

### 所选高星题解
#### 1. 作者：Tjaweiof (赞：4)  
**星级：5星**  
**关键亮点：**  
- 使用状态压缩和记忆化搜索，有效减少状态数。
- 通过队列实现BFS，代码结构清晰，易于理解。
- 详细注释和逻辑分析，帮助理解算法思路。

**核心代码：**
```cpp
void pu(int a, int b, int c, int t){
    if (a + b <= A){
        q.push({c, 1, 0, t});
    }
    if (a + b >= A){
        q.push({a + b - A, 0, 1, t});
    }
    // 其他类似情况
}
```
**实现思想：**  
通过枚举所有可能的倒水操作，将新状态加入队列，并使用记忆化数组记录已访问状态，避免重复计算。

#### 2. 作者：Lazy_crush (赞：0)  
**星级：4星**  
**关键亮点：**  
- 使用BFS进行状态搜索，通过结构体记录状态和步数。
- 通过状态压缩和记忆化搜索优化空间和时间复杂度。
- 代码结构清晰，逻辑严谨。

**核心代码：**
```cpp
void qpush(int x, int y, int z, int step){
    if(x+y<=A) q.push({z,1,0,step});
    if(x+y>=A) q.push({x+y-A,0,1,step});
    // 其他类似情况
}
```
**实现思想：**  
通过枚举所有可能的倒水操作，将新状态加入队列，并使用记忆化数组记录已访问状态，避免重复计算。

### 最优关键思路或技巧
- **状态压缩与记忆化搜索**：通过将状态压缩为一个整数或结构体，并使用记忆化数组记录已访问状态，有效减少状态数和计算量。
- **BFS队列实现**：通过队列实现BFS，确保每次操作都能找到最小步数，避免重复计算。

### 可拓展之处
- **类似题目**：可以扩展到多个瓶子的倒水问题，或引入更多限制条件（如瓶子的容量不同）。
- **算法套路**：BFS+状态压缩+记忆化搜索的组合适用于许多状态搜索问题，如八数码、迷宫问题等。

### 推荐题目
1. [P1443 马的遍历](https://www.luogu.com.cn/problem/P1443)
2. [P1137 旅行计划](https://www.luogu.com.cn/problem/P1137)
3. [P1162 填涂颜色](https://www.luogu.com.cn/problem/P1162)

### 个人心得摘录
- **Tjaweiof**：通过状态压缩和记忆化搜索，有效减少了状态数，避免了重复计算，提高了算法效率。
- **Lazy_crush**：通过BFS进行状态搜索，确保每次操作都能找到最小步数，代码结构清晰，逻辑严谨。

### 通用建议与扩展思路
- **状态压缩**：在处理状态搜索问题时，考虑将状态压缩为一个整数或结构体，减少内存占用。
- **记忆化搜索**：使用记忆化数组记录已访问状态，避免重复计算，提高算法效率。
- **BFS队列实现**：通过队列实现BFS，确保每次操作都能找到最小步数，避免重复计算。

---
处理用时：22.15秒
# 题目信息

# [PA 2021] Ranking sklepów internetowych

## 题目描述

给定长为 $n$ 的**排列** $a$。

定义区间 $[l, r]$ 的权值如下：将区间内的数从小到大排序，设 $x$ 为区间长度（即 $r - l + 1$），$y$ 为区间中位数，则该区间的权值为 $x + 2y$。

求所有 $\frac{n(n + 1)}{2}$ 个区间中权值的最大值和最大值的个数。

------------

中位数的定义：

以一个长为 $n$ 的**单调递增**的序列 $a$ 为例。

- 当 $n$ 为奇数，中位数为 $a_{\frac{n + 1}{2}}$。
- 当 $n$ 为偶数，中位数为 $\frac{a_{\frac{n}{2}} + a_{\frac{n}{2} + 1}}{2}$。

## 说明/提示

对于 $100\%$ 的数据，$1 \leq n \leq 10^6$，$1 \leq a_i \leq n$。

## 样例 #1

### 输入

```
5
1 4 3 5 2```

### 输出

```
11 5```

# AI分析结果

### 算法分类
数学、构造

### 综合分析与结论
本题的核心在于通过数学推导和构造法，找到区间权值的最大值及其出现次数。所有题解都基于排列的性质，推导出最大值为 $2n+1$，并通过构造法统计最大值的出现次数。虽然思路相似，但实现细节和优化程度有所不同。

### 所选题解
1. **作者：LYBT (4星)**
   - **关键亮点**：通过数学推导明确最大值为 $2n+1$，并详细解释了构造法的思路。代码实现清晰，处理边界情况较为完善。
   - **个人心得**：通过推理发现最大值与中位数无关，简化了问题。
   - **核心代码**：
     ```cpp
     for(int i=n;i>=n/2;i--){
         int len,tem,tl,tr;
         l=min(l,pos[i]);
         r=max(r,pos[i]);
         len=r-l+1;
         tem=(n-i)*2+1-len;
         if(tem>=0){
             tl=min(r+tem,n)-r;
             tr=l-max(l-tem,1);
             ans+=max(tl+tr-tem+1,0);
         }
     }
     ```

2. **作者：superl61 (4星)**
   - **关键亮点**：通过贪心思想，固定必选区间，并计算可选区间的范围。代码实现简洁，时间复杂度为 $O(n)$。
   - **个人心得**：通过固定必选区间，简化了问题。
   - **核心代码**：
     ```cpp
     F(m, 1, n){
         int nw = n - m + (m + 1) / 2;
         l = min(l, pos[nw]);
         r = max(r, pos[nw]);
         int t = m - (r - l + 1);
         if(t < 0) continue;    
         int yul = l - 1;
         int yur = n - r;
         int most = min(t, yul);
         int least = max(0ll, t - yur);
         ans += most - least + 1;
     }
     ```

3. **作者：zhm080507 (4星)**
   - **关键亮点**：通过预处理和数学计算，简化了问题。代码实现清晰，处理边界情况较为完善。
   - **个人心得**：通过预处理和数学计算，简化了问题。
   - **核心代码**：
     ```cpp
     for(ll i=2;i<=n;i++){
         ll mi=i/2;
         ll ds=n-mi;
         if(ps[ds]<lt) lt=ps[ds];
         if(ps[ds]>rt) rt=ps[ds];
         if(rt-lt+1>i) continue;
         else{
             ll rs=n-rt;
             ll ls=lt-1;
             ll ln=i-(rt-lt+1);
             if(ls<rs) swap(ls,rs);
             if(ls>=ln&&rs>=ln){
                 s+=ln+1;
             }else{
                 s+=(min(ln,ls)-(ln-rs)+1);
             }
         }
     }
     ```

### 最优关键思路或技巧
1. **数学推导**：通过排列的性质，推导出最大值为 $2n+1$，简化了问题。
2. **构造法**：通过固定必选区间，并计算可选区间的范围，统计最大值的出现次数。
3. **边界处理**：在计算可选区间时，注意处理边界情况，确保计算的准确性。

### 可拓展之处
类似的问题可以通过数学推导和构造法解决，尤其是在处理排列或组合问题时。可以通过预处理和数学计算，简化问题并提高效率。

### 推荐题目
1. [P1045 最大子段和](https://www.luogu.com.cn/problem/P1045)
2. [P1060 开心的金明](https://www.luogu.com.cn/problem/P1060)
3. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)

---
处理用时：23.28秒
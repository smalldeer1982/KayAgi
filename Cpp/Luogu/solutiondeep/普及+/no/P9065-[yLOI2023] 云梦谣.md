# 题目信息

# [yLOI2023] 云梦谣

## 题目背景

> 归来且做云梦梦一场 大梦好  
> 栽花闻酒香 醒醒醉醉笑笑  
> 天地偌大复路远山高 最难得偷半日逍遥  
> 偶尔糊涂不问世事不知晓

——银临 & 慕寒《云梦谣》

## 题目描述

“喂，枸杞，你这只笨狗，又偷吃！看我不收拾你！”

朵一气呼呼地从院子里跑出来，手中握着掸子，而枸杞早已不见踪影。

云梦庭可以看作一个 $n$ 行 $m$ 列的方格阵，第 $i$ 行第 $j$ 列的格子被记作 $(i,j)$。每个格子 $(i,j)$ 要么有一个高度 $h_{i,j}$（$h_{i,j}$ 为正整数），要么是障碍物，不能通过。（方便起见，约定障碍物的 $h_{i,j}$ 用 $0$ 表示。）另外，云梦庭上有 $k$ 个指定的格子上可以进行**御剑飞行**。开始时，朵一和枸杞分别位于方格 $(1,1)$ 和 $(n,m)$。

朵一的御剑飞行还不是很熟练，现在她还控制不好御剑的高度。因此在任意时刻，朵一在方格 $(i,j)$ 上可以做如下行动之一：

- 移动到与该方格相邻的方格 $(i-1,j)$、$(i+1,j)$、$(i,j-1)$、$(i,j+1)$ 之一上（不能移动出方格边界，也不能移动到障碍物上）；
- 如果方格 $(i,j)$ 上允许御剑飞行，则朵一可以御剑飞行至另一个**同样允许御剑飞行且与方格 $(i,j)$ 高度相等的方格上**；
- 使用仙法将当前格子的高度 $h_{i,j}$ 改变为任一正整数。

进行上述每项行动均需花费 $1$ 个单位时间。

“哼，笨狗子你再跑！”说罢，朵一便追了出去。朵一接下来还要尽快继续今天的修行，因此她想知道到达 $(n,m)$ 格子所需的最短时间是多少。

## 说明/提示

### 样例 1 解释

第 $1$ 个单位时间，朵一将当前方格 $(1,1)$ 的高度修改为 $4$；  
第 $2$ 个单位时间，朵一从方格 $(1,1)$ 御剑飞行至 $(3,4)$；  
第 $3$ 个单位时间，朵一从方格 $(3,4)$ 移动到 $(4,4)$，追上了枸杞。

### 样例 2 解释

第 $1$ 个单位时间，朵一从方格 $(1,1)$ 御剑飞行至 $(4,1)$；  
第 $2$ 个单位时间，朵一从方格 $(4,1)$ 移动到 $(4,2)$；  
第 $3$ 个单位时间，朵一从方格 $(4,2)$ 移动到 $(4,3)$；  
第 $4$ 个单位时间，朵一从方格 $(4,3)$ 移动到 $(4,4)$，追上了枸杞。

### 数据规模与约定


![](https://cdn.luogu.com.cn/upload/image_hosting/f2epmv84.png)

对全部的测试点，保证 $1 \leq n, m \leq 3 \times 10^3$，$0 \leq k,h_{i,j} \leq n \times m$。
### 提示

请注意大量数据读入对程序效率造成的影响，选择合适的读入方式，避免超时。

### 说明

本题共有 5 个附加样例文件，见附件里的 dream.zip。

### 后记

不过，别看朵一现在一副生气的样子，可当她追上枸杞后，大抵是不舍得真的动手吧。“嘿嘿，今日的修行结束后，该吃什么好呢？”在这飞瀑悬挂、翠竹怀抱的云梦庭中，修仙炼体，不羡尘嚣，应是这世上最逍遥的事了。

## 样例 #1

### 输入

```
4 4 2
1 2 3 4
1 2 3 4
1 2 3 4
1 2 3 4
1 1
3 4```

### 输出

```
3```

## 样例 #2

### 输入

```
4 4 3
1 2 3 4
1 2 3 4
1 2 3 4
1 2 3 4
1 1
2 4
4 1```

### 输出

```
4```

## 样例 #3

### 输入

```
2 5 0
1 0 3 3 4
2 3 4 0 5```

### 输出

```
7```

## 样例 #4

### 输入

```
4 4 3
1 1 1 0
1 1 0 1
1 0 1 1
0 1 1 1
1 1
2 1
3 3```

### 输出

```
3```

# AI分析结果

### 算法分类
广度优先搜索 BFS

### 综合分析与结论
本题的核心是通过BFS求解从起点到终点的最短路径，结合传送点的特殊操作（御剑飞行和改变高度）进行优化。题解中主要思路是通过BFS分别从起点和终点出发，找到最近的传送点，并判断是否存在高度相同的传送点对，从而减少时间消耗。优化点在于只进行一次传送操作，并通过桶记录高度信息，避免重复计算。

### 所选题解
1. **题解作者：一扶苏一**  
   **星级：5星**  
   **关键亮点：**  
   - 通过BFS分别从起点和终点出发，找到最近的传送点。
   - 使用桶记录高度信息，判断是否存在高度相同的传送点对。
   - 优化了时间复杂度，避免了重复计算。
   **核心代码：**
   ```cpp
   int bfs(int bx, int by, int ex, int ey, int d[][maxn]) {
     int ret = INF;
     std::queue<std::pair<int, int>> Q;
     d[bx][by] = 0;
     for (Q.push(std::make_pair(bx, by)); !Q.empty(); Q.pop()) {
       int x = Q.front().first, y = Q.front().second;
       if (ret == INF && isTrans[x][y]) ret = d[x][y];
       for (int i = 0; i < 4; ++i) {
         int px = dx[i] + x, py = dy[i] + y;
         if (px && py && px <= n && py <= m && h[px][py] && d[px][py] == INF) {
           d[px][py] = d[x][y] + 1;
           Q.push(std::make_pair(px, py));
         }
       }
     }
     return ret;
   }
   ```

2. **题解作者：Transfixion_**  
   **星级：4星**  
   **关键亮点：**  
   - 通过优先队列优化BFS，确保每次找到最近的传送点。
   - 使用标记数组避免重复访问，提高效率。
   **核心代码：**
   ```cpp
   void bfs() {
     Q.push({1, 1, 0});
     while(!Q.empty()) {
       int x = Q.top().x, y = Q.top().y, step = Q.top().step;
       Q.pop();
       if(x == n && y == m) {
         std::cout << step;
         exit(0);
       }
       if(vis[x][y]) continue;
       vis[x][y] = 1;
       for(int i = 0; i < 4; i++) {
         int nx = x + dx[i], ny = y + dy[i];
         if(vis[nx][ny] || !h[nx][ny]) continue;
         Q.push({nx, ny, step + 1});
       }
       if(!chk[x][y] || flg) continue;
       for(int i = 1; i <= n; i++) {
         for(int j = 1; j <= m; j++) {
           if(!chk[i][j] || (i == x && j == y)) continue;
           Q.push({i, j, step + 1 + (h[i][j] != h[x][y])});
         }
       } flg = 1;
     }
   }
   ```

3. **题解作者：MspAInt**  
   **星级：4星**  
   **关键亮点：**  
   - 通过两次BFS分别计算起点和终点到各点的距离。
   - 使用桶记录高度信息，判断是否存在高度相同的传送点对。
   **核心代码：**
   ```cpp
   int bfs(bool l){
     queue<pair<int,int>>q;
     int sx,sy,ret=1e9+1;
     sx=l*n+(!l),sy=l*m+(!l);
     q.push(make_pair(sx,sy));
     d[sx][sy][l]=0;
     memset(v,0,sizeof(v));
     v[sx][sy]=1;
     while(!q.empty()){
       pair<int,int>bot=q.front();
       int x=bot.first,y=bot.second;q.pop();
       if(p[x][y]&&ret>1e9)ret=d[x][y][l];
       for(int i=1;i<=4;i++){
         int ex=x+dx[i],ey=y+dy[i];
         if(ex<1||ex>n||ey<1||ey>m||!h[ex][ey]||v[ex][ey])
           continue;
         v[ex][ey]=1;
         d[ex][ey][l]=d[x][y][l]+1;
         q.push(make_pair(ex,ey));
       }
     }
     return ret;
   }
   ```

### 关键思路与技巧
1. **BFS优化：** 通过优先队列或标记数组优化BFS，确保每次找到最近的传送点。
2. **桶记录高度：** 使用桶记录高度信息，判断是否存在高度相同的传送点对，减少时间复杂度。
3. **一次传送操作：** 通过证明最多只进行一次传送操作，简化问题复杂度。

### 拓展思路
类似的问题可以通过BFS结合特殊操作进行优化，如传送、跳跃等。可以拓展到图论中的最短路径问题，结合特殊边权进行优化。

### 推荐题目
1. [P1073 最优贸易](https://www.luogu.com.cn/problem/P1073)
2. [P3956 棋盘](https://www.luogu.com.cn/problem/P3956)
3. [P9751 最短路径](https://www.luogu.com.cn/problem/P9751)

---
处理用时：35.69秒
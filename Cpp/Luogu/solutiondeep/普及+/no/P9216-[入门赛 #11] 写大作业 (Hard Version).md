# 题目信息

# [入门赛 #11] 写大作业 (Hard Version)

## 题目背景

**本题与 Easy Version 的区别在于：输入的是数列而不是字符串，输入输出格式不同，数据规模不同**。


## 题目描述

扶苏为了写计算理论大作业已经 $36$ 小时没有合眼了。

为了能快点睡觉，扶苏找到了 $n$ 份文献，第 $i$ 份文献是一数列 $a_i$，她打算把这些文献组合起来。

具体来说，一共有两种操作：

- `1 x y`：把文献 $a_x$ 整体拼接到 $a_y$ 的后面，然后删除 $a_x$。
- `2 x y`：查询 $a_x$ 和 $a_y$ 是否**相似**。

我们保证在 `1 x y` 操作出现后，数列 $a_x$ **不会**出现在接下来的任何操作中。这就是说，操作 $1$ 至多有 $n-1$ 次。

**相似**的定义是：对两个数列 $a_x$ 和 $a_y$，如果存在一种重新排列 $a_x$ 的方法，使得重排后的 $a_x$ 和 $a_y$ 相等，则称 $a_x$ 和 $a_y$ **相似**。

例如，假设 $a_1 = 1,2$, $a_2 = 3,4$，$a_3 = 1,2,3,4$，则执行 `1 1 2` 后，$a_1$ 被删除，$a_2 = 3,4,1,2$，$s_3 = 1,2,3,4$；继续执行 `2 2 3` 后，因为可以把 $a_2$ 重排为 $1,2,3,4$，所以 $a_2$ 和 $a_3$ 相似。

注意，操作 $2$ 不会对数列做出实际修改。

## 说明/提示

### 样例解释

共有五次操作，它们的编号和回答情况如下：
| 编号 | 操作 | 回答 |
| :-: | :-: | :-: |
| $1$ | `1 1 2` | 不是查询操作|
| $2$ | `2 2 3` | 相似 |
| $3$ | `2 3 4` | 不相似 |
| $4$ | `2 2 4` | 不相似 |
| $5$ | `2 2 3` | 相似 |

可以看到，回答为**两数列相似**的询问的操作编号为 $2$ 和 $5$。它们的按位异或和是 $7$。故输出为 $7$。

### 数据规模与约定

对全部的测试点，保证 $1 \leq n \leq 10^5$，$1 \leq q \leq 5 \times 10^6$，$1 \leq m_i \leq 10^5$，$\sum_{i = 1}^n m_i \leq 5 \times 10^5$。数列里的元素都是不超过 $10^9$ 的非负整数。

数据保证数列元素的生成方式是：对一个数列，限定一个该数列元素大小的上界 $k$，然后在 $[0, k]$ 内均匀随机地生成 $m_i$ 个整数作为数列 $a_i$。注意，$k$ 不一定是 $10^9$。

## 样例 #1

### 输入

```
4 5
2 1 2
2 3 4
4 1 2 3 4
4 1 2 3 3
1 1 2
2 2 3
2 3 4
2 2 4
2 3 2```

### 输出

```
7```

# AI分析结果

### 算法分类
并查集、哈希

### 综合分析与结论
题目要求处理数列的合并与相似性判断，核心在于如何高效维护数列的哈希值以支持快速查询。各题解主要采用哈希算法，通过给每个数分配随机权值，计算数列的哈希值来判断相似性。合并操作则是将两个数列的哈希值相加。难点在于如何设计哈希函数以降低冲突概率，同时保证合并和查询的高效性。

### 所选高星题解
1. **作者：L0vely_NaiL0ng (4星)**
   - **关键亮点**：使用随机权值哈希，简单高效，代码简洁。
   - **代码核心**：
     ```cpp
     ull v[N];
     map<int, ull> id;
     for (int i = 1; i <= n ; i++) {
         int m; scanf("%d", &m);
         for (int j = 1; j <= m; j++) {
             int x; scanf("%d", &x);
             if (!id[x]) id[x] = rnd() + 1;
             v[i] += id[x];
         }
     }
     ```
   - **个人心得**：通过随机权值哈希，避免了复杂的启发式合并，代码实现简单且高效。

2. **作者：MspAInt (4星)**
   - **关键亮点**：使用`rand()*rand()`生成随机权值，提高哈希值的随机性。
   - **代码核心**：
     ```cpp
     int a[N],n,q,res;
     map<int,int>val;
     for(int i=1;i<=n;i++){
         int m;scanf("%d",&m);
         for(int j=1,x;j<=m;j++){
             scanf("%d",&x);
             if(!val[x])val[x]=rand()*rand();
             a[i]+=val[x];
         }
     }
     ```
   - **个人心得**：通过`rand()*rand()`生成更大的随机数，提高哈希值的随机性，减少冲突。

3. **作者：苏联小渣 (4星)**
   - **关键亮点**：使用和哈希，结合随机权值，代码简洁且高效。
   - **代码核心**：
     ```cpp
     int n, q, op, x, y, ans, len, b[100010];
     map <int, int> mp;
     for (int i=1; i<=n; i++){
         scanf ("%lld", &len);
         for (int j=1; j<=len; j++){
             scanf ("%lld", &x);
             if (mp.find(x) == mp.end()) mp[x] = rand() % mo + 1;
             b[i] += mp[x];
         }
     }
     ```
   - **个人心得**：通过和哈希结合随机权值，简化了哈希计算，代码实现简洁。

### 最优关键思路或技巧
- **随机权值哈希**：给每个数分配一个随机权值，通过求和或异或等方式计算数列的哈希值，支持快速合并和查询。
- **启发式合并**：在合并操作中，将较小的数列合并到较大的数列中，减少操作次数。

### 可拓展之处
- **多哈希**：使用多个不同的哈希函数，进一步降低冲突概率。
- **离散化**：对于大数据范围，可以先离散化处理，减少哈希值的计算量。

### 推荐题目
1. [P3374 【模板】树状数组 1](https://www.luogu.com.cn/problem/P3374)
2. [P3368 【模板】树状数组 2](https://www.luogu.com.cn/problem/P3368)
3. [P3811 【模板】乘法逆元](https://www.luogu.com.cn/problem/P3811)

### 个人心得总结
- **调试经历**：在实现哈希函数时，多次测试不同随机权值生成方式，确保哈希值的随机性和唯一性。
- **踩坑教训**：避免使用简单的`rand()`函数生成随机数，容易导致哈希冲突。
- **顿悟感想**：通过随机权值哈希，简化了复杂的启发式合并，代码实现更加简洁高效。

---
处理用时：25.53秒
# 题目信息

# 「TAOI-1」Antipathy World

## 题目背景

> 簡単なことも解らないわ \
> あたしって何だっけ \
> それすら夜の手に絆されて \
> 愛のように 消える 消える \
> さようならも言えぬ儘泣いた フォニイ フォニイ フォニイ \
> 嘘に絡まっているあたしはフォニイ \
> **ANTIPATHY WORLD**

## 题目描述

**这是一道 IO 交互题。**

可不有 $n$ 朵花，每朵花有一个正整数美丽度。

她发现，有一朵花的美丽度不小于其它任何一朵花的美丽度的两倍。

你想知道这朵花是哪一朵，于是你可以进行至多 $k$ 次询问，每次询问你给出两个正整数 $i,j \in [1, n]$，可不会告诉你第 $i$ 朵和第 $j$ 朵花的美丽度之差的绝对值。

你想运用这些询问的答案，得到最美丽的花是第几朵。

### 交互格式

**本题有多组数据**。

第一行交互库给出一个整数 $T$，表示数据组数。

对于每组数据，第一行输入两个正整数 $n,k$。

对于你的每组询问，你输出 `? i j`，交互库会返回一个非负整数，表示第 $i$ 朵和第 $j$ 朵花的美丽度之差。

如果你已经得到答案，输出 `! i` 代表你得到第 $i$ 朵花为最美丽的花。在此之后你应该开始对下一组数据的处理。

每次你输出之后，请**刷新缓冲区**。

你可以使用如下语句来清空缓冲区：

- 对于 C/C++：`fflush(stdout)`；
- 对于 C++：`std::cout << std::flush`；
- 对于 Java：`System.out.flush()`；
- 对于 Python：`stdout.flush()`；
- 对于 Pascal：`flush(output)`；
- 对于其他语言，请自行查阅对应语言的帮助文档。

特别的，对于 C++ 语言，在输出换行时如果你使用 `std::endl` 而不是 `'\n'`，也可以自动刷新缓冲区。

## 说明/提示

样例中给出了一种可能的交互方式，其中花的美丽度为 $\{4,1,2\}$。

---

**本题采用捆绑测试**。

- Subtask 1（20 points）：$k=\dfrac{n(n-1)}{2}$，$n \le 200$。
- Subtask 2（30 points）：$k=n$。
- Subtask 3（50 points）：$k=\left\lfloor\dfrac{n}{2}\right\rfloor+2$。

对于所有测试数据，设所有花的美丽度为 $a_i$，$1 \le T \le 25$，$3 \le n \le 5 \times 10^4$，$1 \le a_i \le 10^8$。

## 样例 #1

### 输入

```
1
3 114514

3

2

1
```

### 输出

```


? 1 2

? 1 3

? 2 3

! 1```

# AI分析结果

### 算法分类
**贪心**

### 综合分析与结论
题目要求通过有限次数的交互询问，找到美丽度最大的花。核心思路是利用贪心策略，通过两两分组比较，逐步缩小候选范围，最终确定最美丽的花。难点在于如何在有限的询问次数内高效地排除非候选花，并正确处理奇偶数的边界情况。

### 所选高星题解

#### 1. 作者：irris (4星)
**关键亮点**：
- 通过两两分组比较，减少询问次数，优化了时间复杂度。
- 处理了奇偶数的边界情况，确保算法的通用性。
- 代码简洁，逻辑清晰，易于理解。

**核心代码**：
```cpp
void solve() {
    int N, K, b, v; std::cin >> N >> K;
    for (int i = 1, x; i < N; i += 2) {
        std::cout << "? " << i << ' ' << i + 1 << std::endl, std::cin >> x;
        if (i == 1 || x > v) b = i, v = x;
    }
    int t = (b == N - 1 ? 1 : N), x1, x2;
    std::cout << "? " << t << ' ' << b << std::endl, std::cin >> x1;
    std::cout << "? " << t << ' ' << b + 1 << std::endl, std::cin >> x2;
    std::cout << "! " << ((N & 1) && (x1 > v && x2 > v) ? N : x1 > x2 ? b : b + 1) << std::endl;
}
```
**核心思想**：
- 通过两两分组比较，找到差值最大的一组，确定候选花。
- 最后通过额外的询问，确定最美丽的花。

#### 2. 作者：251Sec (4星)
**关键亮点**：
- 详细分析了不同子任务的解决方法，提供了全面的解题思路。
- 通过分组和比较，减少了询问次数，优化了算法效率。
- 代码实现简洁，逻辑清晰。

**核心代码**：
```cpp
void solve() {
    int n, k;
    std::cin >> n >> k;
    int d = -1, I = 0;
    for (int i = 1; i + 1 <= n; i += 2) {
        int w = ask(i, i + 1);
        if (w > d) I = i, d = w;
    }
    int t = I + 1 == n ? 1 : n;
    int x[3] = {ask(I + 1, t), ask(I, t), d};
    int a[3] = {I, I + 1, t};
    for (int i = 0; i < 3; ++i) {
        std::rotate(x, x + 1, x + 3), std::rotate(a, a + 1, a + 3);
        if (x[0] != x[1] + x[2]) continue;
        if (x[1] > x[2])
            ans(a[2]);
        else
            ans(a[1]);
        return;
    }
}
```
**核心思想**：
- 通过两两分组比较，找到差值最大的一组，确定候选花。
- 最后通过额外的询问，确定最美丽的花。

#### 3. 作者：LHQing (4星)
**关键亮点**：
- 通过分组和比较，减少了询问次数，优化了算法效率。
- 处理了奇偶数的边界情况，确保算法的通用性。
- 代码实现简洁，逻辑清晰。

**核心代码**：
```cpp
void solve() {
    int n, k;
    std::cin >> n >> k;
    int p = 1, q = 0, d;
    for (int i = 1; i + 1 <= n; i += 2) {
        cout << "? " << i << " " << i + 1 << endl;
        cin >> d;
        if (d > q) p = i, q = d;
    }
    if (n & 1) {
        int x, y;
        cout << "? " << p << " " << n << endl;
        cin >> x;
        cout << "? " << p + 1 << " " << n << endl;
        cin >> y;
        if (q + y == x) {
            cout << "! " << (y > q ? n : p) << endl;
        } else if (q + x == y) {
            cout << "! " << (x > q ? n : p + 1) << endl;
        } else if (x + y == q) {
            cout << "! " << p + (x <= y) << endl;
        }
    } else {
        int x, y, z = (p == 1 ? 3 : 1);
        cout << "? " << p << " " << z << endl;
        cin >> x;
        cout << "? " << p + 1 << " " << z << endl;
        cin >> y;
        cout << "! " << p + (x <= y) << endl;
    }
}
```
**核心思想**：
- 通过两两分组比较，找到差值最大的一组，确定候选花。
- 最后通过额外的询问，确定最美丽的花。

### 最优关键思路或技巧
- **分组比较**：通过两两分组比较，减少询问次数，优化算法效率。
- **边界处理**：正确处理奇偶数的边界情况，确保算法的通用性。
- **三角关系**：通过额外的询问，构建三角关系，确定最美丽的花。

### 可拓展之处
- 类似的分组比较策略可以应用于其他需要高效排除候选的交互题中。
- 边界处理的技巧可以应用于其他需要处理奇偶数的算法中。

### 推荐题目
1. [P1001 A+B Problem](https://www.luogu.com.cn/problem/P1001)
2. [P1002 过河卒](https://www.luogu.com.cn/problem/P1002)
3. [P1003 铺地毯](https://www.luogu.com.cn/problem/P1003)

### 个人心得
- **调试经历**：在处理奇偶数的边界情况时，需要特别注意，避免遗漏某些情况。
- **踩坑教训**：在分组比较时，确保每次比较都能有效缩小候选范围，避免无效的询问。
- **顿悟感想**：通过分组和比较，可以大大减少询问次数，提高算法效率。

---
处理用时：37.12秒
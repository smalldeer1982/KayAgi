# 题目信息

# [PA 2022] Fotografia

## 题目描述

**题目译自 [PA 2022](https://sio2.mimuw.edu.pl/c/pa-2022-1/dashboard/) Runda 3 [Fotografia](https://sio2.mimuw.edu.pl/c/pa-2022-1/p/fot/)**

字节科技学校（*Bajtockiej Szkoły Technicznej*, BST）的毕业生们聚集在学校前面的广场上拍摄纪念照。他们排成一排，其位置从左到右编号为 $1$ 至 $n$，其中 $n$ 是今年毕业生的人数。

摄影师决定重新安排这些人的位置，让他们按身高升序排列。最矮的人在最左边，最高的人在最右边。幸运的是，今年的毕业生中没有任意两人身高相同。

为了避免混乱，安排位置将按一定方式进行。在一次操作中，摄影师将喊出一串位置编号。在这些位置上的人将按所喊到的顺序出列并走到广场中间。然后，摄影师将重复同样的数字列表。广场中间的人将他们出列顺序的**逆序**，依次回到摄影师所喊出的位置。

我们希望用尽可能少的操作将所有毕业生按身高的升序排列。你的工作是规划重新安排的方案，并告诉摄影师在第几次操作让哪些毕业生出列。

## 说明/提示

对于 $100\%$ 的数据，满足：

$1\le n\le 3 \times 10 ^ 3, 1\le h_i\le 3 \times 10 ^ 3, 1\le p_i\le n$。

## 样例 #1

### 输入

```
5
1670
2011
1560
1232
1447
```

### 输出

```
1
5
2 1 3 4 5
```

## 样例 #2

### 输入

```
6
1556
1449
1863
2014
1333
1220
```

### 输出

```
2
5
5 6 1 4 3
4
1 2 3 4
```

# AI分析结果

### 算法分类
**构造**

### 综合分析与结论
题目要求通过最少的操作将序列按身高升序排列，每次操作可以选择一组位置，将对应位置的人出列并按逆序重新排列。核心思路是通过构造操作序列，逐步将序列排序。

### 题解评分与亮点
1. **dutianchen1** (4星)
   - **关键亮点**：通过分析序列的环结构，提出每次操作可以将大环拆分为小环，最终通过两次操作将所有环拆分为自环。思路清晰，代码实现较为简洁。
   - **代码核心思想**：通过遍历序列，找到每个环，并通过交换操作将环拆分为更小的环，最终将所有环拆分为自环。

### 关键思路与技巧
- **环结构分析**：将序列视为由多个环组成，每次操作可以拆解或合并这些环，最终目标是让每个环变为自环。
- **贪心策略**：每次操作尽可能多地拆解环，避免合并环，以减少操作次数。

### 拓展思路
- **类似问题**：可以考虑其他需要通过特定操作将序列排序的问题，如通过交换相邻元素排序的冒泡排序问题。
- **算法优化**：可以进一步优化操作序列的生成，减少不必要的操作。

### 推荐题目
1. [P1908 逆序对](https://www.luogu.com.cn/problem/P1908)
2. [P1177 【模板】快速排序](https://www.luogu.com.cn/problem/P1177)
3. [P1068 分数线划定](https://www.luogu.com.cn/problem/P1068)

### 重点代码
```cpp
while(true){
    vector<ll> a,b;
    memset(vis,false,sizeof(vis));
    for(int i=1;i<=n;i++){//跑环 
        if(vis[i])continue;
        top=0;
        ll x=i;
        while(!vis[x]){
            c[++top]=x;
            vis[x]=true;
            x=opt[x];
        } 
        ll l=1,r=top;
        while(l<r){
            swap(opt[c[l]],opt[c[r]]);
            a.push_back(c[l]);
            b.push_back(c[r]);
            l++;r--;
        }
    }
    reverse(a.begin(),a.end());
    a.insert(a.end(),b.begin(),b.end());
    if(a.empty())break;
    ans.push_back(a);
} 
```
**核心实现思想**：通过遍历序列，找到每个环，并通过交换操作将环拆分为更小的环，最终将所有环拆分为自环。

---
处理用时：15.11秒
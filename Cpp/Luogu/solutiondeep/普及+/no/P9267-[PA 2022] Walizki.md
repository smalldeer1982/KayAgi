# 题目信息

# [PA 2022] Walizki

## 题目描述

**题目译自 [PA 2022](https://sio2.mimuw.edu.pl/c/pa-2022-1/dashboard/) Runda 5 [Walizki](https://sio2.mimuw.edu.pl/c/pa-2022-1/p/wal/)**

有没有想过，你在机场办理完了登机手续，你的行李箱会去哪里？就在它们消失的帘子后面，有一个巨大的大厅，里面布满了错综复杂的平台和传送带，对你的行李进行相应的分类。

Byteasar 负责评估新规划的 Byteburg Bitom 机场的行李大厅的设计。根据规划，大厅里将有 $n$ 个平台，用 $1$ 到 $n$ 的整数编号，每个行李箱最初都要运输到第一个平台。一些单向传送带可以从平台出发，连接到编号严格更大的平台。如果一个平台没有传送带出口，在这个平台的行李箱将由机场工作人员手动拿走并转移到相应的飞机上。另一方面，如果平台接有多条出口传送带，那么传送带的顺序就很重要——第一个行李箱遇到这样的平台，就会从第一条传送带上离开，第二个就会从第二条上离开，以此类推。当行李箱从最后一条传送带离开平台时，下一个行李箱又会从第一条传送带离开，如此循环往复。

一旦一个行李箱被送到第一个平台，它在传送带上的运输和工作人员的收集都在下一个行李箱放在第一个平台之前进行。换句话说，在任何时候，最多只有一个行李箱在传送带上运输。

可以想见，在处理了一定数量的行李箱后，这个行李系统会「复位」，即回到对于每个有出口传送带的平台，行李箱到达平台后都从第一条出口传送带离开的状态。Byteasar 想知道最少处理多少行李箱之后，系统将自我复位。请帮他计算出这个值！

## 说明/提示

对于 $100\%$ 的数据，满足：

$1\le n\le 100, i<l_{i,1}<l_{i,2}<\ldots<l_{i,r_i}$。

## 样例 #1

### 输入

```
7
3 2 3 5
2 3 6
3 5 6 7
1 6
1 7
0
0
```

### 输出

```
6
```

## 样例 #2

### 输入

```
3
0
1 3
0
```

### 输出

```
1
```

# AI分析结果

### 算法分类
模拟

### 综合分析与结论
该题目主要考察对行李传送系统的模拟能力。核心逻辑是通过模拟行李箱在平台之间的传送过程，找到系统复位的最小行李箱数量。由于题目描述中涉及到传送带的循环使用和顺序处理，模拟是最直接且有效的解决方式。

### 通用建议与扩展思路
1. **模拟思路**：通过模拟每个行李箱的传送路径，记录每个平台的传送带使用状态，直到所有平台的传送带状态恢复到初始状态。
2. **优化技巧**：可以使用状态压缩或哈希表来记录平台的传送带使用状态，以减少空间复杂度。
3. **类似题目**：这类模拟题目通常涉及到状态转移和循环检测，类似的问题可以参考洛谷上的其他模拟题。

### 推荐题目
1. [P1003 铺地毯](https://www.luogu.com.cn/problem/P1003)
2. [P1042 乒乓球](https://www.luogu.com.cn/problem/P1042)
3. [P1056 排座椅](https://www.luogu.com.cn/problem/P1056)

### 关键代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int n;
    cin >> n;
    vector<vector<int>> platforms(n);
    for (int i = 0; i < n; ++i) {
        int r;
        cin >> r;
        platforms[i].resize(r);
        for (int j = 0; j < r; ++j) {
            cin >> platforms[i][j];
        }
    }

    vector<int> state(n, 0);
    int count = 0;
    while (true) {
        int current = 0;
        while (current < n) {
            if (platforms[current].empty()) break;
            int next = platforms[current][state[current]];
            state[current] = (state[current] + 1) % platforms[current].size();
            current = next - 1;
        }
        count++;
        bool reset = true;
        for (int i = 0; i < n; ++i) {
            if (state[i] != 0) {
                reset = false;
                break;
            }
        }
        if (reset) break;
    }
    cout << count << endl;
    return 0;
}
```

### 代码核心思想
1. **初始化**：读取每个平台的传送带信息，并初始化每个平台的传送带使用状态。
2. **模拟过程**：逐个模拟行李箱的传送路径，更新每个平台的传送带使用状态。
3. **复位检测**：每次模拟完成后，检查所有平台的传送带状态是否恢复到初始状态，如果是则输出当前处理的行李箱数量。

---
处理用时：13.92秒
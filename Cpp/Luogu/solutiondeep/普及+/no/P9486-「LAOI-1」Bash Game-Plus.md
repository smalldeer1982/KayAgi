# 题目信息

# 「LAOI-1」Bash Game-Plus

## 题目描述

>巴什博弈：有一堆 $n$ 个物品，两名玩家轮流从中拿取物品。每次至少拿 $1$ 个，至多拿 $m$ 个，不能不拿，最终将物品拿完者获胜。

我们给这个游戏增加一些规则：

有一堆 $n$ 个物品，甲和乙轮流从中拿取物品，甲先拿。每次至少拿 $1$ 个，至多拿 $m$ 个，最终将物品拿完者获胜。    
现在新加入一条规则：**也可以不拿**，但每当有一名玩家选择不拿物品时，接下来的 $k$ 次操作中两名玩家都不可以不拿。

举个例子，当 $k=3$ 时，如果甲在某一次操作中没有拿物品，那么接下来乙、甲、乙三轮都必须拿至少 $1$ 件物品。然后又轮到甲了，这次甲就可以再次选择不拿。

甲乙两人一共进行了 $t$ 次游戏。对于每次游戏，你需要告诉甲他有没有必胜策略。

## 说明/提示

| Subtask | 得分 | $t$ | $op$ | $n\le$ | $m\le$ | $k\le$ | 特殊性质 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| $0$ | $2$ | $100000$ | $1$ | $10^{18}$ | $10^{18}$ | $k=114514$ |  |
| $1$ | $2$ | $99994$ | $0$ | $10^{18}$ | $10^{18}$ | $k=1$ |  |
| $2$ | $9$ | $99995$ | $0$ | $10^{18}$ | $10^{18}$ | $3$ |  |
| $3$ | $5$ | $99996$ | $0$ | $10^{18}$ | $10^{18}$ | $k\ge n$ |  |
| $4$ | $10$ | $50$ | $0$ | $50$ | $50$ | $10^{18}$ |  |
| $5$ | $13$ | $99997$ | $0$ | $100$ | $100$ | $10^{18}$ |  |
| $6$ | $16$ | $99998$ | $0$ | $400$ | $400$ | $10^{18}$ | $A$ |
| $7$ | $10$ | $99999$ | $0$ | $5000$ | $5000$ | $10^{18}$ |  |
| $8$ | $31$ | $100000$ | $0$ | $10^{18}$ | $10^{18}$ | $10^{18}$ |  |
| $9$ | ~~45~~ $2$ | $99993$ | $0$ | $10^{18}$ | $10^{18}$ | $10^{18}$ | 不可以，总司令 |

特殊性质 $A$ ：所有 $m$ 相等。

对于所有数据：$t\le10^5$，$1\le n,m,k\le10^{18}$

不保证数据随机。

## 样例 #1

### 输入

```
6 0
2 2 2
3 2 2
4 2 2
7 2 3
13 2 6
14 2 6```

### 输出

```
Yes
Yes
No
Yes
Yes
No```

## 样例 #2

### 输入

```
6 0
4 3 2
5 3 3
13 3 5
13 3 6
5 100 1000000000000
123454204 4321 97```

### 输出

```
Yes
No
Yes
No
Yes
No```

# AI分析结果

### 算法分类
数学

### 综合分析与结论
该题目是巴什博弈的变种，增加了“可以不拿”的规则，并且在不拿后会有一定的限制。题解通过动态规划和数学分析相结合的方式，找出了问题的规律，并给出了高效的解决方案。核心思路是通过观察和打表发现状态转移的周期性，进而将问题转化为数学上的模运算问题，最终实现了O(1)时间复杂度的查询。

### 所选题解
#### 题解作者：VinstaG173 (赞：3)
- **星级**: 4星
- **关键亮点**: 
  - 通过动态规划和数学分析相结合，找出了状态转移的周期性。
  - 提出了加强结论，并通过打表验证了结论的正确性。
  - 最终实现了O(1)时间复杂度的查询，极大优化了算法效率。
- **个人心得**: 
  - 通过打表找规律，发现状态转移的周期性，这是解决问题的关键。
  - 强调了对边界条件的处理，特别是对特判情况的考虑。

### 核心代码实现
```cpp
bool solve(long long n, long long m, long long k) {
    if (k == 1) {
        return n % (m + 1) != 0;
    }
    long long c = (m + 1) * (k / 2) + 1;
    long long n0 = n % c;
    if (n0 == 0) {
        return false;
    }
    if (n0 % (m + 1) == 1 && (n0 - 1) / (m + 1) > k / 2) {
        return false;
    }
    return true;
}
```
- **核心实现思想**: 
  - 首先处理特判情况，当k=1时，直接判断n是否整除(m+1)。
  - 计算循环周期c，并将n取模得到n0。
  - 根据加强结论判断n0是否满足必败条件，若不满足则返回必胜。

### 拓展思路
- 类似题目：可以进一步研究其他博弈论问题，如Nim游戏、斐波那契博弈等，理解其背后的数学规律。
- 算法优化：在解决类似问题时，可以通过打表找规律，结合数学分析，优化算法效率。

### 推荐题目
1. [P1247 取火柴游戏](https://www.luogu.com.cn/problem/P1247)
2. [P1288 取数游戏 II](https://www.luogu.com.cn/problem/P1288)
3. [P1290 欧几里德的游戏](https://www.luogu.com.cn/problem/P1290)

---
处理用时：16.32秒
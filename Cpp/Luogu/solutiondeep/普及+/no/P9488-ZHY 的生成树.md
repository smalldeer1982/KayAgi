# 题目信息

# ZHY 的生成树

## 题目描述

ZHY 有一个 $n$ 个点的完全图，点 $u$ 与点 $v$ 的距离为 $\gcd(u,v)$，求这个完全图的最大生成树的边权之和。

## 说明/提示

**本题采用捆绑测试。**

$\text{Subtask}$ $0\kern{3pt}$(10pts)：$n\le 5$。

$\text{Subtask}$ $1\kern{3pt}$(20pts)：$n\le 1000$。

$\text{Subtask}$ $2\kern{3pt}$(30pts)：$n\le 10^{6}$。

$\text{Subtask}$ $3\kern{3pt}$(40pts)：$n\le 10^{7}$。

对于所有测试数据，$1\le n \le 10^{7}$。

## 样例 #1

### 输入

```
4```

### 输出

```
4```

## 样例 #2

### 输入

```
30```

### 输出

```
183```

## 样例 #3

### 输入

```
100```

### 输出

```
1916```

# AI分析结果

### 算法分类
并查集、数学、图论

### 综合分析与结论
题目要求在一个完全图中构建最大生成树，边的权重为两个节点的最大公约数（GCD）。由于数据规模较大（$n \leq 10^7$），直接使用Kruskal算法会超时。因此，题解大多采用并查集结合数学优化的思路，通过枚举GCD值并连接其倍数节点，避免重复计算，从而在合理时间内完成计算。

### 所选高星题解
1. **题解作者：封禁用户 (赞：16)**  
   - **星级：5星**  
   - **关键亮点**：  
     - 从大到小枚举GCD值，利用并查集连接节点，确保生成树的最大边权。
     - 通过质数倍数的优化，减少不必要的连接操作，时间复杂度为$O(n \log \log n \alpha(n))$。
     - 思路清晰，代码简洁，优化到位。
   - **核心代码**：
     ```cpp
     for (int i = n / 2; i >= 1; --i) {
         for (int u = 1; prime[u] * i <= n; ++u) {
             int x = find(i), y = find(prime[u] * i);
             if (x != y) {
                 sum += i;
                 fa[y] = x;
             }
         }
     }
     ```
   - **个人心得**：通过质数倍数的优化，避免了重复连接，大大减少了计算量。

2. **题解作者：fuqingchen (赞：12)**  
   - **星级：4星**  
   - **关键亮点**：  
     - 使用欧拉筛预处理质数，优化连接操作。
     - 从$n/2$开始枚举，减少不必要的计算。
     - 代码结构清晰，易于理解。
   - **核心代码**：
     ```cpp
     for (int i = n / 2; i >= 1; --i) {
         for (int j = 1; prime[j] * i <= n; ++j) {
             int x = find(i), y = find(prime[j] * i);
             if (x != y) {
                 sum += i;
                 fa[y] = x;
             }
         }
     }
     ```
   - **个人心得**：通过欧拉筛预处理质数，减少了连接操作的复杂度。

3. **题解作者：柠檬布丁吖 (赞：7)**  
   - **星级：4星**  
   - **关键亮点**：  
     - 通过质数倍数的优化，减少了连接操作的复杂度。
     - 从$n/2$开始枚举，减少不必要的计算。
     - 代码结构清晰，易于理解。
   - **核心代码**：
     ```cpp
     for (int i = num / 2; i >= 2; i--) {
         for (int j = 1; primes[j] <= num / i; j++) {
             bool connected = unite(i, i * primes[j]);
             if (connected) {
                 answer += (ll)i;
                 --total;
             }
         }
     }
     ```
   - **个人心得**：通过质数倍数的优化，避免了重复连接，大大减少了计算量。

### 最优关键思路或技巧
1. **从大到小枚举GCD值**：确保每次连接的边权最大，符合最大生成树的要求。
2. **质数倍数的优化**：通过只连接质数倍数的节点，避免重复连接，减少计算量。
3. **并查集优化**：使用路径压缩和按秩合并，提高并查集的效率。

### 可拓展之处
- **同类型题**：类似的最大生成树问题，可以通过枚举边权并优化连接操作来解决。
- **算法套路**：并查集结合数学优化，适用于处理大规模数据的图论问题。

### 推荐题目
1. [P3366 【模板】最小生成树](https://www.luogu.com.cn/problem/P3366)
2. [P1546 最短网络](https://www.luogu.com.cn/problem/P1546)
3. [P1991 无线通讯网](https://www.luogu.com.cn/problem/P1991)

---
处理用时：24.87秒
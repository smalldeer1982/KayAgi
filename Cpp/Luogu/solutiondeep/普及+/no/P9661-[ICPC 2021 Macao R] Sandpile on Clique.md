# 题目信息

# [ICPC 2021 Macao R] Sandpile on Clique

## 题目描述

阿贝尔沙堆模型（Abelian Sandpile Model）是一个著名的显示自组织临界性的动力学系统。自从它由 Per Bak、Chao Tang 和 Kurt Wiesenfeld 在 1987 年的一篇论文中引入以来，它已经被研究了数十年。沙堆模型的预测引起了物理学、计算机科学和数学的广泛关注，这不仅是因为它美丽的代数结构，还因为它与负载平衡和内部扩散有关的模型的应用，如去随机化。沙堆模型与许多其他模型和物理现象相关，如转子路由模型、雪崩模型。

在沙堆模型中，给定一个顶点编号从 $1$ 到 $n$ 的无向图 $G$。我们还给出了 $n$ 个整数 $a_1, a_2, \cdots, a_n$，其中 $a_i$ 表示初始时放置在顶点 $i$ 上的筹码数量。每个回合，我们将选择一个任意的顶点 $v$，使得 $v$ 上的筹码数量不小于与 $v$ 相连的边数，记为 $d_v$。对于 $v$ 的每个邻居，它将从 $v$ 接收一枚筹码。因此，$v$ 将失去 $d_v$ 枚筹码。这个过程被称为 ``firing`` 或 ``toppling``。直到没有顶点 $v$ 至少有 $d_v$ 枚筹码时，firing 才会停止。

可以证明，firing 的顺序不会影响结果。同时，也可能 firing 永远不会终止。这种情况被描述为“recurrent”。现在给定一个团和初始筹码数量，请确定这个实例是否是一个 recurrent 实例。如果不是，请分别输出每个节点的最终筹码数量。

团（也称为完全图）是一个图，其中任意两个顶点都有边相连。

## 样例 #1

### 输入

```
5
5 0 3 0 3```

### 输出

```
3 3 1 3 1```

## 样例 #2

### 输入

```
2
1 0```

### 输出

```
Recurrent```

# AI分析结果

### 算法分类
模拟

### 综合分析与结论
该题的核心是模拟沙堆模型的操作过程，判断是否能够无限进行下去（Recurrent），或者输出最终每个节点的筹码数量。所有题解都采用了模拟的思路，但实现方式有所不同，主要区别在于如何高效地找到当前最大值的节点以及如何处理筹码的分配。

### 所选高星题解
1. **作者：HFanGDoDM (5星)**
   - **关键亮点**：使用线段树维护全局最大值和区间加操作，确保每次操作的时间复杂度为O(log n)，整体时间复杂度为O(n log n)。思路清晰，代码结构合理，优化程度高。
   - **核心代码**：
     ```cpp
     sgt.Build(1,1,n);
     for(i=1;i<=n-1;i++){
         long long val=sgt.MaxAll().first,pos=sgt.MaxAll().second;
         if(pos>1) sgt.AddInterval(1,1,pos-1,val/(n-1));
         if(pos<n) sgt.AddInterval(1,pos+1,n,val/(n-1));
         sgt.AddInterval(1,pos,pos,-(val/(n-1)*(n-1)));
     }
     if(sgt.MaxAll().first>=n-1) printf("Recurrent");
     else for(i=1;i<=n;i++) printf("%lld ",sgt.MaxInterval(1,i,i).first);
     ```
   - **个人心得**：通过线段树的懒标记机制，大大减少了模拟过程中的时间复杂度，确保了算法的高效性。

2. **作者：__HHX__ (4星)**
   - **关键亮点**：使用优先队列和差分思想，避免了每次操作后对所有节点的更新，优化了时间复杂度。思路简洁，代码易读。
   - **核心代码**：
     ```cpp
     priority_queue< pair<long long, int> > p;
     long long d;
     for(int i = 1; i <= n; i++) {
         pair<long long, int> tmp = p.top();
         long long s = tmp.first + d;
         d += s / (n - 1);
         if (s < n - 1) { Print(); return 0; }
         p.pop();
         p.push({s % (n - 1) - d, tmp.second});
     }
     ```
   - **个人心得**：通过差分思想，减少了每次操作后的更新次数，提高了算法的效率。

3. **作者：naroto2022 (4星)**
   - **关键亮点**：优先队列模拟操作，通过预处理判断是否Recurrent，思路清晰，代码简洁。
   - **核心代码**：
     ```cpp
     priority_queue<pll> q;
     while(q.top().first+cnt>=n-1){
         pll tmp=q.top();q.pop();cnt++;
         q.push({tmp.first-n,tmp.second});
     }
     ```
   - **个人心得**：通过优先队列和预处理，简化了模拟过程，提高了代码的可读性和执行效率。

### 最优关键思路或技巧
1. **线段树维护最大值和区间加**：通过线段树高效地维护全局最大值和区间加操作，确保每次操作的时间复杂度为O(log n)。
2. **优先队列与差分思想**：使用优先队列快速找到当前最大值，并通过差分思想减少更新次数，优化时间复杂度。
3. **预处理判断Recurrent**：通过预处理判断是否Recurrent，避免不必要的模拟操作，提高算法效率。

### 可拓展之处
1. **类似模拟问题**：可以应用于其他需要高效模拟操作的场景，如负载均衡、资源分配等。
2. **数据结构优化**：在需要频繁查询最大值和区间更新的问题中，线段树和优先队列是非常有效的工具。

### 推荐题目
1. [P3372 【模板】线段树 1](https://www.luogu.com.cn/problem/P3372)
2. [P3373 【模板】线段树 2](https://www.luogu.com.cn/problem/P3373)
3. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)

---
处理用时：22.77秒
# 题目信息

# [ICPC 2022 Jinan R] Frozen Scoreboard

## 题目描述

2000 年以前的秦朝，曾举办过一次 ICPC 比赛。比赛中有 $m$ 道题，$n$ 个团队。我们知道每个队完成了多少道题以及其历史记录的总用时。这些称作该团队的结果，但是我们不知道他们每道题是否完成、用时多久。

最近，我们发现了每个队**冻结的计分板**。从该计分板上，我们可以看到每个队在比赛中的提交情况，但是不知道在最后一小时内提交的判分。一些人发现，对于一些队来说，他们冻结的计分板可能与他们在历史记录中的最终成绩相矛盾。

请根据最终得分和冻结的计分板，为各队创建一个与其最终结果和冻结的计分板一致的最终计分板。

按照以下规则来计算计分板和总分：

对于给定的队伍 $i$，它**最终的计分板**是一个 $m$ 元数组，其中第 $j$ 个元素给出队伍 $i$ 在第 $j$ 题上的提交信息。

- 如果队伍 $i$ 没有提交问题 $j$，输出 ```.```。

- 如果队伍 $i$ 对问题 $j$ 提交了 $x$ 次但均未通过，输出 $-x$。

- 否则，考虑队伍 $i$ 在问题 $j$ 的所有评测结果。每次提交都有一个提交时间，设第一个通过的评测是第 $x$ 次评测，在第 $y$ 分钟时提交。输出 $+x/y$，其中 $0\leq y\leq299$。

在最终计分板上，只考虑第一次通过的提交。同一分钟内可能有多次提交。

一个队伍的最终得分是该队伍完成了多少道题，即该队最终计分板上 ```+``` 的个数。

一个队伍总用时按如下方式计算。如果队伍 $i$ 在第 $y$ 分钟完成了第 $j$ 道题，在完成前有 $x-1$ 次失败的提交（即最终计分板上第 $j$ 个问题的数为 $+x/y$），该问题的用时记为 $20(x-1)+y$。 如果队伍 $i$ 没有完成第 $j$ 道题，该问题的用时记为 $0$，无论是否提交过。队伍 $i$ 的总时间是每道题用时的总和。

## 样例 #1

### 输入

```
1 13
7 951
+ 1/6
? 3 4
+ 4/183
- 2
+ 3/217
.
.
.
+ 2/29
+ 1/91
.
+ 1/22
.```

### 输出

```
Yes
+ 1/6
+ 2/263
+ 4/183
- 2
+ 3/217
.
.
.
+ 2/29
+ 1/91
.
+ 1/22
.```

## 样例 #2

### 输入

```
6 2
1 100
.
? 3 4
2 100
+ 1/1
+ 1/2
0 0
- 5
- 6
2 480
? 100 100
? 100 100
2 480
? 99 100
? 100 100
1 2000
? 100 100
? 100 100```

### 输出

```
No
No
Yes
- 5
- 6
Yes
+ 1/240
+ 1/240
No
Yes
+ 87/280
- 100```

# AI分析结果

### 算法分类
模拟

### 综合分析与结论
该题目主要考察对ICPC比赛计分规则的模拟能力，核心在于根据冻结的计分板和最终成绩，推断出可能的最终计分板。题解的关键在于处理不确定的提交（`?`），并通过枚举和贪心策略来分配时间，确保总用时和完成题目数符合要求。

### 所选题解
1. **作者：Field_Mouse (4星)**
   - **关键亮点**：通过枚举所有可能的通过题目组合，并贪心地分配时间，确保总用时和完成题目数符合要求。代码结构清晰，注释详细，易于理解。
   - **核心实现思想**：枚举所有可能的通过题目组合，计算每种组合的最小和最大用时，判断是否满足总用时要求，然后贪心地分配时间。
   - **代码片段**：
     ```cpp
     for(int i=0;i<(1<<T);++i) {
         int ncnt=cnt,maxn=tims,minn=tims;
         for(int j=0;j<T;++j) {
             if((i>>j)&1) {
                 ++ncnt;
                 minn+=240+20*(kn[yiw[j]].y-kn[yiw[j]].x);
                 maxn+=299+20*(kn[yiw[j]].y-1);
             }
         }
         if(ncnt==a&&minn<=b&&b<=maxn) {
             flag=1;
             b-=minn;
             for(int j=0;j<T;++j) {
                 if((i>>j)^1)ans[yiw[j]].opt='-',ans[yiw[j]].y=kn[yiw[j]].y;
                 if((i>>j)&1) {
                     ans[yiw[j]].opt='+';
                     int l=240+20*(kn[yiw[j]].y-kn[yiw[j]].x);
                     int r=299+20*(kn[yiw[j]].y-1);
                     if(b>=r-l) {
                         b-=r-l;
                         ans[yiw[j]].x=kn[yiw[j]].y;
                         ans[yiw[j]].y=299;
                     } else if(!b) {
                         ans[yiw[j]].x=kn[yiw[j]].y-kn[yiw[j]].x+1;
                         ans[yiw[j]].y=240;
                     } else {
                         for(int k=0;k<kn[yiw[j]].x;++k) {
                             int now=b-k*20;
                             if(0<=now&&now<=59) {
                                 ans[yiw[j]].x=kn[yiw[j]].y-kn[yiw[j]].x+k+1;
                                 ans[yiw[j]].y=240+now;
                                 b=0;
                                 break;
                             }
                         }
                     }
                 }
             }
         }
     }
     ```

2. **作者：Tsumugi_Mirai (4星)**
   - **关键亮点**：同样采用枚举和贪心策略，但代码实现更为简洁，直接通过位运算枚举所有可能的通过题目组合，并贪心地分配时间。
   - **核心实现思想**：枚举所有可能的通过题目组合，计算每种组合的最小和最大用时，判断是否满足总用时要求，然后贪心地分配时间。
   - **代码片段**：
     ```cpp
     for (int i = 0; i < (1 << m); i++) {
         int splt = team[p].nplt, mplt = team[p].nplt;
         int cot = 0;
         for (int j = 0; j < m; j++) {
             if (((i >> j) & 1) && team[p].c[j + 1] == '?') {
                 cot++;
                 splt += (team[p].tries[j + 1] - team[p].extr[j + 1]) * 20;
                 splt += 240;
                 mplt += (team[p].tries[j + 1] - 1) * 20;
                 mplt += 299;
             }
         }
         if (cot + team[p].nsor != team[p].sor)
             continue;
         int dis = team[p].plt - splt;
         if (dis >= 0 && mplt >= team[p].plt) {
             team[p].check = 1;
             for (int j = 0; j < m; j++) {
                 if (((i >> j) & 1) && team[p].c[j + 1] == '?') {
                     team[p].c[j + 1] = '+';
                     int add = dis / 20;
                     if (add > team[p].extr[j + 1] - 1) {
                         dis -= (team[p].extr[j + 1] - 1) * 20;
                     } else {
                         dis -= add * 20;
                         team[p].tries[j + 1] -= (team[p].extr[j + 1] - add - 1);
                     }
                     if (dis > 59) {
                         dis -= 59;
                         team[p].time[j + 1] = 299;
                     } else {
                         team[p].time[j + 1] = 240 + dis;
                         dis = 0;
                     }
                 }
             }
             return;
         }
     }
     ```

### 最优关键思路或技巧
- **枚举与贪心**：通过枚举所有可能的通过题目组合，计算每种组合的最小和最大用时，判断是否满足总用时要求，然后贪心地分配时间。
- **位运算**：利用位运算高效地枚举所有可能的通过题目组合。

### 可拓展之处
- 类似题目可以考察其他比赛计分规则的模拟，如ACM、IOI等。
- 可以扩展到更复杂的计分规则，如不同题目的权重不同，或者有额外的奖励机制。

### 推荐题目
1. [P1003 铺地毯](https://www.luogu.com.cn/problem/P1003)
2. [P1047 校门外的树](https://www.luogu.com.cn/problem/P1047)
3. [P1056 排座椅](https://www.luogu.com.cn/problem/P1056)

### 个人心得摘录
- **Field_Mouse**：通过枚举和贪心策略，确保总用时和完成题目数符合要求，代码结构清晰，注释详细，易于理解。
- **Tsumugi_Mirai**：代码实现简洁，直接通过位运算枚举所有可能的通过题目组合，并贪心地分配时间，效率较高。

---
处理用时：34.66秒
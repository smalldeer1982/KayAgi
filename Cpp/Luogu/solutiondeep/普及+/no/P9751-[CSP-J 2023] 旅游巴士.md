# 题目信息

# [CSP-J 2023] 旅游巴士

## 题目描述

小 Z 打算在国庆假期期间搭乘旅游巴士去一处他向往已久的景点旅游。

旅游景点的地图共有 $n$ 处地点，在这些地点之间连有 $m$ 条道路。其中 $1$ 号地点为景区入口，$n$ 号地点为景区出口。我们把一天当中景区开门营业的时间记为 $0$ 时刻，则从 $0$ 时刻起，每间隔 $k$ 单位时间便有一辆旅游巴士到达景区入口，同时有一辆旅游巴士从景区出口驶离景区。

所有道路均只能**单向通行**。对于每条道路，游客步行通过的用时均为恰好 $1$ 单位时间。

小 Z 希望乘坐旅游巴士到达景区入口，并沿着自己选择的任意路径走到景区出口，再乘坐旅游巴士离开，这意味着他到达和离开景区的时间都必须是 **$k$ 的非负整数倍**。由于节假日客流众多，**小 Z 在旅游巴士离开景区前只想一直沿着景区道路移动，而不想在任何地点（包括景区入口和出口）或者道路上停留**。

出发前，小 Z 忽然得知：景区采取了限制客流的方法，对于每条道路均设置了一个
“开放时间”$a _ i$，游客只有**不早于 $a _ i$ 时刻**才能通过这条道路。

请帮助小 Z 设计一个旅游方案，使得他乘坐旅游巴士离开景区的时间尽量地早。

## 说明/提示

**【样例 #1 解释】**

小 Z 可以在 $3$ 时刻到达景区入口，沿 $1 \to 3 \to 4 \to 5$ 的顺序走到景区出口，并在 $6$ 时刻离开。

**【样例 #2】**

见附件中的 `bus/bus2.in` 与 `bus/bus2.ans`。

**【数据范围】**

对于所有测试数据有：$2 \leq n \leq 10 ^ 4$，$1 \leq m \leq 2 \times 10 ^ 4$，$1 \leq k \leq 100$，$1 \leq u _ i, v _ i \leq n$，$0 \leq a _ i \leq 10 ^ 6$。

| 测试点编号 | $n \leq$ | $m \leq$ | $k \leq$ | 特殊性质 |
|:-:|:-:|:-:|:-:|:-:|
| $1 \sim 2$ | $10$ |$15$ | $100$ | $a _ i = 0$ |
| $3 \sim 5$ | $10$ | $15$ | $100$ | 无 |
| $6 \sim 7$ | $10 ^ 4$ | $2 \times 10 ^ 4$ | $1$ | $a _ i = 0$ |
| $8 \sim 10$ | $10 ^ 4$ | $2 \times 10 ^ 4$ | $1$ | 无 |
| $11 \sim 13$ | $10 ^ 4$ | $2 \times 10 ^ 4$ | $100$ | $a _ i = 0$ |
| $14 \sim 15$ | $10 ^ 4$ | $2 \times 10 ^ 4$ | $100$ | $u _ i \leq v _ i$ |
| $16 \sim 20$ | $10 ^ 4$ | $2 \times 10 ^ 4$ | $100$ | 无 |

## 样例 #1

### 输入

```
5 5 3
1 2 0
2 5 1
1 3 0
3 4 3
4 5 1```

### 输出

```
6```

# AI分析结果

### 算法分类
**最短路**

### 综合分析与结论
该题目要求找到从景区入口到出口的最早离开时间，且路径上的每条边都有开放时间的限制。由于每条边的通过时间固定为1，且出发和离开时间必须是k的倍数，因此可以将问题转化为在分层图中寻找最短路的问题。具体来说，可以将每个节点拆分为k个状态，表示到达该节点时的时间模k的值，然后通过Dijkstra算法或BFS来求解最短路径。

### 所选高星题解

#### 题解1：Genius_Star (5星)
**关键亮点**：
- 使用了分层图的思想，将每个节点拆分为k个状态，表示到达该节点时的时间模k的值。
- 通过Dijkstra算法进行状态转移，确保每次转移都满足边的开放时间限制。
- 代码清晰，逻辑严谨，时间复杂度为O(nk log n)，效率较高。

**核心代码**：
```cpp
void dijkstra(ll s){
    dis[s][0]=0;
    q.push({0,s});
    while(!q.empty()){
        ll u=q.top().second,p=q.top().first;
        q.pop();
        if(f[u][p%k])
          continue;
        f[u][p%k]=1;
        for(auto d:E[u]){
            ll v=d.first,w=d.second,t=(p+1)%k;
            if(p>=w)
              t=p;
            else
              t=((w-p+k-1)/k)*k+p;
            if(dis[v][(t+1)%k]>t+1){
                dis[v][(t+1)%k]=t+1;
                q.push({t+1,v});
            }
        }
    }
}
```
**核心思想**：通过Dijkstra算法在分层图中进行状态转移，确保每次转移都满足边的开放时间限制。

#### 题解2：OMG_wc (4星)
**关键亮点**：
- 同样使用了分层图的思想，通过BFS进行状态转移。
- 对于边的开放时间限制，通过等待k的倍数时间来满足条件。
- 代码简洁，易于理解，时间复杂度为O(nk log nk)。

**核心代码**：
```cpp
while (q.size()) {
    int u = q.top().u, i = q.top().i;
    q.pop();
    if (vis[u][i]) continue;
    vis[u][i] = 1;
    for (auto [v, w] : G[u]) {
        int t = d[u][i], j = (i + 1) % kk;
        if (t < w) t += (w - t + kk - 1) / kk * kk;
        if (d[v][j] > t + 1) q.push({v, j, d[v][j] = t + 1});
    }
}
```
**核心思想**：通过BFS在分层图中进行状态转移，确保每次转移都满足边的开放时间限制。

#### 题解3：WaterSun (4星)
**关键亮点**：
- 使用了分层图的思想，通过Dijkstra算法进行状态转移。
- 对于边的开放时间限制，通过等待k的倍数时间来满足条件。
- 代码清晰，逻辑严谨，时间复杂度为O(nk log n)。

**核心代码**：
```cpp
inline void dijkstra(int s){
    priority_queue<pii,vector<pii>,greater<pii>> q;
    d[s][0] = 0;
    q.push({0,s});
    while (!q.empty()){
        pii t = q.top();
        q.pop();
        int dist = t.fst % k;
        if (vis[t.snd][dist]) continue;
        vis[t.snd][dist] = true;
        for (re int i = h[t.snd];~i;i = ne[i]){
            int j = e[i],lim = w[i];
            int ndist = (dist + 1) % k,ntim = get(t.fst,lim) + 1;
            if (d[j][ndist] > ntim){
                d[j][ndist] = ntim;
                q.push({d[j][ndist],j});
            }
        }
    }
}
```
**核心思想**：通过Dijkstra算法在分层图中进行状态转移，确保每次转移都满足边的开放时间限制。

### 最优关键思路或技巧
- **分层图**：将每个节点拆分为k个状态，表示到达该节点时的时间模k的值，从而将问题转化为在分层图中寻找最短路的问题。
- **Dijkstra算法**：在分层图中使用Dijkstra算法进行状态转移，确保每次转移都满足边的开放时间限制。
- **等待时间计算**：对于边的开放时间限制，通过等待k的倍数时间来满足条件，确保路径的合法性。

### 可拓展之处
- 类似的问题可以扩展到其他有边权限制的最短路问题，如时间窗口限制、资源限制等。
- 分层图的思想可以应用于其他需要状态转移的图论问题，如带限制的路径计数、最短路径等。

### 推荐题目
1. [P1144 最短路计数](https://www.luogu.com.cn/problem/P1144)
2. [P1608 路径统计](https://www.luogu.com.cn/problem/P1608)
3. [P4779 【模板】单源最短路径（标准版）](https://www.luogu.com.cn/problem/P4779)

### 个人心得摘录
- **Genius_Star**：通过分层图的思想，将问题转化为在分层图中寻找最短路的问题，确保了每次转移都满足边的开放时间限制。
- **OMG_wc**：对于边的开放时间限制，通过等待k的倍数时间来满足条件，确保了路径的合法性。
- **WaterSun**：通过Dijkstra算法在分层图中进行状态转移，确保了每次转移都满足边的开放时间限制。

---
处理用时：34.22秒
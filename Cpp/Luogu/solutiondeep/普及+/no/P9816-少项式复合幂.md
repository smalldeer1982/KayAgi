# 题目信息

# 少项式复合幂

## 题目背景

> I have won everything except your heart.

终于，小 Z 可以玩一年原神了。但在此之前，他决定做出这道题，以纪念自己对【数据删除】的感情。

## 题目描述

给定多项式 $f(x)=\sum_{i=1}^ma_ix^{b_i}$。定义 $f_1(x)=f(x)$，$f_n(x)=f(f_{n-1}(x))$。

给定模数 $p$。有 $q$ 次询问，每次给出 $x,y$，查询 $f_y(x)\bmod p$ 的值。

**请注意 $m,p$ 的特殊数据范围。**

## 说明/提示

#### 样例解释

样例 1 中 $f(x)=3x^3+x+1$。以第 3 次询问为例，$f_1(10)=f(10)=3\times10^3+10+1=3011\equiv 29 \pmod {71}$。

#### 数据范围与约定

|测试点编号|$y$|$m$|$q$|特殊性质|
|:-:|:-:|:-:|:-:|:-:|
|$1\sim 3$|$\le 10$|$\le 20$|$\le 10^3$|无|
|$4\sim 7$|$\le 10^3$|$\le 20$|$\le 10^4$|无|
|$8,9$|$\le 10^7$|$\le 1$|$\le 3\times 10^5$|A|
|$10$|$\le 10^7$|$\le 1$|$\le 3\times 10^5$|无|
|$11,12$|$\le 10^7$|$\le 2$|$\le 10^5$|A、B|
|$13$|$\le 10^7$|$\le 2$|$\le 10^5$|B|
|$14\sim 16$|$\le 10^7$|$\le 20$|$\le 500$|无|
|$17\sim 20$|$\le 10^7$|$\le 20$|$\le 3\times 10^5$|无|
- 特殊性质 A：保证 $p$ 为质数。
- 特殊性质 B：保证 $b_i\le 1$。

对于所有数据，保证 $1\le m\le 20$，$0\le a_i,b_i\le 10^5$，$2\le p\le 10^5$，$1\le q\le 3\times 10^5$，$1\le x,y\le 10^7$。

## 样例 #1

### 输入

```
3 5 71
1 1
3 3
1 0
7 5
9 6
10 1
5 6
7 6```

### 输出

```
27
11
29
2
5```

# AI分析结果

### 算法分类
数学、递推、倍增

### 综合分析与结论
本题的核心在于高效计算多项式函数的多次复合幂，难点在于如何优化查询操作的时间复杂度。大多数题解都采用了倍增的思路，通过预处理每个 $x$ 的 $f(x) \bmod p$，并利用二进制分解将查询复杂度从 $O(qy)$ 优化到 $O(q \log y)$。具体实现上，预处理 $f(x) \bmod p$ 的复杂度为 $O(mp \log b_i)$，而查询时通过倍增表快速跳转，最终复杂度为 $O((p + q) \log y)$。

### 所选高分题解

#### 1. 作者：znszns (赞：15)
- **星级**: 5星
- **关键亮点**: 提供了35分和100分的两种解法，思路清晰，代码简洁，特别是100分做法中详细解释了倍增的预处理和查询操作。
- **核心代码**:
  ```cpp
  for(int j=1;j<M;j++) {
      for(int i=0;i<mod;i++) {
          f[i][j]=f[f[i][j-1]][j-1];
      }
  }
  ```
  **实现思想**: 预处理每个 $x$ 的 $f(x) \bmod p$，并通过倍增表 $f[i][j]$ 表示 $x$ 跳 $2^j$ 次后的结果。

#### 2. 作者：过氧化氢_syq0057 (赞：6)
- **星级**: 4星
- **关键亮点**: 详细解释了倍增的思路，并强调了预处理时 $p$ 的范围优化，代码结构清晰。
- **核心代码**:
  ```cpp
  for (int j=1; j<=23; j++)
      for (int i=0; i<mod; i++)
          f[i][j] = f[f[i][j - 1]][j - 1];
  ```
  **实现思想**: 通过预处理 $f[i][j]$ 表示 $x$ 跳 $2^j$ 次后的结果，查询时通过二进制分解快速跳转。

#### 3. 作者：_XHY20180718_ (赞：0)
- **星级**: 4星
- **关键亮点**: 提出了基环树森林的图论模型，并详细解释了倍增的实现，代码结构清晰。
- **核心代码**:
  ```cpp
  for(int i=1;i<=25;i++)
      for(int j=0;j<p;j++)
          f[j][i]=f[f[j][i-1]][i-1];
  ```
  **实现思想**: 通过预处理 $f[j][i]$ 表示 $x$ 跳 $2^i$ 次后的结果，查询时通过二进制分解快速跳转。

### 最优关键思路或技巧
- **倍增预处理**: 通过预处理每个 $x$ 的 $f(x) \bmod p$，并利用倍增表将查询复杂度从 $O(qy)$ 优化到 $O(q \log y)$。
- **模数优化**: 利用 $f(x) \equiv f(x \bmod p) \pmod p$ 的性质，将预处理范围缩小到 $0$ 到 $p-1$，减少计算量。

### 可拓展之处
- **类似问题**: 类似的多项式复合问题可以通过倍增或矩阵快速幂等方法来优化查询复杂度。
- **图论模型**: 将问题转化为基环树森林的图论模型，可以进一步优化查询复杂度。

### 推荐题目
1. P3811 【模板】乘法逆元
2. P1226 【模板】快速幂
3. P3390 【模板】矩阵快速幂

---
处理用时：37.51秒
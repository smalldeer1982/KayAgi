# 题目信息

# [USACO05OPEN] Expedition G

## 题目描述

一群奶牛抢了一辆卡车决定前往树林里探险，但是由于它们的驾驶技术太糟，油箱在路上给弄破了，所以它们每前进一个单位的路程就会漏掉一个单位的油。

为了修好油箱，奶牛们必须前往最近的城市（不会超过 $10^6$ 单位路程）。  
在当前位置和城市之间有 $n$ 个加油站．奶牛可以在加油站加 $1$ 到 $100$ 单位的油。  

对于人来说，树林是个危险的地方；对奶牛来说，更是这样。  所以，奶牛要尽可能的少停站加油，幸运的是，这辆卡车的油箱非常大，你可以认为它的容量是无穷大的。  
卡车在离城 $l$ 个单位时还有 $p$ 个单位的油，你要算出奶牛们至少要停几站才能到城市，或者奶牛们根本到不了城市。

## 说明/提示

对于 $100\%$ 的数据，$1\leq n\leq 10^4$，$1\leq p\leq 1000000$。

## 样例 #1

### 输入

```
4
4 4
5 2
11 5
15 10
25 10
```

### 输出

```
2```

# AI分析结果

### 算法分类
贪心

### 综合分析与结论
本题的核心思路是通过贪心算法，利用优先队列（堆）来维护当前可以加油的加油站，每次选择油量最大的加油站进行加油，以减少停车次数。难点在于如何高效地选择加油站，并确保在油量不足时能够及时加油。所有题解都采用了类似的贪心策略，但实现细节和代码风格有所不同。

### 所选高星题解

#### 1. 作者：Glass_S (4星)
**关键亮点**：
- 详细解释了贪心策略的实现过程，代码结构清晰。
- 使用了优先队列来维护最大油量的加油站，优化了选择过程。
- 提供了详细的注释和思路说明，便于理解。

**核心代码**：
```cpp
priority_queue<int>q;
while(1) {
    l -= p;
    if(l <= 0) break;
    for(int i = tim; i <= n; i++) {
        if(a[i].local >= l && a[i].local <= l + p)
            q.push(a[i].hav);
        else {
            tim = i;
            break;
        }
    }
    p = q.top();
    q.pop();
    sum++;
    if(q.empty() && a[tim].local < (l - p)) {
        wr(-1), exit(0);
    }
}
```
**实现思想**：每次将油耗尽后，从当前可到达的加油站中选择油量最大的进行加油，直到到达终点或无法继续前进。

#### 2. 作者：zdoef (4星)
**关键亮点**：
- 代码简洁，逻辑清晰，使用了快读优化输入。
- 通过优先队列动态维护可加油的加油站，确保每次选择最优解。

**核心代码**：
```cpp
priority_queue<int> v;
for (int i = 1; i <= m; i++) {
    int ll = a[i].l - cnt;
    while (y < ll) {
        if(v.empty()) {
            cout << -1;
            return 0;
        }
        ans++, y += v.top();
        v.pop();
    }
    y -= ll, v.push(a[i].p);
    cnt = a[i].l;
}
```
**实现思想**：在油量不足时，从优先队列中选择油量最大的加油站进行加油，直到油量足够到达下一个加油站。

#### 3. 作者：CQ_Bob (4星)
**关键亮点**：
- 代码简洁，使用了优先队列来维护加油站油量。
- 通过贪心策略确保每次选择最优的加油站进行加油。

**核心代码**：
```cpp
priority_queue<int> qu;
for(re int i = 1; i <= n + 1; ++i) {
    if(a[i - 1].l - a[i].l > p) {
        while(!qu.empty() && p < a[i - 1].l - a[i].l)
            p += qu.top(), qu.pop(), ++ans;
        if(p < a[i - 1].l - a[i].l) {
            cout << "-1\n";
            return ;
        }
    }
    p -= (a[i - 1].l - a[i].l), qu.push(a[i].p);
}
```
**实现思想**：在油量不足时，从优先队列中选择油量最大的加油站进行加油，直到油量足够到达下一个加油站。

### 最优关键思路或技巧
- **贪心策略**：每次选择油量最大的加油站进行加油，以减少停车次数。
- **优先队列**：利用优先队列（堆）来高效维护当前可以加油的加油站，确保每次选择最优解。

### 可拓展之处
- 类似问题：如最短路径问题中的Dijkstra算法，也利用了优先队列来维护当前最优解。
- 其他应用：如任务调度、资源分配等问题，都可以通过贪心策略和优先队列来优化。

### 推荐题目
1. [P1090 合并果子](https://www.luogu.com.cn/problem/P1090)
2. [P1168 中位数](https://www.luogu.com.cn/problem/P1168)
3. [P3378 【模板】堆](https://www.luogu.com.cn/problem/P3378)

### 个人心得摘录
- **Glass_S**：通过优先队列维护最大油量的加油站，确保每次选择最优解，减少了停车次数。
- **zdoef**：代码简洁，逻辑清晰，通过优先队列动态维护可加油的加油站，确保每次选择最优解。
- **CQ_Bob**：代码简洁，使用了优先队列来维护加油站油量，通过贪心策略确保每次选择最优的加油站进行加油。

---
处理用时：23.32秒
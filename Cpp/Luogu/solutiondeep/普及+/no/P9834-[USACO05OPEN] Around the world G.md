# 题目信息

# [USACO05OPEN] Around the world G

## 题目描述

这些年，农夫约翰在国际上交了一大批开农场的朋友。由于他有一段时间没有去见过英国的农夫泰德和荷兰的农夫波尔，所以他想去拜访他们。

他知道每个朋友的农场的经度（是一个从 $0$ 到 $359$ 的整数，我们把地球看成一个圆，经度在此圆上顺时针方向递增）。  

农夫约翰打算乘飞机去拜访他的 $n$ 个朋友（用 $1$ 到 $n$ 来表示）。他知道在这些农场之间有 $m$ 条双向的航线。飞机是沿着地面上最短的路径飞行的（就是圆上的最短弧长）。两个农场之间的航线一定是最短的。

保证如果有两个农场在直径两端，那么它们之间一定不会被某条航线直接连接。

所以任何一次航行都可以被描述成顺时针或是逆时针的．比如说，经度 $30$ 到经度 $35$ 是顺时针的，经度 $350$ 到经度 $10$ 也是顺时针的，而经度 $350$ 到经度 $200$ 是逆时针的。

农夫约翰为了耍酷，决定要经过几个朋友的农场做到环球旅行，他想知道这是否可能，如果可能最少要乘几次飞机。

他想在他最好的朋友（即输入中的第一个）的农场上开始和结束这次旅行。为了保证这是一次环球航行，结束旅行，顺时针经过的路程不能等于逆时针经过的路程。

## 说明/提示

对于 $100\%$ 的数据，$1 \leq n \leq 5 \times 10^3$，$1 \leq m \leq 2.5 \times 10^4$。

## 样例 #1

### 输入

```
3 3
0
120
240
1 2
2 3
1 3
```

### 输出

```
3```

# AI分析结果

### 算法分类
广度优先搜索 BFS

### 综合分析与结论
本题的核心在于寻找一条从起点出发并回到起点的路径，且该路径的顺时针和逆时针路程不相等，且总路程大于等于360度。由于需要找到最短的飞行次数，BFS是一个合适的选择，因为它能够按层遍历，确保找到的路径是最短的。

### 所选题解
#### 题解：Arson1st
- **星级**：4星
- **关键亮点**：
  - 使用BFS进行搜索，确保找到的路径是最短的。
  - 通过哈希表存储状态，避免重复搜索，优化了时间复杂度。
  - 处理跨子午线的经度差时，进行了特判，确保计算的准确性。
- **个人心得**：
  - 作者提到“搜索的复杂度一直是玄学”，但实际上通过合理的状态存储和剪枝，复杂度可以控制在可接受范围内。

### 核心代码片段
```cpp
int BFS() {
    node st = {1, 0}; que.push({st, 0}); vis[st] = 1;
    while (!que.empty()) {
        Node now = que.front(); que.pop();
        int u = now.x.u, sta = now.x.w, dis = now.d;
        for (int i = h[u]; i; i = ne[i]) {
            int v = e[i];
            if (v == 1 && sta + w[i] >= 360) return dis+1;
            node tmp = {v, sta + w[i]};
            if (vis[tmp]) continue;
            que.push({tmp, dis+1}); vis[tmp] = 1;
        }
    }
    return -1;
}
```
- **核心实现思想**：从起点开始，使用BFS遍历所有可能的路径，通过哈希表记录每个状态，避免重复搜索。当回到起点且总路程大于等于360度时，返回当前路径的飞行次数。

### 可拓展之处
- 类似的问题可以扩展到其他图论问题，如寻找最短路径、环路检测等。
- 可以进一步优化状态存储，使用更高效的数据结构如unordered_map来提升性能。

### 推荐题目
1. [P1144 最短路计数](https://www.luogu.com.cn/problem/P1144)
2. [P2865 [USACO06NOV]Roadblocks G](https://www.luogu.com.cn/problem/P2865)
3. [P2935 [USACO09JAN]Best Spot S](https://www.luogu.com.cn/problem/P2935)

---
处理用时：14.01秒
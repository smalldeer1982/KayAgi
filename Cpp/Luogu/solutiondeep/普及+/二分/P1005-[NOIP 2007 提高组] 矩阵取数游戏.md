# 题目信息

# [NOIP 2007 提高组] 矩阵取数游戏

## 题目描述

帅帅经常跟同学玩一个矩阵取数游戏：对于一个给定的 $n \times m$ 的矩阵，矩阵中的每个元素 $a_{i,j}$ 均为非负整数。游戏规则如下：

1. 每次取数时须从每行各取走一个元素，共 $n$ 个。经过 $m$ 次后取完矩阵内所有元素；
2. 每次取走的各个元素只能是该元素所在行的行首或行尾；
3. 每次取数都有一个得分值，为每行取数的得分之和，每行取数的得分 = 被取走的元素值 $\times 2^i$，其中 $i$ 表示第 $i$ 次取数（从 $1$ 开始编号）；
4. 游戏结束总得分为 $m$ 次取数得分之和。

帅帅想请你帮忙写一个程序，对于任意矩阵，可以求出取数后的最大得分。


## 说明/提示

**【数据范围】**

对于 $60\%$ 的数据，满足 $1\le n,m\le 30$，答案不超过 $10^{16}$。  
对于 $100\%$ 的数据，满足 $1\le n,m\le 80$，$0\le a_{i,j}\le1000$。

**【题目来源】**

NOIP 2007 提高第三题。





## 样例 #1

### 输入

```
2 3
1 2 3
3 4 2
```

### 输出

```
82```

# AI分析结果



### 综合分析与结论
本题核心为行独立的区间DP，每行求取数最大得分总和。关键难点在于处理大数（需高精度或__int128）及设计高效状态转移。最优思路为：
1. **行独立处理**：每行单独计算后累加。
2. **区间DP状态设计**：`f[l][r]`表示剩余区间`[l,r]`的最大得分。
3. **转移优化**：每次转移时将之前结果翻倍，避免直接计算2的幂。
4. **大数处理**：使用`__int128`简化代码，或高精度结构体。

---

### 高评分题解推荐

#### 1. 题解作者：zhylj (⭐⭐⭐⭐⭐)
**关键亮点**：
- **简洁的状态转移方程**：`f[i][j] = max(2*f[i+1][j]+2*a[i], 2*f[i][j-1]+2*a[j])`，通过乘2隐式处理指数。
- **使用__int128**：避免高精度代码，极大提升代码可读性。
- **循环顺序优化**：按区间长度从小到大递推，自然覆盖所有子问题。

**核心代码**：
```cpp
__int128 solve(__int128 a[]) {
    memset(f,0,sizeof(f));
    for(int len=0; len<=m; ++len)
        for(int i=1; i+len<=m; ++i) {
            int j = i + len;
            f[i][j] = max(2*f[i+1][j] + 2*a[i], 2*f[i][j-1] + 2*a[j]);
        }
    return f[1][m];
}
```

---

#### 2. 题解作者：qhr2023 (⭐⭐⭐⭐⭐)
**关键亮点**：
- **极致简洁的实现**：仅20行代码完成核心逻辑。
- **高效状态转移**：与zhylj类似，利用乘2代替幂次计算。
- **行间处理优化**：直接在输入循环中处理每行，减少内存占用。

**核心代码**：
```cpp
for (int i=1; ans+=f[1][m], memset(f,0,sizeof f), ++i) 
    for (int len=1; len<=m; ++len) 
        for (int l=1, r=l+len-1; r<=m; ++l, ++r)
            f[l][r] = max(f[l+1][r]+a[i][l], f[l][r-1]+a[i][r]) * 2;
```

---

#### 3. 题解作者：Jack_Homes_Huang (⭐⭐⭐⭐)
**关键亮点**：
- **详细的高精度实现**：提供完整高精度结构体，适合无`__int128`环境。
- **预处理2的幂**：通过`base`数组存储2的幂次，优化计算速度。
- **逆向区间遍历**：从大区间向小区间递推，确保子问题先解。

**调试心得**：
> "预处理2的幂时写成n调了n年..." —— 强调边界检查的重要性。

**关键代码片段**：
```cpp
HP operator * (const HP &a, const int &b) { //高精*单精
    HP c; c.len = a.len; int x = 0;
    for (int i=1; i<=c.len; i++) {
        c.p[i] = a.p[i] * b + x;
        x = c.p[i] / Mod;
        c.p[i] %= Mod;
    }
    while (x > 0) c.p[++c.len] = x % Mod, x /= Mod;
    return c;
}
```

---

### 最优技巧总结
1. **隐式处理指数**：通过转移时乘2代替显式计算2^k，减少预处理和计算量。
2. **区间DP遍历顺序**：按长度递增或逆向边界遍历，确保子问题已解。
3. **大数处理选择**：比赛环境优先用`__int128`，工程场景可封装高精度类。

---

### 拓展练习推荐
1. **P1436 棋盘分割**（区间DP+数学优化）
2. **P2858 [USACO06FEB]Treats for the Cows**（区间DP基础）
3. **P1004 方格取数**（多维DP+路径处理）

---
处理用时：63.09秒
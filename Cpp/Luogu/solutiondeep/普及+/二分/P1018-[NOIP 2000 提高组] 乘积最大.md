# 题目信息

# [NOIP 2000 提高组] 乘积最大

## 题目背景

NOIP2000 提高组 T2

## 题目描述

今年是国际数学联盟确定的“2000——世界数学年”，又恰逢我国著名数学家华罗庚先生诞辰 90 周年。在华罗庚先生的家乡江苏金坛，组织了一场别开生面的数学智力竞赛的活动，你的一个好朋友 XZ 也有幸得以参加。活动中，主持人给所有参加活动的选手出了这样一道题目：


设有一个长度为 $N$ 的数字串，要求选手使用 $K$ 个乘号将它分成 $K+1$ 个部分，找出一种分法，使得这 $K+1$ 个部分的乘积能够为最大。


同时，为了帮助选手能够正确理解题意，主持人还举了如下的一个例子：


有一个数字串：$312$，当 $N=3,K=1$ 时会有以下两种分法：

1. $3  \times  12=36$ 
2. $31  \times   2=62$  

   
这时，符合题目要求的结果是：$31  \times  2 = 62$。


现在，请你帮助你的好朋友 XZ 设计一个程序，求得正确的答案。


## 说明/提示

**数据范围与约定**

对于 $60\%$ 的测试数据满足 $6≤N≤20$。  
对于所有测试数据，$6≤N≤40,1≤K≤6$。


## 样例 #1

### 输入

```
4 2
1231
```

### 输出

```
62```

# AI分析结果



### 综合分析与结论
本题核心在于动态规划与高精度结合，难点在于状态转移的正确性和大数处理的实现。所有题解中动态规划思路为主流，DFS剪枝仅适用于小数据或特定场景。高精度实现方式多样，结构体封装与字符串处理各有优劣。

---

### 精选题解（评分≥4星）

#### 1. 题解作者：liar_white（4.5星）
**关键亮点**  
- 结构体封装高精度数，代码逻辑清晰  
- 动态规划状态定义明确（cut[i][j]表示第i位放第j个乘号的最大值）  
- 完整处理边界条件与状态转移路径  

**个人心得**  
作者提到中间变量解决比较错误问题，强调调试中发现的隐式类型转换问题。

**核心实现思想**  
```cpp
struct node { // 高精度结构体
    int c[50], v; 
    bool exi;
};
// 状态转移核心代码
for(int i=1; i<=n; i++) {
    cut[i][1] = culc(1,i); // 初始化
    for(int j=2; j<=k; j++) {
        for(int fr=j-1; fr<i; fr++) { // 枚举分割点
            cut[i][j] = Max(cut[i][j], mul(cut[fr][j-1], culc(fr+1,i)));
        }
    }
}
```

#### 2. 题解作者：FastIO_DP（4.5星）
**关键亮点**  
- 类封装高精度运算，运算符重载规范  
- 状态转移方程简洁（dp[i][j] = max(dp[k][j-1] * num(k+1,i))）  
- 完整处理数字分割与比较逻辑

**核心代码片段**  
```cpp
struct BI { // 高精度类实现
    int d[100], len;
    BI operator*(const BI& o) const { // 重载乘法
        BI res;
        for(int i=0; i<len; i++)
            for(int j=0; j<o.len; j++)
                res.d[i+j] += d[i] * o.d[j];
        // 进位处理...
        return res;
    }
};
// DP转移核心
for(int j=1; j<=K; j++) {
    for(int i=j; i<N; i++) {
        for(int k=j-1; k<i; k++) {
            dp[i][j] = max(dp[i][j], dp[k][j-1] * num(k+1,i));
        }
    }
}
```

#### 3. 题解作者：kuaiCreator（4星）
**关键亮点**  
- 清晰的划分型DP思路分析  
- 提供不带高精度的伪代码方便理解  
- 详细的复杂度分析与状态转移说明  

**核心思路**  
```cpp
dp[i][j] = max(dp[k][j-1] * num(k+1,i))
// 初始化：dp[i][0] = 前i位数字
// 最终答案：dp[n][k]
```

---

### 关键思路与技巧总结
1. **DP状态设计**：定义`dp[i][j]`为前i位使用j个乘号的最大乘积，需配合高精度存储
2. **高精度实现**：推荐结构体/类封装，重载运算符提升代码可读性
3. **分割点枚举**：转移时k从j-1开始（前k位需能放j-1个乘号）
4. **初始化技巧**：`dp[i][0]`直接取前i位数字作为基础值

---

### 推荐相似题目
1. P1005 矩阵取数游戏（高精度+区间DP）  
2. P1013 进制位（数位处理+组合数学）  
3. P1439 乘积最大（同类问题简单版）

---

### 个人心得摘录
1. **调试经验**（liar_white）：比较函数必须严格处理位数和每位数值，中间变量可避免隐式错误  
2. **实现技巧**（FastIO_DP）：高精度数字存储时逆序存储，运算时无需反转  
3. **思维误区**（sunyt）：DFS剪枝需保证剩余数字足够放置剩余乘号，否则无效

---
处理用时：56.55秒
# 题目信息

# [NOIP 2000 提高组] 单词接龙

## 题目背景

注意：本题为上古 NOIP 原题，不保证存在靠谱的做法能通过该数据范围下的所有数据。

本题为搜索题，本题不接受 hack 数据。[关于此类题目的详细内容](https://www.luogu.com.cn/paste/isdgwj5l)

NOIP2000 提高组 T3

## 题目描述

单词接龙是一个与我们经常玩的成语接龙相类似的游戏，现在我们已知一组单词，且给定一个开头的字母，要求出以这个字母开头的最长的“龙”（每个单词都最多在“龙”中出现两次），在两个单词相连时，其重合部分合为一部分，例如 `beast` 和 `astonish`，如果接成一条龙则变为 `beastonish`，另外相邻的两部分不能存在包含关系，例如 `at` 和 `atide` 间不能相连。


## 说明/提示

样例解释：连成的“龙”为 `atoucheatactactouchoose`。

$n \le 20$。

## 样例 #1

### 输入

```
5
at
touch
cheat
choose
tact
a
```

### 输出

```
23
```

# AI分析结果



### 综合分析与结论
本题需通过DFS枚举所有可能的单词接龙方式，关键难点在于处理重叠部分及避免包含关系。正确解法需遍历所有可能的重叠长度，逐一尝试以确保全局最优解。RyanLi的题解通过合理设计DFS逻辑和边界条件，高效解决了问题；而SuyctidohanQ的题解因错误地仅处理首个重叠长度，可能导致漏解。

### 所选优质题解

#### RyanLi 的题解（⭐⭐⭐⭐⭐）
**关键亮点**：
- **DFS回溯设计**：通过维护当前字符串状态和单词使用次数，高效枚举所有可能路径。
- **重叠长度遍历**：直接遍历所有可能的重叠长度（1到min(len1, len2)-1），确保所有接法被考虑。
- **边界处理严谨**：通过`substr`正确截取子串，避免包含关系。
- **代码简洁性**：无冗余模板代码，逻辑清晰。

**核心代码实现**：
```cpp
void dfs(const string &tmp) {
    ans = max(ans, int(tmp.size()));
    for (int i = 1; i <= n; ++i) {
        if (vis[i] >= 2) continue;
        for (int j = 1; j < min(tmp.size(), s[i].size()); ++j)
            if (tmp.substr(tmp.size() - j) == s[i].substr(0, j)) {
                ++vis[i];
                dfs(tmp + s[i].substr(j));
                --vis[i];
            }
    }
}
```
**核心思想**：对每个候选单词，尝试所有可能的重叠长度 `j`，若满足条件则递归拼接剩余部分，并更新使用次数。

### 最优思路总结
1. **DFS遍历所有可能性**：通过深度优先搜索尝试所有可能的单词连接顺序。
2. **动态维护状态**：使用字符串拼接和回溯法管理当前龙的状态及单词使用次数。
3. **重叠长度全遍历**：必须遍历所有可能的 `j` 值（1到两单词长度较小值-1），避免漏解。
4. **避免包含关系**：通过限制 `j≥1` 且 `j<min(len1, len2)`，确保不会出现包含情况。

### 拓展与举一反三
- **预处理优化**：可预先计算每对单词间的最大有效重叠长度，减少DFS中重复计算。
- **剪枝策略**：若当前剩余单词无法超过已知最大长度，可提前终止搜索。
- **状态压缩**：若数据范围更大，可考虑记忆化搜索或动态规划优化。

### 相似题目推荐
1. [P1032 字串变换](https://www.luogu.com.cn/problem/P1032) - BFS与字符串操作结合。
2. [P1120 小木棍](https://www.luogu.com.cn/problem/P1120) - DFS剪枝经典问题。
3. [P1092 虫食算](https://www.luogu.com.cn/problem/P1092) - 搜索与数学逻辑的结合。

---
处理用时：170.18秒
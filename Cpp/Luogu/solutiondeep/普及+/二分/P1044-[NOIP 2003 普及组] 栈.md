# 题目信息

# [NOIP 2003 普及组] 栈

## 题目背景

栈是计算机中经典的数据结构，简单的说，栈就是限制在一端进行插入删除操作的线性表。

栈有两种最重要的操作，即 pop（从栈顶弹出一个元素）和 push（将一个元素进栈）。

栈的重要性不言自明，任何一门数据结构的课程都会介绍栈。宁宁同学在复习栈的基本概念时，想到了一个书上没有讲过的问题，而他自己无法给出答案，所以需要你的帮忙。

## 题目描述

![](https://cdn.luogu.com.cn/upload/image_hosting/5qxy9fz2.png)

宁宁考虑的是这样一个问题：一个操作数序列，$1,2,\ldots ,n$（图示为 1 到 3 的情况），栈 A 的深度大于 $n$。

现在可以进行两种操作，

1. 将一个数，从操作数序列的头端移到栈的头端（对应数据结构栈的 push 操作）
2. 将一个数，从栈的头端移到输出序列的尾端（对应数据结构栈的 pop 操作）

使用这两种操作，由一个操作数序列就可以得到一系列的输出序列，下图所示为由 `1 2 3` 生成序列 `2 3 1` 的过程。

![](https://cdn.luogu.com.cn/upload/image_hosting/8uwv2pa2.png)

（原始状态如上图所示）

你的程序将对给定的 $n$，计算并输出由操作数序列 $1,2,\ldots,n$ 经过操作可能得到的输出序列的总数。

## 说明/提示

**【题目来源】**

NOIP 2003 普及组第三题

## 样例 #1

### 输入

```
3
```

### 输出

```
5
```

# AI分析结果



### 综合分析与结论
本题本质是卡特兰数问题，所有题解均围绕卡特兰数的数学性质展开。核心解决思路可分为三类：①递归/记忆化搜索 ②动态规划 ③直接应用卡特兰数公式。其中数学公式法最优，时间效率O(n)，空间效率O(1)；动态规划法直观易理解，时间O(n²)；递归法需记忆化否则超时。

---

### 高星题解推荐

#### 1. xiejinhao（⭐⭐⭐⭐⭐）
**关键亮点**：  
- 提供4种解法（记忆化搜索/DP/卡特兰数公式/打表）  
- 详细推导递推关系式，对比各卡特兰公式优劣  
- 代码实现简洁规范，含高精度版本

**核心代码（递推公式）**：
```cpp
for(int i=2;i<=n;i++)
    h[i] = h[i-1]*(4*i-2)/(i+1);
```

#### 2. inexistent（⭐⭐⭐⭐）
**关键亮点**：  
- 清晰图解卡特兰数与出栈序列的关系  
- 给出组合数公式的数学证明  
- 代码极简，突出公式优势

**核心思想**：
```python
ans = C(2n,n)/(n+1)
```

#### 3. Shmily_389704（⭐⭐⭐⭐）
**关键亮点**：  
- 独创状态定义 f[i][j] 表示栈内i个数+未进栈j个数的状态  
- 递推关系简洁：f[i][j] = f[i-1][j]（push） + f[i+1][j-1]（pop）  
- 边界条件处理清晰

**核心递推**：
```cpp
if(i>=1) f[i][j] = f[i-1][j] + f[i+1][j-1];
else f[i][j] = f[i+1][j-1];
```

---

### 关键思路总结
**最优解法**：卡特兰数递推公式  
`h(n) = h(n-1)*(4n-2)/(n+1)`  
- 时间复杂度O(n)，空间O(1)  
- 避免组合数计算的溢出风险  
- 数学证明严谨，代码实现仅需5行

**思维突破点**：将栈操作序列转化为卡特兰数的合法括号匹配问题，通过分析第一个出栈元素k的划分，建立递推关系。

---

### 拓展练习
1. [P1976 鸡蛋饼](https://www.luogu.com.cn/problem/P1976) - 卡特兰数经典变形  
2. [P1754 球迷购票问题](https://www.luogu.com.cn/problem/P1754) - 二维限制的卡特兰数  
3. [P3200 [HNOI2009]有趣的数列](https://www.luogu.com.cn/problem/P3200) - 卡特兰数+质因数分解

---

### 核心代码实现
**卡特兰数递推式（最优解）**：
```cpp
#include <iostream>
using namespace std;

int main() {
    int n;
    long long h = 1;
    cin >> n;
    for(int i=1; i<=n; ++i) 
        h = h * (4*i-2) / (i+1);
    cout << h;
}
```

**动态规划法（易理解）**：
```cpp
int dp[20][20] = {0};
for(int j=0; j<=n; j++) dp[0][j] = 1;
for(int i=1; i<=n; i++)
    for(int j=i; j<=n; j++)
        dp[i][j] = (i==j ? dp[i-1][j] : dp[i][j-1] + dp[i-1][j]);
```

---
处理用时：74.20秒
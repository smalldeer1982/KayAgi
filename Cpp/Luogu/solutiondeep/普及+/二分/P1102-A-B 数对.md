# 题目信息

# A-B 数对

## 题目背景

出题是一件痛苦的事情！

相同的题目看多了也会有审美疲劳，于是我舍弃了大家所熟悉的 A+B Problem，改用 A-B 了哈哈！

## 题目描述

给出一串正整数数列以及一个正整数 $C$，要求计算出所有满足 $A - B = C$ 的数对的个数（不同位置的数字一样的数对算不同的数对）。

## 说明/提示

对于 $75\%$ 的数据，$1 \leq N \leq 2000$。

对于 $100\%$ 的数据，$1 \leq N \leq 2 \times 10^5$，$0 \leq a_i <2^{30}$，$1 \leq C < 2^{30}$。

2017/4/29 新添数据两组

## 样例 #1

### 输入

```
4 1
1 1 2 3
```

### 输出

```
3```

# AI分析结果



### 综合分析与结论
本题核心在于高效统计满足A-B=C的数对数量。数据规模要求算法复杂度不高于O(n log n)。题解主要围绕以下思路展开：
1. **哈希映射**：利用map/unordered_map统计数值频率，将问题转化为查找A-C=B的频率累加
2. **二分查找**：排序后通过二分确定每个元素对应的目标值范围
3. **双指针**：排序后维护单调指针寻找匹配区间
4. **手写哈希**：通过自定义哈希结构优化性能

以下为精选的高质量题解：

---

### 精选题解及评分

#### 1. OsvaldoAsensioLopez（★★★★☆）
**关键亮点**：
- 简洁的哈希映射解法，时间复杂度O(n)
- 利用STL map实现直观的频率统计
- 代码仅10行，可读性极佳

```cpp
map<LL,LL> m;
for(int i=1;i<=n;i++) m[a[i]]++;
for(int i=1;i<=n;i++) ans += m[a[i]-c];
```

#### 2. jins3599（★★★★★）
**关键亮点**：
- 双指针法实现O(n)线性扫描
- 巧妙处理重复元素的计数问题
- 空间复杂度O(1)且无需额外哈希结构

```cpp
sort(a+1,a+1+n);
int l=1,r1=1,r2=1;
for(l=1; l<=n; l++) {
    while(r1<=n && a[r1]-a[l]<=c) r1++;
    while(r2<=n && a[r2]-a[l]<c ) r2++;
    if(a[r2]-a[l]==c) ans += r1-r2;
}
```

#### 3. Ajwallet（★★★★☆）
**关键亮点**：
- 手写哈希表实现极致性能
- 通过模大质数减少冲突
- 展示哈希表底层原理

```cpp
struct node{ LL x; int y; }h[p];
int find(LL x){
    int y=hash(abs(x));
    while(h[y].x&&h[y].x!=x) y=hash(++y);
    return y;
}
```

---

### 最优思路总结
1. **哈希映射**：将问题转换为A-C=B的查找，利用O(1)查询特性快速统计
2. **双指针技巧**：排序后维护单调性，通过区间差值直接计算对数
3. **频率预计算**：通过预处理数值频率避免重复扫描

### 关键实现技巧
1. **STL函数组合**：`upper_bound - lower_bound`快速计算目标值出现次数
2. **重复元素处理**：记录连续相同元素的起止位置，通过乘法原理计算组合数
3. **溢出预防**：使用`long long`类型处理大数相乘场景

### 同类题目推荐
1. [P1102 A-B数对（原题）](https://www.luogu.com.cn/problem/P1102)
2. [P1678 烦恼的高考志愿](https://www.luogu.com.cn/problem/P1678)（二分应用）
3. [P1485 火柴排队](https://www.luogu.com.cn/problem/P1485)（双指针+逆序对）

### 调试经验摘录
> "注意开long long！第三个测试点会爆int" —— OsvaldoAsensioLopez  
> "双指针移动时要同时考虑<=c和<c的情况" —— jins3599  
> "哈希表size应选质数，否则可能卡最后一个点" —— Ajwallet

这些经验突出了数值范围和边界条件处理的重要性，对实际编码有重要指导意义。

---
处理用时：62.72秒
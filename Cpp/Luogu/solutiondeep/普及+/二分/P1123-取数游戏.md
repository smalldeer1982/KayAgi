# 题目信息

# 取数游戏

## 题目描述

一个 $N\times M$ 的由非负整数构成的数字矩阵，你需要在其中取出若干个数字，使得取出的任意两个数字不相邻（若一个数字在另外一个数字相邻 $8$ 个格子中的一个即认为这两个数字相邻），求取出数字和最大是多少。

## 说明/提示

### 样例解释

对于第一组数据，取数方式如下：

$$\begin{matrix}
[67] & 75 & 63 & 10 \\
29 & 29 & [92] & 14 \\
[21] & 68 & 71 & 56 \\
8 & 67 & [91] & 25 \\
\end{matrix}$$


### 数据范围及约定

- 对于$20\%$的数据，$1\le N, M \le 3$；
- 对于$40\%$的数据，$1\le N, M\le 4$；
- 对于$60\%$的数据，$1\le N, M\le 5$；
- 对于$100\%$的数据，$1\le N, M\le 6$，$1\le T\le 20$。


## 样例 #1

### 输入

```
3
4 4
67 75 63 10
29 29 92 14
21 68 71 56
8 67 91 25
2 3
87 70 85
10 3 17
3 3
1 1 1
1 99 1
1 1 1

```

### 输出

```
271
172
99
```

# AI分析结果



### 综合分析与结论
该题核心是选择不相邻元素的最大和，关键难点在于高效处理8邻域约束。题解主要分为两类：
1. **DFS+回溯**：通过标记周围区域实现约束，利用数据范围小（6x6）暴力枚举
2. **状压DP**：预处理合法行状态，通过位运算处理行间约束

### 优质题解推荐

#### 1. 绿萧（5星）
**核心亮点**：
- 清晰的DFS回溯框架，使用mark数组记录8邻域冲突
- 通过方向数组实现简洁的邻域标记
- 代码结构工整，注释明确

**核心代码**：
```cpp
void dfs(int x,int y){
    if(y==m+1) dfs(x+1,1);
    if(x==n+1) mx = max(ans,mx);
    
    dfs(x,y+1); // 不取当前点
    
    if(mark[x][y]==0) {
        ans += s[x][y];
        // 标记8邻域
        for(int fx=0;fx<8;++fx) ++mark[x+d[fx][0]][y+d[fx][1]];
        dfs(x,y+1);
        // 回溯
        for(int fx=0;fx<8;++fx) --mark[x+d[fx][0]][y+d[fx][1]];
        ans -= s[x][y];
    }
}
```

#### 2. IntrepidStrayer（4星）
**核心亮点**：
- 状压DP标准解法，预处理合法行状态
- 使用位运算高效处理行间约束
- 状态转移方程清晰

**关键实现**：
```cpp
// 预处理合法行状态
for(int i=0;i<(1<<m);++i)
    if(check1(i)) c[++cnt]=i;

// 状态转移
for(int i=1;i<=n;++i)
    for(int j=1;j<=cnt;++j)
        for(int k=1;k<=cnt;++k)
            if(check2(c[j],c[k])) // 行间约束
                f[i][j] = max(f[i][j], f[i-1][k] + sum);
```

#### 3. 回头是岸（4星）
**核心亮点**：
- 简洁的状压DP实现
- 使用vector存储合法状态
- 行列转换处理巧妙

**关键技巧**：
```cpp
vector<int> t; // 存储合法状态
void work(){
    for(int i=0;i<(1<<m);i++)
        if(!(i&(i>>1)) && !(i&(i<<1))) 
            t.push_back(i);
}
```

### 最优思路总结
1. **DFS核心技巧**：
- 使用计数型标记数组（非bool）处理重叠区域
- 按行列顺序遍历，保证不重复搜索
- 早剪枝：当x>n时立即更新最大值

2. **状压DP核心技巧**：
- 预处理合法行状态（无相邻1）
- 行间约束判断：!(j&k) && !(j&(k<<1)) && !(j&(k>>1))
- 状态转移时计算行内和

### 相似题目推荐
1. P1896 [SCOI2005] 互不侵犯（状压DP经典）
2. P2704 [NOI2001] 炮兵阵地（三维状压DP）
3. P3943 星空（状压+最短路）

### 题解中的实践智慧
zhi_zhang的调试经验：
> "修改后的Dfs从遍历全矩阵改为只遍历后续行，剪枝后多A了一个点...最终通过调整遍历顺序和判断条件AC"

启示：DFS优化应重点限制搜索范围而非单纯减枝，通过调整遍历顺序可避免大量重复计算。

---
处理用时：54.01秒
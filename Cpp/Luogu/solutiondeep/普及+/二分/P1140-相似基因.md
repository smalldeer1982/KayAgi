# 题目信息

# 相似基因

## 题目背景

大家都知道，基因可以看作一个碱基对序列。它包含了 $4$ 种核苷酸，简记作 `A, C, G, T`。生物学家正致力于寻找人类基因的功能，以利用于诊断疾病和发明药物。

在一个人类基因工作组的任务中，生物学家研究的是：两个基因的相似程度。因为这个研究对疾病的治疗有着非同寻常的作用。

## 题目描述

两个基因的相似度的计算方法如下：

对于两个已知基因，例如 `AGTGATG` 和 `GTTAG`，将它们的碱基互相对应。当然，中间可以加入一些空碱基 `-`，例如：

$$
\def\arraystretch{1.5}
\begin{array}{|c|c|c|c|c|c|c|c|} \hline
\tt A & \tt G & \tt T & \tt G & \tt A & \tt T & \texttt - & \tt G \\ \hline
\texttt - & \tt G & \tt T & \texttt - & \texttt - & \tt T & \texttt A & \tt G \\ \hline
\end{array}
$$

这样，两个基因之间的相似度就可以用碱基之间相似度的总和来描述，碱基之间的相似度如下表所示：

$$
\def\arraystretch{1.5}
\begin{array}{ |c|c|c|c|c|c|} \hline
& \tt A & \tt C & \tt G & \tt T & \texttt - \\ \hline
\tt A & 5 & -1 & -2 & -1 & -3\\ \hline
\tt C & -1 & 5 & -3 & -2 & -4 \\\hline
\tt G & -2 & -3 & 5 & -2 & -2 \\\hline
\tt T & -1 & -2 & -2 & 5 & -1 \\\hline
\texttt - & -3 & -4 & -2 & -1 & * \\\hline
\end{array}
$$ 

那么相似度就是：$(-3)+5+5+(-2)+(-3)+5+(-3)+5=9$。因为两个基因的对应方法不唯一，例如又有：

$$
\def\arraystretch{1.5}
\begin{array}{|c|c|c|c|c|c|c|} \hline
\tt A & \tt G & \tt T & \tt G & \tt A & \tt T & \tt G \\ \hline
\texttt - & \tt G & \tt T & \texttt T & \texttt A & \texttt - & \tt G \\ \hline
\end{array}
$$

相似度为：$(-3)+5+5+(-2)+5+(-1)+5=14$。规定两个基因的相似度为所有对应方法中，相似度最大的那个。


## 样例 #1

### 输入

```
7 AGTGATG
5 GTTAG
```

### 输出

```
14
```

# AI分析结果



### 综合分析与结论
该题为二维动态规划经典问题，核心思路为定义 `dp[i][j]` 表示第一个基因前i位与第二个基因前j位的最大相似度。所有题解均围绕三种转移方式展开：直接配对、插入空位配对。关键难点在于边界初始化与负值处理，不同题解在代码实现细节（字符映射方式、初始化顺序）上存在差异。

---

### 精选题解及评分

#### 1. 作者：zhy137036（⭐⭐⭐⭐⭐）
**关键亮点**：  
- 系统化拆分DP解题五步骤（状态定义→转移方程→递推顺序→边界处理→结果获取）  
- 代码结构清晰，包含完整注释与输入处理逻辑  
- 特别强调初始状态 `f[0][0]=0` 的正确性验证

**核心代码**：
```cpp
for(int i=1;i<=la;i++)
    for(int j=1;j<=lb;j++)
        f[i][j] = max(f[i-1][j-1]+d[a[i]][b[j]], 
                     max(f[i-1][j]+d[a[i]][5], 
                         f[i][j-1]+d[5][b[j]]));
```

#### 2. 作者：Ykimna（⭐⭐⭐⭐）  
**关键亮点**：  
- 强调必须初始化DP数组为极小值（避免错误计算负分场景）  
- 使用独立函数处理字符映射，提升可维护性  
- 图示辅助理解状态转移过程  

**调试心得**：  
> "一开始没注意初始化极小值导致WA，后来发现题目答案可能为负数，必须显式初始化dp数组为-INF"

#### 3. 作者：Segment_Tree（⭐⭐⭐⭐）  
**关键亮点**：  
- 使用预处理二维数组存储相似度表，逻辑直观  
- 采用字符串直接处理，减少中间变量  
- 通过宏定义优化最大值计算  

**核心代码**：
```cpp
const int tab[5][5] = {/* 相似度表 */};
for(int i=1;i<=la;i++)
    dp[i][0] = dp[i-1][0] + tab[a[i]][4];
```

---

### 关键思路与技巧总结
1. **状态转移方程**：  
   `dp[i][j] = max(直接配对, 插入空位1, 插入空位2)`  
   对应三种转移来源：`dp[i-1][j-1]`, `dp[i-1][j]`, `dp[i][j-1]`

2. **边界处理**：  
   显式处理单序列全空位场景：  
   ```cpp
   for(int i=1;i<=n;i++) dp[i][0] = dp[i-1][0] + score(a[i], '-');
   ```

3. **负值陷阱**：  
   初始化DP数组为极小值（如 `-1e8`），防止默认0值干扰负分场景。

4. **字符映射优化**：  
   将碱基字符（A/C/G/T）映射为0-4的索引，简化查表操作。

---

### 拓展练习推荐
1. **P2758 编辑距离** - 二维DP，状态转移与插入/删除操作类似空位处理  
2. **P1435 回文字符串** - 逆向思维处理字符插入，类似空位配对思想  
3. **P1091 合唱队形** - 双序列动态规划变种，强化状态定义能力  

---

### 调试经验摘录
- **初始化陷阱**：多篇题解提到因未初始化负值导致WA，强调显式初始化的必要性。  
- **索引偏移**：部分代码因字符串索引从0/1开始不一致引发错误，需注意输入处理逻辑。  
- **查表优化**：预处理相似度表时，需严格对齐字符与索引的对应关系，避免查表错位。

---
处理用时：52.19秒
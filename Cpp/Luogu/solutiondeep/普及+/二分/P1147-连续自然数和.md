# 题目信息

# 连续自然数和

## 题目描述

对一个给定的正整数 $M$，求出所有的连续的正整数段（每一段至少有两个数），这些连续的自然数段中的全部数之和为 $M$。

例子：$1998+1999+2000+2001+2002 = 10000$，所以从 $1998$ 到 $2002$ 的一个自然数段为 $M=10000$ 的一个解。


## 样例 #1

### 输入

```
10000
```

### 输出

```
18 142 
297 328 
388 412 
1998 2002
```

# AI分析结果



### 综合分析与结论
本题核心在于利用等差数列性质与数学推导进行高效求解。主要解法可分为三类：
1. **数学分解法**：通过分解因数与奇偶性判断，时间复杂度最优（O(√M)）
2. **双指针法（尺取法）**：利用滑动窗口维护区间和，时间复杂度O(M)
3. **暴力枚举+剪枝**：通过公式推导优化枚举范围，时间复杂度O(M)~O(M²)

---

### 精选题解与评分
#### 1. gzw2005（5星）
**关键亮点**：
- 数学推导：将问题转化为因数分解，通过奇偶性判断保证解的整数性
- 时间复杂度：O(√M)，通过sqrt(2M)优化枚举范围
- 代码简洁性：仅需10行核心逻辑

```cpp
for(int k1=sqrt(2*m);k1>1;k1--)
    if(2*m%k1==0 && (k1+2*m/k1)%2){
        int k2=2*m/k1;
        cout<<(k2-k1+1)/2<<" "<<(k1+k2-1)/2<<endl;
    }
```

#### 2. Frenix（4星）
**关键亮点**：
- 双指针滑动窗口：动态调整区间和，逻辑直观
- 时间复杂度：O(M)，适用于一般规模数据
- 个人心得：提到"两个指针单调右移"的特性证明正确性

```cpp
for(int i=1,j=2;i<=m/2;){
    if(sum==m) printf("%d %d\n",i,j);
    else if(sum<m) j++,sum+=j;
    else sum-=i,i++;
}
```

#### 3. 大头（4星）
**关键亮点**：
- 逆向枚举项数：通过项数i推导首项，避免浮点运算
- 数学优化：通过i的范围限制减少无效计算
- 代码极简：仅需7行核心逻辑

```cpp
for(int i=2000;i>1;i--)
    if(n%i==0&&i*i<=n&&(n/i-i+1)%2==0)
        printf("%d %d\n",(n/i-i+1)/2,(n/i-i+1)/2+i-1);
```

---

### 核心技巧总结
1. **数学公式转化**：  
   $$ (L+R)(R-L+1)=2M $$  
   通过分解2M为k1*k2，要求k1与k2奇偶性不同，保证解为整数。
   
2. **因数分解优化**：  
   仅需枚举到√(2M)，通过交换k1/k2覆盖所有可能情况。

3. **双指针维护单调性**：  
   利用连续数列和的单调性，通过左右指针滑动避免重复计算。

---

### 拓展训练推荐
1. [P1214 等差数列](https://www.luogu.com.cn/problem/P1214)  
   **考察点**：等差数列公式应用与边界处理
2. [P1636 Einstein学画画](https://www.luogu.com.cn/problem/P1636)  
   **考察点**：数学建模与因数分解思想
3. [P1102 A-B数对](https://www.luogu.com.cn/problem/P1102)  
   **考察点**：双指针/哈希表优化查找

---

### 调试经验摘录
1. **gzw2005**提到：  
   > "k1>1而不是k1>=1"防止出现单元素数列  
   **启示**：边界条件需通过数学推导严格验证

2. **lamboo**调试经历：  
   > "long long y = i; 防止i*i溢出"  
   **教训**：大数运算需注意类型转换与溢出问题

3. **feecle6418**自述：  
   > "二分直接把我卡到492ms，看着别人的8ms惭愧"  
   **优化方向**：算法选择比局部优化更关键

---
处理用时：67.08秒
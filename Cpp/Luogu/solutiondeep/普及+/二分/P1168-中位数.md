# 题目信息

# 中位数

## 题目描述

给定一个长度为 $N$ 的非负整数序列 $A$，对于前奇数项求中位数。

## 说明/提示

对于 $20\%$ 的数据，$N \le 100$；

对于 $40\%$ 的数据，$N \le 3000$；

对于 $100\%$ 的数据，$1 \le N ≤ 100000$，$0 \le A_i \le 10^9$。


## 样例 #1

### 输入

```
7
1 3 5 7 9 11 6```

### 输出

```
1
3
5
6```

## 样例 #2

### 输入

```
7
3 1 5 9 8 7 6```

### 输出

```
3
3
5
6```

# AI分析结果



### 题解综合分析结论
本题目核心在于动态维护序列并快速查询奇数项的中位数。所有题解围绕时间复杂度优化展开，主要思路可分为：暴力维护有序性、对顶堆动态分割、树状数组/线段树统计、平衡树维护。其中对顶堆方法因实现简单、效率稳定成为最优解，树状数组离散化方案次之。

---

### 高分题解推荐（≥4星）

#### 1. 肖恩Sean（赞525）⭐⭐⭐⭐⭐
**关键亮点**：  
- 对顶堆思路清晰，用大根堆存较小值、小根堆存较大值  
- 维护堆大小差≤1，直接取堆顶作为中位数  
- 代码简洁（仅24行），利用STL优先队列实现  

**核心代码**：
```cpp
priority_queue<int> q1; // 大根堆（存较小值）
priority_queue<int, vector<int>, greater<int>> q2; // 小根堆（存较大值）

void insert(int x) {
    if (x > q1.top()) q2.push(x);
    else q1.push(x);
    // 调整堆大小差...
}
int get_median() {
    return q1.size() > q2.size() ? q1.top() : q2.top();
}
```

#### 2. IRipple（赞365）⭐⭐⭐⭐  
**关键亮点**：  
- 引入中间变量mid记录当前中位数  
- 详细图示解释堆调整逻辑  
- 调整策略更直观：元素直接与mid比较后入堆  

**调试心得**：  
> "调试中发现当插入元素导致堆不平衡时，必须将mid转移至另一堆再重新确定mid，这个边界条件容易被忽略"

---

### 最优思路提炼
**对顶堆核心逻辑**：  
1. 大根堆存较小半部分，小根堆存较大半部分  
2. 每次插入后保证 `|size(q1)-size(q2)| ≤ 1`  
3. 中位数即为元素较多的堆顶或两堆顶平均（本题只需取较多堆顶）  
4. 插入时与当前中位数比较决定归属堆  

**时间复杂度**：O(n log n)  
**空间复杂度**：O(n)

---

### 相似题目推荐
1. [P1801 黑匣子](https://www.luogu.com.cn/problem/P1801) - 动态查询第K大  
2. [P3871 中位数](https://www.luogu.com.cn/problem/P3871) - 带删除操作的中位数维护  
3. [P3380 二逼平衡树](https://www.luogu.com.cn/problem/P3380) - 综合查询（区间第K大等）  

---

### 关键代码实现（对顶堆完整版）
```cpp
#include <queue>
using namespace std;

int main() {
    priority_queue<int> left; // 大根堆（存较小值）
    priority_queue<int, vector<int>, greater<int>> right; // 小根堆（存较大值）
    
    int n, x; scanf("%d", &n);
    scanf("%d", &x);
    left.push(x);
    printf("%d\n", x);
    
    for(int i=2; i<=n; i++) {
        scanf("%d", &x);
        // 插入元素
        (x > left.top()) ? right.push(x) : left.push(x);
        
        // 调整堆大小差
        while(abs((int)left.size() - (int)right.size()) > 1) {
            if(left.size() > right.size()) {
                right.push(left.top());
                left.pop();
            } else {
                left.push(right.top());
                right.pop();
            }
        }
        
        // 输出奇数项中位数
        if(i % 2 == 1) 
            printf("%d\n", (left.size() > right.size()) ? left.top() : right.top());
    }
    return 0;
}
```

---
处理用时：71.82秒
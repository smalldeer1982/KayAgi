# 题目信息

# [JSOI2008] 最大数

## 题目描述

现在请求你维护一个数列，要求提供以下两种操作：

1.  查询操作。

语法：`Q L`

功能：查询当前数列中末尾 $L$ 个数中的最大的数，并输出这个数的值。

限制：$L$ 不超过当前数列的长度。$(L > 0)$

2. 插入操作。

语法：`A n`

功能：将 $n$ 加上 $t$，其中 $t$ 是最近一次查询操作的答案（如果还未执行过查询操作，则 $t=0$），并将所得结果对一个固定的常数 $D$ 取模，将所得答案插入到数列的末尾。

限制：$n$ 是整数（可能为负数）并且在长整范围内。

注意：初始时数列是空的，没有一个数。


## 说明/提示

#### 数据规模与约定

对于全部的测试点，保证 $1 \leq M \leq 2 \times 10^5$，$1 \leq D \leq 2 \times 10^9$。

## 样例 #1

### 输入

```
5 100
A 96
Q 1
A 97
Q 1
Q 2
```

### 输出

```
96
93
96
```

# AI分析结果



### 综合分析结论
本题核心在于动态维护末尾插入元素的区间最值查询。题解呈现多种解法，其中线性或近似线性的算法（单调队列+二分/并查集）效率最优，线段树/ST表等通用解法较易实现但常数较大。最优解法利用插入位置特性，通过维护单调性降低查询复杂度。

---

### 高星题解精选（≥4★）

#### 1. Spasmodic的线性做法（5★）
**关键亮点**：  
- 使用单调队列维护递减序列，插入时淘汰无用元素  
- 结合并查集实现O(α(n))查询，突破二分查询的log瓶颈  
- 创新性地将单调栈与并查集结合，时间复杂度最优  

**核心代码**：
```cpp
int find(int x){ return x==id[x]?x:id[x]=find(id[x]); }
void unite(int u,int v){ id[find(u)]=find(v); }

// 插入时维护单调队列
while(r && a[q[r-1]]<=a[sz]) unite(q[--r],sz);
q[r++]=sz;
```

#### 2. SaoFish的ST表解法（4★）
**关键亮点**：  
- 逆向定义ST表区间，适应尾部插入特性  
- 插入时仅更新相关区间，O(logn)维护  
- 思路清晰，代码简洁  

**核心思想**：  
每次插入新元素时，重建以该元素为终点的ST表区间：
```cpp
void change(int u){
    f[u][0] = a[u];
    for(int i=1; u-(1<<i)>=0; i++)
        f[u][i] = max(f[u][i-1], f[u-(1<<(i-1))][i-1]);
}
```

#### 3. 单曦增的并查集优化（4★）
**独特思路**：  
- 用并查集合并被淘汰元素，直接跳跃查询  
- 图示解释清晰，形象展示集合合并过程  
- 时间复杂度稳定O(nα(n))  

**实现要点**：
```cpp
while(cnt && a[tmp]<=x){
    fa[tmp] = id; // 将淘汰元素的父节点设为新元素
    cnt--;
    tmp = st[cnt];
}
```

---

### 关键技巧总结
1. **单调性维护**：利用插入位置在末尾的特性，维护递减序列快速定位极值  
2. **数据结构融合**：将单调队列与并查集结合，突破传统二分查询的限制  
3. **逆向存储优化**：ST表反向定义区间，适应动态插入场景  
4. **集合跳跃查询**：通过并查集合并被淘汰元素，实现O(1)级查询  

---

### 相似题目推荐
1. P1886 滑动窗口（单调队列经典应用）  
2. P1440 求m区间内的最小值（动态区间最值）  
3. P4137 Rmq Problem mex（特殊区间查询+离线处理）  

---

### 题解心得摘录
1. **Spasmodic调试经验**：  
> "发现查询任意区间会失效，但本题仅需末尾区间查询，故可大胆优化"  
**启示**：抓住题目特殊条件进行针对性优化  

2. **SaoFish踩坑记录**：  
> "原ST表方向定义错误导致WA，修正区间方向后通过"  
**教训**：数据结构定义需严格匹配问题特性  

3. **树状数组解法心得**：  
> "发现前缀维护不适用，反向建树实现后缀查询"  
**技巧**：灵活转换存储方向突破思维定式

---
处理用时：61.53秒
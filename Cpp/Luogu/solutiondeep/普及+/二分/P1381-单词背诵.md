# 题目信息

# 单词背诵

## 题目描述

灵梦有 $n$ 个单词想要背，但她想通过一篇文章中的一段来记住这些单词。

文章由 $m$ 个单词构成，她想在文章中找出连续的一段，其中包含最多的她想要背的单词（重复的只算一个）。并且在背诵的单词量尽量多的情况下，还要使选出的文章段落尽量短，这样她就可以用尽量短的时间学习尽可能多的单词了。

## 说明/提示

### 数据规模与约定

- 对于 $30\%$ 的数据，$n \le 50$，$m \le 500$；
- 对于 $60\%$ 的数据，$n \le 300$，$m \le 5000$；
- 对于 $100\%$ 的数据，$n \le 1000$，$m \le 10^5$。

## 样例 #1

### 输入

```
3

hot

dog

milk

5

hot

dog

dog

milk

hot

```

### 输出

```
3

3

```

# AI分析结果



### 综合分析与结论
本题核心在于双重要求：最大化目标单词种类数，同时求最短区间。各题解主要采用滑动窗口（尺取法）配合哈希表统计，部分结合二分法优化。最优解法为滑动窗口+双哈希统计，时间复杂度O(m)，空间优化良好。

### 高星题解推荐

#### 1. louhao088（5星）
**核心亮点**：
- 使用滑动窗口+双哈希统计，代码简洁高效
- 动态维护出现次数与种类数的映射关系
- 实时更新最优解，处理重复单词逻辑清晰
**关键代码**：
```cpp
while(l<=i) {
    if(!flag[s[l]]) { l++; continue; } // 非目标单词直接跳过
    if(sum[s[l]]>=2) { sum[s[l]]--; l++; } // 重复出现时收缩左边界
    else break;
}
ans2 = min(ans2, i-l+1); // 实时更新最小长度
```
**实现思想**：维护当前窗口内各单词出现次数，当左端点单词冗余时收缩窗口，保证窗口始终包含最大种类数的前提下最小化长度。

#### 2. 早右昕（4.5星）
**核心亮点**：
- 标准尺取法模板实现，逻辑模块化
- 使用质数双哈希减少碰撞概率
- 引入独立vis数组处理首次出现判断
**调试心得**：作者特别强调右端点处理时要考虑单词是否唯一出现，通过多次调试验证边界条件。

#### 3. 清尘（4星）
**创新思路**：
- 利用队列维护有效区间
- 预处理时将文章单词映射为目标单词索引
- 通过lower_bound优化查找效率
**代码特色**：将字符串比较转化为数值比较，显著提升处理速度。

### 最优思路提炼
1. **双指针滑动窗口**：维护当前窗口内目标单词出现次数，动态调整窗口边界
2. **哈希快速映射**：将字符串映射为数值便于统计（推荐双哈希防碰撞）
3. **状态同步更新**：在移动指针时同步更新计数器，确保种类数正确性
4. **冗余剪枝**：当左端点单词出现次数>1时直接收缩，不影响种类数

### 拓展应用
- 类似问题：最长无重复子串（LeetCode 3）、最小覆盖子串（LeetCode 76）
- 算法变种：可结合前缀和统计区间特征值，如P1712 [NOI2016] 区间

### 推荐练习题
1. P1638 逛画展（滑动窗口经典应用）
2. P3405 字符串哈希（哈希基础训练）
3. P4551 最长最短子串（双指针进阶）

### 关键代码实现（louhao088核心逻辑）
完整窗口维护逻辑：
```cpp
for(int i=1;i<=m;i++) {
    cin>>s[i];
    if(flag[s[i]]) sum[s[i]]++; // 记录目标单词出现次数
    if(sum[s[i]]==1) { // 首次出现时更新计数
        ans1++;
        ans2 = i-l+1; 
    }
    // 收缩左边界逻辑
    while(l<=i) {
        if(!flag[s[l]]) { l++; continue; }
        if(sum[s[l]]>=2) { sum[s[l]]--; l++; }
        else break;
    }
    ans2 = min(ans2, i-l+1);
}
```
此片段完美展现滑动窗口的动态调整过程，通过哈希表实现O(1)时间的状态查询更新。

---
处理用时：52.14秒
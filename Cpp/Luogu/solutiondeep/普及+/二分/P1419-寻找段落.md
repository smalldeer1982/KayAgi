# 题目信息

# 寻找段落

## 题目描述

给定一个长度为 $n$ 的序列 $a$，定义 $a_i$ 为第 $i$ 个元素的价值。现在需要找出序列中最有价值的“段落”。段落的定义是长度在 $[S, T]$ 之间的连续序列。最有价值段落是指平均值最大的段落。

**段落的平均值** 等于 **段落总价值** 除以 **段落长度**。

## 说明/提示

【数据范围】

对于 $30\%$ 的数据有 $n \le 1000$。

对于 $100\%$ 的数据有 $1 \le n \le 100000$，$1 \le S \le T \le n$，$-{10}^4 \le a_i \le {10}^4$。

【题目来源】

tinylic 改编


## 样例 #1

### 输入

```
3

2 2

3

-1

2

```

### 输出

```
1.000```

# AI分析结果



### 综合分析与结论
本题要求寻找长度在[S,T]范围内的最大平均值连续子段。主流解法为二分答案+单调队列优化，复杂度O(n logA)。核心在于将平均值问题转化为子段和是否非负的判定问题，利用单调队列维护前缀和最小值以实现高效判定。

---

### 高星题解推荐

#### 1. 作者：kkksc03 (⭐⭐⭐⭐⭐)
**关键亮点**：  
- 思路清晰，完整推导二分判定条件与子段和转换  
- 代码规范，正确处理单调队列的维护逻辑（窗口移动、过期元素弹出）  
- 详细注释与边界处理，适合学习实现细节  

**核心代码思想**：  
```cpp
bool check(double x) {
    deque维护i-s之前的sum最小值，确保窗口长度在[S,T]
    若存在sum[i] - sum[q.front()] >=0 则x可行
}
```

#### 2. 作者：autoint (⭐⭐⭐⭐)
**关键亮点**：  
- 引入数值缩放技巧（乘1e4）避免浮点精度问题  
- 使用STL deque简化代码，适合理解单调队列思想  
- 详细分析单调队列维护的数学原理与边界条件  

**核心优化片段**：  
```cpp
// 将a[i]放大为整数处理，避免浮点误差
a[i] *= 1e4;
if(judge(M)) L=M; // 二分整数域
printf("%.3f",L/1e4); // 输出时还原精度
```

#### 3. 作者：Treaker (⭐⭐⭐⭐)
**关键亮点**：  
- 代码简洁高效，适合快速理解算法框架  
- 正确维护队列中元素的下标范围（i-t到i-s）  
- 显式处理队列空判断，避免逻辑错误  

---

### 关键思路与技巧总结
1. **二分答案转化问题**：将求最大平均值转化为判定性问题，每次检查是否存在子段平均值≥mid。
2. **前缀和变形**：令b[i] = a[i]-mid，问题等价于找长度[S,T]内子段和≥0。
3. **单调队列优化**：维护窗口内最小的sum[j]（j=i-T~i-S），快速判断sum[i]-min_sum≥0。

---

### 相似题目推荐
1. [P1404 平均数](https://www.luogu.com.cn/problem/P1404) - 同款模型，固定子段长度  
2. [P3512 [POI2010]PIL-Pilots](https://www.luogu.com.cn/problem/P3512) - 单调队列维护极值  
3. [P2216 [HAOI2007]理想的正方形](https://www.luogu.com.cn/problem/P2216) - 二维单调队列应用  

---

### 调试与心得摘录
- **autoint**提到浮点处理繁琐，改用整数域二分：避免精度丢失，提高效率。  
- **Harry27182**采用卡时技巧但指出可能被特殊数据卡：强调算法正确性优先于投机策略。  
- **山蛙or山兔**在队列维护中强调“L1>L2且S1<=S2则L1无效”：深化对单调队列筛选条件的理解。

---
处理用时：41.50秒
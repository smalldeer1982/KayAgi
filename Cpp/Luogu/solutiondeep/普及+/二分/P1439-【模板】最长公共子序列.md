# 题目信息

# 【模板】最长公共子序列

## 题目描述

给出 $1,2,\ldots,n$ 的两个排列 $P_1$ 和 $P_2$ ，求它们的最长公共子序列。

## 说明/提示

- 对于 $50\%$ 的数据， $n \le 10^3$；
- 对于 $100\%$ 的数据， $n \le 10^5$。

## 样例 #1

### 输入

```
5 
3 2 1 4 5
1 2 3 4 5
```

### 输出

```
3```

# AI分析结果



### 综合分析与结论
本题核心在于利用排列特性，将LCS转化为LIS问题。最优解法通过映射建立位置关系，结合二分/树状数组求LIS，达到O(n log n)复杂度。关键技巧是发现排列中元素唯一性带来的映射简化。

### 精选题解及亮点

#### 1. 阮行止（★★★★★）
**关键亮点**：用极简例子揭示LCS转LIS的本质，直观解释映射原理  
**核心思路**：将A序列元素视为"标准排列"，B序列元素对应到A的位置后求LIS。  
**代码实现**：
```cpp
for(int i=1;i<=n;i++) a[x] = i; // 建立A的映射
for(int i=1;i<=n;i++) b[i] = a[b[i]]; // 转换B序列
// 求转换后序列的LIS
```

#### 2. heey（★★★★☆）
**关键亮点**：代码简洁高效，直接给出完整实现  
**优化技巧**：用lower_bound替代手写二分，STL使用得当  
**核心代码**：
```cpp
int len=0;
for(int i=1;i<=n;i++){
    if(b[i]>f[len]) f[++len]=b[i];
    else *lower_bound(f+1,f+len+1,b[i]) = b[i];
}
cout<<len;
```

#### 3. Brian_WBY（★★★★☆）
**调试心得**：强调二分边界处理，分享错误修正经验  
**关键实现**：手写二分查找确保正确性  
**代码片段**：
```cpp
int l=0,r=len,mid;
while(l<r){
    mid = (l+r)/2;
    if(f[mid]>x) r=mid;
    else l=mid+1;
}
f[l] = x; // 关键替换操作
```

### 关键思路总结
1. **映射转换**：利用排列唯一性，将元素映射为位置坐标
2. **LIS优化**：使用单调栈+二分维护当前最优序列
3. **数据结构**：树状数组可维护位置最大值（适合元素范围较大时）

### 拓展练习
1. P1020 导弹拦截（LIS经典应用）
2. P2782 友好城市（二维LIS问题）
3. P4309 最长上升子序列（动态LIS维护）

### 同类型技巧
当处理序列间顺序关系时，可考虑：
- 建立元素到位置的映射字典
- 将序列比较转化为单调性维护问题
- 遇到排列类输入时优先考虑O(n)映射优化

---
处理用时：51.48秒
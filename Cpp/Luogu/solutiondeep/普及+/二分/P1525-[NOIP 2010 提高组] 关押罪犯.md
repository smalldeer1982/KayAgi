# 题目信息

# [NOIP 2010 提高组] 关押罪犯

## 题目背景

NOIP2010 提高组 T3

## 题目描述

S 城现有两座监狱，一共关押着 $N$ 名罪犯，编号分别为 $1\sim N$。他们之间的关系自然也极不和谐。很多罪犯之间甚至积怨已久，如果客观条件具备则随时可能爆发冲突。我们用“怨气值”（一个正整数值）来表示某两名罪犯之间的仇恨程度，怨气值越大，则这两名罪犯之间的积怨越多。如果两名怨气值为 $c$ 的罪犯被关押在同一监狱，他们俩之间会发生摩擦，并造成影响力为 $c$ 的冲突事件。

每年年末，警察局会将本年内监狱中的所有冲突事件按影响力从大到小排成一个列表，然后上报到 S 城 Z 市长那里。公务繁忙的 Z 市长只会去看列表中的第一个事件的影响力，如果影响很坏，他就会考虑撤换警察局长。

在详细考察了 $N$ 名罪犯间的矛盾关系后，警察局长觉得压力巨大。他准备将罪犯们在两座监狱内重新分配，以求产生的冲突事件影响力都较小，从而保住自己的乌纱帽。假设只要处于同一监狱内的某两个罪犯间有仇恨，那么他们一定会在每年的某个时候发生摩擦。

那么，应如何分配罪犯，才能使 Z 市长看到的那个冲突事件的影响力最小？这个最小值是多少？


## 说明/提示

**输入输出样例说明**

罪犯之间的怨气值如下面左图所示，右图所示为罪犯的分配方法，市长看到的冲突事件影响力是 $3512$（由 $2$ 号和 $3$ 号罪犯引发）。其他任何分法都不会比这个分法更优。

![](https://cdn.luogu.com.cn/upload/image_hosting/uia11zcq.png)

**数据范围**  

对于 $30\%$ 的数据有 $N\leq 15$。

对于 $70\%$ 的数据有 $N\leq 2000,M\leq 50000$。  

对于 $100\%$ 的数据有 $N\leq 20000,M\leq 100000$。


## 样例 #1

### 输入

```
4 6
1 4 2534
2 3 3512
1 2 28351
1 3 6618
2 4 1805
3 4 12884```

### 输出

```
3512```

# AI分析结果



### 综合分析与结论
本题核心在于通过贪心策略处理冲突值，结合高效数据结构判断矛盾。最优解法为拓展域并查集（种类并查集），时间复杂度 O(Mα(N))，完美适配题目数据规模。二分图判定法虽正确，但效率略低。关键技巧是敌人的敌人合并策略与双域状态表示。

---

### 精选题解推荐

#### 1. _Weslie_ 的拓展域并查集（⭐⭐⭐⭐⭐）
**核心亮点**  
- 系统化讲解拓展域原理，通过"正反状态"解决二元关系问题  
- 代码结构清晰，包含多个同类例题（CF776D等）的扩展  
- 通过双倍域合并实现敌人关系维护，完美契合题意  

**关键代码**  
```cpp
for(int i=1;i<=m;i++){
    vnion(e[i].u+n,e[i].v); // 合并u的反面与v
    vnion(e[i].u,e[i].v+n); // 合并u与v的反面
    if(findd(e[i].u)==findd(e[i].u+n)){ // 冲突检测
        printf("%d",e[i].w);
        return 0;
    }
}
```

#### 2. 梦回还 的敌人标记法（⭐⭐⭐⭐）  
**核心亮点**  
- 创新使用敌人标记数组维护关系链  
- 通过m+1循环巧妙处理无冲突情况  
- 代码简洁高效，空间复杂度优化到位  

**优化技巧**  
```cpp
for(i=1;i<=m+1;i++) { // m+1处理全分配情况
    if(check(f[i].x,f[i].y)) break;
    else {
        if(!b[f[i].x]) b[f[i].x]=f[i].y; // 标记直接敌人
        else ad(b[f[i].x],f[i].y); // 合并敌人的敌人
    }
}
```

#### 3. ClV_Csy 的种类并查集（⭐⭐⭐⭐）  
**核心亮点**  
- 清晰阐述种类并查集的数学原理  
- 通过假想敌概念直观解释状态转移  
- 代码包含详细注释，适合新手理解  

**实现要点**  
```cpp
void merge(int x, int y) {
    x = find(x); 
    y = find(y);
    if(x != y) fa[x] = y;
}
// 合并时处理正反关系
merge(a, b+n); 
merge(b, a+n);
```

---

### 关键思路总结
1. **贪心排序**：按冲突值降序处理，优先解决高冲突对  
2. **双域并查集**：用i表示本身，i+n表示敌人域  
3. **冲突检测**：当find(x)==find(y)时必然冲突  
4. **敌人链维护**：将当前敌人的旧敌人与新敌人合并  

---

### 同类题目推荐
1. **P2024 [NOI2001] 食物链**（种类并查集经典）  
2. **P1892 [BOI2003] 团伙**（敌人/朋友关系处理）  
3. **P1330 封锁阳光大学**（二分图判定实际应用）  

---

### 实践心得摘录
1. **边界处理**：多篇题解强调循环m+1或最后输出0，忽视将导致WA  
2. **空间计算**："开两倍空间"是拓展域的关键，如i+n的敌人域表示  
3. **合并顺序**：注意同时合并u→v+n和v→u+n，确保关系对称性  
4. **路径压缩**：必须带路径压缩的find函数保证O(α(N))复杂度  

```cpp
// 典型错误示例：忘记处理反方向合并
void wrong_merge(int u, int v) {
    fa[find(u)] = find(v+n); // 缺少v与u+n的合并
}
```

通过系统化应用这些技巧，可高效解决各类二元关系分配问题。

---
处理用时：57.18秒
# 题目信息

# 有趣的数

## 题目描述

让我们来考虑 $1$ 到 $N$ 的正整数集合。让我们把集合中的元素按照字典序排列，例如当 $N=11$ 时，其顺序应该为：$1,10,11,2,3,4,5,6,7,8,9$。

定义 $K$ 在 $N$ 个数中的位置为 $Q(N,K)$，例如 $Q(11,2)=4$。现在给出整数 $K$ 和 $M$，要求找到最小的 $N$，使得 $Q(N,K)=M$。

## 说明/提示

【数据约定】


$40\%$ 的数据，$1 \le K,M \le 10^5$；

$100\%$ 的数据，$1 \le K,M \le 10^9$。


## 样例 #1

### 输入

```
2 4
```

### 输出

```
11
```

## 样例 #2

### 输入

```
100000001 1000000000```

### 输出

```
100000000888888879```

# AI分析结果



### 综合分析与结论
本题要求找到字典序排列下满足特定位置的N，核心在于高效计算字典序前序数的数量及动态扩展位数。各题解主要思路分为两类：(1)计算K的最小位置后逐位扩展补充差值；(2)二分+数位DP/字典树遍历。前者时间复杂度O(log M)更优，后者更普适但常数较大。

---

### 高星题解推荐

#### 1. 作者：Akashicw（5星）
**关键亮点**  
- 分阶段处理：先计算K的最小位置，再逐位扩展补足差值  
- 特判10^n情况避免错误  
- 数学推导清晰，代码结构简洁高效（对数级复杂度）  
**核心代码片段**  
```cpp
long long ans=mi[len];
m-=base;
for(int i=1;;i++) {
    long long tmp=k*mi[i]-mi[len+i-1]; // 计算当前位可插入数量
    if(m>tmp) m-=tmp, ans*=10; 
    else break;
}
ans += m-1; // 补充剩余差值
```

#### 2. 作者：Thunder_S（4星）
**关键亮点**  
- 二分答案框架，适用性广  
- 通过字典树遍历计算排名，思路新颖  
- 处理大数时用字符串比较代替数值运算  
**核心思路**  
```cpp
int check(int n, int k) {
    while(now < k) { // 模拟字典树遍历
        int cnt = getnum(ans, n); // 计算以ans为前缀的数量
        if(k >= now + cnt) now += cnt, ans++;
        else ans *= 10, now++;
    }
    return ans == need; // 判断是否命中目标
}
```

#### 3. 作者：shellfish（4星）
**个人心得引用**  
> "特判10的幂次情况，否则测试点9,14,16,34,48会TLE。数本身前后差别如12在123前而1230在123后，需仔细处理边界。"  
**优化技巧**  
- 显式处理幂次特例  
- 利用数值规律快速计算可扩展区间  

---

### 最优关键思路总结
1. **最小位置计算**：按位数分解K的前缀，累加各前缀段的数量（如234→2-1,23-10,234-100）。  
2. **逐位扩展**：在K后补零生成新范围（如1000~2339），每次扩展数量呈10倍增长。  
3. **特判幂次**：若K=10^n，其位置固定为n+1，直接校验M匹配性。  

---

### 相似题目推荐
1. [P1102 A-B数对](https://www.luogu.com.cn/problem/P1102) - 利用哈希或双指针处理有序序列  
2. [P2119 魔法阵](https://www.luogu.com.cn/problem/P2119) - 数学推导与分阶段计数  
3. [P2801 教主的魔法](https://www.luogu.com.cn/problem/P2801) - 分块处理有序区间查询

---
处理用时：46.85秒
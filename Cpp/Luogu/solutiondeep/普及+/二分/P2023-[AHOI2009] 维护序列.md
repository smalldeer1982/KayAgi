# 题目信息

# [AHOI2009] 维护序列

## 题目背景

老师交给小可可一个维护数列的任务，现在小可可希望你来帮他完成。

## 题目描述

有一个长为 $n$ 的数列 $\{a_n\}$，有如下三种操作形式：

1. 格式 `1 t g c`，表示把所有满足 $t\le i\le g$ 的 $a_i$ 改为 $a_i\times c$ ;
2. 格式 `2 t g c` 表示把所有满足 $t\le i\le g$ 的 $a_i$ 改为 $a_i+c$ ;
3. 格式 `3 t g` 询问所有满足 $t\le i\le g$ 的 $a_i$ 的和，由于答案可能很大，你只需输出这个数模 $p$ 的值。

## 说明/提示

#### 样例输入输出 1 解释

- 初始时数列为 $\{1,2,3,4,5,6,7\}$。
- 经过第 $1$ 次操作后，数列为 $\{1,10,15,20,25,6,7\}$。
- 对第 $2$ 次操作，和为 $10+15+20=45$，模 $43$ 的结果是 $2$。
- 经过第 $3$ 次操作后，数列为 $\{1,10,24,29,34,15,16\}$。
- 对第 $4$ 次操作，和为 $1+10+24=35$，模 $43$ 的结果是 $35$。
- 对第 $5$ 次操作，和为 $29+34+15+16=94$，模 $43$ 的结果是$8$。


#### 数据规模与约定

测试数据规模如下表所示：

| 数据点编号 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9,10 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| $n=$ | $10$ | $1000$ | $1000$ | $10000$ | $60000$ | $70000$ | $80000$ | $90000$ | $100000$ |
| $m=$ | $10$ | $1000$ | $1000$ | $10000$ | $60000$ | $70000$ | $80000$ | $90000$ | $100000$ |

对于全部的测试点，保证 $0 \leq p, a_i, c \leq 10^9$，$1 \leq t \leq g \leq n$。

## 样例 #1

### 输入

```
7 43
1 2 3 4 5 6 7
5
1 2 5 5
3 2 4
2 3 7 9
3 1 3
3 4 7```

### 输出

```
2
35
8
```

# AI分析结果



### 综合分析与结论
本题考察线段树处理区间乘加混合操作的能力，核心难点在于**乘法与加法优先级处理**及**lazy标记的正确下传**。所有题解均采用线段树结构，关键点在于维护乘法标记(mul)和加法标记(add)，处理顺序为"先乘后加"。

---

### 精选题解与亮点

#### 1. 作者：GaryZhong（★★★★★）
**核心亮点**：
- 采用结构体指针构建线段树，更易理解树结构
- 清晰定义`pushdown`逻辑，明确标记下传顺序
- 代码模块化，各操作逻辑分离清晰

**关键代码**：
```cpp
void pushdown(Node *p) {
    p->lc->sum = (p->lc->sum * p->mul + p->add * (mid-l+1)) % mod;
    p->rc->sum = (p->rc->sum * p->mul + p->add * (r-mid)) % mod;
    p->lc->mul = (p->lc->mul * p->mul) % mod;
    p->rc->mul = (p->rc->mul * p->mul) % mod;
    p->lc->add = (p->lc->add * p->mul + p->add) % mod;
    p->rc->add = (p->rc->add * p->mul + p->add) % mod;
}
```
**实现思想**：在标记下传时，先处理乘法对子节点加法的影响，保证运算顺序正确。

---

#### 2. 作者：MashPlant（★★★★☆）
**核心亮点**：
- 使用int128优化取模运算
- 位运算优化提高效率
- 采用非递归建树方式

**优化技巧**：
```cpp
#define mod(x) (x)%p
void pushup(LL rt) { sum[rt] = mod(sum[lson] + sum[rson]); }
```
**个人心得**："取模运算频繁时，用宏定义代替函数调用可提升效率，但需注意类型溢出。"

---

#### 3. 作者：zjy111（★★★★☆）
**核心亮点**：
- 详细图解线段树结构
- 分步骤讲解建树、标记下传等核心操作
- 使用位运算优化左右子节点访问

**关键图示**：
线段树结构图示清晰展示节点划分逻辑，帮助理解区间二分原理。

---

### 最优关键思路总结
1. **标记处理顺序**：乘法标记影响加法标记，下传时遵循：
   - 子节点加法标记 = 原加法标记 * 父乘法标记 + 父加法标记
   - 子节点乘法标记 = 原乘法标记 * 父乘法标记

2. **运算优先级**：区间更新时先处理乘法再处理加法，保证数学运算正确性。

3. **取模优化**：对大数取模采用先乘后模、先加后模的分步处理，避免溢出。

---

### 举一反三推荐
1. [P3373 线段树2](https://www.luogu.com.cn/problem/P3373)（本题双倍经验）
2. [P3372 线段树1](https://www.luogu.com.cn/problem/P3372)（纯加法区间操作）
3. [P6242 线段树3](https://www.luogu.com.cn/problem/P6242)（区间最值+历史版本）

---

### 调试经验摘录
1. **标记清零**：某解提到"下传后必须立即清除父标记，否则导致重复计算"。
2. **边界处理**：有解强调"叶子节点不下传标记，避免无效操作"。
3. **数据类型**：多解指出"即使题目说明int范围，中间过程仍可能溢出需用long long"。

---
处理用时：63.77秒
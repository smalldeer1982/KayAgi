# 题目信息

# 神秘数字

## 题目背景

在公元XXXX年，侦探小明收到了组织的神秘信息，在Y市的某个地方有一道神秘的门。小明到达了那个门后，发现门上有一行字：“这个门需要密码才能解锁。”小明左找右找，终于找到了一张字条：“现在给你n个数，请你求出这n个数里面，有多少个连续的数的平均数大于某个给定的数M？注意：这个数可能会很大，请输出这个数对92084931取模的结果。最终的结果即是这个门的密码。”小明苦思冥想了半天，但始终找不到答案。于是他来求助于你。请你帮他解决这个问题。由于小明十分着急，他最多只能等1秒。


## 题目描述

给定n个数，请你帮助小明求出里面有多少个连续的数的平均数大于给定的某个数M.并将这个方案数输出。注意：这个数可能会很大，所以请输出这个数对92084931取模的结果。


## 说明/提示

【样例解释】

①对于这4个数，问题的解有{5}，{4}，{5,4}，{1,5,4}，{5,4,2}共5组。

②对于这4个数，问题的解有{5}，{7}，{2,7}，{7,3}，{5,2,7}，{5,2,7,3}共6组。

【数据规模】

对于10%的数据，1＜n≤10.

对于30%的数据，1＜n≤1000.

对于50%的数据，1＜n≤30000.

对于100%的数据，1＜n≤200000，1＜M≤3000，每个数均为正整数且不大于5000.


## 样例 #1

### 输入

```
4 3
1 5 4 2```

### 输出

```
5```

## 样例 #2

### 输入

```
4 4
5 2 7 3```

### 输出

```
6```

# AI分析结果



### 综合分析与结论  
题目要求统计连续子数组平均数大于给定值的个数，核心思路是将原数组转换为前缀和顺序对问题。各题解主要采用归并排序、树状数组、权值线段树等方法，其中部分题解存在实现细节错误（如归并方向错误）。最优解法为通过离散化前缀和数组后，用树状数组或权值线段树统计顺序对。

---

### 精选题解与评分  

#### 1. 郑翰的题解（★★★★★）  
**关键亮点**  
- 使用树状数组高效统计顺序对，代码简洁清晰。  
- 正确处理离散化与重复元素，逻辑严谨。  
**核心代码**  
```cpp
int main(){
    scanf("%d%d",&n,&m);
    c[c[0]=1]=0;
    for(int i=1;i<=n;i++){
        int x; scanf("%d",&x);
        sum[i]=sum[i-1]+x-m; 
        c[++c[0]]=sum[i];
    }
    sort(c+1,c+1+c[0]);
    c[0]=unique(c+1,c+1+c[0])-(c+1); 
    Updata(_find(sum[0]));
    for(int i=1;i<=n;i++){
        ans=(ans+Query(_find(sum[i])-1))%MOD;
        Updata(_find(sum[i]));
    }
    printf("%d\n",ans);
    return 0;
}
```
**实现思想**  
将前缀和数组离散化后，用树状数组维护已插入元素，每次查询当前元素之前的较小值数量，累加得到答案。

#### 2. _edge_的题解（★★★★）  
**关键亮点**  
- 归并排序统计顺序对，时间复杂度稳定。  
- 合并时巧妙统计右侧剩余元素，正确性保证。  
**核心代码**  
```cpp
void merge(int l,int mid,int r){
    int p1=l,p2=mid+1,k=l-1;
    while(p1<=mid && p2<=r){
        if(sum[p1]<sum[p2]){
            ans += r - p2 +1; // 统计右侧剩余元素
            temp[++k] = sum[p1++];
        }else{
            temp[++k] = sum[p2++];
        }
    }
    // 合并剩余元素...
}
```
**实现思想**  
归并排序过程中，当左半元素小于右半元素时，右半剩余元素均比当前左元素大，直接累加该段长度。

#### 3. Zachary_Cloud的题解（★★★★）  
**关键亮点**  
- 权值线段树动态维护前缀和大小关系。  
- 离散化处理巧妙，支持负数统计。  
**核心代码**  
```cpp
inline ll query(ll rt, ll l, ll r, ll e) {
    if (l > e) return 0;
    if (r <= e) return tr[rt];
    return query(ls, l, mid, e) + query(rs, mid + 1, r, e);
}
// 调用时查询比当前值小的数量
ans += query(1,1,size, lower_bound(...)-1);
```
**实现思想**  
离散化后通过权值线段树维护已插入元素，每次查询比当前前缀和小的元素数量。

---

### 关键思路总结  
1. **问题转换**：将每个数减去平均值，转化为前缀和顺序对问题。  
2. **离散化处理**：处理负数和大范围前缀和，压缩至可处理范围。  
3. **高效统计**：树状数组/线段树动态维护前缀关系，或归并排序分治统计。  

---

### 拓展与推荐题目  
1. **逆序对基础**：[P1908 逆序对](https://www.luogu.com.cn/problem/P1908)  
2. **类似问题变种**：[P2717 寒假作业](https://www.luogu.com.cn/problem/P2717)  
3. **序列统计技巧**：[P5149 会议座位](https://www.luogu.com.cn/problem/P5149)  

---

### 个人心得摘录  
- **SCKer**：注意树状数组处理重复值时需额外计数。  
- **waOooo**：顺序对与逆序对方向易混淆，需仔细验证。  
- **Light_az**：归并时错误累加左半剩余元素，应改为右侧剩余元素。

---
处理用时：190.10秒
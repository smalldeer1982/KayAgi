# 题目信息

# [USACO16DEC] Moocast G

## 题目描述

Farmer John 的 $N$ 头奶牛（$1 \leq N \leq 1000$）希望组织一个紧急的“哞播”系统，用于在它们之间广播重要消息。

为了避免在长距离上互相哞叫，奶牛们决定为自己配备对讲机，每头奶牛一个。这些对讲机每个都有一个有限的传输半径，但奶牛们可以通过多次跳跃的路径中继消息，因此并非每头奶牛都需要能够直接与其他每头奶牛通信。

奶牛们需要决定在对讲机上花费多少钱。如果它们花费 $X$，每头奶牛将获得一个能够传输到 $\sqrt{X}$ 距离的对讲机。也就是说，两头奶牛之间的平方距离必须不超过 $X$，它们才能通信。

请帮助奶牛们确定 $X$ 的最小整数值，使得从任何一头奶牛发出的广播最终能够到达其他所有奶牛。

## 样例 #1

### 输入

```
4
1 3
5 4
7 2
6 1```

### 输出

```
17
```

# AI分析结果



### 综合分析
本题核心为求连通所有点的最小广播半径，等价于求连通图中的最大边权最小值。各题解主要采用**最小生成树（MST）** 或 **二分答案+连通性检查** 两种思路。MST解法中，答案即为生成树中的最长边；二分法通过枚举X验证图的连通性。MST在时间和代码复杂度上更优。

---

### 精选题解与评分

#### 1. hht2005 的 Prim 解法（★★★★★）
**亮点**：  
- 直接以**距离平方**为边权，避免浮点运算，提升效率与精度。  
- 使用 **Prim 算法**，时间复杂度稳定为 $O(N^2)$，适合稠密图。  
- 代码简洁，维护点到集合的最短距离，动态更新答案。

**核心代码**：
```cpp
int dis[1010], f[1010], ans = 0;
memset(dis, 0x3f, sizeof(dis));
dis[1] = 0;
for (int i = 1; i <= n; ++i) {
    int minj = -1;
    for (int j = 1; j <= n; ++j) // 找最小未访问点
        if (!f[j] && (minj == -1 || dis[j] < dis[minj])) 
            minj = j;
    ans = max(ans, dis[minj]); // 更新最长边
    f[minj] = 1;
    for (int j = 1; j <= n; ++j) // 松弛相邻点
        dis[j] = min(dis[j], (x[j]-x[minj])*(x[j]-x[minj]) + (y[j]-y[minj])*(y[j]-y[minj]));
}
printf("%d", ans);
```

#### 2. 奔波儿霸的 Kruskal 解法（★★★★）
**亮点**：  
- 直观的 **Kruskal 实现**，适合理解MST流程。  
- 预处理所有边并排序，记录合并时的最大边。  
- 需注意浮点精度问题，但代码结构清晰。

**关键代码段**：
```cpp
sort(edges, edges + cnt, cmp); // 按边权排序
double max_edge = 0;
for (int i = 0; i < cnt; ++i) {
    int u = find(edges[i].u), v = find(edges[i].v);
    if (u != v) {
        fa[u] = v;
        max_edge = edges[i].w; // 更新最长边
        if (++merged == n-1) break;
    }
}
printf("%.0lf", max_edge * max_edge); // 平方输出
```

#### 3. __Watcher 的二分答案解法（★★★★）
**亮点**：  
- 二分框架清晰，验证阶段用并查集检查连通性。  
- 避免处理浮点数，直接比较平方距离。  
- 时间复杂度 $O(N^2 \log C)$，适用于更灵活的验证条件。

**代码片段**：
```cpp
bool check(int X) {
    for (int i = 1; i <= n; ++i) fa[i] = i;
    for (int i = 1; i <= n; ++i)
        for (int j = i+1; j <= n; ++j)
            if ((x[i]-x[j])*(x[i]-x[j]) + (y[i]-y[j])*(y[i]-y[j]) <= X)
                unite(i, j); // 合并连通块
    return is_connected(); // 检查是否全连通
}
// 二分主逻辑
int l = 0, r = 1e9;
while (l < r) {
    int mid = (l + r) >> 1;
    if (check(mid)) r = mid;
    else l = mid + 1;
}
printf("%d", l);
```

---

### 关键思路总结
- **最小生成树法**：直接求MST中的最大边权，Prim适合稠密图，Kruskal需处理较多边。  
- **整数运算优化**：用距离平方代替实际距离，避免浮点误差，提升效率。  
- **二分答案通用性**：当问题可转化为“验证某阈值是否可行”时，二分法适用性更广。

---

### 同类题目推荐
1. **P2330 [SCOI2005] 繁忙的都市**  
   - 最小生成树应用，求连通城市的最小改造标准。
2. **P1991 无线通讯网**  
   - 类似广播覆盖，求卫星设备下的最小通信半径。
3. **P1547 Out of Hay**  
   - MST求最长边，与本题解法高度一致。

---
处理用时：64.94秒
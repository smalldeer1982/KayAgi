# 题目信息

# 【模板】二分图最大匹配

## 题目描述

给定一个二分图，其左部点的个数为 $n$，右部点的个数为 $m$，边数为 $e$，求其最大匹配的边数。

左部点从 $1$ 至 $n$ 编号，右部点从 $1$ 至 $m$ 编号。

## 说明/提示

#### 数据规模与约定

对于全部的测试点，保证：
- $1 \leq n, m \leq 500$。
- $1 \leq e \leq 5 \times 10^4$。
- $1 \leq u \leq n$，$1 \leq v \leq m$。

**不保证给出的图没有重边**。


## 样例 #1

### 输入

```
1 1 1
1 1
```

### 输出

```
1```

## 样例 #2

### 输入

```
4 2 7
3 1
1 2
3 2
1 1
4 2
4 1
1 1
```

### 输出

```
2
```

# AI分析结果



### 综合分析与结论

二分图最大匹配的核心算法为匈牙利算法（DFS/BFS实现）与网络流方法（Dinic/ISAP）。各题解主要围绕以下要点展开：

1. **匈牙利算法**：通过递归寻找增广路进行贪心匹配，时间复杂度O(nm)，邻接表实现更优
2. **网络流建模**：将二分图转化为最大流问题，时间复杂度O(n√e)，适合大规模数据
3. **Hopcroft-Carp算法**：BFS+DFS的优化算法，时间复杂度O(√n * e)
4. **代码优化技巧**：邻接表存储、时间戳代替memset、输入过滤等

### 高星题解推荐（≥4★）

#### 1. 一扶苏一（5★）
**亮点**：
- 图示辅助理解匈牙利算法的增广过程
- 提供邻接表实现的标准匈牙利模板
- 补充Dinic算法思路，对比复杂度差异
- 代码简洁规范，含详细注释

**核心代码**：
```cpp
bool dfs(const int u, const int tag) {
  if (vistime[u] == tag) return false;
  vistime[u] = tag;
  for (auto v : e[u]) if ((mch[v] == 0) || dfs(mch[v], tag)) {
    mch[v] = u;
    return true;
  }
  return false;
}
```
**技巧**：使用时间戳vistime代替memset清空数组，将O(m)清空操作优化为O(1)

#### 2. Arcturus1350（4★）
**亮点**：
- 网络流解法，Dinic实现更高效
- 完整建图思路：超级源点→左部→右部→超级汇点
- 适合处理大规模数据（e=1e5级别）

**核心代码**：
```cpp
void dinic() {
    while(bfs()) ans += dfs(s,0x7fffffff);
}
bool bfs() { // 分层图
    memset(dep,0,sizeof(dep));
    queue<int> q; q.push(s); dep[s]=1;
    while(!q.empty()) {
        int u=q.front(); q.pop();
        for(int i=head[u];i;i=e[i].nxt)
            if(e[i].val && !dep[e[i].v]) {
                dep[e[i].v] = dep[u]+1;
                q.push(e[i].v);
            }
    }
    return dep[t];
}
```

#### 3. 奈芙莲（4★）
**亮点**：
- Hopcroft-Carp算法实现，复杂度更优
- BFS预处理分层加速DFS
- 适合需要多次匹配的场景

**核心代码**：
```cpp
bool searchP() {
    queue<int> Q; dis = INF;
    memset(dx,-1,sizeof(dx)); 
    for(int i=0;i<Nx;++i) 
        if(Mx[i] == -1) Q.push(i), dx[i]=0;
    while(!Q.empty()) { // BFS分层
        int u=Q.front(); Q.pop();
        if(dx[u] > dis) break;
        for(auto v:G[u]) {
            if(dy[v]==-1) {
                dy[v]=dx[u]+1;
                if(My[v]==-1) dis=dy[v];
                else dx[My[v]]=dy[v]+1, Q.push(My[v]);
            }
        }
    }
    return dis != INF;
}
```

### 关键技巧总结

1. **邻接表优先**：使用vector或链式前向星存储，避免邻接矩阵的O(n²)空间
2. **时间戳优化**：用递增标记代替memset，将清空操作复杂度从O(n)降为O(1)
3. **网络流建模**：超级源点→左部点（容量1）→原边→右部点→超级汇点（容量1）
4. **输入过滤**：提前排除u>n或v>m的非法边，减少无效处理

### 相似题目推荐

1. P2756 飞行员配对方案问题（二分图匹配方案输出）
2. P2764 最小路径覆盖问题（二分图建模技巧）
3. P4055 棋盘覆盖（网格二分图特殊形态）

### 调试经验摘录

"注意输入的u,v可能超过n/m范围，必须过滤否则RE" —— 多题解提及输入校验的重要性

"DFS版匈牙利用时间戳代替memset，效率提升显著" —— 算法常数优化的关键点

"网络流建图时右部点编号要偏移n，避免与左部点冲突" —— 建模时的常见陷阱

---
处理用时：73.11秒
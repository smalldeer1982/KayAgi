# 题目信息

# 斐波那契

## 题目背景

大样例可在页面底部「附件」中下载。

## 题目描述

小 C 养了一些很可爱的兔子。 有一天，小 C 突然发现兔子们都是严格按照伟大的数学家斐波那契提出的模型来进行 繁衍：一对兔子从出生后第二个月起，每个月刚开始的时候都会产下一对小兔子。我们假定， 在整个过程中兔子不会出现任何意外。

小 C 把兔子按出生顺序，把兔子们从 1 开始标号，并且小 C 的兔子都是 1 号兔子和 1 号兔子的后代。如果某两对兔子是同时出生的，那么小 C 会将父母标号更小的一对优先标 号。

如果我们把这种关系用图画下来，前六个月大概就是这样的：

 
  ![](https://cdn.luogu.com.cn/upload/pic/9806.png) 

其中，一个箭头 $A \to B$ 表示 $A$ 是 $B$ 的祖先，相同的颜色表示同一个月出生的兔子。

为了更细致地了解兔子们是如何繁衍的，小 C 找来了一些兔子，并且向你提出了 $m$ 个问题：她想知道关于每两对兔子 $a_i$ 和 $b_i$，他们的最近公共祖先是谁。你能帮帮小 C 吗？

一对兔子的祖先是这对兔子以及他们父母（如果有的话）的祖先，而最近公共祖先是指 两对兔子所共有的祖先中，离他们的距离之和最近的一对兔子。比如，$5$ 和 $7$ 的最近公共祖 先是 $2,1$ 和 $2$ 的最近公共祖先是 $1,6$ 和 $6$ 的最近公共祖先是 $6$。


## 说明/提示

【数据范围与约定】 子任务会给出部分测试数据的特点。如果你在解决题目中遇到了困难，可以尝试只解决一部分测试数据。 每个测试点的数据规模及特点如下表：

 ![](https://cdn.luogu.com.cn/upload/pic/9807.png) 

特殊性质 $1$：保证 $a_i$, $b_i$ 均为某一个月出生的兔子中标号最大的一对兔子。例如，对 于前六个月，标号最大的兔子分别是 $1, 2, 3, 5, 8, 13$。

特殊性质 $2$：保证 $|a_i-b_i|\le 1$。


## 样例 #1

### 输入

```
5 
1 1 
2 3 
5 7 
7 13 
4 12```

### 输出

```
1 
1 
2 
2 
4 ```

# AI分析结果



### 综合分析与结论
各题解核心思路均基于斐波那契树的特殊性质：**每个节点的父节点是当前节点减去比它小的最大斐波那契数**。通过预处理斐波那契数列后，递归或迭代地将较大数跳转到父节点，直至两数相等。该算法时间复杂度为 $O(m \log \phi N)$，其中 $\phi$ 为黄金分割比，可高效处理 $10^{12}$ 量级数据。

---

### 精选题解与评分

#### 1. 作者：浅色调（⭐⭐⭐⭐⭐）
**关键亮点**：  
- 使用 `lower_bound` 二分优化斐波那契数查找，提升效率  
- 递归实现简洁，代码仅20行  
- 清晰注释与数据范围处理（预处理前60项）

**核心代码**：
```cpp
void find(ll a, ll b) {
    if (a < b) swap(a, b);
    if (a == b) { printf("%lld\n", a); return; }
    int w = lower_bound(c, c + 62, a) - c;
    find(b, a - c[w - 1]);
}
```

#### 2. 作者：吾乃会虎（⭐⭐⭐⭐）
**关键亮点**：  
- 斐波那契进制编码，将问题转化为最长公共前缀匹配  
- 数学归纳法证明规律，提供更深的数学视角  
- 非递归实现，空间优化（仅需存储两个路径）

**核心代码**：
```cpp
for (int i = 59; i > 0; --i) 
    A[i] = a / FBNQ[i], a %= FBNQ[i];
for (int i = 0; i < 60; ++i, ans += FBNQ[i] * A[i])
    if (A[i+1] != B[i+1]) break;
```

#### 3. 作者：Smallbasic（⭐⭐⭐）
**关键亮点**：  
- 循环代替递归，避免栈溢出风险  
- 直接暴力枚举斐波那契数，代码极简  
- 适合初学者理解核心逻辑

**核心代码**：
```cpp
while (n != m) {
    if (n < m) swap(n, m);
    for (int i = 59; i >= 1; --i)
        if (fib[i] < n) { n -= fib[i]; break; }
}
```

---

### 关键技巧总结
1. **斐波那契树性质**：节点与父节点差为斐波那契数，预处理数列后快速跳转。
2. **二分查找优化**：用 `lower_bound` 快速定位最大斐波那契数，时间复杂度降至 $O(\log n)$。
3. **对称处理技巧**：始终处理较大数，保证路径收敛。
4. **数学归纳思维**：通过斐波那契进制编码将问题转化为数位匹配。

---

### 拓展题目推荐
1. **P1306 斐波那契公约数**（斐波那契性质与GCD结合）
2. **P1755 斐波那契数列**（高精度斐波那契计算）
3. **P3398 仓鼠找sugar**（LCA问题变式，树结构分析）

---

### 调试心得摘录
- **long long陷阱**：多篇题解强调必须使用 `long long`，未使用会导致 $>2^{31}$ 数据溢出（如厨师长_阿才）。
- **边界处理**：斐波那契数列初始项定义需一致，如 `f[1]=1, f[2]=1` 或 `f[1]=1, f[2]=2`（见zxf_272题解）。
- **二分细节**：`lower_bound` 返回位置需减1得到最大合法值（浅色调题解中的 `w-1`）。

---
处理用时：55.49秒
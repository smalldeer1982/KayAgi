# 题目信息

# 数颜色

## 题目背景

大样例可在页面底部「附件」中下载。

## 题目描述

小 C 的兔子不是雪白的，而是五彩缤纷的。每只兔子都有一种颜色，不同的兔子可能有 相同的颜色。小 C 把她标号从 1 到 $n$ 的 $n$ 只兔子排成长长的一排，来给他们喂胡萝卜吃。 排列完成后，第 $i$ 只兔子的颜色是 $a_i$。

俗话说得好，“萝卜青菜，各有所爱”。小 C 发现，不同颜色的兔子可能有对胡萝卜的 不同偏好。比如，银色的兔子最喜欢吃金色的胡萝卜，金色的兔子更喜欢吃胡萝卜叶子，而 绿色的兔子却喜欢吃酸一点的胡萝卜……为了满足兔子们的要求，小 C 十分苦恼。所以，为 了使得胡萝卜喂得更加准确，小 C 想知道在区间 $[l_j,r_j]$ 里有多少只颜色为 $c_j$ 的兔子。

不过，因为小 C 的兔子们都十分地活跃，它们不是很愿意待在一个固定的位置；与此同 时，小 C 也在根据她知道的信息来给兔子们调整位置。所以，有时编号为 $x_j$ 和 $x_j+1$ 的两 只兔子会交换位置。  小 C 被这一系列麻烦事给难住了。你能帮帮她吗？


## 说明/提示

【样例 1 说明】

前两个 1 操作和后两个 1 操作对应相同；在第三次的 2 操作后，3 号兔子和 4 号兔子

交换了位置，序列变为 1 2 2 3 3 3。

【数据范围与约定】

子任务会给出部分测试数据的特点。如果你在解决题目中遇到了困难，可以尝试只解 决一部分测试数据。 对于所有测试点，有 $1 \le l_j < r_j \le n,1 \le x_j < n$。 每个测试点的数据规模及特点如下表：

 ![](https://cdn.luogu.com.cn/upload/pic/9808.png) 

特殊性质 1：保证对于所有操作 1，有 $|r_j - l_j| \le 20$ 或 $|r_j - l_j| \le n - 20$。

特殊性质 2：保证不会有两只相同颜色的兔子。


## 样例 #1

### 输入

```
6 5 
1 2 3 2 3 3  
1 1 3 2 
1 4 6 3  
2 3 
1 1 3 2  
1 4 6 3```

### 输出

```
1 
2 
2 
3 
```

# AI分析结果



### 综合分析与结论
题目核心在于高效处理动态颜色区间查询与相邻交换操作。主流解法聚焦于**vector+二分**的组合，利用颜色位置的有序性进行快速查询，通过直接修改位置值处理交换。相比主席树/线段树等数据结构，该方案在时间常数和代码复杂度上更优，是本题的最优解。

---

### 精选题解与评分
#### 1. 作者：「QQ红包」 (⭐⭐⭐⭐⭐)
**关键亮点**：
- 使用`vector<int>`按颜色存储位置，天然有序避免重复排序
- 通过`lower_bound`和`upper_bound`实现O(log n)查询
- 交换操作直接修改vector中的位置值，复杂度O(1)
- 处理了颜色相同时的无效交换优化

**核心代码**：
```cpp
vector<int> g[maxn]; // 存储各颜色位置
// 查询操作
p1 = lower_bound(g[c].begin(), g[c].end(), l);
p2 = upper_bound(g[c].begin(), g[c].end(), r);
ans = p2 - p1; 

// 交换操作（颜色不同时）
swap(g[a[x]][pos_x], g[a[x+1]][pos_x1]);
swap(a[x], a[x+1]);
```

#### 2. 作者：Sweetie_Liu (⭐⭐⭐⭐)
**关键亮点**：
- 明确解释二分边界选择原理（upper_bound减1）
- 强调特判查询结果可能为负数的情况
- 给出三个关键坑点的代码处理示例

**调试心得**：
> "二分的左端点是lower_bound，但右端点必须用upper_bound-1，否则会包含超出区间的元素。实际测试发现若直接使用lower_bound求右界，在区间末元素不存在时会出错。"

#### 3. 作者：Na2PtCl6 (⭐⭐⭐⭐)
**优化技巧**：
- 使用`fwrite`批量输出结果降低IO耗时
- 通过预存字符数组代替逐字符输出
- 处理离散化可能引入的哈希冲突问题

**代码片段**：
```cpp
char res[maxn*10]; // 预存输出结果
void save(int x) { // 递归写入字符数组
    if(x>9) save(x/10);
    res[++cnt] = x%10+48; 
}
// 最终批量输出
fwrite(res+1, 1, cnt, stdout);
```

---

### 关键思路总结
1. **有序容器+二分查询**：利用颜色位置的有序性，通过STL二分函数快速定位区间边界
2. **交换位置修正**：直接修改vector中存储的位置值，而非重建结构，复杂度最优
3. **无效操作剪枝**：在交换相邻相同颜色时直接跳过，减少计算量
4. **IO优化**：大数据量时采用字符数组预存+批量输出

---

### 拓展与相似题目
1. **区间频次扩展**：P1972 [SDOI2009]HH的项链（离线查询+树状数组）
2. **动态维护有序性**：P1908 逆序对（分治/树状数组）
3. **高效二分应用**：P3380 【模板】二逼平衡树（树套树）

---

### 核心代码实现（vector法）
```cpp
#include <vector>
#include <algorithm>
using namespace std;

const int MAXN = 3e5+5;
vector<int> pos[MAXN]; // pos[c]存储颜色c的所有位置
int a[MAXN]; // 原数组

// 查询[l,r]内颜色c的数量
int query(int l, int r, int c) {
    auto &v = pos[c];
    return upper_bound(v.begin(), v.end(), r) 
         - lower_bound(v.begin(), v.end(), l);
}

// 交换x和x+1位置
void swap_pos(int x) {
    if(a[x] == a[x+1]) return;
    
    int c1 = a[x], c2 = a[x+1];
    // 查找并修改vector中的位置
    auto it1 = lower_bound(pos[c1].begin(), pos[c1].end(), x);
    auto it2 = lower_bound(pos[c2].begin(), pos[c2].end(), x+1);
    *it1 = x+1;
    *it2 = x;
    
    swap(a[x], a[x+1]);
}
```

---
处理用时：65.17秒
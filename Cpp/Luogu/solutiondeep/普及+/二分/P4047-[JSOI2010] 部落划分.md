# 题目信息

# [JSOI2010] 部落划分

## 题目描述

聪聪研究发现，荒岛野人总是过着群居的生活，但是，并不是整个荒岛上的所有野人都属于同一个部落，野人们总是拉帮结派形成属于自己的部落，不同的部落之间则经常发生争斗。只是，这一切都成为谜团了——聪聪根本就不知道部落究竟是如何分布的。

不过好消息是，聪聪得到了一份荒岛的地图。地图上标注了 $n$ 个野人居住的地点（可以看作是平面上的坐标）。我们知道，同一个部落的野人总是生活在附近。我们把两个部落的距离，定义为部落中距离最近的那两个居住点的距离。聪聪还获得了一个有意义的信息——这些野人总共被分为了 $k$ 个部落！这真是个好消息。聪聪希望从这些信息里挖掘出所有部落的详细信息。他正在尝试这样一种算法：

对于任意一种部落划分的方法，都能够求出两个部落之间的距离，聪聪希望求出一种部落划分的方法，使靠得最近的两个部落尽可能远离。

例如，下面的左图表示了一个好的划分，而右图则不是。请你编程帮助聪聪解决这个难题。


![](https://cdn.luogu.com.cn/upload/pic/30573.png)

## 说明/提示

#### 数据规模与约定

对于 $100\%$ 的数据，保证 $2 \leq k \leq n \leq 10^3$，$0 \leq  x, y \leq 10^4$。

## 样例 #1

### 输入

```
4 2
0 0
0 1
1 1
1 0
```

### 输出

```
1.00
```

## 样例 #2

### 输入

```
9 3
2 2
2 3
3 2
3 3
3 5
3 6
4 6
6 2
6 3```

### 输出

```
2.00```

# AI分析结果



### 综合分析
本题核心是求划分部落后的最小最大距离，主流解法为**生成树变形**与**二分答案**。生成树思路通过合并最近边直到剩k个部落，取下一有效边为答案；二分答案通过验证距离阈值能否划分k个部落。两种方法均能达到最优解，生成树更适合稠密图，二分答案更易理解。

### 高星题解推荐
---

#### 题解作者：I_am_Accepted（5星）
**关键亮点**：
- 采用 $O(n^2)$ Prim算法，时间最优（36ms）
- 逆向思维，直接生成最小生成树后取第k-1大边
- 代码简洁高效，无冗余结构

**核心思路**：
1. 构建完全图并计算所有点间距
2. 跑Prim生成最小生成树
3. 将生成树的边降序排列，取第k-1条边作为答案

```cpp
void prim() {
    for (int i = 1; i <= n; i++) dis[i] = INF;
    dis[1] = 0;
    for (int i = 1; i <= n; i++) {
        int u = 0;
        for (int j = 1; j <= n; j++) 
            if (!vis[j] && dis[j] < dis[u]) u = j;
        vis[u] = true;
        s[tot++] = dis[u];
        for (int j = 1; j <= n; j++)
            dis[j] = min(dis[j], cal_dist(u, j));
    }
    sort(s + 1, s + tot, greater<double>());
    printf("%.2lf", s[k - 1]);
}
```

---

#### 题解作者：轻尘（4星）
**关键亮点**：
- 经典Kruskal解法，思路直观易理解
- 完整注释与调试记录，适合新手学习
- 明确说明「部落减少时记录下一有效边」

**核心思路**：
1. 暴力建完全图的所有边
2. 按边权排序后合并部落
3. 当部落数减至k时，记录下一条不同部落边

**个人心得**：
> "暴力的做法太朴素...侥幸A过" —— 坦然面对朴素实现，强调算法选择的重要性

---

#### 题解作者：wjyyy（4星）
**关键亮点**：
- 二分答案思路清晰，数学证明完备
- 详细分析两种方法时空复杂度差异
- 实现时保留平方计算优化精度

**核心思路**：
```cpp
bool check(double mid) {
    for (int i=1; i<=n; i++) fa[i] = i;
    for (int i=1; i<=n; i++)
        for (int j=1; j<=n; j++)
            if (dis_sqr(i,j) <= mid*mid)
                merge(i,j); // 合并部落
    return count_set() >= k; // 统计连通块
}
```

---

### 关键技巧总结
1. **生成树变形**：当需要划分k个组时，最小生成树的第n-k+1条边即为解
2. **距离优化**：保留平方计算延迟开根，避免浮点精度损失
3. **并查集压缩**：路径压缩使合并操作接近O(1)
4. **逆向思维**：求最大最小值时，可转化为构造过程中的临界值

### 同类题目推荐
1. [P1991 无线通讯网](https://www.luogu.com.cn/problem/P1991) - 最小生成树变形
2. [P2872 Building Roads](https://www.luogu.com.cn/problem/P2872) - 生成树+已有边处理
3. [P2330 繁忙的都市](https://www.luogu.com.cn/problem/P2330) - 最小生成树极差问题

---
处理用时：57.76秒
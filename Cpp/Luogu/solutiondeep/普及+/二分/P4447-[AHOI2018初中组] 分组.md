# 题目信息

# [AHOI2018初中组] 分组

## 题目描述

小可可的学校信息组总共有 $n$ 个队员，每个人都有一个实力值 $a_i$。现在，一年一度的编程大赛就要到了，小可可的学校获得了若干个参赛名额，教练决定把学校信息组的 $n$ 个队员分成若干个小组去参加这场比赛。

但是每个队员都不会愿意与实力跟自己过于悬殊的队员组队，于是要求分成的每个小组的队员实力值连续，同时，一个队不需要两个实力相同的选手。举个例子：$[1, 2, 3, 4, 5]$ 是合法的分组方案，因为实力值连续；$[1, 2, 3, 5]$ 不是合法的分组方案，因为实力值不连续；$[0, 1, 1, 2]$ 同样不是合法的分组方案，因为出现了两个实力值为 $1$ 的选手。

如果有小组内人数太少，就会因为时间不够而无法获得高分，于是小可可想让你给出一个合法的分组方案，满足所有人都恰好分到一个小组，使得人数最少的组人数最多，输出人数最少的组人数的最大值。

注意：实力值可能是负数，分组的数量没有限制。

## 说明/提示

【样例解释】
分为 $2$ 组，一组的队员实力值是 $\{4, 5, 2, 3\}$，一组是 $\{-4, -3, -5\}$，其中最小的组人数为 $3$，可以发现没有比 $3$ 更优的分法了。

【数据范围】

对于 $100\%$ 的数据满足：$1\leq n\leq 100000$，$|a_i|\leq10^9$。

本题共 $10$ 个测试点，编号为 $1\sim10$，每个测试点额外保证如下：
| 测试点编号 | 数据限制 |
| :-----------: | :-----------: |
| $1\sim2$ | $n\leq 6, 1\leq a_i \leq 100$ |
| $3\sim4$ | $n\leq 1000, 1\leq a_i\leq 10^5$ 且 $a_i$ 互不相同 |
| $5\sim6$ | $n\leq 100000, a_i$ 互不相同 |
| $7\sim8$ | $n\leq 100000, 1\leq a_i \leq10^5$ |
| $9\sim 10$ | $n\leq 100000, -10^9 \leq a_i \leq 10^9$ |

## 样例 #1

### 输入

```
7
4 5 2 3 -4 -3 -5```

### 输出

```
3
```

# AI分析结果



### 综合分析与结论
题目核心是寻找最优分组策略，使得最小组人数最大化。各题解主要采用贪心策略，结合数据结构维护分组连续性。最优解法均围绕排序后维护合法组队列，通过高效查找/更新机制保证时间复杂度为O(n log n)。

---

### 高星题解推荐

#### 1. CherryPockyOvO（★★★★★）
**核心思路**：排序后维护单调队列q，q[i]表示第i组的最大实力值。每次用lower_bound找到可接续的组，优先更新最右侧合法组以维护队列单调性。
**亮点**：
- 巧妙利用二分查找优化分组匹配
- 通过维护单调队列保证各组长度最优
- 代码简洁高效（仅需30行）
**关键代码**：
```cpp
sort(f+1,f+n+1);
for(int i=1;i<=n;i++){
    int pos=lower_bound(q+1,q+top+1,f[i])-q; 
    while(q[pos+1]==f[i]&&pos<top) pos++;
    if(pos>top||q[pos]!=f[i]) // 新建组
    else siz[pos]++,q[pos]++; // 更新组
}
```

#### 2. Wenoide（★★★★☆）
**核心思路**：模拟俄罗斯方块式填装，使用map维护各实力值出现次数，每次从最小值开始构建最长连续链。
**亮点**：
- 创新的图形化思维模型
- 利用map自动排序特性简化处理
- 直观的"画线"终止条件判断
**调试心得**：
"发现终止条件应比较右侧列高度，而非单纯连续判断，通过调整画线规则解决了孤立点问题"

#### 3. xiaoniu142857（★★★★☆）
**核心思路**：离散化后采用尺取法遍历连续块，树状数组维护区间人数变化，动态计算最小组长度。
**亮点**：
- 结合离散化处理大数据范围
- 树状数组实现高效区间修改
- 时间复杂度严格O(n log n)
**关键优化**：
"通过记录断点将序列分割为独立处理块，避免无效遍历，实测72ms成为最优解"

---

### 最优思路提炼
**贪心策略**：排序后，每个元素加入满足条件（实力值连续）且当前长度最短的组  
**数据结构**：使用有序容器（map/priority_queue）或二分查找维护合法组队列  
**关键技巧**：
1. 通过排序保证处理顺序性
2. 维护组的最大实力值而非完整记录
3. 使用lower_bound替代暴力查找
4. 懒标记处理整体增减（xiaoniu解法中的shift）

---

### 举一反三
1. **类似分组策略**：P1090 合并果子（优先队列维护）
2. **连续序列处理**：P3143 离散化+双指针
3. **最值优化问题**：P2212 二分答案验证

---

### 核心代码示例（CherryPockyOvO版）
```cpp
sort(a+1, a+n+1);
int top = 0;
for(int i=1; i<=n; i++) {
    int pos = lower_bound(q+1, q+top+1, a[i]) - q;
    while(pos < top && q[pos+1] == a[i]) pos++;
    
    if(pos > top || q[pos] != a[i]) { // 新建组
        q[++top] = a[i] + 1;
        siz[top] = 1;
    } else { // 更新组
        q[pos]++;
        siz[pos]++;
    }
}
```

---
处理用时：67.03秒
# 题目信息

# [BalticOI 2015] Hacker

## 题目描述

### 题面描述

Byteasar 获得了今年国际黑客奥林匹克竞赛的参赛资格。竞赛的任务之一是与系统操作员竞争。有从 $1$ 到 $n$ 编号的 $n$ 台计算机，以环形连接，即计算机 $i$ 和 $i+1$ 连接（其中 $i = 1,2,\dots,n-1$），特别地，计算机 $n$ 和 $1$ 也连接。

这个任务是黑客和系统操作员之间的游戏：

- Byteasar 先走。之后，操作员和 Byteasar 交替移动。
- Byteasar 的第一步是选择任何一台计算机并对其进行黑客攻击。
- 在他的第一步中，操作员选择任何未被黑客攻击的计算机并对其进行保护。
- 在接下来的所有动作中，Byteasar 要么什么都不做，要么选择任何既没有被黑客攻击也没有受到保护的计算机，并直接链接到任何被黑客攻击的计算机，然后对其进行黑客攻击。
- 在接下来的所有动作中，操作员要么什么都不做，要么选择任何既没有被黑客攻击也没有受到保护的计算机，直接链接到任何受保护的计算机并对其进行保护。
- 一旦两人在接下来的两个动作中都没有做任何事情，游戏就结束了。

在游戏开始时，没有任何一台电脑被黑客攻击或受到保护。

每台计算机 $i$ 都有一个特定的值 $v_i$，该值指定了存储在其上的数据的价值。Byteasar 最终获得的分数就是所有被他攻击的计算机的 $v$ 值之和。

虽然 Byteasar 是一个很好的黑客，但对算法一无所知——这就是为什么他要求你编写一个程序来计算他的最大可能分数，假设操作员按最优策略。

## 样例 #1

### 输入

```
4
7 6 8 4```

### 输出

```
13```

## 样例 #2

### 输入

```
5
1 1 1 1 1```

### 输出

```
3```

# AI分析结果



### 题解综合分析结论

所有题解的核心思路均基于以下观察：当 Byteasar 选择初始点后，操作员会迫使其最终只能选择一个包含该点的特定长度区间，且该区间是所有可能区间中和最小的。因此问题的关键在于对每个位置计算包含它的所有可能区间最小值，再取全局最大值。

各解法的主要区别在于求区间最小值的方式：
1. **线段树/ST表**：预处理区间最值，适合任意查询但常数较大
2. **单调队列**：利用滑动窗口特性达到线性复杂度，效率最优
3. **离线排序+区间覆盖**：通过排序贪心覆盖，实现较复杂

---

### 高星题解推荐

#### 1. 作者：tanghg (⭐⭐⭐⭐⭐)
**核心亮点**：
- 采用断环成链技巧与ST表结合
- 预处理每个区间的和，通过ST表快速查询最小值
- 代码简洁高效（时间复杂度O(n log n)，空间优化良好）

**核心代码**：
```cpp
ll sa=ceil(n*1.0/2);
for(int i=1;i<=2*n;i++) 
    st[i][0]=f[i+sa-1]-f[i-1]; // 预处理区间和
for(int l=1;l<=lg[2*n];l++)
    for(int i=1;i+(1<<l)-1<=2*n;i++)
        st[i][l]=min(st[i][l-1],st[i+(1<<(l-1))][l-1]); // ST表递推
```

#### 2. 作者：MagicalGirl_0d00 (⭐⭐⭐⭐)
**核心亮点**：
- 单调队列维护滑动窗口最小值
- 真正线性时间复杂度（O(n)），适合n≥1e6场景
- 代码短小精悍，无复杂数据结构

**关键实现**：
```cpp
for(int i=1;i<=(n+1)/2-1;i++){ // 初始化窗口
    while(q.size() && sum[q.back()+len-1]-sum[q.back()-1] > sum[i+len-1]-sum[i-1]) 
        q.pop_back();
    q.push_back(i);
}
for(int i=len;i+len-1<=2*n;i++){ // 滑动窗口
    while(q.front()+len-1 < i) q.pop_front();
    ans = max(ans, sum[q.front()+len-1]-sum[q.front()-1]);
}
```

#### 3. 作者：船酱魔王 (⭐⭐⭐)
**独特价值**：
- 提供完整的题意转化证明过程
- 采用离线排序+区间覆盖的独特思路
- 代码中展示了线段树区间覆盖的另类应用

---

### 最优技巧总结

1. **环形问题转化**：将环拆解为2倍长度的链处理（如`a[i+n]=a[i]`）
2. **关键观察**：结果仅与⌈n/2⌉长度的连续区间相关
3. **前缀和优化**：预处理区间和`sum[i] = sum[i-1]+a[i]`
4. **极值查询策略**：
   - 滑动窗口用单调队列（最优时间复杂度）
   - 多查询场景用ST表（预处理后O(1)查询）
5. **逆向思维**：将对手的最优策略转化为求区间最小值问题

---

### 相似题目推荐

1. [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886) - 单调队列模板题
2. [P3512 [POI2010]PIL-Pilots](https://www.luogu.com.cn/problem/P3512) - 双指针维护极值窗口
3. [P3088 [USACO13NOV]Crowded Cows S](https://www.luogu.com.cn/problem/P3088) - 环形结构上的滑动窗口

---

### 题解中的调试心得

作者：_EternalRegrets_  
**踩坑记录**：  
_"在计算环形区间时，j = i + o - 1可能超过n，需要特殊处理为j -= n"_  
→ 验证了断环成链时边界条件的处理重要性

作者：wjr_jok  
**实现技巧**：  
_"将环形区间分为两段处理：i ≤ n 和 i > n 的情况"_  
→ 展示了分情况处理环状区间的典型方法

---
处理用时：53.33秒
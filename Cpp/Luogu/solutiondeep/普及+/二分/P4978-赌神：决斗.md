# 题目信息

# 赌神：决斗

## 题目背景

**赌神 $\mathcal{CYJian}$，他回来了！**


## 题目描述

**$\mathcal{tomoo}$** 决定与 **$\mathcal{CYJian}$** 进行决斗！

已知 **$\mathcal{tomoo}$** 有 $\mathcal{N}$ 张扑克牌，每张扑克牌有一个$\mathcal{RP}$值$\mathcal{A_i}$， **$\mathcal{CYJian}$** 有$\mathcal{M}$张扑克牌，每张扑克牌有一个$\mathcal{RP}$值$\mathcal{B_i}$。

**$\mathcal{CYJian}$** 与 **$\mathcal{tomoo}$** 将会各自从他们的牌里任意取一段**连续区间**的牌决斗，谁的区间内的牌的$\mathcal{RP}$值的和更大，谁就赢了，请你帮忙求出 **$\mathcal{tomoo}$** 赢的概率。

## 说明/提示

### 样例解释
- 样例 $3$：不管怎么抽都是平均，胜率为 $0$
- 样例 $5$：共有 $9$ 种方案，其中 $3$ 次 **tomoo** 会赢，胜率为 $1/3$

### 数据范围
- 对于 $20\%$ 的数据，$0<N,M\le50$
- 对于另外 $20\%$ 的数据，$\sum_{i=1}^NA_i\le10^6,\sum_{j=1}^MB_j\le10^6$
- 对于$100\%$的数据，$0<N,M\le2000,0<A_i,B_i\le10^9$

## 样例 #1

### 输入

```
5 5
1 2 3 4 5
1 3 5 7 9```

### 输出

```
754229067```

## 样例 #2

### 输入

```
10 15
7 8 5 1 2 3 6 5 4 1 
52 10 5 6 3 2 1 4 5 8 7 4 5 6 3```

### 输出

```
181952721```

## 样例 #3

### 输入

```
1 1
5
5```

### 输出

```
0```

## 样例 #4

### 输入

```
5 5
1254125 36521421 25362142 12514221 25362142
857412252 36322411 2236232 1254112 36224125```

### 输出

```
261761853```

## 样例 #5

### 输入

```
2 2
2 4
2 5```

### 输出

```
332748118```

# AI分析结果



### 综合分析与结论

本题核心是统计两个数组的所有连续区间和，并计算其中一方严格大于另一方的概率。所有题解均采用以下步骤：
1. **预处理区间和**：利用前缀和计算所有可能区间的和。
2. **排序优化**：对区间和数组排序后，通过双指针或二分法快速统计符合条件的对数。
3. **模数处理**：使用逆元计算概率模数。

关键优化点在于高效排序与统计方法的选择，主流解法时间复杂度为 $O(n^2 \log n)$，部分通过基数排序优化到 $O(n^2)$。

---

### 高星题解推荐

#### 1. 作者：Hope2075（⭐⭐⭐⭐⭐）
**亮点**：
- 提供双指针与二分两种实现，代码结构清晰。
- 使用基数排序优化至 $O(n^2)$，实测效率最优。
- 内存管理精细（动态数组分配）。

**核心代码**：
```cpp
void sort(long long *beg, long long *end) { // 基数排序实现
    long long* s = new long long[end - beg];
    // ... 基数排序逻辑 ...
}
```

#### 2. 作者：桐间纱路（⭐⭐⭐⭐）
**亮点**：
- 代码简洁易懂，使用标准库排序。
- 详细注释与复杂度分析，适合快速理解。
- 提供暴力解法对比，突出优化思路。

**核心代码**：
```cpp
sort(sa, sb); // 排序后双指针统计
int j = 0;
for (int i : a_sums) {
    while (b_sums[j] < i) j++;
    ans += j;
}
```

#### 3. 作者：Mobius127（⭐⭐⭐⭐）
**亮点**：
- 直接调用标准库排序与二分，代码极简。
- 逆元计算封装清晰，适合模板复用。

**核心代码**：
```cpp
ans += upper_bound(b_sums.begin(), b_sums.end(), a_sum) - b_sums.begin();
```

---

### 关键思路与技巧

1. **前缀和预处理**：快速生成所有区间和。
2. **排序+双指针/二分**：将二维比较降为一维有序数组的线性扫描。
3. **基数排序优化**：针对大范围整数的特殊排序，减少常数时间。
4. **逆元处理模数**：利用费马小定理计算分母的模逆元。

---

### 扩展与同类题目

1. **前缀和+双指针**：[P1102 两数之和](https://www.luogu.com.cn/problem/P1102)
2. **区间和统计**：[P3406 海底高铁](https://www.luogu.com.cn/problem/P3406)
3. **模逆元应用**：[P2613 有理数取余](https://www.luogu.com.cn/problem/P2613)

---

### 题解代码节选

**Hope2075的双指针核心逻辑**：
```cpp
sort(p, p+t1); // 基数排序
sort(q, q+t2);
int i=0, j=0;
while (i < t1) {
    while (p[i] > q[j] && j < t2) j++;
    cnt += j; // 统计所有比p[i]小的q元素
    i++;
}
```

**Mobius127的二分实现**：
```cpp
for (auto a : a_sums) {
    int pos = lower_bound(b_sums.begin(), b_sums.end(), a) - b_sums.begin();
    ans += pos; // 直接累加二分结果
}
```

---

以上解法均体现了高效处理大规模数据比较的核心思想，读者可根据实际场景选择平衡代码复杂度与性能的解决方案。

---
处理用时：61.92秒
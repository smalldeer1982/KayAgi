# 题目信息

# [CSP-S2020] 儒略日

## 题目描述

为了简便计算，天文学家们使用儒略日（Julian day）来表达时间。所谓儒略日，其定义为从**公元前 4713 年 1 月 1 日正午 12 点到此后某一时刻间所经过的天数**，不满一天者用小数表达。若利用这一天文学历法，则每一个时刻都将被均匀的映射到数轴上，从而得以很方便的计算它们的差值。

现在，给定一个不含小数部分的儒略日，请你帮忙计算出该儒略日（一定是某一天的中午 12 点）所对应的公历日期。

我们现行的公历为格里高利历（Gregorian calendar），它是在公元 1582 年由教皇格里高利十三世在原有的儒略历（Julian calendar）的基础上修改得到的（注：儒略历与儒略日并无直接关系）。具体而言，现行的公历日期按照以下规则计算：

1. 公元 1582 年 10 月 15 日（含）以后：适用格里高利历，每年一月 $31$ 天、 二月 $28$ 天或 $29$ 天、三月 $31$ 天、四月 $30$ 天、五月 $31$ 天、六月 $30$ 天、七月 $31$ 天、八月 $31$ 天、九月 $30$ 天、十月 $31$ 天、十一月 $30$ 天、十二月 $31$ 天。其中，闰年的二月为 $29$ 天，平年为 $28$ 天。当年份是 $400$ 的倍数，或日期年份是 $4$ 的倍数但不是 $100$ 的倍数时，该年为闰年。
2. 公元 1582 年 10 月 5 日（含）至 10 月 14 日（含）：不存在，这些日期被删除，该年 10 月 4 日之后为 10 月 15 日。
3. 公元 1582 年 10 月 4 日（含）以前：适用儒略历，每月天数与格里高利历相同，但只要年份是 $4$ 的倍数就是闰年。
4. 尽管儒略历于公元前 45 年才开始实行，且初期经过若干次调整，但今天人类习惯于按照儒略历最终的规则反推一切 1582 年 10 月 4 日之前的时间。注意，**公元零年并不存在**，即公元前 1 年的下一年是公元 1 年。因此公元前 1 年、前 5 年、前 9 年、前 13 年……以此类推的年份应视为闰年。

## 说明/提示

**【数据范围】**

| 测试点编号 | $Q =$ | $r_i \le$ |
|:-:|:-:|:-:|
| $1$ | $1000$ | $365$ |
| $2$ | $1000$ | $10^4$ |
| $3$ | $1000$ | $10^5$ |
| $4$ | $10000$ | $3\times 10^5$ |
| $5$ | $10000$ | $2.5\times 10^6$ |
| $6$ | $10^5$ | $2.5\times 10^6$ |
| $7$ | $10^5$ | $5\times 10^6$ |
| $8$ | $10^5$ | $10^7$ |
| $9$ | $10^5$ | $10^9$ |
| $10$ | $10^5$ | 年份答案不超过 $10^9$ |

## 样例 #1

### 输入

```
3
10
100
1000```

### 输出

```
11 1 4713 BC
10 4 4713 BC
27 9 4711 BC```

## 样例 #2

### 输入

```
3
2000000
3000000
4000000```

### 输出

```
14 9 763
15 8 3501
12 7 6239```

## 样例 #3

### 输入

```
见附件中的 julian/julian3.in```

### 输出

```
见附件中的 julian/julian3.ans```

# AI分析结果



### 综合分析与结论
本题核心难点在于处理不同历法规则（儒略历与格里高利历）、闰年判断变化以及1582年10月缺失日期。高效解法需利用周期性预处理或分阶段优化，避免逐日暴力模拟。关键技巧包括：**周期分段处理、日期跳步优化、闰年规则分类判断**。

---

### 高星题解推荐

#### 1. 题解「已注销」 (★★★★★)
**关键亮点**：
- **周期预处理**：利用格里高利历400年周期（146097天）进行快速年份定位，通过模运算大幅减少计算量。
- **分治思想**：将问题拆分为儒略历与格里高利历两阶段处理，边界清晰。
- **代码简洁**：通过预处理数组直接映射日期，逻辑紧凑高效。

```cpp
const int N=146097; // 预处理400年天数
int y[N],m[N],d[N];  // 存储每日对应的年月日
for(int i=1;i<N;++i){ // 预处理循环
    d[i]=d[i-1]+1;
    if(d[i]>md(y[i-1],m[i-1])) ++m[i],d[i]=1;
    if(m[i]>12) ++y[i],m[i]=1;
}
// 主逻辑快速定位年份
if(n>2299160){ // 格里高利历处理
    n-=2159351; // 调整基准日
    t = n/N*400 + 1200; // 周期跳步
    n %= N;
}
```

#### 2. 题解OMG_wc (★★★★☆)
**关键亮点**：
- **二分年份**：通过二分确定年份，再计算剩余天数，避免逐日枚举。
- **分段闰年判断**：独立函数处理不同历法的闰年规则，逻辑清晰。
- **特殊日期处理**：对1582年10月缺失日期进行显式判断。

```cpp
ll cal(LL x){ // 计算到某年的累计天数
    if(x < 1582) return ...; // 儒略历计算
    else return ...;          // 格里高利历计算
}
// 二分查找年份
int l=-4712, r=1e9;
while(l<r) {
    int mid = (l+r)/2;
    if(cal(mid)>=n) r=mid;
    else l=mid+1;
}
```

#### 3. 题解囧仙 (★★★★☆)
**关键亮点**：
- **分段暴力预处理**：将1600年前日期全量计算存储，后续年份利用400年周期跳步。
- **边界处理优化**：对1582年附近的日期单独处理，避免复杂逻辑污染主流程。

```cpp
pre(); // 预处理到1600年的所有日期
if(r < 2299161) 直接查表;
else {
    r -= 2299161;
    year = 1600 + (r/146097)*400; // 周期跳步
    r %= 146097;
    // 处理剩余天数
}
```

---

### 最优技巧总结
1. **周期跳步**：格里高利历每400年周期固定为146097天，利用模运算快速定位年份。
2. **二分定位年份**：在年份范围较大时，二分法比线性扫描更高效。
3. **分段处理历法**：将日期分为儒略历、过渡期、格里高利历三阶段，分别优化逻辑。
4. **预处理加速**：对高频小范围日期（如前1e7天）全量预处理，大范围日期周期跳步。

---

### 推荐习题
1. [P1015 回文日期](https://www.luogu.com.cn/problem/P1015) - 日期遍历与特征判断
2. [P1059 日期计算](https://www.luogu.com.cn/problem/P1059) - 年月日快速转换
3. [P1202 黑色星期五](https://www.luogu.com.cn/problem/P1202) - 周期日期统计

---
处理用时：66.08秒
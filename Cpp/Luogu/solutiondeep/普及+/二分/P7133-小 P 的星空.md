# 题目信息

# 小 P 的星空

## 题目背景



>星依云渚溅溅，露零玉液涓涓，宝砌哀兰剪剪。碧天如练，光摇北斗阑干。
>
>—— 【元】孟昉《天净沙 · 星依云渚溅溅》

小 P 漫步于星空之下。

“摘下星星送给你，你就是我的全世界”。

“今夜，我不关心人类，我只想你”。

## 题目描述

将星空看作一个平面直角坐标系，小 P 所在的位置为 $(0,0)$，即坐标原点。天上共有 $n$ 颗星星，第 $i$ 颗星星的坐标为 $(x_i,y_i)$。

小 P 最初面向点 $(1,0)$，然后小 P 会进行 $m$ 次原地转动，第 $i$ 次转动后会面向点 $(u_i,v_i)$。

他可以选择逆时针转动或顺时针转动，当面向此次旋转最终将要面向的方向时，此次转动立即停止。

他相信，在转动过程中，越多的星星出现在他正前方，他【数据删除】。

小 P 想知道，每一次转动过程中他最多可以让多少星星出现在他正前方（包括转动初始方向和结束方向正前方看到的星星）。

## 说明/提示

样例1示意图如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/h2t5eu1a.png)

橙色点为星星，绿色点小 P 第一次的转动位置。第一次转动，从 $(1,0)$ 转到 $(-1,1)$。若顺时针转动(蓝色区域，包括边界)，$(1,0)$, $(-2,-1)$，共计 $2$ 颗星星；而逆时针转动(绿色区域，包括边界)，$(1,0)$, $(1,1)$,$(2,2)$,$(-1,2)$，共计 $4$ 颗星星。

第二次转动，从 $(-1,1)$ 转到 $(-1,2)$，逆时针转动，$5$ 颗星星都会在转动过程中出现在小 P 正前方。

![](https://cdn.luogu.com.cn/upload/image_hosting/b22go7at.png)

除测试点 $24$ 和 $25$ 外，其他测试点保证所有坐标的绝对值 $\le 1000$。

对于前 $12$ 个测试点，保证原点到任意星星形成的射线上没有其他星星。

除 $23,25$ 测试点外，对于所有编号为奇数的测试点，保证小 P 初始面向方向和每次转动目标方向上没有任何星星。

除 $22,24$ 测试点外，对于所有编号为偶数的测试点，保证小 P 初始面向方向和每次转动目标方向上至少有一颗星星。

对于 $100\%$ 的数据，保证星星的坐标互不相同，保证坐标不会出现 $(0,0)$，保证不会出现转动初始方向等于结束方向。

样例 $3$ 满足偶数测试点的限制。

## 样例 #1

### 输入

```
5 2
1 0
1 1
2 2
-1 2
-2 -1
-1 1
-1 2```

### 输出

```
4
5```

## 样例 #2

### 输入

```
见下发文件 ex_star2.in```

### 输出

```
见下发文件 ex_star2.out```

## 样例 #3

### 输入

```
见下发文件 ex_star3.in```

### 输出

```
见下发文件 ex_star3.out```

# AI分析结果



### 综合分析与结论
本题核心在于将星星按转动方向极角排序，通过二分查找确定转动覆盖区间。关键难点在于处理极角比较时的精度问题和象限分类。最优解法是采用整数运算的极角排序，避免浮点精度误差，同时合理处理不同象限的比较逻辑。

---

### 高星题解推荐

#### 1. 作者：tuxiaobei ★★★★★  
**关键亮点**  
- 使用整数运算处理极角排序，彻底避免浮点精度问题  
- 通过象限分层比较+斜率交叉相乘比较，实现严格的逆时针排序  
- 预处理时将坐标化归为绝对值形式，简化比较逻辑  
**个人心得**  
"注意处理不同象限的星星的大小关系" —— 作者特别强调象限分层比较的重要性，这对正确排序至关重要  

**核心代码**  
```cpp
struct point {
    int x, y, c;
    bool operator<(const point& p) const {
        if(c != p.c) return c < p.c;
        if(c%2 == 0) return false; // 坐标轴不交换
        if(c == 1 || c ==5) return (ll)x*p.y > (ll)y*p.x; // 一三象限
        else return (ll)x*p.y < (ll)y*p.x; // 二四象限
    }
};
```

#### 2. 作者：麦克斯韦の妖 ★★★★  
**关键亮点**  
- 对出题人解法的详细注释，特别解释象限分类逻辑  
- 明确指出同一坐标轴上的点不需要交换顺序  
- 强调比较斜率时的交叉相乘技巧  

**核心思路**  
```cpp
// 判断象限并化简坐标
Node getPos(Node x) {
    if(x.y==0 && x.x>0) x.pos=0; // x正半轴
    if(x.x>0 && x.y>0) x.pos=1;  // 第一象限
    // ...其他象限处理
    x.x=abs(x.x); x.y=abs(x.y); // 坐标取绝对值
    return x;
}
```

---

### 最优思路与技巧总结
**关键技巧**  
1. **极角排序优化**：将坐标转换为绝对值形式，按象限分层排序  
   - 一、三象限按斜率降序（`x1y2 > x2y1`）  
   - 二、四象限按斜率升序（`x1y2 < x2y1`）  
2. **整数比较**：用叉积代替浮点运算，避免精度问题  
3. **区间计算**：通过`lower_bound`和`upper_bound`确定区间，结合环形特性处理  

**拓展应用**  
- 适用于所有涉及极角排序的几何问题（如凸包、旋转扫描）  
- 叉积比较法可推广到向量方向判断等场景  

---

### 推荐练习题
1. [P1355 三角形的最大面积](https://www.luogu.com.cn/problem/P1355) - 极角排序应用  
2. [P1666 前缀极角](https://www.luogu.com.cn/problem/P1666) - 极角排序变形  
3. [P2742 [USACO5.1]圈奶牛](https://www.luogu.com.cn/problem/P2742) - 凸包极角排序经典题

---
处理用时：47.88秒
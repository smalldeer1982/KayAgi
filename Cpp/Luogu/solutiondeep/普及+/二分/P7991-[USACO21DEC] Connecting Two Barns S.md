# 题目信息

# [USACO21DEC] Connecting Two Barns S

## 题目描述

Farmer John 的农场由 $N$ 块田地（$1 \leq N \leq 10^5$）组成，编号为 $1 \ldots N$。在这些田地之间有 $M$ 条双向道路（$0 \leq M \leq 10^5$），每条道路连接两块田地。

农场有两个牛棚，一个在田地 1 中，另一个在田地 $N$ 中。Farmer John 希望确保有一种方式可以沿着一组道路在两个牛棚之间行走。 他愿意建造至多两条新道路来实现这一目标。由于田地的位置因素，在田地 $i$ 和 $j$ 之间建造新道路的花费是 $(i-j)^2$。

请帮助 Farmer John 求出使得牛棚 $1$ 和 $N$ 可以相互到达所需要的最小花费。

## 说明/提示

【样例解释】

- 第一个子测试用例中，最优的方式是用一条道路连接田地 2 和 3，用一条道路连接田地 3 和 4。
- 第二个子测试用例中，最优的方式是用一条道路连接田地 3 和 4。不需要第二条道路。

【数据范围】

- 测试点 2 满足 $N \le 20$。
- 测试点 3-5 满足 $N \le 10^3$。
- 测试点 6-10 没有额外限制。

## 样例 #1

### 输入

```
2
5 2
1 2
4 5
5 3
1 2
2 3
4 5```

### 输出

```
2
1
```

# AI分析结果



### 综合分析与结论
该题核心在于处理连通块间的最优连接策略，需高效计算两点间的最小代价。题解普遍采用并查集划分连通块，结合排序与二分查找优化距离计算。最优思路为：预处理各连通块的排序点集，通过二分找到最近邻点，并枚举中间连通块组合两种连接方式。时间复杂度可控制在 $O(n \log n)$。

---

### 高星题解亮点

#### 1. 望月Asta（5星）
**关键亮点**：
- 采用分治思想，将问题拆解为单边连接与中间块连接两种情形。
- 通过预处理每个连通块到1和n的最小代价数组（f/g），实现全局最优解的高效计算。
- 代码结构清晰，利用二分查找优化最近邻计算，极大减少冗余运算。

**核心代码思想**：
```cpp
// 预处理各连通块到1和n的代价
for(int i=1; i<=n; ++i){
    int u = find(i);
    if(u != r1) // 计算与1连通块的最小代价
        f[u] = min(f[u], (i-F[pre])²);
    if(u != rn) // 计算与n连通块的最小代价
        g[u] = min(g[u], (i-G[nxt])²);
}
// 最终答案取各连通块f+g的最小值
ans = min(ans, f[u] + g[u]);
```

#### 2. lyt_awa（4.5星）
**关键亮点**：
- 显式处理两种连接场景，通过分离s/e数组提升可读性。
- 采用类似双指针方法维护最近邻点，避免重复排序。
- 代码注释详细，逻辑闭环清晰。

**调试经验**：
作者在题解中提到需注意"连通块代表点的更新时机"，通过显式调用find(i)确保并查集状态正确，避免因路径压缩未完成导致的逻辑错误。

---

### 最优关键思路与技巧
1. **并查集快速划分连通块**：将点划分至不同连通块，便于后续处理。
2. **有序点集+二分查找**：对每个连通块的点排序后，通过二分快速找到最近邻点。
3. **代价预计算**：对每个连通块预先计算到1和n的最小代价，避免重复计算。
4. **中间块枚举策略**：枚举所有可能的中间连通块，组合两边的代价得到全局最优。

---

### 举一反三推荐
1. [P1119 灾后重建](https://www.luogu.com.cn/problem/P1119) - 动态连通性与最短路径结合
2. [P2872 Building Roads](https://www.luogu.com.cn/problem/P2872) - 最小生成树与额外边限制
3. [P2502 [HAOI2006]旅行](https://www.luogu.com.cn/problem/P2502) - 连通块间路径最值问题

---

### 关键代码实现（望月Asta解法核心）
```cpp
void solve() {
    // 并查集初始化与合并
    for(int i=1; i<=n; ++i) fa[i] = i;
    while(m--) merge(u,v);
    
    // 收集1和n的连通块点集
    for(int i=1; i<=n; ++i) {
        if(find(i) == r1) F[++cntF] = i;
        else if(find(i) == rn) G[++cntG] = i;
    }
    
    // 计算每个点所在连通块的f/g值
    for(int i=1; i<=n; ++i) {
        int u = find(i);
        // 在F中二分找最近点更新f[u]
        int pre = upper_bound(F+1, F+cntF+1, i) - F - 1;
        f[u] = min(f[u], (i-F[pre])²);
        // 在G中二分找最近点更新g[u]
        int nxt = upper_bound(G+1, G+cntG+1, i) - G;
        g[u] = min(g[u], (i-G[nxt])²);
    }
    
    // 全局答案取最小值
    ll ans = (n-1ll)*(n-1ll);
    for(int i=1; i<=n; ++i)
        ans = min(ans, f[find(i)] + g[find(i)]);
}
```

---
处理用时：72.87秒
# 题目信息

# 『JROI-5』Autumn

## 题目背景

感谢 @[王熙文](/user/353688) 提供了一种优于标算的做法。

## 题目描述

**本题读入量较大，建议使用较快的读入方式，可以参考 [赛时公告板](https://www.luogu.com.cn/paste/lueudpd5)**


给定 $n$ 个数列，每个数列有 $m$ 个元素，第 $i$ 个数列第 $j$ 个元素为正整数 $a_{i,j}$。

你每次可以选择 $i_1,j_1$ 和 $i_2,j_2$，交换 $a_{i_1,j_1}$ 和 $a_{i_2,j_2}$。你至多可以进行 $x$ 次交换。

定义 $d_i$ 为第 $i$ 个数列中第 $k$ 大的元素。

请最小化 $\max\limits_{i=1}^n \{d_i\}$。（表示 $d_1,d_2,\cdots,d_n$ 中的最大值）

## 说明/提示

对于样例 1，将 $a_{2,5}$ 和 $a_{1,5}$ 交换，可以证明，没有更优策略。
***
对于 $30\%$ 的数据，$x = 10^6,1\leq k\leq m$。

对于另外 $10\%$ 的数据，**所有的数都相等**。

对于另外 $30\%$ 的数据，$1\leq n,m\leq 2\times 10^3,1\leq k\leq m,a_{i,j}\leq 10^6,0\leq x\leq n\times m$。

对于 $100\%$ 的数据，$1\leq n,m\leq 2\times 10^3,1\leq k\leq m,1\leq a_{i,j}\leq 10^{18},0\leq x\leq n\times m$。



## 样例 #1

### 输入

```
5 5
1 2 3 4 5
6 7 8 9 10
1 2 3 4 5
1 2 3 4 5
1 2 3 4 5
2 1```

### 输出

```
8```

## 样例 #2

### 输入

```
5 5
1 2 3 4 5
6 7 8 9 10
1 2 3 4 5
1 2 3 4 5
1 2 3 4 5
2 2```

### 输出

```
7```

## 样例 #3

### 输入

```
见附件```

### 输出

```
见附件```

# AI分析结果



### 综合分析与结论
本题核心是通过交换操作最小化每行第k大值的最大值。主流解法采用二分答案，通过预处理行排序后统计必要交换次数。关键技巧在于将问题转化为对候选值的可行性检查，并利用排序后的行列特性快速统计可交换资源。少数题解尝试贪心策略但需注意正确性证明。

---

### 高评分题解推荐

#### 1. 囧仙（★★★★★）
**关键亮点**  
- 引入二分答案框架，逻辑清晰  
- 利用行列排序预处理优化统计效率  
- 通过黑白染色模型直观展示交换需求  
- 代码实现高效（O(nm log nm)），正确性可靠  
**核心代码思想**  
```cpp
// 预处理所有元素并排序，通过双指针维护交换需求
while(y>0&&W[I[y]][0]>d) q+=(W[I[y]][1]<=k),--y;
if(q>u||q>p) break; ans=d;
```

#### 2. Moya_Rao（★★★★☆）
**关键亮点**  
- 详细解释二分答案的转化思路  
- 清晰定义check函数中的关键统计量  
- 完整代码注释，适合学习参考  
**调试心得**  
> "加上快读就没事啦！不过也要记得开long long哦" —— 强调输入优化与数据范围意识

#### 3. MichaelWong（★★★★☆）
**关键亮点**  
- 创新性使用双优先队列贪心策略  
- 代码简洁易实现（O(x log nm)）  
- 直观理解交换极值的贪心本质  
**核心代码**  
```cpp
// 维护S（前k-1大）和T（剩余元素）的极值交换
while(x--) {
    if(S.top()<T.top()) swap(S.top(), T.top());
    else break;
}
```

---

### 最优关键思路总结
**二分答案 + 行列预处理**  
1. 将每行降序排列，第k大元素位置固定为m-k+1  
2. 二分候选值d，统计所有行中：  
   - 左侧超过d的元素数p（需被换出）  
   - 右侧小于等于d的元素数q（可换入）  
3. 当且仅当p≤q且p≤x时，d为可行解  
**优化技巧**  
- 使用全局排序数组替代逐次二分，减少常数  
- 双指针维护p,q的单调性，实现线性统计  

---

### 拓展训练推荐
1. P1090 合并果子（贪心/优先队列）  
2. P3743 kotori的设备（二分答案应用）  
3. P1182 数列分段（最小化最大值经典题）  

---

### 关键代码实现（以二分法为例）
```cpp
bool check(int mid) {
    long long x = s[mid];
    int need = 0, supply = 0;
    for(int i=1; i<=n; ++i) 
        for(int j=1; j<=m; ++j) {
            if(j <= k_pos && a[i][j] > x) need++;
            if(j > k_pos && a[i][j] <= x) supply++;
        }
    return need <= x && need <= supply;
}
```

---
处理用时：69.06秒
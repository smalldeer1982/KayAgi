# 题目信息

# 「DAOI R1」Flame

## 题目背景

>尝尝天堂里的苹果有什么了不起，我要尝尝地狱里的苹果。

## 题目描述

黑暗里有黑色的火焰，只有目光敏锐的人才可以捕捉到,

借着这点卑微之光,走进地狱深处......

欢迎来到地狱的审判之地。

$ \texttt{hhpq.} $ 将 D 押入了地狱的审判之地，D 必须在业火之城成功生成一座业火监狱之前逃离，所以他想知道还有多少秒时间。

在这座业火之城中，共有 $n$ 个祭坛，共有 $m$ 条可以蔓延火苗的业火之路，且业火之路是双向连通。

已知在这一座业火之城共有 $k$ 个火种已被点燃的业火祭坛，且从第一秒开始，火种将开始从被点燃的业火祭坛向可以蔓延且未被点燃的业火祭坛蔓延。

当祭坛被点燃后，则会瞬间激活，和与之有路的祭坛连接业火圣壁。

当存在一片由业火圣壁构成的封闭图形时，则业火监狱生成成功。

### 简化题意
给出一个 $n$ 个点，$m$ 条边的无向图，每一个点有一个标记，初始有 $k$ 个点的标记为 `1`（将给出这 $k$ 个点的编号），其余的点标记为 `0`。

每一秒，对于每个标记为 `1` 的点，与它**有边相连**的点的标记都会变成 `1`。

求最少需要多少秒，图中标记为 `1` 的点与其相邻的边可以构成一个简单环。

**换言之，求最少多少秒后存在一个由 `1` 构成的集合形成简单环。**

## 说明/提示

### 样例解释

#### 样例1解释

当时间到第一秒时，祭坛 $1$ 的火焰将蔓延到祭坛 $2$ 和 $3$，此时已经构成一个封闭图形了，故答案为 $1$。

#### 样例2解释

可以证明到此时是无法产生简单环的。

### 数据规模

| Subtask | $n\leq$ | $m\leq$ | $k\leq$ | 分值 |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $0$ | $10^6$ | $n-1$ | $10^4$ | $5$ |
| $1$ | $10^6$ | $2\times10^6$ | $1$ | $10$|
| $2$ | $10$ | $45$ | $1$ | $5$ |
| $3$ | $200$ | $500$ | $10$ | $10$ |
| $4$| $2\times 10^3$ | $5\times 10^3$ | $50$ | $10$ |
| $5$ | $5\times10^5$ | $6\times10^5$ | $500$ | $30$ |
| $6$ | $10^6$ | $2\times10^6$ | $10^4$ | $30$ |

### 保证与约定

保证数据无重边和自环；

保证数据给定的图是一张无向连通图。

### 帮助

输入量较大，建议使用较为快速的读入方式。

## 样例 #1

### 输入

```
3 3 1
1 2
2 3
3 1
1
```

### 输出

```
1
```

## 样例 #2

### 输入

```
5 4 2
1 2
2 3
3 4
2 5
1 5
```

### 输出

```
Poor D!
```

## 样例 #3

### 输入

```
15 15 2
2 1
2 3
2 9
5 9
4 5
5 7
6 7
7 8
7 11
11 10
10 9
10 14
14 15
11 12
12 13
4 15
```

### 输出

```
3
```

# AI分析结果



### 综合分析与结论
该题核心在于快速判断火焰扩散过程中形成环的最早时间。最优解法集中在两种思路：
1. **BFS预处理 + 动态并查集合并**：在火焰扩散过程中实时维护连通性，合并时检测环
2. **二分答案 + 并查集判环**：预处理各点感染时间后，二分时间判断是否成环

### 高星题解推荐
#### 1. Augen_stern（⭐⭐⭐⭐⭐）
**核心亮点**：
- 创新性的双向链表删边优化
- 按秩合并并查集保证线性复杂度
- 记忆化剪枝提前终止无效搜索
**关键代码**：
```cpp
// 双向链表删边实现
void erase(int i,int k) {
    edge[edge[i].lnex].rnex=edge[i].rnex;
    if(i!=head[k]) edge[edge[i].rnex].lnex=edge[i].lnex;
    else head[k]=edge[i].lnex;
}

// 动态合并过程
for(int i=head[u]; i; i=edge[i].lnex) {
    int v=edge[i].act;
    if(find(c[x])==find(c[v])) 
        ans=min(ans,dis[y]);
    else merge(c[x],c[v]);
}
```

#### 2. Binary_Lee（⭐⭐⭐⭐）
**核心亮点**：
- 二分答案框架清晰
- 并查集判环逻辑简洁
- 预处理时BFS优化
**关键代码**：
```cpp
bool check(int mid) {
    dsu.init(n);
    for(int i=1;i<=m;i++) 
        if(dis[u[i]]<=mid && dis[v[i]]<=mid)
            if(dsu.query(u[i],v[i])) return true;
            else dsu.merge(u[i],v[i]);
    return false;
}
```

#### 3. ICE__LX（⭐⭐⭐⭐）
**核心亮点**：
- 基于广搜的实时更新策略
- 父节点标记避免反向搜索
- 路径压缩并查集高效合并
**关键代码**：
```cpp
while(!q.empty()) {
    auto [fa,u] = q.front(); q.pop();
    for(int v:G[u]) {
        if(v == fa) continue; // 跳过父节点
        if(dis[v] > dis[u]+1) {
            // 更新距离并合并集合
            fa[find(v)] = find(u);
        } else if(find(u) == find(v)) {
            ans = min(ans, max(dis[u],dis[v]));
        }
    }
}
```

### 关键思路总结
1. **感染时间预处理**：多源BFS计算各点最早感染时间
2. **动态连通性维护**：使用路径压缩+按秩合并的并查集
3. **环检测策略**：合并时检测同祖先，或二分后静态检测

### 相似题目推荐
1. [P1119 灾后重建](https://www.luogu.com.cn/problem/P1119) - 时间轴上的最短路径
2. [P2661 信息传递](https://www.luogu.com.cn/problem/P2661) - 并查集找最小环
3. [P2921 Trick or Treat](https://www.luogu.com.cn/problem/P2921) - 基于广搜的扩散分析

### 心得摘录
1. **双向链表删边**（Augen_stern）："通过静态删边避免重复遍历，将时间复杂度严格控制在O(m)"
2. **二分边界优化**（Binary_Lee）："初始右边界取各点最大感染时间，减少无效二分区间"
3. **父节点标记**（ICE__LX）："记录每个节点的来源父节点，有效避免反向搜索导致的错误合并"

---
处理用时：58.49秒
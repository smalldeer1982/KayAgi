# 题目信息

# [Aya Round 1 H] 破碎的历史

## 题目背景

幻想乡迎来了它的毁灭，幻想的载体也已经遁入了幻想。

所幸的是，幻想乡中的乡民们还侥幸存活着，她们在尝试恢复幻想乡的历史。然而历史之中的大大小小的事情不计其数，人们只能记得起一些大事情罢了。

或许，根据那些重要的事情，可以把次要的事件推导出来呢？

## 题目描述

数轴的正半轴上有 $n$ 个互不相同的被黑白染色的特殊整点，位置从左到右依次为 $p_1,p_2,\cdots,p_n$。维护初始为空的**可重**线段集合 $S$。

$q$ 次操作。操作分若干种，具体格式如下：

- `1 l r`：将所有满足 $l \le x \le y \le r$ 且两端点均为特殊整点的线段 $[x,y]$ 加入 $S$。
- `2 x`：撤回第 $x$ 次操作添加的线段。

在初始时和每次操作后，假设你可以进行任意次（可以是零次）染色。每次从 $S$ 中选出一条线段 $[x,y]$，满足位于点 $x$ 和点 $y$ 的特殊整点均为黑色，然后将所有在线段内的白色特殊整点染黑。试判断是否存在至少一种合法染色方式使得正半轴上的所有特殊整点均被染黑（即，不存在白色特殊整点）。**注意：所有的询问均为「假设」，即各组询问之间独立，不会造成对数轴的实际修改。**


## 说明/提示

### 样例解释

六个特殊点的位置/颜色在数轴正半轴上如图所示。

![](https://cdn.luogu.com.cn/upload/image_hosting/i1hfjrk8.png)

容易发现，并非所有点都是黑点。因此在进行操作前，输出 $\verb!NO!$。

第一次操作后，一共往 $S$ 加入了三条线段：$[5,5],[8,8],[5,8]$（图中省略了端点重叠的线段）。容易发现，此时无法进行任何操作，因此没法将所有点变成黑点。输出 $\verb!NO!$。

![](https://cdn.luogu.com.cn/upload/image_hosting/ayeijyli.png)

第二次操作后，又往 $S$ 中加入了 $20$ 条线段。除去端点重叠的选段，在 $S$ 中如图所示。（以示区别，上一次操作加入的边标成了深蓝色）。

![](https://cdn.luogu.com.cn/upload/image_hosting/icw9ar9m.png)

可以找出一种方案，将图上所有特殊点变成黑点。具体而言，首先选择 $S$ 中 $[1,5]$ 线段（容易发现位于 $1$ 和 $5$ 的特殊点均为黑点，因此可以进行染色），那么可以把位于 $2$ 和 $3$ 的点染色。

![](https://cdn.luogu.com.cn/upload/image_hosting/3k1uvul0.png)

此时又可以选择 $S$ 中 $[3,13]$ 线段（在上一轮操作中，$3$ 号点变为了黑点，因此 $[3,13]$ 符合条件），将点 $8$ 染为黑色。

![](https://cdn.luogu.com.cn/upload/image_hosting/7ebafj63.png)

此时所有点都为黑色，因此输出 $\verb!YES!$。再次强调，询问之间互相独立，且只是询问是否存在染色方案，而不会对特殊整点进行实际上的染色操作。

![](https://cdn.luogu.com.cn/upload/image_hosting/pjqpqvtr.png)

第三个操作撤回了第二个操作往 $S$ 里加入的所有线段。因此退回到了只有第一个操作的情况。不存在一种方案将所有点染黑，因此输出 $\verb!NO!$。

### 数据范围

对于所有数据，$1 \le n,q \le 5 \times 10^5$，$a_i \in \{0,1\}$，$1 \le l< r \le 10^9$，$1 \le p_i \le 10^9$。保证 $p_i$ 单调递增，$2$ 操作撤销的只会是 $1$ 操作，且每个操作最多被撤销一次。


## 样例 #1

### 输入

```
6 3
1 2 3 5 8 13
1 0 0 1 0 1
1 5 10
1 1 15
2 2
```

### 输出

```
No
No
Yes
No```

# AI分析结果

### 综合分析与结论

这道题的核心在于如何高效地维护和查询线段集合，并判断是否可以通过这些线段将所有特殊点染黑。题解中主要采用了线段树来维护区间的覆盖情况，并通过二分查找来确定有效的线段端点。以下是各题解的要点对比：

1. **jjsnam的题解**：
   - **亮点**：详细解释了线段树的构建与更新过程，强调了每次操作后立即输出结果的重要性。通过“撒雪”的比喻形象地解释了区间覆盖的逻辑。
   - **难点**：如何找到最长的“两端黑线段”并进行区间更新。
   - **优化**：使用`lower_bound`和`upper_bound`来快速找到有效线段端点，时间复杂度为$O(n \log n)$。

2. **chen_zhe的题解**：
   - **亮点**：简洁明了地指出了问题的关键——只有最长的“两端黑线段”是有用的，并通过线段树维护区间的最小值来判断是否所有点都被覆盖。
   - **难点**：如何将问题抽象为区间加减操作，并通过线段树维护全局最小值。
   - **优化**：使用线段树维护区间的最小值，并通过二分查找确定有效线段端点。

3. **Micnation_AFO的题解**：
   - **亮点**：详细解释了如何通过二分查找确定有效线段端点，并通过线段树维护区间的覆盖情况。
   - **难点**：如何将问题抽象为区间加减操作，并通过线段树维护全局最小值。
   - **优化**：使用线段树维护区间的最小值，并通过二分查找确定有效线段端点。

### 所选高星题解

#### 1. jjsnam的题解（5星）
- **关键亮点**：详细解释了线段树的构建与更新过程，强调了每次操作后立即输出结果的重要性。通过“撒雪”的比喻形象地解释了区间覆盖的逻辑。
- **个人心得**：作者提到在考试时一度认为题目难度较高，后来发现是忘了每次都输出结果，强调了细节的重要性。

```cpp
void update(int id, int l, int r, int a, int b, int v){
    if (a <= l && r <= b){
        tr[id].mn += v;
        tr[id].lazy += v;
        return;
    }
    pushdown(id);
    if (a <= mid) update(ls, l, mid, a, b, v);
    if (b > mid) update(rs, mid+1, r, a, b, v);
    pushup(id);
}
```

#### 2. chen_zhe的题解（4.5星）
- **关键亮点**：简洁明了地指出了问题的关键——只有最长的“两端黑线段”是有用的，并通过线段树维护区间的最小值来判断是否所有点都被覆盖。
- **优化**：使用线段树维护区间的最小值，并通过二分查找确定有效线段端点。

```cpp
inline void Change(int id,int l,int r,int val){
    if (l<=t[id].l && t[id].r<=r){
        t[id].tag+=val;
        t[id].val+=val;
        return;
    }
    Push_Down(id);
    int mid=(t[id].l+t[id].r)>>1;
    if (r<=mid) Change(id<<1,l,r,val);
    else if (l>mid) Change(id<<1|1,l,r,val);
    else{
        Change(id<<1,l,mid,val);
        Change(id<<1|1,mid+1,r,val);
    }
    Push_Up(id);
}
```

### 最优关键思路与技巧

1. **线段树维护区间覆盖**：通过线段树维护区间的覆盖情况，判断是否所有点都被覆盖。
2. **二分查找确定有效线段端点**：使用`lower_bound`和`upper_bound`快速找到有效线段端点，减少时间复杂度。
3. **区间加减操作**：将问题抽象为区间加减操作，通过线段树维护全局最小值来判断是否所有点都被覆盖。

### 可拓展之处

- **类似题目**：可以扩展到其他需要维护区间覆盖和查询的问题，如区间染色、区间查询等。
- **算法套路**：线段树+二分查找的组合在解决区间问题时非常常见，可以举一反三应用到其他类似问题中。

### 推荐题目

1. [P8463 「REOI-1」深潜的第六兽](https://www.luogu.com.cn/problem/P8463)
2. [P1442 铁球落地](https://www.luogu.com.cn/problem/P1442)
3. [P3372 【模板】线段树 1](https://www.luogu.com.cn/problem/P3372)

---
处理用时：35.46秒
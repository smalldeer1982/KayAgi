# 题目信息

# 「HGOI-1」Build

## 题目背景

一次旅行，$\text{uuku}$ 到了一个奇怪的小镇。

## 题目描述

这个小镇将要和周围的其他小镇一共 $n$ 个小镇，一起修建一个能**连通**这 $n$ 个小镇，有 $m$ 条高速公路的交通网。其中每条高速公路都将会连接**不同的两个小镇**，即不存在一条高速公路的起点和终点相同。

但高速公路的修建费用是很高的，所以镇长们一致决定将共同承担高速公路的费用，所以他们希望修建的**总费用最小**。

而且由于不同小镇的基础设施建设情况不同，所以每个小镇在修建的费用也不同。经过协商，每条高速公路将由其所连接的两个小镇共同施工。每个小镇负责一半路程。为了同时结束整个施工过程，显然将会有小镇同时进行多条道路的施工，而施工的道路数量越多，所需要花费的价钱就越多。

经过计算，每个小镇施工的花费可以用函数表示，及对于小镇 $i$，有三个参数 $a_i$，$b_i$，$c_i$。对于 $i$ 小镇来说在修建其第 $j$ 条高速时，**这条**高速所需要的花费为 $a_ij^2+b_ij+c_i$。

现在，这些镇长想要 $\text{uuku}$ 给他们提供一个满足要求的**建造方案**，使**总价格最小**。

当然，$\text{uuku}$ 将这个问题交给了你。

## 说明/提示

#### 数据范围
本题采用**捆绑测试**，共有 $6$ 个 $\text{subtask}$，最终分数为所有 $\text{subtask}$ 分数之和。
$$
\def\arraystretch{1.5}
\begin{array}{|c|c|c|}\hline
\textbf{Task} & \textbf{Score} & \textbf{特殊限制} \cr\hline
1 & 10 & n,m\le 500  \cr\hline
2 & 20 &  n,m\le 5\times 10^3 \cr\hline
3 & 10 & \text{每个小镇的函数相同}\cr\hline
4 & 20 & a_i=0 \cr\hline
5 & 20 & m=n-1 \cr\hline
6 & 20 & \cr\hline
\end{array}
$$

对于 $100\%$ 的数据，$2\le n \le 2 \times 10^5$， $n-1 \le m \le 10^6$，$0 \le a_i$，$b_i$，$c_i \le 10^6$。

数据保证最小价格在 $\tt{long \ long}$ 范围内。

#### 说明

本题有 $\text{spj}$，价格正确可以获得 $30\%$ 的分数。每个 $\text{subtask}$ 取其中所有数据点得分的最小值。

如果你不会构造方案，也请你再输出最小价格后输出 $m$ 行，每行两个 $[1,n]$ 范围内的整数，防止 $\text{spj}$ 出现错误。

本题已添加 hack 数据，为 $\text{subtask7}$，该 $\text{subtask}$ 不计分数，但会影响是否 $\text{AC}$。

## 样例 #1

### 输入

```
4 4
1 2 3
2 3 4
3 4 5
4 5 6```

### 输出

```
114
1 2
1 2
1 3
3 4```

# AI分析结果

### 综合分析与结论

本题的核心在于如何最小化修建高速公路的总费用，同时满足图的连通性和无自环的条件。题解中主要提出了两种思路：

1. **堆优化贪心算法**：通过堆维护每个小镇修建下一条公路的代价，优先选择代价最小的边，最终通过构造方案保证图的连通性和无自环。
2. **二分查找优化**：通过二分查找确定每个小镇的最大度数，利用二次函数求根公式快速计算每个点的度数，确保总度数达到要求且满足条件。

两种方法各有优劣，堆优化贪心算法思路清晰，代码实现较为直观，但时间复杂度较高；二分查找优化在时间复杂度上有优势，但实现复杂度较高。

### 所选高星题解

#### 题解1：堆优化贪心算法
- **星级**：★★★★☆
- **关键亮点**：
  - 使用堆维护每个小镇的修建代价，优先选择最小代价的边。
  - 通过构造方案保证图的连通性和无自环，思路清晰。
  - 代码实现较为直观，易于理解。
- **个人心得**：
  - 作者提到“每个小镇花费的价钱只与该小镇建了多少条公路有关，与和哪个小镇建的无关”，这一观察简化了问题，使得问题转化为如何分配度数。
  - 通过不断将度数最小的点连向度数最大的点，保证了图的连通性。

**核心代码片段**：
```cpp
priority_queue<pli, vector<pli>, greater<pli>> q;
pli now;

for(int i = 1; i <= n; ++i) q.push(make_pair(v[i].get(), i));

while(du--)
{
    now = q.top(), q.pop();
    ans += now.first;
    if(v[now.second].cnt == m){v[now.second].cnt++;continue;}
    q.push(make_pair(v[now.second].get(), now.second));		
}
```
**核心思想**：使用优先队列（堆）维护每个小镇的修建代价，每次选择代价最小的边进行修建，直到所有边修建完毕。

#### 题解2：二分查找优化
- **星级**：★★★★★
- **关键亮点**：
  - 通过二分查找确定每个小镇的最大度数，利用二次函数求根公式快速计算每个点的度数。
  - 时间复杂度优化到 \(O(n\log V + m)\)，适合大规模数据。
  - 思路新颖，优化程度高。
- **个人心得**：
  - 作者提到“显然会有一个最大值，我们不妨直接二分这个最大值”，这一思路将问题转化为二分查找问题，大大提高了效率。

**核心代码片段**：
```cpp
// 二分查找最大度数
int l = 0, r = 2 * m;
while (l < r) {
    int mid = (l + r + 1) >> 1;
    if (check(mid)) l = mid;
    else r = mid - 1;
}
```
**核心思想**：通过二分查找确定每个小镇的最大度数，利用二次函数求根公式快速计算每个点的度数，确保总度数达到要求且满足条件。

### 最优关键思路或技巧

1. **度数分配与代价计算**：将问题转化为如何分配每个小镇的度数，使得总代价最小。这一思路简化了问题，使得问题更容易处理。
2. **堆优化贪心算法**：通过堆维护每个小镇的修建代价，优先选择最小代价的边，保证了算法的效率。
3. **二分查找优化**：通过二分查找确定每个小镇的最大度数，利用二次函数求根公式快速计算每个点的度数，优化了时间复杂度。

### 可拓展之处

- **类似问题**：类似的问题可以出现在网络设计、资源分配等领域，核心思想是通过优化分配策略来最小化总代价。
- **算法套路**：堆优化贪心算法和二分查找优化是解决此类问题的常用套路，可以推广到其他类似问题中。

### 推荐题目

1. **P3366 【模板】最小生成树**：考察最小生成树的构建，与本题的图连通性要求类似。
2. **P3371 【模板】单源最短路径（弱化版）**：考察最短路径问题，与本题的代价最小化思路相似。
3. **P3388 【模板】割点（割顶）**：考察图的连通性，与本题的图连通性要求相关。

### 总结

本题解通过堆优化贪心算法和二分查找优化两种方法，成功解决了最小化修建高速公路总费用的问题。堆优化贪心算法思路清晰，代码实现直观，适合小规模数据；二分查找优化在时间复杂度上有优势，适合大规模数据。两种方法各有优劣，可以根据实际情况选择使用。

---
处理用时：33.96秒
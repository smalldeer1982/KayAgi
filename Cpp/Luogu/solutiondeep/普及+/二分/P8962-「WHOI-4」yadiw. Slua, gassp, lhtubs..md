# 题目信息

# 「WHOI-4」yadiw. Slua, gassp, lhtubs.

## 题目背景

> If you know at least 3 of these things and you are not red — you are doing it wrong. Stop learning useless algorithms, go and solve some problems, learn how to use binary search.


## 题目描述

小 F 有一个奇妙的数组 $a$，$a$ 中没有重复的元素，长度为 $n$，他使用`std::sort`将他排序了，认为它是有序的，所以他正在使用这样的方法进行二分查找。显然，能否查到只和数列的离散化结果有关，所以你可以直接把 $a$ 看作 $1\sim n$ 的一个排列。

```cpp
int search(int key) {
  int l = 1, r = n;
  while (l <= r) {
    int mid = (l + r) / 2;
    if (a[mid] < key)
      l = mid + 1;
    else if (a[mid] == key)
      return mid;
    else
      r = mid - 1;
  }
  return -1;
}
```

不幸的是，小 W 为了让他戒掉万能头，在`bits/stdc++.h`中写了`#define sort random_shuffle`，这意味着 $a$ 实际是一个随机的排列。

现在，对于所有在 $1$ 到 $N$ 范围内的 $n$，以及所有在 $1$ 到 $n$ 范围内的 $k$，在 $a$ 数列的所有排列中，有几个可以正确地找到第 $k$ 小的元素 $key$（即返回值非 $-1$）？由于答案可能过大，请输出它对给定模数 $p$ 取模的结果。

## 说明/提示

**数据范围**

**本题采用 Subtask 评测。**

- Subtask 1（$10$ pts）：$N=10$，$ p\ge998244352$；
- Subtask 2（$25$ pts）：$N=100$，$p\ge1009$ **且为素数**；
- Subtask 3（$25$ pts）：$N=400$，$p\ge1009$ **且为素数**；
- Subtask 4（$40$ pts）：$N=400$。

对于所有数据，$10\le N\le 400$，$ 2\le p\le998244353$。

## 样例 #1

### 输入

```
998244353 5
```

### 输出

```
1
1 2
4 4 4
12 12 14 18
48 54 60 66 72```

# AI分析结果

### 综合分析与结论

本题的核心在于理解二分查找过程中，数组的排列如何影响查找结果。具体来说，我们需要计算在所有可能的排列中，能够通过二分查找正确找到第 $k$ 小元素的排列数。题解的关键在于通过模拟二分查找过程，确定哪些元素必须小于或大于目标元素，然后通过组合数学计算满足条件的排列数。

### 所选题解

#### 题解1：作者：Register_int (赞：7)  
**星级：4.5星**  
**关键亮点：**
- 通过模拟二分查找过程，确定每个位置 $k$ 的 $mid$ 点的值必须小于或大于 $a_k$，从而计算满足条件的排列数。
- 使用组合数和阶乘预处理，优化了排列数的计算。
- 代码结构清晰，逻辑严谨，且通过枚举顺序优化避免了不必要的复杂度。

**个人心得：**
- 作者提到枚举顺序的重要性，先枚举位置再枚举填什么数，避免了额外的 $\log$ 复杂度。
- 强调了模数不一定是素数，通过递推组合数和阶乘来得到排列数。

**核心代码：**
```cpp
for (int m = 1; m <= n; m++) {
    for (int i = 1; i <= m; i++) ans[i] = 0;
    for (int k = 1, l, r, mid, x, y, t; k <= m; k++) {
        l = 1, r = m, x = y = 0;
        while (l <= r) {
            mid = l + r >> 1;
            if (mid == k) break;
            k < mid ? (r = mid - 1, y++) : (l = mid + 1, x++);
        }
        t = fac[m - x - y - 1] % mod * fac[x] % mod * fac[y] % mod;
        for (int i = x + 1; i <= m - y; i++) {
            ans[i] = (ans[i] + c[i - 1][x] * c[m - i][y] % mod * t % mod) % mod;
        }
    }
    for (int i = 1; i <= m; i++) printf("%lld ", ans[i]); puts("");
}
```

#### 题解2：作者：OIer_Eternity (赞：6)  
**星级：4星**  
**关键亮点：**
- 通过预处理 $cnt_1$ 和 $cnt_2$，优化了二分查找过程中必须小于或大于目标元素的元素个数的计算。
- 使用组合数和阶乘预处理，进一步优化了排列数的计算。
- 代码结构清晰，逻辑严谨，且通过预处理降低了复杂度。

**个人心得：**
- 作者提到通过预处理 $cnt_1$ 和 $cnt_2$，将复杂度从 $O(n^3\log n)$ 降低到 $O(n^3)$，速度提升了一倍。

**核心代码：**
```cpp
for (int i=1;i<=n;i++) // 预处理 cnt1,cnt2
    for (int k=1;k<=i;k++){
        int L=1,R=i;
        while (L<R){
            int Mid=(L+R)>>1;
            if (k==Mid) break;
            if (k<Mid) cnt2[i][k]++,R=Mid-1;
            else cnt1[i][k]++,L=Mid+1;
        }
    }
```

### 最优关键思路与技巧

1. **模拟二分查找过程**：通过模拟二分查找，确定哪些元素必须小于或大于目标元素，从而计算满足条件的排列数。
2. **组合数学与预处理**：通过预处理组合数和阶乘，优化排列数的计算，降低复杂度。
3. **枚举顺序优化**：先枚举位置再枚举填什么数，避免不必要的复杂度。

### 可拓展之处

- **类似算法套路**：这种通过模拟过程确定条件，再通过组合数学计算满足条件的排列数的方法，可以应用于其他需要计算特定排列数的题目。
- **同类型题**：可以考虑类似的二分查找与排列组合结合的题目，如计算满足特定查找条件的排列数。

### 推荐题目

1. **洛谷 P1494 [国家集训队]小Z的袜子**（题号：P1494）：考察组合数学与概率计算。
2. **洛谷 P3807 【模板】卢卡斯定理**（题号：P3807）：考察组合数计算与模数处理。
3. **洛谷 P3383 【模板】线性筛素数**（题号：P3383）：考察素数筛法与预处理。

### 通用建议与扩展思路

- **预处理与优化**：在处理组合数学问题时，预处理阶乘和组合数可以显著降低复杂度。
- **模拟过程**：通过模拟具体过程（如二分查找）来确定条件，再结合数学方法计算满足条件的排列数，是一种有效的解题思路。
- **枚举顺序**：在枚举时，选择合适的顺序可以避免不必要的复杂度，优化算法效率。

---
处理用时：41.98秒
# 题目信息

# [USACO23OPEN] Milk Sum S

## 题目描述

**注意：本题的时间限制为 4 秒，是默认时间限制的 2 倍。**

Farmer John 的 $N$ 头奶牛的产奶量为整数 $a_1, \dots, a_N$。也就是说，第 $i$ 头奶牛每分钟产 $a_i$ 单位的牛奶。

每天早上，Farmer John 会将所有 $N$ 头奶牛连接到谷仓的挤奶机上。他需要依次断开连接，将奶牛送去进行日常锻炼。第一头奶牛在挤奶 1 分钟后被断开连接，第二头奶牛在再挤奶 1 分钟后被断开连接，依此类推。由于第一头奶牛（假设是奶牛 $x$）只在挤奶机上停留了 1 分钟，她总共贡献了 $a_x$ 单位的牛奶。第二头奶牛（假设是奶牛 $y$）在挤奶机上停留了总共 2 分钟，因此贡献了 $2a_y$ 单位的牛奶。第三头奶牛（假设是奶牛 $z$）贡献了 $3a_z$ 单位的牛奶，依此类推。设 $T$ 表示 Farmer John 以最优顺序断开奶牛连接时，可以收集到的最大总牛奶量。

Farmer John 很好奇，如果某些奶牛的产奶量发生变化，$T$ 会如何变化。对于每个由两个整数 $i$ 和 $j$ 指定的 $Q$ 个查询，请计算如果将 $a_i$ 设置为 $j$，新的 $T$ 值会是多少。注意，每个查询都是独立的临时变化，即在考虑下一个查询之前，$a_i$ 会恢复为原始值。

## 说明/提示

对于第一个查询，$a$ 将变为 $[1,1,4,2,6]$，此时 $T = 1 \cdot 1 + 2 \cdot 1 + 3 \cdot 2 + 4 \cdot 4 + 5 \cdot 6 = 55$。

对于第二个查询，$a$ 将变为 $[1,8,4,2,6]$，此时 $T = 1 \cdot 1 + 2 \cdot 2 + 3 \cdot 4 + 4 \cdot 6 + 5 \cdot 8 = 81$。

对于第三个查询，$a$ 将变为 $[1,10,4,5,6]$，此时 $T = 1 \cdot 1 + 2 \cdot 4 + 3 \cdot 5 + 4 \cdot 6 + 5 \cdot 10 = 98$。

$1 \leq N \leq 1.5 \cdot 10^5$，$0 \leq a_i \leq 10^8$，$1 \leq Q \leq 1.5 \cdot 10^5$，$0 \leq j \leq 10^8$。

- 输入 2-4：$N, Q \leq 1000$。
- 输入 5-11：没有额外限制。

## 样例 #1

### 输入

```
5
1 10 4 2 6
3
2 1
2 8
4 5
```

### 输出

```
55
81
98
```

# AI分析结果

### 综合分析与结论

本题的核心在于如何高效处理多个查询，每次查询要求修改数组中的一个元素，并快速计算修改后的最大牛奶量。题解的主要思路是通过排序和前缀和优化，结合二分查找来快速定位修改后的元素位置，从而高效计算新的最大值。

### 所选高星题解

#### 1. 作者：DreamLand_zcb (5星)
- **关键亮点**：
  - 详细图解和分步解释，帮助理解复杂逻辑。
  - 使用 `upper_bound` 确保插入位置的准确性。
  - 通过前缀和优化，减少计算复杂度。
  - 代码清晰，注释详细，易于理解。
- **个人心得**：
  - 强调了 `upper_bound` 和 `lower_bound` 的区别，避免常见错误。
  - 提醒注意 `long long` 的使用，避免溢出问题。

```cpp
ll pos=upper_bound(b+1, b+n+1, y)-b;
ll ans=sum;
ans-=a[x]*P[a[x]];
ans-=s[n]-s[P[a[x]]];
ans+=y*(pos-(pos > P[a[x]]));
ans+=s[n]-s[pos-1];
if(pos <= P[a[x]])	ans-=b[P[a[x]]];
```

#### 2. 作者：Nuyoah_awa (4星)
- **关键亮点**：
  - 将修改操作分为两种情况（改大和改小），分别处理。
  - 通过二分查找快速定位修改后的位置。
  - 使用前缀和优化计算，减少时间复杂度。
- **个人心得**：
  - 强调了二分查找的细节处理，确保准确性。
  - 提醒注意 `long long` 的使用，避免溢出问题。

```cpp
if (x < a[opt].val) {
    int l = 1, r = opt - 1;
    while (l < r) {
        int mid = (l + r) / 2;
        if (a[mid].val >= x) r = mid;
        else l = mid + 1; 
    }
    int value = ans + (s[opt - 1] - s[l - 1]);
    value = value - a[opt].val * opt + x * l;
    cout << value << "\n";
}
```

#### 3. 作者：_Above_the_clouds_ (4星)
- **关键亮点**：
  - 通过二分查找快速定位修改后的位置。
  - 使用前缀和优化计算，减少时间复杂度。
  - 代码简洁，逻辑清晰。
- **个人心得**：
  - 强调了二分查找的细节处理，确保准确性。

```cpp
l=1,r=n;
while(l<=r){
    int mid=(l+r)/2;
    if(a[mid]>y) r=mid-1;
    else l=mid+1;
}
if(p>=l) cout<<sum-tmp[x]*p+l*y+s[p-1]-s[l-1]<<"\n";
else cout<<sum-tmp[x]*p+(l-1)*y-s[l-1]+s[p]<<"\n";
```

### 最优关键思路与技巧

1. **排序与前缀和**：通过排序确保数组有序，利用前缀和快速计算区间和，减少计算复杂度。
2. **二分查找**：通过二分查找快速定位修改后的元素位置，确保每次查询的高效性。
3. **分类讨论**：将修改操作分为改大和改小两种情况，分别处理，简化逻辑。

### 可拓展之处

- **类似问题**：可以应用于其他需要频繁修改数组元素并快速计算某种最优值的问题。
- **算法套路**：排序、前缀和、二分查找的组合可以解决许多类似的查询优化问题。

### 推荐题目

1. [P3374 【模板】树状数组 1](https://www.luogu.com.cn/problem/P3374)
2. [P3368 【模板】树状数组 2](https://www.luogu.com.cn/problem/P3368)
3. [P1908 逆序对](https://www.luogu.com.cn/problem/P1908)

### 个人心得总结

- **调试经历**：强调了 `upper_bound` 和 `lower_bound` 的区别，避免常见错误。
- **踩坑教训**：提醒注意 `long long` 的使用，避免溢出问题。
- **顿悟感想**：通过分类讨论和前缀和优化，可以大幅提升查询效率。

---
处理用时：36.39秒
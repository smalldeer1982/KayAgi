# 题目信息

# pay

## 题目描述

今天是 L 公司发工资的一天。

$n$ 名员工排成一排准备领工资，编号为 $1\sim n$，第 $i$ 名员工有一个期望快乐值 $a_i$。

老板非常扣，在这 $n$ 名员工中只选择了 $m$ 名员工 $b_1,b_2,\cdots,b_m$ 发 $k$ 元工资。

员工们都非常具有同理心，不仅自己获得工资时会增加快乐值，当周围的员工获得工资时自己也会增加快乐值。

具体地，当与一名员工 A 距离为 $d$ 的员工获得了工资，A 的快乐值会增加 $\max(0, k - d)$。特别地，如果 A 本身就获得了工资，A 的快乐值会增加 $k$。

老板希望，你能找到最小的整数 $k$，使得所有员工的快乐值不低于他的期望。

## 说明/提示

**【样例说明】**

样例 $1$ 中，$k=2$ 时，每个人的快乐值分别为 $3,4,4,4,3$，满足要求。

样例 $2$ 中，$k=5$ 时，每个人的快乐值分别为 $5,7,7,7,7$，满足要求。

**【数据范围】**

对于 $10\%$ 的数据，满足 $n=1$。

对于 $30\%$ 的数据，满足 $n\le 300$。

对于 $60\%$ 的数据，满足 $n\le 5000$。

对于另外 $10\%$ 的数据，满足 $m=1$。

对于 $100\%$ 的数据，满足 $1\le m\le n\le 10^6$，$0\le a_i\le 10^9$，$1\le b_i\le n$ 且 $b_i$ 互不相同。

**本题输入量较大，请注意使用合理的输入方式。**

## 样例 #1

### 输入

```
5 5
3 3 3 3 3
1 2 3 4 5```

### 输出

```
2```

## 样例 #2

### 输入

```
5 2
5 2 6 3 1
2 5```

### 输出

```
5```

# AI分析结果

### 综合分析与结论

本题的核心是通过二分查找确定最小的工资值 \( k \)，使得所有员工的快乐值不低于其期望值。难点在于如何高效计算每个员工在给定 \( k \) 下的快乐值。大多数题解采用了二分查找结合差分或前缀和的优化策略，避免了暴力计算的 \( O(n^2) \) 复杂度，将时间复杂度优化到 \( O(n \log n) \) 或 \( O(n \log V) \)。

### 所选高星题解

#### 1. **引领天下 (5星)**
- **关键亮点**：通过队列维护贡献，线性时间内完成对 \( k \) 的检查。思路清晰，代码简洁，优化到位。
- **核心实现思想**：使用队列维护对当前员工有贡献的工资发放员工，通过队列的进出动态更新贡献值。
- **代码片段**：
  ```cpp
  bool check(int k){
      queue<int> q;
      long long sum=0;
      memset(c,0,sizeof(c));
      for(int i=1;i<=n;i++){
          sum-=q.size();
          if(!q.empty()&&i-q.front()>=k)q.pop();
          if(s[i])sum+=k,q.push(i);
          c[i]+=sum;
      }
      while(!q.empty())q.pop();sum=0;
      for(int i=n;i;i--){
          sum-=q.size();
          if(!q.empty()&&q.front()-i>=k)q.pop();
          if(s[i])sum+=k,q.push(i);
          c[i]+=sum;
          if(s[i])c[i]-=k;
      }
      for(int i=1;i<=n;i++)if(c[i]<a[i])return 0;
      return 1;
  }
  ```

#### 2. **Register_int (4.5星)**
- **关键亮点**：通过前缀和与后缀和快速计算每个员工的快乐值，避免了复杂的队列操作，代码可读性高。
- **核心实现思想**：利用前缀和和后缀和计算每个员工左右两侧的贡献，结合二分查找确定最小 \( k \)。
- **代码片段**：
  ```cpp
  bool check(ll x) {
      ll s = 0;
      for (int i = 1, j = 1, k = 0; i <= n; i++) {
          for (s -= k; k > 0 && i - b[j] >= x; k--, j++);
          v[i] && (k++, s += x), t[i] = s;
      }
      s = 0;
      for (int i = n, j = m, k = 0; i; i--) {
          for (s -= k; k > 0 && b[j] - i >= x; k--, j--);
          v[i] && (k++, s += x, t[i] -= x), t[i] += s;
      }
      for (int i = 1; i <= n; i++) if (t[i] < a[i]) return 0; return 1;
  }
  ```

#### 3. **ShwStone (4星)**
- **关键亮点**：通过差分数组优化区间更新操作，思路新颖，代码实现简洁。
- **核心实现思想**：使用二阶差分数组快速计算每个员工的快乐值，避免了复杂的循环操作。
- **代码片段**：
  ```cpp
  bool check(long long x) {
      memset(d, 0, sizeof d);
      for (int i = 1; i <= m; i++) {
          if (b[i] < x) {
              d[1] += x - b[i] + 1;
              d[2] -= x - b[i];
              d[b[i] + 1]--;
          }
          else {
              d[b[i] - x + 1]++;
              d[b[i] + 1]--;
          }
          d[b[i] + 1]--;
          if (b[i] + x <= n) d[b[i] + x + 1]++;
      }
      for (int i = 1; i <= n; i++) d[i] += d[i - 1];
      for (int i = 1; i <= n; i++) d[i] += d[i - 1];
      for (int i = 1; i <= n; i++) {
          if (d[i] < a[i]) return false;
      }
      return true;
  }
  ```

### 最优关键思路与技巧
1. **二分查找**：通过二分查找确定最小 \( k \)，结合单调性优化搜索过程。
2. **差分与前缀和**：通过差分或前缀和快速计算每个员工的快乐值，避免暴力计算。
3. **队列维护贡献**：使用队列动态维护对当前员工有贡献的工资发放员工，优化贡献计算。

### 可拓展之处
- **类似题型**：类似的问题可以扩展到其他区间更新与查询的场景，如区间加等差数列、区间最大值查询等。
- **算法套路**：二分查找结合差分、前缀和等优化技巧，适用于多种区间操作问题。

### 推荐题目
1. **P3372 【模板】线段树 1**：考察区间更新与查询，适合练习差分与前缀和的应用。
2. **P3368 【模板】树状数组 1**：考察树状数组的区间更新与查询，适合进一步理解差分思想。
3. **P1908 逆序对**：考察分治与归并排序，适合练习二分查找与区间操作。

### 个人心得摘录
- **引领天下**：通过队列维护贡献，避免了复杂的循环操作，代码简洁高效。
- **Register_int**：利用前缀和与后缀和快速计算贡献，思路清晰，代码可读性高。
- **ShwStone**：通过二阶差分数组优化区间更新操作，思路新颖，代码实现简洁。

---
处理用时：52.01秒